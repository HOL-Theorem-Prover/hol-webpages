<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: binary_ieee</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "binary_ieee"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "wordsTheory.html"><span class="strong">words</span></a>&nbsp;&nbsp;
    <a href = "transcTheory.html"><span class="strong">transc</span></a>

<h1>Signature</h1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr> <th> Type <th> Arity<tr><td> <span class="strong">float</span> <td> 2
    <tr><td> <span class="strong">float_compare</span> <td> 0
    <tr><td> <span class="strong">float_value</span> <td> 0
    <tr><td> <span class="strong">rounding</span> <td> 0
    <tr>
    <th>
    Constant
    <th>
    Type<tr><td> <span class="strong">EQ</span> <td> :float_compare
    <tr><td> <span class="strong">Float</span> <td> :real -> float_value
    <tr><td> <span class="strong">GT</span> <td> :float_compare
    <tr><td> <span class="strong">Infinity</span> <td> :float_value
    <tr><td> <span class="strong">LT</span> <td> :float_compare
    <tr><td> <span class="strong">NaN</span> <td> :float_value
    <tr><td> <span class="strong">ULP</span> <td> :χ word # τ itself -> real
    <tr><td> <span class="strong">UN</span> <td> :float_compare
    <tr><td>
        <span class="strong">closest</span>
        <td>
        :((α, β) float -> bool) -> real -> (α, β) float
    <tr><td>
        <span class="strong">closest_such</span>
        <td>
        :((α, β) float -> bool) ->
         ((α, β) float -> bool) -> real -> (α, β) float
    <tr><td>
        <span class="strong">exponent_boundary</span>
        <td>
        :(τ, χ) float reln
    <tr><td>
        <span class="strong">float</span>
        <td>
        :word1 -> χ word -> τ word -> (τ, χ) float
    <tr><td>
        <span class="strong">float_CASE</span>
        <td>
        :(τ, χ) float -> (word1 -> χ word -> τ word -> α) -> α
    <tr><td>
        <span class="strong">float_Exponent</span>
        <td>
        :(τ, χ) float -> χ word
    <tr><td>
        <span class="strong">float_Exponent_fupd</span>
        <td>
        :(χ word -> χ word) -> (τ, χ) float -> (τ, χ) float
    <tr><td>
        <span class="strong">float_Sign</span>
        <td>
        :(τ, χ) float -> word1
    <tr><td>
        <span class="strong">float_Sign_fupd</span>
        <td>
        :(word1 -> word1) -> (τ, χ) float -> (τ, χ) float
    <tr><td>
        <span class="strong">float_Significand</span>
        <td>
        :(τ, χ) float -> τ word
    <tr><td>
        <span class="strong">float_Significand_fupd</span>
        <td>
        :(τ word -> τ word) -> (τ, χ) float -> (τ, χ) float
    <tr><td>
        <span class="strong">float_abs</span>
        <td>
        :(τ, χ) float -> (τ, χ) float
    <tr><td>
        <span class="strong">float_add</span>
        <td>
        :rounding -> (τ, χ) float -> (τ, χ) float -> (τ, χ) float
    <tr><td>
        <span class="strong">float_bottom</span>
        <td>
        :(τ # χ) itself -> (τ, χ) float
    <tr><td>
        <span class="strong">float_compare</span>
        <td>
        :(τ, χ) float -> (τ, χ) float -> float_compare
    <tr><td>
        <span class="strong">float_compare2num</span>
        <td>
        :float_compare -> num
    <tr><td>
        <span class="strong">float_compare_CASE</span>
        <td>
        :float_compare -> α -> α -> α -> α -> α
    <tr><td>
        <span class="strong">float_compare_size</span>
        <td>
        :float_compare -> num
    <tr><td>
        <span class="strong">float_div</span>
        <td>
        :rounding -> (τ, χ) float -> (τ, χ) float -> (τ, χ) float
    <tr><td> <span class="strong">float_equal</span> <td> :(τ, χ) float reln
    <tr><td>
        <span class="strong">float_greater_equal</span>
        <td>
        :(τ, χ) float reln
    <tr><td>
        <span class="strong">float_greater_than</span>
        <td>
        :(τ, χ) float reln
    <tr><td>
        <span class="strong">float_is_finite</span>
        <td>
        :(τ, χ) float -> bool
    <tr><td>
        <span class="strong">float_is_infinite</span>
        <td>
        :(τ, χ) float -> bool
    <tr><td>
        <span class="strong">float_is_integral</span>
        <td>
        :(τ, χ) float -> bool
    <tr><td>
        <span class="strong">float_is_nan</span>
        <td>
        :(τ, χ) float -> bool
    <tr><td>
        <span class="strong">float_is_normal</span>
        <td>
        :(τ, χ) float -> bool
    <tr><td>
        <span class="strong">float_is_subnormal</span>
        <td>
        :(τ, χ) float -> bool
    <tr><td>
        <span class="strong">float_is_zero</span>
        <td>
        :(τ, χ) float -> bool
    <tr><td>
        <span class="strong">float_less_equal</span>
        <td>
        :(τ, χ) float reln
    <tr><td>
        <span class="strong">float_less_than</span>
        <td>
        :(τ, χ) float reln
    <tr><td>
        <span class="strong">float_minus_infinity</span>
        <td>
        :(τ # χ) itself -> (τ, χ) float
    <tr><td>
        <span class="strong">float_minus_min</span>
        <td>
        :(τ # χ) itself -> (τ, χ) float
    <tr><td>
        <span class="strong">float_minus_zero</span>
        <td>
        :(τ # χ) itself -> (τ, χ) float
    <tr><td>
        <span class="strong">float_mul</span>
        <td>
        :rounding -> (τ, χ) float -> (τ, χ) float -> (τ, χ) float
    <tr><td>
        <span class="strong">float_mul_add</span>
        <td>
        :rounding ->
         (τ, χ) float -> (τ, χ) float -> (τ, χ) float -> (τ, χ) float
    <tr><td>
        <span class="strong">float_negate</span>
        <td>
        :(τ, χ) float -> (τ, χ) float
    <tr><td>
        <span class="strong">float_plus_infinity</span>
        <td>
        :(τ # χ) itself -> (τ, χ) float
    <tr><td>
        <span class="strong">float_plus_min</span>
        <td>
        :(τ # χ) itself -> (τ, χ) float
    <tr><td>
        <span class="strong">float_plus_zero</span>
        <td>
        :(τ # χ) itself -> (τ, χ) float
    <tr><td>
        <span class="strong">float_round</span>
        <td>
        :rounding -> bool -> real -> (τ, χ) float
    <tr><td>
        <span class="strong">float_round_to_integral</span>
        <td>
        :rounding -> (τ, χ) float -> (τ, χ) float
    <tr><td>
        <span class="strong">float_size</span>
        <td>
        :(τ -> num) -> (χ -> num) -> (τ, χ) float -> num
    <tr><td>
        <span class="strong">float_some_nan</span>
        <td>
        :(τ # χ) itself -> (τ, χ) float
    <tr><td>
        <span class="strong">float_sqrt</span>
        <td>
        :rounding -> (τ, χ) float -> (τ, χ) float
    <tr><td>
        <span class="strong">float_sub</span>
        <td>
        :rounding -> (τ, χ) float -> (τ, χ) float -> (τ, χ) float
    <tr><td>
        <span class="strong">float_to_real</span>
        <td>
        :(τ, χ) float -> real
    <tr><td>
        <span class="strong">float_top</span>
        <td>
        :(τ # χ) itself -> (τ, χ) float
    <tr><td>
        <span class="strong">float_value</span>
        <td>
        :(τ, χ) float -> float_value
    <tr><td>
        <span class="strong">float_value_CASE</span>
        <td>
        :float_value -> (real -> α) -> α -> α -> α
    <tr><td>
        <span class="strong">float_value_size</span>
        <td>
        :float_value -> num
    <tr><td>
        <span class="strong">integral_round</span>
        <td>
        :rounding -> real -> (τ, χ) float
    <tr><td>
        <span class="strong">is_closest</span>
        <td>
        :((α, β) float -> bool) -> real -> (α, β) float -> bool
    <tr><td> <span class="strong">largest</span> <td> :(τ # χ) itself -> real
    <tr><td>
        <span class="strong">num2float_compare</span>
        <td>
        :num -> float_compare
    <tr><td> <span class="strong">num2rounding</span> <td> :num -> rounding
    <tr><td>
        <span class="strong">round</span>
        <td>
        :rounding -> real -> (τ, χ) float
    <tr><td> <span class="strong">roundTiesToEven</span> <td> :rounding
    <tr><td> <span class="strong">roundTowardNegative</span> <td> :rounding
    <tr><td> <span class="strong">roundTowardPositive</span> <td> :rounding
    <tr><td> <span class="strong">roundTowardZero</span> <td> :rounding
    <tr><td> <span class="strong">rounding2num</span> <td> :rounding -> num
    <tr><td>
        <span class="strong">rounding_CASE</span>
        <td>
        :rounding -> α -> α -> α -> α -> α
    <tr><td> <span class="strong">rounding_size</span> <td> :rounding -> num
    <tr><td>
        <span class="strong">threshold</span>
        <td>
        :(τ # χ) itself -> real
    <tr><td> <span class="strong">ulp</span> <td> :(τ # χ) itself -> real

</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">float_TY_DEF</span>
<DD>
<pre>
|- ∃rep.
     TYPE_DEFINITION
       (λa0'.
          ∀'float' .
            (∀a0'.
               (∃a0 a1 a2.
                  a0' =
                  (λa0 a1 a2.
                     ind_type$CONSTR 0 (a0,a1,a2) (λn. ind_type$BOTTOM)) a0 a1
                    a2) ⇒
               'float' a0') ⇒
            'float' a0') rep
</pre>

<DT><span class="strong">float_case_def</span>
<DD>
<pre>
|- ∀a0 a1 a2 f. float_CASE (float a0 a1 a2) f = f a0 a1 a2
</pre>

<DT><span class="strong">float_size_def</span>
<DD>
<pre>
|- ∀f f1 a0 a1 a2. float_size f f1 (float a0 a1 a2) = 1
</pre>

<DT><span class="strong">float_Sign</span>
<DD>
<pre>
|- ∀c c0 c1. (float c c0 c1).Sign = c
</pre>

<DT><span class="strong">float_Exponent</span>
<DD>
<pre>
|- ∀c c0 c1. (float c c0 c1).Exponent = c0
</pre>

<DT><span class="strong">float_Significand</span>
<DD>
<pre>
|- ∀c c0 c1. (float c c0 c1).Significand = c1
</pre>

<DT><span class="strong">float_Sign_fupd</span>
<DD>
<pre>
|- ∀f c c0 c1. float c c0 c1 with Sign updated_by f = float (f c) c0 c1
</pre>

<DT><span class="strong">float_Exponent_fupd</span>
<DD>
<pre>
|- ∀f c c0 c1. float c c0 c1 with Exponent updated_by f = float c (f c0) c1
</pre>

<DT><span class="strong">float_Significand_fupd</span>
<DD>
<pre>
|- ∀f c c0 c1. float c c0 c1 with Significand updated_by f = float c c0 (f c1)
</pre>

<DT><span class="strong">float_value_TY_DEF</span>
<DD>
<pre>
|- ∃rep.
     TYPE_DEFINITION
       (λa0.
          ∀'float_value' .
            (∀a0.
               (∃a. a0 = (λa. ind_type$CONSTR 0 a (λn. ind_type$BOTTOM)) a) ∨
               (a0 = ind_type$CONSTR (SUC 0) ARB (λn. ind_type$BOTTOM)) ∨
               (a0 =
                ind_type$CONSTR (SUC (SUC 0)) ARB (λn. ind_type$BOTTOM)) ⇒
               'float_value' a0) ⇒
            'float_value' a0) rep
</pre>

<DT><span class="strong">float_value_case_def</span>
<DD>
<pre>
|- (∀a f v v1. float_value_CASE (Float a) f v v1 = f a) ∧
   (∀f v v1. float_value_CASE Infinity f v v1 = v) ∧
   ∀f v v1. float_value_CASE NaN f v v1 = v1
</pre>

<DT><span class="strong">float_value_size_def</span>
<DD>
<pre>
|- (∀a. float_value_size (Float a) = 1) ∧ (float_value_size Infinity = 0) ∧
   (float_value_size NaN = 0)
</pre>

<DT><span class="strong">float_to_real_def</span>
<DD>
<pre>
|- ∀x.
     float_to_real x =
     if x.Exponent = 0w then
       -1 pow w2n x.Sign * (2 / 2 pow INT_MAX (:χ)) *
       (&w2n x.Significand / 2 pow dimindex (:τ))
     else
       -1 pow w2n x.Sign * (2 pow w2n x.Exponent / 2 pow INT_MAX (:χ)) *
       (1 + &w2n x.Significand / 2 pow dimindex (:τ))
</pre>

<DT><span class="strong">float_value_def</span>
<DD>
<pre>
|- ∀x.
     float_value x =
     if x.Exponent = UINT_MAXw then
       if x.Significand = 0w then Infinity else NaN
     else Float (float_to_real x)
</pre>

<DT><span class="strong">float_is_nan_def</span>
<DD>
<pre>
|- ∀x. float_is_nan x ⇔ case float_value x of NaN => T | _ => F
</pre>

<DT><span class="strong">float_is_infinite_def</span>
<DD>
<pre>
|- ∀x. float_is_infinite x ⇔ case float_value x of Infinity => T | _ => F
</pre>

<DT><span class="strong">float_is_normal_def</span>
<DD>
<pre>
|- ∀x. float_is_normal x ⇔ x.Exponent ≠ 0w ∧ x.Exponent ≠ UINT_MAXw
</pre>

<DT><span class="strong">float_is_subnormal_def</span>
<DD>
<pre>
|- ∀x. float_is_subnormal x ⇔ (x.Exponent = 0w) ∧ x.Significand ≠ 0w
</pre>

<DT><span class="strong">float_is_zero_def</span>
<DD>
<pre>
|- ∀x. float_is_zero x ⇔ case float_value x of Float r => r = 0 | _ => F
</pre>

<DT><span class="strong">float_is_finite_def</span>
<DD>
<pre>
|- ∀x. float_is_finite x ⇔ case float_value x of Float v1 => T | _ => F
</pre>

<DT><span class="strong">float_is_integral_def</span>
<DD>
<pre>
|- ∀x.
     float_is_integral x ⇔
     case float_value x of Float r => ∃n. abs r = &n | _ => F
</pre>

<DT><span class="strong">float_negate_def</span>
<DD>
<pre>
|- ∀x. float_negate x = x with Sign := ¬x.Sign
</pre>

<DT><span class="strong">float_abs_def</span>
<DD>
<pre>
|- ∀x. float_abs x = x with Sign := 0w
</pre>

<DT><span class="strong">float_plus_infinity_def</span>
<DD>
<pre>
|- float_plus_infinity (:τ # χ) =
   <|Sign := 0w; Exponent := UINT_MAXw; Significand := 0w|>
</pre>

<DT><span class="strong">float_plus_zero_def</span>
<DD>
<pre>
|- float_plus_zero (:τ # χ) =
   <|Sign := 0w; Exponent := 0w; Significand := 0w|>
</pre>

<DT><span class="strong">float_top_def</span>
<DD>
<pre>
|- float_top (:τ # χ) =
   <|Sign := 0w; Exponent := UINT_MAXw − 1w; Significand := UINT_MAXw|>
</pre>

<DT><span class="strong">float_plus_min_def</span>
<DD>
<pre>
|- float_plus_min (:τ # χ) = <|Sign := 0w; Exponent := 0w; Significand := 1w|>
</pre>

<DT><span class="strong">float_minus_infinity_def</span>
<DD>
<pre>
|- float_minus_infinity (:τ # χ) = float_negate (float_plus_infinity (:τ # χ))
</pre>

<DT><span class="strong">float_minus_zero_def</span>
<DD>
<pre>
|- float_minus_zero (:τ # χ) = float_negate (float_plus_zero (:τ # χ))
</pre>

<DT><span class="strong">float_bottom_def</span>
<DD>
<pre>
|- float_bottom (:τ # χ) = float_negate (float_top (:τ # χ))
</pre>

<DT><span class="strong">float_minus_min_def</span>
<DD>
<pre>
|- float_minus_min (:τ # χ) = float_negate (float_plus_min (:τ # χ))
</pre>

<DT><span class="strong">float_some_nan_def</span>
<DD>
<pre>
|- float_some_nan (:τ # χ) = @a. float_is_nan a
</pre>

<DT><span class="strong">rounding_TY_DEF</span>
<DD>
<pre>
|- ∃rep. TYPE_DEFINITION (λn. n < 4) rep
</pre>

<DT><span class="strong">rounding_BIJ</span>
<DD>
<pre>
|- (∀a. num2rounding (rounding2num a) = a) ∧
   ∀r. (λn. n < 4) r ⇔ (rounding2num (num2rounding r) = r)
</pre>

<DT><span class="strong">rounding_size_def</span>
<DD>
<pre>
|- ∀x. rounding_size x = 0
</pre>

<DT><span class="strong">rounding_CASE</span>
<DD>
<pre>
|- ∀x v0 v1 v2 v3.
     (case x of
        roundTiesToEven => v0
      | roundTowardPositive => v1
      | roundTowardNegative => v2
      | roundTowardZero => v3) =
     (λm.
        if m < 1 then v0 else if m < 2 then v1 else if m = 2 then v2 else v3)
       (rounding2num x)
</pre>

<DT><span class="strong">is_closest_def</span>
<DD>
<pre>
|- ∀s x a.
     is_closest s x a ⇔
     a ∈ s ∧ ∀b. b ∈ s ⇒ abs (float_to_real a − x) ≤ abs (float_to_real b − x)
</pre>

<DT><span class="strong">closest_such_def</span>
<DD>
<pre>
|- ∀p s x.
     closest_such p s x =
     @a. is_closest s x a ∧ ∀b. is_closest s x b ∧ p b ⇒ p a
</pre>

<DT><span class="strong">closest_def</span>
<DD>
<pre>
|- closest = closest_such (K T)
</pre>

<DT><span class="strong">largest_def</span>
<DD>
<pre>
|- largest (:τ # χ) =
   2 pow (UINT_MAX (:χ) − 1) / 2 pow INT_MAX (:χ) *
   (2 − inv (2 pow dimindex (:τ)))
</pre>

<DT><span class="strong">threshold_def</span>
<DD>
<pre>
|- threshold (:τ # χ) =
   2 pow (UINT_MAX (:χ) − 1) / 2 pow INT_MAX (:χ) *
   (2 − inv (2 pow SUC (dimindex (:τ))))
</pre>

<DT><span class="strong">ULP_primitive_def</span>
<DD>
<pre>
|- ULP =
   WFREC (@R. WF R)
     (λULP a.
        case a of
          (e,v1) =>
            I
              (2 pow (if e = 0w then 1 else w2n e) /
               2 pow (INT_MAX (:χ) + dimindex (:τ))))
</pre>

<DT><span class="strong">ulp_def</span>
<DD>
<pre>
|- ulp (:τ # χ) = ULP (0w,(:τ))
</pre>

<DT><span class="strong">round_def</span>
<DD>
<pre>
|- ∀mode x.
     round mode x =
     case mode of
       roundTiesToEven =>
         (let t = threshold (:τ # χ)
          in
            if x ≤ -t then float_minus_infinity (:τ # χ)
            else if x ≥ t then float_plus_infinity (:τ # χ)
            else closest_such (λa. ¬word_lsb a.Significand) float_is_finite x)
     | roundTowardPositive =>
         (let t = largest (:τ # χ)
          in
            if x < -t then float_bottom (:τ # χ)
            else if x > t then float_plus_infinity (:τ # χ)
            else closest {a | float_is_finite a ∧ float_to_real a ≥ x} x)
     | roundTowardNegative =>
         (let t = largest (:τ # χ)
          in
            if x < -t then float_minus_infinity (:τ # χ)
            else if x > t then float_top (:τ # χ)
            else closest {a | float_is_finite a ∧ float_to_real a ≤ x} x)
     | roundTowardZero =>
         (let t = largest (:τ # χ)
          in
            if x < -t then float_bottom (:τ # χ)
            else if x > t then float_top (:τ # χ)
            else
              closest {a | float_is_finite a ∧ abs (float_to_real a) ≤ abs x}
                x)
</pre>

<DT><span class="strong">integral_round_def</span>
<DD>
<pre>
|- ∀mode x.
     integral_round mode x =
     case mode of
       roundTiesToEven =>
         (let t = threshold (:τ # χ)
          in
            if x ≤ -t then float_minus_infinity (:τ # χ)
            else if x ≥ t then float_plus_infinity (:τ # χ)
            else
              closest_such (λa. ∃n. EVEN n ∧ (abs (float_to_real a) = &n))
                float_is_integral x)
     | roundTowardPositive =>
         (let t = largest (:τ # χ)
          in
            if x < -t then float_bottom (:τ # χ)
            else if x > t then float_plus_infinity (:τ # χ)
            else closest {a | float_is_integral a ∧ float_to_real a ≥ x} x)
     | roundTowardNegative =>
         (let t = largest (:τ # χ)
          in
            if x < -t then float_minus_infinity (:τ # χ)
            else if x > t then float_top (:τ # χ)
            else closest {a | float_is_integral a ∧ float_to_real a ≤ x} x)
     | roundTowardZero =>
         (let t = largest (:τ # χ)
          in
            if x < -t then float_bottom (:τ # χ)
            else if x > t then float_top (:τ # χ)
            else
              closest
                {a | float_is_integral a ∧ abs (float_to_real a) ≤ abs x} x)
</pre>

<DT><span class="strong">float_round_def</span>
<DD>
<pre>
|- ∀mode toneg r.
     float_round mode toneg r =
     (let x = round mode r
      in
        if float_is_zero x then
          if toneg then float_minus_zero (:τ # χ)
          else float_plus_zero (:τ # χ)
        else x)
</pre>

<DT><span class="strong">float_round_to_integral_def</span>
<DD>
<pre>
|- ∀mode x.
     float_round_to_integral mode x =
     case float_value x of Float r => integral_round mode r | _ => x
</pre>

<DT><span class="strong">float_sqrt_def</span>
<DD>
<pre>
|- ∀mode x.
     float_sqrt mode x =
     if x.Sign = 0w then
       case float_value x of
         Float r => float_round mode (x.Sign = 1w) (sqrt r)
       | Infinity => float_plus_infinity (:τ # χ)
       | NaN => float_some_nan (:τ # χ)
     else float_some_nan (:τ # χ)
</pre>

<DT><span class="strong">float_add_def</span>
<DD>
<pre>
|- ∀mode x y.
     (mode float_add x) y =
     case (float_value x,float_value y) of
       (Float r1,Float r2) =>
         float_round mode
           (if (r1 = 0) ∧ (r2 = 0) ∧ (x.Sign = y.Sign) then x.Sign = 1w
            else (mode = roundTowardNegative)) (r1 + r2)
     | (Float r1,Infinity) => y
     | (Float r1,NaN) => float_some_nan (:τ # χ)
     | (Infinity,Float v7) => x
     | (Infinity,Infinity) =>
         if x.Sign = y.Sign then x else float_some_nan (:τ # χ)
     | (Infinity,NaN) => float_some_nan (:τ # χ)
     | (NaN,v1) => float_some_nan (:τ # χ)
</pre>

<DT><span class="strong">float_sub_def</span>
<DD>
<pre>
|- ∀mode x y.
     (mode float_sub x) y =
     case (float_value x,float_value y) of
       (Float r1,Float r2) =>
         float_round mode
           (if (r1 = 0) ∧ (r2 = 0) ∧ x.Sign ≠ y.Sign then x.Sign = 1w
            else (mode = roundTowardNegative)) (r1 − r2)
     | (Float r1,Infinity) => float_negate y
     | (Float r1,NaN) => float_some_nan (:τ # χ)
     | (Infinity,Float v7) => x
     | (Infinity,Infinity) =>
         if x.Sign = y.Sign then float_some_nan (:τ # χ) else x
     | (Infinity,NaN) => float_some_nan (:τ # χ)
     | (NaN,v1) => float_some_nan (:τ # χ)
</pre>

<DT><span class="strong">float_mul_def</span>
<DD>
<pre>
|- ∀mode x y.
     (mode float_mul x) y =
     case (float_value x,float_value y) of
       (Float r',Float r2) => float_round mode (x.Sign ≠ y.Sign) (r' * r2)
     | (Float 0,Infinity) => float_some_nan (:τ # χ)
     | (Float r',Infinity) =>
         if x.Sign = y.Sign then float_plus_infinity (:τ # χ)
         else float_minus_infinity (:τ # χ)
     | (Float r',NaN) => float_some_nan (:τ # χ)
     | (Infinity,Float 0) => float_some_nan (:τ # χ)
     | (Infinity,Float r) =>
         if x.Sign = y.Sign then float_plus_infinity (:τ # χ)
         else float_minus_infinity (:τ # χ)
     | (Infinity,Infinity) =>
         if x.Sign = y.Sign then float_plus_infinity (:τ # χ)
         else float_minus_infinity (:τ # χ)
     | (Infinity,NaN) => float_some_nan (:τ # χ)
     | (NaN,v1) => float_some_nan (:τ # χ)
</pre>

<DT><span class="strong">float_div_def</span>
<DD>
<pre>
|- ∀mode x y.
     (mode float_div x) y =
     case (float_value x,float_value y) of
       (Float 0,Float 0) => float_some_nan (:τ # χ)
     | (Float r1,Float 0) =>
         if x.Sign = y.Sign then float_plus_infinity (:τ # χ)
         else float_minus_infinity (:τ # χ)
     | (Float r1,Float r2) => float_round mode (x.Sign ≠ y.Sign) (r1 / r2)
     | (Float r1,Infinity) =>
         if x.Sign = y.Sign then float_plus_zero (:τ # χ)
         else float_minus_zero (:τ # χ)
     | (Float r1,NaN) => float_some_nan (:τ # χ)
     | (Infinity,Float v7) =>
         if x.Sign = y.Sign then float_plus_infinity (:τ # χ)
         else float_minus_infinity (:τ # χ)
     | (Infinity,Infinity) => float_some_nan (:τ # χ)
     | (Infinity,NaN) => float_some_nan (:τ # χ)
     | (NaN,v1) => float_some_nan (:τ # χ)
</pre>

<DT><span class="strong">float_mul_add_def</span>
<DD>
<pre>
|- ∀mode x y z.
     float_mul_add mode x y z =
     (let signP = x.Sign ⊕ y.Sign in
      let infP = float_is_infinite x ∨ float_is_infinite y
      in
        if
          float_is_nan x ∨ float_is_nan y ∨ float_is_nan z ∨
          float_is_infinite x ∧ float_is_zero y ∨
          float_is_zero x ∧ float_is_infinite y ∨
          float_is_infinite z ∧ infP ∧ z.Sign ≠ signP
        then
          float_some_nan (:τ # χ)
        else if float_is_infinite z ∧ (z.Sign = 0w) ∨ infP ∧ (signP = 0w) then
          float_plus_infinity (:τ # χ)
        else if float_is_infinite z ∧ (z.Sign = 1w) ∨ infP ∧ (signP = 1w) then
          float_minus_infinity (:τ # χ)
        else if
          float_is_zero z ∧ (float_is_zero x ∨ float_is_zero y) ∧
          (x.Sign = signP)
        then
          if x.Sign = 1w then float_minus_zero (:τ # χ)
          else float_plus_zero (:τ # χ)
        else
          float_round mode (mode = roundTowardNegative)
            (float_to_real z + float_to_real x * float_to_real y))
</pre>

<DT><span class="strong">float_compare_TY_DEF</span>
<DD>
<pre>
|- ∃rep. TYPE_DEFINITION (λn. n < 4) rep
</pre>

<DT><span class="strong">float_compare_BIJ</span>
<DD>
<pre>
|- (∀a. num2float_compare (float_compare2num a) = a) ∧
   ∀r. (λn. n < 4) r ⇔ (float_compare2num (num2float_compare r) = r)
</pre>

<DT><span class="strong">float_compare_size_def</span>
<DD>
<pre>
|- ∀x. float_compare_size x = 0
</pre>

<DT><span class="strong">float_compare_CASE</span>
<DD>
<pre>
|- ∀x v0 v1 v2 v3.
     (case x of LT => v0 | GT => v1 | EQ => v2 | UN => v3) =
     (λm.
        if m < 1 then v0 else if m < 2 then v1 else if m = 2 then v2 else v3)
       (float_compare2num x)
</pre>

<DT><span class="strong">float_compare_def</span>
<DD>
<pre>
|- ∀x y.
     float_compare x y =
     case (float_value x,float_value y) of
       (Float r1,Float r2) =>
         if r1 < r2 then LT else if r1 = r2 then EQ else GT
     | (Float r1,Infinity) => if y.Sign = 1w then GT else LT
     | (Float r1,NaN) => UN
     | (Infinity,Float v7) => if x.Sign = 1w then LT else GT
     | (Infinity,Infinity) =>
         if x.Sign = y.Sign then EQ else if x.Sign = 1w then LT else GT
     | (Infinity,NaN) => UN
     | (NaN,v1) => UN
</pre>

<DT><span class="strong">float_less_than_def</span>
<DD>
<pre>
|- ∀x y. float_less_than x y ⇔ (float_compare x y = LT)
</pre>

<DT><span class="strong">float_less_equal_def</span>
<DD>
<pre>
|- ∀x y.
     float_less_equal x y ⇔
     case float_compare x y of LT => T | GT => F | EQ => T | UN => F
</pre>

<DT><span class="strong">float_greater_than_def</span>
<DD>
<pre>
|- ∀x y. float_greater_than x y ⇔ (float_compare x y = GT)
</pre>

<DT><span class="strong">float_greater_equal_def</span>
<DD>
<pre>
|- ∀x y.
     float_greater_equal x y ⇔
     case float_compare x y of LT => F | GT => T | EQ => T | UN => F
</pre>

<DT><span class="strong">float_equal_def</span>
<DD>
<pre>
|- ∀x y. float_equal x y ⇔ (float_compare x y = EQ)
</pre>

<DT><span class="strong">exponent_boundary_def</span>
<DD>
<pre>
|- ∀y x.
     exponent_boundary y x ⇔
     (x.Sign = y.Sign) ∧ (w2n x.Exponent = w2n y.Exponent + 1) ∧
     x.Exponent ≠ 1w ∧ (y.Significand = -1w) ∧ (x.Significand = 0w)
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">float_accessors</span>
<DD>
<pre>
|- (∀c c0 c1. (float c c0 c1).Sign = c) ∧
   (∀c c0 c1. (float c c0 c1).Exponent = c0) ∧
   ∀c c0 c1. (float c c0 c1).Significand = c1
</pre>

<DT><span class="strong">float_fn_updates</span>
<DD>
<pre>
|- (∀f c c0 c1. float c c0 c1 with Sign updated_by f = float (f c) c0 c1) ∧
   (∀f c c0 c1.
      float c c0 c1 with Exponent updated_by f = float c (f c0) c1) ∧
   ∀f c c0 c1. float c c0 c1 with Significand updated_by f = float c c0 (f c1)
</pre>

<DT><span class="strong">float_accfupds</span>
<DD>
<pre>
|- (∀f0 f. (f with Exponent updated_by f0).Sign = f.Sign) ∧
   (∀f0 f. (f with Significand updated_by f0).Sign = f.Sign) ∧
   (∀f0 f. (f with Sign updated_by f0).Exponent = f.Exponent) ∧
   (∀f0 f. (f with Significand updated_by f0).Exponent = f.Exponent) ∧
   (∀f0 f. (f with Sign updated_by f0).Significand = f.Significand) ∧
   (∀f0 f. (f with Exponent updated_by f0).Significand = f.Significand) ∧
   (∀f0 f. (f with Sign updated_by f0).Sign = f0 f.Sign) ∧
   (∀f0 f. (f with Exponent updated_by f0).Exponent = f0 f.Exponent) ∧
   ∀f0 f. (f with Significand updated_by f0).Significand = f0 f.Significand
</pre>

<DT><span class="strong">float_fupdfupds</span>
<DD>
<pre>
|- (∀g f0 f.
      f with <|Sign updated_by f0; Sign updated_by g|> =
      f with Sign updated_by f0 o g) ∧
   (∀g f0 f.
      f with <|Exponent updated_by f0; Exponent updated_by g|> =
      f with Exponent updated_by f0 o g) ∧
   ∀g f0 f.
     f with <|Significand updated_by f0; Significand updated_by g|> =
     f with Significand updated_by f0 o g
</pre>

<DT><span class="strong">float_fupdfupds_comp</span>
<DD>
<pre>
|- ((∀g f0.
        _ record fupdateSign f0 o  _ record fupdateSign g =
        _ record fupdateSign (f0 o g)) ∧
    ∀h g f0.
       _ record fupdateSign f0 o  _ record fupdateSign g o h =
       _ record fupdateSign (f0 o g) o h) ∧
   ((∀g f0.
        _ record fupdateExponent f0 o  _ record fupdateExponent g =
        _ record fupdateExponent (f0 o g)) ∧
    ∀h g f0.
       _ record fupdateExponent f0 o  _ record fupdateExponent g o h =
       _ record fupdateExponent (f0 o g) o h) ∧
   (∀g f0.
       _ record fupdateSignificand f0 o  _ record fupdateSignificand g =
       _ record fupdateSignificand (f0 o g)) ∧
   ∀h g f0.
      _ record fupdateSignificand f0 o  _ record fupdateSignificand g o h =
      _ record fupdateSignificand (f0 o g) o h
</pre>

<DT><span class="strong">float_fupdcanon</span>
<DD>
<pre>
|- (∀g f0 f.
      f with <|Exponent updated_by f0; Sign updated_by g|> =
      f with <|Sign updated_by g; Exponent updated_by f0|>) ∧
   (∀g f0 f.
      f with <|Significand updated_by f0; Sign updated_by g|> =
      f with <|Sign updated_by g; Significand updated_by f0|>) ∧
   ∀g f0 f.
     f with <|Significand updated_by f0; Exponent updated_by g|> =
     f with <|Exponent updated_by g; Significand updated_by f0|>
</pre>

<DT><span class="strong">float_fupdcanon_comp</span>
<DD>
<pre>
|- ((∀g f0.
        _ record fupdateExponent f0 o  _ record fupdateSign g =
        _ record fupdateSign g o  _ record fupdateExponent f0) ∧
    ∀h g f0.
       _ record fupdateExponent f0 o  _ record fupdateSign g o h =
       _ record fupdateSign g o  _ record fupdateExponent f0 o h) ∧
   ((∀g f0.
        _ record fupdateSignificand f0 o  _ record fupdateSign g =
        _ record fupdateSign g o  _ record fupdateSignificand f0) ∧
    ∀h g f0.
       _ record fupdateSignificand f0 o  _ record fupdateSign g o h =
       _ record fupdateSign g o  _ record fupdateSignificand f0 o h) ∧
   (∀g f0.
       _ record fupdateSignificand f0 o  _ record fupdateExponent g =
       _ record fupdateExponent g o  _ record fupdateSignificand f0) ∧
   ∀h g f0.
      _ record fupdateSignificand f0 o  _ record fupdateExponent g o h =
      _ record fupdateExponent g o  _ record fupdateSignificand f0 o h
</pre>

<DT><span class="strong">float_component_equality</span>
<DD>
<pre>
|- ∀f1 f2.
     (f1 = f2) ⇔
     (f1.Sign = f2.Sign) ∧ (f1.Exponent = f2.Exponent) ∧
     (f1.Significand = f2.Significand)
</pre>

<DT><span class="strong">float_updates_eq_literal</span>
<DD>
<pre>
|- ∀f c1 c0 c.
     f with <|Sign := c1; Exponent := c0; Significand := c|> =
     <|Sign := c1; Exponent := c0; Significand := c|>
</pre>

<DT><span class="strong">float_literal_nchotomy</span>
<DD>
<pre>
|- ∀f. ∃c1 c0 c. f = <|Sign := c1; Exponent := c0; Significand := c|>
</pre>

<DT><span class="strong">FORALL_float</span>
<DD>
<pre>
|- ∀P.
     (∀f. P f) ⇔ ∀c1 c0 c. P <|Sign := c1; Exponent := c0; Significand := c|>
</pre>

<DT><span class="strong">EXISTS_float</span>
<DD>
<pre>
|- ∀P.
     (∃f. P f) ⇔ ∃c1 c0 c. P <|Sign := c1; Exponent := c0; Significand := c|>
</pre>

<DT><span class="strong">float_literal_11</span>
<DD>
<pre>
|- ∀c11 c01 c1 c12 c02 c2.
     (<|Sign := c11; Exponent := c01; Significand := c1|> =
      <|Sign := c12; Exponent := c02; Significand := c2|>) ⇔
     (c11 = c12) ∧ (c01 = c02) ∧ (c1 = c2)
</pre>

<DT><span class="strong">datatype_float</span>
<DD>
<pre>
|- DATATYPE (record float Sign Exponent Significand)
</pre>

<DT><span class="strong">float_11</span>
<DD>
<pre>
|- ∀a0 a1 a2 a0' a1' a2'.
     (float a0 a1 a2 = float a0' a1' a2') ⇔
     (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2')
</pre>

<DT><span class="strong">float_case_cong</span>
<DD>
<pre>
|- ∀M M' f.
     (M = M') ∧
     (∀a0 a1 a2. (M' = float a0 a1 a2) ⇒ (f a0 a1 a2 = f' a0 a1 a2)) ⇒
     (float_CASE M f = float_CASE M' f')
</pre>

<DT><span class="strong">float_nchotomy</span>
<DD>
<pre>
|- ∀ff. ∃c c0 c1. ff = float c c0 c1
</pre>

<DT><span class="strong">float_Axiom</span>
<DD>
<pre>
|- ∀f. ∃fn. ∀a0 a1 a2. fn (float a0 a1 a2) = f a0 a1 a2
</pre>

<DT><span class="strong">float_induction</span>
<DD>
<pre>
|- ∀P. (∀c c0 c1. P (float c c0 c1)) ⇒ ∀f. P f
</pre>

<DT><span class="strong">datatype_float_value</span>
<DD>
<pre>
|- DATATYPE (float_value Float Infinity NaN)
</pre>

<DT><span class="strong">float_value_11</span>
<DD>
<pre>
|- ∀a a'. (Float a = Float a') ⇔ (a = a')
</pre>

<DT><span class="strong">float_value_distinct</span>
<DD>
<pre>
|- (∀a. Float a ≠ Infinity) ∧ (∀a. Float a ≠ NaN) ∧ Infinity ≠ NaN
</pre>

<DT><span class="strong">float_value_case_cong</span>
<DD>
<pre>
|- ∀M M' f v v1.
     (M = M') ∧ (∀a. (M' = Float a) ⇒ (f a = f' a)) ∧
     ((M' = Infinity) ⇒ (v = v')) ∧ ((M' = NaN) ⇒ (v1 = v1')) ⇒
     (float_value_CASE M f v v1 = float_value_CASE M' f' v' v1')
</pre>

<DT><span class="strong">float_value_nchotomy</span>
<DD>
<pre>
|- ∀ff. (∃r. ff = Float r) ∨ (ff = Infinity) ∨ (ff = NaN)
</pre>

<DT><span class="strong">float_value_Axiom</span>
<DD>
<pre>
|- ∀f0 f1 f2.
     ∃fn. (∀a. fn (Float a) = f0 a) ∧ (fn Infinity = f1) ∧ (fn NaN = f2)
</pre>

<DT><span class="strong">float_value_induction</span>
<DD>
<pre>
|- ∀P. (∀r. P (Float r)) ∧ P Infinity ∧ P NaN ⇒ ∀f. P f
</pre>

<DT><span class="strong">num2rounding_rounding2num</span>
<DD>
<pre>
|- ∀a. num2rounding (rounding2num a) = a
</pre>

<DT><span class="strong">rounding2num_num2rounding</span>
<DD>
<pre>
|- ∀r. r < 4 ⇔ (rounding2num (num2rounding r) = r)
</pre>

<DT><span class="strong">num2rounding_11</span>
<DD>
<pre>
|- ∀r r'. r < 4 ⇒ r' < 4 ⇒ ((num2rounding r = num2rounding r') ⇔ (r = r'))
</pre>

<DT><span class="strong">rounding2num_11</span>
<DD>
<pre>
|- ∀a a'. (rounding2num a = rounding2num a') ⇔ (a = a')
</pre>

<DT><span class="strong">num2rounding_ONTO</span>
<DD>
<pre>
|- ∀a. ∃r. (a = num2rounding r) ∧ r < 4
</pre>

<DT><span class="strong">rounding2num_ONTO</span>
<DD>
<pre>
|- ∀r. r < 4 ⇔ ∃a. r = rounding2num a
</pre>

<DT><span class="strong">num2rounding_thm</span>
<DD>
<pre>
|- (num2rounding 0 = roundTiesToEven) ∧
   (num2rounding 1 = roundTowardPositive) ∧
   (num2rounding 2 = roundTowardNegative) ∧ (num2rounding 3 = roundTowardZero)
</pre>

<DT><span class="strong">rounding2num_thm</span>
<DD>
<pre>
|- (rounding2num roundTiesToEven = 0) ∧
   (rounding2num roundTowardPositive = 1) ∧
   (rounding2num roundTowardNegative = 2) ∧ (rounding2num roundTowardZero = 3)
</pre>

<DT><span class="strong">rounding_EQ_rounding</span>
<DD>
<pre>
|- ∀a a'. (a = a') ⇔ (rounding2num a = rounding2num a')
</pre>

<DT><span class="strong">rounding_case_def</span>
<DD>
<pre>
|- (∀v0 v1 v2 v3.
      (case roundTiesToEven of
         roundTiesToEven => v0
       | roundTowardPositive => v1
       | roundTowardNegative => v2
       | roundTowardZero => v3) =
      v0) ∧
   (∀v0 v1 v2 v3.
      (case roundTowardPositive of
         roundTiesToEven => v0
       | roundTowardPositive => v1
       | roundTowardNegative => v2
       | roundTowardZero => v3) =
      v1) ∧
   (∀v0 v1 v2 v3.
      (case roundTowardNegative of
         roundTiesToEven => v0
       | roundTowardPositive => v1
       | roundTowardNegative => v2
       | roundTowardZero => v3) =
      v2) ∧
   ∀v0 v1 v2 v3.
     (case roundTowardZero of
        roundTiesToEven => v0
      | roundTowardPositive => v1
      | roundTowardNegative => v2
      | roundTowardZero => v3) =
     v3
</pre>

<DT><span class="strong">datatype_rounding</span>
<DD>
<pre>
|- DATATYPE
     (rounding roundTiesToEven roundTowardPositive roundTowardNegative
        roundTowardZero)
</pre>

<DT><span class="strong">rounding_distinct</span>
<DD>
<pre>
|- roundTiesToEven ≠ roundTowardPositive ∧
   roundTiesToEven ≠ roundTowardNegative ∧ roundTiesToEven ≠ roundTowardZero ∧
   roundTowardPositive ≠ roundTowardNegative ∧
   roundTowardPositive ≠ roundTowardZero ∧
   roundTowardNegative ≠ roundTowardZero
</pre>

<DT><span class="strong">rounding_case_cong</span>
<DD>
<pre>
|- ∀M M' v0 v1 v2 v3.
     (M = M') ∧ ((M' = roundTiesToEven) ⇒ (v0 = v0')) ∧
     ((M' = roundTowardPositive) ⇒ (v1 = v1')) ∧
     ((M' = roundTowardNegative) ⇒ (v2 = v2')) ∧
     ((M' = roundTowardZero) ⇒ (v3 = v3')) ⇒
     ((case M of
         roundTiesToEven => v0
       | roundTowardPositive => v1
       | roundTowardNegative => v2
       | roundTowardZero => v3) =
      case M' of
        roundTiesToEven => v0'
      | roundTowardPositive => v1'
      | roundTowardNegative => v2'
      | roundTowardZero => v3')
</pre>

<DT><span class="strong">rounding_nchotomy</span>
<DD>
<pre>
|- ∀a.
     (a = roundTiesToEven) ∨ (a = roundTowardPositive) ∨
     (a = roundTowardNegative) ∨ (a = roundTowardZero)
</pre>

<DT><span class="strong">rounding_Axiom</span>
<DD>
<pre>
|- ∀x0 x1 x2 x3.
     ∃f.
       (f roundTiesToEven = x0) ∧ (f roundTowardPositive = x1) ∧
       (f roundTowardNegative = x2) ∧ (f roundTowardZero = x3)
</pre>

<DT><span class="strong">rounding_induction</span>
<DD>
<pre>
|- ∀P.
     P roundTiesToEven ∧ P roundTowardNegative ∧ P roundTowardPositive ∧
     P roundTowardZero ⇒
     ∀a. P a
</pre>

<DT><span class="strong">ULP_ind</span>
<DD>
<pre>
|- ∀P. (∀e. P (e,(:τ))) ⇒ ∀v v1. P (v,v1)
</pre>

<DT><span class="strong">ULP_def</span>
<DD>
<pre>
|- ULP (e,(:τ)) =
   2 pow (if e = 0w then 1 else w2n e) / 2 pow (INT_MAX (:χ) + dimindex (:τ))
</pre>

<DT><span class="strong">num2float_compare_float_compare2num</span>
<DD>
<pre>
|- ∀a. num2float_compare (float_compare2num a) = a
</pre>

<DT><span class="strong">float_compare2num_num2float_compare</span>
<DD>
<pre>
|- ∀r. r < 4 ⇔ (float_compare2num (num2float_compare r) = r)
</pre>

<DT><span class="strong">num2float_compare_11</span>
<DD>
<pre>
|- ∀r r'.
     r < 4 ⇒
     r' < 4 ⇒
     ((num2float_compare r = num2float_compare r') ⇔ (r = r'))
</pre>

<DT><span class="strong">float_compare2num_11</span>
<DD>
<pre>
|- ∀a a'. (float_compare2num a = float_compare2num a') ⇔ (a = a')
</pre>

<DT><span class="strong">num2float_compare_ONTO</span>
<DD>
<pre>
|- ∀a. ∃r. (a = num2float_compare r) ∧ r < 4
</pre>

<DT><span class="strong">float_compare2num_ONTO</span>
<DD>
<pre>
|- ∀r. r < 4 ⇔ ∃a. r = float_compare2num a
</pre>

<DT><span class="strong">num2float_compare_thm</span>
<DD>
<pre>
|- (num2float_compare 0 = LT) ∧ (num2float_compare 1 = GT) ∧
   (num2float_compare 2 = EQ) ∧ (num2float_compare 3 = UN)
</pre>

<DT><span class="strong">float_compare2num_thm</span>
<DD>
<pre>
|- (float_compare2num LT = 0) ∧ (float_compare2num GT = 1) ∧
   (float_compare2num EQ = 2) ∧ (float_compare2num UN = 3)
</pre>

<DT><span class="strong">float_compare_EQ_float_compare</span>
<DD>
<pre>
|- ∀a a'. (a = a') ⇔ (float_compare2num a = float_compare2num a')
</pre>

<DT><span class="strong">float_compare_case_def</span>
<DD>
<pre>
|- (∀v0 v1 v2 v3.
      (case LT of LT => v0 | GT => v1 | EQ => v2 | UN => v3) = v0) ∧
   (∀v0 v1 v2 v3.
      (case GT of LT => v0 | GT => v1 | EQ => v2 | UN => v3) = v1) ∧
   (∀v0 v1 v2 v3.
      (case EQ of LT => v0 | GT => v1 | EQ => v2 | UN => v3) = v2) ∧
   ∀v0 v1 v2 v3. (case UN of LT => v0 | GT => v1 | EQ => v2 | UN => v3) = v3
</pre>

<DT><span class="strong">datatype_float_compare</span>
<DD>
<pre>
|- DATATYPE (float_compare LT GT EQ UN)
</pre>

<DT><span class="strong">float_compare_distinct</span>
<DD>
<pre>
|- LT ≠ GT ∧ LT ≠ EQ ∧ LT ≠ UN ∧ GT ≠ EQ ∧ GT ≠ UN ∧ EQ ≠ UN
</pre>

<DT><span class="strong">float_compare_case_cong</span>
<DD>
<pre>
|- ∀M M' v0 v1 v2 v3.
     (M = M') ∧ ((M' = LT) ⇒ (v0 = v0')) ∧ ((M' = GT) ⇒ (v1 = v1')) ∧
     ((M' = EQ) ⇒ (v2 = v2')) ∧ ((M' = UN) ⇒ (v3 = v3')) ⇒
     ((case M of LT => v0 | GT => v1 | EQ => v2 | UN => v3) =
      case M' of LT => v0' | GT => v1' | EQ => v2' | UN => v3')
</pre>

<DT><span class="strong">float_compare_nchotomy</span>
<DD>
<pre>
|- ∀a. (a = LT) ∨ (a = GT) ∨ (a = EQ) ∨ (a = UN)
</pre>

<DT><span class="strong">float_compare_Axiom</span>
<DD>
<pre>
|- ∀x0 x1 x2 x3. ∃f. (f LT = x0) ∧ (f GT = x1) ∧ (f EQ = x2) ∧ (f UN = x3)
</pre>

<DT><span class="strong">float_compare_induction</span>
<DD>
<pre>
|- ∀P. P EQ ∧ P GT ∧ P LT ∧ P UN ⇒ ∀a. P a
</pre>

<DT><span class="strong">zero_lt_twopow</span>
<DD>
<pre>
|- ∀n. 0 < 2 pow n
</pre>

<DT><span class="strong">zero_le_twopow</span>
<DD>
<pre>
|- ∀n. 0 ≤ 2 pow n
</pre>

<DT><span class="strong">zero_neq_twopow</span>
<DD>
<pre>
|- ∀n. 2 pow n ≠ 0
</pre>

<DT><span class="strong">zero_le_pos_div_twopow</span>
<DD>
<pre>
|- ∀m n. 0 ≤ &m / 2 pow n
</pre>

<DT><span class="strong">div_eq0</span>
<DD>
<pre>
|- ∀a b. 0 < b ⇒ ((a / b = 0) ⇔ (a = 0))
</pre>

<DT><span class="strong">exp_ge2</span>
<DD>
<pre>
|- ∀b. 2 ≤ 2 ** b ⇔ 1 ≤ b
</pre>

<DT><span class="strong">exp_gt2</span>
<DD>
<pre>
|- ∀b. 2 < 2 ** b ⇔ 1 < b
</pre>

<DT><span class="strong">le2</span>
<DD>
<pre>
|- ∀n m. 2 ≤ n ∧ 2 ≤ m ⇒ 2 ≤ n * m
</pre>

<DT><span class="strong">float_components</span>
<DD>
<pre>
|- ((float_plus_infinity (:τ # χ)).Sign = 0w) ∧
   ((float_plus_infinity (:τ # χ)).Exponent = UINT_MAXw) ∧
   ((float_plus_infinity (:τ # χ)).Significand = 0w) ∧
   ((float_minus_infinity (:τ # χ)).Sign = 1w) ∧
   ((float_minus_infinity (:τ # χ)).Exponent = UINT_MAXw) ∧
   ((float_minus_infinity (:τ # χ)).Significand = 0w) ∧
   ((float_plus_zero (:τ # χ)).Sign = 0w) ∧
   ((float_plus_zero (:τ # χ)).Exponent = 0w) ∧
   ((float_plus_zero (:τ # χ)).Significand = 0w) ∧
   ((float_minus_zero (:τ # χ)).Sign = 1w) ∧
   ((float_minus_zero (:τ # χ)).Exponent = 0w) ∧
   ((float_minus_zero (:τ # χ)).Significand = 0w) ∧
   ((float_plus_min (:τ # χ)).Sign = 0w) ∧
   ((float_plus_min (:τ # χ)).Exponent = 0w) ∧
   ((float_plus_min (:τ # χ)).Significand = 1w) ∧
   ((float_minus_min (:τ # χ)).Sign = 1w) ∧
   ((float_minus_min (:τ # χ)).Exponent = 0w) ∧
   ((float_minus_min (:τ # χ)).Significand = 1w) ∧
   ((float_top (:τ # χ)).Sign = 0w) ∧
   ((float_top (:τ # χ)).Exponent = UINT_MAXw − 1w) ∧
   ((float_top (:τ # χ)).Significand = UINT_MAXw) ∧
   ((float_bottom (:τ # χ)).Sign = 1w) ∧
   ((float_bottom (:τ # χ)).Exponent = UINT_MAXw − 1w) ∧
   ((float_bottom (:τ # χ)).Significand = UINT_MAXw) ∧
   ((float_some_nan (:τ # χ)).Exponent = UINT_MAXw) ∧
   (float_some_nan (:τ # χ)).Significand ≠ 0w ∧
   (∀x. (float_negate x).Sign = ¬x.Sign) ∧
   (∀x. (float_negate x).Exponent = x.Exponent) ∧
   ∀x. (float_negate x).Significand = x.Significand
</pre>

<DT><span class="strong">float_distinct</span>
<DD>
<pre>
|- float_plus_infinity (:τ # χ) ≠ float_minus_infinity (:τ # χ) ∧
   float_plus_infinity (:τ # χ) ≠ float_plus_zero (:τ # χ) ∧
   float_plus_infinity (:τ # χ) ≠ float_minus_zero (:τ # χ) ∧
   float_plus_infinity (:τ # χ) ≠ float_top (:τ # χ) ∧
   float_plus_infinity (:τ # χ) ≠ float_bottom (:τ # χ) ∧
   float_plus_infinity (:τ # χ) ≠ float_plus_min (:τ # χ) ∧
   float_plus_infinity (:τ # χ) ≠ float_minus_min (:τ # χ) ∧
   float_plus_infinity (:τ # χ) ≠ float_some_nan (:τ # χ) ∧
   float_minus_infinity (:τ # χ) ≠ float_plus_zero (:τ # χ) ∧
   float_minus_infinity (:τ # χ) ≠ float_minus_zero (:τ # χ) ∧
   float_minus_infinity (:τ # χ) ≠ float_top (:τ # χ) ∧
   float_minus_infinity (:τ # χ) ≠ float_bottom (:τ # χ) ∧
   float_minus_infinity (:τ # χ) ≠ float_plus_min (:τ # χ) ∧
   float_minus_infinity (:τ # χ) ≠ float_minus_min (:τ # χ) ∧
   float_minus_infinity (:τ # χ) ≠ float_some_nan (:τ # χ) ∧
   float_plus_zero (:τ # χ) ≠ float_minus_zero (:τ # χ) ∧
   float_plus_zero (:τ # χ) ≠ float_top (:τ # χ) ∧
   float_plus_zero (:τ # χ) ≠ float_bottom (:τ # χ) ∧
   float_plus_zero (:τ # χ) ≠ float_plus_min (:τ # χ) ∧
   float_plus_zero (:τ # χ) ≠ float_minus_min (:τ # χ) ∧
   float_plus_zero (:τ # χ) ≠ float_some_nan (:τ # χ) ∧
   float_minus_zero (:τ # χ) ≠ float_top (:τ # χ) ∧
   float_minus_zero (:τ # χ) ≠ float_bottom (:τ # χ) ∧
   float_minus_zero (:τ # χ) ≠ float_plus_min (:τ # χ) ∧
   float_minus_zero (:τ # χ) ≠ float_minus_min (:τ # χ) ∧
   float_minus_zero (:τ # χ) ≠ float_some_nan (:τ # χ) ∧
   float_top (:τ # χ) ≠ float_minus_min (:τ # χ) ∧
   float_top (:τ # χ) ≠ float_bottom (:τ # χ) ∧
   float_top (:τ # χ) ≠ float_some_nan (:τ # χ) ∧
   float_bottom (:τ # χ) ≠ float_plus_min (:τ # χ) ∧
   float_bottom (:τ # χ) ≠ float_some_nan (:τ # χ) ∧
   float_plus_min (:τ # χ) ≠ float_some_nan (:τ # χ) ∧
   float_plus_min (:τ # χ) ≠ float_minus_min (:τ # χ) ∧
   float_minus_min (:τ # χ) ≠ float_some_nan (:τ # χ) ∧ ∀x. float_negate x ≠ x
</pre>

<DT><span class="strong">float_values</span>
<DD>
<pre>
|- (float_value (float_plus_infinity (:τ # χ)) = Infinity) ∧
   (float_value (float_minus_infinity (:τ # χ)) = Infinity) ∧
   (float_value (float_some_nan (:τ # χ)) = NaN) ∧
   (float_value (float_plus_zero (:τ # χ)) = Float 0) ∧
   (float_value (float_minus_zero (:τ # χ)) = Float 0) ∧
   (float_value (float_plus_min (:τ # χ)) =
    Float (2 / 2 pow (INT_MAX (:χ) + dimindex (:τ)))) ∧
   (float_value (float_minus_min (:τ # χ)) =
    Float (-2 / 2 pow (INT_MAX (:χ) + dimindex (:τ))))
</pre>

<DT><span class="strong">zero_to_real</span>
<DD>
<pre>
|- (float_to_real (float_plus_zero (:τ # χ)) = 0) ∧
   (float_to_real (float_minus_zero (:τ # χ)) = 0)
</pre>

<DT><span class="strong">sign_not_zero</span>
<DD>
<pre>
|- ∀s. -1 pow w2n s ≠ 0
</pre>

<DT><span class="strong">float_sets</span>
<DD>
<pre>
|- (float_is_zero = {float_minus_zero (:τ # χ); float_plus_zero (:τ # χ)}) ∧
   (float_is_infinite =
    {float_minus_infinity (:τ # χ); float_plus_infinity (:τ # χ)})
</pre>

<DT><span class="strong">infinity_properties</span>
<DD>
<pre>
|- ¬float_is_zero (float_plus_infinity (:τ # χ)) ∧
   ¬float_is_zero (float_minus_infinity (:τ # χ)) ∧
   ¬float_is_finite (float_plus_infinity (:τ # χ)) ∧
   ¬float_is_finite (float_minus_infinity (:τ # χ)) ∧
   ¬float_is_integral (float_plus_infinity (:τ # χ)) ∧
   ¬float_is_integral (float_minus_infinity (:τ # χ)) ∧
   ¬float_is_nan (float_plus_infinity (:τ # χ)) ∧
   ¬float_is_nan (float_minus_infinity (:τ # χ)) ∧
   ¬float_is_normal (float_plus_infinity (:τ # χ)) ∧
   ¬float_is_normal (float_minus_infinity (:τ # χ)) ∧
   ¬float_is_subnormal (float_plus_infinity (:τ # χ)) ∧
   ¬float_is_subnormal (float_minus_infinity (:τ # χ)) ∧
   float_is_infinite (float_plus_infinity (:τ # χ)) ∧
   float_is_infinite (float_minus_infinity (:τ # χ))
</pre>

<DT><span class="strong">zero_properties</span>
<DD>
<pre>
|- float_is_zero (float_plus_zero (:τ # χ)) ∧
   float_is_zero (float_minus_zero (:τ # χ)) ∧
   float_is_finite (float_plus_zero (:τ # χ)) ∧
   float_is_finite (float_minus_zero (:τ # χ)) ∧
   float_is_integral (float_plus_zero (:τ # χ)) ∧
   float_is_integral (float_minus_zero (:τ # χ)) ∧
   ¬float_is_nan (float_plus_zero (:τ # χ)) ∧
   ¬float_is_nan (float_minus_zero (:τ # χ)) ∧
   ¬float_is_normal (float_plus_zero (:τ # χ)) ∧
   ¬float_is_normal (float_minus_zero (:τ # χ)) ∧
   ¬float_is_subnormal (float_plus_zero (:τ # χ)) ∧
   ¬float_is_subnormal (float_minus_zero (:τ # χ)) ∧
   ¬float_is_infinite (float_plus_zero (:τ # χ)) ∧
   ¬float_is_infinite (float_minus_zero (:τ # χ))
</pre>

<DT><span class="strong">some_nan_properties</span>
<DD>
<pre>
|- ¬float_is_zero (float_some_nan (:τ # χ)) ∧
   ¬float_is_finite (float_some_nan (:τ # χ)) ∧
   ¬float_is_integral (float_some_nan (:τ # χ)) ∧
   float_is_nan (float_some_nan (:τ # χ)) ∧
   ¬float_is_normal (float_some_nan (:τ # χ)) ∧
   ¬float_is_subnormal (float_some_nan (:τ # χ)) ∧
   ¬float_is_infinite (float_some_nan (:τ # χ))
</pre>

<DT><span class="strong">min_properties</span>
<DD>
<pre>
|- ¬float_is_zero (float_plus_min (:τ # χ)) ∧
   float_is_finite (float_plus_min (:τ # χ)) ∧
   (float_is_integral (float_plus_min (:τ # χ)) ⇔
    (dimindex (:χ) = 1) ∧ (dimindex (:τ) = 1)) ∧
   ¬float_is_nan (float_plus_min (:τ # χ)) ∧
   ¬float_is_normal (float_plus_min (:τ # χ)) ∧
   float_is_subnormal (float_plus_min (:τ # χ)) ∧
   ¬float_is_infinite (float_plus_min (:τ # χ)) ∧
   ¬float_is_zero (float_minus_min (:τ # χ)) ∧
   float_is_finite (float_minus_min (:τ # χ)) ∧
   (float_is_integral (float_minus_min (:τ # χ)) ⇔
    (dimindex (:χ) = 1) ∧ (dimindex (:τ) = 1)) ∧
   ¬float_is_nan (float_minus_min (:τ # χ)) ∧
   ¬float_is_normal (float_minus_min (:τ # χ)) ∧
   float_is_subnormal (float_minus_min (:τ # χ)) ∧
   ¬float_is_infinite (float_minus_min (:τ # χ))
</pre>

<DT><span class="strong">top_properties</span>
<DD>
<pre>
|- ¬float_is_zero (float_top (:τ # χ)) ∧
   float_is_finite (float_top (:τ # χ)) ∧ ¬float_is_nan (float_top (:τ # χ)) ∧
   (float_is_normal (float_top (:τ # χ)) ⇔ dimindex (:χ) ≠ 1) ∧
   (float_is_subnormal (float_top (:τ # χ)) ⇔ (dimindex (:χ) = 1)) ∧
   ¬float_is_infinite (float_top (:τ # χ))
</pre>

<DT><span class="strong">bottom_properties</span>
<DD>
<pre>
|- ¬float_is_zero (float_bottom (:τ # χ)) ∧
   float_is_finite (float_bottom (:τ # χ)) ∧
   ¬float_is_nan (float_bottom (:τ # χ)) ∧
   (float_is_normal (float_bottom (:τ # χ)) ⇔ dimindex (:χ) ≠ 1) ∧
   (float_is_subnormal (float_bottom (:τ # χ)) ⇔ (dimindex (:χ) = 1)) ∧
   ¬float_is_infinite (float_bottom (:τ # χ))
</pre>

<DT><span class="strong">float_to_real_negate</span>
<DD>
<pre>
|- ∀x. float_to_real (float_negate x) = -float_to_real x
</pre>

<DT><span class="strong">float_negate_negate</span>
<DD>
<pre>
|- ∀x. float_negate (float_negate x) = x
</pre>

<DT><span class="strong">ulp</span>
<DD>
<pre>
|- ulp (:τ # χ) = float_to_real (float_plus_min (:τ # χ))
</pre>

<DT><span class="strong">neg_ulp</span>
<DD>
<pre>
|- -ulp (:τ # χ) = float_to_real (float_negate (float_plus_min (:τ # χ)))
</pre>

<DT><span class="strong">ULP_le_mono</span>
<DD>
<pre>
|- ∀e1 e2. e2 ≠ 0w ⇒ (ULP (e1,(:τ)) ≤ ULP (e2,(:τ)) ⇔ e1 ≤₊ e2)
</pre>

<DT><span class="strong">ulp_lt_ULP</span>
<DD>
<pre>
|- ∀e. ulp (:τ # χ) ≤ ULP (e,(:τ))
</pre>

<DT><span class="strong">ulp_lt_largest</span>
<DD>
<pre>
|- ulp (:τ # χ) < largest (:τ # χ)
</pre>

<DT><span class="strong">ulp_lt_threshold</span>
<DD>
<pre>
|- ulp (:τ # χ) < threshold (:τ # χ)
</pre>

<DT><span class="strong">abs_float_value</span>
<DD>
<pre>
|- (∀b c d. abs (-1 pow w2n b * c * d) = abs (c * d)) ∧
   ∀b c. abs (-1 pow w2n b * c) = abs c
</pre>

<DT><span class="strong">less_than_ulp</span>
<DD>
<pre>
|- ∀a.
     abs (float_to_real a) < ulp (:τ # χ) ⇔
     (a.Exponent = 0w) ∧ (a.Significand = 0w)
</pre>

<DT><span class="strong">float_is_zero_to_real</span>
<DD>
<pre>
|- ∀x. float_is_zero x ⇔ (float_to_real x = 0)
</pre>

<DT><span class="strong">float_is_zero</span>
<DD>
<pre>
|- ∀x. float_is_zero x ⇔ (x.Exponent = 0w) ∧ (x.Significand = 0w)
</pre>

<DT><span class="strong">float_to_real_eq</span>
<DD>
<pre>
|- ∀x y.
     (float_to_real x = float_to_real y) ⇔
     (x = y) ∨ float_is_zero x ∧ float_is_zero y
</pre>

<DT><span class="strong">diff_float_ULP</span>
<DD>
<pre>
|- ∀x y.
     float_to_real x ≠ float_to_real y ∧ ¬exponent_boundary y x ⇒
     ULP (x.Exponent,(:τ)) ≤ abs (float_to_real x − float_to_real y)
</pre>

<DT><span class="strong">diff_lt_ulp_eq0</span>
<DD>
<pre>
|- ∀a b x.
     ¬exponent_boundary b a ∧
     abs (x − float_to_real a) < ULP (a.Exponent,(:τ)) ∧
     abs (x − float_to_real b) < ULP (a.Exponent,(:τ)) ∧
     abs (float_to_real a) ≤ abs x ∧ abs (float_to_real b) ≤ abs x ∧
     ¬float_is_zero a ⇒
     (b = a)
</pre>

<DT><span class="strong">diff_lt_ulp_even</span>
<DD>
<pre>
|- ∀a b x.
     ¬exponent_boundary b a ∧
     2 * abs (float_to_real a − x) < ULP (a.Exponent,(:τ)) ∧
     2 * abs (float_to_real b − x) < ULP (a.Exponent,(:τ)) ∧
     ¬float_is_zero a ⇒
     (b = a)
</pre>

<DT><span class="strong">diff_lt_ulp_even4</span>
<DD>
<pre>
|- ∀a b x.
     ¬exponent_boundary b a ∧
     4 * abs (float_to_real a − x) ≤ ULP (a.Exponent,(:τ)) ∧
     4 * abs (float_to_real b − x) ≤ ULP (a.Exponent,(:τ)) ∧
     ¬float_is_zero a ⇒
     (b = a)
</pre>

<DT><span class="strong">round_roundTowardZero</span>
<DD>
<pre>
|- ∀y x r.
     (float_value y = Float r) ∧ abs (r − x) < ULP (y.Exponent,(:τ)) ∧
     abs r ≤ abs x ∧ ulp (:τ # χ) ≤ abs x ∧ abs x ≤ largest (:τ # χ) ⇒
     (round roundTowardZero x = y)
</pre>

<DT><span class="strong">round_roundTiesToEven</span>
<DD>
<pre>
|- ∀y x r.
     (float_value y = Float r) ∧
     ((y.Significand = 0w) ∧ y.Exponent ≠ 1w ⇒ abs r ≤ abs x) ∧
     2 * abs (r − x) ≤ ULP (y.Exponent,(:τ)) ∧
     ((2 * abs (r − x) = ULP (y.Exponent,(:τ))) ⇒ ¬word_lsb y.Significand) ∧
     ulp (:τ # χ) < 2 * abs x ∧ abs x < threshold (:τ # χ) ⇒
     (round roundTiesToEven x = y)
</pre>

<DT><span class="strong">round_roundTiesToEven0</span>
<DD>
<pre>
|- ∀y x r.
     (float_value y = Float r) ∧
     ((y.Significand = 0w) ∧ y.Exponent ≠ 1w ∧ ¬(abs r ≤ abs x)) ∧
     4 * abs (r − x) ≤ ULP (y.Exponent,(:τ)) ∧ ulp (:τ # χ) < 2 * abs x ∧
     abs x < threshold (:τ # χ) ⇒
     (round roundTiesToEven x = y)
</pre>

<DT><span class="strong">round_roundTowardZero_is_zero</span>
<DD>
<pre>
|- ∀x.
     abs x < ulp (:τ # χ) ⇒
     (round roundTowardZero x = float_plus_zero (:τ # χ)) ∨
     (round roundTowardZero x = float_minus_zero (:τ # χ))
</pre>

<DT><span class="strong">round_roundTiesToEven_is_zero</span>
<DD>
<pre>
|- ∀x.
     2 * abs x ≤ ulp (:τ # χ) ⇒
     (round roundTiesToEven x = float_plus_zero (:τ # χ)) ∨
     (round roundTiesToEven x = float_minus_zero (:τ # χ))
</pre>

<DT><span class="strong">round_roundTowardZero_is_minus_zero</span>
<DD>
<pre>
|- ∀x.
     abs x < ulp (:τ # χ) ⇒
     (float_round roundTowardZero T x = float_minus_zero (:τ # χ))
</pre>

<DT><span class="strong">round_roundTowardZero_is_plus_zero</span>
<DD>
<pre>
|- ∀x.
     abs x < ulp (:τ # χ) ⇒
     (float_round roundTowardZero F x = float_plus_zero (:τ # χ))
</pre>

<DT><span class="strong">round_roundTiesToEven_is_minus_zero</span>
<DD>
<pre>
|- ∀x.
     2 * abs x ≤ ulp (:τ # χ) ⇒
     (float_round roundTiesToEven T x = float_minus_zero (:τ # χ))
</pre>

<DT><span class="strong">round_roundTiesToEven_is_plus_zero</span>
<DD>
<pre>
|- ∀x.
     2 * abs x ≤ ulp (:τ # χ) ⇒
     (float_round roundTiesToEven F x = float_plus_zero (:τ # χ))
</pre>

<DT><span class="strong">largest_is_positive</span>
<DD>
<pre>
|- 0 ≤ largest (:τ # χ)
</pre>

<DT><span class="strong">threshold_is_positive</span>
<DD>
<pre>
|- 0 < threshold (:τ # χ)
</pre>

<DT><span class="strong">round_roundTiesToEven_plus_infinity</span>
<DD>
<pre>
|- ∀y x.
     threshold (:τ # χ) ≤ x ⇒
     (round roundTiesToEven x = float_plus_infinity (:τ # χ))
</pre>

<DT><span class="strong">round_roundTiesToEven_minus_infinity</span>
<DD>
<pre>
|- ∀y x.
     x ≤ -threshold (:τ # χ) ⇒
     (round roundTiesToEven x = float_minus_infinity (:τ # χ))
</pre>

<DT><span class="strong">round_roundTowardZero_top</span>
<DD>
<pre>
|- ∀y x. largest (:τ # χ) < x ⇒ (round roundTowardZero x = float_top (:τ # χ))
</pre>

<DT><span class="strong">round_roundTowardZero_bottom</span>
<DD>
<pre>
|- ∀y x.
     x < -largest (:τ # χ) ⇒ (round roundTowardZero x = float_bottom (:τ # χ))
</pre>

<DT><span class="strong">round_roundTowardPositive_plus_infinity</span>
<DD>
<pre>
|- ∀y x.
     largest (:τ # χ) < x ⇒
     (round roundTowardPositive x = float_plus_infinity (:τ # χ))
</pre>

<DT><span class="strong">round_roundTowardPositive_bottom</span>
<DD>
<pre>
|- ∀y x.
     x < -largest (:τ # χ) ⇒
     (round roundTowardPositive x = float_bottom (:τ # χ))
</pre>

<DT><span class="strong">round_roundTowardNegative_top</span>
<DD>
<pre>
|- ∀y x.
     largest (:τ # χ) < x ⇒ (round roundTowardNegative x = float_top (:τ # χ))
</pre>

<DT><span class="strong">round_roundTowardNegative_minus_infinity</span>
<DD>
<pre>
|- ∀y x.
     x < -largest (:τ # χ) ⇒
     (round roundTowardNegative x = float_minus_infinity (:τ # χ))
</pre>

<DT><span class="strong">float_round_roundTowardZero_top</span>
<DD>
<pre>
|- ∀b y x.
     largest (:τ # χ) < x ⇒
     (float_round roundTowardZero b x = float_top (:τ # χ))
</pre>

<DT><span class="strong">float_round_roundTowardZero_bottom</span>
<DD>
<pre>
|- ∀b y x.
     x < -largest (:τ # χ) ⇒
     (float_round roundTowardZero b x = float_bottom (:τ # χ))
</pre>

<DT><span class="strong">float_round_roundTowardPositive_plus_infinity</span>
<DD>
<pre>
|- ∀b y x.
     largest (:τ # χ) < x ⇒
     (float_round roundTowardPositive b x = float_plus_infinity (:τ # χ))
</pre>

<DT><span class="strong">float_round_roundTowardPositive_bottom</span>
<DD>
<pre>
|- ∀b y x.
     x < -largest (:τ # χ) ⇒
     (float_round roundTowardPositive b x = float_bottom (:τ # χ))
</pre>

<DT><span class="strong">float_round_roundTowardNegative_top</span>
<DD>
<pre>
|- ∀b y x.
     largest (:τ # χ) < x ⇒
     (float_round roundTowardNegative b x = float_top (:τ # χ))
</pre>

<DT><span class="strong">float_round_roundTowardNegative_minus_infinity</span>
<DD>
<pre>
|- ∀b y x.
     x < -largest (:τ # χ) ⇒
     (float_round roundTowardNegative b x = float_minus_infinity (:τ # χ))
</pre>

<DT><span class="strong">float_minus_zero</span>
<DD>
<pre>
|- float_minus_zero (:τ # χ) =
   <|Sign := 1w; Exponent := 0w; Significand := 0w|>
</pre>

<DT><span class="strong">float_minus_infinity</span>
<DD>
<pre>
|- float_minus_infinity (:τ # χ) =
   <|Sign := 1w; Exponent := UINT_MAXw; Significand := 0w|>
</pre>

<DT><span class="strong">float_round_non_zero</span>
<DD>
<pre>
|- ∀mode toneg r s e f.
     (round mode r = <|Sign := s; Exponent := e; Significand := f|>) ∧
     (e ≠ 0w ∨ f ≠ 0w) ⇒
     (float_round mode toneg r =
      <|Sign := s; Exponent := e; Significand := f|>)
</pre>

<DT><span class="strong">float_round_plus_infinity</span>
<DD>
<pre>
|- ∀mode toneg r.
     (round mode r = float_plus_infinity (:τ # χ)) ⇒
     (float_round mode toneg r = float_plus_infinity (:τ # χ))
</pre>

<DT><span class="strong">float_round_minus_infinity</span>
<DD>
<pre>
|- ∀mode toneg r.
     (round mode r = float_minus_infinity (:τ # χ)) ⇒
     (float_round mode toneg r = float_minus_infinity (:τ # χ))
</pre>

<DT><span class="strong">float_round_top</span>
<DD>
<pre>
|- ∀mode toneg r.
     (round mode r = float_top (:τ # χ)) ⇒
     (float_round mode toneg r = float_top (:τ # χ))
</pre>

<DT><span class="strong">float_round_bottom</span>
<DD>
<pre>
|- ∀mode toneg r.
     (round mode r = float_bottom (:τ # χ)) ⇒
     (float_round mode toneg r = float_bottom (:τ # χ))
</pre>

<DT><span class="strong">float_to_real</span>
<DD>
<pre>
|- ∀s e f.
     float_to_real <|Sign := s; Exponent := e; Significand := f|> =
     (let r =
            if e = 0w then 2 / &(2 ** INT_MAX (:χ)) * (&w2n f / &dimword (:τ))
            else
              &(2 ** w2n e) / &(2 ** INT_MAX (:χ)) *
              (1 + &w2n f / &dimword (:τ))
      in
        if s = 1w then -r else r)
</pre>

<DT><span class="strong">largest</span>
<DD>
<pre>
|- largest (:τ # χ) =
   &(2 ** (UINT_MAX (:χ) − 1)) * (2 − 1 / &dimword (:τ)) /
   &(2 ** INT_MAX (:χ))
</pre>

<DT><span class="strong">threshold</span>
<DD>
<pre>
|- threshold (:τ # χ) =
   &(2 ** (UINT_MAX (:χ) − 1)) * (2 − 1 / &(2 * dimword (:τ))) /
   &(2 ** INT_MAX (:χ))
</pre>

<DT><span class="strong">float_tests</span>
<DD>
<pre>
|- (∀s e f.
      float_is_nan <|Sign := s; Exponent := e; Significand := f|> ⇔
      (e = -1w) ∧ f ≠ 0w) ∧
   (∀s e f.
      float_is_infinite <|Sign := s; Exponent := e; Significand := f|> ⇔
      (e = -1w) ∧ (f = 0w)) ∧
   (∀s e f.
      float_is_normal <|Sign := s; Exponent := e; Significand := f|> ⇔
      e ≠ 0w ∧ e ≠ -1w) ∧
   (∀s e f.
      float_is_subnormal <|Sign := s; Exponent := e; Significand := f|> ⇔
      (e = 0w) ∧ f ≠ 0w) ∧
   (∀s e f.
      float_is_zero <|Sign := s; Exponent := e; Significand := f|> ⇔
      (e = 0w) ∧ (f = 0w)) ∧
   ∀s e f.
     float_is_finite <|Sign := s; Exponent := e; Significand := f|> ⇔ e ≠ -1w
</pre>

<DT><span class="strong">float_infinity_negate_abs</span>
<DD>
<pre>
|- (float_negate (float_plus_infinity (:τ # χ)) =
    float_minus_infinity (:τ # χ)) ∧
   (float_negate (float_minus_infinity (:τ # χ)) =
    float_plus_infinity (:τ # χ)) ∧
   (float_abs (float_plus_infinity (:τ # χ)) = float_plus_infinity (:τ # χ)) ∧
   (float_abs (float_minus_infinity (:τ # χ)) = float_plus_infinity (:τ # χ))
</pre>

<DT><span class="strong">float_add_compute</span>
<DD>
<pre>
|- (∀mode x.
      (mode float_add float_some_nan (:τ # χ)) x = float_some_nan (:τ # χ)) ∧
   (∀mode x.
      (mode float_add x) (float_some_nan (:τ # χ)) =
      float_some_nan (:τ # χ)) ∧
   (∀mode.
      (mode float_add float_minus_infinity (:τ # χ))
        (float_minus_infinity (:τ # χ)) =
      float_minus_infinity (:τ # χ)) ∧
   (∀mode.
      (mode float_add float_minus_infinity (:τ # χ))
        (float_plus_infinity (:τ # χ)) =
      float_some_nan (:τ # χ)) ∧
   (∀mode.
      (mode float_add float_plus_infinity (:τ # χ))
        (float_plus_infinity (:τ # χ)) =
      float_plus_infinity (:τ # χ)) ∧
   ∀mode.
     (mode float_add float_plus_infinity (:τ # χ))
       (float_minus_infinity (:τ # χ)) =
     float_some_nan (:τ # χ)
</pre>

<DT><span class="strong">float_add_nan</span>
<DD>
<pre>
|- ∀mode x y.
     (float_value x = NaN) ∨ (float_value y = NaN) ⇒
     ((mode float_add x) y = float_some_nan (:τ # χ))
</pre>

<DT><span class="strong">float_add_finite</span>
<DD>
<pre>
|- ∀mode x y r1 r2.
     (float_value x = Float r1) ∧ (float_value y = Float r2) ⇒
     ((mode float_add x) y =
      float_round mode
        (if (r1 = 0) ∧ (r2 = 0) ∧ (x.Sign = y.Sign) then x.Sign = 1w
         else (mode = roundTowardNegative)) (r1 + r2))
</pre>

<DT><span class="strong">float_add_finite_plus_infinity</span>
<DD>
<pre>
|- ∀mode x r.
     (float_value x = Float r) ⇒
     ((mode float_add x) (float_plus_infinity (:τ # χ)) =
      float_plus_infinity (:τ # χ))
</pre>

<DT><span class="strong">float_add_plus_infinity_finite</span>
<DD>
<pre>
|- ∀mode x r.
     (float_value x = Float r) ⇒
     ((mode float_add float_plus_infinity (:τ # χ)) x =
      float_plus_infinity (:τ # χ))
</pre>

<DT><span class="strong">float_add_finite_minus_infinity</span>
<DD>
<pre>
|- ∀mode x r.
     (float_value x = Float r) ⇒
     ((mode float_add x) (float_minus_infinity (:τ # χ)) =
      float_minus_infinity (:τ # χ))
</pre>

<DT><span class="strong">float_add_minus_infinity_finite</span>
<DD>
<pre>
|- ∀mode x r.
     (float_value x = Float r) ⇒
     ((mode float_add float_minus_infinity (:τ # χ)) x =
      float_minus_infinity (:τ # χ))
</pre>

<DT><span class="strong">float_sub_compute</span>
<DD>
<pre>
|- (∀mode x.
      (mode float_sub float_some_nan (:τ # χ)) x = float_some_nan (:τ # χ)) ∧
   (∀mode x.
      (mode float_sub x) (float_some_nan (:τ # χ)) =
      float_some_nan (:τ # χ)) ∧
   (∀mode.
      (mode float_sub float_minus_infinity (:τ # χ))
        (float_minus_infinity (:τ # χ)) =
      float_some_nan (:τ # χ)) ∧
   (∀mode.
      (mode float_sub float_minus_infinity (:τ # χ))
        (float_plus_infinity (:τ # χ)) =
      float_minus_infinity (:τ # χ)) ∧
   (∀mode.
      (mode float_sub float_plus_infinity (:τ # χ))
        (float_plus_infinity (:τ # χ)) =
      float_some_nan (:τ # χ)) ∧
   ∀mode.
     (mode float_sub float_plus_infinity (:τ # χ))
       (float_minus_infinity (:τ # χ)) =
     float_plus_infinity (:τ # χ)
</pre>

<DT><span class="strong">float_sub_nan</span>
<DD>
<pre>
|- ∀mode x y.
     (float_value x = NaN) ∨ (float_value y = NaN) ⇒
     ((mode float_sub x) y = float_some_nan (:τ # χ))
</pre>

<DT><span class="strong">float_sub_finite</span>
<DD>
<pre>
|- ∀mode x y r1 r2.
     (float_value x = Float r1) ∧ (float_value y = Float r2) ⇒
     ((mode float_sub x) y =
      float_round mode
        (if (r1 = 0) ∧ (r2 = 0) ∧ x.Sign ≠ y.Sign then x.Sign = 1w
         else (mode = roundTowardNegative)) (r1 − r2))
</pre>

<DT><span class="strong">float_sub_finite_plus_infinity</span>
<DD>
<pre>
|- ∀mode x r.
     (float_value x = Float r) ⇒
     ((mode float_sub x) (float_plus_infinity (:τ # χ)) =
      float_minus_infinity (:τ # χ))
</pre>

<DT><span class="strong">float_sub_plus_infinity_finite</span>
<DD>
<pre>
|- ∀mode x r.
     (float_value x = Float r) ⇒
     ((mode float_sub float_plus_infinity (:τ # χ)) x =
      float_plus_infinity (:τ # χ))
</pre>

<DT><span class="strong">float_sub_finite_minus_infinity</span>
<DD>
<pre>
|- ∀mode x r.
     (float_value x = Float r) ⇒
     ((mode float_sub x) (float_minus_infinity (:τ # χ)) =
      float_plus_infinity (:τ # χ))
</pre>

<DT><span class="strong">float_sub_minus_infinity_finite</span>
<DD>
<pre>
|- ∀mode x r.
     (float_value x = Float r) ⇒
     ((mode float_sub float_minus_infinity (:τ # χ)) x =
      float_minus_infinity (:τ # χ))
</pre>

<DT><span class="strong">float_mul_compute</span>
<DD>
<pre>
|- (∀mode x.
      (mode float_mul float_some_nan (:τ # χ)) x = float_some_nan (:τ # χ)) ∧
   (∀mode x.
      (mode float_mul x) (float_some_nan (:τ # χ)) =
      float_some_nan (:τ # χ)) ∧
   (∀mode.
      (mode float_mul float_minus_infinity (:τ # χ))
        (float_minus_infinity (:τ # χ)) =
      float_plus_infinity (:τ # χ)) ∧
   (∀mode.
      (mode float_mul float_minus_infinity (:τ # χ))
        (float_plus_infinity (:τ # χ)) =
      float_minus_infinity (:τ # χ)) ∧
   (∀mode.
      (mode float_mul float_plus_infinity (:τ # χ))
        (float_plus_infinity (:τ # χ)) =
      float_plus_infinity (:τ # χ)) ∧
   ∀mode.
     (mode float_mul float_plus_infinity (:τ # χ))
       (float_minus_infinity (:τ # χ)) =
     float_minus_infinity (:τ # χ)
</pre>

<DT><span class="strong">float_mul_nan</span>
<DD>
<pre>
|- ∀mode x y.
     (float_value x = NaN) ∨ (float_value y = NaN) ⇒
     ((mode float_mul x) y = float_some_nan (:τ # χ))
</pre>

<DT><span class="strong">float_mul_finite</span>
<DD>
<pre>
|- ∀mode x y r1 r2.
     (float_value x = Float r1) ∧ (float_value y = Float r2) ⇒
     ((mode float_mul x) y = float_round mode (x.Sign ≠ y.Sign) (r1 * r2))
</pre>

<DT><span class="strong">float_mul_finite_plus_infinity</span>
<DD>
<pre>
|- ∀mode x r.
     (float_value x = Float r) ⇒
     ((mode float_mul x) (float_plus_infinity (:τ # χ)) =
      if r = 0 then float_some_nan (:τ # χ)
      else if x.Sign = 0w then float_plus_infinity (:τ # χ)
      else float_minus_infinity (:τ # χ))
</pre>

<DT><span class="strong">float_mul_plus_infinity_finite</span>
<DD>
<pre>
|- ∀mode x r.
     (float_value x = Float r) ⇒
     ((mode float_mul float_plus_infinity (:τ # χ)) x =
      if r = 0 then float_some_nan (:τ # χ)
      else if x.Sign = 0w then float_plus_infinity (:τ # χ)
      else float_minus_infinity (:τ # χ))
</pre>

<DT><span class="strong">float_mul_finite_minus_infinity</span>
<DD>
<pre>
|- ∀mode x r.
     (float_value x = Float r) ⇒
     ((mode float_mul x) (float_minus_infinity (:τ # χ)) =
      if r = 0 then float_some_nan (:τ # χ)
      else if x.Sign = 0w then float_minus_infinity (:τ # χ)
      else float_plus_infinity (:τ # χ))
</pre>

<DT><span class="strong">float_mul_minus_infinity_finite</span>
<DD>
<pre>
|- ∀mode x r.
     (float_value x = Float r) ⇒
     ((mode float_mul float_minus_infinity (:τ # χ)) x =
      if r = 0 then float_some_nan (:τ # χ)
      else if x.Sign = 0w then float_minus_infinity (:τ # χ)
      else float_plus_infinity (:τ # χ))
</pre>

<DT><span class="strong">float_div_compute</span>
<DD>
<pre>
|- (∀mode x.
      (mode float_div float_some_nan (:τ # χ)) x = float_some_nan (:τ # χ)) ∧
   (∀mode x.
      (mode float_div x) (float_some_nan (:τ # χ)) =
      float_some_nan (:τ # χ)) ∧
   (∀mode.
      (mode float_div float_minus_infinity (:τ # χ))
        (float_minus_infinity (:τ # χ)) =
      float_some_nan (:τ # χ)) ∧
   (∀mode.
      (mode float_div float_minus_infinity (:τ # χ))
        (float_plus_infinity (:τ # χ)) =
      float_some_nan (:τ # χ)) ∧
   (∀mode.
      (mode float_div float_plus_infinity (:τ # χ))
        (float_plus_infinity (:τ # χ)) =
      float_some_nan (:τ # χ)) ∧
   ∀mode.
     (mode float_div float_plus_infinity (:τ # χ))
       (float_minus_infinity (:τ # χ)) =
     float_some_nan (:τ # χ)
</pre>

<DT><span class="strong">float_div_nan</span>
<DD>
<pre>
|- ∀mode x y.
     (float_value x = NaN) ∨ (float_value y = NaN) ⇒
     ((mode float_div x) y = float_some_nan (:τ # χ))
</pre>

<DT><span class="strong">float_div_finite</span>
<DD>
<pre>
|- ∀mode x y r1 r2.
     (float_value x = Float r1) ∧ (float_value y = Float r2) ⇒
     ((mode float_div x) y =
      if r2 = 0 then
        if r1 = 0 then float_some_nan (:τ # χ)
        else if x.Sign = y.Sign then float_plus_infinity (:τ # χ)
        else float_minus_infinity (:τ # χ)
      else float_round mode (x.Sign ≠ y.Sign) (r1 / r2))
</pre>

<DT><span class="strong">float_div_finite_plus_infinity</span>
<DD>
<pre>
|- ∀mode x r.
     (float_value x = Float r) ⇒
     ((mode float_div x) (float_plus_infinity (:τ # χ)) =
      if x.Sign = 0w then float_plus_zero (:τ # χ)
      else float_minus_zero (:τ # χ))
</pre>

<DT><span class="strong">float_div_plus_infinity_finite</span>
<DD>
<pre>
|- ∀mode x r.
     (float_value x = Float r) ⇒
     ((mode float_div float_plus_infinity (:τ # χ)) x =
      if x.Sign = 0w then float_plus_infinity (:τ # χ)
      else float_minus_infinity (:τ # χ))
</pre>

<DT><span class="strong">float_div_finite_minus_infinity</span>
<DD>
<pre>
|- ∀mode x r.
     (float_value x = Float r) ⇒
     ((mode float_div x) (float_minus_infinity (:τ # χ)) =
      if x.Sign = 0w then float_minus_zero (:τ # χ)
      else float_plus_zero (:τ # χ))
</pre>

<DT><span class="strong">float_div_minus_infinity_finite</span>
<DD>
<pre>
|- ∀mode x r.
     (float_value x = Float r) ⇒
     ((mode float_div float_minus_infinity (:τ # χ)) x =
      if x.Sign = 0w then float_minus_infinity (:τ # χ)
      else float_plus_infinity (:τ # χ))
</pre>

</DL>



<hr>
</body>
</html>
