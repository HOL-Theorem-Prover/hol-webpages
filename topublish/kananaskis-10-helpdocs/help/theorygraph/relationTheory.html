<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: relation</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "relation"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "normalFormsTheory.html"><span class="strong">normalForms</span></a>&nbsp;&nbsp;
    <a href = "satTheory.html"><span class="strong">sat</span></a>&nbsp;&nbsp;
    <a href = "combinTheory.html"><span class="strong">combin</span></a>

<h1>Signature</h1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr>
    <th>
    Constant
    <th>
    Type<tr><td> <span class="strong">CR</span> <td> :α reln -> bool
    <tr><td> <span class="strong">EMPTY_REL</span> <td> :α reln
    <tr><td> <span class="strong">EQC</span> <td> :α reln -> α reln
    <tr><td> <span class="strong">IDEM</span> <td> :('z -> 'z) -> bool
    <tr><td>
        <span class="strong">INDUCTIVE_INVARIANT</span>
        <td>
        :α reln -> (α -> β -> bool) -> ((α -> β) -> α -> β) -> bool
    <tr><td>
        <span class="strong">INDUCTIVE_INVARIANT_ON</span>
        <td>
        :α reln ->
         (α -> bool) -> (α -> β -> bool) -> ((α -> β) -> α -> β) -> bool
    <tr><td> <span class="strong">INVOL</span> <td> :('z -> 'z) -> bool
    <tr><td> <span class="strong">LinearOrder</span> <td> :α reln -> bool
    <tr><td>
        <span class="strong">O</span>
        <td>
        :(θ -> 'k -> bool) -> (η -> θ -> bool) -> η -> 'k -> bool
    <tr><td> <span class="strong">Order</span> <td> :η reln -> bool
    <tr><td> <span class="strong">PreOrder</span> <td> :α reln -> bool
    <tr><td> <span class="strong">RC</span> <td> :α reln -> α reln
    <tr><td>
        <span class="strong">RCOMPL</span>
        <td>
        :(α -> β -> bool) -> α -> β -> bool
    <tr><td>
        <span class="strong">RDOM</span>
        <td>
        :(α -> β -> bool) -> α -> bool
    <tr><td>
        <span class="strong">RDOM_DELETE</span>
        <td>
        :(α -> β -> bool) -> α -> α -> β -> bool
    <tr><td>
        <span class="strong">RESTRICT</span>
        <td>
        :(α -> β) -> α reln -> α -> α -> β
    <tr><td>
        <span class="strong">RINTER</span>
        <td>
        :(α -> β -> bool) -> (α -> β -> bool) -> α -> β -> bool
    <tr><td>
        <span class="strong">RRANGE</span>
        <td>
        :(α -> β -> bool) -> β -> bool
    <tr><td>
        <span class="strong">RRESTRICT</span>
        <td>
        :(α -> β -> bool) -> (α -> bool) -> α -> β -> bool
    <tr><td> <span class="strong">RSUBSET</span> <td> :(α -> β -> bool) reln
    <tr><td> <span class="strong">RTC</span> <td> :α reln -> α reln
    <tr><td>
        <span class="strong">RUNION</span>
        <td>
        :(α -> β -> bool) -> (α -> β -> bool) -> α -> β -> bool
    <tr><td> <span class="strong">RUNIV</span> <td> :α -> β -> bool
    <tr><td> <span class="strong">SC</span> <td> :α reln -> α reln
    <tr><td> <span class="strong">SN</span> <td> :α reln -> bool
    <tr><td> <span class="strong">STRORD</span> <td> :α reln -> α reln
    <tr><td>
        <span class="strong">StrongLinearOrder</span>
        <td>
        :α reln -> bool
    <tr><td> <span class="strong">StrongOrder</span> <td> :η reln -> bool
    <tr><td> <span class="strong">TC</span> <td> :α reln -> α reln
    <tr><td> <span class="strong">WCR</span> <td> :α reln -> bool
    <tr><td> <span class="strong">WF</span> <td> :α reln -> bool
    <tr><td> <span class="strong">WFP</span> <td> :α reln -> α -> bool
    <tr><td>
        <span class="strong">WFREC</span>
        <td>
        :α reln -> ((α -> β) -> α -> β) -> α -> β
    <tr><td> <span class="strong">WeakLinearOrder</span> <td> :α reln -> bool
    <tr><td> <span class="strong">WeakOrder</span> <td> :η reln -> bool
    <tr><td> <span class="strong">antisymmetric</span> <td> :α reln -> bool
    <tr><td>
        <span class="strong">approx</span>
        <td>
        :α reln -> ((α -> β) -> α -> β) -> α -> (α -> β) -> bool
    <tr><td> <span class="strong">diag</span> <td> :(α -> bool) -> α reln
    <tr><td> <span class="strong">diamond</span> <td> :α reln -> bool
    <tr><td> <span class="strong">equivalence</span> <td> :α reln -> bool
    <tr><td> <span class="strong">inv</span> <td> :α reln -> α reln
    <tr><td>
        <span class="strong">inv_image</span>
        <td>
        :β reln -> (α -> β) -> α reln
    <tr><td> <span class="strong">irreflexive</span> <td> :α reln -> bool
    <tr><td>
        <span class="strong">nf</span>
        <td>
        :(α -> β -> bool) -> α -> bool
    <tr><td> <span class="strong">rcdiamond</span> <td> :α reln -> bool
    <tr><td> <span class="strong">reflexive</span> <td> :α reln -> bool
    <tr><td> <span class="strong">symmetric</span> <td> :α reln -> bool
    <tr><td>
        <span class="strong">the_fun</span>
        <td>
        :α reln -> ((α -> β) -> α -> β) -> α -> α -> β
    <tr><td> <span class="strong">total</span> <td> :α reln -> bool
    <tr><td> <span class="strong">transitive</span> <td> :α reln -> bool
    <tr><td> <span class="strong">trichotomous</span> <td> :α reln -> bool

</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">transitive_def</span>
<DD>
<pre>
|- ∀R. transitive R ⇔ ∀x y z. R x y ∧ R y z ⇒ R x z
</pre>

<DT><span class="strong">reflexive_def</span>
<DD>
<pre>
|- ∀R. reflexive R ⇔ ∀x. R x x
</pre>

<DT><span class="strong">irreflexive_def</span>
<DD>
<pre>
|- ∀R. irreflexive R ⇔ ∀x. ¬R x x
</pre>

<DT><span class="strong">symmetric_def</span>
<DD>
<pre>
|- ∀R. symmetric R ⇔ ∀x y. R x y ⇔ R y x
</pre>

<DT><span class="strong">antisymmetric_def</span>
<DD>
<pre>
|- ∀R. antisymmetric R ⇔ ∀x y. R x y ∧ R y x ⇒ (x = y)
</pre>

<DT><span class="strong">equivalence_def</span>
<DD>
<pre>
|- ∀R. equivalence R ⇔ reflexive R ∧ symmetric R ∧ transitive R
</pre>

<DT><span class="strong">total_def</span>
<DD>
<pre>
|- ∀R. total R ⇔ ∀x y. R x y ∨ R y x
</pre>

<DT><span class="strong">trichotomous</span>
<DD>
<pre>
|- ∀R. trichotomous R ⇔ ∀a b. R a b ∨ R b a ∨ (a = b)
</pre>

<DT><span class="strong">TC_DEF</span>
<DD>
<pre>
|- ∀R a b.
     R⁺ a b ⇔
     ∀P. (∀x y. R x y ⇒ P x y) ∧ (∀x y z. P x y ∧ P y z ⇒ P x z) ⇒ P a b
</pre>

<DT><span class="strong">RTC_DEF</span>
<DD>
<pre>
|- ∀R a b. R^* a b ⇔ ∀P. (∀x. P x x) ∧ (∀x y z. R x y ∧ P y z ⇒ P x z) ⇒ P a b
</pre>

<DT><span class="strong">RC_DEF</span>
<DD>
<pre>
|- ∀R x y. RC R x y ⇔ (x = y) ∨ R x y
</pre>

<DT><span class="strong">SC_DEF</span>
<DD>
<pre>
|- ∀R x y. SC R x y ⇔ R x y ∨ R y x
</pre>

<DT><span class="strong">EQC_DEF</span>
<DD>
<pre>
|- ∀R. R^= = RC (SC R)⁺
</pre>

<DT><span class="strong">WF_DEF</span>
<DD>
<pre>
|- ∀R. WF R ⇔ ∀B. (∃w. B w) ⇒ ∃min. B min ∧ ∀b. R b min ⇒ ¬B b
</pre>

<DT><span class="strong">EMPTY_REL_DEF</span>
<DD>
<pre>
|- ∀x y. REMPTY x y ⇔ F
</pre>

<DT><span class="strong">inv_image_def</span>
<DD>
<pre>
|- ∀R f. inv_image R f = (λx y. R (f x) (f y))
</pre>

<DT><span class="strong">RESTRICT_DEF</span>
<DD>
<pre>
|- ∀f R x. RESTRICT f R x = (λy. if R y x then f y else ARB)
</pre>

<DT><span class="strong">approx_def</span>
<DD>
<pre>
|- ∀R M x f. approx R M x f ⇔ (f = RESTRICT (λy. M (RESTRICT f R y) y) R x)
</pre>

<DT><span class="strong">the_fun_def</span>
<DD>
<pre>
|- ∀R M x. the_fun R M x = @f. approx R M x f
</pre>

<DT><span class="strong">WFREC_DEF</span>
<DD>
<pre>
|- ∀R M.
     WFREC R M =
     (λx. M (RESTRICT (the_fun R⁺ (λf v. M (RESTRICT f R v) v) x) R x) x)
</pre>

<DT><span class="strong">WFP_DEF</span>
<DD>
<pre>
|- ∀R a. WFP R a ⇔ ∀P. (∀x. (∀y. R y x ⇒ P y) ⇒ P x) ⇒ P a
</pre>

<DT><span class="strong">INDUCTIVE_INVARIANT_DEF</span>
<DD>
<pre>
|- ∀R P M.
     INDUCTIVE_INVARIANT R P M ⇔ ∀f x. (∀y. R y x ⇒ P y (f y)) ⇒ P x (M f x)
</pre>

<DT><span class="strong">INDUCTIVE_INVARIANT_ON_DEF</span>
<DD>
<pre>
|- ∀R D P M.
     INDUCTIVE_INVARIANT_ON R D P M ⇔
     ∀f x. D x ∧ (∀y. D y ⇒ R y x ⇒ P y (f y)) ⇒ P x (M f x)
</pre>

<DT><span class="strong">inv_DEF</span>
<DD>
<pre>
|- ∀R x y. inv R x y ⇔ R y x
</pre>

<DT><span class="strong">INVOL_DEF</span>
<DD>
<pre>
|- ∀f. INVOL f ⇔ (f o f = I)
</pre>

<DT><span class="strong">IDEM_DEF</span>
<DD>
<pre>
|- ∀f. IDEM f ⇔ (f o f = f)
</pre>

<DT><span class="strong">O_DEF</span>
<DD>
<pre>
|- ∀R1 R2 x z. (R1 O R2) x z ⇔ ∃y. R2 x y ∧ R1 y z
</pre>

<DT><span class="strong">RSUBSET</span>
<DD>
<pre>
|- ∀R1 R2. R1 RSUBSET R2 ⇔ ∀x y. R1 x y ⇒ R2 x y
</pre>

<DT><span class="strong">RUNION</span>
<DD>
<pre>
|- ∀R1 R2 x y. (R1 RUNION R2) x y ⇔ R1 x y ∨ R2 x y
</pre>

<DT><span class="strong">RINTER</span>
<DD>
<pre>
|- ∀R1 R2 x y. (R1 RINTER R2) x y ⇔ R1 x y ∧ R2 x y
</pre>

<DT><span class="strong">RCOMPL</span>
<DD>
<pre>
|- ∀R x y. RCOMPL R x y ⇔ ¬R x y
</pre>

<DT><span class="strong">PreOrder</span>
<DD>
<pre>
|- ∀R. PreOrder R ⇔ reflexive R ∧ transitive R
</pre>

<DT><span class="strong">Order</span>
<DD>
<pre>
|- ∀Z. Order Z ⇔ antisymmetric Z ∧ transitive Z
</pre>

<DT><span class="strong">WeakOrder</span>
<DD>
<pre>
|- ∀Z. WeakOrder Z ⇔ reflexive Z ∧ antisymmetric Z ∧ transitive Z
</pre>

<DT><span class="strong">StrongOrder</span>
<DD>
<pre>
|- ∀Z. StrongOrder Z ⇔ irreflexive Z ∧ transitive Z
</pre>

<DT><span class="strong">STRORD</span>
<DD>
<pre>
|- ∀R a b. STRORD R a b ⇔ R a b ∧ a ≠ b
</pre>

<DT><span class="strong">LinearOrder</span>
<DD>
<pre>
|- ∀R. LinearOrder R ⇔ Order R ∧ trichotomous R
</pre>

<DT><span class="strong">StrongLinearOrder</span>
<DD>
<pre>
|- ∀R. StrongLinearOrder R ⇔ StrongOrder R ∧ trichotomous R
</pre>

<DT><span class="strong">WeakLinearOrder</span>
<DD>
<pre>
|- ∀R. WeakLinearOrder R ⇔ WeakOrder R ∧ trichotomous R
</pre>

<DT><span class="strong">diag_def</span>
<DD>
<pre>
|- ∀A x y. diag A x y ⇔ (x = y) ∧ x ∈ A
</pre>

<DT><span class="strong">RDOM_DEF</span>
<DD>
<pre>
|- ∀R x. RDOM R x ⇔ ∃y. R x y
</pre>

<DT><span class="strong">RRANGE</span>
<DD>
<pre>
|- ∀R y. RRANGE R y ⇔ ∃x. R x y
</pre>

<DT><span class="strong">RUNIV</span>
<DD>
<pre>
|- ∀x y. RUNIV x y ⇔ T
</pre>

<DT><span class="strong">RRESTRICT_DEF</span>
<DD>
<pre>
|- ∀R s x y. RRESTRICT R s x y ⇔ R x y ∧ x ∈ s
</pre>

<DT><span class="strong">RDOM_DELETE_DEF</span>
<DD>
<pre>
|- ∀R x u v. (R \\ x) u v ⇔ R u v ∧ u ≠ x
</pre>

<DT><span class="strong">diamond_def</span>
<DD>
<pre>
|- ∀R. diamond R ⇔ ∀x y z. R x y ∧ R x z ⇒ ∃u. R y u ∧ R z u
</pre>

<DT><span class="strong">rcdiamond_def</span>
<DD>
<pre>
|- ∀R. rcdiamond R ⇔ ∀x y z. R x y ∧ R x z ⇒ ∃u. RC R y u ∧ RC R z u
</pre>

<DT><span class="strong">CR_def</span>
<DD>
<pre>
|- ∀R. CR R ⇔ diamond R^*
</pre>

<DT><span class="strong">WCR_def</span>
<DD>
<pre>
|- ∀R. WCR R ⇔ ∀x y z. R x y ∧ R x z ⇒ ∃u. R^* y u ∧ R^* z u
</pre>

<DT><span class="strong">SN_def</span>
<DD>
<pre>
|- ∀R. SN R ⇔ WF (inv R)
</pre>

<DT><span class="strong">nf_def</span>
<DD>
<pre>
|- ∀R x. nf R x ⇔ ∀y. ¬R x y
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">SC_SYMMETRIC</span>
<DD>
<pre>
|- ∀R. symmetric (SC R)
</pre>

<DT><span class="strong">TC_TRANSITIVE</span>
<DD>
<pre>
|- ∀R. transitive R⁺
</pre>

<DT><span class="strong">RTC_INDUCT</span>
<DD>
<pre>
|- ∀R P. (∀x. P x x) ∧ (∀x y z. R x y ∧ P y z ⇒ P x z) ⇒ ∀x y. R^* x y ⇒ P x y
</pre>

<DT><span class="strong">TC_RULES</span>
<DD>
<pre>
|- ∀R. (∀x y. R x y ⇒ R⁺ x y) ∧ ∀x y z. R⁺ x y ∧ R⁺ y z ⇒ R⁺ x z
</pre>

<DT><span class="strong">RTC_RULES</span>
<DD>
<pre>
|- ∀R. (∀x. R^* x x) ∧ ∀x y z. R x y ∧ R^* y z ⇒ R^* x z
</pre>

<DT><span class="strong">RTC_REFL</span>
<DD>
<pre>
|- R^* x x
</pre>

<DT><span class="strong">RTC_SINGLE</span>
<DD>
<pre>
|- ∀R x y. R x y ⇒ R^* x y
</pre>

<DT><span class="strong">RTC_STRONG_INDUCT</span>
<DD>
<pre>
|- ∀R P.
     (∀x. P x x) ∧ (∀x y z. R x y ∧ R^* y z ∧ P y z ⇒ P x z) ⇒
     ∀x y. R^* x y ⇒ P x y
</pre>

<DT><span class="strong">RTC_RTC</span>
<DD>
<pre>
|- ∀R x y. R^* x y ⇒ ∀z. R^* y z ⇒ R^* x z
</pre>

<DT><span class="strong">RTC_TRANSITIVE</span>
<DD>
<pre>
|- ∀R. transitive R^*
</pre>

<DT><span class="strong">transitive_RTC</span>
<DD>
<pre>
|- ∀R. transitive R^*
</pre>

<DT><span class="strong">RTC_REFLEXIVE</span>
<DD>
<pre>
|- ∀R. reflexive R^*
</pre>

<DT><span class="strong">reflexive_RTC</span>
<DD>
<pre>
|- ∀R. reflexive R^*
</pre>

<DT><span class="strong">RC_REFLEXIVE</span>
<DD>
<pre>
|- ∀R. reflexive (RC R)
</pre>

<DT><span class="strong">reflexive_RC</span>
<DD>
<pre>
|- ∀R. reflexive (RC R)
</pre>

<DT><span class="strong">RC_lifts_monotonicities</span>
<DD>
<pre>
|- (∀x y. R x y ⇒ R (f x) (f y)) ⇒ ∀x y. RC R x y ⇒ RC R (f x) (f y)
</pre>

<DT><span class="strong">RC_MONOTONE</span>
<DD>
<pre>
|- (∀x y. R x y ⇒ Q x y) ⇒ RC R x y ⇒ RC Q x y
</pre>

<DT><span class="strong">RC_lifts_invariants</span>
<DD>
<pre>
|- (∀x y. P x ∧ R x y ⇒ P y) ⇒ ∀x y. P x ∧ RC R x y ⇒ P y
</pre>

<DT><span class="strong">RC_lifts_equalities</span>
<DD>
<pre>
|- (∀x y. R x y ⇒ (f x = f y)) ⇒ ∀x y. RC R x y ⇒ (f x = f y)
</pre>

<DT><span class="strong">SC_lifts_monotonicities</span>
<DD>
<pre>
|- (∀x y. R x y ⇒ R (f x) (f y)) ⇒ ∀x y. SC R x y ⇒ SC R (f x) (f y)
</pre>

<DT><span class="strong">SC_lifts_equalities</span>
<DD>
<pre>
|- (∀x y. R x y ⇒ (f x = f y)) ⇒ ∀x y. SC R x y ⇒ (f x = f y)
</pre>

<DT><span class="strong">SC_MONOTONE</span>
<DD>
<pre>
|- (∀x y. R x y ⇒ Q x y) ⇒ SC R x y ⇒ SC Q x y
</pre>

<DT><span class="strong">symmetric_RC</span>
<DD>
<pre>
|- ∀R. symmetric (RC R) ⇔ symmetric R
</pre>

<DT><span class="strong">antisymmetric_RC</span>
<DD>
<pre>
|- ∀R. antisymmetric (RC R) ⇔ antisymmetric R
</pre>

<DT><span class="strong">transitive_RC</span>
<DD>
<pre>
|- ∀R. transitive R ⇒ transitive (RC R)
</pre>

<DT><span class="strong">TC_SUBSET</span>
<DD>
<pre>
|- ∀R x y. R x y ⇒ R⁺ x y
</pre>

<DT><span class="strong">RTC_SUBSET</span>
<DD>
<pre>
|- ∀R x y. R x y ⇒ R^* x y
</pre>

<DT><span class="strong">RC_SUBSET</span>
<DD>
<pre>
|- ∀R x y. R x y ⇒ RC R x y
</pre>

<DT><span class="strong">RC_RTC</span>
<DD>
<pre>
|- ∀R x y. RC R x y ⇒ R^* x y
</pre>

<DT><span class="strong">TC_INDUCT</span>
<DD>
<pre>
|- ∀R P.
     (∀x y. R x y ⇒ P x y) ∧ (∀x y z. P x y ∧ P y z ⇒ P x z) ⇒
     ∀u v. R⁺ u v ⇒ P u v
</pre>

<DT><span class="strong">TC_INDUCT_LEFT1</span>
<DD>
<pre>
|- ∀R P.
     (∀x y. R x y ⇒ P x y) ∧ (∀x y z. R x y ∧ P y z ⇒ P x z) ⇒
     ∀x y. R⁺ x y ⇒ P x y
</pre>

<DT><span class="strong">TC_INDUCT_RIGHT1</span>
<DD>
<pre>
|- ∀R P.
     (∀x y. R x y ⇒ P x y) ∧ (∀x y z. P x y ∧ R y z ⇒ P x z) ⇒
     ∀x y. R⁺ x y ⇒ P x y
</pre>

<DT><span class="strong">TC_STRONG_INDUCT</span>
<DD>
<pre>
|- ∀R P.
     (∀x y. R x y ⇒ P x y) ∧
     (∀x y z. P x y ∧ P y z ∧ R⁺ x y ∧ R⁺ y z ⇒ P x z) ⇒
     ∀u v. R⁺ u v ⇒ P u v
</pre>

<DT><span class="strong">TC_STRONG_INDUCT_LEFT1</span>
<DD>
<pre>
|- ∀R P.
     (∀x y. R x y ⇒ P x y) ∧ (∀x y z. R x y ∧ P y z ∧ R⁺ y z ⇒ P x z) ⇒
     ∀u v. R⁺ u v ⇒ P u v
</pre>

<DT><span class="strong">TC_STRONG_INDUCT_RIGHT1</span>
<DD>
<pre>
|- ∀R P.
     (∀x y. R x y ⇒ P x y) ∧ (∀x y z. P x y ∧ R⁺ x y ∧ R y z ⇒ P x z) ⇒
     ∀u v. R⁺ u v ⇒ P u v
</pre>

<DT><span class="strong">TC_lifts_monotonicities</span>
<DD>
<pre>
|- (∀x y. R x y ⇒ R (f x) (f y)) ⇒ ∀x y. R⁺ x y ⇒ R⁺ (f x) (f y)
</pre>

<DT><span class="strong">TC_lifts_invariants</span>
<DD>
<pre>
|- (∀x y. P x ∧ R x y ⇒ P y) ⇒ ∀x y. P x ∧ R⁺ x y ⇒ P y
</pre>

<DT><span class="strong">TC_lifts_equalities</span>
<DD>
<pre>
|- (∀x y. R x y ⇒ (f x = f y)) ⇒ ∀x y. R⁺ x y ⇒ (f x = f y)
</pre>

<DT><span class="strong">TC_lifts_transitive_relations</span>
<DD>
<pre>
|- (∀x y. R x y ⇒ Q (f x) (f y)) ∧ transitive Q ⇒ ∀x y. R⁺ x y ⇒ Q (f x) (f y)
</pre>

<DT><span class="strong">TC_implies_one_step</span>
<DD>
<pre>
|- ∀x y. R⁺ x y ∧ x ≠ y ⇒ ∃z. R x z ∧ x ≠ z
</pre>

<DT><span class="strong">TC_RTC</span>
<DD>
<pre>
|- ∀R x y. R⁺ x y ⇒ R^* x y
</pre>

<DT><span class="strong">RTC_TC_RC</span>
<DD>
<pre>
|- ∀R x y. R^* x y ⇒ RC R x y ∨ R⁺ x y
</pre>

<DT><span class="strong">TC_RC_EQNS</span>
<DD>
<pre>
|- ∀R. (RC R⁺ = R^* ) ∧ ((RC R)⁺ = R^* )
</pre>

<DT><span class="strong">RTC_INDUCT_RIGHT1</span>
<DD>
<pre>
|- ∀R P. (∀x. P x x) ∧ (∀x y z. P x y ∧ R y z ⇒ P x z) ⇒ ∀x y. R^* x y ⇒ P x y
</pre>

<DT><span class="strong">RTC_RULES_RIGHT1</span>
<DD>
<pre>
|- ∀R. (∀x. R^* x x) ∧ ∀x y z. R^* x y ∧ R y z ⇒ R^* x z
</pre>

<DT><span class="strong">RTC_STRONG_INDUCT_RIGHT1</span>
<DD>
<pre>
|- ∀R P.
     (∀x. P x x) ∧ (∀x y z. P x y ∧ R^* x y ∧ R y z ⇒ P x z) ⇒
     ∀x y. R^* x y ⇒ P x y
</pre>

<DT><span class="strong">EXTEND_RTC_TC</span>
<DD>
<pre>
|- ∀R x y z. R x y ∧ R^* y z ⇒ R⁺ x z
</pre>

<DT><span class="strong">EXTEND_RTC_TC_EQN</span>
<DD>
<pre>
|- ∀R x z. R⁺ x z ⇔ ∃y. R x y ∧ R^* y z
</pre>

<DT><span class="strong">reflexive_RC_identity</span>
<DD>
<pre>
|- ∀R. reflexive R ⇒ (RC R = R)
</pre>

<DT><span class="strong">symmetric_SC_identity</span>
<DD>
<pre>
|- ∀R. symmetric R ⇒ (SC R = R)
</pre>

<DT><span class="strong">transitive_TC_identity</span>
<DD>
<pre>
|- ∀R. transitive R ⇒ (R⁺ = R)
</pre>

<DT><span class="strong">RC_IDEM</span>
<DD>
<pre>
|- ∀R. RC (RC R) = RC R
</pre>

<DT><span class="strong">SC_IDEM</span>
<DD>
<pre>
|- ∀R. SC (SC R) = SC R
</pre>

<DT><span class="strong">TC_IDEM</span>
<DD>
<pre>
|- ∀R. R⁺ ⁺ = R⁺
</pre>

<DT><span class="strong">RC_MOVES_OUT</span>
<DD>
<pre>
|- ∀R. (SC (RC R) = RC (SC R)) ∧ (RC (RC R) = RC R) ∧ ((RC R)⁺ = RC R⁺)
</pre>

<DT><span class="strong">symmetric_TC</span>
<DD>
<pre>
|- ∀R. symmetric R ⇒ symmetric R⁺
</pre>

<DT><span class="strong">reflexive_TC</span>
<DD>
<pre>
|- ∀R. reflexive R ⇒ reflexive R⁺
</pre>

<DT><span class="strong">EQC_EQUIVALENCE</span>
<DD>
<pre>
|- ∀R. equivalence R^=
</pre>

<DT><span class="strong">EQC_IDEM</span>
<DD>
<pre>
|- ∀R. R^= ^= = R^=
</pre>

<DT><span class="strong">RTC_IDEM</span>
<DD>
<pre>
|- ∀R. R^* ^* = R^*
</pre>

<DT><span class="strong">RTC_CASES1</span>
<DD>
<pre>
|- ∀R x y. R^* x y ⇔ (x = y) ∨ ∃u. R x u ∧ R^* u y
</pre>

<DT><span class="strong">RTC_CASES_TC</span>
<DD>
<pre>
|- ∀R x y. R^* x y ⇔ (x = y) ∨ R⁺ x y
</pre>

<DT><span class="strong">RTC_CASES2</span>
<DD>
<pre>
|- ∀R x y. R^* x y ⇔ (x = y) ∨ ∃u. R^* x u ∧ R u y
</pre>

<DT><span class="strong">RTC_CASES_RTC_TWICE</span>
<DD>
<pre>
|- ∀R x y. R^* x y ⇔ ∃u. R^* x u ∧ R^* u y
</pre>

<DT><span class="strong">TC_CASES1_E</span>
<DD>
<pre>
|- ∀R x z. R⁺ x z ⇒ R x z ∨ ∃y. R x y ∧ R⁺ y z
</pre>

<DT><span class="strong">TC_CASES1</span>
<DD>
<pre>
|- R⁺ x z ⇔ R x z ∨ ∃y. R x y ∧ R⁺ y z
</pre>

<DT><span class="strong">TC_CASES2_E</span>
<DD>
<pre>
|- ∀R x z. R⁺ x z ⇒ R x z ∨ ∃y. R⁺ x y ∧ R y z
</pre>

<DT><span class="strong">TC_CASES2</span>
<DD>
<pre>
|- R⁺ x z ⇔ R x z ∨ ∃y. R⁺ x y ∧ R y z
</pre>

<DT><span class="strong">TC_MONOTONE</span>
<DD>
<pre>
|- (∀x y. R x y ⇒ Q x y) ⇒ R⁺ x y ⇒ Q⁺ x y
</pre>

<DT><span class="strong">RTC_MONOTONE</span>
<DD>
<pre>
|- (∀x y. R x y ⇒ Q x y) ⇒ R^* x y ⇒ Q^* x y
</pre>

<DT><span class="strong">EQC_INDUCTION</span>
<DD>
<pre>
|- ∀R P.
     (∀x y. R x y ⇒ P x y) ∧ (∀x. P x x) ∧ (∀x y. P x y ⇒ P y x) ∧
     (∀x y z. P x y ∧ P y z ⇒ P x z) ⇒
     ∀x y. R^= x y ⇒ P x y
</pre>

<DT><span class="strong">EQC_REFL</span>
<DD>
<pre>
|- ∀R x. R^= x x
</pre>

<DT><span class="strong">EQC_R</span>
<DD>
<pre>
|- ∀R x y. R x y ⇒ R^= x y
</pre>

<DT><span class="strong">EQC_SYM</span>
<DD>
<pre>
|- ∀R x y. R^= x y ⇒ R^= y x
</pre>

<DT><span class="strong">EQC_TRANS</span>
<DD>
<pre>
|- ∀R x y z. R^= x y ∧ R^= y z ⇒ R^= x z
</pre>

<DT><span class="strong">transitive_EQC</span>
<DD>
<pre>
|- transitive R^=
</pre>

<DT><span class="strong">symmetric_EQC</span>
<DD>
<pre>
|- symmetric R^=
</pre>

<DT><span class="strong">reflexive_EQC</span>
<DD>
<pre>
|- reflexive R^=
</pre>

<DT><span class="strong">EQC_MOVES_IN</span>
<DD>
<pre>
|- ∀R. ((RC R)^= = R^=) ∧ ((SC R)^= = R^=) ∧ (R⁺ ^= = R^=)
</pre>

<DT><span class="strong">STRONG_EQC_INDUCTION</span>
<DD>
<pre>
|- ∀R P.
     (∀x y. R x y ⇒ P x y) ∧ (∀x. P x x) ∧ (∀x y. R^= x y ∧ P x y ⇒ P y x) ∧
     (∀x y z. P x y ∧ P y z ∧ R^= x y ∧ R^= y z ⇒ P x z) ⇒
     ∀x y. R^= x y ⇒ P x y
</pre>

<DT><span class="strong">ALT_equivalence</span>
<DD>
<pre>
|- ∀R. equivalence R ⇔ ∀x y. R x y ⇔ (R x = R y)
</pre>

<DT><span class="strong">EQC_MONOTONE</span>
<DD>
<pre>
|- (∀x y. R x y ⇒ R' x y) ⇒ R^= x y ⇒ R'^= x y
</pre>

<DT><span class="strong">RTC_EQC</span>
<DD>
<pre>
|- ∀x y. R^* x y ⇒ R^= x y
</pre>

<DT><span class="strong">RTC_lifts_monotonicities</span>
<DD>
<pre>
|- (∀x y. R x y ⇒ R (f x) (f y)) ⇒ ∀x y. R^* x y ⇒ R^* (f x) (f y)
</pre>

<DT><span class="strong">RTC_lifts_reflexive_transitive_relations</span>
<DD>
<pre>
|- (∀x y. R x y ⇒ Q (f x) (f y)) ∧ reflexive Q ∧ transitive Q ⇒
   ∀x y. R^* x y ⇒ Q (f x) (f y)
</pre>

<DT><span class="strong">RTC_lifts_equalities</span>
<DD>
<pre>
|- (∀x y. R x y ⇒ (f x = f y)) ⇒ ∀x y. R^* x y ⇒ (f x = f y)
</pre>

<DT><span class="strong">RTC_lifts_invariants</span>
<DD>
<pre>
|- (∀x y. P x ∧ R x y ⇒ P y) ⇒ ∀x y. P x ∧ R^* x y ⇒ P y
</pre>

<DT><span class="strong">WF_INDUCTION_THM</span>
<DD>
<pre>
|- ∀R. WF R ⇒ ∀P. (∀x. (∀y. R y x ⇒ P y) ⇒ P x) ⇒ ∀x. P x
</pre>

<DT><span class="strong">INDUCTION_WF_THM</span>
<DD>
<pre>
|- ∀R. (∀P. (∀x. (∀y. R y x ⇒ P y) ⇒ P x) ⇒ ∀x. P x) ⇒ WF R
</pre>

<DT><span class="strong">WF_EQ_INDUCTION_THM</span>
<DD>
<pre>
|- ∀R. WF R ⇔ ∀P. (∀x. (∀y. R y x ⇒ P y) ⇒ P x) ⇒ ∀x. P x
</pre>

<DT><span class="strong">WF_NOT_REFL</span>
<DD>
<pre>
|- ∀R x y. WF R ⇒ R x y ⇒ x ≠ y
</pre>

<DT><span class="strong">WF_irreflexive</span>
<DD>
<pre>
|- WF R ⇒ irreflexive R
</pre>

<DT><span class="strong">WF_EMPTY_REL</span>
<DD>
<pre>
|- WF REMPTY
</pre>

<DT><span class="strong">WF_SUBSET</span>
<DD>
<pre>
|- ∀R P. WF R ∧ (∀x y. P x y ⇒ R x y) ⇒ WF P
</pre>

<DT><span class="strong">WF_TC</span>
<DD>
<pre>
|- ∀R. WF R ⇒ WF R⁺
</pre>

<DT><span class="strong">WF_TC_EQN</span>
<DD>
<pre>
|- WF R⁺ ⇔ WF R
</pre>

<DT><span class="strong">WF_noloops</span>
<DD>
<pre>
|- WF R ⇒ R⁺ x y ⇒ x ≠ y
</pre>

<DT><span class="strong">WF_antisymmetric</span>
<DD>
<pre>
|- WF R ⇒ antisymmetric R
</pre>

<DT><span class="strong">inv_image_thm</span>
<DD>
<pre>
|- ∀R f x y. inv_image R f x y ⇔ R (f x) (f y)
</pre>

<DT><span class="strong">WF_inv_image</span>
<DD>
<pre>
|- ∀R f. WF R ⇒ WF (inv_image R f)
</pre>

<DT><span class="strong">total_inv_image</span>
<DD>
<pre>
|- ∀R f. total R ⇒ total (inv_image R f)
</pre>

<DT><span class="strong">reflexive_inv_image</span>
<DD>
<pre>
|- ∀R f. reflexive R ⇒ reflexive (inv_image R f)
</pre>

<DT><span class="strong">symmetric_inv_image</span>
<DD>
<pre>
|- ∀R f. symmetric R ⇒ symmetric (inv_image R f)
</pre>

<DT><span class="strong">transitive_inv_image</span>
<DD>
<pre>
|- ∀R f. transitive R ⇒ transitive (inv_image R f)
</pre>

<DT><span class="strong">RESTRICT_LEMMA</span>
<DD>
<pre>
|- ∀f R y z. R y z ⇒ (RESTRICT f R z y = f y)
</pre>

<DT><span class="strong">WFREC_THM</span>
<DD>
<pre>
|- ∀R M. WF R ⇒ ∀x. WFREC R M x = M (RESTRICT (WFREC R M) R x) x
</pre>

<DT><span class="strong">WFREC_COROLLARY</span>
<DD>
<pre>
|- ∀M R f. (f = WFREC R M) ⇒ WF R ⇒ ∀x. f x = M (RESTRICT f R x) x
</pre>

<DT><span class="strong">WF_RECURSION_THM</span>
<DD>
<pre>
|- ∀R. WF R ⇒ ∀M. ∃!f. ∀x. f x = M (RESTRICT f R x) x
</pre>

<DT><span class="strong">WFP_RULES</span>
<DD>
<pre>
|- ∀R x. (∀y. R y x ⇒ WFP R y) ⇒ WFP R x
</pre>

<DT><span class="strong">WFP_INDUCT</span>
<DD>
<pre>
|- ∀R P. (∀x. (∀y. R y x ⇒ P y) ⇒ P x) ⇒ ∀x. WFP R x ⇒ P x
</pre>

<DT><span class="strong">WFP_CASES</span>
<DD>
<pre>
|- ∀R x. WFP R x ⇔ ∀y. R y x ⇒ WFP R y
</pre>

<DT><span class="strong">WFP_STRONG_INDUCT</span>
<DD>
<pre>
|- ∀R. (∀x. WFP R x ∧ (∀y. R y x ⇒ P y) ⇒ P x) ⇒ ∀x. WFP R x ⇒ P x
</pre>

<DT><span class="strong">WF_EQ_WFP</span>
<DD>
<pre>
|- ∀R. WF R ⇔ ∀x. WFP R x
</pre>

<DT><span class="strong">INDUCTIVE_INVARIANT_WFREC</span>
<DD>
<pre>
|- ∀R P M. WF R ∧ INDUCTIVE_INVARIANT R P M ⇒ ∀x. P x (WFREC R M x)
</pre>

<DT><span class="strong">TFL_INDUCTIVE_INVARIANT_WFREC</span>
<DD>
<pre>
|- ∀f R P M x. (f = WFREC R M) ∧ WF R ∧ INDUCTIVE_INVARIANT R P M ⇒ P x (f x)
</pre>

<DT><span class="strong">INDUCTIVE_INVARIANT_ON_WFREC</span>
<DD>
<pre>
|- ∀R P M D x. WF R ∧ INDUCTIVE_INVARIANT_ON R D P M ∧ D x ⇒ P x (WFREC R M x)
</pre>

<DT><span class="strong">TFL_INDUCTIVE_INVARIANT_ON_WFREC</span>
<DD>
<pre>
|- ∀f R D P M x.
     (f = WFREC R M) ∧ WF R ∧ INDUCTIVE_INVARIANT_ON R D P M ∧ D x ⇒ P x (f x)
</pre>

<DT><span class="strong">inv_inv</span>
<DD>
<pre>
|- ∀R. inv (inv R) = R
</pre>

<DT><span class="strong">inv_RC</span>
<DD>
<pre>
|- ∀R. inv (RC R) = RC (inv R)
</pre>

<DT><span class="strong">inv_SC</span>
<DD>
<pre>
|- ∀R. (inv (SC R) = SC R) ∧ (SC (inv R) = SC R)
</pre>

<DT><span class="strong">inv_TC</span>
<DD>
<pre>
|- ∀R. inv R⁺ = (inv R)⁺
</pre>

<DT><span class="strong">inv_EQC</span>
<DD>
<pre>
|- ∀R. (inv R^= = R^=) ∧ ((inv R)^= = R^=)
</pre>

<DT><span class="strong">inv_MOVES_OUT</span>
<DD>
<pre>
|- ∀R.
     (inv (inv R) = R) ∧ (SC (inv R) = SC R) ∧ (RC (inv R) = inv (RC R)) ∧
     ((inv R)⁺ = inv R⁺) ∧ ((inv R)^* = inv R^* ) ∧ ((inv R)^= = R^=)
</pre>

<DT><span class="strong">reflexive_inv</span>
<DD>
<pre>
|- ∀R. reflexive (inv R) ⇔ reflexive R
</pre>

<DT><span class="strong">irreflexive_inv</span>
<DD>
<pre>
|- ∀R. irreflexive (inv R) ⇔ irreflexive R
</pre>

<DT><span class="strong">symmetric_inv</span>
<DD>
<pre>
|- ∀R. symmetric (inv R) ⇔ symmetric R
</pre>

<DT><span class="strong">antisymmetric_inv</span>
<DD>
<pre>
|- ∀R. antisymmetric (inv R) ⇔ antisymmetric R
</pre>

<DT><span class="strong">transitive_inv</span>
<DD>
<pre>
|- ∀R. transitive (inv R) ⇔ transitive R
</pre>

<DT><span class="strong">symmetric_inv_identity</span>
<DD>
<pre>
|- ∀R. symmetric R ⇒ (inv R = R)
</pre>

<DT><span class="strong">equivalence_inv_identity</span>
<DD>
<pre>
|- ∀R. equivalence R ⇒ (inv R = R)
</pre>

<DT><span class="strong">INVOL</span>
<DD>
<pre>
|- ∀f. INVOL f ⇔ ∀x. f (f x) = x
</pre>

<DT><span class="strong">INVOL_ONE_ONE</span>
<DD>
<pre>
|- ∀f. INVOL f ⇒ ∀a b. (f a = f b) ⇔ (a = b)
</pre>

<DT><span class="strong">INVOL_ONE_ENO</span>
<DD>
<pre>
|- ∀f. INVOL f ⇒ ∀a b. (f a = b) ⇔ (a = f b)
</pre>

<DT><span class="strong">NOT_INVOL</span>
<DD>
<pre>
|- INVOL $~
</pre>

<DT><span class="strong">IDEM</span>
<DD>
<pre>
|- ∀f. IDEM f ⇔ ∀x. f (f x) = f x
</pre>

<DT><span class="strong">inv_INVOL</span>
<DD>
<pre>
|- INVOL inv
</pre>

<DT><span class="strong">inv_O</span>
<DD>
<pre>
|- ∀R R'. inv (R O R') = inv R' O inv R
</pre>

<DT><span class="strong">irreflexive_RSUBSET</span>
<DD>
<pre>
|- ∀R1 R2. irreflexive R2 ∧ R1 RSUBSET R2 ⇒ irreflexive R1
</pre>

<DT><span class="strong">RUNION_COMM</span>
<DD>
<pre>
|- R1 RUNION R2 = R2 RUNION R1
</pre>

<DT><span class="strong">RUNION_ASSOC</span>
<DD>
<pre>
|- R1 RUNION (R2 RUNION R3) = R1 RUNION R2 RUNION R3
</pre>

<DT><span class="strong">RINTER_COMM</span>
<DD>
<pre>
|- R1 RINTER R2 = R2 RINTER R1
</pre>

<DT><span class="strong">RINTER_ASSOC</span>
<DD>
<pre>
|- R1 RINTER (R2 RINTER R3) = R1 RINTER R2 RINTER R3
</pre>

<DT><span class="strong">antisymmetric_RINTER</span>
<DD>
<pre>
|- (antisymmetric R1 ⇒ antisymmetric (R1 RINTER R2)) ∧
   (antisymmetric R2 ⇒ antisymmetric (R1 RINTER R2))
</pre>

<DT><span class="strong">transitive_RINTER</span>
<DD>
<pre>
|- transitive R1 ∧ transitive R2 ⇒ transitive (R1 RINTER R2)
</pre>

<DT><span class="strong">reflexive_Id_RSUBSET</span>
<DD>
<pre>
|- ∀R. reflexive R ⇔ $= RSUBSET R
</pre>

<DT><span class="strong">symmetric_inv_RSUBSET</span>
<DD>
<pre>
|- symmetric R ⇔ inv R RSUBSET R
</pre>

<DT><span class="strong">transitive_O_RSUBSET</span>
<DD>
<pre>
|- transitive R ⇔ R O R RSUBSET R
</pre>

<DT><span class="strong">irrefl_trans_implies_antisym</span>
<DD>
<pre>
|- ∀R. irreflexive R ∧ transitive R ⇒ antisymmetric R
</pre>

<DT><span class="strong">StrongOrd_Ord</span>
<DD>
<pre>
|- ∀R. StrongOrder R ⇒ Order R
</pre>

<DT><span class="strong">WeakOrd_Ord</span>
<DD>
<pre>
|- ∀R. WeakOrder R ⇒ Order R
</pre>

<DT><span class="strong">WeakOrder_EQ</span>
<DD>
<pre>
|- ∀R. WeakOrder R ⇒ ∀y z. (y = z) ⇔ R y z ∧ R z y
</pre>

<DT><span class="strong">RSUBSET_ANTISYM</span>
<DD>
<pre>
|- ∀R1 R2. R1 RSUBSET R2 ∧ R2 RSUBSET R1 ⇒ (R1 = R2)
</pre>

<DT><span class="strong">RSUBSET_antisymmetric</span>
<DD>
<pre>
|- antisymmetric $RSUBSET
</pre>

<DT><span class="strong">RSUBSET_WeakOrder</span>
<DD>
<pre>
|- WeakOrder $RSUBSET
</pre>

<DT><span class="strong">EqIsBothRSUBSET</span>
<DD>
<pre>
|- ∀y z. (y = z) ⇔ y RSUBSET z ∧ z RSUBSET y
</pre>

<DT><span class="strong">STRORD_AND_NOT_Id</span>
<DD>
<pre>
|- STRORD R = R RINTER RCOMPL $=
</pre>

<DT><span class="strong">RC_OR_Id</span>
<DD>
<pre>
|- RC R = R RUNION $=
</pre>

<DT><span class="strong">RC_Weak</span>
<DD>
<pre>
|- Order R ⇔ WeakOrder (RC R)
</pre>

<DT><span class="strong">STRORD_Strong</span>
<DD>
<pre>
|- ∀R. Order R ⇔ StrongOrder (STRORD R)
</pre>

<DT><span class="strong">STRORD_RC</span>
<DD>
<pre>
|- ∀R. StrongOrder R ⇒ (STRORD (RC R) = R)
</pre>

<DT><span class="strong">RC_STRORD</span>
<DD>
<pre>
|- ∀R. WeakOrder R ⇒ (RC (STRORD R) = R)
</pre>

<DT><span class="strong">IDEM_STRORD</span>
<DD>
<pre>
|- IDEM STRORD
</pre>

<DT><span class="strong">IDEM_RC</span>
<DD>
<pre>
|- IDEM RC
</pre>

<DT><span class="strong">IDEM_SC</span>
<DD>
<pre>
|- IDEM SC
</pre>

<DT><span class="strong">IDEM_TC</span>
<DD>
<pre>
|- IDEM TC
</pre>

<DT><span class="strong">IDEM_RTC</span>
<DD>
<pre>
|- IDEM RTC
</pre>

<DT><span class="strong">trichotomous_STRORD</span>
<DD>
<pre>
|- trichotomous (STRORD R) ⇔ trichotomous R
</pre>

<DT><span class="strong">trichotomous_RC</span>
<DD>
<pre>
|- trichotomous (RC R) ⇔ trichotomous R
</pre>

<DT><span class="strong">WeakLinearOrder_dichotomy</span>
<DD>
<pre>
|- ∀R. WeakLinearOrder R ⇔ WeakOrder R ∧ ∀a b. R a b ∨ R b a
</pre>

<DT><span class="strong">O_ASSOC</span>
<DD>
<pre>
|- R1 O R2 O R3 = (R1 O R2) O R3
</pre>

<DT><span class="strong">Id_O</span>
<DD>
<pre>
|- $= O R = R
</pre>

<DT><span class="strong">O_Id</span>
<DD>
<pre>
|- R O $= = R
</pre>

<DT><span class="strong">O_MONO</span>
<DD>
<pre>
|- R1 RSUBSET R2 ∧ S1 RSUBSET S2 ⇒ R1 O S1 RSUBSET R2 O S2
</pre>

<DT><span class="strong">inv_Id</span>
<DD>
<pre>
|- inv $= = $=
</pre>

<DT><span class="strong">inv_diag</span>
<DD>
<pre>
|- inv (diag A) = diag A
</pre>

<DT><span class="strong">IN_RDOM</span>
<DD>
<pre>
|- x ∈ RDOM R ⇔ ∃y. R x y
</pre>

<DT><span class="strong">IN_RRANGE</span>
<DD>
<pre>
|- y ∈ RRANGE R ⇔ ∃x. R x y
</pre>

<DT><span class="strong">IN_RDOM_RUNION</span>
<DD>
<pre>
|- x ∈ RDOM (R1 RUNION R2) ⇔ x ∈ RDOM R1 ∨ x ∈ RDOM R2
</pre>

<DT><span class="strong">RUNIV_SUBSET</span>
<DD>
<pre>
|- (RUNIV RSUBSET R ⇔ (R = RUNIV)) ∧ R RSUBSET RUNIV
</pre>

<DT><span class="strong">REMPTY_SUBSET</span>
<DD>
<pre>
|- REMPTY RSUBSET R ∧ (R RSUBSET REMPTY ⇔ (R = REMPTY))
</pre>

<DT><span class="strong">IN_RDOM_RRESTRICT</span>
<DD>
<pre>
|- x ∈ RDOM (RRESTRICT R s) ⇔ x ∈ RDOM R ∧ x ∈ s
</pre>

<DT><span class="strong">IN_RDOM_DELETE</span>
<DD>
<pre>
|- x ∈ RDOM (R \\ k) ⇔ x ∈ RDOM R ∧ x ≠ k
</pre>

<DT><span class="strong">rcdiamond_diamond</span>
<DD>
<pre>
|- ∀R. rcdiamond R ⇔ diamond (RC R)
</pre>

<DT><span class="strong">diamond_RC_diamond</span>
<DD>
<pre>
|- ∀R. diamond R ⇒ diamond (RC R)
</pre>

<DT><span class="strong">diamond_TC_diamond</span>
<DD>
<pre>
|- ∀R. diamond R ⇒ diamond R⁺
</pre>

<DT><span class="strong">establish_CR</span>
<DD>
<pre>
|- ∀R. (rcdiamond R ⇒ CR R) ∧ (diamond R ⇒ CR R)
</pre>

<DT><span class="strong">Newmans_lemma</span>
<DD>
<pre>
|- ∀R. WCR R ∧ SN R ⇒ CR R
</pre>

</DL>



<hr>
</body>
</html>
