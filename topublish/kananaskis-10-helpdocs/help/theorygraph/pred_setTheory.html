<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: pred_set</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "pred_set"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "numpairTheory.html"><span class="strong">numpair</span></a>

<h1>Signature</h1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr>
    <th>
    Constant
    <th>
    Type<tr><td>
            <span class="strong">BIGINTER</span>
            <td>
            :((Ξ± -> bool) -> bool) -> Ξ± -> bool
    <tr><td>
        <span class="strong">BIGUNION</span>
        <td>
        :((Ξ± -> bool) -> bool) -> Ξ± -> bool
    <tr><td>
        <span class="strong">BIJ</span>
        <td>
        :(Ξ± -> Ξ²) -> (Ξ± -> bool) -> (Ξ² -> bool) -> bool
    <tr><td> <span class="strong">CARD</span> <td> :(Ξ± -> bool) -> num
    <tr><td> <span class="strong">CHOICE</span> <td> :(Ξ± -> bool) -> Ξ±
    <tr><td> <span class="strong">COMPL</span> <td> :(Ξ± -> bool) -> Ξ± -> bool
    <tr><td>
        <span class="strong">CROSS</span>
        <td>
        :(Ξ± -> bool) -> (Ξ² -> bool) -> Ξ± # Ξ² -> bool
    <tr><td> <span class="strong">DELETE</span> <td> :(Ξ± -> bool) -> Ξ± reln
    <tr><td>
        <span class="strong">DIFF</span>
        <td>
        :(Ξ± -> bool) -> (Ξ± -> bool) -> Ξ± -> bool
    <tr><td> <span class="strong">DISJOINT</span> <td> :(Ξ± -> bool) reln
    <tr><td> <span class="strong">EMPTY</span> <td> :Ξ± -> bool
    <tr><td> <span class="strong">FINITE</span> <td> :(Ξ± -> bool) -> bool
    <tr><td>
        <span class="strong">GSPEC</span>
        <td>
        :(Ξ² -> Ξ± # bool) -> Ξ± -> bool
    <tr><td>
        <span class="strong">IMAGE</span>
        <td>
        :(Ξ± -> Ξ²) -> (Ξ± -> bool) -> Ξ² -> bool
    <tr><td>
        <span class="strong">INJ</span>
        <td>
        :(Ξ± -> Ξ²) -> (Ξ± -> bool) -> (Ξ² -> bool) -> bool
    <tr><td>
        <span class="strong">INSERT</span>
        <td>
        :Ξ± -> (Ξ± -> bool) -> Ξ± -> bool
    <tr><td>
        <span class="strong">INTER</span>
        <td>
        :(Ξ± -> bool) -> (Ξ± -> bool) -> Ξ± -> bool
    <tr><td>
        <span class="strong">ITSET</span>
        <td>
        :(Ξ± -> Ξ² -> Ξ²) -> (Ξ± -> bool) -> Ξ² -> Ξ²
    <tr><td>
        <span class="strong">ITSET_tupled</span>
        <td>
        :(Ξ± -> Ξ² -> Ξ²) -> (Ξ± -> bool) # Ξ² -> Ξ²
    <tr><td>
        <span class="strong">LINV</span>
        <td>
        :(Ξ± -> Ξ²) -> (Ξ± -> bool) -> Ξ² -> Ξ±
    <tr><td> <span class="strong">MAX_SET</span> <td> :(num -> bool) -> num
    <tr><td> <span class="strong">MIN_SET</span> <td> :(num -> bool) -> num
    <tr><td> <span class="strong">POW</span> <td> :(Ξ± -> bool) reln
    <tr><td>
        <span class="strong">PROD_IMAGE</span>
        <td>
        :(Ξ± -> num) -> (Ξ± -> bool) -> num
    <tr><td> <span class="strong">PROD_SET</span> <td> :(num -> bool) -> num
    <tr><td> <span class="strong">PSUBSET</span> <td> :(Ξ± -> bool) reln
    <tr><td>
        <span class="strong">REL_RESTRICT</span>
        <td>
        :Ξ± reln -> (Ξ± -> bool) -> Ξ± reln
    <tr><td> <span class="strong">REST</span> <td> :(Ξ± -> bool) -> Ξ± -> bool
    <tr><td>
        <span class="strong">RINV</span>
        <td>
        :(Ξ± -> Ξ²) -> (Ξ± -> bool) -> Ξ² -> Ξ±
    <tr><td> <span class="strong">SING</span> <td> :(Ξ± -> bool) -> bool
    <tr><td> <span class="strong">SUBSET</span> <td> :(Ξ± -> bool) reln
    <tr><td>
        <span class="strong">SUM_IMAGE</span>
        <td>
        :(Ξ± -> num) -> (Ξ± -> bool) -> num
    <tr><td> <span class="strong">SUM_SET</span> <td> :(num -> bool) -> num
    <tr><td>
        <span class="strong">SURJ</span>
        <td>
        :(Ξ± -> Ξ²) -> (Ξ± -> bool) -> (Ξ² -> bool) -> bool
    <tr><td>
        <span class="strong">UNION</span>
        <td>
        :(Ξ± -> bool) -> (Ξ± -> bool) -> Ξ± -> bool
    <tr><td> <span class="strong">UNIV</span> <td> :Ξ± -> bool
    <tr><td> <span class="strong">chooser</span> <td> :(Ξ± -> bool) -> num -> Ξ±
    <tr><td> <span class="strong">count</span> <td> :num reln
    <tr><td> <span class="strong">countable</span> <td> :(Ξ± -> bool) -> bool
    <tr><td>
        <span class="strong">equiv_on</span>
        <td>
        :Ξ± reln -> (Ξ± -> bool) -> bool
    <tr><td> <span class="strong">num_to_pair</span> <td> :num -> num # num
    <tr><td> <span class="strong">pair_to_num</span> <td> :num # num -> num
    <tr><td>
        <span class="strong">pairwise</span>
        <td>
        :Ξ± reln -> (Ξ± -> bool) -> bool
    <tr><td>
        <span class="strong">partition</span>
        <td>
        :Ξ± reln -> (Ξ± -> bool) reln

</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">GSPECIFICATION</span>
<DD>
<pre>
|- β€f v. v β GSPEC f β‡” βƒx. (v,T) = f x
</pre>

<DT><span class="strong">EMPTY_DEF</span>
<DD>
<pre>
|- β… = (Ξ»x. F)
</pre>

<DT><span class="strong">UNIV_DEF</span>
<DD>
<pre>
|- π•(:Ξ±) = (Ξ»x. T)
</pre>

<DT><span class="strong">SUBSET_DEF</span>
<DD>
<pre>
|- β€s t. s β† t β‡” β€x. x β s β‡’ x β t
</pre>

<DT><span class="strong">PSUBSET_DEF</span>
<DD>
<pre>
|- β€s t. s β‚ t β‡” s β† t β§ s β‰  t
</pre>

<DT><span class="strong">UNION_DEF</span>
<DD>
<pre>
|- β€s t. s β t = {x | x β s β¨ x β t}
</pre>

<DT><span class="strong">INTER_DEF</span>
<DD>
<pre>
|- β€s t. s β© t = {x | x β s β§ x β t}
</pre>

<DT><span class="strong">DISJOINT_DEF</span>
<DD>
<pre>
|- β€s t. DISJOINT s t β‡” (s β© t = β…)
</pre>

<DT><span class="strong">DIFF_DEF</span>
<DD>
<pre>
|- β€s t. s DIFF t = {x | x β s β§ x β‰ t}
</pre>

<DT><span class="strong">INSERT_DEF</span>
<DD>
<pre>
|- β€x s. x INSERT s = {y | (y = x) β¨ y β s}
</pre>

<DT><span class="strong">DELETE_DEF</span>
<DD>
<pre>
|- β€s x. s DELETE x = s DIFF {x}
</pre>

<DT><span class="strong">CHOICE_DEF</span>
<DD>
<pre>
|- β€s. s β‰  β… β‡’ CHOICE s β s
</pre>

<DT><span class="strong">REST_DEF</span>
<DD>
<pre>
|- β€s. REST s = s DELETE CHOICE s
</pre>

<DT><span class="strong">SING_DEF</span>
<DD>
<pre>
|- β€s. SING s β‡” βƒx. s = {x}
</pre>

<DT><span class="strong">IMAGE_DEF</span>
<DD>
<pre>
|- β€f s. IMAGE f s = {f x | x β s}
</pre>

<DT><span class="strong">INJ_DEF</span>
<DD>
<pre>
|- β€f s t.
     INJ f s t β‡”
     (β€x. x β s β‡’ f x β t) β§ β€x y. x β s β§ y β s β‡’ (f x = f y) β‡’ (x = y)
</pre>

<DT><span class="strong">SURJ_DEF</span>
<DD>
<pre>
|- β€f s t.
     SURJ f s t β‡” (β€x. x β s β‡’ f x β t) β§ β€x. x β t β‡’ βƒy. y β s β§ (f y = x)
</pre>

<DT><span class="strong">BIJ_DEF</span>
<DD>
<pre>
|- β€f s t. BIJ f s t β‡” INJ f s t β§ SURJ f s t
</pre>

<DT><span class="strong">LINV_DEF</span>
<DD>
<pre>
|- β€f s t. INJ f s t β‡’ β€x. x β s β‡’ (LINV f s (f x) = x)
</pre>

<DT><span class="strong">RINV_DEF</span>
<DD>
<pre>
|- β€f s t. SURJ f s t β‡’ β€x. x β t β‡’ (f (RINV f s x) = x)
</pre>

<DT><span class="strong">FINITE_DEF</span>
<DD>
<pre>
|- β€s. FINITE s β‡” β€P. P β… β§ (β€s. P s β‡’ β€e. P (e INSERT s)) β‡’ P s
</pre>

<DT><span class="strong">REL_RESTRICT_DEF</span>
<DD>
<pre>
|- β€R s x y. REL_RESTRICT R s x y β‡” x β s β§ y β s β§ R x y
</pre>

<DT><span class="strong">CARD_DEF</span>
<DD>
<pre>
|- (CARD β… = 0) β§
   β€s.
     FINITE s β‡’ β€x. CARD (x INSERT s) = if x β s then CARD s else SUC (CARD s)
</pre>

<DT><span class="strong">BIGUNION</span>
<DD>
<pre>
|- β€P. BIGUNION P = {x | βƒs. s β P β§ x β s}
</pre>

<DT><span class="strong">BIGINTER</span>
<DD>
<pre>
|- β€P. BIGINTER P = {x | β€s. s β P β‡’ x β s}
</pre>

<DT><span class="strong">CROSS_DEF</span>
<DD>
<pre>
|- β€P Q. P Γ— Q = {p | FST p β P β§ SND p β Q}
</pre>

<DT><span class="strong">COMPL_DEF</span>
<DD>
<pre>
|- β€P. COMPL P = π•(:Ξ±) DIFF P
</pre>

<DT><span class="strong">count_def</span>
<DD>
<pre>
|- β€n. count n = {m | m < n}
</pre>

<DT><span class="strong">ITSET_tupled_primitive_def</span>
<DD>
<pre>
|- β€f.
     ITSET_tupled f =
     WFREC
       (@R. WF R β§ β€b s. FINITE s β§ s β‰  β… β‡’ R (REST s,f (CHOICE s) b) (s,b))
       (Ξ»ITSET_tupled a.
          case a of
            (s,b) =>
              I
                (if FINITE s then
                   if s = β… then b else ITSET_tupled (REST s,f (CHOICE s) b)
                 else ARB))
</pre>

<DT><span class="strong">ITSET_curried_def</span>
<DD>
<pre>
|- β€f x x1. ITSET f x x1 = ITSET_tupled f (x,x1)
</pre>

<DT><span class="strong">SUM_IMAGE_DEF</span>
<DD>
<pre>
|- β€f s. β‘ f s = ITSET (Ξ»e acc. f e + acc) s 0
</pre>

<DT><span class="strong">SUM_SET_DEF</span>
<DD>
<pre>
|- SUM_SET = β‘ I
</pre>

<DT><span class="strong">PROD_IMAGE_DEF</span>
<DD>
<pre>
|- β€f s. Ξ  f s = ITSET (Ξ»e acc. f e * acc) s 1
</pre>

<DT><span class="strong">PROD_SET_DEF</span>
<DD>
<pre>
|- PROD_SET = Ξ  I
</pre>

<DT><span class="strong">MAX_SET_DEF</span>
<DD>
<pre>
|- β€s.
     FINITE s β‡’
     (s β‰  β… β‡’ MAX_SET s β s β§ β€y. y β s β‡’ y β‰¤ MAX_SET s) β§
     ((s = β…) β‡’ (MAX_SET s = 0))
</pre>

<DT><span class="strong">MIN_SET_DEF</span>
<DD>
<pre>
|- MIN_SET = $LEAST
</pre>

<DT><span class="strong">POW_DEF</span>
<DD>
<pre>
|- β€set. POW set = {s | s β† set}
</pre>

<DT><span class="strong">equiv_on_def</span>
<DD>
<pre>
|- β€R s.
     R equiv_on s β‡”
     (β€x. x β s β‡’ R x x) β§ (β€x y. x β s β§ y β s β‡’ (R x y β‡” R y x)) β§
     β€x y z. x β s β§ y β s β§ z β s β§ R x y β§ R y z β‡’ R x z
</pre>

<DT><span class="strong">partition_def</span>
<DD>
<pre>
|- β€R s. partition R s = {t | βƒx. x β s β§ (t = {y | y β s β§ R x y})}
</pre>

<DT><span class="strong">pairwise_def</span>
<DD>
<pre>
|- β€P s. pairwise P s β‡” β€e1 e2. e1 β s β§ e2 β s β‡’ P e1 e2
</pre>

<DT><span class="strong">chooser_def</span>
<DD>
<pre>
|- (β€s. chooser s 0 = CHOICE s) β§ β€s n. chooser s (SUC n) = chooser (REST s) n
</pre>

<DT><span class="strong">countable_def</span>
<DD>
<pre>
|- β€s. countable s β‡” βƒf. INJ f s π•(:num)
</pre>

<DT><span class="strong">num_to_pair_def</span>
<DD>
<pre>
|- β€n. num_to_pair n = (nfst n,nsnd n)
</pre>

<DT><span class="strong">pair_to_num_def</span>
<DD>
<pre>
|- β€m n. pair_to_num (m,n) = m β— n
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">SPECIFICATION</span>
<DD>
<pre>
|- β€P x. x β P β‡” P x
</pre>

<DT><span class="strong">IN_ABS</span>
<DD>
<pre>
|- β€x P. x β (Ξ»x. P x) β‡” P x
</pre>

<DT><span class="strong">ABS_applied</span>
<DD>
<pre>
|- T
</pre>

<DT><span class="strong">EXTENSION</span>
<DD>
<pre>
|- β€s t. (s = t) β‡” β€x. x β s β‡” x β t
</pre>

<DT><span class="strong">NOT_EQUAL_SETS</span>
<DD>
<pre>
|- β€s t. s β‰  t β‡” βƒx. x β t β‡” x β‰ s
</pre>

<DT><span class="strong">NUM_SET_WOP</span>
<DD>
<pre>
|- β€s. (βƒn. n β s) β‡” βƒn. n β s β§ β€m. m β s β‡’ n β‰¤ m
</pre>

<DT><span class="strong">GSPECIFICATION_applied</span>
<DD>
<pre>
|- β€f v. GSPEC f v β‡” βƒx. (v,T) = f x
</pre>

<DT><span class="strong">SET_MINIMUM</span>
<DD>
<pre>
|- β€s M. (βƒx. x β s) β‡” βƒx. x β s β§ β€y. y β s β‡’ M x β‰¤ M y
</pre>

<DT><span class="strong">NOT_IN_EMPTY</span>
<DD>
<pre>
|- β€x. x β‰ β…
</pre>

<DT><span class="strong">MEMBER_NOT_EMPTY</span>
<DD>
<pre>
|- β€s. (βƒx. x β s) β‡” s β‰  β…
</pre>

<DT><span class="strong">EMPTY_applied</span>
<DD>
<pre>
|- β… x β‡” F
</pre>

<DT><span class="strong">IN_UNIV</span>
<DD>
<pre>
|- β€x. x β π•(:Ξ±)
</pre>

<DT><span class="strong">UNIV_NOT_EMPTY</span>
<DD>
<pre>
|- π•(:Ξ±) β‰  β…
</pre>

<DT><span class="strong">EMPTY_NOT_UNIV</span>
<DD>
<pre>
|- β… β‰  π•(:Ξ±)
</pre>

<DT><span class="strong">EQ_UNIV</span>
<DD>
<pre>
|- (β€x. x β s) β‡” (s = π•(:Ξ±))
</pre>

<DT><span class="strong">SUBSET_TRANS</span>
<DD>
<pre>
|- β€s t u. s β† t β§ t β† u β‡’ s β† u
</pre>

<DT><span class="strong">SUBSET_REFL</span>
<DD>
<pre>
|- β€s. s β† s
</pre>

<DT><span class="strong">SUBSET_ANTISYM</span>
<DD>
<pre>
|- β€s t. s β† t β§ t β† s β‡’ (s = t)
</pre>

<DT><span class="strong">EMPTY_SUBSET</span>
<DD>
<pre>
|- β€s. β… β† s
</pre>

<DT><span class="strong">SUBSET_EMPTY</span>
<DD>
<pre>
|- β€s. s β† β… β‡” (s = β…)
</pre>

<DT><span class="strong">SUBSET_UNIV</span>
<DD>
<pre>
|- β€s. s β† π•(:Ξ±)
</pre>

<DT><span class="strong">UNIV_SUBSET</span>
<DD>
<pre>
|- β€s. π•(:Ξ±) β† s β‡” (s = π•(:Ξ±))
</pre>

<DT><span class="strong">PSUBSET_TRANS</span>
<DD>
<pre>
|- β€s t u. s β‚ t β§ t β‚ u β‡’ s β‚ u
</pre>

<DT><span class="strong">PSUBSET_IRREFL</span>
<DD>
<pre>
|- β€s. Β¬(s β‚ s)
</pre>

<DT><span class="strong">NOT_PSUBSET_EMPTY</span>
<DD>
<pre>
|- β€s. Β¬(s β‚ β…)
</pre>

<DT><span class="strong">NOT_UNIV_PSUBSET</span>
<DD>
<pre>
|- β€s. Β¬(π•(:Ξ±) β‚ s)
</pre>

<DT><span class="strong">PSUBSET_UNIV</span>
<DD>
<pre>
|- β€s. s β‚ π•(:Ξ±) β‡” βƒx. x β‰ s
</pre>

<DT><span class="strong">IN_UNION</span>
<DD>
<pre>
|- β€s t x. x β s β t β‡” x β s β¨ x β t
</pre>

<DT><span class="strong">UNION_applied</span>
<DD>
<pre>
|- β€s t x. (s β t) x β‡” x β s β¨ x β t
</pre>

<DT><span class="strong">UNION_ASSOC</span>
<DD>
<pre>
|- β€s t u. s β (t β u) = s β t β u
</pre>

<DT><span class="strong">UNION_IDEMPOT</span>
<DD>
<pre>
|- β€s. s β s = s
</pre>

<DT><span class="strong">UNION_COMM</span>
<DD>
<pre>
|- β€s t. s β t = t β s
</pre>

<DT><span class="strong">SUBSET_UNION</span>
<DD>
<pre>
|- (β€s t. s β† s β t) β§ β€s t. s β† t β s
</pre>

<DT><span class="strong">UNION_SUBSET</span>
<DD>
<pre>
|- β€s t u. s β t β† u β‡” s β† u β§ t β† u
</pre>

<DT><span class="strong">SUBSET_UNION_ABSORPTION</span>
<DD>
<pre>
|- β€s t. s β† t β‡” (s β t = t)
</pre>

<DT><span class="strong">UNION_EMPTY</span>
<DD>
<pre>
|- (β€s. β… β s = s) β§ β€s. s β β… = s
</pre>

<DT><span class="strong">UNION_UNIV</span>
<DD>
<pre>
|- (β€s. π•(:Ξ±) β s = π•(:Ξ±)) β§ β€s. s β π•(:Ξ±) = π•(:Ξ±)
</pre>

<DT><span class="strong">EMPTY_UNION</span>
<DD>
<pre>
|- β€s t. (s β t = β…) β‡” (s = β…) β§ (t = β…)
</pre>

<DT><span class="strong">IN_INTER</span>
<DD>
<pre>
|- β€s t x. x β s β© t β‡” x β s β§ x β t
</pre>

<DT><span class="strong">INTER_applied</span>
<DD>
<pre>
|- β€s t x. (s β© t) x β‡” x β s β§ x β t
</pre>

<DT><span class="strong">INTER_ASSOC</span>
<DD>
<pre>
|- β€s t u. s β© (t β© u) = s β© t β© u
</pre>

<DT><span class="strong">INTER_IDEMPOT</span>
<DD>
<pre>
|- β€s. s β© s = s
</pre>

<DT><span class="strong">INTER_COMM</span>
<DD>
<pre>
|- β€s t. s β© t = t β© s
</pre>

<DT><span class="strong">INTER_SUBSET</span>
<DD>
<pre>
|- (β€s t. s β© t β† s) β§ β€s t. t β© s β† s
</pre>

<DT><span class="strong">SUBSET_INTER</span>
<DD>
<pre>
|- β€s t u. s β† t β© u β‡” s β† t β§ s β† u
</pre>

<DT><span class="strong">SUBSET_INTER_ABSORPTION</span>
<DD>
<pre>
|- β€s t. s β† t β‡” (s β© t = s)
</pre>

<DT><span class="strong">INTER_EMPTY</span>
<DD>
<pre>
|- (β€s. β… β© s = β…) β§ β€s. s β© β… = β…
</pre>

<DT><span class="strong">INTER_UNIV</span>
<DD>
<pre>
|- (β€s. π•(:Ξ±) β© s = s) β§ β€s. s β© π•(:Ξ±) = s
</pre>

<DT><span class="strong">UNION_OVER_INTER</span>
<DD>
<pre>
|- β€s t u. s β© (t β u) = s β© t β s β© u
</pre>

<DT><span class="strong">INTER_OVER_UNION</span>
<DD>
<pre>
|- β€s t u. s β t β© u = (s β t) β© (s β u)
</pre>

<DT><span class="strong">IN_DISJOINT</span>
<DD>
<pre>
|- β€s t. DISJOINT s t β‡” Β¬βƒx. x β s β§ x β t
</pre>

<DT><span class="strong">DISJOINT_SYM</span>
<DD>
<pre>
|- β€s t. DISJOINT s t β‡” DISJOINT t s
</pre>

<DT><span class="strong">DISJOINT_EMPTY</span>
<DD>
<pre>
|- β€s. DISJOINT β… s β§ DISJOINT s β…
</pre>

<DT><span class="strong">DISJOINT_EMPTY_REFL</span>
<DD>
<pre>
|- β€s. (s = β…) β‡” DISJOINT s s
</pre>

<DT><span class="strong">DISJOINT_EMPTY_REFL_RWT</span>
<DD>
<pre>
|- β€s. DISJOINT s s β‡” (s = β…)
</pre>

<DT><span class="strong">DISJOINT_UNION</span>
<DD>
<pre>
|- β€s t u. DISJOINT (s β t) u β‡” DISJOINT s u β§ DISJOINT t u
</pre>

<DT><span class="strong">DISJOINT_UNION_BOTH</span>
<DD>
<pre>
|- β€s t u.
     (DISJOINT (s β t) u β‡” DISJOINT s u β§ DISJOINT t u) β§
     (DISJOINT u (s β t) β‡” DISJOINT s u β§ DISJOINT t u)
</pre>

<DT><span class="strong">DISJOINT_SUBSET</span>
<DD>
<pre>
|- β€s t u. DISJOINT s t β§ u β† t β‡’ DISJOINT s u
</pre>

<DT><span class="strong">IN_DIFF</span>
<DD>
<pre>
|- β€s t x. x β s DIFF t β‡” x β s β§ x β‰ t
</pre>

<DT><span class="strong">DIFF_applied</span>
<DD>
<pre>
|- β€s t x. (s DIFF t) x β‡” x β s β§ x β‰ t
</pre>

<DT><span class="strong">DIFF_EMPTY</span>
<DD>
<pre>
|- β€s. s DIFF β… = s
</pre>

<DT><span class="strong">EMPTY_DIFF</span>
<DD>
<pre>
|- β€s. β… DIFF s = β…
</pre>

<DT><span class="strong">DIFF_UNIV</span>
<DD>
<pre>
|- β€s. s DIFF π•(:Ξ±) = β…
</pre>

<DT><span class="strong">DIFF_DIFF</span>
<DD>
<pre>
|- β€s t. s DIFF t DIFF t = s DIFF t
</pre>

<DT><span class="strong">DIFF_EQ_EMPTY</span>
<DD>
<pre>
|- β€s. s DIFF s = β…
</pre>

<DT><span class="strong">DIFF_SUBSET</span>
<DD>
<pre>
|- β€s t. s DIFF t β† s
</pre>

<DT><span class="strong">UNION_DIFF</span>
<DD>
<pre>
|- s β† t β‡’ (s β (t DIFF s) = t) β§ (t DIFF s β s = t)
</pre>

<DT><span class="strong">DIFF_UNION</span>
<DD>
<pre>
|- β€x y z. x DIFF (y β z) = x DIFF y DIFF z
</pre>

<DT><span class="strong">DIFF_COMM</span>
<DD>
<pre>
|- β€x y z. x DIFF y DIFF z = x DIFF z DIFF y
</pre>

<DT><span class="strong">DIFF_SAME_UNION</span>
<DD>
<pre>
|- β€x y. (x β y DIFF x = y DIFF x) β§ (x β y DIFF y = x DIFF y)
</pre>

<DT><span class="strong">IN_INSERT</span>
<DD>
<pre>
|- β€x y s. x β y INSERT s β‡” (x = y) β¨ x β s
</pre>

<DT><span class="strong">INSERT_applied</span>
<DD>
<pre>
|- β€x y s. (y INSERT s) x β‡” (x = y) β¨ x β s
</pre>

<DT><span class="strong">COMPONENT</span>
<DD>
<pre>
|- β€x s. x β x INSERT s
</pre>

<DT><span class="strong">SET_CASES</span>
<DD>
<pre>
|- β€s. (s = β…) β¨ βƒx t. (s = x INSERT t) β§ x β‰ t
</pre>

<DT><span class="strong">DECOMPOSITION</span>
<DD>
<pre>
|- β€s x. x β s β‡” βƒt. (s = x INSERT t) β§ x β‰ t
</pre>

<DT><span class="strong">ABSORPTION</span>
<DD>
<pre>
|- β€x s. x β s β‡” (x INSERT s = s)
</pre>

<DT><span class="strong">ABSORPTION_RWT</span>
<DD>
<pre>
|- β€x s. x β s β‡’ (x INSERT s = s)
</pre>

<DT><span class="strong">INSERT_INSERT</span>
<DD>
<pre>
|- β€x s. x INSERT x INSERT s = x INSERT s
</pre>

<DT><span class="strong">INSERT_COMM</span>
<DD>
<pre>
|- β€x y s. x INSERT y INSERT s = y INSERT x INSERT s
</pre>

<DT><span class="strong">INSERT_UNIV</span>
<DD>
<pre>
|- β€x. x INSERT π•(:Ξ±) = π•(:Ξ±)
</pre>

<DT><span class="strong">NOT_INSERT_EMPTY</span>
<DD>
<pre>
|- β€x s. x INSERT s β‰  β…
</pre>

<DT><span class="strong">NOT_EMPTY_INSERT</span>
<DD>
<pre>
|- β€x s. β… β‰  x INSERT s
</pre>

<DT><span class="strong">INSERT_UNION</span>
<DD>
<pre>
|- β€x s t. (x INSERT s) β t = if x β t then s β t else x INSERT s β t
</pre>

<DT><span class="strong">INSERT_UNION_EQ</span>
<DD>
<pre>
|- β€x s t. (x INSERT s) β t = x INSERT s β t
</pre>

<DT><span class="strong">INSERT_INTER</span>
<DD>
<pre>
|- β€x s t. (x INSERT s) β© t = if x β t then x INSERT s β© t else s β© t
</pre>

<DT><span class="strong">DISJOINT_INSERT</span>
<DD>
<pre>
|- β€x s t. DISJOINT (x INSERT s) t β‡” DISJOINT s t β§ x β‰ t
</pre>

<DT><span class="strong">DISJOINT_INSERT'</span>
<DD>
<pre>
|- β€x s t. DISJOINT t (x INSERT s) β‡” DISJOINT t s β§ x β‰ t
</pre>

<DT><span class="strong">INSERT_SUBSET</span>
<DD>
<pre>
|- β€x s t. x INSERT s β† t β‡” x β t β§ s β† t
</pre>

<DT><span class="strong">SUBSET_INSERT</span>
<DD>
<pre>
|- β€x s. x β‰ s β‡’ β€t. s β† x INSERT t β‡” s β† t
</pre>

<DT><span class="strong">INSERT_DIFF</span>
<DD>
<pre>
|- β€s t x. (x INSERT s) DIFF t = if x β t then s DIFF t else x INSERT s DIFF t
</pre>

<DT><span class="strong">UNIV_BOOL</span>
<DD>
<pre>
|- π•(:bool) = {T; F}
</pre>

<DT><span class="strong">IN_DELETE</span>
<DD>
<pre>
|- β€s x y. x β s DELETE y β‡” x β s β§ x β‰  y
</pre>

<DT><span class="strong">DELETE_applied</span>
<DD>
<pre>
|- β€s x y. (s DELETE y) x β‡” x β s β§ x β‰  y
</pre>

<DT><span class="strong">DELETE_NON_ELEMENT</span>
<DD>
<pre>
|- β€x s. x β‰ s β‡” (s DELETE x = s)
</pre>

<DT><span class="strong">DELETE_NON_ELEMENT_RWT</span>
<DD>
<pre>
|- β€x s. x β‰ s β‡’ (s DELETE x = s)
</pre>

<DT><span class="strong">IN_DELETE_EQ</span>
<DD>
<pre>
|- β€s x x'. (x β s β‡” x' β s) β‡” (x β s DELETE x' β‡” x' β s DELETE x)
</pre>

<DT><span class="strong">EMPTY_DELETE</span>
<DD>
<pre>
|- β€x. β… DELETE x = β…
</pre>

<DT><span class="strong">DELETE_DELETE</span>
<DD>
<pre>
|- β€x s. s DELETE x DELETE x = s DELETE x
</pre>

<DT><span class="strong">DELETE_COMM</span>
<DD>
<pre>
|- β€x y s. s DELETE x DELETE y = s DELETE y DELETE x
</pre>

<DT><span class="strong">DELETE_SUBSET</span>
<DD>
<pre>
|- β€x s. s DELETE x β† s
</pre>

<DT><span class="strong">SUBSET_DELETE</span>
<DD>
<pre>
|- β€x s t. s β† t DELETE x β‡” x β‰ s β§ s β† t
</pre>

<DT><span class="strong">SUBSET_INSERT_DELETE</span>
<DD>
<pre>
|- β€x s t. s β† x INSERT t β‡” s DELETE x β† t
</pre>

<DT><span class="strong">DIFF_INSERT</span>
<DD>
<pre>
|- β€s t x. s DIFF (x INSERT t) = s DELETE x DIFF t
</pre>

<DT><span class="strong">PSUBSET_INSERT_SUBSET</span>
<DD>
<pre>
|- β€s t. s β‚ t β‡” βƒx. x β‰ s β§ x INSERT s β† t
</pre>

<DT><span class="strong">PSUBSET_MEMBER</span>
<DD>
<pre>
|- β€s t. s β‚ t β‡” s β† t β§ βƒy. y β t β§ y β‰ s
</pre>

<DT><span class="strong">DELETE_INSERT</span>
<DD>
<pre>
|- β€x y s.
     (x INSERT s) DELETE y = if x = y then s DELETE y else x INSERT s DELETE y
</pre>

<DT><span class="strong">INSERT_DELETE</span>
<DD>
<pre>
|- β€x s. x β s β‡’ (x INSERT s DELETE x = s)
</pre>

<DT><span class="strong">DELETE_INTER</span>
<DD>
<pre>
|- β€s t x. (s DELETE x) β© t = s β© t DELETE x
</pre>

<DT><span class="strong">DISJOINT_DELETE_SYM</span>
<DD>
<pre>
|- β€s t x. DISJOINT (s DELETE x) t β‡” DISJOINT (t DELETE x) s
</pre>

<DT><span class="strong">CHOICE_NOT_IN_REST</span>
<DD>
<pre>
|- β€s. CHOICE s β‰ REST s
</pre>

<DT><span class="strong">CHOICE_INSERT_REST</span>
<DD>
<pre>
|- β€s. s β‰  β… β‡’ (CHOICE s INSERT REST s = s)
</pre>

<DT><span class="strong">REST_SUBSET</span>
<DD>
<pre>
|- β€s. REST s β† s
</pre>

<DT><span class="strong">REST_PSUBSET</span>
<DD>
<pre>
|- β€s. s β‰  β… β‡’ REST s β‚ s
</pre>

<DT><span class="strong">SING</span>
<DD>
<pre>
|- β€x. SING {x}
</pre>

<DT><span class="strong">SING_EMPTY</span>
<DD>
<pre>
|- SING β… β‡” F
</pre>

<DT><span class="strong">SING_INSERT</span>
<DD>
<pre>
|- SING (x INSERT s) β‡” (s = β…) β¨ (s = {x})
</pre>

<DT><span class="strong">SING_UNION</span>
<DD>
<pre>
|- SING (s β t) β‡”
   SING s β§ (t = β…) β¨ SING t β§ (s = β…) β¨ SING s β§ SING t β§ (s = t)
</pre>

<DT><span class="strong">IN_SING</span>
<DD>
<pre>
|- β€x y. x β {y} β‡” (x = y)
</pre>

<DT><span class="strong">SING_applied</span>
<DD>
<pre>
|- β€x y. {y} x β‡” (x = y)
</pre>

<DT><span class="strong">NOT_SING_EMPTY</span>
<DD>
<pre>
|- β€x. {x} β‰  β…
</pre>

<DT><span class="strong">NOT_EMPTY_SING</span>
<DD>
<pre>
|- β€x. β… β‰  {x}
</pre>

<DT><span class="strong">EQUAL_SING</span>
<DD>
<pre>
|- β€x y. ({x} = {y}) β‡” (x = y)
</pre>

<DT><span class="strong">DISJOINT_SING_EMPTY</span>
<DD>
<pre>
|- β€x. DISJOINT {x} β…
</pre>

<DT><span class="strong">INSERT_SING_UNION</span>
<DD>
<pre>
|- β€s x. x INSERT s = {x} β s
</pre>

<DT><span class="strong">SING_DELETE</span>
<DD>
<pre>
|- β€x. {x} DELETE x = β…
</pre>

<DT><span class="strong">DELETE_EQ_SING</span>
<DD>
<pre>
|- β€s x. x β s β‡’ ((s DELETE x = β…) β‡” (s = {x}))
</pre>

<DT><span class="strong">CHOICE_SING</span>
<DD>
<pre>
|- β€x. CHOICE {x} = x
</pre>

<DT><span class="strong">REST_SING</span>
<DD>
<pre>
|- β€x. REST {x} = β…
</pre>

<DT><span class="strong">SING_IFF_EMPTY_REST</span>
<DD>
<pre>
|- β€s. SING s β‡” s β‰  β… β§ (REST s = β…)
</pre>

<DT><span class="strong">IN_IMAGE</span>
<DD>
<pre>
|- β€y s f. y β IMAGE f s β‡” βƒx. (y = f x) β§ x β s
</pre>

<DT><span class="strong">IMAGE_applied</span>
<DD>
<pre>
|- β€y s f. IMAGE f s y β‡” βƒx. (y = f x) β§ x β s
</pre>

<DT><span class="strong">IMAGE_IN</span>
<DD>
<pre>
|- β€x s. x β s β‡’ β€f. f x β IMAGE f s
</pre>

<DT><span class="strong">IMAGE_EMPTY</span>
<DD>
<pre>
|- β€f. IMAGE f β… = β…
</pre>

<DT><span class="strong">IMAGE_ID</span>
<DD>
<pre>
|- β€s. IMAGE (Ξ»x. x) s = s
</pre>

<DT><span class="strong">IMAGE_COMPOSE</span>
<DD>
<pre>
|- β€f g s. IMAGE (f o g) s = IMAGE f (IMAGE g s)
</pre>

<DT><span class="strong">IMAGE_INSERT</span>
<DD>
<pre>
|- β€f x s. IMAGE f (x INSERT s) = f x INSERT IMAGE f s
</pre>

<DT><span class="strong">IMAGE_EQ_EMPTY</span>
<DD>
<pre>
|- β€s f. (IMAGE f s = β…) β‡” (s = β…)
</pre>

<DT><span class="strong">IMAGE_DELETE</span>
<DD>
<pre>
|- β€f x s. x β‰ s β‡’ (IMAGE f (s DELETE x) = IMAGE f s)
</pre>

<DT><span class="strong">IMAGE_UNION</span>
<DD>
<pre>
|- β€f s t. IMAGE f (s β t) = IMAGE f s β IMAGE f t
</pre>

<DT><span class="strong">IMAGE_SUBSET</span>
<DD>
<pre>
|- β€s t. s β† t β‡’ β€f. IMAGE f s β† IMAGE f t
</pre>

<DT><span class="strong">IMAGE_INTER</span>
<DD>
<pre>
|- β€f s t. IMAGE f (s β© t) β† IMAGE f s β© IMAGE f t
</pre>

<DT><span class="strong">IMAGE_11</span>
<DD>
<pre>
|- (β€x y. (f x = f y) β‡” (x = y)) β‡’ ((IMAGE f s1 = IMAGE f s2) β‡” (s1 = s2))
</pre>

<DT><span class="strong">IMAGE_CONG</span>
<DD>
<pre>
|- β€f s f' s'.
     (s = s') β§ (β€x. x β s' β‡’ (f x = f' x)) β‡’ (IMAGE f s = IMAGE f' s')
</pre>

<DT><span class="strong">INJ_IFF</span>
<DD>
<pre>
|- INJ f s t β‡”
   (β€x. x β s β‡’ f x β t) β§ β€x y. x β s β§ y β s β‡’ ((f x = f y) β‡” (x = y))
</pre>

<DT><span class="strong">INJ_ID</span>
<DD>
<pre>
|- β€s. INJ (Ξ»x. x) s s
</pre>

<DT><span class="strong">INJ_COMPOSE</span>
<DD>
<pre>
|- β€f g s t u. INJ f s t β§ INJ g t u β‡’ INJ (g o f) s u
</pre>

<DT><span class="strong">INJ_EMPTY</span>
<DD>
<pre>
|- β€f. (β€s. INJ f β… s) β§ β€s. INJ f s β… β‡” (s = β…)
</pre>

<DT><span class="strong">INJ_DELETE</span>
<DD>
<pre>
|- β€s t f. INJ f s t β‡’ β€e. e β s β‡’ INJ f (s DELETE e) (t DELETE f e)
</pre>

<DT><span class="strong">INJ_INSERT</span>
<DD>
<pre>
|- β€f x s t.
     INJ f (x INSERT s) t β‡”
     INJ f s t β§ f x β t β§ β€y. y β s β§ (f x = f y) β‡’ (x = y)
</pre>

<DT><span class="strong">INJ_SUBSET</span>
<DD>
<pre>
|- β€f s t s0 t0. INJ f s t β§ s0 β† s β§ t β† t0 β‡’ INJ f s0 t0
</pre>

<DT><span class="strong">SURJ_ID</span>
<DD>
<pre>
|- β€s. SURJ (Ξ»x. x) s s
</pre>

<DT><span class="strong">SURJ_COMPOSE</span>
<DD>
<pre>
|- β€f g s t u. SURJ f s t β§ SURJ g t u β‡’ SURJ (g o f) s u
</pre>

<DT><span class="strong">SURJ_EMPTY</span>
<DD>
<pre>
|- β€f. (β€s. SURJ f β… s β‡” (s = β…)) β§ β€s. SURJ f s β… β‡” (s = β…)
</pre>

<DT><span class="strong">IMAGE_SURJ</span>
<DD>
<pre>
|- β€f s t. SURJ f s t β‡” (IMAGE f s = t)
</pre>

<DT><span class="strong">SURJ_IMAGE</span>
<DD>
<pre>
|- SURJ f s (IMAGE f s)
</pre>

<DT><span class="strong">SURJ_INJ_INV</span>
<DD>
<pre>
|- SURJ f s t β‡’ βƒg. INJ g t s β§ β€y. y β t β‡’ (f (g y) = y)
</pre>

<DT><span class="strong">BIJ_ID</span>
<DD>
<pre>
|- β€s. BIJ (Ξ»x. x) s s
</pre>

<DT><span class="strong">BIJ_EMPTY</span>
<DD>
<pre>
|- β€f. (β€s. BIJ f β… s β‡” (s = β…)) β§ β€s. BIJ f s β… β‡” (s = β…)
</pre>

<DT><span class="strong">BIJ_COMPOSE</span>
<DD>
<pre>
|- β€f g s t u. BIJ f s t β§ BIJ g t u β‡’ BIJ (g o f) s u
</pre>

<DT><span class="strong">BIJ_DELETE</span>
<DD>
<pre>
|- β€s t f. BIJ f s t β‡’ β€e. e β s β‡’ BIJ f (s DELETE e) (t DELETE f e)
</pre>

<DT><span class="strong">BIJ_LINV_INV</span>
<DD>
<pre>
|- β€f s t. BIJ f s t β‡’ β€x. x β t β‡’ (f (LINV f s x) = x)
</pre>

<DT><span class="strong">BIJ_LINV_BIJ</span>
<DD>
<pre>
|- β€f s t. BIJ f s t β‡’ BIJ (LINV f s) t s
</pre>

<DT><span class="strong">BIJ_IFF_INV</span>
<DD>
<pre>
|- β€f s t.
     BIJ f s t β‡”
     (β€x. x β s β‡’ f x β t) β§
     βƒg.
       (β€x. x β t β‡’ g x β s) β§ (β€x. x β s β‡’ (g (f x) = x)) β§
       β€x. x β t β‡’ (f (g x) = x)
</pre>

<DT><span class="strong">BIJ_INSERT</span>
<DD>
<pre>
|- BIJ f (e INSERT s) t β‡”
   e β‰ s β§ f e β t β§ BIJ f s (t DELETE f e) β¨ e β s β§ BIJ f s t
</pre>

<DT><span class="strong">FINITE_EMPTY</span>
<DD>
<pre>
|- FINITE β…
</pre>

<DT><span class="strong">FINITE_INDUCT</span>
<DD>
<pre>
|- β€P.
     P β… β§ (β€s. FINITE s β§ P s β‡’ β€e. e β‰ s β‡’ P (e INSERT s)) β‡’
     β€s. FINITE s β‡’ P s
</pre>

<DT><span class="strong">FINITE_INSERT</span>
<DD>
<pre>
|- β€x s. FINITE (x INSERT s) β‡” FINITE s
</pre>

<DT><span class="strong">FINITE_DELETE</span>
<DD>
<pre>
|- β€x s. FINITE (s DELETE x) β‡” FINITE s
</pre>

<DT><span class="strong">FINITE_REST</span>
<DD>
<pre>
|- β€s. FINITE s β‡’ FINITE (REST s)
</pre>

<DT><span class="strong">FINITE_UNION</span>
<DD>
<pre>
|- β€s t. FINITE (s β t) β‡” FINITE s β§ FINITE t
</pre>

<DT><span class="strong">INTER_FINITE</span>
<DD>
<pre>
|- β€s. FINITE s β‡’ β€t. FINITE (s β© t)
</pre>

<DT><span class="strong">SUBSET_FINITE</span>
<DD>
<pre>
|- β€s. FINITE s β‡’ β€t. t β† s β‡’ FINITE t
</pre>

<DT><span class="strong">SUBSET_FINITE_I</span>
<DD>
<pre>
|- β€s t. FINITE s β§ t β† s β‡’ FINITE t
</pre>

<DT><span class="strong">PSUBSET_FINITE</span>
<DD>
<pre>
|- β€s. FINITE s β‡’ β€t. t β‚ s β‡’ FINITE t
</pre>

<DT><span class="strong">FINITE_DIFF</span>
<DD>
<pre>
|- β€s. FINITE s β‡’ β€t. FINITE (s DIFF t)
</pre>

<DT><span class="strong">FINITE_DIFF_down</span>
<DD>
<pre>
|- β€P Q. FINITE (P DIFF Q) β§ FINITE Q β‡’ FINITE P
</pre>

<DT><span class="strong">FINITE_SING</span>
<DD>
<pre>
|- β€x. FINITE {x}
</pre>

<DT><span class="strong">SING_FINITE</span>
<DD>
<pre>
|- β€s. SING s β‡’ FINITE s
</pre>

<DT><span class="strong">IMAGE_FINITE</span>
<DD>
<pre>
|- β€s. FINITE s β‡’ β€f. FINITE (IMAGE f s)
</pre>

<DT><span class="strong">FINITELY_INJECTIVE_IMAGE_FINITE</span>
<DD>
<pre>
|- β€f. (β€x. FINITE {y | x = f y}) β‡’ β€s. FINITE (IMAGE f s) β‡” FINITE s
</pre>

<DT><span class="strong">INJECTIVE_IMAGE_FINITE</span>
<DD>
<pre>
|- β€f. (β€x y. (f x = f y) β‡” (x = y)) β‡’ β€s. FINITE (IMAGE f s) β‡” FINITE s
</pre>

<DT><span class="strong">FINITE_INJ</span>
<DD>
<pre>
|- β€f s t. INJ f s t β§ FINITE t β‡’ FINITE s
</pre>

<DT><span class="strong">REL_RESTRICT_EMPTY</span>
<DD>
<pre>
|- REL_RESTRICT R β… = REMPTY
</pre>

<DT><span class="strong">REL_RESTRICT_SUBSET</span>
<DD>
<pre>
|- s1 β† s2 β‡’ REL_RESTRICT R s1 RSUBSET REL_RESTRICT R s2
</pre>

<DT><span class="strong">CARD_EMPTY</span>
<DD>
<pre>
|- CARD β… = 0
</pre>

<DT><span class="strong">CARD_INSERT</span>
<DD>
<pre>
|- β€s.
     FINITE s β‡’ β€x. CARD (x INSERT s) = if x β s then CARD s else SUC (CARD s)
</pre>

<DT><span class="strong">CARD_EQ_0</span>
<DD>
<pre>
|- β€s. FINITE s β‡’ ((CARD s = 0) β‡” (s = β…))
</pre>

<DT><span class="strong">CARD_DELETE</span>
<DD>
<pre>
|- β€s. FINITE s β‡’ β€x. CARD (s DELETE x) = if x β s then CARD s β’ 1 else CARD s
</pre>

<DT><span class="strong">CARD_INTER_LESS_EQ</span>
<DD>
<pre>
|- β€s. FINITE s β‡’ β€t. CARD (s β© t) β‰¤ CARD s
</pre>

<DT><span class="strong">CARD_UNION</span>
<DD>
<pre>
|- β€s.
     FINITE s β‡’ β€t. FINITE t β‡’ (CARD (s β t) + CARD (s β© t) = CARD s + CARD t)
</pre>

<DT><span class="strong">CARD_UNION_EQN</span>
<DD>
<pre>
|- β€s t. FINITE s β§ FINITE t β‡’ (CARD (s β t) = CARD s + CARD t β’ CARD (s β© t))
</pre>

<DT><span class="strong">CARD_SUBSET</span>
<DD>
<pre>
|- β€s. FINITE s β‡’ β€t. t β† s β‡’ CARD t β‰¤ CARD s
</pre>

<DT><span class="strong">CARD_PSUBSET</span>
<DD>
<pre>
|- β€s. FINITE s β‡’ β€t. t β‚ s β‡’ CARD t < CARD s
</pre>

<DT><span class="strong">SUBSET_EQ_CARD</span>
<DD>
<pre>
|- β€s. FINITE s β‡’ β€t. FINITE t β§ (CARD s = CARD t) β§ s β† t β‡’ (s = t)
</pre>

<DT><span class="strong">CARD_SING</span>
<DD>
<pre>
|- β€x. CARD {x} = 1
</pre>

<DT><span class="strong">SING_IFF_CARD1</span>
<DD>
<pre>
|- β€s. SING s β‡” (CARD s = 1) β§ FINITE s
</pre>

<DT><span class="strong">CARD_DIFF</span>
<DD>
<pre>
|- β€t. FINITE t β‡’ β€s. FINITE s β‡’ (CARD (s DIFF t) = CARD s β’ CARD (s β© t))
</pre>

<DT><span class="strong">CARD_DIFF_EQN</span>
<DD>
<pre>
|- β€s. FINITE s β‡’ (CARD (s DIFF t) = CARD s β’ CARD (s β© t))
</pre>

<DT><span class="strong">LESS_CARD_DIFF</span>
<DD>
<pre>
|- β€t. FINITE t β‡’ β€s. FINITE s β‡’ CARD t < CARD s β‡’ 0 < CARD (s DIFF t)
</pre>

<DT><span class="strong">BIJ_FINITE</span>
<DD>
<pre>
|- β€f s t. BIJ f s t β§ FINITE s β‡’ FINITE t
</pre>

<DT><span class="strong">FINITE_BIJ_CARD_EQ</span>
<DD>
<pre>
|- β€S. FINITE S β‡’ β€t f. BIJ f S t β§ FINITE t β‡’ (CARD S = CARD t)
</pre>

<DT><span class="strong">CARD_INJ_IMAGE</span>
<DD>
<pre>
|- β€f s.
     (β€x y. (f x = f y) β‡” (x = y)) β§ FINITE s β‡’ (CARD (IMAGE f s) = CARD s)
</pre>

<DT><span class="strong">FINITE_COMPLETE_INDUCTION</span>
<DD>
<pre>
|- β€P. (β€x. (β€y. y β‚ x β‡’ P y) β‡’ FINITE x β‡’ P x) β‡’ β€x. FINITE x β‡’ P x
</pre>

<DT><span class="strong">INJ_CARD</span>
<DD>
<pre>
|- β€f s t. INJ f s t β§ FINITE t β‡’ CARD s β‰¤ CARD t
</pre>

<DT><span class="strong">PHP</span>
<DD>
<pre>
|- β€f s t. FINITE t β§ CARD t < CARD s β‡’ Β¬INJ f s t
</pre>

<DT><span class="strong">INFINITE_DEF</span>
<DD>
<pre>
|- T
</pre>

<DT><span class="strong">NOT_IN_FINITE</span>
<DD>
<pre>
|- INFINITE π•(:Ξ±) β‡” β€s. FINITE s β‡’ βƒx. x β‰ s
</pre>

<DT><span class="strong">INFINITE_INHAB</span>
<DD>
<pre>
|- β€P. INFINITE P β‡’ βƒx. x β P
</pre>

<DT><span class="strong">IMAGE_11_INFINITE</span>
<DD>
<pre>
|- β€f. (β€x y. (f x = f y) β‡’ (x = y)) β‡’ β€s. INFINITE s β‡’ INFINITE (IMAGE f s)
</pre>

<DT><span class="strong">INFINITE_SUBSET</span>
<DD>
<pre>
|- β€s. INFINITE s β‡’ β€t. s β† t β‡’ INFINITE t
</pre>

<DT><span class="strong">IN_INFINITE_NOT_FINITE</span>
<DD>
<pre>
|- β€s t. INFINITE s β§ FINITE t β‡’ βƒx. x β s β§ x β‰ t
</pre>

<DT><span class="strong">INFINITE_UNIV</span>
<DD>
<pre>
|- INFINITE π•(:Ξ±) β‡” βƒf. (β€x y. (f x = f y) β‡’ (x = y)) β§ βƒy. β€x. f x β‰  y
</pre>

<DT><span class="strong">INFINITE_NUM_UNIV</span>
<DD>
<pre>
|- INFINITE π•(:num)
</pre>

<DT><span class="strong">FINITE_PSUBSET_INFINITE</span>
<DD>
<pre>
|- β€s. INFINITE s β‡” β€t. FINITE t β‡’ t β† s β‡’ t β‚ s
</pre>

<DT><span class="strong">FINITE_PSUBSET_UNIV</span>
<DD>
<pre>
|- INFINITE π•(:Ξ±) β‡” β€s. FINITE s β‡’ s β‚ π•(:Ξ±)
</pre>

<DT><span class="strong">INFINITE_DIFF_FINITE</span>
<DD>
<pre>
|- β€s t. INFINITE s β§ FINITE t β‡’ s DIFF t β‰  β…
</pre>

<DT><span class="strong">FINITE_ISO_NUM</span>
<DD>
<pre>
|- β€s.
     FINITE s β‡’
     βƒf.
       (β€n m. n < CARD s β§ m < CARD s β‡’ (f n = f m) β‡’ (n = m)) β§
       (s = {f n | n < CARD s})
</pre>

<DT><span class="strong">FINITE_WEAK_ENUMERATE</span>
<DD>
<pre>
|- β€s. FINITE s β‡” βƒf b. β€e. e β s β‡” βƒn. n < b β§ (e = f n)
</pre>

<DT><span class="strong">FINITE_WF_noloops</span>
<DD>
<pre>
|- β€s. FINITE s β‡’ (WF (REL_RESTRICT R s) β‡” irreflexive (REL_RESTRICT R s)βΊ)
</pre>

<DT><span class="strong">FINITE_StrongOrder_WF</span>
<DD>
<pre>
|- β€R s. FINITE s β§ StrongOrder (REL_RESTRICT R s) β‡’ WF (REL_RESTRICT R s)
</pre>

<DT><span class="strong">IN_BIGUNION</span>
<DD>
<pre>
|- β€x sos. x β BIGUNION sos β‡” βƒs. x β s β§ s β sos
</pre>

<DT><span class="strong">BIGUNION_applied</span>
<DD>
<pre>
|- β€x sos. BIGUNION sos x β‡” βƒs. x β s β§ s β sos
</pre>

<DT><span class="strong">BIGUNION_EMPTY</span>
<DD>
<pre>
|- BIGUNION β… = β…
</pre>

<DT><span class="strong">BIGUNION_EQ_EMPTY</span>
<DD>
<pre>
|- β€P.
     ((BIGUNION P = β…) β‡” (P = β…) β¨ (P = {β…})) β§
     ((β… = BIGUNION P) β‡” (P = β…) β¨ (P = {β…}))
</pre>

<DT><span class="strong">BIGUNION_SING</span>
<DD>
<pre>
|- β€x. BIGUNION {x} = x
</pre>

<DT><span class="strong">BIGUNION_UNION</span>
<DD>
<pre>
|- β€s1 s2. BIGUNION (s1 β s2) = BIGUNION s1 β BIGUNION s2
</pre>

<DT><span class="strong">DISJOINT_BIGUNION</span>
<DD>
<pre>
|- (β€s t. DISJOINT (BIGUNION s) t β‡” β€s'. s' β s β‡’ DISJOINT s' t) β§
   β€s t. DISJOINT t (BIGUNION s) β‡” β€s'. s' β s β‡’ DISJOINT t s'
</pre>

<DT><span class="strong">BIGUNION_INSERT</span>
<DD>
<pre>
|- β€s P. BIGUNION (s INSERT P) = s β BIGUNION P
</pre>

<DT><span class="strong">BIGUNION_SUBSET</span>
<DD>
<pre>
|- β€X P. BIGUNION P β† X β‡” β€Y. Y β P β‡’ Y β† X
</pre>

<DT><span class="strong">FINITE_BIGUNION</span>
<DD>
<pre>
|- β€P. FINITE P β§ (β€s. s β P β‡’ FINITE s) β‡’ FINITE (BIGUNION P)
</pre>

<DT><span class="strong">FINITE_BIGUNION_EQ</span>
<DD>
<pre>
|- β€P. FINITE (BIGUNION P) β‡” FINITE P β§ β€s. s β P β‡’ FINITE s
</pre>

<DT><span class="strong">SUBSET_BIGUNION_I</span>
<DD>
<pre>
|- x β P β‡’ x β† BIGUNION P
</pre>

<DT><span class="strong">CARD_BIGUNION_SAME_SIZED_SETS</span>
<DD>
<pre>
|- β€n s.
     FINITE s β§ (β€e. e β s β‡’ FINITE e β§ (CARD e = n)) β§
     (β€e1 e2. e1 β s β§ e2 β s β§ e1 β‰  e2 β‡’ DISJOINT e1 e2) β‡’
     (CARD (BIGUNION s) = CARD s * n)
</pre>

<DT><span class="strong">IN_BIGINTER</span>
<DD>
<pre>
|- x β BIGINTER B β‡” β€P. P β B β‡’ x β P
</pre>

<DT><span class="strong">BIGINTER_applied</span>
<DD>
<pre>
|- BIGINTER B x β‡” β€P. P β B β‡’ x β P
</pre>

<DT><span class="strong">BIGINTER_INSERT</span>
<DD>
<pre>
|- β€P B. BIGINTER (P INSERT B) = P β© BIGINTER B
</pre>

<DT><span class="strong">BIGINTER_EMPTY</span>
<DD>
<pre>
|- BIGINTER β… = π•(:Ξ±)
</pre>

<DT><span class="strong">BIGINTER_INTER</span>
<DD>
<pre>
|- β€P Q. BIGINTER {P; Q} = P β© Q
</pre>

<DT><span class="strong">BIGINTER_SING</span>
<DD>
<pre>
|- β€P. BIGINTER {P} = P
</pre>

<DT><span class="strong">SUBSET_BIGINTER</span>
<DD>
<pre>
|- β€X P. X β† BIGINTER P β‡” β€Y. Y β P β‡’ X β† Y
</pre>

<DT><span class="strong">DISJOINT_BIGINTER</span>
<DD>
<pre>
|- β€X Y P.
     Y β P β§ DISJOINT Y X β‡’ DISJOINT X (BIGINTER P) β§ DISJOINT (BIGINTER P) X
</pre>

<DT><span class="strong">BIGINTER_UNION</span>
<DD>
<pre>
|- β€s1 s2. BIGINTER (s1 β s2) = BIGINTER s1 β© BIGINTER s2
</pre>

<DT><span class="strong">IN_CROSS</span>
<DD>
<pre>
|- β€P Q x. x β P Γ— Q β‡” FST x β P β§ SND x β Q
</pre>

<DT><span class="strong">CROSS_applied</span>
<DD>
<pre>
|- β€P Q x. (P Γ— Q) x β‡” FST x β P β§ SND x β Q
</pre>

<DT><span class="strong">CROSS_EMPTY</span>
<DD>
<pre>
|- β€P. (P Γ— β… = β…) β§ (β… Γ— P = β…)
</pre>

<DT><span class="strong">CROSS_EMPTY_EQN</span>
<DD>
<pre>
|- (s Γ— t = β…) β‡” (s = β…) β¨ (t = β…)
</pre>

<DT><span class="strong">CROSS_INSERT_LEFT</span>
<DD>
<pre>
|- β€P Q x. (x INSERT P) Γ— Q = {x} Γ— Q β P Γ— Q
</pre>

<DT><span class="strong">CROSS_INSERT_RIGHT</span>
<DD>
<pre>
|- β€P Q x. P Γ— (x INSERT Q) = P Γ— {x} β P Γ— Q
</pre>

<DT><span class="strong">FINITE_CROSS</span>
<DD>
<pre>
|- β€P Q. FINITE P β§ FINITE Q β‡’ FINITE (P Γ— Q)
</pre>

<DT><span class="strong">CROSS_SINGS</span>
<DD>
<pre>
|- β€x y. {x} Γ— {y} = {(x,y)}
</pre>

<DT><span class="strong">CARD_SING_CROSS</span>
<DD>
<pre>
|- β€x P. FINITE P β‡’ (CARD ({x} Γ— P) = CARD P)
</pre>

<DT><span class="strong">CARD_CROSS</span>
<DD>
<pre>
|- β€P Q. FINITE P β§ FINITE Q β‡’ (CARD (P Γ— Q) = CARD P * CARD Q)
</pre>

<DT><span class="strong">CROSS_SUBSET</span>
<DD>
<pre>
|- β€P Q P0 Q0. P0 Γ— Q0 β† P Γ— Q β‡” (P0 = β…) β¨ (Q0 = β…) β¨ P0 β† P β§ Q0 β† Q
</pre>

<DT><span class="strong">FINITE_CROSS_EQ</span>
<DD>
<pre>
|- β€P Q. FINITE (P Γ— Q) β‡” (P = β…) β¨ (Q = β…) β¨ FINITE P β§ FINITE Q
</pre>

<DT><span class="strong">CROSS_UNIV</span>
<DD>
<pre>
|- π•(:Ξ± # Ξ²) = π•(:Ξ±) Γ— π•(:Ξ²)
</pre>

<DT><span class="strong">INFINITE_PAIR_UNIV</span>
<DD>
<pre>
|- FINITE π•(:Ξ± # Ξ²) β‡” FINITE π•(:Ξ±) β§ FINITE π•(:Ξ²)
</pre>

<DT><span class="strong">SUM_UNIV</span>
<DD>
<pre>
|- π•(:Ξ± + Ξ²) = IMAGE INL π•(:Ξ±) β IMAGE INR π•(:Ξ²)
</pre>

<DT><span class="strong">INJ_INL</span>
<DD>
<pre>
|- (β€x. x β s β‡’ INL x β t) β‡’ INJ INL s t
</pre>

<DT><span class="strong">INJ_INR</span>
<DD>
<pre>
|- (β€x. x β s β‡’ INR x β t) β‡’ INJ INR s t
</pre>

<DT><span class="strong">IN_COMPL</span>
<DD>
<pre>
|- β€x s. x β COMPL s β‡” x β‰ s
</pre>

<DT><span class="strong">COMPL_applied</span>
<DD>
<pre>
|- β€x s. COMPL s x β‡” x β‰ s
</pre>

<DT><span class="strong">COMPL_COMPL</span>
<DD>
<pre>
|- β€s. COMPL (COMPL s) = s
</pre>

<DT><span class="strong">COMPL_CLAUSES</span>
<DD>
<pre>
|- β€s. (COMPL s β© s = β…) β§ (COMPL s β s = π•(:Ξ±))
</pre>

<DT><span class="strong">COMPL_SPLITS</span>
<DD>
<pre>
|- β€p q. p β© q β COMPL p β© q = q
</pre>

<DT><span class="strong">INTER_UNION_COMPL</span>
<DD>
<pre>
|- β€s t. s β© t = COMPL (COMPL s β COMPL t)
</pre>

<DT><span class="strong">COMPL_EMPTY</span>
<DD>
<pre>
|- COMPL β… = π•(:Ξ±)
</pre>

<DT><span class="strong">COMPL_INTER</span>
<DD>
<pre>
|- (x β© COMPL x = β…) β§ (COMPL x β© x = β…)
</pre>

<DT><span class="strong">COMPL_UNION</span>
<DD>
<pre>
|- COMPL (s β t) = COMPL s β© COMPL t
</pre>

<DT><span class="strong">IN_COUNT</span>
<DD>
<pre>
|- β€m n. m β count n β‡” m < n
</pre>

<DT><span class="strong">COUNT_applied</span>
<DD>
<pre>
|- β€m n. count n m β‡” m < n
</pre>

<DT><span class="strong">COUNT_ZERO</span>
<DD>
<pre>
|- count 0 = β…
</pre>

<DT><span class="strong">COUNT_SUC</span>
<DD>
<pre>
|- β€n. count (SUC n) = n INSERT count n
</pre>

<DT><span class="strong">FINITE_COUNT</span>
<DD>
<pre>
|- β€n. FINITE (count n)
</pre>

<DT><span class="strong">CARD_COUNT</span>
<DD>
<pre>
|- β€n. CARD (count n) = n
</pre>

<DT><span class="strong">COUNT_11</span>
<DD>
<pre>
|- (count n1 = count n2) β‡” (n1 = n2)
</pre>

<DT><span class="strong">ITSET_ind</span>
<DD>
<pre>
|- β€P.
     (β€s b. (FINITE s β§ s β‰  β… β‡’ P (REST s) (f (CHOICE s) b)) β‡’ P s b) β‡’
     β€v v1. P v v1
</pre>

<DT><span class="strong">ITSET_def</span>
<DD>
<pre>
|- β€s f b.
     ITSET f s b =
     if FINITE s then if s = β… then b else ITSET f (REST s) (f (CHOICE s) b)
     else ARB
</pre>

<DT><span class="strong">ITSET_IND</span>
<DD>
<pre>
|- β€P.
     (β€s b. (FINITE s β§ s β‰  β… β‡’ P (REST s) (f (CHOICE s) b)) β‡’ P s b) β‡’
     β€v v1. P v v1
</pre>

<DT><span class="strong">ITSET_THM</span>
<DD>
<pre>
|- β€s f b.
     FINITE s β‡’
     (ITSET f s b = if s = β… then b else ITSET f (REST s) (f (CHOICE s) b))
</pre>

<DT><span class="strong">ITSET_EMPTY</span>
<DD>
<pre>
|- β€f b. ITSET f β… b = b
</pre>

<DT><span class="strong">ITSET_INSERT</span>
<DD>
<pre>
|- β€s.
     FINITE s β‡’
     β€f x b.
       ITSET f (x INSERT s) b =
       ITSET f (REST (x INSERT s)) (f (CHOICE (x INSERT s)) b)
</pre>

<DT><span class="strong">COMMUTING_ITSET_INSERT</span>
<DD>
<pre>
|- β€f s.
     (β€x y z. f x (f y z) = f y (f x z)) β§ FINITE s β‡’
     β€x b. ITSET f (x INSERT s) b = ITSET f (s DELETE x) (f x b)
</pre>

<DT><span class="strong">COMMUTING_ITSET_RECURSES</span>
<DD>
<pre>
|- β€f e s b.
     (β€x y z. f x (f y z) = f y (f x z)) β§ FINITE s β‡’
     (ITSET f (e INSERT s) b = f e (ITSET f (s DELETE e) b))
</pre>

<DT><span class="strong">SUM_IMAGE_THM</span>
<DD>
<pre>
|- β€f.
     (β‘ f β… = 0) β§
     β€e s. FINITE s β‡’ (β‘ f (e INSERT s) = f e + β‘ f (s DELETE e))
</pre>

<DT><span class="strong">SUM_IMAGE_SING</span>
<DD>
<pre>
|- β€f e. β‘ f {e} = f e
</pre>

<DT><span class="strong">SUM_IMAGE_SUBSET_LE</span>
<DD>
<pre>
|- β€f s t. FINITE s β§ t β† s β‡’ β‘ f t β‰¤ β‘ f s
</pre>

<DT><span class="strong">SUM_IMAGE_IN_LE</span>
<DD>
<pre>
|- β€f s e. FINITE s β§ e β s β‡’ f e β‰¤ β‘ f s
</pre>

<DT><span class="strong">SUM_IMAGE_DELETE</span>
<DD>
<pre>
|- β€f s.
     FINITE s β‡’ β€e. β‘ f (s DELETE e) = if e β s then β‘ f s β’ f e else β‘ f s
</pre>

<DT><span class="strong">SUM_IMAGE_UNION</span>
<DD>
<pre>
|- β€f s t. FINITE s β§ FINITE t β‡’ (β‘ f (s β t) = β‘ f s + β‘ f t β’ β‘ f (s β© t))
</pre>

<DT><span class="strong">SUM_IMAGE_lower_bound</span>
<DD>
<pre>
|- β€s. FINITE s β‡’ β€n. (β€x. x β s β‡’ n β‰¤ f x) β‡’ CARD s * n β‰¤ β‘ f s
</pre>

<DT><span class="strong">SUM_IMAGE_upper_bound</span>
<DD>
<pre>
|- β€s. FINITE s β‡’ β€n. (β€x. x β s β‡’ f x β‰¤ n) β‡’ β‘ f s β‰¤ CARD s * n
</pre>

<DT><span class="strong">SUM_SAME_IMAGE</span>
<DD>
<pre>
|- β€P.
     FINITE P β‡’
     β€f p. p β P β§ (β€q. q β P β‡’ (f p = f q)) β‡’ (β‘ f P = CARD P * f p)
</pre>

<DT><span class="strong">SUM_IMAGE_CONG</span>
<DD>
<pre>
|- (s1 = s2) β§ (β€x. x β s2 β‡’ (f1 x = f2 x)) β‡’ (β‘ f1 s1 = β‘ f2 s2)
</pre>

<DT><span class="strong">SUM_IMAGE_ZERO</span>
<DD>
<pre>
|- β€s. FINITE s β‡’ ((β‘ f s = 0) β‡” β€x. x β s β‡’ (f x = 0))
</pre>

<DT><span class="strong">ABS_DIFF_SUM_IMAGE</span>
<DD>
<pre>
|- β€s. FINITE s β‡’ ABS_DIFF (β‘ f s) (β‘ g s) β‰¤ β‘ (Ξ»x. ABS_DIFF (f x) (g x)) s
</pre>

<DT><span class="strong">SUM_IMAGE_MONO_LESS_EQ</span>
<DD>
<pre>
|- β€s. FINITE s β‡’ (β€x. x β s β‡’ f x β‰¤ g x) β‡’ β‘ f s β‰¤ β‘ g s
</pre>

<DT><span class="strong">SUM_IMAGE_MONO_LESS</span>
<DD>
<pre>
|- β€s.
     FINITE s β‡’
     (βƒx. x β s β§ f x < g x) β§ (β€x. x β s β‡’ f x β‰¤ g x) β‡’
     β‘ f s < β‘ g s
</pre>

<DT><span class="strong">SUM_SET_THM</span>
<DD>
<pre>
|- (SUM_SET β… = 0) β§
   β€x s. FINITE s β‡’ (SUM_SET (x INSERT s) = x + SUM_SET (s DELETE x))
</pre>

<DT><span class="strong">SUM_SET_EMPTY</span>
<DD>
<pre>
|- SUM_SET β… = 0
</pre>

<DT><span class="strong">SUM_SET_SING</span>
<DD>
<pre>
|- β€n. SUM_SET {n} = n
</pre>

<DT><span class="strong">SUM_SET_SUBSET_LE</span>
<DD>
<pre>
|- β€s t. FINITE t β§ s β† t β‡’ SUM_SET s β‰¤ SUM_SET t
</pre>

<DT><span class="strong">SUM_SET_IN_LE</span>
<DD>
<pre>
|- β€x s. FINITE s β§ x β s β‡’ x β‰¤ SUM_SET s
</pre>

<DT><span class="strong">SUM_SET_DELETE</span>
<DD>
<pre>
|- β€s.
     FINITE s β‡’
     β€e. SUM_SET (s DELETE e) = if e β s then SUM_SET s β’ e else SUM_SET s
</pre>

<DT><span class="strong">SUM_SET_UNION</span>
<DD>
<pre>
|- β€s t.
     FINITE s β§ FINITE t β‡’
     (SUM_SET (s β t) = SUM_SET s + SUM_SET t β’ SUM_SET (s β© t))
</pre>

<DT><span class="strong">PROD_IMAGE_THM</span>
<DD>
<pre>
|- β€f.
     (Ξ  f β… = 1) β§
     β€e s. FINITE s β‡’ (Ξ  f (e INSERT s) = f e * Ξ  f (s DELETE e))
</pre>

<DT><span class="strong">PROD_SET_THM</span>
<DD>
<pre>
|- (PROD_SET β… = 1) β§
   β€x s. FINITE s β‡’ (PROD_SET (x INSERT s) = x * PROD_SET (s DELETE x))
</pre>

<DT><span class="strong">PROD_SET_EMPTY</span>
<DD>
<pre>
|- PROD_SET β… = 1
</pre>

<DT><span class="strong">PROD_SET_IMAGE_REDUCTION</span>
<DD>
<pre>
|- β€f s x.
     FINITE (IMAGE f s) β§ f x β‰ IMAGE f s β‡’
     (PROD_SET (IMAGE f (x INSERT s)) = f x * PROD_SET (IMAGE f s))
</pre>

<DT><span class="strong">MAX_SET_THM</span>
<DD>
<pre>
|- (MAX_SET β… = 0) β§
   β€e s. FINITE s β‡’ (MAX_SET (e INSERT s) = MAX e (MAX_SET s))
</pre>

<DT><span class="strong">MAX_SET_REWRITES</span>
<DD>
<pre>
|- (MAX_SET β… = 0) β§ (MAX_SET {e} = e)
</pre>

<DT><span class="strong">MAX_SET_ELIM</span>
<DD>
<pre>
|- β€P Q.
     FINITE P β§ ((P = β…) β‡’ Q 0) β§ (β€x. (β€y. y β P β‡’ y β‰¤ x) β§ x β P β‡’ Q x) β‡’
     Q (MAX_SET P)
</pre>

<DT><span class="strong">MIN_SET_ELIM</span>
<DD>
<pre>
|- β€P Q. P β‰  β… β§ (β€x. (β€y. y β P β‡’ x β‰¤ y) β§ x β P β‡’ Q x) β‡’ Q (MIN_SET P)
</pre>

<DT><span class="strong">MIN_SET_THM</span>
<DD>
<pre>
|- (β€e. MIN_SET {e} = e) β§
   β€s e1 e2. MIN_SET (e1 INSERT e2 INSERT s) = MIN e1 (MIN_SET (e2 INSERT s))
</pre>

<DT><span class="strong">MIN_SET_LEM</span>
<DD>
<pre>
|- β€s. s β‰  β… β‡’ MIN_SET s β s β§ β€x. x β s β‡’ MIN_SET s β‰¤ x
</pre>

<DT><span class="strong">SUBSET_MIN_SET</span>
<DD>
<pre>
|- β€I J n. I β‰  β… β§ J β‰  β… β§ I β† J β‡’ MIN_SET J β‰¤ MIN_SET I
</pre>

<DT><span class="strong">SUBSET_MAX_SET</span>
<DD>
<pre>
|- β€I J n. FINITE I β§ FINITE J β§ I β† J β‡’ MAX_SET I β‰¤ MAX_SET J
</pre>

<DT><span class="strong">MIN_SET_LEQ_MAX_SET</span>
<DD>
<pre>
|- β€s. s β‰  β… β§ FINITE s β‡’ MIN_SET s β‰¤ MAX_SET s
</pre>

<DT><span class="strong">MIN_SET_UNION</span>
<DD>
<pre>
|- β€A B.
     FINITE A β§ FINITE B β§ A β‰  β… β§ B β‰  β… β‡’
     (MIN_SET (A β B) = MIN (MIN_SET A) (MIN_SET B))
</pre>

<DT><span class="strong">MAX_SET_UNION</span>
<DD>
<pre>
|- β€A B. FINITE A β§ FINITE B β‡’ (MAX_SET (A β B) = MAX (MAX_SET A) (MAX_SET B))
</pre>

<DT><span class="strong">IN_POW</span>
<DD>
<pre>
|- β€set e. e β POW set β‡” e β† set
</pre>

<DT><span class="strong">UNIV_FUN_TO_BOOL</span>
<DD>
<pre>
|- π•(:Ξ± -> bool) = POW π•(:Ξ±)
</pre>

<DT><span class="strong">SUBSET_POW</span>
<DD>
<pre>
|- β€s1 s2. s1 β† s2 β‡’ POW s1 β† POW s2
</pre>

<DT><span class="strong">SUBSET_INSERT_RIGHT</span>
<DD>
<pre>
|- β€e s1 s2. s1 β† s2 β‡’ s1 β† e INSERT s2
</pre>

<DT><span class="strong">SUBSET_DELETE_BOTH</span>
<DD>
<pre>
|- β€s1 s2 x. s1 β† s2 β‡’ s1 DELETE x β† s2 DELETE x
</pre>

<DT><span class="strong">POW_EMPTY</span>
<DD>
<pre>
|- β€s. POW s β‰  β…
</pre>

<DT><span class="strong">POW_INSERT</span>
<DD>
<pre>
|- β€e s. POW (e INSERT s) = IMAGE ($INSERT e) (POW s) β POW s
</pre>

<DT><span class="strong">POW_EQNS</span>
<DD>
<pre>
|- (POW β… = {β…}) β§
   β€e s. POW (e INSERT s) = (let ps = POW s in IMAGE ($INSERT e) ps β ps)
</pre>

<DT><span class="strong">FINITE_POW</span>
<DD>
<pre>
|- β€s. FINITE s β‡’ FINITE (POW s)
</pre>

<DT><span class="strong">CARD_POW</span>
<DD>
<pre>
|- β€s. FINITE s β‡’ (CARD (POW s) = 2 ** CARD s)
</pre>

<DT><span class="strong">GSPEC_ETA</span>
<DD>
<pre>
|- {x | P x} = P
</pre>

<DT><span class="strong">GSPEC_F</span>
<DD>
<pre>
|- {x | F} = β…
</pre>

<DT><span class="strong">GSPEC_T</span>
<DD>
<pre>
|- {x | T} = π•(:Ξ±)
</pre>

<DT><span class="strong">GSPEC_ID</span>
<DD>
<pre>
|- {x | x β y} = y
</pre>

<DT><span class="strong">GSPEC_EQ</span>
<DD>
<pre>
|- {x | x = y} = {y}
</pre>

<DT><span class="strong">GSPEC_EQ2</span>
<DD>
<pre>
|- {x | y = x} = {y}
</pre>

<DT><span class="strong">GSPEC_F_COND</span>
<DD>
<pre>
|- β€f. (β€x. Β¬SND (f x)) β‡’ (GSPEC f = β…)
</pre>

<DT><span class="strong">GSPEC_AND</span>
<DD>
<pre>
|- β€P Q. {x | P x β§ Q x} = {x | P x} β© {x | Q x}
</pre>

<DT><span class="strong">GSPEC_OR</span>
<DD>
<pre>
|- β€P Q. {x | P x β¨ Q x} = {x | P x} β {x | Q x}
</pre>

<DT><span class="strong">BIGUNION_partition</span>
<DD>
<pre>
|- R equiv_on s β‡’ (BIGUNION (partition R s) = s)
</pre>

<DT><span class="strong">EMPTY_NOT_IN_partition</span>
<DD>
<pre>
|- R equiv_on s β‡’ β… β‰ partition R s
</pre>

<DT><span class="strong">partition_elements_disjoint</span>
<DD>
<pre>
|- R equiv_on s β‡’
   β€t1 t2. t1 β partition R s β§ t2 β partition R s β§ t1 β‰  t2 β‡’ DISJOINT t1 t2
</pre>

<DT><span class="strong">partition_elements_interrelate</span>
<DD>
<pre>
|- R equiv_on s β‡’ β€t. t β partition R s β‡’ β€x y. x β t β§ y β t β‡’ R x y
</pre>

<DT><span class="strong">partition_SUBSET</span>
<DD>
<pre>
|- β€R s t. t β partition R s β‡’ t β† s
</pre>

<DT><span class="strong">FINITE_partition</span>
<DD>
<pre>
|- β€R s. FINITE s β‡’ FINITE (partition R s) β§ β€t. t β partition R s β‡’ FINITE t
</pre>

<DT><span class="strong">partition_CARD</span>
<DD>
<pre>
|- β€R s. R equiv_on s β§ FINITE s β‡’ (CARD s = β‘ CARD (partition R s))
</pre>

<DT><span class="strong">pairwise_UNION</span>
<DD>
<pre>
|- pairwise R (s1 β s2) β‡”
   pairwise R s1 β§ pairwise R s2 β§ β€x y. x β s1 β§ y β s2 β‡’ R x y β§ R y x
</pre>

<DT><span class="strong">pairwise_SUBSET</span>
<DD>
<pre>
|- β€R s t. pairwise R t β§ s β† t β‡’ pairwise R s
</pre>

<DT><span class="strong">KoenigsLemma</span>
<DD>
<pre>
|- β€R.
     (β€x. FINITE {y | R x y}) β‡’
     β€x. INFINITE {y | R^* x y} β‡’ βƒf. (f 0 = x) β§ β€n. R (f n) (f (SUC n))
</pre>

<DT><span class="strong">KoenigsLemma_WF</span>
<DD>
<pre>
|- β€R. (β€x. FINITE {y | R x y}) β§ WF (inv R) β‡’ β€x. FINITE {y | R^* x y}
</pre>

<DT><span class="strong">SET_EQ_SUBSET</span>
<DD>
<pre>
|- β€s1 s2. (s1 = s2) β‡” s1 β† s2 β§ s2 β† s1
</pre>

<DT><span class="strong">PSUBSET_EQN</span>
<DD>
<pre>
|- β€s1 s2. s1 β‚ s2 β‡” s1 β† s2 β§ Β¬(s2 β† s1)
</pre>

<DT><span class="strong">PSUBSET_SUBSET_TRANS</span>
<DD>
<pre>
|- β€s t u. s β‚ t β§ t β† u β‡’ s β‚ u
</pre>

<DT><span class="strong">SUBSET_PSUBSET_TRANS</span>
<DD>
<pre>
|- β€s t u. s β† t β§ t β‚ u β‡’ s β‚ u
</pre>

<DT><span class="strong">CROSS_EQNS</span>
<DD>
<pre>
|- β€s1 s2.
     (β… Γ— s2 = β…) β§ ((a INSERT s1) Γ— s2 = IMAGE (Ξ»y. (a,y)) s2 β s1 Γ— s2)
</pre>

<DT><span class="strong">count_EQN</span>
<DD>
<pre>
|- β€n. count n = if n = 0 then β… else (let p = PRE n in p INSERT count p)
</pre>

<DT><span class="strong">UNIQUE_MEMBER_SING</span>
<DD>
<pre>
|- β€x s. x β s β§ (β€y. y β s β‡’ (x = y)) β‡” (s = {x})
</pre>

<DT><span class="strong">inj_surj</span>
<DD>
<pre>
|- β€f s t. INJ f s t β‡’ (s = β…) β¨ βƒf'. SURJ f' t s
</pre>

<DT><span class="strong">infinite_rest</span>
<DD>
<pre>
|- β€s. INFINITE s β‡’ INFINITE (REST s)
</pre>

<DT><span class="strong">chooser_def_compute</span>
<DD>
<pre>
|- (β€s. chooser s 0 = CHOICE s) β§
   (β€s n.
      chooser s (NUMERAL (BIT1 n)) =
      chooser (REST s) (NUMERAL (BIT1 n) β’ 1)) β§
   β€s n. chooser s (NUMERAL (BIT2 n)) = chooser (REST s) (NUMERAL (BIT1 n))
</pre>

<DT><span class="strong">infinite_num_inj</span>
<DD>
<pre>
|- β€s. INFINITE s β‡” βƒf. INJ f π•(:num) s
</pre>

<DT><span class="strong">countable_image_nats</span>
<DD>
<pre>
|- countable (IMAGE f π•(:num))
</pre>

<DT><span class="strong">countable_surj</span>
<DD>
<pre>
|- β€s. countable s β‡” (s = β…) β¨ βƒf. SURJ f π•(:num) s
</pre>

<DT><span class="strong">num_countable</span>
<DD>
<pre>
|- countable π•(:num)
</pre>

<DT><span class="strong">subset_countable</span>
<DD>
<pre>
|- β€s t. countable s β§ t β† s β‡’ countable t
</pre>

<DT><span class="strong">image_countable</span>
<DD>
<pre>
|- β€f s. countable s β‡’ countable (IMAGE f s)
</pre>

<DT><span class="strong">finite_countable</span>
<DD>
<pre>
|- β€s. FINITE s β‡’ countable s
</pre>

<DT><span class="strong">pair_to_num_formula</span>
<DD>
<pre>
|- β€x y. pair_to_num (x,y) = (x + y + 1) * (x + y) DIV 2 + y
</pre>

<DT><span class="strong">pair_to_num_inv</span>
<DD>
<pre>
|- (β€x. pair_to_num (num_to_pair x) = x) β§
   β€x y. num_to_pair (pair_to_num (x,y)) = (x,y)
</pre>

<DT><span class="strong">cross_countable</span>
<DD>
<pre>
|- β€s t. countable s β§ countable t β‡’ countable (s Γ— t)
</pre>

<DT><span class="strong">inter_countable</span>
<DD>
<pre>
|- β€s t. countable s β¨ countable t β‡’ countable (s β© t)
</pre>

<DT><span class="strong">inj_countable</span>
<DD>
<pre>
|- β€f s t. countable t β§ INJ f s t β‡’ countable s
</pre>

<DT><span class="strong">bigunion_countable</span>
<DD>
<pre>
|- β€s. countable s β§ (β€x. x β s β‡’ countable x) β‡’ countable (BIGUNION s)
</pre>

<DT><span class="strong">union_countable</span>
<DD>
<pre>
|- β€s t. countable s β§ countable t β‡’ countable (s β t)
</pre>

<DT><span class="strong">union_countable_IFF</span>
<DD>
<pre>
|- countable (s β t) β‡” countable s β§ countable t
</pre>

<DT><span class="strong">inj_image_countable_IFF</span>
<DD>
<pre>
|- INJ f s (IMAGE f s) β‡’ (countable (IMAGE f s) β‡” countable s)
</pre>

<DT><span class="strong">pow_no_surj</span>
<DD>
<pre>
|- β€s. Β¬βƒf. SURJ f s (POW s)
</pre>

<DT><span class="strong">infinite_pow_uncountable</span>
<DD>
<pre>
|- β€s. INFINITE s β‡’ Β¬countable (POW s)
</pre>

<DT><span class="strong">countable_Usum</span>
<DD>
<pre>
|- countable π•(:Ξ± + Ξ²) β‡” countable π•(:Ξ±) β§ countable π•(:Ξ²)
</pre>

<DT><span class="strong">countable_EMPTY</span>
<DD>
<pre>
|- countable β…
</pre>

<DT><span class="strong">countable_INSERT</span>
<DD>
<pre>
|- countable (x INSERT s) β‡” countable s
</pre>

<DT><span class="strong">cross_countable_IFF</span>
<DD>
<pre>
|- countable (s Γ— t) β‡” (s = β…) β¨ (t = β…) β¨ countable s β§ countable t
</pre>

<DT><span class="strong">countable_Uprod</span>
<DD>
<pre>
|- countable π•(:Ξ± # Ξ²) β‡” countable π•(:Ξ±) β§ countable π•(:Ξ²)
</pre>

<DT><span class="strong">IMAGE_BIGUNION</span>
<DD>
<pre>
|- β€f M. IMAGE f (BIGUNION M) = BIGUNION (IMAGE (IMAGE f) M)
</pre>

<DT><span class="strong">SUBSET_DIFF</span>
<DD>
<pre>
|- β€s1 s2 s3. s1 β† s2 DIFF s3 β‡” s1 β† s2 β§ DISJOINT s1 s3
</pre>

<DT><span class="strong">INTER_SUBSET_EQN</span>
<DD>
<pre>
|- ((A β© B = A) β‡” A β† B) β§ ((A β© B = B) β‡” B β† A)
</pre>

<DT><span class="strong">PSUBSET_SING</span>
<DD>
<pre>
|- β€s x. x β‚ {s} β‡” (x = β…)
</pre>

<DT><span class="strong">INTER_UNION</span>
<DD>
<pre>
|- ((A β B) β© A = A) β§ ((B β A) β© A = A) β§ (A β© (A β B) = A) β§
   (A β© (B β A) = A)
</pre>

<DT><span class="strong">UNION_DELETE</span>
<DD>
<pre>
|- β€A B x. A β B DELETE x = A DELETE x β (B DELETE x)
</pre>

<DT><span class="strong">DELETE_SUBSET_INSERT</span>
<DD>
<pre>
|- β€s e s2. s DELETE e β† s2 β‡” s β† e INSERT s2
</pre>

<DT><span class="strong">IN_INSERT_EXPAND</span>
<DD>
<pre>
|- β€x y P. x β y INSERT P β‡” (x = y) β¨ x β‰  y β§ x β P
</pre>

<DT><span class="strong">FINITE_INTER</span>
<DD>
<pre>
|- β€s1 s2. FINITE s1 β¨ FINITE s2 β‡’ FINITE (s1 β© s2)
</pre>

<DT><span class="strong">INSERT_EQ_SING</span>
<DD>
<pre>
|- β€s x y. (x INSERT s = {y}) β‡” (x = y) β§ s β† {y}
</pre>

<DT><span class="strong">CARD_UNION_LE</span>
<DD>
<pre>
|- FINITE s β§ FINITE t β‡’ CARD (s β t) β‰¤ CARD s + CARD t
</pre>

<DT><span class="strong">IMAGE_SUBSET_gen</span>
<DD>
<pre>
|- β€f s u t. s β† u β§ IMAGE f u β† t β‡’ IMAGE f s β† t
</pre>

<DT><span class="strong">CARD_REST</span>
<DD>
<pre>
|- β€s. FINITE s β§ s β‰  β… β‡’ (CARD (REST s) = CARD s β’ 1)
</pre>

<DT><span class="strong">SUBSET_DIFF_EMPTY</span>
<DD>
<pre>
|- β€s t. (s DIFF t = β…) β‡” s β† t
</pre>

<DT><span class="strong">DIFF_INTER_SUBSET</span>
<DD>
<pre>
|- β€r s t. r β† s β‡’ (r DIFF s β© t = r DIFF t)
</pre>

<DT><span class="strong">UNION_DIFF_2</span>
<DD>
<pre>
|- β€s t. s β (s DIFF t) = s
</pre>

<DT><span class="strong">count_add</span>
<DD>
<pre>
|- β€n m. count (n + m) = count n β IMAGE ($+ n) (count m)
</pre>

<DT><span class="strong">IMAGE_EQ_SING</span>
<DD>
<pre>
|- (IMAGE f s = {z}) β‡” s β‰  β… β§ β€x. x β s β‡’ (f x = z)
</pre>

<DT><span class="strong">count_add1</span>
<DD>
<pre>
|- β€n. count (n + 1) = n INSERT count n
</pre>

<DT><span class="strong">compl_insert</span>
<DD>
<pre>
|- β€s x. COMPL (x INSERT s) = COMPL s DELETE x
</pre>

<DT><span class="strong">in_max_set</span>
<DD>
<pre>
|- β€s. FINITE s β‡’ β€x. x β s β‡’ x β‰¤ MAX_SET s
</pre>

</DL>



<hr>
</body>
</html>
