<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: words</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "words"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "sum_numTheory.html"><span class="strong">sum_num</span></a>&nbsp;&nbsp;
    <a href = "ASCIInumbersTheory.html"><span class="strong">ASCIInumbers</span></a>&nbsp;&nbsp;
    <a href = "numeral_bitTheory.html"><span class="strong">numeral_bit</span></a>&nbsp;&nbsp;
    <a href = "fcpTheory.html"><span class="strong">fcp</span></a>

<h1>Signature</h1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr>
    <th>
    Constant
    <th>
    Type<tr><td> <span class="strong">BIT_SET</span> <td> :num -> num reln
    <tr><td>
        <span class="strong">BIT_SET_tupled</span>
        <td>
        :num # num -> num -> bool
    <tr><td> <span class="strong">INT_MAX</span> <td> :α itself -> num
    <tr><td> <span class="strong">INT_MIN</span> <td> :α itself -> num
    <tr><td> <span class="strong">UINT_MAX</span> <td> :α itself -> num
    <tr><td>
        <span class="strong">add_with_carry</span>
        <td>
        :α word # α word # bool -> α word # bool # bool
    <tr><td> <span class="strong">bit_count</span> <td> :α word -> num
    <tr><td>
        <span class="strong">bit_count_upto</span>
        <td>
        :num -> α word -> num
    <tr><td>
        <span class="strong">bit_field_insert</span>
        <td>
        :num -> num -> β word -> α word -> α word
    <tr><td>
        <span class="strong">concat_word_list</span>
        <td>
        :α word list -> β word
    <tr><td> <span class="strong">dimword</span> <td> :α itself -> num
    <tr><td> <span class="strong">l2w</span> <td> :num -> num list -> α word
    <tr><td> <span class="strong">n2w</span> <td> :num -> α word
    <tr><td>
        <span class="strong">n2w_itself</span>
        <td>
        :num # α itself -> α word
    <tr><td>
        <span class="strong">nzcv</span>
        <td>
        :α word -> α word -> bool # bool # bool # bool
    <tr><td> <span class="strong">reduce_and</span> <td> :α word -> word1
    <tr><td> <span class="strong">reduce_nand</span> <td> :α word -> word1
    <tr><td> <span class="strong">reduce_nor</span> <td> :α word -> word1
    <tr><td> <span class="strong">reduce_or</span> <td> :α word -> word1
    <tr><td> <span class="strong">reduce_xnor</span> <td> :α word -> word1
    <tr><td> <span class="strong">reduce_xor</span> <td> :α word -> word1
    <tr><td>
        <span class="strong">s2w</span>
        <td>
        :num -> (char -> num) -> string -> α word
    <tr><td>
        <span class="strong">saturate_add</span>
        <td>
        :α word -> α word -> α word
    <tr><td>
        <span class="strong">saturate_mul</span>
        <td>
        :α word -> α word -> α word
    <tr><td> <span class="strong">saturate_n2w</span> <td> :num -> α word
    <tr><td>
        <span class="strong">saturate_sub</span>
        <td>
        :α word -> α word -> α word
    <tr><td> <span class="strong">saturate_w2w</span> <td> :α word -> β word
    <tr><td> <span class="strong">sw2sw</span> <td> :α word -> β word
    <tr><td> <span class="strong">w2l</span> <td> :num -> α word -> num list
    <tr><td> <span class="strong">w2n</span> <td> :α word -> num
    <tr><td>
        <span class="strong">w2s</span>
        <td>
        :num -> (num -> char) -> α word -> string
    <tr><td> <span class="strong">w2w</span> <td> :α word -> β word
    <tr><td> <span class="strong">word_1comp</span> <td> :α word -> α word
    <tr><td> <span class="strong">word_2comp</span> <td> :α word -> α word
    <tr><td> <span class="strong">word_H</span> <td> :α word
    <tr><td> <span class="strong">word_L</span> <td> :α word
    <tr><td> <span class="strong">word_L2</span> <td> :α word
    <tr><td> <span class="strong">word_T</span> <td> :α word
    <tr><td> <span class="strong">word_abs</span> <td> :α word -> α word
    <tr><td>
        <span class="strong">word_add</span>
        <td>
        :α word -> α word -> α word
    <tr><td>
        <span class="strong">word_and</span>
        <td>
        :α word -> α word -> α word
    <tr><td>
        <span class="strong">word_asr</span>
        <td>
        :α word -> num -> α word
    <tr><td>
        <span class="strong">word_asr_bv</span>
        <td>
        :α word -> α word -> α word
    <tr><td> <span class="strong">word_bit</span> <td> :num -> α word -> bool
    <tr><td>
        <span class="strong">word_bits</span>
        <td>
        :num -> num -> α word -> α word
    <tr><td>
        <span class="strong">word_compare</span>
        <td>
        :α word -> α word -> word1
    <tr><td>
        <span class="strong">word_concat</span>
        <td>
        :α word -> β word -> γ word
    <tr><td>
        <span class="strong">word_div</span>
        <td>
        :α word -> α word -> α word
    <tr><td>
        <span class="strong">word_extract</span>
        <td>
        :num -> num -> α word -> β word
    <tr><td>
        <span class="strong">word_from_bin_list</span>
        <td>
        :num list -> α word
    <tr><td>
        <span class="strong">word_from_bin_string</span>
        <td>
        :string -> α word
    <tr><td>
        <span class="strong">word_from_dec_list</span>
        <td>
        :num list -> α word
    <tr><td>
        <span class="strong">word_from_dec_string</span>
        <td>
        :string -> α word
    <tr><td>
        <span class="strong">word_from_hex_list</span>
        <td>
        :num list -> α word
    <tr><td>
        <span class="strong">word_from_hex_string</span>
        <td>
        :string -> α word
    <tr><td>
        <span class="strong">word_from_oct_list</span>
        <td>
        :num list -> α word
    <tr><td>
        <span class="strong">word_from_oct_string</span>
        <td>
        :string -> α word
    <tr><td> <span class="strong">word_ge</span> <td> :α word reln
    <tr><td> <span class="strong">word_gt</span> <td> :α word reln
    <tr><td> <span class="strong">word_hi</span> <td> :α word reln
    <tr><td> <span class="strong">word_hs</span> <td> :α word reln
    <tr><td>
        <span class="strong">word_join</span>
        <td>
        :α word -> β word -> (α + β) word
    <tr><td> <span class="strong">word_le</span> <td> :α word reln
    <tr><td> <span class="strong">word_len</span> <td> :α word -> num
    <tr><td> <span class="strong">word_lo</span> <td> :α word reln
    <tr><td> <span class="strong">word_log2</span> <td> :α word -> α word
    <tr><td> <span class="strong">word_ls</span> <td> :α word reln
    <tr><td> <span class="strong">word_lsb</span> <td> :α word -> bool
    <tr><td>
        <span class="strong">word_lsl</span>
        <td>
        :α word -> num -> α word
    <tr><td>
        <span class="strong">word_lsl_bv</span>
        <td>
        :α word -> α word -> α word
    <tr><td>
        <span class="strong">word_lsr</span>
        <td>
        :α word -> num -> α word
    <tr><td>
        <span class="strong">word_lsr_bv</span>
        <td>
        :α word -> α word -> α word
    <tr><td> <span class="strong">word_lt</span> <td> :α word reln
    <tr><td>
        <span class="strong">word_max</span>
        <td>
        :α word -> α word -> α word
    <tr><td>
        <span class="strong">word_min</span>
        <td>
        :α word -> α word -> α word
    <tr><td>
        <span class="strong">word_mod</span>
        <td>
        :α word -> α word -> α word
    <tr><td>
        <span class="strong">word_modify</span>
        <td>
        :(num -> bool -> bool) -> α word -> α word
    <tr><td> <span class="strong">word_msb</span> <td> :α word -> bool
    <tr><td>
        <span class="strong">word_mul</span>
        <td>
        :α word -> α word -> α word
    <tr><td>
        <span class="strong">word_nand</span>
        <td>
        :α word -> α word -> α word
    <tr><td>
        <span class="strong">word_nor</span>
        <td>
        :α word -> α word -> α word
    <tr><td>
        <span class="strong">word_or</span>
        <td>
        :α word -> α word -> α word
    <tr><td>
        <span class="strong">word_reduce</span>
        <td>
        :bool reln -> α word -> word1
    <tr><td>
        <span class="strong">word_replicate</span>
        <td>
        :num -> α word -> β word
    <tr><td> <span class="strong">word_reverse</span> <td> :α word -> α word
    <tr><td>
        <span class="strong">word_rol</span>
        <td>
        :α word -> num -> α word
    <tr><td>
        <span class="strong">word_rol_bv</span>
        <td>
        :α word -> α word -> α word
    <tr><td>
        <span class="strong">word_ror</span>
        <td>
        :α word -> num -> α word
    <tr><td>
        <span class="strong">word_ror_bv</span>
        <td>
        :α word -> α word -> α word
    <tr><td>
        <span class="strong">word_rrx</span>
        <td>
        :bool # α word -> bool # α word
    <tr><td>
        <span class="strong">word_sdiv</span>
        <td>
        :α word -> α word -> α word
    <tr><td>
        <span class="strong">word_sign_extend</span>
        <td>
        :num -> α word -> α word
    <tr><td>
        <span class="strong">word_signed_bits</span>
        <td>
        :num -> num -> α word -> α word
    <tr><td>
        <span class="strong">word_slice</span>
        <td>
        :num -> num -> α word -> α word
    <tr><td>
        <span class="strong">word_smax</span>
        <td>
        :α word -> α word -> α word
    <tr><td>
        <span class="strong">word_smin</span>
        <td>
        :α word -> α word -> α word
    <tr><td>
        <span class="strong">word_smod</span>
        <td>
        :α word -> α word -> α word
    <tr><td>
        <span class="strong">word_srem</span>
        <td>
        :α word -> α word -> α word
    <tr><td>
        <span class="strong">word_sub</span>
        <td>
        :α word -> α word -> α word
    <tr><td>
        <span class="strong">word_to_bin_list</span>
        <td>
        :α word -> num list
    <tr><td>
        <span class="strong">word_to_bin_string</span>
        <td>
        :α word -> string
    <tr><td>
        <span class="strong">word_to_dec_list</span>
        <td>
        :α word -> num list
    <tr><td>
        <span class="strong">word_to_dec_string</span>
        <td>
        :α word -> string
    <tr><td>
        <span class="strong">word_to_hex_list</span>
        <td>
        :α word -> num list
    <tr><td>
        <span class="strong">word_to_hex_string</span>
        <td>
        :α word -> string
    <tr><td>
        <span class="strong">word_to_oct_list</span>
        <td>
        :α word -> num list
    <tr><td>
        <span class="strong">word_to_oct_string</span>
        <td>
        :α word -> string
    <tr><td>
        <span class="strong">word_xnor</span>
        <td>
        :α word -> α word -> α word
    <tr><td>
        <span class="strong">word_xor</span>
        <td>
        :α word -> α word -> α word

</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">dimword_def</span>
<DD>
<pre>
|- dimword (:α) = 2 ** dimindex (:α)
</pre>

<DT><span class="strong">INT_MIN_def</span>
<DD>
<pre>
|- INT_MIN (:α) = 2 ** (dimindex (:α) − 1)
</pre>

<DT><span class="strong">UINT_MAX_def</span>
<DD>
<pre>
|- UINT_MAX (:α) = dimword (:α) − 1
</pre>

<DT><span class="strong">INT_MAX_def</span>
<DD>
<pre>
|- INT_MAX (:α) = INT_MIN (:α) − 1
</pre>

<DT><span class="strong">w2n_def</span>
<DD>
<pre>
|- ∀w. w2n w = SUM (dimindex (:α)) (λi. SBIT (w ' i) i)
</pre>

<DT><span class="strong">n2w_def</span>
<DD>
<pre>
|- ∀n. n2w n = FCP i. BIT i n
</pre>

<DT><span class="strong">w2w_def</span>
<DD>
<pre>
|- ∀w. w2w w = n2w (w2n w)
</pre>

<DT><span class="strong">sw2sw_def</span>
<DD>
<pre>
|- ∀w. sw2sw w = n2w (SIGN_EXTEND (dimindex (:α)) (dimindex (:β)) (w2n w))
</pre>

<DT><span class="strong">w2l_def</span>
<DD>
<pre>
|- ∀b w. w2l b w = n2l b (w2n w)
</pre>

<DT><span class="strong">l2w_def</span>
<DD>
<pre>
|- ∀b l. l2w b l = n2w (l2n b l)
</pre>

<DT><span class="strong">w2s_def</span>
<DD>
<pre>
|- ∀b f w. w2s b f w = n2s b f (w2n w)
</pre>

<DT><span class="strong">s2w_def</span>
<DD>
<pre>
|- ∀b f s. s2w b f s = n2w (s2n b f s)
</pre>

<DT><span class="strong">word_from_bin_list_def</span>
<DD>
<pre>
|- word_from_bin_list = l2w 2
</pre>

<DT><span class="strong">word_from_oct_list_def</span>
<DD>
<pre>
|- word_from_oct_list = l2w 8
</pre>

<DT><span class="strong">word_from_dec_list_def</span>
<DD>
<pre>
|- word_from_dec_list = l2w 10
</pre>

<DT><span class="strong">word_from_hex_list_def</span>
<DD>
<pre>
|- word_from_hex_list = l2w 16
</pre>

<DT><span class="strong">word_to_bin_list_def</span>
<DD>
<pre>
|- word_to_bin_list = w2l 2
</pre>

<DT><span class="strong">word_to_oct_list_def</span>
<DD>
<pre>
|- word_to_oct_list = w2l 8
</pre>

<DT><span class="strong">word_to_dec_list_def</span>
<DD>
<pre>
|- word_to_dec_list = w2l 10
</pre>

<DT><span class="strong">word_to_hex_list_def</span>
<DD>
<pre>
|- word_to_hex_list = w2l 16
</pre>

<DT><span class="strong">word_from_bin_string_def</span>
<DD>
<pre>
|- word_from_bin_string = s2w 2 UNHEX
</pre>

<DT><span class="strong">word_from_oct_string_def</span>
<DD>
<pre>
|- word_from_oct_string = s2w 8 UNHEX
</pre>

<DT><span class="strong">word_from_dec_string_def</span>
<DD>
<pre>
|- word_from_dec_string = s2w 10 UNHEX
</pre>

<DT><span class="strong">word_from_hex_string_def</span>
<DD>
<pre>
|- word_from_hex_string = s2w 16 UNHEX
</pre>

<DT><span class="strong">word_to_bin_string_def</span>
<DD>
<pre>
|- word_to_bin_string = w2s 2 HEX
</pre>

<DT><span class="strong">word_to_oct_string_def</span>
<DD>
<pre>
|- word_to_oct_string = w2s 8 HEX
</pre>

<DT><span class="strong">word_to_dec_string_def</span>
<DD>
<pre>
|- word_to_dec_string = w2s 10 HEX
</pre>

<DT><span class="strong">word_to_hex_string_def</span>
<DD>
<pre>
|- word_to_hex_string = w2s 16 HEX
</pre>

<DT><span class="strong">word_T_def</span>
<DD>
<pre>
|- UINT_MAXw = n2w (UINT_MAX (:α))
</pre>

<DT><span class="strong">word_L_def</span>
<DD>
<pre>
|- INT_MINw = n2w (INT_MIN (:α))
</pre>

<DT><span class="strong">word_H_def</span>
<DD>
<pre>
|- INT_MAXw = n2w (INT_MAX (:α))
</pre>

<DT><span class="strong">word_1comp_def</span>
<DD>
<pre>
|- ∀w. ¬w = FCP i. ¬w ' i
</pre>

<DT><span class="strong">word_and_def</span>
<DD>
<pre>
|- ∀v w. v && w = FCP i. v ' i ∧ w ' i
</pre>

<DT><span class="strong">word_or_def</span>
<DD>
<pre>
|- ∀v w. v ‖ w = FCP i. v ' i ∨ w ' i
</pre>

<DT><span class="strong">word_xor_def</span>
<DD>
<pre>
|- ∀v w. v ⊕ w = FCP i. v ' i ⇎ w ' i
</pre>

<DT><span class="strong">word_nand_def</span>
<DD>
<pre>
|- ∀v w. v ~&& w = FCP i. ¬(v ' i ∧ w ' i)
</pre>

<DT><span class="strong">word_nor_def</span>
<DD>
<pre>
|- ∀v w. v ~|| w = FCP i. ¬(v ' i ∨ w ' i)
</pre>

<DT><span class="strong">word_xnor_def</span>
<DD>
<pre>
|- ∀v w. v ~?? w = FCP i. v ' i ⇔ w ' i
</pre>

<DT><span class="strong">word_reduce_def</span>
<DD>
<pre>
|- ∀f w.
     word_reduce f w =
     $FCP
       (K
          (let l = GENLIST (λi. w ' (dimindex (:α) − 1 − i)) (dimindex (:α))
           in
             FOLDL f (HD l) (TL l)))
</pre>

<DT><span class="strong">word_compare_def</span>
<DD>
<pre>
|- ∀a b. word_compare a b = if a = b then 1w else 0w
</pre>

<DT><span class="strong">reduce_and_def</span>
<DD>
<pre>
|- reduce_and = word_reduce $/\
</pre>

<DT><span class="strong">reduce_or_def</span>
<DD>
<pre>
|- reduce_or = word_reduce $\/
</pre>

<DT><span class="strong">reduce_xor_def</span>
<DD>
<pre>
|- reduce_xor = word_reduce (λx y. x ⇎ y)
</pre>

<DT><span class="strong">reduce_nand_def</span>
<DD>
<pre>
|- reduce_nand = word_reduce (λa b. ¬(a ∧ b))
</pre>

<DT><span class="strong">reduce_nor_def</span>
<DD>
<pre>
|- reduce_nor = word_reduce (λa b. ¬(a ∨ b))
</pre>

<DT><span class="strong">reduce_xnor_def</span>
<DD>
<pre>
|- reduce_xnor = word_reduce $<=>
</pre>

<DT><span class="strong">word_lsb_def</span>
<DD>
<pre>
|- ∀w. word_lsb w ⇔ w ' 0
</pre>

<DT><span class="strong">word_msb_def</span>
<DD>
<pre>
|- ∀w. word_msb w ⇔ w ' (dimindex (:α) − 1)
</pre>

<DT><span class="strong">word_slice_def</span>
<DD>
<pre>
|- ∀h l. h '' l = (λw. FCP i. l ≤ i ∧ i ≤ MIN h (dimindex (:α) − 1) ∧ w ' i)
</pre>

<DT><span class="strong">word_bits_def</span>
<DD>
<pre>
|- ∀h l. h -- l = (λw. FCP i. i + l ≤ MIN h (dimindex (:α) − 1) ∧ w ' (i + l))
</pre>

<DT><span class="strong">word_signed_bits_def</span>
<DD>
<pre>
|- ∀h l.
     h --- l =
     (λw.
        FCP i.
          l ≤ MIN h (dimindex (:α) − 1) ∧
          w ' (MIN (i + l) (MIN h (dimindex (:α) − 1))))
</pre>

<DT><span class="strong">word_extract_def</span>
<DD>
<pre>
|- ∀h l. h >< l = w2w o (h -- l)
</pre>

<DT><span class="strong">word_bit_def</span>
<DD>
<pre>
|- ∀b w. word_bit b w ⇔ b ≤ dimindex (:α) − 1 ∧ w ' b
</pre>

<DT><span class="strong">word_reverse_def</span>
<DD>
<pre>
|- ∀w. word_reverse w = FCP i. w ' (dimindex (:α) − 1 − i)
</pre>

<DT><span class="strong">word_modify_def</span>
<DD>
<pre>
|- ∀f w. word_modify f w = FCP i. f i (w ' i)
</pre>

<DT><span class="strong">BIT_SET_tupled_primitive_def</span>
<DD>
<pre>
|- BIT_SET_tupled =
   WFREC
     (@R.
        WF R ∧ (∀i n. n ≠ 0 ∧ ODD n ⇒ R (SUC i,n DIV 2) (i,n)) ∧
        ∀i n. n ≠ 0 ∧ ¬ODD n ⇒ R (SUC i,n DIV 2) (i,n))
     (λBIT_SET_tupled a.
        case a of
          (i,n) =>
            I
              (if n = 0 then ∅
               else if ODD n then i INSERT BIT_SET_tupled (SUC i,n DIV 2)
               else BIT_SET_tupled (SUC i,n DIV 2)))
</pre>

<DT><span class="strong">BIT_SET_curried_def</span>
<DD>
<pre>
|- ∀x x1. BIT_SET x x1 = BIT_SET_tupled (x,x1)
</pre>

<DT><span class="strong">bit_field_insert_def</span>
<DD>
<pre>
|- ∀h l a.
     bit_field_insert h l a =
     word_modify (λi. COND (l ≤ i ∧ i ≤ h) (a ' (i − l)))
</pre>

<DT><span class="strong">word_sign_extend_def</span>
<DD>
<pre>
|- ∀n w. word_sign_extend n w = n2w (SIGN_EXTEND n (dimindex (:α)) (w2n w))
</pre>

<DT><span class="strong">word_len_def</span>
<DD>
<pre>
|- ∀w. word_len w = dimindex (:α)
</pre>

<DT><span class="strong">bit_count_upto_def</span>
<DD>
<pre>
|- ∀n w. bit_count_upto n w = SUM n (λi. if w ' i then 1 else 0)
</pre>

<DT><span class="strong">bit_count_def</span>
<DD>
<pre>
|- ∀w. bit_count w = bit_count_upto (dimindex (:α)) w
</pre>

<DT><span class="strong">word_2comp_def</span>
<DD>
<pre>
|- ∀w. -w = n2w (dimword (:α) − w2n w)
</pre>

<DT><span class="strong">word_add_def</span>
<DD>
<pre>
|- ∀v w. v + w = n2w (w2n v + w2n w)
</pre>

<DT><span class="strong">word_mul_def</span>
<DD>
<pre>
|- ∀v w. v * w = n2w (w2n v * w2n w)
</pre>

<DT><span class="strong">word_log2_def</span>
<DD>
<pre>
|- ∀w. word_log2 w = n2w (LOG2 (w2n w))
</pre>

<DT><span class="strong">add_with_carry_def</span>
<DD>
<pre>
|- ∀x y carry_in.
     add_with_carry (x,y,carry_in) =
     (let unsigned_sum = w2n x + w2n y + if carry_in then 1 else 0 in
      let result = n2w unsigned_sum in
      let carry_out = w2n result ≠ unsigned_sum and
          overflow =
            (word_msb x ⇔ word_msb y) ∧ (word_msb x ⇎ word_msb result)
      in
        (result,carry_out,overflow))
</pre>

<DT><span class="strong">word_sub_def</span>
<DD>
<pre>
|- ∀v w. v − w = v + -w
</pre>

<DT><span class="strong">word_div_def</span>
<DD>
<pre>
|- ∀v w. v // w = n2w (w2n v DIV w2n w)
</pre>

<DT><span class="strong">word_sdiv_def</span>
<DD>
<pre>
|- ∀a b.
     a / b =
     if word_msb a then if word_msb b then -a // -b else -(-a // b)
     else if word_msb b then -(a // -b)
     else a // b
</pre>

<DT><span class="strong">word_mod_def</span>
<DD>
<pre>
|- ∀v w. word_mod v w = n2w (w2n v MOD w2n w)
</pre>

<DT><span class="strong">word_srem_def</span>
<DD>
<pre>
|- ∀a b.
     word_srem a b =
     if word_msb a then
       if word_msb b then -word_mod (-a) (-b) else -word_mod (-a) b
     else if word_msb b then word_mod a (-b)
     else word_mod a b
</pre>

<DT><span class="strong">word_smod_def</span>
<DD>
<pre>
|- ∀s t.
     word_smod s t =
     (let abs_s = if word_msb s then -s else s and
          abs_t = if word_msb t then -t else t
      in
      let u = word_mod abs_s abs_t
      in
        if u = 0w then u
        else if word_msb s then if word_msb t then -u else -u + t
        else if word_msb t then u + t
        else u)
</pre>

<DT><span class="strong">word_L2_def</span>
<DD>
<pre>
|- INT_MINw2 = INT_MINw * INT_MINw
</pre>

<DT><span class="strong">nzcv_def</span>
<DD>
<pre>
|- ∀a b.
     nzcv a b =
     (let q = w2n a + w2n (-b) in
      let r = n2w q
      in
        (word_msb r,r = 0w,BIT (dimindex (:α)) q ∨ (b = 0w),
         (word_msb a ⇎ word_msb b) ∧ (word_msb r ⇎ word_msb a)))
</pre>

<DT><span class="strong">word_lt_def</span>
<DD>
<pre>
|- ∀a b. a < b ⇔ (let (n,z,c,v) = nzcv a b in n ⇎ v)
</pre>

<DT><span class="strong">word_gt_def</span>
<DD>
<pre>
|- ∀a b. a > b ⇔ (let (n,z,c,v) = nzcv a b in ¬z ∧ (n ⇔ v))
</pre>

<DT><span class="strong">word_le_def</span>
<DD>
<pre>
|- ∀a b. a ≤ b ⇔ (let (n,z,c,v) = nzcv a b in z ∨ (n ⇎ v))
</pre>

<DT><span class="strong">word_ge_def</span>
<DD>
<pre>
|- ∀a b. a ≥ b ⇔ (let (n,z,c,v) = nzcv a b in n ⇔ v)
</pre>

<DT><span class="strong">word_ls_def</span>
<DD>
<pre>
|- ∀a b. a ≤₊ b ⇔ (let (n,z,c,v) = nzcv a b in ¬c ∨ z)
</pre>

<DT><span class="strong">word_hi_def</span>
<DD>
<pre>
|- ∀a b. a >₊ b ⇔ (let (n,z,c,v) = nzcv a b in c ∧ ¬z)
</pre>

<DT><span class="strong">word_lo_def</span>
<DD>
<pre>
|- ∀a b. a <₊ b ⇔ (let (n,z,c,v) = nzcv a b in ¬c)
</pre>

<DT><span class="strong">word_hs_def</span>
<DD>
<pre>
|- ∀a b. a ≥₊ b ⇔ (let (n,z,c,v) = nzcv a b in c)
</pre>

<DT><span class="strong">word_min_def</span>
<DD>
<pre>
|- ∀a b. word_min a b = if a <₊ b then a else b
</pre>

<DT><span class="strong">word_max_def</span>
<DD>
<pre>
|- ∀a b. word_max a b = if a <₊ b then b else a
</pre>

<DT><span class="strong">word_smin_def</span>
<DD>
<pre>
|- ∀a b. word_smin a b = if a < b then a else b
</pre>

<DT><span class="strong">word_smax_def</span>
<DD>
<pre>
|- ∀a b. word_smax a b = if a < b then b else a
</pre>

<DT><span class="strong">word_abs_def</span>
<DD>
<pre>
|- ∀w. word_abs w = if w < 0w then -w else w
</pre>

<DT><span class="strong">word_lsl_def</span>
<DD>
<pre>
|- ∀w n. w ≪ n = FCP i. i < dimindex (:α) ∧ n ≤ i ∧ w ' (i − n)
</pre>

<DT><span class="strong">word_lsr_def</span>
<DD>
<pre>
|- ∀w n. w ⋙ n = FCP i. i + n < dimindex (:α) ∧ w ' (i + n)
</pre>

<DT><span class="strong">word_asr_def</span>
<DD>
<pre>
|- ∀w n.
     w ≫ n = FCP i. if dimindex (:α) ≤ i + n then word_msb w else w ' (i + n)
</pre>

<DT><span class="strong">word_ror_def</span>
<DD>
<pre>
|- ∀w n. w ⇄ n = FCP i. w ' ((i + n) MOD dimindex (:α))
</pre>

<DT><span class="strong">word_rol_def</span>
<DD>
<pre>
|- ∀w n. w ⇆ n = w ⇄ (dimindex (:α) − n MOD dimindex (:α))
</pre>

<DT><span class="strong">word_rrx_def</span>
<DD>
<pre>
|- ∀c w.
     word_rrx (c,w) =
     (word_lsb w,FCP i. if i = dimindex (:α) − 1 then c else (w ⋙ 1) ' i)
</pre>

<DT><span class="strong">word_lsl_bv_def</span>
<DD>
<pre>
|- ∀w n. w <<~ n = w ≪ w2n n
</pre>

<DT><span class="strong">word_lsr_bv_def</span>
<DD>
<pre>
|- ∀w n. w >>>~ n = w ⋙ w2n n
</pre>

<DT><span class="strong">word_asr_bv_def</span>
<DD>
<pre>
|- ∀w n. w >>~ n = w ≫ w2n n
</pre>

<DT><span class="strong">word_ror_bv_def</span>
<DD>
<pre>
|- ∀w n. w #>>~ n = w ⇄ w2n n
</pre>

<DT><span class="strong">word_rol_bv_def</span>
<DD>
<pre>
|- ∀w n. w #<<~ n = w ⇆ w2n n
</pre>

<DT><span class="strong">word_join_def</span>
<DD>
<pre>
|- ∀v w.
     word_join v w =
     (let cv = w2w v and cw = w2w w in cv ≪ dimindex (:β) ‖ cw)
</pre>

<DT><span class="strong">word_concat_def</span>
<DD>
<pre>
|- ∀v w. v @@ w = w2w (word_join v w)
</pre>

<DT><span class="strong">word_replicate_def</span>
<DD>
<pre>
|- ∀n w.
     word_replicate n w =
     FCP i. i < n * dimindex (:α) ∧ w ' (i MOD dimindex (:α))
</pre>

<DT><span class="strong">concat_word_list_def</span>
<DD>
<pre>
|- (concat_word_list [] = 0w) ∧
   ∀h t. concat_word_list (h::t) = w2w h ‖ concat_word_list t ≪ dimindex (:α)
</pre>

<DT><span class="strong">saturate_n2w_def</span>
<DD>
<pre>
|- ∀n. saturate_n2w n = if dimword (:α) ≤ n then UINT_MAXw else n2w n
</pre>

<DT><span class="strong">saturate_w2w_def</span>
<DD>
<pre>
|- ∀w. saturate_w2w w = saturate_n2w (w2n w)
</pre>

<DT><span class="strong">saturate_add_def</span>
<DD>
<pre>
|- ∀a b. saturate_add a b = saturate_n2w (w2n a + w2n b)
</pre>

<DT><span class="strong">saturate_sub_def</span>
<DD>
<pre>
|- ∀a b. saturate_sub a b = n2w (w2n a − w2n b)
</pre>

<DT><span class="strong">saturate_mul_def</span>
<DD>
<pre>
|- ∀a b. saturate_mul a b = saturate_n2w (w2n a * w2n b)
</pre>

<DT><span class="strong">n2w_itself_primitive_def</span>
<DD>
<pre>
|- n2w_itself =
   WFREC (@R. WF R) (λn2w_itself a. case a of (n,v1) => I (n2w n))
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">BIT_SET_ind</span>
<DD>
<pre>
|- ∀P.
     (∀i n.
        (n ≠ 0 ∧ ODD n ⇒ P (SUC i) (n DIV 2)) ∧
        (n ≠ 0 ∧ ¬ODD n ⇒ P (SUC i) (n DIV 2)) ⇒
        P i n) ⇒
     ∀v v1. P v v1
</pre>

<DT><span class="strong">BIT_SET_def</span>
<DD>
<pre>
|- ∀n i.
     BIT_SET i n =
     if n = 0 then ∅
     else if ODD n then i INSERT BIT_SET (SUC i) (n DIV 2)
     else BIT_SET (SUC i) (n DIV 2)
</pre>

<DT><span class="strong">ZERO_LT_dimword</span>
<DD>
<pre>
|- 0 < dimword (:α)
</pre>

<DT><span class="strong">dimword_IS_TWICE_INT_MIN</span>
<DD>
<pre>
|- dimword (:α) = 2 * INT_MIN (:α)
</pre>

<DT><span class="strong">dimword_sub_int_min</span>
<DD>
<pre>
|- dimword (:α) − INT_MIN (:α) = INT_MIN (:α)
</pre>

<DT><span class="strong">DIMINDEX_GT_0</span>
<DD>
<pre>
|- 0 < dimindex (:α)
</pre>

<DT><span class="strong">ONE_LT_dimword</span>
<DD>
<pre>
|- 1 < dimword (:α)
</pre>

<DT><span class="strong">EXISTS_HB</span>
<DD>
<pre>
|- ∃m. dimindex (:α) = SUC m
</pre>

<DT><span class="strong">MOD_DIMINDEX</span>
<DD>
<pre>
|- ∀n. n MOD dimword (:α) = BITS (dimindex (:α) − 1) 0 n
</pre>

<DT><span class="strong">BITS_ZEROL_DIMINDEX</span>
<DD>
<pre>
|- ∀n. n < dimword (:α) ⇒ (BITS (dimindex (:α) − 1) 0 n = n)
</pre>

<DT><span class="strong">MOD_2EXP_DIMINDEX</span>
<DD>
<pre>
|- ∀n. n MOD dimword (:α) = MOD_2EXP (dimindex (:α)) n
</pre>

<DT><span class="strong">INT_MIN_SUM</span>
<DD>
<pre>
|- INT_MIN (:α + β) =
   if FINITE 𝕌(:α) ∧ FINITE 𝕌(:β) then dimword (:α) * INT_MIN (:β)
   else INT_MIN (:α + β)
</pre>

<DT><span class="strong">ZERO_LT_INT_MIN</span>
<DD>
<pre>
|- 0 < INT_MIN (:α)
</pre>

<DT><span class="strong">ZERO_LT_INT_MAX</span>
<DD>
<pre>
|- 1 < dimindex (:α) ⇒ 0 < INT_MAX (:α)
</pre>

<DT><span class="strong">ZERO_LE_INT_MAX</span>
<DD>
<pre>
|- 0 ≤ INT_MAX (:α)
</pre>

<DT><span class="strong">ZERO_LT_UINT_MAX</span>
<DD>
<pre>
|- 0 < UINT_MAX (:α)
</pre>

<DT><span class="strong">INT_MIN_LT_DIMWORD</span>
<DD>
<pre>
|- INT_MIN (:α) < dimword (:α)
</pre>

<DT><span class="strong">INT_MAX_LT_DIMWORD</span>
<DD>
<pre>
|- INT_MAX (:α) < dimword (:α)
</pre>

<DT><span class="strong">dimindex_lt_dimword</span>
<DD>
<pre>
|- dimindex (:α) < dimword (:α)
</pre>

<DT><span class="strong">BOUND_ORDER</span>
<DD>
<pre>
|- INT_MAX (:α) < INT_MIN (:α) ∧ INT_MIN (:α) ≤ UINT_MAX (:α) ∧
   UINT_MAX (:α) < dimword (:α)
</pre>

<DT><span class="strong">dimindex_dimword_iso</span>
<DD>
<pre>
|- (dimindex (:α) = dimindex (:β)) ⇔ (dimword (:α) = dimword (:β))
</pre>

<DT><span class="strong">dimindex_dimword_le_iso</span>
<DD>
<pre>
|- dimindex (:α) ≤ dimindex (:β) ⇔ dimword (:α) ≤ dimword (:β)
</pre>

<DT><span class="strong">dimindex_dimword_lt_iso</span>
<DD>
<pre>
|- dimindex (:α) < dimindex (:β) ⇔ dimword (:α) < dimword (:β)
</pre>

<DT><span class="strong">dimindex_int_min_iso</span>
<DD>
<pre>
|- (dimindex (:α) = dimindex (:β)) ⇔ (INT_MIN (:α) = INT_MIN (:β))
</pre>

<DT><span class="strong">dimindex_int_min_le_iso</span>
<DD>
<pre>
|- dimindex (:α) ≤ dimindex (:β) ⇔ INT_MIN (:α) ≤ INT_MIN (:β)
</pre>

<DT><span class="strong">dimindex_int_min_lt_iso</span>
<DD>
<pre>
|- dimindex (:α) < dimindex (:β) ⇔ INT_MIN (:α) < INT_MIN (:β)
</pre>

<DT><span class="strong">dimindex_int_max_iso</span>
<DD>
<pre>
|- (dimindex (:α) = dimindex (:β)) ⇔ (INT_MAX (:α) = INT_MAX (:β))
</pre>

<DT><span class="strong">dimindex_int_max_le_iso</span>
<DD>
<pre>
|- dimindex (:α) ≤ dimindex (:β) ⇔ INT_MAX (:α) ≤ INT_MAX (:β)
</pre>

<DT><span class="strong">dimindex_int_max_lt_iso</span>
<DD>
<pre>
|- dimindex (:α) < dimindex (:β) ⇔ INT_MAX (:α) < INT_MAX (:β)
</pre>

<DT><span class="strong">dimindex_uint_max_iso</span>
<DD>
<pre>
|- (dimindex (:α) = dimindex (:β)) ⇔ (UINT_MAX (:α) = UINT_MAX (:β))
</pre>

<DT><span class="strong">dimindex_uint_max_le_iso</span>
<DD>
<pre>
|- dimindex (:α) ≤ dimindex (:β) ⇔ UINT_MAX (:α) ≤ UINT_MAX (:β)
</pre>

<DT><span class="strong">dimindex_uint_max_lt_iso</span>
<DD>
<pre>
|- dimindex (:α) < dimindex (:β) ⇔ UINT_MAX (:α) < UINT_MAX (:β)
</pre>

<DT><span class="strong">w2n_n2w</span>
<DD>
<pre>
|- ∀n. w2n (n2w n) = n MOD dimword (:α)
</pre>

<DT><span class="strong">n2w_w2n</span>
<DD>
<pre>
|- ∀w. n2w (w2n w) = w
</pre>

<DT><span class="strong">word_nchotomy</span>
<DD>
<pre>
|- ∀w. ∃n. w = n2w n
</pre>

<DT><span class="strong">n2w_mod</span>
<DD>
<pre>
|- ∀n. n2w (n MOD dimword (:α)) = n2w n
</pre>

<DT><span class="strong">n2w_11</span>
<DD>
<pre>
|- ∀m n. (n2w m = n2w n) ⇔ (m MOD dimword (:α) = n MOD dimword (:α))
</pre>

<DT><span class="strong">ranged_word_nchotomy</span>
<DD>
<pre>
|- ∀w. ∃n. (w = n2w n) ∧ n < dimword (:α)
</pre>

<DT><span class="strong">dimindex_1_cases</span>
<DD>
<pre>
|- ∀a. (dimindex (:α) = 1) ⇒ (a = 0w) ∨ (a = 1w)
</pre>

<DT><span class="strong">mod_dimindex</span>
<DD>
<pre>
|- ∀n. n MOD dimindex (:α) < dimword (:α)
</pre>

<DT><span class="strong">WORD_INDUCT</span>
<DD>
<pre>
|- ∀P.
     P 0w ∧ (∀n. SUC n < dimword (:α) ⇒ P (n2w n) ⇒ P (n2w (SUC n))) ⇒ ∀x. P x
</pre>

<DT><span class="strong">w2n_11</span>
<DD>
<pre>
|- ∀v w. (w2n v = w2n w) ⇔ (v = w)
</pre>

<DT><span class="strong">w2n_lt</span>
<DD>
<pre>
|- ∀w. w2n w < dimword (:α)
</pre>

<DT><span class="strong">word_0_n2w</span>
<DD>
<pre>
|- w2n 0w = 0
</pre>

<DT><span class="strong">word_1_n2w</span>
<DD>
<pre>
|- w2n 1w = 1
</pre>

<DT><span class="strong">w2n_eq_0</span>
<DD>
<pre>
|- ∀w. (w2n w = 0) ⇔ (w = 0w)
</pre>

<DT><span class="strong">n2w_dimword</span>
<DD>
<pre>
|- n2w (dimword (:α)) = 0w
</pre>

<DT><span class="strong">word_2comp_dimindex_1</span>
<DD>
<pre>
|- ∀w. (dimindex (:α) = 1) ⇒ (-w = w)
</pre>

<DT><span class="strong">word_add_n2w</span>
<DD>
<pre>
|- ∀m n. n2w m + n2w n = n2w (m + n)
</pre>

<DT><span class="strong">word_mul_n2w</span>
<DD>
<pre>
|- ∀m n. n2w m * n2w n = n2w (m * n)
</pre>

<DT><span class="strong">word_log2_n2w</span>
<DD>
<pre>
|- ∀n. word_log2 (n2w n) = n2w (LOG2 (n MOD dimword (:α)))
</pre>

<DT><span class="strong">word_1comp_n2w</span>
<DD>
<pre>
|- ∀n. ¬n2w n = n2w (dimword (:α) − 1 − n MOD dimword (:α))
</pre>

<DT><span class="strong">word_2comp_n2w</span>
<DD>
<pre>
|- ∀n. -n2w n = n2w (dimword (:α) − n MOD dimword (:α))
</pre>

<DT><span class="strong">word_lsb</span>
<DD>
<pre>
|- word_lsb = word_bit 0
</pre>

<DT><span class="strong">word_msb</span>
<DD>
<pre>
|- word_msb = word_bit (dimindex (:α) − 1)
</pre>

<DT><span class="strong">word_lsb_n2w</span>
<DD>
<pre>
|- ∀n. word_lsb (n2w n) ⇔ ODD n
</pre>

<DT><span class="strong">word_msb_n2w</span>
<DD>
<pre>
|- ∀n. word_msb (n2w n) ⇔ BIT (dimindex (:α) − 1) n
</pre>

<DT><span class="strong">word_msb_n2w_numeric</span>
<DD>
<pre>
|- word_msb (n2w n) ⇔ INT_MIN (:α) ≤ n MOD dimword (:α)
</pre>

<DT><span class="strong">word_and_n2w</span>
<DD>
<pre>
|- ∀n m. n2w n && n2w m = n2w (BITWISE (dimindex (:α)) $/\ n m)
</pre>

<DT><span class="strong">word_or_n2w</span>
<DD>
<pre>
|- ∀n m. n2w n ‖ n2w m = n2w (BITWISE (dimindex (:α)) $\/ n m)
</pre>

<DT><span class="strong">word_xor_n2w</span>
<DD>
<pre>
|- ∀n m. n2w n ⊕ n2w m = n2w (BITWISE (dimindex (:α)) (λx y. x ⇎ y) n m)
</pre>

<DT><span class="strong">word_nand_n2w</span>
<DD>
<pre>
|- ∀n m. n2w n ~&& n2w m = n2w (BITWISE (dimindex (:α)) (λx y. ¬(x ∧ y)) n m)
</pre>

<DT><span class="strong">word_nor_n2w</span>
<DD>
<pre>
|- ∀n m. n2w n ~|| n2w m = n2w (BITWISE (dimindex (:α)) (λx y. ¬(x ∨ y)) n m)
</pre>

<DT><span class="strong">word_xnor_n2w</span>
<DD>
<pre>
|- ∀n m. n2w n ~?? n2w m = n2w (BITWISE (dimindex (:α)) $<=> n m)
</pre>

<DT><span class="strong">l2w_w2l</span>
<DD>
<pre>
|- ∀b w. 1 < b ⇒ (l2w b (w2l b w) = w)
</pre>

<DT><span class="strong">w2l_l2w</span>
<DD>
<pre>
|- ∀b l. w2l b (l2w b l) = n2l b (l2n b l MOD dimword (:α))
</pre>

<DT><span class="strong">s2w_w2s</span>
<DD>
<pre>
|- ∀c2n n2c b w.
     1 < b ∧ (∀x. x < b ⇒ (c2n (n2c x) = x)) ⇒ (s2w b c2n (w2s b n2c w) = w)
</pre>

<DT><span class="strong">w2s_s2w</span>
<DD>
<pre>
|- ∀b c2n n2c s.
     w2s b n2c (s2w b c2n s) = n2s b n2c (s2n b c2n s MOD dimword (:α))
</pre>

<DT><span class="strong">NUMERAL_LESS_THM</span>
<DD>
<pre>
|- (∀m n.
      m < NUMERAL (BIT1 n) ⇔
      (m = NUMERAL (BIT1 n) − 1) ∨ m < NUMERAL (BIT1 n) − 1) ∧
   ∀m n. m < NUMERAL (BIT2 n) ⇔ (m = NUMERAL (BIT1 n)) ∨ m < NUMERAL (BIT1 n)
</pre>

<DT><span class="strong">word_bin_list</span>
<DD>
<pre>
|- word_from_bin_list o word_to_bin_list = I
</pre>

<DT><span class="strong">word_oct_list</span>
<DD>
<pre>
|- word_from_oct_list o word_to_oct_list = I
</pre>

<DT><span class="strong">word_dec_list</span>
<DD>
<pre>
|- word_from_dec_list o word_to_dec_list = I
</pre>

<DT><span class="strong">word_hex_list</span>
<DD>
<pre>
|- word_from_hex_list o word_to_hex_list = I
</pre>

<DT><span class="strong">word_bin_string</span>
<DD>
<pre>
|- word_from_bin_string o word_to_bin_string = I
</pre>

<DT><span class="strong">word_oct_string</span>
<DD>
<pre>
|- word_from_oct_string o word_to_oct_string = I
</pre>

<DT><span class="strong">word_dec_string</span>
<DD>
<pre>
|- word_from_dec_string o word_to_dec_string = I
</pre>

<DT><span class="strong">word_hex_string</span>
<DD>
<pre>
|- word_from_hex_string o word_to_hex_string = I
</pre>

<DT><span class="strong">word_0</span>
<DD>
<pre>
|- ∀i. i < dimindex (:α) ⇒ ¬0w ' i
</pre>

<DT><span class="strong">word_eq_0</span>
<DD>
<pre>
|- ∀w. (w = 0w) ⇔ ∀i. i < dimindex (:α) ⇒ ¬w ' i
</pre>

<DT><span class="strong">word_T</span>
<DD>
<pre>
|- ∀i. i < dimindex (:α) ⇒ UINT_MAXw ' i
</pre>

<DT><span class="strong">FCP_T_F</span>
<DD>
<pre>
|- ($FCP (K T) = UINT_MAXw) ∧ ($FCP (K F) = 0w)
</pre>

<DT><span class="strong">word_L</span>
<DD>
<pre>
|- ∀n. n < dimindex (:α) ⇒ (INT_MINw ' n ⇔ (n = dimindex (:α) − 1))
</pre>

<DT><span class="strong">word_H</span>
<DD>
<pre>
|- ∀n. n < dimindex (:α) ⇒ (INT_MAXw ' n ⇔ n < dimindex (:α) − 1)
</pre>

<DT><span class="strong">word_L2</span>
<DD>
<pre>
|- INT_MINw2 = if 1 < dimindex (:α) then 0w else INT_MINw
</pre>

<DT><span class="strong">WORD_NEG_1</span>
<DD>
<pre>
|- -1w = UINT_MAXw
</pre>

<DT><span class="strong">WORD_NEG_1_T</span>
<DD>
<pre>
|- ∀i. i < dimindex (:α) ⇒ (-1w) ' i
</pre>

<DT><span class="strong">WORD_MSB_1COMP</span>
<DD>
<pre>
|- ∀w. word_msb (¬w) ⇔ ¬word_msb w
</pre>

<DT><span class="strong">w2n_minus1</span>
<DD>
<pre>
|- w2n (-1w) = dimword (:α) − 1
</pre>

<DT><span class="strong">WORD_NOT_NOT</span>
<DD>
<pre>
|- ∀a. ¬ ¬a = a
</pre>

<DT><span class="strong">WORD_DE_MORGAN_THM</span>
<DD>
<pre>
|- ∀a b. (¬(a && b) = ¬a ‖ ¬b) ∧ (¬(a ‖ b) = ¬a && ¬b)
</pre>

<DT><span class="strong">WORD_NOT_XOR</span>
<DD>
<pre>
|- ∀a b. (¬a ⊕ ¬b = a ⊕ b) ∧ (a ⊕ ¬b = ¬(a ⊕ b)) ∧ (¬a ⊕ b = ¬(a ⊕ b))
</pre>

<DT><span class="strong">WORD_AND_CLAUSES</span>
<DD>
<pre>
|- ∀a.
     (UINT_MAXw && a = a) ∧ (a && UINT_MAXw = a) ∧ (0w && a = 0w) ∧
     (a && 0w = 0w) ∧ (a && a = a)
</pre>

<DT><span class="strong">WORD_OR_CLAUSES</span>
<DD>
<pre>
|- ∀a.
     (UINT_MAXw ‖ a = UINT_MAXw) ∧ (a ‖ UINT_MAXw = UINT_MAXw) ∧
     (0w ‖ a = a) ∧ (a ‖ 0w = a) ∧ (a ‖ a = a)
</pre>

<DT><span class="strong">WORD_XOR_CLAUSES</span>
<DD>
<pre>
|- ∀a.
     (UINT_MAXw ⊕ a = ¬a) ∧ (a ⊕ UINT_MAXw = ¬a) ∧ (0w ⊕ a = a) ∧
     (a ⊕ 0w = a) ∧ (a ⊕ a = 0w)
</pre>

<DT><span class="strong">WORD_AND_ASSOC</span>
<DD>
<pre>
|- ∀a b c. (a && b) && c = a && b && c
</pre>

<DT><span class="strong">WORD_OR_ASSOC</span>
<DD>
<pre>
|- ∀a b c. (a ‖ b) ‖ c = a ‖ b ‖ c
</pre>

<DT><span class="strong">WORD_XOR_ASSOC</span>
<DD>
<pre>
|- ∀a b c. (a ⊕ b) ⊕ c = a ⊕ b ⊕ c
</pre>

<DT><span class="strong">WORD_AND_COMM</span>
<DD>
<pre>
|- ∀a b. a && b = b && a
</pre>

<DT><span class="strong">WORD_OR_COMM</span>
<DD>
<pre>
|- ∀a b. a ‖ b = b ‖ a
</pre>

<DT><span class="strong">WORD_XOR_COMM</span>
<DD>
<pre>
|- ∀a b. a ⊕ b = b ⊕ a
</pre>

<DT><span class="strong">WORD_AND_IDEM</span>
<DD>
<pre>
|- ∀a. a && a = a
</pre>

<DT><span class="strong">WORD_OR_IDEM</span>
<DD>
<pre>
|- ∀a. a ‖ a = a
</pre>

<DT><span class="strong">WORD_AND_ABSORD</span>
<DD>
<pre>
|- ∀a b. a ‖ a && b = a
</pre>

<DT><span class="strong">WORD_OR_ABSORB</span>
<DD>
<pre>
|- ∀a b. a && (a ‖ b) = a
</pre>

<DT><span class="strong">WORD_AND_COMP</span>
<DD>
<pre>
|- ∀a. a && ¬a = 0w
</pre>

<DT><span class="strong">WORD_OR_COMP</span>
<DD>
<pre>
|- ∀a. a ‖ ¬a = UINT_MAXw
</pre>

<DT><span class="strong">WORD_XOR_COMP</span>
<DD>
<pre>
|- ∀a. a ⊕ ¬a = UINT_MAXw
</pre>

<DT><span class="strong">WORD_RIGHT_AND_OVER_OR</span>
<DD>
<pre>
|- ∀a b c. (a ‖ b) && c = a && c ‖ b && c
</pre>

<DT><span class="strong">WORD_RIGHT_OR_OVER_AND</span>
<DD>
<pre>
|- ∀a b c. a && b ‖ c = (a ‖ c) && (b ‖ c)
</pre>

<DT><span class="strong">WORD_RIGHT_AND_OVER_XOR</span>
<DD>
<pre>
|- ∀a b c. (a ⊕ b) && c = a && c ⊕ b && c
</pre>

<DT><span class="strong">WORD_LEFT_AND_OVER_OR</span>
<DD>
<pre>
|- ∀a b c. a && (b ‖ c) = a && b ‖ a && c
</pre>

<DT><span class="strong">WORD_LEFT_OR_OVER_AND</span>
<DD>
<pre>
|- ∀a b c. a ‖ b && c = (a ‖ b) && (a ‖ c)
</pre>

<DT><span class="strong">WORD_LEFT_AND_OVER_XOR</span>
<DD>
<pre>
|- ∀a b c. a && (b ⊕ c) = a && b ⊕ a && c
</pre>

<DT><span class="strong">WORD_XOR</span>
<DD>
<pre>
|- ∀a b. a ⊕ b = a && ¬b ‖ b && ¬a
</pre>

<DT><span class="strong">WORD_NAND_NOT_AND</span>
<DD>
<pre>
|- ∀a b. a ~&& b = ¬(a && b)
</pre>

<DT><span class="strong">WORD_NOR_NOT_OR</span>
<DD>
<pre>
|- ∀a b. a ~|| b = ¬(a ‖ b)
</pre>

<DT><span class="strong">WORD_XNOR_NOT_XOR</span>
<DD>
<pre>
|- ∀a b. a ~?? b = ¬(a ⊕ b)
</pre>

<DT><span class="strong">WORD_ADD_OR</span>
<DD>
<pre>
|- ∀a b. (a && b = 0w) ⇒ (a + b = a ‖ b)
</pre>

<DT><span class="strong">WORD_ADD_XOR</span>
<DD>
<pre>
|- ∀a b. (a && b = 0w) ⇒ (a + b = a ⊕ b)
</pre>

<DT><span class="strong">WORD_AND_EXP_SUB1</span>
<DD>
<pre>
|- ∀m n. n2w n && n2w (2 ** m − 1) = n2w (n MOD 2 ** m)
</pre>

<DT><span class="strong">w2w</span>
<DD>
<pre>
|- ∀w i. i < dimindex (:β) ⇒ (w2w w ' i ⇔ i < dimindex (:α) ∧ w ' i)
</pre>

<DT><span class="strong">sw2sw</span>
<DD>
<pre>
|- ∀w i.
     i < dimindex (:β) ⇒
     (sw2sw w ' i ⇔
      if i < dimindex (:α) ∨ dimindex (:β) < dimindex (:α) then w ' i
      else word_msb w)
</pre>

<DT><span class="strong">w2w_id</span>
<DD>
<pre>
|- ∀w. w2w w = w
</pre>

<DT><span class="strong">sw2sw_id</span>
<DD>
<pre>
|- ∀w. sw2sw w = w
</pre>

<DT><span class="strong">w2w_w2w</span>
<DD>
<pre>
|- ∀w. w2w (w2w w) = w2w ((dimindex (:β) − 1 -- 0) w)
</pre>

<DT><span class="strong">sw2sw_sw2sw</span>
<DD>
<pre>
|- ∀w.
     sw2sw (sw2sw w) =
     if dimindex (:β) < dimindex (:α) ∧ dimindex (:β) < dimindex (:γ) then
       sw2sw (w2w w)
     else sw2sw w
</pre>

<DT><span class="strong">sw2sw_w2w</span>
<DD>
<pre>
|- ∀w. sw2sw w = (if word_msb w then -1w ≪ dimindex (:α) else 0w) ‖ w2w w
</pre>

<DT><span class="strong">word_bit</span>
<DD>
<pre>
|- ∀w b. b < dimindex (:α) ⇒ (w ' b ⇔ word_bit b w)
</pre>

<DT><span class="strong">word_slice_n2w</span>
<DD>
<pre>
|- ∀h l n. (h '' l) (n2w n) = n2w (SLICE (MIN h (dimindex (:α) − 1)) l n)
</pre>

<DT><span class="strong">word_bits_n2w</span>
<DD>
<pre>
|- ∀h l n. (h -- l) (n2w n) = n2w (BITS (MIN h (dimindex (:α) − 1)) l n)
</pre>

<DT><span class="strong">word_bit_n2w</span>
<DD>
<pre>
|- ∀b n. word_bit b (n2w n) ⇔ b ≤ dimindex (:α) − 1 ∧ BIT b n
</pre>

<DT><span class="strong">word_signed_bits_n2w</span>
<DD>
<pre>
|- ∀h l n.
     (h --- l) (n2w n) =
     n2w
       (SIGN_EXTEND (MIN (SUC h) (dimindex (:α)) − l) (dimindex (:α))
          (BITS (MIN h (dimindex (:α) − 1)) l n))
</pre>

<DT><span class="strong">word_sign_extend_bits</span>
<DD>
<pre>
|- ∀h l w.
     (h --- l) w =
     word_sign_extend (MIN (SUC h) (dimindex (:α)) − l) ((h -- l) w)
</pre>

<DT><span class="strong">word_index_n2w</span>
<DD>
<pre>
|- ∀n i.
     n2w n ' i ⇔
     if i < dimindex (:α) then BIT i n else FAIL $' index too large (n2w n) i
</pre>

<DT><span class="strong">word_index</span>
<DD>
<pre>
|- ∀n i. i < dimindex (:α) ⇒ (n2w n ' i ⇔ BIT i n)
</pre>

<DT><span class="strong">word_bits_w2w</span>
<DD>
<pre>
|- ∀w h l. (h -- l) (w2w w) = w2w ((MIN h (dimindex (:β) − 1) -- l) w)
</pre>

<DT><span class="strong">word_reverse_n2w</span>
<DD>
<pre>
|- ∀n. word_reverse (n2w n) = n2w (BIT_REVERSE (dimindex (:α)) n)
</pre>

<DT><span class="strong">word_modify_n2w</span>
<DD>
<pre>
|- ∀f n. word_modify f (n2w n) = n2w (BIT_MODIFY (dimindex (:α)) f n)
</pre>

<DT><span class="strong">fcp_n2w</span>
<DD>
<pre>
|- ∀f. $FCP f = word_modify (λi b. f i) 0w
</pre>

<DT><span class="strong">w2n_w2w</span>
<DD>
<pre>
|- ∀w.
     w2n (w2w w) =
     if dimindex (:α) ≤ dimindex (:β) then w2n w
     else w2n ((dimindex (:β) − 1 -- 0) w)
</pre>

<DT><span class="strong">w2n_w2w_le</span>
<DD>
<pre>
|- ∀w. w2n (w2w w) ≤ w2n w
</pre>

<DT><span class="strong">w2w_lt</span>
<DD>
<pre>
|- ∀w. w2n (w2w w) < dimword (:α)
</pre>

<DT><span class="strong">w2w_n2w</span>
<DD>
<pre>
|- ∀n.
     w2w (n2w n) =
     if dimindex (:β) ≤ dimindex (:α) then n2w n
     else n2w (BITS (dimindex (:α) − 1) 0 n)
</pre>

<DT><span class="strong">w2w_0</span>
<DD>
<pre>
|- w2w 0w = 0w
</pre>

<DT><span class="strong">w2n_11_lift</span>
<DD>
<pre>
|- ∀a b.
     dimindex (:α) ≤ dimindex (:γ) ∧ dimindex (:β) ≤ dimindex (:γ) ⇒
     ((w2n a = w2n b) ⇔ (w2w a = w2w b))
</pre>

<DT><span class="strong">word_extract_n2w</span>
<DD>
<pre>
|- (h >< l) (n2w n) =
   if dimindex (:β) ≤ dimindex (:α) then
     n2w (BITS (MIN h (dimindex (:α) − 1)) l n)
   else
     n2w (BITS (MIN (MIN h (dimindex (:α) − 1)) (dimindex (:α) − 1 + l)) l n)
</pre>

<DT><span class="strong">n2w_BITS</span>
<DD>
<pre>
|- ∀h l n. h < dimindex (:α) ⇒ (n2w (BITS h l n) = (h -- l) (n2w n))
</pre>

<DT><span class="strong">word_extract_w2w</span>
<DD>
<pre>
|- ∀w h l. dimindex (:α) ≤ dimindex (:β) ⇒ ((h >< l) (w2w w) = (h >< l) w)
</pre>

<DT><span class="strong">WORD_w2w_EXTRACT</span>
<DD>
<pre>
|- ∀w. w2w w = (dimindex (:α) − 1 >< 0) w
</pre>

<DT><span class="strong">WORD_EQ</span>
<DD>
<pre>
|- ∀v w. (∀x. x < dimindex (:α) ⇒ (word_bit x v ⇔ word_bit x w)) ⇔ (v = w)
</pre>

<DT><span class="strong">BIT_UPDATE</span>
<DD>
<pre>
|- ∀n x. n :+ x = word_modify (λi b. if i = n then x else b)
</pre>

<DT><span class="strong">WORD_MODIFY_BIT</span>
<DD>
<pre>
|- ∀f w i. i < dimindex (:α) ⇒ (word_modify f w ' i ⇔ f i (w ' i))
</pre>

<DT><span class="strong">WORD_BIT_BITS</span>
<DD>
<pre>
|- ∀b w. word_bit b w ⇔ ((b -- b) w = 1w)
</pre>

<DT><span class="strong">WORD_BITS_COMP_THM</span>
<DD>
<pre>
|- ∀h1 l1 h2 l2 w. (h2 -- l2) ((h1 -- l1) w) = (MIN h1 (h2 + l1) -- l2 + l1) w
</pre>

<DT><span class="strong">WORD_BITS_EXTRACT</span>
<DD>
<pre>
|- ∀h l w. (h -- l) w = (h >< l) w
</pre>

<DT><span class="strong">WORD_BITS_LSR</span>
<DD>
<pre>
|- ∀h l w n. (h -- l) w ⋙ n = (h -- l + n) w
</pre>

<DT><span class="strong">WORD_BITS_ZERO</span>
<DD>
<pre>
|- ∀h l w. h < l ⇒ ((h -- l) w = 0w)
</pre>

<DT><span class="strong">WORD_BITS_ZERO2</span>
<DD>
<pre>
|- ∀h l. (h -- l) 0w = 0w
</pre>

<DT><span class="strong">WORD_BITS_ZERO3</span>
<DD>
<pre>
|- ∀h l w. dimindex (:α) ≤ l ⇒ ((h -- l) w = 0w)
</pre>

<DT><span class="strong">WORD_BITS_LT</span>
<DD>
<pre>
|- ∀h l w. w2n ((h -- l) w) < 2 ** (SUC h − l)
</pre>

<DT><span class="strong">WORD_EXTRACT_LT</span>
<DD>
<pre>
|- ∀h l w. w2n ((h >< l) w) < 2 ** (SUC h − l)
</pre>

<DT><span class="strong">WORD_EXTRACT_ZERO</span>
<DD>
<pre>
|- ∀h l w. h < l ⇒ ((h >< l) w = 0w)
</pre>

<DT><span class="strong">WORD_EXTRACT_ZERO2</span>
<DD>
<pre>
|- ∀h l. (h >< l) 0w = 0w
</pre>

<DT><span class="strong">WORD_EXTRACT_ZERO3</span>
<DD>
<pre>
|- ∀h l w. dimindex (:α) ≤ l ⇒ ((h >< l) w = 0w)
</pre>

<DT><span class="strong">WORD_SLICE_THM</span>
<DD>
<pre>
|- ∀h l w. (h '' l) w = (h -- l) w ≪ l
</pre>

<DT><span class="strong">WORD_SLICE_ZERO</span>
<DD>
<pre>
|- ∀h l w. h < l ⇒ ((h '' l) w = 0w)
</pre>

<DT><span class="strong">WORD_SLICE_ZERO2</span>
<DD>
<pre>
|- ∀l h. (h '' l) 0w = 0w
</pre>

<DT><span class="strong">WORD_SLICE_BITS_THM</span>
<DD>
<pre>
|- ∀h w. (h '' 0) w = (h -- 0) w
</pre>

<DT><span class="strong">WORD_BITS_SLICE_THM</span>
<DD>
<pre>
|- ∀h l w. (h -- l) ((h '' l) w) = (h -- l) w
</pre>

<DT><span class="strong">WORD_SLICE_COMP_THM</span>
<DD>
<pre>
|- ∀h m' m l w.
     l ≤ m ∧ (m' = m + 1) ∧ m < h ⇒ ((h '' m') w ‖ (m '' l) w = (h '' l) w)
</pre>

<DT><span class="strong">WORD_EXTRACT_COMP_THM</span>
<DD>
<pre>
|- ∀w h l m n.
     (h >< l) ((m >< n) w) =
     (MIN m (MIN (h + n) (MIN (dimindex (:γ) − 1) (dimindex (:β) + n − 1))) ><
      l + n) w
</pre>

<DT><span class="strong">WORD_EXTRACT_BITS_COMP</span>
<DD>
<pre>
|- ∀n l k j h. (j >< k) ((h -- l) n) = (MIN h (j + l) >< k + l) n
</pre>

<DT><span class="strong">WORD_ALL_BITS</span>
<DD>
<pre>
|- ∀w h. dimindex (:α) − 1 ≤ h ⇒ ((h -- 0) w = w)
</pre>

<DT><span class="strong">EXTRACT_ALL_BITS</span>
<DD>
<pre>
|- ∀h w. dimindex (:α) − 1 ≤ h ⇒ ((h >< 0) w = w2w w)
</pre>

<DT><span class="strong">WORD_BITS_MIN_HIGH</span>
<DD>
<pre>
|- ∀w h l. dimindex (:α) − 1 < h ⇒ ((h -- l) w = (dimindex (:α) − 1 -- l) w)
</pre>

<DT><span class="strong">WORD_EXTRACT_MIN_HIGH</span>
<DD>
<pre>
|- (∀h l w.
      dimindex (:α) ≤ dimindex (:β) + l ∧ dimindex (:α) ≤ h ⇒
      ((h >< l) w = (dimindex (:α) − 1 >< l) w)) ∧
   ∀h l w.
     dimindex (:β) + l < dimindex (:α) ∧ dimindex (:β) + l ≤ h ⇒
     ((h >< l) w = (dimindex (:β) + l − 1 >< l) w)
</pre>

<DT><span class="strong">CONCAT_EXTRACT</span>
<DD>
<pre>
|- ∀h m l w.
     (h − m = dimindex (:β)) ∧ (m + 1 − l = dimindex (:γ)) ∧
     (h + 1 − l = dimindex (:δ)) ∧ dimindex (:β + γ) ≠ 1 ⇒
     ((h >< m + 1) w @@ (m >< l) w = (h >< l) w)
</pre>

<DT><span class="strong">EXTRACT_CONCAT</span>
<DD>
<pre>
|- ∀v w.
     FINITE 𝕌(:α) ∧ FINITE 𝕌(:β) ∧
     dimindex (:α) + dimindex (:β) ≤ dimindex (:γ) ⇒
     ((dimindex (:β) − 1 >< 0) (v @@ w) = w) ∧
     ((dimindex (:α) + dimindex (:β) − 1 >< dimindex (:β)) (v @@ w) = v)
</pre>

<DT><span class="strong">EXTRACT_JOIN</span>
<DD>
<pre>
|- ∀h m m' l s w.
     l ≤ m ∧ m' ≤ h ∧ (m' = m + 1) ∧ (s = m' − l) ⇒
     ((h >< m') w ≪ s ‖ (m >< l) w =
      (MIN h (MIN (dimindex (:β) + l − 1) (dimindex (:α) − 1)) >< l) w)
</pre>

<DT><span class="strong">EXTRACT_JOIN_ADD</span>
<DD>
<pre>
|- ∀h m m' l s w.
     l ≤ m ∧ m' ≤ h ∧ (m' = m + 1) ∧ (s = m' − l) ⇒
     ((h >< m') w ≪ s + (m >< l) w =
      (MIN h (MIN (dimindex (:β) + l − 1) (dimindex (:α) − 1)) >< l) w)
</pre>

<DT><span class="strong">EXTEND_EXTRACT</span>
<DD>
<pre>
|- ∀h l w. (dimindex (:γ) = h + 1 − l) ⇒ ((h >< l) w = w2w ((h >< l) w))
</pre>

<DT><span class="strong">WORD_SLICE_OVER_BITWISE</span>
<DD>
<pre>
|- (∀h l v w. (h '' l) v && (h '' l) w = (h '' l) (v && w)) ∧
   (∀h l v w. (h '' l) v ‖ (h '' l) w = (h '' l) (v ‖ w)) ∧
   ∀h l v w. (h '' l) v ⊕ (h '' l) w = (h '' l) (v ⊕ w)
</pre>

<DT><span class="strong">WORD_BITS_OVER_BITWISE</span>
<DD>
<pre>
|- (∀h l v w. (h -- l) v && (h -- l) w = (h -- l) (v && w)) ∧
   (∀h l v w. (h -- l) v ‖ (h -- l) w = (h -- l) (v ‖ w)) ∧
   ∀h l v w. (h -- l) v ⊕ (h -- l) w = (h -- l) (v ⊕ w)
</pre>

<DT><span class="strong">WORD_w2w_OVER_BITWISE</span>
<DD>
<pre>
|- (∀v w. w2w v && w2w w = w2w (v && w)) ∧
   (∀v w. w2w v ‖ w2w w = w2w (v ‖ w)) ∧ ∀v w. w2w v ⊕ w2w w = w2w (v ⊕ w)
</pre>

<DT><span class="strong">WORD_EXTRACT_OVER_BITWISE</span>
<DD>
<pre>
|- (∀h l v w. (h >< l) v && (h >< l) w = (h >< l) (v && w)) ∧
   (∀h l v w. (h >< l) v ‖ (h >< l) w = (h >< l) (v ‖ w)) ∧
   ∀h l v w. (h >< l) v ⊕ (h >< l) w = (h >< l) (v ⊕ w)
</pre>

<DT><span class="strong">WORD_w2w_OVER_ADD</span>
<DD>
<pre>
|- ∀a b. w2w (a + b) = (dimindex (:α) − 1 -- 0) (w2w a + w2w b)
</pre>

<DT><span class="strong">WORD_w2w_OVER_MUL</span>
<DD>
<pre>
|- ∀a b. w2w (a * b) = (dimindex (:α) − 1 -- 0) (w2w a * w2w b)
</pre>

<DT><span class="strong">WORD_EXTRACT_OVER_ADD</span>
<DD>
<pre>
|- ∀a b h.
     dimindex (:β) − 1 ≤ h ∧ dimindex (:β) ≤ dimindex (:α) ⇒
     ((h >< 0) (a + b) = (h >< 0) a + (h >< 0) b)
</pre>

<DT><span class="strong">WORD_EXTRACT_OVER_MUL</span>
<DD>
<pre>
|- ∀a b h.
     dimindex (:β) − 1 ≤ h ∧ dimindex (:β) ≤ dimindex (:α) ⇒
     ((h >< 0) (a * b) = (h >< 0) a * (h >< 0) b)
</pre>

<DT><span class="strong">WORD_EXTRACT_OVER_ADD2</span>
<DD>
<pre>
|- ∀a b h.
     h < dimindex (:α) ⇒
     ((h >< 0) ((h >< 0) a + (h >< 0) b) = (h >< 0) (a + b))
</pre>

<DT><span class="strong">WORD_EXTRACT_OVER_MUL2</span>
<DD>
<pre>
|- ∀a b h.
     h < dimindex (:α) ⇒
     ((h >< 0) ((h >< 0) a * (h >< 0) b) = (h >< 0) (a * b))
</pre>

<DT><span class="strong">WORD_EXTRACT_ID</span>
<DD>
<pre>
|- ∀w h. w2n w < 2 ** SUC h ⇒ ((h >< 0) w = w)
</pre>

<DT><span class="strong">BIT_SET</span>
<DD>
<pre>
|- ∀i n. BIT i n ⇔ i ∈ BIT_SET 0 n
</pre>

<DT><span class="strong">WORD_LITERAL_AND</span>
<DD>
<pre>
|- (∀n m.
      n2w n && n2w m = n2w (BITWISE (SUC (MIN (LOG2 n) (LOG2 m))) $/\ n m)) ∧
   (∀n m. n2w n && ¬n2w m = n2w (BITWISE (SUC (LOG2 n)) (λa b. a ∧ ¬b) n m)) ∧
   (∀n m. ¬n2w m && n2w n = n2w (BITWISE (SUC (LOG2 n)) (λa b. a ∧ ¬b) n m)) ∧
   ∀n m.
     ¬n2w n && ¬n2w m = ¬n2w (BITWISE (SUC (MAX (LOG2 n) (LOG2 m))) $\/ n m)
</pre>

<DT><span class="strong">WORD_LITERAL_OR</span>
<DD>
<pre>
|- (∀n m.
      n2w n ‖ n2w m = n2w (BITWISE (SUC (MAX (LOG2 n) (LOG2 m))) $\/ n m)) ∧
   (∀n m. n2w n ‖ ¬n2w m = ¬n2w (BITWISE (SUC (LOG2 m)) (λa b. a ∧ ¬b) m n)) ∧
   (∀n m. ¬n2w m ‖ n2w n = ¬n2w (BITWISE (SUC (LOG2 m)) (λa b. a ∧ ¬b) m n)) ∧
   ∀n m.
     ¬n2w n ‖ ¬n2w m = ¬n2w (BITWISE (SUC (MIN (LOG2 n) (LOG2 m))) $/\ n m)
</pre>

<DT><span class="strong">WORD_LITERAL_XOR</span>
<DD>
<pre>
|- ∀n m.
     n2w n ⊕ n2w m =
     n2w (BITWISE (SUC (MAX (LOG2 n) (LOG2 m))) (λx y. x ⇎ y) n m)
</pre>

<DT><span class="strong">word_replicate_concat_word_list</span>
<DD>
<pre>
|- ∀n w. word_replicate n w = concat_word_list (GENLIST (K w) n)
</pre>

<DT><span class="strong">bit_field_insert</span>
<DD>
<pre>
|- ∀h l a b.
     h < l + dimindex (:α) ⇒
     (bit_field_insert h l a b =
      (let mask = (h '' l) (-1w) in w2w a ≪ l && mask ‖ b && ¬mask))
</pre>

<DT><span class="strong">word_join_index</span>
<DD>
<pre>
|- ∀i a b.
     FINITE 𝕌(:α) ∧ FINITE 𝕌(:β) ∧ i < dimindex (:α + β) ⇒
     (word_join a b ' i ⇔
      if i < dimindex (:β) then b ' i else a ' (i − dimindex (:β)))
</pre>

<DT><span class="strong">foldl_reduce_and</span>
<DD>
<pre>
|- ∀w.
     reduce_and w =
     (let l =
            GENLIST (λi. (let n = dimindex (:α) − 1 − i in (n >< n) w))
              (dimindex (:α))
      in
        FOLDL $&& (HD l) (TL l))
</pre>

<DT><span class="strong">foldl_reduce_or</span>
<DD>
<pre>
|- ∀w.
     reduce_or w =
     (let l =
            GENLIST (λi. (let n = dimindex (:α) − 1 − i in (n >< n) w))
              (dimindex (:α))
      in
        FOLDL $|| (HD l) (TL l))
</pre>

<DT><span class="strong">foldl_reduce_xor</span>
<DD>
<pre>
|- ∀w.
     reduce_xor w =
     (let l =
            GENLIST (λi. (let n = dimindex (:α) − 1 − i in (n >< n) w))
              (dimindex (:α))
      in
        FOLDL $?? (HD l) (TL l))
</pre>

<DT><span class="strong">foldl_reduce_nand</span>
<DD>
<pre>
|- ∀w.
     reduce_nand w =
     (let l =
            GENLIST (λi. (let n = dimindex (:α) − 1 − i in (n >< n) w))
              (dimindex (:α))
      in
        FOLDL $~&& (HD l) (TL l))
</pre>

<DT><span class="strong">foldl_reduce_nor</span>
<DD>
<pre>
|- ∀w.
     reduce_nor w =
     (let l =
            GENLIST (λi. (let n = dimindex (:α) − 1 − i in (n >< n) w))
              (dimindex (:α))
      in
        FOLDL $~|| (HD l) (TL l))
</pre>

<DT><span class="strong">foldl_reduce_xnor</span>
<DD>
<pre>
|- ∀w.
     reduce_xnor w =
     (let l =
            GENLIST (λi. (let n = dimindex (:α) − 1 − i in (n >< n) w))
              (dimindex (:α))
      in
        FOLDL $~?? (HD l) (TL l))
</pre>

<DT><span class="strong">LOG2_w2n_lt</span>
<DD>
<pre>
|- ∀w. w ≠ 0w ⇒ LOG2 (w2n w) < dimindex (:α)
</pre>

<DT><span class="strong">LOG2_w2n</span>
<DD>
<pre>
|- ∀w.
     w ≠ 0w ⇒
     (LOG2 (w2n w) = dimindex (:α) − 1 − LEAST i. w ' (dimindex (:α) − 1 − i))
</pre>

<DT><span class="strong">LEAST_BIT_LT</span>
<DD>
<pre>
|- ∀w. w ≠ 0w ⇒ (LEAST i. w ' i) < dimindex (:α)
</pre>

<DT><span class="strong">word_reduce_n2w</span>
<DD>
<pre>
|- ∀n f.
     word_reduce f (n2w n) =
     $FCP (K (let l = BOOLIFY (dimindex (:α)) n [] in FOLDL f (HD l) (TL l)))
</pre>

<DT><span class="strong">NOT_UINTMAXw</span>
<DD>
<pre>
|- ∀w. w ≠ UINT_MAXw ⇒ ∃i. i < dimindex (:α) ∧ ¬w ' i
</pre>

<DT><span class="strong">NOT_0w</span>
<DD>
<pre>
|- ∀w. w ≠ 0w ⇒ ∃i. i < dimindex (:α) ∧ w ' i
</pre>

<DT><span class="strong">reduce_and</span>
<DD>
<pre>
|- ∀w. reduce_and w = if w = UINT_MAXw then 1w else 0w
</pre>

<DT><span class="strong">reduce_or</span>
<DD>
<pre>
|- ∀w. reduce_or w = if w = 0w then 0w else 1w
</pre>

<DT><span class="strong">WORD_ADD_0</span>
<DD>
<pre>
|- (∀w. w + 0w = w) ∧ ∀w. 0w + w = w
</pre>

<DT><span class="strong">WORD_ADD_ASSOC</span>
<DD>
<pre>
|- ∀v w x. v + (w + x) = v + w + x
</pre>

<DT><span class="strong">WORD_MULT_ASSOC</span>
<DD>
<pre>
|- ∀v w x. v * (w * x) = v * w * x
</pre>

<DT><span class="strong">WORD_ADD_COMM</span>
<DD>
<pre>
|- ∀v w. v + w = w + v
</pre>

<DT><span class="strong">WORD_MULT_COMM</span>
<DD>
<pre>
|- ∀v w. v * w = w * v
</pre>

<DT><span class="strong">WORD_MULT_CLAUSES</span>
<DD>
<pre>
|- ∀v w.
     (0w * v = 0w) ∧ (v * 0w = 0w) ∧ (1w * v = v) ∧ (v * 1w = v) ∧
     ((v + 1w) * w = v * w + w) ∧ (v * (w + 1w) = v + v * w)
</pre>

<DT><span class="strong">WORD_LEFT_ADD_DISTRIB</span>
<DD>
<pre>
|- ∀v w x. v * (w + x) = v * w + v * x
</pre>

<DT><span class="strong">WORD_RIGHT_ADD_DISTRIB</span>
<DD>
<pre>
|- ∀v w x. (v + w) * x = v * x + w * x
</pre>

<DT><span class="strong">WORD_ADD_SUB_ASSOC</span>
<DD>
<pre>
|- ∀v w x. v + w − x = v + (w − x)
</pre>

<DT><span class="strong">WORD_ADD_SUB_SYM</span>
<DD>
<pre>
|- ∀v w x. v + w − x = v − x + w
</pre>

<DT><span class="strong">WORD_ADD_LINV</span>
<DD>
<pre>
|- ∀w. -w + w = 0w
</pre>

<DT><span class="strong">WORD_ADD_RINV</span>
<DD>
<pre>
|- ∀w. w + -w = 0w
</pre>

<DT><span class="strong">WORD_SUB_REFL</span>
<DD>
<pre>
|- ∀w. w − w = 0w
</pre>

<DT><span class="strong">WORD_SUB_ADD2</span>
<DD>
<pre>
|- ∀v w. v + (w − v) = w
</pre>

<DT><span class="strong">WORD_ADD_SUB</span>
<DD>
<pre>
|- ∀v w. v + w − w = v
</pre>

<DT><span class="strong">WORD_SUB_ADD</span>
<DD>
<pre>
|- ∀v w. v − w + w = v
</pre>

<DT><span class="strong">WORD_ADD_EQ_SUB</span>
<DD>
<pre>
|- ∀v w x. (v + w = x) ⇔ (v = x − w)
</pre>

<DT><span class="strong">WORD_ADD_INV_0_EQ</span>
<DD>
<pre>
|- ∀v w. (v + w = v) ⇔ (w = 0w)
</pre>

<DT><span class="strong">WORD_EQ_ADD_LCANCEL</span>
<DD>
<pre>
|- ∀v w x. (v + w = v + x) ⇔ (w = x)
</pre>

<DT><span class="strong">WORD_EQ_ADD_RCANCEL</span>
<DD>
<pre>
|- ∀v w x. (v + w = x + w) ⇔ (v = x)
</pre>

<DT><span class="strong">WORD_NEG</span>
<DD>
<pre>
|- ∀w. -w = ¬w + 1w
</pre>

<DT><span class="strong">WORD_NOT</span>
<DD>
<pre>
|- ∀w. ¬w = -w − 1w
</pre>

<DT><span class="strong">WORD_NEG_0</span>
<DD>
<pre>
|- -0w = 0w
</pre>

<DT><span class="strong">WORD_NEG_ADD</span>
<DD>
<pre>
|- ∀v w. -(v + w) = -v + -w
</pre>

<DT><span class="strong">WORD_NEG_NEG</span>
<DD>
<pre>
|- ∀w. - -w = w
</pre>

<DT><span class="strong">WORD_SUB_LNEG</span>
<DD>
<pre>
|- ∀v w. -v − w = -(v + w)
</pre>

<DT><span class="strong">WORD_SUB_RNEG</span>
<DD>
<pre>
|- ∀v w. v − -w = v + w
</pre>

<DT><span class="strong">WORD_SUB_SUB</span>
<DD>
<pre>
|- ∀v w x. v − (w − x) = v + x − w
</pre>

<DT><span class="strong">WORD_SUB_SUB2</span>
<DD>
<pre>
|- ∀v w. v − (v − w) = w
</pre>

<DT><span class="strong">WORD_EQ_SUB_LADD</span>
<DD>
<pre>
|- ∀v w x. (v = w − x) ⇔ (v + x = w)
</pre>

<DT><span class="strong">WORD_EQ_SUB_RADD</span>
<DD>
<pre>
|- ∀v w x. (v − w = x) ⇔ (v = x + w)
</pre>

<DT><span class="strong">WORD_EQ_SUB_ZERO</span>
<DD>
<pre>
|- ∀w v. (v − w = 0w) ⇔ (v = w)
</pre>

<DT><span class="strong">WORD_LCANCEL_SUB</span>
<DD>
<pre>
|- ∀v w x. (v − w = x − w) ⇔ (v = x)
</pre>

<DT><span class="strong">WORD_RCANCEL_SUB</span>
<DD>
<pre>
|- ∀v w x. (v − w = v − x) ⇔ (w = x)
</pre>

<DT><span class="strong">WORD_SUB_PLUS</span>
<DD>
<pre>
|- ∀v w x. v − (w + x) = v − w − x
</pre>

<DT><span class="strong">WORD_SUB_LZERO</span>
<DD>
<pre>
|- ∀w. 0w − w = -w
</pre>

<DT><span class="strong">WORD_SUB_RZERO</span>
<DD>
<pre>
|- ∀w. w − 0w = w
</pre>

<DT><span class="strong">WORD_ADD_LID_UNIQ</span>
<DD>
<pre>
|- ∀v w. (v + w = w) ⇔ (v = 0w)
</pre>

<DT><span class="strong">WORD_ADD_RID_UNIQ</span>
<DD>
<pre>
|- ∀v w. (v + w = v) ⇔ (w = 0w)
</pre>

<DT><span class="strong">WORD_SUM_ZERO</span>
<DD>
<pre>
|- ∀a b. (a + b = 0w) ⇔ (a = -b)
</pre>

<DT><span class="strong">WORD_ADD_SUB2</span>
<DD>
<pre>
|- ∀v w. w + v − w = v
</pre>

<DT><span class="strong">WORD_ADD_SUB3</span>
<DD>
<pre>
|- ∀v x. v − (v + x) = -x
</pre>

<DT><span class="strong">WORD_SUB_SUB3</span>
<DD>
<pre>
|- ∀w v. v − w − v = -w
</pre>

<DT><span class="strong">WORD_EQ_NEG</span>
<DD>
<pre>
|- ∀v w. (-v = -w) ⇔ (v = w)
</pre>

<DT><span class="strong">WORD_NEG_EQ</span>
<DD>
<pre>
|- ∀w v. (-v = w) ⇔ (v = -w)
</pre>

<DT><span class="strong">WORD_NEG_EQ_0</span>
<DD>
<pre>
|- (-v = 0w) ⇔ (v = 0w)
</pre>

<DT><span class="strong">WORD_SUB</span>
<DD>
<pre>
|- ∀v w. -w + v = v − w
</pre>

<DT><span class="strong">WORD_SUB_NEG</span>
<DD>
<pre>
|- ∀v w. -v − -w = w − v
</pre>

<DT><span class="strong">WORD_NEG_SUB</span>
<DD>
<pre>
|- ∀w v. -(v − w) = w − v
</pre>

<DT><span class="strong">WORD_SUB_TRIANGLE</span>
<DD>
<pre>
|- ∀v w x. v − w + (w − x) = v − x
</pre>

<DT><span class="strong">WORD_NOT_0</span>
<DD>
<pre>
|- ¬0w = UINT_MAXw
</pre>

<DT><span class="strong">WORD_NOT_T</span>
<DD>
<pre>
|- ¬UINT_MAXw = 0w
</pre>

<DT><span class="strong">WORD_NEG_T</span>
<DD>
<pre>
|- -UINT_MAXw = 1w
</pre>

<DT><span class="strong">WORD_MULT_SUC</span>
<DD>
<pre>
|- ∀v n. v * n2w (n + 1) = v * n2w n + v
</pre>

<DT><span class="strong">WORD_NEG_LMUL</span>
<DD>
<pre>
|- ∀v w. -(v * w) = -v * w
</pre>

<DT><span class="strong">WORD_NEG_RMUL</span>
<DD>
<pre>
|- ∀v w. -(v * w) = v * -w
</pre>

<DT><span class="strong">WORD_NEG_MUL</span>
<DD>
<pre>
|- ∀w. -w = -1w * w
</pre>

<DT><span class="strong">sw2sw_w2w_add</span>
<DD>
<pre>
|- ∀w. sw2sw w = (if word_msb w then -1w ≪ dimindex (:α) else 0w) + w2w w
</pre>

<DT><span class="strong">WORD_ADD_BIT0</span>
<DD>
<pre>
|- ∀a b. (a + b) ' 0 ⇔ (a ' 0 ⇎ b ' 0)
</pre>

<DT><span class="strong">WORD_ADD_BIT</span>
<DD>
<pre>
|- ∀n a b.
     n < dimindex (:α) ⇒
     ((a + b) ' n ⇔
      if n = 0 then a ' 0 ⇎ b ' 0
      else if ((n − 1 -- 0) a + (n − 1 -- 0) b) ' n then a ' n ⇔ b ' n
      else a ' n ⇎ b ' n)
</pre>

<DT><span class="strong">WORD_LEFT_SUB_DISTRIB</span>
<DD>
<pre>
|- ∀v w x. v * (w − x) = v * w − v * x
</pre>

<DT><span class="strong">WORD_RIGHT_SUB_DISTRIB</span>
<DD>
<pre>
|- ∀v w x. (w − x) * v = w * v − x * v
</pre>

<DT><span class="strong">WORD_LITERAL_MULT</span>
<DD>
<pre>
|- (∀m n. n2w m * -n2w n = -n2w (m * n)) ∧ ∀m n. -n2w m * -n2w n = n2w (m * n)
</pre>

<DT><span class="strong">WORD_LITERAL_ADD</span>
<DD>
<pre>
|- (∀m n. -n2w m + -n2w n = -n2w (m + n)) ∧
   ∀m n. n2w m + -n2w n = if n ≤ m then n2w (m − n) else -n2w (n − m)
</pre>

<DT><span class="strong">WORD_SUB_INTRO</span>
<DD>
<pre>
|- (∀x y. -y + x = x − y) ∧ (∀x y. x + -y = x − y) ∧
   (∀x y z. -x * y + z = z − x * y) ∧ (∀x y z. z + -x * y = z − x * y) ∧
   (∀x. -1w * x = -x) ∧ (∀x y z. z − -x * y = z + x * y) ∧
   ∀x y z. -x * y − z = -(x * y + z)
</pre>

<DT><span class="strong">n2w_SUC</span>
<DD>
<pre>
|- ∀n. n2w (SUC n) = n2w n + 1w
</pre>

<DT><span class="strong">n2w_sub</span>
<DD>
<pre>
|- ∀a b. b ≤ a ⇒ (n2w (a − b) = n2w a − n2w b)
</pre>

<DT><span class="strong">n2w_sub_eq_0</span>
<DD>
<pre>
|- ∀a b. a ≤ b ⇒ (n2w (a − b) = 0w)
</pre>

<DT><span class="strong">WORD_H_WORD_L</span>
<DD>
<pre>
|- INT_MAXw = INT_MINw − 1w
</pre>

<DT><span class="strong">word_L_MULT</span>
<DD>
<pre>
|- ∀n. n2w n * INT_MINw = if EVEN n then 0w else INT_MINw
</pre>

<DT><span class="strong">ASR_ADD</span>
<DD>
<pre>
|- ∀w m n. w ≫ m ≫ n = w ≫ (m + n)
</pre>

<DT><span class="strong">LSR_ADD</span>
<DD>
<pre>
|- ∀w m n. w ⋙ m ⋙ n = w ⋙ (m + n)
</pre>

<DT><span class="strong">ROR_ADD</span>
<DD>
<pre>
|- ∀w m n. w ⇄ m ⇄ n = w ⇄ (m + n)
</pre>

<DT><span class="strong">LSL_ADD</span>
<DD>
<pre>
|- ∀w m n. w ≪ m ≪ n = w ≪ (m + n)
</pre>

<DT><span class="strong">ASR_LIMIT</span>
<DD>
<pre>
|- ∀w n. dimindex (:α) ≤ n ⇒ (w ≫ n = if word_msb w then UINT_MAXw else 0w)
</pre>

<DT><span class="strong">ASR_UINT_MAX</span>
<DD>
<pre>
|- ∀n. UINT_MAXw ≫ n = UINT_MAXw
</pre>

<DT><span class="strong">LSR_LIMIT</span>
<DD>
<pre>
|- ∀w n. dimindex (:α) ≤ n ⇒ (w ⋙ n = 0w)
</pre>

<DT><span class="strong">LSL_LIMIT</span>
<DD>
<pre>
|- ∀w n. dimindex (:α) ≤ n ⇒ (w ≪ n = 0w)
</pre>

<DT><span class="strong">ROR_CYCLE</span>
<DD>
<pre>
|- ∀w n. w ⇄ (n * dimindex (:α)) = w
</pre>

<DT><span class="strong">ROR_MOD</span>
<DD>
<pre>
|- ∀w n. w ⇄ (n MOD dimindex (:α)) = w ⇄ n
</pre>

<DT><span class="strong">ROL_MOD</span>
<DD>
<pre>
|- ∀w n. w ⇆ (n MOD dimindex (:α)) = w ⇆ n
</pre>

<DT><span class="strong">LSL_ONE</span>
<DD>
<pre>
|- ∀w. w ≪ 1 = w + w
</pre>

<DT><span class="strong">ROR_UINT_MAX</span>
<DD>
<pre>
|- ∀n. UINT_MAXw ⇄ n = UINT_MAXw
</pre>

<DT><span class="strong">ROR_ROL</span>
<DD>
<pre>
|- ∀w n. (w ⇄ n ⇆ n = w) ∧ (w ⇆ n ⇄ n = w)
</pre>

<DT><span class="strong">MOD_COMPLEMENT</span>
<DD>
<pre>
|- ∀n q a.
     0 < n ∧ 0 < q ∧ a < q * n ⇒ ((q * n − a) MOD n = (n − a MOD n) MOD n)
</pre>

<DT><span class="strong">ROL_ADD</span>
<DD>
<pre>
|- ∀w m n. w ⇆ m ⇆ n = w ⇆ (m + n)
</pre>

<DT><span class="strong">ZERO_SHIFT</span>
<DD>
<pre>
|- (∀n. 0w ≪ n = 0w) ∧ (∀n. 0w ≫ n = 0w) ∧ (∀n. 0w ⋙ n = 0w) ∧
   (∀n. 0w ⇆ n = 0w) ∧ ∀n. 0w ⇄ n = 0w
</pre>

<DT><span class="strong">SHIFT_ZERO</span>
<DD>
<pre>
|- (∀a. a ≪ 0 = a) ∧ (∀a. a ≫ 0 = a) ∧ (∀a. a ⋙ 0 = a) ∧ (∀a. a ⇆ 0 = a) ∧
   ∀a. a ⇄ 0 = a
</pre>

<DT><span class="strong">word_lsl_n2w</span>
<DD>
<pre>
|- ∀n m. n2w m ≪ n = if dimindex (:α) − 1 < n then 0w else n2w (m * 2 ** n)
</pre>

<DT><span class="strong">word_lsr_n2w</span>
<DD>
<pre>
|- ∀w n. w ⋙ n = (dimindex (:α) − 1 -- n) w
</pre>

<DT><span class="strong">LSL_UINT_MAX</span>
<DD>
<pre>
|- ∀n. UINT_MAXw ≪ n = n2w (dimword (:α) − 2 ** n)
</pre>

<DT><span class="strong">word_asr_n2w</span>
<DD>
<pre>
|- ∀n w.
     w ≫ n =
     if word_msb w then
       n2w (dimword (:α) − 2 ** (dimindex (:α) − MIN n (dimindex (:α)))) ‖
       w ⋙ n
     else w ⋙ n
</pre>

<DT><span class="strong">word_ror_n2w</span>
<DD>
<pre>
|- ∀n a.
     n2w a ⇄ n =
     (let x = n MOD dimindex (:α)
      in
        n2w
          (BITS (dimindex (:α) − 1) x a +
           BITS (x − 1) 0 a * 2 ** (dimindex (:α) − x)))
</pre>

<DT><span class="strong">word_rrx_n2w</span>
<DD>
<pre>
|- ∀c a.
     word_rrx (c,n2w a) =
     (ODD a,n2w (BITS (dimindex (:α) − 1) 1 a + SBIT c (dimindex (:α) − 1)))
</pre>

<DT><span class="strong">word_ror</span>
<DD>
<pre>
|- ∀w n.
     w ⇄ n =
     (let x = n MOD dimindex (:α)
      in
        (dimindex (:α) − 1 -- x) w ‖ (x − 1 -- 0) w ≪ (dimindex (:α) − x))
</pre>

<DT><span class="strong">word_asr</span>
<DD>
<pre>
|- ∀w n.
     w ≫ n =
     if word_msb w then
       (dimindex (:α) − 1 '' dimindex (:α) − n) UINT_MAXw ‖ w ⋙ n
     else w ⋙ n
</pre>

<DT><span class="strong">w2n_lsr</span>
<DD>
<pre>
|- ∀w m. w2n (w ⋙ m) = w2n w DIV 2 ** m
</pre>

<DT><span class="strong">WORD_MUL_LSL</span>
<DD>
<pre>
|- ∀a n. a ≪ n = n2w (2 ** n) * a
</pre>

<DT><span class="strong">WORD_ADD_LSL</span>
<DD>
<pre>
|- ∀n a b. (a + b) ≪ n = a ≪ n + b ≪ n
</pre>

<DT><span class="strong">WORD_DIV_LSR</span>
<DD>
<pre>
|- ∀m n. n < dimindex (:α) ⇒ (m ⋙ n = m // n2w (2 ** n))
</pre>

<DT><span class="strong">WORD_MOD_1</span>
<DD>
<pre>
|- ∀m. word_mod m 1w = 0w
</pre>

<DT><span class="strong">WORD_MOD_POW2</span>
<DD>
<pre>
|- ∀m v. v < dimindex (:α) − 1 ⇒ (word_mod m (n2w (2 ** SUC v)) = (v -- 0) m)
</pre>

<DT><span class="strong">SHIFT_1_SUB_1</span>
<DD>
<pre>
|- ∀i n. i < dimindex (:α) ⇒ ((1w ≪ n − 1w) ' i ⇔ i < n)
</pre>

<DT><span class="strong">LSR_BITWISE</span>
<DD>
<pre>
|- (∀n v w. w ⋙ n && v ⋙ n = (w && v) ⋙ n) ∧
   (∀n v w. w ⋙ n ‖ v ⋙ n = (w ‖ v) ⋙ n) ∧ ∀n v w. w ⋙ n ⊕ v ⋙ n = (w ⊕ v) ⋙ n
</pre>

<DT><span class="strong">LSL_BITWISE</span>
<DD>
<pre>
|- (∀n v w. w ≪ n && v ≪ n = (w && v) ≪ n) ∧
   (∀n v w. w ≪ n ‖ v ≪ n = (w ‖ v) ≪ n) ∧ ∀n v w. w ≪ n ⊕ v ≪ n = (w ⊕ v) ≪ n
</pre>

<DT><span class="strong">ROR_BITWISE</span>
<DD>
<pre>
|- (∀n v w. w ⇄ n && v ⇄ n = (w && v) ⇄ n) ∧
   (∀n v w. w ⇄ n ‖ v ⇄ n = (w ‖ v) ⇄ n) ∧ ∀n v w. w ⇄ n ⊕ v ⇄ n = (w ⊕ v) ⇄ n
</pre>

<DT><span class="strong">ROL_BITWISE</span>
<DD>
<pre>
|- (∀n v w. w ⇆ n && v ⇆ n = (w && v) ⇆ n) ∧
   (∀n v w. w ⇆ n ‖ v ⇆ n = (w ‖ v) ⇆ n) ∧ ∀n v w. w ⇆ n ⊕ v ⇆ n = (w ⊕ v) ⇆ n
</pre>

<DT><span class="strong">WORD_2COMP_LSL</span>
<DD>
<pre>
|- ∀n a. -a ≪ n = -(a ≪ n)
</pre>

<DT><span class="strong">w2w_LSL</span>
<DD>
<pre>
|- ∀w n.
     w2w (w ≪ n) =
     if n < dimindex (:α) then w2w ((dimindex (:α) − 1 − n -- 0) w) ≪ n
     else 0w
</pre>

<DT><span class="strong">n2w_DIV</span>
<DD>
<pre>
|- ∀a n. a < dimword (:α) ⇒ (n2w (a DIV 2 ** n) = n2w a ⋙ n)
</pre>

<DT><span class="strong">WORD_BITS_LSL</span>
<DD>
<pre>
|- ∀h l n w.
     h < dimindex (:α) ⇒
     ((h -- l) (w ≪ n) = if n ≤ h then (h − n -- l − n) w ≪ (n − l) else 0w)
</pre>

<DT><span class="strong">WORD_EXTRACT_LSL</span>
<DD>
<pre>
|- ∀h l n w.
     h < dimindex (:α) ⇒
     ((h >< l) (w ≪ n) = if n ≤ h then (h − n >< l − n) w ≪ (n − l) else 0w)
</pre>

<DT><span class="strong">WORD_EXTRACT_LSL2</span>
<DD>
<pre>
|- ∀h l n w.
     dimindex (:β) + l ≤ h + n ⇒
     ((h >< l) w ≪ n = (dimindex (:β) + l − (n + 1) >< l) w ≪ n)
</pre>

<DT><span class="strong">EXTRACT_JOIN_LSL</span>
<DD>
<pre>
|- ∀h m m' l s n w.
     l ≤ m ∧ m' ≤ h ∧ (m' = m + 1) ∧ (s = m' − l + n) ⇒
     ((h >< m') w ≪ s ‖ (m >< l) w ≪ n =
      (MIN h (MIN (dimindex (:β) + l − 1) (dimindex (:α) − 1)) >< l) w ≪ n)
</pre>

<DT><span class="strong">EXTRACT_JOIN_ADD_LSL</span>
<DD>
<pre>
|- ∀h m m' l s n w.
     l ≤ m ∧ m' ≤ h ∧ (m' = m + 1) ∧ (s = m' − l + n) ⇒
     ((h >< m') w ≪ s + (m >< l) w ≪ n =
      (MIN h (MIN (dimindex (:β) + l − 1) (dimindex (:α) − 1)) >< l) w ≪ n)
</pre>

<DT><span class="strong">word_extract_mask</span>
<DD>
<pre>
|- ∀h l a. (h >< l) a = if l ≤ h then a ⋙ l && 2w ≪ (h − l) − 1w else 0w
</pre>

<DT><span class="strong">word_shift_bv</span>
<DD>
<pre>
|- (∀w n. n < dimword (:α) ⇒ (w ≪ n = w <<~ n2w n)) ∧
   (∀w n. n < dimword (:α) ⇒ (w ≫ n = w >>~ n2w n)) ∧
   (∀w n. n < dimword (:α) ⇒ (w ⋙ n = w >>>~ n2w n)) ∧
   (∀w n. w ⇄ n = w #>>~ n2w (n MOD dimindex (:α))) ∧
   ∀w n. w ⇆ n = w #<<~ n2w (n MOD dimindex (:α))
</pre>

<DT><span class="strong">WORD_NEG_L</span>
<DD>
<pre>
|- -INT_MINw = INT_MINw
</pre>

<DT><span class="strong">word_L_MULT_NEG</span>
<DD>
<pre>
|- ∀n. -n2w n * INT_MINw = if EVEN n then 0w else INT_MINw
</pre>

<DT><span class="strong">word_L2_MULT</span>
<DD>
<pre>
|- (INT_MINw2 * INT_MINw2 = INT_MINw2) ∧ (INT_MINw * INT_MINw2 = INT_MINw2) ∧
   (∀n. n2w n * INT_MINw2 = if EVEN n then 0w else INT_MINw2) ∧
   ∀n. -n2w n * INT_MINw2 = if EVEN n then 0w else INT_MINw2
</pre>

<DT><span class="strong">TWO_COMP_NEG</span>
<DD>
<pre>
|- ∀a.
     word_msb a ⇒
     if (dimindex (:α) − 1 = 0) ∨ (a = INT_MINw) then word_msb (-a)
     else ¬word_msb (-a)
</pre>

<DT><span class="strong">TWO_COMP_POS_NEG</span>
<DD>
<pre>
|- ∀a.
     ¬((dimindex (:α) − 1 = 0) ∨ (a = 0w) ∨ (a = INT_MINw)) ⇒
     (¬word_msb a ⇔ word_msb (-a))
</pre>

<DT><span class="strong">WORD_0_POS</span>
<DD>
<pre>
|- ¬word_msb 0w
</pre>

<DT><span class="strong">TWO_COMP_POS</span>
<DD>
<pre>
|- ∀a. ¬word_msb a ⇒ (a = 0w) ∨ word_msb (-a)
</pre>

<DT><span class="strong">WORD_H_POS</span>
<DD>
<pre>
|- ¬word_msb INT_MAXw
</pre>

<DT><span class="strong">WORD_L_NEG</span>
<DD>
<pre>
|- word_msb INT_MINw
</pre>

<DT><span class="strong">WORD_GREATER</span>
<DD>
<pre>
|- ∀a b. a > b ⇔ b < a
</pre>

<DT><span class="strong">WORD_GREATER_EQ</span>
<DD>
<pre>
|- ∀a b. a ≥ b ⇔ b ≤ a
</pre>

<DT><span class="strong">WORD_NOT_LESS</span>
<DD>
<pre>
|- ∀a b. ¬(a < b) ⇔ b ≤ a
</pre>

<DT><span class="strong">WORD_LT</span>
<DD>
<pre>
|- ∀a b.
     a < b ⇔
     (word_msb a ⇔ word_msb b) ∧ w2n a < w2n b ∨ word_msb a ∧ ¬word_msb b
</pre>

<DT><span class="strong">WORD_GT</span>
<DD>
<pre>
|- ∀a b.
     a > b ⇔
     (word_msb b ⇔ word_msb a) ∧ w2n a > w2n b ∨ word_msb b ∧ ¬word_msb a
</pre>

<DT><span class="strong">WORD_LE</span>
<DD>
<pre>
|- ∀a b.
     a ≤ b ⇔
     (word_msb a ⇔ word_msb b) ∧ w2n a ≤ w2n b ∨ word_msb a ∧ ¬word_msb b
</pre>

<DT><span class="strong">WORD_GE</span>
<DD>
<pre>
|- ∀a b.
     a ≥ b ⇔
     (word_msb b ⇔ word_msb a) ∧ w2n a ≥ w2n b ∨ word_msb b ∧ ¬word_msb a
</pre>

<DT><span class="strong">WORD_LO</span>
<DD>
<pre>
|- ∀a b. a <₊ b ⇔ w2n a < w2n b
</pre>

<DT><span class="strong">WORD_LS</span>
<DD>
<pre>
|- ∀a b. a ≤₊ b ⇔ w2n a ≤ w2n b
</pre>

<DT><span class="strong">WORD_HI</span>
<DD>
<pre>
|- ∀a b. a >₊ b ⇔ w2n a > w2n b
</pre>

<DT><span class="strong">WORD_HS</span>
<DD>
<pre>
|- ∀a b. a ≥₊ b ⇔ w2n a ≥ w2n b
</pre>

<DT><span class="strong">WORD_NOT_LESS_EQUAL</span>
<DD>
<pre>
|- ∀a b. ¬(a ≤ b) ⇔ b < a
</pre>

<DT><span class="strong">WORD_LESS_OR_EQ</span>
<DD>
<pre>
|- ∀a b. a ≤ b ⇔ a < b ∨ (a = b)
</pre>

<DT><span class="strong">WORD_GREATER_OR_EQ</span>
<DD>
<pre>
|- ∀a b. a ≥ b ⇔ a > b ∨ (a = b)
</pre>

<DT><span class="strong">WORD_LESS_TRANS</span>
<DD>
<pre>
|- ∀a b c. a < b ∧ b < c ⇒ a < c
</pre>

<DT><span class="strong">WORD_LESS_EQ_TRANS</span>
<DD>
<pre>
|- ∀a b c. a ≤ b ∧ b ≤ c ⇒ a ≤ c
</pre>

<DT><span class="strong">WORD_LESS_EQ_LESS_TRANS</span>
<DD>
<pre>
|- ∀a b c. a ≤ b ∧ b < c ⇒ a < c
</pre>

<DT><span class="strong">WORD_LESS_LESS_EQ_TRANS</span>
<DD>
<pre>
|- ∀a b c. a < b ∧ b ≤ c ⇒ a < c
</pre>

<DT><span class="strong">WORD_LESS_EQ_CASES</span>
<DD>
<pre>
|- ∀a b. a ≤ b ∨ b ≤ a
</pre>

<DT><span class="strong">WORD_LESS_CASES</span>
<DD>
<pre>
|- ∀a b. a < b ∨ b ≤ a
</pre>

<DT><span class="strong">WORD_LESS_CASES_IMP</span>
<DD>
<pre>
|- ∀a b. ¬(a < b) ∧ a ≠ b ⇒ b < a
</pre>

<DT><span class="strong">WORD_LESS_ANTISYM</span>
<DD>
<pre>
|- ∀a b. ¬(a < b ∧ b < a)
</pre>

<DT><span class="strong">WORD_LESS_EQ_ANTISYM</span>
<DD>
<pre>
|- ∀a b. ¬(a < b ∧ b ≤ a)
</pre>

<DT><span class="strong">WORD_LESS_EQ_REFL</span>
<DD>
<pre>
|- ∀a. a ≤ a
</pre>

<DT><span class="strong">WORD_LESS_EQUAL_ANTISYM</span>
<DD>
<pre>
|- ∀a b. a ≤ b ∧ b ≤ a ⇒ (a = b)
</pre>

<DT><span class="strong">WORD_LESS_IMP_LESS_OR_EQ</span>
<DD>
<pre>
|- ∀a b. a < b ⇒ a ≤ b
</pre>

<DT><span class="strong">WORD_LESS_REFL</span>
<DD>
<pre>
|- ∀a. ¬(a < a)
</pre>

<DT><span class="strong">WORD_LESS_LESS_CASES</span>
<DD>
<pre>
|- ∀a b. (a = b) ∨ a < b ∨ b < a
</pre>

<DT><span class="strong">WORD_NOT_GREATER</span>
<DD>
<pre>
|- ∀a b. ¬(a > b) ⇔ a ≤ b
</pre>

<DT><span class="strong">WORD_LESS_NOT_EQ</span>
<DD>
<pre>
|- ∀a b. a < b ⇒ a ≠ b
</pre>

<DT><span class="strong">WORD_NOT_LESS_EQ</span>
<DD>
<pre>
|- ∀a b. (a = b) ⇒ ¬(a < b)
</pre>

<DT><span class="strong">WORD_HIGHER</span>
<DD>
<pre>
|- ∀a b. a >₊ b ⇔ b <₊ a
</pre>

<DT><span class="strong">WORD_HIGHER_EQ</span>
<DD>
<pre>
|- ∀a b. a ≥₊ b ⇔ b ≤₊ a
</pre>

<DT><span class="strong">WORD_NOT_LOWER</span>
<DD>
<pre>
|- ∀a b. ¬(a <₊ b) ⇔ b ≤₊ a
</pre>

<DT><span class="strong">WORD_NOT_LOWER_EQUAL</span>
<DD>
<pre>
|- ∀a b. ¬(a ≤₊ b) ⇔ b <₊ a
</pre>

<DT><span class="strong">WORD_LOWER_OR_EQ</span>
<DD>
<pre>
|- ∀a b. a ≤₊ b ⇔ a <₊ b ∨ (a = b)
</pre>

<DT><span class="strong">WORD_HIGHER_OR_EQ</span>
<DD>
<pre>
|- ∀a b. a ≥₊ b ⇔ a >₊ b ∨ (a = b)
</pre>

<DT><span class="strong">WORD_LOWER_TRANS</span>
<DD>
<pre>
|- ∀a b c. a <₊ b ∧ b <₊ c ⇒ a <₊ c
</pre>

<DT><span class="strong">WORD_LOWER_EQ_TRANS</span>
<DD>
<pre>
|- ∀a b c. a ≤₊ b ∧ b ≤₊ c ⇒ a ≤₊ c
</pre>

<DT><span class="strong">WORD_LOWER_EQ_LOWER_TRANS</span>
<DD>
<pre>
|- ∀a b c. a ≤₊ b ∧ b <₊ c ⇒ a <₊ c
</pre>

<DT><span class="strong">WORD_LOWER_LOWER_EQ_TRANS</span>
<DD>
<pre>
|- ∀a b c. a <₊ b ∧ b ≤₊ c ⇒ a <₊ c
</pre>

<DT><span class="strong">WORD_LOWER_EQ_CASES</span>
<DD>
<pre>
|- ∀a b. a ≤₊ b ∨ b ≤₊ a
</pre>

<DT><span class="strong">WORD_LOWER_CASES</span>
<DD>
<pre>
|- ∀a b. a <₊ b ∨ b ≤₊ a
</pre>

<DT><span class="strong">WORD_LOWER_CASES_IMP</span>
<DD>
<pre>
|- ∀a b. ¬(a <₊ b) ∧ a ≠ b ⇒ b <₊ a
</pre>

<DT><span class="strong">WORD_LOWER_ANTISYM</span>
<DD>
<pre>
|- ∀a b. ¬(a <₊ b ∧ b <₊ a)
</pre>

<DT><span class="strong">WORD_LOWER_EQ_ANTISYM</span>
<DD>
<pre>
|- ∀a b. ¬(a <₊ b ∧ b ≤₊ a)
</pre>

<DT><span class="strong">WORD_LOWER_EQ_REFL</span>
<DD>
<pre>
|- ∀a. a ≤₊ a
</pre>

<DT><span class="strong">WORD_LOWER_EQUAL_ANTISYM</span>
<DD>
<pre>
|- ∀a b. a ≤₊ b ∧ b ≤₊ a ⇒ (a = b)
</pre>

<DT><span class="strong">WORD_LOWER_IMP_LOWER_OR_EQ</span>
<DD>
<pre>
|- ∀a b. a <₊ b ⇒ a ≤₊ b
</pre>

<DT><span class="strong">WORD_LOWER_REFL</span>
<DD>
<pre>
|- ∀a. ¬(a <₊ a)
</pre>

<DT><span class="strong">WORD_LOWER_LOWER_CASES</span>
<DD>
<pre>
|- ∀a b. (a = b) ∨ a <₊ b ∨ b <₊ a
</pre>

<DT><span class="strong">WORD_NOT_HIGHER</span>
<DD>
<pre>
|- ∀a b. ¬(a >₊ b) ⇔ a ≤₊ b
</pre>

<DT><span class="strong">WORD_LOWER_NOT_EQ</span>
<DD>
<pre>
|- ∀a b. a <₊ b ⇒ a ≠ b
</pre>

<DT><span class="strong">WORD_NOT_LOWER_EQ</span>
<DD>
<pre>
|- ∀a b. (a = b) ⇒ ¬(a <₊ b)
</pre>

<DT><span class="strong">WORD_L_PLUS_H</span>
<DD>
<pre>
|- INT_MINw + INT_MAXw = UINT_MAXw
</pre>

<DT><span class="strong">WORD_L_LESS_EQ</span>
<DD>
<pre>
|- ∀a. INT_MINw ≤ a
</pre>

<DT><span class="strong">WORD_LESS_EQ_H</span>
<DD>
<pre>
|- ∀a. a ≤ INT_MAXw
</pre>

<DT><span class="strong">WORD_L_LESS_H</span>
<DD>
<pre>
|- INT_MINw < INT_MAXw
</pre>

<DT><span class="strong">NOT_INT_MIN_ZERO</span>
<DD>
<pre>
|- INT_MINw ≠ 0w
</pre>

<DT><span class="strong">ZERO_LO_INT_MIN</span>
<DD>
<pre>
|- 0w <₊ INT_MINw
</pre>

<DT><span class="strong">WORD_0_LS</span>
<DD>
<pre>
|- ∀w. 0w ≤₊ w
</pre>

<DT><span class="strong">WORD_LS_T</span>
<DD>
<pre>
|- ∀w. w ≤₊ UINT_MAXw
</pre>

<DT><span class="strong">WORD_ADD_LEFT_LO</span>
<DD>
<pre>
|- ∀b c a.
     a + b <₊ c ⇔
     if b ≤₊ c then
       (let x = n2w (w2n c − w2n b) in a <₊ x ∨ b ≠ 0w ∧ -c + x ≤₊ a)
     else -b ≤₊ a ∧ a <₊ -b + c
</pre>

<DT><span class="strong">WORD_ADD_LEFT_LS</span>
<DD>
<pre>
|- ∀b c a.
     a + b ≤₊ c ⇔
     if b ≤₊ c then
       (let x = n2w (w2n c − w2n b) in a ≤₊ x ∨ b ≠ 0w ∧ -c + x ≤₊ a)
     else -b ≤₊ a ∧ a ≤₊ -b + c
</pre>

<DT><span class="strong">WORD_ADD_RIGHT_LS</span>
<DD>
<pre>
|- ∀c a b.
     a ≤₊ b + c ⇔
     if c ≤₊ a then
       (let x = n2w (w2n a − w2n c) in x ≤₊ b ∧ ((c = 0w) ∨ b <₊ -a + x))
     else b <₊ -c ∨ -c + a ≤₊ b
</pre>

<DT><span class="strong">WORD_ADD_RIGHT_LO</span>
<DD>
<pre>
|- ∀c a b.
     a <₊ b + c ⇔
     if c ≤₊ a then
       (let x = n2w (w2n a − w2n c) in x <₊ b ∧ ((c = 0w) ∨ b <₊ -a + x))
     else b <₊ -c ∨ -c + a <₊ b
</pre>

<DT><span class="strong">WORD_MSB_INT_MIN_LS</span>
<DD>
<pre>
|- ∀a. word_msb a ⇔ INT_MINw ≤₊ a
</pre>

<DT><span class="strong">WORD_LT_LO</span>
<DD>
<pre>
|- ∀a b.
     a < b ⇔
     INT_MINw ≤₊ a ∧ (b <₊ INT_MINw ∨ a <₊ b) ∨
     a <₊ INT_MINw ∧ b <₊ INT_MINw ∧ a <₊ b
</pre>

<DT><span class="strong">WORD_LE_LS</span>
<DD>
<pre>
|- ∀a b.
     a ≤ b ⇔
     INT_MINw ≤₊ a ∧ (b <₊ INT_MINw ∨ a ≤₊ b) ∨
     a <₊ INT_MINw ∧ b <₊ INT_MINw ∧ a ≤₊ b
</pre>

<DT><span class="strong">WORD_LESS_NEG_LEFT</span>
<DD>
<pre>
|- ∀a b. -a <₊ b ⇔ b ≠ 0w ∧ ((a = 0w) ∨ -b <₊ a)
</pre>

<DT><span class="strong">WORD_LESS_NEG_RIGHT</span>
<DD>
<pre>
|- ∀a b. a <₊ -b ⇔ b ≠ 0w ∧ ((a = 0w) ∨ b <₊ -a)
</pre>

<DT><span class="strong">WORD_LS_word_0</span>
<DD>
<pre>
|- ∀n. n ≤₊ 0w ⇔ (n = 0w)
</pre>

<DT><span class="strong">WORD_LO_word_0</span>
<DD>
<pre>
|- (∀n. 0w <₊ n ⇔ n ≠ 0w) ∧ ∀n. ¬(n <₊ 0w)
</pre>

<DT><span class="strong">WORD_ADD_LEFT_LO2</span>
<DD>
<pre>
|- ∀c a. c + a <₊ a ⇔ a ≠ 0w ∧ (c ≠ 0w ∧ -c <₊ a ∨ (a = -c))
</pre>

<DT><span class="strong">WORD_ADD_LEFT_LS2</span>
<DD>
<pre>
|- ∀c a. c + a ≤₊ a ⇔ (c = 0w) ∨ a ≠ 0w ∧ (-c <₊ a ∨ (a = -c))
</pre>

<DT><span class="strong">WORD_ADD_RIGHT_LO2</span>
<DD>
<pre>
|- ∀c a. a <₊ c + a ⇔ c ≠ 0w ∧ ((a = 0w) ∨ a <₊ -c)
</pre>

<DT><span class="strong">WORD_ADD_RIGHT_LS2</span>
<DD>
<pre>
|- ∀c a. a ≤₊ c + a ⇔ (a = 0w) ∨ (c = 0w) ∨ a <₊ -c
</pre>

<DT><span class="strong">word_msb_neg</span>
<DD>
<pre>
|- ∀w. word_msb w ⇔ w < 0w
</pre>

<DT><span class="strong">word_abs</span>
<DD>
<pre>
|- ∀w. word_abs w = FCP i. ¬word_msb w ∧ w ' i ∨ word_msb w ∧ (-w) ' i
</pre>

<DT><span class="strong">word_abs_word_abs</span>
<DD>
<pre>
|- ∀w. word_abs (word_abs w) = word_abs w
</pre>

<DT><span class="strong">word_abs_neg</span>
<DD>
<pre>
|- ∀w. word_abs (-w) = word_abs w
</pre>

<DT><span class="strong">word_abs_diff</span>
<DD>
<pre>
|- ∀a b. word_abs (a − b) = word_abs (b − a)
</pre>

<DT><span class="strong">FST_ADD_WITH_CARRY</span>
<DD>
<pre>
|- ((∀a b. FST (add_with_carry (a,b,F)) = a + b) ∧
    (∀a b. FST (add_with_carry (a,¬b,T)) = a − b) ∧
    ∀a b. FST (add_with_carry (¬a,b,T)) = b − a) ∧
   (∀n a. FST (add_with_carry (a,n2w n,T)) = a − ¬n2w n) ∧
   ∀n b. FST (add_with_carry (n2w n,b,T)) = b − ¬n2w n
</pre>

<DT><span class="strong">ADD_WITH_CARRY_SUB</span>
<DD>
<pre>
|- ∀x y.
     add_with_carry (x,¬y,T) =
     (x − y,y ≤₊ x,
      (word_msb x ⇎ word_msb y) ∧ (word_msb (x − y) ⇎ word_msb x))
</pre>

<DT><span class="strong">word_eq_n2w</span>
<DD>
<pre>
|- (∀m n. (n2w m = n2w n) ⇔ MOD_2EXP_EQ (dimindex (:α)) m n) ∧
   (∀n. (n2w n = -1w) ⇔ MOD_2EXP_MAX (dimindex (:α)) n) ∧
   ∀n. (-1w = n2w n) ⇔ MOD_2EXP_MAX (dimindex (:α)) n
</pre>

<DT><span class="strong">word_lt_n2w</span>
<DD>
<pre>
|- ∀a b.
     n2w a < n2w b ⇔
     (let sa = BIT (dimindex (:α) − 1) a and sb = BIT (dimindex (:α) − 1) b
      in
        (sa ⇔ sb) ∧ a MOD dimword (:α) < b MOD dimword (:α) ∨ sa ∧ ¬sb)
</pre>

<DT><span class="strong">word_gt_n2w</span>
<DD>
<pre>
|- ∀a b.
     n2w a > n2w b ⇔
     (let sa = BIT (dimindex (:α) − 1) a and sb = BIT (dimindex (:α) − 1) b
      in
        (sa ⇔ sb) ∧ a MOD dimword (:α) > b MOD dimword (:α) ∨ ¬sa ∧ sb)
</pre>

<DT><span class="strong">word_le_n2w</span>
<DD>
<pre>
|- ∀a b.
     n2w a ≤ n2w b ⇔
     (let sa = BIT (dimindex (:α) − 1) a and sb = BIT (dimindex (:α) − 1) b
      in
        (sa ⇔ sb) ∧ a MOD dimword (:α) ≤ b MOD dimword (:α) ∨ sa ∧ ¬sb)
</pre>

<DT><span class="strong">word_ge_n2w</span>
<DD>
<pre>
|- ∀a b.
     n2w a ≥ n2w b ⇔
     (let sa = BIT (dimindex (:α) − 1) a and sb = BIT (dimindex (:α) − 1) b
      in
        (sa ⇔ sb) ∧ a MOD dimword (:α) ≥ b MOD dimword (:α) ∨ ¬sa ∧ sb)
</pre>

<DT><span class="strong">word_ls_n2w</span>
<DD>
<pre>
|- ∀a b. n2w a ≤₊ n2w b ⇔ a MOD dimword (:α) ≤ b MOD dimword (:α)
</pre>

<DT><span class="strong">word_hi_n2w</span>
<DD>
<pre>
|- ∀a b. n2w a >₊ n2w b ⇔ a MOD dimword (:α) > b MOD dimword (:α)
</pre>

<DT><span class="strong">word_lo_n2w</span>
<DD>
<pre>
|- ∀a b. n2w a <₊ n2w b ⇔ a MOD dimword (:α) < b MOD dimword (:α)
</pre>

<DT><span class="strong">word_hs_n2w</span>
<DD>
<pre>
|- ∀a b. n2w a ≥₊ n2w b ⇔ a MOD dimword (:α) ≥ b MOD dimword (:α)
</pre>

<DT><span class="strong">w2n_add</span>
<DD>
<pre>
|- ∀a b. ¬word_msb a ∧ ¬word_msb b ⇒ (w2n (a + b) = w2n a + w2n b)
</pre>

<DT><span class="strong">saturate_w2w_n2w</span>
<DD>
<pre>
|- ∀n.
     saturate_w2w (n2w n) =
     (let m = n MOD dimword (:α)
      in
        if dimindex (:β) ≤ dimindex (:α) ∧ dimword (:β) ≤ m then UINT_MAXw
        else n2w m)
</pre>

<DT><span class="strong">saturate_w2w</span>
<DD>
<pre>
|- ∀w.
     saturate_w2w w =
     if dimindex (:β) ≤ dimindex (:α) ∧ w2w UINT_MAXw ≤₊ w then UINT_MAXw
     else w2w w
</pre>

<DT><span class="strong">saturate_sub</span>
<DD>
<pre>
|- ∀a b. saturate_sub a b = if a ≤₊ b then 0w else a − b
</pre>

<DT><span class="strong">saturate_add</span>
<DD>
<pre>
|- ∀a b. saturate_add a b = if UINT_MAXw − a ≤₊ b then UINT_MAXw else a + b
</pre>

<DT><span class="strong">NOT_FINITE_IMP_dimword_2</span>
<DD>
<pre>
|- INFINITE 𝕌(:α) ⇒ (dimword (:α) = 2)
</pre>

<DT><span class="strong">saturate_mul</span>
<DD>
<pre>
|- ∀a b.
     saturate_mul a b =
     if FINITE 𝕌(:α) ∧ w2w UINT_MAXw ≤₊ w2w a * w2w b then UINT_MAXw
     else a * b
</pre>

<DT><span class="strong">WORD_DIVISION</span>
<DD>
<pre>
|- ∀w. w ≠ 0w ⇒ ∀v. (v = v // w * w + word_mod v w) ∧ word_mod v w <₊ w
</pre>

<DT><span class="strong">word_reverse_0</span>
<DD>
<pre>
|- word_reverse 0w = 0w
</pre>

<DT><span class="strong">word_reverse_word_T</span>
<DD>
<pre>
|- word_reverse (-1w) = -1w
</pre>

<DT><span class="strong">sw2sw_0</span>
<DD>
<pre>
|- sw2sw 0w = 0w
</pre>

<DT><span class="strong">sw2sw_word_T</span>
<DD>
<pre>
|- sw2sw (-1w) = -1w
</pre>

<DT><span class="strong">word_div_1</span>
<DD>
<pre>
|- ∀v. v // 1w = v
</pre>

<DT><span class="strong">word_bit_0</span>
<DD>
<pre>
|- ∀h. ¬word_bit h 0w
</pre>

<DT><span class="strong">word_lsb_word_T</span>
<DD>
<pre>
|- word_lsb (-1w)
</pre>

<DT><span class="strong">word_msb_word_T</span>
<DD>
<pre>
|- word_msb (-1w)
</pre>

<DT><span class="strong">word_bit_0_word_T</span>
<DD>
<pre>
|- word_bit 0 (-1w)
</pre>

<DT><span class="strong">word_log2_1</span>
<DD>
<pre>
|- word_log2 1w = 0w
</pre>

<DT><span class="strong">word_join_0</span>
<DD>
<pre>
|- ∀a. word_join 0w a = w2w a
</pre>

<DT><span class="strong">word_concat_0_0</span>
<DD>
<pre>
|- 0w @@ 0w = 0w
</pre>

<DT><span class="strong">w2w_eq_n2w</span>
<DD>
<pre>
|- ∀x y.
     dimindex (:α) ≤ dimindex (:β) ∧ y < dimword (:α) ⇒
     ((w2w x = n2w y) ⇔ (x = n2w y))
</pre>

<DT><span class="strong">word_extract_eq_n2w</span>
<DD>
<pre>
|- ∀x h y.
     dimindex (:α) ≤ dimindex (:β) ∧ dimindex (:α) − 1 ≤ h ∧
     y < dimword (:α) ⇒
     (((h >< 0) x = n2w y) ⇔ (x = n2w y))
</pre>

<DT><span class="strong">word_concat_0</span>
<DD>
<pre>
|- ∀x. FINITE 𝕌(:α) ∧ x < dimword (:β) ⇒ (0w @@ n2w x = n2w x)
</pre>

<DT><span class="strong">word_concat_0_eq</span>
<DD>
<pre>
|- ∀x y.
     FINITE 𝕌(:α) ∧ dimindex (:β) ≤ dimindex (:γ) ∧ y < dimword (:β) ⇒
     ((0w @@ x = n2w y) ⇔ (x = n2w y))
</pre>

<DT><span class="strong">word_join_word_T</span>
<DD>
<pre>
|- word_join (-1w) (-1w) = -1w
</pre>

<DT><span class="strong">word_concat_word_T</span>
<DD>
<pre>
|- -1w @@ -1w = w2w (-1w)
</pre>

<DT><span class="strong">lsr_1_word_T</span>
<DD>
<pre>
|- -1w ⋙ 1 = INT_MAXw
</pre>

<DT><span class="strong">word_rrx_0</span>
<DD>
<pre>
|- (word_rrx (F,0w) = (F,0w)) ∧ (word_rrx (T,0w) = (F,INT_MINw))
</pre>

<DT><span class="strong">word_rrx_word_T</span>
<DD>
<pre>
|- (word_rrx (F,-1w) = (T,INT_MAXw)) ∧ (word_rrx (T,-1w) = (T,-1w))
</pre>

<DT><span class="strong">word_T_not_zero</span>
<DD>
<pre>
|- -1w ≠ 0w
</pre>

<DT><span class="strong">WORD_LS_word_T</span>
<DD>
<pre>
|- (∀n. -1w ≤₊ n ⇔ (n = -1w)) ∧ ∀n. n ≤₊ -1w
</pre>

<DT><span class="strong">WORD_LO_word_T</span>
<DD>
<pre>
|- (∀n. ¬(-1w <₊ n)) ∧ ∀n. n <₊ -1w ⇔ n ≠ -1w
</pre>

<DT><span class="strong">WORD_LESS_0_word_T</span>
<DD>
<pre>
|- ¬(0w < -1w) ∧ ¬(0w ≤ -1w) ∧ -1w < 0w ∧ -1w ≤ 0w
</pre>

<DT><span class="strong">word_reverse_thm</span>
<DD>
<pre>
|- ∀w v n.
     (word_reverse (word_reverse w) = w) ∧
     (word_reverse (w ≪ n) = word_reverse w ⋙ n) ∧
     (word_reverse (w ⋙ n) = word_reverse w ≪ n) ∧
     (word_reverse (w ‖ v) = word_reverse w ‖ word_reverse v) ∧
     (word_reverse (w && v) = word_reverse w && word_reverse v) ∧
     (word_reverse (w ⊕ v) = word_reverse w ⊕ word_reverse v) ∧
     (word_reverse (¬w) = ¬word_reverse w) ∧ (word_reverse 0w = 0w) ∧
     (word_reverse (-1w) = -1w) ∧ ((word_reverse w = 0w) ⇔ (w = 0w)) ∧
     ((word_reverse w = -1w) ⇔ (w = -1w))
</pre>

<DT><span class="strong">bit_count_upto_0</span>
<DD>
<pre>
|- ∀w. bit_count_upto 0 w = 0
</pre>

<DT><span class="strong">bit_count_upto_SUC</span>
<DD>
<pre>
|- ∀w n.
     bit_count_upto (SUC n) w = (if w ' n then 1 else 0) + bit_count_upto n w
</pre>

<DT><span class="strong">bit_count_upto_is_zero</span>
<DD>
<pre>
|- ∀n w. (bit_count_upto n w = 0) ⇔ ∀i. i < n ⇒ ¬w ' i
</pre>

<DT><span class="strong">bit_count_is_zero</span>
<DD>
<pre>
|- ∀w. (bit_count w = 0) ⇔ (w = 0w)
</pre>

<DT><span class="strong">WORD_FINITE</span>
<DD>
<pre>
|- ∀s. FINITE s
</pre>

<DT><span class="strong">WORD_SET_INDUCT</span>
<DD>
<pre>
|- ∀P. P ∅ ∧ (∀s. P s ⇒ ∀e. e ∉ s ⇒ P (e INSERT s)) ⇒ ∀s. P s
</pre>

<DT><span class="strong">SUC_WORD_PRED</span>
<DD>
<pre>
|- ∀x. x ≠ 0w ⇒ (SUC (w2n (x − 1w)) = w2n x)
</pre>

<DT><span class="strong">WORD_PRED_THM</span>
<DD>
<pre>
|- ∀m. m ≠ 0w ⇒ w2n (m − 1w) < w2n m
</pre>

<DT><span class="strong">LSR_LESS</span>
<DD>
<pre>
|- ∀m y. y ≠ 0w ∧ 0 < m ⇒ w2n (y ⋙ m) < w2n y
</pre>

<DT><span class="strong">word_sub_w2n</span>
<DD>
<pre>
|- ∀x y. y ≤₊ x ⇒ (w2n (x − y) = w2n x − w2n y)
</pre>

<DT><span class="strong">WORD_LE_EQ_LS</span>
<DD>
<pre>
|- ∀x y. 0w ≤ x ∧ 0w ≤ y ⇒ (x ≤ y ⇔ x ≤₊ y)
</pre>

<DT><span class="strong">WORD_LT_EQ_LO</span>
<DD>
<pre>
|- ∀x y. 0w ≤ x ∧ 0w ≤ y ⇒ (x < y ⇔ x <₊ y)
</pre>

<DT><span class="strong">WORD_ZERO_LE</span>
<DD>
<pre>
|- ∀w. 0w ≤ w ⇔ w2n w < INT_MIN (:α)
</pre>

<DT><span class="strong">WORD_LT_SUB_UPPER</span>
<DD>
<pre>
|- ∀x y. 0w < y ∧ y < x ⇒ x − y < x
</pre>

<DT><span class="strong">WORD_SUB_LT</span>
<DD>
<pre>
|- ∀x y. 0w < y ∧ y < x ⇒ 0w < x − y ∧ x − y < x
</pre>

<DT><span class="strong">WORD_SUB_LE</span>
<DD>
<pre>
|- ∀x y. 0w ≤ y ∧ y ≤ x ⇒ 0w ≤ x − y ∧ x − y ≤ x
</pre>

<DT><span class="strong">dimindex_1</span>
<DD>
<pre>
|- dimindex (:unit) = 1
</pre>

<DT><span class="strong">finite_1</span>
<DD>
<pre>
|- FINITE 𝕌(:unit)
</pre>

<DT><span class="strong">INT_MIN_1</span>
<DD>
<pre>
|- INT_MIN (:unit) = 1
</pre>

<DT><span class="strong">dimword_1</span>
<DD>
<pre>
|- dimword (:unit) = 2
</pre>

<DT><span class="strong">dimindex_2</span>
<DD>
<pre>
|- dimindex (:2) = 2
</pre>

<DT><span class="strong">finite_2</span>
<DD>
<pre>
|- FINITE 𝕌(:2)
</pre>

<DT><span class="strong">INT_MIN_2</span>
<DD>
<pre>
|- INT_MIN (:2) = 2
</pre>

<DT><span class="strong">dimword_2</span>
<DD>
<pre>
|- dimword (:2) = 4
</pre>

<DT><span class="strong">dimindex_3</span>
<DD>
<pre>
|- dimindex (:3) = 3
</pre>

<DT><span class="strong">finite_3</span>
<DD>
<pre>
|- FINITE 𝕌(:3)
</pre>

<DT><span class="strong">INT_MIN_3</span>
<DD>
<pre>
|- INT_MIN (:3) = 4
</pre>

<DT><span class="strong">dimword_3</span>
<DD>
<pre>
|- dimword (:3) = 8
</pre>

<DT><span class="strong">dimindex_4</span>
<DD>
<pre>
|- dimindex (:4) = 4
</pre>

<DT><span class="strong">finite_4</span>
<DD>
<pre>
|- FINITE 𝕌(:4)
</pre>

<DT><span class="strong">INT_MIN_4</span>
<DD>
<pre>
|- INT_MIN (:4) = 8
</pre>

<DT><span class="strong">dimword_4</span>
<DD>
<pre>
|- dimword (:4) = 16
</pre>

<DT><span class="strong">dimindex_5</span>
<DD>
<pre>
|- dimindex (:5) = 5
</pre>

<DT><span class="strong">finite_5</span>
<DD>
<pre>
|- FINITE 𝕌(:5)
</pre>

<DT><span class="strong">INT_MIN_5</span>
<DD>
<pre>
|- INT_MIN (:5) = 16
</pre>

<DT><span class="strong">dimword_5</span>
<DD>
<pre>
|- dimword (:5) = 32
</pre>

<DT><span class="strong">dimindex_6</span>
<DD>
<pre>
|- dimindex (:6) = 6
</pre>

<DT><span class="strong">finite_6</span>
<DD>
<pre>
|- FINITE 𝕌(:6)
</pre>

<DT><span class="strong">INT_MIN_6</span>
<DD>
<pre>
|- INT_MIN (:6) = 32
</pre>

<DT><span class="strong">dimword_6</span>
<DD>
<pre>
|- dimword (:6) = 64
</pre>

<DT><span class="strong">dimindex_7</span>
<DD>
<pre>
|- dimindex (:7) = 7
</pre>

<DT><span class="strong">finite_7</span>
<DD>
<pre>
|- FINITE 𝕌(:7)
</pre>

<DT><span class="strong">INT_MIN_7</span>
<DD>
<pre>
|- INT_MIN (:7) = 64
</pre>

<DT><span class="strong">dimword_7</span>
<DD>
<pre>
|- dimword (:7) = 128
</pre>

<DT><span class="strong">dimindex_8</span>
<DD>
<pre>
|- dimindex (:8) = 8
</pre>

<DT><span class="strong">finite_8</span>
<DD>
<pre>
|- FINITE 𝕌(:8)
</pre>

<DT><span class="strong">INT_MIN_8</span>
<DD>
<pre>
|- INT_MIN (:8) = 128
</pre>

<DT><span class="strong">dimword_8</span>
<DD>
<pre>
|- dimword (:8) = 256
</pre>

<DT><span class="strong">dimindex_9</span>
<DD>
<pre>
|- dimindex (:9) = 9
</pre>

<DT><span class="strong">finite_9</span>
<DD>
<pre>
|- FINITE 𝕌(:9)
</pre>

<DT><span class="strong">INT_MIN_9</span>
<DD>
<pre>
|- INT_MIN (:9) = 256
</pre>

<DT><span class="strong">dimword_9</span>
<DD>
<pre>
|- dimword (:9) = 512
</pre>

<DT><span class="strong">dimindex_10</span>
<DD>
<pre>
|- dimindex (:10) = 10
</pre>

<DT><span class="strong">finite_10</span>
<DD>
<pre>
|- FINITE 𝕌(:10)
</pre>

<DT><span class="strong">INT_MIN_10</span>
<DD>
<pre>
|- INT_MIN (:10) = 512
</pre>

<DT><span class="strong">dimword_10</span>
<DD>
<pre>
|- dimword (:10) = 1024
</pre>

<DT><span class="strong">dimindex_11</span>
<DD>
<pre>
|- dimindex (:11) = 11
</pre>

<DT><span class="strong">finite_11</span>
<DD>
<pre>
|- FINITE 𝕌(:11)
</pre>

<DT><span class="strong">INT_MIN_11</span>
<DD>
<pre>
|- INT_MIN (:11) = 1024
</pre>

<DT><span class="strong">dimword_11</span>
<DD>
<pre>
|- dimword (:11) = 2048
</pre>

<DT><span class="strong">dimindex_12</span>
<DD>
<pre>
|- dimindex (:12) = 12
</pre>

<DT><span class="strong">finite_12</span>
<DD>
<pre>
|- FINITE 𝕌(:12)
</pre>

<DT><span class="strong">INT_MIN_12</span>
<DD>
<pre>
|- INT_MIN (:12) = 2048
</pre>

<DT><span class="strong">dimword_12</span>
<DD>
<pre>
|- dimword (:12) = 4096
</pre>

<DT><span class="strong">dimindex_16</span>
<DD>
<pre>
|- dimindex (:16) = 16
</pre>

<DT><span class="strong">finite_16</span>
<DD>
<pre>
|- FINITE 𝕌(:16)
</pre>

<DT><span class="strong">INT_MIN_16</span>
<DD>
<pre>
|- INT_MIN (:16) = 32768
</pre>

<DT><span class="strong">dimword_16</span>
<DD>
<pre>
|- dimword (:16) = 65536
</pre>

<DT><span class="strong">dimindex_20</span>
<DD>
<pre>
|- dimindex (:20) = 20
</pre>

<DT><span class="strong">finite_20</span>
<DD>
<pre>
|- FINITE 𝕌(:20)
</pre>

<DT><span class="strong">INT_MIN_20</span>
<DD>
<pre>
|- INT_MIN (:20) = 524288
</pre>

<DT><span class="strong">dimword_20</span>
<DD>
<pre>
|- dimword (:20) = 1048576
</pre>

<DT><span class="strong">dimindex_24</span>
<DD>
<pre>
|- dimindex (:24) = 24
</pre>

<DT><span class="strong">finite_24</span>
<DD>
<pre>
|- FINITE 𝕌(:24)
</pre>

<DT><span class="strong">INT_MIN_24</span>
<DD>
<pre>
|- INT_MIN (:24) = 8388608
</pre>

<DT><span class="strong">dimword_24</span>
<DD>
<pre>
|- dimword (:24) = 16777216
</pre>

<DT><span class="strong">dimindex_28</span>
<DD>
<pre>
|- dimindex (:28) = 28
</pre>

<DT><span class="strong">finite_28</span>
<DD>
<pre>
|- FINITE 𝕌(:28)
</pre>

<DT><span class="strong">INT_MIN_28</span>
<DD>
<pre>
|- INT_MIN (:28) = 134217728
</pre>

<DT><span class="strong">dimword_28</span>
<DD>
<pre>
|- dimword (:28) = 268435456
</pre>

<DT><span class="strong">dimindex_30</span>
<DD>
<pre>
|- dimindex (:30) = 30
</pre>

<DT><span class="strong">finite_30</span>
<DD>
<pre>
|- FINITE 𝕌(:30)
</pre>

<DT><span class="strong">INT_MIN_30</span>
<DD>
<pre>
|- INT_MIN (:30) = 536870912
</pre>

<DT><span class="strong">dimword_30</span>
<DD>
<pre>
|- dimword (:30) = 1073741824
</pre>

<DT><span class="strong">dimindex_32</span>
<DD>
<pre>
|- dimindex (:32) = 32
</pre>

<DT><span class="strong">finite_32</span>
<DD>
<pre>
|- FINITE 𝕌(:32)
</pre>

<DT><span class="strong">INT_MIN_32</span>
<DD>
<pre>
|- INT_MIN (:32) = 2147483648
</pre>

<DT><span class="strong">dimword_32</span>
<DD>
<pre>
|- dimword (:32) = 4294967296
</pre>

<DT><span class="strong">dimindex_48</span>
<DD>
<pre>
|- dimindex (:48) = 48
</pre>

<DT><span class="strong">finite_48</span>
<DD>
<pre>
|- FINITE 𝕌(:48)
</pre>

<DT><span class="strong">INT_MIN_48</span>
<DD>
<pre>
|- INT_MIN (:48) = 140737488355328
</pre>

<DT><span class="strong">dimword_48</span>
<DD>
<pre>
|- dimword (:48) = 281474976710656
</pre>

<DT><span class="strong">dimindex_64</span>
<DD>
<pre>
|- dimindex (:64) = 64
</pre>

<DT><span class="strong">finite_64</span>
<DD>
<pre>
|- FINITE 𝕌(:64)
</pre>

<DT><span class="strong">INT_MIN_64</span>
<DD>
<pre>
|- INT_MIN (:64) = 9223372036854775808
</pre>

<DT><span class="strong">dimword_64</span>
<DD>
<pre>
|- dimword (:64) = 18446744073709551616
</pre>

<DT><span class="strong">dimindex_96</span>
<DD>
<pre>
|- dimindex (:96) = 96
</pre>

<DT><span class="strong">finite_96</span>
<DD>
<pre>
|- FINITE 𝕌(:96)
</pre>

<DT><span class="strong">INT_MIN_96</span>
<DD>
<pre>
|- INT_MIN (:96) = 39614081257132168796771975168
</pre>

<DT><span class="strong">dimword_96</span>
<DD>
<pre>
|- dimword (:96) = 79228162514264337593543950336
</pre>

<DT><span class="strong">dimindex_128</span>
<DD>
<pre>
|- dimindex (:128) = 128
</pre>

<DT><span class="strong">finite_128</span>
<DD>
<pre>
|- FINITE 𝕌(:128)
</pre>

<DT><span class="strong">INT_MIN_128</span>
<DD>
<pre>
|- INT_MIN (:128) = 170141183460469231731687303715884105728
</pre>

<DT><span class="strong">dimword_128</span>
<DD>
<pre>
|- dimword (:128) = 340282366920938463463374607431768211456
</pre>

<DT><span class="strong">n2w_itself_ind</span>
<DD>
<pre>
|- ∀P. (∀n. P (n,(:α))) ⇒ ∀v v1. P (v,v1)
</pre>

<DT><span class="strong">n2w_itself_def</span>
<DD>
<pre>
|- n2w_itself (n,(:α)) = n2w n
</pre>

</DL>



<hr>
</body>
</html>
