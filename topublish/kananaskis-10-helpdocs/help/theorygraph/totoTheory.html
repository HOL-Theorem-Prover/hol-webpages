<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: toto</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "toto"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "wotTheory.html"><span class="strong">wot</span></a>&nbsp;&nbsp;
    <a href = "stringTheory.html"><span class="strong">string</span></a>

<h1>Signature</h1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr> <th> Type <th> Arity<tr><td> <span class="strong">cpn</span> <td> 0
    <tr><td> <span class="strong">num_dt</span> <td> 0
    <tr><td> <span class="strong">toto</span> <td> 1
    <tr>
    <th>
    Constant
    <th>
    Type<tr><td> <span class="strong">EQUAL</span> <td> :cpn
    <tr><td> <span class="strong">GREATER</span> <td> :cpn
    <tr><td> <span class="strong">LESS</span> <td> :cpn
    <tr><td> <span class="strong">ListOrd</span> <td> :α toto -> α list comp
    <tr><td>
        <span class="strong">StrongLinearOrder_of_TO</span>
        <td>
        :α comp -> α reln
    <tr><td> <span class="strong">TO</span> <td> :α comp -> α toto
    <tr><td> <span class="strong">TO_inv</span> <td> :α comp -> α comp
    <tr><td>
        <span class="strong">TO_of_LinearOrder</span>
        <td>
        :α reln -> α comp
    <tr><td> <span class="strong">TotOrd</span> <td> :α comp -> bool
    <tr><td>
        <span class="strong">WeakLinearOrder_of_TO</span>
        <td>
        :α comp -> α reln
    <tr><td> <span class="strong">apto</span> <td> :α toto -> α comp
    <tr><td> <span class="strong">bit1</span> <td> :num_dt -> num_dt
    <tr><td> <span class="strong">bit2</span> <td> :num_dt -> num_dt
    <tr><td> <span class="strong">charOrd</span> <td> :char comp
    <tr><td> <span class="strong">charto</span> <td> :char toto
    <tr><td> <span class="strong">cpn2num</span> <td> :cpn -> num
    <tr><td>
        <span class="strong">cpn_CASE</span>
        <td>
        :cpn -> α -> α -> α -> α
    <tr><td> <span class="strong">cpn_size</span> <td> :cpn -> num
    <tr><td>
        <span class="strong">imageOrd</span>
        <td>
        :(α -> γ) -> γ comp -> α comp
    <tr><td>
        <span class="strong">lexTO</span>
        <td>
        :α comp -> β comp -> (α # β) comp
    <tr><td>
        <span class="strong">lextoto</span>
        <td>
        :α toto -> β toto -> (α # β) toto
    <tr><td> <span class="strong">listorder</span> <td> :α reln -> α list reln
    <tr><td>
        <span class="strong">listorder_tupled</span>
        <td>
        :α reln # α list # α list -> bool
    <tr><td> <span class="strong">listoto</span> <td> :α toto -> α list toto
    <tr><td> <span class="strong">num2cpn</span> <td> :num -> cpn
    <tr><td> <span class="strong">numOrd</span> <td> :num comp
    <tr><td> <span class="strong">num_dtOrd</span> <td> :num_dt comp
    <tr><td>
        <span class="strong">num_dtOrd_tupled</span>
        <td>
        :num_dt # num_dt -> cpn
    <tr><td>
        <span class="strong">num_dt_CASE</span>
        <td>
        :num_dt -> α -> (num_dt -> α) -> (num_dt -> α) -> α
    <tr><td> <span class="strong">num_dt_size</span> <td> :num_dt -> num
    <tr><td> <span class="strong">num_to_dt</span> <td> :num -> num_dt
    <tr><td> <span class="strong">numto</span> <td> :num toto
    <tr><td> <span class="strong">qk_numOrd</span> <td> :num comp
    <tr><td> <span class="strong">qk_numto</span> <td> :num toto
    <tr><td> <span class="strong">stringto</span> <td> :string toto
    <tr><td> <span class="strong">toto_inv</span> <td> :α toto -> α toto
    <tr><td>
        <span class="strong">toto_of_LinearOrder</span>
        <td>
        :α reln -> α toto
    <tr><td> <span class="strong">zer</span> <td> :num_dt

</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">cpn_TY_DEF</span>
<DD>
<pre>
|- ∃rep. TYPE_DEFINITION (λn. n < 3) rep
</pre>

<DT><span class="strong">cpn_BIJ</span>
<DD>
<pre>
|- (∀a. num2cpn (cpn2num a) = a) ∧
   ∀r. (λn. n < 3) r ⇔ (cpn2num (num2cpn r) = r)
</pre>

<DT><span class="strong">cpn_size_def</span>
<DD>
<pre>
|- ∀x. cpn_size x = 0
</pre>

<DT><span class="strong">cpn_CASE</span>
<DD>
<pre>
|- ∀x v0 v1 v2.
     (case x of LESS => v0 | EQUAL => v1 | GREATER => v2) =
     (λm. if m < 1 then v0 else if m = 1 then v1 else v2) (cpn2num x)
</pre>

<DT><span class="strong">TotOrd</span>
<DD>
<pre>
|- ∀c.
     TotOrd c ⇔
     (∀x y. (c x y = EQUAL) ⇔ (x = y)) ∧
     (∀x y. (c x y = GREATER) ⇔ (c y x = LESS)) ∧
     ∀x y z. (c x y = LESS) ∧ (c y z = LESS) ⇒ (c x z = LESS)
</pre>

<DT><span class="strong">TO_of_LinearOrder</span>
<DD>
<pre>
|- ∀r x y.
     TO_of_LinearOrder r x y =
     if x = y then EQUAL else if r x y then LESS else GREATER
</pre>

<DT><span class="strong">toto_TY_DEF</span>
<DD>
<pre>
|- ∃rep. TYPE_DEFINITION TotOrd rep
</pre>

<DT><span class="strong">to_bij</span>
<DD>
<pre>
|- (∀a. TO (apto a) = a) ∧ ∀r. TotOrd r ⇔ (apto (TO r) = r)
</pre>

<DT><span class="strong">WeakLinearOrder_of_TO</span>
<DD>
<pre>
|- ∀c x y. WeakLinearOrder_of_TO c x y ⇔ case c x y of GREATER => F | _ => T
</pre>

<DT><span class="strong">StrongLinearOrder_of_TO</span>
<DD>
<pre>
|- ∀c x y. StrongLinearOrder_of_TO c x y ⇔ case c x y of LESS => T | _ => F
</pre>

<DT><span class="strong">toto_of_LinearOrder</span>
<DD>
<pre>
|- ∀r. toto_of_LinearOrder r = TO (TO_of_LinearOrder r)
</pre>

<DT><span class="strong">TO_inv</span>
<DD>
<pre>
|- ∀c x y. TO_inv c x y = c y x
</pre>

<DT><span class="strong">toto_inv</span>
<DD>
<pre>
|- ∀c. toto_inv c = TO (TO_inv (apto c))
</pre>

<DT><span class="strong">lexTO</span>
<DD>
<pre>
|- ∀R V.
     R lexTO V =
     TO_of_LinearOrder
       (StrongLinearOrder_of_TO R LEX StrongLinearOrder_of_TO V)
</pre>

<DT><span class="strong">lextoto</span>
<DD>
<pre>
|- ∀c v. c lextoto v = TO (apto c lexTO apto v)
</pre>

<DT><span class="strong">numOrd</span>
<DD>
<pre>
|- numOrd = TO_of_LinearOrder $<
</pre>

<DT><span class="strong">numto</span>
<DD>
<pre>
|- numto = TO numOrd
</pre>

<DT><span class="strong">num_dt_TY_DEF</span>
<DD>
<pre>
|- ∃rep.
     TYPE_DEFINITION
       (λa0.
          ∀'num_dt' .
            (∀a0.
               (a0 = ind_type$CONSTR 0 ARB (λn. ind_type$BOTTOM)) ∨
               (∃a.
                  (a0 =
                   (λa.
                      ind_type$CONSTR (SUC 0) ARB
                        (ind_type$FCONS a (λn. ind_type$BOTTOM))) a) ∧
                  'num_dt' a) ∨
               (∃a.
                  (a0 =
                   (λa.
                      ind_type$CONSTR (SUC (SUC 0)) ARB
                        (ind_type$FCONS a (λn. ind_type$BOTTOM))) a) ∧
                  'num_dt' a) ⇒
               'num_dt' a0) ⇒
            'num_dt' a0) rep
</pre>

<DT><span class="strong">num_dt_case_def</span>
<DD>
<pre>
|- (∀v f f1. num_dt_CASE zer v f f1 = v) ∧
   (∀a v f f1. num_dt_CASE (bit1 a) v f f1 = f a) ∧
   ∀a v f f1. num_dt_CASE (bit2 a) v f f1 = f1 a
</pre>

<DT><span class="strong">num_dt_size_def</span>
<DD>
<pre>
|- (num_dt_size zer = 0) ∧ (∀a. num_dt_size (bit1 a) = 1 + num_dt_size a) ∧
   ∀a. num_dt_size (bit2 a) = 1 + num_dt_size a
</pre>

<DT><span class="strong">num_to_dt_primitive</span>
<DD>
<pre>
|- num_to_dt =
   WFREC
     (@R.
        WF R ∧ (∀n. n ≠ 0 ∧ ODD n ⇒ R (DIV2 (n − 1)) n) ∧
        ∀n. n ≠ 0 ∧ ¬ODD n ⇒ R (DIV2 (n − 2)) n)
     (λnum_to_dt n.
        I
          (if n = 0 then zer
           else if ODD n then bit1 (num_to_dt (DIV2 (n − 1)))
           else bit2 (num_to_dt (DIV2 (n − 2)))))
</pre>

<DT><span class="strong">num_dtOrd_tupled_primitive</span>
<DD>
<pre>
|- num_dtOrd_tupled =
   WFREC
     (@R.
        WF R ∧ (∀y x. R (x,y) (bit1 x,bit1 y)) ∧
        ∀y x. R (x,y) (bit2 x,bit2 y))
     (λnum_dtOrd_tupled a.
        case a of
          (zer,zer) => I EQUAL
        | (zer,bit1 x) => I LESS
        | (zer,bit2 x') => I LESS
        | (bit1 x'',zer) => I GREATER
        | (bit1 x'',bit1 y'') => I (num_dtOrd_tupled (x'',y''))
        | (bit1 x'',bit2 y) => I LESS
        | (bit2 x''',zer) => I GREATER
        | (bit2 x''',bit1 y') => I GREATER
        | (bit2 x''',bit2 y''') => I (num_dtOrd_tupled (x''',y''')))
</pre>

<DT><span class="strong">num_dtOrd_curried</span>
<DD>
<pre>
|- ∀x x1. num_dtOrd x x1 = num_dtOrd_tupled (x,x1)
</pre>

<DT><span class="strong">qk_numOrd_def</span>
<DD>
<pre>
|- ∀m n. qk_numOrd m n = num_dtOrd (num_to_dt m) (num_to_dt n)
</pre>

<DT><span class="strong">qk_numto</span>
<DD>
<pre>
|- qk_numto = TO qk_numOrd
</pre>

<DT><span class="strong">charOrd</span>
<DD>
<pre>
|- ∀a b. charOrd a b = numOrd (ORD a) (ORD b)
</pre>

<DT><span class="strong">charto</span>
<DD>
<pre>
|- charto = TO charOrd
</pre>

<DT><span class="strong">listorder_tupled_primitive</span>
<DD>
<pre>
|- listorder_tupled =
   WFREC (@R. WF R ∧ ∀s r m l V. R (V,l,m) (V,r::l,s::m))
     (λlistorder_tupled a.
        case a of
          (V,l,[]) => I F
        | (V,[],s::m) => I T
        | (V,r::l',s::m) => I (V r s ∨ (r = s) ∧ listorder_tupled (V,l',m)))
</pre>

<DT><span class="strong">listorder_curried</span>
<DD>
<pre>
|- ∀x x1 x2. listorder x x1 x2 ⇔ listorder_tupled (x,x1,x2)
</pre>

<DT><span class="strong">ListOrd</span>
<DD>
<pre>
|- ∀c.
     ListOrd c =
     TO_of_LinearOrder (listorder (StrongLinearOrder_of_TO (apto c)))
</pre>

<DT><span class="strong">listoto</span>
<DD>
<pre>
|- ∀c. listoto c = TO (ListOrd c)
</pre>

<DT><span class="strong">stringto</span>
<DD>
<pre>
|- stringto = listoto charto
</pre>

<DT><span class="strong">imageOrd</span>
<DD>
<pre>
|- ∀f cp a b. imageOrd f cp a b = cp (f a) (f b)
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">num2cpn_cpn2num</span>
<DD>
<pre>
|- ∀a. num2cpn (cpn2num a) = a
</pre>

<DT><span class="strong">cpn2num_num2cpn</span>
<DD>
<pre>
|- ∀r. r < 3 ⇔ (cpn2num (num2cpn r) = r)
</pre>

<DT><span class="strong">num2cpn_11</span>
<DD>
<pre>
|- ∀r r'. r < 3 ⇒ r' < 3 ⇒ ((num2cpn r = num2cpn r') ⇔ (r = r'))
</pre>

<DT><span class="strong">cpn2num_11</span>
<DD>
<pre>
|- ∀a a'. (cpn2num a = cpn2num a') ⇔ (a = a')
</pre>

<DT><span class="strong">num2cpn_ONTO</span>
<DD>
<pre>
|- ∀a. ∃r. (a = num2cpn r) ∧ r < 3
</pre>

<DT><span class="strong">cpn2num_ONTO</span>
<DD>
<pre>
|- ∀r. r < 3 ⇔ ∃a. r = cpn2num a
</pre>

<DT><span class="strong">num2cpn_thm</span>
<DD>
<pre>
|- (num2cpn 0 = LESS) ∧ (num2cpn 1 = EQUAL) ∧ (num2cpn 2 = GREATER)
</pre>

<DT><span class="strong">cpn2num_thm</span>
<DD>
<pre>
|- (cpn2num LESS = 0) ∧ (cpn2num EQUAL = 1) ∧ (cpn2num GREATER = 2)
</pre>

<DT><span class="strong">cpn_EQ_cpn</span>
<DD>
<pre>
|- ∀a a'. (a = a') ⇔ (cpn2num a = cpn2num a')
</pre>

<DT><span class="strong">cpn_case_def</span>
<DD>
<pre>
|- (∀v0 v1 v2. (case LESS of LESS => v0 | EQUAL => v1 | GREATER => v2) = v0) ∧
   (∀v0 v1 v2.
      (case EQUAL of LESS => v0 | EQUAL => v1 | GREATER => v2) = v1) ∧
   ∀v0 v1 v2. (case GREATER of LESS => v0 | EQUAL => v1 | GREATER => v2) = v2
</pre>

<DT><span class="strong">datatype_cpn</span>
<DD>
<pre>
|- DATATYPE (cpn LESS EQUAL GREATER)
</pre>

<DT><span class="strong">cpn_distinct</span>
<DD>
<pre>
|- LESS ≠ EQUAL ∧ LESS ≠ GREATER ∧ EQUAL ≠ GREATER
</pre>

<DT><span class="strong">cpn_case_cong</span>
<DD>
<pre>
|- ∀M M' v0 v1 v2.
     (M = M') ∧ ((M' = LESS) ⇒ (v0 = v0')) ∧ ((M' = EQUAL) ⇒ (v1 = v1')) ∧
     ((M' = GREATER) ⇒ (v2 = v2')) ⇒
     ((case M of LESS => v0 | EQUAL => v1 | GREATER => v2) =
      case M' of LESS => v0' | EQUAL => v1' | GREATER => v2')
</pre>

<DT><span class="strong">cpn_nchotomy</span>
<DD>
<pre>
|- ∀a. (a = LESS) ∨ (a = EQUAL) ∨ (a = GREATER)
</pre>

<DT><span class="strong">cpn_Axiom</span>
<DD>
<pre>
|- ∀x0 x1 x2. ∃f. (f LESS = x0) ∧ (f EQUAL = x1) ∧ (f GREATER = x2)
</pre>

<DT><span class="strong">cpn_induction</span>
<DD>
<pre>
|- ∀P. P EQUAL ∧ P GREATER ∧ P LESS ⇒ ∀a. P a
</pre>

<DT><span class="strong">all_cpn_distinct</span>
<DD>
<pre>
|- (LESS ≠ EQUAL ∧ LESS ≠ GREATER ∧ EQUAL ≠ GREATER) ∧ EQUAL ≠ LESS ∧
   GREATER ≠ LESS ∧ GREATER ≠ EQUAL
</pre>

<DT><span class="strong">TO_apto_ID</span>
<DD>
<pre>
|- ∀a. TO (apto a) = a
</pre>

<DT><span class="strong">TO_apto_TO_ID</span>
<DD>
<pre>
|- ∀r. TotOrd r ⇔ (apto (TO r) = r)
</pre>

<DT><span class="strong">TO_11</span>
<DD>
<pre>
|- ∀r r'. TotOrd r ⇒ TotOrd r' ⇒ ((TO r = TO r') ⇔ (r = r'))
</pre>

<DT><span class="strong">onto_apto</span>
<DD>
<pre>
|- ∀r. TotOrd r ⇔ ∃a. r = apto a
</pre>

<DT><span class="strong">TO_onto</span>
<DD>
<pre>
|- ∀a. ∃r. (a = TO r) ∧ TotOrd r
</pre>

<DT><span class="strong">TotOrd_apto</span>
<DD>
<pre>
|- ∀c. TotOrd (apto c)
</pre>

<DT><span class="strong">TO_apto_TO_IMP</span>
<DD>
<pre>
|- ∀r. TotOrd r ⇒ (apto (TO r) = r)
</pre>

<DT><span class="strong">toto_equal_eq</span>
<DD>
<pre>
|- ∀c x y. (apto c x y = EQUAL) ⇔ (x = y)
</pre>

<DT><span class="strong">toto_equal_imp_eq</span>
<DD>
<pre>
|- ∀c x y. (apto c x y = EQUAL) ⇒ (x = y)
</pre>

<DT><span class="strong">TO_refl</span>
<DD>
<pre>
|- ∀c. TotOrd c ⇒ ∀x. c x x = EQUAL
</pre>

<DT><span class="strong">toto_refl</span>
<DD>
<pre>
|- ∀c x. apto c x x = EQUAL
</pre>

<DT><span class="strong">toto_equal_sym</span>
<DD>
<pre>
|- ∀c x y. (apto c x y = EQUAL) ⇔ (apto c y x = EQUAL)
</pre>

<DT><span class="strong">toto_antisym</span>
<DD>
<pre>
|- ∀c x y. (apto c x y = GREATER) ⇔ (apto c y x = LESS)
</pre>

<DT><span class="strong">toto_not_less_refl</span>
<DD>
<pre>
|- ∀cmp h. (apto cmp h h = LESS) ⇔ F
</pre>

<DT><span class="strong">toto_swap_cases</span>
<DD>
<pre>
|- ∀c x y.
     apto c y x =
     case apto c x y of LESS => GREATER | EQUAL => EQUAL | GREATER => LESS
</pre>

<DT><span class="strong">toto_glneq</span>
<DD>
<pre>
|- (∀c x y. (apto c x y = LESS) ⇒ x ≠ y) ∧
   ∀c x y. (apto c x y = GREATER) ⇒ x ≠ y
</pre>

<DT><span class="strong">toto_cpn_eqn</span>
<DD>
<pre>
|- (∀c x y. (apto c x y = EQUAL) ⇒ (x = y)) ∧
   (∀c x y. (apto c x y = LESS) ⇒ x ≠ y) ∧
   ∀c x y. (apto c x y = GREATER) ⇒ x ≠ y
</pre>

<DT><span class="strong">NOT_EQ_LESS_IMP</span>
<DD>
<pre>
|- ∀cmp x y. apto cmp x y ≠ LESS ⇒ (x = y) ∨ (apto cmp y x = LESS)
</pre>

<DT><span class="strong">totoEEtrans</span>
<DD>
<pre>
|- ∀c x y z.
     ((apto c x y = EQUAL) ∧ (apto c y z = EQUAL) ⇒ (apto c x z = EQUAL)) ∧
     ((apto c x y = EQUAL) ∧ (apto c z y = EQUAL) ⇒ (apto c x z = EQUAL))
</pre>

<DT><span class="strong">totoLLtrans</span>
<DD>
<pre>
|- ∀c x y z. (apto c x y = LESS) ∧ (apto c y z = LESS) ⇒ (apto c x z = LESS)
</pre>

<DT><span class="strong">totoLGtrans</span>
<DD>
<pre>
|- ∀c x y z.
     (apto c x y = LESS) ∧ (apto c z y = GREATER) ⇒ (apto c x z = LESS)
</pre>

<DT><span class="strong">totoGGtrans</span>
<DD>
<pre>
|- ∀c x y z.
     (apto c y x = GREATER) ∧ (apto c z y = GREATER) ⇒ (apto c x z = LESS)
</pre>

<DT><span class="strong">totoGLtrans</span>
<DD>
<pre>
|- ∀c x y z.
     (apto c y x = GREATER) ∧ (apto c y z = LESS) ⇒ (apto c x z = LESS)
</pre>

<DT><span class="strong">totoLEtrans</span>
<DD>
<pre>
|- ∀c x y z. (apto c x y = LESS) ∧ (apto c y z = EQUAL) ⇒ (apto c x z = LESS)
</pre>

<DT><span class="strong">totoELtrans</span>
<DD>
<pre>
|- ∀c x y z. (apto c x y = EQUAL) ∧ (apto c y z = LESS) ⇒ (apto c x z = LESS)
</pre>

<DT><span class="strong">toto_trans_less</span>
<DD>
<pre>
|- (∀c x y z.
      (apto c x y = LESS) ∧ (apto c y z = LESS) ⇒ (apto c x z = LESS)) ∧
   (∀c x y z.
      (apto c x y = LESS) ∧ (apto c z y = GREATER) ⇒ (apto c x z = LESS)) ∧
   (∀c x y z.
      (apto c y x = GREATER) ∧ (apto c z y = GREATER) ⇒ (apto c x z = LESS)) ∧
   (∀c x y z.
      (apto c y x = GREATER) ∧ (apto c y z = LESS) ⇒ (apto c x z = LESS)) ∧
   (∀c x y z.
      (apto c x y = LESS) ∧ (apto c y z = EQUAL) ⇒ (apto c x z = LESS)) ∧
   ∀c x y z. (apto c x y = EQUAL) ∧ (apto c y z = LESS) ⇒ (apto c x z = LESS)
</pre>

<DT><span class="strong">TotOrd_TO_of_Strong</span>
<DD>
<pre>
|- ∀r. StrongLinearOrder r ⇒ TotOrd (TO_of_LinearOrder r)
</pre>

<DT><span class="strong">toto_equal_imp</span>
<DD>
<pre>
|- ∀cmp phi.
     LinearOrder phi ∧ (cmp = toto_of_LinearOrder phi) ⇒
     ∀x y. ((x = y) ⇔ T) ⇒ (apto cmp x y = EQUAL)
</pre>

<DT><span class="strong">toto_unequal_imp</span>
<DD>
<pre>
|- ∀cmp phi.
     LinearOrder phi ∧ (cmp = toto_of_LinearOrder phi) ⇒
     ∀x y.
       ((x = y) ⇔ F) ⇒
       if phi x y then apto cmp x y = LESS else apto cmp x y = GREATER
</pre>

<DT><span class="strong">StrongOrder_ALT</span>
<DD>
<pre>
|- ∀Z. StrongOrder Z ⇔ irreflexive Z ∧ transitive Z
</pre>

<DT><span class="strong">aplextoto</span>
<DD>
<pre>
|- ∀c v x1 x2 y1 y2.
     apto (c lextoto v) (x1,x2) (y1,y2) =
     case apto c x1 y1 of
       LESS => LESS
     | EQUAL => apto v x2 y2
     | GREATER => GREATER
</pre>

<DT><span class="strong">TO_numOrd</span>
<DD>
<pre>
|- TotOrd numOrd
</pre>

<DT><span class="strong">apnumto_thm</span>
<DD>
<pre>
|- apto numto = numOrd
</pre>

<DT><span class="strong">numeralOrd</span>
<DD>
<pre>
|- ∀x y.
     (numOrd ZERO ZERO = EQUAL) ∧ (numOrd ZERO (BIT1 y) = LESS) ∧
     (numOrd ZERO (BIT2 y) = LESS) ∧ (numOrd (BIT1 x) ZERO = GREATER) ∧
     (numOrd (BIT2 x) ZERO = GREATER) ∧
     (numOrd (BIT1 x) (BIT1 y) = numOrd x y) ∧
     (numOrd (BIT2 x) (BIT2 y) = numOrd x y) ∧
     (numOrd (BIT1 x) (BIT2 y) =
      case numOrd x y of GREATER => GREATER | _ => LESS) ∧
     (numOrd (BIT2 x) (BIT1 y) =
      case numOrd x y of LESS => LESS | _ => GREATER)
</pre>

<DT><span class="strong">datatype_num_dt</span>
<DD>
<pre>
|- DATATYPE (num_dt zer bit1 bit2)
</pre>

<DT><span class="strong">num_dt_11</span>
<DD>
<pre>
|- (∀a a'. (bit1 a = bit1 a') ⇔ (a = a')) ∧
   ∀a a'. (bit2 a = bit2 a') ⇔ (a = a')
</pre>

<DT><span class="strong">num_dt_distinct</span>
<DD>
<pre>
|- (∀a. zer ≠ bit1 a) ∧ (∀a. zer ≠ bit2 a) ∧ ∀a' a. bit1 a ≠ bit2 a'
</pre>

<DT><span class="strong">num_dt_case_cong</span>
<DD>
<pre>
|- ∀M M' v f f1.
     (M = M') ∧ ((M' = zer) ⇒ (v = v')) ∧ (∀a. (M' = bit1 a) ⇒ (f a = f' a)) ∧
     (∀a. (M' = bit2 a) ⇒ (f1 a = f1' a)) ⇒
     (num_dt_CASE M v f f1 = num_dt_CASE M' v' f' f1')
</pre>

<DT><span class="strong">num_dt_nchotomy</span>
<DD>
<pre>
|- ∀nn. (nn = zer) ∨ (∃n. nn = bit1 n) ∨ ∃n. nn = bit2 n
</pre>

<DT><span class="strong">num_dt_Axiom</span>
<DD>
<pre>
|- ∀f0 f1 f2.
     ∃fn.
       (fn zer = f0) ∧ (∀a. fn (bit1 a) = f1 a (fn a)) ∧
       ∀a. fn (bit2 a) = f2 a (fn a)
</pre>

<DT><span class="strong">num_dt_induction</span>
<DD>
<pre>
|- ∀P. P zer ∧ (∀n. P n ⇒ P (bit1 n)) ∧ (∀n. P n ⇒ P (bit2 n)) ⇒ ∀n. P n
</pre>

<DT><span class="strong">num_dtOrd_ind</span>
<DD>
<pre>
|- ∀P.
     P zer zer ∧ (∀x. P zer (bit1 x)) ∧ (∀x. P zer (bit2 x)) ∧
     (∀x. P (bit1 x) zer) ∧ (∀x. P (bit2 x) zer) ∧
     (∀x y. P (bit1 x) (bit2 y)) ∧ (∀x y. P (bit2 x) (bit1 y)) ∧
     (∀x y. P x y ⇒ P (bit1 x) (bit1 y)) ∧
     (∀x y. P x y ⇒ P (bit2 x) (bit2 y)) ⇒
     ∀v v1. P v v1
</pre>

<DT><span class="strong">num_dtOrd</span>
<DD>
<pre>
|- (num_dtOrd zer zer = EQUAL) ∧ (∀x. num_dtOrd zer (bit1 x) = LESS) ∧
   (∀x. num_dtOrd zer (bit2 x) = LESS) ∧
   (∀x. num_dtOrd (bit1 x) zer = GREATER) ∧
   (∀x. num_dtOrd (bit2 x) zer = GREATER) ∧
   (∀y x. num_dtOrd (bit1 x) (bit2 y) = LESS) ∧
   (∀y x. num_dtOrd (bit2 x) (bit1 y) = GREATER) ∧
   (∀y x. num_dtOrd (bit1 x) (bit1 y) = num_dtOrd x y) ∧
   ∀y x. num_dtOrd (bit2 x) (bit2 y) = num_dtOrd x y
</pre>

<DT><span class="strong">TO_qk_numOrd</span>
<DD>
<pre>
|- TotOrd qk_numOrd
</pre>

<DT><span class="strong">qk_numeralOrd</span>
<DD>
<pre>
|- ∀x y.
     (qk_numOrd ZERO ZERO = EQUAL) ∧ (qk_numOrd ZERO (BIT1 y) = LESS) ∧
     (qk_numOrd ZERO (BIT2 y) = LESS) ∧ (qk_numOrd (BIT1 x) ZERO = GREATER) ∧
     (qk_numOrd (BIT2 x) ZERO = GREATER) ∧
     (qk_numOrd (BIT1 x) (BIT1 y) = qk_numOrd x y) ∧
     (qk_numOrd (BIT2 x) (BIT2 y) = qk_numOrd x y) ∧
     (qk_numOrd (BIT1 x) (BIT2 y) = LESS) ∧
     (qk_numOrd (BIT2 x) (BIT1 y) = GREATER)
</pre>

<DT><span class="strong">ap_qk_numto_thm</span>
<DD>
<pre>
|- apto qk_numto = qk_numOrd
</pre>

<DT><span class="strong">apcharto_thm</span>
<DD>
<pre>
|- apto charto = charOrd
</pre>

<DT><span class="strong">charOrd_lt_lem</span>
<DD>
<pre>
|- ∀a b.
     (numOrd a b = LESS) ⇒ (b < 256 ⇔ T) ⇒ (charOrd (CHR a) (CHR b) = LESS)
</pre>

<DT><span class="strong">charOrd_gt_lem</span>
<DD>
<pre>
|- ∀a b.
     (numOrd a b = GREATER) ⇒
     (a < 256 ⇔ T) ⇒
     (charOrd (CHR a) (CHR b) = GREATER)
</pre>

<DT><span class="strong">charOrd_eq_lem</span>
<DD>
<pre>
|- ∀a b. (numOrd a b = EQUAL) ⇒ (charOrd (CHR a) (CHR b) = EQUAL)
</pre>

<DT><span class="strong">listorder_ind</span>
<DD>
<pre>
|- ∀P.
     (∀V l. P V l []) ∧ (∀V s m. P V [] (s::m)) ∧
     (∀V r l s m. P V l m ⇒ P V (r::l) (s::m)) ⇒
     ∀v v1 v2. P v v1 v2
</pre>

<DT><span class="strong">listorder</span>
<DD>
<pre>
|- (∀l V. listorder V l [] ⇔ F) ∧ (∀s m V. listorder V [] (s::m) ⇔ T) ∧
   ∀s r m l V. listorder V (r::l) (s::m) ⇔ V r s ∨ (r = s) ∧ listorder V l m
</pre>

<DT><span class="strong">aplistoto</span>
<DD>
<pre>
|- ∀c.
     (apto (listoto c) [] [] = EQUAL) ∧
     (∀b y. apto (listoto c) [] (b::y) = LESS) ∧
     (∀a x. apto (listoto c) (a::x) [] = GREATER) ∧
     ∀a x b y.
       apto (listoto c) (a::x) (b::y) =
       case apto c a b of
         LESS => LESS
       | EQUAL => apto (listoto c) x y
       | GREATER => GREATER
</pre>

</DL>



<hr>
</body>
</html>
