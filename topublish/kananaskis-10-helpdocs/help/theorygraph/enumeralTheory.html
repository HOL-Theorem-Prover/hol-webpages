<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: enumeral</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "enumeral"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "totoTheory.html"><span class="strong">toto</span></a>&nbsp;&nbsp;
    <a href = "res_quanTheory.html"><span class="strong">res_quan</span></a>

<h1>Signature</h1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr> <th> Type <th> Arity<tr><td> <span class="strong">bl</span> <td> 1
    <tr><td> <span class="strong">bt</span> <td> 1
    <tr>
    <th>
    Constant
    <th>
    Type<tr><td>
            <span class="strong">BL_ACCUM</span>
            <td>
            :α -> α bt -> α bl -> α bl
    <tr><td> <span class="strong">BL_CONS</span> <td> :α -> α bl -> α bl
    <tr><td>
        <span class="strong">ENUMERAL</span>
        <td>
        :α toto -> α bt -> α -> bool
    <tr><td> <span class="strong">K2</span> <td> :α -> num
    <tr><td>
        <span class="strong">LESS_ALL</span>
        <td>
        :α toto -> α -> (α -> bool) -> bool
    <tr><td> <span class="strong">OL</span> <td> :α toto -> α list -> bool
    <tr><td> <span class="strong">OL_bt</span> <td> :α toto -> α bt -> bool
    <tr><td>
        <span class="strong">OL_bt_lb</span>
        <td>
        :α toto -> α -> α bt -> bool
    <tr><td>
        <span class="strong">OL_bt_lb_ub</span>
        <td>
        :α toto -> α -> α bt -> α -> bool
    <tr><td>
        <span class="strong">OL_bt_ub</span>
        <td>
        :α toto -> α bt -> α -> bool
    <tr><td>
        <span class="strong">OL_sublists</span>
        <td>
        :α toto -> α list option list -> bool
    <tr><td>
        <span class="strong">OL_sublists_tupled</span>
        <td>
        :α toto # α list option list -> bool
    <tr><td>
        <span class="strong">OU</span>
        <td>
        :α toto -> (α -> bool) -> (α -> bool) -> α -> bool
    <tr><td>
        <span class="strong">OWL</span>
        <td>
        :α toto -> (α -> bool) -> α list -> bool
    <tr><td>
        <span class="strong">UO</span>
        <td>
        :α toto -> (α -> bool) -> (α -> bool) -> α -> bool
    <tr><td>
        <span class="strong">bl_CASE</span>
        <td>
        :α bl -> β -> (α bl -> β) -> (α -> α bt -> α bl -> β) -> β
    <tr><td> <span class="strong">bl_rev</span> <td> :α bt -> α bl -> α bt
    <tr><td>
        <span class="strong">bl_size</span>
        <td>
        :(α -> num) -> α bl -> num
    <tr><td> <span class="strong">bl_to_bt</span> <td> :α bl -> α bt
    <tr><td>
        <span class="strong">bl_to_set</span>
        <td>
        :α toto -> α bl -> α -> bool
    <tr><td>
        <span class="strong">bt_CASE</span>
        <td>
        :α bt -> β -> (α bt -> α -> α bt -> β) -> β
    <tr><td> <span class="strong">bt_rev</span> <td> :α bt -> α bl -> α bl
    <tr><td>
        <span class="strong">bt_size</span>
        <td>
        :(α -> num) -> α bt -> num
    <tr><td> <span class="strong">bt_to_bl</span> <td> :α bt -> α bl
    <tr><td> <span class="strong">bt_to_list</span> <td> :α bt -> α list
    <tr><td>
        <span class="strong">bt_to_list_ac</span>
        <td>
        :α bt -> α list -> α list
    <tr><td>
        <span class="strong">bt_to_ol</span>
        <td>
        :α toto -> α bt -> α list
    <tr><td>
        <span class="strong">bt_to_ol_ac</span>
        <td>
        :α toto -> α bt -> α list -> α list
    <tr><td>
        <span class="strong">bt_to_ol_lb</span>
        <td>
        :α toto -> α -> α bt -> α list
    <tr><td>
        <span class="strong">bt_to_ol_lb_ac</span>
        <td>
        :α toto -> α -> α bt -> α list -> α list
    <tr><td>
        <span class="strong">bt_to_ol_lb_ub</span>
        <td>
        :α toto -> α -> α bt -> α -> α list
    <tr><td>
        <span class="strong">bt_to_ol_lb_ub_ac</span>
        <td>
        :α toto -> α -> α bt -> α -> α list -> α list
    <tr><td>
        <span class="strong">bt_to_ol_ub</span>
        <td>
        :α toto -> α bt -> α -> α list
    <tr><td>
        <span class="strong">bt_to_ol_ub_ac</span>
        <td>
        :α toto -> α bt -> α -> α list -> α list
    <tr><td>
        <span class="strong">bt_to_set_lb</span>
        <td>
        :α toto -> α -> α bt -> α -> bool
    <tr><td>
        <span class="strong">bt_to_set_lb_ub</span>
        <td>
        :α toto -> α -> α bt -> α reln
    <tr><td>
        <span class="strong">bt_to_set_ub</span>
        <td>
        :α toto -> α bt -> α reln
    <tr><td>
        <span class="strong">incr_sbuild</span>
        <td>
        :α toto -> α list -> α list option list
    <tr><td>
        <span class="strong">incr_smerge</span>
        <td>
        :α toto -> α list -> α list option list -> α list option list
    <tr><td>
        <span class="strong">incr_smerge_tupled</span>
        <td>
        :α toto # α list # α list option list -> α list option list
    <tr><td>
        <span class="strong">incr_ssort</span>
        <td>
        :α toto -> α list -> α list
    <tr><td> <span class="strong">list_to_bl</span> <td> :α list -> α bl
    <tr><td> <span class="strong">list_to_bt</span> <td> :γ list -> γ bt
    <tr><td>
        <span class="strong">lol_set</span>
        <td>
        :α list option list -> α -> bool
    <tr><td> <span class="strong">nbl</span> <td> :α bl
    <tr><td> <span class="strong">node</span> <td> :α bt -> α -> α bt -> α bt
    <tr><td> <span class="strong">nt</span> <td> :α bt
    <tr><td> <span class="strong">onebl</span> <td> :α -> α bt -> α bl -> α bl
    <tr><td>
        <span class="strong">sdiff</span>
        <td>
        :α toto -> α list -> α list -> α list
    <tr><td>
        <span class="strong">sdiff_tupled</span>
        <td>
        :α toto # α list # α list -> α list
    <tr><td>
        <span class="strong">sinter</span>
        <td>
        :α toto -> α list -> α list -> α list
    <tr><td>
        <span class="strong">sinter_tupled</span>
        <td>
        :α toto # α list # α list -> α list
    <tr><td>
        <span class="strong">smerge</span>
        <td>
        :α toto -> α list -> α list -> α list
    <tr><td>
        <span class="strong">smerge_out</span>
        <td>
        :α toto -> α list -> α list option list -> α list
    <tr><td>
        <span class="strong">smerge_out_tupled</span>
        <td>
        :α toto # α list # α list option list -> α list
    <tr><td>
        <span class="strong">smerge_tupled</span>
        <td>
        :α toto # α list # α list -> α list
    <tr><td> <span class="strong">zerbl</span> <td> :α bl -> α bl

</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">bl_TY_DEF</span>
<DD>
<pre>
|- ∃rep.
     TYPE_DEFINITION
       (λa0'.
          ∀'bl' .
            (∀a0'.
               (a0' = ind_type$CONSTR 0 (ARB,ARB) (λn. ind_type$BOTTOM)) ∨
               (∃a.
                  (a0' =
                   (λa.
                      ind_type$CONSTR (SUC 0) (ARB,ARB)
                        (ind_type$FCONS a (λn. ind_type$BOTTOM))) a) ∧
                  'bl' a) ∨
               (∃a0 a1 a2.
                  (a0' =
                   (λa0 a1 a2.
                      ind_type$CONSTR (SUC (SUC 0)) (a0,a1)
                        (ind_type$FCONS a2 (λn. ind_type$BOTTOM))) a0 a1 a2) ∧
                  'bl' a2) ⇒
               'bl' a0') ⇒
            'bl' a0') rep
</pre>

<DT><span class="strong">bl_case_def</span>
<DD>
<pre>
|- (∀v f f1. bl_CASE nbl v f f1 = v) ∧
   (∀a v f f1. bl_CASE (zerbl a) v f f1 = f a) ∧
   ∀a0 a1 a2 v f f1. bl_CASE (onebl a0 a1 a2) v f f1 = f1 a0 a1 a2
</pre>

<DT><span class="strong">bl_size_def</span>
<DD>
<pre>
|- (∀f. bl_size f nbl = 0) ∧ (∀f a. bl_size f (zerbl a) = 1 + bl_size f a) ∧
   ∀f a0 a1 a2.
     bl_size f (onebl a0 a1 a2) = 1 + (f a0 + (bt_size f a1 + bl_size f a2))
</pre>

<DT><span class="strong">bt_TY_DEF</span>
<DD>
<pre>
|- ∃rep.
     TYPE_DEFINITION
       (λa0'.
          ∀'bt' .
            (∀a0'.
               (a0' = ind_type$CONSTR 0 ARB (λn. ind_type$BOTTOM)) ∨
               (∃a0 a1 a2.
                  (a0' =
                   (λa0 a1 a2.
                      ind_type$CONSTR (SUC 0) a1
                        (ind_type$FCONS a0
                           (ind_type$FCONS a2 (λn. ind_type$BOTTOM)))) a0 a1
                     a2) ∧ 'bt' a0 ∧ 'bt' a2) ⇒
               'bt' a0') ⇒
            'bt' a0') rep
</pre>

<DT><span class="strong">bt_size_def</span>
<DD>
<pre>
|- (∀f. bt_size f nt = 0) ∧
   ∀f a0 a1 a2.
     bt_size f (node a0 a1 a2) = 1 + (bt_size f a0 + (f a1 + bt_size f a2))
</pre>

<DT><span class="strong">BL_ACCUM</span>
<DD>
<pre>
|- (∀a ac. BL_ACCUM a ac nbl = onebl a ac nbl) ∧
   (∀a ac bl. BL_ACCUM a ac (zerbl bl) = onebl a ac bl) ∧
   ∀a ac r rft bl.
     BL_ACCUM a ac (onebl r rft bl) = zerbl (BL_ACCUM a (node ac r rft) bl)
</pre>

<DT><span class="strong">BL_CONS</span>
<DD>
<pre>
|- ∀a bl. BL_CONS a bl = BL_ACCUM a nt bl
</pre>

<DT><span class="strong">list_to_bl</span>
<DD>
<pre>
|- (list_to_bl [] = nbl) ∧ ∀a l. list_to_bl (a::l) = BL_CONS a (list_to_bl l)
</pre>

<DT><span class="strong">bt_to_list</span>
<DD>
<pre>
|- (bt_to_list nt = []) ∧
   ∀l x r. bt_to_list (node l x r) = bt_to_list l ++ [x] ++ bt_to_list r
</pre>

<DT><span class="strong">bt_to_list_ac</span>
<DD>
<pre>
|- (∀m. bt_to_list_ac nt m = m) ∧
   ∀l x r m.
     bt_to_list_ac (node l x r) m = bt_to_list_ac l (x::bt_to_list_ac r m)
</pre>

<DT><span class="strong">bt_rev</span>
<DD>
<pre>
|- (∀bl. bt_rev nt bl = bl) ∧
   ∀lft r rft bl. bt_rev (node lft r rft) bl = bt_rev lft (onebl r rft bl)
</pre>

<DT><span class="strong">K2</span>
<DD>
<pre>
|- ∀a. K2 a = 2
</pre>

<DT><span class="strong">bl_rev</span>
<DD>
<pre>
|- (∀ft. bl_rev ft nbl = ft) ∧ (∀ft b. bl_rev ft (zerbl b) = bl_rev ft b) ∧
   ∀ft a f b. bl_rev ft (onebl a f b) = bl_rev (node ft a f) b
</pre>

<DT><span class="strong">bl_to_bt</span>
<DD>
<pre>
|- bl_to_bt = bl_rev nt
</pre>

<DT><span class="strong">bt_to_bl</span>
<DD>
<pre>
|- ∀t. bt_to_bl t = bt_rev t nbl
</pre>

<DT><span class="strong">list_to_bt</span>
<DD>
<pre>
|- ∀l. list_to_bt l = bl_to_bt (list_to_bl l)
</pre>

<DT><span class="strong">OL</span>
<DD>
<pre>
|- (∀cmp. OL cmp [] ⇔ T) ∧
   ∀cmp a l. OL cmp (a::l) ⇔ OL cmp l ∧ ∀p. MEM p l ⇒ (apto cmp a p = LESS)
</pre>

<DT><span class="strong">smerge_tupled_primitive</span>
<DD>
<pre>
|- smerge_tupled =
   WFREC
     (@R.
        WF R ∧
        (∀m l y x cmp. (apto cmp x y = EQUAL) ⇒ R (cmp,l,m) (cmp,x::l,y::m)) ∧
        (∀m l y x cmp.
           (apto cmp x y = GREATER) ⇒ R (cmp,x::l,m) (cmp,x::l,y::m)) ∧
        ∀m l y x cmp. (apto cmp x y = LESS) ⇒ R (cmp,l,y::m) (cmp,x::l,y::m))
     (λsmerge_tupled a.
        case a of
          (cmp,[],[]) => I []
        | (cmp,[],y::m) => I (y::m)
        | (cmp,x::l,[]) => I (x::l)
        | (cmp,x::l,y'::m') =>
            I
              (case apto cmp x y' of
                 LESS => x::smerge_tupled (cmp,l,y'::m')
               | EQUAL => x::smerge_tupled (cmp,l,m')
               | GREATER => y'::smerge_tupled (cmp,x::l,m')))
</pre>

<DT><span class="strong">smerge_curried</span>
<DD>
<pre>
|- ∀x x1 x2. smerge x x1 x2 = smerge_tupled (x,x1,x2)
</pre>

<DT><span class="strong">OL_sublists_tupled_primitive</span>
<DD>
<pre>
|- OL_sublists_tupled =
   WFREC
     (@R.
        WF R ∧ (∀lol cmp. R (cmp,lol) (cmp,NONE::lol)) ∧
        ∀m lol cmp. R (cmp,lol) (cmp,SOME m::lol))
     (λOL_sublists_tupled a.
        case a of
          (cmp,[]) => I T
        | (cmp,NONE::lol) => I (OL_sublists_tupled (cmp,lol))
        | (cmp,SOME m::lol) => I (OL cmp m ∧ OL_sublists_tupled (cmp,lol)))
</pre>

<DT><span class="strong">OL_sublists_curried</span>
<DD>
<pre>
|- ∀x x1. OL_sublists x x1 ⇔ OL_sublists_tupled (x,x1)
</pre>

<DT><span class="strong">lol_set_primitive</span>
<DD>
<pre>
|- lol_set =
   WFREC (@R. WF R ∧ (∀lol. R lol (NONE::lol)) ∧ ∀m lol. R lol (SOME m::lol))
     (λlol_set a.
        case a of
          [] => I ∅
        | NONE::lol => I (lol_set lol)
        | SOME m::lol => I (LIST_TO_SET m ∪ lol_set lol))
</pre>

<DT><span class="strong">incr_smerge_tupled_primitive</span>
<DD>
<pre>
|- incr_smerge_tupled =
   WFREC
     (@R. WF R ∧ ∀lol m l cmp. R (cmp,smerge cmp l m,lol) (cmp,l,SOME m::lol))
     (λincr_smerge_tupled a.
        case a of
          (cmp,l,[]) => I [SOME l]
        | (cmp,l,NONE::lol) => I (SOME l::lol)
        | (cmp,l,SOME m::lol) =>
            I (NONE::incr_smerge_tupled (cmp,smerge cmp l m,lol)))
</pre>

<DT><span class="strong">incr_smerge_curried</span>
<DD>
<pre>
|- ∀x x1 x2. incr_smerge x x1 x2 = incr_smerge_tupled (x,x1,x2)
</pre>

<DT><span class="strong">smerge_out_tupled_primitive</span>
<DD>
<pre>
|- smerge_out_tupled =
   WFREC
     (@R.
        WF R ∧ (∀lol l cmp. R (cmp,l,lol) (cmp,l,NONE::lol)) ∧
        ∀lol m l cmp. R (cmp,smerge cmp l m,lol) (cmp,l,SOME m::lol))
     (λsmerge_out_tupled a.
        case a of
          (cmp,l,[]) => I l
        | (cmp,l,NONE::lol) => I (smerge_out_tupled (cmp,l,lol))
        | (cmp,l,SOME m::lol) =>
            I (smerge_out_tupled (cmp,smerge cmp l m,lol)))
</pre>

<DT><span class="strong">smerge_out_curried</span>
<DD>
<pre>
|- ∀x x1 x2. smerge_out x x1 x2 = smerge_out_tupled (x,x1,x2)
</pre>

<DT><span class="strong">incr_sbuild</span>
<DD>
<pre>
|- (∀cmp. incr_sbuild cmp [] = []) ∧
   ∀cmp x l. incr_sbuild cmp (x::l) = incr_smerge cmp [x] (incr_sbuild cmp l)
</pre>

<DT><span class="strong">incr_ssort</span>
<DD>
<pre>
|- ∀cmp l. incr_ssort cmp l = smerge_out cmp [] (incr_sbuild cmp l)
</pre>

<DT><span class="strong">bt_to_set</span>
<DD>
<pre>
|- (∀cmp. ENUMERAL cmp nt = ∅) ∧
   ∀cmp l x r.
     ENUMERAL cmp (node l x r) =
     {y | y ∈ ENUMERAL cmp l ∧ (apto cmp y x = LESS)} ∪ {x} ∪
     {z | z ∈ ENUMERAL cmp r ∧ (apto cmp x z = LESS)}
</pre>

<DT><span class="strong">bt_to_set_lb</span>
<DD>
<pre>
|- ∀cmp lb t.
     bt_to_set_lb cmp lb t = {x | x ∈ ENUMERAL cmp t ∧ (apto cmp lb x = LESS)}
</pre>

<DT><span class="strong">bt_to_set_ub</span>
<DD>
<pre>
|- ∀cmp t ub.
     bt_to_set_ub cmp t ub = {x | x ∈ ENUMERAL cmp t ∧ (apto cmp x ub = LESS)}
</pre>

<DT><span class="strong">bt_to_set_lb_ub</span>
<DD>
<pre>
|- ∀cmp lb t ub.
     bt_to_set_lb_ub cmp lb t ub =
     {x |
      x ∈ ENUMERAL cmp t ∧ (apto cmp lb x = LESS) ∧ (apto cmp x ub = LESS)}
</pre>

<DT><span class="strong">bt_to_ol_lb_ub</span>
<DD>
<pre>
|- (∀cmp lb ub. bt_to_ol_lb_ub cmp lb nt ub = []) ∧
   ∀cmp lb l x r ub.
     bt_to_ol_lb_ub cmp lb (node l x r) ub =
     if apto cmp lb x = LESS then
       if apto cmp x ub = LESS then
         bt_to_ol_lb_ub cmp lb l x ++ [x] ++ bt_to_ol_lb_ub cmp x r ub
       else bt_to_ol_lb_ub cmp lb l ub
     else bt_to_ol_lb_ub cmp lb r ub
</pre>

<DT><span class="strong">bt_to_ol_lb</span>
<DD>
<pre>
|- (∀cmp lb. bt_to_ol_lb cmp lb nt = []) ∧
   ∀cmp lb l x r.
     bt_to_ol_lb cmp lb (node l x r) =
     if apto cmp lb x = LESS then
       bt_to_ol_lb_ub cmp lb l x ++ [x] ++ bt_to_ol_lb cmp x r
     else bt_to_ol_lb cmp lb r
</pre>

<DT><span class="strong">bt_to_ol_ub</span>
<DD>
<pre>
|- (∀cmp ub. bt_to_ol_ub cmp nt ub = []) ∧
   ∀cmp l x r ub.
     bt_to_ol_ub cmp (node l x r) ub =
     if apto cmp x ub = LESS then
       bt_to_ol_ub cmp l x ++ [x] ++ bt_to_ol_lb_ub cmp x r ub
     else bt_to_ol_ub cmp l ub
</pre>

<DT><span class="strong">bt_to_ol</span>
<DD>
<pre>
|- (∀cmp. bt_to_ol cmp nt = []) ∧
   ∀cmp l x r.
     bt_to_ol cmp (node l x r) =
     bt_to_ol_ub cmp l x ++ [x] ++ bt_to_ol_lb cmp x r
</pre>

<DT><span class="strong">bt_to_ol_lb_ub_ac</span>
<DD>
<pre>
|- (∀cmp lb ub m. bt_to_ol_lb_ub_ac cmp lb nt ub m = m) ∧
   ∀cmp lb l x r ub m.
     bt_to_ol_lb_ub_ac cmp lb (node l x r) ub m =
     if apto cmp lb x = LESS then
       if apto cmp x ub = LESS then
         bt_to_ol_lb_ub_ac cmp lb l x (x::bt_to_ol_lb_ub_ac cmp x r ub m)
       else bt_to_ol_lb_ub_ac cmp lb l ub m
     else bt_to_ol_lb_ub_ac cmp lb r ub m
</pre>

<DT><span class="strong">bt_to_ol_lb_ac</span>
<DD>
<pre>
|- (∀cmp lb m. bt_to_ol_lb_ac cmp lb nt m = m) ∧
   ∀cmp lb l x r m.
     bt_to_ol_lb_ac cmp lb (node l x r) m =
     if apto cmp lb x = LESS then
       bt_to_ol_lb_ub_ac cmp lb l x (x::bt_to_ol_lb_ac cmp x r m)
     else bt_to_ol_lb_ac cmp lb r m
</pre>

<DT><span class="strong">bt_to_ol_ub_ac</span>
<DD>
<pre>
|- (∀cmp ub m. bt_to_ol_ub_ac cmp nt ub m = m) ∧
   ∀cmp l x r ub m.
     bt_to_ol_ub_ac cmp (node l x r) ub m =
     if apto cmp x ub = LESS then
       bt_to_ol_ub_ac cmp l x (x::bt_to_ol_lb_ub_ac cmp x r ub m)
     else bt_to_ol_ub_ac cmp l ub m
</pre>

<DT><span class="strong">bt_to_ol_ac</span>
<DD>
<pre>
|- (∀cmp m. bt_to_ol_ac cmp nt m = m) ∧
   ∀cmp l x r m.
     bt_to_ol_ac cmp (node l x r) m =
     bt_to_ol_ub_ac cmp l x (x::bt_to_ol_lb_ac cmp x r m)
</pre>

<DT><span class="strong">OWL</span>
<DD>
<pre>
|- ∀cmp s l. OWL cmp s l ⇔ (s = LIST_TO_SET l) ∧ OL cmp l
</pre>

<DT><span class="strong">OU</span>
<DD>
<pre>
|- ∀cmp t u. OU cmp t u = {x | x ∈ t ∧ ∀z. z ∈ u ⇒ (apto cmp x z = LESS)} ∪ u
</pre>

<DT><span class="strong">UO</span>
<DD>
<pre>
|- ∀cmp s t. UO cmp s t = s ∪ {y | y ∈ t ∧ ∀z. z ∈ s ⇒ (apto cmp z y = LESS)}
</pre>

<DT><span class="strong">LESS_ALL</span>
<DD>
<pre>
|- ∀cmp x s. LESS_ALL cmp x s ⇔ ∀y. y ∈ s ⇒ (apto cmp x y = LESS)
</pre>

<DT><span class="strong">bl_to_set</span>
<DD>
<pre>
|- (∀cmp. bl_to_set cmp nbl = ∅) ∧
   (∀cmp b. bl_to_set cmp (zerbl b) = bl_to_set cmp b) ∧
   ∀cmp x t b.
     bl_to_set cmp (onebl x t b) =
     OU cmp ({x} ∪ {y | y ∈ ENUMERAL cmp t ∧ (apto cmp x y = LESS)})
       (bl_to_set cmp b)
</pre>

<DT><span class="strong">sinter_tupled_primitive</span>
<DD>
<pre>
|- sinter_tupled =
   WFREC
     (@R.
        WF R ∧
        (∀m l y x cmp. (apto cmp x y = EQUAL) ⇒ R (cmp,l,m) (cmp,x::l,y::m)) ∧
        (∀m l y x cmp.
           (apto cmp x y = GREATER) ⇒ R (cmp,x::l,m) (cmp,x::l,y::m)) ∧
        ∀m l y x cmp. (apto cmp x y = LESS) ⇒ R (cmp,l,y::m) (cmp,x::l,y::m))
     (λsinter_tupled a.
        case a of
          (cmp,x::l,y::m) =>
            I
              (case apto cmp x y of
                 LESS => sinter_tupled (cmp,l,y::m)
               | EQUAL => x::sinter_tupled (cmp,l,m)
               | GREATER => sinter_tupled (cmp,x::l,m))
        | _ => I [])
</pre>

<DT><span class="strong">sinter_curried</span>
<DD>
<pre>
|- ∀x x1 x2. sinter x x1 x2 = sinter_tupled (x,x1,x2)
</pre>

<DT><span class="strong">sdiff_tupled_primitive</span>
<DD>
<pre>
|- sdiff_tupled =
   WFREC
     (@R.
        WF R ∧
        (∀m l y x cmp. (apto cmp x y = EQUAL) ⇒ R (cmp,l,m) (cmp,x::l,y::m)) ∧
        (∀m l y x cmp.
           (apto cmp x y = GREATER) ⇒ R (cmp,x::l,m) (cmp,x::l,y::m)) ∧
        ∀m l y x cmp. (apto cmp x y = LESS) ⇒ R (cmp,l,y::m) (cmp,x::l,y::m))
     (λsdiff_tupled a.
        case a of
          (cmp,[],v3) => I []
        | (cmp,x::l,[]) => I (x::l)
        | (cmp,x::l,y::m) =>
            I
              (case apto cmp x y of
                 LESS => x::sdiff_tupled (cmp,l,y::m)
               | EQUAL => sdiff_tupled (cmp,l,m)
               | GREATER => sdiff_tupled (cmp,x::l,m)))
</pre>

<DT><span class="strong">sdiff_curried</span>
<DD>
<pre>
|- ∀x x1 x2. sdiff x x1 x2 = sdiff_tupled (x,x1,x2)
</pre>

<DT><span class="strong">OL_bt_lb_ub</span>
<DD>
<pre>
|- (∀cmp lb ub. OL_bt_lb_ub cmp lb nt ub ⇔ (apto cmp lb ub = LESS)) ∧
   ∀cmp lb l x r ub.
     OL_bt_lb_ub cmp lb (node l x r) ub ⇔
     OL_bt_lb_ub cmp lb l x ∧ OL_bt_lb_ub cmp x r ub
</pre>

<DT><span class="strong">OL_bt_lb</span>
<DD>
<pre>
|- (∀cmp lb. OL_bt_lb cmp lb nt ⇔ T) ∧
   ∀cmp lb l x r.
     OL_bt_lb cmp lb (node l x r) ⇔ OL_bt_lb_ub cmp lb l x ∧ OL_bt_lb cmp x r
</pre>

<DT><span class="strong">OL_bt_ub</span>
<DD>
<pre>
|- (∀cmp ub. OL_bt_ub cmp nt ub ⇔ T) ∧
   ∀cmp l x r ub.
     OL_bt_ub cmp (node l x r) ub ⇔ OL_bt_ub cmp l x ∧ OL_bt_lb_ub cmp x r ub
</pre>

<DT><span class="strong">OL_bt</span>
<DD>
<pre>
|- (∀cmp. OL_bt cmp nt ⇔ T) ∧
   ∀cmp l x r. OL_bt cmp (node l x r) ⇔ OL_bt_ub cmp l x ∧ OL_bt_lb cmp x r
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">bt_distinct</span>
<DD>
<pre>
|- ∀a2 a1 a0. nt ≠ node a0 a1 a2
</pre>

<DT><span class="strong">bt_case_cong</span>
<DD>
<pre>
|- ∀M M' v f.
     (M = M') ∧ ((M' = nt) ⇒ (v = v')) ∧
     (∀a0 a1 a2. (M' = node a0 a1 a2) ⇒ (f a0 a1 a2 = f' a0 a1 a2)) ⇒
     (bt_CASE M v f = bt_CASE M' v' f')
</pre>

<DT><span class="strong">bt_nchotomy</span>
<DD>
<pre>
|- ∀bb. (bb = nt) ∨ ∃b a b0. bb = node b a b0
</pre>

<DT><span class="strong">bt_Axiom</span>
<DD>
<pre>
|- ∀f0 f1.
     ∃fn.
       (fn nt = f0) ∧
       ∀a0 a1 a2. fn (node a0 a1 a2) = f1 a1 a0 a2 (fn a0) (fn a2)
</pre>

<DT><span class="strong">bt_induction</span>
<DD>
<pre>
|- ∀P. P nt ∧ (∀b b0. P b ∧ P b0 ⇒ ∀a. P (node b a b0)) ⇒ ∀b. P b
</pre>

<DT><span class="strong">datatype_bl</span>
<DD>
<pre>
|- DATATYPE (bl nbl zerbl onebl)
</pre>

<DT><span class="strong">bl_11</span>
<DD>
<pre>
|- (∀a a'. (zerbl a = zerbl a') ⇔ (a = a')) ∧
   ∀a0 a1 a2 a0' a1' a2'.
     (onebl a0 a1 a2 = onebl a0' a1' a2') ⇔
     (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2')
</pre>

<DT><span class="strong">bl_distinct</span>
<DD>
<pre>
|- (∀a. nbl ≠ zerbl a) ∧ (∀a2 a1 a0. nbl ≠ onebl a0 a1 a2) ∧
   ∀a2 a1 a0 a. zerbl a ≠ onebl a0 a1 a2
</pre>

<DT><span class="strong">bl_case_cong</span>
<DD>
<pre>
|- ∀M M' v f f1.
     (M = M') ∧ ((M' = nbl) ⇒ (v = v')) ∧
     (∀a. (M' = zerbl a) ⇒ (f a = f' a)) ∧
     (∀a0 a1 a2. (M' = onebl a0 a1 a2) ⇒ (f1 a0 a1 a2 = f1' a0 a1 a2)) ⇒
     (bl_CASE M v f f1 = bl_CASE M' v' f' f1')
</pre>

<DT><span class="strong">bl_nchotomy</span>
<DD>
<pre>
|- ∀bb. (bb = nbl) ∨ (∃b. bb = zerbl b) ∨ ∃a b0 b. bb = onebl a b0 b
</pre>

<DT><span class="strong">bl_Axiom</span>
<DD>
<pre>
|- ∀f0 f1 f2.
     ∃fn.
       (fn nbl = f0) ∧ (∀a. fn (zerbl a) = f1 a (fn a)) ∧
       ∀a0 a1 a2. fn (onebl a0 a1 a2) = f2 a0 a1 a2 (fn a2)
</pre>

<DT><span class="strong">bl_induction</span>
<DD>
<pre>
|- ∀P.
     P nbl ∧ (∀b. P b ⇒ P (zerbl b)) ∧ (∀b. P b ⇒ ∀b0 a. P (onebl a b0 b)) ⇒
     ∀b. P b
</pre>

<DT><span class="strong">bt_11</span>
<DD>
<pre>
|- ∀a0 a1 a2 a0' a1' a2'.
     (node a0 a1 a2 = node a0' a1' a2') ⇔ (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2')
</pre>

<DT><span class="strong">datatype_bt</span>
<DD>
<pre>
|- DATATYPE (bt nt node)
</pre>

<DT><span class="strong">bt_case_def</span>
<DD>
<pre>
|- (∀v f. bt_CASE nt v f = v) ∧
   ∀a0 a1 a2 v f. bt_CASE (node a0 a1 a2) v f = f a0 a1 a2
</pre>

<DT><span class="strong">bt_to_list_thm</span>
<DD>
<pre>
|- ∀t. bt_to_list t = bt_to_list_ac t []
</pre>

<DT><span class="strong">smerge_ind</span>
<DD>
<pre>
|- ∀P.
     (∀cmp. P cmp [] []) ∧ (∀cmp x l. P cmp (x::l) []) ∧
     (∀cmp y m. P cmp [] (y::m)) ∧
     (∀cmp x l y m.
        ((apto cmp x y = EQUAL) ⇒ P cmp l m) ∧
        ((apto cmp x y = GREATER) ⇒ P cmp (x::l) m) ∧
        ((apto cmp x y = LESS) ⇒ P cmp l (y::m)) ⇒
        P cmp (x::l) (y::m)) ⇒
     ∀v v1 v2. P v v1 v2
</pre>

<DT><span class="strong">smerge</span>
<DD>
<pre>
|- (∀cmp. smerge cmp [] [] = []) ∧ (∀x l cmp. smerge cmp (x::l) [] = x::l) ∧
   (∀y m cmp. smerge cmp [] (y::m) = y::m) ∧
   ∀y x m l cmp.
     smerge cmp (x::l) (y::m) =
     case apto cmp x y of
       LESS => x::smerge cmp l (y::m)
     | EQUAL => x::smerge cmp l m
     | GREATER => y::smerge cmp (x::l) m
</pre>

<DT><span class="strong">smerge_nil</span>
<DD>
<pre>
|- ∀cmp l. (smerge cmp l [] = l) ∧ (smerge cmp [] l = l)
</pre>

<DT><span class="strong">smerge_OL</span>
<DD>
<pre>
|- ∀cmp l m. OL cmp l ∧ OL cmp m ⇒ OL cmp (smerge cmp l m)
</pre>

<DT><span class="strong">OL_sublists_ind</span>
<DD>
<pre>
|- ∀P.
     (∀cmp. P cmp []) ∧ (∀cmp lol. P cmp lol ⇒ P cmp (NONE::lol)) ∧
     (∀cmp m lol. P cmp lol ⇒ P cmp (SOME m::lol)) ⇒
     ∀v v1. P v v1
</pre>

<DT><span class="strong">OL_sublists</span>
<DD>
<pre>
|- (∀cmp. OL_sublists cmp [] ⇔ T) ∧
   (∀lol cmp. OL_sublists cmp (NONE::lol) ⇔ OL_sublists cmp lol) ∧
   ∀m lol cmp. OL_sublists cmp (SOME m::lol) ⇔ OL cmp m ∧ OL_sublists cmp lol
</pre>

<DT><span class="strong">lol_set_ind</span>
<DD>
<pre>
|- ∀P.
     P [] ∧ (∀lol. P lol ⇒ P (NONE::lol)) ∧
     (∀m lol. P lol ⇒ P (SOME m::lol)) ⇒
     ∀v. P v
</pre>

<DT><span class="strong">lol_set</span>
<DD>
<pre>
|- (lol_set [] = ∅) ∧ (∀lol. lol_set (NONE::lol) = lol_set lol) ∧
   ∀m lol. lol_set (SOME m::lol) = LIST_TO_SET m ∪ lol_set lol
</pre>

<DT><span class="strong">incr_smerge_ind</span>
<DD>
<pre>
|- ∀P.
     (∀cmp l. P cmp l []) ∧ (∀cmp l lol. P cmp l (NONE::lol)) ∧
     (∀cmp l m lol. P cmp (smerge cmp l m) lol ⇒ P cmp l (SOME m::lol)) ⇒
     ∀v v1 v2. P v v1 v2
</pre>

<DT><span class="strong">incr_smerge</span>
<DD>
<pre>
|- (∀l cmp. incr_smerge cmp l [] = [SOME l]) ∧
   (∀lol l cmp. incr_smerge cmp l (NONE::lol) = SOME l::lol) ∧
   ∀m lol l cmp.
     incr_smerge cmp l (SOME m::lol) =
     NONE::incr_smerge cmp (smerge cmp l m) lol
</pre>

<DT><span class="strong">incr_smerge_OL</span>
<DD>
<pre>
|- ∀cmp lol l.
     OL_sublists cmp lol ∧ OL cmp l ⇒ OL_sublists cmp (incr_smerge cmp l lol)
</pre>

<DT><span class="strong">smerge_out_ind</span>
<DD>
<pre>
|- ∀P.
     (∀cmp l. P cmp l []) ∧ (∀cmp l lol. P cmp l lol ⇒ P cmp l (NONE::lol)) ∧
     (∀cmp l m lol. P cmp (smerge cmp l m) lol ⇒ P cmp l (SOME m::lol)) ⇒
     ∀v v1 v2. P v v1 v2
</pre>

<DT><span class="strong">smerge_out</span>
<DD>
<pre>
|- (∀l cmp. smerge_out cmp l [] = l) ∧
   (∀lol l cmp. smerge_out cmp l (NONE::lol) = smerge_out cmp l lol) ∧
   ∀m lol l cmp.
     smerge_out cmp l (SOME m::lol) = smerge_out cmp (smerge cmp l m) lol
</pre>

<DT><span class="strong">IN_bt_to_set</span>
<DD>
<pre>
|- (∀cmp y. y ∈ ENUMERAL cmp nt ⇔ F) ∧
   ∀cmp l x r y.
     y ∈ ENUMERAL cmp (node l x r) ⇔
     y ∈ ENUMERAL cmp l ∧ (apto cmp y x = LESS) ∨ (y = x) ∨
     y ∈ ENUMERAL cmp r ∧ (apto cmp x y = LESS)
</pre>

<DT><span class="strong">NOT_IN_nt</span>
<DD>
<pre>
|- ∀cmp y. y ∈ ENUMERAL cmp nt ⇔ F
</pre>

<DT><span class="strong">IN_node</span>
<DD>
<pre>
|- ∀cmp x l y r.
     x ∈ ENUMERAL cmp (node l y r) ⇔
     case apto cmp x y of
       LESS => x ∈ ENUMERAL cmp l
     | EQUAL => T
     | GREATER => x ∈ ENUMERAL cmp r
</pre>

<DT><span class="strong">ol_set</span>
<DD>
<pre>
|- ∀cmp t. ENUMERAL cmp t = LIST_TO_SET (bt_to_ol cmp t)
</pre>

<DT><span class="strong">OL_bt_to_ol_lb_ub</span>
<DD>
<pre>
|- ∀cmp t lb ub. OL cmp (bt_to_ol_lb_ub cmp lb t ub)
</pre>

<DT><span class="strong">OL_bt_to_ol_lb</span>
<DD>
<pre>
|- ∀cmp t lb. OL cmp (bt_to_ol_lb cmp lb t)
</pre>

<DT><span class="strong">OL_bt_to_ol_ub</span>
<DD>
<pre>
|- ∀cmp t ub. OL cmp (bt_to_ol_ub cmp t ub)
</pre>

<DT><span class="strong">OL_bt_to_ol</span>
<DD>
<pre>
|- ∀cmp t. OL cmp (bt_to_ol cmp t)
</pre>

<DT><span class="strong">OWL_bt_to_ol</span>
<DD>
<pre>
|- ∀cmp t. OWL cmp (ENUMERAL cmp t) (bt_to_ol cmp t)
</pre>

<DT><span class="strong">EMPTY_OU</span>
<DD>
<pre>
|- ∀cmp sl. OU cmp ∅ sl = sl
</pre>

<DT><span class="strong">OU_EMPTY</span>
<DD>
<pre>
|- ∀cmp t. OU cmp t ∅ = t
</pre>

<DT><span class="strong">LESS_UO_LEM</span>
<DD>
<pre>
|- ∀cmp x y s.
     (∀z. z ∈ UO cmp {x} s ⇒ (apto cmp y z = LESS)) ⇔ (apto cmp y x = LESS)
</pre>

<DT><span class="strong">LESS_ALL_OU</span>
<DD>
<pre>
|- ∀cmp x u v.
     LESS_ALL cmp x (OU cmp u v) ⇔ LESS_ALL cmp x u ∧ LESS_ALL cmp x v
</pre>

<DT><span class="strong">OU_ASSOC</span>
<DD>
<pre>
|- ∀cmp a b c. OU cmp a (OU cmp b c) = OU cmp (OU cmp a b) c
</pre>

<DT><span class="strong">LESS_ALL_UO_LEM</span>
<DD>
<pre>
|- ∀cmp a s. LESS_ALL cmp a s ⇒ (UO cmp {a} s = a INSERT s)
</pre>

<DT><span class="strong">LESS_ALL_OU_UO_LEM</span>
<DD>
<pre>
|- ∀cmp a s t.
     LESS_ALL cmp a s ∧ LESS_ALL cmp a t ⇒
     (OU cmp (UO cmp {a} s) t = a INSERT OU cmp s t)
</pre>

<DT><span class="strong">bt_to_ol_ID_IMP</span>
<DD>
<pre>
|- ∀cmp l. OL cmp l ⇒ (bt_to_ol cmp (list_to_bt l) = l)
</pre>

<DT><span class="strong">OL_UNION_IMP</span>
<DD>
<pre>
|- ∀cmp l.
     OL cmp l ⇒
     ∀m.
       OL cmp m ⇒
       OL cmp (smerge cmp l m) ∧
       (LIST_TO_SET (smerge cmp l m) = LIST_TO_SET l ∪ LIST_TO_SET m)
</pre>

<DT><span class="strong">sinter_ind</span>
<DD>
<pre>
|- ∀P.
     (∀cmp. P cmp [] []) ∧ (∀cmp x l. P cmp (x::l) []) ∧
     (∀cmp y m. P cmp [] (y::m)) ∧
     (∀cmp x l y m.
        ((apto cmp x y = EQUAL) ⇒ P cmp l m) ∧
        ((apto cmp x y = GREATER) ⇒ P cmp (x::l) m) ∧
        ((apto cmp x y = LESS) ⇒ P cmp l (y::m)) ⇒
        P cmp (x::l) (y::m)) ⇒
     ∀v v1 v2. P v v1 v2
</pre>

<DT><span class="strong">sinter</span>
<DD>
<pre>
|- (∀cmp. sinter cmp [] [] = []) ∧ (∀x l cmp. sinter cmp (x::l) [] = []) ∧
   (∀y m cmp. sinter cmp [] (y::m) = []) ∧
   ∀y x m l cmp.
     sinter cmp (x::l) (y::m) =
     case apto cmp x y of
       LESS => sinter cmp l (y::m)
     | EQUAL => x::sinter cmp l m
     | GREATER => sinter cmp (x::l) m
</pre>

<DT><span class="strong">OL_INTER_IMP</span>
<DD>
<pre>
|- ∀cmp l.
     OL cmp l ⇒
     ∀m.
       OL cmp m ⇒
       OL cmp (sinter cmp l m) ∧
       (LIST_TO_SET (sinter cmp l m) = LIST_TO_SET l ∩ LIST_TO_SET m)
</pre>

<DT><span class="strong">sdiff_ind</span>
<DD>
<pre>
|- ∀P.
     (∀cmp. P cmp [] []) ∧ (∀cmp x l. P cmp (x::l) []) ∧
     (∀cmp y m. P cmp [] (y::m)) ∧
     (∀cmp x l y m.
        ((apto cmp x y = EQUAL) ⇒ P cmp l m) ∧
        ((apto cmp x y = GREATER) ⇒ P cmp (x::l) m) ∧
        ((apto cmp x y = LESS) ⇒ P cmp l (y::m)) ⇒
        P cmp (x::l) (y::m)) ⇒
     ∀v v1 v2. P v v1 v2
</pre>

<DT><span class="strong">sdiff</span>
<DD>
<pre>
|- (∀cmp. sdiff cmp [] [] = []) ∧ (∀x l cmp. sdiff cmp (x::l) [] = x::l) ∧
   (∀y m cmp. sdiff cmp [] (y::m) = []) ∧
   ∀y x m l cmp.
     sdiff cmp (x::l) (y::m) =
     case apto cmp x y of
       LESS => x::sdiff cmp l (y::m)
     | EQUAL => sdiff cmp l m
     | GREATER => sdiff cmp (x::l) m
</pre>

<DT><span class="strong">OL_DIFF_IMP</span>
<DD>
<pre>
|- ∀cmp l.
     OL cmp l ⇒
     ∀m.
       OL cmp m ⇒
       OL cmp (sdiff cmp l m) ∧
       (LIST_TO_SET (sdiff cmp l m) = LIST_TO_SET l DIFF LIST_TO_SET m)
</pre>

<DT><span class="strong">ENUMERAL_set</span>
<DD>
<pre>
|- ∀cmp l. LIST_TO_SET l = ENUMERAL cmp (list_to_bt (incr_ssort cmp l))
</pre>

<DT><span class="strong">OL_ENUMERAL</span>
<DD>
<pre>
|- ∀cmp l. OL cmp l ⇒ (LIST_TO_SET l = ENUMERAL cmp (list_to_bt l))
</pre>

<DT><span class="strong">OWL_UNION_THM</span>
<DD>
<pre>
|- ∀cmp s l t m. OWL cmp s l ∧ OWL cmp t m ⇒ OWL cmp (s ∪ t) (smerge cmp l m)
</pre>

<DT><span class="strong">OWL_INTER_THM</span>
<DD>
<pre>
|- ∀cmp s l t m. OWL cmp s l ∧ OWL cmp t m ⇒ OWL cmp (s ∩ t) (sinter cmp l m)
</pre>

<DT><span class="strong">OWL_DIFF_THM</span>
<DD>
<pre>
|- ∀cmp s l t m.
     OWL cmp s l ∧ OWL cmp t m ⇒ OWL cmp (s DIFF t) (sdiff cmp l m)
</pre>

<DT><span class="strong">better_bt_to_ol</span>
<DD>
<pre>
|- ∀cmp t.
     bt_to_ol cmp t =
     if OL_bt cmp t then bt_to_list_ac t [] else bt_to_ol_ac cmp t []
</pre>

<DT><span class="strong">set_OWL_thm</span>
<DD>
<pre>
|- ∀cmp l. OWL cmp (LIST_TO_SET l) (incr_ssort cmp l)
</pre>

</DL>



<hr>
</body>
</html>
