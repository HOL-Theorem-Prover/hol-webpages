<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: sorting</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "sorting"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "rich_listTheory.html"><span class="strong">rich_list</span></a>

<h1>Signature</h1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr>
    <th>
    Constant
    <th>
    Type<tr><td>
            <span class="strong">PART</span>
            <td>
            :(α -> bool) -> α list -> α list -> α list -> α list # α list
    <tr><td>
        <span class="strong">PART3</span>
        <td>
        :α reln -> α -> α list -> α list # α list # α list
    <tr><td>
        <span class="strong">PARTITION</span>
        <td>
        :(α -> bool) -> α list -> α list # α list
    <tr><td> <span class="strong">PERM</span> <td> :α list reln
    <tr><td> <span class="strong">PERM_SINGLE_SWAP</span> <td> :α list reln
    <tr><td>
        <span class="strong">QSORT</span>
        <td>
        :α reln -> α list -> α list
    <tr><td>
        <span class="strong">QSORT3</span>
        <td>
        :α reln -> α list -> α list
    <tr><td>
        <span class="strong">QSORT3_tupled</span>
        <td>
        :α reln # α list -> α list
    <tr><td>
        <span class="strong">QSORT_tupled</span>
        <td>
        :α reln # α list -> α list
    <tr><td> <span class="strong">SORTED</span> <td> :α reln -> α list -> bool
    <tr><td>
        <span class="strong">SORTED_tupled</span>
        <td>
        :α reln # α list -> bool
    <tr><td>
        <span class="strong">SORTS</span>
        <td>
        :(α reln -> α list -> α list) -> α reln -> bool
    <tr><td>
        <span class="strong">STABLE</span>
        <td>
        :(α reln -> α list -> α list) -> α reln -> bool

</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">PERM_DEF</span>
<DD>
<pre>
|- ∀L1 L2. PERM L1 L2 ⇔ ∀x. FILTER ($= x) L1 = FILTER ($= x) L2
</pre>

<DT><span class="strong">SORTED_tupled_primitive_DEF</span>
<DD>
<pre>
|- SORTED_tupled =
   WFREC (@R'. WF R' ∧ ∀x rst y R. R' (R,y::rst) (R,x::y::rst))
     (λSORTED_tupled a.
        case a of
          (R,x::y::rst) => I (R x y ∧ SORTED_tupled (R,y::rst))
        | _ => I T)
</pre>

<DT><span class="strong">SORTED_curried_DEF</span>
<DD>
<pre>
|- ∀x x1. SORTED x x1 ⇔ SORTED_tupled (x,x1)
</pre>

<DT><span class="strong">SORTS_DEF</span>
<DD>
<pre>
|- ∀f R. SORTS f R ⇔ ∀l. PERM l (f R l) ∧ SORTED R (f R l)
</pre>

<DT><span class="strong">PART_DEF</span>
<DD>
<pre>
|- (∀P l1 l2. PART P [] l1 l2 = (l1,l2)) ∧
   ∀P h rst l1 l2.
     PART P (h::rst) l1 l2 =
     if P h then PART P rst (h::l1) l2 else PART P rst l1 (h::l2)
</pre>

<DT><span class="strong">PARTITION_DEF</span>
<DD>
<pre>
|- ∀P l. PARTITION P l = PART P l [] []
</pre>

<DT><span class="strong">QSORT_tupled_primitive_DEF</span>
<DD>
<pre>
|- QSORT_tupled =
   WFREC
     (@R.
        WF R ∧
        (∀t h ord l1 l2.
           ((l1,l2) = PARTITION (λy. ord y h) t) ⇒ R (ord,l2) (ord,h::t)) ∧
        ∀t h ord l1 l2.
          ((l1,l2) = PARTITION (λy. ord y h) t) ⇒ R (ord,l1) (ord,h::t))
     (λQSORT_tupled a.
        case a of
          (ord,[]) => I []
        | (ord,h::t) =>
            I
              (let (l1,l2) = PARTITION (λy. ord y h) t
               in
                 QSORT_tupled (ord,l1) ++ [h] ++ QSORT_tupled (ord,l2)))
</pre>

<DT><span class="strong">QSORT_curried_DEF</span>
<DD>
<pre>
|- ∀x x1. QSORT x x1 = QSORT_tupled (x,x1)
</pre>

<DT><span class="strong">PERM_SINGLE_SWAP_DEF</span>
<DD>
<pre>
|- ∀l1 l2.
     PERM_SINGLE_SWAP l1 l2 ⇔
     ∃x1 x2 x3. (l1 = x1 ++ x2 ++ x3) ∧ (l2 = x1 ++ x3 ++ x2)
</pre>

<DT><span class="strong">STABLE_DEF</span>
<DD>
<pre>
|- ∀sort r.
     STABLE sort r ⇔
     SORTS sort r ∧
     ∀p. (∀x y. p x ∧ p y ⇒ r x y) ⇒ ∀l. FILTER p l = FILTER p (sort r l)
</pre>

<DT><span class="strong">PART3_DEF</span>
<DD>
<pre>
|- (∀R h. PART3 R h [] = ([],[],[])) ∧
   ∀R h hd tl.
     PART3 R h (hd::tl) =
     if R h hd ∧ R hd h then (I ## (CONS hd ## I)) (PART3 R h tl)
     else if R hd h then (CONS hd ## (I ## I)) (PART3 R h tl)
     else (I ## (I ## CONS hd)) (PART3 R h tl)
</pre>

<DT><span class="strong">QSORT3_tupled_primitive_DEF</span>
<DD>
<pre>
|- QSORT3_tupled =
   WFREC
     (@R'.
        WF R' ∧
        (∀tl hd R lo eq hi.
           ((lo,eq,hi) = PART3 R hd tl) ⇒ R' (R,hi) (R,hd::tl)) ∧
        ∀tl hd R lo eq hi.
          ((lo,eq,hi) = PART3 R hd tl) ⇒ R' (R,lo) (R,hd::tl))
     (λQSORT3_tupled a.
        case a of
          (R,[]) => I []
        | (R,hd::tl) =>
            I
              (let (lo,eq,hi) = PART3 R hd tl
               in
                 QSORT3_tupled (R,lo) ++ hd::eq ++ QSORT3_tupled (R,hi)))
</pre>

<DT><span class="strong">QSORT3_curried_DEF</span>
<DD>
<pre>
|- ∀x x1. QSORT3 x x1 = QSORT3_tupled (x,x1)
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">PERM_FUN_APPEND_APPEND_2</span>
<DD>
<pre>
|- ∀l1 l2 l3 l4.
     (PERM l1 = PERM (l2 ++ l3)) ⇒ (PERM (l4 ++ l1) = PERM (l2 ++ (l4 ++ l3)))
</pre>

<DT><span class="strong">PERM_FUN_APPEND_APPEND_1</span>
<DD>
<pre>
|- ∀l1 l2 l3 l4.
     (PERM l1 = PERM (l2 ++ l3)) ⇒ (PERM (l1 ++ l4) = PERM (l2 ++ (l3 ++ l4)))
</pre>

<DT><span class="strong">PERM_FUN_CONS_APPEND_2</span>
<DD>
<pre>
|- ∀l l1 x l2.
     (PERM l1 = PERM (x::l2)) ⇒ (PERM (l ++ l1) = PERM (x::(l ++ l2)))
</pre>

<DT><span class="strong">PERM_FUN_CONS_APPEND_1</span>
<DD>
<pre>
|- ∀l l1 x l2.
     (PERM l1 = PERM (x::l2)) ⇒ (PERM (l1 ++ l) = PERM (x::(l2 ++ l)))
</pre>

<DT><span class="strong">PERM_FUN_CONS_11_APPEND</span>
<DD>
<pre>
|- ∀y l1 l2 l3.
     (PERM l1 = PERM (l2 ++ l3)) ⇒ (PERM (y::l1) = PERM (l2 ++ y::l3))
</pre>

<DT><span class="strong">PERM_FUN_CONS_11_SWAP_AT_FRONT</span>
<DD>
<pre>
|- ∀y l1 x l2. (PERM l1 = PERM (x::l2)) ⇒ (PERM (y::l1) = PERM (x::y::l2))
</pre>

<DT><span class="strong">PERM_FUN_SWAP_AT_FRONT</span>
<DD>
<pre>
|- ∀x y l. PERM (x::y::l) = PERM (y::x::l)
</pre>

<DT><span class="strong">PERM_FUN_APPEND_CONS</span>
<DD>
<pre>
|- ∀x l1 l2. PERM (l1 ++ x::l2) = PERM (x::l1 ++ l2)
</pre>

<DT><span class="strong">PERM_FUN_CONS</span>
<DD>
<pre>
|- ∀x l1 l1'. (PERM l1 = PERM l1') ⇒ (PERM (x::l1) = PERM (x::l1'))
</pre>

<DT><span class="strong">PERM_REFL</span>
<DD>
<pre>
|- ∀L. PERM L L
</pre>

<DT><span class="strong">PERM_INTRO</span>
<DD>
<pre>
|- ∀x y. (x = y) ⇒ PERM x y
</pre>

<DT><span class="strong">PERM_transitive</span>
<DD>
<pre>
|- transitive PERM
</pre>

<DT><span class="strong">PERM_TRANS</span>
<DD>
<pre>
|- ∀x y z. PERM x y ∧ PERM y z ⇒ PERM x z
</pre>

<DT><span class="strong">PERM_SYM</span>
<DD>
<pre>
|- ∀l1 l2. PERM l1 l2 ⇔ PERM l2 l1
</pre>

<DT><span class="strong">PERM_CONG</span>
<DD>
<pre>
|- ∀L1 L2 L3 L4. PERM L1 L3 ∧ PERM L2 L4 ⇒ PERM (L1 ++ L2) (L3 ++ L4)
</pre>

<DT><span class="strong">PERM_MONO</span>
<DD>
<pre>
|- ∀l1 l2 x. PERM l1 l2 ⇒ PERM (x::l1) (x::l2)
</pre>

<DT><span class="strong">PERM_CONS_IFF</span>
<DD>
<pre>
|- ∀x l2 l1. PERM (x::l1) (x::l2) ⇔ PERM l1 l2
</pre>

<DT><span class="strong">PERM_NIL</span>
<DD>
<pre>
|- ∀L. (PERM L [] ⇔ (L = [])) ∧ (PERM [] L ⇔ (L = []))
</pre>

<DT><span class="strong">PERM_SING</span>
<DD>
<pre>
|- (PERM L [x] ⇔ (L = [x])) ∧ (PERM [x] L ⇔ (L = [x]))
</pre>

<DT><span class="strong">PERM_CONS_EQ_APPEND</span>
<DD>
<pre>
|- ∀L h. PERM (h::t) L ⇔ ∃M N. (L = M ++ h::N) ∧ PERM t (M ++ N)
</pre>

<DT><span class="strong">PERM_APPEND</span>
<DD>
<pre>
|- ∀l1 l2. PERM (l1 ++ l2) (l2 ++ l1)
</pre>

<DT><span class="strong">CONS_PERM</span>
<DD>
<pre>
|- ∀x L M N. PERM L (M ++ N) ⇒ PERM (x::L) (M ++ x::N)
</pre>

<DT><span class="strong">APPEND_PERM_SYM</span>
<DD>
<pre>
|- ∀A B C. PERM (A ++ B) C ⇒ PERM (B ++ A) C
</pre>

<DT><span class="strong">PERM_SPLIT</span>
<DD>
<pre>
|- ∀P l. PERM l (FILTER P l ++ FILTER ($~ o P) l)
</pre>

<DT><span class="strong">PERM_IND</span>
<DD>
<pre>
|- ∀P.
     P [] [] ∧ (∀x l1 l2. P l1 l2 ⇒ P (x::l1) (x::l2)) ∧
     (∀x y l1 l2. P l1 l2 ⇒ P (x::y::l1) (y::x::l2)) ∧
     (∀l1 l2 l3. P l1 l2 ∧ P l2 l3 ⇒ P l1 l3) ⇒
     ∀l1 l2. PERM l1 l2 ⇒ P l1 l2
</pre>

<DT><span class="strong">PERM_SWAP_AT_FRONT</span>
<DD>
<pre>
|- PERM (x::y::l1) (y::x::l2) ⇔ PERM l1 l2
</pre>

<DT><span class="strong">PERM_STRONG_IND</span>
<DD>
<pre>
|- ∀P.
     P [] [] ∧ (∀x l1 l2. PERM l1 l2 ∧ P l1 l2 ⇒ P (x::l1) (x::l2)) ∧
     (∀x y l1 l2. PERM l1 l2 ∧ P l1 l2 ⇒ P (x::y::l1) (y::x::l2)) ∧
     (∀l1 l2 l3. PERM l1 l2 ∧ P l1 l2 ∧ PERM l2 l3 ∧ P l2 l3 ⇒ P l1 l3) ⇒
     ∀l1 l2. PERM l1 l2 ⇒ P l1 l2
</pre>

<DT><span class="strong">PERM_LENGTH</span>
<DD>
<pre>
|- ∀l1 l2. PERM l1 l2 ⇒ (LENGTH l1 = LENGTH l2)
</pre>

<DT><span class="strong">PERM_MEM_EQ</span>
<DD>
<pre>
|- ∀l1 l2. PERM l1 l2 ⇒ ∀x. MEM x l1 ⇔ MEM x l2
</pre>

<DT><span class="strong">PERM_LIST_TO_SET</span>
<DD>
<pre>
|- ∀l1 l2. PERM l1 l2 ⇒ (LIST_TO_SET l1 = LIST_TO_SET l2)
</pre>

<DT><span class="strong">SORTED_IND</span>
<DD>
<pre>
|- ∀P.
     (∀R. P R []) ∧ (∀R x. P R [x]) ∧
     (∀R x y rst. P R (y::rst) ⇒ P R (x::y::rst)) ⇒
     ∀v v1. P v v1
</pre>

<DT><span class="strong">SORTED_DEF</span>
<DD>
<pre>
|- (∀R. SORTED R [] ⇔ T) ∧ (∀x R. SORTED R [x] ⇔ T) ∧
   ∀y x rst R. SORTED R (x::y::rst) ⇔ R x y ∧ SORTED R (y::rst)
</pre>

<DT><span class="strong">SORTED_EQ</span>
<DD>
<pre>
|- ∀R L x. transitive R ⇒ (SORTED R (x::L) ⇔ SORTED R L ∧ ∀y. MEM y L ⇒ R x y)
</pre>

<DT><span class="strong">SORTED_APPEND</span>
<DD>
<pre>
|- ∀R L1 L2.
     transitive R ∧ SORTED R L1 ∧ SORTED R L2 ∧
     (∀x y. MEM x L1 ∧ MEM y L2 ⇒ R x y) ⇒
     SORTED R (L1 ++ L2)
</pre>

<DT><span class="strong">PART_LENGTH</span>
<DD>
<pre>
|- ∀P L l1 l2 p q.
     ((p,q) = PART P L l1 l2) ⇒
     (LENGTH L + LENGTH l1 + LENGTH l2 = LENGTH p + LENGTH q)
</pre>

<DT><span class="strong">PART_LENGTH_LEM</span>
<DD>
<pre>
|- ∀P L l1 l2 p q.
     ((p,q) = PART P L l1 l2) ⇒
     LENGTH p ≤ LENGTH L + LENGTH l1 + LENGTH l2 ∧
     LENGTH q ≤ LENGTH L + LENGTH l1 + LENGTH l2
</pre>

<DT><span class="strong">PARTs_HAVE_PROP</span>
<DD>
<pre>
|- ∀P L A B l1 l2.
     ((A,B) = PART P L l1 l2) ∧ (∀x. MEM x l1 ⇒ P x) ∧ (∀x. MEM x l2 ⇒ ¬P x) ⇒
     (∀z. MEM z A ⇒ P z) ∧ ∀z. MEM z B ⇒ ¬P z
</pre>

<DT><span class="strong">PART_MEM</span>
<DD>
<pre>
|- ∀P L a1 a2 l1 l2.
     ((a1,a2) = PART P L l1 l2) ⇒
     ∀x. MEM x (L ++ (l1 ++ l2)) ⇔ MEM x (a1 ++ a2)
</pre>

<DT><span class="strong">QSORT_IND</span>
<DD>
<pre>
|- ∀P.
     (∀ord. P ord []) ∧
     (∀ord h t.
        (∀l1 l2. ((l1,l2) = PARTITION (λy. ord y h) t) ⇒ P ord l2) ∧
        (∀l1 l2. ((l1,l2) = PARTITION (λy. ord y h) t) ⇒ P ord l1) ⇒
        P ord (h::t)) ⇒
     ∀v v1. P v v1
</pre>

<DT><span class="strong">QSORT_DEF</span>
<DD>
<pre>
|- (∀ord. QSORT ord [] = []) ∧
   ∀t ord h.
     QSORT ord (h::t) =
     (let (l1,l2) = PARTITION (λy. ord y h) t
      in
        QSORT ord l1 ++ [h] ++ QSORT ord l2)
</pre>

<DT><span class="strong">QSORT_MEM</span>
<DD>
<pre>
|- ∀R L x. MEM x (QSORT R L) ⇔ MEM x L
</pre>

<DT><span class="strong">QSORT_PERM</span>
<DD>
<pre>
|- ∀R L. PERM L (QSORT R L)
</pre>

<DT><span class="strong">QSORT_SORTED</span>
<DD>
<pre>
|- ∀R L. transitive R ∧ total R ⇒ SORTED R (QSORT R L)
</pre>

<DT><span class="strong">QSORT_SORTS</span>
<DD>
<pre>
|- ∀R. transitive R ∧ total R ⇒ SORTS QSORT R
</pre>

<DT><span class="strong">PERM_APPEND_IFF</span>
<DD>
<pre>
|- (∀l l1 l2. PERM (l ++ l1) (l ++ l2) ⇔ PERM l1 l2) ∧
   ∀l l1 l2. PERM (l1 ++ l) (l2 ++ l) ⇔ PERM l1 l2
</pre>

<DT><span class="strong">PERM_SINGLE_SWAP_REFL</span>
<DD>
<pre>
|- ∀l. PERM_SINGLE_SWAP l l
</pre>

<DT><span class="strong">PERM_SINGLE_SWAP_SYM</span>
<DD>
<pre>
|- ∀l1 l2. PERM_SINGLE_SWAP l1 l2 ⇔ PERM_SINGLE_SWAP l2 l1
</pre>

<DT><span class="strong">PERM_TC</span>
<DD>
<pre>
|- PERM = PERM_SINGLE_SWAP⁺
</pre>

<DT><span class="strong">PERM_RTC</span>
<DD>
<pre>
|- PERM = PERM_SINGLE_SWAP^*
</pre>

<DT><span class="strong">PERM_EQC</span>
<DD>
<pre>
|- PERM = PERM_SINGLE_SWAP^=
</pre>

<DT><span class="strong">PERM_lifts_transitive_relations</span>
<DD>
<pre>
|- ∀f Q.
     (∀x1 x2 x3. Q (f (x1 ++ x2 ++ x3)) (f (x1 ++ x3 ++ x2))) ∧ transitive Q ⇒
     ∀x y. PERM x y ⇒ Q (f x) (f y)
</pre>

<DT><span class="strong">PERM_lifts_equalities</span>
<DD>
<pre>
|- ∀f.
     (∀x1 x2 x3. f (x1 ++ x2 ++ x3) = f (x1 ++ x3 ++ x2)) ⇒
     ∀x y. PERM x y ⇒ (f x = f y)
</pre>

<DT><span class="strong">PERM_lifts_invariants</span>
<DD>
<pre>
|- ∀P.
     (∀x1 x2 x3. P (x1 ++ x2 ++ x3) ⇒ P (x1 ++ x3 ++ x2)) ⇒
     ∀x y. P x ∧ PERM x y ⇒ P y
</pre>

<DT><span class="strong">PERM_lifts_monotonicities</span>
<DD>
<pre>
|- ∀f.
     (∀x1 x2 x3.
        ∃x1' x2' x3'.
          (f (x1 ++ x2 ++ x3) = x1' ++ x2' ++ x3') ∧
          (f (x1 ++ x3 ++ x2) = x1' ++ x3' ++ x2')) ⇒
     ∀x y. PERM x y ⇒ PERM (f x) (f y)
</pre>

<DT><span class="strong">PERM_EQUIVALENCE</span>
<DD>
<pre>
|- equivalence PERM
</pre>

<DT><span class="strong">PERM_EQUIVALENCE_ALT_DEF</span>
<DD>
<pre>
|- ∀x y. PERM x y ⇔ (PERM x = PERM y)
</pre>

<DT><span class="strong">ALL_DISTINCT_PERM</span>
<DD>
<pre>
|- ∀l1 l2. PERM l1 l2 ⇒ (ALL_DISTINCT l1 ⇔ ALL_DISTINCT l2)
</pre>

<DT><span class="strong">PERM_ALL_DISTINCT</span>
<DD>
<pre>
|- ∀l1 l2.
     ALL_DISTINCT l1 ∧ ALL_DISTINCT l2 ∧ (∀x. MEM x l1 ⇔ MEM x l2) ⇒
     PERM l1 l2
</pre>

<DT><span class="strong">ALL_DISTINCT_PERM_LIST_TO_SET_TO_LIST</span>
<DD>
<pre>
|- ∀ls. ALL_DISTINCT ls ⇔ PERM ls (SET_TO_LIST (LIST_TO_SET ls))
</pre>

<DT><span class="strong">PERM_MAP</span>
<DD>
<pre>
|- ∀f l1 l2. PERM l1 l2 ⇒ PERM (MAP f l1) (MAP f l2)
</pre>

<DT><span class="strong">PERM_SUM</span>
<DD>
<pre>
|- ∀l1 l2. PERM l1 l2 ⇒ (SUM l1 = SUM l2)
</pre>

<DT><span class="strong">PERM_FILTER</span>
<DD>
<pre>
|- ∀P l1 l2. PERM l1 l2 ⇒ PERM (FILTER P l1) (FILTER P l2)
</pre>

<DT><span class="strong">PERM_REVERSE</span>
<DD>
<pre>
|- PERM ls (REVERSE ls)
</pre>

<DT><span class="strong">PERM_REVERSE_EQ</span>
<DD>
<pre>
|- (PERM (REVERSE l1) l2 ⇔ PERM l1 l2) ∧ (PERM l1 (REVERSE l2) ⇔ PERM l1 l2)
</pre>

<DT><span class="strong">FOLDR_PERM</span>
<DD>
<pre>
|- ∀f l1 l2 e. ASSOC f ∧ COMM f ⇒ PERM l1 l2 ⇒ (FOLDR f e l1 = FOLDR f e l2)
</pre>

<DT><span class="strong">PERM_SET_TO_LIST_count_COUNT_LIST</span>
<DD>
<pre>
|- PERM (SET_TO_LIST (count n)) (COUNT_LIST n)
</pre>

<DT><span class="strong">SUM_IMAGE_count_SUM_GENLIST</span>
<DD>
<pre>
|- ∑ f (count n) = SUM (GENLIST f n)
</pre>

<DT><span class="strong">SUM_IMAGE_count_MULT</span>
<DD>
<pre>
|- (∀m. m < n ⇒ (g m = ∑ (λx. f (x + k * m)) (count k))) ⇒
   (∑ f (count (k * n)) = ∑ g (count n))
</pre>

<DT><span class="strong">sum_of_sums</span>
<DD>
<pre>
|- ∑ (λm. ∑ (f m) (count a)) (count b) =
   ∑ (λm. f (m DIV a) (m MOD a)) (count (a * b))
</pre>

<DT><span class="strong">SORTED_NIL</span>
<DD>
<pre>
|- ∀R. SORTED R []
</pre>

<DT><span class="strong">SORTED_SING</span>
<DD>
<pre>
|- ∀R x. SORTED R [x]
</pre>

<DT><span class="strong">SORTED_EL_SUC</span>
<DD>
<pre>
|- ∀R ls. SORTED R ls ⇔ ∀n. SUC n < LENGTH ls ⇒ R (EL n ls) (EL (SUC n) ls)
</pre>

<DT><span class="strong">SORTED_EL_LESS</span>
<DD>
<pre>
|- ∀R.
     transitive R ⇒
     ∀ls. SORTED R ls ⇔ ∀m n. m < n ∧ n < LENGTH ls ⇒ R (EL m ls) (EL n ls)
</pre>

<DT><span class="strong">SORTED_transitive_APPEND_IFF</span>
<DD>
<pre>
|- ∀R.
     transitive R ⇒
     ∀L1 L2.
       SORTED R (L1 ++ L2) ⇔
       SORTED R L1 ∧ SORTED R L2 ∧
       ((L1 = []) ∨ (L2 = []) ∨ R (LAST L1) (HD L2))
</pre>

<DT><span class="strong">MEM_PERM</span>
<DD>
<pre>
|- ∀l1 l2. PERM l1 l2 ⇒ ∀a. MEM a l1 ⇔ MEM a l2
</pre>

<DT><span class="strong">SORTED_PERM_EQ</span>
<DD>
<pre>
|- ∀R.
     transitive R ∧ antisymmetric R ⇒
     ∀l1 l2. SORTED R l1 ∧ SORTED R l2 ∧ PERM l1 l2 ⇒ (l1 = l2)
</pre>

<DT><span class="strong">QSORT_eq_if_PERM</span>
<DD>
<pre>
|- ∀R.
     total R ∧ transitive R ∧ antisymmetric R ⇒
     ∀l1 l2. (QSORT R l1 = QSORT R l2) ⇔ PERM l1 l2
</pre>

<DT><span class="strong">PERM_FUN_APPEND</span>
<DD>
<pre>
|- ∀l1 l2. PERM (l1 ++ l2) = PERM (l2 ++ l1)
</pre>

<DT><span class="strong">PERM_FUN_CONS_IFF</span>
<DD>
<pre>
|- ∀x l1 l2. (PERM l1 = PERM l2) ⇒ (PERM (x::l1) = PERM (x::l2))
</pre>

<DT><span class="strong">PERM_FUN_APPEND_IFF</span>
<DD>
<pre>
|- ∀l l1 l2. (PERM l1 = PERM l2) ⇒ (PERM (l ++ l1) = PERM (l ++ l2))
</pre>

<DT><span class="strong">PERM_FUN_CONG</span>
<DD>
<pre>
|- ∀l1 l1' l2 l2'.
     (PERM l1 = PERM l1') ⇒ (PERM l2 = PERM l2') ⇒ (PERM l1 l2 ⇔ PERM l1' l2')
</pre>

<DT><span class="strong">PERM_CONG_2</span>
<DD>
<pre>
|- ∀l1 l1' l2 l2'. PERM l1 l1' ⇒ PERM l2 l2' ⇒ (PERM l1 l2 ⇔ PERM l1' l2')
</pre>

<DT><span class="strong">PERM_CONG_APPEND_IFF</span>
<DD>
<pre>
|- ∀l l1 l1' l2 l2'.
     PERM l1 (l ++ l1') ⇒ PERM l2 (l ++ l2') ⇒ (PERM l1 l2 ⇔ PERM l1' l2')
</pre>

<DT><span class="strong">PERM_FUN_SPLIT</span>
<DD>
<pre>
|- ∀l l1 l1' l2. PERM l (l1 ++ l2) ⇒ PERM l1' l1 ⇒ PERM l (l1' ++ l2)
</pre>

<DT><span class="strong">PERM_REWR</span>
<DD>
<pre>
|- ∀l r l1 l2. PERM l r ⇒ (PERM (l ++ l1) l2 ⇔ PERM (r ++ l1) l2)
</pre>

<DT><span class="strong">PART3_FILTER</span>
<DD>
<pre>
|- ∀tl hd.
     PART3 R hd tl =
     (FILTER (λx. R x hd ∧ ¬R hd x) tl,FILTER (λx. R x hd ∧ R hd x) tl,
      FILTER (λx. ¬R x hd) tl)
</pre>

<DT><span class="strong">QSORT3_IND</span>
<DD>
<pre>
|- ∀P.
     (∀R. P R []) ∧
     (∀R hd tl.
        (∀lo eq hi. ((lo,eq,hi) = PART3 R hd tl) ⇒ P R hi) ∧
        (∀lo eq hi. ((lo,eq,hi) = PART3 R hd tl) ⇒ P R lo) ⇒
        P R (hd::tl)) ⇒
     ∀v v1. P v v1
</pre>

<DT><span class="strong">QSORT3_DEF</span>
<DD>
<pre>
|- (∀R. QSORT3 R [] = []) ∧
   ∀tl hd R.
     QSORT3 R (hd::tl) =
     (let (lo,eq,hi) = PART3 R hd tl in QSORT3 R lo ++ hd::eq ++ QSORT3 R hi)
</pre>

<DT><span class="strong">PERM3</span>
<DD>
<pre>
|- ∀x a a' b b' c c'.
     (PERM a a' ∧ PERM b b' ∧ PERM c c') ∧ PERM x (a ++ b ++ c) ⇒
     PERM x (a' ++ b' ++ c')
</pre>

<DT><span class="strong">PERM3_FILTER</span>
<DD>
<pre>
|- ∀l h.
     PERM l
       (FILTER (λx. R x h ∧ ¬R h x) l ++ FILTER (λx. R x h ∧ R h x) l ++
        FILTER (λx. ¬R x h) l)
</pre>

<DT><span class="strong">PERM_QSORT3</span>
<DD>
<pre>
|- ∀l R. PERM l (QSORT3 R l)
</pre>

<DT><span class="strong">SORTED_EQ_PART</span>
<DD>
<pre>
|- ∀l R. transitive R ⇒ SORTED R (FILTER (λx. R x hd ∧ R hd x) l)
</pre>

<DT><span class="strong">QSORT3_SORTS</span>
<DD>
<pre>
|- ∀R. transitive R ∧ total R ⇒ SORTS QSORT3 R
</pre>

<DT><span class="strong">QSORT3_SPLIT</span>
<DD>
<pre>
|- ∀R.
     transitive R ∧ total R ⇒
     ∀l e.
       QSORT3 R l =
       QSORT3 R (FILTER (λx. R x e ∧ ¬R e x) l) ++
       FILTER (λx. R x e ∧ R e x) l ++ QSORT3 R (FILTER (λx. ¬R x e) l)
</pre>

<DT><span class="strong">QSORT3_STABLE</span>
<DD>
<pre>
|- ∀R. transitive R ∧ total R ⇒ STABLE QSORT3 R
</pre>

<DT><span class="strong">QSORT3_MEM</span>
<DD>
<pre>
|- ∀R L x. MEM x (QSORT3 R L) ⇔ MEM x L
</pre>

<DT><span class="strong">QSORT3_SORTED</span>
<DD>
<pre>
|- ∀R L. transitive R ∧ total R ⇒ SORTED R (QSORT3 R L)
</pre>

<DT><span class="strong">sorted_count_list</span>
<DD>
<pre>
|- ∀n. SORTED $<= (COUNT_LIST n)
</pre>

<DT><span class="strong">sorted_map</span>
<DD>
<pre>
|- ∀R f l. transitive R ⇒ (SORTED R (MAP f l) ⇔ SORTED (inv_image R f) l)
</pre>

<DT><span class="strong">sorted_perm_count_list</span>
<DD>
<pre>
|- ∀y f l n.
     SORTED (inv_image $<= f) l ∧ PERM (MAP f l) (COUNT_LIST n) ⇒
     (MAP f l = COUNT_LIST n)
</pre>

<DT><span class="strong">SORTED_weaken</span>
<DD>
<pre>
|- ∀R R' ls.
     SORTED R ls ∧ (∀x y. MEM x ls ∧ MEM y ls ∧ R x y ⇒ R' x y) ⇒ SORTED R' ls
</pre>

</DL>



<hr>
</body>
</html>
