<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure Omega_AutomataTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure Omega_AutomataTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/temporal/src/Omega_AutomataScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature Omega_AutomataTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Theorems  *)
<a name="line6"></a>    val <a href="#AUTOMATON_TEMP_CLOSURE-val">AUTOMATON_TEMP_CLOSURE</a> : thm
<a name="line7"></a>    val <a href="#BEFORE_AS_CO_BUECHI-val">BEFORE_AS_CO_BUECHI</a> : thm
<a name="line8"></a>    val <a href="#BOOLEAN_CLOSURE_F-val">BOOLEAN_CLOSURE_F</a> : thm
<a name="line9"></a>    val <a href="#BOOLEAN_CLOSURE_FG-val">BOOLEAN_CLOSURE_FG</a> : thm
<a name="line10"></a>    val <a href="#BOOLEAN_CLOSURE_G-val">BOOLEAN_CLOSURE_G</a> : thm
<a name="line11"></a>    val <a href="#BOOLEAN_CLOSURE_GF-val">BOOLEAN_CLOSURE_GF</a> : thm
<a name="line12"></a>    val <a href="#BOREL_HIERARCHY_F-val">BOREL_HIERARCHY_F</a> : thm
<a name="line13"></a>    val <a href="#BOREL_HIERARCHY_FG-val">BOREL_HIERARCHY_FG</a> : thm
<a name="line14"></a>    val <a href="#BOREL_HIERARCHY_G-val">BOREL_HIERARCHY_G</a> : thm
<a name="line15"></a>    val <a href="#BUECHI_PERIODIC_MODEL-val">BUECHI_PERIODIC_MODEL</a> : thm
<a name="line16"></a>    val <a href="#BUECHI_PERIODIC_REDUCTION_THM-val">BUECHI_PERIODIC_REDUCTION_THM</a> : thm
<a name="line17"></a>    val <a href="#BUECHI_PROP_REDUCTION-val">BUECHI_PROP_REDUCTION</a> : thm
<a name="line18"></a>    val <a href="#BUECHI_TRANSLATION-val">BUECHI_TRANSLATION</a> : thm
<a name="line19"></a>    val <a href="#CO_BUECHI_BEFORE_CLOSURE-val">CO_BUECHI_BEFORE_CLOSURE</a> : thm
<a name="line20"></a>    val <a href="#CO_BUECHI_CONJ_CLOSURE-val">CO_BUECHI_CONJ_CLOSURE</a> : thm
<a name="line21"></a>    val <a href="#CO_BUECHI_DISJ_CLOSURE-val">CO_BUECHI_DISJ_CLOSURE</a> : thm
<a name="line22"></a>    val <a href="#CO_BUECHI_NEXT_CLOSURE-val">CO_BUECHI_NEXT_CLOSURE</a> : thm
<a name="line23"></a>    val <a href="#CO_BUECHI_SBEFORE_CLOSURE-val">CO_BUECHI_SBEFORE_CLOSURE</a> : thm
<a name="line24"></a>    val <a href="#CO_BUECHI_SUNTIL_CLOSURE-val">CO_BUECHI_SUNTIL_CLOSURE</a> : thm
<a name="line25"></a>    val <a href="#CO_BUECHI_SWHEN_CLOSURE-val">CO_BUECHI_SWHEN_CLOSURE</a> : thm
<a name="line26"></a>    val <a href="#CO_BUECHI_UNTIL_CLOSURE-val">CO_BUECHI_UNTIL_CLOSURE</a> : thm
<a name="line27"></a>    val <a href="#CO_BUECHI_WHEN_CLOSURE-val">CO_BUECHI_WHEN_CLOSURE</a> : thm
<a name="line28"></a>    val <a href="#DET_OMEGA_EXISTS_FORALL_THEOREM-val">DET_OMEGA_EXISTS_FORALL_THEOREM</a> : thm
<a name="line29"></a>    val <a href="#ELGOT1_THM-val">ELGOT1_THM</a> : thm
<a name="line30"></a>    val <a href="#ELGOT2_THM-val">ELGOT2_THM</a> : thm
<a name="line31"></a>    val <a href="#ELGOT_LEMMA-val">ELGOT_LEMMA</a> : thm
<a name="line32"></a>    val <a href="#EQUALITY_THM-val">EQUALITY_THM</a> : thm
<a name="line33"></a>    val <a href="#EXISTS_FORALL_THM-val">EXISTS_FORALL_THM</a> : thm
<a name="line34"></a>    val <a href="#FORALL_EXISTS_THM-val">FORALL_EXISTS_THM</a> : thm
<a name="line35"></a>    val <a href="#LESS_THM-val">LESS_THM</a> : thm
<a name="line36"></a>    val <a href="#NEG_DET_AUTOMATA-val">NEG_DET_AUTOMATA</a> : thm
<a name="line37"></a>    val <a href="#NEXT_AS_CO_BUECHI-val">NEXT_AS_CO_BUECHI</a> : thm
<a name="line38"></a>    val <a href="#OMEGA_CONJ_CLOSURE-val">OMEGA_CONJ_CLOSURE</a> : thm
<a name="line39"></a>    val <a href="#OMEGA_DISJ_CLOSURE-val">OMEGA_DISJ_CLOSURE</a> : thm
<a name="line40"></a>    val <a href="#SBEFORE_AS_CO_BUECHI-val">SBEFORE_AS_CO_BUECHI</a> : thm
<a name="line41"></a>    val <a href="#SUNTIL_AS_CO_BUECHI-val">SUNTIL_AS_CO_BUECHI</a> : thm
<a name="line42"></a>    val <a href="#SWHEN_AS_CO_BUECHI-val">SWHEN_AS_CO_BUECHI</a> : thm
<a name="line43"></a>    val <a href="#TEMP_OPS_DEFS_TO_OMEGA-val">TEMP_OPS_DEFS_TO_OMEGA</a> : thm
<a name="line44"></a>    val <a href="#UNTIL_AS_CO_BUECHI-val">UNTIL_AS_CO_BUECHI</a> : thm
<a name="line45"></a>    val <a href="#WHEN_AS_CO_BUECHI-val">WHEN_AS_CO_BUECHI</a> : thm
<a name="line46"></a>
<a name="line47"></a>  val Omega_Automata_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line48"></a>(*
   [Past_Temporal_Logic] Parent theory of "Omega_Automata"

   [<a name="AUTOMATON_TEMP_CLOSURE-val"><b>AUTOMATON_TEMP_CLOSURE</b></a>]  Theorem

      |- ((∃q1.
             Phi_I1 q1 ∧ Phi_R1 q1 ∧
             ∃q2. Phi_I2 q2 ∧ Phi_R2 (q2,q1) ∧ Phi_F (q1,q2)) ⇔
          ∃q1 q2.
            (Phi_I1 q1 ∧ Phi_I2 q2) ∧ (Phi_R1 q1 ∧ Phi_R2 (q2,q1)) ∧
            Phi_F (q1,q2)) ∧
         (Phi (NEXT phi) ⇔
          ∃q0 q1.
            T ∧ (∀t. (q0 t ⇔ phi t) ∧ (q1 t ⇔ q0 (t + 1))) ∧ Phi q1) ∧
         (Phi (PNEXT phi) ⇔ ∃q. q 0 ∧ (∀t. q (t + 1) ⇔ phi t) ∧ Phi q) ∧
         (Phi (PSNEXT phi) ⇔ ∃q. ¬q 0 ∧ (∀t. q (t + 1) ⇔ phi t) ∧ Phi q) ∧
         (Phi (PNEXT (PALWAYS a)) ⇔
          ∃q. q 0 ∧ (∀t. q (t + 1) ⇔ a t ∧ q t) ∧ Phi q) ∧
         (Phi (PSNEXT (PEVENTUAL a)) ⇔
          ∃q. ¬q 0 ∧ (∀t. q (t + 1) ⇔ a t ∨ q t) ∧ Phi q) ∧
         (Phi (PSNEXT (a PSUNTIL b)) ⇔
          ∃q. ¬q 0 ∧ (∀t. q (t + 1) ⇔ b t ∨ a t ∧ q t) ∧ Phi q) ∧
         (Phi (PSNEXT (a PSWHEN b)) ⇔
          ∃q. ¬q 0 ∧ (∀t. q (t + 1) ⇔ a t ∧ b t ∨ ¬b t ∧ q t) ∧ Phi q) ∧
         (Phi (PSNEXT (a PSBEFORE b)) ⇔
          ∃q. ¬q 0 ∧ (∀t. q (t + 1) ⇔ ¬b t ∧ (a t ∨ q t)) ∧ Phi q) ∧
         (Phi (PNEXT (a PUNTIL b)) ⇔
          ∃q. q 0 ∧ (∀t. q (t + 1) ⇔ b t ∨ a t ∧ q t) ∧ Phi q) ∧
         (Phi (PNEXT (a PWHEN b)) ⇔
          ∃q. q 0 ∧ (∀t. q (t + 1) ⇔ a t ∧ b t ∨ ¬b t ∧ q t) ∧ Phi q) ∧
         (Phi (PNEXT (a PBEFORE b)) ⇔
          ∃q. q 0 ∧ (∀t. q (t + 1) ⇔ ¬b t ∧ (a t ∨ q t)) ∧ Phi q)

   [<a name="BEFORE_AS_CO_BUECHI-val"><b>BEFORE_AS_CO_BUECHI</b></a>]  Theorem

      |- (a BEFORE b) t0 ⇔
         ∃q.
           ¬q t0 ∧
           (∀t.
              ¬q (t + t0) ∧ ¬a (t + t0) ∧ ¬b (t + t0) ∧ ¬q (t + (1 + t0)) ∨
              ¬q (t + t0) ∧ a (t + t0) ∧ ¬b (t + t0) ∧ q (t + (1 + t0)) ∨
              q (t + t0) ∧ q (t + (1 + t0))) ∧
           ∃t1. ∀t2. ¬q (t1 + (t2 + t0)) ∨ q (t1 + (t2 + t0))

   [<a name="BOOLEAN_CLOSURE_F-val"><b>BOOLEAN_CLOSURE_F</b></a>]  Theorem

      |- (¬(∃t. a (t + t0)) ⇔ ∀t. ¬a (t + t0)) ∧
         ((∃t. a (t + t0)) ∨ (∃t. b (t + t0)) ⇔
          ∃t. a (t + t0) ∨ b (t + t0)) ∧
         ((∃t. a (t + t0)) ∧ (∃t. b (t + t0)) ⇔
          ∃p q.
            (¬p t0 ∧ ¬q t0) ∧
            (∀t.
               (p (t + (t0 + 1)) ⇔ p (t + t0) ∨ a (t + t0)) ∧
               (q (t + (t0 + 1)) ⇔ q (t + t0) ∨ b (t + t0))) ∧
            ∃t. p (t + t0) ∧ q (t + t0))

   [<a name="BOOLEAN_CLOSURE_FG-val"><b>BOOLEAN_CLOSURE_FG</b></a>]  Theorem

      |- (¬(∃t1. ∀t2. a (t1 + (t2 + t0))) ⇔
          ∀t1. ∃t2. ¬a (t1 + (t2 + t0))) ∧
         ((∃t1. ∀t2. a (t1 + (t2 + t0))) ∧ (∃t1. ∀t2. b (t1 + (t2 + t0))) ⇔
          ∃t1. ∀t2. a (t1 + (t2 + t0)) ∧ b (t1 + (t2 + t0))) ∧
         ((∃t1. ∀t2. a (t1 + (t2 + t0))) ∨ (∃t1. ∀t2. b (t1 + (t2 + t0))) ⇔
          ∃q.
            ¬q t0 ∧
            (∀t.
               q (t + (t0 + 1)) ⇔
               if q (t + t0) then b (t + t0) else ¬a (t + t0)) ∧
            ∃t1. ∀t2. ¬q (t1 + (t2 + t0)) ∨ b (t1 + (t2 + t0)))

   [<a name="BOOLEAN_CLOSURE_G-val"><b>BOOLEAN_CLOSURE_G</b></a>]  Theorem

      |- (¬(∀t. a (t + t0)) ⇔ ∃t. ¬a (t + t0)) ∧
         ((∀t. a (t + t0)) ∧ (∀t. b (t + t0)) ⇔
          ∀t. a (t + t0) ∧ b (t + t0)) ∧
         ((∀t. a (t + t0)) ∨ (∀t. b (t + t0)) ⇔
          ∃p q.
            (¬p t0 ∧ ¬q t0) ∧
            (∀t.
               (p (t + (t0 + 1)) ⇔ p (t + t0) ∨ ¬a (t + t0)) ∧
               (q (t + (t0 + 1)) ⇔ q (t + t0) ∨ ¬b (t + t0))) ∧
            ∀t. ¬p (t + t0) ∨ ¬q (t + t0))

   [<a name="BOOLEAN_CLOSURE_GF-val"><b>BOOLEAN_CLOSURE_GF</b></a>]  Theorem

      |- (¬(∀t1. ∃t2. a (t1 + (t2 + t0))) ⇔
          ∃t1. ∀t2. ¬a (t1 + (t2 + t0))) ∧
         ((∀t1. ∃t2. a (t1 + (t2 + t0))) ∨ (∀t1. ∃t2. b (t1 + (t2 + t0))) ⇔
          ∀t1. ∃t2. a (t1 + (t2 + t0)) ∨ b (t1 + (t2 + t0))) ∧
         ((∀t1. ∃t2. a (t1 + (t2 + t0))) ∧ (∀t1. ∃t2. b (t1 + (t2 + t0))) ⇔
          ∃q.
            ¬q t0 ∧
            (∀t.
               q (t + (t0 + 1)) ⇔
               if q (t + t0) then ¬b (t + t0) else a (t + t0)) ∧
            ∀t1. ∃t2. q (t1 + (t2 + t0)) ∧ b (t1 + (t2 + t0)))

   [<a name="BOREL_HIERARCHY_F-val"><b>BOREL_HIERARCHY_F</b></a>]  Theorem

      |- ((∃t. a (t + t0)) ⇔
          ∃q.
            ¬q t0 ∧ (∀t. q (SUC (t + t0)) ⇔ q (t + t0) ∨ a (t + t0)) ∧
            ∃t1. ∀t2. q (t1 + (t2 + t0))) ∧
         ((∃t. a (t + t0)) ⇔
          ∃q.
            ¬q t0 ∧ (∀t. q (SUC (t + t0)) ⇔ q (t + t0) ∨ a (t + t0)) ∧
            ∀t1. ∃t2. q (t1 + (t2 + t0)))

   [<a name="BOREL_HIERARCHY_FG-val"><b>BOREL_HIERARCHY_FG</b></a>]  Theorem

      |- ((∃t1. ∀t2. a (t1 + (t2 + t0))) ⇔
          ∃q.
            ¬q t0 ∧ (∀t. q (t + t0) ⇒ a (t + t0) ∧ q (SUC (t + t0))) ∧
            ∃t. q (t + t0)) ∧
         ((∃t1. ∀t2. a (t1 + (t2 + t0))) ⇔
          ∃p q.
            (¬p t0 ∧ ¬q t0) ∧
            (∀t.
               (p (t + t0) ⇒ p (SUC (t + t0))) ∧
               (p (SUC (t + t0)) ⇒ p (t + t0) ∨ ¬q (t + t0)) ∧
               (q (SUC (t + t0)) ⇔
                p (t + t0) ∧ ¬q (t + t0) ∧ ¬a (t + t0) ∨
                p (t + t0) ∧ q (t + t0))) ∧
            ∀t1. ∃t2. p (t1 + (t2 + t0)) ∧ ¬q (t1 + (t2 + t0)))

   [<a name="BOREL_HIERARCHY_G-val"><b>BOREL_HIERARCHY_G</b></a>]  Theorem

      |- ((∀t. a (t + t0)) ⇔
          ∃q.
            q t0 ∧ (∀t. q (t + t0) ∧ a (t + t0) ∧ q (SUC (t + t0))) ∧
            ∃t. q (t + t0)) ∧
         ((∀t. a (t + t0)) ⇔
          ∃q.
            q t0 ∧ (∀t. q (SUC (t + t0)) ⇔ q (t + t0) ∧ a (t + t0)) ∧
            ∃t1. ∀t2. q (t1 + (t2 + t0))) ∧
         ((∀t. a (t + t0)) ⇔
          ∃q.
            q t0 ∧ (∀t. q (SUC (t + t0)) ⇔ q (t + t0) ∧ a (t + t0)) ∧
            ∀t1. ∃t2. q (t1 + (t2 + t0)))

   [<a name="BUECHI_PERIODIC_MODEL-val"><b>BUECHI_PERIODIC_MODEL</b></a>]  Theorem

      |- (∀s. ∃x0 l. 0 &lt; l ∧ (s x0 = s (x0 + l))) ⇒
         ((∃i q.
             InitState (q 0) ∧ (∀t. TransRel (i t,q t,q (t + 1))) ∧
             ∀t1. ∃t2. Accept (q (t1 + t2))) ⇔
          ∃x0 l j p.
            0 &lt; l ∧ (∀t2. j (x0 + t2) = j (x0 + t2 MOD l)) ∧
            (∀t2. p (x0 + t2) = p (x0 + t2 MOD l)) ∧ InitState (p 0) ∧
            (∀t. TransRel (j t,p t,p (t + 1))) ∧
            ∀t1. ∃t2. Accept (p (t1 + t2)))

   [<a name="BUECHI_PERIODIC_REDUCTION_THM-val"><b>BUECHI_PERIODIC_REDUCTION_THM</b></a>]  Theorem

      |- (∀s. ∃x0 l. 0 &lt; l ∧ (s x0 = s (x0 + l))) ⇒
         ((∃i q.
             InitState (q 0) ∧ (∀t. TransRel (i t,q t,q (t + 1))) ∧
             ∀t1. ∃t2. Accept (q (t1 + t2))) ⇔
          ∃x0 l j p.
            0 &lt; l ∧ (∀t2. j (x0 + t2) = j (x0 + t2 MOD l)) ∧
            (∀t2. p (x0 + t2) = p (x0 + t2 MOD l)) ∧ InitState (p 0) ∧
            (∀t. t &lt; x0 + l ⇒ TransRel (j t,p t,p (t + 1))) ∧
            ∃t. t &lt; l ∧ Accept (p (x0 + t)))

   [<a name="BUECHI_PROP_REDUCTION-val"><b>BUECHI_PROP_REDUCTION</b></a>]  Theorem

      |- (∀s. ∃x0 l. 0 &lt; l ∧ (s x0 = s (x0 + l))) ⇒
         ((∃i q.
             InitState (q 0) ∧ (∀t. TransRel (i t,q t,q (t + 1))) ∧
             ∀t1. ∃t2. Accept (q (t1 + t2))) ⇔
          ∃x0 l j p.
            0 &lt; l ∧ InitState (p 0) ∧
            (∀t. t &lt; x0 + l ⇒ TransRel (j t,p t,p (t + 1))) ∧
            (∃t. t &lt; l ∧ Accept (p (x0 + t))) ∧ (p x0 = p (x0 + l)))

   [<a name="BUECHI_TRANSLATION-val"><b>BUECHI_TRANSLATION</b></a>]  Theorem

      |- (Phi (NEXT phi) ⇔
          ∃q0 q1.
            T ∧ (∀t. (q0 t ⇔ phi t) ∧ (q1 t ⇔ q0 (t + 1))) ∧ Phi q1) ∧
         (Phi (ALWAYS a) ⇔
          ∃q.
            T ∧ (∀t. q t ⇔ a t ∧ q (t + 1)) ∧
            (∀t1. ∃t2. a (t1 + t2) ⇒ q (t1 + t2)) ∧ Phi q) ∧
         (Phi (EVENTUAL a) ⇔
          ∃q.
            T ∧ (∀t. q t ⇔ a t ∨ q (t + 1)) ∧
            (∀t1. ∃t2. q (t1 + t2) ⇒ a (t1 + t2)) ∧ Phi q) ∧
         (Phi (a SUNTIL b) ⇔
          ∃q.
            T ∧ (∀t. q t ⇔ b t ∨ a t ∧ q (t + 1)) ∧
            (∀t1. ∃t2. q (t1 + t2) ⇒ ¬a (t1 + t2) ∨ b (t1 + t2)) ∧ Phi q) ∧
         (Phi (a UNTIL b) ⇔
          ∃q.
            T ∧ (∀t. q t ⇔ b t ∨ a t ∧ q (t + 1)) ∧
            (∀t1. ∃t2. ¬q (t1 + t2) ⇒ ¬a (t1 + t2) ∨ b (t1 + t2)) ∧
            Phi q) ∧
         (Phi (a SWHEN b) ⇔
          ∃q.
            T ∧ (∀t. q t ⇔ if b t then a t else q (t + 1)) ∧
            (∀t1. ∃t2. q (t1 + t2) ⇒ b (t1 + t2)) ∧ Phi q) ∧
         (Phi (a WHEN b) ⇔
          ∃q.
            T ∧ (∀t. q t ⇔ if b t then a t else q (t + 1)) ∧
            (∀t1. ∃t2. q (t1 + t2) ∨ b (t1 + t2)) ∧ Phi q) ∧
         (Phi (a SBEFORE b) ⇔
          ∃q.
            T ∧ (∀t. q t ⇔ ¬b t ∧ (a t ∨ q (t + 1))) ∧
            (∀t1. ∃t2. q (t1 + t2) ⇒ a (t1 + t2) ∨ b (t1 + t2)) ∧ Phi q) ∧
         (Phi (a BEFORE b) ⇔
          ∃q.
            T ∧ (∀t. q t ⇔ ¬b t ∧ (a t ∨ q (t + 1))) ∧
            (∀t1. ∃t2. ¬q (t1 + t2) ⇒ a (t1 + t2) ∨ b (t1 + t2)) ∧ Phi q)

   [<a name="CO_BUECHI_BEFORE_CLOSURE-val"><b>CO_BUECHI_BEFORE_CLOSURE</b></a>]  Theorem

      |- ((λt0.
             ∃q.
               Phi_I (q t0) ∧ (∀t. Phi_R (i (t + t0),q (t + t0))) ∧
               ∃t1.
                 ∀t2. Psi (i (t1 + (t2 + t0)),q (t1 + (t2 + t0)))) BEFORE
          phi) t0 ⇔
         ∃p1 p2 q.
           (¬p1 t0 ∧ ¬p2 t0 ∧ (q t0 = c) ∨ p1 t0 ∧ ¬p2 t0 ∧ Phi_I (q t0)) ∧
           (∀t.
              ¬p1 (t + t0) ∧ ¬p2 (t + t0) ∧ (q (t + t0) = c) ∧
              ¬phi (t + t0) ∧ ¬p1 (t + (t0 + 1)) ∧ ¬p2 (t + (t0 + 1)) ∧
              (q (t + (t0 + 1)) = c) ∨
              ¬p1 (t + t0) ∧ ¬p2 (t + t0) ∧ (q (t + t0) = c) ∧
              ¬phi (t + t0) ∧ p1 (t + (t0 + 1)) ∧ ¬p2 (t + (t0 + 1)) ∧
              Phi_I (q (t + (t0 + 1))) ∨
              p1 (t + t0) ∧ ¬p2 (t + t0) ∧ ¬phi (t + t0) ∧
              Phi_I (q (t + t0)) ∧ Phi_R (i (t + t0),q (t + t0)) ∧
              p1 (t + (t0 + 1)) ∧ p2 (t + (t0 + 1)) ∨
              p1 (t + t0) ∧ p2 (t + t0) ∧ Phi_R (i (t + t0),q (t + t0)) ∧
              p1 (t + (t0 + 1)) ∧ p2 (t + (t0 + 1))) ∧
           ∃t1.
             ∀t2.
               ¬p1 (t1 + (t2 + t0)) ∨
               Psi (i (t1 + (t2 + t0)),q (t1 + (t2 + t0)))

   [<a name="CO_BUECHI_CONJ_CLOSURE-val"><b>CO_BUECHI_CONJ_CLOSURE</b></a>]  Theorem

      |- (∃q1.
            Phi_I1 (q1 t0) ∧ (∀t. Phi_R1 (i (t + t0),q1 (t + t0))) ∧
            ∃t1. ∀t2. Psi1 (i (t1 + (t2 + t0)),q1 (t1 + (t2 + t0)))) ∧
         (∃q2.
            Phi_I2 (q2 t0) ∧ (∀t. Phi_R2 (i (t + t0),q2 (t + t0))) ∧
            ∃t1. ∀t2. Psi2 (i (t1 + (t2 + t0)),q2 (t1 + (t2 + t0)))) ⇔
         ∃q1 q2.
           (Phi_I1 (q1 t0) ∧ Phi_I2 (q2 t0)) ∧
           (∀t.
              Phi_R1 (i (t + t0),q1 (t + t0)) ∧
              Phi_R2 (i (t + t0),q2 (t + t0))) ∧
           ∃t1.
             ∀t2.
               Psi1 (i (t1 + (t2 + t0)),q1 (t1 + (t2 + t0))) ∧
               Psi2 (i (t1 + (t2 + t0)),q2 (t1 + (t2 + t0)))

   [<a name="CO_BUECHI_DISJ_CLOSURE-val"><b>CO_BUECHI_DISJ_CLOSURE</b></a>]  Theorem

      |- (∃q1.
            Phi_I1 (q1 t0) ∧ (∀t. Phi_R1 (i (t + t0),q1 (t + t0))) ∧
            ∃t1. ∀t2. Psi1 (i (t1 + (t2 + t0)),q1 (t1 + (t2 + t0)))) ∨
         (∃q2.
            Phi_I2 (q2 t0) ∧ (∀t. Phi_R2 (i (t + t0),q2 (t + t0))) ∧
            ∃t1. ∀t2. Psi2 (i (t1 + (t2 + t0)),q2 (t1 + (t2 + t0)))) ⇔
         ∃p q1 q2.
           (¬p t0 ∧ Phi_I1 (q1 t0) ∨ p t0 ∧ Phi_I2 (q2 t0)) ∧
           (∀t.
              ¬p (t + t0) ∧ Phi_R1 (i (t + t0),q1 (t + t0)) ∧
              ¬p (t + (t0 + 1)) ∨
              p (t + t0) ∧ Phi_R2 (i (t + t0),q2 (t + t0)) ∧
              p (t + (t0 + 1))) ∧
           ∃t1.
             ∀t2.
               ¬p (t + t0) ∧
               Psi1 (i (t1 + (t2 + t0)),q1 (t1 + (t2 + t0))) ∨
               p (t + t0) ∧ Psi2 (i (t1 + (t2 + t0)),q2 (t1 + (t2 + t0)))

   [<a name="CO_BUECHI_NEXT_CLOSURE-val"><b>CO_BUECHI_NEXT_CLOSURE</b></a>]  Theorem

      |- NEXT
           (λt0.
              ∃q.
                Phi_I (q t0) ∧ (∀t. Phi_R (i (t + t0),q (t + t0))) ∧
                ∃t1. ∀t2. Psi (i (t1 + (t2 + t0)),q (t1 + (t2 + t0)))) t0 ⇔
         ∃p q.
           ((p t0 ⇔ F) ∧ (q t0 = c)) ∧
           (∀t.
              ¬p (t + t0) ∧ (q (t + t0) = c) ∧ p (t + (t0 + 1)) ∧
              Phi_I (q (t + (t0 + 1))) ∨
              p (t + t0) ∧ Phi_R (i (t + t0),q (t + t0)) ∧
              p (t + (t0 + 1))) ∧
           ∃t1. ∀t2. Psi (i (t1 + (t2 + t0)),q (t1 + (t2 + t0)))

   [<a name="CO_BUECHI_SBEFORE_CLOSURE-val"><b>CO_BUECHI_SBEFORE_CLOSURE</b></a>]  Theorem

      |- ((λt0.
             ∃q.
               Phi_I (q t0) ∧ (∀t. Phi_R (i (t + t0),q (t + t0))) ∧
               ∃t1.
                 ∀t2. Psi (i (t1 + (t2 + t0)),q (t1 + (t2 + t0)))) SBEFORE
          phi) t0 ⇔
         ∃p1 p2 q.
           (¬p1 t0 ∧ ¬p2 t0 ∧ (q t0 = c) ∨ p1 t0 ∧ ¬p2 t0 ∧ Phi_I (q t0)) ∧
           (∀t.
              ¬p1 (t + t0) ∧ ¬p2 (t + t0) ∧ (q (t + t0) = c) ∧
              ¬phi (t + t0) ∧ ¬p1 (t + (t0 + 1)) ∧ ¬p2 (t + (t0 + 1)) ∧
              (q (t + (t0 + 1)) = c) ∨
              ¬p1 (t + t0) ∧ ¬p2 (t + t0) ∧ (q (t + t0) = c) ∧
              ¬phi (t + t0) ∧ p1 (t + (t0 + 1)) ∧ ¬p2 (t + (t0 + 1)) ∧
              Phi_I (q (t + (t0 + 1))) ∨
              p1 (t + t0) ∧ ¬p2 (t + t0) ∧ ¬phi (t + t0) ∧
              Phi_I (q (t + t0)) ∧ Phi_R (i (t + t0),q (t + t0)) ∧
              p1 (t + (t0 + 1)) ∧ p2 (t + (t0 + 1)) ∨
              p1 (t + t0) ∧ p2 (t + t0) ∧ Phi_R (i (t + t0),q (t + t0)) ∧
              p1 (t + (t0 + 1)) ∧ p2 (t + (t0 + 1))) ∧
           ∃t1.
             ∀t2.
               p1 (t1 + (t2 + t0)) ∧
               Psi (i (t1 + (t2 + t0)),q (t1 + (t2 + t0)))

   [<a name="CO_BUECHI_SUNTIL_CLOSURE-val"><b>CO_BUECHI_SUNTIL_CLOSURE</b></a>]  Theorem

      |- (phi SUNTIL
          (λt0.
             ∃q.
               Phi_I (q t0) ∧ (∀t. Phi_R (i (t + t0),q (t + t0))) ∧
               ∃t1. ∀t2. Psi (i (t1 + (t2 + t0)),q (t1 + (t2 + t0))))) t0 ⇔
         ∃p q.
           (if p t0 then Phi_I (q t0) else (q t0 = c)) ∧
           (∀t.
              ¬p (t + t0) ∧ (q (t + t0) = c) ∧ phi (t + t0) ∧
              ¬p (t + (t0 + 1)) ∧ (q (t + (t0 + 1)) = c) ∨
              ¬p (t + t0) ∧ (q (t + t0) = c) ∧ phi (t + t0) ∧
              p (t + (t0 + 1)) ∧ Phi_I (q (t + (t0 + 1))) ∨
              p (t + t0) ∧ Phi_R (i (t + t0),q (t + t0)) ∧
              p (t + (t0 + 1))) ∧
           ∃t1.
             ∀t2.
               p (t1 + (t2 + t0)) ∧
               Psi (i (t1 + (t2 + t0)),q (t1 + (t2 + t0)))

   [<a name="CO_BUECHI_SWHEN_CLOSURE-val"><b>CO_BUECHI_SWHEN_CLOSURE</b></a>]  Theorem

      |- ((λt0.
             ∃q.
               Phi_I (q t0) ∧ (∀t. Phi_R (i (t + t0),q (t + t0))) ∧
               ∃t1. ∀t2. Psi (i (t1 + (t2 + t0)),q (t1 + (t2 + t0)))) SWHEN
          phi) t0 ⇔
         ∃p1 p2 q.
           (¬p1 t0 ∧ ¬p2 t0 ∧ (q t0 = c) ∨ p1 t0 ∧ ¬p2 t0 ∧ Phi_I (q t0)) ∧
           (∀t.
              ¬p1 (t + t0) ∧ ¬p2 (t + t0) ∧ (q (t + t0) = c) ∧
              ¬phi (t + t0) ∧ ¬p1 (t + (t0 + 1)) ∧ ¬p2 (t + (t0 + 1)) ∧
              (q (t + (t0 + 1)) = c) ∨
              ¬p1 (t + t0) ∧ ¬p2 (t + t0) ∧ (q (t + t0) = c) ∧
              ¬phi (t + t0) ∧ p1 (t + (t0 + 1)) ∧ ¬p2 (t + (t0 + 1)) ∧
              Phi_I (q (t + (t0 + 1))) ∨
              p1 (t + t0) ∧ ¬p2 (t + t0) ∧ phi (t + t0) ∧
              Phi_I (q (t + t0)) ∧ Phi_R (i (t + t0),q (t + t0)) ∧
              p1 (t + (t0 + 1)) ∧ p2 (t + (t0 + 1)) ∨
              p1 (t + t0) ∧ p2 (t + t0) ∧ Phi_R (i (t + t0),q (t + t0)) ∧
              p1 (t + (t0 + 1)) ∧ p2 (t + (t0 + 1))) ∧
           ∃t1.
             ∀t2.
               p1 (t1 + (t2 + t0)) ∧
               Psi (i (t1 + (t2 + t0)),q (t1 + (t2 + t0)))

   [<a name="CO_BUECHI_UNTIL_CLOSURE-val"><b>CO_BUECHI_UNTIL_CLOSURE</b></a>]  Theorem

      |- (phi UNTIL
          (λt0.
             ∃q.
               Phi_I (q t0) ∧ (∀t. Phi_R (i (t + t0),q (t + t0))) ∧
               ∃t1. ∀t2. Psi (i (t1 + (t2 + t0)),q (t1 + (t2 + t0))))) t0 ⇔
         ∃p q.
           (if p t0 then Phi_I (q t0) else (q t0 = c)) ∧
           (∀t.
              ¬p (t + t0) ∧ (q (t + t0) = c) ∧ phi (t + t0) ∧
              ¬p (t + (t0 + 1)) ∧ (q (t + (t0 + 1)) = c) ∨
              ¬p (t + t0) ∧ (q (t + t0) = c) ∧ phi (t + t0) ∧
              p (t + (t0 + 1)) ∧ Phi_I (q (t + (t0 + 1))) ∨
              p (t + t0) ∧ Phi_R (i (t + t0),q (t + t0)) ∧
              p (t + (t0 + 1))) ∧
           ∃t1.
             ∀t2.
               ¬p (t1 + (t2 + t0)) ∨
               Psi (i (t1 + (t2 + t0)),q (t1 + (t2 + t0)))

   [<a name="CO_BUECHI_WHEN_CLOSURE-val"><b>CO_BUECHI_WHEN_CLOSURE</b></a>]  Theorem

      |- ((λt0.
             ∃q.
               Phi_I (q t0) ∧ (∀t. Phi_R (i (t + t0),q (t + t0))) ∧
               ∃t1. ∀t2. Psi (i (t1 + (t2 + t0)),q (t1 + (t2 + t0)))) WHEN
          phi) t0 ⇔
         ∃p1 p2 q.
           (¬p1 t0 ∧ ¬p2 t0 ∧ (q t0 = c) ∨ p1 t0 ∧ ¬p2 t0 ∧ Phi_I (q t0)) ∧
           (∀t.
              ¬p1 (t + t0) ∧ ¬p2 (t + t0) ∧ (q (t + t0) = c) ∧
              ¬phi (t + t0) ∧ ¬p1 (t + (t0 + 1)) ∧ ¬p2 (t + (t0 + 1)) ∧
              (q (t + (t0 + 1)) = c) ∨
              ¬p1 (t + t0) ∧ ¬p2 (t + t0) ∧ (q (t + t0) = c) ∧
              ¬phi (t + t0) ∧ p1 (t + (t0 + 1)) ∧ ¬p2 (t + (t0 + 1)) ∧
              Phi_I (q (t + (t0 + 1))) ∨
              p1 (t + t0) ∧ ¬p2 (t + t0) ∧ phi (t + t0) ∧
              Phi_I (q (t + t0)) ∧ Phi_R (i (t + t0),q (t + t0)) ∧
              p1 (t + (t0 + 1)) ∧ p2 (t + (t0 + 1)) ∨
              p1 (t + t0) ∧ p2 (t + t0) ∧ Phi_R (i (t + t0),q (t + t0)) ∧
              p1 (t + (t0 + 1)) ∧ p2 (t + (t0 + 1))) ∧
           ∃t1.
             ∀t2.
               ¬p1 (t1 + (t2 + t0)) ∨
               Psi (i (t1 + (t2 + t0)),q (t1 + (t2 + t0)))

   [<a name="DET_OMEGA_EXISTS_FORALL_THEOREM-val"><b>DET_OMEGA_EXISTS_FORALL_THEOREM</b></a>]  Theorem

      |- (∃q.
            (q t0 = InitVal) ∧
            (∀t. q (t + (t0 + 1)) = TransRel (i (t + t0),q (t + t0))) ∧
            Accept (i,(λt. q (t + t0)))) ⇔
         ∀q.
           (q t0 = InitVal) ∧
           (∀t. q (t + (t0 + 1)) = TransRel (i (t + t0),q (t + t0))) ⇒
           Accept (i,(λt. q (t + t0)))

   [<a name="ELGOT1_THM-val"><b>ELGOT1_THM</b></a>]  Theorem

      |- ∀PHI. (∃x. ∀p. PHI p x) ⇔ ∃q. ∀p x. ∃z. (q x ⇒ PHI p x) ∧ q z

   [<a name="ELGOT2_THM-val"><b>ELGOT2_THM</b></a>]  Theorem

      |- ∀PHI. (∀x. ∃p. PHI p x) ⇔ ∀q. ∃p x. ∀z. q z ⇒ PHI p x ∧ q x

   [<a name="ELGOT_LEMMA-val"><b>ELGOT_LEMMA</b></a>]  Theorem

      |- ∀PHI. (∃x. ∀p. PHI p x) ⇔ ∃q. (∀x. q x ⇒ ∀p. PHI p x) ∧ ∃z. q z

   [<a name="EQUALITY_THM-val"><b>EQUALITY_THM</b></a>]  Theorem

      |- ∀x y. (x = y) ⇔ ∀P. P x ⇔ P y

   [<a name="EXISTS_FORALL_THM-val"><b>EXISTS_FORALL_THM</b></a>]  Theorem

      |- ∀P. (∃t1. ∀t2. P (t1 + t2)) ⇔ ∃t1. ∀t2. t1 &lt; t2 ⇒ P t2

   [<a name="FORALL_EXISTS_THM-val"><b>FORALL_EXISTS_THM</b></a>]  Theorem

      |- ∀P. (∀t1. ∃t2. P (t1 + t2)) ⇔ ∀t1. ∃t2. t1 &lt; t2 ∧ P t2

   [<a name="LESS_THM-val"><b>LESS_THM</b></a>]  Theorem

      |- ∀x y. x &lt; y ⇔ ∃P. P x ∧ ¬P y ∧ ∀z. P (SUC z) ⇒ P z

   [<a name="NEG_DET_AUTOMATA-val"><b>NEG_DET_AUTOMATA</b></a>]  Theorem

      |- ¬(∃q.
             (q t0 = InitVal) ∧
             (∀t. q (t + (t0 + 1)) = TransRel (i (t + t0),q (t + t0))) ∧
             Accept (i,(λt. q (t + t0)))) ⇔
         ∃q.
           (q t0 = InitVal) ∧
           (∀t. q (t + (t0 + 1)) = TransRel (i (t + t0),q (t + t0))) ∧
           ¬Accept (i,(λt. q (t + t0)))

   [<a name="NEXT_AS_CO_BUECHI-val"><b>NEXT_AS_CO_BUECHI</b></a>]  Theorem

      |- NEXT a t0 ⇔
         ∃p q.
           (¬p t0 ∧ ¬q t0) ∧
           (∀t.
              ¬p (t + t0) ∧ ¬q (t + t0) ∧ p (t + (1 + t0)) ∧
              ¬q (t + (1 + t0)) ∨
              p (t + t0) ∧ ¬q (t + t0) ∧ a (t + t0) ∧ p (t + (1 + t0)) ∧
              q (t + (1 + t0)) ∨
              p (t + t0) ∧ q (t + t0) ∧ p (t + (1 + t0)) ∧
              q (t + (1 + t0))) ∧ ∃t1. ∀t2. q (t1 + (t2 + t0))

   [<a name="OMEGA_CONJ_CLOSURE-val"><b>OMEGA_CONJ_CLOSURE</b></a>]  Theorem

      |- (∃q1.
            Phi_I1 (q1 t0) ∧ (∀t. Phi_R1 (i (t + t0),q1 (t + t0))) ∧
            Psi1 (i,q1)) ∧
         (∃q2.
            Phi_I2 (q2 t0) ∧ (∀t. Phi_R2 (i (t + t0),q2 (t + t0))) ∧
            Psi2 (i,q2)) ⇔
         ∃q1 q2.
           (Phi_I1 (q1 t0) ∧ Phi_I2 (q2 t0)) ∧
           (∀t.
              Phi_R1 (i (t + t0),q1 (t + t0)) ∧
              Phi_R2 (i (t + t0),q2 (t + t0))) ∧ Psi1 (i,q1) ∧ Psi2 (i,q2)

   [<a name="OMEGA_DISJ_CLOSURE-val"><b>OMEGA_DISJ_CLOSURE</b></a>]  Theorem

      |- (∃q1.
            Phi_I1 (q1 t0) ∧ (∀t. Phi_R1 (i (t + t0),q1 (t + t0))) ∧
            Psi1 (i,q1)) ∨
         (∃q2.
            Phi_I2 (q2 t0) ∧ (∀t. Phi_R2 (i (t + t0),q2 (t + t0))) ∧
            Psi2 (i,q2)) ⇔
         ∃p q1 q2.
           (¬p t0 ∧ Phi_I1 (q1 t0) ∨ p t0 ∧ Phi_I2 (q2 t0)) ∧
           (∀t.
              ¬p (t + t0) ∧ Phi_R1 (i (t + t0),q1 (t + t0)) ∧
              ¬p (t + (t0 + 1)) ∨
              p (t + t0) ∧ Phi_R2 (i (t + t0),q2 (t + t0)) ∧
              p (t + (t0 + 1))) ∧
           (¬p t0 ∧ Psi1 (i,q1) ∨ p t0 ∧ Psi2 (i,q2))

   [<a name="SBEFORE_AS_CO_BUECHI-val"><b>SBEFORE_AS_CO_BUECHI</b></a>]  Theorem

      |- (a SBEFORE b) t0 ⇔
         ∃q.
           ¬q t0 ∧
           (∀t.
              ¬q (t + t0) ∧ ¬a (t + t0) ∧ ¬b (t + t0) ∧ ¬q (t + (1 + t0)) ∨
              ¬q (t + t0) ∧ a (t + t0) ∧ ¬b (t + t0) ∧ q (t + (1 + t0)) ∨
              q (t + t0) ∧ q (t + (1 + t0))) ∧ ∃t1. ∀t2. q (t1 + (t2 + t0))

   [<a name="SUNTIL_AS_CO_BUECHI-val"><b>SUNTIL_AS_CO_BUECHI</b></a>]  Theorem

      |- (a SUNTIL b) t0 ⇔
         ∃q.
           ¬q t0 ∧
           (∀t.
              ¬q (t + t0) ∧ a (t + t0) ∧ ¬b (t + t0) ∧ ¬q (t + (1 + t0)) ∨
              ¬q (t + t0) ∧ b (t + t0) ∧ q (t + (1 + t0)) ∨
              q (t + t0) ∧ q (t + (1 + t0))) ∧ ∃t1. ∀t2. q (t1 + (t2 + t0))

   [<a name="SWHEN_AS_CO_BUECHI-val"><b>SWHEN_AS_CO_BUECHI</b></a>]  Theorem

      |- (a SWHEN b) t0 ⇔
         ∃q.
           ¬q t0 ∧
           (∀t.
              ¬q (t + t0) ∧ ¬b (t + t0) ∧ ¬q (t + (1 + t0)) ∨
              ¬q (t + t0) ∧ a (t + t0) ∧ b (t + t0) ∧ q (t + (1 + t0)) ∨
              q (t + t0) ∧ q (t + (1 + t0))) ∧ ∃t1. ∀t2. q (t1 + (t2 + t0))

   [<a name="TEMP_OPS_DEFS_TO_OMEGA-val"><b>TEMP_OPS_DEFS_TO_OMEGA</b></a>]  Theorem

      |- ((l = NEXT a) ⇔ T ∧ (∀t. l t ⇔ a (SUC t)) ∧ T) ∧
         ((l = ALWAYS a) ⇔
          T ∧ (∀t. l t ⇔ a t ∧ l (SUC t)) ∧
          ∀t1. ∃t2. a (t1 + t2) ⇒ l (t1 + t2)) ∧
         ((l = EVENTUAL a) ⇔
          T ∧ (∀t. l t ⇔ a t ∨ l (SUC t)) ∧
          ∀t1. ∃t2. l (t1 + t2) ⇒ a (t1 + t2)) ∧
         ((l = a SUNTIL b) ⇔
          T ∧ (∀t. l t ⇔ ¬b t ⇒ a t ∧ l (SUC t)) ∧
          ∀t1. ∃t2. l (t1 + t2) ⇒ ¬a (t1 + t2) ∨ b (t1 + t2)) ∧
         ((l = a SWHEN b) ⇔
          T ∧ (∀t. l t ⇔ if b t then a t else l (SUC t)) ∧
          ∀t1. ∃t2. l (t1 + t2) ⇒ b (t1 + t2)) ∧
         ((l = a SBEFORE b) ⇔
          T ∧ (∀t. l t ⇔ ¬b t ∧ (a t ∨ l (SUC t))) ∧
          ∀t1. ∃t2. l (t1 + t2) ⇒ a (t1 + t2) ∨ b (t1 + t2)) ∧
         ((l = a UNTIL b) ⇔
          T ∧ (∀t. l t ⇔ ¬b t ⇒ a t ∧ l (SUC t)) ∧
          ∀t1. ∃t2. ¬l (t1 + t2) ⇒ ¬a (t1 + t2) ∨ b (t1 + t2)) ∧
         ((l = a WHEN b) ⇔
          T ∧ (∀t. l t ⇔ if b t then a t else l (SUC t)) ∧
          ∀t1. ∃t2. l (t1 + t2) ∨ b (t1 + t2)) ∧
         ((l = a BEFORE b) ⇔
          T ∧ (∀t. l t ⇔ ¬b t ∧ (a t ∨ l (SUC t))) ∧
          ∀t1. ∃t2. ¬l (t1 + t2) ⇒ a (t1 + t2) ∨ b (t1 + t2)) ∧
         ((l = PNEXT a) ⇔ (l 0 ⇔ T) ∧ (∀t. l (SUC t) ⇔ a t) ∧ T) ∧
         ((l = PSNEXT a) ⇔ (l 0 ⇔ F) ∧ (∀t. l (SUC t) ⇔ a t) ∧ T) ∧
         ((l = PNEXT (PALWAYS a)) ⇔
          (l 0 ⇔ T) ∧ (∀t. l (SUC t) ⇔ a t ∧ l t) ∧ T) ∧
         ((l = PSNEXT (PEVENTUAL a)) ⇔
          (l 0 ⇔ F) ∧ (∀t. l (SUC t) ⇔ a t ∨ l t) ∧ T) ∧
         ((l = PSNEXT (a PSUNTIL b)) ⇔
          (l 0 ⇔ F) ∧ (∀t. l (SUC t) ⇔ b t ∨ a t ∧ l t) ∧ T) ∧
         ((l = PSNEXT (a PSWHEN b)) ⇔
          (l 0 ⇔ F) ∧ (∀t. l (SUC t) ⇔ a t ∧ b t ∨ ¬b t ∧ l t) ∧ T) ∧
         ((l = PSNEXT (a PSBEFORE b)) ⇔
          (l 0 ⇔ F) ∧ (∀t. l (SUC t) ⇔ ¬b t ∧ (a t ∨ l t)) ∧ T) ∧
         ((l = PNEXT (a PUNTIL b)) ⇔
          (l 0 ⇔ T) ∧ (∀t. l (SUC t) ⇔ b t ∨ a t ∧ l t) ∧ T) ∧
         ((l = PNEXT (a PWHEN b)) ⇔
          (l 0 ⇔ T) ∧ (∀t. l (SUC t) ⇔ a t ∧ b t ∨ ¬b t ∧ l t) ∧ T) ∧
         ((l = PNEXT (a PBEFORE b)) ⇔
          (l 0 ⇔ T) ∧ (∀t. l (SUC t) ⇔ ¬b t ∧ (a t ∨ l t)) ∧ T)

   [<a name="UNTIL_AS_CO_BUECHI-val"><b>UNTIL_AS_CO_BUECHI</b></a>]  Theorem

      |- (a UNTIL b) t0 ⇔
         ∃q.
           ¬q t0 ∧
           (∀t.
              ¬q (t + t0) ∧ a (t + t0) ∧ ¬b (t + t0) ∧ ¬q (t + (1 + t0)) ∨
              ¬q (t + t0) ∧ b (t + t0) ∧ q (t + (1 + t0)) ∨
              q (t + t0) ∧ q (t + (1 + t0))) ∧
           ∃t1. ∀t2. ¬q (t1 + (t2 + t0)) ∨ q (t1 + (t2 + t0))

   [<a name="WHEN_AS_CO_BUECHI-val"><b>WHEN_AS_CO_BUECHI</b></a>]  Theorem

      |- (a WHEN b) t0 ⇔
         ∃q.
           ¬q t0 ∧
           (∀t.
              ¬q (t + t0) ∧ ¬b (t + t0) ∧ ¬q (t + (1 + t0)) ∨
              ¬q (t + t0) ∧ a (t + t0) ∧ b (t + t0) ∧ q (t + (1 + t0)) ∨
              q (t + t0) ∧ q (t + (1 + t0))) ∧
           ∃t1. ∀t2. ¬q (t1 + (t2 + t0)) ∨ q (t1 + (t2 + t0))


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/temporal/src/Omega_AutomataScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-10</a></em></p></body></html>
