<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure totoTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure totoTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/enumfset/totoScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature totoTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#ListOrd-val">ListOrd</a> : thm
<a name="line7"></a>    val <a href="#StrongLinearOrder_of_TO-val">StrongLinearOrder_of_TO</a> : thm
<a name="line8"></a>    val <a href="#TO_inv-val">TO_inv</a> : thm
<a name="line9"></a>    val <a href="#TO_of_LinearOrder-val">TO_of_LinearOrder</a> : thm
<a name="line10"></a>    val <a href="#TotOrd-val">TotOrd</a> : thm
<a name="line11"></a>    val <a href="#WeakLinearOrder_of_TO-val">WeakLinearOrder_of_TO</a> : thm
<a name="line12"></a>    val <a href="#charOrd-val">charOrd</a> : thm
<a name="line13"></a>    val <a href="#charto-val">charto</a> : thm
<a name="line14"></a>    val <a href="#cpn_BIJ-val">cpn_BIJ</a> : thm
<a name="line15"></a>    val <a href="#cpn_CASE-val">cpn_CASE</a> : thm
<a name="line16"></a>    val <a href="#cpn_TY_DEF-val">cpn_TY_DEF</a> : thm
<a name="line17"></a>    val <a href="#cpn_size_def-val">cpn_size_def</a> : thm
<a name="line18"></a>    val <a href="#imageOrd-val">imageOrd</a> : thm
<a name="line19"></a>    val <a href="#lexTO-val">lexTO</a> : thm
<a name="line20"></a>    val <a href="#lextoto-val">lextoto</a> : thm
<a name="line21"></a>    val <a href="#listorder_curried-val">listorder_curried</a> : thm
<a name="line22"></a>    val <a href="#listorder_tupled_primitive-val">listorder_tupled_primitive</a> : thm
<a name="line23"></a>    val <a href="#listoto-val">listoto</a> : thm
<a name="line24"></a>    val <a href="#numOrd-val">numOrd</a> : thm
<a name="line25"></a>    val <a href="#num_dtOrd_curried-val">num_dtOrd_curried</a> : thm
<a name="line26"></a>    val <a href="#num_dtOrd_tupled_primitive-val">num_dtOrd_tupled_primitive</a> : thm
<a name="line27"></a>    val <a href="#num_dt_TY_DEF-val">num_dt_TY_DEF</a> : thm
<a name="line28"></a>    val <a href="#num_dt_case_def-val">num_dt_case_def</a> : thm
<a name="line29"></a>    val <a href="#num_dt_size_def-val">num_dt_size_def</a> : thm
<a name="line30"></a>    val <a href="#num_to_dt_primitive-val">num_to_dt_primitive</a> : thm
<a name="line31"></a>    val <a href="#numto-val">numto</a> : thm
<a name="line32"></a>    val <a href="#qk_numOrd_def-val">qk_numOrd_def</a> : thm
<a name="line33"></a>    val <a href="#qk_numto-val">qk_numto</a> : thm
<a name="line34"></a>    val <a href="#stringto-val">stringto</a> : thm
<a name="line35"></a>    val <a href="#to_bij-val">to_bij</a> : thm
<a name="line36"></a>    val <a href="#toto_TY_DEF-val">toto_TY_DEF</a> : thm
<a name="line37"></a>    val <a href="#toto_inv-val">toto_inv</a> : thm
<a name="line38"></a>    val <a href="#toto_of_LinearOrder-val">toto_of_LinearOrder</a> : thm
<a name="line39"></a>
<a name="line40"></a>  (*  Theorems  *)
<a name="line41"></a>    val <a href="#NOT_EQ_LESS_IMP-val">NOT_EQ_LESS_IMP</a> : thm
<a name="line42"></a>    val <a href="#StrongOrder_ALT-val">StrongOrder_ALT</a> : thm
<a name="line43"></a>    val <a href="#TO_11-val">TO_11</a> : thm
<a name="line44"></a>    val <a href="#TO_apto_ID-val">TO_apto_ID</a> : thm
<a name="line45"></a>    val <a href="#TO_apto_TO_ID-val">TO_apto_TO_ID</a> : thm
<a name="line46"></a>    val <a href="#TO_apto_TO_IMP-val">TO_apto_TO_IMP</a> : thm
<a name="line47"></a>    val <a href="#TO_numOrd-val">TO_numOrd</a> : thm
<a name="line48"></a>    val <a href="#TO_onto-val">TO_onto</a> : thm
<a name="line49"></a>    val <a href="#TO_qk_numOrd-val">TO_qk_numOrd</a> : thm
<a name="line50"></a>    val <a href="#TO_refl-val">TO_refl</a> : thm
<a name="line51"></a>    val <a href="#TotOrd_TO_of_Strong-val">TotOrd_TO_of_Strong</a> : thm
<a name="line52"></a>    val <a href="#TotOrd_apto-val">TotOrd_apto</a> : thm
<a name="line53"></a>    val <a href="#all_cpn_distinct-val">all_cpn_distinct</a> : thm
<a name="line54"></a>    val <a href="#ap_qk_numto_thm-val">ap_qk_numto_thm</a> : thm
<a name="line55"></a>    val <a href="#apcharto_thm-val">apcharto_thm</a> : thm
<a name="line56"></a>    val <a href="#aplextoto-val">aplextoto</a> : thm
<a name="line57"></a>    val <a href="#aplistoto-val">aplistoto</a> : thm
<a name="line58"></a>    val <a href="#apnumto_thm-val">apnumto_thm</a> : thm
<a name="line59"></a>    val <a href="#charOrd_eq_lem-val">charOrd_eq_lem</a> : thm
<a name="line60"></a>    val <a href="#charOrd_gt_lem-val">charOrd_gt_lem</a> : thm
<a name="line61"></a>    val <a href="#charOrd_lt_lem-val">charOrd_lt_lem</a> : thm
<a name="line62"></a>    val <a href="#cpn2num_11-val">cpn2num_11</a> : thm
<a name="line63"></a>    val <a href="#cpn2num_ONTO-val">cpn2num_ONTO</a> : thm
<a name="line64"></a>    val <a href="#cpn2num_num2cpn-val">cpn2num_num2cpn</a> : thm
<a name="line65"></a>    val <a href="#cpn2num_thm-val">cpn2num_thm</a> : thm
<a name="line66"></a>    val <a href="#cpn_Axiom-val">cpn_Axiom</a> : thm
<a name="line67"></a>    val <a href="#cpn_EQ_cpn-val">cpn_EQ_cpn</a> : thm
<a name="line68"></a>    val <a href="#cpn_case_cong-val">cpn_case_cong</a> : thm
<a name="line69"></a>    val <a href="#cpn_case_def-val">cpn_case_def</a> : thm
<a name="line70"></a>    val <a href="#cpn_distinct-val">cpn_distinct</a> : thm
<a name="line71"></a>    val <a href="#cpn_induction-val">cpn_induction</a> : thm
<a name="line72"></a>    val <a href="#cpn_nchotomy-val">cpn_nchotomy</a> : thm
<a name="line73"></a>    val <a href="#datatype_cpn-val">datatype_cpn</a> : thm
<a name="line74"></a>    val <a href="#datatype_num_dt-val">datatype_num_dt</a> : thm
<a name="line75"></a>    val <a href="#listorder-val">listorder</a> : thm
<a name="line76"></a>    val <a href="#listorder_ind-val">listorder_ind</a> : thm
<a name="line77"></a>    val <a href="#num2cpn_11-val">num2cpn_11</a> : thm
<a name="line78"></a>    val <a href="#num2cpn_ONTO-val">num2cpn_ONTO</a> : thm
<a name="line79"></a>    val <a href="#num2cpn_cpn2num-val">num2cpn_cpn2num</a> : thm
<a name="line80"></a>    val <a href="#num2cpn_thm-val">num2cpn_thm</a> : thm
<a name="line81"></a>    val <a href="#num_dtOrd-val">num_dtOrd</a> : thm
<a name="line82"></a>    val <a href="#num_dtOrd_ind-val">num_dtOrd_ind</a> : thm
<a name="line83"></a>    val <a href="#num_dt_11-val">num_dt_11</a> : thm
<a name="line84"></a>    val <a href="#num_dt_Axiom-val">num_dt_Axiom</a> : thm
<a name="line85"></a>    val <a href="#num_dt_case_cong-val">num_dt_case_cong</a> : thm
<a name="line86"></a>    val <a href="#num_dt_distinct-val">num_dt_distinct</a> : thm
<a name="line87"></a>    val <a href="#num_dt_induction-val">num_dt_induction</a> : thm
<a name="line88"></a>    val <a href="#num_dt_nchotomy-val">num_dt_nchotomy</a> : thm
<a name="line89"></a>    val <a href="#numeralOrd-val">numeralOrd</a> : thm
<a name="line90"></a>    val <a href="#onto_apto-val">onto_apto</a> : thm
<a name="line91"></a>    val <a href="#qk_numeralOrd-val">qk_numeralOrd</a> : thm
<a name="line92"></a>    val <a href="#totoEEtrans-val">totoEEtrans</a> : thm
<a name="line93"></a>    val <a href="#totoELtrans-val">totoELtrans</a> : thm
<a name="line94"></a>    val <a href="#totoGGtrans-val">totoGGtrans</a> : thm
<a name="line95"></a>    val <a href="#totoGLtrans-val">totoGLtrans</a> : thm
<a name="line96"></a>    val <a href="#totoLEtrans-val">totoLEtrans</a> : thm
<a name="line97"></a>    val <a href="#totoLGtrans-val">totoLGtrans</a> : thm
<a name="line98"></a>    val <a href="#totoLLtrans-val">totoLLtrans</a> : thm
<a name="line99"></a>    val <a href="#toto_antisym-val">toto_antisym</a> : thm
<a name="line100"></a>    val <a href="#toto_cpn_eqn-val">toto_cpn_eqn</a> : thm
<a name="line101"></a>    val <a href="#toto_equal_eq-val">toto_equal_eq</a> : thm
<a name="line102"></a>    val <a href="#toto_equal_imp-val">toto_equal_imp</a> : thm
<a name="line103"></a>    val <a href="#toto_equal_imp_eq-val">toto_equal_imp_eq</a> : thm
<a name="line104"></a>    val <a href="#toto_equal_sym-val">toto_equal_sym</a> : thm
<a name="line105"></a>    val <a href="#toto_glneq-val">toto_glneq</a> : thm
<a name="line106"></a>    val <a href="#toto_not_less_refl-val">toto_not_less_refl</a> : thm
<a name="line107"></a>    val <a href="#toto_refl-val">toto_refl</a> : thm
<a name="line108"></a>    val <a href="#toto_swap_cases-val">toto_swap_cases</a> : thm
<a name="line109"></a>    val <a href="#toto_trans_less-val">toto_trans_less</a> : thm
<a name="line110"></a>    val <a href="#toto_unequal_imp-val">toto_unequal_imp</a> : thm
<a name="line111"></a>
<a name="line112"></a>  val toto_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line113"></a>(*
   [string] Parent theory of "toto"

   [wot] Parent theory of "toto"

   [<a name="ListOrd-val"><b>ListOrd</b></a>]  Definition

      |- !c.
           ListOrd c =
           TO_of_LinearOrder (listorder (StrongLinearOrder_of_TO (apto c)))

   [<a name="StrongLinearOrder_of_TO-val"><b>StrongLinearOrder_of_TO</b></a>]  Definition

      |- !c x y.
           StrongLinearOrder_of_TO c x y &lt;=&gt;
           case c x y of LESS =&gt; T | _ =&gt; F

   [<a name="TO_inv-val"><b>TO_inv</b></a>]  Definition

      |- !c x y. TO_inv c x y = c y x

   [<a name="TO_of_LinearOrder-val"><b>TO_of_LinearOrder</b></a>]  Definition

      |- !r x y.
           TO_of_LinearOrder r x y =
           if x = y then EQUAL else if r x y then LESS else GREATER

   [<a name="TotOrd-val"><b>TotOrd</b></a>]  Definition

      |- !c.
           TotOrd c &lt;=&gt;
           (!x y. (c x y = EQUAL) &lt;=&gt; (x = y)) /\
           (!x y. (c x y = GREATER) &lt;=&gt; (c y x = LESS)) /\
           !x y z. (c x y = LESS) /\ (c y z = LESS) ==&gt; (c x z = LESS)

   [<a name="WeakLinearOrder_of_TO-val"><b>WeakLinearOrder_of_TO</b></a>]  Definition

      |- !c x y.
           WeakLinearOrder_of_TO c x y &lt;=&gt;
           case c x y of GREATER =&gt; F | _ =&gt; T

   [<a name="charOrd-val"><b>charOrd</b></a>]  Definition

      |- !a b. charOrd a b = numOrd (ORD a) (ORD b)

   [<a name="charto-val"><b>charto</b></a>]  Definition

      |- charto = TO charOrd

   [<a name="cpn_BIJ-val"><b>cpn_BIJ</b></a>]  Definition

      |- (!a. num2cpn (cpn2num a) = a) /\
         !r. (\n. n &lt; 3) r &lt;=&gt; (cpn2num (num2cpn r) = r)

   [<a name="cpn_CASE-val"><b>cpn_CASE</b></a>]  Definition

      |- !x v0 v1 v2.
           (case x of LESS =&gt; v0 | EQUAL =&gt; v1 | GREATER =&gt; v2) =
           (\m. if m &lt; 1 then v0 else if m = 1 then v1 else v2) (cpn2num x)

   [<a name="cpn_TY_DEF-val"><b>cpn_TY_DEF</b></a>]  Definition

      |- ?rep. TYPE_DEFINITION (\n. n &lt; 3) rep

   [<a name="cpn_size_def-val"><b>cpn_size_def</b></a>]  Definition

      |- !x. cpn_size x = 0

   [<a name="imageOrd-val"><b>imageOrd</b></a>]  Definition

      |- !f cp a b. imageOrd f cp a b = cp (f a) (f b)

   [<a name="lexTO-val"><b>lexTO</b></a>]  Definition

      |- !R V.
           R lexTO V =
           TO_of_LinearOrder
             (StrongLinearOrder_of_TO R LEX StrongLinearOrder_of_TO V)

   [<a name="lextoto-val"><b>lextoto</b></a>]  Definition

      |- !c v. c lextoto v = TO (apto c lexTO apto v)

   [<a name="listorder_curried-val"><b>listorder_curried</b></a>]  Definition

      |- !x x1 x2. listorder x x1 x2 &lt;=&gt; listorder_tupled (x,x1,x2)

   [<a name="listorder_tupled_primitive-val"><b>listorder_tupled_primitive</b></a>]  Definition

      |- listorder_tupled =
         WFREC (@R. WF R /\ !s r m l V. R (V,l,m) (V,r::l,s::m))
           (\listorder_tupled a.
              case a of
                (V,l,[]) =&gt; I F
              | (V,[],s::m) =&gt; I T
              | (V,r::l',s::m) =&gt;
                  I (V r s \/ (r = s) /\ listorder_tupled (V,l',m)))

   [<a name="listoto-val"><b>listoto</b></a>]  Definition

      |- !c. listoto c = TO (ListOrd c)

   [<a name="numOrd-val"><b>numOrd</b></a>]  Definition

      |- numOrd = TO_of_LinearOrder $&lt;

   [<a name="num_dtOrd_curried-val"><b>num_dtOrd_curried</b></a>]  Definition

      |- !x x1. num_dtOrd x x1 = num_dtOrd_tupled (x,x1)

   [<a name="num_dtOrd_tupled_primitive-val"><b>num_dtOrd_tupled_primitive</b></a>]  Definition

      |- num_dtOrd_tupled =
         WFREC
           (@R.
              WF R /\ (!y x. R (x,y) (bit1 x,bit1 y)) /\
              !y x. R (x,y) (bit2 x,bit2 y))
           (\num_dtOrd_tupled a.
              case a of
                (zer,zer) =&gt; I EQUAL
              | (zer,bit1 x) =&gt; I LESS
              | (zer,bit2 x') =&gt; I LESS
              | (bit1 x'',zer) =&gt; I GREATER
              | (bit1 x'',bit1 y'') =&gt; I (num_dtOrd_tupled (x'',y''))
              | (bit1 x'',bit2 y) =&gt; I LESS
              | (bit2 x''',zer) =&gt; I GREATER
              | (bit2 x''',bit1 y') =&gt; I GREATER
              | (bit2 x''',bit2 y''') =&gt; I (num_dtOrd_tupled (x''',y''')))

   [<a name="num_dt_TY_DEF-val"><b>num_dt_TY_DEF</b></a>]  Definition

      |- ?rep.
           TYPE_DEFINITION
             (\a0.
                !'num_dt' .
                  (!a0.
                     (a0 = ind_type$CONSTR 0 ARB (\n. ind_type$BOTTOM)) \/
                     (?a.
                        (a0 =
                         (\a.
                            ind_type$CONSTR (SUC 0) ARB
                              (ind_type$FCONS a (\n. ind_type$BOTTOM)))
                           a) /\ 'num_dt' a) \/
                     (?a.
                        (a0 =
                         (\a.
                            ind_type$CONSTR (SUC (SUC 0)) ARB
                              (ind_type$FCONS a (\n. ind_type$BOTTOM)))
                           a) /\ 'num_dt' a) ==&gt;
                     'num_dt' a0) ==&gt;
                  'num_dt' a0) rep

   [<a name="num_dt_case_def-val"><b>num_dt_case_def</b></a>]  Definition

      |- (!v f f1. num_dt_CASE zer v f f1 = v) /\
         (!a v f f1. num_dt_CASE (bit1 a) v f f1 = f a) /\
         !a v f f1. num_dt_CASE (bit2 a) v f f1 = f1 a

   [<a name="num_dt_size_def-val"><b>num_dt_size_def</b></a>]  Definition

      |- (num_dt_size zer = 0) /\
         (!a. num_dt_size (bit1 a) = 1 + num_dt_size a) /\
         !a. num_dt_size (bit2 a) = 1 + num_dt_size a

   [<a name="num_to_dt_primitive-val"><b>num_to_dt_primitive</b></a>]  Definition

      |- num_to_dt =
         WFREC
           (@R.
              WF R /\ (!n. n &lt;&gt; 0 /\ ODD n ==&gt; R (DIV2 (n - 1)) n) /\
              !n. n &lt;&gt; 0 /\ ~ODD n ==&gt; R (DIV2 (n - 2)) n)
           (\num_to_dt n.
              I
                (if n = 0 then zer
                 else if ODD n then bit1 (num_to_dt (DIV2 (n - 1)))
                 else bit2 (num_to_dt (DIV2 (n - 2)))))

   [<a name="numto-val"><b>numto</b></a>]  Definition

      |- numto = TO numOrd

   [<a name="qk_numOrd_def-val"><b>qk_numOrd_def</b></a>]  Definition

      |- !m n. qk_numOrd m n = num_dtOrd (num_to_dt m) (num_to_dt n)

   [<a name="qk_numto-val"><b>qk_numto</b></a>]  Definition

      |- qk_numto = TO qk_numOrd

   [<a name="stringto-val"><b>stringto</b></a>]  Definition

      |- stringto = listoto charto

   [<a name="to_bij-val"><b>to_bij</b></a>]  Definition

      |- (!a. TO (apto a) = a) /\ !r. TotOrd r &lt;=&gt; (apto (TO r) = r)

   [<a name="toto_TY_DEF-val"><b>toto_TY_DEF</b></a>]  Definition

      |- ?rep. TYPE_DEFINITION TotOrd rep

   [<a name="toto_inv-val"><b>toto_inv</b></a>]  Definition

      |- !c. toto_inv c = TO (TO_inv (apto c))

   [<a name="toto_of_LinearOrder-val"><b>toto_of_LinearOrder</b></a>]  Definition

      |- !r. toto_of_LinearOrder r = TO (TO_of_LinearOrder r)

   [<a name="NOT_EQ_LESS_IMP-val"><b>NOT_EQ_LESS_IMP</b></a>]  Theorem

      |- !cmp x y.
           apto cmp x y &lt;&gt; LESS ==&gt; (x = y) \/ (apto cmp y x = LESS)

   [<a name="StrongOrder_ALT-val"><b>StrongOrder_ALT</b></a>]  Theorem

      |- !Z. StrongOrder Z &lt;=&gt; irreflexive Z /\ transitive Z

   [<a name="TO_11-val"><b>TO_11</b></a>]  Theorem

      |- !r r'. TotOrd r ==&gt; TotOrd r' ==&gt; ((TO r = TO r') &lt;=&gt; (r = r'))

   [<a name="TO_apto_ID-val"><b>TO_apto_ID</b></a>]  Theorem

      |- !a. TO (apto a) = a

   [<a name="TO_apto_TO_ID-val"><b>TO_apto_TO_ID</b></a>]  Theorem

      |- !r. TotOrd r &lt;=&gt; (apto (TO r) = r)

   [<a name="TO_apto_TO_IMP-val"><b>TO_apto_TO_IMP</b></a>]  Theorem

      |- !r. TotOrd r ==&gt; (apto (TO r) = r)

   [<a name="TO_numOrd-val"><b>TO_numOrd</b></a>]  Theorem

      |- TotOrd numOrd

   [<a name="TO_onto-val"><b>TO_onto</b></a>]  Theorem

      |- !a. ?r. (a = TO r) /\ TotOrd r

   [<a name="TO_qk_numOrd-val"><b>TO_qk_numOrd</b></a>]  Theorem

      |- TotOrd qk_numOrd

   [<a name="TO_refl-val"><b>TO_refl</b></a>]  Theorem

      |- !c. TotOrd c ==&gt; !x. c x x = EQUAL

   [<a name="TotOrd_TO_of_Strong-val"><b>TotOrd_TO_of_Strong</b></a>]  Theorem

      |- !r. StrongLinearOrder r ==&gt; TotOrd (TO_of_LinearOrder r)

   [<a name="TotOrd_apto-val"><b>TotOrd_apto</b></a>]  Theorem

      |- !c. TotOrd (apto c)

   [<a name="all_cpn_distinct-val"><b>all_cpn_distinct</b></a>]  Theorem

      |- (LESS &lt;&gt; EQUAL /\ LESS &lt;&gt; GREATER /\ EQUAL &lt;&gt; GREATER) /\
         EQUAL &lt;&gt; LESS /\ GREATER &lt;&gt; LESS /\ GREATER &lt;&gt; EQUAL

   [<a name="ap_qk_numto_thm-val"><b>ap_qk_numto_thm</b></a>]  Theorem

      |- apto qk_numto = qk_numOrd

   [<a name="apcharto_thm-val"><b>apcharto_thm</b></a>]  Theorem

      |- apto charto = charOrd

   [<a name="aplextoto-val"><b>aplextoto</b></a>]  Theorem

      |- !c v x1 x2 y1 y2.
           apto (c lextoto v) (x1,x2) (y1,y2) =
           case apto c x1 y1 of
             LESS =&gt; LESS
           | EQUAL =&gt; apto v x2 y2
           | GREATER =&gt; GREATER

   [<a name="aplistoto-val"><b>aplistoto</b></a>]  Theorem

      |- !c.
           (apto (listoto c) [] [] = EQUAL) /\
           (!b y. apto (listoto c) [] (b::y) = LESS) /\
           (!a x. apto (listoto c) (a::x) [] = GREATER) /\
           !a x b y.
             apto (listoto c) (a::x) (b::y) =
             case apto c a b of
               LESS =&gt; LESS
             | EQUAL =&gt; apto (listoto c) x y
             | GREATER =&gt; GREATER

   [<a name="apnumto_thm-val"><b>apnumto_thm</b></a>]  Theorem

      |- apto numto = numOrd

   [<a name="charOrd_eq_lem-val"><b>charOrd_eq_lem</b></a>]  Theorem

      |- !a b. (numOrd a b = EQUAL) ==&gt; (charOrd (CHR a) (CHR b) = EQUAL)

   [<a name="charOrd_gt_lem-val"><b>charOrd_gt_lem</b></a>]  Theorem

      |- !a b.
           (numOrd a b = GREATER) ==&gt;
           (a &lt; 256 &lt;=&gt; T) ==&gt;
           (charOrd (CHR a) (CHR b) = GREATER)

   [<a name="charOrd_lt_lem-val"><b>charOrd_lt_lem</b></a>]  Theorem

      |- !a b.
           (numOrd a b = LESS) ==&gt;
           (b &lt; 256 &lt;=&gt; T) ==&gt;
           (charOrd (CHR a) (CHR b) = LESS)

   [<a name="cpn2num_11-val"><b>cpn2num_11</b></a>]  Theorem

      |- !a a'. (cpn2num a = cpn2num a') &lt;=&gt; (a = a')

   [<a name="cpn2num_ONTO-val"><b>cpn2num_ONTO</b></a>]  Theorem

      |- !r. r &lt; 3 &lt;=&gt; ?a. r = cpn2num a

   [<a name="cpn2num_num2cpn-val"><b>cpn2num_num2cpn</b></a>]  Theorem

      |- !r. r &lt; 3 &lt;=&gt; (cpn2num (num2cpn r) = r)

   [<a name="cpn2num_thm-val"><b>cpn2num_thm</b></a>]  Theorem

      |- (cpn2num LESS = 0) /\ (cpn2num EQUAL = 1) /\ (cpn2num GREATER = 2)

   [<a name="cpn_Axiom-val"><b>cpn_Axiom</b></a>]  Theorem

      |- !x0 x1 x2. ?f. (f LESS = x0) /\ (f EQUAL = x1) /\ (f GREATER = x2)

   [<a name="cpn_EQ_cpn-val"><b>cpn_EQ_cpn</b></a>]  Theorem

      |- !a a'. (a = a') &lt;=&gt; (cpn2num a = cpn2num a')

   [<a name="cpn_case_cong-val"><b>cpn_case_cong</b></a>]  Theorem

      |- !M M' v0 v1 v2.
           (M = M') /\ ((M' = LESS) ==&gt; (v0 = v0')) /\
           ((M' = EQUAL) ==&gt; (v1 = v1')) /\
           ((M' = GREATER) ==&gt; (v2 = v2')) ==&gt;
           ((case M of LESS =&gt; v0 | EQUAL =&gt; v1 | GREATER =&gt; v2) =
            case M' of LESS =&gt; v0' | EQUAL =&gt; v1' | GREATER =&gt; v2')

   [<a name="cpn_case_def-val"><b>cpn_case_def</b></a>]  Theorem

      |- (!v0 v1 v2.
            (case LESS of LESS =&gt; v0 | EQUAL =&gt; v1 | GREATER =&gt; v2) =
            v0) /\
         (!v0 v1 v2.
            (case EQUAL of LESS =&gt; v0 | EQUAL =&gt; v1 | GREATER =&gt; v2) =
            v1) /\
         !v0 v1 v2.
           (case GREATER of LESS =&gt; v0 | EQUAL =&gt; v1 | GREATER =&gt; v2) = v2

   [<a name="cpn_distinct-val"><b>cpn_distinct</b></a>]  Theorem

      |- LESS &lt;&gt; EQUAL /\ LESS &lt;&gt; GREATER /\ EQUAL &lt;&gt; GREATER

   [<a name="cpn_induction-val"><b>cpn_induction</b></a>]  Theorem

      |- !P. P EQUAL /\ P GREATER /\ P LESS ==&gt; !a. P a

   [<a name="cpn_nchotomy-val"><b>cpn_nchotomy</b></a>]  Theorem

      |- !a. (a = LESS) \/ (a = EQUAL) \/ (a = GREATER)

   [<a name="datatype_cpn-val"><b>datatype_cpn</b></a>]  Theorem

      |- DATATYPE (cpn LESS EQUAL GREATER)

   [<a name="datatype_num_dt-val"><b>datatype_num_dt</b></a>]  Theorem

      |- DATATYPE (num_dt zer bit1 bit2)

   [<a name="listorder-val"><b>listorder</b></a>]  Theorem

      |- (!l V. listorder V l [] &lt;=&gt; F) /\
         (!s m V. listorder V [] (s::m) &lt;=&gt; T) /\
         !s r m l V.
           listorder V (r::l) (s::m) &lt;=&gt;
           V r s \/ (r = s) /\ listorder V l m

   [<a name="listorder_ind-val"><b>listorder_ind</b></a>]  Theorem

      |- !P.
           (!V l. P V l []) /\ (!V s m. P V [] (s::m)) /\
           (!V r l s m. P V l m ==&gt; P V (r::l) (s::m)) ==&gt;
           !v v1 v2. P v v1 v2

   [<a name="num2cpn_11-val"><b>num2cpn_11</b></a>]  Theorem

      |- !r r'.
           r &lt; 3 ==&gt; r' &lt; 3 ==&gt; ((num2cpn r = num2cpn r') &lt;=&gt; (r = r'))

   [<a name="num2cpn_ONTO-val"><b>num2cpn_ONTO</b></a>]  Theorem

      |- !a. ?r. (a = num2cpn r) /\ r &lt; 3

   [<a name="num2cpn_cpn2num-val"><b>num2cpn_cpn2num</b></a>]  Theorem

      |- !a. num2cpn (cpn2num a) = a

   [<a name="num2cpn_thm-val"><b>num2cpn_thm</b></a>]  Theorem

      |- (num2cpn 0 = LESS) /\ (num2cpn 1 = EQUAL) /\ (num2cpn 2 = GREATER)

   [<a name="num_dtOrd-val"><b>num_dtOrd</b></a>]  Theorem

      |- (num_dtOrd zer zer = EQUAL) /\
         (!x. num_dtOrd zer (bit1 x) = LESS) /\
         (!x. num_dtOrd zer (bit2 x) = LESS) /\
         (!x. num_dtOrd (bit1 x) zer = GREATER) /\
         (!x. num_dtOrd (bit2 x) zer = GREATER) /\
         (!y x. num_dtOrd (bit1 x) (bit2 y) = LESS) /\
         (!y x. num_dtOrd (bit2 x) (bit1 y) = GREATER) /\
         (!y x. num_dtOrd (bit1 x) (bit1 y) = num_dtOrd x y) /\
         !y x. num_dtOrd (bit2 x) (bit2 y) = num_dtOrd x y

   [<a name="num_dtOrd_ind-val"><b>num_dtOrd_ind</b></a>]  Theorem

      |- !P.
           P zer zer /\ (!x. P zer (bit1 x)) /\ (!x. P zer (bit2 x)) /\
           (!x. P (bit1 x) zer) /\ (!x. P (bit2 x) zer) /\
           (!x y. P (bit1 x) (bit2 y)) /\ (!x y. P (bit2 x) (bit1 y)) /\
           (!x y. P x y ==&gt; P (bit1 x) (bit1 y)) /\
           (!x y. P x y ==&gt; P (bit2 x) (bit2 y)) ==&gt;
           !v v1. P v v1

   [<a name="num_dt_11-val"><b>num_dt_11</b></a>]  Theorem

      |- (!a a'. (bit1 a = bit1 a') &lt;=&gt; (a = a')) /\
         !a a'. (bit2 a = bit2 a') &lt;=&gt; (a = a')

   [<a name="num_dt_Axiom-val"><b>num_dt_Axiom</b></a>]  Theorem

      |- !f0 f1 f2.
           ?fn.
             (fn zer = f0) /\ (!a. fn (bit1 a) = f1 a (fn a)) /\
             !a. fn (bit2 a) = f2 a (fn a)

   [<a name="num_dt_case_cong-val"><b>num_dt_case_cong</b></a>]  Theorem

      |- !M M' v f f1.
           (M = M') /\ ((M' = zer) ==&gt; (v = v')) /\
           (!a. (M' = bit1 a) ==&gt; (f a = f' a)) /\
           (!a. (M' = bit2 a) ==&gt; (f1 a = f1' a)) ==&gt;
           (num_dt_CASE M v f f1 = num_dt_CASE M' v' f' f1')

   [<a name="num_dt_distinct-val"><b>num_dt_distinct</b></a>]  Theorem

      |- (!a. zer &lt;&gt; bit1 a) /\ (!a. zer &lt;&gt; bit2 a) /\
         !a' a. bit1 a &lt;&gt; bit2 a'

   [<a name="num_dt_induction-val"><b>num_dt_induction</b></a>]  Theorem

      |- !P.
           P zer /\ (!n. P n ==&gt; P (bit1 n)) /\
           (!n. P n ==&gt; P (bit2 n)) ==&gt;
           !n. P n

   [<a name="num_dt_nchotomy-val"><b>num_dt_nchotomy</b></a>]  Theorem

      |- !nn. (nn = zer) \/ (?n. nn = bit1 n) \/ ?n. nn = bit2 n

   [<a name="numeralOrd-val"><b>numeralOrd</b></a>]  Theorem

      |- !x y.
           (numOrd ZERO ZERO = EQUAL) /\ (numOrd ZERO (BIT1 y) = LESS) /\
           (numOrd ZERO (BIT2 y) = LESS) /\
           (numOrd (BIT1 x) ZERO = GREATER) /\
           (numOrd (BIT2 x) ZERO = GREATER) /\
           (numOrd (BIT1 x) (BIT1 y) = numOrd x y) /\
           (numOrd (BIT2 x) (BIT2 y) = numOrd x y) /\
           (numOrd (BIT1 x) (BIT2 y) =
            case numOrd x y of GREATER =&gt; GREATER | _ =&gt; LESS) /\
           (numOrd (BIT2 x) (BIT1 y) =
            case numOrd x y of LESS =&gt; LESS | _ =&gt; GREATER)

   [<a name="onto_apto-val"><b>onto_apto</b></a>]  Theorem

      |- !r. TotOrd r &lt;=&gt; ?a. r = apto a

   [<a name="qk_numeralOrd-val"><b>qk_numeralOrd</b></a>]  Theorem

      |- !x y.
           (qk_numOrd ZERO ZERO = EQUAL) /\
           (qk_numOrd ZERO (BIT1 y) = LESS) /\
           (qk_numOrd ZERO (BIT2 y) = LESS) /\
           (qk_numOrd (BIT1 x) ZERO = GREATER) /\
           (qk_numOrd (BIT2 x) ZERO = GREATER) /\
           (qk_numOrd (BIT1 x) (BIT1 y) = qk_numOrd x y) /\
           (qk_numOrd (BIT2 x) (BIT2 y) = qk_numOrd x y) /\
           (qk_numOrd (BIT1 x) (BIT2 y) = LESS) /\
           (qk_numOrd (BIT2 x) (BIT1 y) = GREATER)

   [<a name="totoEEtrans-val"><b>totoEEtrans</b></a>]  Theorem

      |- !c x y z.
           ((apto c x y = EQUAL) /\ (apto c y z = EQUAL) ==&gt;
            (apto c x z = EQUAL)) /\
           ((apto c x y = EQUAL) /\ (apto c z y = EQUAL) ==&gt;
            (apto c x z = EQUAL))

   [<a name="totoELtrans-val"><b>totoELtrans</b></a>]  Theorem

      |- !c x y z.
           (apto c x y = EQUAL) /\ (apto c y z = LESS) ==&gt;
           (apto c x z = LESS)

   [<a name="totoGGtrans-val"><b>totoGGtrans</b></a>]  Theorem

      |- !c x y z.
           (apto c y x = GREATER) /\ (apto c z y = GREATER) ==&gt;
           (apto c x z = LESS)

   [<a name="totoGLtrans-val"><b>totoGLtrans</b></a>]  Theorem

      |- !c x y z.
           (apto c y x = GREATER) /\ (apto c y z = LESS) ==&gt;
           (apto c x z = LESS)

   [<a name="totoLEtrans-val"><b>totoLEtrans</b></a>]  Theorem

      |- !c x y z.
           (apto c x y = LESS) /\ (apto c y z = EQUAL) ==&gt;
           (apto c x z = LESS)

   [<a name="totoLGtrans-val"><b>totoLGtrans</b></a>]  Theorem

      |- !c x y z.
           (apto c x y = LESS) /\ (apto c z y = GREATER) ==&gt;
           (apto c x z = LESS)

   [<a name="totoLLtrans-val"><b>totoLLtrans</b></a>]  Theorem

      |- !c x y z.
           (apto c x y = LESS) /\ (apto c y z = LESS) ==&gt;
           (apto c x z = LESS)

   [<a name="toto_antisym-val"><b>toto_antisym</b></a>]  Theorem

      |- !c x y. (apto c x y = GREATER) &lt;=&gt; (apto c y x = LESS)

   [<a name="toto_cpn_eqn-val"><b>toto_cpn_eqn</b></a>]  Theorem

      |- (!c x y. (apto c x y = EQUAL) ==&gt; (x = y)) /\
         (!c x y. (apto c x y = LESS) ==&gt; x &lt;&gt; y) /\
         !c x y. (apto c x y = GREATER) ==&gt; x &lt;&gt; y

   [<a name="toto_equal_eq-val"><b>toto_equal_eq</b></a>]  Theorem

      |- !c x y. (apto c x y = EQUAL) &lt;=&gt; (x = y)

   [<a name="toto_equal_imp-val"><b>toto_equal_imp</b></a>]  Theorem

      |- !cmp phi.
           LinearOrder phi /\ (cmp = toto_of_LinearOrder phi) ==&gt;
           !x y. ((x = y) &lt;=&gt; T) ==&gt; (apto cmp x y = EQUAL)

   [<a name="toto_equal_imp_eq-val"><b>toto_equal_imp_eq</b></a>]  Theorem

      |- !c x y. (apto c x y = EQUAL) ==&gt; (x = y)

   [<a name="toto_equal_sym-val"><b>toto_equal_sym</b></a>]  Theorem

      |- !c x y. (apto c x y = EQUAL) &lt;=&gt; (apto c y x = EQUAL)

   [<a name="toto_glneq-val"><b>toto_glneq</b></a>]  Theorem

      |- (!c x y. (apto c x y = LESS) ==&gt; x &lt;&gt; y) /\
         !c x y. (apto c x y = GREATER) ==&gt; x &lt;&gt; y

   [<a name="toto_not_less_refl-val"><b>toto_not_less_refl</b></a>]  Theorem

      |- !cmp h. (apto cmp h h = LESS) &lt;=&gt; F

   [<a name="toto_refl-val"><b>toto_refl</b></a>]  Theorem

      |- !c x. apto c x x = EQUAL

   [<a name="toto_swap_cases-val"><b>toto_swap_cases</b></a>]  Theorem

      |- !c x y.
           apto c y x =
           case apto c x y of
             LESS =&gt; GREATER
           | EQUAL =&gt; EQUAL
           | GREATER =&gt; LESS

   [<a name="toto_trans_less-val"><b>toto_trans_less</b></a>]  Theorem

      |- (!c x y z.
            (apto c x y = LESS) /\ (apto c y z = LESS) ==&gt;
            (apto c x z = LESS)) /\
         (!c x y z.
            (apto c x y = LESS) /\ (apto c z y = GREATER) ==&gt;
            (apto c x z = LESS)) /\
         (!c x y z.
            (apto c y x = GREATER) /\ (apto c z y = GREATER) ==&gt;
            (apto c x z = LESS)) /\
         (!c x y z.
            (apto c y x = GREATER) /\ (apto c y z = LESS) ==&gt;
            (apto c x z = LESS)) /\
         (!c x y z.
            (apto c x y = LESS) /\ (apto c y z = EQUAL) ==&gt;
            (apto c x z = LESS)) /\
         !c x y z.
           (apto c x y = EQUAL) /\ (apto c y z = LESS) ==&gt;
           (apto c x z = LESS)

   [<a name="toto_unequal_imp-val"><b>toto_unequal_imp</b></a>]  Theorem

      |- !cmp phi.
           LinearOrder phi /\ (cmp = toto_of_LinearOrder phi) ==&gt;
           !x y.
             ((x = y) &lt;=&gt; F) ==&gt;
             if phi x y then apto cmp x y = LESS
             else apto cmp x y = GREATER


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/enumfset/totoScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-10</a></em></p></body></html>
