<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure enumeralTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure enumeralTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/enumfset/enumeralScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature enumeralTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#BL_ACCUM-val">BL_ACCUM</a> : thm
<a name="line7"></a>    val <a href="#BL_CONS-val">BL_CONS</a> : thm
<a name="line8"></a>    val <a href="#K2-val">K2</a> : thm
<a name="line9"></a>    val <a href="#LESS_ALL-val">LESS_ALL</a> : thm
<a name="line10"></a>    val <a href="#OL-val">OL</a> : thm
<a name="line11"></a>    val <a href="#OL_bt-val">OL_bt</a> : thm
<a name="line12"></a>    val <a href="#OL_bt_lb-val">OL_bt_lb</a> : thm
<a name="line13"></a>    val <a href="#OL_bt_lb_ub-val">OL_bt_lb_ub</a> : thm
<a name="line14"></a>    val <a href="#OL_bt_ub-val">OL_bt_ub</a> : thm
<a name="line15"></a>    val <a href="#OL_sublists_curried-val">OL_sublists_curried</a> : thm
<a name="line16"></a>    val <a href="#OL_sublists_tupled_primitive-val">OL_sublists_tupled_primitive</a> : thm
<a name="line17"></a>    val <a href="#OU-val">OU</a> : thm
<a name="line18"></a>    val <a href="#OWL-val">OWL</a> : thm
<a name="line19"></a>    val <a href="#UO-val">UO</a> : thm
<a name="line20"></a>    val <a href="#bl_TY_DEF-val">bl_TY_DEF</a> : thm
<a name="line21"></a>    val <a href="#bl_case_def-val">bl_case_def</a> : thm
<a name="line22"></a>    val <a href="#bl_rev-val">bl_rev</a> : thm
<a name="line23"></a>    val <a href="#bl_size_def-val">bl_size_def</a> : thm
<a name="line24"></a>    val <a href="#bl_to_bt-val">bl_to_bt</a> : thm
<a name="line25"></a>    val <a href="#bl_to_set-val">bl_to_set</a> : thm
<a name="line26"></a>    val <a href="#bt_TY_DEF-val">bt_TY_DEF</a> : thm
<a name="line27"></a>    val <a href="#bt_rev-val">bt_rev</a> : thm
<a name="line28"></a>    val <a href="#bt_size_def-val">bt_size_def</a> : thm
<a name="line29"></a>    val <a href="#bt_to_bl-val">bt_to_bl</a> : thm
<a name="line30"></a>    val <a href="#bt_to_list-val">bt_to_list</a> : thm
<a name="line31"></a>    val <a href="#bt_to_list_ac-val">bt_to_list_ac</a> : thm
<a name="line32"></a>    val <a href="#bt_to_ol-val">bt_to_ol</a> : thm
<a name="line33"></a>    val <a href="#bt_to_ol_ac-val">bt_to_ol_ac</a> : thm
<a name="line34"></a>    val <a href="#bt_to_ol_lb-val">bt_to_ol_lb</a> : thm
<a name="line35"></a>    val <a href="#bt_to_ol_lb_ac-val">bt_to_ol_lb_ac</a> : thm
<a name="line36"></a>    val <a href="#bt_to_ol_lb_ub-val">bt_to_ol_lb_ub</a> : thm
<a name="line37"></a>    val <a href="#bt_to_ol_lb_ub_ac-val">bt_to_ol_lb_ub_ac</a> : thm
<a name="line38"></a>    val <a href="#bt_to_ol_ub-val">bt_to_ol_ub</a> : thm
<a name="line39"></a>    val <a href="#bt_to_ol_ub_ac-val">bt_to_ol_ub_ac</a> : thm
<a name="line40"></a>    val <a href="#bt_to_set-val">bt_to_set</a> : thm
<a name="line41"></a>    val <a href="#bt_to_set_lb-val">bt_to_set_lb</a> : thm
<a name="line42"></a>    val <a href="#bt_to_set_lb_ub-val">bt_to_set_lb_ub</a> : thm
<a name="line43"></a>    val <a href="#bt_to_set_ub-val">bt_to_set_ub</a> : thm
<a name="line44"></a>    val <a href="#incr_sbuild-val">incr_sbuild</a> : thm
<a name="line45"></a>    val <a href="#incr_smerge_curried-val">incr_smerge_curried</a> : thm
<a name="line46"></a>    val <a href="#incr_smerge_tupled_primitive-val">incr_smerge_tupled_primitive</a> : thm
<a name="line47"></a>    val <a href="#incr_ssort-val">incr_ssort</a> : thm
<a name="line48"></a>    val <a href="#list_to_bl-val">list_to_bl</a> : thm
<a name="line49"></a>    val <a href="#list_to_bt-val">list_to_bt</a> : thm
<a name="line50"></a>    val <a href="#lol_set_primitive-val">lol_set_primitive</a> : thm
<a name="line51"></a>    val <a href="#sdiff_curried-val">sdiff_curried</a> : thm
<a name="line52"></a>    val <a href="#sdiff_tupled_primitive-val">sdiff_tupled_primitive</a> : thm
<a name="line53"></a>    val <a href="#sinter_curried-val">sinter_curried</a> : thm
<a name="line54"></a>    val <a href="#sinter_tupled_primitive-val">sinter_tupled_primitive</a> : thm
<a name="line55"></a>    val <a href="#smerge_curried-val">smerge_curried</a> : thm
<a name="line56"></a>    val <a href="#smerge_out_curried-val">smerge_out_curried</a> : thm
<a name="line57"></a>    val <a href="#smerge_out_tupled_primitive-val">smerge_out_tupled_primitive</a> : thm
<a name="line58"></a>    val <a href="#smerge_tupled_primitive-val">smerge_tupled_primitive</a> : thm
<a name="line59"></a>
<a name="line60"></a>  (*  Theorems  *)
<a name="line61"></a>    val <a href="#EMPTY_OU-val">EMPTY_OU</a> : thm
<a name="line62"></a>    val <a href="#ENUMERAL_set-val">ENUMERAL_set</a> : thm
<a name="line63"></a>    val <a href="#IN_bt_to_set-val">IN_bt_to_set</a> : thm
<a name="line64"></a>    val <a href="#IN_node-val">IN_node</a> : thm
<a name="line65"></a>    val <a href="#LESS_ALL_OU-val">LESS_ALL_OU</a> : thm
<a name="line66"></a>    val <a href="#LESS_ALL_OU_UO_LEM-val">LESS_ALL_OU_UO_LEM</a> : thm
<a name="line67"></a>    val <a href="#LESS_ALL_UO_LEM-val">LESS_ALL_UO_LEM</a> : thm
<a name="line68"></a>    val <a href="#LESS_UO_LEM-val">LESS_UO_LEM</a> : thm
<a name="line69"></a>    val <a href="#NOT_IN_nt-val">NOT_IN_nt</a> : thm
<a name="line70"></a>    val <a href="#OL_DIFF_IMP-val">OL_DIFF_IMP</a> : thm
<a name="line71"></a>    val <a href="#OL_ENUMERAL-val">OL_ENUMERAL</a> : thm
<a name="line72"></a>    val <a href="#OL_INTER_IMP-val">OL_INTER_IMP</a> : thm
<a name="line73"></a>    val <a href="#OL_UNION_IMP-val">OL_UNION_IMP</a> : thm
<a name="line74"></a>    val <a href="#OL_bt_to_ol-val">OL_bt_to_ol</a> : thm
<a name="line75"></a>    val <a href="#OL_bt_to_ol_lb-val">OL_bt_to_ol_lb</a> : thm
<a name="line76"></a>    val <a href="#OL_bt_to_ol_lb_ub-val">OL_bt_to_ol_lb_ub</a> : thm
<a name="line77"></a>    val <a href="#OL_bt_to_ol_ub-val">OL_bt_to_ol_ub</a> : thm
<a name="line78"></a>    val <a href="#OL_sublists-val">OL_sublists</a> : thm
<a name="line79"></a>    val <a href="#OL_sublists_ind-val">OL_sublists_ind</a> : thm
<a name="line80"></a>    val <a href="#OU_ASSOC-val">OU_ASSOC</a> : thm
<a name="line81"></a>    val <a href="#OU_EMPTY-val">OU_EMPTY</a> : thm
<a name="line82"></a>    val <a href="#OWL_DIFF_THM-val">OWL_DIFF_THM</a> : thm
<a name="line83"></a>    val <a href="#OWL_INTER_THM-val">OWL_INTER_THM</a> : thm
<a name="line84"></a>    val <a href="#OWL_UNION_THM-val">OWL_UNION_THM</a> : thm
<a name="line85"></a>    val <a href="#OWL_bt_to_ol-val">OWL_bt_to_ol</a> : thm
<a name="line86"></a>    val <a href="#better_bt_to_ol-val">better_bt_to_ol</a> : thm
<a name="line87"></a>    val <a href="#bl_11-val">bl_11</a> : thm
<a name="line88"></a>    val <a href="#bl_Axiom-val">bl_Axiom</a> : thm
<a name="line89"></a>    val <a href="#bl_case_cong-val">bl_case_cong</a> : thm
<a name="line90"></a>    val <a href="#bl_distinct-val">bl_distinct</a> : thm
<a name="line91"></a>    val <a href="#bl_induction-val">bl_induction</a> : thm
<a name="line92"></a>    val <a href="#bl_nchotomy-val">bl_nchotomy</a> : thm
<a name="line93"></a>    val <a href="#bt_11-val">bt_11</a> : thm
<a name="line94"></a>    val <a href="#bt_Axiom-val">bt_Axiom</a> : thm
<a name="line95"></a>    val <a href="#bt_case_cong-val">bt_case_cong</a> : thm
<a name="line96"></a>    val <a href="#bt_case_def-val">bt_case_def</a> : thm
<a name="line97"></a>    val <a href="#bt_distinct-val">bt_distinct</a> : thm
<a name="line98"></a>    val <a href="#bt_induction-val">bt_induction</a> : thm
<a name="line99"></a>    val <a href="#bt_nchotomy-val">bt_nchotomy</a> : thm
<a name="line100"></a>    val <a href="#bt_to_list_thm-val">bt_to_list_thm</a> : thm
<a name="line101"></a>    val <a href="#bt_to_ol_ID_IMP-val">bt_to_ol_ID_IMP</a> : thm
<a name="line102"></a>    val <a href="#datatype_bl-val">datatype_bl</a> : thm
<a name="line103"></a>    val <a href="#datatype_bt-val">datatype_bt</a> : thm
<a name="line104"></a>    val <a href="#incr_smerge-val">incr_smerge</a> : thm
<a name="line105"></a>    val <a href="#incr_smerge_OL-val">incr_smerge_OL</a> : thm
<a name="line106"></a>    val <a href="#incr_smerge_ind-val">incr_smerge_ind</a> : thm
<a name="line107"></a>    val <a href="#lol_set-val">lol_set</a> : thm
<a name="line108"></a>    val <a href="#lol_set_ind-val">lol_set_ind</a> : thm
<a name="line109"></a>    val <a href="#ol_set-val">ol_set</a> : thm
<a name="line110"></a>    val <a href="#sdiff-val">sdiff</a> : thm
<a name="line111"></a>    val <a href="#sdiff_ind-val">sdiff_ind</a> : thm
<a name="line112"></a>    val <a href="#set_OWL_thm-val">set_OWL_thm</a> : thm
<a name="line113"></a>    val <a href="#sinter-val">sinter</a> : thm
<a name="line114"></a>    val <a href="#sinter_ind-val">sinter_ind</a> : thm
<a name="line115"></a>    val <a href="#smerge-val">smerge</a> : thm
<a name="line116"></a>    val <a href="#smerge_OL-val">smerge_OL</a> : thm
<a name="line117"></a>    val <a href="#smerge_ind-val">smerge_ind</a> : thm
<a name="line118"></a>    val <a href="#smerge_nil-val">smerge_nil</a> : thm
<a name="line119"></a>    val <a href="#smerge_out-val">smerge_out</a> : thm
<a name="line120"></a>    val <a href="#smerge_out_ind-val">smerge_out_ind</a> : thm
<a name="line121"></a>
<a name="line122"></a>  val enumeral_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line123"></a>(*
   [res_quan] Parent theory of "enumeral"

   [toto] Parent theory of "enumeral"

   [<a name="BL_ACCUM-val"><b>BL_ACCUM</b></a>]  Definition

      |- (!a ac. BL_ACCUM a ac nbl = onebl a ac nbl) /\
         (!a ac bl. BL_ACCUM a ac (zerbl bl) = onebl a ac bl) /\
         !a ac r rft bl.
           BL_ACCUM a ac (onebl r rft bl) =
           zerbl (BL_ACCUM a (node ac r rft) bl)

   [<a name="BL_CONS-val"><b>BL_CONS</b></a>]  Definition

      |- !a bl. BL_CONS a bl = BL_ACCUM a nt bl

   [<a name="K2-val"><b>K2</b></a>]  Definition

      |- !a. K2 a = 2

   [<a name="LESS_ALL-val"><b>LESS_ALL</b></a>]  Definition

      |- !cmp x s.
           LESS_ALL cmp x s &lt;=&gt; !y. y IN s ==&gt; (apto cmp x y = LESS)

   [<a name="OL-val"><b>OL</b></a>]  Definition

      |- (!cmp. OL cmp [] &lt;=&gt; T) /\
         !cmp a l.
           OL cmp (a::l) &lt;=&gt;
           OL cmp l /\ !p. MEM p l ==&gt; (apto cmp a p = LESS)

   [<a name="OL_bt-val"><b>OL_bt</b></a>]  Definition

      |- (!cmp. OL_bt cmp nt &lt;=&gt; T) /\
         !cmp l x r.
           OL_bt cmp (node l x r) &lt;=&gt; OL_bt_ub cmp l x /\ OL_bt_lb cmp x r

   [<a name="OL_bt_lb-val"><b>OL_bt_lb</b></a>]  Definition

      |- (!cmp lb. OL_bt_lb cmp lb nt &lt;=&gt; T) /\
         !cmp lb l x r.
           OL_bt_lb cmp lb (node l x r) &lt;=&gt;
           OL_bt_lb_ub cmp lb l x /\ OL_bt_lb cmp x r

   [<a name="OL_bt_lb_ub-val"><b>OL_bt_lb_ub</b></a>]  Definition

      |- (!cmp lb ub.
            OL_bt_lb_ub cmp lb nt ub &lt;=&gt; (apto cmp lb ub = LESS)) /\
         !cmp lb l x r ub.
           OL_bt_lb_ub cmp lb (node l x r) ub &lt;=&gt;
           OL_bt_lb_ub cmp lb l x /\ OL_bt_lb_ub cmp x r ub

   [<a name="OL_bt_ub-val"><b>OL_bt_ub</b></a>]  Definition

      |- (!cmp ub. OL_bt_ub cmp nt ub &lt;=&gt; T) /\
         !cmp l x r ub.
           OL_bt_ub cmp (node l x r) ub &lt;=&gt;
           OL_bt_ub cmp l x /\ OL_bt_lb_ub cmp x r ub

   [<a name="OL_sublists_curried-val"><b>OL_sublists_curried</b></a>]  Definition

      |- !x x1. OL_sublists x x1 &lt;=&gt; OL_sublists_tupled (x,x1)

   [<a name="OL_sublists_tupled_primitive-val"><b>OL_sublists_tupled_primitive</b></a>]  Definition

      |- OL_sublists_tupled =
         WFREC
           (@R.
              WF R /\ (!lol cmp. R (cmp,lol) (cmp,NONE::lol)) /\
              !m lol cmp. R (cmp,lol) (cmp,SOME m::lol))
           (\OL_sublists_tupled a.
              case a of
                (cmp,[]) =&gt; I T
              | (cmp,NONE::lol) =&gt; I (OL_sublists_tupled (cmp,lol))
              | (cmp,SOME m::lol) =&gt;
                  I (OL cmp m /\ OL_sublists_tupled (cmp,lol)))

   [<a name="OU-val"><b>OU</b></a>]  Definition

      |- !cmp t u.
           OU cmp t u =
           {x | x IN t /\ !z. z IN u ==&gt; (apto cmp x z = LESS)} UNION u

   [<a name="OWL-val"><b>OWL</b></a>]  Definition

      |- !cmp s l. OWL cmp s l &lt;=&gt; (s = set l) /\ OL cmp l

   [<a name="UO-val"><b>UO</b></a>]  Definition

      |- !cmp s t.
           UO cmp s t =
           s UNION {y | y IN t /\ !z. z IN s ==&gt; (apto cmp z y = LESS)}

   [<a name="bl_TY_DEF-val"><b>bl_TY_DEF</b></a>]  Definition

      |- ?rep.
           TYPE_DEFINITION
             (\a0'.
                !'bl' .
                  (!a0'.
                     (a0' =
                      ind_type$CONSTR 0 (ARB,ARB) (\n. ind_type$BOTTOM)) \/
                     (?a.
                        (a0' =
                         (\a.
                            ind_type$CONSTR (SUC 0) (ARB,ARB)
                              (ind_type$FCONS a (\n. ind_type$BOTTOM)))
                           a) /\ 'bl' a) \/
                     (?a0 a1 a2.
                        (a0' =
                         (\a0 a1 a2.
                            ind_type$CONSTR (SUC (SUC 0)) (a0,a1)
                              (ind_type$FCONS a2 (\n. ind_type$BOTTOM))) a0
                           a1 a2) /\ 'bl' a2) ==&gt;
                     'bl' a0') ==&gt;
                  'bl' a0') rep

   [<a name="bl_case_def-val"><b>bl_case_def</b></a>]  Definition

      |- (!v f f1. bl_CASE nbl v f f1 = v) /\
         (!a v f f1. bl_CASE (zerbl a) v f f1 = f a) /\
         !a0 a1 a2 v f f1. bl_CASE (onebl a0 a1 a2) v f f1 = f1 a0 a1 a2

   [<a name="bl_rev-val"><b>bl_rev</b></a>]  Definition

      |- (!ft. bl_rev ft nbl = ft) /\
         (!ft b. bl_rev ft (zerbl b) = bl_rev ft b) /\
         !ft a f b. bl_rev ft (onebl a f b) = bl_rev (node ft a f) b

   [<a name="bl_size_def-val"><b>bl_size_def</b></a>]  Definition

      |- (!f. bl_size f nbl = 0) /\
         (!f a. bl_size f (zerbl a) = 1 + bl_size f a) /\
         !f a0 a1 a2.
           bl_size f (onebl a0 a1 a2) =
           1 + (f a0 + (bt_size f a1 + bl_size f a2))

   [<a name="bl_to_bt-val"><b>bl_to_bt</b></a>]  Definition

      |- bl_to_bt = bl_rev nt

   [<a name="bl_to_set-val"><b>bl_to_set</b></a>]  Definition

      |- (!cmp. bl_to_set cmp nbl = {}) /\
         (!cmp b. bl_to_set cmp (zerbl b) = bl_to_set cmp b) /\
         !cmp x t b.
           bl_to_set cmp (onebl x t b) =
           OU cmp
             ({x} UNION {y | y IN ENUMERAL cmp t /\ (apto cmp x y = LESS)})
             (bl_to_set cmp b)

   [<a name="bt_TY_DEF-val"><b>bt_TY_DEF</b></a>]  Definition

      |- ?rep.
           TYPE_DEFINITION
             (\a0'.
                !'bt' .
                  (!a0'.
                     (a0' = ind_type$CONSTR 0 ARB (\n. ind_type$BOTTOM)) \/
                     (?a0 a1 a2.
                        (a0' =
                         (\a0 a1 a2.
                            ind_type$CONSTR (SUC 0) a1
                              (ind_type$FCONS a0
                                 (ind_type$FCONS a2
                                    (\n. ind_type$BOTTOM)))) a0 a1 a2) /\
                        'bt' a0 /\ 'bt' a2) ==&gt;
                     'bt' a0') ==&gt;
                  'bt' a0') rep

   [<a name="bt_rev-val"><b>bt_rev</b></a>]  Definition

      |- (!bl. bt_rev nt bl = bl) /\
         !lft r rft bl.
           bt_rev (node lft r rft) bl = bt_rev lft (onebl r rft bl)

   [<a name="bt_size_def-val"><b>bt_size_def</b></a>]  Definition

      |- (!f. bt_size f nt = 0) /\
         !f a0 a1 a2.
           bt_size f (node a0 a1 a2) =
           1 + (bt_size f a0 + (f a1 + bt_size f a2))

   [<a name="bt_to_bl-val"><b>bt_to_bl</b></a>]  Definition

      |- !t. bt_to_bl t = bt_rev t nbl

   [<a name="bt_to_list-val"><b>bt_to_list</b></a>]  Definition

      |- (bt_to_list nt = []) /\
         !l x r.
           bt_to_list (node l x r) = bt_to_list l ++ [x] ++ bt_to_list r

   [<a name="bt_to_list_ac-val"><b>bt_to_list_ac</b></a>]  Definition

      |- (!m. bt_to_list_ac nt m = m) /\
         !l x r m.
           bt_to_list_ac (node l x r) m =
           bt_to_list_ac l (x::bt_to_list_ac r m)

   [<a name="bt_to_ol-val"><b>bt_to_ol</b></a>]  Definition

      |- (!cmp. bt_to_ol cmp nt = []) /\
         !cmp l x r.
           bt_to_ol cmp (node l x r) =
           bt_to_ol_ub cmp l x ++ [x] ++ bt_to_ol_lb cmp x r

   [<a name="bt_to_ol_ac-val"><b>bt_to_ol_ac</b></a>]  Definition

      |- (!cmp m. bt_to_ol_ac cmp nt m = m) /\
         !cmp l x r m.
           bt_to_ol_ac cmp (node l x r) m =
           bt_to_ol_ub_ac cmp l x (x::bt_to_ol_lb_ac cmp x r m)

   [<a name="bt_to_ol_lb-val"><b>bt_to_ol_lb</b></a>]  Definition

      |- (!cmp lb. bt_to_ol_lb cmp lb nt = []) /\
         !cmp lb l x r.
           bt_to_ol_lb cmp lb (node l x r) =
           if apto cmp lb x = LESS then
             bt_to_ol_lb_ub cmp lb l x ++ [x] ++ bt_to_ol_lb cmp x r
           else bt_to_ol_lb cmp lb r

   [<a name="bt_to_ol_lb_ac-val"><b>bt_to_ol_lb_ac</b></a>]  Definition

      |- (!cmp lb m. bt_to_ol_lb_ac cmp lb nt m = m) /\
         !cmp lb l x r m.
           bt_to_ol_lb_ac cmp lb (node l x r) m =
           if apto cmp lb x = LESS then
             bt_to_ol_lb_ub_ac cmp lb l x (x::bt_to_ol_lb_ac cmp x r m)
           else bt_to_ol_lb_ac cmp lb r m

   [<a name="bt_to_ol_lb_ub-val"><b>bt_to_ol_lb_ub</b></a>]  Definition

      |- (!cmp lb ub. bt_to_ol_lb_ub cmp lb nt ub = []) /\
         !cmp lb l x r ub.
           bt_to_ol_lb_ub cmp lb (node l x r) ub =
           if apto cmp lb x = LESS then
             if apto cmp x ub = LESS then
               bt_to_ol_lb_ub cmp lb l x ++ [x] ++
               bt_to_ol_lb_ub cmp x r ub
             else bt_to_ol_lb_ub cmp lb l ub
           else bt_to_ol_lb_ub cmp lb r ub

   [<a name="bt_to_ol_lb_ub_ac-val"><b>bt_to_ol_lb_ub_ac</b></a>]  Definition

      |- (!cmp lb ub m. bt_to_ol_lb_ub_ac cmp lb nt ub m = m) /\
         !cmp lb l x r ub m.
           bt_to_ol_lb_ub_ac cmp lb (node l x r) ub m =
           if apto cmp lb x = LESS then
             if apto cmp x ub = LESS then
               bt_to_ol_lb_ub_ac cmp lb l x
                 (x::bt_to_ol_lb_ub_ac cmp x r ub m)
             else bt_to_ol_lb_ub_ac cmp lb l ub m
           else bt_to_ol_lb_ub_ac cmp lb r ub m

   [<a name="bt_to_ol_ub-val"><b>bt_to_ol_ub</b></a>]  Definition

      |- (!cmp ub. bt_to_ol_ub cmp nt ub = []) /\
         !cmp l x r ub.
           bt_to_ol_ub cmp (node l x r) ub =
           if apto cmp x ub = LESS then
             bt_to_ol_ub cmp l x ++ [x] ++ bt_to_ol_lb_ub cmp x r ub
           else bt_to_ol_ub cmp l ub

   [<a name="bt_to_ol_ub_ac-val"><b>bt_to_ol_ub_ac</b></a>]  Definition

      |- (!cmp ub m. bt_to_ol_ub_ac cmp nt ub m = m) /\
         !cmp l x r ub m.
           bt_to_ol_ub_ac cmp (node l x r) ub m =
           if apto cmp x ub = LESS then
             bt_to_ol_ub_ac cmp l x (x::bt_to_ol_lb_ub_ac cmp x r ub m)
           else bt_to_ol_ub_ac cmp l ub m

   [<a name="bt_to_set-val"><b>bt_to_set</b></a>]  Definition

      |- (!cmp. ENUMERAL cmp nt = {}) /\
         !cmp l x r.
           ENUMERAL cmp (node l x r) =
           {y | y IN ENUMERAL cmp l /\ (apto cmp y x = LESS)} UNION
           {x} UNION {z | z IN ENUMERAL cmp r /\ (apto cmp x z = LESS)}

   [<a name="bt_to_set_lb-val"><b>bt_to_set_lb</b></a>]  Definition

      |- !cmp lb t.
           bt_to_set_lb cmp lb t =
           {x | x IN ENUMERAL cmp t /\ (apto cmp lb x = LESS)}

   [<a name="bt_to_set_lb_ub-val"><b>bt_to_set_lb_ub</b></a>]  Definition

      |- !cmp lb t ub.
           bt_to_set_lb_ub cmp lb t ub =
           {x |
            x IN ENUMERAL cmp t /\ (apto cmp lb x = LESS) /\
            (apto cmp x ub = LESS)}

   [<a name="bt_to_set_ub-val"><b>bt_to_set_ub</b></a>]  Definition

      |- !cmp t ub.
           bt_to_set_ub cmp t ub =
           {x | x IN ENUMERAL cmp t /\ (apto cmp x ub = LESS)}

   [<a name="incr_sbuild-val"><b>incr_sbuild</b></a>]  Definition

      |- (!cmp. incr_sbuild cmp [] = []) /\
         !cmp x l.
           incr_sbuild cmp (x::l) = incr_smerge cmp [x] (incr_sbuild cmp l)

   [<a name="incr_smerge_curried-val"><b>incr_smerge_curried</b></a>]  Definition

      |- !x x1 x2. incr_smerge x x1 x2 = incr_smerge_tupled (x,x1,x2)

   [<a name="incr_smerge_tupled_primitive-val"><b>incr_smerge_tupled_primitive</b></a>]  Definition

      |- incr_smerge_tupled =
         WFREC
           (@R.
              WF R /\
              !lol m l cmp. R (cmp,smerge cmp l m,lol) (cmp,l,SOME m::lol))
           (\incr_smerge_tupled a.
              case a of
                (cmp,l,[]) =&gt; I [SOME l]
              | (cmp,l,NONE::lol) =&gt; I (SOME l::lol)
              | (cmp,l,SOME m::lol) =&gt;
                  I (NONE::incr_smerge_tupled (cmp,smerge cmp l m,lol)))

   [<a name="incr_ssort-val"><b>incr_ssort</b></a>]  Definition

      |- !cmp l. incr_ssort cmp l = smerge_out cmp [] (incr_sbuild cmp l)

   [<a name="list_to_bl-val"><b>list_to_bl</b></a>]  Definition

      |- (list_to_bl [] = nbl) /\
         !a l. list_to_bl (a::l) = BL_CONS a (list_to_bl l)

   [<a name="list_to_bt-val"><b>list_to_bt</b></a>]  Definition

      |- !l. list_to_bt l = bl_to_bt (list_to_bl l)

   [<a name="lol_set_primitive-val"><b>lol_set_primitive</b></a>]  Definition

      |- lol_set =
         WFREC
           (@R.
              WF R /\ (!lol. R lol (NONE::lol)) /\
              !m lol. R lol (SOME m::lol))
           (\lol_set a.
              case a of
                [] =&gt; I {}
              | NONE::lol =&gt; I (lol_set lol)
              | SOME m::lol =&gt; I (set m UNION lol_set lol))

   [<a name="sdiff_curried-val"><b>sdiff_curried</b></a>]  Definition

      |- !x x1 x2. sdiff x x1 x2 = sdiff_tupled (x,x1,x2)

   [<a name="sdiff_tupled_primitive-val"><b>sdiff_tupled_primitive</b></a>]  Definition

      |- sdiff_tupled =
         WFREC
           (@R.
              WF R /\
              (!m l y x cmp.
                 (apto cmp x y = EQUAL) ==&gt; R (cmp,l,m) (cmp,x::l,y::m)) /\
              (!m l y x cmp.
                 (apto cmp x y = GREATER) ==&gt;
                 R (cmp,x::l,m) (cmp,x::l,y::m)) /\
              !m l y x cmp.
                (apto cmp x y = LESS) ==&gt; R (cmp,l,y::m) (cmp,x::l,y::m))
           (\sdiff_tupled a.
              case a of
                (cmp,[],v3) =&gt; I []
              | (cmp,x::l,[]) =&gt; I (x::l)
              | (cmp,x::l,y::m) =&gt;
                  I
                    (case apto cmp x y of
                       LESS =&gt; x::sdiff_tupled (cmp,l,y::m)
                     | EQUAL =&gt; sdiff_tupled (cmp,l,m)
                     | GREATER =&gt; sdiff_tupled (cmp,x::l,m)))

   [<a name="sinter_curried-val"><b>sinter_curried</b></a>]  Definition

      |- !x x1 x2. sinter x x1 x2 = sinter_tupled (x,x1,x2)

   [<a name="sinter_tupled_primitive-val"><b>sinter_tupled_primitive</b></a>]  Definition

      |- sinter_tupled =
         WFREC
           (@R.
              WF R /\
              (!m l y x cmp.
                 (apto cmp x y = EQUAL) ==&gt; R (cmp,l,m) (cmp,x::l,y::m)) /\
              (!m l y x cmp.
                 (apto cmp x y = GREATER) ==&gt;
                 R (cmp,x::l,m) (cmp,x::l,y::m)) /\
              !m l y x cmp.
                (apto cmp x y = LESS) ==&gt; R (cmp,l,y::m) (cmp,x::l,y::m))
           (\sinter_tupled a.
              case a of
                (cmp,x::l,y::m) =&gt;
                  I
                    (case apto cmp x y of
                       LESS =&gt; sinter_tupled (cmp,l,y::m)
                     | EQUAL =&gt; x::sinter_tupled (cmp,l,m)
                     | GREATER =&gt; sinter_tupled (cmp,x::l,m))
              | _ =&gt; I [])

   [<a name="smerge_curried-val"><b>smerge_curried</b></a>]  Definition

      |- !x x1 x2. smerge x x1 x2 = smerge_tupled (x,x1,x2)

   [<a name="smerge_out_curried-val"><b>smerge_out_curried</b></a>]  Definition

      |- !x x1 x2. smerge_out x x1 x2 = smerge_out_tupled (x,x1,x2)

   [<a name="smerge_out_tupled_primitive-val"><b>smerge_out_tupled_primitive</b></a>]  Definition

      |- smerge_out_tupled =
         WFREC
           (@R.
              WF R /\ (!lol l cmp. R (cmp,l,lol) (cmp,l,NONE::lol)) /\
              !lol m l cmp. R (cmp,smerge cmp l m,lol) (cmp,l,SOME m::lol))
           (\smerge_out_tupled a.
              case a of
                (cmp,l,[]) =&gt; I l
              | (cmp,l,NONE::lol) =&gt; I (smerge_out_tupled (cmp,l,lol))
              | (cmp,l,SOME m::lol) =&gt;
                  I (smerge_out_tupled (cmp,smerge cmp l m,lol)))

   [<a name="smerge_tupled_primitive-val"><b>smerge_tupled_primitive</b></a>]  Definition

      |- smerge_tupled =
         WFREC
           (@R.
              WF R /\
              (!m l y x cmp.
                 (apto cmp x y = EQUAL) ==&gt; R (cmp,l,m) (cmp,x::l,y::m)) /\
              (!m l y x cmp.
                 (apto cmp x y = GREATER) ==&gt;
                 R (cmp,x::l,m) (cmp,x::l,y::m)) /\
              !m l y x cmp.
                (apto cmp x y = LESS) ==&gt; R (cmp,l,y::m) (cmp,x::l,y::m))
           (\smerge_tupled a.
              case a of
                (cmp,[],[]) =&gt; I []
              | (cmp,[],y::m) =&gt; I (y::m)
              | (cmp,x::l,[]) =&gt; I (x::l)
              | (cmp,x::l,y'::m') =&gt;
                  I
                    (case apto cmp x y' of
                       LESS =&gt; x::smerge_tupled (cmp,l,y'::m')
                     | EQUAL =&gt; x::smerge_tupled (cmp,l,m')
                     | GREATER =&gt; y'::smerge_tupled (cmp,x::l,m')))

   [<a name="EMPTY_OU-val"><b>EMPTY_OU</b></a>]  Theorem

      |- !cmp sl. OU cmp {} sl = sl

   [<a name="ENUMERAL_set-val"><b>ENUMERAL_set</b></a>]  Theorem

      |- !cmp l. set l = ENUMERAL cmp (list_to_bt (incr_ssort cmp l))

   [<a name="IN_bt_to_set-val"><b>IN_bt_to_set</b></a>]  Theorem

      |- (!cmp y. y IN ENUMERAL cmp nt &lt;=&gt; F) /\
         !cmp l x r y.
           y IN ENUMERAL cmp (node l x r) &lt;=&gt;
           y IN ENUMERAL cmp l /\ (apto cmp y x = LESS) \/ (y = x) \/
           y IN ENUMERAL cmp r /\ (apto cmp x y = LESS)

   [<a name="IN_node-val"><b>IN_node</b></a>]  Theorem

      |- !cmp x l y r.
           x IN ENUMERAL cmp (node l y r) &lt;=&gt;
           case apto cmp x y of
             LESS =&gt; x IN ENUMERAL cmp l
           | EQUAL =&gt; T
           | GREATER =&gt; x IN ENUMERAL cmp r

   [<a name="LESS_ALL_OU-val"><b>LESS_ALL_OU</b></a>]  Theorem

      |- !cmp x u v.
           LESS_ALL cmp x (OU cmp u v) &lt;=&gt;
           LESS_ALL cmp x u /\ LESS_ALL cmp x v

   [<a name="LESS_ALL_OU_UO_LEM-val"><b>LESS_ALL_OU_UO_LEM</b></a>]  Theorem

      |- !cmp a s t.
           LESS_ALL cmp a s /\ LESS_ALL cmp a t ==&gt;
           (OU cmp (UO cmp {a} s) t = a INSERT OU cmp s t)

   [<a name="LESS_ALL_UO_LEM-val"><b>LESS_ALL_UO_LEM</b></a>]  Theorem

      |- !cmp a s. LESS_ALL cmp a s ==&gt; (UO cmp {a} s = a INSERT s)

   [<a name="LESS_UO_LEM-val"><b>LESS_UO_LEM</b></a>]  Theorem

      |- !cmp x y s.
           (!z. z IN UO cmp {x} s ==&gt; (apto cmp y z = LESS)) &lt;=&gt;
           (apto cmp y x = LESS)

   [<a name="NOT_IN_nt-val"><b>NOT_IN_nt</b></a>]  Theorem

      |- !cmp y. y IN ENUMERAL cmp nt &lt;=&gt; F

   [<a name="OL_DIFF_IMP-val"><b>OL_DIFF_IMP</b></a>]  Theorem

      |- !cmp l.
           OL cmp l ==&gt;
           !m.
             OL cmp m ==&gt;
             OL cmp (sdiff cmp l m) /\
             (set (sdiff cmp l m) = set l DIFF set m)

   [<a name="OL_ENUMERAL-val"><b>OL_ENUMERAL</b></a>]  Theorem

      |- !cmp l. OL cmp l ==&gt; (set l = ENUMERAL cmp (list_to_bt l))

   [<a name="OL_INTER_IMP-val"><b>OL_INTER_IMP</b></a>]  Theorem

      |- !cmp l.
           OL cmp l ==&gt;
           !m.
             OL cmp m ==&gt;
             OL cmp (sinter cmp l m) /\
             (set (sinter cmp l m) = set l INTER set m)

   [<a name="OL_UNION_IMP-val"><b>OL_UNION_IMP</b></a>]  Theorem

      |- !cmp l.
           OL cmp l ==&gt;
           !m.
             OL cmp m ==&gt;
             OL cmp (smerge cmp l m) /\
             (set (smerge cmp l m) = set l UNION set m)

   [<a name="OL_bt_to_ol-val"><b>OL_bt_to_ol</b></a>]  Theorem

      |- !cmp t. OL cmp (bt_to_ol cmp t)

   [<a name="OL_bt_to_ol_lb-val"><b>OL_bt_to_ol_lb</b></a>]  Theorem

      |- !cmp t lb. OL cmp (bt_to_ol_lb cmp lb t)

   [<a name="OL_bt_to_ol_lb_ub-val"><b>OL_bt_to_ol_lb_ub</b></a>]  Theorem

      |- !cmp t lb ub. OL cmp (bt_to_ol_lb_ub cmp lb t ub)

   [<a name="OL_bt_to_ol_ub-val"><b>OL_bt_to_ol_ub</b></a>]  Theorem

      |- !cmp t ub. OL cmp (bt_to_ol_ub cmp t ub)

   [<a name="OL_sublists-val"><b>OL_sublists</b></a>]  Theorem

      |- (!cmp. OL_sublists cmp [] &lt;=&gt; T) /\
         (!lol cmp. OL_sublists cmp (NONE::lol) &lt;=&gt; OL_sublists cmp lol) /\
         !m lol cmp.
           OL_sublists cmp (SOME m::lol) &lt;=&gt;
           OL cmp m /\ OL_sublists cmp lol

   [<a name="OL_sublists_ind-val"><b>OL_sublists_ind</b></a>]  Theorem

      |- !P.
           (!cmp. P cmp []) /\
           (!cmp lol. P cmp lol ==&gt; P cmp (NONE::lol)) /\
           (!cmp m lol. P cmp lol ==&gt; P cmp (SOME m::lol)) ==&gt;
           !v v1. P v v1

   [<a name="OU_ASSOC-val"><b>OU_ASSOC</b></a>]  Theorem

      |- !cmp a b c. OU cmp a (OU cmp b c) = OU cmp (OU cmp a b) c

   [<a name="OU_EMPTY-val"><b>OU_EMPTY</b></a>]  Theorem

      |- !cmp t. OU cmp t {} = t

   [<a name="OWL_DIFF_THM-val"><b>OWL_DIFF_THM</b></a>]  Theorem

      |- !cmp s l t m.
           OWL cmp s l /\ OWL cmp t m ==&gt;
           OWL cmp (s DIFF t) (sdiff cmp l m)

   [<a name="OWL_INTER_THM-val"><b>OWL_INTER_THM</b></a>]  Theorem

      |- !cmp s l t m.
           OWL cmp s l /\ OWL cmp t m ==&gt;
           OWL cmp (s INTER t) (sinter cmp l m)

   [<a name="OWL_UNION_THM-val"><b>OWL_UNION_THM</b></a>]  Theorem

      |- !cmp s l t m.
           OWL cmp s l /\ OWL cmp t m ==&gt;
           OWL cmp (s UNION t) (smerge cmp l m)

   [<a name="OWL_bt_to_ol-val"><b>OWL_bt_to_ol</b></a>]  Theorem

      |- !cmp t. OWL cmp (ENUMERAL cmp t) (bt_to_ol cmp t)

   [<a name="better_bt_to_ol-val"><b>better_bt_to_ol</b></a>]  Theorem

      |- !cmp t.
           bt_to_ol cmp t =
           if OL_bt cmp t then bt_to_list_ac t [] else bt_to_ol_ac cmp t []

   [<a name="bl_11-val"><b>bl_11</b></a>]  Theorem

      |- (!a a'. (zerbl a = zerbl a') &lt;=&gt; (a = a')) /\
         !a0 a1 a2 a0' a1' a2'.
           (onebl a0 a1 a2 = onebl a0' a1' a2') &lt;=&gt;
           (a0 = a0') /\ (a1 = a1') /\ (a2 = a2')

   [<a name="bl_Axiom-val"><b>bl_Axiom</b></a>]  Theorem

      |- !f0 f1 f2.
           ?fn.
             (fn nbl = f0) /\ (!a. fn (zerbl a) = f1 a (fn a)) /\
             !a0 a1 a2. fn (onebl a0 a1 a2) = f2 a0 a1 a2 (fn a2)

   [<a name="bl_case_cong-val"><b>bl_case_cong</b></a>]  Theorem

      |- !M M' v f f1.
           (M = M') /\ ((M' = nbl) ==&gt; (v = v')) /\
           (!a. (M' = zerbl a) ==&gt; (f a = f' a)) /\
           (!a0 a1 a2.
              (M' = onebl a0 a1 a2) ==&gt; (f1 a0 a1 a2 = f1' a0 a1 a2)) ==&gt;
           (bl_CASE M v f f1 = bl_CASE M' v' f' f1')

   [<a name="bl_distinct-val"><b>bl_distinct</b></a>]  Theorem

      |- (!a. nbl &lt;&gt; zerbl a) /\ (!a2 a1 a0. nbl &lt;&gt; onebl a0 a1 a2) /\
         !a2 a1 a0 a. zerbl a &lt;&gt; onebl a0 a1 a2

   [<a name="bl_induction-val"><b>bl_induction</b></a>]  Theorem

      |- !P.
           P nbl /\ (!b. P b ==&gt; P (zerbl b)) /\
           (!b. P b ==&gt; !b0 a. P (onebl a b0 b)) ==&gt;
           !b. P b

   [<a name="bl_nchotomy-val"><b>bl_nchotomy</b></a>]  Theorem

      |- !bb.
           (bb = nbl) \/ (?b. bb = zerbl b) \/ ?a b0 b. bb = onebl a b0 b

   [<a name="bt_11-val"><b>bt_11</b></a>]  Theorem

      |- !a0 a1 a2 a0' a1' a2'.
           (node a0 a1 a2 = node a0' a1' a2') &lt;=&gt;
           (a0 = a0') /\ (a1 = a1') /\ (a2 = a2')

   [<a name="bt_Axiom-val"><b>bt_Axiom</b></a>]  Theorem

      |- !f0 f1.
           ?fn.
             (fn nt = f0) /\
             !a0 a1 a2. fn (node a0 a1 a2) = f1 a1 a0 a2 (fn a0) (fn a2)

   [<a name="bt_case_cong-val"><b>bt_case_cong</b></a>]  Theorem

      |- !M M' v f.
           (M = M') /\ ((M' = nt) ==&gt; (v = v')) /\
           (!a0 a1 a2.
              (M' = node a0 a1 a2) ==&gt; (f a0 a1 a2 = f' a0 a1 a2)) ==&gt;
           (bt_CASE M v f = bt_CASE M' v' f')

   [<a name="bt_case_def-val"><b>bt_case_def</b></a>]  Theorem

      |- (!v f. bt_CASE nt v f = v) /\
         !a0 a1 a2 v f. bt_CASE (node a0 a1 a2) v f = f a0 a1 a2

   [<a name="bt_distinct-val"><b>bt_distinct</b></a>]  Theorem

      |- !a2 a1 a0. nt &lt;&gt; node a0 a1 a2

   [<a name="bt_induction-val"><b>bt_induction</b></a>]  Theorem

      |- !P.
           P nt /\ (!b b0. P b /\ P b0 ==&gt; !a. P (node b a b0)) ==&gt; !b. P b

   [<a name="bt_nchotomy-val"><b>bt_nchotomy</b></a>]  Theorem

      |- !bb. (bb = nt) \/ ?b a b0. bb = node b a b0

   [<a name="bt_to_list_thm-val"><b>bt_to_list_thm</b></a>]  Theorem

      |- !t. bt_to_list t = bt_to_list_ac t []

   [<a name="bt_to_ol_ID_IMP-val"><b>bt_to_ol_ID_IMP</b></a>]  Theorem

      |- !cmp l. OL cmp l ==&gt; (bt_to_ol cmp (list_to_bt l) = l)

   [<a name="datatype_bl-val"><b>datatype_bl</b></a>]  Theorem

      |- DATATYPE (bl nbl zerbl onebl)

   [<a name="datatype_bt-val"><b>datatype_bt</b></a>]  Theorem

      |- DATATYPE (bt nt node)

   [<a name="incr_smerge-val"><b>incr_smerge</b></a>]  Theorem

      |- (!l cmp. incr_smerge cmp l [] = [SOME l]) /\
         (!lol l cmp. incr_smerge cmp l (NONE::lol) = SOME l::lol) /\
         !m lol l cmp.
           incr_smerge cmp l (SOME m::lol) =
           NONE::incr_smerge cmp (smerge cmp l m) lol

   [<a name="incr_smerge_OL-val"><b>incr_smerge_OL</b></a>]  Theorem

      |- !cmp lol l.
           OL_sublists cmp lol /\ OL cmp l ==&gt;
           OL_sublists cmp (incr_smerge cmp l lol)

   [<a name="incr_smerge_ind-val"><b>incr_smerge_ind</b></a>]  Theorem

      |- !P.
           (!cmp l. P cmp l []) /\ (!cmp l lol. P cmp l (NONE::lol)) /\
           (!cmp l m lol.
              P cmp (smerge cmp l m) lol ==&gt; P cmp l (SOME m::lol)) ==&gt;
           !v v1 v2. P v v1 v2

   [<a name="lol_set-val"><b>lol_set</b></a>]  Theorem

      |- (lol_set [] = {}) /\ (!lol. lol_set (NONE::lol) = lol_set lol) /\
         !m lol. lol_set (SOME m::lol) = set m UNION lol_set lol

   [<a name="lol_set_ind-val"><b>lol_set_ind</b></a>]  Theorem

      |- !P.
           P [] /\ (!lol. P lol ==&gt; P (NONE::lol)) /\
           (!m lol. P lol ==&gt; P (SOME m::lol)) ==&gt;
           !v. P v

   [<a name="ol_set-val"><b>ol_set</b></a>]  Theorem

      |- !cmp t. ENUMERAL cmp t = set (bt_to_ol cmp t)

   [<a name="sdiff-val"><b>sdiff</b></a>]  Theorem

      |- (!cmp. sdiff cmp [] [] = []) /\
         (!x l cmp. sdiff cmp (x::l) [] = x::l) /\
         (!y m cmp. sdiff cmp [] (y::m) = []) /\
         !y x m l cmp.
           sdiff cmp (x::l) (y::m) =
           case apto cmp x y of
             LESS =&gt; x::sdiff cmp l (y::m)
           | EQUAL =&gt; sdiff cmp l m
           | GREATER =&gt; sdiff cmp (x::l) m

   [<a name="sdiff_ind-val"><b>sdiff_ind</b></a>]  Theorem

      |- !P.
           (!cmp. P cmp [] []) /\ (!cmp x l. P cmp (x::l) []) /\
           (!cmp y m. P cmp [] (y::m)) /\
           (!cmp x l y m.
              ((apto cmp x y = EQUAL) ==&gt; P cmp l m) /\
              ((apto cmp x y = GREATER) ==&gt; P cmp (x::l) m) /\
              ((apto cmp x y = LESS) ==&gt; P cmp l (y::m)) ==&gt;
              P cmp (x::l) (y::m)) ==&gt;
           !v v1 v2. P v v1 v2

   [<a name="set_OWL_thm-val"><b>set_OWL_thm</b></a>]  Theorem

      |- !cmp l. OWL cmp (set l) (incr_ssort cmp l)

   [<a name="sinter-val"><b>sinter</b></a>]  Theorem

      |- (!cmp. sinter cmp [] [] = []) /\
         (!x l cmp. sinter cmp (x::l) [] = []) /\
         (!y m cmp. sinter cmp [] (y::m) = []) /\
         !y x m l cmp.
           sinter cmp (x::l) (y::m) =
           case apto cmp x y of
             LESS =&gt; sinter cmp l (y::m)
           | EQUAL =&gt; x::sinter cmp l m
           | GREATER =&gt; sinter cmp (x::l) m

   [<a name="sinter_ind-val"><b>sinter_ind</b></a>]  Theorem

      |- !P.
           (!cmp. P cmp [] []) /\ (!cmp x l. P cmp (x::l) []) /\
           (!cmp y m. P cmp [] (y::m)) /\
           (!cmp x l y m.
              ((apto cmp x y = EQUAL) ==&gt; P cmp l m) /\
              ((apto cmp x y = GREATER) ==&gt; P cmp (x::l) m) /\
              ((apto cmp x y = LESS) ==&gt; P cmp l (y::m)) ==&gt;
              P cmp (x::l) (y::m)) ==&gt;
           !v v1 v2. P v v1 v2

   [<a name="smerge-val"><b>smerge</b></a>]  Theorem

      |- (!cmp. smerge cmp [] [] = []) /\
         (!x l cmp. smerge cmp (x::l) [] = x::l) /\
         (!y m cmp. smerge cmp [] (y::m) = y::m) /\
         !y x m l cmp.
           smerge cmp (x::l) (y::m) =
           case apto cmp x y of
             LESS =&gt; x::smerge cmp l (y::m)
           | EQUAL =&gt; x::smerge cmp l m
           | GREATER =&gt; y::smerge cmp (x::l) m

   [<a name="smerge_OL-val"><b>smerge_OL</b></a>]  Theorem

      |- !cmp l m. OL cmp l /\ OL cmp m ==&gt; OL cmp (smerge cmp l m)

   [<a name="smerge_ind-val"><b>smerge_ind</b></a>]  Theorem

      |- !P.
           (!cmp. P cmp [] []) /\ (!cmp x l. P cmp (x::l) []) /\
           (!cmp y m. P cmp [] (y::m)) /\
           (!cmp x l y m.
              ((apto cmp x y = EQUAL) ==&gt; P cmp l m) /\
              ((apto cmp x y = GREATER) ==&gt; P cmp (x::l) m) /\
              ((apto cmp x y = LESS) ==&gt; P cmp l (y::m)) ==&gt;
              P cmp (x::l) (y::m)) ==&gt;
           !v v1 v2. P v v1 v2

   [<a name="smerge_nil-val"><b>smerge_nil</b></a>]  Theorem

      |- !cmp l. (smerge cmp l [] = l) /\ (smerge cmp [] l = l)

   [<a name="smerge_out-val"><b>smerge_out</b></a>]  Theorem

      |- (!l cmp. smerge_out cmp l [] = l) /\
         (!lol l cmp.
            smerge_out cmp l (NONE::lol) = smerge_out cmp l lol) /\
         !m lol l cmp.
           smerge_out cmp l (SOME m::lol) =
           smerge_out cmp (smerge cmp l m) lol

   [<a name="smerge_out_ind-val"><b>smerge_out_ind</b></a>]  Theorem

      |- !P.
           (!cmp l. P cmp l []) /\
           (!cmp l lol. P cmp l lol ==&gt; P cmp l (NONE::lol)) /\
           (!cmp l m lol.
              P cmp (smerge cmp l m) lol ==&gt; P cmp l (SOME m::lol)) ==&gt;
           !v v1 v2. P v v1 v2


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/enumfset/enumeralScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-10</a></em></p></body></html>
