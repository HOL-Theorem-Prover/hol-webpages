<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure bitstringTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure bitstringTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/n-bit/bitstringScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature bitstringTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#add_def-val">add_def</a> : thm
<a name="line7"></a>    val <a href="#band_def-val">band_def</a> : thm
<a name="line8"></a>    val <a href="#bitify_curried_def-val">bitify_curried_def</a> : thm
<a name="line9"></a>    val <a href="#bitify_tupled_primitive_def-val">bitify_tupled_primitive_def</a> : thm
<a name="line10"></a>    val <a href="#bitwise_def-val">bitwise_def</a> : thm
<a name="line11"></a>    val <a href="#bnand_def-val">bnand_def</a> : thm
<a name="line12"></a>    val <a href="#bnor_def-val">bnor_def</a> : thm
<a name="line13"></a>    val <a href="#bnot_def-val">bnot_def</a> : thm
<a name="line14"></a>    val <a href="#boolify_def-val">boolify_def</a> : thm
<a name="line15"></a>    val <a href="#bor_def-val">bor_def</a> : thm
<a name="line16"></a>    val <a href="#bxnor_def-val">bxnor_def</a> : thm
<a name="line17"></a>    val <a href="#bxor_def-val">bxor_def</a> : thm
<a name="line18"></a>    val <a href="#extend_def-val">extend_def</a> : thm
<a name="line19"></a>    val <a href="#field_def-val">field_def</a> : thm
<a name="line20"></a>    val <a href="#field_insert_def-val">field_insert_def</a> : thm
<a name="line21"></a>    val <a href="#fixwidth_def-val">fixwidth_def</a> : thm
<a name="line22"></a>    val <a href="#modify_def-val">modify_def</a> : thm
<a name="line23"></a>    val <a href="#n2v_def-val">n2v_def</a> : thm
<a name="line24"></a>    val <a href="#replicate_def-val">replicate_def</a> : thm
<a name="line25"></a>    val <a href="#rev_count_list_def-val">rev_count_list_def</a> : thm
<a name="line26"></a>    val <a href="#rotate_def-val">rotate_def</a> : thm
<a name="line27"></a>    val <a href="#s2v_def-val">s2v_def</a> : thm
<a name="line28"></a>    val <a href="#shiftl_def-val">shiftl_def</a> : thm
<a name="line29"></a>    val <a href="#shiftr_def-val">shiftr_def</a> : thm
<a name="line30"></a>    val <a href="#sign_extend_def-val">sign_extend_def</a> : thm
<a name="line31"></a>    val <a href="#testbit_def-val">testbit_def</a> : thm
<a name="line32"></a>    val <a href="#v2n_def-val">v2n_def</a> : thm
<a name="line33"></a>    val <a href="#v2s_def-val">v2s_def</a> : thm
<a name="line34"></a>    val <a href="#v2w_def-val">v2w_def</a> : thm
<a name="line35"></a>    val <a href="#w2v_def-val">w2v_def</a> : thm
<a name="line36"></a>    val <a href="#zero_extend_def-val">zero_extend_def</a> : thm
<a name="line37"></a>
<a name="line38"></a>  (*  Theorems  *)
<a name="line39"></a>    val <a href="#bit_v2w-val">bit_v2w</a> : thm
<a name="line40"></a>    val <a href="#bitify_def-val">bitify_def</a> : thm
<a name="line41"></a>    val <a href="#bitify_ind-val">bitify_ind</a> : thm
<a name="line42"></a>    val <a href="#bitify_reverse_map-val">bitify_reverse_map</a> : thm
<a name="line43"></a>    val <a href="#bitstring_nchotomy-val">bitstring_nchotomy</a> : thm
<a name="line44"></a>    val <a href="#boolify_reverse_map-val">boolify_reverse_map</a> : thm
<a name="line45"></a>    val <a href="#el_field-val">el_field</a> : thm
<a name="line46"></a>    val <a href="#el_fixwidth-val">el_fixwidth</a> : thm
<a name="line47"></a>    val <a href="#el_rev_count_list-val">el_rev_count_list</a> : thm
<a name="line48"></a>    val <a href="#el_shiftr-val">el_shiftr</a> : thm
<a name="line49"></a>    val <a href="#el_sign_extend-val">el_sign_extend</a> : thm
<a name="line50"></a>    val <a href="#el_w2v-val">el_w2v</a> : thm
<a name="line51"></a>    val <a href="#el_zero_extend-val">el_zero_extend</a> : thm
<a name="line52"></a>    val <a href="#every_bit_bitify-val">every_bit_bitify</a> : thm
<a name="line53"></a>    val <a href="#extend-val">extend</a> : thm
<a name="line54"></a>    val <a href="#extend_cons-val">extend_cons</a> : thm
<a name="line55"></a>    val <a href="#extend_def_compute-val">extend_def_compute</a> : thm
<a name="line56"></a>    val <a href="#extract_v2w-val">extract_v2w</a> : thm
<a name="line57"></a>    val <a href="#field_concat_left-val">field_concat_left</a> : thm
<a name="line58"></a>    val <a href="#field_concat_right-val">field_concat_right</a> : thm
<a name="line59"></a>    val <a href="#field_fixwidth-val">field_fixwidth</a> : thm
<a name="line60"></a>    val <a href="#field_id_imp-val">field_id_imp</a> : thm
<a name="line61"></a>    val <a href="#fixwidth-val">fixwidth</a> : thm
<a name="line62"></a>    val <a href="#fixwidth_eq-val">fixwidth_eq</a> : thm
<a name="line63"></a>    val <a href="#fixwidth_fixwidth-val">fixwidth_fixwidth</a> : thm
<a name="line64"></a>    val <a href="#fixwidth_id-val">fixwidth_id</a> : thm
<a name="line65"></a>    val <a href="#fixwidth_id_imp-val">fixwidth_id_imp</a> : thm
<a name="line66"></a>    val <a href="#length_bitify-val">length_bitify</a> : thm
<a name="line67"></a>    val <a href="#length_bitify_null-val">length_bitify_null</a> : thm
<a name="line68"></a>    val <a href="#length_field-val">length_field</a> : thm
<a name="line69"></a>    val <a href="#length_fixwidth-val">length_fixwidth</a> : thm
<a name="line70"></a>    val <a href="#length_pad_left-val">length_pad_left</a> : thm
<a name="line71"></a>    val <a href="#length_pad_right-val">length_pad_right</a> : thm
<a name="line72"></a>    val <a href="#length_rev_count_list-val">length_rev_count_list</a> : thm
<a name="line73"></a>    val <a href="#length_shiftr-val">length_shiftr</a> : thm
<a name="line74"></a>    val <a href="#length_sign_extend-val">length_sign_extend</a> : thm
<a name="line75"></a>    val <a href="#length_w2v-val">length_w2v</a> : thm
<a name="line76"></a>    val <a href="#length_zero_extend-val">length_zero_extend</a> : thm
<a name="line77"></a>    val <a href="#n2w_v2n-val">n2w_v2n</a> : thm
<a name="line78"></a>    val <a href="#ops_to_n2w-val">ops_to_n2w</a> : thm
<a name="line79"></a>    val <a href="#ops_to_v2w-val">ops_to_v2w</a> : thm
<a name="line80"></a>    val <a href="#pad_left_extend-val">pad_left_extend</a> : thm
<a name="line81"></a>    val <a href="#ranged_bitstring_nchotomy-val">ranged_bitstring_nchotomy</a> : thm
<a name="line82"></a>    val <a href="#reduce_and_v2w-val">reduce_and_v2w</a> : thm
<a name="line83"></a>    val <a href="#reduce_or_v2w-val">reduce_or_v2w</a> : thm
<a name="line84"></a>    val <a href="#shiftl_replicate_F-val">shiftl_replicate_F</a> : thm
<a name="line85"></a>    val <a href="#shiftr_0-val">shiftr_0</a> : thm
<a name="line86"></a>    val <a href="#sw2sw_v2w-val">sw2sw_v2w</a> : thm
<a name="line87"></a>    val <a href="#testbit-val">testbit</a> : thm
<a name="line88"></a>    val <a href="#testbit_el-val">testbit_el</a> : thm
<a name="line89"></a>    val <a href="#testbit_geq_len-val">testbit_geq_len</a> : thm
<a name="line90"></a>    val <a href="#testbit_w2v-val">testbit_w2v</a> : thm
<a name="line91"></a>    val <a href="#v2n_lt-val">v2n_lt</a> : thm
<a name="line92"></a>    val <a href="#v2n_n2v-val">v2n_n2v</a> : thm
<a name="line93"></a>    val <a href="#v2w_11-val">v2w_11</a> : thm
<a name="line94"></a>    val <a href="#v2w_fixwidth-val">v2w_fixwidth</a> : thm
<a name="line95"></a>    val <a href="#v2w_n2v-val">v2w_n2v</a> : thm
<a name="line96"></a>    val <a href="#v2w_w2v-val">v2w_w2v</a> : thm
<a name="line97"></a>    val <a href="#w2n_v2w-val">w2n_v2w</a> : thm
<a name="line98"></a>    val <a href="#w2v_v2w-val">w2v_v2w</a> : thm
<a name="line99"></a>    val <a href="#w2w_v2w-val">w2w_v2w</a> : thm
<a name="line100"></a>    val <a href="#word_1comp_v2w-val">word_1comp_v2w</a> : thm
<a name="line101"></a>    val <a href="#word_and_v2w-val">word_and_v2w</a> : thm
<a name="line102"></a>    val <a href="#word_asr_v2w-val">word_asr_v2w</a> : thm
<a name="line103"></a>    val <a href="#word_bit_last_shiftr-val">word_bit_last_shiftr</a> : thm
<a name="line104"></a>    val <a href="#word_bits_v2w-val">word_bits_v2w</a> : thm
<a name="line105"></a>    val <a href="#word_concat_v2w-val">word_concat_v2w</a> : thm
<a name="line106"></a>    val <a href="#word_concat_v2w_rwt-val">word_concat_v2w_rwt</a> : thm
<a name="line107"></a>    val <a href="#word_extract_v2w-val">word_extract_v2w</a> : thm
<a name="line108"></a>    val <a href="#word_index_v2w-val">word_index_v2w</a> : thm
<a name="line109"></a>    val <a href="#word_join_v2w-val">word_join_v2w</a> : thm
<a name="line110"></a>    val <a href="#word_join_v2w_rwt-val">word_join_v2w_rwt</a> : thm
<a name="line111"></a>    val <a href="#word_lsb_v2w-val">word_lsb_v2w</a> : thm
<a name="line112"></a>    val <a href="#word_lsl_v2w-val">word_lsl_v2w</a> : thm
<a name="line113"></a>    val <a href="#word_lsr_v2w-val">word_lsr_v2w</a> : thm
<a name="line114"></a>    val <a href="#word_modify_v2w-val">word_modify_v2w</a> : thm
<a name="line115"></a>    val <a href="#word_msb_v2w-val">word_msb_v2w</a> : thm
<a name="line116"></a>    val <a href="#word_nand_v2w-val">word_nand_v2w</a> : thm
<a name="line117"></a>    val <a href="#word_nor_v2w-val">word_nor_v2w</a> : thm
<a name="line118"></a>    val <a href="#word_or_v2w-val">word_or_v2w</a> : thm
<a name="line119"></a>    val <a href="#word_reduce_v2w-val">word_reduce_v2w</a> : thm
<a name="line120"></a>    val <a href="#word_reverse_v2w-val">word_reverse_v2w</a> : thm
<a name="line121"></a>    val <a href="#word_ror_v2w-val">word_ror_v2w</a> : thm
<a name="line122"></a>    val <a href="#word_slice_v2w-val">word_slice_v2w</a> : thm
<a name="line123"></a>    val <a href="#word_xnor_v2w-val">word_xnor_v2w</a> : thm
<a name="line124"></a>    val <a href="#word_xor_v2w-val">word_xor_v2w</a> : thm
<a name="line125"></a>
<a name="line126"></a>  val bitstring_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line127"></a>(*
   [words] Parent theory of "bitstring"

   [<a name="add_def-val"><b>add_def</b></a>]  Definition

      |- ∀a b.
           add a b =
           (let m = MAX (LENGTH a) (LENGTH b)
            in
              zero_extend m (n2v (v2n a + v2n b)))

   [<a name="band_def-val"><b>band_def</b></a>]  Definition

      |- band = bitwise $/\

   [<a name="bitify_curried_def-val"><b>bitify_curried_def</b></a>]  Definition

      |- ∀x x1. bitify x x1 = bitify_tupled (x,x1)

   [<a name="bitify_tupled_primitive_def-val"><b>bitify_tupled_primitive_def</b></a>]  Definition

      |- bitify_tupled =
         WFREC
           (@R.
              WF R ∧ (∀l a. R (0::a,l) (a,F::l)) ∧
              ∀l a. R (1::a,l) (a,T::l))
           (λbitify_tupled a'.
              case a' of
                (a,[]) =&gt; I a
              | (a,T::l) =&gt; I (bitify_tupled (1::a,l))
              | (a,F::l) =&gt; I (bitify_tupled (0::a,l)))

   [<a name="bitwise_def-val"><b>bitwise_def</b></a>]  Definition

      |- ∀f v1 v2.
           bitwise f v1 v2 =
           (let m = MAX (LENGTH v1) (LENGTH v2)
            in
              MAP (UNCURRY f) (ZIP (fixwidth m v1,fixwidth m v2)))

   [<a name="bnand_def-val"><b>bnand_def</b></a>]  Definition

      |- bnand = bitwise (λx y. ¬(x ∧ y))

   [<a name="bnor_def-val"><b>bnor_def</b></a>]  Definition

      |- bnor = bitwise (λx y. ¬(x ∨ y))

   [<a name="bnot_def-val"><b>bnot_def</b></a>]  Definition

      |- bnot = MAP $~

   [<a name="boolify_def-val"><b>boolify_def</b></a>]  Definition

      |- (∀a. boolify a [] = a) ∧
         ∀a n l. boolify a (n::l) = boolify ((n ≠ 0)::a) l

   [<a name="bor_def-val"><b>bor_def</b></a>]  Definition

      |- bor = bitwise $\/

   [<a name="bxnor_def-val"><b>bxnor_def</b></a>]  Definition

      |- bxnor = bitwise $&lt;=&gt;

   [<a name="bxor_def-val"><b>bxor_def</b></a>]  Definition

      |- bxor = bitwise (λx y. x ⇎ y)

   [<a name="extend_def-val"><b>extend_def</b></a>]  Definition

      |- (∀v0 l. extend v0 0 l = l) ∧
         ∀c n l. extend c (SUC n) l = extend c n (c::l)

   [<a name="field_def-val"><b>field_def</b></a>]  Definition

      |- ∀h l v. field h l v = fixwidth (SUC h − l) (shiftr v l)

   [<a name="field_insert_def-val"><b>field_insert_def</b></a>]  Definition

      |- ∀h l s.
           field_insert h l s =
           modify (λi. COND (l ≤ i ∧ i ≤ h) (testbit (i − l) s))

   [<a name="fixwidth_def-val"><b>fixwidth_def</b></a>]  Definition

      |- ∀n v.
           fixwidth n v =
           (let l = LENGTH v
            in
              if l &lt; n then zero_extend n v else DROP (l − n) v)

   [<a name="modify_def-val"><b>modify_def</b></a>]  Definition

      |- ∀f v.
           modify f v = MAP (UNCURRY f) (ZIP (rev_count_list (LENGTH v),v))

   [<a name="n2v_def-val"><b>n2v_def</b></a>]  Definition

      |- ∀n.
           n2v n =
           if n = 0 then [F]
           else
             (let w = LOG2 n
              in
                PAD_LEFT F (w + 1)
                  (boolify [] (num_to_bin_list (BITS w 0 n))))

   [<a name="replicate_def-val"><b>replicate_def</b></a>]  Definition

      |- ∀v n. replicate v n = FLAT (GENLIST (K v) n)

   [<a name="rev_count_list_def-val"><b>rev_count_list_def</b></a>]  Definition

      |- ∀n. rev_count_list n = GENLIST (λi. n − 1 − i) n

   [<a name="rotate_def-val"><b>rotate_def</b></a>]  Definition

      |- ∀v m.
           rotate v m =
           (let l = LENGTH v in
            let x = m MOD l
            in
              if x = 0 then v else field (x − 1) 0 v ++ field (l − 1) x v)

   [<a name="s2v_def-val"><b>s2v_def</b></a>]  Definition

      |- s2v = MAP (λc. (c = #"1") ∨ (c = #"T"))

   [<a name="shiftl_def-val"><b>shiftl_def</b></a>]  Definition

      |- ∀v m. shiftl v m = PAD_RIGHT F (LENGTH v + m) v

   [<a name="shiftr_def-val"><b>shiftr_def</b></a>]  Definition

      |- ∀v m. shiftr v m = TAKE (LENGTH v − m) v

   [<a name="sign_extend_def-val"><b>sign_extend_def</b></a>]  Definition

      |- ∀n v. sign_extend n v = PAD_LEFT (HD v) n v

   [<a name="testbit_def-val"><b>testbit_def</b></a>]  Definition

      |- ∀b v. testbit b v ⇔ (field b b v = [T])

   [<a name="v2n_def-val"><b>v2n_def</b></a>]  Definition

      |- ∀l. v2n l = num_from_bin_list (bitify [] l)

   [<a name="v2s_def-val"><b>v2s_def</b></a>]  Definition

      |- v2s = MAP (λb. if b then #"1" else #"0")

   [<a name="v2w_def-val"><b>v2w_def</b></a>]  Definition

      |- ∀v. v2w v = FCP i. testbit i v

   [<a name="w2v_def-val"><b>w2v_def</b></a>]  Definition

      |- ∀w.
           w2v w =
           GENLIST (λi. w ' (dimindex (:α) − 1 − i)) (dimindex (:α))

   [<a name="zero_extend_def-val"><b>zero_extend_def</b></a>]  Definition

      |- ∀n v. zero_extend n v = PAD_LEFT F n v

   [<a name="bit_v2w-val"><b>bit_v2w</b></a>]  Theorem

      |- ∀n v. word_bit n (v2w v) ⇔ n &lt; dimindex (:α) ∧ testbit n v

   [<a name="bitify_def-val"><b>bitify_def</b></a>]  Theorem

      |- (∀a. bitify a [] = a) ∧
         (∀l a. bitify a (F::l) = bitify (0::a) l) ∧
         ∀l a. bitify a (T::l) = bitify (1::a) l

   [<a name="bitify_ind-val"><b>bitify_ind</b></a>]  Theorem

      |- ∀P.
           (∀a. P a []) ∧ (∀a l. P (0::a) l ⇒ P a (F::l)) ∧
           (∀a l. P (1::a) l ⇒ P a (T::l)) ⇒
           ∀v v1. P v v1

   [<a name="bitify_reverse_map-val"><b>bitify_reverse_map</b></a>]  Theorem

      |- ∀v a. bitify a v = REVERSE (MAP (λb. if b then 1 else 0) v) ++ a

   [<a name="bitstring_nchotomy-val"><b>bitstring_nchotomy</b></a>]  Theorem

      |- ∀w. ∃v. w = v2w v

   [<a name="boolify_reverse_map-val"><b>boolify_reverse_map</b></a>]  Theorem

      |- ∀v a. boolify a v = REVERSE (MAP (λn. n ≠ 0) v) ++ a

   [<a name="el_field-val"><b>el_field</b></a>]  Theorem

      |- ∀v h l i.
           i &lt; SUC h − l ⇒
           (EL i (field h l v) ⇔
            SUC h ≤ i + LENGTH v ∧ EL (i + LENGTH v − SUC h) v)

   [<a name="el_fixwidth-val"><b>el_fixwidth</b></a>]  Theorem

      |- ∀i n w.
           i &lt; n ⇒
           (EL i (fixwidth n w) ⇔
            if LENGTH w &lt; n then
              n − LENGTH w ≤ i ∧ EL (i − (n − LENGTH w)) w
            else EL (i + (LENGTH w − n)) w)

   [<a name="el_rev_count_list-val"><b>el_rev_count_list</b></a>]  Theorem

      |- ∀n i. i &lt; n ⇒ (EL i (rev_count_list n) = n − 1 − i)

   [<a name="el_shiftr-val"><b>el_shiftr</b></a>]  Theorem

      |- ∀i v n d.
           n &lt; d ∧ i &lt; d − n ∧ 0 &lt; d ⇒
           (EL i (shiftr (fixwidth d v) n) ⇔
            d ≤ i + LENGTH v ∧ EL (i + LENGTH v − d) v)

   [<a name="el_sign_extend-val"><b>el_sign_extend</b></a>]  Theorem

      |- ∀n i v.
           EL i (sign_extend n v) =
           if i &lt; n − LENGTH v then EL 0 v else EL (i − (n − LENGTH v)) v

   [<a name="el_w2v-val"><b>el_w2v</b></a>]  Theorem

      |- ∀w n.
           n &lt; dimindex (:α) ⇒ (EL n (w2v w) ⇔ w ' (dimindex (:α) − 1 − n))

   [<a name="el_zero_extend-val"><b>el_zero_extend</b></a>]  Theorem

      |- ∀n i v.
           EL i (zero_extend n v) ⇔
           n − LENGTH v ≤ i ∧ EL (i − (n − LENGTH v)) v

   [<a name="every_bit_bitify-val"><b>every_bit_bitify</b></a>]  Theorem

      |- ∀v. EVERY ($&gt; 2) (bitify [] v)

   [<a name="extend-val"><b>extend</b></a>]  Theorem

      |- (∀n v. zero_extend n v = extend F (n − LENGTH v) v) ∧
         ∀n v. sign_extend n v = extend (HD v) (n − LENGTH v) v

   [<a name="extend_cons-val"><b>extend_cons</b></a>]  Theorem

      |- ∀n c l. extend c (SUC n) l = c::extend c n l

   [<a name="extend_def_compute-val"><b>extend_def_compute</b></a>]  Theorem

      |- (∀v0 l. extend v0 0 l = l) ∧
         (∀c n l.
            extend c (NUMERAL (BIT1 n)) l =
            extend c (NUMERAL (BIT1 n) − 1) (c::l)) ∧
         ∀c n l.
           extend c (NUMERAL (BIT2 n)) l =
           extend c (NUMERAL (BIT1 n)) (c::l)

   [<a name="extract_v2w-val"><b>extract_v2w</b></a>]  Theorem

      |- ∀h l v.
           LENGTH v ≤ dimindex (:α) ∧ (dimindex (:β) = SUC h − l) ∧
           dimindex (:β) &lt; dimindex (:α) ⇒
           ((h &gt;&lt; l) (v2w v) = v2w (field h l v))

   [<a name="field_concat_left-val"><b>field_concat_left</b></a>]  Theorem

      |- ∀h l a b.
           l ≤ h ∧ LENGTH b ≤ l ⇒
           (field h l (a ++ b) = field (h − LENGTH b) (l − LENGTH b) a)

   [<a name="field_concat_right-val"><b>field_concat_right</b></a>]  Theorem

      |- ∀h a b. (LENGTH b = SUC h) ⇒ (field h 0 (a ++ b) = b)

   [<a name="field_fixwidth-val"><b>field_fixwidth</b></a>]  Theorem

      |- ∀h v. field h 0 v = fixwidth (SUC h) v

   [<a name="field_id_imp-val"><b>field_id_imp</b></a>]  Theorem

      |- ∀n v. (SUC n = LENGTH v) ⇒ (field n 0 v = v)

   [<a name="fixwidth-val"><b>fixwidth</b></a>]  Theorem

      |- ∀n v.
           fixwidth n v =
           (let l = LENGTH v
            in
              if l &lt; n then extend F (n − l) v else DROP (l − n) v)

   [<a name="fixwidth_eq-val"><b>fixwidth_eq</b></a>]  Theorem

      |- ∀n v w.
           (fixwidth n v = fixwidth n w) ⇔
           ∀i. i &lt; n ⇒ (testbit i v ⇔ testbit i w)

   [<a name="fixwidth_fixwidth-val"><b>fixwidth_fixwidth</b></a>]  Theorem

      |- ∀n v. fixwidth n (fixwidth n v) = fixwidth n v

   [<a name="fixwidth_id-val"><b>fixwidth_id</b></a>]  Theorem

      |- ∀w. fixwidth (LENGTH w) w = w

   [<a name="fixwidth_id_imp-val"><b>fixwidth_id_imp</b></a>]  Theorem

      |- ∀n w. (n = LENGTH w) ⇒ (fixwidth n w = w)

   [<a name="length_bitify-val"><b>length_bitify</b></a>]  Theorem

      |- ∀v l. LENGTH (bitify l v) = LENGTH l + LENGTH v

   [<a name="length_bitify_null-val"><b>length_bitify_null</b></a>]  Theorem

      |- ∀v l. LENGTH (bitify [] v) = LENGTH v

   [<a name="length_field-val"><b>length_field</b></a>]  Theorem

      |- ∀h l v. LENGTH (field h l v) = SUC h − l

   [<a name="length_fixwidth-val"><b>length_fixwidth</b></a>]  Theorem

      |- ∀n v. LENGTH (fixwidth n v) = n

   [<a name="length_pad_left-val"><b>length_pad_left</b></a>]  Theorem

      |- ∀x n a.
           LENGTH (PAD_LEFT x n a) = if LENGTH a &lt; n then n else LENGTH a

   [<a name="length_pad_right-val"><b>length_pad_right</b></a>]  Theorem

      |- ∀x n a.
           LENGTH (PAD_RIGHT x n a) = if LENGTH a &lt; n then n else LENGTH a

   [<a name="length_rev_count_list-val"><b>length_rev_count_list</b></a>]  Theorem

      |- ∀n. LENGTH (rev_count_list n) = n

   [<a name="length_shiftr-val"><b>length_shiftr</b></a>]  Theorem

      |- ∀v n. LENGTH (shiftr v n) = LENGTH v − n

   [<a name="length_sign_extend-val"><b>length_sign_extend</b></a>]  Theorem

      |- ∀n v. LENGTH v &lt; n ⇒ (LENGTH (sign_extend n v) = n)

   [<a name="length_w2v-val"><b>length_w2v</b></a>]  Theorem

      |- ∀w. LENGTH (w2v w) = dimindex (:α)

   [<a name="length_zero_extend-val"><b>length_zero_extend</b></a>]  Theorem

      |- ∀n v. LENGTH v &lt; n ⇒ (LENGTH (zero_extend n v) = n)

   [<a name="n2w_v2n-val"><b>n2w_v2n</b></a>]  Theorem

      |- ∀v. n2w (v2n v) = v2w v

   [<a name="ops_to_n2w-val"><b>ops_to_n2w</b></a>]  Theorem

      |- (∀v. -v2w v = -n2w (v2n v)) ∧
         (∀v. word_log2 (v2w v) = word_log2 (n2w (v2n v))) ∧
         (∀v n. (v2w v = n2w n) ⇔ (n2w (v2n v) = n2w n)) ∧
         (∀v n. (n2w n = v2w v) ⇔ (n2w n = n2w (v2n v))) ∧
         (∀v w. v2w v + w = n2w (v2n v) + w) ∧
         (∀v w. w + v2w v = w + n2w (v2n v)) ∧
         (∀v w. v2w v − w = n2w (v2n v) − w) ∧
         (∀v w. w − v2w v = w − n2w (v2n v)) ∧
         (∀v w. v2w v * w = n2w (v2n v) * w) ∧
         (∀v w. w * v2w v = w * n2w (v2n v)) ∧
         (∀v w. v2w v / w = n2w (v2n v) / w) ∧
         (∀v w. w / v2w v = w / n2w (v2n v)) ∧
         (∀v w. v2w v // w = n2w (v2n v) // w) ∧
         (∀v w. w // v2w v = w // n2w (v2n v)) ∧
         (∀v w. word_mod (v2w v) w = word_mod (n2w (v2n v)) w) ∧
         (∀v w. word_mod w (v2w v) = word_mod w (n2w (v2n v))) ∧
         (∀v w. v2w v &lt; w ⇔ n2w (v2n v) &lt; w) ∧
         (∀v w. w &lt; v2w v ⇔ w &lt; n2w (v2n v)) ∧
         (∀v w. v2w v &gt; w ⇔ n2w (v2n v) &gt; w) ∧
         (∀v w. w &gt; v2w v ⇔ w &gt; n2w (v2n v)) ∧
         (∀v w. v2w v ≤ w ⇔ n2w (v2n v) ≤ w) ∧
         (∀v w. w ≤ v2w v ⇔ w ≤ n2w (v2n v)) ∧
         (∀v w. v2w v ≥ w ⇔ n2w (v2n v) ≥ w) ∧
         (∀v w. w ≥ v2w v ⇔ w ≥ n2w (v2n v)) ∧
         (∀v w. v2w v &lt;₊ w ⇔ n2w (v2n v) &lt;₊ w) ∧
         (∀v w. w &lt;₊ v2w v ⇔ w &lt;₊ n2w (v2n v)) ∧
         (∀v w. v2w v &gt;₊ w ⇔ n2w (v2n v) &gt;₊ w) ∧
         (∀v w. w &gt;₊ v2w v ⇔ w &gt;₊ n2w (v2n v)) ∧
         (∀v w. v2w v ≤₊ w ⇔ n2w (v2n v) ≤₊ w) ∧
         (∀v w. w ≤₊ v2w v ⇔ w ≤₊ n2w (v2n v)) ∧
         (∀v w. v2w v ≥₊ w ⇔ n2w (v2n v) ≥₊ w) ∧
         ∀v w. w ≥₊ v2w v ⇔ w ≥₊ n2w (v2n v)

   [<a name="ops_to_v2w-val"><b>ops_to_v2w</b></a>]  Theorem

      |- (∀v n. v2w v ‖ n2w n = v2w v ‖ v2w (n2v n)) ∧
         (∀v n. n2w n ‖ v2w v = v2w (n2v n) ‖ v2w v) ∧
         (∀v n. v2w v && n2w n = v2w v && v2w (n2v n)) ∧
         (∀v n. n2w n && v2w v = v2w (n2v n) && v2w v) ∧
         (∀v n. v2w v ⊕ n2w n = v2w v ⊕ v2w (n2v n)) ∧
         (∀v n. n2w n ⊕ v2w v = v2w (n2v n) ⊕ v2w v) ∧
         (∀v n. v2w v ~|| n2w n = v2w v ~|| v2w (n2v n)) ∧
         (∀v n. n2w n ~|| v2w v = v2w (n2v n) ~|| v2w v) ∧
         (∀v n. v2w v ~&& n2w n = v2w v ~&& v2w (n2v n)) ∧
         (∀v n. n2w n ~&& v2w v = v2w (n2v n) ~&& v2w v) ∧
         (∀v n. v2w v ~?? n2w n = v2w v ~?? v2w (n2v n)) ∧
         (∀v n. n2w n ~?? v2w v = v2w (n2v n) ~?? v2w v) ∧
         (∀v n. v2w v @@ n2w n = v2w v @@ v2w (n2v n)) ∧
         (∀v n. n2w n @@ v2w v = v2w (n2v n) @@ v2w v) ∧
         (∀v n.
            word_join (v2w v) (n2w n) = word_join (v2w v) (v2w (n2v n))) ∧
         ∀v n. word_join (n2w n) (v2w v) = word_join (v2w (n2v n)) (v2w v)

   [<a name="pad_left_extend-val"><b>pad_left_extend</b></a>]  Theorem

      |- ∀n l c. PAD_LEFT c n l = extend c (n − LENGTH l) l

   [<a name="ranged_bitstring_nchotomy-val"><b>ranged_bitstring_nchotomy</b></a>]  Theorem

      |- ∀w. ∃v. (w = v2w v) ∧ Abbrev (LENGTH v = dimindex (:α))

   [<a name="reduce_and_v2w-val"><b>reduce_and_v2w</b></a>]  Theorem

      |- ∀v. reduce_and (v2w v) = word_reduce $/\ (v2w v)

   [<a name="reduce_or_v2w-val"><b>reduce_or_v2w</b></a>]  Theorem

      |- ∀v. reduce_or (v2w v) = word_reduce $\/ (v2w v)

   [<a name="shiftl_replicate_F-val"><b>shiftl_replicate_F</b></a>]  Theorem

      |- ∀v n. shiftl v n = v ++ replicate [F] n

   [<a name="shiftr_0-val"><b>shiftr_0</b></a>]  Theorem

      |- ∀v. shiftr v 0 = v

   [<a name="sw2sw_v2w-val"><b>sw2sw_v2w</b></a>]  Theorem

      |- ∀v.
           sw2sw (v2w v) =
           if dimindex (:α) &lt; dimindex (:β) then
             v2w (sign_extend (dimindex (:β)) (fixwidth (dimindex (:α)) v))
           else v2w (fixwidth (dimindex (:β)) v)

   [<a name="testbit-val"><b>testbit</b></a>]  Theorem

      |- ∀b v. testbit b v ⇔ (let n = LENGTH v in b &lt; n ∧ EL (n − 1 − b) v)

   [<a name="testbit_el-val"><b>testbit_el</b></a>]  Theorem

      |- ∀v i. i &lt; LENGTH v ⇒ (testbit i v ⇔ EL (LENGTH v − 1 − i) v)

   [<a name="testbit_geq_len-val"><b>testbit_geq_len</b></a>]  Theorem

      |- ∀v i. LENGTH v ≤ i ⇒ ¬testbit i v

   [<a name="testbit_w2v-val"><b>testbit_w2v</b></a>]  Theorem

      |- ∀n w. testbit n (w2v w) ⇔ word_bit n w

   [<a name="v2n_lt-val"><b>v2n_lt</b></a>]  Theorem

      |- ∀v. v2n v &lt; 2 ** LENGTH v

   [<a name="v2n_n2v-val"><b>v2n_n2v</b></a>]  Theorem

      |- ∀n. v2n (n2v n) = n

   [<a name="v2w_11-val"><b>v2w_11</b></a>]  Theorem

      |- ∀v w.
           (v2w v = v2w w) ⇔
           (fixwidth (dimindex (:α)) v = fixwidth (dimindex (:α)) w)

   [<a name="v2w_fixwidth-val"><b>v2w_fixwidth</b></a>]  Theorem

      |- ∀v. v2w (fixwidth (dimindex (:α)) v) = v2w v

   [<a name="v2w_n2v-val"><b>v2w_n2v</b></a>]  Theorem

      |- ∀n. v2w (n2v n) = n2w n

   [<a name="v2w_w2v-val"><b>v2w_w2v</b></a>]  Theorem

      |- ∀w. v2w (w2v w) = w

   [<a name="w2n_v2w-val"><b>w2n_v2w</b></a>]  Theorem

      |- ∀v. w2n (v2w v) = MOD_2EXP (dimindex (:α)) (v2n v)

   [<a name="w2v_v2w-val"><b>w2v_v2w</b></a>]  Theorem

      |- ∀v. w2v (v2w v) = fixwidth (dimindex (:α)) v

   [<a name="w2w_v2w-val"><b>w2w_v2w</b></a>]  Theorem

      |- ∀v.
           w2w (v2w v) =
           v2w
             (fixwidth
                (if dimindex (:β) &lt; dimindex (:α) then dimindex (:β)
                 else dimindex (:α)) v)

   [<a name="word_1comp_v2w-val"><b>word_1comp_v2w</b></a>]  Theorem

      |- ∀v. ¬v2w v = v2w (bnot (fixwidth (dimindex (:α)) v))

   [<a name="word_and_v2w-val"><b>word_and_v2w</b></a>]  Theorem

      |- ∀v w. v2w v && v2w w = v2w (band v w)

   [<a name="word_asr_v2w-val"><b>word_asr_v2w</b></a>]  Theorem

      |- ∀n v.
           v2w v ≫ n =
           (let l = fixwidth (dimindex (:α)) v
            in
              v2w
                (sign_extend (dimindex (:α))
                   (if dimindex (:α) ≤ n then [HD l] else shiftr l n)))

   [<a name="word_bit_last_shiftr-val"><b>word_bit_last_shiftr</b></a>]  Theorem

      |- ∀i v.
           i &lt; dimindex (:α) ⇒
           (word_bit i (v2w v) ⇔ (let l = shiftr v i in ¬NULL l ∧ LAST l))

   [<a name="word_bits_v2w-val"><b>word_bits_v2w</b></a>]  Theorem

      |- ∀h l v.
           (h -- l) (v2w v) = v2w (field h l (fixwidth (dimindex (:α)) v))

   [<a name="word_concat_v2w-val"><b>word_concat_v2w</b></a>]  Theorem

      |- ∀v1 v2.
           FINITE 𝕌(:α) ∧ FINITE 𝕌(:β) ⇒
           (v2w v1 @@ v2w v2 =
            v2w
              (fixwidth
                 (MIN (dimindex (:γ)) (dimindex (:α) + dimindex (:β)))
                 (v1 ++ fixwidth (dimindex (:β)) v2)))

   [<a name="word_concat_v2w_rwt-val"><b>word_concat_v2w_rwt</b></a>]  Theorem

      |- ∀v1 v2.
           v2w v1 @@ v2w v2 =
           if FINITE 𝕌(:α) ∧ FINITE 𝕌(:β) then
             v2w
               (fixwidth
                  (MIN (dimindex (:γ)) (dimindex (:α) + dimindex (:β)))
                  (v1 ++ fixwidth (dimindex (:β)) v2))
           else FAIL $@@ bad domain (v2w v1) (v2w v2)

   [<a name="word_extract_v2w-val"><b>word_extract_v2w</b></a>]  Theorem

      |- ∀h l v. (h &gt;&lt; l) (v2w v) = w2w ((h -- l) (v2w v))

   [<a name="word_index_v2w-val"><b>word_index_v2w</b></a>]  Theorem

      |- ∀v i.
           v2w v ' i ⇔
           if i &lt; dimindex (:α) then testbit i v
           else FAIL $' index too large (v2w v) i

   [<a name="word_join_v2w-val"><b>word_join_v2w</b></a>]  Theorem

      |- ∀v1 v2.
           FINITE 𝕌(:α) ∧ FINITE 𝕌(:β) ⇒
           (word_join (v2w v1) (v2w v2) =
            v2w (v1 ++ fixwidth (dimindex (:β)) v2))

   [<a name="word_join_v2w_rwt-val"><b>word_join_v2w_rwt</b></a>]  Theorem

      |- ∀v1 v2.
           word_join (v2w v1) (v2w v2) =
           if FINITE 𝕌(:α) ∧ FINITE 𝕌(:β) then
             v2w (v1 ++ fixwidth (dimindex (:β)) v2)
           else FAIL word_join bad domain (v2w v1) (v2w v2)

   [<a name="word_lsb_v2w-val"><b>word_lsb_v2w</b></a>]  Theorem

      |- ∀v. word_lsb (v2w v) ⇔ v ≠ [] ∧ LAST v

   [<a name="word_lsl_v2w-val"><b>word_lsl_v2w</b></a>]  Theorem

      |- ∀n v. v2w v ≪ n = v2w (shiftl v n)

   [<a name="word_lsr_v2w-val"><b>word_lsr_v2w</b></a>]  Theorem

      |- ∀n v. v2w v ⋙ n = v2w (shiftr (fixwidth (dimindex (:α)) v) n)

   [<a name="word_modify_v2w-val"><b>word_modify_v2w</b></a>]  Theorem

      |- ∀f v.
           word_modify f (v2w v) =
           v2w (modify f (fixwidth (dimindex (:α)) v))

   [<a name="word_msb_v2w-val"><b>word_msb_v2w</b></a>]  Theorem

      |- ∀v. word_msb (v2w v) ⇔ testbit (dimindex (:α) − 1) v

   [<a name="word_nand_v2w-val"><b>word_nand_v2w</b></a>]  Theorem

      |- ∀v w.
           v2w v ~&& v2w w =
           v2w
             (bnand (fixwidth (dimindex (:α)) v)
                (fixwidth (dimindex (:α)) w))

   [<a name="word_nor_v2w-val"><b>word_nor_v2w</b></a>]  Theorem

      |- ∀v w.
           v2w v ~|| v2w w =
           v2w
             (bnor (fixwidth (dimindex (:α)) v)
                (fixwidth (dimindex (:α)) w))

   [<a name="word_or_v2w-val"><b>word_or_v2w</b></a>]  Theorem

      |- ∀v w. v2w v ‖ v2w w = v2w (bor v w)

   [<a name="word_reduce_v2w-val"><b>word_reduce_v2w</b></a>]  Theorem

      |- ∀f v.
           word_reduce f (v2w v) =
           (let l = fixwidth (dimindex (:α)) v
            in
              v2w [FOLDL f (HD l) (TL l)])

   [<a name="word_reverse_v2w-val"><b>word_reverse_v2w</b></a>]  Theorem

      |- ∀v.
           word_reverse (v2w v) =
           v2w (REVERSE (fixwidth (dimindex (:α)) v))

   [<a name="word_ror_v2w-val"><b>word_ror_v2w</b></a>]  Theorem

      |- ∀n v. v2w v ⇄ n = v2w (rotate (fixwidth (dimindex (:α)) v) n)

   [<a name="word_slice_v2w-val"><b>word_slice_v2w</b></a>]  Theorem

      |- ∀h l v.
           (h '' l) (v2w v) =
           v2w (shiftl (field h l (fixwidth (dimindex (:α)) v)) l)

   [<a name="word_xnor_v2w-val"><b>word_xnor_v2w</b></a>]  Theorem

      |- ∀v w.
           v2w v ~?? v2w w =
           v2w
             (bxnor (fixwidth (dimindex (:α)) v)
                (fixwidth (dimindex (:α)) w))

   [<a name="word_xor_v2w-val"><b>word_xor_v2w</b></a>]  Theorem

      |- ∀v w. v2w v ⊕ v2w w = v2w (bxor v w)


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/n-bit/bitstringScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-10</a></em></p></body></html>
