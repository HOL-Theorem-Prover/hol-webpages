<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure lbtreeTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure lbtreeTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/llist/lbtreeScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature lbtreeTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#Lf_def-val">Lf_def</a> : thm
<a name="line7"></a>    val <a href="#Lfrep_def-val">Lfrep_def</a> : thm
<a name="line8"></a>    val <a href="#Nd_def-val">Nd_def</a> : thm
<a name="line9"></a>    val <a href="#Ndrep_def-val">Ndrep_def</a> : thm
<a name="line10"></a>    val <a href="#bf_flatten_def-val">bf_flatten_def</a> : thm
<a name="line11"></a>    val <a href="#depth_def-val">depth_def</a> : thm
<a name="line12"></a>    val <a href="#finite_def-val">finite_def</a> : thm
<a name="line13"></a>    val <a href="#is_lbtree_def-val">is_lbtree_def</a> : thm
<a name="line14"></a>    val <a href="#is_mmindex_def-val">is_mmindex_def</a> : thm
<a name="line15"></a>    val <a href="#lbtree_TY_DEF-val">lbtree_TY_DEF</a> : thm
<a name="line16"></a>    val <a href="#lbtree_absrep-val">lbtree_absrep</a> : thm
<a name="line17"></a>    val <a href="#lbtree_case_def-val">lbtree_case_def</a> : thm
<a name="line18"></a>    val <a href="#map_def-val">map_def</a> : thm
<a name="line19"></a>    val <a href="#mem_def-val">mem_def</a> : thm
<a name="line20"></a>    val <a href="#mindepth_def-val">mindepth_def</a> : thm
<a name="line21"></a>    val <a href="#optmin_curried_def-val">optmin_curried_def</a> : thm
<a name="line22"></a>    val <a href="#optmin_tupled_primitive_def-val">optmin_tupled_primitive_def</a> : thm
<a name="line23"></a>    val <a href="#path_follow_def-val">path_follow_def</a> : thm
<a name="line24"></a>
<a name="line25"></a>  (*  Theorems  *)
<a name="line26"></a>    val <a href="#EXISTS_FIRST-val">EXISTS_FIRST</a> : thm
<a name="line27"></a>    val <a href="#Lf_NOT_Nd-val">Lf_NOT_Nd</a> : thm
<a name="line28"></a>    val <a href="#Nd_11-val">Nd_11</a> : thm
<a name="line29"></a>    val <a href="#bf_flatten_append-val">bf_flatten_append</a> : thm
<a name="line30"></a>    val <a href="#bf_flatten_eq_lnil-val">bf_flatten_eq_lnil</a> : thm
<a name="line31"></a>    val <a href="#depth_cases-val">depth_cases</a> : thm
<a name="line32"></a>    val <a href="#depth_ind-val">depth_ind</a> : thm
<a name="line33"></a>    val <a href="#depth_mem-val">depth_mem</a> : thm
<a name="line34"></a>    val <a href="#depth_rules-val">depth_rules</a> : thm
<a name="line35"></a>    val <a href="#depth_strongind-val">depth_strongind</a> : thm
<a name="line36"></a>    val <a href="#exists_bf_flatten-val">exists_bf_flatten</a> : thm
<a name="line37"></a>    val <a href="#finite_cases-val">finite_cases</a> : thm
<a name="line38"></a>    val <a href="#finite_ind-val">finite_ind</a> : thm
<a name="line39"></a>    val <a href="#finite_map-val">finite_map</a> : thm
<a name="line40"></a>    val <a href="#finite_rules-val">finite_rules</a> : thm
<a name="line41"></a>    val <a href="#finite_strongind-val">finite_strongind</a> : thm
<a name="line42"></a>    val <a href="#finite_thm-val">finite_thm</a> : thm
<a name="line43"></a>    val <a href="#lbtree_bisimulation-val">lbtree_bisimulation</a> : thm
<a name="line44"></a>    val <a href="#lbtree_case_thm-val">lbtree_case_thm</a> : thm
<a name="line45"></a>    val <a href="#lbtree_cases-val">lbtree_cases</a> : thm
<a name="line46"></a>    val <a href="#lbtree_strong_bisimulation-val">lbtree_strong_bisimulation</a> : thm
<a name="line47"></a>    val <a href="#lbtree_ue_Axiom-val">lbtree_ue_Axiom</a> : thm
<a name="line48"></a>    val <a href="#map_eq_Lf-val">map_eq_Lf</a> : thm
<a name="line49"></a>    val <a href="#map_eq_Nd-val">map_eq_Nd</a> : thm
<a name="line50"></a>    val <a href="#mem_bf_flatten-val">mem_bf_flatten</a> : thm
<a name="line51"></a>    val <a href="#mem_cases-val">mem_cases</a> : thm
<a name="line52"></a>    val <a href="#mem_depth-val">mem_depth</a> : thm
<a name="line53"></a>    val <a href="#mem_ind-val">mem_ind</a> : thm
<a name="line54"></a>    val <a href="#mem_mindepth-val">mem_mindepth</a> : thm
<a name="line55"></a>    val <a href="#mem_rules-val">mem_rules</a> : thm
<a name="line56"></a>    val <a href="#mem_strongind-val">mem_strongind</a> : thm
<a name="line57"></a>    val <a href="#mem_thm-val">mem_thm</a> : thm
<a name="line58"></a>    val <a href="#mindepth_depth-val">mindepth_depth</a> : thm
<a name="line59"></a>    val <a href="#mindepth_thm-val">mindepth_thm</a> : thm
<a name="line60"></a>    val <a href="#mmindex_EXISTS-val">mmindex_EXISTS</a> : thm
<a name="line61"></a>    val <a href="#mmindex_unique-val">mmindex_unique</a> : thm
<a name="line62"></a>    val <a href="#optmin_def-val">optmin_def</a> : thm
<a name="line63"></a>    val <a href="#optmin_ind-val">optmin_ind</a> : thm
<a name="line64"></a>
<a name="line65"></a>  val lbtree_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line66"></a>(*
   [llist] Parent theory of "lbtree"

   [<a name="Lf_def-val"><b>Lf_def</b></a>]  Definition

      |- Lf = lbtree_abs Lfrep

   [<a name="Lfrep_def-val"><b>Lfrep_def</b></a>]  Definition

      |- Lfrep = (λl. NONE)

   [<a name="Nd_def-val"><b>Nd_def</b></a>]  Definition

      |- ∀a t1 t2.
           Nd a t1 t2 =
           lbtree_abs (Ndrep a (lbtree_rep t1) (lbtree_rep t2))

   [<a name="Ndrep_def-val"><b>Ndrep_def</b></a>]  Definition

      |- ∀a t1 t2.
           Ndrep a t1 t2 =
           (λl. case l of [] =&gt; SOME a | T::xs =&gt; t1 xs | F::xs =&gt; t2 xs)

   [<a name="bf_flatten_def-val"><b>bf_flatten_def</b></a>]  Definition

      |- (bf_flatten [] = [||]) ∧
         (∀ts. bf_flatten (Lf::ts) = bf_flatten ts) ∧
         ∀a t1 t2 ts.
           bf_flatten (Nd a t1 t2::ts) = a:::bf_flatten (ts ++ [t1; t2])

   [<a name="depth_def-val"><b>depth_def</b></a>]  Definition

      |- lbtree$depth =
         (λa0 a1 a2.
            ∀depth'.
              (∀a0 a1 a2.
                 (∃t1 t2. (a1 = Nd a0 t1 t2) ∧ (a2 = 0)) ∨
                 (∃m a t1 t2.
                    (a1 = Nd a t1 t2) ∧ (a2 = SUC m) ∧ depth' a0 t1 m) ∨
                 (∃m a t1 t2.
                    (a1 = Nd a t1 t2) ∧ (a2 = SUC m) ∧ depth' a0 t2 m) ⇒
                 depth' a0 a1 a2) ⇒
              depth' a0 a1 a2)

   [<a name="finite_def-val"><b>finite_def</b></a>]  Definition

      |- finite =
         (λa0.
            ∀finite'.
              (∀a0.
                 (a0 = Lf) ∨
                 (∃a t1 t2. (a0 = Nd a t1 t2) ∧ finite' t1 ∧ finite' t2) ⇒
                 finite' a0) ⇒
              finite' a0)

   [<a name="is_lbtree_def-val"><b>is_lbtree_def</b></a>]  Definition

      |- ∀t.
           is_lbtree t ⇔
           ∃P.
             (∀t.
                P t ⇒
                (t = Lfrep) ∨
                ∃a t1 t2. P t1 ∧ P t2 ∧ (t = Ndrep a t1 t2)) ∧ P t

   [<a name="is_mmindex_def-val"><b>is_mmindex_def</b></a>]  Definition

      |- ∀f l n d.
           lbtree$is_mmindex f l n d ⇔
           n &lt; LENGTH l ∧ (f (EL n l) = SOME d) ∧
           ∀i.
             i &lt; LENGTH l ⇒
             (f (EL i l) = NONE) ∨
             ∃d'. (f (EL i l) = SOME d') ∧ d ≤ d' ∧ (i &lt; n ⇒ d &lt; d')

   [<a name="lbtree_TY_DEF-val"><b>lbtree_TY_DEF</b></a>]  Definition

      |- ∃rep. TYPE_DEFINITION is_lbtree rep

   [<a name="lbtree_absrep-val"><b>lbtree_absrep</b></a>]  Definition

      |- (∀a. lbtree_abs (lbtree_rep a) = a) ∧
         ∀r. is_lbtree r ⇔ (lbtree_rep (lbtree_abs r) = r)

   [<a name="lbtree_case_def-val"><b>lbtree_case_def</b></a>]  Definition

      |- ∀e f t.
           lbtree_case e f t =
           if t = Lf then e
           else
             f (@a. ∃t1 t2. t = Nd a t1 t2) (@t1. ∃a t2. t = Nd a t1 t2)
               (@t2. ∃a t1. t = Nd a t1 t2)

   [<a name="map_def-val"><b>map_def</b></a>]  Definition

      |- ∀f.
           (map f Lf = Lf) ∧
           ∀a t1 t2. map f (Nd a t1 t2) = Nd (f a) (map f t1) (map f t2)

   [<a name="mem_def-val"><b>mem_def</b></a>]  Definition

      |- mem =
         (λa0 a1.
            ∀mem'.
              (∀a0 a1.
                 (∃t1 t2. a1 = Nd a0 t1 t2) ∨
                 (∃b t1 t2. (a1 = Nd b t1 t2) ∧ mem' a0 t1) ∨
                 (∃b t1 t2. (a1 = Nd b t1 t2) ∧ mem' a0 t2) ⇒
                 mem' a0 a1) ⇒
              mem' a0 a1)

   [<a name="mindepth_def-val"><b>mindepth_def</b></a>]  Definition

      |- ∀x t.
           lbtree$mindepth x t =
           if mem x t then SOME (LEAST n. lbtree$depth x t n) else NONE

   [<a name="optmin_curried_def-val"><b>optmin_curried_def</b></a>]  Definition

      |- ∀x x1. lbtree$optmin x x1 = optmin_tupled (x,x1)

   [<a name="optmin_tupled_primitive_def-val"><b>optmin_tupled_primitive_def</b></a>]  Definition

      |- optmin_tupled =
         WFREC (@R. WF R)
           (λoptmin_tupled a.
              case a of
                (NONE,NONE) =&gt; I NONE
              | (NONE,SOME y) =&gt; I (SOME y)
              | (SOME x,NONE) =&gt; I (SOME x)
              | (SOME x,SOME y') =&gt; I (SOME (MIN x y')))

   [<a name="path_follow_def-val"><b>path_follow_def</b></a>]  Definition

      |- (∀g x. path_follow g x [] = OPTION_MAP FST (g x)) ∧
         ∀g x h t.
           path_follow g x (h::t) =
           case g x of
             NONE =&gt; NONE
           | SOME (a,y,z) =&gt; path_follow g (if h then y else z) t

   [<a name="EXISTS_FIRST-val"><b>EXISTS_FIRST</b></a>]  Theorem

      |- ∀l.
           EXISTS P l ⇒
           ∃l1 x l2. (l = l1 ++ x::l2) ∧ EVERY ($~ o P) l1 ∧ P x

   [<a name="Lf_NOT_Nd-val"><b>Lf_NOT_Nd</b></a>]  Theorem

      |- Lf ≠ Nd a t1 t2

   [<a name="Nd_11-val"><b>Nd_11</b></a>]  Theorem

      |- (Nd a1 t1 u1 = Nd a2 t2 u2) ⇔ (a1 = a2) ∧ (t1 = t2) ∧ (u1 = u2)

   [<a name="bf_flatten_append-val"><b>bf_flatten_append</b></a>]  Theorem

      |- ∀l1. EVERY ($= Lf) l1 ⇒ (bf_flatten (l1 ++ l2) = bf_flatten l2)

   [<a name="bf_flatten_eq_lnil-val"><b>bf_flatten_eq_lnil</b></a>]  Theorem

      |- ∀l. (bf_flatten l = [||]) ⇔ EVERY ($= Lf) l

   [<a name="depth_cases-val"><b>depth_cases</b></a>]  Theorem

      |- ∀a0 a1 a2.
           lbtree$depth a0 a1 a2 ⇔
           (∃t1 t2. (a1 = Nd a0 t1 t2) ∧ (a2 = 0)) ∨
           (∃m a t1 t2.
              (a1 = Nd a t1 t2) ∧ (a2 = SUC m) ∧ lbtree$depth a0 t1 m) ∨
           ∃m a t1 t2.
             (a1 = Nd a t1 t2) ∧ (a2 = SUC m) ∧ lbtree$depth a0 t2 m

   [<a name="depth_ind-val"><b>depth_ind</b></a>]  Theorem

      |- ∀depth'.
           (∀x t1 t2. depth' x (Nd x t1 t2) 0) ∧
           (∀m x a t1 t2. depth' x t1 m ⇒ depth' x (Nd a t1 t2) (SUC m)) ∧
           (∀m x a t1 t2. depth' x t2 m ⇒ depth' x (Nd a t1 t2) (SUC m)) ⇒
           ∀a0 a1 a2. lbtree$depth a0 a1 a2 ⇒ depth' a0 a1 a2

   [<a name="depth_mem-val"><b>depth_mem</b></a>]  Theorem

      |- ∀x t n. lbtree$depth x t n ⇒ mem x t

   [<a name="depth_rules-val"><b>depth_rules</b></a>]  Theorem

      |- (∀x t1 t2. lbtree$depth x (Nd x t1 t2) 0) ∧
         (∀m x a t1 t2.
            lbtree$depth x t1 m ⇒ lbtree$depth x (Nd a t1 t2) (SUC m)) ∧
         ∀m x a t1 t2.
           lbtree$depth x t2 m ⇒ lbtree$depth x (Nd a t1 t2) (SUC m)

   [<a name="depth_strongind-val"><b>depth_strongind</b></a>]  Theorem

      |- ∀depth'.
           (∀x t1 t2. depth' x (Nd x t1 t2) 0) ∧
           (∀m x a t1 t2.
              lbtree$depth x t1 m ∧ depth' x t1 m ⇒
              depth' x (Nd a t1 t2) (SUC m)) ∧
           (∀m x a t1 t2.
              lbtree$depth x t2 m ∧ depth' x t2 m ⇒
              depth' x (Nd a t1 t2) (SUC m)) ⇒
           ∀a0 a1 a2. lbtree$depth a0 a1 a2 ⇒ depth' a0 a1 a2

   [<a name="exists_bf_flatten-val"><b>exists_bf_flatten</b></a>]  Theorem

      |- exists ($= x) (bf_flatten tlist) ⇒ EXISTS (mem x) tlist

   [<a name="finite_cases-val"><b>finite_cases</b></a>]  Theorem

      |- ∀a0.
           finite a0 ⇔
           (a0 = Lf) ∨ ∃a t1 t2. (a0 = Nd a t1 t2) ∧ finite t1 ∧ finite t2

   [<a name="finite_ind-val"><b>finite_ind</b></a>]  Theorem

      |- ∀finite'.
           finite' Lf ∧
           (∀a t1 t2. finite' t1 ∧ finite' t2 ⇒ finite' (Nd a t1 t2)) ⇒
           ∀a0. finite a0 ⇒ finite' a0

   [<a name="finite_map-val"><b>finite_map</b></a>]  Theorem

      |- finite (map f t) ⇔ finite t

   [<a name="finite_rules-val"><b>finite_rules</b></a>]  Theorem

      |- finite Lf ∧ ∀a t1 t2. finite t1 ∧ finite t2 ⇒ finite (Nd a t1 t2)

   [<a name="finite_strongind-val"><b>finite_strongind</b></a>]  Theorem

      |- ∀finite'.
           finite' Lf ∧
           (∀a t1 t2.
              finite t1 ∧ finite' t1 ∧ finite t2 ∧ finite' t2 ⇒
              finite' (Nd a t1 t2)) ⇒
           ∀a0. finite a0 ⇒ finite' a0

   [<a name="finite_thm-val"><b>finite_thm</b></a>]  Theorem

      |- (finite Lf ⇔ T) ∧ (finite (Nd a t1 t2) ⇔ finite t1 ∧ finite t2)

   [<a name="lbtree_bisimulation-val"><b>lbtree_bisimulation</b></a>]  Theorem

      |- ∀t u.
           (t = u) ⇔
           ∃R.
             R t u ∧
             ∀t u.
               R t u ⇒
               (t = Lf) ∧ (u = Lf) ∨
               ∃a t1 u1 t2 u2.
                 R t1 u1 ∧ R t2 u2 ∧ (t = Nd a t1 t2) ∧ (u = Nd a u1 u2)

   [<a name="lbtree_case_thm-val"><b>lbtree_case_thm</b></a>]  Theorem

      |- (lbtree_case e f Lf = e) ∧
         (lbtree_case e f (Nd a t1 t2) = f a t1 t2)

   [<a name="lbtree_cases-val"><b>lbtree_cases</b></a>]  Theorem

      |- ∀t. (t = Lf) ∨ ∃a t1 t2. t = Nd a t1 t2

   [<a name="lbtree_strong_bisimulation-val"><b>lbtree_strong_bisimulation</b></a>]  Theorem

      |- ∀t u.
           (t = u) ⇔
           ∃R.
             R t u ∧
             ∀t u.
               R t u ⇒
               (t = u) ∨
               ∃a t1 u1 t2 u2.
                 R t1 u1 ∧ R t2 u2 ∧ (t = Nd a t1 t2) ∧ (u = Nd a u1 u2)

   [<a name="lbtree_ue_Axiom-val"><b>lbtree_ue_Axiom</b></a>]  Theorem

      |- ∀f.
           ∃!g.
             ∀x.
               g x =
               case f x of NONE =&gt; Lf | SOME (b,y,z) =&gt; Nd b (g y) (g z)

   [<a name="map_eq_Lf-val"><b>map_eq_Lf</b></a>]  Theorem

      |- ((map f t = Lf) ⇔ (t = Lf)) ∧ ((Lf = map f t) ⇔ (t = Lf))

   [<a name="map_eq_Nd-val"><b>map_eq_Nd</b></a>]  Theorem

      |- (map f t = Nd a t1 t2) ⇔
         ∃a' t1' t2'.
           (t = Nd a' t1' t2') ∧ (a = f a') ∧ (t1 = map f t1') ∧
           (t2 = map f t2')

   [<a name="mem_bf_flatten-val"><b>mem_bf_flatten</b></a>]  Theorem

      |- exists ($= x) (bf_flatten tlist) ⇔ EXISTS (mem x) tlist

   [<a name="mem_cases-val"><b>mem_cases</b></a>]  Theorem

      |- ∀a0 a1.
           mem a0 a1 ⇔
           (∃t1 t2. a1 = Nd a0 t1 t2) ∨
           (∃b t1 t2. (a1 = Nd b t1 t2) ∧ mem a0 t1) ∨
           ∃b t1 t2. (a1 = Nd b t1 t2) ∧ mem a0 t2

   [<a name="mem_depth-val"><b>mem_depth</b></a>]  Theorem

      |- ∀x t. mem x t ⇒ ∃n. lbtree$depth x t n

   [<a name="mem_ind-val"><b>mem_ind</b></a>]  Theorem

      |- ∀mem'.
           (∀a t1 t2. mem' a (Nd a t1 t2)) ∧
           (∀a b t1 t2. mem' a t1 ⇒ mem' a (Nd b t1 t2)) ∧
           (∀a b t1 t2. mem' a t2 ⇒ mem' a (Nd b t1 t2)) ⇒
           ∀a0 a1. mem a0 a1 ⇒ mem' a0 a1

   [<a name="mem_mindepth-val"><b>mem_mindepth</b></a>]  Theorem

      |- ∀x t. mem x t ⇒ ∃n. lbtree$mindepth x t = SOME n

   [<a name="mem_rules-val"><b>mem_rules</b></a>]  Theorem

      |- (∀a t1 t2. mem a (Nd a t1 t2)) ∧
         (∀a b t1 t2. mem a t1 ⇒ mem a (Nd b t1 t2)) ∧
         ∀a b t1 t2. mem a t2 ⇒ mem a (Nd b t1 t2)

   [<a name="mem_strongind-val"><b>mem_strongind</b></a>]  Theorem

      |- ∀mem'.
           (∀a t1 t2. mem' a (Nd a t1 t2)) ∧
           (∀a b t1 t2. mem a t1 ∧ mem' a t1 ⇒ mem' a (Nd b t1 t2)) ∧
           (∀a b t1 t2. mem a t2 ∧ mem' a t2 ⇒ mem' a (Nd b t1 t2)) ⇒
           ∀a0 a1. mem a0 a1 ⇒ mem' a0 a1

   [<a name="mem_thm-val"><b>mem_thm</b></a>]  Theorem

      |- (mem a Lf ⇔ F) ∧
         (mem a (Nd b t1 t2) ⇔ (a = b) ∨ mem a t1 ∨ mem a t2)

   [<a name="mindepth_depth-val"><b>mindepth_depth</b></a>]  Theorem

      |- (lbtree$mindepth x t = SOME n) ⇒ lbtree$depth x t n

   [<a name="mindepth_thm-val"><b>mindepth_thm</b></a>]  Theorem

      |- (lbtree$mindepth x Lf = NONE) ∧
         (lbtree$mindepth x (Nd a t1 t2) =
          if x = a then SOME 0
          else
            OPTION_MAP SUC
              (lbtree$optmin (lbtree$mindepth x t1)
                 (lbtree$mindepth x t2)))

   [<a name="mmindex_EXISTS-val"><b>mmindex_EXISTS</b></a>]  Theorem

      |- EXISTS (λe. ∃n. f e = SOME n) l ⇒ ∃i m. lbtree$is_mmindex f l i m

   [<a name="mmindex_unique-val"><b>mmindex_unique</b></a>]  Theorem

      |- lbtree$is_mmindex f l i m ⇒
         ∀j n. lbtree$is_mmindex f l j n ⇔ (j = i) ∧ (n = m)

   [<a name="optmin_def-val"><b>optmin_def</b></a>]  Theorem

      |- (lbtree$optmin NONE NONE = NONE) ∧
         (lbtree$optmin (SOME x) NONE = SOME x) ∧
         (lbtree$optmin NONE (SOME y) = SOME y) ∧
         (lbtree$optmin (SOME x) (SOME y) = SOME (MIN x y))

   [<a name="optmin_ind-val"><b>optmin_ind</b></a>]  Theorem

      |- ∀P.
           P NONE NONE ∧ (∀x. P (SOME x) NONE) ∧ (∀y. P NONE (SOME y)) ∧
           (∀x y. P (SOME x) (SOME y)) ⇒
           ∀v v1. P v v1


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/llist/lbtreeScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-10</a></em></p></body></html>
