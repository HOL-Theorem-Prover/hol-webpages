<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure binary_ieeeTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure binary_ieeeTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/floating-point/binary_ieeeScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature binary_ieeeTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#ULP_primitive_def-val">ULP_primitive_def</a> : thm
<a name="line7"></a>    val <a href="#closest_def-val">closest_def</a> : thm
<a name="line8"></a>    val <a href="#closest_such_def-val">closest_such_def</a> : thm
<a name="line9"></a>    val <a href="#exponent_boundary_def-val">exponent_boundary_def</a> : thm
<a name="line10"></a>    val <a href="#float_Exponent-val">float_Exponent</a> : thm
<a name="line11"></a>    val <a href="#float_Exponent_fupd-val">float_Exponent_fupd</a> : thm
<a name="line12"></a>    val <a href="#float_Sign-val">float_Sign</a> : thm
<a name="line13"></a>    val <a href="#float_Sign_fupd-val">float_Sign_fupd</a> : thm
<a name="line14"></a>    val <a href="#float_Significand-val">float_Significand</a> : thm
<a name="line15"></a>    val <a href="#float_Significand_fupd-val">float_Significand_fupd</a> : thm
<a name="line16"></a>    val <a href="#float_TY_DEF-val">float_TY_DEF</a> : thm
<a name="line17"></a>    val <a href="#float_abs_def-val">float_abs_def</a> : thm
<a name="line18"></a>    val <a href="#float_add_def-val">float_add_def</a> : thm
<a name="line19"></a>    val <a href="#float_bottom_def-val">float_bottom_def</a> : thm
<a name="line20"></a>    val <a href="#float_case_def-val">float_case_def</a> : thm
<a name="line21"></a>    val <a href="#float_compare_BIJ-val">float_compare_BIJ</a> : thm
<a name="line22"></a>    val <a href="#float_compare_CASE-val">float_compare_CASE</a> : thm
<a name="line23"></a>    val <a href="#float_compare_TY_DEF-val">float_compare_TY_DEF</a> : thm
<a name="line24"></a>    val <a href="#float_compare_def-val">float_compare_def</a> : thm
<a name="line25"></a>    val <a href="#float_compare_size_def-val">float_compare_size_def</a> : thm
<a name="line26"></a>    val <a href="#float_div_def-val">float_div_def</a> : thm
<a name="line27"></a>    val <a href="#float_equal_def-val">float_equal_def</a> : thm
<a name="line28"></a>    val <a href="#float_greater_equal_def-val">float_greater_equal_def</a> : thm
<a name="line29"></a>    val <a href="#float_greater_than_def-val">float_greater_than_def</a> : thm
<a name="line30"></a>    val <a href="#float_is_finite_def-val">float_is_finite_def</a> : thm
<a name="line31"></a>    val <a href="#float_is_infinite_def-val">float_is_infinite_def</a> : thm
<a name="line32"></a>    val <a href="#float_is_integral_def-val">float_is_integral_def</a> : thm
<a name="line33"></a>    val <a href="#float_is_nan_def-val">float_is_nan_def</a> : thm
<a name="line34"></a>    val <a href="#float_is_normal_def-val">float_is_normal_def</a> : thm
<a name="line35"></a>    val <a href="#float_is_subnormal_def-val">float_is_subnormal_def</a> : thm
<a name="line36"></a>    val <a href="#float_is_zero_def-val">float_is_zero_def</a> : thm
<a name="line37"></a>    val <a href="#float_less_equal_def-val">float_less_equal_def</a> : thm
<a name="line38"></a>    val <a href="#float_less_than_def-val">float_less_than_def</a> : thm
<a name="line39"></a>    val <a href="#float_minus_infinity_def-val">float_minus_infinity_def</a> : thm
<a name="line40"></a>    val <a href="#float_minus_min_def-val">float_minus_min_def</a> : thm
<a name="line41"></a>    val <a href="#float_minus_zero_def-val">float_minus_zero_def</a> : thm
<a name="line42"></a>    val <a href="#float_mul_add_def-val">float_mul_add_def</a> : thm
<a name="line43"></a>    val <a href="#float_mul_def-val">float_mul_def</a> : thm
<a name="line44"></a>    val <a href="#float_negate_def-val">float_negate_def</a> : thm
<a name="line45"></a>    val <a href="#float_plus_infinity_def-val">float_plus_infinity_def</a> : thm
<a name="line46"></a>    val <a href="#float_plus_min_def-val">float_plus_min_def</a> : thm
<a name="line47"></a>    val <a href="#float_plus_zero_def-val">float_plus_zero_def</a> : thm
<a name="line48"></a>    val <a href="#float_round_def-val">float_round_def</a> : thm
<a name="line49"></a>    val <a href="#float_round_to_integral_def-val">float_round_to_integral_def</a> : thm
<a name="line50"></a>    val <a href="#float_size_def-val">float_size_def</a> : thm
<a name="line51"></a>    val <a href="#float_some_nan_def-val">float_some_nan_def</a> : thm
<a name="line52"></a>    val <a href="#float_sqrt_def-val">float_sqrt_def</a> : thm
<a name="line53"></a>    val <a href="#float_sub_def-val">float_sub_def</a> : thm
<a name="line54"></a>    val <a href="#float_to_real_def-val">float_to_real_def</a> : thm
<a name="line55"></a>    val <a href="#float_top_def-val">float_top_def</a> : thm
<a name="line56"></a>    val <a href="#float_value_TY_DEF-val">float_value_TY_DEF</a> : thm
<a name="line57"></a>    val <a href="#float_value_case_def-val">float_value_case_def</a> : thm
<a name="line58"></a>    val <a href="#float_value_def-val">float_value_def</a> : thm
<a name="line59"></a>    val <a href="#float_value_size_def-val">float_value_size_def</a> : thm
<a name="line60"></a>    val <a href="#integral_round_def-val">integral_round_def</a> : thm
<a name="line61"></a>    val <a href="#is_closest_def-val">is_closest_def</a> : thm
<a name="line62"></a>    val <a href="#largest_def-val">largest_def</a> : thm
<a name="line63"></a>    val <a href="#round_def-val">round_def</a> : thm
<a name="line64"></a>    val <a href="#rounding_BIJ-val">rounding_BIJ</a> : thm
<a name="line65"></a>    val <a href="#rounding_CASE-val">rounding_CASE</a> : thm
<a name="line66"></a>    val <a href="#rounding_TY_DEF-val">rounding_TY_DEF</a> : thm
<a name="line67"></a>    val <a href="#rounding_size_def-val">rounding_size_def</a> : thm
<a name="line68"></a>    val <a href="#threshold_def-val">threshold_def</a> : thm
<a name="line69"></a>    val <a href="#ulp_def-val">ulp_def</a> : thm
<a name="line70"></a>
<a name="line71"></a>  (*  Theorems  *)
<a name="line72"></a>    val <a href="#EXISTS_float-val">EXISTS_float</a> : thm
<a name="line73"></a>    val <a href="#FORALL_float-val">FORALL_float</a> : thm
<a name="line74"></a>    val <a href="#ULP_def-val">ULP_def</a> : thm
<a name="line75"></a>    val <a href="#ULP_ind-val">ULP_ind</a> : thm
<a name="line76"></a>    val <a href="#ULP_le_mono-val">ULP_le_mono</a> : thm
<a name="line77"></a>    val <a href="#abs_float_value-val">abs_float_value</a> : thm
<a name="line78"></a>    val <a href="#bottom_properties-val">bottom_properties</a> : thm
<a name="line79"></a>    val <a href="#datatype_float-val">datatype_float</a> : thm
<a name="line80"></a>    val <a href="#datatype_float_compare-val">datatype_float_compare</a> : thm
<a name="line81"></a>    val <a href="#datatype_float_value-val">datatype_float_value</a> : thm
<a name="line82"></a>    val <a href="#datatype_rounding-val">datatype_rounding</a> : thm
<a name="line83"></a>    val <a href="#diff_float_ULP-val">diff_float_ULP</a> : thm
<a name="line84"></a>    val <a href="#diff_lt_ulp_eq0-val">diff_lt_ulp_eq0</a> : thm
<a name="line85"></a>    val <a href="#diff_lt_ulp_even-val">diff_lt_ulp_even</a> : thm
<a name="line86"></a>    val <a href="#diff_lt_ulp_even4-val">diff_lt_ulp_even4</a> : thm
<a name="line87"></a>    val <a href="#div_eq0-val">div_eq0</a> : thm
<a name="line88"></a>    val <a href="#exp_ge2-val">exp_ge2</a> : thm
<a name="line89"></a>    val <a href="#exp_gt2-val">exp_gt2</a> : thm
<a name="line90"></a>    val <a href="#float_11-val">float_11</a> : thm
<a name="line91"></a>    val <a href="#float_Axiom-val">float_Axiom</a> : thm
<a name="line92"></a>    val <a href="#float_accessors-val">float_accessors</a> : thm
<a name="line93"></a>    val <a href="#float_accfupds-val">float_accfupds</a> : thm
<a name="line94"></a>    val <a href="#float_add_compute-val">float_add_compute</a> : thm
<a name="line95"></a>    val <a href="#float_add_finite-val">float_add_finite</a> : thm
<a name="line96"></a>    val <a href="#float_add_finite_minus_infinity-val">float_add_finite_minus_infinity</a> : thm
<a name="line97"></a>    val <a href="#float_add_finite_plus_infinity-val">float_add_finite_plus_infinity</a> : thm
<a name="line98"></a>    val <a href="#float_add_minus_infinity_finite-val">float_add_minus_infinity_finite</a> : thm
<a name="line99"></a>    val <a href="#float_add_nan-val">float_add_nan</a> : thm
<a name="line100"></a>    val <a href="#float_add_plus_infinity_finite-val">float_add_plus_infinity_finite</a> : thm
<a name="line101"></a>    val <a href="#float_case_cong-val">float_case_cong</a> : thm
<a name="line102"></a>    val <a href="#float_compare2num_11-val">float_compare2num_11</a> : thm
<a name="line103"></a>    val <a href="#float_compare2num_ONTO-val">float_compare2num_ONTO</a> : thm
<a name="line104"></a>    val <a href="#float_compare2num_num2float_compare-val">float_compare2num_num2float_compare</a> : thm
<a name="line105"></a>    val <a href="#float_compare2num_thm-val">float_compare2num_thm</a> : thm
<a name="line106"></a>    val <a href="#float_compare_Axiom-val">float_compare_Axiom</a> : thm
<a name="line107"></a>    val <a href="#float_compare_EQ_float_compare-val">float_compare_EQ_float_compare</a> : thm
<a name="line108"></a>    val <a href="#float_compare_case_cong-val">float_compare_case_cong</a> : thm
<a name="line109"></a>    val <a href="#float_compare_case_def-val">float_compare_case_def</a> : thm
<a name="line110"></a>    val <a href="#float_compare_distinct-val">float_compare_distinct</a> : thm
<a name="line111"></a>    val <a href="#float_compare_induction-val">float_compare_induction</a> : thm
<a name="line112"></a>    val <a href="#float_compare_nchotomy-val">float_compare_nchotomy</a> : thm
<a name="line113"></a>    val <a href="#float_component_equality-val">float_component_equality</a> : thm
<a name="line114"></a>    val <a href="#float_components-val">float_components</a> : thm
<a name="line115"></a>    val <a href="#float_distinct-val">float_distinct</a> : thm
<a name="line116"></a>    val <a href="#float_div_compute-val">float_div_compute</a> : thm
<a name="line117"></a>    val <a href="#float_div_finite-val">float_div_finite</a> : thm
<a name="line118"></a>    val <a href="#float_div_finite_minus_infinity-val">float_div_finite_minus_infinity</a> : thm
<a name="line119"></a>    val <a href="#float_div_finite_plus_infinity-val">float_div_finite_plus_infinity</a> : thm
<a name="line120"></a>    val <a href="#float_div_minus_infinity_finite-val">float_div_minus_infinity_finite</a> : thm
<a name="line121"></a>    val <a href="#float_div_nan-val">float_div_nan</a> : thm
<a name="line122"></a>    val <a href="#float_div_plus_infinity_finite-val">float_div_plus_infinity_finite</a> : thm
<a name="line123"></a>    val <a href="#float_fn_updates-val">float_fn_updates</a> : thm
<a name="line124"></a>    val <a href="#float_fupdcanon-val">float_fupdcanon</a> : thm
<a name="line125"></a>    val <a href="#float_fupdcanon_comp-val">float_fupdcanon_comp</a> : thm
<a name="line126"></a>    val <a href="#float_fupdfupds-val">float_fupdfupds</a> : thm
<a name="line127"></a>    val <a href="#float_fupdfupds_comp-val">float_fupdfupds_comp</a> : thm
<a name="line128"></a>    val <a href="#float_induction-val">float_induction</a> : thm
<a name="line129"></a>    val <a href="#float_infinity_negate_abs-val">float_infinity_negate_abs</a> : thm
<a name="line130"></a>    val <a href="#float_is_zero-val">float_is_zero</a> : thm
<a name="line131"></a>    val <a href="#float_is_zero_to_real-val">float_is_zero_to_real</a> : thm
<a name="line132"></a>    val <a href="#float_literal_11-val">float_literal_11</a> : thm
<a name="line133"></a>    val <a href="#float_literal_nchotomy-val">float_literal_nchotomy</a> : thm
<a name="line134"></a>    val <a href="#float_minus_infinity-val">float_minus_infinity</a> : thm
<a name="line135"></a>    val <a href="#float_minus_zero-val">float_minus_zero</a> : thm
<a name="line136"></a>    val <a href="#float_mul_compute-val">float_mul_compute</a> : thm
<a name="line137"></a>    val <a href="#float_mul_finite-val">float_mul_finite</a> : thm
<a name="line138"></a>    val <a href="#float_mul_finite_minus_infinity-val">float_mul_finite_minus_infinity</a> : thm
<a name="line139"></a>    val <a href="#float_mul_finite_plus_infinity-val">float_mul_finite_plus_infinity</a> : thm
<a name="line140"></a>    val <a href="#float_mul_minus_infinity_finite-val">float_mul_minus_infinity_finite</a> : thm
<a name="line141"></a>    val <a href="#float_mul_nan-val">float_mul_nan</a> : thm
<a name="line142"></a>    val <a href="#float_mul_plus_infinity_finite-val">float_mul_plus_infinity_finite</a> : thm
<a name="line143"></a>    val <a href="#float_nchotomy-val">float_nchotomy</a> : thm
<a name="line144"></a>    val <a href="#float_negate_negate-val">float_negate_negate</a> : thm
<a name="line145"></a>    val <a href="#float_round_bottom-val">float_round_bottom</a> : thm
<a name="line146"></a>    val <a href="#float_round_minus_infinity-val">float_round_minus_infinity</a> : thm
<a name="line147"></a>    val <a href="#float_round_non_zero-val">float_round_non_zero</a> : thm
<a name="line148"></a>    val <a href="#float_round_plus_infinity-val">float_round_plus_infinity</a> : thm
<a name="line149"></a>    val <a href="#float_round_roundTowardNegative_minus_infinity-val">float_round_roundTowardNegative_minus_infinity</a> : thm
<a name="line150"></a>    val <a href="#float_round_roundTowardNegative_top-val">float_round_roundTowardNegative_top</a> : thm
<a name="line151"></a>    val <a href="#float_round_roundTowardPositive_bottom-val">float_round_roundTowardPositive_bottom</a> : thm
<a name="line152"></a>    val <a href="#float_round_roundTowardPositive_plus_infinity-val">float_round_roundTowardPositive_plus_infinity</a> : thm
<a name="line153"></a>    val <a href="#float_round_roundTowardZero_bottom-val">float_round_roundTowardZero_bottom</a> : thm
<a name="line154"></a>    val <a href="#float_round_roundTowardZero_top-val">float_round_roundTowardZero_top</a> : thm
<a name="line155"></a>    val <a href="#float_round_top-val">float_round_top</a> : thm
<a name="line156"></a>    val <a href="#float_sets-val">float_sets</a> : thm
<a name="line157"></a>    val <a href="#float_sub_compute-val">float_sub_compute</a> : thm
<a name="line158"></a>    val <a href="#float_sub_finite-val">float_sub_finite</a> : thm
<a name="line159"></a>    val <a href="#float_sub_finite_minus_infinity-val">float_sub_finite_minus_infinity</a> : thm
<a name="line160"></a>    val <a href="#float_sub_finite_plus_infinity-val">float_sub_finite_plus_infinity</a> : thm
<a name="line161"></a>    val <a href="#float_sub_minus_infinity_finite-val">float_sub_minus_infinity_finite</a> : thm
<a name="line162"></a>    val <a href="#float_sub_nan-val">float_sub_nan</a> : thm
<a name="line163"></a>    val <a href="#float_sub_plus_infinity_finite-val">float_sub_plus_infinity_finite</a> : thm
<a name="line164"></a>    val <a href="#float_tests-val">float_tests</a> : thm
<a name="line165"></a>    val <a href="#float_to_real-val">float_to_real</a> : thm
<a name="line166"></a>    val <a href="#float_to_real_eq-val">float_to_real_eq</a> : thm
<a name="line167"></a>    val <a href="#float_to_real_negate-val">float_to_real_negate</a> : thm
<a name="line168"></a>    val <a href="#float_updates_eq_literal-val">float_updates_eq_literal</a> : thm
<a name="line169"></a>    val <a href="#float_value_11-val">float_value_11</a> : thm
<a name="line170"></a>    val <a href="#float_value_Axiom-val">float_value_Axiom</a> : thm
<a name="line171"></a>    val <a href="#float_value_case_cong-val">float_value_case_cong</a> : thm
<a name="line172"></a>    val <a href="#float_value_distinct-val">float_value_distinct</a> : thm
<a name="line173"></a>    val <a href="#float_value_induction-val">float_value_induction</a> : thm
<a name="line174"></a>    val <a href="#float_value_nchotomy-val">float_value_nchotomy</a> : thm
<a name="line175"></a>    val <a href="#float_values-val">float_values</a> : thm
<a name="line176"></a>    val <a href="#infinity_properties-val">infinity_properties</a> : thm
<a name="line177"></a>    val <a href="#largest-val">largest</a> : thm
<a name="line178"></a>    val <a href="#largest_is_positive-val">largest_is_positive</a> : thm
<a name="line179"></a>    val <a href="#le2-val">le2</a> : thm
<a name="line180"></a>    val <a href="#less_than_ulp-val">less_than_ulp</a> : thm
<a name="line181"></a>    val <a href="#min_properties-val">min_properties</a> : thm
<a name="line182"></a>    val <a href="#neg_ulp-val">neg_ulp</a> : thm
<a name="line183"></a>    val <a href="#num2float_compare_11-val">num2float_compare_11</a> : thm
<a name="line184"></a>    val <a href="#num2float_compare_ONTO-val">num2float_compare_ONTO</a> : thm
<a name="line185"></a>    val <a href="#num2float_compare_float_compare2num-val">num2float_compare_float_compare2num</a> : thm
<a name="line186"></a>    val <a href="#num2float_compare_thm-val">num2float_compare_thm</a> : thm
<a name="line187"></a>    val <a href="#num2rounding_11-val">num2rounding_11</a> : thm
<a name="line188"></a>    val <a href="#num2rounding_ONTO-val">num2rounding_ONTO</a> : thm
<a name="line189"></a>    val <a href="#num2rounding_rounding2num-val">num2rounding_rounding2num</a> : thm
<a name="line190"></a>    val <a href="#num2rounding_thm-val">num2rounding_thm</a> : thm
<a name="line191"></a>    val <a href="#round_roundTiesToEven-val">round_roundTiesToEven</a> : thm
<a name="line192"></a>    val <a href="#round_roundTiesToEven0-val">round_roundTiesToEven0</a> : thm
<a name="line193"></a>    val <a href="#round_roundTiesToEven_is_minus_zero-val">round_roundTiesToEven_is_minus_zero</a> : thm
<a name="line194"></a>    val <a href="#round_roundTiesToEven_is_plus_zero-val">round_roundTiesToEven_is_plus_zero</a> : thm
<a name="line195"></a>    val <a href="#round_roundTiesToEven_is_zero-val">round_roundTiesToEven_is_zero</a> : thm
<a name="line196"></a>    val <a href="#round_roundTiesToEven_minus_infinity-val">round_roundTiesToEven_minus_infinity</a> : thm
<a name="line197"></a>    val <a href="#round_roundTiesToEven_plus_infinity-val">round_roundTiesToEven_plus_infinity</a> : thm
<a name="line198"></a>    val <a href="#round_roundTowardNegative_minus_infinity-val">round_roundTowardNegative_minus_infinity</a> : thm
<a name="line199"></a>    val <a href="#round_roundTowardNegative_top-val">round_roundTowardNegative_top</a> : thm
<a name="line200"></a>    val <a href="#round_roundTowardPositive_bottom-val">round_roundTowardPositive_bottom</a> : thm
<a name="line201"></a>    val <a href="#round_roundTowardPositive_plus_infinity-val">round_roundTowardPositive_plus_infinity</a> : thm
<a name="line202"></a>    val <a href="#round_roundTowardZero-val">round_roundTowardZero</a> : thm
<a name="line203"></a>    val <a href="#round_roundTowardZero_bottom-val">round_roundTowardZero_bottom</a> : thm
<a name="line204"></a>    val <a href="#round_roundTowardZero_is_minus_zero-val">round_roundTowardZero_is_minus_zero</a> : thm
<a name="line205"></a>    val <a href="#round_roundTowardZero_is_plus_zero-val">round_roundTowardZero_is_plus_zero</a> : thm
<a name="line206"></a>    val <a href="#round_roundTowardZero_is_zero-val">round_roundTowardZero_is_zero</a> : thm
<a name="line207"></a>    val <a href="#round_roundTowardZero_top-val">round_roundTowardZero_top</a> : thm
<a name="line208"></a>    val <a href="#rounding2num_11-val">rounding2num_11</a> : thm
<a name="line209"></a>    val <a href="#rounding2num_ONTO-val">rounding2num_ONTO</a> : thm
<a name="line210"></a>    val <a href="#rounding2num_num2rounding-val">rounding2num_num2rounding</a> : thm
<a name="line211"></a>    val <a href="#rounding2num_thm-val">rounding2num_thm</a> : thm
<a name="line212"></a>    val <a href="#rounding_Axiom-val">rounding_Axiom</a> : thm
<a name="line213"></a>    val <a href="#rounding_EQ_rounding-val">rounding_EQ_rounding</a> : thm
<a name="line214"></a>    val <a href="#rounding_case_cong-val">rounding_case_cong</a> : thm
<a name="line215"></a>    val <a href="#rounding_case_def-val">rounding_case_def</a> : thm
<a name="line216"></a>    val <a href="#rounding_distinct-val">rounding_distinct</a> : thm
<a name="line217"></a>    val <a href="#rounding_induction-val">rounding_induction</a> : thm
<a name="line218"></a>    val <a href="#rounding_nchotomy-val">rounding_nchotomy</a> : thm
<a name="line219"></a>    val <a href="#sign_not_zero-val">sign_not_zero</a> : thm
<a name="line220"></a>    val <a href="#some_nan_properties-val">some_nan_properties</a> : thm
<a name="line221"></a>    val <a href="#threshold-val">threshold</a> : thm
<a name="line222"></a>    val <a href="#threshold_is_positive-val">threshold_is_positive</a> : thm
<a name="line223"></a>    val <a href="#top_properties-val">top_properties</a> : thm
<a name="line224"></a>    val <a href="#ulp-val">ulp</a> : thm
<a name="line225"></a>    val <a href="#ulp_lt_ULP-val">ulp_lt_ULP</a> : thm
<a name="line226"></a>    val <a href="#ulp_lt_largest-val">ulp_lt_largest</a> : thm
<a name="line227"></a>    val <a href="#ulp_lt_threshold-val">ulp_lt_threshold</a> : thm
<a name="line228"></a>    val <a href="#zero_le_pos_div_twopow-val">zero_le_pos_div_twopow</a> : thm
<a name="line229"></a>    val <a href="#zero_le_twopow-val">zero_le_twopow</a> : thm
<a name="line230"></a>    val <a href="#zero_lt_twopow-val">zero_lt_twopow</a> : thm
<a name="line231"></a>    val <a href="#zero_neq_twopow-val">zero_neq_twopow</a> : thm
<a name="line232"></a>    val <a href="#zero_properties-val">zero_properties</a> : thm
<a name="line233"></a>    val <a href="#zero_to_real-val">zero_to_real</a> : thm
<a name="line234"></a>
<a name="line235"></a>  val binary_ieee_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line236"></a>(*
   [transc] Parent theory of "binary_ieee"

   [words] Parent theory of "binary_ieee"

   [<a name="ULP_primitive_def-val"><b>ULP_primitive_def</b></a>]  Definition

      |- ULP =
         WFREC (@R. WF R)
           (λULP a.
              case a of
                (e,v1) =&gt;
                  I
                    (2 pow (if e = 0w then 1 else w2n e) /
                     2 pow (bias (:χ) + precision (:τ))))

   [<a name="closest_def-val"><b>closest_def</b></a>]  Definition

      |- closest = closest_such (K T)

   [<a name="closest_such_def-val"><b>closest_such_def</b></a>]  Definition

      |- ∀p s x.
           closest_such p s x =
           @a. is_closest s x a ∧ ∀b. is_closest s x b ∧ p b ⇒ p a

   [<a name="exponent_boundary_def-val"><b>exponent_boundary_def</b></a>]  Definition

      |- ∀y x.
           exponent_boundary y x ⇔
           (x.Sign = y.Sign) ∧ (w2n x.Exponent = w2n y.Exponent + 1) ∧
           x.Exponent ≠ 1w ∧ (y.Significand = -1w) ∧ (x.Significand = 0w)

   [<a name="float_Exponent-val"><b>float_Exponent</b></a>]  Definition

      |- ∀c c0 c1. (float c c0 c1).Exponent = c0

   [<a name="float_Exponent_fupd-val"><b>float_Exponent_fupd</b></a>]  Definition

      |- ∀f c c0 c1.
           float c c0 c1 with Exponent updated_by f = float c (f c0) c1

   [<a name="float_Sign-val"><b>float_Sign</b></a>]  Definition

      |- ∀c c0 c1. (float c c0 c1).Sign = c

   [<a name="float_Sign_fupd-val"><b>float_Sign_fupd</b></a>]  Definition

      |- ∀f c c0 c1.
           float c c0 c1 with Sign updated_by f = float (f c) c0 c1

   [<a name="float_Significand-val"><b>float_Significand</b></a>]  Definition

      |- ∀c c0 c1. (float c c0 c1).Significand = c1

   [<a name="float_Significand_fupd-val"><b>float_Significand_fupd</b></a>]  Definition

      |- ∀f c c0 c1.
           float c c0 c1 with Significand updated_by f = float c c0 (f c1)

   [<a name="float_TY_DEF-val"><b>float_TY_DEF</b></a>]  Definition

      |- ∃rep.
           TYPE_DEFINITION
             (λa0'.
                ∀'float' .
                  (∀a0'.
                     (∃a0 a1 a2.
                        a0' =
                        (λa0 a1 a2.
                           ind_type$CONSTR 0 (a0,a1,a2)
                             (λn. ind_type$BOTTOM)) a0 a1 a2) ⇒
                     'float' a0') ⇒
                  'float' a0') rep

   [<a name="float_abs_def-val"><b>float_abs_def</b></a>]  Definition

      |- ∀x. float_abs x = x with Sign := 0w

   [<a name="float_add_def-val"><b>float_add_def</b></a>]  Definition

      |- ∀mode x y.
           float_add mode x y =
           case (float_value x,float_value y) of
             (Float r1,Float r2) =&gt;
               float_round mode
                 (if (r1 = 0) ∧ (r2 = 0) ∧ (x.Sign = y.Sign) then
                    x.Sign = 1w
                  else (mode = roundTowardNegative)) (r1 + r2)
           | (Float r1,Infinity) =&gt; y
           | (Float r1,NaN) =&gt; float_some_nan (:τ # χ)
           | (Infinity,Float v7) =&gt; x
           | (Infinity,Infinity) =&gt;
               if x.Sign = y.Sign then x else float_some_nan (:τ # χ)
           | (Infinity,NaN) =&gt; float_some_nan (:τ # χ)
           | (NaN,v1) =&gt; float_some_nan (:τ # χ)

   [<a name="float_bottom_def-val"><b>float_bottom_def</b></a>]  Definition

      |- float_bottom (:τ # χ) = float_negate (float_top (:τ # χ))

   [<a name="float_case_def-val"><b>float_case_def</b></a>]  Definition

      |- ∀a0 a1 a2 f. float_CASE (float a0 a1 a2) f = f a0 a1 a2

   [<a name="float_compare_BIJ-val"><b>float_compare_BIJ</b></a>]  Definition

      |- (∀a. num2float_compare (float_compare2num a) = a) ∧
         ∀r. (λn. n &lt; 4) r ⇔ (float_compare2num (num2float_compare r) = r)

   [<a name="float_compare_CASE-val"><b>float_compare_CASE</b></a>]  Definition

      |- ∀x v0 v1 v2 v3.
           (case x of LT =&gt; v0 | GT =&gt; v1 | EQ =&gt; v2 | UN =&gt; v3) =
           (λm.
              if m &lt; 1 then v0
              else if m &lt; 2 then v1
              else if m = 2 then v2
              else v3) (float_compare2num x)

   [<a name="float_compare_TY_DEF-val"><b>float_compare_TY_DEF</b></a>]  Definition

      |- ∃rep. TYPE_DEFINITION (λn. n &lt; 4) rep

   [<a name="float_compare_def-val"><b>float_compare_def</b></a>]  Definition

      |- ∀x y.
           float_compare x y =
           case (float_value x,float_value y) of
             (Float r1,Float r2) =&gt;
               if r1 &lt; r2 then LT else if r1 = r2 then EQ else GT
           | (Float r1,Infinity) =&gt; if y.Sign = 1w then GT else LT
           | (Float r1,NaN) =&gt; UN
           | (Infinity,Float v7) =&gt; if x.Sign = 1w then LT else GT
           | (Infinity,Infinity) =&gt;
               if x.Sign = y.Sign then EQ
               else if x.Sign = 1w then LT
               else GT
           | (Infinity,NaN) =&gt; UN
           | (NaN,v1) =&gt; UN

   [<a name="float_compare_size_def-val"><b>float_compare_size_def</b></a>]  Definition

      |- ∀x. float_compare_size x = 0

   [<a name="float_div_def-val"><b>float_div_def</b></a>]  Definition

      |- ∀mode x y.
           float_div mode x y =
           case (float_value x,float_value y) of
             (Float 0,Float 0) =&gt; float_some_nan (:τ # χ)
           | (Float r1,Float 0) =&gt;
               if x.Sign = y.Sign then float_plus_infinity (:τ # χ)
               else float_minus_infinity (:τ # χ)
           | (Float r1,Float r2) =&gt;
               float_round mode (x.Sign ≠ y.Sign) (r1 / r2)
           | (Float r1,Infinity) =&gt;
               if x.Sign = y.Sign then float_plus_zero (:τ # χ)
               else float_minus_zero (:τ # χ)
           | (Float r1,NaN) =&gt; float_some_nan (:τ # χ)
           | (Infinity,Float v7) =&gt;
               if x.Sign = y.Sign then float_plus_infinity (:τ # χ)
               else float_minus_infinity (:τ # χ)
           | (Infinity,Infinity) =&gt; float_some_nan (:τ # χ)
           | (Infinity,NaN) =&gt; float_some_nan (:τ # χ)
           | (NaN,v1) =&gt; float_some_nan (:τ # χ)

   [<a name="float_equal_def-val"><b>float_equal_def</b></a>]  Definition

      |- ∀x y. float_equal x y ⇔ (float_compare x y = EQ)

   [<a name="float_greater_equal_def-val"><b>float_greater_equal_def</b></a>]  Definition

      |- ∀x y.
           float_greater_equal x y ⇔
           case float_compare x y of LT =&gt; F | GT =&gt; T | EQ =&gt; T | UN =&gt; F

   [<a name="float_greater_than_def-val"><b>float_greater_than_def</b></a>]  Definition

      |- ∀x y. float_greater_than x y ⇔ (float_compare x y = GT)

   [<a name="float_is_finite_def-val"><b>float_is_finite_def</b></a>]  Definition

      |- ∀x.
           float_is_finite x ⇔ case float_value x of Float v1 =&gt; T | _ =&gt; F

   [<a name="float_is_infinite_def-val"><b>float_is_infinite_def</b></a>]  Definition

      |- ∀x.
           float_is_infinite x ⇔
           case float_value x of Infinity =&gt; T | _ =&gt; F

   [<a name="float_is_integral_def-val"><b>float_is_integral_def</b></a>]  Definition

      |- ∀x.
           float_is_integral x ⇔
           case float_value x of Float r =&gt; ∃n. abs r = &n | _ =&gt; F

   [<a name="float_is_nan_def-val"><b>float_is_nan_def</b></a>]  Definition

      |- ∀x. float_is_nan x ⇔ case float_value x of NaN =&gt; T | _ =&gt; F

   [<a name="float_is_normal_def-val"><b>float_is_normal_def</b></a>]  Definition

      |- ∀x. float_is_normal x ⇔ x.Exponent ≠ 0w ∧ x.Exponent ≠ UINT_MAXw

   [<a name="float_is_subnormal_def-val"><b>float_is_subnormal_def</b></a>]  Definition

      |- ∀x. float_is_subnormal x ⇔ (x.Exponent = 0w) ∧ x.Significand ≠ 0w

   [<a name="float_is_zero_def-val"><b>float_is_zero_def</b></a>]  Definition

      |- ∀x.
           float_is_zero x ⇔
           case float_value x of Float r =&gt; r = 0 | _ =&gt; F

   [<a name="float_less_equal_def-val"><b>float_less_equal_def</b></a>]  Definition

      |- ∀x y.
           float_less_equal x y ⇔
           case float_compare x y of LT =&gt; T | GT =&gt; F | EQ =&gt; T | UN =&gt; F

   [<a name="float_less_than_def-val"><b>float_less_than_def</b></a>]  Definition

      |- ∀x y. float_less_than x y ⇔ (float_compare x y = LT)

   [<a name="float_minus_infinity_def-val"><b>float_minus_infinity_def</b></a>]  Definition

      |- float_minus_infinity (:τ # χ) =
         float_negate (float_plus_infinity (:τ # χ))

   [<a name="float_minus_min_def-val"><b>float_minus_min_def</b></a>]  Definition

      |- float_minus_min (:τ # χ) = float_negate (float_plus_min (:τ # χ))

   [<a name="float_minus_zero_def-val"><b>float_minus_zero_def</b></a>]  Definition

      |- float_minus_zero (:τ # χ) =
         float_negate (float_plus_zero (:τ # χ))

   [<a name="float_mul_add_def-val"><b>float_mul_add_def</b></a>]  Definition

      |- ∀mode x y z.
           float_mul_add mode x y z =
           (let signP = x.Sign ⊕ y.Sign in
            let infP = float_is_infinite x ∨ float_is_infinite y
            in
              if
                float_is_nan x ∨ float_is_nan y ∨ float_is_nan z ∨
                float_is_infinite x ∧ float_is_zero y ∨
                float_is_zero x ∧ float_is_infinite y ∨
                float_is_infinite z ∧ infP ∧ z.Sign ≠ signP
              then
                float_some_nan (:τ # χ)
              else if
                float_is_infinite z ∧ (z.Sign = 0w) ∨ infP ∧ (signP = 0w)
              then
                float_plus_infinity (:τ # χ)
              else if
                float_is_infinite z ∧ (z.Sign = 1w) ∨ infP ∧ (signP = 1w)
              then
                float_minus_infinity (:τ # χ)
              else if
                float_is_zero z ∧ (float_is_zero x ∨ float_is_zero y) ∧
                (x.Sign = signP)
              then
                if x.Sign = 1w then float_minus_zero (:τ # χ)
                else float_plus_zero (:τ # χ)
              else
                float_round mode (mode = roundTowardNegative)
                  (float_to_real z + float_to_real x * float_to_real y))

   [<a name="float_mul_def-val"><b>float_mul_def</b></a>]  Definition

      |- ∀mode x y.
           float_mul mode x y =
           case (float_value x,float_value y) of
             (Float r',Float r2) =&gt;
               float_round mode (x.Sign ≠ y.Sign) (r' * r2)
           | (Float 0,Infinity) =&gt; float_some_nan (:τ # χ)
           | (Float r',Infinity) =&gt;
               if x.Sign = y.Sign then float_plus_infinity (:τ # χ)
               else float_minus_infinity (:τ # χ)
           | (Float r',NaN) =&gt; float_some_nan (:τ # χ)
           | (Infinity,Float 0) =&gt; float_some_nan (:τ # χ)
           | (Infinity,Float r) =&gt;
               if x.Sign = y.Sign then float_plus_infinity (:τ # χ)
               else float_minus_infinity (:τ # χ)
           | (Infinity,Infinity) =&gt;
               if x.Sign = y.Sign then float_plus_infinity (:τ # χ)
               else float_minus_infinity (:τ # χ)
           | (Infinity,NaN) =&gt; float_some_nan (:τ # χ)
           | (NaN,v1) =&gt; float_some_nan (:τ # χ)

   [<a name="float_negate_def-val"><b>float_negate_def</b></a>]  Definition

      |- ∀x. float_negate x = x with Sign := ¬x.Sign

   [<a name="float_plus_infinity_def-val"><b>float_plus_infinity_def</b></a>]  Definition

      |- float_plus_infinity (:τ # χ) =
         &lt;|Sign := 0w; Exponent := UINT_MAXw; Significand := 0w|&gt;

   [<a name="float_plus_min_def-val"><b>float_plus_min_def</b></a>]  Definition

      |- float_plus_min (:τ # χ) =
         &lt;|Sign := 0w; Exponent := 0w; Significand := 1w|&gt;

   [<a name="float_plus_zero_def-val"><b>float_plus_zero_def</b></a>]  Definition

      |- float_plus_zero (:τ # χ) =
         &lt;|Sign := 0w; Exponent := 0w; Significand := 0w|&gt;

   [<a name="float_round_def-val"><b>float_round_def</b></a>]  Definition

      |- ∀mode toneg r.
           float_round mode toneg r =
           (let x = round mode r
            in
              if float_is_zero x then
                if toneg then float_minus_zero (:τ # χ)
                else float_plus_zero (:τ # χ)
              else x)

   [<a name="float_round_to_integral_def-val"><b>float_round_to_integral_def</b></a>]  Definition

      |- ∀mode x.
           float_round_to_integral mode x =
           case float_value x of Float r =&gt; integral_round mode r | _ =&gt; x

   [<a name="float_size_def-val"><b>float_size_def</b></a>]  Definition

      |- ∀f f1 a0 a1 a2. float_size f f1 (float a0 a1 a2) = 1

   [<a name="float_some_nan_def-val"><b>float_some_nan_def</b></a>]  Definition

      |- float_some_nan (:τ # χ) = @a. float_is_nan a

   [<a name="float_sqrt_def-val"><b>float_sqrt_def</b></a>]  Definition

      |- ∀mode x.
           float_sqrt mode x =
           if x.Sign = 0w then
             case float_value x of
               Float r =&gt; float_round mode (x.Sign = 1w) (sqrt r)
             | Infinity =&gt; float_plus_infinity (:τ # χ)
             | NaN =&gt; float_some_nan (:τ # χ)
           else float_some_nan (:τ # χ)

   [<a name="float_sub_def-val"><b>float_sub_def</b></a>]  Definition

      |- ∀mode x y.
           float_sub mode x y =
           case (float_value x,float_value y) of
             (Float r1,Float r2) =&gt;
               float_round mode
                 (if (r1 = 0) ∧ (r2 = 0) ∧ x.Sign ≠ y.Sign then x.Sign = 1w
                  else (mode = roundTowardNegative)) (r1 − r2)
           | (Float r1,Infinity) =&gt; float_negate y
           | (Float r1,NaN) =&gt; float_some_nan (:τ # χ)
           | (Infinity,Float v7) =&gt; x
           | (Infinity,Infinity) =&gt;
               if x.Sign = y.Sign then float_some_nan (:τ # χ) else x
           | (Infinity,NaN) =&gt; float_some_nan (:τ # χ)
           | (NaN,v1) =&gt; float_some_nan (:τ # χ)

   [<a name="float_to_real_def-val"><b>float_to_real_def</b></a>]  Definition

      |- ∀x.
           float_to_real x =
           if x.Exponent = 0w then
             -1 pow w2n x.Sign * (2 / 2 pow bias (:χ)) *
             (&w2n x.Significand / 2 pow precision (:τ))
           else
             -1 pow w2n x.Sign * (2 pow w2n x.Exponent / 2 pow bias (:χ)) *
             (1 + &w2n x.Significand / 2 pow precision (:τ))

   [<a name="float_top_def-val"><b>float_top_def</b></a>]  Definition

      |- float_top (:τ # χ) =
         &lt;|Sign := 0w; Exponent := UINT_MAXw − 1w;
           Significand := UINT_MAXw|&gt;

   [<a name="float_value_TY_DEF-val"><b>float_value_TY_DEF</b></a>]  Definition

      |- ∃rep.
           TYPE_DEFINITION
             (λa0.
                ∀'float_value' .
                  (∀a0.
                     (∃a.
                        a0 =
                        (λa. ind_type$CONSTR 0 a (λn. ind_type$BOTTOM))
                          a) ∨
                     (a0 =
                      ind_type$CONSTR (SUC 0) ARB (λn. ind_type$BOTTOM)) ∨
                     (a0 =
                      ind_type$CONSTR (SUC (SUC 0)) ARB
                        (λn. ind_type$BOTTOM)) ⇒
                     'float_value' a0) ⇒
                  'float_value' a0) rep

   [<a name="float_value_case_def-val"><b>float_value_case_def</b></a>]  Definition

      |- (∀a f v v1. float_value_CASE (Float a) f v v1 = f a) ∧
         (∀f v v1. float_value_CASE Infinity f v v1 = v) ∧
         ∀f v v1. float_value_CASE NaN f v v1 = v1

   [<a name="float_value_def-val"><b>float_value_def</b></a>]  Definition

      |- ∀x.
           float_value x =
           if x.Exponent = UINT_MAXw then
             if x.Significand = 0w then Infinity else NaN
           else Float (float_to_real x)

   [<a name="float_value_size_def-val"><b>float_value_size_def</b></a>]  Definition

      |- (∀a. float_value_size (Float a) = 1) ∧
         (float_value_size Infinity = 0) ∧ (float_value_size NaN = 0)

   [<a name="integral_round_def-val"><b>integral_round_def</b></a>]  Definition

      |- ∀mode x.
           integral_round mode x =
           case mode of
             roundTiesToEven =&gt;
               (let t = threshold (:τ # χ)
                in
                  if x ≤ -t then float_minus_infinity (:τ # χ)
                  else if x ≥ t then float_plus_infinity (:τ # χ)
                  else
                    closest_such
                      (λa. ∃n. EVEN n ∧ (abs (float_to_real a) = &n))
                      float_is_integral x)
           | roundTowardPositive =&gt;
               (let t = largest (:τ # χ)
                in
                  if x &lt; -t then float_bottom (:τ # χ)
                  else if x &gt; t then float_plus_infinity (:τ # χ)
                  else
                    closest {a | float_is_integral a ∧ float_to_real a ≥ x}
                      x)
           | roundTowardNegative =&gt;
               (let t = largest (:τ # χ)
                in
                  if x &lt; -t then float_minus_infinity (:τ # χ)
                  else if x &gt; t then float_top (:τ # χ)
                  else
                    closest {a | float_is_integral a ∧ float_to_real a ≤ x}
                      x)
           | roundTowardZero =&gt;
               (let t = largest (:τ # χ)
                in
                  if x &lt; -t then float_bottom (:τ # χ)
                  else if x &gt; t then float_top (:τ # χ)
                  else
                    closest
                      {a |
                       float_is_integral a ∧ abs (float_to_real a) ≤ abs x}
                      x)

   [<a name="is_closest_def-val"><b>is_closest_def</b></a>]  Definition

      |- ∀s x a.
           is_closest s x a ⇔
           a ∈ s ∧
           ∀b.
             b ∈ s ⇒ abs (float_to_real a − x) ≤ abs (float_to_real b − x)

   [<a name="largest_def-val"><b>largest_def</b></a>]  Definition

      |- largest (:τ # χ) =
         2 pow (UINT_MAX (:χ) − 1) / 2 pow bias (:χ) *
         (2 − inv (2 pow precision (:τ)))

   [<a name="round_def-val"><b>round_def</b></a>]  Definition

      |- ∀mode x.
           round mode x =
           case mode of
             roundTiesToEven =&gt;
               (let t = threshold (:τ # χ)
                in
                  if x ≤ -t then float_minus_infinity (:τ # χ)
                  else if x ≥ t then float_plus_infinity (:τ # χ)
                  else
                    closest_such (λa. ¬word_lsb a.Significand)
                      float_is_finite x)
           | roundTowardPositive =&gt;
               (let t = largest (:τ # χ)
                in
                  if x &lt; -t then float_bottom (:τ # χ)
                  else if x &gt; t then float_plus_infinity (:τ # χ)
                  else
                    closest {a | float_is_finite a ∧ float_to_real a ≥ x}
                      x)
           | roundTowardNegative =&gt;
               (let t = largest (:τ # χ)
                in
                  if x &lt; -t then float_minus_infinity (:τ # χ)
                  else if x &gt; t then float_top (:τ # χ)
                  else
                    closest {a | float_is_finite a ∧ float_to_real a ≤ x}
                      x)
           | roundTowardZero =&gt;
               (let t = largest (:τ # χ)
                in
                  if x &lt; -t then float_bottom (:τ # χ)
                  else if x &gt; t then float_top (:τ # χ)
                  else
                    closest
                      {a |
                       float_is_finite a ∧ abs (float_to_real a) ≤ abs x}
                      x)

   [<a name="rounding_BIJ-val"><b>rounding_BIJ</b></a>]  Definition

      |- (∀a. num2rounding (rounding2num a) = a) ∧
         ∀r. (λn. n &lt; 4) r ⇔ (rounding2num (num2rounding r) = r)

   [<a name="rounding_CASE-val"><b>rounding_CASE</b></a>]  Definition

      |- ∀x v0 v1 v2 v3.
           (case x of
              roundTiesToEven =&gt; v0
            | roundTowardPositive =&gt; v1
            | roundTowardNegative =&gt; v2
            | roundTowardZero =&gt; v3) =
           (λm.
              if m &lt; 1 then v0
              else if m &lt; 2 then v1
              else if m = 2 then v2
              else v3) (rounding2num x)

   [<a name="rounding_TY_DEF-val"><b>rounding_TY_DEF</b></a>]  Definition

      |- ∃rep. TYPE_DEFINITION (λn. n &lt; 4) rep

   [<a name="rounding_size_def-val"><b>rounding_size_def</b></a>]  Definition

      |- ∀x. rounding_size x = 0

   [<a name="threshold_def-val"><b>threshold_def</b></a>]  Definition

      |- threshold (:τ # χ) =
         2 pow (UINT_MAX (:χ) − 1) / 2 pow bias (:χ) *
         (2 − inv (2 pow SUC (precision (:τ))))

   [<a name="ulp_def-val"><b>ulp_def</b></a>]  Definition

      |- ulp (:τ # χ) = ULP (0w,(:τ))

   [<a name="EXISTS_float-val"><b>EXISTS_float</b></a>]  Theorem

      |- ∀P.
           (∃f. P f) ⇔
           ∃c1 c0 c. P &lt;|Sign := c1; Exponent := c0; Significand := c|&gt;

   [<a name="FORALL_float-val"><b>FORALL_float</b></a>]  Theorem

      |- ∀P.
           (∀f. P f) ⇔
           ∀c1 c0 c. P &lt;|Sign := c1; Exponent := c0; Significand := c|&gt;

   [<a name="ULP_def-val"><b>ULP_def</b></a>]  Theorem

      |- ULP (e,(:τ)) =
         2 pow (if e = 0w then 1 else w2n e) /
         2 pow (bias (:χ) + precision (:τ))

   [<a name="ULP_ind-val"><b>ULP_ind</b></a>]  Theorem

      |- ∀P. (∀e. P (e,(:τ))) ⇒ ∀v v1. P (v,v1)

   [<a name="ULP_le_mono-val"><b>ULP_le_mono</b></a>]  Theorem

      |- ∀e1 e2. e2 ≠ 0w ⇒ (ULP (e1,(:τ)) ≤ ULP (e2,(:τ)) ⇔ e1 ≤₊ e2)

   [<a name="abs_float_value-val"><b>abs_float_value</b></a>]  Theorem

      |- (∀b c d. abs (-1 pow w2n b * c * d) = abs (c * d)) ∧
         ∀b c. abs (-1 pow w2n b * c) = abs c

   [<a name="bottom_properties-val"><b>bottom_properties</b></a>]  Theorem

      |- ¬float_is_zero (float_bottom (:τ # χ)) ∧
         float_is_finite (float_bottom (:τ # χ)) ∧
         ¬float_is_nan (float_bottom (:τ # χ)) ∧
         (float_is_normal (float_bottom (:τ # χ)) ⇔ precision (:χ) ≠ 1) ∧
         (float_is_subnormal (float_bottom (:τ # χ)) ⇔
          (precision (:χ) = 1)) ∧
         ¬float_is_infinite (float_bottom (:τ # χ))

   [<a name="datatype_float-val"><b>datatype_float</b></a>]  Theorem

      |- DATATYPE (record float Sign Exponent Significand)

   [<a name="datatype_float_compare-val"><b>datatype_float_compare</b></a>]  Theorem

      |- DATATYPE (float_compare LT GT EQ UN)

   [<a name="datatype_float_value-val"><b>datatype_float_value</b></a>]  Theorem

      |- DATATYPE (float_value Float Infinity NaN)

   [<a name="datatype_rounding-val"><b>datatype_rounding</b></a>]  Theorem

      |- DATATYPE
           (rounding roundTiesToEven roundTowardPositive
              roundTowardNegative roundTowardZero)

   [<a name="diff_float_ULP-val"><b>diff_float_ULP</b></a>]  Theorem

      |- ∀x y.
           float_to_real x ≠ float_to_real y ∧ ¬exponent_boundary y x ⇒
           ULP (x.Exponent,(:τ)) ≤ abs (float_to_real x − float_to_real y)

   [<a name="diff_lt_ulp_eq0-val"><b>diff_lt_ulp_eq0</b></a>]  Theorem

      |- ∀a b x.
           ¬exponent_boundary b a ∧
           abs (x − float_to_real a) &lt; ULP (a.Exponent,(:τ)) ∧
           abs (x − float_to_real b) &lt; ULP (a.Exponent,(:τ)) ∧
           abs (float_to_real a) ≤ abs x ∧ abs (float_to_real b) ≤ abs x ∧
           ¬float_is_zero a ⇒
           (b = a)

   [<a name="diff_lt_ulp_even-val"><b>diff_lt_ulp_even</b></a>]  Theorem

      |- ∀a b x.
           ¬exponent_boundary b a ∧
           2 * abs (float_to_real a − x) &lt; ULP (a.Exponent,(:τ)) ∧
           2 * abs (float_to_real b − x) &lt; ULP (a.Exponent,(:τ)) ∧
           ¬float_is_zero a ⇒
           (b = a)

   [<a name="diff_lt_ulp_even4-val"><b>diff_lt_ulp_even4</b></a>]  Theorem

      |- ∀a b x.
           ¬exponent_boundary b a ∧
           4 * abs (float_to_real a − x) ≤ ULP (a.Exponent,(:τ)) ∧
           4 * abs (float_to_real b − x) ≤ ULP (a.Exponent,(:τ)) ∧
           ¬float_is_zero a ⇒
           (b = a)

   [<a name="div_eq0-val"><b>div_eq0</b></a>]  Theorem

      |- ∀a b. 0 &lt; b ⇒ ((a / b = 0) ⇔ (a = 0))

   [<a name="exp_ge2-val"><b>exp_ge2</b></a>]  Theorem

      |- ∀b. 2 ≤ 2 ** b ⇔ 1 ≤ b

   [<a name="exp_gt2-val"><b>exp_gt2</b></a>]  Theorem

      |- ∀b. 2 &lt; 2 ** b ⇔ 1 &lt; b

   [<a name="float_11-val"><b>float_11</b></a>]  Theorem

      |- ∀a0 a1 a2 a0' a1' a2'.
           (float a0 a1 a2 = float a0' a1' a2') ⇔
           (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2')

   [<a name="float_Axiom-val"><b>float_Axiom</b></a>]  Theorem

      |- ∀f. ∃fn. ∀a0 a1 a2. fn (float a0 a1 a2) = f a0 a1 a2

   [<a name="float_accessors-val"><b>float_accessors</b></a>]  Theorem

      |- (∀c c0 c1. (float c c0 c1).Sign = c) ∧
         (∀c c0 c1. (float c c0 c1).Exponent = c0) ∧
         ∀c c0 c1. (float c c0 c1).Significand = c1

   [<a name="float_accfupds-val"><b>float_accfupds</b></a>]  Theorem

      |- (∀f0 f. (f with Exponent updated_by f0).Sign = f.Sign) ∧
         (∀f0 f. (f with Significand updated_by f0).Sign = f.Sign) ∧
         (∀f0 f. (f with Sign updated_by f0).Exponent = f.Exponent) ∧
         (∀f0 f.
            (f with Significand updated_by f0).Exponent = f.Exponent) ∧
         (∀f0 f. (f with Sign updated_by f0).Significand = f.Significand) ∧
         (∀f0 f.
            (f with Exponent updated_by f0).Significand = f.Significand) ∧
         (∀f0 f. (f with Sign updated_by f0).Sign = f0 f.Sign) ∧
         (∀f0 f.
            (f with Exponent updated_by f0).Exponent = f0 f.Exponent) ∧
         ∀f0 f.
           (f with Significand updated_by f0).Significand =
           f0 f.Significand

   [<a name="float_add_compute-val"><b>float_add_compute</b></a>]  Theorem

      |- (∀mode x.
            float_add mode (float_some_nan (:τ # χ)) x =
            float_some_nan (:τ # χ)) ∧
         (∀mode x.
            float_add mode x (float_some_nan (:τ # χ)) =
            float_some_nan (:τ # χ)) ∧
         (∀mode.
            float_add mode (float_minus_infinity (:τ # χ))
              (float_minus_infinity (:τ # χ)) =
            float_minus_infinity (:τ # χ)) ∧
         (∀mode.
            float_add mode (float_minus_infinity (:τ # χ))
              (float_plus_infinity (:τ # χ)) =
            float_some_nan (:τ # χ)) ∧
         (∀mode.
            float_add mode (float_plus_infinity (:τ # χ))
              (float_plus_infinity (:τ # χ)) =
            float_plus_infinity (:τ # χ)) ∧
         ∀mode.
           float_add mode (float_plus_infinity (:τ # χ))
             (float_minus_infinity (:τ # χ)) =
           float_some_nan (:τ # χ)

   [<a name="float_add_finite-val"><b>float_add_finite</b></a>]  Theorem

      |- ∀mode x y r1 r2.
           (float_value x = Float r1) ∧ (float_value y = Float r2) ⇒
           (float_add mode x y =
            float_round mode
              (if (r1 = 0) ∧ (r2 = 0) ∧ (x.Sign = y.Sign) then x.Sign = 1w
               else (mode = roundTowardNegative)) (r1 + r2))

   [<a name="float_add_finite_minus_infinity-val"><b>float_add_finite_minus_infinity</b></a>]  Theorem

      |- ∀mode x r.
           (float_value x = Float r) ⇒
           (float_add mode x (float_minus_infinity (:τ # χ)) =
            float_minus_infinity (:τ # χ))

   [<a name="float_add_finite_plus_infinity-val"><b>float_add_finite_plus_infinity</b></a>]  Theorem

      |- ∀mode x r.
           (float_value x = Float r) ⇒
           (float_add mode x (float_plus_infinity (:τ # χ)) =
            float_plus_infinity (:τ # χ))

   [<a name="float_add_minus_infinity_finite-val"><b>float_add_minus_infinity_finite</b></a>]  Theorem

      |- ∀mode x r.
           (float_value x = Float r) ⇒
           (float_add mode (float_minus_infinity (:τ # χ)) x =
            float_minus_infinity (:τ # χ))

   [<a name="float_add_nan-val"><b>float_add_nan</b></a>]  Theorem

      |- ∀mode x y.
           (float_value x = NaN) ∨ (float_value y = NaN) ⇒
           (float_add mode x y = float_some_nan (:τ # χ))

   [<a name="float_add_plus_infinity_finite-val"><b>float_add_plus_infinity_finite</b></a>]  Theorem

      |- ∀mode x r.
           (float_value x = Float r) ⇒
           (float_add mode (float_plus_infinity (:τ # χ)) x =
            float_plus_infinity (:τ # χ))

   [<a name="float_case_cong-val"><b>float_case_cong</b></a>]  Theorem

      |- ∀M M' f.
           (M = M') ∧
           (∀a0 a1 a2.
              (M' = float a0 a1 a2) ⇒ (f a0 a1 a2 = f' a0 a1 a2)) ⇒
           (float_CASE M f = float_CASE M' f')

   [<a name="float_compare2num_11-val"><b>float_compare2num_11</b></a>]  Theorem

      |- ∀a a'. (float_compare2num a = float_compare2num a') ⇔ (a = a')

   [<a name="float_compare2num_ONTO-val"><b>float_compare2num_ONTO</b></a>]  Theorem

      |- ∀r. r &lt; 4 ⇔ ∃a. r = float_compare2num a

   [<a name="float_compare2num_num2float_compare-val"><b>float_compare2num_num2float_compare</b></a>]  Theorem

      |- ∀r. r &lt; 4 ⇔ (float_compare2num (num2float_compare r) = r)

   [<a name="float_compare2num_thm-val"><b>float_compare2num_thm</b></a>]  Theorem

      |- (float_compare2num LT = 0) ∧ (float_compare2num GT = 1) ∧
         (float_compare2num EQ = 2) ∧ (float_compare2num UN = 3)

   [<a name="float_compare_Axiom-val"><b>float_compare_Axiom</b></a>]  Theorem

      |- ∀x0 x1 x2 x3.
           ∃f. (f LT = x0) ∧ (f GT = x1) ∧ (f EQ = x2) ∧ (f UN = x3)

   [<a name="float_compare_EQ_float_compare-val"><b>float_compare_EQ_float_compare</b></a>]  Theorem

      |- ∀a a'. (a = a') ⇔ (float_compare2num a = float_compare2num a')

   [<a name="float_compare_case_cong-val"><b>float_compare_case_cong</b></a>]  Theorem

      |- ∀M M' v0 v1 v2 v3.
           (M = M') ∧ ((M' = LT) ⇒ (v0 = v0')) ∧ ((M' = GT) ⇒ (v1 = v1')) ∧
           ((M' = EQ) ⇒ (v2 = v2')) ∧ ((M' = UN) ⇒ (v3 = v3')) ⇒
           ((case M of LT =&gt; v0 | GT =&gt; v1 | EQ =&gt; v2 | UN =&gt; v3) =
            case M' of LT =&gt; v0' | GT =&gt; v1' | EQ =&gt; v2' | UN =&gt; v3')

   [<a name="float_compare_case_def-val"><b>float_compare_case_def</b></a>]  Theorem

      |- (∀v0 v1 v2 v3.
            (case LT of LT =&gt; v0 | GT =&gt; v1 | EQ =&gt; v2 | UN =&gt; v3) = v0) ∧
         (∀v0 v1 v2 v3.
            (case GT of LT =&gt; v0 | GT =&gt; v1 | EQ =&gt; v2 | UN =&gt; v3) = v1) ∧
         (∀v0 v1 v2 v3.
            (case EQ of LT =&gt; v0 | GT =&gt; v1 | EQ =&gt; v2 | UN =&gt; v3) = v2) ∧
         ∀v0 v1 v2 v3.
           (case UN of LT =&gt; v0 | GT =&gt; v1 | EQ =&gt; v2 | UN =&gt; v3) = v3

   [<a name="float_compare_distinct-val"><b>float_compare_distinct</b></a>]  Theorem

      |- LT ≠ GT ∧ LT ≠ EQ ∧ LT ≠ UN ∧ GT ≠ EQ ∧ GT ≠ UN ∧ EQ ≠ UN

   [<a name="float_compare_induction-val"><b>float_compare_induction</b></a>]  Theorem

      |- ∀P. P EQ ∧ P GT ∧ P LT ∧ P UN ⇒ ∀a. P a

   [<a name="float_compare_nchotomy-val"><b>float_compare_nchotomy</b></a>]  Theorem

      |- ∀a. (a = LT) ∨ (a = GT) ∨ (a = EQ) ∨ (a = UN)

   [<a name="float_component_equality-val"><b>float_component_equality</b></a>]  Theorem

      |- ∀f1 f2.
           (f1 = f2) ⇔
           (f1.Sign = f2.Sign) ∧ (f1.Exponent = f2.Exponent) ∧
           (f1.Significand = f2.Significand)

   [<a name="float_components-val"><b>float_components</b></a>]  Theorem

      |- ((float_plus_infinity (:τ # χ)).Sign = 0w) ∧
         ((float_plus_infinity (:τ # χ)).Exponent = UINT_MAXw) ∧
         ((float_plus_infinity (:τ # χ)).Significand = 0w) ∧
         ((float_minus_infinity (:τ # χ)).Sign = 1w) ∧
         ((float_minus_infinity (:τ # χ)).Exponent = UINT_MAXw) ∧
         ((float_minus_infinity (:τ # χ)).Significand = 0w) ∧
         ((float_plus_zero (:τ # χ)).Sign = 0w) ∧
         ((float_plus_zero (:τ # χ)).Exponent = 0w) ∧
         ((float_plus_zero (:τ # χ)).Significand = 0w) ∧
         ((float_minus_zero (:τ # χ)).Sign = 1w) ∧
         ((float_minus_zero (:τ # χ)).Exponent = 0w) ∧
         ((float_minus_zero (:τ # χ)).Significand = 0w) ∧
         ((float_plus_min (:τ # χ)).Sign = 0w) ∧
         ((float_plus_min (:τ # χ)).Exponent = 0w) ∧
         ((float_plus_min (:τ # χ)).Significand = 1w) ∧
         ((float_minus_min (:τ # χ)).Sign = 1w) ∧
         ((float_minus_min (:τ # χ)).Exponent = 0w) ∧
         ((float_minus_min (:τ # χ)).Significand = 1w) ∧
         ((float_top (:τ # χ)).Sign = 0w) ∧
         ((float_top (:τ # χ)).Exponent = UINT_MAXw − 1w) ∧
         ((float_top (:τ # χ)).Significand = UINT_MAXw) ∧
         ((float_bottom (:τ # χ)).Sign = 1w) ∧
         ((float_bottom (:τ # χ)).Exponent = UINT_MAXw − 1w) ∧
         ((float_bottom (:τ # χ)).Significand = UINT_MAXw) ∧
         ((float_some_nan (:τ # χ)).Exponent = UINT_MAXw) ∧
         (float_some_nan (:τ # χ)).Significand ≠ 0w ∧
         (∀x. (float_negate x).Sign = ¬x.Sign) ∧
         (∀x. (float_negate x).Exponent = x.Exponent) ∧
         ∀x. (float_negate x).Significand = x.Significand

   [<a name="float_distinct-val"><b>float_distinct</b></a>]  Theorem

      |- float_plus_infinity (:τ # χ) ≠ float_minus_infinity (:τ # χ) ∧
         float_plus_infinity (:τ # χ) ≠ float_plus_zero (:τ # χ) ∧
         float_plus_infinity (:τ # χ) ≠ float_minus_zero (:τ # χ) ∧
         float_plus_infinity (:τ # χ) ≠ float_top (:τ # χ) ∧
         float_plus_infinity (:τ # χ) ≠ float_bottom (:τ # χ) ∧
         float_plus_infinity (:τ # χ) ≠ float_plus_min (:τ # χ) ∧
         float_plus_infinity (:τ # χ) ≠ float_minus_min (:τ # χ) ∧
         float_plus_infinity (:τ # χ) ≠ float_some_nan (:τ # χ) ∧
         float_minus_infinity (:τ # χ) ≠ float_plus_zero (:τ # χ) ∧
         float_minus_infinity (:τ # χ) ≠ float_minus_zero (:τ # χ) ∧
         float_minus_infinity (:τ # χ) ≠ float_top (:τ # χ) ∧
         float_minus_infinity (:τ # χ) ≠ float_bottom (:τ # χ) ∧
         float_minus_infinity (:τ # χ) ≠ float_plus_min (:τ # χ) ∧
         float_minus_infinity (:τ # χ) ≠ float_minus_min (:τ # χ) ∧
         float_minus_infinity (:τ # χ) ≠ float_some_nan (:τ # χ) ∧
         float_plus_zero (:τ # χ) ≠ float_minus_zero (:τ # χ) ∧
         float_plus_zero (:τ # χ) ≠ float_top (:τ # χ) ∧
         float_plus_zero (:τ # χ) ≠ float_bottom (:τ # χ) ∧
         float_plus_zero (:τ # χ) ≠ float_plus_min (:τ # χ) ∧
         float_plus_zero (:τ # χ) ≠ float_minus_min (:τ # χ) ∧
         float_plus_zero (:τ # χ) ≠ float_some_nan (:τ # χ) ∧
         float_minus_zero (:τ # χ) ≠ float_top (:τ # χ) ∧
         float_minus_zero (:τ # χ) ≠ float_bottom (:τ # χ) ∧
         float_minus_zero (:τ # χ) ≠ float_plus_min (:τ # χ) ∧
         float_minus_zero (:τ # χ) ≠ float_minus_min (:τ # χ) ∧
         float_minus_zero (:τ # χ) ≠ float_some_nan (:τ # χ) ∧
         float_top (:τ # χ) ≠ float_minus_min (:τ # χ) ∧
         float_top (:τ # χ) ≠ float_bottom (:τ # χ) ∧
         float_top (:τ # χ) ≠ float_some_nan (:τ # χ) ∧
         float_bottom (:τ # χ) ≠ float_plus_min (:τ # χ) ∧
         float_bottom (:τ # χ) ≠ float_some_nan (:τ # χ) ∧
         float_plus_min (:τ # χ) ≠ float_some_nan (:τ # χ) ∧
         float_plus_min (:τ # χ) ≠ float_minus_min (:τ # χ) ∧
         float_minus_min (:τ # χ) ≠ float_some_nan (:τ # χ) ∧
         ∀x. float_negate x ≠ x

   [<a name="float_div_compute-val"><b>float_div_compute</b></a>]  Theorem

      |- (∀mode x.
            float_div mode (float_some_nan (:τ # χ)) x =
            float_some_nan (:τ # χ)) ∧
         (∀mode x.
            float_div mode x (float_some_nan (:τ # χ)) =
            float_some_nan (:τ # χ)) ∧
         (∀mode.
            float_div mode (float_minus_infinity (:τ # χ))
              (float_minus_infinity (:τ # χ)) =
            float_some_nan (:τ # χ)) ∧
         (∀mode.
            float_div mode (float_minus_infinity (:τ # χ))
              (float_plus_infinity (:τ # χ)) =
            float_some_nan (:τ # χ)) ∧
         (∀mode.
            float_div mode (float_plus_infinity (:τ # χ))
              (float_plus_infinity (:τ # χ)) =
            float_some_nan (:τ # χ)) ∧
         ∀mode.
           float_div mode (float_plus_infinity (:τ # χ))
             (float_minus_infinity (:τ # χ)) =
           float_some_nan (:τ # χ)

   [<a name="float_div_finite-val"><b>float_div_finite</b></a>]  Theorem

      |- ∀mode x y r1 r2.
           (float_value x = Float r1) ∧ (float_value y = Float r2) ⇒
           (float_div mode x y =
            if r2 = 0 then
              if r1 = 0 then float_some_nan (:τ # χ)
              else if x.Sign = y.Sign then float_plus_infinity (:τ # χ)
              else float_minus_infinity (:τ # χ)
            else float_round mode (x.Sign ≠ y.Sign) (r1 / r2))

   [<a name="float_div_finite_minus_infinity-val"><b>float_div_finite_minus_infinity</b></a>]  Theorem

      |- ∀mode x r.
           (float_value x = Float r) ⇒
           (float_div mode x (float_minus_infinity (:τ # χ)) =
            if x.Sign = 0w then float_minus_zero (:τ # χ)
            else float_plus_zero (:τ # χ))

   [<a name="float_div_finite_plus_infinity-val"><b>float_div_finite_plus_infinity</b></a>]  Theorem

      |- ∀mode x r.
           (float_value x = Float r) ⇒
           (float_div mode x (float_plus_infinity (:τ # χ)) =
            if x.Sign = 0w then float_plus_zero (:τ # χ)
            else float_minus_zero (:τ # χ))

   [<a name="float_div_minus_infinity_finite-val"><b>float_div_minus_infinity_finite</b></a>]  Theorem

      |- ∀mode x r.
           (float_value x = Float r) ⇒
           (float_div mode (float_minus_infinity (:τ # χ)) x =
            if x.Sign = 0w then float_minus_infinity (:τ # χ)
            else float_plus_infinity (:τ # χ))

   [<a name="float_div_nan-val"><b>float_div_nan</b></a>]  Theorem

      |- ∀mode x y.
           (float_value x = NaN) ∨ (float_value y = NaN) ⇒
           (float_div mode x y = float_some_nan (:τ # χ))

   [<a name="float_div_plus_infinity_finite-val"><b>float_div_plus_infinity_finite</b></a>]  Theorem

      |- ∀mode x r.
           (float_value x = Float r) ⇒
           (float_div mode (float_plus_infinity (:τ # χ)) x =
            if x.Sign = 0w then float_plus_infinity (:τ # χ)
            else float_minus_infinity (:τ # χ))

   [<a name="float_fn_updates-val"><b>float_fn_updates</b></a>]  Theorem

      |- (∀f c c0 c1.
            float c c0 c1 with Sign updated_by f = float (f c) c0 c1) ∧
         (∀f c c0 c1.
            float c c0 c1 with Exponent updated_by f = float c (f c0) c1) ∧
         ∀f c c0 c1.
           float c c0 c1 with Significand updated_by f = float c c0 (f c1)

   [<a name="float_fupdcanon-val"><b>float_fupdcanon</b></a>]  Theorem

      |- (∀g f0 f.
            f with &lt;|Exponent updated_by f0; Sign updated_by g|&gt; =
            f with &lt;|Sign updated_by g; Exponent updated_by f0|&gt;) ∧
         (∀g f0 f.
            f with &lt;|Significand updated_by f0; Sign updated_by g|&gt; =
            f with &lt;|Sign updated_by g; Significand updated_by f0|&gt;) ∧
         ∀g f0 f.
           f with &lt;|Significand updated_by f0; Exponent updated_by g|&gt; =
           f with &lt;|Exponent updated_by g; Significand updated_by f0|&gt;

   [<a name="float_fupdcanon_comp-val"><b>float_fupdcanon_comp</b></a>]  Theorem

      |- ((∀g f0.
              _ record fupdateExponent f0 o  _ record fupdateSign g =
              _ record fupdateSign g o  _ record fupdateExponent f0) ∧
          ∀h g f0.
             _ record fupdateExponent f0 o  _ record fupdateSign g o h =
             _ record fupdateSign g o  _ record fupdateExponent f0 o h) ∧
         ((∀g f0.
              _ record fupdateSignificand f0 o  _ record fupdateSign g =
              _ record fupdateSign g o  _ record fupdateSignificand f0) ∧
          ∀h g f0.
             _ record fupdateSignificand f0 o  _ record fupdateSign g o h =
             _ record fupdateSign g o  _ record fupdateSignificand f0 o
            h) ∧
         (∀g f0.
             _ record fupdateSignificand f0 o  _ record fupdateExponent g =
             _ record fupdateExponent g o
             _ record fupdateSignificand f0) ∧
         ∀h g f0.
            _ record fupdateSignificand f0 o  _ record fupdateExponent g o
           h =
            _ record fupdateExponent g o  _ record fupdateSignificand f0 o
           h

   [<a name="float_fupdfupds-val"><b>float_fupdfupds</b></a>]  Theorem

      |- (∀g f0 f.
            f with &lt;|Sign updated_by f0; Sign updated_by g|&gt; =
            f with Sign updated_by f0 o g) ∧
         (∀g f0 f.
            f with &lt;|Exponent updated_by f0; Exponent updated_by g|&gt; =
            f with Exponent updated_by f0 o g) ∧
         ∀g f0 f.
           f with &lt;|Significand updated_by f0; Significand updated_by g|&gt; =
           f with Significand updated_by f0 o g

   [<a name="float_fupdfupds_comp-val"><b>float_fupdfupds_comp</b></a>]  Theorem

      |- ((∀g f0.
              _ record fupdateSign f0 o  _ record fupdateSign g =
              _ record fupdateSign (f0 o g)) ∧
          ∀h g f0.
             _ record fupdateSign f0 o  _ record fupdateSign g o h =
             _ record fupdateSign (f0 o g) o h) ∧
         ((∀g f0.
              _ record fupdateExponent f0 o  _ record fupdateExponent g =
              _ record fupdateExponent (f0 o g)) ∧
          ∀h g f0.
             _ record fupdateExponent f0 o  _ record fupdateExponent g o
            h =
             _ record fupdateExponent (f0 o g) o h) ∧
         (∀g f0.
             _ record fupdateSignificand f0 o
             _ record fupdateSignificand g =
             _ record fupdateSignificand (f0 o g)) ∧
         ∀h g f0.
            _ record fupdateSignificand f0 o
            _ record fupdateSignificand g o h =
            _ record fupdateSignificand (f0 o g) o h

   [<a name="float_induction-val"><b>float_induction</b></a>]  Theorem

      |- ∀P. (∀c c0 c1. P (float c c0 c1)) ⇒ ∀f. P f

   [<a name="float_infinity_negate_abs-val"><b>float_infinity_negate_abs</b></a>]  Theorem

      |- (float_negate (float_plus_infinity (:τ # χ)) =
          float_minus_infinity (:τ # χ)) ∧
         (float_negate (float_minus_infinity (:τ # χ)) =
          float_plus_infinity (:τ # χ)) ∧
         (float_abs (float_plus_infinity (:τ # χ)) =
          float_plus_infinity (:τ # χ)) ∧
         (float_abs (float_minus_infinity (:τ # χ)) =
          float_plus_infinity (:τ # χ))

   [<a name="float_is_zero-val"><b>float_is_zero</b></a>]  Theorem

      |- ∀x. float_is_zero x ⇔ (x.Exponent = 0w) ∧ (x.Significand = 0w)

   [<a name="float_is_zero_to_real-val"><b>float_is_zero_to_real</b></a>]  Theorem

      |- ∀x. float_is_zero x ⇔ (float_to_real x = 0)

   [<a name="float_literal_11-val"><b>float_literal_11</b></a>]  Theorem

      |- ∀c11 c01 c1 c12 c02 c2.
           (&lt;|Sign := c11; Exponent := c01; Significand := c1|&gt; =
            &lt;|Sign := c12; Exponent := c02; Significand := c2|&gt;) ⇔
           (c11 = c12) ∧ (c01 = c02) ∧ (c1 = c2)

   [<a name="float_literal_nchotomy-val"><b>float_literal_nchotomy</b></a>]  Theorem

      |- ∀f. ∃c1 c0 c. f = &lt;|Sign := c1; Exponent := c0; Significand := c|&gt;

   [<a name="float_minus_infinity-val"><b>float_minus_infinity</b></a>]  Theorem

      |- float_minus_infinity (:τ # χ) =
         &lt;|Sign := 1w; Exponent := UINT_MAXw; Significand := 0w|&gt;

   [<a name="float_minus_zero-val"><b>float_minus_zero</b></a>]  Theorem

      |- float_minus_zero (:τ # χ) =
         &lt;|Sign := 1w; Exponent := 0w; Significand := 0w|&gt;

   [<a name="float_mul_compute-val"><b>float_mul_compute</b></a>]  Theorem

      |- (∀mode x.
            float_mul mode (float_some_nan (:τ # χ)) x =
            float_some_nan (:τ # χ)) ∧
         (∀mode x.
            float_mul mode x (float_some_nan (:τ # χ)) =
            float_some_nan (:τ # χ)) ∧
         (∀mode.
            float_mul mode (float_minus_infinity (:τ # χ))
              (float_minus_infinity (:τ # χ)) =
            float_plus_infinity (:τ # χ)) ∧
         (∀mode.
            float_mul mode (float_minus_infinity (:τ # χ))
              (float_plus_infinity (:τ # χ)) =
            float_minus_infinity (:τ # χ)) ∧
         (∀mode.
            float_mul mode (float_plus_infinity (:τ # χ))
              (float_plus_infinity (:τ # χ)) =
            float_plus_infinity (:τ # χ)) ∧
         ∀mode.
           float_mul mode (float_plus_infinity (:τ # χ))
             (float_minus_infinity (:τ # χ)) =
           float_minus_infinity (:τ # χ)

   [<a name="float_mul_finite-val"><b>float_mul_finite</b></a>]  Theorem

      |- ∀mode x y r1 r2.
           (float_value x = Float r1) ∧ (float_value y = Float r2) ⇒
           (float_mul mode x y =
            float_round mode (x.Sign ≠ y.Sign) (r1 * r2))

   [<a name="float_mul_finite_minus_infinity-val"><b>float_mul_finite_minus_infinity</b></a>]  Theorem

      |- ∀mode x r.
           (float_value x = Float r) ⇒
           (float_mul mode x (float_minus_infinity (:τ # χ)) =
            if r = 0 then float_some_nan (:τ # χ)
            else if x.Sign = 0w then float_minus_infinity (:τ # χ)
            else float_plus_infinity (:τ # χ))

   [<a name="float_mul_finite_plus_infinity-val"><b>float_mul_finite_plus_infinity</b></a>]  Theorem

      |- ∀mode x r.
           (float_value x = Float r) ⇒
           (float_mul mode x (float_plus_infinity (:τ # χ)) =
            if r = 0 then float_some_nan (:τ # χ)
            else if x.Sign = 0w then float_plus_infinity (:τ # χ)
            else float_minus_infinity (:τ # χ))

   [<a name="float_mul_minus_infinity_finite-val"><b>float_mul_minus_infinity_finite</b></a>]  Theorem

      |- ∀mode x r.
           (float_value x = Float r) ⇒
           (float_mul mode (float_minus_infinity (:τ # χ)) x =
            if r = 0 then float_some_nan (:τ # χ)
            else if x.Sign = 0w then float_minus_infinity (:τ # χ)
            else float_plus_infinity (:τ # χ))

   [<a name="float_mul_nan-val"><b>float_mul_nan</b></a>]  Theorem

      |- ∀mode x y.
           (float_value x = NaN) ∨ (float_value y = NaN) ⇒
           (float_mul mode x y = float_some_nan (:τ # χ))

   [<a name="float_mul_plus_infinity_finite-val"><b>float_mul_plus_infinity_finite</b></a>]  Theorem

      |- ∀mode x r.
           (float_value x = Float r) ⇒
           (float_mul mode (float_plus_infinity (:τ # χ)) x =
            if r = 0 then float_some_nan (:τ # χ)
            else if x.Sign = 0w then float_plus_infinity (:τ # χ)
            else float_minus_infinity (:τ # χ))

   [<a name="float_nchotomy-val"><b>float_nchotomy</b></a>]  Theorem

      |- ∀ff. ∃c c0 c1. ff = float c c0 c1

   [<a name="float_negate_negate-val"><b>float_negate_negate</b></a>]  Theorem

      |- ∀x. float_negate (float_negate x) = x

   [<a name="float_round_bottom-val"><b>float_round_bottom</b></a>]  Theorem

      |- ∀mode toneg r.
           (round mode r = float_bottom (:τ # χ)) ⇒
           (float_round mode toneg r = float_bottom (:τ # χ))

   [<a name="float_round_minus_infinity-val"><b>float_round_minus_infinity</b></a>]  Theorem

      |- ∀mode toneg r.
           (round mode r = float_minus_infinity (:τ # χ)) ⇒
           (float_round mode toneg r = float_minus_infinity (:τ # χ))

   [<a name="float_round_non_zero-val"><b>float_round_non_zero</b></a>]  Theorem

      |- ∀mode toneg r s e f.
           (round mode r =
            &lt;|Sign := s; Exponent := e; Significand := f|&gt;) ∧
           (e ≠ 0w ∨ f ≠ 0w) ⇒
           (float_round mode toneg r =
            &lt;|Sign := s; Exponent := e; Significand := f|&gt;)

   [<a name="float_round_plus_infinity-val"><b>float_round_plus_infinity</b></a>]  Theorem

      |- ∀mode toneg r.
           (round mode r = float_plus_infinity (:τ # χ)) ⇒
           (float_round mode toneg r = float_plus_infinity (:τ # χ))

   [<a name="float_round_roundTowardNegative_minus_infinity-val"><b>float_round_roundTowardNegative_minus_infinity</b></a>]  Theorem

      |- ∀b y x.
           x &lt; -largest (:τ # χ) ⇒
           (float_round roundTowardNegative b x =
            float_minus_infinity (:τ # χ))

   [<a name="float_round_roundTowardNegative_top-val"><b>float_round_roundTowardNegative_top</b></a>]  Theorem

      |- ∀b y x.
           largest (:τ # χ) &lt; x ⇒
           (float_round roundTowardNegative b x = float_top (:τ # χ))

   [<a name="float_round_roundTowardPositive_bottom-val"><b>float_round_roundTowardPositive_bottom</b></a>]  Theorem

      |- ∀b y x.
           x &lt; -largest (:τ # χ) ⇒
           (float_round roundTowardPositive b x = float_bottom (:τ # χ))

   [<a name="float_round_roundTowardPositive_plus_infinity-val"><b>float_round_roundTowardPositive_plus_infinity</b></a>]  Theorem

      |- ∀b y x.
           largest (:τ # χ) &lt; x ⇒
           (float_round roundTowardPositive b x =
            float_plus_infinity (:τ # χ))

   [<a name="float_round_roundTowardZero_bottom-val"><b>float_round_roundTowardZero_bottom</b></a>]  Theorem

      |- ∀b y x.
           x &lt; -largest (:τ # χ) ⇒
           (float_round roundTowardZero b x = float_bottom (:τ # χ))

   [<a name="float_round_roundTowardZero_top-val"><b>float_round_roundTowardZero_top</b></a>]  Theorem

      |- ∀b y x.
           largest (:τ # χ) &lt; x ⇒
           (float_round roundTowardZero b x = float_top (:τ # χ))

   [<a name="float_round_top-val"><b>float_round_top</b></a>]  Theorem

      |- ∀mode toneg r.
           (round mode r = float_top (:τ # χ)) ⇒
           (float_round mode toneg r = float_top (:τ # χ))

   [<a name="float_sets-val"><b>float_sets</b></a>]  Theorem

      |- (float_is_zero =
          {float_minus_zero (:τ # χ); float_plus_zero (:τ # χ)}) ∧
         (float_is_infinite =
          {float_minus_infinity (:τ # χ); float_plus_infinity (:τ # χ)})

   [<a name="float_sub_compute-val"><b>float_sub_compute</b></a>]  Theorem

      |- (∀mode x.
            float_sub mode (float_some_nan (:τ # χ)) x =
            float_some_nan (:τ # χ)) ∧
         (∀mode x.
            float_sub mode x (float_some_nan (:τ # χ)) =
            float_some_nan (:τ # χ)) ∧
         (∀mode.
            float_sub mode (float_minus_infinity (:τ # χ))
              (float_minus_infinity (:τ # χ)) =
            float_some_nan (:τ # χ)) ∧
         (∀mode.
            float_sub mode (float_minus_infinity (:τ # χ))
              (float_plus_infinity (:τ # χ)) =
            float_minus_infinity (:τ # χ)) ∧
         (∀mode.
            float_sub mode (float_plus_infinity (:τ # χ))
              (float_plus_infinity (:τ # χ)) =
            float_some_nan (:τ # χ)) ∧
         ∀mode.
           float_sub mode (float_plus_infinity (:τ # χ))
             (float_minus_infinity (:τ # χ)) =
           float_plus_infinity (:τ # χ)

   [<a name="float_sub_finite-val"><b>float_sub_finite</b></a>]  Theorem

      |- ∀mode x y r1 r2.
           (float_value x = Float r1) ∧ (float_value y = Float r2) ⇒
           (float_sub mode x y =
            float_round mode
              (if (r1 = 0) ∧ (r2 = 0) ∧ x.Sign ≠ y.Sign then x.Sign = 1w
               else (mode = roundTowardNegative)) (r1 − r2))

   [<a name="float_sub_finite_minus_infinity-val"><b>float_sub_finite_minus_infinity</b></a>]  Theorem

      |- ∀mode x r.
           (float_value x = Float r) ⇒
           (float_sub mode x (float_minus_infinity (:τ # χ)) =
            float_plus_infinity (:τ # χ))

   [<a name="float_sub_finite_plus_infinity-val"><b>float_sub_finite_plus_infinity</b></a>]  Theorem

      |- ∀mode x r.
           (float_value x = Float r) ⇒
           (float_sub mode x (float_plus_infinity (:τ # χ)) =
            float_minus_infinity (:τ # χ))

   [<a name="float_sub_minus_infinity_finite-val"><b>float_sub_minus_infinity_finite</b></a>]  Theorem

      |- ∀mode x r.
           (float_value x = Float r) ⇒
           (float_sub mode (float_minus_infinity (:τ # χ)) x =
            float_minus_infinity (:τ # χ))

   [<a name="float_sub_nan-val"><b>float_sub_nan</b></a>]  Theorem

      |- ∀mode x y.
           (float_value x = NaN) ∨ (float_value y = NaN) ⇒
           (float_sub mode x y = float_some_nan (:τ # χ))

   [<a name="float_sub_plus_infinity_finite-val"><b>float_sub_plus_infinity_finite</b></a>]  Theorem

      |- ∀mode x r.
           (float_value x = Float r) ⇒
           (float_sub mode (float_plus_infinity (:τ # χ)) x =
            float_plus_infinity (:τ # χ))

   [<a name="float_tests-val"><b>float_tests</b></a>]  Theorem

      |- (∀s e f.
            float_is_nan &lt;|Sign := s; Exponent := e; Significand := f|&gt; ⇔
            (e = -1w) ∧ f ≠ 0w) ∧
         (∀s e f.
            float_is_infinite
              &lt;|Sign := s; Exponent := e; Significand := f|&gt; ⇔
            (e = -1w) ∧ (f = 0w)) ∧
         (∀s e f.
            float_is_normal
              &lt;|Sign := s; Exponent := e; Significand := f|&gt; ⇔
            e ≠ 0w ∧ e ≠ -1w) ∧
         (∀s e f.
            float_is_subnormal
              &lt;|Sign := s; Exponent := e; Significand := f|&gt; ⇔
            (e = 0w) ∧ f ≠ 0w) ∧
         (∀s e f.
            float_is_zero &lt;|Sign := s; Exponent := e; Significand := f|&gt; ⇔
            (e = 0w) ∧ (f = 0w)) ∧
         ∀s e f.
           float_is_finite &lt;|Sign := s; Exponent := e; Significand := f|&gt; ⇔
           e ≠ -1w

   [<a name="float_to_real-val"><b>float_to_real</b></a>]  Theorem

      |- ∀s e f.
           float_to_real &lt;|Sign := s; Exponent := e; Significand := f|&gt; =
           (let r =
                  if e = 0w then
                    2 / &(2 ** bias (:χ)) * (&w2n f / &dimword (:τ))
                  else
                    &(2 ** w2n e) / &(2 ** bias (:χ)) *
                    (1 + &w2n f / &dimword (:τ))
            in
              if s = 1w then -r else r)

   [<a name="float_to_real_eq-val"><b>float_to_real_eq</b></a>]  Theorem

      |- ∀x y.
           (float_to_real x = float_to_real y) ⇔
           (x = y) ∨ float_is_zero x ∧ float_is_zero y

   [<a name="float_to_real_negate-val"><b>float_to_real_negate</b></a>]  Theorem

      |- ∀x. float_to_real (float_negate x) = -float_to_real x

   [<a name="float_updates_eq_literal-val"><b>float_updates_eq_literal</b></a>]  Theorem

      |- ∀f c1 c0 c.
           f with &lt;|Sign := c1; Exponent := c0; Significand := c|&gt; =
           &lt;|Sign := c1; Exponent := c0; Significand := c|&gt;

   [<a name="float_value_11-val"><b>float_value_11</b></a>]  Theorem

      |- ∀a a'. (Float a = Float a') ⇔ (a = a')

   [<a name="float_value_Axiom-val"><b>float_value_Axiom</b></a>]  Theorem

      |- ∀f0 f1 f2.
           ∃fn.
             (∀a. fn (Float a) = f0 a) ∧ (fn Infinity = f1) ∧ (fn NaN = f2)

   [<a name="float_value_case_cong-val"><b>float_value_case_cong</b></a>]  Theorem

      |- ∀M M' f v v1.
           (M = M') ∧ (∀a. (M' = Float a) ⇒ (f a = f' a)) ∧
           ((M' = Infinity) ⇒ (v = v')) ∧ ((M' = NaN) ⇒ (v1 = v1')) ⇒
           (float_value_CASE M f v v1 = float_value_CASE M' f' v' v1')

   [<a name="float_value_distinct-val"><b>float_value_distinct</b></a>]  Theorem

      |- (∀a. Float a ≠ Infinity) ∧ (∀a. Float a ≠ NaN) ∧ Infinity ≠ NaN

   [<a name="float_value_induction-val"><b>float_value_induction</b></a>]  Theorem

      |- ∀P. (∀r. P (Float r)) ∧ P Infinity ∧ P NaN ⇒ ∀f. P f

   [<a name="float_value_nchotomy-val"><b>float_value_nchotomy</b></a>]  Theorem

      |- ∀ff. (∃r. ff = Float r) ∨ (ff = Infinity) ∨ (ff = NaN)

   [<a name="float_values-val"><b>float_values</b></a>]  Theorem

      |- (float_value (float_plus_infinity (:τ # χ)) = Infinity) ∧
         (float_value (float_minus_infinity (:τ # χ)) = Infinity) ∧
         (float_value (float_some_nan (:τ # χ)) = NaN) ∧
         (float_value (float_plus_zero (:τ # χ)) = Float 0) ∧
         (float_value (float_minus_zero (:τ # χ)) = Float 0) ∧
         (float_value (float_plus_min (:τ # χ)) =
          Float (2 / 2 pow (bias (:χ) + precision (:τ)))) ∧
         (float_value (float_minus_min (:τ # χ)) =
          Float (-2 / 2 pow (bias (:χ) + precision (:τ))))

   [<a name="infinity_properties-val"><b>infinity_properties</b></a>]  Theorem

      |- ¬float_is_zero (float_plus_infinity (:τ # χ)) ∧
         ¬float_is_zero (float_minus_infinity (:τ # χ)) ∧
         ¬float_is_finite (float_plus_infinity (:τ # χ)) ∧
         ¬float_is_finite (float_minus_infinity (:τ # χ)) ∧
         ¬float_is_integral (float_plus_infinity (:τ # χ)) ∧
         ¬float_is_integral (float_minus_infinity (:τ # χ)) ∧
         ¬float_is_nan (float_plus_infinity (:τ # χ)) ∧
         ¬float_is_nan (float_minus_infinity (:τ # χ)) ∧
         ¬float_is_normal (float_plus_infinity (:τ # χ)) ∧
         ¬float_is_normal (float_minus_infinity (:τ # χ)) ∧
         ¬float_is_subnormal (float_plus_infinity (:τ # χ)) ∧
         ¬float_is_subnormal (float_minus_infinity (:τ # χ)) ∧
         float_is_infinite (float_plus_infinity (:τ # χ)) ∧
         float_is_infinite (float_minus_infinity (:τ # χ))

   [<a name="largest-val"><b>largest</b></a>]  Theorem

      |- largest (:τ # χ) =
         &(2 ** (UINT_MAX (:χ) − 1)) * (2 − 1 / &dimword (:τ)) /
         &(2 ** bias (:χ))

   [<a name="largest_is_positive-val"><b>largest_is_positive</b></a>]  Theorem

      |- 0 ≤ largest (:τ # χ)

   [<a name="le2-val"><b>le2</b></a>]  Theorem

      |- ∀n m. 2 ≤ n ∧ 2 ≤ m ⇒ 2 ≤ n * m

   [<a name="less_than_ulp-val"><b>less_than_ulp</b></a>]  Theorem

      |- ∀a.
           abs (float_to_real a) &lt; ulp (:τ # χ) ⇔
           (a.Exponent = 0w) ∧ (a.Significand = 0w)

   [<a name="min_properties-val"><b>min_properties</b></a>]  Theorem

      |- ¬float_is_zero (float_plus_min (:τ # χ)) ∧
         float_is_finite (float_plus_min (:τ # χ)) ∧
         (float_is_integral (float_plus_min (:τ # χ)) ⇔
          (precision (:χ) = 1) ∧ (precision (:τ) = 1)) ∧
         ¬float_is_nan (float_plus_min (:τ # χ)) ∧
         ¬float_is_normal (float_plus_min (:τ # χ)) ∧
         float_is_subnormal (float_plus_min (:τ # χ)) ∧
         ¬float_is_infinite (float_plus_min (:τ # χ)) ∧
         ¬float_is_zero (float_minus_min (:τ # χ)) ∧
         float_is_finite (float_minus_min (:τ # χ)) ∧
         (float_is_integral (float_minus_min (:τ # χ)) ⇔
          (precision (:χ) = 1) ∧ (precision (:τ) = 1)) ∧
         ¬float_is_nan (float_minus_min (:τ # χ)) ∧
         ¬float_is_normal (float_minus_min (:τ # χ)) ∧
         float_is_subnormal (float_minus_min (:τ # χ)) ∧
         ¬float_is_infinite (float_minus_min (:τ # χ))

   [<a name="neg_ulp-val"><b>neg_ulp</b></a>]  Theorem

      |- -ulp (:τ # χ) =
         float_to_real (float_negate (float_plus_min (:τ # χ)))

   [<a name="num2float_compare_11-val"><b>num2float_compare_11</b></a>]  Theorem

      |- ∀r r'.
           r &lt; 4 ⇒
           r' &lt; 4 ⇒
           ((num2float_compare r = num2float_compare r') ⇔ (r = r'))

   [<a name="num2float_compare_ONTO-val"><b>num2float_compare_ONTO</b></a>]  Theorem

      |- ∀a. ∃r. (a = num2float_compare r) ∧ r &lt; 4

   [<a name="num2float_compare_float_compare2num-val"><b>num2float_compare_float_compare2num</b></a>]  Theorem

      |- ∀a. num2float_compare (float_compare2num a) = a

   [<a name="num2float_compare_thm-val"><b>num2float_compare_thm</b></a>]  Theorem

      |- (num2float_compare 0 = LT) ∧ (num2float_compare 1 = GT) ∧
         (num2float_compare 2 = EQ) ∧ (num2float_compare 3 = UN)

   [<a name="num2rounding_11-val"><b>num2rounding_11</b></a>]  Theorem

      |- ∀r r'.
           r &lt; 4 ⇒ r' &lt; 4 ⇒ ((num2rounding r = num2rounding r') ⇔ (r = r'))

   [<a name="num2rounding_ONTO-val"><b>num2rounding_ONTO</b></a>]  Theorem

      |- ∀a. ∃r. (a = num2rounding r) ∧ r &lt; 4

   [<a name="num2rounding_rounding2num-val"><b>num2rounding_rounding2num</b></a>]  Theorem

      |- ∀a. num2rounding (rounding2num a) = a

   [<a name="num2rounding_thm-val"><b>num2rounding_thm</b></a>]  Theorem

      |- (num2rounding 0 = roundTiesToEven) ∧
         (num2rounding 1 = roundTowardPositive) ∧
         (num2rounding 2 = roundTowardNegative) ∧
         (num2rounding 3 = roundTowardZero)

   [<a name="round_roundTiesToEven-val"><b>round_roundTiesToEven</b></a>]  Theorem

      |- ∀y x r.
           (float_value y = Float r) ∧
           ((y.Significand = 0w) ∧ y.Exponent ≠ 1w ⇒ abs r ≤ abs x) ∧
           2 * abs (r − x) ≤ ULP (y.Exponent,(:τ)) ∧
           ((2 * abs (r − x) = ULP (y.Exponent,(:τ))) ⇒
            ¬word_lsb y.Significand) ∧ ulp (:τ # χ) &lt; 2 * abs x ∧
           abs x &lt; threshold (:τ # χ) ⇒
           (round roundTiesToEven x = y)

   [<a name="round_roundTiesToEven0-val"><b>round_roundTiesToEven0</b></a>]  Theorem

      |- ∀y x r.
           (float_value y = Float r) ∧
           ((y.Significand = 0w) ∧ y.Exponent ≠ 1w ∧ ¬(abs r ≤ abs x)) ∧
           4 * abs (r − x) ≤ ULP (y.Exponent,(:τ)) ∧
           ulp (:τ # χ) &lt; 2 * abs x ∧ abs x &lt; threshold (:τ # χ) ⇒
           (round roundTiesToEven x = y)

   [<a name="round_roundTiesToEven_is_minus_zero-val"><b>round_roundTiesToEven_is_minus_zero</b></a>]  Theorem

      |- ∀x.
           2 * abs x ≤ ulp (:τ # χ) ⇒
           (float_round roundTiesToEven T x = float_minus_zero (:τ # χ))

   [<a name="round_roundTiesToEven_is_plus_zero-val"><b>round_roundTiesToEven_is_plus_zero</b></a>]  Theorem

      |- ∀x.
           2 * abs x ≤ ulp (:τ # χ) ⇒
           (float_round roundTiesToEven F x = float_plus_zero (:τ # χ))

   [<a name="round_roundTiesToEven_is_zero-val"><b>round_roundTiesToEven_is_zero</b></a>]  Theorem

      |- ∀x.
           2 * abs x ≤ ulp (:τ # χ) ⇒
           (round roundTiesToEven x = float_plus_zero (:τ # χ)) ∨
           (round roundTiesToEven x = float_minus_zero (:τ # χ))

   [<a name="round_roundTiesToEven_minus_infinity-val"><b>round_roundTiesToEven_minus_infinity</b></a>]  Theorem

      |- ∀y x.
           x ≤ -threshold (:τ # χ) ⇒
           (round roundTiesToEven x = float_minus_infinity (:τ # χ))

   [<a name="round_roundTiesToEven_plus_infinity-val"><b>round_roundTiesToEven_plus_infinity</b></a>]  Theorem

      |- ∀y x.
           threshold (:τ # χ) ≤ x ⇒
           (round roundTiesToEven x = float_plus_infinity (:τ # χ))

   [<a name="round_roundTowardNegative_minus_infinity-val"><b>round_roundTowardNegative_minus_infinity</b></a>]  Theorem

      |- ∀y x.
           x &lt; -largest (:τ # χ) ⇒
           (round roundTowardNegative x = float_minus_infinity (:τ # χ))

   [<a name="round_roundTowardNegative_top-val"><b>round_roundTowardNegative_top</b></a>]  Theorem

      |- ∀y x.
           largest (:τ # χ) &lt; x ⇒
           (round roundTowardNegative x = float_top (:τ # χ))

   [<a name="round_roundTowardPositive_bottom-val"><b>round_roundTowardPositive_bottom</b></a>]  Theorem

      |- ∀y x.
           x &lt; -largest (:τ # χ) ⇒
           (round roundTowardPositive x = float_bottom (:τ # χ))

   [<a name="round_roundTowardPositive_plus_infinity-val"><b>round_roundTowardPositive_plus_infinity</b></a>]  Theorem

      |- ∀y x.
           largest (:τ # χ) &lt; x ⇒
           (round roundTowardPositive x = float_plus_infinity (:τ # χ))

   [<a name="round_roundTowardZero-val"><b>round_roundTowardZero</b></a>]  Theorem

      |- ∀y x r.
           (float_value y = Float r) ∧
           abs (r − x) &lt; ULP (y.Exponent,(:τ)) ∧ abs r ≤ abs x ∧
           ulp (:τ # χ) ≤ abs x ∧ abs x ≤ largest (:τ # χ) ⇒
           (round roundTowardZero x = y)

   [<a name="round_roundTowardZero_bottom-val"><b>round_roundTowardZero_bottom</b></a>]  Theorem

      |- ∀y x.
           x &lt; -largest (:τ # χ) ⇒
           (round roundTowardZero x = float_bottom (:τ # χ))

   [<a name="round_roundTowardZero_is_minus_zero-val"><b>round_roundTowardZero_is_minus_zero</b></a>]  Theorem

      |- ∀x.
           abs x &lt; ulp (:τ # χ) ⇒
           (float_round roundTowardZero T x = float_minus_zero (:τ # χ))

   [<a name="round_roundTowardZero_is_plus_zero-val"><b>round_roundTowardZero_is_plus_zero</b></a>]  Theorem

      |- ∀x.
           abs x &lt; ulp (:τ # χ) ⇒
           (float_round roundTowardZero F x = float_plus_zero (:τ # χ))

   [<a name="round_roundTowardZero_is_zero-val"><b>round_roundTowardZero_is_zero</b></a>]  Theorem

      |- ∀x.
           abs x &lt; ulp (:τ # χ) ⇒
           (round roundTowardZero x = float_plus_zero (:τ # χ)) ∨
           (round roundTowardZero x = float_minus_zero (:τ # χ))

   [<a name="round_roundTowardZero_top-val"><b>round_roundTowardZero_top</b></a>]  Theorem

      |- ∀y x.
           largest (:τ # χ) &lt; x ⇒
           (round roundTowardZero x = float_top (:τ # χ))

   [<a name="rounding2num_11-val"><b>rounding2num_11</b></a>]  Theorem

      |- ∀a a'. (rounding2num a = rounding2num a') ⇔ (a = a')

   [<a name="rounding2num_ONTO-val"><b>rounding2num_ONTO</b></a>]  Theorem

      |- ∀r. r &lt; 4 ⇔ ∃a. r = rounding2num a

   [<a name="rounding2num_num2rounding-val"><b>rounding2num_num2rounding</b></a>]  Theorem

      |- ∀r. r &lt; 4 ⇔ (rounding2num (num2rounding r) = r)

   [<a name="rounding2num_thm-val"><b>rounding2num_thm</b></a>]  Theorem

      |- (rounding2num roundTiesToEven = 0) ∧
         (rounding2num roundTowardPositive = 1) ∧
         (rounding2num roundTowardNegative = 2) ∧
         (rounding2num roundTowardZero = 3)

   [<a name="rounding_Axiom-val"><b>rounding_Axiom</b></a>]  Theorem

      |- ∀x0 x1 x2 x3.
           ∃f.
             (f roundTiesToEven = x0) ∧ (f roundTowardPositive = x1) ∧
             (f roundTowardNegative = x2) ∧ (f roundTowardZero = x3)

   [<a name="rounding_EQ_rounding-val"><b>rounding_EQ_rounding</b></a>]  Theorem

      |- ∀a a'. (a = a') ⇔ (rounding2num a = rounding2num a')

   [<a name="rounding_case_cong-val"><b>rounding_case_cong</b></a>]  Theorem

      |- ∀M M' v0 v1 v2 v3.
           (M = M') ∧ ((M' = roundTiesToEven) ⇒ (v0 = v0')) ∧
           ((M' = roundTowardPositive) ⇒ (v1 = v1')) ∧
           ((M' = roundTowardNegative) ⇒ (v2 = v2')) ∧
           ((M' = roundTowardZero) ⇒ (v3 = v3')) ⇒
           ((case M of
               roundTiesToEven =&gt; v0
             | roundTowardPositive =&gt; v1
             | roundTowardNegative =&gt; v2
             | roundTowardZero =&gt; v3) =
            case M' of
              roundTiesToEven =&gt; v0'
            | roundTowardPositive =&gt; v1'
            | roundTowardNegative =&gt; v2'
            | roundTowardZero =&gt; v3')

   [<a name="rounding_case_def-val"><b>rounding_case_def</b></a>]  Theorem

      |- (∀v0 v1 v2 v3.
            (case roundTiesToEven of
               roundTiesToEven =&gt; v0
             | roundTowardPositive =&gt; v1
             | roundTowardNegative =&gt; v2
             | roundTowardZero =&gt; v3) =
            v0) ∧
         (∀v0 v1 v2 v3.
            (case roundTowardPositive of
               roundTiesToEven =&gt; v0
             | roundTowardPositive =&gt; v1
             | roundTowardNegative =&gt; v2
             | roundTowardZero =&gt; v3) =
            v1) ∧
         (∀v0 v1 v2 v3.
            (case roundTowardNegative of
               roundTiesToEven =&gt; v0
             | roundTowardPositive =&gt; v1
             | roundTowardNegative =&gt; v2
             | roundTowardZero =&gt; v3) =
            v2) ∧
         ∀v0 v1 v2 v3.
           (case roundTowardZero of
              roundTiesToEven =&gt; v0
            | roundTowardPositive =&gt; v1
            | roundTowardNegative =&gt; v2
            | roundTowardZero =&gt; v3) =
           v3

   [<a name="rounding_distinct-val"><b>rounding_distinct</b></a>]  Theorem

      |- roundTiesToEven ≠ roundTowardPositive ∧
         roundTiesToEven ≠ roundTowardNegative ∧
         roundTiesToEven ≠ roundTowardZero ∧
         roundTowardPositive ≠ roundTowardNegative ∧
         roundTowardPositive ≠ roundTowardZero ∧
         roundTowardNegative ≠ roundTowardZero

   [<a name="rounding_induction-val"><b>rounding_induction</b></a>]  Theorem

      |- ∀P.
           P roundTiesToEven ∧ P roundTowardNegative ∧
           P roundTowardPositive ∧ P roundTowardZero ⇒
           ∀a. P a

   [<a name="rounding_nchotomy-val"><b>rounding_nchotomy</b></a>]  Theorem

      |- ∀a.
           (a = roundTiesToEven) ∨ (a = roundTowardPositive) ∨
           (a = roundTowardNegative) ∨ (a = roundTowardZero)

   [<a name="sign_not_zero-val"><b>sign_not_zero</b></a>]  Theorem

      |- ∀s. -1 pow w2n s ≠ 0

   [<a name="some_nan_properties-val"><b>some_nan_properties</b></a>]  Theorem

      |- ¬float_is_zero (float_some_nan (:τ # χ)) ∧
         ¬float_is_finite (float_some_nan (:τ # χ)) ∧
         ¬float_is_integral (float_some_nan (:τ # χ)) ∧
         float_is_nan (float_some_nan (:τ # χ)) ∧
         ¬float_is_normal (float_some_nan (:τ # χ)) ∧
         ¬float_is_subnormal (float_some_nan (:τ # χ)) ∧
         ¬float_is_infinite (float_some_nan (:τ # χ))

   [<a name="threshold-val"><b>threshold</b></a>]  Theorem

      |- threshold (:τ # χ) =
         &(2 ** (UINT_MAX (:χ) − 1)) * (2 − 1 / &(2 * dimword (:τ))) /
         &(2 ** bias (:χ))

   [<a name="threshold_is_positive-val"><b>threshold_is_positive</b></a>]  Theorem

      |- 0 &lt; threshold (:τ # χ)

   [<a name="top_properties-val"><b>top_properties</b></a>]  Theorem

      |- ¬float_is_zero (float_top (:τ # χ)) ∧
         float_is_finite (float_top (:τ # χ)) ∧
         ¬float_is_nan (float_top (:τ # χ)) ∧
         (float_is_normal (float_top (:τ # χ)) ⇔ precision (:χ) ≠ 1) ∧
         (float_is_subnormal (float_top (:τ # χ)) ⇔ (precision (:χ) = 1)) ∧
         ¬float_is_infinite (float_top (:τ # χ))

   [<a name="ulp-val"><b>ulp</b></a>]  Theorem

      |- ulp (:τ # χ) = float_to_real (float_plus_min (:τ # χ))

   [<a name="ulp_lt_ULP-val"><b>ulp_lt_ULP</b></a>]  Theorem

      |- ∀e. ulp (:τ # χ) ≤ ULP (e,(:τ))

   [<a name="ulp_lt_largest-val"><b>ulp_lt_largest</b></a>]  Theorem

      |- ulp (:τ # χ) &lt; largest (:τ # χ)

   [<a name="ulp_lt_threshold-val"><b>ulp_lt_threshold</b></a>]  Theorem

      |- ulp (:τ # χ) &lt; threshold (:τ # χ)

   [<a name="zero_le_pos_div_twopow-val"><b>zero_le_pos_div_twopow</b></a>]  Theorem

      |- ∀m n. 0 ≤ &m / 2 pow n

   [<a name="zero_le_twopow-val"><b>zero_le_twopow</b></a>]  Theorem

      |- ∀n. 0 ≤ 2 pow n

   [<a name="zero_lt_twopow-val"><b>zero_lt_twopow</b></a>]  Theorem

      |- ∀n. 0 &lt; 2 pow n

   [<a name="zero_neq_twopow-val"><b>zero_neq_twopow</b></a>]  Theorem

      |- ∀n. 2 pow n ≠ 0

   [<a name="zero_properties-val"><b>zero_properties</b></a>]  Theorem

      |- float_is_zero (float_plus_zero (:τ # χ)) ∧
         float_is_zero (float_minus_zero (:τ # χ)) ∧
         float_is_finite (float_plus_zero (:τ # χ)) ∧
         float_is_finite (float_minus_zero (:τ # χ)) ∧
         float_is_integral (float_plus_zero (:τ # χ)) ∧
         float_is_integral (float_minus_zero (:τ # χ)) ∧
         ¬float_is_nan (float_plus_zero (:τ # χ)) ∧
         ¬float_is_nan (float_minus_zero (:τ # χ)) ∧
         ¬float_is_normal (float_plus_zero (:τ # χ)) ∧
         ¬float_is_normal (float_minus_zero (:τ # χ)) ∧
         ¬float_is_subnormal (float_plus_zero (:τ # χ)) ∧
         ¬float_is_subnormal (float_minus_zero (:τ # χ)) ∧
         ¬float_is_infinite (float_plus_zero (:τ # χ)) ∧
         ¬float_is_infinite (float_minus_zero (:τ # χ))

   [<a name="zero_to_real-val"><b>zero_to_real</b></a>]  Theorem

      |- (float_to_real (float_plus_zero (:τ # χ)) = 0) ∧
         (float_to_real (float_minus_zero (:τ # χ)) = 0)


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/floating-point/binary_ieeeScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-10</a></em></p></body></html>
