<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure fcpTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure fcpTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/n-bit/fcpScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature fcpTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#FCP-val">FCP</a> : thm
<a name="line7"></a>    val <a href="#FCP_CONCAT_def-val">FCP_CONCAT_def</a> : thm
<a name="line8"></a>    val <a href="#FCP_CONS_def-val">FCP_CONS_def</a> : thm
<a name="line9"></a>    val <a href="#FCP_EVERY_def-val">FCP_EVERY_def</a> : thm
<a name="line10"></a>    val <a href="#FCP_EXISTS_def-val">FCP_EXISTS_def</a> : thm
<a name="line11"></a>    val <a href="#FCP_FOLD_def-val">FCP_FOLD_def</a> : thm
<a name="line12"></a>    val <a href="#FCP_HD_def-val">FCP_HD_def</a> : thm
<a name="line13"></a>    val <a href="#FCP_MAP_def-val">FCP_MAP_def</a> : thm
<a name="line14"></a>    val <a href="#FCP_TL_def-val">FCP_TL_def</a> : thm
<a name="line15"></a>    val <a href="#FCP_UPDATE_def-val">FCP_UPDATE_def</a> : thm
<a name="line16"></a>    val <a href="#FCP_ZIP_def-val">FCP_ZIP_def</a> : thm
<a name="line17"></a>    val <a href="#HAS_SIZE_def-val">HAS_SIZE_def</a> : thm
<a name="line18"></a>    val <a href="#L2V_def-val">L2V_def</a> : thm
<a name="line19"></a>    val <a href="#V2L_def-val">V2L_def</a> : thm
<a name="line20"></a>    val <a href="#bit0_TY_DEF-val">bit0_TY_DEF</a> : thm
<a name="line21"></a>    val <a href="#bit0_case_def-val">bit0_case_def</a> : thm
<a name="line22"></a>    val <a href="#bit0_size_def-val">bit0_size_def</a> : thm
<a name="line23"></a>    val <a href="#bit1_TY_DEF-val">bit1_TY_DEF</a> : thm
<a name="line24"></a>    val <a href="#bit1_case_def-val">bit1_case_def</a> : thm
<a name="line25"></a>    val <a href="#bit1_size_def-val">bit1_size_def</a> : thm
<a name="line26"></a>    val <a href="#cart_TY_DEF-val">cart_TY_DEF</a> : thm
<a name="line27"></a>    val <a href="#cart_tybij-val">cart_tybij</a> : thm
<a name="line28"></a>    val <a href="#dimindex_def-val">dimindex_def</a> : thm
<a name="line29"></a>    val <a href="#fcp_case_def-val">fcp_case_def</a> : thm
<a name="line30"></a>    val <a href="#fcp_index-val">fcp_index</a> : thm
<a name="line31"></a>    val <a href="#finite_image_TY_DEF-val">finite_image_TY_DEF</a> : thm
<a name="line32"></a>    val <a href="#finite_image_tybij-val">finite_image_tybij</a> : thm
<a name="line33"></a>    val <a href="#finite_index_def-val">finite_index_def</a> : thm
<a name="line34"></a>
<a name="line35"></a>  (*  Theorems  *)
<a name="line36"></a>    val <a href="#APPLY_FCP_UPDATE_ID-val">APPLY_FCP_UPDATE_ID</a> : thm
<a name="line37"></a>    val <a href="#CART_EQ-val">CART_EQ</a> : thm
<a name="line38"></a>    val <a href="#DIMINDEX_GE_1-val">DIMINDEX_GE_1</a> : thm
<a name="line39"></a>    val <a href="#EL_V2L-val">EL_V2L</a> : thm
<a name="line40"></a>    val <a href="#FCP_APPLY_UPDATE_THM-val">FCP_APPLY_UPDATE_THM</a> : thm
<a name="line41"></a>    val <a href="#FCP_BETA-val">FCP_BETA</a> : thm
<a name="line42"></a>    val <a href="#FCP_CONS-val">FCP_CONS</a> : thm
<a name="line43"></a>    val <a href="#FCP_ETA-val">FCP_ETA</a> : thm
<a name="line44"></a>    val <a href="#FCP_EVERY-val">FCP_EVERY</a> : thm
<a name="line45"></a>    val <a href="#FCP_EXISTS-val">FCP_EXISTS</a> : thm
<a name="line46"></a>    val <a href="#FCP_HD-val">FCP_HD</a> : thm
<a name="line47"></a>    val <a href="#FCP_MAP-val">FCP_MAP</a> : thm
<a name="line48"></a>    val <a href="#FCP_TL-val">FCP_TL</a> : thm
<a name="line49"></a>    val <a href="#FCP_UNIQUE-val">FCP_UNIQUE</a> : thm
<a name="line50"></a>    val <a href="#FCP_UPDATE_COMMUTES-val">FCP_UPDATE_COMMUTES</a> : thm
<a name="line51"></a>    val <a href="#FCP_UPDATE_EQ-val">FCP_UPDATE_EQ</a> : thm
<a name="line52"></a>    val <a href="#FCP_UPDATE_IMP_ID-val">FCP_UPDATE_IMP_ID</a> : thm
<a name="line53"></a>    val <a href="#LENGTH_V2L-val">LENGTH_V2L</a> : thm
<a name="line54"></a>    val <a href="#NOT_FINITE_IMP_dimindex_1-val">NOT_FINITE_IMP_dimindex_1</a> : thm
<a name="line55"></a>    val <a href="#NULL_V2L-val">NULL_V2L</a> : thm
<a name="line56"></a>    val <a href="#READ_L2V-val">READ_L2V</a> : thm
<a name="line57"></a>    val <a href="#READ_TL-val">READ_TL</a> : thm
<a name="line58"></a>    val <a href="#V2L_L2V-val">V2L_L2V</a> : thm
<a name="line59"></a>    val <a href="#bit0_11-val">bit0_11</a> : thm
<a name="line60"></a>    val <a href="#bit0_Axiom-val">bit0_Axiom</a> : thm
<a name="line61"></a>    val <a href="#bit0_case_cong-val">bit0_case_cong</a> : thm
<a name="line62"></a>    val <a href="#bit0_distinct-val">bit0_distinct</a> : thm
<a name="line63"></a>    val <a href="#bit0_induction-val">bit0_induction</a> : thm
<a name="line64"></a>    val <a href="#bit0_nchotomy-val">bit0_nchotomy</a> : thm
<a name="line65"></a>    val <a href="#bit1_11-val">bit1_11</a> : thm
<a name="line66"></a>    val <a href="#bit1_Axiom-val">bit1_Axiom</a> : thm
<a name="line67"></a>    val <a href="#bit1_case_cong-val">bit1_case_cong</a> : thm
<a name="line68"></a>    val <a href="#bit1_distinct-val">bit1_distinct</a> : thm
<a name="line69"></a>    val <a href="#bit1_induction-val">bit1_induction</a> : thm
<a name="line70"></a>    val <a href="#bit1_nchotomy-val">bit1_nchotomy</a> : thm
<a name="line71"></a>    val <a href="#card_dimindex-val">card_dimindex</a> : thm
<a name="line72"></a>    val <a href="#datatype_bit0-val">datatype_bit0</a> : thm
<a name="line73"></a>    val <a href="#datatype_bit1-val">datatype_bit1</a> : thm
<a name="line74"></a>    val <a href="#fcp_Axiom-val">fcp_Axiom</a> : thm
<a name="line75"></a>    val <a href="#fcp_ind-val">fcp_ind</a> : thm
<a name="line76"></a>    val <a href="#fcp_subst_comp-val">fcp_subst_comp</a> : thm
<a name="line77"></a>    val <a href="#finite_bit0-val">finite_bit0</a> : thm
<a name="line78"></a>    val <a href="#finite_bit1-val">finite_bit1</a> : thm
<a name="line79"></a>    val <a href="#finite_one-val">finite_one</a> : thm
<a name="line80"></a>    val <a href="#finite_sum-val">finite_sum</a> : thm
<a name="line81"></a>    val <a href="#index_bit0-val">index_bit0</a> : thm
<a name="line82"></a>    val <a href="#index_bit1-val">index_bit1</a> : thm
<a name="line83"></a>    val <a href="#index_comp-val">index_comp</a> : thm
<a name="line84"></a>    val <a href="#index_one-val">index_one</a> : thm
<a name="line85"></a>    val <a href="#index_sum-val">index_sum</a> : thm
<a name="line86"></a>
<a name="line87"></a>  val fcp_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line88"></a>(*
   [list] Parent theory of "fcp"

   [<a name="FCP-val"><b>FCP</b></a>]  Definition

      |- $FCP = (λg. @f. ∀i. i &lt; dimindex (:β) ⇒ (f ' i = g i))

   [<a name="FCP_CONCAT_def-val"><b>FCP_CONCAT_def</b></a>]  Definition

      |- ∀a b.
           FCP_CONCAT a b =
           FCP i.
             if i &lt; dimindex (:γ) then b ' i else a ' (i − dimindex (:γ))

   [<a name="FCP_CONS_def-val"><b>FCP_CONS_def</b></a>]  Definition

      |- ∀h v. FCP_CONS h v = (0 :+ h) (FCP i. v ' (PRE i))

   [<a name="FCP_EVERY_def-val"><b>FCP_EVERY_def</b></a>]  Definition

      |- ∀P v. FCP_EVERY P v ⇔ ∀i. dimindex (:α) ≤ i ∨ P (v ' i)

   [<a name="FCP_EXISTS_def-val"><b>FCP_EXISTS_def</b></a>]  Definition

      |- ∀P v. FCP_EXISTS P v ⇔ ∃i. i &lt; dimindex (:α) ∧ P (v ' i)

   [<a name="FCP_FOLD_def-val"><b>FCP_FOLD_def</b></a>]  Definition

      |- ∀f i v. FCP_FOLD f i v = FOLDL f i (V2L v)

   [<a name="FCP_HD_def-val"><b>FCP_HD_def</b></a>]  Definition

      |- ∀v. FCP_HD v = v ' 0

   [<a name="FCP_MAP_def-val"><b>FCP_MAP_def</b></a>]  Definition

      |- ∀f v. FCP_MAP f v = FCP i. f (v ' i)

   [<a name="FCP_TL_def-val"><b>FCP_TL_def</b></a>]  Definition

      |- ∀v. FCP_TL v = FCP i. v ' (SUC i)

   [<a name="FCP_UPDATE_def-val"><b>FCP_UPDATE_def</b></a>]  Definition

      |- ∀a b. a :+ b = (λm. FCP c. if a = c then b else m ' c)

   [<a name="FCP_ZIP_def-val"><b>FCP_ZIP_def</b></a>]  Definition

      |- ∀a b. FCP_ZIP a b = FCP i. (a ' i,b ' i)

   [<a name="HAS_SIZE_def-val"><b>HAS_SIZE_def</b></a>]  Definition

      |- ∀s n. s HAS_SIZE n ⇔ FINITE s ∧ (CARD s = n)

   [<a name="L2V_def-val"><b>L2V_def</b></a>]  Definition

      |- ∀L. L2V L = FCP i. EL i L

   [<a name="V2L_def-val"><b>V2L_def</b></a>]  Definition

      |- ∀v. V2L v = GENLIST ($' v) (dimindex (:β))

   [<a name="bit0_TY_DEF-val"><b>bit0_TY_DEF</b></a>]  Definition

      |- ∃rep.
           TYPE_DEFINITION
             (λa0.
                ∀'bit0' .
                  (∀a0.
                     (∃a.
                        a0 =
                        (λa. ind_type$CONSTR 0 a (λn. ind_type$BOTTOM))
                          a) ∨
                     (∃a.
                        a0 =
                        (λa.
                           ind_type$CONSTR (SUC 0) a (λn. ind_type$BOTTOM))
                          a) ⇒
                     'bit0' a0) ⇒
                  'bit0' a0) rep

   [<a name="bit0_case_def-val"><b>bit0_case_def</b></a>]  Definition

      |- (∀a f f1. bit0_CASE (BIT0A a) f f1 = f a) ∧
         ∀a f f1. bit0_CASE (BIT0B a) f f1 = f1 a

   [<a name="bit0_size_def-val"><b>bit0_size_def</b></a>]  Definition

      |- (∀f a. bit0_size f (BIT0A a) = 1 + f a) ∧
         ∀f a. bit0_size f (BIT0B a) = 1 + f a

   [<a name="bit1_TY_DEF-val"><b>bit1_TY_DEF</b></a>]  Definition

      |- ∃rep.
           TYPE_DEFINITION
             (λa0.
                ∀'bit1' .
                  (∀a0.
                     (∃a.
                        a0 =
                        (λa. ind_type$CONSTR 0 a (λn. ind_type$BOTTOM))
                          a) ∨
                     (∃a.
                        a0 =
                        (λa.
                           ind_type$CONSTR (SUC 0) a (λn. ind_type$BOTTOM))
                          a) ∨
                     (a0 =
                      ind_type$CONSTR (SUC (SUC 0)) ARB
                        (λn. ind_type$BOTTOM)) ⇒
                     'bit1' a0) ⇒
                  'bit1' a0) rep

   [<a name="bit1_case_def-val"><b>bit1_case_def</b></a>]  Definition

      |- (∀a f f1 v. bit1_CASE (BIT1A a) f f1 v = f a) ∧
         (∀a f f1 v. bit1_CASE (BIT1B a) f f1 v = f1 a) ∧
         ∀f f1 v. bit1_CASE BIT1C f f1 v = v

   [<a name="bit1_size_def-val"><b>bit1_size_def</b></a>]  Definition

      |- (∀f a. bit1_size f (BIT1A a) = 1 + f a) ∧
         (∀f a. bit1_size f (BIT1B a) = 1 + f a) ∧
         ∀f. bit1_size f BIT1C = 0

   [<a name="cart_TY_DEF-val"><b>cart_TY_DEF</b></a>]  Definition

      |- ∃rep. TYPE_DEFINITION (λf. T) rep

   [<a name="cart_tybij-val"><b>cart_tybij</b></a>]  Definition

      |- (∀a. mk_cart (dest_cart a) = a) ∧
         ∀r. (λf. T) r ⇔ (dest_cart (mk_cart r) = r)

   [<a name="dimindex_def-val"><b>dimindex_def</b></a>]  Definition

      |- dimindex (:α) = if FINITE 𝕌(:α) then CARD 𝕌(:α) else 1

   [<a name="fcp_case_def-val"><b>fcp_case_def</b></a>]  Definition

      |- ∀h f. fcp_CASE (mk_cart h) f = f h

   [<a name="fcp_index-val"><b>fcp_index</b></a>]  Definition

      |- ∀x i. x ' i = dest_cart x (finite_index i)

   [<a name="finite_image_TY_DEF-val"><b>finite_image_TY_DEF</b></a>]  Definition

      |- ∃rep. TYPE_DEFINITION (λx. (x = ARB) ∨ FINITE 𝕌(:α)) rep

   [<a name="finite_image_tybij-val"><b>finite_image_tybij</b></a>]  Definition

      |- (∀a. mk_finite_image (dest_finite_image a) = a) ∧
         ∀r.
           (λx. (x = ARB) ∨ FINITE 𝕌(:α)) r ⇔
           (dest_finite_image (mk_finite_image r) = r)

   [<a name="finite_index_def-val"><b>finite_index_def</b></a>]  Definition

      |- finite_index = @f. ∀x. ∃!n. n &lt; dimindex (:α) ∧ (f n = x)

   [<a name="APPLY_FCP_UPDATE_ID-val"><b>APPLY_FCP_UPDATE_ID</b></a>]  Theorem

      |- ∀m a. (a :+ m ' a) m = m

   [<a name="CART_EQ-val"><b>CART_EQ</b></a>]  Theorem

      |- ∀x y. (x = y) ⇔ ∀i. i &lt; dimindex (:β) ⇒ (x ' i = y ' i)

   [<a name="DIMINDEX_GE_1-val"><b>DIMINDEX_GE_1</b></a>]  Theorem

      |- 1 ≤ dimindex (:α)

   [<a name="EL_V2L-val"><b>EL_V2L</b></a>]  Theorem

      |- ∀i v. i &lt; dimindex (:β) ⇒ (EL i (V2L v) = v ' i)

   [<a name="FCP_APPLY_UPDATE_THM-val"><b>FCP_APPLY_UPDATE_THM</b></a>]  Theorem

      |- ∀m a w b.
           (a :+ w) m ' b =
           if b &lt; dimindex (:β) then if a = b then w else m ' b
           else FAIL $' index out of range ((a :+ w) m) b

   [<a name="FCP_BETA-val"><b>FCP_BETA</b></a>]  Theorem

      |- ∀i. i &lt; dimindex (:β) ⇒ ($FCP g ' i = g i)

   [<a name="FCP_CONS-val"><b>FCP_CONS</b></a>]  Theorem

      |- ∀a v. FCP_CONS a v = L2V (a::V2L v)

   [<a name="FCP_ETA-val"><b>FCP_ETA</b></a>]  Theorem

      |- ∀g. (FCP i. g ' i) = g

   [<a name="FCP_EVERY-val"><b>FCP_EVERY</b></a>]  Theorem

      |- ∀P v. FCP_EVERY P v ⇔ EVERY P (V2L v)

   [<a name="FCP_EXISTS-val"><b>FCP_EXISTS</b></a>]  Theorem

      |- ∀P v. FCP_EXISTS P v ⇔ EXISTS P (V2L v)

   [<a name="FCP_HD-val"><b>FCP_HD</b></a>]  Theorem

      |- ∀v. FCP_HD v = HD (V2L v)

   [<a name="FCP_MAP-val"><b>FCP_MAP</b></a>]  Theorem

      |- ∀f v. FCP_MAP f v = L2V (MAP f (V2L v))

   [<a name="FCP_TL-val"><b>FCP_TL</b></a>]  Theorem

      |- ∀v.
           1 &lt; dimindex (:β) ∧ (dimindex (:γ) = dimindex (:β) − 1) ⇒
           (FCP_TL v = L2V (TL (V2L v)))

   [<a name="FCP_UNIQUE-val"><b>FCP_UNIQUE</b></a>]  Theorem

      |- ∀f g. (∀i. i &lt; dimindex (:β) ⇒ (f ' i = g i)) ⇔ ($FCP g = f)

   [<a name="FCP_UPDATE_COMMUTES-val"><b>FCP_UPDATE_COMMUTES</b></a>]  Theorem

      |- ∀m a b c d.
           a ≠ b ⇒ ((a :+ c) ((b :+ d) m) = (b :+ d) ((a :+ c) m))

   [<a name="FCP_UPDATE_EQ-val"><b>FCP_UPDATE_EQ</b></a>]  Theorem

      |- ∀m a b c. (a :+ c) ((a :+ b) m) = (a :+ c) m

   [<a name="FCP_UPDATE_IMP_ID-val"><b>FCP_UPDATE_IMP_ID</b></a>]  Theorem

      |- ∀m a v. (m ' a = v) ⇒ ((a :+ v) m = m)

   [<a name="LENGTH_V2L-val"><b>LENGTH_V2L</b></a>]  Theorem

      |- ∀v. LENGTH (V2L v) = dimindex (:β)

   [<a name="NOT_FINITE_IMP_dimindex_1-val"><b>NOT_FINITE_IMP_dimindex_1</b></a>]  Theorem

      |- INFINITE 𝕌(:α) ⇒ (dimindex (:α) = 1)

   [<a name="NULL_V2L-val"><b>NULL_V2L</b></a>]  Theorem

      |- ∀v. ¬NULL (V2L v)

   [<a name="READ_L2V-val"><b>READ_L2V</b></a>]  Theorem

      |- ∀i a. i &lt; dimindex (:β) ⇒ (L2V a ' i = EL i a)

   [<a name="READ_TL-val"><b>READ_TL</b></a>]  Theorem

      |- ∀i a. i &lt; dimindex (:β) ⇒ (FCP_TL a ' i = a ' (SUC i))

   [<a name="V2L_L2V-val"><b>V2L_L2V</b></a>]  Theorem

      |- ∀x. (dimindex (:β) = LENGTH x) ⇒ (V2L (L2V x) = x)

   [<a name="bit0_11-val"><b>bit0_11</b></a>]  Theorem

      |- (∀a a'. (BIT0A a = BIT0A a') ⇔ (a = a')) ∧
         ∀a a'. (BIT0B a = BIT0B a') ⇔ (a = a')

   [<a name="bit0_Axiom-val"><b>bit0_Axiom</b></a>]  Theorem

      |- ∀f0 f1. ∃fn. (∀a. fn (BIT0A a) = f0 a) ∧ ∀a. fn (BIT0B a) = f1 a

   [<a name="bit0_case_cong-val"><b>bit0_case_cong</b></a>]  Theorem

      |- ∀M M' f f1.
           (M = M') ∧ (∀a. (M' = BIT0A a) ⇒ (f a = f' a)) ∧
           (∀a. (M' = BIT0B a) ⇒ (f1 a = f1' a)) ⇒
           (bit0_CASE M f f1 = bit0_CASE M' f' f1')

   [<a name="bit0_distinct-val"><b>bit0_distinct</b></a>]  Theorem

      |- ∀a' a. BIT0A a ≠ BIT0B a'

   [<a name="bit0_induction-val"><b>bit0_induction</b></a>]  Theorem

      |- ∀P. (∀a. P (BIT0A a)) ∧ (∀a. P (BIT0B a)) ⇒ ∀b. P b

   [<a name="bit0_nchotomy-val"><b>bit0_nchotomy</b></a>]  Theorem

      |- ∀bb. (∃a. bb = BIT0A a) ∨ ∃a. bb = BIT0B a

   [<a name="bit1_11-val"><b>bit1_11</b></a>]  Theorem

      |- (∀a a'. (BIT1A a = BIT1A a') ⇔ (a = a')) ∧
         ∀a a'. (BIT1B a = BIT1B a') ⇔ (a = a')

   [<a name="bit1_Axiom-val"><b>bit1_Axiom</b></a>]  Theorem

      |- ∀f0 f1 f2.
           ∃fn.
             (∀a. fn (BIT1A a) = f0 a) ∧ (∀a. fn (BIT1B a) = f1 a) ∧
             (fn BIT1C = f2)

   [<a name="bit1_case_cong-val"><b>bit1_case_cong</b></a>]  Theorem

      |- ∀M M' f f1 v.
           (M = M') ∧ (∀a. (M' = BIT1A a) ⇒ (f a = f' a)) ∧
           (∀a. (M' = BIT1B a) ⇒ (f1 a = f1' a)) ∧
           ((M' = BIT1C) ⇒ (v = v')) ⇒
           (bit1_CASE M f f1 v = bit1_CASE M' f' f1' v')

   [<a name="bit1_distinct-val"><b>bit1_distinct</b></a>]  Theorem

      |- (∀a' a. BIT1A a ≠ BIT1B a') ∧ (∀a. BIT1A a ≠ BIT1C) ∧
         ∀a. BIT1B a ≠ BIT1C

   [<a name="bit1_induction-val"><b>bit1_induction</b></a>]  Theorem

      |- ∀P. (∀a. P (BIT1A a)) ∧ (∀a. P (BIT1B a)) ∧ P BIT1C ⇒ ∀b. P b

   [<a name="bit1_nchotomy-val"><b>bit1_nchotomy</b></a>]  Theorem

      |- ∀bb. (∃a. bb = BIT1A a) ∨ (∃a. bb = BIT1B a) ∨ (bb = BIT1C)

   [<a name="card_dimindex-val"><b>card_dimindex</b></a>]  Theorem

      |- FINITE 𝕌(:α) ⇒ (CARD 𝕌(:α) = dimindex (:α))

   [<a name="datatype_bit0-val"><b>datatype_bit0</b></a>]  Theorem

      |- DATATYPE (bit0 BIT0A BIT0B)

   [<a name="datatype_bit1-val"><b>datatype_bit1</b></a>]  Theorem

      |- DATATYPE (bit1 BIT1A BIT1B BIT1C)

   [<a name="fcp_Axiom-val"><b>fcp_Axiom</b></a>]  Theorem

      |- ∀f. ∃g. ∀h. g (mk_cart h) = f h

   [<a name="fcp_ind-val"><b>fcp_ind</b></a>]  Theorem

      |- ∀P. (∀f. P (mk_cart f)) ⇒ ∀a. P a

   [<a name="fcp_subst_comp-val"><b>fcp_subst_comp</b></a>]  Theorem

      |- ∀a b f. (x :+ y) ($FCP f) = FCP c. if x = c then y else f c

   [<a name="finite_bit0-val"><b>finite_bit0</b></a>]  Theorem

      |- FINITE 𝕌(:α bit0) ⇔ FINITE 𝕌(:α)

   [<a name="finite_bit1-val"><b>finite_bit1</b></a>]  Theorem

      |- FINITE 𝕌(:α bit1) ⇔ FINITE 𝕌(:α)

   [<a name="finite_one-val"><b>finite_one</b></a>]  Theorem

      |- FINITE 𝕌(:unit)

   [<a name="finite_sum-val"><b>finite_sum</b></a>]  Theorem

      |- FINITE 𝕌(:α + β) ⇔ FINITE 𝕌(:α) ∧ FINITE 𝕌(:β)

   [<a name="index_bit0-val"><b>index_bit0</b></a>]  Theorem

      |- dimindex (:α bit0) = if FINITE 𝕌(:α) then 2 * dimindex (:α) else 1

   [<a name="index_bit1-val"><b>index_bit1</b></a>]  Theorem

      |- dimindex (:α bit1) =
         if FINITE 𝕌(:α) then 2 * dimindex (:α) + 1 else 1

   [<a name="index_comp-val"><b>index_comp</b></a>]  Theorem

      |- ∀f n.
           $FCP f ' n =
           if n &lt; dimindex (:β) then f n
           else FAIL $' FCP out of bounds ($FCP f) n

   [<a name="index_one-val"><b>index_one</b></a>]  Theorem

      |- dimindex (:unit) = 1

   [<a name="index_sum-val"><b>index_sum</b></a>]  Theorem

      |- dimindex (:α + β) =
         if FINITE 𝕌(:α) ∧ FINITE 𝕌(:β) then dimindex (:α) + dimindex (:β)
         else 1


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/n-bit/fcpScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-10</a></em></p></body></html>
