<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure complexTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure complexTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/complex/complexScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature complexTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#IM-val">IM</a> : thm
<a name="line7"></a>    val <a href="#RE-val">RE</a> : thm
<a name="line8"></a>    val <a href="#arg-val">arg</a> : thm
<a name="line9"></a>    val <a href="#complex_add-val">complex_add</a> : thm
<a name="line10"></a>    val <a href="#complex_div-val">complex_div</a> : thm
<a name="line11"></a>    val <a href="#complex_exp-val">complex_exp</a> : thm
<a name="line12"></a>    val <a href="#complex_inv-val">complex_inv</a> : thm
<a name="line13"></a>    val <a href="#complex_mul-val">complex_mul</a> : thm
<a name="line14"></a>    val <a href="#complex_neg-val">complex_neg</a> : thm
<a name="line15"></a>    val <a href="#complex_of_num-val">complex_of_num</a> : thm
<a name="line16"></a>    val <a href="#complex_of_real-val">complex_of_real</a> : thm
<a name="line17"></a>    val <a href="#complex_pow_def-val">complex_pow_def</a> : thm
<a name="line18"></a>    val <a href="#complex_scalar_lmul-val">complex_scalar_lmul</a> : thm
<a name="line19"></a>    val <a href="#complex_scalar_rmul-val">complex_scalar_rmul</a> : thm
<a name="line20"></a>    val <a href="#complex_sub-val">complex_sub</a> : thm
<a name="line21"></a>    val <a href="#conj-val">conj</a> : thm
<a name="line22"></a>    val <a href="#i-val">i</a> : thm
<a name="line23"></a>    val <a href="#modu-val">modu</a> : thm
<a name="line24"></a>
<a name="line25"></a>  (*  Theorems  *)
<a name="line26"></a>    val <a href="#ARG_COS-val">ARG_COS</a> : thm
<a name="line27"></a>    val <a href="#ARG_SIN-val">ARG_SIN</a> : thm
<a name="line28"></a>    val <a href="#COMPLEX-val">COMPLEX</a> : thm
<a name="line29"></a>    val <a href="#COMPLEX_0-val">COMPLEX_0</a> : thm
<a name="line30"></a>    val <a href="#COMPLEX_0_THM-val">COMPLEX_0_THM</a> : thm
<a name="line31"></a>    val <a href="#COMPLEX_1-val">COMPLEX_1</a> : thm
<a name="line32"></a>    val <a href="#COMPLEX_10-val">COMPLEX_10</a> : thm
<a name="line33"></a>    val <a href="#COMPLEX_ADD2_SUB2-val">COMPLEX_ADD2_SUB2</a> : thm
<a name="line34"></a>    val <a href="#COMPLEX_ADD_ASSOC-val">COMPLEX_ADD_ASSOC</a> : thm
<a name="line35"></a>    val <a href="#COMPLEX_ADD_COMM-val">COMPLEX_ADD_COMM</a> : thm
<a name="line36"></a>    val <a href="#COMPLEX_ADD_LDISTRIB-val">COMPLEX_ADD_LDISTRIB</a> : thm
<a name="line37"></a>    val <a href="#COMPLEX_ADD_LID-val">COMPLEX_ADD_LID</a> : thm
<a name="line38"></a>    val <a href="#COMPLEX_ADD_LID_UNIQ-val">COMPLEX_ADD_LID_UNIQ</a> : thm
<a name="line39"></a>    val <a href="#COMPLEX_ADD_LINV-val">COMPLEX_ADD_LINV</a> : thm
<a name="line40"></a>    val <a href="#COMPLEX_ADD_RAT-val">COMPLEX_ADD_RAT</a> : thm
<a name="line41"></a>    val <a href="#COMPLEX_ADD_RDISTRIB-val">COMPLEX_ADD_RDISTRIB</a> : thm
<a name="line42"></a>    val <a href="#COMPLEX_ADD_RID-val">COMPLEX_ADD_RID</a> : thm
<a name="line43"></a>    val <a href="#COMPLEX_ADD_RID_UNIQ-val">COMPLEX_ADD_RID_UNIQ</a> : thm
<a name="line44"></a>    val <a href="#COMPLEX_ADD_RINV-val">COMPLEX_ADD_RINV</a> : thm
<a name="line45"></a>    val <a href="#COMPLEX_ADD_RSCALAR_RMUL-val">COMPLEX_ADD_RSCALAR_RMUL</a> : thm
<a name="line46"></a>    val <a href="#COMPLEX_ADD_SCALAR_LMUL-val">COMPLEX_ADD_SCALAR_LMUL</a> : thm
<a name="line47"></a>    val <a href="#COMPLEX_ADD_SUB-val">COMPLEX_ADD_SUB</a> : thm
<a name="line48"></a>    val <a href="#COMPLEX_ADD_SUB2-val">COMPLEX_ADD_SUB2</a> : thm
<a name="line49"></a>    val <a href="#COMPLEX_DIFFSQ-val">COMPLEX_DIFFSQ</a> : thm
<a name="line50"></a>    val <a href="#COMPLEX_DIV1-val">COMPLEX_DIV1</a> : thm
<a name="line51"></a>    val <a href="#COMPLEX_DIV_ADD-val">COMPLEX_DIV_ADD</a> : thm
<a name="line52"></a>    val <a href="#COMPLEX_DIV_ARG-val">COMPLEX_DIV_ARG</a> : thm
<a name="line53"></a>    val <a href="#COMPLEX_DIV_DENOM_CANCEL-val">COMPLEX_DIV_DENOM_CANCEL</a> : thm
<a name="line54"></a>    val <a href="#COMPLEX_DIV_INNER_CANCEL-val">COMPLEX_DIV_INNER_CANCEL</a> : thm
<a name="line55"></a>    val <a href="#COMPLEX_DIV_LMUL_CANCEL-val">COMPLEX_DIV_LMUL_CANCEL</a> : thm
<a name="line56"></a>    val <a href="#COMPLEX_DIV_LZERO-val">COMPLEX_DIV_LZERO</a> : thm
<a name="line57"></a>    val <a href="#COMPLEX_DIV_MUL2-val">COMPLEX_DIV_MUL2</a> : thm
<a name="line58"></a>    val <a href="#COMPLEX_DIV_OUTER_CANCEL-val">COMPLEX_DIV_OUTER_CANCEL</a> : thm
<a name="line59"></a>    val <a href="#COMPLEX_DIV_REFL-val">COMPLEX_DIV_REFL</a> : thm
<a name="line60"></a>    val <a href="#COMPLEX_DIV_RMUL_CANCEL-val">COMPLEX_DIV_RMUL_CANCEL</a> : thm
<a name="line61"></a>    val <a href="#COMPLEX_DIV_SUB-val">COMPLEX_DIV_SUB</a> : thm
<a name="line62"></a>    val <a href="#COMPLEX_DOUBLE-val">COMPLEX_DOUBLE</a> : thm
<a name="line63"></a>    val <a href="#COMPLEX_ENTIRE-val">COMPLEX_ENTIRE</a> : thm
<a name="line64"></a>    val <a href="#COMPLEX_EQ_LADD-val">COMPLEX_EQ_LADD</a> : thm
<a name="line65"></a>    val <a href="#COMPLEX_EQ_LDIV_EQ-val">COMPLEX_EQ_LDIV_EQ</a> : thm
<a name="line66"></a>    val <a href="#COMPLEX_EQ_LMUL-val">COMPLEX_EQ_LMUL</a> : thm
<a name="line67"></a>    val <a href="#COMPLEX_EQ_LMUL2-val">COMPLEX_EQ_LMUL2</a> : thm
<a name="line68"></a>    val <a href="#COMPLEX_EQ_LMUL_IMP-val">COMPLEX_EQ_LMUL_IMP</a> : thm
<a name="line69"></a>    val <a href="#COMPLEX_EQ_NEG-val">COMPLEX_EQ_NEG</a> : thm
<a name="line70"></a>    val <a href="#COMPLEX_EQ_RADD-val">COMPLEX_EQ_RADD</a> : thm
<a name="line71"></a>    val <a href="#COMPLEX_EQ_RDIV_EQ-val">COMPLEX_EQ_RDIV_EQ</a> : thm
<a name="line72"></a>    val <a href="#COMPLEX_EQ_RMUL-val">COMPLEX_EQ_RMUL</a> : thm
<a name="line73"></a>    val <a href="#COMPLEX_EQ_RMUL_IMP-val">COMPLEX_EQ_RMUL_IMP</a> : thm
<a name="line74"></a>    val <a href="#COMPLEX_EQ_SCALAR_LMUL-val">COMPLEX_EQ_SCALAR_LMUL</a> : thm
<a name="line75"></a>    val <a href="#COMPLEX_EQ_SUB_LADD-val">COMPLEX_EQ_SUB_LADD</a> : thm
<a name="line76"></a>    val <a href="#COMPLEX_EQ_SUB_RADD-val">COMPLEX_EQ_SUB_RADD</a> : thm
<a name="line77"></a>    val <a href="#COMPLEX_EXP_0-val">COMPLEX_EXP_0</a> : thm
<a name="line78"></a>    val <a href="#COMPLEX_EXP_ADD-val">COMPLEX_EXP_ADD</a> : thm
<a name="line79"></a>    val <a href="#COMPLEX_EXP_ADD_MUL-val">COMPLEX_EXP_ADD_MUL</a> : thm
<a name="line80"></a>    val <a href="#COMPLEX_EXP_N-val">COMPLEX_EXP_N</a> : thm
<a name="line81"></a>    val <a href="#COMPLEX_EXP_N2-val">COMPLEX_EXP_N2</a> : thm
<a name="line82"></a>    val <a href="#COMPLEX_EXP_NEG-val">COMPLEX_EXP_NEG</a> : thm
<a name="line83"></a>    val <a href="#COMPLEX_EXP_NEG_MUL-val">COMPLEX_EXP_NEG_MUL</a> : thm
<a name="line84"></a>    val <a href="#COMPLEX_EXP_NEG_MUL2-val">COMPLEX_EXP_NEG_MUL2</a> : thm
<a name="line85"></a>    val <a href="#COMPLEX_EXP_NZ-val">COMPLEX_EXP_NZ</a> : thm
<a name="line86"></a>    val <a href="#COMPLEX_EXP_SUB-val">COMPLEX_EXP_SUB</a> : thm
<a name="line87"></a>    val <a href="#COMPLEX_INV1-val">COMPLEX_INV1</a> : thm
<a name="line88"></a>    val <a href="#COMPLEX_INVINV-val">COMPLEX_INVINV</a> : thm
<a name="line89"></a>    val <a href="#COMPLEX_INV_0-val">COMPLEX_INV_0</a> : thm
<a name="line90"></a>    val <a href="#COMPLEX_INV_1OVER-val">COMPLEX_INV_1OVER</a> : thm
<a name="line91"></a>    val <a href="#COMPLEX_INV_ARG-val">COMPLEX_INV_ARG</a> : thm
<a name="line92"></a>    val <a href="#COMPLEX_INV_EQ_0-val">COMPLEX_INV_EQ_0</a> : thm
<a name="line93"></a>    val <a href="#COMPLEX_INV_INJ-val">COMPLEX_INV_INJ</a> : thm
<a name="line94"></a>    val <a href="#COMPLEX_INV_INV-val">COMPLEX_INV_INV</a> : thm
<a name="line95"></a>    val <a href="#COMPLEX_INV_MUL-val">COMPLEX_INV_MUL</a> : thm
<a name="line96"></a>    val <a href="#COMPLEX_INV_NEG-val">COMPLEX_INV_NEG</a> : thm
<a name="line97"></a>    val <a href="#COMPLEX_INV_NZ-val">COMPLEX_INV_NZ</a> : thm
<a name="line98"></a>    val <a href="#COMPLEX_INV_SCALAR_LMUL-val">COMPLEX_INV_SCALAR_LMUL</a> : thm
<a name="line99"></a>    val <a href="#COMPLEX_LEMMA1-val">COMPLEX_LEMMA1</a> : thm
<a name="line100"></a>    val <a href="#COMPLEX_LEMMA2-val">COMPLEX_LEMMA2</a> : thm
<a name="line101"></a>    val <a href="#COMPLEX_LINV_UNIQ-val">COMPLEX_LINV_UNIQ</a> : thm
<a name="line102"></a>    val <a href="#COMPLEX_LMUL_SCALAR_LMUL-val">COMPLEX_LMUL_SCALAR_LMUL</a> : thm
<a name="line103"></a>    val <a href="#COMPLEX_LNEG_UNIQ-val">COMPLEX_LNEG_UNIQ</a> : thm
<a name="line104"></a>    val <a href="#COMPLEX_MODU_ARG_EQ-val">COMPLEX_MODU_ARG_EQ</a> : thm
<a name="line105"></a>    val <a href="#COMPLEX_MUL_ARG-val">COMPLEX_MUL_ARG</a> : thm
<a name="line106"></a>    val <a href="#COMPLEX_MUL_ASSOC-val">COMPLEX_MUL_ASSOC</a> : thm
<a name="line107"></a>    val <a href="#COMPLEX_MUL_COMM-val">COMPLEX_MUL_COMM</a> : thm
<a name="line108"></a>    val <a href="#COMPLEX_MUL_LCONJ1-val">COMPLEX_MUL_LCONJ1</a> : thm
<a name="line109"></a>    val <a href="#COMPLEX_MUL_LID-val">COMPLEX_MUL_LID</a> : thm
<a name="line110"></a>    val <a href="#COMPLEX_MUL_LINV-val">COMPLEX_MUL_LINV</a> : thm
<a name="line111"></a>    val <a href="#COMPLEX_MUL_LNEG-val">COMPLEX_MUL_LNEG</a> : thm
<a name="line112"></a>    val <a href="#COMPLEX_MUL_LZERO-val">COMPLEX_MUL_LZERO</a> : thm
<a name="line113"></a>    val <a href="#COMPLEX_MUL_RCONJ-val">COMPLEX_MUL_RCONJ</a> : thm
<a name="line114"></a>    val <a href="#COMPLEX_MUL_RCONJ1-val">COMPLEX_MUL_RCONJ1</a> : thm
<a name="line115"></a>    val <a href="#COMPLEX_MUL_RID-val">COMPLEX_MUL_RID</a> : thm
<a name="line116"></a>    val <a href="#COMPLEX_MUL_RINV-val">COMPLEX_MUL_RINV</a> : thm
<a name="line117"></a>    val <a href="#COMPLEX_MUL_RNEG-val">COMPLEX_MUL_RNEG</a> : thm
<a name="line118"></a>    val <a href="#COMPLEX_MUL_RZERO-val">COMPLEX_MUL_RZERO</a> : thm
<a name="line119"></a>    val <a href="#COMPLEX_MUL_SCALAR_LMUL2-val">COMPLEX_MUL_SCALAR_LMUL2</a> : thm
<a name="line120"></a>    val <a href="#COMPLEX_NEGNEG-val">COMPLEX_NEGNEG</a> : thm
<a name="line121"></a>    val <a href="#COMPLEX_NEG_0-val">COMPLEX_NEG_0</a> : thm
<a name="line122"></a>    val <a href="#COMPLEX_NEG_ADD-val">COMPLEX_NEG_ADD</a> : thm
<a name="line123"></a>    val <a href="#COMPLEX_NEG_DIV2-val">COMPLEX_NEG_DIV2</a> : thm
<a name="line124"></a>    val <a href="#COMPLEX_NEG_EQ-val">COMPLEX_NEG_EQ</a> : thm
<a name="line125"></a>    val <a href="#COMPLEX_NEG_EQ0-val">COMPLEX_NEG_EQ0</a> : thm
<a name="line126"></a>    val <a href="#COMPLEX_NEG_INV-val">COMPLEX_NEG_INV</a> : thm
<a name="line127"></a>    val <a href="#COMPLEX_NEG_LDIV-val">COMPLEX_NEG_LDIV</a> : thm
<a name="line128"></a>    val <a href="#COMPLEX_NEG_LMUL-val">COMPLEX_NEG_LMUL</a> : thm
<a name="line129"></a>    val <a href="#COMPLEX_NEG_MUL2-val">COMPLEX_NEG_MUL2</a> : thm
<a name="line130"></a>    val <a href="#COMPLEX_NEG_RDIV-val">COMPLEX_NEG_RDIV</a> : thm
<a name="line131"></a>    val <a href="#COMPLEX_NEG_RMUL-val">COMPLEX_NEG_RMUL</a> : thm
<a name="line132"></a>    val <a href="#COMPLEX_NEG_SCALAR_LMUL-val">COMPLEX_NEG_SCALAR_LMUL</a> : thm
<a name="line133"></a>    val <a href="#COMPLEX_NEG_SCALAR_RMUL-val">COMPLEX_NEG_SCALAR_RMUL</a> : thm
<a name="line134"></a>    val <a href="#COMPLEX_NEG_SUB-val">COMPLEX_NEG_SUB</a> : thm
<a name="line135"></a>    val <a href="#COMPLEX_OF_NUM_ADD-val">COMPLEX_OF_NUM_ADD</a> : thm
<a name="line136"></a>    val <a href="#COMPLEX_OF_NUM_EQ-val">COMPLEX_OF_NUM_EQ</a> : thm
<a name="line137"></a>    val <a href="#COMPLEX_OF_NUM_MUL-val">COMPLEX_OF_NUM_MUL</a> : thm
<a name="line138"></a>    val <a href="#COMPLEX_OF_REAL_ADD-val">COMPLEX_OF_REAL_ADD</a> : thm
<a name="line139"></a>    val <a href="#COMPLEX_OF_REAL_DIV-val">COMPLEX_OF_REAL_DIV</a> : thm
<a name="line140"></a>    val <a href="#COMPLEX_OF_REAL_EQ-val">COMPLEX_OF_REAL_EQ</a> : thm
<a name="line141"></a>    val <a href="#COMPLEX_OF_REAL_INV-val">COMPLEX_OF_REAL_INV</a> : thm
<a name="line142"></a>    val <a href="#COMPLEX_OF_REAL_MUL-val">COMPLEX_OF_REAL_MUL</a> : thm
<a name="line143"></a>    val <a href="#COMPLEX_OF_REAL_NEG-val">COMPLEX_OF_REAL_NEG</a> : thm
<a name="line144"></a>    val <a href="#COMPLEX_OF_REAL_SUB-val">COMPLEX_OF_REAL_SUB</a> : thm
<a name="line145"></a>    val <a href="#COMPLEX_POWINV-val">COMPLEX_POWINV</a> : thm
<a name="line146"></a>    val <a href="#COMPLEX_POW_0-val">COMPLEX_POW_0</a> : thm
<a name="line147"></a>    val <a href="#COMPLEX_POW_1-val">COMPLEX_POW_1</a> : thm
<a name="line148"></a>    val <a href="#COMPLEX_POW_2-val">COMPLEX_POW_2</a> : thm
<a name="line149"></a>    val <a href="#COMPLEX_POW_ADD-val">COMPLEX_POW_ADD</a> : thm
<a name="line150"></a>    val <a href="#COMPLEX_POW_DIV-val">COMPLEX_POW_DIV</a> : thm
<a name="line151"></a>    val <a href="#COMPLEX_POW_INV-val">COMPLEX_POW_INV</a> : thm
<a name="line152"></a>    val <a href="#COMPLEX_POW_L-val">COMPLEX_POW_L</a> : thm
<a name="line153"></a>    val <a href="#COMPLEX_POW_MUL-val">COMPLEX_POW_MUL</a> : thm
<a name="line154"></a>    val <a href="#COMPLEX_POW_NZ-val">COMPLEX_POW_NZ</a> : thm
<a name="line155"></a>    val <a href="#COMPLEX_POW_ONE-val">COMPLEX_POW_ONE</a> : thm
<a name="line156"></a>    val <a href="#COMPLEX_POW_POW-val">COMPLEX_POW_POW</a> : thm
<a name="line157"></a>    val <a href="#COMPLEX_POW_ZERO-val">COMPLEX_POW_ZERO</a> : thm
<a name="line158"></a>    val <a href="#COMPLEX_POW_ZERO_EQ-val">COMPLEX_POW_ZERO_EQ</a> : thm
<a name="line159"></a>    val <a href="#COMPLEX_RE_IM_EQ-val">COMPLEX_RE_IM_EQ</a> : thm
<a name="line160"></a>    val <a href="#COMPLEX_RINV_UNIQ-val">COMPLEX_RINV_UNIQ</a> : thm
<a name="line161"></a>    val <a href="#COMPLEX_RMUL_SCALAR_LMUL-val">COMPLEX_RMUL_SCALAR_LMUL</a> : thm
<a name="line162"></a>    val <a href="#COMPLEX_RNEG_UNIQ-val">COMPLEX_RNEG_UNIQ</a> : thm
<a name="line163"></a>    val <a href="#COMPLEX_RSCALAR_RMUL_SUB-val">COMPLEX_RSCALAR_RMUL_SUB</a> : thm
<a name="line164"></a>    val <a href="#COMPLEX_SCALAR_LMUL-val">COMPLEX_SCALAR_LMUL</a> : thm
<a name="line165"></a>    val <a href="#COMPLEX_SCALAR_LMUL_ADD-val">COMPLEX_SCALAR_LMUL_ADD</a> : thm
<a name="line166"></a>    val <a href="#COMPLEX_SCALAR_LMUL_DIV2-val">COMPLEX_SCALAR_LMUL_DIV2</a> : thm
<a name="line167"></a>    val <a href="#COMPLEX_SCALAR_LMUL_ENTIRE-val">COMPLEX_SCALAR_LMUL_ENTIRE</a> : thm
<a name="line168"></a>    val <a href="#COMPLEX_SCALAR_LMUL_EQ-val">COMPLEX_SCALAR_LMUL_EQ</a> : thm
<a name="line169"></a>    val <a href="#COMPLEX_SCALAR_LMUL_EQ1-val">COMPLEX_SCALAR_LMUL_EQ1</a> : thm
<a name="line170"></a>    val <a href="#COMPLEX_SCALAR_LMUL_NEG-val">COMPLEX_SCALAR_LMUL_NEG</a> : thm
<a name="line171"></a>    val <a href="#COMPLEX_SCALAR_LMUL_NEG1-val">COMPLEX_SCALAR_LMUL_NEG1</a> : thm
<a name="line172"></a>    val <a href="#COMPLEX_SCALAR_LMUL_ONE-val">COMPLEX_SCALAR_LMUL_ONE</a> : thm
<a name="line173"></a>    val <a href="#COMPLEX_SCALAR_LMUL_SUB-val">COMPLEX_SCALAR_LMUL_SUB</a> : thm
<a name="line174"></a>    val <a href="#COMPLEX_SCALAR_LMUL_ZERO-val">COMPLEX_SCALAR_LMUL_ZERO</a> : thm
<a name="line175"></a>    val <a href="#COMPLEX_SCALAR_MUL_COMM-val">COMPLEX_SCALAR_MUL_COMM</a> : thm
<a name="line176"></a>    val <a href="#COMPLEX_SCALAR_RMUL-val">COMPLEX_SCALAR_RMUL</a> : thm
<a name="line177"></a>    val <a href="#COMPLEX_SCALAR_RMUL_ADD-val">COMPLEX_SCALAR_RMUL_ADD</a> : thm
<a name="line178"></a>    val <a href="#COMPLEX_SCALAR_RMUL_NEG-val">COMPLEX_SCALAR_RMUL_NEG</a> : thm
<a name="line179"></a>    val <a href="#COMPLEX_SCALAR_RMUL_NEG1-val">COMPLEX_SCALAR_RMUL_NEG1</a> : thm
<a name="line180"></a>    val <a href="#COMPLEX_SCALAR_RMUL_ONE-val">COMPLEX_SCALAR_RMUL_ONE</a> : thm
<a name="line181"></a>    val <a href="#COMPLEX_SCALAR_RMUL_ZERO-val">COMPLEX_SCALAR_RMUL_ZERO</a> : thm
<a name="line182"></a>    val <a href="#COMPLEX_SUB_0-val">COMPLEX_SUB_0</a> : thm
<a name="line183"></a>    val <a href="#COMPLEX_SUB_ADD-val">COMPLEX_SUB_ADD</a> : thm
<a name="line184"></a>    val <a href="#COMPLEX_SUB_ADD2-val">COMPLEX_SUB_ADD2</a> : thm
<a name="line185"></a>    val <a href="#COMPLEX_SUB_INV2-val">COMPLEX_SUB_INV2</a> : thm
<a name="line186"></a>    val <a href="#COMPLEX_SUB_LDISTRIB-val">COMPLEX_SUB_LDISTRIB</a> : thm
<a name="line187"></a>    val <a href="#COMPLEX_SUB_LNEG-val">COMPLEX_SUB_LNEG</a> : thm
<a name="line188"></a>    val <a href="#COMPLEX_SUB_LZERO-val">COMPLEX_SUB_LZERO</a> : thm
<a name="line189"></a>    val <a href="#COMPLEX_SUB_NEG2-val">COMPLEX_SUB_NEG2</a> : thm
<a name="line190"></a>    val <a href="#COMPLEX_SUB_RAT-val">COMPLEX_SUB_RAT</a> : thm
<a name="line191"></a>    val <a href="#COMPLEX_SUB_RDISTRIB-val">COMPLEX_SUB_RDISTRIB</a> : thm
<a name="line192"></a>    val <a href="#COMPLEX_SUB_REFL-val">COMPLEX_SUB_REFL</a> : thm
<a name="line193"></a>    val <a href="#COMPLEX_SUB_RNEG-val">COMPLEX_SUB_RNEG</a> : thm
<a name="line194"></a>    val <a href="#COMPLEX_SUB_RZERO-val">COMPLEX_SUB_RZERO</a> : thm
<a name="line195"></a>    val <a href="#COMPLEX_SUB_SCALAR_LMUL-val">COMPLEX_SUB_SCALAR_LMUL</a> : thm
<a name="line196"></a>    val <a href="#COMPLEX_SUB_SCALAR_RMUL-val">COMPLEX_SUB_SCALAR_RMUL</a> : thm
<a name="line197"></a>    val <a href="#COMPLEX_SUB_SUB-val">COMPLEX_SUB_SUB</a> : thm
<a name="line198"></a>    val <a href="#COMPLEX_SUB_SUB2-val">COMPLEX_SUB_SUB2</a> : thm
<a name="line199"></a>    val <a href="#COMPLEX_SUB_TRIANGLE-val">COMPLEX_SUB_TRIANGLE</a> : thm
<a name="line200"></a>    val <a href="#COMPLEX_TRIANGLE-val">COMPLEX_TRIANGLE</a> : thm
<a name="line201"></a>    val <a href="#COMPLEX_ZERO_SCALAR_LMUL-val">COMPLEX_ZERO_SCALAR_LMUL</a> : thm
<a name="line202"></a>    val <a href="#COMPLEX_ZERO_SCALAR_RMUL-val">COMPLEX_ZERO_SCALAR_RMUL</a> : thm
<a name="line203"></a>    val <a href="#CONJ_ADD-val">CONJ_ADD</a> : thm
<a name="line204"></a>    val <a href="#CONJ_CONJ-val">CONJ_CONJ</a> : thm
<a name="line205"></a>    val <a href="#CONJ_DIV-val">CONJ_DIV</a> : thm
<a name="line206"></a>    val <a href="#CONJ_EQ-val">CONJ_EQ</a> : thm
<a name="line207"></a>    val <a href="#CONJ_EQ2-val">CONJ_EQ2</a> : thm
<a name="line208"></a>    val <a href="#CONJ_INV-val">CONJ_INV</a> : thm
<a name="line209"></a>    val <a href="#CONJ_MUL-val">CONJ_MUL</a> : thm
<a name="line210"></a>    val <a href="#CONJ_NEG-val">CONJ_NEG</a> : thm
<a name="line211"></a>    val <a href="#CONJ_NUM_REFL-val">CONJ_NUM_REFL</a> : thm
<a name="line212"></a>    val <a href="#CONJ_REAL_REFL-val">CONJ_REAL_REFL</a> : thm
<a name="line213"></a>    val <a href="#CONJ_SCALAR_LMUL-val">CONJ_SCALAR_LMUL</a> : thm
<a name="line214"></a>    val <a href="#CONJ_SUB-val">CONJ_SUB</a> : thm
<a name="line215"></a>    val <a href="#CONJ_ZERO-val">CONJ_ZERO</a> : thm
<a name="line216"></a>    val <a href="#DE_MOIVRE_LEMMA-val">DE_MOIVRE_LEMMA</a> : thm
<a name="line217"></a>    val <a href="#DE_MOIVRE_THM-val">DE_MOIVRE_THM</a> : thm
<a name="line218"></a>    val <a href="#EULER_FORMULE-val">EULER_FORMULE</a> : thm
<a name="line219"></a>    val <a href="#EXP_IMAGINARY-val">EXP_IMAGINARY</a> : thm
<a name="line220"></a>    val <a href="#IM_COMPLEX_OF_REAL-val">IM_COMPLEX_OF_REAL</a> : thm
<a name="line221"></a>    val <a href="#IM_DIV_MODU_ASN_BOUNDS-val">IM_DIV_MODU_ASN_BOUNDS</a> : thm
<a name="line222"></a>    val <a href="#IM_DIV_MODU_ASN_SIN-val">IM_DIV_MODU_ASN_SIN</a> : thm
<a name="line223"></a>    val <a href="#IM_DIV_MODU_BOUNDS-val">IM_DIV_MODU_BOUNDS</a> : thm
<a name="line224"></a>    val <a href="#IM_MODU_ARG-val">IM_MODU_ARG</a> : thm
<a name="line225"></a>    val <a href="#MODU_0-val">MODU_0</a> : thm
<a name="line226"></a>    val <a href="#MODU_1-val">MODU_1</a> : thm
<a name="line227"></a>    val <a href="#MODU_CASES-val">MODU_CASES</a> : thm
<a name="line228"></a>    val <a href="#MODU_COMPLEX_INV-val">MODU_COMPLEX_INV</a> : thm
<a name="line229"></a>    val <a href="#MODU_COMPLEX_POW-val">MODU_COMPLEX_POW</a> : thm
<a name="line230"></a>    val <a href="#MODU_CONJ-val">MODU_CONJ</a> : thm
<a name="line231"></a>    val <a href="#MODU_DIV-val">MODU_DIV</a> : thm
<a name="line232"></a>    val <a href="#MODU_MUL-val">MODU_MUL</a> : thm
<a name="line233"></a>    val <a href="#MODU_NEG-val">MODU_NEG</a> : thm
<a name="line234"></a>    val <a href="#MODU_NUM-val">MODU_NUM</a> : thm
<a name="line235"></a>    val <a href="#MODU_NZ-val">MODU_NZ</a> : thm
<a name="line236"></a>    val <a href="#MODU_POS-val">MODU_POS</a> : thm
<a name="line237"></a>    val <a href="#MODU_POW2-val">MODU_POW2</a> : thm
<a name="line238"></a>    val <a href="#MODU_REAL-val">MODU_REAL</a> : thm
<a name="line239"></a>    val <a href="#MODU_SCALAR_LMUL-val">MODU_SCALAR_LMUL</a> : thm
<a name="line240"></a>    val <a href="#MODU_SUB-val">MODU_SUB</a> : thm
<a name="line241"></a>    val <a href="#MODU_UNIT-val">MODU_UNIT</a> : thm
<a name="line242"></a>    val <a href="#MODU_ZERO-val">MODU_ZERO</a> : thm
<a name="line243"></a>    val <a href="#RE_COMPLEX_OF_REAL-val">RE_COMPLEX_OF_REAL</a> : thm
<a name="line244"></a>    val <a href="#RE_DIV_MODU_ACS_BOUNDS-val">RE_DIV_MODU_ACS_BOUNDS</a> : thm
<a name="line245"></a>    val <a href="#RE_DIV_MODU_ACS_COS-val">RE_DIV_MODU_ACS_COS</a> : thm
<a name="line246"></a>    val <a href="#RE_DIV_MODU_BOUNDS-val">RE_DIV_MODU_BOUNDS</a> : thm
<a name="line247"></a>    val <a href="#RE_IM_LE_MODU-val">RE_IM_LE_MODU</a> : thm
<a name="line248"></a>    val <a href="#RE_MODU_ARG-val">RE_MODU_ARG</a> : thm
<a name="line249"></a>    val <a href="#complex_pow_def_compute-val">complex_pow_def_compute</a> : thm
<a name="line250"></a>
<a name="line251"></a>  val complex_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line252"></a>(*
   [transc] Parent theory of "complex"

   [<a name="IM-val"><b>IM</b></a>]  Definition

      |- ∀z. IM z = SND z

   [<a name="RE-val"><b>RE</b></a>]  Definition

      |- ∀z. RE z = FST z

   [<a name="arg-val"><b>arg</b></a>]  Definition

      |- ∀z.
           arg z =
           if 0 ≤ IM z then acs (RE z / modu z)
           else -acs (RE z / modu z) + 2 * pi

   [<a name="complex_add-val"><b>complex_add</b></a>]  Definition

      |- ∀z w. z + w = (RE z + RE w,IM z + IM w)

   [<a name="complex_div-val"><b>complex_div</b></a>]  Definition

      |- ∀z w. z / w = z * inv w

   [<a name="complex_exp-val"><b>complex_exp</b></a>]  Definition

      |- ∀z. exp z = exp (RE z) * (cos (IM z),sin (IM z))

   [<a name="complex_inv-val"><b>complex_inv</b></a>]  Definition

      |- ∀z.
           inv z =
           (RE z / (RE z pow 2 + IM z pow 2),
            -IM z / (RE z pow 2 + IM z pow 2))

   [<a name="complex_mul-val"><b>complex_mul</b></a>]  Definition

      |- ∀z w.
           z * w = (RE z * RE w − IM z * IM w,RE z * IM w + IM z * RE w)

   [<a name="complex_neg-val"><b>complex_neg</b></a>]  Definition

      |- ∀z. -z = (-RE z,-IM z)

   [<a name="complex_of_num-val"><b>complex_of_num</b></a>]  Definition

      |- ∀n. &n = complex_of_real (&n)

   [<a name="complex_of_real-val"><b>complex_of_real</b></a>]  Definition

      |- ∀x. complex_of_real x = (x,0)

   [<a name="complex_pow_def-val"><b>complex_pow_def</b></a>]  Definition

      |- (∀z. z pow 0 = 1) ∧ ∀z n. z pow SUC n = z * z pow n

   [<a name="complex_scalar_lmul-val"><b>complex_scalar_lmul</b></a>]  Definition

      |- ∀k z. k * z = (k * RE z,k * IM z)

   [<a name="complex_scalar_rmul-val"><b>complex_scalar_rmul</b></a>]  Definition

      |- ∀z k. z * k = (RE z * k,IM z * k)

   [<a name="complex_sub-val"><b>complex_sub</b></a>]  Definition

      |- ∀z w. z − w = z + -w

   [<a name="conj-val"><b>conj</b></a>]  Definition

      |- ∀z. conj z = (RE z,-IM z)

   [<a name="i-val"><b>i</b></a>]  Definition

      |- i = (0,1)

   [<a name="modu-val"><b>modu</b></a>]  Definition

      |- ∀z. modu z = sqrt (RE z pow 2 + IM z pow 2)

   [<a name="ARG_COS-val"><b>ARG_COS</b></a>]  Theorem

      |- ∀z. z ≠ 0 ⇒ (cos (arg z) = RE z / modu z)

   [<a name="ARG_SIN-val"><b>ARG_SIN</b></a>]  Theorem

      |- ∀z. z ≠ 0 ⇒ (sin (arg z) = IM z / modu z)

   [<a name="COMPLEX-val"><b>COMPLEX</b></a>]  Theorem

      |- ∀z. (RE z,IM z) = z

   [<a name="COMPLEX_0-val"><b>COMPLEX_0</b></a>]  Theorem

      |- 0 = complex_of_real 0

   [<a name="COMPLEX_0_THM-val"><b>COMPLEX_0_THM</b></a>]  Theorem

      |- ∀z. (z = 0) ⇔ (RE z pow 2 + IM z pow 2 = 0)

   [<a name="COMPLEX_1-val"><b>COMPLEX_1</b></a>]  Theorem

      |- 1 = complex_of_real 1

   [<a name="COMPLEX_10-val"><b>COMPLEX_10</b></a>]  Theorem

      |- 1 ≠ 0

   [<a name="COMPLEX_ADD2_SUB2-val"><b>COMPLEX_ADD2_SUB2</b></a>]  Theorem

      |- ∀z w u v. z + w − (u + v) = z − u + (w − v)

   [<a name="COMPLEX_ADD_ASSOC-val"><b>COMPLEX_ADD_ASSOC</b></a>]  Theorem

      |- ∀z w v. z + (w + v) = z + w + v

   [<a name="COMPLEX_ADD_COMM-val"><b>COMPLEX_ADD_COMM</b></a>]  Theorem

      |- ∀z w. z + w = w + z

   [<a name="COMPLEX_ADD_LDISTRIB-val"><b>COMPLEX_ADD_LDISTRIB</b></a>]  Theorem

      |- ∀z w v. z * (w + v) = z * w + z * v

   [<a name="COMPLEX_ADD_LID-val"><b>COMPLEX_ADD_LID</b></a>]  Theorem

      |- ∀z. 0 + z = z

   [<a name="COMPLEX_ADD_LID_UNIQ-val"><b>COMPLEX_ADD_LID_UNIQ</b></a>]  Theorem

      |- ∀z w. (z + w = w) ⇔ (z = 0)

   [<a name="COMPLEX_ADD_LINV-val"><b>COMPLEX_ADD_LINV</b></a>]  Theorem

      |- ∀z. -z + z = 0

   [<a name="COMPLEX_ADD_RAT-val"><b>COMPLEX_ADD_RAT</b></a>]  Theorem

      |- ∀z w u v.
           w ≠ 0 ∧ v ≠ 0 ⇒ (z / w + u / v = (z * v + w * u) / (w * v))

   [<a name="COMPLEX_ADD_RDISTRIB-val"><b>COMPLEX_ADD_RDISTRIB</b></a>]  Theorem

      |- ∀z w v. (z + w) * v = z * v + w * v

   [<a name="COMPLEX_ADD_RID-val"><b>COMPLEX_ADD_RID</b></a>]  Theorem

      |- ∀z. z + 0 = z

   [<a name="COMPLEX_ADD_RID_UNIQ-val"><b>COMPLEX_ADD_RID_UNIQ</b></a>]  Theorem

      |- ∀z w. (z + w = z) ⇔ (w = 0)

   [<a name="COMPLEX_ADD_RINV-val"><b>COMPLEX_ADD_RINV</b></a>]  Theorem

      |- ∀z. z + -z = 0

   [<a name="COMPLEX_ADD_RSCALAR_RMUL-val"><b>COMPLEX_ADD_RSCALAR_RMUL</b></a>]  Theorem

      |- ∀k z w. (z + w) * k = z * k + w * k

   [<a name="COMPLEX_ADD_SCALAR_LMUL-val"><b>COMPLEX_ADD_SCALAR_LMUL</b></a>]  Theorem

      |- ∀k z w. k * (z + w) = k * z + k * w

   [<a name="COMPLEX_ADD_SUB-val"><b>COMPLEX_ADD_SUB</b></a>]  Theorem

      |- ∀z w. z + w − z = w

   [<a name="COMPLEX_ADD_SUB2-val"><b>COMPLEX_ADD_SUB2</b></a>]  Theorem

      |- ∀z w. z − (z + w) = -w

   [<a name="COMPLEX_DIFFSQ-val"><b>COMPLEX_DIFFSQ</b></a>]  Theorem

      |- ∀z w. (z + w) * (z − w) = z * z − w * w

   [<a name="COMPLEX_DIV1-val"><b>COMPLEX_DIV1</b></a>]  Theorem

      |- ∀z. z / 1 = z

   [<a name="COMPLEX_DIV_ADD-val"><b>COMPLEX_DIV_ADD</b></a>]  Theorem

      |- ∀z w v. z / v + w / v = (z + w) / v

   [<a name="COMPLEX_DIV_ARG-val"><b>COMPLEX_DIV_ARG</b></a>]  Theorem

      |- ∀x y. (cos x,sin x) / (cos y,sin y) = (cos (x − y),sin (x − y))

   [<a name="COMPLEX_DIV_DENOM_CANCEL-val"><b>COMPLEX_DIV_DENOM_CANCEL</b></a>]  Theorem

      |- ∀z w v. z ≠ 0 ⇒ (w / z / (v / z) = w / v)

   [<a name="COMPLEX_DIV_INNER_CANCEL-val"><b>COMPLEX_DIV_INNER_CANCEL</b></a>]  Theorem

      |- ∀z w v. z ≠ 0 ⇒ (w / z * (z / v) = w / v)

   [<a name="COMPLEX_DIV_LMUL_CANCEL-val"><b>COMPLEX_DIV_LMUL_CANCEL</b></a>]  Theorem

      |- ∀v z w. v ≠ 0 ⇒ (v * z / (v * w) = z / w)

   [<a name="COMPLEX_DIV_LZERO-val"><b>COMPLEX_DIV_LZERO</b></a>]  Theorem

      |- ∀z. 0 / z = 0

   [<a name="COMPLEX_DIV_MUL2-val"><b>COMPLEX_DIV_MUL2</b></a>]  Theorem

      |- ∀z w. z ≠ 0 ∧ w ≠ 0 ⇒ ∀v. v / w = z * v / (z * w)

   [<a name="COMPLEX_DIV_OUTER_CANCEL-val"><b>COMPLEX_DIV_OUTER_CANCEL</b></a>]  Theorem

      |- ∀z w v. z ≠ 0 ⇒ (z / w * (v / z) = v / w)

   [<a name="COMPLEX_DIV_REFL-val"><b>COMPLEX_DIV_REFL</b></a>]  Theorem

      |- ∀z. z ≠ 0 ⇒ (z / z = 1)

   [<a name="COMPLEX_DIV_RMUL_CANCEL-val"><b>COMPLEX_DIV_RMUL_CANCEL</b></a>]  Theorem

      |- ∀v z w. v ≠ 0 ⇒ (z * v / (w * v) = z / w)

   [<a name="COMPLEX_DIV_SUB-val"><b>COMPLEX_DIV_SUB</b></a>]  Theorem

      |- ∀z w v. z / v − w / v = (z − w) / v

   [<a name="COMPLEX_DOUBLE-val"><b>COMPLEX_DOUBLE</b></a>]  Theorem

      |- ∀z. z + z = 2 * z

   [<a name="COMPLEX_ENTIRE-val"><b>COMPLEX_ENTIRE</b></a>]  Theorem

      |- ∀z w. (z * w = 0) ⇔ (z = 0) ∨ (w = 0)

   [<a name="COMPLEX_EQ_LADD-val"><b>COMPLEX_EQ_LADD</b></a>]  Theorem

      |- ∀z w v. (z + w = z + v) ⇔ (w = v)

   [<a name="COMPLEX_EQ_LDIV_EQ-val"><b>COMPLEX_EQ_LDIV_EQ</b></a>]  Theorem

      |- ∀z w v. v ≠ 0 ⇒ ((z / v = w) ⇔ (z = w * v))

   [<a name="COMPLEX_EQ_LMUL-val"><b>COMPLEX_EQ_LMUL</b></a>]  Theorem

      |- ∀z w v. (z * w = z * v) ⇔ (z = 0) ∨ (w = v)

   [<a name="COMPLEX_EQ_LMUL2-val"><b>COMPLEX_EQ_LMUL2</b></a>]  Theorem

      |- ∀z w v. z ≠ 0 ⇒ ((w = v) ⇔ (z * w = z * v))

   [<a name="COMPLEX_EQ_LMUL_IMP-val"><b>COMPLEX_EQ_LMUL_IMP</b></a>]  Theorem

      |- ∀z w v. z ≠ 0 ∧ (z * w = z * v) ⇒ (w = v)

   [<a name="COMPLEX_EQ_NEG-val"><b>COMPLEX_EQ_NEG</b></a>]  Theorem

      |- ∀z w. (-z = -w) ⇔ (z = w)

   [<a name="COMPLEX_EQ_RADD-val"><b>COMPLEX_EQ_RADD</b></a>]  Theorem

      |- ∀z w v. (z + v = w + v) ⇔ (z = w)

   [<a name="COMPLEX_EQ_RDIV_EQ-val"><b>COMPLEX_EQ_RDIV_EQ</b></a>]  Theorem

      |- ∀z w v. v ≠ 0 ⇒ ((z = w / v) ⇔ (z * v = w))

   [<a name="COMPLEX_EQ_RMUL-val"><b>COMPLEX_EQ_RMUL</b></a>]  Theorem

      |- ∀z w v. (z * v = w * v) ⇔ (v = 0) ∨ (z = w)

   [<a name="COMPLEX_EQ_RMUL_IMP-val"><b>COMPLEX_EQ_RMUL_IMP</b></a>]  Theorem

      |- ∀z w v. z ≠ 0 ∧ (w * z = v * z) ⇒ (w = v)

   [<a name="COMPLEX_EQ_SCALAR_LMUL-val"><b>COMPLEX_EQ_SCALAR_LMUL</b></a>]  Theorem

      |- ∀k z w. (k * z = k * w) ⇔ (k = 0) ∨ (z = w)

   [<a name="COMPLEX_EQ_SUB_LADD-val"><b>COMPLEX_EQ_SUB_LADD</b></a>]  Theorem

      |- ∀z w v. (z = w − v) ⇔ (z + v = w)

   [<a name="COMPLEX_EQ_SUB_RADD-val"><b>COMPLEX_EQ_SUB_RADD</b></a>]  Theorem

      |- ∀z w v. (z − w = v) ⇔ (z = v + w)

   [<a name="COMPLEX_EXP_0-val"><b>COMPLEX_EXP_0</b></a>]  Theorem

      |- exp 0 = 1

   [<a name="COMPLEX_EXP_ADD-val"><b>COMPLEX_EXP_ADD</b></a>]  Theorem

      |- ∀z w. exp (z + w) = exp z * exp w

   [<a name="COMPLEX_EXP_ADD_MUL-val"><b>COMPLEX_EXP_ADD_MUL</b></a>]  Theorem

      |- ∀z w. exp (z + w) * exp (-z) = exp w

   [<a name="COMPLEX_EXP_N-val"><b>COMPLEX_EXP_N</b></a>]  Theorem

      |- ∀z n. exp (&n * z) = exp z pow n

   [<a name="COMPLEX_EXP_N2-val"><b>COMPLEX_EXP_N2</b></a>]  Theorem

      |- ∀z n. exp (&n * z) = exp z pow n

   [<a name="COMPLEX_EXP_NEG-val"><b>COMPLEX_EXP_NEG</b></a>]  Theorem

      |- ∀z. exp (-z) = inv (exp z)

   [<a name="COMPLEX_EXP_NEG_MUL-val"><b>COMPLEX_EXP_NEG_MUL</b></a>]  Theorem

      |- ∀z. exp z * exp (-z) = 1

   [<a name="COMPLEX_EXP_NEG_MUL2-val"><b>COMPLEX_EXP_NEG_MUL2</b></a>]  Theorem

      |- ∀z. exp (-z) * exp z = 1

   [<a name="COMPLEX_EXP_NZ-val"><b>COMPLEX_EXP_NZ</b></a>]  Theorem

      |- ∀z. exp z ≠ 0

   [<a name="COMPLEX_EXP_SUB-val"><b>COMPLEX_EXP_SUB</b></a>]  Theorem

      |- ∀z w. exp (z − w) = exp z / exp w

   [<a name="COMPLEX_INV1-val"><b>COMPLEX_INV1</b></a>]  Theorem

      |- inv 1 = 1

   [<a name="COMPLEX_INVINV-val"><b>COMPLEX_INVINV</b></a>]  Theorem

      |- ∀z. z ≠ 0 ⇒ (inv (inv z) = z)

   [<a name="COMPLEX_INV_0-val"><b>COMPLEX_INV_0</b></a>]  Theorem

      |- inv 0 = 0

   [<a name="COMPLEX_INV_1OVER-val"><b>COMPLEX_INV_1OVER</b></a>]  Theorem

      |- ∀z. inv z = 1 / z

   [<a name="COMPLEX_INV_ARG-val"><b>COMPLEX_INV_ARG</b></a>]  Theorem

      |- ∀x. inv (cos x,sin x) = (cos (-x),sin (-x))

   [<a name="COMPLEX_INV_EQ_0-val"><b>COMPLEX_INV_EQ_0</b></a>]  Theorem

      |- ∀z. (inv z = 0) ⇔ (z = 0)

   [<a name="COMPLEX_INV_INJ-val"><b>COMPLEX_INV_INJ</b></a>]  Theorem

      |- ∀z w. (inv z = inv w) ⇔ (z = w)

   [<a name="COMPLEX_INV_INV-val"><b>COMPLEX_INV_INV</b></a>]  Theorem

      |- ∀z. inv (inv z) = z

   [<a name="COMPLEX_INV_MUL-val"><b>COMPLEX_INV_MUL</b></a>]  Theorem

      |- ∀z w. z ≠ 0 ∧ w ≠ 0 ⇒ (inv (z * w) = inv z * inv w)

   [<a name="COMPLEX_INV_NEG-val"><b>COMPLEX_INV_NEG</b></a>]  Theorem

      |- ∀z. inv (-z) = -inv z

   [<a name="COMPLEX_INV_NZ-val"><b>COMPLEX_INV_NZ</b></a>]  Theorem

      |- ∀z. z ≠ 0 ⇒ inv z ≠ 0

   [<a name="COMPLEX_INV_SCALAR_LMUL-val"><b>COMPLEX_INV_SCALAR_LMUL</b></a>]  Theorem

      |- ∀k z. k ≠ 0 ∧ z ≠ 0 ⇒ (inv (k * z) = inv k * inv z)

   [<a name="COMPLEX_LEMMA1-val"><b>COMPLEX_LEMMA1</b></a>]  Theorem

      |- ∀a b c d.
           (a * c − b * d) pow 2 + (a * d + b * c) pow 2 =
           (a pow 2 + b pow 2) * (c pow 2 + d pow 2)

   [<a name="COMPLEX_LEMMA2-val"><b>COMPLEX_LEMMA2</b></a>]  Theorem

      |- ∀x y. abs x ≤ sqrt (x pow 2 + y pow 2)

   [<a name="COMPLEX_LINV_UNIQ-val"><b>COMPLEX_LINV_UNIQ</b></a>]  Theorem

      |- ∀z w. (z * w = 1) ⇒ (z = inv w)

   [<a name="COMPLEX_LMUL_SCALAR_LMUL-val"><b>COMPLEX_LMUL_SCALAR_LMUL</b></a>]  Theorem

      |- ∀k z w. k * z * w = k * (z * w)

   [<a name="COMPLEX_LNEG_UNIQ-val"><b>COMPLEX_LNEG_UNIQ</b></a>]  Theorem

      |- ∀z w. (z + w = 0) ⇔ (z = -w)

   [<a name="COMPLEX_MODU_ARG_EQ-val"><b>COMPLEX_MODU_ARG_EQ</b></a>]  Theorem

      |- ∀z w. (z = w) ⇔ (modu z = modu w) ∧ (arg z = arg w)

   [<a name="COMPLEX_MUL_ARG-val"><b>COMPLEX_MUL_ARG</b></a>]  Theorem

      |- ∀x y. (cos x,sin x) * (cos y,sin y) = (cos (x + y),sin (x + y))

   [<a name="COMPLEX_MUL_ASSOC-val"><b>COMPLEX_MUL_ASSOC</b></a>]  Theorem

      |- ∀z w v. z * (w * v) = z * w * v

   [<a name="COMPLEX_MUL_COMM-val"><b>COMPLEX_MUL_COMM</b></a>]  Theorem

      |- ∀z w. z * w = w * z

   [<a name="COMPLEX_MUL_LCONJ1-val"><b>COMPLEX_MUL_LCONJ1</b></a>]  Theorem

      |- ∀z. conj z * z = complex_of_real (modu z pow 2)

   [<a name="COMPLEX_MUL_LID-val"><b>COMPLEX_MUL_LID</b></a>]  Theorem

      |- ∀z. 1 * z = z

   [<a name="COMPLEX_MUL_LINV-val"><b>COMPLEX_MUL_LINV</b></a>]  Theorem

      |- ∀z. z ≠ 0 ⇒ (inv z * z = 1)

   [<a name="COMPLEX_MUL_LNEG-val"><b>COMPLEX_MUL_LNEG</b></a>]  Theorem

      |- ∀z w. -z * w = -(z * w)

   [<a name="COMPLEX_MUL_LZERO-val"><b>COMPLEX_MUL_LZERO</b></a>]  Theorem

      |- ∀z. 0 * z = 0

   [<a name="COMPLEX_MUL_RCONJ-val"><b>COMPLEX_MUL_RCONJ</b></a>]  Theorem

      |- ∀z. conj z * z = complex_of_real (RE z pow 2 + IM z pow 2)

   [<a name="COMPLEX_MUL_RCONJ1-val"><b>COMPLEX_MUL_RCONJ1</b></a>]  Theorem

      |- ∀z. z * conj z = complex_of_real (modu z pow 2)

   [<a name="COMPLEX_MUL_RID-val"><b>COMPLEX_MUL_RID</b></a>]  Theorem

      |- ∀z. z * 1 = z

   [<a name="COMPLEX_MUL_RINV-val"><b>COMPLEX_MUL_RINV</b></a>]  Theorem

      |- ∀z. z ≠ 0 ⇒ (z * inv z = 1)

   [<a name="COMPLEX_MUL_RNEG-val"><b>COMPLEX_MUL_RNEG</b></a>]  Theorem

      |- ∀z w. z * -w = -(z * w)

   [<a name="COMPLEX_MUL_RZERO-val"><b>COMPLEX_MUL_RZERO</b></a>]  Theorem

      |- ∀z. z * 0 = 0

   [<a name="COMPLEX_MUL_SCALAR_LMUL2-val"><b>COMPLEX_MUL_SCALAR_LMUL2</b></a>]  Theorem

      |- ∀k l z w. k * z * (l * w) = k * l * (z * w)

   [<a name="COMPLEX_NEGNEG-val"><b>COMPLEX_NEGNEG</b></a>]  Theorem

      |- ∀z. --z = z

   [<a name="COMPLEX_NEG_0-val"><b>COMPLEX_NEG_0</b></a>]  Theorem

      |- -0 = 0

   [<a name="COMPLEX_NEG_ADD-val"><b>COMPLEX_NEG_ADD</b></a>]  Theorem

      |- ∀z w. -(z + w) = -z + -w

   [<a name="COMPLEX_NEG_DIV2-val"><b>COMPLEX_NEG_DIV2</b></a>]  Theorem

      |- ∀z w. -z / -w = z / w

   [<a name="COMPLEX_NEG_EQ-val"><b>COMPLEX_NEG_EQ</b></a>]  Theorem

      |- ∀z w. (-z = w) ⇔ (z = -w)

   [<a name="COMPLEX_NEG_EQ0-val"><b>COMPLEX_NEG_EQ0</b></a>]  Theorem

      |- ∀z. (-z = 0) ⇔ (z = 0)

   [<a name="COMPLEX_NEG_INV-val"><b>COMPLEX_NEG_INV</b></a>]  Theorem

      |- ∀z. z ≠ 0 ⇒ (inv (-z) = -inv z)

   [<a name="COMPLEX_NEG_LDIV-val"><b>COMPLEX_NEG_LDIV</b></a>]  Theorem

      |- ∀z w. -(z / w) = -z / w

   [<a name="COMPLEX_NEG_LMUL-val"><b>COMPLEX_NEG_LMUL</b></a>]  Theorem

      |- ∀z w. -(z * w) = -z * w

   [<a name="COMPLEX_NEG_MUL2-val"><b>COMPLEX_NEG_MUL2</b></a>]  Theorem

      |- ∀z w. -z * -w = z * w

   [<a name="COMPLEX_NEG_RDIV-val"><b>COMPLEX_NEG_RDIV</b></a>]  Theorem

      |- ∀z w. -(z / w) = z / -w

   [<a name="COMPLEX_NEG_RMUL-val"><b>COMPLEX_NEG_RMUL</b></a>]  Theorem

      |- ∀z w. -(z * w) = z * -w

   [<a name="COMPLEX_NEG_SCALAR_LMUL-val"><b>COMPLEX_NEG_SCALAR_LMUL</b></a>]  Theorem

      |- ∀k z. k * -z = -k * z

   [<a name="COMPLEX_NEG_SCALAR_RMUL-val"><b>COMPLEX_NEG_SCALAR_RMUL</b></a>]  Theorem

      |- ∀k z. -z * k = z * -k

   [<a name="COMPLEX_NEG_SUB-val"><b>COMPLEX_NEG_SUB</b></a>]  Theorem

      |- ∀z w. -(z − w) = w − z

   [<a name="COMPLEX_OF_NUM_ADD-val"><b>COMPLEX_OF_NUM_ADD</b></a>]  Theorem

      |- ∀m n. &m + &n = &(m + n)

   [<a name="COMPLEX_OF_NUM_EQ-val"><b>COMPLEX_OF_NUM_EQ</b></a>]  Theorem

      |- ∀m n. (&m = &n) ⇔ (m = n)

   [<a name="COMPLEX_OF_NUM_MUL-val"><b>COMPLEX_OF_NUM_MUL</b></a>]  Theorem

      |- ∀m n. &m * &n = &(m * n)

   [<a name="COMPLEX_OF_REAL_ADD-val"><b>COMPLEX_OF_REAL_ADD</b></a>]  Theorem

      |- ∀x y.
           complex_of_real x + complex_of_real y = complex_of_real (x + y)

   [<a name="COMPLEX_OF_REAL_DIV-val"><b>COMPLEX_OF_REAL_DIV</b></a>]  Theorem

      |- ∀x y.
           complex_of_real x / complex_of_real y = complex_of_real (x / y)

   [<a name="COMPLEX_OF_REAL_EQ-val"><b>COMPLEX_OF_REAL_EQ</b></a>]  Theorem

      |- ∀x y. (complex_of_real x = complex_of_real y) ⇔ (x = y)

   [<a name="COMPLEX_OF_REAL_INV-val"><b>COMPLEX_OF_REAL_INV</b></a>]  Theorem

      |- ∀x. inv (complex_of_real x) = complex_of_real (inv x)

   [<a name="COMPLEX_OF_REAL_MUL-val"><b>COMPLEX_OF_REAL_MUL</b></a>]  Theorem

      |- ∀x y.
           complex_of_real x * complex_of_real y = complex_of_real (x * y)

   [<a name="COMPLEX_OF_REAL_NEG-val"><b>COMPLEX_OF_REAL_NEG</b></a>]  Theorem

      |- ∀x. -complex_of_real x = complex_of_real (-x)

   [<a name="COMPLEX_OF_REAL_SUB-val"><b>COMPLEX_OF_REAL_SUB</b></a>]  Theorem

      |- ∀x y.
           complex_of_real x − complex_of_real y = complex_of_real (x − y)

   [<a name="COMPLEX_POWINV-val"><b>COMPLEX_POWINV</b></a>]  Theorem

      |- ∀z. z ≠ 0 ⇒ ∀n. inv (z pow n) = inv z pow n

   [<a name="COMPLEX_POW_0-val"><b>COMPLEX_POW_0</b></a>]  Theorem

      |- ∀n. 0 pow SUC n = 0

   [<a name="COMPLEX_POW_1-val"><b>COMPLEX_POW_1</b></a>]  Theorem

      |- ∀z. z pow 1 = z

   [<a name="COMPLEX_POW_2-val"><b>COMPLEX_POW_2</b></a>]  Theorem

      |- ∀z. z pow 2 = z * z

   [<a name="COMPLEX_POW_ADD-val"><b>COMPLEX_POW_ADD</b></a>]  Theorem

      |- ∀z m n. z pow (m + n) = z pow m * z pow n

   [<a name="COMPLEX_POW_DIV-val"><b>COMPLEX_POW_DIV</b></a>]  Theorem

      |- ∀z w n. (z / w) pow n = z pow n / w pow n

   [<a name="COMPLEX_POW_INV-val"><b>COMPLEX_POW_INV</b></a>]  Theorem

      |- ∀z n. inv z pow n = inv (z pow n)

   [<a name="COMPLEX_POW_L-val"><b>COMPLEX_POW_L</b></a>]  Theorem

      |- ∀n k z. (k * z) pow n = k pow n * z pow n

   [<a name="COMPLEX_POW_MUL-val"><b>COMPLEX_POW_MUL</b></a>]  Theorem

      |- ∀n z w. (z * w) pow n = z pow n * w pow n

   [<a name="COMPLEX_POW_NZ-val"><b>COMPLEX_POW_NZ</b></a>]  Theorem

      |- ∀z n. z ≠ 0 ⇒ z pow n ≠ 0

   [<a name="COMPLEX_POW_ONE-val"><b>COMPLEX_POW_ONE</b></a>]  Theorem

      |- ∀n. 1 pow n = 1

   [<a name="COMPLEX_POW_POW-val"><b>COMPLEX_POW_POW</b></a>]  Theorem

      |- ∀z m n. (z pow m) pow n = z pow (m * n)

   [<a name="COMPLEX_POW_ZERO-val"><b>COMPLEX_POW_ZERO</b></a>]  Theorem

      |- ∀n z. (z pow n = 0) ⇒ (z = 0)

   [<a name="COMPLEX_POW_ZERO_EQ-val"><b>COMPLEX_POW_ZERO_EQ</b></a>]  Theorem

      |- ∀n z. (z pow SUC n = 0) ⇔ (z = 0)

   [<a name="COMPLEX_RE_IM_EQ-val"><b>COMPLEX_RE_IM_EQ</b></a>]  Theorem

      |- ∀z w. (z = w) ⇔ (RE z = RE w) ∧ (IM z = IM w)

   [<a name="COMPLEX_RINV_UNIQ-val"><b>COMPLEX_RINV_UNIQ</b></a>]  Theorem

      |- ∀z w. (z * w = 1) ⇒ (w = inv z)

   [<a name="COMPLEX_RMUL_SCALAR_LMUL-val"><b>COMPLEX_RMUL_SCALAR_LMUL</b></a>]  Theorem

      |- ∀k z w. z * (k * w) = k * (z * w)

   [<a name="COMPLEX_RNEG_UNIQ-val"><b>COMPLEX_RNEG_UNIQ</b></a>]  Theorem

      |- ∀z w. (z + w = 0) ⇔ (w = -z)

   [<a name="COMPLEX_RSCALAR_RMUL_SUB-val"><b>COMPLEX_RSCALAR_RMUL_SUB</b></a>]  Theorem

      |- ∀k l z. z * (k − l) = z * k − z * l

   [<a name="COMPLEX_SCALAR_LMUL-val"><b>COMPLEX_SCALAR_LMUL</b></a>]  Theorem

      |- ∀k l z. k * (l * z) = k * l * z

   [<a name="COMPLEX_SCALAR_LMUL_ADD-val"><b>COMPLEX_SCALAR_LMUL_ADD</b></a>]  Theorem

      |- ∀k l z. (k + l) * z = k * z + l * z

   [<a name="COMPLEX_SCALAR_LMUL_DIV2-val"><b>COMPLEX_SCALAR_LMUL_DIV2</b></a>]  Theorem

      |- ∀k l z w. l ≠ 0 ∧ w ≠ 0 ⇒ (k * z / (l * w) = k / l * (z / w))

   [<a name="COMPLEX_SCALAR_LMUL_ENTIRE-val"><b>COMPLEX_SCALAR_LMUL_ENTIRE</b></a>]  Theorem

      |- ∀k z. (k * z = 0) ⇔ (k = 0) ∨ (z = 0)

   [<a name="COMPLEX_SCALAR_LMUL_EQ-val"><b>COMPLEX_SCALAR_LMUL_EQ</b></a>]  Theorem

      |- ∀k l z. (k * z = l * z) ⇔ (k = l) ∨ (z = 0)

   [<a name="COMPLEX_SCALAR_LMUL_EQ1-val"><b>COMPLEX_SCALAR_LMUL_EQ1</b></a>]  Theorem

      |- ∀k z. (k * z = z) ⇔ (k = 1) ∨ (z = 0)

   [<a name="COMPLEX_SCALAR_LMUL_NEG-val"><b>COMPLEX_SCALAR_LMUL_NEG</b></a>]  Theorem

      |- ∀k z. -(k * z) = -k * z

   [<a name="COMPLEX_SCALAR_LMUL_NEG1-val"><b>COMPLEX_SCALAR_LMUL_NEG1</b></a>]  Theorem

      |- ∀z. -1 * z = -z

   [<a name="COMPLEX_SCALAR_LMUL_ONE-val"><b>COMPLEX_SCALAR_LMUL_ONE</b></a>]  Theorem

      |- ∀z. 1 * z = z

   [<a name="COMPLEX_SCALAR_LMUL_SUB-val"><b>COMPLEX_SCALAR_LMUL_SUB</b></a>]  Theorem

      |- ∀k l z. (k − l) * z = k * z − l * z

   [<a name="COMPLEX_SCALAR_LMUL_ZERO-val"><b>COMPLEX_SCALAR_LMUL_ZERO</b></a>]  Theorem

      |- ∀z. 0 * z = 0

   [<a name="COMPLEX_SCALAR_MUL_COMM-val"><b>COMPLEX_SCALAR_MUL_COMM</b></a>]  Theorem

      |- ∀k z. k * z = z * k

   [<a name="COMPLEX_SCALAR_RMUL-val"><b>COMPLEX_SCALAR_RMUL</b></a>]  Theorem

      |- ∀k l z. z * k * l = z * (k * l)

   [<a name="COMPLEX_SCALAR_RMUL_ADD-val"><b>COMPLEX_SCALAR_RMUL_ADD</b></a>]  Theorem

      |- ∀k l z. z * (k + l) = z * k + z * l

   [<a name="COMPLEX_SCALAR_RMUL_NEG-val"><b>COMPLEX_SCALAR_RMUL_NEG</b></a>]  Theorem

      |- ∀k z. -(z * k) = z * -k

   [<a name="COMPLEX_SCALAR_RMUL_NEG1-val"><b>COMPLEX_SCALAR_RMUL_NEG1</b></a>]  Theorem

      |- ∀z. z * -1 = -z

   [<a name="COMPLEX_SCALAR_RMUL_ONE-val"><b>COMPLEX_SCALAR_RMUL_ONE</b></a>]  Theorem

      |- ∀z. z * 1 = z

   [<a name="COMPLEX_SCALAR_RMUL_ZERO-val"><b>COMPLEX_SCALAR_RMUL_ZERO</b></a>]  Theorem

      |- ∀z. z * 0 = 0

   [<a name="COMPLEX_SUB_0-val"><b>COMPLEX_SUB_0</b></a>]  Theorem

      |- ∀z w. (z − w = 0) ⇔ (z = w)

   [<a name="COMPLEX_SUB_ADD-val"><b>COMPLEX_SUB_ADD</b></a>]  Theorem

      |- ∀z w. z − w + w = z

   [<a name="COMPLEX_SUB_ADD2-val"><b>COMPLEX_SUB_ADD2</b></a>]  Theorem

      |- ∀z w. w + (z − w) = z

   [<a name="COMPLEX_SUB_INV2-val"><b>COMPLEX_SUB_INV2</b></a>]  Theorem

      |- ∀z w. z ≠ 0 ∧ w ≠ 0 ⇒ (inv z − inv w = (w − z) / (z * w))

   [<a name="COMPLEX_SUB_LDISTRIB-val"><b>COMPLEX_SUB_LDISTRIB</b></a>]  Theorem

      |- ∀z w v. z * (w − v) = z * w − z * v

   [<a name="COMPLEX_SUB_LNEG-val"><b>COMPLEX_SUB_LNEG</b></a>]  Theorem

      |- ∀z w. -z − w = -(z + w)

   [<a name="COMPLEX_SUB_LZERO-val"><b>COMPLEX_SUB_LZERO</b></a>]  Theorem

      |- ∀z. 0 − z = -z

   [<a name="COMPLEX_SUB_NEG2-val"><b>COMPLEX_SUB_NEG2</b></a>]  Theorem

      |- ∀z w. -z − -w = w − z

   [<a name="COMPLEX_SUB_RAT-val"><b>COMPLEX_SUB_RAT</b></a>]  Theorem

      |- ∀z w u v.
           w ≠ 0 ∧ v ≠ 0 ⇒ (z / w − u / v = (z * v − w * u) / (w * v))

   [<a name="COMPLEX_SUB_RDISTRIB-val"><b>COMPLEX_SUB_RDISTRIB</b></a>]  Theorem

      |- ∀z w v. (z − w) * v = z * v − w * v

   [<a name="COMPLEX_SUB_REFL-val"><b>COMPLEX_SUB_REFL</b></a>]  Theorem

      |- ∀z. z − z = 0

   [<a name="COMPLEX_SUB_RNEG-val"><b>COMPLEX_SUB_RNEG</b></a>]  Theorem

      |- ∀z w. z − -w = z + w

   [<a name="COMPLEX_SUB_RZERO-val"><b>COMPLEX_SUB_RZERO</b></a>]  Theorem

      |- ∀z. z − 0 = z

   [<a name="COMPLEX_SUB_SCALAR_LMUL-val"><b>COMPLEX_SUB_SCALAR_LMUL</b></a>]  Theorem

      |- ∀k z w. k * (z − w) = k * z − k * w

   [<a name="COMPLEX_SUB_SCALAR_RMUL-val"><b>COMPLEX_SUB_SCALAR_RMUL</b></a>]  Theorem

      |- ∀k z w. (z − w) * k = z * k − w * k

   [<a name="COMPLEX_SUB_SUB-val"><b>COMPLEX_SUB_SUB</b></a>]  Theorem

      |- ∀z w. z − w − z = -w

   [<a name="COMPLEX_SUB_SUB2-val"><b>COMPLEX_SUB_SUB2</b></a>]  Theorem

      |- ∀z w. z − (z − w) = w

   [<a name="COMPLEX_SUB_TRIANGLE-val"><b>COMPLEX_SUB_TRIANGLE</b></a>]  Theorem

      |- ∀z w v. z − w + (w − v) = z − v

   [<a name="COMPLEX_TRIANGLE-val"><b>COMPLEX_TRIANGLE</b></a>]  Theorem

      |- ∀z. modu z * (cos (arg z),sin (arg z)) = z

   [<a name="COMPLEX_ZERO_SCALAR_LMUL-val"><b>COMPLEX_ZERO_SCALAR_LMUL</b></a>]  Theorem

      |- ∀k. k * 0 = 0

   [<a name="COMPLEX_ZERO_SCALAR_RMUL-val"><b>COMPLEX_ZERO_SCALAR_RMUL</b></a>]  Theorem

      |- ∀k. 0 * k = 0

   [<a name="CONJ_ADD-val"><b>CONJ_ADD</b></a>]  Theorem

      |- ∀z w. conj (z + w) = conj z + conj w

   [<a name="CONJ_CONJ-val"><b>CONJ_CONJ</b></a>]  Theorem

      |- ∀z. conj (conj z) = z

   [<a name="CONJ_DIV-val"><b>CONJ_DIV</b></a>]  Theorem

      |- ∀z w. conj (z / w) = conj z / conj w

   [<a name="CONJ_EQ-val"><b>CONJ_EQ</b></a>]  Theorem

      |- ∀z w. (conj z = w) ⇔ (z = conj w)

   [<a name="CONJ_EQ2-val"><b>CONJ_EQ2</b></a>]  Theorem

      |- ∀z w. (conj z = conj w) ⇔ (z = w)

   [<a name="CONJ_INV-val"><b>CONJ_INV</b></a>]  Theorem

      |- ∀z. conj (inv z) = inv (conj z)

   [<a name="CONJ_MUL-val"><b>CONJ_MUL</b></a>]  Theorem

      |- ∀z w. conj (z * w) = conj z * conj w

   [<a name="CONJ_NEG-val"><b>CONJ_NEG</b></a>]  Theorem

      |- ∀z. conj (-z) = -conj z

   [<a name="CONJ_NUM_REFL-val"><b>CONJ_NUM_REFL</b></a>]  Theorem

      |- ∀n. conj (&n) = &n

   [<a name="CONJ_REAL_REFL-val"><b>CONJ_REAL_REFL</b></a>]  Theorem

      |- ∀x. conj (complex_of_real x) = complex_of_real x

   [<a name="CONJ_SCALAR_LMUL-val"><b>CONJ_SCALAR_LMUL</b></a>]  Theorem

      |- ∀k z. conj (k * z) = k * conj z

   [<a name="CONJ_SUB-val"><b>CONJ_SUB</b></a>]  Theorem

      |- ∀z w. conj (z − w) = conj z − conj w

   [<a name="CONJ_ZERO-val"><b>CONJ_ZERO</b></a>]  Theorem

      |- conj 0 = 0

   [<a name="DE_MOIVRE_LEMMA-val"><b>DE_MOIVRE_LEMMA</b></a>]  Theorem

      |- ∀x n. (cos x,sin x) pow n = (cos (&n * x),sin (&n * x))

   [<a name="DE_MOIVRE_THM-val"><b>DE_MOIVRE_THM</b></a>]  Theorem

      |- ∀z n.
           (modu z * (cos (arg z),sin (arg z))) pow n =
           modu z pow n * (cos (&n * arg z),sin (&n * arg z))

   [<a name="EULER_FORMULE-val"><b>EULER_FORMULE</b></a>]  Theorem

      |- ∀z. modu z * exp (i * arg z) = z

   [<a name="EXP_IMAGINARY-val"><b>EXP_IMAGINARY</b></a>]  Theorem

      |- ∀x. exp (i * x) = (cos x,sin x)

   [<a name="IM_COMPLEX_OF_REAL-val"><b>IM_COMPLEX_OF_REAL</b></a>]  Theorem

      |- ∀x. IM (complex_of_real x) = 0

   [<a name="IM_DIV_MODU_ASN_BOUNDS-val"><b>IM_DIV_MODU_ASN_BOUNDS</b></a>]  Theorem

      |- ∀z.
           z ≠ 0 ⇒
           -(pi / 2) ≤ asn (IM z / modu z) ∧ asn (IM z / modu z) ≤ pi / 2

   [<a name="IM_DIV_MODU_ASN_SIN-val"><b>IM_DIV_MODU_ASN_SIN</b></a>]  Theorem

      |- ∀z. z ≠ 0 ⇒ (sin (asn (IM z / modu z)) = IM z / modu z)

   [<a name="IM_DIV_MODU_BOUNDS-val"><b>IM_DIV_MODU_BOUNDS</b></a>]  Theorem

      |- ∀z. z ≠ 0 ⇒ -1 ≤ IM z / modu z ∧ IM z / modu z ≤ 1

   [<a name="IM_MODU_ARG-val"><b>IM_MODU_ARG</b></a>]  Theorem

      |- ∀z. IM z = modu z * sin (arg z)

   [<a name="MODU_0-val"><b>MODU_0</b></a>]  Theorem

      |- modu 0 = 0

   [<a name="MODU_1-val"><b>MODU_1</b></a>]  Theorem

      |- modu 1 = 1

   [<a name="MODU_CASES-val"><b>MODU_CASES</b></a>]  Theorem

      |- ∀z. (z = 0) ∨ 0 &lt; modu z

   [<a name="MODU_COMPLEX_INV-val"><b>MODU_COMPLEX_INV</b></a>]  Theorem

      |- ∀z. z ≠ 0 ⇒ (modu (inv z) = inv (modu z))

   [<a name="MODU_COMPLEX_POW-val"><b>MODU_COMPLEX_POW</b></a>]  Theorem

      |- ∀z n. modu (z pow n) = modu z pow n

   [<a name="MODU_CONJ-val"><b>MODU_CONJ</b></a>]  Theorem

      |- ∀z. modu (conj z) = modu z

   [<a name="MODU_DIV-val"><b>MODU_DIV</b></a>]  Theorem

      |- ∀z w. w ≠ 0 ⇒ (modu (z / w) = modu z / modu w)

   [<a name="MODU_MUL-val"><b>MODU_MUL</b></a>]  Theorem

      |- ∀z w. modu (z * w) = modu z * modu w

   [<a name="MODU_NEG-val"><b>MODU_NEG</b></a>]  Theorem

      |- ∀z. modu (-z) = modu z

   [<a name="MODU_NUM-val"><b>MODU_NUM</b></a>]  Theorem

      |- ∀n. modu (&n) = &n

   [<a name="MODU_NZ-val"><b>MODU_NZ</b></a>]  Theorem

      |- ∀z. z ≠ 0 ⇔ 0 &lt; modu z

   [<a name="MODU_POS-val"><b>MODU_POS</b></a>]  Theorem

      |- ∀z. 0 ≤ modu z

   [<a name="MODU_POW2-val"><b>MODU_POW2</b></a>]  Theorem

      |- ∀z. modu z pow 2 = RE z pow 2 + IM z pow 2

   [<a name="MODU_REAL-val"><b>MODU_REAL</b></a>]  Theorem

      |- ∀x. modu (complex_of_real x) = abs x

   [<a name="MODU_SCALAR_LMUL-val"><b>MODU_SCALAR_LMUL</b></a>]  Theorem

      |- ∀k z. modu (k * z) = abs k * modu z

   [<a name="MODU_SUB-val"><b>MODU_SUB</b></a>]  Theorem

      |- ∀z w. modu (z − w) = modu (w − z)

   [<a name="MODU_UNIT-val"><b>MODU_UNIT</b></a>]  Theorem

      |- ∀x y. modu (cos x,sin x) = 1

   [<a name="MODU_ZERO-val"><b>MODU_ZERO</b></a>]  Theorem

      |- ∀z. (z = 0) ⇔ (modu z = 0)

   [<a name="RE_COMPLEX_OF_REAL-val"><b>RE_COMPLEX_OF_REAL</b></a>]  Theorem

      |- ∀x. RE (complex_of_real x) = x

   [<a name="RE_DIV_MODU_ACS_BOUNDS-val"><b>RE_DIV_MODU_ACS_BOUNDS</b></a>]  Theorem

      |- ∀z. z ≠ 0 ⇒ 0 ≤ acs (RE z / modu z) ∧ acs (RE z / modu z) ≤ pi

   [<a name="RE_DIV_MODU_ACS_COS-val"><b>RE_DIV_MODU_ACS_COS</b></a>]  Theorem

      |- ∀z. z ≠ 0 ⇒ (cos (acs (RE z / modu z)) = RE z / modu z)

   [<a name="RE_DIV_MODU_BOUNDS-val"><b>RE_DIV_MODU_BOUNDS</b></a>]  Theorem

      |- ∀z. z ≠ 0 ⇒ -1 ≤ RE z / modu z ∧ RE z / modu z ≤ 1

   [<a name="RE_IM_LE_MODU-val"><b>RE_IM_LE_MODU</b></a>]  Theorem

      |- ∀z. abs (RE z) ≤ modu z ∧ abs (IM z) ≤ modu z

   [<a name="RE_MODU_ARG-val"><b>RE_MODU_ARG</b></a>]  Theorem

      |- ∀z. RE z = modu z * cos (arg z)

   [<a name="complex_pow_def_compute-val"><b>complex_pow_def_compute</b></a>]  Theorem

      |- (∀z. z pow 0 = 1) ∧
         (∀z n.
            z pow NUMERAL (BIT1 n) = z * z pow (NUMERAL (BIT1 n) − 1)) ∧
         ∀z n. z pow NUMERAL (BIT2 n) = z * z pow NUMERAL (BIT1 n)


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/complex/complexScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-10</a></em></p></body></html>
