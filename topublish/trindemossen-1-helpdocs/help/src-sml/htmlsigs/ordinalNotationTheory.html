<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure ordinalNotationTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure ordinalNotationTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/pred_set/src/more_theories/ordinalNotationScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature ordinalNotationTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#cf1_def-val">cf1_def</a> : thm
<a name="line7"></a>    val <a href="#cf2_def-val">cf2_def</a> : thm
<a name="line8"></a>    val <a href="#coeff_def-val">coeff_def</a> : thm
<a name="line9"></a>    val <a href="#expt_def-val">expt_def</a> : thm
<a name="line10"></a>    val <a href="#finp_def-val">finp_def</a> : thm
<a name="line11"></a>    val <a href="#ord_less_def-val">ord_less_def</a> : thm
<a name="line12"></a>    val <a href="#osyntax_TY_DEF-val">osyntax_TY_DEF</a> : thm
<a name="line13"></a>    val <a href="#osyntax_case_def-val">osyntax_case_def</a> : thm
<a name="line14"></a>    val <a href="#osyntax_size_def-val">osyntax_size_def</a> : thm
<a name="line15"></a>    val <a href="#padd_def-val">padd_def</a> : thm
<a name="line16"></a>    val <a href="#rank_def-val">rank_def</a> : thm
<a name="line17"></a>    val <a href="#restn_def-val">restn_def</a> : thm
<a name="line18"></a>    val <a href="#tail_def-val">tail_def</a> : thm
<a name="line19"></a>  
<a name="line20"></a>  (*  Theorems  *)
<a name="line21"></a>    val <a href="#WF_ord_less-val">WF_ord_less</a> : thm
<a name="line22"></a>    val <a href="#datatype_osyntax-val">datatype_osyntax</a> : thm
<a name="line23"></a>    val <a href="#decompose_plus-val">decompose_plus</a> : thm
<a name="line24"></a>    val <a href="#e0_INDUCTION-val">e0_INDUCTION</a> : thm
<a name="line25"></a>    val <a href="#e0_RECURSION-val">e0_RECURSION</a> : thm
<a name="line26"></a>    val <a href="#is_ord_cases-val">is_ord_cases</a> : thm
<a name="line27"></a>    val <a href="#is_ord_coeff_pos-val">is_ord_coeff_pos</a> : thm
<a name="line28"></a>    val <a href="#is_ord_downclosed-val">is_ord_downclosed</a> : thm
<a name="line29"></a>    val <a href="#is_ord_equations-val">is_ord_equations</a> : thm
<a name="line30"></a>    val <a href="#is_ord_expt_closed-val">is_ord_expt_closed</a> : thm
<a name="line31"></a>    val <a href="#is_ord_ind-val">is_ord_ind</a> : thm
<a name="line32"></a>    val <a href="#is_ord_rules-val">is_ord_rules</a> : thm
<a name="line33"></a>    val <a href="#is_ord_strong_ind-val">is_ord_strong_ind</a> : thm
<a name="line34"></a>    val <a href="#is_ord_strongind-val">is_ord_strongind</a> : thm
<a name="line35"></a>    val <a href="#is_ord_tail_closed-val">is_ord_tail_closed</a> : thm
<a name="line36"></a>    val <a href="#lemma-val">lemma</a> : thm
<a name="line37"></a>    val <a href="#main_lemma-val">main_lemma</a> : thm
<a name="line38"></a>    val <a href="#oless_End_End-val">oless_End_End</a> : thm
<a name="line39"></a>    val <a href="#oless_antirefl-val">oless_antirefl</a> : thm
<a name="line40"></a>    val <a href="#oless_antisym-val">oless_antisym</a> : thm
<a name="line41"></a>    val <a href="#oless_cases-val">oless_cases</a> : thm
<a name="line42"></a>    val <a href="#oless_equations-val">oless_equations</a> : thm
<a name="line43"></a>    val <a href="#oless_expt-val">oless_expt</a> : thm
<a name="line44"></a>    val <a href="#oless_imp_rank_leq-val">oless_imp_rank_leq</a> : thm
<a name="line45"></a>    val <a href="#oless_ind-val">oless_ind</a> : thm
<a name="line46"></a>    val <a href="#oless_rules-val">oless_rules</a> : thm
<a name="line47"></a>    val <a href="#oless_strong_ind-val">oless_strong_ind</a> : thm
<a name="line48"></a>    val <a href="#oless_strongind-val">oless_strongind</a> : thm
<a name="line49"></a>    val <a href="#oless_tail-val">oless_tail</a> : thm
<a name="line50"></a>    val <a href="#ord_add_def-val">ord_add_def</a> : thm
<a name="line51"></a>    val <a href="#ord_add_ind-val">ord_add_ind</a> : thm
<a name="line52"></a>    val <a href="#ord_mult_def-val">ord_mult_def</a> : thm
<a name="line53"></a>    val <a href="#ord_mult_ind-val">ord_mult_ind</a> : thm
<a name="line54"></a>    val <a href="#ord_sub_def-val">ord_sub_def</a> : thm
<a name="line55"></a>    val <a href="#ord_sub_ind-val">ord_sub_ind</a> : thm
<a name="line56"></a>    val <a href="#osyntax_11-val">osyntax_11</a> : thm
<a name="line57"></a>    val <a href="#osyntax_Axiom-val">osyntax_Axiom</a> : thm
<a name="line58"></a>    val <a href="#osyntax_case_cong-val">osyntax_case_cong</a> : thm
<a name="line59"></a>    val <a href="#osyntax_case_eq-val">osyntax_case_eq</a> : thm
<a name="line60"></a>    val <a href="#osyntax_distinct-val">osyntax_distinct</a> : thm
<a name="line61"></a>    val <a href="#osyntax_induction-val">osyntax_induction</a> : thm
<a name="line62"></a>    val <a href="#osyntax_nchotomy-val">osyntax_nchotomy</a> : thm
<a name="line63"></a>    val <a href="#padd_compute-val">padd_compute</a> : thm
<a name="line64"></a>    val <a href="#pmult_def-val">pmult_def</a> : thm
<a name="line65"></a>    val <a href="#pmult_ind-val">pmult_ind</a> : thm
<a name="line66"></a>    val <a href="#rank_0_End-val">rank_0_End</a> : thm
<a name="line67"></a>    val <a href="#rank_expt-val">rank_expt</a> : thm
<a name="line68"></a>    val <a href="#rank_finp-val">rank_finp</a> : thm
<a name="line69"></a>    val <a href="#rank_less_imp_oless-val">rank_less_imp_oless</a> : thm
<a name="line70"></a>    val <a href="#rank_positive-val">rank_positive</a> : thm
<a name="line71"></a>    val <a href="#rank_positive_exists-val">rank_positive_exists</a> : thm
<a name="line72"></a>    val <a href="#rank_positive_expt-val">rank_positive_expt</a> : thm
<a name="line73"></a>    val <a href="#restn_compute-val">restn_compute</a> : thm
<a name="line74"></a>  
<a name="line75"></a>  val ordinalNotation_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line76"></a>(*
   [indexedLists] Parent theory of "ordinalNotation"
   
   [patternMatches] Parent theory of "ordinalNotation"
   
   [<a name="cf1_def-val"><b>cf1_def</b></a>]  Definition
      
      ⊢ (∀v0 b. cf1 (End v0) b = 0) ∧
        ∀e1 c1 k1 b.
          cf1 (Plus e1 c1 k1) b =
          if ord_less (expt b) e1 then 1 + cf1 k1 b else 0
   
   [<a name="cf2_def-val"><b>cf2_def</b></a>]  Definition
      
      ⊢ ∀a b n. cf2 a b n = n + cf1 (restn a n) b
   
   [<a name="coeff_def-val"><b>coeff_def</b></a>]  Definition
      
      ⊢ (∀x. coeff (End x) = x) ∧ ∀e k t. coeff (Plus e k t) = k
   
   [<a name="expt_def-val"><b>expt_def</b></a>]  Definition
      
      ⊢ (∀v0. expt (End v0) = End 0) ∧ ∀e k t. expt (Plus e k t) = e
   
   [<a name="finp_def-val"><b>finp_def</b></a>]  Definition
      
      ⊢ (∀v0. finp (End v0) ⇔ T) ∧ ∀v1 v2 v3. finp (Plus v1 v2 v3) ⇔ F
   
   [<a name="ord_less_def-val"><b>ord_less_def</b></a>]  Definition
      
      ⊢ ∀x y. ord_less x y ⇔ is_ord x ∧ is_ord y ∧ oless x y
   
   [<a name="osyntax_TY_DEF-val"><b>osyntax_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep.
          TYPE_DEFINITION
            (λa0'.
                 ∀ $var$('osyntax').
                   (∀a0'.
                      (∃a. a0' =
                           (λa. ind_type$CONSTR 0 a (λn. ind_type$BOTTOM))
                             a) ∨
                      (∃a0 a1 a2.
                         (a0' =
                          (λa0 a1 a2.
                               ind_type$CONSTR (SUC 0) a1
                                 (ind_type$FCONS a0
                                    (ind_type$FCONS a2
                                       (λn. ind_type$BOTTOM)))) a0 a1 a2) ∧
                         $var$('osyntax') a0 ∧ $var$('osyntax') a2) ⇒
                      $var$('osyntax') a0') ⇒
                   $var$('osyntax') a0') rep
   
   [<a name="osyntax_case_def-val"><b>osyntax_case_def</b></a>]  Definition
      
      ⊢ (∀a f f1. osyntax_CASE (End a) f f1 = f a) ∧
        ∀a0 a1 a2 f f1. osyntax_CASE (Plus a0 a1 a2) f f1 = f1 a0 a1 a2
   
   [<a name="osyntax_size_def-val"><b>osyntax_size_def</b></a>]  Definition
      
      ⊢ (∀a. osyntax_size (End a) = 1 + a) ∧
        ∀a0 a1 a2.
          osyntax_size (Plus a0 a1 a2) =
          1 + (osyntax_size a0 + (a1 + osyntax_size a2))
   
   [<a name="padd_def-val"><b>padd_def</b></a>]  Definition
      
      ⊢ (∀a b. padd a b 0 = ord_add a b) ∧
        ∀a b n.
          padd a b (SUC n) = Plus (expt a) (coeff a) (padd (tail a) b n)
   
   [<a name="rank_def-val"><b>rank_def</b></a>]  Definition
      
      ⊢ (∀v0. rank (End v0) = 0) ∧ ∀e k t. rank (Plus e k t) = 1 + rank e
   
   [<a name="restn_def-val"><b>restn_def</b></a>]  Definition
      
      ⊢ (∀a. restn a 0 = a) ∧ ∀a n. restn a (SUC n) = restn (tail a) n
   
   [<a name="tail_def-val"><b>tail_def</b></a>]  Definition
      
      ⊢ ∀e k t. tail (Plus e k t) = t
   
   [<a name="WF_ord_less-val"><b>WF_ord_less</b></a>]  Theorem
      
      ⊢ WF ord_less
   
   [<a name="datatype_osyntax-val"><b>datatype_osyntax</b></a>]  Theorem
      
      ⊢ DATATYPE (osyntax End Plus)
   
   [<a name="decompose_plus-val"><b>decompose_plus</b></a>]  Theorem
      
      ⊢ ∀e k t.
          is_ord (Plus e k t) ⇒
          is_ord e ∧ e ≠ End 0 ∧ 0 &lt; k ∧ is_ord t ∧ oless (expt t) e
   
   [<a name="e0_INDUCTION-val"><b>e0_INDUCTION</b></a>]  Theorem
      
      ⊢ ∀P f. (∀x. (∀y. ord_less (f y) (f x) ⇒ P y) ⇒ P x) ⇒ ∀x. P x
   
   [<a name="e0_RECURSION-val"><b>e0_RECURSION</b></a>]  Theorem
      
      ⊢ ∀f. ∃!g. ∀x. g x = M (RESTRICT g (λx y. ord_less (f x) (f y)) x) x
   
   [<a name="is_ord_cases-val"><b>is_ord_cases</b></a>]  Theorem
      
      ⊢ ∀a0.
          is_ord a0 ⇔
          (∃k. a0 = End k) ∨
          ∃e k t.
            (a0 = Plus e k t) ∧ is_ord e ∧ e ≠ End 0 ∧ 0 &lt; k ∧ is_ord t ∧
            oless (expt t) e
   
   [<a name="is_ord_coeff_pos-val"><b>is_ord_coeff_pos</b></a>]  Theorem
      
      ⊢ ∀x. ¬finp x ∧ is_ord x ⇒ 0 &lt; coeff x
   
   [<a name="is_ord_downclosed-val"><b>is_ord_downclosed</b></a>]  Theorem
      
      ⊢ is_ord (Plus w k t) ⇒ is_ord w ∧ is_ord t
   
   [<a name="is_ord_equations-val"><b>is_ord_equations</b></a>]  Theorem
      
      ⊢ (is_ord (End k) ⇔ T) ∧
        (is_ord (Plus e k t) ⇔
         is_ord e ∧ e ≠ End 0 ∧ 0 &lt; k ∧ is_ord t ∧ oless (expt t) e)
   
   [<a name="is_ord_expt_closed-val"><b>is_ord_expt_closed</b></a>]  Theorem
      
      ⊢ ∀x. is_ord x ⇒ is_ord (expt x)
   
   [<a name="is_ord_ind-val"><b>is_ord_ind</b></a>]  Theorem
      
      ⊢ ∀is_ord'.
          (∀k. is_ord' (End k)) ∧
          (∀e k t.
             is_ord' e ∧ e ≠ End 0 ∧ 0 &lt; k ∧ is_ord' t ∧ oless (expt t) e ⇒
             is_ord' (Plus e k t)) ⇒
          ∀a0. is_ord a0 ⇒ is_ord' a0
   
   [<a name="is_ord_rules-val"><b>is_ord_rules</b></a>]  Theorem
      
      ⊢ (∀k. is_ord (End k)) ∧
        ∀e k t.
          is_ord e ∧ e ≠ End 0 ∧ 0 &lt; k ∧ is_ord t ∧ oless (expt t) e ⇒
          is_ord (Plus e k t)
   
   [<a name="is_ord_strong_ind-val"><b>is_ord_strong_ind</b></a>]  Theorem
      
      ⊢ ∀is_ord'.
          (∀k. is_ord' (End k)) ∧
          (∀e k t.
             is_ord e ∧ is_ord' e ∧ e ≠ End 0 ∧ 0 &lt; k ∧ is_ord t ∧
             is_ord' t ∧ oless (expt t) e ⇒
             is_ord' (Plus e k t)) ⇒
          ∀a0. is_ord a0 ⇒ is_ord' a0
   
   [<a name="is_ord_strongind-val"><b>is_ord_strongind</b></a>]  Theorem
      
      ⊢ ∀is_ord'.
          (∀k. is_ord' (End k)) ∧
          (∀e k t.
             is_ord e ∧ is_ord' e ∧ e ≠ End 0 ∧ 0 &lt; k ∧ is_ord t ∧
             is_ord' t ∧ oless (expt t) e ⇒
             is_ord' (Plus e k t)) ⇒
          ∀a0. is_ord a0 ⇒ is_ord' a0
   
   [<a name="is_ord_tail_closed-val"><b>is_ord_tail_closed</b></a>]  Theorem
      
      ⊢ ∀x. ¬finp x ∧ is_ord x ⇒ is_ord (tail x)
   
   [<a name="lemma-val"><b>lemma</b></a>]  Theorem
      
      ⊢ ∀n P.
          (∃x. is_ord x ∧ P x ∧ rank x ≤ n) ⇒
          ∃m. is_ord m ∧ P m ∧ rank m ≤ n ∧
              ∀y. is_ord y ∧ rank y ≤ n ∧ oless y m ⇒ ¬P y
   
   [<a name="main_lemma-val"><b>main_lemma</b></a>]  Theorem
      
      ⊢ ∀P. (∃x. P x ∧ is_ord x) ⇒
            ∃x. P x ∧ is_ord x ∧ ∀y. is_ord y ∧ oless y x ⇒ ¬P y
   
   [<a name="oless_End_End-val"><b>oless_End_End</b></a>]  Theorem
      
      ⊢ ∀k1 k2. oless (End k1) (End k2) ⇒ k1 &lt; k2
   
   [<a name="oless_antirefl-val"><b>oless_antirefl</b></a>]  Theorem
      
      ⊢ ∀x. is_ord x ⇒ ¬oless x x
   
   [<a name="oless_antisym-val"><b>oless_antisym</b></a>]  Theorem
      
      ⊢ ∀x y. is_ord x ∧ is_ord y ∧ oless x y ⇒ ¬oless y x
   
   [<a name="oless_cases-val"><b>oless_cases</b></a>]  Theorem
      
      ⊢ ∀a0 a1.
          oless a0 a1 ⇔
          (∃k1 k2. (a0 = End k1) ∧ (a1 = End k2) ∧ k1 &lt; k2) ∨
          (∃k1 e2 k2 t2. (a0 = End k1) ∧ (a1 = Plus e2 k2 t2)) ∨
          (∃e1 k1 t1 e2 k2 t2.
             (a0 = Plus e1 k1 t1) ∧ (a1 = Plus e2 k2 t2) ∧ oless e1 e2) ∨
          (∃e1 k1 t1 e2 k2 t2.
             (a0 = Plus e1 k1 t1) ∧ (a1 = Plus e2 k2 t2) ∧ (e1 = e2) ∧
             k1 &lt; k2) ∨
          ∃e1 k1 t1 e2 k2 t2.
            (a0 = Plus e1 k1 t1) ∧ (a1 = Plus e2 k2 t2) ∧ (e1 = e2) ∧
            (k1 = k2) ∧ oless t1 t2
   
   [<a name="oless_equations-val"><b>oless_equations</b></a>]  Theorem
      
      ⊢ (oless (End m) (End n) ⇔ m &lt; n) ∧
        (oless (End m) (Plus e k t) ⇔ T) ∧
        (oless (Plus e k t) (End m) ⇔ F) ∧
        (oless (Plus e1 k1 t1) (Plus e2 k2 t2) ⇔
         if oless e1 e2 then T
         else if (e1 = e2) ∧ k1 &lt; k2 then T
         else if (e1 = e2) ∧ (k1 = k2) ∧ oless t1 t2 then T
         else F)
   
   [<a name="oless_expt-val"><b>oless_expt</b></a>]  Theorem
      
      ⊢ ∀e k t. is_ord (Plus e k t) ⇒ oless e (Plus e k t)
   
   [<a name="oless_imp_rank_leq-val"><b>oless_imp_rank_leq</b></a>]  Theorem
      
      ⊢ ∀x y. is_ord x ∧ is_ord y ∧ oless x y ⇒ rank x ≤ rank y
   
   [<a name="oless_ind-val"><b>oless_ind</b></a>]  Theorem
      
      ⊢ ∀oless'.
          (∀k1 k2. k1 &lt; k2 ⇒ oless' (End k1) (End k2)) ∧
          (∀k1 e2 k2 t2. oless' (End k1) (Plus e2 k2 t2)) ∧
          (∀e1 k1 t1 e2 k2 t2.
             oless' e1 e2 ⇒ oless' (Plus e1 k1 t1) (Plus e2 k2 t2)) ∧
          (∀e1 k1 t1 e2 k2 t2.
             (e1 = e2) ∧ k1 &lt; k2 ⇒ oless' (Plus e1 k1 t1) (Plus e2 k2 t2)) ∧
          (∀e1 k1 t1 e2 k2 t2.
             (e1 = e2) ∧ (k1 = k2) ∧ oless' t1 t2 ⇒
             oless' (Plus e1 k1 t1) (Plus e2 k2 t2)) ⇒
          ∀a0 a1. oless a0 a1 ⇒ oless' a0 a1
   
   [<a name="oless_rules-val"><b>oless_rules</b></a>]  Theorem
      
      ⊢ (∀k1 k2. k1 &lt; k2 ⇒ oless (End k1) (End k2)) ∧
        (∀k1 e2 k2 t2. oless (End k1) (Plus e2 k2 t2)) ∧
        (∀e1 k1 t1 e2 k2 t2.
           oless e1 e2 ⇒ oless (Plus e1 k1 t1) (Plus e2 k2 t2)) ∧
        (∀e1 k1 t1 e2 k2 t2.
           (e1 = e2) ∧ k1 &lt; k2 ⇒ oless (Plus e1 k1 t1) (Plus e2 k2 t2)) ∧
        ∀e1 k1 t1 e2 k2 t2.
          (e1 = e2) ∧ (k1 = k2) ∧ oless t1 t2 ⇒
          oless (Plus e1 k1 t1) (Plus e2 k2 t2)
   
   [<a name="oless_strong_ind-val"><b>oless_strong_ind</b></a>]  Theorem
      
      ⊢ ∀oless'.
          (∀k1 k2. k1 &lt; k2 ⇒ oless' (End k1) (End k2)) ∧
          (∀k1 e2 k2 t2. oless' (End k1) (Plus e2 k2 t2)) ∧
          (∀e1 k1 t1 e2 k2 t2.
             oless e1 e2 ∧ oless' e1 e2 ⇒
             oless' (Plus e1 k1 t1) (Plus e2 k2 t2)) ∧
          (∀e1 k1 t1 e2 k2 t2.
             (e1 = e2) ∧ k1 &lt; k2 ⇒ oless' (Plus e1 k1 t1) (Plus e2 k2 t2)) ∧
          (∀e1 k1 t1 e2 k2 t2.
             (e1 = e2) ∧ (k1 = k2) ∧ oless t1 t2 ∧ oless' t1 t2 ⇒
             oless' (Plus e1 k1 t1) (Plus e2 k2 t2)) ⇒
          ∀a0 a1. oless a0 a1 ⇒ oless' a0 a1
   
   [<a name="oless_strongind-val"><b>oless_strongind</b></a>]  Theorem
      
      ⊢ ∀oless'.
          (∀k1 k2. k1 &lt; k2 ⇒ oless' (End k1) (End k2)) ∧
          (∀k1 e2 k2 t2. oless' (End k1) (Plus e2 k2 t2)) ∧
          (∀e1 k1 t1 e2 k2 t2.
             oless e1 e2 ∧ oless' e1 e2 ⇒
             oless' (Plus e1 k1 t1) (Plus e2 k2 t2)) ∧
          (∀e1 k1 t1 e2 k2 t2.
             (e1 = e2) ∧ k1 &lt; k2 ⇒ oless' (Plus e1 k1 t1) (Plus e2 k2 t2)) ∧
          (∀e1 k1 t1 e2 k2 t2.
             (e1 = e2) ∧ (k1 = k2) ∧ oless t1 t2 ∧ oless' t1 t2 ⇒
             oless' (Plus e1 k1 t1) (Plus e2 k2 t2)) ⇒
          ∀a0 a1. oless a0 a1 ⇒ oless' a0 a1
   
   [<a name="oless_tail-val"><b>oless_tail</b></a>]  Theorem
      
      ⊢ ∀x. is_ord x ∧ ¬finp x ⇒ oless (tail x) x
   
   [<a name="ord_add_def-val"><b>ord_add_def</b></a>]  Theorem
      
      ⊢ (∀n m. ord_add (End m) (End n) = End (m + n)) ∧
        (∀t p m k. ord_add (End m) (Plus p k t) = Plus p k t) ∧
        (∀t m k e.
           ord_add (Plus e k t) (End m) = Plus e k (ord_add t (End m))) ∧
        ∀t2 t1 k2 k1 e2 e1.
          ord_add (Plus e1 k1 t1) (Plus e2 k2 t2) =
          if oless e1 e2 then Plus e2 k2 t2
          else if e1 = e2 then Plus e2 (k1 + k2) t2
          else Plus e1 k1 (ord_add t1 (Plus e2 k2 t2))
   
   [<a name="ord_add_ind-val"><b>ord_add_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀m n. P (End m) (End n)) ∧
            (∀m p k t. P (End m) (Plus p k t)) ∧
            (∀e k t m. P t (End m) ⇒ P (Plus e k t) (End m)) ∧
            (∀e1 k1 t1 e2 k2 t2.
               (¬oless e1 e2 ∧ e1 ≠ e2 ⇒ P t1 (Plus e2 k2 t2)) ⇒
               P (Plus e1 k1 t1) (Plus e2 k2 t2)) ⇒
            ∀v v1. P v v1
   
   [<a name="ord_mult_def-val"><b>ord_mult_def</b></a>]  Theorem
      
      ⊢ ∀y x.
          ord_mult x y =
          if (x = End 0) ∨ (y = End 0) then End 0
          else
            case (x,y) of
              (End m,End n) =&gt; End (m * n)
            | (End m,Plus e k t) =&gt;
              Plus (ord_add (End 0) e) k (ord_mult (End m) t)
            | (Plus e' k' t',End n') =&gt; Plus e' (k' * n') t'
            | (Plus e' k' t',Plus e2 k2 t2) =&gt;
              Plus (ord_add e' e2) k2 (ord_mult (Plus e' k' t') t2)
   
   [<a name="ord_mult_ind-val"><b>ord_mult_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀x y.
               (∀v v1 m e k t.
                  ¬((x = End 0) ∨ (y = End 0)) ∧ ((x,y) = (v,v1)) ∧
                  (v = End m) ∧ (v1 = Plus e k t) ⇒
                  P (End m) t) ∧
               (∀v v1 e' k' t' e2 k2 t2.
                  ¬((x = End 0) ∨ (y = End 0)) ∧ ((x,y) = (v,v1)) ∧
                  (v = Plus e' k' t') ∧ (v1 = Plus e2 k2 t2) ⇒
                  P (Plus e' k' t') t2) ⇒
               P x y) ⇒
            ∀v v1. P v v1
   
   [<a name="ord_sub_def-val"><b>ord_sub_def</b></a>]  Theorem
      
      ⊢ (∀n m. ord_sub (End m) (End n) = End (m − n)) ∧
        (∀t p m k. ord_sub (End m) (Plus p k t) = End 0) ∧
        (∀t m k e. ord_sub (Plus e k t) (End m) = Plus e k t) ∧
        ∀t2 t1 k2 k1 e2 e1.
          ord_sub (Plus e1 k1 t1) (Plus e2 k2 t2) =
          if oless e1 e2 then End 0
          else if e1 = e2 then
            if k1 &lt; k2 then End 0
            else if k1 &gt; k2 then Plus e1 (k1 − k2) t1
            else ord_sub t1 t2
          else Plus e1 k1 t1
   
   [<a name="ord_sub_ind-val"><b>ord_sub_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀m n. P (End m) (End n)) ∧
            (∀m p k t. P (End m) (Plus p k t)) ∧
            (∀e k t m. P (Plus e k t) (End m)) ∧
            (∀e1 k1 t1 e2 k2 t2.
               (¬oless e1 e2 ∧ (e1 = e2) ∧ ¬(k1 &lt; k2) ∧ ¬(k1 &gt; k2) ⇒
                P t1 t2) ⇒
               P (Plus e1 k1 t1) (Plus e2 k2 t2)) ⇒
            ∀v v1. P v v1
   
   [<a name="osyntax_11-val"><b>osyntax_11</b></a>]  Theorem
      
      ⊢ (∀a a'. (End a = End a') ⇔ (a = a')) ∧
        ∀a0 a1 a2 a0' a1' a2'.
          (Plus a0 a1 a2 = Plus a0' a1' a2') ⇔
          (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2')
   
   [<a name="osyntax_Axiom-val"><b>osyntax_Axiom</b></a>]  Theorem
      
      ⊢ ∀f0 f1. ∃fn.
          (∀a. fn (End a) = f0 a) ∧
          ∀a0 a1 a2. fn (Plus a0 a1 a2) = f1 a1 a0 a2 (fn a0) (fn a2)
   
   [<a name="osyntax_case_cong-val"><b>osyntax_case_cong</b></a>]  Theorem
      
      ⊢ ∀M M' f f1.
          (M = M') ∧ (∀a. (M' = End a) ⇒ (f a = f' a)) ∧
          (∀a0 a1 a2. (M' = Plus a0 a1 a2) ⇒ (f1 a0 a1 a2 = f1' a0 a1 a2)) ⇒
          (osyntax_CASE M f f1 = osyntax_CASE M' f' f1')
   
   [<a name="osyntax_case_eq-val"><b>osyntax_case_eq</b></a>]  Theorem
      
      ⊢ (osyntax_CASE x f f1 = v) ⇔
        (∃n. (x = End n) ∧ (f n = v)) ∨
        ∃o' n o0. (x = Plus o' n o0) ∧ (f1 o' n o0 = v)
   
   [<a name="osyntax_distinct-val"><b>osyntax_distinct</b></a>]  Theorem
      
      ⊢ ∀a2 a1 a0 a. End a ≠ Plus a0 a1 a2
   
   [<a name="osyntax_induction-val"><b>osyntax_induction</b></a>]  Theorem
      
      ⊢ ∀P. (∀n. P (End n)) ∧ (∀ $o o0. P $o ∧ P o0 ⇒ ∀n. P (Plus $o n o0)) ⇒
            ∀ $o. P $o
   
   [<a name="osyntax_nchotomy-val"><b>osyntax_nchotomy</b></a>]  Theorem
      
      ⊢ ∀oo. (∃n. oo = End n) ∨ ∃ $o n o0. oo = Plus $o n o0
   
   [<a name="padd_compute-val"><b>padd_compute</b></a>]  Theorem
      
      ⊢ (∀a b. padd a b 0 = ord_add a b) ∧
        (∀a b n.
           padd a b (NUMERAL (BIT1 n)) =
           Plus (expt a) (coeff a) (padd (tail a) b (NUMERAL (BIT1 n) − 1))) ∧
        ∀a b n.
          padd a b (NUMERAL (BIT2 n)) =
          Plus (expt a) (coeff a) (padd (tail a) b (NUMERAL (BIT1 n)))
   
   [<a name="pmult_def-val"><b>pmult_def</b></a>]  Theorem
      
      ⊢ ∀n b a.
          pmult a b n =
          if (a = End 0) ∨ (b = End 0) then End 0
          else
            case (a,b) of
              (End i,End j) =&gt; End (i * j)
            | (Plus e1 c1 k1,End j) =&gt; Plus e1 (c1 * j) k1
            | (v,Plus e2 c2 k2) =&gt;
              (let
                 m = cf2 (expt a) e2 n
               in
                 Plus (padd (expt a) e2 m) c2 (pmult a k2 m))
   
   [<a name="pmult_ind-val"><b>pmult_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀a b n.
               (∀v v1 e2 c2 k2 m.
                  ¬((a = End 0) ∨ (b = End 0)) ∧ ((a,b) = (v,v1)) ∧
                  (v1 = Plus e2 c2 k2) ∧ (m = cf2 (expt a) e2 n) ⇒
                  P a k2 m) ⇒
               P a b n) ⇒
            ∀v v1 v2. P v v1 v2
   
   [<a name="rank_0_End-val"><b>rank_0_End</b></a>]  Theorem
      
      ⊢ ∀x. (rank x = 0) ⇔ ∃n. x = End n
   
   [<a name="rank_expt-val"><b>rank_expt</b></a>]  Theorem
      
      ⊢ ∀x n. is_ord x ∧ (rank x = SUC n) ⇒ (rank (expt x) = n)
   
   [<a name="rank_finp-val"><b>rank_finp</b></a>]  Theorem
      
      ⊢ ∀x. (rank x = 0) ⇔ finp x
   
   [<a name="rank_less_imp_oless-val"><b>rank_less_imp_oless</b></a>]  Theorem
      
      ⊢ ∀x y. is_ord x ∧ is_ord y ∧ rank x &lt; rank y ⇒ oless x y
   
   [<a name="rank_positive-val"><b>rank_positive</b></a>]  Theorem
      
      ⊢ ∀x. 0 &lt; rank x ⇔ (x = Plus (expt x) (coeff x) (tail x))
   
   [<a name="rank_positive_exists-val"><b>rank_positive_exists</b></a>]  Theorem
      
      ⊢ ∀x. 0 &lt; rank x ⇔ ∃e c t. x = Plus e c t
   
   [<a name="rank_positive_expt-val"><b>rank_positive_expt</b></a>]  Theorem
      
      ⊢ ∀x n. (rank x = SUC n) ⇒ (rank (expt x) = n)
   
   [<a name="restn_compute-val"><b>restn_compute</b></a>]  Theorem
      
      ⊢ (∀a. restn a 0 = a) ∧
        (∀a n.
           restn a (NUMERAL (BIT1 n)) =
           restn (tail a) (NUMERAL (BIT1 n) − 1)) ∧
        ∀a n.
          restn a (NUMERAL (BIT2 n)) = restn (tail a) (NUMERAL (BIT1 n))
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/pred_set/src/more_theories/ordinalNotationScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-1</a></em></p></body></html>
