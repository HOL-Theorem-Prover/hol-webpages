<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure pairTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure pairTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/coretypes/pairScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature pairTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#ABS_REP_prod-val">ABS_REP_prod</a> : thm
<a name="line7"></a>    val <a href="#COMMA_DEF-val">COMMA_DEF</a> : thm
<a name="line8"></a>    val <a href="#CURRY_DEF-val">CURRY_DEF</a> : thm
<a name="line9"></a>    val <a href="#LEX_DEF-val">LEX_DEF</a> : thm
<a name="line10"></a>    val <a href="#PAIR-val">PAIR</a> : thm
<a name="line11"></a>    val <a href="#PAIR_MAP-val">PAIR_MAP</a> : thm
<a name="line12"></a>    val <a href="#PAIR_SET_def-val">PAIR_SET_def</a> : thm
<a name="line13"></a>    val <a href="#PROD_ALL_def-val">PROD_ALL_def</a> : thm
<a name="line14"></a>    val <a href="#RPROD_DEF-val">RPROD_DEF</a> : thm
<a name="line15"></a>    val <a href="#SWAP_def-val">SWAP_def</a> : thm
<a name="line16"></a>    val <a href="#UNCURRY-val">UNCURRY</a> : thm
<a name="line17"></a>    val <a href="#pair_CASE_def-val">pair_CASE_def</a> : thm
<a name="line18"></a>    val <a href="#prod_TY_DEF-val">prod_TY_DEF</a> : thm
<a name="line19"></a>  
<a name="line20"></a>  (*  Theorems  *)
<a name="line21"></a>    val <a href="#ABS_PAIR_THM-val">ABS_PAIR_THM</a> : thm
<a name="line22"></a>    val <a href="#CLOSED_PAIR_EQ-val">CLOSED_PAIR_EQ</a> : thm
<a name="line23"></a>    val <a href="#COMMA_PRS-val">COMMA_PRS</a> : thm
<a name="line24"></a>    val <a href="#COMMA_RSP-val">COMMA_RSP</a> : thm
<a name="line25"></a>    val <a href="#CURRY_ONE_ONE_THM-val">CURRY_ONE_ONE_THM</a> : thm
<a name="line26"></a>    val <a href="#CURRY_PRS-val">CURRY_PRS</a> : thm
<a name="line27"></a>    val <a href="#CURRY_RSP-val">CURRY_RSP</a> : thm
<a name="line28"></a>    val <a href="#CURRY_UNCURRY_THM-val">CURRY_UNCURRY_THM</a> : thm
<a name="line29"></a>    val <a href="#C_UNCURRY_L-val">C_UNCURRY_L</a> : thm
<a name="line30"></a>    val <a href="#ELIM_PEXISTS-val">ELIM_PEXISTS</a> : thm
<a name="line31"></a>    val <a href="#ELIM_PEXISTS_EVAL-val">ELIM_PEXISTS_EVAL</a> : thm
<a name="line32"></a>    val <a href="#ELIM_PFORALL-val">ELIM_PFORALL</a> : thm
<a name="line33"></a>    val <a href="#ELIM_PFORALL_EVAL-val">ELIM_PFORALL_EVAL</a> : thm
<a name="line34"></a>    val <a href="#ELIM_UNCURRY-val">ELIM_UNCURRY</a> : thm
<a name="line35"></a>    val <a href="#EXISTS_PROD-val">EXISTS_PROD</a> : thm
<a name="line36"></a>    val <a href="#FORALL_PROD-val">FORALL_PROD</a> : thm
<a name="line37"></a>    val <a href="#FORALL_UNCURRY-val">FORALL_UNCURRY</a> : thm
<a name="line38"></a>    val <a href="#FST-val">FST</a> : thm
<a name="line39"></a>    val <a href="#FST_EQ_EQUIV-val">FST_EQ_EQUIV</a> : thm
<a name="line40"></a>    val <a href="#FST_PAIR_MAP-val">FST_PAIR_MAP</a> : thm
<a name="line41"></a>    val <a href="#FST_PRS-val">FST_PRS</a> : thm
<a name="line42"></a>    val <a href="#FST_RSP-val">FST_RSP</a> : thm
<a name="line43"></a>    val <a href="#IN_PAIR_SET-val">IN_PAIR_SET</a> : thm
<a name="line44"></a>    val <a href="#IN_UNCURRY_R-val">IN_UNCURRY_R</a> : thm
<a name="line45"></a>    val <a href="#IN_setFSTSND-val">IN_setFSTSND</a> : thm
<a name="line46"></a>    val <a href="#LAMBDA_PROD-val">LAMBDA_PROD</a> : thm
<a name="line47"></a>    val <a href="#LET2_RAND-val">LET2_RAND</a> : thm
<a name="line48"></a>    val <a href="#LET2_RATOR-val">LET2_RATOR</a> : thm
<a name="line49"></a>    val <a href="#LEX_CONG-val">LEX_CONG</a> : thm
<a name="line50"></a>    val <a href="#LEX_DEF_THM-val">LEX_DEF_THM</a> : thm
<a name="line51"></a>    val <a href="#LEX_MONO-val">LEX_MONO</a> : thm
<a name="line52"></a>    val <a href="#PAIR_EQ-val">PAIR_EQ</a> : thm
<a name="line53"></a>    val <a href="#PAIR_EQUIV-val">PAIR_EQUIV</a> : thm
<a name="line54"></a>    val <a href="#PAIR_FST_SND_EQ-val">PAIR_FST_SND_EQ</a> : thm
<a name="line55"></a>    val <a href="#PAIR_FUN_THM-val">PAIR_FUN_THM</a> : thm
<a name="line56"></a>    val <a href="#PAIR_MAP_CONG-val">PAIR_MAP_CONG</a> : thm
<a name="line57"></a>    val <a href="#PAIR_MAP_I-val">PAIR_MAP_I</a> : thm
<a name="line58"></a>    val <a href="#PAIR_MAP_PRS-val">PAIR_MAP_PRS</a> : thm
<a name="line59"></a>    val <a href="#PAIR_MAP_RSP-val">PAIR_MAP_RSP</a> : thm
<a name="line60"></a>    val <a href="#PAIR_MAP_SET-val">PAIR_MAP_SET</a> : thm
<a name="line61"></a>    val <a href="#PAIR_MAP_THM-val">PAIR_MAP_THM</a> : thm
<a name="line62"></a>    val <a href="#PAIR_QUOTIENT-val">PAIR_QUOTIENT</a> : thm
<a name="line63"></a>    val <a href="#PAIR_REL-val">PAIR_REL</a> : thm
<a name="line64"></a>    val <a href="#PAIR_REL_EQ-val">PAIR_REL_EQ</a> : thm
<a name="line65"></a>    val <a href="#PAIR_REL_REFL-val">PAIR_REL_REFL</a> : thm
<a name="line66"></a>    val <a href="#PAIR_REL_SYM-val">PAIR_REL_SYM</a> : thm
<a name="line67"></a>    val <a href="#PAIR_REL_THM-val">PAIR_REL_THM</a> : thm
<a name="line68"></a>    val <a href="#PAIR_REL_TRANS-val">PAIR_REL_TRANS</a> : thm
<a name="line69"></a>    val <a href="#PEXISTS_THM-val">PEXISTS_THM</a> : thm
<a name="line70"></a>    val <a href="#PFORALL_THM-val">PFORALL_THM</a> : thm
<a name="line71"></a>    val <a href="#PROD_ALL_CONG-val">PROD_ALL_CONG</a> : thm
<a name="line72"></a>    val <a href="#PROD_ALL_MONO-val">PROD_ALL_MONO</a> : thm
<a name="line73"></a>    val <a href="#PROD_ALL_THM-val">PROD_ALL_THM</a> : thm
<a name="line74"></a>    val <a href="#SND-val">SND</a> : thm
<a name="line75"></a>    val <a href="#SND_EQ_EQUIV-val">SND_EQ_EQUIV</a> : thm
<a name="line76"></a>    val <a href="#SND_PAIR_MAP-val">SND_PAIR_MAP</a> : thm
<a name="line77"></a>    val <a href="#SND_PRS-val">SND_PRS</a> : thm
<a name="line78"></a>    val <a href="#SND_RSP-val">SND_RSP</a> : thm
<a name="line79"></a>    val <a href="#SWAP_SWAP-val">SWAP_SWAP</a> : thm
<a name="line80"></a>    val <a href="#S_UNCURRY_R-val">S_UNCURRY_R</a> : thm
<a name="line81"></a>    val <a href="#UNCURRY_CONG-val">UNCURRY_CONG</a> : thm
<a name="line82"></a>    val <a href="#UNCURRY_CURRY_THM-val">UNCURRY_CURRY_THM</a> : thm
<a name="line83"></a>    val <a href="#UNCURRY_DEF-val">UNCURRY_DEF</a> : thm
<a name="line84"></a>    val <a href="#UNCURRY_ONE_ONE_THM-val">UNCURRY_ONE_ONE_THM</a> : thm
<a name="line85"></a>    val <a href="#UNCURRY_PRS-val">UNCURRY_PRS</a> : thm
<a name="line86"></a>    val <a href="#UNCURRY_RSP-val">UNCURRY_RSP</a> : thm
<a name="line87"></a>    val <a href="#UNCURRY_VAR-val">UNCURRY_VAR</a> : thm
<a name="line88"></a>    val <a href="#WF_LEX-val">WF_LEX</a> : thm
<a name="line89"></a>    val <a href="#WF_RPROD-val">WF_RPROD</a> : thm
<a name="line90"></a>    val <a href="#datatype_pair-val">datatype_pair</a> : thm
<a name="line91"></a>    val <a href="#o_UNCURRY_R-val">o_UNCURRY_R</a> : thm
<a name="line92"></a>    val <a href="#pair_Axiom-val">pair_Axiom</a> : thm
<a name="line93"></a>    val <a href="#pair_CASES-val">pair_CASES</a> : thm
<a name="line94"></a>    val <a href="#pair_case_cong-val">pair_case_cong</a> : thm
<a name="line95"></a>    val <a href="#pair_case_def-val">pair_case_def</a> : thm
<a name="line96"></a>    val <a href="#pair_case_eq-val">pair_case_eq</a> : thm
<a name="line97"></a>    val <a href="#pair_case_ho_elim-val">pair_case_ho_elim</a> : thm
<a name="line98"></a>    val <a href="#pair_case_thm-val">pair_case_thm</a> : thm
<a name="line99"></a>    val <a href="#pair_induction-val">pair_induction</a> : thm
<a name="line100"></a>    val <a href="#reflexive_LEX-val">reflexive_LEX</a> : thm
<a name="line101"></a>    val <a href="#symmetric_LEX-val">symmetric_LEX</a> : thm
<a name="line102"></a>    val <a href="#total_LEX-val">total_LEX</a> : thm
<a name="line103"></a>    val <a href="#transitive_LEX-val">transitive_LEX</a> : thm
<a name="line104"></a>  
<a name="line105"></a>  val pair_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line106"></a>  
<a name="line107"></a>  val pair_rws : thm list
<a name="line108"></a>  
<a name="line109"></a>  type hol_type = Abbrev.hol_type
<a name="line110"></a>  type term     = Abbrev.term
<a name="line111"></a>  type conv     = Abbrev.conv
<a name="line112"></a>  
<a name="line113"></a>  val uncurry_tm       : term
<a name="line114"></a>  val comma_tm         : term
<a name="line115"></a>  val dest_pair        : term -&gt; term * term
<a name="line116"></a>  val strip_pair       : term -&gt; term list
<a name="line117"></a>  val spine_pair       : term -&gt; term list
<a name="line118"></a>  val is_vstruct       : term -&gt; bool
<a name="line119"></a>  val mk_pabs          : term * term -&gt; term
<a name="line120"></a>  val PAIRED_BETA_CONV : conv
<a name="line121"></a>  
<a name="line122"></a>(*
   [quotient] Parent theory of "pair"
   
   [relation] Parent theory of "pair"
   
   [<a name="ABS_REP_prod-val"><b>ABS_REP_prod</b></a>]  Definition
      
      ⊢ (∀a. ABS_prod (REP_prod a) = a) ∧
        ∀r. (λp. ∃x y. p = (λa b. a = x ∧ b = y)) r ⇔
            REP_prod (ABS_prod r) = r
   
   [<a name="COMMA_DEF-val"><b>COMMA_DEF</b></a>]  Definition
      
      ⊢ ∀x y. (x,y) = ABS_prod (λa b. a = x ∧ b = y)
   
   [<a name="CURRY_DEF-val"><b>CURRY_DEF</b></a>]  Definition
      
      ⊢ ∀f x y. CURRY f x y = f (x,y)
   
   [<a name="LEX_DEF-val"><b>LEX_DEF</b></a>]  Definition
      
      ⊢ ∀R1 R2. R1 LEX R2 = (λ(s,t) (u,v). R1 s u ∨ s = u ∧ R2 t v)
   
   [<a name="PAIR-val"><b>PAIR</b></a>]  Definition
      
      ⊢ ∀x. (FST x,SND x) = x
   
   [<a name="PAIR_MAP-val"><b>PAIR_MAP</b></a>]  Definition
      
      ⊢ ∀f g p. (f ## g) p = (f (FST p),g (SND p))
   
   [<a name="PAIR_SET_def-val"><b>PAIR_SET_def</b></a>]  Definition
      
      ⊢ ∀f g. PAIR_SET f g = (λ(a,b) c. c ∈ f a ∨ c ∈ g b)
   
   [<a name="PROD_ALL_def-val"><b>PROD_ALL_def</b></a>]  Definition
      
      ⊢ ∀P Q p. PROD_ALL P Q p ⇔ P (FST p) ∧ Q (SND p)
   
   [<a name="RPROD_DEF-val"><b>RPROD_DEF</b></a>]  Definition
      
      ⊢ ∀R1 R2. R1 ### R2 = (λ(s,t) (u,v). R1 s u ∧ R2 t v)
   
   [<a name="SWAP_def-val"><b>SWAP_def</b></a>]  Definition
      
      ⊢ ∀a. SWAP a = (SND a,FST a)
   
   [<a name="UNCURRY-val"><b>UNCURRY</b></a>]  Definition
      
      ⊢ ∀f v. UNCURRY f v = f (FST v) (SND v)
   
   [<a name="pair_CASE_def-val"><b>pair_CASE_def</b></a>]  Definition
      
      ⊢ ∀p f. pair_CASE p f = f (FST p) (SND p)
   
   [<a name="prod_TY_DEF-val"><b>prod_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep. TYPE_DEFINITION (λp. ∃x y. p = (λa b. a = x ∧ b = y)) rep
   
   [<a name="ABS_PAIR_THM-val"><b>ABS_PAIR_THM</b></a>]  Theorem
      
      ⊢ ∀x. ∃q r. x = (q,r)
   
   [<a name="CLOSED_PAIR_EQ-val"><b>CLOSED_PAIR_EQ</b></a>]  Theorem
      
      ⊢ ∀x y a b. (x,y) = (a,b) ⇔ x = a ∧ y = b
   
   [<a name="COMMA_PRS-val"><b>COMMA_PRS</b></a>]  Theorem
      
      ⊢ ∀R1 abs1 rep1.
          QUOTIENT R1 abs1 rep1 ⇒
          ∀R2 abs2 rep2.
            QUOTIENT R2 abs2 rep2 ⇒
            ∀a b. (a,b) = (abs1 ## abs2) (rep1 a,rep2 b)
   
   [<a name="COMMA_RSP-val"><b>COMMA_RSP</b></a>]  Theorem
      
      ⊢ ∀R1 abs1 rep1.
          QUOTIENT R1 abs1 rep1 ⇒
          ∀R2 abs2 rep2.
            QUOTIENT R2 abs2 rep2 ⇒
            ∀a1 a2 b1 b2. R1 a1 b1 ∧ R2 a2 b2 ⇒ (R1 ### R2) (a1,a2) (b1,b2)
   
   [<a name="CURRY_ONE_ONE_THM-val"><b>CURRY_ONE_ONE_THM</b></a>]  Theorem
      
      ⊢ CURRY f = CURRY g ⇔ f = g
   
   [<a name="CURRY_PRS-val"><b>CURRY_PRS</b></a>]  Theorem
      
      ⊢ ∀R1 abs1 rep1.
          QUOTIENT R1 abs1 rep1 ⇒
          ∀R2 abs2 rep2.
            QUOTIENT R2 abs2 rep2 ⇒
            ∀R3 abs3 rep3.
              QUOTIENT R3 abs3 rep3 ⇒
              ∀f a b.
                CURRY f a b =
                abs3
                  (CURRY (((abs1 ## abs2) --&gt; rep3) f) (rep1 a) (rep2 b))
   
   [<a name="CURRY_RSP-val"><b>CURRY_RSP</b></a>]  Theorem
      
      ⊢ ∀R1 abs1 rep1.
          QUOTIENT R1 abs1 rep1 ⇒
          ∀R2 abs2 rep2.
            QUOTIENT R2 abs2 rep2 ⇒
            ∀R3 abs3 rep3.
              QUOTIENT R3 abs3 rep3 ⇒
              ∀f1 f2.
                ((R1 ### R2) ===&gt; R3) f1 f2 ⇒
                (R1 ===&gt; R2 ===&gt; R3) (CURRY f1) (CURRY f2)
   
   [<a name="CURRY_UNCURRY_THM-val"><b>CURRY_UNCURRY_THM</b></a>]  Theorem
      
      ⊢ ∀f. CURRY (UNCURRY f) = f
   
   [<a name="C_UNCURRY_L-val"><b>C_UNCURRY_L</b></a>]  Theorem
      
      ⊢ flip (UNCURRY f) x = UNCURRY (flip (flip ∘ f) x)
   
   [<a name="ELIM_PEXISTS-val"><b>ELIM_PEXISTS</b></a>]  Theorem
      
      ⊢ (∃p. P (FST p) (SND p)) ⇔ ∃p1 p2. P p1 p2
   
   [<a name="ELIM_PEXISTS_EVAL-val"><b>ELIM_PEXISTS_EVAL</b></a>]  Theorem
      
      ⊢ $? (UNCURRY (λx. P x)) ⇔ ∃x. $? (P x)
   
   [<a name="ELIM_PFORALL-val"><b>ELIM_PFORALL</b></a>]  Theorem
      
      ⊢ (∀p. P (FST p) (SND p)) ⇔ ∀p1 p2. P p1 p2
   
   [<a name="ELIM_PFORALL_EVAL-val"><b>ELIM_PFORALL_EVAL</b></a>]  Theorem
      
      ⊢ $! (UNCURRY (λx. P x)) ⇔ ∀x. $! (P x)
   
   [<a name="ELIM_UNCURRY-val"><b>ELIM_UNCURRY</b></a>]  Theorem
      
      ⊢ ∀f. UNCURRY f = (λx. f (FST x) (SND x))
   
   [<a name="EXISTS_PROD-val"><b>EXISTS_PROD</b></a>]  Theorem
      
      ⊢ (∃p. P p) ⇔ ∃p_1 p_2. P (p_1,p_2)
   
   [<a name="FORALL_PROD-val"><b>FORALL_PROD</b></a>]  Theorem
      
      ⊢ (∀p. P p) ⇔ ∀p_1 p_2. P (p_1,p_2)
   
   [<a name="FORALL_UNCURRY-val"><b>FORALL_UNCURRY</b></a>]  Theorem
      
      ⊢ $! (UNCURRY f) ⇔ $! ($! ∘ f)
   
   [<a name="FST-val"><b>FST</b></a>]  Theorem
      
      ⊢ ∀x y. FST (x,y) = x
   
   [<a name="FST_EQ_EQUIV-val"><b>FST_EQ_EQUIV</b></a>]  Theorem
      
      ⊢ FST p = x ⇔ ∃y. p = (x,y)
   
   [<a name="FST_PAIR_MAP-val"><b>FST_PAIR_MAP</b></a>]  Theorem
      
      ⊢ ∀p f g. FST ((f ## g) p) = f (FST p)
   
   [<a name="FST_PRS-val"><b>FST_PRS</b></a>]  Theorem
      
      ⊢ ∀R1 abs1 rep1.
          QUOTIENT R1 abs1 rep1 ⇒
          ∀R2 abs2 rep2.
            QUOTIENT R2 abs2 rep2 ⇒
            ∀p. FST p = abs1 (FST ((rep1 ## rep2) p))
   
   [<a name="FST_RSP-val"><b>FST_RSP</b></a>]  Theorem
      
      ⊢ ∀R1 abs1 rep1.
          QUOTIENT R1 abs1 rep1 ⇒
          ∀R2 abs2 rep2.
            QUOTIENT R2 abs2 rep2 ⇒
            ∀p1 p2. (R1 ### R2) p1 p2 ⇒ R1 (FST p1) (FST p2)
   
   [<a name="IN_PAIR_SET-val"><b>IN_PAIR_SET</b></a>]  Theorem
      
      ⊢ c ∈ PAIR_SET f g (a,b) ⇔ c ∈ f a ∨ c ∈ g b
   
   [<a name="IN_UNCURRY_R-val"><b>IN_UNCURRY_R</b></a>]  Theorem
      
      ⊢ (x,y) ∈ UNCURRY R ⇔ R x y
   
   [<a name="IN_setFSTSND-val"><b>IN_setFSTSND</b></a>]  Theorem
      
      ⊢ (a ∈ setFST ab ⇔ FST ab = a) ∧ (b ∈ setSND ab ⇔ SND ab = b)
   
   [<a name="LAMBDA_PROD-val"><b>LAMBDA_PROD</b></a>]  Theorem
      
      ⊢ ∀P. (λp. P p) = (λ(p1,p2). P (p1,p2))
   
   [<a name="LET2_RAND-val"><b>LET2_RAND</b></a>]  Theorem
      
      ⊢ ∀P M N. P (let (x,y) = M in N x y) = (let (x,y) = M in P (N x y))
   
   [<a name="LET2_RATOR-val"><b>LET2_RATOR</b></a>]  Theorem
      
      ⊢ ∀M N b. (let (x,y) = M in N x y) b = (let (x,y) = M in N x y b)
   
   [<a name="LEX_CONG-val"><b>LEX_CONG</b></a>]  Theorem
      
      ⊢ ∀R1 R2 v1 v2 R1' R2' v1' v2'.
          v1 = v1' ∧ v2 = v2' ∧
          (∀a b c d. v1' = (a,b) ∧ v2' = (c,d) ⇒ (R1 a c ⇔ R1' a c)) ∧
          (∀a b c d. v1' = (a,b) ∧ v2' = (c,d) ∧ a = c ⇒ (R2 b d ⇔ R2' b d)) ⇒
          ((R1 LEX R2) v1 v2 ⇔ (R1' LEX R2') v1' v2')
   
   [<a name="LEX_DEF_THM-val"><b>LEX_DEF_THM</b></a>]  Theorem
      
      ⊢ (R1 LEX R2) (a,b) (c,d) ⇔ R1 a c ∨ a = c ∧ R2 b d
   
   [<a name="LEX_MONO-val"><b>LEX_MONO</b></a>]  Theorem
      
      ⊢ (∀x y. R1 x y ⇒ R2 x y) ∧ (∀x y. R3 x y ⇒ R4 x y) ⇒
        (R1 LEX R3) x y ⇒
        (R2 LEX R4) x y
   
   [<a name="PAIR_EQ-val"><b>PAIR_EQ</b></a>]  Theorem
      
      ⊢ (x,y) = (a,b) ⇔ x = a ∧ y = b
   
   [<a name="PAIR_EQUIV-val"><b>PAIR_EQUIV</b></a>]  Theorem
      
      ⊢ ∀R1 R2. EQUIV R1 ⇒ EQUIV R2 ⇒ EQUIV (R1 ### R2)
   
   [<a name="PAIR_FST_SND_EQ-val"><b>PAIR_FST_SND_EQ</b></a>]  Theorem
      
      ⊢ ∀p q. p = q ⇔ FST p = FST q ∧ SND p = SND q
   
   [<a name="PAIR_FUN_THM-val"><b>PAIR_FUN_THM</b></a>]  Theorem
      
      ⊢ ∀P. (∃!f. P f) ⇔ ∃!p. P (λa. (FST p a,SND p a))
   
   [<a name="PAIR_MAP_CONG-val"><b>PAIR_MAP_CONG</b></a>]  Theorem
      
      ⊢ (∀a. a ∈ setFST ab ⇒ f1 a = f2 a) ∧
        (∀b. b ∈ setSND ab ⇒ g1 b = g2 b) ⇒
        (f1 ## g1) ab = (f2 ## g2) ab
   
   [<a name="PAIR_MAP_I-val"><b>PAIR_MAP_I</b></a>]  Theorem
      
      ⊢ I ## I = I
   
   [<a name="PAIR_MAP_PRS-val"><b>PAIR_MAP_PRS</b></a>]  Theorem
      
      ⊢ ∀R1 abs1 rep1.
          QUOTIENT R1 abs1 rep1 ⇒
          ∀R2 abs2 rep2.
            QUOTIENT R2 abs2 rep2 ⇒
            ∀R3 abs3 rep3.
              QUOTIENT R3 abs3 rep3 ⇒
              ∀R4 abs4 rep4.
                QUOTIENT R4 abs4 rep4 ⇒
                ∀f g.
                  f ## g =
                  ((rep1 ## rep3) --&gt; (abs2 ## abs4))
                    ((abs1 --&gt; rep2) f ## (abs3 --&gt; rep4) g)
   
   [<a name="PAIR_MAP_RSP-val"><b>PAIR_MAP_RSP</b></a>]  Theorem
      
      ⊢ ∀R1 abs1 rep1.
          QUOTIENT R1 abs1 rep1 ⇒
          ∀R2 abs2 rep2.
            QUOTIENT R2 abs2 rep2 ⇒
            ∀R3 abs3 rep3.
              QUOTIENT R3 abs3 rep3 ⇒
              ∀R4 abs4 rep4.
                QUOTIENT R4 abs4 rep4 ⇒
                ∀f1 f2 g1 g2.
                  (R1 ===&gt; R2) f1 f2 ∧ (R3 ===&gt; R4) g1 g2 ⇒
                  ((R1 ### R3) ===&gt; R2 ### R4) (f1 ## g1) (f2 ## g2)
   
   [<a name="PAIR_MAP_SET-val"><b>PAIR_MAP_SET</b></a>]  Theorem
      
      ⊢ (c ∈ setFST ((f ## g) ab) ⇔ ∃a. c = f a ∧ a ∈ setFST ab) ∧
        (d ∈ setSND ((f ## g) ab) ⇔ ∃b. d = g b ∧ b ∈ setSND ab)
   
   [<a name="PAIR_MAP_THM-val"><b>PAIR_MAP_THM</b></a>]  Theorem
      
      ⊢ ∀f g x y. (f ## g) (x,y) = (f x,g y)
   
   [<a name="PAIR_QUOTIENT-val"><b>PAIR_QUOTIENT</b></a>]  Theorem
      
      ⊢ ∀R1 abs1 rep1.
          QUOTIENT R1 abs1 rep1 ⇒
          ∀R2 abs2 rep2.
            QUOTIENT R2 abs2 rep2 ⇒
            QUOTIENT (R1 ### R2) (abs1 ## abs2) (rep1 ## rep2)
   
   [<a name="PAIR_REL-val"><b>PAIR_REL</b></a>]  Theorem
      
      ⊢ ∀R1 R2. R1 ### R2 = (λ(s,t) (u,v). R1 s u ∧ R2 t v)
   
   [<a name="PAIR_REL_EQ-val"><b>PAIR_REL_EQ</b></a>]  Theorem
      
      ⊢ $= ### $= = $=
   
   [<a name="PAIR_REL_REFL-val"><b>PAIR_REL_REFL</b></a>]  Theorem
      
      ⊢ (∀x. R1 x x) ∧ (∀y. R2 y y) ⇒ ∀xy. (R1 ### R2) xy xy
   
   [<a name="PAIR_REL_SYM-val"><b>PAIR_REL_SYM</b></a>]  Theorem
      
      ⊢ (∀x y. R1 x y ⇔ R1 y x) ∧ (∀a b. R2 a b ⇔ R2 b a) ⇒
        ∀xy ab. (R1 ### R2) xy ab ⇔ (R1 ### R2) ab xy
   
   [<a name="PAIR_REL_THM-val"><b>PAIR_REL_THM</b></a>]  Theorem
      
      ⊢ (R1 ### R2) (a,b) (c,d) ⇔ R1 a c ∧ R2 b d
   
   [<a name="PAIR_REL_TRANS-val"><b>PAIR_REL_TRANS</b></a>]  Theorem
      
      ⊢ (∀x y z. R1 x y ∧ R1 y z ⇒ R1 x z) ∧
        (∀a b c. R2 a b ∧ R2 b c ⇒ R2 a c) ⇒
        ∀xy ab uv.
          (R1 ### R2) xy ab ∧ (R1 ### R2) ab uv ⇒ (R1 ### R2) xy uv
   
   [<a name="PEXISTS_THM-val"><b>PEXISTS_THM</b></a>]  Theorem
      
      ⊢ ∀P. (∃x y. P x y) ⇔ ∃(x,y). P x y
   
   [<a name="PFORALL_THM-val"><b>PFORALL_THM</b></a>]  Theorem
      
      ⊢ ∀P. (∀x y. P x y) ⇔ ∀(x,y). P x y
   
   [<a name="PROD_ALL_CONG-val"><b>PROD_ALL_CONG</b></a>]  Theorem
      
      ⊢ ∀p p' P P' Q Q'.
          p = p' ∧ (∀x y. p' = (x,y) ⇒ (P x ⇔ P' x)) ∧
          (∀x y. p' = (x,y) ⇒ (Q y ⇔ Q' y)) ⇒
          (PROD_ALL P Q p ⇔ PROD_ALL P' Q' p')
   
   [<a name="PROD_ALL_MONO-val"><b>PROD_ALL_MONO</b></a>]  Theorem
      
      ⊢ (∀x. P x ⇒ P' x) ∧ (∀y. Q y ⇒ Q' y) ⇒
        PROD_ALL P Q p ⇒
        PROD_ALL P' Q' p
   
   [<a name="PROD_ALL_THM-val"><b>PROD_ALL_THM</b></a>]  Theorem
      
      ⊢ PROD_ALL P Q (x,y) ⇔ P x ∧ Q y
   
   [<a name="SND-val"><b>SND</b></a>]  Theorem
      
      ⊢ ∀x y. SND (x,y) = y
   
   [<a name="SND_EQ_EQUIV-val"><b>SND_EQ_EQUIV</b></a>]  Theorem
      
      ⊢ SND p = y ⇔ ∃x. p = (x,y)
   
   [<a name="SND_PAIR_MAP-val"><b>SND_PAIR_MAP</b></a>]  Theorem
      
      ⊢ ∀p f g. SND ((f ## g) p) = g (SND p)
   
   [<a name="SND_PRS-val"><b>SND_PRS</b></a>]  Theorem
      
      ⊢ ∀R1 abs1 rep1.
          QUOTIENT R1 abs1 rep1 ⇒
          ∀R2 abs2 rep2.
            QUOTIENT R2 abs2 rep2 ⇒
            ∀p. SND p = abs2 (SND ((rep1 ## rep2) p))
   
   [<a name="SND_RSP-val"><b>SND_RSP</b></a>]  Theorem
      
      ⊢ ∀R1 abs1 rep1.
          QUOTIENT R1 abs1 rep1 ⇒
          ∀R2 abs2 rep2.
            QUOTIENT R2 abs2 rep2 ⇒
            ∀p1 p2. (R1 ### R2) p1 p2 ⇒ R2 (SND p1) (SND p2)
   
   [<a name="SWAP_SWAP-val"><b>SWAP_SWAP</b></a>]  Theorem
      
      ⊢ ∀x. SWAP (SWAP x) = x
   
   [<a name="S_UNCURRY_R-val"><b>S_UNCURRY_R</b></a>]  Theorem
      
      ⊢ S f (UNCURRY g) = UNCURRY (S (S ∘ $o f ∘ $,) g)
   
   [<a name="UNCURRY_CONG-val"><b>UNCURRY_CONG</b></a>]  Theorem
      
      ⊢ ∀f' f M' M.
          M = M' ∧ (∀x y. M' = (x,y) ⇒ f x y = f' x y) ⇒
          UNCURRY f M = UNCURRY f' M'
   
   [<a name="UNCURRY_CURRY_THM-val"><b>UNCURRY_CURRY_THM</b></a>]  Theorem
      
      ⊢ ∀f. UNCURRY (CURRY f) = f
   
   [<a name="UNCURRY_DEF-val"><b>UNCURRY_DEF</b></a>]  Theorem
      
      ⊢ ∀f x y. UNCURRY f (x,y) = f x y
   
   [<a name="UNCURRY_ONE_ONE_THM-val"><b>UNCURRY_ONE_ONE_THM</b></a>]  Theorem
      
      ⊢ UNCURRY f = UNCURRY g ⇔ f = g
   
   [<a name="UNCURRY_PRS-val"><b>UNCURRY_PRS</b></a>]  Theorem
      
      ⊢ ∀R1 abs1 rep1.
          QUOTIENT R1 abs1 rep1 ⇒
          ∀R2 abs2 rep2.
            QUOTIENT R2 abs2 rep2 ⇒
            ∀R3 abs3 rep3.
              QUOTIENT R3 abs3 rep3 ⇒
              ∀f p.
                UNCURRY f p =
                abs3
                  (UNCURRY ((abs1 --&gt; abs2 --&gt; rep3) f) ((rep1 ## rep2) p))
   
   [<a name="UNCURRY_RSP-val"><b>UNCURRY_RSP</b></a>]  Theorem
      
      ⊢ ∀R1 abs1 rep1.
          QUOTIENT R1 abs1 rep1 ⇒
          ∀R2 abs2 rep2.
            QUOTIENT R2 abs2 rep2 ⇒
            ∀R3 abs3 rep3.
              QUOTIENT R3 abs3 rep3 ⇒
              ∀f1 f2.
                (R1 ===&gt; R2 ===&gt; R3) f1 f2 ⇒
                ((R1 ### R2) ===&gt; R3) (UNCURRY f1) (UNCURRY f2)
   
   [<a name="UNCURRY_VAR-val"><b>UNCURRY_VAR</b></a>]  Theorem
      
      ⊢ ∀f v. UNCURRY f v = f (FST v) (SND v)
   
   [<a name="WF_LEX-val"><b>WF_LEX</b></a>]  Theorem
      
      ⊢ ∀R Q. WF R ∧ WF Q ⇒ WF (R LEX Q)
   
   [<a name="WF_RPROD-val"><b>WF_RPROD</b></a>]  Theorem
      
      ⊢ ∀R Q. WF R ∧ WF Q ⇒ WF (R ### Q)
   
   [<a name="datatype_pair-val"><b>datatype_pair</b></a>]  Theorem
      
      ⊢ DATATYPE (pair $,)
   
   [<a name="o_UNCURRY_R-val"><b>o_UNCURRY_R</b></a>]  Theorem
      
      ⊢ f ∘ UNCURRY g = UNCURRY ($o f ∘ g)
   
   [<a name="pair_Axiom-val"><b>pair_Axiom</b></a>]  Theorem
      
      ⊢ ∀f. ∃fn. ∀x y. fn (x,y) = f x y
   
   [<a name="pair_CASES-val"><b>pair_CASES</b></a>]  Theorem
      
      ⊢ ∀x. ∃q r. x = (q,r)
   
   [<a name="pair_case_cong-val"><b>pair_case_cong</b></a>]  Theorem
      
      ⊢ ∀M M' f.
          M = M' ∧ (∀x y. M' = (x,y) ⇒ f x y = f' x y) ⇒
          pair_CASE M f = pair_CASE M' f'
   
   [<a name="pair_case_def-val"><b>pair_case_def</b></a>]  Theorem
      
      ⊢ pair_CASE (x,y) f = f x y
   
   [<a name="pair_case_eq-val"><b>pair_case_eq</b></a>]  Theorem
      
      ⊢ pair_CASE p f = v ⇔ ∃x y. p = (x,y) ∧ f x y = v
   
   [<a name="pair_case_ho_elim-val"><b>pair_case_ho_elim</b></a>]  Theorem
      
      ⊢ ∀f'. f' (pair_CASE p f) ⇔ ∃x y. p = (x,y) ∧ f' (f x y)
   
   [<a name="pair_case_thm-val"><b>pair_case_thm</b></a>]  Theorem
      
      ⊢ pair_CASE (x,y) f = f x y
   
   [<a name="pair_induction-val"><b>pair_induction</b></a>]  Theorem
      
      ⊢ ∀P. (∀p_1 p_2. P (p_1,p_2)) ⇒ ∀p. P p
   
   [<a name="reflexive_LEX-val"><b>reflexive_LEX</b></a>]  Theorem
      
      ⊢ reflexive (R1 LEX R2) ⇔ reflexive R1 ∨ reflexive R2
   
   [<a name="symmetric_LEX-val"><b>symmetric_LEX</b></a>]  Theorem
      
      ⊢ symmetric R1 ∧ symmetric R2 ⇒ symmetric (R1 LEX R2)
   
   [<a name="total_LEX-val"><b>total_LEX</b></a>]  Theorem
      
      ⊢ total R1 ∧ total R2 ⇒ total (R1 LEX R2)
   
   [<a name="transitive_LEX-val"><b>transitive_LEX</b></a>]  Theorem
      
      ⊢ transitive R1 ∧ transitive R2 ⇒ transitive (R1 LEX R2)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/coretypes/pairScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-1</a></em></p></body></html>
