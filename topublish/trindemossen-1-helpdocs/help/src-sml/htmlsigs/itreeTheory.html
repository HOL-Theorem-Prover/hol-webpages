<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure itreeTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure itreeTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/coalgebras/itreeScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature itreeTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#ibind_def-val">ibind_def</a> : thm
<a name="line7"></a>    val <a href="#iflat_def-val">iflat_def</a> : thm
<a name="line8"></a>    val <a href="#imap_def-val">imap_def</a> : thm
<a name="line9"></a>    val <a href="#itree_TY_DEF-val">itree_TY_DEF</a> : thm
<a name="line10"></a>    val <a href="#itree_el_case_def-val">itree_el_case_def</a> : thm
<a name="line11"></a>    val <a href="#itree_el_size_def-val">itree_el_size_def</a> : thm
<a name="line12"></a>    val <a href="#itree_next_case_def-val">itree_next_case_def</a> : thm
<a name="line13"></a>    val <a href="#itree_next_size_def-val">itree_next_size_def</a> : thm
<a name="line14"></a>  
<a name="line15"></a>  (*  Theorems  *)
<a name="line16"></a>    val <a href="#Ret_11-val">Ret_11</a> : thm
<a name="line17"></a>    val <a href="#Vis_11-val">Vis_11</a> : thm
<a name="line18"></a>    val <a href="#at_path_cases-val">at_path_cases</a> : thm
<a name="line19"></a>    val <a href="#at_path_implies_iset-val">at_path_implies_iset</a> : thm
<a name="line20"></a>    val <a href="#at_path_ind-val">at_path_ind</a> : thm
<a name="line21"></a>    val <a href="#at_path_ret-val">at_path_ret</a> : thm
<a name="line22"></a>    val <a href="#at_path_rules-val">at_path_rules</a> : thm
<a name="line23"></a>    val <a href="#at_path_strongind-val">at_path_strongind</a> : thm
<a name="line24"></a>    val <a href="#at_path_thm-val">at_path_thm</a> : thm
<a name="line25"></a>    val <a href="#at_path_vis-val">at_path_vis</a> : thm
<a name="line26"></a>    val <a href="#datatype_itree-val">datatype_itree</a> : thm
<a name="line27"></a>    val <a href="#datatype_itree_el-val">datatype_itree_el</a> : thm
<a name="line28"></a>    val <a href="#datatype_itree_next-val">datatype_itree_next</a> : thm
<a name="line29"></a>    val <a href="#ibind_assoc-val">ibind_assoc</a> : thm
<a name="line30"></a>    val <a href="#ibind_eq_div-val">ibind_eq_div</a> : thm
<a name="line31"></a>    val <a href="#ibind_eq_ret-val">ibind_eq_ret</a> : thm
<a name="line32"></a>    val <a href="#ibind_eq_vis-val">ibind_eq_vis</a> : thm
<a name="line33"></a>    val <a href="#ibind_left_id-val">ibind_left_id</a> : thm
<a name="line34"></a>    val <a href="#ibind_right_id-val">ibind_right_id</a> : thm
<a name="line35"></a>    val <a href="#ievery_cases-val">ievery_cases</a> : thm
<a name="line36"></a>    val <a href="#ievery_coind-val">ievery_coind</a> : thm
<a name="line37"></a>    val <a href="#ievery_div-val">ievery_div</a> : thm
<a name="line38"></a>    val <a href="#ievery_ret-val">ievery_ret</a> : thm
<a name="line39"></a>    val <a href="#ievery_rules-val">ievery_rules</a> : thm
<a name="line40"></a>    val <a href="#ievery_set-val">ievery_set</a> : thm
<a name="line41"></a>    val <a href="#ievery_thm-val">ievery_thm</a> : thm
<a name="line42"></a>    val <a href="#ievery_vis-val">ievery_vis</a> : thm
<a name="line43"></a>    val <a href="#iexists_cases-val">iexists_cases</a> : thm
<a name="line44"></a>    val <a href="#iexists_ind-val">iexists_ind</a> : thm
<a name="line45"></a>    val <a href="#iexists_ret-val">iexists_ret</a> : thm
<a name="line46"></a>    val <a href="#iexists_rules-val">iexists_rules</a> : thm
<a name="line47"></a>    val <a href="#iexists_set-val">iexists_set</a> : thm
<a name="line48"></a>    val <a href="#iexists_strongind-val">iexists_strongind</a> : thm
<a name="line49"></a>    val <a href="#iexists_thm-val">iexists_thm</a> : thm
<a name="line50"></a>    val <a href="#iexists_vis-val">iexists_vis</a> : thm
<a name="line51"></a>    val <a href="#ifinite_cases-val">ifinite_cases</a> : thm
<a name="line52"></a>    val <a href="#ifinite_div-val">ifinite_div</a> : thm
<a name="line53"></a>    val <a href="#ifinite_ind-val">ifinite_ind</a> : thm
<a name="line54"></a>    val <a href="#ifinite_ret-val">ifinite_ret</a> : thm
<a name="line55"></a>    val <a href="#ifinite_rules-val">ifinite_rules</a> : thm
<a name="line56"></a>    val <a href="#ifinite_strongind-val">ifinite_strongind</a> : thm
<a name="line57"></a>    val <a href="#ifinite_vis-val">ifinite_vis</a> : thm
<a name="line58"></a>    val <a href="#iflat_div-val">iflat_div</a> : thm
<a name="line59"></a>    val <a href="#iflat_eq_div-val">iflat_eq_div</a> : thm
<a name="line60"></a>    val <a href="#iflat_eq_ret-val">iflat_eq_ret</a> : thm
<a name="line61"></a>    val <a href="#iflat_eq_vis-val">iflat_eq_vis</a> : thm
<a name="line62"></a>    val <a href="#iflat_ret-val">iflat_ret</a> : thm
<a name="line63"></a>    val <a href="#iflat_vis-val">iflat_vis</a> : thm
<a name="line64"></a>    val <a href="#imap_composition-val">imap_composition</a> : thm
<a name="line65"></a>    val <a href="#imap_div-val">imap_div</a> : thm
<a name="line66"></a>    val <a href="#imap_eq_div-val">imap_eq_div</a> : thm
<a name="line67"></a>    val <a href="#imap_eq_ret-val">imap_eq_ret</a> : thm
<a name="line68"></a>    val <a href="#imap_eq_vis-val">imap_eq_vis</a> : thm
<a name="line69"></a>    val <a href="#imap_id-val">imap_id</a> : thm
<a name="line70"></a>    val <a href="#imap_ret-val">imap_ret</a> : thm
<a name="line71"></a>    val <a href="#imap_vis-val">imap_vis</a> : thm
<a name="line72"></a>    val <a href="#iset_cases-val">iset_cases</a> : thm
<a name="line73"></a>    val <a href="#iset_flat-val">iset_flat</a> : thm
<a name="line74"></a>    val <a href="#iset_flat_1-val">iset_flat_1</a> : thm
<a name="line75"></a>    val <a href="#iset_flat_2-val">iset_flat_2</a> : thm
<a name="line76"></a>    val <a href="#iset_iff_exists_path-val">iset_iff_exists_path</a> : thm
<a name="line77"></a>    val <a href="#iset_ind-val">iset_ind</a> : thm
<a name="line78"></a>    val <a href="#iset_map-val">iset_map</a> : thm
<a name="line79"></a>    val <a href="#iset_map_1-val">iset_map_1</a> : thm
<a name="line80"></a>    val <a href="#iset_map_2-val">iset_map_2</a> : thm
<a name="line81"></a>    val <a href="#iset_ret-val">iset_ret</a> : thm
<a name="line82"></a>    val <a href="#iset_rules-val">iset_rules</a> : thm
<a name="line83"></a>    val <a href="#iset_strongind-val">iset_strongind</a> : thm
<a name="line84"></a>    val <a href="#iset_thm-val">iset_thm</a> : thm
<a name="line85"></a>    val <a href="#iset_truncate-val">iset_truncate</a> : thm
<a name="line86"></a>    val <a href="#iset_vis-val">iset_vis</a> : thm
<a name="line87"></a>    val <a href="#itree_11-val">itree_11</a> : thm
<a name="line88"></a>    val <a href="#itree_CASE-val">itree_CASE</a> : thm
<a name="line89"></a>    val <a href="#itree_CASE_cong-val">itree_CASE_cong</a> : thm
<a name="line90"></a>    val <a href="#itree_CASE_elim-val">itree_CASE_elim</a> : thm
<a name="line91"></a>    val <a href="#itree_CASE_eq-val">itree_CASE_eq</a> : thm
<a name="line92"></a>    val <a href="#itree_bisimulation-val">itree_bisimulation</a> : thm
<a name="line93"></a>    val <a href="#itree_cases-val">itree_cases</a> : thm
<a name="line94"></a>    val <a href="#itree_distinct-val">itree_distinct</a> : thm
<a name="line95"></a>    val <a href="#itree_el_11-val">itree_el_11</a> : thm
<a name="line96"></a>    val <a href="#itree_el_Axiom-val">itree_el_Axiom</a> : thm
<a name="line97"></a>    val <a href="#itree_el_case_cong-val">itree_el_case_cong</a> : thm
<a name="line98"></a>    val <a href="#itree_el_case_eq-val">itree_el_case_eq</a> : thm
<a name="line99"></a>    val <a href="#itree_el_def-val">itree_el_def</a> : thm
<a name="line100"></a>    val <a href="#itree_el_distinct-val">itree_el_distinct</a> : thm
<a name="line101"></a>    val <a href="#itree_el_eqv-val">itree_el_eqv</a> : thm
<a name="line102"></a>    val <a href="#itree_el_induction-val">itree_el_induction</a> : thm
<a name="line103"></a>    val <a href="#itree_el_nchotomy-val">itree_el_nchotomy</a> : thm
<a name="line104"></a>    val <a href="#itree_next_11-val">itree_next_11</a> : thm
<a name="line105"></a>    val <a href="#itree_next_Axiom-val">itree_next_Axiom</a> : thm
<a name="line106"></a>    val <a href="#itree_next_case_cong-val">itree_next_case_cong</a> : thm
<a name="line107"></a>    val <a href="#itree_next_case_eq-val">itree_next_case_eq</a> : thm
<a name="line108"></a>    val <a href="#itree_next_distinct-val">itree_next_distinct</a> : thm
<a name="line109"></a>    val <a href="#itree_next_induction-val">itree_next_induction</a> : thm
<a name="line110"></a>    val <a href="#itree_next_nchotomy-val">itree_next_nchotomy</a> : thm
<a name="line111"></a>    val <a href="#itree_unfold-val">itree_unfold</a> : thm
<a name="line112"></a>    val <a href="#itree_unfold_err-val">itree_unfold_err</a> : thm
<a name="line113"></a>    val <a href="#itruncate_compute-val">itruncate_compute</a> : thm
<a name="line114"></a>    val <a href="#itruncate_def-val">itruncate_def</a> : thm
<a name="line115"></a>    val <a href="#itruncate_implies_ifinite-val">itruncate_implies_ifinite</a> : thm
<a name="line116"></a>    val <a href="#itruncate_ind-val">itruncate_ind</a> : thm
<a name="line117"></a>    val <a href="#itruncate_ret-val">itruncate_ret</a> : thm
<a name="line118"></a>    val <a href="#not_ievery_exists-val">not_ievery_exists</a> : thm
<a name="line119"></a>  
<a name="line120"></a>  val itree_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line121"></a>(*
   [indexedLists] Parent theory of "itree"
   
   [patternMatches] Parent theory of "itree"
   
   [<a name="ibind_def-val"><b>ibind_def</b></a>]  Definition
      
      ⊢ ∀itr f. ibind itr f = iflat (imap f itr)
   
   [<a name="iflat_def-val"><b>iflat_def</b></a>]  Definition
      
      ⊢ ∀itr.
          iflat itr =
          itree_unfold
            (λx.
                 case x of
                   INL (ireturn (ireturn r0)) =&gt; Ret' r0
                 | INL (ireturn Div) =&gt; Div'
                 | INL (ireturn (Vis e f)) =&gt; Vis' e (λi. INR (f i))
                 | INL Div =&gt; Div'
                 | INL (Vis e f) =&gt; Vis' e (λi. INL (f i))
                 | INR (ireturn r) =&gt; Ret' r
                 | INR Div =&gt; Div'
                 | INR (Vis e' f') =&gt; Vis' e' (λi. INR (f' i))) (INL itr)
   
   [<a name="imap_def-val"><b>imap_def</b></a>]  Definition
      
      ⊢ ∀g itr.
          imap g itr =
          itree_unfold
            (λx. itree_CASE x (λr. Ret' (g r)) Div' (λe f. Vis' e f)) itr
   
   [<a name="itree_TY_DEF-val"><b>itree_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep. TYPE_DEFINITION itree_rep_ok rep
   
   [<a name="itree_el_case_def-val"><b>itree_el_case_def</b></a>]  Definition
      
      ⊢ (∀a f f1 v. itree_el_CASE (Event a) f f1 v = f a) ∧
        (∀a f f1 v. itree_el_CASE (Return a) f f1 v = f1 a) ∧
        ∀f f1 v. itree_el_CASE Stuck f f1 v = v
   
   [<a name="itree_el_size_def-val"><b>itree_el_size_def</b></a>]  Definition
      
      ⊢ (∀f f1 a. itree_el_size f f1 (Event a) = 1 + f a) ∧
        (∀f f1 a. itree_el_size f f1 (Return a) = 1 + f1 a) ∧
        ∀f f1. itree_el_size f f1 Stuck = 0
   
   [<a name="itree_next_case_def-val"><b>itree_next_case_def</b></a>]  Definition
      
      ⊢ (∀a f v f1. itree_next_CASE (Ret' a) f v f1 = f a) ∧
        (∀f v f1. itree_next_CASE Div' f v f1 = v) ∧
        ∀a0 a1 f v f1. itree_next_CASE (Vis' a0 a1) f v f1 = f1 a0 a1
   
   [<a name="itree_next_size_def-val"><b>itree_next_size_def</b></a>]  Definition
      
      ⊢ (∀f f1 f2 f3 a. itree_next_size f f1 f2 f3 (Ret' a) = 1 + f2 a) ∧
        (∀f f1 f2 f3. itree_next_size f f1 f2 f3 Div' = 0) ∧
        ∀f f1 f2 f3 a0 a1.
          itree_next_size f f1 f2 f3 (Vis' a0 a1) = 1 + f1 a0
   
   [<a name="Ret_11-val"><b>Ret_11</b></a>]  Theorem
      
      ⊢ ∀x y. ireturn x = ireturn y ⇔ x = y
   
   [<a name="Vis_11-val"><b>Vis_11</b></a>]  Theorem
      
      ⊢ ∀x f y g. Vis x f = Vis y g ⇔ x = y ∧ f = g
   
   [<a name="at_path_cases-val"><b>at_path_cases</b></a>]  Theorem
      
      ⊢ ∀a0 a1 a2.
          at_path a0 a1 a2 ⇔
          a0 = ireturn a2 ∧ a1 = [] ∨
          ∃f i ov p. a0 = Vis ov f ∧ a1 = (ov,i)::p ∧ at_path (f i) p a2
   
   [<a name="at_path_implies_iset-val"><b>at_path_implies_iset</b></a>]  Theorem
      
      ⊢ at_path itree p e ⇒ iset itree e
   
   [<a name="at_path_ind-val"><b>at_path_ind</b></a>]  Theorem
      
      ⊢ ∀at_path'.
          (∀e. at_path' (ireturn e) [] e) ∧
          (∀e f i ov p.
             at_path' (f i) p e ⇒ at_path' (Vis ov f) ((ov,i)::p) e) ⇒
          ∀a0 a1 a2. at_path a0 a1 a2 ⇒ at_path' a0 a1 a2
   
   [<a name="at_path_ret-val"><b>at_path_ret</b></a>]  Theorem
      
      ⊢ ∀e. at_path (ireturn e) [] e
   
   [<a name="at_path_rules-val"><b>at_path_rules</b></a>]  Theorem
      
      ⊢ (∀e. at_path (ireturn e) [] e) ∧
        ∀e f i ov p. at_path (f i) p e ⇒ at_path (Vis ov f) ((ov,i)::p) e
   
   [<a name="at_path_strongind-val"><b>at_path_strongind</b></a>]  Theorem
      
      ⊢ ∀at_path'.
          (∀e. at_path' (ireturn e) [] e) ∧
          (∀e f i ov p.
             at_path (f i) p e ∧ at_path' (f i) p e ⇒
             at_path' (Vis ov f) ((ov,i)::p) e) ⇒
          ∀a0 a1 a2. at_path a0 a1 a2 ⇒ at_path' a0 a1 a2
   
   [<a name="at_path_thm-val"><b>at_path_thm</b></a>]  Theorem
      
      ⊢ (at_path Div p e ⇔ F) ∧
        (at_path (ireturn e) p a ⇔ p = [] ∧ a = e) ∧
        (at_path (Vis ov f) p e ⇔ ∃i l. p = (ov,i)::l ∧ at_path (f i) l e)
   
   [<a name="at_path_vis-val"><b>at_path_vis</b></a>]  Theorem
      
      ⊢ ∀e f i ov p. at_path (f i) p e ⇒ at_path (Vis ov f) ((ov,i)::p) e
   
   [<a name="datatype_itree-val"><b>datatype_itree</b></a>]  Theorem
      
      ⊢ DATATYPE (itree ireturn Div Vis)
   
   [<a name="datatype_itree_el-val"><b>datatype_itree_el</b></a>]  Theorem
      
      ⊢ DATATYPE (itree_el Event Return Stuck)
   
   [<a name="datatype_itree_next-val"><b>datatype_itree_next</b></a>]  Theorem
      
      ⊢ DATATYPE (itree_next Ret' Div' Vis')
   
   [<a name="ibind_assoc-val"><b>ibind_assoc</b></a>]  Theorem
      
      ⊢ ibind itr (λx. ibind (f x) g) = ibind (ibind itr f) g
   
   [<a name="ibind_eq_div-val"><b>ibind_eq_div</b></a>]  Theorem
      
      ⊢ ibind itr f = Div ⇔ itr = Div ∨ ∃x. itr = ireturn x ∧ f x = Div
   
   [<a name="ibind_eq_ret-val"><b>ibind_eq_ret</b></a>]  Theorem
      
      ⊢ ibind itr f = ireturn v ⇔ ∃v'. itr = ireturn v' ∧ f v' = ireturn v
   
   [<a name="ibind_eq_vis-val"><b>ibind_eq_vis</b></a>]  Theorem
      
      ⊢ ibind itr f = Vis rv g ⇔
        (∃h. itr = Vis rv h ∧ iflat ∘ imap f ∘ h = g) ∨
        ∃x. itr = ireturn x ∧ f x = Vis rv g
   
   [<a name="ibind_left_id-val"><b>ibind_left_id</b></a>]  Theorem
      
      ⊢ ibind (ireturn itr) f = f itr
   
   [<a name="ibind_right_id-val"><b>ibind_right_id</b></a>]  Theorem
      
      ⊢ ibind itr ireturn = itr
   
   [<a name="ievery_cases-val"><b>ievery_cases</b></a>]  Theorem
      
      ⊢ ∀P a0.
          ievery P a0 ⇔
          a0 = Div ∨ (∃e. a0 = ireturn e ∧ P e) ∨
          ∃f ov. a0 = Vis ov f ∧ ∀iv. ievery P (f iv)
   
   [<a name="ievery_coind-val"><b>ievery_coind</b></a>]  Theorem
      
      ⊢ ∀P ievery'.
          (∀a0.
             ievery' a0 ⇒
             a0 = Div ∨ (∃e. a0 = ireturn e ∧ P e) ∨
             ∃f ov. a0 = Vis ov f ∧ ∀iv. ievery' (f iv)) ⇒
          ∀a0. ievery' a0 ⇒ ievery P a0
   
   [<a name="ievery_div-val"><b>ievery_div</b></a>]  Theorem
      
      ⊢ ∀P. ievery P Div
   
   [<a name="ievery_ret-val"><b>ievery_ret</b></a>]  Theorem
      
      ⊢ ∀P e. P e ⇒ ievery P (ireturn e)
   
   [<a name="ievery_rules-val"><b>ievery_rules</b></a>]  Theorem
      
      ⊢ ∀P. ievery P Div ∧ (∀e. P e ⇒ ievery P (ireturn e)) ∧
            ∀f ov. (∀iv. ievery P (f iv)) ⇒ ievery P (Vis ov f)
   
   [<a name="ievery_set-val"><b>ievery_set</b></a>]  Theorem
      
      ⊢ ∀itr. ievery P itr ⇔ ∀rv. iset itr rv ⇒ P rv
   
   [<a name="ievery_thm-val"><b>ievery_thm</b></a>]  Theorem
      
      ⊢ (ievery P Div ⇔ T) ∧ (ievery P (ireturn e) ⇔ P e) ∧
        (ievery P (Vis ov f) ⇔ ∀iv. ievery P (f iv))
   
   [<a name="ievery_vis-val"><b>ievery_vis</b></a>]  Theorem
      
      ⊢ ∀P f ov. (∀iv. ievery P (f iv)) ⇒ ievery P (Vis ov f)
   
   [<a name="iexists_cases-val"><b>iexists_cases</b></a>]  Theorem
      
      ⊢ ∀P a0.
          iexists P a0 ⇔
          (∃e. a0 = ireturn e ∧ P e) ∨
          ∃f ov. a0 = Vis ov f ∧ ∃iv. iexists P (f iv)
   
   [<a name="iexists_ind-val"><b>iexists_ind</b></a>]  Theorem
      
      ⊢ ∀P iexists'.
          (∀e. P e ⇒ iexists' (ireturn e)) ∧
          (∀f ov. (∃iv. iexists' (f iv)) ⇒ iexists' (Vis ov f)) ⇒
          ∀a0. iexists P a0 ⇒ iexists' a0
   
   [<a name="iexists_ret-val"><b>iexists_ret</b></a>]  Theorem
      
      ⊢ ∀P e. P e ⇒ iexists P (ireturn e)
   
   [<a name="iexists_rules-val"><b>iexists_rules</b></a>]  Theorem
      
      ⊢ ∀P. (∀e. P e ⇒ iexists P (ireturn e)) ∧
            ∀f ov. (∃iv. iexists P (f iv)) ⇒ iexists P (Vis ov f)
   
   [<a name="iexists_set-val"><b>iexists_set</b></a>]  Theorem
      
      ⊢ iexists P itr ⇔ ∃x. iset itr x ∧ P x
   
   [<a name="iexists_strongind-val"><b>iexists_strongind</b></a>]  Theorem
      
      ⊢ ∀P iexists'.
          (∀e. P e ⇒ iexists' (ireturn e)) ∧
          (∀f ov.
             (∃iv. iexists P (f iv) ∧ iexists' (f iv)) ⇒
             iexists' (Vis ov f)) ⇒
          ∀a0. iexists P a0 ⇒ iexists' a0
   
   [<a name="iexists_thm-val"><b>iexists_thm</b></a>]  Theorem
      
      ⊢ (iexists P Div ⇔ F) ∧ (iexists P (ireturn e) ⇔ P e) ∧
        (iexists P (Vis ov f) ⇔ ∃iv. iexists P (f iv))
   
   [<a name="iexists_vis-val"><b>iexists_vis</b></a>]  Theorem
      
      ⊢ ∀P f ov. (∃iv. iexists P (f iv)) ⇒ iexists P (Vis ov f)
   
   [<a name="ifinite_cases-val"><b>ifinite_cases</b></a>]  Theorem
      
      ⊢ ∀a0.
          ifinite a0 ⇔
          (∃e. a0 = ireturn e) ∨ a0 = Div ∨
          ∃f ov. a0 = Vis ov f ∧ ∀iv. ifinite (f iv)
   
   [<a name="ifinite_div-val"><b>ifinite_div</b></a>]  Theorem
      
      ⊢ ifinite Div
   
   [<a name="ifinite_ind-val"><b>ifinite_ind</b></a>]  Theorem
      
      ⊢ ∀ifinite'.
          (∀e. ifinite' (ireturn e)) ∧ ifinite' Div ∧
          (∀f ov. (∀iv. ifinite' (f iv)) ⇒ ifinite' (Vis ov f)) ⇒
          ∀a0. ifinite a0 ⇒ ifinite' a0
   
   [<a name="ifinite_ret-val"><b>ifinite_ret</b></a>]  Theorem
      
      ⊢ ∀e. ifinite (ireturn e)
   
   [<a name="ifinite_rules-val"><b>ifinite_rules</b></a>]  Theorem
      
      ⊢ (∀e. ifinite (ireturn e)) ∧ ifinite Div ∧
        ∀f ov. (∀iv. ifinite (f iv)) ⇒ ifinite (Vis ov f)
   
   [<a name="ifinite_strongind-val"><b>ifinite_strongind</b></a>]  Theorem
      
      ⊢ ∀ifinite'.
          (∀e. ifinite' (ireturn e)) ∧ ifinite' Div ∧
          (∀f ov.
             (∀iv. ifinite (f iv) ∧ ifinite' (f iv)) ⇒ ifinite' (Vis ov f)) ⇒
          ∀a0. ifinite a0 ⇒ ifinite' a0
   
   [<a name="ifinite_vis-val"><b>ifinite_vis</b></a>]  Theorem
      
      ⊢ ∀f ov. (∀iv. ifinite (f iv)) ⇒ ifinite (Vis ov f)
   
   [<a name="iflat_div-val"><b>iflat_div</b></a>]  Theorem
      
      ⊢ iflat Div = Div
   
   [<a name="iflat_eq_div-val"><b>iflat_eq_div</b></a>]  Theorem
      
      ⊢ iflat itr = Div ⇔ itr = Div ∨ itr = ireturn Div
   
   [<a name="iflat_eq_ret-val"><b>iflat_eq_ret</b></a>]  Theorem
      
      ⊢ (iflat itr = ireturn rv ⇔ itr = ireturn (ireturn rv)) ∧
        (ireturn rv = iflat itr ⇔ itr = ireturn (ireturn rv))
   
   [<a name="iflat_eq_vis-val"><b>iflat_eq_vis</b></a>]  Theorem
      
      ⊢ iflat itr = Vis ov f ⇔
        (∃g. itr = Vis ov g ∧ iflat ∘ g = f) ∨ itr = ireturn (Vis ov f)
   
   [<a name="iflat_ret-val"><b>iflat_ret</b></a>]  Theorem
      
      ⊢ iflat (ireturn r) = r
   
   [<a name="iflat_vis-val"><b>iflat_vis</b></a>]  Theorem
      
      ⊢ iflat (Vis ov f) = Vis ov (iflat ∘ f)
   
   [<a name="imap_composition-val"><b>imap_composition</b></a>]  Theorem
      
      ⊢ imap (f ∘ g) itr = imap f (imap g itr)
   
   [<a name="imap_div-val"><b>imap_div</b></a>]  Theorem
      
      ⊢ imap g Div = Div
   
   [<a name="imap_eq_div-val"><b>imap_eq_div</b></a>]  Theorem
      
      ⊢ (imap g itr = Div ⇔ itr = Div) ∧ (Div = imap g itr ⇔ itr = Div)
   
   [<a name="imap_eq_ret-val"><b>imap_eq_ret</b></a>]  Theorem
      
      ⊢ ireturn r = imap g itr ⇔ ∃x. itr = ireturn x ∧ g x = r
   
   [<a name="imap_eq_vis-val"><b>imap_eq_vis</b></a>]  Theorem
      
      ⊢ Vis rv f = imap g itr ⇔ ∃h. itr = Vis rv h ∧ imap g ∘ h = f
   
   [<a name="imap_id-val"><b>imap_id</b></a>]  Theorem
      
      ⊢ imap (λx. x) itr = itr
   
   [<a name="imap_ret-val"><b>imap_ret</b></a>]  Theorem
      
      ⊢ imap g (ireturn rv) = ireturn (g rv)
   
   [<a name="imap_vis-val"><b>imap_vis</b></a>]  Theorem
      
      ⊢ imap f (Vis ov g) = Vis ov (imap f ∘ g)
   
   [<a name="iset_cases-val"><b>iset_cases</b></a>]  Theorem
      
      ⊢ ∀a0 a1.
          iset a0 a1 ⇔
          a0 = ireturn a1 ∨ ∃f i ov. a0 = Vis ov f ∧ iset (f i) a1
   
   [<a name="iset_flat-val"><b>iset_flat</b></a>]  Theorem
      
      ⊢ ∀itr e. iset (iflat itr) e ⇔ ∃t0. iset itr t0 ∧ iset t0 e
   
   [<a name="iset_flat_1-val"><b>iset_flat_1</b></a>]  Theorem
      
      ⊢ ∀itr e. iset (iflat itr) e ⇒ ∃t0. iset itr t0 ∧ iset t0 e
   
   [<a name="iset_flat_2-val"><b>iset_flat_2</b></a>]  Theorem
      
      ⊢ ∀itr t0 e. iset itr t0 ∧ iset t0 e ⇒ iset (iflat itr) e
   
   [<a name="iset_iff_exists_path-val"><b>iset_iff_exists_path</b></a>]  Theorem
      
      ⊢ iset itree e ⇔ ∃p. at_path itree p e
   
   [<a name="iset_ind-val"><b>iset_ind</b></a>]  Theorem
      
      ⊢ ∀iset'.
          (∀e. iset' (ireturn e) e) ∧
          (∀e f i ov. iset' (f i) e ⇒ iset' (Vis ov f) e) ⇒
          ∀a0 a1. iset a0 a1 ⇒ iset' a0 a1
   
   [<a name="iset_map-val"><b>iset_map</b></a>]  Theorem
      
      ⊢ iset (imap f itr) = IMAGE f (iset itr)
   
   [<a name="iset_map_1-val"><b>iset_map_1</b></a>]  Theorem
      
      ⊢ ∀itr x. iset (imap f itr) x ⇒ ∃y. x = f y ∧ iset itr y
   
   [<a name="iset_map_2-val"><b>iset_map_2</b></a>]  Theorem
      
      ⊢ ∀itr. iset itr y ⇒ iset (imap f itr) (f y)
   
   [<a name="iset_ret-val"><b>iset_ret</b></a>]  Theorem
      
      ⊢ ∀e. iset (ireturn e) e
   
   [<a name="iset_rules-val"><b>iset_rules</b></a>]  Theorem
      
      ⊢ (∀e. iset (ireturn e) e) ∧
        ∀e f i ov. iset (f i) e ⇒ iset (Vis ov f) e
   
   [<a name="iset_strongind-val"><b>iset_strongind</b></a>]  Theorem
      
      ⊢ ∀iset'.
          (∀e. iset' (ireturn e) e) ∧
          (∀e f i ov. iset (f i) e ∧ iset' (f i) e ⇒ iset' (Vis ov f) e) ⇒
          ∀a0 a1. iset a0 a1 ⇒ iset' a0 a1
   
   [<a name="iset_thm-val"><b>iset_thm</b></a>]  Theorem
      
      ⊢ (iset (ireturn e) e' ⇔ e = e') ∧ (iset Div e ⇔ F) ∧
        (iset (Vis ov f) e ⇔ ∃i. iset (f i) e)
   
   [<a name="iset_truncate-val"><b>iset_truncate</b></a>]  Theorem
      
      ⊢ iset itr elem ⇒ ∃n. iset (itruncate n itr) elem
   
   [<a name="iset_vis-val"><b>iset_vis</b></a>]  Theorem
      
      ⊢ ∀e f i ov. iset (f i) e ⇒ iset (Vis ov f) e
   
   [<a name="itree_11-val"><b>itree_11</b></a>]  Theorem
      
      ⊢ (∀x y. ireturn x = ireturn y ⇔ x = y) ∧
        ∀x f y g. Vis x f = Vis y g ⇔ x = y ∧ f = g
   
   [<a name="itree_CASE-val"><b>itree_CASE</b></a>]  Theorem
      
      ⊢ itree_CASE (ireturn r) ret div vis = ret r ∧
        itree_CASE Div ret div vis = div ∧
        itree_CASE (Vis a g) ret div vis = vis a g
   
   [<a name="itree_CASE_cong-val"><b>itree_CASE_cong</b></a>]  Theorem
      
      ⊢ ∀M M' ret div vis ret' div' vis'.
          M = M' ∧ (∀x. M' = ireturn x ⇒ ret x = ret' x) ∧
          (M' = Div ⇒ div = div') ∧
          (∀a g. M' = Vis a g ⇒ vis a g = vis' a g) ⇒
          itree_CASE M ret div vis = itree_CASE M' ret' div' vis'
   
   [<a name="itree_CASE_elim-val"><b>itree_CASE_elim</b></a>]  Theorem
      
      ⊢ ∀f. f (itree_CASE t ret div vis) ⇔
            (∃r. t = ireturn r ∧ f (ret r)) ∨ t = Div ∧ f div ∨
            ∃a g. t = Vis a g ∧ f (vis a g)
   
   [<a name="itree_CASE_eq-val"><b>itree_CASE_eq</b></a>]  Theorem
      
      ⊢ itree_CASE t ret div vis = v ⇔
        (∃r. t = ireturn r ∧ ret r = v) ∨ t = Div ∧ div = v ∨
        ∃a g. t = Vis a g ∧ vis a g = v
   
   [<a name="itree_bisimulation-val"><b>itree_bisimulation</b></a>]  Theorem
      
      ⊢ ∀t1 t2.
          t1 = t2 ⇔
          ∃R. R t1 t2 ∧ (∀x t. R (ireturn x) t ⇒ t = ireturn x) ∧
              (∀t. R Div t ⇒ t = Div) ∧
              ∀a f t. R (Vis a f) t ⇒ ∃b g. t = Vis a g ∧ ∀s. R (f s) (g s)
   
   [<a name="itree_cases-val"><b>itree_cases</b></a>]  Theorem
      
      ⊢ ∀t. (∃x. t = ireturn x) ∨ t = Div ∨ ∃a g. t = Vis a g
   
   [<a name="itree_distinct-val"><b>itree_distinct</b></a>]  Theorem
      
      ⊢ (∀x. ireturn x ≠ Div) ∧ (∀x g e. ireturn x ≠ Vis e g) ∧
        ∀g e. Div ≠ Vis e g
   
   [<a name="itree_el_11-val"><b>itree_el_11</b></a>]  Theorem
      
      ⊢ (∀a a'. Event a = Event a' ⇔ a = a') ∧
        ∀a a'. Return a = Return a' ⇔ a = a'
   
   [<a name="itree_el_Axiom-val"><b>itree_el_Axiom</b></a>]  Theorem
      
      ⊢ ∀f0 f1 f2. ∃fn.
          (∀a. fn (Event a) = f0 a) ∧ (∀a. fn (Return a) = f1 a) ∧
          fn Stuck = f2
   
   [<a name="itree_el_case_cong-val"><b>itree_el_case_cong</b></a>]  Theorem
      
      ⊢ ∀M M' f f1 v.
          M = M' ∧ (∀a. M' = Event a ⇒ f a = f' a) ∧
          (∀a. M' = Return a ⇒ f1 a = f1' a) ∧ (M' = Stuck ⇒ v = v') ⇒
          itree_el_CASE M f f1 v = itree_el_CASE M' f' f1' v'
   
   [<a name="itree_el_case_eq-val"><b>itree_el_case_eq</b></a>]  Theorem
      
      ⊢ itree_el_CASE x f f1 v = v' ⇔
        (∃e. x = Event e ∧ f e = v') ∨ (∃r. x = Return r ∧ f1 r = v') ∨
        x = Stuck ∧ v = v'
   
   [<a name="itree_el_def-val"><b>itree_el_def</b></a>]  Theorem
      
      ⊢ itree_el (ireturn r) [] = Return r ∧ itree_el Div [] = Stuck ∧
        itree_el (Vis e g) [] = Event e ∧
        itree_el (ireturn r) (a::ns) = Return ARB ∧
        itree_el Div (a::ns) = Return ARB ∧
        itree_el (Vis e g) (a::ns) = itree_el (g a) ns
   
   [<a name="itree_el_distinct-val"><b>itree_el_distinct</b></a>]  Theorem
      
      ⊢ (∀a' a. Event a ≠ Return a') ∧ (∀a. Event a ≠ Stuck) ∧
        ∀a. Return a ≠ Stuck
   
   [<a name="itree_el_eqv-val"><b>itree_el_eqv</b></a>]  Theorem
      
      ⊢ ∀t1 t2. t1 = t2 ⇔ ∀path. itree_el t1 path = itree_el t2 path
   
   [<a name="itree_el_induction-val"><b>itree_el_induction</b></a>]  Theorem
      
      ⊢ ∀P. (∀e. P (Event e)) ∧ (∀r. P (Return r)) ∧ P Stuck ⇒ ∀i. P i
   
   [<a name="itree_el_nchotomy-val"><b>itree_el_nchotomy</b></a>]  Theorem
      
      ⊢ ∀ii. (∃e. ii = Event e) ∨ (∃r. ii = Return r) ∨ ii = Stuck
   
   [<a name="itree_next_11-val"><b>itree_next_11</b></a>]  Theorem
      
      ⊢ (∀a a'. Ret' a = Ret' a' ⇔ a = a') ∧
        ∀a0 a1 a0' a1'. Vis' a0 a1 = Vis' a0' a1' ⇔ a0 = a0' ∧ a1 = a1'
   
   [<a name="itree_next_Axiom-val"><b>itree_next_Axiom</b></a>]  Theorem
      
      ⊢ ∀f0 f1 f2. ∃fn.
          (∀a. fn (Ret' a) = f0 a) ∧ fn Div' = f1 ∧
          ∀a0 a1. fn (Vis' a0 a1) = f2 a0 a1
   
   [<a name="itree_next_case_cong-val"><b>itree_next_case_cong</b></a>]  Theorem
      
      ⊢ ∀M M' f v f1.
          M = M' ∧ (∀a. M' = Ret' a ⇒ f a = f' a) ∧ (M' = Div' ⇒ v = v') ∧
          (∀a0 a1. M' = Vis' a0 a1 ⇒ f1 a0 a1 = f1' a0 a1) ⇒
          itree_next_CASE M f v f1 = itree_next_CASE M' f' v' f1'
   
   [<a name="itree_next_case_eq-val"><b>itree_next_case_eq</b></a>]  Theorem
      
      ⊢ itree_next_CASE x f v f1 = v' ⇔
        (∃r. x = Ret' r ∧ f r = v') ∨ x = Div' ∧ v = v' ∨
        ∃e f'. x = Vis' e f' ∧ f1 e f' = v'
   
   [<a name="itree_next_distinct-val"><b>itree_next_distinct</b></a>]  Theorem
      
      ⊢ (∀a. Ret' a ≠ Div') ∧ (∀a1 a0 a. Ret' a ≠ Vis' a0 a1) ∧
        ∀a1 a0. Div' ≠ Vis' a0 a1
   
   [<a name="itree_next_induction-val"><b>itree_next_induction</b></a>]  Theorem
      
      ⊢ ∀P. (∀r. P (Ret' r)) ∧ P Div' ∧ (∀e f. P (Vis' e f)) ⇒ ∀i. P i
   
   [<a name="itree_next_nchotomy-val"><b>itree_next_nchotomy</b></a>]  Theorem
      
      ⊢ ∀ii. (∃r. ii = Ret' r) ∨ ii = Div' ∨ ∃e f. ii = Vis' e f
   
   [<a name="itree_unfold-val"><b>itree_unfold</b></a>]  Theorem
      
      ⊢ itree_unfold f seed =
        case f seed of
          Ret' r =&gt; ireturn r
        | Div' =&gt; Div
        | Vis' e g =&gt; Vis e (itree_unfold f ∘ g)
   
   [<a name="itree_unfold_err-val"><b>itree_unfold_err</b></a>]  Theorem
      
      ⊢ itree_unfold_err f (rel,err_f,err) seed =
        case f seed of
          Ret' r =&gt; ireturn r
        | Div' =&gt; Div
        | Vis' e g =&gt;
          Vis e
            (λa.
                 case a of
                   INL x =&gt; ireturn (err_f e x)
                 | INR y =&gt;
                   if rel e y then itree_unfold_err f (rel,err_f,err) (g y)
                   else ireturn (err e))
   
   [<a name="itruncate_compute-val"><b>itruncate_compute</b></a>]  Theorem
      
      ⊢ (∀itr. itruncate 0 itr = Div) ∧
        (∀v2. itruncate (NUMERAL (BIT1 v2)) Div = Div) ∧
        (∀v2. itruncate (NUMERAL (BIT2 v2)) Div = Div) ∧
        (∀v3 rv. itruncate (NUMERAL (BIT1 v3)) (ireturn rv) = ireturn rv) ∧
        (∀v3 rv. itruncate (NUMERAL (BIT2 v3)) (ireturn rv) = ireturn rv) ∧
        (∀v4 ov f.
           itruncate (NUMERAL (BIT1 v4)) (Vis ov f) =
           Vis ov (λx. itruncate (NUMERAL (BIT1 v4) − 1) (f x))) ∧
        ∀v4 ov f.
          itruncate (NUMERAL (BIT2 v4)) (Vis ov f) =
          Vis ov (λx. itruncate (NUMERAL (BIT2 v4) − 1) (f x))
   
   [<a name="itruncate_def-val"><b>itruncate_def</b></a>]  Theorem
      
      ⊢ (∀itr. itruncate 0 itr = Div) ∧
        (∀v2. itruncate (SUC v2) Div = Div) ∧
        (∀v3 rv. itruncate (SUC v3) (ireturn rv) = ireturn rv) ∧
        ∀v4 ov f.
          itruncate (SUC v4) (Vis ov f) =
          Vis ov (λx. itruncate (SUC v4 − 1) (f x))
   
   [<a name="itruncate_implies_ifinite-val"><b>itruncate_implies_ifinite</b></a>]  Theorem
      
      ⊢ ∀itr. itruncate n itr = itr ⇒ ifinite itr
   
   [<a name="itruncate_ind-val"><b>itruncate_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀itr. P 0 itr) ∧ (∀v2. P (SUC v2) Div) ∧
            (∀v3 rv. P (SUC v3) (ireturn rv)) ∧
            (∀v4 ov f. (∀x. P (SUC v4 − 1) (f x)) ⇒ P (SUC v4) (Vis ov f)) ⇒
            ∀v v1. P v v1
   
   [<a name="itruncate_ret-val"><b>itruncate_ret</b></a>]  Theorem
      
      ⊢ ∀n. itruncate n itr = ireturn r ⇔ itr = ireturn r ∧ n ≠ 0
   
   [<a name="not_ievery_exists-val"><b>not_ievery_exists</b></a>]  Theorem
      
      ⊢ ¬ievery P itr ⇔ iexists (λx. ¬P x) itr
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/coalgebras/itreeScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-1</a></em></p></body></html>
