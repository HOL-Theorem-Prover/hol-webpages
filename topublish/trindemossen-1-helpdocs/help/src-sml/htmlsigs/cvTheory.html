<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure cvTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure cvTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/num/theories/cvScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature cvTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#b2c_def-val">b2c_def</a> : thm
<a name="line7"></a>    val <a href="#c2b_def-val">c2b_def</a> : thm
<a name="line8"></a>    val <a href="#cv_case_def-val">cv_case_def</a> : thm
<a name="line9"></a>    val <a href="#cv_eq_def0-val">cv_eq_def0</a> : thm
<a name="line10"></a>    val <a href="#cv_exp_def-val">cv_exp_def</a> : thm
<a name="line11"></a>    val <a href="#cv_fst_def-val">cv_fst_def</a> : thm
<a name="line12"></a>    val <a href="#cv_if_def0-val">cv_if_def0</a> : thm
<a name="line13"></a>    val <a href="#cv_ispair_def-val">cv_ispair_def</a> : thm
<a name="line14"></a>    val <a href="#cv_lt_def0-val">cv_lt_def0</a> : thm
<a name="line15"></a>    val <a href="#cv_size_def-val">cv_size_def</a> : thm
<a name="line16"></a>    val <a href="#cv_snd_def-val">cv_snd_def</a> : thm
<a name="line17"></a>  
<a name="line18"></a>  (*  Theorems  *)
<a name="line19"></a>    val <a href="#CV_EQ-val">CV_EQ</a> : thm
<a name="line20"></a>    val <a href="#DIV_RECURSIVE-val">DIV_RECURSIVE</a> : thm
<a name="line21"></a>    val <a href="#EVEN_to_cv-val">EVEN_to_cv</a> : thm
<a name="line22"></a>    val <a href="#LT_RECURSIVE-val">LT_RECURSIVE</a> : thm
<a name="line23"></a>    val <a href="#MOD_RECURSIVE-val">MOD_RECURSIVE</a> : thm
<a name="line24"></a>    val <a href="#Num_11-val">Num_11</a> : thm
<a name="line25"></a>    val <a href="#ODD_to_cv-val">ODD_to_cv</a> : thm
<a name="line26"></a>    val <a href="#Pair_11-val">Pair_11</a> : thm
<a name="line27"></a>    val <a href="#SUC_EQ-val">SUC_EQ</a> : thm
<a name="line28"></a>    val <a href="#add_to_cv-val">add_to_cv</a> : thm
<a name="line29"></a>    val <a href="#b2c-val">b2c</a> : thm
<a name="line30"></a>    val <a href="#b2c_if-val">b2c_if</a> : thm
<a name="line31"></a>    val <a href="#c2b_thm-val">c2b_thm</a> : thm
<a name="line32"></a>    val <a href="#c2n_def-val">c2n_def</a> : thm
<a name="line33"></a>    val <a href="#cv_Axiom-val">cv_Axiom</a> : thm
<a name="line34"></a>    val <a href="#cv_add_def-val">cv_add_def</a> : thm
<a name="line35"></a>    val <a href="#cv_distinct-val">cv_distinct</a> : thm
<a name="line36"></a>    val <a href="#cv_div_def-val">cv_div_def</a> : thm
<a name="line37"></a>    val <a href="#cv_eq-val">cv_eq</a> : thm
<a name="line38"></a>    val <a href="#cv_eq_def-val">cv_eq_def</a> : thm
<a name="line39"></a>    val <a href="#cv_exp_eq-val">cv_exp_eq</a> : thm
<a name="line40"></a>    val <a href="#cv_extras-val">cv_extras</a> : thm
<a name="line41"></a>    val <a href="#cv_if-val">cv_if</a> : thm
<a name="line42"></a>    val <a href="#cv_if_cong-val">cv_if_cong</a> : thm
<a name="line43"></a>    val <a href="#cv_if_def-val">cv_if_def</a> : thm
<a name="line44"></a>    val <a href="#cv_induction-val">cv_induction</a> : thm
<a name="line45"></a>    val <a href="#cv_lt_def-val">cv_lt_def</a> : thm
<a name="line46"></a>    val <a href="#cv_mod_def-val">cv_mod_def</a> : thm
<a name="line47"></a>    val <a href="#cv_mul_def-val">cv_mul_def</a> : thm
<a name="line48"></a>    val <a href="#cv_sub_def-val">cv_sub_def</a> : thm
<a name="line49"></a>    val <a href="#div_to_cv-val">div_to_cv</a> : thm
<a name="line50"></a>    val <a href="#exp_to_cv-val">exp_to_cv</a> : thm
<a name="line51"></a>    val <a href="#ge_to_cv-val">ge_to_cv</a> : thm
<a name="line52"></a>    val <a href="#gt_to_cv-val">gt_to_cv</a> : thm
<a name="line53"></a>    val <a href="#isnseq_cases-val">isnseq_cases</a> : thm
<a name="line54"></a>    val <a href="#isnseq_cons-val">isnseq_cons</a> : thm
<a name="line55"></a>    val <a href="#isnseq_ind-val">isnseq_ind</a> : thm
<a name="line56"></a>    val <a href="#isnseq_nil-val">isnseq_nil</a> : thm
<a name="line57"></a>    val <a href="#isnseq_rules-val">isnseq_rules</a> : thm
<a name="line58"></a>    val <a href="#isnseq_strongind-val">isnseq_strongind</a> : thm
<a name="line59"></a>    val <a href="#le_to_cv-val">le_to_cv</a> : thm
<a name="line60"></a>    val <a href="#lt_to_cv-val">lt_to_cv</a> : thm
<a name="line61"></a>    val <a href="#mod_to_cv-val">mod_to_cv</a> : thm
<a name="line62"></a>    val <a href="#mul_to_cv-val">mul_to_cv</a> : thm
<a name="line63"></a>    val <a href="#neq_to_cv-val">neq_to_cv</a> : thm
<a name="line64"></a>    val <a href="#pre_to_cv-val">pre_to_cv</a> : thm
<a name="line65"></a>    val <a href="#sub_to_cv-val">sub_to_cv</a> : thm
<a name="line66"></a>    val <a href="#suc_to_cv-val">suc_to_cv</a> : thm
<a name="line67"></a>  
<a name="line68"></a>  val cv_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line69"></a>(*
   [numeral] Parent theory of "cv"
   
   [<a name="b2c_def-val"><b>b2c_def</b></a>]  Definition
      
      ⊢ b2c T = cv$Num (SUC 0) ∧ b2c F = cv$Num 0
   
   [<a name="c2b_def-val"><b>c2b_def</b></a>]  Definition
      
      ⊢ ∀x. cv$c2b x ⇔ ∃k. x = cv$Num (SUC k)
   
   [<a name="cv_case_def-val"><b>cv_case_def</b></a>]  Definition
      
      ⊢ (∀n nmf prf. cv_CASE (cv$Num n) nmf prf = nmf n) ∧
        ∀c d nmf prf. cv_CASE (cv$Pair c d) nmf prf = prf c d
   
   [<a name="cv_eq_def0-val"><b>cv_eq_def0</b></a>]  Definition
      
      ⊢ ∀c d. cv_eq c d = b2c (c = d)
   
   [<a name="cv_exp_def-val"><b>cv_exp_def</b></a>]  Definition
      
      ⊢ ∀m n. cv_exp m n = cv$Num (cv$c2n m ** cv$c2n n)
   
   [<a name="cv_fst_def-val"><b>cv_fst_def</b></a>]  Definition
      
      ⊢ (∀p q. cv_fst (cv$Pair p q) = p) ∧ ∀m. cv_fst (cv$Num m) = cv$Num 0
   
   [<a name="cv_if_def0-val"><b>cv_if_def0</b></a>]  Definition
      
      ⊢ ∀p q r. cv_if p q r = if cv$c2b p then q else r
   
   [<a name="cv_ispair_def-val"><b>cv_ispair_def</b></a>]  Definition
      
      ⊢ (∀p q. cv_ispair (cv$Pair p q) = cv$Num (SUC 0)) ∧
        ∀m. cv_ispair (cv$Num m) = cv$Num 0
   
   [<a name="cv_lt_def0-val"><b>cv_lt_def0</b></a>]  Definition
      
      ⊢ (∀m c.
           cv_lt (cv$Num m) c =
           case c of cv$Num n =&gt; b2c (m &lt; n) | cv$Pair v4 v5 =&gt; cv$Num 0) ∧
        ∀c d e. cv_lt (cv$Pair c d) e = cv$Num 0
   
   [<a name="cv_size_def-val"><b>cv_size_def</b></a>]  Definition
      
      ⊢ (∀n. cv_size (cv$Num n) = n) ∧
        ∀c d. cv_size (cv$Pair c d) = 1 + (cv_size c + cv_size d)
   
   [<a name="cv_snd_def-val"><b>cv_snd_def</b></a>]  Definition
      
      ⊢ (∀p q. cv_snd (cv$Pair p q) = q) ∧ ∀m. cv_snd (cv$Num m) = cv$Num 0
   
   [<a name="CV_EQ-val"><b>CV_EQ</b></a>]  Theorem
      
      ⊢ (cv$Pair p q = cv$Pair r s ⇔ if p = r then q = s else F) ∧
        (cv$Pair p q = cv$Num n ⇔ F) ∧ (cv$Num m = cv$Num n ⇔ m = n)
   
   [<a name="DIV_RECURSIVE-val"><b>DIV_RECURSIVE</b></a>]  Theorem
      
      ⊢ m DIV n =
        if n = 0 then 0 else if m &lt; n then 0 else SUC ((m − n) DIV n)
   
   [<a name="EVEN_to_cv-val"><b>EVEN_to_cv</b></a>]  Theorem
      
      ⊢ EVEN n ⇔ ¬cv$c2b (cv_mod (cv$Num n) (cv$Num 2))
   
   [<a name="LT_RECURSIVE-val"><b>LT_RECURSIVE</b></a>]  Theorem
      
      ⊢ (m &lt; 0 ⇔ F) ∧ (m &lt; SUC n ⇔ if m = n then T else m &lt; n)
   
   [<a name="MOD_RECURSIVE-val"><b>MOD_RECURSIVE</b></a>]  Theorem
      
      ⊢ m MOD n = if n = 0 then m else if m &lt; n then m else (m − n) MOD n
   
   [<a name="Num_11-val"><b>Num_11</b></a>]  Theorem
      
      ⊢ cv$Num m = cv$Num n ⇔ m = n
   
   [<a name="ODD_to_cv-val"><b>ODD_to_cv</b></a>]  Theorem
      
      ⊢ ODD n ⇔ cv$c2b (cv_mod (cv$Num n) (cv$Num 2))
   
   [<a name="Pair_11-val"><b>Pair_11</b></a>]  Theorem
      
      ⊢ cv$Pair c d = cv$Pair e f ⇔ c = e ∧ d = f
   
   [<a name="SUC_EQ-val"><b>SUC_EQ</b></a>]  Theorem
      
      ⊢ (SUC m = 0 ⇔ F) ∧ (SUC m = SUC n ⇔ m = n)
   
   [<a name="add_to_cv-val"><b>add_to_cv</b></a>]  Theorem
      
      ⊢ m + n = cv$c2n (cv_add (cv$Num m) (cv$Num n))
   
   [<a name="b2c-val"><b>b2c</b></a>]  Theorem
      
      ⊢ (b2c x = cv$Num 1 ⇔ x) ∧ (b2c x = cv$Num (SUC 0) ⇔ x)
   
   [<a name="b2c_if-val"><b>b2c_if</b></a>]  Theorem
      
      ⊢ b2c g = if g then cv$Num (SUC 0) else cv$Num 0
   
   [<a name="c2b_thm-val"><b>c2b_thm</b></a>]  Theorem
      
      ⊢ (cv$c2b (cv$Num (SUC n)) ⇔ T) ∧ (cv$c2b (cv$Num 1) ⇔ T) ∧
        (cv$c2b (cv$Num 0) ⇔ F) ∧ (cv$c2b (cv$Num 0) ⇔ F) ∧
        (cv$c2b (cv$Pair x y) ⇔ F)
   
   [<a name="c2n_def-val"><b>c2n_def</b></a>]  Theorem
      
      ⊢ (∀n. cv$c2n (cv$Num n) = n) ∧ ∀c d. cv$c2n (cv$Pair c d) = 0
   
   [<a name="cv_Axiom-val"><b>cv_Axiom</b></a>]  Theorem
      
      ⊢ ∀f g. ∃h.
          (∀n. h (cv$Num n) = f n) ∧
          ∀c d. h (cv$Pair c d) = g c d (h c) (h d)
   
   [<a name="cv_add_def-val"><b>cv_add_def</b></a>]  Theorem
      
      ⊢ cv_add (cv$Num m) (cv$Num n) = cv$Num (m + n) ∧
        cv_add (cv$Num m) (cv$Pair p q) = cv$Num m ∧
        cv_add (cv$Pair p q) (cv$Num n) = cv$Num n ∧
        cv_add (cv$Pair p q) (cv$Pair r s) = cv$Num 0
   
   [<a name="cv_distinct-val"><b>cv_distinct</b></a>]  Theorem
      
      ⊢ cv$Num n ≠ cv$Pair c d
   
   [<a name="cv_div_def-val"><b>cv_div_def</b></a>]  Theorem
      
      ⊢ cv_div (cv$Num m) (cv$Num n) = cv$Num (m DIV n) ∧
        cv_div (cv$Num m) (cv$Pair p q) = cv$Num 0 ∧
        cv_div (cv$Pair p q) (cv$Num n) = cv$Num 0 ∧
        cv_div (cv$Pair p q) (cv$Pair r s) = cv$Num 0
   
   [<a name="cv_eq-val"><b>cv_eq</b></a>]  Theorem
      
      ⊢ cv_eq (cv$Pair x y) (cv$Pair x' y') = b2c (x = x' ∧ y = y') ∧
        cv_eq (cv$Num m) (cv$Num n) = b2c (m = n) ∧
        cv_eq (cv$Pair x y) (cv$Num n) = b2c F ∧
        cv_eq (cv$Num n) (cv$Pair x y) = b2c F
   
   [<a name="cv_eq_def-val"><b>cv_eq_def</b></a>]  Theorem
      
      ⊢ cv_eq p q = cv$Num (if p = q then SUC 0 else 0)
   
   [<a name="cv_exp_eq-val"><b>cv_exp_eq</b></a>]  Theorem
      
      ⊢ cv_exp b e =
        cv_if e
          (cv_if (cv_mod e (cv$Num 2))
             (cv_mul b (cv_exp b (cv_sub e (cv$Num 1))))
             (let x = cv_exp b (cv_div e (cv$Num 2)) in cv_mul x x))
          (cv$Num 1)
   
   [<a name="cv_extras-val"><b>cv_extras</b></a>]  Theorem
      
      ⊢ cv_lt v (cv$Pair x y) = cv$Num 0 ∧
        cv_lt (cv$Pair x y) v = cv$Num 0 ∧
        cv_add (cv$Pair x y) v =
        (case v of cv$Num v4 =&gt; v | cv$Pair a b =&gt; cv$Num 0) ∧
        cv_add v (cv$Pair x y) =
        (case v of cv$Num v4 =&gt; v | cv$Pair a b =&gt; cv$Num 0) ∧
        cv_sub (cv$Pair x y) v = cv$Num 0 ∧
        cv_sub v (cv$Pair x y) =
        (case v of cv$Num v4 =&gt; v | cv$Pair a b =&gt; cv$Num 0) ∧
        cv_mul (cv$Pair x y) v = cv$Num 0 ∧
        cv_mul v (cv$Pair x y) = cv$Num 0 ∧
        cv_div (cv$Pair x y) v = cv$Num 0 ∧
        cv_div v (cv$Pair x y) = cv$Num 0 ∧
        cv_mod (cv$Pair x y) v = cv$Num 0 ∧
        cv_mod v (cv$Pair x y) =
        case v of cv$Num v4 =&gt; v | cv$Pair a b =&gt; cv$Num 0
   
   [<a name="cv_if-val"><b>cv_if</b></a>]  Theorem
      
      ⊢ cv_if x y z = if cv$c2b x then y else z
   
   [<a name="cv_if_cong-val"><b>cv_if_cong</b></a>]  Theorem
      
      ⊢ (cv$c2b P ⇔ cv$c2b Q) ∧ (cv$c2b Q ⇒ x = x') ∧ (¬cv$c2b Q ⇒ y = y') ⇒
        cv_if P x y = cv_if Q x' y'
   
   [<a name="cv_if_def-val"><b>cv_if_def</b></a>]  Theorem
      
      ⊢ cv_if (cv$Num (SUC m)) p q = p ∧ cv_if (cv$Num 0) p q = q ∧
        cv_if (cv$Pair r s) p q = q
   
   [<a name="cv_induction-val"><b>cv_induction</b></a>]  Theorem
      
      ⊢ ∀P. (∀m. P (cv$Num m)) ∧ (∀g g'. P g ∧ P g' ⇒ P (cv$Pair g g')) ⇒
            ∀g. P g
   
   [<a name="cv_lt_def-val"><b>cv_lt_def</b></a>]  Theorem
      
      ⊢ cv_lt (cv$Num m) (cv$Num n) = cv$Num (if m &lt; n then SUC 0 else 0) ∧
        cv_lt (cv$Num m) (cv$Pair p q) = cv$Num 0 ∧
        cv_lt (cv$Pair p q) (cv$Num n) = cv$Num 0 ∧
        cv_lt (cv$Pair p q) (cv$Pair r s) = cv$Num 0
   
   [<a name="cv_mod_def-val"><b>cv_mod_def</b></a>]  Theorem
      
      ⊢ cv_mod (cv$Num m) (cv$Num n) = cv$Num (m MOD n) ∧
        cv_mod (cv$Num m) (cv$Pair p q) = cv$Num m ∧
        cv_mod (cv$Pair p q) (cv$Num n) = cv$Num 0 ∧
        cv_mod (cv$Pair p q) (cv$Pair r s) = cv$Num 0
   
   [<a name="cv_mul_def-val"><b>cv_mul_def</b></a>]  Theorem
      
      ⊢ cv_mul (cv$Num m) (cv$Num n) = cv$Num (m * n) ∧
        cv_mul (cv$Num m) (cv$Pair p q) = cv$Num 0 ∧
        cv_mul (cv$Pair p q) (cv$Num n) = cv$Num 0 ∧
        cv_mul (cv$Pair p q) (cv$Pair r s) = cv$Num 0
   
   [<a name="cv_sub_def-val"><b>cv_sub_def</b></a>]  Theorem
      
      ⊢ cv_sub (cv$Num m) (cv$Num n) = cv$Num (m − n) ∧
        cv_sub (cv$Num m) (cv$Pair p q) = cv$Num m ∧
        cv_sub (cv$Pair p q) (cv$Num n) = cv$Num 0 ∧
        cv_sub (cv$Pair p q) (cv$Pair r s) = cv$Num 0
   
   [<a name="div_to_cv-val"><b>div_to_cv</b></a>]  Theorem
      
      ⊢ m DIV n = cv$c2n (cv_div (cv$Num m) (cv$Num n))
   
   [<a name="exp_to_cv-val"><b>exp_to_cv</b></a>]  Theorem
      
      ⊢ m ** n = cv$c2n (cv_exp (cv$Num m) (cv$Num n))
   
   [<a name="ge_to_cv-val"><b>ge_to_cv</b></a>]  Theorem
      
      ⊢ n ≥ m ⇔ ¬cv$c2b (cv_lt (cv$Num n) (cv$Num m))
   
   [<a name="gt_to_cv-val"><b>gt_to_cv</b></a>]  Theorem
      
      ⊢ m &gt; n ⇔ cv$c2b (cv_lt (cv$Num n) (cv$Num m))
   
   [<a name="isnseq_cases-val"><b>isnseq_cases</b></a>]  Theorem
      
      ⊢ ∀a0. isnseq a0 ⇔ a0 = cv$Num 0 ∨ ∃n c. a0 = cv$Pair n c ∧ isnseq c
   
   [<a name="isnseq_cons-val"><b>isnseq_cons</b></a>]  Theorem
      
      ⊢ ∀n c. isnseq c ⇒ isnseq (cv$Pair n c)
   
   [<a name="isnseq_ind-val"><b>isnseq_ind</b></a>]  Theorem
      
      ⊢ ∀isnseq'.
          isnseq' (cv$Num 0) ∧ (∀n c. isnseq' c ⇒ isnseq' (cv$Pair n c)) ⇒
          ∀a0. isnseq a0 ⇒ isnseq' a0
   
   [<a name="isnseq_nil-val"><b>isnseq_nil</b></a>]  Theorem
      
      ⊢ isnseq (cv$Num 0)
   
   [<a name="isnseq_rules-val"><b>isnseq_rules</b></a>]  Theorem
      
      ⊢ isnseq (cv$Num 0) ∧ ∀n c. isnseq c ⇒ isnseq (cv$Pair n c)
   
   [<a name="isnseq_strongind-val"><b>isnseq_strongind</b></a>]  Theorem
      
      ⊢ ∀isnseq'.
          isnseq' (cv$Num 0) ∧
          (∀n c. isnseq c ∧ isnseq' c ⇒ isnseq' (cv$Pair n c)) ⇒
          ∀a0. isnseq a0 ⇒ isnseq' a0
   
   [<a name="le_to_cv-val"><b>le_to_cv</b></a>]  Theorem
      
      ⊢ m ≤ n ⇔ ¬cv$c2b (cv_lt (cv$Num n) (cv$Num m))
   
   [<a name="lt_to_cv-val"><b>lt_to_cv</b></a>]  Theorem
      
      ⊢ m &lt; n ⇔ cv$c2b (cv_lt (cv$Num m) (cv$Num n))
   
   [<a name="mod_to_cv-val"><b>mod_to_cv</b></a>]  Theorem
      
      ⊢ m MOD n = cv$c2n (cv_mod (cv$Num m) (cv$Num n))
   
   [<a name="mul_to_cv-val"><b>mul_to_cv</b></a>]  Theorem
      
      ⊢ m * n = cv$c2n (cv_mul (cv$Num m) (cv$Num n))
   
   [<a name="neq_to_cv-val"><b>neq_to_cv</b></a>]  Theorem
      
      ⊢ ∀m n. m = n ⇔ cv$c2b (cv_eq (cv$Num m) (cv$Num n))
   
   [<a name="pre_to_cv-val"><b>pre_to_cv</b></a>]  Theorem
      
      ⊢ PRE m = cv$c2n (cv_sub (cv$Num m) (cv$Num 1))
   
   [<a name="sub_to_cv-val"><b>sub_to_cv</b></a>]  Theorem
      
      ⊢ m − n = cv$c2n (cv_sub (cv$Num m) (cv$Num n))
   
   [<a name="suc_to_cv-val"><b>suc_to_cv</b></a>]  Theorem
      
      ⊢ SUC m = cv$c2n (cv_add (cv$Num m) (cv$Num 1))
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/num/theories/cvScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-1</a></em></p></body></html>
