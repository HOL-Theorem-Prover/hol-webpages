<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure real_lebesgueTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure real_lebesgueTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/probability/real_lebesgueScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature real_lebesgueTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#RN_deriv_def-val">RN_deriv_def</a> : thm
<a name="line7"></a>    val <a href="#countable_space_integral_def-val">countable_space_integral_def</a> : thm
<a name="line8"></a>    val <a href="#finite_space_integral_def-val">finite_space_integral_def</a> : thm
<a name="line9"></a>    val <a href="#fn_minus_def-val">fn_minus_def</a> : thm
<a name="line10"></a>    val <a href="#fn_plus_def-val">fn_plus_def</a> : thm
<a name="line11"></a>    val <a href="#integrable_def-val">integrable_def</a> : thm
<a name="line12"></a>    val <a href="#integral_def-val">integral_def</a> : thm
<a name="line13"></a>    val <a href="#max_fn_seq_def-val">max_fn_seq_def</a> : thm
<a name="line14"></a>    val <a href="#mon_upclose_def-val">mon_upclose_def</a> : thm
<a name="line15"></a>    val <a href="#mon_upclose_help_def-val">mon_upclose_help_def</a> : thm
<a name="line16"></a>    val <a href="#nnfis_def-val">nnfis_def</a> : thm
<a name="line17"></a>    val <a href="#nonneg_def-val">nonneg_def</a> : thm
<a name="line18"></a>    val <a href="#pos_fn_integral_def-val">pos_fn_integral_def</a> : thm
<a name="line19"></a>    val <a href="#pos_simple_fn_def-val">pos_simple_fn_def</a> : thm
<a name="line20"></a>    val <a href="#pos_simple_fn_integral_def-val">pos_simple_fn_integral_def</a> : thm
<a name="line21"></a>    val <a href="#prod_measure3_def-val">prod_measure3_def</a> : thm
<a name="line22"></a>    val <a href="#prod_measure_def-val">prod_measure_def</a> : thm
<a name="line23"></a>    val <a href="#prod_measure_space3_def-val">prod_measure_space3_def</a> : thm
<a name="line24"></a>    val <a href="#prod_measure_space_def-val">prod_measure_space_def</a> : thm
<a name="line25"></a>    val <a href="#prod_sets3_def-val">prod_sets3_def</a> : thm
<a name="line26"></a>    val <a href="#psfis_def-val">psfis_def</a> : thm
<a name="line27"></a>    val <a href="#psfs_def-val">psfs_def</a> : thm
<a name="line28"></a>    val <a href="#seq_sup_def-val">seq_sup_def</a> : thm
<a name="line29"></a>    val <a href="#upclose_def-val">upclose_def</a> : thm
<a name="line30"></a>  
<a name="line31"></a>  (*  Theorems  *)
<a name="line32"></a>    val <a href="#IN_psfis-val">IN_psfis</a> : thm
<a name="line33"></a>    val <a href="#REAL_SUP_FUN_SEQ_IMAGE-val">REAL_SUP_FUN_SEQ_IMAGE</a> : thm
<a name="line34"></a>    val <a href="#REAL_SUP_FUN_SEQ_MONO_IMAGE-val">REAL_SUP_FUN_SEQ_MONO_IMAGE</a> : thm
<a name="line35"></a>    val <a href="#REAL_SUP_SEQ-val">REAL_SUP_SEQ</a> : thm
<a name="line36"></a>    val <a href="#borel_measurable_mon_conv_psfis-val">borel_measurable_mon_conv_psfis</a> : thm
<a name="line37"></a>    val <a href="#countable_space_integral_reduce-val">countable_space_integral_reduce</a> : thm
<a name="line38"></a>    val <a href="#finite_POW_RN_deriv_reduce-val">finite_POW_RN_deriv_reduce</a> : thm
<a name="line39"></a>    val <a href="#finite_POW_prod_measure_reduce-val">finite_POW_prod_measure_reduce</a> : thm
<a name="line40"></a>    val <a href="#finite_POW_prod_measure_reduce3-val">finite_POW_prod_measure_reduce3</a> : thm
<a name="line41"></a>    val <a href="#finite_integral_on_set-val">finite_integral_on_set</a> : thm
<a name="line42"></a>    val <a href="#finite_prod_measure_space_POW-val">finite_prod_measure_space_POW</a> : thm
<a name="line43"></a>    val <a href="#finite_prod_measure_space_POW3-val">finite_prod_measure_space_POW3</a> : thm
<a name="line44"></a>    val <a href="#finite_space_POW_integral_reduce-val">finite_space_POW_integral_reduce</a> : thm
<a name="line45"></a>    val <a href="#finite_space_integral_reduce-val">finite_space_integral_reduce</a> : thm
<a name="line46"></a>    val <a href="#fn_plus_fn_minus_borel_measurable-val">fn_plus_fn_minus_borel_measurable</a> : thm
<a name="line47"></a>    val <a href="#fn_plus_fn_minus_borel_measurable_iff-val">fn_plus_fn_minus_borel_measurable_iff</a> : thm
<a name="line48"></a>    val <a href="#indicator_fn_split-val">indicator_fn_split</a> : thm
<a name="line49"></a>    val <a href="#integral_add-val">integral_add</a> : thm
<a name="line50"></a>    val <a href="#integral_borel_measurable-val">integral_borel_measurable</a> : thm
<a name="line51"></a>    val <a href="#integral_cmul_indicator-val">integral_cmul_indicator</a> : thm
<a name="line52"></a>    val <a href="#integral_indicator_fn-val">integral_indicator_fn</a> : thm
<a name="line53"></a>    val <a href="#integral_mono-val">integral_mono</a> : thm
<a name="line54"></a>    val <a href="#integral_times-val">integral_times</a> : thm
<a name="line55"></a>    val <a href="#integral_zero-val">integral_zero</a> : thm
<a name="line56"></a>    val <a href="#markov_ineq-val">markov_ineq</a> : thm
<a name="line57"></a>    val <a href="#max_fn_seq_compute-val">max_fn_seq_compute</a> : thm
<a name="line58"></a>    val <a href="#max_fn_seq_mono-val">max_fn_seq_mono</a> : thm
<a name="line59"></a>    val <a href="#measure_space_finite_prod_measure_POW1-val">measure_space_finite_prod_measure_POW1</a> : thm
<a name="line60"></a>    val <a href="#measure_space_finite_prod_measure_POW2-val">measure_space_finite_prod_measure_POW2</a> : thm
<a name="line61"></a>    val <a href="#measure_space_finite_prod_measure_POW3-val">measure_space_finite_prod_measure_POW3</a> : thm
<a name="line62"></a>    val <a href="#measure_split-val">measure_split</a> : thm
<a name="line63"></a>    val <a href="#mon_upclose_help_compute-val">mon_upclose_help_compute</a> : thm
<a name="line64"></a>    val <a href="#mon_upclose_psfis-val">mon_upclose_psfis</a> : thm
<a name="line65"></a>    val <a href="#nnfis_add-val">nnfis_add</a> : thm
<a name="line66"></a>    val <a href="#nnfis_borel_measurable-val">nnfis_borel_measurable</a> : thm
<a name="line67"></a>    val <a href="#nnfis_dom_conv-val">nnfis_dom_conv</a> : thm
<a name="line68"></a>    val <a href="#nnfis_integral-val">nnfis_integral</a> : thm
<a name="line69"></a>    val <a href="#nnfis_minus_nnfis_integral-val">nnfis_minus_nnfis_integral</a> : thm
<a name="line70"></a>    val <a href="#nnfis_mon_conv-val">nnfis_mon_conv</a> : thm
<a name="line71"></a>    val <a href="#nnfis_mono-val">nnfis_mono</a> : thm
<a name="line72"></a>    val <a href="#nnfis_pos_on_mspace-val">nnfis_pos_on_mspace</a> : thm
<a name="line73"></a>    val <a href="#nnfis_times-val">nnfis_times</a> : thm
<a name="line74"></a>    val <a href="#nnfis_unique-val">nnfis_unique</a> : thm
<a name="line75"></a>    val <a href="#pos_psfis-val">pos_psfis</a> : thm
<a name="line76"></a>    val <a href="#pos_simple_fn_integral_REAL_SUM_IMAGE-val">pos_simple_fn_integral_REAL_SUM_IMAGE</a> : thm
<a name="line77"></a>    val <a href="#pos_simple_fn_integral_add-val">pos_simple_fn_integral_add</a> : thm
<a name="line78"></a>    val <a href="#pos_simple_fn_integral_indicator-val">pos_simple_fn_integral_indicator</a> : thm
<a name="line79"></a>    val <a href="#pos_simple_fn_integral_mono-val">pos_simple_fn_integral_mono</a> : thm
<a name="line80"></a>    val <a href="#pos_simple_fn_integral_mono_on_mspace-val">pos_simple_fn_integral_mono_on_mspace</a> : thm
<a name="line81"></a>    val <a href="#pos_simple_fn_integral_mult-val">pos_simple_fn_integral_mult</a> : thm
<a name="line82"></a>    val <a href="#pos_simple_fn_integral_present-val">pos_simple_fn_integral_present</a> : thm
<a name="line83"></a>    val <a href="#pos_simple_fn_integral_unique-val">pos_simple_fn_integral_unique</a> : thm
<a name="line84"></a>    val <a href="#psfis_REAL_SUM_IMAGE-val">psfis_REAL_SUM_IMAGE</a> : thm
<a name="line85"></a>    val <a href="#psfis_add-val">psfis_add</a> : thm
<a name="line86"></a>    val <a href="#psfis_borel_measurable-val">psfis_borel_measurable</a> : thm
<a name="line87"></a>    val <a href="#psfis_equiv-val">psfis_equiv</a> : thm
<a name="line88"></a>    val <a href="#psfis_indicator-val">psfis_indicator</a> : thm
<a name="line89"></a>    val <a href="#psfis_intro-val">psfis_intro</a> : thm
<a name="line90"></a>    val <a href="#psfis_mono-val">psfis_mono</a> : thm
<a name="line91"></a>    val <a href="#psfis_mono_conv_mono-val">psfis_mono_conv_mono</a> : thm
<a name="line92"></a>    val <a href="#psfis_mult-val">psfis_mult</a> : thm
<a name="line93"></a>    val <a href="#psfis_nnfis-val">psfis_nnfis</a> : thm
<a name="line94"></a>    val <a href="#psfis_nonneg-val">psfis_nonneg</a> : thm
<a name="line95"></a>    val <a href="#psfis_present-val">psfis_present</a> : thm
<a name="line96"></a>    val <a href="#psfis_unique-val">psfis_unique</a> : thm
<a name="line97"></a>    val <a href="#seq_sup_compute-val">seq_sup_compute</a> : thm
<a name="line98"></a>    val <a href="#upclose_psfis-val">upclose_psfis</a> : thm
<a name="line99"></a>  
<a name="line100"></a>  val real_lebesgue_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line101"></a>(*
   [real_measure] Parent theory of "real_lebesgue"
   
   [<a name="RN_deriv_def-val"><b>RN_deriv_def</b></a>]  Definition
      
      âŠ¢ âˆ€m v.
          RN_deriv m v =
          @f. measure_space m âˆ§
              measure_space (m_space m,measurable_sets m,v) âˆ§
              f âˆˆ borel_measurable (m_space m,measurable_sets m) âˆ§
              âˆ€a. a âˆˆ measurable_sets m â‡’
                  integral m (Î»x. f x * indicator_fn a x) = v a
   
   [<a name="countable_space_integral_def-val"><b>countable_space_integral_def</b></a>]  Definition
      
      âŠ¢ âˆ€m f.
          countable_space_integral m f =
          (let
             e = enumerate (IMAGE f (m_space m))
           in
             suminf ((Î»r. r * measure m (PREIMAGE f {r} âˆ© m_space m)) âˆ˜ e))
   
   [<a name="finite_space_integral_def-val"><b>finite_space_integral_def</b></a>]  Definition
      
      âŠ¢ âˆ€m f.
          finite_space_integral m f =
          SIGMA (Î»r. r * measure m (PREIMAGE f {r} âˆ© m_space m))
            (IMAGE f (m_space m))
   
   [<a name="fn_minus_def-val"><b>fn_minus_def</b></a>]  Definition
      
      âŠ¢ âˆ€f. fn_minus f = (Î»x. if 0 â‰¤ f x then 0 else -f x)
   
   [<a name="fn_plus_def-val"><b>fn_plus_def</b></a>]  Definition
      
      âŠ¢ âˆ€f. fn_plus f = (Î»x. if 0 â‰¤ f x then f x else 0)
   
   [<a name="integrable_def-val"><b>integrable_def</b></a>]  Definition
      
      âŠ¢ âˆ€m f.
          integrable m f â‡”
          measure_space m âˆ§ (âˆƒx. x âˆˆ nnfis m (fn_plus f)) âˆ§
          âˆƒy. y âˆˆ nnfis m (fn_minus f)
   
   [<a name="integral_def-val"><b>integral_def</b></a>]  Definition
      
      âŠ¢ âˆ€m f.
          integral m f =
          (@i. i âˆˆ nnfis m (fn_plus f)) âˆ’ @j. j âˆˆ nnfis m (fn_minus f)
   
   [<a name="max_fn_seq_def-val"><b>max_fn_seq_def</b></a>]  Definition
      
      âŠ¢ (âˆ€g x. max_fn_seq g 0 x = g 0 x) âˆ§
        âˆ€g n x.
          max_fn_seq g (SUC n) x = max (max_fn_seq g n x) (g (SUC n) x)
   
   [<a name="mon_upclose_def-val"><b>mon_upclose_def</b></a>]  Definition
      
      âŠ¢ âˆ€u m. mon_upclose u m = mon_upclose_help m u m
   
   [<a name="mon_upclose_help_def-val"><b>mon_upclose_help_def</b></a>]  Definition
      
      âŠ¢ (âˆ€u m. mon_upclose_help 0 u m = u m 0) âˆ§
        âˆ€n u m.
          mon_upclose_help (SUC n) u m =
          upclose (u m (SUC n)) (mon_upclose_help n u m)
   
   [<a name="nnfis_def-val"><b>nnfis_def</b></a>]  Definition
      
      âŠ¢ âˆ€m f.
          nnfis m f =
          {y |
           âˆƒu x.
             mono_convergent u f (m_space m) âˆ§ (âˆ€n. x n âˆˆ psfis m (u n)) âˆ§
             x --&gt; y}
   
   [<a name="nonneg_def-val"><b>nonneg_def</b></a>]  Definition
      
      âŠ¢ âˆ€f. nonneg f â‡” âˆ€x. 0 â‰¤ f x
   
   [<a name="pos_fn_integral_def-val"><b>pos_fn_integral_def</b></a>]  Definition
      
      âŠ¢ âˆ€m f.
          pos_fn_integral m f =
          sup {r | (âˆƒg. r âˆˆ psfis m g âˆ§ âˆ€x. g x â‰¤ f x)}
   
   [<a name="pos_simple_fn_def-val"><b>pos_simple_fn_def</b></a>]  Definition
      
      âŠ¢ âˆ€m f s a x.
          pos_simple_fn m f s a x â‡”
          (âˆ€t. 0 â‰¤ f t) âˆ§
          (âˆ€t. t âˆˆ m_space m â‡’
               f t = SIGMA (Î»i. x i * indicator_fn (a i) t) s) âˆ§
          (âˆ€i. i âˆˆ s â‡’ a i âˆˆ measurable_sets m) âˆ§ (âˆ€i. 0 â‰¤ x i) âˆ§
          FINITE s âˆ§ (âˆ€i j. i âˆˆ s âˆ§ j âˆˆ s âˆ§ i â‰  j â‡’ DISJOINT (a i) (a j)) âˆ§
          BIGUNION (IMAGE a s) = m_space m
   
   [<a name="pos_simple_fn_integral_def-val"><b>pos_simple_fn_integral_def</b></a>]  Definition
      
      âŠ¢ âˆ€m s a x.
          pos_simple_fn_integral m s a x =
          SIGMA (Î»i. x i * measure m (a i)) s
   
   [<a name="prod_measure3_def-val"><b>prod_measure3_def</b></a>]  Definition
      
      âŠ¢ âˆ€m0 m1 m2.
          prod_measure3 m0 m1 m2 =
          prod_measure m0 (prod_measure_space m1 m2)
   
   [<a name="prod_measure_def-val"><b>prod_measure_def</b></a>]  Definition
      
      âŠ¢ âˆ€m0 m1.
          prod_measure m0 m1 =
          (Î»a. integral m0 (Î»s0. measure m1 (PREIMAGE (Î»s1. (s0,s1)) a)))
   
   [<a name="prod_measure_space3_def-val"><b>prod_measure_space3_def</b></a>]  Definition
      
      âŠ¢ âˆ€m0 m1 m2.
          prod_measure_space3 m0 m1 m2 =
          (m_space m0 Ã— m_space m1 Ã— m_space m2,
           subsets
             (sigma (m_space m0 Ã— m_space m1 Ã— m_space m2)
                (prod_sets3 (measurable_sets m0) (measurable_sets m1)
                   (measurable_sets m2))),prod_measure3 m0 m1 m2)
   
   [<a name="prod_measure_space_def-val"><b>prod_measure_space_def</b></a>]  Definition
      
      âŠ¢ âˆ€m0 m1.
          prod_measure_space m0 m1 =
          (m_space m0 Ã— m_space m1,
           subsets
             (sigma (m_space m0 Ã— m_space m1)
                (prod_sets (measurable_sets m0) (measurable_sets m1))),
           prod_measure m0 m1)
   
   [<a name="prod_sets3_def-val"><b>prod_sets3_def</b></a>]  Definition
      
      âŠ¢ âˆ€a b c. prod_sets3 a b c = {s Ã— t Ã— u | s âˆˆ a âˆ§ t âˆˆ b âˆ§ u âˆˆ c}
   
   [<a name="psfis_def-val"><b>psfis_def</b></a>]  Definition
      
      âŠ¢ âˆ€m f.
          psfis m f =
          IMAGE (Î»(s,a,x). pos_simple_fn_integral m s a x) (psfs m f)
   
   [<a name="psfs_def-val"><b>psfs_def</b></a>]  Definition
      
      âŠ¢ âˆ€m f. psfs m f = {(s,a,x) | pos_simple_fn m f s a x}
   
   [<a name="seq_sup_def-val"><b>seq_sup_def</b></a>]  Definition
      
      âŠ¢ (âˆ€P. seq_sup P 0 = @r. r âˆˆ P âˆ§ sup P &lt; r + 1) âˆ§
        âˆ€P n.
          seq_sup P (SUC n) =
          @r. r âˆˆ P âˆ§ sup P &lt; r + (1 / 2) pow SUC n âˆ§ seq_sup P n &lt; r âˆ§
              r &lt; sup P
   
   [<a name="upclose_def-val"><b>upclose_def</b></a>]  Definition
      
      âŠ¢ âˆ€f g. upclose f g = (Î»t. max (f t) (g t))
   
   [<a name="IN_psfis-val"><b>IN_psfis</b></a>]  Theorem
      
      âŠ¢ âˆ€m r f.
          r âˆˆ psfis m f â‡’
          âˆƒs a x.
            pos_simple_fn m f s a x âˆ§ r = pos_simple_fn_integral m s a x
   
   [<a name="REAL_SUP_FUN_SEQ_IMAGE-val"><b>REAL_SUP_FUN_SEQ_IMAGE</b></a>]  Theorem
      
      âŠ¢ âˆ€P P' f.
          (âˆƒx. P x) âˆ§ (âˆƒz. âˆ€x. P x â‡’ x â‰¤ z) âˆ§ P = IMAGE f P' â‡’
          âˆƒg. (âˆ€n. g n âˆˆ P') âˆ§ sup (IMAGE (Î»n. f (g n)) ğ•Œ(:num)) = sup P
   
   [<a name="REAL_SUP_FUN_SEQ_MONO_IMAGE-val"><b>REAL_SUP_FUN_SEQ_MONO_IMAGE</b></a>]  Theorem
      
      âŠ¢ âˆ€P P' f.
          (âˆƒx. P x) âˆ§ (âˆƒz. âˆ€x. P x â‡’ x â‰¤ z) âˆ§ P = IMAGE f P' âˆ§
          (âˆ€g1 g2. g1 âˆˆ P' âˆ§ g2 âˆˆ P' âˆ§ (âˆ€x. g1 x â‰¤ g2 x) â‡’ f g1 â‰¤ f g2) âˆ§
          (âˆ€g1 g2. g1 âˆˆ P' âˆ§ g2 âˆˆ P' â‡’ (Î»x. max (g1 x) (g2 x)) âˆˆ P') â‡’
          âˆƒg. (âˆ€n. g n âˆˆ P') âˆ§ (âˆ€x n. g n x â‰¤ g (SUC n) x) âˆ§
              sup (IMAGE (Î»n. f (g n)) ğ•Œ(:num)) = sup P
   
   [<a name="REAL_SUP_SEQ-val"><b>REAL_SUP_SEQ</b></a>]  Theorem
      
      âŠ¢ âˆ€P. (âˆƒx. P x) âˆ§ (âˆƒz. âˆ€x. P x â‡’ x â‰¤ z) â‡’
            âˆƒx. (âˆ€n. x n âˆˆ P) âˆ§ (âˆ€n. x n â‰¤ x (SUC n)) âˆ§
                sup (IMAGE x ğ•Œ(:num)) = sup P
   
   [<a name="borel_measurable_mon_conv_psfis-val"><b>borel_measurable_mon_conv_psfis</b></a>]  Theorem
      
      âŠ¢ âˆ€m f.
          measure_space m âˆ§
          f âˆˆ borel_measurable (m_space m,measurable_sets m) âˆ§
          (âˆ€t. t âˆˆ m_space m â‡’ 0 â‰¤ f t) â‡’
          âˆƒu x. mono_convergent u f (m_space m) âˆ§ âˆ€n. x n âˆˆ psfis m (u n)
   
   [<a name="countable_space_integral_reduce-val"><b>countable_space_integral_reduce</b></a>]  Theorem
      
      âŠ¢ âˆ€m f p n.
          measure_space m âˆ§ positive m âˆ§
          f âˆˆ borel_measurable (m_space m,measurable_sets m) âˆ§
          countable (IMAGE f (m_space m)) âˆ§
          INFINITE (IMAGE (fn_plus f) (m_space m)) âˆ§
          INFINITE (IMAGE (fn_minus f) (m_space m)) âˆ§
          (Î»r. r * measure m (PREIMAGE (fn_minus f) {r} âˆ© m_space m)) âˆ˜
          enumerate (IMAGE (fn_minus f) (m_space m)) sums n âˆ§
          (Î»r. r * measure m (PREIMAGE (fn_plus f) {r} âˆ© m_space m)) âˆ˜
          enumerate (IMAGE (fn_plus f) (m_space m)) sums p â‡’
          integral m f = p âˆ’ n
   
   [<a name="finite_POW_RN_deriv_reduce-val"><b>finite_POW_RN_deriv_reduce</b></a>]  Theorem
      
      âŠ¢ âˆ€m v.
          measure_space m âˆ§ FINITE (m_space m) âˆ§
          measure_space (m_space m,measurable_sets m,v) âˆ§
          POW (m_space m) = measurable_sets m âˆ§
          (âˆ€x. measure m {x} = 0 â‡’ v {x} = 0) â‡’
          âˆ€x. x âˆˆ m_space m âˆ§ measure m {x} â‰  0 â‡’
              RN_deriv m v x = v {x} / measure m {x}
   
   [<a name="finite_POW_prod_measure_reduce-val"><b>finite_POW_prod_measure_reduce</b></a>]  Theorem
      
      âŠ¢ âˆ€m0 m1.
          measure_space m0 âˆ§ measure_space m1 âˆ§ FINITE (m_space m0) âˆ§
          FINITE (m_space m1) âˆ§ POW (m_space m0) = measurable_sets m0 âˆ§
          POW (m_space m1) = measurable_sets m1 â‡’
          âˆ€a0 a1.
            a0 âˆˆ measurable_sets m0 âˆ§ a1 âˆˆ measurable_sets m1 â‡’
            prod_measure m0 m1 (a0 Ã— a1) = measure m0 a0 * measure m1 a1
   
   [<a name="finite_POW_prod_measure_reduce3-val"><b>finite_POW_prod_measure_reduce3</b></a>]  Theorem
      
      âŠ¢ âˆ€m0 m1 m2.
          measure_space m0 âˆ§ measure_space m1 âˆ§ measure_space m2 âˆ§
          FINITE (m_space m0) âˆ§ FINITE (m_space m1) âˆ§ FINITE (m_space m2) âˆ§
          POW (m_space m0) = measurable_sets m0 âˆ§
          POW (m_space m1) = measurable_sets m1 âˆ§
          POW (m_space m2) = measurable_sets m2 â‡’
          âˆ€a0 a1 a2.
            a0 âˆˆ measurable_sets m0 âˆ§ a1 âˆˆ measurable_sets m1 âˆ§
            a2 âˆˆ measurable_sets m2 â‡’
            prod_measure3 m0 m1 m2 (a0 Ã— a1 Ã— a2) =
            measure m0 a0 * measure m1 a1 * measure m2 a2
   
   [<a name="finite_integral_on_set-val"><b>finite_integral_on_set</b></a>]  Theorem
      
      âŠ¢ âˆ€m f a.
          measure_space m âˆ§ FINITE (m_space m) âˆ§
          f âˆˆ borel_measurable (m_space m,measurable_sets m) âˆ§
          a âˆˆ measurable_sets m â‡’
          integral m (Î»x. f x * indicator_fn a x) =
          SIGMA (Î»r. r * measure m (PREIMAGE f {r} âˆ© a)) (IMAGE f a)
   
   [<a name="finite_prod_measure_space_POW-val"><b>finite_prod_measure_space_POW</b></a>]  Theorem
      
      âŠ¢ âˆ€s1 s2 u v.
          FINITE s1 âˆ§ FINITE s2 â‡’
          prod_measure_space (s1,POW s1,u) (s2,POW s2,v) =
          (s1 Ã— s2,POW (s1 Ã— s2),prod_measure (s1,POW s1,u) (s2,POW s2,v))
   
   [<a name="finite_prod_measure_space_POW3-val"><b>finite_prod_measure_space_POW3</b></a>]  Theorem
      
      âŠ¢ âˆ€s1 s2 s3 u v w.
          FINITE s1 âˆ§ FINITE s2 âˆ§ FINITE s3 â‡’
          prod_measure_space3 (s1,POW s1,u) (s2,POW s2,v) (s3,POW s3,w) =
          (s1 Ã— s2 Ã— s3,POW (s1 Ã— s2 Ã— s3),
           prod_measure3 (s1,POW s1,u) (s2,POW s2,v) (s3,POW s3,w))
   
   [<a name="finite_space_POW_integral_reduce-val"><b>finite_space_POW_integral_reduce</b></a>]  Theorem
      
      âŠ¢ âˆ€m f.
          measure_space m âˆ§ POW (m_space m) = measurable_sets m âˆ§
          FINITE (m_space m) â‡’
          integral m f = SIGMA (Î»x. f x * measure m {x}) (m_space m)
   
   [<a name="finite_space_integral_reduce-val"><b>finite_space_integral_reduce</b></a>]  Theorem
      
      âŠ¢ âˆ€m f.
          measure_space m âˆ§
          f âˆˆ borel_measurable (m_space m,measurable_sets m) âˆ§
          FINITE (m_space m) â‡’
          integral m f = finite_space_integral m f
   
   [<a name="fn_plus_fn_minus_borel_measurable-val"><b>fn_plus_fn_minus_borel_measurable</b></a>]  Theorem
      
      âŠ¢ âˆ€f m.
          measure_space m âˆ§
          f âˆˆ borel_measurable (m_space m,measurable_sets m) â‡’
          fn_plus f âˆˆ borel_measurable (m_space m,measurable_sets m) âˆ§
          fn_minus f âˆˆ borel_measurable (m_space m,measurable_sets m)
   
   [<a name="fn_plus_fn_minus_borel_measurable_iff-val"><b>fn_plus_fn_minus_borel_measurable_iff</b></a>]  Theorem
      
      âŠ¢ âˆ€f m.
          measure_space m â‡’
          (f âˆˆ borel_measurable (m_space m,measurable_sets m) â‡”
           fn_plus f âˆˆ borel_measurable (m_space m,measurable_sets m) âˆ§
           fn_minus f âˆˆ borel_measurable (m_space m,measurable_sets m))
   
   [<a name="indicator_fn_split-val"><b>indicator_fn_split</b></a>]  Theorem
      
      âŠ¢ âˆ€r s b.
          FINITE r âˆ§ BIGUNION (IMAGE b r) = s âˆ§
          (âˆ€i j. i âˆˆ r âˆ§ j âˆˆ r âˆ§ i â‰  j â‡’ DISJOINT (b i) (b j)) â‡’
          âˆ€a. a âŠ† s â‡’
              indicator_fn a = (Î»x. SIGMA (Î»i. indicator_fn (a âˆ© b i) x) r)
   
   [<a name="integral_add-val"><b>integral_add</b></a>]  Theorem
      
      âŠ¢ âˆ€m f g.
          integrable m f âˆ§ integrable m g â‡’
          integrable m (Î»t. f t + g t) âˆ§
          integral m (Î»t. f t + g t) = integral m f + integral m g
   
   [<a name="integral_borel_measurable-val"><b>integral_borel_measurable</b></a>]  Theorem
      
      âŠ¢ âˆ€m f.
          integrable m f â‡’
          f âˆˆ borel_measurable (m_space m,measurable_sets m)
   
   [<a name="integral_cmul_indicator-val"><b>integral_cmul_indicator</b></a>]  Theorem
      
      âŠ¢ âˆ€m s c.
          measure_space m âˆ§ s âˆˆ measurable_sets m â‡’
          integral m (Î»x. c * indicator_fn s x) = c * measure m s
   
   [<a name="integral_indicator_fn-val"><b>integral_indicator_fn</b></a>]  Theorem
      
      âŠ¢ âˆ€m a.
          measure_space m âˆ§ a âˆˆ measurable_sets m â‡’
          integral m (indicator_fn a) = measure m a âˆ§
          integrable m (indicator_fn a)
   
   [<a name="integral_mono-val"><b>integral_mono</b></a>]  Theorem
      
      âŠ¢ âˆ€m f g.
          integrable m f âˆ§ integrable m g âˆ§ (âˆ€t. t âˆˆ m_space m â‡’ f t â‰¤ g t) â‡’
          integral m f â‰¤ integral m g
   
   [<a name="integral_times-val"><b>integral_times</b></a>]  Theorem
      
      âŠ¢ âˆ€m f a.
          integrable m f â‡’
          integrable m (Î»t. a * f t) âˆ§
          integral m (Î»t. a * f t) = a * integral m f
   
   [<a name="integral_zero-val"><b>integral_zero</b></a>]  Theorem
      
      âŠ¢ âˆ€m. measure_space m â‡’ integral m (Î»x. 0) = 0
   
   [<a name="markov_ineq-val"><b>markov_ineq</b></a>]  Theorem
      
      âŠ¢ âˆ€m f a n.
          integrable m f âˆ§ 0 &lt; a âˆ§ integrable m (Î»x. abs (f x) pow n) â‡’
          measure m (PREIMAGE f {y | a â‰¤ y} âˆ© m_space m) â‰¤
          integral m (Î»x. abs (f x) pow n) / a pow n
   
   [<a name="max_fn_seq_compute-val"><b>max_fn_seq_compute</b></a>]  Theorem
      
      âŠ¢ (âˆ€g x. max_fn_seq g 0 x = g 0 x) âˆ§
        (âˆ€g n x.
           max_fn_seq g (NUMERAL (BIT1 n)) x =
           max (max_fn_seq g (NUMERAL (BIT1 n) âˆ’ 1) x)
             (g (NUMERAL (BIT1 n)) x)) âˆ§
        âˆ€g n x.
          max_fn_seq g (NUMERAL (BIT2 n)) x =
          max (max_fn_seq g (NUMERAL (BIT1 n)) x) (g (NUMERAL (BIT2 n)) x)
   
   [<a name="max_fn_seq_mono-val"><b>max_fn_seq_mono</b></a>]  Theorem
      
      âŠ¢ âˆ€g n x. max_fn_seq g n x â‰¤ max_fn_seq g (SUC n) x
   
   [<a name="measure_space_finite_prod_measure_POW1-val"><b>measure_space_finite_prod_measure_POW1</b></a>]  Theorem
      
      âŠ¢ âˆ€m0 m1.
          measure_space m0 âˆ§ measure_space m1 âˆ§ FINITE (m_space m0) âˆ§
          FINITE (m_space m1) âˆ§ POW (m_space m0) = measurable_sets m0 âˆ§
          POW (m_space m1) = measurable_sets m1 â‡’
          measure_space (prod_measure_space m0 m1)
   
   [<a name="measure_space_finite_prod_measure_POW2-val"><b>measure_space_finite_prod_measure_POW2</b></a>]  Theorem
      
      âŠ¢ âˆ€m0 m1.
          measure_space m0 âˆ§ measure_space m1 âˆ§ FINITE (m_space m0) âˆ§
          FINITE (m_space m1) âˆ§ POW (m_space m0) = measurable_sets m0 âˆ§
          POW (m_space m1) = measurable_sets m1 â‡’
          measure_space
            (m_space m0 Ã— m_space m1,POW (m_space m0 Ã— m_space m1),
             prod_measure m0 m1)
   
   [<a name="measure_space_finite_prod_measure_POW3-val"><b>measure_space_finite_prod_measure_POW3</b></a>]  Theorem
      
      âŠ¢ âˆ€m0 m1 m2.
          measure_space m0 âˆ§ measure_space m1 âˆ§ measure_space m2 âˆ§
          FINITE (m_space m0) âˆ§ FINITE (m_space m1) âˆ§ FINITE (m_space m2) âˆ§
          POW (m_space m0) = measurable_sets m0 âˆ§
          POW (m_space m1) = measurable_sets m1 âˆ§
          POW (m_space m2) = measurable_sets m2 â‡’
          measure_space
            (m_space m0 Ã— m_space m1 Ã— m_space m2,
             POW (m_space m0 Ã— m_space m1 Ã— m_space m2),
             prod_measure3 m0 m1 m2)
   
   [<a name="measure_split-val"><b>measure_split</b></a>]  Theorem
      
      âŠ¢ âˆ€r b m.
          measure_space m âˆ§ FINITE r âˆ§ BIGUNION (IMAGE b r) = m_space m âˆ§
          (âˆ€i j. i âˆˆ r âˆ§ j âˆˆ r âˆ§ i â‰  j â‡’ DISJOINT (b i) (b j)) âˆ§
          (âˆ€i. i âˆˆ r â‡’ b i âˆˆ measurable_sets m) â‡’
          âˆ€a. a âˆˆ measurable_sets m â‡’
              measure m a = SIGMA (Î»i. measure m (a âˆ© b i)) r
   
   [<a name="mon_upclose_help_compute-val"><b>mon_upclose_help_compute</b></a>]  Theorem
      
      âŠ¢ (âˆ€u m. mon_upclose_help 0 u m = u m 0) âˆ§
        (âˆ€n u m.
           mon_upclose_help (NUMERAL (BIT1 n)) u m =
           upclose (u m (NUMERAL (BIT1 n)))
             (mon_upclose_help (NUMERAL (BIT1 n) âˆ’ 1) u m)) âˆ§
        âˆ€n u m.
          mon_upclose_help (NUMERAL (BIT2 n)) u m =
          upclose (u m (NUMERAL (BIT2 n)))
            (mon_upclose_help (NUMERAL (BIT1 n)) u m)
   
   [<a name="mon_upclose_psfis-val"><b>mon_upclose_psfis</b></a>]  Theorem
      
      âŠ¢ âˆ€m u.
          measure_space m âˆ§ (âˆ€n n'. âˆƒa. a âˆˆ psfis m (u n n')) â‡’
          âˆƒc. âˆ€n. c n âˆˆ psfis m (mon_upclose u n)
   
   [<a name="nnfis_add-val"><b>nnfis_add</b></a>]  Theorem
      
      âŠ¢ âˆ€f g m a b.
          measure_space m âˆ§ a âˆˆ nnfis m f âˆ§ b âˆˆ nnfis m g â‡’
          a + b âˆˆ nnfis m (Î»w. f w + g w)
   
   [<a name="nnfis_borel_measurable-val"><b>nnfis_borel_measurable</b></a>]  Theorem
      
      âŠ¢ âˆ€m f a.
          measure_space m âˆ§ a âˆˆ nnfis m f â‡’
          f âˆˆ borel_measurable (m_space m,measurable_sets m)
   
   [<a name="nnfis_dom_conv-val"><b>nnfis_dom_conv</b></a>]  Theorem
      
      âŠ¢ âˆ€m f g b.
          measure_space m âˆ§
          f âˆˆ borel_measurable (m_space m,measurable_sets m) âˆ§
          b âˆˆ nnfis m g âˆ§ (âˆ€t. t âˆˆ m_space m â‡’ f t â‰¤ g t) âˆ§
          (âˆ€t. t âˆˆ m_space m â‡’ 0 â‰¤ f t) â‡’
          âˆƒa. a âˆˆ nnfis m f âˆ§ a â‰¤ b
   
   [<a name="nnfis_integral-val"><b>nnfis_integral</b></a>]  Theorem
      
      âŠ¢ âˆ€m f a.
          measure_space m âˆ§ a âˆˆ nnfis m f â‡’
          integrable m f âˆ§ integral m f = a
   
   [<a name="nnfis_minus_nnfis_integral-val"><b>nnfis_minus_nnfis_integral</b></a>]  Theorem
      
      âŠ¢ âˆ€m f g a b.
          measure_space m âˆ§ a âˆˆ nnfis m f âˆ§ b âˆˆ nnfis m g â‡’
          integrable m (Î»t. f t âˆ’ g t) âˆ§ integral m (Î»t. f t âˆ’ g t) = a âˆ’ b
   
   [<a name="nnfis_mon_conv-val"><b>nnfis_mon_conv</b></a>]  Theorem
      
      âŠ¢ âˆ€f m h x y.
          measure_space m âˆ§ mono_convergent f h (m_space m) âˆ§
          (âˆ€n. x n âˆˆ nnfis m (f n)) âˆ§ x --&gt; y â‡’
          y âˆˆ nnfis m h
   
   [<a name="nnfis_mono-val"><b>nnfis_mono</b></a>]  Theorem
      
      âŠ¢ âˆ€f g m a b.
          measure_space m âˆ§ a âˆˆ nnfis m f âˆ§ b âˆˆ nnfis m g âˆ§
          (âˆ€w. w âˆˆ m_space m â‡’ f w â‰¤ g w) â‡’
          a â‰¤ b
   
   [<a name="nnfis_pos_on_mspace-val"><b>nnfis_pos_on_mspace</b></a>]  Theorem
      
      âŠ¢ âˆ€f m a.
          measure_space m âˆ§ a âˆˆ nnfis m f â‡’ âˆ€x. x âˆˆ m_space m â‡’ 0 â‰¤ f x
   
   [<a name="nnfis_times-val"><b>nnfis_times</b></a>]  Theorem
      
      âŠ¢ âˆ€f m a z.
          measure_space m âˆ§ a âˆˆ nnfis m f âˆ§ 0 â‰¤ z â‡’
          z * a âˆˆ nnfis m (Î»w. z * f w)
   
   [<a name="nnfis_unique-val"><b>nnfis_unique</b></a>]  Theorem
      
      âŠ¢ âˆ€f m a b. measure_space m âˆ§ a âˆˆ nnfis m f âˆ§ b âˆˆ nnfis m f â‡’ a = b
   
   [<a name="pos_psfis-val"><b>pos_psfis</b></a>]  Theorem
      
      âŠ¢ âˆ€r m f. measure_space m âˆ§ r âˆˆ psfis m f â‡’ 0 â‰¤ r
   
   [<a name="pos_simple_fn_integral_REAL_SUM_IMAGE-val"><b>pos_simple_fn_integral_REAL_SUM_IMAGE</b></a>]  Theorem
      
      âŠ¢ âˆ€m f s a x P.
          measure_space m âˆ§
          (âˆ€i. i âˆˆ P â‡’ pos_simple_fn m (f i) (s i) (a i) (x i)) âˆ§ FINITE P â‡’
          âˆƒs' a' x'.
            pos_simple_fn m (Î»t. SIGMA (Î»i. f i t) P) s' a' x' âˆ§
            pos_simple_fn_integral m s' a' x' =
            SIGMA (Î»i. pos_simple_fn_integral m (s i) (a i) (x i)) P
   
   [<a name="pos_simple_fn_integral_add-val"><b>pos_simple_fn_integral_add</b></a>]  Theorem
      
      âŠ¢ âˆ€m f s a x g s' b y.
          measure_space m âˆ§ pos_simple_fn m f s a x âˆ§
          pos_simple_fn m g s' b y â‡’
          âˆƒs'' c z.
            pos_simple_fn m (Î»x. f x + g x) s'' c z âˆ§
            pos_simple_fn_integral m s a x +
            pos_simple_fn_integral m s' b y =
            pos_simple_fn_integral m s'' c z
   
   [<a name="pos_simple_fn_integral_indicator-val"><b>pos_simple_fn_integral_indicator</b></a>]  Theorem
      
      âŠ¢ âˆ€m A.
          measure_space m âˆ§ A âˆˆ measurable_sets m â‡’
          âˆƒs a x.
            pos_simple_fn m (indicator_fn A) s a x âˆ§
            pos_simple_fn_integral m s a x = measure m A
   
   [<a name="pos_simple_fn_integral_mono-val"><b>pos_simple_fn_integral_mono</b></a>]  Theorem
      
      âŠ¢ âˆ€m f s a x g s' b y.
          measure_space m âˆ§ pos_simple_fn m f s a x âˆ§
          pos_simple_fn m g s' b y âˆ§ (âˆ€x. f x â‰¤ g x) â‡’
          pos_simple_fn_integral m s a x â‰¤ pos_simple_fn_integral m s' b y
   
   [<a name="pos_simple_fn_integral_mono_on_mspace-val"><b>pos_simple_fn_integral_mono_on_mspace</b></a>]  Theorem
      
      âŠ¢ âˆ€m f s a x g s' b y.
          measure_space m âˆ§ pos_simple_fn m f s a x âˆ§
          pos_simple_fn m g s' b y âˆ§ (âˆ€x. x âˆˆ m_space m â‡’ f x â‰¤ g x) â‡’
          pos_simple_fn_integral m s a x â‰¤ pos_simple_fn_integral m s' b y
   
   [<a name="pos_simple_fn_integral_mult-val"><b>pos_simple_fn_integral_mult</b></a>]  Theorem
      
      âŠ¢ âˆ€m f s a x.
          measure_space m âˆ§ pos_simple_fn m f s a x â‡’
          âˆ€z. 0 â‰¤ z â‡’
              âˆƒs' b y.
                pos_simple_fn m (Î»x. z * f x) s' b y âˆ§
                pos_simple_fn_integral m s' b y =
                z * pos_simple_fn_integral m s a x
   
   [<a name="pos_simple_fn_integral_present-val"><b>pos_simple_fn_integral_present</b></a>]  Theorem
      
      âŠ¢ âˆ€m f s a x g s' b y.
          measure_space m âˆ§ pos_simple_fn m f s a x âˆ§
          pos_simple_fn m g s' b y â‡’
          âˆƒz z' c k.
            (âˆ€t. t âˆˆ m_space m â‡’
                 f t = SIGMA (Î»i. z i * indicator_fn (c i) t) k) âˆ§
            (âˆ€t. t âˆˆ m_space m â‡’
                 g t = SIGMA (Î»i. z' i * indicator_fn (c i) t) k) âˆ§
            pos_simple_fn_integral m s a x = pos_simple_fn_integral m k c z âˆ§
            pos_simple_fn_integral m s' b y =
            pos_simple_fn_integral m k c z' âˆ§ FINITE k âˆ§
            (âˆ€i j. i âˆˆ k âˆ§ j âˆˆ k âˆ§ i â‰  j â‡’ DISJOINT (c i) (c j)) âˆ§
            (âˆ€i. i âˆˆ k â‡’ c i âˆˆ measurable_sets m) âˆ§
            BIGUNION (IMAGE c k) = m_space m âˆ§ (âˆ€i. 0 â‰¤ z i) âˆ§ âˆ€i. 0 â‰¤ z' i
   
   [<a name="pos_simple_fn_integral_unique-val"><b>pos_simple_fn_integral_unique</b></a>]  Theorem
      
      âŠ¢ âˆ€m f s a x s' b y.
          measure_space m âˆ§ pos_simple_fn m f s a x âˆ§
          pos_simple_fn m f s' b y â‡’
          pos_simple_fn_integral m s a x = pos_simple_fn_integral m s' b y
   
   [<a name="psfis_REAL_SUM_IMAGE-val"><b>psfis_REAL_SUM_IMAGE</b></a>]  Theorem
      
      âŠ¢ âˆ€m f a P.
          measure_space m âˆ§ (âˆ€i. i âˆˆ P â‡’ a i âˆˆ psfis m (f i)) âˆ§ FINITE P â‡’
          SIGMA a P âˆˆ psfis m (Î»t. SIGMA (Î»i. f i t) P)
   
   [<a name="psfis_add-val"><b>psfis_add</b></a>]  Theorem
      
      âŠ¢ âˆ€m f g a b.
          measure_space m âˆ§ a âˆˆ psfis m f âˆ§ b âˆˆ psfis m g â‡’
          a + b âˆˆ psfis m (Î»x. f x + g x)
   
   [<a name="psfis_borel_measurable-val"><b>psfis_borel_measurable</b></a>]  Theorem
      
      âŠ¢ âˆ€m f a.
          measure_space m âˆ§ a âˆˆ psfis m f â‡’
          f âˆˆ borel_measurable (m_space m,measurable_sets m)
   
   [<a name="psfis_equiv-val"><b>psfis_equiv</b></a>]  Theorem
      
      âŠ¢ âˆ€f g a m.
          measure_space m âˆ§ a âˆˆ psfis m f âˆ§ (âˆ€t. 0 â‰¤ g t) âˆ§
          (âˆ€t. t âˆˆ m_space m â‡’ f t = g t) â‡’
          a âˆˆ psfis m g
   
   [<a name="psfis_indicator-val"><b>psfis_indicator</b></a>]  Theorem
      
      âŠ¢ âˆ€m A.
          measure_space m âˆ§ A âˆˆ measurable_sets m â‡’
          measure m A âˆˆ psfis m (indicator_fn A)
   
   [<a name="psfis_intro-val"><b>psfis_intro</b></a>]  Theorem
      
      âŠ¢ âˆ€m a x P.
          measure_space m âˆ§ (âˆ€i. i âˆˆ P â‡’ a i âˆˆ measurable_sets m) âˆ§
          (âˆ€i. 0 â‰¤ x i) âˆ§ FINITE P â‡’
          SIGMA (Î»i. x i * measure m (a i)) P âˆˆ
          psfis m (Î»t. SIGMA (Î»i. x i * indicator_fn (a i) t) P)
   
   [<a name="psfis_mono-val"><b>psfis_mono</b></a>]  Theorem
      
      âŠ¢ âˆ€m f g a b.
          measure_space m âˆ§ a âˆˆ psfis m f âˆ§ b âˆˆ psfis m g âˆ§
          (âˆ€x. x âˆˆ m_space m â‡’ f x â‰¤ g x) â‡’
          a â‰¤ b
   
   [<a name="psfis_mono_conv_mono-val"><b>psfis_mono_conv_mono</b></a>]  Theorem
      
      âŠ¢ âˆ€m f u x y r s.
          measure_space m âˆ§ mono_convergent u f (m_space m) âˆ§
          (âˆ€n. x n âˆˆ psfis m (u n)) âˆ§ (âˆ€m n. m â‰¤ n â‡’ x m â‰¤ x n) âˆ§ x --&gt; y âˆ§
          r âˆˆ psfis m s âˆ§ (âˆ€a. a âˆˆ m_space m â‡’ s a â‰¤ f a) â‡’
          r â‰¤ y
   
   [<a name="psfis_mult-val"><b>psfis_mult</b></a>]  Theorem
      
      âŠ¢ âˆ€m f a.
          measure_space m âˆ§ a âˆˆ psfis m f â‡’
          âˆ€z. 0 â‰¤ z â‡’ z * a âˆˆ psfis m (Î»x. z * f x)
   
   [<a name="psfis_nnfis-val"><b>psfis_nnfis</b></a>]  Theorem
      
      âŠ¢ âˆ€m f a. measure_space m âˆ§ a âˆˆ psfis m f â‡’ a âˆˆ nnfis m f
   
   [<a name="psfis_nonneg-val"><b>psfis_nonneg</b></a>]  Theorem
      
      âŠ¢ âˆ€m f a. a âˆˆ psfis m f â‡’ nonneg f
   
   [<a name="psfis_present-val"><b>psfis_present</b></a>]  Theorem
      
      âŠ¢ âˆ€m f g a b.
          measure_space m âˆ§ a âˆˆ psfis m f âˆ§ b âˆˆ psfis m g â‡’
          âˆƒz z' c k.
            (âˆ€t. t âˆˆ m_space m â‡’
                 f t = SIGMA (Î»i. z i * indicator_fn (c i) t) k) âˆ§
            (âˆ€t. t âˆˆ m_space m â‡’
                 g t = SIGMA (Î»i. z' i * indicator_fn (c i) t) k) âˆ§
            a = pos_simple_fn_integral m k c z âˆ§
            b = pos_simple_fn_integral m k c z' âˆ§ FINITE k âˆ§
            (âˆ€i j. i âˆˆ k âˆ§ j âˆˆ k âˆ§ i â‰  j â‡’ DISJOINT (c i) (c j)) âˆ§
            (âˆ€i. i âˆˆ k â‡’ c i âˆˆ measurable_sets m) âˆ§
            BIGUNION (IMAGE c k) = m_space m âˆ§ (âˆ€i. 0 â‰¤ z i) âˆ§ âˆ€i. 0 â‰¤ z' i
   
   [<a name="psfis_unique-val"><b>psfis_unique</b></a>]  Theorem
      
      âŠ¢ âˆ€m f a b. measure_space m âˆ§ a âˆˆ psfis m f âˆ§ b âˆˆ psfis m f â‡’ a = b
   
   [<a name="seq_sup_compute-val"><b>seq_sup_compute</b></a>]  Theorem
      
      âŠ¢ (âˆ€P. seq_sup P 0 = @r. r âˆˆ P âˆ§ sup P &lt; r + 1) âˆ§
        (âˆ€P n.
           seq_sup P (NUMERAL (BIT1 n)) =
           @r. r âˆˆ P âˆ§ sup P &lt; r + (1 / 2) pow NUMERAL (BIT1 n) âˆ§
               seq_sup P (NUMERAL (BIT1 n) âˆ’ 1) &lt; r âˆ§ r &lt; sup P) âˆ§
        âˆ€P n.
          seq_sup P (NUMERAL (BIT2 n)) =
          @r. r âˆˆ P âˆ§ sup P &lt; r + (1 / 2) pow NUMERAL (BIT2 n) âˆ§
              seq_sup P (NUMERAL (BIT1 n)) &lt; r âˆ§ r &lt; sup P
   
   [<a name="upclose_psfis-val"><b>upclose_psfis</b></a>]  Theorem
      
      âŠ¢ âˆ€f g a b m.
          measure_space m âˆ§ a âˆˆ psfis m f âˆ§ b âˆˆ psfis m g â‡’
          âˆƒc. c âˆˆ psfis m (upclose f g)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/probability/real_lebesgueScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-1</a></em></p></body></html>
