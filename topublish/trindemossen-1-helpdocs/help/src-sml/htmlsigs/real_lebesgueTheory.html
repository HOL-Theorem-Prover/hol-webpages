<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure real_lebesgueTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure real_lebesgueTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/probability/real_lebesgueScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature real_lebesgueTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#RN_deriv_def-val">RN_deriv_def</a> : thm
<a name="line7"></a>    val <a href="#countable_space_integral_def-val">countable_space_integral_def</a> : thm
<a name="line8"></a>    val <a href="#finite_space_integral_def-val">finite_space_integral_def</a> : thm
<a name="line9"></a>    val <a href="#fn_minus_def-val">fn_minus_def</a> : thm
<a name="line10"></a>    val <a href="#fn_plus_def-val">fn_plus_def</a> : thm
<a name="line11"></a>    val <a href="#integrable_def-val">integrable_def</a> : thm
<a name="line12"></a>    val <a href="#integral_def-val">integral_def</a> : thm
<a name="line13"></a>    val <a href="#max_fn_seq_def-val">max_fn_seq_def</a> : thm
<a name="line14"></a>    val <a href="#mon_upclose_def-val">mon_upclose_def</a> : thm
<a name="line15"></a>    val <a href="#mon_upclose_help_def-val">mon_upclose_help_def</a> : thm
<a name="line16"></a>    val <a href="#nnfis_def-val">nnfis_def</a> : thm
<a name="line17"></a>    val <a href="#nonneg_def-val">nonneg_def</a> : thm
<a name="line18"></a>    val <a href="#pos_fn_integral_def-val">pos_fn_integral_def</a> : thm
<a name="line19"></a>    val <a href="#pos_simple_fn_def-val">pos_simple_fn_def</a> : thm
<a name="line20"></a>    val <a href="#pos_simple_fn_integral_def-val">pos_simple_fn_integral_def</a> : thm
<a name="line21"></a>    val <a href="#prod_measure3_def-val">prod_measure3_def</a> : thm
<a name="line22"></a>    val <a href="#prod_measure_def-val">prod_measure_def</a> : thm
<a name="line23"></a>    val <a href="#prod_measure_space3_def-val">prod_measure_space3_def</a> : thm
<a name="line24"></a>    val <a href="#prod_measure_space_def-val">prod_measure_space_def</a> : thm
<a name="line25"></a>    val <a href="#prod_sets3_def-val">prod_sets3_def</a> : thm
<a name="line26"></a>    val <a href="#psfis_def-val">psfis_def</a> : thm
<a name="line27"></a>    val <a href="#psfs_def-val">psfs_def</a> : thm
<a name="line28"></a>    val <a href="#seq_sup_def-val">seq_sup_def</a> : thm
<a name="line29"></a>    val <a href="#upclose_def-val">upclose_def</a> : thm
<a name="line30"></a>  
<a name="line31"></a>  (*  Theorems  *)
<a name="line32"></a>    val <a href="#IN_psfis-val">IN_psfis</a> : thm
<a name="line33"></a>    val <a href="#REAL_SUP_FUN_SEQ_IMAGE-val">REAL_SUP_FUN_SEQ_IMAGE</a> : thm
<a name="line34"></a>    val <a href="#REAL_SUP_FUN_SEQ_MONO_IMAGE-val">REAL_SUP_FUN_SEQ_MONO_IMAGE</a> : thm
<a name="line35"></a>    val <a href="#REAL_SUP_SEQ-val">REAL_SUP_SEQ</a> : thm
<a name="line36"></a>    val <a href="#borel_measurable_mon_conv_psfis-val">borel_measurable_mon_conv_psfis</a> : thm
<a name="line37"></a>    val <a href="#countable_space_integral_reduce-val">countable_space_integral_reduce</a> : thm
<a name="line38"></a>    val <a href="#finite_POW_RN_deriv_reduce-val">finite_POW_RN_deriv_reduce</a> : thm
<a name="line39"></a>    val <a href="#finite_POW_prod_measure_reduce-val">finite_POW_prod_measure_reduce</a> : thm
<a name="line40"></a>    val <a href="#finite_POW_prod_measure_reduce3-val">finite_POW_prod_measure_reduce3</a> : thm
<a name="line41"></a>    val <a href="#finite_integral_on_set-val">finite_integral_on_set</a> : thm
<a name="line42"></a>    val <a href="#finite_prod_measure_space_POW-val">finite_prod_measure_space_POW</a> : thm
<a name="line43"></a>    val <a href="#finite_prod_measure_space_POW3-val">finite_prod_measure_space_POW3</a> : thm
<a name="line44"></a>    val <a href="#finite_space_POW_integral_reduce-val">finite_space_POW_integral_reduce</a> : thm
<a name="line45"></a>    val <a href="#finite_space_integral_reduce-val">finite_space_integral_reduce</a> : thm
<a name="line46"></a>    val <a href="#fn_plus_fn_minus_borel_measurable-val">fn_plus_fn_minus_borel_measurable</a> : thm
<a name="line47"></a>    val <a href="#fn_plus_fn_minus_borel_measurable_iff-val">fn_plus_fn_minus_borel_measurable_iff</a> : thm
<a name="line48"></a>    val <a href="#indicator_fn_split-val">indicator_fn_split</a> : thm
<a name="line49"></a>    val <a href="#integral_add-val">integral_add</a> : thm
<a name="line50"></a>    val <a href="#integral_borel_measurable-val">integral_borel_measurable</a> : thm
<a name="line51"></a>    val <a href="#integral_cmul_indicator-val">integral_cmul_indicator</a> : thm
<a name="line52"></a>    val <a href="#integral_indicator_fn-val">integral_indicator_fn</a> : thm
<a name="line53"></a>    val <a href="#integral_mono-val">integral_mono</a> : thm
<a name="line54"></a>    val <a href="#integral_times-val">integral_times</a> : thm
<a name="line55"></a>    val <a href="#integral_zero-val">integral_zero</a> : thm
<a name="line56"></a>    val <a href="#markov_ineq-val">markov_ineq</a> : thm
<a name="line57"></a>    val <a href="#max_fn_seq_compute-val">max_fn_seq_compute</a> : thm
<a name="line58"></a>    val <a href="#max_fn_seq_mono-val">max_fn_seq_mono</a> : thm
<a name="line59"></a>    val <a href="#measure_space_finite_prod_measure_POW1-val">measure_space_finite_prod_measure_POW1</a> : thm
<a name="line60"></a>    val <a href="#measure_space_finite_prod_measure_POW2-val">measure_space_finite_prod_measure_POW2</a> : thm
<a name="line61"></a>    val <a href="#measure_space_finite_prod_measure_POW3-val">measure_space_finite_prod_measure_POW3</a> : thm
<a name="line62"></a>    val <a href="#measure_split-val">measure_split</a> : thm
<a name="line63"></a>    val <a href="#mon_upclose_help_compute-val">mon_upclose_help_compute</a> : thm
<a name="line64"></a>    val <a href="#mon_upclose_psfis-val">mon_upclose_psfis</a> : thm
<a name="line65"></a>    val <a href="#nnfis_add-val">nnfis_add</a> : thm
<a name="line66"></a>    val <a href="#nnfis_borel_measurable-val">nnfis_borel_measurable</a> : thm
<a name="line67"></a>    val <a href="#nnfis_dom_conv-val">nnfis_dom_conv</a> : thm
<a name="line68"></a>    val <a href="#nnfis_integral-val">nnfis_integral</a> : thm
<a name="line69"></a>    val <a href="#nnfis_minus_nnfis_integral-val">nnfis_minus_nnfis_integral</a> : thm
<a name="line70"></a>    val <a href="#nnfis_mon_conv-val">nnfis_mon_conv</a> : thm
<a name="line71"></a>    val <a href="#nnfis_mono-val">nnfis_mono</a> : thm
<a name="line72"></a>    val <a href="#nnfis_pos_on_mspace-val">nnfis_pos_on_mspace</a> : thm
<a name="line73"></a>    val <a href="#nnfis_times-val">nnfis_times</a> : thm
<a name="line74"></a>    val <a href="#nnfis_unique-val">nnfis_unique</a> : thm
<a name="line75"></a>    val <a href="#pos_psfis-val">pos_psfis</a> : thm
<a name="line76"></a>    val <a href="#pos_simple_fn_integral_REAL_SUM_IMAGE-val">pos_simple_fn_integral_REAL_SUM_IMAGE</a> : thm
<a name="line77"></a>    val <a href="#pos_simple_fn_integral_add-val">pos_simple_fn_integral_add</a> : thm
<a name="line78"></a>    val <a href="#pos_simple_fn_integral_indicator-val">pos_simple_fn_integral_indicator</a> : thm
<a name="line79"></a>    val <a href="#pos_simple_fn_integral_mono-val">pos_simple_fn_integral_mono</a> : thm
<a name="line80"></a>    val <a href="#pos_simple_fn_integral_mono_on_mspace-val">pos_simple_fn_integral_mono_on_mspace</a> : thm
<a name="line81"></a>    val <a href="#pos_simple_fn_integral_mult-val">pos_simple_fn_integral_mult</a> : thm
<a name="line82"></a>    val <a href="#pos_simple_fn_integral_present-val">pos_simple_fn_integral_present</a> : thm
<a name="line83"></a>    val <a href="#pos_simple_fn_integral_unique-val">pos_simple_fn_integral_unique</a> : thm
<a name="line84"></a>    val <a href="#psfis_REAL_SUM_IMAGE-val">psfis_REAL_SUM_IMAGE</a> : thm
<a name="line85"></a>    val <a href="#psfis_add-val">psfis_add</a> : thm
<a name="line86"></a>    val <a href="#psfis_borel_measurable-val">psfis_borel_measurable</a> : thm
<a name="line87"></a>    val <a href="#psfis_equiv-val">psfis_equiv</a> : thm
<a name="line88"></a>    val <a href="#psfis_indicator-val">psfis_indicator</a> : thm
<a name="line89"></a>    val <a href="#psfis_intro-val">psfis_intro</a> : thm
<a name="line90"></a>    val <a href="#psfis_mono-val">psfis_mono</a> : thm
<a name="line91"></a>    val <a href="#psfis_mono_conv_mono-val">psfis_mono_conv_mono</a> : thm
<a name="line92"></a>    val <a href="#psfis_mult-val">psfis_mult</a> : thm
<a name="line93"></a>    val <a href="#psfis_nnfis-val">psfis_nnfis</a> : thm
<a name="line94"></a>    val <a href="#psfis_nonneg-val">psfis_nonneg</a> : thm
<a name="line95"></a>    val <a href="#psfis_present-val">psfis_present</a> : thm
<a name="line96"></a>    val <a href="#psfis_unique-val">psfis_unique</a> : thm
<a name="line97"></a>    val <a href="#seq_sup_compute-val">seq_sup_compute</a> : thm
<a name="line98"></a>    val <a href="#upclose_psfis-val">upclose_psfis</a> : thm
<a name="line99"></a>  
<a name="line100"></a>  val real_lebesgue_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line101"></a>(*
   [real_measure] Parent theory of "real_lebesgue"
   
   [<a name="RN_deriv_def-val"><b>RN_deriv_def</b></a>]  Definition
      
      ⊢ ∀m v.
          RN_deriv m v =
          @f. measure_space m ∧
              measure_space (m_space m,measurable_sets m,v) ∧
              f ∈ borel_measurable (m_space m,measurable_sets m) ∧
              ∀a. a ∈ measurable_sets m ⇒
                  integral m (λx. f x * indicator_fn a x) = v a
   
   [<a name="countable_space_integral_def-val"><b>countable_space_integral_def</b></a>]  Definition
      
      ⊢ ∀m f.
          countable_space_integral m f =
          (let
             e = enumerate (IMAGE f (m_space m))
           in
             suminf ((λr. r * measure m (PREIMAGE f {r} ∩ m_space m)) ∘ e))
   
   [<a name="finite_space_integral_def-val"><b>finite_space_integral_def</b></a>]  Definition
      
      ⊢ ∀m f.
          finite_space_integral m f =
          SIGMA (λr. r * measure m (PREIMAGE f {r} ∩ m_space m))
            (IMAGE f (m_space m))
   
   [<a name="fn_minus_def-val"><b>fn_minus_def</b></a>]  Definition
      
      ⊢ ∀f. fn_minus f = (λx. if 0 ≤ f x then 0 else -f x)
   
   [<a name="fn_plus_def-val"><b>fn_plus_def</b></a>]  Definition
      
      ⊢ ∀f. fn_plus f = (λx. if 0 ≤ f x then f x else 0)
   
   [<a name="integrable_def-val"><b>integrable_def</b></a>]  Definition
      
      ⊢ ∀m f.
          integrable m f ⇔
          measure_space m ∧ (∃x. x ∈ nnfis m (fn_plus f)) ∧
          ∃y. y ∈ nnfis m (fn_minus f)
   
   [<a name="integral_def-val"><b>integral_def</b></a>]  Definition
      
      ⊢ ∀m f.
          integral m f =
          (@i. i ∈ nnfis m (fn_plus f)) − @j. j ∈ nnfis m (fn_minus f)
   
   [<a name="max_fn_seq_def-val"><b>max_fn_seq_def</b></a>]  Definition
      
      ⊢ (∀g x. max_fn_seq g 0 x = g 0 x) ∧
        ∀g n x.
          max_fn_seq g (SUC n) x = max (max_fn_seq g n x) (g (SUC n) x)
   
   [<a name="mon_upclose_def-val"><b>mon_upclose_def</b></a>]  Definition
      
      ⊢ ∀u m. mon_upclose u m = mon_upclose_help m u m
   
   [<a name="mon_upclose_help_def-val"><b>mon_upclose_help_def</b></a>]  Definition
      
      ⊢ (∀u m. mon_upclose_help 0 u m = u m 0) ∧
        ∀n u m.
          mon_upclose_help (SUC n) u m =
          upclose (u m (SUC n)) (mon_upclose_help n u m)
   
   [<a name="nnfis_def-val"><b>nnfis_def</b></a>]  Definition
      
      ⊢ ∀m f.
          nnfis m f =
          {y |
           ∃u x.
             mono_convergent u f (m_space m) ∧ (∀n. x n ∈ psfis m (u n)) ∧
             x --&gt; y}
   
   [<a name="nonneg_def-val"><b>nonneg_def</b></a>]  Definition
      
      ⊢ ∀f. nonneg f ⇔ ∀x. 0 ≤ f x
   
   [<a name="pos_fn_integral_def-val"><b>pos_fn_integral_def</b></a>]  Definition
      
      ⊢ ∀m f.
          pos_fn_integral m f =
          sup {r | (∃g. r ∈ psfis m g ∧ ∀x. g x ≤ f x)}
   
   [<a name="pos_simple_fn_def-val"><b>pos_simple_fn_def</b></a>]  Definition
      
      ⊢ ∀m f s a x.
          pos_simple_fn m f s a x ⇔
          (∀t. 0 ≤ f t) ∧
          (∀t. t ∈ m_space m ⇒
               f t = SIGMA (λi. x i * indicator_fn (a i) t) s) ∧
          (∀i. i ∈ s ⇒ a i ∈ measurable_sets m) ∧ (∀i. 0 ≤ x i) ∧
          FINITE s ∧ (∀i j. i ∈ s ∧ j ∈ s ∧ i ≠ j ⇒ DISJOINT (a i) (a j)) ∧
          BIGUNION (IMAGE a s) = m_space m
   
   [<a name="pos_simple_fn_integral_def-val"><b>pos_simple_fn_integral_def</b></a>]  Definition
      
      ⊢ ∀m s a x.
          pos_simple_fn_integral m s a x =
          SIGMA (λi. x i * measure m (a i)) s
   
   [<a name="prod_measure3_def-val"><b>prod_measure3_def</b></a>]  Definition
      
      ⊢ ∀m0 m1 m2.
          prod_measure3 m0 m1 m2 =
          prod_measure m0 (prod_measure_space m1 m2)
   
   [<a name="prod_measure_def-val"><b>prod_measure_def</b></a>]  Definition
      
      ⊢ ∀m0 m1.
          prod_measure m0 m1 =
          (λa. integral m0 (λs0. measure m1 (PREIMAGE (λs1. (s0,s1)) a)))
   
   [<a name="prod_measure_space3_def-val"><b>prod_measure_space3_def</b></a>]  Definition
      
      ⊢ ∀m0 m1 m2.
          prod_measure_space3 m0 m1 m2 =
          (m_space m0 × m_space m1 × m_space m2,
           subsets
             (sigma (m_space m0 × m_space m1 × m_space m2)
                (prod_sets3 (measurable_sets m0) (measurable_sets m1)
                   (measurable_sets m2))),prod_measure3 m0 m1 m2)
   
   [<a name="prod_measure_space_def-val"><b>prod_measure_space_def</b></a>]  Definition
      
      ⊢ ∀m0 m1.
          prod_measure_space m0 m1 =
          (m_space m0 × m_space m1,
           subsets
             (sigma (m_space m0 × m_space m1)
                (prod_sets (measurable_sets m0) (measurable_sets m1))),
           prod_measure m0 m1)
   
   [<a name="prod_sets3_def-val"><b>prod_sets3_def</b></a>]  Definition
      
      ⊢ ∀a b c. prod_sets3 a b c = {s × t × u | s ∈ a ∧ t ∈ b ∧ u ∈ c}
   
   [<a name="psfis_def-val"><b>psfis_def</b></a>]  Definition
      
      ⊢ ∀m f.
          psfis m f =
          IMAGE (λ(s,a,x). pos_simple_fn_integral m s a x) (psfs m f)
   
   [<a name="psfs_def-val"><b>psfs_def</b></a>]  Definition
      
      ⊢ ∀m f. psfs m f = {(s,a,x) | pos_simple_fn m f s a x}
   
   [<a name="seq_sup_def-val"><b>seq_sup_def</b></a>]  Definition
      
      ⊢ (∀P. seq_sup P 0 = @r. r ∈ P ∧ sup P &lt; r + 1) ∧
        ∀P n.
          seq_sup P (SUC n) =
          @r. r ∈ P ∧ sup P &lt; r + (1 / 2) pow SUC n ∧ seq_sup P n &lt; r ∧
              r &lt; sup P
   
   [<a name="upclose_def-val"><b>upclose_def</b></a>]  Definition
      
      ⊢ ∀f g. upclose f g = (λt. max (f t) (g t))
   
   [<a name="IN_psfis-val"><b>IN_psfis</b></a>]  Theorem
      
      ⊢ ∀m r f.
          r ∈ psfis m f ⇒
          ∃s a x.
            pos_simple_fn m f s a x ∧ r = pos_simple_fn_integral m s a x
   
   [<a name="REAL_SUP_FUN_SEQ_IMAGE-val"><b>REAL_SUP_FUN_SEQ_IMAGE</b></a>]  Theorem
      
      ⊢ ∀P P' f.
          (∃x. P x) ∧ (∃z. ∀x. P x ⇒ x ≤ z) ∧ P = IMAGE f P' ⇒
          ∃g. (∀n. g n ∈ P') ∧ sup (IMAGE (λn. f (g n)) 𝕌(:num)) = sup P
   
   [<a name="REAL_SUP_FUN_SEQ_MONO_IMAGE-val"><b>REAL_SUP_FUN_SEQ_MONO_IMAGE</b></a>]  Theorem
      
      ⊢ ∀P P' f.
          (∃x. P x) ∧ (∃z. ∀x. P x ⇒ x ≤ z) ∧ P = IMAGE f P' ∧
          (∀g1 g2. g1 ∈ P' ∧ g2 ∈ P' ∧ (∀x. g1 x ≤ g2 x) ⇒ f g1 ≤ f g2) ∧
          (∀g1 g2. g1 ∈ P' ∧ g2 ∈ P' ⇒ (λx. max (g1 x) (g2 x)) ∈ P') ⇒
          ∃g. (∀n. g n ∈ P') ∧ (∀x n. g n x ≤ g (SUC n) x) ∧
              sup (IMAGE (λn. f (g n)) 𝕌(:num)) = sup P
   
   [<a name="REAL_SUP_SEQ-val"><b>REAL_SUP_SEQ</b></a>]  Theorem
      
      ⊢ ∀P. (∃x. P x) ∧ (∃z. ∀x. P x ⇒ x ≤ z) ⇒
            ∃x. (∀n. x n ∈ P) ∧ (∀n. x n ≤ x (SUC n)) ∧
                sup (IMAGE x 𝕌(:num)) = sup P
   
   [<a name="borel_measurable_mon_conv_psfis-val"><b>borel_measurable_mon_conv_psfis</b></a>]  Theorem
      
      ⊢ ∀m f.
          measure_space m ∧
          f ∈ borel_measurable (m_space m,measurable_sets m) ∧
          (∀t. t ∈ m_space m ⇒ 0 ≤ f t) ⇒
          ∃u x. mono_convergent u f (m_space m) ∧ ∀n. x n ∈ psfis m (u n)
   
   [<a name="countable_space_integral_reduce-val"><b>countable_space_integral_reduce</b></a>]  Theorem
      
      ⊢ ∀m f p n.
          measure_space m ∧ positive m ∧
          f ∈ borel_measurable (m_space m,measurable_sets m) ∧
          countable (IMAGE f (m_space m)) ∧
          INFINITE (IMAGE (fn_plus f) (m_space m)) ∧
          INFINITE (IMAGE (fn_minus f) (m_space m)) ∧
          (λr. r * measure m (PREIMAGE (fn_minus f) {r} ∩ m_space m)) ∘
          enumerate (IMAGE (fn_minus f) (m_space m)) sums n ∧
          (λr. r * measure m (PREIMAGE (fn_plus f) {r} ∩ m_space m)) ∘
          enumerate (IMAGE (fn_plus f) (m_space m)) sums p ⇒
          integral m f = p − n
   
   [<a name="finite_POW_RN_deriv_reduce-val"><b>finite_POW_RN_deriv_reduce</b></a>]  Theorem
      
      ⊢ ∀m v.
          measure_space m ∧ FINITE (m_space m) ∧
          measure_space (m_space m,measurable_sets m,v) ∧
          POW (m_space m) = measurable_sets m ∧
          (∀x. measure m {x} = 0 ⇒ v {x} = 0) ⇒
          ∀x. x ∈ m_space m ∧ measure m {x} ≠ 0 ⇒
              RN_deriv m v x = v {x} / measure m {x}
   
   [<a name="finite_POW_prod_measure_reduce-val"><b>finite_POW_prod_measure_reduce</b></a>]  Theorem
      
      ⊢ ∀m0 m1.
          measure_space m0 ∧ measure_space m1 ∧ FINITE (m_space m0) ∧
          FINITE (m_space m1) ∧ POW (m_space m0) = measurable_sets m0 ∧
          POW (m_space m1) = measurable_sets m1 ⇒
          ∀a0 a1.
            a0 ∈ measurable_sets m0 ∧ a1 ∈ measurable_sets m1 ⇒
            prod_measure m0 m1 (a0 × a1) = measure m0 a0 * measure m1 a1
   
   [<a name="finite_POW_prod_measure_reduce3-val"><b>finite_POW_prod_measure_reduce3</b></a>]  Theorem
      
      ⊢ ∀m0 m1 m2.
          measure_space m0 ∧ measure_space m1 ∧ measure_space m2 ∧
          FINITE (m_space m0) ∧ FINITE (m_space m1) ∧ FINITE (m_space m2) ∧
          POW (m_space m0) = measurable_sets m0 ∧
          POW (m_space m1) = measurable_sets m1 ∧
          POW (m_space m2) = measurable_sets m2 ⇒
          ∀a0 a1 a2.
            a0 ∈ measurable_sets m0 ∧ a1 ∈ measurable_sets m1 ∧
            a2 ∈ measurable_sets m2 ⇒
            prod_measure3 m0 m1 m2 (a0 × a1 × a2) =
            measure m0 a0 * measure m1 a1 * measure m2 a2
   
   [<a name="finite_integral_on_set-val"><b>finite_integral_on_set</b></a>]  Theorem
      
      ⊢ ∀m f a.
          measure_space m ∧ FINITE (m_space m) ∧
          f ∈ borel_measurable (m_space m,measurable_sets m) ∧
          a ∈ measurable_sets m ⇒
          integral m (λx. f x * indicator_fn a x) =
          SIGMA (λr. r * measure m (PREIMAGE f {r} ∩ a)) (IMAGE f a)
   
   [<a name="finite_prod_measure_space_POW-val"><b>finite_prod_measure_space_POW</b></a>]  Theorem
      
      ⊢ ∀s1 s2 u v.
          FINITE s1 ∧ FINITE s2 ⇒
          prod_measure_space (s1,POW s1,u) (s2,POW s2,v) =
          (s1 × s2,POW (s1 × s2),prod_measure (s1,POW s1,u) (s2,POW s2,v))
   
   [<a name="finite_prod_measure_space_POW3-val"><b>finite_prod_measure_space_POW3</b></a>]  Theorem
      
      ⊢ ∀s1 s2 s3 u v w.
          FINITE s1 ∧ FINITE s2 ∧ FINITE s3 ⇒
          prod_measure_space3 (s1,POW s1,u) (s2,POW s2,v) (s3,POW s3,w) =
          (s1 × s2 × s3,POW (s1 × s2 × s3),
           prod_measure3 (s1,POW s1,u) (s2,POW s2,v) (s3,POW s3,w))
   
   [<a name="finite_space_POW_integral_reduce-val"><b>finite_space_POW_integral_reduce</b></a>]  Theorem
      
      ⊢ ∀m f.
          measure_space m ∧ POW (m_space m) = measurable_sets m ∧
          FINITE (m_space m) ⇒
          integral m f = SIGMA (λx. f x * measure m {x}) (m_space m)
   
   [<a name="finite_space_integral_reduce-val"><b>finite_space_integral_reduce</b></a>]  Theorem
      
      ⊢ ∀m f.
          measure_space m ∧
          f ∈ borel_measurable (m_space m,measurable_sets m) ∧
          FINITE (m_space m) ⇒
          integral m f = finite_space_integral m f
   
   [<a name="fn_plus_fn_minus_borel_measurable-val"><b>fn_plus_fn_minus_borel_measurable</b></a>]  Theorem
      
      ⊢ ∀f m.
          measure_space m ∧
          f ∈ borel_measurable (m_space m,measurable_sets m) ⇒
          fn_plus f ∈ borel_measurable (m_space m,measurable_sets m) ∧
          fn_minus f ∈ borel_measurable (m_space m,measurable_sets m)
   
   [<a name="fn_plus_fn_minus_borel_measurable_iff-val"><b>fn_plus_fn_minus_borel_measurable_iff</b></a>]  Theorem
      
      ⊢ ∀f m.
          measure_space m ⇒
          (f ∈ borel_measurable (m_space m,measurable_sets m) ⇔
           fn_plus f ∈ borel_measurable (m_space m,measurable_sets m) ∧
           fn_minus f ∈ borel_measurable (m_space m,measurable_sets m))
   
   [<a name="indicator_fn_split-val"><b>indicator_fn_split</b></a>]  Theorem
      
      ⊢ ∀r s b.
          FINITE r ∧ BIGUNION (IMAGE b r) = s ∧
          (∀i j. i ∈ r ∧ j ∈ r ∧ i ≠ j ⇒ DISJOINT (b i) (b j)) ⇒
          ∀a. a ⊆ s ⇒
              indicator_fn a = (λx. SIGMA (λi. indicator_fn (a ∩ b i) x) r)
   
   [<a name="integral_add-val"><b>integral_add</b></a>]  Theorem
      
      ⊢ ∀m f g.
          integrable m f ∧ integrable m g ⇒
          integrable m (λt. f t + g t) ∧
          integral m (λt. f t + g t) = integral m f + integral m g
   
   [<a name="integral_borel_measurable-val"><b>integral_borel_measurable</b></a>]  Theorem
      
      ⊢ ∀m f.
          integrable m f ⇒
          f ∈ borel_measurable (m_space m,measurable_sets m)
   
   [<a name="integral_cmul_indicator-val"><b>integral_cmul_indicator</b></a>]  Theorem
      
      ⊢ ∀m s c.
          measure_space m ∧ s ∈ measurable_sets m ⇒
          integral m (λx. c * indicator_fn s x) = c * measure m s
   
   [<a name="integral_indicator_fn-val"><b>integral_indicator_fn</b></a>]  Theorem
      
      ⊢ ∀m a.
          measure_space m ∧ a ∈ measurable_sets m ⇒
          integral m (indicator_fn a) = measure m a ∧
          integrable m (indicator_fn a)
   
   [<a name="integral_mono-val"><b>integral_mono</b></a>]  Theorem
      
      ⊢ ∀m f g.
          integrable m f ∧ integrable m g ∧ (∀t. t ∈ m_space m ⇒ f t ≤ g t) ⇒
          integral m f ≤ integral m g
   
   [<a name="integral_times-val"><b>integral_times</b></a>]  Theorem
      
      ⊢ ∀m f a.
          integrable m f ⇒
          integrable m (λt. a * f t) ∧
          integral m (λt. a * f t) = a * integral m f
   
   [<a name="integral_zero-val"><b>integral_zero</b></a>]  Theorem
      
      ⊢ ∀m. measure_space m ⇒ integral m (λx. 0) = 0
   
   [<a name="markov_ineq-val"><b>markov_ineq</b></a>]  Theorem
      
      ⊢ ∀m f a n.
          integrable m f ∧ 0 &lt; a ∧ integrable m (λx. abs (f x) pow n) ⇒
          measure m (PREIMAGE f {y | a ≤ y} ∩ m_space m) ≤
          integral m (λx. abs (f x) pow n) / a pow n
   
   [<a name="max_fn_seq_compute-val"><b>max_fn_seq_compute</b></a>]  Theorem
      
      ⊢ (∀g x. max_fn_seq g 0 x = g 0 x) ∧
        (∀g n x.
           max_fn_seq g (NUMERAL (BIT1 n)) x =
           max (max_fn_seq g (NUMERAL (BIT1 n) − 1) x)
             (g (NUMERAL (BIT1 n)) x)) ∧
        ∀g n x.
          max_fn_seq g (NUMERAL (BIT2 n)) x =
          max (max_fn_seq g (NUMERAL (BIT1 n)) x) (g (NUMERAL (BIT2 n)) x)
   
   [<a name="max_fn_seq_mono-val"><b>max_fn_seq_mono</b></a>]  Theorem
      
      ⊢ ∀g n x. max_fn_seq g n x ≤ max_fn_seq g (SUC n) x
   
   [<a name="measure_space_finite_prod_measure_POW1-val"><b>measure_space_finite_prod_measure_POW1</b></a>]  Theorem
      
      ⊢ ∀m0 m1.
          measure_space m0 ∧ measure_space m1 ∧ FINITE (m_space m0) ∧
          FINITE (m_space m1) ∧ POW (m_space m0) = measurable_sets m0 ∧
          POW (m_space m1) = measurable_sets m1 ⇒
          measure_space (prod_measure_space m0 m1)
   
   [<a name="measure_space_finite_prod_measure_POW2-val"><b>measure_space_finite_prod_measure_POW2</b></a>]  Theorem
      
      ⊢ ∀m0 m1.
          measure_space m0 ∧ measure_space m1 ∧ FINITE (m_space m0) ∧
          FINITE (m_space m1) ∧ POW (m_space m0) = measurable_sets m0 ∧
          POW (m_space m1) = measurable_sets m1 ⇒
          measure_space
            (m_space m0 × m_space m1,POW (m_space m0 × m_space m1),
             prod_measure m0 m1)
   
   [<a name="measure_space_finite_prod_measure_POW3-val"><b>measure_space_finite_prod_measure_POW3</b></a>]  Theorem
      
      ⊢ ∀m0 m1 m2.
          measure_space m0 ∧ measure_space m1 ∧ measure_space m2 ∧
          FINITE (m_space m0) ∧ FINITE (m_space m1) ∧ FINITE (m_space m2) ∧
          POW (m_space m0) = measurable_sets m0 ∧
          POW (m_space m1) = measurable_sets m1 ∧
          POW (m_space m2) = measurable_sets m2 ⇒
          measure_space
            (m_space m0 × m_space m1 × m_space m2,
             POW (m_space m0 × m_space m1 × m_space m2),
             prod_measure3 m0 m1 m2)
   
   [<a name="measure_split-val"><b>measure_split</b></a>]  Theorem
      
      ⊢ ∀r b m.
          measure_space m ∧ FINITE r ∧ BIGUNION (IMAGE b r) = m_space m ∧
          (∀i j. i ∈ r ∧ j ∈ r ∧ i ≠ j ⇒ DISJOINT (b i) (b j)) ∧
          (∀i. i ∈ r ⇒ b i ∈ measurable_sets m) ⇒
          ∀a. a ∈ measurable_sets m ⇒
              measure m a = SIGMA (λi. measure m (a ∩ b i)) r
   
   [<a name="mon_upclose_help_compute-val"><b>mon_upclose_help_compute</b></a>]  Theorem
      
      ⊢ (∀u m. mon_upclose_help 0 u m = u m 0) ∧
        (∀n u m.
           mon_upclose_help (NUMERAL (BIT1 n)) u m =
           upclose (u m (NUMERAL (BIT1 n)))
             (mon_upclose_help (NUMERAL (BIT1 n) − 1) u m)) ∧
        ∀n u m.
          mon_upclose_help (NUMERAL (BIT2 n)) u m =
          upclose (u m (NUMERAL (BIT2 n)))
            (mon_upclose_help (NUMERAL (BIT1 n)) u m)
   
   [<a name="mon_upclose_psfis-val"><b>mon_upclose_psfis</b></a>]  Theorem
      
      ⊢ ∀m u.
          measure_space m ∧ (∀n n'. ∃a. a ∈ psfis m (u n n')) ⇒
          ∃c. ∀n. c n ∈ psfis m (mon_upclose u n)
   
   [<a name="nnfis_add-val"><b>nnfis_add</b></a>]  Theorem
      
      ⊢ ∀f g m a b.
          measure_space m ∧ a ∈ nnfis m f ∧ b ∈ nnfis m g ⇒
          a + b ∈ nnfis m (λw. f w + g w)
   
   [<a name="nnfis_borel_measurable-val"><b>nnfis_borel_measurable</b></a>]  Theorem
      
      ⊢ ∀m f a.
          measure_space m ∧ a ∈ nnfis m f ⇒
          f ∈ borel_measurable (m_space m,measurable_sets m)
   
   [<a name="nnfis_dom_conv-val"><b>nnfis_dom_conv</b></a>]  Theorem
      
      ⊢ ∀m f g b.
          measure_space m ∧
          f ∈ borel_measurable (m_space m,measurable_sets m) ∧
          b ∈ nnfis m g ∧ (∀t. t ∈ m_space m ⇒ f t ≤ g t) ∧
          (∀t. t ∈ m_space m ⇒ 0 ≤ f t) ⇒
          ∃a. a ∈ nnfis m f ∧ a ≤ b
   
   [<a name="nnfis_integral-val"><b>nnfis_integral</b></a>]  Theorem
      
      ⊢ ∀m f a.
          measure_space m ∧ a ∈ nnfis m f ⇒
          integrable m f ∧ integral m f = a
   
   [<a name="nnfis_minus_nnfis_integral-val"><b>nnfis_minus_nnfis_integral</b></a>]  Theorem
      
      ⊢ ∀m f g a b.
          measure_space m ∧ a ∈ nnfis m f ∧ b ∈ nnfis m g ⇒
          integrable m (λt. f t − g t) ∧ integral m (λt. f t − g t) = a − b
   
   [<a name="nnfis_mon_conv-val"><b>nnfis_mon_conv</b></a>]  Theorem
      
      ⊢ ∀f m h x y.
          measure_space m ∧ mono_convergent f h (m_space m) ∧
          (∀n. x n ∈ nnfis m (f n)) ∧ x --&gt; y ⇒
          y ∈ nnfis m h
   
   [<a name="nnfis_mono-val"><b>nnfis_mono</b></a>]  Theorem
      
      ⊢ ∀f g m a b.
          measure_space m ∧ a ∈ nnfis m f ∧ b ∈ nnfis m g ∧
          (∀w. w ∈ m_space m ⇒ f w ≤ g w) ⇒
          a ≤ b
   
   [<a name="nnfis_pos_on_mspace-val"><b>nnfis_pos_on_mspace</b></a>]  Theorem
      
      ⊢ ∀f m a.
          measure_space m ∧ a ∈ nnfis m f ⇒ ∀x. x ∈ m_space m ⇒ 0 ≤ f x
   
   [<a name="nnfis_times-val"><b>nnfis_times</b></a>]  Theorem
      
      ⊢ ∀f m a z.
          measure_space m ∧ a ∈ nnfis m f ∧ 0 ≤ z ⇒
          z * a ∈ nnfis m (λw. z * f w)
   
   [<a name="nnfis_unique-val"><b>nnfis_unique</b></a>]  Theorem
      
      ⊢ ∀f m a b. measure_space m ∧ a ∈ nnfis m f ∧ b ∈ nnfis m f ⇒ a = b
   
   [<a name="pos_psfis-val"><b>pos_psfis</b></a>]  Theorem
      
      ⊢ ∀r m f. measure_space m ∧ r ∈ psfis m f ⇒ 0 ≤ r
   
   [<a name="pos_simple_fn_integral_REAL_SUM_IMAGE-val"><b>pos_simple_fn_integral_REAL_SUM_IMAGE</b></a>]  Theorem
      
      ⊢ ∀m f s a x P.
          measure_space m ∧
          (∀i. i ∈ P ⇒ pos_simple_fn m (f i) (s i) (a i) (x i)) ∧ FINITE P ⇒
          ∃s' a' x'.
            pos_simple_fn m (λt. SIGMA (λi. f i t) P) s' a' x' ∧
            pos_simple_fn_integral m s' a' x' =
            SIGMA (λi. pos_simple_fn_integral m (s i) (a i) (x i)) P
   
   [<a name="pos_simple_fn_integral_add-val"><b>pos_simple_fn_integral_add</b></a>]  Theorem
      
      ⊢ ∀m f s a x g s' b y.
          measure_space m ∧ pos_simple_fn m f s a x ∧
          pos_simple_fn m g s' b y ⇒
          ∃s'' c z.
            pos_simple_fn m (λx. f x + g x) s'' c z ∧
            pos_simple_fn_integral m s a x +
            pos_simple_fn_integral m s' b y =
            pos_simple_fn_integral m s'' c z
   
   [<a name="pos_simple_fn_integral_indicator-val"><b>pos_simple_fn_integral_indicator</b></a>]  Theorem
      
      ⊢ ∀m A.
          measure_space m ∧ A ∈ measurable_sets m ⇒
          ∃s a x.
            pos_simple_fn m (indicator_fn A) s a x ∧
            pos_simple_fn_integral m s a x = measure m A
   
   [<a name="pos_simple_fn_integral_mono-val"><b>pos_simple_fn_integral_mono</b></a>]  Theorem
      
      ⊢ ∀m f s a x g s' b y.
          measure_space m ∧ pos_simple_fn m f s a x ∧
          pos_simple_fn m g s' b y ∧ (∀x. f x ≤ g x) ⇒
          pos_simple_fn_integral m s a x ≤ pos_simple_fn_integral m s' b y
   
   [<a name="pos_simple_fn_integral_mono_on_mspace-val"><b>pos_simple_fn_integral_mono_on_mspace</b></a>]  Theorem
      
      ⊢ ∀m f s a x g s' b y.
          measure_space m ∧ pos_simple_fn m f s a x ∧
          pos_simple_fn m g s' b y ∧ (∀x. x ∈ m_space m ⇒ f x ≤ g x) ⇒
          pos_simple_fn_integral m s a x ≤ pos_simple_fn_integral m s' b y
   
   [<a name="pos_simple_fn_integral_mult-val"><b>pos_simple_fn_integral_mult</b></a>]  Theorem
      
      ⊢ ∀m f s a x.
          measure_space m ∧ pos_simple_fn m f s a x ⇒
          ∀z. 0 ≤ z ⇒
              ∃s' b y.
                pos_simple_fn m (λx. z * f x) s' b y ∧
                pos_simple_fn_integral m s' b y =
                z * pos_simple_fn_integral m s a x
   
   [<a name="pos_simple_fn_integral_present-val"><b>pos_simple_fn_integral_present</b></a>]  Theorem
      
      ⊢ ∀m f s a x g s' b y.
          measure_space m ∧ pos_simple_fn m f s a x ∧
          pos_simple_fn m g s' b y ⇒
          ∃z z' c k.
            (∀t. t ∈ m_space m ⇒
                 f t = SIGMA (λi. z i * indicator_fn (c i) t) k) ∧
            (∀t. t ∈ m_space m ⇒
                 g t = SIGMA (λi. z' i * indicator_fn (c i) t) k) ∧
            pos_simple_fn_integral m s a x = pos_simple_fn_integral m k c z ∧
            pos_simple_fn_integral m s' b y =
            pos_simple_fn_integral m k c z' ∧ FINITE k ∧
            (∀i j. i ∈ k ∧ j ∈ k ∧ i ≠ j ⇒ DISJOINT (c i) (c j)) ∧
            (∀i. i ∈ k ⇒ c i ∈ measurable_sets m) ∧
            BIGUNION (IMAGE c k) = m_space m ∧ (∀i. 0 ≤ z i) ∧ ∀i. 0 ≤ z' i
   
   [<a name="pos_simple_fn_integral_unique-val"><b>pos_simple_fn_integral_unique</b></a>]  Theorem
      
      ⊢ ∀m f s a x s' b y.
          measure_space m ∧ pos_simple_fn m f s a x ∧
          pos_simple_fn m f s' b y ⇒
          pos_simple_fn_integral m s a x = pos_simple_fn_integral m s' b y
   
   [<a name="psfis_REAL_SUM_IMAGE-val"><b>psfis_REAL_SUM_IMAGE</b></a>]  Theorem
      
      ⊢ ∀m f a P.
          measure_space m ∧ (∀i. i ∈ P ⇒ a i ∈ psfis m (f i)) ∧ FINITE P ⇒
          SIGMA a P ∈ psfis m (λt. SIGMA (λi. f i t) P)
   
   [<a name="psfis_add-val"><b>psfis_add</b></a>]  Theorem
      
      ⊢ ∀m f g a b.
          measure_space m ∧ a ∈ psfis m f ∧ b ∈ psfis m g ⇒
          a + b ∈ psfis m (λx. f x + g x)
   
   [<a name="psfis_borel_measurable-val"><b>psfis_borel_measurable</b></a>]  Theorem
      
      ⊢ ∀m f a.
          measure_space m ∧ a ∈ psfis m f ⇒
          f ∈ borel_measurable (m_space m,measurable_sets m)
   
   [<a name="psfis_equiv-val"><b>psfis_equiv</b></a>]  Theorem
      
      ⊢ ∀f g a m.
          measure_space m ∧ a ∈ psfis m f ∧ (∀t. 0 ≤ g t) ∧
          (∀t. t ∈ m_space m ⇒ f t = g t) ⇒
          a ∈ psfis m g
   
   [<a name="psfis_indicator-val"><b>psfis_indicator</b></a>]  Theorem
      
      ⊢ ∀m A.
          measure_space m ∧ A ∈ measurable_sets m ⇒
          measure m A ∈ psfis m (indicator_fn A)
   
   [<a name="psfis_intro-val"><b>psfis_intro</b></a>]  Theorem
      
      ⊢ ∀m a x P.
          measure_space m ∧ (∀i. i ∈ P ⇒ a i ∈ measurable_sets m) ∧
          (∀i. 0 ≤ x i) ∧ FINITE P ⇒
          SIGMA (λi. x i * measure m (a i)) P ∈
          psfis m (λt. SIGMA (λi. x i * indicator_fn (a i) t) P)
   
   [<a name="psfis_mono-val"><b>psfis_mono</b></a>]  Theorem
      
      ⊢ ∀m f g a b.
          measure_space m ∧ a ∈ psfis m f ∧ b ∈ psfis m g ∧
          (∀x. x ∈ m_space m ⇒ f x ≤ g x) ⇒
          a ≤ b
   
   [<a name="psfis_mono_conv_mono-val"><b>psfis_mono_conv_mono</b></a>]  Theorem
      
      ⊢ ∀m f u x y r s.
          measure_space m ∧ mono_convergent u f (m_space m) ∧
          (∀n. x n ∈ psfis m (u n)) ∧ (∀m n. m ≤ n ⇒ x m ≤ x n) ∧ x --&gt; y ∧
          r ∈ psfis m s ∧ (∀a. a ∈ m_space m ⇒ s a ≤ f a) ⇒
          r ≤ y
   
   [<a name="psfis_mult-val"><b>psfis_mult</b></a>]  Theorem
      
      ⊢ ∀m f a.
          measure_space m ∧ a ∈ psfis m f ⇒
          ∀z. 0 ≤ z ⇒ z * a ∈ psfis m (λx. z * f x)
   
   [<a name="psfis_nnfis-val"><b>psfis_nnfis</b></a>]  Theorem
      
      ⊢ ∀m f a. measure_space m ∧ a ∈ psfis m f ⇒ a ∈ nnfis m f
   
   [<a name="psfis_nonneg-val"><b>psfis_nonneg</b></a>]  Theorem
      
      ⊢ ∀m f a. a ∈ psfis m f ⇒ nonneg f
   
   [<a name="psfis_present-val"><b>psfis_present</b></a>]  Theorem
      
      ⊢ ∀m f g a b.
          measure_space m ∧ a ∈ psfis m f ∧ b ∈ psfis m g ⇒
          ∃z z' c k.
            (∀t. t ∈ m_space m ⇒
                 f t = SIGMA (λi. z i * indicator_fn (c i) t) k) ∧
            (∀t. t ∈ m_space m ⇒
                 g t = SIGMA (λi. z' i * indicator_fn (c i) t) k) ∧
            a = pos_simple_fn_integral m k c z ∧
            b = pos_simple_fn_integral m k c z' ∧ FINITE k ∧
            (∀i j. i ∈ k ∧ j ∈ k ∧ i ≠ j ⇒ DISJOINT (c i) (c j)) ∧
            (∀i. i ∈ k ⇒ c i ∈ measurable_sets m) ∧
            BIGUNION (IMAGE c k) = m_space m ∧ (∀i. 0 ≤ z i) ∧ ∀i. 0 ≤ z' i
   
   [<a name="psfis_unique-val"><b>psfis_unique</b></a>]  Theorem
      
      ⊢ ∀m f a b. measure_space m ∧ a ∈ psfis m f ∧ b ∈ psfis m f ⇒ a = b
   
   [<a name="seq_sup_compute-val"><b>seq_sup_compute</b></a>]  Theorem
      
      ⊢ (∀P. seq_sup P 0 = @r. r ∈ P ∧ sup P &lt; r + 1) ∧
        (∀P n.
           seq_sup P (NUMERAL (BIT1 n)) =
           @r. r ∈ P ∧ sup P &lt; r + (1 / 2) pow NUMERAL (BIT1 n) ∧
               seq_sup P (NUMERAL (BIT1 n) − 1) &lt; r ∧ r &lt; sup P) ∧
        ∀P n.
          seq_sup P (NUMERAL (BIT2 n)) =
          @r. r ∈ P ∧ sup P &lt; r + (1 / 2) pow NUMERAL (BIT2 n) ∧
              seq_sup P (NUMERAL (BIT1 n)) &lt; r ∧ r &lt; sup P
   
   [<a name="upclose_psfis-val"><b>upclose_psfis</b></a>]  Theorem
      
      ⊢ ∀f g a b m.
          measure_space m ∧ a ∈ psfis m f ∧ b ∈ psfis m g ⇒
          ∃c. c ∈ psfis m (upclose f g)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/probability/real_lebesgueScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-1</a></em></p></body></html>
