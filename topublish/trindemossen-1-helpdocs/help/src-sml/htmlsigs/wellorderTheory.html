<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure wellorderTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure wellorderTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/pred_set/src/more_theories/wellorderScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature wellorderTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#ADD1_def-val">ADD1_def</a> : thm
<a name="line7"></a>    val <a href="#elsOf_def-val">elsOf_def</a> : thm
<a name="line8"></a>    val <a href="#finite_def-val">finite_def</a> : thm
<a name="line9"></a>    val <a href="#fromNatWO_def-val">fromNatWO_def</a> : thm
<a name="line10"></a>    val <a href="#iseg_def-val">iseg_def</a> : thm
<a name="line11"></a>    val <a href="#orderiso_def-val">orderiso_def</a> : thm
<a name="line12"></a>    val <a href="#orderlt_def-val">orderlt_def</a> : thm
<a name="line13"></a>    val <a href="#remove_def-val">remove_def</a> : thm
<a name="line14"></a>    val <a href="#wZERO_def-val">wZERO_def</a> : thm
<a name="line15"></a>    val <a href="#wellfounded_def-val">wellfounded_def</a> : thm
<a name="line16"></a>    val <a href="#wellorder_ABSREP-val">wellorder_ABSREP</a> : thm
<a name="line17"></a>    val <a href="#wellorder_TY_DEF-val">wellorder_TY_DEF</a> : thm
<a name="line18"></a>    val <a href="#wellorder_def-val">wellorder_def</a> : thm
<a name="line19"></a>    val <a href="#wleast_def-val">wleast_def</a> : thm
<a name="line20"></a>    val <a href="#wo2wo_def-val">wo2wo_def</a> : thm
<a name="line21"></a>    val <a href="#wobound_def-val">wobound_def</a> : thm
<a name="line22"></a>  
<a name="line23"></a>  (*  Theorems  *)
<a name="line24"></a>    val <a href="#FORALL_NUM-val">FORALL_NUM</a> : thm
<a name="line25"></a>    val <a href="#IMAGE_wo2wo_SUBSET-val">IMAGE_wo2wo_SUBSET</a> : thm
<a name="line26"></a>    val <a href="#INJ_preserves_antisym-val">INJ_preserves_antisym</a> : thm
<a name="line27"></a>    val <a href="#INJ_preserves_linear_order-val">INJ_preserves_linear_order</a> : thm
<a name="line28"></a>    val <a href="#INJ_preserves_transitive-val">INJ_preserves_transitive</a> : thm
<a name="line29"></a>    val <a href="#INJ_preserves_wellorder-val">INJ_preserves_wellorder</a> : thm
<a name="line30"></a>    val <a href="#LT_wZERO-val">LT_wZERO</a> : thm
<a name="line31"></a>    val <a href="#StrongWellOrderExists-val">StrongWellOrderExists</a> : thm
<a name="line32"></a>    val <a href="#TARSKI_SET-val">TARSKI_SET</a> : thm
<a name="line33"></a>    val <a href="#WEXTENSION-val">WEXTENSION</a> : thm
<a name="line34"></a>    val <a href="#WF-val">WF</a> : thm
<a name="line35"></a>    val <a href="#WF_DCHAIN-val">WF_DCHAIN</a> : thm
<a name="line36"></a>    val <a href="#WF_EQ-val">WF_EQ</a> : thm
<a name="line37"></a>    val <a href="#WF_IND-val">WF_IND</a> : thm
<a name="line38"></a>    val <a href="#WF_REC-val">WF_REC</a> : thm
<a name="line39"></a>    val <a href="#WF_REC_INVARIANT-val">WF_REC_INVARIANT</a> : thm
<a name="line40"></a>    val <a href="#WF_REC_num-val">WF_REC_num</a> : thm
<a name="line41"></a>    val <a href="#WF_UREC-val">WF_UREC</a> : thm
<a name="line42"></a>    val <a href="#WF_UREC_WF-val">WF_UREC_WF</a> : thm
<a name="line43"></a>    val <a href="#WF_num-val">WF_num</a> : thm
<a name="line44"></a>    val <a href="#WIN_ADD1-val">WIN_ADD1</a> : thm
<a name="line45"></a>    val <a href="#WIN_REFL-val">WIN_REFL</a> : thm
<a name="line46"></a>    val <a href="#WIN_TRANS-val">WIN_TRANS</a> : thm
<a name="line47"></a>    val <a href="#WIN_WF-val">WIN_WF</a> : thm
<a name="line48"></a>    val <a href="#WIN_WF2-val">WIN_WF2</a> : thm
<a name="line49"></a>    val <a href="#WIN_WLE-val">WIN_WLE</a> : thm
<a name="line50"></a>    val <a href="#WIN_elsOf-val">WIN_elsOf</a> : thm
<a name="line51"></a>    val <a href="#WIN_remove-val">WIN_remove</a> : thm
<a name="line52"></a>    val <a href="#WIN_trichotomy-val">WIN_trichotomy</a> : thm
<a name="line53"></a>    val <a href="#WIN_wZERO-val">WIN_wZERO</a> : thm
<a name="line54"></a>    val <a href="#WIN_wobound-val">WIN_wobound</a> : thm
<a name="line55"></a>    val <a href="#WLE_ANTISYM-val">WLE_ANTISYM</a> : thm
<a name="line56"></a>    val <a href="#WLE_TRANS-val">WLE_TRANS</a> : thm
<a name="line57"></a>    val <a href="#WLE_WIN-val">WLE_WIN</a> : thm
<a name="line58"></a>    val <a href="#WLE_WIN_EQ-val">WLE_WIN_EQ</a> : thm
<a name="line59"></a>    val <a href="#WLE_elsOf-val">WLE_elsOf</a> : thm
<a name="line60"></a>    val <a href="#WLE_wZERO-val">WLE_wZERO</a> : thm
<a name="line61"></a>    val <a href="#WLE_wobound-val">WLE_wobound</a> : thm
<a name="line62"></a>    val <a href="#allsets_wellorderable-val">allsets_wellorderable</a> : thm
<a name="line63"></a>    val <a href="#antisym_rrestrict-val">antisym_rrestrict</a> : thm
<a name="line64"></a>    val <a href="#destWO_mkWO-val">destWO_mkWO</a> : thm
<a name="line65"></a>    val <a href="#domain_IMAGE_ff-val">domain_IMAGE_ff</a> : thm
<a name="line66"></a>    val <a href="#elsOf_ADD1-val">elsOf_ADD1</a> : thm
<a name="line67"></a>    val <a href="#elsOf_EQ_EMPTY-val">elsOf_EQ_EMPTY</a> : thm
<a name="line68"></a>    val <a href="#elsOf_WLE-val">elsOf_WLE</a> : thm
<a name="line69"></a>    val <a href="#elsOf_cardeq_iso-val">elsOf_cardeq_iso</a> : thm
<a name="line70"></a>    val <a href="#elsOf_fromNatWO-val">elsOf_fromNatWO</a> : thm
<a name="line71"></a>    val <a href="#elsOf_remove-val">elsOf_remove</a> : thm
<a name="line72"></a>    val <a href="#elsOf_wZERO-val">elsOf_wZERO</a> : thm
<a name="line73"></a>    val <a href="#elsOf_wobound-val">elsOf_wobound</a> : thm
<a name="line74"></a>    val <a href="#finite_iso-val">finite_iso</a> : thm
<a name="line75"></a>    val <a href="#finite_wZERO-val">finite_wZERO</a> : thm
<a name="line76"></a>    val <a href="#fromNatWO_11-val">fromNatWO_11</a> : thm
<a name="line77"></a>    val <a href="#linear_order_rrestrict-val">linear_order_rrestrict</a> : thm
<a name="line78"></a>    val <a href="#mkWO_destWO-val">mkWO_destWO</a> : thm
<a name="line79"></a>    val <a href="#mono_woseg-val">mono_woseg</a> : thm
<a name="line80"></a>    val <a href="#orderiso_REFL-val">orderiso_REFL</a> : thm
<a name="line81"></a>    val <a href="#orderiso_SYM-val">orderiso_SYM</a> : thm
<a name="line82"></a>    val <a href="#orderiso_TRANS-val">orderiso_TRANS</a> : thm
<a name="line83"></a>    val <a href="#orderiso_thm-val">orderiso_thm</a> : thm
<a name="line84"></a>    val <a href="#orderiso_unique-val">orderiso_unique</a> : thm
<a name="line85"></a>    val <a href="#orderiso_wZERO-val">orderiso_wZERO</a> : thm
<a name="line86"></a>    val <a href="#orderlt_REFL-val">orderlt_REFL</a> : thm
<a name="line87"></a>    val <a href="#orderlt_TRANS-val">orderlt_TRANS</a> : thm
<a name="line88"></a>    val <a href="#orderlt_WF-val">orderlt_WF</a> : thm
<a name="line89"></a>    val <a href="#orderlt_orderiso-val">orderlt_orderiso</a> : thm
<a name="line90"></a>    val <a href="#orderlt_trichotomy-val">orderlt_trichotomy</a> : thm
<a name="line91"></a>    val <a href="#range_IMAGE_ff-val">range_IMAGE_ff</a> : thm
<a name="line92"></a>    val <a href="#reflexive_rrestrict-val">reflexive_rrestrict</a> : thm
<a name="line93"></a>    val <a href="#rrestrict_SUBSET-val">rrestrict_SUBSET</a> : thm
<a name="line94"></a>    val <a href="#seteq_wlog-val">seteq_wlog</a> : thm
<a name="line95"></a>    val <a href="#strict_UNION-val">strict_UNION</a> : thm
<a name="line96"></a>    val <a href="#strict_subset-val">strict_subset</a> : thm
<a name="line97"></a>    val <a href="#transitive_rrestrict-val">transitive_rrestrict</a> : thm
<a name="line98"></a>    val <a href="#transitive_strict-val">transitive_strict</a> : thm
<a name="line99"></a>    val <a href="#wellfounded_WF-val">wellfounded_WF</a> : thm
<a name="line100"></a>    val <a href="#wellfounded_subset-val">wellfounded_subset</a> : thm
<a name="line101"></a>    val <a href="#wellorder_ADD1-val">wellorder_ADD1</a> : thm
<a name="line102"></a>    val <a href="#wellorder_EMPTY-val">wellorder_EMPTY</a> : thm
<a name="line103"></a>    val <a href="#wellorder_SING-val">wellorder_SING</a> : thm
<a name="line104"></a>    val <a href="#wellorder_cases-val">wellorder_cases</a> : thm
<a name="line105"></a>    val <a href="#wellorder_fromNat-val">wellorder_fromNat</a> : thm
<a name="line106"></a>    val <a href="#wellorder_fromNat_SUM-val">wellorder_fromNat_SUM</a> : thm
<a name="line107"></a>    val <a href="#wellorder_remove-val">wellorder_remove</a> : thm
<a name="line108"></a>    val <a href="#wellorder_rrestrict-val">wellorder_rrestrict</a> : thm
<a name="line109"></a>    val <a href="#wleast_EQ_NONE-val">wleast_EQ_NONE</a> : thm
<a name="line110"></a>    val <a href="#wleast_IN_wo-val">wleast_IN_wo</a> : thm
<a name="line111"></a>    val <a href="#wleast_SUBSET-val">wleast_SUBSET</a> : thm
<a name="line112"></a>    val <a href="#wo2wo_11-val">wo2wo_11</a> : thm
<a name="line113"></a>    val <a href="#wo2wo_EQ_NONE-val">wo2wo_EQ_NONE</a> : thm
<a name="line114"></a>    val <a href="#wo2wo_EQ_NONE_woseg-val">wo2wo_EQ_NONE_woseg</a> : thm
<a name="line115"></a>    val <a href="#wo2wo_EQ_SOME_downwards-val">wo2wo_EQ_SOME_downwards</a> : thm
<a name="line116"></a>    val <a href="#wo2wo_IN_w2-val">wo2wo_IN_w2</a> : thm
<a name="line117"></a>    val <a href="#wo2wo_ONTO-val">wo2wo_ONTO</a> : thm
<a name="line118"></a>    val <a href="#wo2wo_mono-val">wo2wo_mono</a> : thm
<a name="line119"></a>    val <a href="#wo2wo_thm-val">wo2wo_thm</a> : thm
<a name="line120"></a>    val <a href="#wo_INDUCTION-val">wo_INDUCTION</a> : thm
<a name="line121"></a>    val <a href="#wobound2-val">wobound2</a> : thm
<a name="line122"></a>    val <a href="#wobounds_preserve_bijections-val">wobounds_preserve_bijections</a> : thm
<a name="line123"></a>  
<a name="line124"></a>  val wellorder_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line125"></a>(*
   [indexedLists] Parent theory of "wellorder"
   
   [patternMatches] Parent theory of "wellorder"
   
   [set_relation] Parent theory of "wellorder"
   
   [<a name="ADD1_def-val"><b>ADD1_def</b></a>]  Definition
      
      ⊢ ∀e w.
          ADD1 e w =
          if e ∈ elsOf w then w
          else mkWO (destWO w ∪ {(x,e) | x ∈ elsOf w} ∪ {(e,e)})
   
   [<a name="elsOf_def-val"><b>elsOf_def</b></a>]  Definition
      
      ⊢ ∀w. elsOf w = domain (destWO w) ∪ wrange w
   
   [<a name="finite_def-val"><b>finite_def</b></a>]  Definition
      
      ⊢ ∀w. finite w ⇔ FINITE (elsOf w)
   
   [<a name="fromNatWO_def-val"><b>fromNatWO_def</b></a>]  Definition
      
      ⊢ ∀n. fromNatWO n = mkWO {(INL i,INL j) | i ≤ j ∧ j &lt; n}
   
   [<a name="iseg_def-val"><b>iseg_def</b></a>]  Definition
      
      ⊢ ∀w x. iseg w x = {y | (y,x) WIN w}
   
   [<a name="orderiso_def-val"><b>orderiso_def</b></a>]  Definition
      
      ⊢ ∀w1 w2.
          orderiso w1 w2 ⇔
          ∃f. (∀x. x ∈ elsOf w1 ⇒ f x ∈ elsOf w2) ∧
              (∀x1 x2.
                 x1 ∈ elsOf w1 ∧ x2 ∈ elsOf w1 ⇒ (f x1 = f x2 ⇔ x1 = x2)) ∧
              (∀y. y ∈ elsOf w2 ⇒ ∃x. x ∈ elsOf w1 ∧ f x = y) ∧
              ∀x y. (x,y) WIN w1 ⇒ (f x,f y) WIN w2
   
   [<a name="orderlt_def-val"><b>orderlt_def</b></a>]  Definition
      
      ⊢ ∀w1 w2.
          orderlt w1 w2 ⇔ ∃x. x ∈ elsOf w2 ∧ orderiso w1 (wobound x w2)
   
   [<a name="remove_def-val"><b>remove_def</b></a>]  Definition
      
      ⊢ ∀e w. remove e w = mkWO {(x,y) | x ≠ e ∧ y ≠ e ∧ (x,y) WLE w}
   
   [<a name="wZERO_def-val"><b>wZERO_def</b></a>]  Definition
      
      ⊢ wZERO = mkWO ∅
   
   [<a name="wellfounded_def-val"><b>wellfounded_def</b></a>]  Definition
      
      ⊢ ∀R. Wellfounded R ⇔
            ∀s. (∃w. w ∈ s) ⇒ ∃min. min ∈ s ∧ ∀w. (w,min) ∈ R ⇒ w ∉ s
   
   [<a name="wellorder_ABSREP-val"><b>wellorder_ABSREP</b></a>]  Definition
      
      ⊢ (∀a. mkWO (destWO a) = a) ∧ ∀r. wellorder r ⇔ destWO (mkWO r) = r
   
   [<a name="wellorder_TY_DEF-val"><b>wellorder_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep. TYPE_DEFINITION wellorder rep
   
   [<a name="wellorder_def-val"><b>wellorder_def</b></a>]  Definition
      
      ⊢ ∀R. wellorder R ⇔
            Wellfounded (strict R) ∧ linear_order R (domain R ∪ range R) ∧
            reflexive R (domain R ∪ range R)
   
   [<a name="wleast_def-val"><b>wleast_def</b></a>]  Definition
      
      ⊢ ∀w s.
          wleast w s =
          some x.
            x ∈ elsOf w ∧ x ∉ s ∧
            ∀y. y ∈ elsOf w ∧ y ∉ s ∧ x ≠ y ⇒ (x,y) WIN w
   
   [<a name="wo2wo_def-val"><b>wo2wo_def</b></a>]  Definition
      
      ⊢ ∀w1 w2.
          wo2wo w1 w2 =
          WFREC (λx y. (x,y) WIN w1)
            (λf x.
                 (let
                    s0 = IMAGE f (iseg w1 x);
                    s1 = IMAGE THE (s0 DELETE NONE)
                  in
                    if s1 = elsOf w2 then NONE else wleast w2 s1))
   
   [<a name="wobound_def-val"><b>wobound_def</b></a>]  Definition
      
      ⊢ ∀x w. wobound x w = mkWO (rrestrict (destWO w) (iseg w x))
   
   [<a name="FORALL_NUM-val"><b>FORALL_NUM</b></a>]  Theorem
      
      ⊢ (∀n. P n) ⇔ P 0 ∧ ∀n. P (SUC n)
   
   [<a name="IMAGE_wo2wo_SUBSET-val"><b>IMAGE_wo2wo_SUBSET</b></a>]  Theorem
      
      ⊢ woseg w1 w2 x ⊆ elsOf w2
   
   [<a name="INJ_preserves_antisym-val"><b>INJ_preserves_antisym</b></a>]  Theorem
      
      ⊢ antisym r ∧ INJ f (domain r ∪ range r) t ⇒
        antisym (IMAGE (f ## f) r)
   
   [<a name="INJ_preserves_linear_order-val"><b>INJ_preserves_linear_order</b></a>]  Theorem
      
      ⊢ linear_order r (domain r ∪ range r) ∧ INJ f (domain r ∪ range r) t ⇒
        linear_order (IMAGE (f ## f) r) (IMAGE f (domain r ∪ range r))
   
   [<a name="INJ_preserves_transitive-val"><b>INJ_preserves_transitive</b></a>]  Theorem
      
      ⊢ transitive r ∧ INJ f (domain r ∪ range r) t ⇒
        transitive (IMAGE (f ## f) r)
   
   [<a name="INJ_preserves_wellorder-val"><b>INJ_preserves_wellorder</b></a>]  Theorem
      
      ⊢ wellorder r ∧ INJ f (domain r ∪ range r) t ⇒
        wellorder (IMAGE (f ## f) r)
   
   [<a name="LT_wZERO-val"><b>LT_wZERO</b></a>]  Theorem
      
      ⊢ orderlt w wZERO ⇔ F
   
   [<a name="StrongWellOrderExists-val"><b>StrongWellOrderExists</b></a>]  Theorem
      
      ⊢ ∃R. StrongLinearOrder R ∧ WF R
   
   [<a name="TARSKI_SET-val"><b>TARSKI_SET</b></a>]  Theorem
      
      ⊢ ∀f. (∀s t. s ⊆ t ⇒ f s ⊆ f t) ⇒ ∃s. f s = s
   
   [<a name="WEXTENSION-val"><b>WEXTENSION</b></a>]  Theorem
      
      ⊢ w1 = w2 ⇔ ∀a b. (a,b) WLE w1 ⇔ (a,b) WLE w2
   
   [<a name="WF-val"><b>WF</b></a>]  Theorem
      
      ⊢ WF $&lt;&lt; ⇔ ∀P. (∃x. P x) ⇒ ∃x. P x ∧ ∀y. y &lt;&lt; x ⇒ ¬P y
   
   [<a name="WF_DCHAIN-val"><b>WF_DCHAIN</b></a>]  Theorem
      
      ⊢ WF $&lt;&lt; ⇔ ¬∃s. ∀n. s (SUC n) &lt;&lt; s n
   
   [<a name="WF_EQ-val"><b>WF_EQ</b></a>]  Theorem
      
      ⊢ WF $&lt;&lt; ⇔ ∀P. (∃x. P x) ⇔ ∃x. P x ∧ ∀y. y &lt;&lt; x ⇒ ¬P y
   
   [<a name="WF_IND-val"><b>WF_IND</b></a>]  Theorem
      
      ⊢ WF $&lt;&lt; ⇔ ∀P. (∀x. (∀y. y &lt;&lt; x ⇒ P y) ⇒ P x) ⇒ ∀x. P x
   
   [<a name="WF_REC-val"><b>WF_REC</b></a>]  Theorem
      
      ⊢ WF $&lt;&lt; ⇒
        ∀H. (∀f g x. (∀z. z &lt;&lt; x ⇒ f z = g z) ⇒ H f x = H g x) ⇒
            ∃f. ∀x. f x = H f x
   
   [<a name="WF_REC_INVARIANT-val"><b>WF_REC_INVARIANT</b></a>]  Theorem
      
      ⊢ WF $&lt;&lt; ⇒
        ∀H S.
          (∀f g x.
             (∀z. z &lt;&lt; x ⇒ f z = g z ∧ S z (f z)) ⇒
             H f x = H g x ∧ S x (H f x)) ⇒
          ∃f. ∀x. f x = H f x
   
   [<a name="WF_REC_num-val"><b>WF_REC_num</b></a>]  Theorem
      
      ⊢ ∀H. (∀f g n. (∀m. m &lt; n ⇒ f m = g m) ⇒ H f n = H g n) ⇒
            ∃f. ∀n. f n = H f n
   
   [<a name="WF_UREC-val"><b>WF_UREC</b></a>]  Theorem
      
      ⊢ WF $&lt;&lt; ⇒
        ∀H. (∀f g x. (∀z. z &lt;&lt; x ⇒ f z = g z) ⇒ H f x = H g x) ⇒
            ∀f g. (∀x. f x = H f x) ∧ (∀x. g x = H g x) ⇒ f = g
   
   [<a name="WF_UREC_WF-val"><b>WF_UREC_WF</b></a>]  Theorem
      
      ⊢ (∀H. (∀f g x. (∀z. z &lt;&lt; x ⇒ (f z ⇔ g z)) ⇒ (H f x ⇔ H g x)) ⇒
             ∀f g. (∀x. f x ⇔ H f x) ∧ (∀x. g x ⇔ H g x) ⇒ f = g) ⇒
        WF $&lt;&lt;
   
   [<a name="WF_num-val"><b>WF_num</b></a>]  Theorem
      
      ⊢ WF $&lt;
   
   [<a name="WIN_ADD1-val"><b>WIN_ADD1</b></a>]  Theorem
      
      ⊢ (x,y) WIN ADD1 e w ⇔
        e ∉ elsOf w ∧ x ∈ elsOf w ∧ y = e ∨ (x,y) WIN w
   
   [<a name="WIN_REFL-val"><b>WIN_REFL</b></a>]  Theorem
      
      ⊢ (x,x) WIN w ⇔ F
   
   [<a name="WIN_TRANS-val"><b>WIN_TRANS</b></a>]  Theorem
      
      ⊢ (x,y) WIN w ∧ (y,z) WIN w ⇒ (x,z) WIN w
   
   [<a name="WIN_WF-val"><b>WIN_WF</b></a>]  Theorem
      
      ⊢ Wellfounded (λp. p WIN w)
   
   [<a name="WIN_WF2-val"><b>WIN_WF2</b></a>]  Theorem
      
      ⊢ WF (λx y. (x,y) WIN w)
   
   [<a name="WIN_WLE-val"><b>WIN_WLE</b></a>]  Theorem
      
      ⊢ (x,y) WIN w ⇒ (x,y) WLE w
   
   [<a name="WIN_elsOf-val"><b>WIN_elsOf</b></a>]  Theorem
      
      ⊢ (x,y) WIN w ⇒ x ∈ elsOf w ∧ y ∈ elsOf w
   
   [<a name="WIN_remove-val"><b>WIN_remove</b></a>]  Theorem
      
      ⊢ (x,y) WIN remove e w ⇔ x ≠ e ∧ y ≠ e ∧ (x,y) WIN w
   
   [<a name="WIN_trichotomy-val"><b>WIN_trichotomy</b></a>]  Theorem
      
      ⊢ ∀x y. x ∈ elsOf w ∧ y ∈ elsOf w ⇒ (x,y) WIN w ∨ x = y ∨ (y,x) WIN w
   
   [<a name="WIN_wZERO-val"><b>WIN_wZERO</b></a>]  Theorem
      
      ⊢ (x,y) WIN wZERO ⇔ F
   
   [<a name="WIN_wobound-val"><b>WIN_wobound</b></a>]  Theorem
      
      ⊢ (x,y) WIN wobound z w ⇔ (x,z) WIN w ∧ (y,z) WIN w ∧ (x,y) WIN w
   
   [<a name="WLE_ANTISYM-val"><b>WLE_ANTISYM</b></a>]  Theorem
      
      ⊢ (x,y) WLE w ∧ (y,x) WLE w ⇒ x = y
   
   [<a name="WLE_TRANS-val"><b>WLE_TRANS</b></a>]  Theorem
      
      ⊢ (x,y) WLE w ∧ (y,z) WLE w ⇒ (x,z) WLE w
   
   [<a name="WLE_WIN-val"><b>WLE_WIN</b></a>]  Theorem
      
      ⊢ (x,y) WLE w ⇒ x = y ∨ (x,y) WIN w
   
   [<a name="WLE_WIN_EQ-val"><b>WLE_WIN_EQ</b></a>]  Theorem
      
      ⊢ (x,y) WLE w ⇔ x = y ∧ x ∈ elsOf w ∨ (x,y) WIN w
   
   [<a name="WLE_elsOf-val"><b>WLE_elsOf</b></a>]  Theorem
      
      ⊢ (x,y) WLE w ⇒ x ∈ elsOf w ∧ y ∈ elsOf w
   
   [<a name="WLE_wZERO-val"><b>WLE_wZERO</b></a>]  Theorem
      
      ⊢ (x,y) WLE wZERO ⇔ F
   
   [<a name="WLE_wobound-val"><b>WLE_wobound</b></a>]  Theorem
      
      ⊢ (x,y) WLE wobound z w ⇔ (x,z) WIN w ∧ (y,z) WIN w ∧ (x,y) WLE w
   
   [<a name="allsets_wellorderable-val"><b>allsets_wellorderable</b></a>]  Theorem
      
      ⊢ ∀s. ∃wo. elsOf wo = s
   
   [<a name="antisym_rrestrict-val"><b>antisym_rrestrict</b></a>]  Theorem
      
      ⊢ antisym r ⇒ antisym (rrestrict r s)
   
   [<a name="destWO_mkWO-val"><b>destWO_mkWO</b></a>]  Theorem
      
      ⊢ ∀r. wellorder r ⇒ destWO (mkWO r) = r
   
   [<a name="domain_IMAGE_ff-val"><b>domain_IMAGE_ff</b></a>]  Theorem
      
      ⊢ domain (IMAGE (f ## g) r) = IMAGE f (domain r)
   
   [<a name="elsOf_ADD1-val"><b>elsOf_ADD1</b></a>]  Theorem
      
      ⊢ elsOf (ADD1 e w) = e INSERT elsOf w
   
   [<a name="elsOf_EQ_EMPTY-val"><b>elsOf_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ elsOf w = ∅ ⇔ w = wZERO
   
   [<a name="elsOf_WLE-val"><b>elsOf_WLE</b></a>]  Theorem
      
      ⊢ x ∈ elsOf w ⇔ (x,x) WLE w
   
   [<a name="elsOf_cardeq_iso-val"><b>elsOf_cardeq_iso</b></a>]  Theorem
      
      ⊢ INJ f (elsOf wo) 𝕌(:α) ⇒ ∃wo'. orderiso wo wo'
   
   [<a name="elsOf_fromNatWO-val"><b>elsOf_fromNatWO</b></a>]  Theorem
      
      ⊢ elsOf (fromNatWO n) = IMAGE INL (count n)
   
   [<a name="elsOf_remove-val"><b>elsOf_remove</b></a>]  Theorem
      
      ⊢ elsOf (remove e w) = elsOf w DELETE e
   
   [<a name="elsOf_wZERO-val"><b>elsOf_wZERO</b></a>]  Theorem
      
      ⊢ elsOf wZERO = ∅
   
   [<a name="elsOf_wobound-val"><b>elsOf_wobound</b></a>]  Theorem
      
      ⊢ elsOf (wobound x w) = {y | (y,x) WIN w}
   
   [<a name="finite_iso-val"><b>finite_iso</b></a>]  Theorem
      
      ⊢ orderiso w1 w2 ⇒ (finite w1 ⇔ finite w2)
   
   [<a name="finite_wZERO-val"><b>finite_wZERO</b></a>]  Theorem
      
      ⊢ finite wZERO
   
   [<a name="fromNatWO_11-val"><b>fromNatWO_11</b></a>]  Theorem
      
      ⊢ fromNatWO i = fromNatWO j ⇔ i = j
   
   [<a name="linear_order_rrestrict-val"><b>linear_order_rrestrict</b></a>]  Theorem
      
      ⊢ linear_order r (domain r ∪ range r) ⇒
        linear_order (rrestrict r s)
          (domain (rrestrict r s) ∪ range (rrestrict r s))
   
   [<a name="mkWO_destWO-val"><b>mkWO_destWO</b></a>]  Theorem
      
      ⊢ ∀a. mkWO (destWO a) = a
   
   [<a name="mono_woseg-val"><b>mono_woseg</b></a>]  Theorem
      
      ⊢ (x1,x2) WIN w1 ⇒ woseg w1 w2 x1 ⊆ woseg w1 w2 x2
   
   [<a name="orderiso_REFL-val"><b>orderiso_REFL</b></a>]  Theorem
      
      ⊢ ∀w. orderiso w w
   
   [<a name="orderiso_SYM-val"><b>orderiso_SYM</b></a>]  Theorem
      
      ⊢ ∀w1 w2. orderiso w1 w2 ⇒ orderiso w2 w1
   
   [<a name="orderiso_TRANS-val"><b>orderiso_TRANS</b></a>]  Theorem
      
      ⊢ ∀w1 w2 w3. orderiso w1 w2 ∧ orderiso w2 w3 ⇒ orderiso w1 w3
   
   [<a name="orderiso_thm-val"><b>orderiso_thm</b></a>]  Theorem
      
      ⊢ orderiso w1 w2 ⇔
        ∃f. BIJ f (elsOf w1) (elsOf w2) ∧
            ∀x y. (x,y) WIN w1 ⇒ (f x,f y) WIN w2
   
   [<a name="orderiso_unique-val"><b>orderiso_unique</b></a>]  Theorem
      
      ⊢ BIJ f1 (elsOf w1) (elsOf w2) ∧ BIJ f2 (elsOf w1) (elsOf w2) ∧
        (∀x y. (x,y) WIN w1 ⇒ (f1 x,f1 y) WIN w2) ∧
        (∀x y. (x,y) WIN w1 ⇒ (f2 x,f2 y) WIN w2) ⇒
        ∀x. x ∈ elsOf w1 ⇒ f1 x = f2 x
   
   [<a name="orderiso_wZERO-val"><b>orderiso_wZERO</b></a>]  Theorem
      
      ⊢ orderiso wZERO w ⇔ w = wZERO
   
   [<a name="orderlt_REFL-val"><b>orderlt_REFL</b></a>]  Theorem
      
      ⊢ orderlt w w ⇔ F
   
   [<a name="orderlt_TRANS-val"><b>orderlt_TRANS</b></a>]  Theorem
      
      ⊢ ∀w1 w2 w3. orderlt w1 w2 ∧ orderlt w2 w3 ⇒ orderlt w1 w3
   
   [<a name="orderlt_WF-val"><b>orderlt_WF</b></a>]  Theorem
      
      ⊢ WF orderlt
   
   [<a name="orderlt_orderiso-val"><b>orderlt_orderiso</b></a>]  Theorem
      
      ⊢ orderiso x0 y0 ∧ orderiso a0 b0 ⇒ (orderlt x0 a0 ⇔ orderlt y0 b0)
   
   [<a name="orderlt_trichotomy-val"><b>orderlt_trichotomy</b></a>]  Theorem
      
      ⊢ orderlt w1 w2 ∨ orderiso w1 w2 ∨ orderlt w2 w1
   
   [<a name="range_IMAGE_ff-val"><b>range_IMAGE_ff</b></a>]  Theorem
      
      ⊢ range (IMAGE (f ## g) r) = IMAGE g (range r)
   
   [<a name="reflexive_rrestrict-val"><b>reflexive_rrestrict</b></a>]  Theorem
      
      ⊢ reflexive r (domain r ∪ range r) ⇒
        reflexive (rrestrict r s)
          (domain (rrestrict r s) ∪ range (rrestrict r s))
   
   [<a name="rrestrict_SUBSET-val"><b>rrestrict_SUBSET</b></a>]  Theorem
      
      ⊢ ∀r s. rrestrict r s ⊆ r
   
   [<a name="seteq_wlog-val"><b>seteq_wlog</b></a>]  Theorem
      
      ⊢ ∀f. (∀a b. P a b ⇒ P b a) ∧ (∀x a b. P a b ∧ x ∈ f a ⇒ x ∈ f b) ⇒
            ∀a b. P a b ⇒ f a = f b
   
   [<a name="strict_UNION-val"><b>strict_UNION</b></a>]  Theorem
      
      ⊢ strict (r1 ∪ r2) = strict r1 ∪ strict r2
   
   [<a name="strict_subset-val"><b>strict_subset</b></a>]  Theorem
      
      ⊢ r1 ⊆ r2 ⇒ strict r1 ⊆ strict r2
   
   [<a name="transitive_rrestrict-val"><b>transitive_rrestrict</b></a>]  Theorem
      
      ⊢ transitive r ⇒ transitive (rrestrict r s)
   
   [<a name="transitive_strict-val"><b>transitive_strict</b></a>]  Theorem
      
      ⊢ transitive r ∧ antisym r ⇒ transitive (strict r)
   
   [<a name="wellfounded_WF-val"><b>wellfounded_WF</b></a>]  Theorem
      
      ⊢ ∀R. Wellfounded R ⇔ WF (CURRY R)
   
   [<a name="wellfounded_subset-val"><b>wellfounded_subset</b></a>]  Theorem
      
      ⊢ ∀r0 r. Wellfounded r ∧ r0 ⊆ r ⇒ Wellfounded r0
   
   [<a name="wellorder_ADD1-val"><b>wellorder_ADD1</b></a>]  Theorem
      
      ⊢ e ∉ elsOf w ⇒
        wellorder (destWO w ∪ {(x,e) | x ∈ elsOf w} ∪ {(e,e)})
   
   [<a name="wellorder_EMPTY-val"><b>wellorder_EMPTY</b></a>]  Theorem
      
      ⊢ wellorder ∅
   
   [<a name="wellorder_SING-val"><b>wellorder_SING</b></a>]  Theorem
      
      ⊢ ∀x y. wellorder {(x,y)} ⇔ x = y
   
   [<a name="wellorder_cases-val"><b>wellorder_cases</b></a>]  Theorem
      
      ⊢ ∀w. ∃s. wellorder s ∧ w = mkWO s
   
   [<a name="wellorder_fromNat-val"><b>wellorder_fromNat</b></a>]  Theorem
      
      ⊢ wellorder {(i,j) | i ≤ j ∧ j &lt; n}
   
   [<a name="wellorder_fromNat_SUM-val"><b>wellorder_fromNat_SUM</b></a>]  Theorem
      
      ⊢ wellorder {(INL i,INL j) | i ≤ j ∧ j &lt; n}
   
   [<a name="wellorder_remove-val"><b>wellorder_remove</b></a>]  Theorem
      
      ⊢ wellorder {(x,y) | x ≠ e ∧ y ≠ e ∧ (x,y) WLE w}
   
   [<a name="wellorder_rrestrict-val"><b>wellorder_rrestrict</b></a>]  Theorem
      
      ⊢ wellorder (rrestrict (destWO w) s)
   
   [<a name="wleast_EQ_NONE-val"><b>wleast_EQ_NONE</b></a>]  Theorem
      
      ⊢ wleast w s = NONE ⇒ elsOf w ⊆ s
   
   [<a name="wleast_IN_wo-val"><b>wleast_IN_wo</b></a>]  Theorem
      
      ⊢ wleast w s = SOME x ⇒
        x ∈ elsOf w ∧ x ∉ s ∧ ∀y. y ∈ elsOf w ∧ y ∉ s ∧ x ≠ y ⇒ (x,y) WIN w
   
   [<a name="wleast_SUBSET-val"><b>wleast_SUBSET</b></a>]  Theorem
      
      ⊢ wleast w s1 = SOME x ∧ wleast w s2 = SOME y ∧ s1 ⊆ s2 ⇒
        x = y ∨ (x,y) WIN w
   
   [<a name="wo2wo_11-val"><b>wo2wo_11</b></a>]  Theorem
      
      ⊢ x1 ∈ elsOf w1 ∧ x2 ∈ elsOf w1 ∧ wo2wo w1 w2 x1 = SOME y ∧
        wo2wo w1 w2 x2 = SOME y ⇒
        x1 = x2
   
   [<a name="wo2wo_EQ_NONE-val"><b>wo2wo_EQ_NONE</b></a>]  Theorem
      
      ⊢ ∀x. wo2wo w1 w2 x = NONE ⇒ ∀y. (x,y) WIN w1 ⇒ wo2wo w1 w2 y = NONE
   
   [<a name="wo2wo_EQ_NONE_woseg-val"><b>wo2wo_EQ_NONE_woseg</b></a>]  Theorem
      
      ⊢ wo2wo w1 w2 x = NONE ⇒ elsOf w2 = woseg w1 w2 x
   
   [<a name="wo2wo_EQ_SOME_downwards-val"><b>wo2wo_EQ_SOME_downwards</b></a>]  Theorem
      
      ⊢ ∀x y.
          wo2wo w1 w2 x = SOME y ⇒
          ∀x0. (x0,x) WIN w1 ⇒ ∃y0. wo2wo w1 w2 x0 = SOME y0
   
   [<a name="wo2wo_IN_w2-val"><b>wo2wo_IN_w2</b></a>]  Theorem
      
      ⊢ ∀x y. wo2wo w1 w2 x = SOME y ⇒ y ∈ elsOf w2
   
   [<a name="wo2wo_ONTO-val"><b>wo2wo_ONTO</b></a>]  Theorem
      
      ⊢ x ∈ elsOf w1 ∧ wo2wo w1 w2 x = SOME y ∧ (y0,y) WIN w2 ⇒
        ∃x0. x0 ∈ elsOf w1 ∧ wo2wo w1 w2 x0 = SOME y0
   
   [<a name="wo2wo_mono-val"><b>wo2wo_mono</b></a>]  Theorem
      
      ⊢ wo2wo w1 w2 x0 = SOME y0 ∧ wo2wo w1 w2 x = SOME y ∧ (x0,x) WIN w1 ⇒
        (y0,y) WIN w2
   
   [<a name="wo2wo_thm-val"><b>wo2wo_thm</b></a>]  Theorem
      
      ⊢ ∀x. wo2wo w w2 x =
            (let
               s0 = IMAGE (wo2wo w w2) (iseg w x);
               s1 = IMAGE THE (s0 DELETE NONE)
             in
               if s1 = elsOf w2 then NONE else wleast w2 s1)
   
   [<a name="wo_INDUCTION-val"><b>wo_INDUCTION</b></a>]  Theorem
      
      ⊢ ∀P w.
          (∀x. (∀y. (y,x) WIN w ⇒ y ∈ elsOf w ⇒ P y) ⇒ x ∈ elsOf w ⇒ P x) ⇒
          ∀x. x ∈ elsOf w ⇒ P x
   
   [<a name="wobound2-val"><b>wobound2</b></a>]  Theorem
      
      ⊢ (a,b) WIN w ⇒ wobound a (wobound b w) = wobound a w
   
   [<a name="wobounds_preserve_bijections-val"><b>wobounds_preserve_bijections</b></a>]  Theorem
      
      ⊢ BIJ f (elsOf w1) (elsOf w2) ∧ x ∈ elsOf w1 ∧
        (∀x y. (x,y) WIN w1 ⇒ (f x,f y) WIN w2) ⇒
        BIJ f (elsOf (wobound x w1)) (elsOf (wobound (f x) w2))
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/pred_set/src/more_theories/wellorderScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-1</a></em></p></body></html>
