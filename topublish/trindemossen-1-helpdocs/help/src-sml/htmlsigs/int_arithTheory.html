<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure int_arithTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure int_arithTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/integer/int_arithScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature int_arithTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#bmarker_def-val">bmarker_def</a> : thm
<a name="line7"></a>  
<a name="line8"></a>  (*  Theorems  *)
<a name="line9"></a>    val <a href="#CONJ_EQ_ELIM-val">CONJ_EQ_ELIM</a> : thm
<a name="line10"></a>    val <a href="#HO_SUB_ELIM-val">HO_SUB_ELIM</a> : thm
<a name="line11"></a>    val <a href="#INT_DIVIDES_LRMUL-val">INT_DIVIDES_LRMUL</a> : thm
<a name="line12"></a>    val <a href="#INT_DIVIDES_RELPRIME_MUL-val">INT_DIVIDES_RELPRIME_MUL</a> : thm
<a name="line13"></a>    val <a href="#INT_LINEAR_GCD-val">INT_LINEAR_GCD</a> : thm
<a name="line14"></a>    val <a href="#INT_LT_ADD_NUMERAL-val">INT_LT_ADD_NUMERAL</a> : thm
<a name="line15"></a>    val <a href="#INT_NUM_COND-val">INT_NUM_COND</a> : thm
<a name="line16"></a>    val <a href="#INT_NUM_DIVIDES-val">INT_NUM_DIVIDES</a> : thm
<a name="line17"></a>    val <a href="#INT_NUM_EVEN-val">INT_NUM_EVEN</a> : thm
<a name="line18"></a>    val <a href="#INT_NUM_EXISTS-val">INT_NUM_EXISTS</a> : thm
<a name="line19"></a>    val <a href="#INT_NUM_FORALL-val">INT_NUM_FORALL</a> : thm
<a name="line20"></a>    val <a href="#INT_NUM_ODD-val">INT_NUM_ODD</a> : thm
<a name="line21"></a>    val <a href="#INT_NUM_SUB-val">INT_NUM_SUB</a> : thm
<a name="line22"></a>    val <a href="#INT_NUM_UEXISTS-val">INT_NUM_UEXISTS</a> : thm
<a name="line23"></a>    val <a href="#INT_SUB_SUB3-val">INT_SUB_SUB3</a> : thm
<a name="line24"></a>    val <a href="#NOT_INT_DIVIDES-val">NOT_INT_DIVIDES</a> : thm
<a name="line25"></a>    val <a href="#NOT_INT_DIVIDES_POS-val">NOT_INT_DIVIDES_POS</a> : thm
<a name="line26"></a>    val <a href="#add_to_greater-val">add_to_greater</a> : thm
<a name="line27"></a>    val <a href="#bmarker_rewrites-val">bmarker_rewrites</a> : thm
<a name="line28"></a>    val <a href="#bot_and_greaters-val">bot_and_greaters</a> : thm
<a name="line29"></a>    val <a href="#can_get_big-val">can_get_big</a> : thm
<a name="line30"></a>    val <a href="#can_get_small-val">can_get_small</a> : thm
<a name="line31"></a>    val <a href="#cooper_lemma_1-val">cooper_lemma_1</a> : thm
<a name="line32"></a>    val <a href="#elim_eq-val">elim_eq</a> : thm
<a name="line33"></a>    val <a href="#elim_eq_coeffs-val">elim_eq_coeffs</a> : thm
<a name="line34"></a>    val <a href="#elim_le_coeffs-val">elim_le_coeffs</a> : thm
<a name="line35"></a>    val <a href="#elim_lt_coeffs1-val">elim_lt_coeffs1</a> : thm
<a name="line36"></a>    val <a href="#elim_lt_coeffs2-val">elim_lt_coeffs2</a> : thm
<a name="line37"></a>    val <a href="#elim_minus_ones-val">elim_minus_ones</a> : thm
<a name="line38"></a>    val <a href="#elim_neg_ones-val">elim_neg_ones</a> : thm
<a name="line39"></a>    val <a href="#eq_context_rwt1-val">eq_context_rwt1</a> : thm
<a name="line40"></a>    val <a href="#eq_context_rwt2-val">eq_context_rwt2</a> : thm
<a name="line41"></a>    val <a href="#eq_justify_multiplication-val">eq_justify_multiplication</a> : thm
<a name="line42"></a>    val <a href="#eq_move_all_left-val">eq_move_all_left</a> : thm
<a name="line43"></a>    val <a href="#eq_move_all_right-val">eq_move_all_right</a> : thm
<a name="line44"></a>    val <a href="#eq_move_left_left-val">eq_move_left_left</a> : thm
<a name="line45"></a>    val <a href="#eq_move_left_right-val">eq_move_left_right</a> : thm
<a name="line46"></a>    val <a href="#eq_move_right_left-val">eq_move_right_left</a> : thm
<a name="line47"></a>    val <a href="#gcd1thm-val">gcd1thm</a> : thm
<a name="line48"></a>    val <a href="#gcd21_thm-val">gcd21_thm</a> : thm
<a name="line49"></a>    val <a href="#gcdthm2-val">gcdthm2</a> : thm
<a name="line50"></a>    val <a href="#in_additive_range-val">in_additive_range</a> : thm
<a name="line51"></a>    val <a href="#in_subtractive_range-val">in_subtractive_range</a> : thm
<a name="line52"></a>    val <a href="#justify_divides-val">justify_divides</a> : thm
<a name="line53"></a>    val <a href="#justify_divides2-val">justify_divides2</a> : thm
<a name="line54"></a>    val <a href="#justify_divides3-val">justify_divides3</a> : thm
<a name="line55"></a>    val <a href="#lcm_eliminate-val">lcm_eliminate</a> : thm
<a name="line56"></a>    val <a href="#le_context_rwt1-val">le_context_rwt1</a> : thm
<a name="line57"></a>    val <a href="#le_context_rwt2-val">le_context_rwt2</a> : thm
<a name="line58"></a>    val <a href="#le_context_rwt3-val">le_context_rwt3</a> : thm
<a name="line59"></a>    val <a href="#le_context_rwt4-val">le_context_rwt4</a> : thm
<a name="line60"></a>    val <a href="#le_context_rwt5-val">le_context_rwt5</a> : thm
<a name="line61"></a>    val <a href="#le_move_all_right-val">le_move_all_right</a> : thm
<a name="line62"></a>    val <a href="#le_move_right_left-val">le_move_right_left</a> : thm
<a name="line63"></a>    val <a href="#less_to_leq_samel-val">less_to_leq_samel</a> : thm
<a name="line64"></a>    val <a href="#less_to_leq_samer-val">less_to_leq_samer</a> : thm
<a name="line65"></a>    val <a href="#lt_justify_multiplication-val">lt_justify_multiplication</a> : thm
<a name="line66"></a>    val <a href="#lt_move_all_left-val">lt_move_all_left</a> : thm
<a name="line67"></a>    val <a href="#lt_move_all_right-val">lt_move_all_right</a> : thm
<a name="line68"></a>    val <a href="#lt_move_left_left-val">lt_move_left_left</a> : thm
<a name="line69"></a>    val <a href="#lt_move_left_right-val">lt_move_left_right</a> : thm
<a name="line70"></a>    val <a href="#move_sub-val">move_sub</a> : thm
<a name="line71"></a>    val <a href="#not_less-val">not_less</a> : thm
<a name="line72"></a>    val <a href="#positive_product_implication-val">positive_product_implication</a> : thm
<a name="line73"></a>    val <a href="#restricted_quantification_simp-val">restricted_quantification_simp</a> : thm
<a name="line74"></a>    val <a href="#subtract_to_small-val">subtract_to_small</a> : thm
<a name="line75"></a>    val <a href="#top_and_lessers-val">top_and_lessers</a> : thm
<a name="line76"></a>  
<a name="line77"></a>  val int_arith_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line78"></a>(*
   [gcd] Parent theory of "int_arith"
   
   [integer] Parent theory of "int_arith"
   
   [<a name="bmarker_def-val"><b>bmarker_def</b></a>]  Definition
      
      ⊢ ∀b. int_arith$bmarker b ⇔ b
   
   [<a name="CONJ_EQ_ELIM-val"><b>CONJ_EQ_ELIM</b></a>]  Theorem
      
      ⊢ ∀P v e. (v = e) ∧ P v ⇔ (v = e) ∧ P e
   
   [<a name="HO_SUB_ELIM-val"><b>HO_SUB_ELIM</b></a>]  Theorem
      
      ⊢ ∀P a b. P (&(a − b)) ⇔ &b ≤ &a ∧ P (&a + -&b) ∨ &a &lt; &b ∧ P 0
   
   [<a name="INT_DIVIDES_LRMUL-val"><b>INT_DIVIDES_LRMUL</b></a>]  Theorem
      
      ⊢ ∀p q r. q ≠ 0 ⇒ (p * q int_divides r * q ⇔ p int_divides r)
   
   [<a name="INT_DIVIDES_RELPRIME_MUL-val"><b>INT_DIVIDES_RELPRIME_MUL</b></a>]  Theorem
      
      ⊢ ∀p q r. (gcd p q = 1) ⇒ (&p int_divides &q * r ⇔ &p int_divides r)
   
   [<a name="INT_LINEAR_GCD-val"><b>INT_LINEAR_GCD</b></a>]  Theorem
      
      ⊢ ∀n m. ∃p q. p * &n + q * &m = &gcd n m
   
   [<a name="INT_LT_ADD_NUMERAL-val"><b>INT_LT_ADD_NUMERAL</b></a>]  Theorem
      
      ⊢ ∀x y.
          x &lt; x + &NUMERAL (BIT1 y) ∧ x &lt; x + &NUMERAL (BIT2 y) ∧
          ¬(x &lt; x + -&NUMERAL y)
   
   [<a name="INT_NUM_COND-val"><b>INT_NUM_COND</b></a>]  Theorem
      
      ⊢ ∀b n m. &(if b then n else m) = if b then &n else &m
   
   [<a name="INT_NUM_DIVIDES-val"><b>INT_NUM_DIVIDES</b></a>]  Theorem
      
      ⊢ ∀n m. &n int_divides &m ⇔ divides n m
   
   [<a name="INT_NUM_EVEN-val"><b>INT_NUM_EVEN</b></a>]  Theorem
      
      ⊢ ∀n. EVEN n ⇔ 2 int_divides &n
   
   [<a name="INT_NUM_EXISTS-val"><b>INT_NUM_EXISTS</b></a>]  Theorem
      
      ⊢ (∃n. P (&n)) ⇔ ∃x. 0 ≤ x ∧ P x
   
   [<a name="INT_NUM_FORALL-val"><b>INT_NUM_FORALL</b></a>]  Theorem
      
      ⊢ (∀n. P (&n)) ⇔ ∀x. 0 ≤ x ⇒ P x
   
   [<a name="INT_NUM_ODD-val"><b>INT_NUM_ODD</b></a>]  Theorem
      
      ⊢ ∀n. ODD n ⇔ ¬(2 int_divides &n)
   
   [<a name="INT_NUM_SUB-val"><b>INT_NUM_SUB</b></a>]  Theorem
      
      ⊢ ∀n m. &(n − m) = if &n &lt; &m then 0 else &n − &m
   
   [<a name="INT_NUM_UEXISTS-val"><b>INT_NUM_UEXISTS</b></a>]  Theorem
      
      ⊢ (∃!n. P (&n)) ⇔ ∃!x. 0 ≤ x ∧ P x
   
   [<a name="INT_SUB_SUB3-val"><b>INT_SUB_SUB3</b></a>]  Theorem
      
      ⊢ ∀x y z. x − (y − z) = x + z − y
   
   [<a name="NOT_INT_DIVIDES-val"><b>NOT_INT_DIVIDES</b></a>]  Theorem
      
      ⊢ ∀c d.
          c ≠ 0 ⇒
          (¬(c int_divides d) ⇔
           ∃i. 1 ≤ i ∧ i ≤ ABS c − 1 ∧ c int_divides d + i)
   
   [<a name="NOT_INT_DIVIDES_POS-val"><b>NOT_INT_DIVIDES_POS</b></a>]  Theorem
      
      ⊢ ∀n d.
          n ≠ 0 ⇒
          (¬(&n int_divides d) ⇔
           ∃i. (1 ≤ i ∧ i ≤ &n − 1) ∧ &n int_divides d + i)
   
   [<a name="add_to_greater-val"><b>add_to_greater</b></a>]  Theorem
      
      ⊢ ∀x d. 0 &lt; d ⇒ ∃k. 0 &lt; x + k * d ∧ x + k * d ≤ d
   
   [<a name="bmarker_rewrites-val"><b>bmarker_rewrites</b></a>]  Theorem
      
      ⊢ ∀p q r.
          (q ∧ int_arith$bmarker p ⇔ int_arith$bmarker p ∧ q) ∧
          (q ∧ int_arith$bmarker p ∧ r ⇔ int_arith$bmarker p ∧ q ∧ r) ∧
          ((int_arith$bmarker p ∧ q) ∧ r ⇔ int_arith$bmarker p ∧ q ∧ r)
   
   [<a name="bot_and_greaters-val"><b>bot_and_greaters</b></a>]  Theorem
      
      ⊢ ∀P d x0. (∀x. P x ⇒ P (x + d)) ∧ P x0 ⇒ ∀c. 0 &lt; c ⇒ P (x0 + c * d)
   
   [<a name="can_get_big-val"><b>can_get_big</b></a>]  Theorem
      
      ⊢ ∀x y d. 0 &lt; d ⇒ ∃c. 0 &lt; c ∧ x &lt; y + c * d
   
   [<a name="can_get_small-val"><b>can_get_small</b></a>]  Theorem
      
      ⊢ ∀x y d. 0 &lt; d ⇒ ∃c. 0 &lt; c ∧ y − c * d &lt; x
   
   [<a name="cooper_lemma_1-val"><b>cooper_lemma_1</b></a>]  Theorem
      
      ⊢ ∀m n a b u v p q x d.
          (d = gcd (u * m) (a * n)) ∧ (&d = p * &u * &m + q * &a * &n) ∧
          m ≠ 0 ∧ n ≠ 0 ∧ a ≠ 0 ∧ u ≠ 0 ⇒
          (&m int_divides &a * x + b ∧ &n int_divides &u * x + v ⇔
           &m * &n int_divides &d * x + v * &m * p + b * &n * q ∧
           &d int_divides &a * v − &u * b)
   
   [<a name="elim_eq-val"><b>elim_eq</b></a>]  Theorem
      
      ⊢ (x = y) ⇔ x &lt; y + 1 ∧ y &lt; x + 1
   
   [<a name="elim_eq_coeffs-val"><b>elim_eq_coeffs</b></a>]  Theorem
      
      ⊢ ∀m x y. m ≠ 0 ⇒ ((&m * x = y) ⇔ &m int_divides y ∧ (x = y / &m))
   
   [<a name="elim_le_coeffs-val"><b>elim_le_coeffs</b></a>]  Theorem
      
      ⊢ ∀m n x. 0 &lt; m ⇒ (0 ≤ m * x + n ⇔ 0 ≤ x + n / m)
   
   [<a name="elim_lt_coeffs1-val"><b>elim_lt_coeffs1</b></a>]  Theorem
      
      ⊢ ∀n m x. m ≠ 0 ⇒ (&n &lt; &m * x ⇔ &n / &m &lt; x)
   
   [<a name="elim_lt_coeffs2-val"><b>elim_lt_coeffs2</b></a>]  Theorem
      
      ⊢ ∀n m x.
          m ≠ 0 ⇒
          (&m * x &lt; &n ⇔
           x &lt; if &m int_divides &n then &n / &m else &n / &m + 1)
   
   [<a name="elim_minus_ones-val"><b>elim_minus_ones</b></a>]  Theorem
      
      ⊢ ∀x. x + 1 − 1 = x
   
   [<a name="elim_neg_ones-val"><b>elim_neg_ones</b></a>]  Theorem
      
      ⊢ ∀x. x + -1 + 1 = x
   
   [<a name="eq_context_rwt1-val"><b>eq_context_rwt1</b></a>]  Theorem
      
      ⊢ (0 = c + x) ⇒ (0 ≤ c + y ⇔ x ≤ y)
   
   [<a name="eq_context_rwt2-val"><b>eq_context_rwt2</b></a>]  Theorem
      
      ⊢ (0 = c + x) ⇒ (0 ≤ -c + y ⇔ -x ≤ y)
   
   [<a name="eq_justify_multiplication-val"><b>eq_justify_multiplication</b></a>]  Theorem
      
      ⊢ ∀n x y. 0 &lt; n ⇒ ((x = y) ⇔ (n * x = n * y))
   
   [<a name="eq_move_all_left-val"><b>eq_move_all_left</b></a>]  Theorem
      
      ⊢ ∀x y. (x = y) ⇔ (x + -y = 0)
   
   [<a name="eq_move_all_right-val"><b>eq_move_all_right</b></a>]  Theorem
      
      ⊢ ∀x y. (x = y) ⇔ (0 = y + -x)
   
   [<a name="eq_move_left_left-val"><b>eq_move_left_left</b></a>]  Theorem
      
      ⊢ ∀x y z. (x = y + z) ⇔ (x + -y = z)
   
   [<a name="eq_move_left_right-val"><b>eq_move_left_right</b></a>]  Theorem
      
      ⊢ ∀x y z. (x + y = z) ⇔ (y = z + -x)
   
   [<a name="eq_move_right_left-val"><b>eq_move_right_left</b></a>]  Theorem
      
      ⊢ ∀x y z. (x = y + z) ⇔ (x + -z = y)
   
   [<a name="gcd1thm-val"><b>gcd1thm</b></a>]  Theorem
      
      ⊢ ∀m n p q. (p * &m + q * &n = 1) ⇒ (gcd m n = 1)
   
   [<a name="gcd21_thm-val"><b>gcd21_thm</b></a>]  Theorem
      
      ⊢ ∀m a x b p q.
          (p * &a + q * &m = 1) ∧ m ≠ 0 ∧ a ≠ 0 ⇒
          (&m int_divides &a * x + b ⇔ ∃t. x = -p * b + t * &m)
   
   [<a name="gcdthm2-val"><b>gcdthm2</b></a>]  Theorem
      
      ⊢ ∀m a x b d p q.
          (d = gcd a m) ∧ (&d = p * &a + q * &m) ∧ d ≠ 0 ∧ m ≠ 0 ∧ a ≠ 0 ⇒
          (&m int_divides &a * x + b ⇔
           &d int_divides b ∧ ∃t. x = -p * (b / &d) + t * (&m / &d))
   
   [<a name="in_additive_range-val"><b>in_additive_range</b></a>]  Theorem
      
      ⊢ ∀low d x. low &lt; x ∧ x ≤ low + d ⇔ ∃j. (x = low + j) ∧ 0 &lt; j ∧ j ≤ d
   
   [<a name="in_subtractive_range-val"><b>in_subtractive_range</b></a>]  Theorem
      
      ⊢ ∀high d x.
          high − d ≤ x ∧ x &lt; high ⇔ ∃j. (x = high − j) ∧ 0 &lt; j ∧ j ≤ d
   
   [<a name="justify_divides-val"><b>justify_divides</b></a>]  Theorem
      
      ⊢ ∀n x y. 0 &lt; n ⇒ (x int_divides y ⇔ n * x int_divides n * y)
   
   [<a name="justify_divides2-val"><b>justify_divides2</b></a>]  Theorem
      
      ⊢ ∀n c x y.
          n * x int_divides n * y + c ⇔
          n * x int_divides n * y + c ∧ n int_divides c
   
   [<a name="justify_divides3-val"><b>justify_divides3</b></a>]  Theorem
      
      ⊢ ∀n x c. n int_divides n * x + c ⇔ n int_divides c
   
   [<a name="lcm_eliminate-val"><b>lcm_eliminate</b></a>]  Theorem
      
      ⊢ ∀P c. (∃x. P (c * x)) ⇔ ∃x. P x ∧ c int_divides x
   
   [<a name="le_context_rwt1-val"><b>le_context_rwt1</b></a>]  Theorem
      
      ⊢ 0 ≤ c + x ⇒ x ≤ y ⇒ (0 ≤ c + y ⇔ T)
   
   [<a name="le_context_rwt2-val"><b>le_context_rwt2</b></a>]  Theorem
      
      ⊢ 0 ≤ c + x ⇒ y &lt; -x ⇒ (0 ≤ -c + y ⇔ F)
   
   [<a name="le_context_rwt3-val"><b>le_context_rwt3</b></a>]  Theorem
      
      ⊢ 0 ≤ c + x ⇒ x &lt; y ⇒ ((0 = c + y) ⇔ F)
   
   [<a name="le_context_rwt4-val"><b>le_context_rwt4</b></a>]  Theorem
      
      ⊢ 0 ≤ c + x ⇒ x &lt; -y ⇒ ((0 = -c + y) ⇔ F)
   
   [<a name="le_context_rwt5-val"><b>le_context_rwt5</b></a>]  Theorem
      
      ⊢ 0 ≤ c + x ⇒ (0 ≤ -c + -x ⇔ (0 = c + x))
   
   [<a name="le_move_all_right-val"><b>le_move_all_right</b></a>]  Theorem
      
      ⊢ ∀x y. x ≤ y ⇔ 0 ≤ y + -x
   
   [<a name="le_move_right_left-val"><b>le_move_right_left</b></a>]  Theorem
      
      ⊢ ∀x y z. x ≤ y + z ⇔ x + -z ≤ y
   
   [<a name="less_to_leq_samel-val"><b>less_to_leq_samel</b></a>]  Theorem
      
      ⊢ ∀x y. x &lt; y ⇔ x ≤ y + -1
   
   [<a name="less_to_leq_samer-val"><b>less_to_leq_samer</b></a>]  Theorem
      
      ⊢ ∀x y. x &lt; y ⇔ x + 1 ≤ y
   
   [<a name="lt_justify_multiplication-val"><b>lt_justify_multiplication</b></a>]  Theorem
      
      ⊢ ∀n x y. 0 &lt; n ⇒ (x &lt; y ⇔ n * x &lt; n * y)
   
   [<a name="lt_move_all_left-val"><b>lt_move_all_left</b></a>]  Theorem
      
      ⊢ ∀x y. x &lt; y ⇔ x + -y &lt; 0
   
   [<a name="lt_move_all_right-val"><b>lt_move_all_right</b></a>]  Theorem
      
      ⊢ ∀x y. x &lt; y ⇔ 0 &lt; y + -x
   
   [<a name="lt_move_left_left-val"><b>lt_move_left_left</b></a>]  Theorem
      
      ⊢ ∀x y z. x &lt; y + z ⇔ x + -y &lt; z
   
   [<a name="lt_move_left_right-val"><b>lt_move_left_right</b></a>]  Theorem
      
      ⊢ ∀x y z. x + y &lt; z ⇔ y &lt; z + -x
   
   [<a name="move_sub-val"><b>move_sub</b></a>]  Theorem
      
      ⊢ ∀c b a. a − c + b = a + b − c
   
   [<a name="not_less-val"><b>not_less</b></a>]  Theorem
      
      ⊢ ¬(x &lt; y) ⇔ y &lt; x + 1
   
   [<a name="positive_product_implication-val"><b>positive_product_implication</b></a>]  Theorem
      
      ⊢ ∀c d. 0 &lt; c ∧ 0 &lt; d ⇒ 0 &lt; c * d
   
   [<a name="restricted_quantification_simp-val"><b>restricted_quantification_simp</b></a>]  Theorem
      
      ⊢ ∀low high x.
          low &lt; x ∧ x ≤ high ⇔
          low &lt; high ∧ ((x = high) ∨ low &lt; x ∧ x ≤ high − 1)
   
   [<a name="subtract_to_small-val"><b>subtract_to_small</b></a>]  Theorem
      
      ⊢ ∀x d. 0 &lt; d ⇒ ∃k. 0 &lt; x − k * d ∧ x − k * d ≤ d
   
   [<a name="top_and_lessers-val"><b>top_and_lessers</b></a>]  Theorem
      
      ⊢ ∀P d x0. (∀x. P x ⇒ P (x − d)) ∧ P x0 ⇒ ∀c. 0 &lt; c ⇒ P (x0 − c * d)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/integer/int_arithScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-1</a></em></p></body></html>
