<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure iterateTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure iterateTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/real/iterateScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature iterateTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#FINREC_def-val">FINREC_def</a> : thm
<a name="line7"></a>    val <a href="#from_def-val">from_def</a> : thm
<a name="line8"></a>    val <a href="#indicator-val">indicator</a> : thm
<a name="line9"></a>    val <a href="#iterate-val">iterate</a> : thm
<a name="line10"></a>    val <a href="#monoidal-val">monoidal</a> : thm
<a name="line11"></a>    val <a href="#neutral-val">neutral</a> : thm
<a name="line12"></a>    val <a href="#nproduct-val">nproduct</a> : thm
<a name="line13"></a>    val <a href="#nsum-val">nsum</a> : thm
<a name="line14"></a>    val <a href="#numseg-val">numseg</a> : thm
<a name="line15"></a>    val <a href="#polynomial_function-val">polynomial_function</a> : thm
<a name="line16"></a>    val <a href="#product-val">product</a> : thm
<a name="line17"></a>    val <a href="#sum_def-val">sum_def</a> : thm
<a name="line18"></a>    val <a href="#support-val">support</a> : thm
<a name="line19"></a>  
<a name="line20"></a>  (*  Theorems  *)
<a name="line21"></a>    val <a href="#ABS_LE_0-val">ABS_LE_0</a> : thm
<a name="line22"></a>    val <a href="#ABS_LE_HALF_POW2-val">ABS_LE_HALF_POW2</a> : thm
<a name="line23"></a>    val <a href="#ADD_SUB2-val">ADD_SUB2</a> : thm
<a name="line24"></a>    val <a href="#ADD_SUBR-val">ADD_SUBR</a> : thm
<a name="line25"></a>    val <a href="#ADD_SUBR2-val">ADD_SUBR2</a> : thm
<a name="line26"></a>    val <a href="#BIGINTER_BIGUNION-val">BIGINTER_BIGUNION</a> : thm
<a name="line27"></a>    val <a href="#BIGINTER_GSPEC-val">BIGINTER_GSPEC</a> : thm
<a name="line28"></a>    val <a href="#BIGUNION_BIGINTER-val">BIGUNION_BIGINTER</a> : thm
<a name="line29"></a>    val <a href="#BIGUNION_GSPEC-val">BIGUNION_GSPEC</a> : thm
<a name="line30"></a>    val <a href="#BOUNDS_LINEAR-val">BOUNDS_LINEAR</a> : thm
<a name="line31"></a>    val <a href="#BOUNDS_LINEAR_0-val">BOUNDS_LINEAR_0</a> : thm
<a name="line32"></a>    val <a href="#CARD_BIGUNION-val">CARD_BIGUNION</a> : thm
<a name="line33"></a>    val <a href="#CARD_EQ_NSUM-val">CARD_EQ_NSUM</a> : thm
<a name="line34"></a>    val <a href="#CARD_EQ_SUM-val">CARD_EQ_SUM</a> : thm
<a name="line35"></a>    val <a href="#CARD_NUMSEG-val">CARD_NUMSEG</a> : thm
<a name="line36"></a>    val <a href="#CARD_NUMSEG_1-val">CARD_NUMSEG_1</a> : thm
<a name="line37"></a>    val <a href="#CARD_NUMSEG_LEMMA-val">CARD_NUMSEG_LEMMA</a> : thm
<a name="line38"></a>    val <a href="#CARD_UNION_EQ-val">CARD_UNION_EQ</a> : thm
<a name="line39"></a>    val <a href="#CHOOSE_SUBSET-val">CHOOSE_SUBSET</a> : thm
<a name="line40"></a>    val <a href="#CHOOSE_SUBSET_STRONG-val">CHOOSE_SUBSET_STRONG</a> : thm
<a name="line41"></a>    val <a href="#COUNTABLE_FROM-val">COUNTABLE_FROM</a> : thm
<a name="line42"></a>    val <a href="#COUNT_NUMSEG-val">COUNT_NUMSEG</a> : thm
<a name="line43"></a>    val <a href="#DIFF_BIGINTER2-val">DIFF_BIGINTER2</a> : thm
<a name="line44"></a>    val <a href="#DISJOINT_COUNT_FROM-val">DISJOINT_COUNT_FROM</a> : thm
<a name="line45"></a>    val <a href="#DISJOINT_FROM_COUNT-val">DISJOINT_FROM_COUNT</a> : thm
<a name="line46"></a>    val <a href="#DISJOINT_NUMSEG-val">DISJOINT_NUMSEG</a> : thm
<a name="line47"></a>    val <a href="#DROP_INDICATOR-val">DROP_INDICATOR</a> : thm
<a name="line48"></a>    val <a href="#DROP_INDICATOR_ABS_LE_1-val">DROP_INDICATOR_ABS_LE_1</a> : thm
<a name="line49"></a>    val <a href="#DROP_INDICATOR_LE_1-val">DROP_INDICATOR_LE_1</a> : thm
<a name="line50"></a>    val <a href="#DROP_INDICATOR_POS_LE-val">DROP_INDICATOR_POS_LE</a> : thm
<a name="line51"></a>    val <a href="#EMPTY_BIGUNION-val">EMPTY_BIGUNION</a> : thm
<a name="line52"></a>    val <a href="#EXISTS_FINITE_SUBSET_IMAGE-val">EXISTS_FINITE_SUBSET_IMAGE</a> : thm
<a name="line53"></a>    val <a href="#FINITE_INDEX_NUMBERS-val">FINITE_INDEX_NUMBERS</a> : thm
<a name="line54"></a>    val <a href="#FINITE_INDEX_NUMSEG-val">FINITE_INDEX_NUMSEG</a> : thm
<a name="line55"></a>    val <a href="#FINITE_NUMSEG-val">FINITE_NUMSEG</a> : thm
<a name="line56"></a>    val <a href="#FINITE_POWERSET-val">FINITE_POWERSET</a> : thm
<a name="line57"></a>    val <a href="#FINITE_REAL_INTERVAL-val">FINITE_REAL_INTERVAL</a> : thm
<a name="line58"></a>    val <a href="#FINITE_RECURSION-val">FINITE_RECURSION</a> : thm
<a name="line59"></a>    val <a href="#FINITE_RESTRICT-val">FINITE_RESTRICT</a> : thm
<a name="line60"></a>    val <a href="#FINITE_SUBSET_IMAGE-val">FINITE_SUBSET_IMAGE</a> : thm
<a name="line61"></a>    val <a href="#FINITE_SUPPORT-val">FINITE_SUPPORT</a> : thm
<a name="line62"></a>    val <a href="#FINITE_SUPPORT_DELTA-val">FINITE_SUPPORT_DELTA</a> : thm
<a name="line63"></a>    val <a href="#FINREC_1_LEMMA-val">FINREC_1_LEMMA</a> : thm
<a name="line64"></a>    val <a href="#FINREC_EXISTS_LEMMA-val">FINREC_EXISTS_LEMMA</a> : thm
<a name="line65"></a>    val <a href="#FINREC_FUN-val">FINREC_FUN</a> : thm
<a name="line66"></a>    val <a href="#FINREC_FUN_LEMMA-val">FINREC_FUN_LEMMA</a> : thm
<a name="line67"></a>    val <a href="#FINREC_SUC_LEMMA-val">FINREC_SUC_LEMMA</a> : thm
<a name="line68"></a>    val <a href="#FINREC_UNIQUE_LEMMA-val">FINREC_UNIQUE_LEMMA</a> : thm
<a name="line69"></a>    val <a href="#FINREC_compute-val">FINREC_compute</a> : thm
<a name="line70"></a>    val <a href="#FORALL_FINITE_SUBSET_IMAGE-val">FORALL_FINITE_SUBSET_IMAGE</a> : thm
<a name="line71"></a>    val <a href="#FROM_0-val">FROM_0</a> : thm
<a name="line72"></a>    val <a href="#FROM_INTER_NUMSEG-val">FROM_INTER_NUMSEG</a> : thm
<a name="line73"></a>    val <a href="#FROM_INTER_NUMSEG_GEN-val">FROM_INTER_NUMSEG_GEN</a> : thm
<a name="line74"></a>    val <a href="#FROM_INTER_NUMSEG_MAX-val">FROM_INTER_NUMSEG_MAX</a> : thm
<a name="line75"></a>    val <a href="#FROM_NOT_EMPTY-val">FROM_NOT_EMPTY</a> : thm
<a name="line76"></a>    val <a href="#FUN_IN_IMAGE-val">FUN_IN_IMAGE</a> : thm
<a name="line77"></a>    val <a href="#HAS_SIZE_NUMSEG-val">HAS_SIZE_NUMSEG</a> : thm
<a name="line78"></a>    val <a href="#HAS_SIZE_NUMSEG_1-val">HAS_SIZE_NUMSEG_1</a> : thm
<a name="line79"></a>    val <a href="#INDICATOR_COMPLEMENT-val">INDICATOR_COMPLEMENT</a> : thm
<a name="line80"></a>    val <a href="#INDICATOR_EMPTY-val">INDICATOR_EMPTY</a> : thm
<a name="line81"></a>    val <a href="#INF-val">INF</a> : thm
<a name="line82"></a>    val <a href="#INFINITE_FROM-val">INFINITE_FROM</a> : thm
<a name="line83"></a>    val <a href="#INF_CLOSE-val">INF_CLOSE</a> : thm
<a name="line84"></a>    val <a href="#INF_DEF_ALT-val">INF_DEF_ALT</a> : thm
<a name="line85"></a>    val <a href="#INF_EQ-val">INF_EQ</a> : thm
<a name="line86"></a>    val <a href="#INF_FINITE-val">INF_FINITE</a> : thm
<a name="line87"></a>    val <a href="#INF_FINITE_LEMMA-val">INF_FINITE_LEMMA</a> : thm
<a name="line88"></a>    val <a href="#INF_GREATER-val">INF_GREATER</a> : thm
<a name="line89"></a>    val <a href="#INF_INSERT_FINITE-val">INF_INSERT_FINITE</a> : thm
<a name="line90"></a>    val <a href="#INF_LE-val">INF_LE</a> : thm
<a name="line91"></a>    val <a href="#INF_SING-val">INF_SING</a> : thm
<a name="line92"></a>    val <a href="#INF_UNIQUE_FINITE-val">INF_UNIQUE_FINITE</a> : thm
<a name="line93"></a>    val <a href="#IN_FROM-val">IN_FROM</a> : thm
<a name="line94"></a>    val <a href="#IN_NUMSEG-val">IN_NUMSEG</a> : thm
<a name="line95"></a>    val <a href="#IN_NUMSEG_0-val">IN_NUMSEG_0</a> : thm
<a name="line96"></a>    val <a href="#IN_SUPPORT-val">IN_SUPPORT</a> : thm
<a name="line97"></a>    val <a href="#ITERATE_AND-val">ITERATE_AND</a> : thm
<a name="line98"></a>    val <a href="#ITERATE_BIJECTION-val">ITERATE_BIJECTION</a> : thm
<a name="line99"></a>    val <a href="#ITERATE_CASES-val">ITERATE_CASES</a> : thm
<a name="line100"></a>    val <a href="#ITERATE_CLAUSES-val">ITERATE_CLAUSES</a> : thm
<a name="line101"></a>    val <a href="#ITERATE_CLAUSES_GEN-val">ITERATE_CLAUSES_GEN</a> : thm
<a name="line102"></a>    val <a href="#ITERATE_CLAUSES_NUMSEG-val">ITERATE_CLAUSES_NUMSEG</a> : thm
<a name="line103"></a>    val <a href="#ITERATE_CLOSED-val">ITERATE_CLOSED</a> : thm
<a name="line104"></a>    val <a href="#ITERATE_DELETE-val">ITERATE_DELETE</a> : thm
<a name="line105"></a>    val <a href="#ITERATE_DELTA-val">ITERATE_DELTA</a> : thm
<a name="line106"></a>    val <a href="#ITERATE_DIFF-val">ITERATE_DIFF</a> : thm
<a name="line107"></a>    val <a href="#ITERATE_DIFF_GEN-val">ITERATE_DIFF_GEN</a> : thm
<a name="line108"></a>    val <a href="#ITERATE_EQ-val">ITERATE_EQ</a> : thm
<a name="line109"></a>    val <a href="#ITERATE_EQ_GENERAL-val">ITERATE_EQ_GENERAL</a> : thm
<a name="line110"></a>    val <a href="#ITERATE_EQ_GENERAL_INVERSES-val">ITERATE_EQ_GENERAL_INVERSES</a> : thm
<a name="line111"></a>    val <a href="#ITERATE_EQ_NEUTRAL-val">ITERATE_EQ_NEUTRAL</a> : thm
<a name="line112"></a>    val <a href="#ITERATE_EXPAND_CASES-val">ITERATE_EXPAND_CASES</a> : thm
<a name="line113"></a>    val <a href="#ITERATE_IMAGE-val">ITERATE_IMAGE</a> : thm
<a name="line114"></a>    val <a href="#ITERATE_IMAGE_NONZERO-val">ITERATE_IMAGE_NONZERO</a> : thm
<a name="line115"></a>    val <a href="#ITERATE_INCL_EXCL-val">ITERATE_INCL_EXCL</a> : thm
<a name="line116"></a>    val <a href="#ITERATE_INJECTION-val">ITERATE_INJECTION</a> : thm
<a name="line117"></a>    val <a href="#ITERATE_ITERATE_PRODUCT-val">ITERATE_ITERATE_PRODUCT</a> : thm
<a name="line118"></a>    val <a href="#ITERATE_NONZERO_IMAGE_LEMMA-val">ITERATE_NONZERO_IMAGE_LEMMA</a> : thm
<a name="line119"></a>    val <a href="#ITERATE_OP-val">ITERATE_OP</a> : thm
<a name="line120"></a>    val <a href="#ITERATE_OP_GEN-val">ITERATE_OP_GEN</a> : thm
<a name="line121"></a>    val <a href="#ITERATE_PAIR-val">ITERATE_PAIR</a> : thm
<a name="line122"></a>    val <a href="#ITERATE_PERMUTE-val">ITERATE_PERMUTE</a> : thm
<a name="line123"></a>    val <a href="#ITERATE_PERMUTES-val">ITERATE_PERMUTES</a> : thm
<a name="line124"></a>    val <a href="#ITERATE_RELATED-val">ITERATE_RELATED</a> : thm
<a name="line125"></a>    val <a href="#ITERATE_SING-val">ITERATE_SING</a> : thm
<a name="line126"></a>    val <a href="#ITERATE_SOME-val">ITERATE_SOME</a> : thm
<a name="line127"></a>    val <a href="#ITERATE_SUPERSET-val">ITERATE_SUPERSET</a> : thm
<a name="line128"></a>    val <a href="#ITERATE_SUPPORT-val">ITERATE_SUPPORT</a> : thm
<a name="line129"></a>    val <a href="#ITERATE_UNION-val">ITERATE_UNION</a> : thm
<a name="line130"></a>    val <a href="#ITERATE_UNION_GEN-val">ITERATE_UNION_GEN</a> : thm
<a name="line131"></a>    val <a href="#ITERATE_UNION_NONZERO-val">ITERATE_UNION_NONZERO</a> : thm
<a name="line132"></a>    val <a href="#ITSET_alt-val">ITSET_alt</a> : thm
<a name="line133"></a>    val <a href="#LAMBDA_PAIR-val">LAMBDA_PAIR</a> : thm
<a name="line134"></a>    val <a href="#LE_ADD-val">LE_ADD</a> : thm
<a name="line135"></a>    val <a href="#LE_ADDR-val">LE_ADDR</a> : thm
<a name="line136"></a>    val <a href="#LE_EXISTS-val">LE_EXISTS</a> : thm
<a name="line137"></a>    val <a href="#LE_INF-val">LE_INF</a> : thm
<a name="line138"></a>    val <a href="#LOWER_BOUND_FINITE_SET_REAL-val">LOWER_BOUND_FINITE_SET_REAL</a> : thm
<a name="line139"></a>    val <a href="#LT_EXISTS-val">LT_EXISTS</a> : thm
<a name="line140"></a>    val <a href="#MOD_NSUM_MOD-val">MOD_NSUM_MOD</a> : thm
<a name="line141"></a>    val <a href="#MOD_NSUM_MOD_NUMSEG-val">MOD_NSUM_MOD_NUMSEG</a> : thm
<a name="line142"></a>    val <a href="#MONOIDAL_AC-val">MONOIDAL_AC</a> : thm
<a name="line143"></a>    val <a href="#MONOIDAL_ADD-val">MONOIDAL_ADD</a> : thm
<a name="line144"></a>    val <a href="#MONOIDAL_AND-val">MONOIDAL_AND</a> : thm
<a name="line145"></a>    val <a href="#MONOIDAL_LIFTED-val">MONOIDAL_LIFTED</a> : thm
<a name="line146"></a>    val <a href="#MONOIDAL_MUL-val">MONOIDAL_MUL</a> : thm
<a name="line147"></a>    val <a href="#MONOIDAL_REAL_ADD-val">MONOIDAL_REAL_ADD</a> : thm
<a name="line148"></a>    val <a href="#MONOIDAL_REAL_MUL-val">MONOIDAL_REAL_MUL</a> : thm
<a name="line149"></a>    val <a href="#NEUTRAL_ADD-val">NEUTRAL_ADD</a> : thm
<a name="line150"></a>    val <a href="#NEUTRAL_AND-val">NEUTRAL_AND</a> : thm
<a name="line151"></a>    val <a href="#NEUTRAL_LIFTED-val">NEUTRAL_LIFTED</a> : thm
<a name="line152"></a>    val <a href="#NEUTRAL_MUL-val">NEUTRAL_MUL</a> : thm
<a name="line153"></a>    val <a href="#NEUTRAL_REAL_ADD-val">NEUTRAL_REAL_ADD</a> : thm
<a name="line154"></a>    val <a href="#NEUTRAL_REAL_MUL-val">NEUTRAL_REAL_MUL</a> : thm
<a name="line155"></a>    val <a href="#NOT_EQ-val">NOT_EQ</a> : thm
<a name="line156"></a>    val <a href="#NPRODUCT_ADD_SPLIT-val">NPRODUCT_ADD_SPLIT</a> : thm
<a name="line157"></a>    val <a href="#NPRODUCT_CLAUSES-val">NPRODUCT_CLAUSES</a> : thm
<a name="line158"></a>    val <a href="#NPRODUCT_CLAUSES_LEFT-val">NPRODUCT_CLAUSES_LEFT</a> : thm
<a name="line159"></a>    val <a href="#NPRODUCT_CLAUSES_NUMSEG-val">NPRODUCT_CLAUSES_NUMSEG</a> : thm
<a name="line160"></a>    val <a href="#NPRODUCT_CLAUSES_RIGHT-val">NPRODUCT_CLAUSES_RIGHT</a> : thm
<a name="line161"></a>    val <a href="#NPRODUCT_CLOSED-val">NPRODUCT_CLOSED</a> : thm
<a name="line162"></a>    val <a href="#NPRODUCT_CONG-val">NPRODUCT_CONG</a> : thm
<a name="line163"></a>    val <a href="#NPRODUCT_CONST-val">NPRODUCT_CONST</a> : thm
<a name="line164"></a>    val <a href="#NPRODUCT_CONST_NUMSEG-val">NPRODUCT_CONST_NUMSEG</a> : thm
<a name="line165"></a>    val <a href="#NPRODUCT_CONST_NUMSEG_1-val">NPRODUCT_CONST_NUMSEG_1</a> : thm
<a name="line166"></a>    val <a href="#NPRODUCT_DELETE-val">NPRODUCT_DELETE</a> : thm
<a name="line167"></a>    val <a href="#NPRODUCT_DELTA-val">NPRODUCT_DELTA</a> : thm
<a name="line168"></a>    val <a href="#NPRODUCT_EQ-val">NPRODUCT_EQ</a> : thm
<a name="line169"></a>    val <a href="#NPRODUCT_EQ_0-val">NPRODUCT_EQ_0</a> : thm
<a name="line170"></a>    val <a href="#NPRODUCT_EQ_0_NUMSEG-val">NPRODUCT_EQ_0_NUMSEG</a> : thm
<a name="line171"></a>    val <a href="#NPRODUCT_EQ_1-val">NPRODUCT_EQ_1</a> : thm
<a name="line172"></a>    val <a href="#NPRODUCT_EQ_1_NUMSEG-val">NPRODUCT_EQ_1_NUMSEG</a> : thm
<a name="line173"></a>    val <a href="#NPRODUCT_EQ_NUMSEG-val">NPRODUCT_EQ_NUMSEG</a> : thm
<a name="line174"></a>    val <a href="#NPRODUCT_FACT-val">NPRODUCT_FACT</a> : thm
<a name="line175"></a>    val <a href="#NPRODUCT_IMAGE-val">NPRODUCT_IMAGE</a> : thm
<a name="line176"></a>    val <a href="#NPRODUCT_LE-val">NPRODUCT_LE</a> : thm
<a name="line177"></a>    val <a href="#NPRODUCT_LE_NUMSEG-val">NPRODUCT_LE_NUMSEG</a> : thm
<a name="line178"></a>    val <a href="#NPRODUCT_MUL-val">NPRODUCT_MUL</a> : thm
<a name="line179"></a>    val <a href="#NPRODUCT_MUL_GEN-val">NPRODUCT_MUL_GEN</a> : thm
<a name="line180"></a>    val <a href="#NPRODUCT_MUL_NUMSEG-val">NPRODUCT_MUL_NUMSEG</a> : thm
<a name="line181"></a>    val <a href="#NPRODUCT_OFFSET-val">NPRODUCT_OFFSET</a> : thm
<a name="line182"></a>    val <a href="#NPRODUCT_ONE-val">NPRODUCT_ONE</a> : thm
<a name="line183"></a>    val <a href="#NPRODUCT_PAIR-val">NPRODUCT_PAIR</a> : thm
<a name="line184"></a>    val <a href="#NPRODUCT_POS_LT-val">NPRODUCT_POS_LT</a> : thm
<a name="line185"></a>    val <a href="#NPRODUCT_POS_LT_NUMSEG-val">NPRODUCT_POS_LT_NUMSEG</a> : thm
<a name="line186"></a>    val <a href="#NPRODUCT_SING-val">NPRODUCT_SING</a> : thm
<a name="line187"></a>    val <a href="#NPRODUCT_SING_NUMSEG-val">NPRODUCT_SING_NUMSEG</a> : thm
<a name="line188"></a>    val <a href="#NPRODUCT_SUPERSET-val">NPRODUCT_SUPERSET</a> : thm
<a name="line189"></a>    val <a href="#NPRODUCT_SUPPORT-val">NPRODUCT_SUPPORT</a> : thm
<a name="line190"></a>    val <a href="#NPRODUCT_UNION-val">NPRODUCT_UNION</a> : thm
<a name="line191"></a>    val <a href="#NSUM_0-val">NSUM_0</a> : thm
<a name="line192"></a>    val <a href="#NSUM_ADD-val">NSUM_ADD</a> : thm
<a name="line193"></a>    val <a href="#NSUM_ADD_GEN-val">NSUM_ADD_GEN</a> : thm
<a name="line194"></a>    val <a href="#NSUM_ADD_NUMSEG-val">NSUM_ADD_NUMSEG</a> : thm
<a name="line195"></a>    val <a href="#NSUM_ADD_SPLIT-val">NSUM_ADD_SPLIT</a> : thm
<a name="line196"></a>    val <a href="#NSUM_BIGUNION_NONZERO-val">NSUM_BIGUNION_NONZERO</a> : thm
<a name="line197"></a>    val <a href="#NSUM_BIJECTION-val">NSUM_BIJECTION</a> : thm
<a name="line198"></a>    val <a href="#NSUM_BOUND-val">NSUM_BOUND</a> : thm
<a name="line199"></a>    val <a href="#NSUM_BOUND_GEN-val">NSUM_BOUND_GEN</a> : thm
<a name="line200"></a>    val <a href="#NSUM_BOUND_LT-val">NSUM_BOUND_LT</a> : thm
<a name="line201"></a>    val <a href="#NSUM_BOUND_LT_ALL-val">NSUM_BOUND_LT_ALL</a> : thm
<a name="line202"></a>    val <a href="#NSUM_BOUND_LT_GEN-val">NSUM_BOUND_LT_GEN</a> : thm
<a name="line203"></a>    val <a href="#NSUM_CASES-val">NSUM_CASES</a> : thm
<a name="line204"></a>    val <a href="#NSUM_CLAUSES-val">NSUM_CLAUSES</a> : thm
<a name="line205"></a>    val <a href="#NSUM_CLAUSES_LEFT-val">NSUM_CLAUSES_LEFT</a> : thm
<a name="line206"></a>    val <a href="#NSUM_CLAUSES_NUMSEG-val">NSUM_CLAUSES_NUMSEG</a> : thm
<a name="line207"></a>    val <a href="#NSUM_CLAUSES_RIGHT-val">NSUM_CLAUSES_RIGHT</a> : thm
<a name="line208"></a>    val <a href="#NSUM_CLOSED-val">NSUM_CLOSED</a> : thm
<a name="line209"></a>    val <a href="#NSUM_CONG-val">NSUM_CONG</a> : thm
<a name="line210"></a>    val <a href="#NSUM_CONST-val">NSUM_CONST</a> : thm
<a name="line211"></a>    val <a href="#NSUM_CONST_NUMSEG-val">NSUM_CONST_NUMSEG</a> : thm
<a name="line212"></a>    val <a href="#NSUM_DEGENERATE-val">NSUM_DEGENERATE</a> : thm
<a name="line213"></a>    val <a href="#NSUM_DELETE-val">NSUM_DELETE</a> : thm
<a name="line214"></a>    val <a href="#NSUM_DELTA-val">NSUM_DELTA</a> : thm
<a name="line215"></a>    val <a href="#NSUM_DIFF-val">NSUM_DIFF</a> : thm
<a name="line216"></a>    val <a href="#NSUM_EQ-val">NSUM_EQ</a> : thm
<a name="line217"></a>    val <a href="#NSUM_EQ_0-val">NSUM_EQ_0</a> : thm
<a name="line218"></a>    val <a href="#NSUM_EQ_0_IFF-val">NSUM_EQ_0_IFF</a> : thm
<a name="line219"></a>    val <a href="#NSUM_EQ_0_IFF_NUMSEG-val">NSUM_EQ_0_IFF_NUMSEG</a> : thm
<a name="line220"></a>    val <a href="#NSUM_EQ_0_NUMSEG-val">NSUM_EQ_0_NUMSEG</a> : thm
<a name="line221"></a>    val <a href="#NSUM_EQ_GENERAL-val">NSUM_EQ_GENERAL</a> : thm
<a name="line222"></a>    val <a href="#NSUM_EQ_GENERAL_INVERSES-val">NSUM_EQ_GENERAL_INVERSES</a> : thm
<a name="line223"></a>    val <a href="#NSUM_EQ_NUMSEG-val">NSUM_EQ_NUMSEG</a> : thm
<a name="line224"></a>    val <a href="#NSUM_EQ_SUPERSET-val">NSUM_EQ_SUPERSET</a> : thm
<a name="line225"></a>    val <a href="#NSUM_GROUP-val">NSUM_GROUP</a> : thm
<a name="line226"></a>    val <a href="#NSUM_IMAGE-val">NSUM_IMAGE</a> : thm
<a name="line227"></a>    val <a href="#NSUM_IMAGE_GEN-val">NSUM_IMAGE_GEN</a> : thm
<a name="line228"></a>    val <a href="#NSUM_IMAGE_NONZERO-val">NSUM_IMAGE_NONZERO</a> : thm
<a name="line229"></a>    val <a href="#NSUM_INCL_EXCL-val">NSUM_INCL_EXCL</a> : thm
<a name="line230"></a>    val <a href="#NSUM_INJECTION-val">NSUM_INJECTION</a> : thm
<a name="line231"></a>    val <a href="#NSUM_LE-val">NSUM_LE</a> : thm
<a name="line232"></a>    val <a href="#NSUM_LE_GEN-val">NSUM_LE_GEN</a> : thm
<a name="line233"></a>    val <a href="#NSUM_LE_NUMSEG-val">NSUM_LE_NUMSEG</a> : thm
<a name="line234"></a>    val <a href="#NSUM_LMUL-val">NSUM_LMUL</a> : thm
<a name="line235"></a>    val <a href="#NSUM_LT-val">NSUM_LT</a> : thm
<a name="line236"></a>    val <a href="#NSUM_LT_ALL-val">NSUM_LT_ALL</a> : thm
<a name="line237"></a>    val <a href="#NSUM_MULTICOUNT-val">NSUM_MULTICOUNT</a> : thm
<a name="line238"></a>    val <a href="#NSUM_MULTICOUNT_GEN-val">NSUM_MULTICOUNT_GEN</a> : thm
<a name="line239"></a>    val <a href="#NSUM_NSUM_PRODUCT-val">NSUM_NSUM_PRODUCT</a> : thm
<a name="line240"></a>    val <a href="#NSUM_NSUM_RESTRICT-val">NSUM_NSUM_RESTRICT</a> : thm
<a name="line241"></a>    val <a href="#NSUM_OFFSET-val">NSUM_OFFSET</a> : thm
<a name="line242"></a>    val <a href="#NSUM_OFFSET_0-val">NSUM_OFFSET_0</a> : thm
<a name="line243"></a>    val <a href="#NSUM_PAIR-val">NSUM_PAIR</a> : thm
<a name="line244"></a>    val <a href="#NSUM_PERMUTE-val">NSUM_PERMUTE</a> : thm
<a name="line245"></a>    val <a href="#NSUM_PERMUTE_COUNT-val">NSUM_PERMUTE_COUNT</a> : thm
<a name="line246"></a>    val <a href="#NSUM_PERMUTE_NUMSEG-val">NSUM_PERMUTE_NUMSEG</a> : thm
<a name="line247"></a>    val <a href="#NSUM_POS_BOUND-val">NSUM_POS_BOUND</a> : thm
<a name="line248"></a>    val <a href="#NSUM_POS_LT-val">NSUM_POS_LT</a> : thm
<a name="line249"></a>    val <a href="#NSUM_POS_LT_ALL-val">NSUM_POS_LT_ALL</a> : thm
<a name="line250"></a>    val <a href="#NSUM_RESTRICT-val">NSUM_RESTRICT</a> : thm
<a name="line251"></a>    val <a href="#NSUM_RESTRICT_SET-val">NSUM_RESTRICT_SET</a> : thm
<a name="line252"></a>    val <a href="#NSUM_RMUL-val">NSUM_RMUL</a> : thm
<a name="line253"></a>    val <a href="#NSUM_SING-val">NSUM_SING</a> : thm
<a name="line254"></a>    val <a href="#NSUM_SING_NUMSEG-val">NSUM_SING_NUMSEG</a> : thm
<a name="line255"></a>    val <a href="#NSUM_SUBSET-val">NSUM_SUBSET</a> : thm
<a name="line256"></a>    val <a href="#NSUM_SUBSET_SIMPLE-val">NSUM_SUBSET_SIMPLE</a> : thm
<a name="line257"></a>    val <a href="#NSUM_SUPERSET-val">NSUM_SUPERSET</a> : thm
<a name="line258"></a>    val <a href="#NSUM_SUPPORT-val">NSUM_SUPPORT</a> : thm
<a name="line259"></a>    val <a href="#NSUM_SWAP-val">NSUM_SWAP</a> : thm
<a name="line260"></a>    val <a href="#NSUM_SWAP_NUMSEG-val">NSUM_SWAP_NUMSEG</a> : thm
<a name="line261"></a>    val <a href="#NSUM_TRIV_NUMSEG-val">NSUM_TRIV_NUMSEG</a> : thm
<a name="line262"></a>    val <a href="#NSUM_UNION-val">NSUM_UNION</a> : thm
<a name="line263"></a>    val <a href="#NSUM_UNION_EQ-val">NSUM_UNION_EQ</a> : thm
<a name="line264"></a>    val <a href="#NSUM_UNION_LZERO-val">NSUM_UNION_LZERO</a> : thm
<a name="line265"></a>    val <a href="#NSUM_UNION_NONZERO-val">NSUM_UNION_NONZERO</a> : thm
<a name="line266"></a>    val <a href="#NSUM_UNION_RZERO-val">NSUM_UNION_RZERO</a> : thm
<a name="line267"></a>    val <a href="#NUMSEG_ADD_SPLIT-val">NUMSEG_ADD_SPLIT</a> : thm
<a name="line268"></a>    val <a href="#NUMSEG_CLAUSES-val">NUMSEG_CLAUSES</a> : thm
<a name="line269"></a>    val <a href="#NUMSEG_COMBINE_L-val">NUMSEG_COMBINE_L</a> : thm
<a name="line270"></a>    val <a href="#NUMSEG_COMBINE_R-val">NUMSEG_COMBINE_R</a> : thm
<a name="line271"></a>    val <a href="#NUMSEG_EMPTY-val">NUMSEG_EMPTY</a> : thm
<a name="line272"></a>    val <a href="#NUMSEG_LE-val">NUMSEG_LE</a> : thm
<a name="line273"></a>    val <a href="#NUMSEG_LREC-val">NUMSEG_LREC</a> : thm
<a name="line274"></a>    val <a href="#NUMSEG_LT-val">NUMSEG_LT</a> : thm
<a name="line275"></a>    val <a href="#NUMSEG_OFFSET_IMAGE-val">NUMSEG_OFFSET_IMAGE</a> : thm
<a name="line276"></a>    val <a href="#NUMSEG_REC-val">NUMSEG_REC</a> : thm
<a name="line277"></a>    val <a href="#NUMSEG_RREC-val">NUMSEG_RREC</a> : thm
<a name="line278"></a>    val <a href="#NUMSEG_SING-val">NUMSEG_SING</a> : thm
<a name="line279"></a>    val <a href="#PERMUTES_IN_NUMSEG-val">PERMUTES_IN_NUMSEG</a> : thm
<a name="line280"></a>    val <a href="#POLYNOMIAL_FUNCTION_ADD-val">POLYNOMIAL_FUNCTION_ADD</a> : thm
<a name="line281"></a>    val <a href="#POLYNOMIAL_FUNCTION_CONST-val">POLYNOMIAL_FUNCTION_CONST</a> : thm
<a name="line282"></a>    val <a href="#POLYNOMIAL_FUNCTION_FINITE_ROOTS-val">POLYNOMIAL_FUNCTION_FINITE_ROOTS</a> : thm
<a name="line283"></a>    val <a href="#POLYNOMIAL_FUNCTION_ID-val">POLYNOMIAL_FUNCTION_ID</a> : thm
<a name="line284"></a>    val <a href="#POLYNOMIAL_FUNCTION_INDUCT-val">POLYNOMIAL_FUNCTION_INDUCT</a> : thm
<a name="line285"></a>    val <a href="#POLYNOMIAL_FUNCTION_LMUL-val">POLYNOMIAL_FUNCTION_LMUL</a> : thm
<a name="line286"></a>    val <a href="#POLYNOMIAL_FUNCTION_MUL-val">POLYNOMIAL_FUNCTION_MUL</a> : thm
<a name="line287"></a>    val <a href="#POLYNOMIAL_FUNCTION_NEG-val">POLYNOMIAL_FUNCTION_NEG</a> : thm
<a name="line288"></a>    val <a href="#POLYNOMIAL_FUNCTION_POW-val">POLYNOMIAL_FUNCTION_POW</a> : thm
<a name="line289"></a>    val <a href="#POLYNOMIAL_FUNCTION_RMUL-val">POLYNOMIAL_FUNCTION_RMUL</a> : thm
<a name="line290"></a>    val <a href="#POLYNOMIAL_FUNCTION_SUB-val">POLYNOMIAL_FUNCTION_SUB</a> : thm
<a name="line291"></a>    val <a href="#POLYNOMIAL_FUNCTION_SUM-val">POLYNOMIAL_FUNCTION_SUM</a> : thm
<a name="line292"></a>    val <a href="#POLYNOMIAL_FUNCTION_o-val">POLYNOMIAL_FUNCTION_o</a> : thm
<a name="line293"></a>    val <a href="#POWERSET_CLAUSES-val">POWERSET_CLAUSES</a> : thm
<a name="line294"></a>    val <a href="#POW_NEG_ODD-val">POW_NEG_ODD</a> : thm
<a name="line295"></a>    val <a href="#POW_POS_EVEN-val">POW_POS_EVEN</a> : thm
<a name="line296"></a>    val <a href="#PRODUCT_ABS-val">PRODUCT_ABS</a> : thm
<a name="line297"></a>    val <a href="#PRODUCT_ADD_SPLIT-val">PRODUCT_ADD_SPLIT</a> : thm
<a name="line298"></a>    val <a href="#PRODUCT_CLAUSES-val">PRODUCT_CLAUSES</a> : thm
<a name="line299"></a>    val <a href="#PRODUCT_CLAUSES_LEFT-val">PRODUCT_CLAUSES_LEFT</a> : thm
<a name="line300"></a>    val <a href="#PRODUCT_CLAUSES_NUMSEG-val">PRODUCT_CLAUSES_NUMSEG</a> : thm
<a name="line301"></a>    val <a href="#PRODUCT_CLAUSES_RIGHT-val">PRODUCT_CLAUSES_RIGHT</a> : thm
<a name="line302"></a>    val <a href="#PRODUCT_CLOSED-val">PRODUCT_CLOSED</a> : thm
<a name="line303"></a>    val <a href="#PRODUCT_CONG-val">PRODUCT_CONG</a> : thm
<a name="line304"></a>    val <a href="#PRODUCT_CONST-val">PRODUCT_CONST</a> : thm
<a name="line305"></a>    val <a href="#PRODUCT_CONST_NUMSEG-val">PRODUCT_CONST_NUMSEG</a> : thm
<a name="line306"></a>    val <a href="#PRODUCT_CONST_NUMSEG_1-val">PRODUCT_CONST_NUMSEG_1</a> : thm
<a name="line307"></a>    val <a href="#PRODUCT_DELETE-val">PRODUCT_DELETE</a> : thm
<a name="line308"></a>    val <a href="#PRODUCT_DELTA-val">PRODUCT_DELTA</a> : thm
<a name="line309"></a>    val <a href="#PRODUCT_DIV-val">PRODUCT_DIV</a> : thm
<a name="line310"></a>    val <a href="#PRODUCT_DIV_NUMSEG-val">PRODUCT_DIV_NUMSEG</a> : thm
<a name="line311"></a>    val <a href="#PRODUCT_EQ-val">PRODUCT_EQ</a> : thm
<a name="line312"></a>    val <a href="#PRODUCT_EQ_0-val">PRODUCT_EQ_0</a> : thm
<a name="line313"></a>    val <a href="#PRODUCT_EQ_0_COUNT-val">PRODUCT_EQ_0_COUNT</a> : thm
<a name="line314"></a>    val <a href="#PRODUCT_EQ_0_NUMSEG-val">PRODUCT_EQ_0_NUMSEG</a> : thm
<a name="line315"></a>    val <a href="#PRODUCT_EQ_1-val">PRODUCT_EQ_1</a> : thm
<a name="line316"></a>    val <a href="#PRODUCT_EQ_1_COUNT-val">PRODUCT_EQ_1_COUNT</a> : thm
<a name="line317"></a>    val <a href="#PRODUCT_EQ_1_NUMSEG-val">PRODUCT_EQ_1_NUMSEG</a> : thm
<a name="line318"></a>    val <a href="#PRODUCT_EQ_COUNT-val">PRODUCT_EQ_COUNT</a> : thm
<a name="line319"></a>    val <a href="#PRODUCT_EQ_NUMSEG-val">PRODUCT_EQ_NUMSEG</a> : thm
<a name="line320"></a>    val <a href="#PRODUCT_IMAGE-val">PRODUCT_IMAGE</a> : thm
<a name="line321"></a>    val <a href="#PRODUCT_INV-val">PRODUCT_INV</a> : thm
<a name="line322"></a>    val <a href="#PRODUCT_LE-val">PRODUCT_LE</a> : thm
<a name="line323"></a>    val <a href="#PRODUCT_LE_1-val">PRODUCT_LE_1</a> : thm
<a name="line324"></a>    val <a href="#PRODUCT_LE_NUMSEG-val">PRODUCT_LE_NUMSEG</a> : thm
<a name="line325"></a>    val <a href="#PRODUCT_MUL-val">PRODUCT_MUL</a> : thm
<a name="line326"></a>    val <a href="#PRODUCT_MUL_COUNT-val">PRODUCT_MUL_COUNT</a> : thm
<a name="line327"></a>    val <a href="#PRODUCT_MUL_GEN-val">PRODUCT_MUL_GEN</a> : thm
<a name="line328"></a>    val <a href="#PRODUCT_MUL_NUMSEG-val">PRODUCT_MUL_NUMSEG</a> : thm
<a name="line329"></a>    val <a href="#PRODUCT_NEG-val">PRODUCT_NEG</a> : thm
<a name="line330"></a>    val <a href="#PRODUCT_NEG_NUMSEG-val">PRODUCT_NEG_NUMSEG</a> : thm
<a name="line331"></a>    val <a href="#PRODUCT_NEG_NUMSEG_1-val">PRODUCT_NEG_NUMSEG_1</a> : thm
<a name="line332"></a>    val <a href="#PRODUCT_OFFSET-val">PRODUCT_OFFSET</a> : thm
<a name="line333"></a>    val <a href="#PRODUCT_ONE-val">PRODUCT_ONE</a> : thm
<a name="line334"></a>    val <a href="#PRODUCT_PAIR-val">PRODUCT_PAIR</a> : thm
<a name="line335"></a>    val <a href="#PRODUCT_PERMUTE-val">PRODUCT_PERMUTE</a> : thm
<a name="line336"></a>    val <a href="#PRODUCT_PERMUTE_COUNT-val">PRODUCT_PERMUTE_COUNT</a> : thm
<a name="line337"></a>    val <a href="#PRODUCT_PERMUTE_NUMSEG-val">PRODUCT_PERMUTE_NUMSEG</a> : thm
<a name="line338"></a>    val <a href="#PRODUCT_POS_LE-val">PRODUCT_POS_LE</a> : thm
<a name="line339"></a>    val <a href="#PRODUCT_POS_LE_NUMSEG-val">PRODUCT_POS_LE_NUMSEG</a> : thm
<a name="line340"></a>    val <a href="#PRODUCT_POS_LT-val">PRODUCT_POS_LT</a> : thm
<a name="line341"></a>    val <a href="#PRODUCT_POS_LT_NUMSEG-val">PRODUCT_POS_LT_NUMSEG</a> : thm
<a name="line342"></a>    val <a href="#PRODUCT_SING-val">PRODUCT_SING</a> : thm
<a name="line343"></a>    val <a href="#PRODUCT_SING_NUMSEG-val">PRODUCT_SING_NUMSEG</a> : thm
<a name="line344"></a>    val <a href="#PRODUCT_SUPERSET-val">PRODUCT_SUPERSET</a> : thm
<a name="line345"></a>    val <a href="#PRODUCT_SUPPORT-val">PRODUCT_SUPPORT</a> : thm
<a name="line346"></a>    val <a href="#PRODUCT_UNION-val">PRODUCT_UNION</a> : thm
<a name="line347"></a>    val <a href="#REAL_ABS_INF_LE-val">REAL_ABS_INF_LE</a> : thm
<a name="line348"></a>    val <a href="#REAL_ABS_SUP_LE-val">REAL_ABS_SUP_LE</a> : thm
<a name="line349"></a>    val <a href="#REAL_ARCH_INV'-val">REAL_ARCH_INV'</a> : thm
<a name="line350"></a>    val <a href="#REAL_ARCH_INV_SUC-val">REAL_ARCH_INV_SUC</a> : thm
<a name="line351"></a>    val <a href="#REAL_BOUNDS_LT-val">REAL_BOUNDS_LT</a> : thm
<a name="line352"></a>    val <a href="#REAL_COMPLETE-val">REAL_COMPLETE</a> : thm
<a name="line353"></a>    val <a href="#REAL_EQ_SQUARE_ABS-val">REAL_EQ_SQUARE_ABS</a> : thm
<a name="line354"></a>    val <a href="#REAL_HALF-val">REAL_HALF</a> : thm
<a name="line355"></a>    val <a href="#REAL_IMP_LE_SUP'-val">REAL_IMP_LE_SUP'</a> : thm
<a name="line356"></a>    val <a href="#REAL_IMP_SUP_LE'-val">REAL_IMP_SUP_LE'</a> : thm
<a name="line357"></a>    val <a href="#REAL_INF_ASCLOSE-val">REAL_INF_ASCLOSE</a> : thm
<a name="line358"></a>    val <a href="#REAL_INF_BOUNDS-val">REAL_INF_BOUNDS</a> : thm
<a name="line359"></a>    val <a href="#REAL_INF_LE'-val">REAL_INF_LE'</a> : thm
<a name="line360"></a>    val <a href="#REAL_INF_LE_FINITE-val">REAL_INF_LE_FINITE</a> : thm
<a name="line361"></a>    val <a href="#REAL_INF_LT_FINITE-val">REAL_INF_LT_FINITE</a> : thm
<a name="line362"></a>    val <a href="#REAL_INF_UNIQUE-val">REAL_INF_UNIQUE</a> : thm
<a name="line363"></a>    val <a href="#REAL_LE_BETWEEN-val">REAL_LE_BETWEEN</a> : thm
<a name="line364"></a>    val <a href="#REAL_LE_INF-val">REAL_LE_INF</a> : thm
<a name="line365"></a>    val <a href="#REAL_LE_INF_FINITE-val">REAL_LE_INF_FINITE</a> : thm
<a name="line366"></a>    val <a href="#REAL_LE_INF_SUBSET-val">REAL_LE_INF_SUBSET</a> : thm
<a name="line367"></a>    val <a href="#REAL_LE_LDIV_CANCEL-val">REAL_LE_LDIV_CANCEL</a> : thm
<a name="line368"></a>    val <a href="#REAL_LE_LT_MUL-val">REAL_LE_LT_MUL</a> : thm
<a name="line369"></a>    val <a href="#REAL_LE_MUL'-val">REAL_LE_MUL'</a> : thm
<a name="line370"></a>    val <a href="#REAL_LE_MUL_EPSILON-val">REAL_LE_MUL_EPSILON</a> : thm
<a name="line371"></a>    val <a href="#REAL_LE_RDIV_EQ_NEG-val">REAL_LE_RDIV_EQ_NEG</a> : thm
<a name="line372"></a>    val <a href="#REAL_LE_SQUARE_ABS-val">REAL_LE_SQUARE_ABS</a> : thm
<a name="line373"></a>    val <a href="#REAL_LE_SUP'-val">REAL_LE_SUP'</a> : thm
<a name="line374"></a>    val <a href="#REAL_LE_SUP_EQ-val">REAL_LE_SUP_EQ</a> : thm
<a name="line375"></a>    val <a href="#REAL_LE_SUP_FINITE-val">REAL_LE_SUP_FINITE</a> : thm
<a name="line376"></a>    val <a href="#REAL_LT_BETWEEN-val">REAL_LT_BETWEEN</a> : thm
<a name="line377"></a>    val <a href="#REAL_LT_INF_FINITE-val">REAL_LT_INF_FINITE</a> : thm
<a name="line378"></a>    val <a href="#REAL_LT_INV2-val">REAL_LT_INV2</a> : thm
<a name="line379"></a>    val <a href="#REAL_LT_LCANCEL_IMP-val">REAL_LT_LCANCEL_IMP</a> : thm
<a name="line380"></a>    val <a href="#REAL_LT_LDIV_CANCEL-val">REAL_LT_LDIV_CANCEL</a> : thm
<a name="line381"></a>    val <a href="#REAL_LT_LE_MUL-val">REAL_LT_LE_MUL</a> : thm
<a name="line382"></a>    val <a href="#REAL_LT_LMUL'-val">REAL_LT_LMUL'</a> : thm
<a name="line383"></a>    val <a href="#REAL_LT_LMUL_0_NEG-val">REAL_LT_LMUL_0_NEG</a> : thm
<a name="line384"></a>    val <a href="#REAL_LT_LMUL_NEG_0-val">REAL_LT_LMUL_NEG_0</a> : thm
<a name="line385"></a>    val <a href="#REAL_LT_LMUL_NEG_0_NEG-val">REAL_LT_LMUL_NEG_0_NEG</a> : thm
<a name="line386"></a>    val <a href="#REAL_LT_MAX_BETWEEN-val">REAL_LT_MAX_BETWEEN</a> : thm
<a name="line387"></a>    val <a href="#REAL_LT_MUL'-val">REAL_LT_MUL'</a> : thm
<a name="line388"></a>    val <a href="#REAL_LT_POW2-val">REAL_LT_POW2</a> : thm
<a name="line389"></a>    val <a href="#REAL_LT_RDIV_EQ_NEG-val">REAL_LT_RDIV_EQ_NEG</a> : thm
<a name="line390"></a>    val <a href="#REAL_LT_RMUL'-val">REAL_LT_RMUL'</a> : thm
<a name="line391"></a>    val <a href="#REAL_LT_RMUL_0_NEG-val">REAL_LT_RMUL_0_NEG</a> : thm
<a name="line392"></a>    val <a href="#REAL_LT_RMUL_NEG_0-val">REAL_LT_RMUL_NEG_0</a> : thm
<a name="line393"></a>    val <a href="#REAL_LT_RMUL_NEG_0_NEG-val">REAL_LT_RMUL_NEG_0_NEG</a> : thm
<a name="line394"></a>    val <a href="#REAL_LT_SUP_FINITE-val">REAL_LT_SUP_FINITE</a> : thm
<a name="line395"></a>    val <a href="#REAL_MAX_REDUCE-val">REAL_MAX_REDUCE</a> : thm
<a name="line396"></a>    val <a href="#REAL_MIN_LE_BETWEEN-val">REAL_MIN_LE_BETWEEN</a> : thm
<a name="line397"></a>    val <a href="#REAL_MIN_REDUCE-val">REAL_MIN_REDUCE</a> : thm
<a name="line398"></a>    val <a href="#REAL_MUL_IDEMPOT-val">REAL_MUL_IDEMPOT</a> : thm
<a name="line399"></a>    val <a href="#REAL_MUL_SUM-val">REAL_MUL_SUM</a> : thm
<a name="line400"></a>    val <a href="#REAL_MUL_SUM_NUMSEG-val">REAL_MUL_SUM_NUMSEG</a> : thm
<a name="line401"></a>    val <a href="#REAL_NEG_NZ-val">REAL_NEG_NZ</a> : thm
<a name="line402"></a>    val <a href="#REAL_OF_NUM_GE-val">REAL_OF_NUM_GE</a> : thm
<a name="line403"></a>    val <a href="#REAL_OF_NUM_NPRODUCT-val">REAL_OF_NUM_NPRODUCT</a> : thm
<a name="line404"></a>    val <a href="#REAL_OF_NUM_SUM-val">REAL_OF_NUM_SUM</a> : thm
<a name="line405"></a>    val <a href="#REAL_OF_NUM_SUM_NUMSEG-val">REAL_OF_NUM_SUM_NUMSEG</a> : thm
<a name="line406"></a>    val <a href="#REAL_POLYFUN_EQ_0-val">REAL_POLYFUN_EQ_0</a> : thm
<a name="line407"></a>    val <a href="#REAL_POLYFUN_EQ_CONST-val">REAL_POLYFUN_EQ_CONST</a> : thm
<a name="line408"></a>    val <a href="#REAL_POLYFUN_FINITE_ROOTS-val">REAL_POLYFUN_FINITE_ROOTS</a> : thm
<a name="line409"></a>    val <a href="#REAL_POLYFUN_ROOTBOUND-val">REAL_POLYFUN_ROOTBOUND</a> : thm
<a name="line410"></a>    val <a href="#REAL_SUB_POLYFUN-val">REAL_SUB_POLYFUN</a> : thm
<a name="line411"></a>    val <a href="#REAL_SUB_POLYFUN_ALT-val">REAL_SUB_POLYFUN_ALT</a> : thm
<a name="line412"></a>    val <a href="#REAL_SUB_POW-val">REAL_SUB_POW</a> : thm
<a name="line413"></a>    val <a href="#REAL_SUB_POW_L1-val">REAL_SUB_POW_L1</a> : thm
<a name="line414"></a>    val <a href="#REAL_SUB_POW_R1-val">REAL_SUB_POW_R1</a> : thm
<a name="line415"></a>    val <a href="#REAL_SUP_ASCLOSE-val">REAL_SUP_ASCLOSE</a> : thm
<a name="line416"></a>    val <a href="#REAL_SUP_BOUNDS-val">REAL_SUP_BOUNDS</a> : thm
<a name="line417"></a>    val <a href="#REAL_SUP_EQ_INF-val">REAL_SUP_EQ_INF</a> : thm
<a name="line418"></a>    val <a href="#REAL_SUP_LE'-val">REAL_SUP_LE'</a> : thm
<a name="line419"></a>    val <a href="#REAL_SUP_LE_EQ-val">REAL_SUP_LE_EQ</a> : thm
<a name="line420"></a>    val <a href="#REAL_SUP_LE_FINITE-val">REAL_SUP_LE_FINITE</a> : thm
<a name="line421"></a>    val <a href="#REAL_SUP_LE_SUBSET-val">REAL_SUP_LE_SUBSET</a> : thm
<a name="line422"></a>    val <a href="#REAL_SUP_LE_X-val">REAL_SUP_LE_X</a> : thm
<a name="line423"></a>    val <a href="#REAL_SUP_LT_FINITE-val">REAL_SUP_LT_FINITE</a> : thm
<a name="line424"></a>    val <a href="#REAL_SUP_UNIQUE-val">REAL_SUP_UNIQUE</a> : thm
<a name="line425"></a>    val <a href="#REAL_WLOG_LE-val">REAL_WLOG_LE</a> : thm
<a name="line426"></a>    val <a href="#REAL_WLOG_LT-val">REAL_WLOG_LT</a> : thm
<a name="line427"></a>    val <a href="#REAL_X_LE_SUP-val">REAL_X_LE_SUP</a> : thm
<a name="line428"></a>    val <a href="#SET_PROVE_CASES-val">SET_PROVE_CASES</a> : thm
<a name="line429"></a>    val <a href="#SET_RECURSION_LEMMA-val">SET_RECURSION_LEMMA</a> : thm
<a name="line430"></a>    val <a href="#SIMPLE_IMAGE_GEN-val">SIMPLE_IMAGE_GEN</a> : thm
<a name="line431"></a>    val <a href="#SUBSET_NUMSEG-val">SUBSET_NUMSEG</a> : thm
<a name="line432"></a>    val <a href="#SUBSET_RESTRICT-val">SUBSET_RESTRICT</a> : thm
<a name="line433"></a>    val <a href="#SUMS_SYM-val">SUMS_SYM</a> : thm
<a name="line434"></a>    val <a href="#SUM_0'-val">SUM_0'</a> : thm
<a name="line435"></a>    val <a href="#SUM_ABS'-val">SUM_ABS'</a> : thm
<a name="line436"></a>    val <a href="#SUM_ABS_BOUND-val">SUM_ABS_BOUND</a> : thm
<a name="line437"></a>    val <a href="#SUM_ABS_LE'-val">SUM_ABS_LE'</a> : thm
<a name="line438"></a>    val <a href="#SUM_ABS_NUMSEG-val">SUM_ABS_NUMSEG</a> : thm
<a name="line439"></a>    val <a href="#SUM_ABS_TRIANGLE-val">SUM_ABS_TRIANGLE</a> : thm
<a name="line440"></a>    val <a href="#SUM_ADD'-val">SUM_ADD'</a> : thm
<a name="line441"></a>    val <a href="#SUM_ADD_COUNT-val">SUM_ADD_COUNT</a> : thm
<a name="line442"></a>    val <a href="#SUM_ADD_GEN-val">SUM_ADD_GEN</a> : thm
<a name="line443"></a>    val <a href="#SUM_ADD_NUMSEG-val">SUM_ADD_NUMSEG</a> : thm
<a name="line444"></a>    val <a href="#SUM_ADD_SPLIT-val">SUM_ADD_SPLIT</a> : thm
<a name="line445"></a>    val <a href="#SUM_BIGUNION_NONZERO-val">SUM_BIGUNION_NONZERO</a> : thm
<a name="line446"></a>    val <a href="#SUM_BIJECTION-val">SUM_BIJECTION</a> : thm
<a name="line447"></a>    val <a href="#SUM_BOUND'-val">SUM_BOUND'</a> : thm
<a name="line448"></a>    val <a href="#SUM_BOUND_GEN-val">SUM_BOUND_GEN</a> : thm
<a name="line449"></a>    val <a href="#SUM_BOUND_LT-val">SUM_BOUND_LT</a> : thm
<a name="line450"></a>    val <a href="#SUM_BOUND_LT_ALL-val">SUM_BOUND_LT_ALL</a> : thm
<a name="line451"></a>    val <a href="#SUM_BOUND_LT_GEN-val">SUM_BOUND_LT_GEN</a> : thm
<a name="line452"></a>    val <a href="#SUM_CASES-val">SUM_CASES</a> : thm
<a name="line453"></a>    val <a href="#SUM_CASES_1-val">SUM_CASES_1</a> : thm
<a name="line454"></a>    val <a href="#SUM_CLAUSES-val">SUM_CLAUSES</a> : thm
<a name="line455"></a>    val <a href="#SUM_CLAUSES_LEFT-val">SUM_CLAUSES_LEFT</a> : thm
<a name="line456"></a>    val <a href="#SUM_CLAUSES_NUMSEG-val">SUM_CLAUSES_NUMSEG</a> : thm
<a name="line457"></a>    val <a href="#SUM_CLAUSES_RIGHT-val">SUM_CLAUSES_RIGHT</a> : thm
<a name="line458"></a>    val <a href="#SUM_CLOSED-val">SUM_CLOSED</a> : thm
<a name="line459"></a>    val <a href="#SUM_COMBINE_L-val">SUM_COMBINE_L</a> : thm
<a name="line460"></a>    val <a href="#SUM_COMBINE_R-val">SUM_COMBINE_R</a> : thm
<a name="line461"></a>    val <a href="#SUM_CONG-val">SUM_CONG</a> : thm
<a name="line462"></a>    val <a href="#SUM_CONST-val">SUM_CONST</a> : thm
<a name="line463"></a>    val <a href="#SUM_CONST_NUMSEG-val">SUM_CONST_NUMSEG</a> : thm
<a name="line464"></a>    val <a href="#SUM_DEGENERATE-val">SUM_DEGENERATE</a> : thm
<a name="line465"></a>    val <a href="#SUM_DELETE-val">SUM_DELETE</a> : thm
<a name="line466"></a>    val <a href="#SUM_DELETE_CASES-val">SUM_DELETE_CASES</a> : thm
<a name="line467"></a>    val <a href="#SUM_DELTA-val">SUM_DELTA</a> : thm
<a name="line468"></a>    val <a href="#SUM_DIFF'-val">SUM_DIFF'</a> : thm
<a name="line469"></a>    val <a href="#SUM_DIFFS'-val">SUM_DIFFS'</a> : thm
<a name="line470"></a>    val <a href="#SUM_DIFFS_ALT-val">SUM_DIFFS_ALT</a> : thm
<a name="line471"></a>    val <a href="#SUM_EQ'-val">SUM_EQ'</a> : thm
<a name="line472"></a>    val <a href="#SUM_EQ_0'-val">SUM_EQ_0'</a> : thm
<a name="line473"></a>    val <a href="#SUM_EQ_0_NUMSEG-val">SUM_EQ_0_NUMSEG</a> : thm
<a name="line474"></a>    val <a href="#SUM_EQ_COUNT-val">SUM_EQ_COUNT</a> : thm
<a name="line475"></a>    val <a href="#SUM_EQ_GENERAL-val">SUM_EQ_GENERAL</a> : thm
<a name="line476"></a>    val <a href="#SUM_EQ_GENERAL_INVERSES-val">SUM_EQ_GENERAL_INVERSES</a> : thm
<a name="line477"></a>    val <a href="#SUM_EQ_NUMSEG-val">SUM_EQ_NUMSEG</a> : thm
<a name="line478"></a>    val <a href="#SUM_EQ_SUPERSET-val">SUM_EQ_SUPERSET</a> : thm
<a name="line479"></a>    val <a href="#SUM_GP-val">SUM_GP</a> : thm
<a name="line480"></a>    val <a href="#SUM_GP_BASIC-val">SUM_GP_BASIC</a> : thm
<a name="line481"></a>    val <a href="#SUM_GP_MULTIPLIED-val">SUM_GP_MULTIPLIED</a> : thm
<a name="line482"></a>    val <a href="#SUM_GROUP'-val">SUM_GROUP'</a> : thm
<a name="line483"></a>    val <a href="#SUM_IMAGE-val">SUM_IMAGE</a> : thm
<a name="line484"></a>    val <a href="#SUM_IMAGE_GEN-val">SUM_IMAGE_GEN</a> : thm
<a name="line485"></a>    val <a href="#SUM_IMAGE_LE-val">SUM_IMAGE_LE</a> : thm
<a name="line486"></a>    val <a href="#SUM_IMAGE_NONZERO-val">SUM_IMAGE_NONZERO</a> : thm
<a name="line487"></a>    val <a href="#SUM_INCL_EXCL-val">SUM_INCL_EXCL</a> : thm
<a name="line488"></a>    val <a href="#SUM_INJECTION-val">SUM_INJECTION</a> : thm
<a name="line489"></a>    val <a href="#SUM_LE'-val">SUM_LE'</a> : thm
<a name="line490"></a>    val <a href="#SUM_LE_INCLUDED-val">SUM_LE_INCLUDED</a> : thm
<a name="line491"></a>    val <a href="#SUM_LE_NUMSEG-val">SUM_LE_NUMSEG</a> : thm
<a name="line492"></a>    val <a href="#SUM_LMUL-val">SUM_LMUL</a> : thm
<a name="line493"></a>    val <a href="#SUM_LT'-val">SUM_LT'</a> : thm
<a name="line494"></a>    val <a href="#SUM_LT_ALL-val">SUM_LT_ALL</a> : thm
<a name="line495"></a>    val <a href="#SUM_MULTICOUNT-val">SUM_MULTICOUNT</a> : thm
<a name="line496"></a>    val <a href="#SUM_MULTICOUNT_GEN-val">SUM_MULTICOUNT_GEN</a> : thm
<a name="line497"></a>    val <a href="#SUM_NEG'-val">SUM_NEG'</a> : thm
<a name="line498"></a>    val <a href="#SUM_OFFSET'-val">SUM_OFFSET'</a> : thm
<a name="line499"></a>    val <a href="#SUM_OFFSET_0-val">SUM_OFFSET_0</a> : thm
<a name="line500"></a>    val <a href="#SUM_PAIR-val">SUM_PAIR</a> : thm
<a name="line501"></a>    val <a href="#SUM_PARTIAL_PRE-val">SUM_PARTIAL_PRE</a> : thm
<a name="line502"></a>    val <a href="#SUM_PARTIAL_SUC-val">SUM_PARTIAL_SUC</a> : thm
<a name="line503"></a>    val <a href="#SUM_PERMUTATIONS_COMPOSE_L-val">SUM_PERMUTATIONS_COMPOSE_L</a> : thm
<a name="line504"></a>    val <a href="#SUM_PERMUTATIONS_COMPOSE_L_COUNT-val">SUM_PERMUTATIONS_COMPOSE_L_COUNT</a> : thm
<a name="line505"></a>    val <a href="#SUM_PERMUTATIONS_COMPOSE_L_NUMSEG-val">SUM_PERMUTATIONS_COMPOSE_L_NUMSEG</a> : thm
<a name="line506"></a>    val <a href="#SUM_PERMUTATIONS_COMPOSE_R-val">SUM_PERMUTATIONS_COMPOSE_R</a> : thm
<a name="line507"></a>    val <a href="#SUM_PERMUTATIONS_COMPOSE_R_COUNT-val">SUM_PERMUTATIONS_COMPOSE_R_COUNT</a> : thm
<a name="line508"></a>    val <a href="#SUM_PERMUTATIONS_COMPOSE_R_NUMSEG-val">SUM_PERMUTATIONS_COMPOSE_R_NUMSEG</a> : thm
<a name="line509"></a>    val <a href="#SUM_PERMUTATIONS_INVERSE-val">SUM_PERMUTATIONS_INVERSE</a> : thm
<a name="line510"></a>    val <a href="#SUM_PERMUTE-val">SUM_PERMUTE</a> : thm
<a name="line511"></a>    val <a href="#SUM_PERMUTE_COUNT-val">SUM_PERMUTE_COUNT</a> : thm
<a name="line512"></a>    val <a href="#SUM_PERMUTE_NUMSEG-val">SUM_PERMUTE_NUMSEG</a> : thm
<a name="line513"></a>    val <a href="#SUM_POS_BOUND-val">SUM_POS_BOUND</a> : thm
<a name="line514"></a>    val <a href="#SUM_POS_EQ_0-val">SUM_POS_EQ_0</a> : thm
<a name="line515"></a>    val <a href="#SUM_POS_EQ_0_NUMSEG-val">SUM_POS_EQ_0_NUMSEG</a> : thm
<a name="line516"></a>    val <a href="#SUM_POS_LE-val">SUM_POS_LE</a> : thm
<a name="line517"></a>    val <a href="#SUM_POS_LE_NUMSEG-val">SUM_POS_LE_NUMSEG</a> : thm
<a name="line518"></a>    val <a href="#SUM_POS_LT-val">SUM_POS_LT</a> : thm
<a name="line519"></a>    val <a href="#SUM_POS_LT_ALL-val">SUM_POS_LT_ALL</a> : thm
<a name="line520"></a>    val <a href="#SUM_RESTRICT-val">SUM_RESTRICT</a> : thm
<a name="line521"></a>    val <a href="#SUM_RESTRICT_SET-val">SUM_RESTRICT_SET</a> : thm
<a name="line522"></a>    val <a href="#SUM_RMUL-val">SUM_RMUL</a> : thm
<a name="line523"></a>    val <a href="#SUM_SING-val">SUM_SING</a> : thm
<a name="line524"></a>    val <a href="#SUM_SING_NUMSEG-val">SUM_SING_NUMSEG</a> : thm
<a name="line525"></a>    val <a href="#SUM_SUB'-val">SUM_SUB'</a> : thm
<a name="line526"></a>    val <a href="#SUM_SUBSET-val">SUM_SUBSET</a> : thm
<a name="line527"></a>    val <a href="#SUM_SUBSET_SIMPLE-val">SUM_SUBSET_SIMPLE</a> : thm
<a name="line528"></a>    val <a href="#SUM_SUB_NUMSEG-val">SUM_SUB_NUMSEG</a> : thm
<a name="line529"></a>    val <a href="#SUM_SUM_PRODUCT-val">SUM_SUM_PRODUCT</a> : thm
<a name="line530"></a>    val <a href="#SUM_SUM_RESTRICT-val">SUM_SUM_RESTRICT</a> : thm
<a name="line531"></a>    val <a href="#SUM_SUPERSET-val">SUM_SUPERSET</a> : thm
<a name="line532"></a>    val <a href="#SUM_SUPPORT-val">SUM_SUPPORT</a> : thm
<a name="line533"></a>    val <a href="#SUM_SWAP-val">SUM_SWAP</a> : thm
<a name="line534"></a>    val <a href="#SUM_SWAP_COUNT-val">SUM_SWAP_COUNT</a> : thm
<a name="line535"></a>    val <a href="#SUM_SWAP_NUMSEG-val">SUM_SWAP_NUMSEG</a> : thm
<a name="line536"></a>    val <a href="#SUM_TRIV_NUMSEG-val">SUM_TRIV_NUMSEG</a> : thm
<a name="line537"></a>    val <a href="#SUM_UNION-val">SUM_UNION</a> : thm
<a name="line538"></a>    val <a href="#SUM_UNION_EQ-val">SUM_UNION_EQ</a> : thm
<a name="line539"></a>    val <a href="#SUM_UNION_LZERO-val">SUM_UNION_LZERO</a> : thm
<a name="line540"></a>    val <a href="#SUM_UNION_NONZERO-val">SUM_UNION_NONZERO</a> : thm
<a name="line541"></a>    val <a href="#SUM_UNION_RZERO-val">SUM_UNION_RZERO</a> : thm
<a name="line542"></a>    val <a href="#SUM_ZERO_EXISTS-val">SUM_ZERO_EXISTS</a> : thm
<a name="line543"></a>    val <a href="#SUP-val">SUP</a> : thm
<a name="line544"></a>    val <a href="#SUPPORT_CLAUSES-val">SUPPORT_CLAUSES</a> : thm
<a name="line545"></a>    val <a href="#SUPPORT_DELTA-val">SUPPORT_DELTA</a> : thm
<a name="line546"></a>    val <a href="#SUPPORT_EMPTY-val">SUPPORT_EMPTY</a> : thm
<a name="line547"></a>    val <a href="#SUPPORT_SUBSET-val">SUPPORT_SUBSET</a> : thm
<a name="line548"></a>    val <a href="#SUPPORT_SUPPORT-val">SUPPORT_SUPPORT</a> : thm
<a name="line549"></a>    val <a href="#SUP_EQ-val">SUP_EQ</a> : thm
<a name="line550"></a>    val <a href="#SUP_FINITE-val">SUP_FINITE</a> : thm
<a name="line551"></a>    val <a href="#SUP_FINITE_LEMMA-val">SUP_FINITE_LEMMA</a> : thm
<a name="line552"></a>    val <a href="#SUP_INSERT_FINITE-val">SUP_INSERT_FINITE</a> : thm
<a name="line553"></a>    val <a href="#SUP_MONO-val">SUP_MONO</a> : thm
<a name="line554"></a>    val <a href="#SUP_SING-val">SUP_SING</a> : thm
<a name="line555"></a>    val <a href="#SUP_UNION-val">SUP_UNION</a> : thm
<a name="line556"></a>    val <a href="#SUP_UNIQUE-val">SUP_UNIQUE</a> : thm
<a name="line557"></a>    val <a href="#SUP_UNIQUE_FINITE-val">SUP_UNIQUE_FINITE</a> : thm
<a name="line558"></a>    val <a href="#TOPOLOGICAL_SORT-val">TOPOLOGICAL_SORT</a> : thm
<a name="line559"></a>    val <a href="#TOPOLOGICAL_SORT'-val">TOPOLOGICAL_SORT'</a> : thm
<a name="line560"></a>    val <a href="#TRANSITIVE_STEPWISE_LE-val">TRANSITIVE_STEPWISE_LE</a> : thm
<a name="line561"></a>    val <a href="#TRANSITIVE_STEPWISE_LE_EQ-val">TRANSITIVE_STEPWISE_LE_EQ</a> : thm
<a name="line562"></a>    val <a href="#UNION_COUNT_FROM-val">UNION_COUNT_FROM</a> : thm
<a name="line563"></a>    val <a href="#UNION_FROM_COUNT-val">UNION_FROM_COUNT</a> : thm
<a name="line564"></a>    val <a href="#UPPER_BOUND_FINITE_SET-val">UPPER_BOUND_FINITE_SET</a> : thm
<a name="line565"></a>    val <a href="#UPPER_BOUND_FINITE_SET_REAL-val">UPPER_BOUND_FINITE_SET_REAL</a> : thm
<a name="line566"></a>    val <a href="#inf_alt-val">inf_alt</a> : thm
<a name="line567"></a>    val <a href="#lifted-val">lifted</a> : thm
<a name="line568"></a>    val <a href="#lifted_ind-val">lifted_ind</a> : thm
<a name="line569"></a>    val <a href="#real_INFINITE-val">real_INFINITE</a> : thm
<a name="line570"></a>    val <a href="#sum_real-val">sum_real</a> : thm
<a name="line571"></a>    val <a href="#sup_alt-val">sup_alt</a> : thm
<a name="line572"></a>  
<a name="line573"></a>  val iterate_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line574"></a>(*
   [permutes] Parent theory of "iterate"
   
   [real] Parent theory of "iterate"
   
   [<a name="FINREC_def-val"><b>FINREC_def</b></a>]  Definition
      
      ⊢ (∀f b s a. FINREC f b s a 0 ⇔ s = ∅ ∧ a = b) ∧
        ∀f b s a n.
          FINREC f b s a (SUC n) ⇔
          ∃x c. x ∈ s ∧ FINREC f b (s DELETE x) c n ∧ a = f x c
   
   [<a name="from_def-val"><b>from_def</b></a>]  Definition
      
      ⊢ ∀n. from n = {m | n ≤ m}
   
   [<a name="indicator-val"><b>indicator</b></a>]  Definition
      
      ⊢ ∀s. indicator s = (λx. if x ∈ s then 1 else 0)
   
   [<a name="iterate-val"><b>iterate</b></a>]  Definition
      
      ⊢ ∀op s f.
          iterate op s f =
          if FINITE (support op f s) then
            ITSET (λx a. op (f x) a) (support op f s) (neutral op)
          else neutral op
   
   [<a name="monoidal-val"><b>monoidal</b></a>]  Definition
      
      ⊢ ∀op.
          monoidal op ⇔
          (∀x y. op x y = op y x) ∧
          (∀x y z. op x (op y z) = op (op x y) z) ∧
          ∀x. op (neutral op) x = x
   
   [<a name="neutral-val"><b>neutral</b></a>]  Definition
      
      ⊢ ∀op. neutral op = @x. ∀y. op x y = y ∧ op y x = y
   
   [<a name="nproduct-val"><b>nproduct</b></a>]  Definition
      
      ⊢ nproduct = iterate $*
   
   [<a name="nsum-val"><b>nsum</b></a>]  Definition
      
      ⊢ nsum = iterate $+
   
   [<a name="numseg-val"><b>numseg</b></a>]  Definition
      
      ⊢ ∀m n. {m .. n} = {x | m ≤ x ∧ x ≤ n}
   
   [<a name="polynomial_function-val"><b>polynomial_function</b></a>]  Definition
      
      ⊢ ∀p. polynomial_function p ⇔
            ∃m c. ∀x. p x = sum {0 .. m} (λi. c i * x pow i)
   
   [<a name="product-val"><b>product</b></a>]  Definition
      
      ⊢ product = iterate $*
   
   [<a name="sum_def-val"><b>sum_def</b></a>]  Definition
      
      ⊢ sum = iterate $+
   
   [<a name="support-val"><b>support</b></a>]  Definition
      
      ⊢ ∀op f s. support op f s = {x | x ∈ s ∧ f x ≠ neutral op}
   
   [<a name="ABS_LE_0-val"><b>ABS_LE_0</b></a>]  Theorem
      
      ⊢ ∀x. abs x ≤ 0 ⇔ x = 0
   
   [<a name="ABS_LE_HALF_POW2-val"><b>ABS_LE_HALF_POW2</b></a>]  Theorem
      
      ⊢ ∀x y. abs (x * y) ≤ 1 / 2 * (x² + y²)
   
   [<a name="ADD_SUB2-val"><b>ADD_SUB2</b></a>]  Theorem
      
      ⊢ ∀m n. m + n − m = n
   
   [<a name="ADD_SUBR-val"><b>ADD_SUBR</b></a>]  Theorem
      
      ⊢ ∀m n. n − (m + n) = 0
   
   [<a name="ADD_SUBR2-val"><b>ADD_SUBR2</b></a>]  Theorem
      
      ⊢ ∀m n. m − (m + n) = 0
   
   [<a name="BIGINTER_BIGUNION-val"><b>BIGINTER_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀s. BIGINTER s = 𝕌(:α) DIFF BIGUNION {𝕌(:α) DIFF t | t ∈ s}
   
   [<a name="BIGINTER_GSPEC-val"><b>BIGINTER_GSPEC</b></a>]  Theorem
      
      ⊢ (∀P f. BIGINTER {f x | P x} = {a | ∀x. P x ⇒ a ∈ f x}) ∧
        (∀P f. BIGINTER {f x y | P x y} = {a | ∀x y. P x y ⇒ a ∈ f x y}) ∧
        ∀P f.
          BIGINTER {f x y z | P x y z} =
          {a | ∀x y z. P x y z ⇒ a ∈ f x y z}
   
   [<a name="BIGUNION_BIGINTER-val"><b>BIGUNION_BIGINTER</b></a>]  Theorem
      
      ⊢ ∀s. BIGUNION s = 𝕌(:α) DIFF BIGINTER {𝕌(:α) DIFF t | t ∈ s}
   
   [<a name="BIGUNION_GSPEC-val"><b>BIGUNION_GSPEC</b></a>]  Theorem
      
      ⊢ (∀P f. BIGUNION {f x | P x} = {a | ∃x. P x ∧ a ∈ f x}) ∧
        (∀P f. BIGUNION {f x y | P x y} = {a | ∃x y. P x y ∧ a ∈ f x y}) ∧
        ∀P f.
          BIGUNION {f x y z | P x y z} =
          {a | ∃x y z. P x y z ∧ a ∈ f x y z}
   
   [<a name="BOUNDS_LINEAR-val"><b>BOUNDS_LINEAR</b></a>]  Theorem
      
      ⊢ ∀A B C. (∀n. A * n ≤ B * n + C) ⇔ A ≤ B
   
   [<a name="BOUNDS_LINEAR_0-val"><b>BOUNDS_LINEAR_0</b></a>]  Theorem
      
      ⊢ ∀A B. (∀n. A * n ≤ B) ⇔ A = 0
   
   [<a name="CARD_BIGUNION-val"><b>CARD_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ∧ (∀t. t ∈ s ⇒ FINITE t) ∧
            (∀t u. t ∈ s ∧ u ∈ s ∧ t ≠ u ⇒ t ∩ u = ∅) ⇒
            CARD (BIGUNION s) = nsum s CARD
   
   [<a name="CARD_EQ_NSUM-val"><b>CARD_EQ_NSUM</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ CARD s = nsum s (λx. 1)
   
   [<a name="CARD_EQ_SUM-val"><b>CARD_EQ_SUM</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ &CARD s = sum s (λx. 1)
   
   [<a name="CARD_NUMSEG-val"><b>CARD_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀m n. CARD {m .. n} = n + 1 − m
   
   [<a name="CARD_NUMSEG_1-val"><b>CARD_NUMSEG_1</b></a>]  Theorem
      
      ⊢ ∀n. CARD {1 .. n} = n
   
   [<a name="CARD_NUMSEG_LEMMA-val"><b>CARD_NUMSEG_LEMMA</b></a>]  Theorem
      
      ⊢ ∀m d. CARD {m .. m + d} = d + 1
   
   [<a name="CARD_UNION_EQ-val"><b>CARD_UNION_EQ</b></a>]  Theorem
      
      ⊢ ∀s t u. FINITE u ∧ s ∩ t = ∅ ∧ s ∪ t = u ⇒ CARD s + CARD t = CARD u
   
   [<a name="CHOOSE_SUBSET-val"><b>CHOOSE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀n. n ≤ CARD s ⇒ ∃t. t ⊆ s ∧ t HAS_SIZE n
   
   [<a name="CHOOSE_SUBSET_STRONG-val"><b>CHOOSE_SUBSET_STRONG</b></a>]  Theorem
      
      ⊢ ∀n s. (FINITE s ⇒ n ≤ CARD s) ⇒ ∃t. t ⊆ s ∧ t HAS_SIZE n
   
   [<a name="COUNTABLE_FROM-val"><b>COUNTABLE_FROM</b></a>]  Theorem
      
      ⊢ ∀n. countable (from n)
   
   [<a name="COUNT_NUMSEG-val"><b>COUNT_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ count n = {0 .. n − 1}
   
   [<a name="DIFF_BIGINTER2-val"><b>DIFF_BIGINTER2</b></a>]  Theorem
      
      ⊢ ∀u s. u DIFF BIGINTER s = BIGUNION {u DIFF t | t ∈ s}
   
   [<a name="DISJOINT_COUNT_FROM-val"><b>DISJOINT_COUNT_FROM</b></a>]  Theorem
      
      ⊢ ∀n. DISJOINT (count n) (from n)
   
   [<a name="DISJOINT_FROM_COUNT-val"><b>DISJOINT_FROM_COUNT</b></a>]  Theorem
      
      ⊢ ∀n. DISJOINT (from n) (count n)
   
   [<a name="DISJOINT_NUMSEG-val"><b>DISJOINT_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀m n p q.
          DISJOINT {m .. n} {p .. q} ⇔ n &lt; p ∨ q &lt; m ∨ n &lt; m ∨ q &lt; p
   
   [<a name="DROP_INDICATOR-val"><b>DROP_INDICATOR</b></a>]  Theorem
      
      ⊢ ∀s x. indicator s x = if x ∈ s then 1 else 0
   
   [<a name="DROP_INDICATOR_ABS_LE_1-val"><b>DROP_INDICATOR_ABS_LE_1</b></a>]  Theorem
      
      ⊢ ∀s x. abs (indicator s x) ≤ 1
   
   [<a name="DROP_INDICATOR_LE_1-val"><b>DROP_INDICATOR_LE_1</b></a>]  Theorem
      
      ⊢ ∀s x. indicator s x ≤ 1
   
   [<a name="DROP_INDICATOR_POS_LE-val"><b>DROP_INDICATOR_POS_LE</b></a>]  Theorem
      
      ⊢ ∀s x. 0 ≤ indicator s x
   
   [<a name="EMPTY_BIGUNION-val"><b>EMPTY_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀s. BIGUNION s = ∅ ⇔ ∀t. t ∈ s ⇒ t = ∅
   
   [<a name="EXISTS_FINITE_SUBSET_IMAGE-val"><b>EXISTS_FINITE_SUBSET_IMAGE</b></a>]  Theorem
      
      ⊢ ∀P f s.
          (∃t. FINITE t ∧ t ⊆ IMAGE f s ∧ P t) ⇔
          ∃t. FINITE t ∧ t ⊆ s ∧ P (IMAGE f t)
   
   [<a name="FINITE_INDEX_NUMBERS-val"><b>FINITE_INDEX_NUMBERS</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇔
            ∃k f.
              (∀i j. i ∈ k ∧ j ∈ k ∧ f i = f j ⇒ i = j) ∧ FINITE k ∧
              s = IMAGE f k
   
   [<a name="FINITE_INDEX_NUMSEG-val"><b>FINITE_INDEX_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇔
            ∃f. (∀i j.
                   i ∈ {1 .. CARD s} ∧ j ∈ {1 .. CARD s} ∧ f i = f j ⇒
                   i = j) ∧ s = IMAGE f {1 .. CARD s}
   
   [<a name="FINITE_NUMSEG-val"><b>FINITE_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀m n. FINITE {m .. n}
   
   [<a name="FINITE_POWERSET-val"><b>FINITE_POWERSET</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ FINITE {t | t ⊆ s}
   
   [<a name="FINITE_REAL_INTERVAL-val"><b>FINITE_REAL_INTERVAL</b></a>]  Theorem
      
      ⊢ (∀a. INFINITE {x | a &lt; x}) ∧ (∀a. INFINITE {x | a ≤ x}) ∧
        (∀b. INFINITE {x | x &lt; b}) ∧ (∀b. INFINITE {x | x ≤ b}) ∧
        (∀a b. FINITE {x | a &lt; x ∧ x &lt; b} ⇔ b ≤ a) ∧
        (∀a b. FINITE {x | a ≤ x ∧ x &lt; b} ⇔ b ≤ a) ∧
        (∀a b. FINITE {x | a &lt; x ∧ x ≤ b} ⇔ b ≤ a) ∧
        ∀a b. FINITE {x | a ≤ x ∧ x ≤ b} ⇔ b ≤ a
   
   [<a name="FINITE_RECURSION-val"><b>FINITE_RECURSION</b></a>]  Theorem
      
      ⊢ ∀f b.
          (∀x y s. x ≠ y ⇒ f x (f y s) = f y (f x s)) ⇒
          ITSET f ∅ b = b ∧
          ∀x s.
            FINITE s ⇒
            ITSET f (x INSERT s) b =
            if x ∈ s then ITSET f s b else f x (ITSET f s b)
   
   [<a name="FINITE_RESTRICT-val"><b>FINITE_RESTRICT</b></a>]  Theorem
      
      ⊢ ∀s P. FINITE s ⇒ FINITE {x | x ∈ s ∧ P x}
   
   [<a name="FINITE_SUBSET_IMAGE-val"><b>FINITE_SUBSET_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s t.
          FINITE t ∧ t ⊆ IMAGE f s ⇔
          ∃s'. FINITE s' ∧ s' ⊆ s ∧ t = IMAGE f s'
   
   [<a name="FINITE_SUPPORT-val"><b>FINITE_SUPPORT</b></a>]  Theorem
      
      ⊢ ∀op f s. FINITE s ⇒ FINITE (support op f s)
   
   [<a name="FINITE_SUPPORT_DELTA-val"><b>FINITE_SUPPORT_DELTA</b></a>]  Theorem
      
      ⊢ ∀op f a.
          FINITE (support op (λx. if x = a then f x else neutral op) s)
   
   [<a name="FINREC_1_LEMMA-val"><b>FINREC_1_LEMMA</b></a>]  Theorem
      
      ⊢ ∀f b s a. FINREC f b s a (SUC 0) ⇔ ∃x. s = {x} ∧ a = f x b
   
   [<a name="FINREC_EXISTS_LEMMA-val"><b>FINREC_EXISTS_LEMMA</b></a>]  Theorem
      
      ⊢ ∀f b s. FINITE s ⇒ ∃a n. FINREC f b s a n
   
   [<a name="FINREC_FUN-val"><b>FINREC_FUN</b></a>]  Theorem
      
      ⊢ ∀f b.
          (∀x y s. x ≠ y ⇒ f x (f y s) = f y (f x s)) ⇒
          ∃g. g ∅ = b ∧ ∀s x. FINITE s ∧ x ∈ s ⇒ g s = f x (g (s DELETE x))
   
   [<a name="FINREC_FUN_LEMMA-val"><b>FINREC_FUN_LEMMA</b></a>]  Theorem
      
      ⊢ ∀P R.
          (∀s. P s ⇒ ∃a n. R s a n) ∧
          (∀n1 n2 s a1 a2. R s a1 n1 ∧ R s a2 n2 ⇒ a1 = a2 ∧ n1 = n2) ⇒
          ∃f. ∀s a. P s ⇒ ((∃n. R s a n) ⇔ f s = a)
   
   [<a name="FINREC_SUC_LEMMA-val"><b>FINREC_SUC_LEMMA</b></a>]  Theorem
      
      ⊢ ∀f b.
          (∀x y s. x ≠ y ⇒ f x (f y s) = f y (f x s)) ⇒
          ∀n s z.
            FINREC f b s z (SUC n) ⇒
            ∀x. x ∈ s ⇒ ∃w. FINREC f b (s DELETE x) w n ∧ z = f x w
   
   [<a name="FINREC_UNIQUE_LEMMA-val"><b>FINREC_UNIQUE_LEMMA</b></a>]  Theorem
      
      ⊢ ∀f b.
          (∀x y s. x ≠ y ⇒ f x (f y s) = f y (f x s)) ⇒
          ∀n1 n2 s a1 a2.
            FINREC f b s a1 n1 ∧ FINREC f b s a2 n2 ⇒ a1 = a2 ∧ n1 = n2
   
   [<a name="FINREC_compute-val"><b>FINREC_compute</b></a>]  Theorem
      
      ⊢ (∀f b s a. FINREC f b s a 0 ⇔ s = ∅ ∧ a = b) ∧
        (∀f b s a n.
           FINREC f b s a (NUMERAL (BIT1 n)) ⇔
           ∃x c.
             x ∈ s ∧ FINREC f b (s DELETE x) c (NUMERAL (BIT1 n) − 1) ∧
             a = f x c) ∧
        ∀f b s a n.
          FINREC f b s a (NUMERAL (BIT2 n)) ⇔
          ∃x c.
            x ∈ s ∧ FINREC f b (s DELETE x) c (NUMERAL (BIT1 n)) ∧
            a = f x c
   
   [<a name="FORALL_FINITE_SUBSET_IMAGE-val"><b>FORALL_FINITE_SUBSET_IMAGE</b></a>]  Theorem
      
      ⊢ ∀P f s.
          (∀t. FINITE t ∧ t ⊆ IMAGE f s ⇒ P t) ⇔
          ∀t. FINITE t ∧ t ⊆ s ⇒ P (IMAGE f t)
   
   [<a name="FROM_0-val"><b>FROM_0</b></a>]  Theorem
      
      ⊢ from 0 = 𝕌(:num)
   
   [<a name="FROM_INTER_NUMSEG-val"><b>FROM_INTER_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀k n. from k ∩ {0 .. n} = {k .. n}
   
   [<a name="FROM_INTER_NUMSEG_GEN-val"><b>FROM_INTER_NUMSEG_GEN</b></a>]  Theorem
      
      ⊢ ∀k m n. from k ∩ {m .. n} = if m &lt; k then {k .. n} else {m .. n}
   
   [<a name="FROM_INTER_NUMSEG_MAX-val"><b>FROM_INTER_NUMSEG_MAX</b></a>]  Theorem
      
      ⊢ ∀m n p. from p ∩ {m .. n} = {MAX p m .. n}
   
   [<a name="FROM_NOT_EMPTY-val"><b>FROM_NOT_EMPTY</b></a>]  Theorem
      
      ⊢ ∀n. from n ≠ ∅
   
   [<a name="FUN_IN_IMAGE-val"><b>FUN_IN_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s x. x ∈ s ⇒ f x ∈ IMAGE f s
   
   [<a name="HAS_SIZE_NUMSEG-val"><b>HAS_SIZE_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀m n. {m .. n} HAS_SIZE n + 1 − m
   
   [<a name="HAS_SIZE_NUMSEG_1-val"><b>HAS_SIZE_NUMSEG_1</b></a>]  Theorem
      
      ⊢ ∀n. {1 .. n} HAS_SIZE n
   
   [<a name="INDICATOR_COMPLEMENT-val"><b>INDICATOR_COMPLEMENT</b></a>]  Theorem
      
      ⊢ ∀s. indicator (𝕌(:α) DIFF s) = (λx. 1 − indicator s x)
   
   [<a name="INDICATOR_EMPTY-val"><b>INDICATOR_EMPTY</b></a>]  Theorem
      
      ⊢ indicator ∅ = (λx. 0)
   
   [<a name="INF-val"><b>INF</b></a>]  Theorem
      
      ⊢ ∀s. s ≠ ∅ ∧ (∃b. ∀x. x ∈ s ⇒ b ≤ x) ⇒
            (∀x. x ∈ s ⇒ inf s ≤ x) ∧ ∀b. (∀x. x ∈ s ⇒ b ≤ x) ⇒ b ≤ inf s
   
   [<a name="INFINITE_FROM-val"><b>INFINITE_FROM</b></a>]  Theorem
      
      ⊢ ∀n. INFINITE (from n)
   
   [<a name="INF_CLOSE-val"><b>INF_CLOSE</b></a>]  Theorem
      
      ⊢ ∀p e. (∃x. x ∈ p) ∧ 0 &lt; e ⇒ ∃x. x ∈ p ∧ x &lt; inf p + e
   
   [<a name="INF_DEF_ALT-val"><b>INF_DEF_ALT</b></a>]  Theorem
      
      ⊢ ∀p. inf p = -sup (λr. -r ∈ p)
   
   [<a name="INF_EQ-val"><b>INF_EQ</b></a>]  Theorem
      
      ⊢ ∀s t.
          s ≠ ∅ ∧ (∃b. ∀x. x ∈ s ⇒ b ≤ x) ∧ t ≠ ∅ ∧
          (∃b. ∀x. x ∈ t ⇒ b ≤ x) ∧
          (∀a. (∀x. x ∈ s ⇒ a ≤ x) ⇔ ∀x. x ∈ t ⇒ a ≤ x) ⇒
          inf s = inf t
   
   [<a name="INF_FINITE-val"><b>INF_FINITE</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ∧ s ≠ ∅ ⇒ inf s ∈ s ∧ ∀x. x ∈ s ⇒ inf s ≤ x
   
   [<a name="INF_FINITE_LEMMA-val"><b>INF_FINITE_LEMMA</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ∧ s ≠ ∅ ⇒ ∃b. b ∈ s ∧ ∀x. x ∈ s ⇒ b ≤ x
   
   [<a name="INF_GREATER-val"><b>INF_GREATER</b></a>]  Theorem
      
      ⊢ ∀p z. (∃x. x ∈ p) ∧ inf p &lt; z ⇒ ∃x. x ∈ p ∧ x &lt; z
   
   [<a name="INF_INSERT_FINITE-val"><b>INF_INSERT_FINITE</b></a>]  Theorem
      
      ⊢ ∀x s.
          FINITE s ⇒ inf (x INSERT s) = if s = ∅ then x else min x (inf s)
   
   [<a name="INF_LE-val"><b>INF_LE</b></a>]  Theorem
      
      ⊢ ∀p r. (∃z. ∀x. x ∈ p ⇒ z ≤ x) ∧ (∃x. x ∈ p ∧ x ≤ r) ⇒ inf p ≤ r
   
   [<a name="INF_SING-val"><b>INF_SING</b></a>]  Theorem
      
      ⊢ ∀a. inf {a} = a
   
   [<a name="INF_UNIQUE_FINITE-val"><b>INF_UNIQUE_FINITE</b></a>]  Theorem
      
      ⊢ ∀s a. FINITE s ∧ s ≠ ∅ ⇒ (inf s = a ⇔ a ∈ s ∧ ∀y. y ∈ s ⇒ a ≤ y)
   
   [<a name="IN_FROM-val"><b>IN_FROM</b></a>]  Theorem
      
      ⊢ ∀m n. m ∈ from n ⇔ n ≤ m
   
   [<a name="IN_NUMSEG-val"><b>IN_NUMSEG</b></a>]  Theorem
      
      ⊢ x ∈ {m .. n} ⇔ m ≤ x ∧ x ≤ n
   
   [<a name="IN_NUMSEG_0-val"><b>IN_NUMSEG_0</b></a>]  Theorem
      
      ⊢ ∀m n. m ∈ {0 .. n} ⇔ m ≤ n
   
   [<a name="IN_SUPPORT-val"><b>IN_SUPPORT</b></a>]  Theorem
      
      ⊢ ∀op f x s. x ∈ support op f s ⇔ x ∈ s ∧ f x ≠ neutral op
   
   [<a name="ITERATE_AND-val"><b>ITERATE_AND</b></a>]  Theorem
      
      ⊢ ∀p s. FINITE s ⇒ (iterate $/\ s p ⇔ ∀x. x ∈ s ⇒ p x)
   
   [<a name="ITERATE_BIJECTION-val"><b>ITERATE_BIJECTION</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          ∀f p s.
            (∀x. x ∈ s ⇒ p x ∈ s) ∧ (∀y. y ∈ s ⇒ ∃!x. x ∈ s ∧ p x = y) ⇒
            iterate op s f = iterate op s (f ∘ p)
   
   [<a name="ITERATE_CASES-val"><b>ITERATE_CASES</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          ∀s P f g.
            FINITE s ⇒
            iterate op s (λx. if P x then f x else g x) =
            op (iterate op {x | x ∈ s ∧ P x} f)
              (iterate op {x | x ∈ s ∧ ¬P x} g)
   
   [<a name="ITERATE_CLAUSES-val"><b>ITERATE_CLAUSES</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          (∀f. iterate op ∅ f = neutral op) ∧
          ∀f x s.
            FINITE s ⇒
            iterate op (x INSERT s) f =
            if x ∈ s then iterate op s f else op (f x) (iterate op s f)
   
   [<a name="ITERATE_CLAUSES_GEN-val"><b>ITERATE_CLAUSES_GEN</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          (∀f. iterate op ∅ f = neutral op) ∧
          ∀f x s.
            monoidal op ∧ FINITE (support op f s) ⇒
            iterate op (x INSERT s) f =
            if x ∈ s then iterate op s f else op (f x) (iterate op s f)
   
   [<a name="ITERATE_CLAUSES_NUMSEG-val"><b>ITERATE_CLAUSES_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          (∀m. iterate op {m .. 0} f = if m = 0 then f 0 else neutral op) ∧
          ∀m n.
            iterate op {m .. SUC n} f =
            if m ≤ SUC n then op (iterate op {m .. n} f) (f (SUC n))
            else iterate op {m .. n} f
   
   [<a name="ITERATE_CLOSED-val"><b>ITERATE_CLOSED</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          ∀P. P (neutral op) ∧ (∀x y. P x ∧ P y ⇒ P (op x y)) ⇒
              ∀f s.
                (∀x. x ∈ s ∧ f x ≠ neutral op ⇒ P (f x)) ⇒
                P (iterate op s f)
   
   [<a name="ITERATE_DELETE-val"><b>ITERATE_DELETE</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          ∀f s a.
            FINITE s ∧ a ∈ s ⇒
            op (f a) (iterate op (s DELETE a) f) = iterate op s f
   
   [<a name="ITERATE_DELTA-val"><b>ITERATE_DELTA</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          ∀f a s.
            iterate op s (λx. if x = a then f x else neutral op) =
            if a ∈ s then f a else neutral op
   
   [<a name="ITERATE_DIFF-val"><b>ITERATE_DIFF</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          ∀f s t.
            FINITE s ∧ t ⊆ s ⇒
            op (iterate op (s DIFF t) f) (iterate op t f) = iterate op s f
   
   [<a name="ITERATE_DIFF_GEN-val"><b>ITERATE_DIFF_GEN</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          ∀f s t.
            FINITE (support op f s) ∧ support op f t ⊆ support op f s ⇒
            op (iterate op (s DIFF t) f) (iterate op t f) = iterate op s f
   
   [<a name="ITERATE_EQ-val"><b>ITERATE_EQ</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          ∀f g s. (∀x. x ∈ s ⇒ f x = g x) ⇒ iterate op s f = iterate op s g
   
   [<a name="ITERATE_EQ_GENERAL-val"><b>ITERATE_EQ_GENERAL</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          ∀s t f g h.
            (∀y. y ∈ t ⇒ ∃!x. x ∈ s ∧ h x = y) ∧
            (∀x. x ∈ s ⇒ h x ∈ t ∧ g (h x) = f x) ⇒
            iterate op s f = iterate op t g
   
   [<a name="ITERATE_EQ_GENERAL_INVERSES-val"><b>ITERATE_EQ_GENERAL_INVERSES</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          ∀s t f g h k.
            (∀y. y ∈ t ⇒ k y ∈ s ∧ h (k y) = y) ∧
            (∀x. x ∈ s ⇒ h x ∈ t ∧ k (h x) = x ∧ g (h x) = f x) ⇒
            iterate op s f = iterate op t g
   
   [<a name="ITERATE_EQ_NEUTRAL-val"><b>ITERATE_EQ_NEUTRAL</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          ∀f s.
            (∀x. x ∈ s ⇒ f x = neutral op) ⇒ iterate op s f = neutral op
   
   [<a name="ITERATE_EXPAND_CASES-val"><b>ITERATE_EXPAND_CASES</b></a>]  Theorem
      
      ⊢ ∀op f s.
          iterate op s f =
          if FINITE (support op f s) then iterate op (support op f s) f
          else neutral op
   
   [<a name="ITERATE_IMAGE-val"><b>ITERATE_IMAGE</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          ∀f g s.
            (∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y) ⇒
            iterate op (IMAGE f s) g = iterate op s (g ∘ f)
   
   [<a name="ITERATE_IMAGE_NONZERO-val"><b>ITERATE_IMAGE_NONZERO</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          ∀g f s.
            FINITE s ∧
            (∀x y. x ∈ s ∧ y ∈ s ∧ x ≠ y ∧ f x = f y ⇒ g (f x) = neutral op) ⇒
            iterate op (IMAGE f s) g = iterate op s (g ∘ f)
   
   [<a name="ITERATE_INCL_EXCL-val"><b>ITERATE_INCL_EXCL</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          ∀s t f.
            FINITE s ∧ FINITE t ⇒
            op (iterate op s f) (iterate op t f) =
            op (iterate op (s ∪ t) f) (iterate op (s ∩ t) f)
   
   [<a name="ITERATE_INJECTION-val"><b>ITERATE_INJECTION</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          ∀f p s.
            FINITE s ∧ (∀x. x ∈ s ⇒ p x ∈ s) ∧
            (∀x y. x ∈ s ∧ y ∈ s ∧ p x = p y ⇒ x = y) ⇒
            iterate op s (f ∘ p) = iterate op s f
   
   [<a name="ITERATE_ITERATE_PRODUCT-val"><b>ITERATE_ITERATE_PRODUCT</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          ∀s t x.
            FINITE s ∧ (∀i. i ∈ s ⇒ FINITE (t i)) ⇒
            iterate op s (λi. iterate op (t i) (x i)) =
            iterate op {(i,j) | i ∈ s ∧ j ∈ t i} (λ(i,j). x i j)
   
   [<a name="ITERATE_NONZERO_IMAGE_LEMMA-val"><b>ITERATE_NONZERO_IMAGE_LEMMA</b></a>]  Theorem
      
      ⊢ ∀op s f g a.
          monoidal op ∧ FINITE s ∧ g a = neutral op ∧
          (∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ∧ x ≠ y ⇒ g (f x) = neutral op) ⇒
          iterate op {f x | x | x ∈ s ∧ f x ≠ a} g = iterate op s (g ∘ f)
   
   [<a name="ITERATE_OP-val"><b>ITERATE_OP</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          ∀f g s.
            FINITE s ⇒
            iterate op s (λx. op (f x) (g x)) =
            op (iterate op s f) (iterate op s g)
   
   [<a name="ITERATE_OP_GEN-val"><b>ITERATE_OP_GEN</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          ∀f g s.
            FINITE (support op f s) ∧ FINITE (support op g s) ⇒
            iterate op s (λx. op (f x) (g x)) =
            op (iterate op s f) (iterate op s g)
   
   [<a name="ITERATE_PAIR-val"><b>ITERATE_PAIR</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          ∀f m n.
            iterate op {2 * m .. 2 * n + 1} f =
            iterate op {m .. n} (λi. op (f (2 * i)) (f (2 * i + 1)))
   
   [<a name="ITERATE_PERMUTE-val"><b>ITERATE_PERMUTE</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          ∀f p s. p permutes s ⇒ iterate op s f = iterate op s (f ∘ p)
   
   [<a name="ITERATE_PERMUTES-val"><b>ITERATE_PERMUTES</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          ∀f p s. p PERMUTES s ⇒ iterate op s f = iterate op s (f ∘ p)
   
   [<a name="ITERATE_RELATED-val"><b>ITERATE_RELATED</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          ∀R. R (neutral op) (neutral op) ∧
              (∀x1 y1 x2 y2. R x1 x2 ∧ R y1 y2 ⇒ R (op x1 y1) (op x2 y2)) ⇒
              ∀f g s.
                FINITE s ∧ (∀x. x ∈ s ⇒ R (f x) (g x)) ⇒
                R (iterate op s f) (iterate op s g)
   
   [<a name="ITERATE_SING-val"><b>ITERATE_SING</b></a>]  Theorem
      
      ⊢ ∀op. monoidal op ⇒ ∀f x. iterate op {x} f = f x
   
   [<a name="ITERATE_SOME-val"><b>ITERATE_SOME</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          ∀f s.
            FINITE s ⇒
            iterate (lifted op) s (λx. SOME (f x)) = SOME (iterate op s f)
   
   [<a name="ITERATE_SUPERSET-val"><b>ITERATE_SUPERSET</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          ∀f u v.
            u ⊆ v ∧ (∀x. x ∈ v ∧ x ∉ u ⇒ f x = neutral op) ⇒
            iterate op v f = iterate op u f
   
   [<a name="ITERATE_SUPPORT-val"><b>ITERATE_SUPPORT</b></a>]  Theorem
      
      ⊢ ∀op f s. iterate op (support op f s) f = iterate op s f
   
   [<a name="ITERATE_UNION-val"><b>ITERATE_UNION</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          ∀f s t.
            FINITE s ∧ FINITE t ∧ DISJOINT s t ⇒
            iterate op (s ∪ t) f = op (iterate op s f) (iterate op t f)
   
   [<a name="ITERATE_UNION_GEN-val"><b>ITERATE_UNION_GEN</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          ∀f s t.
            FINITE (support op f s) ∧ FINITE (support op f t) ∧
            DISJOINT (support op f s) (support op f t) ⇒
            iterate op (s ∪ t) f = op (iterate op s f) (iterate op t f)
   
   [<a name="ITERATE_UNION_NONZERO-val"><b>ITERATE_UNION_NONZERO</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          ∀f s t.
            FINITE s ∧ FINITE t ∧ (∀x. x ∈ s ∩ t ⇒ f x = neutral op) ⇒
            iterate op (s ∪ t) f = op (iterate op s f) (iterate op t f)
   
   [<a name="ITSET_alt-val"><b>ITSET_alt</b></a>]  Theorem
      
      ⊢ ∀f s b.
          (∀x y z. f x (f y z) = f y (f x z)) ∧ FINITE s ⇒
          ITSET f s b =
          (@g. g ∅ = b ∧
               ∀x s.
                 FINITE s ⇒
                 g (x INSERT s) = if x ∈ s then g s else f x (g s)) s
   
   [<a name="LAMBDA_PAIR-val"><b>LAMBDA_PAIR</b></a>]  Theorem
      
      ⊢ (λ(x,y). P x y) = (λp. P (FST p) (SND p))
   
   [<a name="LE_ADD-val"><b>LE_ADD</b></a>]  Theorem
      
      ⊢ ∀m n. m ≤ m + n
   
   [<a name="LE_ADDR-val"><b>LE_ADDR</b></a>]  Theorem
      
      ⊢ ∀m n. n ≤ m + n
   
   [<a name="LE_EXISTS-val"><b>LE_EXISTS</b></a>]  Theorem
      
      ⊢ ∀m n. m ≤ n ⇔ ∃d. n = m + d
   
   [<a name="LE_INF-val"><b>LE_INF</b></a>]  Theorem
      
      ⊢ ∀p r. (∃x. x ∈ p) ∧ (∀x. x ∈ p ⇒ r ≤ x) ⇒ r ≤ inf p
   
   [<a name="LOWER_BOUND_FINITE_SET_REAL-val"><b>LOWER_BOUND_FINITE_SET_REAL</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ⇒ ∃a. ∀x. x ∈ s ⇒ a ≤ f x
   
   [<a name="LT_EXISTS-val"><b>LT_EXISTS</b></a>]  Theorem
      
      ⊢ ∀m n. m &lt; n ⇔ ∃d. n = m + SUC d
   
   [<a name="MOD_NSUM_MOD-val"><b>MOD_NSUM_MOD</b></a>]  Theorem
      
      ⊢ ∀f n s.
          FINITE s ∧ n ≠ 0 ⇒ nsum s f MOD n = nsum s (λi. f i MOD n) MOD n
   
   [<a name="MOD_NSUM_MOD_NUMSEG-val"><b>MOD_NSUM_MOD_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f a b n.
          n ≠ 0 ⇒
          nsum {a .. b} f MOD n = nsum {a .. b} (λi. f i MOD n) MOD n
   
   [<a name="MONOIDAL_AC-val"><b>MONOIDAL_AC</b></a>]  Theorem
      
      ⊢ ∀op.
          monoidal op ⇒
          (∀a. op (neutral op) a = a) ∧ (∀a. op a (neutral op) = a) ∧
          (∀a b. op a b = op b a) ∧
          (∀a b c. op (op a b) c = op a (op b c)) ∧
          ∀a b c. op a (op b c) = op b (op a c)
   
   [<a name="MONOIDAL_ADD-val"><b>MONOIDAL_ADD</b></a>]  Theorem
      
      ⊢ monoidal $+
   
   [<a name="MONOIDAL_AND-val"><b>MONOIDAL_AND</b></a>]  Theorem
      
      ⊢ monoidal $/\
   
   [<a name="MONOIDAL_LIFTED-val"><b>MONOIDAL_LIFTED</b></a>]  Theorem
      
      ⊢ ∀op. monoidal op ⇒ monoidal (lifted op)
   
   [<a name="MONOIDAL_MUL-val"><b>MONOIDAL_MUL</b></a>]  Theorem
      
      ⊢ monoidal $*
   
   [<a name="MONOIDAL_REAL_ADD-val"><b>MONOIDAL_REAL_ADD</b></a>]  Theorem
      
      ⊢ monoidal $+
   
   [<a name="MONOIDAL_REAL_MUL-val"><b>MONOIDAL_REAL_MUL</b></a>]  Theorem
      
      ⊢ monoidal $*
   
   [<a name="NEUTRAL_ADD-val"><b>NEUTRAL_ADD</b></a>]  Theorem
      
      ⊢ neutral $+ = 0
   
   [<a name="NEUTRAL_AND-val"><b>NEUTRAL_AND</b></a>]  Theorem
      
      ⊢ neutral $/\ ⇔ T
   
   [<a name="NEUTRAL_LIFTED-val"><b>NEUTRAL_LIFTED</b></a>]  Theorem
      
      ⊢ ∀op. monoidal op ⇒ neutral (lifted op) = SOME (neutral op)
   
   [<a name="NEUTRAL_MUL-val"><b>NEUTRAL_MUL</b></a>]  Theorem
      
      ⊢ neutral $* = 1
   
   [<a name="NEUTRAL_REAL_ADD-val"><b>NEUTRAL_REAL_ADD</b></a>]  Theorem
      
      ⊢ neutral $+ = 0
   
   [<a name="NEUTRAL_REAL_MUL-val"><b>NEUTRAL_REAL_MUL</b></a>]  Theorem
      
      ⊢ neutral $* = 1
   
   [<a name="NOT_EQ-val"><b>NOT_EQ</b></a>]  Theorem
      
      ⊢ ∀a b. a ≠ b ⇔ a ≠ b
   
   [<a name="NPRODUCT_ADD_SPLIT-val"><b>NPRODUCT_ADD_SPLIT</b></a>]  Theorem
      
      ⊢ ∀f m n p.
          m ≤ n + 1 ⇒
          nproduct {m .. n + p} f =
          nproduct {m .. n} f * nproduct {n + 1 .. n + p} f
   
   [<a name="NPRODUCT_CLAUSES-val"><b>NPRODUCT_CLAUSES</b></a>]  Theorem
      
      ⊢ (∀f. nproduct ∅ f = 1) ∧
        ∀x f s.
          FINITE s ⇒
          nproduct (x INSERT s) f =
          if x ∈ s then nproduct s f else f x * nproduct s f
   
   [<a name="NPRODUCT_CLAUSES_LEFT-val"><b>NPRODUCT_CLAUSES_LEFT</b></a>]  Theorem
      
      ⊢ ∀f m n. m ≤ n ⇒ nproduct {m .. n} f = f m * nproduct {m + 1 .. n} f
   
   [<a name="NPRODUCT_CLAUSES_NUMSEG-val"><b>NPRODUCT_CLAUSES_NUMSEG</b></a>]  Theorem
      
      ⊢ (∀m. nproduct {m .. 0} f = if m = 0 then f 0 else 1) ∧
        ∀m n.
          nproduct {m .. SUC n} f =
          if m ≤ SUC n then nproduct {m .. n} f * f (SUC n)
          else nproduct {m .. n} f
   
   [<a name="NPRODUCT_CLAUSES_RIGHT-val"><b>NPRODUCT_CLAUSES_RIGHT</b></a>]  Theorem
      
      ⊢ ∀f m n.
          0 &lt; n ∧ m ≤ n ⇒
          nproduct {m .. n} f = nproduct {m .. n − 1} f * f n
   
   [<a name="NPRODUCT_CLOSED-val"><b>NPRODUCT_CLOSED</b></a>]  Theorem
      
      ⊢ ∀P f s.
          P 1 ∧ (∀x y. P x ∧ P y ⇒ P (x * y)) ∧ (∀a. a ∈ s ⇒ P (f a)) ⇒
          P (nproduct s f)
   
   [<a name="NPRODUCT_CONG-val"><b>NPRODUCT_CONG</b></a>]  Theorem
      
      ⊢ (∀f g s.
           (∀x. x ∈ s ⇒ f x = g x) ⇒ nproduct s (λi. f i) = nproduct s g) ∧
        (∀f g a b.
           (∀i. a ≤ i ∧ i ≤ b ⇒ f i = g i) ⇒
           nproduct {a .. b} (λi. f i) = nproduct {a .. b} g) ∧
        ∀f g p.
          (∀x. p x ⇒ f x = g x) ⇒
          nproduct {y | p y} (λi. f i) = nproduct {y | p y} g
   
   [<a name="NPRODUCT_CONST-val"><b>NPRODUCT_CONST</b></a>]  Theorem
      
      ⊢ ∀c s. FINITE s ⇒ nproduct s (λx. c) = c ** CARD s
   
   [<a name="NPRODUCT_CONST_NUMSEG-val"><b>NPRODUCT_CONST_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀c m n. nproduct {m .. n} (λx. c) = c ** (n + 1 − m)
   
   [<a name="NPRODUCT_CONST_NUMSEG_1-val"><b>NPRODUCT_CONST_NUMSEG_1</b></a>]  Theorem
      
      ⊢ ∀c n. nproduct {1 .. n} (λx. c) = c ** n
   
   [<a name="NPRODUCT_DELETE-val"><b>NPRODUCT_DELETE</b></a>]  Theorem
      
      ⊢ ∀f s a.
          FINITE s ∧ a ∈ s ⇒ f a * nproduct (s DELETE a) f = nproduct s f
   
   [<a name="NPRODUCT_DELTA-val"><b>NPRODUCT_DELTA</b></a>]  Theorem
      
      ⊢ ∀s a.
          nproduct s (λx. if x = a then b else 1) = if a ∈ s then b else 1
   
   [<a name="NPRODUCT_EQ-val"><b>NPRODUCT_EQ</b></a>]  Theorem
      
      ⊢ ∀f g s. (∀x. x ∈ s ⇒ f x = g x) ⇒ nproduct s f = nproduct s g
   
   [<a name="NPRODUCT_EQ_0-val"><b>NPRODUCT_EQ_0</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ⇒ (nproduct s f = 0 ⇔ ∃x. x ∈ s ∧ f x = 0)
   
   [<a name="NPRODUCT_EQ_0_NUMSEG-val"><b>NPRODUCT_EQ_0_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n. nproduct {m .. n} f = 0 ⇔ ∃x. m ≤ x ∧ x ≤ n ∧ f x = 0
   
   [<a name="NPRODUCT_EQ_1-val"><b>NPRODUCT_EQ_1</b></a>]  Theorem
      
      ⊢ ∀f s. (∀x. x ∈ s ⇒ f x = 1) ⇒ nproduct s f = 1
   
   [<a name="NPRODUCT_EQ_1_NUMSEG-val"><b>NPRODUCT_EQ_1_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n. (∀i. m ≤ i ∧ i ≤ n ⇒ f i = 1) ⇒ nproduct {m .. n} f = 1
   
   [<a name="NPRODUCT_EQ_NUMSEG-val"><b>NPRODUCT_EQ_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f g m n.
          (∀i. m ≤ i ∧ i ≤ n ⇒ f i = g i) ⇒
          nproduct {m .. n} f = nproduct {m .. n} g
   
   [<a name="NPRODUCT_FACT-val"><b>NPRODUCT_FACT</b></a>]  Theorem
      
      ⊢ ∀n. nproduct {1 .. n} (λm. m) = FACT n
   
   [<a name="NPRODUCT_IMAGE-val"><b>NPRODUCT_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f g s.
          (∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y) ⇒
          nproduct (IMAGE f s) g = nproduct s (g ∘ f)
   
   [<a name="NPRODUCT_LE-val"><b>NPRODUCT_LE</b></a>]  Theorem
      
      ⊢ ∀f s.
          FINITE s ∧ (∀x. x ∈ s ⇒ 0 ≤ f x ∧ f x ≤ g x) ⇒
          nproduct s f ≤ nproduct s g
   
   [<a name="NPRODUCT_LE_NUMSEG-val"><b>NPRODUCT_LE_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n.
          (∀i. m ≤ i ∧ i ≤ n ⇒ 0 ≤ f i ∧ f i ≤ g i) ⇒
          nproduct {m .. n} f ≤ nproduct {m .. n} g
   
   [<a name="NPRODUCT_MUL-val"><b>NPRODUCT_MUL</b></a>]  Theorem
      
      ⊢ ∀f g s.
          FINITE s ⇒
          nproduct s (λx. f x * g x) = nproduct s f * nproduct s g
   
   [<a name="NPRODUCT_MUL_GEN-val"><b>NPRODUCT_MUL_GEN</b></a>]  Theorem
      
      ⊢ ∀f g s.
          FINITE {x | x ∈ s ∧ f x ≠ 1} ∧ FINITE {x | x ∈ s ∧ g x ≠ 1} ⇒
          nproduct s (λx. f x * g x) = nproduct s f * nproduct s g
   
   [<a name="NPRODUCT_MUL_NUMSEG-val"><b>NPRODUCT_MUL_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f g m n.
          nproduct {m .. n} (λx. f x * g x) =
          nproduct {m .. n} f * nproduct {m .. n} g
   
   [<a name="NPRODUCT_OFFSET-val"><b>NPRODUCT_OFFSET</b></a>]  Theorem
      
      ⊢ ∀f m p.
          nproduct {m + p .. n + p} f = nproduct {m .. n} (λi. f (i + p))
   
   [<a name="NPRODUCT_ONE-val"><b>NPRODUCT_ONE</b></a>]  Theorem
      
      ⊢ ∀s. nproduct s (λn. 1) = 1
   
   [<a name="NPRODUCT_PAIR-val"><b>NPRODUCT_PAIR</b></a>]  Theorem
      
      ⊢ ∀f m n.
          nproduct {2 * m .. 2 * n + 1} f =
          nproduct {m .. n} (λi. f (2 * i) * f (2 * i + 1))
   
   [<a name="NPRODUCT_POS_LT-val"><b>NPRODUCT_POS_LT</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ∧ (∀x. x ∈ s ⇒ 0 &lt; f x) ⇒ 0 &lt; nproduct s f
   
   [<a name="NPRODUCT_POS_LT_NUMSEG-val"><b>NPRODUCT_POS_LT_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n. (∀x. m ≤ x ∧ x ≤ n ⇒ 0 &lt; f x) ⇒ 0 &lt; nproduct {m .. n} f
   
   [<a name="NPRODUCT_SING-val"><b>NPRODUCT_SING</b></a>]  Theorem
      
      ⊢ ∀f x. nproduct {x} f = f x
   
   [<a name="NPRODUCT_SING_NUMSEG-val"><b>NPRODUCT_SING_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f n. nproduct {n .. n} f = f n
   
   [<a name="NPRODUCT_SUPERSET-val"><b>NPRODUCT_SUPERSET</b></a>]  Theorem
      
      ⊢ ∀f u v.
          u ⊆ v ∧ (∀x. x ∈ v ∧ x ∉ u ⇒ f x = 1) ⇒
          nproduct v f = nproduct u f
   
   [<a name="NPRODUCT_SUPPORT-val"><b>NPRODUCT_SUPPORT</b></a>]  Theorem
      
      ⊢ ∀f s. nproduct (support $* f s) f = nproduct s f
   
   [<a name="NPRODUCT_UNION-val"><b>NPRODUCT_UNION</b></a>]  Theorem
      
      ⊢ ∀f s t.
          FINITE s ∧ FINITE t ∧ DISJOINT s t ⇒
          nproduct (s ∪ t) f = nproduct s f * nproduct t f
   
   [<a name="NSUM_0-val"><b>NSUM_0</b></a>]  Theorem
      
      ⊢ ∀s. nsum s (λn. 0) = 0
   
   [<a name="NSUM_ADD-val"><b>NSUM_ADD</b></a>]  Theorem
      
      ⊢ ∀f g s. FINITE s ⇒ nsum s (λx. f x + g x) = nsum s f + nsum s g
   
   [<a name="NSUM_ADD_GEN-val"><b>NSUM_ADD_GEN</b></a>]  Theorem
      
      ⊢ ∀f g s.
          FINITE {x | x ∈ s ∧ f x ≠ 0} ∧ FINITE {x | x ∈ s ∧ g x ≠ 0} ⇒
          nsum s (λx. f x + g x) = nsum s f + nsum s g
   
   [<a name="NSUM_ADD_NUMSEG-val"><b>NSUM_ADD_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f g m n.
          nsum {m .. n} (λi. f i + g i) = nsum {m .. n} f + nsum {m .. n} g
   
   [<a name="NSUM_ADD_SPLIT-val"><b>NSUM_ADD_SPLIT</b></a>]  Theorem
      
      ⊢ ∀f m n p.
          m ≤ n + 1 ⇒
          nsum {m .. n + p} f = nsum {m .. n} f + nsum {n + 1 .. n + p} f
   
   [<a name="NSUM_BIGUNION_NONZERO-val"><b>NSUM_BIGUNION_NONZERO</b></a>]  Theorem
      
      ⊢ ∀f s.
          FINITE s ∧ (∀t. t ∈ s ⇒ FINITE t) ∧
          (∀t1 t2 x. t1 ∈ s ∧ t2 ∈ s ∧ t1 ≠ t2 ∧ x ∈ t1 ∧ x ∈ t2 ⇒ f x = 0) ⇒
          nsum (BIGUNION s) f = nsum s (λt. nsum t f)
   
   [<a name="NSUM_BIJECTION-val"><b>NSUM_BIJECTION</b></a>]  Theorem
      
      ⊢ ∀f p s.
          (∀x. x ∈ s ⇒ p x ∈ s) ∧ (∀y. y ∈ s ⇒ ∃!x. x ∈ s ∧ p x = y) ⇒
          nsum s f = nsum s (f ∘ p)
   
   [<a name="NSUM_BOUND-val"><b>NSUM_BOUND</b></a>]  Theorem
      
      ⊢ ∀s f b. FINITE s ∧ (∀x. x ∈ s ⇒ f x ≤ b) ⇒ nsum s f ≤ CARD s * b
   
   [<a name="NSUM_BOUND_GEN-val"><b>NSUM_BOUND_GEN</b></a>]  Theorem
      
      ⊢ ∀s f b.
          FINITE s ∧ s ≠ ∅ ∧ (∀x. x ∈ s ⇒ f x ≤ b DIV CARD s) ⇒
          nsum s f ≤ b
   
   [<a name="NSUM_BOUND_LT-val"><b>NSUM_BOUND_LT</b></a>]  Theorem
      
      ⊢ ∀s f b.
          FINITE s ∧ (∀x. x ∈ s ⇒ f x ≤ b) ∧ (∃x. x ∈ s ∧ f x &lt; b) ⇒
          nsum s f &lt; CARD s * b
   
   [<a name="NSUM_BOUND_LT_ALL-val"><b>NSUM_BOUND_LT_ALL</b></a>]  Theorem
      
      ⊢ ∀s f b.
          FINITE s ∧ s ≠ ∅ ∧ (∀x. x ∈ s ⇒ f x &lt; b) ⇒ nsum s f &lt; CARD s * b
   
   [<a name="NSUM_BOUND_LT_GEN-val"><b>NSUM_BOUND_LT_GEN</b></a>]  Theorem
      
      ⊢ ∀s f b.
          FINITE s ∧ s ≠ ∅ ∧ (∀x. x ∈ s ⇒ f x &lt; b DIV CARD s) ⇒
          nsum s f &lt; b
   
   [<a name="NSUM_CASES-val"><b>NSUM_CASES</b></a>]  Theorem
      
      ⊢ ∀s P f g.
          FINITE s ⇒
          nsum s (λx. if P x then f x else g x) =
          nsum {x | x ∈ s ∧ P x} f + nsum {x | x ∈ s ∧ ¬P x} g
   
   [<a name="NSUM_CLAUSES-val"><b>NSUM_CLAUSES</b></a>]  Theorem
      
      ⊢ (∀f. nsum ∅ f = 0) ∧
        ∀x f s.
          FINITE s ⇒
          nsum (x INSERT s) f = if x ∈ s then nsum s f else f x + nsum s f
   
   [<a name="NSUM_CLAUSES_LEFT-val"><b>NSUM_CLAUSES_LEFT</b></a>]  Theorem
      
      ⊢ ∀f m n. m ≤ n ⇒ nsum {m .. n} f = f m + nsum {m + 1 .. n} f
   
   [<a name="NSUM_CLAUSES_NUMSEG-val"><b>NSUM_CLAUSES_NUMSEG</b></a>]  Theorem
      
      ⊢ (∀m. nsum {m .. 0} f = if m = 0 then f 0 else 0) ∧
        ∀m n.
          nsum {m .. SUC n} f =
          if m ≤ SUC n then nsum {m .. n} f + f (SUC n)
          else nsum {m .. n} f
   
   [<a name="NSUM_CLAUSES_RIGHT-val"><b>NSUM_CLAUSES_RIGHT</b></a>]  Theorem
      
      ⊢ ∀f m n. 0 &lt; n ∧ m ≤ n ⇒ nsum {m .. n} f = nsum {m .. n − 1} f + f n
   
   [<a name="NSUM_CLOSED-val"><b>NSUM_CLOSED</b></a>]  Theorem
      
      ⊢ ∀P f s.
          P 0 ∧ (∀x y. P x ∧ P y ⇒ P (x + y)) ∧ (∀a. a ∈ s ⇒ P (f a)) ⇒
          P (nsum s f)
   
   [<a name="NSUM_CONG-val"><b>NSUM_CONG</b></a>]  Theorem
      
      ⊢ (∀f g s. (∀x. x ∈ s ⇒ f x = g x) ⇒ nsum s (λi. f i) = nsum s g) ∧
        (∀f g a b.
           (∀i. a ≤ i ∧ i ≤ b ⇒ f i = g i) ⇒
           nsum {a .. b} (λi. f i) = nsum {a .. b} g) ∧
        ∀f g p.
          (∀x. p x ⇒ f x = g x) ⇒
          nsum {y | p y} (λi. f i) = nsum {y | p y} g
   
   [<a name="NSUM_CONST-val"><b>NSUM_CONST</b></a>]  Theorem
      
      ⊢ ∀c s. FINITE s ⇒ nsum s (λn. c) = CARD s * c
   
   [<a name="NSUM_CONST_NUMSEG-val"><b>NSUM_CONST_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀c m n. nsum {m .. n} (λn. c) = (n + 1 − m) * c
   
   [<a name="NSUM_DEGENERATE-val"><b>NSUM_DEGENERATE</b></a>]  Theorem
      
      ⊢ ∀f s. INFINITE {x | x ∈ s ∧ f x ≠ 0} ⇒ nsum s f = 0
   
   [<a name="NSUM_DELETE-val"><b>NSUM_DELETE</b></a>]  Theorem
      
      ⊢ ∀f s a. FINITE s ∧ a ∈ s ⇒ f a + nsum (s DELETE a) f = nsum s f
   
   [<a name="NSUM_DELTA-val"><b>NSUM_DELTA</b></a>]  Theorem
      
      ⊢ ∀s a. nsum s (λx. if x = a then b else 0) = if a ∈ s then b else 0
   
   [<a name="NSUM_DIFF-val"><b>NSUM_DIFF</b></a>]  Theorem
      
      ⊢ ∀f s t. FINITE s ∧ t ⊆ s ⇒ nsum (s DIFF t) f = nsum s f − nsum t f
   
   [<a name="NSUM_EQ-val"><b>NSUM_EQ</b></a>]  Theorem
      
      ⊢ ∀f g s. (∀x. x ∈ s ⇒ f x = g x) ⇒ nsum s f = nsum s g
   
   [<a name="NSUM_EQ_0-val"><b>NSUM_EQ_0</b></a>]  Theorem
      
      ⊢ ∀f s. (∀x. x ∈ s ⇒ f x = 0) ⇒ nsum s f = 0
   
   [<a name="NSUM_EQ_0_IFF-val"><b>NSUM_EQ_0_IFF</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ (nsum s f = 0 ⇔ ∀x. x ∈ s ⇒ f x = 0)
   
   [<a name="NSUM_EQ_0_IFF_NUMSEG-val"><b>NSUM_EQ_0_IFF_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n. nsum {m .. n} f = 0 ⇔ ∀i. m ≤ i ∧ i ≤ n ⇒ f i = 0
   
   [<a name="NSUM_EQ_0_NUMSEG-val"><b>NSUM_EQ_0_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n. (∀i. m ≤ i ∧ i ≤ n ⇒ f i = 0) ⇒ nsum {m .. n} f = 0
   
   [<a name="NSUM_EQ_GENERAL-val"><b>NSUM_EQ_GENERAL</b></a>]  Theorem
      
      ⊢ ∀s t f g h.
          (∀y. y ∈ t ⇒ ∃!x. x ∈ s ∧ h x = y) ∧
          (∀x. x ∈ s ⇒ h x ∈ t ∧ g (h x) = f x) ⇒
          nsum s f = nsum t g
   
   [<a name="NSUM_EQ_GENERAL_INVERSES-val"><b>NSUM_EQ_GENERAL_INVERSES</b></a>]  Theorem
      
      ⊢ ∀s t f g h k.
          (∀y. y ∈ t ⇒ k y ∈ s ∧ h (k y) = y) ∧
          (∀x. x ∈ s ⇒ h x ∈ t ∧ k (h x) = x ∧ g (h x) = f x) ⇒
          nsum s f = nsum t g
   
   [<a name="NSUM_EQ_NUMSEG-val"><b>NSUM_EQ_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f g m n.
          (∀i. m ≤ i ∧ i ≤ n ⇒ f i = g i) ⇒
          nsum {m .. n} f = nsum {m .. n} g
   
   [<a name="NSUM_EQ_SUPERSET-val"><b>NSUM_EQ_SUPERSET</b></a>]  Theorem
      
      ⊢ ∀f s t.
          FINITE t ∧ t ⊆ s ∧ (∀x. x ∈ t ⇒ f x = g x) ∧
          (∀x. x ∈ s ∧ x ∉ t ⇒ f x = 0) ⇒
          nsum s f = nsum t g
   
   [<a name="NSUM_GROUP-val"><b>NSUM_GROUP</b></a>]  Theorem
      
      ⊢ ∀f g s t.
          FINITE s ∧ IMAGE f s ⊆ t ⇒
          nsum t (λy. nsum {x | x ∈ s ∧ f x = y} g) = nsum s g
   
   [<a name="NSUM_IMAGE-val"><b>NSUM_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f g s.
          (∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y) ⇒
          nsum (IMAGE f s) g = nsum s (g ∘ f)
   
   [<a name="NSUM_IMAGE_GEN-val"><b>NSUM_IMAGE_GEN</b></a>]  Theorem
      
      ⊢ ∀f g s.
          FINITE s ⇒
          nsum s g = nsum (IMAGE f s) (λy. nsum {x | x ∈ s ∧ f x = y} g)
   
   [<a name="NSUM_IMAGE_NONZERO-val"><b>NSUM_IMAGE_NONZERO</b></a>]  Theorem
      
      ⊢ ∀d i s.
          FINITE s ∧
          (∀x y. x ∈ s ∧ y ∈ s ∧ x ≠ y ∧ i x = i y ⇒ d (i x) = 0) ⇒
          nsum (IMAGE i s) d = nsum s (d ∘ i)
   
   [<a name="NSUM_INCL_EXCL-val"><b>NSUM_INCL_EXCL</b></a>]  Theorem
      
      ⊢ ∀s t f.
          FINITE s ∧ FINITE t ⇒
          nsum s f + nsum t f = nsum (s ∪ t) f + nsum (s ∩ t) f
   
   [<a name="NSUM_INJECTION-val"><b>NSUM_INJECTION</b></a>]  Theorem
      
      ⊢ ∀f p s.
          FINITE s ∧ (∀x. x ∈ s ⇒ p x ∈ s) ∧
          (∀x y. x ∈ s ∧ y ∈ s ∧ p x = p y ⇒ x = y) ⇒
          nsum s (f ∘ p) = nsum s f
   
   [<a name="NSUM_LE-val"><b>NSUM_LE</b></a>]  Theorem
      
      ⊢ ∀f g s. FINITE s ∧ (∀x. x ∈ s ⇒ f x ≤ g x) ⇒ nsum s f ≤ nsum s g
   
   [<a name="NSUM_LE_GEN-val"><b>NSUM_LE_GEN</b></a>]  Theorem
      
      ⊢ ∀f g s.
          (∀x. x ∈ s ⇒ f x ≤ g x) ∧ FINITE {x | x ∈ s ∧ g x ≠ 0} ⇒
          nsum s f ≤ nsum s g
   
   [<a name="NSUM_LE_NUMSEG-val"><b>NSUM_LE_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f g m n.
          (∀i. m ≤ i ∧ i ≤ n ⇒ f i ≤ g i) ⇒
          nsum {m .. n} f ≤ nsum {m .. n} g
   
   [<a name="NSUM_LMUL-val"><b>NSUM_LMUL</b></a>]  Theorem
      
      ⊢ ∀f c s. nsum s (λx. c * f x) = c * nsum s f
   
   [<a name="NSUM_LT-val"><b>NSUM_LT</b></a>]  Theorem
      
      ⊢ ∀f g s.
          FINITE s ∧ (∀x. x ∈ s ⇒ f x ≤ g x) ∧ (∃x. x ∈ s ∧ f x &lt; g x) ⇒
          nsum s f &lt; nsum s g
   
   [<a name="NSUM_LT_ALL-val"><b>NSUM_LT_ALL</b></a>]  Theorem
      
      ⊢ ∀f g s.
          FINITE s ∧ s ≠ ∅ ∧ (∀x. x ∈ s ⇒ f x &lt; g x) ⇒ nsum s f &lt; nsum s g
   
   [<a name="NSUM_MULTICOUNT-val"><b>NSUM_MULTICOUNT</b></a>]  Theorem
      
      ⊢ ∀R s t k.
          FINITE s ∧ FINITE t ∧ (∀j. j ∈ t ⇒ CARD {i | i ∈ s ∧ R i j} = k) ⇒
          nsum s (λi. CARD (equiv_class R t i)) = k * CARD t
   
   [<a name="NSUM_MULTICOUNT_GEN-val"><b>NSUM_MULTICOUNT_GEN</b></a>]  Theorem
      
      ⊢ ∀R s t k.
          FINITE s ∧ FINITE t ∧
          (∀j. j ∈ t ⇒ CARD {i | i ∈ s ∧ R i j} = k j) ⇒
          nsum s (λi. CARD (equiv_class R t i)) = nsum t (λi. k i)
   
   [<a name="NSUM_NSUM_PRODUCT-val"><b>NSUM_NSUM_PRODUCT</b></a>]  Theorem
      
      ⊢ ∀s t x.
          FINITE s ∧ (∀i. i ∈ s ⇒ FINITE (t i)) ⇒
          nsum s (λi. nsum (t i) (x i)) =
          nsum {(i,j) | i ∈ s ∧ j ∈ t i} (λ(i,j). x i j)
   
   [<a name="NSUM_NSUM_RESTRICT-val"><b>NSUM_NSUM_RESTRICT</b></a>]  Theorem
      
      ⊢ ∀R f s t.
          FINITE s ∧ FINITE t ⇒
          nsum s (λx. nsum (equiv_class R t x) (λy. f x y)) =
          nsum t (λy. nsum {x | x ∈ s ∧ R x y} (λx. f x y))
   
   [<a name="NSUM_OFFSET-val"><b>NSUM_OFFSET</b></a>]  Theorem
      
      ⊢ ∀p f m n. nsum {m + p .. n + p} f = nsum {m .. n} (λi. f (i + p))
   
   [<a name="NSUM_OFFSET_0-val"><b>NSUM_OFFSET_0</b></a>]  Theorem
      
      ⊢ ∀f m n. m ≤ n ⇒ nsum {m .. n} f = nsum {0 .. n − m} (λi. f (i + m))
   
   [<a name="NSUM_PAIR-val"><b>NSUM_PAIR</b></a>]  Theorem
      
      ⊢ ∀f m n.
          nsum {2 * m .. 2 * n + 1} f =
          nsum {m .. n} (λi. f (2 * i) + f (2 * i + 1))
   
   [<a name="NSUM_PERMUTE-val"><b>NSUM_PERMUTE</b></a>]  Theorem
      
      ⊢ ∀f p s. p permutes s ⇒ nsum s f = nsum s (f ∘ p)
   
   [<a name="NSUM_PERMUTE_COUNT-val"><b>NSUM_PERMUTE_COUNT</b></a>]  Theorem
      
      ⊢ ∀f p n.
          p permutes count n ⇒ nsum (count n) f = nsum (count n) (f ∘ p)
   
   [<a name="NSUM_PERMUTE_NUMSEG-val"><b>NSUM_PERMUTE_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f p m n.
          p permutes count n DIFF count m ⇒
          nsum (count n DIFF count m) f =
          nsum (count n DIFF count m) (f ∘ p)
   
   [<a name="NSUM_POS_BOUND-val"><b>NSUM_POS_BOUND</b></a>]  Theorem
      
      ⊢ ∀f b s. FINITE s ∧ nsum s f ≤ b ⇒ ∀x. x ∈ s ⇒ f x ≤ b
   
   [<a name="NSUM_POS_LT-val"><b>NSUM_POS_LT</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ∧ (∃x. x ∈ s ∧ 0 &lt; f x) ⇒ 0 &lt; nsum s f
   
   [<a name="NSUM_POS_LT_ALL-val"><b>NSUM_POS_LT_ALL</b></a>]  Theorem
      
      ⊢ ∀s f. FINITE s ∧ s ≠ ∅ ∧ (∀i. i ∈ s ⇒ 0 &lt; f i) ⇒ 0 &lt; nsum s f
   
   [<a name="NSUM_RESTRICT-val"><b>NSUM_RESTRICT</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ⇒ nsum s (λx. if x ∈ s then f x else 0) = nsum s f
   
   [<a name="NSUM_RESTRICT_SET-val"><b>NSUM_RESTRICT_SET</b></a>]  Theorem
      
      ⊢ ∀P s f.
          nsum {x | x ∈ s ∧ P x} f = nsum s (λx. if P x then f x else 0)
   
   [<a name="NSUM_RMUL-val"><b>NSUM_RMUL</b></a>]  Theorem
      
      ⊢ ∀f c s. nsum s (λx. f x * c) = nsum s f * c
   
   [<a name="NSUM_SING-val"><b>NSUM_SING</b></a>]  Theorem
      
      ⊢ ∀f x. nsum {x} f = f x
   
   [<a name="NSUM_SING_NUMSEG-val"><b>NSUM_SING_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f n. nsum {n .. n} f = f n
   
   [<a name="NSUM_SUBSET-val"><b>NSUM_SUBSET</b></a>]  Theorem
      
      ⊢ ∀u v f.
          FINITE u ∧ FINITE v ∧ (∀x. x ∈ u DIFF v ⇒ f x = 0) ⇒
          nsum u f ≤ nsum v f
   
   [<a name="NSUM_SUBSET_SIMPLE-val"><b>NSUM_SUBSET_SIMPLE</b></a>]  Theorem
      
      ⊢ ∀u v f. FINITE v ∧ u ⊆ v ⇒ nsum u f ≤ nsum v f
   
   [<a name="NSUM_SUPERSET-val"><b>NSUM_SUPERSET</b></a>]  Theorem
      
      ⊢ ∀f u v. u ⊆ v ∧ (∀x. x ∈ v ∧ x ∉ u ⇒ f x = 0) ⇒ nsum v f = nsum u f
   
   [<a name="NSUM_SUPPORT-val"><b>NSUM_SUPPORT</b></a>]  Theorem
      
      ⊢ ∀f s. nsum (support $+ f s) f = nsum s f
   
   [<a name="NSUM_SWAP-val"><b>NSUM_SWAP</b></a>]  Theorem
      
      ⊢ ∀f s t.
          FINITE s ∧ FINITE t ⇒
          nsum s (λi. nsum t (f i)) = nsum t (λj. nsum s (λi. f i j))
   
   [<a name="NSUM_SWAP_NUMSEG-val"><b>NSUM_SWAP_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀a b c d f.
          nsum {a .. b} (λi. nsum {c .. d} (f i)) =
          nsum {c .. d} (λj. nsum {a .. b} (λi. f i j))
   
   [<a name="NSUM_TRIV_NUMSEG-val"><b>NSUM_TRIV_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n. n &lt; m ⇒ nsum {m .. n} f = 0
   
   [<a name="NSUM_UNION-val"><b>NSUM_UNION</b></a>]  Theorem
      
      ⊢ ∀f s t.
          FINITE s ∧ FINITE t ∧ DISJOINT s t ⇒
          nsum (s ∪ t) f = nsum s f + nsum t f
   
   [<a name="NSUM_UNION_EQ-val"><b>NSUM_UNION_EQ</b></a>]  Theorem
      
      ⊢ ∀s t u.
          FINITE u ∧ s ∩ t = ∅ ∧ s ∪ t = u ⇒ nsum s f + nsum t f = nsum u f
   
   [<a name="NSUM_UNION_LZERO-val"><b>NSUM_UNION_LZERO</b></a>]  Theorem
      
      ⊢ ∀f u v.
          FINITE v ∧ (∀x. x ∈ u ∧ x ∉ v ⇒ f x = 0) ⇒
          nsum (u ∪ v) f = nsum v f
   
   [<a name="NSUM_UNION_NONZERO-val"><b>NSUM_UNION_NONZERO</b></a>]  Theorem
      
      ⊢ ∀f s t.
          FINITE s ∧ FINITE t ∧ (∀x. x ∈ s ∩ t ⇒ f x = 0) ⇒
          nsum (s ∪ t) f = nsum s f + nsum t f
   
   [<a name="NSUM_UNION_RZERO-val"><b>NSUM_UNION_RZERO</b></a>]  Theorem
      
      ⊢ ∀f u v.
          FINITE u ∧ (∀x. x ∈ v ∧ x ∉ u ⇒ f x = 0) ⇒
          nsum (u ∪ v) f = nsum u f
   
   [<a name="NUMSEG_ADD_SPLIT-val"><b>NUMSEG_ADD_SPLIT</b></a>]  Theorem
      
      ⊢ ∀m n p. m ≤ n + 1 ⇒ {m .. n + p} = {m .. n} ∪ {n + 1 .. n + p}
   
   [<a name="NUMSEG_CLAUSES-val"><b>NUMSEG_CLAUSES</b></a>]  Theorem
      
      ⊢ (∀m. {m .. 0} = if m = 0 then {0} else ∅) ∧
        ∀m n.
          {m .. SUC n} =
          if m ≤ SUC n then SUC n INSERT {m .. n} else {m .. n}
   
   [<a name="NUMSEG_COMBINE_L-val"><b>NUMSEG_COMBINE_L</b></a>]  Theorem
      
      ⊢ ∀m p n. m ≤ p ∧ p ≤ n + 1 ⇒ {m .. p − 1} ∪ {p .. n} = {m .. n}
   
   [<a name="NUMSEG_COMBINE_R-val"><b>NUMSEG_COMBINE_R</b></a>]  Theorem
      
      ⊢ ∀m p n. m ≤ p + 1 ∧ p ≤ n ⇒ {m .. p} ∪ {p + 1 .. n} = {m .. n}
   
   [<a name="NUMSEG_EMPTY-val"><b>NUMSEG_EMPTY</b></a>]  Theorem
      
      ⊢ ∀m n. {m .. n} = ∅ ⇔ n &lt; m
   
   [<a name="NUMSEG_LE-val"><b>NUMSEG_LE</b></a>]  Theorem
      
      ⊢ ∀n. {x | x ≤ n} = {0 .. n}
   
   [<a name="NUMSEG_LREC-val"><b>NUMSEG_LREC</b></a>]  Theorem
      
      ⊢ ∀m n. m ≤ n ⇒ m INSERT {m + 1 .. n} = {m .. n}
   
   [<a name="NUMSEG_LT-val"><b>NUMSEG_LT</b></a>]  Theorem
      
      ⊢ ∀n. {x | x &lt; n} = if n = 0 then ∅ else {0 .. n − 1}
   
   [<a name="NUMSEG_OFFSET_IMAGE-val"><b>NUMSEG_OFFSET_IMAGE</b></a>]  Theorem
      
      ⊢ ∀m n p. {m + p .. n + p} = IMAGE (λi. i + p) {m .. n}
   
   [<a name="NUMSEG_REC-val"><b>NUMSEG_REC</b></a>]  Theorem
      
      ⊢ ∀m n. m ≤ SUC n ⇒ {m .. SUC n} = SUC n INSERT {m .. n}
   
   [<a name="NUMSEG_RREC-val"><b>NUMSEG_RREC</b></a>]  Theorem
      
      ⊢ ∀m n. m ≤ n ⇒ n INSERT {m .. n − 1} = {m .. n}
   
   [<a name="NUMSEG_SING-val"><b>NUMSEG_SING</b></a>]  Theorem
      
      ⊢ ∀n. {n .. n} = {n}
   
   [<a name="PERMUTES_IN_NUMSEG-val"><b>PERMUTES_IN_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀p n i. p permutes {1 .. n} ∧ i ∈ {1 .. n} ⇒ 1 ≤ p i ∧ p i ≤ n
   
   [<a name="POLYNOMIAL_FUNCTION_ADD-val"><b>POLYNOMIAL_FUNCTION_ADD</b></a>]  Theorem
      
      ⊢ ∀p q.
          polynomial_function p ∧ polynomial_function q ⇒
          polynomial_function (λx. p x + q x)
   
   [<a name="POLYNOMIAL_FUNCTION_CONST-val"><b>POLYNOMIAL_FUNCTION_CONST</b></a>]  Theorem
      
      ⊢ ∀c. polynomial_function (λx. c)
   
   [<a name="POLYNOMIAL_FUNCTION_FINITE_ROOTS-val"><b>POLYNOMIAL_FUNCTION_FINITE_ROOTS</b></a>]  Theorem
      
      ⊢ ∀p a. polynomial_function p ⇒ (FINITE {x | p x = a} ⇔ ¬∀x. p x = a)
   
   [<a name="POLYNOMIAL_FUNCTION_ID-val"><b>POLYNOMIAL_FUNCTION_ID</b></a>]  Theorem
      
      ⊢ polynomial_function (λx. x)
   
   [<a name="POLYNOMIAL_FUNCTION_INDUCT-val"><b>POLYNOMIAL_FUNCTION_INDUCT</b></a>]  Theorem
      
      ⊢ ∀P. P (λx. x) ∧ (∀c. P (λx. c)) ∧
            (∀p q. P p ∧ P q ⇒ P (λx. p x + q x)) ∧
            (∀p q. P p ∧ P q ⇒ P (λx. p x * q x)) ⇒
            ∀p. polynomial_function p ⇒ P p
   
   [<a name="POLYNOMIAL_FUNCTION_LMUL-val"><b>POLYNOMIAL_FUNCTION_LMUL</b></a>]  Theorem
      
      ⊢ ∀p c. polynomial_function p ⇒ polynomial_function (λx. c * p x)
   
   [<a name="POLYNOMIAL_FUNCTION_MUL-val"><b>POLYNOMIAL_FUNCTION_MUL</b></a>]  Theorem
      
      ⊢ ∀p q.
          polynomial_function p ∧ polynomial_function q ⇒
          polynomial_function (λx. p x * q x)
   
   [<a name="POLYNOMIAL_FUNCTION_NEG-val"><b>POLYNOMIAL_FUNCTION_NEG</b></a>]  Theorem
      
      ⊢ ∀p. polynomial_function (λx. -p x) ⇔ polynomial_function p
   
   [<a name="POLYNOMIAL_FUNCTION_POW-val"><b>POLYNOMIAL_FUNCTION_POW</b></a>]  Theorem
      
      ⊢ ∀p n. polynomial_function p ⇒ polynomial_function (λx. p x pow n)
   
   [<a name="POLYNOMIAL_FUNCTION_RMUL-val"><b>POLYNOMIAL_FUNCTION_RMUL</b></a>]  Theorem
      
      ⊢ ∀p c. polynomial_function p ⇒ polynomial_function (λx. p x * c)
   
   [<a name="POLYNOMIAL_FUNCTION_SUB-val"><b>POLYNOMIAL_FUNCTION_SUB</b></a>]  Theorem
      
      ⊢ ∀p q.
          polynomial_function p ∧ polynomial_function q ⇒
          polynomial_function (λx. p x − q x)
   
   [<a name="POLYNOMIAL_FUNCTION_SUM-val"><b>POLYNOMIAL_FUNCTION_SUM</b></a>]  Theorem
      
      ⊢ ∀s p.
          FINITE s ∧ (∀i. i ∈ s ⇒ polynomial_function (λx. p x i)) ⇒
          polynomial_function (λx. sum s (p x))
   
   [<a name="POLYNOMIAL_FUNCTION_o-val"><b>POLYNOMIAL_FUNCTION_o</b></a>]  Theorem
      
      ⊢ ∀p q.
          polynomial_function p ∧ polynomial_function q ⇒
          polynomial_function (p ∘ q)
   
   [<a name="POWERSET_CLAUSES-val"><b>POWERSET_CLAUSES</b></a>]  Theorem
      
      ⊢ {s | s ⊆ ∅} = {∅} ∧
        ∀a t.
          {s | s ⊆ a INSERT t} =
          {s | s ⊆ t} ∪ IMAGE (λs. a INSERT s) {s | s ⊆ t}
   
   [<a name="POW_NEG_ODD-val"><b>POW_NEG_ODD</b></a>]  Theorem
      
      ⊢ ∀x. x &lt; 0 ⇒ (x pow n &lt; 0 ⇔ ODD n)
   
   [<a name="POW_POS_EVEN-val"><b>POW_POS_EVEN</b></a>]  Theorem
      
      ⊢ ∀x. x &lt; 0 ⇒ (0 &lt; x pow n ⇔ EVEN n)
   
   [<a name="PRODUCT_ABS-val"><b>PRODUCT_ABS</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ⇒ product s (λx. abs (f x)) = abs (product s f)
   
   [<a name="PRODUCT_ADD_SPLIT-val"><b>PRODUCT_ADD_SPLIT</b></a>]  Theorem
      
      ⊢ ∀f m n p.
          m ≤ n + 1 ⇒
          product {m .. n + p} f =
          product {m .. n} f * product {n + 1 .. n + p} f
   
   [<a name="PRODUCT_CLAUSES-val"><b>PRODUCT_CLAUSES</b></a>]  Theorem
      
      ⊢ (∀f. product ∅ f = 1) ∧
        ∀x f s.
          FINITE s ⇒
          product (x INSERT s) f =
          if x ∈ s then product s f else f x * product s f
   
   [<a name="PRODUCT_CLAUSES_LEFT-val"><b>PRODUCT_CLAUSES_LEFT</b></a>]  Theorem
      
      ⊢ ∀f m n. m ≤ n ⇒ product {m .. n} f = f m * product {m + 1 .. n} f
   
   [<a name="PRODUCT_CLAUSES_NUMSEG-val"><b>PRODUCT_CLAUSES_NUMSEG</b></a>]  Theorem
      
      ⊢ (∀m. product {m .. 0} f = if m = 0 then f 0 else 1) ∧
        ∀m n.
          product {m .. SUC n} f =
          if m ≤ SUC n then product {m .. n} f * f (SUC n)
          else product {m .. n} f
   
   [<a name="PRODUCT_CLAUSES_RIGHT-val"><b>PRODUCT_CLAUSES_RIGHT</b></a>]  Theorem
      
      ⊢ ∀f m n.
          0 &lt; n ∧ m ≤ n ⇒ product {m .. n} f = product {m .. n − 1} f * f n
   
   [<a name="PRODUCT_CLOSED-val"><b>PRODUCT_CLOSED</b></a>]  Theorem
      
      ⊢ ∀P f s.
          P 1 ∧ (∀x y. P x ∧ P y ⇒ P (x * y)) ∧ (∀a. a ∈ s ⇒ P (f a)) ⇒
          P (product s f)
   
   [<a name="PRODUCT_CONG-val"><b>PRODUCT_CONG</b></a>]  Theorem
      
      ⊢ (∀f g s.
           (∀x. x ∈ s ⇒ f x = g x) ⇒ product s (λi. f i) = product s g) ∧
        (∀f g a b.
           (∀i. a ≤ i ∧ i ≤ b ⇒ f i = g i) ⇒
           product {a .. b} (λi. f i) = product {a .. b} g) ∧
        ∀f g p.
          (∀x. p x ⇒ f x = g x) ⇒
          product {y | p y} (λi. f i) = product {y | p y} g
   
   [<a name="PRODUCT_CONST-val"><b>PRODUCT_CONST</b></a>]  Theorem
      
      ⊢ ∀c s. FINITE s ⇒ product s (λx. c) = c pow CARD s
   
   [<a name="PRODUCT_CONST_NUMSEG-val"><b>PRODUCT_CONST_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀c m n. product {m .. n} (λx. c) = c pow (n + 1 − m)
   
   [<a name="PRODUCT_CONST_NUMSEG_1-val"><b>PRODUCT_CONST_NUMSEG_1</b></a>]  Theorem
      
      ⊢ ∀c n. product {1 .. n} (λx. c) = c pow n
   
   [<a name="PRODUCT_DELETE-val"><b>PRODUCT_DELETE</b></a>]  Theorem
      
      ⊢ ∀f s a.
          FINITE s ∧ a ∈ s ⇒ f a * product (s DELETE a) f = product s f
   
   [<a name="PRODUCT_DELTA-val"><b>PRODUCT_DELTA</b></a>]  Theorem
      
      ⊢ ∀s a.
          product s (λx. if x = a then b else 1) = if a ∈ s then b else 1
   
   [<a name="PRODUCT_DIV-val"><b>PRODUCT_DIV</b></a>]  Theorem
      
      ⊢ ∀f g s.
          FINITE s ⇒ product s (λx. f x / g x) = product s f / product s g
   
   [<a name="PRODUCT_DIV_NUMSEG-val"><b>PRODUCT_DIV_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f g m n.
          product {m .. n} (λx. f x / g x) =
          product {m .. n} f / product {m .. n} g
   
   [<a name="PRODUCT_EQ-val"><b>PRODUCT_EQ</b></a>]  Theorem
      
      ⊢ ∀f g s. (∀x. x ∈ s ⇒ f x = g x) ⇒ product s f = product s g
   
   [<a name="PRODUCT_EQ_0-val"><b>PRODUCT_EQ_0</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ⇒ (product s f = 0 ⇔ ∃x. x ∈ s ∧ f x = 0)
   
   [<a name="PRODUCT_EQ_0_COUNT-val"><b>PRODUCT_EQ_0_COUNT</b></a>]  Theorem
      
      ⊢ ∀f n. product (count n) f = 0 ⇔ ∃i. i &lt; n ∧ f i = 0
   
   [<a name="PRODUCT_EQ_0_NUMSEG-val"><b>PRODUCT_EQ_0_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n. product {m .. n} f = 0 ⇔ ∃x. m ≤ x ∧ x ≤ n ∧ f x = 0
   
   [<a name="PRODUCT_EQ_1-val"><b>PRODUCT_EQ_1</b></a>]  Theorem
      
      ⊢ ∀f s. (∀x. x ∈ s ⇒ f x = 1) ⇒ product s f = 1
   
   [<a name="PRODUCT_EQ_1_COUNT-val"><b>PRODUCT_EQ_1_COUNT</b></a>]  Theorem
      
      ⊢ ∀f n. (∀i. i &lt; n ⇒ f i = 1) ⇒ product (count n) f = 1
   
   [<a name="PRODUCT_EQ_1_NUMSEG-val"><b>PRODUCT_EQ_1_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n. (∀i. m ≤ i ∧ i ≤ n ⇒ f i = 1) ⇒ product {m .. n} f = 1
   
   [<a name="PRODUCT_EQ_COUNT-val"><b>PRODUCT_EQ_COUNT</b></a>]  Theorem
      
      ⊢ ∀f g n.
          (∀i. i &lt; n ⇒ f i = g i) ⇒
          product (count n) f = product (count n) g
   
   [<a name="PRODUCT_EQ_NUMSEG-val"><b>PRODUCT_EQ_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f g m n.
          (∀i. m ≤ i ∧ i ≤ n ⇒ f i = g i) ⇒
          product {m .. n} f = product {m .. n} g
   
   [<a name="PRODUCT_IMAGE-val"><b>PRODUCT_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f g s.
          (∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y) ⇒
          product (IMAGE f s) g = product s (g ∘ f)
   
   [<a name="PRODUCT_INV-val"><b>PRODUCT_INV</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ⇒ product s (λx. (f x)⁻¹) = (product s f)⁻¹
   
   [<a name="PRODUCT_LE-val"><b>PRODUCT_LE</b></a>]  Theorem
      
      ⊢ ∀f s.
          FINITE s ∧ (∀x. x ∈ s ⇒ 0 ≤ f x ∧ f x ≤ g x) ⇒
          product s f ≤ product s g
   
   [<a name="PRODUCT_LE_1-val"><b>PRODUCT_LE_1</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ∧ (∀x. x ∈ s ⇒ 0 ≤ f x ∧ f x ≤ 1) ⇒ product s f ≤ 1
   
   [<a name="PRODUCT_LE_NUMSEG-val"><b>PRODUCT_LE_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n.
          (∀i. m ≤ i ∧ i ≤ n ⇒ 0 ≤ f i ∧ f i ≤ g i) ⇒
          product {m .. n} f ≤ product {m .. n} g
   
   [<a name="PRODUCT_MUL-val"><b>PRODUCT_MUL</b></a>]  Theorem
      
      ⊢ ∀f g s.
          FINITE s ⇒ product s (λx. f x * g x) = product s f * product s g
   
   [<a name="PRODUCT_MUL_COUNT-val"><b>PRODUCT_MUL_COUNT</b></a>]  Theorem
      
      ⊢ ∀f g n.
          product (count n) (λx. f x * g x) =
          product (count n) f * product (count n) g
   
   [<a name="PRODUCT_MUL_GEN-val"><b>PRODUCT_MUL_GEN</b></a>]  Theorem
      
      ⊢ ∀f g s.
          FINITE {x | x ∈ s ∧ f x ≠ 1} ∧ FINITE {x | x ∈ s ∧ g x ≠ 1} ⇒
          product s (λx. f x * g x) = product s f * product s g
   
   [<a name="PRODUCT_MUL_NUMSEG-val"><b>PRODUCT_MUL_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f g m n.
          product {m .. n} (λx. f x * g x) =
          product {m .. n} f * product {m .. n} g
   
   [<a name="PRODUCT_NEG-val"><b>PRODUCT_NEG</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ⇒ product s (λi. -f i) = -1 pow CARD s * product s f
   
   [<a name="PRODUCT_NEG_NUMSEG-val"><b>PRODUCT_NEG_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n.
          product {m .. n} (λi. -f i) =
          -1 pow (n + 1 − m) * product {m .. n} f
   
   [<a name="PRODUCT_NEG_NUMSEG_1-val"><b>PRODUCT_NEG_NUMSEG_1</b></a>]  Theorem
      
      ⊢ ∀f n. product {1 .. n} (λi. -f i) = -1 pow n * product {1 .. n} f
   
   [<a name="PRODUCT_OFFSET-val"><b>PRODUCT_OFFSET</b></a>]  Theorem
      
      ⊢ ∀f m p.
          product {m + p .. n + p} f = product {m .. n} (λi. f (i + p))
   
   [<a name="PRODUCT_ONE-val"><b>PRODUCT_ONE</b></a>]  Theorem
      
      ⊢ ∀s. product s (λn. 1) = 1
   
   [<a name="PRODUCT_PAIR-val"><b>PRODUCT_PAIR</b></a>]  Theorem
      
      ⊢ ∀f m n.
          product {2 * m .. 2 * n + 1} f =
          product {m .. n} (λi. f (2 * i) * f (2 * i + 1))
   
   [<a name="PRODUCT_PERMUTE-val"><b>PRODUCT_PERMUTE</b></a>]  Theorem
      
      ⊢ ∀f p s. p permutes s ⇒ product s f = product s (f ∘ p)
   
   [<a name="PRODUCT_PERMUTE_COUNT-val"><b>PRODUCT_PERMUTE_COUNT</b></a>]  Theorem
      
      ⊢ ∀f p n.
          p permutes count n ⇒
          product (count n) f = product (count n) (f ∘ p)
   
   [<a name="PRODUCT_PERMUTE_NUMSEG-val"><b>PRODUCT_PERMUTE_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f p m n.
          p permutes count n DIFF count m ⇒
          product (count n DIFF count m) f =
          product (count n DIFF count m) (f ∘ p)
   
   [<a name="PRODUCT_POS_LE-val"><b>PRODUCT_POS_LE</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ∧ (∀x. x ∈ s ⇒ 0 ≤ f x) ⇒ 0 ≤ product s f
   
   [<a name="PRODUCT_POS_LE_NUMSEG-val"><b>PRODUCT_POS_LE_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n. (∀x. m ≤ x ∧ x ≤ n ⇒ 0 ≤ f x) ⇒ 0 ≤ product {m .. n} f
   
   [<a name="PRODUCT_POS_LT-val"><b>PRODUCT_POS_LT</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ∧ (∀x. x ∈ s ⇒ 0 &lt; f x) ⇒ 0 &lt; product s f
   
   [<a name="PRODUCT_POS_LT_NUMSEG-val"><b>PRODUCT_POS_LT_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n. (∀x. m ≤ x ∧ x ≤ n ⇒ 0 &lt; f x) ⇒ 0 &lt; product {m .. n} f
   
   [<a name="PRODUCT_SING-val"><b>PRODUCT_SING</b></a>]  Theorem
      
      ⊢ ∀f x. product {x} f = f x
   
   [<a name="PRODUCT_SING_NUMSEG-val"><b>PRODUCT_SING_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f n. product {n .. n} f = f n
   
   [<a name="PRODUCT_SUPERSET-val"><b>PRODUCT_SUPERSET</b></a>]  Theorem
      
      ⊢ ∀f u v.
          u ⊆ v ∧ (∀x. x ∈ v ∧ x ∉ u ⇒ f x = 1) ⇒ product v f = product u f
   
   [<a name="PRODUCT_SUPPORT-val"><b>PRODUCT_SUPPORT</b></a>]  Theorem
      
      ⊢ ∀f s. product (support $* f s) f = product s f
   
   [<a name="PRODUCT_UNION-val"><b>PRODUCT_UNION</b></a>]  Theorem
      
      ⊢ ∀f s t.
          FINITE s ∧ FINITE t ∧ DISJOINT s t ⇒
          product (s ∪ t) f = product s f * product t f
   
   [<a name="REAL_ABS_INF_LE-val"><b>REAL_ABS_INF_LE</b></a>]  Theorem
      
      ⊢ ∀s a. s ≠ ∅ ∧ (∀x. x ∈ s ⇒ abs x ≤ a) ⇒ abs (inf s) ≤ a
   
   [<a name="REAL_ABS_SUP_LE-val"><b>REAL_ABS_SUP_LE</b></a>]  Theorem
      
      ⊢ ∀s a. s ≠ ∅ ∧ (∀x. x ∈ s ⇒ abs x ≤ a) ⇒ abs (sup s) ≤ a
   
   [<a name="REAL_ARCH_INV'-val"><b>REAL_ARCH_INV'</b></a>]  Theorem
      
      ⊢ ∀x. 0 &lt; x ⇒ ∃n. (&n)⁻¹ &lt; x
   
   [<a name="REAL_ARCH_INV_SUC-val"><b>REAL_ARCH_INV_SUC</b></a>]  Theorem
      
      ⊢ ∀x. 0 &lt; x ⇒ ∃n. (&SUC n)⁻¹ &lt; x
   
   [<a name="REAL_BOUNDS_LT-val"><b>REAL_BOUNDS_LT</b></a>]  Theorem
      
      ⊢ ∀x k. -k &lt; x ∧ x &lt; k ⇔ abs x &lt; k
   
   [<a name="REAL_COMPLETE-val"><b>REAL_COMPLETE</b></a>]  Theorem
      
      ⊢ ∀P. (∃x. P x) ∧ (∃M. ∀x. P x ⇒ x ≤ M) ⇒
            ∃M. (∀x. P x ⇒ x ≤ M) ∧ ∀M'. (∀x. P x ⇒ x ≤ M') ⇒ M ≤ M'
   
   [<a name="REAL_EQ_SQUARE_ABS-val"><b>REAL_EQ_SQUARE_ABS</b></a>]  Theorem
      
      ⊢ ∀x y. abs x = abs y ⇔ x² = y²
   
   [<a name="REAL_HALF-val"><b>REAL_HALF</b></a>]  Theorem
      
      ⊢ (∀e. 0 &lt; e / 2 ⇔ 0 &lt; e) ∧ (∀e. e / 2 + e / 2 = e) ∧
        ∀e. 2 * (e / 2) = e
   
   [<a name="REAL_IMP_LE_SUP'-val"><b>REAL_IMP_LE_SUP'</b></a>]  Theorem
      
      ⊢ ∀p x. (∃z. ∀r. r ∈ p ⇒ r ≤ z) ∧ (∃r. r ∈ p ∧ x ≤ r) ⇒ x ≤ sup p
   
   [<a name="REAL_IMP_SUP_LE'-val"><b>REAL_IMP_SUP_LE'</b></a>]  Theorem
      
      ⊢ ∀p x. (∃r. r ∈ p) ∧ (∀r. r ∈ p ⇒ r ≤ x) ⇒ sup p ≤ x
   
   [<a name="REAL_INF_ASCLOSE-val"><b>REAL_INF_ASCLOSE</b></a>]  Theorem
      
      ⊢ ∀s l e. s ≠ ∅ ∧ (∀x. x ∈ s ⇒ abs (x − l) ≤ e) ⇒ abs (inf s − l) ≤ e
   
   [<a name="REAL_INF_BOUNDS-val"><b>REAL_INF_BOUNDS</b></a>]  Theorem
      
      ⊢ ∀s a b. s ≠ ∅ ∧ (∀x. x ∈ s ⇒ a ≤ x ∧ x ≤ b) ⇒ a ≤ inf s ∧ inf s ≤ b
   
   [<a name="REAL_INF_LE'-val"><b>REAL_INF_LE'</b></a>]  Theorem
      
      ⊢ ∀p x.
          (∃y. y ∈ p) ∧ (∃y. ∀z. z ∈ p ⇒ y ≤ z) ⇒
          (inf p ≤ x ⇔ ∀y. (∀z. z ∈ p ⇒ y ≤ z) ⇒ y ≤ x)
   
   [<a name="REAL_INF_LE_FINITE-val"><b>REAL_INF_LE_FINITE</b></a>]  Theorem
      
      ⊢ ∀s a. FINITE s ∧ s ≠ ∅ ⇒ (inf s ≤ a ⇔ ∃x. x ∈ s ∧ x ≤ a)
   
   [<a name="REAL_INF_LT_FINITE-val"><b>REAL_INF_LT_FINITE</b></a>]  Theorem
      
      ⊢ ∀s a. FINITE s ∧ s ≠ ∅ ⇒ (inf s &lt; a ⇔ ∃x. x ∈ s ∧ x &lt; a)
   
   [<a name="REAL_INF_UNIQUE-val"><b>REAL_INF_UNIQUE</b></a>]  Theorem
      
      ⊢ ∀s b.
          (∀x. x ∈ s ⇒ b ≤ x) ∧ (∀b'. b &lt; b' ⇒ ∃x. x ∈ s ∧ x &lt; b') ⇒
          inf s = b
   
   [<a name="REAL_LE_BETWEEN-val"><b>REAL_LE_BETWEEN</b></a>]  Theorem
      
      ⊢ ∀a b. a ≤ b ⇔ ∃x. a ≤ x ∧ x ≤ b
   
   [<a name="REAL_LE_INF-val"><b>REAL_LE_INF</b></a>]  Theorem
      
      ⊢ ∀s b. s ≠ ∅ ∧ (∀x. x ∈ s ⇒ b ≤ x) ⇒ b ≤ inf s
   
   [<a name="REAL_LE_INF_FINITE-val"><b>REAL_LE_INF_FINITE</b></a>]  Theorem
      
      ⊢ ∀s a. FINITE s ∧ s ≠ ∅ ⇒ (a ≤ inf s ⇔ ∀x. x ∈ s ⇒ a ≤ x)
   
   [<a name="REAL_LE_INF_SUBSET-val"><b>REAL_LE_INF_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t. t ≠ ∅ ∧ t ⊆ s ∧ (∃b. ∀x. x ∈ s ⇒ b ≤ x) ⇒ inf s ≤ inf t
   
   [<a name="REAL_LE_LDIV_CANCEL-val"><b>REAL_LE_LDIV_CANCEL</b></a>]  Theorem
      
      ⊢ ∀x y z. 0 &lt; x ∧ 0 &lt; y ∧ 0 &lt; z ⇒ (z / x ≤ z / y ⇔ y ≤ x)
   
   [<a name="REAL_LE_LT_MUL-val"><b>REAL_LE_LT_MUL</b></a>]  Theorem
      
      ⊢ ∀x y. 0 ≤ x ∧ 0 &lt; y ⇒ 0 ≤ x * y
   
   [<a name="REAL_LE_MUL'-val"><b>REAL_LE_MUL'</b></a>]  Theorem
      
      ⊢ ∀x y. x ≤ 0 ∧ y ≤ 0 ⇒ 0 ≤ x * y
   
   [<a name="REAL_LE_MUL_EPSILON-val"><b>REAL_LE_MUL_EPSILON</b></a>]  Theorem
      
      ⊢ ∀x y. (∀z. 0 &lt; z ∧ z &lt; 1 ⇒ z * x ≤ y) ⇒ x ≤ y
   
   [<a name="REAL_LE_RDIV_EQ_NEG-val"><b>REAL_LE_RDIV_EQ_NEG</b></a>]  Theorem
      
      ⊢ ∀x y z. z &lt; 0 ⇒ (y / z ≤ x ⇔ x * z ≤ y)
   
   [<a name="REAL_LE_SQUARE_ABS-val"><b>REAL_LE_SQUARE_ABS</b></a>]  Theorem
      
      ⊢ ∀x y. abs x ≤ abs y ⇔ x² ≤ y²
   
   [<a name="REAL_LE_SUP'-val"><b>REAL_LE_SUP'</b></a>]  Theorem
      
      ⊢ ∀s a b y. y ∈ s ∧ a ≤ y ∧ (∀x. x ∈ s ⇒ x ≤ b) ⇒ a ≤ sup s
   
   [<a name="REAL_LE_SUP_EQ-val"><b>REAL_LE_SUP_EQ</b></a>]  Theorem
      
      ⊢ ∀p x.
          (∃y. y ∈ p) ∧ (∃y. ∀z. z ∈ p ⇒ z ≤ y) ⇒
          (x ≤ sup p ⇔ ∀y. (∀z. z ∈ p ⇒ z ≤ y) ⇒ x ≤ y)
   
   [<a name="REAL_LE_SUP_FINITE-val"><b>REAL_LE_SUP_FINITE</b></a>]  Theorem
      
      ⊢ ∀s a. FINITE s ∧ s ≠ ∅ ⇒ (a ≤ sup s ⇔ ∃x. x ∈ s ∧ a ≤ x)
   
   [<a name="REAL_LT_BETWEEN-val"><b>REAL_LT_BETWEEN</b></a>]  Theorem
      
      ⊢ ∀a b. a &lt; b ⇔ ∃x. a &lt; x ∧ x &lt; b
   
   [<a name="REAL_LT_INF_FINITE-val"><b>REAL_LT_INF_FINITE</b></a>]  Theorem
      
      ⊢ ∀s a. FINITE s ∧ s ≠ ∅ ⇒ (a &lt; inf s ⇔ ∀x. x ∈ s ⇒ a &lt; x)
   
   [<a name="REAL_LT_INV2-val"><b>REAL_LT_INV2</b></a>]  Theorem
      
      ⊢ ∀x y. 0 &lt; x ∧ x &lt; y ⇒ y⁻¹ &lt; x⁻¹
   
   [<a name="REAL_LT_LCANCEL_IMP-val"><b>REAL_LT_LCANCEL_IMP</b></a>]  Theorem
      
      ⊢ ∀x y z. 0 &lt; x ∧ x * y &lt; x * z ⇒ y &lt; z
   
   [<a name="REAL_LT_LDIV_CANCEL-val"><b>REAL_LT_LDIV_CANCEL</b></a>]  Theorem
      
      ⊢ ∀x y z. 0 &lt; x ∧ 0 &lt; y ∧ 0 &lt; z ⇒ (z / x &lt; z / y ⇔ y &lt; x)
   
   [<a name="REAL_LT_LE_MUL-val"><b>REAL_LT_LE_MUL</b></a>]  Theorem
      
      ⊢ ∀x y. 0 &lt; x ∧ 0 ≤ y ⇒ 0 ≤ x * y
   
   [<a name="REAL_LT_LMUL'-val"><b>REAL_LT_LMUL'</b></a>]  Theorem
      
      ⊢ ∀x y z. x &lt; 0 ⇒ (x * y &lt; x * z ⇔ z &lt; y)
   
   [<a name="REAL_LT_LMUL_0_NEG-val"><b>REAL_LT_LMUL_0_NEG</b></a>]  Theorem
      
      ⊢ ∀x y. 0 &lt; x * y ∧ x &lt; 0 ⇒ y &lt; 0
   
   [<a name="REAL_LT_LMUL_NEG_0-val"><b>REAL_LT_LMUL_NEG_0</b></a>]  Theorem
      
      ⊢ ∀x y. x * y &lt; 0 ∧ 0 &lt; x ⇒ y &lt; 0
   
   [<a name="REAL_LT_LMUL_NEG_0_NEG-val"><b>REAL_LT_LMUL_NEG_0_NEG</b></a>]  Theorem
      
      ⊢ ∀x y. x * y &lt; 0 ∧ x &lt; 0 ⇒ 0 &lt; y
   
   [<a name="REAL_LT_MAX_BETWEEN-val"><b>REAL_LT_MAX_BETWEEN</b></a>]  Theorem
      
      ⊢ ∀x b d. x &lt; max b d ∧ b ≤ x ⇒ x &lt; d
   
   [<a name="REAL_LT_MUL'-val"><b>REAL_LT_MUL'</b></a>]  Theorem
      
      ⊢ ∀x y. x &lt; 0 ∧ y &lt; 0 ⇒ 0 &lt; x * y
   
   [<a name="REAL_LT_POW2-val"><b>REAL_LT_POW2</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; 2 pow n
   
   [<a name="REAL_LT_RDIV_EQ_NEG-val"><b>REAL_LT_RDIV_EQ_NEG</b></a>]  Theorem
      
      ⊢ ∀x y z. z &lt; 0 ⇒ (y / z &lt; x ⇔ x * z &lt; y)
   
   [<a name="REAL_LT_RMUL'-val"><b>REAL_LT_RMUL'</b></a>]  Theorem
      
      ⊢ ∀x y z. z &lt; 0 ⇒ (x * z &lt; y * z ⇔ y &lt; x)
   
   [<a name="REAL_LT_RMUL_0_NEG-val"><b>REAL_LT_RMUL_0_NEG</b></a>]  Theorem
      
      ⊢ ∀x y. 0 &lt; x * y ∧ y &lt; 0 ⇒ x &lt; 0
   
   [<a name="REAL_LT_RMUL_NEG_0-val"><b>REAL_LT_RMUL_NEG_0</b></a>]  Theorem
      
      ⊢ ∀x y. x * y &lt; 0 ∧ 0 &lt; y ⇒ x &lt; 0
   
   [<a name="REAL_LT_RMUL_NEG_0_NEG-val"><b>REAL_LT_RMUL_NEG_0_NEG</b></a>]  Theorem
      
      ⊢ ∀x y. x * y &lt; 0 ∧ y &lt; 0 ⇒ 0 &lt; x
   
   [<a name="REAL_LT_SUP_FINITE-val"><b>REAL_LT_SUP_FINITE</b></a>]  Theorem
      
      ⊢ ∀s a. FINITE s ∧ s ≠ ∅ ⇒ (a &lt; sup s ⇔ ∃x. x ∈ s ∧ a &lt; x)
   
   [<a name="REAL_MAX_REDUCE-val"><b>REAL_MAX_REDUCE</b></a>]  Theorem
      
      ⊢ ∀x y. x ≤ y ∨ x &lt; y ⇒ max x y = y ∧ max y x = y
   
   [<a name="REAL_MIN_LE_BETWEEN-val"><b>REAL_MIN_LE_BETWEEN</b></a>]  Theorem
      
      ⊢ ∀x a c. min a c ≤ x ∧ x &lt; a ⇒ c ≤ x
   
   [<a name="REAL_MIN_REDUCE-val"><b>REAL_MIN_REDUCE</b></a>]  Theorem
      
      ⊢ ∀x y. x ≤ y ∨ x &lt; y ⇒ min x y = x ∧ min y x = x
   
   [<a name="REAL_MUL_IDEMPOT-val"><b>REAL_MUL_IDEMPOT</b></a>]  Theorem
      
      ⊢ ∀r. r * r = r ⇔ r = 0 ∨ r = 1
   
   [<a name="REAL_MUL_SUM-val"><b>REAL_MUL_SUM</b></a>]  Theorem
      
      ⊢ ∀s t f g.
          FINITE s ∧ FINITE t ⇒
          sum s f * sum t g = sum s (λi. sum t (λj. f i * g j))
   
   [<a name="REAL_MUL_SUM_NUMSEG-val"><b>REAL_MUL_SUM_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f g m n p q.
          sum {m .. n} f * sum {p .. q} g =
          sum {m .. n} (λi. sum {p .. q} (λj. f i * g j))
   
   [<a name="REAL_NEG_NZ-val"><b>REAL_NEG_NZ</b></a>]  Theorem
      
      ⊢ ∀x. x &lt; 0 ⇒ x ≠ 0
   
   [<a name="REAL_OF_NUM_GE-val"><b>REAL_OF_NUM_GE</b></a>]  Theorem
      
      ⊢ ∀m n. &m ≥ &n ⇔ m ≥ n
   
   [<a name="REAL_OF_NUM_NPRODUCT-val"><b>REAL_OF_NUM_NPRODUCT</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ⇒ &nproduct s f = product s (λx. &f x)
   
   [<a name="REAL_OF_NUM_SUM-val"><b>REAL_OF_NUM_SUM</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ⇒ &nsum s f = sum s (λx. &f x)
   
   [<a name="REAL_OF_NUM_SUM_NUMSEG-val"><b>REAL_OF_NUM_SUM_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n. &nsum {m .. n} f = sum {m .. n} (λi. &f i)
   
   [<a name="REAL_POLYFUN_EQ_0-val"><b>REAL_POLYFUN_EQ_0</b></a>]  Theorem
      
      ⊢ ∀n c.
          (∀x. sum {0 .. n} (λi. c i * x pow i) = 0) ⇔
          ∀i. i ∈ {0 .. n} ⇒ c i = 0
   
   [<a name="REAL_POLYFUN_EQ_CONST-val"><b>REAL_POLYFUN_EQ_CONST</b></a>]  Theorem
      
      ⊢ ∀n c k.
          (∀x. sum {0 .. n} (λi. c i * x pow i) = k) ⇔
          c 0 = k ∧ ∀i. i ∈ {1 .. n} ⇒ c i = 0
   
   [<a name="REAL_POLYFUN_FINITE_ROOTS-val"><b>REAL_POLYFUN_FINITE_ROOTS</b></a>]  Theorem
      
      ⊢ ∀n c.
          FINITE {x | sum {0 .. n} (λi. c i * x pow i) = 0} ⇔
          ∃i. i ∈ {0 .. n} ∧ c i ≠ 0
   
   [<a name="REAL_POLYFUN_ROOTBOUND-val"><b>REAL_POLYFUN_ROOTBOUND</b></a>]  Theorem
      
      ⊢ ∀n c.
          ¬(∀i. i ∈ {0 .. n} ⇒ c i = 0) ⇒
          FINITE {x | sum {0 .. n} (λi. c i * x pow i) = 0} ∧
          CARD {x | sum {0 .. n} (λi. c i * x pow i) = 0} ≤ n
   
   [<a name="REAL_SUB_POLYFUN-val"><b>REAL_SUB_POLYFUN</b></a>]  Theorem
      
      ⊢ ∀a x y n.
          1 ≤ n ⇒
          sum {0 .. n} (λi. a i * x pow i) −
          sum {0 .. n} (λi. a i * y pow i) =
          (x − y) *
          sum {0 .. n − 1}
            (λj. sum {j + 1 .. n} (λi. a i * y pow (i − j − 1)) * x pow j)
   
   [<a name="REAL_SUB_POLYFUN_ALT-val"><b>REAL_SUB_POLYFUN_ALT</b></a>]  Theorem
      
      ⊢ ∀a x y n.
          1 ≤ n ⇒
          sum {0 .. n} (λi. a i * x pow i) −
          sum {0 .. n} (λi. a i * y pow i) =
          (x − y) *
          sum {0 .. n − 1}
            (λj.
                 sum {0 .. n − j − 1} (λk. a (j + k + 1) * y pow k) *
                 x pow j)
   
   [<a name="REAL_SUB_POW-val"><b>REAL_SUB_POW</b></a>]  Theorem
      
      ⊢ ∀x y n.
          1 ≤ n ⇒
          x pow n − y pow n =
          (x − y) * sum {0 .. n − 1} (λi. x pow i * y pow (n − 1 − i))
   
   [<a name="REAL_SUB_POW_L1-val"><b>REAL_SUB_POW_L1</b></a>]  Theorem
      
      ⊢ ∀x n.
          1 ≤ n ⇒ 1 − x pow n = (1 − x) * sum {0 .. n − 1} (λi. x pow i)
   
   [<a name="REAL_SUB_POW_R1-val"><b>REAL_SUB_POW_R1</b></a>]  Theorem
      
      ⊢ ∀x n.
          1 ≤ n ⇒ x pow n − 1 = (x − 1) * sum {0 .. n − 1} (λi. x pow i)
   
   [<a name="REAL_SUP_ASCLOSE-val"><b>REAL_SUP_ASCLOSE</b></a>]  Theorem
      
      ⊢ ∀s l e. s ≠ ∅ ∧ (∀x. x ∈ s ⇒ abs (x − l) ≤ e) ⇒ abs (sup s − l) ≤ e
   
   [<a name="REAL_SUP_BOUNDS-val"><b>REAL_SUP_BOUNDS</b></a>]  Theorem
      
      ⊢ ∀s a b. s ≠ ∅ ∧ (∀x. x ∈ s ⇒ a ≤ x ∧ x ≤ b) ⇒ a ≤ sup s ∧ sup s ≤ b
   
   [<a name="REAL_SUP_EQ_INF-val"><b>REAL_SUP_EQ_INF</b></a>]  Theorem
      
      ⊢ ∀s. s ≠ ∅ ∧ (∃B. ∀x. x ∈ s ⇒ abs x ≤ B) ⇒
            (sup s = inf s ⇔ ∃a. s = {a})
   
   [<a name="REAL_SUP_LE'-val"><b>REAL_SUP_LE'</b></a>]  Theorem
      
      ⊢ ∀s b. s ≠ ∅ ∧ (∀x. x ∈ s ⇒ x ≤ b) ⇒ sup s ≤ b
   
   [<a name="REAL_SUP_LE_EQ-val"><b>REAL_SUP_LE_EQ</b></a>]  Theorem
      
      ⊢ ∀s y.
          s ≠ ∅ ∧ (∃b. ∀x. x ∈ s ⇒ x ≤ b) ⇒ (sup s ≤ y ⇔ ∀x. x ∈ s ⇒ x ≤ y)
   
   [<a name="REAL_SUP_LE_FINITE-val"><b>REAL_SUP_LE_FINITE</b></a>]  Theorem
      
      ⊢ ∀s a. FINITE s ∧ s ≠ ∅ ⇒ (sup s ≤ a ⇔ ∀x. x ∈ s ⇒ x ≤ a)
   
   [<a name="REAL_SUP_LE_SUBSET-val"><b>REAL_SUP_LE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t. s ≠ ∅ ∧ s ⊆ t ∧ (∃b. ∀x. x ∈ t ⇒ x ≤ b) ⇒ sup s ≤ sup t
   
   [<a name="REAL_SUP_LE_X-val"><b>REAL_SUP_LE_X</b></a>]  Theorem
      
      ⊢ ∀P x. (∃r. P r) ∧ (∀r. P r ⇒ r ≤ x) ⇒ sup P ≤ x
   
   [<a name="REAL_SUP_LT_FINITE-val"><b>REAL_SUP_LT_FINITE</b></a>]  Theorem
      
      ⊢ ∀s a. FINITE s ∧ s ≠ ∅ ⇒ (sup s &lt; a ⇔ ∀x. x ∈ s ⇒ x &lt; a)
   
   [<a name="REAL_SUP_UNIQUE-val"><b>REAL_SUP_UNIQUE</b></a>]  Theorem
      
      ⊢ ∀s b.
          (∀x. x ∈ s ⇒ x ≤ b) ∧ (∀b'. b' &lt; b ⇒ ∃x. x ∈ s ∧ b' &lt; x) ⇒
          sup s = b
   
   [<a name="REAL_WLOG_LE-val"><b>REAL_WLOG_LE</b></a>]  Theorem
      
      ⊢ (∀x y. P x y ⇔ P y x) ∧ (∀x y. x ≤ y ⇒ P x y) ⇒ ∀x y. P x y
   
   [<a name="REAL_WLOG_LT-val"><b>REAL_WLOG_LT</b></a>]  Theorem
      
      ⊢ (∀x. P x x) ∧ (∀x y. P x y ⇔ P y x) ∧ (∀x y. x &lt; y ⇒ P x y) ⇒
        ∀x y. P x y
   
   [<a name="REAL_X_LE_SUP-val"><b>REAL_X_LE_SUP</b></a>]  Theorem
      
      ⊢ ∀P x.
          (∃r. P r) ∧ (∃z. ∀r. P r ⇒ r ≤ z) ∧ (∃r. P r ∧ x ≤ r) ⇒ x ≤ sup P
   
   [<a name="SET_PROVE_CASES-val"><b>SET_PROVE_CASES</b></a>]  Theorem
      
      ⊢ ∀P. P ∅ ∧ (∀a s. a ∉ s ⇒ P (a INSERT s)) ⇒ ∀s. P s
   
   [<a name="SET_RECURSION_LEMMA-val"><b>SET_RECURSION_LEMMA</b></a>]  Theorem
      
      ⊢ ∀f b.
          (∀x y s. x ≠ y ⇒ f x (f y s) = f y (f x s)) ⇒
          ∃g. g ∅ = b ∧
              ∀x s.
                FINITE s ⇒
                g (x INSERT s) = if x ∈ s then g s else f x (g s)
   
   [<a name="SIMPLE_IMAGE_GEN-val"><b>SIMPLE_IMAGE_GEN</b></a>]  Theorem
      
      ⊢ ∀f P. {f x | P x} = IMAGE f {x | P x}
   
   [<a name="SUBSET_NUMSEG-val"><b>SUBSET_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀m n p q. {m .. n} ⊆ {p .. q} ⇔ n &lt; m ∨ p ≤ m ∧ n ≤ q
   
   [<a name="SUBSET_RESTRICT-val"><b>SUBSET_RESTRICT</b></a>]  Theorem
      
      ⊢ ∀s P. {x | x ∈ s ∧ P x} ⊆ s
   
   [<a name="SUMS_SYM-val"><b>SUMS_SYM</b></a>]  Theorem
      
      ⊢ ∀s t. {x + y | x ∈ s ∧ y ∈ t} = {y + x | y ∈ t ∧ x ∈ s}
   
   [<a name="SUM_0'-val"><b>SUM_0'</b></a>]  Theorem
      
      ⊢ ∀s. sum s (λn. 0) = 0
   
   [<a name="SUM_ABS'-val"><b>SUM_ABS'</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ⇒ abs (sum s f) ≤ sum s (λx. abs (f x))
   
   [<a name="SUM_ABS_BOUND-val"><b>SUM_ABS_BOUND</b></a>]  Theorem
      
      ⊢ ∀s f b.
          FINITE s ∧ (∀x. x ∈ s ⇒ abs (f x) ≤ b) ⇒
          abs (sum s f) ≤ &CARD s * b
   
   [<a name="SUM_ABS_LE'-val"><b>SUM_ABS_LE'</b></a>]  Theorem
      
      ⊢ ∀f g s.
          FINITE s ∧ (∀x. x ∈ s ⇒ abs (f x) ≤ g x) ⇒
          abs (sum s f) ≤ sum s g
   
   [<a name="SUM_ABS_NUMSEG-val"><b>SUM_ABS_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n. abs (sum {m .. n} f) ≤ sum {m .. n} (λi. abs (f i))
   
   [<a name="SUM_ABS_TRIANGLE-val"><b>SUM_ABS_TRIANGLE</b></a>]  Theorem
      
      ⊢ ∀s f b. FINITE s ∧ sum s (λa. abs (f a)) ≤ b ⇒ abs (sum s f) ≤ b
   
   [<a name="SUM_ADD'-val"><b>SUM_ADD'</b></a>]  Theorem
      
      ⊢ ∀f g s. FINITE s ⇒ sum s (λx. f x + g x) = sum s f + sum s g
   
   [<a name="SUM_ADD_COUNT-val"><b>SUM_ADD_COUNT</b></a>]  Theorem
      
      ⊢ ∀f g n.
          sum (count n) (λx. f x + g x) = sum (count n) f + sum (count n) g
   
   [<a name="SUM_ADD_GEN-val"><b>SUM_ADD_GEN</b></a>]  Theorem
      
      ⊢ ∀f g s.
          FINITE {x | x ∈ s ∧ f x ≠ 0} ∧ FINITE {x | x ∈ s ∧ g x ≠ 0} ⇒
          sum s (λx. f x + g x) = sum s f + sum s g
   
   [<a name="SUM_ADD_NUMSEG-val"><b>SUM_ADD_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f g m n.
          sum {m .. n} (λi. f i + g i) = sum {m .. n} f + sum {m .. n} g
   
   [<a name="SUM_ADD_SPLIT-val"><b>SUM_ADD_SPLIT</b></a>]  Theorem
      
      ⊢ ∀f m n p.
          m ≤ n + 1 ⇒
          sum {m .. n + p} f = sum {m .. n} f + sum {n + 1 .. n + p} f
   
   [<a name="SUM_BIGUNION_NONZERO-val"><b>SUM_BIGUNION_NONZERO</b></a>]  Theorem
      
      ⊢ ∀f s.
          FINITE s ∧ (∀t. t ∈ s ⇒ FINITE t) ∧
          (∀t1 t2 x. t1 ∈ s ∧ t2 ∈ s ∧ t1 ≠ t2 ∧ x ∈ t1 ∧ x ∈ t2 ⇒ f x = 0) ⇒
          sum (BIGUNION s) f = sum s (λt. sum t f)
   
   [<a name="SUM_BIJECTION-val"><b>SUM_BIJECTION</b></a>]  Theorem
      
      ⊢ ∀f p s.
          (∀x. x ∈ s ⇒ p x ∈ s) ∧ (∀y. y ∈ s ⇒ ∃!x. x ∈ s ∧ p x = y) ⇒
          sum s f = sum s (f ∘ p)
   
   [<a name="SUM_BOUND'-val"><b>SUM_BOUND'</b></a>]  Theorem
      
      ⊢ ∀s f b. FINITE s ∧ (∀x. x ∈ s ⇒ f x ≤ b) ⇒ sum s f ≤ &CARD s * b
   
   [<a name="SUM_BOUND_GEN-val"><b>SUM_BOUND_GEN</b></a>]  Theorem
      
      ⊢ ∀s f b.
          FINITE s ∧ s ≠ ∅ ∧ (∀x. x ∈ s ⇒ f x ≤ b / &CARD s) ⇒ sum s f ≤ b
   
   [<a name="SUM_BOUND_LT-val"><b>SUM_BOUND_LT</b></a>]  Theorem
      
      ⊢ ∀s f b.
          FINITE s ∧ (∀x. x ∈ s ⇒ f x ≤ b) ∧ (∃x. x ∈ s ∧ f x &lt; b) ⇒
          sum s f &lt; &CARD s * b
   
   [<a name="SUM_BOUND_LT_ALL-val"><b>SUM_BOUND_LT_ALL</b></a>]  Theorem
      
      ⊢ ∀s f b.
          FINITE s ∧ s ≠ ∅ ∧ (∀x. x ∈ s ⇒ f x &lt; b) ⇒ sum s f &lt; &CARD s * b
   
   [<a name="SUM_BOUND_LT_GEN-val"><b>SUM_BOUND_LT_GEN</b></a>]  Theorem
      
      ⊢ ∀s f b.
          FINITE s ∧ s ≠ ∅ ∧ (∀x. x ∈ s ⇒ f x &lt; b / &CARD s) ⇒ sum s f &lt; b
   
   [<a name="SUM_CASES-val"><b>SUM_CASES</b></a>]  Theorem
      
      ⊢ ∀s P f g.
          FINITE s ⇒
          sum s (λx. if P x then f x else g x) =
          sum {x | x ∈ s ∧ P x} f + sum {x | x ∈ s ∧ ¬P x} g
   
   [<a name="SUM_CASES_1-val"><b>SUM_CASES_1</b></a>]  Theorem
      
      ⊢ ∀s a.
          FINITE s ∧ a ∈ s ⇒
          sum s (λx. if x = a then y else f x) = sum s f + (y − f a)
   
   [<a name="SUM_CLAUSES-val"><b>SUM_CLAUSES</b></a>]  Theorem
      
      ⊢ (∀f. sum ∅ f = 0) ∧
        ∀x f s.
          FINITE s ⇒
          sum (x INSERT s) f = if x ∈ s then sum s f else f x + sum s f
   
   [<a name="SUM_CLAUSES_LEFT-val"><b>SUM_CLAUSES_LEFT</b></a>]  Theorem
      
      ⊢ ∀f m n. m ≤ n ⇒ sum {m .. n} f = f m + sum {m + 1 .. n} f
   
   [<a name="SUM_CLAUSES_NUMSEG-val"><b>SUM_CLAUSES_NUMSEG</b></a>]  Theorem
      
      ⊢ (∀m. sum {m .. 0} f = if m = 0 then f 0 else 0) ∧
        ∀m n.
          sum {m .. SUC n} f =
          if m ≤ SUC n then sum {m .. n} f + f (SUC n) else sum {m .. n} f
   
   [<a name="SUM_CLAUSES_RIGHT-val"><b>SUM_CLAUSES_RIGHT</b></a>]  Theorem
      
      ⊢ ∀f m n. 0 &lt; n ∧ m ≤ n ⇒ sum {m .. n} f = sum {m .. n − 1} f + f n
   
   [<a name="SUM_CLOSED-val"><b>SUM_CLOSED</b></a>]  Theorem
      
      ⊢ ∀P f s.
          P 0 ∧ (∀x y. P x ∧ P y ⇒ P (x + y)) ∧ (∀a. a ∈ s ⇒ P (f a)) ⇒
          P (sum s f)
   
   [<a name="SUM_COMBINE_L-val"><b>SUM_COMBINE_L</b></a>]  Theorem
      
      ⊢ ∀f m n p.
          0 &lt; n ∧ m ≤ n ∧ n ≤ p + 1 ⇒
          sum {m .. n − 1} f + sum {n .. p} f = sum {m .. p} f
   
   [<a name="SUM_COMBINE_R-val"><b>SUM_COMBINE_R</b></a>]  Theorem
      
      ⊢ ∀f m n p.
          m ≤ n + 1 ∧ n ≤ p ⇒
          sum {m .. n} f + sum {n + 1 .. p} f = sum {m .. p} f
   
   [<a name="SUM_CONG-val"><b>SUM_CONG</b></a>]  Theorem
      
      ⊢ (∀f g s. (∀x. x ∈ s ⇒ f x = g x) ⇒ sum s (λi. f i) = sum s g) ∧
        (∀f g a b.
           (∀i. a ≤ i ∧ i ≤ b ⇒ f i = g i) ⇒
           sum {a .. b} (λi. f i) = sum {a .. b} g) ∧
        ∀f g p.
          (∀x. p x ⇒ f x = g x) ⇒ sum {y | p y} (λi. f i) = sum {y | p y} g
   
   [<a name="SUM_CONST-val"><b>SUM_CONST</b></a>]  Theorem
      
      ⊢ ∀c s. FINITE s ⇒ sum s (λn. c) = &CARD s * c
   
   [<a name="SUM_CONST_NUMSEG-val"><b>SUM_CONST_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀c m n. sum {m .. n} (λn. c) = &(n + 1 − m) * c
   
   [<a name="SUM_DEGENERATE-val"><b>SUM_DEGENERATE</b></a>]  Theorem
      
      ⊢ ∀f s. INFINITE {x | x ∈ s ∧ f x ≠ 0} ⇒ sum s f = 0
   
   [<a name="SUM_DELETE-val"><b>SUM_DELETE</b></a>]  Theorem
      
      ⊢ ∀f s a. FINITE s ∧ a ∈ s ⇒ sum (s DELETE a) f = sum s f − f a
   
   [<a name="SUM_DELETE_CASES-val"><b>SUM_DELETE_CASES</b></a>]  Theorem
      
      ⊢ ∀f s a.
          FINITE s ⇒
          sum (s DELETE a) f = if a ∈ s then sum s f − f a else sum s f
   
   [<a name="SUM_DELTA-val"><b>SUM_DELTA</b></a>]  Theorem
      
      ⊢ ∀s a. sum s (λx. if x = a then b else 0) = if a ∈ s then b else 0
   
   [<a name="SUM_DIFF'-val"><b>SUM_DIFF'</b></a>]  Theorem
      
      ⊢ ∀f s t. FINITE s ∧ t ⊆ s ⇒ sum (s DIFF t) f = sum s f − sum t f
   
   [<a name="SUM_DIFFS'-val"><b>SUM_DIFFS'</b></a>]  Theorem
      
      ⊢ ∀m n.
          sum {m .. n} (λk. f k − f (k + 1)) =
          if m ≤ n then f m − f (n + 1) else 0
   
   [<a name="SUM_DIFFS_ALT-val"><b>SUM_DIFFS_ALT</b></a>]  Theorem
      
      ⊢ ∀m n.
          sum {m .. n} (λk. f (k + 1) − f k) =
          if m ≤ n then f (n + 1) − f m else 0
   
   [<a name="SUM_EQ'-val"><b>SUM_EQ'</b></a>]  Theorem
      
      ⊢ ∀f g s. (∀x. x ∈ s ⇒ f x = g x) ⇒ sum s f = sum s g
   
   [<a name="SUM_EQ_0'-val"><b>SUM_EQ_0'</b></a>]  Theorem
      
      ⊢ ∀f s. (∀x. x ∈ s ⇒ f x = 0) ⇒ sum s f = 0
   
   [<a name="SUM_EQ_0_NUMSEG-val"><b>SUM_EQ_0_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n. (∀i. m ≤ i ∧ i ≤ n ⇒ f i = 0) ⇒ sum {m .. n} f = 0
   
   [<a name="SUM_EQ_COUNT-val"><b>SUM_EQ_COUNT</b></a>]  Theorem
      
      ⊢ ∀f g n. (∀i. i &lt; n ⇒ f i = g i) ⇒ sum (count n) f = sum (count n) g
   
   [<a name="SUM_EQ_GENERAL-val"><b>SUM_EQ_GENERAL</b></a>]  Theorem
      
      ⊢ ∀s t f g h.
          (∀y. y ∈ t ⇒ ∃!x. x ∈ s ∧ h x = y) ∧
          (∀x. x ∈ s ⇒ h x ∈ t ∧ g (h x) = f x) ⇒
          sum s f = sum t g
   
   [<a name="SUM_EQ_GENERAL_INVERSES-val"><b>SUM_EQ_GENERAL_INVERSES</b></a>]  Theorem
      
      ⊢ ∀s t f g h k.
          (∀y. y ∈ t ⇒ k y ∈ s ∧ h (k y) = y) ∧
          (∀x. x ∈ s ⇒ h x ∈ t ∧ k (h x) = x ∧ g (h x) = f x) ⇒
          sum s f = sum t g
   
   [<a name="SUM_EQ_NUMSEG-val"><b>SUM_EQ_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f g m n.
          (∀i. m ≤ i ∧ i ≤ n ⇒ f i = g i) ⇒ sum {m .. n} f = sum {m .. n} g
   
   [<a name="SUM_EQ_SUPERSET-val"><b>SUM_EQ_SUPERSET</b></a>]  Theorem
      
      ⊢ ∀f s t.
          FINITE t ∧ t ⊆ s ∧ (∀x. x ∈ t ⇒ f x = g x) ∧
          (∀x. x ∈ s ∧ x ∉ t ⇒ f x = 0) ⇒
          sum s f = sum t g
   
   [<a name="SUM_GP-val"><b>SUM_GP</b></a>]  Theorem
      
      ⊢ ∀x m n.
          sum {m .. n} (λi. x pow i) =
          if n &lt; m then 0
          else if x = 1 then &(n + 1 − m)
          else (x pow m − x pow SUC n) / (1 − x)
   
   [<a name="SUM_GP_BASIC-val"><b>SUM_GP_BASIC</b></a>]  Theorem
      
      ⊢ ∀x n. (1 − x) * sum {0 .. n} (λi. x pow i) = 1 − x pow SUC n
   
   [<a name="SUM_GP_MULTIPLIED-val"><b>SUM_GP_MULTIPLIED</b></a>]  Theorem
      
      ⊢ ∀x m n.
          m ≤ n ⇒
          (1 − x) * sum {m .. n} (λi. x pow i) = x pow m − x pow SUC n
   
   [<a name="SUM_GROUP'-val"><b>SUM_GROUP'</b></a>]  Theorem
      
      ⊢ ∀f g s t.
          FINITE s ∧ IMAGE f s ⊆ t ⇒
          sum t (λy. sum {x | x ∈ s ∧ f x = y} g) = sum s g
   
   [<a name="SUM_IMAGE-val"><b>SUM_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f g s.
          (∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y) ⇒
          sum (IMAGE f s) g = sum s (g ∘ f)
   
   [<a name="SUM_IMAGE_GEN-val"><b>SUM_IMAGE_GEN</b></a>]  Theorem
      
      ⊢ ∀f g s.
          FINITE s ⇒
          sum s g = sum (IMAGE f s) (λy. sum {x | x ∈ s ∧ f x = y} g)
   
   [<a name="SUM_IMAGE_LE-val"><b>SUM_IMAGE_LE</b></a>]  Theorem
      
      ⊢ ∀f g s.
          FINITE s ∧ (∀x. x ∈ s ⇒ 0 ≤ g (f x)) ⇒
          sum (IMAGE f s) g ≤ sum s (g ∘ f)
   
   [<a name="SUM_IMAGE_NONZERO-val"><b>SUM_IMAGE_NONZERO</b></a>]  Theorem
      
      ⊢ ∀d i s.
          FINITE s ∧
          (∀x y. x ∈ s ∧ y ∈ s ∧ x ≠ y ∧ i x = i y ⇒ d (i x) = 0) ⇒
          sum (IMAGE i s) d = sum s (d ∘ i)
   
   [<a name="SUM_INCL_EXCL-val"><b>SUM_INCL_EXCL</b></a>]  Theorem
      
      ⊢ ∀s t f.
          FINITE s ∧ FINITE t ⇒
          sum s f + sum t f = sum (s ∪ t) f + sum (s ∩ t) f
   
   [<a name="SUM_INJECTION-val"><b>SUM_INJECTION</b></a>]  Theorem
      
      ⊢ ∀f p s.
          FINITE s ∧ (∀x. x ∈ s ⇒ p x ∈ s) ∧
          (∀x y. x ∈ s ∧ y ∈ s ∧ p x = p y ⇒ x = y) ⇒
          sum s (f ∘ p) = sum s f
   
   [<a name="SUM_LE'-val"><b>SUM_LE'</b></a>]  Theorem
      
      ⊢ ∀f g s. FINITE s ∧ (∀x. x ∈ s ⇒ f x ≤ g x) ⇒ sum s f ≤ sum s g
   
   [<a name="SUM_LE_INCLUDED-val"><b>SUM_LE_INCLUDED</b></a>]  Theorem
      
      ⊢ ∀f g s t i.
          FINITE s ∧ FINITE t ∧ (∀y. y ∈ t ⇒ 0 ≤ g y) ∧
          (∀x. x ∈ s ⇒ ∃y. y ∈ t ∧ i y = x ∧ f x ≤ g y) ⇒
          sum s f ≤ sum t g
   
   [<a name="SUM_LE_NUMSEG-val"><b>SUM_LE_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f g m n.
          (∀i. m ≤ i ∧ i ≤ n ⇒ f i ≤ g i) ⇒ sum {m .. n} f ≤ sum {m .. n} g
   
   [<a name="SUM_LMUL-val"><b>SUM_LMUL</b></a>]  Theorem
      
      ⊢ ∀f c s. sum s (λx. c * f x) = c * sum s f
   
   [<a name="SUM_LT'-val"><b>SUM_LT'</b></a>]  Theorem
      
      ⊢ ∀f g s.
          FINITE s ∧ (∀x. x ∈ s ⇒ f x ≤ g x) ∧ (∃x. x ∈ s ∧ f x &lt; g x) ⇒
          sum s f &lt; sum s g
   
   [<a name="SUM_LT_ALL-val"><b>SUM_LT_ALL</b></a>]  Theorem
      
      ⊢ ∀f g s.
          FINITE s ∧ s ≠ ∅ ∧ (∀x. x ∈ s ⇒ f x &lt; g x) ⇒ sum s f &lt; sum s g
   
   [<a name="SUM_MULTICOUNT-val"><b>SUM_MULTICOUNT</b></a>]  Theorem
      
      ⊢ ∀R s t k.
          FINITE s ∧ FINITE t ∧ (∀j. j ∈ t ⇒ CARD {i | i ∈ s ∧ R i j} = k) ⇒
          sum s (λi. &CARD (equiv_class R t i)) = &(k * CARD t)
   
   [<a name="SUM_MULTICOUNT_GEN-val"><b>SUM_MULTICOUNT_GEN</b></a>]  Theorem
      
      ⊢ ∀R s t k.
          FINITE s ∧ FINITE t ∧
          (∀j. j ∈ t ⇒ CARD {i | i ∈ s ∧ R i j} = k j) ⇒
          sum s (λi. &CARD (equiv_class R t i)) = sum t (λi. &k i)
   
   [<a name="SUM_NEG'-val"><b>SUM_NEG'</b></a>]  Theorem
      
      ⊢ ∀f s. sum s (λx. -f x) = -sum s f
   
   [<a name="SUM_OFFSET'-val"><b>SUM_OFFSET'</b></a>]  Theorem
      
      ⊢ ∀p f m n. sum {m + p .. n + p} f = sum {m .. n} (λi. f (i + p))
   
   [<a name="SUM_OFFSET_0-val"><b>SUM_OFFSET_0</b></a>]  Theorem
      
      ⊢ ∀f m n. m ≤ n ⇒ sum {m .. n} f = sum {0 .. n − m} (λi. f (i + m))
   
   [<a name="SUM_PAIR-val"><b>SUM_PAIR</b></a>]  Theorem
      
      ⊢ ∀f m n.
          sum {2 * m .. 2 * n + 1} f =
          sum {m .. n} (λi. f (2 * i) + f (2 * i + 1))
   
   [<a name="SUM_PARTIAL_PRE-val"><b>SUM_PARTIAL_PRE</b></a>]  Theorem
      
      ⊢ ∀f g m n.
          sum {m .. n} (λk. f k * (g k − g (k − 1))) =
          if m ≤ n then
            f (n + 1) * g n − f m * g (m − 1) −
            sum {m .. n} (λk. g k * (f (k + 1) − f k))
          else 0
   
   [<a name="SUM_PARTIAL_SUC-val"><b>SUM_PARTIAL_SUC</b></a>]  Theorem
      
      ⊢ ∀f g m n.
          sum {m .. n} (λk. f k * (g (k + 1) − g k)) =
          if m ≤ n then
            f (n + 1) * g (n + 1) − f m * g m −
            sum {m .. n} (λk. g (k + 1) * (f (k + 1) − f k))
          else 0
   
   [<a name="SUM_PERMUTATIONS_COMPOSE_L-val"><b>SUM_PERMUTATIONS_COMPOSE_L</b></a>]  Theorem
      
      ⊢ ∀f s q.
          q permutes s ⇒
          sum {p | p permutes s} f = sum {p | p permutes s} (λp. f (q ∘ p))
   
   [<a name="SUM_PERMUTATIONS_COMPOSE_L_COUNT-val"><b>SUM_PERMUTATIONS_COMPOSE_L_COUNT</b></a>]  Theorem
      
      ⊢ ∀f n q.
          q permutes count n ⇒
          sum {p | p permutes count n} f =
          sum {p | p permutes count n} (λp. f (q ∘ p))
   
   [<a name="SUM_PERMUTATIONS_COMPOSE_L_NUMSEG-val"><b>SUM_PERMUTATIONS_COMPOSE_L_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n q.
          q permutes count n DIFF count m ⇒
          sum {p | p permutes count n DIFF count m} f =
          sum {p | p permutes count n DIFF count m} (λp. f (q ∘ p))
   
   [<a name="SUM_PERMUTATIONS_COMPOSE_R-val"><b>SUM_PERMUTATIONS_COMPOSE_R</b></a>]  Theorem
      
      ⊢ ∀f s q.
          q permutes s ⇒
          sum {p | p permutes s} f = sum {p | p permutes s} (λp. f (p ∘ q))
   
   [<a name="SUM_PERMUTATIONS_COMPOSE_R_COUNT-val"><b>SUM_PERMUTATIONS_COMPOSE_R_COUNT</b></a>]  Theorem
      
      ⊢ ∀f n q.
          q permutes count n ⇒
          sum {p | p permutes count n} f =
          sum {p | p permutes count n} (λp. f (p ∘ q))
   
   [<a name="SUM_PERMUTATIONS_COMPOSE_R_NUMSEG-val"><b>SUM_PERMUTATIONS_COMPOSE_R_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n q.
          q permutes count n DIFF count m ⇒
          sum {p | p permutes count n DIFF count m} f =
          sum {p | p permutes count n DIFF count m} (λp. f (p ∘ q))
   
   [<a name="SUM_PERMUTATIONS_INVERSE-val"><b>SUM_PERMUTATIONS_INVERSE</b></a>]  Theorem
      
      ⊢ ∀f n.
          sum {p | p permutes count n} f =
          sum {p | p permutes count n} (λp. f (inverse p))
   
   [<a name="SUM_PERMUTE-val"><b>SUM_PERMUTE</b></a>]  Theorem
      
      ⊢ ∀f p s. p permutes s ⇒ sum s f = sum s (f ∘ p)
   
   [<a name="SUM_PERMUTE_COUNT-val"><b>SUM_PERMUTE_COUNT</b></a>]  Theorem
      
      ⊢ ∀f p n.
          p permutes count n ⇒ sum (count n) f = sum (count n) (f ∘ p)
   
   [<a name="SUM_PERMUTE_NUMSEG-val"><b>SUM_PERMUTE_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f p m n.
          p permutes count n DIFF count m ⇒
          sum (count n DIFF count m) f = sum (count n DIFF count m) (f ∘ p)
   
   [<a name="SUM_POS_BOUND-val"><b>SUM_POS_BOUND</b></a>]  Theorem
      
      ⊢ ∀f b s.
          FINITE s ∧ (∀x. x ∈ s ⇒ 0 ≤ f x) ∧ sum s f ≤ b ⇒
          ∀x. x ∈ s ⇒ f x ≤ b
   
   [<a name="SUM_POS_EQ_0-val"><b>SUM_POS_EQ_0</b></a>]  Theorem
      
      ⊢ ∀f s.
          FINITE s ∧ (∀x. x ∈ s ⇒ 0 ≤ f x) ∧ sum s f = 0 ⇒
          ∀x. x ∈ s ⇒ f x = 0
   
   [<a name="SUM_POS_EQ_0_NUMSEG-val"><b>SUM_POS_EQ_0_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n.
          (∀p. m ≤ p ∧ p ≤ n ⇒ 0 ≤ f p) ∧ sum {m .. n} f = 0 ⇒
          ∀p. m ≤ p ∧ p ≤ n ⇒ f p = 0
   
   [<a name="SUM_POS_LE-val"><b>SUM_POS_LE</b></a>]  Theorem
      
      ⊢ ∀s. (∀x. x ∈ s ⇒ 0 ≤ f x) ⇒ 0 ≤ sum s f
   
   [<a name="SUM_POS_LE_NUMSEG-val"><b>SUM_POS_LE_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀m n f. (∀p. m ≤ p ∧ p ≤ n ⇒ 0 ≤ f p) ⇒ 0 ≤ sum {m .. n} f
   
   [<a name="SUM_POS_LT-val"><b>SUM_POS_LT</b></a>]  Theorem
      
      ⊢ ∀f s.
          FINITE s ∧ (∀x. x ∈ s ⇒ 0 ≤ f x) ∧ (∃x. x ∈ s ∧ 0 &lt; f x) ⇒
          0 &lt; sum s f
   
   [<a name="SUM_POS_LT_ALL-val"><b>SUM_POS_LT_ALL</b></a>]  Theorem
      
      ⊢ ∀s f. FINITE s ∧ s ≠ ∅ ∧ (∀i. i ∈ s ⇒ 0 &lt; f i) ⇒ 0 &lt; sum s f
   
   [<a name="SUM_RESTRICT-val"><b>SUM_RESTRICT</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ⇒ sum s (λx. if x ∈ s then f x else 0) = sum s f
   
   [<a name="SUM_RESTRICT_SET-val"><b>SUM_RESTRICT_SET</b></a>]  Theorem
      
      ⊢ ∀P s f.
          sum {x | x ∈ s ∧ P x} f = sum s (λx. if P x then f x else 0)
   
   [<a name="SUM_RMUL-val"><b>SUM_RMUL</b></a>]  Theorem
      
      ⊢ ∀f c s. sum s (λx. f x * c) = sum s f * c
   
   [<a name="SUM_SING-val"><b>SUM_SING</b></a>]  Theorem
      
      ⊢ ∀f x. sum {x} f = f x
   
   [<a name="SUM_SING_NUMSEG-val"><b>SUM_SING_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f n. sum {n .. n} f = f n
   
   [<a name="SUM_SUB'-val"><b>SUM_SUB'</b></a>]  Theorem
      
      ⊢ ∀f g s. FINITE s ⇒ sum s (λx. f x − g x) = sum s f − sum s g
   
   [<a name="SUM_SUBSET-val"><b>SUM_SUBSET</b></a>]  Theorem
      
      ⊢ ∀u v f.
          FINITE u ∧ FINITE v ∧ (∀x. x ∈ u DIFF v ⇒ f x ≤ 0) ∧
          (∀x. x ∈ v DIFF u ⇒ 0 ≤ f x) ⇒
          sum u f ≤ sum v f
   
   [<a name="SUM_SUBSET_SIMPLE-val"><b>SUM_SUBSET_SIMPLE</b></a>]  Theorem
      
      ⊢ ∀u v f.
          FINITE v ∧ u ⊆ v ∧ (∀x. x ∈ v DIFF u ⇒ 0 ≤ f x) ⇒
          sum u f ≤ sum v f
   
   [<a name="SUM_SUB_NUMSEG-val"><b>SUM_SUB_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f g m n.
          sum {m .. n} (λi. f i − g i) = sum {m .. n} f − sum {m .. n} g
   
   [<a name="SUM_SUM_PRODUCT-val"><b>SUM_SUM_PRODUCT</b></a>]  Theorem
      
      ⊢ ∀s t x.
          FINITE s ∧ (∀i. i ∈ s ⇒ FINITE (t i)) ⇒
          sum s (λi. sum (t i) (x i)) =
          sum {(i,j) | i ∈ s ∧ j ∈ t i} (λ(i,j). x i j)
   
   [<a name="SUM_SUM_RESTRICT-val"><b>SUM_SUM_RESTRICT</b></a>]  Theorem
      
      ⊢ ∀R f s t.
          FINITE s ∧ FINITE t ⇒
          sum s (λx. sum (equiv_class R t x) (λy. f x y)) =
          sum t (λy. sum {x | x ∈ s ∧ R x y} (λx. f x y))
   
   [<a name="SUM_SUPERSET-val"><b>SUM_SUPERSET</b></a>]  Theorem
      
      ⊢ ∀f u v. u ⊆ v ∧ (∀x. x ∈ v ∧ x ∉ u ⇒ f x = 0) ⇒ sum v f = sum u f
   
   [<a name="SUM_SUPPORT-val"><b>SUM_SUPPORT</b></a>]  Theorem
      
      ⊢ ∀f s. sum (support $+ f s) f = sum s f
   
   [<a name="SUM_SWAP-val"><b>SUM_SWAP</b></a>]  Theorem
      
      ⊢ ∀f s t.
          FINITE s ∧ FINITE t ⇒
          sum s (λi. sum t (f i)) = sum t (λj. sum s (λi. f i j))
   
   [<a name="SUM_SWAP_COUNT-val"><b>SUM_SWAP_COUNT</b></a>]  Theorem
      
      ⊢ ∀f m n.
          sum (count m) (λi. sum (count n) (f i)) =
          sum (count n) (λj. sum (count m) (λi. f i j))
   
   [<a name="SUM_SWAP_NUMSEG-val"><b>SUM_SWAP_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀a b c d f.
          sum {a .. b} (λi. sum {c .. d} (f i)) =
          sum {c .. d} (λj. sum {a .. b} (λi. f i j))
   
   [<a name="SUM_TRIV_NUMSEG-val"><b>SUM_TRIV_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n. n &lt; m ⇒ sum {m .. n} f = 0
   
   [<a name="SUM_UNION-val"><b>SUM_UNION</b></a>]  Theorem
      
      ⊢ ∀f s t.
          FINITE s ∧ FINITE t ∧ DISJOINT s t ⇒
          sum (s ∪ t) f = sum s f + sum t f
   
   [<a name="SUM_UNION_EQ-val"><b>SUM_UNION_EQ</b></a>]  Theorem
      
      ⊢ ∀s t u.
          FINITE u ∧ s ∩ t = ∅ ∧ s ∪ t = u ⇒ sum s f + sum t f = sum u f
   
   [<a name="SUM_UNION_LZERO-val"><b>SUM_UNION_LZERO</b></a>]  Theorem
      
      ⊢ ∀f u v.
          FINITE v ∧ (∀x. x ∈ u ∧ x ∉ v ⇒ f x = 0) ⇒
          sum (u ∪ v) f = sum v f
   
   [<a name="SUM_UNION_NONZERO-val"><b>SUM_UNION_NONZERO</b></a>]  Theorem
      
      ⊢ ∀f s t.
          FINITE s ∧ FINITE t ∧ (∀x. x ∈ s ∩ t ⇒ f x = 0) ⇒
          sum (s ∪ t) f = sum s f + sum t f
   
   [<a name="SUM_UNION_RZERO-val"><b>SUM_UNION_RZERO</b></a>]  Theorem
      
      ⊢ ∀f u v.
          FINITE u ∧ (∀x. x ∈ v ∧ x ∉ u ⇒ f x = 0) ⇒
          sum (u ∪ v) f = sum u f
   
   [<a name="SUM_ZERO_EXISTS-val"><b>SUM_ZERO_EXISTS</b></a>]  Theorem
      
      ⊢ ∀u s.
          FINITE s ∧ sum s u = 0 ⇒
          (∀i. i ∈ s ⇒ u i = 0) ∨ ∃j k. j ∈ s ∧ u j &lt; 0 ∧ k ∈ s ∧ u k &gt; 0
   
   [<a name="SUP-val"><b>SUP</b></a>]  Theorem
      
      ⊢ ∀s. s ≠ ∅ ∧ (∃b. ∀x. x ∈ s ⇒ x ≤ b) ⇒
            (∀x. x ∈ s ⇒ x ≤ sup s) ∧ ∀b. (∀x. x ∈ s ⇒ x ≤ b) ⇒ sup s ≤ b
   
   [<a name="SUPPORT_CLAUSES-val"><b>SUPPORT_CLAUSES</b></a>]  Theorem
      
      ⊢ (∀f. support op f ∅ = ∅) ∧
        (∀f x s.
           support op f (x INSERT s) =
           if f x = neutral op then support op f s
           else x INSERT support op f s) ∧
        (∀f x s. support op f (s DELETE x) = support op f s DELETE x) ∧
        (∀f s t. support op f (s ∪ t) = support op f s ∪ support op f t) ∧
        (∀f s t. support op f (s ∩ t) = support op f s ∩ support op f t) ∧
        (∀f s t.
           support op f (s DIFF t) = support op f s DIFF support op f t) ∧
        ∀f g s. support op g (IMAGE f s) = IMAGE f (support op (g ∘ f) s)
   
   [<a name="SUPPORT_DELTA-val"><b>SUPPORT_DELTA</b></a>]  Theorem
      
      ⊢ ∀op s f a.
          support op (λx. if x = a then f x else neutral op) s =
          if a ∈ s then support op f {a} else ∅
   
   [<a name="SUPPORT_EMPTY-val"><b>SUPPORT_EMPTY</b></a>]  Theorem
      
      ⊢ ∀op f s. (∀x. x ∈ s ⇒ f x = neutral op) ⇔ support op f s = ∅
   
   [<a name="SUPPORT_SUBSET-val"><b>SUPPORT_SUBSET</b></a>]  Theorem
      
      ⊢ ∀op f s. support op f s ⊆ s
   
   [<a name="SUPPORT_SUPPORT-val"><b>SUPPORT_SUPPORT</b></a>]  Theorem
      
      ⊢ ∀op f s. support op f (support op f s) = support op f s
   
   [<a name="SUP_EQ-val"><b>SUP_EQ</b></a>]  Theorem
      
      ⊢ ∀s t. (∀b. (∀x. x ∈ s ⇒ x ≤ b) ⇔ ∀x. x ∈ t ⇒ x ≤ b) ⇒ sup s = sup t
   
   [<a name="SUP_FINITE-val"><b>SUP_FINITE</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ∧ s ≠ ∅ ⇒ sup s ∈ s ∧ ∀x. x ∈ s ⇒ x ≤ sup s
   
   [<a name="SUP_FINITE_LEMMA-val"><b>SUP_FINITE_LEMMA</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ∧ s ≠ ∅ ⇒ ∃b. b ∈ s ∧ ∀x. x ∈ s ⇒ x ≤ b
   
   [<a name="SUP_INSERT_FINITE-val"><b>SUP_INSERT_FINITE</b></a>]  Theorem
      
      ⊢ ∀x s.
          FINITE s ⇒ sup (x INSERT s) = if s = ∅ then x else max x (sup s)
   
   [<a name="SUP_MONO-val"><b>SUP_MONO</b></a>]  Theorem
      
      ⊢ ∀p q.
          (∃b. ∀n. p n ≤ b) ∧ (∃c. ∀n. q n ≤ c) ∧ (∀n. p n ≤ q n) ⇒
          sup (IMAGE p 𝕌(:num)) ≤ sup (IMAGE q 𝕌(:num))
   
   [<a name="SUP_SING-val"><b>SUP_SING</b></a>]  Theorem
      
      ⊢ ∀a. sup {a} = a
   
   [<a name="SUP_UNION-val"><b>SUP_UNION</b></a>]  Theorem
      
      ⊢ ∀s t.
          s ≠ ∅ ∧ t ≠ ∅ ∧ (∃b. ∀x. x ∈ s ⇒ x ≤ b) ∧ (∃c. ∀x. x ∈ t ⇒ x ≤ c) ⇒
          sup (s ∪ t) = max (sup s) (sup t)
   
   [<a name="SUP_UNIQUE-val"><b>SUP_UNIQUE</b></a>]  Theorem
      
      ⊢ ∀s b. (∀c. (∀x. x ∈ s ⇒ x ≤ c) ⇔ b ≤ c) ⇒ sup s = b
   
   [<a name="SUP_UNIQUE_FINITE-val"><b>SUP_UNIQUE_FINITE</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ∧ s ≠ ∅ ⇒ (sup s = a ⇔ a ∈ s ∧ ∀y. y ∈ s ⇒ y ≤ a)
   
   [<a name="TOPOLOGICAL_SORT-val"><b>TOPOLOGICAL_SORT</b></a>]  Theorem
      
      ⊢ ∀ $&lt;&lt;.
          (∀x y. x &lt;&lt; y ∧ y &lt;&lt; x ⇒ x = y) ∧
          (∀x y z. x &lt;&lt; y ∧ y &lt;&lt; z ⇒ x &lt;&lt; z) ⇒
          ∀n s.
            s HAS_SIZE n ⇒
            ∃f. s = IMAGE f {1 .. n} ∧
                ∀j k. j ∈ {1 .. n} ∧ k ∈ {1 .. n} ∧ j &lt; k ⇒ ¬(f k &lt;&lt; f j)
   
   [<a name="TOPOLOGICAL_SORT'-val"><b>TOPOLOGICAL_SORT'</b></a>]  Theorem
      
      ⊢ ∀R s n.
          transitive R ∧ antisymmetric R ∧ s HAS_SIZE n ⇒
          ∃f. s = IMAGE f (count n) ∧
              ∀j k. j &lt; n ∧ k &lt; n ∧ j &lt; k ⇒ ¬R (f k) (f j)
   
   [<a name="TRANSITIVE_STEPWISE_LE-val"><b>TRANSITIVE_STEPWISE_LE</b></a>]  Theorem
      
      ⊢ ∀R. (∀x. R x x) ∧ (∀x y z. R x y ∧ R y z ⇒ R x z) ∧
            (∀n. R n (SUC n)) ⇒
            ∀m n. m ≤ n ⇒ R m n
   
   [<a name="TRANSITIVE_STEPWISE_LE_EQ-val"><b>TRANSITIVE_STEPWISE_LE_EQ</b></a>]  Theorem
      
      ⊢ ∀R. (∀x. R x x) ∧ (∀x y z. R x y ∧ R y z ⇒ R x z) ⇒
            ((∀m n. m ≤ n ⇒ R m n) ⇔ ∀n. R n (SUC n))
   
   [<a name="UNION_COUNT_FROM-val"><b>UNION_COUNT_FROM</b></a>]  Theorem
      
      ⊢ ∀n. count n ∪ from n = 𝕌(:num)
   
   [<a name="UNION_FROM_COUNT-val"><b>UNION_FROM_COUNT</b></a>]  Theorem
      
      ⊢ ∀n. from n ∪ count n = 𝕌(:num)
   
   [<a name="UPPER_BOUND_FINITE_SET-val"><b>UPPER_BOUND_FINITE_SET</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ⇒ ∃a. ∀x. x ∈ s ⇒ f x ≤ a
   
   [<a name="UPPER_BOUND_FINITE_SET_REAL-val"><b>UPPER_BOUND_FINITE_SET_REAL</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ⇒ ∃a. ∀x. x ∈ s ⇒ f x ≤ a
   
   [<a name="inf_alt-val"><b>inf_alt</b></a>]  Theorem
      
      ⊢ ∀s. s ≠ ∅ ∧ (∃b. ∀x. x ∈ s ⇒ b ≤ x) ⇒
            inf s =
            @a. (∀x. x ∈ s ⇒ a ≤ x) ∧ ∀b. (∀x. x ∈ s ⇒ b ≤ x) ⇒ b ≤ a
   
   [<a name="lifted-val"><b>lifted</b></a>]  Theorem
      
      ⊢ lifted op NONE v0 = NONE ∧ lifted op (SOME v5) NONE = NONE ∧
        lifted op (SOME x) (SOME y) = SOME (op x y)
   
   [<a name="lifted_ind-val"><b>lifted_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀op v0. P op NONE v0) ∧ (∀op v5. P op (SOME v5) NONE) ∧
            (∀op x y. P op (SOME x) (SOME y)) ⇒
            ∀v v1 v2. P v v1 v2
   
   [<a name="real_INFINITE-val"><b>real_INFINITE</b></a>]  Theorem
      
      ⊢ INFINITE 𝕌(:real)
   
   [<a name="sum_real-val"><b>sum_real</b></a>]  Theorem
      
      ⊢ ∀f n. sum {0 .. n} f = sum (0,SUC n) f
   
   [<a name="sup_alt-val"><b>sup_alt</b></a>]  Theorem
      
      ⊢ sup s = @a. (∀x. x ∈ s ⇒ x ≤ a) ∧ ∀b. (∀x. x ∈ s ⇒ x ≤ b) ⇒ a ≤ b
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/real/iterateScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-1</a></em></p></body></html>
