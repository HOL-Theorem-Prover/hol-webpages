<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure real_topologyTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure real_topologyTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/real/analysis/real_topologyScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature real_topologyTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#CLOSED_interval-val">CLOSED_interval</a> : thm
<a name="line7"></a>    val <a href="#OPEN_interval-val">OPEN_interval</a> : thm
<a name="line8"></a>    val <a href="#at_def-val">at_def</a> : thm
<a name="line9"></a>    val <a href="#at_infinity-val">at_infinity</a> : thm
<a name="line10"></a>    val <a href="#at_neginfinity-val">at_neginfinity</a> : thm
<a name="line11"></a>    val <a href="#at_posinfinity-val">at_posinfinity</a> : thm
<a name="line12"></a>    val <a href="#ball_def-val">ball_def</a> : thm
<a name="line13"></a>    val <a href="#between-val">between</a> : thm
<a name="line14"></a>    val <a href="#bilinear-val">bilinear</a> : thm
<a name="line15"></a>    val <a href="#bounded_def-val">bounded_def</a> : thm
<a name="line16"></a>    val <a href="#cauchy_def-val">cauchy_def</a> : thm
<a name="line17"></a>    val <a href="#cball-val">cball</a> : thm
<a name="line18"></a>    val <a href="#closed_segment-val">closed_segment</a> : thm
<a name="line19"></a>    val <a href="#closest_point-val">closest_point</a> : thm
<a name="line20"></a>    val <a href="#closure-val">closure</a> : thm
<a name="line21"></a>    val <a href="#collinear-val">collinear</a> : thm
<a name="line22"></a>    val <a href="#compact-val">compact</a> : thm
<a name="line23"></a>    val <a href="#complete-val">complete</a> : thm
<a name="line24"></a>    val <a href="#components-val">components</a> : thm
<a name="line25"></a>    val <a href="#condensation_point_of-val">condensation_point_of</a> : thm
<a name="line26"></a>    val <a href="#connected-val">connected</a> : thm
<a name="line27"></a>    val <a href="#connected_component-val">connected_component</a> : thm
<a name="line28"></a>    val <a href="#content-val">content</a> : thm
<a name="line29"></a>    val <a href="#continuous-val">continuous</a> : thm
<a name="line30"></a>    val <a href="#continuous_on-val">continuous_on</a> : thm
<a name="line31"></a>    val <a href="#dependent-val">dependent</a> : thm
<a name="line32"></a>    val <a href="#dim-val">dim</a> : thm
<a name="line33"></a>    val <a href="#dist_def-val">dist_def</a> : thm
<a name="line34"></a>    val <a href="#euclidean_closed_def-val">euclidean_closed_def</a> : thm
<a name="line35"></a>    val <a href="#euclidean_def-val">euclidean_def</a> : thm
<a name="line36"></a>    val <a href="#euclidean_open_def-val">euclidean_open_def</a> : thm
<a name="line37"></a>    val <a href="#eventually-val">eventually</a> : thm
<a name="line38"></a>    val <a href="#frontier-val">frontier</a> : thm
<a name="line39"></a>    val <a href="#hausdist-val">hausdist</a> : thm
<a name="line40"></a>    val <a href="#homeomorphic-val">homeomorphic</a> : thm
<a name="line41"></a>    val <a href="#homeomorphism-val">homeomorphism</a> : thm
<a name="line42"></a>    val <a href="#in_direction-val">in_direction</a> : thm
<a name="line43"></a>    val <a href="#independent-val">independent</a> : thm
<a name="line44"></a>    val <a href="#interior-val">interior</a> : thm
<a name="line45"></a>    val <a href="#interval_lowerbound-val">interval_lowerbound</a> : thm
<a name="line46"></a>    val <a href="#interval_upperbound-val">interval_upperbound</a> : thm
<a name="line47"></a>    val <a href="#is_interval-val">is_interval</a> : thm
<a name="line48"></a>    val <a href="#isnet-val">isnet</a> : thm
<a name="line49"></a>    val <a href="#limit_point_of_def-val">limit_point_of_def</a> : thm
<a name="line50"></a>    val <a href="#linear-val">linear</a> : thm
<a name="line51"></a>    val <a href="#locally-val">locally</a> : thm
<a name="line52"></a>    val <a href="#midpoint-val">midpoint</a> : thm
<a name="line53"></a>    val <a href="#net_TY_DEF-val">net_TY_DEF</a> : thm
<a name="line54"></a>    val <a href="#netlimit-val">netlimit</a> : thm
<a name="line55"></a>    val <a href="#open_segment-val">open_segment</a> : thm
<a name="line56"></a>    val <a href="#reallim-val">reallim</a> : thm
<a name="line57"></a>    val <a href="#sequentially-val">sequentially</a> : thm
<a name="line58"></a>    val <a href="#set_diameter_def-val">set_diameter_def</a> : thm
<a name="line59"></a>    val <a href="#set_dist_def-val">set_dist_def</a> : thm
<a name="line60"></a>    val <a href="#span-val">span</a> : thm
<a name="line61"></a>    val <a href="#sphere-val">sphere</a> : thm
<a name="line62"></a>    val <a href="#subspace-val">subspace</a> : thm
<a name="line63"></a>    val <a href="#suminf_def-val">suminf_def</a> : thm
<a name="line64"></a>    val <a href="#summable_def-val">summable_def</a> : thm
<a name="line65"></a>    val <a href="#sums_def-val">sums_def</a> : thm
<a name="line66"></a>    val <a href="#tendsto_real-val">tendsto_real</a> : thm
<a name="line67"></a>    val <a href="#trivial_limit-val">trivial_limit</a> : thm
<a name="line68"></a>    val <a href="#uniformly_continuous_on-val">uniformly_continuous_on</a> : thm
<a name="line69"></a>    val <a href="#within-val">within</a> : thm
<a name="line70"></a>  
<a name="line71"></a>  (*  Theorems  *)
<a name="line72"></a>    val <a href="#ABS_CAUCHY_SCHWARZ_ABS_EQ-val">ABS_CAUCHY_SCHWARZ_ABS_EQ</a> : thm
<a name="line73"></a>    val <a href="#ABS_CAUCHY_SCHWARZ_EQ-val">ABS_CAUCHY_SCHWARZ_EQ</a> : thm
<a name="line74"></a>    val <a href="#ABS_CAUCHY_SCHWARZ_EQUAL-val">ABS_CAUCHY_SCHWARZ_EQUAL</a> : thm
<a name="line75"></a>    val <a href="#ABS_SUM_TRIVIAL_LEMMA-val">ABS_SUM_TRIVIAL_LEMMA</a> : thm
<a name="line76"></a>    val <a href="#ABS_TRIANGLE_EQ-val">ABS_TRIANGLE_EQ</a> : thm
<a name="line77"></a>    val <a href="#ABS_TRIANGLE_LE-val">ABS_TRIANGLE_LE</a> : thm
<a name="line78"></a>    val <a href="#AFFINITY_INVERSES-val">AFFINITY_INVERSES</a> : thm
<a name="line79"></a>    val <a href="#ALWAYS_EVENTUALLY-val">ALWAYS_EVENTUALLY</a> : thm
<a name="line80"></a>    val <a href="#APPROACHABLE_LT_LE-val">APPROACHABLE_LT_LE</a> : thm
<a name="line81"></a>    val <a href="#AT-val">AT</a> : thm
<a name="line82"></a>    val <a href="#AT_INFINITY-val">AT_INFINITY</a> : thm
<a name="line83"></a>    val <a href="#AT_NEGINFINITY-val">AT_NEGINFINITY</a> : thm
<a name="line84"></a>    val <a href="#AT_POSINFINITY-val">AT_POSINFINITY</a> : thm
<a name="line85"></a>    val <a href="#BAIRE-val">BAIRE</a> : thm
<a name="line86"></a>    val <a href="#BAIRE_ALT-val">BAIRE_ALT</a> : thm
<a name="line87"></a>    val <a href="#BALL-val">BALL</a> : thm
<a name="line88"></a>    val <a href="#BALL_EMPTY-val">BALL_EMPTY</a> : thm
<a name="line89"></a>    val <a href="#BALL_EQ_EMPTY-val">BALL_EQ_EMPTY</a> : thm
<a name="line90"></a>    val <a href="#BALL_INTERVAL-val">BALL_INTERVAL</a> : thm
<a name="line91"></a>    val <a href="#BALL_INTERVAL_0-val">BALL_INTERVAL_0</a> : thm
<a name="line92"></a>    val <a href="#BALL_LINEAR_IMAGE-val">BALL_LINEAR_IMAGE</a> : thm
<a name="line93"></a>    val <a href="#BALL_MAX_UNION-val">BALL_MAX_UNION</a> : thm
<a name="line94"></a>    val <a href="#BALL_MIN_INTER-val">BALL_MIN_INTER</a> : thm
<a name="line95"></a>    val <a href="#BALL_SCALING-val">BALL_SCALING</a> : thm
<a name="line96"></a>    val <a href="#BALL_SUBSET_CBALL-val">BALL_SUBSET_CBALL</a> : thm
<a name="line97"></a>    val <a href="#BALL_TRANSLATION-val">BALL_TRANSLATION</a> : thm
<a name="line98"></a>    val <a href="#BALL_TRIVIAL-val">BALL_TRIVIAL</a> : thm
<a name="line99"></a>    val <a href="#BALL_UNION_SPHERE-val">BALL_UNION_SPHERE</a> : thm
<a name="line100"></a>    val <a href="#BANACH_FIX-val">BANACH_FIX</a> : thm
<a name="line101"></a>    val <a href="#BASIS_CARD_EQ_DIM-val">BASIS_CARD_EQ_DIM</a> : thm
<a name="line102"></a>    val <a href="#BASIS_EXISTS-val">BASIS_EXISTS</a> : thm
<a name="line103"></a>    val <a href="#BASIS_HAS_SIZE_DIM-val">BASIS_HAS_SIZE_DIM</a> : thm
<a name="line104"></a>    val <a href="#BETWEEN_ABS-val">BETWEEN_ABS</a> : thm
<a name="line105"></a>    val <a href="#BETWEEN_ANTISYM-val">BETWEEN_ANTISYM</a> : thm
<a name="line106"></a>    val <a href="#BETWEEN_IMP_COLLINEAR-val">BETWEEN_IMP_COLLINEAR</a> : thm
<a name="line107"></a>    val <a href="#BETWEEN_IN_SEGMENT-val">BETWEEN_IN_SEGMENT</a> : thm
<a name="line108"></a>    val <a href="#BETWEEN_MIDPOINT-val">BETWEEN_MIDPOINT</a> : thm
<a name="line109"></a>    val <a href="#BETWEEN_REFL-val">BETWEEN_REFL</a> : thm
<a name="line110"></a>    val <a href="#BETWEEN_REFL_EQ-val">BETWEEN_REFL_EQ</a> : thm
<a name="line111"></a>    val <a href="#BETWEEN_SYM-val">BETWEEN_SYM</a> : thm
<a name="line112"></a>    val <a href="#BETWEEN_TRANS-val">BETWEEN_TRANS</a> : thm
<a name="line113"></a>    val <a href="#BETWEEN_TRANS_2-val">BETWEEN_TRANS_2</a> : thm
<a name="line114"></a>    val <a href="#BIGUNION_COMPONENTS-val">BIGUNION_COMPONENTS</a> : thm
<a name="line115"></a>    val <a href="#BIGUNION_CONNECTED_COMPONENT-val">BIGUNION_CONNECTED_COMPONENT</a> : thm
<a name="line116"></a>    val <a href="#BIGUNION_DIFF-val">BIGUNION_DIFF</a> : thm
<a name="line117"></a>    val <a href="#BIGUNION_MONO-val">BIGUNION_MONO</a> : thm
<a name="line118"></a>    val <a href="#BIGUNION_MONO_IMAGE-val">BIGUNION_MONO_IMAGE</a> : thm
<a name="line119"></a>    val <a href="#BILINEAR_BOUNDED-val">BILINEAR_BOUNDED</a> : thm
<a name="line120"></a>    val <a href="#BILINEAR_BOUNDED_POS-val">BILINEAR_BOUNDED_POS</a> : thm
<a name="line121"></a>    val <a href="#BILINEAR_CONTINUOUS_COMPOSE-val">BILINEAR_CONTINUOUS_COMPOSE</a> : thm
<a name="line122"></a>    val <a href="#BILINEAR_CONTINUOUS_ON_COMPOSE-val">BILINEAR_CONTINUOUS_ON_COMPOSE</a> : thm
<a name="line123"></a>    val <a href="#BILINEAR_DOT-val">BILINEAR_DOT</a> : thm
<a name="line124"></a>    val <a href="#BILINEAR_LADD-val">BILINEAR_LADD</a> : thm
<a name="line125"></a>    val <a href="#BILINEAR_LMUL-val">BILINEAR_LMUL</a> : thm
<a name="line126"></a>    val <a href="#BILINEAR_LNEG-val">BILINEAR_LNEG</a> : thm
<a name="line127"></a>    val <a href="#BILINEAR_LSUB-val">BILINEAR_LSUB</a> : thm
<a name="line128"></a>    val <a href="#BILINEAR_LZERO-val">BILINEAR_LZERO</a> : thm
<a name="line129"></a>    val <a href="#BILINEAR_RADD-val">BILINEAR_RADD</a> : thm
<a name="line130"></a>    val <a href="#BILINEAR_RMUL-val">BILINEAR_RMUL</a> : thm
<a name="line131"></a>    val <a href="#BILINEAR_RNEG-val">BILINEAR_RNEG</a> : thm
<a name="line132"></a>    val <a href="#BILINEAR_RSUB-val">BILINEAR_RSUB</a> : thm
<a name="line133"></a>    val <a href="#BILINEAR_RZERO-val">BILINEAR_RZERO</a> : thm
<a name="line134"></a>    val <a href="#BILINEAR_SUM-val">BILINEAR_SUM</a> : thm
<a name="line135"></a>    val <a href="#BILINEAR_SUM_PARTIAL_PRE-val">BILINEAR_SUM_PARTIAL_PRE</a> : thm
<a name="line136"></a>    val <a href="#BILINEAR_SUM_PARTIAL_SUC-val">BILINEAR_SUM_PARTIAL_SUC</a> : thm
<a name="line137"></a>    val <a href="#BILINEAR_SWAP-val">BILINEAR_SWAP</a> : thm
<a name="line138"></a>    val <a href="#BILINEAR_UNIFORMLY_CONTINUOUS_ON_COMPOSE-val">BILINEAR_UNIFORMLY_CONTINUOUS_ON_COMPOSE</a> : thm
<a name="line139"></a>    val <a href="#BOLZANO_WEIERSTRASS-val">BOLZANO_WEIERSTRASS</a> : thm
<a name="line140"></a>    val <a href="#BOLZANO_WEIERSTRASS_CONTRAPOS-val">BOLZANO_WEIERSTRASS_CONTRAPOS</a> : thm
<a name="line141"></a>    val <a href="#BOLZANO_WEIERSTRASS_IMP_BOUNDED-val">BOLZANO_WEIERSTRASS_IMP_BOUNDED</a> : thm
<a name="line142"></a>    val <a href="#BOLZANO_WEIERSTRASS_IMP_CLOSED-val">BOLZANO_WEIERSTRASS_IMP_CLOSED</a> : thm
<a name="line143"></a>    val <a href="#BOUNDED_BALL-val">BOUNDED_BALL</a> : thm
<a name="line144"></a>    val <a href="#BOUNDED_BIGINTER-val">BOUNDED_BIGINTER</a> : thm
<a name="line145"></a>    val <a href="#BOUNDED_BIGUNION-val">BOUNDED_BIGUNION</a> : thm
<a name="line146"></a>    val <a href="#BOUNDED_CBALL-val">BOUNDED_CBALL</a> : thm
<a name="line147"></a>    val <a href="#BOUNDED_CLOSED_CHAIN-val">BOUNDED_CLOSED_CHAIN</a> : thm
<a name="line148"></a>    val <a href="#BOUNDED_CLOSED_IMP_COMPACT-val">BOUNDED_CLOSED_IMP_COMPACT</a> : thm
<a name="line149"></a>    val <a href="#BOUNDED_CLOSED_INTERVAL-val">BOUNDED_CLOSED_INTERVAL</a> : thm
<a name="line150"></a>    val <a href="#BOUNDED_CLOSED_NEST-val">BOUNDED_CLOSED_NEST</a> : thm
<a name="line151"></a>    val <a href="#BOUNDED_CLOSURE-val">BOUNDED_CLOSURE</a> : thm
<a name="line152"></a>    val <a href="#BOUNDED_CLOSURE_EQ-val">BOUNDED_CLOSURE_EQ</a> : thm
<a name="line153"></a>    val <a href="#BOUNDED_COMPONENTWISE-val">BOUNDED_COMPONENTWISE</a> : thm
<a name="line154"></a>    val <a href="#BOUNDED_DECREASING_CONVERGENT-val">BOUNDED_DECREASING_CONVERGENT</a> : thm
<a name="line155"></a>    val <a href="#BOUNDED_DIFF-val">BOUNDED_DIFF</a> : thm
<a name="line156"></a>    val <a href="#BOUNDED_DIFFS-val">BOUNDED_DIFFS</a> : thm
<a name="line157"></a>    val <a href="#BOUNDED_EMPTY-val">BOUNDED_EMPTY</a> : thm
<a name="line158"></a>    val <a href="#BOUNDED_EQ_BOLZANO_WEIERSTRASS-val">BOUNDED_EQ_BOLZANO_WEIERSTRASS</a> : thm
<a name="line159"></a>    val <a href="#BOUNDED_FRONTIER-val">BOUNDED_FRONTIER</a> : thm
<a name="line160"></a>    val <a href="#BOUNDED_HAS_INF-val">BOUNDED_HAS_INF</a> : thm
<a name="line161"></a>    val <a href="#BOUNDED_HAS_SUP-val">BOUNDED_HAS_SUP</a> : thm
<a name="line162"></a>    val <a href="#BOUNDED_INCREASING_CONVERGENT-val">BOUNDED_INCREASING_CONVERGENT</a> : thm
<a name="line163"></a>    val <a href="#BOUNDED_INSERT-val">BOUNDED_INSERT</a> : thm
<a name="line164"></a>    val <a href="#BOUNDED_INTER-val">BOUNDED_INTER</a> : thm
<a name="line165"></a>    val <a href="#BOUNDED_INTERIOR-val">BOUNDED_INTERIOR</a> : thm
<a name="line166"></a>    val <a href="#BOUNDED_INTERVAL-val">BOUNDED_INTERVAL</a> : thm
<a name="line167"></a>    val <a href="#BOUNDED_LINEAR_IMAGE-val">BOUNDED_LINEAR_IMAGE</a> : thm
<a name="line168"></a>    val <a href="#BOUNDED_NEGATIONS-val">BOUNDED_NEGATIONS</a> : thm
<a name="line169"></a>    val <a href="#BOUNDED_PARTIAL_SUMS-val">BOUNDED_PARTIAL_SUMS</a> : thm
<a name="line170"></a>    val <a href="#BOUNDED_POS-val">BOUNDED_POS</a> : thm
<a name="line171"></a>    val <a href="#BOUNDED_POS_LT-val">BOUNDED_POS_LT</a> : thm
<a name="line172"></a>    val <a href="#BOUNDED_SCALING-val">BOUNDED_SCALING</a> : thm
<a name="line173"></a>    val <a href="#BOUNDED_SING-val">BOUNDED_SING</a> : thm
<a name="line174"></a>    val <a href="#BOUNDED_SPHERE-val">BOUNDED_SPHERE</a> : thm
<a name="line175"></a>    val <a href="#BOUNDED_SUBSET-val">BOUNDED_SUBSET</a> : thm
<a name="line176"></a>    val <a href="#BOUNDED_SUBSET_BALL-val">BOUNDED_SUBSET_BALL</a> : thm
<a name="line177"></a>    val <a href="#BOUNDED_SUBSET_CBALL-val">BOUNDED_SUBSET_CBALL</a> : thm
<a name="line178"></a>    val <a href="#BOUNDED_SUBSET_CLOSED_INTERVAL-val">BOUNDED_SUBSET_CLOSED_INTERVAL</a> : thm
<a name="line179"></a>    val <a href="#BOUNDED_SUBSET_CLOSED_INTERVAL_SYMMETRIC-val">BOUNDED_SUBSET_CLOSED_INTERVAL_SYMMETRIC</a> : thm
<a name="line180"></a>    val <a href="#BOUNDED_SUBSET_OPEN_INTERVAL-val">BOUNDED_SUBSET_OPEN_INTERVAL</a> : thm
<a name="line181"></a>    val <a href="#BOUNDED_SUBSET_OPEN_INTERVAL_SYMMETRIC-val">BOUNDED_SUBSET_OPEN_INTERVAL_SYMMETRIC</a> : thm
<a name="line182"></a>    val <a href="#BOUNDED_SUMS-val">BOUNDED_SUMS</a> : thm
<a name="line183"></a>    val <a href="#BOUNDED_SUMS_IMAGE-val">BOUNDED_SUMS_IMAGE</a> : thm
<a name="line184"></a>    val <a href="#BOUNDED_SUMS_IMAGES-val">BOUNDED_SUMS_IMAGES</a> : thm
<a name="line185"></a>    val <a href="#BOUNDED_TRANSLATION-val">BOUNDED_TRANSLATION</a> : thm
<a name="line186"></a>    val <a href="#BOUNDED_TRANSLATION_EQ-val">BOUNDED_TRANSLATION_EQ</a> : thm
<a name="line187"></a>    val <a href="#BOUNDED_UNIFORMLY_CONTINUOUS_IMAGE-val">BOUNDED_UNIFORMLY_CONTINUOUS_IMAGE</a> : thm
<a name="line188"></a>    val <a href="#BOUNDED_UNION-val">BOUNDED_UNION</a> : thm
<a name="line189"></a>    val <a href="#CARD_EQ_BALL-val">CARD_EQ_BALL</a> : thm
<a name="line190"></a>    val <a href="#CARD_EQ_CBALL-val">CARD_EQ_CBALL</a> : thm
<a name="line191"></a>    val <a href="#CARD_EQ_EUCLIDEAN-val">CARD_EQ_EUCLIDEAN</a> : thm
<a name="line192"></a>    val <a href="#CARD_EQ_INTERVAL-val">CARD_EQ_INTERVAL</a> : thm
<a name="line193"></a>    val <a href="#CARD_EQ_OPEN-val">CARD_EQ_OPEN</a> : thm
<a name="line194"></a>    val <a href="#CARD_EQ_REAL-val">CARD_EQ_REAL</a> : thm
<a name="line195"></a>    val <a href="#CARD_EQ_REAL_IMP_UNCOUNTABLE-val">CARD_EQ_REAL_IMP_UNCOUNTABLE</a> : thm
<a name="line196"></a>    val <a href="#CARD_FRONTIER_INTERVAL-val">CARD_FRONTIER_INTERVAL</a> : thm
<a name="line197"></a>    val <a href="#CARD_GE_DIM_INDEPENDENT-val">CARD_GE_DIM_INDEPENDENT</a> : thm
<a name="line198"></a>    val <a href="#CARD_STDBASIS-val">CARD_STDBASIS</a> : thm
<a name="line199"></a>    val <a href="#CAUCHY-val">CAUCHY</a> : thm
<a name="line200"></a>    val <a href="#CAUCHY_CONTINUOUS_EXTENDS_TO_CLOSURE-val">CAUCHY_CONTINUOUS_EXTENDS_TO_CLOSURE</a> : thm
<a name="line201"></a>    val <a href="#CAUCHY_CONTINUOUS_IMP_CONTINUOUS-val">CAUCHY_CONTINUOUS_IMP_CONTINUOUS</a> : thm
<a name="line202"></a>    val <a href="#CAUCHY_CONTINUOUS_UNIQUENESS_LEMMA-val">CAUCHY_CONTINUOUS_UNIQUENESS_LEMMA</a> : thm
<a name="line203"></a>    val <a href="#CAUCHY_IMP_BOUNDED-val">CAUCHY_IMP_BOUNDED</a> : thm
<a name="line204"></a>    val <a href="#CAUCHY_ISOMETRIC-val">CAUCHY_ISOMETRIC</a> : thm
<a name="line205"></a>    val <a href="#CBALL_DIFF_BALL-val">CBALL_DIFF_BALL</a> : thm
<a name="line206"></a>    val <a href="#CBALL_DIFF_SPHERE-val">CBALL_DIFF_SPHERE</a> : thm
<a name="line207"></a>    val <a href="#CBALL_EMPTY-val">CBALL_EMPTY</a> : thm
<a name="line208"></a>    val <a href="#CBALL_EQ_EMPTY-val">CBALL_EQ_EMPTY</a> : thm
<a name="line209"></a>    val <a href="#CBALL_EQ_SING-val">CBALL_EQ_SING</a> : thm
<a name="line210"></a>    val <a href="#CBALL_INTERVAL-val">CBALL_INTERVAL</a> : thm
<a name="line211"></a>    val <a href="#CBALL_INTERVAL_0-val">CBALL_INTERVAL_0</a> : thm
<a name="line212"></a>    val <a href="#CBALL_LINEAR_IMAGE-val">CBALL_LINEAR_IMAGE</a> : thm
<a name="line213"></a>    val <a href="#CBALL_MAX_UNION-val">CBALL_MAX_UNION</a> : thm
<a name="line214"></a>    val <a href="#CBALL_MIN_INTER-val">CBALL_MIN_INTER</a> : thm
<a name="line215"></a>    val <a href="#CBALL_SCALING-val">CBALL_SCALING</a> : thm
<a name="line216"></a>    val <a href="#CBALL_SING-val">CBALL_SING</a> : thm
<a name="line217"></a>    val <a href="#CBALL_TRANSLATION-val">CBALL_TRANSLATION</a> : thm
<a name="line218"></a>    val <a href="#CBALL_TRIVIAL-val">CBALL_TRIVIAL</a> : thm
<a name="line219"></a>    val <a href="#CENTRE_IN_BALL-val">CENTRE_IN_BALL</a> : thm
<a name="line220"></a>    val <a href="#CENTRE_IN_CBALL-val">CENTRE_IN_CBALL</a> : thm
<a name="line221"></a>    val <a href="#CLOPEN-val">CLOPEN</a> : thm
<a name="line222"></a>    val <a href="#CLOPEN_BIGUNION_COMPONENTS-val">CLOPEN_BIGUNION_COMPONENTS</a> : thm
<a name="line223"></a>    val <a href="#CLOPEN_IN_COMPONENTS-val">CLOPEN_IN_COMPONENTS</a> : thm
<a name="line224"></a>    val <a href="#CLOSED-val">CLOSED</a> : thm
<a name="line225"></a>    val <a href="#CLOSED_APPROACHABLE-val">CLOSED_APPROACHABLE</a> : thm
<a name="line226"></a>    val <a href="#CLOSED_AS_GDELTA-val">CLOSED_AS_GDELTA</a> : thm
<a name="line227"></a>    val <a href="#CLOSED_BIGINTER-val">CLOSED_BIGINTER</a> : thm
<a name="line228"></a>    val <a href="#CLOSED_BIGINTER_COMPACT-val">CLOSED_BIGINTER_COMPACT</a> : thm
<a name="line229"></a>    val <a href="#CLOSED_BIGUNION-val">CLOSED_BIGUNION</a> : thm
<a name="line230"></a>    val <a href="#CLOSED_CBALL-val">CLOSED_CBALL</a> : thm
<a name="line231"></a>    val <a href="#CLOSED_CLOSURE-val">CLOSED_CLOSURE</a> : thm
<a name="line232"></a>    val <a href="#CLOSED_COMPACT_DIFFERENCES-val">CLOSED_COMPACT_DIFFERENCES</a> : thm
<a name="line233"></a>    val <a href="#CLOSED_COMPACT_SUMS-val">CLOSED_COMPACT_SUMS</a> : thm
<a name="line234"></a>    val <a href="#CLOSED_COMPONENTS-val">CLOSED_COMPONENTS</a> : thm
<a name="line235"></a>    val <a href="#CLOSED_CONNECTED_COMPONENT-val">CLOSED_CONNECTED_COMPONENT</a> : thm
<a name="line236"></a>    val <a href="#CLOSED_CONTAINS_SEQUENTIAL_LIMIT-val">CLOSED_CONTAINS_SEQUENTIAL_LIMIT</a> : thm
<a name="line237"></a>    val <a href="#CLOSED_DIFF-val">CLOSED_DIFF</a> : thm
<a name="line238"></a>    val <a href="#CLOSED_DIFF_OPEN_INTERVAL-val">CLOSED_DIFF_OPEN_INTERVAL</a> : thm
<a name="line239"></a>    val <a href="#CLOSED_EMPTY-val">CLOSED_EMPTY</a> : thm
<a name="line240"></a>    val <a href="#CLOSED_FIP-val">CLOSED_FIP</a> : thm
<a name="line241"></a>    val <a href="#CLOSED_FORALL-val">CLOSED_FORALL</a> : thm
<a name="line242"></a>    val <a href="#CLOSED_FORALL_IN-val">CLOSED_FORALL_IN</a> : thm
<a name="line243"></a>    val <a href="#CLOSED_HALFSPACE_COMPONENT_GE-val">CLOSED_HALFSPACE_COMPONENT_GE</a> : thm
<a name="line244"></a>    val <a href="#CLOSED_HALFSPACE_COMPONENT_LE-val">CLOSED_HALFSPACE_COMPONENT_LE</a> : thm
<a name="line245"></a>    val <a href="#CLOSED_HALFSPACE_GE-val">CLOSED_HALFSPACE_GE</a> : thm
<a name="line246"></a>    val <a href="#CLOSED_HALFSPACE_LE-val">CLOSED_HALFSPACE_LE</a> : thm
<a name="line247"></a>    val <a href="#CLOSED_HYPERPLANE-val">CLOSED_HYPERPLANE</a> : thm
<a name="line248"></a>    val <a href="#CLOSED_IMP_FIP-val">CLOSED_IMP_FIP</a> : thm
<a name="line249"></a>    val <a href="#CLOSED_IMP_FIP_COMPACT-val">CLOSED_IMP_FIP_COMPACT</a> : thm
<a name="line250"></a>    val <a href="#CLOSED_IMP_LOCALLY_COMPACT-val">CLOSED_IMP_LOCALLY_COMPACT</a> : thm
<a name="line251"></a>    val <a href="#CLOSED_IN-val">CLOSED_IN</a> : thm
<a name="line252"></a>    val <a href="#CLOSED_INJECTIVE_IMAGE_SUBSPACE-val">CLOSED_INJECTIVE_IMAGE_SUBSPACE</a> : thm
<a name="line253"></a>    val <a href="#CLOSED_INJECTIVE_LINEAR_IMAGE-val">CLOSED_INJECTIVE_LINEAR_IMAGE</a> : thm
<a name="line254"></a>    val <a href="#CLOSED_INJECTIVE_LINEAR_IMAGE_EQ-val">CLOSED_INJECTIVE_LINEAR_IMAGE_EQ</a> : thm
<a name="line255"></a>    val <a href="#CLOSED_INSERT-val">CLOSED_INSERT</a> : thm
<a name="line256"></a>    val <a href="#CLOSED_INTER-val">CLOSED_INTER</a> : thm
<a name="line257"></a>    val <a href="#CLOSED_INTERVAL-val">CLOSED_INTERVAL</a> : thm
<a name="line258"></a>    val <a href="#CLOSED_INTERVAL_EQ-val">CLOSED_INTERVAL_EQ</a> : thm
<a name="line259"></a>    val <a href="#CLOSED_INTERVAL_IMAGE_UNIT_INTERVAL-val">CLOSED_INTERVAL_IMAGE_UNIT_INTERVAL</a> : thm
<a name="line260"></a>    val <a href="#CLOSED_INTERVAL_LEFT-val">CLOSED_INTERVAL_LEFT</a> : thm
<a name="line261"></a>    val <a href="#CLOSED_INTERVAL_RIGHT-val">CLOSED_INTERVAL_RIGHT</a> : thm
<a name="line262"></a>    val <a href="#CLOSED_INTER_COMPACT-val">CLOSED_INTER_COMPACT</a> : thm
<a name="line263"></a>    val <a href="#CLOSED_IN_CLOSED-val">CLOSED_IN_CLOSED</a> : thm
<a name="line264"></a>    val <a href="#CLOSED_IN_CLOSED_EQ-val">CLOSED_IN_CLOSED_EQ</a> : thm
<a name="line265"></a>    val <a href="#CLOSED_IN_CLOSED_INTER-val">CLOSED_IN_CLOSED_INTER</a> : thm
<a name="line266"></a>    val <a href="#CLOSED_IN_CLOSED_TRANS-val">CLOSED_IN_CLOSED_TRANS</a> : thm
<a name="line267"></a>    val <a href="#CLOSED_IN_COMPACT-val">CLOSED_IN_COMPACT</a> : thm
<a name="line268"></a>    val <a href="#CLOSED_IN_COMPACT_EQ-val">CLOSED_IN_COMPACT_EQ</a> : thm
<a name="line269"></a>    val <a href="#CLOSED_IN_COMPONENT-val">CLOSED_IN_COMPONENT</a> : thm
<a name="line270"></a>    val <a href="#CLOSED_IN_CONNECTED_COMPONENT-val">CLOSED_IN_CONNECTED_COMPONENT</a> : thm
<a name="line271"></a>    val <a href="#CLOSED_IN_INTER_CLOSED-val">CLOSED_IN_INTER_CLOSED</a> : thm
<a name="line272"></a>    val <a href="#CLOSED_IN_INTER_CLOSURE-val">CLOSED_IN_INTER_CLOSURE</a> : thm
<a name="line273"></a>    val <a href="#CLOSED_IN_LIMPT-val">CLOSED_IN_LIMPT</a> : thm
<a name="line274"></a>    val <a href="#CLOSED_IN_REFL-val">CLOSED_IN_REFL</a> : thm
<a name="line275"></a>    val <a href="#CLOSED_IN_SING-val">CLOSED_IN_SING</a> : thm
<a name="line276"></a>    val <a href="#CLOSED_IN_SUBSET_TRANS-val">CLOSED_IN_SUBSET_TRANS</a> : thm
<a name="line277"></a>    val <a href="#CLOSED_IN_TRANS-val">CLOSED_IN_TRANS</a> : thm
<a name="line278"></a>    val <a href="#CLOSED_IN_TRANS_EQ-val">CLOSED_IN_TRANS_EQ</a> : thm
<a name="line279"></a>    val <a href="#CLOSED_LIMPT-val">CLOSED_LIMPT</a> : thm
<a name="line280"></a>    val <a href="#CLOSED_LIMPTS-val">CLOSED_LIMPTS</a> : thm
<a name="line281"></a>    val <a href="#CLOSED_MAP_CLOSURES-val">CLOSED_MAP_CLOSURES</a> : thm
<a name="line282"></a>    val <a href="#CLOSED_MAP_FROM_COMPOSITION_INJECTIVE-val">CLOSED_MAP_FROM_COMPOSITION_INJECTIVE</a> : thm
<a name="line283"></a>    val <a href="#CLOSED_MAP_FROM_COMPOSITION_SURJECTIVE-val">CLOSED_MAP_FROM_COMPOSITION_SURJECTIVE</a> : thm
<a name="line284"></a>    val <a href="#CLOSED_MAP_IFF_UPPER_HEMICONTINUOUS_PREIMAGE-val">CLOSED_MAP_IFF_UPPER_HEMICONTINUOUS_PREIMAGE</a> : thm
<a name="line285"></a>    val <a href="#CLOSED_MAP_IMP_OPEN_MAP-val">CLOSED_MAP_IMP_OPEN_MAP</a> : thm
<a name="line286"></a>    val <a href="#CLOSED_MAP_IMP_QUOTIENT_MAP-val">CLOSED_MAP_IMP_QUOTIENT_MAP</a> : thm
<a name="line287"></a>    val <a href="#CLOSED_MAP_OPEN_SUPERSET_PREIMAGE-val">CLOSED_MAP_OPEN_SUPERSET_PREIMAGE</a> : thm
<a name="line288"></a>    val <a href="#CLOSED_MAP_OPEN_SUPERSET_PREIMAGE_EQ-val">CLOSED_MAP_OPEN_SUPERSET_PREIMAGE_EQ</a> : thm
<a name="line289"></a>    val <a href="#CLOSED_MAP_OPEN_SUPERSET_PREIMAGE_POINT-val">CLOSED_MAP_OPEN_SUPERSET_PREIMAGE_POINT</a> : thm
<a name="line290"></a>    val <a href="#CLOSED_MAP_RESTRICT-val">CLOSED_MAP_RESTRICT</a> : thm
<a name="line291"></a>    val <a href="#CLOSED_NEGATIONS-val">CLOSED_NEGATIONS</a> : thm
<a name="line292"></a>    val <a href="#CLOSED_OPEN_INTERVAL-val">CLOSED_OPEN_INTERVAL</a> : thm
<a name="line293"></a>    val <a href="#CLOSED_POSITIVE_ORTHANT-val">CLOSED_POSITIVE_ORTHANT</a> : thm
<a name="line294"></a>    val <a href="#CLOSED_SCALING-val">CLOSED_SCALING</a> : thm
<a name="line295"></a>    val <a href="#CLOSED_SEGMENT_LINEAR_IMAGE-val">CLOSED_SEGMENT_LINEAR_IMAGE</a> : thm
<a name="line296"></a>    val <a href="#CLOSED_SEQUENTIAL_LIMITS-val">CLOSED_SEQUENTIAL_LIMITS</a> : thm
<a name="line297"></a>    val <a href="#CLOSED_SING-val">CLOSED_SING</a> : thm
<a name="line298"></a>    val <a href="#CLOSED_SPHERE-val">CLOSED_SPHERE</a> : thm
<a name="line299"></a>    val <a href="#CLOSED_STANDARD_HYPERPLANE-val">CLOSED_STANDARD_HYPERPLANE</a> : thm
<a name="line300"></a>    val <a href="#CLOSED_SUBSET-val">CLOSED_SUBSET</a> : thm
<a name="line301"></a>    val <a href="#CLOSED_SUBSET_EQ-val">CLOSED_SUBSET_EQ</a> : thm
<a name="line302"></a>    val <a href="#CLOSED_SUBSTANDARD-val">CLOSED_SUBSTANDARD</a> : thm
<a name="line303"></a>    val <a href="#CLOSED_UNION-val">CLOSED_UNION</a> : thm
<a name="line304"></a>    val <a href="#CLOSED_UNION_COMPACT_SUBSETS-val">CLOSED_UNION_COMPACT_SUBSETS</a> : thm
<a name="line305"></a>    val <a href="#CLOSED_UNIV-val">CLOSED_UNIV</a> : thm
<a name="line306"></a>    val <a href="#CLOSEST_POINT_EXISTS-val">CLOSEST_POINT_EXISTS</a> : thm
<a name="line307"></a>    val <a href="#CLOSEST_POINT_IN_FRONTIER-val">CLOSEST_POINT_IN_FRONTIER</a> : thm
<a name="line308"></a>    val <a href="#CLOSEST_POINT_IN_INTERIOR-val">CLOSEST_POINT_IN_INTERIOR</a> : thm
<a name="line309"></a>    val <a href="#CLOSEST_POINT_IN_SET-val">CLOSEST_POINT_IN_SET</a> : thm
<a name="line310"></a>    val <a href="#CLOSEST_POINT_LE-val">CLOSEST_POINT_LE</a> : thm
<a name="line311"></a>    val <a href="#CLOSEST_POINT_REFL-val">CLOSEST_POINT_REFL</a> : thm
<a name="line312"></a>    val <a href="#CLOSEST_POINT_SELF-val">CLOSEST_POINT_SELF</a> : thm
<a name="line313"></a>    val <a href="#CLOSURE_APPROACHABLE-val">CLOSURE_APPROACHABLE</a> : thm
<a name="line314"></a>    val <a href="#CLOSURE_BALL-val">CLOSURE_BALL</a> : thm
<a name="line315"></a>    val <a href="#CLOSURE_BIGINTER_SUBSET-val">CLOSURE_BIGINTER_SUBSET</a> : thm
<a name="line316"></a>    val <a href="#CLOSURE_BIGUNION-val">CLOSURE_BIGUNION</a> : thm
<a name="line317"></a>    val <a href="#CLOSURE_BOUNDED_LINEAR_IMAGE-val">CLOSURE_BOUNDED_LINEAR_IMAGE</a> : thm
<a name="line318"></a>    val <a href="#CLOSURE_CLOSED-val">CLOSURE_CLOSED</a> : thm
<a name="line319"></a>    val <a href="#CLOSURE_CLOSURE-val">CLOSURE_CLOSURE</a> : thm
<a name="line320"></a>    val <a href="#CLOSURE_COMPLEMENT-val">CLOSURE_COMPLEMENT</a> : thm
<a name="line321"></a>    val <a href="#CLOSURE_EMPTY-val">CLOSURE_EMPTY</a> : thm
<a name="line322"></a>    val <a href="#CLOSURE_EQ-val">CLOSURE_EQ</a> : thm
<a name="line323"></a>    val <a href="#CLOSURE_EQ_EMPTY-val">CLOSURE_EQ_EMPTY</a> : thm
<a name="line324"></a>    val <a href="#CLOSURE_HALFSPACE_COMPONENT_GT-val">CLOSURE_HALFSPACE_COMPONENT_GT</a> : thm
<a name="line325"></a>    val <a href="#CLOSURE_HALFSPACE_COMPONENT_LT-val">CLOSURE_HALFSPACE_COMPONENT_LT</a> : thm
<a name="line326"></a>    val <a href="#CLOSURE_HALFSPACE_GT-val">CLOSURE_HALFSPACE_GT</a> : thm
<a name="line327"></a>    val <a href="#CLOSURE_HALFSPACE_LT-val">CLOSURE_HALFSPACE_LT</a> : thm
<a name="line328"></a>    val <a href="#CLOSURE_HULL-val">CLOSURE_HULL</a> : thm
<a name="line329"></a>    val <a href="#CLOSURE_HYPERPLANE-val">CLOSURE_HYPERPLANE</a> : thm
<a name="line330"></a>    val <a href="#CLOSURE_IMAGE_BOUNDED-val">CLOSURE_IMAGE_BOUNDED</a> : thm
<a name="line331"></a>    val <a href="#CLOSURE_IMAGE_CLOSURE-val">CLOSURE_IMAGE_CLOSURE</a> : thm
<a name="line332"></a>    val <a href="#CLOSURE_INJECTIVE_LINEAR_IMAGE-val">CLOSURE_INJECTIVE_LINEAR_IMAGE</a> : thm
<a name="line333"></a>    val <a href="#CLOSURE_INTERIOR-val">CLOSURE_INTERIOR</a> : thm
<a name="line334"></a>    val <a href="#CLOSURE_INTERIOR_IDEMP-val">CLOSURE_INTERIOR_IDEMP</a> : thm
<a name="line335"></a>    val <a href="#CLOSURE_INTERIOR_UNION_CLOSED-val">CLOSURE_INTERIOR_UNION_CLOSED</a> : thm
<a name="line336"></a>    val <a href="#CLOSURE_INTERVAL-val">CLOSURE_INTERVAL</a> : thm
<a name="line337"></a>    val <a href="#CLOSURE_INTER_SUBSET-val">CLOSURE_INTER_SUBSET</a> : thm
<a name="line338"></a>    val <a href="#CLOSURE_LINEAR_IMAGE_SUBSET-val">CLOSURE_LINEAR_IMAGE_SUBSET</a> : thm
<a name="line339"></a>    val <a href="#CLOSURE_MINIMAL-val">CLOSURE_MINIMAL</a> : thm
<a name="line340"></a>    val <a href="#CLOSURE_MINIMAL_EQ-val">CLOSURE_MINIMAL_EQ</a> : thm
<a name="line341"></a>    val <a href="#CLOSURE_NEGATIONS-val">CLOSURE_NEGATIONS</a> : thm
<a name="line342"></a>    val <a href="#CLOSURE_NONEMPTY_OPEN_INTER-val">CLOSURE_NONEMPTY_OPEN_INTER</a> : thm
<a name="line343"></a>    val <a href="#CLOSURE_OPEN_INTERVAL-val">CLOSURE_OPEN_INTERVAL</a> : thm
<a name="line344"></a>    val <a href="#CLOSURE_OPEN_INTER_CLOSURE-val">CLOSURE_OPEN_INTER_CLOSURE</a> : thm
<a name="line345"></a>    val <a href="#CLOSURE_OPEN_INTER_SUPERSET-val">CLOSURE_OPEN_INTER_SUPERSET</a> : thm
<a name="line346"></a>    val <a href="#CLOSURE_OPEN_IN_INTER_CLOSURE-val">CLOSURE_OPEN_IN_INTER_CLOSURE</a> : thm
<a name="line347"></a>    val <a href="#CLOSURE_SEQUENTIAL-val">CLOSURE_SEQUENTIAL</a> : thm
<a name="line348"></a>    val <a href="#CLOSURE_SING-val">CLOSURE_SING</a> : thm
<a name="line349"></a>    val <a href="#CLOSURE_SUBSET-val">CLOSURE_SUBSET</a> : thm
<a name="line350"></a>    val <a href="#CLOSURE_SUBSET_EQ-val">CLOSURE_SUBSET_EQ</a> : thm
<a name="line351"></a>    val <a href="#CLOSURE_SUMS-val">CLOSURE_SUMS</a> : thm
<a name="line352"></a>    val <a href="#CLOSURE_UNION-val">CLOSURE_UNION</a> : thm
<a name="line353"></a>    val <a href="#CLOSURE_UNION_FRONTIER-val">CLOSURE_UNION_FRONTIER</a> : thm
<a name="line354"></a>    val <a href="#CLOSURE_UNIQUE-val">CLOSURE_UNIQUE</a> : thm
<a name="line355"></a>    val <a href="#CLOSURE_UNIV-val">CLOSURE_UNIV</a> : thm
<a name="line356"></a>    val <a href="#COBOUNDED_IMP_UNBOUNDED-val">COBOUNDED_IMP_UNBOUNDED</a> : thm
<a name="line357"></a>    val <a href="#COBOUNDED_INTER_UNBOUNDED-val">COBOUNDED_INTER_UNBOUNDED</a> : thm
<a name="line358"></a>    val <a href="#COLLINEAR_1-val">COLLINEAR_1</a> : thm
<a name="line359"></a>    val <a href="#COLLINEAR_2-val">COLLINEAR_2</a> : thm
<a name="line360"></a>    val <a href="#COLLINEAR_3-val">COLLINEAR_3</a> : thm
<a name="line361"></a>    val <a href="#COLLINEAR_3_EXPAND-val">COLLINEAR_3_EXPAND</a> : thm
<a name="line362"></a>    val <a href="#COLLINEAR_3_TRANS-val">COLLINEAR_3_TRANS</a> : thm
<a name="line363"></a>    val <a href="#COLLINEAR_4_3-val">COLLINEAR_4_3</a> : thm
<a name="line364"></a>    val <a href="#COLLINEAR_BETWEEN_CASES-val">COLLINEAR_BETWEEN_CASES</a> : thm
<a name="line365"></a>    val <a href="#COLLINEAR_DIST_BETWEEN-val">COLLINEAR_DIST_BETWEEN</a> : thm
<a name="line366"></a>    val <a href="#COLLINEAR_DIST_IN_CLOSED_SEGMENT-val">COLLINEAR_DIST_IN_CLOSED_SEGMENT</a> : thm
<a name="line367"></a>    val <a href="#COLLINEAR_DIST_IN_OPEN_SEGMENT-val">COLLINEAR_DIST_IN_OPEN_SEGMENT</a> : thm
<a name="line368"></a>    val <a href="#COLLINEAR_EMPTY-val">COLLINEAR_EMPTY</a> : thm
<a name="line369"></a>    val <a href="#COLLINEAR_LEMMA-val">COLLINEAR_LEMMA</a> : thm
<a name="line370"></a>    val <a href="#COLLINEAR_LEMMA_ALT-val">COLLINEAR_LEMMA_ALT</a> : thm
<a name="line371"></a>    val <a href="#COLLINEAR_MIDPOINT-val">COLLINEAR_MIDPOINT</a> : thm
<a name="line372"></a>    val <a href="#COLLINEAR_SING-val">COLLINEAR_SING</a> : thm
<a name="line373"></a>    val <a href="#COLLINEAR_SMALL-val">COLLINEAR_SMALL</a> : thm
<a name="line374"></a>    val <a href="#COLLINEAR_SUBSET-val">COLLINEAR_SUBSET</a> : thm
<a name="line375"></a>    val <a href="#COLLINEAR_TRIPLES-val">COLLINEAR_TRIPLES</a> : thm
<a name="line376"></a>    val <a href="#COMPACT_AFFINITY-val">COMPACT_AFFINITY</a> : thm
<a name="line377"></a>    val <a href="#COMPACT_ATTAINS_INF-val">COMPACT_ATTAINS_INF</a> : thm
<a name="line378"></a>    val <a href="#COMPACT_ATTAINS_SUP-val">COMPACT_ATTAINS_SUP</a> : thm
<a name="line379"></a>    val <a href="#COMPACT_BIGINTER-val">COMPACT_BIGINTER</a> : thm
<a name="line380"></a>    val <a href="#COMPACT_BIGUNION-val">COMPACT_BIGUNION</a> : thm
<a name="line381"></a>    val <a href="#COMPACT_CBALL-val">COMPACT_CBALL</a> : thm
<a name="line382"></a>    val <a href="#COMPACT_CHAIN-val">COMPACT_CHAIN</a> : thm
<a name="line383"></a>    val <a href="#COMPACT_CLOSED_DIFFERENCES-val">COMPACT_CLOSED_DIFFERENCES</a> : thm
<a name="line384"></a>    val <a href="#COMPACT_CLOSED_SUMS-val">COMPACT_CLOSED_SUMS</a> : thm
<a name="line385"></a>    val <a href="#COMPACT_CLOSURE-val">COMPACT_CLOSURE</a> : thm
<a name="line386"></a>    val <a href="#COMPACT_COMPONENTS-val">COMPACT_COMPONENTS</a> : thm
<a name="line387"></a>    val <a href="#COMPACT_CONTINUOUS_IMAGE-val">COMPACT_CONTINUOUS_IMAGE</a> : thm
<a name="line388"></a>    val <a href="#COMPACT_CONTINUOUS_IMAGE_EQ-val">COMPACT_CONTINUOUS_IMAGE_EQ</a> : thm
<a name="line389"></a>    val <a href="#COMPACT_DIFF-val">COMPACT_DIFF</a> : thm
<a name="line390"></a>    val <a href="#COMPACT_EMPTY-val">COMPACT_EMPTY</a> : thm
<a name="line391"></a>    val <a href="#COMPACT_EQ_BOLZANO_WEIERSTRASS-val">COMPACT_EQ_BOLZANO_WEIERSTRASS</a> : thm
<a name="line392"></a>    val <a href="#COMPACT_EQ_BOUNDED_CLOSED-val">COMPACT_EQ_BOUNDED_CLOSED</a> : thm
<a name="line393"></a>    val <a href="#COMPACT_EQ_HEINE_BOREL-val">COMPACT_EQ_HEINE_BOREL</a> : thm
<a name="line394"></a>    val <a href="#COMPACT_EQ_HEINE_BOREL_SUBTOPOLOGY-val">COMPACT_EQ_HEINE_BOREL_SUBTOPOLOGY</a> : thm
<a name="line395"></a>    val <a href="#COMPACT_FIP-val">COMPACT_FIP</a> : thm
<a name="line396"></a>    val <a href="#COMPACT_FRONTIER-val">COMPACT_FRONTIER</a> : thm
<a name="line397"></a>    val <a href="#COMPACT_FRONTIER_BOUNDED-val">COMPACT_FRONTIER_BOUNDED</a> : thm
<a name="line398"></a>    val <a href="#COMPACT_IMP_BOUNDED-val">COMPACT_IMP_BOUNDED</a> : thm
<a name="line399"></a>    val <a href="#COMPACT_IMP_CLOSED-val">COMPACT_IMP_CLOSED</a> : thm
<a name="line400"></a>    val <a href="#COMPACT_IMP_COMPLETE-val">COMPACT_IMP_COMPLETE</a> : thm
<a name="line401"></a>    val <a href="#COMPACT_IMP_FIP-val">COMPACT_IMP_FIP</a> : thm
<a name="line402"></a>    val <a href="#COMPACT_IMP_HEINE_BOREL-val">COMPACT_IMP_HEINE_BOREL</a> : thm
<a name="line403"></a>    val <a href="#COMPACT_IMP_TOTALLY_BOUNDED-val">COMPACT_IMP_TOTALLY_BOUNDED</a> : thm
<a name="line404"></a>    val <a href="#COMPACT_INSERT-val">COMPACT_INSERT</a> : thm
<a name="line405"></a>    val <a href="#COMPACT_INTER-val">COMPACT_INTER</a> : thm
<a name="line406"></a>    val <a href="#COMPACT_INTERVAL-val">COMPACT_INTERVAL</a> : thm
<a name="line407"></a>    val <a href="#COMPACT_INTERVAL_EQ-val">COMPACT_INTERVAL_EQ</a> : thm
<a name="line408"></a>    val <a href="#COMPACT_INTER_CLOSED-val">COMPACT_INTER_CLOSED</a> : thm
<a name="line409"></a>    val <a href="#COMPACT_LEMMA-val">COMPACT_LEMMA</a> : thm
<a name="line410"></a>    val <a href="#COMPACT_LINEAR_IMAGE-val">COMPACT_LINEAR_IMAGE</a> : thm
<a name="line411"></a>    val <a href="#COMPACT_NEGATIONS-val">COMPACT_NEGATIONS</a> : thm
<a name="line412"></a>    val <a href="#COMPACT_NEST-val">COMPACT_NEST</a> : thm
<a name="line413"></a>    val <a href="#COMPACT_REAL_LEMMA-val">COMPACT_REAL_LEMMA</a> : thm
<a name="line414"></a>    val <a href="#COMPACT_SCALING-val">COMPACT_SCALING</a> : thm
<a name="line415"></a>    val <a href="#COMPACT_SEQUENCE_WITH_LIMIT-val">COMPACT_SEQUENCE_WITH_LIMIT</a> : thm
<a name="line416"></a>    val <a href="#COMPACT_SING-val">COMPACT_SING</a> : thm
<a name="line417"></a>    val <a href="#COMPACT_SPHERE-val">COMPACT_SPHERE</a> : thm
<a name="line418"></a>    val <a href="#COMPACT_TRANSLATION-val">COMPACT_TRANSLATION</a> : thm
<a name="line419"></a>    val <a href="#COMPACT_TRANSLATION_EQ-val">COMPACT_TRANSLATION_EQ</a> : thm
<a name="line420"></a>    val <a href="#COMPACT_UNIFORMLY_CONTINUOUS-val">COMPACT_UNIFORMLY_CONTINUOUS</a> : thm
<a name="line421"></a>    val <a href="#COMPACT_UNIFORMLY_EQUICONTINUOUS-val">COMPACT_UNIFORMLY_EQUICONTINUOUS</a> : thm
<a name="line422"></a>    val <a href="#COMPACT_UNION-val">COMPACT_UNION</a> : thm
<a name="line423"></a>    val <a href="#COMPLEMENT_CONNECTED_COMPONENT_BIGUNION-val">COMPLEMENT_CONNECTED_COMPONENT_BIGUNION</a> : thm
<a name="line424"></a>    val <a href="#COMPLETE_EQ_CLOSED-val">COMPLETE_EQ_CLOSED</a> : thm
<a name="line425"></a>    val <a href="#COMPLETE_INJECTIVE_LINEAR_IMAGE-val">COMPLETE_INJECTIVE_LINEAR_IMAGE</a> : thm
<a name="line426"></a>    val <a href="#COMPLETE_INJECTIVE_LINEAR_IMAGE_EQ-val">COMPLETE_INJECTIVE_LINEAR_IMAGE_EQ</a> : thm
<a name="line427"></a>    val <a href="#COMPLETE_ISOMETRIC_IMAGE-val">COMPLETE_ISOMETRIC_IMAGE</a> : thm
<a name="line428"></a>    val <a href="#COMPLETE_UNIV-val">COMPLETE_UNIV</a> : thm
<a name="line429"></a>    val <a href="#COMPONENTS_EMPTY-val">COMPONENTS_EMPTY</a> : thm
<a name="line430"></a>    val <a href="#COMPONENTS_EQ-val">COMPONENTS_EQ</a> : thm
<a name="line431"></a>    val <a href="#COMPONENTS_EQ_EMPTY-val">COMPONENTS_EQ_EMPTY</a> : thm
<a name="line432"></a>    val <a href="#COMPONENTS_EQ_SING-val">COMPONENTS_EQ_SING</a> : thm
<a name="line433"></a>    val <a href="#COMPONENTS_EQ_SING_EXISTS-val">COMPONENTS_EQ_SING_EXISTS</a> : thm
<a name="line434"></a>    val <a href="#COMPONENTS_EQ_SING_N_EXISTS-val">COMPONENTS_EQ_SING_N_EXISTS</a> : thm
<a name="line435"></a>    val <a href="#COMPONENTS_INTERMEDIATE_SUBSET-val">COMPONENTS_INTERMEDIATE_SUBSET</a> : thm
<a name="line436"></a>    val <a href="#COMPONENTS_MAXIMAL-val">COMPONENTS_MAXIMAL</a> : thm
<a name="line437"></a>    val <a href="#COMPONENTS_NONOVERLAP-val">COMPONENTS_NONOVERLAP</a> : thm
<a name="line438"></a>    val <a href="#COMPONENTS_UNIQUE-val">COMPONENTS_UNIQUE</a> : thm
<a name="line439"></a>    val <a href="#COMPONENTS_UNIQUE_EQ-val">COMPONENTS_UNIQUE_EQ</a> : thm
<a name="line440"></a>    val <a href="#COMPONENTS_UNIV-val">COMPONENTS_UNIV</a> : thm
<a name="line441"></a>    val <a href="#CONDENSATION_POINT_IMP_LIMPT-val">CONDENSATION_POINT_IMP_LIMPT</a> : thm
<a name="line442"></a>    val <a href="#CONDENSATION_POINT_INFINITE_BALL-val">CONDENSATION_POINT_INFINITE_BALL</a> : thm
<a name="line443"></a>    val <a href="#CONDENSATION_POINT_INFINITE_BALL_CBALL-val">CONDENSATION_POINT_INFINITE_BALL_CBALL</a> : thm
<a name="line444"></a>    val <a href="#CONDENSATION_POINT_INFINITE_CBALL-val">CONDENSATION_POINT_INFINITE_CBALL</a> : thm
<a name="line445"></a>    val <a href="#CONDENSATION_POINT_OF_SUBSET-val">CONDENSATION_POINT_OF_SUBSET</a> : thm
<a name="line446"></a>    val <a href="#CONNECTED_BIGUNION-val">CONNECTED_BIGUNION</a> : thm
<a name="line447"></a>    val <a href="#CONNECTED_CHAIN-val">CONNECTED_CHAIN</a> : thm
<a name="line448"></a>    val <a href="#CONNECTED_CHAIN_GEN-val">CONNECTED_CHAIN_GEN</a> : thm
<a name="line449"></a>    val <a href="#CONNECTED_CLOPEN-val">CONNECTED_CLOPEN</a> : thm
<a name="line450"></a>    val <a href="#CONNECTED_CLOSED-val">CONNECTED_CLOSED</a> : thm
<a name="line451"></a>    val <a href="#CONNECTED_CLOSED_IN-val">CONNECTED_CLOSED_IN</a> : thm
<a name="line452"></a>    val <a href="#CONNECTED_CLOSED_IN_EQ-val">CONNECTED_CLOSED_IN_EQ</a> : thm
<a name="line453"></a>    val <a href="#CONNECTED_CLOSED_MONOTONE_PREIMAGE-val">CONNECTED_CLOSED_MONOTONE_PREIMAGE</a> : thm
<a name="line454"></a>    val <a href="#CONNECTED_CLOSED_SET-val">CONNECTED_CLOSED_SET</a> : thm
<a name="line455"></a>    val <a href="#CONNECTED_CLOSURE-val">CONNECTED_CLOSURE</a> : thm
<a name="line456"></a>    val <a href="#CONNECTED_COMPONENT_BIGUNION-val">CONNECTED_COMPONENT_BIGUNION</a> : thm
<a name="line457"></a>    val <a href="#CONNECTED_COMPONENT_DISJOINT-val">CONNECTED_COMPONENT_DISJOINT</a> : thm
<a name="line458"></a>    val <a href="#CONNECTED_COMPONENT_EMPTY-val">CONNECTED_COMPONENT_EMPTY</a> : thm
<a name="line459"></a>    val <a href="#CONNECTED_COMPONENT_EQ-val">CONNECTED_COMPONENT_EQ</a> : thm
<a name="line460"></a>    val <a href="#CONNECTED_COMPONENT_EQUIVALENCE_RELATION-val">CONNECTED_COMPONENT_EQUIVALENCE_RELATION</a> : thm
<a name="line461"></a>    val <a href="#CONNECTED_COMPONENT_EQ_EMPTY-val">CONNECTED_COMPONENT_EQ_EMPTY</a> : thm
<a name="line462"></a>    val <a href="#CONNECTED_COMPONENT_EQ_EQ-val">CONNECTED_COMPONENT_EQ_EQ</a> : thm
<a name="line463"></a>    val <a href="#CONNECTED_COMPONENT_EQ_SELF-val">CONNECTED_COMPONENT_EQ_SELF</a> : thm
<a name="line464"></a>    val <a href="#CONNECTED_COMPONENT_EQ_UNIV-val">CONNECTED_COMPONENT_EQ_UNIV</a> : thm
<a name="line465"></a>    val <a href="#CONNECTED_COMPONENT_IDEMP-val">CONNECTED_COMPONENT_IDEMP</a> : thm
<a name="line466"></a>    val <a href="#CONNECTED_COMPONENT_IN-val">CONNECTED_COMPONENT_IN</a> : thm
<a name="line467"></a>    val <a href="#CONNECTED_COMPONENT_INTERMEDIATE_SUBSET-val">CONNECTED_COMPONENT_INTERMEDIATE_SUBSET</a> : thm
<a name="line468"></a>    val <a href="#CONNECTED_COMPONENT_MAXIMAL-val">CONNECTED_COMPONENT_MAXIMAL</a> : thm
<a name="line469"></a>    val <a href="#CONNECTED_COMPONENT_MONO-val">CONNECTED_COMPONENT_MONO</a> : thm
<a name="line470"></a>    val <a href="#CONNECTED_COMPONENT_NONOVERLAP-val">CONNECTED_COMPONENT_NONOVERLAP</a> : thm
<a name="line471"></a>    val <a href="#CONNECTED_COMPONENT_OF_SUBSET-val">CONNECTED_COMPONENT_OF_SUBSET</a> : thm
<a name="line472"></a>    val <a href="#CONNECTED_COMPONENT_OVERLAP-val">CONNECTED_COMPONENT_OVERLAP</a> : thm
<a name="line473"></a>    val <a href="#CONNECTED_COMPONENT_REFL-val">CONNECTED_COMPONENT_REFL</a> : thm
<a name="line474"></a>    val <a href="#CONNECTED_COMPONENT_REFL_EQ-val">CONNECTED_COMPONENT_REFL_EQ</a> : thm
<a name="line475"></a>    val <a href="#CONNECTED_COMPONENT_SET-val">CONNECTED_COMPONENT_SET</a> : thm
<a name="line476"></a>    val <a href="#CONNECTED_COMPONENT_SUBSET-val">CONNECTED_COMPONENT_SUBSET</a> : thm
<a name="line477"></a>    val <a href="#CONNECTED_COMPONENT_SYM-val">CONNECTED_COMPONENT_SYM</a> : thm
<a name="line478"></a>    val <a href="#CONNECTED_COMPONENT_SYM_EQ-val">CONNECTED_COMPONENT_SYM_EQ</a> : thm
<a name="line479"></a>    val <a href="#CONNECTED_COMPONENT_TRANS-val">CONNECTED_COMPONENT_TRANS</a> : thm
<a name="line480"></a>    val <a href="#CONNECTED_COMPONENT_UNIQUE-val">CONNECTED_COMPONENT_UNIQUE</a> : thm
<a name="line481"></a>    val <a href="#CONNECTED_COMPONENT_UNIV-val">CONNECTED_COMPONENT_UNIV</a> : thm
<a name="line482"></a>    val <a href="#CONNECTED_CONNECTED_COMPONENT-val">CONNECTED_CONNECTED_COMPONENT</a> : thm
<a name="line483"></a>    val <a href="#CONNECTED_CONNECTED_COMPONENT_SET-val">CONNECTED_CONNECTED_COMPONENT_SET</a> : thm
<a name="line484"></a>    val <a href="#CONNECTED_CONTINUOUS_IMAGE-val">CONNECTED_CONTINUOUS_IMAGE</a> : thm
<a name="line485"></a>    val <a href="#CONNECTED_DIFF_OPEN_FROM_CLOSED-val">CONNECTED_DIFF_OPEN_FROM_CLOSED</a> : thm
<a name="line486"></a>    val <a href="#CONNECTED_DISJOINT_BIGUNION_OPEN_UNIQUE-val">CONNECTED_DISJOINT_BIGUNION_OPEN_UNIQUE</a> : thm
<a name="line487"></a>    val <a href="#CONNECTED_EMPTY-val">CONNECTED_EMPTY</a> : thm
<a name="line488"></a>    val <a href="#CONNECTED_EQUIVALENCE_RELATION-val">CONNECTED_EQUIVALENCE_RELATION</a> : thm
<a name="line489"></a>    val <a href="#CONNECTED_EQUIVALENCE_RELATION_GEN-val">CONNECTED_EQUIVALENCE_RELATION_GEN</a> : thm
<a name="line490"></a>    val <a href="#CONNECTED_EQ_COMPONENTS_SUBSET_SING-val">CONNECTED_EQ_COMPONENTS_SUBSET_SING</a> : thm
<a name="line491"></a>    val <a href="#CONNECTED_EQ_COMPONENTS_SUBSET_SING_EXISTS-val">CONNECTED_EQ_COMPONENTS_SUBSET_SING_EXISTS</a> : thm
<a name="line492"></a>    val <a href="#CONNECTED_EQ_CONNECTED_COMPONENTS_EQ-val">CONNECTED_EQ_CONNECTED_COMPONENTS_EQ</a> : thm
<a name="line493"></a>    val <a href="#CONNECTED_EQ_CONNECTED_COMPONENT_EQ-val">CONNECTED_EQ_CONNECTED_COMPONENT_EQ</a> : thm
<a name="line494"></a>    val <a href="#CONNECTED_FROM_CLOSED_UNION_AND_INTER-val">CONNECTED_FROM_CLOSED_UNION_AND_INTER</a> : thm
<a name="line495"></a>    val <a href="#CONNECTED_FROM_OPEN_UNION_AND_INTER-val">CONNECTED_FROM_OPEN_UNION_AND_INTER</a> : thm
<a name="line496"></a>    val <a href="#CONNECTED_IFF_CONNECTABLE_POINTS-val">CONNECTED_IFF_CONNECTABLE_POINTS</a> : thm
<a name="line497"></a>    val <a href="#CONNECTED_IFF_CONNECTED_COMPONENT-val">CONNECTED_IFF_CONNECTED_COMPONENT</a> : thm
<a name="line498"></a>    val <a href="#CONNECTED_IMP_PERFECT-val">CONNECTED_IMP_PERFECT</a> : thm
<a name="line499"></a>    val <a href="#CONNECTED_IMP_PERFECT_CLOSED-val">CONNECTED_IMP_PERFECT_CLOSED</a> : thm
<a name="line500"></a>    val <a href="#CONNECTED_INDUCTION-val">CONNECTED_INDUCTION</a> : thm
<a name="line501"></a>    val <a href="#CONNECTED_INDUCTION_SIMPLE-val">CONNECTED_INDUCTION_SIMPLE</a> : thm
<a name="line502"></a>    val <a href="#CONNECTED_INTERMEDIATE_CLOSURE-val">CONNECTED_INTERMEDIATE_CLOSURE</a> : thm
<a name="line503"></a>    val <a href="#CONNECTED_INTER_FRONTIER-val">CONNECTED_INTER_FRONTIER</a> : thm
<a name="line504"></a>    val <a href="#CONNECTED_IVT_COMPONENT-val">CONNECTED_IVT_COMPONENT</a> : thm
<a name="line505"></a>    val <a href="#CONNECTED_IVT_HYPERPLANE-val">CONNECTED_IVT_HYPERPLANE</a> : thm
<a name="line506"></a>    val <a href="#CONNECTED_LINEAR_IMAGE-val">CONNECTED_LINEAR_IMAGE</a> : thm
<a name="line507"></a>    val <a href="#CONNECTED_MONOTONE_QUOTIENT_PREIMAGE-val">CONNECTED_MONOTONE_QUOTIENT_PREIMAGE</a> : thm
<a name="line508"></a>    val <a href="#CONNECTED_MONOTONE_QUOTIENT_PREIMAGE_GEN-val">CONNECTED_MONOTONE_QUOTIENT_PREIMAGE_GEN</a> : thm
<a name="line509"></a>    val <a href="#CONNECTED_NEGATIONS-val">CONNECTED_NEGATIONS</a> : thm
<a name="line510"></a>    val <a href="#CONNECTED_NEST-val">CONNECTED_NEST</a> : thm
<a name="line511"></a>    val <a href="#CONNECTED_NEST_GEN-val">CONNECTED_NEST_GEN</a> : thm
<a name="line512"></a>    val <a href="#CONNECTED_OPEN_IN-val">CONNECTED_OPEN_IN</a> : thm
<a name="line513"></a>    val <a href="#CONNECTED_OPEN_IN_EQ-val">CONNECTED_OPEN_IN_EQ</a> : thm
<a name="line514"></a>    val <a href="#CONNECTED_OPEN_MONOTONE_PREIMAGE-val">CONNECTED_OPEN_MONOTONE_PREIMAGE</a> : thm
<a name="line515"></a>    val <a href="#CONNECTED_OPEN_SET-val">CONNECTED_OPEN_SET</a> : thm
<a name="line516"></a>    val <a href="#CONNECTED_REAL_LEMMA-val">CONNECTED_REAL_LEMMA</a> : thm
<a name="line517"></a>    val <a href="#CONNECTED_SCALING-val">CONNECTED_SCALING</a> : thm
<a name="line518"></a>    val <a href="#CONNECTED_SEGMENT-val">CONNECTED_SEGMENT</a> : thm
<a name="line519"></a>    val <a href="#CONNECTED_SING-val">CONNECTED_SING</a> : thm
<a name="line520"></a>    val <a href="#CONNECTED_SUBSET_CLOPEN-val">CONNECTED_SUBSET_CLOPEN</a> : thm
<a name="line521"></a>    val <a href="#CONNECTED_TRANSLATION-val">CONNECTED_TRANSLATION</a> : thm
<a name="line522"></a>    val <a href="#CONNECTED_TRANSLATION_EQ-val">CONNECTED_TRANSLATION_EQ</a> : thm
<a name="line523"></a>    val <a href="#CONNECTED_UNION-val">CONNECTED_UNION</a> : thm
<a name="line524"></a>    val <a href="#CONNECTED_UNION_STRONG-val">CONNECTED_UNION_STRONG</a> : thm
<a name="line525"></a>    val <a href="#CONNECTED_UNIV-val">CONNECTED_UNIV</a> : thm
<a name="line526"></a>    val <a href="#CONTENT_0_SUBSET-val">CONTENT_0_SUBSET</a> : thm
<a name="line527"></a>    val <a href="#CONTENT_0_SUBSET_GEN-val">CONTENT_0_SUBSET_GEN</a> : thm
<a name="line528"></a>    val <a href="#CONTENT_CLOSED_INTERVAL-val">CONTENT_CLOSED_INTERVAL</a> : thm
<a name="line529"></a>    val <a href="#CONTENT_CLOSED_INTERVAL_CASES-val">CONTENT_CLOSED_INTERVAL_CASES</a> : thm
<a name="line530"></a>    val <a href="#CONTENT_EMPTY-val">CONTENT_EMPTY</a> : thm
<a name="line531"></a>    val <a href="#CONTENT_EQ_0-val">CONTENT_EQ_0</a> : thm
<a name="line532"></a>    val <a href="#CONTENT_EQ_0_1-val">CONTENT_EQ_0_1</a> : thm
<a name="line533"></a>    val <a href="#CONTENT_EQ_0_GEN-val">CONTENT_EQ_0_GEN</a> : thm
<a name="line534"></a>    val <a href="#CONTENT_EQ_0_INTERIOR-val">CONTENT_EQ_0_INTERIOR</a> : thm
<a name="line535"></a>    val <a href="#CONTENT_LT_NZ-val">CONTENT_LT_NZ</a> : thm
<a name="line536"></a>    val <a href="#CONTENT_POS_LE-val">CONTENT_POS_LE</a> : thm
<a name="line537"></a>    val <a href="#CONTENT_POS_LT-val">CONTENT_POS_LT</a> : thm
<a name="line538"></a>    val <a href="#CONTENT_POS_LT_EQ-val">CONTENT_POS_LT_EQ</a> : thm
<a name="line539"></a>    val <a href="#CONTENT_SUBSET-val">CONTENT_SUBSET</a> : thm
<a name="line540"></a>    val <a href="#CONTENT_UNIT-val">CONTENT_UNIT</a> : thm
<a name="line541"></a>    val <a href="#CONTINUOUS_ABS-val">CONTINUOUS_ABS</a> : thm
<a name="line542"></a>    val <a href="#CONTINUOUS_ABS_COMPOSE-val">CONTINUOUS_ABS_COMPOSE</a> : thm
<a name="line543"></a>    val <a href="#CONTINUOUS_ADD-val">CONTINUOUS_ADD</a> : thm
<a name="line544"></a>    val <a href="#CONTINUOUS_AGREE_ON_CLOSURE-val">CONTINUOUS_AGREE_ON_CLOSURE</a> : thm
<a name="line545"></a>    val <a href="#CONTINUOUS_AT-val">CONTINUOUS_AT</a> : thm
<a name="line546"></a>    val <a href="#CONTINUOUS_ATTAINS_INF-val">CONTINUOUS_ATTAINS_INF</a> : thm
<a name="line547"></a>    val <a href="#CONTINUOUS_ATTAINS_SUP-val">CONTINUOUS_ATTAINS_SUP</a> : thm
<a name="line548"></a>    val <a href="#CONTINUOUS_AT_ABS-val">CONTINUOUS_AT_ABS</a> : thm
<a name="line549"></a>    val <a href="#CONTINUOUS_AT_AVOID-val">CONTINUOUS_AT_AVOID</a> : thm
<a name="line550"></a>    val <a href="#CONTINUOUS_AT_BALL-val">CONTINUOUS_AT_BALL</a> : thm
<a name="line551"></a>    val <a href="#CONTINUOUS_AT_COMPOSE-val">CONTINUOUS_AT_COMPOSE</a> : thm
<a name="line552"></a>    val <a href="#CONTINUOUS_AT_COMPOSE_EQ-val">CONTINUOUS_AT_COMPOSE_EQ</a> : thm
<a name="line553"></a>    val <a href="#CONTINUOUS_AT_DIST-val">CONTINUOUS_AT_DIST</a> : thm
<a name="line554"></a>    val <a href="#CONTINUOUS_AT_DIST_CLOSEST_POINT-val">CONTINUOUS_AT_DIST_CLOSEST_POINT</a> : thm
<a name="line555"></a>    val <a href="#CONTINUOUS_AT_ID-val">CONTINUOUS_AT_ID</a> : thm
<a name="line556"></a>    val <a href="#CONTINUOUS_AT_IMP_CONTINUOUS_ON-val">CONTINUOUS_AT_IMP_CONTINUOUS_ON</a> : thm
<a name="line557"></a>    val <a href="#CONTINUOUS_AT_INV-val">CONTINUOUS_AT_INV</a> : thm
<a name="line558"></a>    val <a href="#CONTINUOUS_AT_LIFT_DOT-val">CONTINUOUS_AT_LIFT_DOT</a> : thm
<a name="line559"></a>    val <a href="#CONTINUOUS_AT_OPEN-val">CONTINUOUS_AT_OPEN</a> : thm
<a name="line560"></a>    val <a href="#CONTINUOUS_AT_RANGE-val">CONTINUOUS_AT_RANGE</a> : thm
<a name="line561"></a>    val <a href="#CONTINUOUS_AT_SEQUENTIALLY-val">CONTINUOUS_AT_SEQUENTIALLY</a> : thm
<a name="line562"></a>    val <a href="#CONTINUOUS_AT_SETDIST-val">CONTINUOUS_AT_SETDIST</a> : thm
<a name="line563"></a>    val <a href="#CONTINUOUS_AT_TRANSLATION-val">CONTINUOUS_AT_TRANSLATION</a> : thm
<a name="line564"></a>    val <a href="#CONTINUOUS_AT_WITHIN-val">CONTINUOUS_AT_WITHIN</a> : thm
<a name="line565"></a>    val <a href="#CONTINUOUS_AT_WITHIN_INV-val">CONTINUOUS_AT_WITHIN_INV</a> : thm
<a name="line566"></a>    val <a href="#CONTINUOUS_CLOSED_IMP_CAUCHY_CONTINUOUS-val">CONTINUOUS_CLOSED_IMP_CAUCHY_CONTINUOUS</a> : thm
<a name="line567"></a>    val <a href="#CONTINUOUS_CLOSED_IN_PREIMAGE-val">CONTINUOUS_CLOSED_IN_PREIMAGE</a> : thm
<a name="line568"></a>    val <a href="#CONTINUOUS_CLOSED_IN_PREIMAGE_CONSTANT-val">CONTINUOUS_CLOSED_IN_PREIMAGE_CONSTANT</a> : thm
<a name="line569"></a>    val <a href="#CONTINUOUS_CLOSED_IN_PREIMAGE_EQ-val">CONTINUOUS_CLOSED_IN_PREIMAGE_EQ</a> : thm
<a name="line570"></a>    val <a href="#CONTINUOUS_CLOSED_IN_PREIMAGE_GEN-val">CONTINUOUS_CLOSED_IN_PREIMAGE_GEN</a> : thm
<a name="line571"></a>    val <a href="#CONTINUOUS_CLOSED_PREIMAGE-val">CONTINUOUS_CLOSED_PREIMAGE</a> : thm
<a name="line572"></a>    val <a href="#CONTINUOUS_CLOSED_PREIMAGE_CONSTANT-val">CONTINUOUS_CLOSED_PREIMAGE_CONSTANT</a> : thm
<a name="line573"></a>    val <a href="#CONTINUOUS_CLOSED_PREIMAGE_UNIV-val">CONTINUOUS_CLOSED_PREIMAGE_UNIV</a> : thm
<a name="line574"></a>    val <a href="#CONTINUOUS_CMUL-val">CONTINUOUS_CMUL</a> : thm
<a name="line575"></a>    val <a href="#CONTINUOUS_COMPONENT_COMPOSE-val">CONTINUOUS_COMPONENT_COMPOSE</a> : thm
<a name="line576"></a>    val <a href="#CONTINUOUS_CONST-val">CONTINUOUS_CONST</a> : thm
<a name="line577"></a>    val <a href="#CONTINUOUS_CONSTANT_ON_CLOSURE-val">CONTINUOUS_CONSTANT_ON_CLOSURE</a> : thm
<a name="line578"></a>    val <a href="#CONTINUOUS_DIAMETER-val">CONTINUOUS_DIAMETER</a> : thm
<a name="line579"></a>    val <a href="#CONTINUOUS_DISCONNECTED_DISCRETE_FINITE_RANGE_CONSTANT_EQ-val">CONTINUOUS_DISCONNECTED_DISCRETE_FINITE_RANGE_CONSTANT_EQ</a> : thm
<a name="line580"></a>    val <a href="#CONTINUOUS_DISCONNECTED_RANGE_CONSTANT-val">CONTINUOUS_DISCONNECTED_RANGE_CONSTANT</a> : thm
<a name="line581"></a>    val <a href="#CONTINUOUS_DISCONNECTED_RANGE_CONSTANT_EQ-val">CONTINUOUS_DISCONNECTED_RANGE_CONSTANT_EQ</a> : thm
<a name="line582"></a>    val <a href="#CONTINUOUS_DISCRETE_RANGE_CONSTANT-val">CONTINUOUS_DISCRETE_RANGE_CONSTANT</a> : thm
<a name="line583"></a>    val <a href="#CONTINUOUS_DISCRETE_RANGE_CONSTANT_EQ-val">CONTINUOUS_DISCRETE_RANGE_CONSTANT_EQ</a> : thm
<a name="line584"></a>    val <a href="#CONTINUOUS_DOT2-val">CONTINUOUS_DOT2</a> : thm
<a name="line585"></a>    val <a href="#CONTINUOUS_FINITE_RANGE_CONSTANT-val">CONTINUOUS_FINITE_RANGE_CONSTANT</a> : thm
<a name="line586"></a>    val <a href="#CONTINUOUS_FINITE_RANGE_CONSTANT_EQ-val">CONTINUOUS_FINITE_RANGE_CONSTANT_EQ</a> : thm
<a name="line587"></a>    val <a href="#CONTINUOUS_GE_ON_CLOSURE-val">CONTINUOUS_GE_ON_CLOSURE</a> : thm
<a name="line588"></a>    val <a href="#CONTINUOUS_IMP_CLOSED_MAP-val">CONTINUOUS_IMP_CLOSED_MAP</a> : thm
<a name="line589"></a>    val <a href="#CONTINUOUS_IMP_QUOTIENT_MAP-val">CONTINUOUS_IMP_QUOTIENT_MAP</a> : thm
<a name="line590"></a>    val <a href="#CONTINUOUS_INV-val">CONTINUOUS_INV</a> : thm
<a name="line591"></a>    val <a href="#CONTINUOUS_LEFT_INVERSE_IMP_QUOTIENT_MAP-val">CONTINUOUS_LEFT_INVERSE_IMP_QUOTIENT_MAP</a> : thm
<a name="line592"></a>    val <a href="#CONTINUOUS_LEVELSET_OPEN-val">CONTINUOUS_LEVELSET_OPEN</a> : thm
<a name="line593"></a>    val <a href="#CONTINUOUS_LEVELSET_OPEN_IN-val">CONTINUOUS_LEVELSET_OPEN_IN</a> : thm
<a name="line594"></a>    val <a href="#CONTINUOUS_LEVELSET_OPEN_IN_CASES-val">CONTINUOUS_LEVELSET_OPEN_IN_CASES</a> : thm
<a name="line595"></a>    val <a href="#CONTINUOUS_LE_ON_CLOSURE-val">CONTINUOUS_LE_ON_CLOSURE</a> : thm
<a name="line596"></a>    val <a href="#CONTINUOUS_MAP_CLOSURES-val">CONTINUOUS_MAP_CLOSURES</a> : thm
<a name="line597"></a>    val <a href="#CONTINUOUS_MAX-val">CONTINUOUS_MAX</a> : thm
<a name="line598"></a>    val <a href="#CONTINUOUS_MIN-val">CONTINUOUS_MIN</a> : thm
<a name="line599"></a>    val <a href="#CONTINUOUS_MUL-val">CONTINUOUS_MUL</a> : thm
<a name="line600"></a>    val <a href="#CONTINUOUS_NEG-val">CONTINUOUS_NEG</a> : thm
<a name="line601"></a>    val <a href="#CONTINUOUS_ON-val">CONTINUOUS_ON</a> : thm
<a name="line602"></a>    val <a href="#CONTINUOUS_ON_ABS-val">CONTINUOUS_ON_ABS</a> : thm
<a name="line603"></a>    val <a href="#CONTINUOUS_ON_ABS_COMPOSE-val">CONTINUOUS_ON_ABS_COMPOSE</a> : thm
<a name="line604"></a>    val <a href="#CONTINUOUS_ON_ADD-val">CONTINUOUS_ON_ADD</a> : thm
<a name="line605"></a>    val <a href="#CONTINUOUS_ON_AVOID-val">CONTINUOUS_ON_AVOID</a> : thm
<a name="line606"></a>    val <a href="#CONTINUOUS_ON_CASES-val">CONTINUOUS_ON_CASES</a> : thm
<a name="line607"></a>    val <a href="#CONTINUOUS_ON_CASES_1-val">CONTINUOUS_ON_CASES_1</a> : thm
<a name="line608"></a>    val <a href="#CONTINUOUS_ON_CASES_LE-val">CONTINUOUS_ON_CASES_LE</a> : thm
<a name="line609"></a>    val <a href="#CONTINUOUS_ON_CASES_LOCAL-val">CONTINUOUS_ON_CASES_LOCAL</a> : thm
<a name="line610"></a>    val <a href="#CONTINUOUS_ON_CASES_LOCAL_OPEN-val">CONTINUOUS_ON_CASES_LOCAL_OPEN</a> : thm
<a name="line611"></a>    val <a href="#CONTINUOUS_ON_CASES_OPEN-val">CONTINUOUS_ON_CASES_OPEN</a> : thm
<a name="line612"></a>    val <a href="#CONTINUOUS_ON_CLOSED-val">CONTINUOUS_ON_CLOSED</a> : thm
<a name="line613"></a>    val <a href="#CONTINUOUS_ON_CLOSED_GEN-val">CONTINUOUS_ON_CLOSED_GEN</a> : thm
<a name="line614"></a>    val <a href="#CONTINUOUS_ON_CLOSURE-val">CONTINUOUS_ON_CLOSURE</a> : thm
<a name="line615"></a>    val <a href="#CONTINUOUS_ON_CLOSURE_ABS_LE-val">CONTINUOUS_ON_CLOSURE_ABS_LE</a> : thm
<a name="line616"></a>    val <a href="#CONTINUOUS_ON_CLOSURE_COMPONENT_GE-val">CONTINUOUS_ON_CLOSURE_COMPONENT_GE</a> : thm
<a name="line617"></a>    val <a href="#CONTINUOUS_ON_CLOSURE_COMPONENT_LE-val">CONTINUOUS_ON_CLOSURE_COMPONENT_LE</a> : thm
<a name="line618"></a>    val <a href="#CONTINUOUS_ON_CLOSURE_SEQUENTIALLY-val">CONTINUOUS_ON_CLOSURE_SEQUENTIALLY</a> : thm
<a name="line619"></a>    val <a href="#CONTINUOUS_ON_CMUL-val">CONTINUOUS_ON_CMUL</a> : thm
<a name="line620"></a>    val <a href="#CONTINUOUS_ON_COMPONENTS_FINITE-val">CONTINUOUS_ON_COMPONENTS_FINITE</a> : thm
<a name="line621"></a>    val <a href="#CONTINUOUS_ON_COMPONENTS_GEN-val">CONTINUOUS_ON_COMPONENTS_GEN</a> : thm
<a name="line622"></a>    val <a href="#CONTINUOUS_ON_COMPONENT_COMPOSE-val">CONTINUOUS_ON_COMPONENT_COMPOSE</a> : thm
<a name="line623"></a>    val <a href="#CONTINUOUS_ON_COMPOSE-val">CONTINUOUS_ON_COMPOSE</a> : thm
<a name="line624"></a>    val <a href="#CONTINUOUS_ON_COMPOSE_QUOTIENT-val">CONTINUOUS_ON_COMPOSE_QUOTIENT</a> : thm
<a name="line625"></a>    val <a href="#CONTINUOUS_ON_CONST-val">CONTINUOUS_ON_CONST</a> : thm
<a name="line626"></a>    val <a href="#CONTINUOUS_ON_DIST-val">CONTINUOUS_ON_DIST</a> : thm
<a name="line627"></a>    val <a href="#CONTINUOUS_ON_DIST_CLOSEST_POINT-val">CONTINUOUS_ON_DIST_CLOSEST_POINT</a> : thm
<a name="line628"></a>    val <a href="#CONTINUOUS_ON_DOT2-val">CONTINUOUS_ON_DOT2</a> : thm
<a name="line629"></a>    val <a href="#CONTINUOUS_ON_EMPTY-val">CONTINUOUS_ON_EMPTY</a> : thm
<a name="line630"></a>    val <a href="#CONTINUOUS_ON_EQ-val">CONTINUOUS_ON_EQ</a> : thm
<a name="line631"></a>    val <a href="#CONTINUOUS_ON_EQ_CONTINUOUS_AT-val">CONTINUOUS_ON_EQ_CONTINUOUS_AT</a> : thm
<a name="line632"></a>    val <a href="#CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN-val">CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN</a> : thm
<a name="line633"></a>    val <a href="#CONTINUOUS_ON_FINITE-val">CONTINUOUS_ON_FINITE</a> : thm
<a name="line634"></a>    val <a href="#CONTINUOUS_ON_ID-val">CONTINUOUS_ON_ID</a> : thm
<a name="line635"></a>    val <a href="#CONTINUOUS_ON_IMP_CLOSED_IN-val">CONTINUOUS_ON_IMP_CLOSED_IN</a> : thm
<a name="line636"></a>    val <a href="#CONTINUOUS_ON_IMP_OPEN_IN-val">CONTINUOUS_ON_IMP_OPEN_IN</a> : thm
<a name="line637"></a>    val <a href="#CONTINUOUS_ON_INTERIOR-val">CONTINUOUS_ON_INTERIOR</a> : thm
<a name="line638"></a>    val <a href="#CONTINUOUS_ON_INV-val">CONTINUOUS_ON_INV</a> : thm
<a name="line639"></a>    val <a href="#CONTINUOUS_ON_INVERSE-val">CONTINUOUS_ON_INVERSE</a> : thm
<a name="line640"></a>    val <a href="#CONTINUOUS_ON_INVERSE_CLOSED_MAP-val">CONTINUOUS_ON_INVERSE_CLOSED_MAP</a> : thm
<a name="line641"></a>    val <a href="#CONTINUOUS_ON_INVERSE_OPEN_MAP-val">CONTINUOUS_ON_INVERSE_OPEN_MAP</a> : thm
<a name="line642"></a>    val <a href="#CONTINUOUS_ON_IVT-val">CONTINUOUS_ON_IVT</a> : thm
<a name="line643"></a>    val <a href="#CONTINUOUS_ON_LIFT_DOT-val">CONTINUOUS_ON_LIFT_DOT</a> : thm
<a name="line644"></a>    val <a href="#CONTINUOUS_ON_MAX-val">CONTINUOUS_ON_MAX</a> : thm
<a name="line645"></a>    val <a href="#CONTINUOUS_ON_MIN-val">CONTINUOUS_ON_MIN</a> : thm
<a name="line646"></a>    val <a href="#CONTINUOUS_ON_MUL-val">CONTINUOUS_ON_MUL</a> : thm
<a name="line647"></a>    val <a href="#CONTINUOUS_ON_NEG-val">CONTINUOUS_ON_NEG</a> : thm
<a name="line648"></a>    val <a href="#CONTINUOUS_ON_NO_LIMPT-val">CONTINUOUS_ON_NO_LIMPT</a> : thm
<a name="line649"></a>    val <a href="#CONTINUOUS_ON_OPEN-val">CONTINUOUS_ON_OPEN</a> : thm
<a name="line650"></a>    val <a href="#CONTINUOUS_ON_OPEN_AVOID-val">CONTINUOUS_ON_OPEN_AVOID</a> : thm
<a name="line651"></a>    val <a href="#CONTINUOUS_ON_OPEN_GEN-val">CONTINUOUS_ON_OPEN_GEN</a> : thm
<a name="line652"></a>    val <a href="#CONTINUOUS_ON_POW-val">CONTINUOUS_ON_POW</a> : thm
<a name="line653"></a>    val <a href="#CONTINUOUS_ON_PRODUCT-val">CONTINUOUS_ON_PRODUCT</a> : thm
<a name="line654"></a>    val <a href="#CONTINUOUS_ON_RANGE-val">CONTINUOUS_ON_RANGE</a> : thm
<a name="line655"></a>    val <a href="#CONTINUOUS_ON_SEQUENTIALLY-val">CONTINUOUS_ON_SEQUENTIALLY</a> : thm
<a name="line656"></a>    val <a href="#CONTINUOUS_ON_SETDIST-val">CONTINUOUS_ON_SETDIST</a> : thm
<a name="line657"></a>    val <a href="#CONTINUOUS_ON_SING-val">CONTINUOUS_ON_SING</a> : thm
<a name="line658"></a>    val <a href="#CONTINUOUS_ON_SUB-val">CONTINUOUS_ON_SUB</a> : thm
<a name="line659"></a>    val <a href="#CONTINUOUS_ON_SUBSET-val">CONTINUOUS_ON_SUBSET</a> : thm
<a name="line660"></a>    val <a href="#CONTINUOUS_ON_SUM-val">CONTINUOUS_ON_SUM</a> : thm
<a name="line661"></a>    val <a href="#CONTINUOUS_ON_UNION-val">CONTINUOUS_ON_UNION</a> : thm
<a name="line662"></a>    val <a href="#CONTINUOUS_ON_UNION_LOCAL-val">CONTINUOUS_ON_UNION_LOCAL</a> : thm
<a name="line663"></a>    val <a href="#CONTINUOUS_ON_UNION_LOCAL_OPEN-val">CONTINUOUS_ON_UNION_LOCAL_OPEN</a> : thm
<a name="line664"></a>    val <a href="#CONTINUOUS_ON_UNION_OPEN-val">CONTINUOUS_ON_UNION_OPEN</a> : thm
<a name="line665"></a>    val <a href="#CONTINUOUS_ON_VMUL-val">CONTINUOUS_ON_VMUL</a> : thm
<a name="line666"></a>    val <a href="#CONTINUOUS_OPEN_IN_PREIMAGE-val">CONTINUOUS_OPEN_IN_PREIMAGE</a> : thm
<a name="line667"></a>    val <a href="#CONTINUOUS_OPEN_IN_PREIMAGE_EQ-val">CONTINUOUS_OPEN_IN_PREIMAGE_EQ</a> : thm
<a name="line668"></a>    val <a href="#CONTINUOUS_OPEN_IN_PREIMAGE_GEN-val">CONTINUOUS_OPEN_IN_PREIMAGE_GEN</a> : thm
<a name="line669"></a>    val <a href="#CONTINUOUS_OPEN_PREIMAGE-val">CONTINUOUS_OPEN_PREIMAGE</a> : thm
<a name="line670"></a>    val <a href="#CONTINUOUS_OPEN_PREIMAGE_UNIV-val">CONTINUOUS_OPEN_PREIMAGE_UNIV</a> : thm
<a name="line671"></a>    val <a href="#CONTINUOUS_POW-val">CONTINUOUS_POW</a> : thm
<a name="line672"></a>    val <a href="#CONTINUOUS_PRODUCT-val">CONTINUOUS_PRODUCT</a> : thm
<a name="line673"></a>    val <a href="#CONTINUOUS_RIGHT_INVERSE_IMP_QUOTIENT_MAP-val">CONTINUOUS_RIGHT_INVERSE_IMP_QUOTIENT_MAP</a> : thm
<a name="line674"></a>    val <a href="#CONTINUOUS_SUB-val">CONTINUOUS_SUB</a> : thm
<a name="line675"></a>    val <a href="#CONTINUOUS_SUM-val">CONTINUOUS_SUM</a> : thm
<a name="line676"></a>    val <a href="#CONTINUOUS_TRANSFORM_AT-val">CONTINUOUS_TRANSFORM_AT</a> : thm
<a name="line677"></a>    val <a href="#CONTINUOUS_TRANSFORM_WITHIN-val">CONTINUOUS_TRANSFORM_WITHIN</a> : thm
<a name="line678"></a>    val <a href="#CONTINUOUS_TRANSFORM_WITHIN_OPEN-val">CONTINUOUS_TRANSFORM_WITHIN_OPEN</a> : thm
<a name="line679"></a>    val <a href="#CONTINUOUS_TRANSFORM_WITHIN_OPEN_IN-val">CONTINUOUS_TRANSFORM_WITHIN_OPEN_IN</a> : thm
<a name="line680"></a>    val <a href="#CONTINUOUS_TRANSFORM_WITHIN_SET_IMP-val">CONTINUOUS_TRANSFORM_WITHIN_SET_IMP</a> : thm
<a name="line681"></a>    val <a href="#CONTINUOUS_TRIVIAL_LIMIT-val">CONTINUOUS_TRIVIAL_LIMIT</a> : thm
<a name="line682"></a>    val <a href="#CONTINUOUS_UNIFORM_LIMIT-val">CONTINUOUS_UNIFORM_LIMIT</a> : thm
<a name="line683"></a>    val <a href="#CONTINUOUS_VMUL-val">CONTINUOUS_VMUL</a> : thm
<a name="line684"></a>    val <a href="#CONTINUOUS_WITHIN-val">CONTINUOUS_WITHIN</a> : thm
<a name="line685"></a>    val <a href="#CONTINUOUS_WITHIN_AVOID-val">CONTINUOUS_WITHIN_AVOID</a> : thm
<a name="line686"></a>    val <a href="#CONTINUOUS_WITHIN_BALL-val">CONTINUOUS_WITHIN_BALL</a> : thm
<a name="line687"></a>    val <a href="#CONTINUOUS_WITHIN_CLOSED_NONTRIVIAL-val">CONTINUOUS_WITHIN_CLOSED_NONTRIVIAL</a> : thm
<a name="line688"></a>    val <a href="#CONTINUOUS_WITHIN_COMPARISON-val">CONTINUOUS_WITHIN_COMPARISON</a> : thm
<a name="line689"></a>    val <a href="#CONTINUOUS_WITHIN_COMPOSE-val">CONTINUOUS_WITHIN_COMPOSE</a> : thm
<a name="line690"></a>    val <a href="#CONTINUOUS_WITHIN_ID-val">CONTINUOUS_WITHIN_ID</a> : thm
<a name="line691"></a>    val <a href="#CONTINUOUS_WITHIN_OPEN-val">CONTINUOUS_WITHIN_OPEN</a> : thm
<a name="line692"></a>    val <a href="#CONTINUOUS_WITHIN_SEQUENTIALLY-val">CONTINUOUS_WITHIN_SEQUENTIALLY</a> : thm
<a name="line693"></a>    val <a href="#CONTINUOUS_WITHIN_SUBSET-val">CONTINUOUS_WITHIN_SUBSET</a> : thm
<a name="line694"></a>    val <a href="#CONTRACTION_IMP_CONTINUOUS_ON-val">CONTRACTION_IMP_CONTINUOUS_ON</a> : thm
<a name="line695"></a>    val <a href="#CONVERGENT_BOUNDED_INCREASING-val">CONVERGENT_BOUNDED_INCREASING</a> : thm
<a name="line696"></a>    val <a href="#CONVERGENT_BOUNDED_MONOTONE-val">CONVERGENT_BOUNDED_MONOTONE</a> : thm
<a name="line697"></a>    val <a href="#CONVERGENT_EQ_CAUCHY-val">CONVERGENT_EQ_CAUCHY</a> : thm
<a name="line698"></a>    val <a href="#CONVERGENT_IMP_BOUNDED-val">CONVERGENT_IMP_BOUNDED</a> : thm
<a name="line699"></a>    val <a href="#CONVERGENT_IMP_CAUCHY-val">CONVERGENT_IMP_CAUCHY</a> : thm
<a name="line700"></a>    val <a href="#COUNTABLE_OPEN_INTERVAL-val">COUNTABLE_OPEN_INTERVAL</a> : thm
<a name="line701"></a>    val <a href="#DECREASING_CLOSED_NEST-val">DECREASING_CLOSED_NEST</a> : thm
<a name="line702"></a>    val <a href="#DECREASING_CLOSED_NEST_SING-val">DECREASING_CLOSED_NEST_SING</a> : thm
<a name="line703"></a>    val <a href="#DENSE_IMP_PERFECT-val">DENSE_IMP_PERFECT</a> : thm
<a name="line704"></a>    val <a href="#DENSE_LIMIT_POINTS-val">DENSE_LIMIT_POINTS</a> : thm
<a name="line705"></a>    val <a href="#DENSE_OPEN_INTER-val">DENSE_OPEN_INTER</a> : thm
<a name="line706"></a>    val <a href="#DEPENDENT_CHOICE-val">DEPENDENT_CHOICE</a> : thm
<a name="line707"></a>    val <a href="#DEPENDENT_CHOICE_FIXED-val">DEPENDENT_CHOICE_FIXED</a> : thm
<a name="line708"></a>    val <a href="#DEPENDENT_EXPLICIT-val">DEPENDENT_EXPLICIT</a> : thm
<a name="line709"></a>    val <a href="#DEPENDENT_MONO-val">DEPENDENT_MONO</a> : thm
<a name="line710"></a>    val <a href="#DIAMETER_BALL-val">DIAMETER_BALL</a> : thm
<a name="line711"></a>    val <a href="#DIAMETER_BOUNDED-val">DIAMETER_BOUNDED</a> : thm
<a name="line712"></a>    val <a href="#DIAMETER_BOUNDED_BOUND-val">DIAMETER_BOUNDED_BOUND</a> : thm
<a name="line713"></a>    val <a href="#DIAMETER_CBALL-val">DIAMETER_CBALL</a> : thm
<a name="line714"></a>    val <a href="#DIAMETER_CLOSURE-val">DIAMETER_CLOSURE</a> : thm
<a name="line715"></a>    val <a href="#DIAMETER_EMPTY-val">DIAMETER_EMPTY</a> : thm
<a name="line716"></a>    val <a href="#DIAMETER_EQ_0-val">DIAMETER_EQ_0</a> : thm
<a name="line717"></a>    val <a href="#DIAMETER_INTERVAL-val">DIAMETER_INTERVAL</a> : thm
<a name="line718"></a>    val <a href="#DIAMETER_LE-val">DIAMETER_LE</a> : thm
<a name="line719"></a>    val <a href="#DIAMETER_LINEAR_IMAGE-val">DIAMETER_LINEAR_IMAGE</a> : thm
<a name="line720"></a>    val <a href="#DIAMETER_POS_LE-val">DIAMETER_POS_LE</a> : thm
<a name="line721"></a>    val <a href="#DIAMETER_SING-val">DIAMETER_SING</a> : thm
<a name="line722"></a>    val <a href="#DIAMETER_SUBSET-val">DIAMETER_SUBSET</a> : thm
<a name="line723"></a>    val <a href="#DIAMETER_SUBSET_CBALL-val">DIAMETER_SUBSET_CBALL</a> : thm
<a name="line724"></a>    val <a href="#DIAMETER_SUBSET_CBALL_NONEMPTY-val">DIAMETER_SUBSET_CBALL_NONEMPTY</a> : thm
<a name="line725"></a>    val <a href="#DIAMETER_SUMS-val">DIAMETER_SUMS</a> : thm
<a name="line726"></a>    val <a href="#DIFF_CLOSURE_SUBSET-val">DIFF_CLOSURE_SUBSET</a> : thm
<a name="line727"></a>    val <a href="#DIM_LE_CARD-val">DIM_LE_CARD</a> : thm
<a name="line728"></a>    val <a href="#DIM_SUBSET-val">DIM_SUBSET</a> : thm
<a name="line729"></a>    val <a href="#DIM_SUBSET_UNIV-val">DIM_SUBSET_UNIV</a> : thm
<a name="line730"></a>    val <a href="#DIM_SUBSTANDARD-val">DIM_SUBSTANDARD</a> : thm
<a name="line731"></a>    val <a href="#DIM_UNIQUE-val">DIM_UNIQUE</a> : thm
<a name="line732"></a>    val <a href="#DIM_UNIV-val">DIM_UNIV</a> : thm
<a name="line733"></a>    val <a href="#DINI-val">DINI</a> : thm
<a name="line734"></a>    val <a href="#DISCRETE_BOUNDED_IMP_FINITE-val">DISCRETE_BOUNDED_IMP_FINITE</a> : thm
<a name="line735"></a>    val <a href="#DISCRETE_IMP_CLOSED-val">DISCRETE_IMP_CLOSED</a> : thm
<a name="line736"></a>    val <a href="#DISJOINT_INTERVAL-val">DISJOINT_INTERVAL</a> : thm
<a name="line737"></a>    val <a href="#DISTANCE_ATTAINS_INF-val">DISTANCE_ATTAINS_INF</a> : thm
<a name="line738"></a>    val <a href="#DISTANCE_ATTAINS_SUP-val">DISTANCE_ATTAINS_SUP</a> : thm
<a name="line739"></a>    val <a href="#DIST_0-val">DIST_0</a> : thm
<a name="line740"></a>    val <a href="#DIST_CLOSEST_POINT_LIPSCHITZ-val">DIST_CLOSEST_POINT_LIPSCHITZ</a> : thm
<a name="line741"></a>    val <a href="#DIST_EQ-val">DIST_EQ</a> : thm
<a name="line742"></a>    val <a href="#DIST_EQ_0-val">DIST_EQ_0</a> : thm
<a name="line743"></a>    val <a href="#DIST_IN_CLOSED_SEGMENT-val">DIST_IN_CLOSED_SEGMENT</a> : thm
<a name="line744"></a>    val <a href="#DIST_IN_OPEN_CLOSED_SEGMENT-val">DIST_IN_OPEN_CLOSED_SEGMENT</a> : thm
<a name="line745"></a>    val <a href="#DIST_IN_OPEN_SEGMENT-val">DIST_IN_OPEN_SEGMENT</a> : thm
<a name="line746"></a>    val <a href="#DIST_LE_0-val">DIST_LE_0</a> : thm
<a name="line747"></a>    val <a href="#DIST_MIDPOINT-val">DIST_MIDPOINT</a> : thm
<a name="line748"></a>    val <a href="#DIST_MUL-val">DIST_MUL</a> : thm
<a name="line749"></a>    val <a href="#DIST_NZ-val">DIST_NZ</a> : thm
<a name="line750"></a>    val <a href="#DIST_POS_LE-val">DIST_POS_LE</a> : thm
<a name="line751"></a>    val <a href="#DIST_POS_LT-val">DIST_POS_LT</a> : thm
<a name="line752"></a>    val <a href="#DIST_REFL-val">DIST_REFL</a> : thm
<a name="line753"></a>    val <a href="#DIST_SYM-val">DIST_SYM</a> : thm
<a name="line754"></a>    val <a href="#DIST_TRIANGLE-val">DIST_TRIANGLE</a> : thm
<a name="line755"></a>    val <a href="#DIST_TRIANGLE_ADD-val">DIST_TRIANGLE_ADD</a> : thm
<a name="line756"></a>    val <a href="#DIST_TRIANGLE_ADD_HALF-val">DIST_TRIANGLE_ADD_HALF</a> : thm
<a name="line757"></a>    val <a href="#DIST_TRIANGLE_ALT-val">DIST_TRIANGLE_ALT</a> : thm
<a name="line758"></a>    val <a href="#DIST_TRIANGLE_EQ-val">DIST_TRIANGLE_EQ</a> : thm
<a name="line759"></a>    val <a href="#DIST_TRIANGLE_HALF_L-val">DIST_TRIANGLE_HALF_L</a> : thm
<a name="line760"></a>    val <a href="#DIST_TRIANGLE_HALF_R-val">DIST_TRIANGLE_HALF_R</a> : thm
<a name="line761"></a>    val <a href="#DIST_TRIANGLE_LE-val">DIST_TRIANGLE_LE</a> : thm
<a name="line762"></a>    val <a href="#DIST_TRIANGLE_LT-val">DIST_TRIANGLE_LT</a> : thm
<a name="line763"></a>    val <a href="#DORDER_NET-val">DORDER_NET</a> : thm
<a name="line764"></a>    val <a href="#EMPTY_AS_INTERVAL-val">EMPTY_AS_INTERVAL</a> : thm
<a name="line765"></a>    val <a href="#EMPTY_INTERIOR_FINITE-val">EMPTY_INTERIOR_FINITE</a> : thm
<a name="line766"></a>    val <a href="#ENDS_IN_INTERVAL-val">ENDS_IN_INTERVAL</a> : thm
<a name="line767"></a>    val <a href="#ENDS_IN_SEGMENT-val">ENDS_IN_SEGMENT</a> : thm
<a name="line768"></a>    val <a href="#ENDS_IN_UNIT_INTERVAL-val">ENDS_IN_UNIT_INTERVAL</a> : thm
<a name="line769"></a>    val <a href="#ENDS_NOT_IN_SEGMENT-val">ENDS_NOT_IN_SEGMENT</a> : thm
<a name="line770"></a>    val <a href="#EQ_BALLS-val">EQ_BALLS</a> : thm
<a name="line771"></a>    val <a href="#EQ_INTERVAL-val">EQ_INTERVAL</a> : thm
<a name="line772"></a>    val <a href="#EVENTUALLY_AND-val">EVENTUALLY_AND</a> : thm
<a name="line773"></a>    val <a href="#EVENTUALLY_AT-val">EVENTUALLY_AT</a> : thm
<a name="line774"></a>    val <a href="#EVENTUALLY_AT_INFINITY-val">EVENTUALLY_AT_INFINITY</a> : thm
<a name="line775"></a>    val <a href="#EVENTUALLY_AT_INFINITY_POS-val">EVENTUALLY_AT_INFINITY_POS</a> : thm
<a name="line776"></a>    val <a href="#EVENTUALLY_AT_NEGINFINITY-val">EVENTUALLY_AT_NEGINFINITY</a> : thm
<a name="line777"></a>    val <a href="#EVENTUALLY_AT_POSINFINITY-val">EVENTUALLY_AT_POSINFINITY</a> : thm
<a name="line778"></a>    val <a href="#EVENTUALLY_FALSE-val">EVENTUALLY_FALSE</a> : thm
<a name="line779"></a>    val <a href="#EVENTUALLY_FORALL-val">EVENTUALLY_FORALL</a> : thm
<a name="line780"></a>    val <a href="#EVENTUALLY_HAPPENS-val">EVENTUALLY_HAPPENS</a> : thm
<a name="line781"></a>    val <a href="#EVENTUALLY_MONO-val">EVENTUALLY_MONO</a> : thm
<a name="line782"></a>    val <a href="#EVENTUALLY_MP-val">EVENTUALLY_MP</a> : thm
<a name="line783"></a>    val <a href="#EVENTUALLY_SEQUENTIALLY-val">EVENTUALLY_SEQUENTIALLY</a> : thm
<a name="line784"></a>    val <a href="#EVENTUALLY_TRUE-val">EVENTUALLY_TRUE</a> : thm
<a name="line785"></a>    val <a href="#EVENTUALLY_WITHIN-val">EVENTUALLY_WITHIN</a> : thm
<a name="line786"></a>    val <a href="#EVENTUALLY_WITHIN_INTERIOR-val">EVENTUALLY_WITHIN_INTERIOR</a> : thm
<a name="line787"></a>    val <a href="#EVENTUALLY_WITHIN_LE-val">EVENTUALLY_WITHIN_LE</a> : thm
<a name="line788"></a>    val <a href="#EXCHANGE_LEMMA-val">EXCHANGE_LEMMA</a> : thm
<a name="line789"></a>    val <a href="#EXISTS_COMPONENT_SUPERSET-val">EXISTS_COMPONENT_SUPERSET</a> : thm
<a name="line790"></a>    val <a href="#EXISTS_DIFF-val">EXISTS_DIFF</a> : thm
<a name="line791"></a>    val <a href="#EXISTS_IN_INSERT-val">EXISTS_IN_INSERT</a> : thm
<a name="line792"></a>    val <a href="#EXTENSION_FROM_CLOPEN-val">EXTENSION_FROM_CLOPEN</a> : thm
<a name="line793"></a>    val <a href="#FINITE_BALL-val">FINITE_BALL</a> : thm
<a name="line794"></a>    val <a href="#FINITE_CBALL-val">FINITE_CBALL</a> : thm
<a name="line795"></a>    val <a href="#FINITE_IMP_BOUNDED-val">FINITE_IMP_BOUNDED</a> : thm
<a name="line796"></a>    val <a href="#FINITE_IMP_CLOSED-val">FINITE_IMP_CLOSED</a> : thm
<a name="line797"></a>    val <a href="#FINITE_IMP_CLOSED_IN-val">FINITE_IMP_CLOSED_IN</a> : thm
<a name="line798"></a>    val <a href="#FINITE_IMP_COMPACT-val">FINITE_IMP_COMPACT</a> : thm
<a name="line799"></a>    val <a href="#FINITE_IMP_NOT_OPEN-val">FINITE_IMP_NOT_OPEN</a> : thm
<a name="line800"></a>    val <a href="#FINITE_INTERVAL-val">FINITE_INTERVAL</a> : thm
<a name="line801"></a>    val <a href="#FINITE_INTER_NUMSEG-val">FINITE_INTER_NUMSEG</a> : thm
<a name="line802"></a>    val <a href="#FINITE_SET_AVOID-val">FINITE_SET_AVOID</a> : thm
<a name="line803"></a>    val <a href="#FINITE_SPHERE-val">FINITE_SPHERE</a> : thm
<a name="line804"></a>    val <a href="#FORALL_EVENTUALLY-val">FORALL_EVENTUALLY</a> : thm
<a name="line805"></a>    val <a href="#FORALL_IN_CLOSURE-val">FORALL_IN_CLOSURE</a> : thm
<a name="line806"></a>    val <a href="#FORALL_IN_CLOSURE_EQ-val">FORALL_IN_CLOSURE_EQ</a> : thm
<a name="line807"></a>    val <a href="#FORALL_POS_MONO_1-val">FORALL_POS_MONO_1</a> : thm
<a name="line808"></a>    val <a href="#FRONTIER_BALL-val">FRONTIER_BALL</a> : thm
<a name="line809"></a>    val <a href="#FRONTIER_CBALL-val">FRONTIER_CBALL</a> : thm
<a name="line810"></a>    val <a href="#FRONTIER_CLOSED-val">FRONTIER_CLOSED</a> : thm
<a name="line811"></a>    val <a href="#FRONTIER_CLOSED_INTERVAL-val">FRONTIER_CLOSED_INTERVAL</a> : thm
<a name="line812"></a>    val <a href="#FRONTIER_CLOSURES-val">FRONTIER_CLOSURES</a> : thm
<a name="line813"></a>    val <a href="#FRONTIER_CLOSURE_SUBSET-val">FRONTIER_CLOSURE_SUBSET</a> : thm
<a name="line814"></a>    val <a href="#FRONTIER_COMPLEMENT-val">FRONTIER_COMPLEMENT</a> : thm
<a name="line815"></a>    val <a href="#FRONTIER_DISJOINT_EQ-val">FRONTIER_DISJOINT_EQ</a> : thm
<a name="line816"></a>    val <a href="#FRONTIER_EMPTY-val">FRONTIER_EMPTY</a> : thm
<a name="line817"></a>    val <a href="#FRONTIER_FRONTIER-val">FRONTIER_FRONTIER</a> : thm
<a name="line818"></a>    val <a href="#FRONTIER_FRONTIER_FRONTIER-val">FRONTIER_FRONTIER_FRONTIER</a> : thm
<a name="line819"></a>    val <a href="#FRONTIER_FRONTIER_SUBSET-val">FRONTIER_FRONTIER_SUBSET</a> : thm
<a name="line820"></a>    val <a href="#FRONTIER_HALFSPACE_GE-val">FRONTIER_HALFSPACE_GE</a> : thm
<a name="line821"></a>    val <a href="#FRONTIER_HALFSPACE_GT-val">FRONTIER_HALFSPACE_GT</a> : thm
<a name="line822"></a>    val <a href="#FRONTIER_HALFSPACE_LE-val">FRONTIER_HALFSPACE_LE</a> : thm
<a name="line823"></a>    val <a href="#FRONTIER_HALFSPACE_LT-val">FRONTIER_HALFSPACE_LT</a> : thm
<a name="line824"></a>    val <a href="#FRONTIER_INTERIORS-val">FRONTIER_INTERIORS</a> : thm
<a name="line825"></a>    val <a href="#FRONTIER_INTERIOR_SUBSET-val">FRONTIER_INTERIOR_SUBSET</a> : thm
<a name="line826"></a>    val <a href="#FRONTIER_INTER_SUBSET-val">FRONTIER_INTER_SUBSET</a> : thm
<a name="line827"></a>    val <a href="#FRONTIER_INTER_SUBSET_INTER-val">FRONTIER_INTER_SUBSET_INTER</a> : thm
<a name="line828"></a>    val <a href="#FRONTIER_OPEN_INTERVAL-val">FRONTIER_OPEN_INTERVAL</a> : thm
<a name="line829"></a>    val <a href="#FRONTIER_SING-val">FRONTIER_SING</a> : thm
<a name="line830"></a>    val <a href="#FRONTIER_STRADDLE-val">FRONTIER_STRADDLE</a> : thm
<a name="line831"></a>    val <a href="#FRONTIER_SUBSET_CLOSED-val">FRONTIER_SUBSET_CLOSED</a> : thm
<a name="line832"></a>    val <a href="#FRONTIER_SUBSET_COMPACT-val">FRONTIER_SUBSET_COMPACT</a> : thm
<a name="line833"></a>    val <a href="#FRONTIER_SUBSET_EQ-val">FRONTIER_SUBSET_EQ</a> : thm
<a name="line834"></a>    val <a href="#FRONTIER_UNION-val">FRONTIER_UNION</a> : thm
<a name="line835"></a>    val <a href="#FRONTIER_UNION_SUBSET-val">FRONTIER_UNION_SUBSET</a> : thm
<a name="line836"></a>    val <a href="#FRONTIER_UNIV-val">FRONTIER_UNIV</a> : thm
<a name="line837"></a>    val <a href="#FUNCTION_FACTORS_LEFT_GEN-val">FUNCTION_FACTORS_LEFT_GEN</a> : thm
<a name="line838"></a>    val <a href="#GDELTA_COMPLEMENT-val">GDELTA_COMPLEMENT</a> : thm
<a name="line839"></a>    val <a href="#GREATER_EQ_REFL-val">GREATER_EQ_REFL</a> : thm
<a name="line840"></a>    val <a href="#HAS_SIZE_STDBASIS-val">HAS_SIZE_STDBASIS</a> : thm
<a name="line841"></a>    val <a href="#HAUSDIST_ALT-val">HAUSDIST_ALT</a> : thm
<a name="line842"></a>    val <a href="#HAUSDIST_BALLS-val">HAUSDIST_BALLS</a> : thm
<a name="line843"></a>    val <a href="#HAUSDIST_CLOSURE-val">HAUSDIST_CLOSURE</a> : thm
<a name="line844"></a>    val <a href="#HAUSDIST_COMPACT_EXISTS-val">HAUSDIST_COMPACT_EXISTS</a> : thm
<a name="line845"></a>    val <a href="#HAUSDIST_COMPACT_NONTRIVIAL-val">HAUSDIST_COMPACT_NONTRIVIAL</a> : thm
<a name="line846"></a>    val <a href="#HAUSDIST_COMPACT_SUMS-val">HAUSDIST_COMPACT_SUMS</a> : thm
<a name="line847"></a>    val <a href="#HAUSDIST_EMPTY-val">HAUSDIST_EMPTY</a> : thm
<a name="line848"></a>    val <a href="#HAUSDIST_EQ-val">HAUSDIST_EQ</a> : thm
<a name="line849"></a>    val <a href="#HAUSDIST_EQ_0-val">HAUSDIST_EQ_0</a> : thm
<a name="line850"></a>    val <a href="#HAUSDIST_INSERT_LE-val">HAUSDIST_INSERT_LE</a> : thm
<a name="line851"></a>    val <a href="#HAUSDIST_LINEAR_IMAGE-val">HAUSDIST_LINEAR_IMAGE</a> : thm
<a name="line852"></a>    val <a href="#HAUSDIST_NONTRIVIAL-val">HAUSDIST_NONTRIVIAL</a> : thm
<a name="line853"></a>    val <a href="#HAUSDIST_NONTRIVIAL_ALT-val">HAUSDIST_NONTRIVIAL_ALT</a> : thm
<a name="line854"></a>    val <a href="#HAUSDIST_POS_LE-val">HAUSDIST_POS_LE</a> : thm
<a name="line855"></a>    val <a href="#HAUSDIST_REFL-val">HAUSDIST_REFL</a> : thm
<a name="line856"></a>    val <a href="#HAUSDIST_SETDIST_TRIANGLE-val">HAUSDIST_SETDIST_TRIANGLE</a> : thm
<a name="line857"></a>    val <a href="#HAUSDIST_SINGS-val">HAUSDIST_SINGS</a> : thm
<a name="line858"></a>    val <a href="#HAUSDIST_SYM-val">HAUSDIST_SYM</a> : thm
<a name="line859"></a>    val <a href="#HAUSDIST_TRANS-val">HAUSDIST_TRANS</a> : thm
<a name="line860"></a>    val <a href="#HAUSDIST_TRANSLATION-val">HAUSDIST_TRANSLATION</a> : thm
<a name="line861"></a>    val <a href="#HAUSDIST_TRIANGLE-val">HAUSDIST_TRIANGLE</a> : thm
<a name="line862"></a>    val <a href="#HAUSDIST_UNION_LE-val">HAUSDIST_UNION_LE</a> : thm
<a name="line863"></a>    val <a href="#HEINE_BOREL_IMP_BOLZANO_WEIERSTRASS-val">HEINE_BOREL_IMP_BOLZANO_WEIERSTRASS</a> : thm
<a name="line864"></a>    val <a href="#HEINE_BOREL_LEMMA-val">HEINE_BOREL_LEMMA</a> : thm
<a name="line865"></a>    val <a href="#HOMEOMORPHIC_AFFINITY-val">HOMEOMORPHIC_AFFINITY</a> : thm
<a name="line866"></a>    val <a href="#HOMEOMORPHIC_BALLS-val">HOMEOMORPHIC_BALLS</a> : thm
<a name="line867"></a>    val <a href="#HOMEOMORPHIC_BALLS_CBALL_SPHERE-val">HOMEOMORPHIC_BALLS_CBALL_SPHERE</a> : thm
<a name="line868"></a>    val <a href="#HOMEOMORPHIC_CBALL-val">HOMEOMORPHIC_CBALL</a> : thm
<a name="line869"></a>    val <a href="#HOMEOMORPHIC_COMPACT-val">HOMEOMORPHIC_COMPACT</a> : thm
<a name="line870"></a>    val <a href="#HOMEOMORPHIC_COMPACTNESS-val">HOMEOMORPHIC_COMPACTNESS</a> : thm
<a name="line871"></a>    val <a href="#HOMEOMORPHIC_CONNECTEDNESS-val">HOMEOMORPHIC_CONNECTEDNESS</a> : thm
<a name="line872"></a>    val <a href="#HOMEOMORPHIC_EMPTY-val">HOMEOMORPHIC_EMPTY</a> : thm
<a name="line873"></a>    val <a href="#HOMEOMORPHIC_FINITE-val">HOMEOMORPHIC_FINITE</a> : thm
<a name="line874"></a>    val <a href="#HOMEOMORPHIC_FINITENESS-val">HOMEOMORPHIC_FINITENESS</a> : thm
<a name="line875"></a>    val <a href="#HOMEOMORPHIC_FINITE_STRONG-val">HOMEOMORPHIC_FINITE_STRONG</a> : thm
<a name="line876"></a>    val <a href="#HOMEOMORPHIC_HYPERPLANES-val">HOMEOMORPHIC_HYPERPLANES</a> : thm
<a name="line877"></a>    val <a href="#HOMEOMORPHIC_HYPERPLANE_STANDARD_HYPERPLANE-val">HOMEOMORPHIC_HYPERPLANE_STANDARD_HYPERPLANE</a> : thm
<a name="line878"></a>    val <a href="#HOMEOMORPHIC_IMP_CARD_EQ-val">HOMEOMORPHIC_IMP_CARD_EQ</a> : thm
<a name="line879"></a>    val <a href="#HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_LEFT_EQ-val">HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_LEFT_EQ</a> : thm
<a name="line880"></a>    val <a href="#HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_RIGHT_EQ-val">HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_RIGHT_EQ</a> : thm
<a name="line881"></a>    val <a href="#HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_SELF-val">HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_SELF</a> : thm
<a name="line882"></a>    val <a href="#HOMEOMORPHIC_LOCALLY-val">HOMEOMORPHIC_LOCALLY</a> : thm
<a name="line883"></a>    val <a href="#HOMEOMORPHIC_LOCAL_COMPACTNESS-val">HOMEOMORPHIC_LOCAL_COMPACTNESS</a> : thm
<a name="line884"></a>    val <a href="#HOMEOMORPHIC_MINIMAL-val">HOMEOMORPHIC_MINIMAL</a> : thm
<a name="line885"></a>    val <a href="#HOMEOMORPHIC_ONE_POINT_COMPACTIFICATIONS-val">HOMEOMORPHIC_ONE_POINT_COMPACTIFICATIONS</a> : thm
<a name="line886"></a>    val <a href="#HOMEOMORPHIC_OPEN_INTERVALS-val">HOMEOMORPHIC_OPEN_INTERVALS</a> : thm
<a name="line887"></a>    val <a href="#HOMEOMORPHIC_OPEN_INTERVAL_UNIV-val">HOMEOMORPHIC_OPEN_INTERVAL_UNIV</a> : thm
<a name="line888"></a>    val <a href="#HOMEOMORPHIC_REFL-val">HOMEOMORPHIC_REFL</a> : thm
<a name="line889"></a>    val <a href="#HOMEOMORPHIC_SCALING-val">HOMEOMORPHIC_SCALING</a> : thm
<a name="line890"></a>    val <a href="#HOMEOMORPHIC_SCALING_LEFT-val">HOMEOMORPHIC_SCALING_LEFT</a> : thm
<a name="line891"></a>    val <a href="#HOMEOMORPHIC_SCALING_RIGHT-val">HOMEOMORPHIC_SCALING_RIGHT</a> : thm
<a name="line892"></a>    val <a href="#HOMEOMORPHIC_SING-val">HOMEOMORPHIC_SING</a> : thm
<a name="line893"></a>    val <a href="#HOMEOMORPHIC_SPHERE-val">HOMEOMORPHIC_SPHERE</a> : thm
<a name="line894"></a>    val <a href="#HOMEOMORPHIC_STANDARD_HYPERPLANE_HYPERPLANE-val">HOMEOMORPHIC_STANDARD_HYPERPLANE_HYPERPLANE</a> : thm
<a name="line895"></a>    val <a href="#HOMEOMORPHIC_SYM-val">HOMEOMORPHIC_SYM</a> : thm
<a name="line896"></a>    val <a href="#HOMEOMORPHIC_TRANS-val">HOMEOMORPHIC_TRANS</a> : thm
<a name="line897"></a>    val <a href="#HOMEOMORPHIC_TRANSLATION-val">HOMEOMORPHIC_TRANSLATION</a> : thm
<a name="line898"></a>    val <a href="#HOMEOMORPHIC_TRANSLATION_LEFT_EQ-val">HOMEOMORPHIC_TRANSLATION_LEFT_EQ</a> : thm
<a name="line899"></a>    val <a href="#HOMEOMORPHIC_TRANSLATION_RIGHT_EQ-val">HOMEOMORPHIC_TRANSLATION_RIGHT_EQ</a> : thm
<a name="line900"></a>    val <a href="#HOMEOMORPHIC_TRANSLATION_SELF-val">HOMEOMORPHIC_TRANSLATION_SELF</a> : thm
<a name="line901"></a>    val <a href="#HOMEOMORPHISM-val">HOMEOMORPHISM</a> : thm
<a name="line902"></a>    val <a href="#HOMEOMORPHISM_COMPACT-val">HOMEOMORPHISM_COMPACT</a> : thm
<a name="line903"></a>    val <a href="#HOMEOMORPHISM_COMPOSE-val">HOMEOMORPHISM_COMPOSE</a> : thm
<a name="line904"></a>    val <a href="#HOMEOMORPHISM_FROM_COMPOSITION_INJECTIVE-val">HOMEOMORPHISM_FROM_COMPOSITION_INJECTIVE</a> : thm
<a name="line905"></a>    val <a href="#HOMEOMORPHISM_FROM_COMPOSITION_SURJECTIVE-val">HOMEOMORPHISM_FROM_COMPOSITION_SURJECTIVE</a> : thm
<a name="line906"></a>    val <a href="#HOMEOMORPHISM_ID-val">HOMEOMORPHISM_ID</a> : thm
<a name="line907"></a>    val <a href="#HOMEOMORPHISM_IMP_CLOSED_MAP-val">HOMEOMORPHISM_IMP_CLOSED_MAP</a> : thm
<a name="line908"></a>    val <a href="#HOMEOMORPHISM_IMP_OPEN_MAP-val">HOMEOMORPHISM_IMP_OPEN_MAP</a> : thm
<a name="line909"></a>    val <a href="#HOMEOMORPHISM_IMP_QUOTIENT_MAP-val">HOMEOMORPHISM_IMP_QUOTIENT_MAP</a> : thm
<a name="line910"></a>    val <a href="#HOMEOMORPHISM_INJECTIVE_CLOSED_MAP-val">HOMEOMORPHISM_INJECTIVE_CLOSED_MAP</a> : thm
<a name="line911"></a>    val <a href="#HOMEOMORPHISM_INJECTIVE_CLOSED_MAP_EQ-val">HOMEOMORPHISM_INJECTIVE_CLOSED_MAP_EQ</a> : thm
<a name="line912"></a>    val <a href="#HOMEOMORPHISM_INJECTIVE_OPEN_MAP-val">HOMEOMORPHISM_INJECTIVE_OPEN_MAP</a> : thm
<a name="line913"></a>    val <a href="#HOMEOMORPHISM_INJECTIVE_OPEN_MAP_EQ-val">HOMEOMORPHISM_INJECTIVE_OPEN_MAP_EQ</a> : thm
<a name="line914"></a>    val <a href="#HOMEOMORPHISM_LOCALLY-val">HOMEOMORPHISM_LOCALLY</a> : thm
<a name="line915"></a>    val <a href="#HOMEOMORPHISM_OF_SUBSETS-val">HOMEOMORPHISM_OF_SUBSETS</a> : thm
<a name="line916"></a>    val <a href="#HOMEOMORPHISM_SYM-val">HOMEOMORPHISM_SYM</a> : thm
<a name="line917"></a>    val <a href="#IMAGE_AFFINITY_INTERVAL-val">IMAGE_AFFINITY_INTERVAL</a> : thm
<a name="line918"></a>    val <a href="#IMAGE_CLOSURE_SUBSET-val">IMAGE_CLOSURE_SUBSET</a> : thm
<a name="line919"></a>    val <a href="#IMAGE_STRETCH_INTERVAL-val">IMAGE_STRETCH_INTERVAL</a> : thm
<a name="line920"></a>    val <a href="#IMAGE_TWIZZLE_INTERVAL-val">IMAGE_TWIZZLE_INTERVAL</a> : thm
<a name="line921"></a>    val <a href="#INDEPENDENT_BOUND-val">INDEPENDENT_BOUND</a> : thm
<a name="line922"></a>    val <a href="#INDEPENDENT_CARD_LE_DIM-val">INDEPENDENT_CARD_LE_DIM</a> : thm
<a name="line923"></a>    val <a href="#INDEPENDENT_EMPTY-val">INDEPENDENT_EMPTY</a> : thm
<a name="line924"></a>    val <a href="#INDEPENDENT_INJECTIVE_IMAGE-val">INDEPENDENT_INJECTIVE_IMAGE</a> : thm
<a name="line925"></a>    val <a href="#INDEPENDENT_INJECTIVE_IMAGE_GEN-val">INDEPENDENT_INJECTIVE_IMAGE_GEN</a> : thm
<a name="line926"></a>    val <a href="#INDEPENDENT_INSERT-val">INDEPENDENT_INSERT</a> : thm
<a name="line927"></a>    val <a href="#INDEPENDENT_MONO-val">INDEPENDENT_MONO</a> : thm
<a name="line928"></a>    val <a href="#INDEPENDENT_NONZERO-val">INDEPENDENT_NONZERO</a> : thm
<a name="line929"></a>    val <a href="#INDEPENDENT_SING-val">INDEPENDENT_SING</a> : thm
<a name="line930"></a>    val <a href="#INDEPENDENT_SPAN_BOUND-val">INDEPENDENT_SPAN_BOUND</a> : thm
<a name="line931"></a>    val <a href="#INDEPENDENT_STDBASIS-val">INDEPENDENT_STDBASIS</a> : thm
<a name="line932"></a>    val <a href="#INFINITE_OPEN_IN-val">INFINITE_OPEN_IN</a> : thm
<a name="line933"></a>    val <a href="#INFINITE_SUPERSET-val">INFINITE_SUPERSET</a> : thm
<a name="line934"></a>    val <a href="#INFSUM_0-val">INFSUM_0</a> : thm
<a name="line935"></a>    val <a href="#INFSUM_ADD-val">INFSUM_ADD</a> : thm
<a name="line936"></a>    val <a href="#INFSUM_CMUL-val">INFSUM_CMUL</a> : thm
<a name="line937"></a>    val <a href="#INFSUM_EQ-val">INFSUM_EQ</a> : thm
<a name="line938"></a>    val <a href="#INFSUM_LINEAR-val">INFSUM_LINEAR</a> : thm
<a name="line939"></a>    val <a href="#INFSUM_NEG-val">INFSUM_NEG</a> : thm
<a name="line940"></a>    val <a href="#INFSUM_RESTRICT-val">INFSUM_RESTRICT</a> : thm
<a name="line941"></a>    val <a href="#INFSUM_SUB-val">INFSUM_SUB</a> : thm
<a name="line942"></a>    val <a href="#INFSUM_UNIQUE-val">INFSUM_UNIQUE</a> : thm
<a name="line943"></a>    val <a href="#INF_INSERT-val">INF_INSERT</a> : thm
<a name="line944"></a>    val <a href="#INJECTIVE_IMP_ISOMETRIC-val">INJECTIVE_IMP_ISOMETRIC</a> : thm
<a name="line945"></a>    val <a href="#INJECTIVE_MAP_OPEN_IFF_CLOSED-val">INJECTIVE_MAP_OPEN_IFF_CLOSED</a> : thm
<a name="line946"></a>    val <a href="#INTERIOR_BALL-val">INTERIOR_BALL</a> : thm
<a name="line947"></a>    val <a href="#INTERIOR_BIGINTER_SUBSET-val">INTERIOR_BIGINTER_SUBSET</a> : thm
<a name="line948"></a>    val <a href="#INTERIOR_BIJECTIVE_LINEAR_IMAGE-val">INTERIOR_BIJECTIVE_LINEAR_IMAGE</a> : thm
<a name="line949"></a>    val <a href="#INTERIOR_CBALL-val">INTERIOR_CBALL</a> : thm
<a name="line950"></a>    val <a href="#INTERIOR_CLOSED_EQ_EMPTY_AS_FRONTIER-val">INTERIOR_CLOSED_EQ_EMPTY_AS_FRONTIER</a> : thm
<a name="line951"></a>    val <a href="#INTERIOR_CLOSED_INTERVAL-val">INTERIOR_CLOSED_INTERVAL</a> : thm
<a name="line952"></a>    val <a href="#INTERIOR_CLOSED_UNION_EMPTY_INTERIOR-val">INTERIOR_CLOSED_UNION_EMPTY_INTERIOR</a> : thm
<a name="line953"></a>    val <a href="#INTERIOR_CLOSURE-val">INTERIOR_CLOSURE</a> : thm
<a name="line954"></a>    val <a href="#INTERIOR_CLOSURE_IDEMP-val">INTERIOR_CLOSURE_IDEMP</a> : thm
<a name="line955"></a>    val <a href="#INTERIOR_CLOSURE_INTER_OPEN-val">INTERIOR_CLOSURE_INTER_OPEN</a> : thm
<a name="line956"></a>    val <a href="#INTERIOR_COMPLEMENT-val">INTERIOR_COMPLEMENT</a> : thm
<a name="line957"></a>    val <a href="#INTERIOR_DIFF-val">INTERIOR_DIFF</a> : thm
<a name="line958"></a>    val <a href="#INTERIOR_EMPTY-val">INTERIOR_EMPTY</a> : thm
<a name="line959"></a>    val <a href="#INTERIOR_EQ-val">INTERIOR_EQ</a> : thm
<a name="line960"></a>    val <a href="#INTERIOR_EQ_EMPTY-val">INTERIOR_EQ_EMPTY</a> : thm
<a name="line961"></a>    val <a href="#INTERIOR_EQ_EMPTY_ALT-val">INTERIOR_EQ_EMPTY_ALT</a> : thm
<a name="line962"></a>    val <a href="#INTERIOR_FINITE_BIGINTER-val">INTERIOR_FINITE_BIGINTER</a> : thm
<a name="line963"></a>    val <a href="#INTERIOR_FRONTIER-val">INTERIOR_FRONTIER</a> : thm
<a name="line964"></a>    val <a href="#INTERIOR_FRONTIER_EMPTY-val">INTERIOR_FRONTIER_EMPTY</a> : thm
<a name="line965"></a>    val <a href="#INTERIOR_HALFSPACE_COMPONENT_GE-val">INTERIOR_HALFSPACE_COMPONENT_GE</a> : thm
<a name="line966"></a>    val <a href="#INTERIOR_HALFSPACE_COMPONENT_LE-val">INTERIOR_HALFSPACE_COMPONENT_LE</a> : thm
<a name="line967"></a>    val <a href="#INTERIOR_HALFSPACE_GE-val">INTERIOR_HALFSPACE_GE</a> : thm
<a name="line968"></a>    val <a href="#INTERIOR_HALFSPACE_LE-val">INTERIOR_HALFSPACE_LE</a> : thm
<a name="line969"></a>    val <a href="#INTERIOR_HYPERPLANE-val">INTERIOR_HYPERPLANE</a> : thm
<a name="line970"></a>    val <a href="#INTERIOR_IMAGE_SUBSET-val">INTERIOR_IMAGE_SUBSET</a> : thm
<a name="line971"></a>    val <a href="#INTERIOR_INJECTIVE_LINEAR_IMAGE-val">INTERIOR_INJECTIVE_LINEAR_IMAGE</a> : thm
<a name="line972"></a>    val <a href="#INTERIOR_INTER-val">INTERIOR_INTER</a> : thm
<a name="line973"></a>    val <a href="#INTERIOR_INTERIOR-val">INTERIOR_INTERIOR</a> : thm
<a name="line974"></a>    val <a href="#INTERIOR_INTERVAL-val">INTERIOR_INTERVAL</a> : thm
<a name="line975"></a>    val <a href="#INTERIOR_LIMIT_POINT-val">INTERIOR_LIMIT_POINT</a> : thm
<a name="line976"></a>    val <a href="#INTERIOR_MAXIMAL-val">INTERIOR_MAXIMAL</a> : thm
<a name="line977"></a>    val <a href="#INTERIOR_MAXIMAL_EQ-val">INTERIOR_MAXIMAL_EQ</a> : thm
<a name="line978"></a>    val <a href="#INTERIOR_NEGATIONS-val">INTERIOR_NEGATIONS</a> : thm
<a name="line979"></a>    val <a href="#INTERIOR_OPEN-val">INTERIOR_OPEN</a> : thm
<a name="line980"></a>    val <a href="#INTERIOR_SING-val">INTERIOR_SING</a> : thm
<a name="line981"></a>    val <a href="#INTERIOR_STANDARD_HYPERPLANE-val">INTERIOR_STANDARD_HYPERPLANE</a> : thm
<a name="line982"></a>    val <a href="#INTERIOR_SUBSET-val">INTERIOR_SUBSET</a> : thm
<a name="line983"></a>    val <a href="#INTERIOR_TRANSLATION-val">INTERIOR_TRANSLATION</a> : thm
<a name="line984"></a>    val <a href="#INTERIOR_UNIONS_OPEN_SUBSETS-val">INTERIOR_UNIONS_OPEN_SUBSETS</a> : thm
<a name="line985"></a>    val <a href="#INTERIOR_UNION_EQ_EMPTY-val">INTERIOR_UNION_EQ_EMPTY</a> : thm
<a name="line986"></a>    val <a href="#INTERIOR_UNIQUE-val">INTERIOR_UNIQUE</a> : thm
<a name="line987"></a>    val <a href="#INTERIOR_UNIV-val">INTERIOR_UNIV</a> : thm
<a name="line988"></a>    val <a href="#INTERVAL-val">INTERVAL</a> : thm
<a name="line989"></a>    val <a href="#INTERVAL_BOUNDS_EMPTY-val">INTERVAL_BOUNDS_EMPTY</a> : thm
<a name="line990"></a>    val <a href="#INTERVAL_BOUNDS_NULL-val">INTERVAL_BOUNDS_NULL</a> : thm
<a name="line991"></a>    val <a href="#INTERVAL_CASES-val">INTERVAL_CASES</a> : thm
<a name="line992"></a>    val <a href="#INTERVAL_CONTAINS_COMPACT_NEIGHBOURHOOD-val">INTERVAL_CONTAINS_COMPACT_NEIGHBOURHOOD</a> : thm
<a name="line993"></a>    val <a href="#INTERVAL_EQ_EMPTY-val">INTERVAL_EQ_EMPTY</a> : thm
<a name="line994"></a>    val <a href="#INTERVAL_IMAGE_STRETCH_INTERVAL-val">INTERVAL_IMAGE_STRETCH_INTERVAL</a> : thm
<a name="line995"></a>    val <a href="#INTERVAL_LOWERBOUND-val">INTERVAL_LOWERBOUND</a> : thm
<a name="line996"></a>    val <a href="#INTERVAL_LOWERBOUND_NONEMPTY-val">INTERVAL_LOWERBOUND_NONEMPTY</a> : thm
<a name="line997"></a>    val <a href="#INTERVAL_NE_EMPTY-val">INTERVAL_NE_EMPTY</a> : thm
<a name="line998"></a>    val <a href="#INTERVAL_OPEN_SUBSET_CLOSED-val">INTERVAL_OPEN_SUBSET_CLOSED</a> : thm
<a name="line999"></a>    val <a href="#INTERVAL_SING-val">INTERVAL_SING</a> : thm
<a name="line1000"></a>    val <a href="#INTERVAL_SUBSET_IS_INTERVAL-val">INTERVAL_SUBSET_IS_INTERVAL</a> : thm
<a name="line1001"></a>    val <a href="#INTERVAL_TRANSLATION-val">INTERVAL_TRANSLATION</a> : thm
<a name="line1002"></a>    val <a href="#INTERVAL_UPPERBOUND-val">INTERVAL_UPPERBOUND</a> : thm
<a name="line1003"></a>    val <a href="#INTERVAL_UPPERBOUND_NONEMPTY-val">INTERVAL_UPPERBOUND_NONEMPTY</a> : thm
<a name="line1004"></a>    val <a href="#INTER_BALLS_EQ_EMPTY-val">INTER_BALLS_EQ_EMPTY</a> : thm
<a name="line1005"></a>    val <a href="#INTER_INTERVAL-val">INTER_INTERVAL</a> : thm
<a name="line1006"></a>    val <a href="#INTER_INTERVAL_MIXED_EQ_EMPTY-val">INTER_INTERVAL_MIXED_EQ_EMPTY</a> : thm
<a name="line1007"></a>    val <a href="#IN_BALL-val">IN_BALL</a> : thm
<a name="line1008"></a>    val <a href="#IN_BALL_0-val">IN_BALL_0</a> : thm
<a name="line1009"></a>    val <a href="#IN_CBALL-val">IN_CBALL</a> : thm
<a name="line1010"></a>    val <a href="#IN_CBALL_0-val">IN_CBALL_0</a> : thm
<a name="line1011"></a>    val <a href="#IN_CLOSURE_DELETE-val">IN_CLOSURE_DELETE</a> : thm
<a name="line1012"></a>    val <a href="#IN_COMPONENTS-val">IN_COMPONENTS</a> : thm
<a name="line1013"></a>    val <a href="#IN_COMPONENTS_BIGUNION_COMPLEMENT-val">IN_COMPONENTS_BIGUNION_COMPLEMENT</a> : thm
<a name="line1014"></a>    val <a href="#IN_COMPONENTS_CONNECTED-val">IN_COMPONENTS_CONNECTED</a> : thm
<a name="line1015"></a>    val <a href="#IN_COMPONENTS_MAXIMAL-val">IN_COMPONENTS_MAXIMAL</a> : thm
<a name="line1016"></a>    val <a href="#IN_COMPONENTS_NONEMPTY-val">IN_COMPONENTS_NONEMPTY</a> : thm
<a name="line1017"></a>    val <a href="#IN_COMPONENTS_SELF-val">IN_COMPONENTS_SELF</a> : thm
<a name="line1018"></a>    val <a href="#IN_COMPONENTS_SUBSET-val">IN_COMPONENTS_SUBSET</a> : thm
<a name="line1019"></a>    val <a href="#IN_DIRECTION-val">IN_DIRECTION</a> : thm
<a name="line1020"></a>    val <a href="#IN_INTERIOR-val">IN_INTERIOR</a> : thm
<a name="line1021"></a>    val <a href="#IN_INTERIOR_CBALL-val">IN_INTERIOR_CBALL</a> : thm
<a name="line1022"></a>    val <a href="#IN_INTERIOR_LINEAR_IMAGE-val">IN_INTERIOR_LINEAR_IMAGE</a> : thm
<a name="line1023"></a>    val <a href="#IN_INTERVAL-val">IN_INTERVAL</a> : thm
<a name="line1024"></a>    val <a href="#IN_INTERVAL_REFLECT-val">IN_INTERVAL_REFLECT</a> : thm
<a name="line1025"></a>    val <a href="#IN_OPEN_SEGMENT-val">IN_OPEN_SEGMENT</a> : thm
<a name="line1026"></a>    val <a href="#IN_OPEN_SEGMENT_ALT-val">IN_OPEN_SEGMENT_ALT</a> : thm
<a name="line1027"></a>    val <a href="#IN_SEGMENT-val">IN_SEGMENT</a> : thm
<a name="line1028"></a>    val <a href="#IN_SEGMENT_COMPONENT-val">IN_SEGMENT_COMPONENT</a> : thm
<a name="line1029"></a>    val <a href="#IN_SPAN_DELETE-val">IN_SPAN_DELETE</a> : thm
<a name="line1030"></a>    val <a href="#IN_SPAN_INSERT-val">IN_SPAN_INSERT</a> : thm
<a name="line1031"></a>    val <a href="#IN_SPHERE-val">IN_SPHERE</a> : thm
<a name="line1032"></a>    val <a href="#IN_SPHERE_0-val">IN_SPHERE_0</a> : thm
<a name="line1033"></a>    val <a href="#ISOMETRY_IMP_EMBEDDING-val">ISOMETRY_IMP_EMBEDDING</a> : thm
<a name="line1034"></a>    val <a href="#ISOMETRY_IMP_HOMEOMORPHISM_COMPACT-val">ISOMETRY_IMP_HOMEOMORPHISM_COMPACT</a> : thm
<a name="line1035"></a>    val <a href="#ISOMETRY_IMP_OPEN_MAP-val">ISOMETRY_IMP_OPEN_MAP</a> : thm
<a name="line1036"></a>    val <a href="#ISOMETRY_ON_IMP_CONTINUOUS_ON-val">ISOMETRY_ON_IMP_CONTINUOUS_ON</a> : thm
<a name="line1037"></a>    val <a href="#IS_INTERVAL-val">IS_INTERVAL</a> : thm
<a name="line1038"></a>    val <a href="#IS_INTERVAL_CASES-val">IS_INTERVAL_CASES</a> : thm
<a name="line1039"></a>    val <a href="#IS_INTERVAL_COMPACT-val">IS_INTERVAL_COMPACT</a> : thm
<a name="line1040"></a>    val <a href="#IS_INTERVAL_EMPTY-val">IS_INTERVAL_EMPTY</a> : thm
<a name="line1041"></a>    val <a href="#IS_INTERVAL_IMP_LOCALLY_COMPACT-val">IS_INTERVAL_IMP_LOCALLY_COMPACT</a> : thm
<a name="line1042"></a>    val <a href="#IS_INTERVAL_INTER-val">IS_INTERVAL_INTER</a> : thm
<a name="line1043"></a>    val <a href="#IS_INTERVAL_INTERVAL-val">IS_INTERVAL_INTERVAL</a> : thm
<a name="line1044"></a>    val <a href="#IS_INTERVAL_POINTWISE-val">IS_INTERVAL_POINTWISE</a> : thm
<a name="line1045"></a>    val <a href="#IS_INTERVAL_SCALING-val">IS_INTERVAL_SCALING</a> : thm
<a name="line1046"></a>    val <a href="#IS_INTERVAL_SCALING_EQ-val">IS_INTERVAL_SCALING_EQ</a> : thm
<a name="line1047"></a>    val <a href="#IS_INTERVAL_SING-val">IS_INTERVAL_SING</a> : thm
<a name="line1048"></a>    val <a href="#IS_INTERVAL_SUMS-val">IS_INTERVAL_SUMS</a> : thm
<a name="line1049"></a>    val <a href="#IS_INTERVAL_UNIV-val">IS_INTERVAL_UNIV</a> : thm
<a name="line1050"></a>    val <a href="#JOINABLE_COMPONENTS_EQ-val">JOINABLE_COMPONENTS_EQ</a> : thm
<a name="line1051"></a>    val <a href="#JOINABLE_CONNECTED_COMPONENT_EQ-val">JOINABLE_CONNECTED_COMPONENT_EQ</a> : thm
<a name="line1052"></a>    val <a href="#LEBESGUE_COVERING_LEMMA-val">LEBESGUE_COVERING_LEMMA</a> : thm
<a name="line1053"></a>    val <a href="#LE_1-val">LE_1</a> : thm
<a name="line1054"></a>    val <a href="#LIFT_TO_QUOTIENT_SPACE-val">LIFT_TO_QUOTIENT_SPACE</a> : thm
<a name="line1055"></a>    val <a href="#LIFT_TO_QUOTIENT_SPACE_UNIQUE-val">LIFT_TO_QUOTIENT_SPACE_UNIQUE</a> : thm
<a name="line1056"></a>    val <a href="#LIMIT_POINT_FINITE-val">LIMIT_POINT_FINITE</a> : thm
<a name="line1057"></a>    val <a href="#LIMIT_POINT_UNION-val">LIMIT_POINT_UNION</a> : thm
<a name="line1058"></a>    val <a href="#LIMPT_APPROACHABLE-val">LIMPT_APPROACHABLE</a> : thm
<a name="line1059"></a>    val <a href="#LIMPT_APPROACHABLE_LE-val">LIMPT_APPROACHABLE_LE</a> : thm
<a name="line1060"></a>    val <a href="#LIMPT_BALL-val">LIMPT_BALL</a> : thm
<a name="line1061"></a>    val <a href="#LIMPT_EMPTY-val">LIMPT_EMPTY</a> : thm
<a name="line1062"></a>    val <a href="#LIMPT_INFINITE_BALL-val">LIMPT_INFINITE_BALL</a> : thm
<a name="line1063"></a>    val <a href="#LIMPT_INFINITE_CBALL-val">LIMPT_INFINITE_CBALL</a> : thm
<a name="line1064"></a>    val <a href="#LIMPT_INFINITE_OPEN-val">LIMPT_INFINITE_OPEN</a> : thm
<a name="line1065"></a>    val <a href="#LIMPT_INFINITE_OPEN_BALL_CBALL-val">LIMPT_INFINITE_OPEN_BALL_CBALL</a> : thm
<a name="line1066"></a>    val <a href="#LIMPT_INJECTIVE_LINEAR_IMAGE_EQ-val">LIMPT_INJECTIVE_LINEAR_IMAGE_EQ</a> : thm
<a name="line1067"></a>    val <a href="#LIMPT_INSERT-val">LIMPT_INSERT</a> : thm
<a name="line1068"></a>    val <a href="#LIMPT_OF_CLOSURE-val">LIMPT_OF_CLOSURE</a> : thm
<a name="line1069"></a>    val <a href="#LIMPT_OF_LIMPTS-val">LIMPT_OF_LIMPTS</a> : thm
<a name="line1070"></a>    val <a href="#LIMPT_OF_OPEN-val">LIMPT_OF_OPEN</a> : thm
<a name="line1071"></a>    val <a href="#LIMPT_OF_OPEN_IN-val">LIMPT_OF_OPEN_IN</a> : thm
<a name="line1072"></a>    val <a href="#LIMPT_OF_SEQUENCE_SUBSEQUENCE-val">LIMPT_OF_SEQUENCE_SUBSEQUENCE</a> : thm
<a name="line1073"></a>    val <a href="#LIMPT_OF_UNIV-val">LIMPT_OF_UNIV</a> : thm
<a name="line1074"></a>    val <a href="#LIMPT_SEQUENTIAL-val">LIMPT_SEQUENTIAL</a> : thm
<a name="line1075"></a>    val <a href="#LIMPT_SEQUENTIAL_INJ-val">LIMPT_SEQUENTIAL_INJ</a> : thm
<a name="line1076"></a>    val <a href="#LIMPT_SING-val">LIMPT_SING</a> : thm
<a name="line1077"></a>    val <a href="#LIMPT_SUBSET-val">LIMPT_SUBSET</a> : thm
<a name="line1078"></a>    val <a href="#LIMPT_UNIV-val">LIMPT_UNIV</a> : thm
<a name="line1079"></a>    val <a href="#LIM_ABS-val">LIM_ABS</a> : thm
<a name="line1080"></a>    val <a href="#LIM_ABS_LBOUND-val">LIM_ABS_LBOUND</a> : thm
<a name="line1081"></a>    val <a href="#LIM_ABS_UBOUND-val">LIM_ABS_UBOUND</a> : thm
<a name="line1082"></a>    val <a href="#LIM_ADD-val">LIM_ADD</a> : thm
<a name="line1083"></a>    val <a href="#LIM_AT-val">LIM_AT</a> : thm
<a name="line1084"></a>    val <a href="#LIM_AT_ID-val">LIM_AT_ID</a> : thm
<a name="line1085"></a>    val <a href="#LIM_AT_INFINITY-val">LIM_AT_INFINITY</a> : thm
<a name="line1086"></a>    val <a href="#LIM_AT_INFINITY_POS-val">LIM_AT_INFINITY_POS</a> : thm
<a name="line1087"></a>    val <a href="#LIM_AT_LE-val">LIM_AT_LE</a> : thm
<a name="line1088"></a>    val <a href="#LIM_AT_NEGINFINITY-val">LIM_AT_NEGINFINITY</a> : thm
<a name="line1089"></a>    val <a href="#LIM_AT_POSINFINITY-val">LIM_AT_POSINFINITY</a> : thm
<a name="line1090"></a>    val <a href="#LIM_AT_WITHIN-val">LIM_AT_WITHIN</a> : thm
<a name="line1091"></a>    val <a href="#LIM_AT_ZERO-val">LIM_AT_ZERO</a> : thm
<a name="line1092"></a>    val <a href="#LIM_BILINEAR-val">LIM_BILINEAR</a> : thm
<a name="line1093"></a>    val <a href="#LIM_CASES_COFINITE_SEQUENTIALLY-val">LIM_CASES_COFINITE_SEQUENTIALLY</a> : thm
<a name="line1094"></a>    val <a href="#LIM_CASES_FINITE_SEQUENTIALLY-val">LIM_CASES_FINITE_SEQUENTIALLY</a> : thm
<a name="line1095"></a>    val <a href="#LIM_CASES_SEQUENTIALLY-val">LIM_CASES_SEQUENTIALLY</a> : thm
<a name="line1096"></a>    val <a href="#LIM_CMUL-val">LIM_CMUL</a> : thm
<a name="line1097"></a>    val <a href="#LIM_CMUL_EQ-val">LIM_CMUL_EQ</a> : thm
<a name="line1098"></a>    val <a href="#LIM_COMPONENT-val">LIM_COMPONENT</a> : thm
<a name="line1099"></a>    val <a href="#LIM_COMPONENT_EQ-val">LIM_COMPONENT_EQ</a> : thm
<a name="line1100"></a>    val <a href="#LIM_COMPONENT_LBOUND-val">LIM_COMPONENT_LBOUND</a> : thm
<a name="line1101"></a>    val <a href="#LIM_COMPONENT_LE-val">LIM_COMPONENT_LE</a> : thm
<a name="line1102"></a>    val <a href="#LIM_COMPONENT_UBOUND-val">LIM_COMPONENT_UBOUND</a> : thm
<a name="line1103"></a>    val <a href="#LIM_COMPOSE_AT-val">LIM_COMPOSE_AT</a> : thm
<a name="line1104"></a>    val <a href="#LIM_COMPOSE_WITHIN-val">LIM_COMPOSE_WITHIN</a> : thm
<a name="line1105"></a>    val <a href="#LIM_CONG_AT-val">LIM_CONG_AT</a> : thm
<a name="line1106"></a>    val <a href="#LIM_CONG_WITHIN-val">LIM_CONG_WITHIN</a> : thm
<a name="line1107"></a>    val <a href="#LIM_CONST-val">LIM_CONST</a> : thm
<a name="line1108"></a>    val <a href="#LIM_CONST_EQ-val">LIM_CONST_EQ</a> : thm
<a name="line1109"></a>    val <a href="#LIM_CONTINUOUS_FUNCTION-val">LIM_CONTINUOUS_FUNCTION</a> : thm
<a name="line1110"></a>    val <a href="#LIM_DEF-val">LIM_DEF</a> : thm
<a name="line1111"></a>    val <a href="#LIM_DROP_LBOUND-val">LIM_DROP_LBOUND</a> : thm
<a name="line1112"></a>    val <a href="#LIM_DROP_LE-val">LIM_DROP_LE</a> : thm
<a name="line1113"></a>    val <a href="#LIM_DROP_UBOUND-val">LIM_DROP_UBOUND</a> : thm
<a name="line1114"></a>    val <a href="#LIM_EVENTUALLY-val">LIM_EVENTUALLY</a> : thm
<a name="line1115"></a>    val <a href="#LIM_INFINITY_POSINFINITY-val">LIM_INFINITY_POSINFINITY</a> : thm
<a name="line1116"></a>    val <a href="#LIM_INV-val">LIM_INV</a> : thm
<a name="line1117"></a>    val <a href="#LIM_IN_CLOSED_SET-val">LIM_IN_CLOSED_SET</a> : thm
<a name="line1118"></a>    val <a href="#LIM_LIFT_DOT-val">LIM_LIFT_DOT</a> : thm
<a name="line1119"></a>    val <a href="#LIM_LINEAR-val">LIM_LINEAR</a> : thm
<a name="line1120"></a>    val <a href="#LIM_MAX-val">LIM_MAX</a> : thm
<a name="line1121"></a>    val <a href="#LIM_MIN-val">LIM_MIN</a> : thm
<a name="line1122"></a>    val <a href="#LIM_MUL-val">LIM_MUL</a> : thm
<a name="line1123"></a>    val <a href="#LIM_NEG-val">LIM_NEG</a> : thm
<a name="line1124"></a>    val <a href="#LIM_NEG_EQ-val">LIM_NEG_EQ</a> : thm
<a name="line1125"></a>    val <a href="#LIM_NULL-val">LIM_NULL</a> : thm
<a name="line1126"></a>    val <a href="#LIM_NULL_ABS-val">LIM_NULL_ABS</a> : thm
<a name="line1127"></a>    val <a href="#LIM_NULL_ADD-val">LIM_NULL_ADD</a> : thm
<a name="line1128"></a>    val <a href="#LIM_NULL_CMUL-val">LIM_NULL_CMUL</a> : thm
<a name="line1129"></a>    val <a href="#LIM_NULL_CMUL_BOUNDED-val">LIM_NULL_CMUL_BOUNDED</a> : thm
<a name="line1130"></a>    val <a href="#LIM_NULL_CMUL_EQ-val">LIM_NULL_CMUL_EQ</a> : thm
<a name="line1131"></a>    val <a href="#LIM_NULL_COMPARISON-val">LIM_NULL_COMPARISON</a> : thm
<a name="line1132"></a>    val <a href="#LIM_NULL_SUB-val">LIM_NULL_SUB</a> : thm
<a name="line1133"></a>    val <a href="#LIM_NULL_SUM-val">LIM_NULL_SUM</a> : thm
<a name="line1134"></a>    val <a href="#LIM_POSINFINITY_SEQUENTIALLY-val">LIM_POSINFINITY_SEQUENTIALLY</a> : thm
<a name="line1135"></a>    val <a href="#LIM_SEQUENTIALLY-val">LIM_SEQUENTIALLY</a> : thm
<a name="line1136"></a>    val <a href="#LIM_SUB-val">LIM_SUB</a> : thm
<a name="line1137"></a>    val <a href="#LIM_SUBSEQUENCE-val">LIM_SUBSEQUENCE</a> : thm
<a name="line1138"></a>    val <a href="#LIM_SUBSEQUENCE_WEAK-val">LIM_SUBSEQUENCE_WEAK</a> : thm
<a name="line1139"></a>    val <a href="#LIM_SUM-val">LIM_SUM</a> : thm
<a name="line1140"></a>    val <a href="#LIM_TRANSFORM-val">LIM_TRANSFORM</a> : thm
<a name="line1141"></a>    val <a href="#LIM_TRANSFORM_AT-val">LIM_TRANSFORM_AT</a> : thm
<a name="line1142"></a>    val <a href="#LIM_TRANSFORM_AWAY_AT-val">LIM_TRANSFORM_AWAY_AT</a> : thm
<a name="line1143"></a>    val <a href="#LIM_TRANSFORM_AWAY_WITHIN-val">LIM_TRANSFORM_AWAY_WITHIN</a> : thm
<a name="line1144"></a>    val <a href="#LIM_TRANSFORM_BOUND-val">LIM_TRANSFORM_BOUND</a> : thm
<a name="line1145"></a>    val <a href="#LIM_TRANSFORM_EQ-val">LIM_TRANSFORM_EQ</a> : thm
<a name="line1146"></a>    val <a href="#LIM_TRANSFORM_EVENTUALLY-val">LIM_TRANSFORM_EVENTUALLY</a> : thm
<a name="line1147"></a>    val <a href="#LIM_TRANSFORM_WITHIN-val">LIM_TRANSFORM_WITHIN</a> : thm
<a name="line1148"></a>    val <a href="#LIM_TRANSFORM_WITHIN_OPEN-val">LIM_TRANSFORM_WITHIN_OPEN</a> : thm
<a name="line1149"></a>    val <a href="#LIM_TRANSFORM_WITHIN_OPEN_IN-val">LIM_TRANSFORM_WITHIN_OPEN_IN</a> : thm
<a name="line1150"></a>    val <a href="#LIM_TRANSFORM_WITHIN_SET-val">LIM_TRANSFORM_WITHIN_SET</a> : thm
<a name="line1151"></a>    val <a href="#LIM_TRANSFORM_WITHIN_SET_IMP-val">LIM_TRANSFORM_WITHIN_SET_IMP</a> : thm
<a name="line1152"></a>    val <a href="#LIM_UNION-val">LIM_UNION</a> : thm
<a name="line1153"></a>    val <a href="#LIM_UNION_UNIV-val">LIM_UNION_UNIV</a> : thm
<a name="line1154"></a>    val <a href="#LIM_UNIQUE-val">LIM_UNIQUE</a> : thm
<a name="line1155"></a>    val <a href="#LIM_VMUL-val">LIM_VMUL</a> : thm
<a name="line1156"></a>    val <a href="#LIM_WITHIN-val">LIM_WITHIN</a> : thm
<a name="line1157"></a>    val <a href="#LIM_WITHIN_CLOSED_TRIVIAL-val">LIM_WITHIN_CLOSED_TRIVIAL</a> : thm
<a name="line1158"></a>    val <a href="#LIM_WITHIN_EMPTY-val">LIM_WITHIN_EMPTY</a> : thm
<a name="line1159"></a>    val <a href="#LIM_WITHIN_ID-val">LIM_WITHIN_ID</a> : thm
<a name="line1160"></a>    val <a href="#LIM_WITHIN_INTERIOR-val">LIM_WITHIN_INTERIOR</a> : thm
<a name="line1161"></a>    val <a href="#LIM_WITHIN_LE-val">LIM_WITHIN_LE</a> : thm
<a name="line1162"></a>    val <a href="#LIM_WITHIN_OPEN-val">LIM_WITHIN_OPEN</a> : thm
<a name="line1163"></a>    val <a href="#LIM_WITHIN_SUBSET-val">LIM_WITHIN_SUBSET</a> : thm
<a name="line1164"></a>    val <a href="#LIM_WITHIN_UNION-val">LIM_WITHIN_UNION</a> : thm
<a name="line1165"></a>    val <a href="#LINEAR_0-val">LINEAR_0</a> : thm
<a name="line1166"></a>    val <a href="#LINEAR_ADD-val">LINEAR_ADD</a> : thm
<a name="line1167"></a>    val <a href="#LINEAR_BOUNDED-val">LINEAR_BOUNDED</a> : thm
<a name="line1168"></a>    val <a href="#LINEAR_BOUNDED_POS-val">LINEAR_BOUNDED_POS</a> : thm
<a name="line1169"></a>    val <a href="#LINEAR_CMUL-val">LINEAR_CMUL</a> : thm
<a name="line1170"></a>    val <a href="#LINEAR_COMPOSE-val">LINEAR_COMPOSE</a> : thm
<a name="line1171"></a>    val <a href="#LINEAR_COMPOSE_ADD-val">LINEAR_COMPOSE_ADD</a> : thm
<a name="line1172"></a>    val <a href="#LINEAR_COMPOSE_CMUL-val">LINEAR_COMPOSE_CMUL</a> : thm
<a name="line1173"></a>    val <a href="#LINEAR_COMPOSE_NEG-val">LINEAR_COMPOSE_NEG</a> : thm
<a name="line1174"></a>    val <a href="#LINEAR_COMPOSE_SUB-val">LINEAR_COMPOSE_SUB</a> : thm
<a name="line1175"></a>    val <a href="#LINEAR_COMPOSE_SUM-val">LINEAR_COMPOSE_SUM</a> : thm
<a name="line1176"></a>    val <a href="#LINEAR_CONTINUOUS_AT-val">LINEAR_CONTINUOUS_AT</a> : thm
<a name="line1177"></a>    val <a href="#LINEAR_CONTINUOUS_COMPOSE-val">LINEAR_CONTINUOUS_COMPOSE</a> : thm
<a name="line1178"></a>    val <a href="#LINEAR_CONTINUOUS_ON-val">LINEAR_CONTINUOUS_ON</a> : thm
<a name="line1179"></a>    val <a href="#LINEAR_CONTINUOUS_ON_COMPOSE-val">LINEAR_CONTINUOUS_ON_COMPOSE</a> : thm
<a name="line1180"></a>    val <a href="#LINEAR_CONTINUOUS_WITHIN-val">LINEAR_CONTINUOUS_WITHIN</a> : thm
<a name="line1181"></a>    val <a href="#LINEAR_EQ-val">LINEAR_EQ</a> : thm
<a name="line1182"></a>    val <a href="#LINEAR_EQ_0-val">LINEAR_EQ_0</a> : thm
<a name="line1183"></a>    val <a href="#LINEAR_EQ_0_SPAN-val">LINEAR_EQ_0_SPAN</a> : thm
<a name="line1184"></a>    val <a href="#LINEAR_EQ_STDBASIS-val">LINEAR_EQ_STDBASIS</a> : thm
<a name="line1185"></a>    val <a href="#LINEAR_ID-val">LINEAR_ID</a> : thm
<a name="line1186"></a>    val <a href="#LINEAR_IMAGE_SUBSET_INTERIOR-val">LINEAR_IMAGE_SUBSET_INTERIOR</a> : thm
<a name="line1187"></a>    val <a href="#LINEAR_INDEPENDENT_EXTEND-val">LINEAR_INDEPENDENT_EXTEND</a> : thm
<a name="line1188"></a>    val <a href="#LINEAR_INDEPENDENT_EXTEND_LEMMA-val">LINEAR_INDEPENDENT_EXTEND_LEMMA</a> : thm
<a name="line1189"></a>    val <a href="#LINEAR_INJECTIVE_0_SUBSPACE-val">LINEAR_INJECTIVE_0_SUBSPACE</a> : thm
<a name="line1190"></a>    val <a href="#LINEAR_INJECTIVE_BOUNDED_BELOW_POS-val">LINEAR_INJECTIVE_BOUNDED_BELOW_POS</a> : thm
<a name="line1191"></a>    val <a href="#LINEAR_INJECTIVE_IMP_SURJECTIVE-val">LINEAR_INJECTIVE_IMP_SURJECTIVE</a> : thm
<a name="line1192"></a>    val <a href="#LINEAR_INJECTIVE_LEFT_INVERSE-val">LINEAR_INJECTIVE_LEFT_INVERSE</a> : thm
<a name="line1193"></a>    val <a href="#LINEAR_INTERIOR_IMAGE_SUBSET-val">LINEAR_INTERIOR_IMAGE_SUBSET</a> : thm
<a name="line1194"></a>    val <a href="#LINEAR_INVERTIBLE_BOUNDED_BELOW-val">LINEAR_INVERTIBLE_BOUNDED_BELOW</a> : thm
<a name="line1195"></a>    val <a href="#LINEAR_INVERTIBLE_BOUNDED_BELOW_POS-val">LINEAR_INVERTIBLE_BOUNDED_BELOW_POS</a> : thm
<a name="line1196"></a>    val <a href="#LINEAR_LIM_0-val">LINEAR_LIM_0</a> : thm
<a name="line1197"></a>    val <a href="#LINEAR_MUL_COMPONENT-val">LINEAR_MUL_COMPONENT</a> : thm
<a name="line1198"></a>    val <a href="#LINEAR_NEG-val">LINEAR_NEG</a> : thm
<a name="line1199"></a>    val <a href="#LINEAR_NEGATION-val">LINEAR_NEGATION</a> : thm
<a name="line1200"></a>    val <a href="#LINEAR_OPEN_MAPPING-val">LINEAR_OPEN_MAPPING</a> : thm
<a name="line1201"></a>    val <a href="#LINEAR_SCALING-val">LINEAR_SCALING</a> : thm
<a name="line1202"></a>    val <a href="#LINEAR_SUB-val">LINEAR_SUB</a> : thm
<a name="line1203"></a>    val <a href="#LINEAR_SUM-val">LINEAR_SUM</a> : thm
<a name="line1204"></a>    val <a href="#LINEAR_SUM_MUL-val">LINEAR_SUM_MUL</a> : thm
<a name="line1205"></a>    val <a href="#LINEAR_UNIFORMLY_CONTINUOUS_ON-val">LINEAR_UNIFORMLY_CONTINUOUS_ON</a> : thm
<a name="line1206"></a>    val <a href="#LINEAR_ZERO-val">LINEAR_ZERO</a> : thm
<a name="line1207"></a>    val <a href="#LOCALLY_CLOSED-val">LOCALLY_CLOSED</a> : thm
<a name="line1208"></a>    val <a href="#LOCALLY_COMPACT-val">LOCALLY_COMPACT</a> : thm
<a name="line1209"></a>    val <a href="#LOCALLY_COMPACT_ALT-val">LOCALLY_COMPACT_ALT</a> : thm
<a name="line1210"></a>    val <a href="#LOCALLY_COMPACT_CLOSED_IN-val">LOCALLY_COMPACT_CLOSED_IN</a> : thm
<a name="line1211"></a>    val <a href="#LOCALLY_COMPACT_CLOSED_INTER_OPEN-val">LOCALLY_COMPACT_CLOSED_INTER_OPEN</a> : thm
<a name="line1212"></a>    val <a href="#LOCALLY_COMPACT_CLOSED_IN_OPEN-val">LOCALLY_COMPACT_CLOSED_IN_OPEN</a> : thm
<a name="line1213"></a>    val <a href="#LOCALLY_COMPACT_CLOSED_UNION-val">LOCALLY_COMPACT_CLOSED_UNION</a> : thm
<a name="line1214"></a>    val <a href="#LOCALLY_COMPACT_COMPACT-val">LOCALLY_COMPACT_COMPACT</a> : thm
<a name="line1215"></a>    val <a href="#LOCALLY_COMPACT_COMPACT_ALT-val">LOCALLY_COMPACT_COMPACT_ALT</a> : thm
<a name="line1216"></a>    val <a href="#LOCALLY_COMPACT_COMPACT_SUBOPEN-val">LOCALLY_COMPACT_COMPACT_SUBOPEN</a> : thm
<a name="line1217"></a>    val <a href="#LOCALLY_COMPACT_DELETE-val">LOCALLY_COMPACT_DELETE</a> : thm
<a name="line1218"></a>    val <a href="#LOCALLY_COMPACT_INTER-val">LOCALLY_COMPACT_INTER</a> : thm
<a name="line1219"></a>    val <a href="#LOCALLY_COMPACT_INTER_CBALL-val">LOCALLY_COMPACT_INTER_CBALL</a> : thm
<a name="line1220"></a>    val <a href="#LOCALLY_COMPACT_INTER_CBALLS-val">LOCALLY_COMPACT_INTER_CBALLS</a> : thm
<a name="line1221"></a>    val <a href="#LOCALLY_COMPACT_OPEN_IN-val">LOCALLY_COMPACT_OPEN_IN</a> : thm
<a name="line1222"></a>    val <a href="#LOCALLY_COMPACT_OPEN_INTER_CLOSURE-val">LOCALLY_COMPACT_OPEN_INTER_CLOSURE</a> : thm
<a name="line1223"></a>    val <a href="#LOCALLY_COMPACT_OPEN_UNION-val">LOCALLY_COMPACT_OPEN_UNION</a> : thm
<a name="line1224"></a>    val <a href="#LOCALLY_COMPACT_PROPER_IMAGE-val">LOCALLY_COMPACT_PROPER_IMAGE</a> : thm
<a name="line1225"></a>    val <a href="#LOCALLY_COMPACT_PROPER_IMAGE_EQ-val">LOCALLY_COMPACT_PROPER_IMAGE_EQ</a> : thm
<a name="line1226"></a>    val <a href="#LOCALLY_COMPACT_TRANSLATION_EQ-val">LOCALLY_COMPACT_TRANSLATION_EQ</a> : thm
<a name="line1227"></a>    val <a href="#LOCALLY_COMPACT_UNIV-val">LOCALLY_COMPACT_UNIV</a> : thm
<a name="line1228"></a>    val <a href="#LOCALLY_DIFF_CLOSED-val">LOCALLY_DIFF_CLOSED</a> : thm
<a name="line1229"></a>    val <a href="#LOCALLY_EMPTY-val">LOCALLY_EMPTY</a> : thm
<a name="line1230"></a>    val <a href="#LOCALLY_INJECTIVE_LINEAR_IMAGE-val">LOCALLY_INJECTIVE_LINEAR_IMAGE</a> : thm
<a name="line1231"></a>    val <a href="#LOCALLY_INTER-val">LOCALLY_INTER</a> : thm
<a name="line1232"></a>    val <a href="#LOCALLY_MONO-val">LOCALLY_MONO</a> : thm
<a name="line1233"></a>    val <a href="#LOCALLY_OPEN_MAP_IMAGE-val">LOCALLY_OPEN_MAP_IMAGE</a> : thm
<a name="line1234"></a>    val <a href="#LOCALLY_OPEN_SUBSET-val">LOCALLY_OPEN_SUBSET</a> : thm
<a name="line1235"></a>    val <a href="#LOCALLY_SING-val">LOCALLY_SING</a> : thm
<a name="line1236"></a>    val <a href="#LOCALLY_TRANSLATION-val">LOCALLY_TRANSLATION</a> : thm
<a name="line1237"></a>    val <a href="#LOWER_HEMICONTINUOUS-val">LOWER_HEMICONTINUOUS</a> : thm
<a name="line1238"></a>    val <a href="#MAPPING_CONNECTED_ONTO_SEGMENT-val">MAPPING_CONNECTED_ONTO_SEGMENT</a> : thm
<a name="line1239"></a>    val <a href="#MAXIMAL_INDEPENDENT_SUBSET-val">MAXIMAL_INDEPENDENT_SUBSET</a> : thm
<a name="line1240"></a>    val <a href="#MAXIMAL_INDEPENDENT_SUBSET_EXTEND-val">MAXIMAL_INDEPENDENT_SUBSET_EXTEND</a> : thm
<a name="line1241"></a>    val <a href="#METRIZABLE_SPACE_EUCLIDEAN-val">METRIZABLE_SPACE_EUCLIDEAN</a> : thm
<a name="line1242"></a>    val <a href="#MIDPOINT_COLLINEAR-val">MIDPOINT_COLLINEAR</a> : thm
<a name="line1243"></a>    val <a href="#MIDPOINT_EQ_ENDPOINT-val">MIDPOINT_EQ_ENDPOINT</a> : thm
<a name="line1244"></a>    val <a href="#MIDPOINT_IN_SEGMENT-val">MIDPOINT_IN_SEGMENT</a> : thm
<a name="line1245"></a>    val <a href="#MIDPOINT_LINEAR_IMAGE-val">MIDPOINT_LINEAR_IMAGE</a> : thm
<a name="line1246"></a>    val <a href="#MIDPOINT_REFL-val">MIDPOINT_REFL</a> : thm
<a name="line1247"></a>    val <a href="#MIDPOINT_SYM-val">MIDPOINT_SYM</a> : thm
<a name="line1248"></a>    val <a href="#MONOTONE_BIGGER-val">MONOTONE_BIGGER</a> : thm
<a name="line1249"></a>    val <a href="#MONOTONE_SUBSEQUENCE-val">MONOTONE_SUBSEQUENCE</a> : thm
<a name="line1250"></a>    val <a href="#MUL_CAUCHY_SCHWARZ_EQUAL-val">MUL_CAUCHY_SCHWARZ_EQUAL</a> : thm
<a name="line1251"></a>    val <a href="#MUMFORD_LEMMA-val">MUMFORD_LEMMA</a> : thm
<a name="line1252"></a>    val <a href="#NEGATIONS_BALL-val">NEGATIONS_BALL</a> : thm
<a name="line1253"></a>    val <a href="#NEGATIONS_CBALL-val">NEGATIONS_CBALL</a> : thm
<a name="line1254"></a>    val <a href="#NEGATIONS_SPHERE-val">NEGATIONS_SPHERE</a> : thm
<a name="line1255"></a>    val <a href="#NET-val">NET</a> : thm
<a name="line1256"></a>    val <a href="#NETLIMIT_AT-val">NETLIMIT_AT</a> : thm
<a name="line1257"></a>    val <a href="#NETLIMIT_WITHIN-val">NETLIMIT_WITHIN</a> : thm
<a name="line1258"></a>    val <a href="#NETLIMIT_WITHIN_INTERIOR-val">NETLIMIT_WITHIN_INTERIOR</a> : thm
<a name="line1259"></a>    val <a href="#NET_DILEMMA-val">NET_DILEMMA</a> : thm
<a name="line1260"></a>    val <a href="#NONTRIVIAL_LIMIT_WITHIN-val">NONTRIVIAL_LIMIT_WITHIN</a> : thm
<a name="line1261"></a>    val <a href="#NOT_BOUNDED_UNIV-val">NOT_BOUNDED_UNIV</a> : thm
<a name="line1262"></a>    val <a href="#NOT_EVENTUALLY-val">NOT_EVENTUALLY</a> : thm
<a name="line1263"></a>    val <a href="#NOT_INTERVAL_UNIV-val">NOT_INTERVAL_UNIV</a> : thm
<a name="line1264"></a>    val <a href="#NOWHERE_DENSE-val">NOWHERE_DENSE</a> : thm
<a name="line1265"></a>    val <a href="#NOWHERE_DENSE_COUNTABLE_BIGUNION-val">NOWHERE_DENSE_COUNTABLE_BIGUNION</a> : thm
<a name="line1266"></a>    val <a href="#NOWHERE_DENSE_COUNTABLE_BIGUNION_CLOSED-val">NOWHERE_DENSE_COUNTABLE_BIGUNION_CLOSED</a> : thm
<a name="line1267"></a>    val <a href="#NOWHERE_DENSE_UNION-val">NOWHERE_DENSE_UNION</a> : thm
<a name="line1268"></a>    val <a href="#NO_LIMIT_POINT_IMP_CLOSED-val">NO_LIMIT_POINT_IMP_CLOSED</a> : thm
<a name="line1269"></a>    val <a href="#OLDNET-val">OLDNET</a> : thm
<a name="line1270"></a>    val <a href="#OPEN-val">OPEN</a> : thm
<a name="line1271"></a>    val <a href="#OPEN_AFFINITY-val">OPEN_AFFINITY</a> : thm
<a name="line1272"></a>    val <a href="#OPEN_BALL-val">OPEN_BALL</a> : thm
<a name="line1273"></a>    val <a href="#OPEN_BIGINTER-val">OPEN_BIGINTER</a> : thm
<a name="line1274"></a>    val <a href="#OPEN_BIGUNION-val">OPEN_BIGUNION</a> : thm
<a name="line1275"></a>    val <a href="#OPEN_BIJECTIVE_LINEAR_IMAGE_EQ-val">OPEN_BIJECTIVE_LINEAR_IMAGE_EQ</a> : thm
<a name="line1276"></a>    val <a href="#OPEN_CLOSED-val">OPEN_CLOSED</a> : thm
<a name="line1277"></a>    val <a href="#OPEN_CLOSED_INTERVAL-val">OPEN_CLOSED_INTERVAL</a> : thm
<a name="line1278"></a>    val <a href="#OPEN_CLOSED_INTERVAL_CONVEX-val">OPEN_CLOSED_INTERVAL_CONVEX</a> : thm
<a name="line1279"></a>    val <a href="#OPEN_CONTAINS_BALL-val">OPEN_CONTAINS_BALL</a> : thm
<a name="line1280"></a>    val <a href="#OPEN_CONTAINS_BALL_EQ-val">OPEN_CONTAINS_BALL_EQ</a> : thm
<a name="line1281"></a>    val <a href="#OPEN_CONTAINS_CBALL-val">OPEN_CONTAINS_CBALL</a> : thm
<a name="line1282"></a>    val <a href="#OPEN_CONTAINS_CBALL_EQ-val">OPEN_CONTAINS_CBALL_EQ</a> : thm
<a name="line1283"></a>    val <a href="#OPEN_CONTAINS_INTERVAL-val">OPEN_CONTAINS_INTERVAL</a> : thm
<a name="line1284"></a>    val <a href="#OPEN_CONTAINS_INTERVAL_OPEN_INTERVAL-val">OPEN_CONTAINS_INTERVAL_OPEN_INTERVAL</a> : thm
<a name="line1285"></a>    val <a href="#OPEN_CONTAINS_OPEN_INTERVAL-val">OPEN_CONTAINS_OPEN_INTERVAL</a> : thm
<a name="line1286"></a>    val <a href="#OPEN_DELETE-val">OPEN_DELETE</a> : thm
<a name="line1287"></a>    val <a href="#OPEN_DIFF-val">OPEN_DIFF</a> : thm
<a name="line1288"></a>    val <a href="#OPEN_EMPTY-val">OPEN_EMPTY</a> : thm
<a name="line1289"></a>    val <a href="#OPEN_EXISTS-val">OPEN_EXISTS</a> : thm
<a name="line1290"></a>    val <a href="#OPEN_EXISTS_IN-val">OPEN_EXISTS_IN</a> : thm
<a name="line1291"></a>    val <a href="#OPEN_HALFSPACE_COMPONENT_GT-val">OPEN_HALFSPACE_COMPONENT_GT</a> : thm
<a name="line1292"></a>    val <a href="#OPEN_HALFSPACE_COMPONENT_LT-val">OPEN_HALFSPACE_COMPONENT_LT</a> : thm
<a name="line1293"></a>    val <a href="#OPEN_HALFSPACE_GT-val">OPEN_HALFSPACE_GT</a> : thm
<a name="line1294"></a>    val <a href="#OPEN_HALFSPACE_LT-val">OPEN_HALFSPACE_LT</a> : thm
<a name="line1295"></a>    val <a href="#OPEN_IMP_INFINITE-val">OPEN_IMP_INFINITE</a> : thm
<a name="line1296"></a>    val <a href="#OPEN_IMP_LOCALLY_COMPACT-val">OPEN_IMP_LOCALLY_COMPACT</a> : thm
<a name="line1297"></a>    val <a href="#OPEN_IN-val">OPEN_IN</a> : thm
<a name="line1298"></a>    val <a href="#OPEN_INTER-val">OPEN_INTER</a> : thm
<a name="line1299"></a>    val <a href="#OPEN_INTERIOR-val">OPEN_INTERIOR</a> : thm
<a name="line1300"></a>    val <a href="#OPEN_INTERVAL-val">OPEN_INTERVAL</a> : thm
<a name="line1301"></a>    val <a href="#OPEN_INTERVAL_EQ-val">OPEN_INTERVAL_EQ</a> : thm
<a name="line1302"></a>    val <a href="#OPEN_INTERVAL_LEFT-val">OPEN_INTERVAL_LEFT</a> : thm
<a name="line1303"></a>    val <a href="#OPEN_INTERVAL_LEMMA-val">OPEN_INTERVAL_LEMMA</a> : thm
<a name="line1304"></a>    val <a href="#OPEN_INTERVAL_LOWERBOUND-val">OPEN_INTERVAL_LOWERBOUND</a> : thm
<a name="line1305"></a>    val <a href="#OPEN_INTERVAL_MIDPOINT-val">OPEN_INTERVAL_MIDPOINT</a> : thm
<a name="line1306"></a>    val <a href="#OPEN_INTERVAL_RIGHT-val">OPEN_INTERVAL_RIGHT</a> : thm
<a name="line1307"></a>    val <a href="#OPEN_INTERVAL_UPPERBOUND-val">OPEN_INTERVAL_UPPERBOUND</a> : thm
<a name="line1308"></a>    val <a href="#OPEN_INTER_CLOSURE_EQ_EMPTY-val">OPEN_INTER_CLOSURE_EQ_EMPTY</a> : thm
<a name="line1309"></a>    val <a href="#OPEN_INTER_CLOSURE_SUBSET-val">OPEN_INTER_CLOSURE_SUBSET</a> : thm
<a name="line1310"></a>    val <a href="#OPEN_IN_CONNECTED_COMPONENT-val">OPEN_IN_CONNECTED_COMPONENT</a> : thm
<a name="line1311"></a>    val <a href="#OPEN_IN_CONTAINS_BALL-val">OPEN_IN_CONTAINS_BALL</a> : thm
<a name="line1312"></a>    val <a href="#OPEN_IN_CONTAINS_CBALL-val">OPEN_IN_CONTAINS_CBALL</a> : thm
<a name="line1313"></a>    val <a href="#OPEN_IN_DELETE-val">OPEN_IN_DELETE</a> : thm
<a name="line1314"></a>    val <a href="#OPEN_IN_INTER_OPEN-val">OPEN_IN_INTER_OPEN</a> : thm
<a name="line1315"></a>    val <a href="#OPEN_IN_LOCALLY_COMPACT-val">OPEN_IN_LOCALLY_COMPACT</a> : thm
<a name="line1316"></a>    val <a href="#OPEN_IN_OPEN-val">OPEN_IN_OPEN</a> : thm
<a name="line1317"></a>    val <a href="#OPEN_IN_OPEN_EQ-val">OPEN_IN_OPEN_EQ</a> : thm
<a name="line1318"></a>    val <a href="#OPEN_IN_OPEN_INTER-val">OPEN_IN_OPEN_INTER</a> : thm
<a name="line1319"></a>    val <a href="#OPEN_IN_OPEN_TRANS-val">OPEN_IN_OPEN_TRANS</a> : thm
<a name="line1320"></a>    val <a href="#OPEN_IN_REFL-val">OPEN_IN_REFL</a> : thm
<a name="line1321"></a>    val <a href="#OPEN_IN_SING-val">OPEN_IN_SING</a> : thm
<a name="line1322"></a>    val <a href="#OPEN_IN_SUBSET_TRANS-val">OPEN_IN_SUBSET_TRANS</a> : thm
<a name="line1323"></a>    val <a href="#OPEN_IN_SUBTOPOLOGY_INTER_SUBSET-val">OPEN_IN_SUBTOPOLOGY_INTER_SUBSET</a> : thm
<a name="line1324"></a>    val <a href="#OPEN_IN_TRANS-val">OPEN_IN_TRANS</a> : thm
<a name="line1325"></a>    val <a href="#OPEN_IN_TRANS_EQ-val">OPEN_IN_TRANS_EQ</a> : thm
<a name="line1326"></a>    val <a href="#OPEN_MAP_CLOSED_SUPERSET_PREIMAGE-val">OPEN_MAP_CLOSED_SUPERSET_PREIMAGE</a> : thm
<a name="line1327"></a>    val <a href="#OPEN_MAP_CLOSED_SUPERSET_PREIMAGE_EQ-val">OPEN_MAP_CLOSED_SUPERSET_PREIMAGE_EQ</a> : thm
<a name="line1328"></a>    val <a href="#OPEN_MAP_FROM_COMPOSITION_INJECTIVE-val">OPEN_MAP_FROM_COMPOSITION_INJECTIVE</a> : thm
<a name="line1329"></a>    val <a href="#OPEN_MAP_FROM_COMPOSITION_SURJECTIVE-val">OPEN_MAP_FROM_COMPOSITION_SURJECTIVE</a> : thm
<a name="line1330"></a>    val <a href="#OPEN_MAP_IFF_LOWER_HEMICONTINUOUS_PREIMAGE-val">OPEN_MAP_IFF_LOWER_HEMICONTINUOUS_PREIMAGE</a> : thm
<a name="line1331"></a>    val <a href="#OPEN_MAP_IMP_CLOSED_MAP-val">OPEN_MAP_IMP_CLOSED_MAP</a> : thm
<a name="line1332"></a>    val <a href="#OPEN_MAP_IMP_QUOTIENT_MAP-val">OPEN_MAP_IMP_QUOTIENT_MAP</a> : thm
<a name="line1333"></a>    val <a href="#OPEN_MAP_INTERIORS-val">OPEN_MAP_INTERIORS</a> : thm
<a name="line1334"></a>    val <a href="#OPEN_MAP_RESTRICT-val">OPEN_MAP_RESTRICT</a> : thm
<a name="line1335"></a>    val <a href="#OPEN_NEGATIONS-val">OPEN_NEGATIONS</a> : thm
<a name="line1336"></a>    val <a href="#OPEN_OPEN_IN_TRANS-val">OPEN_OPEN_IN_TRANS</a> : thm
<a name="line1337"></a>    val <a href="#OPEN_POSITIVE_MULTIPLES-val">OPEN_POSITIVE_MULTIPLES</a> : thm
<a name="line1338"></a>    val <a href="#OPEN_POSITIVE_ORTHANT-val">OPEN_POSITIVE_ORTHANT</a> : thm
<a name="line1339"></a>    val <a href="#OPEN_SCALING-val">OPEN_SCALING</a> : thm
<a name="line1340"></a>    val <a href="#OPEN_SEGMENT-val">OPEN_SEGMENT</a> : thm
<a name="line1341"></a>    val <a href="#OPEN_SEGMENT_ALT-val">OPEN_SEGMENT_ALT</a> : thm
<a name="line1342"></a>    val <a href="#OPEN_SEGMENT_LINEAR_IMAGE-val">OPEN_SEGMENT_LINEAR_IMAGE</a> : thm
<a name="line1343"></a>    val <a href="#OPEN_SUBSET-val">OPEN_SUBSET</a> : thm
<a name="line1344"></a>    val <a href="#OPEN_SUBSET_INTERIOR-val">OPEN_SUBSET_INTERIOR</a> : thm
<a name="line1345"></a>    val <a href="#OPEN_SUB_OPEN-val">OPEN_SUB_OPEN</a> : thm
<a name="line1346"></a>    val <a href="#OPEN_SUMS-val">OPEN_SUMS</a> : thm
<a name="line1347"></a>    val <a href="#OPEN_SURJECTIVE_LINEAR_IMAGE-val">OPEN_SURJECTIVE_LINEAR_IMAGE</a> : thm
<a name="line1348"></a>    val <a href="#OPEN_TRANSLATION-val">OPEN_TRANSLATION</a> : thm
<a name="line1349"></a>    val <a href="#OPEN_TRANSLATION_EQ-val">OPEN_TRANSLATION_EQ</a> : thm
<a name="line1350"></a>    val <a href="#OPEN_UNION-val">OPEN_UNION</a> : thm
<a name="line1351"></a>    val <a href="#OPEN_UNION_COMPACT_SUBSETS-val">OPEN_UNION_COMPACT_SUBSETS</a> : thm
<a name="line1352"></a>    val <a href="#OPEN_UNIV-val">OPEN_UNIV</a> : thm
<a name="line1353"></a>    val <a href="#PAIRWISE_DISJOINT_COMPONENTS-val">PAIRWISE_DISJOINT_COMPONENTS</a> : thm
<a name="line1354"></a>    val <a href="#PARTIAL_SUMS_COMPONENT_LE_INFSUM-val">PARTIAL_SUMS_COMPONENT_LE_INFSUM</a> : thm
<a name="line1355"></a>    val <a href="#PARTIAL_SUMS_DROP_LE_INFSUM-val">PARTIAL_SUMS_DROP_LE_INFSUM</a> : thm
<a name="line1356"></a>    val <a href="#PASTING_LEMMA-val">PASTING_LEMMA</a> : thm
<a name="line1357"></a>    val <a href="#PASTING_LEMMA_CLOSED-val">PASTING_LEMMA_CLOSED</a> : thm
<a name="line1358"></a>    val <a href="#PASTING_LEMMA_EXISTS-val">PASTING_LEMMA_EXISTS</a> : thm
<a name="line1359"></a>    val <a href="#PASTING_LEMMA_EXISTS_CLOSED-val">PASTING_LEMMA_EXISTS_CLOSED</a> : thm
<a name="line1360"></a>    val <a href="#PROPER_MAP-val">PROPER_MAP</a> : thm
<a name="line1361"></a>    val <a href="#PROPER_MAP_COMPOSE-val">PROPER_MAP_COMPOSE</a> : thm
<a name="line1362"></a>    val <a href="#PROPER_MAP_FROM_COMPACT-val">PROPER_MAP_FROM_COMPACT</a> : thm
<a name="line1363"></a>    val <a href="#PROPER_MAP_FROM_COMPOSITION_LEFT-val">PROPER_MAP_FROM_COMPOSITION_LEFT</a> : thm
<a name="line1364"></a>    val <a href="#PROPER_MAP_FROM_COMPOSITION_RIGHT-val">PROPER_MAP_FROM_COMPOSITION_RIGHT</a> : thm
<a name="line1365"></a>    val <a href="#QUASICOMPACT_OPEN_CLOSED-val">QUASICOMPACT_OPEN_CLOSED</a> : thm
<a name="line1366"></a>    val <a href="#QUOTIENT_MAP_CLOSED_MAP_EQ-val">QUOTIENT_MAP_CLOSED_MAP_EQ</a> : thm
<a name="line1367"></a>    val <a href="#QUOTIENT_MAP_COMPOSE-val">QUOTIENT_MAP_COMPOSE</a> : thm
<a name="line1368"></a>    val <a href="#QUOTIENT_MAP_FROM_COMPOSITION-val">QUOTIENT_MAP_FROM_COMPOSITION</a> : thm
<a name="line1369"></a>    val <a href="#QUOTIENT_MAP_FROM_SUBSET-val">QUOTIENT_MAP_FROM_SUBSET</a> : thm
<a name="line1370"></a>    val <a href="#QUOTIENT_MAP_IMP_CONTINUOUS_CLOSED-val">QUOTIENT_MAP_IMP_CONTINUOUS_CLOSED</a> : thm
<a name="line1371"></a>    val <a href="#QUOTIENT_MAP_IMP_CONTINUOUS_OPEN-val">QUOTIENT_MAP_IMP_CONTINUOUS_OPEN</a> : thm
<a name="line1372"></a>    val <a href="#QUOTIENT_MAP_OPEN_CLOSED-val">QUOTIENT_MAP_OPEN_CLOSED</a> : thm
<a name="line1373"></a>    val <a href="#QUOTIENT_MAP_OPEN_MAP_EQ-val">QUOTIENT_MAP_OPEN_MAP_EQ</a> : thm
<a name="line1374"></a>    val <a href="#QUOTIENT_MAP_RESTRICT-val">QUOTIENT_MAP_RESTRICT</a> : thm
<a name="line1375"></a>    val <a href="#REAL_AFFINITY_EQ-val">REAL_AFFINITY_EQ</a> : thm
<a name="line1376"></a>    val <a href="#REAL_AFFINITY_LE-val">REAL_AFFINITY_LE</a> : thm
<a name="line1377"></a>    val <a href="#REAL_AFFINITY_LT-val">REAL_AFFINITY_LT</a> : thm
<a name="line1378"></a>    val <a href="#REAL_ARCH_RDIV_EQ_0-val">REAL_ARCH_RDIV_EQ_0</a> : thm
<a name="line1379"></a>    val <a href="#REAL_CHOOSE_DIST-val">REAL_CHOOSE_DIST</a> : thm
<a name="line1380"></a>    val <a href="#REAL_CHOOSE_SIZE-val">REAL_CHOOSE_SIZE</a> : thm
<a name="line1381"></a>    val <a href="#REAL_CONVEX_BOUND_LE-val">REAL_CONVEX_BOUND_LE</a> : thm
<a name="line1382"></a>    val <a href="#REAL_EQ_AFFINITY-val">REAL_EQ_AFFINITY</a> : thm
<a name="line1383"></a>    val <a href="#REAL_EQ_LINV-val">REAL_EQ_LINV</a> : thm
<a name="line1384"></a>    val <a href="#REAL_EQ_RINV-val">REAL_EQ_RINV</a> : thm
<a name="line1385"></a>    val <a href="#REAL_HAUSDIST_LE-val">REAL_HAUSDIST_LE</a> : thm
<a name="line1386"></a>    val <a href="#REAL_HAUSDIST_LE_EQ-val">REAL_HAUSDIST_LE_EQ</a> : thm
<a name="line1387"></a>    val <a href="#REAL_HAUSDIST_LE_SUMS-val">REAL_HAUSDIST_LE_SUMS</a> : thm
<a name="line1388"></a>    val <a href="#REAL_LE_AFFINITY-val">REAL_LE_AFFINITY</a> : thm
<a name="line1389"></a>    val <a href="#REAL_LE_HAUSDIST-val">REAL_LE_HAUSDIST</a> : thm
<a name="line1390"></a>    val <a href="#REAL_LE_SETDIST-val">REAL_LE_SETDIST</a> : thm
<a name="line1391"></a>    val <a href="#REAL_LE_SETDIST_EQ-val">REAL_LE_SETDIST_EQ</a> : thm
<a name="line1392"></a>    val <a href="#REAL_LT_AFFINITY-val">REAL_LT_AFFINITY</a> : thm
<a name="line1393"></a>    val <a href="#REAL_LT_HAUSDIST_POINT_EXISTS-val">REAL_LT_HAUSDIST_POINT_EXISTS</a> : thm
<a name="line1394"></a>    val <a href="#REAL_SETDIST_LT_EXISTS-val">REAL_SETDIST_LT_EXISTS</a> : thm
<a name="line1395"></a>    val <a href="#REFLECT_INTERVAL-val">REFLECT_INTERVAL</a> : thm
<a name="line1396"></a>    val <a href="#REGULAR_CLOSED_BIGUNION-val">REGULAR_CLOSED_BIGUNION</a> : thm
<a name="line1397"></a>    val <a href="#REGULAR_CLOSED_UNION-val">REGULAR_CLOSED_UNION</a> : thm
<a name="line1398"></a>    val <a href="#REGULAR_OPEN_INTER-val">REGULAR_OPEN_INTER</a> : thm
<a name="line1399"></a>    val <a href="#SEGMENT-val">SEGMENT</a> : thm
<a name="line1400"></a>    val <a href="#SEGMENT_CLOSED_OPEN-val">SEGMENT_CLOSED_OPEN</a> : thm
<a name="line1401"></a>    val <a href="#SEGMENT_OPEN_SUBSET_CLOSED-val">SEGMENT_OPEN_SUBSET_CLOSED</a> : thm
<a name="line1402"></a>    val <a href="#SEGMENT_REFL-val">SEGMENT_REFL</a> : thm
<a name="line1403"></a>    val <a href="#SEGMENT_SCALAR_MULTIPLE-val">SEGMENT_SCALAR_MULTIPLE</a> : thm
<a name="line1404"></a>    val <a href="#SEGMENT_SYM-val">SEGMENT_SYM</a> : thm
<a name="line1405"></a>    val <a href="#SEGMENT_TO_CLOSEST_POINT-val">SEGMENT_TO_CLOSEST_POINT</a> : thm
<a name="line1406"></a>    val <a href="#SEGMENT_TO_POINT_EXISTS-val">SEGMENT_TO_POINT_EXISTS</a> : thm
<a name="line1407"></a>    val <a href="#SEGMENT_TRANSLATION-val">SEGMENT_TRANSLATION</a> : thm
<a name="line1408"></a>    val <a href="#SEPARATE_CLOSED_COMPACT-val">SEPARATE_CLOSED_COMPACT</a> : thm
<a name="line1409"></a>    val <a href="#SEPARATE_COMPACT_CLOSED-val">SEPARATE_COMPACT_CLOSED</a> : thm
<a name="line1410"></a>    val <a href="#SEPARATE_POINT_CLOSED-val">SEPARATE_POINT_CLOSED</a> : thm
<a name="line1411"></a>    val <a href="#SEPARATION_CLOSURES-val">SEPARATION_CLOSURES</a> : thm
<a name="line1412"></a>    val <a href="#SEPARATION_HAUSDORFF-val">SEPARATION_HAUSDORFF</a> : thm
<a name="line1413"></a>    val <a href="#SEPARATION_NORMAL-val">SEPARATION_NORMAL</a> : thm
<a name="line1414"></a>    val <a href="#SEPARATION_NORMAL_COMPACT-val">SEPARATION_NORMAL_COMPACT</a> : thm
<a name="line1415"></a>    val <a href="#SEPARATION_NORMAL_LOCAL-val">SEPARATION_NORMAL_LOCAL</a> : thm
<a name="line1416"></a>    val <a href="#SEPARATION_T0-val">SEPARATION_T0</a> : thm
<a name="line1417"></a>    val <a href="#SEPARATION_T1-val">SEPARATION_T1</a> : thm
<a name="line1418"></a>    val <a href="#SEPARATION_T2-val">SEPARATION_T2</a> : thm
<a name="line1419"></a>    val <a href="#SEQUENCE_CAUCHY_WLOG-val">SEQUENCE_CAUCHY_WLOG</a> : thm
<a name="line1420"></a>    val <a href="#SEQUENCE_INFINITE_LEMMA-val">SEQUENCE_INFINITE_LEMMA</a> : thm
<a name="line1421"></a>    val <a href="#SEQUENCE_UNIQUE_LIMPT-val">SEQUENCE_UNIQUE_LIMPT</a> : thm
<a name="line1422"></a>    val <a href="#SEQUENTIALLY-val">SEQUENTIALLY</a> : thm
<a name="line1423"></a>    val <a href="#SEQ_HARMONIC-val">SEQ_HARMONIC</a> : thm
<a name="line1424"></a>    val <a href="#SEQ_HARMONIC_OFFSET-val">SEQ_HARMONIC_OFFSET</a> : thm
<a name="line1425"></a>    val <a href="#SEQ_OFFSET-val">SEQ_OFFSET</a> : thm
<a name="line1426"></a>    val <a href="#SEQ_OFFSET_NEG-val">SEQ_OFFSET_NEG</a> : thm
<a name="line1427"></a>    val <a href="#SEQ_OFFSET_REV-val">SEQ_OFFSET_REV</a> : thm
<a name="line1428"></a>    val <a href="#SERIES_0-val">SERIES_0</a> : thm
<a name="line1429"></a>    val <a href="#SERIES_ABSCONV_IMP_CONV-val">SERIES_ABSCONV_IMP_CONV</a> : thm
<a name="line1430"></a>    val <a href="#SERIES_ADD-val">SERIES_ADD</a> : thm
<a name="line1431"></a>    val <a href="#SERIES_BOUND-val">SERIES_BOUND</a> : thm
<a name="line1432"></a>    val <a href="#SERIES_CAUCHY-val">SERIES_CAUCHY</a> : thm
<a name="line1433"></a>    val <a href="#SERIES_CAUCHY_UNIFORM-val">SERIES_CAUCHY_UNIFORM</a> : thm
<a name="line1434"></a>    val <a href="#SERIES_CMUL-val">SERIES_CMUL</a> : thm
<a name="line1435"></a>    val <a href="#SERIES_COMPARISON-val">SERIES_COMPARISON</a> : thm
<a name="line1436"></a>    val <a href="#SERIES_COMPARISON_BOUND-val">SERIES_COMPARISON_BOUND</a> : thm
<a name="line1437"></a>    val <a href="#SERIES_COMPARISON_UNIFORM-val">SERIES_COMPARISON_UNIFORM</a> : thm
<a name="line1438"></a>    val <a href="#SERIES_COMPONENT-val">SERIES_COMPONENT</a> : thm
<a name="line1439"></a>    val <a href="#SERIES_DIFFS-val">SERIES_DIFFS</a> : thm
<a name="line1440"></a>    val <a href="#SERIES_DIRICHLET-val">SERIES_DIRICHLET</a> : thm
<a name="line1441"></a>    val <a href="#SERIES_DIRICHLET_BILINEAR-val">SERIES_DIRICHLET_BILINEAR</a> : thm
<a name="line1442"></a>    val <a href="#SERIES_DROP_LE-val">SERIES_DROP_LE</a> : thm
<a name="line1443"></a>    val <a href="#SERIES_DROP_POS-val">SERIES_DROP_POS</a> : thm
<a name="line1444"></a>    val <a href="#SERIES_FINITE-val">SERIES_FINITE</a> : thm
<a name="line1445"></a>    val <a href="#SERIES_FINITE_SUPPORT-val">SERIES_FINITE_SUPPORT</a> : thm
<a name="line1446"></a>    val <a href="#SERIES_FROM-val">SERIES_FROM</a> : thm
<a name="line1447"></a>    val <a href="#SERIES_GOESTOZERO-val">SERIES_GOESTOZERO</a> : thm
<a name="line1448"></a>    val <a href="#SERIES_INJECTIVE_IMAGE-val">SERIES_INJECTIVE_IMAGE</a> : thm
<a name="line1449"></a>    val <a href="#SERIES_INJECTIVE_IMAGE_STRONG-val">SERIES_INJECTIVE_IMAGE_STRONG</a> : thm
<a name="line1450"></a>    val <a href="#SERIES_LINEAR-val">SERIES_LINEAR</a> : thm
<a name="line1451"></a>    val <a href="#SERIES_NEG-val">SERIES_NEG</a> : thm
<a name="line1452"></a>    val <a href="#SERIES_RATIO-val">SERIES_RATIO</a> : thm
<a name="line1453"></a>    val <a href="#SERIES_REARRANGE-val">SERIES_REARRANGE</a> : thm
<a name="line1454"></a>    val <a href="#SERIES_REARRANGE_EQ-val">SERIES_REARRANGE_EQ</a> : thm
<a name="line1455"></a>    val <a href="#SERIES_RESTRICT-val">SERIES_RESTRICT</a> : thm
<a name="line1456"></a>    val <a href="#SERIES_SUB-val">SERIES_SUB</a> : thm
<a name="line1457"></a>    val <a href="#SERIES_SUBSET-val">SERIES_SUBSET</a> : thm
<a name="line1458"></a>    val <a href="#SERIES_SUM-val">SERIES_SUM</a> : thm
<a name="line1459"></a>    val <a href="#SERIES_TERMS_TOZERO-val">SERIES_TERMS_TOZERO</a> : thm
<a name="line1460"></a>    val <a href="#SERIES_TRIVIAL-val">SERIES_TRIVIAL</a> : thm
<a name="line1461"></a>    val <a href="#SERIES_UNIQUE-val">SERIES_UNIQUE</a> : thm
<a name="line1462"></a>    val <a href="#SETDIST_BALLS-val">SETDIST_BALLS</a> : thm
<a name="line1463"></a>    val <a href="#SETDIST_CLOSED_COMPACT-val">SETDIST_CLOSED_COMPACT</a> : thm
<a name="line1464"></a>    val <a href="#SETDIST_CLOSEST_POINT-val">SETDIST_CLOSEST_POINT</a> : thm
<a name="line1465"></a>    val <a href="#SETDIST_CLOSURE-val">SETDIST_CLOSURE</a> : thm
<a name="line1466"></a>    val <a href="#SETDIST_COMPACT_CLOSED-val">SETDIST_COMPACT_CLOSED</a> : thm
<a name="line1467"></a>    val <a href="#SETDIST_DIFFERENCES-val">SETDIST_DIFFERENCES</a> : thm
<a name="line1468"></a>    val <a href="#SETDIST_EMPTY-val">SETDIST_EMPTY</a> : thm
<a name="line1469"></a>    val <a href="#SETDIST_EQ_0_BOUNDED-val">SETDIST_EQ_0_BOUNDED</a> : thm
<a name="line1470"></a>    val <a href="#SETDIST_EQ_0_CLOSED-val">SETDIST_EQ_0_CLOSED</a> : thm
<a name="line1471"></a>    val <a href="#SETDIST_EQ_0_CLOSED_COMPACT-val">SETDIST_EQ_0_CLOSED_COMPACT</a> : thm
<a name="line1472"></a>    val <a href="#SETDIST_EQ_0_CLOSED_IN-val">SETDIST_EQ_0_CLOSED_IN</a> : thm
<a name="line1473"></a>    val <a href="#SETDIST_EQ_0_COMPACT_CLOSED-val">SETDIST_EQ_0_COMPACT_CLOSED</a> : thm
<a name="line1474"></a>    val <a href="#SETDIST_EQ_0_SING-val">SETDIST_EQ_0_SING</a> : thm
<a name="line1475"></a>    val <a href="#SETDIST_FRONTIER-val">SETDIST_FRONTIER</a> : thm
<a name="line1476"></a>    val <a href="#SETDIST_FRONTIERS-val">SETDIST_FRONTIERS</a> : thm
<a name="line1477"></a>    val <a href="#SETDIST_HAUSDIST_TRIANGLE-val">SETDIST_HAUSDIST_TRIANGLE</a> : thm
<a name="line1478"></a>    val <a href="#SETDIST_LE_DIST-val">SETDIST_LE_DIST</a> : thm
<a name="line1479"></a>    val <a href="#SETDIST_LE_HAUSDIST-val">SETDIST_LE_HAUSDIST</a> : thm
<a name="line1480"></a>    val <a href="#SETDIST_LE_SING-val">SETDIST_LE_SING</a> : thm
<a name="line1481"></a>    val <a href="#SETDIST_LINEAR_IMAGE-val">SETDIST_LINEAR_IMAGE</a> : thm
<a name="line1482"></a>    val <a href="#SETDIST_LIPSCHITZ-val">SETDIST_LIPSCHITZ</a> : thm
<a name="line1483"></a>    val <a href="#SETDIST_POS_LE-val">SETDIST_POS_LE</a> : thm
<a name="line1484"></a>    val <a href="#SETDIST_REFL-val">SETDIST_REFL</a> : thm
<a name="line1485"></a>    val <a href="#SETDIST_SINGS-val">SETDIST_SINGS</a> : thm
<a name="line1486"></a>    val <a href="#SETDIST_SING_FRONTIER-val">SETDIST_SING_FRONTIER</a> : thm
<a name="line1487"></a>    val <a href="#SETDIST_SING_FRONTIER_CASES-val">SETDIST_SING_FRONTIER_CASES</a> : thm
<a name="line1488"></a>    val <a href="#SETDIST_SING_IN_SET-val">SETDIST_SING_IN_SET</a> : thm
<a name="line1489"></a>    val <a href="#SETDIST_SING_LE_HAUSDIST-val">SETDIST_SING_LE_HAUSDIST</a> : thm
<a name="line1490"></a>    val <a href="#SETDIST_SING_TRIANGLE-val">SETDIST_SING_TRIANGLE</a> : thm
<a name="line1491"></a>    val <a href="#SETDIST_SUBSETS_EQ-val">SETDIST_SUBSETS_EQ</a> : thm
<a name="line1492"></a>    val <a href="#SETDIST_SUBSET_LEFT-val">SETDIST_SUBSET_LEFT</a> : thm
<a name="line1493"></a>    val <a href="#SETDIST_SUBSET_RIGHT-val">SETDIST_SUBSET_RIGHT</a> : thm
<a name="line1494"></a>    val <a href="#SETDIST_SYM-val">SETDIST_SYM</a> : thm
<a name="line1495"></a>    val <a href="#SETDIST_TRANSLATION-val">SETDIST_TRANSLATION</a> : thm
<a name="line1496"></a>    val <a href="#SETDIST_TRIANGLE-val">SETDIST_TRIANGLE</a> : thm
<a name="line1497"></a>    val <a href="#SETDIST_UNIQUE-val">SETDIST_UNIQUE</a> : thm
<a name="line1498"></a>    val <a href="#SETDIST_UNIV-val">SETDIST_UNIV</a> : thm
<a name="line1499"></a>    val <a href="#SETDIST_ZERO-val">SETDIST_ZERO</a> : thm
<a name="line1500"></a>    val <a href="#SETDIST_ZERO_STRONG-val">SETDIST_ZERO_STRONG</a> : thm
<a name="line1501"></a>    val <a href="#SET_DIFF_FRONTIER-val">SET_DIFF_FRONTIER</a> : thm
<a name="line1502"></a>    val <a href="#SPANNING_SUBSET_INDEPENDENT-val">SPANNING_SUBSET_INDEPENDENT</a> : thm
<a name="line1503"></a>    val <a href="#SPAN_0-val">SPAN_0</a> : thm
<a name="line1504"></a>    val <a href="#SPAN_ADD-val">SPAN_ADD</a> : thm
<a name="line1505"></a>    val <a href="#SPAN_ADD_EQ-val">SPAN_ADD_EQ</a> : thm
<a name="line1506"></a>    val <a href="#SPAN_BREAKDOWN-val">SPAN_BREAKDOWN</a> : thm
<a name="line1507"></a>    val <a href="#SPAN_BREAKDOWN_EQ-val">SPAN_BREAKDOWN_EQ</a> : thm
<a name="line1508"></a>    val <a href="#SPAN_CARD_GE_DIM-val">SPAN_CARD_GE_DIM</a> : thm
<a name="line1509"></a>    val <a href="#SPAN_CLAUSES-val">SPAN_CLAUSES</a> : thm
<a name="line1510"></a>    val <a href="#SPAN_EMPTY-val">SPAN_EMPTY</a> : thm
<a name="line1511"></a>    val <a href="#SPAN_EQ_SELF-val">SPAN_EQ_SELF</a> : thm
<a name="line1512"></a>    val <a href="#SPAN_EXPLICIT-val">SPAN_EXPLICIT</a> : thm
<a name="line1513"></a>    val <a href="#SPAN_INC-val">SPAN_INC</a> : thm
<a name="line1514"></a>    val <a href="#SPAN_INDUCT-val">SPAN_INDUCT</a> : thm
<a name="line1515"></a>    val <a href="#SPAN_INDUCT_ALT-val">SPAN_INDUCT_ALT</a> : thm
<a name="line1516"></a>    val <a href="#SPAN_LINEAR_IMAGE-val">SPAN_LINEAR_IMAGE</a> : thm
<a name="line1517"></a>    val <a href="#SPAN_MONO-val">SPAN_MONO</a> : thm
<a name="line1518"></a>    val <a href="#SPAN_MUL-val">SPAN_MUL</a> : thm
<a name="line1519"></a>    val <a href="#SPAN_MUL_EQ-val">SPAN_MUL_EQ</a> : thm
<a name="line1520"></a>    val <a href="#SPAN_NEG-val">SPAN_NEG</a> : thm
<a name="line1521"></a>    val <a href="#SPAN_NEG_EQ-val">SPAN_NEG_EQ</a> : thm
<a name="line1522"></a>    val <a href="#SPAN_SPAN-val">SPAN_SPAN</a> : thm
<a name="line1523"></a>    val <a href="#SPAN_STDBASIS-val">SPAN_STDBASIS</a> : thm
<a name="line1524"></a>    val <a href="#SPAN_SUB-val">SPAN_SUB</a> : thm
<a name="line1525"></a>    val <a href="#SPAN_SUBSET_SUBSPACE-val">SPAN_SUBSET_SUBSPACE</a> : thm
<a name="line1526"></a>    val <a href="#SPAN_SUBSPACE-val">SPAN_SUBSPACE</a> : thm
<a name="line1527"></a>    val <a href="#SPAN_SUM-val">SPAN_SUM</a> : thm
<a name="line1528"></a>    val <a href="#SPAN_SUPERSET-val">SPAN_SUPERSET</a> : thm
<a name="line1529"></a>    val <a href="#SPAN_TRANS-val">SPAN_TRANS</a> : thm
<a name="line1530"></a>    val <a href="#SPAN_UNION-val">SPAN_UNION</a> : thm
<a name="line1531"></a>    val <a href="#SPAN_UNION_SUBSET-val">SPAN_UNION_SUBSET</a> : thm
<a name="line1532"></a>    val <a href="#SPAN_UNIV-val">SPAN_UNIV</a> : thm
<a name="line1533"></a>    val <a href="#SPHERE-val">SPHERE</a> : thm
<a name="line1534"></a>    val <a href="#SPHERE_EMPTY-val">SPHERE_EMPTY</a> : thm
<a name="line1535"></a>    val <a href="#SPHERE_EQ_EMPTY-val">SPHERE_EQ_EMPTY</a> : thm
<a name="line1536"></a>    val <a href="#SPHERE_EQ_SING-val">SPHERE_EQ_SING</a> : thm
<a name="line1537"></a>    val <a href="#SPHERE_LINEAR_IMAGE-val">SPHERE_LINEAR_IMAGE</a> : thm
<a name="line1538"></a>    val <a href="#SPHERE_SING-val">SPHERE_SING</a> : thm
<a name="line1539"></a>    val <a href="#SPHERE_SUBSET_CBALL-val">SPHERE_SUBSET_CBALL</a> : thm
<a name="line1540"></a>    val <a href="#SPHERE_TRANSLATION-val">SPHERE_TRANSLATION</a> : thm
<a name="line1541"></a>    val <a href="#SPHERE_UNION_BALL-val">SPHERE_UNION_BALL</a> : thm
<a name="line1542"></a>    val <a href="#SUBORDINATE_PARTITION_OF_UNITY-val">SUBORDINATE_PARTITION_OF_UNITY</a> : thm
<a name="line1543"></a>    val <a href="#SUBSET_BALL-val">SUBSET_BALL</a> : thm
<a name="line1544"></a>    val <a href="#SUBSET_BALLS-val">SUBSET_BALLS</a> : thm
<a name="line1545"></a>    val <a href="#SUBSET_CBALL-val">SUBSET_CBALL</a> : thm
<a name="line1546"></a>    val <a href="#SUBSET_CLOSURE-val">SUBSET_CLOSURE</a> : thm
<a name="line1547"></a>    val <a href="#SUBSET_INTERIOR-val">SUBSET_INTERIOR</a> : thm
<a name="line1548"></a>    val <a href="#SUBSET_INTERIOR_EQ-val">SUBSET_INTERIOR_EQ</a> : thm
<a name="line1549"></a>    val <a href="#SUBSET_INTERVAL-val">SUBSET_INTERVAL</a> : thm
<a name="line1550"></a>    val <a href="#SUBSET_INTERVAL_IMP-val">SUBSET_INTERVAL_IMP</a> : thm
<a name="line1551"></a>    val <a href="#SUBSPACE_0-val">SUBSPACE_0</a> : thm
<a name="line1552"></a>    val <a href="#SUBSPACE_ADD-val">SUBSPACE_ADD</a> : thm
<a name="line1553"></a>    val <a href="#SUBSPACE_BIGINTER-val">SUBSPACE_BIGINTER</a> : thm
<a name="line1554"></a>    val <a href="#SUBSPACE_BOUNDED_EQ_TRIVIAL-val">SUBSPACE_BOUNDED_EQ_TRIVIAL</a> : thm
<a name="line1555"></a>    val <a href="#SUBSPACE_IMP_NONEMPTY-val">SUBSPACE_IMP_NONEMPTY</a> : thm
<a name="line1556"></a>    val <a href="#SUBSPACE_INTER-val">SUBSPACE_INTER</a> : thm
<a name="line1557"></a>    val <a href="#SUBSPACE_KERNEL-val">SUBSPACE_KERNEL</a> : thm
<a name="line1558"></a>    val <a href="#SUBSPACE_LINEAR_IMAGE-val">SUBSPACE_LINEAR_IMAGE</a> : thm
<a name="line1559"></a>    val <a href="#SUBSPACE_LINEAR_PREIMAGE-val">SUBSPACE_LINEAR_PREIMAGE</a> : thm
<a name="line1560"></a>    val <a href="#SUBSPACE_MUL-val">SUBSPACE_MUL</a> : thm
<a name="line1561"></a>    val <a href="#SUBSPACE_NEG-val">SUBSPACE_NEG</a> : thm
<a name="line1562"></a>    val <a href="#SUBSPACE_SPAN-val">SUBSPACE_SPAN</a> : thm
<a name="line1563"></a>    val <a href="#SUBSPACE_SUB-val">SUBSPACE_SUB</a> : thm
<a name="line1564"></a>    val <a href="#SUBSPACE_SUBSTANDARD-val">SUBSPACE_SUBSTANDARD</a> : thm
<a name="line1565"></a>    val <a href="#SUBSPACE_SUM-val">SUBSPACE_SUM</a> : thm
<a name="line1566"></a>    val <a href="#SUBSPACE_SUMS-val">SUBSPACE_SUMS</a> : thm
<a name="line1567"></a>    val <a href="#SUBSPACE_TRANSLATION_SELF-val">SUBSPACE_TRANSLATION_SELF</a> : thm
<a name="line1568"></a>    val <a href="#SUBSPACE_TRANSLATION_SELF_EQ-val">SUBSPACE_TRANSLATION_SELF_EQ</a> : thm
<a name="line1569"></a>    val <a href="#SUBSPACE_TRIVIAL-val">SUBSPACE_TRIVIAL</a> : thm
<a name="line1570"></a>    val <a href="#SUBSPACE_UNION_CHAIN-val">SUBSPACE_UNION_CHAIN</a> : thm
<a name="line1571"></a>    val <a href="#SUBSPACE_UNIV-val">SUBSPACE_UNIV</a> : thm
<a name="line1572"></a>    val <a href="#SUMMABLE_0-val">SUMMABLE_0</a> : thm
<a name="line1573"></a>    val <a href="#SUMMABLE_ADD-val">SUMMABLE_ADD</a> : thm
<a name="line1574"></a>    val <a href="#SUMMABLE_BILINEAR_PARTIAL_PRE-val">SUMMABLE_BILINEAR_PARTIAL_PRE</a> : thm
<a name="line1575"></a>    val <a href="#SUMMABLE_CAUCHY-val">SUMMABLE_CAUCHY</a> : thm
<a name="line1576"></a>    val <a href="#SUMMABLE_CMUL-val">SUMMABLE_CMUL</a> : thm
<a name="line1577"></a>    val <a href="#SUMMABLE_COMPARISON-val">SUMMABLE_COMPARISON</a> : thm
<a name="line1578"></a>    val <a href="#SUMMABLE_COMPONENT-val">SUMMABLE_COMPONENT</a> : thm
<a name="line1579"></a>    val <a href="#SUMMABLE_EQ-val">SUMMABLE_EQ</a> : thm
<a name="line1580"></a>    val <a href="#SUMMABLE_EQ_COFINITE-val">SUMMABLE_EQ_COFINITE</a> : thm
<a name="line1581"></a>    val <a href="#SUMMABLE_EQ_EVENTUALLY-val">SUMMABLE_EQ_EVENTUALLY</a> : thm
<a name="line1582"></a>    val <a href="#SUMMABLE_FROM_ELSEWHERE-val">SUMMABLE_FROM_ELSEWHERE</a> : thm
<a name="line1583"></a>    val <a href="#SUMMABLE_IFF-val">SUMMABLE_IFF</a> : thm
<a name="line1584"></a>    val <a href="#SUMMABLE_IFF_COFINITE-val">SUMMABLE_IFF_COFINITE</a> : thm
<a name="line1585"></a>    val <a href="#SUMMABLE_IFF_EVENTUALLY-val">SUMMABLE_IFF_EVENTUALLY</a> : thm
<a name="line1586"></a>    val <a href="#SUMMABLE_IMP_BOUNDED-val">SUMMABLE_IMP_BOUNDED</a> : thm
<a name="line1587"></a>    val <a href="#SUMMABLE_IMP_SUMS_BOUNDED-val">SUMMABLE_IMP_SUMS_BOUNDED</a> : thm
<a name="line1588"></a>    val <a href="#SUMMABLE_IMP_TOZERO-val">SUMMABLE_IMP_TOZERO</a> : thm
<a name="line1589"></a>    val <a href="#SUMMABLE_LINEAR-val">SUMMABLE_LINEAR</a> : thm
<a name="line1590"></a>    val <a href="#SUMMABLE_NEG-val">SUMMABLE_NEG</a> : thm
<a name="line1591"></a>    val <a href="#SUMMABLE_REARRANGE-val">SUMMABLE_REARRANGE</a> : thm
<a name="line1592"></a>    val <a href="#SUMMABLE_REINDEX-val">SUMMABLE_REINDEX</a> : thm
<a name="line1593"></a>    val <a href="#SUMMABLE_RESTRICT-val">SUMMABLE_RESTRICT</a> : thm
<a name="line1594"></a>    val <a href="#SUMMABLE_SUB-val">SUMMABLE_SUB</a> : thm
<a name="line1595"></a>    val <a href="#SUMMABLE_SUBSET-val">SUMMABLE_SUBSET</a> : thm
<a name="line1596"></a>    val <a href="#SUMMABLE_SUBSET_ABSCONV-val">SUMMABLE_SUBSET_ABSCONV</a> : thm
<a name="line1597"></a>    val <a href="#SUMMABLE_TRIVIAL-val">SUMMABLE_TRIVIAL</a> : thm
<a name="line1598"></a>    val <a href="#SUMS_0-val">SUMS_0</a> : thm
<a name="line1599"></a>    val <a href="#SUMS_EQ-val">SUMS_EQ</a> : thm
<a name="line1600"></a>    val <a href="#SUMS_FINITE_DIFF-val">SUMS_FINITE_DIFF</a> : thm
<a name="line1601"></a>    val <a href="#SUMS_FINITE_UNION-val">SUMS_FINITE_UNION</a> : thm
<a name="line1602"></a>    val <a href="#SUMS_IFF-val">SUMS_IFF</a> : thm
<a name="line1603"></a>    val <a href="#SUMS_INFSUM-val">SUMS_INFSUM</a> : thm
<a name="line1604"></a>    val <a href="#SUMS_INTERVALS-val">SUMS_INTERVALS</a> : thm
<a name="line1605"></a>    val <a href="#SUMS_LIM-val">SUMS_LIM</a> : thm
<a name="line1606"></a>    val <a href="#SUMS_OFFSET-val">SUMS_OFFSET</a> : thm
<a name="line1607"></a>    val <a href="#SUMS_OFFSET_REV-val">SUMS_OFFSET_REV</a> : thm
<a name="line1608"></a>    val <a href="#SUMS_REINDEX-val">SUMS_REINDEX</a> : thm
<a name="line1609"></a>    val <a href="#SUMS_REINDEX_GEN-val">SUMS_REINDEX_GEN</a> : thm
<a name="line1610"></a>    val <a href="#SUMS_SUMMABLE-val">SUMS_SUMMABLE</a> : thm
<a name="line1611"></a>    val <a href="#SUM_DIFF_LEMMA-val">SUM_DIFF_LEMMA</a> : thm
<a name="line1612"></a>    val <a href="#SUP_INSERT-val">SUP_INSERT</a> : thm
<a name="line1613"></a>    val <a href="#SURJECTIVE_IMAGE_EQ-val">SURJECTIVE_IMAGE_EQ</a> : thm
<a name="line1614"></a>    val <a href="#SYMMETRIC_CLOSURE-val">SYMMETRIC_CLOSURE</a> : thm
<a name="line1615"></a>    val <a href="#SYMMETRIC_INTERIOR-val">SYMMETRIC_INTERIOR</a> : thm
<a name="line1616"></a>    val <a href="#SYMMETRIC_LINEAR_IMAGE-val">SYMMETRIC_LINEAR_IMAGE</a> : thm
<a name="line1617"></a>    val <a href="#TENDSTO_LIM-val">TENDSTO_LIM</a> : thm
<a name="line1618"></a>    val <a href="#TOPSPACE_EUCLIDEAN-val">TOPSPACE_EUCLIDEAN</a> : thm
<a name="line1619"></a>    val <a href="#TOPSPACE_EUCLIDEAN_SUBTOPOLOGY-val">TOPSPACE_EUCLIDEAN_SUBTOPOLOGY</a> : thm
<a name="line1620"></a>    val <a href="#TRANSITIVE_STEPWISE_LT-val">TRANSITIVE_STEPWISE_LT</a> : thm
<a name="line1621"></a>    val <a href="#TRANSITIVE_STEPWISE_LT_EQ-val">TRANSITIVE_STEPWISE_LT_EQ</a> : thm
<a name="line1622"></a>    val <a href="#TRANSLATION_DIFF-val">TRANSLATION_DIFF</a> : thm
<a name="line1623"></a>    val <a href="#TRIVIAL_LIMIT_AT-val">TRIVIAL_LIMIT_AT</a> : thm
<a name="line1624"></a>    val <a href="#TRIVIAL_LIMIT_AT_INFINITY-val">TRIVIAL_LIMIT_AT_INFINITY</a> : thm
<a name="line1625"></a>    val <a href="#TRIVIAL_LIMIT_AT_NEGINFINITY-val">TRIVIAL_LIMIT_AT_NEGINFINITY</a> : thm
<a name="line1626"></a>    val <a href="#TRIVIAL_LIMIT_AT_POSINFINITY-val">TRIVIAL_LIMIT_AT_POSINFINITY</a> : thm
<a name="line1627"></a>    val <a href="#TRIVIAL_LIMIT_SEQUENTIALLY-val">TRIVIAL_LIMIT_SEQUENTIALLY</a> : thm
<a name="line1628"></a>    val <a href="#TRIVIAL_LIMIT_WITHIN-val">TRIVIAL_LIMIT_WITHIN</a> : thm
<a name="line1629"></a>    val <a href="#UNBOUNDED_HALFSPACE_COMPONENT_GE-val">UNBOUNDED_HALFSPACE_COMPONENT_GE</a> : thm
<a name="line1630"></a>    val <a href="#UNBOUNDED_HALFSPACE_COMPONENT_GT-val">UNBOUNDED_HALFSPACE_COMPONENT_GT</a> : thm
<a name="line1631"></a>    val <a href="#UNBOUNDED_HALFSPACE_COMPONENT_LE-val">UNBOUNDED_HALFSPACE_COMPONENT_LE</a> : thm
<a name="line1632"></a>    val <a href="#UNBOUNDED_HALFSPACE_COMPONENT_LT-val">UNBOUNDED_HALFSPACE_COMPONENT_LT</a> : thm
<a name="line1633"></a>    val <a href="#UNBOUNDED_INTER_COBOUNDED-val">UNBOUNDED_INTER_COBOUNDED</a> : thm
<a name="line1634"></a>    val <a href="#UNCOUNTABLE_EUCLIDEAN-val">UNCOUNTABLE_EUCLIDEAN</a> : thm
<a name="line1635"></a>    val <a href="#UNCOUNTABLE_INTERVAL-val">UNCOUNTABLE_INTERVAL</a> : thm
<a name="line1636"></a>    val <a href="#UNCOUNTABLE_OPEN-val">UNCOUNTABLE_OPEN</a> : thm
<a name="line1637"></a>    val <a href="#UNCOUNTABLE_REAL-val">UNCOUNTABLE_REAL</a> : thm
<a name="line1638"></a>    val <a href="#UNIFORMLY_CAUCHY_IMP_UNIFORMLY_CONVERGENT-val">UNIFORMLY_CAUCHY_IMP_UNIFORMLY_CONVERGENT</a> : thm
<a name="line1639"></a>    val <a href="#UNIFORMLY_CONTINUOUS_EXTENDS_TO_CLOSURE-val">UNIFORMLY_CONTINUOUS_EXTENDS_TO_CLOSURE</a> : thm
<a name="line1640"></a>    val <a href="#UNIFORMLY_CONTINUOUS_IMP_CAUCHY_CONTINUOUS-val">UNIFORMLY_CONTINUOUS_IMP_CAUCHY_CONTINUOUS</a> : thm
<a name="line1641"></a>    val <a href="#UNIFORMLY_CONTINUOUS_IMP_CONTINUOUS-val">UNIFORMLY_CONTINUOUS_IMP_CONTINUOUS</a> : thm
<a name="line1642"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_ADD-val">UNIFORMLY_CONTINUOUS_ON_ADD</a> : thm
<a name="line1643"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_CLOSURE-val">UNIFORMLY_CONTINUOUS_ON_CLOSURE</a> : thm
<a name="line1644"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_CMUL-val">UNIFORMLY_CONTINUOUS_ON_CMUL</a> : thm
<a name="line1645"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_COMPOSE-val">UNIFORMLY_CONTINUOUS_ON_COMPOSE</a> : thm
<a name="line1646"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_CONST-val">UNIFORMLY_CONTINUOUS_ON_CONST</a> : thm
<a name="line1647"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_DIST_CLOSEST_POINT-val">UNIFORMLY_CONTINUOUS_ON_DIST_CLOSEST_POINT</a> : thm
<a name="line1648"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_EQ-val">UNIFORMLY_CONTINUOUS_ON_EQ</a> : thm
<a name="line1649"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_ID-val">UNIFORMLY_CONTINUOUS_ON_ID</a> : thm
<a name="line1650"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_MUL-val">UNIFORMLY_CONTINUOUS_ON_MUL</a> : thm
<a name="line1651"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_NEG-val">UNIFORMLY_CONTINUOUS_ON_NEG</a> : thm
<a name="line1652"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_SEQUENTIALLY-val">UNIFORMLY_CONTINUOUS_ON_SEQUENTIALLY</a> : thm
<a name="line1653"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_SETDIST-val">UNIFORMLY_CONTINUOUS_ON_SETDIST</a> : thm
<a name="line1654"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_SUB-val">UNIFORMLY_CONTINUOUS_ON_SUB</a> : thm
<a name="line1655"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_SUBSET-val">UNIFORMLY_CONTINUOUS_ON_SUBSET</a> : thm
<a name="line1656"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_SUM-val">UNIFORMLY_CONTINUOUS_ON_SUM</a> : thm
<a name="line1657"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_VMUL-val">UNIFORMLY_CONTINUOUS_ON_VMUL</a> : thm
<a name="line1658"></a>    val <a href="#UNIFORMLY_CONVERGENT_EQ_CAUCHY-val">UNIFORMLY_CONVERGENT_EQ_CAUCHY</a> : thm
<a name="line1659"></a>    val <a href="#UNIFORMLY_CONVERGENT_EQ_CAUCHY_ALT-val">UNIFORMLY_CONVERGENT_EQ_CAUCHY_ALT</a> : thm
<a name="line1660"></a>    val <a href="#UNIFORM_LIM_ADD-val">UNIFORM_LIM_ADD</a> : thm
<a name="line1661"></a>    val <a href="#UNIFORM_LIM_BILINEAR-val">UNIFORM_LIM_BILINEAR</a> : thm
<a name="line1662"></a>    val <a href="#UNIFORM_LIM_SUB-val">UNIFORM_LIM_SUB</a> : thm
<a name="line1663"></a>    val <a href="#UNION_FRONTIER-val">UNION_FRONTIER</a> : thm
<a name="line1664"></a>    val <a href="#UNION_INTERIOR_SUBSET-val">UNION_INTERIOR_SUBSET</a> : thm
<a name="line1665"></a>    val <a href="#UNIT_INTERVAL_NONEMPTY-val">UNIT_INTERVAL_NONEMPTY</a> : thm
<a name="line1666"></a>    val <a href="#UPPER_HEMICONTINUOUS-val">UPPER_HEMICONTINUOUS</a> : thm
<a name="line1667"></a>    val <a href="#UPPER_LOWER_HEMICONTINUOUS-val">UPPER_LOWER_HEMICONTINUOUS</a> : thm
<a name="line1668"></a>    val <a href="#UPPER_LOWER_HEMICONTINUOUS_EXPLICIT-val">UPPER_LOWER_HEMICONTINUOUS_EXPLICIT</a> : thm
<a name="line1669"></a>    val <a href="#URYSOHN-val">URYSOHN</a> : thm
<a name="line1670"></a>    val <a href="#URYSOHN_LOCAL-val">URYSOHN_LOCAL</a> : thm
<a name="line1671"></a>    val <a href="#URYSOHN_LOCAL_STRONG-val">URYSOHN_LOCAL_STRONG</a> : thm
<a name="line1672"></a>    val <a href="#URYSOHN_STRONG-val">URYSOHN_STRONG</a> : thm
<a name="line1673"></a>    val <a href="#WITHIN-val">WITHIN</a> : thm
<a name="line1674"></a>    val <a href="#WITHIN_UNIV-val">WITHIN_UNIV</a> : thm
<a name="line1675"></a>    val <a href="#WITHIN_WITHIN-val">WITHIN_WITHIN</a> : thm
<a name="line1676"></a>    val <a href="#at-val">at</a> : thm
<a name="line1677"></a>    val <a href="#ball-val">ball</a> : thm
<a name="line1678"></a>    val <a href="#closed_def-val">closed_def</a> : thm
<a name="line1679"></a>    val <a href="#continuous_at-val">continuous_at</a> : thm
<a name="line1680"></a>    val <a href="#continuous_within-val">continuous_within</a> : thm
<a name="line1681"></a>    val <a href="#diameter-val">diameter</a> : thm
<a name="line1682"></a>    val <a href="#dist-val">dist</a> : thm
<a name="line1683"></a>    val <a href="#euclidean-val">euclidean</a> : thm
<a name="line1684"></a>    val <a href="#fsigma-val">fsigma</a> : thm
<a name="line1685"></a>    val <a href="#gdelta-val">gdelta</a> : thm
<a name="line1686"></a>    val <a href="#interval-val">interval</a> : thm
<a name="line1687"></a>    val <a href="#limit_point_of-val">limit_point_of</a> : thm
<a name="line1688"></a>    val <a href="#linear_alt_cmul-val">linear_alt_cmul</a> : thm
<a name="line1689"></a>    val <a href="#linear_repr-val">linear_repr</a> : thm
<a name="line1690"></a>    val <a href="#net_tybij-val">net_tybij</a> : thm
<a name="line1691"></a>    val <a href="#open_def-val">open_def</a> : thm
<a name="line1692"></a>    val <a href="#open_in-val">open_in</a> : thm
<a name="line1693"></a>    val <a href="#segment-val">segment</a> : thm
<a name="line1694"></a>    val <a href="#setdist-val">setdist</a> : thm
<a name="line1695"></a>  
<a name="line1696"></a>  val real_topology_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line1697"></a>(*
   [nets] Parent theory of "real_topology"
   
   [real_sigma] Parent theory of "real_topology"
   
   [<a name="CLOSED_interval-val"><b>CLOSED_interval</b></a>]  Definition
      
       l. interval l = {x | FST (HD l)  x  x  SND (HD l)}
   
   [<a name="OPEN_interval-val"><b>OPEN_interval</b></a>]  Definition
      
       a b. interval (a,b) = {x | a &lt; x  x &lt; b}
   
   [<a name="at_def-val"><b>at_def</b></a>]  Definition
      
       z. at z = mk_net (tendsto (mr1,z))
   
   [<a name="at_infinity-val"><b>at_infinity</b></a>]  Definition
      
       at_infinity = mk_net (x y. abs x  abs y)
   
   [<a name="at_neginfinity-val"><b>at_neginfinity</b></a>]  Definition
      
       at_neginfinity = mk_net (x y. x  y)
   
   [<a name="at_posinfinity-val"><b>at_posinfinity</b></a>]  Definition
      
       at_posinfinity = mk_net (x y. x  y)
   
   [<a name="ball_def-val"><b>ball_def</b></a>]  Definition
      
       ball = mball mr1
   
   [<a name="between-val"><b>between</b></a>]  Definition
      
       x a b. between x (a,b)  dist (a,b) = dist (a,x) + dist (x,b)
   
   [<a name="bilinear-val"><b>bilinear</b></a>]  Definition
      
       f. bilinear f  (x. linear (y. f x y))  y. linear (x. f x y)
   
   [<a name="bounded_def-val"><b>bounded_def</b></a>]  Definition
      
       s. bounded s  a. x. x  s  abs x  a
   
   [<a name="cauchy_def-val"><b>cauchy_def</b></a>]  Definition
      
       s. cauchy s 
            e. 0 &lt; e  N. m n. m  N  n  N  dist (s m,s n) &lt; e
   
   [<a name="cball-val"><b>cball</b></a>]  Definition
      
       x e. cball (x,e) = {y | dist (x,y)  e}
   
   [<a name="closed_segment-val"><b>closed_segment</b></a>]  Definition
      
       l. segment l =
            {(1  u) * FST (HD l) + u * SND (HD l) | 0  u  u  1}
   
   [<a name="closest_point-val"><b>closest_point</b></a>]  Definition
      
       s a.
          closest_point s a =
          @x. x  s  y. y  s  dist (a,x)  dist (a,y)
   
   [<a name="closure-val"><b>closure</b></a>]  Definition
      
       s. closure s = s  {x | x limit_point_of s}
   
   [<a name="collinear-val"><b>collinear</b></a>]  Definition
      
       s. collinear s  u. x y. x  s  y  s  c. x  y = c * u
   
   [<a name="compact-val"><b>compact</b></a>]  Definition
      
       s. compact s 
            f. (n. f n  s) 
                l r.
                  l  s  (m n. m &lt; n  r m &lt; r n) 
                  (f  r  l) sequentially
   
   [<a name="complete-val"><b>complete</b></a>]  Definition
      
       s. complete s 
            f. (n. f n  s)  cauchy f  l. l  s  (f  l) sequentially
   
   [<a name="components-val"><b>components</b></a>]  Definition
      
       s. components s = {connected_component s x | x | x  s}
   
   [<a name="condensation_point_of-val"><b>condensation_point_of</b></a>]  Definition
      
       x s.
          x condensation_point_of s 
          t. x  t  open t  uncountable (s  t)
   
   [<a name="connected-val"><b>connected</b></a>]  Definition
      
       s. connected s 
            e1 e2.
              open e1  open e2  s  e1  e2  e1  e2  s =  
              e1  s    e2  s  
   
   [<a name="connected_component-val"><b>connected_component</b></a>]  Definition
      
       s x y.
          connected_component s x y 
          t. connected t  t  s  x  t  y  t
   
   [<a name="content-val"><b>content</b></a>]  Definition
      
       s. content s =
            if s =  then 0
            else interval_upperbound s  interval_lowerbound s
   
   [<a name="continuous-val"><b>continuous</b></a>]  Definition
      
       f net. f continuous net  (f  f (netlimit net)) net
   
   [<a name="continuous_on-val"><b>continuous_on</b></a>]  Definition
      
       f s.
          f continuous_on s 
          x. x  s 
              e. 0 &lt; e 
                  d. 0 &lt; d 
                      x'. x'  s  dist (x',x) &lt; d  dist (f x',f x) &lt; e
   
   [<a name="dependent-val"><b>dependent</b></a>]  Definition
      
       s. dependent s  a. a  s  a  span (s DELETE a)
   
   [<a name="dim-val"><b>dim</b></a>]  Definition
      
       v. dim v =
            @n. b. b  v  independent b  v  span b  b HAS_SIZE n
   
   [<a name="dist_def-val"><b>dist_def</b></a>]  Definition
      
       dist = dist mr1
   
   [<a name="euclidean_closed_def-val"><b>euclidean_closed_def</b></a>]  Definition
      
       closed = closed_in euclidean
   
   [<a name="euclidean_def-val"><b>euclidean_def</b></a>]  Definition
      
       euclidean = mtop mr1
   
   [<a name="euclidean_open_def-val"><b>euclidean_open_def</b></a>]  Definition
      
       open = open_in euclidean
   
   [<a name="eventually-val"><b>eventually</b></a>]  Definition
      
       p net.
          eventually p net 
          trivial_limit net 
          y. (x. netord net x y)  x. netord net x y  p x
   
   [<a name="frontier-val"><b>frontier</b></a>]  Definition
      
       s. frontier s = closure s DIFF interior s
   
   [<a name="hausdist-val"><b>hausdist</b></a>]  Definition
      
       s t.
          hausdist (s,t) =
          if
            {setdist ({x},t) | x  s}  {setdist ({y},s) | y  t}   
            b. d.
              d  {setdist ({x},t) | x  s}  {setdist ({y},s) | y  t} 
              d  b
          then
            sup ({setdist ({x},t) | x  s}  {setdist ({y},s) | y  t})
          else 0
   
   [<a name="homeomorphic-val"><b>homeomorphic</b></a>]  Definition
      
       s t. s homeomorphic t  f g. homeomorphism (s,t) (f,g)
   
   [<a name="homeomorphism-val"><b>homeomorphism</b></a>]  Definition
      
       s t f g.
          homeomorphism (s,t) (f,g) 
          (x. x  s  g (f x) = x)  IMAGE f s = t  f continuous_on s 
          (y. y  t  f (g y) = y)  IMAGE g t = s  g continuous_on t
   
   [<a name="in_direction-val"><b>in_direction</b></a>]  Definition
      
       a v.
          (a in_direction v) =
          (at a within {b | c. 0  c  b  a = c * v})
   
   [<a name="independent-val"><b>independent</b></a>]  Definition
      
       s. independent s  dependent s
   
   [<a name="interior-val"><b>interior</b></a>]  Definition
      
       s. interior s = {x | t. open t  x  t  t  s}
   
   [<a name="interval_lowerbound-val"><b>interval_lowerbound</b></a>]  Definition
      
       s. interval_lowerbound s = if s =  then 0 else inf s
   
   [<a name="interval_upperbound-val"><b>interval_upperbound</b></a>]  Definition
      
       s. interval_upperbound s = if s =  then 0 else sup s
   
   [<a name="is_interval-val"><b>is_interval</b></a>]  Definition
      
       s. is_interval s 
            a b x. a  s  b  s  a  x  x  b  b  x  x  a  x  s
   
   [<a name="isnet-val"><b>isnet</b></a>]  Definition
      
       g. isnet g  x y. (z. g z x  g z y)  z. g z y  g z x
   
   [<a name="limit_point_of_def-val"><b>limit_point_of_def</b></a>]  Definition
      
       x s. x limit_point_of s  limpt euclidean x s
   
   [<a name="linear-val"><b>linear</b></a>]  Definition
      
       f. linear f 
            (x y. f (x + y) = f x + f y)  c x. f (c * x) = c * f x
   
   [<a name="locally-val"><b>locally</b></a>]  Definition
      
       P s.
          locally P s 
          w x.
            open_in (subtopology euclidean s) w  x  w 
            u v.
              open_in (subtopology euclidean s) u  P v  x  u  u  v 
              v  w
   
   [<a name="midpoint-val"><b>midpoint</b></a>]  Definition
      
       a b. midpoint (a,b) = 2 * (a + b)
   
   [<a name="net_TY_DEF-val"><b>net_TY_DEF</b></a>]  Definition
      
       rep. TYPE_DEFINITION isnet rep
   
   [<a name="netlimit-val"><b>netlimit</b></a>]  Definition
      
       net. netlimit net = @a. x. netord net x a
   
   [<a name="open_segment-val"><b>open_segment</b></a>]  Definition
      
       a b. segment (a,b) = segment [(a,b)] DIFF {a; b}
   
   [<a name="reallim-val"><b>reallim</b></a>]  Definition
      
       net f. lim net f = @l. (f  l) net
   
   [<a name="sequentially-val"><b>sequentially</b></a>]  Definition
      
       sequentially = mk_net (m n. m  n)
   
   [<a name="set_diameter_def-val"><b>set_diameter_def</b></a>]  Definition
      
       d s.
          set_diameter d s =
          if s =  then 0 else sup {dist d (x,y) | x  s  y  s}
   
   [<a name="set_dist_def-val"><b>set_dist_def</b></a>]  Definition
      
       d s t.
          set_dist d (s,t) =
          if s =   t =  then 0 else inf {dist d (x,y) | x  s  y  t}
   
   [<a name="span-val"><b>span</b></a>]  Definition
      
       s. span s = subspace hull s
   
   [<a name="sphere-val"><b>sphere</b></a>]  Definition
      
       x e. sphere (x,e) = {y | dist (x,y) = e}
   
   [<a name="subspace-val"><b>subspace</b></a>]  Definition
      
       s. subspace s 
            0  s  (x y. x  s  y  s  x + y  s) 
            c x. x  s  c * x  s
   
   [<a name="suminf_def-val"><b>suminf_def</b></a>]  Definition
      
       s f. suminf s f = @l. (f sums l) s
   
   [<a name="summable_def-val"><b>summable_def</b></a>]  Definition
      
       s f. summable s f  l. (f sums l) s
   
   [<a name="sums_def-val"><b>sums_def</b></a>]  Definition
      
       f l s.
          (f sums l) s  ((n. sum (s  {0 .. n}) f)  l) sequentially
   
   [<a name="tendsto_real-val"><b>tendsto_real</b></a>]  Definition
      
       f l net.
          (f  l) net  e. 0 &lt; e  eventually (x. dist (f x,l) &lt; e) net
   
   [<a name="trivial_limit-val"><b>trivial_limit</b></a>]  Definition
      
       net.
          trivial_limit net 
          (a b. a = b) 
          a b. a  b  x. netord net x a  netord net x b
   
   [<a name="uniformly_continuous_on-val"><b>uniformly_continuous_on</b></a>]  Definition
      
       f s.
          f uniformly_continuous_on s 
          e. 0 &lt; e 
              d. 0 &lt; d 
                  x x'.
                    x  s  x'  s  dist (x',x) &lt; d  dist (f x',f x) &lt; e
   
   [<a name="within-val"><b>within</b></a>]  Definition
      
       net s. (net within s) = mk_net (x y. netord net x y  x  s)
   
   [<a name="ABS_CAUCHY_SCHWARZ_ABS_EQ-val"><b>ABS_CAUCHY_SCHWARZ_ABS_EQ</b></a>]  Theorem
      
       x y.
          abs (x * y) = abs x * abs y 
          abs x * y = abs y * x  abs x * y = -abs y * x
   
   [<a name="ABS_CAUCHY_SCHWARZ_EQ-val"><b>ABS_CAUCHY_SCHWARZ_EQ</b></a>]  Theorem
      
       x y. x * y = abs x * abs y  abs x * y = abs y * x
   
   [<a name="ABS_CAUCHY_SCHWARZ_EQUAL-val"><b>ABS_CAUCHY_SCHWARZ_EQUAL</b></a>]  Theorem
      
       x y. abs (x * y) = abs x * abs y  collinear {0; x; y}
   
   [<a name="ABS_SUM_TRIVIAL_LEMMA-val"><b>ABS_SUM_TRIVIAL_LEMMA</b></a>]  Theorem
      
       e. 0 &lt; e 
            (P  abs (sum (s  {m .. n}) f) &lt; e 
             P  n &lt; m  abs (sum (s  {m .. n}) f) &lt; e)
   
   [<a name="ABS_TRIANGLE_EQ-val"><b>ABS_TRIANGLE_EQ</b></a>]  Theorem
      
       x y. abs (x + y) = abs x + abs y  abs x * y = abs y * x
   
   [<a name="ABS_TRIANGLE_LE-val"><b>ABS_TRIANGLE_LE</b></a>]  Theorem
      
       x y. abs x + abs y  e  abs (x + y)  e
   
   [<a name="AFFINITY_INVERSES-val"><b>AFFINITY_INVERSES</b></a>]  Theorem
      
       m c.
          m  0 
          (x. m * x + c)  (x. m * x + -(m * c)) = (x. x) 
          (x. m * x + -(m * c))  (x. m * x + c) = (x. x)
   
   [<a name="ALWAYS_EVENTUALLY-val"><b>ALWAYS_EVENTUALLY</b></a>]  Theorem
      
       (x. p x)  eventually p net
   
   [<a name="APPROACHABLE_LT_LE-val"><b>APPROACHABLE_LT_LE</b></a>]  Theorem
      
       P f.
          (d. 0 &lt; d  x. f x &lt; d  P x)  d. 0 &lt; d  x. f x  d  P x
   
   [<a name="AT-val"><b>AT</b></a>]  Theorem
      
       a x y.
          netord (at a) x y  0 &lt; dist (x,a)  dist (x,a)  dist (y,a)
   
   [<a name="AT_INFINITY-val"><b>AT_INFINITY</b></a>]  Theorem
      
       x y. netord at_infinity x y  abs x  abs y
   
   [<a name="AT_NEGINFINITY-val"><b>AT_NEGINFINITY</b></a>]  Theorem
      
       x y. netord at_neginfinity x y  x  y
   
   [<a name="AT_POSINFINITY-val"><b>AT_POSINFINITY</b></a>]  Theorem
      
       x y. netord at_posinfinity x y  x  y
   
   [<a name="BAIRE-val"><b>BAIRE</b></a>]  Theorem
      
       g s.
          locally compact s  countable g 
          (t. t  g  open_in (subtopology euclidean s) t  s  closure t) 
          s  closure (BIGINTER g)
   
   [<a name="BAIRE_ALT-val"><b>BAIRE_ALT</b></a>]  Theorem
      
       g s.
          locally compact s  s    countable g  BIGUNION g = s 
          t u. t  g  open_in (subtopology euclidean s) u  u  closure t
   
   [<a name="BALL-val"><b>BALL</b></a>]  Theorem
      
       x r.
          cball (x,r) = interval [(x  r,x + r)] 
          ball (x,r) = interval (x  r,x + r)
   
   [<a name="BALL_EMPTY-val"><b>BALL_EMPTY</b></a>]  Theorem
      
       x e. e  0  ball (x,e) = 
   
   [<a name="BALL_EQ_EMPTY-val"><b>BALL_EQ_EMPTY</b></a>]  Theorem
      
       x e. ball (x,e) =   e  0
   
   [<a name="BALL_INTERVAL-val"><b>BALL_INTERVAL</b></a>]  Theorem
      
       x e. ball (x,e) = interval (x  e,x + e)
   
   [<a name="BALL_INTERVAL_0-val"><b>BALL_INTERVAL_0</b></a>]  Theorem
      
       e. ball (0,e) = interval (-e,e)
   
   [<a name="BALL_LINEAR_IMAGE-val"><b>BALL_LINEAR_IMAGE</b></a>]  Theorem
      
       f x r.
          linear f  (y. x. f x = y)  (x. abs (f x) = abs x) 
          ball (f x,r) = IMAGE f (ball (x,r))
   
   [<a name="BALL_MAX_UNION-val"><b>BALL_MAX_UNION</b></a>]  Theorem
      
       a r s. ball (a,max r s) = ball (a,r)  ball (a,s)
   
   [<a name="BALL_MIN_INTER-val"><b>BALL_MIN_INTER</b></a>]  Theorem
      
       a r s. ball (a,min r s) = ball (a,r)  ball (a,s)
   
   [<a name="BALL_SCALING-val"><b>BALL_SCALING</b></a>]  Theorem
      
       c. 0 &lt; c 
            x r. ball (c * x,c * r) = IMAGE (x. c * x) (ball (x,r))
   
   [<a name="BALL_SUBSET_CBALL-val"><b>BALL_SUBSET_CBALL</b></a>]  Theorem
      
       x e. ball (x,e)  cball (x,e)
   
   [<a name="BALL_TRANSLATION-val"><b>BALL_TRANSLATION</b></a>]  Theorem
      
       a x r. ball (a + x,r) = IMAGE (y. a + y) (ball (x,r))
   
   [<a name="BALL_TRIVIAL-val"><b>BALL_TRIVIAL</b></a>]  Theorem
      
       x. ball (x,0) = 
   
   [<a name="BALL_UNION_SPHERE-val"><b>BALL_UNION_SPHERE</b></a>]  Theorem
      
       a r. ball (a,r)  sphere (a,r) = cball (a,r)
   
   [<a name="BANACH_FIX-val"><b>BANACH_FIX</b></a>]  Theorem
      
       f s c.
          complete s  s    0  c  c &lt; 1  IMAGE f s  s 
          (x y. x  s  y  s  dist (f x,f y)  c * dist (x,y)) 
          !x. x  s  f x = x
   
   [<a name="BASIS_CARD_EQ_DIM-val"><b>BASIS_CARD_EQ_DIM</b></a>]  Theorem
      
       v b.
          b  v  v  span b  independent b  FINITE b  CARD b = dim v
   
   [<a name="BASIS_EXISTS-val"><b>BASIS_EXISTS</b></a>]  Theorem
      
       v. b. b  v  independent b  v  span b  b HAS_SIZE dim v
   
   [<a name="BASIS_HAS_SIZE_DIM-val"><b>BASIS_HAS_SIZE_DIM</b></a>]  Theorem
      
       v b. independent b  span b = v  b HAS_SIZE dim v
   
   [<a name="BETWEEN_ABS-val"><b>BETWEEN_ABS</b></a>]  Theorem
      
       a b x.
          between x (a,b)  abs (x  a) * (b  x) = abs (b  x) * (x  a)
   
   [<a name="BETWEEN_ANTISYM-val"><b>BETWEEN_ANTISYM</b></a>]  Theorem
      
       a b c. between a (b,c)  between b (a,c)  a = b
   
   [<a name="BETWEEN_IMP_COLLINEAR-val"><b>BETWEEN_IMP_COLLINEAR</b></a>]  Theorem
      
       a b x. between x (a,b)  collinear {a; x; b}
   
   [<a name="BETWEEN_IN_SEGMENT-val"><b>BETWEEN_IN_SEGMENT</b></a>]  Theorem
      
       x a b. between x (a,b)  x  segment [(a,b)]
   
   [<a name="BETWEEN_MIDPOINT-val"><b>BETWEEN_MIDPOINT</b></a>]  Theorem
      
       a b.
          between (midpoint (a,b)) (a,b)  between (midpoint (a,b)) (b,a)
   
   [<a name="BETWEEN_REFL-val"><b>BETWEEN_REFL</b></a>]  Theorem
      
       a b. between a (a,b)  between b (a,b)  between a (a,a)
   
   [<a name="BETWEEN_REFL_EQ-val"><b>BETWEEN_REFL_EQ</b></a>]  Theorem
      
       a x. between x (a,a)  x = a
   
   [<a name="BETWEEN_SYM-val"><b>BETWEEN_SYM</b></a>]  Theorem
      
       a b x. between x (a,b)  between x (b,a)
   
   [<a name="BETWEEN_TRANS-val"><b>BETWEEN_TRANS</b></a>]  Theorem
      
       a b c d. between a (b,c)  between d (a,c)  between d (b,c)
   
   [<a name="BETWEEN_TRANS_2-val"><b>BETWEEN_TRANS_2</b></a>]  Theorem
      
       a b c d. between a (b,c)  between d (a,b)  between a (c,d)
   
   [<a name="BIGUNION_COMPONENTS-val"><b>BIGUNION_COMPONENTS</b></a>]  Theorem
      
       u. u = BIGUNION (components u)
   
   [<a name="BIGUNION_CONNECTED_COMPONENT-val"><b>BIGUNION_CONNECTED_COMPONENT</b></a>]  Theorem
      
       s. BIGUNION {connected_component s x | x | x  s} = s
   
   [<a name="BIGUNION_DIFF-val"><b>BIGUNION_DIFF</b></a>]  Theorem
      
       s t. BIGUNION s DIFF t = BIGUNION {x DIFF t | x  s}
   
   [<a name="BIGUNION_MONO-val"><b>BIGUNION_MONO</b></a>]  Theorem
      
       (x. x  s  y. y  t  x  y)  BIGUNION s  BIGUNION t
   
   [<a name="BIGUNION_MONO_IMAGE-val"><b>BIGUNION_MONO_IMAGE</b></a>]  Theorem
      
       (x. x  s  f x  g x) 
        BIGUNION (IMAGE f s)  BIGUNION (IMAGE g s)
   
   [<a name="BILINEAR_BOUNDED-val"><b>BILINEAR_BOUNDED</b></a>]  Theorem
      
       h. bilinear h  B. x y. abs (h x y)  B * abs x * abs y
   
   [<a name="BILINEAR_BOUNDED_POS-val"><b>BILINEAR_BOUNDED_POS</b></a>]  Theorem
      
       h. bilinear h  B. 0 &lt; B  x y. abs (h x y)  B * abs x * abs y
   
   [<a name="BILINEAR_CONTINUOUS_COMPOSE-val"><b>BILINEAR_CONTINUOUS_COMPOSE</b></a>]  Theorem
      
       net f g h.
          f continuous net  g continuous net  bilinear h 
          (x. h (f x) (g x)) continuous net
   
   [<a name="BILINEAR_CONTINUOUS_ON_COMPOSE-val"><b>BILINEAR_CONTINUOUS_ON_COMPOSE</b></a>]  Theorem
      
       f g h s.
          f continuous_on s  g continuous_on s  bilinear h 
          (x. h (f x) (g x)) continuous_on s
   
   [<a name="BILINEAR_DOT-val"><b>BILINEAR_DOT</b></a>]  Theorem
      
       bilinear (x y. x * y)
   
   [<a name="BILINEAR_LADD-val"><b>BILINEAR_LADD</b></a>]  Theorem
      
       h x y z. bilinear h  h (x + y) z = h x z + h y z
   
   [<a name="BILINEAR_LMUL-val"><b>BILINEAR_LMUL</b></a>]  Theorem
      
       h c x y. bilinear h  h (c * x) y = c * h x y
   
   [<a name="BILINEAR_LNEG-val"><b>BILINEAR_LNEG</b></a>]  Theorem
      
       h x y. bilinear h  h (-x) y = -h x y
   
   [<a name="BILINEAR_LSUB-val"><b>BILINEAR_LSUB</b></a>]  Theorem
      
       h x y z. bilinear h  h (x  y) z = h x z  h y z
   
   [<a name="BILINEAR_LZERO-val"><b>BILINEAR_LZERO</b></a>]  Theorem
      
       h x. bilinear h  h 0 x = 0
   
   [<a name="BILINEAR_RADD-val"><b>BILINEAR_RADD</b></a>]  Theorem
      
       h x y z. bilinear h  h x (y + z) = h x y + h x z
   
   [<a name="BILINEAR_RMUL-val"><b>BILINEAR_RMUL</b></a>]  Theorem
      
       h c x y. bilinear h  h x (c * y) = c * h x y
   
   [<a name="BILINEAR_RNEG-val"><b>BILINEAR_RNEG</b></a>]  Theorem
      
       h x y. bilinear h  h x (-y) = -h x y
   
   [<a name="BILINEAR_RSUB-val"><b>BILINEAR_RSUB</b></a>]  Theorem
      
       h x y z. bilinear h  h x (y  z) = h x y  h x z
   
   [<a name="BILINEAR_RZERO-val"><b>BILINEAR_RZERO</b></a>]  Theorem
      
       h x. bilinear h  h x 0 = 0
   
   [<a name="BILINEAR_SUM-val"><b>BILINEAR_SUM</b></a>]  Theorem
      
       h. bilinear h  FINITE s  FINITE t 
            h (sum s f) (sum t g) = sum (s  t) ((i,j). h (f i) (g j))
   
   [<a name="BILINEAR_SUM_PARTIAL_PRE-val"><b>BILINEAR_SUM_PARTIAL_PRE</b></a>]  Theorem
      
       f g h m n.
          bilinear h 
          sum {m .. n} (k. h (f k) (g k  g (k  1))) =
          if m  n then
            h (f (n + 1)) (g n)  h (f m) (g (m  1)) 
            sum {m .. n} (k. h (f (k + 1)  f k) (g k))
          else 0
   
   [<a name="BILINEAR_SUM_PARTIAL_SUC-val"><b>BILINEAR_SUM_PARTIAL_SUC</b></a>]  Theorem
      
       f g h m n.
          bilinear h 
          sum {m .. n} (k. h (f k) (g (k + 1)  g k)) =
          if m  n then
            h (f (n + 1)) (g (n + 1))  h (f m) (g m) 
            sum {m .. n} (k. h (f (k + 1)  f k) (g (k + 1)))
          else 0
   
   [<a name="BILINEAR_SWAP-val"><b>BILINEAR_SWAP</b></a>]  Theorem
      
       op. bilinear (x y. op y x)  bilinear op
   
   [<a name="BILINEAR_UNIFORMLY_CONTINUOUS_ON_COMPOSE-val"><b>BILINEAR_UNIFORMLY_CONTINUOUS_ON_COMPOSE</b></a>]  Theorem
      
       f g h s.
          f uniformly_continuous_on s  g uniformly_continuous_on s 
          bilinear h  bounded (IMAGE f s)  bounded (IMAGE g s) 
          (x. h (f x) (g x)) uniformly_continuous_on s
   
   [<a name="BOLZANO_WEIERSTRASS-val"><b>BOLZANO_WEIERSTRASS</b></a>]  Theorem
      
       s. bounded s  INFINITE s  x. x limit_point_of s
   
   [<a name="BOLZANO_WEIERSTRASS_CONTRAPOS-val"><b>BOLZANO_WEIERSTRASS_CONTRAPOS</b></a>]  Theorem
      
       s t.
          compact s  t  s  (x. x  s  (x limit_point_of t)) 
          FINITE t
   
   [<a name="BOLZANO_WEIERSTRASS_IMP_BOUNDED-val"><b>BOLZANO_WEIERSTRASS_IMP_BOUNDED</b></a>]  Theorem
      
       s. (t. INFINITE t  t  s  x. x limit_point_of t)  bounded s
   
   [<a name="BOLZANO_WEIERSTRASS_IMP_CLOSED-val"><b>BOLZANO_WEIERSTRASS_IMP_CLOSED</b></a>]  Theorem
      
       s. (t. INFINITE t  t  s  x. x  s  x limit_point_of t) 
            closed s
   
   [<a name="BOUNDED_BALL-val"><b>BOUNDED_BALL</b></a>]  Theorem
      
       x e. bounded (ball (x,e))
   
   [<a name="BOUNDED_BIGINTER-val"><b>BOUNDED_BIGINTER</b></a>]  Theorem
      
       f. (s. s  f  bounded s)  bounded (BIGINTER f)
   
   [<a name="BOUNDED_BIGUNION-val"><b>BOUNDED_BIGUNION</b></a>]  Theorem
      
       f. FINITE f  (s. s  f  bounded s)  bounded (BIGUNION f)
   
   [<a name="BOUNDED_CBALL-val"><b>BOUNDED_CBALL</b></a>]  Theorem
      
       x e. bounded (cball (x,e))
   
   [<a name="BOUNDED_CLOSED_CHAIN-val"><b>BOUNDED_CLOSED_CHAIN</b></a>]  Theorem
      
       f b.
          (s. s  f  closed s  s  ) 
          (s t. s  f  t  f  s  t  t  s)  b  f  bounded b 
          BIGINTER f  
   
   [<a name="BOUNDED_CLOSED_IMP_COMPACT-val"><b>BOUNDED_CLOSED_IMP_COMPACT</b></a>]  Theorem
      
       s. bounded s  closed s  compact s
   
   [<a name="BOUNDED_CLOSED_INTERVAL-val"><b>BOUNDED_CLOSED_INTERVAL</b></a>]  Theorem
      
       a b. bounded (interval [(a,b)])
   
   [<a name="BOUNDED_CLOSED_NEST-val"><b>BOUNDED_CLOSED_NEST</b></a>]  Theorem
      
       s. (n. closed (s n))  (n. s n  ) 
            (m n. m  n  s n  s m)  bounded (s 0) 
            a. n. a  s n
   
   [<a name="BOUNDED_CLOSURE-val"><b>BOUNDED_CLOSURE</b></a>]  Theorem
      
       s. bounded s  bounded (closure s)
   
   [<a name="BOUNDED_CLOSURE_EQ-val"><b>BOUNDED_CLOSURE_EQ</b></a>]  Theorem
      
       s. bounded (closure s)  bounded s
   
   [<a name="BOUNDED_COMPONENTWISE-val"><b>BOUNDED_COMPONENTWISE</b></a>]  Theorem
      
       s. bounded s  bounded (IMAGE (x. x) s)
   
   [<a name="BOUNDED_DECREASING_CONVERGENT-val"><b>BOUNDED_DECREASING_CONVERGENT</b></a>]  Theorem
      
       s. bounded {s n | n  (:num)}  (n. s (SUC n)  s n) 
            l. (s  l) sequentially
   
   [<a name="BOUNDED_DIFF-val"><b>BOUNDED_DIFF</b></a>]  Theorem
      
       s t. bounded s  bounded (s DIFF t)
   
   [<a name="BOUNDED_DIFFS-val"><b>BOUNDED_DIFFS</b></a>]  Theorem
      
       s t. bounded s  bounded t  bounded {x  y | x  s  y  t}
   
   [<a name="BOUNDED_EMPTY-val"><b>BOUNDED_EMPTY</b></a>]  Theorem
      
       bounded 
   
   [<a name="BOUNDED_EQ_BOLZANO_WEIERSTRASS-val"><b>BOUNDED_EQ_BOLZANO_WEIERSTRASS</b></a>]  Theorem
      
       s. bounded s  t. t  s  INFINITE t  x. x limit_point_of t
   
   [<a name="BOUNDED_FRONTIER-val"><b>BOUNDED_FRONTIER</b></a>]  Theorem
      
       s. bounded s  bounded (frontier s)
   
   [<a name="BOUNDED_HAS_INF-val"><b>BOUNDED_HAS_INF</b></a>]  Theorem
      
       s. bounded s  s   
            (x. x  s  inf s  x)  b. (x. x  s  b  x)  b  inf s
   
   [<a name="BOUNDED_HAS_SUP-val"><b>BOUNDED_HAS_SUP</b></a>]  Theorem
      
       s. bounded s  s   
            (x. x  s  x  sup s)  b. (x. x  s  x  b)  sup s  b
   
   [<a name="BOUNDED_INCREASING_CONVERGENT-val"><b>BOUNDED_INCREASING_CONVERGENT</b></a>]  Theorem
      
       s. bounded {s n | n  (:num)}  (n. s n  s (SUC n)) 
            l. (s  l) sequentially
   
   [<a name="BOUNDED_INSERT-val"><b>BOUNDED_INSERT</b></a>]  Theorem
      
       x s. bounded (x INSERT s)  bounded s
   
   [<a name="BOUNDED_INTER-val"><b>BOUNDED_INTER</b></a>]  Theorem
      
       s t. bounded s  bounded t  bounded (s  t)
   
   [<a name="BOUNDED_INTERIOR-val"><b>BOUNDED_INTERIOR</b></a>]  Theorem
      
       s. bounded s  bounded (interior s)
   
   [<a name="BOUNDED_INTERVAL-val"><b>BOUNDED_INTERVAL</b></a>]  Theorem
      
       (a b. bounded (interval [(a,b)]))  a b. bounded (interval (a,b))
   
   [<a name="BOUNDED_LINEAR_IMAGE-val"><b>BOUNDED_LINEAR_IMAGE</b></a>]  Theorem
      
       f s. bounded s  linear f  bounded (IMAGE f s)
   
   [<a name="BOUNDED_NEGATIONS-val"><b>BOUNDED_NEGATIONS</b></a>]  Theorem
      
       s. bounded s  bounded (IMAGE (x. -x) s)
   
   [<a name="BOUNDED_PARTIAL_SUMS-val"><b>BOUNDED_PARTIAL_SUMS</b></a>]  Theorem
      
       f k.
          bounded {sum {k .. n} f | n  (:num)} 
          bounded {sum {m .. n} f | m  (:num)  n  (:num)}
   
   [<a name="BOUNDED_POS-val"><b>BOUNDED_POS</b></a>]  Theorem
      
       s. bounded s  b. 0 &lt; b  x. x  s  abs x  b
   
   [<a name="BOUNDED_POS_LT-val"><b>BOUNDED_POS_LT</b></a>]  Theorem
      
       s. bounded s  b. 0 &lt; b  x. x  s  abs x &lt; b
   
   [<a name="BOUNDED_SCALING-val"><b>BOUNDED_SCALING</b></a>]  Theorem
      
       c s. bounded s  bounded (IMAGE (x. c * x) s)
   
   [<a name="BOUNDED_SING-val"><b>BOUNDED_SING</b></a>]  Theorem
      
       a. bounded {a}
   
   [<a name="BOUNDED_SPHERE-val"><b>BOUNDED_SPHERE</b></a>]  Theorem
      
       a r. bounded (sphere (a,r))
   
   [<a name="BOUNDED_SUBSET-val"><b>BOUNDED_SUBSET</b></a>]  Theorem
      
       s t. bounded t  s  t  bounded s
   
   [<a name="BOUNDED_SUBSET_BALL-val"><b>BOUNDED_SUBSET_BALL</b></a>]  Theorem
      
       s x. bounded s  r. 0 &lt; r  s  ball (x,r)
   
   [<a name="BOUNDED_SUBSET_CBALL-val"><b>BOUNDED_SUBSET_CBALL</b></a>]  Theorem
      
       s x. bounded s  r. 0 &lt; r  s  cball (x,r)
   
   [<a name="BOUNDED_SUBSET_CLOSED_INTERVAL-val"><b>BOUNDED_SUBSET_CLOSED_INTERVAL</b></a>]  Theorem
      
       s. bounded s  a b. s  interval [(a,b)]
   
   [<a name="BOUNDED_SUBSET_CLOSED_INTERVAL_SYMMETRIC-val"><b>BOUNDED_SUBSET_CLOSED_INTERVAL_SYMMETRIC</b></a>]  Theorem
      
       s. bounded s  a. s  interval [(-a,a)]
   
   [<a name="BOUNDED_SUBSET_OPEN_INTERVAL-val"><b>BOUNDED_SUBSET_OPEN_INTERVAL</b></a>]  Theorem
      
       s. bounded s  a b. s  interval (a,b)
   
   [<a name="BOUNDED_SUBSET_OPEN_INTERVAL_SYMMETRIC-val"><b>BOUNDED_SUBSET_OPEN_INTERVAL_SYMMETRIC</b></a>]  Theorem
      
       s. bounded s  a. s  interval (-a,a)
   
   [<a name="BOUNDED_SUMS-val"><b>BOUNDED_SUMS</b></a>]  Theorem
      
       s t. bounded s  bounded t  bounded {x + y | x  s  y  t}
   
   [<a name="BOUNDED_SUMS_IMAGE-val"><b>BOUNDED_SUMS_IMAGE</b></a>]  Theorem
      
       f g t.
          bounded {f x | x  t}  bounded {g x | x  t} 
          bounded {f x + g x | x  t}
   
   [<a name="BOUNDED_SUMS_IMAGES-val"><b>BOUNDED_SUMS_IMAGES</b></a>]  Theorem
      
       f t s.
          FINITE s  (a. a  s  bounded {f x a | x  t}) 
          bounded {sum s (f x) | x  t}
   
   [<a name="BOUNDED_TRANSLATION-val"><b>BOUNDED_TRANSLATION</b></a>]  Theorem
      
       a s. bounded s  bounded (IMAGE (x. a + x) s)
   
   [<a name="BOUNDED_TRANSLATION_EQ-val"><b>BOUNDED_TRANSLATION_EQ</b></a>]  Theorem
      
       a s. bounded (IMAGE (x. a + x) s)  bounded s
   
   [<a name="BOUNDED_UNIFORMLY_CONTINUOUS_IMAGE-val"><b>BOUNDED_UNIFORMLY_CONTINUOUS_IMAGE</b></a>]  Theorem
      
       f s. f uniformly_continuous_on s  bounded s  bounded (IMAGE f s)
   
   [<a name="BOUNDED_UNION-val"><b>BOUNDED_UNION</b></a>]  Theorem
      
       s t. bounded (s  t)  bounded s  bounded t
   
   [<a name="CARD_EQ_BALL-val"><b>CARD_EQ_BALL</b></a>]  Theorem
      
       a r. 0 &lt; r  ball (a,r)  (:real)
   
   [<a name="CARD_EQ_CBALL-val"><b>CARD_EQ_CBALL</b></a>]  Theorem
      
       a r. 0 &lt; r  cball (a,r)  (:real)
   
   [<a name="CARD_EQ_EUCLIDEAN-val"><b>CARD_EQ_EUCLIDEAN</b></a>]  Theorem
      
       (:real)  (:real)
   
   [<a name="CARD_EQ_INTERVAL-val"><b>CARD_EQ_INTERVAL</b></a>]  Theorem
      
       (a b. interval (a,b)    interval [(a,b)]  (:real)) 
        a b. interval (a,b)    interval (a,b)  (:real)
   
   [<a name="CARD_EQ_OPEN-val"><b>CARD_EQ_OPEN</b></a>]  Theorem
      
       s. open s  s    s  (:real)
   
   [<a name="CARD_EQ_REAL-val"><b>CARD_EQ_REAL</b></a>]  Theorem
      
       (:real)  (:num -&gt; bool)
   
   [<a name="CARD_EQ_REAL_IMP_UNCOUNTABLE-val"><b>CARD_EQ_REAL_IMP_UNCOUNTABLE</b></a>]  Theorem
      
       s. s  (:real)  uncountable s
   
   [<a name="CARD_FRONTIER_INTERVAL-val"><b>CARD_FRONTIER_INTERVAL</b></a>]  Theorem
      
       s. is_interval s  FINITE (frontier s)  CARD (frontier s)  2
   
   [<a name="CARD_GE_DIM_INDEPENDENT-val"><b>CARD_GE_DIM_INDEPENDENT</b></a>]  Theorem
      
       v b. b  v  independent b  dim v  CARD b  v  span b
   
   [<a name="CARD_STDBASIS-val"><b>CARD_STDBASIS</b></a>]  Theorem
      
       CARD {1} = 1
   
   [<a name="CAUCHY-val"><b>CAUCHY</b></a>]  Theorem
      
       s. cauchy s  e. 0 &lt; e  N. n. n  N  dist (s n,s N) &lt; e
   
   [<a name="CAUCHY_CONTINUOUS_EXTENDS_TO_CLOSURE-val"><b>CAUCHY_CONTINUOUS_EXTENDS_TO_CLOSURE</b></a>]  Theorem
      
       f s.
          (x. cauchy x  (n. x n  s)  cauchy (f  x)) 
          g. g continuous_on closure s  x. x  s  g x = f x
   
   [<a name="CAUCHY_CONTINUOUS_IMP_CONTINUOUS-val"><b>CAUCHY_CONTINUOUS_IMP_CONTINUOUS</b></a>]  Theorem
      
       f s.
          (x. cauchy x  (n. x n  s)  cauchy (f  x)) 
          f continuous_on s
   
   [<a name="CAUCHY_CONTINUOUS_UNIQUENESS_LEMMA-val"><b>CAUCHY_CONTINUOUS_UNIQUENESS_LEMMA</b></a>]  Theorem
      
       f s.
          (x. cauchy x  (n. x n  s)  cauchy (f  x)) 
          a x.
            (n. x n  s)  (x  a) sequentially 
            l. (f  x  l) sequentially 
                y. (n. y n  s)  (y  a) sequentially 
                    (f  y  l) sequentially
   
   [<a name="CAUCHY_IMP_BOUNDED-val"><b>CAUCHY_IMP_BOUNDED</b></a>]  Theorem
      
       s. cauchy s  bounded {y | (n. y = s n)}
   
   [<a name="CAUCHY_ISOMETRIC-val"><b>CAUCHY_ISOMETRIC</b></a>]  Theorem
      
       f s e x.
          0 &lt; e  subspace s  linear f 
          (x. x  s  abs (f x)  e * abs x)  (n. x n  s) 
          cauchy (f  x) 
          cauchy x
   
   [<a name="CBALL_DIFF_BALL-val"><b>CBALL_DIFF_BALL</b></a>]  Theorem
      
       a r. cball (a,r) DIFF ball (a,r) = sphere (a,r)
   
   [<a name="CBALL_DIFF_SPHERE-val"><b>CBALL_DIFF_SPHERE</b></a>]  Theorem
      
       a r. cball (a,r) DIFF sphere (a,r) = ball (a,r)
   
   [<a name="CBALL_EMPTY-val"><b>CBALL_EMPTY</b></a>]  Theorem
      
       x e. e &lt; 0  cball (x,e) = 
   
   [<a name="CBALL_EQ_EMPTY-val"><b>CBALL_EQ_EMPTY</b></a>]  Theorem
      
       x e. cball (x,e) =   e &lt; 0
   
   [<a name="CBALL_EQ_SING-val"><b>CBALL_EQ_SING</b></a>]  Theorem
      
       x e. cball (x,e) = {x}  e = 0
   
   [<a name="CBALL_INTERVAL-val"><b>CBALL_INTERVAL</b></a>]  Theorem
      
       x e. cball (x,e) = interval [(x  e,x + e)]
   
   [<a name="CBALL_INTERVAL_0-val"><b>CBALL_INTERVAL_0</b></a>]  Theorem
      
       e. cball (0,e) = interval [(-e,e)]
   
   [<a name="CBALL_LINEAR_IMAGE-val"><b>CBALL_LINEAR_IMAGE</b></a>]  Theorem
      
       f x r.
          linear f  (y. x. f x = y)  (x. abs (f x) = abs x) 
          cball (f x,r) = IMAGE f (cball (x,r))
   
   [<a name="CBALL_MAX_UNION-val"><b>CBALL_MAX_UNION</b></a>]  Theorem
      
       a r s. cball (a,max r s) = cball (a,r)  cball (a,s)
   
   [<a name="CBALL_MIN_INTER-val"><b>CBALL_MIN_INTER</b></a>]  Theorem
      
       x d e. cball (x,min d e) = cball (x,d)  cball (x,e)
   
   [<a name="CBALL_SCALING-val"><b>CBALL_SCALING</b></a>]  Theorem
      
       c. 0 &lt; c 
            x r. cball (c * x,c * r) = IMAGE (x. c * x) (cball (x,r))
   
   [<a name="CBALL_SING-val"><b>CBALL_SING</b></a>]  Theorem
      
       x e. e = 0  cball (x,e) = {x}
   
   [<a name="CBALL_TRANSLATION-val"><b>CBALL_TRANSLATION</b></a>]  Theorem
      
       a x r. cball (a + x,r) = IMAGE (y. a + y) (cball (x,r))
   
   [<a name="CBALL_TRIVIAL-val"><b>CBALL_TRIVIAL</b></a>]  Theorem
      
       x. cball (x,0) = {x}
   
   [<a name="CENTRE_IN_BALL-val"><b>CENTRE_IN_BALL</b></a>]  Theorem
      
       x e. x  ball (x,e)  0 &lt; e
   
   [<a name="CENTRE_IN_CBALL-val"><b>CENTRE_IN_CBALL</b></a>]  Theorem
      
       x e. x  cball (x,e)  0  e
   
   [<a name="CLOPEN-val"><b>CLOPEN</b></a>]  Theorem
      
       s. closed s  open s  s =   s = (:real)
   
   [<a name="CLOPEN_BIGUNION_COMPONENTS-val"><b>CLOPEN_BIGUNION_COMPONENTS</b></a>]  Theorem
      
       u s.
          closed_in (subtopology euclidean u) s 
          open_in (subtopology euclidean u) s 
          k. k  components u  s = BIGUNION k
   
   [<a name="CLOPEN_IN_COMPONENTS-val"><b>CLOPEN_IN_COMPONENTS</b></a>]  Theorem
      
       u s.
          closed_in (subtopology euclidean u) s 
          open_in (subtopology euclidean u) s  connected s  s   
          s  components u
   
   [<a name="CLOSED-val"><b>CLOSED</b></a>]  Theorem
      
       s. closed s 
            x. (e. 0 &lt; e  x'. x'  s  x'  x  abs (x'  x) &lt; e) 
                x  s
   
   [<a name="CLOSED_APPROACHABLE-val"><b>CLOSED_APPROACHABLE</b></a>]  Theorem
      
       x s. closed s  ((e. 0 &lt; e  y. y  s  dist (y,x) &lt; e)  x  s)
   
   [<a name="CLOSED_AS_GDELTA-val"><b>CLOSED_AS_GDELTA</b></a>]  Theorem
      
       s. closed s  gdelta s
   
   [<a name="CLOSED_BIGINTER-val"><b>CLOSED_BIGINTER</b></a>]  Theorem
      
       f. (s. s  f  closed s)  closed (BIGINTER f)
   
   [<a name="CLOSED_BIGINTER_COMPACT-val"><b>CLOSED_BIGINTER_COMPACT</b></a>]  Theorem
      
       s. closed s  e. compact (cball (0,e)  s)
   
   [<a name="CLOSED_BIGUNION-val"><b>CLOSED_BIGUNION</b></a>]  Theorem
      
       s. FINITE s  (t. t  s  closed t)  closed (BIGUNION s)
   
   [<a name="CLOSED_CBALL-val"><b>CLOSED_CBALL</b></a>]  Theorem
      
       x e. closed (cball (x,e))
   
   [<a name="CLOSED_CLOSURE-val"><b>CLOSED_CLOSURE</b></a>]  Theorem
      
       s. closed (closure s)
   
   [<a name="CLOSED_COMPACT_DIFFERENCES-val"><b>CLOSED_COMPACT_DIFFERENCES</b></a>]  Theorem
      
       s t. closed s  compact t  closed {x  y | x  s  y  t}
   
   [<a name="CLOSED_COMPACT_SUMS-val"><b>CLOSED_COMPACT_SUMS</b></a>]  Theorem
      
       s t. closed s  compact t  closed {x + y | x  s  y  t}
   
   [<a name="CLOSED_COMPONENTS-val"><b>CLOSED_COMPONENTS</b></a>]  Theorem
      
       s c. closed s  c  components s  closed c
   
   [<a name="CLOSED_CONNECTED_COMPONENT-val"><b>CLOSED_CONNECTED_COMPONENT</b></a>]  Theorem
      
       s x. closed s  closed (connected_component s x)
   
   [<a name="CLOSED_CONTAINS_SEQUENTIAL_LIMIT-val"><b>CLOSED_CONTAINS_SEQUENTIAL_LIMIT</b></a>]  Theorem
      
       s x l. closed s  (n. x n  s)  (x  l) sequentially  l  s
   
   [<a name="CLOSED_DIFF-val"><b>CLOSED_DIFF</b></a>]  Theorem
      
       s t. closed s  open t  closed (s DIFF t)
   
   [<a name="CLOSED_DIFF_OPEN_INTERVAL-val"><b>CLOSED_DIFF_OPEN_INTERVAL</b></a>]  Theorem
      
       a b.
          interval [(a,b)] DIFF interval (a,b) =
          if interval [(a,b)] =  then  else {a; b}
   
   [<a name="CLOSED_EMPTY-val"><b>CLOSED_EMPTY</b></a>]  Theorem
      
       closed 
   
   [<a name="CLOSED_FIP-val"><b>CLOSED_FIP</b></a>]  Theorem
      
       f. (t. t  f  closed t)  (t. t  f  bounded t) 
            (f'. FINITE f'  f'  f  BIGINTER f'  ) 
            BIGINTER f  
   
   [<a name="CLOSED_FORALL-val"><b>CLOSED_FORALL</b></a>]  Theorem
      
       Q. (a. closed {x | Q a x})  closed {x | (a. Q a x)}
   
   [<a name="CLOSED_FORALL_IN-val"><b>CLOSED_FORALL_IN</b></a>]  Theorem
      
       P Q.
          (a. P a  closed {x | Q a x})  closed {x | (a. P a  Q a x)}
   
   [<a name="CLOSED_HALFSPACE_COMPONENT_GE-val"><b>CLOSED_HALFSPACE_COMPONENT_GE</b></a>]  Theorem
      
       a. closed {x | x  a}
   
   [<a name="CLOSED_HALFSPACE_COMPONENT_LE-val"><b>CLOSED_HALFSPACE_COMPONENT_LE</b></a>]  Theorem
      
       a. closed {x | x  a}
   
   [<a name="CLOSED_HALFSPACE_GE-val"><b>CLOSED_HALFSPACE_GE</b></a>]  Theorem
      
       a b. closed {x | a * x  b}
   
   [<a name="CLOSED_HALFSPACE_LE-val"><b>CLOSED_HALFSPACE_LE</b></a>]  Theorem
      
       a b. closed {x | a * x  b}
   
   [<a name="CLOSED_HYPERPLANE-val"><b>CLOSED_HYPERPLANE</b></a>]  Theorem
      
       a b. closed {x | a * x = b}
   
   [<a name="CLOSED_IMP_FIP-val"><b>CLOSED_IMP_FIP</b></a>]  Theorem
      
       s f.
          closed s  (t. t  f  closed t)  (t. t  f  bounded t) 
          (f'. FINITE f'  f'  f  s  BIGINTER f'  ) 
          s  BIGINTER f  
   
   [<a name="CLOSED_IMP_FIP_COMPACT-val"><b>CLOSED_IMP_FIP_COMPACT</b></a>]  Theorem
      
       s f.
          closed s  (t. t  f  compact t) 
          (f'. FINITE f'  f'  f  s  BIGINTER f'  ) 
          s  BIGINTER f  
   
   [<a name="CLOSED_IMP_LOCALLY_COMPACT-val"><b>CLOSED_IMP_LOCALLY_COMPACT</b></a>]  Theorem
      
       s. closed s  locally compact s
   
   [<a name="CLOSED_IN-val"><b>CLOSED_IN</b></a>]  Theorem
      
       s. closed s  closed_in euclidean s
   
   [<a name="CLOSED_INJECTIVE_IMAGE_SUBSPACE-val"><b>CLOSED_INJECTIVE_IMAGE_SUBSPACE</b></a>]  Theorem
      
       f s.
          subspace s  linear f  (x. x  s  f x = 0  x = 0)  closed s 
          closed (IMAGE f s)
   
   [<a name="CLOSED_INJECTIVE_LINEAR_IMAGE-val"><b>CLOSED_INJECTIVE_LINEAR_IMAGE</b></a>]  Theorem
      
       f. linear f  (x y. f x = f y  x = y) 
            s. closed s  closed (IMAGE f s)
   
   [<a name="CLOSED_INJECTIVE_LINEAR_IMAGE_EQ-val"><b>CLOSED_INJECTIVE_LINEAR_IMAGE_EQ</b></a>]  Theorem
      
       f s.
          linear f  (x y. f x = f y  x = y) 
          (closed (IMAGE f s)  closed s)
   
   [<a name="CLOSED_INSERT-val"><b>CLOSED_INSERT</b></a>]  Theorem
      
       a s. closed s  closed (a INSERT s)
   
   [<a name="CLOSED_INTER-val"><b>CLOSED_INTER</b></a>]  Theorem
      
       s t. closed s  closed t  closed (s  t)
   
   [<a name="CLOSED_INTERVAL-val"><b>CLOSED_INTERVAL</b></a>]  Theorem
      
       a b. closed (interval [(a,b)])
   
   [<a name="CLOSED_INTERVAL_EQ-val"><b>CLOSED_INTERVAL_EQ</b></a>]  Theorem
      
       (a b. closed (interval [(a,b)])) 
        a b. closed (interval (a,b))  interval (a,b) = 
   
   [<a name="CLOSED_INTERVAL_IMAGE_UNIT_INTERVAL-val"><b>CLOSED_INTERVAL_IMAGE_UNIT_INTERVAL</b></a>]  Theorem
      
       a b.
          interval [(a,b)]   
          interval [(a,b)] =
          IMAGE (x. a + x)
            (IMAGE (x. @f. f = (b  a) * x) (interval [(0,1)]))
   
   [<a name="CLOSED_INTERVAL_LEFT-val"><b>CLOSED_INTERVAL_LEFT</b></a>]  Theorem
      
       b. closed {x | x  b}
   
   [<a name="CLOSED_INTERVAL_RIGHT-val"><b>CLOSED_INTERVAL_RIGHT</b></a>]  Theorem
      
       a. closed {x | a  x}
   
   [<a name="CLOSED_INTER_COMPACT-val"><b>CLOSED_INTER_COMPACT</b></a>]  Theorem
      
       s t. closed s  compact t  compact (s  t)
   
   [<a name="CLOSED_IN_CLOSED-val"><b>CLOSED_IN_CLOSED</b></a>]  Theorem
      
       s u.
          closed_in (subtopology euclidean u) s  t. closed t  s = u  t
   
   [<a name="CLOSED_IN_CLOSED_EQ-val"><b>CLOSED_IN_CLOSED_EQ</b></a>]  Theorem
      
       s t.
          closed s 
          (closed_in (subtopology euclidean s) t  closed t  t  s)
   
   [<a name="CLOSED_IN_CLOSED_INTER-val"><b>CLOSED_IN_CLOSED_INTER</b></a>]  Theorem
      
       u s. closed s  closed_in (subtopology euclidean u) (u  s)
   
   [<a name="CLOSED_IN_CLOSED_TRANS-val"><b>CLOSED_IN_CLOSED_TRANS</b></a>]  Theorem
      
       s t. closed_in (subtopology euclidean t) s  closed t  closed s
   
   [<a name="CLOSED_IN_COMPACT-val"><b>CLOSED_IN_COMPACT</b></a>]  Theorem
      
       s t. compact s  closed_in (subtopology euclidean s) t  compact t
   
   [<a name="CLOSED_IN_COMPACT_EQ-val"><b>CLOSED_IN_COMPACT_EQ</b></a>]  Theorem
      
       s t.
          compact s 
          (closed_in (subtopology euclidean s) t  compact t  t  s)
   
   [<a name="CLOSED_IN_COMPONENT-val"><b>CLOSED_IN_COMPONENT</b></a>]  Theorem
      
       s c. c  components s  closed_in (subtopology euclidean s) c
   
   [<a name="CLOSED_IN_CONNECTED_COMPONENT-val"><b>CLOSED_IN_CONNECTED_COMPONENT</b></a>]  Theorem
      
       s x. closed_in (subtopology euclidean s) (connected_component s x)
   
   [<a name="CLOSED_IN_INTER_CLOSED-val"><b>CLOSED_IN_INTER_CLOSED</b></a>]  Theorem
      
       s t u.
          closed_in (subtopology euclidean u) s  closed t 
          closed_in (subtopology euclidean u) (s  t)
   
   [<a name="CLOSED_IN_INTER_CLOSURE-val"><b>CLOSED_IN_INTER_CLOSURE</b></a>]  Theorem
      
       s t. closed_in (subtopology euclidean s) t  s  closure t = t
   
   [<a name="CLOSED_IN_LIMPT-val"><b>CLOSED_IN_LIMPT</b></a>]  Theorem
      
       s t.
          closed_in (subtopology euclidean t) s 
          s  t  x. x limit_point_of s  x  t  x  s
   
   [<a name="CLOSED_IN_REFL-val"><b>CLOSED_IN_REFL</b></a>]  Theorem
      
       s. closed_in (subtopology euclidean s) s
   
   [<a name="CLOSED_IN_SING-val"><b>CLOSED_IN_SING</b></a>]  Theorem
      
       u x. closed_in (subtopology euclidean u) {x}  x  u
   
   [<a name="CLOSED_IN_SUBSET_TRANS-val"><b>CLOSED_IN_SUBSET_TRANS</b></a>]  Theorem
      
       s t u.
          closed_in (subtopology euclidean u) s  s  t  t  u 
          closed_in (subtopology euclidean t) s
   
   [<a name="CLOSED_IN_TRANS-val"><b>CLOSED_IN_TRANS</b></a>]  Theorem
      
       s t u.
          closed_in (subtopology euclidean t) s 
          closed_in (subtopology euclidean u) t 
          closed_in (subtopology euclidean u) s
   
   [<a name="CLOSED_IN_TRANS_EQ-val"><b>CLOSED_IN_TRANS_EQ</b></a>]  Theorem
      
       s t.
          (u. closed_in (subtopology euclidean t) u 
               closed_in (subtopology euclidean s) t) 
          closed_in (subtopology euclidean s) t
   
   [<a name="CLOSED_LIMPT-val"><b>CLOSED_LIMPT</b></a>]  Theorem
      
       s. closed s  x. x limit_point_of s  x  s
   
   [<a name="CLOSED_LIMPTS-val"><b>CLOSED_LIMPTS</b></a>]  Theorem
      
       s. closed {x | x limit_point_of s}
   
   [<a name="CLOSED_MAP_CLOSURES-val"><b>CLOSED_MAP_CLOSURES</b></a>]  Theorem
      
       f. (s. closed s  closed (IMAGE f s)) 
            s. closure (IMAGE f s)  IMAGE f (closure s)
   
   [<a name="CLOSED_MAP_FROM_COMPOSITION_INJECTIVE-val"><b>CLOSED_MAP_FROM_COMPOSITION_INJECTIVE</b></a>]  Theorem
      
       f g s t u.
          IMAGE f s  t  IMAGE g t  u  g continuous_on t 
          (x y. x  t  y  t  g x = g y  x = y) 
          (k. closed_in (subtopology euclidean s) k 
               closed_in (subtopology euclidean u) (IMAGE (g  f) k)) 
          k. closed_in (subtopology euclidean s) k 
              closed_in (subtopology euclidean t) (IMAGE f k)
   
   [<a name="CLOSED_MAP_FROM_COMPOSITION_SURJECTIVE-val"><b>CLOSED_MAP_FROM_COMPOSITION_SURJECTIVE</b></a>]  Theorem
      
       f g s t u.
          f continuous_on s  IMAGE f s = t  IMAGE g t  u 
          (k. closed_in (subtopology euclidean s) k 
               closed_in (subtopology euclidean u) (IMAGE (g  f) k)) 
          k. closed_in (subtopology euclidean t) k 
              closed_in (subtopology euclidean u) (IMAGE g k)
   
   [<a name="CLOSED_MAP_IFF_UPPER_HEMICONTINUOUS_PREIMAGE-val"><b>CLOSED_MAP_IFF_UPPER_HEMICONTINUOUS_PREIMAGE</b></a>]  Theorem
      
       f s t.
          IMAGE f s  t 
          ((u. closed_in (subtopology euclidean s) u 
                closed_in (subtopology euclidean t) (IMAGE f u)) 
           u. open_in (subtopology euclidean s) u 
               open_in (subtopology euclidean t)
                 {y | y  t  {x | x  s  f x = y}  u})
   
   [<a name="CLOSED_MAP_IMP_OPEN_MAP-val"><b>CLOSED_MAP_IMP_OPEN_MAP</b></a>]  Theorem
      
       f s t.
          IMAGE f s = t 
          (u. closed_in (subtopology euclidean s) u 
               closed_in (subtopology euclidean t) (IMAGE f u)) 
          (u. open_in (subtopology euclidean s) u 
               open_in (subtopology euclidean s)
                 {x | x  s  f x  IMAGE f u}) 
          u. open_in (subtopology euclidean s) u 
              open_in (subtopology euclidean t) (IMAGE f u)
   
   [<a name="CLOSED_MAP_IMP_QUOTIENT_MAP-val"><b>CLOSED_MAP_IMP_QUOTIENT_MAP</b></a>]  Theorem
      
       f s.
          f continuous_on s 
          (t. closed_in (subtopology euclidean s) t 
               closed_in (subtopology euclidean (IMAGE f s)) (IMAGE f t)) 
          t. t  IMAGE f s 
              (open_in (subtopology euclidean s) {x | x  s  f x  t} 
               open_in (subtopology euclidean (IMAGE f s)) t)
   
   [<a name="CLOSED_MAP_OPEN_SUPERSET_PREIMAGE-val"><b>CLOSED_MAP_OPEN_SUPERSET_PREIMAGE</b></a>]  Theorem
      
       f s t u w.
          (k. closed_in (subtopology euclidean s) k 
               closed_in (subtopology euclidean t) (IMAGE f k)) 
          open_in (subtopology euclidean s) u  w  t 
          {x | x  s  f x  w}  u 
          v. open_in (subtopology euclidean t) v  w  v 
              {x | x  s  f x  v}  u
   
   [<a name="CLOSED_MAP_OPEN_SUPERSET_PREIMAGE_EQ-val"><b>CLOSED_MAP_OPEN_SUPERSET_PREIMAGE_EQ</b></a>]  Theorem
      
       f s t.
          IMAGE f s  t 
          ((k. closed_in (subtopology euclidean s) k 
                closed_in (subtopology euclidean t) (IMAGE f k)) 
           u w.
             open_in (subtopology euclidean s) u  w  t 
             {x | x  s  f x  w}  u 
             v. open_in (subtopology euclidean t) v  w  v 
                 {x | x  s  f x  v}  u)
   
   [<a name="CLOSED_MAP_OPEN_SUPERSET_PREIMAGE_POINT-val"><b>CLOSED_MAP_OPEN_SUPERSET_PREIMAGE_POINT</b></a>]  Theorem
      
       f s t.
          IMAGE f s  t 
          ((k. closed_in (subtopology euclidean s) k 
                closed_in (subtopology euclidean t) (IMAGE f k)) 
           u y.
             open_in (subtopology euclidean s) u  y  t 
             {x | x  s  f x = y}  u 
             v. open_in (subtopology euclidean t) v  y  v 
                 {x | x  s  f x  v}  u)
   
   [<a name="CLOSED_MAP_RESTRICT-val"><b>CLOSED_MAP_RESTRICT</b></a>]  Theorem
      
       f s t t'.
          (u. closed_in (subtopology euclidean s) u 
               closed_in (subtopology euclidean t) (IMAGE f u))  t'  t 
          u. closed_in (subtopology euclidean {x | x  s  f x  t'}) u 
              closed_in (subtopology euclidean t') (IMAGE f u)
   
   [<a name="CLOSED_NEGATIONS-val"><b>CLOSED_NEGATIONS</b></a>]  Theorem
      
       s. closed s  closed (IMAGE (x. -x) s)
   
   [<a name="CLOSED_OPEN_INTERVAL-val"><b>CLOSED_OPEN_INTERVAL</b></a>]  Theorem
      
       a b. a  b  interval [(a,b)] = interval (a,b)  {a; b}
   
   [<a name="CLOSED_POSITIVE_ORTHANT-val"><b>CLOSED_POSITIVE_ORTHANT</b></a>]  Theorem
      
       closed {x | 0  x}
   
   [<a name="CLOSED_SCALING-val"><b>CLOSED_SCALING</b></a>]  Theorem
      
       s c. closed s  closed (IMAGE (x. c * x) s)
   
   [<a name="CLOSED_SEGMENT_LINEAR_IMAGE-val"><b>CLOSED_SEGMENT_LINEAR_IMAGE</b></a>]  Theorem
      
       f a b. linear f  segment [(f a,f b)] = IMAGE f (segment [(a,b)])
   
   [<a name="CLOSED_SEQUENTIAL_LIMITS-val"><b>CLOSED_SEQUENTIAL_LIMITS</b></a>]  Theorem
      
       s. closed s  x l. (n. x n  s)  (x  l) sequentially  l  s
   
   [<a name="CLOSED_SING-val"><b>CLOSED_SING</b></a>]  Theorem
      
       a. closed {a}
   
   [<a name="CLOSED_SPHERE-val"><b>CLOSED_SPHERE</b></a>]  Theorem
      
       a r. closed (sphere (a,r))
   
   [<a name="CLOSED_STANDARD_HYPERPLANE-val"><b>CLOSED_STANDARD_HYPERPLANE</b></a>]  Theorem
      
       a. closed {x | x = a}
   
   [<a name="CLOSED_SUBSET-val"><b>CLOSED_SUBSET</b></a>]  Theorem
      
       s t. s  t  closed s  closed_in (subtopology euclidean t) s
   
   [<a name="CLOSED_SUBSET_EQ-val"><b>CLOSED_SUBSET_EQ</b></a>]  Theorem
      
       u s. closed s  (closed_in (subtopology euclidean u) s  s  u)
   
   [<a name="CLOSED_SUBSTANDARD-val"><b>CLOSED_SUBSTANDARD</b></a>]  Theorem
      
       closed {x | x = 0}
   
   [<a name="CLOSED_UNION-val"><b>CLOSED_UNION</b></a>]  Theorem
      
       s t. closed s  closed t  closed (s  t)
   
   [<a name="CLOSED_UNION_COMPACT_SUBSETS-val"><b>CLOSED_UNION_COMPACT_SUBSETS</b></a>]  Theorem
      
       s. closed s 
            f. (n. compact (f n))  (n. f n  s) 
                (n. f n  f (n + 1))  BIGUNION {f n | n  (:num)} = s 
                k. compact k  k  s  N. n. n  N  k  f n
   
   [<a name="CLOSED_UNIV-val"><b>CLOSED_UNIV</b></a>]  Theorem
      
       closed (:real)
   
   [<a name="CLOSEST_POINT_EXISTS-val"><b>CLOSEST_POINT_EXISTS</b></a>]  Theorem
      
       s a.
          closed s  s   
          closest_point s a  s 
          y. y  s  dist (a,closest_point s a)  dist (a,y)
   
   [<a name="CLOSEST_POINT_IN_FRONTIER-val"><b>CLOSEST_POINT_IN_FRONTIER</b></a>]  Theorem
      
       s x.
          closed s  s    x  interior s 
          closest_point s x  frontier s
   
   [<a name="CLOSEST_POINT_IN_INTERIOR-val"><b>CLOSEST_POINT_IN_INTERIOR</b></a>]  Theorem
      
       s x.
          closed s  s   
          (closest_point s x  interior s  x  interior s)
   
   [<a name="CLOSEST_POINT_IN_SET-val"><b>CLOSEST_POINT_IN_SET</b></a>]  Theorem
      
       s a. closed s  s    closest_point s a  s
   
   [<a name="CLOSEST_POINT_LE-val"><b>CLOSEST_POINT_LE</b></a>]  Theorem
      
       s a x. closed s  x  s  dist (a,closest_point s a)  dist (a,x)
   
   [<a name="CLOSEST_POINT_REFL-val"><b>CLOSEST_POINT_REFL</b></a>]  Theorem
      
       s x. closed s  s    (closest_point s x = x  x  s)
   
   [<a name="CLOSEST_POINT_SELF-val"><b>CLOSEST_POINT_SELF</b></a>]  Theorem
      
       s x. x  s  closest_point s x = x
   
   [<a name="CLOSURE_APPROACHABLE-val"><b>CLOSURE_APPROACHABLE</b></a>]  Theorem
      
       x s. x  closure s  e. 0 &lt; e  y. y  s  dist (y,x) &lt; e
   
   [<a name="CLOSURE_BALL-val"><b>CLOSURE_BALL</b></a>]  Theorem
      
       x e. 0 &lt; e  closure (ball (x,e)) = cball (x,e)
   
   [<a name="CLOSURE_BIGINTER_SUBSET-val"><b>CLOSURE_BIGINTER_SUBSET</b></a>]  Theorem
      
       f. closure (BIGINTER f)  BIGINTER (IMAGE closure f)
   
   [<a name="CLOSURE_BIGUNION-val"><b>CLOSURE_BIGUNION</b></a>]  Theorem
      
       f. FINITE f  closure (BIGUNION f) = BIGUNION {closure s | s  f}
   
   [<a name="CLOSURE_BOUNDED_LINEAR_IMAGE-val"><b>CLOSURE_BOUNDED_LINEAR_IMAGE</b></a>]  Theorem
      
       f s.
          linear f  bounded s  closure (IMAGE f s) = IMAGE f (closure s)
   
   [<a name="CLOSURE_CLOSED-val"><b>CLOSURE_CLOSED</b></a>]  Theorem
      
       s. closed s  closure s = s
   
   [<a name="CLOSURE_CLOSURE-val"><b>CLOSURE_CLOSURE</b></a>]  Theorem
      
       s. closure (closure s) = closure s
   
   [<a name="CLOSURE_COMPLEMENT-val"><b>CLOSURE_COMPLEMENT</b></a>]  Theorem
      
       s. closure ((:real) DIFF s) = (:real) DIFF interior s
   
   [<a name="CLOSURE_EMPTY-val"><b>CLOSURE_EMPTY</b></a>]  Theorem
      
       closure  = 
   
   [<a name="CLOSURE_EQ-val"><b>CLOSURE_EQ</b></a>]  Theorem
      
       s. closure s = s  closed s
   
   [<a name="CLOSURE_EQ_EMPTY-val"><b>CLOSURE_EQ_EMPTY</b></a>]  Theorem
      
       s. closure s =   s = 
   
   [<a name="CLOSURE_HALFSPACE_COMPONENT_GT-val"><b>CLOSURE_HALFSPACE_COMPONENT_GT</b></a>]  Theorem
      
       a. closure {x | x &gt; a} = {x | x  a}
   
   [<a name="CLOSURE_HALFSPACE_COMPONENT_LT-val"><b>CLOSURE_HALFSPACE_COMPONENT_LT</b></a>]  Theorem
      
       a. closure {x | x &lt; a} = {x | x  a}
   
   [<a name="CLOSURE_HALFSPACE_GT-val"><b>CLOSURE_HALFSPACE_GT</b></a>]  Theorem
      
       a b. a  0  closure {x | a * x &gt; b} = {x | a * x  b}
   
   [<a name="CLOSURE_HALFSPACE_LT-val"><b>CLOSURE_HALFSPACE_LT</b></a>]  Theorem
      
       a b. a  0  closure {x | a * x &lt; b} = {x | a * x  b}
   
   [<a name="CLOSURE_HULL-val"><b>CLOSURE_HULL</b></a>]  Theorem
      
       s. closure s = closed hull s
   
   [<a name="CLOSURE_HYPERPLANE-val"><b>CLOSURE_HYPERPLANE</b></a>]  Theorem
      
       a b. closure {x | a * x = b} = {x | a * x = b}
   
   [<a name="CLOSURE_IMAGE_BOUNDED-val"><b>CLOSURE_IMAGE_BOUNDED</b></a>]  Theorem
      
       f s.
          f continuous_on closure s  bounded s 
          closure (IMAGE f s) = IMAGE f (closure s)
   
   [<a name="CLOSURE_IMAGE_CLOSURE-val"><b>CLOSURE_IMAGE_CLOSURE</b></a>]  Theorem
      
       f s.
          f continuous_on closure s 
          closure (IMAGE f (closure s)) = closure (IMAGE f s)
   
   [<a name="CLOSURE_INJECTIVE_LINEAR_IMAGE-val"><b>CLOSURE_INJECTIVE_LINEAR_IMAGE</b></a>]  Theorem
      
       f s.
          linear f  (x y. f x = f y  x = y) 
          closure (IMAGE f s) = IMAGE f (closure s)
   
   [<a name="CLOSURE_INTERIOR-val"><b>CLOSURE_INTERIOR</b></a>]  Theorem
      
       s. closure s = (:real) DIFF interior ((:real) DIFF s)
   
   [<a name="CLOSURE_INTERIOR_IDEMP-val"><b>CLOSURE_INTERIOR_IDEMP</b></a>]  Theorem
      
       s. closure (interior (closure (interior s))) =
            closure (interior s)
   
   [<a name="CLOSURE_INTERIOR_UNION_CLOSED-val"><b>CLOSURE_INTERIOR_UNION_CLOSED</b></a>]  Theorem
      
       s t.
          closed s  closed t 
          closure (interior (s  t)) =
          closure (interior s)  closure (interior t)
   
   [<a name="CLOSURE_INTERVAL-val"><b>CLOSURE_INTERVAL</b></a>]  Theorem
      
       (a b. closure (interval [(a,b)]) = interval [(a,b)]) 
        a b.
          closure (interval (a,b)) =
          if interval (a,b) =  then  else interval [(a,b)]
   
   [<a name="CLOSURE_INTER_SUBSET-val"><b>CLOSURE_INTER_SUBSET</b></a>]  Theorem
      
       s t. closure (s  t)  closure s  closure t
   
   [<a name="CLOSURE_LINEAR_IMAGE_SUBSET-val"><b>CLOSURE_LINEAR_IMAGE_SUBSET</b></a>]  Theorem
      
       f s. linear f  IMAGE f (closure s)  closure (IMAGE f s)
   
   [<a name="CLOSURE_MINIMAL-val"><b>CLOSURE_MINIMAL</b></a>]  Theorem
      
       s t. s  t  closed t  closure s  t
   
   [<a name="CLOSURE_MINIMAL_EQ-val"><b>CLOSURE_MINIMAL_EQ</b></a>]  Theorem
      
       s t. closed t  (closure s  t  s  t)
   
   [<a name="CLOSURE_NEGATIONS-val"><b>CLOSURE_NEGATIONS</b></a>]  Theorem
      
       s. closure (IMAGE (x. -x) s) = IMAGE (x. -x) (closure s)
   
   [<a name="CLOSURE_NONEMPTY_OPEN_INTER-val"><b>CLOSURE_NONEMPTY_OPEN_INTER</b></a>]  Theorem
      
       s x. x  closure s  t. x  t  open t  s  t  
   
   [<a name="CLOSURE_OPEN_INTERVAL-val"><b>CLOSURE_OPEN_INTERVAL</b></a>]  Theorem
      
       a b.
          interval (a,b)    closure (interval (a,b)) = interval [(a,b)]
   
   [<a name="CLOSURE_OPEN_INTER_CLOSURE-val"><b>CLOSURE_OPEN_INTER_CLOSURE</b></a>]  Theorem
      
       s t. open s  closure (s  closure t) = closure (s  t)
   
   [<a name="CLOSURE_OPEN_INTER_SUPERSET-val"><b>CLOSURE_OPEN_INTER_SUPERSET</b></a>]  Theorem
      
       s t. open s  s  closure t  closure (s  t) = closure s
   
   [<a name="CLOSURE_OPEN_IN_INTER_CLOSURE-val"><b>CLOSURE_OPEN_IN_INTER_CLOSURE</b></a>]  Theorem
      
       s t u.
          open_in (subtopology euclidean u) s  t  u 
          closure (s  closure t) = closure (s  t)
   
   [<a name="CLOSURE_SEQUENTIAL-val"><b>CLOSURE_SEQUENTIAL</b></a>]  Theorem
      
       s l. l  closure s  x. (n. x n  s)  (x  l) sequentially
   
   [<a name="CLOSURE_SING-val"><b>CLOSURE_SING</b></a>]  Theorem
      
       x. closure {x} = {x}
   
   [<a name="CLOSURE_SUBSET-val"><b>CLOSURE_SUBSET</b></a>]  Theorem
      
       s. s  closure s
   
   [<a name="CLOSURE_SUBSET_EQ-val"><b>CLOSURE_SUBSET_EQ</b></a>]  Theorem
      
       s. closure s  s  closed s
   
   [<a name="CLOSURE_SUMS-val"><b>CLOSURE_SUMS</b></a>]  Theorem
      
       s t.
          bounded s  bounded t 
          closure {x + y | x  s  y  t} =
          {x + y | x  closure s  y  closure t}
   
   [<a name="CLOSURE_UNION-val"><b>CLOSURE_UNION</b></a>]  Theorem
      
       s t. closure (s  t) = closure s  closure t
   
   [<a name="CLOSURE_UNION_FRONTIER-val"><b>CLOSURE_UNION_FRONTIER</b></a>]  Theorem
      
       s. closure s = s  frontier s
   
   [<a name="CLOSURE_UNIQUE-val"><b>CLOSURE_UNIQUE</b></a>]  Theorem
      
       s t.
          s  t  closed t  (t'. s  t'  closed t'  t  t') 
          closure s = t
   
   [<a name="CLOSURE_UNIV-val"><b>CLOSURE_UNIV</b></a>]  Theorem
      
       closure (:real) = (:real)
   
   [<a name="COBOUNDED_IMP_UNBOUNDED-val"><b>COBOUNDED_IMP_UNBOUNDED</b></a>]  Theorem
      
       s. bounded ((:real) DIFF s)  bounded s
   
   [<a name="COBOUNDED_INTER_UNBOUNDED-val"><b>COBOUNDED_INTER_UNBOUNDED</b></a>]  Theorem
      
       s t. bounded ((:real) DIFF s)  bounded t  s  t  
   
   [<a name="COLLINEAR_1-val"><b>COLLINEAR_1</b></a>]  Theorem
      
       s. collinear s
   
   [<a name="COLLINEAR_2-val"><b>COLLINEAR_2</b></a>]  Theorem
      
       x y. collinear {x; y}
   
   [<a name="COLLINEAR_3-val"><b>COLLINEAR_3</b></a>]  Theorem
      
       x y z. collinear {x; y; z}  collinear {0; x  y; z  y}
   
   [<a name="COLLINEAR_3_EXPAND-val"><b>COLLINEAR_3_EXPAND</b></a>]  Theorem
      
       a b c. collinear {a; b; c}  a = c  u. b = u * a + (1  u) * c
   
   [<a name="COLLINEAR_3_TRANS-val"><b>COLLINEAR_3_TRANS</b></a>]  Theorem
      
       a b c d.
          collinear {a; b; c}  collinear {b; c; d}  b  c 
          collinear {a; b; d}
   
   [<a name="COLLINEAR_4_3-val"><b>COLLINEAR_4_3</b></a>]  Theorem
      
       a b c d.
          a  b 
          (collinear {a; b; c; d} 
           collinear {a; b; c}  collinear {a; b; d})
   
   [<a name="COLLINEAR_BETWEEN_CASES-val"><b>COLLINEAR_BETWEEN_CASES</b></a>]  Theorem
      
       a b c.
          collinear {a; b; c} 
          between a (b,c)  between b (c,a)  between c (a,b)
   
   [<a name="COLLINEAR_DIST_BETWEEN-val"><b>COLLINEAR_DIST_BETWEEN</b></a>]  Theorem
      
       a b x.
          collinear {x; a; b}  dist (x,a)  dist (a,b) 
          dist (x,b)  dist (a,b) 
          between x (a,b)
   
   [<a name="COLLINEAR_DIST_IN_CLOSED_SEGMENT-val"><b>COLLINEAR_DIST_IN_CLOSED_SEGMENT</b></a>]  Theorem
      
       a b x.
          collinear {x; a; b}  dist (x,a)  dist (a,b) 
          dist (x,b)  dist (a,b) 
          x  segment [(a,b)]
   
   [<a name="COLLINEAR_DIST_IN_OPEN_SEGMENT-val"><b>COLLINEAR_DIST_IN_OPEN_SEGMENT</b></a>]  Theorem
      
       a b x.
          collinear {x; a; b}  dist (x,a) &lt; dist (a,b) 
          dist (x,b) &lt; dist (a,b) 
          x  segment (a,b)
   
   [<a name="COLLINEAR_EMPTY-val"><b>COLLINEAR_EMPTY</b></a>]  Theorem
      
       collinear 
   
   [<a name="COLLINEAR_LEMMA-val"><b>COLLINEAR_LEMMA</b></a>]  Theorem
      
       x y. collinear {0; x; y}  x = 0  y = 0  c. y = c * x
   
   [<a name="COLLINEAR_LEMMA_ALT-val"><b>COLLINEAR_LEMMA_ALT</b></a>]  Theorem
      
       x y. collinear {0; x; y}  x = 0  c. y = c * x
   
   [<a name="COLLINEAR_MIDPOINT-val"><b>COLLINEAR_MIDPOINT</b></a>]  Theorem
      
       a b. collinear {a; midpoint (a,b); b}
   
   [<a name="COLLINEAR_SING-val"><b>COLLINEAR_SING</b></a>]  Theorem
      
       x. collinear {x}
   
   [<a name="COLLINEAR_SMALL-val"><b>COLLINEAR_SMALL</b></a>]  Theorem
      
       s. FINITE s  CARD s  2  collinear s
   
   [<a name="COLLINEAR_SUBSET-val"><b>COLLINEAR_SUBSET</b></a>]  Theorem
      
       s t. collinear t  s  t  collinear s
   
   [<a name="COLLINEAR_TRIPLES-val"><b>COLLINEAR_TRIPLES</b></a>]  Theorem
      
       s a b.
          a  b 
          (collinear (a INSERT b INSERT s) 
           x. x  s  collinear {a; b; x})
   
   [<a name="COMPACT_AFFINITY-val"><b>COMPACT_AFFINITY</b></a>]  Theorem
      
       s a c. compact s  compact (IMAGE (x. a + c * x) s)
   
   [<a name="COMPACT_ATTAINS_INF-val"><b>COMPACT_ATTAINS_INF</b></a>]  Theorem
      
       s. compact s  s    x. x  s  y. y  s  x  y
   
   [<a name="COMPACT_ATTAINS_SUP-val"><b>COMPACT_ATTAINS_SUP</b></a>]  Theorem
      
       s. compact s  s    x. x  s  y. y  s  y  x
   
   [<a name="COMPACT_BIGINTER-val"><b>COMPACT_BIGINTER</b></a>]  Theorem
      
       f. (s. s  f  compact s)  f    compact (BIGINTER f)
   
   [<a name="COMPACT_BIGUNION-val"><b>COMPACT_BIGUNION</b></a>]  Theorem
      
       s. FINITE s  (t. t  s  compact t)  compact (BIGUNION s)
   
   [<a name="COMPACT_CBALL-val"><b>COMPACT_CBALL</b></a>]  Theorem
      
       x e. compact (cball (x,e))
   
   [<a name="COMPACT_CHAIN-val"><b>COMPACT_CHAIN</b></a>]  Theorem
      
       f. (s. s  f  compact s  s  ) 
            (s t. s  f  t  f  s  t  t  s) 
            BIGINTER f  
   
   [<a name="COMPACT_CLOSED_DIFFERENCES-val"><b>COMPACT_CLOSED_DIFFERENCES</b></a>]  Theorem
      
       s t. compact s  closed t  closed {x  y | x  s  y  t}
   
   [<a name="COMPACT_CLOSED_SUMS-val"><b>COMPACT_CLOSED_SUMS</b></a>]  Theorem
      
       s t. compact s  closed t  closed {x + y | x  s  y  t}
   
   [<a name="COMPACT_CLOSURE-val"><b>COMPACT_CLOSURE</b></a>]  Theorem
      
       s. compact (closure s)  bounded s
   
   [<a name="COMPACT_COMPONENTS-val"><b>COMPACT_COMPONENTS</b></a>]  Theorem
      
       s c. compact s  c  components s  compact c
   
   [<a name="COMPACT_CONTINUOUS_IMAGE-val"><b>COMPACT_CONTINUOUS_IMAGE</b></a>]  Theorem
      
       f s. f continuous_on s  compact s  compact (IMAGE f s)
   
   [<a name="COMPACT_CONTINUOUS_IMAGE_EQ-val"><b>COMPACT_CONTINUOUS_IMAGE_EQ</b></a>]  Theorem
      
       f s.
          (x y. x  s  y  s  f x = f y  x = y) 
          (f continuous_on s  t. compact t  t  s  compact (IMAGE f t))
   
   [<a name="COMPACT_DIFF-val"><b>COMPACT_DIFF</b></a>]  Theorem
      
       s t. compact s  open t  compact (s DIFF t)
   
   [<a name="COMPACT_EMPTY-val"><b>COMPACT_EMPTY</b></a>]  Theorem
      
       compact 
   
   [<a name="COMPACT_EQ_BOLZANO_WEIERSTRASS-val"><b>COMPACT_EQ_BOLZANO_WEIERSTRASS</b></a>]  Theorem
      
       s. compact s 
            t. INFINITE t  t  s  x. x  s  x limit_point_of t
   
   [<a name="COMPACT_EQ_BOUNDED_CLOSED-val"><b>COMPACT_EQ_BOUNDED_CLOSED</b></a>]  Theorem
      
       s. compact s  bounded s  closed s
   
   [<a name="COMPACT_EQ_HEINE_BOREL-val"><b>COMPACT_EQ_HEINE_BOREL</b></a>]  Theorem
      
       s. compact s 
            f. (t. t  f  open t)  s  BIGUNION f 
                f'. f'  f  FINITE f'  s  BIGUNION f'
   
   [<a name="COMPACT_EQ_HEINE_BOREL_SUBTOPOLOGY-val"><b>COMPACT_EQ_HEINE_BOREL_SUBTOPOLOGY</b></a>]  Theorem
      
       s. compact s 
            f. (t. t  f  open_in (subtopology euclidean s) t) 
                s  BIGUNION f 
                f'. f'  f  FINITE f'  s  BIGUNION f'
   
   [<a name="COMPACT_FIP-val"><b>COMPACT_FIP</b></a>]  Theorem
      
       f. (t. t  f  compact t) 
            (f'. FINITE f'  f'  f  BIGINTER f'  ) 
            BIGINTER f  
   
   [<a name="COMPACT_FRONTIER-val"><b>COMPACT_FRONTIER</b></a>]  Theorem
      
       s. compact s  compact (frontier s)
   
   [<a name="COMPACT_FRONTIER_BOUNDED-val"><b>COMPACT_FRONTIER_BOUNDED</b></a>]  Theorem
      
       s. bounded s  compact (frontier s)
   
   [<a name="COMPACT_IMP_BOUNDED-val"><b>COMPACT_IMP_BOUNDED</b></a>]  Theorem
      
       s. compact s  bounded s
   
   [<a name="COMPACT_IMP_CLOSED-val"><b>COMPACT_IMP_CLOSED</b></a>]  Theorem
      
       s. compact s  closed s
   
   [<a name="COMPACT_IMP_COMPLETE-val"><b>COMPACT_IMP_COMPLETE</b></a>]  Theorem
      
       s. compact s  complete s
   
   [<a name="COMPACT_IMP_FIP-val"><b>COMPACT_IMP_FIP</b></a>]  Theorem
      
       s f.
          compact s  (t. t  f  closed t) 
          (f'. FINITE f'  f'  f  s  BIGINTER f'  ) 
          s  BIGINTER f  
   
   [<a name="COMPACT_IMP_HEINE_BOREL-val"><b>COMPACT_IMP_HEINE_BOREL</b></a>]  Theorem
      
       s. compact s 
            f. (t. t  f  open t)  s  BIGUNION f 
                f'. f'  f  FINITE f'  s  BIGUNION f'
   
   [<a name="COMPACT_IMP_TOTALLY_BOUNDED-val"><b>COMPACT_IMP_TOTALLY_BOUNDED</b></a>]  Theorem
      
       s. compact s 
            e. 0 &lt; e 
                k. FINITE k  k  s 
                    s  BIGUNION (IMAGE (x. ball (x,e)) k)
   
   [<a name="COMPACT_INSERT-val"><b>COMPACT_INSERT</b></a>]  Theorem
      
       a s. compact s  compact (a INSERT s)
   
   [<a name="COMPACT_INTER-val"><b>COMPACT_INTER</b></a>]  Theorem
      
       s t. compact s  compact t  compact (s  t)
   
   [<a name="COMPACT_INTERVAL-val"><b>COMPACT_INTERVAL</b></a>]  Theorem
      
       a b. compact (interval [(a,b)])
   
   [<a name="COMPACT_INTERVAL_EQ-val"><b>COMPACT_INTERVAL_EQ</b></a>]  Theorem
      
       (a b. compact (interval [(a,b)])) 
        a b. compact (interval (a,b))  interval (a,b) = 
   
   [<a name="COMPACT_INTER_CLOSED-val"><b>COMPACT_INTER_CLOSED</b></a>]  Theorem
      
       s t. compact s  closed t  compact (s  t)
   
   [<a name="COMPACT_LEMMA-val"><b>COMPACT_LEMMA</b></a>]  Theorem
      
       s. bounded s  (n. x n  s) 
            l r.
              (m n. m &lt; n  r m &lt; r n) 
              e. 0 &lt; e  N. n i. N  n  abs (x (r n)  l) &lt; e
   
   [<a name="COMPACT_LINEAR_IMAGE-val"><b>COMPACT_LINEAR_IMAGE</b></a>]  Theorem
      
       f s. compact s  linear f  compact (IMAGE f s)
   
   [<a name="COMPACT_NEGATIONS-val"><b>COMPACT_NEGATIONS</b></a>]  Theorem
      
       s. compact s  compact (IMAGE (x. -x) s)
   
   [<a name="COMPACT_NEST-val"><b>COMPACT_NEST</b></a>]  Theorem
      
       s. (n. compact (s n)  s n  )  (m n. m  n  s n  s m) 
            BIGINTER {s n | n  (:num)}  
   
   [<a name="COMPACT_REAL_LEMMA-val"><b>COMPACT_REAL_LEMMA</b></a>]  Theorem
      
       s b.
          (n. abs (s n)  b) 
          l r.
            (m n. m &lt; n  r m &lt; r n) 
            e. 0 &lt; e  N. n. N  n  abs (s (r n)  l) &lt; e
   
   [<a name="COMPACT_SCALING-val"><b>COMPACT_SCALING</b></a>]  Theorem
      
       s c. compact s  compact (IMAGE (x. c * x) s)
   
   [<a name="COMPACT_SEQUENCE_WITH_LIMIT-val"><b>COMPACT_SEQUENCE_WITH_LIMIT</b></a>]  Theorem
      
       f l. (f  l) sequentially  compact (l INSERT IMAGE f (:num))
   
   [<a name="COMPACT_SING-val"><b>COMPACT_SING</b></a>]  Theorem
      
       a. compact {a}
   
   [<a name="COMPACT_SPHERE-val"><b>COMPACT_SPHERE</b></a>]  Theorem
      
       a r. compact (sphere (a,r))
   
   [<a name="COMPACT_TRANSLATION-val"><b>COMPACT_TRANSLATION</b></a>]  Theorem
      
       s a. compact s  compact (IMAGE (x. a + x) s)
   
   [<a name="COMPACT_TRANSLATION_EQ-val"><b>COMPACT_TRANSLATION_EQ</b></a>]  Theorem
      
       a s. compact (IMAGE (x. a + x) s)  compact s
   
   [<a name="COMPACT_UNIFORMLY_CONTINUOUS-val"><b>COMPACT_UNIFORMLY_CONTINUOUS</b></a>]  Theorem
      
       f s. f continuous_on s  compact s  f uniformly_continuous_on s
   
   [<a name="COMPACT_UNIFORMLY_EQUICONTINUOUS-val"><b>COMPACT_UNIFORMLY_EQUICONTINUOUS</b></a>]  Theorem
      
       fs s.
          (x e.
             x  s  0 &lt; e 
             d. 0 &lt; d 
                 f x'.
                   f  fs  x'  s  dist (x',x) &lt; d  dist (f x',f x) &lt; e) 
          compact s 
          e. 0 &lt; e 
              d. 0 &lt; d 
                  f x x'.
                    f  fs  x  s  x'  s  dist (x',x) &lt; d 
                    dist (f x',f x) &lt; e
   
   [<a name="COMPACT_UNION-val"><b>COMPACT_UNION</b></a>]  Theorem
      
       s t. compact s  compact t  compact (s  t)
   
   [<a name="COMPLEMENT_CONNECTED_COMPONENT_BIGUNION-val"><b>COMPLEMENT_CONNECTED_COMPONENT_BIGUNION</b></a>]  Theorem
      
       s x.
          s DIFF connected_component s x =
          BIGUNION
            ({connected_component s y | y | y  s} DELETE
             connected_component s x)
   
   [<a name="COMPLETE_EQ_CLOSED-val"><b>COMPLETE_EQ_CLOSED</b></a>]  Theorem
      
       s. complete s  closed s
   
   [<a name="COMPLETE_INJECTIVE_LINEAR_IMAGE-val"><b>COMPLETE_INJECTIVE_LINEAR_IMAGE</b></a>]  Theorem
      
       f. linear f  (x y. f x = f y  x = y) 
            s. complete s  complete (IMAGE f s)
   
   [<a name="COMPLETE_INJECTIVE_LINEAR_IMAGE_EQ-val"><b>COMPLETE_INJECTIVE_LINEAR_IMAGE_EQ</b></a>]  Theorem
      
       f s.
          linear f  (x y. f x = f y  x = y) 
          (complete (IMAGE f s)  complete s)
   
   [<a name="COMPLETE_ISOMETRIC_IMAGE-val"><b>COMPLETE_ISOMETRIC_IMAGE</b></a>]  Theorem
      
       f s e.
          0 &lt; e  subspace s  linear f 
          (x. x  s  abs (f x)  e * abs x)  complete s 
          complete (IMAGE f s)
   
   [<a name="COMPLETE_UNIV-val"><b>COMPLETE_UNIV</b></a>]  Theorem
      
       complete (:real)
   
   [<a name="COMPONENTS_EMPTY-val"><b>COMPONENTS_EMPTY</b></a>]  Theorem
      
       components  = 
   
   [<a name="COMPONENTS_EQ-val"><b>COMPONENTS_EQ</b></a>]  Theorem
      
       s c c'.
          c  components s  c'  components s  (c = c'  c  c'  )
   
   [<a name="COMPONENTS_EQ_EMPTY-val"><b>COMPONENTS_EQ_EMPTY</b></a>]  Theorem
      
       s. components s =   s = 
   
   [<a name="COMPONENTS_EQ_SING-val"><b>COMPONENTS_EQ_SING</b></a>]  Theorem
      
       s. components s = {s}  connected s  s  
   
   [<a name="COMPONENTS_EQ_SING_EXISTS-val"><b>COMPONENTS_EQ_SING_EXISTS</b></a>]  Theorem
      
       s. (a. components s = {a})  connected s  s  
   
   [<a name="COMPONENTS_EQ_SING_N_EXISTS-val"><b>COMPONENTS_EQ_SING_N_EXISTS</b></a>]  Theorem
      
       (s. components s = {s}  connected s  s  ) 
        s. (a. components s = {a})  connected s  s  
   
   [<a name="COMPONENTS_INTERMEDIATE_SUBSET-val"><b>COMPONENTS_INTERMEDIATE_SUBSET</b></a>]  Theorem
      
       s t u. s  components u  s  t  t  u  s  components t
   
   [<a name="COMPONENTS_MAXIMAL-val"><b>COMPONENTS_MAXIMAL</b></a>]  Theorem
      
       s t c. c  components s  connected t  t  s  c  t    t  c
   
   [<a name="COMPONENTS_NONOVERLAP-val"><b>COMPONENTS_NONOVERLAP</b></a>]  Theorem
      
       s c c'.
          c  components s  c'  components s  (c  c' =   c  c')
   
   [<a name="COMPONENTS_UNIQUE-val"><b>COMPONENTS_UNIQUE</b></a>]  Theorem
      
       s k.
          BIGUNION k = s 
          (c. c  k 
               connected c  c   
               c'. connected c'  c  c'  c'  s  c' = c) 
          components s = k
   
   [<a name="COMPONENTS_UNIQUE_EQ-val"><b>COMPONENTS_UNIQUE_EQ</b></a>]  Theorem
      
       s k.
          components s = k 
          BIGUNION k = s 
          c. c  k 
              connected c  c   
              c'. connected c'  c  c'  c'  s  c' = c
   
   [<a name="COMPONENTS_UNIV-val"><b>COMPONENTS_UNIV</b></a>]  Theorem
      
       components (:real) = {(:real)}
   
   [<a name="CONDENSATION_POINT_IMP_LIMPT-val"><b>CONDENSATION_POINT_IMP_LIMPT</b></a>]  Theorem
      
       x s. x condensation_point_of s  x limit_point_of s
   
   [<a name="CONDENSATION_POINT_INFINITE_BALL-val"><b>CONDENSATION_POINT_INFINITE_BALL</b></a>]  Theorem
      
       s x.
          x condensation_point_of s 
          e. 0 &lt; e  uncountable (s  ball (x,e))
   
   [<a name="CONDENSATION_POINT_INFINITE_BALL_CBALL-val"><b>CONDENSATION_POINT_INFINITE_BALL_CBALL</b></a>]  Theorem
      
       (s x.
           x condensation_point_of s 
           e. 0 &lt; e  uncountable (s  ball (x,e))) 
        s x.
          x condensation_point_of s 
          e. 0 &lt; e  uncountable (s  cball (x,e))
   
   [<a name="CONDENSATION_POINT_INFINITE_CBALL-val"><b>CONDENSATION_POINT_INFINITE_CBALL</b></a>]  Theorem
      
       s x.
          x condensation_point_of s 
          e. 0 &lt; e  uncountable (s  cball (x,e))
   
   [<a name="CONDENSATION_POINT_OF_SUBSET-val"><b>CONDENSATION_POINT_OF_SUBSET</b></a>]  Theorem
      
       x s t.
          x condensation_point_of s  s  t  x condensation_point_of t
   
   [<a name="CONNECTED_BIGUNION-val"><b>CONNECTED_BIGUNION</b></a>]  Theorem
      
       P. (s. s  P  connected s)  BIGINTER P   
            connected (BIGUNION P)
   
   [<a name="CONNECTED_CHAIN-val"><b>CONNECTED_CHAIN</b></a>]  Theorem
      
       f. (s. s  f  compact s  connected s) 
            (s t. s  f  t  f  s  t  t  s) 
            connected (BIGINTER f)
   
   [<a name="CONNECTED_CHAIN_GEN-val"><b>CONNECTED_CHAIN_GEN</b></a>]  Theorem
      
       f. (s. s  f  closed s  connected s) 
            (s. s  f  compact s)  (s t. s  f  t  f  s  t  t  s) 
            connected (BIGINTER f)
   
   [<a name="CONNECTED_CLOPEN-val"><b>CONNECTED_CLOPEN</b></a>]  Theorem
      
       s. connected s 
            t. open_in (subtopology euclidean s) t 
                closed_in (subtopology euclidean s) t 
                t =   t = s
   
   [<a name="CONNECTED_CLOSED-val"><b>CONNECTED_CLOSED</b></a>]  Theorem
      
       s. connected s 
            e1 e2.
              closed e1  closed e2  s  e1  e2  e1  e2  s =  
              e1  s    e2  s  
   
   [<a name="CONNECTED_CLOSED_IN-val"><b>CONNECTED_CLOSED_IN</b></a>]  Theorem
      
       s. connected s 
            e1 e2.
              closed_in (subtopology euclidean s) e1 
              closed_in (subtopology euclidean s) e2  s  e1  e2 
              e1  e2 =   e1    e2  
   
   [<a name="CONNECTED_CLOSED_IN_EQ-val"><b>CONNECTED_CLOSED_IN_EQ</b></a>]  Theorem
      
       s. connected s 
            e1 e2.
              closed_in (subtopology euclidean s) e1 
              closed_in (subtopology euclidean s) e2  e1  e2 = s 
              e1  e2 =   e1    e2  
   
   [<a name="CONNECTED_CLOSED_MONOTONE_PREIMAGE-val"><b>CONNECTED_CLOSED_MONOTONE_PREIMAGE</b></a>]  Theorem
      
       f s t.
          f continuous_on s  IMAGE f s = t 
          (c. closed_in (subtopology euclidean s) c 
               closed_in (subtopology euclidean t) (IMAGE f c)) 
          (y. y  t  connected {x | x  s  f x = y}) 
          c. connected c  c  t  connected {x | x  s  f x  c}
   
   [<a name="CONNECTED_CLOSED_SET-val"><b>CONNECTED_CLOSED_SET</b></a>]  Theorem
      
       s. closed s 
            (connected s 
             e1 e2.
               closed e1  closed e2  e1    e2    e1  e2 = s 
               e1  e2 = )
   
   [<a name="CONNECTED_CLOSURE-val"><b>CONNECTED_CLOSURE</b></a>]  Theorem
      
       s. connected s  connected (closure s)
   
   [<a name="CONNECTED_COMPONENT_BIGUNION-val"><b>CONNECTED_COMPONENT_BIGUNION</b></a>]  Theorem
      
       s x.
          connected_component s x =
          BIGUNION {t | connected t  x  t  t  s}
   
   [<a name="CONNECTED_COMPONENT_DISJOINT-val"><b>CONNECTED_COMPONENT_DISJOINT</b></a>]  Theorem
      
       s a b.
          DISJOINT (connected_component s a) (connected_component s b) 
          a  connected_component s b
   
   [<a name="CONNECTED_COMPONENT_EMPTY-val"><b>CONNECTED_COMPONENT_EMPTY</b></a>]  Theorem
      
       x. connected_component  x = 
   
   [<a name="CONNECTED_COMPONENT_EQ-val"><b>CONNECTED_COMPONENT_EQ</b></a>]  Theorem
      
       s x y.
          y  connected_component s x 
          connected_component s y = connected_component s x
   
   [<a name="CONNECTED_COMPONENT_EQUIVALENCE_RELATION-val"><b>CONNECTED_COMPONENT_EQUIVALENCE_RELATION</b></a>]  Theorem
      
       R s.
          (x y. R x y  R y x)  (x y z. R x y  R y z  R x z) 
          (a. a  s 
               t. open_in (subtopology euclidean s) t  a  t 
                   x. x  t  R a x) 
          a b. connected_component s a b  R a b
   
   [<a name="CONNECTED_COMPONENT_EQ_EMPTY-val"><b>CONNECTED_COMPONENT_EQ_EMPTY</b></a>]  Theorem
      
       s x. connected_component s x =   x  s
   
   [<a name="CONNECTED_COMPONENT_EQ_EQ-val"><b>CONNECTED_COMPONENT_EQ_EQ</b></a>]  Theorem
      
       s x y.
          connected_component s x = connected_component s y 
          x  s  y  s  x  s  y  s  connected_component s x y
   
   [<a name="CONNECTED_COMPONENT_EQ_SELF-val"><b>CONNECTED_COMPONENT_EQ_SELF</b></a>]  Theorem
      
       s x. connected s  x  s  connected_component s x = s
   
   [<a name="CONNECTED_COMPONENT_EQ_UNIV-val"><b>CONNECTED_COMPONENT_EQ_UNIV</b></a>]  Theorem
      
       s x. connected_component s x = (:real)  s = (:real)
   
   [<a name="CONNECTED_COMPONENT_IDEMP-val"><b>CONNECTED_COMPONENT_IDEMP</b></a>]  Theorem
      
       s x.
          connected_component (connected_component s x) x =
          connected_component s x
   
   [<a name="CONNECTED_COMPONENT_IN-val"><b>CONNECTED_COMPONENT_IN</b></a>]  Theorem
      
       s x y. connected_component s x y  x  s  y  s
   
   [<a name="CONNECTED_COMPONENT_INTERMEDIATE_SUBSET-val"><b>CONNECTED_COMPONENT_INTERMEDIATE_SUBSET</b></a>]  Theorem
      
       t u a.
          connected_component u a  t  t  u 
          connected_component t a = connected_component u a
   
   [<a name="CONNECTED_COMPONENT_MAXIMAL-val"><b>CONNECTED_COMPONENT_MAXIMAL</b></a>]  Theorem
      
       s t x. x  t  connected t  t  s  t  connected_component s x
   
   [<a name="CONNECTED_COMPONENT_MONO-val"><b>CONNECTED_COMPONENT_MONO</b></a>]  Theorem
      
       s t x. s  t  connected_component s x  connected_component t x
   
   [<a name="CONNECTED_COMPONENT_NONOVERLAP-val"><b>CONNECTED_COMPONENT_NONOVERLAP</b></a>]  Theorem
      
       s a b.
          connected_component s a  connected_component s b =  
          a  s  b  s  connected_component s a  connected_component s b
   
   [<a name="CONNECTED_COMPONENT_OF_SUBSET-val"><b>CONNECTED_COMPONENT_OF_SUBSET</b></a>]  Theorem
      
       s t x.
          s  t  connected_component s x y  connected_component t x y
   
   [<a name="CONNECTED_COMPONENT_OVERLAP-val"><b>CONNECTED_COMPONENT_OVERLAP</b></a>]  Theorem
      
       s a b.
          connected_component s a  connected_component s b   
          a  s  b  s  connected_component s a = connected_component s b
   
   [<a name="CONNECTED_COMPONENT_REFL-val"><b>CONNECTED_COMPONENT_REFL</b></a>]  Theorem
      
       s x. x  s  connected_component s x x
   
   [<a name="CONNECTED_COMPONENT_REFL_EQ-val"><b>CONNECTED_COMPONENT_REFL_EQ</b></a>]  Theorem
      
       s x. connected_component s x x  x  s
   
   [<a name="CONNECTED_COMPONENT_SET-val"><b>CONNECTED_COMPONENT_SET</b></a>]  Theorem
      
       s x.
          connected_component s x =
          {y | t. connected t  t  s  x  t  y  t}
   
   [<a name="CONNECTED_COMPONENT_SUBSET-val"><b>CONNECTED_COMPONENT_SUBSET</b></a>]  Theorem
      
       s x. connected_component s x  s
   
   [<a name="CONNECTED_COMPONENT_SYM-val"><b>CONNECTED_COMPONENT_SYM</b></a>]  Theorem
      
       s x y. connected_component s x y  connected_component s y x
   
   [<a name="CONNECTED_COMPONENT_SYM_EQ-val"><b>CONNECTED_COMPONENT_SYM_EQ</b></a>]  Theorem
      
       s x y. connected_component s x y  connected_component s y x
   
   [<a name="CONNECTED_COMPONENT_TRANS-val"><b>CONNECTED_COMPONENT_TRANS</b></a>]  Theorem
      
       s x y.
          connected_component s x y  connected_component s y z 
          connected_component s x z
   
   [<a name="CONNECTED_COMPONENT_UNIQUE-val"><b>CONNECTED_COMPONENT_UNIQUE</b></a>]  Theorem
      
       s c x.
          x  c  c  s  connected c 
          (c'. x  c'  c'  s  connected c'  c'  c) 
          connected_component s x = c
   
   [<a name="CONNECTED_COMPONENT_UNIV-val"><b>CONNECTED_COMPONENT_UNIV</b></a>]  Theorem
      
       x. connected_component (:real) x = (:real)
   
   [<a name="CONNECTED_CONNECTED_COMPONENT-val"><b>CONNECTED_CONNECTED_COMPONENT</b></a>]  Theorem
      
       s x. connected (connected_component s x)
   
   [<a name="CONNECTED_CONNECTED_COMPONENT_SET-val"><b>CONNECTED_CONNECTED_COMPONENT_SET</b></a>]  Theorem
      
       s. connected s  x. x  s  connected_component s x = s
   
   [<a name="CONNECTED_CONTINUOUS_IMAGE-val"><b>CONNECTED_CONTINUOUS_IMAGE</b></a>]  Theorem
      
       f s. f continuous_on s  connected s  connected (IMAGE f s)
   
   [<a name="CONNECTED_DIFF_OPEN_FROM_CLOSED-val"><b>CONNECTED_DIFF_OPEN_FROM_CLOSED</b></a>]  Theorem
      
       s t u.
          s  t  t  u  open s  closed t  connected u 
          connected (t DIFF s) 
          connected (u DIFF s)
   
   [<a name="CONNECTED_DISJOINT_BIGUNION_OPEN_UNIQUE-val"><b>CONNECTED_DISJOINT_BIGUNION_OPEN_UNIQUE</b></a>]  Theorem
      
       f f'.
          pairwiseD DISJOINT f  pairwiseD DISJOINT f' 
          (s. s  f  open s  connected s  s  ) 
          (s. s  f'  open s  connected s  s  ) 
          BIGUNION f = BIGUNION f' 
          f = f'
   
   [<a name="CONNECTED_EMPTY-val"><b>CONNECTED_EMPTY</b></a>]  Theorem
      
       connected 
   
   [<a name="CONNECTED_EQUIVALENCE_RELATION-val"><b>CONNECTED_EQUIVALENCE_RELATION</b></a>]  Theorem
      
       R s.
          connected s  (x y. R x y  R y x) 
          (x y z. R x y  R y z  R x z) 
          (a. a  s 
               t. open_in (subtopology euclidean s) t  a  t 
                   x. x  t  R a x) 
          a b. a  s  b  s  R a b
   
   [<a name="CONNECTED_EQUIVALENCE_RELATION_GEN-val"><b>CONNECTED_EQUIVALENCE_RELATION_GEN</b></a>]  Theorem
      
       P R s.
          connected s  (x y. R x y  R y x) 
          (x y z. R x y  R y z  R x z) 
          (t a.
             open_in (subtopology euclidean s) t  a  t  z. z  t  P z) 
          (a. a  s 
               t. open_in (subtopology euclidean s) t  a  t 
                   x y. x  t  y  t  P x  P y  R x y) 
          a b. a  s  b  s  P a  P b  R a b
   
   [<a name="CONNECTED_EQ_COMPONENTS_SUBSET_SING-val"><b>CONNECTED_EQ_COMPONENTS_SUBSET_SING</b></a>]  Theorem
      
       s. connected s  components s  {s}
   
   [<a name="CONNECTED_EQ_COMPONENTS_SUBSET_SING_EXISTS-val"><b>CONNECTED_EQ_COMPONENTS_SUBSET_SING_EXISTS</b></a>]  Theorem
      
       s. connected s  a. components s  {a}
   
   [<a name="CONNECTED_EQ_CONNECTED_COMPONENTS_EQ-val"><b>CONNECTED_EQ_CONNECTED_COMPONENTS_EQ</b></a>]  Theorem
      
       s. connected s 
            c c'. c  components s  c'  components s  c = c'
   
   [<a name="CONNECTED_EQ_CONNECTED_COMPONENT_EQ-val"><b>CONNECTED_EQ_CONNECTED_COMPONENT_EQ</b></a>]  Theorem
      
       s. connected s 
            x y.
              x  s  y  s 
              connected_component s x = connected_component s y
   
   [<a name="CONNECTED_FROM_CLOSED_UNION_AND_INTER-val"><b>CONNECTED_FROM_CLOSED_UNION_AND_INTER</b></a>]  Theorem
      
       s t.
          closed s  closed t  connected (s  t)  connected (s  t) 
          connected s  connected t
   
   [<a name="CONNECTED_FROM_OPEN_UNION_AND_INTER-val"><b>CONNECTED_FROM_OPEN_UNION_AND_INTER</b></a>]  Theorem
      
       s t.
          open s  open t  connected (s  t)  connected (s  t) 
          connected s  connected t
   
   [<a name="CONNECTED_IFF_CONNECTABLE_POINTS-val"><b>CONNECTED_IFF_CONNECTABLE_POINTS</b></a>]  Theorem
      
       s. connected s 
            a b. a  s  b  s  t. connected t  t  s  a  t  b  t
   
   [<a name="CONNECTED_IFF_CONNECTED_COMPONENT-val"><b>CONNECTED_IFF_CONNECTED_COMPONENT</b></a>]  Theorem
      
       s. connected s  x y. x  s  y  s  connected_component s x y
   
   [<a name="CONNECTED_IMP_PERFECT-val"><b>CONNECTED_IMP_PERFECT</b></a>]  Theorem
      
       s x. connected s  (a. s = {a})  x  s  x limit_point_of s
   
   [<a name="CONNECTED_IMP_PERFECT_CLOSED-val"><b>CONNECTED_IMP_PERFECT_CLOSED</b></a>]  Theorem
      
       s x.
          connected s  closed s  (a. s = {a}) 
          (x limit_point_of s  x  s)
   
   [<a name="CONNECTED_INDUCTION-val"><b>CONNECTED_INDUCTION</b></a>]  Theorem
      
       P Q s.
          connected s 
          (t a.
             open_in (subtopology euclidean s) t  a  t  z. z  t  P z) 
          (a. a  s 
               t. open_in (subtopology euclidean s) t  a  t 
                   x y. x  t  y  t  P x  P y  Q x  Q y) 
          a b. a  s  b  s  P a  P b  Q a  Q b
   
   [<a name="CONNECTED_INDUCTION_SIMPLE-val"><b>CONNECTED_INDUCTION_SIMPLE</b></a>]  Theorem
      
       P s.
          connected s 
          (a. a  s 
               t. open_in (subtopology euclidean s) t  a  t 
                   x y. x  t  y  t  P x  P y) 
          a b. a  s  b  s  P a  P b
   
   [<a name="CONNECTED_INTERMEDIATE_CLOSURE-val"><b>CONNECTED_INTERMEDIATE_CLOSURE</b></a>]  Theorem
      
       s t. connected s  s  t  t  closure s  connected t
   
   [<a name="CONNECTED_INTER_FRONTIER-val"><b>CONNECTED_INTER_FRONTIER</b></a>]  Theorem
      
       s t. connected s  s  t    s DIFF t    s  frontier t  
   
   [<a name="CONNECTED_IVT_COMPONENT-val"><b>CONNECTED_IVT_COMPONENT</b></a>]  Theorem
      
       s x y a.
          connected s  x  s  y  s  x  a  a  y  z. z  s  z = a
   
   [<a name="CONNECTED_IVT_HYPERPLANE-val"><b>CONNECTED_IVT_HYPERPLANE</b></a>]  Theorem
      
       s x y a b.
          connected s  x  s  y  s  a * x  b  b  a * y 
          z. z  s  a * z = b
   
   [<a name="CONNECTED_LINEAR_IMAGE-val"><b>CONNECTED_LINEAR_IMAGE</b></a>]  Theorem
      
       f s. connected s  linear f  connected (IMAGE f s)
   
   [<a name="CONNECTED_MONOTONE_QUOTIENT_PREIMAGE-val"><b>CONNECTED_MONOTONE_QUOTIENT_PREIMAGE</b></a>]  Theorem
      
       f s t.
          f continuous_on s  IMAGE f s = t 
          (u. u  t 
               (open_in (subtopology euclidean s) {x | x  s  f x  u} 
                open_in (subtopology euclidean t) u)) 
          (y. y  t  connected {x | x  s  f x = y})  connected t 
          connected s
   
   [<a name="CONNECTED_MONOTONE_QUOTIENT_PREIMAGE_GEN-val"><b>CONNECTED_MONOTONE_QUOTIENT_PREIMAGE_GEN</b></a>]  Theorem
      
       f s t c.
          IMAGE f s = t 
          (u. u  t 
               (open_in (subtopology euclidean s) {x | x  s  f x  u} 
                open_in (subtopology euclidean t) u)) 
          (y. y  t  connected {x | x  s  f x = y}) 
          (open_in (subtopology euclidean t) c 
           closed_in (subtopology euclidean t) c)  connected c 
          connected {x | x  s  f x  c}
   
   [<a name="CONNECTED_NEGATIONS-val"><b>CONNECTED_NEGATIONS</b></a>]  Theorem
      
       s. connected s  connected (IMAGE (x. -x) s)
   
   [<a name="CONNECTED_NEST-val"><b>CONNECTED_NEST</b></a>]  Theorem
      
       s. (n. compact (s n)  connected (s n)) 
            (m n. m  n  s n  s m) 
            connected (BIGINTER {s n | n  (:num)})
   
   [<a name="CONNECTED_NEST_GEN-val"><b>CONNECTED_NEST_GEN</b></a>]  Theorem
      
       s. (n. closed (s n)  connected (s n))  (n. compact (s n)) 
            (m n. m  n  s n  s m) 
            connected (BIGINTER {s n | n  (:num)})
   
   [<a name="CONNECTED_OPEN_IN-val"><b>CONNECTED_OPEN_IN</b></a>]  Theorem
      
       s. connected s 
            e1 e2.
              open_in (subtopology euclidean s) e1 
              open_in (subtopology euclidean s) e2  s  e1  e2 
              e1  e2 =   e1    e2  
   
   [<a name="CONNECTED_OPEN_IN_EQ-val"><b>CONNECTED_OPEN_IN_EQ</b></a>]  Theorem
      
       s. connected s 
            e1 e2.
              open_in (subtopology euclidean s) e1 
              open_in (subtopology euclidean s) e2  e1  e2 = s 
              e1  e2 =   e1    e2  
   
   [<a name="CONNECTED_OPEN_MONOTONE_PREIMAGE-val"><b>CONNECTED_OPEN_MONOTONE_PREIMAGE</b></a>]  Theorem
      
       f s t.
          f continuous_on s  IMAGE f s = t 
          (c. open_in (subtopology euclidean s) c 
               open_in (subtopology euclidean t) (IMAGE f c)) 
          (y. y  t  connected {x | x  s  f x = y}) 
          c. connected c  c  t  connected {x | x  s  f x  c}
   
   [<a name="CONNECTED_OPEN_SET-val"><b>CONNECTED_OPEN_SET</b></a>]  Theorem
      
       s. open s 
            (connected s 
             e1 e2.
               open e1  open e2  e1    e2    e1  e2 = s 
               e1  e2 = )
   
   [<a name="CONNECTED_REAL_LEMMA-val"><b>CONNECTED_REAL_LEMMA</b></a>]  Theorem
      
       f a b e1 e2.
          a  b  f a  e1  f b  e2 
          (e x.
             a  x  x  b  0 &lt; e 
             d. 0 &lt; d  y. abs (y  x) &lt; d  dist (f y,f x) &lt; e) 
          (y. y  e1  e. 0 &lt; e  y'. dist (y',y) &lt; e  y'  e1) 
          (y. y  e2  e. 0 &lt; e  y'. dist (y',y) &lt; e  y'  e2) 
          (x. a  x  x  b  f x  e1  f x  e2) 
          x. a  x  x  b  f x  e1  f x  e2
   
   [<a name="CONNECTED_SCALING-val"><b>CONNECTED_SCALING</b></a>]  Theorem
      
       s c. connected s  connected (IMAGE (x. c * x) s)
   
   [<a name="CONNECTED_SEGMENT-val"><b>CONNECTED_SEGMENT</b></a>]  Theorem
      
       (a b. connected (segment [(a,b)])) 
        a b. connected (segment (a,b))
   
   [<a name="CONNECTED_SING-val"><b>CONNECTED_SING</b></a>]  Theorem
      
       a. connected {a}
   
   [<a name="CONNECTED_SUBSET_CLOPEN-val"><b>CONNECTED_SUBSET_CLOPEN</b></a>]  Theorem
      
       u s c.
          closed_in (subtopology euclidean u) s 
          open_in (subtopology euclidean u) s  connected c  c  u 
          c  s   
          c  s
   
   [<a name="CONNECTED_TRANSLATION-val"><b>CONNECTED_TRANSLATION</b></a>]  Theorem
      
       a s. connected s  connected (IMAGE (x. a + x) s)
   
   [<a name="CONNECTED_TRANSLATION_EQ-val"><b>CONNECTED_TRANSLATION_EQ</b></a>]  Theorem
      
       a s. connected (IMAGE (x. a + x) s)  connected s
   
   [<a name="CONNECTED_UNION-val"><b>CONNECTED_UNION</b></a>]  Theorem
      
       s t. connected s  connected t  s  t    connected (s  t)
   
   [<a name="CONNECTED_UNION_STRONG-val"><b>CONNECTED_UNION_STRONG</b></a>]  Theorem
      
       s t.
          connected s  connected t  closure s  t    connected (s  t)
   
   [<a name="CONNECTED_UNIV-val"><b>CONNECTED_UNIV</b></a>]  Theorem
      
       connected (:real)
   
   [<a name="CONTENT_0_SUBSET-val"><b>CONTENT_0_SUBSET</b></a>]  Theorem
      
       s a b.
          s  interval [(a,b)]  content (interval [(a,b)]) = 0 
          content s = 0
   
   [<a name="CONTENT_0_SUBSET_GEN-val"><b>CONTENT_0_SUBSET_GEN</b></a>]  Theorem
      
       s t. s  t  bounded t  content t = 0  content s = 0
   
   [<a name="CONTENT_CLOSED_INTERVAL-val"><b>CONTENT_CLOSED_INTERVAL</b></a>]  Theorem
      
       a b. a  b  content (interval [(a,b)]) = b  a
   
   [<a name="CONTENT_CLOSED_INTERVAL_CASES-val"><b>CONTENT_CLOSED_INTERVAL_CASES</b></a>]  Theorem
      
       a b. content (interval [(a,b)]) = if a  b then b  a else 0
   
   [<a name="CONTENT_EMPTY-val"><b>CONTENT_EMPTY</b></a>]  Theorem
      
       content  = 0
   
   [<a name="CONTENT_EQ_0-val"><b>CONTENT_EQ_0</b></a>]  Theorem
      
       a b. content (interval [(a,b)]) = 0  b  a
   
   [<a name="CONTENT_EQ_0_1-val"><b>CONTENT_EQ_0_1</b></a>]  Theorem
      
       a b. content (interval [(a,b)]) = 0  b  a
   
   [<a name="CONTENT_EQ_0_GEN-val"><b>CONTENT_EQ_0_GEN</b></a>]  Theorem
      
       s. bounded s  (content s = 0  a. x. x  s  x = a)
   
   [<a name="CONTENT_EQ_0_INTERIOR-val"><b>CONTENT_EQ_0_INTERIOR</b></a>]  Theorem
      
       a b.
          content (interval [(a,b)]) = 0  interior (interval [(a,b)]) = 
   
   [<a name="CONTENT_LT_NZ-val"><b>CONTENT_LT_NZ</b></a>]  Theorem
      
       a b.
          0 &lt; content (interval [(a,b)])  content (interval [(a,b)])  0
   
   [<a name="CONTENT_POS_LE-val"><b>CONTENT_POS_LE</b></a>]  Theorem
      
       a b. 0  content (interval [(a,b)])
   
   [<a name="CONTENT_POS_LT-val"><b>CONTENT_POS_LT</b></a>]  Theorem
      
       a b. a &lt; b  0 &lt; content (interval [(a,b)])
   
   [<a name="CONTENT_POS_LT_EQ-val"><b>CONTENT_POS_LT_EQ</b></a>]  Theorem
      
       a b. 0 &lt; content (interval [(a,b)])  a &lt; b
   
   [<a name="CONTENT_SUBSET-val"><b>CONTENT_SUBSET</b></a>]  Theorem
      
       a b c d.
          interval [(a,b)]  interval [(c,d)] 
          content (interval [(a,b)])  content (interval [(c,d)])
   
   [<a name="CONTENT_UNIT-val"><b>CONTENT_UNIT</b></a>]  Theorem
      
       content (interval [(0,1)]) = 1
   
   [<a name="CONTINUOUS_ABS-val"><b>CONTINUOUS_ABS</b></a>]  Theorem
      
       f net. f continuous net  (x. abs (f x)) continuous net
   
   [<a name="CONTINUOUS_ABS_COMPOSE-val"><b>CONTINUOUS_ABS_COMPOSE</b></a>]  Theorem
      
       net f. f continuous net  (x. abs (f x)) continuous net
   
   [<a name="CONTINUOUS_ADD-val"><b>CONTINUOUS_ADD</b></a>]  Theorem
      
       f g net.
          f continuous net  g continuous net 
          (x. f x + g x) continuous net
   
   [<a name="CONTINUOUS_AGREE_ON_CLOSURE-val"><b>CONTINUOUS_AGREE_ON_CLOSURE</b></a>]  Theorem
      
       g h.
          g continuous_on closure s  h continuous_on closure s 
          (x. x  s  g x = h x) 
          x. x  closure s  g x = h x
   
   [<a name="CONTINUOUS_AT-val"><b>CONTINUOUS_AT</b></a>]  Theorem
      
       f x. f continuous at x  (f  f x) (at x)
   
   [<a name="CONTINUOUS_ATTAINS_INF-val"><b>CONTINUOUS_ATTAINS_INF</b></a>]  Theorem
      
       f s.
          compact s  s    f continuous_on s 
          x. x  s  y. y  s  f x  f y
   
   [<a name="CONTINUOUS_ATTAINS_SUP-val"><b>CONTINUOUS_ATTAINS_SUP</b></a>]  Theorem
      
       f s.
          compact s  s    f continuous_on s 
          x. x  s  y. y  s  f y  f x
   
   [<a name="CONTINUOUS_AT_ABS-val"><b>CONTINUOUS_AT_ABS</b></a>]  Theorem
      
       x. abs continuous at x
   
   [<a name="CONTINUOUS_AT_AVOID-val"><b>CONTINUOUS_AT_AVOID</b></a>]  Theorem
      
       f x a.
          f continuous at x  f x  a 
          e. 0 &lt; e  y. dist (x,y) &lt; e  f y  a
   
   [<a name="CONTINUOUS_AT_BALL-val"><b>CONTINUOUS_AT_BALL</b></a>]  Theorem
      
       f x.
          f continuous at x 
          e. 0 &lt; e  d. 0 &lt; d  IMAGE f (ball (x,d))  ball (f x,e)
   
   [<a name="CONTINUOUS_AT_COMPOSE-val"><b>CONTINUOUS_AT_COMPOSE</b></a>]  Theorem
      
       f g x.
          f continuous at x  g continuous at (f x)  g  f continuous at x
   
   [<a name="CONTINUOUS_AT_COMPOSE_EQ-val"><b>CONTINUOUS_AT_COMPOSE_EQ</b></a>]  Theorem
      
       f g h.
          g continuous at x  h continuous at (g x)  (y. g (h y) = y) 
          h (g x) = x 
          (f continuous at (g x)  (x. f (g x)) continuous at x)
   
   [<a name="CONTINUOUS_AT_DIST-val"><b>CONTINUOUS_AT_DIST</b></a>]  Theorem
      
       a x. (x. dist (a,x)) continuous at x
   
   [<a name="CONTINUOUS_AT_DIST_CLOSEST_POINT-val"><b>CONTINUOUS_AT_DIST_CLOSEST_POINT</b></a>]  Theorem
      
       s x.
          closed s  s   
          (x. dist (x,closest_point s x)) continuous at x
   
   [<a name="CONTINUOUS_AT_ID-val"><b>CONTINUOUS_AT_ID</b></a>]  Theorem
      
       a. (x. x) continuous at a
   
   [<a name="CONTINUOUS_AT_IMP_CONTINUOUS_ON-val"><b>CONTINUOUS_AT_IMP_CONTINUOUS_ON</b></a>]  Theorem
      
       f s. (x. x  s  f continuous at x)  f continuous_on s
   
   [<a name="CONTINUOUS_AT_INV-val"><b>CONTINUOUS_AT_INV</b></a>]  Theorem
      
       f a. f continuous at a  f a  0  realinv  f continuous at a
   
   [<a name="CONTINUOUS_AT_LIFT_DOT-val"><b>CONTINUOUS_AT_LIFT_DOT</b></a>]  Theorem
      
       a x. (y. a * y) continuous at x
   
   [<a name="CONTINUOUS_AT_OPEN-val"><b>CONTINUOUS_AT_OPEN</b></a>]  Theorem
      
       f x.
          f continuous at x 
          t. open t  f x  t 
              s. open s  x  s  x'. x'  s  f x'  t
   
   [<a name="CONTINUOUS_AT_RANGE-val"><b>CONTINUOUS_AT_RANGE</b></a>]  Theorem
      
       f x.
          f continuous at x 
          e. 0 &lt; e 
              d. 0 &lt; d  x'. abs (x'  x) &lt; d  abs (f x'  f x) &lt; e
   
   [<a name="CONTINUOUS_AT_SEQUENTIALLY-val"><b>CONTINUOUS_AT_SEQUENTIALLY</b></a>]  Theorem
      
       f a.
          f continuous at a 
          x. (x  a) sequentially  (f  x  f a) sequentially
   
   [<a name="CONTINUOUS_AT_SETDIST-val"><b>CONTINUOUS_AT_SETDIST</b></a>]  Theorem
      
       s x. (y. setdist ({y},s)) continuous at x
   
   [<a name="CONTINUOUS_AT_TRANSLATION-val"><b>CONTINUOUS_AT_TRANSLATION</b></a>]  Theorem
      
       a z f. f continuous at (a + z)  (x. f (a + x)) continuous at z
   
   [<a name="CONTINUOUS_AT_WITHIN-val"><b>CONTINUOUS_AT_WITHIN</b></a>]  Theorem
      
       f x s. f continuous at x  f continuous (at x within s)
   
   [<a name="CONTINUOUS_AT_WITHIN_INV-val"><b>CONTINUOUS_AT_WITHIN_INV</b></a>]  Theorem
      
       f s a.
          f continuous (at a within s)  f a  0 
          realinv  f continuous (at a within s)
   
   [<a name="CONTINUOUS_CLOSED_IMP_CAUCHY_CONTINUOUS-val"><b>CONTINUOUS_CLOSED_IMP_CAUCHY_CONTINUOUS</b></a>]  Theorem
      
       f s.
          f continuous_on s  closed s 
          x. cauchy x  (n. x n  s)  cauchy (f  x)
   
   [<a name="CONTINUOUS_CLOSED_IN_PREIMAGE-val"><b>CONTINUOUS_CLOSED_IN_PREIMAGE</b></a>]  Theorem
      
       f s t.
          f continuous_on s  closed t 
          closed_in (subtopology euclidean s) {x | x  s  f x  t}
   
   [<a name="CONTINUOUS_CLOSED_IN_PREIMAGE_CONSTANT-val"><b>CONTINUOUS_CLOSED_IN_PREIMAGE_CONSTANT</b></a>]  Theorem
      
       f s a.
          f continuous_on s 
          closed_in (subtopology euclidean s) {x | x  s  f x = a}
   
   [<a name="CONTINUOUS_CLOSED_IN_PREIMAGE_EQ-val"><b>CONTINUOUS_CLOSED_IN_PREIMAGE_EQ</b></a>]  Theorem
      
       f s.
          f continuous_on s 
          t. closed t 
              closed_in (subtopology euclidean s) {x | x  s  f x  t}
   
   [<a name="CONTINUOUS_CLOSED_IN_PREIMAGE_GEN-val"><b>CONTINUOUS_CLOSED_IN_PREIMAGE_GEN</b></a>]  Theorem
      
       f s t u.
          f continuous_on s  IMAGE f s  t 
          closed_in (subtopology euclidean t) u 
          closed_in (subtopology euclidean s) {x | x  s  f x  u}
   
   [<a name="CONTINUOUS_CLOSED_PREIMAGE-val"><b>CONTINUOUS_CLOSED_PREIMAGE</b></a>]  Theorem
      
       f s t.
          f continuous_on s  closed s  closed t 
          closed {x | x  s  f x  t}
   
   [<a name="CONTINUOUS_CLOSED_PREIMAGE_CONSTANT-val"><b>CONTINUOUS_CLOSED_PREIMAGE_CONSTANT</b></a>]  Theorem
      
       f s. f continuous_on s  closed s  closed {x | x  s  f x = a}
   
   [<a name="CONTINUOUS_CLOSED_PREIMAGE_UNIV-val"><b>CONTINUOUS_CLOSED_PREIMAGE_UNIV</b></a>]  Theorem
      
       f s. (x. f continuous at x)  closed s  closed {x | f x  s}
   
   [<a name="CONTINUOUS_CMUL-val"><b>CONTINUOUS_CMUL</b></a>]  Theorem
      
       f c net. f continuous net  (x. c * f x) continuous net
   
   [<a name="CONTINUOUS_COMPONENT_COMPOSE-val"><b>CONTINUOUS_COMPONENT_COMPOSE</b></a>]  Theorem
      
       net f i. f continuous net  (x. f x) continuous net
   
   [<a name="CONTINUOUS_CONST-val"><b>CONTINUOUS_CONST</b></a>]  Theorem
      
       net c. (x. c) continuous net
   
   [<a name="CONTINUOUS_CONSTANT_ON_CLOSURE-val"><b>CONTINUOUS_CONSTANT_ON_CLOSURE</b></a>]  Theorem
      
       f s a.
          f continuous_on closure s  (x. x  s  f x = a) 
          x. x  closure s  f x = a
   
   [<a name="CONTINUOUS_DIAMETER-val"><b>CONTINUOUS_DIAMETER</b></a>]  Theorem
      
       s e.
          bounded s  s    0 &lt; e 
          d. 0 &lt; d 
              t. bounded t  t    hausdist (s,t) &lt; d 
                  abs (diameter s  diameter t) &lt; e
   
   [<a name="CONTINUOUS_DISCONNECTED_DISCRETE_FINITE_RANGE_CONSTANT_EQ-val"><b>CONTINUOUS_DISCONNECTED_DISCRETE_FINITE_RANGE_CONSTANT_EQ</b></a>]  Theorem
      
       (s. connected s 
             f t.
               f continuous_on s  IMAGE f s  t 
               (y. y  t  connected_component t y = {y}) 
               a. x. x  s  f x = a) 
        (s. connected s 
             f. f continuous_on s 
                 (x. x  s 
                      e. 0 &lt; e 
                          y. y  s  f y  f x  e  abs (f y  f x)) 
                 a. x. x  s  f x = a) 
        s. connected s 
            f. f continuous_on s  FINITE (IMAGE f s) 
                a. x. x  s  f x = a
   
   [<a name="CONTINUOUS_DISCONNECTED_RANGE_CONSTANT-val"><b>CONTINUOUS_DISCONNECTED_RANGE_CONSTANT</b></a>]  Theorem
      
       f s.
          connected s  f continuous_on s  IMAGE f s  t 
          (y. y  t  connected_component t y = {y}) 
          a. x. x  s  f x = a
   
   [<a name="CONTINUOUS_DISCONNECTED_RANGE_CONSTANT_EQ-val"><b>CONTINUOUS_DISCONNECTED_RANGE_CONSTANT_EQ</b></a>]  Theorem
      
       s. connected s 
            f t.
              f continuous_on s  IMAGE f s  t 
              (y. y  t  connected_component t y = {y}) 
              a. x. x  s  f x = a
   
   [<a name="CONTINUOUS_DISCRETE_RANGE_CONSTANT-val"><b>CONTINUOUS_DISCRETE_RANGE_CONSTANT</b></a>]  Theorem
      
       f s.
          connected s  f continuous_on s 
          (x. x  s 
               e. 0 &lt; e  y. y  s  f y  f x  e  abs (f y  f x)) 
          a. x. x  s  f x = a
   
   [<a name="CONTINUOUS_DISCRETE_RANGE_CONSTANT_EQ-val"><b>CONTINUOUS_DISCRETE_RANGE_CONSTANT_EQ</b></a>]  Theorem
      
       s. connected s 
            f. f continuous_on s 
                (x. x  s 
                     e. 0 &lt; e 
                         y. y  s  f y  f x  e  abs (f y  f x)) 
                a. x. x  s  f x = a
   
   [<a name="CONTINUOUS_DOT2-val"><b>CONTINUOUS_DOT2</b></a>]  Theorem
      
       net f g.
          f continuous net  g continuous net 
          (x. f x * g x) continuous net
   
   [<a name="CONTINUOUS_FINITE_RANGE_CONSTANT-val"><b>CONTINUOUS_FINITE_RANGE_CONSTANT</b></a>]  Theorem
      
       f s.
          connected s  f continuous_on s  FINITE (IMAGE f s) 
          a. x. x  s  f x = a
   
   [<a name="CONTINUOUS_FINITE_RANGE_CONSTANT_EQ-val"><b>CONTINUOUS_FINITE_RANGE_CONSTANT_EQ</b></a>]  Theorem
      
       s. connected s 
            f. f continuous_on s  FINITE (IMAGE f s) 
                a. x. x  s  f x = a
   
   [<a name="CONTINUOUS_GE_ON_CLOSURE-val"><b>CONTINUOUS_GE_ON_CLOSURE</b></a>]  Theorem
      
       f s a.
          f continuous_on closure s  (x. x  s  a  f x) 
          x. x  closure s  a  f x
   
   [<a name="CONTINUOUS_IMP_CLOSED_MAP-val"><b>CONTINUOUS_IMP_CLOSED_MAP</b></a>]  Theorem
      
       f s t.
          f continuous_on s  IMAGE f s = t  compact s 
          u. closed_in (subtopology euclidean s) u 
              closed_in (subtopology euclidean t) (IMAGE f u)
   
   [<a name="CONTINUOUS_IMP_QUOTIENT_MAP-val"><b>CONTINUOUS_IMP_QUOTIENT_MAP</b></a>]  Theorem
      
       f s t.
          f continuous_on s  IMAGE f s = t  compact s 
          u. u  t 
              (open_in (subtopology euclidean s) {x | x  s  f x  u} 
               open_in (subtopology euclidean t) u)
   
   [<a name="CONTINUOUS_INV-val"><b>CONTINUOUS_INV</b></a>]  Theorem
      
       net f.
          f continuous net  f (netlimit net)  0 
          realinv  f continuous net
   
   [<a name="CONTINUOUS_LEFT_INVERSE_IMP_QUOTIENT_MAP-val"><b>CONTINUOUS_LEFT_INVERSE_IMP_QUOTIENT_MAP</b></a>]  Theorem
      
       f g s.
          f continuous_on s  g continuous_on IMAGE f s 
          (x. x  s  g (f x) = x) 
          u. u  IMAGE f s 
              (open_in (subtopology euclidean s) {x | x  s  f x  u} 
               open_in (subtopology euclidean (IMAGE f s)) u)
   
   [<a name="CONTINUOUS_LEVELSET_OPEN-val"><b>CONTINUOUS_LEVELSET_OPEN</b></a>]  Theorem
      
       f s a.
          connected s  f continuous_on s  open {x | x  s  f x = a} 
          (x. x  s  f x = a) 
          x. x  s  f x = a
   
   [<a name="CONTINUOUS_LEVELSET_OPEN_IN-val"><b>CONTINUOUS_LEVELSET_OPEN_IN</b></a>]  Theorem
      
       f s a.
          connected s  f continuous_on s 
          open_in (subtopology euclidean s) {x | x  s  f x = a} 
          (x. x  s  f x = a) 
          x. x  s  f x = a
   
   [<a name="CONTINUOUS_LEVELSET_OPEN_IN_CASES-val"><b>CONTINUOUS_LEVELSET_OPEN_IN_CASES</b></a>]  Theorem
      
       f s a.
          connected s  f continuous_on s 
          open_in (subtopology euclidean s) {x | x  s  f x = a} 
          (x. x  s  f x  a)  x. x  s  f x = a
   
   [<a name="CONTINUOUS_LE_ON_CLOSURE-val"><b>CONTINUOUS_LE_ON_CLOSURE</b></a>]  Theorem
      
       f s a.
          f continuous_on closure s  (x. x  s  f x  a) 
          x. x  closure s  f x  a
   
   [<a name="CONTINUOUS_MAP_CLOSURES-val"><b>CONTINUOUS_MAP_CLOSURES</b></a>]  Theorem
      
       f. f continuous_on (:real) 
            s. IMAGE f (closure s)  closure (IMAGE f s)
   
   [<a name="CONTINUOUS_MAX-val"><b>CONTINUOUS_MAX</b></a>]  Theorem
      
       f g net.
          f continuous net  g continuous net 
          (x. max (f x) (g x)) continuous net
   
   [<a name="CONTINUOUS_MIN-val"><b>CONTINUOUS_MIN</b></a>]  Theorem
      
       f g net.
          f continuous net  g continuous net 
          (x. min (f x) (g x)) continuous net
   
   [<a name="CONTINUOUS_MUL-val"><b>CONTINUOUS_MUL</b></a>]  Theorem
      
       net f c.
          c continuous net  f continuous net 
          (x. c x * f x) continuous net
   
   [<a name="CONTINUOUS_NEG-val"><b>CONTINUOUS_NEG</b></a>]  Theorem
      
       f net. f continuous net  (x. -f x) continuous net
   
   [<a name="CONTINUOUS_ON-val"><b>CONTINUOUS_ON</b></a>]  Theorem
      
       f s. f continuous_on s  x. x  s  (f  f x) (at x within s)
   
   [<a name="CONTINUOUS_ON_ABS-val"><b>CONTINUOUS_ON_ABS</b></a>]  Theorem
      
       f s. f continuous_on s  (x. abs (f x)) continuous_on s
   
   [<a name="CONTINUOUS_ON_ABS_COMPOSE-val"><b>CONTINUOUS_ON_ABS_COMPOSE</b></a>]  Theorem
      
       f s. f continuous_on s  (x. abs (f x)) continuous_on s
   
   [<a name="CONTINUOUS_ON_ADD-val"><b>CONTINUOUS_ON_ADD</b></a>]  Theorem
      
       f g s.
          f continuous_on s  g continuous_on s 
          (x. f x + g x) continuous_on s
   
   [<a name="CONTINUOUS_ON_AVOID-val"><b>CONTINUOUS_ON_AVOID</b></a>]  Theorem
      
       f x s a.
          f continuous_on s  x  s  f x  a 
          e. 0 &lt; e  y. y  s  dist (x,y) &lt; e  f y  a
   
   [<a name="CONTINUOUS_ON_CASES-val"><b>CONTINUOUS_ON_CASES</b></a>]  Theorem
      
       P f g s t.
          closed s  closed t  f continuous_on s  g continuous_on t 
          (x. x  s  P x  x  t  P x  f x = g x) 
          (x. if P x then f x else g x) continuous_on s  t
   
   [<a name="CONTINUOUS_ON_CASES_1-val"><b>CONTINUOUS_ON_CASES_1</b></a>]  Theorem
      
       f g s a.
          f continuous_on {t | t  s  t  a} 
          g continuous_on equiv_class $&lt;= s a  (a  s  f a = g a) 
          (t. if t  a then f t else g t) continuous_on s
   
   [<a name="CONTINUOUS_ON_CASES_LE-val"><b>CONTINUOUS_ON_CASES_LE</b></a>]  Theorem
      
       f g h s a.
          f continuous_on {t | t  s  h t  a} 
          g continuous_on {t | t  s  a  h t}  h continuous_on s 
          (t. t  s  h t = a  f t = g t) 
          (t. if h t  a then f t else g t) continuous_on s
   
   [<a name="CONTINUOUS_ON_CASES_LOCAL-val"><b>CONTINUOUS_ON_CASES_LOCAL</b></a>]  Theorem
      
       P f g s t.
          closed_in (subtopology euclidean (s  t)) s 
          closed_in (subtopology euclidean (s  t)) t  f continuous_on s 
          g continuous_on t  (x. x  s  P x  x  t  P x  f x = g x) 
          (x. if P x then f x else g x) continuous_on s  t
   
   [<a name="CONTINUOUS_ON_CASES_LOCAL_OPEN-val"><b>CONTINUOUS_ON_CASES_LOCAL_OPEN</b></a>]  Theorem
      
       P f g s t.
          open_in (subtopology euclidean (s  t)) s 
          open_in (subtopology euclidean (s  t)) t  f continuous_on s 
          g continuous_on t  (x. x  s  P x  x  t  P x  f x = g x) 
          (x. if P x then f x else g x) continuous_on s  t
   
   [<a name="CONTINUOUS_ON_CASES_OPEN-val"><b>CONTINUOUS_ON_CASES_OPEN</b></a>]  Theorem
      
       P f g s t.
          open s  open t  f continuous_on s  g continuous_on t 
          (x. x  s  P x  x  t  P x  f x = g x) 
          (x. if P x then f x else g x) continuous_on s  t
   
   [<a name="CONTINUOUS_ON_CLOSED-val"><b>CONTINUOUS_ON_CLOSED</b></a>]  Theorem
      
       f s.
          f continuous_on s 
          t. closed_in (subtopology euclidean (IMAGE f s)) t 
              closed_in (subtopology euclidean s) {x | x  s  f x  t}
   
   [<a name="CONTINUOUS_ON_CLOSED_GEN-val"><b>CONTINUOUS_ON_CLOSED_GEN</b></a>]  Theorem
      
       f s t.
          IMAGE f s  t 
          (f continuous_on s 
           u. closed_in (subtopology euclidean t) u 
               closed_in (subtopology euclidean s) {x | x  s  f x  u})
   
   [<a name="CONTINUOUS_ON_CLOSURE-val"><b>CONTINUOUS_ON_CLOSURE</b></a>]  Theorem
      
       f s.
          f continuous_on closure s 
          x e.
            x  closure s  0 &lt; e 
            d. 0 &lt; d  y. y  s  dist (y,x) &lt; d  dist (f y,f x) &lt; e
   
   [<a name="CONTINUOUS_ON_CLOSURE_ABS_LE-val"><b>CONTINUOUS_ON_CLOSURE_ABS_LE</b></a>]  Theorem
      
       f s x b.
          f continuous_on closure s  (y. y  s  abs (f y)  b) 
          x  closure s 
          abs (f x)  b
   
   [<a name="CONTINUOUS_ON_CLOSURE_COMPONENT_GE-val"><b>CONTINUOUS_ON_CLOSURE_COMPONENT_GE</b></a>]  Theorem
      
       f s x b.
          f continuous_on closure s  (y. y  s  b  f y)  x  closure s 
          b  f x
   
   [<a name="CONTINUOUS_ON_CLOSURE_COMPONENT_LE-val"><b>CONTINUOUS_ON_CLOSURE_COMPONENT_LE</b></a>]  Theorem
      
       f s x b.
          f continuous_on closure s  (y. y  s  f y  b)  x  closure s 
          f x  b
   
   [<a name="CONTINUOUS_ON_CLOSURE_SEQUENTIALLY-val"><b>CONTINUOUS_ON_CLOSURE_SEQUENTIALLY</b></a>]  Theorem
      
       f s.
          f continuous_on closure s 
          x a.
            a  closure s  (n. x n  s)  (x  a) sequentially 
            (f  x  f a) sequentially
   
   [<a name="CONTINUOUS_ON_CMUL-val"><b>CONTINUOUS_ON_CMUL</b></a>]  Theorem
      
       f c s. f continuous_on s  (x. c * f x) continuous_on s
   
   [<a name="CONTINUOUS_ON_COMPONENTS_FINITE-val"><b>CONTINUOUS_ON_COMPONENTS_FINITE</b></a>]  Theorem
      
       f s.
          FINITE (components s) 
          (c. c  components s  f continuous_on c) 
          f continuous_on s
   
   [<a name="CONTINUOUS_ON_COMPONENTS_GEN-val"><b>CONTINUOUS_ON_COMPONENTS_GEN</b></a>]  Theorem
      
       f s.
          (c. c  components s 
               open_in (subtopology euclidean s) c  f continuous_on c) 
          f continuous_on s
   
   [<a name="CONTINUOUS_ON_COMPONENT_COMPOSE-val"><b>CONTINUOUS_ON_COMPONENT_COMPOSE</b></a>]  Theorem
      
       f s. f continuous_on s  (x. f x) continuous_on s
   
   [<a name="CONTINUOUS_ON_COMPOSE-val"><b>CONTINUOUS_ON_COMPOSE</b></a>]  Theorem
      
       f g s.
          f continuous_on s  g continuous_on IMAGE f s 
          g  f continuous_on s
   
   [<a name="CONTINUOUS_ON_COMPOSE_QUOTIENT-val"><b>CONTINUOUS_ON_COMPOSE_QUOTIENT</b></a>]  Theorem
      
       f g s t u.
          IMAGE f s  t  IMAGE g t  u 
          (v. v  t 
               (open_in (subtopology euclidean s) {x | x  s  f x  v} 
                open_in (subtopology euclidean t) v)) 
          g  f continuous_on s 
          g continuous_on t
   
   [<a name="CONTINUOUS_ON_CONST-val"><b>CONTINUOUS_ON_CONST</b></a>]  Theorem
      
       s c. (x. c) continuous_on s
   
   [<a name="CONTINUOUS_ON_DIST-val"><b>CONTINUOUS_ON_DIST</b></a>]  Theorem
      
       a s. (x. dist (a,x)) continuous_on s
   
   [<a name="CONTINUOUS_ON_DIST_CLOSEST_POINT-val"><b>CONTINUOUS_ON_DIST_CLOSEST_POINT</b></a>]  Theorem
      
       s t.
          closed s  s   
          (x. dist (x,closest_point s x)) continuous_on t
   
   [<a name="CONTINUOUS_ON_DOT2-val"><b>CONTINUOUS_ON_DOT2</b></a>]  Theorem
      
       f g s.
          f continuous_on s  g continuous_on s 
          (x. f x * g x) continuous_on s
   
   [<a name="CONTINUOUS_ON_EMPTY-val"><b>CONTINUOUS_ON_EMPTY</b></a>]  Theorem
      
       f. f continuous_on 
   
   [<a name="CONTINUOUS_ON_EQ-val"><b>CONTINUOUS_ON_EQ</b></a>]  Theorem
      
       f g s.
          (x. x  s  f x = g x)  f continuous_on s  g continuous_on s
   
   [<a name="CONTINUOUS_ON_EQ_CONTINUOUS_AT-val"><b>CONTINUOUS_ON_EQ_CONTINUOUS_AT</b></a>]  Theorem
      
       f s. open s  (f continuous_on s  x. x  s  f continuous at x)
   
   [<a name="CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN-val"><b>CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN</b></a>]  Theorem
      
       f s. f continuous_on s  x. x  s  f continuous (at x within s)
   
   [<a name="CONTINUOUS_ON_FINITE-val"><b>CONTINUOUS_ON_FINITE</b></a>]  Theorem
      
       f s. FINITE s  f continuous_on s
   
   [<a name="CONTINUOUS_ON_ID-val"><b>CONTINUOUS_ON_ID</b></a>]  Theorem
      
       s. (x. x) continuous_on s
   
   [<a name="CONTINUOUS_ON_IMP_CLOSED_IN-val"><b>CONTINUOUS_ON_IMP_CLOSED_IN</b></a>]  Theorem
      
       f s t.
          f continuous_on s 
          closed_in (subtopology euclidean (IMAGE f s)) t 
          closed_in (subtopology euclidean s) {x | x  s  f x  t}
   
   [<a name="CONTINUOUS_ON_IMP_OPEN_IN-val"><b>CONTINUOUS_ON_IMP_OPEN_IN</b></a>]  Theorem
      
       f s t.
          f continuous_on s  open_in (subtopology euclidean (IMAGE f s)) t 
          open_in (subtopology euclidean s) {x | x  s  f x  t}
   
   [<a name="CONTINUOUS_ON_INTERIOR-val"><b>CONTINUOUS_ON_INTERIOR</b></a>]  Theorem
      
       f s x. f continuous_on s  x  interior s  f continuous at x
   
   [<a name="CONTINUOUS_ON_INV-val"><b>CONTINUOUS_ON_INV</b></a>]  Theorem
      
       f s.
          f continuous_on s  (x. x  s  f x  0) 
          realinv  f continuous_on s
   
   [<a name="CONTINUOUS_ON_INVERSE-val"><b>CONTINUOUS_ON_INVERSE</b></a>]  Theorem
      
       f g s.
          f continuous_on s  compact s  (x. x  s  g (f x) = x) 
          g continuous_on IMAGE f s
   
   [<a name="CONTINUOUS_ON_INVERSE_CLOSED_MAP-val"><b>CONTINUOUS_ON_INVERSE_CLOSED_MAP</b></a>]  Theorem
      
       f g s t.
          f continuous_on s  IMAGE f s = t  (x. x  s  g (f x) = x) 
          (u. closed_in (subtopology euclidean s) u 
               closed_in (subtopology euclidean t) (IMAGE f u)) 
          g continuous_on t
   
   [<a name="CONTINUOUS_ON_INVERSE_OPEN_MAP-val"><b>CONTINUOUS_ON_INVERSE_OPEN_MAP</b></a>]  Theorem
      
       f g s t.
          f continuous_on s  IMAGE f s = t  (x. x  s  g (f x) = x) 
          (u. open_in (subtopology euclidean s) u 
               open_in (subtopology euclidean t) (IMAGE f u)) 
          g continuous_on t
   
   [<a name="CONTINUOUS_ON_IVT-val"><b>CONTINUOUS_ON_IVT</b></a>]  Theorem
      
       f a b y.
          a  b  f a  y  y  f b  f continuous_on interval [(a,b)] 
          x. x  interval [(a,b)]  f x = y
   
   [<a name="CONTINUOUS_ON_LIFT_DOT-val"><b>CONTINUOUS_ON_LIFT_DOT</b></a>]  Theorem
      
       s. (y. a * y) continuous_on s
   
   [<a name="CONTINUOUS_ON_MAX-val"><b>CONTINUOUS_ON_MAX</b></a>]  Theorem
      
       f g s.
          f continuous_on s  g continuous_on s 
          (x. max (f x) (g x)) continuous_on s
   
   [<a name="CONTINUOUS_ON_MIN-val"><b>CONTINUOUS_ON_MIN</b></a>]  Theorem
      
       f g s.
          f continuous_on s  g continuous_on s 
          (x. min (f x) (g x)) continuous_on s
   
   [<a name="CONTINUOUS_ON_MUL-val"><b>CONTINUOUS_ON_MUL</b></a>]  Theorem
      
       s c f.
          c continuous_on s  f continuous_on s 
          (x. c x * f x) continuous_on s
   
   [<a name="CONTINUOUS_ON_NEG-val"><b>CONTINUOUS_ON_NEG</b></a>]  Theorem
      
       f s. f continuous_on s  (x. -f x) continuous_on s
   
   [<a name="CONTINUOUS_ON_NO_LIMPT-val"><b>CONTINUOUS_ON_NO_LIMPT</b></a>]  Theorem
      
       f s. (x. x limit_point_of s)  f continuous_on s
   
   [<a name="CONTINUOUS_ON_OPEN-val"><b>CONTINUOUS_ON_OPEN</b></a>]  Theorem
      
       f s.
          f continuous_on s 
          t. open_in (subtopology euclidean (IMAGE f s)) t 
              open_in (subtopology euclidean s) {x | x  s  f x  t}
   
   [<a name="CONTINUOUS_ON_OPEN_AVOID-val"><b>CONTINUOUS_ON_OPEN_AVOID</b></a>]  Theorem
      
       f x s a.
          f continuous_on s  open s  x  s  f x  a 
          e. 0 &lt; e  y. dist (x,y) &lt; e  f y  a
   
   [<a name="CONTINUOUS_ON_OPEN_GEN-val"><b>CONTINUOUS_ON_OPEN_GEN</b></a>]  Theorem
      
       f s t.
          IMAGE f s  t 
          (f continuous_on s 
           u. open_in (subtopology euclidean t) u 
               open_in (subtopology euclidean s) {x | x  s  f x  u})
   
   [<a name="CONTINUOUS_ON_POW-val"><b>CONTINUOUS_ON_POW</b></a>]  Theorem
      
       f s n. (x. f x) continuous_on s  (x. f x pow n) continuous_on s
   
   [<a name="CONTINUOUS_ON_PRODUCT-val"><b>CONTINUOUS_ON_PRODUCT</b></a>]  Theorem
      
       f s t.
          FINITE t  (i. i  t  (x. f x i) continuous_on s) 
          (x. product t (f x)) continuous_on s
   
   [<a name="CONTINUOUS_ON_RANGE-val"><b>CONTINUOUS_ON_RANGE</b></a>]  Theorem
      
       f s.
          f continuous_on s 
          x. x  s 
              e. 0 &lt; e 
                  d. 0 &lt; d 
                      x'. x'  s  abs (x'  x) &lt; d  abs (f x'  f x) &lt; e
   
   [<a name="CONTINUOUS_ON_SEQUENTIALLY-val"><b>CONTINUOUS_ON_SEQUENTIALLY</b></a>]  Theorem
      
       f s.
          f continuous_on s 
          x a.
            a  s  (n. x n  s)  (x  a) sequentially 
            (f  x  f a) sequentially
   
   [<a name="CONTINUOUS_ON_SETDIST-val"><b>CONTINUOUS_ON_SETDIST</b></a>]  Theorem
      
       s t. (y. setdist ({y},s)) continuous_on t
   
   [<a name="CONTINUOUS_ON_SING-val"><b>CONTINUOUS_ON_SING</b></a>]  Theorem
      
       f a. f continuous_on {a}
   
   [<a name="CONTINUOUS_ON_SUB-val"><b>CONTINUOUS_ON_SUB</b></a>]  Theorem
      
       f g s.
          f continuous_on s  g continuous_on s 
          (x. f x  g x) continuous_on s
   
   [<a name="CONTINUOUS_ON_SUBSET-val"><b>CONTINUOUS_ON_SUBSET</b></a>]  Theorem
      
       f s t. f continuous_on s  t  s  f continuous_on t
   
   [<a name="CONTINUOUS_ON_SUM-val"><b>CONTINUOUS_ON_SUM</b></a>]  Theorem
      
       t f s.
          FINITE s  (a. a  s  f a continuous_on t) 
          (x. sum s (a. f a x)) continuous_on t
   
   [<a name="CONTINUOUS_ON_UNION-val"><b>CONTINUOUS_ON_UNION</b></a>]  Theorem
      
       f s t.
          closed s  closed t  f continuous_on s  f continuous_on t 
          f continuous_on s  t
   
   [<a name="CONTINUOUS_ON_UNION_LOCAL-val"><b>CONTINUOUS_ON_UNION_LOCAL</b></a>]  Theorem
      
       f s.
          closed_in (subtopology euclidean (s  t)) s 
          closed_in (subtopology euclidean (s  t)) t  f continuous_on s 
          f continuous_on t 
          f continuous_on s  t
   
   [<a name="CONTINUOUS_ON_UNION_LOCAL_OPEN-val"><b>CONTINUOUS_ON_UNION_LOCAL_OPEN</b></a>]  Theorem
      
       f s.
          open_in (subtopology euclidean (s  t)) s 
          open_in (subtopology euclidean (s  t)) t  f continuous_on s 
          f continuous_on t 
          f continuous_on s  t
   
   [<a name="CONTINUOUS_ON_UNION_OPEN-val"><b>CONTINUOUS_ON_UNION_OPEN</b></a>]  Theorem
      
       f s t.
          open s  open t  f continuous_on s  f continuous_on t 
          f continuous_on s  t
   
   [<a name="CONTINUOUS_ON_VMUL-val"><b>CONTINUOUS_ON_VMUL</b></a>]  Theorem
      
       s c v. c continuous_on s  (x. c x * v) continuous_on s
   
   [<a name="CONTINUOUS_OPEN_IN_PREIMAGE-val"><b>CONTINUOUS_OPEN_IN_PREIMAGE</b></a>]  Theorem
      
       f s t.
          f continuous_on s  open t 
          open_in (subtopology euclidean s) {x | x  s  f x  t}
   
   [<a name="CONTINUOUS_OPEN_IN_PREIMAGE_EQ-val"><b>CONTINUOUS_OPEN_IN_PREIMAGE_EQ</b></a>]  Theorem
      
       f s.
          f continuous_on s 
          t. open t 
              open_in (subtopology euclidean s) {x | x  s  f x  t}
   
   [<a name="CONTINUOUS_OPEN_IN_PREIMAGE_GEN-val"><b>CONTINUOUS_OPEN_IN_PREIMAGE_GEN</b></a>]  Theorem
      
       f s t u.
          f continuous_on s  IMAGE f s  t 
          open_in (subtopology euclidean t) u 
          open_in (subtopology euclidean s) {x | x  s  f x  u}
   
   [<a name="CONTINUOUS_OPEN_PREIMAGE-val"><b>CONTINUOUS_OPEN_PREIMAGE</b></a>]  Theorem
      
       f s t.
          f continuous_on s  open s  open t  open {x | x  s  f x  t}
   
   [<a name="CONTINUOUS_OPEN_PREIMAGE_UNIV-val"><b>CONTINUOUS_OPEN_PREIMAGE_UNIV</b></a>]  Theorem
      
       f s. (x. f continuous at x)  open s  open {x | f x  s}
   
   [<a name="CONTINUOUS_POW-val"><b>CONTINUOUS_POW</b></a>]  Theorem
      
       net f n. (x. f x) continuous net  (x. f x pow n) continuous net
   
   [<a name="CONTINUOUS_PRODUCT-val"><b>CONTINUOUS_PRODUCT</b></a>]  Theorem
      
       net f t.
          FINITE t  (i. i  t  (x. f x i) continuous net) 
          (x. product t (f x)) continuous net
   
   [<a name="CONTINUOUS_RIGHT_INVERSE_IMP_QUOTIENT_MAP-val"><b>CONTINUOUS_RIGHT_INVERSE_IMP_QUOTIENT_MAP</b></a>]  Theorem
      
       f g s t.
          f continuous_on s  IMAGE f s  t  g continuous_on t 
          IMAGE g t  s  (y. y  t  f (g y) = y) 
          u. u  t 
              (open_in (subtopology euclidean s) {x | x  s  f x  u} 
               open_in (subtopology euclidean t) u)
   
   [<a name="CONTINUOUS_SUB-val"><b>CONTINUOUS_SUB</b></a>]  Theorem
      
       f g net.
          f continuous net  g continuous net 
          (x. f x  g x) continuous net
   
   [<a name="CONTINUOUS_SUM-val"><b>CONTINUOUS_SUM</b></a>]  Theorem
      
       net f s.
          FINITE s  (a. a  s  f a continuous net) 
          (x. sum s (a. f a x)) continuous net
   
   [<a name="CONTINUOUS_TRANSFORM_AT-val"><b>CONTINUOUS_TRANSFORM_AT</b></a>]  Theorem
      
       f g x d.
          0 &lt; d  (x'. dist (x',x) &lt; d  f x' = g x')  f continuous at x 
          g continuous at x
   
   [<a name="CONTINUOUS_TRANSFORM_WITHIN-val"><b>CONTINUOUS_TRANSFORM_WITHIN</b></a>]  Theorem
      
       f g s x d.
          0 &lt; d  x  s  (x'. x'  s  dist (x',x) &lt; d  f x' = g x') 
          f continuous (at x within s) 
          g continuous (at x within s)
   
   [<a name="CONTINUOUS_TRANSFORM_WITHIN_OPEN-val"><b>CONTINUOUS_TRANSFORM_WITHIN_OPEN</b></a>]  Theorem
      
       f g s a.
          open s  a  s  (x. x  s  f x = g x)  f continuous at a 
          g continuous at a
   
   [<a name="CONTINUOUS_TRANSFORM_WITHIN_OPEN_IN-val"><b>CONTINUOUS_TRANSFORM_WITHIN_OPEN_IN</b></a>]  Theorem
      
       f g s t a.
          open_in (subtopology euclidean t) s  a  s 
          (x. x  s  f x = g x)  f continuous (at a within t) 
          g continuous (at a within t)
   
   [<a name="CONTINUOUS_TRANSFORM_WITHIN_SET_IMP-val"><b>CONTINUOUS_TRANSFORM_WITHIN_SET_IMP</b></a>]  Theorem
      
       f a s t.
          eventually (x. x  t  x  s) (at a) 
          f continuous (at a within s) 
          f continuous (at a within t)
   
   [<a name="CONTINUOUS_TRIVIAL_LIMIT-val"><b>CONTINUOUS_TRIVIAL_LIMIT</b></a>]  Theorem
      
       f net. trivial_limit net  f continuous net
   
   [<a name="CONTINUOUS_UNIFORM_LIMIT-val"><b>CONTINUOUS_UNIFORM_LIMIT</b></a>]  Theorem
      
       net f g s.
          trivial_limit net  eventually (n. f n continuous_on s) net 
          (e. 0 &lt; e 
               eventually (n. x. x  s  abs (f n x  g x) &lt; e) net) 
          g continuous_on s
   
   [<a name="CONTINUOUS_VMUL-val"><b>CONTINUOUS_VMUL</b></a>]  Theorem
      
       net c v. c continuous net  (x. c x * v) continuous net
   
   [<a name="CONTINUOUS_WITHIN-val"><b>CONTINUOUS_WITHIN</b></a>]  Theorem
      
       f x. f continuous (at x within s)  (f  f x) (at x within s)
   
   [<a name="CONTINUOUS_WITHIN_AVOID-val"><b>CONTINUOUS_WITHIN_AVOID</b></a>]  Theorem
      
       f x s a.
          f continuous (at x within s)  x  s  f x  a 
          e. 0 &lt; e  y. y  s  dist (x,y) &lt; e  f y  a
   
   [<a name="CONTINUOUS_WITHIN_BALL-val"><b>CONTINUOUS_WITHIN_BALL</b></a>]  Theorem
      
       f s x.
          f continuous (at x within s) 
          e. 0 &lt; e  d. 0 &lt; d  IMAGE f (ball (x,d)  s)  ball (f x,e)
   
   [<a name="CONTINUOUS_WITHIN_CLOSED_NONTRIVIAL-val"><b>CONTINUOUS_WITHIN_CLOSED_NONTRIVIAL</b></a>]  Theorem
      
       a s. closed s  a  s  f continuous (at a within s)
   
   [<a name="CONTINUOUS_WITHIN_COMPARISON-val"><b>CONTINUOUS_WITHIN_COMPARISON</b></a>]  Theorem
      
       f g s a.
          g continuous (at a within s) 
          (x. x  s  dist (f a,f x)  dist (g a,g x)) 
          f continuous (at a within s)
   
   [<a name="CONTINUOUS_WITHIN_COMPOSE-val"><b>CONTINUOUS_WITHIN_COMPOSE</b></a>]  Theorem
      
       f g x s.
          f continuous (at x within s) 
          g continuous (at (f x) within IMAGE f s) 
          g  f continuous (at x within s)
   
   [<a name="CONTINUOUS_WITHIN_ID-val"><b>CONTINUOUS_WITHIN_ID</b></a>]  Theorem
      
       a s. (x. x) continuous (at a within s)
   
   [<a name="CONTINUOUS_WITHIN_OPEN-val"><b>CONTINUOUS_WITHIN_OPEN</b></a>]  Theorem
      
       f x u.
          f continuous (at x within u) 
          t. open t  f x  t 
              s. open s  x  s  x'. x'  s  x'  u  f x'  t
   
   [<a name="CONTINUOUS_WITHIN_SEQUENTIALLY-val"><b>CONTINUOUS_WITHIN_SEQUENTIALLY</b></a>]  Theorem
      
       f s a.
          f continuous (at a within s) 
          x. (n. x n  s)  (x  a) sequentially 
              (f  x  f a) sequentially
   
   [<a name="CONTINUOUS_WITHIN_SUBSET-val"><b>CONTINUOUS_WITHIN_SUBSET</b></a>]  Theorem
      
       f s t x.
          f continuous (at x within s)  t  s 
          f continuous (at x within t)
   
   [<a name="CONTRACTION_IMP_CONTINUOUS_ON-val"><b>CONTRACTION_IMP_CONTINUOUS_ON</b></a>]  Theorem
      
       f. (x y. x  s  y  s  dist (f x,f y)  dist (x,y)) 
            f continuous_on s
   
   [<a name="CONVERGENT_BOUNDED_INCREASING-val"><b>CONVERGENT_BOUNDED_INCREASING</b></a>]  Theorem
      
       s b.
          (m n. m  n  s m  s n)  (n. abs (s n)  b) 
          l. e. 0 &lt; e  N. n. N  n  abs (s n  l) &lt; e
   
   [<a name="CONVERGENT_BOUNDED_MONOTONE-val"><b>CONVERGENT_BOUNDED_MONOTONE</b></a>]  Theorem
      
       s b.
          (n. abs (s n)  b) 
          ((m n. m  n  s m  s n)  m n. m  n  s n  s m) 
          l. e. 0 &lt; e  N. n. N  n  abs (s n  l) &lt; e
   
   [<a name="CONVERGENT_EQ_CAUCHY-val"><b>CONVERGENT_EQ_CAUCHY</b></a>]  Theorem
      
       s. (l. (s  l) sequentially)  cauchy s
   
   [<a name="CONVERGENT_IMP_BOUNDED-val"><b>CONVERGENT_IMP_BOUNDED</b></a>]  Theorem
      
       s l. (s  l) sequentially  bounded (IMAGE s (:num))
   
   [<a name="CONVERGENT_IMP_CAUCHY-val"><b>CONVERGENT_IMP_CAUCHY</b></a>]  Theorem
      
       s l. (s  l) sequentially  cauchy s
   
   [<a name="COUNTABLE_OPEN_INTERVAL-val"><b>COUNTABLE_OPEN_INTERVAL</b></a>]  Theorem
      
       a b. countable (interval (a,b))  interval (a,b) = 
   
   [<a name="DECREASING_CLOSED_NEST-val"><b>DECREASING_CLOSED_NEST</b></a>]  Theorem
      
       s. (n. closed (s n))  (n. s n  ) 
            (m n. m  n  s n  s m) 
            (e. 0 &lt; e  n. x y. x  s n  y  s n  dist (x,y) &lt; e) 
            a. n. a  s n
   
   [<a name="DECREASING_CLOSED_NEST_SING-val"><b>DECREASING_CLOSED_NEST_SING</b></a>]  Theorem
      
       s. (n. closed (s n))  (n. s n  ) 
            (m n. m  n  s n  s m) 
            (e. 0 &lt; e  n. x y. x  s n  y  s n  dist (x,y) &lt; e) 
            a. BIGINTER {t | (n. t = s n)} = {a}
   
   [<a name="DENSE_IMP_PERFECT-val"><b>DENSE_IMP_PERFECT</b></a>]  Theorem
      
       s. closure s = (:real)  x. x  s  x limit_point_of s
   
   [<a name="DENSE_LIMIT_POINTS-val"><b>DENSE_LIMIT_POINTS</b></a>]  Theorem
      
       x. {x | x limit_point_of s} = (:real)  closure s = (:real)
   
   [<a name="DENSE_OPEN_INTER-val"><b>DENSE_OPEN_INTER</b></a>]  Theorem
      
       s t u.
          open_in (subtopology euclidean u) s  t  u 
          open_in (subtopology euclidean u) t  s  u 
          (u  closure (s  t)  u  closure s  u  closure t)
   
   [<a name="DEPENDENT_CHOICE-val"><b>DEPENDENT_CHOICE</b></a>]  Theorem
      
       P R.
          (a. P 0 a)  (n x. P n x  y. P (SUC n) y  R n x y) 
          f. (n. P n (f n))  n. R n (f n) (f (SUC n))
   
   [<a name="DEPENDENT_CHOICE_FIXED-val"><b>DEPENDENT_CHOICE_FIXED</b></a>]  Theorem
      
       P R a.
          P 0 a  (n x. P n x  y. P (SUC n) y  R n x y) 
          f. f 0 = a  (n. P n (f n))  n. R n (f n) (f (SUC n))
   
   [<a name="DEPENDENT_EXPLICIT-val"><b>DEPENDENT_EXPLICIT</b></a>]  Theorem
      
       p. dependent p 
            s u.
              FINITE s  s  p  (v. v  s  u v  0) 
              sum s (v. u v * v) = 0
   
   [<a name="DEPENDENT_MONO-val"><b>DEPENDENT_MONO</b></a>]  Theorem
      
       s t. dependent s  s  t  dependent t
   
   [<a name="DIAMETER_BALL-val"><b>DIAMETER_BALL</b></a>]  Theorem
      
       a r. diameter (ball (a,r)) = if r &lt; 0 then 0 else 2 * r
   
   [<a name="DIAMETER_BOUNDED-val"><b>DIAMETER_BOUNDED</b></a>]  Theorem
      
       s. bounded s 
            (x y. x  s  y  s  abs (x  y)  diameter s) 
            d. 0  d  d &lt; diameter s 
                x y. x  s  y  s  abs (x  y) &gt; d
   
   [<a name="DIAMETER_BOUNDED_BOUND-val"><b>DIAMETER_BOUNDED_BOUND</b></a>]  Theorem
      
       s x y. bounded s  x  s  y  s  abs (x  y)  diameter s
   
   [<a name="DIAMETER_CBALL-val"><b>DIAMETER_CBALL</b></a>]  Theorem
      
       a r. diameter (cball (a,r)) = if r &lt; 0 then 0 else 2 * r
   
   [<a name="DIAMETER_CLOSURE-val"><b>DIAMETER_CLOSURE</b></a>]  Theorem
      
       s. bounded s  diameter (closure s) = diameter s
   
   [<a name="DIAMETER_EMPTY-val"><b>DIAMETER_EMPTY</b></a>]  Theorem
      
       diameter  = 0
   
   [<a name="DIAMETER_EQ_0-val"><b>DIAMETER_EQ_0</b></a>]  Theorem
      
       s. bounded s  (diameter s = 0  s =   a. s = {a})
   
   [<a name="DIAMETER_INTERVAL-val"><b>DIAMETER_INTERVAL</b></a>]  Theorem
      
       (a b.
           diameter (interval [(a,b)]) =
           if interval [(a,b)] =  then 0 else abs (b  a)) 
        a b.
          diameter (interval (a,b)) =
          if interval (a,b) =  then 0 else abs (b  a)
   
   [<a name="DIAMETER_LE-val"><b>DIAMETER_LE</b></a>]  Theorem
      
       s d.
          (s    0  d)  (x y. x  s  y  s  abs (x  y)  d) 
          diameter s  d
   
   [<a name="DIAMETER_LINEAR_IMAGE-val"><b>DIAMETER_LINEAR_IMAGE</b></a>]  Theorem
      
       f s.
          linear f  (x. abs (f x) = abs x) 
          diameter (IMAGE f s) = diameter s
   
   [<a name="DIAMETER_POS_LE-val"><b>DIAMETER_POS_LE</b></a>]  Theorem
      
       s. bounded s  0  diameter s
   
   [<a name="DIAMETER_SING-val"><b>DIAMETER_SING</b></a>]  Theorem
      
       a. diameter {a} = 0
   
   [<a name="DIAMETER_SUBSET-val"><b>DIAMETER_SUBSET</b></a>]  Theorem
      
       s t. s  t  bounded t  diameter s  diameter t
   
   [<a name="DIAMETER_SUBSET_CBALL-val"><b>DIAMETER_SUBSET_CBALL</b></a>]  Theorem
      
       s. bounded s  z. s  cball (z,diameter s)
   
   [<a name="DIAMETER_SUBSET_CBALL_NONEMPTY-val"><b>DIAMETER_SUBSET_CBALL_NONEMPTY</b></a>]  Theorem
      
       s. bounded s  s    z. z  s  s  cball (z,diameter s)
   
   [<a name="DIAMETER_SUMS-val"><b>DIAMETER_SUMS</b></a>]  Theorem
      
       s t.
          bounded s  bounded t 
          diameter {x + y | x  s  y  t}  diameter s + diameter t
   
   [<a name="DIFF_CLOSURE_SUBSET-val"><b>DIFF_CLOSURE_SUBSET</b></a>]  Theorem
      
       s t. closure s DIFF closure t  closure (s DIFF t)
   
   [<a name="DIM_LE_CARD-val"><b>DIM_LE_CARD</b></a>]  Theorem
      
       s. FINITE s  dim s  CARD s
   
   [<a name="DIM_SUBSET-val"><b>DIM_SUBSET</b></a>]  Theorem
      
       s t. s  t  dim s  dim t
   
   [<a name="DIM_SUBSET_UNIV-val"><b>DIM_SUBSET_UNIV</b></a>]  Theorem
      
       s. dim s  1
   
   [<a name="DIM_SUBSTANDARD-val"><b>DIM_SUBSTANDARD</b></a>]  Theorem
      
       dim {x | x = 0} = 0
   
   [<a name="DIM_UNIQUE-val"><b>DIM_UNIQUE</b></a>]  Theorem
      
       v b. b  v  v  span b  independent b  b HAS_SIZE n  dim v = n
   
   [<a name="DIM_UNIV-val"><b>DIM_UNIV</b></a>]  Theorem
      
       dim (:real) = 1
   
   [<a name="DINI-val"><b>DINI</b></a>]  Theorem
      
       f g s.
          compact s  (n. f n continuous_on s)  g continuous_on s 
          (x. x  s  ((n. f n x)  g x) sequentially) 
          (n x. x  s  f n x  f (n + 1) x) 
          e. 0 &lt; e 
              eventually (n. x. x  s  abs (f n x  g x) &lt; e)
                sequentially
   
   [<a name="DISCRETE_BOUNDED_IMP_FINITE-val"><b>DISCRETE_BOUNDED_IMP_FINITE</b></a>]  Theorem
      
       s e.
          0 &lt; e  (x y. x  s  y  s  abs (y  x) &lt; e  y = x) 
          bounded s 
          FINITE s
   
   [<a name="DISCRETE_IMP_CLOSED-val"><b>DISCRETE_IMP_CLOSED</b></a>]  Theorem
      
       s e.
          0 &lt; e  (x y. x  s  y  s  abs (y  x) &lt; e  y = x) 
          closed s
   
   [<a name="DISJOINT_INTERVAL-val"><b>DISJOINT_INTERVAL</b></a>]  Theorem
      
       a b c d.
          (interval [(a,b)]  interval [(c,d)] =  
           b &lt; a  d &lt; c  b &lt; c  d &lt; a) 
          (interval [(a,b)]  interval (c,d) =  
           b &lt; a  d  c  b  c  d  a) 
          (interval (a,b)  interval [(c,d)] =  
           b  a  d &lt; c  b  c  d  a) 
          (interval (a,b)  interval (c,d) =  
           b  a  d  c  b  c  d  a)
   
   [<a name="DISTANCE_ATTAINS_INF-val"><b>DISTANCE_ATTAINS_INF</b></a>]  Theorem
      
       s a.
          closed s  s   
          x. x  s  y. y  s  dist (a,x)  dist (a,y)
   
   [<a name="DISTANCE_ATTAINS_SUP-val"><b>DISTANCE_ATTAINS_SUP</b></a>]  Theorem
      
       s a.
          compact s  s   
          x. x  s  y. y  s  dist (a,y)  dist (a,x)
   
   [<a name="DIST_0-val"><b>DIST_0</b></a>]  Theorem
      
       x. dist (x,0) = abs x  dist (0,x) = abs x
   
   [<a name="DIST_CLOSEST_POINT_LIPSCHITZ-val"><b>DIST_CLOSEST_POINT_LIPSCHITZ</b></a>]  Theorem
      
       s x y.
          closed s  s   
          abs (dist (x,closest_point s x)  dist (y,closest_point s y)) 
          dist (x,y)
   
   [<a name="DIST_EQ-val"><b>DIST_EQ</b></a>]  Theorem
      
       w x y z. dist (w,x) = dist (y,z)  (dist (w,x)) = (dist (y,z))
   
   [<a name="DIST_EQ_0-val"><b>DIST_EQ_0</b></a>]  Theorem
      
       x y. dist (x,y) = 0  x = y
   
   [<a name="DIST_IN_CLOSED_SEGMENT-val"><b>DIST_IN_CLOSED_SEGMENT</b></a>]  Theorem
      
       a b x.
          x  segment [(a,b)] 
          dist (x,a)  dist (a,b)  dist (x,b)  dist (a,b)
   
   [<a name="DIST_IN_OPEN_CLOSED_SEGMENT-val"><b>DIST_IN_OPEN_CLOSED_SEGMENT</b></a>]  Theorem
      
       (a b x.
           x  segment [(a,b)] 
           dist (x,a)  dist (a,b)  dist (x,b)  dist (a,b)) 
        a b x.
          x  segment (a,b) 
          dist (x,a) &lt; dist (a,b)  dist (x,b) &lt; dist (a,b)
   
   [<a name="DIST_IN_OPEN_SEGMENT-val"><b>DIST_IN_OPEN_SEGMENT</b></a>]  Theorem
      
       a b x.
          x  segment (a,b) 
          dist (x,a) &lt; dist (a,b)  dist (x,b) &lt; dist (a,b)
   
   [<a name="DIST_LE_0-val"><b>DIST_LE_0</b></a>]  Theorem
      
       x y. dist (x,y)  0  x = y
   
   [<a name="DIST_MIDPOINT-val"><b>DIST_MIDPOINT</b></a>]  Theorem
      
       a b.
          dist (a,midpoint (a,b)) = dist (a,b) / 2 
          dist (b,midpoint (a,b)) = dist (a,b) / 2 
          dist (midpoint (a,b),a) = dist (a,b) / 2 
          dist (midpoint (a,b),b) = dist (a,b) / 2
   
   [<a name="DIST_MUL-val"><b>DIST_MUL</b></a>]  Theorem
      
       x y c. dist (c * x,c * y) = abs c * dist (x,y)
   
   [<a name="DIST_NZ-val"><b>DIST_NZ</b></a>]  Theorem
      
       x y. x  y  0 &lt; dist (x,y)
   
   [<a name="DIST_POS_LE-val"><b>DIST_POS_LE</b></a>]  Theorem
      
       x y. 0  dist (x,y)
   
   [<a name="DIST_POS_LT-val"><b>DIST_POS_LT</b></a>]  Theorem
      
       x y. x  y  0 &lt; dist (x,y)
   
   [<a name="DIST_REFL-val"><b>DIST_REFL</b></a>]  Theorem
      
       x. dist (x,x) = 0
   
   [<a name="DIST_SYM-val"><b>DIST_SYM</b></a>]  Theorem
      
       x y. dist (x,y) = dist (y,x)
   
   [<a name="DIST_TRIANGLE-val"><b>DIST_TRIANGLE</b></a>]  Theorem
      
       x y z. dist (x,z)  dist (x,y) + dist (y,z)
   
   [<a name="DIST_TRIANGLE_ADD-val"><b>DIST_TRIANGLE_ADD</b></a>]  Theorem
      
       x x' y y'. dist (x + y,x' + y')  dist (x,x') + dist (y,y')
   
   [<a name="DIST_TRIANGLE_ADD_HALF-val"><b>DIST_TRIANGLE_ADD_HALF</b></a>]  Theorem
      
       x x' y y'.
          dist (x,x') &lt; e / 2  dist (y,y') &lt; e / 2 
          dist (x + y,x' + y') &lt; e
   
   [<a name="DIST_TRIANGLE_ALT-val"><b>DIST_TRIANGLE_ALT</b></a>]  Theorem
      
       x y z. dist (y,z)  dist (x,y) + dist (x,z)
   
   [<a name="DIST_TRIANGLE_EQ-val"><b>DIST_TRIANGLE_EQ</b></a>]  Theorem
      
       x y z.
          dist (x,z) = dist (x,y) + dist (y,z) 
          abs (x  y) * (y  z) = abs (y  z) * (x  y)
   
   [<a name="DIST_TRIANGLE_HALF_L-val"><b>DIST_TRIANGLE_HALF_L</b></a>]  Theorem
      
       x1 x2 y.
          dist (x1,y) &lt; e / 2  dist (x2,y) &lt; e / 2  dist (x1,x2) &lt; e
   
   [<a name="DIST_TRIANGLE_HALF_R-val"><b>DIST_TRIANGLE_HALF_R</b></a>]  Theorem
      
       x1 x2 y.
          dist (y,x1) &lt; e / 2  dist (y,x2) &lt; e / 2  dist (x1,x2) &lt; e
   
   [<a name="DIST_TRIANGLE_LE-val"><b>DIST_TRIANGLE_LE</b></a>]  Theorem
      
       x y z e. dist (x,z) + dist (y,z)  e  dist (x,y)  e
   
   [<a name="DIST_TRIANGLE_LT-val"><b>DIST_TRIANGLE_LT</b></a>]  Theorem
      
       x y z e. dist (x,z) + dist (y,z) &lt; e  dist (x,y) &lt; e
   
   [<a name="DORDER_NET-val"><b>DORDER_NET</b></a>]  Theorem
      
       n. dorder (netord n)
   
   [<a name="EMPTY_AS_INTERVAL-val"><b>EMPTY_AS_INTERVAL</b></a>]  Theorem
      
        = interval [(1,0)]
   
   [<a name="EMPTY_INTERIOR_FINITE-val"><b>EMPTY_INTERIOR_FINITE</b></a>]  Theorem
      
       s. FINITE s  interior s = 
   
   [<a name="ENDS_IN_INTERVAL-val"><b>ENDS_IN_INTERVAL</b></a>]  Theorem
      
       (a b. a  interval [(a,b)]  interval [(a,b)]  ) 
        (a b. b  interval [(a,b)]  interval [(a,b)]  ) 
        (a b. a  interval (a,b))  a b. b  interval (a,b)
   
   [<a name="ENDS_IN_SEGMENT-val"><b>ENDS_IN_SEGMENT</b></a>]  Theorem
      
       a b. a  segment [(a,b)]  b  segment [(a,b)]
   
   [<a name="ENDS_IN_UNIT_INTERVAL-val"><b>ENDS_IN_UNIT_INTERVAL</b></a>]  Theorem
      
       0  interval [(0,1)]  1  interval [(0,1)]  0  interval (0,1) 
        1  interval (0,1)
   
   [<a name="ENDS_NOT_IN_SEGMENT-val"><b>ENDS_NOT_IN_SEGMENT</b></a>]  Theorem
      
       a b. a  segment (a,b)  b  segment (a,b)
   
   [<a name="EQ_BALLS-val"><b>EQ_BALLS</b></a>]  Theorem
      
       (a a' r r'.
           ball (a,r) = ball (a',r')  a = a'  r = r'  r  0  r'  0) 
        (a a' r r'. ball (a,r) = cball (a',r')  r  0  r' &lt; 0) 
        (a a' r r'. cball (a,r) = ball (a',r')  r &lt; 0  r'  0) 
        a a' r r'.
          cball (a,r) = cball (a',r')  a = a'  r = r'  r &lt; 0  r' &lt; 0
   
   [<a name="EQ_INTERVAL-val"><b>EQ_INTERVAL</b></a>]  Theorem
      
       (a b c d.
           interval [(a,b)] = interval [(c,d)] 
           interval [(a,b)] =   interval [(c,d)] =   a = c  b = d) 
        (a b c d.
           interval [(a,b)] = interval (c,d) 
           interval [(a,b)] =   interval (c,d) = ) 
        (a b c d.
           interval (a,b) = interval [(c,d)] 
           interval (a,b) =   interval [(c,d)] = ) 
        a b c d.
          interval (a,b) = interval (c,d) 
          interval (a,b) =   interval (c,d) =   a = c  b = d
   
   [<a name="EVENTUALLY_AND-val"><b>EVENTUALLY_AND</b></a>]  Theorem
      
       net p q.
          eventually (x. p x  q x) net 
          eventually p net  eventually q net
   
   [<a name="EVENTUALLY_AT-val"><b>EVENTUALLY_AT</b></a>]  Theorem
      
       a p.
          eventually p (at a) 
          d. 0 &lt; d  x. 0 &lt; dist (x,a)  dist (x,a) &lt; d  p x
   
   [<a name="EVENTUALLY_AT_INFINITY-val"><b>EVENTUALLY_AT_INFINITY</b></a>]  Theorem
      
       p. eventually p at_infinity  b. x. abs x  b  p x
   
   [<a name="EVENTUALLY_AT_INFINITY_POS-val"><b>EVENTUALLY_AT_INFINITY_POS</b></a>]  Theorem
      
       p. eventually p at_infinity  b. 0 &lt; b  x. abs x  b  p x
   
   [<a name="EVENTUALLY_AT_NEGINFINITY-val"><b>EVENTUALLY_AT_NEGINFINITY</b></a>]  Theorem
      
       p. eventually p at_neginfinity  b. x. x  b  p x
   
   [<a name="EVENTUALLY_AT_POSINFINITY-val"><b>EVENTUALLY_AT_POSINFINITY</b></a>]  Theorem
      
       p. eventually p at_posinfinity  b. x. x  b  p x
   
   [<a name="EVENTUALLY_FALSE-val"><b>EVENTUALLY_FALSE</b></a>]  Theorem
      
       net. eventually (x. F) net  trivial_limit net
   
   [<a name="EVENTUALLY_FORALL-val"><b>EVENTUALLY_FORALL</b></a>]  Theorem
      
       net p s.
          FINITE s  s   
          (eventually (x. a. a  s  p a x) net 
           a. a  s  eventually (p a) net)
   
   [<a name="EVENTUALLY_HAPPENS-val"><b>EVENTUALLY_HAPPENS</b></a>]  Theorem
      
       net p. eventually p net  trivial_limit net  x. p x
   
   [<a name="EVENTUALLY_MONO-val"><b>EVENTUALLY_MONO</b></a>]  Theorem
      
       net p q. (x. p x  q x)  eventually p net  eventually q net
   
   [<a name="EVENTUALLY_MP-val"><b>EVENTUALLY_MP</b></a>]  Theorem
      
       net p q.
          eventually (x. p x  q x) net  eventually p net 
          eventually q net
   
   [<a name="EVENTUALLY_SEQUENTIALLY-val"><b>EVENTUALLY_SEQUENTIALLY</b></a>]  Theorem
      
       p. eventually p sequentially  N. n. N  n  p n
   
   [<a name="EVENTUALLY_TRUE-val"><b>EVENTUALLY_TRUE</b></a>]  Theorem
      
       net. eventually (x. T) net  T
   
   [<a name="EVENTUALLY_WITHIN-val"><b>EVENTUALLY_WITHIN</b></a>]  Theorem
      
       s a p.
          eventually p (at a within s) 
          d. 0 &lt; d  x. x  s  0 &lt; dist (x,a)  dist (x,a) &lt; d  p x
   
   [<a name="EVENTUALLY_WITHIN_INTERIOR-val"><b>EVENTUALLY_WITHIN_INTERIOR</b></a>]  Theorem
      
       p s x.
          x  interior s 
          (eventually p (at x within s)  eventually p (at x))
   
   [<a name="EVENTUALLY_WITHIN_LE-val"><b>EVENTUALLY_WITHIN_LE</b></a>]  Theorem
      
       s a p.
          eventually p (at a within s) 
          d. 0 &lt; d  x. x  s  0 &lt; dist (x,a)  dist (x,a)  d  p x
   
   [<a name="EXCHANGE_LEMMA-val"><b>EXCHANGE_LEMMA</b></a>]  Theorem
      
       s t.
          FINITE t  independent s  s  span t 
          t'. t' HAS_SIZE CARD t  s  t'  t'  s  t  s  span t'
   
   [<a name="EXISTS_COMPONENT_SUPERSET-val"><b>EXISTS_COMPONENT_SUPERSET</b></a>]  Theorem
      
       s t. t  s  s    connected t  c. c  components s  t  c
   
   [<a name="EXISTS_DIFF-val"><b>EXISTS_DIFF</b></a>]  Theorem
      
       (s. P ((:) DIFF s))  s. P s
   
   [<a name="EXISTS_IN_INSERT-val"><b>EXISTS_IN_INSERT</b></a>]  Theorem
      
       P a s. (x. x  a INSERT s  P x)  P a  x. x  s  P x
   
   [<a name="EXTENSION_FROM_CLOPEN-val"><b>EXTENSION_FROM_CLOPEN</b></a>]  Theorem
      
       f s t u.
          open_in (subtopology euclidean s) t 
          closed_in (subtopology euclidean s) t  f continuous_on t 
          IMAGE f t  u  (u =   s = ) 
          g. g continuous_on s  IMAGE g s  u  x. x  t  g x = f x
   
   [<a name="FINITE_BALL-val"><b>FINITE_BALL</b></a>]  Theorem
      
       a r. FINITE (ball (a,r))  r  0
   
   [<a name="FINITE_CBALL-val"><b>FINITE_CBALL</b></a>]  Theorem
      
       a r. FINITE (cball (a,r))  r  0
   
   [<a name="FINITE_IMP_BOUNDED-val"><b>FINITE_IMP_BOUNDED</b></a>]  Theorem
      
       s. FINITE s  bounded s
   
   [<a name="FINITE_IMP_CLOSED-val"><b>FINITE_IMP_CLOSED</b></a>]  Theorem
      
       s. FINITE s  closed s
   
   [<a name="FINITE_IMP_CLOSED_IN-val"><b>FINITE_IMP_CLOSED_IN</b></a>]  Theorem
      
       s t. FINITE s  s  t  closed_in (subtopology euclidean t) s
   
   [<a name="FINITE_IMP_COMPACT-val"><b>FINITE_IMP_COMPACT</b></a>]  Theorem
      
       s. FINITE s  compact s
   
   [<a name="FINITE_IMP_NOT_OPEN-val"><b>FINITE_IMP_NOT_OPEN</b></a>]  Theorem
      
       s. FINITE s  s    open s
   
   [<a name="FINITE_INTERVAL-val"><b>FINITE_INTERVAL</b></a>]  Theorem
      
       (a b. FINITE (interval [(a,b)])  b  a) 
        a b. FINITE (interval (a,b))  b  a
   
   [<a name="FINITE_INTER_NUMSEG-val"><b>FINITE_INTER_NUMSEG</b></a>]  Theorem
      
       s m n. FINITE (s  {m .. n})
   
   [<a name="FINITE_SET_AVOID-val"><b>FINITE_SET_AVOID</b></a>]  Theorem
      
       a s. FINITE s  d. 0 &lt; d  x. x  s  x  a  d  dist (a,x)
   
   [<a name="FINITE_SPHERE-val"><b>FINITE_SPHERE</b></a>]  Theorem
      
       a r. FINITE (sphere (a,r))
   
   [<a name="FORALL_EVENTUALLY-val"><b>FORALL_EVENTUALLY</b></a>]  Theorem
      
       net p s.
          FINITE s  s   
          ((a. a  s  eventually (p a) net) 
           eventually (x. a. a  s  p a x) net)
   
   [<a name="FORALL_IN_CLOSURE-val"><b>FORALL_IN_CLOSURE</b></a>]  Theorem
      
       f s t.
          closed t  f continuous_on closure s  (x. x  s  f x  t) 
          x. x  closure s  f x  t
   
   [<a name="FORALL_IN_CLOSURE_EQ-val"><b>FORALL_IN_CLOSURE_EQ</b></a>]  Theorem
      
       f s t.
          closed t  f continuous_on closure s 
          ((x. x  closure s  f x  t)  x. x  s  f x  t)
   
   [<a name="FORALL_POS_MONO_1-val"><b>FORALL_POS_MONO_1</b></a>]  Theorem
      
       P. (d e. d &lt; e  P d  P e)  (n. P (&n + 1)) 
            e. 0 &lt; e  P e
   
   [<a name="FRONTIER_BALL-val"><b>FRONTIER_BALL</b></a>]  Theorem
      
       a e. 0 &lt; e  frontier (ball (a,e)) = sphere (a,e)
   
   [<a name="FRONTIER_CBALL-val"><b>FRONTIER_CBALL</b></a>]  Theorem
      
       a e. frontier (cball (a,e)) = sphere (a,e)
   
   [<a name="FRONTIER_CLOSED-val"><b>FRONTIER_CLOSED</b></a>]  Theorem
      
       s. closed (frontier s)
   
   [<a name="FRONTIER_CLOSED_INTERVAL-val"><b>FRONTIER_CLOSED_INTERVAL</b></a>]  Theorem
      
       a b.
          frontier (interval [(a,b)]) =
          interval [(a,b)] DIFF interval (a,b)
   
   [<a name="FRONTIER_CLOSURES-val"><b>FRONTIER_CLOSURES</b></a>]  Theorem
      
       s. frontier s = closure s  closure ((:real) DIFF s)
   
   [<a name="FRONTIER_CLOSURE_SUBSET-val"><b>FRONTIER_CLOSURE_SUBSET</b></a>]  Theorem
      
       s. frontier (closure s)  frontier s
   
   [<a name="FRONTIER_COMPLEMENT-val"><b>FRONTIER_COMPLEMENT</b></a>]  Theorem
      
       s. frontier ((:real) DIFF s) = frontier s
   
   [<a name="FRONTIER_DISJOINT_EQ-val"><b>FRONTIER_DISJOINT_EQ</b></a>]  Theorem
      
       s. frontier s  s =   open s
   
   [<a name="FRONTIER_EMPTY-val"><b>FRONTIER_EMPTY</b></a>]  Theorem
      
       frontier  = 
   
   [<a name="FRONTIER_FRONTIER-val"><b>FRONTIER_FRONTIER</b></a>]  Theorem
      
       s. open s  closed s  frontier (frontier s) = frontier s
   
   [<a name="FRONTIER_FRONTIER_FRONTIER-val"><b>FRONTIER_FRONTIER_FRONTIER</b></a>]  Theorem
      
       s. frontier (frontier (frontier s)) = frontier (frontier s)
   
   [<a name="FRONTIER_FRONTIER_SUBSET-val"><b>FRONTIER_FRONTIER_SUBSET</b></a>]  Theorem
      
       s. frontier (frontier s)  frontier s
   
   [<a name="FRONTIER_HALFSPACE_GE-val"><b>FRONTIER_HALFSPACE_GE</b></a>]  Theorem
      
       a b. (a = 0  b = 0)  frontier {x | a * x  b} = {x | a * x = b}
   
   [<a name="FRONTIER_HALFSPACE_GT-val"><b>FRONTIER_HALFSPACE_GT</b></a>]  Theorem
      
       a b. (a = 0  b = 0)  frontier {x | a * x &gt; b} = {x | a * x = b}
   
   [<a name="FRONTIER_HALFSPACE_LE-val"><b>FRONTIER_HALFSPACE_LE</b></a>]  Theorem
      
       a b. (a = 0  b = 0)  frontier {x | a * x  b} = {x | a * x = b}
   
   [<a name="FRONTIER_HALFSPACE_LT-val"><b>FRONTIER_HALFSPACE_LT</b></a>]  Theorem
      
       a b. (a = 0  b = 0)  frontier {x | a * x &lt; b} = {x | a * x = b}
   
   [<a name="FRONTIER_INTERIORS-val"><b>FRONTIER_INTERIORS</b></a>]  Theorem
      
       s. frontier s =
            (:real) DIFF interior s DIFF interior ((:real) DIFF s)
   
   [<a name="FRONTIER_INTERIOR_SUBSET-val"><b>FRONTIER_INTERIOR_SUBSET</b></a>]  Theorem
      
       s. frontier (interior s)  frontier s
   
   [<a name="FRONTIER_INTER_SUBSET-val"><b>FRONTIER_INTER_SUBSET</b></a>]  Theorem
      
       s t. frontier (s  t)  frontier s  frontier t
   
   [<a name="FRONTIER_INTER_SUBSET_INTER-val"><b>FRONTIER_INTER_SUBSET_INTER</b></a>]  Theorem
      
       s t.
          frontier (s  t) 
          closure s  frontier t  frontier s  closure t
   
   [<a name="FRONTIER_OPEN_INTERVAL-val"><b>FRONTIER_OPEN_INTERVAL</b></a>]  Theorem
      
       a b.
          frontier (interval (a,b)) =
          if interval (a,b) =  then 
          else interval [(a,b)] DIFF interval (a,b)
   
   [<a name="FRONTIER_SING-val"><b>FRONTIER_SING</b></a>]  Theorem
      
       a. frontier {a} = {a}
   
   [<a name="FRONTIER_STRADDLE-val"><b>FRONTIER_STRADDLE</b></a>]  Theorem
      
       a s.
          a  frontier s 
          e. 0 &lt; e 
              (x. x  s  dist (a,x) &lt; e)  x. x  s  dist (a,x) &lt; e
   
   [<a name="FRONTIER_SUBSET_CLOSED-val"><b>FRONTIER_SUBSET_CLOSED</b></a>]  Theorem
      
       s. closed s  frontier s  s
   
   [<a name="FRONTIER_SUBSET_COMPACT-val"><b>FRONTIER_SUBSET_COMPACT</b></a>]  Theorem
      
       s. compact s  frontier s  s
   
   [<a name="FRONTIER_SUBSET_EQ-val"><b>FRONTIER_SUBSET_EQ</b></a>]  Theorem
      
       s. frontier s  s  closed s
   
   [<a name="FRONTIER_UNION-val"><b>FRONTIER_UNION</b></a>]  Theorem
      
       s t.
          closure s  closure t =  
          frontier (s  t) = frontier s  frontier t
   
   [<a name="FRONTIER_UNION_SUBSET-val"><b>FRONTIER_UNION_SUBSET</b></a>]  Theorem
      
       s t. frontier (s  t)  frontier s  frontier t
   
   [<a name="FRONTIER_UNIV-val"><b>FRONTIER_UNIV</b></a>]  Theorem
      
       frontier (:real) = 
   
   [<a name="FUNCTION_FACTORS_LEFT_GEN-val"><b>FUNCTION_FACTORS_LEFT_GEN</b></a>]  Theorem
      
       P f g.
          (x y. P x  P y  g x = g y  f x = f y) 
          h. x. P x  f x = h (g x)
   
   [<a name="GDELTA_COMPLEMENT-val"><b>GDELTA_COMPLEMENT</b></a>]  Theorem
      
       s. gdelta ((:real) DIFF s)  fsigma s
   
   [<a name="GREATER_EQ_REFL-val"><b>GREATER_EQ_REFL</b></a>]  Theorem
      
       m. m  m
   
   [<a name="HAS_SIZE_STDBASIS-val"><b>HAS_SIZE_STDBASIS</b></a>]  Theorem
      
       {i | 1  i  i  1} HAS_SIZE 1
   
   [<a name="HAUSDIST_ALT-val"><b>HAUSDIST_ALT</b></a>]  Theorem
      
       s t.
          bounded s  bounded t  s    t   
          hausdist (s,t) =
          sup {abs (setdist ({x},s)  setdist ({x},t)) | x  (:real)}
   
   [<a name="HAUSDIST_BALLS-val"><b>HAUSDIST_BALLS</b></a>]  Theorem
      
       (a b r s.
           hausdist (ball (a,r),ball (b,s)) =
           if r  0  s  0 then 0 else dist (a,b) + abs (r  s)) 
        (a b r s.
           hausdist (ball (a,r),cball (b,s)) =
           if r  0  s &lt; 0 then 0 else dist (a,b) + abs (r  s)) 
        (a b r s.
           hausdist (cball (a,r),ball (b,s)) =
           if r &lt; 0  s  0 then 0 else dist (a,b) + abs (r  s)) 
        a b r s.
          hausdist (cball (a,r),cball (b,s)) =
          if r &lt; 0  s &lt; 0 then 0 else dist (a,b) + abs (r  s)
   
   [<a name="HAUSDIST_CLOSURE-val"><b>HAUSDIST_CLOSURE</b></a>]  Theorem
      
       (s t. hausdist (closure s,t) = hausdist (s,t)) 
        s t. hausdist (s,closure t) = hausdist (s,t)
   
   [<a name="HAUSDIST_COMPACT_EXISTS-val"><b>HAUSDIST_COMPACT_EXISTS</b></a>]  Theorem
      
       s t.
          bounded s  compact t  t   
          x. x  s  y. y  t  dist (x,y)  hausdist (s,t)
   
   [<a name="HAUSDIST_COMPACT_NONTRIVIAL-val"><b>HAUSDIST_COMPACT_NONTRIVIAL</b></a>]  Theorem
      
       s t.
          compact s  compact t  s    t   
          hausdist (s,t) =
          inf
            {e |
             0  e  s  {x + y | x  t  abs y  e} 
             t  {x + y | x  s  abs y  e}}
   
   [<a name="HAUSDIST_COMPACT_SUMS-val"><b>HAUSDIST_COMPACT_SUMS</b></a>]  Theorem
      
       s t.
          bounded s  compact t  t   
          s  {y + z | y  t  z  cball (0,hausdist (s,t))}
   
   [<a name="HAUSDIST_EMPTY-val"><b>HAUSDIST_EMPTY</b></a>]  Theorem
      
       (t. hausdist (,t) = 0)  s. hausdist (s,) = 0
   
   [<a name="HAUSDIST_EQ-val"><b>HAUSDIST_EQ</b></a>]  Theorem
      
       s t s' t'.
          (b. (x. x  s  setdist ({x},t)  b) 
               (y. y  t  setdist ({y},s)  b) 
               (x. x  s'  setdist ({x},t')  b) 
               y. y  t'  setdist ({y},s')  b) 
          hausdist (s,t) = hausdist (s',t')
   
   [<a name="HAUSDIST_EQ_0-val"><b>HAUSDIST_EQ_0</b></a>]  Theorem
      
       s t.
          bounded s  bounded t 
          (hausdist (s,t) = 0  s =   t =   closure s = closure t)
   
   [<a name="HAUSDIST_INSERT_LE-val"><b>HAUSDIST_INSERT_LE</b></a>]  Theorem
      
       s t a.
          bounded s  bounded t  s    t   
          hausdist (a INSERT s,a INSERT t)  hausdist (s,t)
   
   [<a name="HAUSDIST_LINEAR_IMAGE-val"><b>HAUSDIST_LINEAR_IMAGE</b></a>]  Theorem
      
       f s t.
          linear f  (x. abs (f x) = abs x) 
          hausdist (IMAGE f s,IMAGE f t) = hausdist (s,t)
   
   [<a name="HAUSDIST_NONTRIVIAL-val"><b>HAUSDIST_NONTRIVIAL</b></a>]  Theorem
      
       s t.
          bounded s  bounded t  s    t   
          hausdist (s,t) =
          sup ({setdist ({x},t) | x  s}  {setdist ({y},s) | y  t})
   
   [<a name="HAUSDIST_NONTRIVIAL_ALT-val"><b>HAUSDIST_NONTRIVIAL_ALT</b></a>]  Theorem
      
       s t.
          bounded s  bounded t  s    t   
          hausdist (s,t) =
          max (sup {setdist ({x},t) | x  s})
            (sup {setdist ({y},s) | y  t})
   
   [<a name="HAUSDIST_POS_LE-val"><b>HAUSDIST_POS_LE</b></a>]  Theorem
      
       s t. 0  hausdist (s,t)
   
   [<a name="HAUSDIST_REFL-val"><b>HAUSDIST_REFL</b></a>]  Theorem
      
       s. hausdist (s,s) = 0
   
   [<a name="HAUSDIST_SETDIST_TRIANGLE-val"><b>HAUSDIST_SETDIST_TRIANGLE</b></a>]  Theorem
      
       s t u.
          t    bounded s  bounded t 
          setdist (s,u)  hausdist (s,t) + setdist (t,u)
   
   [<a name="HAUSDIST_SINGS-val"><b>HAUSDIST_SINGS</b></a>]  Theorem
      
       x y. hausdist ({x},{y}) = dist (x,y)
   
   [<a name="HAUSDIST_SYM-val"><b>HAUSDIST_SYM</b></a>]  Theorem
      
       s t. hausdist (s,t) = hausdist (t,s)
   
   [<a name="HAUSDIST_TRANS-val"><b>HAUSDIST_TRANS</b></a>]  Theorem
      
       s t u.
          bounded s  bounded t  bounded u  t   
          hausdist (s,u)  hausdist (s,t) + hausdist (t,u)
   
   [<a name="HAUSDIST_TRANSLATION-val"><b>HAUSDIST_TRANSLATION</b></a>]  Theorem
      
       a s t.
          hausdist (IMAGE (x. a + x) s,IMAGE (x. a + x) t) =
          hausdist (s,t)
   
   [<a name="HAUSDIST_TRIANGLE-val"><b>HAUSDIST_TRIANGLE</b></a>]  Theorem
      
       s t u.
          bounded s  bounded t  bounded u  t   
          hausdist (s,u)  hausdist (s,t) + hausdist (t,u)
   
   [<a name="HAUSDIST_UNION_LE-val"><b>HAUSDIST_UNION_LE</b></a>]  Theorem
      
       s t u.
          bounded s  bounded t  bounded u  t    u   
          hausdist (s  t,s  u)  hausdist (t,u)
   
   [<a name="HEINE_BOREL_IMP_BOLZANO_WEIERSTRASS-val"><b>HEINE_BOREL_IMP_BOLZANO_WEIERSTRASS</b></a>]  Theorem
      
       s. (f. (t. t  f  open t)  s  BIGUNION f 
                 f'. f'  f  FINITE f'  s  BIGUNION f') 
            t. INFINITE t  t  s  x. x  s  x limit_point_of t
   
   [<a name="HEINE_BOREL_LEMMA-val"><b>HEINE_BOREL_LEMMA</b></a>]  Theorem
      
       s. compact s 
            t. s  BIGUNION t  (b. b  t  open b) 
                e. 0 &lt; e  x. x  s  b. b  t  ball (x,e)  b
   
   [<a name="HOMEOMORPHIC_AFFINITY-val"><b>HOMEOMORPHIC_AFFINITY</b></a>]  Theorem
      
       s a c. c  0  s homeomorphic IMAGE (x. a + c * x) s
   
   [<a name="HOMEOMORPHIC_BALLS-val"><b>HOMEOMORPHIC_BALLS</b></a>]  Theorem
      
       a b d e. 0 &lt; d  0 &lt; e  ball (a,d) homeomorphic ball (b,e)
   
   [<a name="HOMEOMORPHIC_BALLS_CBALL_SPHERE-val"><b>HOMEOMORPHIC_BALLS_CBALL_SPHERE</b></a>]  Theorem
      
       (a b d e. 0 &lt; d  0 &lt; e  ball (a,d) homeomorphic ball (b,e)) 
        (a b d e. 0 &lt; d  0 &lt; e  cball (a,d) homeomorphic cball (b,e)) 
        a b d e. 0 &lt; d  0 &lt; e  sphere (a,d) homeomorphic sphere (b,e)
   
   [<a name="HOMEOMORPHIC_CBALL-val"><b>HOMEOMORPHIC_CBALL</b></a>]  Theorem
      
       a b d e. 0 &lt; d  0 &lt; e  cball (a,d) homeomorphic cball (b,e)
   
   [<a name="HOMEOMORPHIC_COMPACT-val"><b>HOMEOMORPHIC_COMPACT</b></a>]  Theorem
      
       s f t.
          compact s  f continuous_on s  IMAGE f s = t 
          (x y. x  s  y  s  f x = f y  x = y) 
          s homeomorphic t
   
   [<a name="HOMEOMORPHIC_COMPACTNESS-val"><b>HOMEOMORPHIC_COMPACTNESS</b></a>]  Theorem
      
       s t. s homeomorphic t  (compact s  compact t)
   
   [<a name="HOMEOMORPHIC_CONNECTEDNESS-val"><b>HOMEOMORPHIC_CONNECTEDNESS</b></a>]  Theorem
      
       s t. s homeomorphic t  (connected s  connected t)
   
   [<a name="HOMEOMORPHIC_EMPTY-val"><b>HOMEOMORPHIC_EMPTY</b></a>]  Theorem
      
       (s. s homeomorphic   s = )  s.  homeomorphic s  s = 
   
   [<a name="HOMEOMORPHIC_FINITE-val"><b>HOMEOMORPHIC_FINITE</b></a>]  Theorem
      
       s t. FINITE s  FINITE t  (s homeomorphic t  CARD s = CARD t)
   
   [<a name="HOMEOMORPHIC_FINITENESS-val"><b>HOMEOMORPHIC_FINITENESS</b></a>]  Theorem
      
       s t. s homeomorphic t  (FINITE s  FINITE t)
   
   [<a name="HOMEOMORPHIC_FINITE_STRONG-val"><b>HOMEOMORPHIC_FINITE_STRONG</b></a>]  Theorem
      
       s t.
          FINITE s  FINITE t 
          (s homeomorphic t  FINITE s  FINITE t  CARD s = CARD t)
   
   [<a name="HOMEOMORPHIC_HYPERPLANES-val"><b>HOMEOMORPHIC_HYPERPLANES</b></a>]  Theorem
      
       a b c d.
          a  0  c  0  {x | a * x = b} homeomorphic {x | c * x = d}
   
   [<a name="HOMEOMORPHIC_HYPERPLANE_STANDARD_HYPERPLANE-val"><b>HOMEOMORPHIC_HYPERPLANE_STANDARD_HYPERPLANE</b></a>]  Theorem
      
       a b c. a  0  {x | a * x = b} homeomorphic {x | x = c}
   
   [<a name="HOMEOMORPHIC_IMP_CARD_EQ-val"><b>HOMEOMORPHIC_IMP_CARD_EQ</b></a>]  Theorem
      
       s t. s homeomorphic t  s  t
   
   [<a name="HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_LEFT_EQ-val"><b>HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_LEFT_EQ</b></a>]  Theorem
      
       f s t.
          linear f  (x y. f x = f y  x = y) 
          (IMAGE f s homeomorphic t  s homeomorphic t)
   
   [<a name="HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_RIGHT_EQ-val"><b>HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_RIGHT_EQ</b></a>]  Theorem
      
       f s t.
          linear f  (x y. f x = f y  x = y) 
          (s homeomorphic IMAGE f t  s homeomorphic t)
   
   [<a name="HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_SELF-val"><b>HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_SELF</b></a>]  Theorem
      
       f s.
          linear f  (x y. f x = f y  x = y)  IMAGE f s homeomorphic s
   
   [<a name="HOMEOMORPHIC_LOCALLY-val"><b>HOMEOMORPHIC_LOCALLY</b></a>]  Theorem
      
       P Q.
          (s t. s homeomorphic t  (P s  Q t)) 
          s t. s homeomorphic t  (locally P s  locally Q t)
   
   [<a name="HOMEOMORPHIC_LOCAL_COMPACTNESS-val"><b>HOMEOMORPHIC_LOCAL_COMPACTNESS</b></a>]  Theorem
      
       s t. s homeomorphic t  (locally compact s  locally compact t)
   
   [<a name="HOMEOMORPHIC_MINIMAL-val"><b>HOMEOMORPHIC_MINIMAL</b></a>]  Theorem
      
       s t.
          s homeomorphic t 
          f g.
            (x. x  s  f x  t  g (f x) = x) 
            (y. y  t  g y  s  f (g y) = y)  f continuous_on s 
            g continuous_on t
   
   [<a name="HOMEOMORPHIC_ONE_POINT_COMPACTIFICATIONS-val"><b>HOMEOMORPHIC_ONE_POINT_COMPACTIFICATIONS</b></a>]  Theorem
      
       s t a b.
          compact s  compact t  a  s  b  t 
          s DELETE a homeomorphic t DELETE b 
          s homeomorphic t
   
   [<a name="HOMEOMORPHIC_OPEN_INTERVALS-val"><b>HOMEOMORPHIC_OPEN_INTERVALS</b></a>]  Theorem
      
       a b c d.
          a &lt; b  c &lt; d  interval (a,b) homeomorphic interval (c,d)
   
   [<a name="HOMEOMORPHIC_OPEN_INTERVAL_UNIV-val"><b>HOMEOMORPHIC_OPEN_INTERVAL_UNIV</b></a>]  Theorem
      
       a b. a &lt; b  interval (a,b) homeomorphic (:real)
   
   [<a name="HOMEOMORPHIC_REFL-val"><b>HOMEOMORPHIC_REFL</b></a>]  Theorem
      
       s. s homeomorphic s
   
   [<a name="HOMEOMORPHIC_SCALING-val"><b>HOMEOMORPHIC_SCALING</b></a>]  Theorem
      
       s c. c  0  s homeomorphic IMAGE (x. c * x) s
   
   [<a name="HOMEOMORPHIC_SCALING_LEFT-val"><b>HOMEOMORPHIC_SCALING_LEFT</b></a>]  Theorem
      
       c. 0 &lt; c 
            s t. IMAGE (x. c * x) s homeomorphic t  s homeomorphic t
   
   [<a name="HOMEOMORPHIC_SCALING_RIGHT-val"><b>HOMEOMORPHIC_SCALING_RIGHT</b></a>]  Theorem
      
       c. 0 &lt; c 
            s t. s homeomorphic IMAGE (x. c * x) t  s homeomorphic t
   
   [<a name="HOMEOMORPHIC_SING-val"><b>HOMEOMORPHIC_SING</b></a>]  Theorem
      
       a b. {a} homeomorphic {b}
   
   [<a name="HOMEOMORPHIC_SPHERE-val"><b>HOMEOMORPHIC_SPHERE</b></a>]  Theorem
      
       a b d e. 0 &lt; d  0 &lt; e  sphere (a,d) homeomorphic sphere (b,e)
   
   [<a name="HOMEOMORPHIC_STANDARD_HYPERPLANE_HYPERPLANE-val"><b>HOMEOMORPHIC_STANDARD_HYPERPLANE_HYPERPLANE</b></a>]  Theorem
      
       a b c. a  0  {x | x = c} homeomorphic {x | a * x = b}
   
   [<a name="HOMEOMORPHIC_SYM-val"><b>HOMEOMORPHIC_SYM</b></a>]  Theorem
      
       s t. s homeomorphic t  t homeomorphic s
   
   [<a name="HOMEOMORPHIC_TRANS-val"><b>HOMEOMORPHIC_TRANS</b></a>]  Theorem
      
       s t u. s homeomorphic t  t homeomorphic u  s homeomorphic u
   
   [<a name="HOMEOMORPHIC_TRANSLATION-val"><b>HOMEOMORPHIC_TRANSLATION</b></a>]  Theorem
      
       s a. s homeomorphic IMAGE (x. a + x) s
   
   [<a name="HOMEOMORPHIC_TRANSLATION_LEFT_EQ-val"><b>HOMEOMORPHIC_TRANSLATION_LEFT_EQ</b></a>]  Theorem
      
       a s t. IMAGE (x. a + x) s homeomorphic t  s homeomorphic t
   
   [<a name="HOMEOMORPHIC_TRANSLATION_RIGHT_EQ-val"><b>HOMEOMORPHIC_TRANSLATION_RIGHT_EQ</b></a>]  Theorem
      
       a s t. s homeomorphic IMAGE (x. a + x) t  s homeomorphic t
   
   [<a name="HOMEOMORPHIC_TRANSLATION_SELF-val"><b>HOMEOMORPHIC_TRANSLATION_SELF</b></a>]  Theorem
      
       a s. IMAGE (x. a + x) s homeomorphic s
   
   [<a name="HOMEOMORPHISM-val"><b>HOMEOMORPHISM</b></a>]  Theorem
      
       s t f g.
          homeomorphism (s,t) (f,g) 
          f continuous_on s  IMAGE f s  t  g continuous_on t 
          IMAGE g t  s  (x. x  s  g (f x) = x) 
          y. y  t  f (g y) = y
   
   [<a name="HOMEOMORPHISM_COMPACT-val"><b>HOMEOMORPHISM_COMPACT</b></a>]  Theorem
      
       s f t.
          compact s  f continuous_on s  IMAGE f s = t 
          (x y. x  s  y  s  f x = f y  x = y) 
          g. homeomorphism (s,t) (f,g)
   
   [<a name="HOMEOMORPHISM_COMPOSE-val"><b>HOMEOMORPHISM_COMPOSE</b></a>]  Theorem
      
       f g h k s t u.
          homeomorphism (s,t) (f,g)  homeomorphism (t,u) (h,k) 
          homeomorphism (s,u) (h  f,g  k)
   
   [<a name="HOMEOMORPHISM_FROM_COMPOSITION_INJECTIVE-val"><b>HOMEOMORPHISM_FROM_COMPOSITION_INJECTIVE</b></a>]  Theorem
      
       f g s t u.
          f continuous_on s  IMAGE f s  t  g continuous_on t 
          IMAGE g t  u  (x y. x  t  y  t  g x = g y  x = y) 
          (h. homeomorphism (s,u) (g  f,h)) 
          (f'. homeomorphism (s,t) (f,f')) 
          g'. homeomorphism (t,u) (g,g')
   
   [<a name="HOMEOMORPHISM_FROM_COMPOSITION_SURJECTIVE-val"><b>HOMEOMORPHISM_FROM_COMPOSITION_SURJECTIVE</b></a>]  Theorem
      
       f g s t u.
          f continuous_on s  IMAGE f s = t  g continuous_on t 
          IMAGE g t  u  (h. homeomorphism (s,u) (g  f,h)) 
          (f'. homeomorphism (s,t) (f,f')) 
          g'. homeomorphism (t,u) (g,g')
   
   [<a name="HOMEOMORPHISM_ID-val"><b>HOMEOMORPHISM_ID</b></a>]  Theorem
      
       s. homeomorphism (s,s) ((x. x),(x. x))
   
   [<a name="HOMEOMORPHISM_IMP_CLOSED_MAP-val"><b>HOMEOMORPHISM_IMP_CLOSED_MAP</b></a>]  Theorem
      
       f g s t u.
          homeomorphism (s,t) (f,g)  closed_in (subtopology euclidean s) u 
          closed_in (subtopology euclidean t) (IMAGE f u)
   
   [<a name="HOMEOMORPHISM_IMP_OPEN_MAP-val"><b>HOMEOMORPHISM_IMP_OPEN_MAP</b></a>]  Theorem
      
       f g s t u.
          homeomorphism (s,t) (f,g)  open_in (subtopology euclidean s) u 
          open_in (subtopology euclidean t) (IMAGE f u)
   
   [<a name="HOMEOMORPHISM_IMP_QUOTIENT_MAP-val"><b>HOMEOMORPHISM_IMP_QUOTIENT_MAP</b></a>]  Theorem
      
       f g s t.
          homeomorphism (s,t) (f,g) 
          u. u  t 
              (open_in (subtopology euclidean s) {x | x  s  f x  u} 
               open_in (subtopology euclidean t) u)
   
   [<a name="HOMEOMORPHISM_INJECTIVE_CLOSED_MAP-val"><b>HOMEOMORPHISM_INJECTIVE_CLOSED_MAP</b></a>]  Theorem
      
       f s t.
          f continuous_on s  IMAGE f s = t 
          (x y. x  s  y  s  f x = f y  x = y) 
          (u. closed_in (subtopology euclidean s) u 
               closed_in (subtopology euclidean t) (IMAGE f u)) 
          g. homeomorphism (s,t) (f,g)
   
   [<a name="HOMEOMORPHISM_INJECTIVE_CLOSED_MAP_EQ-val"><b>HOMEOMORPHISM_INJECTIVE_CLOSED_MAP_EQ</b></a>]  Theorem
      
       f s t.
          f continuous_on s  IMAGE f s = t 
          (x y. x  s  y  s  f x = f y  x = y) 
          ((g. homeomorphism (s,t) (f,g)) 
           u. closed_in (subtopology euclidean s) u 
               closed_in (subtopology euclidean t) (IMAGE f u))
   
   [<a name="HOMEOMORPHISM_INJECTIVE_OPEN_MAP-val"><b>HOMEOMORPHISM_INJECTIVE_OPEN_MAP</b></a>]  Theorem
      
       f s t.
          f continuous_on s  IMAGE f s = t 
          (x y. x  s  y  s  f x = f y  x = y) 
          (u. open_in (subtopology euclidean s) u 
               open_in (subtopology euclidean t) (IMAGE f u)) 
          g. homeomorphism (s,t) (f,g)
   
   [<a name="HOMEOMORPHISM_INJECTIVE_OPEN_MAP_EQ-val"><b>HOMEOMORPHISM_INJECTIVE_OPEN_MAP_EQ</b></a>]  Theorem
      
       f s t.
          f continuous_on s  IMAGE f s = t 
          (x y. x  s  y  s  f x = f y  x = y) 
          ((g. homeomorphism (s,t) (f,g)) 
           u. open_in (subtopology euclidean s) u 
               open_in (subtopology euclidean t) (IMAGE f u))
   
   [<a name="HOMEOMORPHISM_LOCALLY-val"><b>HOMEOMORPHISM_LOCALLY</b></a>]  Theorem
      
       P Q f g.
          (s t. homeomorphism (s,t) (f,g)  (P s  Q t)) 
          s t. homeomorphism (s,t) (f,g)  (locally P s  locally Q t)
   
   [<a name="HOMEOMORPHISM_OF_SUBSETS-val"><b>HOMEOMORPHISM_OF_SUBSETS</b></a>]  Theorem
      
       f g s t s' t'.
          homeomorphism (s,t) (f,g)  s'  s  t'  t  IMAGE f s' = t' 
          homeomorphism (s',t') (f,g)
   
   [<a name="HOMEOMORPHISM_SYM-val"><b>HOMEOMORPHISM_SYM</b></a>]  Theorem
      
       f g s t. homeomorphism (s,t) (f,g)  homeomorphism (t,s) (g,f)
   
   [<a name="IMAGE_AFFINITY_INTERVAL-val"><b>IMAGE_AFFINITY_INTERVAL</b></a>]  Theorem
      
       a b m c.
          IMAGE (x. m * x + c) (interval [(a,b)]) =
          if interval [(a,b)] =  then 
          else if 0  m then interval [(m * a + c,m * b + c)]
          else interval [(m * b + c,m * a + c)]
   
   [<a name="IMAGE_CLOSURE_SUBSET-val"><b>IMAGE_CLOSURE_SUBSET</b></a>]  Theorem
      
       f s t.
          f continuous_on closure s  closed t  IMAGE f s  t 
          IMAGE f (closure s)  t
   
   [<a name="IMAGE_STRETCH_INTERVAL-val"><b>IMAGE_STRETCH_INTERVAL</b></a>]  Theorem
      
       a b m.
          IMAGE (x. @f. f = m 1 * x) (interval [(a,b)]) =
          if interval [(a,b)] =  then 
          else
            interval
              [((@f. f = min (m 1 * a) (m 1 * b)),
                @f. f = max (m 1 * a) (m 1 * b))]
   
   [<a name="IMAGE_TWIZZLE_INTERVAL-val"><b>IMAGE_TWIZZLE_INTERVAL</b></a>]  Theorem
      
       p a b. IMAGE (x. x) (interval [(a,b)]) = interval [(a,b)]
   
   [<a name="INDEPENDENT_BOUND-val"><b>INDEPENDENT_BOUND</b></a>]  Theorem
      
       s. independent s  FINITE s  CARD s  1
   
   [<a name="INDEPENDENT_CARD_LE_DIM-val"><b>INDEPENDENT_CARD_LE_DIM</b></a>]  Theorem
      
       v b. b  v  independent b  FINITE b  CARD b  dim v
   
   [<a name="INDEPENDENT_EMPTY-val"><b>INDEPENDENT_EMPTY</b></a>]  Theorem
      
       independent 
   
   [<a name="INDEPENDENT_INJECTIVE_IMAGE-val"><b>INDEPENDENT_INJECTIVE_IMAGE</b></a>]  Theorem
      
       f s.
          independent s  linear f  (x y. f x = f y  x = y) 
          independent (IMAGE f s)
   
   [<a name="INDEPENDENT_INJECTIVE_IMAGE_GEN-val"><b>INDEPENDENT_INJECTIVE_IMAGE_GEN</b></a>]  Theorem
      
       f s.
          independent s  linear f 
          (x y. x  span s  y  span s  f x = f y  x = y) 
          independent (IMAGE f s)
   
   [<a name="INDEPENDENT_INSERT-val"><b>INDEPENDENT_INSERT</b></a>]  Theorem
      
       a s.
          independent (a INSERT s) 
          if a  s then independent s else independent s  a  span s
   
   [<a name="INDEPENDENT_MONO-val"><b>INDEPENDENT_MONO</b></a>]  Theorem
      
       s t. independent t  s  t  independent s
   
   [<a name="INDEPENDENT_NONZERO-val"><b>INDEPENDENT_NONZERO</b></a>]  Theorem
      
       s. independent s  0  s
   
   [<a name="INDEPENDENT_SING-val"><b>INDEPENDENT_SING</b></a>]  Theorem
      
       x. independent {x}  x  0
   
   [<a name="INDEPENDENT_SPAN_BOUND-val"><b>INDEPENDENT_SPAN_BOUND</b></a>]  Theorem
      
       s t.
          FINITE t  independent s  s  span t 
          FINITE s  CARD s  CARD t
   
   [<a name="INDEPENDENT_STDBASIS-val"><b>INDEPENDENT_STDBASIS</b></a>]  Theorem
      
       independent {i | 1  i  i  1}
   
   [<a name="INFINITE_OPEN_IN-val"><b>INFINITE_OPEN_IN</b></a>]  Theorem
      
       u s.
          open_in (subtopology euclidean u) s 
          (x. x  s  x limit_point_of u) 
          INFINITE s
   
   [<a name="INFINITE_SUPERSET-val"><b>INFINITE_SUPERSET</b></a>]  Theorem
      
       s t. INFINITE s  s  t  INFINITE t
   
   [<a name="INFSUM_0-val"><b>INFSUM_0</b></a>]  Theorem
      
       suminf s (i. 0) = 0
   
   [<a name="INFSUM_ADD-val"><b>INFSUM_ADD</b></a>]  Theorem
      
       x y s.
          summable s x  summable s y 
          suminf s (i. x i + y i) = suminf s x + suminf s y
   
   [<a name="INFSUM_CMUL-val"><b>INFSUM_CMUL</b></a>]  Theorem
      
       s x c. summable s x  suminf s (n. c * x n) = c * suminf s x
   
   [<a name="INFSUM_EQ-val"><b>INFSUM_EQ</b></a>]  Theorem
      
       f g k.
          summable k f  summable k g  (x. x  k  f x = g x) 
          suminf k f = suminf k g
   
   [<a name="INFSUM_LINEAR-val"><b>INFSUM_LINEAR</b></a>]  Theorem
      
       f h s.
          summable s f  linear h  suminf s (n. h (f n)) = h (suminf s f)
   
   [<a name="INFSUM_NEG-val"><b>INFSUM_NEG</b></a>]  Theorem
      
       s x. summable s x  suminf s (n. -x n) = -suminf s x
   
   [<a name="INFSUM_RESTRICT-val"><b>INFSUM_RESTRICT</b></a>]  Theorem
      
       k a. suminf (:num) (n. if n  k then a n else 0) = suminf k a
   
   [<a name="INFSUM_SUB-val"><b>INFSUM_SUB</b></a>]  Theorem
      
       x y s.
          summable s x  summable s y 
          suminf s (i. x i  y i) = suminf s x  suminf s y
   
   [<a name="INFSUM_UNIQUE-val"><b>INFSUM_UNIQUE</b></a>]  Theorem
      
       f l s. (f sums l) s  suminf s f = l
   
   [<a name="INF_INSERT-val"><b>INF_INSERT</b></a>]  Theorem
      
       x s.
          bounded s  inf (x INSERT s) = if s =  then x else min x (inf s)
   
   [<a name="INJECTIVE_IMP_ISOMETRIC-val"><b>INJECTIVE_IMP_ISOMETRIC</b></a>]  Theorem
      
       f s.
          closed s  subspace s  linear f  (x. x  s  f x = 0  x = 0) 
          e. 0 &lt; e  x. x  s  abs (f x)  e * abs x
   
   [<a name="INJECTIVE_MAP_OPEN_IFF_CLOSED-val"><b>INJECTIVE_MAP_OPEN_IFF_CLOSED</b></a>]  Theorem
      
       f s t.
          f continuous_on s  IMAGE f s = t 
          (x y. x  s  y  s  f x = f y  x = y) 
          ((u. open_in (subtopology euclidean s) u 
                open_in (subtopology euclidean t) (IMAGE f u)) 
           u. closed_in (subtopology euclidean s) u 
               closed_in (subtopology euclidean t) (IMAGE f u))
   
   [<a name="INTERIOR_BALL-val"><b>INTERIOR_BALL</b></a>]  Theorem
      
       a r. interior (ball (a,r)) = ball (a,r)
   
   [<a name="INTERIOR_BIGINTER_SUBSET-val"><b>INTERIOR_BIGINTER_SUBSET</b></a>]  Theorem
      
       f. interior (BIGINTER f)  BIGINTER (IMAGE interior f)
   
   [<a name="INTERIOR_BIJECTIVE_LINEAR_IMAGE-val"><b>INTERIOR_BIJECTIVE_LINEAR_IMAGE</b></a>]  Theorem
      
       f s.
          linear f  (x y. f x = f y  x = y)  (y. x. f x = y) 
          interior (IMAGE f s) = IMAGE f (interior s)
   
   [<a name="INTERIOR_CBALL-val"><b>INTERIOR_CBALL</b></a>]  Theorem
      
       x e. interior (cball (x,e)) = ball (x,e)
   
   [<a name="INTERIOR_CLOSED_EQ_EMPTY_AS_FRONTIER-val"><b>INTERIOR_CLOSED_EQ_EMPTY_AS_FRONTIER</b></a>]  Theorem
      
       s. closed s  interior s =   t. open t  s = frontier t
   
   [<a name="INTERIOR_CLOSED_INTERVAL-val"><b>INTERIOR_CLOSED_INTERVAL</b></a>]  Theorem
      
       a b. interior (interval [(a,b)]) = interval (a,b)
   
   [<a name="INTERIOR_CLOSED_UNION_EMPTY_INTERIOR-val"><b>INTERIOR_CLOSED_UNION_EMPTY_INTERIOR</b></a>]  Theorem
      
       s t. closed s  interior t =   interior (s  t) = interior s
   
   [<a name="INTERIOR_CLOSURE-val"><b>INTERIOR_CLOSURE</b></a>]  Theorem
      
       s. interior s = (:real) DIFF closure ((:real) DIFF s)
   
   [<a name="INTERIOR_CLOSURE_IDEMP-val"><b>INTERIOR_CLOSURE_IDEMP</b></a>]  Theorem
      
       s. interior (closure (interior (closure s))) =
            interior (closure s)
   
   [<a name="INTERIOR_CLOSURE_INTER_OPEN-val"><b>INTERIOR_CLOSURE_INTER_OPEN</b></a>]  Theorem
      
       s t.
          open s  open t 
          interior (closure (s  t)) =
          interior (closure s)  interior (closure t)
   
   [<a name="INTERIOR_COMPLEMENT-val"><b>INTERIOR_COMPLEMENT</b></a>]  Theorem
      
       s. interior ((:real) DIFF s) = (:real) DIFF closure s
   
   [<a name="INTERIOR_DIFF-val"><b>INTERIOR_DIFF</b></a>]  Theorem
      
       s t. interior (s DIFF t) = interior s DIFF closure t
   
   [<a name="INTERIOR_EMPTY-val"><b>INTERIOR_EMPTY</b></a>]  Theorem
      
       interior  = 
   
   [<a name="INTERIOR_EQ-val"><b>INTERIOR_EQ</b></a>]  Theorem
      
       s. interior s = s  open s
   
   [<a name="INTERIOR_EQ_EMPTY-val"><b>INTERIOR_EQ_EMPTY</b></a>]  Theorem
      
       s. interior s =   t. open t  t  s  t = 
   
   [<a name="INTERIOR_EQ_EMPTY_ALT-val"><b>INTERIOR_EQ_EMPTY_ALT</b></a>]  Theorem
      
       s. interior s =   t. open t  t    t DIFF s  
   
   [<a name="INTERIOR_FINITE_BIGINTER-val"><b>INTERIOR_FINITE_BIGINTER</b></a>]  Theorem
      
       s. FINITE s  interior (BIGINTER s) = BIGINTER (IMAGE interior s)
   
   [<a name="INTERIOR_FRONTIER-val"><b>INTERIOR_FRONTIER</b></a>]  Theorem
      
       s. interior (frontier s) =
            interior (closure s) DIFF closure (interior s)
   
   [<a name="INTERIOR_FRONTIER_EMPTY-val"><b>INTERIOR_FRONTIER_EMPTY</b></a>]  Theorem
      
       s. open s  closed s  interior (frontier s) = 
   
   [<a name="INTERIOR_HALFSPACE_COMPONENT_GE-val"><b>INTERIOR_HALFSPACE_COMPONENT_GE</b></a>]  Theorem
      
       a. interior {x | x  a} = {x | x &gt; a}
   
   [<a name="INTERIOR_HALFSPACE_COMPONENT_LE-val"><b>INTERIOR_HALFSPACE_COMPONENT_LE</b></a>]  Theorem
      
       a. interior {x | x  a} = {x | x &lt; a}
   
   [<a name="INTERIOR_HALFSPACE_GE-val"><b>INTERIOR_HALFSPACE_GE</b></a>]  Theorem
      
       a b. a  0  interior {x | a * x  b} = {x | a * x &gt; b}
   
   [<a name="INTERIOR_HALFSPACE_LE-val"><b>INTERIOR_HALFSPACE_LE</b></a>]  Theorem
      
       a b. a  0  interior {x | a * x  b} = {x | a * x &lt; b}
   
   [<a name="INTERIOR_HYPERPLANE-val"><b>INTERIOR_HYPERPLANE</b></a>]  Theorem
      
       a b. a  0  interior {x | a * x = b} = 
   
   [<a name="INTERIOR_IMAGE_SUBSET-val"><b>INTERIOR_IMAGE_SUBSET</b></a>]  Theorem
      
       f s.
          (x. f continuous at x)  (x y. f x = f y  x = y) 
          interior (IMAGE f s)  IMAGE f (interior s)
   
   [<a name="INTERIOR_INJECTIVE_LINEAR_IMAGE-val"><b>INTERIOR_INJECTIVE_LINEAR_IMAGE</b></a>]  Theorem
      
       f s.
          linear f  (x y. f x = f y  x = y) 
          interior (IMAGE f s) = IMAGE f (interior s)
   
   [<a name="INTERIOR_INTER-val"><b>INTERIOR_INTER</b></a>]  Theorem
      
       s t. interior (s  t) = interior s  interior t
   
   [<a name="INTERIOR_INTERIOR-val"><b>INTERIOR_INTERIOR</b></a>]  Theorem
      
       s. interior (interior s) = interior s
   
   [<a name="INTERIOR_INTERVAL-val"><b>INTERIOR_INTERVAL</b></a>]  Theorem
      
       (a b. interior (interval [(a,b)]) = interval (a,b)) 
        a b. interior (interval (a,b)) = interval (a,b)
   
   [<a name="INTERIOR_LIMIT_POINT-val"><b>INTERIOR_LIMIT_POINT</b></a>]  Theorem
      
       s x. x  interior s  x limit_point_of s
   
   [<a name="INTERIOR_MAXIMAL-val"><b>INTERIOR_MAXIMAL</b></a>]  Theorem
      
       s t. t  s  open t  t  interior s
   
   [<a name="INTERIOR_MAXIMAL_EQ-val"><b>INTERIOR_MAXIMAL_EQ</b></a>]  Theorem
      
       s t. open s  (s  interior t  s  t)
   
   [<a name="INTERIOR_NEGATIONS-val"><b>INTERIOR_NEGATIONS</b></a>]  Theorem
      
       s. interior (IMAGE (x. -x) s) = IMAGE (x. -x) (interior s)
   
   [<a name="INTERIOR_OPEN-val"><b>INTERIOR_OPEN</b></a>]  Theorem
      
       s. open s  interior s = s
   
   [<a name="INTERIOR_SING-val"><b>INTERIOR_SING</b></a>]  Theorem
      
       a. interior {a} = 
   
   [<a name="INTERIOR_STANDARD_HYPERPLANE-val"><b>INTERIOR_STANDARD_HYPERPLANE</b></a>]  Theorem
      
       a. interior {x | x = a} = 
   
   [<a name="INTERIOR_SUBSET-val"><b>INTERIOR_SUBSET</b></a>]  Theorem
      
       s. interior s  s
   
   [<a name="INTERIOR_TRANSLATION-val"><b>INTERIOR_TRANSLATION</b></a>]  Theorem
      
       a s.
          interior (IMAGE (x. a + x) s) = IMAGE (x. a + x) (interior s)
   
   [<a name="INTERIOR_UNIONS_OPEN_SUBSETS-val"><b>INTERIOR_UNIONS_OPEN_SUBSETS</b></a>]  Theorem
      
       s. BIGUNION {t | open t  t  s} = interior s
   
   [<a name="INTERIOR_UNION_EQ_EMPTY-val"><b>INTERIOR_UNION_EQ_EMPTY</b></a>]  Theorem
      
       s t.
          closed s  closed t 
          (interior (s  t) =   interior s =   interior t = )
   
   [<a name="INTERIOR_UNIQUE-val"><b>INTERIOR_UNIQUE</b></a>]  Theorem
      
       s t.
          t  s  open t  (t'. t'  s  open t'  t'  t) 
          interior s = t
   
   [<a name="INTERIOR_UNIV-val"><b>INTERIOR_UNIV</b></a>]  Theorem
      
       interior (:real) = (:real)
   
   [<a name="INTERVAL-val"><b>INTERVAL</b></a>]  Theorem
      
       (a b.
           interval [(a,b)] =
           if a  b then cball (midpoint (a,b),dist (a,b) / 2) else ) 
        a b.
          interval (a,b) =
          if a &lt; b then ball (midpoint (a,b),dist (a,b) / 2) else 
   
   [<a name="INTERVAL_BOUNDS_EMPTY-val"><b>INTERVAL_BOUNDS_EMPTY</b></a>]  Theorem
      
       interval_upperbound  = 0  interval_lowerbound  = 0
   
   [<a name="INTERVAL_BOUNDS_NULL-val"><b>INTERVAL_BOUNDS_NULL</b></a>]  Theorem
      
       a b.
          content (interval [(a,b)]) = 0 
          interval_upperbound (interval [(a,b)]) =
          interval_lowerbound (interval [(a,b)])
   
   [<a name="INTERVAL_CASES-val"><b>INTERVAL_CASES</b></a>]  Theorem
      
       x. x  interval [(a,b)]  x  interval (a,b)  x = a  x = b
   
   [<a name="INTERVAL_CONTAINS_COMPACT_NEIGHBOURHOOD-val"><b>INTERVAL_CONTAINS_COMPACT_NEIGHBOURHOOD</b></a>]  Theorem
      
       s x.
          is_interval s  x  s 
          a b d.
            0 &lt; d  x  interval [(a,b)]  interval [(a,b)]  s 
            ball (x,d)  s  interval [(a,b)]
   
   [<a name="INTERVAL_EQ_EMPTY-val"><b>INTERVAL_EQ_EMPTY</b></a>]  Theorem
      
       a b. (b &lt; a  interval [(a,b)] = )  (b  a  interval (a,b) = )
   
   [<a name="INTERVAL_IMAGE_STRETCH_INTERVAL-val"><b>INTERVAL_IMAGE_STRETCH_INTERVAL</b></a>]  Theorem
      
       a b m. u v.
          IMAGE (x. @f. f = m 1 * x) (interval [(a,b)]) = interval [(u,v)]
   
   [<a name="INTERVAL_LOWERBOUND-val"><b>INTERVAL_LOWERBOUND</b></a>]  Theorem
      
       a b. a  b  interval_lowerbound (interval [(a,b)]) = a
   
   [<a name="INTERVAL_LOWERBOUND_NONEMPTY-val"><b>INTERVAL_LOWERBOUND_NONEMPTY</b></a>]  Theorem
      
       a b.
          interval [(a,b)]    interval_lowerbound (interval [(a,b)]) = a
   
   [<a name="INTERVAL_NE_EMPTY-val"><b>INTERVAL_NE_EMPTY</b></a>]  Theorem
      
       (interval [(a,b)]    a  b)  (interval (a,b)    a &lt; b)
   
   [<a name="INTERVAL_OPEN_SUBSET_CLOSED-val"><b>INTERVAL_OPEN_SUBSET_CLOSED</b></a>]  Theorem
      
       a b. interval (a,b)  interval [(a,b)]
   
   [<a name="INTERVAL_SING-val"><b>INTERVAL_SING</b></a>]  Theorem
      
       interval [(a,a)] = {a}  interval (a,a) = 
   
   [<a name="INTERVAL_SUBSET_IS_INTERVAL-val"><b>INTERVAL_SUBSET_IS_INTERVAL</b></a>]  Theorem
      
       s a b.
          is_interval s 
          (interval [(a,b)]  s  interval [(a,b)] =   a  s  b  s)
   
   [<a name="INTERVAL_TRANSLATION-val"><b>INTERVAL_TRANSLATION</b></a>]  Theorem
      
       (c a b.
           interval [(c + a,c + b)] = IMAGE (x. c + x) (interval [(a,b)])) 
        c a b. interval (c + a,c + b) = IMAGE (x. c + x) (interval (a,b))
   
   [<a name="INTERVAL_UPPERBOUND-val"><b>INTERVAL_UPPERBOUND</b></a>]  Theorem
      
       a b. a  b  interval_upperbound (interval [(a,b)]) = b
   
   [<a name="INTERVAL_UPPERBOUND_NONEMPTY-val"><b>INTERVAL_UPPERBOUND_NONEMPTY</b></a>]  Theorem
      
       a b.
          interval [(a,b)]    interval_upperbound (interval [(a,b)]) = b
   
   [<a name="INTER_BALLS_EQ_EMPTY-val"><b>INTER_BALLS_EQ_EMPTY</b></a>]  Theorem
      
       (a b r s.
           ball (a,r)  ball (b,s) =   r  0  s  0  r + s  dist (a,b)) 
        (a b r s.
           ball (a,r)  cball (b,s) =  
           r  0  s &lt; 0  r + s  dist (a,b)) 
        (a b r s.
           cball (a,r)  ball (b,s) =  
           r &lt; 0  s  0  r + s  dist (a,b)) 
        a b r s.
          cball (a,r)  cball (b,s) =  
          r &lt; 0  s &lt; 0  r + s &lt; dist (a,b)
   
   [<a name="INTER_INTERVAL-val"><b>INTER_INTERVAL</b></a>]  Theorem
      
       interval [(a,b)]  interval [(c,d)] = interval [(max a c,min b d)]
   
   [<a name="INTER_INTERVAL_MIXED_EQ_EMPTY-val"><b>INTER_INTERVAL_MIXED_EQ_EMPTY</b></a>]  Theorem
      
       a b c d.
          interval (c,d)   
          (interval (a,b)  interval [(c,d)] =  
           interval (a,b)  interval (c,d) = )
   
   [<a name="IN_BALL-val"><b>IN_BALL</b></a>]  Theorem
      
       x y e. y  ball (x,e)  dist (x,y) &lt; e
   
   [<a name="IN_BALL_0-val"><b>IN_BALL_0</b></a>]  Theorem
      
       x e. x  ball (0,e)  abs x &lt; e
   
   [<a name="IN_CBALL-val"><b>IN_CBALL</b></a>]  Theorem
      
       x y e. y  cball (x,e)  dist (x,y)  e
   
   [<a name="IN_CBALL_0-val"><b>IN_CBALL_0</b></a>]  Theorem
      
       x e. x  cball (0,e)  abs x  e
   
   [<a name="IN_CLOSURE_DELETE-val"><b>IN_CLOSURE_DELETE</b></a>]  Theorem
      
       s x. x  closure (s DELETE x)  x limit_point_of s
   
   [<a name="IN_COMPONENTS-val"><b>IN_COMPONENTS</b></a>]  Theorem
      
       u s. s  components u  x. x  u  s = connected_component u x
   
   [<a name="IN_COMPONENTS_BIGUNION_COMPLEMENT-val"><b>IN_COMPONENTS_BIGUNION_COMPLEMENT</b></a>]  Theorem
      
       s c.
          c  components s  s DIFF c = BIGUNION (components s DELETE c)
   
   [<a name="IN_COMPONENTS_CONNECTED-val"><b>IN_COMPONENTS_CONNECTED</b></a>]  Theorem
      
       s c. c  components s  connected c
   
   [<a name="IN_COMPONENTS_MAXIMAL-val"><b>IN_COMPONENTS_MAXIMAL</b></a>]  Theorem
      
       s c.
          c  components s 
          c    c  s  connected c 
          c'. c'    c  c'  c'  s  connected c'  c' = c
   
   [<a name="IN_COMPONENTS_NONEMPTY-val"><b>IN_COMPONENTS_NONEMPTY</b></a>]  Theorem
      
       s c. c  components s  c  
   
   [<a name="IN_COMPONENTS_SELF-val"><b>IN_COMPONENTS_SELF</b></a>]  Theorem
      
       s. s  components s  connected s  s  
   
   [<a name="IN_COMPONENTS_SUBSET-val"><b>IN_COMPONENTS_SUBSET</b></a>]  Theorem
      
       s c. c  components s  c  s
   
   [<a name="IN_DIRECTION-val"><b>IN_DIRECTION</b></a>]  Theorem
      
       a v x y.
          netord (a in_direction v) x y 
          0 &lt; dist (x,a)  dist (x,a)  dist (y,a) 
          c. 0  c  x  a = c * v
   
   [<a name="IN_INTERIOR-val"><b>IN_INTERIOR</b></a>]  Theorem
      
       x s. x  interior s  e. 0 &lt; e  ball (x,e)  s
   
   [<a name="IN_INTERIOR_CBALL-val"><b>IN_INTERIOR_CBALL</b></a>]  Theorem
      
       x s. x  interior s  e. 0 &lt; e  cball (x,e)  s
   
   [<a name="IN_INTERIOR_LINEAR_IMAGE-val"><b>IN_INTERIOR_LINEAR_IMAGE</b></a>]  Theorem
      
       f g s x.
          linear f  linear g  f  g = I  x  interior s 
          f x  interior (IMAGE f s)
   
   [<a name="IN_INTERVAL-val"><b>IN_INTERVAL</b></a>]  Theorem
      
       (x  interval (a,b)  a &lt; x  x &lt; b) 
        (x  interval [(a,b)]  a  x  x  b)
   
   [<a name="IN_INTERVAL_REFLECT-val"><b>IN_INTERVAL_REFLECT</b></a>]  Theorem
      
       (a b x. -x  interval [(-b,-a)]  x  interval [(a,b)]) 
        a b x. -x  interval (-b,-a)  x  interval (a,b)
   
   [<a name="IN_OPEN_SEGMENT-val"><b>IN_OPEN_SEGMENT</b></a>]  Theorem
      
       a b x. x  segment (a,b)  x  segment [(a,b)]  x  a  x  b
   
   [<a name="IN_OPEN_SEGMENT_ALT-val"><b>IN_OPEN_SEGMENT_ALT</b></a>]  Theorem
      
       a b x.
          x  segment (a,b)  x  segment [(a,b)]  x  a  x  b  a  b
   
   [<a name="IN_SEGMENT-val"><b>IN_SEGMENT</b></a>]  Theorem
      
       a b x.
          (x  segment [(a,b)] 
           u. 0  u  u  1  x = (1  u) * a + u * b) 
          (x  segment (a,b) 
           a  b  u. 0 &lt; u  u &lt; 1  x = (1  u) * a + u * b)
   
   [<a name="IN_SEGMENT_COMPONENT-val"><b>IN_SEGMENT_COMPONENT</b></a>]  Theorem
      
       a b x i. x  segment [(a,b)]  min a b  x  x  max a b
   
   [<a name="IN_SPAN_DELETE-val"><b>IN_SPAN_DELETE</b></a>]  Theorem
      
       a b s.
          a  span s  a  span (s DELETE b) 
          b  span (a INSERT s DELETE b)
   
   [<a name="IN_SPAN_INSERT-val"><b>IN_SPAN_INSERT</b></a>]  Theorem
      
       a b s. a  span (b INSERT s)  a  span s  b  span (a INSERT s)
   
   [<a name="IN_SPHERE-val"><b>IN_SPHERE</b></a>]  Theorem
      
       x y e. y  sphere (x,e)  dist (x,y) = e
   
   [<a name="IN_SPHERE_0-val"><b>IN_SPHERE_0</b></a>]  Theorem
      
       x e. x  sphere (0,e)  abs x = e
   
   [<a name="ISOMETRY_IMP_EMBEDDING-val"><b>ISOMETRY_IMP_EMBEDDING</b></a>]  Theorem
      
       f s t.
          IMAGE f s = t 
          (x y. x  s  y  s  dist (f x,f y) = dist (x,y)) 
          g. homeomorphism (s,t) (f,g)
   
   [<a name="ISOMETRY_IMP_HOMEOMORPHISM_COMPACT-val"><b>ISOMETRY_IMP_HOMEOMORPHISM_COMPACT</b></a>]  Theorem
      
       f s.
          compact s  IMAGE f s  s 
          (x y. x  s  y  s  dist (f x,f y) = dist (x,y)) 
          g. homeomorphism (s,s) (f,g)
   
   [<a name="ISOMETRY_IMP_OPEN_MAP-val"><b>ISOMETRY_IMP_OPEN_MAP</b></a>]  Theorem
      
       f s t u.
          IMAGE f s = t 
          (x y. x  s  y  s  dist (f x,f y) = dist (x,y)) 
          open_in (subtopology euclidean s) u 
          open_in (subtopology euclidean t) (IMAGE f u)
   
   [<a name="ISOMETRY_ON_IMP_CONTINUOUS_ON-val"><b>ISOMETRY_ON_IMP_CONTINUOUS_ON</b></a>]  Theorem
      
       f. (x y. x  s  y  s  dist (f x,f y) = dist (x,y)) 
            f continuous_on s
   
   [<a name="IS_INTERVAL-val"><b>IS_INTERVAL</b></a>]  Theorem
      
       s. is_interval s  a b x. a  s  b  s  a  x  x  b  x  s
   
   [<a name="IS_INTERVAL_CASES-val"><b>IS_INTERVAL_CASES</b></a>]  Theorem
      
       s. is_interval s 
            s =   s = (:real)  (a. s = {x | a &lt; x}) 
            (a. s = {x | a  x})  (b. s = {x | x  b}) 
            (b. s = {x | x &lt; b})  (a b. s = {x | a &lt; x  x &lt; b}) 
            (a b. s = {x | a &lt; x  x  b}) 
            (a b. s = {x | a  x  x &lt; b})  a b. s = {x | a  x  x  b}
   
   [<a name="IS_INTERVAL_COMPACT-val"><b>IS_INTERVAL_COMPACT</b></a>]  Theorem
      
       s. is_interval s  compact s  a b. s = interval [(a,b)]
   
   [<a name="IS_INTERVAL_EMPTY-val"><b>IS_INTERVAL_EMPTY</b></a>]  Theorem
      
       is_interval 
   
   [<a name="IS_INTERVAL_IMP_LOCALLY_COMPACT-val"><b>IS_INTERVAL_IMP_LOCALLY_COMPACT</b></a>]  Theorem
      
       s. is_interval s  locally compact s
   
   [<a name="IS_INTERVAL_INTER-val"><b>IS_INTERVAL_INTER</b></a>]  Theorem
      
       s t. is_interval s  is_interval t  is_interval (s  t)
   
   [<a name="IS_INTERVAL_INTERVAL-val"><b>IS_INTERVAL_INTERVAL</b></a>]  Theorem
      
       a b. is_interval (interval (a,b))  is_interval (interval [(a,b)])
   
   [<a name="IS_INTERVAL_POINTWISE-val"><b>IS_INTERVAL_POINTWISE</b></a>]  Theorem
      
       s x. is_interval s  (a. a  s  a = x)  x  s
   
   [<a name="IS_INTERVAL_SCALING-val"><b>IS_INTERVAL_SCALING</b></a>]  Theorem
      
       s c. is_interval s  is_interval (IMAGE (x. c * x) s)
   
   [<a name="IS_INTERVAL_SCALING_EQ-val"><b>IS_INTERVAL_SCALING_EQ</b></a>]  Theorem
      
       s c. is_interval (IMAGE (x. c * x) s)  c = 0  is_interval s
   
   [<a name="IS_INTERVAL_SING-val"><b>IS_INTERVAL_SING</b></a>]  Theorem
      
       a. is_interval {a}
   
   [<a name="IS_INTERVAL_SUMS-val"><b>IS_INTERVAL_SUMS</b></a>]  Theorem
      
       s t.
          is_interval s  is_interval t 
          is_interval {x + y | x  s  y  t}
   
   [<a name="IS_INTERVAL_UNIV-val"><b>IS_INTERVAL_UNIV</b></a>]  Theorem
      
       is_interval (:real)
   
   [<a name="JOINABLE_COMPONENTS_EQ-val"><b>JOINABLE_COMPONENTS_EQ</b></a>]  Theorem
      
       s t c1 c2.
          connected t  t  s  c1  components s  c2  components s 
          c1  t    c2  t   
          c1 = c2
   
   [<a name="JOINABLE_CONNECTED_COMPONENT_EQ-val"><b>JOINABLE_CONNECTED_COMPONENT_EQ</b></a>]  Theorem
      
       s t x y.
          connected t  t  s  connected_component s x  t   
          connected_component s y  t   
          connected_component s x = connected_component s y
   
   [<a name="LEBESGUE_COVERING_LEMMA-val"><b>LEBESGUE_COVERING_LEMMA</b></a>]  Theorem
      
       s c.
          compact s  c    s  BIGUNION c  (b. b  c  open b) 
          d. 0 &lt; d  t. t  s  diameter t  d  b. b  c  t  b
   
   [<a name="LE_1-val"><b>LE_1</b></a>]  Theorem
      
       (n. n  0  0 &lt; n)  (n. n  0  1  n)  (n. 0 &lt; n  n  0) 
        (n. 0 &lt; n  1  n)  (n. 1  n  0 &lt; n)  n. 1  n  n  0
   
   [<a name="LIFT_TO_QUOTIENT_SPACE-val"><b>LIFT_TO_QUOTIENT_SPACE</b></a>]  Theorem
      
       f h s t u.
          IMAGE f s = t 
          (v. v  t 
               (open_in (subtopology euclidean s) {x | x  s  f x  v} 
                open_in (subtopology euclidean t) v))  h continuous_on s 
          IMAGE h s = u  (x y. x  s  y  s  f x = f y  h x = h y) 
          g. g continuous_on t  IMAGE g t = u  x. x  s  h x = g (f x)
   
   [<a name="LIFT_TO_QUOTIENT_SPACE_UNIQUE-val"><b>LIFT_TO_QUOTIENT_SPACE_UNIQUE</b></a>]  Theorem
      
       f g s t u.
          IMAGE f s = t  IMAGE g s = u 
          (v. v  t 
               (open_in (subtopology euclidean s) {x | x  s  f x  v} 
                open_in (subtopology euclidean t) v)) 
          (v. v  u 
               (open_in (subtopology euclidean s) {x | x  s  g x  v} 
                open_in (subtopology euclidean u) v)) 
          (x y. x  s  y  s  (f x = f y  g x = g y)) 
          t homeomorphic u
   
   [<a name="LIMIT_POINT_FINITE-val"><b>LIMIT_POINT_FINITE</b></a>]  Theorem
      
       s a. FINITE s  (a limit_point_of s)
   
   [<a name="LIMIT_POINT_UNION-val"><b>LIMIT_POINT_UNION</b></a>]  Theorem
      
       s t x.
          x limit_point_of s  t  x limit_point_of s  x limit_point_of t
   
   [<a name="LIMPT_APPROACHABLE-val"><b>LIMPT_APPROACHABLE</b></a>]  Theorem
      
       x s.
          x limit_point_of s 
          e. 0 &lt; e  x'. x'  s  x'  x  dist (x',x) &lt; e
   
   [<a name="LIMPT_APPROACHABLE_LE-val"><b>LIMPT_APPROACHABLE_LE</b></a>]  Theorem
      
       x s.
          x limit_point_of s 
          e. 0 &lt; e  x'. x'  s  x'  x  dist (x',x)  e
   
   [<a name="LIMPT_BALL-val"><b>LIMPT_BALL</b></a>]  Theorem
      
       x y e. y limit_point_of ball (x,e)  0 &lt; e  y  cball (x,e)
   
   [<a name="LIMPT_EMPTY-val"><b>LIMPT_EMPTY</b></a>]  Theorem
      
       x. (x limit_point_of )
   
   [<a name="LIMPT_INFINITE_BALL-val"><b>LIMPT_INFINITE_BALL</b></a>]  Theorem
      
       s x. x limit_point_of s  e. 0 &lt; e  INFINITE (s  ball (x,e))
   
   [<a name="LIMPT_INFINITE_CBALL-val"><b>LIMPT_INFINITE_CBALL</b></a>]  Theorem
      
       s x. x limit_point_of s  e. 0 &lt; e  INFINITE (s  cball (x,e))
   
   [<a name="LIMPT_INFINITE_OPEN-val"><b>LIMPT_INFINITE_OPEN</b></a>]  Theorem
      
       s x. x limit_point_of s  t. x  t  open t  INFINITE (s  t)
   
   [<a name="LIMPT_INFINITE_OPEN_BALL_CBALL-val"><b>LIMPT_INFINITE_OPEN_BALL_CBALL</b></a>]  Theorem
      
       (s x. x limit_point_of s  t. x  t  open t  INFINITE (s  t)) 
        (s x. x limit_point_of s  e. 0 &lt; e  INFINITE (s  ball (x,e))) 
        s x. x limit_point_of s  e. 0 &lt; e  INFINITE (s  cball (x,e))
   
   [<a name="LIMPT_INJECTIVE_LINEAR_IMAGE_EQ-val"><b>LIMPT_INJECTIVE_LINEAR_IMAGE_EQ</b></a>]  Theorem
      
       f s.
          linear f  (x y. f x = f y  x = y) 
          (f x limit_point_of IMAGE f s  x limit_point_of s)
   
   [<a name="LIMPT_INSERT-val"><b>LIMPT_INSERT</b></a>]  Theorem
      
       s x y. x limit_point_of y INSERT s  x limit_point_of s
   
   [<a name="LIMPT_OF_CLOSURE-val"><b>LIMPT_OF_CLOSURE</b></a>]  Theorem
      
       x s. x limit_point_of closure s  x limit_point_of s
   
   [<a name="LIMPT_OF_LIMPTS-val"><b>LIMPT_OF_LIMPTS</b></a>]  Theorem
      
       x s.
          x limit_point_of {y | y limit_point_of s}  x limit_point_of s
   
   [<a name="LIMPT_OF_OPEN-val"><b>LIMPT_OF_OPEN</b></a>]  Theorem
      
       s x. open s  x  s  x limit_point_of s
   
   [<a name="LIMPT_OF_OPEN_IN-val"><b>LIMPT_OF_OPEN_IN</b></a>]  Theorem
      
       s t x.
          open_in (subtopology euclidean s) t  x limit_point_of s  x  t 
          x limit_point_of t
   
   [<a name="LIMPT_OF_SEQUENCE_SUBSEQUENCE-val"><b>LIMPT_OF_SEQUENCE_SUBSEQUENCE</b></a>]  Theorem
      
       f l.
          l limit_point_of IMAGE f (:num) 
          r. (m n. m &lt; n  r m &lt; r n)  (f  r  l) sequentially
   
   [<a name="LIMPT_OF_UNIV-val"><b>LIMPT_OF_UNIV</b></a>]  Theorem
      
       x. x limit_point_of (:real)
   
   [<a name="LIMPT_SEQUENTIAL-val"><b>LIMPT_SEQUENTIAL</b></a>]  Theorem
      
       x s.
          x limit_point_of s 
          f. (n. f n  s DELETE x)  (f  x) sequentially
   
   [<a name="LIMPT_SEQUENTIAL_INJ-val"><b>LIMPT_SEQUENTIAL_INJ</b></a>]  Theorem
      
       x s.
          x limit_point_of s 
          f. (n. f n  s DELETE x)  (m n. f m = f n  m = n) 
              (f  x) sequentially
   
   [<a name="LIMPT_SING-val"><b>LIMPT_SING</b></a>]  Theorem
      
       x y. (x limit_point_of {y})
   
   [<a name="LIMPT_SUBSET-val"><b>LIMPT_SUBSET</b></a>]  Theorem
      
       x s t. x limit_point_of s  s  t  x limit_point_of t
   
   [<a name="LIMPT_UNIV-val"><b>LIMPT_UNIV</b></a>]  Theorem
      
       x. x limit_point_of (:real)
   
   [<a name="LIM_ABS-val"><b>LIM_ABS</b></a>]  Theorem
      
       net f l. (f  l) net  ((x. abs (f x))  abs l) net
   
   [<a name="LIM_ABS_LBOUND-val"><b>LIM_ABS_LBOUND</b></a>]  Theorem
      
       net f l b.
          trivial_limit net  (f  l) net 
          eventually (x. b  abs (f x)) net 
          b  abs l
   
   [<a name="LIM_ABS_UBOUND-val"><b>LIM_ABS_UBOUND</b></a>]  Theorem
      
       net f l b.
          trivial_limit net  (f  l) net 
          eventually (x. abs (f x)  b) net 
          abs l  b
   
   [<a name="LIM_ADD-val"><b>LIM_ADD</b></a>]  Theorem
      
       net f g l m.
          (f  l) net  (g  m) net  ((x. f x + g x)  (l + m)) net
   
   [<a name="LIM_AT-val"><b>LIM_AT</b></a>]  Theorem
      
       f l a.
          (f  l) (at a) 
          e. 0 &lt; e 
              d. 0 &lt; d 
                  x. 0 &lt; dist (x,a)  dist (x,a) &lt; d  dist (f x,l) &lt; e
   
   [<a name="LIM_AT_ID-val"><b>LIM_AT_ID</b></a>]  Theorem
      
       a. ((x. x)  a) (at a)
   
   [<a name="LIM_AT_INFINITY-val"><b>LIM_AT_INFINITY</b></a>]  Theorem
      
       f l.
          (f  l) at_infinity 
          e. 0 &lt; e  b. x. abs x  b  dist (f x,l) &lt; e
   
   [<a name="LIM_AT_INFINITY_POS-val"><b>LIM_AT_INFINITY_POS</b></a>]  Theorem
      
       f l.
          (f  l) at_infinity 
          e. 0 &lt; e  b. 0 &lt; b  x. abs x  b  dist (f x,l) &lt; e
   
   [<a name="LIM_AT_LE-val"><b>LIM_AT_LE</b></a>]  Theorem
      
       f l a.
          (f  l) (at a) 
          e. 0 &lt; e 
              d. 0 &lt; d 
                  x. 0 &lt; dist (x,a)  dist (x,a)  d  dist (f x,l) &lt; e
   
   [<a name="LIM_AT_NEGINFINITY-val"><b>LIM_AT_NEGINFINITY</b></a>]  Theorem
      
       f l.
          (f  l) at_neginfinity 
          e. 0 &lt; e  b. x. x  b  dist (f x,l) &lt; e
   
   [<a name="LIM_AT_POSINFINITY-val"><b>LIM_AT_POSINFINITY</b></a>]  Theorem
      
       f l.
          (f  l) at_posinfinity 
          e. 0 &lt; e  b. x. x  b  dist (f x,l) &lt; e
   
   [<a name="LIM_AT_WITHIN-val"><b>LIM_AT_WITHIN</b></a>]  Theorem
      
       f l a s. (f  l) (at a)  (f  l) (at a within s)
   
   [<a name="LIM_AT_ZERO-val"><b>LIM_AT_ZERO</b></a>]  Theorem
      
       f l a. (f  l) (at a)  ((x. f (a + x))  l) (at 0)
   
   [<a name="LIM_BILINEAR-val"><b>LIM_BILINEAR</b></a>]  Theorem
      
       net h f g l m.
          (f  l) net  (g  m) net  bilinear h 
          ((x. h (f x) (g x))  h l m) net
   
   [<a name="LIM_CASES_COFINITE_SEQUENTIALLY-val"><b>LIM_CASES_COFINITE_SEQUENTIALLY</b></a>]  Theorem
      
       f g l.
          FINITE {n | (P n)} 
          (((n. if P n then f n else g n)  l) sequentially 
           (f  l) sequentially)
   
   [<a name="LIM_CASES_FINITE_SEQUENTIALLY-val"><b>LIM_CASES_FINITE_SEQUENTIALLY</b></a>]  Theorem
      
       f g l.
          FINITE {n | P n} 
          (((n. if P n then f n else g n)  l) sequentially 
           (g  l) sequentially)
   
   [<a name="LIM_CASES_SEQUENTIALLY-val"><b>LIM_CASES_SEQUENTIALLY</b></a>]  Theorem
      
       f g l m.
          (((n. if m  n then f n else g n)  l) sequentially 
           (f  l) sequentially) 
          (((n. if m &lt; n then f n else g n)  l) sequentially 
           (f  l) sequentially) 
          (((n. if n  m then f n else g n)  l) sequentially 
           (g  l) sequentially) 
          (((n. if n &lt; m then f n else g n)  l) sequentially 
           (g  l) sequentially)
   
   [<a name="LIM_CMUL-val"><b>LIM_CMUL</b></a>]  Theorem
      
       f l c. (f  l) net  ((x. c * f x)  (c * l)) net
   
   [<a name="LIM_CMUL_EQ-val"><b>LIM_CMUL_EQ</b></a>]  Theorem
      
       net f l c. c  0  (((x. c * f x)  (c * l)) net  (f  l) net)
   
   [<a name="LIM_COMPONENT-val"><b>LIM_COMPONENT</b></a>]  Theorem
      
       net f i l. (f  l) net  ((a. f a)  l) net
   
   [<a name="LIM_COMPONENT_EQ-val"><b>LIM_COMPONENT_EQ</b></a>]  Theorem
      
       net f i l b.
          (f  l) net  trivial_limit net  eventually (x. f x = b) net 
          l = b
   
   [<a name="LIM_COMPONENT_LBOUND-val"><b>LIM_COMPONENT_LBOUND</b></a>]  Theorem
      
       net f l b.
          trivial_limit net  (f  l) net  eventually (x. b  f x) net 
          b  l
   
   [<a name="LIM_COMPONENT_LE-val"><b>LIM_COMPONENT_LE</b></a>]  Theorem
      
       net f g l m.
          trivial_limit net  (f  l) net  (g  m) net 
          eventually (x. f x  g x) net 
          l  m
   
   [<a name="LIM_COMPONENT_UBOUND-val"><b>LIM_COMPONENT_UBOUND</b></a>]  Theorem
      
       net f l b k.
          trivial_limit net  (f  l) net  eventually (x. f x  b) net 
          l  b
   
   [<a name="LIM_COMPOSE_AT-val"><b>LIM_COMPOSE_AT</b></a>]  Theorem
      
       net f g y z.
          (f  y) net  eventually (w. f w = y  g y = z) net 
          (g  z) (at y) 
          (g  f  z) net
   
   [<a name="LIM_COMPOSE_WITHIN-val"><b>LIM_COMPOSE_WITHIN</b></a>]  Theorem
      
       net f g s y z.
          (f  y) net 
          eventually (w. f w  s  (f w = y  g y = z)) net 
          (g  z) (at y within s) 
          (g  f  z) net
   
   [<a name="LIM_CONG_AT-val"><b>LIM_CONG_AT</b></a>]  Theorem
      
       (x. x  a  f x = g x)  (((x. f x)  l) (at a)  (g  l) (at a))
   
   [<a name="LIM_CONG_WITHIN-val"><b>LIM_CONG_WITHIN</b></a>]  Theorem
      
       (x. x  a  f x = g x) 
        (((x. f x)  l) (at a within s)  (g  l) (at a within s))
   
   [<a name="LIM_CONST-val"><b>LIM_CONST</b></a>]  Theorem
      
       net a. ((x. a)  a) net
   
   [<a name="LIM_CONST_EQ-val"><b>LIM_CONST_EQ</b></a>]  Theorem
      
       net c d. ((x. c)  d) net  trivial_limit net  c = d
   
   [<a name="LIM_CONTINUOUS_FUNCTION-val"><b>LIM_CONTINUOUS_FUNCTION</b></a>]  Theorem
      
       f net g l.
          f continuous at l  (g  l) net  ((x. f (g x))  f l) net
   
   [<a name="LIM_DEF-val"><b>LIM_DEF</b></a>]  Theorem
      
       f l net.
          (f  l) net 
          trivial_limit net 
          e. 0 &lt; e 
              y. (x. netord net x y) 
                  x. netord net x y  dist (f x,l) &lt; e
   
   [<a name="LIM_DROP_LBOUND-val"><b>LIM_DROP_LBOUND</b></a>]  Theorem
      
       net f l b.
          (f  l) net  trivial_limit net  eventually (x. b  f x) net 
          b  l
   
   [<a name="LIM_DROP_LE-val"><b>LIM_DROP_LE</b></a>]  Theorem
      
       net f g l m.
          trivial_limit net  (f  l) net  (g  m) net 
          eventually (x. f x  g x) net 
          l  m
   
   [<a name="LIM_DROP_UBOUND-val"><b>LIM_DROP_UBOUND</b></a>]  Theorem
      
       net f l b.
          (f  l) net  trivial_limit net  eventually (x. f x  b) net 
          l  b
   
   [<a name="LIM_EVENTUALLY-val"><b>LIM_EVENTUALLY</b></a>]  Theorem
      
       net f l. eventually (x. f x = l) net  (f  l) net
   
   [<a name="LIM_INFINITY_POSINFINITY-val"><b>LIM_INFINITY_POSINFINITY</b></a>]  Theorem
      
       f l. (f  l) at_infinity  (f  l) at_posinfinity
   
   [<a name="LIM_INV-val"><b>LIM_INV</b></a>]  Theorem
      
       net f l. (f  l) net  l  0  (realinv  f  l) net
   
   [<a name="LIM_IN_CLOSED_SET-val"><b>LIM_IN_CLOSED_SET</b></a>]  Theorem
      
       net f s l.
          closed s  eventually (x. f x  s) net  trivial_limit net 
          (f  l) net 
          l  s
   
   [<a name="LIM_LIFT_DOT-val"><b>LIM_LIFT_DOT</b></a>]  Theorem
      
       f a. (f  l) net  ((y. a * f y)  (a * l)) net
   
   [<a name="LIM_LINEAR-val"><b>LIM_LINEAR</b></a>]  Theorem
      
       net h f l. (f  l) net  linear h  ((x. h (f x))  h l) net
   
   [<a name="LIM_MAX-val"><b>LIM_MAX</b></a>]  Theorem
      
       net f g l m.
          (f  l) net  (g  m) net  ((x. max (f x) (g x))  max l m) net
   
   [<a name="LIM_MIN-val"><b>LIM_MIN</b></a>]  Theorem
      
       net f g l m.
          (f  l) net  (g  m) net  ((x. min (f x) (g x))  min l m) net
   
   [<a name="LIM_MUL-val"><b>LIM_MUL</b></a>]  Theorem
      
       net f l c d.
          (c  d) net  (f  l) net  ((x. c x * f x)  (d * l)) net
   
   [<a name="LIM_NEG-val"><b>LIM_NEG</b></a>]  Theorem
      
       net f l. (f  l) net  ((x. -f x)  -l) net
   
   [<a name="LIM_NEG_EQ-val"><b>LIM_NEG_EQ</b></a>]  Theorem
      
       net f l. ((x. -f x)  -l) net  (f  l) net
   
   [<a name="LIM_NULL-val"><b>LIM_NULL</b></a>]  Theorem
      
       net f l. (f  l) net  ((x. f x  l)  0) net
   
   [<a name="LIM_NULL_ABS-val"><b>LIM_NULL_ABS</b></a>]  Theorem
      
       net f. (f  0) net  ((x. abs (f x))  0) net
   
   [<a name="LIM_NULL_ADD-val"><b>LIM_NULL_ADD</b></a>]  Theorem
      
       net f g. (f  0) net  (g  0) net  ((x. f x + g x)  0) net
   
   [<a name="LIM_NULL_CMUL-val"><b>LIM_NULL_CMUL</b></a>]  Theorem
      
       net f c. (f  0) net  ((x. c * f x)  0) net
   
   [<a name="LIM_NULL_CMUL_BOUNDED-val"><b>LIM_NULL_CMUL_BOUNDED</b></a>]  Theorem
      
       f g B.
          eventually (a. g a = 0  abs (f a)  B) net  (g  0) net 
          ((n. f n * g n)  0) net
   
   [<a name="LIM_NULL_CMUL_EQ-val"><b>LIM_NULL_CMUL_EQ</b></a>]  Theorem
      
       net f c. c  0  (((x. c * f x)  0) net  (f  0) net)
   
   [<a name="LIM_NULL_COMPARISON-val"><b>LIM_NULL_COMPARISON</b></a>]  Theorem
      
       net f g.
          eventually (x. abs (f x)  g x) net  ((x. g x)  0) net 
          (f  0) net
   
   [<a name="LIM_NULL_SUB-val"><b>LIM_NULL_SUB</b></a>]  Theorem
      
       net f g. (f  0) net  (g  0) net  ((x. f x  g x)  0) net
   
   [<a name="LIM_NULL_SUM-val"><b>LIM_NULL_SUM</b></a>]  Theorem
      
       net f s.
          FINITE s  (a. a  s  ((x. f x a)  0) net) 
          ((x. sum s (f x))  0) net
   
   [<a name="LIM_POSINFINITY_SEQUENTIALLY-val"><b>LIM_POSINFINITY_SEQUENTIALLY</b></a>]  Theorem
      
       f l. (f  l) at_posinfinity  ((n. f (&n))  l) sequentially
   
   [<a name="LIM_SEQUENTIALLY-val"><b>LIM_SEQUENTIALLY</b></a>]  Theorem
      
       s l.
          (s  l) sequentially 
          e. 0 &lt; e  N. n. N  n  dist (s n,l) &lt; e
   
   [<a name="LIM_SUB-val"><b>LIM_SUB</b></a>]  Theorem
      
       net f g l m.
          (f  l) net  (g  m) net  ((x. f x  g x)  (l  m)) net
   
   [<a name="LIM_SUBSEQUENCE-val"><b>LIM_SUBSEQUENCE</b></a>]  Theorem
      
       s r l.
          (m n. m &lt; n  r m &lt; r n)  (s  l) sequentially 
          (s  r  l) sequentially
   
   [<a name="LIM_SUBSEQUENCE_WEAK-val"><b>LIM_SUBSEQUENCE_WEAK</b></a>]  Theorem
      
       s r l.
          (m n. m  n  r m  r n)  (n. m. n  r m) 
          (s  l) sequentially 
          (s  r  l) sequentially
   
   [<a name="LIM_SUM-val"><b>LIM_SUM</b></a>]  Theorem
      
       net f l s.
          FINITE s  (i. i  s  (f i  l i) net) 
          ((x. sum s (i. f i x))  sum s l) net
   
   [<a name="LIM_TRANSFORM-val"><b>LIM_TRANSFORM</b></a>]  Theorem
      
       net f g l. ((x. f x  g x)  0) net  (f  l) net  (g  l) net
   
   [<a name="LIM_TRANSFORM_AT-val"><b>LIM_TRANSFORM_AT</b></a>]  Theorem
      
       f g x d.
          0 &lt; d  (x'. 0 &lt; dist (x',x)  dist (x',x) &lt; d  f x' = g x') 
          (f  l) (at x) 
          (g  l) (at x)
   
   [<a name="LIM_TRANSFORM_AWAY_AT-val"><b>LIM_TRANSFORM_AWAY_AT</b></a>]  Theorem
      
       f g a b.
          a  b  (x. x  a  x  b  f x = g x)  (f  l) (at a) 
          (g  l) (at a)
   
   [<a name="LIM_TRANSFORM_AWAY_WITHIN-val"><b>LIM_TRANSFORM_AWAY_WITHIN</b></a>]  Theorem
      
       f g a b s.
          a  b  (x. x  s  x  a  x  b  f x = g x) 
          (f  l) (at a within s) 
          (g  l) (at a within s)
   
   [<a name="LIM_TRANSFORM_BOUND-val"><b>LIM_TRANSFORM_BOUND</b></a>]  Theorem
      
       f g.
          eventually (n. abs (f n)  abs (g n)) net  (g  0) net 
          (f  0) net
   
   [<a name="LIM_TRANSFORM_EQ-val"><b>LIM_TRANSFORM_EQ</b></a>]  Theorem
      
       net f g l. ((x. f x  g x)  0) net  ((f  l) net  (g  l) net)
   
   [<a name="LIM_TRANSFORM_EVENTUALLY-val"><b>LIM_TRANSFORM_EVENTUALLY</b></a>]  Theorem
      
       net f g l.
          eventually (x. f x = g x) net  (f  l) net  (g  l) net
   
   [<a name="LIM_TRANSFORM_WITHIN-val"><b>LIM_TRANSFORM_WITHIN</b></a>]  Theorem
      
       f g x s d.
          0 &lt; d 
          (x'. x'  s  0 &lt; dist (x',x)  dist (x',x) &lt; d  f x' = g x') 
          (f  l) (at x within s) 
          (g  l) (at x within s)
   
   [<a name="LIM_TRANSFORM_WITHIN_OPEN-val"><b>LIM_TRANSFORM_WITHIN_OPEN</b></a>]  Theorem
      
       f g s a l.
          open s  a  s  (x. x  s  x  a  f x = g x)  (f  l) (at a) 
          (g  l) (at a)
   
   [<a name="LIM_TRANSFORM_WITHIN_OPEN_IN-val"><b>LIM_TRANSFORM_WITHIN_OPEN_IN</b></a>]  Theorem
      
       f g s t a l.
          open_in (subtopology euclidean t) s  a  s 
          (x. x  s  x  a  f x = g x)  (f  l) (at a within t) 
          (g  l) (at a within t)
   
   [<a name="LIM_TRANSFORM_WITHIN_SET-val"><b>LIM_TRANSFORM_WITHIN_SET</b></a>]  Theorem
      
       f a s t.
          eventually (x. x  s  x  t) (at a) 
          ((f  l) (at a within s)  (f  l) (at a within t))
   
   [<a name="LIM_TRANSFORM_WITHIN_SET_IMP-val"><b>LIM_TRANSFORM_WITHIN_SET_IMP</b></a>]  Theorem
      
       f l a s t.
          eventually (x. x  t  x  s) (at a)  (f  l) (at a within s) 
          (f  l) (at a within t)
   
   [<a name="LIM_UNION-val"><b>LIM_UNION</b></a>]  Theorem
      
       f x l s t.
          (f  l) (at x within s)  (f  l) (at x within t) 
          (f  l) (at x within s  t)
   
   [<a name="LIM_UNION_UNIV-val"><b>LIM_UNION_UNIV</b></a>]  Theorem
      
       f x l s t.
          (f  l) (at x within s)  (f  l) (at x within t) 
          s  t = (:real) 
          (f  l) (at x)
   
   [<a name="LIM_UNIQUE-val"><b>LIM_UNIQUE</b></a>]  Theorem
      
       net f l l'.
          trivial_limit net  (f  l) net  (f  l') net  l = l'
   
   [<a name="LIM_VMUL-val"><b>LIM_VMUL</b></a>]  Theorem
      
       net c d v. (c  d) net  ((x. c x * v)  (d * v)) net
   
   [<a name="LIM_WITHIN-val"><b>LIM_WITHIN</b></a>]  Theorem
      
       f l a s.
          (f  l) (at a within s) 
          e. 0 &lt; e 
              d. 0 &lt; d 
                  x. x  s  0 &lt; dist (x,a)  dist (x,a) &lt; d 
                      dist (f x,l) &lt; e
   
   [<a name="LIM_WITHIN_CLOSED_TRIVIAL-val"><b>LIM_WITHIN_CLOSED_TRIVIAL</b></a>]  Theorem
      
       a s. closed s  a  s  trivial_limit (at a within s)
   
   [<a name="LIM_WITHIN_EMPTY-val"><b>LIM_WITHIN_EMPTY</b></a>]  Theorem
      
       f l x. (f  l) (at x within )
   
   [<a name="LIM_WITHIN_ID-val"><b>LIM_WITHIN_ID</b></a>]  Theorem
      
       a s. ((x. x)  a) (at a within s)
   
   [<a name="LIM_WITHIN_INTERIOR-val"><b>LIM_WITHIN_INTERIOR</b></a>]  Theorem
      
       f l s x.
          x  interior s  ((f  l) (at x within s)  (f  l) (at x))
   
   [<a name="LIM_WITHIN_LE-val"><b>LIM_WITHIN_LE</b></a>]  Theorem
      
       f l a s.
          (f  l) (at a within s) 
          e. 0 &lt; e 
              d. 0 &lt; d 
                  x. x  s  0 &lt; dist (x,a)  dist (x,a)  d 
                      dist (f x,l) &lt; e
   
   [<a name="LIM_WITHIN_OPEN-val"><b>LIM_WITHIN_OPEN</b></a>]  Theorem
      
       f l a s.
          a  s  open s  ((f  l) (at a within s)  (f  l) (at a))
   
   [<a name="LIM_WITHIN_SUBSET-val"><b>LIM_WITHIN_SUBSET</b></a>]  Theorem
      
       f l a s. (f  l) (at a within s)  t  s  (f  l) (at a within t)
   
   [<a name="LIM_WITHIN_UNION-val"><b>LIM_WITHIN_UNION</b></a>]  Theorem
      
       (f  l) (at x within s  t) 
        (f  l) (at x within s)  (f  l) (at x within t)
   
   [<a name="LINEAR_0-val"><b>LINEAR_0</b></a>]  Theorem
      
       f. linear f  f 0 = 0
   
   [<a name="LINEAR_ADD-val"><b>LINEAR_ADD</b></a>]  Theorem
      
       f x y. linear f  f (x + y) = f x + f y
   
   [<a name="LINEAR_BOUNDED-val"><b>LINEAR_BOUNDED</b></a>]  Theorem
      
       f. linear f  B. x. abs (f x)  B * abs x
   
   [<a name="LINEAR_BOUNDED_POS-val"><b>LINEAR_BOUNDED_POS</b></a>]  Theorem
      
       f. linear f  B. 0 &lt; B  x. abs (f x)  B * abs x
   
   [<a name="LINEAR_CMUL-val"><b>LINEAR_CMUL</b></a>]  Theorem
      
       f c x. linear f  f (c * x) = c * f x
   
   [<a name="LINEAR_COMPOSE-val"><b>LINEAR_COMPOSE</b></a>]  Theorem
      
       f g. linear f  linear g  linear (g  f)
   
   [<a name="LINEAR_COMPOSE_ADD-val"><b>LINEAR_COMPOSE_ADD</b></a>]  Theorem
      
       f g. linear f  linear g  linear (x. f x + g x)
   
   [<a name="LINEAR_COMPOSE_CMUL-val"><b>LINEAR_COMPOSE_CMUL</b></a>]  Theorem
      
       f c. linear f  linear (x. c * f x)
   
   [<a name="LINEAR_COMPOSE_NEG-val"><b>LINEAR_COMPOSE_NEG</b></a>]  Theorem
      
       f. linear f  linear (x. -f x)
   
   [<a name="LINEAR_COMPOSE_SUB-val"><b>LINEAR_COMPOSE_SUB</b></a>]  Theorem
      
       f g. linear f  linear g  linear (x. f x  g x)
   
   [<a name="LINEAR_COMPOSE_SUM-val"><b>LINEAR_COMPOSE_SUM</b></a>]  Theorem
      
       f s.
          FINITE s  (a. a  s  linear (f a)) 
          linear (x. sum s (a. f a x))
   
   [<a name="LINEAR_CONTINUOUS_AT-val"><b>LINEAR_CONTINUOUS_AT</b></a>]  Theorem
      
       f a. linear f  f continuous at a
   
   [<a name="LINEAR_CONTINUOUS_COMPOSE-val"><b>LINEAR_CONTINUOUS_COMPOSE</b></a>]  Theorem
      
       net f g.
          f continuous net  linear g  (x. g (f x)) continuous net
   
   [<a name="LINEAR_CONTINUOUS_ON-val"><b>LINEAR_CONTINUOUS_ON</b></a>]  Theorem
      
       f s. linear f  f continuous_on s
   
   [<a name="LINEAR_CONTINUOUS_ON_COMPOSE-val"><b>LINEAR_CONTINUOUS_ON_COMPOSE</b></a>]  Theorem
      
       f g s.
          f continuous_on s  linear g  (x. g (f x)) continuous_on s
   
   [<a name="LINEAR_CONTINUOUS_WITHIN-val"><b>LINEAR_CONTINUOUS_WITHIN</b></a>]  Theorem
      
       f s x. linear f  f continuous (at x within s)
   
   [<a name="LINEAR_EQ-val"><b>LINEAR_EQ</b></a>]  Theorem
      
       f g b s.
          linear f  linear g  s  span b  (x. x  b  f x = g x) 
          x. x  s  f x = g x
   
   [<a name="LINEAR_EQ_0-val"><b>LINEAR_EQ_0</b></a>]  Theorem
      
       f b s.
          linear f  s  span b  (x. x  b  f x = 0) 
          x. x  s  f x = 0
   
   [<a name="LINEAR_EQ_0_SPAN-val"><b>LINEAR_EQ_0_SPAN</b></a>]  Theorem
      
       f b. linear f  (x. x  b  f x = 0)  x. x  span b  f x = 0
   
   [<a name="LINEAR_EQ_STDBASIS-val"><b>LINEAR_EQ_STDBASIS</b></a>]  Theorem
      
       f g. linear f  linear g  (i. 1  i  i  1  f i = g i)  f = g
   
   [<a name="LINEAR_ID-val"><b>LINEAR_ID</b></a>]  Theorem
      
       linear (x. x)
   
   [<a name="LINEAR_IMAGE_SUBSET_INTERIOR-val"><b>LINEAR_IMAGE_SUBSET_INTERIOR</b></a>]  Theorem
      
       f s.
          linear f  (y. x. f x = y) 
          IMAGE f (interior s)  interior (IMAGE f s)
   
   [<a name="LINEAR_INDEPENDENT_EXTEND-val"><b>LINEAR_INDEPENDENT_EXTEND</b></a>]  Theorem
      
       f b. independent b  g. linear g  x. x  b  g x = f x
   
   [<a name="LINEAR_INDEPENDENT_EXTEND_LEMMA-val"><b>LINEAR_INDEPENDENT_EXTEND_LEMMA</b></a>]  Theorem
      
       f b.
          FINITE b 
          independent b 
          g. (x y. x  span b  y  span b  g (x + y) = g x + g y) 
              (x c. x  span b  g (c * x) = c * g x) 
              x. x  b  g x = f x
   
   [<a name="LINEAR_INJECTIVE_0_SUBSPACE-val"><b>LINEAR_INJECTIVE_0_SUBSPACE</b></a>]  Theorem
      
       f s.
          linear f  subspace s 
          ((x y. x  s  y  s  f x = f y  x = y) 
           x. x  s  f x = 0  x = 0)
   
   [<a name="LINEAR_INJECTIVE_BOUNDED_BELOW_POS-val"><b>LINEAR_INJECTIVE_BOUNDED_BELOW_POS</b></a>]  Theorem
      
       f. linear f  (x y. f x = f y  x = y) 
            B. 0 &lt; B  x. abs x * B  abs (f x)
   
   [<a name="LINEAR_INJECTIVE_IMP_SURJECTIVE-val"><b>LINEAR_INJECTIVE_IMP_SURJECTIVE</b></a>]  Theorem
      
       f. linear f  (x y. f x = f y  x = y)  y. x. f x = y
   
   [<a name="LINEAR_INJECTIVE_LEFT_INVERSE-val"><b>LINEAR_INJECTIVE_LEFT_INVERSE</b></a>]  Theorem
      
       f. linear f  (x y. f x = f y  x = y) 
            g. linear g  g  f = (x. x)
   
   [<a name="LINEAR_INTERIOR_IMAGE_SUBSET-val"><b>LINEAR_INTERIOR_IMAGE_SUBSET</b></a>]  Theorem
      
       f s.
          linear f  (x y. f x = f y  x = y) 
          interior (IMAGE f s)  IMAGE f (interior s)
   
   [<a name="LINEAR_INVERTIBLE_BOUNDED_BELOW-val"><b>LINEAR_INVERTIBLE_BOUNDED_BELOW</b></a>]  Theorem
      
       f g.
          linear f  linear g  g  f = I  B. x. B * abs x  abs (f x)
   
   [<a name="LINEAR_INVERTIBLE_BOUNDED_BELOW_POS-val"><b>LINEAR_INVERTIBLE_BOUNDED_BELOW_POS</b></a>]  Theorem
      
       f g.
          linear f  linear g  g  f = I 
          B. 0 &lt; B  x. B * abs x  abs (f x)
   
   [<a name="LINEAR_LIM_0-val"><b>LINEAR_LIM_0</b></a>]  Theorem
      
       f. linear f  (f  0) (at 0)
   
   [<a name="LINEAR_MUL_COMPONENT-val"><b>LINEAR_MUL_COMPONENT</b></a>]  Theorem
      
       f v. linear f  linear (x. f x * v)
   
   [<a name="LINEAR_NEG-val"><b>LINEAR_NEG</b></a>]  Theorem
      
       f x. linear f  f (-x) = -f x
   
   [<a name="LINEAR_NEGATION-val"><b>LINEAR_NEGATION</b></a>]  Theorem
      
       linear (x. -x)
   
   [<a name="LINEAR_OPEN_MAPPING-val"><b>LINEAR_OPEN_MAPPING</b></a>]  Theorem
      
       f g.
          linear f  linear g  f  g = I  s. open s  open (IMAGE f s)
   
   [<a name="LINEAR_SCALING-val"><b>LINEAR_SCALING</b></a>]  Theorem
      
       c. linear (x. c * x)
   
   [<a name="LINEAR_SUB-val"><b>LINEAR_SUB</b></a>]  Theorem
      
       f x y. linear f  f (x  y) = f x  f y
   
   [<a name="LINEAR_SUM-val"><b>LINEAR_SUM</b></a>]  Theorem
      
       f g s. linear f  FINITE s  f (sum s g) = sum s (f  g)
   
   [<a name="LINEAR_SUM_MUL-val"><b>LINEAR_SUM_MUL</b></a>]  Theorem
      
       f s c v.
          linear f  FINITE s 
          f (sum s (i. c i * v i)) = sum s (i. c i * f (v i))
   
   [<a name="LINEAR_UNIFORMLY_CONTINUOUS_ON-val"><b>LINEAR_UNIFORMLY_CONTINUOUS_ON</b></a>]  Theorem
      
       f s. linear f  f uniformly_continuous_on s
   
   [<a name="LINEAR_ZERO-val"><b>LINEAR_ZERO</b></a>]  Theorem
      
       linear (x. 0)
   
   [<a name="LOCALLY_CLOSED-val"><b>LOCALLY_CLOSED</b></a>]  Theorem
      
       s. locally closed s  locally compact s
   
   [<a name="LOCALLY_COMPACT-val"><b>LOCALLY_COMPACT</b></a>]  Theorem
      
       s. locally compact s 
            x. x  s 
                u v.
                  x  u  u  v  v  s 
                  open_in (subtopology euclidean s) u  compact v
   
   [<a name="LOCALLY_COMPACT_ALT-val"><b>LOCALLY_COMPACT_ALT</b></a>]  Theorem
      
       s. locally compact s 
            x. x  s 
                u. x  u  open_in (subtopology euclidean s) u 
                    compact (closure u)  closure u  s
   
   [<a name="LOCALLY_COMPACT_CLOSED_IN-val"><b>LOCALLY_COMPACT_CLOSED_IN</b></a>]  Theorem
      
       s t.
          closed_in (subtopology euclidean s) t  locally compact s 
          locally compact t
   
   [<a name="LOCALLY_COMPACT_CLOSED_INTER_OPEN-val"><b>LOCALLY_COMPACT_CLOSED_INTER_OPEN</b></a>]  Theorem
      
       s. locally compact s  t u. closed t  open u  s = t  u
   
   [<a name="LOCALLY_COMPACT_CLOSED_IN_OPEN-val"><b>LOCALLY_COMPACT_CLOSED_IN_OPEN</b></a>]  Theorem
      
       s. locally compact s 
            t. open t  closed_in (subtopology euclidean t) s
   
   [<a name="LOCALLY_COMPACT_CLOSED_UNION-val"><b>LOCALLY_COMPACT_CLOSED_UNION</b></a>]  Theorem
      
       s t.
          locally compact s  locally compact t 
          closed_in (subtopology euclidean (s  t)) s 
          closed_in (subtopology euclidean (s  t)) t 
          locally compact (s  t)
   
   [<a name="LOCALLY_COMPACT_COMPACT-val"><b>LOCALLY_COMPACT_COMPACT</b></a>]  Theorem
      
       s. locally compact s 
            k. k  s  compact k 
                u v.
                  k  u  u  v  v  s 
                  open_in (subtopology euclidean s) u  compact v
   
   [<a name="LOCALLY_COMPACT_COMPACT_ALT-val"><b>LOCALLY_COMPACT_COMPACT_ALT</b></a>]  Theorem
      
       s. locally compact s 
            k. k  s  compact k 
                u. k  u  open_in (subtopology euclidean s) u 
                    compact (closure u)  closure u  s
   
   [<a name="LOCALLY_COMPACT_COMPACT_SUBOPEN-val"><b>LOCALLY_COMPACT_COMPACT_SUBOPEN</b></a>]  Theorem
      
       s. locally compact s 
            k t.
              k  s  compact k  open t  k  t 
              u v.
                k  u  u  v  u  t  v  s 
                open_in (subtopology euclidean s) u  compact v
   
   [<a name="LOCALLY_COMPACT_DELETE-val"><b>LOCALLY_COMPACT_DELETE</b></a>]  Theorem
      
       s a. locally compact s  locally compact (s DELETE a)
   
   [<a name="LOCALLY_COMPACT_INTER-val"><b>LOCALLY_COMPACT_INTER</b></a>]  Theorem
      
       s t.
          locally compact s  locally compact t  locally compact (s  t)
   
   [<a name="LOCALLY_COMPACT_INTER_CBALL-val"><b>LOCALLY_COMPACT_INTER_CBALL</b></a>]  Theorem
      
       s. locally compact s 
            x. x  s  e. 0 &lt; e  closed (cball (x,e)  s)
   
   [<a name="LOCALLY_COMPACT_INTER_CBALLS-val"><b>LOCALLY_COMPACT_INTER_CBALLS</b></a>]  Theorem
      
       s. locally compact s 
            x. x  s  e. 0 &lt; e  d. d  e  closed (cball (x,d)  s)
   
   [<a name="LOCALLY_COMPACT_OPEN_IN-val"><b>LOCALLY_COMPACT_OPEN_IN</b></a>]  Theorem
      
       s t.
          open_in (subtopology euclidean s) t  locally compact s 
          locally compact t
   
   [<a name="LOCALLY_COMPACT_OPEN_INTER_CLOSURE-val"><b>LOCALLY_COMPACT_OPEN_INTER_CLOSURE</b></a>]  Theorem
      
       s. locally compact s  t. open t  s = t  closure s
   
   [<a name="LOCALLY_COMPACT_OPEN_UNION-val"><b>LOCALLY_COMPACT_OPEN_UNION</b></a>]  Theorem
      
       s t.
          locally compact s  locally compact t 
          open_in (subtopology euclidean (s  t)) s 
          open_in (subtopology euclidean (s  t)) t 
          locally compact (s  t)
   
   [<a name="LOCALLY_COMPACT_PROPER_IMAGE-val"><b>LOCALLY_COMPACT_PROPER_IMAGE</b></a>]  Theorem
      
       f s.
          f continuous_on s 
          (k. k  IMAGE f s  compact k  compact {x | x  s  f x  k}) 
          locally compact s 
          locally compact (IMAGE f s)
   
   [<a name="LOCALLY_COMPACT_PROPER_IMAGE_EQ-val"><b>LOCALLY_COMPACT_PROPER_IMAGE_EQ</b></a>]  Theorem
      
       f s.
          f continuous_on s 
          (k. k  IMAGE f s  compact k  compact {x | x  s  f x  k}) 
          (locally compact s  locally compact (IMAGE f s))
   
   [<a name="LOCALLY_COMPACT_TRANSLATION_EQ-val"><b>LOCALLY_COMPACT_TRANSLATION_EQ</b></a>]  Theorem
      
       a s. locally compact (IMAGE (x. a + x) s)  locally compact s
   
   [<a name="LOCALLY_COMPACT_UNIV-val"><b>LOCALLY_COMPACT_UNIV</b></a>]  Theorem
      
       locally compact (:real)
   
   [<a name="LOCALLY_DIFF_CLOSED-val"><b>LOCALLY_DIFF_CLOSED</b></a>]  Theorem
      
       P s t.
          locally P s  closed_in (subtopology euclidean s) t 
          locally P (s DIFF t)
   
   [<a name="LOCALLY_EMPTY-val"><b>LOCALLY_EMPTY</b></a>]  Theorem
      
       P. locally P 
   
   [<a name="LOCALLY_INJECTIVE_LINEAR_IMAGE-val"><b>LOCALLY_INJECTIVE_LINEAR_IMAGE</b></a>]  Theorem
      
       P Q.
          (f s.
             linear f  (x y. f x = f y  x = y)  (P (IMAGE f s)  Q s)) 
          f s.
            linear f  (x y. f x = f y  x = y) 
            (locally P (IMAGE f s)  locally Q s)
   
   [<a name="LOCALLY_INTER-val"><b>LOCALLY_INTER</b></a>]  Theorem
      
       P. (s t. P s  P t  P (s  t)) 
            s t. locally P s  locally P t  locally P (s  t)
   
   [<a name="LOCALLY_MONO-val"><b>LOCALLY_MONO</b></a>]  Theorem
      
       P Q s. (t. P t  Q t)  locally P s  locally Q s
   
   [<a name="LOCALLY_OPEN_MAP_IMAGE-val"><b>LOCALLY_OPEN_MAP_IMAGE</b></a>]  Theorem
      
       P Q f s.
          f continuous_on s 
          (t. open_in (subtopology euclidean s) t 
               open_in (subtopology euclidean (IMAGE f s)) (IMAGE f t)) 
          (t. t  s  P t  Q (IMAGE f t))  locally P s 
          locally Q (IMAGE f s)
   
   [<a name="LOCALLY_OPEN_SUBSET-val"><b>LOCALLY_OPEN_SUBSET</b></a>]  Theorem
      
       P s t.
          locally P s  open_in (subtopology euclidean s) t  locally P t
   
   [<a name="LOCALLY_SING-val"><b>LOCALLY_SING</b></a>]  Theorem
      
       P a. locally P {a}  P {a}
   
   [<a name="LOCALLY_TRANSLATION-val"><b>LOCALLY_TRANSLATION</b></a>]  Theorem
      
       P. (a s. P (IMAGE (x. a + x) s)  P s) 
            a s. locally P (IMAGE (x. a + x) s)  locally P s
   
   [<a name="LOWER_HEMICONTINUOUS-val"><b>LOWER_HEMICONTINUOUS</b></a>]  Theorem
      
       f t s.
          (x. x  s  f x  t) 
          ((u. closed_in (subtopology euclidean t) u 
                closed_in (subtopology euclidean s) {x | x  s  f x  u}) 
           u. open_in (subtopology euclidean t) u 
               open_in (subtopology euclidean s) {x | x  s  f x  u  })
   
   [<a name="MAPPING_CONNECTED_ONTO_SEGMENT-val"><b>MAPPING_CONNECTED_ONTO_SEGMENT</b></a>]  Theorem
      
       s a b.
          connected s  (a. s  {a}) 
          f. f continuous_on s  IMAGE f s = segment [(a,b)]
   
   [<a name="MAXIMAL_INDEPENDENT_SUBSET-val"><b>MAXIMAL_INDEPENDENT_SUBSET</b></a>]  Theorem
      
       v. b. b  v  independent b  v  span b
   
   [<a name="MAXIMAL_INDEPENDENT_SUBSET_EXTEND-val"><b>MAXIMAL_INDEPENDENT_SUBSET_EXTEND</b></a>]  Theorem
      
       s v.
          s  v  independent s 
          b. s  b  b  v  independent b  v  span b
   
   [<a name="METRIZABLE_SPACE_EUCLIDEAN-val"><b>METRIZABLE_SPACE_EUCLIDEAN</b></a>]  Theorem
      
       metrizable_space euclidean
   
   [<a name="MIDPOINT_COLLINEAR-val"><b>MIDPOINT_COLLINEAR</b></a>]  Theorem
      
       a b c.
          a  c 
          (b = midpoint (a,c) 
           collinear {a; b; c}  dist (a,b) = dist (b,c))
   
   [<a name="MIDPOINT_EQ_ENDPOINT-val"><b>MIDPOINT_EQ_ENDPOINT</b></a>]  Theorem
      
       a b.
          (midpoint (a,b) = a  a = b)  (midpoint (a,b) = b  a = b) 
          (a = midpoint (a,b)  a = b)  (b = midpoint (a,b)  a = b)
   
   [<a name="MIDPOINT_IN_SEGMENT-val"><b>MIDPOINT_IN_SEGMENT</b></a>]  Theorem
      
       (a b. midpoint (a,b)  segment [(a,b)]) 
        a b. midpoint (a,b)  segment (a,b)  a  b
   
   [<a name="MIDPOINT_LINEAR_IMAGE-val"><b>MIDPOINT_LINEAR_IMAGE</b></a>]  Theorem
      
       f a b. linear f  midpoint (f a,f b) = f (midpoint (a,b))
   
   [<a name="MIDPOINT_REFL-val"><b>MIDPOINT_REFL</b></a>]  Theorem
      
       x. midpoint (x,x) = x
   
   [<a name="MIDPOINT_SYM-val"><b>MIDPOINT_SYM</b></a>]  Theorem
      
       a b. midpoint (a,b) = midpoint (b,a)
   
   [<a name="MONOTONE_BIGGER-val"><b>MONOTONE_BIGGER</b></a>]  Theorem
      
       r. (m n. m &lt; n  r m &lt; r n)  n. n  r n
   
   [<a name="MONOTONE_SUBSEQUENCE-val"><b>MONOTONE_SUBSEQUENCE</b></a>]  Theorem
      
       s. r.
          (m n. m &lt; n  r m &lt; r n) 
          ((m n. m  n  s (r m)  s (r n)) 
           m n. m  n  s (r n)  s (r m))
   
   [<a name="MUL_CAUCHY_SCHWARZ_EQUAL-val"><b>MUL_CAUCHY_SCHWARZ_EQUAL</b></a>]  Theorem
      
       x y. (x * y) = x * x * (y * y)  collinear {0; x; y}
   
   [<a name="MUMFORD_LEMMA-val"><b>MUMFORD_LEMMA</b></a>]  Theorem
      
       f s t y.
          f continuous_on s  IMAGE f s  t  locally compact s  y  t 
          compact {x | x  s  f x = y} 
          u v.
            open_in (subtopology euclidean s) u 
            open_in (subtopology euclidean t) v 
            {x | x  s  f x = y}  u  y  v  IMAGE f u  v 
            k. k  v  compact k  compact {x | x  u  f x  k}
   
   [<a name="NEGATIONS_BALL-val"><b>NEGATIONS_BALL</b></a>]  Theorem
      
       r. IMAGE (x. -x) (ball (0,r)) = ball (0,r)
   
   [<a name="NEGATIONS_CBALL-val"><b>NEGATIONS_CBALL</b></a>]  Theorem
      
       r. IMAGE (x. -x) (cball (0,r)) = cball (0,r)
   
   [<a name="NEGATIONS_SPHERE-val"><b>NEGATIONS_SPHERE</b></a>]  Theorem
      
       r. IMAGE (x. -x) (sphere (0,r)) = sphere (0,r)
   
   [<a name="NET-val"><b>NET</b></a>]  Theorem
      
       n x y.
          (z. netord n z x  netord n z y) 
          z. netord n z y  netord n z x
   
   [<a name="NETLIMIT_AT-val"><b>NETLIMIT_AT</b></a>]  Theorem
      
       a. netlimit (at a) = a
   
   [<a name="NETLIMIT_WITHIN-val"><b>NETLIMIT_WITHIN</b></a>]  Theorem
      
       a s. trivial_limit (at a within s)  netlimit (at a within s) = a
   
   [<a name="NETLIMIT_WITHIN_INTERIOR-val"><b>NETLIMIT_WITHIN_INTERIOR</b></a>]  Theorem
      
       s x. x  interior s  netlimit (at x within s) = x
   
   [<a name="NET_DILEMMA-val"><b>NET_DILEMMA</b></a>]  Theorem
      
       net.
          (a. (x. netord net x a)  x. netord net x a  P x) 
          (b. (x. netord net x b)  x. netord net x b  Q x) 
          c. (x. netord net x c)  x. netord net x c  P x  Q x
   
   [<a name="NONTRIVIAL_LIMIT_WITHIN-val"><b>NONTRIVIAL_LIMIT_WITHIN</b></a>]  Theorem
      
       net s. trivial_limit net  trivial_limit (net within s)
   
   [<a name="NOT_BOUNDED_UNIV-val"><b>NOT_BOUNDED_UNIV</b></a>]  Theorem
      
       bounded (:real)
   
   [<a name="NOT_EVENTUALLY-val"><b>NOT_EVENTUALLY</b></a>]  Theorem
      
       net p. (x. p x)  trivial_limit net  eventually p net
   
   [<a name="NOT_INTERVAL_UNIV-val"><b>NOT_INTERVAL_UNIV</b></a>]  Theorem
      
       (a b. interval [(a,b)]  (:real)) 
        a b. interval (a,b)  (:real)
   
   [<a name="NOWHERE_DENSE-val"><b>NOWHERE_DENSE</b></a>]  Theorem
      
       s. interior (closure s) =  
            t. open t  t    u. open u  u    u  t  u  s = 
   
   [<a name="NOWHERE_DENSE_COUNTABLE_BIGUNION-val"><b>NOWHERE_DENSE_COUNTABLE_BIGUNION</b></a>]  Theorem
      
       g. countable g  (s. s  g  interior (closure s) = ) 
            interior (BIGUNION g) = 
   
   [<a name="NOWHERE_DENSE_COUNTABLE_BIGUNION_CLOSED-val"><b>NOWHERE_DENSE_COUNTABLE_BIGUNION_CLOSED</b></a>]  Theorem
      
       g. countable g  (s. s  g  closed s  interior s = ) 
            interior (BIGUNION g) = 
   
   [<a name="NOWHERE_DENSE_UNION-val"><b>NOWHERE_DENSE_UNION</b></a>]  Theorem
      
       s t.
          interior (closure (s  t)) =  
          interior (closure s) =   interior (closure t) = 
   
   [<a name="NO_LIMIT_POINT_IMP_CLOSED-val"><b>NO_LIMIT_POINT_IMP_CLOSED</b></a>]  Theorem
      
       s. (x. x limit_point_of s)  closed s
   
   [<a name="OLDNET-val"><b>OLDNET</b></a>]  Theorem
      
       n x y.
          netord n x x  netord n y y 
          z. netord n z z  w. netord n w z  netord n w x  netord n w y
   
   [<a name="OPEN-val"><b>OPEN</b></a>]  Theorem
      
       s. open s  x. x  s  e. 0 &lt; e  x'. abs (x'  x) &lt; e  x'  s
   
   [<a name="OPEN_AFFINITY-val"><b>OPEN_AFFINITY</b></a>]  Theorem
      
       s a c. open s  c  0  open (IMAGE (x. a + c * x) s)
   
   [<a name="OPEN_BALL-val"><b>OPEN_BALL</b></a>]  Theorem
      
       x e. open (ball (x,e))
   
   [<a name="OPEN_BIGINTER-val"><b>OPEN_BIGINTER</b></a>]  Theorem
      
       s. FINITE s  (t. t  s  open t)  open (BIGINTER s)
   
   [<a name="OPEN_BIGUNION-val"><b>OPEN_BIGUNION</b></a>]  Theorem
      
       f. (s. s  f  open s)  open (BIGUNION f)
   
   [<a name="OPEN_BIJECTIVE_LINEAR_IMAGE_EQ-val"><b>OPEN_BIJECTIVE_LINEAR_IMAGE_EQ</b></a>]  Theorem
      
       f s.
          linear f  (x y. f x = f y  x = y)  (y. x. f x = y) 
          (open (IMAGE f s)  open s)
   
   [<a name="OPEN_CLOSED-val"><b>OPEN_CLOSED</b></a>]  Theorem
      
       s. open s  closed ((:real) DIFF s)
   
   [<a name="OPEN_CLOSED_INTERVAL-val"><b>OPEN_CLOSED_INTERVAL</b></a>]  Theorem
      
       a b. interval (a,b) = interval [(a,b)] DIFF {a; b}
   
   [<a name="OPEN_CLOSED_INTERVAL_CONVEX-val"><b>OPEN_CLOSED_INTERVAL_CONVEX</b></a>]  Theorem
      
       a b x y e.
          x  interval (a,b)  y  interval [(a,b)]  0 &lt; e  e  1 
          e * x + (1  e) * y  interval (a,b)
   
   [<a name="OPEN_CONTAINS_BALL-val"><b>OPEN_CONTAINS_BALL</b></a>]  Theorem
      
       s. open s  x. x  s  e. 0 &lt; e  ball (x,e)  s
   
   [<a name="OPEN_CONTAINS_BALL_EQ-val"><b>OPEN_CONTAINS_BALL_EQ</b></a>]  Theorem
      
       s. open s  x. x  s  e. 0 &lt; e  ball (x,e)  s
   
   [<a name="OPEN_CONTAINS_CBALL-val"><b>OPEN_CONTAINS_CBALL</b></a>]  Theorem
      
       s. open s  x. x  s  e. 0 &lt; e  cball (x,e)  s
   
   [<a name="OPEN_CONTAINS_CBALL_EQ-val"><b>OPEN_CONTAINS_CBALL_EQ</b></a>]  Theorem
      
       s. open s  x. x  s  e. 0 &lt; e  cball (x,e)  s
   
   [<a name="OPEN_CONTAINS_INTERVAL-val"><b>OPEN_CONTAINS_INTERVAL</b></a>]  Theorem
      
       s. open s 
            x. x  s  a b. x  interval (a,b)  interval [(a,b)]  s
   
   [<a name="OPEN_CONTAINS_INTERVAL_OPEN_INTERVAL-val"><b>OPEN_CONTAINS_INTERVAL_OPEN_INTERVAL</b></a>]  Theorem
      
       (s. open s 
             x. x  s  a b. x  interval (a,b)  interval [(a,b)]  s) 
        s. open s 
            x. x  s  a b. x  interval (a,b)  interval (a,b)  s
   
   [<a name="OPEN_CONTAINS_OPEN_INTERVAL-val"><b>OPEN_CONTAINS_OPEN_INTERVAL</b></a>]  Theorem
      
       s. open s 
            x. x  s  a b. x  interval (a,b)  interval (a,b)  s
   
   [<a name="OPEN_DELETE-val"><b>OPEN_DELETE</b></a>]  Theorem
      
       s x. open s  open (s DELETE x)
   
   [<a name="OPEN_DIFF-val"><b>OPEN_DIFF</b></a>]  Theorem
      
       s t. open s  closed t  open (s DIFF t)
   
   [<a name="OPEN_EMPTY-val"><b>OPEN_EMPTY</b></a>]  Theorem
      
       open 
   
   [<a name="OPEN_EXISTS-val"><b>OPEN_EXISTS</b></a>]  Theorem
      
       Q. (a. open {x | Q a x})  open {x | (a. Q a x)}
   
   [<a name="OPEN_EXISTS_IN-val"><b>OPEN_EXISTS_IN</b></a>]  Theorem
      
       P Q. (a. P a  open {x | Q a x})  open {x | (a. P a  Q a x)}
   
   [<a name="OPEN_HALFSPACE_COMPONENT_GT-val"><b>OPEN_HALFSPACE_COMPONENT_GT</b></a>]  Theorem
      
       a. open {x | x &gt; a}
   
   [<a name="OPEN_HALFSPACE_COMPONENT_LT-val"><b>OPEN_HALFSPACE_COMPONENT_LT</b></a>]  Theorem
      
       a. open {x | x &lt; a}
   
   [<a name="OPEN_HALFSPACE_GT-val"><b>OPEN_HALFSPACE_GT</b></a>]  Theorem
      
       a b. open {x | a * x &gt; b}
   
   [<a name="OPEN_HALFSPACE_LT-val"><b>OPEN_HALFSPACE_LT</b></a>]  Theorem
      
       a b. open {x | a * x &lt; b}
   
   [<a name="OPEN_IMP_INFINITE-val"><b>OPEN_IMP_INFINITE</b></a>]  Theorem
      
       s. open s  s =   INFINITE s
   
   [<a name="OPEN_IMP_LOCALLY_COMPACT-val"><b>OPEN_IMP_LOCALLY_COMPACT</b></a>]  Theorem
      
       s. open s  locally compact s
   
   [<a name="OPEN_IN-val"><b>OPEN_IN</b></a>]  Theorem
      
       s. open s  open_in euclidean s
   
   [<a name="OPEN_INTER-val"><b>OPEN_INTER</b></a>]  Theorem
      
       s t. open s  open t  open (s  t)
   
   [<a name="OPEN_INTERIOR-val"><b>OPEN_INTERIOR</b></a>]  Theorem
      
       s. open (interior s)
   
   [<a name="OPEN_INTERVAL-val"><b>OPEN_INTERVAL</b></a>]  Theorem
      
       a b. open (interval (a,b))
   
   [<a name="OPEN_INTERVAL_EQ-val"><b>OPEN_INTERVAL_EQ</b></a>]  Theorem
      
       (a b. open (interval [(a,b)])  interval [(a,b)] = ) 
        a b. open (interval (a,b))
   
   [<a name="OPEN_INTERVAL_LEFT-val"><b>OPEN_INTERVAL_LEFT</b></a>]  Theorem
      
       b. open {x | x &lt; b}
   
   [<a name="OPEN_INTERVAL_LEMMA-val"><b>OPEN_INTERVAL_LEMMA</b></a>]  Theorem
      
       a b x.
          a &lt; x  x &lt; b 
          d. 0 &lt; d  x'. abs (x'  x) &lt; d  a &lt; x'  x' &lt; b
   
   [<a name="OPEN_INTERVAL_LOWERBOUND-val"><b>OPEN_INTERVAL_LOWERBOUND</b></a>]  Theorem
      
       a b. a &lt; b  interval_lowerbound (interval (a,b)) = a
   
   [<a name="OPEN_INTERVAL_MIDPOINT-val"><b>OPEN_INTERVAL_MIDPOINT</b></a>]  Theorem
      
       a b. interval (a,b)    2 * (a + b)  interval (a,b)
   
   [<a name="OPEN_INTERVAL_RIGHT-val"><b>OPEN_INTERVAL_RIGHT</b></a>]  Theorem
      
       a. open {x | a &lt; x}
   
   [<a name="OPEN_INTERVAL_UPPERBOUND-val"><b>OPEN_INTERVAL_UPPERBOUND</b></a>]  Theorem
      
       a b. a &lt; b  interval_upperbound (interval (a,b)) = b
   
   [<a name="OPEN_INTER_CLOSURE_EQ_EMPTY-val"><b>OPEN_INTER_CLOSURE_EQ_EMPTY</b></a>]  Theorem
      
       s t. open s  (s  closure t =   s  t = )
   
   [<a name="OPEN_INTER_CLOSURE_SUBSET-val"><b>OPEN_INTER_CLOSURE_SUBSET</b></a>]  Theorem
      
       s t. open s  s  closure t  closure (s  t)
   
   [<a name="OPEN_IN_CONNECTED_COMPONENT-val"><b>OPEN_IN_CONNECTED_COMPONENT</b></a>]  Theorem
      
       s x.
          FINITE {connected_component s x | x | x  s} 
          open_in (subtopology euclidean s) (connected_component s x)
   
   [<a name="OPEN_IN_CONTAINS_BALL-val"><b>OPEN_IN_CONTAINS_BALL</b></a>]  Theorem
      
       s t.
          open_in (subtopology euclidean t) s 
          s  t  x. x  s  e. 0 &lt; e  ball (x,e)  t  s
   
   [<a name="OPEN_IN_CONTAINS_CBALL-val"><b>OPEN_IN_CONTAINS_CBALL</b></a>]  Theorem
      
       s t.
          open_in (subtopology euclidean t) s 
          s  t  x. x  s  e. 0 &lt; e  cball (x,e)  t  s
   
   [<a name="OPEN_IN_DELETE-val"><b>OPEN_IN_DELETE</b></a>]  Theorem
      
       u s a.
          open_in (subtopology euclidean u) s 
          open_in (subtopology euclidean u) (s DELETE a)
   
   [<a name="OPEN_IN_INTER_OPEN-val"><b>OPEN_IN_INTER_OPEN</b></a>]  Theorem
      
       s t u.
          open_in (subtopology euclidean u) s  open t 
          open_in (subtopology euclidean u) (s  t)
   
   [<a name="OPEN_IN_LOCALLY_COMPACT-val"><b>OPEN_IN_LOCALLY_COMPACT</b></a>]  Theorem
      
       s t.
          locally compact s 
          (open_in (subtopology euclidean s) t 
           t  s 
           k. compact k  k  s 
               open_in (subtopology euclidean k) (k  t))
   
   [<a name="OPEN_IN_OPEN-val"><b>OPEN_IN_OPEN</b></a>]  Theorem
      
       s u. open_in (subtopology euclidean u) s  t. open t  s = u  t
   
   [<a name="OPEN_IN_OPEN_EQ-val"><b>OPEN_IN_OPEN_EQ</b></a>]  Theorem
      
       s t.
          open s  (open_in (subtopology euclidean s) t  open t  t  s)
   
   [<a name="OPEN_IN_OPEN_INTER-val"><b>OPEN_IN_OPEN_INTER</b></a>]  Theorem
      
       u s. open s  open_in (subtopology euclidean u) (u  s)
   
   [<a name="OPEN_IN_OPEN_TRANS-val"><b>OPEN_IN_OPEN_TRANS</b></a>]  Theorem
      
       s t. open_in (subtopology euclidean t) s  open t  open s
   
   [<a name="OPEN_IN_REFL-val"><b>OPEN_IN_REFL</b></a>]  Theorem
      
       s. open_in (subtopology euclidean s) s
   
   [<a name="OPEN_IN_SING-val"><b>OPEN_IN_SING</b></a>]  Theorem
      
       s a.
          open_in (subtopology euclidean s) {a} 
          a  s  (a limit_point_of s)
   
   [<a name="OPEN_IN_SUBSET_TRANS-val"><b>OPEN_IN_SUBSET_TRANS</b></a>]  Theorem
      
       s t u.
          open_in (subtopology euclidean u) s  s  t  t  u 
          open_in (subtopology euclidean t) s
   
   [<a name="OPEN_IN_SUBTOPOLOGY_INTER_SUBSET-val"><b>OPEN_IN_SUBTOPOLOGY_INTER_SUBSET</b></a>]  Theorem
      
       s u v.
          open_in (subtopology euclidean u) (u  s)  v  u 
          open_in (subtopology euclidean v) (v  s)
   
   [<a name="OPEN_IN_TRANS-val"><b>OPEN_IN_TRANS</b></a>]  Theorem
      
       s t u.
          open_in (subtopology euclidean t) s 
          open_in (subtopology euclidean u) t 
          open_in (subtopology euclidean u) s
   
   [<a name="OPEN_IN_TRANS_EQ-val"><b>OPEN_IN_TRANS_EQ</b></a>]  Theorem
      
       s t.
          (u. open_in (subtopology euclidean t) u 
               open_in (subtopology euclidean s) t) 
          open_in (subtopology euclidean s) t
   
   [<a name="OPEN_MAP_CLOSED_SUPERSET_PREIMAGE-val"><b>OPEN_MAP_CLOSED_SUPERSET_PREIMAGE</b></a>]  Theorem
      
       f s t u w.
          (k. open_in (subtopology euclidean s) k 
               open_in (subtopology euclidean t) (IMAGE f k)) 
          closed_in (subtopology euclidean s) u  w  t 
          {x | x  s  f x  w}  u 
          v. closed_in (subtopology euclidean t) v  w  v 
              {x | x  s  f x  v}  u
   
   [<a name="OPEN_MAP_CLOSED_SUPERSET_PREIMAGE_EQ-val"><b>OPEN_MAP_CLOSED_SUPERSET_PREIMAGE_EQ</b></a>]  Theorem
      
       f s t.
          IMAGE f s  t 
          ((k. open_in (subtopology euclidean s) k 
                open_in (subtopology euclidean t) (IMAGE f k)) 
           u w.
             closed_in (subtopology euclidean s) u  w  t 
             {x | x  s  f x  w}  u 
             v. closed_in (subtopology euclidean t) v  w  v 
                 {x | x  s  f x  v}  u)
   
   [<a name="OPEN_MAP_FROM_COMPOSITION_INJECTIVE-val"><b>OPEN_MAP_FROM_COMPOSITION_INJECTIVE</b></a>]  Theorem
      
       f g s t u.
          IMAGE f s  t  IMAGE g t  u  g continuous_on t 
          (x y. x  t  y  t  g x = g y  x = y) 
          (k. open_in (subtopology euclidean s) k 
               open_in (subtopology euclidean u) (IMAGE (g  f) k)) 
          k. open_in (subtopology euclidean s) k 
              open_in (subtopology euclidean t) (IMAGE f k)
   
   [<a name="OPEN_MAP_FROM_COMPOSITION_SURJECTIVE-val"><b>OPEN_MAP_FROM_COMPOSITION_SURJECTIVE</b></a>]  Theorem
      
       f g s t u.
          f continuous_on s  IMAGE f s = t  IMAGE g t  u 
          (k. open_in (subtopology euclidean s) k 
               open_in (subtopology euclidean u) (IMAGE (g  f) k)) 
          k. open_in (subtopology euclidean t) k 
              open_in (subtopology euclidean u) (IMAGE g k)
   
   [<a name="OPEN_MAP_IFF_LOWER_HEMICONTINUOUS_PREIMAGE-val"><b>OPEN_MAP_IFF_LOWER_HEMICONTINUOUS_PREIMAGE</b></a>]  Theorem
      
       f s t.
          IMAGE f s  t 
          ((u. open_in (subtopology euclidean s) u 
                open_in (subtopology euclidean t) (IMAGE f u)) 
           u. closed_in (subtopology euclidean s) u 
               closed_in (subtopology euclidean t)
                 {y | y  t  {x | x  s  f x = y}  u})
   
   [<a name="OPEN_MAP_IMP_CLOSED_MAP-val"><b>OPEN_MAP_IMP_CLOSED_MAP</b></a>]  Theorem
      
       f s t.
          IMAGE f s = t 
          (u. open_in (subtopology euclidean s) u 
               open_in (subtopology euclidean t) (IMAGE f u)) 
          (u. closed_in (subtopology euclidean s) u 
               closed_in (subtopology euclidean s)
                 {x | x  s  f x  IMAGE f u}) 
          u. closed_in (subtopology euclidean s) u 
              closed_in (subtopology euclidean t) (IMAGE f u)
   
   [<a name="OPEN_MAP_IMP_QUOTIENT_MAP-val"><b>OPEN_MAP_IMP_QUOTIENT_MAP</b></a>]  Theorem
      
       f s.
          f continuous_on s 
          (t. open_in (subtopology euclidean s) t 
               open_in (subtopology euclidean (IMAGE f s)) (IMAGE f t)) 
          t. t  IMAGE f s 
              (open_in (subtopology euclidean s) {x | x  s  f x  t} 
               open_in (subtopology euclidean (IMAGE f s)) t)
   
   [<a name="OPEN_MAP_INTERIORS-val"><b>OPEN_MAP_INTERIORS</b></a>]  Theorem
      
       f. (s. open s  open (IMAGE f s)) 
            s. IMAGE f (interior s)  interior (IMAGE f s)
   
   [<a name="OPEN_MAP_RESTRICT-val"><b>OPEN_MAP_RESTRICT</b></a>]  Theorem
      
       f s t t'.
          (u. open_in (subtopology euclidean s) u 
               open_in (subtopology euclidean t) (IMAGE f u))  t'  t 
          u. open_in (subtopology euclidean {x | x  s  f x  t'}) u 
              open_in (subtopology euclidean t') (IMAGE f u)
   
   [<a name="OPEN_NEGATIONS-val"><b>OPEN_NEGATIONS</b></a>]  Theorem
      
       s. open s  open (IMAGE (x. -x) s)
   
   [<a name="OPEN_OPEN_IN_TRANS-val"><b>OPEN_OPEN_IN_TRANS</b></a>]  Theorem
      
       s t. open s  open t  t  s  open_in (subtopology euclidean s) t
   
   [<a name="OPEN_POSITIVE_MULTIPLES-val"><b>OPEN_POSITIVE_MULTIPLES</b></a>]  Theorem
      
       s. open s  open {c * x | 0 &lt; c  x  s}
   
   [<a name="OPEN_POSITIVE_ORTHANT-val"><b>OPEN_POSITIVE_ORTHANT</b></a>]  Theorem
      
       open {x | 0 &lt; x}
   
   [<a name="OPEN_SCALING-val"><b>OPEN_SCALING</b></a>]  Theorem
      
       s c. c  0  open s  open (IMAGE (x. c * x) s)
   
   [<a name="OPEN_SEGMENT-val"><b>OPEN_SEGMENT</b></a>]  Theorem
      
       a b. open (segment (a,b))
   
   [<a name="OPEN_SEGMENT_ALT-val"><b>OPEN_SEGMENT_ALT</b></a>]  Theorem
      
       a b. a  b  segment (a,b) = {(1  u) * a + u * b | 0 &lt; u  u &lt; 1}
   
   [<a name="OPEN_SEGMENT_LINEAR_IMAGE-val"><b>OPEN_SEGMENT_LINEAR_IMAGE</b></a>]  Theorem
      
       f a b.
          linear f  (x y. f x = f y  x = y) 
          segment (f a,f b) = IMAGE f (segment (a,b))
   
   [<a name="OPEN_SUBSET-val"><b>OPEN_SUBSET</b></a>]  Theorem
      
       s t. s  t  open s  open_in (subtopology euclidean t) s
   
   [<a name="OPEN_SUBSET_INTERIOR-val"><b>OPEN_SUBSET_INTERIOR</b></a>]  Theorem
      
       s t. open s  (s  interior t  s  t)
   
   [<a name="OPEN_SUB_OPEN-val"><b>OPEN_SUB_OPEN</b></a>]  Theorem
      
       s. open s  x. x  s  t. open t  x  t  t  s
   
   [<a name="OPEN_SUMS-val"><b>OPEN_SUMS</b></a>]  Theorem
      
       s t. open s  open t  open {x + y | x  s  y  t}
   
   [<a name="OPEN_SURJECTIVE_LINEAR_IMAGE-val"><b>OPEN_SURJECTIVE_LINEAR_IMAGE</b></a>]  Theorem
      
       f. linear f  (y. x. f x = y)  s. open s  open (IMAGE f s)
   
   [<a name="OPEN_TRANSLATION-val"><b>OPEN_TRANSLATION</b></a>]  Theorem
      
       s a. open s  open (IMAGE (x. a + x) s)
   
   [<a name="OPEN_TRANSLATION_EQ-val"><b>OPEN_TRANSLATION_EQ</b></a>]  Theorem
      
       a s. open (IMAGE (x. a + x) s)  open s
   
   [<a name="OPEN_UNION-val"><b>OPEN_UNION</b></a>]  Theorem
      
       s t. open s  open t  open (s  t)
   
   [<a name="OPEN_UNION_COMPACT_SUBSETS-val"><b>OPEN_UNION_COMPACT_SUBSETS</b></a>]  Theorem
      
       s. open s 
            f. (n. compact (f n))  (n. f n  s) 
                (n. f n  interior (f (n + 1))) 
                BIGUNION {f n | n  (:num)} = s 
                k. compact k  k  s  N. n. n  N  k  f n
   
   [<a name="OPEN_UNIV-val"><b>OPEN_UNIV</b></a>]  Theorem
      
       open (:real)
   
   [<a name="PAIRWISE_DISJOINT_COMPONENTS-val"><b>PAIRWISE_DISJOINT_COMPONENTS</b></a>]  Theorem
      
       u. pairwiseD DISJOINT (components u)
   
   [<a name="PARTIAL_SUMS_COMPONENT_LE_INFSUM-val"><b>PARTIAL_SUMS_COMPONENT_LE_INFSUM</b></a>]  Theorem
      
       f s n.
          (i. i  s  0  f i)  summable s f 
          sum (s  {0 .. n}) f  suminf s f
   
   [<a name="PARTIAL_SUMS_DROP_LE_INFSUM-val"><b>PARTIAL_SUMS_DROP_LE_INFSUM</b></a>]  Theorem
      
       f s n.
          (i. i  s  0  f i)  summable s f 
          sum (s  {0 .. n}) f  suminf s f
   
   [<a name="PASTING_LEMMA-val"><b>PASTING_LEMMA</b></a>]  Theorem
      
       f g t s k.
          (i. i  k 
               open_in (subtopology euclidean s) (t i) 
               f i continuous_on t i) 
          (i j x. i  k  j  k  x  s  t i  t j  f i x = f j x) 
          (x. x  s  j. j  k  x  t j  g x = f j x) 
          g continuous_on s
   
   [<a name="PASTING_LEMMA_CLOSED-val"><b>PASTING_LEMMA_CLOSED</b></a>]  Theorem
      
       f g t s k.
          FINITE k 
          (i. i  k 
               closed_in (subtopology euclidean s) (t i) 
               f i continuous_on t i) 
          (i j x. i  k  j  k  x  s  t i  t j  f i x = f j x) 
          (x. x  s  j. j  k  x  t j  g x = f j x) 
          g continuous_on s
   
   [<a name="PASTING_LEMMA_EXISTS-val"><b>PASTING_LEMMA_EXISTS</b></a>]  Theorem
      
       f t s k.
          s  BIGUNION {t i | i  k} 
          (i. i  k 
               open_in (subtopology euclidean s) (t i) 
               f i continuous_on t i) 
          (i j x. i  k  j  k  x  s  t i  t j  f i x = f j x) 
          g. g continuous_on s  x i. i  k  x  s  t i  g x = f i x
   
   [<a name="PASTING_LEMMA_EXISTS_CLOSED-val"><b>PASTING_LEMMA_EXISTS_CLOSED</b></a>]  Theorem
      
       f t s k.
          FINITE k  s  BIGUNION {t i | i  k} 
          (i. i  k 
               closed_in (subtopology euclidean s) (t i) 
               f i continuous_on t i) 
          (i j x. i  k  j  k  x  s  t i  t j  f i x = f j x) 
          g. g continuous_on s  x i. i  k  x  s  t i  g x = f i x
   
   [<a name="PROPER_MAP-val"><b>PROPER_MAP</b></a>]  Theorem
      
       f s t.
          IMAGE f s  t 
          ((k. k  t  compact k  compact {x | x  s  f x  k}) 
           (k. closed_in (subtopology euclidean s) k 
                closed_in (subtopology euclidean t) (IMAGE f k)) 
           a. a  t  compact {x | x  s  f x = a})
   
   [<a name="PROPER_MAP_COMPOSE-val"><b>PROPER_MAP_COMPOSE</b></a>]  Theorem
      
       f g s t u.
          IMAGE f s  t 
          (k. k  t  compact k  compact {x | x  s  f x  k}) 
          (k. k  u  compact k  compact {x | x  t  g x  k}) 
          k. k  u  compact k  compact {x | x  s  (g  f) x  k}
   
   [<a name="PROPER_MAP_FROM_COMPACT-val"><b>PROPER_MAP_FROM_COMPACT</b></a>]  Theorem
      
       f s k.
          f continuous_on s  IMAGE f s  t  compact s 
          closed_in (subtopology euclidean t) k 
          compact {x | x  s  f x  k}
   
   [<a name="PROPER_MAP_FROM_COMPOSITION_LEFT-val"><b>PROPER_MAP_FROM_COMPOSITION_LEFT</b></a>]  Theorem
      
       f g s t u.
          f continuous_on s  IMAGE f s = t  g continuous_on t 
          IMAGE g t  u 
          (k. k  u  compact k  compact {x | x  s  (g  f) x  k}) 
          k. k  u  compact k  compact {x | x  t  g x  k}
   
   [<a name="PROPER_MAP_FROM_COMPOSITION_RIGHT-val"><b>PROPER_MAP_FROM_COMPOSITION_RIGHT</b></a>]  Theorem
      
       f g s t u.
          f continuous_on s  IMAGE f s  t  g continuous_on t 
          IMAGE g t  u 
          (k. k  u  compact k  compact {x | x  s  (g  f) x  k}) 
          k. k  t  compact k  compact {x | x  s  f x  k}
   
   [<a name="QUASICOMPACT_OPEN_CLOSED-val"><b>QUASICOMPACT_OPEN_CLOSED</b></a>]  Theorem
      
       f s t.
          IMAGE f s  t 
          ((u. u  t 
                open_in (subtopology euclidean s) {x | x  s  f x  u} 
                open_in (subtopology euclidean t) u) 
           u. u  t 
               closed_in (subtopology euclidean s) {x | x  s  f x  u} 
               closed_in (subtopology euclidean t) u)
   
   [<a name="QUOTIENT_MAP_CLOSED_MAP_EQ-val"><b>QUOTIENT_MAP_CLOSED_MAP_EQ</b></a>]  Theorem
      
       f s t.
          IMAGE f s  t 
          (u. u  t 
               (open_in (subtopology euclidean s) {x | x  s  f x  u} 
                open_in (subtopology euclidean t) u)) 
          ((k. closed_in (subtopology euclidean s) k 
                closed_in (subtopology euclidean t) (IMAGE f k)) 
           k. closed_in (subtopology euclidean s) k 
               closed_in (subtopology euclidean s)
                 {x | x  s  f x  IMAGE f k})
   
   [<a name="QUOTIENT_MAP_COMPOSE-val"><b>QUOTIENT_MAP_COMPOSE</b></a>]  Theorem
      
       f g s t u.
          IMAGE f s  t 
          (v. v  t 
               (open_in (subtopology euclidean s) {x | x  s  f x  v} 
                open_in (subtopology euclidean t) v)) 
          (v. v  u 
               (open_in (subtopology euclidean t) {x | x  t  g x  v} 
                open_in (subtopology euclidean u) v)) 
          v. v  u 
              (open_in (subtopology euclidean s)
                 {x | x  s  (g  f) x  v} 
               open_in (subtopology euclidean u) v)
   
   [<a name="QUOTIENT_MAP_FROM_COMPOSITION-val"><b>QUOTIENT_MAP_FROM_COMPOSITION</b></a>]  Theorem
      
       f g s t u.
          f continuous_on s  IMAGE f s  t  g continuous_on t 
          IMAGE g t  u 
          (v. v  u 
               (open_in (subtopology euclidean s)
                  {x | x  s  (g  f) x  v} 
                open_in (subtopology euclidean u) v)) 
          v. v  u 
              (open_in (subtopology euclidean t) {x | x  t  g x  v} 
               open_in (subtopology euclidean u) v)
   
   [<a name="QUOTIENT_MAP_FROM_SUBSET-val"><b>QUOTIENT_MAP_FROM_SUBSET</b></a>]  Theorem
      
       f s t u.
          f continuous_on t  IMAGE f t  u  s  t  IMAGE f s = u 
          (v. v  u 
               (open_in (subtopology euclidean s) {x | x  s  f x  v} 
                open_in (subtopology euclidean u) v)) 
          v. v  u 
              (open_in (subtopology euclidean t) {x | x  t  f x  v} 
               open_in (subtopology euclidean u) v)
   
   [<a name="QUOTIENT_MAP_IMP_CONTINUOUS_CLOSED-val"><b>QUOTIENT_MAP_IMP_CONTINUOUS_CLOSED</b></a>]  Theorem
      
       f s t.
          IMAGE f s  t 
          (u. u  t 
               (closed_in (subtopology euclidean s) {x | x  s  f x  u} 
                closed_in (subtopology euclidean t) u)) 
          f continuous_on s
   
   [<a name="QUOTIENT_MAP_IMP_CONTINUOUS_OPEN-val"><b>QUOTIENT_MAP_IMP_CONTINUOUS_OPEN</b></a>]  Theorem
      
       f s t.
          IMAGE f s  t 
          (u. u  t 
               (open_in (subtopology euclidean s) {x | x  s  f x  u} 
                open_in (subtopology euclidean t) u)) 
          f continuous_on s
   
   [<a name="QUOTIENT_MAP_OPEN_CLOSED-val"><b>QUOTIENT_MAP_OPEN_CLOSED</b></a>]  Theorem
      
       f s t.
          IMAGE f s  t 
          ((u. u  t 
                (open_in (subtopology euclidean s) {x | x  s  f x  u} 
                 open_in (subtopology euclidean t) u)) 
           u. u  t 
               (closed_in (subtopology euclidean s) {x | x  s  f x  u} 
                closed_in (subtopology euclidean t) u))
   
   [<a name="QUOTIENT_MAP_OPEN_MAP_EQ-val"><b>QUOTIENT_MAP_OPEN_MAP_EQ</b></a>]  Theorem
      
       f s t.
          IMAGE f s  t 
          (u. u  t 
               (open_in (subtopology euclidean s) {x | x  s  f x  u} 
                open_in (subtopology euclidean t) u)) 
          ((k. open_in (subtopology euclidean s) k 
                open_in (subtopology euclidean t) (IMAGE f k)) 
           k. open_in (subtopology euclidean s) k 
               open_in (subtopology euclidean s)
                 {x | x  s  f x  IMAGE f k})
   
   [<a name="QUOTIENT_MAP_RESTRICT-val"><b>QUOTIENT_MAP_RESTRICT</b></a>]  Theorem
      
       f s t c.
          IMAGE f s  t 
          (u. u  t 
               (open_in (subtopology euclidean s) {x | x  s  f x  u} 
                open_in (subtopology euclidean t) u)) 
          (open_in (subtopology euclidean t) c 
           closed_in (subtopology euclidean t) c) 
          u. u  c 
              (open_in (subtopology euclidean {x | x  s  f x  c})
                 {x | x  {x | x  s  f x  c}  f x  u} 
               open_in (subtopology euclidean c) u)
   
   [<a name="REAL_AFFINITY_EQ-val"><b>REAL_AFFINITY_EQ</b></a>]  Theorem
      
       m c x y. m  0  (m * x + c = y  x = m * y + -(c / m))
   
   [<a name="REAL_AFFINITY_LE-val"><b>REAL_AFFINITY_LE</b></a>]  Theorem
      
       m c x y. 0 &lt; m  (m * x + c  y  x  m * y + -(c / m))
   
   [<a name="REAL_AFFINITY_LT-val"><b>REAL_AFFINITY_LT</b></a>]  Theorem
      
       m c x y. 0 &lt; m  (m * x + c &lt; y  x &lt; m * y + -(c / m))
   
   [<a name="REAL_ARCH_RDIV_EQ_0-val"><b>REAL_ARCH_RDIV_EQ_0</b></a>]  Theorem
      
       x c. 0  x  0  c  (m. 0 &lt; m  &m * x  c)  x = 0
   
   [<a name="REAL_CHOOSE_DIST-val"><b>REAL_CHOOSE_DIST</b></a>]  Theorem
      
       x e. 0  e  y. dist (x,y) = e
   
   [<a name="REAL_CHOOSE_SIZE-val"><b>REAL_CHOOSE_SIZE</b></a>]  Theorem
      
       c. 0  c  x. abs x = c
   
   [<a name="REAL_CONVEX_BOUND_LE-val"><b>REAL_CONVEX_BOUND_LE</b></a>]  Theorem
      
       x y a u v.
          x  a  y  a  0  u  0  v  u + v = 1  u * x + v * y  a
   
   [<a name="REAL_EQ_AFFINITY-val"><b>REAL_EQ_AFFINITY</b></a>]  Theorem
      
       m c x y. m  0  (y = m * x + c  m * y + -(c / m) = x)
   
   [<a name="REAL_EQ_LINV-val"><b>REAL_EQ_LINV</b></a>]  Theorem
      
       x. -x = x  x = 0
   
   [<a name="REAL_EQ_RINV-val"><b>REAL_EQ_RINV</b></a>]  Theorem
      
       x. x = -x  x = 0
   
   [<a name="REAL_HAUSDIST_LE-val"><b>REAL_HAUSDIST_LE</b></a>]  Theorem
      
       s t b.
          s    t    (x. x  s  setdist ({x},t)  b) 
          (y. y  t  setdist ({y},s)  b) 
          hausdist (s,t)  b
   
   [<a name="REAL_HAUSDIST_LE_EQ-val"><b>REAL_HAUSDIST_LE_EQ</b></a>]  Theorem
      
       s t b.
          s    t    bounded s  bounded t 
          (hausdist (s,t)  b 
           (x. x  s  setdist ({x},t)  b) 
           y. y  t  setdist ({y},s)  b)
   
   [<a name="REAL_HAUSDIST_LE_SUMS-val"><b>REAL_HAUSDIST_LE_SUMS</b></a>]  Theorem
      
       s t b.
          s    t    s  {y + z | y  t  z  cball (0,b)} 
          t  {y + z | y  s  z  cball (0,b)} 
          hausdist (s,t)  b
   
   [<a name="REAL_LE_AFFINITY-val"><b>REAL_LE_AFFINITY</b></a>]  Theorem
      
       m c x y. 0 &lt; m  (y  m * x + c  m * y + -(c / m)  x)
   
   [<a name="REAL_LE_HAUSDIST-val"><b>REAL_LE_HAUSDIST</b></a>]  Theorem
      
       s t a b c z.
          s    t    (x. x  s  setdist ({x},t)  b) 
          (y. y  t  setdist ({y},s)  c) 
          (z  s  a  setdist ({z},t)  z  t  a  setdist ({z},s)) 
          a  hausdist (s,t)
   
   [<a name="REAL_LE_SETDIST-val"><b>REAL_LE_SETDIST</b></a>]  Theorem
      
       s t d.
          s    t    (x y. x  s  y  t  d  dist (x,y)) 
          d  setdist (s,t)
   
   [<a name="REAL_LE_SETDIST_EQ-val"><b>REAL_LE_SETDIST_EQ</b></a>]  Theorem
      
       d s t.
          d  setdist (s,t) 
          (x y. x  s  y  t  d  dist (x,y))  (s =   t =   d  0)
   
   [<a name="REAL_LT_AFFINITY-val"><b>REAL_LT_AFFINITY</b></a>]  Theorem
      
       m c x y. 0 &lt; m  (y &lt; m * x + c  m * y + -(c / m) &lt; x)
   
   [<a name="REAL_LT_HAUSDIST_POINT_EXISTS-val"><b>REAL_LT_HAUSDIST_POINT_EXISTS</b></a>]  Theorem
      
       s t x d.
          bounded s  bounded t  t    hausdist (s,t) &lt; d  x  s 
          y. y  t  dist (x,y) &lt; d
   
   [<a name="REAL_SETDIST_LT_EXISTS-val"><b>REAL_SETDIST_LT_EXISTS</b></a>]  Theorem
      
       s t b.
          s    t    setdist (s,t) &lt; b 
          x y. x  s  y  t  dist (x,y) &lt; b
   
   [<a name="REFLECT_INTERVAL-val"><b>REFLECT_INTERVAL</b></a>]  Theorem
      
       (a b. IMAGE (x. -x) (interval [(a,b)]) = interval [(-b,-a)]) 
        a b. IMAGE (x. -x) (interval (a,b)) = interval (-b,-a)
   
   [<a name="REGULAR_CLOSED_BIGUNION-val"><b>REGULAR_CLOSED_BIGUNION</b></a>]  Theorem
      
       f. FINITE f  (t. t  f  closure (interior t) = t) 
            closure (interior (BIGUNION f)) = BIGUNION f
   
   [<a name="REGULAR_CLOSED_UNION-val"><b>REGULAR_CLOSED_UNION</b></a>]  Theorem
      
       s t.
          closure (interior s) = s  closure (interior t) = t 
          closure (interior (s  t)) = s  t
   
   [<a name="REGULAR_OPEN_INTER-val"><b>REGULAR_OPEN_INTER</b></a>]  Theorem
      
       s t.
          interior (closure s) = s  interior (closure t) = t 
          interior (closure (s  t)) = s  t
   
   [<a name="SEGMENT-val"><b>SEGMENT</b></a>]  Theorem
      
       (a b.
           segment [(a,b)] =
           if a  b then interval [(a,b)] else interval [(b,a)]) 
        a b.
          segment (a,b) = if a  b then interval (a,b) else interval (b,a)
   
   [<a name="SEGMENT_CLOSED_OPEN-val"><b>SEGMENT_CLOSED_OPEN</b></a>]  Theorem
      
       a b. segment [(a,b)] = segment (a,b)  {a; b}
   
   [<a name="SEGMENT_OPEN_SUBSET_CLOSED-val"><b>SEGMENT_OPEN_SUBSET_CLOSED</b></a>]  Theorem
      
       a b. segment (a,b)  segment [(a,b)]
   
   [<a name="SEGMENT_REFL-val"><b>SEGMENT_REFL</b></a>]  Theorem
      
       (a. segment [(a,a)] = {a})  a. segment (a,a) = 
   
   [<a name="SEGMENT_SCALAR_MULTIPLE-val"><b>SEGMENT_SCALAR_MULTIPLE</b></a>]  Theorem
      
       (a b v.
           segment [(a * v,b * v)] =
           {x * v | a  x  x  b  b  x  x  a}) 
        a b v.
          v  0 
          segment (a * v,b * v) = {x * v | a &lt; x  x &lt; b  b &lt; x  x &lt; a}
   
   [<a name="SEGMENT_SYM-val"><b>SEGMENT_SYM</b></a>]  Theorem
      
       (a b. segment [(a,b)] = segment [(b,a)]) 
        a b. segment (a,b) = segment (b,a)
   
   [<a name="SEGMENT_TO_CLOSEST_POINT-val"><b>SEGMENT_TO_CLOSEST_POINT</b></a>]  Theorem
      
       s a. closed s  s    segment (a,closest_point s a)  s = 
   
   [<a name="SEGMENT_TO_POINT_EXISTS-val"><b>SEGMENT_TO_POINT_EXISTS</b></a>]  Theorem
      
       s a. closed s  s    b. b  s  segment (a,b)  s = 
   
   [<a name="SEGMENT_TRANSLATION-val"><b>SEGMENT_TRANSLATION</b></a>]  Theorem
      
       (c a b.
           segment [(c + a,c + b)] = IMAGE (x. c + x) (segment [(a,b)])) 
        c a b. segment (c + a,c + b) = IMAGE (x. c + x) (segment (a,b))
   
   [<a name="SEPARATE_CLOSED_COMPACT-val"><b>SEPARATE_CLOSED_COMPACT</b></a>]  Theorem
      
       s t.
          closed s  compact t  s  t =  
          d. 0 &lt; d  x y. x  s  y  t  d  dist (x,y)
   
   [<a name="SEPARATE_COMPACT_CLOSED-val"><b>SEPARATE_COMPACT_CLOSED</b></a>]  Theorem
      
       s t.
          compact s  closed t  s  t =  
          d. 0 &lt; d  x y. x  s  y  t  d  dist (x,y)
   
   [<a name="SEPARATE_POINT_CLOSED-val"><b>SEPARATE_POINT_CLOSED</b></a>]  Theorem
      
       s a. closed s  a  s  d. 0 &lt; d  x. x  s  d  dist (a,x)
   
   [<a name="SEPARATION_CLOSURES-val"><b>SEPARATION_CLOSURES</b></a>]  Theorem
      
       s t.
          s  closure t =   t  closure s =  
          u v. DISJOINT u v  open u  open v  s  u  t  v
   
   [<a name="SEPARATION_HAUSDORFF-val"><b>SEPARATION_HAUSDORFF</b></a>]  Theorem
      
       x y. x  y  u v. open u  open v  x  u  y  v  u  v = 
   
   [<a name="SEPARATION_NORMAL-val"><b>SEPARATION_NORMAL</b></a>]  Theorem
      
       s t.
          closed s  closed t  s  t =  
          u v. open u  open v  s  u  t  v  u  v = 
   
   [<a name="SEPARATION_NORMAL_COMPACT-val"><b>SEPARATION_NORMAL_COMPACT</b></a>]  Theorem
      
       s t.
          compact s  closed t  s  t =  
          u v.
            open u  compact (closure u)  open v  s  u  t  v 
            u  v = 
   
   [<a name="SEPARATION_NORMAL_LOCAL-val"><b>SEPARATION_NORMAL_LOCAL</b></a>]  Theorem
      
       s t u.
          closed_in (subtopology euclidean u) s 
          closed_in (subtopology euclidean u) t  s  t =  
          s' t'.
            open_in (subtopology euclidean u) s' 
            open_in (subtopology euclidean u) t'  s  s'  t  t' 
            s'  t' = 
   
   [<a name="SEPARATION_T0-val"><b>SEPARATION_T0</b></a>]  Theorem
      
       x y. x  y  u. open u  (x  u  y  u)
   
   [<a name="SEPARATION_T1-val"><b>SEPARATION_T1</b></a>]  Theorem
      
       x y. x  y  u v. open u  open v  x  u  y  u  x  v  y  v
   
   [<a name="SEPARATION_T2-val"><b>SEPARATION_T2</b></a>]  Theorem
      
       x y. x  y  u v. open u  open v  x  u  y  v  u  v = 
   
   [<a name="SEQUENCE_CAUCHY_WLOG-val"><b>SEQUENCE_CAUCHY_WLOG</b></a>]  Theorem
      
       P s.
          (m n. P m  P n  dist (s m,s n) &lt; e) 
          m n. P m  P n  m  n  dist (s m,s n) &lt; e
   
   [<a name="SEQUENCE_INFINITE_LEMMA-val"><b>SEQUENCE_INFINITE_LEMMA</b></a>]  Theorem
      
       f l.
          (n. f n  l)  (f  l) sequentially 
          INFINITE {y | (n. y = f n)}
   
   [<a name="SEQUENCE_UNIQUE_LIMPT-val"><b>SEQUENCE_UNIQUE_LIMPT</b></a>]  Theorem
      
       f l l'.
          (f  l) sequentially  l' limit_point_of {y | n. y = f n} 
          l' = l
   
   [<a name="SEQUENTIALLY-val"><b>SEQUENTIALLY</b></a>]  Theorem
      
       m n. netord sequentially m n  m  n
   
   [<a name="SEQ_HARMONIC-val"><b>SEQ_HARMONIC</b></a>]  Theorem
      
       ((n. (&n))  0) sequentially
   
   [<a name="SEQ_HARMONIC_OFFSET-val"><b>SEQ_HARMONIC_OFFSET</b></a>]  Theorem
      
       a. ((n. (&n + a))  0) sequentially
   
   [<a name="SEQ_OFFSET-val"><b>SEQ_OFFSET</b></a>]  Theorem
      
       f l k. (f  l) sequentially  ((i. f (i + k))  l) sequentially
   
   [<a name="SEQ_OFFSET_NEG-val"><b>SEQ_OFFSET_NEG</b></a>]  Theorem
      
       f l k. (f  l) sequentially  ((i. f (i  k))  l) sequentially
   
   [<a name="SEQ_OFFSET_REV-val"><b>SEQ_OFFSET_REV</b></a>]  Theorem
      
       f l k. ((i. f (i + k))  l) sequentially  (f  l) sequentially
   
   [<a name="SERIES_0-val"><b>SERIES_0</b></a>]  Theorem
      
       s. ((n. 0) sums 0) s
   
   [<a name="SERIES_ABSCONV_IMP_CONV-val"><b>SERIES_ABSCONV_IMP_CONV</b></a>]  Theorem
      
       x k. summable k (n. abs (x n))  summable k x
   
   [<a name="SERIES_ADD-val"><b>SERIES_ADD</b></a>]  Theorem
      
       x x0 y y0 s.
          (x sums x0) s  (y sums y0) s  ((n. x n + y n) sums x0 + y0) s
   
   [<a name="SERIES_BOUND-val"><b>SERIES_BOUND</b></a>]  Theorem
      
       f g s a b.
          (f sums a) s  (g sums b) s  (i. i  s  abs (f i)  g i) 
          abs a  b
   
   [<a name="SERIES_CAUCHY-val"><b>SERIES_CAUCHY</b></a>]  Theorem
      
       f s.
          (l. (f sums l) s) 
          e. 0 &lt; e  N. m n. m  N  abs (sum (s  {m .. n}) f) &lt; e
   
   [<a name="SERIES_CAUCHY_UNIFORM-val"><b>SERIES_CAUCHY_UNIFORM</b></a>]  Theorem
      
       P f k.
          (l. e.
             0 &lt; e 
             N. n x.
               N  n  P x  dist (sum (k  {0 .. n}) (f x),l x) &lt; e) 
          e. 0 &lt; e 
              N. m n x. N  m  P x  abs (sum (k  {m .. n}) (f x)) &lt; e
   
   [<a name="SERIES_CMUL-val"><b>SERIES_CMUL</b></a>]  Theorem
      
       x x0 c s. (x sums x0) s  ((n. c * x n) sums c * x0) s
   
   [<a name="SERIES_COMPARISON-val"><b>SERIES_COMPARISON</b></a>]  Theorem
      
       f g s.
          (l. (g sums l) s)  (N. n. n  N  n  s  abs (f n)  g n) 
          l. (f sums l) s
   
   [<a name="SERIES_COMPARISON_BOUND-val"><b>SERIES_COMPARISON_BOUND</b></a>]  Theorem
      
       f g s a.
          (g sums a) s  (i. i  s  abs (f i)  g i) 
          l. (f sums l) s  abs l  a
   
   [<a name="SERIES_COMPARISON_UNIFORM-val"><b>SERIES_COMPARISON_UNIFORM</b></a>]  Theorem
      
       f g P s.
          (l. (g sums l) s) 
          (N. n x. N  n  n  s  P x  abs (f x n)  g n) 
          l. e.
            0 &lt; e 
            N. n x. N  n  P x  dist (sum (s  {0 .. n}) (f x),l x) &lt; e
   
   [<a name="SERIES_COMPONENT-val"><b>SERIES_COMPONENT</b></a>]  Theorem
      
       f s l. (f sums l) s  ((i. f i) sums l) s
   
   [<a name="SERIES_DIFFS-val"><b>SERIES_DIFFS</b></a>]  Theorem
      
       f k.
          (f  0) sequentially  ((n. f n  f (n + 1)) sums f k) (from k)
   
   [<a name="SERIES_DIRICHLET-val"><b>SERIES_DIRICHLET</b></a>]  Theorem
      
       f g N k m.
          bounded {sum {m .. n} f | n  (:num)} 
          (n. N  n  g (n + 1)  g n)  (g  0) sequentially 
          summable (from k) (n. g n * f n)
   
   [<a name="SERIES_DIRICHLET_BILINEAR-val"><b>SERIES_DIRICHLET_BILINEAR</b></a>]  Theorem
      
       f g h k m p l.
          bilinear h  bounded {sum {m .. n} f | n  (:num)} 
          summable (from p) (n. abs (g (n + 1)  g n)) 
          ((n. h (g (n + 1)) (sum {1 .. n} f))  l) sequentially 
          summable (from k) (n. h (g n) (f n))
   
   [<a name="SERIES_DROP_LE-val"><b>SERIES_DROP_LE</b></a>]  Theorem
      
       f g s a b.
          (f sums a) s  (g sums b) s  (x. x  s  f x  g x)  a  b
   
   [<a name="SERIES_DROP_POS-val"><b>SERIES_DROP_POS</b></a>]  Theorem
      
       f s a. (f sums a) s  (x. x  s  0  f x)  0  a
   
   [<a name="SERIES_FINITE-val"><b>SERIES_FINITE</b></a>]  Theorem
      
       f s. FINITE s  (f sums sum s f) s
   
   [<a name="SERIES_FINITE_SUPPORT-val"><b>SERIES_FINITE_SUPPORT</b></a>]  Theorem
      
       f s k.
          FINITE (s  k)  (x. x  k  x  s  f x = 0) 
          (f sums sum (s  k) f) k
   
   [<a name="SERIES_FROM-val"><b>SERIES_FROM</b></a>]  Theorem
      
       f l k.
          (f sums l) (from k)  ((n. sum {k .. n} f)  l) sequentially
   
   [<a name="SERIES_GOESTOZERO-val"><b>SERIES_GOESTOZERO</b></a>]  Theorem
      
       s x.
          summable s x 
          e. 0 &lt; e  eventually (n. n  s  abs (x n) &lt; e) sequentially
   
   [<a name="SERIES_INJECTIVE_IMAGE-val"><b>SERIES_INJECTIVE_IMAGE</b></a>]  Theorem
      
       x s f l.
          summable (IMAGE f s) (n. abs (x n)) 
          (m n. m  s  n  s  f m = f n  m = n) 
          ((x  f sums l) s  (x sums l) (IMAGE f s))
   
   [<a name="SERIES_INJECTIVE_IMAGE_STRONG-val"><b>SERIES_INJECTIVE_IMAGE_STRONG</b></a>]  Theorem
      
       x s f.
          summable (IMAGE f s) (n. abs (x n)) 
          (m n. m  s  n  s  f m = f n  m = n) 
          ((n. sum (IMAGE f s  {0 .. n}) x  sum (s  {0 .. n}) (x  f)) 
           0) sequentially
   
   [<a name="SERIES_LINEAR-val"><b>SERIES_LINEAR</b></a>]  Theorem
      
       f h l s. (f sums l) s  linear h  ((n. h (f n)) sums h l) s
   
   [<a name="SERIES_NEG-val"><b>SERIES_NEG</b></a>]  Theorem
      
       x x0 s. (x sums x0) s  ((n. -x n) sums -x0) s
   
   [<a name="SERIES_RATIO-val"><b>SERIES_RATIO</b></a>]  Theorem
      
       c a s N.
          c &lt; 1  (n. n  N  abs (a (SUC n))  c * abs (a n)) 
          l. (a sums l) s
   
   [<a name="SERIES_REARRANGE-val"><b>SERIES_REARRANGE</b></a>]  Theorem
      
       x s p l.
          summable s (n. abs (x n))  p permutes s  (x sums l) s 
          (x  p sums l) s
   
   [<a name="SERIES_REARRANGE_EQ-val"><b>SERIES_REARRANGE_EQ</b></a>]  Theorem
      
       x s p l.
          summable s (n. abs (x n))  p permutes s 
          ((x  p sums l) s  (x sums l) s)
   
   [<a name="SERIES_RESTRICT-val"><b>SERIES_RESTRICT</b></a>]  Theorem
      
       f k l.
          ((n. if n  k then f n else 0) sums l) (:num)  (f sums l) k
   
   [<a name="SERIES_SUB-val"><b>SERIES_SUB</b></a>]  Theorem
      
       x x0 y y0 s.
          (x sums x0) s  (y sums y0) s  ((n. x n  y n) sums x0  y0) s
   
   [<a name="SERIES_SUBSET-val"><b>SERIES_SUBSET</b></a>]  Theorem
      
       x s t l.
          s  t  ((i. if i  s then x i else 0) sums l) t  (x sums l) s
   
   [<a name="SERIES_SUM-val"><b>SERIES_SUM</b></a>]  Theorem
      
       f l k s.
          FINITE s  s  k  (x. x  s  f x = 0)  sum s f = l 
          (f sums l) k
   
   [<a name="SERIES_TERMS_TOZERO-val"><b>SERIES_TERMS_TOZERO</b></a>]  Theorem
      
       f l n. (f sums l) (from n)  (f  0) sequentially
   
   [<a name="SERIES_TRIVIAL-val"><b>SERIES_TRIVIAL</b></a>]  Theorem
      
       f. (f sums 0) 
   
   [<a name="SERIES_UNIQUE-val"><b>SERIES_UNIQUE</b></a>]  Theorem
      
       f l l' s. (f sums l) s  (f sums l') s  l = l'
   
   [<a name="SETDIST_BALLS-val"><b>SETDIST_BALLS</b></a>]  Theorem
      
       (a b r s.
           setdist (ball (a,r),ball (b,s)) =
           if r  0  s  0 then 0 else max 0 (dist (a,b)  (r + s))) 
        (a b r s.
           setdist (ball (a,r),cball (b,s)) =
           if r  0  s &lt; 0 then 0 else max 0 (dist (a,b)  (r + s))) 
        (a b r s.
           setdist (cball (a,r),ball (b,s)) =
           if r &lt; 0  s  0 then 0 else max 0 (dist (a,b)  (r + s))) 
        a b r s.
          setdist (cball (a,r),cball (b,s)) =
          if r &lt; 0  s &lt; 0 then 0 else max 0 (dist (a,b)  (r + s))
   
   [<a name="SETDIST_CLOSED_COMPACT-val"><b>SETDIST_CLOSED_COMPACT</b></a>]  Theorem
      
       s t.
          closed s  compact t  s    t   
          x y. x  s  y  t  dist (x,y) = setdist (s,t)
   
   [<a name="SETDIST_CLOSEST_POINT-val"><b>SETDIST_CLOSEST_POINT</b></a>]  Theorem
      
       a s.
          closed s  s    setdist ({a},s) = dist (a,closest_point s a)
   
   [<a name="SETDIST_CLOSURE-val"><b>SETDIST_CLOSURE</b></a>]  Theorem
      
       (s t. setdist (closure s,t) = setdist (s,t)) 
        s t. setdist (s,closure t) = setdist (s,t)
   
   [<a name="SETDIST_COMPACT_CLOSED-val"><b>SETDIST_COMPACT_CLOSED</b></a>]  Theorem
      
       s t.
          compact s  closed t  s    t   
          x y. x  s  y  t  dist (x,y) = setdist (s,t)
   
   [<a name="SETDIST_DIFFERENCES-val"><b>SETDIST_DIFFERENCES</b></a>]  Theorem
      
       s t. setdist (s,t) = setdist ({0},{x  y | x  s  y  t})
   
   [<a name="SETDIST_EMPTY-val"><b>SETDIST_EMPTY</b></a>]  Theorem
      
       (t. setdist (,t) = 0)  s. setdist (s,) = 0
   
   [<a name="SETDIST_EQ_0_BOUNDED-val"><b>SETDIST_EQ_0_BOUNDED</b></a>]  Theorem
      
       s t.
          bounded s  bounded t 
          (setdist (s,t) = 0  s =   t =   closure s  closure t  )
   
   [<a name="SETDIST_EQ_0_CLOSED-val"><b>SETDIST_EQ_0_CLOSED</b></a>]  Theorem
      
       s x. closed s  (setdist ({x},s) = 0  s =   x  s)
   
   [<a name="SETDIST_EQ_0_CLOSED_COMPACT-val"><b>SETDIST_EQ_0_CLOSED_COMPACT</b></a>]  Theorem
      
       s t.
          closed s  compact t 
          (setdist (s,t) = 0  s =   t =   s  t  )
   
   [<a name="SETDIST_EQ_0_CLOSED_IN-val"><b>SETDIST_EQ_0_CLOSED_IN</b></a>]  Theorem
      
       u s x.
          closed_in (subtopology euclidean u) s  x  u 
          (setdist ({x},s) = 0  s =   x  s)
   
   [<a name="SETDIST_EQ_0_COMPACT_CLOSED-val"><b>SETDIST_EQ_0_COMPACT_CLOSED</b></a>]  Theorem
      
       s t.
          compact s  closed t 
          (setdist (s,t) = 0  s =   t =   s  t  )
   
   [<a name="SETDIST_EQ_0_SING-val"><b>SETDIST_EQ_0_SING</b></a>]  Theorem
      
       (s x. setdist ({x},s) = 0  s =   x  closure s) 
        s x. setdist (s,{x}) = 0  s =   x  closure s
   
   [<a name="SETDIST_FRONTIER-val"><b>SETDIST_FRONTIER</b></a>]  Theorem
      
       (s t. DISJOINT s t  setdist (frontier s,t) = setdist (s,t)) 
        s t. DISJOINT s t  setdist (s,frontier t) = setdist (s,t)
   
   [<a name="SETDIST_FRONTIERS-val"><b>SETDIST_FRONTIERS</b></a>]  Theorem
      
       s t.
          setdist (s,t) =
          if DISJOINT s t then setdist (frontier s,frontier t) else 0
   
   [<a name="SETDIST_HAUSDIST_TRIANGLE-val"><b>SETDIST_HAUSDIST_TRIANGLE</b></a>]  Theorem
      
       s t u.
          t    bounded t  bounded u 
          setdist (s,u)  setdist (s,t) + hausdist (t,u)
   
   [<a name="SETDIST_LE_DIST-val"><b>SETDIST_LE_DIST</b></a>]  Theorem
      
       s t x y. x  s  y  t  setdist (s,t)  dist (x,y)
   
   [<a name="SETDIST_LE_HAUSDIST-val"><b>SETDIST_LE_HAUSDIST</b></a>]  Theorem
      
       s t. bounded s  bounded t  setdist (s,t)  hausdist (s,t)
   
   [<a name="SETDIST_LE_SING-val"><b>SETDIST_LE_SING</b></a>]  Theorem
      
       s t x. x  s  setdist (s,t)  setdist ({x},t)
   
   [<a name="SETDIST_LINEAR_IMAGE-val"><b>SETDIST_LINEAR_IMAGE</b></a>]  Theorem
      
       f s t.
          linear f  (x. abs (f x) = abs x) 
          setdist (IMAGE f s,IMAGE f t) = setdist (s,t)
   
   [<a name="SETDIST_LIPSCHITZ-val"><b>SETDIST_LIPSCHITZ</b></a>]  Theorem
      
       s t x y. abs (setdist ({x},s)  setdist ({y},s))  dist (x,y)
   
   [<a name="SETDIST_POS_LE-val"><b>SETDIST_POS_LE</b></a>]  Theorem
      
       s t. 0  setdist (s,t)
   
   [<a name="SETDIST_REFL-val"><b>SETDIST_REFL</b></a>]  Theorem
      
       s. setdist (s,s) = 0
   
   [<a name="SETDIST_SINGS-val"><b>SETDIST_SINGS</b></a>]  Theorem
      
       x y. setdist ({x},{y}) = dist (x,y)
   
   [<a name="SETDIST_SING_FRONTIER-val"><b>SETDIST_SING_FRONTIER</b></a>]  Theorem
      
       s x. x  s  setdist ({x},frontier s) = setdist ({x},s)
   
   [<a name="SETDIST_SING_FRONTIER_CASES-val"><b>SETDIST_SING_FRONTIER_CASES</b></a>]  Theorem
      
       s x.
          setdist ({x},s) = if x  s then 0 else setdist ({x},frontier s)
   
   [<a name="SETDIST_SING_IN_SET-val"><b>SETDIST_SING_IN_SET</b></a>]  Theorem
      
       x s. x  s  setdist ({x},s) = 0
   
   [<a name="SETDIST_SING_LE_HAUSDIST-val"><b>SETDIST_SING_LE_HAUSDIST</b></a>]  Theorem
      
       s t x.
          bounded s  bounded t  x  s  setdist ({x},t)  hausdist (s,t)
   
   [<a name="SETDIST_SING_TRIANGLE-val"><b>SETDIST_SING_TRIANGLE</b></a>]  Theorem
      
       s x y. abs (setdist ({x},s)  setdist ({y},s))  dist (x,y)
   
   [<a name="SETDIST_SUBSETS_EQ-val"><b>SETDIST_SUBSETS_EQ</b></a>]  Theorem
      
       s t s' t'.
          s'  s  t'  t 
          (x y.
             x  s  y  t 
             x' y'. x'  s'  y'  t'  dist (x',y')  dist (x,y)) 
          setdist (s',t') = setdist (s,t)
   
   [<a name="SETDIST_SUBSET_LEFT-val"><b>SETDIST_SUBSET_LEFT</b></a>]  Theorem
      
       s t u. s    s  t  setdist (t,u)  setdist (s,u)
   
   [<a name="SETDIST_SUBSET_RIGHT-val"><b>SETDIST_SUBSET_RIGHT</b></a>]  Theorem
      
       s t u. t    t  u  setdist (s,u)  setdist (s,t)
   
   [<a name="SETDIST_SYM-val"><b>SETDIST_SYM</b></a>]  Theorem
      
       s t. setdist (s,t) = setdist (t,s)
   
   [<a name="SETDIST_TRANSLATION-val"><b>SETDIST_TRANSLATION</b></a>]  Theorem
      
       a s t.
          setdist (IMAGE (x. a + x) s,IMAGE (x. a + x) t) = setdist (s,t)
   
   [<a name="SETDIST_TRIANGLE-val"><b>SETDIST_TRIANGLE</b></a>]  Theorem
      
       s a t. setdist (s,t)  setdist (s,{a}) + setdist ({a},t)
   
   [<a name="SETDIST_UNIQUE-val"><b>SETDIST_UNIQUE</b></a>]  Theorem
      
       s t a b d.
          a  s  b  t  dist (a,b) = d 
          (x y. x  s  y  t  dist (a,b)  dist (x,y)) 
          setdist (s,t) = d
   
   [<a name="SETDIST_UNIV-val"><b>SETDIST_UNIV</b></a>]  Theorem
      
       (s. setdist (s,(:real)) = 0)  t. setdist ((:real),t) = 0
   
   [<a name="SETDIST_ZERO-val"><b>SETDIST_ZERO</b></a>]  Theorem
      
       s t. DISJOINT s t  setdist (s,t) = 0
   
   [<a name="SETDIST_ZERO_STRONG-val"><b>SETDIST_ZERO_STRONG</b></a>]  Theorem
      
       s t. DISJOINT (closure s) (closure t)  setdist (s,t) = 0
   
   [<a name="SET_DIFF_FRONTIER-val"><b>SET_DIFF_FRONTIER</b></a>]  Theorem
      
       s. s DIFF frontier s = interior s
   
   [<a name="SPANNING_SUBSET_INDEPENDENT-val"><b>SPANNING_SUBSET_INDEPENDENT</b></a>]  Theorem
      
       s t. t  s  independent s  s  span t  s = t
   
   [<a name="SPAN_0-val"><b>SPAN_0</b></a>]  Theorem
      
       0  span s
   
   [<a name="SPAN_ADD-val"><b>SPAN_ADD</b></a>]  Theorem
      
       x y s. x  span s  y  span s  x + y  span s
   
   [<a name="SPAN_ADD_EQ-val"><b>SPAN_ADD_EQ</b></a>]  Theorem
      
       s x y. x  span s  (x + y  span s  y  span s)
   
   [<a name="SPAN_BREAKDOWN-val"><b>SPAN_BREAKDOWN</b></a>]  Theorem
      
       b s a. b  s  a  span s  k. a  k * b  span (s DELETE b)
   
   [<a name="SPAN_BREAKDOWN_EQ-val"><b>SPAN_BREAKDOWN_EQ</b></a>]  Theorem
      
       a s. x  span (a INSERT s)  k. x  k * a  span s
   
   [<a name="SPAN_CARD_GE_DIM-val"><b>SPAN_CARD_GE_DIM</b></a>]  Theorem
      
       v b. v  span b  FINITE b  dim v  CARD b
   
   [<a name="SPAN_CLAUSES-val"><b>SPAN_CLAUSES</b></a>]  Theorem
      
       (a s. a  s  a  span s)  0  span s 
        (x y s. x  span s  y  span s  x + y  span s) 
        x c s. x  span s  c * x  span s
   
   [<a name="SPAN_EMPTY-val"><b>SPAN_EMPTY</b></a>]  Theorem
      
       span  = {0}
   
   [<a name="SPAN_EQ_SELF-val"><b>SPAN_EQ_SELF</b></a>]  Theorem
      
       s. span s = s  subspace s
   
   [<a name="SPAN_EXPLICIT-val"><b>SPAN_EXPLICIT</b></a>]  Theorem
      
       p. span p = {y | s u. FINITE s  s  p  sum s (v. u v * v) = y}
   
   [<a name="SPAN_INC-val"><b>SPAN_INC</b></a>]  Theorem
      
       s. s  span s
   
   [<a name="SPAN_INDUCT-val"><b>SPAN_INDUCT</b></a>]  Theorem
      
       s h. (x. x  s  x  h)  subspace h  x. x  span s  h x
   
   [<a name="SPAN_INDUCT_ALT-val"><b>SPAN_INDUCT_ALT</b></a>]  Theorem
      
       s h.
          h 0  (c x y. x  s  h y  h (c * x + y)) 
          x. x  span s  h x
   
   [<a name="SPAN_LINEAR_IMAGE-val"><b>SPAN_LINEAR_IMAGE</b></a>]  Theorem
      
       f s. linear f  span (IMAGE f s) = IMAGE f (span s)
   
   [<a name="SPAN_MONO-val"><b>SPAN_MONO</b></a>]  Theorem
      
       s t. s  t  span s  span t
   
   [<a name="SPAN_MUL-val"><b>SPAN_MUL</b></a>]  Theorem
      
       x c s. x  span s  c * x  span s
   
   [<a name="SPAN_MUL_EQ-val"><b>SPAN_MUL_EQ</b></a>]  Theorem
      
       x c s. c  0  (c * x  span s  x  span s)
   
   [<a name="SPAN_NEG-val"><b>SPAN_NEG</b></a>]  Theorem
      
       x s. x  span s  -x  span s
   
   [<a name="SPAN_NEG_EQ-val"><b>SPAN_NEG_EQ</b></a>]  Theorem
      
       x s. -x  span s  x  span s
   
   [<a name="SPAN_SPAN-val"><b>SPAN_SPAN</b></a>]  Theorem
      
       s. span (span s) = span s
   
   [<a name="SPAN_STDBASIS-val"><b>SPAN_STDBASIS</b></a>]  Theorem
      
       span {i | 1  i  i  1} = (:real)
   
   [<a name="SPAN_SUB-val"><b>SPAN_SUB</b></a>]  Theorem
      
       x y s. x  span s  y  span s  x  y  span s
   
   [<a name="SPAN_SUBSET_SUBSPACE-val"><b>SPAN_SUBSET_SUBSPACE</b></a>]  Theorem
      
       s t. s  t  subspace t  span s  t
   
   [<a name="SPAN_SUBSPACE-val"><b>SPAN_SUBSPACE</b></a>]  Theorem
      
       b s. b  s  s  span b  subspace s  span b = s
   
   [<a name="SPAN_SUM-val"><b>SPAN_SUM</b></a>]  Theorem
      
       s f t. FINITE t  (x. x  t  f x  span s)  sum t f  span s
   
   [<a name="SPAN_SUPERSET-val"><b>SPAN_SUPERSET</b></a>]  Theorem
      
       x. x  s  x  span s
   
   [<a name="SPAN_TRANS-val"><b>SPAN_TRANS</b></a>]  Theorem
      
       x y s. x  span s  y  span (x INSERT s)  y  span s
   
   [<a name="SPAN_UNION-val"><b>SPAN_UNION</b></a>]  Theorem
      
       s t. span (s  t) = {x + y | x  span s  y  span t}
   
   [<a name="SPAN_UNION_SUBSET-val"><b>SPAN_UNION_SUBSET</b></a>]  Theorem
      
       s t. span s  span t  span (s  t)
   
   [<a name="SPAN_UNIV-val"><b>SPAN_UNIV</b></a>]  Theorem
      
       span (:real) = (:real)
   
   [<a name="SPHERE-val"><b>SPHERE</b></a>]  Theorem
      
       a r. sphere (a,r) = if r &lt; 0 then  else {a  r; a + r}
   
   [<a name="SPHERE_EMPTY-val"><b>SPHERE_EMPTY</b></a>]  Theorem
      
       a r. r &lt; 0  sphere (a,r) = 
   
   [<a name="SPHERE_EQ_EMPTY-val"><b>SPHERE_EQ_EMPTY</b></a>]  Theorem
      
       a r. sphere (a,r) =   r &lt; 0
   
   [<a name="SPHERE_EQ_SING-val"><b>SPHERE_EQ_SING</b></a>]  Theorem
      
       a r x. sphere (a,r) = {x}  x = a  r = 0
   
   [<a name="SPHERE_LINEAR_IMAGE-val"><b>SPHERE_LINEAR_IMAGE</b></a>]  Theorem
      
       f x r.
          linear f  (y. x. f x = y)  (x. abs (f x) = abs x) 
          sphere (f x,r) = IMAGE f (sphere (x,r))
   
   [<a name="SPHERE_SING-val"><b>SPHERE_SING</b></a>]  Theorem
      
       x e. e = 0  sphere (x,e) = {x}
   
   [<a name="SPHERE_SUBSET_CBALL-val"><b>SPHERE_SUBSET_CBALL</b></a>]  Theorem
      
       x e. sphere (x,e)  cball (x,e)
   
   [<a name="SPHERE_TRANSLATION-val"><b>SPHERE_TRANSLATION</b></a>]  Theorem
      
       a x r. sphere (a + x,r) = IMAGE (y. a + y) (sphere (x,r))
   
   [<a name="SPHERE_UNION_BALL-val"><b>SPHERE_UNION_BALL</b></a>]  Theorem
      
       a r. sphere (a,r)  ball (a,r) = cball (a,r)
   
   [<a name="SUBORDINATE_PARTITION_OF_UNITY-val"><b>SUBORDINATE_PARTITION_OF_UNITY</b></a>]  Theorem
      
       c s.
          s  BIGUNION c  (u. u  c  open u) 
          (x. x  s  v. open v  x  v  FINITE {u | u  c  u  v  }) 
          f. (u. u  c  f u continuous_on s  x. x  s  0  f u x) 
              (x u. u  c  x  s  x  u  f u x = 0) 
              (x. x  s  sum c (u. f u x) = 1) 
              x. x  s 
                  n. open n  x  n 
                      FINITE {u | u  c  x. x  n  f u x = 0}
   
   [<a name="SUBSET_BALL-val"><b>SUBSET_BALL</b></a>]  Theorem
      
       x d e. d  e  ball (x,d)  ball (x,e)
   
   [<a name="SUBSET_BALLS-val"><b>SUBSET_BALLS</b></a>]  Theorem
      
       (a a' r r'.
           ball (a,r)  ball (a',r')  dist (a,a') + r  r'  r  0) 
        (a a' r r'.
           ball (a,r)  cball (a',r')  dist (a,a') + r  r'  r  0) 
        (a a' r r'.
           cball (a,r)  ball (a',r')  dist (a,a') + r &lt; r'  r &lt; 0) 
        a a' r r'.
          cball (a,r)  cball (a',r')  dist (a,a') + r  r'  r &lt; 0
   
   [<a name="SUBSET_CBALL-val"><b>SUBSET_CBALL</b></a>]  Theorem
      
       x d e. d  e  cball (x,d)  cball (x,e)
   
   [<a name="SUBSET_CLOSURE-val"><b>SUBSET_CLOSURE</b></a>]  Theorem
      
       s t. s  t  closure s  closure t
   
   [<a name="SUBSET_INTERIOR-val"><b>SUBSET_INTERIOR</b></a>]  Theorem
      
       s t. s  t  interior s  interior t
   
   [<a name="SUBSET_INTERIOR_EQ-val"><b>SUBSET_INTERIOR_EQ</b></a>]  Theorem
      
       s. s  interior s  open s
   
   [<a name="SUBSET_INTERVAL-val"><b>SUBSET_INTERVAL</b></a>]  Theorem
      
       (interval [(c,d)]  interval [(a,b)]  c  d  a  c  d  b) 
        (interval [(c,d)]  interval (a,b)  c  d  a &lt; c  d &lt; b) 
        (interval (c,d)  interval [(a,b)]  c &lt; d  a  c  d  b) 
        (interval (c,d)  interval (a,b)  c &lt; d  a  c  d  b)
   
   [<a name="SUBSET_INTERVAL_IMP-val"><b>SUBSET_INTERVAL_IMP</b></a>]  Theorem
      
       (a  c  d  b  interval [(c,d)]  interval [(a,b)]) 
        (a &lt; c  d &lt; b  interval [(c,d)]  interval (a,b)) 
        (a  c  d  b  interval (c,d)  interval [(a,b)]) 
        (a  c  d  b  interval (c,d)  interval (a,b))
   
   [<a name="SUBSPACE_0-val"><b>SUBSPACE_0</b></a>]  Theorem
      
       subspace s  0  s
   
   [<a name="SUBSPACE_ADD-val"><b>SUBSPACE_ADD</b></a>]  Theorem
      
       x y s. subspace s  x  s  y  s  x + y  s
   
   [<a name="SUBSPACE_BIGINTER-val"><b>SUBSPACE_BIGINTER</b></a>]  Theorem
      
       f. (s. s  f  subspace s)  subspace (BIGINTER f)
   
   [<a name="SUBSPACE_BOUNDED_EQ_TRIVIAL-val"><b>SUBSPACE_BOUNDED_EQ_TRIVIAL</b></a>]  Theorem
      
       s. subspace s  (bounded s  s = {0})
   
   [<a name="SUBSPACE_IMP_NONEMPTY-val"><b>SUBSPACE_IMP_NONEMPTY</b></a>]  Theorem
      
       s. subspace s  s  
   
   [<a name="SUBSPACE_INTER-val"><b>SUBSPACE_INTER</b></a>]  Theorem
      
       s t. subspace s  subspace t  subspace (s  t)
   
   [<a name="SUBSPACE_KERNEL-val"><b>SUBSPACE_KERNEL</b></a>]  Theorem
      
       f. linear f  subspace {x | f x = 0}
   
   [<a name="SUBSPACE_LINEAR_IMAGE-val"><b>SUBSPACE_LINEAR_IMAGE</b></a>]  Theorem
      
       f s. linear f  subspace s  subspace (IMAGE f s)
   
   [<a name="SUBSPACE_LINEAR_PREIMAGE-val"><b>SUBSPACE_LINEAR_PREIMAGE</b></a>]  Theorem
      
       f s. linear f  subspace s  subspace {x | f x  s}
   
   [<a name="SUBSPACE_MUL-val"><b>SUBSPACE_MUL</b></a>]  Theorem
      
       x c s. subspace s  x  s  c * x  s
   
   [<a name="SUBSPACE_NEG-val"><b>SUBSPACE_NEG</b></a>]  Theorem
      
       x s. subspace s  x  s  -x  s
   
   [<a name="SUBSPACE_SPAN-val"><b>SUBSPACE_SPAN</b></a>]  Theorem
      
       s. subspace (span s)
   
   [<a name="SUBSPACE_SUB-val"><b>SUBSPACE_SUB</b></a>]  Theorem
      
       x y s. subspace s  x  s  y  s  x  y  s
   
   [<a name="SUBSPACE_SUBSTANDARD-val"><b>SUBSPACE_SUBSTANDARD</b></a>]  Theorem
      
       subspace {x | x = 0}
   
   [<a name="SUBSPACE_SUM-val"><b>SUBSPACE_SUM</b></a>]  Theorem
      
       s f t. subspace s  FINITE t  (x. x  t  f x  s)  sum t f  s
   
   [<a name="SUBSPACE_SUMS-val"><b>SUBSPACE_SUMS</b></a>]  Theorem
      
       s t. subspace s  subspace t  subspace {x + y | x  s  y  t}
   
   [<a name="SUBSPACE_TRANSLATION_SELF-val"><b>SUBSPACE_TRANSLATION_SELF</b></a>]  Theorem
      
       s a. subspace s  a  s  IMAGE (x. a + x) s = s
   
   [<a name="SUBSPACE_TRANSLATION_SELF_EQ-val"><b>SUBSPACE_TRANSLATION_SELF_EQ</b></a>]  Theorem
      
       s a. subspace s  (IMAGE (x. a + x) s = s  a  s)
   
   [<a name="SUBSPACE_TRIVIAL-val"><b>SUBSPACE_TRIVIAL</b></a>]  Theorem
      
       subspace {0}
   
   [<a name="SUBSPACE_UNION_CHAIN-val"><b>SUBSPACE_UNION_CHAIN</b></a>]  Theorem
      
       s t. subspace s  subspace t  subspace (s  t)  s  t  t  s
   
   [<a name="SUBSPACE_UNIV-val"><b>SUBSPACE_UNIV</b></a>]  Theorem
      
       subspace (:real)
   
   [<a name="SUMMABLE_0-val"><b>SUMMABLE_0</b></a>]  Theorem
      
       s. summable s (n. 0)
   
   [<a name="SUMMABLE_ADD-val"><b>SUMMABLE_ADD</b></a>]  Theorem
      
       x y s. summable s x  summable s y  summable s (n. x n + y n)
   
   [<a name="SUMMABLE_BILINEAR_PARTIAL_PRE-val"><b>SUMMABLE_BILINEAR_PARTIAL_PRE</b></a>]  Theorem
      
       f g h l k.
          bilinear h  ((n. h (f (n + 1)) (g n))  l) sequentially 
          summable (from k) (n. h (f (n + 1)  f n) (g n)) 
          summable (from k) (n. h (f n) (g n  g (n  1)))
   
   [<a name="SUMMABLE_CAUCHY-val"><b>SUMMABLE_CAUCHY</b></a>]  Theorem
      
       f s.
          summable s f 
          e. 0 &lt; e  N. m n. m  N  abs (sum (s  {m .. n}) f) &lt; e
   
   [<a name="SUMMABLE_CMUL-val"><b>SUMMABLE_CMUL</b></a>]  Theorem
      
       s x c. summable s x  summable s (n. c * x n)
   
   [<a name="SUMMABLE_COMPARISON-val"><b>SUMMABLE_COMPARISON</b></a>]  Theorem
      
       f g s.
          summable s g  (N. n. n  N  n  s  abs (f n)  g n) 
          summable s f
   
   [<a name="SUMMABLE_COMPONENT-val"><b>SUMMABLE_COMPONENT</b></a>]  Theorem
      
       f s. summable s f  summable s (i. f i)
   
   [<a name="SUMMABLE_EQ-val"><b>SUMMABLE_EQ</b></a>]  Theorem
      
       f g k. (x. x  k  f x = g x)  summable k f  summable k g
   
   [<a name="SUMMABLE_EQ_COFINITE-val"><b>SUMMABLE_EQ_COFINITE</b></a>]  Theorem
      
       f s t.
          FINITE (s DIFF t  (t DIFF s))  summable s f  summable t f
   
   [<a name="SUMMABLE_EQ_EVENTUALLY-val"><b>SUMMABLE_EQ_EVENTUALLY</b></a>]  Theorem
      
       f g k.
          (N. n. N  n  n  k  f n = g n)  summable k f  summable k g
   
   [<a name="SUMMABLE_FROM_ELSEWHERE-val"><b>SUMMABLE_FROM_ELSEWHERE</b></a>]  Theorem
      
       f m n. summable (from m) f  summable (from n) f
   
   [<a name="SUMMABLE_IFF-val"><b>SUMMABLE_IFF</b></a>]  Theorem
      
       f g k. (x. x  k  f x = g x)  (summable k f  summable k g)
   
   [<a name="SUMMABLE_IFF_COFINITE-val"><b>SUMMABLE_IFF_COFINITE</b></a>]  Theorem
      
       f s t.
          FINITE (s DIFF t  (t DIFF s))  (summable s f  summable t f)
   
   [<a name="SUMMABLE_IFF_EVENTUALLY-val"><b>SUMMABLE_IFF_EVENTUALLY</b></a>]  Theorem
      
       f g k.
          (N. n. N  n  n  k  f n = g n) 
          (summable k f  summable k g)
   
   [<a name="SUMMABLE_IMP_BOUNDED-val"><b>SUMMABLE_IMP_BOUNDED</b></a>]  Theorem
      
       f k. summable k f  bounded (IMAGE f k)
   
   [<a name="SUMMABLE_IMP_SUMS_BOUNDED-val"><b>SUMMABLE_IMP_SUMS_BOUNDED</b></a>]  Theorem
      
       f k. summable (from k) f  bounded {sum {k .. n} f | n  (:num)}
   
   [<a name="SUMMABLE_IMP_TOZERO-val"><b>SUMMABLE_IMP_TOZERO</b></a>]  Theorem
      
       f k.
          summable k f  ((n. if n  k then f n else 0)  0) sequentially
   
   [<a name="SUMMABLE_LINEAR-val"><b>SUMMABLE_LINEAR</b></a>]  Theorem
      
       f h s. summable s f  linear h  summable s (n. h (f n))
   
   [<a name="SUMMABLE_NEG-val"><b>SUMMABLE_NEG</b></a>]  Theorem
      
       x s. summable s x  summable s (n. -x n)
   
   [<a name="SUMMABLE_REARRANGE-val"><b>SUMMABLE_REARRANGE</b></a>]  Theorem
      
       x s p.
          summable s (n. abs (x n))  p permutes s  summable s (x  p)
   
   [<a name="SUMMABLE_REINDEX-val"><b>SUMMABLE_REINDEX</b></a>]  Theorem
      
       k a n.
          summable (from n) (x. a (x + k))  summable (from (n + k)) a
   
   [<a name="SUMMABLE_RESTRICT-val"><b>SUMMABLE_RESTRICT</b></a>]  Theorem
      
       f k.
          summable (:num) (n. if n  k then f n else 0)  summable k f
   
   [<a name="SUMMABLE_SUB-val"><b>SUMMABLE_SUB</b></a>]  Theorem
      
       x y s. summable s x  summable s y  summable s (n. x n  y n)
   
   [<a name="SUMMABLE_SUBSET-val"><b>SUMMABLE_SUBSET</b></a>]  Theorem
      
       x s t.
          s  t  summable t (i. if i  s then x i else 0)  summable s x
   
   [<a name="SUMMABLE_SUBSET_ABSCONV-val"><b>SUMMABLE_SUBSET_ABSCONV</b></a>]  Theorem
      
       x s t.
          summable s (n. abs (x n))  t  s  summable t (n. abs (x n))
   
   [<a name="SUMMABLE_TRIVIAL-val"><b>SUMMABLE_TRIVIAL</b></a>]  Theorem
      
       f. summable  f
   
   [<a name="SUMS_0-val"><b>SUMS_0</b></a>]  Theorem
      
       f s. (n. n  s  f n = 0)  (f sums 0) s
   
   [<a name="SUMS_EQ-val"><b>SUMS_EQ</b></a>]  Theorem
      
       f g k. (x. x  k  f x = g x)  (f sums l) k  (g sums l) k
   
   [<a name="SUMS_FINITE_DIFF-val"><b>SUMS_FINITE_DIFF</b></a>]  Theorem
      
       f t s l.
          t  s  FINITE t  (f sums l) s  (f sums l  sum t f) (s DIFF t)
   
   [<a name="SUMS_FINITE_UNION-val"><b>SUMS_FINITE_UNION</b></a>]  Theorem
      
       f s t l.
          FINITE t  (f sums l) s  (f sums l + sum (t DIFF s) f) (s  t)
   
   [<a name="SUMS_IFF-val"><b>SUMS_IFF</b></a>]  Theorem
      
       f g k. (x. x  k  f x = g x)  ((f sums l) k  (g sums l) k)
   
   [<a name="SUMS_INFSUM-val"><b>SUMS_INFSUM</b></a>]  Theorem
      
       f s. (f sums suminf s f) s  summable s f
   
   [<a name="SUMS_INTERVALS-val"><b>SUMS_INTERVALS</b></a>]  Theorem
      
       (a b c d.
           interval [(a,b)]    interval [(c,d)]   
           {x + y | x  interval [(a,b)]  y  interval [(c,d)]} =
           interval [(a + c,b + d)]) 
        a b c d.
          interval (a,b)    interval (c,d)   
          {x + y | x  interval (a,b)  y  interval (c,d)} =
          interval (a + c,b + d)
   
   [<a name="SUMS_LIM-val"><b>SUMS_LIM</b></a>]  Theorem
      
       f s.
          (f sums lim sequentially (n. sum (s  {0 .. n}) f)) s 
          summable s f
   
   [<a name="SUMS_OFFSET-val"><b>SUMS_OFFSET</b></a>]  Theorem
      
       f l m n.
          (f sums l) (from m)  0 &lt; n  m  n 
          (f sums l  sum {m .. n  1} f) (from n)
   
   [<a name="SUMS_OFFSET_REV-val"><b>SUMS_OFFSET_REV</b></a>]  Theorem
      
       f l m n.
          (f sums l) (from m)  0 &lt; m  n  m 
          (f sums l + sum {n .. m  1} f) (from n)
   
   [<a name="SUMS_REINDEX-val"><b>SUMS_REINDEX</b></a>]  Theorem
      
       k a l n.
          ((x. a (x + k)) sums l) (from n)  (a sums l) (from (n + k))
   
   [<a name="SUMS_REINDEX_GEN-val"><b>SUMS_REINDEX_GEN</b></a>]  Theorem
      
       k a l s.
          ((x. a (x + k)) sums l) s  (a sums l) (IMAGE (i. i + k) s)
   
   [<a name="SUMS_SUMMABLE-val"><b>SUMS_SUMMABLE</b></a>]  Theorem
      
       f l s. (f sums l) s  summable s f
   
   [<a name="SUM_DIFF_LEMMA-val"><b>SUM_DIFF_LEMMA</b></a>]  Theorem
      
       f k m n.
          m  n 
          sum (k  {0 .. n}) f  sum (k  {0 .. m}) f =
          sum (k  {m + 1 .. n}) f
   
   [<a name="SUP_INSERT-val"><b>SUP_INSERT</b></a>]  Theorem
      
       x s.
          bounded s  sup (x INSERT s) = if s =  then x else max x (sup s)
   
   [<a name="SURJECTIVE_IMAGE_EQ-val"><b>SURJECTIVE_IMAGE_EQ</b></a>]  Theorem
      
       s t.
          (y. y  t  x. f x = y)  (x. f x  t  x  s)  IMAGE f s = t
   
   [<a name="SYMMETRIC_CLOSURE-val"><b>SYMMETRIC_CLOSURE</b></a>]  Theorem
      
       s. (x. x  s  -x  s)  x. x  closure s  -x  closure s
   
   [<a name="SYMMETRIC_INTERIOR-val"><b>SYMMETRIC_INTERIOR</b></a>]  Theorem
      
       s. (x. x  s  -x  s)  x. x  interior s  -x  interior s
   
   [<a name="SYMMETRIC_LINEAR_IMAGE-val"><b>SYMMETRIC_LINEAR_IMAGE</b></a>]  Theorem
      
       f s.
          (x. x  s  -x  s)  linear f 
          x. x  IMAGE f s  -x  IMAGE f s
   
   [<a name="TENDSTO_LIM-val"><b>TENDSTO_LIM</b></a>]  Theorem
      
       net f l. trivial_limit net  (f  l) net  lim net f = l
   
   [<a name="TOPSPACE_EUCLIDEAN-val"><b>TOPSPACE_EUCLIDEAN</b></a>]  Theorem
      
       topspace euclidean = (:real)
   
   [<a name="TOPSPACE_EUCLIDEAN_SUBTOPOLOGY-val"><b>TOPSPACE_EUCLIDEAN_SUBTOPOLOGY</b></a>]  Theorem
      
       s. topspace (subtopology euclidean s) = s
   
   [<a name="TRANSITIVE_STEPWISE_LT-val"><b>TRANSITIVE_STEPWISE_LT</b></a>]  Theorem
      
       R. (x y z. R x y  R y z  R x z)  (n. R n (SUC n)) 
            m n. m &lt; n  R m n
   
   [<a name="TRANSITIVE_STEPWISE_LT_EQ-val"><b>TRANSITIVE_STEPWISE_LT_EQ</b></a>]  Theorem
      
       R. (x y z. R x y  R y z  R x z) 
            ((m n. m &lt; n  R m n)  n. R n (SUC n))
   
   [<a name="TRANSLATION_DIFF-val"><b>TRANSLATION_DIFF</b></a>]  Theorem
      
       s t.
          IMAGE (x. a + x) (s DIFF t) =
          IMAGE (x. a + x) s DIFF IMAGE (x. a + x) t
   
   [<a name="TRIVIAL_LIMIT_AT-val"><b>TRIVIAL_LIMIT_AT</b></a>]  Theorem
      
       a. trivial_limit (at a)
   
   [<a name="TRIVIAL_LIMIT_AT_INFINITY-val"><b>TRIVIAL_LIMIT_AT_INFINITY</b></a>]  Theorem
      
       trivial_limit at_infinity
   
   [<a name="TRIVIAL_LIMIT_AT_NEGINFINITY-val"><b>TRIVIAL_LIMIT_AT_NEGINFINITY</b></a>]  Theorem
      
       trivial_limit at_neginfinity
   
   [<a name="TRIVIAL_LIMIT_AT_POSINFINITY-val"><b>TRIVIAL_LIMIT_AT_POSINFINITY</b></a>]  Theorem
      
       trivial_limit at_posinfinity
   
   [<a name="TRIVIAL_LIMIT_SEQUENTIALLY-val"><b>TRIVIAL_LIMIT_SEQUENTIALLY</b></a>]  Theorem
      
       trivial_limit sequentially
   
   [<a name="TRIVIAL_LIMIT_WITHIN-val"><b>TRIVIAL_LIMIT_WITHIN</b></a>]  Theorem
      
       a. trivial_limit (at a within s)  (a limit_point_of s)
   
   [<a name="UNBOUNDED_HALFSPACE_COMPONENT_GE-val"><b>UNBOUNDED_HALFSPACE_COMPONENT_GE</b></a>]  Theorem
      
       a. bounded {x | x  a}
   
   [<a name="UNBOUNDED_HALFSPACE_COMPONENT_GT-val"><b>UNBOUNDED_HALFSPACE_COMPONENT_GT</b></a>]  Theorem
      
       a. bounded {x | x &gt; a}
   
   [<a name="UNBOUNDED_HALFSPACE_COMPONENT_LE-val"><b>UNBOUNDED_HALFSPACE_COMPONENT_LE</b></a>]  Theorem
      
       a. bounded {x | x  a}
   
   [<a name="UNBOUNDED_HALFSPACE_COMPONENT_LT-val"><b>UNBOUNDED_HALFSPACE_COMPONENT_LT</b></a>]  Theorem
      
       a. bounded {x | x &lt; a}
   
   [<a name="UNBOUNDED_INTER_COBOUNDED-val"><b>UNBOUNDED_INTER_COBOUNDED</b></a>]  Theorem
      
       s t. bounded s  bounded ((:real) DIFF t)  s  t  
   
   [<a name="UNCOUNTABLE_EUCLIDEAN-val"><b>UNCOUNTABLE_EUCLIDEAN</b></a>]  Theorem
      
       uncountable (:real)
   
   [<a name="UNCOUNTABLE_INTERVAL-val"><b>UNCOUNTABLE_INTERVAL</b></a>]  Theorem
      
       (a b. interval (a,b)    uncountable (interval [(a,b)])) 
        a b. interval (a,b)    uncountable (interval (a,b))
   
   [<a name="UNCOUNTABLE_OPEN-val"><b>UNCOUNTABLE_OPEN</b></a>]  Theorem
      
       s. open s  s    uncountable s
   
   [<a name="UNCOUNTABLE_REAL-val"><b>UNCOUNTABLE_REAL</b></a>]  Theorem
      
       uncountable (:real)
   
   [<a name="UNIFORMLY_CAUCHY_IMP_UNIFORMLY_CONVERGENT-val"><b>UNIFORMLY_CAUCHY_IMP_UNIFORMLY_CONVERGENT</b></a>]  Theorem
      
       P s l.
          (e. 0 &lt; e 
               N. m n x. N  m  N  n  P x  dist (s m x,s n x) &lt; e) 
          (x. P x  e. 0 &lt; e  N. n. N  n  dist (s n x,l x) &lt; e) 
          e. 0 &lt; e  N. n x. N  n  P x  dist (s n x,l x) &lt; e
   
   [<a name="UNIFORMLY_CONTINUOUS_EXTENDS_TO_CLOSURE-val"><b>UNIFORMLY_CONTINUOUS_EXTENDS_TO_CLOSURE</b></a>]  Theorem
      
       f s.
          f uniformly_continuous_on s 
          g. g uniformly_continuous_on closure s 
              (x. x  s  g x = f x) 
              h. h continuous_on closure s  (x. x  s  h x = f x) 
                  x. x  closure s  h x = g x
   
   [<a name="UNIFORMLY_CONTINUOUS_IMP_CAUCHY_CONTINUOUS-val"><b>UNIFORMLY_CONTINUOUS_IMP_CAUCHY_CONTINUOUS</b></a>]  Theorem
      
       f s.
          f uniformly_continuous_on s 
          x. cauchy x  (n. x n  s)  cauchy (f  x)
   
   [<a name="UNIFORMLY_CONTINUOUS_IMP_CONTINUOUS-val"><b>UNIFORMLY_CONTINUOUS_IMP_CONTINUOUS</b></a>]  Theorem
      
       f s. f uniformly_continuous_on s  f continuous_on s
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_ADD-val"><b>UNIFORMLY_CONTINUOUS_ON_ADD</b></a>]  Theorem
      
       f g s.
          f uniformly_continuous_on s  g uniformly_continuous_on s 
          (x. f x + g x) uniformly_continuous_on s
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_CLOSURE-val"><b>UNIFORMLY_CONTINUOUS_ON_CLOSURE</b></a>]  Theorem
      
       f s.
          f uniformly_continuous_on s  f continuous_on closure s 
          f uniformly_continuous_on closure s
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_CMUL-val"><b>UNIFORMLY_CONTINUOUS_ON_CMUL</b></a>]  Theorem
      
       f c s.
          f uniformly_continuous_on s 
          (x. c * f x) uniformly_continuous_on s
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_COMPOSE-val"><b>UNIFORMLY_CONTINUOUS_ON_COMPOSE</b></a>]  Theorem
      
       f g s.
          f uniformly_continuous_on s  g uniformly_continuous_on IMAGE f s 
          g  f uniformly_continuous_on s
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_CONST-val"><b>UNIFORMLY_CONTINUOUS_ON_CONST</b></a>]  Theorem
      
       s c. (x. c) uniformly_continuous_on s
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_DIST_CLOSEST_POINT-val"><b>UNIFORMLY_CONTINUOUS_ON_DIST_CLOSEST_POINT</b></a>]  Theorem
      
       s t.
          closed s  s   
          (x. dist (x,closest_point s x)) uniformly_continuous_on t
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_EQ-val"><b>UNIFORMLY_CONTINUOUS_ON_EQ</b></a>]  Theorem
      
       f g s.
          (x. x  s  f x = g x)  f uniformly_continuous_on s 
          g uniformly_continuous_on s
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_ID-val"><b>UNIFORMLY_CONTINUOUS_ON_ID</b></a>]  Theorem
      
       s. (x. x) uniformly_continuous_on s
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_MUL-val"><b>UNIFORMLY_CONTINUOUS_ON_MUL</b></a>]  Theorem
      
       f g s.
          f uniformly_continuous_on s  g uniformly_continuous_on s 
          bounded (IMAGE f s)  bounded (IMAGE g s) 
          (x. f x * g x) uniformly_continuous_on s
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_NEG-val"><b>UNIFORMLY_CONTINUOUS_ON_NEG</b></a>]  Theorem
      
       f s.
          f uniformly_continuous_on s 
          (x. -f x) uniformly_continuous_on s
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_SEQUENTIALLY-val"><b>UNIFORMLY_CONTINUOUS_ON_SEQUENTIALLY</b></a>]  Theorem
      
       f s.
          f uniformly_continuous_on s 
          x y.
            (n. x n  s)  (n. y n  s) 
            ((n. x n  y n)  0) sequentially 
            ((n. f (x n)  f (y n))  0) sequentially
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_SETDIST-val"><b>UNIFORMLY_CONTINUOUS_ON_SETDIST</b></a>]  Theorem
      
       s t. (y. setdist ({y},s)) uniformly_continuous_on t
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_SUB-val"><b>UNIFORMLY_CONTINUOUS_ON_SUB</b></a>]  Theorem
      
       f g s.
          f uniformly_continuous_on s  g uniformly_continuous_on s 
          (x. f x  g x) uniformly_continuous_on s
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_SUBSET-val"><b>UNIFORMLY_CONTINUOUS_ON_SUBSET</b></a>]  Theorem
      
       f s t.
          f uniformly_continuous_on s  t  s  f uniformly_continuous_on t
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_SUM-val"><b>UNIFORMLY_CONTINUOUS_ON_SUM</b></a>]  Theorem
      
       t f s.
          FINITE s  (a. a  s  f a uniformly_continuous_on t) 
          (x. sum s (a. f a x)) uniformly_continuous_on t
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_VMUL-val"><b>UNIFORMLY_CONTINUOUS_ON_VMUL</b></a>]  Theorem
      
       s c v.
          c uniformly_continuous_on s 
          (x. c x * v) uniformly_continuous_on s
   
   [<a name="UNIFORMLY_CONVERGENT_EQ_CAUCHY-val"><b>UNIFORMLY_CONVERGENT_EQ_CAUCHY</b></a>]  Theorem
      
       P s.
          (l. e. 0 &lt; e  N. n x. N  n  P x  dist (s n x,l x) &lt; e) 
          e. 0 &lt; e 
              N. m n x. N  m  N  n  P x  dist (s m x,s n x) &lt; e
   
   [<a name="UNIFORMLY_CONVERGENT_EQ_CAUCHY_ALT-val"><b>UNIFORMLY_CONVERGENT_EQ_CAUCHY_ALT</b></a>]  Theorem
      
       P s.
          (l. e. 0 &lt; e  N. n x. N  n  P x  dist (s n x,l x) &lt; e) 
          e. 0 &lt; e 
              N. m n x.
                N  m  N  n  m &lt; n  P x  dist (s m x,s n x) &lt; e
   
   [<a name="UNIFORM_LIM_ADD-val"><b>UNIFORM_LIM_ADD</b></a>]  Theorem
      
       net P f g l m.
          (e. 0 &lt; e  eventually (x. n. P n  abs (f n x  l n) &lt; e) net) 
          (e. 0 &lt; e  eventually (x. n. P n  abs (g n x  m n) &lt; e) net) 
          e. 0 &lt; e 
              eventually
                (x. n. P n  abs (f n x + g n x  (l n + m n)) &lt; e) net
   
   [<a name="UNIFORM_LIM_BILINEAR-val"><b>UNIFORM_LIM_BILINEAR</b></a>]  Theorem
      
       net P h f g l m b1 b2.
          bilinear h  eventually (x. n. P n  abs (l n)  b1) net 
          eventually (x. n. P n  abs (m n)  b2) net 
          (e. 0 &lt; e  eventually (x. n. P n  abs (f n x  l n) &lt; e) net) 
          (e. 0 &lt; e  eventually (x. n. P n  abs (g n x  m n) &lt; e) net) 
          e. 0 &lt; e 
              eventually
                (x. n. P n  abs (h (f n x) (g n x)  h (l n) (m n)) &lt; e)
                net
   
   [<a name="UNIFORM_LIM_SUB-val"><b>UNIFORM_LIM_SUB</b></a>]  Theorem
      
       net P f g l m.
          (e. 0 &lt; e  eventually (x. n. P n  abs (f n x  l n) &lt; e) net) 
          (e. 0 &lt; e  eventually (x. n. P n  abs (g n x  m n) &lt; e) net) 
          e. 0 &lt; e 
              eventually
                (x. n. P n  abs (f n x  g n x  (l n  m n)) &lt; e) net
   
   [<a name="UNION_FRONTIER-val"><b>UNION_FRONTIER</b></a>]  Theorem
      
       s t.
          frontier s  frontier t =
          frontier (s  t)  frontier (s  t)  frontier s  frontier t
   
   [<a name="UNION_INTERIOR_SUBSET-val"><b>UNION_INTERIOR_SUBSET</b></a>]  Theorem
      
       s t. interior s  interior t  interior (s  t)
   
   [<a name="UNIT_INTERVAL_NONEMPTY-val"><b>UNIT_INTERVAL_NONEMPTY</b></a>]  Theorem
      
       interval [(0,1)]    interval (0,1)  
   
   [<a name="UPPER_HEMICONTINUOUS-val"><b>UPPER_HEMICONTINUOUS</b></a>]  Theorem
      
       f t s.
          (x. x  s  f x  t) 
          ((u. open_in (subtopology euclidean t) u 
                open_in (subtopology euclidean s) {x | x  s  f x  u}) 
           u. closed_in (subtopology euclidean t) u 
               closed_in (subtopology euclidean s)
                 {x | x  s  f x  u  })
   
   [<a name="UPPER_LOWER_HEMICONTINUOUS-val"><b>UPPER_LOWER_HEMICONTINUOUS</b></a>]  Theorem
      
       f t s.
          (x. x  s  f x  t) 
          (u. open_in (subtopology euclidean t) u 
               open_in (subtopology euclidean s) {x | x  s  f x  u}) 
          (u. closed_in (subtopology euclidean t) u 
               closed_in (subtopology euclidean s) {x | x  s  f x  u}) 
          x e.
            x  s  0 &lt; e  bounded (f x) 
            d. 0 &lt; d 
                x'. x'  s  dist (x,x') &lt; d  hausdist (f x,f x') &lt; e
   
   [<a name="UPPER_LOWER_HEMICONTINUOUS_EXPLICIT-val"><b>UPPER_LOWER_HEMICONTINUOUS_EXPLICIT</b></a>]  Theorem
      
       f t s.
          (x. x  s  f x  t) 
          (u. open_in (subtopology euclidean t) u 
               open_in (subtopology euclidean s) {x | x  s  f x  u}) 
          (u. closed_in (subtopology euclidean t) u 
               closed_in (subtopology euclidean s) {x | x  s  f x  u}) 
          x e.
            x  s  0 &lt; e  bounded (f x)  f x   
            d. 0 &lt; d 
                x'.
                  x'  s  dist (x,x') &lt; d 
                  (y. y  f x  y'. y'  f x'  dist (y,y') &lt; e) 
                  y'. y'  f x'  y. y  f x  dist (y',y) &lt; e
   
   [<a name="URYSOHN-val"><b>URYSOHN</b></a>]  Theorem
      
       s t a b.
          closed s  closed t  s  t =  
          f. f continuous_on (:real)  (x. f x  segment [(a,b)]) 
              (x. x  s  f x = a)  x. x  t  f x = b
   
   [<a name="URYSOHN_LOCAL-val"><b>URYSOHN_LOCAL</b></a>]  Theorem
      
       s t u a b.
          closed_in (subtopology euclidean u) s 
          closed_in (subtopology euclidean u) t  s  t =  
          f. f continuous_on u  (x. x  u  f x  segment [(a,b)]) 
              (x. x  s  f x = a)  x. x  t  f x = b
   
   [<a name="URYSOHN_LOCAL_STRONG-val"><b>URYSOHN_LOCAL_STRONG</b></a>]  Theorem
      
       s t u a b.
          closed_in (subtopology euclidean u) s 
          closed_in (subtopology euclidean u) t  s  t =   a  b 
          f. f continuous_on u  (x. x  u  f x  segment [(a,b)]) 
              (x. x  u  (f x = a  x  s)) 
              x. x  u  (f x = b  x  t)
   
   [<a name="URYSOHN_STRONG-val"><b>URYSOHN_STRONG</b></a>]  Theorem
      
       s t a b.
          closed s  closed t  s  t =   a  b 
          f. f continuous_on (:real)  (x. f x  segment [(a,b)]) 
              (x. f x = a  x  s)  x. f x = b  x  t
   
   [<a name="WITHIN-val"><b>WITHIN</b></a>]  Theorem
      
       n s x y. netord (n within s) x y  netord n x y  x  s
   
   [<a name="WITHIN_UNIV-val"><b>WITHIN_UNIV</b></a>]  Theorem
      
       x. (at x within (:real)) = at x
   
   [<a name="WITHIN_WITHIN-val"><b>WITHIN_WITHIN</b></a>]  Theorem
      
       net s t. ((net within s) within t) = (net within s  t)
   
   [<a name="at-val"><b>at</b></a>]  Theorem
      
       a. at a = mk_net (x y. 0 &lt; dist (x,a)  dist (x,a)  dist (y,a))
   
   [<a name="ball-val"><b>ball</b></a>]  Theorem
      
       x e. ball (x,e) = {y | dist (x,y) &lt; e}
   
   [<a name="closed_def-val"><b>closed_def</b></a>]  Theorem
      
       s. closed s  open ((:real) DIFF s)
   
   [<a name="continuous_at-val"><b>continuous_at</b></a>]  Theorem
      
       f continuous at x 
        e. 0 &lt; e  d. 0 &lt; d  x'. dist (x',x) &lt; d  dist (f x',f x) &lt; e
   
   [<a name="continuous_within-val"><b>continuous_within</b></a>]  Theorem
      
       f continuous (at x within s) 
        e. 0 &lt; e 
            d. 0 &lt; d  x'. x'  s  dist (x',x) &lt; d  dist (f x',f x) &lt; e
   
   [<a name="diameter-val"><b>diameter</b></a>]  Theorem
      
       s. diameter s =
            if s =  then 0 else sup {abs (x  y) | x  s  y  s}
   
   [<a name="dist-val"><b>dist</b></a>]  Theorem
      
       x y. dist (x,y) = abs (x  y)
   
   [<a name="euclidean-val"><b>euclidean</b></a>]  Theorem
      
       euclidean = topology open
   
   [<a name="fsigma-val"><b>fsigma</b></a>]  Theorem
      
       s. fsigma s 
            g. countable g  (c. c  g  closed c)  BIGUNION g = s
   
   [<a name="gdelta-val"><b>gdelta</b></a>]  Theorem
      
       s. gdelta s 
            g. countable g  (u. u  g  open u)  BIGINTER g = s
   
   [<a name="interval-val"><b>interval</b></a>]  Theorem
      
       interval (a,b) = {x | a &lt; x  x &lt; b} 
        interval [(a,b)] = {x | a  x  x  b}
   
   [<a name="limit_point_of-val"><b>limit_point_of</b></a>]  Theorem
      
       x s.
          x limit_point_of s 
          t. x  t  open t  y. y  x  y  s  y  t
   
   [<a name="linear_alt_cmul-val"><b>linear_alt_cmul</b></a>]  Theorem
      
       f. linear f  c x. f (c * x) = c * f x
   
   [<a name="linear_repr-val"><b>linear_repr</b></a>]  Theorem
      
       f. linear f  l. f = (x. l * x)
   
   [<a name="net_tybij-val"><b>net_tybij</b></a>]  Theorem
      
       (a. mk_net (netord a) = a) 
        r. (x y. (z. r z x  r z y)  z. r z y  r z x) 
            netord (mk_net r) = r
   
   [<a name="open_def-val"><b>open_def</b></a>]  Theorem
      
       s. open s  x. x  s  e. 0 &lt; e  x'. dist (x',x) &lt; e  x'  s
   
   [<a name="open_in-val"><b>open_in</b></a>]  Theorem
      
       u s.
          open_in (subtopology euclidean u) s 
          s  u 
          x. x  s  e. 0 &lt; e  x'. x'  u  dist (x',x) &lt; e  x'  s
   
   [<a name="segment-val"><b>segment</b></a>]  Theorem
      
       segment [(a,b)] = {(1  u) * a + u * b | 0  u  u  1} 
        segment (a,b) = segment [(a,b)] DIFF {a; b}
   
   [<a name="setdist-val"><b>setdist</b></a>]  Theorem
      
       s t.
          setdist (s,t) =
          if s =   t =  then 0 else inf {dist (x,y) | x  s  y  t}
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/real/analysis/real_topologyScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-1</a></em></p></body></html>
