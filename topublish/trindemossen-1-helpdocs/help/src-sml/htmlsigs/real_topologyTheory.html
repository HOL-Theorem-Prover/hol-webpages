<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure real_topologyTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure real_topologyTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/real/analysis/real_topologyScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature real_topologyTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#CLOSED_interval-val">CLOSED_interval</a> : thm
<a name="line7"></a>    val <a href="#OPEN_interval-val">OPEN_interval</a> : thm
<a name="line8"></a>    val <a href="#at_def-val">at_def</a> : thm
<a name="line9"></a>    val <a href="#at_infinity-val">at_infinity</a> : thm
<a name="line10"></a>    val <a href="#at_neginfinity-val">at_neginfinity</a> : thm
<a name="line11"></a>    val <a href="#at_posinfinity-val">at_posinfinity</a> : thm
<a name="line12"></a>    val <a href="#ball_def-val">ball_def</a> : thm
<a name="line13"></a>    val <a href="#between-val">between</a> : thm
<a name="line14"></a>    val <a href="#bilinear-val">bilinear</a> : thm
<a name="line15"></a>    val <a href="#bounded_def-val">bounded_def</a> : thm
<a name="line16"></a>    val <a href="#cauchy_def-val">cauchy_def</a> : thm
<a name="line17"></a>    val <a href="#cball-val">cball</a> : thm
<a name="line18"></a>    val <a href="#closed_segment-val">closed_segment</a> : thm
<a name="line19"></a>    val <a href="#closest_point-val">closest_point</a> : thm
<a name="line20"></a>    val <a href="#closure-val">closure</a> : thm
<a name="line21"></a>    val <a href="#collinear-val">collinear</a> : thm
<a name="line22"></a>    val <a href="#compact-val">compact</a> : thm
<a name="line23"></a>    val <a href="#complete-val">complete</a> : thm
<a name="line24"></a>    val <a href="#components-val">components</a> : thm
<a name="line25"></a>    val <a href="#condensation_point_of-val">condensation_point_of</a> : thm
<a name="line26"></a>    val <a href="#connected-val">connected</a> : thm
<a name="line27"></a>    val <a href="#connected_component-val">connected_component</a> : thm
<a name="line28"></a>    val <a href="#content-val">content</a> : thm
<a name="line29"></a>    val <a href="#continuous-val">continuous</a> : thm
<a name="line30"></a>    val <a href="#continuous_on-val">continuous_on</a> : thm
<a name="line31"></a>    val <a href="#dependent-val">dependent</a> : thm
<a name="line32"></a>    val <a href="#dim-val">dim</a> : thm
<a name="line33"></a>    val <a href="#dist_def-val">dist_def</a> : thm
<a name="line34"></a>    val <a href="#euclidean_closed_def-val">euclidean_closed_def</a> : thm
<a name="line35"></a>    val <a href="#euclidean_def-val">euclidean_def</a> : thm
<a name="line36"></a>    val <a href="#euclidean_open_def-val">euclidean_open_def</a> : thm
<a name="line37"></a>    val <a href="#eventually-val">eventually</a> : thm
<a name="line38"></a>    val <a href="#frontier-val">frontier</a> : thm
<a name="line39"></a>    val <a href="#hausdist-val">hausdist</a> : thm
<a name="line40"></a>    val <a href="#homeomorphic-val">homeomorphic</a> : thm
<a name="line41"></a>    val <a href="#homeomorphism-val">homeomorphism</a> : thm
<a name="line42"></a>    val <a href="#in_direction-val">in_direction</a> : thm
<a name="line43"></a>    val <a href="#independent-val">independent</a> : thm
<a name="line44"></a>    val <a href="#interior-val">interior</a> : thm
<a name="line45"></a>    val <a href="#interval_lowerbound-val">interval_lowerbound</a> : thm
<a name="line46"></a>    val <a href="#interval_upperbound-val">interval_upperbound</a> : thm
<a name="line47"></a>    val <a href="#is_interval-val">is_interval</a> : thm
<a name="line48"></a>    val <a href="#isnet-val">isnet</a> : thm
<a name="line49"></a>    val <a href="#limit_point_of_def-val">limit_point_of_def</a> : thm
<a name="line50"></a>    val <a href="#linear-val">linear</a> : thm
<a name="line51"></a>    val <a href="#locally-val">locally</a> : thm
<a name="line52"></a>    val <a href="#midpoint-val">midpoint</a> : thm
<a name="line53"></a>    val <a href="#net_TY_DEF-val">net_TY_DEF</a> : thm
<a name="line54"></a>    val <a href="#netlimit-val">netlimit</a> : thm
<a name="line55"></a>    val <a href="#open_segment-val">open_segment</a> : thm
<a name="line56"></a>    val <a href="#reallim-val">reallim</a> : thm
<a name="line57"></a>    val <a href="#sequentially-val">sequentially</a> : thm
<a name="line58"></a>    val <a href="#set_diameter_def-val">set_diameter_def</a> : thm
<a name="line59"></a>    val <a href="#set_dist_def-val">set_dist_def</a> : thm
<a name="line60"></a>    val <a href="#span-val">span</a> : thm
<a name="line61"></a>    val <a href="#sphere-val">sphere</a> : thm
<a name="line62"></a>    val <a href="#subspace-val">subspace</a> : thm
<a name="line63"></a>    val <a href="#suminf_def-val">suminf_def</a> : thm
<a name="line64"></a>    val <a href="#summable_def-val">summable_def</a> : thm
<a name="line65"></a>    val <a href="#sums_def-val">sums_def</a> : thm
<a name="line66"></a>    val <a href="#tendsto_real-val">tendsto_real</a> : thm
<a name="line67"></a>    val <a href="#trivial_limit-val">trivial_limit</a> : thm
<a name="line68"></a>    val <a href="#uniformly_continuous_on-val">uniformly_continuous_on</a> : thm
<a name="line69"></a>    val <a href="#within-val">within</a> : thm
<a name="line70"></a>  
<a name="line71"></a>  (*  Theorems  *)
<a name="line72"></a>    val <a href="#ABS_CAUCHY_SCHWARZ_ABS_EQ-val">ABS_CAUCHY_SCHWARZ_ABS_EQ</a> : thm
<a name="line73"></a>    val <a href="#ABS_CAUCHY_SCHWARZ_EQ-val">ABS_CAUCHY_SCHWARZ_EQ</a> : thm
<a name="line74"></a>    val <a href="#ABS_CAUCHY_SCHWARZ_EQUAL-val">ABS_CAUCHY_SCHWARZ_EQUAL</a> : thm
<a name="line75"></a>    val <a href="#ABS_SUM_TRIVIAL_LEMMA-val">ABS_SUM_TRIVIAL_LEMMA</a> : thm
<a name="line76"></a>    val <a href="#ABS_TRIANGLE_EQ-val">ABS_TRIANGLE_EQ</a> : thm
<a name="line77"></a>    val <a href="#ABS_TRIANGLE_LE-val">ABS_TRIANGLE_LE</a> : thm
<a name="line78"></a>    val <a href="#AFFINITY_INVERSES-val">AFFINITY_INVERSES</a> : thm
<a name="line79"></a>    val <a href="#ALWAYS_EVENTUALLY-val">ALWAYS_EVENTUALLY</a> : thm
<a name="line80"></a>    val <a href="#APPROACHABLE_LT_LE-val">APPROACHABLE_LT_LE</a> : thm
<a name="line81"></a>    val <a href="#AT-val">AT</a> : thm
<a name="line82"></a>    val <a href="#AT_INFINITY-val">AT_INFINITY</a> : thm
<a name="line83"></a>    val <a href="#AT_NEGINFINITY-val">AT_NEGINFINITY</a> : thm
<a name="line84"></a>    val <a href="#AT_POSINFINITY-val">AT_POSINFINITY</a> : thm
<a name="line85"></a>    val <a href="#BAIRE-val">BAIRE</a> : thm
<a name="line86"></a>    val <a href="#BAIRE_ALT-val">BAIRE_ALT</a> : thm
<a name="line87"></a>    val <a href="#BALL-val">BALL</a> : thm
<a name="line88"></a>    val <a href="#BALL_EMPTY-val">BALL_EMPTY</a> : thm
<a name="line89"></a>    val <a href="#BALL_EQ_EMPTY-val">BALL_EQ_EMPTY</a> : thm
<a name="line90"></a>    val <a href="#BALL_INTERVAL-val">BALL_INTERVAL</a> : thm
<a name="line91"></a>    val <a href="#BALL_INTERVAL_0-val">BALL_INTERVAL_0</a> : thm
<a name="line92"></a>    val <a href="#BALL_LINEAR_IMAGE-val">BALL_LINEAR_IMAGE</a> : thm
<a name="line93"></a>    val <a href="#BALL_MAX_UNION-val">BALL_MAX_UNION</a> : thm
<a name="line94"></a>    val <a href="#BALL_MIN_INTER-val">BALL_MIN_INTER</a> : thm
<a name="line95"></a>    val <a href="#BALL_SCALING-val">BALL_SCALING</a> : thm
<a name="line96"></a>    val <a href="#BALL_SUBSET_CBALL-val">BALL_SUBSET_CBALL</a> : thm
<a name="line97"></a>    val <a href="#BALL_TRANSLATION-val">BALL_TRANSLATION</a> : thm
<a name="line98"></a>    val <a href="#BALL_TRIVIAL-val">BALL_TRIVIAL</a> : thm
<a name="line99"></a>    val <a href="#BALL_UNION_SPHERE-val">BALL_UNION_SPHERE</a> : thm
<a name="line100"></a>    val <a href="#BANACH_FIX-val">BANACH_FIX</a> : thm
<a name="line101"></a>    val <a href="#BASIS_CARD_EQ_DIM-val">BASIS_CARD_EQ_DIM</a> : thm
<a name="line102"></a>    val <a href="#BASIS_EXISTS-val">BASIS_EXISTS</a> : thm
<a name="line103"></a>    val <a href="#BASIS_HAS_SIZE_DIM-val">BASIS_HAS_SIZE_DIM</a> : thm
<a name="line104"></a>    val <a href="#BETWEEN_ABS-val">BETWEEN_ABS</a> : thm
<a name="line105"></a>    val <a href="#BETWEEN_ANTISYM-val">BETWEEN_ANTISYM</a> : thm
<a name="line106"></a>    val <a href="#BETWEEN_IMP_COLLINEAR-val">BETWEEN_IMP_COLLINEAR</a> : thm
<a name="line107"></a>    val <a href="#BETWEEN_IN_SEGMENT-val">BETWEEN_IN_SEGMENT</a> : thm
<a name="line108"></a>    val <a href="#BETWEEN_MIDPOINT-val">BETWEEN_MIDPOINT</a> : thm
<a name="line109"></a>    val <a href="#BETWEEN_REFL-val">BETWEEN_REFL</a> : thm
<a name="line110"></a>    val <a href="#BETWEEN_REFL_EQ-val">BETWEEN_REFL_EQ</a> : thm
<a name="line111"></a>    val <a href="#BETWEEN_SYM-val">BETWEEN_SYM</a> : thm
<a name="line112"></a>    val <a href="#BETWEEN_TRANS-val">BETWEEN_TRANS</a> : thm
<a name="line113"></a>    val <a href="#BETWEEN_TRANS_2-val">BETWEEN_TRANS_2</a> : thm
<a name="line114"></a>    val <a href="#BIGUNION_COMPONENTS-val">BIGUNION_COMPONENTS</a> : thm
<a name="line115"></a>    val <a href="#BIGUNION_CONNECTED_COMPONENT-val">BIGUNION_CONNECTED_COMPONENT</a> : thm
<a name="line116"></a>    val <a href="#BIGUNION_DIFF-val">BIGUNION_DIFF</a> : thm
<a name="line117"></a>    val <a href="#BIGUNION_MONO-val">BIGUNION_MONO</a> : thm
<a name="line118"></a>    val <a href="#BIGUNION_MONO_IMAGE-val">BIGUNION_MONO_IMAGE</a> : thm
<a name="line119"></a>    val <a href="#BILINEAR_BOUNDED-val">BILINEAR_BOUNDED</a> : thm
<a name="line120"></a>    val <a href="#BILINEAR_BOUNDED_POS-val">BILINEAR_BOUNDED_POS</a> : thm
<a name="line121"></a>    val <a href="#BILINEAR_CONTINUOUS_COMPOSE-val">BILINEAR_CONTINUOUS_COMPOSE</a> : thm
<a name="line122"></a>    val <a href="#BILINEAR_CONTINUOUS_ON_COMPOSE-val">BILINEAR_CONTINUOUS_ON_COMPOSE</a> : thm
<a name="line123"></a>    val <a href="#BILINEAR_DOT-val">BILINEAR_DOT</a> : thm
<a name="line124"></a>    val <a href="#BILINEAR_LADD-val">BILINEAR_LADD</a> : thm
<a name="line125"></a>    val <a href="#BILINEAR_LMUL-val">BILINEAR_LMUL</a> : thm
<a name="line126"></a>    val <a href="#BILINEAR_LNEG-val">BILINEAR_LNEG</a> : thm
<a name="line127"></a>    val <a href="#BILINEAR_LSUB-val">BILINEAR_LSUB</a> : thm
<a name="line128"></a>    val <a href="#BILINEAR_LZERO-val">BILINEAR_LZERO</a> : thm
<a name="line129"></a>    val <a href="#BILINEAR_RADD-val">BILINEAR_RADD</a> : thm
<a name="line130"></a>    val <a href="#BILINEAR_RMUL-val">BILINEAR_RMUL</a> : thm
<a name="line131"></a>    val <a href="#BILINEAR_RNEG-val">BILINEAR_RNEG</a> : thm
<a name="line132"></a>    val <a href="#BILINEAR_RSUB-val">BILINEAR_RSUB</a> : thm
<a name="line133"></a>    val <a href="#BILINEAR_RZERO-val">BILINEAR_RZERO</a> : thm
<a name="line134"></a>    val <a href="#BILINEAR_SUM-val">BILINEAR_SUM</a> : thm
<a name="line135"></a>    val <a href="#BILINEAR_SUM_PARTIAL_PRE-val">BILINEAR_SUM_PARTIAL_PRE</a> : thm
<a name="line136"></a>    val <a href="#BILINEAR_SUM_PARTIAL_SUC-val">BILINEAR_SUM_PARTIAL_SUC</a> : thm
<a name="line137"></a>    val <a href="#BILINEAR_SWAP-val">BILINEAR_SWAP</a> : thm
<a name="line138"></a>    val <a href="#BILINEAR_UNIFORMLY_CONTINUOUS_ON_COMPOSE-val">BILINEAR_UNIFORMLY_CONTINUOUS_ON_COMPOSE</a> : thm
<a name="line139"></a>    val <a href="#BOLZANO_WEIERSTRASS-val">BOLZANO_WEIERSTRASS</a> : thm
<a name="line140"></a>    val <a href="#BOLZANO_WEIERSTRASS_CONTRAPOS-val">BOLZANO_WEIERSTRASS_CONTRAPOS</a> : thm
<a name="line141"></a>    val <a href="#BOLZANO_WEIERSTRASS_IMP_BOUNDED-val">BOLZANO_WEIERSTRASS_IMP_BOUNDED</a> : thm
<a name="line142"></a>    val <a href="#BOLZANO_WEIERSTRASS_IMP_CLOSED-val">BOLZANO_WEIERSTRASS_IMP_CLOSED</a> : thm
<a name="line143"></a>    val <a href="#BOUNDED_BALL-val">BOUNDED_BALL</a> : thm
<a name="line144"></a>    val <a href="#BOUNDED_BIGINTER-val">BOUNDED_BIGINTER</a> : thm
<a name="line145"></a>    val <a href="#BOUNDED_BIGUNION-val">BOUNDED_BIGUNION</a> : thm
<a name="line146"></a>    val <a href="#BOUNDED_CBALL-val">BOUNDED_CBALL</a> : thm
<a name="line147"></a>    val <a href="#BOUNDED_CLOSED_CHAIN-val">BOUNDED_CLOSED_CHAIN</a> : thm
<a name="line148"></a>    val <a href="#BOUNDED_CLOSED_IMP_COMPACT-val">BOUNDED_CLOSED_IMP_COMPACT</a> : thm
<a name="line149"></a>    val <a href="#BOUNDED_CLOSED_INTERVAL-val">BOUNDED_CLOSED_INTERVAL</a> : thm
<a name="line150"></a>    val <a href="#BOUNDED_CLOSED_NEST-val">BOUNDED_CLOSED_NEST</a> : thm
<a name="line151"></a>    val <a href="#BOUNDED_CLOSURE-val">BOUNDED_CLOSURE</a> : thm
<a name="line152"></a>    val <a href="#BOUNDED_CLOSURE_EQ-val">BOUNDED_CLOSURE_EQ</a> : thm
<a name="line153"></a>    val <a href="#BOUNDED_COMPONENTWISE-val">BOUNDED_COMPONENTWISE</a> : thm
<a name="line154"></a>    val <a href="#BOUNDED_DECREASING_CONVERGENT-val">BOUNDED_DECREASING_CONVERGENT</a> : thm
<a name="line155"></a>    val <a href="#BOUNDED_DIFF-val">BOUNDED_DIFF</a> : thm
<a name="line156"></a>    val <a href="#BOUNDED_DIFFS-val">BOUNDED_DIFFS</a> : thm
<a name="line157"></a>    val <a href="#BOUNDED_EMPTY-val">BOUNDED_EMPTY</a> : thm
<a name="line158"></a>    val <a href="#BOUNDED_EQ_BOLZANO_WEIERSTRASS-val">BOUNDED_EQ_BOLZANO_WEIERSTRASS</a> : thm
<a name="line159"></a>    val <a href="#BOUNDED_FRONTIER-val">BOUNDED_FRONTIER</a> : thm
<a name="line160"></a>    val <a href="#BOUNDED_HAS_INF-val">BOUNDED_HAS_INF</a> : thm
<a name="line161"></a>    val <a href="#BOUNDED_HAS_SUP-val">BOUNDED_HAS_SUP</a> : thm
<a name="line162"></a>    val <a href="#BOUNDED_INCREASING_CONVERGENT-val">BOUNDED_INCREASING_CONVERGENT</a> : thm
<a name="line163"></a>    val <a href="#BOUNDED_INSERT-val">BOUNDED_INSERT</a> : thm
<a name="line164"></a>    val <a href="#BOUNDED_INTER-val">BOUNDED_INTER</a> : thm
<a name="line165"></a>    val <a href="#BOUNDED_INTERIOR-val">BOUNDED_INTERIOR</a> : thm
<a name="line166"></a>    val <a href="#BOUNDED_INTERVAL-val">BOUNDED_INTERVAL</a> : thm
<a name="line167"></a>    val <a href="#BOUNDED_LINEAR_IMAGE-val">BOUNDED_LINEAR_IMAGE</a> : thm
<a name="line168"></a>    val <a href="#BOUNDED_NEGATIONS-val">BOUNDED_NEGATIONS</a> : thm
<a name="line169"></a>    val <a href="#BOUNDED_PARTIAL_SUMS-val">BOUNDED_PARTIAL_SUMS</a> : thm
<a name="line170"></a>    val <a href="#BOUNDED_POS-val">BOUNDED_POS</a> : thm
<a name="line171"></a>    val <a href="#BOUNDED_POS_LT-val">BOUNDED_POS_LT</a> : thm
<a name="line172"></a>    val <a href="#BOUNDED_SCALING-val">BOUNDED_SCALING</a> : thm
<a name="line173"></a>    val <a href="#BOUNDED_SING-val">BOUNDED_SING</a> : thm
<a name="line174"></a>    val <a href="#BOUNDED_SPHERE-val">BOUNDED_SPHERE</a> : thm
<a name="line175"></a>    val <a href="#BOUNDED_SUBSET-val">BOUNDED_SUBSET</a> : thm
<a name="line176"></a>    val <a href="#BOUNDED_SUBSET_BALL-val">BOUNDED_SUBSET_BALL</a> : thm
<a name="line177"></a>    val <a href="#BOUNDED_SUBSET_CBALL-val">BOUNDED_SUBSET_CBALL</a> : thm
<a name="line178"></a>    val <a href="#BOUNDED_SUBSET_CLOSED_INTERVAL-val">BOUNDED_SUBSET_CLOSED_INTERVAL</a> : thm
<a name="line179"></a>    val <a href="#BOUNDED_SUBSET_CLOSED_INTERVAL_SYMMETRIC-val">BOUNDED_SUBSET_CLOSED_INTERVAL_SYMMETRIC</a> : thm
<a name="line180"></a>    val <a href="#BOUNDED_SUBSET_OPEN_INTERVAL-val">BOUNDED_SUBSET_OPEN_INTERVAL</a> : thm
<a name="line181"></a>    val <a href="#BOUNDED_SUBSET_OPEN_INTERVAL_SYMMETRIC-val">BOUNDED_SUBSET_OPEN_INTERVAL_SYMMETRIC</a> : thm
<a name="line182"></a>    val <a href="#BOUNDED_SUMS-val">BOUNDED_SUMS</a> : thm
<a name="line183"></a>    val <a href="#BOUNDED_SUMS_IMAGE-val">BOUNDED_SUMS_IMAGE</a> : thm
<a name="line184"></a>    val <a href="#BOUNDED_SUMS_IMAGES-val">BOUNDED_SUMS_IMAGES</a> : thm
<a name="line185"></a>    val <a href="#BOUNDED_TRANSLATION-val">BOUNDED_TRANSLATION</a> : thm
<a name="line186"></a>    val <a href="#BOUNDED_TRANSLATION_EQ-val">BOUNDED_TRANSLATION_EQ</a> : thm
<a name="line187"></a>    val <a href="#BOUNDED_UNIFORMLY_CONTINUOUS_IMAGE-val">BOUNDED_UNIFORMLY_CONTINUOUS_IMAGE</a> : thm
<a name="line188"></a>    val <a href="#BOUNDED_UNION-val">BOUNDED_UNION</a> : thm
<a name="line189"></a>    val <a href="#CARD_EQ_BALL-val">CARD_EQ_BALL</a> : thm
<a name="line190"></a>    val <a href="#CARD_EQ_CBALL-val">CARD_EQ_CBALL</a> : thm
<a name="line191"></a>    val <a href="#CARD_EQ_EUCLIDEAN-val">CARD_EQ_EUCLIDEAN</a> : thm
<a name="line192"></a>    val <a href="#CARD_EQ_INTERVAL-val">CARD_EQ_INTERVAL</a> : thm
<a name="line193"></a>    val <a href="#CARD_EQ_OPEN-val">CARD_EQ_OPEN</a> : thm
<a name="line194"></a>    val <a href="#CARD_EQ_REAL-val">CARD_EQ_REAL</a> : thm
<a name="line195"></a>    val <a href="#CARD_EQ_REAL_IMP_UNCOUNTABLE-val">CARD_EQ_REAL_IMP_UNCOUNTABLE</a> : thm
<a name="line196"></a>    val <a href="#CARD_FRONTIER_INTERVAL-val">CARD_FRONTIER_INTERVAL</a> : thm
<a name="line197"></a>    val <a href="#CARD_GE_DIM_INDEPENDENT-val">CARD_GE_DIM_INDEPENDENT</a> : thm
<a name="line198"></a>    val <a href="#CARD_STDBASIS-val">CARD_STDBASIS</a> : thm
<a name="line199"></a>    val <a href="#CAUCHY-val">CAUCHY</a> : thm
<a name="line200"></a>    val <a href="#CAUCHY_CONTINUOUS_EXTENDS_TO_CLOSURE-val">CAUCHY_CONTINUOUS_EXTENDS_TO_CLOSURE</a> : thm
<a name="line201"></a>    val <a href="#CAUCHY_CONTINUOUS_IMP_CONTINUOUS-val">CAUCHY_CONTINUOUS_IMP_CONTINUOUS</a> : thm
<a name="line202"></a>    val <a href="#CAUCHY_CONTINUOUS_UNIQUENESS_LEMMA-val">CAUCHY_CONTINUOUS_UNIQUENESS_LEMMA</a> : thm
<a name="line203"></a>    val <a href="#CAUCHY_IMP_BOUNDED-val">CAUCHY_IMP_BOUNDED</a> : thm
<a name="line204"></a>    val <a href="#CAUCHY_ISOMETRIC-val">CAUCHY_ISOMETRIC</a> : thm
<a name="line205"></a>    val <a href="#CBALL_DIFF_BALL-val">CBALL_DIFF_BALL</a> : thm
<a name="line206"></a>    val <a href="#CBALL_DIFF_SPHERE-val">CBALL_DIFF_SPHERE</a> : thm
<a name="line207"></a>    val <a href="#CBALL_EMPTY-val">CBALL_EMPTY</a> : thm
<a name="line208"></a>    val <a href="#CBALL_EQ_EMPTY-val">CBALL_EQ_EMPTY</a> : thm
<a name="line209"></a>    val <a href="#CBALL_EQ_SING-val">CBALL_EQ_SING</a> : thm
<a name="line210"></a>    val <a href="#CBALL_INTERVAL-val">CBALL_INTERVAL</a> : thm
<a name="line211"></a>    val <a href="#CBALL_INTERVAL_0-val">CBALL_INTERVAL_0</a> : thm
<a name="line212"></a>    val <a href="#CBALL_LINEAR_IMAGE-val">CBALL_LINEAR_IMAGE</a> : thm
<a name="line213"></a>    val <a href="#CBALL_MAX_UNION-val">CBALL_MAX_UNION</a> : thm
<a name="line214"></a>    val <a href="#CBALL_MIN_INTER-val">CBALL_MIN_INTER</a> : thm
<a name="line215"></a>    val <a href="#CBALL_SCALING-val">CBALL_SCALING</a> : thm
<a name="line216"></a>    val <a href="#CBALL_SING-val">CBALL_SING</a> : thm
<a name="line217"></a>    val <a href="#CBALL_TRANSLATION-val">CBALL_TRANSLATION</a> : thm
<a name="line218"></a>    val <a href="#CBALL_TRIVIAL-val">CBALL_TRIVIAL</a> : thm
<a name="line219"></a>    val <a href="#CENTRE_IN_BALL-val">CENTRE_IN_BALL</a> : thm
<a name="line220"></a>    val <a href="#CENTRE_IN_CBALL-val">CENTRE_IN_CBALL</a> : thm
<a name="line221"></a>    val <a href="#CLOPEN-val">CLOPEN</a> : thm
<a name="line222"></a>    val <a href="#CLOPEN_BIGUNION_COMPONENTS-val">CLOPEN_BIGUNION_COMPONENTS</a> : thm
<a name="line223"></a>    val <a href="#CLOPEN_IN_COMPONENTS-val">CLOPEN_IN_COMPONENTS</a> : thm
<a name="line224"></a>    val <a href="#CLOSED-val">CLOSED</a> : thm
<a name="line225"></a>    val <a href="#CLOSED_APPROACHABLE-val">CLOSED_APPROACHABLE</a> : thm
<a name="line226"></a>    val <a href="#CLOSED_AS_GDELTA-val">CLOSED_AS_GDELTA</a> : thm
<a name="line227"></a>    val <a href="#CLOSED_BIGINTER-val">CLOSED_BIGINTER</a> : thm
<a name="line228"></a>    val <a href="#CLOSED_BIGINTER_COMPACT-val">CLOSED_BIGINTER_COMPACT</a> : thm
<a name="line229"></a>    val <a href="#CLOSED_BIGUNION-val">CLOSED_BIGUNION</a> : thm
<a name="line230"></a>    val <a href="#CLOSED_CBALL-val">CLOSED_CBALL</a> : thm
<a name="line231"></a>    val <a href="#CLOSED_CLOSURE-val">CLOSED_CLOSURE</a> : thm
<a name="line232"></a>    val <a href="#CLOSED_COMPACT_DIFFERENCES-val">CLOSED_COMPACT_DIFFERENCES</a> : thm
<a name="line233"></a>    val <a href="#CLOSED_COMPACT_SUMS-val">CLOSED_COMPACT_SUMS</a> : thm
<a name="line234"></a>    val <a href="#CLOSED_COMPONENTS-val">CLOSED_COMPONENTS</a> : thm
<a name="line235"></a>    val <a href="#CLOSED_CONNECTED_COMPONENT-val">CLOSED_CONNECTED_COMPONENT</a> : thm
<a name="line236"></a>    val <a href="#CLOSED_CONTAINS_SEQUENTIAL_LIMIT-val">CLOSED_CONTAINS_SEQUENTIAL_LIMIT</a> : thm
<a name="line237"></a>    val <a href="#CLOSED_DIFF-val">CLOSED_DIFF</a> : thm
<a name="line238"></a>    val <a href="#CLOSED_DIFF_OPEN_INTERVAL-val">CLOSED_DIFF_OPEN_INTERVAL</a> : thm
<a name="line239"></a>    val <a href="#CLOSED_EMPTY-val">CLOSED_EMPTY</a> : thm
<a name="line240"></a>    val <a href="#CLOSED_FIP-val">CLOSED_FIP</a> : thm
<a name="line241"></a>    val <a href="#CLOSED_FORALL-val">CLOSED_FORALL</a> : thm
<a name="line242"></a>    val <a href="#CLOSED_FORALL_IN-val">CLOSED_FORALL_IN</a> : thm
<a name="line243"></a>    val <a href="#CLOSED_HALFSPACE_COMPONENT_GE-val">CLOSED_HALFSPACE_COMPONENT_GE</a> : thm
<a name="line244"></a>    val <a href="#CLOSED_HALFSPACE_COMPONENT_LE-val">CLOSED_HALFSPACE_COMPONENT_LE</a> : thm
<a name="line245"></a>    val <a href="#CLOSED_HALFSPACE_GE-val">CLOSED_HALFSPACE_GE</a> : thm
<a name="line246"></a>    val <a href="#CLOSED_HALFSPACE_LE-val">CLOSED_HALFSPACE_LE</a> : thm
<a name="line247"></a>    val <a href="#CLOSED_HYPERPLANE-val">CLOSED_HYPERPLANE</a> : thm
<a name="line248"></a>    val <a href="#CLOSED_IMP_FIP-val">CLOSED_IMP_FIP</a> : thm
<a name="line249"></a>    val <a href="#CLOSED_IMP_FIP_COMPACT-val">CLOSED_IMP_FIP_COMPACT</a> : thm
<a name="line250"></a>    val <a href="#CLOSED_IMP_LOCALLY_COMPACT-val">CLOSED_IMP_LOCALLY_COMPACT</a> : thm
<a name="line251"></a>    val <a href="#CLOSED_IN-val">CLOSED_IN</a> : thm
<a name="line252"></a>    val <a href="#CLOSED_INJECTIVE_IMAGE_SUBSPACE-val">CLOSED_INJECTIVE_IMAGE_SUBSPACE</a> : thm
<a name="line253"></a>    val <a href="#CLOSED_INJECTIVE_LINEAR_IMAGE-val">CLOSED_INJECTIVE_LINEAR_IMAGE</a> : thm
<a name="line254"></a>    val <a href="#CLOSED_INJECTIVE_LINEAR_IMAGE_EQ-val">CLOSED_INJECTIVE_LINEAR_IMAGE_EQ</a> : thm
<a name="line255"></a>    val <a href="#CLOSED_INSERT-val">CLOSED_INSERT</a> : thm
<a name="line256"></a>    val <a href="#CLOSED_INTER-val">CLOSED_INTER</a> : thm
<a name="line257"></a>    val <a href="#CLOSED_INTERVAL-val">CLOSED_INTERVAL</a> : thm
<a name="line258"></a>    val <a href="#CLOSED_INTERVAL_EQ-val">CLOSED_INTERVAL_EQ</a> : thm
<a name="line259"></a>    val <a href="#CLOSED_INTERVAL_IMAGE_UNIT_INTERVAL-val">CLOSED_INTERVAL_IMAGE_UNIT_INTERVAL</a> : thm
<a name="line260"></a>    val <a href="#CLOSED_INTERVAL_LEFT-val">CLOSED_INTERVAL_LEFT</a> : thm
<a name="line261"></a>    val <a href="#CLOSED_INTERVAL_RIGHT-val">CLOSED_INTERVAL_RIGHT</a> : thm
<a name="line262"></a>    val <a href="#CLOSED_INTER_COMPACT-val">CLOSED_INTER_COMPACT</a> : thm
<a name="line263"></a>    val <a href="#CLOSED_IN_CLOSED-val">CLOSED_IN_CLOSED</a> : thm
<a name="line264"></a>    val <a href="#CLOSED_IN_CLOSED_EQ-val">CLOSED_IN_CLOSED_EQ</a> : thm
<a name="line265"></a>    val <a href="#CLOSED_IN_CLOSED_INTER-val">CLOSED_IN_CLOSED_INTER</a> : thm
<a name="line266"></a>    val <a href="#CLOSED_IN_CLOSED_TRANS-val">CLOSED_IN_CLOSED_TRANS</a> : thm
<a name="line267"></a>    val <a href="#CLOSED_IN_COMPACT-val">CLOSED_IN_COMPACT</a> : thm
<a name="line268"></a>    val <a href="#CLOSED_IN_COMPACT_EQ-val">CLOSED_IN_COMPACT_EQ</a> : thm
<a name="line269"></a>    val <a href="#CLOSED_IN_COMPONENT-val">CLOSED_IN_COMPONENT</a> : thm
<a name="line270"></a>    val <a href="#CLOSED_IN_CONNECTED_COMPONENT-val">CLOSED_IN_CONNECTED_COMPONENT</a> : thm
<a name="line271"></a>    val <a href="#CLOSED_IN_INTER_CLOSED-val">CLOSED_IN_INTER_CLOSED</a> : thm
<a name="line272"></a>    val <a href="#CLOSED_IN_INTER_CLOSURE-val">CLOSED_IN_INTER_CLOSURE</a> : thm
<a name="line273"></a>    val <a href="#CLOSED_IN_LIMPT-val">CLOSED_IN_LIMPT</a> : thm
<a name="line274"></a>    val <a href="#CLOSED_IN_REFL-val">CLOSED_IN_REFL</a> : thm
<a name="line275"></a>    val <a href="#CLOSED_IN_SING-val">CLOSED_IN_SING</a> : thm
<a name="line276"></a>    val <a href="#CLOSED_IN_SUBSET_TRANS-val">CLOSED_IN_SUBSET_TRANS</a> : thm
<a name="line277"></a>    val <a href="#CLOSED_IN_TRANS-val">CLOSED_IN_TRANS</a> : thm
<a name="line278"></a>    val <a href="#CLOSED_IN_TRANS_EQ-val">CLOSED_IN_TRANS_EQ</a> : thm
<a name="line279"></a>    val <a href="#CLOSED_LIMPT-val">CLOSED_LIMPT</a> : thm
<a name="line280"></a>    val <a href="#CLOSED_LIMPTS-val">CLOSED_LIMPTS</a> : thm
<a name="line281"></a>    val <a href="#CLOSED_MAP_CLOSURES-val">CLOSED_MAP_CLOSURES</a> : thm
<a name="line282"></a>    val <a href="#CLOSED_MAP_FROM_COMPOSITION_INJECTIVE-val">CLOSED_MAP_FROM_COMPOSITION_INJECTIVE</a> : thm
<a name="line283"></a>    val <a href="#CLOSED_MAP_FROM_COMPOSITION_SURJECTIVE-val">CLOSED_MAP_FROM_COMPOSITION_SURJECTIVE</a> : thm
<a name="line284"></a>    val <a href="#CLOSED_MAP_IFF_UPPER_HEMICONTINUOUS_PREIMAGE-val">CLOSED_MAP_IFF_UPPER_HEMICONTINUOUS_PREIMAGE</a> : thm
<a name="line285"></a>    val <a href="#CLOSED_MAP_IMP_OPEN_MAP-val">CLOSED_MAP_IMP_OPEN_MAP</a> : thm
<a name="line286"></a>    val <a href="#CLOSED_MAP_IMP_QUOTIENT_MAP-val">CLOSED_MAP_IMP_QUOTIENT_MAP</a> : thm
<a name="line287"></a>    val <a href="#CLOSED_MAP_OPEN_SUPERSET_PREIMAGE-val">CLOSED_MAP_OPEN_SUPERSET_PREIMAGE</a> : thm
<a name="line288"></a>    val <a href="#CLOSED_MAP_OPEN_SUPERSET_PREIMAGE_EQ-val">CLOSED_MAP_OPEN_SUPERSET_PREIMAGE_EQ</a> : thm
<a name="line289"></a>    val <a href="#CLOSED_MAP_OPEN_SUPERSET_PREIMAGE_POINT-val">CLOSED_MAP_OPEN_SUPERSET_PREIMAGE_POINT</a> : thm
<a name="line290"></a>    val <a href="#CLOSED_MAP_RESTRICT-val">CLOSED_MAP_RESTRICT</a> : thm
<a name="line291"></a>    val <a href="#CLOSED_NEGATIONS-val">CLOSED_NEGATIONS</a> : thm
<a name="line292"></a>    val <a href="#CLOSED_OPEN_INTERVAL-val">CLOSED_OPEN_INTERVAL</a> : thm
<a name="line293"></a>    val <a href="#CLOSED_POSITIVE_ORTHANT-val">CLOSED_POSITIVE_ORTHANT</a> : thm
<a name="line294"></a>    val <a href="#CLOSED_SCALING-val">CLOSED_SCALING</a> : thm
<a name="line295"></a>    val <a href="#CLOSED_SEGMENT_LINEAR_IMAGE-val">CLOSED_SEGMENT_LINEAR_IMAGE</a> : thm
<a name="line296"></a>    val <a href="#CLOSED_SEQUENTIAL_LIMITS-val">CLOSED_SEQUENTIAL_LIMITS</a> : thm
<a name="line297"></a>    val <a href="#CLOSED_SING-val">CLOSED_SING</a> : thm
<a name="line298"></a>    val <a href="#CLOSED_SPHERE-val">CLOSED_SPHERE</a> : thm
<a name="line299"></a>    val <a href="#CLOSED_STANDARD_HYPERPLANE-val">CLOSED_STANDARD_HYPERPLANE</a> : thm
<a name="line300"></a>    val <a href="#CLOSED_SUBSET-val">CLOSED_SUBSET</a> : thm
<a name="line301"></a>    val <a href="#CLOSED_SUBSET_EQ-val">CLOSED_SUBSET_EQ</a> : thm
<a name="line302"></a>    val <a href="#CLOSED_SUBSTANDARD-val">CLOSED_SUBSTANDARD</a> : thm
<a name="line303"></a>    val <a href="#CLOSED_UNION-val">CLOSED_UNION</a> : thm
<a name="line304"></a>    val <a href="#CLOSED_UNION_COMPACT_SUBSETS-val">CLOSED_UNION_COMPACT_SUBSETS</a> : thm
<a name="line305"></a>    val <a href="#CLOSED_UNIV-val">CLOSED_UNIV</a> : thm
<a name="line306"></a>    val <a href="#CLOSEST_POINT_EXISTS-val">CLOSEST_POINT_EXISTS</a> : thm
<a name="line307"></a>    val <a href="#CLOSEST_POINT_IN_FRONTIER-val">CLOSEST_POINT_IN_FRONTIER</a> : thm
<a name="line308"></a>    val <a href="#CLOSEST_POINT_IN_INTERIOR-val">CLOSEST_POINT_IN_INTERIOR</a> : thm
<a name="line309"></a>    val <a href="#CLOSEST_POINT_IN_SET-val">CLOSEST_POINT_IN_SET</a> : thm
<a name="line310"></a>    val <a href="#CLOSEST_POINT_LE-val">CLOSEST_POINT_LE</a> : thm
<a name="line311"></a>    val <a href="#CLOSEST_POINT_REFL-val">CLOSEST_POINT_REFL</a> : thm
<a name="line312"></a>    val <a href="#CLOSEST_POINT_SELF-val">CLOSEST_POINT_SELF</a> : thm
<a name="line313"></a>    val <a href="#CLOSURE_APPROACHABLE-val">CLOSURE_APPROACHABLE</a> : thm
<a name="line314"></a>    val <a href="#CLOSURE_BALL-val">CLOSURE_BALL</a> : thm
<a name="line315"></a>    val <a href="#CLOSURE_BIGINTER_SUBSET-val">CLOSURE_BIGINTER_SUBSET</a> : thm
<a name="line316"></a>    val <a href="#CLOSURE_BIGUNION-val">CLOSURE_BIGUNION</a> : thm
<a name="line317"></a>    val <a href="#CLOSURE_BOUNDED_LINEAR_IMAGE-val">CLOSURE_BOUNDED_LINEAR_IMAGE</a> : thm
<a name="line318"></a>    val <a href="#CLOSURE_CLOSED-val">CLOSURE_CLOSED</a> : thm
<a name="line319"></a>    val <a href="#CLOSURE_CLOSURE-val">CLOSURE_CLOSURE</a> : thm
<a name="line320"></a>    val <a href="#CLOSURE_COMPLEMENT-val">CLOSURE_COMPLEMENT</a> : thm
<a name="line321"></a>    val <a href="#CLOSURE_EMPTY-val">CLOSURE_EMPTY</a> : thm
<a name="line322"></a>    val <a href="#CLOSURE_EQ-val">CLOSURE_EQ</a> : thm
<a name="line323"></a>    val <a href="#CLOSURE_EQ_EMPTY-val">CLOSURE_EQ_EMPTY</a> : thm
<a name="line324"></a>    val <a href="#CLOSURE_HALFSPACE_COMPONENT_GT-val">CLOSURE_HALFSPACE_COMPONENT_GT</a> : thm
<a name="line325"></a>    val <a href="#CLOSURE_HALFSPACE_COMPONENT_LT-val">CLOSURE_HALFSPACE_COMPONENT_LT</a> : thm
<a name="line326"></a>    val <a href="#CLOSURE_HALFSPACE_GT-val">CLOSURE_HALFSPACE_GT</a> : thm
<a name="line327"></a>    val <a href="#CLOSURE_HALFSPACE_LT-val">CLOSURE_HALFSPACE_LT</a> : thm
<a name="line328"></a>    val <a href="#CLOSURE_HULL-val">CLOSURE_HULL</a> : thm
<a name="line329"></a>    val <a href="#CLOSURE_HYPERPLANE-val">CLOSURE_HYPERPLANE</a> : thm
<a name="line330"></a>    val <a href="#CLOSURE_IMAGE_BOUNDED-val">CLOSURE_IMAGE_BOUNDED</a> : thm
<a name="line331"></a>    val <a href="#CLOSURE_IMAGE_CLOSURE-val">CLOSURE_IMAGE_CLOSURE</a> : thm
<a name="line332"></a>    val <a href="#CLOSURE_INJECTIVE_LINEAR_IMAGE-val">CLOSURE_INJECTIVE_LINEAR_IMAGE</a> : thm
<a name="line333"></a>    val <a href="#CLOSURE_INTERIOR-val">CLOSURE_INTERIOR</a> : thm
<a name="line334"></a>    val <a href="#CLOSURE_INTERIOR_IDEMP-val">CLOSURE_INTERIOR_IDEMP</a> : thm
<a name="line335"></a>    val <a href="#CLOSURE_INTERIOR_UNION_CLOSED-val">CLOSURE_INTERIOR_UNION_CLOSED</a> : thm
<a name="line336"></a>    val <a href="#CLOSURE_INTERVAL-val">CLOSURE_INTERVAL</a> : thm
<a name="line337"></a>    val <a href="#CLOSURE_INTER_SUBSET-val">CLOSURE_INTER_SUBSET</a> : thm
<a name="line338"></a>    val <a href="#CLOSURE_LINEAR_IMAGE_SUBSET-val">CLOSURE_LINEAR_IMAGE_SUBSET</a> : thm
<a name="line339"></a>    val <a href="#CLOSURE_MINIMAL-val">CLOSURE_MINIMAL</a> : thm
<a name="line340"></a>    val <a href="#CLOSURE_MINIMAL_EQ-val">CLOSURE_MINIMAL_EQ</a> : thm
<a name="line341"></a>    val <a href="#CLOSURE_NEGATIONS-val">CLOSURE_NEGATIONS</a> : thm
<a name="line342"></a>    val <a href="#CLOSURE_NONEMPTY_OPEN_INTER-val">CLOSURE_NONEMPTY_OPEN_INTER</a> : thm
<a name="line343"></a>    val <a href="#CLOSURE_OPEN_INTERVAL-val">CLOSURE_OPEN_INTERVAL</a> : thm
<a name="line344"></a>    val <a href="#CLOSURE_OPEN_INTER_CLOSURE-val">CLOSURE_OPEN_INTER_CLOSURE</a> : thm
<a name="line345"></a>    val <a href="#CLOSURE_OPEN_INTER_SUPERSET-val">CLOSURE_OPEN_INTER_SUPERSET</a> : thm
<a name="line346"></a>    val <a href="#CLOSURE_OPEN_IN_INTER_CLOSURE-val">CLOSURE_OPEN_IN_INTER_CLOSURE</a> : thm
<a name="line347"></a>    val <a href="#CLOSURE_SEQUENTIAL-val">CLOSURE_SEQUENTIAL</a> : thm
<a name="line348"></a>    val <a href="#CLOSURE_SING-val">CLOSURE_SING</a> : thm
<a name="line349"></a>    val <a href="#CLOSURE_SUBSET-val">CLOSURE_SUBSET</a> : thm
<a name="line350"></a>    val <a href="#CLOSURE_SUBSET_EQ-val">CLOSURE_SUBSET_EQ</a> : thm
<a name="line351"></a>    val <a href="#CLOSURE_SUMS-val">CLOSURE_SUMS</a> : thm
<a name="line352"></a>    val <a href="#CLOSURE_UNION-val">CLOSURE_UNION</a> : thm
<a name="line353"></a>    val <a href="#CLOSURE_UNION_FRONTIER-val">CLOSURE_UNION_FRONTIER</a> : thm
<a name="line354"></a>    val <a href="#CLOSURE_UNIQUE-val">CLOSURE_UNIQUE</a> : thm
<a name="line355"></a>    val <a href="#CLOSURE_UNIV-val">CLOSURE_UNIV</a> : thm
<a name="line356"></a>    val <a href="#COBOUNDED_IMP_UNBOUNDED-val">COBOUNDED_IMP_UNBOUNDED</a> : thm
<a name="line357"></a>    val <a href="#COBOUNDED_INTER_UNBOUNDED-val">COBOUNDED_INTER_UNBOUNDED</a> : thm
<a name="line358"></a>    val <a href="#COLLINEAR_1-val">COLLINEAR_1</a> : thm
<a name="line359"></a>    val <a href="#COLLINEAR_2-val">COLLINEAR_2</a> : thm
<a name="line360"></a>    val <a href="#COLLINEAR_3-val">COLLINEAR_3</a> : thm
<a name="line361"></a>    val <a href="#COLLINEAR_3_EXPAND-val">COLLINEAR_3_EXPAND</a> : thm
<a name="line362"></a>    val <a href="#COLLINEAR_3_TRANS-val">COLLINEAR_3_TRANS</a> : thm
<a name="line363"></a>    val <a href="#COLLINEAR_4_3-val">COLLINEAR_4_3</a> : thm
<a name="line364"></a>    val <a href="#COLLINEAR_BETWEEN_CASES-val">COLLINEAR_BETWEEN_CASES</a> : thm
<a name="line365"></a>    val <a href="#COLLINEAR_DIST_BETWEEN-val">COLLINEAR_DIST_BETWEEN</a> : thm
<a name="line366"></a>    val <a href="#COLLINEAR_DIST_IN_CLOSED_SEGMENT-val">COLLINEAR_DIST_IN_CLOSED_SEGMENT</a> : thm
<a name="line367"></a>    val <a href="#COLLINEAR_DIST_IN_OPEN_SEGMENT-val">COLLINEAR_DIST_IN_OPEN_SEGMENT</a> : thm
<a name="line368"></a>    val <a href="#COLLINEAR_EMPTY-val">COLLINEAR_EMPTY</a> : thm
<a name="line369"></a>    val <a href="#COLLINEAR_LEMMA-val">COLLINEAR_LEMMA</a> : thm
<a name="line370"></a>    val <a href="#COLLINEAR_LEMMA_ALT-val">COLLINEAR_LEMMA_ALT</a> : thm
<a name="line371"></a>    val <a href="#COLLINEAR_MIDPOINT-val">COLLINEAR_MIDPOINT</a> : thm
<a name="line372"></a>    val <a href="#COLLINEAR_SING-val">COLLINEAR_SING</a> : thm
<a name="line373"></a>    val <a href="#COLLINEAR_SMALL-val">COLLINEAR_SMALL</a> : thm
<a name="line374"></a>    val <a href="#COLLINEAR_SUBSET-val">COLLINEAR_SUBSET</a> : thm
<a name="line375"></a>    val <a href="#COLLINEAR_TRIPLES-val">COLLINEAR_TRIPLES</a> : thm
<a name="line376"></a>    val <a href="#COMPACT_AFFINITY-val">COMPACT_AFFINITY</a> : thm
<a name="line377"></a>    val <a href="#COMPACT_ATTAINS_INF-val">COMPACT_ATTAINS_INF</a> : thm
<a name="line378"></a>    val <a href="#COMPACT_ATTAINS_SUP-val">COMPACT_ATTAINS_SUP</a> : thm
<a name="line379"></a>    val <a href="#COMPACT_BIGINTER-val">COMPACT_BIGINTER</a> : thm
<a name="line380"></a>    val <a href="#COMPACT_BIGUNION-val">COMPACT_BIGUNION</a> : thm
<a name="line381"></a>    val <a href="#COMPACT_CBALL-val">COMPACT_CBALL</a> : thm
<a name="line382"></a>    val <a href="#COMPACT_CHAIN-val">COMPACT_CHAIN</a> : thm
<a name="line383"></a>    val <a href="#COMPACT_CLOSED_DIFFERENCES-val">COMPACT_CLOSED_DIFFERENCES</a> : thm
<a name="line384"></a>    val <a href="#COMPACT_CLOSED_SUMS-val">COMPACT_CLOSED_SUMS</a> : thm
<a name="line385"></a>    val <a href="#COMPACT_CLOSURE-val">COMPACT_CLOSURE</a> : thm
<a name="line386"></a>    val <a href="#COMPACT_COMPONENTS-val">COMPACT_COMPONENTS</a> : thm
<a name="line387"></a>    val <a href="#COMPACT_CONTINUOUS_IMAGE-val">COMPACT_CONTINUOUS_IMAGE</a> : thm
<a name="line388"></a>    val <a href="#COMPACT_CONTINUOUS_IMAGE_EQ-val">COMPACT_CONTINUOUS_IMAGE_EQ</a> : thm
<a name="line389"></a>    val <a href="#COMPACT_DIFF-val">COMPACT_DIFF</a> : thm
<a name="line390"></a>    val <a href="#COMPACT_EMPTY-val">COMPACT_EMPTY</a> : thm
<a name="line391"></a>    val <a href="#COMPACT_EQ_BOLZANO_WEIERSTRASS-val">COMPACT_EQ_BOLZANO_WEIERSTRASS</a> : thm
<a name="line392"></a>    val <a href="#COMPACT_EQ_BOUNDED_CLOSED-val">COMPACT_EQ_BOUNDED_CLOSED</a> : thm
<a name="line393"></a>    val <a href="#COMPACT_EQ_HEINE_BOREL-val">COMPACT_EQ_HEINE_BOREL</a> : thm
<a name="line394"></a>    val <a href="#COMPACT_EQ_HEINE_BOREL_SUBTOPOLOGY-val">COMPACT_EQ_HEINE_BOREL_SUBTOPOLOGY</a> : thm
<a name="line395"></a>    val <a href="#COMPACT_FIP-val">COMPACT_FIP</a> : thm
<a name="line396"></a>    val <a href="#COMPACT_FRONTIER-val">COMPACT_FRONTIER</a> : thm
<a name="line397"></a>    val <a href="#COMPACT_FRONTIER_BOUNDED-val">COMPACT_FRONTIER_BOUNDED</a> : thm
<a name="line398"></a>    val <a href="#COMPACT_IMP_BOUNDED-val">COMPACT_IMP_BOUNDED</a> : thm
<a name="line399"></a>    val <a href="#COMPACT_IMP_CLOSED-val">COMPACT_IMP_CLOSED</a> : thm
<a name="line400"></a>    val <a href="#COMPACT_IMP_COMPLETE-val">COMPACT_IMP_COMPLETE</a> : thm
<a name="line401"></a>    val <a href="#COMPACT_IMP_FIP-val">COMPACT_IMP_FIP</a> : thm
<a name="line402"></a>    val <a href="#COMPACT_IMP_HEINE_BOREL-val">COMPACT_IMP_HEINE_BOREL</a> : thm
<a name="line403"></a>    val <a href="#COMPACT_IMP_TOTALLY_BOUNDED-val">COMPACT_IMP_TOTALLY_BOUNDED</a> : thm
<a name="line404"></a>    val <a href="#COMPACT_INSERT-val">COMPACT_INSERT</a> : thm
<a name="line405"></a>    val <a href="#COMPACT_INTER-val">COMPACT_INTER</a> : thm
<a name="line406"></a>    val <a href="#COMPACT_INTERVAL-val">COMPACT_INTERVAL</a> : thm
<a name="line407"></a>    val <a href="#COMPACT_INTERVAL_EQ-val">COMPACT_INTERVAL_EQ</a> : thm
<a name="line408"></a>    val <a href="#COMPACT_INTER_CLOSED-val">COMPACT_INTER_CLOSED</a> : thm
<a name="line409"></a>    val <a href="#COMPACT_LEMMA-val">COMPACT_LEMMA</a> : thm
<a name="line410"></a>    val <a href="#COMPACT_LINEAR_IMAGE-val">COMPACT_LINEAR_IMAGE</a> : thm
<a name="line411"></a>    val <a href="#COMPACT_NEGATIONS-val">COMPACT_NEGATIONS</a> : thm
<a name="line412"></a>    val <a href="#COMPACT_NEST-val">COMPACT_NEST</a> : thm
<a name="line413"></a>    val <a href="#COMPACT_REAL_LEMMA-val">COMPACT_REAL_LEMMA</a> : thm
<a name="line414"></a>    val <a href="#COMPACT_SCALING-val">COMPACT_SCALING</a> : thm
<a name="line415"></a>    val <a href="#COMPACT_SEQUENCE_WITH_LIMIT-val">COMPACT_SEQUENCE_WITH_LIMIT</a> : thm
<a name="line416"></a>    val <a href="#COMPACT_SING-val">COMPACT_SING</a> : thm
<a name="line417"></a>    val <a href="#COMPACT_SPHERE-val">COMPACT_SPHERE</a> : thm
<a name="line418"></a>    val <a href="#COMPACT_TRANSLATION-val">COMPACT_TRANSLATION</a> : thm
<a name="line419"></a>    val <a href="#COMPACT_TRANSLATION_EQ-val">COMPACT_TRANSLATION_EQ</a> : thm
<a name="line420"></a>    val <a href="#COMPACT_UNIFORMLY_CONTINUOUS-val">COMPACT_UNIFORMLY_CONTINUOUS</a> : thm
<a name="line421"></a>    val <a href="#COMPACT_UNIFORMLY_EQUICONTINUOUS-val">COMPACT_UNIFORMLY_EQUICONTINUOUS</a> : thm
<a name="line422"></a>    val <a href="#COMPACT_UNION-val">COMPACT_UNION</a> : thm
<a name="line423"></a>    val <a href="#COMPLEMENT_CONNECTED_COMPONENT_BIGUNION-val">COMPLEMENT_CONNECTED_COMPONENT_BIGUNION</a> : thm
<a name="line424"></a>    val <a href="#COMPLETE_EQ_CLOSED-val">COMPLETE_EQ_CLOSED</a> : thm
<a name="line425"></a>    val <a href="#COMPLETE_INJECTIVE_LINEAR_IMAGE-val">COMPLETE_INJECTIVE_LINEAR_IMAGE</a> : thm
<a name="line426"></a>    val <a href="#COMPLETE_INJECTIVE_LINEAR_IMAGE_EQ-val">COMPLETE_INJECTIVE_LINEAR_IMAGE_EQ</a> : thm
<a name="line427"></a>    val <a href="#COMPLETE_ISOMETRIC_IMAGE-val">COMPLETE_ISOMETRIC_IMAGE</a> : thm
<a name="line428"></a>    val <a href="#COMPLETE_UNIV-val">COMPLETE_UNIV</a> : thm
<a name="line429"></a>    val <a href="#COMPONENTS_EMPTY-val">COMPONENTS_EMPTY</a> : thm
<a name="line430"></a>    val <a href="#COMPONENTS_EQ-val">COMPONENTS_EQ</a> : thm
<a name="line431"></a>    val <a href="#COMPONENTS_EQ_EMPTY-val">COMPONENTS_EQ_EMPTY</a> : thm
<a name="line432"></a>    val <a href="#COMPONENTS_EQ_SING-val">COMPONENTS_EQ_SING</a> : thm
<a name="line433"></a>    val <a href="#COMPONENTS_EQ_SING_EXISTS-val">COMPONENTS_EQ_SING_EXISTS</a> : thm
<a name="line434"></a>    val <a href="#COMPONENTS_EQ_SING_N_EXISTS-val">COMPONENTS_EQ_SING_N_EXISTS</a> : thm
<a name="line435"></a>    val <a href="#COMPONENTS_INTERMEDIATE_SUBSET-val">COMPONENTS_INTERMEDIATE_SUBSET</a> : thm
<a name="line436"></a>    val <a href="#COMPONENTS_MAXIMAL-val">COMPONENTS_MAXIMAL</a> : thm
<a name="line437"></a>    val <a href="#COMPONENTS_NONOVERLAP-val">COMPONENTS_NONOVERLAP</a> : thm
<a name="line438"></a>    val <a href="#COMPONENTS_UNIQUE-val">COMPONENTS_UNIQUE</a> : thm
<a name="line439"></a>    val <a href="#COMPONENTS_UNIQUE_EQ-val">COMPONENTS_UNIQUE_EQ</a> : thm
<a name="line440"></a>    val <a href="#COMPONENTS_UNIV-val">COMPONENTS_UNIV</a> : thm
<a name="line441"></a>    val <a href="#CONDENSATION_POINT_IMP_LIMPT-val">CONDENSATION_POINT_IMP_LIMPT</a> : thm
<a name="line442"></a>    val <a href="#CONDENSATION_POINT_INFINITE_BALL-val">CONDENSATION_POINT_INFINITE_BALL</a> : thm
<a name="line443"></a>    val <a href="#CONDENSATION_POINT_INFINITE_BALL_CBALL-val">CONDENSATION_POINT_INFINITE_BALL_CBALL</a> : thm
<a name="line444"></a>    val <a href="#CONDENSATION_POINT_INFINITE_CBALL-val">CONDENSATION_POINT_INFINITE_CBALL</a> : thm
<a name="line445"></a>    val <a href="#CONDENSATION_POINT_OF_SUBSET-val">CONDENSATION_POINT_OF_SUBSET</a> : thm
<a name="line446"></a>    val <a href="#CONNECTED_BIGUNION-val">CONNECTED_BIGUNION</a> : thm
<a name="line447"></a>    val <a href="#CONNECTED_CHAIN-val">CONNECTED_CHAIN</a> : thm
<a name="line448"></a>    val <a href="#CONNECTED_CHAIN_GEN-val">CONNECTED_CHAIN_GEN</a> : thm
<a name="line449"></a>    val <a href="#CONNECTED_CLOPEN-val">CONNECTED_CLOPEN</a> : thm
<a name="line450"></a>    val <a href="#CONNECTED_CLOSED-val">CONNECTED_CLOSED</a> : thm
<a name="line451"></a>    val <a href="#CONNECTED_CLOSED_IN-val">CONNECTED_CLOSED_IN</a> : thm
<a name="line452"></a>    val <a href="#CONNECTED_CLOSED_IN_EQ-val">CONNECTED_CLOSED_IN_EQ</a> : thm
<a name="line453"></a>    val <a href="#CONNECTED_CLOSED_MONOTONE_PREIMAGE-val">CONNECTED_CLOSED_MONOTONE_PREIMAGE</a> : thm
<a name="line454"></a>    val <a href="#CONNECTED_CLOSED_SET-val">CONNECTED_CLOSED_SET</a> : thm
<a name="line455"></a>    val <a href="#CONNECTED_CLOSURE-val">CONNECTED_CLOSURE</a> : thm
<a name="line456"></a>    val <a href="#CONNECTED_COMPONENT_BIGUNION-val">CONNECTED_COMPONENT_BIGUNION</a> : thm
<a name="line457"></a>    val <a href="#CONNECTED_COMPONENT_DISJOINT-val">CONNECTED_COMPONENT_DISJOINT</a> : thm
<a name="line458"></a>    val <a href="#CONNECTED_COMPONENT_EMPTY-val">CONNECTED_COMPONENT_EMPTY</a> : thm
<a name="line459"></a>    val <a href="#CONNECTED_COMPONENT_EQ-val">CONNECTED_COMPONENT_EQ</a> : thm
<a name="line460"></a>    val <a href="#CONNECTED_COMPONENT_EQUIVALENCE_RELATION-val">CONNECTED_COMPONENT_EQUIVALENCE_RELATION</a> : thm
<a name="line461"></a>    val <a href="#CONNECTED_COMPONENT_EQ_EMPTY-val">CONNECTED_COMPONENT_EQ_EMPTY</a> : thm
<a name="line462"></a>    val <a href="#CONNECTED_COMPONENT_EQ_EQ-val">CONNECTED_COMPONENT_EQ_EQ</a> : thm
<a name="line463"></a>    val <a href="#CONNECTED_COMPONENT_EQ_SELF-val">CONNECTED_COMPONENT_EQ_SELF</a> : thm
<a name="line464"></a>    val <a href="#CONNECTED_COMPONENT_EQ_UNIV-val">CONNECTED_COMPONENT_EQ_UNIV</a> : thm
<a name="line465"></a>    val <a href="#CONNECTED_COMPONENT_IDEMP-val">CONNECTED_COMPONENT_IDEMP</a> : thm
<a name="line466"></a>    val <a href="#CONNECTED_COMPONENT_IN-val">CONNECTED_COMPONENT_IN</a> : thm
<a name="line467"></a>    val <a href="#CONNECTED_COMPONENT_INTERMEDIATE_SUBSET-val">CONNECTED_COMPONENT_INTERMEDIATE_SUBSET</a> : thm
<a name="line468"></a>    val <a href="#CONNECTED_COMPONENT_MAXIMAL-val">CONNECTED_COMPONENT_MAXIMAL</a> : thm
<a name="line469"></a>    val <a href="#CONNECTED_COMPONENT_MONO-val">CONNECTED_COMPONENT_MONO</a> : thm
<a name="line470"></a>    val <a href="#CONNECTED_COMPONENT_NONOVERLAP-val">CONNECTED_COMPONENT_NONOVERLAP</a> : thm
<a name="line471"></a>    val <a href="#CONNECTED_COMPONENT_OF_SUBSET-val">CONNECTED_COMPONENT_OF_SUBSET</a> : thm
<a name="line472"></a>    val <a href="#CONNECTED_COMPONENT_OVERLAP-val">CONNECTED_COMPONENT_OVERLAP</a> : thm
<a name="line473"></a>    val <a href="#CONNECTED_COMPONENT_REFL-val">CONNECTED_COMPONENT_REFL</a> : thm
<a name="line474"></a>    val <a href="#CONNECTED_COMPONENT_REFL_EQ-val">CONNECTED_COMPONENT_REFL_EQ</a> : thm
<a name="line475"></a>    val <a href="#CONNECTED_COMPONENT_SET-val">CONNECTED_COMPONENT_SET</a> : thm
<a name="line476"></a>    val <a href="#CONNECTED_COMPONENT_SUBSET-val">CONNECTED_COMPONENT_SUBSET</a> : thm
<a name="line477"></a>    val <a href="#CONNECTED_COMPONENT_SYM-val">CONNECTED_COMPONENT_SYM</a> : thm
<a name="line478"></a>    val <a href="#CONNECTED_COMPONENT_SYM_EQ-val">CONNECTED_COMPONENT_SYM_EQ</a> : thm
<a name="line479"></a>    val <a href="#CONNECTED_COMPONENT_TRANS-val">CONNECTED_COMPONENT_TRANS</a> : thm
<a name="line480"></a>    val <a href="#CONNECTED_COMPONENT_UNIQUE-val">CONNECTED_COMPONENT_UNIQUE</a> : thm
<a name="line481"></a>    val <a href="#CONNECTED_COMPONENT_UNIV-val">CONNECTED_COMPONENT_UNIV</a> : thm
<a name="line482"></a>    val <a href="#CONNECTED_CONNECTED_COMPONENT-val">CONNECTED_CONNECTED_COMPONENT</a> : thm
<a name="line483"></a>    val <a href="#CONNECTED_CONNECTED_COMPONENT_SET-val">CONNECTED_CONNECTED_COMPONENT_SET</a> : thm
<a name="line484"></a>    val <a href="#CONNECTED_CONTINUOUS_IMAGE-val">CONNECTED_CONTINUOUS_IMAGE</a> : thm
<a name="line485"></a>    val <a href="#CONNECTED_DIFF_OPEN_FROM_CLOSED-val">CONNECTED_DIFF_OPEN_FROM_CLOSED</a> : thm
<a name="line486"></a>    val <a href="#CONNECTED_DISJOINT_BIGUNION_OPEN_UNIQUE-val">CONNECTED_DISJOINT_BIGUNION_OPEN_UNIQUE</a> : thm
<a name="line487"></a>    val <a href="#CONNECTED_EMPTY-val">CONNECTED_EMPTY</a> : thm
<a name="line488"></a>    val <a href="#CONNECTED_EQUIVALENCE_RELATION-val">CONNECTED_EQUIVALENCE_RELATION</a> : thm
<a name="line489"></a>    val <a href="#CONNECTED_EQUIVALENCE_RELATION_GEN-val">CONNECTED_EQUIVALENCE_RELATION_GEN</a> : thm
<a name="line490"></a>    val <a href="#CONNECTED_EQ_COMPONENTS_SUBSET_SING-val">CONNECTED_EQ_COMPONENTS_SUBSET_SING</a> : thm
<a name="line491"></a>    val <a href="#CONNECTED_EQ_COMPONENTS_SUBSET_SING_EXISTS-val">CONNECTED_EQ_COMPONENTS_SUBSET_SING_EXISTS</a> : thm
<a name="line492"></a>    val <a href="#CONNECTED_EQ_CONNECTED_COMPONENTS_EQ-val">CONNECTED_EQ_CONNECTED_COMPONENTS_EQ</a> : thm
<a name="line493"></a>    val <a href="#CONNECTED_EQ_CONNECTED_COMPONENT_EQ-val">CONNECTED_EQ_CONNECTED_COMPONENT_EQ</a> : thm
<a name="line494"></a>    val <a href="#CONNECTED_FROM_CLOSED_UNION_AND_INTER-val">CONNECTED_FROM_CLOSED_UNION_AND_INTER</a> : thm
<a name="line495"></a>    val <a href="#CONNECTED_FROM_OPEN_UNION_AND_INTER-val">CONNECTED_FROM_OPEN_UNION_AND_INTER</a> : thm
<a name="line496"></a>    val <a href="#CONNECTED_IFF_CONNECTABLE_POINTS-val">CONNECTED_IFF_CONNECTABLE_POINTS</a> : thm
<a name="line497"></a>    val <a href="#CONNECTED_IFF_CONNECTED_COMPONENT-val">CONNECTED_IFF_CONNECTED_COMPONENT</a> : thm
<a name="line498"></a>    val <a href="#CONNECTED_IMP_PERFECT-val">CONNECTED_IMP_PERFECT</a> : thm
<a name="line499"></a>    val <a href="#CONNECTED_IMP_PERFECT_CLOSED-val">CONNECTED_IMP_PERFECT_CLOSED</a> : thm
<a name="line500"></a>    val <a href="#CONNECTED_INDUCTION-val">CONNECTED_INDUCTION</a> : thm
<a name="line501"></a>    val <a href="#CONNECTED_INDUCTION_SIMPLE-val">CONNECTED_INDUCTION_SIMPLE</a> : thm
<a name="line502"></a>    val <a href="#CONNECTED_INTERMEDIATE_CLOSURE-val">CONNECTED_INTERMEDIATE_CLOSURE</a> : thm
<a name="line503"></a>    val <a href="#CONNECTED_INTER_FRONTIER-val">CONNECTED_INTER_FRONTIER</a> : thm
<a name="line504"></a>    val <a href="#CONNECTED_IVT_COMPONENT-val">CONNECTED_IVT_COMPONENT</a> : thm
<a name="line505"></a>    val <a href="#CONNECTED_IVT_HYPERPLANE-val">CONNECTED_IVT_HYPERPLANE</a> : thm
<a name="line506"></a>    val <a href="#CONNECTED_LINEAR_IMAGE-val">CONNECTED_LINEAR_IMAGE</a> : thm
<a name="line507"></a>    val <a href="#CONNECTED_MONOTONE_QUOTIENT_PREIMAGE-val">CONNECTED_MONOTONE_QUOTIENT_PREIMAGE</a> : thm
<a name="line508"></a>    val <a href="#CONNECTED_MONOTONE_QUOTIENT_PREIMAGE_GEN-val">CONNECTED_MONOTONE_QUOTIENT_PREIMAGE_GEN</a> : thm
<a name="line509"></a>    val <a href="#CONNECTED_NEGATIONS-val">CONNECTED_NEGATIONS</a> : thm
<a name="line510"></a>    val <a href="#CONNECTED_NEST-val">CONNECTED_NEST</a> : thm
<a name="line511"></a>    val <a href="#CONNECTED_NEST_GEN-val">CONNECTED_NEST_GEN</a> : thm
<a name="line512"></a>    val <a href="#CONNECTED_OPEN_IN-val">CONNECTED_OPEN_IN</a> : thm
<a name="line513"></a>    val <a href="#CONNECTED_OPEN_IN_EQ-val">CONNECTED_OPEN_IN_EQ</a> : thm
<a name="line514"></a>    val <a href="#CONNECTED_OPEN_MONOTONE_PREIMAGE-val">CONNECTED_OPEN_MONOTONE_PREIMAGE</a> : thm
<a name="line515"></a>    val <a href="#CONNECTED_OPEN_SET-val">CONNECTED_OPEN_SET</a> : thm
<a name="line516"></a>    val <a href="#CONNECTED_REAL_LEMMA-val">CONNECTED_REAL_LEMMA</a> : thm
<a name="line517"></a>    val <a href="#CONNECTED_SCALING-val">CONNECTED_SCALING</a> : thm
<a name="line518"></a>    val <a href="#CONNECTED_SEGMENT-val">CONNECTED_SEGMENT</a> : thm
<a name="line519"></a>    val <a href="#CONNECTED_SING-val">CONNECTED_SING</a> : thm
<a name="line520"></a>    val <a href="#CONNECTED_SUBSET_CLOPEN-val">CONNECTED_SUBSET_CLOPEN</a> : thm
<a name="line521"></a>    val <a href="#CONNECTED_TRANSLATION-val">CONNECTED_TRANSLATION</a> : thm
<a name="line522"></a>    val <a href="#CONNECTED_TRANSLATION_EQ-val">CONNECTED_TRANSLATION_EQ</a> : thm
<a name="line523"></a>    val <a href="#CONNECTED_UNION-val">CONNECTED_UNION</a> : thm
<a name="line524"></a>    val <a href="#CONNECTED_UNION_STRONG-val">CONNECTED_UNION_STRONG</a> : thm
<a name="line525"></a>    val <a href="#CONNECTED_UNIV-val">CONNECTED_UNIV</a> : thm
<a name="line526"></a>    val <a href="#CONTENT_0_SUBSET-val">CONTENT_0_SUBSET</a> : thm
<a name="line527"></a>    val <a href="#CONTENT_0_SUBSET_GEN-val">CONTENT_0_SUBSET_GEN</a> : thm
<a name="line528"></a>    val <a href="#CONTENT_CLOSED_INTERVAL-val">CONTENT_CLOSED_INTERVAL</a> : thm
<a name="line529"></a>    val <a href="#CONTENT_CLOSED_INTERVAL_CASES-val">CONTENT_CLOSED_INTERVAL_CASES</a> : thm
<a name="line530"></a>    val <a href="#CONTENT_EMPTY-val">CONTENT_EMPTY</a> : thm
<a name="line531"></a>    val <a href="#CONTENT_EQ_0-val">CONTENT_EQ_0</a> : thm
<a name="line532"></a>    val <a href="#CONTENT_EQ_0_1-val">CONTENT_EQ_0_1</a> : thm
<a name="line533"></a>    val <a href="#CONTENT_EQ_0_GEN-val">CONTENT_EQ_0_GEN</a> : thm
<a name="line534"></a>    val <a href="#CONTENT_EQ_0_INTERIOR-val">CONTENT_EQ_0_INTERIOR</a> : thm
<a name="line535"></a>    val <a href="#CONTENT_LT_NZ-val">CONTENT_LT_NZ</a> : thm
<a name="line536"></a>    val <a href="#CONTENT_POS_LE-val">CONTENT_POS_LE</a> : thm
<a name="line537"></a>    val <a href="#CONTENT_POS_LT-val">CONTENT_POS_LT</a> : thm
<a name="line538"></a>    val <a href="#CONTENT_POS_LT_EQ-val">CONTENT_POS_LT_EQ</a> : thm
<a name="line539"></a>    val <a href="#CONTENT_SUBSET-val">CONTENT_SUBSET</a> : thm
<a name="line540"></a>    val <a href="#CONTENT_UNIT-val">CONTENT_UNIT</a> : thm
<a name="line541"></a>    val <a href="#CONTINUOUS_ABS-val">CONTINUOUS_ABS</a> : thm
<a name="line542"></a>    val <a href="#CONTINUOUS_ABS_COMPOSE-val">CONTINUOUS_ABS_COMPOSE</a> : thm
<a name="line543"></a>    val <a href="#CONTINUOUS_ADD-val">CONTINUOUS_ADD</a> : thm
<a name="line544"></a>    val <a href="#CONTINUOUS_AGREE_ON_CLOSURE-val">CONTINUOUS_AGREE_ON_CLOSURE</a> : thm
<a name="line545"></a>    val <a href="#CONTINUOUS_AT-val">CONTINUOUS_AT</a> : thm
<a name="line546"></a>    val <a href="#CONTINUOUS_ATTAINS_INF-val">CONTINUOUS_ATTAINS_INF</a> : thm
<a name="line547"></a>    val <a href="#CONTINUOUS_ATTAINS_SUP-val">CONTINUOUS_ATTAINS_SUP</a> : thm
<a name="line548"></a>    val <a href="#CONTINUOUS_AT_ABS-val">CONTINUOUS_AT_ABS</a> : thm
<a name="line549"></a>    val <a href="#CONTINUOUS_AT_AVOID-val">CONTINUOUS_AT_AVOID</a> : thm
<a name="line550"></a>    val <a href="#CONTINUOUS_AT_BALL-val">CONTINUOUS_AT_BALL</a> : thm
<a name="line551"></a>    val <a href="#CONTINUOUS_AT_COMPOSE-val">CONTINUOUS_AT_COMPOSE</a> : thm
<a name="line552"></a>    val <a href="#CONTINUOUS_AT_COMPOSE_EQ-val">CONTINUOUS_AT_COMPOSE_EQ</a> : thm
<a name="line553"></a>    val <a href="#CONTINUOUS_AT_DIST-val">CONTINUOUS_AT_DIST</a> : thm
<a name="line554"></a>    val <a href="#CONTINUOUS_AT_DIST_CLOSEST_POINT-val">CONTINUOUS_AT_DIST_CLOSEST_POINT</a> : thm
<a name="line555"></a>    val <a href="#CONTINUOUS_AT_ID-val">CONTINUOUS_AT_ID</a> : thm
<a name="line556"></a>    val <a href="#CONTINUOUS_AT_IMP_CONTINUOUS_ON-val">CONTINUOUS_AT_IMP_CONTINUOUS_ON</a> : thm
<a name="line557"></a>    val <a href="#CONTINUOUS_AT_INV-val">CONTINUOUS_AT_INV</a> : thm
<a name="line558"></a>    val <a href="#CONTINUOUS_AT_LIFT_DOT-val">CONTINUOUS_AT_LIFT_DOT</a> : thm
<a name="line559"></a>    val <a href="#CONTINUOUS_AT_OPEN-val">CONTINUOUS_AT_OPEN</a> : thm
<a name="line560"></a>    val <a href="#CONTINUOUS_AT_RANGE-val">CONTINUOUS_AT_RANGE</a> : thm
<a name="line561"></a>    val <a href="#CONTINUOUS_AT_SEQUENTIALLY-val">CONTINUOUS_AT_SEQUENTIALLY</a> : thm
<a name="line562"></a>    val <a href="#CONTINUOUS_AT_SETDIST-val">CONTINUOUS_AT_SETDIST</a> : thm
<a name="line563"></a>    val <a href="#CONTINUOUS_AT_TRANSLATION-val">CONTINUOUS_AT_TRANSLATION</a> : thm
<a name="line564"></a>    val <a href="#CONTINUOUS_AT_WITHIN-val">CONTINUOUS_AT_WITHIN</a> : thm
<a name="line565"></a>    val <a href="#CONTINUOUS_AT_WITHIN_INV-val">CONTINUOUS_AT_WITHIN_INV</a> : thm
<a name="line566"></a>    val <a href="#CONTINUOUS_CLOSED_IMP_CAUCHY_CONTINUOUS-val">CONTINUOUS_CLOSED_IMP_CAUCHY_CONTINUOUS</a> : thm
<a name="line567"></a>    val <a href="#CONTINUOUS_CLOSED_IN_PREIMAGE-val">CONTINUOUS_CLOSED_IN_PREIMAGE</a> : thm
<a name="line568"></a>    val <a href="#CONTINUOUS_CLOSED_IN_PREIMAGE_CONSTANT-val">CONTINUOUS_CLOSED_IN_PREIMAGE_CONSTANT</a> : thm
<a name="line569"></a>    val <a href="#CONTINUOUS_CLOSED_IN_PREIMAGE_EQ-val">CONTINUOUS_CLOSED_IN_PREIMAGE_EQ</a> : thm
<a name="line570"></a>    val <a href="#CONTINUOUS_CLOSED_IN_PREIMAGE_GEN-val">CONTINUOUS_CLOSED_IN_PREIMAGE_GEN</a> : thm
<a name="line571"></a>    val <a href="#CONTINUOUS_CLOSED_PREIMAGE-val">CONTINUOUS_CLOSED_PREIMAGE</a> : thm
<a name="line572"></a>    val <a href="#CONTINUOUS_CLOSED_PREIMAGE_CONSTANT-val">CONTINUOUS_CLOSED_PREIMAGE_CONSTANT</a> : thm
<a name="line573"></a>    val <a href="#CONTINUOUS_CLOSED_PREIMAGE_UNIV-val">CONTINUOUS_CLOSED_PREIMAGE_UNIV</a> : thm
<a name="line574"></a>    val <a href="#CONTINUOUS_CMUL-val">CONTINUOUS_CMUL</a> : thm
<a name="line575"></a>    val <a href="#CONTINUOUS_COMPONENT_COMPOSE-val">CONTINUOUS_COMPONENT_COMPOSE</a> : thm
<a name="line576"></a>    val <a href="#CONTINUOUS_CONST-val">CONTINUOUS_CONST</a> : thm
<a name="line577"></a>    val <a href="#CONTINUOUS_CONSTANT_ON_CLOSURE-val">CONTINUOUS_CONSTANT_ON_CLOSURE</a> : thm
<a name="line578"></a>    val <a href="#CONTINUOUS_DIAMETER-val">CONTINUOUS_DIAMETER</a> : thm
<a name="line579"></a>    val <a href="#CONTINUOUS_DISCONNECTED_DISCRETE_FINITE_RANGE_CONSTANT_EQ-val">CONTINUOUS_DISCONNECTED_DISCRETE_FINITE_RANGE_CONSTANT_EQ</a> : thm
<a name="line580"></a>    val <a href="#CONTINUOUS_DISCONNECTED_RANGE_CONSTANT-val">CONTINUOUS_DISCONNECTED_RANGE_CONSTANT</a> : thm
<a name="line581"></a>    val <a href="#CONTINUOUS_DISCONNECTED_RANGE_CONSTANT_EQ-val">CONTINUOUS_DISCONNECTED_RANGE_CONSTANT_EQ</a> : thm
<a name="line582"></a>    val <a href="#CONTINUOUS_DISCRETE_RANGE_CONSTANT-val">CONTINUOUS_DISCRETE_RANGE_CONSTANT</a> : thm
<a name="line583"></a>    val <a href="#CONTINUOUS_DISCRETE_RANGE_CONSTANT_EQ-val">CONTINUOUS_DISCRETE_RANGE_CONSTANT_EQ</a> : thm
<a name="line584"></a>    val <a href="#CONTINUOUS_DOT2-val">CONTINUOUS_DOT2</a> : thm
<a name="line585"></a>    val <a href="#CONTINUOUS_FINITE_RANGE_CONSTANT-val">CONTINUOUS_FINITE_RANGE_CONSTANT</a> : thm
<a name="line586"></a>    val <a href="#CONTINUOUS_FINITE_RANGE_CONSTANT_EQ-val">CONTINUOUS_FINITE_RANGE_CONSTANT_EQ</a> : thm
<a name="line587"></a>    val <a href="#CONTINUOUS_GE_ON_CLOSURE-val">CONTINUOUS_GE_ON_CLOSURE</a> : thm
<a name="line588"></a>    val <a href="#CONTINUOUS_IMP_CLOSED_MAP-val">CONTINUOUS_IMP_CLOSED_MAP</a> : thm
<a name="line589"></a>    val <a href="#CONTINUOUS_IMP_QUOTIENT_MAP-val">CONTINUOUS_IMP_QUOTIENT_MAP</a> : thm
<a name="line590"></a>    val <a href="#CONTINUOUS_INV-val">CONTINUOUS_INV</a> : thm
<a name="line591"></a>    val <a href="#CONTINUOUS_LEFT_INVERSE_IMP_QUOTIENT_MAP-val">CONTINUOUS_LEFT_INVERSE_IMP_QUOTIENT_MAP</a> : thm
<a name="line592"></a>    val <a href="#CONTINUOUS_LEVELSET_OPEN-val">CONTINUOUS_LEVELSET_OPEN</a> : thm
<a name="line593"></a>    val <a href="#CONTINUOUS_LEVELSET_OPEN_IN-val">CONTINUOUS_LEVELSET_OPEN_IN</a> : thm
<a name="line594"></a>    val <a href="#CONTINUOUS_LEVELSET_OPEN_IN_CASES-val">CONTINUOUS_LEVELSET_OPEN_IN_CASES</a> : thm
<a name="line595"></a>    val <a href="#CONTINUOUS_LE_ON_CLOSURE-val">CONTINUOUS_LE_ON_CLOSURE</a> : thm
<a name="line596"></a>    val <a href="#CONTINUOUS_MAP_CLOSURES-val">CONTINUOUS_MAP_CLOSURES</a> : thm
<a name="line597"></a>    val <a href="#CONTINUOUS_MAX-val">CONTINUOUS_MAX</a> : thm
<a name="line598"></a>    val <a href="#CONTINUOUS_MIN-val">CONTINUOUS_MIN</a> : thm
<a name="line599"></a>    val <a href="#CONTINUOUS_MUL-val">CONTINUOUS_MUL</a> : thm
<a name="line600"></a>    val <a href="#CONTINUOUS_NEG-val">CONTINUOUS_NEG</a> : thm
<a name="line601"></a>    val <a href="#CONTINUOUS_ON-val">CONTINUOUS_ON</a> : thm
<a name="line602"></a>    val <a href="#CONTINUOUS_ON_ABS-val">CONTINUOUS_ON_ABS</a> : thm
<a name="line603"></a>    val <a href="#CONTINUOUS_ON_ABS_COMPOSE-val">CONTINUOUS_ON_ABS_COMPOSE</a> : thm
<a name="line604"></a>    val <a href="#CONTINUOUS_ON_ADD-val">CONTINUOUS_ON_ADD</a> : thm
<a name="line605"></a>    val <a href="#CONTINUOUS_ON_AVOID-val">CONTINUOUS_ON_AVOID</a> : thm
<a name="line606"></a>    val <a href="#CONTINUOUS_ON_CASES-val">CONTINUOUS_ON_CASES</a> : thm
<a name="line607"></a>    val <a href="#CONTINUOUS_ON_CASES_1-val">CONTINUOUS_ON_CASES_1</a> : thm
<a name="line608"></a>    val <a href="#CONTINUOUS_ON_CASES_LE-val">CONTINUOUS_ON_CASES_LE</a> : thm
<a name="line609"></a>    val <a href="#CONTINUOUS_ON_CASES_LOCAL-val">CONTINUOUS_ON_CASES_LOCAL</a> : thm
<a name="line610"></a>    val <a href="#CONTINUOUS_ON_CASES_LOCAL_OPEN-val">CONTINUOUS_ON_CASES_LOCAL_OPEN</a> : thm
<a name="line611"></a>    val <a href="#CONTINUOUS_ON_CASES_OPEN-val">CONTINUOUS_ON_CASES_OPEN</a> : thm
<a name="line612"></a>    val <a href="#CONTINUOUS_ON_CLOSED-val">CONTINUOUS_ON_CLOSED</a> : thm
<a name="line613"></a>    val <a href="#CONTINUOUS_ON_CLOSED_GEN-val">CONTINUOUS_ON_CLOSED_GEN</a> : thm
<a name="line614"></a>    val <a href="#CONTINUOUS_ON_CLOSURE-val">CONTINUOUS_ON_CLOSURE</a> : thm
<a name="line615"></a>    val <a href="#CONTINUOUS_ON_CLOSURE_ABS_LE-val">CONTINUOUS_ON_CLOSURE_ABS_LE</a> : thm
<a name="line616"></a>    val <a href="#CONTINUOUS_ON_CLOSURE_COMPONENT_GE-val">CONTINUOUS_ON_CLOSURE_COMPONENT_GE</a> : thm
<a name="line617"></a>    val <a href="#CONTINUOUS_ON_CLOSURE_COMPONENT_LE-val">CONTINUOUS_ON_CLOSURE_COMPONENT_LE</a> : thm
<a name="line618"></a>    val <a href="#CONTINUOUS_ON_CLOSURE_SEQUENTIALLY-val">CONTINUOUS_ON_CLOSURE_SEQUENTIALLY</a> : thm
<a name="line619"></a>    val <a href="#CONTINUOUS_ON_CMUL-val">CONTINUOUS_ON_CMUL</a> : thm
<a name="line620"></a>    val <a href="#CONTINUOUS_ON_COMPONENTS_FINITE-val">CONTINUOUS_ON_COMPONENTS_FINITE</a> : thm
<a name="line621"></a>    val <a href="#CONTINUOUS_ON_COMPONENTS_GEN-val">CONTINUOUS_ON_COMPONENTS_GEN</a> : thm
<a name="line622"></a>    val <a href="#CONTINUOUS_ON_COMPONENT_COMPOSE-val">CONTINUOUS_ON_COMPONENT_COMPOSE</a> : thm
<a name="line623"></a>    val <a href="#CONTINUOUS_ON_COMPOSE-val">CONTINUOUS_ON_COMPOSE</a> : thm
<a name="line624"></a>    val <a href="#CONTINUOUS_ON_COMPOSE_QUOTIENT-val">CONTINUOUS_ON_COMPOSE_QUOTIENT</a> : thm
<a name="line625"></a>    val <a href="#CONTINUOUS_ON_CONST-val">CONTINUOUS_ON_CONST</a> : thm
<a name="line626"></a>    val <a href="#CONTINUOUS_ON_DIST-val">CONTINUOUS_ON_DIST</a> : thm
<a name="line627"></a>    val <a href="#CONTINUOUS_ON_DIST_CLOSEST_POINT-val">CONTINUOUS_ON_DIST_CLOSEST_POINT</a> : thm
<a name="line628"></a>    val <a href="#CONTINUOUS_ON_DOT2-val">CONTINUOUS_ON_DOT2</a> : thm
<a name="line629"></a>    val <a href="#CONTINUOUS_ON_EMPTY-val">CONTINUOUS_ON_EMPTY</a> : thm
<a name="line630"></a>    val <a href="#CONTINUOUS_ON_EQ-val">CONTINUOUS_ON_EQ</a> : thm
<a name="line631"></a>    val <a href="#CONTINUOUS_ON_EQ_CONTINUOUS_AT-val">CONTINUOUS_ON_EQ_CONTINUOUS_AT</a> : thm
<a name="line632"></a>    val <a href="#CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN-val">CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN</a> : thm
<a name="line633"></a>    val <a href="#CONTINUOUS_ON_FINITE-val">CONTINUOUS_ON_FINITE</a> : thm
<a name="line634"></a>    val <a href="#CONTINUOUS_ON_ID-val">CONTINUOUS_ON_ID</a> : thm
<a name="line635"></a>    val <a href="#CONTINUOUS_ON_IMP_CLOSED_IN-val">CONTINUOUS_ON_IMP_CLOSED_IN</a> : thm
<a name="line636"></a>    val <a href="#CONTINUOUS_ON_IMP_OPEN_IN-val">CONTINUOUS_ON_IMP_OPEN_IN</a> : thm
<a name="line637"></a>    val <a href="#CONTINUOUS_ON_INTERIOR-val">CONTINUOUS_ON_INTERIOR</a> : thm
<a name="line638"></a>    val <a href="#CONTINUOUS_ON_INV-val">CONTINUOUS_ON_INV</a> : thm
<a name="line639"></a>    val <a href="#CONTINUOUS_ON_INVERSE-val">CONTINUOUS_ON_INVERSE</a> : thm
<a name="line640"></a>    val <a href="#CONTINUOUS_ON_INVERSE_CLOSED_MAP-val">CONTINUOUS_ON_INVERSE_CLOSED_MAP</a> : thm
<a name="line641"></a>    val <a href="#CONTINUOUS_ON_INVERSE_OPEN_MAP-val">CONTINUOUS_ON_INVERSE_OPEN_MAP</a> : thm
<a name="line642"></a>    val <a href="#CONTINUOUS_ON_IVT-val">CONTINUOUS_ON_IVT</a> : thm
<a name="line643"></a>    val <a href="#CONTINUOUS_ON_LIFT_DOT-val">CONTINUOUS_ON_LIFT_DOT</a> : thm
<a name="line644"></a>    val <a href="#CONTINUOUS_ON_MAX-val">CONTINUOUS_ON_MAX</a> : thm
<a name="line645"></a>    val <a href="#CONTINUOUS_ON_MIN-val">CONTINUOUS_ON_MIN</a> : thm
<a name="line646"></a>    val <a href="#CONTINUOUS_ON_MUL-val">CONTINUOUS_ON_MUL</a> : thm
<a name="line647"></a>    val <a href="#CONTINUOUS_ON_NEG-val">CONTINUOUS_ON_NEG</a> : thm
<a name="line648"></a>    val <a href="#CONTINUOUS_ON_NO_LIMPT-val">CONTINUOUS_ON_NO_LIMPT</a> : thm
<a name="line649"></a>    val <a href="#CONTINUOUS_ON_OPEN-val">CONTINUOUS_ON_OPEN</a> : thm
<a name="line650"></a>    val <a href="#CONTINUOUS_ON_OPEN_AVOID-val">CONTINUOUS_ON_OPEN_AVOID</a> : thm
<a name="line651"></a>    val <a href="#CONTINUOUS_ON_OPEN_GEN-val">CONTINUOUS_ON_OPEN_GEN</a> : thm
<a name="line652"></a>    val <a href="#CONTINUOUS_ON_POW-val">CONTINUOUS_ON_POW</a> : thm
<a name="line653"></a>    val <a href="#CONTINUOUS_ON_PRODUCT-val">CONTINUOUS_ON_PRODUCT</a> : thm
<a name="line654"></a>    val <a href="#CONTINUOUS_ON_RANGE-val">CONTINUOUS_ON_RANGE</a> : thm
<a name="line655"></a>    val <a href="#CONTINUOUS_ON_SEQUENTIALLY-val">CONTINUOUS_ON_SEQUENTIALLY</a> : thm
<a name="line656"></a>    val <a href="#CONTINUOUS_ON_SETDIST-val">CONTINUOUS_ON_SETDIST</a> : thm
<a name="line657"></a>    val <a href="#CONTINUOUS_ON_SING-val">CONTINUOUS_ON_SING</a> : thm
<a name="line658"></a>    val <a href="#CONTINUOUS_ON_SUB-val">CONTINUOUS_ON_SUB</a> : thm
<a name="line659"></a>    val <a href="#CONTINUOUS_ON_SUBSET-val">CONTINUOUS_ON_SUBSET</a> : thm
<a name="line660"></a>    val <a href="#CONTINUOUS_ON_SUM-val">CONTINUOUS_ON_SUM</a> : thm
<a name="line661"></a>    val <a href="#CONTINUOUS_ON_UNION-val">CONTINUOUS_ON_UNION</a> : thm
<a name="line662"></a>    val <a href="#CONTINUOUS_ON_UNION_LOCAL-val">CONTINUOUS_ON_UNION_LOCAL</a> : thm
<a name="line663"></a>    val <a href="#CONTINUOUS_ON_UNION_LOCAL_OPEN-val">CONTINUOUS_ON_UNION_LOCAL_OPEN</a> : thm
<a name="line664"></a>    val <a href="#CONTINUOUS_ON_UNION_OPEN-val">CONTINUOUS_ON_UNION_OPEN</a> : thm
<a name="line665"></a>    val <a href="#CONTINUOUS_ON_VMUL-val">CONTINUOUS_ON_VMUL</a> : thm
<a name="line666"></a>    val <a href="#CONTINUOUS_OPEN_IN_PREIMAGE-val">CONTINUOUS_OPEN_IN_PREIMAGE</a> : thm
<a name="line667"></a>    val <a href="#CONTINUOUS_OPEN_IN_PREIMAGE_EQ-val">CONTINUOUS_OPEN_IN_PREIMAGE_EQ</a> : thm
<a name="line668"></a>    val <a href="#CONTINUOUS_OPEN_IN_PREIMAGE_GEN-val">CONTINUOUS_OPEN_IN_PREIMAGE_GEN</a> : thm
<a name="line669"></a>    val <a href="#CONTINUOUS_OPEN_PREIMAGE-val">CONTINUOUS_OPEN_PREIMAGE</a> : thm
<a name="line670"></a>    val <a href="#CONTINUOUS_OPEN_PREIMAGE_UNIV-val">CONTINUOUS_OPEN_PREIMAGE_UNIV</a> : thm
<a name="line671"></a>    val <a href="#CONTINUOUS_POW-val">CONTINUOUS_POW</a> : thm
<a name="line672"></a>    val <a href="#CONTINUOUS_PRODUCT-val">CONTINUOUS_PRODUCT</a> : thm
<a name="line673"></a>    val <a href="#CONTINUOUS_RIGHT_INVERSE_IMP_QUOTIENT_MAP-val">CONTINUOUS_RIGHT_INVERSE_IMP_QUOTIENT_MAP</a> : thm
<a name="line674"></a>    val <a href="#CONTINUOUS_SUB-val">CONTINUOUS_SUB</a> : thm
<a name="line675"></a>    val <a href="#CONTINUOUS_SUM-val">CONTINUOUS_SUM</a> : thm
<a name="line676"></a>    val <a href="#CONTINUOUS_TRANSFORM_AT-val">CONTINUOUS_TRANSFORM_AT</a> : thm
<a name="line677"></a>    val <a href="#CONTINUOUS_TRANSFORM_WITHIN-val">CONTINUOUS_TRANSFORM_WITHIN</a> : thm
<a name="line678"></a>    val <a href="#CONTINUOUS_TRANSFORM_WITHIN_OPEN-val">CONTINUOUS_TRANSFORM_WITHIN_OPEN</a> : thm
<a name="line679"></a>    val <a href="#CONTINUOUS_TRANSFORM_WITHIN_OPEN_IN-val">CONTINUOUS_TRANSFORM_WITHIN_OPEN_IN</a> : thm
<a name="line680"></a>    val <a href="#CONTINUOUS_TRANSFORM_WITHIN_SET_IMP-val">CONTINUOUS_TRANSFORM_WITHIN_SET_IMP</a> : thm
<a name="line681"></a>    val <a href="#CONTINUOUS_TRIVIAL_LIMIT-val">CONTINUOUS_TRIVIAL_LIMIT</a> : thm
<a name="line682"></a>    val <a href="#CONTINUOUS_UNIFORM_LIMIT-val">CONTINUOUS_UNIFORM_LIMIT</a> : thm
<a name="line683"></a>    val <a href="#CONTINUOUS_VMUL-val">CONTINUOUS_VMUL</a> : thm
<a name="line684"></a>    val <a href="#CONTINUOUS_WITHIN-val">CONTINUOUS_WITHIN</a> : thm
<a name="line685"></a>    val <a href="#CONTINUOUS_WITHIN_AVOID-val">CONTINUOUS_WITHIN_AVOID</a> : thm
<a name="line686"></a>    val <a href="#CONTINUOUS_WITHIN_BALL-val">CONTINUOUS_WITHIN_BALL</a> : thm
<a name="line687"></a>    val <a href="#CONTINUOUS_WITHIN_CLOSED_NONTRIVIAL-val">CONTINUOUS_WITHIN_CLOSED_NONTRIVIAL</a> : thm
<a name="line688"></a>    val <a href="#CONTINUOUS_WITHIN_COMPARISON-val">CONTINUOUS_WITHIN_COMPARISON</a> : thm
<a name="line689"></a>    val <a href="#CONTINUOUS_WITHIN_COMPOSE-val">CONTINUOUS_WITHIN_COMPOSE</a> : thm
<a name="line690"></a>    val <a href="#CONTINUOUS_WITHIN_ID-val">CONTINUOUS_WITHIN_ID</a> : thm
<a name="line691"></a>    val <a href="#CONTINUOUS_WITHIN_OPEN-val">CONTINUOUS_WITHIN_OPEN</a> : thm
<a name="line692"></a>    val <a href="#CONTINUOUS_WITHIN_SEQUENTIALLY-val">CONTINUOUS_WITHIN_SEQUENTIALLY</a> : thm
<a name="line693"></a>    val <a href="#CONTINUOUS_WITHIN_SUBSET-val">CONTINUOUS_WITHIN_SUBSET</a> : thm
<a name="line694"></a>    val <a href="#CONTRACTION_IMP_CONTINUOUS_ON-val">CONTRACTION_IMP_CONTINUOUS_ON</a> : thm
<a name="line695"></a>    val <a href="#CONVERGENT_BOUNDED_INCREASING-val">CONVERGENT_BOUNDED_INCREASING</a> : thm
<a name="line696"></a>    val <a href="#CONVERGENT_BOUNDED_MONOTONE-val">CONVERGENT_BOUNDED_MONOTONE</a> : thm
<a name="line697"></a>    val <a href="#CONVERGENT_EQ_CAUCHY-val">CONVERGENT_EQ_CAUCHY</a> : thm
<a name="line698"></a>    val <a href="#CONVERGENT_IMP_BOUNDED-val">CONVERGENT_IMP_BOUNDED</a> : thm
<a name="line699"></a>    val <a href="#CONVERGENT_IMP_CAUCHY-val">CONVERGENT_IMP_CAUCHY</a> : thm
<a name="line700"></a>    val <a href="#COUNTABLE_OPEN_INTERVAL-val">COUNTABLE_OPEN_INTERVAL</a> : thm
<a name="line701"></a>    val <a href="#DECREASING_CLOSED_NEST-val">DECREASING_CLOSED_NEST</a> : thm
<a name="line702"></a>    val <a href="#DECREASING_CLOSED_NEST_SING-val">DECREASING_CLOSED_NEST_SING</a> : thm
<a name="line703"></a>    val <a href="#DENSE_IMP_PERFECT-val">DENSE_IMP_PERFECT</a> : thm
<a name="line704"></a>    val <a href="#DENSE_LIMIT_POINTS-val">DENSE_LIMIT_POINTS</a> : thm
<a name="line705"></a>    val <a href="#DENSE_OPEN_INTER-val">DENSE_OPEN_INTER</a> : thm
<a name="line706"></a>    val <a href="#DEPENDENT_CHOICE-val">DEPENDENT_CHOICE</a> : thm
<a name="line707"></a>    val <a href="#DEPENDENT_CHOICE_FIXED-val">DEPENDENT_CHOICE_FIXED</a> : thm
<a name="line708"></a>    val <a href="#DEPENDENT_EXPLICIT-val">DEPENDENT_EXPLICIT</a> : thm
<a name="line709"></a>    val <a href="#DEPENDENT_MONO-val">DEPENDENT_MONO</a> : thm
<a name="line710"></a>    val <a href="#DIAMETER_BALL-val">DIAMETER_BALL</a> : thm
<a name="line711"></a>    val <a href="#DIAMETER_BOUNDED-val">DIAMETER_BOUNDED</a> : thm
<a name="line712"></a>    val <a href="#DIAMETER_BOUNDED_BOUND-val">DIAMETER_BOUNDED_BOUND</a> : thm
<a name="line713"></a>    val <a href="#DIAMETER_CBALL-val">DIAMETER_CBALL</a> : thm
<a name="line714"></a>    val <a href="#DIAMETER_CLOSURE-val">DIAMETER_CLOSURE</a> : thm
<a name="line715"></a>    val <a href="#DIAMETER_EMPTY-val">DIAMETER_EMPTY</a> : thm
<a name="line716"></a>    val <a href="#DIAMETER_EQ_0-val">DIAMETER_EQ_0</a> : thm
<a name="line717"></a>    val <a href="#DIAMETER_INTERVAL-val">DIAMETER_INTERVAL</a> : thm
<a name="line718"></a>    val <a href="#DIAMETER_LE-val">DIAMETER_LE</a> : thm
<a name="line719"></a>    val <a href="#DIAMETER_LINEAR_IMAGE-val">DIAMETER_LINEAR_IMAGE</a> : thm
<a name="line720"></a>    val <a href="#DIAMETER_POS_LE-val">DIAMETER_POS_LE</a> : thm
<a name="line721"></a>    val <a href="#DIAMETER_SING-val">DIAMETER_SING</a> : thm
<a name="line722"></a>    val <a href="#DIAMETER_SUBSET-val">DIAMETER_SUBSET</a> : thm
<a name="line723"></a>    val <a href="#DIAMETER_SUBSET_CBALL-val">DIAMETER_SUBSET_CBALL</a> : thm
<a name="line724"></a>    val <a href="#DIAMETER_SUBSET_CBALL_NONEMPTY-val">DIAMETER_SUBSET_CBALL_NONEMPTY</a> : thm
<a name="line725"></a>    val <a href="#DIAMETER_SUMS-val">DIAMETER_SUMS</a> : thm
<a name="line726"></a>    val <a href="#DIFF_CLOSURE_SUBSET-val">DIFF_CLOSURE_SUBSET</a> : thm
<a name="line727"></a>    val <a href="#DIM_LE_CARD-val">DIM_LE_CARD</a> : thm
<a name="line728"></a>    val <a href="#DIM_SUBSET-val">DIM_SUBSET</a> : thm
<a name="line729"></a>    val <a href="#DIM_SUBSET_UNIV-val">DIM_SUBSET_UNIV</a> : thm
<a name="line730"></a>    val <a href="#DIM_SUBSTANDARD-val">DIM_SUBSTANDARD</a> : thm
<a name="line731"></a>    val <a href="#DIM_UNIQUE-val">DIM_UNIQUE</a> : thm
<a name="line732"></a>    val <a href="#DIM_UNIV-val">DIM_UNIV</a> : thm
<a name="line733"></a>    val <a href="#DINI-val">DINI</a> : thm
<a name="line734"></a>    val <a href="#DISCRETE_BOUNDED_IMP_FINITE-val">DISCRETE_BOUNDED_IMP_FINITE</a> : thm
<a name="line735"></a>    val <a href="#DISCRETE_IMP_CLOSED-val">DISCRETE_IMP_CLOSED</a> : thm
<a name="line736"></a>    val <a href="#DISJOINT_INTERVAL-val">DISJOINT_INTERVAL</a> : thm
<a name="line737"></a>    val <a href="#DISTANCE_ATTAINS_INF-val">DISTANCE_ATTAINS_INF</a> : thm
<a name="line738"></a>    val <a href="#DISTANCE_ATTAINS_SUP-val">DISTANCE_ATTAINS_SUP</a> : thm
<a name="line739"></a>    val <a href="#DIST_0-val">DIST_0</a> : thm
<a name="line740"></a>    val <a href="#DIST_CLOSEST_POINT_LIPSCHITZ-val">DIST_CLOSEST_POINT_LIPSCHITZ</a> : thm
<a name="line741"></a>    val <a href="#DIST_EQ-val">DIST_EQ</a> : thm
<a name="line742"></a>    val <a href="#DIST_EQ_0-val">DIST_EQ_0</a> : thm
<a name="line743"></a>    val <a href="#DIST_IN_CLOSED_SEGMENT-val">DIST_IN_CLOSED_SEGMENT</a> : thm
<a name="line744"></a>    val <a href="#DIST_IN_OPEN_CLOSED_SEGMENT-val">DIST_IN_OPEN_CLOSED_SEGMENT</a> : thm
<a name="line745"></a>    val <a href="#DIST_IN_OPEN_SEGMENT-val">DIST_IN_OPEN_SEGMENT</a> : thm
<a name="line746"></a>    val <a href="#DIST_LE_0-val">DIST_LE_0</a> : thm
<a name="line747"></a>    val <a href="#DIST_MIDPOINT-val">DIST_MIDPOINT</a> : thm
<a name="line748"></a>    val <a href="#DIST_MUL-val">DIST_MUL</a> : thm
<a name="line749"></a>    val <a href="#DIST_NZ-val">DIST_NZ</a> : thm
<a name="line750"></a>    val <a href="#DIST_POS_LE-val">DIST_POS_LE</a> : thm
<a name="line751"></a>    val <a href="#DIST_POS_LT-val">DIST_POS_LT</a> : thm
<a name="line752"></a>    val <a href="#DIST_REFL-val">DIST_REFL</a> : thm
<a name="line753"></a>    val <a href="#DIST_SYM-val">DIST_SYM</a> : thm
<a name="line754"></a>    val <a href="#DIST_TRIANGLE-val">DIST_TRIANGLE</a> : thm
<a name="line755"></a>    val <a href="#DIST_TRIANGLE_ADD-val">DIST_TRIANGLE_ADD</a> : thm
<a name="line756"></a>    val <a href="#DIST_TRIANGLE_ADD_HALF-val">DIST_TRIANGLE_ADD_HALF</a> : thm
<a name="line757"></a>    val <a href="#DIST_TRIANGLE_ALT-val">DIST_TRIANGLE_ALT</a> : thm
<a name="line758"></a>    val <a href="#DIST_TRIANGLE_EQ-val">DIST_TRIANGLE_EQ</a> : thm
<a name="line759"></a>    val <a href="#DIST_TRIANGLE_HALF_L-val">DIST_TRIANGLE_HALF_L</a> : thm
<a name="line760"></a>    val <a href="#DIST_TRIANGLE_HALF_R-val">DIST_TRIANGLE_HALF_R</a> : thm
<a name="line761"></a>    val <a href="#DIST_TRIANGLE_LE-val">DIST_TRIANGLE_LE</a> : thm
<a name="line762"></a>    val <a href="#DIST_TRIANGLE_LT-val">DIST_TRIANGLE_LT</a> : thm
<a name="line763"></a>    val <a href="#DORDER_NET-val">DORDER_NET</a> : thm
<a name="line764"></a>    val <a href="#EMPTY_AS_INTERVAL-val">EMPTY_AS_INTERVAL</a> : thm
<a name="line765"></a>    val <a href="#EMPTY_INTERIOR_FINITE-val">EMPTY_INTERIOR_FINITE</a> : thm
<a name="line766"></a>    val <a href="#ENDS_IN_INTERVAL-val">ENDS_IN_INTERVAL</a> : thm
<a name="line767"></a>    val <a href="#ENDS_IN_SEGMENT-val">ENDS_IN_SEGMENT</a> : thm
<a name="line768"></a>    val <a href="#ENDS_IN_UNIT_INTERVAL-val">ENDS_IN_UNIT_INTERVAL</a> : thm
<a name="line769"></a>    val <a href="#ENDS_NOT_IN_SEGMENT-val">ENDS_NOT_IN_SEGMENT</a> : thm
<a name="line770"></a>    val <a href="#EQ_BALLS-val">EQ_BALLS</a> : thm
<a name="line771"></a>    val <a href="#EQ_INTERVAL-val">EQ_INTERVAL</a> : thm
<a name="line772"></a>    val <a href="#EVENTUALLY_AND-val">EVENTUALLY_AND</a> : thm
<a name="line773"></a>    val <a href="#EVENTUALLY_AT-val">EVENTUALLY_AT</a> : thm
<a name="line774"></a>    val <a href="#EVENTUALLY_AT_INFINITY-val">EVENTUALLY_AT_INFINITY</a> : thm
<a name="line775"></a>    val <a href="#EVENTUALLY_AT_INFINITY_POS-val">EVENTUALLY_AT_INFINITY_POS</a> : thm
<a name="line776"></a>    val <a href="#EVENTUALLY_AT_NEGINFINITY-val">EVENTUALLY_AT_NEGINFINITY</a> : thm
<a name="line777"></a>    val <a href="#EVENTUALLY_AT_POSINFINITY-val">EVENTUALLY_AT_POSINFINITY</a> : thm
<a name="line778"></a>    val <a href="#EVENTUALLY_FALSE-val">EVENTUALLY_FALSE</a> : thm
<a name="line779"></a>    val <a href="#EVENTUALLY_FORALL-val">EVENTUALLY_FORALL</a> : thm
<a name="line780"></a>    val <a href="#EVENTUALLY_HAPPENS-val">EVENTUALLY_HAPPENS</a> : thm
<a name="line781"></a>    val <a href="#EVENTUALLY_MONO-val">EVENTUALLY_MONO</a> : thm
<a name="line782"></a>    val <a href="#EVENTUALLY_MP-val">EVENTUALLY_MP</a> : thm
<a name="line783"></a>    val <a href="#EVENTUALLY_SEQUENTIALLY-val">EVENTUALLY_SEQUENTIALLY</a> : thm
<a name="line784"></a>    val <a href="#EVENTUALLY_TRUE-val">EVENTUALLY_TRUE</a> : thm
<a name="line785"></a>    val <a href="#EVENTUALLY_WITHIN-val">EVENTUALLY_WITHIN</a> : thm
<a name="line786"></a>    val <a href="#EVENTUALLY_WITHIN_INTERIOR-val">EVENTUALLY_WITHIN_INTERIOR</a> : thm
<a name="line787"></a>    val <a href="#EVENTUALLY_WITHIN_LE-val">EVENTUALLY_WITHIN_LE</a> : thm
<a name="line788"></a>    val <a href="#EXCHANGE_LEMMA-val">EXCHANGE_LEMMA</a> : thm
<a name="line789"></a>    val <a href="#EXISTS_COMPONENT_SUPERSET-val">EXISTS_COMPONENT_SUPERSET</a> : thm
<a name="line790"></a>    val <a href="#EXISTS_DIFF-val">EXISTS_DIFF</a> : thm
<a name="line791"></a>    val <a href="#EXISTS_IN_INSERT-val">EXISTS_IN_INSERT</a> : thm
<a name="line792"></a>    val <a href="#EXTENSION_FROM_CLOPEN-val">EXTENSION_FROM_CLOPEN</a> : thm
<a name="line793"></a>    val <a href="#FINITE_BALL-val">FINITE_BALL</a> : thm
<a name="line794"></a>    val <a href="#FINITE_CBALL-val">FINITE_CBALL</a> : thm
<a name="line795"></a>    val <a href="#FINITE_IMP_BOUNDED-val">FINITE_IMP_BOUNDED</a> : thm
<a name="line796"></a>    val <a href="#FINITE_IMP_CLOSED-val">FINITE_IMP_CLOSED</a> : thm
<a name="line797"></a>    val <a href="#FINITE_IMP_CLOSED_IN-val">FINITE_IMP_CLOSED_IN</a> : thm
<a name="line798"></a>    val <a href="#FINITE_IMP_COMPACT-val">FINITE_IMP_COMPACT</a> : thm
<a name="line799"></a>    val <a href="#FINITE_IMP_NOT_OPEN-val">FINITE_IMP_NOT_OPEN</a> : thm
<a name="line800"></a>    val <a href="#FINITE_INTERVAL-val">FINITE_INTERVAL</a> : thm
<a name="line801"></a>    val <a href="#FINITE_INTER_NUMSEG-val">FINITE_INTER_NUMSEG</a> : thm
<a name="line802"></a>    val <a href="#FINITE_SET_AVOID-val">FINITE_SET_AVOID</a> : thm
<a name="line803"></a>    val <a href="#FINITE_SPHERE-val">FINITE_SPHERE</a> : thm
<a name="line804"></a>    val <a href="#FORALL_EVENTUALLY-val">FORALL_EVENTUALLY</a> : thm
<a name="line805"></a>    val <a href="#FORALL_IN_CLOSURE-val">FORALL_IN_CLOSURE</a> : thm
<a name="line806"></a>    val <a href="#FORALL_IN_CLOSURE_EQ-val">FORALL_IN_CLOSURE_EQ</a> : thm
<a name="line807"></a>    val <a href="#FORALL_POS_MONO_1-val">FORALL_POS_MONO_1</a> : thm
<a name="line808"></a>    val <a href="#FRONTIER_BALL-val">FRONTIER_BALL</a> : thm
<a name="line809"></a>    val <a href="#FRONTIER_CBALL-val">FRONTIER_CBALL</a> : thm
<a name="line810"></a>    val <a href="#FRONTIER_CLOSED-val">FRONTIER_CLOSED</a> : thm
<a name="line811"></a>    val <a href="#FRONTIER_CLOSED_INTERVAL-val">FRONTIER_CLOSED_INTERVAL</a> : thm
<a name="line812"></a>    val <a href="#FRONTIER_CLOSURES-val">FRONTIER_CLOSURES</a> : thm
<a name="line813"></a>    val <a href="#FRONTIER_CLOSURE_SUBSET-val">FRONTIER_CLOSURE_SUBSET</a> : thm
<a name="line814"></a>    val <a href="#FRONTIER_COMPLEMENT-val">FRONTIER_COMPLEMENT</a> : thm
<a name="line815"></a>    val <a href="#FRONTIER_DISJOINT_EQ-val">FRONTIER_DISJOINT_EQ</a> : thm
<a name="line816"></a>    val <a href="#FRONTIER_EMPTY-val">FRONTIER_EMPTY</a> : thm
<a name="line817"></a>    val <a href="#FRONTIER_FRONTIER-val">FRONTIER_FRONTIER</a> : thm
<a name="line818"></a>    val <a href="#FRONTIER_FRONTIER_FRONTIER-val">FRONTIER_FRONTIER_FRONTIER</a> : thm
<a name="line819"></a>    val <a href="#FRONTIER_FRONTIER_SUBSET-val">FRONTIER_FRONTIER_SUBSET</a> : thm
<a name="line820"></a>    val <a href="#FRONTIER_HALFSPACE_GE-val">FRONTIER_HALFSPACE_GE</a> : thm
<a name="line821"></a>    val <a href="#FRONTIER_HALFSPACE_GT-val">FRONTIER_HALFSPACE_GT</a> : thm
<a name="line822"></a>    val <a href="#FRONTIER_HALFSPACE_LE-val">FRONTIER_HALFSPACE_LE</a> : thm
<a name="line823"></a>    val <a href="#FRONTIER_HALFSPACE_LT-val">FRONTIER_HALFSPACE_LT</a> : thm
<a name="line824"></a>    val <a href="#FRONTIER_INTERIORS-val">FRONTIER_INTERIORS</a> : thm
<a name="line825"></a>    val <a href="#FRONTIER_INTERIOR_SUBSET-val">FRONTIER_INTERIOR_SUBSET</a> : thm
<a name="line826"></a>    val <a href="#FRONTIER_INTER_SUBSET-val">FRONTIER_INTER_SUBSET</a> : thm
<a name="line827"></a>    val <a href="#FRONTIER_INTER_SUBSET_INTER-val">FRONTIER_INTER_SUBSET_INTER</a> : thm
<a name="line828"></a>    val <a href="#FRONTIER_OPEN_INTERVAL-val">FRONTIER_OPEN_INTERVAL</a> : thm
<a name="line829"></a>    val <a href="#FRONTIER_SING-val">FRONTIER_SING</a> : thm
<a name="line830"></a>    val <a href="#FRONTIER_STRADDLE-val">FRONTIER_STRADDLE</a> : thm
<a name="line831"></a>    val <a href="#FRONTIER_SUBSET_CLOSED-val">FRONTIER_SUBSET_CLOSED</a> : thm
<a name="line832"></a>    val <a href="#FRONTIER_SUBSET_COMPACT-val">FRONTIER_SUBSET_COMPACT</a> : thm
<a name="line833"></a>    val <a href="#FRONTIER_SUBSET_EQ-val">FRONTIER_SUBSET_EQ</a> : thm
<a name="line834"></a>    val <a href="#FRONTIER_UNION-val">FRONTIER_UNION</a> : thm
<a name="line835"></a>    val <a href="#FRONTIER_UNION_SUBSET-val">FRONTIER_UNION_SUBSET</a> : thm
<a name="line836"></a>    val <a href="#FRONTIER_UNIV-val">FRONTIER_UNIV</a> : thm
<a name="line837"></a>    val <a href="#FUNCTION_FACTORS_LEFT_GEN-val">FUNCTION_FACTORS_LEFT_GEN</a> : thm
<a name="line838"></a>    val <a href="#GDELTA_COMPLEMENT-val">GDELTA_COMPLEMENT</a> : thm
<a name="line839"></a>    val <a href="#GREATER_EQ_REFL-val">GREATER_EQ_REFL</a> : thm
<a name="line840"></a>    val <a href="#HAS_SIZE_STDBASIS-val">HAS_SIZE_STDBASIS</a> : thm
<a name="line841"></a>    val <a href="#HAUSDIST_ALT-val">HAUSDIST_ALT</a> : thm
<a name="line842"></a>    val <a href="#HAUSDIST_BALLS-val">HAUSDIST_BALLS</a> : thm
<a name="line843"></a>    val <a href="#HAUSDIST_CLOSURE-val">HAUSDIST_CLOSURE</a> : thm
<a name="line844"></a>    val <a href="#HAUSDIST_COMPACT_EXISTS-val">HAUSDIST_COMPACT_EXISTS</a> : thm
<a name="line845"></a>    val <a href="#HAUSDIST_COMPACT_NONTRIVIAL-val">HAUSDIST_COMPACT_NONTRIVIAL</a> : thm
<a name="line846"></a>    val <a href="#HAUSDIST_COMPACT_SUMS-val">HAUSDIST_COMPACT_SUMS</a> : thm
<a name="line847"></a>    val <a href="#HAUSDIST_EMPTY-val">HAUSDIST_EMPTY</a> : thm
<a name="line848"></a>    val <a href="#HAUSDIST_EQ-val">HAUSDIST_EQ</a> : thm
<a name="line849"></a>    val <a href="#HAUSDIST_EQ_0-val">HAUSDIST_EQ_0</a> : thm
<a name="line850"></a>    val <a href="#HAUSDIST_INSERT_LE-val">HAUSDIST_INSERT_LE</a> : thm
<a name="line851"></a>    val <a href="#HAUSDIST_LINEAR_IMAGE-val">HAUSDIST_LINEAR_IMAGE</a> : thm
<a name="line852"></a>    val <a href="#HAUSDIST_NONTRIVIAL-val">HAUSDIST_NONTRIVIAL</a> : thm
<a name="line853"></a>    val <a href="#HAUSDIST_NONTRIVIAL_ALT-val">HAUSDIST_NONTRIVIAL_ALT</a> : thm
<a name="line854"></a>    val <a href="#HAUSDIST_POS_LE-val">HAUSDIST_POS_LE</a> : thm
<a name="line855"></a>    val <a href="#HAUSDIST_REFL-val">HAUSDIST_REFL</a> : thm
<a name="line856"></a>    val <a href="#HAUSDIST_SETDIST_TRIANGLE-val">HAUSDIST_SETDIST_TRIANGLE</a> : thm
<a name="line857"></a>    val <a href="#HAUSDIST_SINGS-val">HAUSDIST_SINGS</a> : thm
<a name="line858"></a>    val <a href="#HAUSDIST_SYM-val">HAUSDIST_SYM</a> : thm
<a name="line859"></a>    val <a href="#HAUSDIST_TRANS-val">HAUSDIST_TRANS</a> : thm
<a name="line860"></a>    val <a href="#HAUSDIST_TRANSLATION-val">HAUSDIST_TRANSLATION</a> : thm
<a name="line861"></a>    val <a href="#HAUSDIST_TRIANGLE-val">HAUSDIST_TRIANGLE</a> : thm
<a name="line862"></a>    val <a href="#HAUSDIST_UNION_LE-val">HAUSDIST_UNION_LE</a> : thm
<a name="line863"></a>    val <a href="#HEINE_BOREL_IMP_BOLZANO_WEIERSTRASS-val">HEINE_BOREL_IMP_BOLZANO_WEIERSTRASS</a> : thm
<a name="line864"></a>    val <a href="#HEINE_BOREL_LEMMA-val">HEINE_BOREL_LEMMA</a> : thm
<a name="line865"></a>    val <a href="#HOMEOMORPHIC_AFFINITY-val">HOMEOMORPHIC_AFFINITY</a> : thm
<a name="line866"></a>    val <a href="#HOMEOMORPHIC_BALLS-val">HOMEOMORPHIC_BALLS</a> : thm
<a name="line867"></a>    val <a href="#HOMEOMORPHIC_BALLS_CBALL_SPHERE-val">HOMEOMORPHIC_BALLS_CBALL_SPHERE</a> : thm
<a name="line868"></a>    val <a href="#HOMEOMORPHIC_CBALL-val">HOMEOMORPHIC_CBALL</a> : thm
<a name="line869"></a>    val <a href="#HOMEOMORPHIC_COMPACT-val">HOMEOMORPHIC_COMPACT</a> : thm
<a name="line870"></a>    val <a href="#HOMEOMORPHIC_COMPACTNESS-val">HOMEOMORPHIC_COMPACTNESS</a> : thm
<a name="line871"></a>    val <a href="#HOMEOMORPHIC_CONNECTEDNESS-val">HOMEOMORPHIC_CONNECTEDNESS</a> : thm
<a name="line872"></a>    val <a href="#HOMEOMORPHIC_EMPTY-val">HOMEOMORPHIC_EMPTY</a> : thm
<a name="line873"></a>    val <a href="#HOMEOMORPHIC_FINITE-val">HOMEOMORPHIC_FINITE</a> : thm
<a name="line874"></a>    val <a href="#HOMEOMORPHIC_FINITENESS-val">HOMEOMORPHIC_FINITENESS</a> : thm
<a name="line875"></a>    val <a href="#HOMEOMORPHIC_FINITE_STRONG-val">HOMEOMORPHIC_FINITE_STRONG</a> : thm
<a name="line876"></a>    val <a href="#HOMEOMORPHIC_HYPERPLANES-val">HOMEOMORPHIC_HYPERPLANES</a> : thm
<a name="line877"></a>    val <a href="#HOMEOMORPHIC_HYPERPLANE_STANDARD_HYPERPLANE-val">HOMEOMORPHIC_HYPERPLANE_STANDARD_HYPERPLANE</a> : thm
<a name="line878"></a>    val <a href="#HOMEOMORPHIC_IMP_CARD_EQ-val">HOMEOMORPHIC_IMP_CARD_EQ</a> : thm
<a name="line879"></a>    val <a href="#HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_LEFT_EQ-val">HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_LEFT_EQ</a> : thm
<a name="line880"></a>    val <a href="#HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_RIGHT_EQ-val">HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_RIGHT_EQ</a> : thm
<a name="line881"></a>    val <a href="#HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_SELF-val">HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_SELF</a> : thm
<a name="line882"></a>    val <a href="#HOMEOMORPHIC_LOCALLY-val">HOMEOMORPHIC_LOCALLY</a> : thm
<a name="line883"></a>    val <a href="#HOMEOMORPHIC_LOCAL_COMPACTNESS-val">HOMEOMORPHIC_LOCAL_COMPACTNESS</a> : thm
<a name="line884"></a>    val <a href="#HOMEOMORPHIC_MINIMAL-val">HOMEOMORPHIC_MINIMAL</a> : thm
<a name="line885"></a>    val <a href="#HOMEOMORPHIC_ONE_POINT_COMPACTIFICATIONS-val">HOMEOMORPHIC_ONE_POINT_COMPACTIFICATIONS</a> : thm
<a name="line886"></a>    val <a href="#HOMEOMORPHIC_OPEN_INTERVALS-val">HOMEOMORPHIC_OPEN_INTERVALS</a> : thm
<a name="line887"></a>    val <a href="#HOMEOMORPHIC_OPEN_INTERVAL_UNIV-val">HOMEOMORPHIC_OPEN_INTERVAL_UNIV</a> : thm
<a name="line888"></a>    val <a href="#HOMEOMORPHIC_REFL-val">HOMEOMORPHIC_REFL</a> : thm
<a name="line889"></a>    val <a href="#HOMEOMORPHIC_SCALING-val">HOMEOMORPHIC_SCALING</a> : thm
<a name="line890"></a>    val <a href="#HOMEOMORPHIC_SCALING_LEFT-val">HOMEOMORPHIC_SCALING_LEFT</a> : thm
<a name="line891"></a>    val <a href="#HOMEOMORPHIC_SCALING_RIGHT-val">HOMEOMORPHIC_SCALING_RIGHT</a> : thm
<a name="line892"></a>    val <a href="#HOMEOMORPHIC_SING-val">HOMEOMORPHIC_SING</a> : thm
<a name="line893"></a>    val <a href="#HOMEOMORPHIC_SPHERE-val">HOMEOMORPHIC_SPHERE</a> : thm
<a name="line894"></a>    val <a href="#HOMEOMORPHIC_STANDARD_HYPERPLANE_HYPERPLANE-val">HOMEOMORPHIC_STANDARD_HYPERPLANE_HYPERPLANE</a> : thm
<a name="line895"></a>    val <a href="#HOMEOMORPHIC_SYM-val">HOMEOMORPHIC_SYM</a> : thm
<a name="line896"></a>    val <a href="#HOMEOMORPHIC_TRANS-val">HOMEOMORPHIC_TRANS</a> : thm
<a name="line897"></a>    val <a href="#HOMEOMORPHIC_TRANSLATION-val">HOMEOMORPHIC_TRANSLATION</a> : thm
<a name="line898"></a>    val <a href="#HOMEOMORPHIC_TRANSLATION_LEFT_EQ-val">HOMEOMORPHIC_TRANSLATION_LEFT_EQ</a> : thm
<a name="line899"></a>    val <a href="#HOMEOMORPHIC_TRANSLATION_RIGHT_EQ-val">HOMEOMORPHIC_TRANSLATION_RIGHT_EQ</a> : thm
<a name="line900"></a>    val <a href="#HOMEOMORPHIC_TRANSLATION_SELF-val">HOMEOMORPHIC_TRANSLATION_SELF</a> : thm
<a name="line901"></a>    val <a href="#HOMEOMORPHISM-val">HOMEOMORPHISM</a> : thm
<a name="line902"></a>    val <a href="#HOMEOMORPHISM_COMPACT-val">HOMEOMORPHISM_COMPACT</a> : thm
<a name="line903"></a>    val <a href="#HOMEOMORPHISM_COMPOSE-val">HOMEOMORPHISM_COMPOSE</a> : thm
<a name="line904"></a>    val <a href="#HOMEOMORPHISM_FROM_COMPOSITION_INJECTIVE-val">HOMEOMORPHISM_FROM_COMPOSITION_INJECTIVE</a> : thm
<a name="line905"></a>    val <a href="#HOMEOMORPHISM_FROM_COMPOSITION_SURJECTIVE-val">HOMEOMORPHISM_FROM_COMPOSITION_SURJECTIVE</a> : thm
<a name="line906"></a>    val <a href="#HOMEOMORPHISM_ID-val">HOMEOMORPHISM_ID</a> : thm
<a name="line907"></a>    val <a href="#HOMEOMORPHISM_IMP_CLOSED_MAP-val">HOMEOMORPHISM_IMP_CLOSED_MAP</a> : thm
<a name="line908"></a>    val <a href="#HOMEOMORPHISM_IMP_OPEN_MAP-val">HOMEOMORPHISM_IMP_OPEN_MAP</a> : thm
<a name="line909"></a>    val <a href="#HOMEOMORPHISM_IMP_QUOTIENT_MAP-val">HOMEOMORPHISM_IMP_QUOTIENT_MAP</a> : thm
<a name="line910"></a>    val <a href="#HOMEOMORPHISM_INJECTIVE_CLOSED_MAP-val">HOMEOMORPHISM_INJECTIVE_CLOSED_MAP</a> : thm
<a name="line911"></a>    val <a href="#HOMEOMORPHISM_INJECTIVE_CLOSED_MAP_EQ-val">HOMEOMORPHISM_INJECTIVE_CLOSED_MAP_EQ</a> : thm
<a name="line912"></a>    val <a href="#HOMEOMORPHISM_INJECTIVE_OPEN_MAP-val">HOMEOMORPHISM_INJECTIVE_OPEN_MAP</a> : thm
<a name="line913"></a>    val <a href="#HOMEOMORPHISM_INJECTIVE_OPEN_MAP_EQ-val">HOMEOMORPHISM_INJECTIVE_OPEN_MAP_EQ</a> : thm
<a name="line914"></a>    val <a href="#HOMEOMORPHISM_LOCALLY-val">HOMEOMORPHISM_LOCALLY</a> : thm
<a name="line915"></a>    val <a href="#HOMEOMORPHISM_OF_SUBSETS-val">HOMEOMORPHISM_OF_SUBSETS</a> : thm
<a name="line916"></a>    val <a href="#HOMEOMORPHISM_SYM-val">HOMEOMORPHISM_SYM</a> : thm
<a name="line917"></a>    val <a href="#IMAGE_AFFINITY_INTERVAL-val">IMAGE_AFFINITY_INTERVAL</a> : thm
<a name="line918"></a>    val <a href="#IMAGE_CLOSURE_SUBSET-val">IMAGE_CLOSURE_SUBSET</a> : thm
<a name="line919"></a>    val <a href="#IMAGE_STRETCH_INTERVAL-val">IMAGE_STRETCH_INTERVAL</a> : thm
<a name="line920"></a>    val <a href="#IMAGE_TWIZZLE_INTERVAL-val">IMAGE_TWIZZLE_INTERVAL</a> : thm
<a name="line921"></a>    val <a href="#INDEPENDENT_BOUND-val">INDEPENDENT_BOUND</a> : thm
<a name="line922"></a>    val <a href="#INDEPENDENT_CARD_LE_DIM-val">INDEPENDENT_CARD_LE_DIM</a> : thm
<a name="line923"></a>    val <a href="#INDEPENDENT_EMPTY-val">INDEPENDENT_EMPTY</a> : thm
<a name="line924"></a>    val <a href="#INDEPENDENT_INJECTIVE_IMAGE-val">INDEPENDENT_INJECTIVE_IMAGE</a> : thm
<a name="line925"></a>    val <a href="#INDEPENDENT_INJECTIVE_IMAGE_GEN-val">INDEPENDENT_INJECTIVE_IMAGE_GEN</a> : thm
<a name="line926"></a>    val <a href="#INDEPENDENT_INSERT-val">INDEPENDENT_INSERT</a> : thm
<a name="line927"></a>    val <a href="#INDEPENDENT_MONO-val">INDEPENDENT_MONO</a> : thm
<a name="line928"></a>    val <a href="#INDEPENDENT_NONZERO-val">INDEPENDENT_NONZERO</a> : thm
<a name="line929"></a>    val <a href="#INDEPENDENT_SING-val">INDEPENDENT_SING</a> : thm
<a name="line930"></a>    val <a href="#INDEPENDENT_SPAN_BOUND-val">INDEPENDENT_SPAN_BOUND</a> : thm
<a name="line931"></a>    val <a href="#INDEPENDENT_STDBASIS-val">INDEPENDENT_STDBASIS</a> : thm
<a name="line932"></a>    val <a href="#INFINITE_OPEN_IN-val">INFINITE_OPEN_IN</a> : thm
<a name="line933"></a>    val <a href="#INFINITE_SUPERSET-val">INFINITE_SUPERSET</a> : thm
<a name="line934"></a>    val <a href="#INFSUM_0-val">INFSUM_0</a> : thm
<a name="line935"></a>    val <a href="#INFSUM_ADD-val">INFSUM_ADD</a> : thm
<a name="line936"></a>    val <a href="#INFSUM_CMUL-val">INFSUM_CMUL</a> : thm
<a name="line937"></a>    val <a href="#INFSUM_EQ-val">INFSUM_EQ</a> : thm
<a name="line938"></a>    val <a href="#INFSUM_LINEAR-val">INFSUM_LINEAR</a> : thm
<a name="line939"></a>    val <a href="#INFSUM_NEG-val">INFSUM_NEG</a> : thm
<a name="line940"></a>    val <a href="#INFSUM_RESTRICT-val">INFSUM_RESTRICT</a> : thm
<a name="line941"></a>    val <a href="#INFSUM_SUB-val">INFSUM_SUB</a> : thm
<a name="line942"></a>    val <a href="#INFSUM_UNIQUE-val">INFSUM_UNIQUE</a> : thm
<a name="line943"></a>    val <a href="#INF_INSERT-val">INF_INSERT</a> : thm
<a name="line944"></a>    val <a href="#INJECTIVE_IMP_ISOMETRIC-val">INJECTIVE_IMP_ISOMETRIC</a> : thm
<a name="line945"></a>    val <a href="#INJECTIVE_MAP_OPEN_IFF_CLOSED-val">INJECTIVE_MAP_OPEN_IFF_CLOSED</a> : thm
<a name="line946"></a>    val <a href="#INTERIOR_BALL-val">INTERIOR_BALL</a> : thm
<a name="line947"></a>    val <a href="#INTERIOR_BIGINTER_SUBSET-val">INTERIOR_BIGINTER_SUBSET</a> : thm
<a name="line948"></a>    val <a href="#INTERIOR_BIJECTIVE_LINEAR_IMAGE-val">INTERIOR_BIJECTIVE_LINEAR_IMAGE</a> : thm
<a name="line949"></a>    val <a href="#INTERIOR_CBALL-val">INTERIOR_CBALL</a> : thm
<a name="line950"></a>    val <a href="#INTERIOR_CLOSED_EQ_EMPTY_AS_FRONTIER-val">INTERIOR_CLOSED_EQ_EMPTY_AS_FRONTIER</a> : thm
<a name="line951"></a>    val <a href="#INTERIOR_CLOSED_INTERVAL-val">INTERIOR_CLOSED_INTERVAL</a> : thm
<a name="line952"></a>    val <a href="#INTERIOR_CLOSED_UNION_EMPTY_INTERIOR-val">INTERIOR_CLOSED_UNION_EMPTY_INTERIOR</a> : thm
<a name="line953"></a>    val <a href="#INTERIOR_CLOSURE-val">INTERIOR_CLOSURE</a> : thm
<a name="line954"></a>    val <a href="#INTERIOR_CLOSURE_IDEMP-val">INTERIOR_CLOSURE_IDEMP</a> : thm
<a name="line955"></a>    val <a href="#INTERIOR_CLOSURE_INTER_OPEN-val">INTERIOR_CLOSURE_INTER_OPEN</a> : thm
<a name="line956"></a>    val <a href="#INTERIOR_COMPLEMENT-val">INTERIOR_COMPLEMENT</a> : thm
<a name="line957"></a>    val <a href="#INTERIOR_DIFF-val">INTERIOR_DIFF</a> : thm
<a name="line958"></a>    val <a href="#INTERIOR_EMPTY-val">INTERIOR_EMPTY</a> : thm
<a name="line959"></a>    val <a href="#INTERIOR_EQ-val">INTERIOR_EQ</a> : thm
<a name="line960"></a>    val <a href="#INTERIOR_EQ_EMPTY-val">INTERIOR_EQ_EMPTY</a> : thm
<a name="line961"></a>    val <a href="#INTERIOR_EQ_EMPTY_ALT-val">INTERIOR_EQ_EMPTY_ALT</a> : thm
<a name="line962"></a>    val <a href="#INTERIOR_FINITE_BIGINTER-val">INTERIOR_FINITE_BIGINTER</a> : thm
<a name="line963"></a>    val <a href="#INTERIOR_FRONTIER-val">INTERIOR_FRONTIER</a> : thm
<a name="line964"></a>    val <a href="#INTERIOR_FRONTIER_EMPTY-val">INTERIOR_FRONTIER_EMPTY</a> : thm
<a name="line965"></a>    val <a href="#INTERIOR_HALFSPACE_COMPONENT_GE-val">INTERIOR_HALFSPACE_COMPONENT_GE</a> : thm
<a name="line966"></a>    val <a href="#INTERIOR_HALFSPACE_COMPONENT_LE-val">INTERIOR_HALFSPACE_COMPONENT_LE</a> : thm
<a name="line967"></a>    val <a href="#INTERIOR_HALFSPACE_GE-val">INTERIOR_HALFSPACE_GE</a> : thm
<a name="line968"></a>    val <a href="#INTERIOR_HALFSPACE_LE-val">INTERIOR_HALFSPACE_LE</a> : thm
<a name="line969"></a>    val <a href="#INTERIOR_HYPERPLANE-val">INTERIOR_HYPERPLANE</a> : thm
<a name="line970"></a>    val <a href="#INTERIOR_IMAGE_SUBSET-val">INTERIOR_IMAGE_SUBSET</a> : thm
<a name="line971"></a>    val <a href="#INTERIOR_INJECTIVE_LINEAR_IMAGE-val">INTERIOR_INJECTIVE_LINEAR_IMAGE</a> : thm
<a name="line972"></a>    val <a href="#INTERIOR_INTER-val">INTERIOR_INTER</a> : thm
<a name="line973"></a>    val <a href="#INTERIOR_INTERIOR-val">INTERIOR_INTERIOR</a> : thm
<a name="line974"></a>    val <a href="#INTERIOR_INTERVAL-val">INTERIOR_INTERVAL</a> : thm
<a name="line975"></a>    val <a href="#INTERIOR_LIMIT_POINT-val">INTERIOR_LIMIT_POINT</a> : thm
<a name="line976"></a>    val <a href="#INTERIOR_MAXIMAL-val">INTERIOR_MAXIMAL</a> : thm
<a name="line977"></a>    val <a href="#INTERIOR_MAXIMAL_EQ-val">INTERIOR_MAXIMAL_EQ</a> : thm
<a name="line978"></a>    val <a href="#INTERIOR_NEGATIONS-val">INTERIOR_NEGATIONS</a> : thm
<a name="line979"></a>    val <a href="#INTERIOR_OPEN-val">INTERIOR_OPEN</a> : thm
<a name="line980"></a>    val <a href="#INTERIOR_SING-val">INTERIOR_SING</a> : thm
<a name="line981"></a>    val <a href="#INTERIOR_STANDARD_HYPERPLANE-val">INTERIOR_STANDARD_HYPERPLANE</a> : thm
<a name="line982"></a>    val <a href="#INTERIOR_SUBSET-val">INTERIOR_SUBSET</a> : thm
<a name="line983"></a>    val <a href="#INTERIOR_TRANSLATION-val">INTERIOR_TRANSLATION</a> : thm
<a name="line984"></a>    val <a href="#INTERIOR_UNIONS_OPEN_SUBSETS-val">INTERIOR_UNIONS_OPEN_SUBSETS</a> : thm
<a name="line985"></a>    val <a href="#INTERIOR_UNION_EQ_EMPTY-val">INTERIOR_UNION_EQ_EMPTY</a> : thm
<a name="line986"></a>    val <a href="#INTERIOR_UNIQUE-val">INTERIOR_UNIQUE</a> : thm
<a name="line987"></a>    val <a href="#INTERIOR_UNIV-val">INTERIOR_UNIV</a> : thm
<a name="line988"></a>    val <a href="#INTERVAL-val">INTERVAL</a> : thm
<a name="line989"></a>    val <a href="#INTERVAL_BOUNDS_EMPTY-val">INTERVAL_BOUNDS_EMPTY</a> : thm
<a name="line990"></a>    val <a href="#INTERVAL_BOUNDS_NULL-val">INTERVAL_BOUNDS_NULL</a> : thm
<a name="line991"></a>    val <a href="#INTERVAL_CASES-val">INTERVAL_CASES</a> : thm
<a name="line992"></a>    val <a href="#INTERVAL_CONTAINS_COMPACT_NEIGHBOURHOOD-val">INTERVAL_CONTAINS_COMPACT_NEIGHBOURHOOD</a> : thm
<a name="line993"></a>    val <a href="#INTERVAL_EQ_EMPTY-val">INTERVAL_EQ_EMPTY</a> : thm
<a name="line994"></a>    val <a href="#INTERVAL_IMAGE_STRETCH_INTERVAL-val">INTERVAL_IMAGE_STRETCH_INTERVAL</a> : thm
<a name="line995"></a>    val <a href="#INTERVAL_LOWERBOUND-val">INTERVAL_LOWERBOUND</a> : thm
<a name="line996"></a>    val <a href="#INTERVAL_LOWERBOUND_NONEMPTY-val">INTERVAL_LOWERBOUND_NONEMPTY</a> : thm
<a name="line997"></a>    val <a href="#INTERVAL_NE_EMPTY-val">INTERVAL_NE_EMPTY</a> : thm
<a name="line998"></a>    val <a href="#INTERVAL_OPEN_SUBSET_CLOSED-val">INTERVAL_OPEN_SUBSET_CLOSED</a> : thm
<a name="line999"></a>    val <a href="#INTERVAL_SING-val">INTERVAL_SING</a> : thm
<a name="line1000"></a>    val <a href="#INTERVAL_SUBSET_IS_INTERVAL-val">INTERVAL_SUBSET_IS_INTERVAL</a> : thm
<a name="line1001"></a>    val <a href="#INTERVAL_TRANSLATION-val">INTERVAL_TRANSLATION</a> : thm
<a name="line1002"></a>    val <a href="#INTERVAL_UPPERBOUND-val">INTERVAL_UPPERBOUND</a> : thm
<a name="line1003"></a>    val <a href="#INTERVAL_UPPERBOUND_NONEMPTY-val">INTERVAL_UPPERBOUND_NONEMPTY</a> : thm
<a name="line1004"></a>    val <a href="#INTER_BALLS_EQ_EMPTY-val">INTER_BALLS_EQ_EMPTY</a> : thm
<a name="line1005"></a>    val <a href="#INTER_INTERVAL-val">INTER_INTERVAL</a> : thm
<a name="line1006"></a>    val <a href="#INTER_INTERVAL_MIXED_EQ_EMPTY-val">INTER_INTERVAL_MIXED_EQ_EMPTY</a> : thm
<a name="line1007"></a>    val <a href="#IN_BALL-val">IN_BALL</a> : thm
<a name="line1008"></a>    val <a href="#IN_BALL_0-val">IN_BALL_0</a> : thm
<a name="line1009"></a>    val <a href="#IN_CBALL-val">IN_CBALL</a> : thm
<a name="line1010"></a>    val <a href="#IN_CBALL_0-val">IN_CBALL_0</a> : thm
<a name="line1011"></a>    val <a href="#IN_CLOSURE_DELETE-val">IN_CLOSURE_DELETE</a> : thm
<a name="line1012"></a>    val <a href="#IN_COMPONENTS-val">IN_COMPONENTS</a> : thm
<a name="line1013"></a>    val <a href="#IN_COMPONENTS_BIGUNION_COMPLEMENT-val">IN_COMPONENTS_BIGUNION_COMPLEMENT</a> : thm
<a name="line1014"></a>    val <a href="#IN_COMPONENTS_CONNECTED-val">IN_COMPONENTS_CONNECTED</a> : thm
<a name="line1015"></a>    val <a href="#IN_COMPONENTS_MAXIMAL-val">IN_COMPONENTS_MAXIMAL</a> : thm
<a name="line1016"></a>    val <a href="#IN_COMPONENTS_NONEMPTY-val">IN_COMPONENTS_NONEMPTY</a> : thm
<a name="line1017"></a>    val <a href="#IN_COMPONENTS_SELF-val">IN_COMPONENTS_SELF</a> : thm
<a name="line1018"></a>    val <a href="#IN_COMPONENTS_SUBSET-val">IN_COMPONENTS_SUBSET</a> : thm
<a name="line1019"></a>    val <a href="#IN_DIRECTION-val">IN_DIRECTION</a> : thm
<a name="line1020"></a>    val <a href="#IN_INTERIOR-val">IN_INTERIOR</a> : thm
<a name="line1021"></a>    val <a href="#IN_INTERIOR_CBALL-val">IN_INTERIOR_CBALL</a> : thm
<a name="line1022"></a>    val <a href="#IN_INTERIOR_LINEAR_IMAGE-val">IN_INTERIOR_LINEAR_IMAGE</a> : thm
<a name="line1023"></a>    val <a href="#IN_INTERVAL-val">IN_INTERVAL</a> : thm
<a name="line1024"></a>    val <a href="#IN_INTERVAL_REFLECT-val">IN_INTERVAL_REFLECT</a> : thm
<a name="line1025"></a>    val <a href="#IN_OPEN_SEGMENT-val">IN_OPEN_SEGMENT</a> : thm
<a name="line1026"></a>    val <a href="#IN_OPEN_SEGMENT_ALT-val">IN_OPEN_SEGMENT_ALT</a> : thm
<a name="line1027"></a>    val <a href="#IN_SEGMENT-val">IN_SEGMENT</a> : thm
<a name="line1028"></a>    val <a href="#IN_SEGMENT_COMPONENT-val">IN_SEGMENT_COMPONENT</a> : thm
<a name="line1029"></a>    val <a href="#IN_SPAN_DELETE-val">IN_SPAN_DELETE</a> : thm
<a name="line1030"></a>    val <a href="#IN_SPAN_INSERT-val">IN_SPAN_INSERT</a> : thm
<a name="line1031"></a>    val <a href="#IN_SPHERE-val">IN_SPHERE</a> : thm
<a name="line1032"></a>    val <a href="#IN_SPHERE_0-val">IN_SPHERE_0</a> : thm
<a name="line1033"></a>    val <a href="#ISOMETRY_IMP_EMBEDDING-val">ISOMETRY_IMP_EMBEDDING</a> : thm
<a name="line1034"></a>    val <a href="#ISOMETRY_IMP_HOMEOMORPHISM_COMPACT-val">ISOMETRY_IMP_HOMEOMORPHISM_COMPACT</a> : thm
<a name="line1035"></a>    val <a href="#ISOMETRY_IMP_OPEN_MAP-val">ISOMETRY_IMP_OPEN_MAP</a> : thm
<a name="line1036"></a>    val <a href="#ISOMETRY_ON_IMP_CONTINUOUS_ON-val">ISOMETRY_ON_IMP_CONTINUOUS_ON</a> : thm
<a name="line1037"></a>    val <a href="#IS_INTERVAL-val">IS_INTERVAL</a> : thm
<a name="line1038"></a>    val <a href="#IS_INTERVAL_CASES-val">IS_INTERVAL_CASES</a> : thm
<a name="line1039"></a>    val <a href="#IS_INTERVAL_COMPACT-val">IS_INTERVAL_COMPACT</a> : thm
<a name="line1040"></a>    val <a href="#IS_INTERVAL_EMPTY-val">IS_INTERVAL_EMPTY</a> : thm
<a name="line1041"></a>    val <a href="#IS_INTERVAL_IMP_LOCALLY_COMPACT-val">IS_INTERVAL_IMP_LOCALLY_COMPACT</a> : thm
<a name="line1042"></a>    val <a href="#IS_INTERVAL_INTER-val">IS_INTERVAL_INTER</a> : thm
<a name="line1043"></a>    val <a href="#IS_INTERVAL_INTERVAL-val">IS_INTERVAL_INTERVAL</a> : thm
<a name="line1044"></a>    val <a href="#IS_INTERVAL_POINTWISE-val">IS_INTERVAL_POINTWISE</a> : thm
<a name="line1045"></a>    val <a href="#IS_INTERVAL_SCALING-val">IS_INTERVAL_SCALING</a> : thm
<a name="line1046"></a>    val <a href="#IS_INTERVAL_SCALING_EQ-val">IS_INTERVAL_SCALING_EQ</a> : thm
<a name="line1047"></a>    val <a href="#IS_INTERVAL_SING-val">IS_INTERVAL_SING</a> : thm
<a name="line1048"></a>    val <a href="#IS_INTERVAL_SUMS-val">IS_INTERVAL_SUMS</a> : thm
<a name="line1049"></a>    val <a href="#IS_INTERVAL_UNIV-val">IS_INTERVAL_UNIV</a> : thm
<a name="line1050"></a>    val <a href="#JOINABLE_COMPONENTS_EQ-val">JOINABLE_COMPONENTS_EQ</a> : thm
<a name="line1051"></a>    val <a href="#JOINABLE_CONNECTED_COMPONENT_EQ-val">JOINABLE_CONNECTED_COMPONENT_EQ</a> : thm
<a name="line1052"></a>    val <a href="#LEBESGUE_COVERING_LEMMA-val">LEBESGUE_COVERING_LEMMA</a> : thm
<a name="line1053"></a>    val <a href="#LE_1-val">LE_1</a> : thm
<a name="line1054"></a>    val <a href="#LIFT_TO_QUOTIENT_SPACE-val">LIFT_TO_QUOTIENT_SPACE</a> : thm
<a name="line1055"></a>    val <a href="#LIFT_TO_QUOTIENT_SPACE_UNIQUE-val">LIFT_TO_QUOTIENT_SPACE_UNIQUE</a> : thm
<a name="line1056"></a>    val <a href="#LIMIT_POINT_FINITE-val">LIMIT_POINT_FINITE</a> : thm
<a name="line1057"></a>    val <a href="#LIMIT_POINT_UNION-val">LIMIT_POINT_UNION</a> : thm
<a name="line1058"></a>    val <a href="#LIMPT_APPROACHABLE-val">LIMPT_APPROACHABLE</a> : thm
<a name="line1059"></a>    val <a href="#LIMPT_APPROACHABLE_LE-val">LIMPT_APPROACHABLE_LE</a> : thm
<a name="line1060"></a>    val <a href="#LIMPT_BALL-val">LIMPT_BALL</a> : thm
<a name="line1061"></a>    val <a href="#LIMPT_EMPTY-val">LIMPT_EMPTY</a> : thm
<a name="line1062"></a>    val <a href="#LIMPT_INFINITE_BALL-val">LIMPT_INFINITE_BALL</a> : thm
<a name="line1063"></a>    val <a href="#LIMPT_INFINITE_CBALL-val">LIMPT_INFINITE_CBALL</a> : thm
<a name="line1064"></a>    val <a href="#LIMPT_INFINITE_OPEN-val">LIMPT_INFINITE_OPEN</a> : thm
<a name="line1065"></a>    val <a href="#LIMPT_INFINITE_OPEN_BALL_CBALL-val">LIMPT_INFINITE_OPEN_BALL_CBALL</a> : thm
<a name="line1066"></a>    val <a href="#LIMPT_INJECTIVE_LINEAR_IMAGE_EQ-val">LIMPT_INJECTIVE_LINEAR_IMAGE_EQ</a> : thm
<a name="line1067"></a>    val <a href="#LIMPT_INSERT-val">LIMPT_INSERT</a> : thm
<a name="line1068"></a>    val <a href="#LIMPT_OF_CLOSURE-val">LIMPT_OF_CLOSURE</a> : thm
<a name="line1069"></a>    val <a href="#LIMPT_OF_LIMPTS-val">LIMPT_OF_LIMPTS</a> : thm
<a name="line1070"></a>    val <a href="#LIMPT_OF_OPEN-val">LIMPT_OF_OPEN</a> : thm
<a name="line1071"></a>    val <a href="#LIMPT_OF_OPEN_IN-val">LIMPT_OF_OPEN_IN</a> : thm
<a name="line1072"></a>    val <a href="#LIMPT_OF_SEQUENCE_SUBSEQUENCE-val">LIMPT_OF_SEQUENCE_SUBSEQUENCE</a> : thm
<a name="line1073"></a>    val <a href="#LIMPT_OF_UNIV-val">LIMPT_OF_UNIV</a> : thm
<a name="line1074"></a>    val <a href="#LIMPT_SEQUENTIAL-val">LIMPT_SEQUENTIAL</a> : thm
<a name="line1075"></a>    val <a href="#LIMPT_SEQUENTIAL_INJ-val">LIMPT_SEQUENTIAL_INJ</a> : thm
<a name="line1076"></a>    val <a href="#LIMPT_SING-val">LIMPT_SING</a> : thm
<a name="line1077"></a>    val <a href="#LIMPT_SUBSET-val">LIMPT_SUBSET</a> : thm
<a name="line1078"></a>    val <a href="#LIMPT_UNIV-val">LIMPT_UNIV</a> : thm
<a name="line1079"></a>    val <a href="#LIM_ABS-val">LIM_ABS</a> : thm
<a name="line1080"></a>    val <a href="#LIM_ABS_LBOUND-val">LIM_ABS_LBOUND</a> : thm
<a name="line1081"></a>    val <a href="#LIM_ABS_UBOUND-val">LIM_ABS_UBOUND</a> : thm
<a name="line1082"></a>    val <a href="#LIM_ADD-val">LIM_ADD</a> : thm
<a name="line1083"></a>    val <a href="#LIM_AT-val">LIM_AT</a> : thm
<a name="line1084"></a>    val <a href="#LIM_AT_ID-val">LIM_AT_ID</a> : thm
<a name="line1085"></a>    val <a href="#LIM_AT_INFINITY-val">LIM_AT_INFINITY</a> : thm
<a name="line1086"></a>    val <a href="#LIM_AT_INFINITY_POS-val">LIM_AT_INFINITY_POS</a> : thm
<a name="line1087"></a>    val <a href="#LIM_AT_LE-val">LIM_AT_LE</a> : thm
<a name="line1088"></a>    val <a href="#LIM_AT_NEGINFINITY-val">LIM_AT_NEGINFINITY</a> : thm
<a name="line1089"></a>    val <a href="#LIM_AT_POSINFINITY-val">LIM_AT_POSINFINITY</a> : thm
<a name="line1090"></a>    val <a href="#LIM_AT_WITHIN-val">LIM_AT_WITHIN</a> : thm
<a name="line1091"></a>    val <a href="#LIM_AT_ZERO-val">LIM_AT_ZERO</a> : thm
<a name="line1092"></a>    val <a href="#LIM_BILINEAR-val">LIM_BILINEAR</a> : thm
<a name="line1093"></a>    val <a href="#LIM_CASES_COFINITE_SEQUENTIALLY-val">LIM_CASES_COFINITE_SEQUENTIALLY</a> : thm
<a name="line1094"></a>    val <a href="#LIM_CASES_FINITE_SEQUENTIALLY-val">LIM_CASES_FINITE_SEQUENTIALLY</a> : thm
<a name="line1095"></a>    val <a href="#LIM_CASES_SEQUENTIALLY-val">LIM_CASES_SEQUENTIALLY</a> : thm
<a name="line1096"></a>    val <a href="#LIM_CMUL-val">LIM_CMUL</a> : thm
<a name="line1097"></a>    val <a href="#LIM_CMUL_EQ-val">LIM_CMUL_EQ</a> : thm
<a name="line1098"></a>    val <a href="#LIM_COMPONENT-val">LIM_COMPONENT</a> : thm
<a name="line1099"></a>    val <a href="#LIM_COMPONENT_EQ-val">LIM_COMPONENT_EQ</a> : thm
<a name="line1100"></a>    val <a href="#LIM_COMPONENT_LBOUND-val">LIM_COMPONENT_LBOUND</a> : thm
<a name="line1101"></a>    val <a href="#LIM_COMPONENT_LE-val">LIM_COMPONENT_LE</a> : thm
<a name="line1102"></a>    val <a href="#LIM_COMPONENT_UBOUND-val">LIM_COMPONENT_UBOUND</a> : thm
<a name="line1103"></a>    val <a href="#LIM_COMPOSE_AT-val">LIM_COMPOSE_AT</a> : thm
<a name="line1104"></a>    val <a href="#LIM_COMPOSE_WITHIN-val">LIM_COMPOSE_WITHIN</a> : thm
<a name="line1105"></a>    val <a href="#LIM_CONG_AT-val">LIM_CONG_AT</a> : thm
<a name="line1106"></a>    val <a href="#LIM_CONG_WITHIN-val">LIM_CONG_WITHIN</a> : thm
<a name="line1107"></a>    val <a href="#LIM_CONST-val">LIM_CONST</a> : thm
<a name="line1108"></a>    val <a href="#LIM_CONST_EQ-val">LIM_CONST_EQ</a> : thm
<a name="line1109"></a>    val <a href="#LIM_CONTINUOUS_FUNCTION-val">LIM_CONTINUOUS_FUNCTION</a> : thm
<a name="line1110"></a>    val <a href="#LIM_DEF-val">LIM_DEF</a> : thm
<a name="line1111"></a>    val <a href="#LIM_DROP_LBOUND-val">LIM_DROP_LBOUND</a> : thm
<a name="line1112"></a>    val <a href="#LIM_DROP_LE-val">LIM_DROP_LE</a> : thm
<a name="line1113"></a>    val <a href="#LIM_DROP_UBOUND-val">LIM_DROP_UBOUND</a> : thm
<a name="line1114"></a>    val <a href="#LIM_EVENTUALLY-val">LIM_EVENTUALLY</a> : thm
<a name="line1115"></a>    val <a href="#LIM_INFINITY_POSINFINITY-val">LIM_INFINITY_POSINFINITY</a> : thm
<a name="line1116"></a>    val <a href="#LIM_INV-val">LIM_INV</a> : thm
<a name="line1117"></a>    val <a href="#LIM_IN_CLOSED_SET-val">LIM_IN_CLOSED_SET</a> : thm
<a name="line1118"></a>    val <a href="#LIM_LIFT_DOT-val">LIM_LIFT_DOT</a> : thm
<a name="line1119"></a>    val <a href="#LIM_LINEAR-val">LIM_LINEAR</a> : thm
<a name="line1120"></a>    val <a href="#LIM_MAX-val">LIM_MAX</a> : thm
<a name="line1121"></a>    val <a href="#LIM_MIN-val">LIM_MIN</a> : thm
<a name="line1122"></a>    val <a href="#LIM_MUL-val">LIM_MUL</a> : thm
<a name="line1123"></a>    val <a href="#LIM_NEG-val">LIM_NEG</a> : thm
<a name="line1124"></a>    val <a href="#LIM_NEG_EQ-val">LIM_NEG_EQ</a> : thm
<a name="line1125"></a>    val <a href="#LIM_NULL-val">LIM_NULL</a> : thm
<a name="line1126"></a>    val <a href="#LIM_NULL_ABS-val">LIM_NULL_ABS</a> : thm
<a name="line1127"></a>    val <a href="#LIM_NULL_ADD-val">LIM_NULL_ADD</a> : thm
<a name="line1128"></a>    val <a href="#LIM_NULL_CMUL-val">LIM_NULL_CMUL</a> : thm
<a name="line1129"></a>    val <a href="#LIM_NULL_CMUL_BOUNDED-val">LIM_NULL_CMUL_BOUNDED</a> : thm
<a name="line1130"></a>    val <a href="#LIM_NULL_CMUL_EQ-val">LIM_NULL_CMUL_EQ</a> : thm
<a name="line1131"></a>    val <a href="#LIM_NULL_COMPARISON-val">LIM_NULL_COMPARISON</a> : thm
<a name="line1132"></a>    val <a href="#LIM_NULL_SUB-val">LIM_NULL_SUB</a> : thm
<a name="line1133"></a>    val <a href="#LIM_NULL_SUM-val">LIM_NULL_SUM</a> : thm
<a name="line1134"></a>    val <a href="#LIM_POSINFINITY_SEQUENTIALLY-val">LIM_POSINFINITY_SEQUENTIALLY</a> : thm
<a name="line1135"></a>    val <a href="#LIM_SEQUENTIALLY-val">LIM_SEQUENTIALLY</a> : thm
<a name="line1136"></a>    val <a href="#LIM_SUB-val">LIM_SUB</a> : thm
<a name="line1137"></a>    val <a href="#LIM_SUBSEQUENCE-val">LIM_SUBSEQUENCE</a> : thm
<a name="line1138"></a>    val <a href="#LIM_SUBSEQUENCE_WEAK-val">LIM_SUBSEQUENCE_WEAK</a> : thm
<a name="line1139"></a>    val <a href="#LIM_SUM-val">LIM_SUM</a> : thm
<a name="line1140"></a>    val <a href="#LIM_TRANSFORM-val">LIM_TRANSFORM</a> : thm
<a name="line1141"></a>    val <a href="#LIM_TRANSFORM_AT-val">LIM_TRANSFORM_AT</a> : thm
<a name="line1142"></a>    val <a href="#LIM_TRANSFORM_AWAY_AT-val">LIM_TRANSFORM_AWAY_AT</a> : thm
<a name="line1143"></a>    val <a href="#LIM_TRANSFORM_AWAY_WITHIN-val">LIM_TRANSFORM_AWAY_WITHIN</a> : thm
<a name="line1144"></a>    val <a href="#LIM_TRANSFORM_BOUND-val">LIM_TRANSFORM_BOUND</a> : thm
<a name="line1145"></a>    val <a href="#LIM_TRANSFORM_EQ-val">LIM_TRANSFORM_EQ</a> : thm
<a name="line1146"></a>    val <a href="#LIM_TRANSFORM_EVENTUALLY-val">LIM_TRANSFORM_EVENTUALLY</a> : thm
<a name="line1147"></a>    val <a href="#LIM_TRANSFORM_WITHIN-val">LIM_TRANSFORM_WITHIN</a> : thm
<a name="line1148"></a>    val <a href="#LIM_TRANSFORM_WITHIN_OPEN-val">LIM_TRANSFORM_WITHIN_OPEN</a> : thm
<a name="line1149"></a>    val <a href="#LIM_TRANSFORM_WITHIN_OPEN_IN-val">LIM_TRANSFORM_WITHIN_OPEN_IN</a> : thm
<a name="line1150"></a>    val <a href="#LIM_TRANSFORM_WITHIN_SET-val">LIM_TRANSFORM_WITHIN_SET</a> : thm
<a name="line1151"></a>    val <a href="#LIM_TRANSFORM_WITHIN_SET_IMP-val">LIM_TRANSFORM_WITHIN_SET_IMP</a> : thm
<a name="line1152"></a>    val <a href="#LIM_UNION-val">LIM_UNION</a> : thm
<a name="line1153"></a>    val <a href="#LIM_UNION_UNIV-val">LIM_UNION_UNIV</a> : thm
<a name="line1154"></a>    val <a href="#LIM_UNIQUE-val">LIM_UNIQUE</a> : thm
<a name="line1155"></a>    val <a href="#LIM_VMUL-val">LIM_VMUL</a> : thm
<a name="line1156"></a>    val <a href="#LIM_WITHIN-val">LIM_WITHIN</a> : thm
<a name="line1157"></a>    val <a href="#LIM_WITHIN_CLOSED_TRIVIAL-val">LIM_WITHIN_CLOSED_TRIVIAL</a> : thm
<a name="line1158"></a>    val <a href="#LIM_WITHIN_EMPTY-val">LIM_WITHIN_EMPTY</a> : thm
<a name="line1159"></a>    val <a href="#LIM_WITHIN_ID-val">LIM_WITHIN_ID</a> : thm
<a name="line1160"></a>    val <a href="#LIM_WITHIN_INTERIOR-val">LIM_WITHIN_INTERIOR</a> : thm
<a name="line1161"></a>    val <a href="#LIM_WITHIN_LE-val">LIM_WITHIN_LE</a> : thm
<a name="line1162"></a>    val <a href="#LIM_WITHIN_OPEN-val">LIM_WITHIN_OPEN</a> : thm
<a name="line1163"></a>    val <a href="#LIM_WITHIN_SUBSET-val">LIM_WITHIN_SUBSET</a> : thm
<a name="line1164"></a>    val <a href="#LIM_WITHIN_UNION-val">LIM_WITHIN_UNION</a> : thm
<a name="line1165"></a>    val <a href="#LINEAR_0-val">LINEAR_0</a> : thm
<a name="line1166"></a>    val <a href="#LINEAR_ADD-val">LINEAR_ADD</a> : thm
<a name="line1167"></a>    val <a href="#LINEAR_BOUNDED-val">LINEAR_BOUNDED</a> : thm
<a name="line1168"></a>    val <a href="#LINEAR_BOUNDED_POS-val">LINEAR_BOUNDED_POS</a> : thm
<a name="line1169"></a>    val <a href="#LINEAR_CMUL-val">LINEAR_CMUL</a> : thm
<a name="line1170"></a>    val <a href="#LINEAR_COMPOSE-val">LINEAR_COMPOSE</a> : thm
<a name="line1171"></a>    val <a href="#LINEAR_COMPOSE_ADD-val">LINEAR_COMPOSE_ADD</a> : thm
<a name="line1172"></a>    val <a href="#LINEAR_COMPOSE_CMUL-val">LINEAR_COMPOSE_CMUL</a> : thm
<a name="line1173"></a>    val <a href="#LINEAR_COMPOSE_NEG-val">LINEAR_COMPOSE_NEG</a> : thm
<a name="line1174"></a>    val <a href="#LINEAR_COMPOSE_SUB-val">LINEAR_COMPOSE_SUB</a> : thm
<a name="line1175"></a>    val <a href="#LINEAR_COMPOSE_SUM-val">LINEAR_COMPOSE_SUM</a> : thm
<a name="line1176"></a>    val <a href="#LINEAR_CONTINUOUS_AT-val">LINEAR_CONTINUOUS_AT</a> : thm
<a name="line1177"></a>    val <a href="#LINEAR_CONTINUOUS_COMPOSE-val">LINEAR_CONTINUOUS_COMPOSE</a> : thm
<a name="line1178"></a>    val <a href="#LINEAR_CONTINUOUS_ON-val">LINEAR_CONTINUOUS_ON</a> : thm
<a name="line1179"></a>    val <a href="#LINEAR_CONTINUOUS_ON_COMPOSE-val">LINEAR_CONTINUOUS_ON_COMPOSE</a> : thm
<a name="line1180"></a>    val <a href="#LINEAR_CONTINUOUS_WITHIN-val">LINEAR_CONTINUOUS_WITHIN</a> : thm
<a name="line1181"></a>    val <a href="#LINEAR_EQ-val">LINEAR_EQ</a> : thm
<a name="line1182"></a>    val <a href="#LINEAR_EQ_0-val">LINEAR_EQ_0</a> : thm
<a name="line1183"></a>    val <a href="#LINEAR_EQ_0_SPAN-val">LINEAR_EQ_0_SPAN</a> : thm
<a name="line1184"></a>    val <a href="#LINEAR_EQ_STDBASIS-val">LINEAR_EQ_STDBASIS</a> : thm
<a name="line1185"></a>    val <a href="#LINEAR_ID-val">LINEAR_ID</a> : thm
<a name="line1186"></a>    val <a href="#LINEAR_IMAGE_SUBSET_INTERIOR-val">LINEAR_IMAGE_SUBSET_INTERIOR</a> : thm
<a name="line1187"></a>    val <a href="#LINEAR_INDEPENDENT_EXTEND-val">LINEAR_INDEPENDENT_EXTEND</a> : thm
<a name="line1188"></a>    val <a href="#LINEAR_INDEPENDENT_EXTEND_LEMMA-val">LINEAR_INDEPENDENT_EXTEND_LEMMA</a> : thm
<a name="line1189"></a>    val <a href="#LINEAR_INJECTIVE_0_SUBSPACE-val">LINEAR_INJECTIVE_0_SUBSPACE</a> : thm
<a name="line1190"></a>    val <a href="#LINEAR_INJECTIVE_BOUNDED_BELOW_POS-val">LINEAR_INJECTIVE_BOUNDED_BELOW_POS</a> : thm
<a name="line1191"></a>    val <a href="#LINEAR_INJECTIVE_IMP_SURJECTIVE-val">LINEAR_INJECTIVE_IMP_SURJECTIVE</a> : thm
<a name="line1192"></a>    val <a href="#LINEAR_INJECTIVE_LEFT_INVERSE-val">LINEAR_INJECTIVE_LEFT_INVERSE</a> : thm
<a name="line1193"></a>    val <a href="#LINEAR_INTERIOR_IMAGE_SUBSET-val">LINEAR_INTERIOR_IMAGE_SUBSET</a> : thm
<a name="line1194"></a>    val <a href="#LINEAR_INVERTIBLE_BOUNDED_BELOW-val">LINEAR_INVERTIBLE_BOUNDED_BELOW</a> : thm
<a name="line1195"></a>    val <a href="#LINEAR_INVERTIBLE_BOUNDED_BELOW_POS-val">LINEAR_INVERTIBLE_BOUNDED_BELOW_POS</a> : thm
<a name="line1196"></a>    val <a href="#LINEAR_LIM_0-val">LINEAR_LIM_0</a> : thm
<a name="line1197"></a>    val <a href="#LINEAR_MUL_COMPONENT-val">LINEAR_MUL_COMPONENT</a> : thm
<a name="line1198"></a>    val <a href="#LINEAR_NEG-val">LINEAR_NEG</a> : thm
<a name="line1199"></a>    val <a href="#LINEAR_NEGATION-val">LINEAR_NEGATION</a> : thm
<a name="line1200"></a>    val <a href="#LINEAR_OPEN_MAPPING-val">LINEAR_OPEN_MAPPING</a> : thm
<a name="line1201"></a>    val <a href="#LINEAR_SCALING-val">LINEAR_SCALING</a> : thm
<a name="line1202"></a>    val <a href="#LINEAR_SUB-val">LINEAR_SUB</a> : thm
<a name="line1203"></a>    val <a href="#LINEAR_SUM-val">LINEAR_SUM</a> : thm
<a name="line1204"></a>    val <a href="#LINEAR_SUM_MUL-val">LINEAR_SUM_MUL</a> : thm
<a name="line1205"></a>    val <a href="#LINEAR_UNIFORMLY_CONTINUOUS_ON-val">LINEAR_UNIFORMLY_CONTINUOUS_ON</a> : thm
<a name="line1206"></a>    val <a href="#LINEAR_ZERO-val">LINEAR_ZERO</a> : thm
<a name="line1207"></a>    val <a href="#LOCALLY_CLOSED-val">LOCALLY_CLOSED</a> : thm
<a name="line1208"></a>    val <a href="#LOCALLY_COMPACT-val">LOCALLY_COMPACT</a> : thm
<a name="line1209"></a>    val <a href="#LOCALLY_COMPACT_ALT-val">LOCALLY_COMPACT_ALT</a> : thm
<a name="line1210"></a>    val <a href="#LOCALLY_COMPACT_CLOSED_IN-val">LOCALLY_COMPACT_CLOSED_IN</a> : thm
<a name="line1211"></a>    val <a href="#LOCALLY_COMPACT_CLOSED_INTER_OPEN-val">LOCALLY_COMPACT_CLOSED_INTER_OPEN</a> : thm
<a name="line1212"></a>    val <a href="#LOCALLY_COMPACT_CLOSED_IN_OPEN-val">LOCALLY_COMPACT_CLOSED_IN_OPEN</a> : thm
<a name="line1213"></a>    val <a href="#LOCALLY_COMPACT_CLOSED_UNION-val">LOCALLY_COMPACT_CLOSED_UNION</a> : thm
<a name="line1214"></a>    val <a href="#LOCALLY_COMPACT_COMPACT-val">LOCALLY_COMPACT_COMPACT</a> : thm
<a name="line1215"></a>    val <a href="#LOCALLY_COMPACT_COMPACT_ALT-val">LOCALLY_COMPACT_COMPACT_ALT</a> : thm
<a name="line1216"></a>    val <a href="#LOCALLY_COMPACT_COMPACT_SUBOPEN-val">LOCALLY_COMPACT_COMPACT_SUBOPEN</a> : thm
<a name="line1217"></a>    val <a href="#LOCALLY_COMPACT_DELETE-val">LOCALLY_COMPACT_DELETE</a> : thm
<a name="line1218"></a>    val <a href="#LOCALLY_COMPACT_INTER-val">LOCALLY_COMPACT_INTER</a> : thm
<a name="line1219"></a>    val <a href="#LOCALLY_COMPACT_INTER_CBALL-val">LOCALLY_COMPACT_INTER_CBALL</a> : thm
<a name="line1220"></a>    val <a href="#LOCALLY_COMPACT_INTER_CBALLS-val">LOCALLY_COMPACT_INTER_CBALLS</a> : thm
<a name="line1221"></a>    val <a href="#LOCALLY_COMPACT_OPEN_IN-val">LOCALLY_COMPACT_OPEN_IN</a> : thm
<a name="line1222"></a>    val <a href="#LOCALLY_COMPACT_OPEN_INTER_CLOSURE-val">LOCALLY_COMPACT_OPEN_INTER_CLOSURE</a> : thm
<a name="line1223"></a>    val <a href="#LOCALLY_COMPACT_OPEN_UNION-val">LOCALLY_COMPACT_OPEN_UNION</a> : thm
<a name="line1224"></a>    val <a href="#LOCALLY_COMPACT_PROPER_IMAGE-val">LOCALLY_COMPACT_PROPER_IMAGE</a> : thm
<a name="line1225"></a>    val <a href="#LOCALLY_COMPACT_PROPER_IMAGE_EQ-val">LOCALLY_COMPACT_PROPER_IMAGE_EQ</a> : thm
<a name="line1226"></a>    val <a href="#LOCALLY_COMPACT_TRANSLATION_EQ-val">LOCALLY_COMPACT_TRANSLATION_EQ</a> : thm
<a name="line1227"></a>    val <a href="#LOCALLY_COMPACT_UNIV-val">LOCALLY_COMPACT_UNIV</a> : thm
<a name="line1228"></a>    val <a href="#LOCALLY_DIFF_CLOSED-val">LOCALLY_DIFF_CLOSED</a> : thm
<a name="line1229"></a>    val <a href="#LOCALLY_EMPTY-val">LOCALLY_EMPTY</a> : thm
<a name="line1230"></a>    val <a href="#LOCALLY_INJECTIVE_LINEAR_IMAGE-val">LOCALLY_INJECTIVE_LINEAR_IMAGE</a> : thm
<a name="line1231"></a>    val <a href="#LOCALLY_INTER-val">LOCALLY_INTER</a> : thm
<a name="line1232"></a>    val <a href="#LOCALLY_MONO-val">LOCALLY_MONO</a> : thm
<a name="line1233"></a>    val <a href="#LOCALLY_OPEN_MAP_IMAGE-val">LOCALLY_OPEN_MAP_IMAGE</a> : thm
<a name="line1234"></a>    val <a href="#LOCALLY_OPEN_SUBSET-val">LOCALLY_OPEN_SUBSET</a> : thm
<a name="line1235"></a>    val <a href="#LOCALLY_SING-val">LOCALLY_SING</a> : thm
<a name="line1236"></a>    val <a href="#LOCALLY_TRANSLATION-val">LOCALLY_TRANSLATION</a> : thm
<a name="line1237"></a>    val <a href="#LOWER_HEMICONTINUOUS-val">LOWER_HEMICONTINUOUS</a> : thm
<a name="line1238"></a>    val <a href="#MAPPING_CONNECTED_ONTO_SEGMENT-val">MAPPING_CONNECTED_ONTO_SEGMENT</a> : thm
<a name="line1239"></a>    val <a href="#MAXIMAL_INDEPENDENT_SUBSET-val">MAXIMAL_INDEPENDENT_SUBSET</a> : thm
<a name="line1240"></a>    val <a href="#MAXIMAL_INDEPENDENT_SUBSET_EXTEND-val">MAXIMAL_INDEPENDENT_SUBSET_EXTEND</a> : thm
<a name="line1241"></a>    val <a href="#METRIZABLE_SPACE_EUCLIDEAN-val">METRIZABLE_SPACE_EUCLIDEAN</a> : thm
<a name="line1242"></a>    val <a href="#MIDPOINT_COLLINEAR-val">MIDPOINT_COLLINEAR</a> : thm
<a name="line1243"></a>    val <a href="#MIDPOINT_EQ_ENDPOINT-val">MIDPOINT_EQ_ENDPOINT</a> : thm
<a name="line1244"></a>    val <a href="#MIDPOINT_IN_SEGMENT-val">MIDPOINT_IN_SEGMENT</a> : thm
<a name="line1245"></a>    val <a href="#MIDPOINT_LINEAR_IMAGE-val">MIDPOINT_LINEAR_IMAGE</a> : thm
<a name="line1246"></a>    val <a href="#MIDPOINT_REFL-val">MIDPOINT_REFL</a> : thm
<a name="line1247"></a>    val <a href="#MIDPOINT_SYM-val">MIDPOINT_SYM</a> : thm
<a name="line1248"></a>    val <a href="#MONOTONE_BIGGER-val">MONOTONE_BIGGER</a> : thm
<a name="line1249"></a>    val <a href="#MONOTONE_SUBSEQUENCE-val">MONOTONE_SUBSEQUENCE</a> : thm
<a name="line1250"></a>    val <a href="#MUL_CAUCHY_SCHWARZ_EQUAL-val">MUL_CAUCHY_SCHWARZ_EQUAL</a> : thm
<a name="line1251"></a>    val <a href="#MUMFORD_LEMMA-val">MUMFORD_LEMMA</a> : thm
<a name="line1252"></a>    val <a href="#NEGATIONS_BALL-val">NEGATIONS_BALL</a> : thm
<a name="line1253"></a>    val <a href="#NEGATIONS_CBALL-val">NEGATIONS_CBALL</a> : thm
<a name="line1254"></a>    val <a href="#NEGATIONS_SPHERE-val">NEGATIONS_SPHERE</a> : thm
<a name="line1255"></a>    val <a href="#NET-val">NET</a> : thm
<a name="line1256"></a>    val <a href="#NETLIMIT_AT-val">NETLIMIT_AT</a> : thm
<a name="line1257"></a>    val <a href="#NETLIMIT_WITHIN-val">NETLIMIT_WITHIN</a> : thm
<a name="line1258"></a>    val <a href="#NETLIMIT_WITHIN_INTERIOR-val">NETLIMIT_WITHIN_INTERIOR</a> : thm
<a name="line1259"></a>    val <a href="#NET_DILEMMA-val">NET_DILEMMA</a> : thm
<a name="line1260"></a>    val <a href="#NONTRIVIAL_LIMIT_WITHIN-val">NONTRIVIAL_LIMIT_WITHIN</a> : thm
<a name="line1261"></a>    val <a href="#NOT_BOUNDED_UNIV-val">NOT_BOUNDED_UNIV</a> : thm
<a name="line1262"></a>    val <a href="#NOT_EVENTUALLY-val">NOT_EVENTUALLY</a> : thm
<a name="line1263"></a>    val <a href="#NOT_INTERVAL_UNIV-val">NOT_INTERVAL_UNIV</a> : thm
<a name="line1264"></a>    val <a href="#NOWHERE_DENSE-val">NOWHERE_DENSE</a> : thm
<a name="line1265"></a>    val <a href="#NOWHERE_DENSE_COUNTABLE_BIGUNION-val">NOWHERE_DENSE_COUNTABLE_BIGUNION</a> : thm
<a name="line1266"></a>    val <a href="#NOWHERE_DENSE_COUNTABLE_BIGUNION_CLOSED-val">NOWHERE_DENSE_COUNTABLE_BIGUNION_CLOSED</a> : thm
<a name="line1267"></a>    val <a href="#NOWHERE_DENSE_UNION-val">NOWHERE_DENSE_UNION</a> : thm
<a name="line1268"></a>    val <a href="#NO_LIMIT_POINT_IMP_CLOSED-val">NO_LIMIT_POINT_IMP_CLOSED</a> : thm
<a name="line1269"></a>    val <a href="#OLDNET-val">OLDNET</a> : thm
<a name="line1270"></a>    val <a href="#OPEN-val">OPEN</a> : thm
<a name="line1271"></a>    val <a href="#OPEN_AFFINITY-val">OPEN_AFFINITY</a> : thm
<a name="line1272"></a>    val <a href="#OPEN_BALL-val">OPEN_BALL</a> : thm
<a name="line1273"></a>    val <a href="#OPEN_BIGINTER-val">OPEN_BIGINTER</a> : thm
<a name="line1274"></a>    val <a href="#OPEN_BIGUNION-val">OPEN_BIGUNION</a> : thm
<a name="line1275"></a>    val <a href="#OPEN_BIJECTIVE_LINEAR_IMAGE_EQ-val">OPEN_BIJECTIVE_LINEAR_IMAGE_EQ</a> : thm
<a name="line1276"></a>    val <a href="#OPEN_CLOSED-val">OPEN_CLOSED</a> : thm
<a name="line1277"></a>    val <a href="#OPEN_CLOSED_INTERVAL-val">OPEN_CLOSED_INTERVAL</a> : thm
<a name="line1278"></a>    val <a href="#OPEN_CLOSED_INTERVAL_CONVEX-val">OPEN_CLOSED_INTERVAL_CONVEX</a> : thm
<a name="line1279"></a>    val <a href="#OPEN_CONTAINS_BALL-val">OPEN_CONTAINS_BALL</a> : thm
<a name="line1280"></a>    val <a href="#OPEN_CONTAINS_BALL_EQ-val">OPEN_CONTAINS_BALL_EQ</a> : thm
<a name="line1281"></a>    val <a href="#OPEN_CONTAINS_CBALL-val">OPEN_CONTAINS_CBALL</a> : thm
<a name="line1282"></a>    val <a href="#OPEN_CONTAINS_CBALL_EQ-val">OPEN_CONTAINS_CBALL_EQ</a> : thm
<a name="line1283"></a>    val <a href="#OPEN_CONTAINS_INTERVAL-val">OPEN_CONTAINS_INTERVAL</a> : thm
<a name="line1284"></a>    val <a href="#OPEN_CONTAINS_INTERVAL_OPEN_INTERVAL-val">OPEN_CONTAINS_INTERVAL_OPEN_INTERVAL</a> : thm
<a name="line1285"></a>    val <a href="#OPEN_CONTAINS_OPEN_INTERVAL-val">OPEN_CONTAINS_OPEN_INTERVAL</a> : thm
<a name="line1286"></a>    val <a href="#OPEN_DELETE-val">OPEN_DELETE</a> : thm
<a name="line1287"></a>    val <a href="#OPEN_DIFF-val">OPEN_DIFF</a> : thm
<a name="line1288"></a>    val <a href="#OPEN_EMPTY-val">OPEN_EMPTY</a> : thm
<a name="line1289"></a>    val <a href="#OPEN_EXISTS-val">OPEN_EXISTS</a> : thm
<a name="line1290"></a>    val <a href="#OPEN_EXISTS_IN-val">OPEN_EXISTS_IN</a> : thm
<a name="line1291"></a>    val <a href="#OPEN_HALFSPACE_COMPONENT_GT-val">OPEN_HALFSPACE_COMPONENT_GT</a> : thm
<a name="line1292"></a>    val <a href="#OPEN_HALFSPACE_COMPONENT_LT-val">OPEN_HALFSPACE_COMPONENT_LT</a> : thm
<a name="line1293"></a>    val <a href="#OPEN_HALFSPACE_GT-val">OPEN_HALFSPACE_GT</a> : thm
<a name="line1294"></a>    val <a href="#OPEN_HALFSPACE_LT-val">OPEN_HALFSPACE_LT</a> : thm
<a name="line1295"></a>    val <a href="#OPEN_IMP_INFINITE-val">OPEN_IMP_INFINITE</a> : thm
<a name="line1296"></a>    val <a href="#OPEN_IMP_LOCALLY_COMPACT-val">OPEN_IMP_LOCALLY_COMPACT</a> : thm
<a name="line1297"></a>    val <a href="#OPEN_IN-val">OPEN_IN</a> : thm
<a name="line1298"></a>    val <a href="#OPEN_INTER-val">OPEN_INTER</a> : thm
<a name="line1299"></a>    val <a href="#OPEN_INTERIOR-val">OPEN_INTERIOR</a> : thm
<a name="line1300"></a>    val <a href="#OPEN_INTERVAL-val">OPEN_INTERVAL</a> : thm
<a name="line1301"></a>    val <a href="#OPEN_INTERVAL_EQ-val">OPEN_INTERVAL_EQ</a> : thm
<a name="line1302"></a>    val <a href="#OPEN_INTERVAL_LEFT-val">OPEN_INTERVAL_LEFT</a> : thm
<a name="line1303"></a>    val <a href="#OPEN_INTERVAL_LEMMA-val">OPEN_INTERVAL_LEMMA</a> : thm
<a name="line1304"></a>    val <a href="#OPEN_INTERVAL_LOWERBOUND-val">OPEN_INTERVAL_LOWERBOUND</a> : thm
<a name="line1305"></a>    val <a href="#OPEN_INTERVAL_MIDPOINT-val">OPEN_INTERVAL_MIDPOINT</a> : thm
<a name="line1306"></a>    val <a href="#OPEN_INTERVAL_RIGHT-val">OPEN_INTERVAL_RIGHT</a> : thm
<a name="line1307"></a>    val <a href="#OPEN_INTERVAL_UPPERBOUND-val">OPEN_INTERVAL_UPPERBOUND</a> : thm
<a name="line1308"></a>    val <a href="#OPEN_INTER_CLOSURE_EQ_EMPTY-val">OPEN_INTER_CLOSURE_EQ_EMPTY</a> : thm
<a name="line1309"></a>    val <a href="#OPEN_INTER_CLOSURE_SUBSET-val">OPEN_INTER_CLOSURE_SUBSET</a> : thm
<a name="line1310"></a>    val <a href="#OPEN_IN_CONNECTED_COMPONENT-val">OPEN_IN_CONNECTED_COMPONENT</a> : thm
<a name="line1311"></a>    val <a href="#OPEN_IN_CONTAINS_BALL-val">OPEN_IN_CONTAINS_BALL</a> : thm
<a name="line1312"></a>    val <a href="#OPEN_IN_CONTAINS_CBALL-val">OPEN_IN_CONTAINS_CBALL</a> : thm
<a name="line1313"></a>    val <a href="#OPEN_IN_DELETE-val">OPEN_IN_DELETE</a> : thm
<a name="line1314"></a>    val <a href="#OPEN_IN_INTER_OPEN-val">OPEN_IN_INTER_OPEN</a> : thm
<a name="line1315"></a>    val <a href="#OPEN_IN_LOCALLY_COMPACT-val">OPEN_IN_LOCALLY_COMPACT</a> : thm
<a name="line1316"></a>    val <a href="#OPEN_IN_OPEN-val">OPEN_IN_OPEN</a> : thm
<a name="line1317"></a>    val <a href="#OPEN_IN_OPEN_EQ-val">OPEN_IN_OPEN_EQ</a> : thm
<a name="line1318"></a>    val <a href="#OPEN_IN_OPEN_INTER-val">OPEN_IN_OPEN_INTER</a> : thm
<a name="line1319"></a>    val <a href="#OPEN_IN_OPEN_TRANS-val">OPEN_IN_OPEN_TRANS</a> : thm
<a name="line1320"></a>    val <a href="#OPEN_IN_REFL-val">OPEN_IN_REFL</a> : thm
<a name="line1321"></a>    val <a href="#OPEN_IN_SING-val">OPEN_IN_SING</a> : thm
<a name="line1322"></a>    val <a href="#OPEN_IN_SUBSET_TRANS-val">OPEN_IN_SUBSET_TRANS</a> : thm
<a name="line1323"></a>    val <a href="#OPEN_IN_SUBTOPOLOGY_INTER_SUBSET-val">OPEN_IN_SUBTOPOLOGY_INTER_SUBSET</a> : thm
<a name="line1324"></a>    val <a href="#OPEN_IN_TRANS-val">OPEN_IN_TRANS</a> : thm
<a name="line1325"></a>    val <a href="#OPEN_IN_TRANS_EQ-val">OPEN_IN_TRANS_EQ</a> : thm
<a name="line1326"></a>    val <a href="#OPEN_MAP_CLOSED_SUPERSET_PREIMAGE-val">OPEN_MAP_CLOSED_SUPERSET_PREIMAGE</a> : thm
<a name="line1327"></a>    val <a href="#OPEN_MAP_CLOSED_SUPERSET_PREIMAGE_EQ-val">OPEN_MAP_CLOSED_SUPERSET_PREIMAGE_EQ</a> : thm
<a name="line1328"></a>    val <a href="#OPEN_MAP_FROM_COMPOSITION_INJECTIVE-val">OPEN_MAP_FROM_COMPOSITION_INJECTIVE</a> : thm
<a name="line1329"></a>    val <a href="#OPEN_MAP_FROM_COMPOSITION_SURJECTIVE-val">OPEN_MAP_FROM_COMPOSITION_SURJECTIVE</a> : thm
<a name="line1330"></a>    val <a href="#OPEN_MAP_IFF_LOWER_HEMICONTINUOUS_PREIMAGE-val">OPEN_MAP_IFF_LOWER_HEMICONTINUOUS_PREIMAGE</a> : thm
<a name="line1331"></a>    val <a href="#OPEN_MAP_IMP_CLOSED_MAP-val">OPEN_MAP_IMP_CLOSED_MAP</a> : thm
<a name="line1332"></a>    val <a href="#OPEN_MAP_IMP_QUOTIENT_MAP-val">OPEN_MAP_IMP_QUOTIENT_MAP</a> : thm
<a name="line1333"></a>    val <a href="#OPEN_MAP_INTERIORS-val">OPEN_MAP_INTERIORS</a> : thm
<a name="line1334"></a>    val <a href="#OPEN_MAP_RESTRICT-val">OPEN_MAP_RESTRICT</a> : thm
<a name="line1335"></a>    val <a href="#OPEN_NEGATIONS-val">OPEN_NEGATIONS</a> : thm
<a name="line1336"></a>    val <a href="#OPEN_OPEN_IN_TRANS-val">OPEN_OPEN_IN_TRANS</a> : thm
<a name="line1337"></a>    val <a href="#OPEN_POSITIVE_MULTIPLES-val">OPEN_POSITIVE_MULTIPLES</a> : thm
<a name="line1338"></a>    val <a href="#OPEN_POSITIVE_ORTHANT-val">OPEN_POSITIVE_ORTHANT</a> : thm
<a name="line1339"></a>    val <a href="#OPEN_SCALING-val">OPEN_SCALING</a> : thm
<a name="line1340"></a>    val <a href="#OPEN_SEGMENT-val">OPEN_SEGMENT</a> : thm
<a name="line1341"></a>    val <a href="#OPEN_SEGMENT_ALT-val">OPEN_SEGMENT_ALT</a> : thm
<a name="line1342"></a>    val <a href="#OPEN_SEGMENT_LINEAR_IMAGE-val">OPEN_SEGMENT_LINEAR_IMAGE</a> : thm
<a name="line1343"></a>    val <a href="#OPEN_SUBSET-val">OPEN_SUBSET</a> : thm
<a name="line1344"></a>    val <a href="#OPEN_SUBSET_INTERIOR-val">OPEN_SUBSET_INTERIOR</a> : thm
<a name="line1345"></a>    val <a href="#OPEN_SUB_OPEN-val">OPEN_SUB_OPEN</a> : thm
<a name="line1346"></a>    val <a href="#OPEN_SUMS-val">OPEN_SUMS</a> : thm
<a name="line1347"></a>    val <a href="#OPEN_SURJECTIVE_LINEAR_IMAGE-val">OPEN_SURJECTIVE_LINEAR_IMAGE</a> : thm
<a name="line1348"></a>    val <a href="#OPEN_TRANSLATION-val">OPEN_TRANSLATION</a> : thm
<a name="line1349"></a>    val <a href="#OPEN_TRANSLATION_EQ-val">OPEN_TRANSLATION_EQ</a> : thm
<a name="line1350"></a>    val <a href="#OPEN_UNION-val">OPEN_UNION</a> : thm
<a name="line1351"></a>    val <a href="#OPEN_UNION_COMPACT_SUBSETS-val">OPEN_UNION_COMPACT_SUBSETS</a> : thm
<a name="line1352"></a>    val <a href="#OPEN_UNIV-val">OPEN_UNIV</a> : thm
<a name="line1353"></a>    val <a href="#PAIRWISE_DISJOINT_COMPONENTS-val">PAIRWISE_DISJOINT_COMPONENTS</a> : thm
<a name="line1354"></a>    val <a href="#PARTIAL_SUMS_COMPONENT_LE_INFSUM-val">PARTIAL_SUMS_COMPONENT_LE_INFSUM</a> : thm
<a name="line1355"></a>    val <a href="#PARTIAL_SUMS_DROP_LE_INFSUM-val">PARTIAL_SUMS_DROP_LE_INFSUM</a> : thm
<a name="line1356"></a>    val <a href="#PASTING_LEMMA-val">PASTING_LEMMA</a> : thm
<a name="line1357"></a>    val <a href="#PASTING_LEMMA_CLOSED-val">PASTING_LEMMA_CLOSED</a> : thm
<a name="line1358"></a>    val <a href="#PASTING_LEMMA_EXISTS-val">PASTING_LEMMA_EXISTS</a> : thm
<a name="line1359"></a>    val <a href="#PASTING_LEMMA_EXISTS_CLOSED-val">PASTING_LEMMA_EXISTS_CLOSED</a> : thm
<a name="line1360"></a>    val <a href="#PROPER_MAP-val">PROPER_MAP</a> : thm
<a name="line1361"></a>    val <a href="#PROPER_MAP_COMPOSE-val">PROPER_MAP_COMPOSE</a> : thm
<a name="line1362"></a>    val <a href="#PROPER_MAP_FROM_COMPACT-val">PROPER_MAP_FROM_COMPACT</a> : thm
<a name="line1363"></a>    val <a href="#PROPER_MAP_FROM_COMPOSITION_LEFT-val">PROPER_MAP_FROM_COMPOSITION_LEFT</a> : thm
<a name="line1364"></a>    val <a href="#PROPER_MAP_FROM_COMPOSITION_RIGHT-val">PROPER_MAP_FROM_COMPOSITION_RIGHT</a> : thm
<a name="line1365"></a>    val <a href="#QUASICOMPACT_OPEN_CLOSED-val">QUASICOMPACT_OPEN_CLOSED</a> : thm
<a name="line1366"></a>    val <a href="#QUOTIENT_MAP_CLOSED_MAP_EQ-val">QUOTIENT_MAP_CLOSED_MAP_EQ</a> : thm
<a name="line1367"></a>    val <a href="#QUOTIENT_MAP_COMPOSE-val">QUOTIENT_MAP_COMPOSE</a> : thm
<a name="line1368"></a>    val <a href="#QUOTIENT_MAP_FROM_COMPOSITION-val">QUOTIENT_MAP_FROM_COMPOSITION</a> : thm
<a name="line1369"></a>    val <a href="#QUOTIENT_MAP_FROM_SUBSET-val">QUOTIENT_MAP_FROM_SUBSET</a> : thm
<a name="line1370"></a>    val <a href="#QUOTIENT_MAP_IMP_CONTINUOUS_CLOSED-val">QUOTIENT_MAP_IMP_CONTINUOUS_CLOSED</a> : thm
<a name="line1371"></a>    val <a href="#QUOTIENT_MAP_IMP_CONTINUOUS_OPEN-val">QUOTIENT_MAP_IMP_CONTINUOUS_OPEN</a> : thm
<a name="line1372"></a>    val <a href="#QUOTIENT_MAP_OPEN_CLOSED-val">QUOTIENT_MAP_OPEN_CLOSED</a> : thm
<a name="line1373"></a>    val <a href="#QUOTIENT_MAP_OPEN_MAP_EQ-val">QUOTIENT_MAP_OPEN_MAP_EQ</a> : thm
<a name="line1374"></a>    val <a href="#QUOTIENT_MAP_RESTRICT-val">QUOTIENT_MAP_RESTRICT</a> : thm
<a name="line1375"></a>    val <a href="#REAL_AFFINITY_EQ-val">REAL_AFFINITY_EQ</a> : thm
<a name="line1376"></a>    val <a href="#REAL_AFFINITY_LE-val">REAL_AFFINITY_LE</a> : thm
<a name="line1377"></a>    val <a href="#REAL_AFFINITY_LT-val">REAL_AFFINITY_LT</a> : thm
<a name="line1378"></a>    val <a href="#REAL_ARCH_RDIV_EQ_0-val">REAL_ARCH_RDIV_EQ_0</a> : thm
<a name="line1379"></a>    val <a href="#REAL_CHOOSE_DIST-val">REAL_CHOOSE_DIST</a> : thm
<a name="line1380"></a>    val <a href="#REAL_CHOOSE_SIZE-val">REAL_CHOOSE_SIZE</a> : thm
<a name="line1381"></a>    val <a href="#REAL_CONVEX_BOUND_LE-val">REAL_CONVEX_BOUND_LE</a> : thm
<a name="line1382"></a>    val <a href="#REAL_EQ_AFFINITY-val">REAL_EQ_AFFINITY</a> : thm
<a name="line1383"></a>    val <a href="#REAL_EQ_LINV-val">REAL_EQ_LINV</a> : thm
<a name="line1384"></a>    val <a href="#REAL_EQ_RINV-val">REAL_EQ_RINV</a> : thm
<a name="line1385"></a>    val <a href="#REAL_HAUSDIST_LE-val">REAL_HAUSDIST_LE</a> : thm
<a name="line1386"></a>    val <a href="#REAL_HAUSDIST_LE_EQ-val">REAL_HAUSDIST_LE_EQ</a> : thm
<a name="line1387"></a>    val <a href="#REAL_HAUSDIST_LE_SUMS-val">REAL_HAUSDIST_LE_SUMS</a> : thm
<a name="line1388"></a>    val <a href="#REAL_LE_AFFINITY-val">REAL_LE_AFFINITY</a> : thm
<a name="line1389"></a>    val <a href="#REAL_LE_HAUSDIST-val">REAL_LE_HAUSDIST</a> : thm
<a name="line1390"></a>    val <a href="#REAL_LE_SETDIST-val">REAL_LE_SETDIST</a> : thm
<a name="line1391"></a>    val <a href="#REAL_LE_SETDIST_EQ-val">REAL_LE_SETDIST_EQ</a> : thm
<a name="line1392"></a>    val <a href="#REAL_LT_AFFINITY-val">REAL_LT_AFFINITY</a> : thm
<a name="line1393"></a>    val <a href="#REAL_LT_HAUSDIST_POINT_EXISTS-val">REAL_LT_HAUSDIST_POINT_EXISTS</a> : thm
<a name="line1394"></a>    val <a href="#REAL_SETDIST_LT_EXISTS-val">REAL_SETDIST_LT_EXISTS</a> : thm
<a name="line1395"></a>    val <a href="#REFLECT_INTERVAL-val">REFLECT_INTERVAL</a> : thm
<a name="line1396"></a>    val <a href="#REGULAR_CLOSED_BIGUNION-val">REGULAR_CLOSED_BIGUNION</a> : thm
<a name="line1397"></a>    val <a href="#REGULAR_CLOSED_UNION-val">REGULAR_CLOSED_UNION</a> : thm
<a name="line1398"></a>    val <a href="#REGULAR_OPEN_INTER-val">REGULAR_OPEN_INTER</a> : thm
<a name="line1399"></a>    val <a href="#SEGMENT-val">SEGMENT</a> : thm
<a name="line1400"></a>    val <a href="#SEGMENT_CLOSED_OPEN-val">SEGMENT_CLOSED_OPEN</a> : thm
<a name="line1401"></a>    val <a href="#SEGMENT_OPEN_SUBSET_CLOSED-val">SEGMENT_OPEN_SUBSET_CLOSED</a> : thm
<a name="line1402"></a>    val <a href="#SEGMENT_REFL-val">SEGMENT_REFL</a> : thm
<a name="line1403"></a>    val <a href="#SEGMENT_SCALAR_MULTIPLE-val">SEGMENT_SCALAR_MULTIPLE</a> : thm
<a name="line1404"></a>    val <a href="#SEGMENT_SYM-val">SEGMENT_SYM</a> : thm
<a name="line1405"></a>    val <a href="#SEGMENT_TO_CLOSEST_POINT-val">SEGMENT_TO_CLOSEST_POINT</a> : thm
<a name="line1406"></a>    val <a href="#SEGMENT_TO_POINT_EXISTS-val">SEGMENT_TO_POINT_EXISTS</a> : thm
<a name="line1407"></a>    val <a href="#SEGMENT_TRANSLATION-val">SEGMENT_TRANSLATION</a> : thm
<a name="line1408"></a>    val <a href="#SEPARATE_CLOSED_COMPACT-val">SEPARATE_CLOSED_COMPACT</a> : thm
<a name="line1409"></a>    val <a href="#SEPARATE_COMPACT_CLOSED-val">SEPARATE_COMPACT_CLOSED</a> : thm
<a name="line1410"></a>    val <a href="#SEPARATE_POINT_CLOSED-val">SEPARATE_POINT_CLOSED</a> : thm
<a name="line1411"></a>    val <a href="#SEPARATION_CLOSURES-val">SEPARATION_CLOSURES</a> : thm
<a name="line1412"></a>    val <a href="#SEPARATION_HAUSDORFF-val">SEPARATION_HAUSDORFF</a> : thm
<a name="line1413"></a>    val <a href="#SEPARATION_NORMAL-val">SEPARATION_NORMAL</a> : thm
<a name="line1414"></a>    val <a href="#SEPARATION_NORMAL_COMPACT-val">SEPARATION_NORMAL_COMPACT</a> : thm
<a name="line1415"></a>    val <a href="#SEPARATION_NORMAL_LOCAL-val">SEPARATION_NORMAL_LOCAL</a> : thm
<a name="line1416"></a>    val <a href="#SEPARATION_T0-val">SEPARATION_T0</a> : thm
<a name="line1417"></a>    val <a href="#SEPARATION_T1-val">SEPARATION_T1</a> : thm
<a name="line1418"></a>    val <a href="#SEPARATION_T2-val">SEPARATION_T2</a> : thm
<a name="line1419"></a>    val <a href="#SEQUENCE_CAUCHY_WLOG-val">SEQUENCE_CAUCHY_WLOG</a> : thm
<a name="line1420"></a>    val <a href="#SEQUENCE_INFINITE_LEMMA-val">SEQUENCE_INFINITE_LEMMA</a> : thm
<a name="line1421"></a>    val <a href="#SEQUENCE_UNIQUE_LIMPT-val">SEQUENCE_UNIQUE_LIMPT</a> : thm
<a name="line1422"></a>    val <a href="#SEQUENTIALLY-val">SEQUENTIALLY</a> : thm
<a name="line1423"></a>    val <a href="#SEQ_HARMONIC-val">SEQ_HARMONIC</a> : thm
<a name="line1424"></a>    val <a href="#SEQ_HARMONIC_OFFSET-val">SEQ_HARMONIC_OFFSET</a> : thm
<a name="line1425"></a>    val <a href="#SEQ_OFFSET-val">SEQ_OFFSET</a> : thm
<a name="line1426"></a>    val <a href="#SEQ_OFFSET_NEG-val">SEQ_OFFSET_NEG</a> : thm
<a name="line1427"></a>    val <a href="#SEQ_OFFSET_REV-val">SEQ_OFFSET_REV</a> : thm
<a name="line1428"></a>    val <a href="#SERIES_0-val">SERIES_0</a> : thm
<a name="line1429"></a>    val <a href="#SERIES_ABSCONV_IMP_CONV-val">SERIES_ABSCONV_IMP_CONV</a> : thm
<a name="line1430"></a>    val <a href="#SERIES_ADD-val">SERIES_ADD</a> : thm
<a name="line1431"></a>    val <a href="#SERIES_BOUND-val">SERIES_BOUND</a> : thm
<a name="line1432"></a>    val <a href="#SERIES_CAUCHY-val">SERIES_CAUCHY</a> : thm
<a name="line1433"></a>    val <a href="#SERIES_CAUCHY_UNIFORM-val">SERIES_CAUCHY_UNIFORM</a> : thm
<a name="line1434"></a>    val <a href="#SERIES_CMUL-val">SERIES_CMUL</a> : thm
<a name="line1435"></a>    val <a href="#SERIES_COMPARISON-val">SERIES_COMPARISON</a> : thm
<a name="line1436"></a>    val <a href="#SERIES_COMPARISON_BOUND-val">SERIES_COMPARISON_BOUND</a> : thm
<a name="line1437"></a>    val <a href="#SERIES_COMPARISON_UNIFORM-val">SERIES_COMPARISON_UNIFORM</a> : thm
<a name="line1438"></a>    val <a href="#SERIES_COMPONENT-val">SERIES_COMPONENT</a> : thm
<a name="line1439"></a>    val <a href="#SERIES_DIFFS-val">SERIES_DIFFS</a> : thm
<a name="line1440"></a>    val <a href="#SERIES_DIRICHLET-val">SERIES_DIRICHLET</a> : thm
<a name="line1441"></a>    val <a href="#SERIES_DIRICHLET_BILINEAR-val">SERIES_DIRICHLET_BILINEAR</a> : thm
<a name="line1442"></a>    val <a href="#SERIES_DROP_LE-val">SERIES_DROP_LE</a> : thm
<a name="line1443"></a>    val <a href="#SERIES_DROP_POS-val">SERIES_DROP_POS</a> : thm
<a name="line1444"></a>    val <a href="#SERIES_FINITE-val">SERIES_FINITE</a> : thm
<a name="line1445"></a>    val <a href="#SERIES_FINITE_SUPPORT-val">SERIES_FINITE_SUPPORT</a> : thm
<a name="line1446"></a>    val <a href="#SERIES_FROM-val">SERIES_FROM</a> : thm
<a name="line1447"></a>    val <a href="#SERIES_GOESTOZERO-val">SERIES_GOESTOZERO</a> : thm
<a name="line1448"></a>    val <a href="#SERIES_INJECTIVE_IMAGE-val">SERIES_INJECTIVE_IMAGE</a> : thm
<a name="line1449"></a>    val <a href="#SERIES_INJECTIVE_IMAGE_STRONG-val">SERIES_INJECTIVE_IMAGE_STRONG</a> : thm
<a name="line1450"></a>    val <a href="#SERIES_LINEAR-val">SERIES_LINEAR</a> : thm
<a name="line1451"></a>    val <a href="#SERIES_NEG-val">SERIES_NEG</a> : thm
<a name="line1452"></a>    val <a href="#SERIES_RATIO-val">SERIES_RATIO</a> : thm
<a name="line1453"></a>    val <a href="#SERIES_REARRANGE-val">SERIES_REARRANGE</a> : thm
<a name="line1454"></a>    val <a href="#SERIES_REARRANGE_EQ-val">SERIES_REARRANGE_EQ</a> : thm
<a name="line1455"></a>    val <a href="#SERIES_RESTRICT-val">SERIES_RESTRICT</a> : thm
<a name="line1456"></a>    val <a href="#SERIES_SUB-val">SERIES_SUB</a> : thm
<a name="line1457"></a>    val <a href="#SERIES_SUBSET-val">SERIES_SUBSET</a> : thm
<a name="line1458"></a>    val <a href="#SERIES_SUM-val">SERIES_SUM</a> : thm
<a name="line1459"></a>    val <a href="#SERIES_TERMS_TOZERO-val">SERIES_TERMS_TOZERO</a> : thm
<a name="line1460"></a>    val <a href="#SERIES_TRIVIAL-val">SERIES_TRIVIAL</a> : thm
<a name="line1461"></a>    val <a href="#SERIES_UNIQUE-val">SERIES_UNIQUE</a> : thm
<a name="line1462"></a>    val <a href="#SETDIST_BALLS-val">SETDIST_BALLS</a> : thm
<a name="line1463"></a>    val <a href="#SETDIST_CLOSED_COMPACT-val">SETDIST_CLOSED_COMPACT</a> : thm
<a name="line1464"></a>    val <a href="#SETDIST_CLOSEST_POINT-val">SETDIST_CLOSEST_POINT</a> : thm
<a name="line1465"></a>    val <a href="#SETDIST_CLOSURE-val">SETDIST_CLOSURE</a> : thm
<a name="line1466"></a>    val <a href="#SETDIST_COMPACT_CLOSED-val">SETDIST_COMPACT_CLOSED</a> : thm
<a name="line1467"></a>    val <a href="#SETDIST_DIFFERENCES-val">SETDIST_DIFFERENCES</a> : thm
<a name="line1468"></a>    val <a href="#SETDIST_EMPTY-val">SETDIST_EMPTY</a> : thm
<a name="line1469"></a>    val <a href="#SETDIST_EQ_0_BOUNDED-val">SETDIST_EQ_0_BOUNDED</a> : thm
<a name="line1470"></a>    val <a href="#SETDIST_EQ_0_CLOSED-val">SETDIST_EQ_0_CLOSED</a> : thm
<a name="line1471"></a>    val <a href="#SETDIST_EQ_0_CLOSED_COMPACT-val">SETDIST_EQ_0_CLOSED_COMPACT</a> : thm
<a name="line1472"></a>    val <a href="#SETDIST_EQ_0_CLOSED_IN-val">SETDIST_EQ_0_CLOSED_IN</a> : thm
<a name="line1473"></a>    val <a href="#SETDIST_EQ_0_COMPACT_CLOSED-val">SETDIST_EQ_0_COMPACT_CLOSED</a> : thm
<a name="line1474"></a>    val <a href="#SETDIST_EQ_0_SING-val">SETDIST_EQ_0_SING</a> : thm
<a name="line1475"></a>    val <a href="#SETDIST_FRONTIER-val">SETDIST_FRONTIER</a> : thm
<a name="line1476"></a>    val <a href="#SETDIST_FRONTIERS-val">SETDIST_FRONTIERS</a> : thm
<a name="line1477"></a>    val <a href="#SETDIST_HAUSDIST_TRIANGLE-val">SETDIST_HAUSDIST_TRIANGLE</a> : thm
<a name="line1478"></a>    val <a href="#SETDIST_LE_DIST-val">SETDIST_LE_DIST</a> : thm
<a name="line1479"></a>    val <a href="#SETDIST_LE_HAUSDIST-val">SETDIST_LE_HAUSDIST</a> : thm
<a name="line1480"></a>    val <a href="#SETDIST_LE_SING-val">SETDIST_LE_SING</a> : thm
<a name="line1481"></a>    val <a href="#SETDIST_LINEAR_IMAGE-val">SETDIST_LINEAR_IMAGE</a> : thm
<a name="line1482"></a>    val <a href="#SETDIST_LIPSCHITZ-val">SETDIST_LIPSCHITZ</a> : thm
<a name="line1483"></a>    val <a href="#SETDIST_POS_LE-val">SETDIST_POS_LE</a> : thm
<a name="line1484"></a>    val <a href="#SETDIST_REFL-val">SETDIST_REFL</a> : thm
<a name="line1485"></a>    val <a href="#SETDIST_SINGS-val">SETDIST_SINGS</a> : thm
<a name="line1486"></a>    val <a href="#SETDIST_SING_FRONTIER-val">SETDIST_SING_FRONTIER</a> : thm
<a name="line1487"></a>    val <a href="#SETDIST_SING_FRONTIER_CASES-val">SETDIST_SING_FRONTIER_CASES</a> : thm
<a name="line1488"></a>    val <a href="#SETDIST_SING_IN_SET-val">SETDIST_SING_IN_SET</a> : thm
<a name="line1489"></a>    val <a href="#SETDIST_SING_LE_HAUSDIST-val">SETDIST_SING_LE_HAUSDIST</a> : thm
<a name="line1490"></a>    val <a href="#SETDIST_SING_TRIANGLE-val">SETDIST_SING_TRIANGLE</a> : thm
<a name="line1491"></a>    val <a href="#SETDIST_SUBSETS_EQ-val">SETDIST_SUBSETS_EQ</a> : thm
<a name="line1492"></a>    val <a href="#SETDIST_SUBSET_LEFT-val">SETDIST_SUBSET_LEFT</a> : thm
<a name="line1493"></a>    val <a href="#SETDIST_SUBSET_RIGHT-val">SETDIST_SUBSET_RIGHT</a> : thm
<a name="line1494"></a>    val <a href="#SETDIST_SYM-val">SETDIST_SYM</a> : thm
<a name="line1495"></a>    val <a href="#SETDIST_TRANSLATION-val">SETDIST_TRANSLATION</a> : thm
<a name="line1496"></a>    val <a href="#SETDIST_TRIANGLE-val">SETDIST_TRIANGLE</a> : thm
<a name="line1497"></a>    val <a href="#SETDIST_UNIQUE-val">SETDIST_UNIQUE</a> : thm
<a name="line1498"></a>    val <a href="#SETDIST_UNIV-val">SETDIST_UNIV</a> : thm
<a name="line1499"></a>    val <a href="#SETDIST_ZERO-val">SETDIST_ZERO</a> : thm
<a name="line1500"></a>    val <a href="#SETDIST_ZERO_STRONG-val">SETDIST_ZERO_STRONG</a> : thm
<a name="line1501"></a>    val <a href="#SET_DIFF_FRONTIER-val">SET_DIFF_FRONTIER</a> : thm
<a name="line1502"></a>    val <a href="#SPANNING_SUBSET_INDEPENDENT-val">SPANNING_SUBSET_INDEPENDENT</a> : thm
<a name="line1503"></a>    val <a href="#SPAN_0-val">SPAN_0</a> : thm
<a name="line1504"></a>    val <a href="#SPAN_ADD-val">SPAN_ADD</a> : thm
<a name="line1505"></a>    val <a href="#SPAN_ADD_EQ-val">SPAN_ADD_EQ</a> : thm
<a name="line1506"></a>    val <a href="#SPAN_BREAKDOWN-val">SPAN_BREAKDOWN</a> : thm
<a name="line1507"></a>    val <a href="#SPAN_BREAKDOWN_EQ-val">SPAN_BREAKDOWN_EQ</a> : thm
<a name="line1508"></a>    val <a href="#SPAN_CARD_GE_DIM-val">SPAN_CARD_GE_DIM</a> : thm
<a name="line1509"></a>    val <a href="#SPAN_CLAUSES-val">SPAN_CLAUSES</a> : thm
<a name="line1510"></a>    val <a href="#SPAN_EMPTY-val">SPAN_EMPTY</a> : thm
<a name="line1511"></a>    val <a href="#SPAN_EQ_SELF-val">SPAN_EQ_SELF</a> : thm
<a name="line1512"></a>    val <a href="#SPAN_EXPLICIT-val">SPAN_EXPLICIT</a> : thm
<a name="line1513"></a>    val <a href="#SPAN_INC-val">SPAN_INC</a> : thm
<a name="line1514"></a>    val <a href="#SPAN_INDUCT-val">SPAN_INDUCT</a> : thm
<a name="line1515"></a>    val <a href="#SPAN_INDUCT_ALT-val">SPAN_INDUCT_ALT</a> : thm
<a name="line1516"></a>    val <a href="#SPAN_LINEAR_IMAGE-val">SPAN_LINEAR_IMAGE</a> : thm
<a name="line1517"></a>    val <a href="#SPAN_MONO-val">SPAN_MONO</a> : thm
<a name="line1518"></a>    val <a href="#SPAN_MUL-val">SPAN_MUL</a> : thm
<a name="line1519"></a>    val <a href="#SPAN_MUL_EQ-val">SPAN_MUL_EQ</a> : thm
<a name="line1520"></a>    val <a href="#SPAN_NEG-val">SPAN_NEG</a> : thm
<a name="line1521"></a>    val <a href="#SPAN_NEG_EQ-val">SPAN_NEG_EQ</a> : thm
<a name="line1522"></a>    val <a href="#SPAN_SPAN-val">SPAN_SPAN</a> : thm
<a name="line1523"></a>    val <a href="#SPAN_STDBASIS-val">SPAN_STDBASIS</a> : thm
<a name="line1524"></a>    val <a href="#SPAN_SUB-val">SPAN_SUB</a> : thm
<a name="line1525"></a>    val <a href="#SPAN_SUBSET_SUBSPACE-val">SPAN_SUBSET_SUBSPACE</a> : thm
<a name="line1526"></a>    val <a href="#SPAN_SUBSPACE-val">SPAN_SUBSPACE</a> : thm
<a name="line1527"></a>    val <a href="#SPAN_SUM-val">SPAN_SUM</a> : thm
<a name="line1528"></a>    val <a href="#SPAN_SUPERSET-val">SPAN_SUPERSET</a> : thm
<a name="line1529"></a>    val <a href="#SPAN_TRANS-val">SPAN_TRANS</a> : thm
<a name="line1530"></a>    val <a href="#SPAN_UNION-val">SPAN_UNION</a> : thm
<a name="line1531"></a>    val <a href="#SPAN_UNION_SUBSET-val">SPAN_UNION_SUBSET</a> : thm
<a name="line1532"></a>    val <a href="#SPAN_UNIV-val">SPAN_UNIV</a> : thm
<a name="line1533"></a>    val <a href="#SPHERE-val">SPHERE</a> : thm
<a name="line1534"></a>    val <a href="#SPHERE_EMPTY-val">SPHERE_EMPTY</a> : thm
<a name="line1535"></a>    val <a href="#SPHERE_EQ_EMPTY-val">SPHERE_EQ_EMPTY</a> : thm
<a name="line1536"></a>    val <a href="#SPHERE_EQ_SING-val">SPHERE_EQ_SING</a> : thm
<a name="line1537"></a>    val <a href="#SPHERE_LINEAR_IMAGE-val">SPHERE_LINEAR_IMAGE</a> : thm
<a name="line1538"></a>    val <a href="#SPHERE_SING-val">SPHERE_SING</a> : thm
<a name="line1539"></a>    val <a href="#SPHERE_SUBSET_CBALL-val">SPHERE_SUBSET_CBALL</a> : thm
<a name="line1540"></a>    val <a href="#SPHERE_TRANSLATION-val">SPHERE_TRANSLATION</a> : thm
<a name="line1541"></a>    val <a href="#SPHERE_UNION_BALL-val">SPHERE_UNION_BALL</a> : thm
<a name="line1542"></a>    val <a href="#SUBORDINATE_PARTITION_OF_UNITY-val">SUBORDINATE_PARTITION_OF_UNITY</a> : thm
<a name="line1543"></a>    val <a href="#SUBSET_BALL-val">SUBSET_BALL</a> : thm
<a name="line1544"></a>    val <a href="#SUBSET_BALLS-val">SUBSET_BALLS</a> : thm
<a name="line1545"></a>    val <a href="#SUBSET_CBALL-val">SUBSET_CBALL</a> : thm
<a name="line1546"></a>    val <a href="#SUBSET_CLOSURE-val">SUBSET_CLOSURE</a> : thm
<a name="line1547"></a>    val <a href="#SUBSET_INTERIOR-val">SUBSET_INTERIOR</a> : thm
<a name="line1548"></a>    val <a href="#SUBSET_INTERIOR_EQ-val">SUBSET_INTERIOR_EQ</a> : thm
<a name="line1549"></a>    val <a href="#SUBSET_INTERVAL-val">SUBSET_INTERVAL</a> : thm
<a name="line1550"></a>    val <a href="#SUBSET_INTERVAL_IMP-val">SUBSET_INTERVAL_IMP</a> : thm
<a name="line1551"></a>    val <a href="#SUBSPACE_0-val">SUBSPACE_0</a> : thm
<a name="line1552"></a>    val <a href="#SUBSPACE_ADD-val">SUBSPACE_ADD</a> : thm
<a name="line1553"></a>    val <a href="#SUBSPACE_BIGINTER-val">SUBSPACE_BIGINTER</a> : thm
<a name="line1554"></a>    val <a href="#SUBSPACE_BOUNDED_EQ_TRIVIAL-val">SUBSPACE_BOUNDED_EQ_TRIVIAL</a> : thm
<a name="line1555"></a>    val <a href="#SUBSPACE_IMP_NONEMPTY-val">SUBSPACE_IMP_NONEMPTY</a> : thm
<a name="line1556"></a>    val <a href="#SUBSPACE_INTER-val">SUBSPACE_INTER</a> : thm
<a name="line1557"></a>    val <a href="#SUBSPACE_KERNEL-val">SUBSPACE_KERNEL</a> : thm
<a name="line1558"></a>    val <a href="#SUBSPACE_LINEAR_IMAGE-val">SUBSPACE_LINEAR_IMAGE</a> : thm
<a name="line1559"></a>    val <a href="#SUBSPACE_LINEAR_PREIMAGE-val">SUBSPACE_LINEAR_PREIMAGE</a> : thm
<a name="line1560"></a>    val <a href="#SUBSPACE_MUL-val">SUBSPACE_MUL</a> : thm
<a name="line1561"></a>    val <a href="#SUBSPACE_NEG-val">SUBSPACE_NEG</a> : thm
<a name="line1562"></a>    val <a href="#SUBSPACE_SPAN-val">SUBSPACE_SPAN</a> : thm
<a name="line1563"></a>    val <a href="#SUBSPACE_SUB-val">SUBSPACE_SUB</a> : thm
<a name="line1564"></a>    val <a href="#SUBSPACE_SUBSTANDARD-val">SUBSPACE_SUBSTANDARD</a> : thm
<a name="line1565"></a>    val <a href="#SUBSPACE_SUM-val">SUBSPACE_SUM</a> : thm
<a name="line1566"></a>    val <a href="#SUBSPACE_SUMS-val">SUBSPACE_SUMS</a> : thm
<a name="line1567"></a>    val <a href="#SUBSPACE_TRANSLATION_SELF-val">SUBSPACE_TRANSLATION_SELF</a> : thm
<a name="line1568"></a>    val <a href="#SUBSPACE_TRANSLATION_SELF_EQ-val">SUBSPACE_TRANSLATION_SELF_EQ</a> : thm
<a name="line1569"></a>    val <a href="#SUBSPACE_TRIVIAL-val">SUBSPACE_TRIVIAL</a> : thm
<a name="line1570"></a>    val <a href="#SUBSPACE_UNION_CHAIN-val">SUBSPACE_UNION_CHAIN</a> : thm
<a name="line1571"></a>    val <a href="#SUBSPACE_UNIV-val">SUBSPACE_UNIV</a> : thm
<a name="line1572"></a>    val <a href="#SUMMABLE_0-val">SUMMABLE_0</a> : thm
<a name="line1573"></a>    val <a href="#SUMMABLE_ADD-val">SUMMABLE_ADD</a> : thm
<a name="line1574"></a>    val <a href="#SUMMABLE_BILINEAR_PARTIAL_PRE-val">SUMMABLE_BILINEAR_PARTIAL_PRE</a> : thm
<a name="line1575"></a>    val <a href="#SUMMABLE_CAUCHY-val">SUMMABLE_CAUCHY</a> : thm
<a name="line1576"></a>    val <a href="#SUMMABLE_CMUL-val">SUMMABLE_CMUL</a> : thm
<a name="line1577"></a>    val <a href="#SUMMABLE_COMPARISON-val">SUMMABLE_COMPARISON</a> : thm
<a name="line1578"></a>    val <a href="#SUMMABLE_COMPONENT-val">SUMMABLE_COMPONENT</a> : thm
<a name="line1579"></a>    val <a href="#SUMMABLE_EQ-val">SUMMABLE_EQ</a> : thm
<a name="line1580"></a>    val <a href="#SUMMABLE_EQ_COFINITE-val">SUMMABLE_EQ_COFINITE</a> : thm
<a name="line1581"></a>    val <a href="#SUMMABLE_EQ_EVENTUALLY-val">SUMMABLE_EQ_EVENTUALLY</a> : thm
<a name="line1582"></a>    val <a href="#SUMMABLE_FROM_ELSEWHERE-val">SUMMABLE_FROM_ELSEWHERE</a> : thm
<a name="line1583"></a>    val <a href="#SUMMABLE_IFF-val">SUMMABLE_IFF</a> : thm
<a name="line1584"></a>    val <a href="#SUMMABLE_IFF_COFINITE-val">SUMMABLE_IFF_COFINITE</a> : thm
<a name="line1585"></a>    val <a href="#SUMMABLE_IFF_EVENTUALLY-val">SUMMABLE_IFF_EVENTUALLY</a> : thm
<a name="line1586"></a>    val <a href="#SUMMABLE_IMP_BOUNDED-val">SUMMABLE_IMP_BOUNDED</a> : thm
<a name="line1587"></a>    val <a href="#SUMMABLE_IMP_SUMS_BOUNDED-val">SUMMABLE_IMP_SUMS_BOUNDED</a> : thm
<a name="line1588"></a>    val <a href="#SUMMABLE_IMP_TOZERO-val">SUMMABLE_IMP_TOZERO</a> : thm
<a name="line1589"></a>    val <a href="#SUMMABLE_LINEAR-val">SUMMABLE_LINEAR</a> : thm
<a name="line1590"></a>    val <a href="#SUMMABLE_NEG-val">SUMMABLE_NEG</a> : thm
<a name="line1591"></a>    val <a href="#SUMMABLE_REARRANGE-val">SUMMABLE_REARRANGE</a> : thm
<a name="line1592"></a>    val <a href="#SUMMABLE_REINDEX-val">SUMMABLE_REINDEX</a> : thm
<a name="line1593"></a>    val <a href="#SUMMABLE_RESTRICT-val">SUMMABLE_RESTRICT</a> : thm
<a name="line1594"></a>    val <a href="#SUMMABLE_SUB-val">SUMMABLE_SUB</a> : thm
<a name="line1595"></a>    val <a href="#SUMMABLE_SUBSET-val">SUMMABLE_SUBSET</a> : thm
<a name="line1596"></a>    val <a href="#SUMMABLE_SUBSET_ABSCONV-val">SUMMABLE_SUBSET_ABSCONV</a> : thm
<a name="line1597"></a>    val <a href="#SUMMABLE_TRIVIAL-val">SUMMABLE_TRIVIAL</a> : thm
<a name="line1598"></a>    val <a href="#SUMS_0-val">SUMS_0</a> : thm
<a name="line1599"></a>    val <a href="#SUMS_EQ-val">SUMS_EQ</a> : thm
<a name="line1600"></a>    val <a href="#SUMS_FINITE_DIFF-val">SUMS_FINITE_DIFF</a> : thm
<a name="line1601"></a>    val <a href="#SUMS_FINITE_UNION-val">SUMS_FINITE_UNION</a> : thm
<a name="line1602"></a>    val <a href="#SUMS_IFF-val">SUMS_IFF</a> : thm
<a name="line1603"></a>    val <a href="#SUMS_INFSUM-val">SUMS_INFSUM</a> : thm
<a name="line1604"></a>    val <a href="#SUMS_INTERVALS-val">SUMS_INTERVALS</a> : thm
<a name="line1605"></a>    val <a href="#SUMS_LIM-val">SUMS_LIM</a> : thm
<a name="line1606"></a>    val <a href="#SUMS_OFFSET-val">SUMS_OFFSET</a> : thm
<a name="line1607"></a>    val <a href="#SUMS_OFFSET_REV-val">SUMS_OFFSET_REV</a> : thm
<a name="line1608"></a>    val <a href="#SUMS_REINDEX-val">SUMS_REINDEX</a> : thm
<a name="line1609"></a>    val <a href="#SUMS_REINDEX_GEN-val">SUMS_REINDEX_GEN</a> : thm
<a name="line1610"></a>    val <a href="#SUMS_SUMMABLE-val">SUMS_SUMMABLE</a> : thm
<a name="line1611"></a>    val <a href="#SUM_DIFF_LEMMA-val">SUM_DIFF_LEMMA</a> : thm
<a name="line1612"></a>    val <a href="#SUP_INSERT-val">SUP_INSERT</a> : thm
<a name="line1613"></a>    val <a href="#SURJECTIVE_IMAGE_EQ-val">SURJECTIVE_IMAGE_EQ</a> : thm
<a name="line1614"></a>    val <a href="#SYMMETRIC_CLOSURE-val">SYMMETRIC_CLOSURE</a> : thm
<a name="line1615"></a>    val <a href="#SYMMETRIC_INTERIOR-val">SYMMETRIC_INTERIOR</a> : thm
<a name="line1616"></a>    val <a href="#SYMMETRIC_LINEAR_IMAGE-val">SYMMETRIC_LINEAR_IMAGE</a> : thm
<a name="line1617"></a>    val <a href="#TENDSTO_LIM-val">TENDSTO_LIM</a> : thm
<a name="line1618"></a>    val <a href="#TOPSPACE_EUCLIDEAN-val">TOPSPACE_EUCLIDEAN</a> : thm
<a name="line1619"></a>    val <a href="#TOPSPACE_EUCLIDEAN_SUBTOPOLOGY-val">TOPSPACE_EUCLIDEAN_SUBTOPOLOGY</a> : thm
<a name="line1620"></a>    val <a href="#TRANSITIVE_STEPWISE_LT-val">TRANSITIVE_STEPWISE_LT</a> : thm
<a name="line1621"></a>    val <a href="#TRANSITIVE_STEPWISE_LT_EQ-val">TRANSITIVE_STEPWISE_LT_EQ</a> : thm
<a name="line1622"></a>    val <a href="#TRANSLATION_DIFF-val">TRANSLATION_DIFF</a> : thm
<a name="line1623"></a>    val <a href="#TRIVIAL_LIMIT_AT-val">TRIVIAL_LIMIT_AT</a> : thm
<a name="line1624"></a>    val <a href="#TRIVIAL_LIMIT_AT_INFINITY-val">TRIVIAL_LIMIT_AT_INFINITY</a> : thm
<a name="line1625"></a>    val <a href="#TRIVIAL_LIMIT_AT_NEGINFINITY-val">TRIVIAL_LIMIT_AT_NEGINFINITY</a> : thm
<a name="line1626"></a>    val <a href="#TRIVIAL_LIMIT_AT_POSINFINITY-val">TRIVIAL_LIMIT_AT_POSINFINITY</a> : thm
<a name="line1627"></a>    val <a href="#TRIVIAL_LIMIT_SEQUENTIALLY-val">TRIVIAL_LIMIT_SEQUENTIALLY</a> : thm
<a name="line1628"></a>    val <a href="#TRIVIAL_LIMIT_WITHIN-val">TRIVIAL_LIMIT_WITHIN</a> : thm
<a name="line1629"></a>    val <a href="#UNBOUNDED_HALFSPACE_COMPONENT_GE-val">UNBOUNDED_HALFSPACE_COMPONENT_GE</a> : thm
<a name="line1630"></a>    val <a href="#UNBOUNDED_HALFSPACE_COMPONENT_GT-val">UNBOUNDED_HALFSPACE_COMPONENT_GT</a> : thm
<a name="line1631"></a>    val <a href="#UNBOUNDED_HALFSPACE_COMPONENT_LE-val">UNBOUNDED_HALFSPACE_COMPONENT_LE</a> : thm
<a name="line1632"></a>    val <a href="#UNBOUNDED_HALFSPACE_COMPONENT_LT-val">UNBOUNDED_HALFSPACE_COMPONENT_LT</a> : thm
<a name="line1633"></a>    val <a href="#UNBOUNDED_INTER_COBOUNDED-val">UNBOUNDED_INTER_COBOUNDED</a> : thm
<a name="line1634"></a>    val <a href="#UNCOUNTABLE_EUCLIDEAN-val">UNCOUNTABLE_EUCLIDEAN</a> : thm
<a name="line1635"></a>    val <a href="#UNCOUNTABLE_INTERVAL-val">UNCOUNTABLE_INTERVAL</a> : thm
<a name="line1636"></a>    val <a href="#UNCOUNTABLE_OPEN-val">UNCOUNTABLE_OPEN</a> : thm
<a name="line1637"></a>    val <a href="#UNCOUNTABLE_REAL-val">UNCOUNTABLE_REAL</a> : thm
<a name="line1638"></a>    val <a href="#UNIFORMLY_CAUCHY_IMP_UNIFORMLY_CONVERGENT-val">UNIFORMLY_CAUCHY_IMP_UNIFORMLY_CONVERGENT</a> : thm
<a name="line1639"></a>    val <a href="#UNIFORMLY_CONTINUOUS_EXTENDS_TO_CLOSURE-val">UNIFORMLY_CONTINUOUS_EXTENDS_TO_CLOSURE</a> : thm
<a name="line1640"></a>    val <a href="#UNIFORMLY_CONTINUOUS_IMP_CAUCHY_CONTINUOUS-val">UNIFORMLY_CONTINUOUS_IMP_CAUCHY_CONTINUOUS</a> : thm
<a name="line1641"></a>    val <a href="#UNIFORMLY_CONTINUOUS_IMP_CONTINUOUS-val">UNIFORMLY_CONTINUOUS_IMP_CONTINUOUS</a> : thm
<a name="line1642"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_ADD-val">UNIFORMLY_CONTINUOUS_ON_ADD</a> : thm
<a name="line1643"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_CLOSURE-val">UNIFORMLY_CONTINUOUS_ON_CLOSURE</a> : thm
<a name="line1644"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_CMUL-val">UNIFORMLY_CONTINUOUS_ON_CMUL</a> : thm
<a name="line1645"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_COMPOSE-val">UNIFORMLY_CONTINUOUS_ON_COMPOSE</a> : thm
<a name="line1646"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_CONST-val">UNIFORMLY_CONTINUOUS_ON_CONST</a> : thm
<a name="line1647"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_DIST_CLOSEST_POINT-val">UNIFORMLY_CONTINUOUS_ON_DIST_CLOSEST_POINT</a> : thm
<a name="line1648"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_EQ-val">UNIFORMLY_CONTINUOUS_ON_EQ</a> : thm
<a name="line1649"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_ID-val">UNIFORMLY_CONTINUOUS_ON_ID</a> : thm
<a name="line1650"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_MUL-val">UNIFORMLY_CONTINUOUS_ON_MUL</a> : thm
<a name="line1651"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_NEG-val">UNIFORMLY_CONTINUOUS_ON_NEG</a> : thm
<a name="line1652"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_SEQUENTIALLY-val">UNIFORMLY_CONTINUOUS_ON_SEQUENTIALLY</a> : thm
<a name="line1653"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_SETDIST-val">UNIFORMLY_CONTINUOUS_ON_SETDIST</a> : thm
<a name="line1654"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_SUB-val">UNIFORMLY_CONTINUOUS_ON_SUB</a> : thm
<a name="line1655"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_SUBSET-val">UNIFORMLY_CONTINUOUS_ON_SUBSET</a> : thm
<a name="line1656"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_SUM-val">UNIFORMLY_CONTINUOUS_ON_SUM</a> : thm
<a name="line1657"></a>    val <a href="#UNIFORMLY_CONTINUOUS_ON_VMUL-val">UNIFORMLY_CONTINUOUS_ON_VMUL</a> : thm
<a name="line1658"></a>    val <a href="#UNIFORMLY_CONVERGENT_EQ_CAUCHY-val">UNIFORMLY_CONVERGENT_EQ_CAUCHY</a> : thm
<a name="line1659"></a>    val <a href="#UNIFORMLY_CONVERGENT_EQ_CAUCHY_ALT-val">UNIFORMLY_CONVERGENT_EQ_CAUCHY_ALT</a> : thm
<a name="line1660"></a>    val <a href="#UNIFORM_LIM_ADD-val">UNIFORM_LIM_ADD</a> : thm
<a name="line1661"></a>    val <a href="#UNIFORM_LIM_BILINEAR-val">UNIFORM_LIM_BILINEAR</a> : thm
<a name="line1662"></a>    val <a href="#UNIFORM_LIM_SUB-val">UNIFORM_LIM_SUB</a> : thm
<a name="line1663"></a>    val <a href="#UNION_FRONTIER-val">UNION_FRONTIER</a> : thm
<a name="line1664"></a>    val <a href="#UNION_INTERIOR_SUBSET-val">UNION_INTERIOR_SUBSET</a> : thm
<a name="line1665"></a>    val <a href="#UNIT_INTERVAL_NONEMPTY-val">UNIT_INTERVAL_NONEMPTY</a> : thm
<a name="line1666"></a>    val <a href="#UPPER_HEMICONTINUOUS-val">UPPER_HEMICONTINUOUS</a> : thm
<a name="line1667"></a>    val <a href="#UPPER_LOWER_HEMICONTINUOUS-val">UPPER_LOWER_HEMICONTINUOUS</a> : thm
<a name="line1668"></a>    val <a href="#UPPER_LOWER_HEMICONTINUOUS_EXPLICIT-val">UPPER_LOWER_HEMICONTINUOUS_EXPLICIT</a> : thm
<a name="line1669"></a>    val <a href="#URYSOHN-val">URYSOHN</a> : thm
<a name="line1670"></a>    val <a href="#URYSOHN_LOCAL-val">URYSOHN_LOCAL</a> : thm
<a name="line1671"></a>    val <a href="#URYSOHN_LOCAL_STRONG-val">URYSOHN_LOCAL_STRONG</a> : thm
<a name="line1672"></a>    val <a href="#URYSOHN_STRONG-val">URYSOHN_STRONG</a> : thm
<a name="line1673"></a>    val <a href="#WITHIN-val">WITHIN</a> : thm
<a name="line1674"></a>    val <a href="#WITHIN_UNIV-val">WITHIN_UNIV</a> : thm
<a name="line1675"></a>    val <a href="#WITHIN_WITHIN-val">WITHIN_WITHIN</a> : thm
<a name="line1676"></a>    val <a href="#at-val">at</a> : thm
<a name="line1677"></a>    val <a href="#ball-val">ball</a> : thm
<a name="line1678"></a>    val <a href="#closed_def-val">closed_def</a> : thm
<a name="line1679"></a>    val <a href="#continuous_at-val">continuous_at</a> : thm
<a name="line1680"></a>    val <a href="#continuous_within-val">continuous_within</a> : thm
<a name="line1681"></a>    val <a href="#diameter-val">diameter</a> : thm
<a name="line1682"></a>    val <a href="#dist-val">dist</a> : thm
<a name="line1683"></a>    val <a href="#euclidean-val">euclidean</a> : thm
<a name="line1684"></a>    val <a href="#fsigma-val">fsigma</a> : thm
<a name="line1685"></a>    val <a href="#gdelta-val">gdelta</a> : thm
<a name="line1686"></a>    val <a href="#interval-val">interval</a> : thm
<a name="line1687"></a>    val <a href="#limit_point_of-val">limit_point_of</a> : thm
<a name="line1688"></a>    val <a href="#linear_alt_cmul-val">linear_alt_cmul</a> : thm
<a name="line1689"></a>    val <a href="#linear_repr-val">linear_repr</a> : thm
<a name="line1690"></a>    val <a href="#net_tybij-val">net_tybij</a> : thm
<a name="line1691"></a>    val <a href="#open_def-val">open_def</a> : thm
<a name="line1692"></a>    val <a href="#open_in-val">open_in</a> : thm
<a name="line1693"></a>    val <a href="#segment-val">segment</a> : thm
<a name="line1694"></a>    val <a href="#setdist-val">setdist</a> : thm
<a name="line1695"></a>  
<a name="line1696"></a>  val real_topology_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line1697"></a>(*
   [nets] Parent theory of "real_topology"
   
   [real_sigma] Parent theory of "real_topology"
   
   [<a name="CLOSED_interval-val"><b>CLOSED_interval</b></a>]  Definition
      
      ⊢ ∀l. interval l = {x | FST (HD l) ≤ x ∧ x ≤ SND (HD l)}
   
   [<a name="OPEN_interval-val"><b>OPEN_interval</b></a>]  Definition
      
      ⊢ ∀a b. interval (a,b) = {x | a &lt; x ∧ x &lt; b}
   
   [<a name="at_def-val"><b>at_def</b></a>]  Definition
      
      ⊢ ∀z. at z = mk_net (tendsto (mr1,z))
   
   [<a name="at_infinity-val"><b>at_infinity</b></a>]  Definition
      
      ⊢ at_infinity = mk_net (λx y. abs x ≥ abs y)
   
   [<a name="at_neginfinity-val"><b>at_neginfinity</b></a>]  Definition
      
      ⊢ at_neginfinity = mk_net (λx y. x ≤ y)
   
   [<a name="at_posinfinity-val"><b>at_posinfinity</b></a>]  Definition
      
      ⊢ at_posinfinity = mk_net (λx y. x ≥ y)
   
   [<a name="ball_def-val"><b>ball_def</b></a>]  Definition
      
      ⊢ ball = mball mr1
   
   [<a name="between-val"><b>between</b></a>]  Definition
      
      ⊢ ∀x a b. between x (a,b) ⇔ dist (a,b) = dist (a,x) + dist (x,b)
   
   [<a name="bilinear-val"><b>bilinear</b></a>]  Definition
      
      ⊢ ∀f. bilinear f ⇔ (∀x. linear (λy. f x y)) ∧ ∀y. linear (λx. f x y)
   
   [<a name="bounded_def-val"><b>bounded_def</b></a>]  Definition
      
      ⊢ ∀s. bounded s ⇔ ∃a. ∀x. x ∈ s ⇒ abs x ≤ a
   
   [<a name="cauchy_def-val"><b>cauchy_def</b></a>]  Definition
      
      ⊢ ∀s. cauchy s ⇔
            ∀e. 0 &lt; e ⇒ ∃N. ∀m n. m ≥ N ∧ n ≥ N ⇒ dist (s m,s n) &lt; e
   
   [<a name="cball-val"><b>cball</b></a>]  Definition
      
      ⊢ ∀x e. cball (x,e) = {y | dist (x,y) ≤ e}
   
   [<a name="closed_segment-val"><b>closed_segment</b></a>]  Definition
      
      ⊢ ∀l. segment l =
            {(1 − u) * FST (HD l) + u * SND (HD l) | 0 ≤ u ∧ u ≤ 1}
   
   [<a name="closest_point-val"><b>closest_point</b></a>]  Definition
      
      ⊢ ∀s a.
          closest_point s a =
          @x. x ∈ s ∧ ∀y. y ∈ s ⇒ dist (a,x) ≤ dist (a,y)
   
   [<a name="closure-val"><b>closure</b></a>]  Definition
      
      ⊢ ∀s. closure s = s ∪ {x | x limit_point_of s}
   
   [<a name="collinear-val"><b>collinear</b></a>]  Definition
      
      ⊢ ∀s. collinear s ⇔ ∃u. ∀x y. x ∈ s ∧ y ∈ s ⇒ ∃c. x − y = c * u
   
   [<a name="compact-val"><b>compact</b></a>]  Definition
      
      ⊢ ∀s. compact s ⇔
            ∀f. (∀n. f n ∈ s) ⇒
                ∃l r.
                  l ∈ s ∧ (∀m n. m &lt; n ⇒ r m &lt; r n) ∧
                  (f ∘ r ⟶ l) sequentially
   
   [<a name="complete-val"><b>complete</b></a>]  Definition
      
      ⊢ ∀s. complete s ⇔
            ∀f. (∀n. f n ∈ s) ∧ cauchy f ⇒ ∃l. l ∈ s ∧ (f ⟶ l) sequentially
   
   [<a name="components-val"><b>components</b></a>]  Definition
      
      ⊢ ∀s. components s = {connected_component s x | x | x ∈ s}
   
   [<a name="condensation_point_of-val"><b>condensation_point_of</b></a>]  Definition
      
      ⊢ ∀x s.
          x condensation_point_of s ⇔
          ∀t. x ∈ t ∧ open t ⇒ uncountable (s ∩ t)
   
   [<a name="connected-val"><b>connected</b></a>]  Definition
      
      ⊢ ∀s. connected s ⇔
            ¬∃e1 e2.
              open e1 ∧ open e2 ∧ s ⊆ e1 ∪ e2 ∧ e1 ∩ e2 ∩ s = ∅ ∧
              e1 ∩ s ≠ ∅ ∧ e2 ∩ s ≠ ∅
   
   [<a name="connected_component-val"><b>connected_component</b></a>]  Definition
      
      ⊢ ∀s x y.
          connected_component s x y ⇔
          ∃t. connected t ∧ t ⊆ s ∧ x ∈ t ∧ y ∈ t
   
   [<a name="content-val"><b>content</b></a>]  Definition
      
      ⊢ ∀s. content s =
            if s = ∅ then 0
            else interval_upperbound s − interval_lowerbound s
   
   [<a name="continuous-val"><b>continuous</b></a>]  Definition
      
      ⊢ ∀f net. f continuous net ⇔ (f ⟶ f (netlimit net)) net
   
   [<a name="continuous_on-val"><b>continuous_on</b></a>]  Definition
      
      ⊢ ∀f s.
          f continuous_on s ⇔
          ∀x. x ∈ s ⇒
              ∀e. 0 &lt; e ⇒
                  ∃d. 0 &lt; d ∧
                      ∀x'. x' ∈ s ∧ dist (x',x) &lt; d ⇒ dist (f x',f x) &lt; e
   
   [<a name="dependent-val"><b>dependent</b></a>]  Definition
      
      ⊢ ∀s. dependent s ⇔ ∃a. a ∈ s ∧ a ∈ span (s DELETE a)
   
   [<a name="dim-val"><b>dim</b></a>]  Definition
      
      ⊢ ∀v. dim v =
            @n. ∃b. b ⊆ v ∧ independent b ∧ v ⊆ span b ∧ b HAS_SIZE n
   
   [<a name="dist_def-val"><b>dist_def</b></a>]  Definition
      
      ⊢ dist = dist mr1
   
   [<a name="euclidean_closed_def-val"><b>euclidean_closed_def</b></a>]  Definition
      
      ⊢ closed = closed_in euclidean
   
   [<a name="euclidean_def-val"><b>euclidean_def</b></a>]  Definition
      
      ⊢ euclidean = mtop mr1
   
   [<a name="euclidean_open_def-val"><b>euclidean_open_def</b></a>]  Definition
      
      ⊢ open = open_in euclidean
   
   [<a name="eventually-val"><b>eventually</b></a>]  Definition
      
      ⊢ ∀p net.
          eventually p net ⇔
          trivial_limit net ∨
          ∃y. (∃x. netord net x y) ∧ ∀x. netord net x y ⇒ p x
   
   [<a name="frontier-val"><b>frontier</b></a>]  Definition
      
      ⊢ ∀s. frontier s = closure s DIFF interior s
   
   [<a name="hausdist-val"><b>hausdist</b></a>]  Definition
      
      ⊢ ∀s t.
          hausdist (s,t) =
          if
            {setdist ({x},t) | x ∈ s} ∪ {setdist ({y},s) | y ∈ t} ≠ ∅ ∧
            ∃b. ∀d.
              d ∈ {setdist ({x},t) | x ∈ s} ∪ {setdist ({y},s) | y ∈ t} ⇒
              d ≤ b
          then
            sup ({setdist ({x},t) | x ∈ s} ∪ {setdist ({y},s) | y ∈ t})
          else 0
   
   [<a name="homeomorphic-val"><b>homeomorphic</b></a>]  Definition
      
      ⊢ ∀s t. s homeomorphic t ⇔ ∃f g. homeomorphism (s,t) (f,g)
   
   [<a name="homeomorphism-val"><b>homeomorphism</b></a>]  Definition
      
      ⊢ ∀s t f g.
          homeomorphism (s,t) (f,g) ⇔
          (∀x. x ∈ s ⇒ g (f x) = x) ∧ IMAGE f s = t ∧ f continuous_on s ∧
          (∀y. y ∈ t ⇒ f (g y) = y) ∧ IMAGE g t = s ∧ g continuous_on t
   
   [<a name="in_direction-val"><b>in_direction</b></a>]  Definition
      
      ⊢ ∀a v.
          (a in_direction v) =
          (at a within {b | ∃c. 0 ≤ c ∧ b − a = c * v})
   
   [<a name="independent-val"><b>independent</b></a>]  Definition
      
      ⊢ ∀s. independent s ⇔ ¬dependent s
   
   [<a name="interior-val"><b>interior</b></a>]  Definition
      
      ⊢ ∀s. interior s = {x | ∃t. open t ∧ x ∈ t ∧ t ⊆ s}
   
   [<a name="interval_lowerbound-val"><b>interval_lowerbound</b></a>]  Definition
      
      ⊢ ∀s. interval_lowerbound s = if s = ∅ then 0 else inf s
   
   [<a name="interval_upperbound-val"><b>interval_upperbound</b></a>]  Definition
      
      ⊢ ∀s. interval_upperbound s = if s = ∅ then 0 else sup s
   
   [<a name="is_interval-val"><b>is_interval</b></a>]  Definition
      
      ⊢ ∀s. is_interval s ⇔
            ∀a b x. a ∈ s ∧ b ∈ s ⇒ a ≤ x ∧ x ≤ b ∨ b ≤ x ∧ x ≤ a ⇒ x ∈ s
   
   [<a name="isnet-val"><b>isnet</b></a>]  Definition
      
      ⊢ ∀g. isnet g ⇔ ∀x y. (∀z. g z x ⇒ g z y) ∨ ∀z. g z y ⇒ g z x
   
   [<a name="limit_point_of_def-val"><b>limit_point_of_def</b></a>]  Definition
      
      ⊢ ∀x s. x limit_point_of s ⇔ limpt euclidean x s
   
   [<a name="linear-val"><b>linear</b></a>]  Definition
      
      ⊢ ∀f. linear f ⇔
            (∀x y. f (x + y) = f x + f y) ∧ ∀c x. f (c * x) = c * f x
   
   [<a name="locally-val"><b>locally</b></a>]  Definition
      
      ⊢ ∀P s.
          locally P s ⇔
          ∀w x.
            open_in (subtopology euclidean s) w ∧ x ∈ w ⇒
            ∃u v.
              open_in (subtopology euclidean s) u ∧ P v ∧ x ∈ u ∧ u ⊆ v ∧
              v ⊆ w
   
   [<a name="midpoint-val"><b>midpoint</b></a>]  Definition
      
      ⊢ ∀a b. midpoint (a,b) = 2⁻¹ * (a + b)
   
   [<a name="net_TY_DEF-val"><b>net_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep. TYPE_DEFINITION isnet rep
   
   [<a name="netlimit-val"><b>netlimit</b></a>]  Definition
      
      ⊢ ∀net. netlimit net = @a. ∀x. ¬netord net x a
   
   [<a name="open_segment-val"><b>open_segment</b></a>]  Definition
      
      ⊢ ∀a b. segment (a,b) = segment [(a,b)] DIFF {a; b}
   
   [<a name="reallim-val"><b>reallim</b></a>]  Definition
      
      ⊢ ∀net f. lim net f = @l. (f ⟶ l) net
   
   [<a name="sequentially-val"><b>sequentially</b></a>]  Definition
      
      ⊢ sequentially = mk_net (λm n. m ≥ n)
   
   [<a name="set_diameter_def-val"><b>set_diameter_def</b></a>]  Definition
      
      ⊢ ∀d s.
          set_diameter d s =
          if s = ∅ then 0 else sup {dist d (x,y) | x ∈ s ∧ y ∈ s}
   
   [<a name="set_dist_def-val"><b>set_dist_def</b></a>]  Definition
      
      ⊢ ∀d s t.
          set_dist d (s,t) =
          if s = ∅ ∨ t = ∅ then 0 else inf {dist d (x,y) | x ∈ s ∧ y ∈ t}
   
   [<a name="span-val"><b>span</b></a>]  Definition
      
      ⊢ ∀s. span s = subspace hull s
   
   [<a name="sphere-val"><b>sphere</b></a>]  Definition
      
      ⊢ ∀x e. sphere (x,e) = {y | dist (x,y) = e}
   
   [<a name="subspace-val"><b>subspace</b></a>]  Definition
      
      ⊢ ∀s. subspace s ⇔
            0 ∈ s ∧ (∀x y. x ∈ s ∧ y ∈ s ⇒ x + y ∈ s) ∧
            ∀c x. x ∈ s ⇒ c * x ∈ s
   
   [<a name="suminf_def-val"><b>suminf_def</b></a>]  Definition
      
      ⊢ ∀s f. suminf s f = @l. (f sums l) s
   
   [<a name="summable_def-val"><b>summable_def</b></a>]  Definition
      
      ⊢ ∀s f. summable s f ⇔ ∃l. (f sums l) s
   
   [<a name="sums_def-val"><b>sums_def</b></a>]  Definition
      
      ⊢ ∀f l s.
          (f sums l) s ⇔ ((λn. sum (s ∩ {0 .. n}) f) ⟶ l) sequentially
   
   [<a name="tendsto_real-val"><b>tendsto_real</b></a>]  Definition
      
      ⊢ ∀f l net.
          (f ⟶ l) net ⇔ ∀e. 0 &lt; e ⇒ eventually (λx. dist (f x,l) &lt; e) net
   
   [<a name="trivial_limit-val"><b>trivial_limit</b></a>]  Definition
      
      ⊢ ∀net.
          trivial_limit net ⇔
          (∀a b. a = b) ∨
          ∃a b. a ≠ b ∧ ∀x. ¬netord net x a ∧ ¬netord net x b
   
   [<a name="uniformly_continuous_on-val"><b>uniformly_continuous_on</b></a>]  Definition
      
      ⊢ ∀f s.
          f uniformly_continuous_on s ⇔
          ∀e. 0 &lt; e ⇒
              ∃d. 0 &lt; d ∧
                  ∀x x'.
                    x ∈ s ∧ x' ∈ s ∧ dist (x',x) &lt; d ⇒ dist (f x',f x) &lt; e
   
   [<a name="within-val"><b>within</b></a>]  Definition
      
      ⊢ ∀net s. (net within s) = mk_net (λx y. netord net x y ∧ x ∈ s)
   
   [<a name="ABS_CAUCHY_SCHWARZ_ABS_EQ-val"><b>ABS_CAUCHY_SCHWARZ_ABS_EQ</b></a>]  Theorem
      
      ⊢ ∀x y.
          abs (x * y) = abs x * abs y ⇔
          abs x * y = abs y * x ∨ abs x * y = -abs y * x
   
   [<a name="ABS_CAUCHY_SCHWARZ_EQ-val"><b>ABS_CAUCHY_SCHWARZ_EQ</b></a>]  Theorem
      
      ⊢ ∀x y. x * y = abs x * abs y ⇔ abs x * y = abs y * x
   
   [<a name="ABS_CAUCHY_SCHWARZ_EQUAL-val"><b>ABS_CAUCHY_SCHWARZ_EQUAL</b></a>]  Theorem
      
      ⊢ ∀x y. abs (x * y) = abs x * abs y ⇔ collinear {0; x; y}
   
   [<a name="ABS_SUM_TRIVIAL_LEMMA-val"><b>ABS_SUM_TRIVIAL_LEMMA</b></a>]  Theorem
      
      ⊢ ∀e. 0 &lt; e ⇒
            (P ⇒ abs (sum (s ∩ {m .. n}) f) &lt; e ⇔
             P ⇒ n &lt; m ∨ abs (sum (s ∩ {m .. n}) f) &lt; e)
   
   [<a name="ABS_TRIANGLE_EQ-val"><b>ABS_TRIANGLE_EQ</b></a>]  Theorem
      
      ⊢ ∀x y. abs (x + y) = abs x + abs y ⇔ abs x * y = abs y * x
   
   [<a name="ABS_TRIANGLE_LE-val"><b>ABS_TRIANGLE_LE</b></a>]  Theorem
      
      ⊢ ∀x y. abs x + abs y ≤ e ⇒ abs (x + y) ≤ e
   
   [<a name="AFFINITY_INVERSES-val"><b>AFFINITY_INVERSES</b></a>]  Theorem
      
      ⊢ ∀m c.
          m ≠ 0 ⇒
          (λx. m * x + c) ∘ (λx. m⁻¹ * x + -(m⁻¹ * c)) = (λx. x) ∧
          (λx. m⁻¹ * x + -(m⁻¹ * c)) ∘ (λx. m * x + c) = (λx. x)
   
   [<a name="ALWAYS_EVENTUALLY-val"><b>ALWAYS_EVENTUALLY</b></a>]  Theorem
      
      ⊢ (∀x. p x) ⇒ eventually p net
   
   [<a name="APPROACHABLE_LT_LE-val"><b>APPROACHABLE_LT_LE</b></a>]  Theorem
      
      ⊢ ∀P f.
          (∃d. 0 &lt; d ∧ ∀x. f x &lt; d ⇒ P x) ⇔ ∃d. 0 &lt; d ∧ ∀x. f x ≤ d ⇒ P x
   
   [<a name="AT-val"><b>AT</b></a>]  Theorem
      
      ⊢ ∀a x y.
          netord (at a) x y ⇔ 0 &lt; dist (x,a) ∧ dist (x,a) ≤ dist (y,a)
   
   [<a name="AT_INFINITY-val"><b>AT_INFINITY</b></a>]  Theorem
      
      ⊢ ∀x y. netord at_infinity x y ⇔ abs x ≥ abs y
   
   [<a name="AT_NEGINFINITY-val"><b>AT_NEGINFINITY</b></a>]  Theorem
      
      ⊢ ∀x y. netord at_neginfinity x y ⇔ x ≤ y
   
   [<a name="AT_POSINFINITY-val"><b>AT_POSINFINITY</b></a>]  Theorem
      
      ⊢ ∀x y. netord at_posinfinity x y ⇔ x ≥ y
   
   [<a name="BAIRE-val"><b>BAIRE</b></a>]  Theorem
      
      ⊢ ∀g s.
          locally compact s ∧ countable g ∧
          (∀t. t ∈ g ⇒ open_in (subtopology euclidean s) t ∧ s ⊆ closure t) ⇒
          s ⊆ closure (BIGINTER g)
   
   [<a name="BAIRE_ALT-val"><b>BAIRE_ALT</b></a>]  Theorem
      
      ⊢ ∀g s.
          locally compact s ∧ s ≠ ∅ ∧ countable g ∧ BIGUNION g = s ⇒
          ∃t u. t ∈ g ∧ open_in (subtopology euclidean s) u ∧ u ⊆ closure t
   
   [<a name="BALL-val"><b>BALL</b></a>]  Theorem
      
      ⊢ ∀x r.
          cball (x,r) = interval [(x − r,x + r)] ∧
          ball (x,r) = interval (x − r,x + r)
   
   [<a name="BALL_EMPTY-val"><b>BALL_EMPTY</b></a>]  Theorem
      
      ⊢ ∀x e. e ≤ 0 ⇒ ball (x,e) = ∅
   
   [<a name="BALL_EQ_EMPTY-val"><b>BALL_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ ∀x e. ball (x,e) = ∅ ⇔ e ≤ 0
   
   [<a name="BALL_INTERVAL-val"><b>BALL_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀x e. ball (x,e) = interval (x − e,x + e)
   
   [<a name="BALL_INTERVAL_0-val"><b>BALL_INTERVAL_0</b></a>]  Theorem
      
      ⊢ ∀e. ball (0,e) = interval (-e,e)
   
   [<a name="BALL_LINEAR_IMAGE-val"><b>BALL_LINEAR_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f x r.
          linear f ∧ (∀y. ∃x. f x = y) ∧ (∀x. abs (f x) = abs x) ⇒
          ball (f x,r) = IMAGE f (ball (x,r))
   
   [<a name="BALL_MAX_UNION-val"><b>BALL_MAX_UNION</b></a>]  Theorem
      
      ⊢ ∀a r s. ball (a,max r s) = ball (a,r) ∪ ball (a,s)
   
   [<a name="BALL_MIN_INTER-val"><b>BALL_MIN_INTER</b></a>]  Theorem
      
      ⊢ ∀a r s. ball (a,min r s) = ball (a,r) ∩ ball (a,s)
   
   [<a name="BALL_SCALING-val"><b>BALL_SCALING</b></a>]  Theorem
      
      ⊢ ∀c. 0 &lt; c ⇒
            ∀x r. ball (c * x,c * r) = IMAGE (λx. c * x) (ball (x,r))
   
   [<a name="BALL_SUBSET_CBALL-val"><b>BALL_SUBSET_CBALL</b></a>]  Theorem
      
      ⊢ ∀x e. ball (x,e) ⊆ cball (x,e)
   
   [<a name="BALL_TRANSLATION-val"><b>BALL_TRANSLATION</b></a>]  Theorem
      
      ⊢ ∀a x r. ball (a + x,r) = IMAGE (λy. a + y) (ball (x,r))
   
   [<a name="BALL_TRIVIAL-val"><b>BALL_TRIVIAL</b></a>]  Theorem
      
      ⊢ ∀x. ball (x,0) = ∅
   
   [<a name="BALL_UNION_SPHERE-val"><b>BALL_UNION_SPHERE</b></a>]  Theorem
      
      ⊢ ∀a r. ball (a,r) ∪ sphere (a,r) = cball (a,r)
   
   [<a name="BANACH_FIX-val"><b>BANACH_FIX</b></a>]  Theorem
      
      ⊢ ∀f s c.
          complete s ∧ s ≠ ∅ ∧ 0 ≤ c ∧ c &lt; 1 ∧ IMAGE f s ⊆ s ∧
          (∀x y. x ∈ s ∧ y ∈ s ⇒ dist (f x,f y) ≤ c * dist (x,y)) ⇒
          ∃!x. x ∈ s ∧ f x = x
   
   [<a name="BASIS_CARD_EQ_DIM-val"><b>BASIS_CARD_EQ_DIM</b></a>]  Theorem
      
      ⊢ ∀v b.
          b ⊆ v ∧ v ⊆ span b ∧ independent b ⇒ FINITE b ∧ CARD b = dim v
   
   [<a name="BASIS_EXISTS-val"><b>BASIS_EXISTS</b></a>]  Theorem
      
      ⊢ ∀v. ∃b. b ⊆ v ∧ independent b ∧ v ⊆ span b ∧ b HAS_SIZE dim v
   
   [<a name="BASIS_HAS_SIZE_DIM-val"><b>BASIS_HAS_SIZE_DIM</b></a>]  Theorem
      
      ⊢ ∀v b. independent b ∧ span b = v ⇒ b HAS_SIZE dim v
   
   [<a name="BETWEEN_ABS-val"><b>BETWEEN_ABS</b></a>]  Theorem
      
      ⊢ ∀a b x.
          between x (a,b) ⇔ abs (x − a) * (b − x) = abs (b − x) * (x − a)
   
   [<a name="BETWEEN_ANTISYM-val"><b>BETWEEN_ANTISYM</b></a>]  Theorem
      
      ⊢ ∀a b c. between a (b,c) ∧ between b (a,c) ⇒ a = b
   
   [<a name="BETWEEN_IMP_COLLINEAR-val"><b>BETWEEN_IMP_COLLINEAR</b></a>]  Theorem
      
      ⊢ ∀a b x. between x (a,b) ⇒ collinear {a; x; b}
   
   [<a name="BETWEEN_IN_SEGMENT-val"><b>BETWEEN_IN_SEGMENT</b></a>]  Theorem
      
      ⊢ ∀x a b. between x (a,b) ⇔ x ∈ segment [(a,b)]
   
   [<a name="BETWEEN_MIDPOINT-val"><b>BETWEEN_MIDPOINT</b></a>]  Theorem
      
      ⊢ ∀a b.
          between (midpoint (a,b)) (a,b) ∧ between (midpoint (a,b)) (b,a)
   
   [<a name="BETWEEN_REFL-val"><b>BETWEEN_REFL</b></a>]  Theorem
      
      ⊢ ∀a b. between a (a,b) ∧ between b (a,b) ∧ between a (a,a)
   
   [<a name="BETWEEN_REFL_EQ-val"><b>BETWEEN_REFL_EQ</b></a>]  Theorem
      
      ⊢ ∀a x. between x (a,a) ⇔ x = a
   
   [<a name="BETWEEN_SYM-val"><b>BETWEEN_SYM</b></a>]  Theorem
      
      ⊢ ∀a b x. between x (a,b) ⇔ between x (b,a)
   
   [<a name="BETWEEN_TRANS-val"><b>BETWEEN_TRANS</b></a>]  Theorem
      
      ⊢ ∀a b c d. between a (b,c) ∧ between d (a,c) ⇒ between d (b,c)
   
   [<a name="BETWEEN_TRANS_2-val"><b>BETWEEN_TRANS_2</b></a>]  Theorem
      
      ⊢ ∀a b c d. between a (b,c) ∧ between d (a,b) ⇒ between a (c,d)
   
   [<a name="BIGUNION_COMPONENTS-val"><b>BIGUNION_COMPONENTS</b></a>]  Theorem
      
      ⊢ ∀u. u = BIGUNION (components u)
   
   [<a name="BIGUNION_CONNECTED_COMPONENT-val"><b>BIGUNION_CONNECTED_COMPONENT</b></a>]  Theorem
      
      ⊢ ∀s. BIGUNION {connected_component s x | x | x ∈ s} = s
   
   [<a name="BIGUNION_DIFF-val"><b>BIGUNION_DIFF</b></a>]  Theorem
      
      ⊢ ∀s t. BIGUNION s DIFF t = BIGUNION {x DIFF t | x ∈ s}
   
   [<a name="BIGUNION_MONO-val"><b>BIGUNION_MONO</b></a>]  Theorem
      
      ⊢ (∀x. x ∈ s ⇒ ∃y. y ∈ t ∧ x ⊆ y) ⇒ BIGUNION s ⊆ BIGUNION t
   
   [<a name="BIGUNION_MONO_IMAGE-val"><b>BIGUNION_MONO_IMAGE</b></a>]  Theorem
      
      ⊢ (∀x. x ∈ s ⇒ f x ⊆ g x) ⇒
        BIGUNION (IMAGE f s) ⊆ BIGUNION (IMAGE g s)
   
   [<a name="BILINEAR_BOUNDED-val"><b>BILINEAR_BOUNDED</b></a>]  Theorem
      
      ⊢ ∀h. bilinear h ⇒ ∃B. ∀x y. abs (h x y) ≤ B * abs x * abs y
   
   [<a name="BILINEAR_BOUNDED_POS-val"><b>BILINEAR_BOUNDED_POS</b></a>]  Theorem
      
      ⊢ ∀h. bilinear h ⇒ ∃B. 0 &lt; B ∧ ∀x y. abs (h x y) ≤ B * abs x * abs y
   
   [<a name="BILINEAR_CONTINUOUS_COMPOSE-val"><b>BILINEAR_CONTINUOUS_COMPOSE</b></a>]  Theorem
      
      ⊢ ∀net f g h.
          f continuous net ∧ g continuous net ∧ bilinear h ⇒
          (λx. h (f x) (g x)) continuous net
   
   [<a name="BILINEAR_CONTINUOUS_ON_COMPOSE-val"><b>BILINEAR_CONTINUOUS_ON_COMPOSE</b></a>]  Theorem
      
      ⊢ ∀f g h s.
          f continuous_on s ∧ g continuous_on s ∧ bilinear h ⇒
          (λx. h (f x) (g x)) continuous_on s
   
   [<a name="BILINEAR_DOT-val"><b>BILINEAR_DOT</b></a>]  Theorem
      
      ⊢ bilinear (λx y. x * y)
   
   [<a name="BILINEAR_LADD-val"><b>BILINEAR_LADD</b></a>]  Theorem
      
      ⊢ ∀h x y z. bilinear h ⇒ h (x + y) z = h x z + h y z
   
   [<a name="BILINEAR_LMUL-val"><b>BILINEAR_LMUL</b></a>]  Theorem
      
      ⊢ ∀h c x y. bilinear h ⇒ h (c * x) y = c * h x y
   
   [<a name="BILINEAR_LNEG-val"><b>BILINEAR_LNEG</b></a>]  Theorem
      
      ⊢ ∀h x y. bilinear h ⇒ h (-x) y = -h x y
   
   [<a name="BILINEAR_LSUB-val"><b>BILINEAR_LSUB</b></a>]  Theorem
      
      ⊢ ∀h x y z. bilinear h ⇒ h (x − y) z = h x z − h y z
   
   [<a name="BILINEAR_LZERO-val"><b>BILINEAR_LZERO</b></a>]  Theorem
      
      ⊢ ∀h x. bilinear h ⇒ h 0 x = 0
   
   [<a name="BILINEAR_RADD-val"><b>BILINEAR_RADD</b></a>]  Theorem
      
      ⊢ ∀h x y z. bilinear h ⇒ h x (y + z) = h x y + h x z
   
   [<a name="BILINEAR_RMUL-val"><b>BILINEAR_RMUL</b></a>]  Theorem
      
      ⊢ ∀h c x y. bilinear h ⇒ h x (c * y) = c * h x y
   
   [<a name="BILINEAR_RNEG-val"><b>BILINEAR_RNEG</b></a>]  Theorem
      
      ⊢ ∀h x y. bilinear h ⇒ h x (-y) = -h x y
   
   [<a name="BILINEAR_RSUB-val"><b>BILINEAR_RSUB</b></a>]  Theorem
      
      ⊢ ∀h x y z. bilinear h ⇒ h x (y − z) = h x y − h x z
   
   [<a name="BILINEAR_RZERO-val"><b>BILINEAR_RZERO</b></a>]  Theorem
      
      ⊢ ∀h x. bilinear h ⇒ h x 0 = 0
   
   [<a name="BILINEAR_SUM-val"><b>BILINEAR_SUM</b></a>]  Theorem
      
      ⊢ ∀h. bilinear h ∧ FINITE s ∧ FINITE t ⇒
            h (sum s f) (sum t g) = sum (s × t) (λ(i,j). h (f i) (g j))
   
   [<a name="BILINEAR_SUM_PARTIAL_PRE-val"><b>BILINEAR_SUM_PARTIAL_PRE</b></a>]  Theorem
      
      ⊢ ∀f g h m n.
          bilinear h ⇒
          sum {m .. n} (λk. h (f k) (g k − g (k − 1))) =
          if m ≤ n then
            h (f (n + 1)) (g n) − h (f m) (g (m − 1)) −
            sum {m .. n} (λk. h (f (k + 1) − f k) (g k))
          else 0
   
   [<a name="BILINEAR_SUM_PARTIAL_SUC-val"><b>BILINEAR_SUM_PARTIAL_SUC</b></a>]  Theorem
      
      ⊢ ∀f g h m n.
          bilinear h ⇒
          sum {m .. n} (λk. h (f k) (g (k + 1) − g k)) =
          if m ≤ n then
            h (f (n + 1)) (g (n + 1)) − h (f m) (g m) −
            sum {m .. n} (λk. h (f (k + 1) − f k) (g (k + 1)))
          else 0
   
   [<a name="BILINEAR_SWAP-val"><b>BILINEAR_SWAP</b></a>]  Theorem
      
      ⊢ ∀op. bilinear (λx y. op y x) ⇔ bilinear op
   
   [<a name="BILINEAR_UNIFORMLY_CONTINUOUS_ON_COMPOSE-val"><b>BILINEAR_UNIFORMLY_CONTINUOUS_ON_COMPOSE</b></a>]  Theorem
      
      ⊢ ∀f g h s.
          f uniformly_continuous_on s ∧ g uniformly_continuous_on s ∧
          bilinear h ∧ bounded (IMAGE f s) ∧ bounded (IMAGE g s) ⇒
          (λx. h (f x) (g x)) uniformly_continuous_on s
   
   [<a name="BOLZANO_WEIERSTRASS-val"><b>BOLZANO_WEIERSTRASS</b></a>]  Theorem
      
      ⊢ ∀s. bounded s ∧ INFINITE s ⇒ ∃x. x limit_point_of s
   
   [<a name="BOLZANO_WEIERSTRASS_CONTRAPOS-val"><b>BOLZANO_WEIERSTRASS_CONTRAPOS</b></a>]  Theorem
      
      ⊢ ∀s t.
          compact s ∧ t ⊆ s ∧ (∀x. x ∈ s ⇒ ¬(x limit_point_of t)) ⇒
          FINITE t
   
   [<a name="BOLZANO_WEIERSTRASS_IMP_BOUNDED-val"><b>BOLZANO_WEIERSTRASS_IMP_BOUNDED</b></a>]  Theorem
      
      ⊢ ∀s. (∀t. INFINITE t ∧ t ⊆ s ⇒ ∃x. x limit_point_of t) ⇒ bounded s
   
   [<a name="BOLZANO_WEIERSTRASS_IMP_CLOSED-val"><b>BOLZANO_WEIERSTRASS_IMP_CLOSED</b></a>]  Theorem
      
      ⊢ ∀s. (∀t. INFINITE t ∧ t ⊆ s ⇒ ∃x. x ∈ s ∧ x limit_point_of t) ⇒
            closed s
   
   [<a name="BOUNDED_BALL-val"><b>BOUNDED_BALL</b></a>]  Theorem
      
      ⊢ ∀x e. bounded (ball (x,e))
   
   [<a name="BOUNDED_BIGINTER-val"><b>BOUNDED_BIGINTER</b></a>]  Theorem
      
      ⊢ ∀f. (∃s. s ∈ f ∧ bounded s) ⇒ bounded (BIGINTER f)
   
   [<a name="BOUNDED_BIGUNION-val"><b>BOUNDED_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀f. FINITE f ∧ (∀s. s ∈ f ⇒ bounded s) ⇒ bounded (BIGUNION f)
   
   [<a name="BOUNDED_CBALL-val"><b>BOUNDED_CBALL</b></a>]  Theorem
      
      ⊢ ∀x e. bounded (cball (x,e))
   
   [<a name="BOUNDED_CLOSED_CHAIN-val"><b>BOUNDED_CLOSED_CHAIN</b></a>]  Theorem
      
      ⊢ ∀f b.
          (∀s. s ∈ f ⇒ closed s ∧ s ≠ ∅) ∧
          (∀s t. s ∈ f ∧ t ∈ f ⇒ s ⊆ t ∨ t ⊆ s) ∧ b ∈ f ∧ bounded b ⇒
          BIGINTER f ≠ ∅
   
   [<a name="BOUNDED_CLOSED_IMP_COMPACT-val"><b>BOUNDED_CLOSED_IMP_COMPACT</b></a>]  Theorem
      
      ⊢ ∀s. bounded s ∧ closed s ⇒ compact s
   
   [<a name="BOUNDED_CLOSED_INTERVAL-val"><b>BOUNDED_CLOSED_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀a b. bounded (interval [(a,b)])
   
   [<a name="BOUNDED_CLOSED_NEST-val"><b>BOUNDED_CLOSED_NEST</b></a>]  Theorem
      
      ⊢ ∀s. (∀n. closed (s n)) ∧ (∀n. s n ≠ ∅) ∧
            (∀m n. m ≤ n ⇒ s n ⊆ s m) ∧ bounded (s 0) ⇒
            ∃a. ∀n. a ∈ s n
   
   [<a name="BOUNDED_CLOSURE-val"><b>BOUNDED_CLOSURE</b></a>]  Theorem
      
      ⊢ ∀s. bounded s ⇒ bounded (closure s)
   
   [<a name="BOUNDED_CLOSURE_EQ-val"><b>BOUNDED_CLOSURE_EQ</b></a>]  Theorem
      
      ⊢ ∀s. bounded (closure s) ⇔ bounded s
   
   [<a name="BOUNDED_COMPONENTWISE-val"><b>BOUNDED_COMPONENTWISE</b></a>]  Theorem
      
      ⊢ ∀s. bounded s ⇔ bounded (IMAGE (λx. x) s)
   
   [<a name="BOUNDED_DECREASING_CONVERGENT-val"><b>BOUNDED_DECREASING_CONVERGENT</b></a>]  Theorem
      
      ⊢ ∀s. bounded {s n | n ∈ 𝕌(:num)} ∧ (∀n. s (SUC n) ≤ s n) ⇒
            ∃l. (s ⟶ l) sequentially
   
   [<a name="BOUNDED_DIFF-val"><b>BOUNDED_DIFF</b></a>]  Theorem
      
      ⊢ ∀s t. bounded s ⇒ bounded (s DIFF t)
   
   [<a name="BOUNDED_DIFFS-val"><b>BOUNDED_DIFFS</b></a>]  Theorem
      
      ⊢ ∀s t. bounded s ∧ bounded t ⇒ bounded {x − y | x ∈ s ∧ y ∈ t}
   
   [<a name="BOUNDED_EMPTY-val"><b>BOUNDED_EMPTY</b></a>]  Theorem
      
      ⊢ bounded ∅
   
   [<a name="BOUNDED_EQ_BOLZANO_WEIERSTRASS-val"><b>BOUNDED_EQ_BOLZANO_WEIERSTRASS</b></a>]  Theorem
      
      ⊢ ∀s. bounded s ⇔ ∀t. t ⊆ s ∧ INFINITE t ⇒ ∃x. x limit_point_of t
   
   [<a name="BOUNDED_FRONTIER-val"><b>BOUNDED_FRONTIER</b></a>]  Theorem
      
      ⊢ ∀s. bounded s ⇒ bounded (frontier s)
   
   [<a name="BOUNDED_HAS_INF-val"><b>BOUNDED_HAS_INF</b></a>]  Theorem
      
      ⊢ ∀s. bounded s ∧ s ≠ ∅ ⇒
            (∀x. x ∈ s ⇒ inf s ≤ x) ∧ ∀b. (∀x. x ∈ s ⇒ b ≤ x) ⇒ b ≤ inf s
   
   [<a name="BOUNDED_HAS_SUP-val"><b>BOUNDED_HAS_SUP</b></a>]  Theorem
      
      ⊢ ∀s. bounded s ∧ s ≠ ∅ ⇒
            (∀x. x ∈ s ⇒ x ≤ sup s) ∧ ∀b. (∀x. x ∈ s ⇒ x ≤ b) ⇒ sup s ≤ b
   
   [<a name="BOUNDED_INCREASING_CONVERGENT-val"><b>BOUNDED_INCREASING_CONVERGENT</b></a>]  Theorem
      
      ⊢ ∀s. bounded {s n | n ∈ 𝕌(:num)} ∧ (∀n. s n ≤ s (SUC n)) ⇒
            ∃l. (s ⟶ l) sequentially
   
   [<a name="BOUNDED_INSERT-val"><b>BOUNDED_INSERT</b></a>]  Theorem
      
      ⊢ ∀x s. bounded (x INSERT s) ⇔ bounded s
   
   [<a name="BOUNDED_INTER-val"><b>BOUNDED_INTER</b></a>]  Theorem
      
      ⊢ ∀s t. bounded s ∨ bounded t ⇒ bounded (s ∩ t)
   
   [<a name="BOUNDED_INTERIOR-val"><b>BOUNDED_INTERIOR</b></a>]  Theorem
      
      ⊢ ∀s. bounded s ⇒ bounded (interior s)
   
   [<a name="BOUNDED_INTERVAL-val"><b>BOUNDED_INTERVAL</b></a>]  Theorem
      
      ⊢ (∀a b. bounded (interval [(a,b)])) ∧ ∀a b. bounded (interval (a,b))
   
   [<a name="BOUNDED_LINEAR_IMAGE-val"><b>BOUNDED_LINEAR_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s. bounded s ∧ linear f ⇒ bounded (IMAGE f s)
   
   [<a name="BOUNDED_NEGATIONS-val"><b>BOUNDED_NEGATIONS</b></a>]  Theorem
      
      ⊢ ∀s. bounded s ⇒ bounded (IMAGE (λx. -x) s)
   
   [<a name="BOUNDED_PARTIAL_SUMS-val"><b>BOUNDED_PARTIAL_SUMS</b></a>]  Theorem
      
      ⊢ ∀f k.
          bounded {sum {k .. n} f | n ∈ 𝕌(:num)} ⇒
          bounded {sum {m .. n} f | m ∈ 𝕌(:num) ∧ n ∈ 𝕌(:num)}
   
   [<a name="BOUNDED_POS-val"><b>BOUNDED_POS</b></a>]  Theorem
      
      ⊢ ∀s. bounded s ⇔ ∃b. 0 &lt; b ∧ ∀x. x ∈ s ⇒ abs x ≤ b
   
   [<a name="BOUNDED_POS_LT-val"><b>BOUNDED_POS_LT</b></a>]  Theorem
      
      ⊢ ∀s. bounded s ⇔ ∃b. 0 &lt; b ∧ ∀x. x ∈ s ⇒ abs x &lt; b
   
   [<a name="BOUNDED_SCALING-val"><b>BOUNDED_SCALING</b></a>]  Theorem
      
      ⊢ ∀c s. bounded s ⇒ bounded (IMAGE (λx. c * x) s)
   
   [<a name="BOUNDED_SING-val"><b>BOUNDED_SING</b></a>]  Theorem
      
      ⊢ ∀a. bounded {a}
   
   [<a name="BOUNDED_SPHERE-val"><b>BOUNDED_SPHERE</b></a>]  Theorem
      
      ⊢ ∀a r. bounded (sphere (a,r))
   
   [<a name="BOUNDED_SUBSET-val"><b>BOUNDED_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t. bounded t ∧ s ⊆ t ⇒ bounded s
   
   [<a name="BOUNDED_SUBSET_BALL-val"><b>BOUNDED_SUBSET_BALL</b></a>]  Theorem
      
      ⊢ ∀s x. bounded s ⇒ ∃r. 0 &lt; r ∧ s ⊆ ball (x,r)
   
   [<a name="BOUNDED_SUBSET_CBALL-val"><b>BOUNDED_SUBSET_CBALL</b></a>]  Theorem
      
      ⊢ ∀s x. bounded s ⇒ ∃r. 0 &lt; r ∧ s ⊆ cball (x,r)
   
   [<a name="BOUNDED_SUBSET_CLOSED_INTERVAL-val"><b>BOUNDED_SUBSET_CLOSED_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀s. bounded s ⇒ ∃a b. s ⊆ interval [(a,b)]
   
   [<a name="BOUNDED_SUBSET_CLOSED_INTERVAL_SYMMETRIC-val"><b>BOUNDED_SUBSET_CLOSED_INTERVAL_SYMMETRIC</b></a>]  Theorem
      
      ⊢ ∀s. bounded s ⇒ ∃a. s ⊆ interval [(-a,a)]
   
   [<a name="BOUNDED_SUBSET_OPEN_INTERVAL-val"><b>BOUNDED_SUBSET_OPEN_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀s. bounded s ⇒ ∃a b. s ⊆ interval (a,b)
   
   [<a name="BOUNDED_SUBSET_OPEN_INTERVAL_SYMMETRIC-val"><b>BOUNDED_SUBSET_OPEN_INTERVAL_SYMMETRIC</b></a>]  Theorem
      
      ⊢ ∀s. bounded s ⇒ ∃a. s ⊆ interval (-a,a)
   
   [<a name="BOUNDED_SUMS-val"><b>BOUNDED_SUMS</b></a>]  Theorem
      
      ⊢ ∀s t. bounded s ∧ bounded t ⇒ bounded {x + y | x ∈ s ∧ y ∈ t}
   
   [<a name="BOUNDED_SUMS_IMAGE-val"><b>BOUNDED_SUMS_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f g t.
          bounded {f x | x ∈ t} ∧ bounded {g x | x ∈ t} ⇒
          bounded {f x + g x | x ∈ t}
   
   [<a name="BOUNDED_SUMS_IMAGES-val"><b>BOUNDED_SUMS_IMAGES</b></a>]  Theorem
      
      ⊢ ∀f t s.
          FINITE s ∧ (∀a. a ∈ s ⇒ bounded {f x a | x ∈ t}) ⇒
          bounded {sum s (f x) | x ∈ t}
   
   [<a name="BOUNDED_TRANSLATION-val"><b>BOUNDED_TRANSLATION</b></a>]  Theorem
      
      ⊢ ∀a s. bounded s ⇒ bounded (IMAGE (λx. a + x) s)
   
   [<a name="BOUNDED_TRANSLATION_EQ-val"><b>BOUNDED_TRANSLATION_EQ</b></a>]  Theorem
      
      ⊢ ∀a s. bounded (IMAGE (λx. a + x) s) ⇔ bounded s
   
   [<a name="BOUNDED_UNIFORMLY_CONTINUOUS_IMAGE-val"><b>BOUNDED_UNIFORMLY_CONTINUOUS_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s. f uniformly_continuous_on s ∧ bounded s ⇒ bounded (IMAGE f s)
   
   [<a name="BOUNDED_UNION-val"><b>BOUNDED_UNION</b></a>]  Theorem
      
      ⊢ ∀s t. bounded (s ∪ t) ⇔ bounded s ∧ bounded t
   
   [<a name="CARD_EQ_BALL-val"><b>CARD_EQ_BALL</b></a>]  Theorem
      
      ⊢ ∀a r. 0 &lt; r ⇒ ball (a,r) ≈ 𝕌(:real)
   
   [<a name="CARD_EQ_CBALL-val"><b>CARD_EQ_CBALL</b></a>]  Theorem
      
      ⊢ ∀a r. 0 &lt; r ⇒ cball (a,r) ≈ 𝕌(:real)
   
   [<a name="CARD_EQ_EUCLIDEAN-val"><b>CARD_EQ_EUCLIDEAN</b></a>]  Theorem
      
      ⊢ 𝕌(:real) ≈ 𝕌(:real)
   
   [<a name="CARD_EQ_INTERVAL-val"><b>CARD_EQ_INTERVAL</b></a>]  Theorem
      
      ⊢ (∀a b. interval (a,b) ≠ ∅ ⇒ interval [(a,b)] ≈ 𝕌(:real)) ∧
        ∀a b. interval (a,b) ≠ ∅ ⇒ interval (a,b) ≈ 𝕌(:real)
   
   [<a name="CARD_EQ_OPEN-val"><b>CARD_EQ_OPEN</b></a>]  Theorem
      
      ⊢ ∀s. open s ∧ s ≠ ∅ ⇒ s ≈ 𝕌(:real)
   
   [<a name="CARD_EQ_REAL-val"><b>CARD_EQ_REAL</b></a>]  Theorem
      
      ⊢ 𝕌(:real) ≈ 𝕌(:num -&gt; bool)
   
   [<a name="CARD_EQ_REAL_IMP_UNCOUNTABLE-val"><b>CARD_EQ_REAL_IMP_UNCOUNTABLE</b></a>]  Theorem
      
      ⊢ ∀s. s ≈ 𝕌(:real) ⇒ uncountable s
   
   [<a name="CARD_FRONTIER_INTERVAL-val"><b>CARD_FRONTIER_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀s. is_interval s ⇒ FINITE (frontier s) ∧ CARD (frontier s) ≤ 2
   
   [<a name="CARD_GE_DIM_INDEPENDENT-val"><b>CARD_GE_DIM_INDEPENDENT</b></a>]  Theorem
      
      ⊢ ∀v b. b ⊆ v ∧ independent b ∧ dim v ≤ CARD b ⇒ v ⊆ span b
   
   [<a name="CARD_STDBASIS-val"><b>CARD_STDBASIS</b></a>]  Theorem
      
      ⊢ CARD {1} = 1
   
   [<a name="CAUCHY-val"><b>CAUCHY</b></a>]  Theorem
      
      ⊢ ∀s. cauchy s ⇔ ∀e. 0 &lt; e ⇒ ∃N. ∀n. n ≥ N ⇒ dist (s n,s N) &lt; e
   
   [<a name="CAUCHY_CONTINUOUS_EXTENDS_TO_CLOSURE-val"><b>CAUCHY_CONTINUOUS_EXTENDS_TO_CLOSURE</b></a>]  Theorem
      
      ⊢ ∀f s.
          (∀x. cauchy x ∧ (∀n. x n ∈ s) ⇒ cauchy (f ∘ x)) ⇒
          ∃g. g continuous_on closure s ∧ ∀x. x ∈ s ⇒ g x = f x
   
   [<a name="CAUCHY_CONTINUOUS_IMP_CONTINUOUS-val"><b>CAUCHY_CONTINUOUS_IMP_CONTINUOUS</b></a>]  Theorem
      
      ⊢ ∀f s.
          (∀x. cauchy x ∧ (∀n. x n ∈ s) ⇒ cauchy (f ∘ x)) ⇒
          f continuous_on s
   
   [<a name="CAUCHY_CONTINUOUS_UNIQUENESS_LEMMA-val"><b>CAUCHY_CONTINUOUS_UNIQUENESS_LEMMA</b></a>]  Theorem
      
      ⊢ ∀f s.
          (∀x. cauchy x ∧ (∀n. x n ∈ s) ⇒ cauchy (f ∘ x)) ⇒
          ∀a x.
            (∀n. x n ∈ s) ∧ (x ⟶ a) sequentially ⇒
            ∃l. (f ∘ x ⟶ l) sequentially ∧
                ∀y. (∀n. y n ∈ s) ∧ (y ⟶ a) sequentially ⇒
                    (f ∘ y ⟶ l) sequentially
   
   [<a name="CAUCHY_IMP_BOUNDED-val"><b>CAUCHY_IMP_BOUNDED</b></a>]  Theorem
      
      ⊢ ∀s. cauchy s ⇒ bounded {y | (∃n. y = s n)}
   
   [<a name="CAUCHY_ISOMETRIC-val"><b>CAUCHY_ISOMETRIC</b></a>]  Theorem
      
      ⊢ ∀f s e x.
          0 &lt; e ∧ subspace s ∧ linear f ∧
          (∀x. x ∈ s ⇒ abs (f x) ≥ e * abs x) ∧ (∀n. x n ∈ s) ∧
          cauchy (f ∘ x) ⇒
          cauchy x
   
   [<a name="CBALL_DIFF_BALL-val"><b>CBALL_DIFF_BALL</b></a>]  Theorem
      
      ⊢ ∀a r. cball (a,r) DIFF ball (a,r) = sphere (a,r)
   
   [<a name="CBALL_DIFF_SPHERE-val"><b>CBALL_DIFF_SPHERE</b></a>]  Theorem
      
      ⊢ ∀a r. cball (a,r) DIFF sphere (a,r) = ball (a,r)
   
   [<a name="CBALL_EMPTY-val"><b>CBALL_EMPTY</b></a>]  Theorem
      
      ⊢ ∀x e. e &lt; 0 ⇒ cball (x,e) = ∅
   
   [<a name="CBALL_EQ_EMPTY-val"><b>CBALL_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ ∀x e. cball (x,e) = ∅ ⇔ e &lt; 0
   
   [<a name="CBALL_EQ_SING-val"><b>CBALL_EQ_SING</b></a>]  Theorem
      
      ⊢ ∀x e. cball (x,e) = {x} ⇔ e = 0
   
   [<a name="CBALL_INTERVAL-val"><b>CBALL_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀x e. cball (x,e) = interval [(x − e,x + e)]
   
   [<a name="CBALL_INTERVAL_0-val"><b>CBALL_INTERVAL_0</b></a>]  Theorem
      
      ⊢ ∀e. cball (0,e) = interval [(-e,e)]
   
   [<a name="CBALL_LINEAR_IMAGE-val"><b>CBALL_LINEAR_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f x r.
          linear f ∧ (∀y. ∃x. f x = y) ∧ (∀x. abs (f x) = abs x) ⇒
          cball (f x,r) = IMAGE f (cball (x,r))
   
   [<a name="CBALL_MAX_UNION-val"><b>CBALL_MAX_UNION</b></a>]  Theorem
      
      ⊢ ∀a r s. cball (a,max r s) = cball (a,r) ∪ cball (a,s)
   
   [<a name="CBALL_MIN_INTER-val"><b>CBALL_MIN_INTER</b></a>]  Theorem
      
      ⊢ ∀x d e. cball (x,min d e) = cball (x,d) ∩ cball (x,e)
   
   [<a name="CBALL_SCALING-val"><b>CBALL_SCALING</b></a>]  Theorem
      
      ⊢ ∀c. 0 &lt; c ⇒
            ∀x r. cball (c * x,c * r) = IMAGE (λx. c * x) (cball (x,r))
   
   [<a name="CBALL_SING-val"><b>CBALL_SING</b></a>]  Theorem
      
      ⊢ ∀x e. e = 0 ⇒ cball (x,e) = {x}
   
   [<a name="CBALL_TRANSLATION-val"><b>CBALL_TRANSLATION</b></a>]  Theorem
      
      ⊢ ∀a x r. cball (a + x,r) = IMAGE (λy. a + y) (cball (x,r))
   
   [<a name="CBALL_TRIVIAL-val"><b>CBALL_TRIVIAL</b></a>]  Theorem
      
      ⊢ ∀x. cball (x,0) = {x}
   
   [<a name="CENTRE_IN_BALL-val"><b>CENTRE_IN_BALL</b></a>]  Theorem
      
      ⊢ ∀x e. x ∈ ball (x,e) ⇔ 0 &lt; e
   
   [<a name="CENTRE_IN_CBALL-val"><b>CENTRE_IN_CBALL</b></a>]  Theorem
      
      ⊢ ∀x e. x ∈ cball (x,e) ⇔ 0 ≤ e
   
   [<a name="CLOPEN-val"><b>CLOPEN</b></a>]  Theorem
      
      ⊢ ∀s. closed s ∧ open s ⇔ s = ∅ ∨ s = 𝕌(:real)
   
   [<a name="CLOPEN_BIGUNION_COMPONENTS-val"><b>CLOPEN_BIGUNION_COMPONENTS</b></a>]  Theorem
      
      ⊢ ∀u s.
          closed_in (subtopology euclidean u) s ∧
          open_in (subtopology euclidean u) s ⇒
          ∃k. k ⊆ components u ∧ s = BIGUNION k
   
   [<a name="CLOPEN_IN_COMPONENTS-val"><b>CLOPEN_IN_COMPONENTS</b></a>]  Theorem
      
      ⊢ ∀u s.
          closed_in (subtopology euclidean u) s ∧
          open_in (subtopology euclidean u) s ∧ connected s ∧ s ≠ ∅ ⇒
          s ∈ components u
   
   [<a name="CLOSED-val"><b>CLOSED</b></a>]  Theorem
      
      ⊢ ∀s. closed s ⇔
            ∀x. (∀e. 0 &lt; e ⇒ ∃x'. x' ∈ s ∧ x' ≠ x ∧ abs (x' − x) &lt; e) ⇒
                x ∈ s
   
   [<a name="CLOSED_APPROACHABLE-val"><b>CLOSED_APPROACHABLE</b></a>]  Theorem
      
      ⊢ ∀x s. closed s ⇒ ((∀e. 0 &lt; e ⇒ ∃y. y ∈ s ∧ dist (y,x) &lt; e) ⇔ x ∈ s)
   
   [<a name="CLOSED_AS_GDELTA-val"><b>CLOSED_AS_GDELTA</b></a>]  Theorem
      
      ⊢ ∀s. closed s ⇒ gdelta s
   
   [<a name="CLOSED_BIGINTER-val"><b>CLOSED_BIGINTER</b></a>]  Theorem
      
      ⊢ ∀f. (∀s. s ∈ f ⇒ closed s) ⇒ closed (BIGINTER f)
   
   [<a name="CLOSED_BIGINTER_COMPACT-val"><b>CLOSED_BIGINTER_COMPACT</b></a>]  Theorem
      
      ⊢ ∀s. closed s ⇔ ∀e. compact (cball (0,e) ∩ s)
   
   [<a name="CLOSED_BIGUNION-val"><b>CLOSED_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ∧ (∀t. t ∈ s ⇒ closed t) ⇒ closed (BIGUNION s)
   
   [<a name="CLOSED_CBALL-val"><b>CLOSED_CBALL</b></a>]  Theorem
      
      ⊢ ∀x e. closed (cball (x,e))
   
   [<a name="CLOSED_CLOSURE-val"><b>CLOSED_CLOSURE</b></a>]  Theorem
      
      ⊢ ∀s. closed (closure s)
   
   [<a name="CLOSED_COMPACT_DIFFERENCES-val"><b>CLOSED_COMPACT_DIFFERENCES</b></a>]  Theorem
      
      ⊢ ∀s t. closed s ∧ compact t ⇒ closed {x − y | x ∈ s ∧ y ∈ t}
   
   [<a name="CLOSED_COMPACT_SUMS-val"><b>CLOSED_COMPACT_SUMS</b></a>]  Theorem
      
      ⊢ ∀s t. closed s ∧ compact t ⇒ closed {x + y | x ∈ s ∧ y ∈ t}
   
   [<a name="CLOSED_COMPONENTS-val"><b>CLOSED_COMPONENTS</b></a>]  Theorem
      
      ⊢ ∀s c. closed s ∧ c ∈ components s ⇒ closed c
   
   [<a name="CLOSED_CONNECTED_COMPONENT-val"><b>CLOSED_CONNECTED_COMPONENT</b></a>]  Theorem
      
      ⊢ ∀s x. closed s ⇒ closed (connected_component s x)
   
   [<a name="CLOSED_CONTAINS_SEQUENTIAL_LIMIT-val"><b>CLOSED_CONTAINS_SEQUENTIAL_LIMIT</b></a>]  Theorem
      
      ⊢ ∀s x l. closed s ∧ (∀n. x n ∈ s) ∧ (x ⟶ l) sequentially ⇒ l ∈ s
   
   [<a name="CLOSED_DIFF-val"><b>CLOSED_DIFF</b></a>]  Theorem
      
      ⊢ ∀s t. closed s ∧ open t ⇒ closed (s DIFF t)
   
   [<a name="CLOSED_DIFF_OPEN_INTERVAL-val"><b>CLOSED_DIFF_OPEN_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀a b.
          interval [(a,b)] DIFF interval (a,b) =
          if interval [(a,b)] = ∅ then ∅ else {a; b}
   
   [<a name="CLOSED_EMPTY-val"><b>CLOSED_EMPTY</b></a>]  Theorem
      
      ⊢ closed ∅
   
   [<a name="CLOSED_FIP-val"><b>CLOSED_FIP</b></a>]  Theorem
      
      ⊢ ∀f. (∀t. t ∈ f ⇒ closed t) ∧ (∃t. t ∈ f ∧ bounded t) ∧
            (∀f'. FINITE f' ∧ f' ⊆ f ⇒ BIGINTER f' ≠ ∅) ⇒
            BIGINTER f ≠ ∅
   
   [<a name="CLOSED_FORALL-val"><b>CLOSED_FORALL</b></a>]  Theorem
      
      ⊢ ∀Q. (∀a. closed {x | Q a x}) ⇒ closed {x | (∀a. Q a x)}
   
   [<a name="CLOSED_FORALL_IN-val"><b>CLOSED_FORALL_IN</b></a>]  Theorem
      
      ⊢ ∀P Q.
          (∀a. P a ⇒ closed {x | Q a x}) ⇒ closed {x | (∀a. P a ⇒ Q a x)}
   
   [<a name="CLOSED_HALFSPACE_COMPONENT_GE-val"><b>CLOSED_HALFSPACE_COMPONENT_GE</b></a>]  Theorem
      
      ⊢ ∀a. closed {x | x ≥ a}
   
   [<a name="CLOSED_HALFSPACE_COMPONENT_LE-val"><b>CLOSED_HALFSPACE_COMPONENT_LE</b></a>]  Theorem
      
      ⊢ ∀a. closed {x | x ≤ a}
   
   [<a name="CLOSED_HALFSPACE_GE-val"><b>CLOSED_HALFSPACE_GE</b></a>]  Theorem
      
      ⊢ ∀a b. closed {x | a * x ≥ b}
   
   [<a name="CLOSED_HALFSPACE_LE-val"><b>CLOSED_HALFSPACE_LE</b></a>]  Theorem
      
      ⊢ ∀a b. closed {x | a * x ≤ b}
   
   [<a name="CLOSED_HYPERPLANE-val"><b>CLOSED_HYPERPLANE</b></a>]  Theorem
      
      ⊢ ∀a b. closed {x | a * x = b}
   
   [<a name="CLOSED_IMP_FIP-val"><b>CLOSED_IMP_FIP</b></a>]  Theorem
      
      ⊢ ∀s f.
          closed s ∧ (∀t. t ∈ f ⇒ closed t) ∧ (∃t. t ∈ f ∧ bounded t) ∧
          (∀f'. FINITE f' ∧ f' ⊆ f ⇒ s ∩ BIGINTER f' ≠ ∅) ⇒
          s ∩ BIGINTER f ≠ ∅
   
   [<a name="CLOSED_IMP_FIP_COMPACT-val"><b>CLOSED_IMP_FIP_COMPACT</b></a>]  Theorem
      
      ⊢ ∀s f.
          closed s ∧ (∀t. t ∈ f ⇒ compact t) ∧
          (∀f'. FINITE f' ∧ f' ⊆ f ⇒ s ∩ BIGINTER f' ≠ ∅) ⇒
          s ∩ BIGINTER f ≠ ∅
   
   [<a name="CLOSED_IMP_LOCALLY_COMPACT-val"><b>CLOSED_IMP_LOCALLY_COMPACT</b></a>]  Theorem
      
      ⊢ ∀s. closed s ⇒ locally compact s
   
   [<a name="CLOSED_IN-val"><b>CLOSED_IN</b></a>]  Theorem
      
      ⊢ ∀s. closed s ⇔ closed_in euclidean s
   
   [<a name="CLOSED_INJECTIVE_IMAGE_SUBSPACE-val"><b>CLOSED_INJECTIVE_IMAGE_SUBSPACE</b></a>]  Theorem
      
      ⊢ ∀f s.
          subspace s ∧ linear f ∧ (∀x. x ∈ s ∧ f x = 0 ⇒ x = 0) ∧ closed s ⇒
          closed (IMAGE f s)
   
   [<a name="CLOSED_INJECTIVE_LINEAR_IMAGE-val"><b>CLOSED_INJECTIVE_LINEAR_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f. linear f ∧ (∀x y. f x = f y ⇒ x = y) ⇒
            ∀s. closed s ⇒ closed (IMAGE f s)
   
   [<a name="CLOSED_INJECTIVE_LINEAR_IMAGE_EQ-val"><b>CLOSED_INJECTIVE_LINEAR_IMAGE_EQ</b></a>]  Theorem
      
      ⊢ ∀f s.
          linear f ∧ (∀x y. f x = f y ⇒ x = y) ⇒
          (closed (IMAGE f s) ⇔ closed s)
   
   [<a name="CLOSED_INSERT-val"><b>CLOSED_INSERT</b></a>]  Theorem
      
      ⊢ ∀a s. closed s ⇒ closed (a INSERT s)
   
   [<a name="CLOSED_INTER-val"><b>CLOSED_INTER</b></a>]  Theorem
      
      ⊢ ∀s t. closed s ∧ closed t ⇒ closed (s ∩ t)
   
   [<a name="CLOSED_INTERVAL-val"><b>CLOSED_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀a b. closed (interval [(a,b)])
   
   [<a name="CLOSED_INTERVAL_EQ-val"><b>CLOSED_INTERVAL_EQ</b></a>]  Theorem
      
      ⊢ (∀a b. closed (interval [(a,b)])) ∧
        ∀a b. closed (interval (a,b)) ⇔ interval (a,b) = ∅
   
   [<a name="CLOSED_INTERVAL_IMAGE_UNIT_INTERVAL-val"><b>CLOSED_INTERVAL_IMAGE_UNIT_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀a b.
          interval [(a,b)] ≠ ∅ ⇒
          interval [(a,b)] =
          IMAGE (λx. a + x)
            (IMAGE (λx. @f. f = (b − a) * x) (interval [(0,1)]))
   
   [<a name="CLOSED_INTERVAL_LEFT-val"><b>CLOSED_INTERVAL_LEFT</b></a>]  Theorem
      
      ⊢ ∀b. closed {x | x ≤ b}
   
   [<a name="CLOSED_INTERVAL_RIGHT-val"><b>CLOSED_INTERVAL_RIGHT</b></a>]  Theorem
      
      ⊢ ∀a. closed {x | a ≤ x}
   
   [<a name="CLOSED_INTER_COMPACT-val"><b>CLOSED_INTER_COMPACT</b></a>]  Theorem
      
      ⊢ ∀s t. closed s ∧ compact t ⇒ compact (s ∩ t)
   
   [<a name="CLOSED_IN_CLOSED-val"><b>CLOSED_IN_CLOSED</b></a>]  Theorem
      
      ⊢ ∀s u.
          closed_in (subtopology euclidean u) s ⇔ ∃t. closed t ∧ s = u ∩ t
   
   [<a name="CLOSED_IN_CLOSED_EQ-val"><b>CLOSED_IN_CLOSED_EQ</b></a>]  Theorem
      
      ⊢ ∀s t.
          closed s ⇒
          (closed_in (subtopology euclidean s) t ⇔ closed t ∧ t ⊆ s)
   
   [<a name="CLOSED_IN_CLOSED_INTER-val"><b>CLOSED_IN_CLOSED_INTER</b></a>]  Theorem
      
      ⊢ ∀u s. closed s ⇒ closed_in (subtopology euclidean u) (u ∩ s)
   
   [<a name="CLOSED_IN_CLOSED_TRANS-val"><b>CLOSED_IN_CLOSED_TRANS</b></a>]  Theorem
      
      ⊢ ∀s t. closed_in (subtopology euclidean t) s ∧ closed t ⇒ closed s
   
   [<a name="CLOSED_IN_COMPACT-val"><b>CLOSED_IN_COMPACT</b></a>]  Theorem
      
      ⊢ ∀s t. compact s ∧ closed_in (subtopology euclidean s) t ⇒ compact t
   
   [<a name="CLOSED_IN_COMPACT_EQ-val"><b>CLOSED_IN_COMPACT_EQ</b></a>]  Theorem
      
      ⊢ ∀s t.
          compact s ⇒
          (closed_in (subtopology euclidean s) t ⇔ compact t ∧ t ⊆ s)
   
   [<a name="CLOSED_IN_COMPONENT-val"><b>CLOSED_IN_COMPONENT</b></a>]  Theorem
      
      ⊢ ∀s c. c ∈ components s ⇒ closed_in (subtopology euclidean s) c
   
   [<a name="CLOSED_IN_CONNECTED_COMPONENT-val"><b>CLOSED_IN_CONNECTED_COMPONENT</b></a>]  Theorem
      
      ⊢ ∀s x. closed_in (subtopology euclidean s) (connected_component s x)
   
   [<a name="CLOSED_IN_INTER_CLOSED-val"><b>CLOSED_IN_INTER_CLOSED</b></a>]  Theorem
      
      ⊢ ∀s t u.
          closed_in (subtopology euclidean u) s ∧ closed t ⇒
          closed_in (subtopology euclidean u) (s ∩ t)
   
   [<a name="CLOSED_IN_INTER_CLOSURE-val"><b>CLOSED_IN_INTER_CLOSURE</b></a>]  Theorem
      
      ⊢ ∀s t. closed_in (subtopology euclidean s) t ⇔ s ∩ closure t = t
   
   [<a name="CLOSED_IN_LIMPT-val"><b>CLOSED_IN_LIMPT</b></a>]  Theorem
      
      ⊢ ∀s t.
          closed_in (subtopology euclidean t) s ⇔
          s ⊆ t ∧ ∀x. x limit_point_of s ∧ x ∈ t ⇒ x ∈ s
   
   [<a name="CLOSED_IN_REFL-val"><b>CLOSED_IN_REFL</b></a>]  Theorem
      
      ⊢ ∀s. closed_in (subtopology euclidean s) s
   
   [<a name="CLOSED_IN_SING-val"><b>CLOSED_IN_SING</b></a>]  Theorem
      
      ⊢ ∀u x. closed_in (subtopology euclidean u) {x} ⇔ x ∈ u
   
   [<a name="CLOSED_IN_SUBSET_TRANS-val"><b>CLOSED_IN_SUBSET_TRANS</b></a>]  Theorem
      
      ⊢ ∀s t u.
          closed_in (subtopology euclidean u) s ∧ s ⊆ t ∧ t ⊆ u ⇒
          closed_in (subtopology euclidean t) s
   
   [<a name="CLOSED_IN_TRANS-val"><b>CLOSED_IN_TRANS</b></a>]  Theorem
      
      ⊢ ∀s t u.
          closed_in (subtopology euclidean t) s ∧
          closed_in (subtopology euclidean u) t ⇒
          closed_in (subtopology euclidean u) s
   
   [<a name="CLOSED_IN_TRANS_EQ-val"><b>CLOSED_IN_TRANS_EQ</b></a>]  Theorem
      
      ⊢ ∀s t.
          (∀u. closed_in (subtopology euclidean t) u ⇒
               closed_in (subtopology euclidean s) t) ⇔
          closed_in (subtopology euclidean s) t
   
   [<a name="CLOSED_LIMPT-val"><b>CLOSED_LIMPT</b></a>]  Theorem
      
      ⊢ ∀s. closed s ⇔ ∀x. x limit_point_of s ⇒ x ∈ s
   
   [<a name="CLOSED_LIMPTS-val"><b>CLOSED_LIMPTS</b></a>]  Theorem
      
      ⊢ ∀s. closed {x | x limit_point_of s}
   
   [<a name="CLOSED_MAP_CLOSURES-val"><b>CLOSED_MAP_CLOSURES</b></a>]  Theorem
      
      ⊢ ∀f. (∀s. closed s ⇒ closed (IMAGE f s)) ⇔
            ∀s. closure (IMAGE f s) ⊆ IMAGE f (closure s)
   
   [<a name="CLOSED_MAP_FROM_COMPOSITION_INJECTIVE-val"><b>CLOSED_MAP_FROM_COMPOSITION_INJECTIVE</b></a>]  Theorem
      
      ⊢ ∀f g s t u.
          IMAGE f s ⊆ t ∧ IMAGE g t ⊆ u ∧ g continuous_on t ∧
          (∀x y. x ∈ t ∧ y ∈ t ∧ g x = g y ⇒ x = y) ∧
          (∀k. closed_in (subtopology euclidean s) k ⇒
               closed_in (subtopology euclidean u) (IMAGE (g ∘ f) k)) ⇒
          ∀k. closed_in (subtopology euclidean s) k ⇒
              closed_in (subtopology euclidean t) (IMAGE f k)
   
   [<a name="CLOSED_MAP_FROM_COMPOSITION_SURJECTIVE-val"><b>CLOSED_MAP_FROM_COMPOSITION_SURJECTIVE</b></a>]  Theorem
      
      ⊢ ∀f g s t u.
          f continuous_on s ∧ IMAGE f s = t ∧ IMAGE g t ⊆ u ∧
          (∀k. closed_in (subtopology euclidean s) k ⇒
               closed_in (subtopology euclidean u) (IMAGE (g ∘ f) k)) ⇒
          ∀k. closed_in (subtopology euclidean t) k ⇒
              closed_in (subtopology euclidean u) (IMAGE g k)
   
   [<a name="CLOSED_MAP_IFF_UPPER_HEMICONTINUOUS_PREIMAGE-val"><b>CLOSED_MAP_IFF_UPPER_HEMICONTINUOUS_PREIMAGE</b></a>]  Theorem
      
      ⊢ ∀f s t.
          IMAGE f s ⊆ t ⇒
          ((∀u. closed_in (subtopology euclidean s) u ⇒
                closed_in (subtopology euclidean t) (IMAGE f u)) ⇔
           ∀u. open_in (subtopology euclidean s) u ⇒
               open_in (subtopology euclidean t)
                 {y | y ∈ t ∧ {x | x ∈ s ∧ f x = y} ⊆ u})
   
   [<a name="CLOSED_MAP_IMP_OPEN_MAP-val"><b>CLOSED_MAP_IMP_OPEN_MAP</b></a>]  Theorem
      
      ⊢ ∀f s t.
          IMAGE f s = t ∧
          (∀u. closed_in (subtopology euclidean s) u ⇒
               closed_in (subtopology euclidean t) (IMAGE f u)) ∧
          (∀u. open_in (subtopology euclidean s) u ⇒
               open_in (subtopology euclidean s)
                 {x | x ∈ s ∧ f x ∈ IMAGE f u}) ⇒
          ∀u. open_in (subtopology euclidean s) u ⇒
              open_in (subtopology euclidean t) (IMAGE f u)
   
   [<a name="CLOSED_MAP_IMP_QUOTIENT_MAP-val"><b>CLOSED_MAP_IMP_QUOTIENT_MAP</b></a>]  Theorem
      
      ⊢ ∀f s.
          f continuous_on s ∧
          (∀t. closed_in (subtopology euclidean s) t ⇒
               closed_in (subtopology euclidean (IMAGE f s)) (IMAGE f t)) ⇒
          ∀t. t ⊆ IMAGE f s ⇒
              (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ t} ⇔
               open_in (subtopology euclidean (IMAGE f s)) t)
   
   [<a name="CLOSED_MAP_OPEN_SUPERSET_PREIMAGE-val"><b>CLOSED_MAP_OPEN_SUPERSET_PREIMAGE</b></a>]  Theorem
      
      ⊢ ∀f s t u w.
          (∀k. closed_in (subtopology euclidean s) k ⇒
               closed_in (subtopology euclidean t) (IMAGE f k)) ∧
          open_in (subtopology euclidean s) u ∧ w ⊆ t ∧
          {x | x ∈ s ∧ f x ∈ w} ⊆ u ⇒
          ∃v. open_in (subtopology euclidean t) v ∧ w ⊆ v ∧
              {x | x ∈ s ∧ f x ∈ v} ⊆ u
   
   [<a name="CLOSED_MAP_OPEN_SUPERSET_PREIMAGE_EQ-val"><b>CLOSED_MAP_OPEN_SUPERSET_PREIMAGE_EQ</b></a>]  Theorem
      
      ⊢ ∀f s t.
          IMAGE f s ⊆ t ⇒
          ((∀k. closed_in (subtopology euclidean s) k ⇒
                closed_in (subtopology euclidean t) (IMAGE f k)) ⇔
           ∀u w.
             open_in (subtopology euclidean s) u ∧ w ⊆ t ∧
             {x | x ∈ s ∧ f x ∈ w} ⊆ u ⇒
             ∃v. open_in (subtopology euclidean t) v ∧ w ⊆ v ∧
                 {x | x ∈ s ∧ f x ∈ v} ⊆ u)
   
   [<a name="CLOSED_MAP_OPEN_SUPERSET_PREIMAGE_POINT-val"><b>CLOSED_MAP_OPEN_SUPERSET_PREIMAGE_POINT</b></a>]  Theorem
      
      ⊢ ∀f s t.
          IMAGE f s ⊆ t ⇒
          ((∀k. closed_in (subtopology euclidean s) k ⇒
                closed_in (subtopology euclidean t) (IMAGE f k)) ⇔
           ∀u y.
             open_in (subtopology euclidean s) u ∧ y ∈ t ∧
             {x | x ∈ s ∧ f x = y} ⊆ u ⇒
             ∃v. open_in (subtopology euclidean t) v ∧ y ∈ v ∧
                 {x | x ∈ s ∧ f x ∈ v} ⊆ u)
   
   [<a name="CLOSED_MAP_RESTRICT-val"><b>CLOSED_MAP_RESTRICT</b></a>]  Theorem
      
      ⊢ ∀f s t t'.
          (∀u. closed_in (subtopology euclidean s) u ⇒
               closed_in (subtopology euclidean t) (IMAGE f u)) ∧ t' ⊆ t ⇒
          ∀u. closed_in (subtopology euclidean {x | x ∈ s ∧ f x ∈ t'}) u ⇒
              closed_in (subtopology euclidean t') (IMAGE f u)
   
   [<a name="CLOSED_NEGATIONS-val"><b>CLOSED_NEGATIONS</b></a>]  Theorem
      
      ⊢ ∀s. closed s ⇒ closed (IMAGE (λx. -x) s)
   
   [<a name="CLOSED_OPEN_INTERVAL-val"><b>CLOSED_OPEN_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀a b. a ≤ b ⇒ interval [(a,b)] = interval (a,b) ∪ {a; b}
   
   [<a name="CLOSED_POSITIVE_ORTHANT-val"><b>CLOSED_POSITIVE_ORTHANT</b></a>]  Theorem
      
      ⊢ closed {x | 0 ≤ x}
   
   [<a name="CLOSED_SCALING-val"><b>CLOSED_SCALING</b></a>]  Theorem
      
      ⊢ ∀s c. closed s ⇒ closed (IMAGE (λx. c * x) s)
   
   [<a name="CLOSED_SEGMENT_LINEAR_IMAGE-val"><b>CLOSED_SEGMENT_LINEAR_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f a b. linear f ⇒ segment [(f a,f b)] = IMAGE f (segment [(a,b)])
   
   [<a name="CLOSED_SEQUENTIAL_LIMITS-val"><b>CLOSED_SEQUENTIAL_LIMITS</b></a>]  Theorem
      
      ⊢ ∀s. closed s ⇔ ∀x l. (∀n. x n ∈ s) ∧ (x ⟶ l) sequentially ⇒ l ∈ s
   
   [<a name="CLOSED_SING-val"><b>CLOSED_SING</b></a>]  Theorem
      
      ⊢ ∀a. closed {a}
   
   [<a name="CLOSED_SPHERE-val"><b>CLOSED_SPHERE</b></a>]  Theorem
      
      ⊢ ∀a r. closed (sphere (a,r))
   
   [<a name="CLOSED_STANDARD_HYPERPLANE-val"><b>CLOSED_STANDARD_HYPERPLANE</b></a>]  Theorem
      
      ⊢ ∀a. closed {x | x = a}
   
   [<a name="CLOSED_SUBSET-val"><b>CLOSED_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t. s ⊆ t ∧ closed s ⇒ closed_in (subtopology euclidean t) s
   
   [<a name="CLOSED_SUBSET_EQ-val"><b>CLOSED_SUBSET_EQ</b></a>]  Theorem
      
      ⊢ ∀u s. closed s ⇒ (closed_in (subtopology euclidean u) s ⇔ s ⊆ u)
   
   [<a name="CLOSED_SUBSTANDARD-val"><b>CLOSED_SUBSTANDARD</b></a>]  Theorem
      
      ⊢ closed {x | x = 0}
   
   [<a name="CLOSED_UNION-val"><b>CLOSED_UNION</b></a>]  Theorem
      
      ⊢ ∀s t. closed s ∧ closed t ⇒ closed (s ∪ t)
   
   [<a name="CLOSED_UNION_COMPACT_SUBSETS-val"><b>CLOSED_UNION_COMPACT_SUBSETS</b></a>]  Theorem
      
      ⊢ ∀s. closed s ⇒
            ∃f. (∀n. compact (f n)) ∧ (∀n. f n ⊆ s) ∧
                (∀n. f n ⊆ f (n + 1)) ∧ BIGUNION {f n | n ∈ 𝕌(:num)} = s ∧
                ∀k. compact k ∧ k ⊆ s ⇒ ∃N. ∀n. n ≥ N ⇒ k ⊆ f n
   
   [<a name="CLOSED_UNIV-val"><b>CLOSED_UNIV</b></a>]  Theorem
      
      ⊢ closed 𝕌(:real)
   
   [<a name="CLOSEST_POINT_EXISTS-val"><b>CLOSEST_POINT_EXISTS</b></a>]  Theorem
      
      ⊢ ∀s a.
          closed s ∧ s ≠ ∅ ⇒
          closest_point s a ∈ s ∧
          ∀y. y ∈ s ⇒ dist (a,closest_point s a) ≤ dist (a,y)
   
   [<a name="CLOSEST_POINT_IN_FRONTIER-val"><b>CLOSEST_POINT_IN_FRONTIER</b></a>]  Theorem
      
      ⊢ ∀s x.
          closed s ∧ s ≠ ∅ ∧ x ∉ interior s ⇒
          closest_point s x ∈ frontier s
   
   [<a name="CLOSEST_POINT_IN_INTERIOR-val"><b>CLOSEST_POINT_IN_INTERIOR</b></a>]  Theorem
      
      ⊢ ∀s x.
          closed s ∧ s ≠ ∅ ⇒
          (closest_point s x ∈ interior s ⇔ x ∈ interior s)
   
   [<a name="CLOSEST_POINT_IN_SET-val"><b>CLOSEST_POINT_IN_SET</b></a>]  Theorem
      
      ⊢ ∀s a. closed s ∧ s ≠ ∅ ⇒ closest_point s a ∈ s
   
   [<a name="CLOSEST_POINT_LE-val"><b>CLOSEST_POINT_LE</b></a>]  Theorem
      
      ⊢ ∀s a x. closed s ∧ x ∈ s ⇒ dist (a,closest_point s a) ≤ dist (a,x)
   
   [<a name="CLOSEST_POINT_REFL-val"><b>CLOSEST_POINT_REFL</b></a>]  Theorem
      
      ⊢ ∀s x. closed s ∧ s ≠ ∅ ⇒ (closest_point s x = x ⇔ x ∈ s)
   
   [<a name="CLOSEST_POINT_SELF-val"><b>CLOSEST_POINT_SELF</b></a>]  Theorem
      
      ⊢ ∀s x. x ∈ s ⇒ closest_point s x = x
   
   [<a name="CLOSURE_APPROACHABLE-val"><b>CLOSURE_APPROACHABLE</b></a>]  Theorem
      
      ⊢ ∀x s. x ∈ closure s ⇔ ∀e. 0 &lt; e ⇒ ∃y. y ∈ s ∧ dist (y,x) &lt; e
   
   [<a name="CLOSURE_BALL-val"><b>CLOSURE_BALL</b></a>]  Theorem
      
      ⊢ ∀x e. 0 &lt; e ⇒ closure (ball (x,e)) = cball (x,e)
   
   [<a name="CLOSURE_BIGINTER_SUBSET-val"><b>CLOSURE_BIGINTER_SUBSET</b></a>]  Theorem
      
      ⊢ ∀f. closure (BIGINTER f) ⊆ BIGINTER (IMAGE closure f)
   
   [<a name="CLOSURE_BIGUNION-val"><b>CLOSURE_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀f. FINITE f ⇒ closure (BIGUNION f) = BIGUNION {closure s | s ∈ f}
   
   [<a name="CLOSURE_BOUNDED_LINEAR_IMAGE-val"><b>CLOSURE_BOUNDED_LINEAR_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s.
          linear f ∧ bounded s ⇒ closure (IMAGE f s) = IMAGE f (closure s)
   
   [<a name="CLOSURE_CLOSED-val"><b>CLOSURE_CLOSED</b></a>]  Theorem
      
      ⊢ ∀s. closed s ⇒ closure s = s
   
   [<a name="CLOSURE_CLOSURE-val"><b>CLOSURE_CLOSURE</b></a>]  Theorem
      
      ⊢ ∀s. closure (closure s) = closure s
   
   [<a name="CLOSURE_COMPLEMENT-val"><b>CLOSURE_COMPLEMENT</b></a>]  Theorem
      
      ⊢ ∀s. closure (𝕌(:real) DIFF s) = 𝕌(:real) DIFF interior s
   
   [<a name="CLOSURE_EMPTY-val"><b>CLOSURE_EMPTY</b></a>]  Theorem
      
      ⊢ closure ∅ = ∅
   
   [<a name="CLOSURE_EQ-val"><b>CLOSURE_EQ</b></a>]  Theorem
      
      ⊢ ∀s. closure s = s ⇔ closed s
   
   [<a name="CLOSURE_EQ_EMPTY-val"><b>CLOSURE_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ ∀s. closure s = ∅ ⇔ s = ∅
   
   [<a name="CLOSURE_HALFSPACE_COMPONENT_GT-val"><b>CLOSURE_HALFSPACE_COMPONENT_GT</b></a>]  Theorem
      
      ⊢ ∀a. closure {x | x &gt; a} = {x | x ≥ a}
   
   [<a name="CLOSURE_HALFSPACE_COMPONENT_LT-val"><b>CLOSURE_HALFSPACE_COMPONENT_LT</b></a>]  Theorem
      
      ⊢ ∀a. closure {x | x &lt; a} = {x | x ≤ a}
   
   [<a name="CLOSURE_HALFSPACE_GT-val"><b>CLOSURE_HALFSPACE_GT</b></a>]  Theorem
      
      ⊢ ∀a b. a ≠ 0 ⇒ closure {x | a * x &gt; b} = {x | a * x ≥ b}
   
   [<a name="CLOSURE_HALFSPACE_LT-val"><b>CLOSURE_HALFSPACE_LT</b></a>]  Theorem
      
      ⊢ ∀a b. a ≠ 0 ⇒ closure {x | a * x &lt; b} = {x | a * x ≤ b}
   
   [<a name="CLOSURE_HULL-val"><b>CLOSURE_HULL</b></a>]  Theorem
      
      ⊢ ∀s. closure s = closed hull s
   
   [<a name="CLOSURE_HYPERPLANE-val"><b>CLOSURE_HYPERPLANE</b></a>]  Theorem
      
      ⊢ ∀a b. closure {x | a * x = b} = {x | a * x = b}
   
   [<a name="CLOSURE_IMAGE_BOUNDED-val"><b>CLOSURE_IMAGE_BOUNDED</b></a>]  Theorem
      
      ⊢ ∀f s.
          f continuous_on closure s ∧ bounded s ⇒
          closure (IMAGE f s) = IMAGE f (closure s)
   
   [<a name="CLOSURE_IMAGE_CLOSURE-val"><b>CLOSURE_IMAGE_CLOSURE</b></a>]  Theorem
      
      ⊢ ∀f s.
          f continuous_on closure s ⇒
          closure (IMAGE f (closure s)) = closure (IMAGE f s)
   
   [<a name="CLOSURE_INJECTIVE_LINEAR_IMAGE-val"><b>CLOSURE_INJECTIVE_LINEAR_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s.
          linear f ∧ (∀x y. f x = f y ⇒ x = y) ⇒
          closure (IMAGE f s) = IMAGE f (closure s)
   
   [<a name="CLOSURE_INTERIOR-val"><b>CLOSURE_INTERIOR</b></a>]  Theorem
      
      ⊢ ∀s. closure s = 𝕌(:real) DIFF interior (𝕌(:real) DIFF s)
   
   [<a name="CLOSURE_INTERIOR_IDEMP-val"><b>CLOSURE_INTERIOR_IDEMP</b></a>]  Theorem
      
      ⊢ ∀s. closure (interior (closure (interior s))) =
            closure (interior s)
   
   [<a name="CLOSURE_INTERIOR_UNION_CLOSED-val"><b>CLOSURE_INTERIOR_UNION_CLOSED</b></a>]  Theorem
      
      ⊢ ∀s t.
          closed s ∧ closed t ⇒
          closure (interior (s ∪ t)) =
          closure (interior s) ∪ closure (interior t)
   
   [<a name="CLOSURE_INTERVAL-val"><b>CLOSURE_INTERVAL</b></a>]  Theorem
      
      ⊢ (∀a b. closure (interval [(a,b)]) = interval [(a,b)]) ∧
        ∀a b.
          closure (interval (a,b)) =
          if interval (a,b) = ∅ then ∅ else interval [(a,b)]
   
   [<a name="CLOSURE_INTER_SUBSET-val"><b>CLOSURE_INTER_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t. closure (s ∩ t) ⊆ closure s ∩ closure t
   
   [<a name="CLOSURE_LINEAR_IMAGE_SUBSET-val"><b>CLOSURE_LINEAR_IMAGE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀f s. linear f ⇒ IMAGE f (closure s) ⊆ closure (IMAGE f s)
   
   [<a name="CLOSURE_MINIMAL-val"><b>CLOSURE_MINIMAL</b></a>]  Theorem
      
      ⊢ ∀s t. s ⊆ t ∧ closed t ⇒ closure s ⊆ t
   
   [<a name="CLOSURE_MINIMAL_EQ-val"><b>CLOSURE_MINIMAL_EQ</b></a>]  Theorem
      
      ⊢ ∀s t. closed t ⇒ (closure s ⊆ t ⇔ s ⊆ t)
   
   [<a name="CLOSURE_NEGATIONS-val"><b>CLOSURE_NEGATIONS</b></a>]  Theorem
      
      ⊢ ∀s. closure (IMAGE (λx. -x) s) = IMAGE (λx. -x) (closure s)
   
   [<a name="CLOSURE_NONEMPTY_OPEN_INTER-val"><b>CLOSURE_NONEMPTY_OPEN_INTER</b></a>]  Theorem
      
      ⊢ ∀s x. x ∈ closure s ⇔ ∀t. x ∈ t ∧ open t ⇒ s ∩ t ≠ ∅
   
   [<a name="CLOSURE_OPEN_INTERVAL-val"><b>CLOSURE_OPEN_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀a b.
          interval (a,b) ≠ ∅ ⇒ closure (interval (a,b)) = interval [(a,b)]
   
   [<a name="CLOSURE_OPEN_INTER_CLOSURE-val"><b>CLOSURE_OPEN_INTER_CLOSURE</b></a>]  Theorem
      
      ⊢ ∀s t. open s ⇒ closure (s ∩ closure t) = closure (s ∩ t)
   
   [<a name="CLOSURE_OPEN_INTER_SUPERSET-val"><b>CLOSURE_OPEN_INTER_SUPERSET</b></a>]  Theorem
      
      ⊢ ∀s t. open s ∧ s ⊆ closure t ⇒ closure (s ∩ t) = closure s
   
   [<a name="CLOSURE_OPEN_IN_INTER_CLOSURE-val"><b>CLOSURE_OPEN_IN_INTER_CLOSURE</b></a>]  Theorem
      
      ⊢ ∀s t u.
          open_in (subtopology euclidean u) s ∧ t ⊆ u ⇒
          closure (s ∩ closure t) = closure (s ∩ t)
   
   [<a name="CLOSURE_SEQUENTIAL-val"><b>CLOSURE_SEQUENTIAL</b></a>]  Theorem
      
      ⊢ ∀s l. l ∈ closure s ⇔ ∃x. (∀n. x n ∈ s) ∧ (x ⟶ l) sequentially
   
   [<a name="CLOSURE_SING-val"><b>CLOSURE_SING</b></a>]  Theorem
      
      ⊢ ∀x. closure {x} = {x}
   
   [<a name="CLOSURE_SUBSET-val"><b>CLOSURE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s. s ⊆ closure s
   
   [<a name="CLOSURE_SUBSET_EQ-val"><b>CLOSURE_SUBSET_EQ</b></a>]  Theorem
      
      ⊢ ∀s. closure s ⊆ s ⇔ closed s
   
   [<a name="CLOSURE_SUMS-val"><b>CLOSURE_SUMS</b></a>]  Theorem
      
      ⊢ ∀s t.
          bounded s ∨ bounded t ⇒
          closure {x + y | x ∈ s ∧ y ∈ t} =
          {x + y | x ∈ closure s ∧ y ∈ closure t}
   
   [<a name="CLOSURE_UNION-val"><b>CLOSURE_UNION</b></a>]  Theorem
      
      ⊢ ∀s t. closure (s ∪ t) = closure s ∪ closure t
   
   [<a name="CLOSURE_UNION_FRONTIER-val"><b>CLOSURE_UNION_FRONTIER</b></a>]  Theorem
      
      ⊢ ∀s. closure s = s ∪ frontier s
   
   [<a name="CLOSURE_UNIQUE-val"><b>CLOSURE_UNIQUE</b></a>]  Theorem
      
      ⊢ ∀s t.
          s ⊆ t ∧ closed t ∧ (∀t'. s ⊆ t' ∧ closed t' ⇒ t ⊆ t') ⇒
          closure s = t
   
   [<a name="CLOSURE_UNIV-val"><b>CLOSURE_UNIV</b></a>]  Theorem
      
      ⊢ closure 𝕌(:real) = 𝕌(:real)
   
   [<a name="COBOUNDED_IMP_UNBOUNDED-val"><b>COBOUNDED_IMP_UNBOUNDED</b></a>]  Theorem
      
      ⊢ ∀s. bounded (𝕌(:real) DIFF s) ⇒ ¬bounded s
   
   [<a name="COBOUNDED_INTER_UNBOUNDED-val"><b>COBOUNDED_INTER_UNBOUNDED</b></a>]  Theorem
      
      ⊢ ∀s t. bounded (𝕌(:real) DIFF s) ∧ ¬bounded t ⇒ s ∩ t ≠ ∅
   
   [<a name="COLLINEAR_1-val"><b>COLLINEAR_1</b></a>]  Theorem
      
      ⊢ ∀s. collinear s
   
   [<a name="COLLINEAR_2-val"><b>COLLINEAR_2</b></a>]  Theorem
      
      ⊢ ∀x y. collinear {x; y}
   
   [<a name="COLLINEAR_3-val"><b>COLLINEAR_3</b></a>]  Theorem
      
      ⊢ ∀x y z. collinear {x; y; z} ⇔ collinear {0; x − y; z − y}
   
   [<a name="COLLINEAR_3_EXPAND-val"><b>COLLINEAR_3_EXPAND</b></a>]  Theorem
      
      ⊢ ∀a b c. collinear {a; b; c} ⇔ a = c ∨ ∃u. b = u * a + (1 − u) * c
   
   [<a name="COLLINEAR_3_TRANS-val"><b>COLLINEAR_3_TRANS</b></a>]  Theorem
      
      ⊢ ∀a b c d.
          collinear {a; b; c} ∧ collinear {b; c; d} ∧ b ≠ c ⇒
          collinear {a; b; d}
   
   [<a name="COLLINEAR_4_3-val"><b>COLLINEAR_4_3</b></a>]  Theorem
      
      ⊢ ∀a b c d.
          a ≠ b ⇒
          (collinear {a; b; c; d} ⇔
           collinear {a; b; c} ∧ collinear {a; b; d})
   
   [<a name="COLLINEAR_BETWEEN_CASES-val"><b>COLLINEAR_BETWEEN_CASES</b></a>]  Theorem
      
      ⊢ ∀a b c.
          collinear {a; b; c} ⇔
          between a (b,c) ∨ between b (c,a) ∨ between c (a,b)
   
   [<a name="COLLINEAR_DIST_BETWEEN-val"><b>COLLINEAR_DIST_BETWEEN</b></a>]  Theorem
      
      ⊢ ∀a b x.
          collinear {x; a; b} ∧ dist (x,a) ≤ dist (a,b) ∧
          dist (x,b) ≤ dist (a,b) ⇒
          between x (a,b)
   
   [<a name="COLLINEAR_DIST_IN_CLOSED_SEGMENT-val"><b>COLLINEAR_DIST_IN_CLOSED_SEGMENT</b></a>]  Theorem
      
      ⊢ ∀a b x.
          collinear {x; a; b} ∧ dist (x,a) ≤ dist (a,b) ∧
          dist (x,b) ≤ dist (a,b) ⇒
          x ∈ segment [(a,b)]
   
   [<a name="COLLINEAR_DIST_IN_OPEN_SEGMENT-val"><b>COLLINEAR_DIST_IN_OPEN_SEGMENT</b></a>]  Theorem
      
      ⊢ ∀a b x.
          collinear {x; a; b} ∧ dist (x,a) &lt; dist (a,b) ∧
          dist (x,b) &lt; dist (a,b) ⇒
          x ∈ segment (a,b)
   
   [<a name="COLLINEAR_EMPTY-val"><b>COLLINEAR_EMPTY</b></a>]  Theorem
      
      ⊢ collinear ∅
   
   [<a name="COLLINEAR_LEMMA-val"><b>COLLINEAR_LEMMA</b></a>]  Theorem
      
      ⊢ ∀x y. collinear {0; x; y} ⇔ x = 0 ∨ y = 0 ∨ ∃c. y = c * x
   
   [<a name="COLLINEAR_LEMMA_ALT-val"><b>COLLINEAR_LEMMA_ALT</b></a>]  Theorem
      
      ⊢ ∀x y. collinear {0; x; y} ⇔ x = 0 ∨ ∃c. y = c * x
   
   [<a name="COLLINEAR_MIDPOINT-val"><b>COLLINEAR_MIDPOINT</b></a>]  Theorem
      
      ⊢ ∀a b. collinear {a; midpoint (a,b); b}
   
   [<a name="COLLINEAR_SING-val"><b>COLLINEAR_SING</b></a>]  Theorem
      
      ⊢ ∀x. collinear {x}
   
   [<a name="COLLINEAR_SMALL-val"><b>COLLINEAR_SMALL</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ∧ CARD s ≤ 2 ⇒ collinear s
   
   [<a name="COLLINEAR_SUBSET-val"><b>COLLINEAR_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t. collinear t ∧ s ⊆ t ⇒ collinear s
   
   [<a name="COLLINEAR_TRIPLES-val"><b>COLLINEAR_TRIPLES</b></a>]  Theorem
      
      ⊢ ∀s a b.
          a ≠ b ⇒
          (collinear (a INSERT b INSERT s) ⇔
           ∀x. x ∈ s ⇒ collinear {a; b; x})
   
   [<a name="COMPACT_AFFINITY-val"><b>COMPACT_AFFINITY</b></a>]  Theorem
      
      ⊢ ∀s a c. compact s ⇒ compact (IMAGE (λx. a + c * x) s)
   
   [<a name="COMPACT_ATTAINS_INF-val"><b>COMPACT_ATTAINS_INF</b></a>]  Theorem
      
      ⊢ ∀s. compact s ∧ s ≠ ∅ ⇒ ∃x. x ∈ s ∧ ∀y. y ∈ s ⇒ x ≤ y
   
   [<a name="COMPACT_ATTAINS_SUP-val"><b>COMPACT_ATTAINS_SUP</b></a>]  Theorem
      
      ⊢ ∀s. compact s ∧ s ≠ ∅ ⇒ ∃x. x ∈ s ∧ ∀y. y ∈ s ⇒ y ≤ x
   
   [<a name="COMPACT_BIGINTER-val"><b>COMPACT_BIGINTER</b></a>]  Theorem
      
      ⊢ ∀f. (∀s. s ∈ f ⇒ compact s) ∧ f ≠ ∅ ⇒ compact (BIGINTER f)
   
   [<a name="COMPACT_BIGUNION-val"><b>COMPACT_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ∧ (∀t. t ∈ s ⇒ compact t) ⇒ compact (BIGUNION s)
   
   [<a name="COMPACT_CBALL-val"><b>COMPACT_CBALL</b></a>]  Theorem
      
      ⊢ ∀x e. compact (cball (x,e))
   
   [<a name="COMPACT_CHAIN-val"><b>COMPACT_CHAIN</b></a>]  Theorem
      
      ⊢ ∀f. (∀s. s ∈ f ⇒ compact s ∧ s ≠ ∅) ∧
            (∀s t. s ∈ f ∧ t ∈ f ⇒ s ⊆ t ∨ t ⊆ s) ⇒
            BIGINTER f ≠ ∅
   
   [<a name="COMPACT_CLOSED_DIFFERENCES-val"><b>COMPACT_CLOSED_DIFFERENCES</b></a>]  Theorem
      
      ⊢ ∀s t. compact s ∧ closed t ⇒ closed {x − y | x ∈ s ∧ y ∈ t}
   
   [<a name="COMPACT_CLOSED_SUMS-val"><b>COMPACT_CLOSED_SUMS</b></a>]  Theorem
      
      ⊢ ∀s t. compact s ∧ closed t ⇒ closed {x + y | x ∈ s ∧ y ∈ t}
   
   [<a name="COMPACT_CLOSURE-val"><b>COMPACT_CLOSURE</b></a>]  Theorem
      
      ⊢ ∀s. compact (closure s) ⇔ bounded s
   
   [<a name="COMPACT_COMPONENTS-val"><b>COMPACT_COMPONENTS</b></a>]  Theorem
      
      ⊢ ∀s c. compact s ∧ c ∈ components s ⇒ compact c
   
   [<a name="COMPACT_CONTINUOUS_IMAGE-val"><b>COMPACT_CONTINUOUS_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s. f continuous_on s ∧ compact s ⇒ compact (IMAGE f s)
   
   [<a name="COMPACT_CONTINUOUS_IMAGE_EQ-val"><b>COMPACT_CONTINUOUS_IMAGE_EQ</b></a>]  Theorem
      
      ⊢ ∀f s.
          (∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y) ⇒
          (f continuous_on s ⇔ ∀t. compact t ∧ t ⊆ s ⇒ compact (IMAGE f t))
   
   [<a name="COMPACT_DIFF-val"><b>COMPACT_DIFF</b></a>]  Theorem
      
      ⊢ ∀s t. compact s ∧ open t ⇒ compact (s DIFF t)
   
   [<a name="COMPACT_EMPTY-val"><b>COMPACT_EMPTY</b></a>]  Theorem
      
      ⊢ compact ∅
   
   [<a name="COMPACT_EQ_BOLZANO_WEIERSTRASS-val"><b>COMPACT_EQ_BOLZANO_WEIERSTRASS</b></a>]  Theorem
      
      ⊢ ∀s. compact s ⇔
            ∀t. INFINITE t ∧ t ⊆ s ⇒ ∃x. x ∈ s ∧ x limit_point_of t
   
   [<a name="COMPACT_EQ_BOUNDED_CLOSED-val"><b>COMPACT_EQ_BOUNDED_CLOSED</b></a>]  Theorem
      
      ⊢ ∀s. compact s ⇔ bounded s ∧ closed s
   
   [<a name="COMPACT_EQ_HEINE_BOREL-val"><b>COMPACT_EQ_HEINE_BOREL</b></a>]  Theorem
      
      ⊢ ∀s. compact s ⇔
            ∀f. (∀t. t ∈ f ⇒ open t) ∧ s ⊆ BIGUNION f ⇒
                ∃f'. f' ⊆ f ∧ FINITE f' ∧ s ⊆ BIGUNION f'
   
   [<a name="COMPACT_EQ_HEINE_BOREL_SUBTOPOLOGY-val"><b>COMPACT_EQ_HEINE_BOREL_SUBTOPOLOGY</b></a>]  Theorem
      
      ⊢ ∀s. compact s ⇔
            ∀f. (∀t. t ∈ f ⇒ open_in (subtopology euclidean s) t) ∧
                s ⊆ BIGUNION f ⇒
                ∃f'. f' ⊆ f ∧ FINITE f' ∧ s ⊆ BIGUNION f'
   
   [<a name="COMPACT_FIP-val"><b>COMPACT_FIP</b></a>]  Theorem
      
      ⊢ ∀f. (∀t. t ∈ f ⇒ compact t) ∧
            (∀f'. FINITE f' ∧ f' ⊆ f ⇒ BIGINTER f' ≠ ∅) ⇒
            BIGINTER f ≠ ∅
   
   [<a name="COMPACT_FRONTIER-val"><b>COMPACT_FRONTIER</b></a>]  Theorem
      
      ⊢ ∀s. compact s ⇒ compact (frontier s)
   
   [<a name="COMPACT_FRONTIER_BOUNDED-val"><b>COMPACT_FRONTIER_BOUNDED</b></a>]  Theorem
      
      ⊢ ∀s. bounded s ⇒ compact (frontier s)
   
   [<a name="COMPACT_IMP_BOUNDED-val"><b>COMPACT_IMP_BOUNDED</b></a>]  Theorem
      
      ⊢ ∀s. compact s ⇒ bounded s
   
   [<a name="COMPACT_IMP_CLOSED-val"><b>COMPACT_IMP_CLOSED</b></a>]  Theorem
      
      ⊢ ∀s. compact s ⇒ closed s
   
   [<a name="COMPACT_IMP_COMPLETE-val"><b>COMPACT_IMP_COMPLETE</b></a>]  Theorem
      
      ⊢ ∀s. compact s ⇒ complete s
   
   [<a name="COMPACT_IMP_FIP-val"><b>COMPACT_IMP_FIP</b></a>]  Theorem
      
      ⊢ ∀s f.
          compact s ∧ (∀t. t ∈ f ⇒ closed t) ∧
          (∀f'. FINITE f' ∧ f' ⊆ f ⇒ s ∩ BIGINTER f' ≠ ∅) ⇒
          s ∩ BIGINTER f ≠ ∅
   
   [<a name="COMPACT_IMP_HEINE_BOREL-val"><b>COMPACT_IMP_HEINE_BOREL</b></a>]  Theorem
      
      ⊢ ∀s. compact s ⇒
            ∀f. (∀t. t ∈ f ⇒ open t) ∧ s ⊆ BIGUNION f ⇒
                ∃f'. f' ⊆ f ∧ FINITE f' ∧ s ⊆ BIGUNION f'
   
   [<a name="COMPACT_IMP_TOTALLY_BOUNDED-val"><b>COMPACT_IMP_TOTALLY_BOUNDED</b></a>]  Theorem
      
      ⊢ ∀s. compact s ⇒
            ∀e. 0 &lt; e ⇒
                ∃k. FINITE k ∧ k ⊆ s ∧
                    s ⊆ BIGUNION (IMAGE (λx. ball (x,e)) k)
   
   [<a name="COMPACT_INSERT-val"><b>COMPACT_INSERT</b></a>]  Theorem
      
      ⊢ ∀a s. compact s ⇒ compact (a INSERT s)
   
   [<a name="COMPACT_INTER-val"><b>COMPACT_INTER</b></a>]  Theorem
      
      ⊢ ∀s t. compact s ∧ compact t ⇒ compact (s ∩ t)
   
   [<a name="COMPACT_INTERVAL-val"><b>COMPACT_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀a b. compact (interval [(a,b)])
   
   [<a name="COMPACT_INTERVAL_EQ-val"><b>COMPACT_INTERVAL_EQ</b></a>]  Theorem
      
      ⊢ (∀a b. compact (interval [(a,b)])) ∧
        ∀a b. compact (interval (a,b)) ⇔ interval (a,b) = ∅
   
   [<a name="COMPACT_INTER_CLOSED-val"><b>COMPACT_INTER_CLOSED</b></a>]  Theorem
      
      ⊢ ∀s t. compact s ∧ closed t ⇒ compact (s ∩ t)
   
   [<a name="COMPACT_LEMMA-val"><b>COMPACT_LEMMA</b></a>]  Theorem
      
      ⊢ ∀s. bounded s ∧ (∀n. x n ∈ s) ⇒
            ∃l r.
              (∀m n. m &lt; n ⇒ r m &lt; r n) ∧
              ∀e. 0 &lt; e ⇒ ∃N. ∀n i. N ≤ n ⇒ abs (x (r n) − l) &lt; e
   
   [<a name="COMPACT_LINEAR_IMAGE-val"><b>COMPACT_LINEAR_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s. compact s ∧ linear f ⇒ compact (IMAGE f s)
   
   [<a name="COMPACT_NEGATIONS-val"><b>COMPACT_NEGATIONS</b></a>]  Theorem
      
      ⊢ ∀s. compact s ⇒ compact (IMAGE (λx. -x) s)
   
   [<a name="COMPACT_NEST-val"><b>COMPACT_NEST</b></a>]  Theorem
      
      ⊢ ∀s. (∀n. compact (s n) ∧ s n ≠ ∅) ∧ (∀m n. m ≤ n ⇒ s n ⊆ s m) ⇒
            BIGINTER {s n | n ∈ 𝕌(:num)} ≠ ∅
   
   [<a name="COMPACT_REAL_LEMMA-val"><b>COMPACT_REAL_LEMMA</b></a>]  Theorem
      
      ⊢ ∀s b.
          (∀n. abs (s n) ≤ b) ⇒
          ∃l r.
            (∀m n. m &lt; n ⇒ r m &lt; r n) ∧
            ∀e. 0 &lt; e ⇒ ∃N. ∀n. N ≤ n ⇒ abs (s (r n) − l) &lt; e
   
   [<a name="COMPACT_SCALING-val"><b>COMPACT_SCALING</b></a>]  Theorem
      
      ⊢ ∀s c. compact s ⇒ compact (IMAGE (λx. c * x) s)
   
   [<a name="COMPACT_SEQUENCE_WITH_LIMIT-val"><b>COMPACT_SEQUENCE_WITH_LIMIT</b></a>]  Theorem
      
      ⊢ ∀f l. (f ⟶ l) sequentially ⇒ compact (l INSERT IMAGE f 𝕌(:num))
   
   [<a name="COMPACT_SING-val"><b>COMPACT_SING</b></a>]  Theorem
      
      ⊢ ∀a. compact {a}
   
   [<a name="COMPACT_SPHERE-val"><b>COMPACT_SPHERE</b></a>]  Theorem
      
      ⊢ ∀a r. compact (sphere (a,r))
   
   [<a name="COMPACT_TRANSLATION-val"><b>COMPACT_TRANSLATION</b></a>]  Theorem
      
      ⊢ ∀s a. compact s ⇒ compact (IMAGE (λx. a + x) s)
   
   [<a name="COMPACT_TRANSLATION_EQ-val"><b>COMPACT_TRANSLATION_EQ</b></a>]  Theorem
      
      ⊢ ∀a s. compact (IMAGE (λx. a + x) s) ⇔ compact s
   
   [<a name="COMPACT_UNIFORMLY_CONTINUOUS-val"><b>COMPACT_UNIFORMLY_CONTINUOUS</b></a>]  Theorem
      
      ⊢ ∀f s. f continuous_on s ∧ compact s ⇒ f uniformly_continuous_on s
   
   [<a name="COMPACT_UNIFORMLY_EQUICONTINUOUS-val"><b>COMPACT_UNIFORMLY_EQUICONTINUOUS</b></a>]  Theorem
      
      ⊢ ∀fs s.
          (∀x e.
             x ∈ s ∧ 0 &lt; e ⇒
             ∃d. 0 &lt; d ∧
                 ∀f x'.
                   f ∈ fs ∧ x' ∈ s ∧ dist (x',x) &lt; d ⇒ dist (f x',f x) &lt; e) ∧
          compact s ⇒
          ∀e. 0 &lt; e ⇒
              ∃d. 0 &lt; d ∧
                  ∀f x x'.
                    f ∈ fs ∧ x ∈ s ∧ x' ∈ s ∧ dist (x',x) &lt; d ⇒
                    dist (f x',f x) &lt; e
   
   [<a name="COMPACT_UNION-val"><b>COMPACT_UNION</b></a>]  Theorem
      
      ⊢ ∀s t. compact s ∧ compact t ⇒ compact (s ∪ t)
   
   [<a name="COMPLEMENT_CONNECTED_COMPONENT_BIGUNION-val"><b>COMPLEMENT_CONNECTED_COMPONENT_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀s x.
          s DIFF connected_component s x =
          BIGUNION
            ({connected_component s y | y | y ∈ s} DELETE
             connected_component s x)
   
   [<a name="COMPLETE_EQ_CLOSED-val"><b>COMPLETE_EQ_CLOSED</b></a>]  Theorem
      
      ⊢ ∀s. complete s ⇔ closed s
   
   [<a name="COMPLETE_INJECTIVE_LINEAR_IMAGE-val"><b>COMPLETE_INJECTIVE_LINEAR_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f. linear f ∧ (∀x y. f x = f y ⇒ x = y) ⇒
            ∀s. complete s ⇒ complete (IMAGE f s)
   
   [<a name="COMPLETE_INJECTIVE_LINEAR_IMAGE_EQ-val"><b>COMPLETE_INJECTIVE_LINEAR_IMAGE_EQ</b></a>]  Theorem
      
      ⊢ ∀f s.
          linear f ∧ (∀x y. f x = f y ⇒ x = y) ⇒
          (complete (IMAGE f s) ⇔ complete s)
   
   [<a name="COMPLETE_ISOMETRIC_IMAGE-val"><b>COMPLETE_ISOMETRIC_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s e.
          0 &lt; e ∧ subspace s ∧ linear f ∧
          (∀x. x ∈ s ⇒ abs (f x) ≥ e * abs x) ∧ complete s ⇒
          complete (IMAGE f s)
   
   [<a name="COMPLETE_UNIV-val"><b>COMPLETE_UNIV</b></a>]  Theorem
      
      ⊢ complete 𝕌(:real)
   
   [<a name="COMPONENTS_EMPTY-val"><b>COMPONENTS_EMPTY</b></a>]  Theorem
      
      ⊢ components ∅ = ∅
   
   [<a name="COMPONENTS_EQ-val"><b>COMPONENTS_EQ</b></a>]  Theorem
      
      ⊢ ∀s c c'.
          c ∈ components s ∧ c' ∈ components s ⇒ (c = c' ⇔ c ∩ c' ≠ ∅)
   
   [<a name="COMPONENTS_EQ_EMPTY-val"><b>COMPONENTS_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ ∀s. components s = ∅ ⇔ s = ∅
   
   [<a name="COMPONENTS_EQ_SING-val"><b>COMPONENTS_EQ_SING</b></a>]  Theorem
      
      ⊢ ∀s. components s = {s} ⇔ connected s ∧ s ≠ ∅
   
   [<a name="COMPONENTS_EQ_SING_EXISTS-val"><b>COMPONENTS_EQ_SING_EXISTS</b></a>]  Theorem
      
      ⊢ ∀s. (∃a. components s = {a}) ⇔ connected s ∧ s ≠ ∅
   
   [<a name="COMPONENTS_EQ_SING_N_EXISTS-val"><b>COMPONENTS_EQ_SING_N_EXISTS</b></a>]  Theorem
      
      ⊢ (∀s. components s = {s} ⇔ connected s ∧ s ≠ ∅) ∧
        ∀s. (∃a. components s = {a}) ⇔ connected s ∧ s ≠ ∅
   
   [<a name="COMPONENTS_INTERMEDIATE_SUBSET-val"><b>COMPONENTS_INTERMEDIATE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t u. s ∈ components u ∧ s ⊆ t ∧ t ⊆ u ⇒ s ∈ components t
   
   [<a name="COMPONENTS_MAXIMAL-val"><b>COMPONENTS_MAXIMAL</b></a>]  Theorem
      
      ⊢ ∀s t c. c ∈ components s ∧ connected t ∧ t ⊆ s ∧ c ∩ t ≠ ∅ ⇒ t ⊆ c
   
   [<a name="COMPONENTS_NONOVERLAP-val"><b>COMPONENTS_NONOVERLAP</b></a>]  Theorem
      
      ⊢ ∀s c c'.
          c ∈ components s ∧ c' ∈ components s ⇒ (c ∩ c' = ∅ ⇔ c ≠ c')
   
   [<a name="COMPONENTS_UNIQUE-val"><b>COMPONENTS_UNIQUE</b></a>]  Theorem
      
      ⊢ ∀s k.
          BIGUNION k = s ∧
          (∀c. c ∈ k ⇒
               connected c ∧ c ≠ ∅ ∧
               ∀c'. connected c' ∧ c ⊆ c' ∧ c' ⊆ s ⇒ c' = c) ⇒
          components s = k
   
   [<a name="COMPONENTS_UNIQUE_EQ-val"><b>COMPONENTS_UNIQUE_EQ</b></a>]  Theorem
      
      ⊢ ∀s k.
          components s = k ⇔
          BIGUNION k = s ∧
          ∀c. c ∈ k ⇒
              connected c ∧ c ≠ ∅ ∧
              ∀c'. connected c' ∧ c ⊆ c' ∧ c' ⊆ s ⇒ c' = c
   
   [<a name="COMPONENTS_UNIV-val"><b>COMPONENTS_UNIV</b></a>]  Theorem
      
      ⊢ components 𝕌(:real) = {𝕌(:real)}
   
   [<a name="CONDENSATION_POINT_IMP_LIMPT-val"><b>CONDENSATION_POINT_IMP_LIMPT</b></a>]  Theorem
      
      ⊢ ∀x s. x condensation_point_of s ⇒ x limit_point_of s
   
   [<a name="CONDENSATION_POINT_INFINITE_BALL-val"><b>CONDENSATION_POINT_INFINITE_BALL</b></a>]  Theorem
      
      ⊢ ∀s x.
          x condensation_point_of s ⇔
          ∀e. 0 &lt; e ⇒ uncountable (s ∩ ball (x,e))
   
   [<a name="CONDENSATION_POINT_INFINITE_BALL_CBALL-val"><b>CONDENSATION_POINT_INFINITE_BALL_CBALL</b></a>]  Theorem
      
      ⊢ (∀s x.
           x condensation_point_of s ⇔
           ∀e. 0 &lt; e ⇒ uncountable (s ∩ ball (x,e))) ∧
        ∀s x.
          x condensation_point_of s ⇔
          ∀e. 0 &lt; e ⇒ uncountable (s ∩ cball (x,e))
   
   [<a name="CONDENSATION_POINT_INFINITE_CBALL-val"><b>CONDENSATION_POINT_INFINITE_CBALL</b></a>]  Theorem
      
      ⊢ ∀s x.
          x condensation_point_of s ⇔
          ∀e. 0 &lt; e ⇒ uncountable (s ∩ cball (x,e))
   
   [<a name="CONDENSATION_POINT_OF_SUBSET-val"><b>CONDENSATION_POINT_OF_SUBSET</b></a>]  Theorem
      
      ⊢ ∀x s t.
          x condensation_point_of s ∧ s ⊆ t ⇒ x condensation_point_of t
   
   [<a name="CONNECTED_BIGUNION-val"><b>CONNECTED_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀P. (∀s. s ∈ P ⇒ connected s) ∧ BIGINTER P ≠ ∅ ⇒
            connected (BIGUNION P)
   
   [<a name="CONNECTED_CHAIN-val"><b>CONNECTED_CHAIN</b></a>]  Theorem
      
      ⊢ ∀f. (∀s. s ∈ f ⇒ compact s ∧ connected s) ∧
            (∀s t. s ∈ f ∧ t ∈ f ⇒ s ⊆ t ∨ t ⊆ s) ⇒
            connected (BIGINTER f)
   
   [<a name="CONNECTED_CHAIN_GEN-val"><b>CONNECTED_CHAIN_GEN</b></a>]  Theorem
      
      ⊢ ∀f. (∀s. s ∈ f ⇒ closed s ∧ connected s) ∧
            (∃s. s ∈ f ∧ compact s) ∧ (∀s t. s ∈ f ∧ t ∈ f ⇒ s ⊆ t ∨ t ⊆ s) ⇒
            connected (BIGINTER f)
   
   [<a name="CONNECTED_CLOPEN-val"><b>CONNECTED_CLOPEN</b></a>]  Theorem
      
      ⊢ ∀s. connected s ⇔
            ∀t. open_in (subtopology euclidean s) t ∧
                closed_in (subtopology euclidean s) t ⇒
                t = ∅ ∨ t = s
   
   [<a name="CONNECTED_CLOSED-val"><b>CONNECTED_CLOSED</b></a>]  Theorem
      
      ⊢ ∀s. connected s ⇔
            ¬∃e1 e2.
              closed e1 ∧ closed e2 ∧ s ⊆ e1 ∪ e2 ∧ e1 ∩ e2 ∩ s = ∅ ∧
              e1 ∩ s ≠ ∅ ∧ e2 ∩ s ≠ ∅
   
   [<a name="CONNECTED_CLOSED_IN-val"><b>CONNECTED_CLOSED_IN</b></a>]  Theorem
      
      ⊢ ∀s. connected s ⇔
            ¬∃e1 e2.
              closed_in (subtopology euclidean s) e1 ∧
              closed_in (subtopology euclidean s) e2 ∧ s ⊆ e1 ∪ e2 ∧
              e1 ∩ e2 = ∅ ∧ e1 ≠ ∅ ∧ e2 ≠ ∅
   
   [<a name="CONNECTED_CLOSED_IN_EQ-val"><b>CONNECTED_CLOSED_IN_EQ</b></a>]  Theorem
      
      ⊢ ∀s. connected s ⇔
            ¬∃e1 e2.
              closed_in (subtopology euclidean s) e1 ∧
              closed_in (subtopology euclidean s) e2 ∧ e1 ∪ e2 = s ∧
              e1 ∩ e2 = ∅ ∧ e1 ≠ ∅ ∧ e2 ≠ ∅
   
   [<a name="CONNECTED_CLOSED_MONOTONE_PREIMAGE-val"><b>CONNECTED_CLOSED_MONOTONE_PREIMAGE</b></a>]  Theorem
      
      ⊢ ∀f s t.
          f continuous_on s ∧ IMAGE f s = t ∧
          (∀c. closed_in (subtopology euclidean s) c ⇒
               closed_in (subtopology euclidean t) (IMAGE f c)) ∧
          (∀y. y ∈ t ⇒ connected {x | x ∈ s ∧ f x = y}) ⇒
          ∀c. connected c ∧ c ⊆ t ⇒ connected {x | x ∈ s ∧ f x ∈ c}
   
   [<a name="CONNECTED_CLOSED_SET-val"><b>CONNECTED_CLOSED_SET</b></a>]  Theorem
      
      ⊢ ∀s. closed s ⇒
            (connected s ⇔
             ¬∃e1 e2.
               closed e1 ∧ closed e2 ∧ e1 ≠ ∅ ∧ e2 ≠ ∅ ∧ e1 ∪ e2 = s ∧
               e1 ∩ e2 = ∅)
   
   [<a name="CONNECTED_CLOSURE-val"><b>CONNECTED_CLOSURE</b></a>]  Theorem
      
      ⊢ ∀s. connected s ⇒ connected (closure s)
   
   [<a name="CONNECTED_COMPONENT_BIGUNION-val"><b>CONNECTED_COMPONENT_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀s x.
          connected_component s x =
          BIGUNION {t | connected t ∧ x ∈ t ∧ t ⊆ s}
   
   [<a name="CONNECTED_COMPONENT_DISJOINT-val"><b>CONNECTED_COMPONENT_DISJOINT</b></a>]  Theorem
      
      ⊢ ∀s a b.
          DISJOINT (connected_component s a) (connected_component s b) ⇔
          a ∉ connected_component s b
   
   [<a name="CONNECTED_COMPONENT_EMPTY-val"><b>CONNECTED_COMPONENT_EMPTY</b></a>]  Theorem
      
      ⊢ ∀x. connected_component ∅ x = ∅
   
   [<a name="CONNECTED_COMPONENT_EQ-val"><b>CONNECTED_COMPONENT_EQ</b></a>]  Theorem
      
      ⊢ ∀s x y.
          y ∈ connected_component s x ⇒
          connected_component s y = connected_component s x
   
   [<a name="CONNECTED_COMPONENT_EQUIVALENCE_RELATION-val"><b>CONNECTED_COMPONENT_EQUIVALENCE_RELATION</b></a>]  Theorem
      
      ⊢ ∀R s.
          (∀x y. R x y ⇒ R y x) ∧ (∀x y z. R x y ∧ R y z ⇒ R x z) ∧
          (∀a. a ∈ s ⇒
               ∃t. open_in (subtopology euclidean s) t ∧ a ∈ t ∧
                   ∀x. x ∈ t ⇒ R a x) ⇒
          ∀a b. connected_component s a b ⇒ R a b
   
   [<a name="CONNECTED_COMPONENT_EQ_EMPTY-val"><b>CONNECTED_COMPONENT_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ ∀s x. connected_component s x = ∅ ⇔ x ∉ s
   
   [<a name="CONNECTED_COMPONENT_EQ_EQ-val"><b>CONNECTED_COMPONENT_EQ_EQ</b></a>]  Theorem
      
      ⊢ ∀s x y.
          connected_component s x = connected_component s y ⇔
          x ∉ s ∧ y ∉ s ∨ x ∈ s ∧ y ∈ s ∧ connected_component s x y
   
   [<a name="CONNECTED_COMPONENT_EQ_SELF-val"><b>CONNECTED_COMPONENT_EQ_SELF</b></a>]  Theorem
      
      ⊢ ∀s x. connected s ∧ x ∈ s ⇒ connected_component s x = s
   
   [<a name="CONNECTED_COMPONENT_EQ_UNIV-val"><b>CONNECTED_COMPONENT_EQ_UNIV</b></a>]  Theorem
      
      ⊢ ∀s x. connected_component s x = 𝕌(:real) ⇔ s = 𝕌(:real)
   
   [<a name="CONNECTED_COMPONENT_IDEMP-val"><b>CONNECTED_COMPONENT_IDEMP</b></a>]  Theorem
      
      ⊢ ∀s x.
          connected_component (connected_component s x) x =
          connected_component s x
   
   [<a name="CONNECTED_COMPONENT_IN-val"><b>CONNECTED_COMPONENT_IN</b></a>]  Theorem
      
      ⊢ ∀s x y. connected_component s x y ⇒ x ∈ s ∧ y ∈ s
   
   [<a name="CONNECTED_COMPONENT_INTERMEDIATE_SUBSET-val"><b>CONNECTED_COMPONENT_INTERMEDIATE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀t u a.
          connected_component u a ⊆ t ∧ t ⊆ u ⇒
          connected_component t a = connected_component u a
   
   [<a name="CONNECTED_COMPONENT_MAXIMAL-val"><b>CONNECTED_COMPONENT_MAXIMAL</b></a>]  Theorem
      
      ⊢ ∀s t x. x ∈ t ∧ connected t ∧ t ⊆ s ⇒ t ⊆ connected_component s x
   
   [<a name="CONNECTED_COMPONENT_MONO-val"><b>CONNECTED_COMPONENT_MONO</b></a>]  Theorem
      
      ⊢ ∀s t x. s ⊆ t ⇒ connected_component s x ⊆ connected_component t x
   
   [<a name="CONNECTED_COMPONENT_NONOVERLAP-val"><b>CONNECTED_COMPONENT_NONOVERLAP</b></a>]  Theorem
      
      ⊢ ∀s a b.
          connected_component s a ∩ connected_component s b = ∅ ⇔
          a ∉ s ∨ b ∉ s ∨ connected_component s a ≠ connected_component s b
   
   [<a name="CONNECTED_COMPONENT_OF_SUBSET-val"><b>CONNECTED_COMPONENT_OF_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t x.
          s ⊆ t ∧ connected_component s x y ⇒ connected_component t x y
   
   [<a name="CONNECTED_COMPONENT_OVERLAP-val"><b>CONNECTED_COMPONENT_OVERLAP</b></a>]  Theorem
      
      ⊢ ∀s a b.
          connected_component s a ∩ connected_component s b ≠ ∅ ⇔
          a ∈ s ∧ b ∈ s ∧ connected_component s a = connected_component s b
   
   [<a name="CONNECTED_COMPONENT_REFL-val"><b>CONNECTED_COMPONENT_REFL</b></a>]  Theorem
      
      ⊢ ∀s x. x ∈ s ⇒ connected_component s x x
   
   [<a name="CONNECTED_COMPONENT_REFL_EQ-val"><b>CONNECTED_COMPONENT_REFL_EQ</b></a>]  Theorem
      
      ⊢ ∀s x. connected_component s x x ⇔ x ∈ s
   
   [<a name="CONNECTED_COMPONENT_SET-val"><b>CONNECTED_COMPONENT_SET</b></a>]  Theorem
      
      ⊢ ∀s x.
          connected_component s x =
          {y | ∃t. connected t ∧ t ⊆ s ∧ x ∈ t ∧ y ∈ t}
   
   [<a name="CONNECTED_COMPONENT_SUBSET-val"><b>CONNECTED_COMPONENT_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s x. connected_component s x ⊆ s
   
   [<a name="CONNECTED_COMPONENT_SYM-val"><b>CONNECTED_COMPONENT_SYM</b></a>]  Theorem
      
      ⊢ ∀s x y. connected_component s x y ⇒ connected_component s y x
   
   [<a name="CONNECTED_COMPONENT_SYM_EQ-val"><b>CONNECTED_COMPONENT_SYM_EQ</b></a>]  Theorem
      
      ⊢ ∀s x y. connected_component s x y ⇔ connected_component s y x
   
   [<a name="CONNECTED_COMPONENT_TRANS-val"><b>CONNECTED_COMPONENT_TRANS</b></a>]  Theorem
      
      ⊢ ∀s x y.
          connected_component s x y ∧ connected_component s y z ⇒
          connected_component s x z
   
   [<a name="CONNECTED_COMPONENT_UNIQUE-val"><b>CONNECTED_COMPONENT_UNIQUE</b></a>]  Theorem
      
      ⊢ ∀s c x.
          x ∈ c ∧ c ⊆ s ∧ connected c ∧
          (∀c'. x ∈ c' ∧ c' ⊆ s ∧ connected c' ⇒ c' ⊆ c) ⇒
          connected_component s x = c
   
   [<a name="CONNECTED_COMPONENT_UNIV-val"><b>CONNECTED_COMPONENT_UNIV</b></a>]  Theorem
      
      ⊢ ∀x. connected_component 𝕌(:real) x = 𝕌(:real)
   
   [<a name="CONNECTED_CONNECTED_COMPONENT-val"><b>CONNECTED_CONNECTED_COMPONENT</b></a>]  Theorem
      
      ⊢ ∀s x. connected (connected_component s x)
   
   [<a name="CONNECTED_CONNECTED_COMPONENT_SET-val"><b>CONNECTED_CONNECTED_COMPONENT_SET</b></a>]  Theorem
      
      ⊢ ∀s. connected s ⇔ ∀x. x ∈ s ⇒ connected_component s x = s
   
   [<a name="CONNECTED_CONTINUOUS_IMAGE-val"><b>CONNECTED_CONTINUOUS_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s. f continuous_on s ∧ connected s ⇒ connected (IMAGE f s)
   
   [<a name="CONNECTED_DIFF_OPEN_FROM_CLOSED-val"><b>CONNECTED_DIFF_OPEN_FROM_CLOSED</b></a>]  Theorem
      
      ⊢ ∀s t u.
          s ⊆ t ∧ t ⊆ u ∧ open s ∧ closed t ∧ connected u ∧
          connected (t DIFF s) ⇒
          connected (u DIFF s)
   
   [<a name="CONNECTED_DISJOINT_BIGUNION_OPEN_UNIQUE-val"><b>CONNECTED_DISJOINT_BIGUNION_OPEN_UNIQUE</b></a>]  Theorem
      
      ⊢ ∀f f'.
          pairwiseD DISJOINT f ∧ pairwiseD DISJOINT f' ∧
          (∀s. s ∈ f ⇒ open s ∧ connected s ∧ s ≠ ∅) ∧
          (∀s. s ∈ f' ⇒ open s ∧ connected s ∧ s ≠ ∅) ∧
          BIGUNION f = BIGUNION f' ⇒
          f = f'
   
   [<a name="CONNECTED_EMPTY-val"><b>CONNECTED_EMPTY</b></a>]  Theorem
      
      ⊢ connected ∅
   
   [<a name="CONNECTED_EQUIVALENCE_RELATION-val"><b>CONNECTED_EQUIVALENCE_RELATION</b></a>]  Theorem
      
      ⊢ ∀R s.
          connected s ∧ (∀x y. R x y ⇒ R y x) ∧
          (∀x y z. R x y ∧ R y z ⇒ R x z) ∧
          (∀a. a ∈ s ⇒
               ∃t. open_in (subtopology euclidean s) t ∧ a ∈ t ∧
                   ∀x. x ∈ t ⇒ R a x) ⇒
          ∀a b. a ∈ s ∧ b ∈ s ⇒ R a b
   
   [<a name="CONNECTED_EQUIVALENCE_RELATION_GEN-val"><b>CONNECTED_EQUIVALENCE_RELATION_GEN</b></a>]  Theorem
      
      ⊢ ∀P R s.
          connected s ∧ (∀x y. R x y ⇒ R y x) ∧
          (∀x y z. R x y ∧ R y z ⇒ R x z) ∧
          (∀t a.
             open_in (subtopology euclidean s) t ∧ a ∈ t ⇒ ∃z. z ∈ t ∧ P z) ∧
          (∀a. a ∈ s ⇒
               ∃t. open_in (subtopology euclidean s) t ∧ a ∈ t ∧
                   ∀x y. x ∈ t ∧ y ∈ t ∧ P x ∧ P y ⇒ R x y) ⇒
          ∀a b. a ∈ s ∧ b ∈ s ∧ P a ∧ P b ⇒ R a b
   
   [<a name="CONNECTED_EQ_COMPONENTS_SUBSET_SING-val"><b>CONNECTED_EQ_COMPONENTS_SUBSET_SING</b></a>]  Theorem
      
      ⊢ ∀s. connected s ⇔ components s ⊆ {s}
   
   [<a name="CONNECTED_EQ_COMPONENTS_SUBSET_SING_EXISTS-val"><b>CONNECTED_EQ_COMPONENTS_SUBSET_SING_EXISTS</b></a>]  Theorem
      
      ⊢ ∀s. connected s ⇔ ∃a. components s ⊆ {a}
   
   [<a name="CONNECTED_EQ_CONNECTED_COMPONENTS_EQ-val"><b>CONNECTED_EQ_CONNECTED_COMPONENTS_EQ</b></a>]  Theorem
      
      ⊢ ∀s. connected s ⇔
            ∀c c'. c ∈ components s ∧ c' ∈ components s ⇒ c = c'
   
   [<a name="CONNECTED_EQ_CONNECTED_COMPONENT_EQ-val"><b>CONNECTED_EQ_CONNECTED_COMPONENT_EQ</b></a>]  Theorem
      
      ⊢ ∀s. connected s ⇔
            ∀x y.
              x ∈ s ∧ y ∈ s ⇒
              connected_component s x = connected_component s y
   
   [<a name="CONNECTED_FROM_CLOSED_UNION_AND_INTER-val"><b>CONNECTED_FROM_CLOSED_UNION_AND_INTER</b></a>]  Theorem
      
      ⊢ ∀s t.
          closed s ∧ closed t ∧ connected (s ∪ t) ∧ connected (s ∩ t) ⇒
          connected s ∧ connected t
   
   [<a name="CONNECTED_FROM_OPEN_UNION_AND_INTER-val"><b>CONNECTED_FROM_OPEN_UNION_AND_INTER</b></a>]  Theorem
      
      ⊢ ∀s t.
          open s ∧ open t ∧ connected (s ∪ t) ∧ connected (s ∩ t) ⇒
          connected s ∧ connected t
   
   [<a name="CONNECTED_IFF_CONNECTABLE_POINTS-val"><b>CONNECTED_IFF_CONNECTABLE_POINTS</b></a>]  Theorem
      
      ⊢ ∀s. connected s ⇔
            ∀a b. a ∈ s ∧ b ∈ s ⇒ ∃t. connected t ∧ t ⊆ s ∧ a ∈ t ∧ b ∈ t
   
   [<a name="CONNECTED_IFF_CONNECTED_COMPONENT-val"><b>CONNECTED_IFF_CONNECTED_COMPONENT</b></a>]  Theorem
      
      ⊢ ∀s. connected s ⇔ ∀x y. x ∈ s ∧ y ∈ s ⇒ connected_component s x y
   
   [<a name="CONNECTED_IMP_PERFECT-val"><b>CONNECTED_IMP_PERFECT</b></a>]  Theorem
      
      ⊢ ∀s x. connected s ∧ ¬(∃a. s = {a}) ∧ x ∈ s ⇒ x limit_point_of s
   
   [<a name="CONNECTED_IMP_PERFECT_CLOSED-val"><b>CONNECTED_IMP_PERFECT_CLOSED</b></a>]  Theorem
      
      ⊢ ∀s x.
          connected s ∧ closed s ∧ ¬(∃a. s = {a}) ⇒
          (x limit_point_of s ⇔ x ∈ s)
   
   [<a name="CONNECTED_INDUCTION-val"><b>CONNECTED_INDUCTION</b></a>]  Theorem
      
      ⊢ ∀P Q s.
          connected s ∧
          (∀t a.
             open_in (subtopology euclidean s) t ∧ a ∈ t ⇒ ∃z. z ∈ t ∧ P z) ∧
          (∀a. a ∈ s ⇒
               ∃t. open_in (subtopology euclidean s) t ∧ a ∈ t ∧
                   ∀x y. x ∈ t ∧ y ∈ t ∧ P x ∧ P y ∧ Q x ⇒ Q y) ⇒
          ∀a b. a ∈ s ∧ b ∈ s ∧ P a ∧ P b ∧ Q a ⇒ Q b
   
   [<a name="CONNECTED_INDUCTION_SIMPLE-val"><b>CONNECTED_INDUCTION_SIMPLE</b></a>]  Theorem
      
      ⊢ ∀P s.
          connected s ∧
          (∀a. a ∈ s ⇒
               ∃t. open_in (subtopology euclidean s) t ∧ a ∈ t ∧
                   ∀x y. x ∈ t ∧ y ∈ t ∧ P x ⇒ P y) ⇒
          ∀a b. a ∈ s ∧ b ∈ s ∧ P a ⇒ P b
   
   [<a name="CONNECTED_INTERMEDIATE_CLOSURE-val"><b>CONNECTED_INTERMEDIATE_CLOSURE</b></a>]  Theorem
      
      ⊢ ∀s t. connected s ∧ s ⊆ t ∧ t ⊆ closure s ⇒ connected t
   
   [<a name="CONNECTED_INTER_FRONTIER-val"><b>CONNECTED_INTER_FRONTIER</b></a>]  Theorem
      
      ⊢ ∀s t. connected s ∧ s ∩ t ≠ ∅ ∧ s DIFF t ≠ ∅ ⇒ s ∩ frontier t ≠ ∅
   
   [<a name="CONNECTED_IVT_COMPONENT-val"><b>CONNECTED_IVT_COMPONENT</b></a>]  Theorem
      
      ⊢ ∀s x y a.
          connected s ∧ x ∈ s ∧ y ∈ s ∧ x ≤ a ∧ a ≤ y ⇒ ∃z. z ∈ s ∧ z = a
   
   [<a name="CONNECTED_IVT_HYPERPLANE-val"><b>CONNECTED_IVT_HYPERPLANE</b></a>]  Theorem
      
      ⊢ ∀s x y a b.
          connected s ∧ x ∈ s ∧ y ∈ s ∧ a * x ≤ b ∧ b ≤ a * y ⇒
          ∃z. z ∈ s ∧ a * z = b
   
   [<a name="CONNECTED_LINEAR_IMAGE-val"><b>CONNECTED_LINEAR_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s. connected s ∧ linear f ⇒ connected (IMAGE f s)
   
   [<a name="CONNECTED_MONOTONE_QUOTIENT_PREIMAGE-val"><b>CONNECTED_MONOTONE_QUOTIENT_PREIMAGE</b></a>]  Theorem
      
      ⊢ ∀f s t.
          f continuous_on s ∧ IMAGE f s = t ∧
          (∀u. u ⊆ t ⇒
               (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇔
                open_in (subtopology euclidean t) u)) ∧
          (∀y. y ∈ t ⇒ connected {x | x ∈ s ∧ f x = y}) ∧ connected t ⇒
          connected s
   
   [<a name="CONNECTED_MONOTONE_QUOTIENT_PREIMAGE_GEN-val"><b>CONNECTED_MONOTONE_QUOTIENT_PREIMAGE_GEN</b></a>]  Theorem
      
      ⊢ ∀f s t c.
          IMAGE f s = t ∧
          (∀u. u ⊆ t ⇒
               (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇔
                open_in (subtopology euclidean t) u)) ∧
          (∀y. y ∈ t ⇒ connected {x | x ∈ s ∧ f x = y}) ∧
          (open_in (subtopology euclidean t) c ∨
           closed_in (subtopology euclidean t) c) ∧ connected c ⇒
          connected {x | x ∈ s ∧ f x ∈ c}
   
   [<a name="CONNECTED_NEGATIONS-val"><b>CONNECTED_NEGATIONS</b></a>]  Theorem
      
      ⊢ ∀s. connected s ⇒ connected (IMAGE (λx. -x) s)
   
   [<a name="CONNECTED_NEST-val"><b>CONNECTED_NEST</b></a>]  Theorem
      
      ⊢ ∀s. (∀n. compact (s n) ∧ connected (s n)) ∧
            (∀m n. m ≤ n ⇒ s n ⊆ s m) ⇒
            connected (BIGINTER {s n | n ∈ 𝕌(:num)})
   
   [<a name="CONNECTED_NEST_GEN-val"><b>CONNECTED_NEST_GEN</b></a>]  Theorem
      
      ⊢ ∀s. (∀n. closed (s n) ∧ connected (s n)) ∧ (∃n. compact (s n)) ∧
            (∀m n. m ≤ n ⇒ s n ⊆ s m) ⇒
            connected (BIGINTER {s n | n ∈ 𝕌(:num)})
   
   [<a name="CONNECTED_OPEN_IN-val"><b>CONNECTED_OPEN_IN</b></a>]  Theorem
      
      ⊢ ∀s. connected s ⇔
            ¬∃e1 e2.
              open_in (subtopology euclidean s) e1 ∧
              open_in (subtopology euclidean s) e2 ∧ s ⊆ e1 ∪ e2 ∧
              e1 ∩ e2 = ∅ ∧ e1 ≠ ∅ ∧ e2 ≠ ∅
   
   [<a name="CONNECTED_OPEN_IN_EQ-val"><b>CONNECTED_OPEN_IN_EQ</b></a>]  Theorem
      
      ⊢ ∀s. connected s ⇔
            ¬∃e1 e2.
              open_in (subtopology euclidean s) e1 ∧
              open_in (subtopology euclidean s) e2 ∧ e1 ∪ e2 = s ∧
              e1 ∩ e2 = ∅ ∧ e1 ≠ ∅ ∧ e2 ≠ ∅
   
   [<a name="CONNECTED_OPEN_MONOTONE_PREIMAGE-val"><b>CONNECTED_OPEN_MONOTONE_PREIMAGE</b></a>]  Theorem
      
      ⊢ ∀f s t.
          f continuous_on s ∧ IMAGE f s = t ∧
          (∀c. open_in (subtopology euclidean s) c ⇒
               open_in (subtopology euclidean t) (IMAGE f c)) ∧
          (∀y. y ∈ t ⇒ connected {x | x ∈ s ∧ f x = y}) ⇒
          ∀c. connected c ∧ c ⊆ t ⇒ connected {x | x ∈ s ∧ f x ∈ c}
   
   [<a name="CONNECTED_OPEN_SET-val"><b>CONNECTED_OPEN_SET</b></a>]  Theorem
      
      ⊢ ∀s. open s ⇒
            (connected s ⇔
             ¬∃e1 e2.
               open e1 ∧ open e2 ∧ e1 ≠ ∅ ∧ e2 ≠ ∅ ∧ e1 ∪ e2 = s ∧
               e1 ∩ e2 = ∅)
   
   [<a name="CONNECTED_REAL_LEMMA-val"><b>CONNECTED_REAL_LEMMA</b></a>]  Theorem
      
      ⊢ ∀f a b e1 e2.
          a ≤ b ∧ f a ∈ e1 ∧ f b ∈ e2 ∧
          (∀e x.
             a ≤ x ∧ x ≤ b ∧ 0 &lt; e ⇒
             ∃d. 0 &lt; d ∧ ∀y. abs (y − x) &lt; d ⇒ dist (f y,f x) &lt; e) ∧
          (∀y. y ∈ e1 ⇒ ∃e. 0 &lt; e ∧ ∀y'. dist (y',y) &lt; e ⇒ y' ∈ e1) ∧
          (∀y. y ∈ e2 ⇒ ∃e. 0 &lt; e ∧ ∀y'. dist (y',y) &lt; e ⇒ y' ∈ e2) ∧
          ¬(∃x. a ≤ x ∧ x ≤ b ∧ f x ∈ e1 ∧ f x ∈ e2) ⇒
          ∃x. a ≤ x ∧ x ≤ b ∧ f x ∉ e1 ∧ f x ∉ e2
   
   [<a name="CONNECTED_SCALING-val"><b>CONNECTED_SCALING</b></a>]  Theorem
      
      ⊢ ∀s c. connected s ⇒ connected (IMAGE (λx. c * x) s)
   
   [<a name="CONNECTED_SEGMENT-val"><b>CONNECTED_SEGMENT</b></a>]  Theorem
      
      ⊢ (∀a b. connected (segment [(a,b)])) ∧
        ∀a b. connected (segment (a,b))
   
   [<a name="CONNECTED_SING-val"><b>CONNECTED_SING</b></a>]  Theorem
      
      ⊢ ∀a. connected {a}
   
   [<a name="CONNECTED_SUBSET_CLOPEN-val"><b>CONNECTED_SUBSET_CLOPEN</b></a>]  Theorem
      
      ⊢ ∀u s c.
          closed_in (subtopology euclidean u) s ∧
          open_in (subtopology euclidean u) s ∧ connected c ∧ c ⊆ u ∧
          c ∩ s ≠ ∅ ⇒
          c ⊆ s
   
   [<a name="CONNECTED_TRANSLATION-val"><b>CONNECTED_TRANSLATION</b></a>]  Theorem
      
      ⊢ ∀a s. connected s ⇒ connected (IMAGE (λx. a + x) s)
   
   [<a name="CONNECTED_TRANSLATION_EQ-val"><b>CONNECTED_TRANSLATION_EQ</b></a>]  Theorem
      
      ⊢ ∀a s. connected (IMAGE (λx. a + x) s) ⇔ connected s
   
   [<a name="CONNECTED_UNION-val"><b>CONNECTED_UNION</b></a>]  Theorem
      
      ⊢ ∀s t. connected s ∧ connected t ∧ s ∩ t ≠ ∅ ⇒ connected (s ∪ t)
   
   [<a name="CONNECTED_UNION_STRONG-val"><b>CONNECTED_UNION_STRONG</b></a>]  Theorem
      
      ⊢ ∀s t.
          connected s ∧ connected t ∧ closure s ∩ t ≠ ∅ ⇒ connected (s ∪ t)
   
   [<a name="CONNECTED_UNIV-val"><b>CONNECTED_UNIV</b></a>]  Theorem
      
      ⊢ connected 𝕌(:real)
   
   [<a name="CONTENT_0_SUBSET-val"><b>CONTENT_0_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s a b.
          s ⊆ interval [(a,b)] ∧ content (interval [(a,b)]) = 0 ⇒
          content s = 0
   
   [<a name="CONTENT_0_SUBSET_GEN-val"><b>CONTENT_0_SUBSET_GEN</b></a>]  Theorem
      
      ⊢ ∀s t. s ⊆ t ∧ bounded t ∧ content t = 0 ⇒ content s = 0
   
   [<a name="CONTENT_CLOSED_INTERVAL-val"><b>CONTENT_CLOSED_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀a b. a ≤ b ⇒ content (interval [(a,b)]) = b − a
   
   [<a name="CONTENT_CLOSED_INTERVAL_CASES-val"><b>CONTENT_CLOSED_INTERVAL_CASES</b></a>]  Theorem
      
      ⊢ ∀a b. content (interval [(a,b)]) = if a ≤ b then b − a else 0
   
   [<a name="CONTENT_EMPTY-val"><b>CONTENT_EMPTY</b></a>]  Theorem
      
      ⊢ content ∅ = 0
   
   [<a name="CONTENT_EQ_0-val"><b>CONTENT_EQ_0</b></a>]  Theorem
      
      ⊢ ∀a b. content (interval [(a,b)]) = 0 ⇔ b ≤ a
   
   [<a name="CONTENT_EQ_0_1-val"><b>CONTENT_EQ_0_1</b></a>]  Theorem
      
      ⊢ ∀a b. content (interval [(a,b)]) = 0 ⇔ b ≤ a
   
   [<a name="CONTENT_EQ_0_GEN-val"><b>CONTENT_EQ_0_GEN</b></a>]  Theorem
      
      ⊢ ∀s. bounded s ⇒ (content s = 0 ⇔ ∃a. ∀x. x ∈ s ⇒ x = a)
   
   [<a name="CONTENT_EQ_0_INTERIOR-val"><b>CONTENT_EQ_0_INTERIOR</b></a>]  Theorem
      
      ⊢ ∀a b.
          content (interval [(a,b)]) = 0 ⇔ interior (interval [(a,b)]) = ∅
   
   [<a name="CONTENT_LT_NZ-val"><b>CONTENT_LT_NZ</b></a>]  Theorem
      
      ⊢ ∀a b.
          0 &lt; content (interval [(a,b)]) ⇔ content (interval [(a,b)]) ≠ 0
   
   [<a name="CONTENT_POS_LE-val"><b>CONTENT_POS_LE</b></a>]  Theorem
      
      ⊢ ∀a b. 0 ≤ content (interval [(a,b)])
   
   [<a name="CONTENT_POS_LT-val"><b>CONTENT_POS_LT</b></a>]  Theorem
      
      ⊢ ∀a b. a &lt; b ⇒ 0 &lt; content (interval [(a,b)])
   
   [<a name="CONTENT_POS_LT_EQ-val"><b>CONTENT_POS_LT_EQ</b></a>]  Theorem
      
      ⊢ ∀a b. 0 &lt; content (interval [(a,b)]) ⇔ a &lt; b
   
   [<a name="CONTENT_SUBSET-val"><b>CONTENT_SUBSET</b></a>]  Theorem
      
      ⊢ ∀a b c d.
          interval [(a,b)] ⊆ interval [(c,d)] ⇒
          content (interval [(a,b)]) ≤ content (interval [(c,d)])
   
   [<a name="CONTENT_UNIT-val"><b>CONTENT_UNIT</b></a>]  Theorem
      
      ⊢ content (interval [(0,1)]) = 1
   
   [<a name="CONTINUOUS_ABS-val"><b>CONTINUOUS_ABS</b></a>]  Theorem
      
      ⊢ ∀f net. f continuous net ⇒ (λx. abs (f x)) continuous net
   
   [<a name="CONTINUOUS_ABS_COMPOSE-val"><b>CONTINUOUS_ABS_COMPOSE</b></a>]  Theorem
      
      ⊢ ∀net f. f continuous net ⇒ (λx. abs (f x)) continuous net
   
   [<a name="CONTINUOUS_ADD-val"><b>CONTINUOUS_ADD</b></a>]  Theorem
      
      ⊢ ∀f g net.
          f continuous net ∧ g continuous net ⇒
          (λx. f x + g x) continuous net
   
   [<a name="CONTINUOUS_AGREE_ON_CLOSURE-val"><b>CONTINUOUS_AGREE_ON_CLOSURE</b></a>]  Theorem
      
      ⊢ ∀g h.
          g continuous_on closure s ∧ h continuous_on closure s ∧
          (∀x. x ∈ s ⇒ g x = h x) ⇒
          ∀x. x ∈ closure s ⇒ g x = h x
   
   [<a name="CONTINUOUS_AT-val"><b>CONTINUOUS_AT</b></a>]  Theorem
      
      ⊢ ∀f x. f continuous at x ⇔ (f ⟶ f x) (at x)
   
   [<a name="CONTINUOUS_ATTAINS_INF-val"><b>CONTINUOUS_ATTAINS_INF</b></a>]  Theorem
      
      ⊢ ∀f s.
          compact s ∧ s ≠ ∅ ∧ f continuous_on s ⇒
          ∃x. x ∈ s ∧ ∀y. y ∈ s ⇒ f x ≤ f y
   
   [<a name="CONTINUOUS_ATTAINS_SUP-val"><b>CONTINUOUS_ATTAINS_SUP</b></a>]  Theorem
      
      ⊢ ∀f s.
          compact s ∧ s ≠ ∅ ∧ f continuous_on s ⇒
          ∃x. x ∈ s ∧ ∀y. y ∈ s ⇒ f y ≤ f x
   
   [<a name="CONTINUOUS_AT_ABS-val"><b>CONTINUOUS_AT_ABS</b></a>]  Theorem
      
      ⊢ ∀x. abs continuous at x
   
   [<a name="CONTINUOUS_AT_AVOID-val"><b>CONTINUOUS_AT_AVOID</b></a>]  Theorem
      
      ⊢ ∀f x a.
          f continuous at x ∧ f x ≠ a ⇒
          ∃e. 0 &lt; e ∧ ∀y. dist (x,y) &lt; e ⇒ f y ≠ a
   
   [<a name="CONTINUOUS_AT_BALL-val"><b>CONTINUOUS_AT_BALL</b></a>]  Theorem
      
      ⊢ ∀f x.
          f continuous at x ⇔
          ∀e. 0 &lt; e ⇒ ∃d. 0 &lt; d ∧ IMAGE f (ball (x,d)) ⊆ ball (f x,e)
   
   [<a name="CONTINUOUS_AT_COMPOSE-val"><b>CONTINUOUS_AT_COMPOSE</b></a>]  Theorem
      
      ⊢ ∀f g x.
          f continuous at x ∧ g continuous at (f x) ⇒ g ∘ f continuous at x
   
   [<a name="CONTINUOUS_AT_COMPOSE_EQ-val"><b>CONTINUOUS_AT_COMPOSE_EQ</b></a>]  Theorem
      
      ⊢ ∀f g h.
          g continuous at x ∧ h continuous at (g x) ∧ (∀y. g (h y) = y) ∧
          h (g x) = x ⇒
          (f continuous at (g x) ⇔ (λx. f (g x)) continuous at x)
   
   [<a name="CONTINUOUS_AT_DIST-val"><b>CONTINUOUS_AT_DIST</b></a>]  Theorem
      
      ⊢ ∀a x. (λx. dist (a,x)) continuous at x
   
   [<a name="CONTINUOUS_AT_DIST_CLOSEST_POINT-val"><b>CONTINUOUS_AT_DIST_CLOSEST_POINT</b></a>]  Theorem
      
      ⊢ ∀s x.
          closed s ∧ s ≠ ∅ ⇒
          (λx. dist (x,closest_point s x)) continuous at x
   
   [<a name="CONTINUOUS_AT_ID-val"><b>CONTINUOUS_AT_ID</b></a>]  Theorem
      
      ⊢ ∀a. (λx. x) continuous at a
   
   [<a name="CONTINUOUS_AT_IMP_CONTINUOUS_ON-val"><b>CONTINUOUS_AT_IMP_CONTINUOUS_ON</b></a>]  Theorem
      
      ⊢ ∀f s. (∀x. x ∈ s ⇒ f continuous at x) ⇒ f continuous_on s
   
   [<a name="CONTINUOUS_AT_INV-val"><b>CONTINUOUS_AT_INV</b></a>]  Theorem
      
      ⊢ ∀f a. f continuous at a ∧ f a ≠ 0 ⇒ realinv ∘ f continuous at a
   
   [<a name="CONTINUOUS_AT_LIFT_DOT-val"><b>CONTINUOUS_AT_LIFT_DOT</b></a>]  Theorem
      
      ⊢ ∀a x. (λy. a * y) continuous at x
   
   [<a name="CONTINUOUS_AT_OPEN-val"><b>CONTINUOUS_AT_OPEN</b></a>]  Theorem
      
      ⊢ ∀f x.
          f continuous at x ⇔
          ∀t. open t ∧ f x ∈ t ⇒
              ∃s. open s ∧ x ∈ s ∧ ∀x'. x' ∈ s ⇒ f x' ∈ t
   
   [<a name="CONTINUOUS_AT_RANGE-val"><b>CONTINUOUS_AT_RANGE</b></a>]  Theorem
      
      ⊢ ∀f x.
          f continuous at x ⇔
          ∀e. 0 &lt; e ⇒
              ∃d. 0 &lt; d ∧ ∀x'. abs (x' − x) &lt; d ⇒ abs (f x' − f x) &lt; e
   
   [<a name="CONTINUOUS_AT_SEQUENTIALLY-val"><b>CONTINUOUS_AT_SEQUENTIALLY</b></a>]  Theorem
      
      ⊢ ∀f a.
          f continuous at a ⇔
          ∀x. (x ⟶ a) sequentially ⇒ (f ∘ x ⟶ f a) sequentially
   
   [<a name="CONTINUOUS_AT_SETDIST-val"><b>CONTINUOUS_AT_SETDIST</b></a>]  Theorem
      
      ⊢ ∀s x. (λy. setdist ({y},s)) continuous at x
   
   [<a name="CONTINUOUS_AT_TRANSLATION-val"><b>CONTINUOUS_AT_TRANSLATION</b></a>]  Theorem
      
      ⊢ ∀a z f. f continuous at (a + z) ⇔ (λx. f (a + x)) continuous at z
   
   [<a name="CONTINUOUS_AT_WITHIN-val"><b>CONTINUOUS_AT_WITHIN</b></a>]  Theorem
      
      ⊢ ∀f x s. f continuous at x ⇒ f continuous (at x within s)
   
   [<a name="CONTINUOUS_AT_WITHIN_INV-val"><b>CONTINUOUS_AT_WITHIN_INV</b></a>]  Theorem
      
      ⊢ ∀f s a.
          f continuous (at a within s) ∧ f a ≠ 0 ⇒
          realinv ∘ f continuous (at a within s)
   
   [<a name="CONTINUOUS_CLOSED_IMP_CAUCHY_CONTINUOUS-val"><b>CONTINUOUS_CLOSED_IMP_CAUCHY_CONTINUOUS</b></a>]  Theorem
      
      ⊢ ∀f s.
          f continuous_on s ∧ closed s ⇒
          ∀x. cauchy x ∧ (∀n. x n ∈ s) ⇒ cauchy (f ∘ x)
   
   [<a name="CONTINUOUS_CLOSED_IN_PREIMAGE-val"><b>CONTINUOUS_CLOSED_IN_PREIMAGE</b></a>]  Theorem
      
      ⊢ ∀f s t.
          f continuous_on s ∧ closed t ⇒
          closed_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ t}
   
   [<a name="CONTINUOUS_CLOSED_IN_PREIMAGE_CONSTANT-val"><b>CONTINUOUS_CLOSED_IN_PREIMAGE_CONSTANT</b></a>]  Theorem
      
      ⊢ ∀f s a.
          f continuous_on s ⇒
          closed_in (subtopology euclidean s) {x | x ∈ s ∧ f x = a}
   
   [<a name="CONTINUOUS_CLOSED_IN_PREIMAGE_EQ-val"><b>CONTINUOUS_CLOSED_IN_PREIMAGE_EQ</b></a>]  Theorem
      
      ⊢ ∀f s.
          f continuous_on s ⇔
          ∀t. closed t ⇒
              closed_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ t}
   
   [<a name="CONTINUOUS_CLOSED_IN_PREIMAGE_GEN-val"><b>CONTINUOUS_CLOSED_IN_PREIMAGE_GEN</b></a>]  Theorem
      
      ⊢ ∀f s t u.
          f continuous_on s ∧ IMAGE f s ⊆ t ∧
          closed_in (subtopology euclidean t) u ⇒
          closed_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u}
   
   [<a name="CONTINUOUS_CLOSED_PREIMAGE-val"><b>CONTINUOUS_CLOSED_PREIMAGE</b></a>]  Theorem
      
      ⊢ ∀f s t.
          f continuous_on s ∧ closed s ∧ closed t ⇒
          closed {x | x ∈ s ∧ f x ∈ t}
   
   [<a name="CONTINUOUS_CLOSED_PREIMAGE_CONSTANT-val"><b>CONTINUOUS_CLOSED_PREIMAGE_CONSTANT</b></a>]  Theorem
      
      ⊢ ∀f s. f continuous_on s ∧ closed s ⇒ closed {x | x ∈ s ∧ f x = a}
   
   [<a name="CONTINUOUS_CLOSED_PREIMAGE_UNIV-val"><b>CONTINUOUS_CLOSED_PREIMAGE_UNIV</b></a>]  Theorem
      
      ⊢ ∀f s. (∀x. f continuous at x) ∧ closed s ⇒ closed {x | f x ∈ s}
   
   [<a name="CONTINUOUS_CMUL-val"><b>CONTINUOUS_CMUL</b></a>]  Theorem
      
      ⊢ ∀f c net. f continuous net ⇒ (λx. c * f x) continuous net
   
   [<a name="CONTINUOUS_COMPONENT_COMPOSE-val"><b>CONTINUOUS_COMPONENT_COMPOSE</b></a>]  Theorem
      
      ⊢ ∀net f i. f continuous net ⇒ (λx. f x) continuous net
   
   [<a name="CONTINUOUS_CONST-val"><b>CONTINUOUS_CONST</b></a>]  Theorem
      
      ⊢ ∀net c. (λx. c) continuous net
   
   [<a name="CONTINUOUS_CONSTANT_ON_CLOSURE-val"><b>CONTINUOUS_CONSTANT_ON_CLOSURE</b></a>]  Theorem
      
      ⊢ ∀f s a.
          f continuous_on closure s ∧ (∀x. x ∈ s ⇒ f x = a) ⇒
          ∀x. x ∈ closure s ⇒ f x = a
   
   [<a name="CONTINUOUS_DIAMETER-val"><b>CONTINUOUS_DIAMETER</b></a>]  Theorem
      
      ⊢ ∀s e.
          bounded s ∧ s ≠ ∅ ∧ 0 &lt; e ⇒
          ∃d. 0 &lt; d ∧
              ∀t. bounded t ∧ t ≠ ∅ ∧ hausdist (s,t) &lt; d ⇒
                  abs (diameter s − diameter t) &lt; e
   
   [<a name="CONTINUOUS_DISCONNECTED_DISCRETE_FINITE_RANGE_CONSTANT_EQ-val"><b>CONTINUOUS_DISCONNECTED_DISCRETE_FINITE_RANGE_CONSTANT_EQ</b></a>]  Theorem
      
      ⊢ (∀s. connected s ⇔
             ∀f t.
               f continuous_on s ∧ IMAGE f s ⊆ t ∧
               (∀y. y ∈ t ⇒ connected_component t y = {y}) ⇒
               ∃a. ∀x. x ∈ s ⇒ f x = a) ∧
        (∀s. connected s ⇔
             ∀f. f continuous_on s ∧
                 (∀x. x ∈ s ⇒
                      ∃e. 0 &lt; e ∧
                          ∀y. y ∈ s ∧ f y ≠ f x ⇒ e ≤ abs (f y − f x)) ⇒
                 ∃a. ∀x. x ∈ s ⇒ f x = a) ∧
        ∀s. connected s ⇔
            ∀f. f continuous_on s ∧ FINITE (IMAGE f s) ⇒
                ∃a. ∀x. x ∈ s ⇒ f x = a
   
   [<a name="CONTINUOUS_DISCONNECTED_RANGE_CONSTANT-val"><b>CONTINUOUS_DISCONNECTED_RANGE_CONSTANT</b></a>]  Theorem
      
      ⊢ ∀f s.
          connected s ∧ f continuous_on s ∧ IMAGE f s ⊆ t ∧
          (∀y. y ∈ t ⇒ connected_component t y = {y}) ⇒
          ∃a. ∀x. x ∈ s ⇒ f x = a
   
   [<a name="CONTINUOUS_DISCONNECTED_RANGE_CONSTANT_EQ-val"><b>CONTINUOUS_DISCONNECTED_RANGE_CONSTANT_EQ</b></a>]  Theorem
      
      ⊢ ∀s. connected s ⇔
            ∀f t.
              f continuous_on s ∧ IMAGE f s ⊆ t ∧
              (∀y. y ∈ t ⇒ connected_component t y = {y}) ⇒
              ∃a. ∀x. x ∈ s ⇒ f x = a
   
   [<a name="CONTINUOUS_DISCRETE_RANGE_CONSTANT-val"><b>CONTINUOUS_DISCRETE_RANGE_CONSTANT</b></a>]  Theorem
      
      ⊢ ∀f s.
          connected s ∧ f continuous_on s ∧
          (∀x. x ∈ s ⇒
               ∃e. 0 &lt; e ∧ ∀y. y ∈ s ∧ f y ≠ f x ⇒ e ≤ abs (f y − f x)) ⇒
          ∃a. ∀x. x ∈ s ⇒ f x = a
   
   [<a name="CONTINUOUS_DISCRETE_RANGE_CONSTANT_EQ-val"><b>CONTINUOUS_DISCRETE_RANGE_CONSTANT_EQ</b></a>]  Theorem
      
      ⊢ ∀s. connected s ⇔
            ∀f. f continuous_on s ∧
                (∀x. x ∈ s ⇒
                     ∃e. 0 &lt; e ∧
                         ∀y. y ∈ s ∧ f y ≠ f x ⇒ e ≤ abs (f y − f x)) ⇒
                ∃a. ∀x. x ∈ s ⇒ f x = a
   
   [<a name="CONTINUOUS_DOT2-val"><b>CONTINUOUS_DOT2</b></a>]  Theorem
      
      ⊢ ∀net f g.
          f continuous net ∧ g continuous net ⇒
          (λx. f x * g x) continuous net
   
   [<a name="CONTINUOUS_FINITE_RANGE_CONSTANT-val"><b>CONTINUOUS_FINITE_RANGE_CONSTANT</b></a>]  Theorem
      
      ⊢ ∀f s.
          connected s ∧ f continuous_on s ∧ FINITE (IMAGE f s) ⇒
          ∃a. ∀x. x ∈ s ⇒ f x = a
   
   [<a name="CONTINUOUS_FINITE_RANGE_CONSTANT_EQ-val"><b>CONTINUOUS_FINITE_RANGE_CONSTANT_EQ</b></a>]  Theorem
      
      ⊢ ∀s. connected s ⇔
            ∀f. f continuous_on s ∧ FINITE (IMAGE f s) ⇒
                ∃a. ∀x. x ∈ s ⇒ f x = a
   
   [<a name="CONTINUOUS_GE_ON_CLOSURE-val"><b>CONTINUOUS_GE_ON_CLOSURE</b></a>]  Theorem
      
      ⊢ ∀f s a.
          f continuous_on closure s ∧ (∀x. x ∈ s ⇒ a ≤ f x) ⇒
          ∀x. x ∈ closure s ⇒ a ≤ f x
   
   [<a name="CONTINUOUS_IMP_CLOSED_MAP-val"><b>CONTINUOUS_IMP_CLOSED_MAP</b></a>]  Theorem
      
      ⊢ ∀f s t.
          f continuous_on s ∧ IMAGE f s = t ∧ compact s ⇒
          ∀u. closed_in (subtopology euclidean s) u ⇒
              closed_in (subtopology euclidean t) (IMAGE f u)
   
   [<a name="CONTINUOUS_IMP_QUOTIENT_MAP-val"><b>CONTINUOUS_IMP_QUOTIENT_MAP</b></a>]  Theorem
      
      ⊢ ∀f s t.
          f continuous_on s ∧ IMAGE f s = t ∧ compact s ⇒
          ∀u. u ⊆ t ⇒
              (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇔
               open_in (subtopology euclidean t) u)
   
   [<a name="CONTINUOUS_INV-val"><b>CONTINUOUS_INV</b></a>]  Theorem
      
      ⊢ ∀net f.
          f continuous net ∧ f (netlimit net) ≠ 0 ⇒
          realinv ∘ f continuous net
   
   [<a name="CONTINUOUS_LEFT_INVERSE_IMP_QUOTIENT_MAP-val"><b>CONTINUOUS_LEFT_INVERSE_IMP_QUOTIENT_MAP</b></a>]  Theorem
      
      ⊢ ∀f g s.
          f continuous_on s ∧ g continuous_on IMAGE f s ∧
          (∀x. x ∈ s ⇒ g (f x) = x) ⇒
          ∀u. u ⊆ IMAGE f s ⇒
              (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇔
               open_in (subtopology euclidean (IMAGE f s)) u)
   
   [<a name="CONTINUOUS_LEVELSET_OPEN-val"><b>CONTINUOUS_LEVELSET_OPEN</b></a>]  Theorem
      
      ⊢ ∀f s a.
          connected s ∧ f continuous_on s ∧ open {x | x ∈ s ∧ f x = a} ∧
          (∃x. x ∈ s ∧ f x = a) ⇒
          ∀x. x ∈ s ⇒ f x = a
   
   [<a name="CONTINUOUS_LEVELSET_OPEN_IN-val"><b>CONTINUOUS_LEVELSET_OPEN_IN</b></a>]  Theorem
      
      ⊢ ∀f s a.
          connected s ∧ f continuous_on s ∧
          open_in (subtopology euclidean s) {x | x ∈ s ∧ f x = a} ∧
          (∃x. x ∈ s ∧ f x = a) ⇒
          ∀x. x ∈ s ⇒ f x = a
   
   [<a name="CONTINUOUS_LEVELSET_OPEN_IN_CASES-val"><b>CONTINUOUS_LEVELSET_OPEN_IN_CASES</b></a>]  Theorem
      
      ⊢ ∀f s a.
          connected s ∧ f continuous_on s ∧
          open_in (subtopology euclidean s) {x | x ∈ s ∧ f x = a} ⇒
          (∀x. x ∈ s ⇒ f x ≠ a) ∨ ∀x. x ∈ s ⇒ f x = a
   
   [<a name="CONTINUOUS_LE_ON_CLOSURE-val"><b>CONTINUOUS_LE_ON_CLOSURE</b></a>]  Theorem
      
      ⊢ ∀f s a.
          f continuous_on closure s ∧ (∀x. x ∈ s ⇒ f x ≤ a) ⇒
          ∀x. x ∈ closure s ⇒ f x ≤ a
   
   [<a name="CONTINUOUS_MAP_CLOSURES-val"><b>CONTINUOUS_MAP_CLOSURES</b></a>]  Theorem
      
      ⊢ ∀f. f continuous_on 𝕌(:real) ⇔
            ∀s. IMAGE f (closure s) ⊆ closure (IMAGE f s)
   
   [<a name="CONTINUOUS_MAX-val"><b>CONTINUOUS_MAX</b></a>]  Theorem
      
      ⊢ ∀f g net.
          f continuous net ∧ g continuous net ⇒
          (λx. max (f x) (g x)) continuous net
   
   [<a name="CONTINUOUS_MIN-val"><b>CONTINUOUS_MIN</b></a>]  Theorem
      
      ⊢ ∀f g net.
          f continuous net ∧ g continuous net ⇒
          (λx. min (f x) (g x)) continuous net
   
   [<a name="CONTINUOUS_MUL-val"><b>CONTINUOUS_MUL</b></a>]  Theorem
      
      ⊢ ∀net f c.
          c continuous net ∧ f continuous net ⇒
          (λx. c x * f x) continuous net
   
   [<a name="CONTINUOUS_NEG-val"><b>CONTINUOUS_NEG</b></a>]  Theorem
      
      ⊢ ∀f net. f continuous net ⇒ (λx. -f x) continuous net
   
   [<a name="CONTINUOUS_ON-val"><b>CONTINUOUS_ON</b></a>]  Theorem
      
      ⊢ ∀f s. f continuous_on s ⇔ ∀x. x ∈ s ⇒ (f ⟶ f x) (at x within s)
   
   [<a name="CONTINUOUS_ON_ABS-val"><b>CONTINUOUS_ON_ABS</b></a>]  Theorem
      
      ⊢ ∀f s. f continuous_on s ⇒ (λx. abs (f x)) continuous_on s
   
   [<a name="CONTINUOUS_ON_ABS_COMPOSE-val"><b>CONTINUOUS_ON_ABS_COMPOSE</b></a>]  Theorem
      
      ⊢ ∀f s. f continuous_on s ⇒ (λx. abs (f x)) continuous_on s
   
   [<a name="CONTINUOUS_ON_ADD-val"><b>CONTINUOUS_ON_ADD</b></a>]  Theorem
      
      ⊢ ∀f g s.
          f continuous_on s ∧ g continuous_on s ⇒
          (λx. f x + g x) continuous_on s
   
   [<a name="CONTINUOUS_ON_AVOID-val"><b>CONTINUOUS_ON_AVOID</b></a>]  Theorem
      
      ⊢ ∀f x s a.
          f continuous_on s ∧ x ∈ s ∧ f x ≠ a ⇒
          ∃e. 0 &lt; e ∧ ∀y. y ∈ s ∧ dist (x,y) &lt; e ⇒ f y ≠ a
   
   [<a name="CONTINUOUS_ON_CASES-val"><b>CONTINUOUS_ON_CASES</b></a>]  Theorem
      
      ⊢ ∀P f g s t.
          closed s ∧ closed t ∧ f continuous_on s ∧ g continuous_on t ∧
          (∀x. x ∈ s ∧ ¬P x ∨ x ∈ t ∧ P x ⇒ f x = g x) ⇒
          (λx. if P x then f x else g x) continuous_on s ∪ t
   
   [<a name="CONTINUOUS_ON_CASES_1-val"><b>CONTINUOUS_ON_CASES_1</b></a>]  Theorem
      
      ⊢ ∀f g s a.
          f continuous_on {t | t ∈ s ∧ t ≤ a} ∧
          g continuous_on equiv_class $&lt;= s a ∧ (a ∈ s ⇒ f a = g a) ⇒
          (λt. if t ≤ a then f t else g t) continuous_on s
   
   [<a name="CONTINUOUS_ON_CASES_LE-val"><b>CONTINUOUS_ON_CASES_LE</b></a>]  Theorem
      
      ⊢ ∀f g h s a.
          f continuous_on {t | t ∈ s ∧ h t ≤ a} ∧
          g continuous_on {t | t ∈ s ∧ a ≤ h t} ∧ h continuous_on s ∧
          (∀t. t ∈ s ∧ h t = a ⇒ f t = g t) ⇒
          (λt. if h t ≤ a then f t else g t) continuous_on s
   
   [<a name="CONTINUOUS_ON_CASES_LOCAL-val"><b>CONTINUOUS_ON_CASES_LOCAL</b></a>]  Theorem
      
      ⊢ ∀P f g s t.
          closed_in (subtopology euclidean (s ∪ t)) s ∧
          closed_in (subtopology euclidean (s ∪ t)) t ∧ f continuous_on s ∧
          g continuous_on t ∧ (∀x. x ∈ s ∧ ¬P x ∨ x ∈ t ∧ P x ⇒ f x = g x) ⇒
          (λx. if P x then f x else g x) continuous_on s ∪ t
   
   [<a name="CONTINUOUS_ON_CASES_LOCAL_OPEN-val"><b>CONTINUOUS_ON_CASES_LOCAL_OPEN</b></a>]  Theorem
      
      ⊢ ∀P f g s t.
          open_in (subtopology euclidean (s ∪ t)) s ∧
          open_in (subtopology euclidean (s ∪ t)) t ∧ f continuous_on s ∧
          g continuous_on t ∧ (∀x. x ∈ s ∧ ¬P x ∨ x ∈ t ∧ P x ⇒ f x = g x) ⇒
          (λx. if P x then f x else g x) continuous_on s ∪ t
   
   [<a name="CONTINUOUS_ON_CASES_OPEN-val"><b>CONTINUOUS_ON_CASES_OPEN</b></a>]  Theorem
      
      ⊢ ∀P f g s t.
          open s ∧ open t ∧ f continuous_on s ∧ g continuous_on t ∧
          (∀x. x ∈ s ∧ ¬P x ∨ x ∈ t ∧ P x ⇒ f x = g x) ⇒
          (λx. if P x then f x else g x) continuous_on s ∪ t
   
   [<a name="CONTINUOUS_ON_CLOSED-val"><b>CONTINUOUS_ON_CLOSED</b></a>]  Theorem
      
      ⊢ ∀f s.
          f continuous_on s ⇔
          ∀t. closed_in (subtopology euclidean (IMAGE f s)) t ⇒
              closed_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ t}
   
   [<a name="CONTINUOUS_ON_CLOSED_GEN-val"><b>CONTINUOUS_ON_CLOSED_GEN</b></a>]  Theorem
      
      ⊢ ∀f s t.
          IMAGE f s ⊆ t ⇒
          (f continuous_on s ⇔
           ∀u. closed_in (subtopology euclidean t) u ⇒
               closed_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u})
   
   [<a name="CONTINUOUS_ON_CLOSURE-val"><b>CONTINUOUS_ON_CLOSURE</b></a>]  Theorem
      
      ⊢ ∀f s.
          f continuous_on closure s ⇔
          ∀x e.
            x ∈ closure s ∧ 0 &lt; e ⇒
            ∃d. 0 &lt; d ∧ ∀y. y ∈ s ∧ dist (y,x) &lt; d ⇒ dist (f y,f x) &lt; e
   
   [<a name="CONTINUOUS_ON_CLOSURE_ABS_LE-val"><b>CONTINUOUS_ON_CLOSURE_ABS_LE</b></a>]  Theorem
      
      ⊢ ∀f s x b.
          f continuous_on closure s ∧ (∀y. y ∈ s ⇒ abs (f y) ≤ b) ∧
          x ∈ closure s ⇒
          abs (f x) ≤ b
   
   [<a name="CONTINUOUS_ON_CLOSURE_COMPONENT_GE-val"><b>CONTINUOUS_ON_CLOSURE_COMPONENT_GE</b></a>]  Theorem
      
      ⊢ ∀f s x b.
          f continuous_on closure s ∧ (∀y. y ∈ s ⇒ b ≤ f y) ∧ x ∈ closure s ⇒
          b ≤ f x
   
   [<a name="CONTINUOUS_ON_CLOSURE_COMPONENT_LE-val"><b>CONTINUOUS_ON_CLOSURE_COMPONENT_LE</b></a>]  Theorem
      
      ⊢ ∀f s x b.
          f continuous_on closure s ∧ (∀y. y ∈ s ⇒ f y ≤ b) ∧ x ∈ closure s ⇒
          f x ≤ b
   
   [<a name="CONTINUOUS_ON_CLOSURE_SEQUENTIALLY-val"><b>CONTINUOUS_ON_CLOSURE_SEQUENTIALLY</b></a>]  Theorem
      
      ⊢ ∀f s.
          f continuous_on closure s ⇔
          ∀x a.
            a ∈ closure s ∧ (∀n. x n ∈ s) ∧ (x ⟶ a) sequentially ⇒
            (f ∘ x ⟶ f a) sequentially
   
   [<a name="CONTINUOUS_ON_CMUL-val"><b>CONTINUOUS_ON_CMUL</b></a>]  Theorem
      
      ⊢ ∀f c s. f continuous_on s ⇒ (λx. c * f x) continuous_on s
   
   [<a name="CONTINUOUS_ON_COMPONENTS_FINITE-val"><b>CONTINUOUS_ON_COMPONENTS_FINITE</b></a>]  Theorem
      
      ⊢ ∀f s.
          FINITE (components s) ∧
          (∀c. c ∈ components s ⇒ f continuous_on c) ⇒
          f continuous_on s
   
   [<a name="CONTINUOUS_ON_COMPONENTS_GEN-val"><b>CONTINUOUS_ON_COMPONENTS_GEN</b></a>]  Theorem
      
      ⊢ ∀f s.
          (∀c. c ∈ components s ⇒
               open_in (subtopology euclidean s) c ∧ f continuous_on c) ⇒
          f continuous_on s
   
   [<a name="CONTINUOUS_ON_COMPONENT_COMPOSE-val"><b>CONTINUOUS_ON_COMPONENT_COMPOSE</b></a>]  Theorem
      
      ⊢ ∀f s. f continuous_on s ⇒ (λx. f x) continuous_on s
   
   [<a name="CONTINUOUS_ON_COMPOSE-val"><b>CONTINUOUS_ON_COMPOSE</b></a>]  Theorem
      
      ⊢ ∀f g s.
          f continuous_on s ∧ g continuous_on IMAGE f s ⇒
          g ∘ f continuous_on s
   
   [<a name="CONTINUOUS_ON_COMPOSE_QUOTIENT-val"><b>CONTINUOUS_ON_COMPOSE_QUOTIENT</b></a>]  Theorem
      
      ⊢ ∀f g s t u.
          IMAGE f s ⊆ t ∧ IMAGE g t ⊆ u ∧
          (∀v. v ⊆ t ⇒
               (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ v} ⇔
                open_in (subtopology euclidean t) v)) ∧
          g ∘ f continuous_on s ⇒
          g continuous_on t
   
   [<a name="CONTINUOUS_ON_CONST-val"><b>CONTINUOUS_ON_CONST</b></a>]  Theorem
      
      ⊢ ∀s c. (λx. c) continuous_on s
   
   [<a name="CONTINUOUS_ON_DIST-val"><b>CONTINUOUS_ON_DIST</b></a>]  Theorem
      
      ⊢ ∀a s. (λx. dist (a,x)) continuous_on s
   
   [<a name="CONTINUOUS_ON_DIST_CLOSEST_POINT-val"><b>CONTINUOUS_ON_DIST_CLOSEST_POINT</b></a>]  Theorem
      
      ⊢ ∀s t.
          closed s ∧ s ≠ ∅ ⇒
          (λx. dist (x,closest_point s x)) continuous_on t
   
   [<a name="CONTINUOUS_ON_DOT2-val"><b>CONTINUOUS_ON_DOT2</b></a>]  Theorem
      
      ⊢ ∀f g s.
          f continuous_on s ∧ g continuous_on s ⇒
          (λx. f x * g x) continuous_on s
   
   [<a name="CONTINUOUS_ON_EMPTY-val"><b>CONTINUOUS_ON_EMPTY</b></a>]  Theorem
      
      ⊢ ∀f. f continuous_on ∅
   
   [<a name="CONTINUOUS_ON_EQ-val"><b>CONTINUOUS_ON_EQ</b></a>]  Theorem
      
      ⊢ ∀f g s.
          (∀x. x ∈ s ⇒ f x = g x) ∧ f continuous_on s ⇒ g continuous_on s
   
   [<a name="CONTINUOUS_ON_EQ_CONTINUOUS_AT-val"><b>CONTINUOUS_ON_EQ_CONTINUOUS_AT</b></a>]  Theorem
      
      ⊢ ∀f s. open s ⇒ (f continuous_on s ⇔ ∀x. x ∈ s ⇒ f continuous at x)
   
   [<a name="CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN-val"><b>CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN</b></a>]  Theorem
      
      ⊢ ∀f s. f continuous_on s ⇔ ∀x. x ∈ s ⇒ f continuous (at x within s)
   
   [<a name="CONTINUOUS_ON_FINITE-val"><b>CONTINUOUS_ON_FINITE</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ⇒ f continuous_on s
   
   [<a name="CONTINUOUS_ON_ID-val"><b>CONTINUOUS_ON_ID</b></a>]  Theorem
      
      ⊢ ∀s. (λx. x) continuous_on s
   
   [<a name="CONTINUOUS_ON_IMP_CLOSED_IN-val"><b>CONTINUOUS_ON_IMP_CLOSED_IN</b></a>]  Theorem
      
      ⊢ ∀f s t.
          f continuous_on s ∧
          closed_in (subtopology euclidean (IMAGE f s)) t ⇒
          closed_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ t}
   
   [<a name="CONTINUOUS_ON_IMP_OPEN_IN-val"><b>CONTINUOUS_ON_IMP_OPEN_IN</b></a>]  Theorem
      
      ⊢ ∀f s t.
          f continuous_on s ∧ open_in (subtopology euclidean (IMAGE f s)) t ⇒
          open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ t}
   
   [<a name="CONTINUOUS_ON_INTERIOR-val"><b>CONTINUOUS_ON_INTERIOR</b></a>]  Theorem
      
      ⊢ ∀f s x. f continuous_on s ∧ x ∈ interior s ⇒ f continuous at x
   
   [<a name="CONTINUOUS_ON_INV-val"><b>CONTINUOUS_ON_INV</b></a>]  Theorem
      
      ⊢ ∀f s.
          f continuous_on s ∧ (∀x. x ∈ s ⇒ f x ≠ 0) ⇒
          realinv ∘ f continuous_on s
   
   [<a name="CONTINUOUS_ON_INVERSE-val"><b>CONTINUOUS_ON_INVERSE</b></a>]  Theorem
      
      ⊢ ∀f g s.
          f continuous_on s ∧ compact s ∧ (∀x. x ∈ s ⇒ g (f x) = x) ⇒
          g continuous_on IMAGE f s
   
   [<a name="CONTINUOUS_ON_INVERSE_CLOSED_MAP-val"><b>CONTINUOUS_ON_INVERSE_CLOSED_MAP</b></a>]  Theorem
      
      ⊢ ∀f g s t.
          f continuous_on s ∧ IMAGE f s = t ∧ (∀x. x ∈ s ⇒ g (f x) = x) ∧
          (∀u. closed_in (subtopology euclidean s) u ⇒
               closed_in (subtopology euclidean t) (IMAGE f u)) ⇒
          g continuous_on t
   
   [<a name="CONTINUOUS_ON_INVERSE_OPEN_MAP-val"><b>CONTINUOUS_ON_INVERSE_OPEN_MAP</b></a>]  Theorem
      
      ⊢ ∀f g s t.
          f continuous_on s ∧ IMAGE f s = t ∧ (∀x. x ∈ s ⇒ g (f x) = x) ∧
          (∀u. open_in (subtopology euclidean s) u ⇒
               open_in (subtopology euclidean t) (IMAGE f u)) ⇒
          g continuous_on t
   
   [<a name="CONTINUOUS_ON_IVT-val"><b>CONTINUOUS_ON_IVT</b></a>]  Theorem
      
      ⊢ ∀f a b y.
          a ≤ b ∧ f a ≤ y ∧ y ≤ f b ∧ f continuous_on interval [(a,b)] ⇒
          ∃x. x ∈ interval [(a,b)] ∧ f x = y
   
   [<a name="CONTINUOUS_ON_LIFT_DOT-val"><b>CONTINUOUS_ON_LIFT_DOT</b></a>]  Theorem
      
      ⊢ ∀s. (λy. a * y) continuous_on s
   
   [<a name="CONTINUOUS_ON_MAX-val"><b>CONTINUOUS_ON_MAX</b></a>]  Theorem
      
      ⊢ ∀f g s.
          f continuous_on s ∧ g continuous_on s ⇒
          (λx. max (f x) (g x)) continuous_on s
   
   [<a name="CONTINUOUS_ON_MIN-val"><b>CONTINUOUS_ON_MIN</b></a>]  Theorem
      
      ⊢ ∀f g s.
          f continuous_on s ∧ g continuous_on s ⇒
          (λx. min (f x) (g x)) continuous_on s
   
   [<a name="CONTINUOUS_ON_MUL-val"><b>CONTINUOUS_ON_MUL</b></a>]  Theorem
      
      ⊢ ∀s c f.
          c continuous_on s ∧ f continuous_on s ⇒
          (λx. c x * f x) continuous_on s
   
   [<a name="CONTINUOUS_ON_NEG-val"><b>CONTINUOUS_ON_NEG</b></a>]  Theorem
      
      ⊢ ∀f s. f continuous_on s ⇒ (λx. -f x) continuous_on s
   
   [<a name="CONTINUOUS_ON_NO_LIMPT-val"><b>CONTINUOUS_ON_NO_LIMPT</b></a>]  Theorem
      
      ⊢ ∀f s. ¬(∃x. x limit_point_of s) ⇒ f continuous_on s
   
   [<a name="CONTINUOUS_ON_OPEN-val"><b>CONTINUOUS_ON_OPEN</b></a>]  Theorem
      
      ⊢ ∀f s.
          f continuous_on s ⇔
          ∀t. open_in (subtopology euclidean (IMAGE f s)) t ⇒
              open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ t}
   
   [<a name="CONTINUOUS_ON_OPEN_AVOID-val"><b>CONTINUOUS_ON_OPEN_AVOID</b></a>]  Theorem
      
      ⊢ ∀f x s a.
          f continuous_on s ∧ open s ∧ x ∈ s ∧ f x ≠ a ⇒
          ∃e. 0 &lt; e ∧ ∀y. dist (x,y) &lt; e ⇒ f y ≠ a
   
   [<a name="CONTINUOUS_ON_OPEN_GEN-val"><b>CONTINUOUS_ON_OPEN_GEN</b></a>]  Theorem
      
      ⊢ ∀f s t.
          IMAGE f s ⊆ t ⇒
          (f continuous_on s ⇔
           ∀u. open_in (subtopology euclidean t) u ⇒
               open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u})
   
   [<a name="CONTINUOUS_ON_POW-val"><b>CONTINUOUS_ON_POW</b></a>]  Theorem
      
      ⊢ ∀f s n. (λx. f x) continuous_on s ⇒ (λx. f x pow n) continuous_on s
   
   [<a name="CONTINUOUS_ON_PRODUCT-val"><b>CONTINUOUS_ON_PRODUCT</b></a>]  Theorem
      
      ⊢ ∀f s t.
          FINITE t ∧ (∀i. i ∈ t ⇒ (λx. f x i) continuous_on s) ⇒
          (λx. product t (f x)) continuous_on s
   
   [<a name="CONTINUOUS_ON_RANGE-val"><b>CONTINUOUS_ON_RANGE</b></a>]  Theorem
      
      ⊢ ∀f s.
          f continuous_on s ⇔
          ∀x. x ∈ s ⇒
              ∀e. 0 &lt; e ⇒
                  ∃d. 0 &lt; d ∧
                      ∀x'. x' ∈ s ∧ abs (x' − x) &lt; d ⇒ abs (f x' − f x) &lt; e
   
   [<a name="CONTINUOUS_ON_SEQUENTIALLY-val"><b>CONTINUOUS_ON_SEQUENTIALLY</b></a>]  Theorem
      
      ⊢ ∀f s.
          f continuous_on s ⇔
          ∀x a.
            a ∈ s ∧ (∀n. x n ∈ s) ∧ (x ⟶ a) sequentially ⇒
            (f ∘ x ⟶ f a) sequentially
   
   [<a name="CONTINUOUS_ON_SETDIST-val"><b>CONTINUOUS_ON_SETDIST</b></a>]  Theorem
      
      ⊢ ∀s t. (λy. setdist ({y},s)) continuous_on t
   
   [<a name="CONTINUOUS_ON_SING-val"><b>CONTINUOUS_ON_SING</b></a>]  Theorem
      
      ⊢ ∀f a. f continuous_on {a}
   
   [<a name="CONTINUOUS_ON_SUB-val"><b>CONTINUOUS_ON_SUB</b></a>]  Theorem
      
      ⊢ ∀f g s.
          f continuous_on s ∧ g continuous_on s ⇒
          (λx. f x − g x) continuous_on s
   
   [<a name="CONTINUOUS_ON_SUBSET-val"><b>CONTINUOUS_ON_SUBSET</b></a>]  Theorem
      
      ⊢ ∀f s t. f continuous_on s ∧ t ⊆ s ⇒ f continuous_on t
   
   [<a name="CONTINUOUS_ON_SUM-val"><b>CONTINUOUS_ON_SUM</b></a>]  Theorem
      
      ⊢ ∀t f s.
          FINITE s ∧ (∀a. a ∈ s ⇒ f a continuous_on t) ⇒
          (λx. sum s (λa. f a x)) continuous_on t
   
   [<a name="CONTINUOUS_ON_UNION-val"><b>CONTINUOUS_ON_UNION</b></a>]  Theorem
      
      ⊢ ∀f s t.
          closed s ∧ closed t ∧ f continuous_on s ∧ f continuous_on t ⇒
          f continuous_on s ∪ t
   
   [<a name="CONTINUOUS_ON_UNION_LOCAL-val"><b>CONTINUOUS_ON_UNION_LOCAL</b></a>]  Theorem
      
      ⊢ ∀f s.
          closed_in (subtopology euclidean (s ∪ t)) s ∧
          closed_in (subtopology euclidean (s ∪ t)) t ∧ f continuous_on s ∧
          f continuous_on t ⇒
          f continuous_on s ∪ t
   
   [<a name="CONTINUOUS_ON_UNION_LOCAL_OPEN-val"><b>CONTINUOUS_ON_UNION_LOCAL_OPEN</b></a>]  Theorem
      
      ⊢ ∀f s.
          open_in (subtopology euclidean (s ∪ t)) s ∧
          open_in (subtopology euclidean (s ∪ t)) t ∧ f continuous_on s ∧
          f continuous_on t ⇒
          f continuous_on s ∪ t
   
   [<a name="CONTINUOUS_ON_UNION_OPEN-val"><b>CONTINUOUS_ON_UNION_OPEN</b></a>]  Theorem
      
      ⊢ ∀f s t.
          open s ∧ open t ∧ f continuous_on s ∧ f continuous_on t ⇒
          f continuous_on s ∪ t
   
   [<a name="CONTINUOUS_ON_VMUL-val"><b>CONTINUOUS_ON_VMUL</b></a>]  Theorem
      
      ⊢ ∀s c v. c continuous_on s ⇒ (λx. c x * v) continuous_on s
   
   [<a name="CONTINUOUS_OPEN_IN_PREIMAGE-val"><b>CONTINUOUS_OPEN_IN_PREIMAGE</b></a>]  Theorem
      
      ⊢ ∀f s t.
          f continuous_on s ∧ open t ⇒
          open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ t}
   
   [<a name="CONTINUOUS_OPEN_IN_PREIMAGE_EQ-val"><b>CONTINUOUS_OPEN_IN_PREIMAGE_EQ</b></a>]  Theorem
      
      ⊢ ∀f s.
          f continuous_on s ⇔
          ∀t. open t ⇒
              open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ t}
   
   [<a name="CONTINUOUS_OPEN_IN_PREIMAGE_GEN-val"><b>CONTINUOUS_OPEN_IN_PREIMAGE_GEN</b></a>]  Theorem
      
      ⊢ ∀f s t u.
          f continuous_on s ∧ IMAGE f s ⊆ t ∧
          open_in (subtopology euclidean t) u ⇒
          open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u}
   
   [<a name="CONTINUOUS_OPEN_PREIMAGE-val"><b>CONTINUOUS_OPEN_PREIMAGE</b></a>]  Theorem
      
      ⊢ ∀f s t.
          f continuous_on s ∧ open s ∧ open t ⇒ open {x | x ∈ s ∧ f x ∈ t}
   
   [<a name="CONTINUOUS_OPEN_PREIMAGE_UNIV-val"><b>CONTINUOUS_OPEN_PREIMAGE_UNIV</b></a>]  Theorem
      
      ⊢ ∀f s. (∀x. f continuous at x) ∧ open s ⇒ open {x | f x ∈ s}
   
   [<a name="CONTINUOUS_POW-val"><b>CONTINUOUS_POW</b></a>]  Theorem
      
      ⊢ ∀net f n. (λx. f x) continuous net ⇒ (λx. f x pow n) continuous net
   
   [<a name="CONTINUOUS_PRODUCT-val"><b>CONTINUOUS_PRODUCT</b></a>]  Theorem
      
      ⊢ ∀net f t.
          FINITE t ∧ (∀i. i ∈ t ⇒ (λx. f x i) continuous net) ⇒
          (λx. product t (f x)) continuous net
   
   [<a name="CONTINUOUS_RIGHT_INVERSE_IMP_QUOTIENT_MAP-val"><b>CONTINUOUS_RIGHT_INVERSE_IMP_QUOTIENT_MAP</b></a>]  Theorem
      
      ⊢ ∀f g s t.
          f continuous_on s ∧ IMAGE f s ⊆ t ∧ g continuous_on t ∧
          IMAGE g t ⊆ s ∧ (∀y. y ∈ t ⇒ f (g y) = y) ⇒
          ∀u. u ⊆ t ⇒
              (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇔
               open_in (subtopology euclidean t) u)
   
   [<a name="CONTINUOUS_SUB-val"><b>CONTINUOUS_SUB</b></a>]  Theorem
      
      ⊢ ∀f g net.
          f continuous net ∧ g continuous net ⇒
          (λx. f x − g x) continuous net
   
   [<a name="CONTINUOUS_SUM-val"><b>CONTINUOUS_SUM</b></a>]  Theorem
      
      ⊢ ∀net f s.
          FINITE s ∧ (∀a. a ∈ s ⇒ f a continuous net) ⇒
          (λx. sum s (λa. f a x)) continuous net
   
   [<a name="CONTINUOUS_TRANSFORM_AT-val"><b>CONTINUOUS_TRANSFORM_AT</b></a>]  Theorem
      
      ⊢ ∀f g x d.
          0 &lt; d ∧ (∀x'. dist (x',x) &lt; d ⇒ f x' = g x') ∧ f continuous at x ⇒
          g continuous at x
   
   [<a name="CONTINUOUS_TRANSFORM_WITHIN-val"><b>CONTINUOUS_TRANSFORM_WITHIN</b></a>]  Theorem
      
      ⊢ ∀f g s x d.
          0 &lt; d ∧ x ∈ s ∧ (∀x'. x' ∈ s ∧ dist (x',x) &lt; d ⇒ f x' = g x') ∧
          f continuous (at x within s) ⇒
          g continuous (at x within s)
   
   [<a name="CONTINUOUS_TRANSFORM_WITHIN_OPEN-val"><b>CONTINUOUS_TRANSFORM_WITHIN_OPEN</b></a>]  Theorem
      
      ⊢ ∀f g s a.
          open s ∧ a ∈ s ∧ (∀x. x ∈ s ⇒ f x = g x) ∧ f continuous at a ⇒
          g continuous at a
   
   [<a name="CONTINUOUS_TRANSFORM_WITHIN_OPEN_IN-val"><b>CONTINUOUS_TRANSFORM_WITHIN_OPEN_IN</b></a>]  Theorem
      
      ⊢ ∀f g s t a.
          open_in (subtopology euclidean t) s ∧ a ∈ s ∧
          (∀x. x ∈ s ⇒ f x = g x) ∧ f continuous (at a within t) ⇒
          g continuous (at a within t)
   
   [<a name="CONTINUOUS_TRANSFORM_WITHIN_SET_IMP-val"><b>CONTINUOUS_TRANSFORM_WITHIN_SET_IMP</b></a>]  Theorem
      
      ⊢ ∀f a s t.
          eventually (λx. x ∈ t ⇒ x ∈ s) (at a) ∧
          f continuous (at a within s) ⇒
          f continuous (at a within t)
   
   [<a name="CONTINUOUS_TRIVIAL_LIMIT-val"><b>CONTINUOUS_TRIVIAL_LIMIT</b></a>]  Theorem
      
      ⊢ ∀f net. trivial_limit net ⇒ f continuous net
   
   [<a name="CONTINUOUS_UNIFORM_LIMIT-val"><b>CONTINUOUS_UNIFORM_LIMIT</b></a>]  Theorem
      
      ⊢ ∀net f g s.
          ¬trivial_limit net ∧ eventually (λn. f n continuous_on s) net ∧
          (∀e. 0 &lt; e ⇒
               eventually (λn. ∀x. x ∈ s ⇒ abs (f n x − g x) &lt; e) net) ⇒
          g continuous_on s
   
   [<a name="CONTINUOUS_VMUL-val"><b>CONTINUOUS_VMUL</b></a>]  Theorem
      
      ⊢ ∀net c v. c continuous net ⇒ (λx. c x * v) continuous net
   
   [<a name="CONTINUOUS_WITHIN-val"><b>CONTINUOUS_WITHIN</b></a>]  Theorem
      
      ⊢ ∀f x. f continuous (at x within s) ⇔ (f ⟶ f x) (at x within s)
   
   [<a name="CONTINUOUS_WITHIN_AVOID-val"><b>CONTINUOUS_WITHIN_AVOID</b></a>]  Theorem
      
      ⊢ ∀f x s a.
          f continuous (at x within s) ∧ x ∈ s ∧ f x ≠ a ⇒
          ∃e. 0 &lt; e ∧ ∀y. y ∈ s ∧ dist (x,y) &lt; e ⇒ f y ≠ a
   
   [<a name="CONTINUOUS_WITHIN_BALL-val"><b>CONTINUOUS_WITHIN_BALL</b></a>]  Theorem
      
      ⊢ ∀f s x.
          f continuous (at x within s) ⇔
          ∀e. 0 &lt; e ⇒ ∃d. 0 &lt; d ∧ IMAGE f (ball (x,d) ∩ s) ⊆ ball (f x,e)
   
   [<a name="CONTINUOUS_WITHIN_CLOSED_NONTRIVIAL-val"><b>CONTINUOUS_WITHIN_CLOSED_NONTRIVIAL</b></a>]  Theorem
      
      ⊢ ∀a s. closed s ∧ a ∉ s ⇒ f continuous (at a within s)
   
   [<a name="CONTINUOUS_WITHIN_COMPARISON-val"><b>CONTINUOUS_WITHIN_COMPARISON</b></a>]  Theorem
      
      ⊢ ∀f g s a.
          g continuous (at a within s) ∧
          (∀x. x ∈ s ⇒ dist (f a,f x) ≤ dist (g a,g x)) ⇒
          f continuous (at a within s)
   
   [<a name="CONTINUOUS_WITHIN_COMPOSE-val"><b>CONTINUOUS_WITHIN_COMPOSE</b></a>]  Theorem
      
      ⊢ ∀f g x s.
          f continuous (at x within s) ∧
          g continuous (at (f x) within IMAGE f s) ⇒
          g ∘ f continuous (at x within s)
   
   [<a name="CONTINUOUS_WITHIN_ID-val"><b>CONTINUOUS_WITHIN_ID</b></a>]  Theorem
      
      ⊢ ∀a s. (λx. x) continuous (at a within s)
   
   [<a name="CONTINUOUS_WITHIN_OPEN-val"><b>CONTINUOUS_WITHIN_OPEN</b></a>]  Theorem
      
      ⊢ ∀f x u.
          f continuous (at x within u) ⇔
          ∀t. open t ∧ f x ∈ t ⇒
              ∃s. open s ∧ x ∈ s ∧ ∀x'. x' ∈ s ∧ x' ∈ u ⇒ f x' ∈ t
   
   [<a name="CONTINUOUS_WITHIN_SEQUENTIALLY-val"><b>CONTINUOUS_WITHIN_SEQUENTIALLY</b></a>]  Theorem
      
      ⊢ ∀f s a.
          f continuous (at a within s) ⇔
          ∀x. (∀n. x n ∈ s) ∧ (x ⟶ a) sequentially ⇒
              (f ∘ x ⟶ f a) sequentially
   
   [<a name="CONTINUOUS_WITHIN_SUBSET-val"><b>CONTINUOUS_WITHIN_SUBSET</b></a>]  Theorem
      
      ⊢ ∀f s t x.
          f continuous (at x within s) ∧ t ⊆ s ⇒
          f continuous (at x within t)
   
   [<a name="CONTRACTION_IMP_CONTINUOUS_ON-val"><b>CONTRACTION_IMP_CONTINUOUS_ON</b></a>]  Theorem
      
      ⊢ ∀f. (∀x y. x ∈ s ∧ y ∈ s ⇒ dist (f x,f y) ≤ dist (x,y)) ⇒
            f continuous_on s
   
   [<a name="CONVERGENT_BOUNDED_INCREASING-val"><b>CONVERGENT_BOUNDED_INCREASING</b></a>]  Theorem
      
      ⊢ ∀s b.
          (∀m n. m ≤ n ⇒ s m ≤ s n) ∧ (∀n. abs (s n) ≤ b) ⇒
          ∃l. ∀e. 0 &lt; e ⇒ ∃N. ∀n. N ≤ n ⇒ abs (s n − l) &lt; e
   
   [<a name="CONVERGENT_BOUNDED_MONOTONE-val"><b>CONVERGENT_BOUNDED_MONOTONE</b></a>]  Theorem
      
      ⊢ ∀s b.
          (∀n. abs (s n) ≤ b) ∧
          ((∀m n. m ≤ n ⇒ s m ≤ s n) ∨ ∀m n. m ≤ n ⇒ s n ≤ s m) ⇒
          ∃l. ∀e. 0 &lt; e ⇒ ∃N. ∀n. N ≤ n ⇒ abs (s n − l) &lt; e
   
   [<a name="CONVERGENT_EQ_CAUCHY-val"><b>CONVERGENT_EQ_CAUCHY</b></a>]  Theorem
      
      ⊢ ∀s. (∃l. (s ⟶ l) sequentially) ⇔ cauchy s
   
   [<a name="CONVERGENT_IMP_BOUNDED-val"><b>CONVERGENT_IMP_BOUNDED</b></a>]  Theorem
      
      ⊢ ∀s l. (s ⟶ l) sequentially ⇒ bounded (IMAGE s 𝕌(:num))
   
   [<a name="CONVERGENT_IMP_CAUCHY-val"><b>CONVERGENT_IMP_CAUCHY</b></a>]  Theorem
      
      ⊢ ∀s l. (s ⟶ l) sequentially ⇒ cauchy s
   
   [<a name="COUNTABLE_OPEN_INTERVAL-val"><b>COUNTABLE_OPEN_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀a b. countable (interval (a,b)) ⇔ interval (a,b) = ∅
   
   [<a name="DECREASING_CLOSED_NEST-val"><b>DECREASING_CLOSED_NEST</b></a>]  Theorem
      
      ⊢ ∀s. (∀n. closed (s n)) ∧ (∀n. s n ≠ ∅) ∧
            (∀m n. m ≤ n ⇒ s n ⊆ s m) ∧
            (∀e. 0 &lt; e ⇒ ∃n. ∀x y. x ∈ s n ∧ y ∈ s n ⇒ dist (x,y) &lt; e) ⇒
            ∃a. ∀n. a ∈ s n
   
   [<a name="DECREASING_CLOSED_NEST_SING-val"><b>DECREASING_CLOSED_NEST_SING</b></a>]  Theorem
      
      ⊢ ∀s. (∀n. closed (s n)) ∧ (∀n. s n ≠ ∅) ∧
            (∀m n. m ≤ n ⇒ s n ⊆ s m) ∧
            (∀e. 0 &lt; e ⇒ ∃n. ∀x y. x ∈ s n ∧ y ∈ s n ⇒ dist (x,y) &lt; e) ⇒
            ∃a. BIGINTER {t | (∃n. t = s n)} = {a}
   
   [<a name="DENSE_IMP_PERFECT-val"><b>DENSE_IMP_PERFECT</b></a>]  Theorem
      
      ⊢ ∀s. closure s = 𝕌(:real) ⇒ ∀x. x ∈ s ⇒ x limit_point_of s
   
   [<a name="DENSE_LIMIT_POINTS-val"><b>DENSE_LIMIT_POINTS</b></a>]  Theorem
      
      ⊢ ∀x. {x | x limit_point_of s} = 𝕌(:real) ⇔ closure s = 𝕌(:real)
   
   [<a name="DENSE_OPEN_INTER-val"><b>DENSE_OPEN_INTER</b></a>]  Theorem
      
      ⊢ ∀s t u.
          open_in (subtopology euclidean u) s ∧ t ⊆ u ∨
          open_in (subtopology euclidean u) t ∧ s ⊆ u ⇒
          (u ⊆ closure (s ∩ t) ⇔ u ⊆ closure s ∧ u ⊆ closure t)
   
   [<a name="DEPENDENT_CHOICE-val"><b>DEPENDENT_CHOICE</b></a>]  Theorem
      
      ⊢ ∀P R.
          (∃a. P 0 a) ∧ (∀n x. P n x ⇒ ∃y. P (SUC n) y ∧ R n x y) ⇒
          ∃f. (∀n. P n (f n)) ∧ ∀n. R n (f n) (f (SUC n))
   
   [<a name="DEPENDENT_CHOICE_FIXED-val"><b>DEPENDENT_CHOICE_FIXED</b></a>]  Theorem
      
      ⊢ ∀P R a.
          P 0 a ∧ (∀n x. P n x ⇒ ∃y. P (SUC n) y ∧ R n x y) ⇒
          ∃f. f 0 = a ∧ (∀n. P n (f n)) ∧ ∀n. R n (f n) (f (SUC n))
   
   [<a name="DEPENDENT_EXPLICIT-val"><b>DEPENDENT_EXPLICIT</b></a>]  Theorem
      
      ⊢ ∀p. dependent p ⇔
            ∃s u.
              FINITE s ∧ s ⊆ p ∧ (∃v. v ∈ s ∧ u v ≠ 0) ∧
              sum s (λv. u v * v) = 0
   
   [<a name="DEPENDENT_MONO-val"><b>DEPENDENT_MONO</b></a>]  Theorem
      
      ⊢ ∀s t. dependent s ∧ s ⊆ t ⇒ dependent t
   
   [<a name="DIAMETER_BALL-val"><b>DIAMETER_BALL</b></a>]  Theorem
      
      ⊢ ∀a r. diameter (ball (a,r)) = if r &lt; 0 then 0 else 2 * r
   
   [<a name="DIAMETER_BOUNDED-val"><b>DIAMETER_BOUNDED</b></a>]  Theorem
      
      ⊢ ∀s. bounded s ⇒
            (∀x y. x ∈ s ∧ y ∈ s ⇒ abs (x − y) ≤ diameter s) ∧
            ∀d. 0 ≤ d ∧ d &lt; diameter s ⇒
                ∃x y. x ∈ s ∧ y ∈ s ∧ abs (x − y) &gt; d
   
   [<a name="DIAMETER_BOUNDED_BOUND-val"><b>DIAMETER_BOUNDED_BOUND</b></a>]  Theorem
      
      ⊢ ∀s x y. bounded s ∧ x ∈ s ∧ y ∈ s ⇒ abs (x − y) ≤ diameter s
   
   [<a name="DIAMETER_CBALL-val"><b>DIAMETER_CBALL</b></a>]  Theorem
      
      ⊢ ∀a r. diameter (cball (a,r)) = if r &lt; 0 then 0 else 2 * r
   
   [<a name="DIAMETER_CLOSURE-val"><b>DIAMETER_CLOSURE</b></a>]  Theorem
      
      ⊢ ∀s. bounded s ⇒ diameter (closure s) = diameter s
   
   [<a name="DIAMETER_EMPTY-val"><b>DIAMETER_EMPTY</b></a>]  Theorem
      
      ⊢ diameter ∅ = 0
   
   [<a name="DIAMETER_EQ_0-val"><b>DIAMETER_EQ_0</b></a>]  Theorem
      
      ⊢ ∀s. bounded s ⇒ (diameter s = 0 ⇔ s = ∅ ∨ ∃a. s = {a})
   
   [<a name="DIAMETER_INTERVAL-val"><b>DIAMETER_INTERVAL</b></a>]  Theorem
      
      ⊢ (∀a b.
           diameter (interval [(a,b)]) =
           if interval [(a,b)] = ∅ then 0 else abs (b − a)) ∧
        ∀a b.
          diameter (interval (a,b)) =
          if interval (a,b) = ∅ then 0 else abs (b − a)
   
   [<a name="DIAMETER_LE-val"><b>DIAMETER_LE</b></a>]  Theorem
      
      ⊢ ∀s d.
          (s ≠ ∅ ∨ 0 ≤ d) ∧ (∀x y. x ∈ s ∧ y ∈ s ⇒ abs (x − y) ≤ d) ⇒
          diameter s ≤ d
   
   [<a name="DIAMETER_LINEAR_IMAGE-val"><b>DIAMETER_LINEAR_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s.
          linear f ∧ (∀x. abs (f x) = abs x) ⇒
          diameter (IMAGE f s) = diameter s
   
   [<a name="DIAMETER_POS_LE-val"><b>DIAMETER_POS_LE</b></a>]  Theorem
      
      ⊢ ∀s. bounded s ⇒ 0 ≤ diameter s
   
   [<a name="DIAMETER_SING-val"><b>DIAMETER_SING</b></a>]  Theorem
      
      ⊢ ∀a. diameter {a} = 0
   
   [<a name="DIAMETER_SUBSET-val"><b>DIAMETER_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t. s ⊆ t ∧ bounded t ⇒ diameter s ≤ diameter t
   
   [<a name="DIAMETER_SUBSET_CBALL-val"><b>DIAMETER_SUBSET_CBALL</b></a>]  Theorem
      
      ⊢ ∀s. bounded s ⇒ ∃z. s ⊆ cball (z,diameter s)
   
   [<a name="DIAMETER_SUBSET_CBALL_NONEMPTY-val"><b>DIAMETER_SUBSET_CBALL_NONEMPTY</b></a>]  Theorem
      
      ⊢ ∀s. bounded s ∧ s ≠ ∅ ⇒ ∃z. z ∈ s ∧ s ⊆ cball (z,diameter s)
   
   [<a name="DIAMETER_SUMS-val"><b>DIAMETER_SUMS</b></a>]  Theorem
      
      ⊢ ∀s t.
          bounded s ∧ bounded t ⇒
          diameter {x + y | x ∈ s ∧ y ∈ t} ≤ diameter s + diameter t
   
   [<a name="DIFF_CLOSURE_SUBSET-val"><b>DIFF_CLOSURE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t. closure s DIFF closure t ⊆ closure (s DIFF t)
   
   [<a name="DIM_LE_CARD-val"><b>DIM_LE_CARD</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ dim s ≤ CARD s
   
   [<a name="DIM_SUBSET-val"><b>DIM_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t. s ⊆ t ⇒ dim s ≤ dim t
   
   [<a name="DIM_SUBSET_UNIV-val"><b>DIM_SUBSET_UNIV</b></a>]  Theorem
      
      ⊢ ∀s. dim s ≤ 1
   
   [<a name="DIM_SUBSTANDARD-val"><b>DIM_SUBSTANDARD</b></a>]  Theorem
      
      ⊢ dim {x | x = 0} = 0
   
   [<a name="DIM_UNIQUE-val"><b>DIM_UNIQUE</b></a>]  Theorem
      
      ⊢ ∀v b. b ⊆ v ∧ v ⊆ span b ∧ independent b ∧ b HAS_SIZE n ⇒ dim v = n
   
   [<a name="DIM_UNIV-val"><b>DIM_UNIV</b></a>]  Theorem
      
      ⊢ dim 𝕌(:real) = 1
   
   [<a name="DINI-val"><b>DINI</b></a>]  Theorem
      
      ⊢ ∀f g s.
          compact s ∧ (∀n. f n continuous_on s) ∧ g continuous_on s ∧
          (∀x. x ∈ s ⇒ ((λn. f n x) ⟶ g x) sequentially) ∧
          (∀n x. x ∈ s ⇒ f n x ≤ f (n + 1) x) ⇒
          ∀e. 0 &lt; e ⇒
              eventually (λn. ∀x. x ∈ s ⇒ abs (f n x − g x) &lt; e)
                sequentially
   
   [<a name="DISCRETE_BOUNDED_IMP_FINITE-val"><b>DISCRETE_BOUNDED_IMP_FINITE</b></a>]  Theorem
      
      ⊢ ∀s e.
          0 &lt; e ∧ (∀x y. x ∈ s ∧ y ∈ s ∧ abs (y − x) &lt; e ⇒ y = x) ∧
          bounded s ⇒
          FINITE s
   
   [<a name="DISCRETE_IMP_CLOSED-val"><b>DISCRETE_IMP_CLOSED</b></a>]  Theorem
      
      ⊢ ∀s e.
          0 &lt; e ∧ (∀x y. x ∈ s ∧ y ∈ s ∧ abs (y − x) &lt; e ⇒ y = x) ⇒
          closed s
   
   [<a name="DISJOINT_INTERVAL-val"><b>DISJOINT_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀a b c d.
          (interval [(a,b)] ∩ interval [(c,d)] = ∅ ⇔
           b &lt; a ∨ d &lt; c ∨ b &lt; c ∨ d &lt; a) ∧
          (interval [(a,b)] ∩ interval (c,d) = ∅ ⇔
           b &lt; a ∨ d ≤ c ∨ b ≤ c ∨ d ≤ a) ∧
          (interval (a,b) ∩ interval [(c,d)] = ∅ ⇔
           b ≤ a ∨ d &lt; c ∨ b ≤ c ∨ d ≤ a) ∧
          (interval (a,b) ∩ interval (c,d) = ∅ ⇔
           b ≤ a ∨ d ≤ c ∨ b ≤ c ∨ d ≤ a)
   
   [<a name="DISTANCE_ATTAINS_INF-val"><b>DISTANCE_ATTAINS_INF</b></a>]  Theorem
      
      ⊢ ∀s a.
          closed s ∧ s ≠ ∅ ⇒
          ∃x. x ∈ s ∧ ∀y. y ∈ s ⇒ dist (a,x) ≤ dist (a,y)
   
   [<a name="DISTANCE_ATTAINS_SUP-val"><b>DISTANCE_ATTAINS_SUP</b></a>]  Theorem
      
      ⊢ ∀s a.
          compact s ∧ s ≠ ∅ ⇒
          ∃x. x ∈ s ∧ ∀y. y ∈ s ⇒ dist (a,y) ≤ dist (a,x)
   
   [<a name="DIST_0-val"><b>DIST_0</b></a>]  Theorem
      
      ⊢ ∀x. dist (x,0) = abs x ∧ dist (0,x) = abs x
   
   [<a name="DIST_CLOSEST_POINT_LIPSCHITZ-val"><b>DIST_CLOSEST_POINT_LIPSCHITZ</b></a>]  Theorem
      
      ⊢ ∀s x y.
          closed s ∧ s ≠ ∅ ⇒
          abs (dist (x,closest_point s x) − dist (y,closest_point s y)) ≤
          dist (x,y)
   
   [<a name="DIST_EQ-val"><b>DIST_EQ</b></a>]  Theorem
      
      ⊢ ∀w x y z. dist (w,x) = dist (y,z) ⇔ (dist (w,x))² = (dist (y,z))²
   
   [<a name="DIST_EQ_0-val"><b>DIST_EQ_0</b></a>]  Theorem
      
      ⊢ ∀x y. dist (x,y) = 0 ⇔ x = y
   
   [<a name="DIST_IN_CLOSED_SEGMENT-val"><b>DIST_IN_CLOSED_SEGMENT</b></a>]  Theorem
      
      ⊢ ∀a b x.
          x ∈ segment [(a,b)] ⇒
          dist (x,a) ≤ dist (a,b) ∧ dist (x,b) ≤ dist (a,b)
   
   [<a name="DIST_IN_OPEN_CLOSED_SEGMENT-val"><b>DIST_IN_OPEN_CLOSED_SEGMENT</b></a>]  Theorem
      
      ⊢ (∀a b x.
           x ∈ segment [(a,b)] ⇒
           dist (x,a) ≤ dist (a,b) ∧ dist (x,b) ≤ dist (a,b)) ∧
        ∀a b x.
          x ∈ segment (a,b) ⇒
          dist (x,a) &lt; dist (a,b) ∧ dist (x,b) &lt; dist (a,b)
   
   [<a name="DIST_IN_OPEN_SEGMENT-val"><b>DIST_IN_OPEN_SEGMENT</b></a>]  Theorem
      
      ⊢ ∀a b x.
          x ∈ segment (a,b) ⇒
          dist (x,a) &lt; dist (a,b) ∧ dist (x,b) &lt; dist (a,b)
   
   [<a name="DIST_LE_0-val"><b>DIST_LE_0</b></a>]  Theorem
      
      ⊢ ∀x y. dist (x,y) ≤ 0 ⇔ x = y
   
   [<a name="DIST_MIDPOINT-val"><b>DIST_MIDPOINT</b></a>]  Theorem
      
      ⊢ ∀a b.
          dist (a,midpoint (a,b)) = dist (a,b) / 2 ∧
          dist (b,midpoint (a,b)) = dist (a,b) / 2 ∧
          dist (midpoint (a,b),a) = dist (a,b) / 2 ∧
          dist (midpoint (a,b),b) = dist (a,b) / 2
   
   [<a name="DIST_MUL-val"><b>DIST_MUL</b></a>]  Theorem
      
      ⊢ ∀x y c. dist (c * x,c * y) = abs c * dist (x,y)
   
   [<a name="DIST_NZ-val"><b>DIST_NZ</b></a>]  Theorem
      
      ⊢ ∀x y. x ≠ y ⇔ 0 &lt; dist (x,y)
   
   [<a name="DIST_POS_LE-val"><b>DIST_POS_LE</b></a>]  Theorem
      
      ⊢ ∀x y. 0 ≤ dist (x,y)
   
   [<a name="DIST_POS_LT-val"><b>DIST_POS_LT</b></a>]  Theorem
      
      ⊢ ∀x y. x ≠ y ⇒ 0 &lt; dist (x,y)
   
   [<a name="DIST_REFL-val"><b>DIST_REFL</b></a>]  Theorem
      
      ⊢ ∀x. dist (x,x) = 0
   
   [<a name="DIST_SYM-val"><b>DIST_SYM</b></a>]  Theorem
      
      ⊢ ∀x y. dist (x,y) = dist (y,x)
   
   [<a name="DIST_TRIANGLE-val"><b>DIST_TRIANGLE</b></a>]  Theorem
      
      ⊢ ∀x y z. dist (x,z) ≤ dist (x,y) + dist (y,z)
   
   [<a name="DIST_TRIANGLE_ADD-val"><b>DIST_TRIANGLE_ADD</b></a>]  Theorem
      
      ⊢ ∀x x' y y'. dist (x + y,x' + y') ≤ dist (x,x') + dist (y,y')
   
   [<a name="DIST_TRIANGLE_ADD_HALF-val"><b>DIST_TRIANGLE_ADD_HALF</b></a>]  Theorem
      
      ⊢ ∀x x' y y'.
          dist (x,x') &lt; e / 2 ∧ dist (y,y') &lt; e / 2 ⇒
          dist (x + y,x' + y') &lt; e
   
   [<a name="DIST_TRIANGLE_ALT-val"><b>DIST_TRIANGLE_ALT</b></a>]  Theorem
      
      ⊢ ∀x y z. dist (y,z) ≤ dist (x,y) + dist (x,z)
   
   [<a name="DIST_TRIANGLE_EQ-val"><b>DIST_TRIANGLE_EQ</b></a>]  Theorem
      
      ⊢ ∀x y z.
          dist (x,z) = dist (x,y) + dist (y,z) ⇔
          abs (x − y) * (y − z) = abs (y − z) * (x − y)
   
   [<a name="DIST_TRIANGLE_HALF_L-val"><b>DIST_TRIANGLE_HALF_L</b></a>]  Theorem
      
      ⊢ ∀x1 x2 y.
          dist (x1,y) &lt; e / 2 ∧ dist (x2,y) &lt; e / 2 ⇒ dist (x1,x2) &lt; e
   
   [<a name="DIST_TRIANGLE_HALF_R-val"><b>DIST_TRIANGLE_HALF_R</b></a>]  Theorem
      
      ⊢ ∀x1 x2 y.
          dist (y,x1) &lt; e / 2 ∧ dist (y,x2) &lt; e / 2 ⇒ dist (x1,x2) &lt; e
   
   [<a name="DIST_TRIANGLE_LE-val"><b>DIST_TRIANGLE_LE</b></a>]  Theorem
      
      ⊢ ∀x y z e. dist (x,z) + dist (y,z) ≤ e ⇒ dist (x,y) ≤ e
   
   [<a name="DIST_TRIANGLE_LT-val"><b>DIST_TRIANGLE_LT</b></a>]  Theorem
      
      ⊢ ∀x y z e. dist (x,z) + dist (y,z) &lt; e ⇒ dist (x,y) &lt; e
   
   [<a name="DORDER_NET-val"><b>DORDER_NET</b></a>]  Theorem
      
      ⊢ ∀n. dorder (netord n)
   
   [<a name="EMPTY_AS_INTERVAL-val"><b>EMPTY_AS_INTERVAL</b></a>]  Theorem
      
      ⊢ ∅ = interval [(1,0)]
   
   [<a name="EMPTY_INTERIOR_FINITE-val"><b>EMPTY_INTERIOR_FINITE</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ interior s = ∅
   
   [<a name="ENDS_IN_INTERVAL-val"><b>ENDS_IN_INTERVAL</b></a>]  Theorem
      
      ⊢ (∀a b. a ∈ interval [(a,b)] ⇔ interval [(a,b)] ≠ ∅) ∧
        (∀a b. b ∈ interval [(a,b)] ⇔ interval [(a,b)] ≠ ∅) ∧
        (∀a b. a ∉ interval (a,b)) ∧ ∀a b. b ∉ interval (a,b)
   
   [<a name="ENDS_IN_SEGMENT-val"><b>ENDS_IN_SEGMENT</b></a>]  Theorem
      
      ⊢ ∀a b. a ∈ segment [(a,b)] ∧ b ∈ segment [(a,b)]
   
   [<a name="ENDS_IN_UNIT_INTERVAL-val"><b>ENDS_IN_UNIT_INTERVAL</b></a>]  Theorem
      
      ⊢ 0 ∈ interval [(0,1)] ∧ 1 ∈ interval [(0,1)] ∧ 0 ∉ interval (0,1) ∧
        1 ∉ interval (0,1)
   
   [<a name="ENDS_NOT_IN_SEGMENT-val"><b>ENDS_NOT_IN_SEGMENT</b></a>]  Theorem
      
      ⊢ ∀a b. a ∉ segment (a,b) ∧ b ∉ segment (a,b)
   
   [<a name="EQ_BALLS-val"><b>EQ_BALLS</b></a>]  Theorem
      
      ⊢ (∀a a' r r'.
           ball (a,r) = ball (a',r') ⇔ a = a' ∧ r = r' ∨ r ≤ 0 ∧ r' ≤ 0) ∧
        (∀a a' r r'. ball (a,r) = cball (a',r') ⇔ r ≤ 0 ∧ r' &lt; 0) ∧
        (∀a a' r r'. cball (a,r) = ball (a',r') ⇔ r &lt; 0 ∧ r' ≤ 0) ∧
        ∀a a' r r'.
          cball (a,r) = cball (a',r') ⇔ a = a' ∧ r = r' ∨ r &lt; 0 ∧ r' &lt; 0
   
   [<a name="EQ_INTERVAL-val"><b>EQ_INTERVAL</b></a>]  Theorem
      
      ⊢ (∀a b c d.
           interval [(a,b)] = interval [(c,d)] ⇔
           interval [(a,b)] = ∅ ∧ interval [(c,d)] = ∅ ∨ a = c ∧ b = d) ∧
        (∀a b c d.
           interval [(a,b)] = interval (c,d) ⇔
           interval [(a,b)] = ∅ ∧ interval (c,d) = ∅) ∧
        (∀a b c d.
           interval (a,b) = interval [(c,d)] ⇔
           interval (a,b) = ∅ ∧ interval [(c,d)] = ∅) ∧
        ∀a b c d.
          interval (a,b) = interval (c,d) ⇔
          interval (a,b) = ∅ ∧ interval (c,d) = ∅ ∨ a = c ∧ b = d
   
   [<a name="EVENTUALLY_AND-val"><b>EVENTUALLY_AND</b></a>]  Theorem
      
      ⊢ ∀net p q.
          eventually (λx. p x ∧ q x) net ⇔
          eventually p net ∧ eventually q net
   
   [<a name="EVENTUALLY_AT-val"><b>EVENTUALLY_AT</b></a>]  Theorem
      
      ⊢ ∀a p.
          eventually p (at a) ⇔
          ∃d. 0 &lt; d ∧ ∀x. 0 &lt; dist (x,a) ∧ dist (x,a) &lt; d ⇒ p x
   
   [<a name="EVENTUALLY_AT_INFINITY-val"><b>EVENTUALLY_AT_INFINITY</b></a>]  Theorem
      
      ⊢ ∀p. eventually p at_infinity ⇔ ∃b. ∀x. abs x ≥ b ⇒ p x
   
   [<a name="EVENTUALLY_AT_INFINITY_POS-val"><b>EVENTUALLY_AT_INFINITY_POS</b></a>]  Theorem
      
      ⊢ ∀p. eventually p at_infinity ⇔ ∃b. 0 &lt; b ∧ ∀x. abs x ≥ b ⇒ p x
   
   [<a name="EVENTUALLY_AT_NEGINFINITY-val"><b>EVENTUALLY_AT_NEGINFINITY</b></a>]  Theorem
      
      ⊢ ∀p. eventually p at_neginfinity ⇔ ∃b. ∀x. x ≤ b ⇒ p x
   
   [<a name="EVENTUALLY_AT_POSINFINITY-val"><b>EVENTUALLY_AT_POSINFINITY</b></a>]  Theorem
      
      ⊢ ∀p. eventually p at_posinfinity ⇔ ∃b. ∀x. x ≥ b ⇒ p x
   
   [<a name="EVENTUALLY_FALSE-val"><b>EVENTUALLY_FALSE</b></a>]  Theorem
      
      ⊢ ∀net. eventually (λx. F) net ⇔ trivial_limit net
   
   [<a name="EVENTUALLY_FORALL-val"><b>EVENTUALLY_FORALL</b></a>]  Theorem
      
      ⊢ ∀net p s.
          FINITE s ∧ s ≠ ∅ ⇒
          (eventually (λx. ∀a. a ∈ s ⇒ p a x) net ⇔
           ∀a. a ∈ s ⇒ eventually (p a) net)
   
   [<a name="EVENTUALLY_HAPPENS-val"><b>EVENTUALLY_HAPPENS</b></a>]  Theorem
      
      ⊢ ∀net p. eventually p net ⇒ trivial_limit net ∨ ∃x. p x
   
   [<a name="EVENTUALLY_MONO-val"><b>EVENTUALLY_MONO</b></a>]  Theorem
      
      ⊢ ∀net p q. (∀x. p x ⇒ q x) ∧ eventually p net ⇒ eventually q net
   
   [<a name="EVENTUALLY_MP-val"><b>EVENTUALLY_MP</b></a>]  Theorem
      
      ⊢ ∀net p q.
          eventually (λx. p x ⇒ q x) net ∧ eventually p net ⇒
          eventually q net
   
   [<a name="EVENTUALLY_SEQUENTIALLY-val"><b>EVENTUALLY_SEQUENTIALLY</b></a>]  Theorem
      
      ⊢ ∀p. eventually p sequentially ⇔ ∃N. ∀n. N ≤ n ⇒ p n
   
   [<a name="EVENTUALLY_TRUE-val"><b>EVENTUALLY_TRUE</b></a>]  Theorem
      
      ⊢ ∀net. eventually (λx. T) net ⇔ T
   
   [<a name="EVENTUALLY_WITHIN-val"><b>EVENTUALLY_WITHIN</b></a>]  Theorem
      
      ⊢ ∀s a p.
          eventually p (at a within s) ⇔
          ∃d. 0 &lt; d ∧ ∀x. x ∈ s ∧ 0 &lt; dist (x,a) ∧ dist (x,a) &lt; d ⇒ p x
   
   [<a name="EVENTUALLY_WITHIN_INTERIOR-val"><b>EVENTUALLY_WITHIN_INTERIOR</b></a>]  Theorem
      
      ⊢ ∀p s x.
          x ∈ interior s ⇒
          (eventually p (at x within s) ⇔ eventually p (at x))
   
   [<a name="EVENTUALLY_WITHIN_LE-val"><b>EVENTUALLY_WITHIN_LE</b></a>]  Theorem
      
      ⊢ ∀s a p.
          eventually p (at a within s) ⇔
          ∃d. 0 &lt; d ∧ ∀x. x ∈ s ∧ 0 &lt; dist (x,a) ∧ dist (x,a) ≤ d ⇒ p x
   
   [<a name="EXCHANGE_LEMMA-val"><b>EXCHANGE_LEMMA</b></a>]  Theorem
      
      ⊢ ∀s t.
          FINITE t ∧ independent s ∧ s ⊆ span t ⇒
          ∃t'. t' HAS_SIZE CARD t ∧ s ⊆ t' ∧ t' ⊆ s ∪ t ∧ s ⊆ span t'
   
   [<a name="EXISTS_COMPONENT_SUPERSET-val"><b>EXISTS_COMPONENT_SUPERSET</b></a>]  Theorem
      
      ⊢ ∀s t. t ⊆ s ∧ s ≠ ∅ ∧ connected t ⇒ ∃c. c ∈ components s ∧ t ⊆ c
   
   [<a name="EXISTS_DIFF-val"><b>EXISTS_DIFF</b></a>]  Theorem
      
      ⊢ (∃s. P (𝕌(:α) DIFF s)) ⇔ ∃s. P s
   
   [<a name="EXISTS_IN_INSERT-val"><b>EXISTS_IN_INSERT</b></a>]  Theorem
      
      ⊢ ∀P a s. (∃x. x ∈ a INSERT s ∧ P x) ⇔ P a ∨ ∃x. x ∈ s ∧ P x
   
   [<a name="EXTENSION_FROM_CLOPEN-val"><b>EXTENSION_FROM_CLOPEN</b></a>]  Theorem
      
      ⊢ ∀f s t u.
          open_in (subtopology euclidean s) t ∧
          closed_in (subtopology euclidean s) t ∧ f continuous_on t ∧
          IMAGE f t ⊆ u ∧ (u = ∅ ⇒ s = ∅) ⇒
          ∃g. g continuous_on s ∧ IMAGE g s ⊆ u ∧ ∀x. x ∈ t ⇒ g x = f x
   
   [<a name="FINITE_BALL-val"><b>FINITE_BALL</b></a>]  Theorem
      
      ⊢ ∀a r. FINITE (ball (a,r)) ⇔ r ≤ 0
   
   [<a name="FINITE_CBALL-val"><b>FINITE_CBALL</b></a>]  Theorem
      
      ⊢ ∀a r. FINITE (cball (a,r)) ⇔ r ≤ 0
   
   [<a name="FINITE_IMP_BOUNDED-val"><b>FINITE_IMP_BOUNDED</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ bounded s
   
   [<a name="FINITE_IMP_CLOSED-val"><b>FINITE_IMP_CLOSED</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ closed s
   
   [<a name="FINITE_IMP_CLOSED_IN-val"><b>FINITE_IMP_CLOSED_IN</b></a>]  Theorem
      
      ⊢ ∀s t. FINITE s ∧ s ⊆ t ⇒ closed_in (subtopology euclidean t) s
   
   [<a name="FINITE_IMP_COMPACT-val"><b>FINITE_IMP_COMPACT</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ compact s
   
   [<a name="FINITE_IMP_NOT_OPEN-val"><b>FINITE_IMP_NOT_OPEN</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ∧ s ≠ ∅ ⇒ ¬open s
   
   [<a name="FINITE_INTERVAL-val"><b>FINITE_INTERVAL</b></a>]  Theorem
      
      ⊢ (∀a b. FINITE (interval [(a,b)]) ⇔ b ≤ a) ∧
        ∀a b. FINITE (interval (a,b)) ⇔ b ≤ a
   
   [<a name="FINITE_INTER_NUMSEG-val"><b>FINITE_INTER_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀s m n. FINITE (s ∩ {m .. n})
   
   [<a name="FINITE_SET_AVOID-val"><b>FINITE_SET_AVOID</b></a>]  Theorem
      
      ⊢ ∀a s. FINITE s ⇒ ∃d. 0 &lt; d ∧ ∀x. x ∈ s ∧ x ≠ a ⇒ d ≤ dist (a,x)
   
   [<a name="FINITE_SPHERE-val"><b>FINITE_SPHERE</b></a>]  Theorem
      
      ⊢ ∀a r. FINITE (sphere (a,r))
   
   [<a name="FORALL_EVENTUALLY-val"><b>FORALL_EVENTUALLY</b></a>]  Theorem
      
      ⊢ ∀net p s.
          FINITE s ∧ s ≠ ∅ ⇒
          ((∀a. a ∈ s ⇒ eventually (p a) net) ⇔
           eventually (λx. ∀a. a ∈ s ⇒ p a x) net)
   
   [<a name="FORALL_IN_CLOSURE-val"><b>FORALL_IN_CLOSURE</b></a>]  Theorem
      
      ⊢ ∀f s t.
          closed t ∧ f continuous_on closure s ∧ (∀x. x ∈ s ⇒ f x ∈ t) ⇒
          ∀x. x ∈ closure s ⇒ f x ∈ t
   
   [<a name="FORALL_IN_CLOSURE_EQ-val"><b>FORALL_IN_CLOSURE_EQ</b></a>]  Theorem
      
      ⊢ ∀f s t.
          closed t ∧ f continuous_on closure s ⇒
          ((∀x. x ∈ closure s ⇒ f x ∈ t) ⇔ ∀x. x ∈ s ⇒ f x ∈ t)
   
   [<a name="FORALL_POS_MONO_1-val"><b>FORALL_POS_MONO_1</b></a>]  Theorem
      
      ⊢ ∀P. (∀d e. d &lt; e ∧ P d ⇒ P e) ∧ (∀n. P (&n + 1)⁻¹) ⇒
            ∀e. 0 &lt; e ⇒ P e
   
   [<a name="FRONTIER_BALL-val"><b>FRONTIER_BALL</b></a>]  Theorem
      
      ⊢ ∀a e. 0 &lt; e ⇒ frontier (ball (a,e)) = sphere (a,e)
   
   [<a name="FRONTIER_CBALL-val"><b>FRONTIER_CBALL</b></a>]  Theorem
      
      ⊢ ∀a e. frontier (cball (a,e)) = sphere (a,e)
   
   [<a name="FRONTIER_CLOSED-val"><b>FRONTIER_CLOSED</b></a>]  Theorem
      
      ⊢ ∀s. closed (frontier s)
   
   [<a name="FRONTIER_CLOSED_INTERVAL-val"><b>FRONTIER_CLOSED_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀a b.
          frontier (interval [(a,b)]) =
          interval [(a,b)] DIFF interval (a,b)
   
   [<a name="FRONTIER_CLOSURES-val"><b>FRONTIER_CLOSURES</b></a>]  Theorem
      
      ⊢ ∀s. frontier s = closure s ∩ closure (𝕌(:real) DIFF s)
   
   [<a name="FRONTIER_CLOSURE_SUBSET-val"><b>FRONTIER_CLOSURE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s. frontier (closure s) ⊆ frontier s
   
   [<a name="FRONTIER_COMPLEMENT-val"><b>FRONTIER_COMPLEMENT</b></a>]  Theorem
      
      ⊢ ∀s. frontier (𝕌(:real) DIFF s) = frontier s
   
   [<a name="FRONTIER_DISJOINT_EQ-val"><b>FRONTIER_DISJOINT_EQ</b></a>]  Theorem
      
      ⊢ ∀s. frontier s ∩ s = ∅ ⇔ open s
   
   [<a name="FRONTIER_EMPTY-val"><b>FRONTIER_EMPTY</b></a>]  Theorem
      
      ⊢ frontier ∅ = ∅
   
   [<a name="FRONTIER_FRONTIER-val"><b>FRONTIER_FRONTIER</b></a>]  Theorem
      
      ⊢ ∀s. open s ∨ closed s ⇒ frontier (frontier s) = frontier s
   
   [<a name="FRONTIER_FRONTIER_FRONTIER-val"><b>FRONTIER_FRONTIER_FRONTIER</b></a>]  Theorem
      
      ⊢ ∀s. frontier (frontier (frontier s)) = frontier (frontier s)
   
   [<a name="FRONTIER_FRONTIER_SUBSET-val"><b>FRONTIER_FRONTIER_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s. frontier (frontier s) ⊆ frontier s
   
   [<a name="FRONTIER_HALFSPACE_GE-val"><b>FRONTIER_HALFSPACE_GE</b></a>]  Theorem
      
      ⊢ ∀a b. ¬(a = 0 ∧ b = 0) ⇒ frontier {x | a * x ≥ b} = {x | a * x = b}
   
   [<a name="FRONTIER_HALFSPACE_GT-val"><b>FRONTIER_HALFSPACE_GT</b></a>]  Theorem
      
      ⊢ ∀a b. ¬(a = 0 ∧ b = 0) ⇒ frontier {x | a * x &gt; b} = {x | a * x = b}
   
   [<a name="FRONTIER_HALFSPACE_LE-val"><b>FRONTIER_HALFSPACE_LE</b></a>]  Theorem
      
      ⊢ ∀a b. ¬(a = 0 ∧ b = 0) ⇒ frontier {x | a * x ≤ b} = {x | a * x = b}
   
   [<a name="FRONTIER_HALFSPACE_LT-val"><b>FRONTIER_HALFSPACE_LT</b></a>]  Theorem
      
      ⊢ ∀a b. ¬(a = 0 ∧ b = 0) ⇒ frontier {x | a * x &lt; b} = {x | a * x = b}
   
   [<a name="FRONTIER_INTERIORS-val"><b>FRONTIER_INTERIORS</b></a>]  Theorem
      
      ⊢ ∀s. frontier s =
            𝕌(:real) DIFF interior s DIFF interior (𝕌(:real) DIFF s)
   
   [<a name="FRONTIER_INTERIOR_SUBSET-val"><b>FRONTIER_INTERIOR_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s. frontier (interior s) ⊆ frontier s
   
   [<a name="FRONTIER_INTER_SUBSET-val"><b>FRONTIER_INTER_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t. frontier (s ∩ t) ⊆ frontier s ∪ frontier t
   
   [<a name="FRONTIER_INTER_SUBSET_INTER-val"><b>FRONTIER_INTER_SUBSET_INTER</b></a>]  Theorem
      
      ⊢ ∀s t.
          frontier (s ∩ t) ⊆
          closure s ∩ frontier t ∪ frontier s ∩ closure t
   
   [<a name="FRONTIER_OPEN_INTERVAL-val"><b>FRONTIER_OPEN_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀a b.
          frontier (interval (a,b)) =
          if interval (a,b) = ∅ then ∅
          else interval [(a,b)] DIFF interval (a,b)
   
   [<a name="FRONTIER_SING-val"><b>FRONTIER_SING</b></a>]  Theorem
      
      ⊢ ∀a. frontier {a} = {a}
   
   [<a name="FRONTIER_STRADDLE-val"><b>FRONTIER_STRADDLE</b></a>]  Theorem
      
      ⊢ ∀a s.
          a ∈ frontier s ⇔
          ∀e. 0 &lt; e ⇒
              (∃x. x ∈ s ∧ dist (a,x) &lt; e) ∧ ∃x. x ∉ s ∧ dist (a,x) &lt; e
   
   [<a name="FRONTIER_SUBSET_CLOSED-val"><b>FRONTIER_SUBSET_CLOSED</b></a>]  Theorem
      
      ⊢ ∀s. closed s ⇒ frontier s ⊆ s
   
   [<a name="FRONTIER_SUBSET_COMPACT-val"><b>FRONTIER_SUBSET_COMPACT</b></a>]  Theorem
      
      ⊢ ∀s. compact s ⇒ frontier s ⊆ s
   
   [<a name="FRONTIER_SUBSET_EQ-val"><b>FRONTIER_SUBSET_EQ</b></a>]  Theorem
      
      ⊢ ∀s. frontier s ⊆ s ⇔ closed s
   
   [<a name="FRONTIER_UNION-val"><b>FRONTIER_UNION</b></a>]  Theorem
      
      ⊢ ∀s t.
          closure s ∩ closure t = ∅ ⇒
          frontier (s ∪ t) = frontier s ∪ frontier t
   
   [<a name="FRONTIER_UNION_SUBSET-val"><b>FRONTIER_UNION_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t. frontier (s ∪ t) ⊆ frontier s ∪ frontier t
   
   [<a name="FRONTIER_UNIV-val"><b>FRONTIER_UNIV</b></a>]  Theorem
      
      ⊢ frontier 𝕌(:real) = ∅
   
   [<a name="FUNCTION_FACTORS_LEFT_GEN-val"><b>FUNCTION_FACTORS_LEFT_GEN</b></a>]  Theorem
      
      ⊢ ∀P f g.
          (∀x y. P x ∧ P y ∧ g x = g y ⇒ f x = f y) ⇔
          ∃h. ∀x. P x ⇒ f x = h (g x)
   
   [<a name="GDELTA_COMPLEMENT-val"><b>GDELTA_COMPLEMENT</b></a>]  Theorem
      
      ⊢ ∀s. gdelta (𝕌(:real) DIFF s) ⇔ fsigma s
   
   [<a name="GREATER_EQ_REFL-val"><b>GREATER_EQ_REFL</b></a>]  Theorem
      
      ⊢ ∀m. m ≥ m
   
   [<a name="HAS_SIZE_STDBASIS-val"><b>HAS_SIZE_STDBASIS</b></a>]  Theorem
      
      ⊢ {i | 1 ≤ i ∧ i ≤ 1} HAS_SIZE 1
   
   [<a name="HAUSDIST_ALT-val"><b>HAUSDIST_ALT</b></a>]  Theorem
      
      ⊢ ∀s t.
          bounded s ∧ bounded t ∧ s ≠ ∅ ∧ t ≠ ∅ ⇒
          hausdist (s,t) =
          sup {abs (setdist ({x},s) − setdist ({x},t)) | x ∈ 𝕌(:real)}
   
   [<a name="HAUSDIST_BALLS-val"><b>HAUSDIST_BALLS</b></a>]  Theorem
      
      ⊢ (∀a b r s.
           hausdist (ball (a,r),ball (b,s)) =
           if r ≤ 0 ∨ s ≤ 0 then 0 else dist (a,b) + abs (r − s)) ∧
        (∀a b r s.
           hausdist (ball (a,r),cball (b,s)) =
           if r ≤ 0 ∨ s &lt; 0 then 0 else dist (a,b) + abs (r − s)) ∧
        (∀a b r s.
           hausdist (cball (a,r),ball (b,s)) =
           if r &lt; 0 ∨ s ≤ 0 then 0 else dist (a,b) + abs (r − s)) ∧
        ∀a b r s.
          hausdist (cball (a,r),cball (b,s)) =
          if r &lt; 0 ∨ s &lt; 0 then 0 else dist (a,b) + abs (r − s)
   
   [<a name="HAUSDIST_CLOSURE-val"><b>HAUSDIST_CLOSURE</b></a>]  Theorem
      
      ⊢ (∀s t. hausdist (closure s,t) = hausdist (s,t)) ∧
        ∀s t. hausdist (s,closure t) = hausdist (s,t)
   
   [<a name="HAUSDIST_COMPACT_EXISTS-val"><b>HAUSDIST_COMPACT_EXISTS</b></a>]  Theorem
      
      ⊢ ∀s t.
          bounded s ∧ compact t ∧ t ≠ ∅ ⇒
          ∀x. x ∈ s ⇒ ∃y. y ∈ t ∧ dist (x,y) ≤ hausdist (s,t)
   
   [<a name="HAUSDIST_COMPACT_NONTRIVIAL-val"><b>HAUSDIST_COMPACT_NONTRIVIAL</b></a>]  Theorem
      
      ⊢ ∀s t.
          compact s ∧ compact t ∧ s ≠ ∅ ∧ t ≠ ∅ ⇒
          hausdist (s,t) =
          inf
            {e |
             0 ≤ e ∧ s ⊆ {x + y | x ∈ t ∧ abs y ≤ e} ∧
             t ⊆ {x + y | x ∈ s ∧ abs y ≤ e}}
   
   [<a name="HAUSDIST_COMPACT_SUMS-val"><b>HAUSDIST_COMPACT_SUMS</b></a>]  Theorem
      
      ⊢ ∀s t.
          bounded s ∧ compact t ∧ t ≠ ∅ ⇒
          s ⊆ {y + z | y ∈ t ∧ z ∈ cball (0,hausdist (s,t))}
   
   [<a name="HAUSDIST_EMPTY-val"><b>HAUSDIST_EMPTY</b></a>]  Theorem
      
      ⊢ (∀t. hausdist (∅,t) = 0) ∧ ∀s. hausdist (s,∅) = 0
   
   [<a name="HAUSDIST_EQ-val"><b>HAUSDIST_EQ</b></a>]  Theorem
      
      ⊢ ∀s t s' t'.
          (∀b. (∀x. x ∈ s ⇒ setdist ({x},t) ≤ b) ∧
               (∀y. y ∈ t ⇒ setdist ({y},s) ≤ b) ⇔
               (∀x. x ∈ s' ⇒ setdist ({x},t') ≤ b) ∧
               ∀y. y ∈ t' ⇒ setdist ({y},s') ≤ b) ⇒
          hausdist (s,t) = hausdist (s',t')
   
   [<a name="HAUSDIST_EQ_0-val"><b>HAUSDIST_EQ_0</b></a>]  Theorem
      
      ⊢ ∀s t.
          bounded s ∧ bounded t ⇒
          (hausdist (s,t) = 0 ⇔ s = ∅ ∨ t = ∅ ∨ closure s = closure t)
   
   [<a name="HAUSDIST_INSERT_LE-val"><b>HAUSDIST_INSERT_LE</b></a>]  Theorem
      
      ⊢ ∀s t a.
          bounded s ∧ bounded t ∧ s ≠ ∅ ∧ t ≠ ∅ ⇒
          hausdist (a INSERT s,a INSERT t) ≤ hausdist (s,t)
   
   [<a name="HAUSDIST_LINEAR_IMAGE-val"><b>HAUSDIST_LINEAR_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s t.
          linear f ∧ (∀x. abs (f x) = abs x) ⇒
          hausdist (IMAGE f s,IMAGE f t) = hausdist (s,t)
   
   [<a name="HAUSDIST_NONTRIVIAL-val"><b>HAUSDIST_NONTRIVIAL</b></a>]  Theorem
      
      ⊢ ∀s t.
          bounded s ∧ bounded t ∧ s ≠ ∅ ∧ t ≠ ∅ ⇒
          hausdist (s,t) =
          sup ({setdist ({x},t) | x ∈ s} ∪ {setdist ({y},s) | y ∈ t})
   
   [<a name="HAUSDIST_NONTRIVIAL_ALT-val"><b>HAUSDIST_NONTRIVIAL_ALT</b></a>]  Theorem
      
      ⊢ ∀s t.
          bounded s ∧ bounded t ∧ s ≠ ∅ ∧ t ≠ ∅ ⇒
          hausdist (s,t) =
          max (sup {setdist ({x},t) | x ∈ s})
            (sup {setdist ({y},s) | y ∈ t})
   
   [<a name="HAUSDIST_POS_LE-val"><b>HAUSDIST_POS_LE</b></a>]  Theorem
      
      ⊢ ∀s t. 0 ≤ hausdist (s,t)
   
   [<a name="HAUSDIST_REFL-val"><b>HAUSDIST_REFL</b></a>]  Theorem
      
      ⊢ ∀s. hausdist (s,s) = 0
   
   [<a name="HAUSDIST_SETDIST_TRIANGLE-val"><b>HAUSDIST_SETDIST_TRIANGLE</b></a>]  Theorem
      
      ⊢ ∀s t u.
          t ≠ ∅ ∧ bounded s ∧ bounded t ⇒
          setdist (s,u) ≤ hausdist (s,t) + setdist (t,u)
   
   [<a name="HAUSDIST_SINGS-val"><b>HAUSDIST_SINGS</b></a>]  Theorem
      
      ⊢ ∀x y. hausdist ({x},{y}) = dist (x,y)
   
   [<a name="HAUSDIST_SYM-val"><b>HAUSDIST_SYM</b></a>]  Theorem
      
      ⊢ ∀s t. hausdist (s,t) = hausdist (t,s)
   
   [<a name="HAUSDIST_TRANS-val"><b>HAUSDIST_TRANS</b></a>]  Theorem
      
      ⊢ ∀s t u.
          bounded s ∧ bounded t ∧ bounded u ∧ t ≠ ∅ ⇒
          hausdist (s,u) ≤ hausdist (s,t) + hausdist (t,u)
   
   [<a name="HAUSDIST_TRANSLATION-val"><b>HAUSDIST_TRANSLATION</b></a>]  Theorem
      
      ⊢ ∀a s t.
          hausdist (IMAGE (λx. a + x) s,IMAGE (λx. a + x) t) =
          hausdist (s,t)
   
   [<a name="HAUSDIST_TRIANGLE-val"><b>HAUSDIST_TRIANGLE</b></a>]  Theorem
      
      ⊢ ∀s t u.
          bounded s ∧ bounded t ∧ bounded u ∧ t ≠ ∅ ⇒
          hausdist (s,u) ≤ hausdist (s,t) + hausdist (t,u)
   
   [<a name="HAUSDIST_UNION_LE-val"><b>HAUSDIST_UNION_LE</b></a>]  Theorem
      
      ⊢ ∀s t u.
          bounded s ∧ bounded t ∧ bounded u ∧ t ≠ ∅ ∧ u ≠ ∅ ⇒
          hausdist (s ∪ t,s ∪ u) ≤ hausdist (t,u)
   
   [<a name="HEINE_BOREL_IMP_BOLZANO_WEIERSTRASS-val"><b>HEINE_BOREL_IMP_BOLZANO_WEIERSTRASS</b></a>]  Theorem
      
      ⊢ ∀s. (∀f. (∀t. t ∈ f ⇒ open t) ∧ s ⊆ BIGUNION f ⇒
                 ∃f'. f' ⊆ f ∧ FINITE f' ∧ s ⊆ BIGUNION f') ⇒
            ∀t. INFINITE t ∧ t ⊆ s ⇒ ∃x. x ∈ s ∧ x limit_point_of t
   
   [<a name="HEINE_BOREL_LEMMA-val"><b>HEINE_BOREL_LEMMA</b></a>]  Theorem
      
      ⊢ ∀s. compact s ⇒
            ∀t. s ⊆ BIGUNION t ∧ (∀b. b ∈ t ⇒ open b) ⇒
                ∃e. 0 &lt; e ∧ ∀x. x ∈ s ⇒ ∃b. b ∈ t ∧ ball (x,e) ⊆ b
   
   [<a name="HOMEOMORPHIC_AFFINITY-val"><b>HOMEOMORPHIC_AFFINITY</b></a>]  Theorem
      
      ⊢ ∀s a c. c ≠ 0 ⇒ s homeomorphic IMAGE (λx. a + c * x) s
   
   [<a name="HOMEOMORPHIC_BALLS-val"><b>HOMEOMORPHIC_BALLS</b></a>]  Theorem
      
      ⊢ ∀a b d e. 0 &lt; d ∧ 0 &lt; e ⇒ ball (a,d) homeomorphic ball (b,e)
   
   [<a name="HOMEOMORPHIC_BALLS_CBALL_SPHERE-val"><b>HOMEOMORPHIC_BALLS_CBALL_SPHERE</b></a>]  Theorem
      
      ⊢ (∀a b d e. 0 &lt; d ∧ 0 &lt; e ⇒ ball (a,d) homeomorphic ball (b,e)) ∧
        (∀a b d e. 0 &lt; d ∧ 0 &lt; e ⇒ cball (a,d) homeomorphic cball (b,e)) ∧
        ∀a b d e. 0 &lt; d ∧ 0 &lt; e ⇒ sphere (a,d) homeomorphic sphere (b,e)
   
   [<a name="HOMEOMORPHIC_CBALL-val"><b>HOMEOMORPHIC_CBALL</b></a>]  Theorem
      
      ⊢ ∀a b d e. 0 &lt; d ∧ 0 &lt; e ⇒ cball (a,d) homeomorphic cball (b,e)
   
   [<a name="HOMEOMORPHIC_COMPACT-val"><b>HOMEOMORPHIC_COMPACT</b></a>]  Theorem
      
      ⊢ ∀s f t.
          compact s ∧ f continuous_on s ∧ IMAGE f s = t ∧
          (∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y) ⇒
          s homeomorphic t
   
   [<a name="HOMEOMORPHIC_COMPACTNESS-val"><b>HOMEOMORPHIC_COMPACTNESS</b></a>]  Theorem
      
      ⊢ ∀s t. s homeomorphic t ⇒ (compact s ⇔ compact t)
   
   [<a name="HOMEOMORPHIC_CONNECTEDNESS-val"><b>HOMEOMORPHIC_CONNECTEDNESS</b></a>]  Theorem
      
      ⊢ ∀s t. s homeomorphic t ⇒ (connected s ⇔ connected t)
   
   [<a name="HOMEOMORPHIC_EMPTY-val"><b>HOMEOMORPHIC_EMPTY</b></a>]  Theorem
      
      ⊢ (∀s. s homeomorphic ∅ ⇔ s = ∅) ∧ ∀s. ∅ homeomorphic s ⇔ s = ∅
   
   [<a name="HOMEOMORPHIC_FINITE-val"><b>HOMEOMORPHIC_FINITE</b></a>]  Theorem
      
      ⊢ ∀s t. FINITE s ∧ FINITE t ⇒ (s homeomorphic t ⇔ CARD s = CARD t)
   
   [<a name="HOMEOMORPHIC_FINITENESS-val"><b>HOMEOMORPHIC_FINITENESS</b></a>]  Theorem
      
      ⊢ ∀s t. s homeomorphic t ⇒ (FINITE s ⇔ FINITE t)
   
   [<a name="HOMEOMORPHIC_FINITE_STRONG-val"><b>HOMEOMORPHIC_FINITE_STRONG</b></a>]  Theorem
      
      ⊢ ∀s t.
          FINITE s ∨ FINITE t ⇒
          (s homeomorphic t ⇔ FINITE s ∧ FINITE t ∧ CARD s = CARD t)
   
   [<a name="HOMEOMORPHIC_HYPERPLANES-val"><b>HOMEOMORPHIC_HYPERPLANES</b></a>]  Theorem
      
      ⊢ ∀a b c d.
          a ≠ 0 ∧ c ≠ 0 ⇒ {x | a * x = b} homeomorphic {x | c * x = d}
   
   [<a name="HOMEOMORPHIC_HYPERPLANE_STANDARD_HYPERPLANE-val"><b>HOMEOMORPHIC_HYPERPLANE_STANDARD_HYPERPLANE</b></a>]  Theorem
      
      ⊢ ∀a b c. a ≠ 0 ⇒ {x | a * x = b} homeomorphic {x | x = c}
   
   [<a name="HOMEOMORPHIC_IMP_CARD_EQ-val"><b>HOMEOMORPHIC_IMP_CARD_EQ</b></a>]  Theorem
      
      ⊢ ∀s t. s homeomorphic t ⇒ s ≈ t
   
   [<a name="HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_LEFT_EQ-val"><b>HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_LEFT_EQ</b></a>]  Theorem
      
      ⊢ ∀f s t.
          linear f ∧ (∀x y. f x = f y ⇒ x = y) ⇒
          (IMAGE f s homeomorphic t ⇔ s homeomorphic t)
   
   [<a name="HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_RIGHT_EQ-val"><b>HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_RIGHT_EQ</b></a>]  Theorem
      
      ⊢ ∀f s t.
          linear f ∧ (∀x y. f x = f y ⇒ x = y) ⇒
          (s homeomorphic IMAGE f t ⇔ s homeomorphic t)
   
   [<a name="HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_SELF-val"><b>HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_SELF</b></a>]  Theorem
      
      ⊢ ∀f s.
          linear f ∧ (∀x y. f x = f y ⇒ x = y) ⇒ IMAGE f s homeomorphic s
   
   [<a name="HOMEOMORPHIC_LOCALLY-val"><b>HOMEOMORPHIC_LOCALLY</b></a>]  Theorem
      
      ⊢ ∀P Q.
          (∀s t. s homeomorphic t ⇒ (P s ⇔ Q t)) ⇒
          ∀s t. s homeomorphic t ⇒ (locally P s ⇔ locally Q t)
   
   [<a name="HOMEOMORPHIC_LOCAL_COMPACTNESS-val"><b>HOMEOMORPHIC_LOCAL_COMPACTNESS</b></a>]  Theorem
      
      ⊢ ∀s t. s homeomorphic t ⇒ (locally compact s ⇔ locally compact t)
   
   [<a name="HOMEOMORPHIC_MINIMAL-val"><b>HOMEOMORPHIC_MINIMAL</b></a>]  Theorem
      
      ⊢ ∀s t.
          s homeomorphic t ⇔
          ∃f g.
            (∀x. x ∈ s ⇒ f x ∈ t ∧ g (f x) = x) ∧
            (∀y. y ∈ t ⇒ g y ∈ s ∧ f (g y) = y) ∧ f continuous_on s ∧
            g continuous_on t
   
   [<a name="HOMEOMORPHIC_ONE_POINT_COMPACTIFICATIONS-val"><b>HOMEOMORPHIC_ONE_POINT_COMPACTIFICATIONS</b></a>]  Theorem
      
      ⊢ ∀s t a b.
          compact s ∧ compact t ∧ a ∈ s ∧ b ∈ t ∧
          s DELETE a homeomorphic t DELETE b ⇒
          s homeomorphic t
   
   [<a name="HOMEOMORPHIC_OPEN_INTERVALS-val"><b>HOMEOMORPHIC_OPEN_INTERVALS</b></a>]  Theorem
      
      ⊢ ∀a b c d.
          a &lt; b ∧ c &lt; d ⇒ interval (a,b) homeomorphic interval (c,d)
   
   [<a name="HOMEOMORPHIC_OPEN_INTERVAL_UNIV-val"><b>HOMEOMORPHIC_OPEN_INTERVAL_UNIV</b></a>]  Theorem
      
      ⊢ ∀a b. a &lt; b ⇒ interval (a,b) homeomorphic 𝕌(:real)
   
   [<a name="HOMEOMORPHIC_REFL-val"><b>HOMEOMORPHIC_REFL</b></a>]  Theorem
      
      ⊢ ∀s. s homeomorphic s
   
   [<a name="HOMEOMORPHIC_SCALING-val"><b>HOMEOMORPHIC_SCALING</b></a>]  Theorem
      
      ⊢ ∀s c. c ≠ 0 ⇒ s homeomorphic IMAGE (λx. c * x) s
   
   [<a name="HOMEOMORPHIC_SCALING_LEFT-val"><b>HOMEOMORPHIC_SCALING_LEFT</b></a>]  Theorem
      
      ⊢ ∀c. 0 &lt; c ⇒
            ∀s t. IMAGE (λx. c * x) s homeomorphic t ⇔ s homeomorphic t
   
   [<a name="HOMEOMORPHIC_SCALING_RIGHT-val"><b>HOMEOMORPHIC_SCALING_RIGHT</b></a>]  Theorem
      
      ⊢ ∀c. 0 &lt; c ⇒
            ∀s t. s homeomorphic IMAGE (λx. c * x) t ⇔ s homeomorphic t
   
   [<a name="HOMEOMORPHIC_SING-val"><b>HOMEOMORPHIC_SING</b></a>]  Theorem
      
      ⊢ ∀a b. {a} homeomorphic {b}
   
   [<a name="HOMEOMORPHIC_SPHERE-val"><b>HOMEOMORPHIC_SPHERE</b></a>]  Theorem
      
      ⊢ ∀a b d e. 0 &lt; d ∧ 0 &lt; e ⇒ sphere (a,d) homeomorphic sphere (b,e)
   
   [<a name="HOMEOMORPHIC_STANDARD_HYPERPLANE_HYPERPLANE-val"><b>HOMEOMORPHIC_STANDARD_HYPERPLANE_HYPERPLANE</b></a>]  Theorem
      
      ⊢ ∀a b c. a ≠ 0 ⇒ {x | x = c} homeomorphic {x | a * x = b}
   
   [<a name="HOMEOMORPHIC_SYM-val"><b>HOMEOMORPHIC_SYM</b></a>]  Theorem
      
      ⊢ ∀s t. s homeomorphic t ⇔ t homeomorphic s
   
   [<a name="HOMEOMORPHIC_TRANS-val"><b>HOMEOMORPHIC_TRANS</b></a>]  Theorem
      
      ⊢ ∀s t u. s homeomorphic t ∧ t homeomorphic u ⇒ s homeomorphic u
   
   [<a name="HOMEOMORPHIC_TRANSLATION-val"><b>HOMEOMORPHIC_TRANSLATION</b></a>]  Theorem
      
      ⊢ ∀s a. s homeomorphic IMAGE (λx. a + x) s
   
   [<a name="HOMEOMORPHIC_TRANSLATION_LEFT_EQ-val"><b>HOMEOMORPHIC_TRANSLATION_LEFT_EQ</b></a>]  Theorem
      
      ⊢ ∀a s t. IMAGE (λx. a + x) s homeomorphic t ⇔ s homeomorphic t
   
   [<a name="HOMEOMORPHIC_TRANSLATION_RIGHT_EQ-val"><b>HOMEOMORPHIC_TRANSLATION_RIGHT_EQ</b></a>]  Theorem
      
      ⊢ ∀a s t. s homeomorphic IMAGE (λx. a + x) t ⇔ s homeomorphic t
   
   [<a name="HOMEOMORPHIC_TRANSLATION_SELF-val"><b>HOMEOMORPHIC_TRANSLATION_SELF</b></a>]  Theorem
      
      ⊢ ∀a s. IMAGE (λx. a + x) s homeomorphic s
   
   [<a name="HOMEOMORPHISM-val"><b>HOMEOMORPHISM</b></a>]  Theorem
      
      ⊢ ∀s t f g.
          homeomorphism (s,t) (f,g) ⇔
          f continuous_on s ∧ IMAGE f s ⊆ t ∧ g continuous_on t ∧
          IMAGE g t ⊆ s ∧ (∀x. x ∈ s ⇒ g (f x) = x) ∧
          ∀y. y ∈ t ⇒ f (g y) = y
   
   [<a name="HOMEOMORPHISM_COMPACT-val"><b>HOMEOMORPHISM_COMPACT</b></a>]  Theorem
      
      ⊢ ∀s f t.
          compact s ∧ f continuous_on s ∧ IMAGE f s = t ∧
          (∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y) ⇒
          ∃g. homeomorphism (s,t) (f,g)
   
   [<a name="HOMEOMORPHISM_COMPOSE-val"><b>HOMEOMORPHISM_COMPOSE</b></a>]  Theorem
      
      ⊢ ∀f g h k s t u.
          homeomorphism (s,t) (f,g) ∧ homeomorphism (t,u) (h,k) ⇒
          homeomorphism (s,u) (h ∘ f,g ∘ k)
   
   [<a name="HOMEOMORPHISM_FROM_COMPOSITION_INJECTIVE-val"><b>HOMEOMORPHISM_FROM_COMPOSITION_INJECTIVE</b></a>]  Theorem
      
      ⊢ ∀f g s t u.
          f continuous_on s ∧ IMAGE f s ⊆ t ∧ g continuous_on t ∧
          IMAGE g t ⊆ u ∧ (∀x y. x ∈ t ∧ y ∈ t ∧ g x = g y ⇒ x = y) ∧
          (∃h. homeomorphism (s,u) (g ∘ f,h)) ⇒
          (∃f'. homeomorphism (s,t) (f,f')) ∧
          ∃g'. homeomorphism (t,u) (g,g')
   
   [<a name="HOMEOMORPHISM_FROM_COMPOSITION_SURJECTIVE-val"><b>HOMEOMORPHISM_FROM_COMPOSITION_SURJECTIVE</b></a>]  Theorem
      
      ⊢ ∀f g s t u.
          f continuous_on s ∧ IMAGE f s = t ∧ g continuous_on t ∧
          IMAGE g t ⊆ u ∧ (∃h. homeomorphism (s,u) (g ∘ f,h)) ⇒
          (∃f'. homeomorphism (s,t) (f,f')) ∧
          ∃g'. homeomorphism (t,u) (g,g')
   
   [<a name="HOMEOMORPHISM_ID-val"><b>HOMEOMORPHISM_ID</b></a>]  Theorem
      
      ⊢ ∀s. homeomorphism (s,s) ((λx. x),(λx. x))
   
   [<a name="HOMEOMORPHISM_IMP_CLOSED_MAP-val"><b>HOMEOMORPHISM_IMP_CLOSED_MAP</b></a>]  Theorem
      
      ⊢ ∀f g s t u.
          homeomorphism (s,t) (f,g) ∧ closed_in (subtopology euclidean s) u ⇒
          closed_in (subtopology euclidean t) (IMAGE f u)
   
   [<a name="HOMEOMORPHISM_IMP_OPEN_MAP-val"><b>HOMEOMORPHISM_IMP_OPEN_MAP</b></a>]  Theorem
      
      ⊢ ∀f g s t u.
          homeomorphism (s,t) (f,g) ∧ open_in (subtopology euclidean s) u ⇒
          open_in (subtopology euclidean t) (IMAGE f u)
   
   [<a name="HOMEOMORPHISM_IMP_QUOTIENT_MAP-val"><b>HOMEOMORPHISM_IMP_QUOTIENT_MAP</b></a>]  Theorem
      
      ⊢ ∀f g s t.
          homeomorphism (s,t) (f,g) ⇒
          ∀u. u ⊆ t ⇒
              (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇔
               open_in (subtopology euclidean t) u)
   
   [<a name="HOMEOMORPHISM_INJECTIVE_CLOSED_MAP-val"><b>HOMEOMORPHISM_INJECTIVE_CLOSED_MAP</b></a>]  Theorem
      
      ⊢ ∀f s t.
          f continuous_on s ∧ IMAGE f s = t ∧
          (∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y) ∧
          (∀u. closed_in (subtopology euclidean s) u ⇒
               closed_in (subtopology euclidean t) (IMAGE f u)) ⇒
          ∃g. homeomorphism (s,t) (f,g)
   
   [<a name="HOMEOMORPHISM_INJECTIVE_CLOSED_MAP_EQ-val"><b>HOMEOMORPHISM_INJECTIVE_CLOSED_MAP_EQ</b></a>]  Theorem
      
      ⊢ ∀f s t.
          f continuous_on s ∧ IMAGE f s = t ∧
          (∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y) ⇒
          ((∃g. homeomorphism (s,t) (f,g)) ⇔
           ∀u. closed_in (subtopology euclidean s) u ⇒
               closed_in (subtopology euclidean t) (IMAGE f u))
   
   [<a name="HOMEOMORPHISM_INJECTIVE_OPEN_MAP-val"><b>HOMEOMORPHISM_INJECTIVE_OPEN_MAP</b></a>]  Theorem
      
      ⊢ ∀f s t.
          f continuous_on s ∧ IMAGE f s = t ∧
          (∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y) ∧
          (∀u. open_in (subtopology euclidean s) u ⇒
               open_in (subtopology euclidean t) (IMAGE f u)) ⇒
          ∃g. homeomorphism (s,t) (f,g)
   
   [<a name="HOMEOMORPHISM_INJECTIVE_OPEN_MAP_EQ-val"><b>HOMEOMORPHISM_INJECTIVE_OPEN_MAP_EQ</b></a>]  Theorem
      
      ⊢ ∀f s t.
          f continuous_on s ∧ IMAGE f s = t ∧
          (∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y) ⇒
          ((∃g. homeomorphism (s,t) (f,g)) ⇔
           ∀u. open_in (subtopology euclidean s) u ⇒
               open_in (subtopology euclidean t) (IMAGE f u))
   
   [<a name="HOMEOMORPHISM_LOCALLY-val"><b>HOMEOMORPHISM_LOCALLY</b></a>]  Theorem
      
      ⊢ ∀P Q f g.
          (∀s t. homeomorphism (s,t) (f,g) ⇒ (P s ⇔ Q t)) ⇒
          ∀s t. homeomorphism (s,t) (f,g) ⇒ (locally P s ⇔ locally Q t)
   
   [<a name="HOMEOMORPHISM_OF_SUBSETS-val"><b>HOMEOMORPHISM_OF_SUBSETS</b></a>]  Theorem
      
      ⊢ ∀f g s t s' t'.
          homeomorphism (s,t) (f,g) ∧ s' ⊆ s ∧ t' ⊆ t ∧ IMAGE f s' = t' ⇒
          homeomorphism (s',t') (f,g)
   
   [<a name="HOMEOMORPHISM_SYM-val"><b>HOMEOMORPHISM_SYM</b></a>]  Theorem
      
      ⊢ ∀f g s t. homeomorphism (s,t) (f,g) ⇔ homeomorphism (t,s) (g,f)
   
   [<a name="IMAGE_AFFINITY_INTERVAL-val"><b>IMAGE_AFFINITY_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀a b m c.
          IMAGE (λx. m * x + c) (interval [(a,b)]) =
          if interval [(a,b)] = ∅ then ∅
          else if 0 ≤ m then interval [(m * a + c,m * b + c)]
          else interval [(m * b + c,m * a + c)]
   
   [<a name="IMAGE_CLOSURE_SUBSET-val"><b>IMAGE_CLOSURE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀f s t.
          f continuous_on closure s ∧ closed t ∧ IMAGE f s ⊆ t ⇒
          IMAGE f (closure s) ⊆ t
   
   [<a name="IMAGE_STRETCH_INTERVAL-val"><b>IMAGE_STRETCH_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀a b m.
          IMAGE (λx. @f. f = m 1 * x) (interval [(a,b)]) =
          if interval [(a,b)] = ∅ then ∅
          else
            interval
              [((@f. f = min (m 1 * a) (m 1 * b)),
                @f. f = max (m 1 * a) (m 1 * b))]
   
   [<a name="IMAGE_TWIZZLE_INTERVAL-val"><b>IMAGE_TWIZZLE_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀p a b. IMAGE (λx. x) (interval [(a,b)]) = interval [(a,b)]
   
   [<a name="INDEPENDENT_BOUND-val"><b>INDEPENDENT_BOUND</b></a>]  Theorem
      
      ⊢ ∀s. independent s ⇒ FINITE s ∧ CARD s ≤ 1
   
   [<a name="INDEPENDENT_CARD_LE_DIM-val"><b>INDEPENDENT_CARD_LE_DIM</b></a>]  Theorem
      
      ⊢ ∀v b. b ⊆ v ∧ independent b ⇒ FINITE b ∧ CARD b ≤ dim v
   
   [<a name="INDEPENDENT_EMPTY-val"><b>INDEPENDENT_EMPTY</b></a>]  Theorem
      
      ⊢ independent ∅
   
   [<a name="INDEPENDENT_INJECTIVE_IMAGE-val"><b>INDEPENDENT_INJECTIVE_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s.
          independent s ∧ linear f ∧ (∀x y. f x = f y ⇒ x = y) ⇒
          independent (IMAGE f s)
   
   [<a name="INDEPENDENT_INJECTIVE_IMAGE_GEN-val"><b>INDEPENDENT_INJECTIVE_IMAGE_GEN</b></a>]  Theorem
      
      ⊢ ∀f s.
          independent s ∧ linear f ∧
          (∀x y. x ∈ span s ∧ y ∈ span s ∧ f x = f y ⇒ x = y) ⇒
          independent (IMAGE f s)
   
   [<a name="INDEPENDENT_INSERT-val"><b>INDEPENDENT_INSERT</b></a>]  Theorem
      
      ⊢ ∀a s.
          independent (a INSERT s) ⇔
          if a ∈ s then independent s else independent s ∧ a ∉ span s
   
   [<a name="INDEPENDENT_MONO-val"><b>INDEPENDENT_MONO</b></a>]  Theorem
      
      ⊢ ∀s t. independent t ∧ s ⊆ t ⇒ independent s
   
   [<a name="INDEPENDENT_NONZERO-val"><b>INDEPENDENT_NONZERO</b></a>]  Theorem
      
      ⊢ ∀s. independent s ⇒ 0 ∉ s
   
   [<a name="INDEPENDENT_SING-val"><b>INDEPENDENT_SING</b></a>]  Theorem
      
      ⊢ ∀x. independent {x} ⇔ x ≠ 0
   
   [<a name="INDEPENDENT_SPAN_BOUND-val"><b>INDEPENDENT_SPAN_BOUND</b></a>]  Theorem
      
      ⊢ ∀s t.
          FINITE t ∧ independent s ∧ s ⊆ span t ⇒
          FINITE s ∧ CARD s ≤ CARD t
   
   [<a name="INDEPENDENT_STDBASIS-val"><b>INDEPENDENT_STDBASIS</b></a>]  Theorem
      
      ⊢ independent {i | 1 ≤ i ∧ i ≤ 1}
   
   [<a name="INFINITE_OPEN_IN-val"><b>INFINITE_OPEN_IN</b></a>]  Theorem
      
      ⊢ ∀u s.
          open_in (subtopology euclidean u) s ∧
          (∃x. x ∈ s ∧ x limit_point_of u) ⇒
          INFINITE s
   
   [<a name="INFINITE_SUPERSET-val"><b>INFINITE_SUPERSET</b></a>]  Theorem
      
      ⊢ ∀s t. INFINITE s ∧ s ⊆ t ⇒ INFINITE t
   
   [<a name="INFSUM_0-val"><b>INFSUM_0</b></a>]  Theorem
      
      ⊢ suminf s (λi. 0) = 0
   
   [<a name="INFSUM_ADD-val"><b>INFSUM_ADD</b></a>]  Theorem
      
      ⊢ ∀x y s.
          summable s x ∧ summable s y ⇒
          suminf s (λi. x i + y i) = suminf s x + suminf s y
   
   [<a name="INFSUM_CMUL-val"><b>INFSUM_CMUL</b></a>]  Theorem
      
      ⊢ ∀s x c. summable s x ⇒ suminf s (λn. c * x n) = c * suminf s x
   
   [<a name="INFSUM_EQ-val"><b>INFSUM_EQ</b></a>]  Theorem
      
      ⊢ ∀f g k.
          summable k f ∧ summable k g ∧ (∀x. x ∈ k ⇒ f x = g x) ⇒
          suminf k f = suminf k g
   
   [<a name="INFSUM_LINEAR-val"><b>INFSUM_LINEAR</b></a>]  Theorem
      
      ⊢ ∀f h s.
          summable s f ∧ linear h ⇒ suminf s (λn. h (f n)) = h (suminf s f)
   
   [<a name="INFSUM_NEG-val"><b>INFSUM_NEG</b></a>]  Theorem
      
      ⊢ ∀s x. summable s x ⇒ suminf s (λn. -x n) = -suminf s x
   
   [<a name="INFSUM_RESTRICT-val"><b>INFSUM_RESTRICT</b></a>]  Theorem
      
      ⊢ ∀k a. suminf 𝕌(:num) (λn. if n ∈ k then a n else 0) = suminf k a
   
   [<a name="INFSUM_SUB-val"><b>INFSUM_SUB</b></a>]  Theorem
      
      ⊢ ∀x y s.
          summable s x ∧ summable s y ⇒
          suminf s (λi. x i − y i) = suminf s x − suminf s y
   
   [<a name="INFSUM_UNIQUE-val"><b>INFSUM_UNIQUE</b></a>]  Theorem
      
      ⊢ ∀f l s. (f sums l) s ⇒ suminf s f = l
   
   [<a name="INF_INSERT-val"><b>INF_INSERT</b></a>]  Theorem
      
      ⊢ ∀x s.
          bounded s ⇒ inf (x INSERT s) = if s = ∅ then x else min x (inf s)
   
   [<a name="INJECTIVE_IMP_ISOMETRIC-val"><b>INJECTIVE_IMP_ISOMETRIC</b></a>]  Theorem
      
      ⊢ ∀f s.
          closed s ∧ subspace s ∧ linear f ∧ (∀x. x ∈ s ∧ f x = 0 ⇒ x = 0) ⇒
          ∃e. 0 &lt; e ∧ ∀x. x ∈ s ⇒ abs (f x) ≥ e * abs x
   
   [<a name="INJECTIVE_MAP_OPEN_IFF_CLOSED-val"><b>INJECTIVE_MAP_OPEN_IFF_CLOSED</b></a>]  Theorem
      
      ⊢ ∀f s t.
          f continuous_on s ∧ IMAGE f s = t ∧
          (∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y) ⇒
          ((∀u. open_in (subtopology euclidean s) u ⇒
                open_in (subtopology euclidean t) (IMAGE f u)) ⇔
           ∀u. closed_in (subtopology euclidean s) u ⇒
               closed_in (subtopology euclidean t) (IMAGE f u))
   
   [<a name="INTERIOR_BALL-val"><b>INTERIOR_BALL</b></a>]  Theorem
      
      ⊢ ∀a r. interior (ball (a,r)) = ball (a,r)
   
   [<a name="INTERIOR_BIGINTER_SUBSET-val"><b>INTERIOR_BIGINTER_SUBSET</b></a>]  Theorem
      
      ⊢ ∀f. interior (BIGINTER f) ⊆ BIGINTER (IMAGE interior f)
   
   [<a name="INTERIOR_BIJECTIVE_LINEAR_IMAGE-val"><b>INTERIOR_BIJECTIVE_LINEAR_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s.
          linear f ∧ (∀x y. f x = f y ⇒ x = y) ∧ (∀y. ∃x. f x = y) ⇒
          interior (IMAGE f s) = IMAGE f (interior s)
   
   [<a name="INTERIOR_CBALL-val"><b>INTERIOR_CBALL</b></a>]  Theorem
      
      ⊢ ∀x e. interior (cball (x,e)) = ball (x,e)
   
   [<a name="INTERIOR_CLOSED_EQ_EMPTY_AS_FRONTIER-val"><b>INTERIOR_CLOSED_EQ_EMPTY_AS_FRONTIER</b></a>]  Theorem
      
      ⊢ ∀s. closed s ∧ interior s = ∅ ⇔ ∃t. open t ∧ s = frontier t
   
   [<a name="INTERIOR_CLOSED_INTERVAL-val"><b>INTERIOR_CLOSED_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀a b. interior (interval [(a,b)]) = interval (a,b)
   
   [<a name="INTERIOR_CLOSED_UNION_EMPTY_INTERIOR-val"><b>INTERIOR_CLOSED_UNION_EMPTY_INTERIOR</b></a>]  Theorem
      
      ⊢ ∀s t. closed s ∧ interior t = ∅ ⇒ interior (s ∪ t) = interior s
   
   [<a name="INTERIOR_CLOSURE-val"><b>INTERIOR_CLOSURE</b></a>]  Theorem
      
      ⊢ ∀s. interior s = 𝕌(:real) DIFF closure (𝕌(:real) DIFF s)
   
   [<a name="INTERIOR_CLOSURE_IDEMP-val"><b>INTERIOR_CLOSURE_IDEMP</b></a>]  Theorem
      
      ⊢ ∀s. interior (closure (interior (closure s))) =
            interior (closure s)
   
   [<a name="INTERIOR_CLOSURE_INTER_OPEN-val"><b>INTERIOR_CLOSURE_INTER_OPEN</b></a>]  Theorem
      
      ⊢ ∀s t.
          open s ∧ open t ⇒
          interior (closure (s ∩ t)) =
          interior (closure s) ∩ interior (closure t)
   
   [<a name="INTERIOR_COMPLEMENT-val"><b>INTERIOR_COMPLEMENT</b></a>]  Theorem
      
      ⊢ ∀s. interior (𝕌(:real) DIFF s) = 𝕌(:real) DIFF closure s
   
   [<a name="INTERIOR_DIFF-val"><b>INTERIOR_DIFF</b></a>]  Theorem
      
      ⊢ ∀s t. interior (s DIFF t) = interior s DIFF closure t
   
   [<a name="INTERIOR_EMPTY-val"><b>INTERIOR_EMPTY</b></a>]  Theorem
      
      ⊢ interior ∅ = ∅
   
   [<a name="INTERIOR_EQ-val"><b>INTERIOR_EQ</b></a>]  Theorem
      
      ⊢ ∀s. interior s = s ⇔ open s
   
   [<a name="INTERIOR_EQ_EMPTY-val"><b>INTERIOR_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ ∀s. interior s = ∅ ⇔ ∀t. open t ∧ t ⊆ s ⇒ t = ∅
   
   [<a name="INTERIOR_EQ_EMPTY_ALT-val"><b>INTERIOR_EQ_EMPTY_ALT</b></a>]  Theorem
      
      ⊢ ∀s. interior s = ∅ ⇔ ∀t. open t ∧ t ≠ ∅ ⇒ t DIFF s ≠ ∅
   
   [<a name="INTERIOR_FINITE_BIGINTER-val"><b>INTERIOR_FINITE_BIGINTER</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ interior (BIGINTER s) = BIGINTER (IMAGE interior s)
   
   [<a name="INTERIOR_FRONTIER-val"><b>INTERIOR_FRONTIER</b></a>]  Theorem
      
      ⊢ ∀s. interior (frontier s) =
            interior (closure s) DIFF closure (interior s)
   
   [<a name="INTERIOR_FRONTIER_EMPTY-val"><b>INTERIOR_FRONTIER_EMPTY</b></a>]  Theorem
      
      ⊢ ∀s. open s ∨ closed s ⇒ interior (frontier s) = ∅
   
   [<a name="INTERIOR_HALFSPACE_COMPONENT_GE-val"><b>INTERIOR_HALFSPACE_COMPONENT_GE</b></a>]  Theorem
      
      ⊢ ∀a. interior {x | x ≥ a} = {x | x &gt; a}
   
   [<a name="INTERIOR_HALFSPACE_COMPONENT_LE-val"><b>INTERIOR_HALFSPACE_COMPONENT_LE</b></a>]  Theorem
      
      ⊢ ∀a. interior {x | x ≤ a} = {x | x &lt; a}
   
   [<a name="INTERIOR_HALFSPACE_GE-val"><b>INTERIOR_HALFSPACE_GE</b></a>]  Theorem
      
      ⊢ ∀a b. a ≠ 0 ⇒ interior {x | a * x ≥ b} = {x | a * x &gt; b}
   
   [<a name="INTERIOR_HALFSPACE_LE-val"><b>INTERIOR_HALFSPACE_LE</b></a>]  Theorem
      
      ⊢ ∀a b. a ≠ 0 ⇒ interior {x | a * x ≤ b} = {x | a * x &lt; b}
   
   [<a name="INTERIOR_HYPERPLANE-val"><b>INTERIOR_HYPERPLANE</b></a>]  Theorem
      
      ⊢ ∀a b. a ≠ 0 ⇒ interior {x | a * x = b} = ∅
   
   [<a name="INTERIOR_IMAGE_SUBSET-val"><b>INTERIOR_IMAGE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀f s.
          (∀x. f continuous at x) ∧ (∀x y. f x = f y ⇒ x = y) ⇒
          interior (IMAGE f s) ⊆ IMAGE f (interior s)
   
   [<a name="INTERIOR_INJECTIVE_LINEAR_IMAGE-val"><b>INTERIOR_INJECTIVE_LINEAR_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s.
          linear f ∧ (∀x y. f x = f y ⇒ x = y) ⇒
          interior (IMAGE f s) = IMAGE f (interior s)
   
   [<a name="INTERIOR_INTER-val"><b>INTERIOR_INTER</b></a>]  Theorem
      
      ⊢ ∀s t. interior (s ∩ t) = interior s ∩ interior t
   
   [<a name="INTERIOR_INTERIOR-val"><b>INTERIOR_INTERIOR</b></a>]  Theorem
      
      ⊢ ∀s. interior (interior s) = interior s
   
   [<a name="INTERIOR_INTERVAL-val"><b>INTERIOR_INTERVAL</b></a>]  Theorem
      
      ⊢ (∀a b. interior (interval [(a,b)]) = interval (a,b)) ∧
        ∀a b. interior (interval (a,b)) = interval (a,b)
   
   [<a name="INTERIOR_LIMIT_POINT-val"><b>INTERIOR_LIMIT_POINT</b></a>]  Theorem
      
      ⊢ ∀s x. x ∈ interior s ⇒ x limit_point_of s
   
   [<a name="INTERIOR_MAXIMAL-val"><b>INTERIOR_MAXIMAL</b></a>]  Theorem
      
      ⊢ ∀s t. t ⊆ s ∧ open t ⇒ t ⊆ interior s
   
   [<a name="INTERIOR_MAXIMAL_EQ-val"><b>INTERIOR_MAXIMAL_EQ</b></a>]  Theorem
      
      ⊢ ∀s t. open s ⇒ (s ⊆ interior t ⇔ s ⊆ t)
   
   [<a name="INTERIOR_NEGATIONS-val"><b>INTERIOR_NEGATIONS</b></a>]  Theorem
      
      ⊢ ∀s. interior (IMAGE (λx. -x) s) = IMAGE (λx. -x) (interior s)
   
   [<a name="INTERIOR_OPEN-val"><b>INTERIOR_OPEN</b></a>]  Theorem
      
      ⊢ ∀s. open s ⇒ interior s = s
   
   [<a name="INTERIOR_SING-val"><b>INTERIOR_SING</b></a>]  Theorem
      
      ⊢ ∀a. interior {a} = ∅
   
   [<a name="INTERIOR_STANDARD_HYPERPLANE-val"><b>INTERIOR_STANDARD_HYPERPLANE</b></a>]  Theorem
      
      ⊢ ∀a. interior {x | x = a} = ∅
   
   [<a name="INTERIOR_SUBSET-val"><b>INTERIOR_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s. interior s ⊆ s
   
   [<a name="INTERIOR_TRANSLATION-val"><b>INTERIOR_TRANSLATION</b></a>]  Theorem
      
      ⊢ ∀a s.
          interior (IMAGE (λx. a + x) s) = IMAGE (λx. a + x) (interior s)
   
   [<a name="INTERIOR_UNIONS_OPEN_SUBSETS-val"><b>INTERIOR_UNIONS_OPEN_SUBSETS</b></a>]  Theorem
      
      ⊢ ∀s. BIGUNION {t | open t ∧ t ⊆ s} = interior s
   
   [<a name="INTERIOR_UNION_EQ_EMPTY-val"><b>INTERIOR_UNION_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ ∀s t.
          closed s ∨ closed t ⇒
          (interior (s ∪ t) = ∅ ⇔ interior s = ∅ ∧ interior t = ∅)
   
   [<a name="INTERIOR_UNIQUE-val"><b>INTERIOR_UNIQUE</b></a>]  Theorem
      
      ⊢ ∀s t.
          t ⊆ s ∧ open t ∧ (∀t'. t' ⊆ s ∧ open t' ⇒ t' ⊆ t) ⇒
          interior s = t
   
   [<a name="INTERIOR_UNIV-val"><b>INTERIOR_UNIV</b></a>]  Theorem
      
      ⊢ interior 𝕌(:real) = 𝕌(:real)
   
   [<a name="INTERVAL-val"><b>INTERVAL</b></a>]  Theorem
      
      ⊢ (∀a b.
           interval [(a,b)] =
           if a ≤ b then cball (midpoint (a,b),dist (a,b) / 2) else ∅) ∧
        ∀a b.
          interval (a,b) =
          if a &lt; b then ball (midpoint (a,b),dist (a,b) / 2) else ∅
   
   [<a name="INTERVAL_BOUNDS_EMPTY-val"><b>INTERVAL_BOUNDS_EMPTY</b></a>]  Theorem
      
      ⊢ interval_upperbound ∅ = 0 ∧ interval_lowerbound ∅ = 0
   
   [<a name="INTERVAL_BOUNDS_NULL-val"><b>INTERVAL_BOUNDS_NULL</b></a>]  Theorem
      
      ⊢ ∀a b.
          content (interval [(a,b)]) = 0 ⇒
          interval_upperbound (interval [(a,b)]) =
          interval_lowerbound (interval [(a,b)])
   
   [<a name="INTERVAL_CASES-val"><b>INTERVAL_CASES</b></a>]  Theorem
      
      ⊢ ∀x. x ∈ interval [(a,b)] ⇒ x ∈ interval (a,b) ∨ x = a ∨ x = b
   
   [<a name="INTERVAL_CONTAINS_COMPACT_NEIGHBOURHOOD-val"><b>INTERVAL_CONTAINS_COMPACT_NEIGHBOURHOOD</b></a>]  Theorem
      
      ⊢ ∀s x.
          is_interval s ∧ x ∈ s ⇒
          ∃a b d.
            0 &lt; d ∧ x ∈ interval [(a,b)] ∧ interval [(a,b)] ⊆ s ∧
            ball (x,d) ∩ s ⊆ interval [(a,b)]
   
   [<a name="INTERVAL_EQ_EMPTY-val"><b>INTERVAL_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ ∀a b. (b &lt; a ⇔ interval [(a,b)] = ∅) ∧ (b ≤ a ⇔ interval (a,b) = ∅)
   
   [<a name="INTERVAL_IMAGE_STRETCH_INTERVAL-val"><b>INTERVAL_IMAGE_STRETCH_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀a b m. ∃u v.
          IMAGE (λx. @f. f = m 1 * x) (interval [(a,b)]) = interval [(u,v)]
   
   [<a name="INTERVAL_LOWERBOUND-val"><b>INTERVAL_LOWERBOUND</b></a>]  Theorem
      
      ⊢ ∀a b. a ≤ b ⇒ interval_lowerbound (interval [(a,b)]) = a
   
   [<a name="INTERVAL_LOWERBOUND_NONEMPTY-val"><b>INTERVAL_LOWERBOUND_NONEMPTY</b></a>]  Theorem
      
      ⊢ ∀a b.
          interval [(a,b)] ≠ ∅ ⇒ interval_lowerbound (interval [(a,b)]) = a
   
   [<a name="INTERVAL_NE_EMPTY-val"><b>INTERVAL_NE_EMPTY</b></a>]  Theorem
      
      ⊢ (interval [(a,b)] ≠ ∅ ⇔ a ≤ b) ∧ (interval (a,b) ≠ ∅ ⇔ a &lt; b)
   
   [<a name="INTERVAL_OPEN_SUBSET_CLOSED-val"><b>INTERVAL_OPEN_SUBSET_CLOSED</b></a>]  Theorem
      
      ⊢ ∀a b. interval (a,b) ⊆ interval [(a,b)]
   
   [<a name="INTERVAL_SING-val"><b>INTERVAL_SING</b></a>]  Theorem
      
      ⊢ interval [(a,a)] = {a} ∧ interval (a,a) = ∅
   
   [<a name="INTERVAL_SUBSET_IS_INTERVAL-val"><b>INTERVAL_SUBSET_IS_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀s a b.
          is_interval s ⇒
          (interval [(a,b)] ⊆ s ⇔ interval [(a,b)] = ∅ ∨ a ∈ s ∧ b ∈ s)
   
   [<a name="INTERVAL_TRANSLATION-val"><b>INTERVAL_TRANSLATION</b></a>]  Theorem
      
      ⊢ (∀c a b.
           interval [(c + a,c + b)] = IMAGE (λx. c + x) (interval [(a,b)])) ∧
        ∀c a b. interval (c + a,c + b) = IMAGE (λx. c + x) (interval (a,b))
   
   [<a name="INTERVAL_UPPERBOUND-val"><b>INTERVAL_UPPERBOUND</b></a>]  Theorem
      
      ⊢ ∀a b. a ≤ b ⇒ interval_upperbound (interval [(a,b)]) = b
   
   [<a name="INTERVAL_UPPERBOUND_NONEMPTY-val"><b>INTERVAL_UPPERBOUND_NONEMPTY</b></a>]  Theorem
      
      ⊢ ∀a b.
          interval [(a,b)] ≠ ∅ ⇒ interval_upperbound (interval [(a,b)]) = b
   
   [<a name="INTER_BALLS_EQ_EMPTY-val"><b>INTER_BALLS_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ (∀a b r s.
           ball (a,r) ∩ ball (b,s) = ∅ ⇔ r ≤ 0 ∨ s ≤ 0 ∨ r + s ≤ dist (a,b)) ∧
        (∀a b r s.
           ball (a,r) ∩ cball (b,s) = ∅ ⇔
           r ≤ 0 ∨ s &lt; 0 ∨ r + s ≤ dist (a,b)) ∧
        (∀a b r s.
           cball (a,r) ∩ ball (b,s) = ∅ ⇔
           r &lt; 0 ∨ s ≤ 0 ∨ r + s ≤ dist (a,b)) ∧
        ∀a b r s.
          cball (a,r) ∩ cball (b,s) = ∅ ⇔
          r &lt; 0 ∨ s &lt; 0 ∨ r + s &lt; dist (a,b)
   
   [<a name="INTER_INTERVAL-val"><b>INTER_INTERVAL</b></a>]  Theorem
      
      ⊢ interval [(a,b)] ∩ interval [(c,d)] = interval [(max a c,min b d)]
   
   [<a name="INTER_INTERVAL_MIXED_EQ_EMPTY-val"><b>INTER_INTERVAL_MIXED_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ ∀a b c d.
          interval (c,d) ≠ ∅ ⇒
          (interval (a,b) ∩ interval [(c,d)] = ∅ ⇔
           interval (a,b) ∩ interval (c,d) = ∅)
   
   [<a name="IN_BALL-val"><b>IN_BALL</b></a>]  Theorem
      
      ⊢ ∀x y e. y ∈ ball (x,e) ⇔ dist (x,y) &lt; e
   
   [<a name="IN_BALL_0-val"><b>IN_BALL_0</b></a>]  Theorem
      
      ⊢ ∀x e. x ∈ ball (0,e) ⇔ abs x &lt; e
   
   [<a name="IN_CBALL-val"><b>IN_CBALL</b></a>]  Theorem
      
      ⊢ ∀x y e. y ∈ cball (x,e) ⇔ dist (x,y) ≤ e
   
   [<a name="IN_CBALL_0-val"><b>IN_CBALL_0</b></a>]  Theorem
      
      ⊢ ∀x e. x ∈ cball (0,e) ⇔ abs x ≤ e
   
   [<a name="IN_CLOSURE_DELETE-val"><b>IN_CLOSURE_DELETE</b></a>]  Theorem
      
      ⊢ ∀s x. x ∈ closure (s DELETE x) ⇔ x limit_point_of s
   
   [<a name="IN_COMPONENTS-val"><b>IN_COMPONENTS</b></a>]  Theorem
      
      ⊢ ∀u s. s ∈ components u ⇔ ∃x. x ∈ u ∧ s = connected_component u x
   
   [<a name="IN_COMPONENTS_BIGUNION_COMPLEMENT-val"><b>IN_COMPONENTS_BIGUNION_COMPLEMENT</b></a>]  Theorem
      
      ⊢ ∀s c.
          c ∈ components s ⇒ s DIFF c = BIGUNION (components s DELETE c)
   
   [<a name="IN_COMPONENTS_CONNECTED-val"><b>IN_COMPONENTS_CONNECTED</b></a>]  Theorem
      
      ⊢ ∀s c. c ∈ components s ⇒ connected c
   
   [<a name="IN_COMPONENTS_MAXIMAL-val"><b>IN_COMPONENTS_MAXIMAL</b></a>]  Theorem
      
      ⊢ ∀s c.
          c ∈ components s ⇔
          c ≠ ∅ ∧ c ⊆ s ∧ connected c ∧
          ∀c'. c' ≠ ∅ ∧ c ⊆ c' ∧ c' ⊆ s ∧ connected c' ⇒ c' = c
   
   [<a name="IN_COMPONENTS_NONEMPTY-val"><b>IN_COMPONENTS_NONEMPTY</b></a>]  Theorem
      
      ⊢ ∀s c. c ∈ components s ⇒ c ≠ ∅
   
   [<a name="IN_COMPONENTS_SELF-val"><b>IN_COMPONENTS_SELF</b></a>]  Theorem
      
      ⊢ ∀s. s ∈ components s ⇔ connected s ∧ s ≠ ∅
   
   [<a name="IN_COMPONENTS_SUBSET-val"><b>IN_COMPONENTS_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s c. c ∈ components s ⇒ c ⊆ s
   
   [<a name="IN_DIRECTION-val"><b>IN_DIRECTION</b></a>]  Theorem
      
      ⊢ ∀a v x y.
          netord (a in_direction v) x y ⇔
          0 &lt; dist (x,a) ∧ dist (x,a) ≤ dist (y,a) ∧
          ∃c. 0 ≤ c ∧ x − a = c * v
   
   [<a name="IN_INTERIOR-val"><b>IN_INTERIOR</b></a>]  Theorem
      
      ⊢ ∀x s. x ∈ interior s ⇔ ∃e. 0 &lt; e ∧ ball (x,e) ⊆ s
   
   [<a name="IN_INTERIOR_CBALL-val"><b>IN_INTERIOR_CBALL</b></a>]  Theorem
      
      ⊢ ∀x s. x ∈ interior s ⇔ ∃e. 0 &lt; e ∧ cball (x,e) ⊆ s
   
   [<a name="IN_INTERIOR_LINEAR_IMAGE-val"><b>IN_INTERIOR_LINEAR_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f g s x.
          linear f ∧ linear g ∧ f ∘ g = I ∧ x ∈ interior s ⇒
          f x ∈ interior (IMAGE f s)
   
   [<a name="IN_INTERVAL-val"><b>IN_INTERVAL</b></a>]  Theorem
      
      ⊢ (x ∈ interval (a,b) ⇔ a &lt; x ∧ x &lt; b) ∧
        (x ∈ interval [(a,b)] ⇔ a ≤ x ∧ x ≤ b)
   
   [<a name="IN_INTERVAL_REFLECT-val"><b>IN_INTERVAL_REFLECT</b></a>]  Theorem
      
      ⊢ (∀a b x. -x ∈ interval [(-b,-a)] ⇔ x ∈ interval [(a,b)]) ∧
        ∀a b x. -x ∈ interval (-b,-a) ⇔ x ∈ interval (a,b)
   
   [<a name="IN_OPEN_SEGMENT-val"><b>IN_OPEN_SEGMENT</b></a>]  Theorem
      
      ⊢ ∀a b x. x ∈ segment (a,b) ⇔ x ∈ segment [(a,b)] ∧ x ≠ a ∧ x ≠ b
   
   [<a name="IN_OPEN_SEGMENT_ALT-val"><b>IN_OPEN_SEGMENT_ALT</b></a>]  Theorem
      
      ⊢ ∀a b x.
          x ∈ segment (a,b) ⇔ x ∈ segment [(a,b)] ∧ x ≠ a ∧ x ≠ b ∧ a ≠ b
   
   [<a name="IN_SEGMENT-val"><b>IN_SEGMENT</b></a>]  Theorem
      
      ⊢ ∀a b x.
          (x ∈ segment [(a,b)] ⇔
           ∃u. 0 ≤ u ∧ u ≤ 1 ∧ x = (1 − u) * a + u * b) ∧
          (x ∈ segment (a,b) ⇔
           a ≠ b ∧ ∃u. 0 &lt; u ∧ u &lt; 1 ∧ x = (1 − u) * a + u * b)
   
   [<a name="IN_SEGMENT_COMPONENT-val"><b>IN_SEGMENT_COMPONENT</b></a>]  Theorem
      
      ⊢ ∀a b x i. x ∈ segment [(a,b)] ⇒ min a b ≤ x ∧ x ≤ max a b
   
   [<a name="IN_SPAN_DELETE-val"><b>IN_SPAN_DELETE</b></a>]  Theorem
      
      ⊢ ∀a b s.
          a ∈ span s ∧ a ∉ span (s DELETE b) ⇒
          b ∈ span (a INSERT s DELETE b)
   
   [<a name="IN_SPAN_INSERT-val"><b>IN_SPAN_INSERT</b></a>]  Theorem
      
      ⊢ ∀a b s. a ∈ span (b INSERT s) ∧ a ∉ span s ⇒ b ∈ span (a INSERT s)
   
   [<a name="IN_SPHERE-val"><b>IN_SPHERE</b></a>]  Theorem
      
      ⊢ ∀x y e. y ∈ sphere (x,e) ⇔ dist (x,y) = e
   
   [<a name="IN_SPHERE_0-val"><b>IN_SPHERE_0</b></a>]  Theorem
      
      ⊢ ∀x e. x ∈ sphere (0,e) ⇔ abs x = e
   
   [<a name="ISOMETRY_IMP_EMBEDDING-val"><b>ISOMETRY_IMP_EMBEDDING</b></a>]  Theorem
      
      ⊢ ∀f s t.
          IMAGE f s = t ∧
          (∀x y. x ∈ s ∧ y ∈ s ⇒ dist (f x,f y) = dist (x,y)) ⇒
          ∃g. homeomorphism (s,t) (f,g)
   
   [<a name="ISOMETRY_IMP_HOMEOMORPHISM_COMPACT-val"><b>ISOMETRY_IMP_HOMEOMORPHISM_COMPACT</b></a>]  Theorem
      
      ⊢ ∀f s.
          compact s ∧ IMAGE f s ⊆ s ∧
          (∀x y. x ∈ s ∧ y ∈ s ⇒ dist (f x,f y) = dist (x,y)) ⇒
          ∃g. homeomorphism (s,s) (f,g)
   
   [<a name="ISOMETRY_IMP_OPEN_MAP-val"><b>ISOMETRY_IMP_OPEN_MAP</b></a>]  Theorem
      
      ⊢ ∀f s t u.
          IMAGE f s = t ∧
          (∀x y. x ∈ s ∧ y ∈ s ⇒ dist (f x,f y) = dist (x,y)) ∧
          open_in (subtopology euclidean s) u ⇒
          open_in (subtopology euclidean t) (IMAGE f u)
   
   [<a name="ISOMETRY_ON_IMP_CONTINUOUS_ON-val"><b>ISOMETRY_ON_IMP_CONTINUOUS_ON</b></a>]  Theorem
      
      ⊢ ∀f. (∀x y. x ∈ s ∧ y ∈ s ⇒ dist (f x,f y) = dist (x,y)) ⇒
            f continuous_on s
   
   [<a name="IS_INTERVAL-val"><b>IS_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀s. is_interval s ⇔ ∀a b x. a ∈ s ∧ b ∈ s ∧ a ≤ x ∧ x ≤ b ⇒ x ∈ s
   
   [<a name="IS_INTERVAL_CASES-val"><b>IS_INTERVAL_CASES</b></a>]  Theorem
      
      ⊢ ∀s. is_interval s ⇔
            s = ∅ ∨ s = 𝕌(:real) ∨ (∃a. s = {x | a &lt; x}) ∨
            (∃a. s = {x | a ≤ x}) ∨ (∃b. s = {x | x ≤ b}) ∨
            (∃b. s = {x | x &lt; b}) ∨ (∃a b. s = {x | a &lt; x ∧ x &lt; b}) ∨
            (∃a b. s = {x | a &lt; x ∧ x ≤ b}) ∨
            (∃a b. s = {x | a ≤ x ∧ x &lt; b}) ∨ ∃a b. s = {x | a ≤ x ∧ x ≤ b}
   
   [<a name="IS_INTERVAL_COMPACT-val"><b>IS_INTERVAL_COMPACT</b></a>]  Theorem
      
      ⊢ ∀s. is_interval s ∧ compact s ⇔ ∃a b. s = interval [(a,b)]
   
   [<a name="IS_INTERVAL_EMPTY-val"><b>IS_INTERVAL_EMPTY</b></a>]  Theorem
      
      ⊢ is_interval ∅
   
   [<a name="IS_INTERVAL_IMP_LOCALLY_COMPACT-val"><b>IS_INTERVAL_IMP_LOCALLY_COMPACT</b></a>]  Theorem
      
      ⊢ ∀s. is_interval s ⇒ locally compact s
   
   [<a name="IS_INTERVAL_INTER-val"><b>IS_INTERVAL_INTER</b></a>]  Theorem
      
      ⊢ ∀s t. is_interval s ∧ is_interval t ⇒ is_interval (s ∩ t)
   
   [<a name="IS_INTERVAL_INTERVAL-val"><b>IS_INTERVAL_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀a b. is_interval (interval (a,b)) ∧ is_interval (interval [(a,b)])
   
   [<a name="IS_INTERVAL_POINTWISE-val"><b>IS_INTERVAL_POINTWISE</b></a>]  Theorem
      
      ⊢ ∀s x. is_interval s ⇒ (∃a. a ∈ s ∧ a = x) ⇒ x ∈ s
   
   [<a name="IS_INTERVAL_SCALING-val"><b>IS_INTERVAL_SCALING</b></a>]  Theorem
      
      ⊢ ∀s c. is_interval s ⇒ is_interval (IMAGE (λx. c * x) s)
   
   [<a name="IS_INTERVAL_SCALING_EQ-val"><b>IS_INTERVAL_SCALING_EQ</b></a>]  Theorem
      
      ⊢ ∀s c. is_interval (IMAGE (λx. c * x) s) ⇔ c = 0 ∨ is_interval s
   
   [<a name="IS_INTERVAL_SING-val"><b>IS_INTERVAL_SING</b></a>]  Theorem
      
      ⊢ ∀a. is_interval {a}
   
   [<a name="IS_INTERVAL_SUMS-val"><b>IS_INTERVAL_SUMS</b></a>]  Theorem
      
      ⊢ ∀s t.
          is_interval s ∧ is_interval t ⇒
          is_interval {x + y | x ∈ s ∧ y ∈ t}
   
   [<a name="IS_INTERVAL_UNIV-val"><b>IS_INTERVAL_UNIV</b></a>]  Theorem
      
      ⊢ is_interval 𝕌(:real)
   
   [<a name="JOINABLE_COMPONENTS_EQ-val"><b>JOINABLE_COMPONENTS_EQ</b></a>]  Theorem
      
      ⊢ ∀s t c1 c2.
          connected t ∧ t ⊆ s ∧ c1 ∈ components s ∧ c2 ∈ components s ∧
          c1 ∩ t ≠ ∅ ∧ c2 ∩ t ≠ ∅ ⇒
          c1 = c2
   
   [<a name="JOINABLE_CONNECTED_COMPONENT_EQ-val"><b>JOINABLE_CONNECTED_COMPONENT_EQ</b></a>]  Theorem
      
      ⊢ ∀s t x y.
          connected t ∧ t ⊆ s ∧ connected_component s x ∩ t ≠ ∅ ∧
          connected_component s y ∩ t ≠ ∅ ⇒
          connected_component s x = connected_component s y
   
   [<a name="LEBESGUE_COVERING_LEMMA-val"><b>LEBESGUE_COVERING_LEMMA</b></a>]  Theorem
      
      ⊢ ∀s c.
          compact s ∧ c ≠ ∅ ∧ s ⊆ BIGUNION c ∧ (∀b. b ∈ c ⇒ open b) ⇒
          ∃d. 0 &lt; d ∧ ∀t. t ⊆ s ∧ diameter t ≤ d ⇒ ∃b. b ∈ c ∧ t ⊆ b
   
   [<a name="LE_1-val"><b>LE_1</b></a>]  Theorem
      
      ⊢ (∀n. n ≠ 0 ⇒ 0 &lt; n) ∧ (∀n. n ≠ 0 ⇒ 1 ≤ n) ∧ (∀n. 0 &lt; n ⇒ n ≠ 0) ∧
        (∀n. 0 &lt; n ⇒ 1 ≤ n) ∧ (∀n. 1 ≤ n ⇒ 0 &lt; n) ∧ ∀n. 1 ≤ n ⇒ n ≠ 0
   
   [<a name="LIFT_TO_QUOTIENT_SPACE-val"><b>LIFT_TO_QUOTIENT_SPACE</b></a>]  Theorem
      
      ⊢ ∀f h s t u.
          IMAGE f s = t ∧
          (∀v. v ⊆ t ⇒
               (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ v} ⇔
                open_in (subtopology euclidean t) v)) ∧ h continuous_on s ∧
          IMAGE h s = u ∧ (∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ h x = h y) ⇒
          ∃g. g continuous_on t ∧ IMAGE g t = u ∧ ∀x. x ∈ s ⇒ h x = g (f x)
   
   [<a name="LIFT_TO_QUOTIENT_SPACE_UNIQUE-val"><b>LIFT_TO_QUOTIENT_SPACE_UNIQUE</b></a>]  Theorem
      
      ⊢ ∀f g s t u.
          IMAGE f s = t ∧ IMAGE g s = u ∧
          (∀v. v ⊆ t ⇒
               (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ v} ⇔
                open_in (subtopology euclidean t) v)) ∧
          (∀v. v ⊆ u ⇒
               (open_in (subtopology euclidean s) {x | x ∈ s ∧ g x ∈ v} ⇔
                open_in (subtopology euclidean u) v)) ∧
          (∀x y. x ∈ s ∧ y ∈ s ⇒ (f x = f y ⇔ g x = g y)) ⇒
          t homeomorphic u
   
   [<a name="LIMIT_POINT_FINITE-val"><b>LIMIT_POINT_FINITE</b></a>]  Theorem
      
      ⊢ ∀s a. FINITE s ⇒ ¬(a limit_point_of s)
   
   [<a name="LIMIT_POINT_UNION-val"><b>LIMIT_POINT_UNION</b></a>]  Theorem
      
      ⊢ ∀s t x.
          x limit_point_of s ∪ t ⇔ x limit_point_of s ∨ x limit_point_of t
   
   [<a name="LIMPT_APPROACHABLE-val"><b>LIMPT_APPROACHABLE</b></a>]  Theorem
      
      ⊢ ∀x s.
          x limit_point_of s ⇔
          ∀e. 0 &lt; e ⇒ ∃x'. x' ∈ s ∧ x' ≠ x ∧ dist (x',x) &lt; e
   
   [<a name="LIMPT_APPROACHABLE_LE-val"><b>LIMPT_APPROACHABLE_LE</b></a>]  Theorem
      
      ⊢ ∀x s.
          x limit_point_of s ⇔
          ∀e. 0 &lt; e ⇒ ∃x'. x' ∈ s ∧ x' ≠ x ∧ dist (x',x) ≤ e
   
   [<a name="LIMPT_BALL-val"><b>LIMPT_BALL</b></a>]  Theorem
      
      ⊢ ∀x y e. y limit_point_of ball (x,e) ⇔ 0 &lt; e ∧ y ∈ cball (x,e)
   
   [<a name="LIMPT_EMPTY-val"><b>LIMPT_EMPTY</b></a>]  Theorem
      
      ⊢ ∀x. ¬(x limit_point_of ∅)
   
   [<a name="LIMPT_INFINITE_BALL-val"><b>LIMPT_INFINITE_BALL</b></a>]  Theorem
      
      ⊢ ∀s x. x limit_point_of s ⇔ ∀e. 0 &lt; e ⇒ INFINITE (s ∩ ball (x,e))
   
   [<a name="LIMPT_INFINITE_CBALL-val"><b>LIMPT_INFINITE_CBALL</b></a>]  Theorem
      
      ⊢ ∀s x. x limit_point_of s ⇔ ∀e. 0 &lt; e ⇒ INFINITE (s ∩ cball (x,e))
   
   [<a name="LIMPT_INFINITE_OPEN-val"><b>LIMPT_INFINITE_OPEN</b></a>]  Theorem
      
      ⊢ ∀s x. x limit_point_of s ⇔ ∀t. x ∈ t ∧ open t ⇒ INFINITE (s ∩ t)
   
   [<a name="LIMPT_INFINITE_OPEN_BALL_CBALL-val"><b>LIMPT_INFINITE_OPEN_BALL_CBALL</b></a>]  Theorem
      
      ⊢ (∀s x. x limit_point_of s ⇔ ∀t. x ∈ t ∧ open t ⇒ INFINITE (s ∩ t)) ∧
        (∀s x. x limit_point_of s ⇔ ∀e. 0 &lt; e ⇒ INFINITE (s ∩ ball (x,e))) ∧
        ∀s x. x limit_point_of s ⇔ ∀e. 0 &lt; e ⇒ INFINITE (s ∩ cball (x,e))
   
   [<a name="LIMPT_INJECTIVE_LINEAR_IMAGE_EQ-val"><b>LIMPT_INJECTIVE_LINEAR_IMAGE_EQ</b></a>]  Theorem
      
      ⊢ ∀f s.
          linear f ∧ (∀x y. f x = f y ⇒ x = y) ⇒
          (f x limit_point_of IMAGE f s ⇔ x limit_point_of s)
   
   [<a name="LIMPT_INSERT-val"><b>LIMPT_INSERT</b></a>]  Theorem
      
      ⊢ ∀s x y. x limit_point_of y INSERT s ⇔ x limit_point_of s
   
   [<a name="LIMPT_OF_CLOSURE-val"><b>LIMPT_OF_CLOSURE</b></a>]  Theorem
      
      ⊢ ∀x s. x limit_point_of closure s ⇔ x limit_point_of s
   
   [<a name="LIMPT_OF_LIMPTS-val"><b>LIMPT_OF_LIMPTS</b></a>]  Theorem
      
      ⊢ ∀x s.
          x limit_point_of {y | y limit_point_of s} ⇒ x limit_point_of s
   
   [<a name="LIMPT_OF_OPEN-val"><b>LIMPT_OF_OPEN</b></a>]  Theorem
      
      ⊢ ∀s x. open s ∧ x ∈ s ⇒ x limit_point_of s
   
   [<a name="LIMPT_OF_OPEN_IN-val"><b>LIMPT_OF_OPEN_IN</b></a>]  Theorem
      
      ⊢ ∀s t x.
          open_in (subtopology euclidean s) t ∧ x limit_point_of s ∧ x ∈ t ⇒
          x limit_point_of t
   
   [<a name="LIMPT_OF_SEQUENCE_SUBSEQUENCE-val"><b>LIMPT_OF_SEQUENCE_SUBSEQUENCE</b></a>]  Theorem
      
      ⊢ ∀f l.
          l limit_point_of IMAGE f 𝕌(:num) ⇒
          ∃r. (∀m n. m &lt; n ⇒ r m &lt; r n) ∧ (f ∘ r ⟶ l) sequentially
   
   [<a name="LIMPT_OF_UNIV-val"><b>LIMPT_OF_UNIV</b></a>]  Theorem
      
      ⊢ ∀x. x limit_point_of 𝕌(:real)
   
   [<a name="LIMPT_SEQUENTIAL-val"><b>LIMPT_SEQUENTIAL</b></a>]  Theorem
      
      ⊢ ∀x s.
          x limit_point_of s ⇔
          ∃f. (∀n. f n ∈ s DELETE x) ∧ (f ⟶ x) sequentially
   
   [<a name="LIMPT_SEQUENTIAL_INJ-val"><b>LIMPT_SEQUENTIAL_INJ</b></a>]  Theorem
      
      ⊢ ∀x s.
          x limit_point_of s ⇔
          ∃f. (∀n. f n ∈ s DELETE x) ∧ (∀m n. f m = f n ⇔ m = n) ∧
              (f ⟶ x) sequentially
   
   [<a name="LIMPT_SING-val"><b>LIMPT_SING</b></a>]  Theorem
      
      ⊢ ∀x y. ¬(x limit_point_of {y})
   
   [<a name="LIMPT_SUBSET-val"><b>LIMPT_SUBSET</b></a>]  Theorem
      
      ⊢ ∀x s t. x limit_point_of s ∧ s ⊆ t ⇒ x limit_point_of t
   
   [<a name="LIMPT_UNIV-val"><b>LIMPT_UNIV</b></a>]  Theorem
      
      ⊢ ∀x. x limit_point_of 𝕌(:real)
   
   [<a name="LIM_ABS-val"><b>LIM_ABS</b></a>]  Theorem
      
      ⊢ ∀net f l. (f ⟶ l) net ⇒ ((λx. abs (f x)) ⟶ abs l) net
   
   [<a name="LIM_ABS_LBOUND-val"><b>LIM_ABS_LBOUND</b></a>]  Theorem
      
      ⊢ ∀net f l b.
          ¬trivial_limit net ∧ (f ⟶ l) net ∧
          eventually (λx. b ≤ abs (f x)) net ⇒
          b ≤ abs l
   
   [<a name="LIM_ABS_UBOUND-val"><b>LIM_ABS_UBOUND</b></a>]  Theorem
      
      ⊢ ∀net f l b.
          ¬trivial_limit net ∧ (f ⟶ l) net ∧
          eventually (λx. abs (f x) ≤ b) net ⇒
          abs l ≤ b
   
   [<a name="LIM_ADD-val"><b>LIM_ADD</b></a>]  Theorem
      
      ⊢ ∀net f g l m.
          (f ⟶ l) net ∧ (g ⟶ m) net ⇒ ((λx. f x + g x) ⟶ (l + m)) net
   
   [<a name="LIM_AT-val"><b>LIM_AT</b></a>]  Theorem
      
      ⊢ ∀f l a.
          (f ⟶ l) (at a) ⇔
          ∀e. 0 &lt; e ⇒
              ∃d. 0 &lt; d ∧
                  ∀x. 0 &lt; dist (x,a) ∧ dist (x,a) &lt; d ⇒ dist (f x,l) &lt; e
   
   [<a name="LIM_AT_ID-val"><b>LIM_AT_ID</b></a>]  Theorem
      
      ⊢ ∀a. ((λx. x) ⟶ a) (at a)
   
   [<a name="LIM_AT_INFINITY-val"><b>LIM_AT_INFINITY</b></a>]  Theorem
      
      ⊢ ∀f l.
          (f ⟶ l) at_infinity ⇔
          ∀e. 0 &lt; e ⇒ ∃b. ∀x. abs x ≥ b ⇒ dist (f x,l) &lt; e
   
   [<a name="LIM_AT_INFINITY_POS-val"><b>LIM_AT_INFINITY_POS</b></a>]  Theorem
      
      ⊢ ∀f l.
          (f ⟶ l) at_infinity ⇔
          ∀e. 0 &lt; e ⇒ ∃b. 0 &lt; b ∧ ∀x. abs x ≥ b ⇒ dist (f x,l) &lt; e
   
   [<a name="LIM_AT_LE-val"><b>LIM_AT_LE</b></a>]  Theorem
      
      ⊢ ∀f l a.
          (f ⟶ l) (at a) ⇔
          ∀e. 0 &lt; e ⇒
              ∃d. 0 &lt; d ∧
                  ∀x. 0 &lt; dist (x,a) ∧ dist (x,a) ≤ d ⇒ dist (f x,l) &lt; e
   
   [<a name="LIM_AT_NEGINFINITY-val"><b>LIM_AT_NEGINFINITY</b></a>]  Theorem
      
      ⊢ ∀f l.
          (f ⟶ l) at_neginfinity ⇔
          ∀e. 0 &lt; e ⇒ ∃b. ∀x. x ≤ b ⇒ dist (f x,l) &lt; e
   
   [<a name="LIM_AT_POSINFINITY-val"><b>LIM_AT_POSINFINITY</b></a>]  Theorem
      
      ⊢ ∀f l.
          (f ⟶ l) at_posinfinity ⇔
          ∀e. 0 &lt; e ⇒ ∃b. ∀x. x ≥ b ⇒ dist (f x,l) &lt; e
   
   [<a name="LIM_AT_WITHIN-val"><b>LIM_AT_WITHIN</b></a>]  Theorem
      
      ⊢ ∀f l a s. (f ⟶ l) (at a) ⇒ (f ⟶ l) (at a within s)
   
   [<a name="LIM_AT_ZERO-val"><b>LIM_AT_ZERO</b></a>]  Theorem
      
      ⊢ ∀f l a. (f ⟶ l) (at a) ⇔ ((λx. f (a + x)) ⟶ l) (at 0)
   
   [<a name="LIM_BILINEAR-val"><b>LIM_BILINEAR</b></a>]  Theorem
      
      ⊢ ∀net h f g l m.
          (f ⟶ l) net ∧ (g ⟶ m) net ∧ bilinear h ⇒
          ((λx. h (f x) (g x)) ⟶ h l m) net
   
   [<a name="LIM_CASES_COFINITE_SEQUENTIALLY-val"><b>LIM_CASES_COFINITE_SEQUENTIALLY</b></a>]  Theorem
      
      ⊢ ∀f g l.
          FINITE {n | (¬P n)} ⇒
          (((λn. if P n then f n else g n) ⟶ l) sequentially ⇔
           (f ⟶ l) sequentially)
   
   [<a name="LIM_CASES_FINITE_SEQUENTIALLY-val"><b>LIM_CASES_FINITE_SEQUENTIALLY</b></a>]  Theorem
      
      ⊢ ∀f g l.
          FINITE {n | P n} ⇒
          (((λn. if P n then f n else g n) ⟶ l) sequentially ⇔
           (g ⟶ l) sequentially)
   
   [<a name="LIM_CASES_SEQUENTIALLY-val"><b>LIM_CASES_SEQUENTIALLY</b></a>]  Theorem
      
      ⊢ ∀f g l m.
          (((λn. if m ≤ n then f n else g n) ⟶ l) sequentially ⇔
           (f ⟶ l) sequentially) ∧
          (((λn. if m &lt; n then f n else g n) ⟶ l) sequentially ⇔
           (f ⟶ l) sequentially) ∧
          (((λn. if n ≤ m then f n else g n) ⟶ l) sequentially ⇔
           (g ⟶ l) sequentially) ∧
          (((λn. if n &lt; m then f n else g n) ⟶ l) sequentially ⇔
           (g ⟶ l) sequentially)
   
   [<a name="LIM_CMUL-val"><b>LIM_CMUL</b></a>]  Theorem
      
      ⊢ ∀f l c. (f ⟶ l) net ⇒ ((λx. c * f x) ⟶ (c * l)) net
   
   [<a name="LIM_CMUL_EQ-val"><b>LIM_CMUL_EQ</b></a>]  Theorem
      
      ⊢ ∀net f l c. c ≠ 0 ⇒ (((λx. c * f x) ⟶ (c * l)) net ⇔ (f ⟶ l) net)
   
   [<a name="LIM_COMPONENT-val"><b>LIM_COMPONENT</b></a>]  Theorem
      
      ⊢ ∀net f i l. (f ⟶ l) net ⇒ ((λa. f a) ⟶ l) net
   
   [<a name="LIM_COMPONENT_EQ-val"><b>LIM_COMPONENT_EQ</b></a>]  Theorem
      
      ⊢ ∀net f i l b.
          (f ⟶ l) net ∧ ¬trivial_limit net ∧ eventually (λx. f x = b) net ⇒
          l = b
   
   [<a name="LIM_COMPONENT_LBOUND-val"><b>LIM_COMPONENT_LBOUND</b></a>]  Theorem
      
      ⊢ ∀net f l b.
          ¬trivial_limit net ∧ (f ⟶ l) net ∧ eventually (λx. b ≤ f x) net ⇒
          b ≤ l
   
   [<a name="LIM_COMPONENT_LE-val"><b>LIM_COMPONENT_LE</b></a>]  Theorem
      
      ⊢ ∀net f g l m.
          ¬trivial_limit net ∧ (f ⟶ l) net ∧ (g ⟶ m) net ∧
          eventually (λx. f x ≤ g x) net ⇒
          l ≤ m
   
   [<a name="LIM_COMPONENT_UBOUND-val"><b>LIM_COMPONENT_UBOUND</b></a>]  Theorem
      
      ⊢ ∀net f l b k.
          ¬trivial_limit net ∧ (f ⟶ l) net ∧ eventually (λx. f x ≤ b) net ⇒
          l ≤ b
   
   [<a name="LIM_COMPOSE_AT-val"><b>LIM_COMPOSE_AT</b></a>]  Theorem
      
      ⊢ ∀net f g y z.
          (f ⟶ y) net ∧ eventually (λw. f w = y ⇒ g y = z) net ∧
          (g ⟶ z) (at y) ⇒
          (g ∘ f ⟶ z) net
   
   [<a name="LIM_COMPOSE_WITHIN-val"><b>LIM_COMPOSE_WITHIN</b></a>]  Theorem
      
      ⊢ ∀net f g s y z.
          (f ⟶ y) net ∧
          eventually (λw. f w ∈ s ∧ (f w = y ⇒ g y = z)) net ∧
          (g ⟶ z) (at y within s) ⇒
          (g ∘ f ⟶ z) net
   
   [<a name="LIM_CONG_AT-val"><b>LIM_CONG_AT</b></a>]  Theorem
      
      ⊢ (∀x. x ≠ a ⇒ f x = g x) ⇒ (((λx. f x) ⟶ l) (at a) ⇔ (g ⟶ l) (at a))
   
   [<a name="LIM_CONG_WITHIN-val"><b>LIM_CONG_WITHIN</b></a>]  Theorem
      
      ⊢ (∀x. x ≠ a ⇒ f x = g x) ⇒
        (((λx. f x) ⟶ l) (at a within s) ⇔ (g ⟶ l) (at a within s))
   
   [<a name="LIM_CONST-val"><b>LIM_CONST</b></a>]  Theorem
      
      ⊢ ∀net a. ((λx. a) ⟶ a) net
   
   [<a name="LIM_CONST_EQ-val"><b>LIM_CONST_EQ</b></a>]  Theorem
      
      ⊢ ∀net c d. ((λx. c) ⟶ d) net ⇔ trivial_limit net ∨ c = d
   
   [<a name="LIM_CONTINUOUS_FUNCTION-val"><b>LIM_CONTINUOUS_FUNCTION</b></a>]  Theorem
      
      ⊢ ∀f net g l.
          f continuous at l ∧ (g ⟶ l) net ⇒ ((λx. f (g x)) ⟶ f l) net
   
   [<a name="LIM_DEF-val"><b>LIM_DEF</b></a>]  Theorem
      
      ⊢ ∀f l net.
          (f ⟶ l) net ⇔
          trivial_limit net ∨
          ∀e. 0 &lt; e ⇒
              ∃y. (∃x. netord net x y) ∧
                  ∀x. netord net x y ⇒ dist (f x,l) &lt; e
   
   [<a name="LIM_DROP_LBOUND-val"><b>LIM_DROP_LBOUND</b></a>]  Theorem
      
      ⊢ ∀net f l b.
          (f ⟶ l) net ∧ ¬trivial_limit net ∧ eventually (λx. b ≤ f x) net ⇒
          b ≤ l
   
   [<a name="LIM_DROP_LE-val"><b>LIM_DROP_LE</b></a>]  Theorem
      
      ⊢ ∀net f g l m.
          ¬trivial_limit net ∧ (f ⟶ l) net ∧ (g ⟶ m) net ∧
          eventually (λx. f x ≤ g x) net ⇒
          l ≤ m
   
   [<a name="LIM_DROP_UBOUND-val"><b>LIM_DROP_UBOUND</b></a>]  Theorem
      
      ⊢ ∀net f l b.
          (f ⟶ l) net ∧ ¬trivial_limit net ∧ eventually (λx. f x ≤ b) net ⇒
          l ≤ b
   
   [<a name="LIM_EVENTUALLY-val"><b>LIM_EVENTUALLY</b></a>]  Theorem
      
      ⊢ ∀net f l. eventually (λx. f x = l) net ⇒ (f ⟶ l) net
   
   [<a name="LIM_INFINITY_POSINFINITY-val"><b>LIM_INFINITY_POSINFINITY</b></a>]  Theorem
      
      ⊢ ∀f l. (f ⟶ l) at_infinity ⇒ (f ⟶ l) at_posinfinity
   
   [<a name="LIM_INV-val"><b>LIM_INV</b></a>]  Theorem
      
      ⊢ ∀net f l. (f ⟶ l) net ∧ l ≠ 0 ⇒ (realinv ∘ f ⟶ l⁻¹) net
   
   [<a name="LIM_IN_CLOSED_SET-val"><b>LIM_IN_CLOSED_SET</b></a>]  Theorem
      
      ⊢ ∀net f s l.
          closed s ∧ eventually (λx. f x ∈ s) net ∧ ¬trivial_limit net ∧
          (f ⟶ l) net ⇒
          l ∈ s
   
   [<a name="LIM_LIFT_DOT-val"><b>LIM_LIFT_DOT</b></a>]  Theorem
      
      ⊢ ∀f a. (f ⟶ l) net ⇒ ((λy. a * f y) ⟶ (a * l)) net
   
   [<a name="LIM_LINEAR-val"><b>LIM_LINEAR</b></a>]  Theorem
      
      ⊢ ∀net h f l. (f ⟶ l) net ∧ linear h ⇒ ((λx. h (f x)) ⟶ h l) net
   
   [<a name="LIM_MAX-val"><b>LIM_MAX</b></a>]  Theorem
      
      ⊢ ∀net f g l m.
          (f ⟶ l) net ∧ (g ⟶ m) net ⇒ ((λx. max (f x) (g x)) ⟶ max l m) net
   
   [<a name="LIM_MIN-val"><b>LIM_MIN</b></a>]  Theorem
      
      ⊢ ∀net f g l m.
          (f ⟶ l) net ∧ (g ⟶ m) net ⇒ ((λx. min (f x) (g x)) ⟶ min l m) net
   
   [<a name="LIM_MUL-val"><b>LIM_MUL</b></a>]  Theorem
      
      ⊢ ∀net f l c d.
          (c ⟶ d) net ∧ (f ⟶ l) net ⇒ ((λx. c x * f x) ⟶ (d * l)) net
   
   [<a name="LIM_NEG-val"><b>LIM_NEG</b></a>]  Theorem
      
      ⊢ ∀net f l. (f ⟶ l) net ⇒ ((λx. -f x) ⟶ -l) net
   
   [<a name="LIM_NEG_EQ-val"><b>LIM_NEG_EQ</b></a>]  Theorem
      
      ⊢ ∀net f l. ((λx. -f x) ⟶ -l) net ⇔ (f ⟶ l) net
   
   [<a name="LIM_NULL-val"><b>LIM_NULL</b></a>]  Theorem
      
      ⊢ ∀net f l. (f ⟶ l) net ⇔ ((λx. f x − l) ⟶ 0) net
   
   [<a name="LIM_NULL_ABS-val"><b>LIM_NULL_ABS</b></a>]  Theorem
      
      ⊢ ∀net f. (f ⟶ 0) net ⇔ ((λx. abs (f x)) ⟶ 0) net
   
   [<a name="LIM_NULL_ADD-val"><b>LIM_NULL_ADD</b></a>]  Theorem
      
      ⊢ ∀net f g. (f ⟶ 0) net ∧ (g ⟶ 0) net ⇒ ((λx. f x + g x) ⟶ 0) net
   
   [<a name="LIM_NULL_CMUL-val"><b>LIM_NULL_CMUL</b></a>]  Theorem
      
      ⊢ ∀net f c. (f ⟶ 0) net ⇒ ((λx. c * f x) ⟶ 0) net
   
   [<a name="LIM_NULL_CMUL_BOUNDED-val"><b>LIM_NULL_CMUL_BOUNDED</b></a>]  Theorem
      
      ⊢ ∀f g B.
          eventually (λa. g a = 0 ∨ abs (f a) ≤ B) net ∧ (g ⟶ 0) net ⇒
          ((λn. f n * g n) ⟶ 0) net
   
   [<a name="LIM_NULL_CMUL_EQ-val"><b>LIM_NULL_CMUL_EQ</b></a>]  Theorem
      
      ⊢ ∀net f c. c ≠ 0 ⇒ (((λx. c * f x) ⟶ 0) net ⇔ (f ⟶ 0) net)
   
   [<a name="LIM_NULL_COMPARISON-val"><b>LIM_NULL_COMPARISON</b></a>]  Theorem
      
      ⊢ ∀net f g.
          eventually (λx. abs (f x) ≤ g x) net ∧ ((λx. g x) ⟶ 0) net ⇒
          (f ⟶ 0) net
   
   [<a name="LIM_NULL_SUB-val"><b>LIM_NULL_SUB</b></a>]  Theorem
      
      ⊢ ∀net f g. (f ⟶ 0) net ∧ (g ⟶ 0) net ⇒ ((λx. f x − g x) ⟶ 0) net
   
   [<a name="LIM_NULL_SUM-val"><b>LIM_NULL_SUM</b></a>]  Theorem
      
      ⊢ ∀net f s.
          FINITE s ∧ (∀a. a ∈ s ⇒ ((λx. f x a) ⟶ 0) net) ⇒
          ((λx. sum s (f x)) ⟶ 0) net
   
   [<a name="LIM_POSINFINITY_SEQUENTIALLY-val"><b>LIM_POSINFINITY_SEQUENTIALLY</b></a>]  Theorem
      
      ⊢ ∀f l. (f ⟶ l) at_posinfinity ⇒ ((λn. f (&n)) ⟶ l) sequentially
   
   [<a name="LIM_SEQUENTIALLY-val"><b>LIM_SEQUENTIALLY</b></a>]  Theorem
      
      ⊢ ∀s l.
          (s ⟶ l) sequentially ⇔
          ∀e. 0 &lt; e ⇒ ∃N. ∀n. N ≤ n ⇒ dist (s n,l) &lt; e
   
   [<a name="LIM_SUB-val"><b>LIM_SUB</b></a>]  Theorem
      
      ⊢ ∀net f g l m.
          (f ⟶ l) net ∧ (g ⟶ m) net ⇒ ((λx. f x − g x) ⟶ (l − m)) net
   
   [<a name="LIM_SUBSEQUENCE-val"><b>LIM_SUBSEQUENCE</b></a>]  Theorem
      
      ⊢ ∀s r l.
          (∀m n. m &lt; n ⇒ r m &lt; r n) ∧ (s ⟶ l) sequentially ⇒
          (s ∘ r ⟶ l) sequentially
   
   [<a name="LIM_SUBSEQUENCE_WEAK-val"><b>LIM_SUBSEQUENCE_WEAK</b></a>]  Theorem
      
      ⊢ ∀s r l.
          (∀m n. m ≤ n ⇒ r m ≤ r n) ∧ (∀n. ∃m. n ≤ r m) ∧
          (s ⟶ l) sequentially ⇒
          (s ∘ r ⟶ l) sequentially
   
   [<a name="LIM_SUM-val"><b>LIM_SUM</b></a>]  Theorem
      
      ⊢ ∀net f l s.
          FINITE s ∧ (∀i. i ∈ s ⇒ (f i ⟶ l i) net) ⇒
          ((λx. sum s (λi. f i x)) ⟶ sum s l) net
   
   [<a name="LIM_TRANSFORM-val"><b>LIM_TRANSFORM</b></a>]  Theorem
      
      ⊢ ∀net f g l. ((λx. f x − g x) ⟶ 0) net ∧ (f ⟶ l) net ⇒ (g ⟶ l) net
   
   [<a name="LIM_TRANSFORM_AT-val"><b>LIM_TRANSFORM_AT</b></a>]  Theorem
      
      ⊢ ∀f g x d.
          0 &lt; d ∧ (∀x'. 0 &lt; dist (x',x) ∧ dist (x',x) &lt; d ⇒ f x' = g x') ∧
          (f ⟶ l) (at x) ⇒
          (g ⟶ l) (at x)
   
   [<a name="LIM_TRANSFORM_AWAY_AT-val"><b>LIM_TRANSFORM_AWAY_AT</b></a>]  Theorem
      
      ⊢ ∀f g a b.
          a ≠ b ∧ (∀x. x ≠ a ∧ x ≠ b ⇒ f x = g x) ∧ (f ⟶ l) (at a) ⇒
          (g ⟶ l) (at a)
   
   [<a name="LIM_TRANSFORM_AWAY_WITHIN-val"><b>LIM_TRANSFORM_AWAY_WITHIN</b></a>]  Theorem
      
      ⊢ ∀f g a b s.
          a ≠ b ∧ (∀x. x ∈ s ∧ x ≠ a ∧ x ≠ b ⇒ f x = g x) ∧
          (f ⟶ l) (at a within s) ⇒
          (g ⟶ l) (at a within s)
   
   [<a name="LIM_TRANSFORM_BOUND-val"><b>LIM_TRANSFORM_BOUND</b></a>]  Theorem
      
      ⊢ ∀f g.
          eventually (λn. abs (f n) ≤ abs (g n)) net ∧ (g ⟶ 0) net ⇒
          (f ⟶ 0) net
   
   [<a name="LIM_TRANSFORM_EQ-val"><b>LIM_TRANSFORM_EQ</b></a>]  Theorem
      
      ⊢ ∀net f g l. ((λx. f x − g x) ⟶ 0) net ⇒ ((f ⟶ l) net ⇔ (g ⟶ l) net)
   
   [<a name="LIM_TRANSFORM_EVENTUALLY-val"><b>LIM_TRANSFORM_EVENTUALLY</b></a>]  Theorem
      
      ⊢ ∀net f g l.
          eventually (λx. f x = g x) net ∧ (f ⟶ l) net ⇒ (g ⟶ l) net
   
   [<a name="LIM_TRANSFORM_WITHIN-val"><b>LIM_TRANSFORM_WITHIN</b></a>]  Theorem
      
      ⊢ ∀f g x s d.
          0 &lt; d ∧
          (∀x'. x' ∈ s ∧ 0 &lt; dist (x',x) ∧ dist (x',x) &lt; d ⇒ f x' = g x') ∧
          (f ⟶ l) (at x within s) ⇒
          (g ⟶ l) (at x within s)
   
   [<a name="LIM_TRANSFORM_WITHIN_OPEN-val"><b>LIM_TRANSFORM_WITHIN_OPEN</b></a>]  Theorem
      
      ⊢ ∀f g s a l.
          open s ∧ a ∈ s ∧ (∀x. x ∈ s ∧ x ≠ a ⇒ f x = g x) ∧ (f ⟶ l) (at a) ⇒
          (g ⟶ l) (at a)
   
   [<a name="LIM_TRANSFORM_WITHIN_OPEN_IN-val"><b>LIM_TRANSFORM_WITHIN_OPEN_IN</b></a>]  Theorem
      
      ⊢ ∀f g s t a l.
          open_in (subtopology euclidean t) s ∧ a ∈ s ∧
          (∀x. x ∈ s ∧ x ≠ a ⇒ f x = g x) ∧ (f ⟶ l) (at a within t) ⇒
          (g ⟶ l) (at a within t)
   
   [<a name="LIM_TRANSFORM_WITHIN_SET-val"><b>LIM_TRANSFORM_WITHIN_SET</b></a>]  Theorem
      
      ⊢ ∀f a s t.
          eventually (λx. x ∈ s ⇔ x ∈ t) (at a) ⇒
          ((f ⟶ l) (at a within s) ⇔ (f ⟶ l) (at a within t))
   
   [<a name="LIM_TRANSFORM_WITHIN_SET_IMP-val"><b>LIM_TRANSFORM_WITHIN_SET_IMP</b></a>]  Theorem
      
      ⊢ ∀f l a s t.
          eventually (λx. x ∈ t ⇒ x ∈ s) (at a) ∧ (f ⟶ l) (at a within s) ⇒
          (f ⟶ l) (at a within t)
   
   [<a name="LIM_UNION-val"><b>LIM_UNION</b></a>]  Theorem
      
      ⊢ ∀f x l s t.
          (f ⟶ l) (at x within s) ∧ (f ⟶ l) (at x within t) ⇒
          (f ⟶ l) (at x within s ∪ t)
   
   [<a name="LIM_UNION_UNIV-val"><b>LIM_UNION_UNIV</b></a>]  Theorem
      
      ⊢ ∀f x l s t.
          (f ⟶ l) (at x within s) ∧ (f ⟶ l) (at x within t) ∧
          s ∪ t = 𝕌(:real) ⇒
          (f ⟶ l) (at x)
   
   [<a name="LIM_UNIQUE-val"><b>LIM_UNIQUE</b></a>]  Theorem
      
      ⊢ ∀net f l l'.
          ¬trivial_limit net ∧ (f ⟶ l) net ∧ (f ⟶ l') net ⇒ l = l'
   
   [<a name="LIM_VMUL-val"><b>LIM_VMUL</b></a>]  Theorem
      
      ⊢ ∀net c d v. (c ⟶ d) net ⇒ ((λx. c x * v) ⟶ (d * v)) net
   
   [<a name="LIM_WITHIN-val"><b>LIM_WITHIN</b></a>]  Theorem
      
      ⊢ ∀f l a s.
          (f ⟶ l) (at a within s) ⇔
          ∀e. 0 &lt; e ⇒
              ∃d. 0 &lt; d ∧
                  ∀x. x ∈ s ∧ 0 &lt; dist (x,a) ∧ dist (x,a) &lt; d ⇒
                      dist (f x,l) &lt; e
   
   [<a name="LIM_WITHIN_CLOSED_TRIVIAL-val"><b>LIM_WITHIN_CLOSED_TRIVIAL</b></a>]  Theorem
      
      ⊢ ∀a s. closed s ∧ a ∉ s ⇒ trivial_limit (at a within s)
   
   [<a name="LIM_WITHIN_EMPTY-val"><b>LIM_WITHIN_EMPTY</b></a>]  Theorem
      
      ⊢ ∀f l x. (f ⟶ l) (at x within ∅)
   
   [<a name="LIM_WITHIN_ID-val"><b>LIM_WITHIN_ID</b></a>]  Theorem
      
      ⊢ ∀a s. ((λx. x) ⟶ a) (at a within s)
   
   [<a name="LIM_WITHIN_INTERIOR-val"><b>LIM_WITHIN_INTERIOR</b></a>]  Theorem
      
      ⊢ ∀f l s x.
          x ∈ interior s ⇒ ((f ⟶ l) (at x within s) ⇔ (f ⟶ l) (at x))
   
   [<a name="LIM_WITHIN_LE-val"><b>LIM_WITHIN_LE</b></a>]  Theorem
      
      ⊢ ∀f l a s.
          (f ⟶ l) (at a within s) ⇔
          ∀e. 0 &lt; e ⇒
              ∃d. 0 &lt; d ∧
                  ∀x. x ∈ s ∧ 0 &lt; dist (x,a) ∧ dist (x,a) ≤ d ⇒
                      dist (f x,l) &lt; e
   
   [<a name="LIM_WITHIN_OPEN-val"><b>LIM_WITHIN_OPEN</b></a>]  Theorem
      
      ⊢ ∀f l a s.
          a ∈ s ∧ open s ⇒ ((f ⟶ l) (at a within s) ⇔ (f ⟶ l) (at a))
   
   [<a name="LIM_WITHIN_SUBSET-val"><b>LIM_WITHIN_SUBSET</b></a>]  Theorem
      
      ⊢ ∀f l a s. (f ⟶ l) (at a within s) ∧ t ⊆ s ⇒ (f ⟶ l) (at a within t)
   
   [<a name="LIM_WITHIN_UNION-val"><b>LIM_WITHIN_UNION</b></a>]  Theorem
      
      ⊢ (f ⟶ l) (at x within s ∪ t) ⇔
        (f ⟶ l) (at x within s) ∧ (f ⟶ l) (at x within t)
   
   [<a name="LINEAR_0-val"><b>LINEAR_0</b></a>]  Theorem
      
      ⊢ ∀f. linear f ⇒ f 0 = 0
   
   [<a name="LINEAR_ADD-val"><b>LINEAR_ADD</b></a>]  Theorem
      
      ⊢ ∀f x y. linear f ⇒ f (x + y) = f x + f y
   
   [<a name="LINEAR_BOUNDED-val"><b>LINEAR_BOUNDED</b></a>]  Theorem
      
      ⊢ ∀f. linear f ⇒ ∃B. ∀x. abs (f x) ≤ B * abs x
   
   [<a name="LINEAR_BOUNDED_POS-val"><b>LINEAR_BOUNDED_POS</b></a>]  Theorem
      
      ⊢ ∀f. linear f ⇒ ∃B. 0 &lt; B ∧ ∀x. abs (f x) ≤ B * abs x
   
   [<a name="LINEAR_CMUL-val"><b>LINEAR_CMUL</b></a>]  Theorem
      
      ⊢ ∀f c x. linear f ⇒ f (c * x) = c * f x
   
   [<a name="LINEAR_COMPOSE-val"><b>LINEAR_COMPOSE</b></a>]  Theorem
      
      ⊢ ∀f g. linear f ∧ linear g ⇒ linear (g ∘ f)
   
   [<a name="LINEAR_COMPOSE_ADD-val"><b>LINEAR_COMPOSE_ADD</b></a>]  Theorem
      
      ⊢ ∀f g. linear f ∧ linear g ⇒ linear (λx. f x + g x)
   
   [<a name="LINEAR_COMPOSE_CMUL-val"><b>LINEAR_COMPOSE_CMUL</b></a>]  Theorem
      
      ⊢ ∀f c. linear f ⇒ linear (λx. c * f x)
   
   [<a name="LINEAR_COMPOSE_NEG-val"><b>LINEAR_COMPOSE_NEG</b></a>]  Theorem
      
      ⊢ ∀f. linear f ⇒ linear (λx. -f x)
   
   [<a name="LINEAR_COMPOSE_SUB-val"><b>LINEAR_COMPOSE_SUB</b></a>]  Theorem
      
      ⊢ ∀f g. linear f ∧ linear g ⇒ linear (λx. f x − g x)
   
   [<a name="LINEAR_COMPOSE_SUM-val"><b>LINEAR_COMPOSE_SUM</b></a>]  Theorem
      
      ⊢ ∀f s.
          FINITE s ∧ (∀a. a ∈ s ⇒ linear (f a)) ⇒
          linear (λx. sum s (λa. f a x))
   
   [<a name="LINEAR_CONTINUOUS_AT-val"><b>LINEAR_CONTINUOUS_AT</b></a>]  Theorem
      
      ⊢ ∀f a. linear f ⇒ f continuous at a
   
   [<a name="LINEAR_CONTINUOUS_COMPOSE-val"><b>LINEAR_CONTINUOUS_COMPOSE</b></a>]  Theorem
      
      ⊢ ∀net f g.
          f continuous net ∧ linear g ⇒ (λx. g (f x)) continuous net
   
   [<a name="LINEAR_CONTINUOUS_ON-val"><b>LINEAR_CONTINUOUS_ON</b></a>]  Theorem
      
      ⊢ ∀f s. linear f ⇒ f continuous_on s
   
   [<a name="LINEAR_CONTINUOUS_ON_COMPOSE-val"><b>LINEAR_CONTINUOUS_ON_COMPOSE</b></a>]  Theorem
      
      ⊢ ∀f g s.
          f continuous_on s ∧ linear g ⇒ (λx. g (f x)) continuous_on s
   
   [<a name="LINEAR_CONTINUOUS_WITHIN-val"><b>LINEAR_CONTINUOUS_WITHIN</b></a>]  Theorem
      
      ⊢ ∀f s x. linear f ⇒ f continuous (at x within s)
   
   [<a name="LINEAR_EQ-val"><b>LINEAR_EQ</b></a>]  Theorem
      
      ⊢ ∀f g b s.
          linear f ∧ linear g ∧ s ⊆ span b ∧ (∀x. x ∈ b ⇒ f x = g x) ⇒
          ∀x. x ∈ s ⇒ f x = g x
   
   [<a name="LINEAR_EQ_0-val"><b>LINEAR_EQ_0</b></a>]  Theorem
      
      ⊢ ∀f b s.
          linear f ∧ s ⊆ span b ∧ (∀x. x ∈ b ⇒ f x = 0) ⇒
          ∀x. x ∈ s ⇒ f x = 0
   
   [<a name="LINEAR_EQ_0_SPAN-val"><b>LINEAR_EQ_0_SPAN</b></a>]  Theorem
      
      ⊢ ∀f b. linear f ∧ (∀x. x ∈ b ⇒ f x = 0) ⇒ ∀x. x ∈ span b ⇒ f x = 0
   
   [<a name="LINEAR_EQ_STDBASIS-val"><b>LINEAR_EQ_STDBASIS</b></a>]  Theorem
      
      ⊢ ∀f g. linear f ∧ linear g ∧ (∀i. 1 ≤ i ∧ i ≤ 1 ⇒ f i = g i) ⇒ f = g
   
   [<a name="LINEAR_ID-val"><b>LINEAR_ID</b></a>]  Theorem
      
      ⊢ linear (λx. x)
   
   [<a name="LINEAR_IMAGE_SUBSET_INTERIOR-val"><b>LINEAR_IMAGE_SUBSET_INTERIOR</b></a>]  Theorem
      
      ⊢ ∀f s.
          linear f ∧ (∀y. ∃x. f x = y) ⇒
          IMAGE f (interior s) ⊆ interior (IMAGE f s)
   
   [<a name="LINEAR_INDEPENDENT_EXTEND-val"><b>LINEAR_INDEPENDENT_EXTEND</b></a>]  Theorem
      
      ⊢ ∀f b. independent b ⇒ ∃g. linear g ∧ ∀x. x ∈ b ⇒ g x = f x
   
   [<a name="LINEAR_INDEPENDENT_EXTEND_LEMMA-val"><b>LINEAR_INDEPENDENT_EXTEND_LEMMA</b></a>]  Theorem
      
      ⊢ ∀f b.
          FINITE b ⇒
          independent b ⇒
          ∃g. (∀x y. x ∈ span b ∧ y ∈ span b ⇒ g (x + y) = g x + g y) ∧
              (∀x c. x ∈ span b ⇒ g (c * x) = c * g x) ∧
              ∀x. x ∈ b ⇒ g x = f x
   
   [<a name="LINEAR_INJECTIVE_0_SUBSPACE-val"><b>LINEAR_INJECTIVE_0_SUBSPACE</b></a>]  Theorem
      
      ⊢ ∀f s.
          linear f ∧ subspace s ⇒
          ((∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y) ⇔
           ∀x. x ∈ s ∧ f x = 0 ⇒ x = 0)
   
   [<a name="LINEAR_INJECTIVE_BOUNDED_BELOW_POS-val"><b>LINEAR_INJECTIVE_BOUNDED_BELOW_POS</b></a>]  Theorem
      
      ⊢ ∀f. linear f ∧ (∀x y. f x = f y ⇒ x = y) ⇒
            ∃B. 0 &lt; B ∧ ∀x. abs x * B ≤ abs (f x)
   
   [<a name="LINEAR_INJECTIVE_IMP_SURJECTIVE-val"><b>LINEAR_INJECTIVE_IMP_SURJECTIVE</b></a>]  Theorem
      
      ⊢ ∀f. linear f ∧ (∀x y. f x = f y ⇒ x = y) ⇒ ∀y. ∃x. f x = y
   
   [<a name="LINEAR_INJECTIVE_LEFT_INVERSE-val"><b>LINEAR_INJECTIVE_LEFT_INVERSE</b></a>]  Theorem
      
      ⊢ ∀f. linear f ∧ (∀x y. f x = f y ⇒ x = y) ⇒
            ∃g. linear g ∧ g ∘ f = (λx. x)
   
   [<a name="LINEAR_INTERIOR_IMAGE_SUBSET-val"><b>LINEAR_INTERIOR_IMAGE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀f s.
          linear f ∧ (∀x y. f x = f y ⇒ x = y) ⇒
          interior (IMAGE f s) ⊆ IMAGE f (interior s)
   
   [<a name="LINEAR_INVERTIBLE_BOUNDED_BELOW-val"><b>LINEAR_INVERTIBLE_BOUNDED_BELOW</b></a>]  Theorem
      
      ⊢ ∀f g.
          linear f ∧ linear g ∧ g ∘ f = I ⇒ ∃B. ∀x. B * abs x ≤ abs (f x)
   
   [<a name="LINEAR_INVERTIBLE_BOUNDED_BELOW_POS-val"><b>LINEAR_INVERTIBLE_BOUNDED_BELOW_POS</b></a>]  Theorem
      
      ⊢ ∀f g.
          linear f ∧ linear g ∧ g ∘ f = I ⇒
          ∃B. 0 &lt; B ∧ ∀x. B * abs x ≤ abs (f x)
   
   [<a name="LINEAR_LIM_0-val"><b>LINEAR_LIM_0</b></a>]  Theorem
      
      ⊢ ∀f. linear f ⇒ (f ⟶ 0) (at 0)
   
   [<a name="LINEAR_MUL_COMPONENT-val"><b>LINEAR_MUL_COMPONENT</b></a>]  Theorem
      
      ⊢ ∀f v. linear f ⇒ linear (λx. f x * v)
   
   [<a name="LINEAR_NEG-val"><b>LINEAR_NEG</b></a>]  Theorem
      
      ⊢ ∀f x. linear f ⇒ f (-x) = -f x
   
   [<a name="LINEAR_NEGATION-val"><b>LINEAR_NEGATION</b></a>]  Theorem
      
      ⊢ linear (λx. -x)
   
   [<a name="LINEAR_OPEN_MAPPING-val"><b>LINEAR_OPEN_MAPPING</b></a>]  Theorem
      
      ⊢ ∀f g.
          linear f ∧ linear g ∧ f ∘ g = I ⇒ ∀s. open s ⇒ open (IMAGE f s)
   
   [<a name="LINEAR_SCALING-val"><b>LINEAR_SCALING</b></a>]  Theorem
      
      ⊢ ∀c. linear (λx. c * x)
   
   [<a name="LINEAR_SUB-val"><b>LINEAR_SUB</b></a>]  Theorem
      
      ⊢ ∀f x y. linear f ⇒ f (x − y) = f x − f y
   
   [<a name="LINEAR_SUM-val"><b>LINEAR_SUM</b></a>]  Theorem
      
      ⊢ ∀f g s. linear f ∧ FINITE s ⇒ f (sum s g) = sum s (f ∘ g)
   
   [<a name="LINEAR_SUM_MUL-val"><b>LINEAR_SUM_MUL</b></a>]  Theorem
      
      ⊢ ∀f s c v.
          linear f ∧ FINITE s ⇒
          f (sum s (λi. c i * v i)) = sum s (λi. c i * f (v i))
   
   [<a name="LINEAR_UNIFORMLY_CONTINUOUS_ON-val"><b>LINEAR_UNIFORMLY_CONTINUOUS_ON</b></a>]  Theorem
      
      ⊢ ∀f s. linear f ⇒ f uniformly_continuous_on s
   
   [<a name="LINEAR_ZERO-val"><b>LINEAR_ZERO</b></a>]  Theorem
      
      ⊢ linear (λx. 0)
   
   [<a name="LOCALLY_CLOSED-val"><b>LOCALLY_CLOSED</b></a>]  Theorem
      
      ⊢ ∀s. locally closed s ⇔ locally compact s
   
   [<a name="LOCALLY_COMPACT-val"><b>LOCALLY_COMPACT</b></a>]  Theorem
      
      ⊢ ∀s. locally compact s ⇔
            ∀x. x ∈ s ⇒
                ∃u v.
                  x ∈ u ∧ u ⊆ v ∧ v ⊆ s ∧
                  open_in (subtopology euclidean s) u ∧ compact v
   
   [<a name="LOCALLY_COMPACT_ALT-val"><b>LOCALLY_COMPACT_ALT</b></a>]  Theorem
      
      ⊢ ∀s. locally compact s ⇔
            ∀x. x ∈ s ⇒
                ∃u. x ∈ u ∧ open_in (subtopology euclidean s) u ∧
                    compact (closure u) ∧ closure u ⊆ s
   
   [<a name="LOCALLY_COMPACT_CLOSED_IN-val"><b>LOCALLY_COMPACT_CLOSED_IN</b></a>]  Theorem
      
      ⊢ ∀s t.
          closed_in (subtopology euclidean s) t ∧ locally compact s ⇒
          locally compact t
   
   [<a name="LOCALLY_COMPACT_CLOSED_INTER_OPEN-val"><b>LOCALLY_COMPACT_CLOSED_INTER_OPEN</b></a>]  Theorem
      
      ⊢ ∀s. locally compact s ⇔ ∃t u. closed t ∧ open u ∧ s = t ∩ u
   
   [<a name="LOCALLY_COMPACT_CLOSED_IN_OPEN-val"><b>LOCALLY_COMPACT_CLOSED_IN_OPEN</b></a>]  Theorem
      
      ⊢ ∀s. locally compact s ⇒
            ∃t. open t ∧ closed_in (subtopology euclidean t) s
   
   [<a name="LOCALLY_COMPACT_CLOSED_UNION-val"><b>LOCALLY_COMPACT_CLOSED_UNION</b></a>]  Theorem
      
      ⊢ ∀s t.
          locally compact s ∧ locally compact t ∧
          closed_in (subtopology euclidean (s ∪ t)) s ∧
          closed_in (subtopology euclidean (s ∪ t)) t ⇒
          locally compact (s ∪ t)
   
   [<a name="LOCALLY_COMPACT_COMPACT-val"><b>LOCALLY_COMPACT_COMPACT</b></a>]  Theorem
      
      ⊢ ∀s. locally compact s ⇔
            ∀k. k ⊆ s ∧ compact k ⇒
                ∃u v.
                  k ⊆ u ∧ u ⊆ v ∧ v ⊆ s ∧
                  open_in (subtopology euclidean s) u ∧ compact v
   
   [<a name="LOCALLY_COMPACT_COMPACT_ALT-val"><b>LOCALLY_COMPACT_COMPACT_ALT</b></a>]  Theorem
      
      ⊢ ∀s. locally compact s ⇔
            ∀k. k ⊆ s ∧ compact k ⇒
                ∃u. k ⊆ u ∧ open_in (subtopology euclidean s) u ∧
                    compact (closure u) ∧ closure u ⊆ s
   
   [<a name="LOCALLY_COMPACT_COMPACT_SUBOPEN-val"><b>LOCALLY_COMPACT_COMPACT_SUBOPEN</b></a>]  Theorem
      
      ⊢ ∀s. locally compact s ⇔
            ∀k t.
              k ⊆ s ∧ compact k ∧ open t ∧ k ⊆ t ⇒
              ∃u v.
                k ⊆ u ∧ u ⊆ v ∧ u ⊆ t ∧ v ⊆ s ∧
                open_in (subtopology euclidean s) u ∧ compact v
   
   [<a name="LOCALLY_COMPACT_DELETE-val"><b>LOCALLY_COMPACT_DELETE</b></a>]  Theorem
      
      ⊢ ∀s a. locally compact s ⇒ locally compact (s DELETE a)
   
   [<a name="LOCALLY_COMPACT_INTER-val"><b>LOCALLY_COMPACT_INTER</b></a>]  Theorem
      
      ⊢ ∀s t.
          locally compact s ∧ locally compact t ⇒ locally compact (s ∩ t)
   
   [<a name="LOCALLY_COMPACT_INTER_CBALL-val"><b>LOCALLY_COMPACT_INTER_CBALL</b></a>]  Theorem
      
      ⊢ ∀s. locally compact s ⇔
            ∀x. x ∈ s ⇒ ∃e. 0 &lt; e ∧ closed (cball (x,e) ∩ s)
   
   [<a name="LOCALLY_COMPACT_INTER_CBALLS-val"><b>LOCALLY_COMPACT_INTER_CBALLS</b></a>]  Theorem
      
      ⊢ ∀s. locally compact s ⇔
            ∀x. x ∈ s ⇒ ∃e. 0 &lt; e ∧ ∀d. d ≤ e ⇒ closed (cball (x,d) ∩ s)
   
   [<a name="LOCALLY_COMPACT_OPEN_IN-val"><b>LOCALLY_COMPACT_OPEN_IN</b></a>]  Theorem
      
      ⊢ ∀s t.
          open_in (subtopology euclidean s) t ∧ locally compact s ⇒
          locally compact t
   
   [<a name="LOCALLY_COMPACT_OPEN_INTER_CLOSURE-val"><b>LOCALLY_COMPACT_OPEN_INTER_CLOSURE</b></a>]  Theorem
      
      ⊢ ∀s. locally compact s ⇒ ∃t. open t ∧ s = t ∩ closure s
   
   [<a name="LOCALLY_COMPACT_OPEN_UNION-val"><b>LOCALLY_COMPACT_OPEN_UNION</b></a>]  Theorem
      
      ⊢ ∀s t.
          locally compact s ∧ locally compact t ∧
          open_in (subtopology euclidean (s ∪ t)) s ∧
          open_in (subtopology euclidean (s ∪ t)) t ⇒
          locally compact (s ∪ t)
   
   [<a name="LOCALLY_COMPACT_PROPER_IMAGE-val"><b>LOCALLY_COMPACT_PROPER_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s.
          f continuous_on s ∧
          (∀k. k ⊆ IMAGE f s ∧ compact k ⇒ compact {x | x ∈ s ∧ f x ∈ k}) ∧
          locally compact s ⇒
          locally compact (IMAGE f s)
   
   [<a name="LOCALLY_COMPACT_PROPER_IMAGE_EQ-val"><b>LOCALLY_COMPACT_PROPER_IMAGE_EQ</b></a>]  Theorem
      
      ⊢ ∀f s.
          f continuous_on s ∧
          (∀k. k ⊆ IMAGE f s ∧ compact k ⇒ compact {x | x ∈ s ∧ f x ∈ k}) ⇒
          (locally compact s ⇔ locally compact (IMAGE f s))
   
   [<a name="LOCALLY_COMPACT_TRANSLATION_EQ-val"><b>LOCALLY_COMPACT_TRANSLATION_EQ</b></a>]  Theorem
      
      ⊢ ∀a s. locally compact (IMAGE (λx. a + x) s) ⇔ locally compact s
   
   [<a name="LOCALLY_COMPACT_UNIV-val"><b>LOCALLY_COMPACT_UNIV</b></a>]  Theorem
      
      ⊢ locally compact 𝕌(:real)
   
   [<a name="LOCALLY_DIFF_CLOSED-val"><b>LOCALLY_DIFF_CLOSED</b></a>]  Theorem
      
      ⊢ ∀P s t.
          locally P s ∧ closed_in (subtopology euclidean s) t ⇒
          locally P (s DIFF t)
   
   [<a name="LOCALLY_EMPTY-val"><b>LOCALLY_EMPTY</b></a>]  Theorem
      
      ⊢ ∀P. locally P ∅
   
   [<a name="LOCALLY_INJECTIVE_LINEAR_IMAGE-val"><b>LOCALLY_INJECTIVE_LINEAR_IMAGE</b></a>]  Theorem
      
      ⊢ ∀P Q.
          (∀f s.
             linear f ∧ (∀x y. f x = f y ⇒ x = y) ⇒ (P (IMAGE f s) ⇔ Q s)) ⇒
          ∀f s.
            linear f ∧ (∀x y. f x = f y ⇒ x = y) ⇒
            (locally P (IMAGE f s) ⇔ locally Q s)
   
   [<a name="LOCALLY_INTER-val"><b>LOCALLY_INTER</b></a>]  Theorem
      
      ⊢ ∀P. (∀s t. P s ∧ P t ⇒ P (s ∩ t)) ⇒
            ∀s t. locally P s ∧ locally P t ⇒ locally P (s ∩ t)
   
   [<a name="LOCALLY_MONO-val"><b>LOCALLY_MONO</b></a>]  Theorem
      
      ⊢ ∀P Q s. (∀t. P t ⇒ Q t) ∧ locally P s ⇒ locally Q s
   
   [<a name="LOCALLY_OPEN_MAP_IMAGE-val"><b>LOCALLY_OPEN_MAP_IMAGE</b></a>]  Theorem
      
      ⊢ ∀P Q f s.
          f continuous_on s ∧
          (∀t. open_in (subtopology euclidean s) t ⇒
               open_in (subtopology euclidean (IMAGE f s)) (IMAGE f t)) ∧
          (∀t. t ⊆ s ∧ P t ⇒ Q (IMAGE f t)) ∧ locally P s ⇒
          locally Q (IMAGE f s)
   
   [<a name="LOCALLY_OPEN_SUBSET-val"><b>LOCALLY_OPEN_SUBSET</b></a>]  Theorem
      
      ⊢ ∀P s t.
          locally P s ∧ open_in (subtopology euclidean s) t ⇒ locally P t
   
   [<a name="LOCALLY_SING-val"><b>LOCALLY_SING</b></a>]  Theorem
      
      ⊢ ∀P a. locally P {a} ⇔ P {a}
   
   [<a name="LOCALLY_TRANSLATION-val"><b>LOCALLY_TRANSLATION</b></a>]  Theorem
      
      ⊢ ∀P. (∀a s. P (IMAGE (λx. a + x) s) ⇔ P s) ⇒
            ∀a s. locally P (IMAGE (λx. a + x) s) ⇔ locally P s
   
   [<a name="LOWER_HEMICONTINUOUS-val"><b>LOWER_HEMICONTINUOUS</b></a>]  Theorem
      
      ⊢ ∀f t s.
          (∀x. x ∈ s ⇒ f x ⊆ t) ⇒
          ((∀u. closed_in (subtopology euclidean t) u ⇒
                closed_in (subtopology euclidean s) {x | x ∈ s ∧ f x ⊆ u}) ⇔
           ∀u. open_in (subtopology euclidean t) u ⇒
               open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∩ u ≠ ∅})
   
   [<a name="MAPPING_CONNECTED_ONTO_SEGMENT-val"><b>MAPPING_CONNECTED_ONTO_SEGMENT</b></a>]  Theorem
      
      ⊢ ∀s a b.
          connected s ∧ ¬(∃a. s ⊆ {a}) ⇒
          ∃f. f continuous_on s ∧ IMAGE f s = segment [(a,b)]
   
   [<a name="MAXIMAL_INDEPENDENT_SUBSET-val"><b>MAXIMAL_INDEPENDENT_SUBSET</b></a>]  Theorem
      
      ⊢ ∀v. ∃b. b ⊆ v ∧ independent b ∧ v ⊆ span b
   
   [<a name="MAXIMAL_INDEPENDENT_SUBSET_EXTEND-val"><b>MAXIMAL_INDEPENDENT_SUBSET_EXTEND</b></a>]  Theorem
      
      ⊢ ∀s v.
          s ⊆ v ∧ independent s ⇒
          ∃b. s ⊆ b ∧ b ⊆ v ∧ independent b ∧ v ⊆ span b
   
   [<a name="METRIZABLE_SPACE_EUCLIDEAN-val"><b>METRIZABLE_SPACE_EUCLIDEAN</b></a>]  Theorem
      
      ⊢ metrizable_space euclidean
   
   [<a name="MIDPOINT_COLLINEAR-val"><b>MIDPOINT_COLLINEAR</b></a>]  Theorem
      
      ⊢ ∀a b c.
          a ≠ c ⇒
          (b = midpoint (a,c) ⇔
           collinear {a; b; c} ∧ dist (a,b) = dist (b,c))
   
   [<a name="MIDPOINT_EQ_ENDPOINT-val"><b>MIDPOINT_EQ_ENDPOINT</b></a>]  Theorem
      
      ⊢ ∀a b.
          (midpoint (a,b) = a ⇔ a = b) ∧ (midpoint (a,b) = b ⇔ a = b) ∧
          (a = midpoint (a,b) ⇔ a = b) ∧ (b = midpoint (a,b) ⇔ a = b)
   
   [<a name="MIDPOINT_IN_SEGMENT-val"><b>MIDPOINT_IN_SEGMENT</b></a>]  Theorem
      
      ⊢ (∀a b. midpoint (a,b) ∈ segment [(a,b)]) ∧
        ∀a b. midpoint (a,b) ∈ segment (a,b) ⇔ a ≠ b
   
   [<a name="MIDPOINT_LINEAR_IMAGE-val"><b>MIDPOINT_LINEAR_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f a b. linear f ⇒ midpoint (f a,f b) = f (midpoint (a,b))
   
   [<a name="MIDPOINT_REFL-val"><b>MIDPOINT_REFL</b></a>]  Theorem
      
      ⊢ ∀x. midpoint (x,x) = x
   
   [<a name="MIDPOINT_SYM-val"><b>MIDPOINT_SYM</b></a>]  Theorem
      
      ⊢ ∀a b. midpoint (a,b) = midpoint (b,a)
   
   [<a name="MONOTONE_BIGGER-val"><b>MONOTONE_BIGGER</b></a>]  Theorem
      
      ⊢ ∀r. (∀m n. m &lt; n ⇒ r m &lt; r n) ⇒ ∀n. n ≤ r n
   
   [<a name="MONOTONE_SUBSEQUENCE-val"><b>MONOTONE_SUBSEQUENCE</b></a>]  Theorem
      
      ⊢ ∀s. ∃r.
          (∀m n. m &lt; n ⇒ r m &lt; r n) ∧
          ((∀m n. m ≤ n ⇒ s (r m) ≤ s (r n)) ∨
           ∀m n. m ≤ n ⇒ s (r n) ≤ s (r m))
   
   [<a name="MUL_CAUCHY_SCHWARZ_EQUAL-val"><b>MUL_CAUCHY_SCHWARZ_EQUAL</b></a>]  Theorem
      
      ⊢ ∀x y. (x * y)² = x * x * (y * y) ⇔ collinear {0; x; y}
   
   [<a name="MUMFORD_LEMMA-val"><b>MUMFORD_LEMMA</b></a>]  Theorem
      
      ⊢ ∀f s t y.
          f continuous_on s ∧ IMAGE f s ⊆ t ∧ locally compact s ∧ y ∈ t ∧
          compact {x | x ∈ s ∧ f x = y} ⇒
          ∃u v.
            open_in (subtopology euclidean s) u ∧
            open_in (subtopology euclidean t) v ∧
            {x | x ∈ s ∧ f x = y} ⊆ u ∧ y ∈ v ∧ IMAGE f u ⊆ v ∧
            ∀k. k ⊆ v ∧ compact k ⇒ compact {x | x ∈ u ∧ f x ∈ k}
   
   [<a name="NEGATIONS_BALL-val"><b>NEGATIONS_BALL</b></a>]  Theorem
      
      ⊢ ∀r. IMAGE (λx. -x) (ball (0,r)) = ball (0,r)
   
   [<a name="NEGATIONS_CBALL-val"><b>NEGATIONS_CBALL</b></a>]  Theorem
      
      ⊢ ∀r. IMAGE (λx. -x) (cball (0,r)) = cball (0,r)
   
   [<a name="NEGATIONS_SPHERE-val"><b>NEGATIONS_SPHERE</b></a>]  Theorem
      
      ⊢ ∀r. IMAGE (λx. -x) (sphere (0,r)) = sphere (0,r)
   
   [<a name="NET-val"><b>NET</b></a>]  Theorem
      
      ⊢ ∀n x y.
          (∀z. netord n z x ⇒ netord n z y) ∨
          ∀z. netord n z y ⇒ netord n z x
   
   [<a name="NETLIMIT_AT-val"><b>NETLIMIT_AT</b></a>]  Theorem
      
      ⊢ ∀a. netlimit (at a) = a
   
   [<a name="NETLIMIT_WITHIN-val"><b>NETLIMIT_WITHIN</b></a>]  Theorem
      
      ⊢ ∀a s. ¬trivial_limit (at a within s) ⇒ netlimit (at a within s) = a
   
   [<a name="NETLIMIT_WITHIN_INTERIOR-val"><b>NETLIMIT_WITHIN_INTERIOR</b></a>]  Theorem
      
      ⊢ ∀s x. x ∈ interior s ⇒ netlimit (at x within s) = x
   
   [<a name="NET_DILEMMA-val"><b>NET_DILEMMA</b></a>]  Theorem
      
      ⊢ ∀net.
          (∃a. (∃x. netord net x a) ∧ ∀x. netord net x a ⇒ P x) ∧
          (∃b. (∃x. netord net x b) ∧ ∀x. netord net x b ⇒ Q x) ⇒
          ∃c. (∃x. netord net x c) ∧ ∀x. netord net x c ⇒ P x ∧ Q x
   
   [<a name="NONTRIVIAL_LIMIT_WITHIN-val"><b>NONTRIVIAL_LIMIT_WITHIN</b></a>]  Theorem
      
      ⊢ ∀net s. trivial_limit net ⇒ trivial_limit (net within s)
   
   [<a name="NOT_BOUNDED_UNIV-val"><b>NOT_BOUNDED_UNIV</b></a>]  Theorem
      
      ⊢ ¬bounded 𝕌(:real)
   
   [<a name="NOT_EVENTUALLY-val"><b>NOT_EVENTUALLY</b></a>]  Theorem
      
      ⊢ ∀net p. (∀x. ¬p x) ∧ ¬trivial_limit net ⇒ ¬eventually p net
   
   [<a name="NOT_INTERVAL_UNIV-val"><b>NOT_INTERVAL_UNIV</b></a>]  Theorem
      
      ⊢ (∀a b. interval [(a,b)] ≠ 𝕌(:real)) ∧
        ∀a b. interval (a,b) ≠ 𝕌(:real)
   
   [<a name="NOWHERE_DENSE-val"><b>NOWHERE_DENSE</b></a>]  Theorem
      
      ⊢ ∀s. interior (closure s) = ∅ ⇔
            ∀t. open t ∧ t ≠ ∅ ⇒ ∃u. open u ∧ u ≠ ∅ ∧ u ⊆ t ∧ u ∩ s = ∅
   
   [<a name="NOWHERE_DENSE_COUNTABLE_BIGUNION-val"><b>NOWHERE_DENSE_COUNTABLE_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀g. countable g ∧ (∀s. s ∈ g ⇒ interior (closure s) = ∅) ⇒
            interior (BIGUNION g) = ∅
   
   [<a name="NOWHERE_DENSE_COUNTABLE_BIGUNION_CLOSED-val"><b>NOWHERE_DENSE_COUNTABLE_BIGUNION_CLOSED</b></a>]  Theorem
      
      ⊢ ∀g. countable g ∧ (∀s. s ∈ g ⇒ closed s ∧ interior s = ∅) ⇒
            interior (BIGUNION g) = ∅
   
   [<a name="NOWHERE_DENSE_UNION-val"><b>NOWHERE_DENSE_UNION</b></a>]  Theorem
      
      ⊢ ∀s t.
          interior (closure (s ∪ t)) = ∅ ⇔
          interior (closure s) = ∅ ∧ interior (closure t) = ∅
   
   [<a name="NO_LIMIT_POINT_IMP_CLOSED-val"><b>NO_LIMIT_POINT_IMP_CLOSED</b></a>]  Theorem
      
      ⊢ ∀s. ¬(∃x. x limit_point_of s) ⇒ closed s
   
   [<a name="OLDNET-val"><b>OLDNET</b></a>]  Theorem
      
      ⊢ ∀n x y.
          netord n x x ∧ netord n y y ⇒
          ∃z. netord n z z ∧ ∀w. netord n w z ⇒ netord n w x ∧ netord n w y
   
   [<a name="OPEN-val"><b>OPEN</b></a>]  Theorem
      
      ⊢ ∀s. open s ⇔ ∀x. x ∈ s ⇒ ∃e. 0 &lt; e ∧ ∀x'. abs (x' − x) &lt; e ⇒ x' ∈ s
   
   [<a name="OPEN_AFFINITY-val"><b>OPEN_AFFINITY</b></a>]  Theorem
      
      ⊢ ∀s a c. open s ∧ c ≠ 0 ⇒ open (IMAGE (λx. a + c * x) s)
   
   [<a name="OPEN_BALL-val"><b>OPEN_BALL</b></a>]  Theorem
      
      ⊢ ∀x e. open (ball (x,e))
   
   [<a name="OPEN_BIGINTER-val"><b>OPEN_BIGINTER</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ∧ (∀t. t ∈ s ⇒ open t) ⇒ open (BIGINTER s)
   
   [<a name="OPEN_BIGUNION-val"><b>OPEN_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀f. (∀s. s ∈ f ⇒ open s) ⇒ open (BIGUNION f)
   
   [<a name="OPEN_BIJECTIVE_LINEAR_IMAGE_EQ-val"><b>OPEN_BIJECTIVE_LINEAR_IMAGE_EQ</b></a>]  Theorem
      
      ⊢ ∀f s.
          linear f ∧ (∀x y. f x = f y ⇒ x = y) ∧ (∀y. ∃x. f x = y) ⇒
          (open (IMAGE f s) ⇔ open s)
   
   [<a name="OPEN_CLOSED-val"><b>OPEN_CLOSED</b></a>]  Theorem
      
      ⊢ ∀s. open s ⇔ closed (𝕌(:real) DIFF s)
   
   [<a name="OPEN_CLOSED_INTERVAL-val"><b>OPEN_CLOSED_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀a b. interval (a,b) = interval [(a,b)] DIFF {a; b}
   
   [<a name="OPEN_CLOSED_INTERVAL_CONVEX-val"><b>OPEN_CLOSED_INTERVAL_CONVEX</b></a>]  Theorem
      
      ⊢ ∀a b x y e.
          x ∈ interval (a,b) ∧ y ∈ interval [(a,b)] ∧ 0 &lt; e ∧ e ≤ 1 ⇒
          e * x + (1 − e) * y ∈ interval (a,b)
   
   [<a name="OPEN_CONTAINS_BALL-val"><b>OPEN_CONTAINS_BALL</b></a>]  Theorem
      
      ⊢ ∀s. open s ⇔ ∀x. x ∈ s ⇒ ∃e. 0 &lt; e ∧ ball (x,e) ⊆ s
   
   [<a name="OPEN_CONTAINS_BALL_EQ-val"><b>OPEN_CONTAINS_BALL_EQ</b></a>]  Theorem
      
      ⊢ ∀s. open s ⇒ ∀x. x ∈ s ⇔ ∃e. 0 &lt; e ∧ ball (x,e) ⊆ s
   
   [<a name="OPEN_CONTAINS_CBALL-val"><b>OPEN_CONTAINS_CBALL</b></a>]  Theorem
      
      ⊢ ∀s. open s ⇔ ∀x. x ∈ s ⇒ ∃e. 0 &lt; e ∧ cball (x,e) ⊆ s
   
   [<a name="OPEN_CONTAINS_CBALL_EQ-val"><b>OPEN_CONTAINS_CBALL_EQ</b></a>]  Theorem
      
      ⊢ ∀s. open s ⇒ ∀x. x ∈ s ⇔ ∃e. 0 &lt; e ∧ cball (x,e) ⊆ s
   
   [<a name="OPEN_CONTAINS_INTERVAL-val"><b>OPEN_CONTAINS_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀s. open s ⇔
            ∀x. x ∈ s ⇒ ∃a b. x ∈ interval (a,b) ∧ interval [(a,b)] ⊆ s
   
   [<a name="OPEN_CONTAINS_INTERVAL_OPEN_INTERVAL-val"><b>OPEN_CONTAINS_INTERVAL_OPEN_INTERVAL</b></a>]  Theorem
      
      ⊢ (∀s. open s ⇔
             ∀x. x ∈ s ⇒ ∃a b. x ∈ interval (a,b) ∧ interval [(a,b)] ⊆ s) ∧
        ∀s. open s ⇔
            ∀x. x ∈ s ⇒ ∃a b. x ∈ interval (a,b) ∧ interval (a,b) ⊆ s
   
   [<a name="OPEN_CONTAINS_OPEN_INTERVAL-val"><b>OPEN_CONTAINS_OPEN_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀s. open s ⇔
            ∀x. x ∈ s ⇒ ∃a b. x ∈ interval (a,b) ∧ interval (a,b) ⊆ s
   
   [<a name="OPEN_DELETE-val"><b>OPEN_DELETE</b></a>]  Theorem
      
      ⊢ ∀s x. open s ⇒ open (s DELETE x)
   
   [<a name="OPEN_DIFF-val"><b>OPEN_DIFF</b></a>]  Theorem
      
      ⊢ ∀s t. open s ∧ closed t ⇒ open (s DIFF t)
   
   [<a name="OPEN_EMPTY-val"><b>OPEN_EMPTY</b></a>]  Theorem
      
      ⊢ open ∅
   
   [<a name="OPEN_EXISTS-val"><b>OPEN_EXISTS</b></a>]  Theorem
      
      ⊢ ∀Q. (∀a. open {x | Q a x}) ⇒ open {x | (∃a. Q a x)}
   
   [<a name="OPEN_EXISTS_IN-val"><b>OPEN_EXISTS_IN</b></a>]  Theorem
      
      ⊢ ∀P Q. (∀a. P a ⇒ open {x | Q a x}) ⇒ open {x | (∃a. P a ∧ Q a x)}
   
   [<a name="OPEN_HALFSPACE_COMPONENT_GT-val"><b>OPEN_HALFSPACE_COMPONENT_GT</b></a>]  Theorem
      
      ⊢ ∀a. open {x | x &gt; a}
   
   [<a name="OPEN_HALFSPACE_COMPONENT_LT-val"><b>OPEN_HALFSPACE_COMPONENT_LT</b></a>]  Theorem
      
      ⊢ ∀a. open {x | x &lt; a}
   
   [<a name="OPEN_HALFSPACE_GT-val"><b>OPEN_HALFSPACE_GT</b></a>]  Theorem
      
      ⊢ ∀a b. open {x | a * x &gt; b}
   
   [<a name="OPEN_HALFSPACE_LT-val"><b>OPEN_HALFSPACE_LT</b></a>]  Theorem
      
      ⊢ ∀a b. open {x | a * x &lt; b}
   
   [<a name="OPEN_IMP_INFINITE-val"><b>OPEN_IMP_INFINITE</b></a>]  Theorem
      
      ⊢ ∀s. open s ⇒ s = ∅ ∨ INFINITE s
   
   [<a name="OPEN_IMP_LOCALLY_COMPACT-val"><b>OPEN_IMP_LOCALLY_COMPACT</b></a>]  Theorem
      
      ⊢ ∀s. open s ⇒ locally compact s
   
   [<a name="OPEN_IN-val"><b>OPEN_IN</b></a>]  Theorem
      
      ⊢ ∀s. open s ⇔ open_in euclidean s
   
   [<a name="OPEN_INTER-val"><b>OPEN_INTER</b></a>]  Theorem
      
      ⊢ ∀s t. open s ∧ open t ⇒ open (s ∩ t)
   
   [<a name="OPEN_INTERIOR-val"><b>OPEN_INTERIOR</b></a>]  Theorem
      
      ⊢ ∀s. open (interior s)
   
   [<a name="OPEN_INTERVAL-val"><b>OPEN_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀a b. open (interval (a,b))
   
   [<a name="OPEN_INTERVAL_EQ-val"><b>OPEN_INTERVAL_EQ</b></a>]  Theorem
      
      ⊢ (∀a b. open (interval [(a,b)]) ⇔ interval [(a,b)] = ∅) ∧
        ∀a b. open (interval (a,b))
   
   [<a name="OPEN_INTERVAL_LEFT-val"><b>OPEN_INTERVAL_LEFT</b></a>]  Theorem
      
      ⊢ ∀b. open {x | x &lt; b}
   
   [<a name="OPEN_INTERVAL_LEMMA-val"><b>OPEN_INTERVAL_LEMMA</b></a>]  Theorem
      
      ⊢ ∀a b x.
          a &lt; x ∧ x &lt; b ⇒
          ∃d. 0 &lt; d ∧ ∀x'. abs (x' − x) &lt; d ⇒ a &lt; x' ∧ x' &lt; b
   
   [<a name="OPEN_INTERVAL_LOWERBOUND-val"><b>OPEN_INTERVAL_LOWERBOUND</b></a>]  Theorem
      
      ⊢ ∀a b. a &lt; b ⇒ interval_lowerbound (interval (a,b)) = a
   
   [<a name="OPEN_INTERVAL_MIDPOINT-val"><b>OPEN_INTERVAL_MIDPOINT</b></a>]  Theorem
      
      ⊢ ∀a b. interval (a,b) ≠ ∅ ⇒ 2⁻¹ * (a + b) ∈ interval (a,b)
   
   [<a name="OPEN_INTERVAL_RIGHT-val"><b>OPEN_INTERVAL_RIGHT</b></a>]  Theorem
      
      ⊢ ∀a. open {x | a &lt; x}
   
   [<a name="OPEN_INTERVAL_UPPERBOUND-val"><b>OPEN_INTERVAL_UPPERBOUND</b></a>]  Theorem
      
      ⊢ ∀a b. a &lt; b ⇒ interval_upperbound (interval (a,b)) = b
   
   [<a name="OPEN_INTER_CLOSURE_EQ_EMPTY-val"><b>OPEN_INTER_CLOSURE_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ ∀s t. open s ⇒ (s ∩ closure t = ∅ ⇔ s ∩ t = ∅)
   
   [<a name="OPEN_INTER_CLOSURE_SUBSET-val"><b>OPEN_INTER_CLOSURE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t. open s ⇒ s ∩ closure t ⊆ closure (s ∩ t)
   
   [<a name="OPEN_IN_CONNECTED_COMPONENT-val"><b>OPEN_IN_CONNECTED_COMPONENT</b></a>]  Theorem
      
      ⊢ ∀s x.
          FINITE {connected_component s x | x | x ∈ s} ⇒
          open_in (subtopology euclidean s) (connected_component s x)
   
   [<a name="OPEN_IN_CONTAINS_BALL-val"><b>OPEN_IN_CONTAINS_BALL</b></a>]  Theorem
      
      ⊢ ∀s t.
          open_in (subtopology euclidean t) s ⇔
          s ⊆ t ∧ ∀x. x ∈ s ⇒ ∃e. 0 &lt; e ∧ ball (x,e) ∩ t ⊆ s
   
   [<a name="OPEN_IN_CONTAINS_CBALL-val"><b>OPEN_IN_CONTAINS_CBALL</b></a>]  Theorem
      
      ⊢ ∀s t.
          open_in (subtopology euclidean t) s ⇔
          s ⊆ t ∧ ∀x. x ∈ s ⇒ ∃e. 0 &lt; e ∧ cball (x,e) ∩ t ⊆ s
   
   [<a name="OPEN_IN_DELETE-val"><b>OPEN_IN_DELETE</b></a>]  Theorem
      
      ⊢ ∀u s a.
          open_in (subtopology euclidean u) s ⇒
          open_in (subtopology euclidean u) (s DELETE a)
   
   [<a name="OPEN_IN_INTER_OPEN-val"><b>OPEN_IN_INTER_OPEN</b></a>]  Theorem
      
      ⊢ ∀s t u.
          open_in (subtopology euclidean u) s ∧ open t ⇒
          open_in (subtopology euclidean u) (s ∩ t)
   
   [<a name="OPEN_IN_LOCALLY_COMPACT-val"><b>OPEN_IN_LOCALLY_COMPACT</b></a>]  Theorem
      
      ⊢ ∀s t.
          locally compact s ⇒
          (open_in (subtopology euclidean s) t ⇔
           t ⊆ s ∧
           ∀k. compact k ∧ k ⊆ s ⇒
               open_in (subtopology euclidean k) (k ∩ t))
   
   [<a name="OPEN_IN_OPEN-val"><b>OPEN_IN_OPEN</b></a>]  Theorem
      
      ⊢ ∀s u. open_in (subtopology euclidean u) s ⇔ ∃t. open t ∧ s = u ∩ t
   
   [<a name="OPEN_IN_OPEN_EQ-val"><b>OPEN_IN_OPEN_EQ</b></a>]  Theorem
      
      ⊢ ∀s t.
          open s ⇒ (open_in (subtopology euclidean s) t ⇔ open t ∧ t ⊆ s)
   
   [<a name="OPEN_IN_OPEN_INTER-val"><b>OPEN_IN_OPEN_INTER</b></a>]  Theorem
      
      ⊢ ∀u s. open s ⇒ open_in (subtopology euclidean u) (u ∩ s)
   
   [<a name="OPEN_IN_OPEN_TRANS-val"><b>OPEN_IN_OPEN_TRANS</b></a>]  Theorem
      
      ⊢ ∀s t. open_in (subtopology euclidean t) s ∧ open t ⇒ open s
   
   [<a name="OPEN_IN_REFL-val"><b>OPEN_IN_REFL</b></a>]  Theorem
      
      ⊢ ∀s. open_in (subtopology euclidean s) s
   
   [<a name="OPEN_IN_SING-val"><b>OPEN_IN_SING</b></a>]  Theorem
      
      ⊢ ∀s a.
          open_in (subtopology euclidean s) {a} ⇔
          a ∈ s ∧ ¬(a limit_point_of s)
   
   [<a name="OPEN_IN_SUBSET_TRANS-val"><b>OPEN_IN_SUBSET_TRANS</b></a>]  Theorem
      
      ⊢ ∀s t u.
          open_in (subtopology euclidean u) s ∧ s ⊆ t ∧ t ⊆ u ⇒
          open_in (subtopology euclidean t) s
   
   [<a name="OPEN_IN_SUBTOPOLOGY_INTER_SUBSET-val"><b>OPEN_IN_SUBTOPOLOGY_INTER_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s u v.
          open_in (subtopology euclidean u) (u ∩ s) ∧ v ⊆ u ⇒
          open_in (subtopology euclidean v) (v ∩ s)
   
   [<a name="OPEN_IN_TRANS-val"><b>OPEN_IN_TRANS</b></a>]  Theorem
      
      ⊢ ∀s t u.
          open_in (subtopology euclidean t) s ∧
          open_in (subtopology euclidean u) t ⇒
          open_in (subtopology euclidean u) s
   
   [<a name="OPEN_IN_TRANS_EQ-val"><b>OPEN_IN_TRANS_EQ</b></a>]  Theorem
      
      ⊢ ∀s t.
          (∀u. open_in (subtopology euclidean t) u ⇒
               open_in (subtopology euclidean s) t) ⇔
          open_in (subtopology euclidean s) t
   
   [<a name="OPEN_MAP_CLOSED_SUPERSET_PREIMAGE-val"><b>OPEN_MAP_CLOSED_SUPERSET_PREIMAGE</b></a>]  Theorem
      
      ⊢ ∀f s t u w.
          (∀k. open_in (subtopology euclidean s) k ⇒
               open_in (subtopology euclidean t) (IMAGE f k)) ∧
          closed_in (subtopology euclidean s) u ∧ w ⊆ t ∧
          {x | x ∈ s ∧ f x ∈ w} ⊆ u ⇒
          ∃v. closed_in (subtopology euclidean t) v ∧ w ⊆ v ∧
              {x | x ∈ s ∧ f x ∈ v} ⊆ u
   
   [<a name="OPEN_MAP_CLOSED_SUPERSET_PREIMAGE_EQ-val"><b>OPEN_MAP_CLOSED_SUPERSET_PREIMAGE_EQ</b></a>]  Theorem
      
      ⊢ ∀f s t.
          IMAGE f s ⊆ t ⇒
          ((∀k. open_in (subtopology euclidean s) k ⇒
                open_in (subtopology euclidean t) (IMAGE f k)) ⇔
           ∀u w.
             closed_in (subtopology euclidean s) u ∧ w ⊆ t ∧
             {x | x ∈ s ∧ f x ∈ w} ⊆ u ⇒
             ∃v. closed_in (subtopology euclidean t) v ∧ w ⊆ v ∧
                 {x | x ∈ s ∧ f x ∈ v} ⊆ u)
   
   [<a name="OPEN_MAP_FROM_COMPOSITION_INJECTIVE-val"><b>OPEN_MAP_FROM_COMPOSITION_INJECTIVE</b></a>]  Theorem
      
      ⊢ ∀f g s t u.
          IMAGE f s ⊆ t ∧ IMAGE g t ⊆ u ∧ g continuous_on t ∧
          (∀x y. x ∈ t ∧ y ∈ t ∧ g x = g y ⇒ x = y) ∧
          (∀k. open_in (subtopology euclidean s) k ⇒
               open_in (subtopology euclidean u) (IMAGE (g ∘ f) k)) ⇒
          ∀k. open_in (subtopology euclidean s) k ⇒
              open_in (subtopology euclidean t) (IMAGE f k)
   
   [<a name="OPEN_MAP_FROM_COMPOSITION_SURJECTIVE-val"><b>OPEN_MAP_FROM_COMPOSITION_SURJECTIVE</b></a>]  Theorem
      
      ⊢ ∀f g s t u.
          f continuous_on s ∧ IMAGE f s = t ∧ IMAGE g t ⊆ u ∧
          (∀k. open_in (subtopology euclidean s) k ⇒
               open_in (subtopology euclidean u) (IMAGE (g ∘ f) k)) ⇒
          ∀k. open_in (subtopology euclidean t) k ⇒
              open_in (subtopology euclidean u) (IMAGE g k)
   
   [<a name="OPEN_MAP_IFF_LOWER_HEMICONTINUOUS_PREIMAGE-val"><b>OPEN_MAP_IFF_LOWER_HEMICONTINUOUS_PREIMAGE</b></a>]  Theorem
      
      ⊢ ∀f s t.
          IMAGE f s ⊆ t ⇒
          ((∀u. open_in (subtopology euclidean s) u ⇒
                open_in (subtopology euclidean t) (IMAGE f u)) ⇔
           ∀u. closed_in (subtopology euclidean s) u ⇒
               closed_in (subtopology euclidean t)
                 {y | y ∈ t ∧ {x | x ∈ s ∧ f x = y} ⊆ u})
   
   [<a name="OPEN_MAP_IMP_CLOSED_MAP-val"><b>OPEN_MAP_IMP_CLOSED_MAP</b></a>]  Theorem
      
      ⊢ ∀f s t.
          IMAGE f s = t ∧
          (∀u. open_in (subtopology euclidean s) u ⇒
               open_in (subtopology euclidean t) (IMAGE f u)) ∧
          (∀u. closed_in (subtopology euclidean s) u ⇒
               closed_in (subtopology euclidean s)
                 {x | x ∈ s ∧ f x ∈ IMAGE f u}) ⇒
          ∀u. closed_in (subtopology euclidean s) u ⇒
              closed_in (subtopology euclidean t) (IMAGE f u)
   
   [<a name="OPEN_MAP_IMP_QUOTIENT_MAP-val"><b>OPEN_MAP_IMP_QUOTIENT_MAP</b></a>]  Theorem
      
      ⊢ ∀f s.
          f continuous_on s ∧
          (∀t. open_in (subtopology euclidean s) t ⇒
               open_in (subtopology euclidean (IMAGE f s)) (IMAGE f t)) ⇒
          ∀t. t ⊆ IMAGE f s ⇒
              (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ t} ⇔
               open_in (subtopology euclidean (IMAGE f s)) t)
   
   [<a name="OPEN_MAP_INTERIORS-val"><b>OPEN_MAP_INTERIORS</b></a>]  Theorem
      
      ⊢ ∀f. (∀s. open s ⇒ open (IMAGE f s)) ⇔
            ∀s. IMAGE f (interior s) ⊆ interior (IMAGE f s)
   
   [<a name="OPEN_MAP_RESTRICT-val"><b>OPEN_MAP_RESTRICT</b></a>]  Theorem
      
      ⊢ ∀f s t t'.
          (∀u. open_in (subtopology euclidean s) u ⇒
               open_in (subtopology euclidean t) (IMAGE f u)) ∧ t' ⊆ t ⇒
          ∀u. open_in (subtopology euclidean {x | x ∈ s ∧ f x ∈ t'}) u ⇒
              open_in (subtopology euclidean t') (IMAGE f u)
   
   [<a name="OPEN_NEGATIONS-val"><b>OPEN_NEGATIONS</b></a>]  Theorem
      
      ⊢ ∀s. open s ⇒ open (IMAGE (λx. -x) s)
   
   [<a name="OPEN_OPEN_IN_TRANS-val"><b>OPEN_OPEN_IN_TRANS</b></a>]  Theorem
      
      ⊢ ∀s t. open s ∧ open t ∧ t ⊆ s ⇒ open_in (subtopology euclidean s) t
   
   [<a name="OPEN_POSITIVE_MULTIPLES-val"><b>OPEN_POSITIVE_MULTIPLES</b></a>]  Theorem
      
      ⊢ ∀s. open s ⇒ open {c * x | 0 &lt; c ∧ x ∈ s}
   
   [<a name="OPEN_POSITIVE_ORTHANT-val"><b>OPEN_POSITIVE_ORTHANT</b></a>]  Theorem
      
      ⊢ open {x | 0 &lt; x}
   
   [<a name="OPEN_SCALING-val"><b>OPEN_SCALING</b></a>]  Theorem
      
      ⊢ ∀s c. c ≠ 0 ∧ open s ⇒ open (IMAGE (λx. c * x) s)
   
   [<a name="OPEN_SEGMENT-val"><b>OPEN_SEGMENT</b></a>]  Theorem
      
      ⊢ ∀a b. open (segment (a,b))
   
   [<a name="OPEN_SEGMENT_ALT-val"><b>OPEN_SEGMENT_ALT</b></a>]  Theorem
      
      ⊢ ∀a b. a ≠ b ⇒ segment (a,b) = {(1 − u) * a + u * b | 0 &lt; u ∧ u &lt; 1}
   
   [<a name="OPEN_SEGMENT_LINEAR_IMAGE-val"><b>OPEN_SEGMENT_LINEAR_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f a b.
          linear f ∧ (∀x y. f x = f y ⇒ x = y) ⇒
          segment (f a,f b) = IMAGE f (segment (a,b))
   
   [<a name="OPEN_SUBSET-val"><b>OPEN_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t. s ⊆ t ∧ open s ⇒ open_in (subtopology euclidean t) s
   
   [<a name="OPEN_SUBSET_INTERIOR-val"><b>OPEN_SUBSET_INTERIOR</b></a>]  Theorem
      
      ⊢ ∀s t. open s ⇒ (s ⊆ interior t ⇔ s ⊆ t)
   
   [<a name="OPEN_SUB_OPEN-val"><b>OPEN_SUB_OPEN</b></a>]  Theorem
      
      ⊢ ∀s. open s ⇔ ∀x. x ∈ s ⇒ ∃t. open t ∧ x ∈ t ∧ t ⊆ s
   
   [<a name="OPEN_SUMS-val"><b>OPEN_SUMS</b></a>]  Theorem
      
      ⊢ ∀s t. open s ∨ open t ⇒ open {x + y | x ∈ s ∧ y ∈ t}
   
   [<a name="OPEN_SURJECTIVE_LINEAR_IMAGE-val"><b>OPEN_SURJECTIVE_LINEAR_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f. linear f ∧ (∀y. ∃x. f x = y) ⇒ ∀s. open s ⇒ open (IMAGE f s)
   
   [<a name="OPEN_TRANSLATION-val"><b>OPEN_TRANSLATION</b></a>]  Theorem
      
      ⊢ ∀s a. open s ⇒ open (IMAGE (λx. a + x) s)
   
   [<a name="OPEN_TRANSLATION_EQ-val"><b>OPEN_TRANSLATION_EQ</b></a>]  Theorem
      
      ⊢ ∀a s. open (IMAGE (λx. a + x) s) ⇔ open s
   
   [<a name="OPEN_UNION-val"><b>OPEN_UNION</b></a>]  Theorem
      
      ⊢ ∀s t. open s ∧ open t ⇒ open (s ∪ t)
   
   [<a name="OPEN_UNION_COMPACT_SUBSETS-val"><b>OPEN_UNION_COMPACT_SUBSETS</b></a>]  Theorem
      
      ⊢ ∀s. open s ⇒
            ∃f. (∀n. compact (f n)) ∧ (∀n. f n ⊆ s) ∧
                (∀n. f n ⊆ interior (f (n + 1))) ∧
                BIGUNION {f n | n ∈ 𝕌(:num)} = s ∧
                ∀k. compact k ∧ k ⊆ s ⇒ ∃N. ∀n. n ≥ N ⇒ k ⊆ f n
   
   [<a name="OPEN_UNIV-val"><b>OPEN_UNIV</b></a>]  Theorem
      
      ⊢ open 𝕌(:real)
   
   [<a name="PAIRWISE_DISJOINT_COMPONENTS-val"><b>PAIRWISE_DISJOINT_COMPONENTS</b></a>]  Theorem
      
      ⊢ ∀u. pairwiseD DISJOINT (components u)
   
   [<a name="PARTIAL_SUMS_COMPONENT_LE_INFSUM-val"><b>PARTIAL_SUMS_COMPONENT_LE_INFSUM</b></a>]  Theorem
      
      ⊢ ∀f s n.
          (∀i. i ∈ s ⇒ 0 ≤ f i) ∧ summable s f ⇒
          sum (s ∩ {0 .. n}) f ≤ suminf s f
   
   [<a name="PARTIAL_SUMS_DROP_LE_INFSUM-val"><b>PARTIAL_SUMS_DROP_LE_INFSUM</b></a>]  Theorem
      
      ⊢ ∀f s n.
          (∀i. i ∈ s ⇒ 0 ≤ f i) ∧ summable s f ⇒
          sum (s ∩ {0 .. n}) f ≤ suminf s f
   
   [<a name="PASTING_LEMMA-val"><b>PASTING_LEMMA</b></a>]  Theorem
      
      ⊢ ∀f g t s k.
          (∀i. i ∈ k ⇒
               open_in (subtopology euclidean s) (t i) ∧
               f i continuous_on t i) ∧
          (∀i j x. i ∈ k ∧ j ∈ k ∧ x ∈ s ∩ t i ∩ t j ⇒ f i x = f j x) ∧
          (∀x. x ∈ s ⇒ ∃j. j ∈ k ∧ x ∈ t j ∧ g x = f j x) ⇒
          g continuous_on s
   
   [<a name="PASTING_LEMMA_CLOSED-val"><b>PASTING_LEMMA_CLOSED</b></a>]  Theorem
      
      ⊢ ∀f g t s k.
          FINITE k ∧
          (∀i. i ∈ k ⇒
               closed_in (subtopology euclidean s) (t i) ∧
               f i continuous_on t i) ∧
          (∀i j x. i ∈ k ∧ j ∈ k ∧ x ∈ s ∩ t i ∩ t j ⇒ f i x = f j x) ∧
          (∀x. x ∈ s ⇒ ∃j. j ∈ k ∧ x ∈ t j ∧ g x = f j x) ⇒
          g continuous_on s
   
   [<a name="PASTING_LEMMA_EXISTS-val"><b>PASTING_LEMMA_EXISTS</b></a>]  Theorem
      
      ⊢ ∀f t s k.
          s ⊆ BIGUNION {t i | i ∈ k} ∧
          (∀i. i ∈ k ⇒
               open_in (subtopology euclidean s) (t i) ∧
               f i continuous_on t i) ∧
          (∀i j x. i ∈ k ∧ j ∈ k ∧ x ∈ s ∩ t i ∩ t j ⇒ f i x = f j x) ⇒
          ∃g. g continuous_on s ∧ ∀x i. i ∈ k ∧ x ∈ s ∩ t i ⇒ g x = f i x
   
   [<a name="PASTING_LEMMA_EXISTS_CLOSED-val"><b>PASTING_LEMMA_EXISTS_CLOSED</b></a>]  Theorem
      
      ⊢ ∀f t s k.
          FINITE k ∧ s ⊆ BIGUNION {t i | i ∈ k} ∧
          (∀i. i ∈ k ⇒
               closed_in (subtopology euclidean s) (t i) ∧
               f i continuous_on t i) ∧
          (∀i j x. i ∈ k ∧ j ∈ k ∧ x ∈ s ∩ t i ∩ t j ⇒ f i x = f j x) ⇒
          ∃g. g continuous_on s ∧ ∀x i. i ∈ k ∧ x ∈ s ∩ t i ⇒ g x = f i x
   
   [<a name="PROPER_MAP-val"><b>PROPER_MAP</b></a>]  Theorem
      
      ⊢ ∀f s t.
          IMAGE f s ⊆ t ⇒
          ((∀k. k ⊆ t ∧ compact k ⇒ compact {x | x ∈ s ∧ f x ∈ k}) ⇔
           (∀k. closed_in (subtopology euclidean s) k ⇒
                closed_in (subtopology euclidean t) (IMAGE f k)) ∧
           ∀a. a ∈ t ⇒ compact {x | x ∈ s ∧ f x = a})
   
   [<a name="PROPER_MAP_COMPOSE-val"><b>PROPER_MAP_COMPOSE</b></a>]  Theorem
      
      ⊢ ∀f g s t u.
          IMAGE f s ⊆ t ∧
          (∀k. k ⊆ t ∧ compact k ⇒ compact {x | x ∈ s ∧ f x ∈ k}) ∧
          (∀k. k ⊆ u ∧ compact k ⇒ compact {x | x ∈ t ∧ g x ∈ k}) ⇒
          ∀k. k ⊆ u ∧ compact k ⇒ compact {x | x ∈ s ∧ (g ∘ f) x ∈ k}
   
   [<a name="PROPER_MAP_FROM_COMPACT-val"><b>PROPER_MAP_FROM_COMPACT</b></a>]  Theorem
      
      ⊢ ∀f s k.
          f continuous_on s ∧ IMAGE f s ⊆ t ∧ compact s ∧
          closed_in (subtopology euclidean t) k ⇒
          compact {x | x ∈ s ∧ f x ∈ k}
   
   [<a name="PROPER_MAP_FROM_COMPOSITION_LEFT-val"><b>PROPER_MAP_FROM_COMPOSITION_LEFT</b></a>]  Theorem
      
      ⊢ ∀f g s t u.
          f continuous_on s ∧ IMAGE f s = t ∧ g continuous_on t ∧
          IMAGE g t ⊆ u ∧
          (∀k. k ⊆ u ∧ compact k ⇒ compact {x | x ∈ s ∧ (g ∘ f) x ∈ k}) ⇒
          ∀k. k ⊆ u ∧ compact k ⇒ compact {x | x ∈ t ∧ g x ∈ k}
   
   [<a name="PROPER_MAP_FROM_COMPOSITION_RIGHT-val"><b>PROPER_MAP_FROM_COMPOSITION_RIGHT</b></a>]  Theorem
      
      ⊢ ∀f g s t u.
          f continuous_on s ∧ IMAGE f s ⊆ t ∧ g continuous_on t ∧
          IMAGE g t ⊆ u ∧
          (∀k. k ⊆ u ∧ compact k ⇒ compact {x | x ∈ s ∧ (g ∘ f) x ∈ k}) ⇒
          ∀k. k ⊆ t ∧ compact k ⇒ compact {x | x ∈ s ∧ f x ∈ k}
   
   [<a name="QUASICOMPACT_OPEN_CLOSED-val"><b>QUASICOMPACT_OPEN_CLOSED</b></a>]  Theorem
      
      ⊢ ∀f s t.
          IMAGE f s ⊆ t ⇒
          ((∀u. u ⊆ t ⇒
                open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇒
                open_in (subtopology euclidean t) u) ⇔
           ∀u. u ⊆ t ⇒
               closed_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇒
               closed_in (subtopology euclidean t) u)
   
   [<a name="QUOTIENT_MAP_CLOSED_MAP_EQ-val"><b>QUOTIENT_MAP_CLOSED_MAP_EQ</b></a>]  Theorem
      
      ⊢ ∀f s t.
          IMAGE f s ⊆ t ∧
          (∀u. u ⊆ t ⇒
               (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇔
                open_in (subtopology euclidean t) u)) ⇒
          ((∀k. closed_in (subtopology euclidean s) k ⇒
                closed_in (subtopology euclidean t) (IMAGE f k)) ⇔
           ∀k. closed_in (subtopology euclidean s) k ⇒
               closed_in (subtopology euclidean s)
                 {x | x ∈ s ∧ f x ∈ IMAGE f k})
   
   [<a name="QUOTIENT_MAP_COMPOSE-val"><b>QUOTIENT_MAP_COMPOSE</b></a>]  Theorem
      
      ⊢ ∀f g s t u.
          IMAGE f s ⊆ t ∧
          (∀v. v ⊆ t ⇒
               (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ v} ⇔
                open_in (subtopology euclidean t) v)) ∧
          (∀v. v ⊆ u ⇒
               (open_in (subtopology euclidean t) {x | x ∈ t ∧ g x ∈ v} ⇔
                open_in (subtopology euclidean u) v)) ⇒
          ∀v. v ⊆ u ⇒
              (open_in (subtopology euclidean s)
                 {x | x ∈ s ∧ (g ∘ f) x ∈ v} ⇔
               open_in (subtopology euclidean u) v)
   
   [<a name="QUOTIENT_MAP_FROM_COMPOSITION-val"><b>QUOTIENT_MAP_FROM_COMPOSITION</b></a>]  Theorem
      
      ⊢ ∀f g s t u.
          f continuous_on s ∧ IMAGE f s ⊆ t ∧ g continuous_on t ∧
          IMAGE g t ⊆ u ∧
          (∀v. v ⊆ u ⇒
               (open_in (subtopology euclidean s)
                  {x | x ∈ s ∧ (g ∘ f) x ∈ v} ⇔
                open_in (subtopology euclidean u) v)) ⇒
          ∀v. v ⊆ u ⇒
              (open_in (subtopology euclidean t) {x | x ∈ t ∧ g x ∈ v} ⇔
               open_in (subtopology euclidean u) v)
   
   [<a name="QUOTIENT_MAP_FROM_SUBSET-val"><b>QUOTIENT_MAP_FROM_SUBSET</b></a>]  Theorem
      
      ⊢ ∀f s t u.
          f continuous_on t ∧ IMAGE f t ⊆ u ∧ s ⊆ t ∧ IMAGE f s = u ∧
          (∀v. v ⊆ u ⇒
               (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ v} ⇔
                open_in (subtopology euclidean u) v)) ⇒
          ∀v. v ⊆ u ⇒
              (open_in (subtopology euclidean t) {x | x ∈ t ∧ f x ∈ v} ⇔
               open_in (subtopology euclidean u) v)
   
   [<a name="QUOTIENT_MAP_IMP_CONTINUOUS_CLOSED-val"><b>QUOTIENT_MAP_IMP_CONTINUOUS_CLOSED</b></a>]  Theorem
      
      ⊢ ∀f s t.
          IMAGE f s ⊆ t ∧
          (∀u. u ⊆ t ⇒
               (closed_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇔
                closed_in (subtopology euclidean t) u)) ⇒
          f continuous_on s
   
   [<a name="QUOTIENT_MAP_IMP_CONTINUOUS_OPEN-val"><b>QUOTIENT_MAP_IMP_CONTINUOUS_OPEN</b></a>]  Theorem
      
      ⊢ ∀f s t.
          IMAGE f s ⊆ t ∧
          (∀u. u ⊆ t ⇒
               (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇔
                open_in (subtopology euclidean t) u)) ⇒
          f continuous_on s
   
   [<a name="QUOTIENT_MAP_OPEN_CLOSED-val"><b>QUOTIENT_MAP_OPEN_CLOSED</b></a>]  Theorem
      
      ⊢ ∀f s t.
          IMAGE f s ⊆ t ⇒
          ((∀u. u ⊆ t ⇒
                (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇔
                 open_in (subtopology euclidean t) u)) ⇔
           ∀u. u ⊆ t ⇒
               (closed_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇔
                closed_in (subtopology euclidean t) u))
   
   [<a name="QUOTIENT_MAP_OPEN_MAP_EQ-val"><b>QUOTIENT_MAP_OPEN_MAP_EQ</b></a>]  Theorem
      
      ⊢ ∀f s t.
          IMAGE f s ⊆ t ∧
          (∀u. u ⊆ t ⇒
               (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇔
                open_in (subtopology euclidean t) u)) ⇒
          ((∀k. open_in (subtopology euclidean s) k ⇒
                open_in (subtopology euclidean t) (IMAGE f k)) ⇔
           ∀k. open_in (subtopology euclidean s) k ⇒
               open_in (subtopology euclidean s)
                 {x | x ∈ s ∧ f x ∈ IMAGE f k})
   
   [<a name="QUOTIENT_MAP_RESTRICT-val"><b>QUOTIENT_MAP_RESTRICT</b></a>]  Theorem
      
      ⊢ ∀f s t c.
          IMAGE f s ⊆ t ∧
          (∀u. u ⊆ t ⇒
               (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇔
                open_in (subtopology euclidean t) u)) ∧
          (open_in (subtopology euclidean t) c ∨
           closed_in (subtopology euclidean t) c) ⇒
          ∀u. u ⊆ c ⇒
              (open_in (subtopology euclidean {x | x ∈ s ∧ f x ∈ c})
                 {x | x ∈ {x | x ∈ s ∧ f x ∈ c} ∧ f x ∈ u} ⇔
               open_in (subtopology euclidean c) u)
   
   [<a name="REAL_AFFINITY_EQ-val"><b>REAL_AFFINITY_EQ</b></a>]  Theorem
      
      ⊢ ∀m c x y. m ≠ 0 ⇒ (m * x + c = y ⇔ x = m⁻¹ * y + -(c / m))
   
   [<a name="REAL_AFFINITY_LE-val"><b>REAL_AFFINITY_LE</b></a>]  Theorem
      
      ⊢ ∀m c x y. 0 &lt; m ⇒ (m * x + c ≤ y ⇔ x ≤ m⁻¹ * y + -(c / m))
   
   [<a name="REAL_AFFINITY_LT-val"><b>REAL_AFFINITY_LT</b></a>]  Theorem
      
      ⊢ ∀m c x y. 0 &lt; m ⇒ (m * x + c &lt; y ⇔ x &lt; m⁻¹ * y + -(c / m))
   
   [<a name="REAL_ARCH_RDIV_EQ_0-val"><b>REAL_ARCH_RDIV_EQ_0</b></a>]  Theorem
      
      ⊢ ∀x c. 0 ≤ x ∧ 0 ≤ c ∧ (∀m. 0 &lt; m ⇒ &m * x ≤ c) ⇒ x = 0
   
   [<a name="REAL_CHOOSE_DIST-val"><b>REAL_CHOOSE_DIST</b></a>]  Theorem
      
      ⊢ ∀x e. 0 ≤ e ⇒ ∃y. dist (x,y) = e
   
   [<a name="REAL_CHOOSE_SIZE-val"><b>REAL_CHOOSE_SIZE</b></a>]  Theorem
      
      ⊢ ∀c. 0 ≤ c ⇒ ∃x. abs x = c
   
   [<a name="REAL_CONVEX_BOUND_LE-val"><b>REAL_CONVEX_BOUND_LE</b></a>]  Theorem
      
      ⊢ ∀x y a u v.
          x ≤ a ∧ y ≤ a ∧ 0 ≤ u ∧ 0 ≤ v ∧ u + v = 1 ⇒ u * x + v * y ≤ a
   
   [<a name="REAL_EQ_AFFINITY-val"><b>REAL_EQ_AFFINITY</b></a>]  Theorem
      
      ⊢ ∀m c x y. m ≠ 0 ⇒ (y = m * x + c ⇔ m⁻¹ * y + -(c / m) = x)
   
   [<a name="REAL_EQ_LINV-val"><b>REAL_EQ_LINV</b></a>]  Theorem
      
      ⊢ ∀x. -x = x ⇔ x = 0
   
   [<a name="REAL_EQ_RINV-val"><b>REAL_EQ_RINV</b></a>]  Theorem
      
      ⊢ ∀x. x = -x ⇔ x = 0
   
   [<a name="REAL_HAUSDIST_LE-val"><b>REAL_HAUSDIST_LE</b></a>]  Theorem
      
      ⊢ ∀s t b.
          s ≠ ∅ ∧ t ≠ ∅ ∧ (∀x. x ∈ s ⇒ setdist ({x},t) ≤ b) ∧
          (∀y. y ∈ t ⇒ setdist ({y},s) ≤ b) ⇒
          hausdist (s,t) ≤ b
   
   [<a name="REAL_HAUSDIST_LE_EQ-val"><b>REAL_HAUSDIST_LE_EQ</b></a>]  Theorem
      
      ⊢ ∀s t b.
          s ≠ ∅ ∧ t ≠ ∅ ∧ bounded s ∧ bounded t ⇒
          (hausdist (s,t) ≤ b ⇔
           (∀x. x ∈ s ⇒ setdist ({x},t) ≤ b) ∧
           ∀y. y ∈ t ⇒ setdist ({y},s) ≤ b)
   
   [<a name="REAL_HAUSDIST_LE_SUMS-val"><b>REAL_HAUSDIST_LE_SUMS</b></a>]  Theorem
      
      ⊢ ∀s t b.
          s ≠ ∅ ∧ t ≠ ∅ ∧ s ⊆ {y + z | y ∈ t ∧ z ∈ cball (0,b)} ∧
          t ⊆ {y + z | y ∈ s ∧ z ∈ cball (0,b)} ⇒
          hausdist (s,t) ≤ b
   
   [<a name="REAL_LE_AFFINITY-val"><b>REAL_LE_AFFINITY</b></a>]  Theorem
      
      ⊢ ∀m c x y. 0 &lt; m ⇒ (y ≤ m * x + c ⇔ m⁻¹ * y + -(c / m) ≤ x)
   
   [<a name="REAL_LE_HAUSDIST-val"><b>REAL_LE_HAUSDIST</b></a>]  Theorem
      
      ⊢ ∀s t a b c z.
          s ≠ ∅ ∧ t ≠ ∅ ∧ (∀x. x ∈ s ⇒ setdist ({x},t) ≤ b) ∧
          (∀y. y ∈ t ⇒ setdist ({y},s) ≤ c) ∧
          (z ∈ s ∧ a ≤ setdist ({z},t) ∨ z ∈ t ∧ a ≤ setdist ({z},s)) ⇒
          a ≤ hausdist (s,t)
   
   [<a name="REAL_LE_SETDIST-val"><b>REAL_LE_SETDIST</b></a>]  Theorem
      
      ⊢ ∀s t d.
          s ≠ ∅ ∧ t ≠ ∅ ∧ (∀x y. x ∈ s ∧ y ∈ t ⇒ d ≤ dist (x,y)) ⇒
          d ≤ setdist (s,t)
   
   [<a name="REAL_LE_SETDIST_EQ-val"><b>REAL_LE_SETDIST_EQ</b></a>]  Theorem
      
      ⊢ ∀d s t.
          d ≤ setdist (s,t) ⇔
          (∀x y. x ∈ s ∧ y ∈ t ⇒ d ≤ dist (x,y)) ∧ (s = ∅ ∨ t = ∅ ⇒ d ≤ 0)
   
   [<a name="REAL_LT_AFFINITY-val"><b>REAL_LT_AFFINITY</b></a>]  Theorem
      
      ⊢ ∀m c x y. 0 &lt; m ⇒ (y &lt; m * x + c ⇔ m⁻¹ * y + -(c / m) &lt; x)
   
   [<a name="REAL_LT_HAUSDIST_POINT_EXISTS-val"><b>REAL_LT_HAUSDIST_POINT_EXISTS</b></a>]  Theorem
      
      ⊢ ∀s t x d.
          bounded s ∧ bounded t ∧ t ≠ ∅ ∧ hausdist (s,t) &lt; d ∧ x ∈ s ⇒
          ∃y. y ∈ t ∧ dist (x,y) &lt; d
   
   [<a name="REAL_SETDIST_LT_EXISTS-val"><b>REAL_SETDIST_LT_EXISTS</b></a>]  Theorem
      
      ⊢ ∀s t b.
          s ≠ ∅ ∧ t ≠ ∅ ∧ setdist (s,t) &lt; b ⇒
          ∃x y. x ∈ s ∧ y ∈ t ∧ dist (x,y) &lt; b
   
   [<a name="REFLECT_INTERVAL-val"><b>REFLECT_INTERVAL</b></a>]  Theorem
      
      ⊢ (∀a b. IMAGE (λx. -x) (interval [(a,b)]) = interval [(-b,-a)]) ∧
        ∀a b. IMAGE (λx. -x) (interval (a,b)) = interval (-b,-a)
   
   [<a name="REGULAR_CLOSED_BIGUNION-val"><b>REGULAR_CLOSED_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀f. FINITE f ∧ (∀t. t ∈ f ⇒ closure (interior t) = t) ⇒
            closure (interior (BIGUNION f)) = BIGUNION f
   
   [<a name="REGULAR_CLOSED_UNION-val"><b>REGULAR_CLOSED_UNION</b></a>]  Theorem
      
      ⊢ ∀s t.
          closure (interior s) = s ∧ closure (interior t) = t ⇒
          closure (interior (s ∪ t)) = s ∪ t
   
   [<a name="REGULAR_OPEN_INTER-val"><b>REGULAR_OPEN_INTER</b></a>]  Theorem
      
      ⊢ ∀s t.
          interior (closure s) = s ∧ interior (closure t) = t ⇒
          interior (closure (s ∩ t)) = s ∩ t
   
   [<a name="SEGMENT-val"><b>SEGMENT</b></a>]  Theorem
      
      ⊢ (∀a b.
           segment [(a,b)] =
           if a ≤ b then interval [(a,b)] else interval [(b,a)]) ∧
        ∀a b.
          segment (a,b) = if a ≤ b then interval (a,b) else interval (b,a)
   
   [<a name="SEGMENT_CLOSED_OPEN-val"><b>SEGMENT_CLOSED_OPEN</b></a>]  Theorem
      
      ⊢ ∀a b. segment [(a,b)] = segment (a,b) ∪ {a; b}
   
   [<a name="SEGMENT_OPEN_SUBSET_CLOSED-val"><b>SEGMENT_OPEN_SUBSET_CLOSED</b></a>]  Theorem
      
      ⊢ ∀a b. segment (a,b) ⊆ segment [(a,b)]
   
   [<a name="SEGMENT_REFL-val"><b>SEGMENT_REFL</b></a>]  Theorem
      
      ⊢ (∀a. segment [(a,a)] = {a}) ∧ ∀a. segment (a,a) = ∅
   
   [<a name="SEGMENT_SCALAR_MULTIPLE-val"><b>SEGMENT_SCALAR_MULTIPLE</b></a>]  Theorem
      
      ⊢ (∀a b v.
           segment [(a * v,b * v)] =
           {x * v | a ≤ x ∧ x ≤ b ∨ b ≤ x ∧ x ≤ a}) ∧
        ∀a b v.
          v ≠ 0 ⇒
          segment (a * v,b * v) = {x * v | a &lt; x ∧ x &lt; b ∨ b &lt; x ∧ x &lt; a}
   
   [<a name="SEGMENT_SYM-val"><b>SEGMENT_SYM</b></a>]  Theorem
      
      ⊢ (∀a b. segment [(a,b)] = segment [(b,a)]) ∧
        ∀a b. segment (a,b) = segment (b,a)
   
   [<a name="SEGMENT_TO_CLOSEST_POINT-val"><b>SEGMENT_TO_CLOSEST_POINT</b></a>]  Theorem
      
      ⊢ ∀s a. closed s ∧ s ≠ ∅ ⇒ segment (a,closest_point s a) ∩ s = ∅
   
   [<a name="SEGMENT_TO_POINT_EXISTS-val"><b>SEGMENT_TO_POINT_EXISTS</b></a>]  Theorem
      
      ⊢ ∀s a. closed s ∧ s ≠ ∅ ⇒ ∃b. b ∈ s ∧ segment (a,b) ∩ s = ∅
   
   [<a name="SEGMENT_TRANSLATION-val"><b>SEGMENT_TRANSLATION</b></a>]  Theorem
      
      ⊢ (∀c a b.
           segment [(c + a,c + b)] = IMAGE (λx. c + x) (segment [(a,b)])) ∧
        ∀c a b. segment (c + a,c + b) = IMAGE (λx. c + x) (segment (a,b))
   
   [<a name="SEPARATE_CLOSED_COMPACT-val"><b>SEPARATE_CLOSED_COMPACT</b></a>]  Theorem
      
      ⊢ ∀s t.
          closed s ∧ compact t ∧ s ∩ t = ∅ ⇒
          ∃d. 0 &lt; d ∧ ∀x y. x ∈ s ∧ y ∈ t ⇒ d ≤ dist (x,y)
   
   [<a name="SEPARATE_COMPACT_CLOSED-val"><b>SEPARATE_COMPACT_CLOSED</b></a>]  Theorem
      
      ⊢ ∀s t.
          compact s ∧ closed t ∧ s ∩ t = ∅ ⇒
          ∃d. 0 &lt; d ∧ ∀x y. x ∈ s ∧ y ∈ t ⇒ d ≤ dist (x,y)
   
   [<a name="SEPARATE_POINT_CLOSED-val"><b>SEPARATE_POINT_CLOSED</b></a>]  Theorem
      
      ⊢ ∀s a. closed s ∧ a ∉ s ⇒ ∃d. 0 &lt; d ∧ ∀x. x ∈ s ⇒ d ≤ dist (a,x)
   
   [<a name="SEPARATION_CLOSURES-val"><b>SEPARATION_CLOSURES</b></a>]  Theorem
      
      ⊢ ∀s t.
          s ∩ closure t = ∅ ∧ t ∩ closure s = ∅ ⇒
          ∃u v. DISJOINT u v ∧ open u ∧ open v ∧ s ⊆ u ∧ t ⊆ v
   
   [<a name="SEPARATION_HAUSDORFF-val"><b>SEPARATION_HAUSDORFF</b></a>]  Theorem
      
      ⊢ ∀x y. x ≠ y ⇒ ∃u v. open u ∧ open v ∧ x ∈ u ∧ y ∈ v ∧ u ∩ v = ∅
   
   [<a name="SEPARATION_NORMAL-val"><b>SEPARATION_NORMAL</b></a>]  Theorem
      
      ⊢ ∀s t.
          closed s ∧ closed t ∧ s ∩ t = ∅ ⇒
          ∃u v. open u ∧ open v ∧ s ⊆ u ∧ t ⊆ v ∧ u ∩ v = ∅
   
   [<a name="SEPARATION_NORMAL_COMPACT-val"><b>SEPARATION_NORMAL_COMPACT</b></a>]  Theorem
      
      ⊢ ∀s t.
          compact s ∧ closed t ∧ s ∩ t = ∅ ⇒
          ∃u v.
            open u ∧ compact (closure u) ∧ open v ∧ s ⊆ u ∧ t ⊆ v ∧
            u ∩ v = ∅
   
   [<a name="SEPARATION_NORMAL_LOCAL-val"><b>SEPARATION_NORMAL_LOCAL</b></a>]  Theorem
      
      ⊢ ∀s t u.
          closed_in (subtopology euclidean u) s ∧
          closed_in (subtopology euclidean u) t ∧ s ∩ t = ∅ ⇒
          ∃s' t'.
            open_in (subtopology euclidean u) s' ∧
            open_in (subtopology euclidean u) t' ∧ s ⊆ s' ∧ t ⊆ t' ∧
            s' ∩ t' = ∅
   
   [<a name="SEPARATION_T0-val"><b>SEPARATION_T0</b></a>]  Theorem
      
      ⊢ ∀x y. x ≠ y ⇔ ∃u. open u ∧ (x ∈ u ⇎ y ∈ u)
   
   [<a name="SEPARATION_T1-val"><b>SEPARATION_T1</b></a>]  Theorem
      
      ⊢ ∀x y. x ≠ y ⇔ ∃u v. open u ∧ open v ∧ x ∈ u ∧ y ∉ u ∧ x ∉ v ∧ y ∈ v
   
   [<a name="SEPARATION_T2-val"><b>SEPARATION_T2</b></a>]  Theorem
      
      ⊢ ∀x y. x ≠ y ⇔ ∃u v. open u ∧ open v ∧ x ∈ u ∧ y ∈ v ∧ u ∩ v = ∅
   
   [<a name="SEQUENCE_CAUCHY_WLOG-val"><b>SEQUENCE_CAUCHY_WLOG</b></a>]  Theorem
      
      ⊢ ∀P s.
          (∀m n. P m ∧ P n ⇒ dist (s m,s n) &lt; e) ⇔
          ∀m n. P m ∧ P n ∧ m ≤ n ⇒ dist (s m,s n) &lt; e
   
   [<a name="SEQUENCE_INFINITE_LEMMA-val"><b>SEQUENCE_INFINITE_LEMMA</b></a>]  Theorem
      
      ⊢ ∀f l.
          (∀n. f n ≠ l) ∧ (f ⟶ l) sequentially ⇒
          INFINITE {y | (∃n. y = f n)}
   
   [<a name="SEQUENCE_UNIQUE_LIMPT-val"><b>SEQUENCE_UNIQUE_LIMPT</b></a>]  Theorem
      
      ⊢ ∀f l l'.
          (f ⟶ l) sequentially ∧ l' limit_point_of {y | ∃n. y = f n} ⇒
          l' = l
   
   [<a name="SEQUENTIALLY-val"><b>SEQUENTIALLY</b></a>]  Theorem
      
      ⊢ ∀m n. netord sequentially m n ⇔ m ≥ n
   
   [<a name="SEQ_HARMONIC-val"><b>SEQ_HARMONIC</b></a>]  Theorem
      
      ⊢ ((λn. (&n)⁻¹) ⟶ 0) sequentially
   
   [<a name="SEQ_HARMONIC_OFFSET-val"><b>SEQ_HARMONIC_OFFSET</b></a>]  Theorem
      
      ⊢ ∀a. ((λn. (&n + a)⁻¹) ⟶ 0) sequentially
   
   [<a name="SEQ_OFFSET-val"><b>SEQ_OFFSET</b></a>]  Theorem
      
      ⊢ ∀f l k. (f ⟶ l) sequentially ⇒ ((λi. f (i + k)) ⟶ l) sequentially
   
   [<a name="SEQ_OFFSET_NEG-val"><b>SEQ_OFFSET_NEG</b></a>]  Theorem
      
      ⊢ ∀f l k. (f ⟶ l) sequentially ⇒ ((λi. f (i − k)) ⟶ l) sequentially
   
   [<a name="SEQ_OFFSET_REV-val"><b>SEQ_OFFSET_REV</b></a>]  Theorem
      
      ⊢ ∀f l k. ((λi. f (i + k)) ⟶ l) sequentially ⇒ (f ⟶ l) sequentially
   
   [<a name="SERIES_0-val"><b>SERIES_0</b></a>]  Theorem
      
      ⊢ ∀s. ((λn. 0) sums 0) s
   
   [<a name="SERIES_ABSCONV_IMP_CONV-val"><b>SERIES_ABSCONV_IMP_CONV</b></a>]  Theorem
      
      ⊢ ∀x k. summable k (λn. abs (x n)) ⇒ summable k x
   
   [<a name="SERIES_ADD-val"><b>SERIES_ADD</b></a>]  Theorem
      
      ⊢ ∀x x0 y y0 s.
          (x sums x0) s ∧ (y sums y0) s ⇒ ((λn. x n + y n) sums x0 + y0) s
   
   [<a name="SERIES_BOUND-val"><b>SERIES_BOUND</b></a>]  Theorem
      
      ⊢ ∀f g s a b.
          (f sums a) s ∧ (g sums b) s ∧ (∀i. i ∈ s ⇒ abs (f i) ≤ g i) ⇒
          abs a ≤ b
   
   [<a name="SERIES_CAUCHY-val"><b>SERIES_CAUCHY</b></a>]  Theorem
      
      ⊢ ∀f s.
          (∃l. (f sums l) s) ⇔
          ∀e. 0 &lt; e ⇒ ∃N. ∀m n. m ≥ N ⇒ abs (sum (s ∩ {m .. n}) f) &lt; e
   
   [<a name="SERIES_CAUCHY_UNIFORM-val"><b>SERIES_CAUCHY_UNIFORM</b></a>]  Theorem
      
      ⊢ ∀P f k.
          (∃l. ∀e.
             0 &lt; e ⇒
             ∃N. ∀n x.
               N ≤ n ∧ P x ⇒ dist (sum (k ∩ {0 .. n}) (f x),l x) &lt; e) ⇔
          ∀e. 0 &lt; e ⇒
              ∃N. ∀m n x. N ≤ m ∧ P x ⇒ abs (sum (k ∩ {m .. n}) (f x)) &lt; e
   
   [<a name="SERIES_CMUL-val"><b>SERIES_CMUL</b></a>]  Theorem
      
      ⊢ ∀x x0 c s. (x sums x0) s ⇒ ((λn. c * x n) sums c * x0) s
   
   [<a name="SERIES_COMPARISON-val"><b>SERIES_COMPARISON</b></a>]  Theorem
      
      ⊢ ∀f g s.
          (∃l. (g sums l) s) ∧ (∃N. ∀n. n ≥ N ∧ n ∈ s ⇒ abs (f n) ≤ g n) ⇒
          ∃l. (f sums l) s
   
   [<a name="SERIES_COMPARISON_BOUND-val"><b>SERIES_COMPARISON_BOUND</b></a>]  Theorem
      
      ⊢ ∀f g s a.
          (g sums a) s ∧ (∀i. i ∈ s ⇒ abs (f i) ≤ g i) ⇒
          ∃l. (f sums l) s ∧ abs l ≤ a
   
   [<a name="SERIES_COMPARISON_UNIFORM-val"><b>SERIES_COMPARISON_UNIFORM</b></a>]  Theorem
      
      ⊢ ∀f g P s.
          (∃l. (g sums l) s) ∧
          (∃N. ∀n x. N ≤ n ∧ n ∈ s ∧ P x ⇒ abs (f x n) ≤ g n) ⇒
          ∃l. ∀e.
            0 &lt; e ⇒
            ∃N. ∀n x. N ≤ n ∧ P x ⇒ dist (sum (s ∩ {0 .. n}) (f x),l x) &lt; e
   
   [<a name="SERIES_COMPONENT-val"><b>SERIES_COMPONENT</b></a>]  Theorem
      
      ⊢ ∀f s l. (f sums l) s ⇒ ((λi. f i) sums l) s
   
   [<a name="SERIES_DIFFS-val"><b>SERIES_DIFFS</b></a>]  Theorem
      
      ⊢ ∀f k.
          (f ⟶ 0) sequentially ⇒ ((λn. f n − f (n + 1)) sums f k) (from k)
   
   [<a name="SERIES_DIRICHLET-val"><b>SERIES_DIRICHLET</b></a>]  Theorem
      
      ⊢ ∀f g N k m.
          bounded {sum {m .. n} f | n ∈ 𝕌(:num)} ∧
          (∀n. N ≤ n ⇒ g (n + 1) ≤ g n) ∧ (g ⟶ 0) sequentially ⇒
          summable (from k) (λn. g n * f n)
   
   [<a name="SERIES_DIRICHLET_BILINEAR-val"><b>SERIES_DIRICHLET_BILINEAR</b></a>]  Theorem
      
      ⊢ ∀f g h k m p l.
          bilinear h ∧ bounded {sum {m .. n} f | n ∈ 𝕌(:num)} ∧
          summable (from p) (λn. abs (g (n + 1) − g n)) ∧
          ((λn. h (g (n + 1)) (sum {1 .. n} f)) ⟶ l) sequentially ⇒
          summable (from k) (λn. h (g n) (f n))
   
   [<a name="SERIES_DROP_LE-val"><b>SERIES_DROP_LE</b></a>]  Theorem
      
      ⊢ ∀f g s a b.
          (f sums a) s ∧ (g sums b) s ∧ (∀x. x ∈ s ⇒ f x ≤ g x) ⇒ a ≤ b
   
   [<a name="SERIES_DROP_POS-val"><b>SERIES_DROP_POS</b></a>]  Theorem
      
      ⊢ ∀f s a. (f sums a) s ∧ (∀x. x ∈ s ⇒ 0 ≤ f x) ⇒ 0 ≤ a
   
   [<a name="SERIES_FINITE-val"><b>SERIES_FINITE</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ⇒ (f sums sum s f) s
   
   [<a name="SERIES_FINITE_SUPPORT-val"><b>SERIES_FINITE_SUPPORT</b></a>]  Theorem
      
      ⊢ ∀f s k.
          FINITE (s ∩ k) ∧ (∀x. x ∈ k ∧ x ∉ s ⇒ f x = 0) ⇒
          (f sums sum (s ∩ k) f) k
   
   [<a name="SERIES_FROM-val"><b>SERIES_FROM</b></a>]  Theorem
      
      ⊢ ∀f l k.
          (f sums l) (from k) ⇔ ((λn. sum {k .. n} f) ⟶ l) sequentially
   
   [<a name="SERIES_GOESTOZERO-val"><b>SERIES_GOESTOZERO</b></a>]  Theorem
      
      ⊢ ∀s x.
          summable s x ⇒
          ∀e. 0 &lt; e ⇒ eventually (λn. n ∈ s ⇒ abs (x n) &lt; e) sequentially
   
   [<a name="SERIES_INJECTIVE_IMAGE-val"><b>SERIES_INJECTIVE_IMAGE</b></a>]  Theorem
      
      ⊢ ∀x s f l.
          summable (IMAGE f s) (λn. abs (x n)) ∧
          (∀m n. m ∈ s ∧ n ∈ s ∧ f m = f n ⇒ m = n) ⇒
          ((x ∘ f sums l) s ⇔ (x sums l) (IMAGE f s))
   
   [<a name="SERIES_INJECTIVE_IMAGE_STRONG-val"><b>SERIES_INJECTIVE_IMAGE_STRONG</b></a>]  Theorem
      
      ⊢ ∀x s f.
          summable (IMAGE f s) (λn. abs (x n)) ∧
          (∀m n. m ∈ s ∧ n ∈ s ∧ f m = f n ⇒ m = n) ⇒
          ((λn. sum (IMAGE f s ∩ {0 .. n}) x − sum (s ∩ {0 .. n}) (x ∘ f)) ⟶
           0) sequentially
   
   [<a name="SERIES_LINEAR-val"><b>SERIES_LINEAR</b></a>]  Theorem
      
      ⊢ ∀f h l s. (f sums l) s ∧ linear h ⇒ ((λn. h (f n)) sums h l) s
   
   [<a name="SERIES_NEG-val"><b>SERIES_NEG</b></a>]  Theorem
      
      ⊢ ∀x x0 s. (x sums x0) s ⇒ ((λn. -x n) sums -x0) s
   
   [<a name="SERIES_RATIO-val"><b>SERIES_RATIO</b></a>]  Theorem
      
      ⊢ ∀c a s N.
          c &lt; 1 ∧ (∀n. n ≥ N ⇒ abs (a (SUC n)) ≤ c * abs (a n)) ⇒
          ∃l. (a sums l) s
   
   [<a name="SERIES_REARRANGE-val"><b>SERIES_REARRANGE</b></a>]  Theorem
      
      ⊢ ∀x s p l.
          summable s (λn. abs (x n)) ∧ p permutes s ∧ (x sums l) s ⇒
          (x ∘ p sums l) s
   
   [<a name="SERIES_REARRANGE_EQ-val"><b>SERIES_REARRANGE_EQ</b></a>]  Theorem
      
      ⊢ ∀x s p l.
          summable s (λn. abs (x n)) ∧ p permutes s ⇒
          ((x ∘ p sums l) s ⇔ (x sums l) s)
   
   [<a name="SERIES_RESTRICT-val"><b>SERIES_RESTRICT</b></a>]  Theorem
      
      ⊢ ∀f k l.
          ((λn. if n ∈ k then f n else 0) sums l) 𝕌(:num) ⇔ (f sums l) k
   
   [<a name="SERIES_SUB-val"><b>SERIES_SUB</b></a>]  Theorem
      
      ⊢ ∀x x0 y y0 s.
          (x sums x0) s ∧ (y sums y0) s ⇒ ((λn. x n − y n) sums x0 − y0) s
   
   [<a name="SERIES_SUBSET-val"><b>SERIES_SUBSET</b></a>]  Theorem
      
      ⊢ ∀x s t l.
          s ⊆ t ∧ ((λi. if i ∈ s then x i else 0) sums l) t ⇒ (x sums l) s
   
   [<a name="SERIES_SUM-val"><b>SERIES_SUM</b></a>]  Theorem
      
      ⊢ ∀f l k s.
          FINITE s ∧ s ⊆ k ∧ (∀x. x ∉ s ⇒ f x = 0) ∧ sum s f = l ⇒
          (f sums l) k
   
   [<a name="SERIES_TERMS_TOZERO-val"><b>SERIES_TERMS_TOZERO</b></a>]  Theorem
      
      ⊢ ∀f l n. (f sums l) (from n) ⇒ (f ⟶ 0) sequentially
   
   [<a name="SERIES_TRIVIAL-val"><b>SERIES_TRIVIAL</b></a>]  Theorem
      
      ⊢ ∀f. (f sums 0) ∅
   
   [<a name="SERIES_UNIQUE-val"><b>SERIES_UNIQUE</b></a>]  Theorem
      
      ⊢ ∀f l l' s. (f sums l) s ∧ (f sums l') s ⇒ l = l'
   
   [<a name="SETDIST_BALLS-val"><b>SETDIST_BALLS</b></a>]  Theorem
      
      ⊢ (∀a b r s.
           setdist (ball (a,r),ball (b,s)) =
           if r ≤ 0 ∨ s ≤ 0 then 0 else max 0 (dist (a,b) − (r + s))) ∧
        (∀a b r s.
           setdist (ball (a,r),cball (b,s)) =
           if r ≤ 0 ∨ s &lt; 0 then 0 else max 0 (dist (a,b) − (r + s))) ∧
        (∀a b r s.
           setdist (cball (a,r),ball (b,s)) =
           if r &lt; 0 ∨ s ≤ 0 then 0 else max 0 (dist (a,b) − (r + s))) ∧
        ∀a b r s.
          setdist (cball (a,r),cball (b,s)) =
          if r &lt; 0 ∨ s &lt; 0 then 0 else max 0 (dist (a,b) − (r + s))
   
   [<a name="SETDIST_CLOSED_COMPACT-val"><b>SETDIST_CLOSED_COMPACT</b></a>]  Theorem
      
      ⊢ ∀s t.
          closed s ∧ compact t ∧ s ≠ ∅ ∧ t ≠ ∅ ⇒
          ∃x y. x ∈ s ∧ y ∈ t ∧ dist (x,y) = setdist (s,t)
   
   [<a name="SETDIST_CLOSEST_POINT-val"><b>SETDIST_CLOSEST_POINT</b></a>]  Theorem
      
      ⊢ ∀a s.
          closed s ∧ s ≠ ∅ ⇒ setdist ({a},s) = dist (a,closest_point s a)
   
   [<a name="SETDIST_CLOSURE-val"><b>SETDIST_CLOSURE</b></a>]  Theorem
      
      ⊢ (∀s t. setdist (closure s,t) = setdist (s,t)) ∧
        ∀s t. setdist (s,closure t) = setdist (s,t)
   
   [<a name="SETDIST_COMPACT_CLOSED-val"><b>SETDIST_COMPACT_CLOSED</b></a>]  Theorem
      
      ⊢ ∀s t.
          compact s ∧ closed t ∧ s ≠ ∅ ∧ t ≠ ∅ ⇒
          ∃x y. x ∈ s ∧ y ∈ t ∧ dist (x,y) = setdist (s,t)
   
   [<a name="SETDIST_DIFFERENCES-val"><b>SETDIST_DIFFERENCES</b></a>]  Theorem
      
      ⊢ ∀s t. setdist (s,t) = setdist ({0},{x − y | x ∈ s ∧ y ∈ t})
   
   [<a name="SETDIST_EMPTY-val"><b>SETDIST_EMPTY</b></a>]  Theorem
      
      ⊢ (∀t. setdist (∅,t) = 0) ∧ ∀s. setdist (s,∅) = 0
   
   [<a name="SETDIST_EQ_0_BOUNDED-val"><b>SETDIST_EQ_0_BOUNDED</b></a>]  Theorem
      
      ⊢ ∀s t.
          bounded s ∨ bounded t ⇒
          (setdist (s,t) = 0 ⇔ s = ∅ ∨ t = ∅ ∨ closure s ∩ closure t ≠ ∅)
   
   [<a name="SETDIST_EQ_0_CLOSED-val"><b>SETDIST_EQ_0_CLOSED</b></a>]  Theorem
      
      ⊢ ∀s x. closed s ⇒ (setdist ({x},s) = 0 ⇔ s = ∅ ∨ x ∈ s)
   
   [<a name="SETDIST_EQ_0_CLOSED_COMPACT-val"><b>SETDIST_EQ_0_CLOSED_COMPACT</b></a>]  Theorem
      
      ⊢ ∀s t.
          closed s ∧ compact t ⇒
          (setdist (s,t) = 0 ⇔ s = ∅ ∨ t = ∅ ∨ s ∩ t ≠ ∅)
   
   [<a name="SETDIST_EQ_0_CLOSED_IN-val"><b>SETDIST_EQ_0_CLOSED_IN</b></a>]  Theorem
      
      ⊢ ∀u s x.
          closed_in (subtopology euclidean u) s ∧ x ∈ u ⇒
          (setdist ({x},s) = 0 ⇔ s = ∅ ∨ x ∈ s)
   
   [<a name="SETDIST_EQ_0_COMPACT_CLOSED-val"><b>SETDIST_EQ_0_COMPACT_CLOSED</b></a>]  Theorem
      
      ⊢ ∀s t.
          compact s ∧ closed t ⇒
          (setdist (s,t) = 0 ⇔ s = ∅ ∨ t = ∅ ∨ s ∩ t ≠ ∅)
   
   [<a name="SETDIST_EQ_0_SING-val"><b>SETDIST_EQ_0_SING</b></a>]  Theorem
      
      ⊢ (∀s x. setdist ({x},s) = 0 ⇔ s = ∅ ∨ x ∈ closure s) ∧
        ∀s x. setdist (s,{x}) = 0 ⇔ s = ∅ ∨ x ∈ closure s
   
   [<a name="SETDIST_FRONTIER-val"><b>SETDIST_FRONTIER</b></a>]  Theorem
      
      ⊢ (∀s t. DISJOINT s t ⇒ setdist (frontier s,t) = setdist (s,t)) ∧
        ∀s t. DISJOINT s t ⇒ setdist (s,frontier t) = setdist (s,t)
   
   [<a name="SETDIST_FRONTIERS-val"><b>SETDIST_FRONTIERS</b></a>]  Theorem
      
      ⊢ ∀s t.
          setdist (s,t) =
          if DISJOINT s t then setdist (frontier s,frontier t) else 0
   
   [<a name="SETDIST_HAUSDIST_TRIANGLE-val"><b>SETDIST_HAUSDIST_TRIANGLE</b></a>]  Theorem
      
      ⊢ ∀s t u.
          t ≠ ∅ ∧ bounded t ∧ bounded u ⇒
          setdist (s,u) ≤ setdist (s,t) + hausdist (t,u)
   
   [<a name="SETDIST_LE_DIST-val"><b>SETDIST_LE_DIST</b></a>]  Theorem
      
      ⊢ ∀s t x y. x ∈ s ∧ y ∈ t ⇒ setdist (s,t) ≤ dist (x,y)
   
   [<a name="SETDIST_LE_HAUSDIST-val"><b>SETDIST_LE_HAUSDIST</b></a>]  Theorem
      
      ⊢ ∀s t. bounded s ∧ bounded t ⇒ setdist (s,t) ≤ hausdist (s,t)
   
   [<a name="SETDIST_LE_SING-val"><b>SETDIST_LE_SING</b></a>]  Theorem
      
      ⊢ ∀s t x. x ∈ s ⇒ setdist (s,t) ≤ setdist ({x},t)
   
   [<a name="SETDIST_LINEAR_IMAGE-val"><b>SETDIST_LINEAR_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s t.
          linear f ∧ (∀x. abs (f x) = abs x) ⇒
          setdist (IMAGE f s,IMAGE f t) = setdist (s,t)
   
   [<a name="SETDIST_LIPSCHITZ-val"><b>SETDIST_LIPSCHITZ</b></a>]  Theorem
      
      ⊢ ∀s t x y. abs (setdist ({x},s) − setdist ({y},s)) ≤ dist (x,y)
   
   [<a name="SETDIST_POS_LE-val"><b>SETDIST_POS_LE</b></a>]  Theorem
      
      ⊢ ∀s t. 0 ≤ setdist (s,t)
   
   [<a name="SETDIST_REFL-val"><b>SETDIST_REFL</b></a>]  Theorem
      
      ⊢ ∀s. setdist (s,s) = 0
   
   [<a name="SETDIST_SINGS-val"><b>SETDIST_SINGS</b></a>]  Theorem
      
      ⊢ ∀x y. setdist ({x},{y}) = dist (x,y)
   
   [<a name="SETDIST_SING_FRONTIER-val"><b>SETDIST_SING_FRONTIER</b></a>]  Theorem
      
      ⊢ ∀s x. x ∉ s ⇒ setdist ({x},frontier s) = setdist ({x},s)
   
   [<a name="SETDIST_SING_FRONTIER_CASES-val"><b>SETDIST_SING_FRONTIER_CASES</b></a>]  Theorem
      
      ⊢ ∀s x.
          setdist ({x},s) = if x ∈ s then 0 else setdist ({x},frontier s)
   
   [<a name="SETDIST_SING_IN_SET-val"><b>SETDIST_SING_IN_SET</b></a>]  Theorem
      
      ⊢ ∀x s. x ∈ s ⇒ setdist ({x},s) = 0
   
   [<a name="SETDIST_SING_LE_HAUSDIST-val"><b>SETDIST_SING_LE_HAUSDIST</b></a>]  Theorem
      
      ⊢ ∀s t x.
          bounded s ∧ bounded t ∧ x ∈ s ⇒ setdist ({x},t) ≤ hausdist (s,t)
   
   [<a name="SETDIST_SING_TRIANGLE-val"><b>SETDIST_SING_TRIANGLE</b></a>]  Theorem
      
      ⊢ ∀s x y. abs (setdist ({x},s) − setdist ({y},s)) ≤ dist (x,y)
   
   [<a name="SETDIST_SUBSETS_EQ-val"><b>SETDIST_SUBSETS_EQ</b></a>]  Theorem
      
      ⊢ ∀s t s' t'.
          s' ⊆ s ∧ t' ⊆ t ∧
          (∀x y.
             x ∈ s ∧ y ∈ t ⇒
             ∃x' y'. x' ∈ s' ∧ y' ∈ t' ∧ dist (x',y') ≤ dist (x,y)) ⇒
          setdist (s',t') = setdist (s,t)
   
   [<a name="SETDIST_SUBSET_LEFT-val"><b>SETDIST_SUBSET_LEFT</b></a>]  Theorem
      
      ⊢ ∀s t u. s ≠ ∅ ∧ s ⊆ t ⇒ setdist (t,u) ≤ setdist (s,u)
   
   [<a name="SETDIST_SUBSET_RIGHT-val"><b>SETDIST_SUBSET_RIGHT</b></a>]  Theorem
      
      ⊢ ∀s t u. t ≠ ∅ ∧ t ⊆ u ⇒ setdist (s,u) ≤ setdist (s,t)
   
   [<a name="SETDIST_SYM-val"><b>SETDIST_SYM</b></a>]  Theorem
      
      ⊢ ∀s t. setdist (s,t) = setdist (t,s)
   
   [<a name="SETDIST_TRANSLATION-val"><b>SETDIST_TRANSLATION</b></a>]  Theorem
      
      ⊢ ∀a s t.
          setdist (IMAGE (λx. a + x) s,IMAGE (λx. a + x) t) = setdist (s,t)
   
   [<a name="SETDIST_TRIANGLE-val"><b>SETDIST_TRIANGLE</b></a>]  Theorem
      
      ⊢ ∀s a t. setdist (s,t) ≤ setdist (s,{a}) + setdist ({a},t)
   
   [<a name="SETDIST_UNIQUE-val"><b>SETDIST_UNIQUE</b></a>]  Theorem
      
      ⊢ ∀s t a b d.
          a ∈ s ∧ b ∈ t ∧ dist (a,b) = d ∧
          (∀x y. x ∈ s ∧ y ∈ t ⇒ dist (a,b) ≤ dist (x,y)) ⇒
          setdist (s,t) = d
   
   [<a name="SETDIST_UNIV-val"><b>SETDIST_UNIV</b></a>]  Theorem
      
      ⊢ (∀s. setdist (s,𝕌(:real)) = 0) ∧ ∀t. setdist (𝕌(:real),t) = 0
   
   [<a name="SETDIST_ZERO-val"><b>SETDIST_ZERO</b></a>]  Theorem
      
      ⊢ ∀s t. ¬DISJOINT s t ⇒ setdist (s,t) = 0
   
   [<a name="SETDIST_ZERO_STRONG-val"><b>SETDIST_ZERO_STRONG</b></a>]  Theorem
      
      ⊢ ∀s t. ¬DISJOINT (closure s) (closure t) ⇒ setdist (s,t) = 0
   
   [<a name="SET_DIFF_FRONTIER-val"><b>SET_DIFF_FRONTIER</b></a>]  Theorem
      
      ⊢ ∀s. s DIFF frontier s = interior s
   
   [<a name="SPANNING_SUBSET_INDEPENDENT-val"><b>SPANNING_SUBSET_INDEPENDENT</b></a>]  Theorem
      
      ⊢ ∀s t. t ⊆ s ∧ independent s ∧ s ⊆ span t ⇒ s = t
   
   [<a name="SPAN_0-val"><b>SPAN_0</b></a>]  Theorem
      
      ⊢ 0 ∈ span s
   
   [<a name="SPAN_ADD-val"><b>SPAN_ADD</b></a>]  Theorem
      
      ⊢ ∀x y s. x ∈ span s ∧ y ∈ span s ⇒ x + y ∈ span s
   
   [<a name="SPAN_ADD_EQ-val"><b>SPAN_ADD_EQ</b></a>]  Theorem
      
      ⊢ ∀s x y. x ∈ span s ⇒ (x + y ∈ span s ⇔ y ∈ span s)
   
   [<a name="SPAN_BREAKDOWN-val"><b>SPAN_BREAKDOWN</b></a>]  Theorem
      
      ⊢ ∀b s a. b ∈ s ∧ a ∈ span s ⇒ ∃k. a − k * b ∈ span (s DELETE b)
   
   [<a name="SPAN_BREAKDOWN_EQ-val"><b>SPAN_BREAKDOWN_EQ</b></a>]  Theorem
      
      ⊢ ∀a s. x ∈ span (a INSERT s) ⇔ ∃k. x − k * a ∈ span s
   
   [<a name="SPAN_CARD_GE_DIM-val"><b>SPAN_CARD_GE_DIM</b></a>]  Theorem
      
      ⊢ ∀v b. v ⊆ span b ∧ FINITE b ⇒ dim v ≤ CARD b
   
   [<a name="SPAN_CLAUSES-val"><b>SPAN_CLAUSES</b></a>]  Theorem
      
      ⊢ (∀a s. a ∈ s ⇒ a ∈ span s) ∧ 0 ∈ span s ∧
        (∀x y s. x ∈ span s ∧ y ∈ span s ⇒ x + y ∈ span s) ∧
        ∀x c s. x ∈ span s ⇒ c * x ∈ span s
   
   [<a name="SPAN_EMPTY-val"><b>SPAN_EMPTY</b></a>]  Theorem
      
      ⊢ span ∅ = {0}
   
   [<a name="SPAN_EQ_SELF-val"><b>SPAN_EQ_SELF</b></a>]  Theorem
      
      ⊢ ∀s. span s = s ⇔ subspace s
   
   [<a name="SPAN_EXPLICIT-val"><b>SPAN_EXPLICIT</b></a>]  Theorem
      
      ⊢ ∀p. span p = {y | ∃s u. FINITE s ∧ s ⊆ p ∧ sum s (λv. u v * v) = y}
   
   [<a name="SPAN_INC-val"><b>SPAN_INC</b></a>]  Theorem
      
      ⊢ ∀s. s ⊆ span s
   
   [<a name="SPAN_INDUCT-val"><b>SPAN_INDUCT</b></a>]  Theorem
      
      ⊢ ∀s h. (∀x. x ∈ s ⇒ x ∈ h) ∧ subspace h ⇒ ∀x. x ∈ span s ⇒ h x
   
   [<a name="SPAN_INDUCT_ALT-val"><b>SPAN_INDUCT_ALT</b></a>]  Theorem
      
      ⊢ ∀s h.
          h 0 ∧ (∀c x y. x ∈ s ∧ h y ⇒ h (c * x + y)) ⇒
          ∀x. x ∈ span s ⇒ h x
   
   [<a name="SPAN_LINEAR_IMAGE-val"><b>SPAN_LINEAR_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s. linear f ⇒ span (IMAGE f s) = IMAGE f (span s)
   
   [<a name="SPAN_MONO-val"><b>SPAN_MONO</b></a>]  Theorem
      
      ⊢ ∀s t. s ⊆ t ⇒ span s ⊆ span t
   
   [<a name="SPAN_MUL-val"><b>SPAN_MUL</b></a>]  Theorem
      
      ⊢ ∀x c s. x ∈ span s ⇒ c * x ∈ span s
   
   [<a name="SPAN_MUL_EQ-val"><b>SPAN_MUL_EQ</b></a>]  Theorem
      
      ⊢ ∀x c s. c ≠ 0 ⇒ (c * x ∈ span s ⇔ x ∈ span s)
   
   [<a name="SPAN_NEG-val"><b>SPAN_NEG</b></a>]  Theorem
      
      ⊢ ∀x s. x ∈ span s ⇒ -x ∈ span s
   
   [<a name="SPAN_NEG_EQ-val"><b>SPAN_NEG_EQ</b></a>]  Theorem
      
      ⊢ ∀x s. -x ∈ span s ⇔ x ∈ span s
   
   [<a name="SPAN_SPAN-val"><b>SPAN_SPAN</b></a>]  Theorem
      
      ⊢ ∀s. span (span s) = span s
   
   [<a name="SPAN_STDBASIS-val"><b>SPAN_STDBASIS</b></a>]  Theorem
      
      ⊢ span {i | 1 ≤ i ∧ i ≤ 1} = 𝕌(:real)
   
   [<a name="SPAN_SUB-val"><b>SPAN_SUB</b></a>]  Theorem
      
      ⊢ ∀x y s. x ∈ span s ∧ y ∈ span s ⇒ x − y ∈ span s
   
   [<a name="SPAN_SUBSET_SUBSPACE-val"><b>SPAN_SUBSET_SUBSPACE</b></a>]  Theorem
      
      ⊢ ∀s t. s ⊆ t ∧ subspace t ⇒ span s ⊆ t
   
   [<a name="SPAN_SUBSPACE-val"><b>SPAN_SUBSPACE</b></a>]  Theorem
      
      ⊢ ∀b s. b ⊆ s ∧ s ⊆ span b ∧ subspace s ⇒ span b = s
   
   [<a name="SPAN_SUM-val"><b>SPAN_SUM</b></a>]  Theorem
      
      ⊢ ∀s f t. FINITE t ∧ (∀x. x ∈ t ⇒ f x ∈ span s) ⇒ sum t f ∈ span s
   
   [<a name="SPAN_SUPERSET-val"><b>SPAN_SUPERSET</b></a>]  Theorem
      
      ⊢ ∀x. x ∈ s ⇒ x ∈ span s
   
   [<a name="SPAN_TRANS-val"><b>SPAN_TRANS</b></a>]  Theorem
      
      ⊢ ∀x y s. x ∈ span s ∧ y ∈ span (x INSERT s) ⇒ y ∈ span s
   
   [<a name="SPAN_UNION-val"><b>SPAN_UNION</b></a>]  Theorem
      
      ⊢ ∀s t. span (s ∪ t) = {x + y | x ∈ span s ∧ y ∈ span t}
   
   [<a name="SPAN_UNION_SUBSET-val"><b>SPAN_UNION_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t. span s ∪ span t ⊆ span (s ∪ t)
   
   [<a name="SPAN_UNIV-val"><b>SPAN_UNIV</b></a>]  Theorem
      
      ⊢ span 𝕌(:real) = 𝕌(:real)
   
   [<a name="SPHERE-val"><b>SPHERE</b></a>]  Theorem
      
      ⊢ ∀a r. sphere (a,r) = if r &lt; 0 then ∅ else {a − r; a + r}
   
   [<a name="SPHERE_EMPTY-val"><b>SPHERE_EMPTY</b></a>]  Theorem
      
      ⊢ ∀a r. r &lt; 0 ⇒ sphere (a,r) = ∅
   
   [<a name="SPHERE_EQ_EMPTY-val"><b>SPHERE_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ ∀a r. sphere (a,r) = ∅ ⇔ r &lt; 0
   
   [<a name="SPHERE_EQ_SING-val"><b>SPHERE_EQ_SING</b></a>]  Theorem
      
      ⊢ ∀a r x. sphere (a,r) = {x} ⇔ x = a ∧ r = 0
   
   [<a name="SPHERE_LINEAR_IMAGE-val"><b>SPHERE_LINEAR_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f x r.
          linear f ∧ (∀y. ∃x. f x = y) ∧ (∀x. abs (f x) = abs x) ⇒
          sphere (f x,r) = IMAGE f (sphere (x,r))
   
   [<a name="SPHERE_SING-val"><b>SPHERE_SING</b></a>]  Theorem
      
      ⊢ ∀x e. e = 0 ⇒ sphere (x,e) = {x}
   
   [<a name="SPHERE_SUBSET_CBALL-val"><b>SPHERE_SUBSET_CBALL</b></a>]  Theorem
      
      ⊢ ∀x e. sphere (x,e) ⊆ cball (x,e)
   
   [<a name="SPHERE_TRANSLATION-val"><b>SPHERE_TRANSLATION</b></a>]  Theorem
      
      ⊢ ∀a x r. sphere (a + x,r) = IMAGE (λy. a + y) (sphere (x,r))
   
   [<a name="SPHERE_UNION_BALL-val"><b>SPHERE_UNION_BALL</b></a>]  Theorem
      
      ⊢ ∀a r. sphere (a,r) ∪ ball (a,r) = cball (a,r)
   
   [<a name="SUBORDINATE_PARTITION_OF_UNITY-val"><b>SUBORDINATE_PARTITION_OF_UNITY</b></a>]  Theorem
      
      ⊢ ∀c s.
          s ⊆ BIGUNION c ∧ (∀u. u ∈ c ⇒ open u) ∧
          (∀x. x ∈ s ⇒ ∃v. open v ∧ x ∈ v ∧ FINITE {u | u ∈ c ∧ u ∩ v ≠ ∅}) ⇒
          ∃f. (∀u. u ∈ c ⇒ f u continuous_on s ∧ ∀x. x ∈ s ⇒ 0 ≤ f u x) ∧
              (∀x u. u ∈ c ∧ x ∈ s ∧ x ∉ u ⇒ f u x = 0) ∧
              (∀x. x ∈ s ⇒ sum c (λu. f u x) = 1) ∧
              ∀x. x ∈ s ⇒
                  ∃n. open n ∧ x ∈ n ∧
                      FINITE {u | u ∈ c ∧ ¬∀x. x ∈ n ⇒ f u x = 0}
   
   [<a name="SUBSET_BALL-val"><b>SUBSET_BALL</b></a>]  Theorem
      
      ⊢ ∀x d e. d ≤ e ⇒ ball (x,d) ⊆ ball (x,e)
   
   [<a name="SUBSET_BALLS-val"><b>SUBSET_BALLS</b></a>]  Theorem
      
      ⊢ (∀a a' r r'.
           ball (a,r) ⊆ ball (a',r') ⇔ dist (a,a') + r ≤ r' ∨ r ≤ 0) ∧
        (∀a a' r r'.
           ball (a,r) ⊆ cball (a',r') ⇔ dist (a,a') + r ≤ r' ∨ r ≤ 0) ∧
        (∀a a' r r'.
           cball (a,r) ⊆ ball (a',r') ⇔ dist (a,a') + r &lt; r' ∨ r &lt; 0) ∧
        ∀a a' r r'.
          cball (a,r) ⊆ cball (a',r') ⇔ dist (a,a') + r ≤ r' ∨ r &lt; 0
   
   [<a name="SUBSET_CBALL-val"><b>SUBSET_CBALL</b></a>]  Theorem
      
      ⊢ ∀x d e. d ≤ e ⇒ cball (x,d) ⊆ cball (x,e)
   
   [<a name="SUBSET_CLOSURE-val"><b>SUBSET_CLOSURE</b></a>]  Theorem
      
      ⊢ ∀s t. s ⊆ t ⇒ closure s ⊆ closure t
   
   [<a name="SUBSET_INTERIOR-val"><b>SUBSET_INTERIOR</b></a>]  Theorem
      
      ⊢ ∀s t. s ⊆ t ⇒ interior s ⊆ interior t
   
   [<a name="SUBSET_INTERIOR_EQ-val"><b>SUBSET_INTERIOR_EQ</b></a>]  Theorem
      
      ⊢ ∀s. s ⊆ interior s ⇔ open s
   
   [<a name="SUBSET_INTERVAL-val"><b>SUBSET_INTERVAL</b></a>]  Theorem
      
      ⊢ (interval [(c,d)] ⊆ interval [(a,b)] ⇔ c ≤ d ⇒ a ≤ c ∧ d ≤ b) ∧
        (interval [(c,d)] ⊆ interval (a,b) ⇔ c ≤ d ⇒ a &lt; c ∧ d &lt; b) ∧
        (interval (c,d) ⊆ interval [(a,b)] ⇔ c &lt; d ⇒ a ≤ c ∧ d ≤ b) ∧
        (interval (c,d) ⊆ interval (a,b) ⇔ c &lt; d ⇒ a ≤ c ∧ d ≤ b)
   
   [<a name="SUBSET_INTERVAL_IMP-val"><b>SUBSET_INTERVAL_IMP</b></a>]  Theorem
      
      ⊢ (a ≤ c ∧ d ≤ b ⇒ interval [(c,d)] ⊆ interval [(a,b)]) ∧
        (a &lt; c ∧ d &lt; b ⇒ interval [(c,d)] ⊆ interval (a,b)) ∧
        (a ≤ c ∧ d ≤ b ⇒ interval (c,d) ⊆ interval [(a,b)]) ∧
        (a ≤ c ∧ d ≤ b ⇒ interval (c,d) ⊆ interval (a,b))
   
   [<a name="SUBSPACE_0-val"><b>SUBSPACE_0</b></a>]  Theorem
      
      ⊢ subspace s ⇒ 0 ∈ s
   
   [<a name="SUBSPACE_ADD-val"><b>SUBSPACE_ADD</b></a>]  Theorem
      
      ⊢ ∀x y s. subspace s ∧ x ∈ s ∧ y ∈ s ⇒ x + y ∈ s
   
   [<a name="SUBSPACE_BIGINTER-val"><b>SUBSPACE_BIGINTER</b></a>]  Theorem
      
      ⊢ ∀f. (∀s. s ∈ f ⇒ subspace s) ⇒ subspace (BIGINTER f)
   
   [<a name="SUBSPACE_BOUNDED_EQ_TRIVIAL-val"><b>SUBSPACE_BOUNDED_EQ_TRIVIAL</b></a>]  Theorem
      
      ⊢ ∀s. subspace s ⇒ (bounded s ⇔ s = {0})
   
   [<a name="SUBSPACE_IMP_NONEMPTY-val"><b>SUBSPACE_IMP_NONEMPTY</b></a>]  Theorem
      
      ⊢ ∀s. subspace s ⇒ s ≠ ∅
   
   [<a name="SUBSPACE_INTER-val"><b>SUBSPACE_INTER</b></a>]  Theorem
      
      ⊢ ∀s t. subspace s ∧ subspace t ⇒ subspace (s ∩ t)
   
   [<a name="SUBSPACE_KERNEL-val"><b>SUBSPACE_KERNEL</b></a>]  Theorem
      
      ⊢ ∀f. linear f ⇒ subspace {x | f x = 0}
   
   [<a name="SUBSPACE_LINEAR_IMAGE-val"><b>SUBSPACE_LINEAR_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s. linear f ∧ subspace s ⇒ subspace (IMAGE f s)
   
   [<a name="SUBSPACE_LINEAR_PREIMAGE-val"><b>SUBSPACE_LINEAR_PREIMAGE</b></a>]  Theorem
      
      ⊢ ∀f s. linear f ∧ subspace s ⇒ subspace {x | f x ∈ s}
   
   [<a name="SUBSPACE_MUL-val"><b>SUBSPACE_MUL</b></a>]  Theorem
      
      ⊢ ∀x c s. subspace s ∧ x ∈ s ⇒ c * x ∈ s
   
   [<a name="SUBSPACE_NEG-val"><b>SUBSPACE_NEG</b></a>]  Theorem
      
      ⊢ ∀x s. subspace s ∧ x ∈ s ⇒ -x ∈ s
   
   [<a name="SUBSPACE_SPAN-val"><b>SUBSPACE_SPAN</b></a>]  Theorem
      
      ⊢ ∀s. subspace (span s)
   
   [<a name="SUBSPACE_SUB-val"><b>SUBSPACE_SUB</b></a>]  Theorem
      
      ⊢ ∀x y s. subspace s ∧ x ∈ s ∧ y ∈ s ⇒ x − y ∈ s
   
   [<a name="SUBSPACE_SUBSTANDARD-val"><b>SUBSPACE_SUBSTANDARD</b></a>]  Theorem
      
      ⊢ subspace {x | x = 0}
   
   [<a name="SUBSPACE_SUM-val"><b>SUBSPACE_SUM</b></a>]  Theorem
      
      ⊢ ∀s f t. subspace s ∧ FINITE t ∧ (∀x. x ∈ t ⇒ f x ∈ s) ⇒ sum t f ∈ s
   
   [<a name="SUBSPACE_SUMS-val"><b>SUBSPACE_SUMS</b></a>]  Theorem
      
      ⊢ ∀s t. subspace s ∧ subspace t ⇒ subspace {x + y | x ∈ s ∧ y ∈ t}
   
   [<a name="SUBSPACE_TRANSLATION_SELF-val"><b>SUBSPACE_TRANSLATION_SELF</b></a>]  Theorem
      
      ⊢ ∀s a. subspace s ∧ a ∈ s ⇒ IMAGE (λx. a + x) s = s
   
   [<a name="SUBSPACE_TRANSLATION_SELF_EQ-val"><b>SUBSPACE_TRANSLATION_SELF_EQ</b></a>]  Theorem
      
      ⊢ ∀s a. subspace s ⇒ (IMAGE (λx. a + x) s = s ⇔ a ∈ s)
   
   [<a name="SUBSPACE_TRIVIAL-val"><b>SUBSPACE_TRIVIAL</b></a>]  Theorem
      
      ⊢ subspace {0}
   
   [<a name="SUBSPACE_UNION_CHAIN-val"><b>SUBSPACE_UNION_CHAIN</b></a>]  Theorem
      
      ⊢ ∀s t. subspace s ∧ subspace t ∧ subspace (s ∪ t) ⇒ s ⊆ t ∨ t ⊆ s
   
   [<a name="SUBSPACE_UNIV-val"><b>SUBSPACE_UNIV</b></a>]  Theorem
      
      ⊢ subspace 𝕌(:real)
   
   [<a name="SUMMABLE_0-val"><b>SUMMABLE_0</b></a>]  Theorem
      
      ⊢ ∀s. summable s (λn. 0)
   
   [<a name="SUMMABLE_ADD-val"><b>SUMMABLE_ADD</b></a>]  Theorem
      
      ⊢ ∀x y s. summable s x ∧ summable s y ⇒ summable s (λn. x n + y n)
   
   [<a name="SUMMABLE_BILINEAR_PARTIAL_PRE-val"><b>SUMMABLE_BILINEAR_PARTIAL_PRE</b></a>]  Theorem
      
      ⊢ ∀f g h l k.
          bilinear h ∧ ((λn. h (f (n + 1)) (g n)) ⟶ l) sequentially ∧
          summable (from k) (λn. h (f (n + 1) − f n) (g n)) ⇒
          summable (from k) (λn. h (f n) (g n − g (n − 1)))
   
   [<a name="SUMMABLE_CAUCHY-val"><b>SUMMABLE_CAUCHY</b></a>]  Theorem
      
      ⊢ ∀f s.
          summable s f ⇔
          ∀e. 0 &lt; e ⇒ ∃N. ∀m n. m ≥ N ⇒ abs (sum (s ∩ {m .. n}) f) &lt; e
   
   [<a name="SUMMABLE_CMUL-val"><b>SUMMABLE_CMUL</b></a>]  Theorem
      
      ⊢ ∀s x c. summable s x ⇒ summable s (λn. c * x n)
   
   [<a name="SUMMABLE_COMPARISON-val"><b>SUMMABLE_COMPARISON</b></a>]  Theorem
      
      ⊢ ∀f g s.
          summable s g ∧ (∃N. ∀n. n ≥ N ∧ n ∈ s ⇒ abs (f n) ≤ g n) ⇒
          summable s f
   
   [<a name="SUMMABLE_COMPONENT-val"><b>SUMMABLE_COMPONENT</b></a>]  Theorem
      
      ⊢ ∀f s. summable s f ⇒ summable s (λi. f i)
   
   [<a name="SUMMABLE_EQ-val"><b>SUMMABLE_EQ</b></a>]  Theorem
      
      ⊢ ∀f g k. (∀x. x ∈ k ⇒ f x = g x) ∧ summable k f ⇒ summable k g
   
   [<a name="SUMMABLE_EQ_COFINITE-val"><b>SUMMABLE_EQ_COFINITE</b></a>]  Theorem
      
      ⊢ ∀f s t.
          FINITE (s DIFF t ∪ (t DIFF s)) ∧ summable s f ⇒ summable t f
   
   [<a name="SUMMABLE_EQ_EVENTUALLY-val"><b>SUMMABLE_EQ_EVENTUALLY</b></a>]  Theorem
      
      ⊢ ∀f g k.
          (∃N. ∀n. N ≤ n ∧ n ∈ k ⇒ f n = g n) ∧ summable k f ⇒ summable k g
   
   [<a name="SUMMABLE_FROM_ELSEWHERE-val"><b>SUMMABLE_FROM_ELSEWHERE</b></a>]  Theorem
      
      ⊢ ∀f m n. summable (from m) f ⇒ summable (from n) f
   
   [<a name="SUMMABLE_IFF-val"><b>SUMMABLE_IFF</b></a>]  Theorem
      
      ⊢ ∀f g k. (∀x. x ∈ k ⇒ f x = g x) ⇒ (summable k f ⇔ summable k g)
   
   [<a name="SUMMABLE_IFF_COFINITE-val"><b>SUMMABLE_IFF_COFINITE</b></a>]  Theorem
      
      ⊢ ∀f s t.
          FINITE (s DIFF t ∪ (t DIFF s)) ⇒ (summable s f ⇔ summable t f)
   
   [<a name="SUMMABLE_IFF_EVENTUALLY-val"><b>SUMMABLE_IFF_EVENTUALLY</b></a>]  Theorem
      
      ⊢ ∀f g k.
          (∃N. ∀n. N ≤ n ∧ n ∈ k ⇒ f n = g n) ⇒
          (summable k f ⇔ summable k g)
   
   [<a name="SUMMABLE_IMP_BOUNDED-val"><b>SUMMABLE_IMP_BOUNDED</b></a>]  Theorem
      
      ⊢ ∀f k. summable k f ⇒ bounded (IMAGE f k)
   
   [<a name="SUMMABLE_IMP_SUMS_BOUNDED-val"><b>SUMMABLE_IMP_SUMS_BOUNDED</b></a>]  Theorem
      
      ⊢ ∀f k. summable (from k) f ⇒ bounded {sum {k .. n} f | n ∈ 𝕌(:num)}
   
   [<a name="SUMMABLE_IMP_TOZERO-val"><b>SUMMABLE_IMP_TOZERO</b></a>]  Theorem
      
      ⊢ ∀f k.
          summable k f ⇒ ((λn. if n ∈ k then f n else 0) ⟶ 0) sequentially
   
   [<a name="SUMMABLE_LINEAR-val"><b>SUMMABLE_LINEAR</b></a>]  Theorem
      
      ⊢ ∀f h s. summable s f ∧ linear h ⇒ summable s (λn. h (f n))
   
   [<a name="SUMMABLE_NEG-val"><b>SUMMABLE_NEG</b></a>]  Theorem
      
      ⊢ ∀x s. summable s x ⇒ summable s (λn. -x n)
   
   [<a name="SUMMABLE_REARRANGE-val"><b>SUMMABLE_REARRANGE</b></a>]  Theorem
      
      ⊢ ∀x s p.
          summable s (λn. abs (x n)) ∧ p permutes s ⇒ summable s (x ∘ p)
   
   [<a name="SUMMABLE_REINDEX-val"><b>SUMMABLE_REINDEX</b></a>]  Theorem
      
      ⊢ ∀k a n.
          summable (from n) (λx. a (x + k)) ⇔ summable (from (n + k)) a
   
   [<a name="SUMMABLE_RESTRICT-val"><b>SUMMABLE_RESTRICT</b></a>]  Theorem
      
      ⊢ ∀f k.
          summable 𝕌(:num) (λn. if n ∈ k then f n else 0) ⇔ summable k f
   
   [<a name="SUMMABLE_SUB-val"><b>SUMMABLE_SUB</b></a>]  Theorem
      
      ⊢ ∀x y s. summable s x ∧ summable s y ⇒ summable s (λn. x n − y n)
   
   [<a name="SUMMABLE_SUBSET-val"><b>SUMMABLE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀x s t.
          s ⊆ t ∧ summable t (λi. if i ∈ s then x i else 0) ⇒ summable s x
   
   [<a name="SUMMABLE_SUBSET_ABSCONV-val"><b>SUMMABLE_SUBSET_ABSCONV</b></a>]  Theorem
      
      ⊢ ∀x s t.
          summable s (λn. abs (x n)) ∧ t ⊆ s ⇒ summable t (λn. abs (x n))
   
   [<a name="SUMMABLE_TRIVIAL-val"><b>SUMMABLE_TRIVIAL</b></a>]  Theorem
      
      ⊢ ∀f. summable ∅ f
   
   [<a name="SUMS_0-val"><b>SUMS_0</b></a>]  Theorem
      
      ⊢ ∀f s. (∀n. n ∈ s ⇒ f n = 0) ⇒ (f sums 0) s
   
   [<a name="SUMS_EQ-val"><b>SUMS_EQ</b></a>]  Theorem
      
      ⊢ ∀f g k. (∀x. x ∈ k ⇒ f x = g x) ∧ (f sums l) k ⇒ (g sums l) k
   
   [<a name="SUMS_FINITE_DIFF-val"><b>SUMS_FINITE_DIFF</b></a>]  Theorem
      
      ⊢ ∀f t s l.
          t ⊆ s ∧ FINITE t ∧ (f sums l) s ⇒ (f sums l − sum t f) (s DIFF t)
   
   [<a name="SUMS_FINITE_UNION-val"><b>SUMS_FINITE_UNION</b></a>]  Theorem
      
      ⊢ ∀f s t l.
          FINITE t ∧ (f sums l) s ⇒ (f sums l + sum (t DIFF s) f) (s ∪ t)
   
   [<a name="SUMS_IFF-val"><b>SUMS_IFF</b></a>]  Theorem
      
      ⊢ ∀f g k. (∀x. x ∈ k ⇒ f x = g x) ⇒ ((f sums l) k ⇔ (g sums l) k)
   
   [<a name="SUMS_INFSUM-val"><b>SUMS_INFSUM</b></a>]  Theorem
      
      ⊢ ∀f s. (f sums suminf s f) s ⇔ summable s f
   
   [<a name="SUMS_INTERVALS-val"><b>SUMS_INTERVALS</b></a>]  Theorem
      
      ⊢ (∀a b c d.
           interval [(a,b)] ≠ ∅ ∧ interval [(c,d)] ≠ ∅ ⇒
           {x + y | x ∈ interval [(a,b)] ∧ y ∈ interval [(c,d)]} =
           interval [(a + c,b + d)]) ∧
        ∀a b c d.
          interval (a,b) ≠ ∅ ∧ interval (c,d) ≠ ∅ ⇒
          {x + y | x ∈ interval (a,b) ∧ y ∈ interval (c,d)} =
          interval (a + c,b + d)
   
   [<a name="SUMS_LIM-val"><b>SUMS_LIM</b></a>]  Theorem
      
      ⊢ ∀f s.
          (f sums lim sequentially (λn. sum (s ∩ {0 .. n}) f)) s ⇔
          summable s f
   
   [<a name="SUMS_OFFSET-val"><b>SUMS_OFFSET</b></a>]  Theorem
      
      ⊢ ∀f l m n.
          (f sums l) (from m) ∧ 0 &lt; n ∧ m ≤ n ⇒
          (f sums l − sum {m .. n − 1} f) (from n)
   
   [<a name="SUMS_OFFSET_REV-val"><b>SUMS_OFFSET_REV</b></a>]  Theorem
      
      ⊢ ∀f l m n.
          (f sums l) (from m) ∧ 0 &lt; m ∧ n ≤ m ⇒
          (f sums l + sum {n .. m − 1} f) (from n)
   
   [<a name="SUMS_REINDEX-val"><b>SUMS_REINDEX</b></a>]  Theorem
      
      ⊢ ∀k a l n.
          ((λx. a (x + k)) sums l) (from n) ⇔ (a sums l) (from (n + k))
   
   [<a name="SUMS_REINDEX_GEN-val"><b>SUMS_REINDEX_GEN</b></a>]  Theorem
      
      ⊢ ∀k a l s.
          ((λx. a (x + k)) sums l) s ⇔ (a sums l) (IMAGE (λi. i + k) s)
   
   [<a name="SUMS_SUMMABLE-val"><b>SUMS_SUMMABLE</b></a>]  Theorem
      
      ⊢ ∀f l s. (f sums l) s ⇒ summable s f
   
   [<a name="SUM_DIFF_LEMMA-val"><b>SUM_DIFF_LEMMA</b></a>]  Theorem
      
      ⊢ ∀f k m n.
          m ≤ n ⇒
          sum (k ∩ {0 .. n}) f − sum (k ∩ {0 .. m}) f =
          sum (k ∩ {m + 1 .. n}) f
   
   [<a name="SUP_INSERT-val"><b>SUP_INSERT</b></a>]  Theorem
      
      ⊢ ∀x s.
          bounded s ⇒ sup (x INSERT s) = if s = ∅ then x else max x (sup s)
   
   [<a name="SURJECTIVE_IMAGE_EQ-val"><b>SURJECTIVE_IMAGE_EQ</b></a>]  Theorem
      
      ⊢ ∀s t.
          (∀y. y ∈ t ⇒ ∃x. f x = y) ∧ (∀x. f x ∈ t ⇔ x ∈ s) ⇒ IMAGE f s = t
   
   [<a name="SYMMETRIC_CLOSURE-val"><b>SYMMETRIC_CLOSURE</b></a>]  Theorem
      
      ⊢ ∀s. (∀x. x ∈ s ⇒ -x ∈ s) ⇒ ∀x. x ∈ closure s ⇒ -x ∈ closure s
   
   [<a name="SYMMETRIC_INTERIOR-val"><b>SYMMETRIC_INTERIOR</b></a>]  Theorem
      
      ⊢ ∀s. (∀x. x ∈ s ⇒ -x ∈ s) ⇒ ∀x. x ∈ interior s ⇒ -x ∈ interior s
   
   [<a name="SYMMETRIC_LINEAR_IMAGE-val"><b>SYMMETRIC_LINEAR_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s.
          (∀x. x ∈ s ⇒ -x ∈ s) ∧ linear f ⇒
          ∀x. x ∈ IMAGE f s ⇒ -x ∈ IMAGE f s
   
   [<a name="TENDSTO_LIM-val"><b>TENDSTO_LIM</b></a>]  Theorem
      
      ⊢ ∀net f l. ¬trivial_limit net ∧ (f ⟶ l) net ⇒ lim net f = l
   
   [<a name="TOPSPACE_EUCLIDEAN-val"><b>TOPSPACE_EUCLIDEAN</b></a>]  Theorem
      
      ⊢ topspace euclidean = 𝕌(:real)
   
   [<a name="TOPSPACE_EUCLIDEAN_SUBTOPOLOGY-val"><b>TOPSPACE_EUCLIDEAN_SUBTOPOLOGY</b></a>]  Theorem
      
      ⊢ ∀s. topspace (subtopology euclidean s) = s
   
   [<a name="TRANSITIVE_STEPWISE_LT-val"><b>TRANSITIVE_STEPWISE_LT</b></a>]  Theorem
      
      ⊢ ∀R. (∀x y z. R x y ∧ R y z ⇒ R x z) ∧ (∀n. R n (SUC n)) ⇒
            ∀m n. m &lt; n ⇒ R m n
   
   [<a name="TRANSITIVE_STEPWISE_LT_EQ-val"><b>TRANSITIVE_STEPWISE_LT_EQ</b></a>]  Theorem
      
      ⊢ ∀R. (∀x y z. R x y ∧ R y z ⇒ R x z) ⇒
            ((∀m n. m &lt; n ⇒ R m n) ⇔ ∀n. R n (SUC n))
   
   [<a name="TRANSLATION_DIFF-val"><b>TRANSLATION_DIFF</b></a>]  Theorem
      
      ⊢ ∀s t.
          IMAGE (λx. a + x) (s DIFF t) =
          IMAGE (λx. a + x) s DIFF IMAGE (λx. a + x) t
   
   [<a name="TRIVIAL_LIMIT_AT-val"><b>TRIVIAL_LIMIT_AT</b></a>]  Theorem
      
      ⊢ ∀a. ¬trivial_limit (at a)
   
   [<a name="TRIVIAL_LIMIT_AT_INFINITY-val"><b>TRIVIAL_LIMIT_AT_INFINITY</b></a>]  Theorem
      
      ⊢ ¬trivial_limit at_infinity
   
   [<a name="TRIVIAL_LIMIT_AT_NEGINFINITY-val"><b>TRIVIAL_LIMIT_AT_NEGINFINITY</b></a>]  Theorem
      
      ⊢ ¬trivial_limit at_neginfinity
   
   [<a name="TRIVIAL_LIMIT_AT_POSINFINITY-val"><b>TRIVIAL_LIMIT_AT_POSINFINITY</b></a>]  Theorem
      
      ⊢ ¬trivial_limit at_posinfinity
   
   [<a name="TRIVIAL_LIMIT_SEQUENTIALLY-val"><b>TRIVIAL_LIMIT_SEQUENTIALLY</b></a>]  Theorem
      
      ⊢ ¬trivial_limit sequentially
   
   [<a name="TRIVIAL_LIMIT_WITHIN-val"><b>TRIVIAL_LIMIT_WITHIN</b></a>]  Theorem
      
      ⊢ ∀a. trivial_limit (at a within s) ⇔ ¬(a limit_point_of s)
   
   [<a name="UNBOUNDED_HALFSPACE_COMPONENT_GE-val"><b>UNBOUNDED_HALFSPACE_COMPONENT_GE</b></a>]  Theorem
      
      ⊢ ∀a. ¬bounded {x | x ≥ a}
   
   [<a name="UNBOUNDED_HALFSPACE_COMPONENT_GT-val"><b>UNBOUNDED_HALFSPACE_COMPONENT_GT</b></a>]  Theorem
      
      ⊢ ∀a. ¬bounded {x | x &gt; a}
   
   [<a name="UNBOUNDED_HALFSPACE_COMPONENT_LE-val"><b>UNBOUNDED_HALFSPACE_COMPONENT_LE</b></a>]  Theorem
      
      ⊢ ∀a. ¬bounded {x | x ≤ a}
   
   [<a name="UNBOUNDED_HALFSPACE_COMPONENT_LT-val"><b>UNBOUNDED_HALFSPACE_COMPONENT_LT</b></a>]  Theorem
      
      ⊢ ∀a. ¬bounded {x | x &lt; a}
   
   [<a name="UNBOUNDED_INTER_COBOUNDED-val"><b>UNBOUNDED_INTER_COBOUNDED</b></a>]  Theorem
      
      ⊢ ∀s t. ¬bounded s ∧ bounded (𝕌(:real) DIFF t) ⇒ s ∩ t ≠ ∅
   
   [<a name="UNCOUNTABLE_EUCLIDEAN-val"><b>UNCOUNTABLE_EUCLIDEAN</b></a>]  Theorem
      
      ⊢ uncountable 𝕌(:real)
   
   [<a name="UNCOUNTABLE_INTERVAL-val"><b>UNCOUNTABLE_INTERVAL</b></a>]  Theorem
      
      ⊢ (∀a b. interval (a,b) ≠ ∅ ⇒ uncountable (interval [(a,b)])) ∧
        ∀a b. interval (a,b) ≠ ∅ ⇒ uncountable (interval (a,b))
   
   [<a name="UNCOUNTABLE_OPEN-val"><b>UNCOUNTABLE_OPEN</b></a>]  Theorem
      
      ⊢ ∀s. open s ∧ s ≠ ∅ ⇒ uncountable s
   
   [<a name="UNCOUNTABLE_REAL-val"><b>UNCOUNTABLE_REAL</b></a>]  Theorem
      
      ⊢ uncountable 𝕌(:real)
   
   [<a name="UNIFORMLY_CAUCHY_IMP_UNIFORMLY_CONVERGENT-val"><b>UNIFORMLY_CAUCHY_IMP_UNIFORMLY_CONVERGENT</b></a>]  Theorem
      
      ⊢ ∀P s l.
          (∀e. 0 &lt; e ⇒
               ∃N. ∀m n x. N ≤ m ∧ N ≤ n ∧ P x ⇒ dist (s m x,s n x) &lt; e) ∧
          (∀x. P x ⇒ ∀e. 0 &lt; e ⇒ ∃N. ∀n. N ≤ n ⇒ dist (s n x,l x) &lt; e) ⇒
          ∀e. 0 &lt; e ⇒ ∃N. ∀n x. N ≤ n ∧ P x ⇒ dist (s n x,l x) &lt; e
   
   [<a name="UNIFORMLY_CONTINUOUS_EXTENDS_TO_CLOSURE-val"><b>UNIFORMLY_CONTINUOUS_EXTENDS_TO_CLOSURE</b></a>]  Theorem
      
      ⊢ ∀f s.
          f uniformly_continuous_on s ⇒
          ∃g. g uniformly_continuous_on closure s ∧
              (∀x. x ∈ s ⇒ g x = f x) ∧
              ∀h. h continuous_on closure s ∧ (∀x. x ∈ s ⇒ h x = f x) ⇒
                  ∀x. x ∈ closure s ⇒ h x = g x
   
   [<a name="UNIFORMLY_CONTINUOUS_IMP_CAUCHY_CONTINUOUS-val"><b>UNIFORMLY_CONTINUOUS_IMP_CAUCHY_CONTINUOUS</b></a>]  Theorem
      
      ⊢ ∀f s.
          f uniformly_continuous_on s ⇒
          ∀x. cauchy x ∧ (∀n. x n ∈ s) ⇒ cauchy (f ∘ x)
   
   [<a name="UNIFORMLY_CONTINUOUS_IMP_CONTINUOUS-val"><b>UNIFORMLY_CONTINUOUS_IMP_CONTINUOUS</b></a>]  Theorem
      
      ⊢ ∀f s. f uniformly_continuous_on s ⇒ f continuous_on s
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_ADD-val"><b>UNIFORMLY_CONTINUOUS_ON_ADD</b></a>]  Theorem
      
      ⊢ ∀f g s.
          f uniformly_continuous_on s ∧ g uniformly_continuous_on s ⇒
          (λx. f x + g x) uniformly_continuous_on s
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_CLOSURE-val"><b>UNIFORMLY_CONTINUOUS_ON_CLOSURE</b></a>]  Theorem
      
      ⊢ ∀f s.
          f uniformly_continuous_on s ∧ f continuous_on closure s ⇒
          f uniformly_continuous_on closure s
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_CMUL-val"><b>UNIFORMLY_CONTINUOUS_ON_CMUL</b></a>]  Theorem
      
      ⊢ ∀f c s.
          f uniformly_continuous_on s ⇒
          (λx. c * f x) uniformly_continuous_on s
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_COMPOSE-val"><b>UNIFORMLY_CONTINUOUS_ON_COMPOSE</b></a>]  Theorem
      
      ⊢ ∀f g s.
          f uniformly_continuous_on s ∧ g uniformly_continuous_on IMAGE f s ⇒
          g ∘ f uniformly_continuous_on s
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_CONST-val"><b>UNIFORMLY_CONTINUOUS_ON_CONST</b></a>]  Theorem
      
      ⊢ ∀s c. (λx. c) uniformly_continuous_on s
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_DIST_CLOSEST_POINT-val"><b>UNIFORMLY_CONTINUOUS_ON_DIST_CLOSEST_POINT</b></a>]  Theorem
      
      ⊢ ∀s t.
          closed s ∧ s ≠ ∅ ⇒
          (λx. dist (x,closest_point s x)) uniformly_continuous_on t
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_EQ-val"><b>UNIFORMLY_CONTINUOUS_ON_EQ</b></a>]  Theorem
      
      ⊢ ∀f g s.
          (∀x. x ∈ s ⇒ f x = g x) ∧ f uniformly_continuous_on s ⇒
          g uniformly_continuous_on s
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_ID-val"><b>UNIFORMLY_CONTINUOUS_ON_ID</b></a>]  Theorem
      
      ⊢ ∀s. (λx. x) uniformly_continuous_on s
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_MUL-val"><b>UNIFORMLY_CONTINUOUS_ON_MUL</b></a>]  Theorem
      
      ⊢ ∀f g s.
          f uniformly_continuous_on s ∧ g uniformly_continuous_on s ∧
          bounded (IMAGE f s) ∧ bounded (IMAGE g s) ⇒
          (λx. f x * g x) uniformly_continuous_on s
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_NEG-val"><b>UNIFORMLY_CONTINUOUS_ON_NEG</b></a>]  Theorem
      
      ⊢ ∀f s.
          f uniformly_continuous_on s ⇒
          (λx. -f x) uniformly_continuous_on s
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_SEQUENTIALLY-val"><b>UNIFORMLY_CONTINUOUS_ON_SEQUENTIALLY</b></a>]  Theorem
      
      ⊢ ∀f s.
          f uniformly_continuous_on s ⇔
          ∀x y.
            (∀n. x n ∈ s) ∧ (∀n. y n ∈ s) ∧
            ((λn. x n − y n) ⟶ 0) sequentially ⇒
            ((λn. f (x n) − f (y n)) ⟶ 0) sequentially
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_SETDIST-val"><b>UNIFORMLY_CONTINUOUS_ON_SETDIST</b></a>]  Theorem
      
      ⊢ ∀s t. (λy. setdist ({y},s)) uniformly_continuous_on t
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_SUB-val"><b>UNIFORMLY_CONTINUOUS_ON_SUB</b></a>]  Theorem
      
      ⊢ ∀f g s.
          f uniformly_continuous_on s ∧ g uniformly_continuous_on s ⇒
          (λx. f x − g x) uniformly_continuous_on s
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_SUBSET-val"><b>UNIFORMLY_CONTINUOUS_ON_SUBSET</b></a>]  Theorem
      
      ⊢ ∀f s t.
          f uniformly_continuous_on s ∧ t ⊆ s ⇒ f uniformly_continuous_on t
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_SUM-val"><b>UNIFORMLY_CONTINUOUS_ON_SUM</b></a>]  Theorem
      
      ⊢ ∀t f s.
          FINITE s ∧ (∀a. a ∈ s ⇒ f a uniformly_continuous_on t) ⇒
          (λx. sum s (λa. f a x)) uniformly_continuous_on t
   
   [<a name="UNIFORMLY_CONTINUOUS_ON_VMUL-val"><b>UNIFORMLY_CONTINUOUS_ON_VMUL</b></a>]  Theorem
      
      ⊢ ∀s c v.
          c uniformly_continuous_on s ⇒
          (λx. c x * v) uniformly_continuous_on s
   
   [<a name="UNIFORMLY_CONVERGENT_EQ_CAUCHY-val"><b>UNIFORMLY_CONVERGENT_EQ_CAUCHY</b></a>]  Theorem
      
      ⊢ ∀P s.
          (∃l. ∀e. 0 &lt; e ⇒ ∃N. ∀n x. N ≤ n ∧ P x ⇒ dist (s n x,l x) &lt; e) ⇔
          ∀e. 0 &lt; e ⇒
              ∃N. ∀m n x. N ≤ m ∧ N ≤ n ∧ P x ⇒ dist (s m x,s n x) &lt; e
   
   [<a name="UNIFORMLY_CONVERGENT_EQ_CAUCHY_ALT-val"><b>UNIFORMLY_CONVERGENT_EQ_CAUCHY_ALT</b></a>]  Theorem
      
      ⊢ ∀P s.
          (∃l. ∀e. 0 &lt; e ⇒ ∃N. ∀n x. N ≤ n ∧ P x ⇒ dist (s n x,l x) &lt; e) ⇔
          ∀e. 0 &lt; e ⇒
              ∃N. ∀m n x.
                N ≤ m ∧ N ≤ n ∧ m &lt; n ∧ P x ⇒ dist (s m x,s n x) &lt; e
   
   [<a name="UNIFORM_LIM_ADD-val"><b>UNIFORM_LIM_ADD</b></a>]  Theorem
      
      ⊢ ∀net P f g l m.
          (∀e. 0 &lt; e ⇒ eventually (λx. ∀n. P n ⇒ abs (f n x − l n) &lt; e) net) ∧
          (∀e. 0 &lt; e ⇒ eventually (λx. ∀n. P n ⇒ abs (g n x − m n) &lt; e) net) ⇒
          ∀e. 0 &lt; e ⇒
              eventually
                (λx. ∀n. P n ⇒ abs (f n x + g n x − (l n + m n)) &lt; e) net
   
   [<a name="UNIFORM_LIM_BILINEAR-val"><b>UNIFORM_LIM_BILINEAR</b></a>]  Theorem
      
      ⊢ ∀net P h f g l m b1 b2.
          bilinear h ∧ eventually (λx. ∀n. P n ⇒ abs (l n) ≤ b1) net ∧
          eventually (λx. ∀n. P n ⇒ abs (m n) ≤ b2) net ∧
          (∀e. 0 &lt; e ⇒ eventually (λx. ∀n. P n ⇒ abs (f n x − l n) &lt; e) net) ∧
          (∀e. 0 &lt; e ⇒ eventually (λx. ∀n. P n ⇒ abs (g n x − m n) &lt; e) net) ⇒
          ∀e. 0 &lt; e ⇒
              eventually
                (λx. ∀n. P n ⇒ abs (h (f n x) (g n x) − h (l n) (m n)) &lt; e)
                net
   
   [<a name="UNIFORM_LIM_SUB-val"><b>UNIFORM_LIM_SUB</b></a>]  Theorem
      
      ⊢ ∀net P f g l m.
          (∀e. 0 &lt; e ⇒ eventually (λx. ∀n. P n ⇒ abs (f n x − l n) &lt; e) net) ∧
          (∀e. 0 &lt; e ⇒ eventually (λx. ∀n. P n ⇒ abs (g n x − m n) &lt; e) net) ⇒
          ∀e. 0 &lt; e ⇒
              eventually
                (λx. ∀n. P n ⇒ abs (f n x − g n x − (l n − m n)) &lt; e) net
   
   [<a name="UNION_FRONTIER-val"><b>UNION_FRONTIER</b></a>]  Theorem
      
      ⊢ ∀s t.
          frontier s ∪ frontier t =
          frontier (s ∪ t) ∪ frontier (s ∩ t) ∪ frontier s ∩ frontier t
   
   [<a name="UNION_INTERIOR_SUBSET-val"><b>UNION_INTERIOR_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t. interior s ∪ interior t ⊆ interior (s ∪ t)
   
   [<a name="UNIT_INTERVAL_NONEMPTY-val"><b>UNIT_INTERVAL_NONEMPTY</b></a>]  Theorem
      
      ⊢ interval [(0,1)] ≠ ∅ ∧ interval (0,1) ≠ ∅
   
   [<a name="UPPER_HEMICONTINUOUS-val"><b>UPPER_HEMICONTINUOUS</b></a>]  Theorem
      
      ⊢ ∀f t s.
          (∀x. x ∈ s ⇒ f x ⊆ t) ⇒
          ((∀u. open_in (subtopology euclidean t) u ⇒
                open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ⊆ u}) ⇔
           ∀u. closed_in (subtopology euclidean t) u ⇒
               closed_in (subtopology euclidean s)
                 {x | x ∈ s ∧ f x ∩ u ≠ ∅})
   
   [<a name="UPPER_LOWER_HEMICONTINUOUS-val"><b>UPPER_LOWER_HEMICONTINUOUS</b></a>]  Theorem
      
      ⊢ ∀f t s.
          (∀x. x ∈ s ⇒ f x ⊆ t) ∧
          (∀u. open_in (subtopology euclidean t) u ⇒
               open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ⊆ u}) ∧
          (∀u. closed_in (subtopology euclidean t) u ⇒
               closed_in (subtopology euclidean s) {x | x ∈ s ∧ f x ⊆ u}) ⇒
          ∀x e.
            x ∈ s ∧ 0 &lt; e ∧ bounded (f x) ⇒
            ∃d. 0 &lt; d ∧
                ∀x'. x' ∈ s ∧ dist (x,x') &lt; d ⇒ hausdist (f x,f x') &lt; e
   
   [<a name="UPPER_LOWER_HEMICONTINUOUS_EXPLICIT-val"><b>UPPER_LOWER_HEMICONTINUOUS_EXPLICIT</b></a>]  Theorem
      
      ⊢ ∀f t s.
          (∀x. x ∈ s ⇒ f x ⊆ t) ∧
          (∀u. open_in (subtopology euclidean t) u ⇒
               open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ⊆ u}) ∧
          (∀u. closed_in (subtopology euclidean t) u ⇒
               closed_in (subtopology euclidean s) {x | x ∈ s ∧ f x ⊆ u}) ⇒
          ∀x e.
            x ∈ s ∧ 0 &lt; e ∧ bounded (f x) ∧ f x ≠ ∅ ⇒
            ∃d. 0 &lt; d ∧
                ∀x'.
                  x' ∈ s ∧ dist (x,x') &lt; d ⇒
                  (∀y. y ∈ f x ⇒ ∃y'. y' ∈ f x' ∧ dist (y,y') &lt; e) ∧
                  ∀y'. y' ∈ f x' ⇒ ∃y. y ∈ f x ∧ dist (y',y) &lt; e
   
   [<a name="URYSOHN-val"><b>URYSOHN</b></a>]  Theorem
      
      ⊢ ∀s t a b.
          closed s ∧ closed t ∧ s ∩ t = ∅ ⇒
          ∃f. f continuous_on 𝕌(:real) ∧ (∀x. f x ∈ segment [(a,b)]) ∧
              (∀x. x ∈ s ⇒ f x = a) ∧ ∀x. x ∈ t ⇒ f x = b
   
   [<a name="URYSOHN_LOCAL-val"><b>URYSOHN_LOCAL</b></a>]  Theorem
      
      ⊢ ∀s t u a b.
          closed_in (subtopology euclidean u) s ∧
          closed_in (subtopology euclidean u) t ∧ s ∩ t = ∅ ⇒
          ∃f. f continuous_on u ∧ (∀x. x ∈ u ⇒ f x ∈ segment [(a,b)]) ∧
              (∀x. x ∈ s ⇒ f x = a) ∧ ∀x. x ∈ t ⇒ f x = b
   
   [<a name="URYSOHN_LOCAL_STRONG-val"><b>URYSOHN_LOCAL_STRONG</b></a>]  Theorem
      
      ⊢ ∀s t u a b.
          closed_in (subtopology euclidean u) s ∧
          closed_in (subtopology euclidean u) t ∧ s ∩ t = ∅ ∧ a ≠ b ⇒
          ∃f. f continuous_on u ∧ (∀x. x ∈ u ⇒ f x ∈ segment [(a,b)]) ∧
              (∀x. x ∈ u ⇒ (f x = a ⇔ x ∈ s)) ∧
              ∀x. x ∈ u ⇒ (f x = b ⇔ x ∈ t)
   
   [<a name="URYSOHN_STRONG-val"><b>URYSOHN_STRONG</b></a>]  Theorem
      
      ⊢ ∀s t a b.
          closed s ∧ closed t ∧ s ∩ t = ∅ ∧ a ≠ b ⇒
          ∃f. f continuous_on 𝕌(:real) ∧ (∀x. f x ∈ segment [(a,b)]) ∧
              (∀x. f x = a ⇔ x ∈ s) ∧ ∀x. f x = b ⇔ x ∈ t
   
   [<a name="WITHIN-val"><b>WITHIN</b></a>]  Theorem
      
      ⊢ ∀n s x y. netord (n within s) x y ⇔ netord n x y ∧ x ∈ s
   
   [<a name="WITHIN_UNIV-val"><b>WITHIN_UNIV</b></a>]  Theorem
      
      ⊢ ∀x. (at x within 𝕌(:real)) = at x
   
   [<a name="WITHIN_WITHIN-val"><b>WITHIN_WITHIN</b></a>]  Theorem
      
      ⊢ ∀net s t. ((net within s) within t) = (net within s ∩ t)
   
   [<a name="at-val"><b>at</b></a>]  Theorem
      
      ⊢ ∀a. at a = mk_net (λx y. 0 &lt; dist (x,a) ∧ dist (x,a) ≤ dist (y,a))
   
   [<a name="ball-val"><b>ball</b></a>]  Theorem
      
      ⊢ ∀x e. ball (x,e) = {y | dist (x,y) &lt; e}
   
   [<a name="closed_def-val"><b>closed_def</b></a>]  Theorem
      
      ⊢ ∀s. closed s ⇔ open (𝕌(:real) DIFF s)
   
   [<a name="continuous_at-val"><b>continuous_at</b></a>]  Theorem
      
      ⊢ f continuous at x ⇔
        ∀e. 0 &lt; e ⇒ ∃d. 0 &lt; d ∧ ∀x'. dist (x',x) &lt; d ⇒ dist (f x',f x) &lt; e
   
   [<a name="continuous_within-val"><b>continuous_within</b></a>]  Theorem
      
      ⊢ f continuous (at x within s) ⇔
        ∀e. 0 &lt; e ⇒
            ∃d. 0 &lt; d ∧ ∀x'. x' ∈ s ∧ dist (x',x) &lt; d ⇒ dist (f x',f x) &lt; e
   
   [<a name="diameter-val"><b>diameter</b></a>]  Theorem
      
      ⊢ ∀s. diameter s =
            if s = ∅ then 0 else sup {abs (x − y) | x ∈ s ∧ y ∈ s}
   
   [<a name="dist-val"><b>dist</b></a>]  Theorem
      
      ⊢ ∀x y. dist (x,y) = abs (x − y)
   
   [<a name="euclidean-val"><b>euclidean</b></a>]  Theorem
      
      ⊢ euclidean = topology open
   
   [<a name="fsigma-val"><b>fsigma</b></a>]  Theorem
      
      ⊢ ∀s. fsigma s ⇔
            ∃g. countable g ∧ (∀c. c ∈ g ⇒ closed c) ∧ BIGUNION g = s
   
   [<a name="gdelta-val"><b>gdelta</b></a>]  Theorem
      
      ⊢ ∀s. gdelta s ⇔
            ∃g. countable g ∧ (∀u. u ∈ g ⇒ open u) ∧ BIGINTER g = s
   
   [<a name="interval-val"><b>interval</b></a>]  Theorem
      
      ⊢ interval (a,b) = {x | a &lt; x ∧ x &lt; b} ∧
        interval [(a,b)] = {x | a ≤ x ∧ x ≤ b}
   
   [<a name="limit_point_of-val"><b>limit_point_of</b></a>]  Theorem
      
      ⊢ ∀x s.
          x limit_point_of s ⇔
          ∀t. x ∈ t ∧ open t ⇒ ∃y. y ≠ x ∧ y ∈ s ∧ y ∈ t
   
   [<a name="linear_alt_cmul-val"><b>linear_alt_cmul</b></a>]  Theorem
      
      ⊢ ∀f. linear f ⇔ ∀c x. f (c * x) = c * f x
   
   [<a name="linear_repr-val"><b>linear_repr</b></a>]  Theorem
      
      ⊢ ∀f. linear f ⇔ ∃l. f = (λx. l * x)
   
   [<a name="net_tybij-val"><b>net_tybij</b></a>]  Theorem
      
      ⊢ (∀a. mk_net (netord a) = a) ∧
        ∀r. (∀x y. (∀z. r z x ⇒ r z y) ∨ ∀z. r z y ⇒ r z x) ⇔
            netord (mk_net r) = r
   
   [<a name="open_def-val"><b>open_def</b></a>]  Theorem
      
      ⊢ ∀s. open s ⇔ ∀x. x ∈ s ⇒ ∃e. 0 &lt; e ∧ ∀x'. dist (x',x) &lt; e ⇒ x' ∈ s
   
   [<a name="open_in-val"><b>open_in</b></a>]  Theorem
      
      ⊢ ∀u s.
          open_in (subtopology euclidean u) s ⇔
          s ⊆ u ∧
          ∀x. x ∈ s ⇒ ∃e. 0 &lt; e ∧ ∀x'. x' ∈ u ∧ dist (x',x) &lt; e ⇒ x' ∈ s
   
   [<a name="segment-val"><b>segment</b></a>]  Theorem
      
      ⊢ segment [(a,b)] = {(1 − u) * a + u * b | 0 ≤ u ∧ u ≤ 1} ∧
        segment (a,b) = segment [(a,b)] DIFF {a; b}
   
   [<a name="setdist-val"><b>setdist</b></a>]  Theorem
      
      ⊢ ∀s t.
          setdist (s,t) =
          if s = ∅ ∨ t = ∅ then 0 else inf {dist (x,y) | x ∈ s ∧ y ∈ t}
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/real/analysis/real_topologyScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-1</a></em></p></body></html>
