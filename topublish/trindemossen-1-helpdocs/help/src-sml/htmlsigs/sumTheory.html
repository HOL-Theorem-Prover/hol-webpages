<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure sumTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure sumTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/coretypes/sumScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature sumTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#INL_DEF-val">INL_DEF</a> : thm
<a name="line7"></a>    val <a href="#INR_DEF-val">INR_DEF</a> : thm
<a name="line8"></a>    val <a href="#ISL-val">ISL</a> : thm
<a name="line9"></a>    val <a href="#ISR-val">ISR</a> : thm
<a name="line10"></a>    val <a href="#IS_SUM_REP-val">IS_SUM_REP</a> : thm
<a name="line11"></a>    val <a href="#OUTL-val">OUTL</a> : thm
<a name="line12"></a>    val <a href="#OUTR-val">OUTR</a> : thm
<a name="line13"></a>    val <a href="#SUM_ALL_def-val">SUM_ALL_def</a> : thm
<a name="line14"></a>    val <a href="#SUM_FIN_def-val">SUM_FIN_def</a> : thm
<a name="line15"></a>    val <a href="#SUM_MAP_def-val">SUM_MAP_def</a> : thm
<a name="line16"></a>    val <a href="#SUM_REL_def-val">SUM_REL_def</a> : thm
<a name="line17"></a>    val <a href="#SUM_SET_def-val">SUM_SET_def</a> : thm
<a name="line18"></a>    val <a href="#sum_ISO_DEF-val">sum_ISO_DEF</a> : thm
<a name="line19"></a>    val <a href="#sum_TY_DEF-val">sum_TY_DEF</a> : thm
<a name="line20"></a>    val <a href="#sum_case_def-val">sum_case_def</a> : thm
<a name="line21"></a>  
<a name="line22"></a>  (*  Theorems  *)
<a name="line23"></a>    val <a href="#EXISTS_SUM-val">EXISTS_SUM</a> : thm
<a name="line24"></a>    val <a href="#FORALL_SUM-val">FORALL_SUM</a> : thm
<a name="line25"></a>    val <a href="#INL-val">INL</a> : thm
<a name="line26"></a>    val <a href="#INL_11-val">INL_11</a> : thm
<a name="line27"></a>    val <a href="#INL_PRS-val">INL_PRS</a> : thm
<a name="line28"></a>    val <a href="#INL_RSP-val">INL_RSP</a> : thm
<a name="line29"></a>    val <a href="#INR-val">INR</a> : thm
<a name="line30"></a>    val <a href="#INR_11-val">INR_11</a> : thm
<a name="line31"></a>    val <a href="#INR_INL_11-val">INR_INL_11</a> : thm
<a name="line32"></a>    val <a href="#INR_PRS-val">INR_PRS</a> : thm
<a name="line33"></a>    val <a href="#INR_RSP-val">INR_RSP</a> : thm
<a name="line34"></a>    val <a href="#INR_neq_INL-val">INR_neq_INL</a> : thm
<a name="line35"></a>    val <a href="#IN_SUM_FIN_THM-val">IN_SUM_FIN_THM</a> : thm
<a name="line36"></a>    val <a href="#ISL_OR_ISR-val">ISL_OR_ISR</a> : thm
<a name="line37"></a>    val <a href="#ISL_PRS-val">ISL_PRS</a> : thm
<a name="line38"></a>    val <a href="#ISL_RSP-val">ISL_RSP</a> : thm
<a name="line39"></a>    val <a href="#ISR_PRS-val">ISR_PRS</a> : thm
<a name="line40"></a>    val <a href="#ISR_RSP-val">ISR_RSP</a> : thm
<a name="line41"></a>    val <a href="#NOT_ISL_ISR-val">NOT_ISL_ISR</a> : thm
<a name="line42"></a>    val <a href="#NOT_ISR_ISL-val">NOT_ISR_ISL</a> : thm
<a name="line43"></a>    val <a href="#SUM_ALL_CONG-val">SUM_ALL_CONG</a> : thm
<a name="line44"></a>    val <a href="#SUM_ALL_MONO-val">SUM_ALL_MONO</a> : thm
<a name="line45"></a>    val <a href="#SUM_ALL_SET-val">SUM_ALL_SET</a> : thm
<a name="line46"></a>    val <a href="#SUM_EQUIV-val">SUM_EQUIV</a> : thm
<a name="line47"></a>    val <a href="#SUM_MAP-val">SUM_MAP</a> : thm
<a name="line48"></a>    val <a href="#SUM_MAP_CASE-val">SUM_MAP_CASE</a> : thm
<a name="line49"></a>    val <a href="#SUM_MAP_CONG-val">SUM_MAP_CONG</a> : thm
<a name="line50"></a>    val <a href="#SUM_MAP_I-val">SUM_MAP_I</a> : thm
<a name="line51"></a>    val <a href="#SUM_MAP_PRS-val">SUM_MAP_PRS</a> : thm
<a name="line52"></a>    val <a href="#SUM_MAP_RSP-val">SUM_MAP_RSP</a> : thm
<a name="line53"></a>    val <a href="#SUM_MAP_SET-val">SUM_MAP_SET</a> : thm
<a name="line54"></a>    val <a href="#SUM_MAP_o-val">SUM_MAP_o</a> : thm
<a name="line55"></a>    val <a href="#SUM_QUOTIENT-val">SUM_QUOTIENT</a> : thm
<a name="line56"></a>    val <a href="#SUM_REL_EQ-val">SUM_REL_EQ</a> : thm
<a name="line57"></a>    val <a href="#SUM_REL_REFL-val">SUM_REL_REFL</a> : thm
<a name="line58"></a>    val <a href="#SUM_REL_SYM-val">SUM_REL_SYM</a> : thm
<a name="line59"></a>    val <a href="#SUM_REL_THM-val">SUM_REL_THM</a> : thm
<a name="line60"></a>    val <a href="#SUM_REL_TRANS-val">SUM_REL_TRANS</a> : thm
<a name="line61"></a>    val <a href="#SUM_SETLR_THM-val">SUM_SETLR_THM</a> : thm
<a name="line62"></a>    val <a href="#cond_sum_expand-val">cond_sum_expand</a> : thm
<a name="line63"></a>    val <a href="#datatype_sum-val">datatype_sum</a> : thm
<a name="line64"></a>    val <a href="#sum_Axiom-val">sum_Axiom</a> : thm
<a name="line65"></a>    val <a href="#sum_CASES-val">sum_CASES</a> : thm
<a name="line66"></a>    val <a href="#sum_INDUCT-val">sum_INDUCT</a> : thm
<a name="line67"></a>    val <a href="#sum_axiom-val">sum_axiom</a> : thm
<a name="line68"></a>    val <a href="#sum_case_cong-val">sum_case_cong</a> : thm
<a name="line69"></a>    val <a href="#sum_distinct-val">sum_distinct</a> : thm
<a name="line70"></a>    val <a href="#sum_distinct1-val">sum_distinct1</a> : thm
<a name="line71"></a>  
<a name="line72"></a>  val sum_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line73"></a>(*
   [pair] Parent theory of "sum"
   
   [<a name="INL_DEF-val"><b>INL_DEF</b></a>]  Definition
      
      ⊢ ∀e. INL e = ABS_sum (λb x y. x = e ∧ b)
   
   [<a name="INR_DEF-val"><b>INR_DEF</b></a>]  Definition
      
      ⊢ ∀e. INR e = ABS_sum (λb x y. y = e ∧ ¬b)
   
   [<a name="ISL-val"><b>ISL</b></a>]  Definition
      
      ⊢ (∀x. ISL (INL x) ⇔ T) ∧ ∀y. ISL (INR y) ⇔ F
   
   [<a name="ISR-val"><b>ISR</b></a>]  Definition
      
      ⊢ (∀x. ISR (INR x) ⇔ T) ∧ ∀y. ISR (INL y) ⇔ F
   
   [<a name="IS_SUM_REP-val"><b>IS_SUM_REP</b></a>]  Definition
      
      ⊢ ∀f. IS_SUM_REP f ⇔
            ∃v1 v2. f = (λb x y. x = v1 ∧ b) ∨ f = (λb x y. y = v2 ∧ ¬b)
   
   [<a name="OUTL-val"><b>OUTL</b></a>]  Definition
      
      ⊢ ∀x. OUTL (INL x) = x
   
   [<a name="OUTR-val"><b>OUTR</b></a>]  Definition
      
      ⊢ ∀x. OUTR (INR x) = x
   
   [<a name="SUM_ALL_def-val"><b>SUM_ALL_def</b></a>]  Definition
      
      ⊢ (∀P Q x. SUM_ALL P Q (INL x) ⇔ P x) ∧
        ∀P Q y. SUM_ALL P Q (INR y) ⇔ Q y
   
   [<a name="SUM_FIN_def-val"><b>SUM_FIN_def</b></a>]  Definition
      
      ⊢ ∀A B.
          SUM_FIN A B = (λab. case ab of INL a =&gt; a ∈ A | INR b =&gt; b ∈ B)
   
   [<a name="SUM_MAP_def-val"><b>SUM_MAP_def</b></a>]  Definition
      
      ⊢ (∀f g a. SUM_MAP f g (INL a) = INL (f a)) ∧
        ∀f g b. SUM_MAP f g (INR b) = INR (g b)
   
   [<a name="SUM_REL_def-val"><b>SUM_REL_def</b></a>]  Definition
      
      ⊢ (∀R1 R2 x ab. (R1 +++ R2) (INL x) ab ⇔ ISL ab ∧ R1 x (OUTL ab)) ∧
        ∀R1 R2 y ab. (R1 +++ R2) (INR y) ab ⇔ ISR ab ∧ R2 y (OUTR ab)
   
   [<a name="SUM_SET_def-val"><b>SUM_SET_def</b></a>]  Definition
      
      ⊢ (∀f1 f2 a. sum$SUM_SET f1 f2 (INL a) = f1 a) ∧
        ∀f1 f2 b. sum$SUM_SET f1 f2 (INR b) = f2 b
   
   [<a name="sum_ISO_DEF-val"><b>sum_ISO_DEF</b></a>]  Definition
      
      ⊢ (∀a. ABS_sum (REP_sum a) = a) ∧
        ∀r. IS_SUM_REP r ⇔ REP_sum (ABS_sum r) = r
   
   [<a name="sum_TY_DEF-val"><b>sum_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep. TYPE_DEFINITION IS_SUM_REP rep
   
   [<a name="sum_case_def-val"><b>sum_case_def</b></a>]  Definition
      
      ⊢ (∀x f f1. sum_CASE (INL x) f f1 = f x) ∧
        ∀y f f1. sum_CASE (INR y) f f1 = f1 y
   
   [<a name="EXISTS_SUM-val"><b>EXISTS_SUM</b></a>]  Theorem
      
      ⊢ ∀P. (∃s. P s) ⇔ (∃x. P (INL x)) ∨ ∃y. P (INR y)
   
   [<a name="FORALL_SUM-val"><b>FORALL_SUM</b></a>]  Theorem
      
      ⊢ (∀s. P s) ⇔ (∀x. P (INL x)) ∧ ∀y. P (INR y)
   
   [<a name="INL-val"><b>INL</b></a>]  Theorem
      
      ⊢ ∀x. ISL x ⇒ INL (OUTL x) = x
   
   [<a name="INL_11-val"><b>INL_11</b></a>]  Theorem
      
      ⊢ INL x = INL y ⇔ x = y
   
   [<a name="INL_PRS-val"><b>INL_PRS</b></a>]  Theorem
      
      ⊢ ∀R1 abs1 rep1.
          QUOTIENT R1 abs1 rep1 ⇒
          ∀R2 abs2 rep2.
            QUOTIENT R2 abs2 rep2 ⇒
            ∀a. INL a = SUM_MAP abs1 abs2 (INL (rep1 a))
   
   [<a name="INL_RSP-val"><b>INL_RSP</b></a>]  Theorem
      
      ⊢ ∀R1 abs1 rep1.
          QUOTIENT R1 abs1 rep1 ⇒
          ∀R2 abs2 rep2.
            QUOTIENT R2 abs2 rep2 ⇒
            ∀a1 a2. R1 a1 a2 ⇒ (R1 +++ R2) (INL a1) (INL a2)
   
   [<a name="INR-val"><b>INR</b></a>]  Theorem
      
      ⊢ ∀x. ISR x ⇒ INR (OUTR x) = x
   
   [<a name="INR_11-val"><b>INR_11</b></a>]  Theorem
      
      ⊢ INR x = INR y ⇔ x = y
   
   [<a name="INR_INL_11-val"><b>INR_INL_11</b></a>]  Theorem
      
      ⊢ (∀y x. INL x = INL y ⇔ x = y) ∧ ∀y x. INR x = INR y ⇔ x = y
   
   [<a name="INR_PRS-val"><b>INR_PRS</b></a>]  Theorem
      
      ⊢ ∀R1 abs1 rep1.
          QUOTIENT R1 abs1 rep1 ⇒
          ∀R2 abs2 rep2.
            QUOTIENT R2 abs2 rep2 ⇒
            ∀b. INR b = SUM_MAP abs1 abs2 (INR (rep2 b))
   
   [<a name="INR_RSP-val"><b>INR_RSP</b></a>]  Theorem
      
      ⊢ ∀R1 abs1 rep1.
          QUOTIENT R1 abs1 rep1 ⇒
          ∀R2 abs2 rep2.
            QUOTIENT R2 abs2 rep2 ⇒
            ∀b1 b2. R2 b1 b2 ⇒ (R1 +++ R2) (INR b1) (INR b2)
   
   [<a name="INR_neq_INL-val"><b>INR_neq_INL</b></a>]  Theorem
      
      ⊢ ∀v1 v2. INR v2 ≠ INL v1
   
   [<a name="IN_SUM_FIN_THM-val"><b>IN_SUM_FIN_THM</b></a>]  Theorem
      
      ⊢ (INL a ∈ SUM_FIN A B ⇔ a ∈ A) ∧ (INR b ∈ SUM_FIN A B ⇔ b ∈ B)
   
   [<a name="ISL_OR_ISR-val"><b>ISL_OR_ISR</b></a>]  Theorem
      
      ⊢ ∀x. ISL x ∨ ISR x
   
   [<a name="ISL_PRS-val"><b>ISL_PRS</b></a>]  Theorem
      
      ⊢ ∀R1 abs1 rep1.
          QUOTIENT R1 abs1 rep1 ⇒
          ∀R2 abs2 rep2.
            QUOTIENT R2 abs2 rep2 ⇒ ∀a. ISL a ⇔ ISL (SUM_MAP rep1 rep2 a)
   
   [<a name="ISL_RSP-val"><b>ISL_RSP</b></a>]  Theorem
      
      ⊢ ∀R1 abs1 rep1.
          QUOTIENT R1 abs1 rep1 ⇒
          ∀R2 abs2 rep2.
            QUOTIENT R2 abs2 rep2 ⇒
            ∀a1 a2. (R1 +++ R2) a1 a2 ⇒ (ISL a1 ⇔ ISL a2)
   
   [<a name="ISR_PRS-val"><b>ISR_PRS</b></a>]  Theorem
      
      ⊢ ∀R1 abs1 rep1.
          QUOTIENT R1 abs1 rep1 ⇒
          ∀R2 abs2 rep2.
            QUOTIENT R2 abs2 rep2 ⇒ ∀a. ISR a ⇔ ISR (SUM_MAP rep1 rep2 a)
   
   [<a name="ISR_RSP-val"><b>ISR_RSP</b></a>]  Theorem
      
      ⊢ ∀R1 abs1 rep1.
          QUOTIENT R1 abs1 rep1 ⇒
          ∀R2 abs2 rep2.
            QUOTIENT R2 abs2 rep2 ⇒
            ∀a1 a2. (R1 +++ R2) a1 a2 ⇒ (ISR a1 ⇔ ISR a2)
   
   [<a name="NOT_ISL_ISR-val"><b>NOT_ISL_ISR</b></a>]  Theorem
      
      ⊢ ∀x. ¬ISL x ⇔ ISR x
   
   [<a name="NOT_ISR_ISL-val"><b>NOT_ISR_ISL</b></a>]  Theorem
      
      ⊢ ∀x. ¬ISR x ⇔ ISL x
   
   [<a name="SUM_ALL_CONG-val"><b>SUM_ALL_CONG</b></a>]  Theorem
      
      ⊢ ∀s s' P P' Q Q'.
          s = s' ∧ (∀a. s' = INL a ⇒ (P a ⇔ P' a)) ∧
          (∀b. s' = INR b ⇒ (Q b ⇔ Q' b)) ⇒
          (SUM_ALL P Q s ⇔ SUM_ALL P' Q' s')
   
   [<a name="SUM_ALL_MONO-val"><b>SUM_ALL_MONO</b></a>]  Theorem
      
      ⊢ (∀x. P x ⇒ P' x) ∧ (∀y. Q y ⇒ Q' y) ⇒
        SUM_ALL P Q s ⇒
        SUM_ALL P' Q' s
   
   [<a name="SUM_ALL_SET-val"><b>SUM_ALL_SET</b></a>]  Theorem
      
      ⊢ SUM_ALL P Q ab ⇔ (∀a. a ∈ setL ab ⇒ P a) ∧ ∀b. b ∈ setR ab ⇒ Q b
   
   [<a name="SUM_EQUIV-val"><b>SUM_EQUIV</b></a>]  Theorem
      
      ⊢ ∀R1 R2. EQUIV R1 ⇒ EQUIV R2 ⇒ EQUIV (R1 +++ R2)
   
   [<a name="SUM_MAP-val"><b>SUM_MAP</b></a>]  Theorem
      
      ⊢ ∀f g z.
          SUM_MAP f g z =
          if ISL z then INL (f (OUTL z)) else INR (g (OUTR z))
   
   [<a name="SUM_MAP_CASE-val"><b>SUM_MAP_CASE</b></a>]  Theorem
      
      ⊢ ∀f g z. SUM_MAP f g z = sum_CASE z (INL ∘ f) (INR ∘ g)
   
   [<a name="SUM_MAP_CONG-val"><b>SUM_MAP_CONG</b></a>]  Theorem
      
      ⊢ (∀a. a ∈ setL ab ⇒ f1 a = f2 a) ∧ (∀b. b ∈ setR ab ⇒ g1 b = g2 b) ⇒
        SUM_MAP f1 g1 ab = SUM_MAP f2 g2 ab
   
   [<a name="SUM_MAP_I-val"><b>SUM_MAP_I</b></a>]  Theorem
      
      ⊢ SUM_MAP I I = I
   
   [<a name="SUM_MAP_PRS-val"><b>SUM_MAP_PRS</b></a>]  Theorem
      
      ⊢ ∀R1 abs1 rep1.
          QUOTIENT R1 abs1 rep1 ⇒
          ∀R2 abs2 rep2.
            QUOTIENT R2 abs2 rep2 ⇒
            ∀R3 abs3 rep3.
              QUOTIENT R3 abs3 rep3 ⇒
              ∀R4 abs4 rep4.
                QUOTIENT R4 abs4 rep4 ⇒
                ∀f g.
                  SUM_MAP f g =
                  (SUM_MAP rep1 rep3 --&gt; SUM_MAP abs2 abs4)
                    (SUM_MAP ((abs1 --&gt; rep2) f) ((abs3 --&gt; rep4) g))
   
   [<a name="SUM_MAP_RSP-val"><b>SUM_MAP_RSP</b></a>]  Theorem
      
      ⊢ ∀R1 abs1 rep1.
          QUOTIENT R1 abs1 rep1 ⇒
          ∀R2 abs2 rep2.
            QUOTIENT R2 abs2 rep2 ⇒
            ∀R3 abs3 rep3.
              QUOTIENT R3 abs3 rep3 ⇒
              ∀R4 abs4 rep4.
                QUOTIENT R4 abs4 rep4 ⇒
                ∀f1 f2 g1 g2.
                  (R1 ===&gt; R2) f1 f2 ∧ (R3 ===&gt; R4) g1 g2 ⇒
                  ((R1 +++ R3) ===&gt; (R2 +++ R4)) (SUM_MAP f1 g1)
                    (SUM_MAP f2 g2)
   
   [<a name="SUM_MAP_SET-val"><b>SUM_MAP_SET</b></a>]  Theorem
      
      ⊢ (c ∈ setL (SUM_MAP f g ab) ⇔ ∃a. c = f a ∧ a ∈ setL ab) ∧
        (d ∈ setR (SUM_MAP f g ab) ⇔ ∃b. d = g b ∧ b ∈ setR ab)
   
   [<a name="SUM_MAP_o-val"><b>SUM_MAP_o</b></a>]  Theorem
      
      ⊢ SUM_MAP f g ∘ SUM_MAP h k = SUM_MAP (f ∘ h) (g ∘ k)
   
   [<a name="SUM_QUOTIENT-val"><b>SUM_QUOTIENT</b></a>]  Theorem
      
      ⊢ ∀R1 abs1 rep1.
          QUOTIENT R1 abs1 rep1 ⇒
          ∀R2 abs2 rep2.
            QUOTIENT R2 abs2 rep2 ⇒
            QUOTIENT (R1 +++ R2) (SUM_MAP abs1 abs2) (SUM_MAP rep1 rep2)
   
   [<a name="SUM_REL_EQ-val"><b>SUM_REL_EQ</b></a>]  Theorem
      
      ⊢ $= +++ $= = $=
   
   [<a name="SUM_REL_REFL-val"><b>SUM_REL_REFL</b></a>]  Theorem
      
      ⊢ (∀x. R1 x x) ∧ (∀a. R2 a a) ⇒ ∀xy. (R1 +++ R2) xy xy
   
   [<a name="SUM_REL_SYM-val"><b>SUM_REL_SYM</b></a>]  Theorem
      
      ⊢ (∀x y. R1 x y ⇔ R1 y x) ∧ (∀a b. R2 a b ⇔ R2 b a) ⇒
        ∀xy ab. (R1 +++ R2) xy ab ⇔ (R1 +++ R2) ab xy
   
   [<a name="SUM_REL_THM-val"><b>SUM_REL_THM</b></a>]  Theorem
      
      ⊢ ((R1 +++ R2) (INL x) (INL a) ⇔ R1 x a) ∧
        ((R1 +++ R2) (INL x) (INR b) ⇔ F) ∧
        ((R1 +++ R2) (INR y) (INL a) ⇔ F) ∧
        ((R1 +++ R2) (INR y) (INR b) ⇔ R2 y b)
   
   [<a name="SUM_REL_TRANS-val"><b>SUM_REL_TRANS</b></a>]  Theorem
      
      ⊢ (∀x y z. R1 x y ∧ R1 y z ⇒ R1 x z) ∧
        (∀a b c. R2 a b ∧ R2 b c ⇒ R2 a c) ⇒
        ∀xy ab uv.
          (R1 +++ R2) xy ab ∧ (R1 +++ R2) ab uv ⇒ (R1 +++ R2) xy uv
   
   [<a name="SUM_SETLR_THM-val"><b>SUM_SETLR_THM</b></a>]  Theorem
      
      ⊢ (a1 ∈ setL (INL a2) ⇔ a1 = a2) ∧ (a ∈ setL (INR b) ⇔ F) ∧
        (b ∈ setR (INL a) ⇔ F) ∧ (b1 ∈ setR (INR b2) ⇔ b1 = b2)
   
   [<a name="cond_sum_expand-val"><b>cond_sum_expand</b></a>]  Theorem
      
      ⊢ (∀x y z. (if P then INR x else INL y) = INR z ⇔ P ∧ z = x) ∧
        (∀x y z. (if P then INR x else INL y) = INL z ⇔ ¬P ∧ z = y) ∧
        (∀x y z. (if P then INL x else INR y) = INL z ⇔ P ∧ z = x) ∧
        ∀x y z. (if P then INL x else INR y) = INR z ⇔ ¬P ∧ z = y
   
   [<a name="datatype_sum-val"><b>datatype_sum</b></a>]  Theorem
      
      ⊢ DATATYPE (sum INL INR)
   
   [<a name="sum_Axiom-val"><b>sum_Axiom</b></a>]  Theorem
      
      ⊢ ∀f g. ∃h. (∀x. h (INL x) = f x) ∧ ∀y. h (INR y) = g y
   
   [<a name="sum_CASES-val"><b>sum_CASES</b></a>]  Theorem
      
      ⊢ ∀ss. (∃x. ss = INL x) ∨ ∃y. ss = INR y
   
   [<a name="sum_INDUCT-val"><b>sum_INDUCT</b></a>]  Theorem
      
      ⊢ ∀P. (∀x. P (INL x)) ∧ (∀y. P (INR y)) ⇒ ∀s. P s
   
   [<a name="sum_axiom-val"><b>sum_axiom</b></a>]  Theorem
      
      ⊢ ∀f g. ∃!h. h ∘ INL = f ∧ h ∘ INR = g
   
   [<a name="sum_case_cong-val"><b>sum_case_cong</b></a>]  Theorem
      
      ⊢ ∀M M' f f1.
          M = M' ∧ (∀x. M' = INL x ⇒ f x = f' x) ∧
          (∀y. M' = INR y ⇒ f1 y = f1' y) ⇒
          sum_CASE M f f1 = sum_CASE M' f' f1'
   
   [<a name="sum_distinct-val"><b>sum_distinct</b></a>]  Theorem
      
      ⊢ ∀x y. INL x ≠ INR y
   
   [<a name="sum_distinct1-val"><b>sum_distinct1</b></a>]  Theorem
      
      ⊢ ∀x y. INR y ≠ INL x
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/coretypes/sumScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-1</a></em></p></body></html>
