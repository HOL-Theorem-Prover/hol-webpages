<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure itreeTauTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure itreeTauTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/coalgebras/itreeTauScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature itreeTauTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#itree_TY_DEF-val">itree_TY_DEF</a> : thm
<a name="line7"></a>    val <a href="#itree_bind_def-val">itree_bind_def</a> : thm
<a name="line8"></a>    val <a href="#itree_el_case_def-val">itree_el_case_def</a> : thm
<a name="line9"></a>    val <a href="#itree_el_size_def-val">itree_el_size_def</a> : thm
<a name="line10"></a>    val <a href="#itree_iter_def-val">itree_iter_def</a> : thm
<a name="line11"></a>    val <a href="#itree_loop_def-val">itree_loop_def</a> : thm
<a name="line12"></a>    val <a href="#itree_next_case_def-val">itree_next_case_def</a> : thm
<a name="line13"></a>    val <a href="#itree_next_size_def-val">itree_next_size_def</a> : thm
<a name="line14"></a>    val <a href="#untau_def-val">untau_def</a> : thm
<a name="line15"></a>  
<a name="line16"></a>  (*  Theorems  *)
<a name="line17"></a>    val <a href="#Ret_11-val">Ret_11</a> : thm
<a name="line18"></a>    val <a href="#Tau_11-val">Tau_11</a> : thm
<a name="line19"></a>    val <a href="#Vis_11-val">Vis_11</a> : thm
<a name="line20"></a>    val <a href="#datatype_itree-val">datatype_itree</a> : thm
<a name="line21"></a>    val <a href="#datatype_itree_el-val">datatype_itree_el</a> : thm
<a name="line22"></a>    val <a href="#datatype_itree_next-val">datatype_itree_next</a> : thm
<a name="line23"></a>    val <a href="#itree_11-val">itree_11</a> : thm
<a name="line24"></a>    val <a href="#itree_CASE-val">itree_CASE</a> : thm
<a name="line25"></a>    val <a href="#itree_CASE_cong-val">itree_CASE_cong</a> : thm
<a name="line26"></a>    val <a href="#itree_CASE_elim-val">itree_CASE_elim</a> : thm
<a name="line27"></a>    val <a href="#itree_CASE_eq-val">itree_CASE_eq</a> : thm
<a name="line28"></a>    val <a href="#itree_bind_assoc-val">itree_bind_assoc</a> : thm
<a name="line29"></a>    val <a href="#itree_bind_resp_k_wbisim-val">itree_bind_resp_k_wbisim</a> : thm
<a name="line30"></a>    val <a href="#itree_bind_resp_t_wbisim-val">itree_bind_resp_t_wbisim</a> : thm
<a name="line31"></a>    val <a href="#itree_bind_resp_wbisim-val">itree_bind_resp_wbisim</a> : thm
<a name="line32"></a>    val <a href="#itree_bind_right_identity-val">itree_bind_right_identity</a> : thm
<a name="line33"></a>    val <a href="#itree_bind_strip_tau_wbisim-val">itree_bind_strip_tau_wbisim</a> : thm
<a name="line34"></a>    val <a href="#itree_bind_thm-val">itree_bind_thm</a> : thm
<a name="line35"></a>    val <a href="#itree_bind_vis_strip_tau-val">itree_bind_vis_strip_tau</a> : thm
<a name="line36"></a>    val <a href="#itree_bisimulation-val">itree_bisimulation</a> : thm
<a name="line37"></a>    val <a href="#itree_cases-val">itree_cases</a> : thm
<a name="line38"></a>    val <a href="#itree_distinct-val">itree_distinct</a> : thm
<a name="line39"></a>    val <a href="#itree_el_11-val">itree_el_11</a> : thm
<a name="line40"></a>    val <a href="#itree_el_Axiom-val">itree_el_Axiom</a> : thm
<a name="line41"></a>    val <a href="#itree_el_case_cong-val">itree_el_case_cong</a> : thm
<a name="line42"></a>    val <a href="#itree_el_case_eq-val">itree_el_case_eq</a> : thm
<a name="line43"></a>    val <a href="#itree_el_def-val">itree_el_def</a> : thm
<a name="line44"></a>    val <a href="#itree_el_distinct-val">itree_el_distinct</a> : thm
<a name="line45"></a>    val <a href="#itree_el_eqv-val">itree_el_eqv</a> : thm
<a name="line46"></a>    val <a href="#itree_el_ind-val">itree_el_ind</a> : thm
<a name="line47"></a>    val <a href="#itree_el_induction-val">itree_el_induction</a> : thm
<a name="line48"></a>    val <a href="#itree_el_nchotomy-val">itree_el_nchotomy</a> : thm
<a name="line49"></a>    val <a href="#itree_el_thm-val">itree_el_thm</a> : thm
<a name="line50"></a>    val <a href="#itree_iter_resp_wbisim-val">itree_iter_resp_wbisim</a> : thm
<a name="line51"></a>    val <a href="#itree_iter_thm-val">itree_iter_thm</a> : thm
<a name="line52"></a>    val <a href="#itree_next_11-val">itree_next_11</a> : thm
<a name="line53"></a>    val <a href="#itree_next_Axiom-val">itree_next_Axiom</a> : thm
<a name="line54"></a>    val <a href="#itree_next_case_cong-val">itree_next_case_cong</a> : thm
<a name="line55"></a>    val <a href="#itree_next_case_eq-val">itree_next_case_eq</a> : thm
<a name="line56"></a>    val <a href="#itree_next_distinct-val">itree_next_distinct</a> : thm
<a name="line57"></a>    val <a href="#itree_next_induction-val">itree_next_induction</a> : thm
<a name="line58"></a>    val <a href="#itree_next_nchotomy-val">itree_next_nchotomy</a> : thm
<a name="line59"></a>    val <a href="#itree_strong_bisimulation-val">itree_strong_bisimulation</a> : thm
<a name="line60"></a>    val <a href="#itree_unfold-val">itree_unfold</a> : thm
<a name="line61"></a>    val <a href="#itree_wbisim_cases-val">itree_wbisim_cases</a> : thm
<a name="line62"></a>    val <a href="#itree_wbisim_coind-val">itree_wbisim_coind</a> : thm
<a name="line63"></a>    val <a href="#itree_wbisim_coind_upto-val">itree_wbisim_coind_upto</a> : thm
<a name="line64"></a>    val <a href="#itree_wbisim_refl-val">itree_wbisim_refl</a> : thm
<a name="line65"></a>    val <a href="#itree_wbisim_rules-val">itree_wbisim_rules</a> : thm
<a name="line66"></a>    val <a href="#itree_wbisim_strip_tau-val">itree_wbisim_strip_tau</a> : thm
<a name="line67"></a>    val <a href="#itree_wbisim_strip_tau_Ret-val">itree_wbisim_strip_tau_Ret</a> : thm
<a name="line68"></a>    val <a href="#itree_wbisim_strip_tau_Vis-val">itree_wbisim_strip_tau_Vis</a> : thm
<a name="line69"></a>    val <a href="#itree_wbisim_strip_tau_sym-val">itree_wbisim_strip_tau_sym</a> : thm
<a name="line70"></a>    val <a href="#itree_wbisim_strong_coind-val">itree_wbisim_strong_coind</a> : thm
<a name="line71"></a>    val <a href="#itree_wbisim_sym-val">itree_wbisim_sym</a> : thm
<a name="line72"></a>    val <a href="#itree_wbisim_tau-val">itree_wbisim_tau</a> : thm
<a name="line73"></a>    val <a href="#itree_wbisim_tau_eq-val">itree_wbisim_tau_eq</a> : thm
<a name="line74"></a>    val <a href="#itree_wbisim_tau_eqn-val">itree_wbisim_tau_eqn</a> : thm
<a name="line75"></a>    val <a href="#itree_wbisim_trans-val">itree_wbisim_trans</a> : thm
<a name="line76"></a>    val <a href="#spin-val">spin</a> : thm
<a name="line77"></a>    val <a href="#spin_strip_tau-val">spin_strip_tau</a> : thm
<a name="line78"></a>    val <a href="#strip_tau_cases-val">strip_tau_cases</a> : thm
<a name="line79"></a>    val <a href="#strip_tau_ind-val">strip_tau_ind</a> : thm
<a name="line80"></a>    val <a href="#strip_tau_inj-val">strip_tau_inj</a> : thm
<a name="line81"></a>    val <a href="#strip_tau_rules-val">strip_tau_rules</a> : thm
<a name="line82"></a>    val <a href="#strip_tau_simps-val">strip_tau_simps</a> : thm
<a name="line83"></a>    val <a href="#strip_tau_simps2-val">strip_tau_simps2</a> : thm
<a name="line84"></a>    val <a href="#strip_tau_simps3-val">strip_tau_simps3</a> : thm
<a name="line85"></a>    val <a href="#strip_tau_spin-val">strip_tau_spin</a> : thm
<a name="line86"></a>    val <a href="#strip_tau_strongind-val">strip_tau_strongind</a> : thm
<a name="line87"></a>    val <a href="#untau_IMP_wbisim-val">untau_IMP_wbisim</a> : thm
<a name="line88"></a>    val <a href="#untau_spin-val">untau_spin</a> : thm
<a name="line89"></a>    val <a href="#wbisim_IMP_untau-val">wbisim_IMP_untau</a> : thm
<a name="line90"></a>  
<a name="line91"></a>  val itreeTau_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line92"></a>(*
   [alist] Parent theory of "itreeTau"
   
   [itree] Parent theory of "itreeTau"
   
   [llist] Parent theory of "itreeTau"
   
   [<a name="itree_TY_DEF-val"><b>itree_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep. TYPE_DEFINITION itree_rep_ok rep
   
   [<a name="itree_bind_def-val"><b>itree_bind_def</b></a>]  Definition
      
      ⊢ ∀t k.
          itree_bind t k =
          itree_unfold
            (λx.
                 case x of
                   INL (Ret r) =&gt;
                     (case k r of
                        Ret s =&gt; Ret' s
                      | Tau t =&gt; Tau' (INR t)
                      | Vis e g =&gt; Vis' e (INR ∘ g))
                 | INL (Tau t) =&gt; Tau' (INL t)
                 | INL (Vis e g) =&gt; Vis' e (INL ∘ g)
                 | INR (Ret r') =&gt; Ret' r'
                 | INR (Tau t') =&gt; Tau' (INR t')
                 | INR (Vis e' g') =&gt; Vis' e' (INR ∘ g')) (INL t)
   
   [<a name="itree_el_case_def-val"><b>itree_el_case_def</b></a>]  Definition
      
      ⊢ (∀a f f1 v. itree_el_CASE (Event a) f f1 v = f a) ∧
        (∀a f f1 v. itree_el_CASE (Return a) f f1 v = f1 a) ∧
        ∀f f1 v. itree_el_CASE Silence f f1 v = v
   
   [<a name="itree_el_size_def-val"><b>itree_el_size_def</b></a>]  Definition
      
      ⊢ (∀f f1 a. itree_el_size f f1 (Event a) = 1 + f a) ∧
        (∀f f1 a. itree_el_size f f1 (Return a) = 1 + f1 a) ∧
        ∀f f1. itree_el_size f f1 Silence = 0
   
   [<a name="itree_iter_def-val"><b>itree_iter_def</b></a>]  Definition
      
      ⊢ ∀body seed.
          itree_iter body seed =
          itree_unfold
            (λx.
                 case x of
                   Ret (INL seed') =&gt; Tau' (body seed')
                 | Ret (INR v) =&gt; Ret' v
                 | Tau u =&gt; Tau' u
                 | Vis e g =&gt; Vis' e g) (body seed)
   
   [<a name="itree_loop_def-val"><b>itree_loop_def</b></a>]  Definition
      
      ⊢ ∀body seed.
          itree_loop body seed =
          itree_iter
            (λx.
                 itree_bind (body x)
                   (λcb.
                        case cb of
                          INL c =&gt; Ret (INL (INL c))
                        | INR b =&gt; Ret (INR b))) (INR seed)
   
   [<a name="itree_next_case_def-val"><b>itree_next_case_def</b></a>]  Definition
      
      ⊢ (∀a f f1 f2. itree_next_CASE (Ret' a) f f1 f2 = f a) ∧
        (∀a f f1 f2. itree_next_CASE (Tau' a) f f1 f2 = f1 a) ∧
        ∀a0 a1 f f1 f2. itree_next_CASE (Vis' a0 a1) f f1 f2 = f2 a0 a1
   
   [<a name="itree_next_size_def-val"><b>itree_next_size_def</b></a>]  Definition
      
      ⊢ (∀f f1 f2 f3 a. itree_next_size f f1 f2 f3 (Ret' a) = 1 + f2 a) ∧
        (∀f f1 f2 f3 a. itree_next_size f f1 f2 f3 (Tau' a) = 1 + f3 a) ∧
        ∀f f1 f2 f3 a0 a1.
          itree_next_size f f1 f2 f3 (Vis' a0 a1) = 1 + f1 a0
   
   [<a name="untau_def-val"><b>untau_def</b></a>]  Definition
      
      ⊢ untau =
        itree_unfold
          (λt.
               case some t'. strip_tau t t' of
                 NONE =&gt; Div'
               | SOME (Ret v) =&gt; Ret' v
               | SOME (Tau t') =&gt; Div'
               | SOME (Vis e k) =&gt; Vis' e k)
   
   [<a name="Ret_11-val"><b>Ret_11</b></a>]  Theorem
      
      ⊢ ∀x y. Ret x = Ret y ⇔ x = y
   
   [<a name="Tau_11-val"><b>Tau_11</b></a>]  Theorem
      
      ⊢ ∀x y. Tau x = Tau y ⇔ x = y
   
   [<a name="Vis_11-val"><b>Vis_11</b></a>]  Theorem
      
      ⊢ ∀x f y g. Vis x f = Vis y g ⇔ x = y ∧ f = g
   
   [<a name="datatype_itree-val"><b>datatype_itree</b></a>]  Theorem
      
      ⊢ DATATYPE (itree Ret Tau Vis)
   
   [<a name="datatype_itree_el-val"><b>datatype_itree_el</b></a>]  Theorem
      
      ⊢ DATATYPE (itree_el Event Return Silence)
   
   [<a name="datatype_itree_next-val"><b>datatype_itree_next</b></a>]  Theorem
      
      ⊢ DATATYPE (itree_next Ret' Tau' Vis')
   
   [<a name="itree_11-val"><b>itree_11</b></a>]  Theorem
      
      ⊢ (∀x y. Ret x = Ret y ⇔ x = y) ∧ (∀x y. Tau x = Tau y ⇔ x = y) ∧
        ∀x f y g. Vis x f = Vis y g ⇔ x = y ∧ f = g
   
   [<a name="itree_CASE-val"><b>itree_CASE</b></a>]  Theorem
      
      ⊢ itree_CASE (Ret r) ret tau vis = ret r ∧
        itree_CASE (Tau t) ret tau vis = tau t ∧
        itree_CASE (Vis a g) ret tau vis = vis a g
   
   [<a name="itree_CASE_cong-val"><b>itree_CASE_cong</b></a>]  Theorem
      
      ⊢ ∀M M' ret tau vis ret' tau' vis'.
          M = M' ∧ (∀x. M' = Ret x ⇒ ret x = ret' x) ∧
          (∀t. M' = Tau t ⇒ tau t = tau' t) ∧
          (∀a g. M' = Vis a g ⇒ vis a g = vis' a g) ⇒
          itree_CASE M ret tau vis = itree_CASE M' ret' tau' vis'
   
   [<a name="itree_CASE_elim-val"><b>itree_CASE_elim</b></a>]  Theorem
      
      ⊢ ∀f. f (itree_CASE t ret tau vis) ⇔
            (∃r. t = Ret r ∧ f (ret r)) ∨ (∃u. t = Tau u ∧ f (tau u)) ∨
            ∃a g. t = Vis a g ∧ f (vis a g)
   
   [<a name="itree_CASE_eq-val"><b>itree_CASE_eq</b></a>]  Theorem
      
      ⊢ itree_CASE t ret tau vis = v ⇔
        (∃r. t = Ret r ∧ ret r = v) ∨ (∃u. t = Tau u ∧ tau u = v) ∨
        ∃a g. t = Vis a g ∧ vis a g = v
   
   [<a name="itree_bind_assoc-val"><b>itree_bind_assoc</b></a>]  Theorem
      
      ⊢ itree_bind (itree_bind t k) k' =
        itree_bind t (λx. itree_bind (k x) k')
   
   [<a name="itree_bind_resp_k_wbisim-val"><b>itree_bind_resp_k_wbisim</b></a>]  Theorem
      
      ⊢ ∀t k1 k2.
          (∀r. itree_wbisim (k1 r) (k2 r)) ⇒
          itree_wbisim (itree_bind t k1) (itree_bind t k2)
   
   [<a name="itree_bind_resp_t_wbisim-val"><b>itree_bind_resp_t_wbisim</b></a>]  Theorem
      
      ⊢ ∀a b k.
          itree_wbisim a b ⇒ itree_wbisim (itree_bind a k) (itree_bind b k)
   
   [<a name="itree_bind_resp_wbisim-val"><b>itree_bind_resp_wbisim</b></a>]  Theorem
      
      ⊢ ∀a b k1 k2.
          itree_wbisim a b ∧ (∀r. itree_wbisim (k1 r) (k2 r)) ⇒
          itree_wbisim (itree_bind a k1) (itree_bind b k2)
   
   [<a name="itree_bind_right_identity-val"><b>itree_bind_right_identity</b></a>]  Theorem
      
      ⊢ itree_bind t Ret = t
   
   [<a name="itree_bind_strip_tau_wbisim-val"><b>itree_bind_strip_tau_wbisim</b></a>]  Theorem
      
      ⊢ ∀u u' k.
          strip_tau u u' ⇒ itree_wbisim (itree_bind u k) (itree_bind u' k)
   
   [<a name="itree_bind_thm-val"><b>itree_bind_thm</b></a>]  Theorem
      
      ⊢ itree_bind (Ret r) k = k r ∧
        itree_bind (Tau t) k = Tau (itree_bind t k) ∧
        itree_bind (Vis e k') k = Vis e (λx. itree_bind (k' x) k)
   
   [<a name="itree_bind_vis_strip_tau-val"><b>itree_bind_vis_strip_tau</b></a>]  Theorem
      
      ⊢ ∀u k k' e.
          strip_tau u (Vis e k') ⇒
          strip_tau (itree_bind u k) (Vis e (λx. itree_bind (k' x) k))
   
   [<a name="itree_bisimulation-val"><b>itree_bisimulation</b></a>]  Theorem
      
      ⊢ ∀t1 t2.
          t1 = t2 ⇔
          ∃R. R t1 t2 ∧ (∀x t. R (Ret x) t ⇒ t = Ret x) ∧
              (∀u t. R (Tau u) t ⇒ ∃v. t = Tau v ∧ R u v) ∧
              ∀a f t. R (Vis a f) t ⇒ ∃g. t = Vis a g ∧ ∀s. R (f s) (g s)
   
   [<a name="itree_cases-val"><b>itree_cases</b></a>]  Theorem
      
      ⊢ ∀t. (∃x. t = Ret x) ∨ (∃u. t = Tau u) ∨ ∃a g. t = Vis a g
   
   [<a name="itree_distinct-val"><b>itree_distinct</b></a>]  Theorem
      
      ⊢ Ret x ≠ Tau t ∧ Ret x ≠ Vis e g ∧ Tau t ≠ Vis e g
   
   [<a name="itree_el_11-val"><b>itree_el_11</b></a>]  Theorem
      
      ⊢ (∀a a'. Event a = Event a' ⇔ a = a') ∧
        ∀a a'. Return a = Return a' ⇔ a = a'
   
   [<a name="itree_el_Axiom-val"><b>itree_el_Axiom</b></a>]  Theorem
      
      ⊢ ∀f0 f1 f2. ∃fn.
          (∀a. fn (Event a) = f0 a) ∧ (∀a. fn (Return a) = f1 a) ∧
          fn Silence = f2
   
   [<a name="itree_el_case_cong-val"><b>itree_el_case_cong</b></a>]  Theorem
      
      ⊢ ∀M M' f f1 v.
          M = M' ∧ (∀a. M' = Event a ⇒ f a = f' a) ∧
          (∀a. M' = Return a ⇒ f1 a = f1' a) ∧ (M' = Silence ⇒ v = v') ⇒
          itree_el_CASE M f f1 v = itree_el_CASE M' f' f1' v'
   
   [<a name="itree_el_case_eq-val"><b>itree_el_case_eq</b></a>]  Theorem
      
      ⊢ itree_el_CASE x f f1 v = v' ⇔
        (∃e. x = Event e ∧ f e = v') ∨ (∃r. x = Return r ∧ f1 r = v') ∨
        x = Silence ∧ v = v'
   
   [<a name="itree_el_def-val"><b>itree_el_def</b></a>]  Theorem
      
      ⊢ (∀t. itree_el t [] =
             case t of
               Ret r =&gt; Return r
             | Tau t =&gt; Silence
             | Vis e g =&gt; Event e) ∧
        (∀t ns.
           itree_el t (NONE::ns) =
           case t of
             Ret r =&gt; Silence
           | Tau t' =&gt; itree_el t' ns
           | Vis e g =&gt; Silence) ∧
        ∀t ns a.
          itree_el t (SOME a::ns) =
          case t of
            Ret r =&gt; Silence
          | Tau t =&gt; Silence
          | Vis e g =&gt; itree_el (g a) ns
   
   [<a name="itree_el_distinct-val"><b>itree_el_distinct</b></a>]  Theorem
      
      ⊢ (∀a' a. Event a ≠ Return a') ∧ (∀a. Event a ≠ Silence) ∧
        ∀a. Return a ≠ Silence
   
   [<a name="itree_el_eqv-val"><b>itree_el_eqv</b></a>]  Theorem
      
      ⊢ ∀t1 t2. t1 = t2 ⇔ ∀path. itree_el t1 path = itree_el t2 path
   
   [<a name="itree_el_ind-val"><b>itree_el_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀t. P t []) ∧ (∀t ns. (∀t'. P t' ns) ⇒ P t (NONE::ns)) ∧
            (∀t a ns. (∀g. P (g a) ns) ⇒ P t (SOME a::ns)) ⇒
            ∀v v1. P v v1
   
   [<a name="itree_el_induction-val"><b>itree_el_induction</b></a>]  Theorem
      
      ⊢ ∀P. (∀e. P (Event e)) ∧ (∀r. P (Return r)) ∧ P Silence ⇒ ∀i. P i
   
   [<a name="itree_el_nchotomy-val"><b>itree_el_nchotomy</b></a>]  Theorem
      
      ⊢ ∀ii. (∃e. ii = Event e) ∨ (∃r. ii = Return r) ∨ ii = Silence
   
   [<a name="itree_el_thm-val"><b>itree_el_thm</b></a>]  Theorem
      
      ⊢ itree_el (Ret r) [] = Return r ∧ itree_el (Tau t) [] = Silence ∧
        itree_el (Vis e g) [] = Event e ∧
        itree_el (Ret r) (NONE::ns) = Silence ∧
        itree_el (Tau t) (NONE::ns) = itree_el t ns ∧
        itree_el (Vis e g) (NONE::ns) = Silence ∧
        itree_el (Ret r) (SOME a::ns) = Silence ∧
        itree_el (Tau t) (SOME a::ns) = Silence ∧
        itree_el (Vis e g) (SOME a::ns) = itree_el (g a) ns
   
   [<a name="itree_iter_resp_wbisim-val"><b>itree_iter_resp_wbisim</b></a>]  Theorem
      
      ⊢ ∀t k1 k2.
          (∀r. itree_wbisim (k1 r) (k2 r)) ⇒
          itree_wbisim (itree_iter k1 t) (itree_iter k2 t)
   
   [<a name="itree_iter_thm-val"><b>itree_iter_thm</b></a>]  Theorem
      
      ⊢ itree_iter body seed =
        itree_bind (body seed)
          (λx. case x of INL a =&gt; Tau (itree_iter body a) | INR b =&gt; Ret b)
   
   [<a name="itree_next_11-val"><b>itree_next_11</b></a>]  Theorem
      
      ⊢ (∀a a'. Ret' a = Ret' a' ⇔ a = a') ∧
        (∀a a'. Tau' a = Tau' a' ⇔ a = a') ∧
        ∀a0 a1 a0' a1'. Vis' a0 a1 = Vis' a0' a1' ⇔ a0 = a0' ∧ a1 = a1'
   
   [<a name="itree_next_Axiom-val"><b>itree_next_Axiom</b></a>]  Theorem
      
      ⊢ ∀f0 f1 f2. ∃fn.
          (∀a. fn (Ret' a) = f0 a) ∧ (∀a. fn (Tau' a) = f1 a) ∧
          ∀a0 a1. fn (Vis' a0 a1) = f2 a0 a1
   
   [<a name="itree_next_case_cong-val"><b>itree_next_case_cong</b></a>]  Theorem
      
      ⊢ ∀M M' f f1 f2.
          M = M' ∧ (∀a. M' = Ret' a ⇒ f a = f' a) ∧
          (∀a. M' = Tau' a ⇒ f1 a = f1' a) ∧
          (∀a0 a1. M' = Vis' a0 a1 ⇒ f2 a0 a1 = f2' a0 a1) ⇒
          itree_next_CASE M f f1 f2 = itree_next_CASE M' f' f1' f2'
   
   [<a name="itree_next_case_eq-val"><b>itree_next_case_eq</b></a>]  Theorem
      
      ⊢ itree_next_CASE x f f1 f2 = v ⇔
        (∃r. x = Ret' r ∧ f r = v) ∨ (∃s. x = Tau' s ∧ f1 s = v) ∨
        ∃e f'. x = Vis' e f' ∧ f2 e f' = v
   
   [<a name="itree_next_distinct-val"><b>itree_next_distinct</b></a>]  Theorem
      
      ⊢ (∀a' a. Ret' a ≠ Tau' a') ∧ (∀a1 a0 a. Ret' a ≠ Vis' a0 a1) ∧
        ∀a1 a0 a. Tau' a ≠ Vis' a0 a1
   
   [<a name="itree_next_induction-val"><b>itree_next_induction</b></a>]  Theorem
      
      ⊢ ∀P. (∀r. P (Ret' r)) ∧ (∀s. P (Tau' s)) ∧ (∀e f. P (Vis' e f)) ⇒
            ∀i. P i
   
   [<a name="itree_next_nchotomy-val"><b>itree_next_nchotomy</b></a>]  Theorem
      
      ⊢ ∀ii. (∃r. ii = Ret' r) ∨ (∃s. ii = Tau' s) ∨ ∃e f. ii = Vis' e f
   
   [<a name="itree_strong_bisimulation-val"><b>itree_strong_bisimulation</b></a>]  Theorem
      
      ⊢ ∀t1 t2.
          t1 = t2 ⇔
          ∃R. R t1 t2 ∧ (∀x t. R (Ret x) t ⇒ t = Ret x) ∧
              (∀u t. R (Tau u) t ⇒ ∃v. t = Tau v ∧ (R u v ∨ u = v)) ∧
              ∀a f t.
                R (Vis a f) t ⇒
                ∃g. t = Vis a g ∧ ∀s. R (f s) (g s) ∨ f s = g s
   
   [<a name="itree_unfold-val"><b>itree_unfold</b></a>]  Theorem
      
      ⊢ itree_unfold f seed =
        case f seed of
          Ret' r =&gt; Ret r
        | Tau' s =&gt; Tau (itree_unfold f s)
        | Vis' e g =&gt; Vis e (itree_unfold f ∘ g)
   
   [<a name="itree_wbisim_cases-val"><b>itree_wbisim_cases</b></a>]  Theorem
      
      ⊢ ∀a0 a1.
          itree_wbisim a0 a1 ⇔
          (∃t t'. a0 = Tau t ∧ a1 = Tau t' ∧ itree_wbisim t t') ∨
          (∃e k k'.
             strip_tau a0 (Vis e k) ∧ strip_tau a1 (Vis e k') ∧
             ∀r. itree_wbisim (k r) (k' r)) ∨
          ∃r. strip_tau a0 (Ret r) ∧ strip_tau a1 (Ret r)
   
   [<a name="itree_wbisim_coind-val"><b>itree_wbisim_coind</b></a>]  Theorem
      
      ⊢ ∀itree_wbisim'.
          (∀a0 a1.
             itree_wbisim' a0 a1 ⇒
             (∃t t'. a0 = Tau t ∧ a1 = Tau t' ∧ itree_wbisim' t t') ∨
             (∃e k k'.
                strip_tau a0 (Vis e k) ∧ strip_tau a1 (Vis e k') ∧
                ∀r. itree_wbisim' (k r) (k' r)) ∨
             ∃r. strip_tau a0 (Ret r) ∧ strip_tau a1 (Ret r)) ⇒
          ∀a0 a1. itree_wbisim' a0 a1 ⇒ itree_wbisim a0 a1
   
   [<a name="itree_wbisim_coind_upto-val"><b>itree_wbisim_coind_upto</b></a>]  Theorem
      
      ⊢ ∀R. (∀t t'.
               R t t' ⇒
               (∃t2 t3.
                  t = Tau t2 ∧ t' = Tau t3 ∧ (R t2 t3 ∨ itree_wbisim t2 t3)) ∨
               (∃e k k'.
                  strip_tau t (Vis e k) ∧ strip_tau t' (Vis e k') ∧
                  ∀r. R (k r) (k' r) ∨ itree_wbisim (k r) (k' r)) ∨
               (∃r. strip_tau t (Ret r) ∧ strip_tau t' (Ret r)) ∨
               itree_wbisim t t') ⇒
            ∀t t'. R t t' ⇒ itree_wbisim t t'
   
   [<a name="itree_wbisim_refl-val"><b>itree_wbisim_refl</b></a>]  Theorem
      
      ⊢ itree_wbisim t t
   
   [<a name="itree_wbisim_rules-val"><b>itree_wbisim_rules</b></a>]  Theorem
      
      ⊢ (∀t t'. itree_wbisim t t' ⇒ itree_wbisim (Tau t) (Tau t')) ∧
        (∀e k k' t t'.
           strip_tau t (Vis e k) ∧ strip_tau t' (Vis e k') ∧
           (∀r. itree_wbisim (k r) (k' r)) ⇒
           itree_wbisim t t') ∧
        ∀r t t'.
          strip_tau t (Ret r) ∧ strip_tau t' (Ret r) ⇒ itree_wbisim t t'
   
   [<a name="itree_wbisim_strip_tau-val"><b>itree_wbisim_strip_tau</b></a>]  Theorem
      
      ⊢ ∀t t' t''.
          itree_wbisim t t' ∧ strip_tau t t'' ⇒ itree_wbisim t'' t'
   
   [<a name="itree_wbisim_strip_tau_Ret-val"><b>itree_wbisim_strip_tau_Ret</b></a>]  Theorem
      
      ⊢ ∀t t' v.
          itree_wbisim t t' ∧ strip_tau t (Ret v) ⇒ strip_tau t' (Ret v)
   
   [<a name="itree_wbisim_strip_tau_Vis-val"><b>itree_wbisim_strip_tau_Vis</b></a>]  Theorem
      
      ⊢ ∀t t' e k.
          itree_wbisim t t' ∧ strip_tau t (Vis e k) ⇒
          ∃k'. strip_tau t' (Vis e k') ∧ ∀r. itree_wbisim (k r) (k' r)
   
   [<a name="itree_wbisim_strip_tau_sym-val"><b>itree_wbisim_strip_tau_sym</b></a>]  Theorem
      
      ⊢ ∀t t' t''.
          itree_wbisim t t' ∧ strip_tau t' t'' ⇒ itree_wbisim t t''
   
   [<a name="itree_wbisim_strong_coind-val"><b>itree_wbisim_strong_coind</b></a>]  Theorem
      
      ⊢ ∀R. (∀t t'.
               R t t' ⇒
               (∃t2 t3.
                  t = Tau t2 ∧ t' = Tau t3 ∧ (R t2 t3 ∨ itree_wbisim t2 t3)) ∨
               (∃e k k'.
                  strip_tau t (Vis e k) ∧ strip_tau t' (Vis e k') ∧
                  ∀r. R (k r) (k' r) ∨ itree_wbisim (k r) (k' r)) ∨
               ∃r. strip_tau t (Ret r) ∧ strip_tau t' (Ret r)) ⇒
            ∀t t'. R t t' ⇒ itree_wbisim t t'
   
   [<a name="itree_wbisim_sym-val"><b>itree_wbisim_sym</b></a>]  Theorem
      
      ⊢ ∀t t'. itree_wbisim t t' ⇒ itree_wbisim t' t
   
   [<a name="itree_wbisim_tau-val"><b>itree_wbisim_tau</b></a>]  Theorem
      
      ⊢ ∀t t'. itree_wbisim (Tau t) t' ⇒ itree_wbisim t t'
   
   [<a name="itree_wbisim_tau_eq-val"><b>itree_wbisim_tau_eq</b></a>]  Theorem
      
      ⊢ itree_wbisim (Tau t) t
   
   [<a name="itree_wbisim_tau_eqn-val"><b>itree_wbisim_tau_eqn</b></a>]  Theorem
      
      ⊢ (itree_wbisim (Tau t1) t2 ⇔ itree_wbisim t1 t2) ∧
        (itree_wbisim t1 (Tau t2) ⇔ itree_wbisim t1 t2)
   
   [<a name="itree_wbisim_trans-val"><b>itree_wbisim_trans</b></a>]  Theorem
      
      ⊢ ∀t t' t''.
          itree_wbisim t t' ∧ itree_wbisim t' t'' ⇒ itree_wbisim t t''
   
   [<a name="spin-val"><b>spin</b></a>]  Theorem
      
      ⊢ spin = Tau spin
   
   [<a name="spin_strip_tau-val"><b>spin_strip_tau</b></a>]  Theorem
      
      ⊢ ∀t. strip_tau spin t ⇒ F
   
   [<a name="strip_tau_cases-val"><b>strip_tau_cases</b></a>]  Theorem
      
      ⊢ ∀a0 a1.
          strip_tau a0 a1 ⇔
          (∃t. a0 = Tau t ∧ strip_tau t a1) ∨
          (∃e k. a0 = Vis e k ∧ a1 = Vis e k) ∨ ∃v. a0 = Ret v ∧ a1 = Ret v
   
   [<a name="strip_tau_ind-val"><b>strip_tau_ind</b></a>]  Theorem
      
      ⊢ ∀strip_tau'.
          (∀t t'. strip_tau' t t' ⇒ strip_tau' (Tau t) t') ∧
          (∀e k. strip_tau' (Vis e k) (Vis e k)) ∧
          (∀v. strip_tau' (Ret v) (Ret v)) ⇒
          ∀a0 a1. strip_tau a0 a1 ⇒ strip_tau' a0 a1
   
   [<a name="strip_tau_inj-val"><b>strip_tau_inj</b></a>]  Theorem
      
      ⊢ ∀t t' t''. strip_tau t t' ∧ strip_tau t t'' ⇒ t' = t''
   
   [<a name="strip_tau_rules-val"><b>strip_tau_rules</b></a>]  Theorem
      
      ⊢ (∀t t'. strip_tau t t' ⇒ strip_tau (Tau t) t') ∧
        (∀e k. strip_tau (Vis e k) (Vis e k)) ∧
        ∀v. strip_tau (Ret v) (Ret v)
   
   [<a name="strip_tau_simps-val"><b>strip_tau_simps</b></a>]  Theorem
      
      ⊢ (strip_tau t' (Tau t) ⇔ F) ∧ (strip_tau (Ret v) (Vis e k) ⇔ F) ∧
        (strip_tau (Vis e k) (Ret v) ⇔ F) ∧
        (strip_tau (Tau t) t' ⇔ strip_tau t t')
   
   [<a name="strip_tau_simps2-val"><b>strip_tau_simps2</b></a>]  Theorem
      
      ⊢ strip_tau (Ret v) (Ret v') ⇔ v = v'
   
   [<a name="strip_tau_simps3-val"><b>strip_tau_simps3</b></a>]  Theorem
      
      ⊢ strip_tau (Vis e k) (Vis e' k') ⇔ e = e' ∧ k = k'
   
   [<a name="strip_tau_spin-val"><b>strip_tau_spin</b></a>]  Theorem
      
      ⊢ (∀t'. ¬strip_tau t t') ⇒ t = spin
   
   [<a name="strip_tau_strongind-val"><b>strip_tau_strongind</b></a>]  Theorem
      
      ⊢ ∀strip_tau'.
          (∀t t'. strip_tau t t' ∧ strip_tau' t t' ⇒ strip_tau' (Tau t) t') ∧
          (∀e k. strip_tau' (Vis e k) (Vis e k)) ∧
          (∀v. strip_tau' (Ret v) (Ret v)) ⇒
          ∀a0 a1. strip_tau a0 a1 ⇒ strip_tau' a0 a1
   
   [<a name="untau_IMP_wbisim-val"><b>untau_IMP_wbisim</b></a>]  Theorem
      
      ⊢ ∀t t'. untau t = untau t' ⇒ itree_wbisim t t'
   
   [<a name="untau_spin-val"><b>untau_spin</b></a>]  Theorem
      
      ⊢ untau spin = Div
   
   [<a name="wbisim_IMP_untau-val"><b>wbisim_IMP_untau</b></a>]  Theorem
      
      ⊢ ∀t t'. itree_wbisim t t' ⇒ untau t = untau t'
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/coalgebras/itreeTauScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-1</a></em></p></body></html>
