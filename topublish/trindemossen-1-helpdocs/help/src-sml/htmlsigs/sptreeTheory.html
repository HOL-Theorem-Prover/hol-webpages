<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure sptreeTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure sptreeTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/finite_maps/sptreeScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature sptreeTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#apsnd_cons_def-val">apsnd_cons_def</a> : thm
<a name="line7"></a>    val <a href="#delete_def-val">delete_def</a> : thm
<a name="line8"></a>    val <a href="#difference_def-val">difference_def</a> : thm
<a name="line9"></a>    val <a href="#domain_def-val">domain_def</a> : thm
<a name="line10"></a>    val <a href="#expand_rle_def-val">expand_rle_def</a> : thm
<a name="line11"></a>    val <a href="#filter_v_def-val">filter_v_def</a> : thm
<a name="line12"></a>    val <a href="#foldi_def-val">foldi_def</a> : thm
<a name="line13"></a>    val <a href="#fromAList_def_primitive-val">fromAList_def_primitive</a> : thm
<a name="line14"></a>    val <a href="#fromList_def-val">fromList_def</a> : thm
<a name="line15"></a>    val <a href="#inter_def-val">inter_def</a> : thm
<a name="line16"></a>    val <a href="#inter_eq_def-val">inter_eq_def</a> : thm
<a name="line17"></a>    val <a href="#list_insert_def-val">list_insert_def</a> : thm
<a name="line18"></a>    val <a href="#list_to_num_set_def-val">list_to_num_set_def</a> : thm
<a name="line19"></a>    val <a href="#lrnext_def_primitive-val">lrnext_def_primitive</a> : thm
<a name="line20"></a>    val <a href="#map_def-val">map_def</a> : thm
<a name="line21"></a>    val <a href="#mapi0_def-val">mapi0_def</a> : thm
<a name="line22"></a>    val <a href="#mapi_def-val">mapi_def</a> : thm
<a name="line23"></a>    val <a href="#mk_wf_def-val">mk_wf_def</a> : thm
<a name="line24"></a>    val <a href="#size_def-val">size_def</a> : thm
<a name="line25"></a>    val <a href="#spt_TY_DEF-val">spt_TY_DEF</a> : thm
<a name="line26"></a>    val <a href="#spt_case_def-val">spt_case_def</a> : thm
<a name="line27"></a>    val <a href="#spt_center_def_primitive-val">spt_center_def_primitive</a> : thm
<a name="line28"></a>    val <a href="#spt_fold_def-val">spt_fold_def</a> : thm
<a name="line29"></a>    val <a href="#spt_left_def-val">spt_left_def</a> : thm
<a name="line30"></a>    val <a href="#spt_right_def-val">spt_right_def</a> : thm
<a name="line31"></a>    val <a href="#spt_size_def-val">spt_size_def</a> : thm
<a name="line32"></a>    val <a href="#subspt_eq-val">subspt_eq</a> : thm
<a name="line33"></a>    val <a href="#toAList_def-val">toAList_def</a> : thm
<a name="line34"></a>    val <a href="#toListA_def-val">toListA_def</a> : thm
<a name="line35"></a>    val <a href="#toList_def-val">toList_def</a> : thm
<a name="line36"></a>    val <a href="#toSortedAList_def-val">toSortedAList_def</a> : thm
<a name="line37"></a>    val <a href="#union_def-val">union_def</a> : thm
<a name="line38"></a>    val <a href="#wf_def-val">wf_def</a> : thm
<a name="line39"></a>  
<a name="line40"></a>  (*  Theorems  *)
<a name="line41"></a>    val <a href="#ALL_DISTINCT_MAP_FST_toAList-val">ALL_DISTINCT_MAP_FST_toAList</a> : thm
<a name="line42"></a>    val <a href="#ALL_DISTINCT_MAP_FST_toSortedAList-val">ALL_DISTINCT_MAP_FST_toSortedAList</a> : thm
<a name="line43"></a>    val <a href="#ALOOKUP_toAList-val">ALOOKUP_toAList</a> : thm
<a name="line44"></a>    val <a href="#ALOOKUP_toSortedAList-val">ALOOKUP_toSortedAList</a> : thm
<a name="line45"></a>    val <a href="#EVERY_combine_rle-val">EVERY_combine_rle</a> : thm
<a name="line46"></a>    val <a href="#EVERY_empty_SND_combine-val">EVERY_empty_SND_combine</a> : thm
<a name="line47"></a>    val <a href="#FINITE_domain-val">FINITE_domain</a> : thm
<a name="line48"></a>    val <a href="#IMP_size_LESS_size-val">IMP_size_LESS_size</a> : thm
<a name="line49"></a>    val <a href="#IN_domain-val">IN_domain</a> : thm
<a name="line50"></a>    val <a href="#LENGTH_toAList-val">LENGTH_toAList</a> : thm
<a name="line51"></a>    val <a href="#LENGTH_toSortedAList-val">LENGTH_toSortedAList</a> : thm
<a name="line52"></a>    val <a href="#MAP_foldi-val">MAP_foldi</a> : thm
<a name="line53"></a>    val <a href="#MEM_spts_to_alist-val">MEM_spts_to_alist</a> : thm
<a name="line54"></a>    val <a href="#MEM_toAList-val">MEM_toAList</a> : thm
<a name="line55"></a>    val <a href="#MEM_toList-val">MEM_toList</a> : thm
<a name="line56"></a>    val <a href="#MEM_toSortedAList-val">MEM_toSortedAList</a> : thm
<a name="line57"></a>    val <a href="#SORTED_spts_to_alist_lemma-val">SORTED_spts_to_alist_lemma</a> : thm
<a name="line58"></a>    val <a href="#SORTED_toSortedAList-val">SORTED_toSortedAList</a> : thm
<a name="line59"></a>    val <a href="#SUM_MAP_same_LE-val">SUM_MAP_same_LE</a> : thm
<a name="line60"></a>    val <a href="#SUM_MAP_same_LESS-val">SUM_MAP_same_LESS</a> : thm
<a name="line61"></a>    val <a href="#alist_insert_REVERSE-val">alist_insert_REVERSE</a> : thm
<a name="line62"></a>    val <a href="#alist_insert_append-val">alist_insert_append</a> : thm
<a name="line63"></a>    val <a href="#alist_insert_def-val">alist_insert_def</a> : thm
<a name="line64"></a>    val <a href="#alist_insert_ind-val">alist_insert_ind</a> : thm
<a name="line65"></a>    val <a href="#alist_insert_pull_insert-val">alist_insert_pull_insert</a> : thm
<a name="line66"></a>    val <a href="#apsnd_cons_is_case-val">apsnd_cons_is_case</a> : thm
<a name="line67"></a>    val <a href="#combine_rle_def-val">combine_rle_def</a> : thm
<a name="line68"></a>    val <a href="#combine_rle_ind-val">combine_rle_ind</a> : thm
<a name="line69"></a>    val <a href="#combine_rle_ind2-val">combine_rle_ind2</a> : thm
<a name="line70"></a>    val <a href="#combine_rle_props-val">combine_rle_props</a> : thm
<a name="line71"></a>    val <a href="#datatype_spt-val">datatype_spt</a> : thm
<a name="line72"></a>    val <a href="#delete_compute-val">delete_compute</a> : thm
<a name="line73"></a>    val <a href="#delete_delete-val">delete_delete</a> : thm
<a name="line74"></a>    val <a href="#delete_fail-val">delete_fail</a> : thm
<a name="line75"></a>    val <a href="#delete_mk_wf-val">delete_mk_wf</a> : thm
<a name="line76"></a>    val <a href="#difference_sub-val">difference_sub</a> : thm
<a name="line77"></a>    val <a href="#domain_FOLDR_delete-val">domain_FOLDR_delete</a> : thm
<a name="line78"></a>    val <a href="#domain_alist_insert-val">domain_alist_insert</a> : thm
<a name="line79"></a>    val <a href="#domain_delete-val">domain_delete</a> : thm
<a name="line80"></a>    val <a href="#domain_difference-val">domain_difference</a> : thm
<a name="line81"></a>    val <a href="#domain_empty-val">domain_empty</a> : thm
<a name="line82"></a>    val <a href="#domain_eq-val">domain_eq</a> : thm
<a name="line83"></a>    val <a href="#domain_foldi-val">domain_foldi</a> : thm
<a name="line84"></a>    val <a href="#domain_fromAList-val">domain_fromAList</a> : thm
<a name="line85"></a>    val <a href="#domain_fromList-val">domain_fromList</a> : thm
<a name="line86"></a>    val <a href="#domain_insert-val">domain_insert</a> : thm
<a name="line87"></a>    val <a href="#domain_inter-val">domain_inter</a> : thm
<a name="line88"></a>    val <a href="#domain_list_insert-val">domain_list_insert</a> : thm
<a name="line89"></a>    val <a href="#domain_list_to_num_set-val">domain_list_to_num_set</a> : thm
<a name="line90"></a>    val <a href="#domain_lookup-val">domain_lookup</a> : thm
<a name="line91"></a>    val <a href="#domain_map-val">domain_map</a> : thm
<a name="line92"></a>    val <a href="#domain_mapi-val">domain_mapi</a> : thm
<a name="line93"></a>    val <a href="#domain_mk_wf-val">domain_mk_wf</a> : thm
<a name="line94"></a>    val <a href="#domain_sing-val">domain_sing</a> : thm
<a name="line95"></a>    val <a href="#domain_union-val">domain_union</a> : thm
<a name="line96"></a>    val <a href="#expand_rle_append-val">expand_rle_append</a> : thm
<a name="line97"></a>    val <a href="#expand_rle_combine_rle-val">expand_rle_combine_rle</a> : thm
<a name="line98"></a>    val <a href="#expand_rle_map-val">expand_rle_map</a> : thm
<a name="line99"></a>    val <a href="#foldi_FOLDR_toAList-val">foldi_FOLDR_toAList</a> : thm
<a name="line100"></a>    val <a href="#fromAList_append-val">fromAList_append</a> : thm
<a name="line101"></a>    val <a href="#fromAList_def-val">fromAList_def</a> : thm
<a name="line102"></a>    val <a href="#fromAList_ind-val">fromAList_ind</a> : thm
<a name="line103"></a>    val <a href="#fromAList_toAList-val">fromAList_toAList</a> : thm
<a name="line104"></a>    val <a href="#fromList_fromAList-val">fromList_fromAList</a> : thm
<a name="line105"></a>    val <a href="#fst_spt_centers_imp-val">fst_spt_centers_imp</a> : thm
<a name="line106"></a>    val <a href="#insert_compute-val">insert_compute</a> : thm
<a name="line107"></a>    val <a href="#insert_def-val">insert_def</a> : thm
<a name="line108"></a>    val <a href="#insert_fromList_IN_domain-val">insert_fromList_IN_domain</a> : thm
<a name="line109"></a>    val <a href="#insert_ind-val">insert_ind</a> : thm
<a name="line110"></a>    val <a href="#insert_insert-val">insert_insert</a> : thm
<a name="line111"></a>    val <a href="#insert_mk_wf-val">insert_mk_wf</a> : thm
<a name="line112"></a>    val <a href="#insert_notEmpty-val">insert_notEmpty</a> : thm
<a name="line113"></a>    val <a href="#insert_shadow-val">insert_shadow</a> : thm
<a name="line114"></a>    val <a href="#insert_swap-val">insert_swap</a> : thm
<a name="line115"></a>    val <a href="#insert_unchanged-val">insert_unchanged</a> : thm
<a name="line116"></a>    val <a href="#insert_union-val">insert_union</a> : thm
<a name="line117"></a>    val <a href="#inter_LN-val">inter_LN</a> : thm
<a name="line118"></a>    val <a href="#inter_assoc-val">inter_assoc</a> : thm
<a name="line119"></a>    val <a href="#inter_eq-val">inter_eq</a> : thm
<a name="line120"></a>    val <a href="#inter_eq_LN-val">inter_eq_LN</a> : thm
<a name="line121"></a>    val <a href="#inter_mk_wf-val">inter_mk_wf</a> : thm
<a name="line122"></a>    val <a href="#isEmpty_toList-val">isEmpty_toList</a> : thm
<a name="line123"></a>    val <a href="#isEmpty_toListA-val">isEmpty_toListA</a> : thm
<a name="line124"></a>    val <a href="#isEmpty_union-val">isEmpty_union</a> : thm
<a name="line125"></a>    val <a href="#list_size_APPEND-val">list_size_APPEND</a> : thm
<a name="line126"></a>    val <a href="#list_to_num_set_append-val">list_to_num_set_append</a> : thm
<a name="line127"></a>    val <a href="#lookup_0_spt_center-val">lookup_0_spt_center</a> : thm
<a name="line128"></a>    val <a href="#lookup_FOLDL_union-val">lookup_FOLDL_union</a> : thm
<a name="line129"></a>    val <a href="#lookup_NONE_domain-val">lookup_NONE_domain</a> : thm
<a name="line130"></a>    val <a href="#lookup_SOME_left_right_cases-val">lookup_SOME_left_right_cases</a> : thm
<a name="line131"></a>    val <a href="#lookup_alist_insert-val">lookup_alist_insert</a> : thm
<a name="line132"></a>    val <a href="#lookup_compute-val">lookup_compute</a> : thm
<a name="line133"></a>    val <a href="#lookup_def-val">lookup_def</a> : thm
<a name="line134"></a>    val <a href="#lookup_delete-val">lookup_delete</a> : thm
<a name="line135"></a>    val <a href="#lookup_difference-val">lookup_difference</a> : thm
<a name="line136"></a>    val <a href="#lookup_filter_v-val">lookup_filter_v</a> : thm
<a name="line137"></a>    val <a href="#lookup_fromAList-val">lookup_fromAList</a> : thm
<a name="line138"></a>    val <a href="#lookup_fromAList_toAList-val">lookup_fromAList_toAList</a> : thm
<a name="line139"></a>    val <a href="#lookup_fromList-val">lookup_fromList</a> : thm
<a name="line140"></a>    val <a href="#lookup_fromList_outside-val">lookup_fromList_outside</a> : thm
<a name="line141"></a>    val <a href="#lookup_ind-val">lookup_ind</a> : thm
<a name="line142"></a>    val <a href="#lookup_insert-val">lookup_insert</a> : thm
<a name="line143"></a>    val <a href="#lookup_insert1-val">lookup_insert1</a> : thm
<a name="line144"></a>    val <a href="#lookup_inter-val">lookup_inter</a> : thm
<a name="line145"></a>    val <a href="#lookup_inter_EQ-val">lookup_inter_EQ</a> : thm
<a name="line146"></a>    val <a href="#lookup_inter_alt-val">lookup_inter_alt</a> : thm
<a name="line147"></a>    val <a href="#lookup_inter_assoc-val">lookup_inter_assoc</a> : thm
<a name="line148"></a>    val <a href="#lookup_inter_eq-val">lookup_inter_eq</a> : thm
<a name="line149"></a>    val <a href="#lookup_list_to_num_set-val">lookup_list_to_num_set</a> : thm
<a name="line150"></a>    val <a href="#lookup_map-val">lookup_map</a> : thm
<a name="line151"></a>    val <a href="#lookup_map_K-val">lookup_map_K</a> : thm
<a name="line152"></a>    val <a href="#lookup_mapi-val">lookup_mapi</a> : thm
<a name="line153"></a>    val <a href="#lookup_mapi0-val">lookup_mapi0</a> : thm
<a name="line154"></a>    val <a href="#lookup_mk_BN-val">lookup_mk_BN</a> : thm
<a name="line155"></a>    val <a href="#lookup_mk_wf-val">lookup_mk_wf</a> : thm
<a name="line156"></a>    val <a href="#lookup_rwts-val">lookup_rwts</a> : thm
<a name="line157"></a>    val <a href="#lookup_spt_left-val">lookup_spt_left</a> : thm
<a name="line158"></a>    val <a href="#lookup_spt_right-val">lookup_spt_right</a> : thm
<a name="line159"></a>    val <a href="#lookup_union-val">lookup_union</a> : thm
<a name="line160"></a>    val <a href="#lrnext_def-val">lrnext_def</a> : thm
<a name="line161"></a>    val <a href="#lrnext_eq-val">lrnext_eq</a> : thm
<a name="line162"></a>    val <a href="#lrnext_ind-val">lrnext_ind</a> : thm
<a name="line163"></a>    val <a href="#lrnext_thm-val">lrnext_thm</a> : thm
<a name="line164"></a>    val <a href="#map_LN-val">map_LN</a> : thm
<a name="line165"></a>    val <a href="#map_fromAList-val">map_fromAList</a> : thm
<a name="line166"></a>    val <a href="#map_insert-val">map_insert</a> : thm
<a name="line167"></a>    val <a href="#map_map_K-val">map_map_K</a> : thm
<a name="line168"></a>    val <a href="#map_map_o-val">map_map_o</a> : thm
<a name="line169"></a>    val <a href="#map_union-val">map_union</a> : thm
<a name="line170"></a>    val <a href="#mapi_Alist-val">mapi_Alist</a> : thm
<a name="line171"></a>    val <a href="#mapi_fromList-val">mapi_fromList</a> : thm
<a name="line172"></a>    val <a href="#mk_BN_def-val">mk_BN_def</a> : thm
<a name="line173"></a>    val <a href="#mk_BN_ind-val">mk_BN_ind</a> : thm
<a name="line174"></a>    val <a href="#mk_BS_def-val">mk_BS_def</a> : thm
<a name="line175"></a>    val <a href="#mk_BS_ind-val">mk_BS_ind</a> : thm
<a name="line176"></a>    val <a href="#mk_wf_eq-val">mk_wf_eq</a> : thm
<a name="line177"></a>    val <a href="#num_set_domain_eq-val">num_set_domain_eq</a> : thm
<a name="line178"></a>    val <a href="#set_MAP_FST_toAList_domain-val">set_MAP_FST_toAList_domain</a> : thm
<a name="line179"></a>    val <a href="#set_foldi_keys-val">set_foldi_keys</a> : thm
<a name="line180"></a>    val <a href="#size_delete-val">size_delete</a> : thm
<a name="line181"></a>    val <a href="#size_diff_less-val">size_diff_less</a> : thm
<a name="line182"></a>    val <a href="#size_domain-val">size_domain</a> : thm
<a name="line183"></a>    val <a href="#size_fromList-val">size_fromList</a> : thm
<a name="line184"></a>    val <a href="#size_insert-val">size_insert</a> : thm
<a name="line185"></a>    val <a href="#size_map-val">size_map</a> : thm
<a name="line186"></a>    val <a href="#size_mapi-val">size_mapi</a> : thm
<a name="line187"></a>    val <a href="#size_zero_empty-val">size_zero_empty</a> : thm
<a name="line188"></a>    val <a href="#spt_11-val">spt_11</a> : thm
<a name="line189"></a>    val <a href="#spt_Axiom-val">spt_Axiom</a> : thm
<a name="line190"></a>    val <a href="#spt_acc_0-val">spt_acc_0</a> : thm
<a name="line191"></a>    val <a href="#spt_acc_compute-val">spt_acc_compute</a> : thm
<a name="line192"></a>    val <a href="#spt_acc_def-val">spt_acc_def</a> : thm
<a name="line193"></a>    val <a href="#spt_acc_eqn-val">spt_acc_eqn</a> : thm
<a name="line194"></a>    val <a href="#spt_acc_ind-val">spt_acc_ind</a> : thm
<a name="line195"></a>    val <a href="#spt_acc_thm-val">spt_acc_thm</a> : thm
<a name="line196"></a>    val <a href="#spt_case_cong-val">spt_case_cong</a> : thm
<a name="line197"></a>    val <a href="#spt_case_eq-val">spt_case_eq</a> : thm
<a name="line198"></a>    val <a href="#spt_center_def-val">spt_center_def</a> : thm
<a name="line199"></a>    val <a href="#spt_center_ind-val">spt_center_ind</a> : thm
<a name="line200"></a>    val <a href="#spt_centers_def-val">spt_centers_def</a> : thm
<a name="line201"></a>    val <a href="#spt_centers_expand_rle-val">spt_centers_expand_rle</a> : thm
<a name="line202"></a>    val <a href="#spt_centers_expand_rle_imp-val">spt_centers_expand_rle_imp</a> : thm
<a name="line203"></a>    val <a href="#spt_centers_ind-val">spt_centers_ind</a> : thm
<a name="line204"></a>    val <a href="#spt_centers_ord-val">spt_centers_ord</a> : thm
<a name="line205"></a>    val <a href="#spt_distinct-val">spt_distinct</a> : thm
<a name="line206"></a>    val <a href="#spt_eq_thm-val">spt_eq_thm</a> : thm
<a name="line207"></a>    val <a href="#spt_induction-val">spt_induction</a> : thm
<a name="line208"></a>    val <a href="#spt_nchotomy-val">spt_nchotomy</a> : thm
<a name="line209"></a>    val <a href="#spts_to_alist_def-val">spts_to_alist_def</a> : thm
<a name="line210"></a>    val <a href="#spts_to_alist_ind-val">spts_to_alist_ind</a> : thm
<a name="line211"></a>    val <a href="#subspt_FOLDL_union-val">subspt_FOLDL_union</a> : thm
<a name="line212"></a>    val <a href="#subspt_LN-val">subspt_LN</a> : thm
<a name="line213"></a>    val <a href="#subspt_def-val">subspt_def</a> : thm
<a name="line214"></a>    val <a href="#subspt_domain-val">subspt_domain</a> : thm
<a name="line215"></a>    val <a href="#subspt_lookup-val">subspt_lookup</a> : thm
<a name="line216"></a>    val <a href="#subspt_refl-val">subspt_refl</a> : thm
<a name="line217"></a>    val <a href="#subspt_trans-val">subspt_trans</a> : thm
<a name="line218"></a>    val <a href="#subspt_union-val">subspt_union</a> : thm
<a name="line219"></a>    val <a href="#sum_size_combine_rle_LE-val">sum_size_combine_rle_LE</a> : thm
<a name="line220"></a>    val <a href="#toListA_append-val">toListA_append</a> : thm
<a name="line221"></a>    val <a href="#toList_map-val">toList_map</a> : thm
<a name="line222"></a>    val <a href="#toSortedAList_fromList-val">toSortedAList_fromList</a> : thm
<a name="line223"></a>    val <a href="#union_LN-val">union_LN</a> : thm
<a name="line224"></a>    val <a href="#union_assoc-val">union_assoc</a> : thm
<a name="line225"></a>    val <a href="#union_disjoint_sym-val">union_disjoint_sym</a> : thm
<a name="line226"></a>    val <a href="#union_insert_LN-val">union_insert_LN</a> : thm
<a name="line227"></a>    val <a href="#union_mk_wf-val">union_mk_wf</a> : thm
<a name="line228"></a>    val <a href="#union_num_set_sym-val">union_num_set_sym</a> : thm
<a name="line229"></a>    val <a href="#wf_LN-val">wf_LN</a> : thm
<a name="line230"></a>    val <a href="#wf_delete-val">wf_delete</a> : thm
<a name="line231"></a>    val <a href="#wf_difference-val">wf_difference</a> : thm
<a name="line232"></a>    val <a href="#wf_filter_v-val">wf_filter_v</a> : thm
<a name="line233"></a>    val <a href="#wf_fromAList-val">wf_fromAList</a> : thm
<a name="line234"></a>    val <a href="#wf_fromList-val">wf_fromList</a> : thm
<a name="line235"></a>    val <a href="#wf_insert-val">wf_insert</a> : thm
<a name="line236"></a>    val <a href="#wf_inter-val">wf_inter</a> : thm
<a name="line237"></a>    val <a href="#wf_map-val">wf_map</a> : thm
<a name="line238"></a>    val <a href="#wf_mapi-val">wf_mapi</a> : thm
<a name="line239"></a>    val <a href="#wf_mk_BN-val">wf_mk_BN</a> : thm
<a name="line240"></a>    val <a href="#wf_mk_BS-val">wf_mk_BS</a> : thm
<a name="line241"></a>    val <a href="#wf_mk_id-val">wf_mk_id</a> : thm
<a name="line242"></a>    val <a href="#wf_mk_wf-val">wf_mk_wf</a> : thm
<a name="line243"></a>    val <a href="#wf_union-val">wf_union</a> : thm
<a name="line244"></a>  
<a name="line245"></a>  val sptree_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line246"></a>(*
   [alist] Parent theory of "sptree"
   
   [logroot] Parent theory of "sptree"
   
   [<a name="apsnd_cons_def-val"><b>apsnd_cons_def</b></a>]  Definition
      
      ⊢ ∀x y xs. apsnd_cons x (y,xs) = (y,x::xs)
   
   [<a name="delete_def-val"><b>delete_def</b></a>]  Definition
      
      ⊢ (∀k. isEmpty (delete k LN)) ∧
        (∀k a. delete k ⦕ 0 ↦ a ⦖ = if k = 0 then LN else ⦕ 0 ↦ a ⦖) ∧
        (∀k t1 t2.
           delete k (BN t1 t2) =
           if k = 0 then BN t1 t2
           else if EVEN k then mk_BN (delete ((k − 1) DIV 2) t1) t2
           else mk_BN t1 (delete ((k − 1) DIV 2) t2)) ∧
        ∀k t1 a t2.
          delete k (BS t1 a t2) =
          if k = 0 then BN t1 t2
          else if EVEN k then mk_BS (delete ((k − 1) DIV 2) t1) a t2
          else mk_BS t1 a (delete ((k − 1) DIV 2) t2)
   
   [<a name="difference_def-val"><b>difference_def</b></a>]  Definition
      
      ⊢ (∀t. isEmpty (difference LN t)) ∧
        (∀a t.
           difference ⦕ 0 ↦ a ⦖ t =
           case t of
             LN =&gt; ⦕ 0 ↦ a ⦖
           | ⦕ 0 ↦ b ⦖ =&gt; LN
           | BN t1 t2 =&gt; ⦕ 0 ↦ a ⦖
           | BS t1' b' t2' =&gt; LN) ∧
        (∀t1 t2 t.
           difference (BN t1 t2) t =
           case t of
             LN =&gt; BN t1 t2
           | ⦕ 0 ↦ a ⦖ =&gt; BN t1 t2
           | BN t1' t2' =&gt; mk_BN (difference t1 t1') (difference t2 t2')
           | BS t1'' a'' t2'' =&gt;
             mk_BN (difference t1 t1'') (difference t2 t2'')) ∧
        ∀t1 a t2 t.
          difference (BS t1 a t2) t =
          case t of
            LN =&gt; BS t1 a t2
          | ⦕ 0 ↦ a' ⦖ =&gt; BN t1 t2
          | BN t1' t2' =&gt; mk_BS (difference t1 t1') a (difference t2 t2')
          | BS t1'' a'³' t2'' =&gt;
            mk_BN (difference t1 t1'') (difference t2 t2'')
   
   [<a name="domain_def-val"><b>domain_def</b></a>]  Definition
      
      ⊢ domain LN = ∅ ∧ (∀v0. domain ⦕ 0 ↦ v0 ⦖ = {0}) ∧
        (∀t1 t2.
           domain (BN t1 t2) =
           IMAGE (λn. 2 * n + 2) (domain t1) ∪
           IMAGE (λn. 2 * n + 1) (domain t2)) ∧
        ∀t1 v1 t2.
          domain (BS t1 v1 t2) =
          {0} ∪ IMAGE (λn. 2 * n + 2) (domain t1) ∪
          IMAGE (λn. 2 * n + 1) (domain t2)
   
   [<a name="expand_rle_def-val"><b>expand_rle_def</b></a>]  Definition
      
      ⊢ ∀xs. expand_rle xs = FLAT (MAP (λ(i,t). REPLICATE i t) xs)
   
   [<a name="filter_v_def-val"><b>filter_v_def</b></a>]  Definition
      
      ⊢ (∀f. isEmpty (filter_v f LN)) ∧
        (∀f x. filter_v f ⦕ 0 ↦ x ⦖ = if f x then ⦕ 0 ↦ x ⦖ else LN) ∧
        (∀f l r. filter_v f (BN l r) = mk_BN (filter_v f l) (filter_v f r)) ∧
        ∀f l x r.
          filter_v f (BS l x r) =
          if f x then mk_BS (filter_v f l) x (filter_v f r)
          else mk_BN (filter_v f l) (filter_v f r)
   
   [<a name="foldi_def-val"><b>foldi_def</b></a>]  Definition
      
      ⊢ (∀f i acc. foldi f i acc LN = acc) ∧
        (∀f i acc a. foldi f i acc ⦕ 0 ↦ a ⦖ = f i a acc) ∧
        (∀f i acc t1 t2.
           foldi f i acc (BN t1 t2) =
           (let
              inc = sptree$lrnext i
            in
              foldi f (i + inc) (foldi f (i + 2 * inc) acc t1) t2)) ∧
        ∀f i acc t1 a t2.
          foldi f i acc (BS t1 a t2) =
          (let
             inc = sptree$lrnext i
           in
             foldi f (i + inc) (f i a (foldi f (i + 2 * inc) acc t1)) t2)
   
   [<a name="fromAList_def_primitive-val"><b>fromAList_def_primitive</b></a>]  Definition
      
      ⊢ fromAList =
        WFREC (@R. WF R ∧ ∀y x xs. R xs ((x,y)::xs))
          (λfromAList a.
               case a of
                 [] =&gt; I LN
               | (x,y)::xs =&gt; I (insert x y (fromAList xs)))
   
   [<a name="fromList_def-val"><b>fromList_def</b></a>]  Definition
      
      ⊢ ∀l. fromList l =
            SND (FOLDL (λ(i,t) a. (i + 1,insert i a t)) (0,LN) l)
   
   [<a name="inter_def-val"><b>inter_def</b></a>]  Definition
      
      ⊢ (∀t. isEmpty (inter LN t)) ∧
        (∀a t.
           inter ⦕ 0 ↦ a ⦖ t =
           case t of
             LN =&gt; LN
           | ⦕ 0 ↦ b ⦖ =&gt; ⦕ 0 ↦ a ⦖
           | BN t1 t2 =&gt; LN
           | BS t1' v4 t2' =&gt; ⦕ 0 ↦ a ⦖) ∧
        (∀t1 t2 t.
           inter (BN t1 t2) t =
           case t of
             LN =&gt; LN
           | ⦕ 0 ↦ a ⦖ =&gt; LN
           | BN t1' t2' =&gt; mk_BN (inter t1 t1') (inter t2 t2')
           | BS t1'' a'' t2'' =&gt; mk_BN (inter t1 t1'') (inter t2 t2'')) ∧
        ∀t1 a t2 t.
          inter (BS t1 a t2) t =
          case t of
            LN =&gt; LN
          | ⦕ 0 ↦ a' ⦖ =&gt; ⦕ 0 ↦ a ⦖
          | BN t1' t2' =&gt; mk_BN (inter t1 t1') (inter t2 t2')
          | BS t1'' a'³' t2'' =&gt; mk_BS (inter t1 t1'') a (inter t2 t2'')
   
   [<a name="inter_eq_def-val"><b>inter_eq_def</b></a>]  Definition
      
      ⊢ (∀t. isEmpty (inter_eq LN t)) ∧
        (∀a t.
           inter_eq ⦕ 0 ↦ a ⦖ t =
           case t of
             LN =&gt; LN
           | ⦕ 0 ↦ b ⦖ =&gt; if a = b then ⦕ 0 ↦ a ⦖ else LN
           | BN t1 t2 =&gt; LN
           | BS t1' b' t2' =&gt; if a = b' then ⦕ 0 ↦ a ⦖ else LN) ∧
        (∀t1 t2 t.
           inter_eq (BN t1 t2) t =
           case t of
             LN =&gt; LN
           | ⦕ 0 ↦ a ⦖ =&gt; LN
           | BN t1' t2' =&gt; mk_BN (inter_eq t1 t1') (inter_eq t2 t2')
           | BS t1'' a'' t2'' =&gt;
             mk_BN (inter_eq t1 t1'') (inter_eq t2 t2'')) ∧
        ∀t1 a t2 t.
          inter_eq (BS t1 a t2) t =
          case t of
            LN =&gt; LN
          | ⦕ 0 ↦ a' ⦖ =&gt; if a' = a then ⦕ 0 ↦ a ⦖ else LN
          | BN t1' t2' =&gt; mk_BN (inter_eq t1 t1') (inter_eq t2 t2')
          | BS t1'' a'³' t2'' =&gt;
            if a'³' = a then mk_BS (inter_eq t1 t1'') a (inter_eq t2 t2'')
            else mk_BN (inter_eq t1 t1'') (inter_eq t2 t2'')
   
   [<a name="list_insert_def-val"><b>list_insert_def</b></a>]  Definition
      
      ⊢ (∀t. list_insert [] t = t) ∧
        ∀n ns t. list_insert (n::ns) t = list_insert ns (insert n () t)
   
   [<a name="list_to_num_set_def-val"><b>list_to_num_set_def</b></a>]  Definition
      
      ⊢ isEmpty (list_to_num_set []) ∧
        ∀n ns. list_to_num_set (n::ns) = insert n () (list_to_num_set ns)
   
   [<a name="lrnext_def_primitive-val"><b>lrnext_def_primitive</b></a>]  Definition
      
      ⊢ sptree$lrnext =
        WFREC (@R. WF R ∧ ∀n. n ≠ 0 ⇒ R ((n − 1) DIV 2) n)
          (λlrnext a. I (if a = 0 then 1 else 2 * lrnext ((a − 1) DIV 2)))
   
   [<a name="map_def-val"><b>map_def</b></a>]  Definition
      
      ⊢ (∀f. isEmpty (map f LN)) ∧ (∀f a. map f ⦕ 0 ↦ a ⦖ = ⦕ 0 ↦ f a ⦖) ∧
        (∀f t1 t2. map f (BN t1 t2) = BN (map f t1) (map f t2)) ∧
        ∀f t1 a t2. map f (BS t1 a t2) = BS (map f t1) (f a) (map f t2)
   
   [<a name="mapi0_def-val"><b>mapi0_def</b></a>]  Definition
      
      ⊢ (∀f i. isEmpty (mapi0 f i LN)) ∧
        (∀f i a. mapi0 f i ⦕ 0 ↦ a ⦖ = ⦕ 0 ↦ f i a ⦖) ∧
        (∀f i t1 t2.
           mapi0 f i (BN t1 t2) =
           (let
              inc = sptree$lrnext i
            in
              mk_BN (mapi0 f (i + 2 * inc) t1) (mapi0 f (i + inc) t2))) ∧
        ∀f i t1 a t2.
          mapi0 f i (BS t1 a t2) =
          (let
             inc = sptree$lrnext i
           in
             mk_BS (mapi0 f (i + 2 * inc) t1) (f i a)
               (mapi0 f (i + inc) t2))
   
   [<a name="mapi_def-val"><b>mapi_def</b></a>]  Definition
      
      ⊢ ∀f pt. mapi f pt = mapi0 f 0 pt
   
   [<a name="mk_wf_def-val"><b>mk_wf_def</b></a>]  Definition
      
      ⊢ isEmpty (mk_wf LN) ∧ (∀x. mk_wf ⦕ 0 ↦ x ⦖ = ⦕ 0 ↦ x ⦖) ∧
        (∀t1 t2. mk_wf (BN t1 t2) = mk_BN (mk_wf t1) (mk_wf t2)) ∧
        ∀t1 x t2. mk_wf (BS t1 x t2) = mk_BS (mk_wf t1) x (mk_wf t2)
   
   [<a name="size_def-val"><b>size_def</b></a>]  Definition
      
      ⊢ size LN = 0 ∧ (∀a. size ⦕ 0 ↦ a ⦖ = 1) ∧
        (∀t1 t2. size (BN t1 t2) = size t1 + size t2) ∧
        ∀t1 a t2. size (BS t1 a t2) = size t1 + size t2 + 1
   
   [<a name="spt_TY_DEF-val"><b>spt_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep.
          TYPE_DEFINITION
            (λa0'.
                 ∀ $var$('spt').
                   (∀a0'.
                      a0' = ind_type$CONSTR 0 ARB (λn. ind_type$BOTTOM) ∨
                      (∃a. a0' =
                           (λa.
                                ind_type$CONSTR (SUC 0) a
                                  (λn. ind_type$BOTTOM)) a) ∨
                      (∃a0 a1.
                         a0' =
                         (λa0 a1.
                              ind_type$CONSTR (SUC (SUC 0)) ARB
                                (ind_type$FCONS a0
                                   (ind_type$FCONS a1 (λn. ind_type$BOTTOM))))
                           a0 a1 ∧ $var$('spt') a0 ∧ $var$('spt') a1) ∨
                      (∃a0 a1 a2.
                         a0' =
                         (λa0 a1 a2.
                              ind_type$CONSTR (SUC (SUC (SUC 0))) a1
                                (ind_type$FCONS a0
                                   (ind_type$FCONS a2 (λn. ind_type$BOTTOM))))
                           a0 a1 a2 ∧ $var$('spt') a0 ∧ $var$('spt') a2) ⇒
                      $var$('spt') a0') ⇒
                   $var$('spt') a0') rep
   
   [<a name="spt_case_def-val"><b>spt_case_def</b></a>]  Definition
      
      ⊢ (∀v f f1 f2. spt_CASE LN v f f1 f2 = v) ∧
        (∀a v f f1 f2. spt_CASE ⦕ 0 ↦ a ⦖ v f f1 f2 = f a) ∧
        (∀a0 a1 v f f1 f2. spt_CASE (BN a0 a1) v f f1 f2 = f1 a0 a1) ∧
        ∀a0 a1 a2 v f f1 f2. spt_CASE (BS a0 a1 a2) v f f1 f2 = f2 a0 a1 a2
   
   [<a name="spt_center_def_primitive-val"><b>spt_center_def_primitive</b></a>]  Definition
      
      ⊢ spt_center =
        WFREC (@R. WF R)
          (λspt_center a.
               case a of
                 LN =&gt; I NONE
               | ⦕ 0 ↦ x ⦖ =&gt; I (SOME x)
               | BN v7 v8 =&gt; I NONE
               | BS t1 x' t2 =&gt; I (SOME x'))
   
   [<a name="spt_fold_def-val"><b>spt_fold_def</b></a>]  Definition
      
      ⊢ (∀f acc. spt_fold f acc LN = acc) ∧
        (∀f acc a. spt_fold f acc ⦕ 0 ↦ a ⦖ = f a acc) ∧
        (∀f acc t1 t2.
           spt_fold f acc (BN t1 t2) = spt_fold f (spt_fold f acc t1) t2) ∧
        ∀f acc t1 a t2.
          spt_fold f acc (BS t1 a t2) =
          spt_fold f (f a (spt_fold f acc t1)) t2
   
   [<a name="spt_left_def-val"><b>spt_left_def</b></a>]  Definition
      
      ⊢ isEmpty (spt_left LN) ∧ (∀x. isEmpty (spt_left ⦕ 0 ↦ x ⦖)) ∧
        (∀t1 t2. spt_left (BN t1 t2) = t1) ∧
        ∀t1 x t2. spt_left (BS t1 x t2) = t1
   
   [<a name="spt_right_def-val"><b>spt_right_def</b></a>]  Definition
      
      ⊢ isEmpty (spt_right LN) ∧ (∀x. isEmpty (spt_right ⦕ 0 ↦ x ⦖)) ∧
        (∀t1 t2. spt_right (BN t1 t2) = t2) ∧
        ∀t1 x t2. spt_right (BS t1 x t2) = t2
   
   [<a name="spt_size_def-val"><b>spt_size_def</b></a>]  Definition
      
      ⊢ (∀f. spt_size f LN = 0) ∧ (∀f a. spt_size f ⦕ 0 ↦ a ⦖ = 1 + f a) ∧
        (∀f a0 a1.
           spt_size f (BN a0 a1) = 1 + (spt_size f a0 + spt_size f a1)) ∧
        ∀f a0 a1 a2.
          spt_size f (BS a0 a1 a2) =
          1 + (spt_size f a0 + (f a1 + spt_size f a2))
   
   [<a name="subspt_eq-val"><b>subspt_eq</b></a>]  Definition
      
      ⊢ (∀t. subspt LN t ⇔ T) ∧
        (∀x t. subspt ⦕ 0 ↦ x ⦖ t ⇔ spt_center t = SOME x) ∧
        (∀t1 t2 t.
           subspt (BN t1 t2) t ⇔
           subspt t1 (spt_left t) ∧ subspt t2 (spt_right t)) ∧
        ∀t1 x t2 t.
          subspt (BS t1 x t2) t ⇔
          spt_center t = SOME x ∧ subspt t1 (spt_left t) ∧
          subspt t2 (spt_right t)
   
   [<a name="toAList_def-val"><b>toAList_def</b></a>]  Definition
      
      ⊢ toAList = foldi (λk v a. (k,v)::a) 0 []
   
   [<a name="toListA_def-val"><b>toListA_def</b></a>]  Definition
      
      ⊢ (∀acc. toListA acc LN = acc) ∧
        (∀acc a. toListA acc ⦕ 0 ↦ a ⦖ = a::acc) ∧
        (∀acc t1 t2. toListA acc (BN t1 t2) = toListA (toListA acc t2) t1) ∧
        ∀acc t1 a t2.
          toListA acc (BS t1 a t2) = toListA (a::toListA acc t2) t1
   
   [<a name="toList_def-val"><b>toList_def</b></a>]  Definition
      
      ⊢ ∀m. toList m = toListA [] m
   
   [<a name="toSortedAList_def-val"><b>toSortedAList_def</b></a>]  Definition
      
      ⊢ ∀spt. toSortedAList spt = spts_to_alist 0 [(1,spt)]
   
   [<a name="union_def-val"><b>union_def</b></a>]  Definition
      
      ⊢ (∀t. union LN t = t) ∧
        (∀a t.
           union ⦕ 0 ↦ a ⦖ t =
           case t of
             LN =&gt; ⦕ 0 ↦ a ⦖
           | ⦕ 0 ↦ b ⦖ =&gt; ⦕ 0 ↦ a ⦖
           | BN t1 t2 =&gt; BS t1 a t2
           | BS t1' v4 t2' =&gt; BS t1' a t2') ∧
        (∀t1 t2 t.
           union (BN t1 t2) t =
           case t of
             LN =&gt; BN t1 t2
           | ⦕ 0 ↦ a ⦖ =&gt; BS t1 a t2
           | BN t1' t2' =&gt; BN (union t1 t1') (union t2 t2')
           | BS t1'' a'' t2'' =&gt; BS (union t1 t1'') a'' (union t2 t2'')) ∧
        ∀t1 a t2 t.
          union (BS t1 a t2) t =
          case t of
            LN =&gt; BS t1 a t2
          | ⦕ 0 ↦ a' ⦖ =&gt; BS t1 a t2
          | BN t1' t2' =&gt; BS (union t1 t1') a (union t2 t2')
          | BS t1'' a'³' t2'' =&gt; BS (union t1 t1'') a (union t2 t2'')
   
   [<a name="wf_def-val"><b>wf_def</b></a>]  Definition
      
      ⊢ (wf LN ⇔ T) ∧ (∀a. wf ⦕ 0 ↦ a ⦖ ⇔ T) ∧
        (∀t1 t2. wf (BN t1 t2) ⇔ wf t1 ∧ wf t2 ∧ ¬(isEmpty t1 ∧ isEmpty t2)) ∧
        ∀t1 a t2.
          wf (BS t1 a t2) ⇔ wf t1 ∧ wf t2 ∧ ¬(isEmpty t1 ∧ isEmpty t2)
   
   [<a name="ALL_DISTINCT_MAP_FST_toAList-val"><b>ALL_DISTINCT_MAP_FST_toAList</b></a>]  Theorem
      
      ⊢ ∀t. ALL_DISTINCT (MAP FST (toAList t))
   
   [<a name="ALL_DISTINCT_MAP_FST_toSortedAList-val"><b>ALL_DISTINCT_MAP_FST_toSortedAList</b></a>]  Theorem
      
      ⊢ ALL_DISTINCT (MAP FST (toSortedAList t))
   
   [<a name="ALOOKUP_toAList-val"><b>ALOOKUP_toAList</b></a>]  Theorem
      
      ⊢ ∀t x. ALOOKUP (toAList t) x = lookup x t
   
   [<a name="ALOOKUP_toSortedAList-val"><b>ALOOKUP_toSortedAList</b></a>]  Theorem
      
      ⊢ ALOOKUP (toSortedAList spt) i = lookup i spt
   
   [<a name="EVERY_combine_rle-val"><b>EVERY_combine_rle</b></a>]  Theorem
      
      ⊢ ∀P xs. EVERY (Q ∘ SND) (combine_rle P xs) ⇔ EVERY (Q ∘ SND) xs
   
   [<a name="EVERY_empty_SND_combine-val"><b>EVERY_empty_SND_combine</b></a>]  Theorem
      
      ⊢ ∀xs.
          EVERY ((λt. isEmpty t) ∘ SND) xs ⇒
          xs = [] ∨
          ∃n. combine_rle (λt. isEmpty t) xs = [(n,LN)] ∧
              expand_rle xs = REPLICATE n LN
   
   [<a name="FINITE_domain-val"><b>FINITE_domain</b></a>]  Theorem
      
      ⊢ FINITE (domain t)
   
   [<a name="IMP_size_LESS_size-val"><b>IMP_size_LESS_size</b></a>]  Theorem
      
      ⊢ ∀x y. subspt x y ∧ domain x ≠ domain y ⇒ size x &lt; size y
   
   [<a name="IN_domain-val"><b>IN_domain</b></a>]  Theorem
      
      ⊢ ∀n x t1 t2.
          (n ∈ domain LN ⇔ F) ∧ (n ∈ domain ⦕ 0 ↦ x ⦖ ⇔ n = 0) ∧
          (n ∈ domain (BN t1 t2) ⇔
           n ≠ 0 ∧
           if EVEN n then (n − 1) DIV 2 ∈ domain t1
           else (n − 1) DIV 2 ∈ domain t2) ∧
          (n ∈ domain (BS t1 x t2) ⇔
           n = 0 ∨
           if EVEN n then (n − 1) DIV 2 ∈ domain t1
           else (n − 1) DIV 2 ∈ domain t2)
   
   [<a name="LENGTH_toAList-val"><b>LENGTH_toAList</b></a>]  Theorem
      
      ⊢ LENGTH (toAList t) = size t
   
   [<a name="LENGTH_toSortedAList-val"><b>LENGTH_toSortedAList</b></a>]  Theorem
      
      ⊢ LENGTH (toSortedAList t) = size t
   
   [<a name="MAP_foldi-val"><b>MAP_foldi</b></a>]  Theorem
      
      ⊢ ∀n acc.
          MAP f (foldi (λk v a. (k,v)::a) n acc pt) =
          foldi (λk v a. f (k,v)::a) n (MAP f acc) pt
   
   [<a name="MEM_spts_to_alist-val"><b>MEM_spts_to_alist</b></a>]  Theorem
      
      ⊢ ∀n xs i x.
          rle_wf xs ⇒
          (MEM (i,x) (spts_to_alist n xs) ⇔
           ∃j k.
             j &lt; LENGTH (expand_rle xs) ∧
             lookup k (EL j (expand_rle xs)) = SOME x ∧
             i = n + j + k * LENGTH (expand_rle xs))
   
   [<a name="MEM_toAList-val"><b>MEM_toAList</b></a>]  Theorem
      
      ⊢ ∀t k v. MEM (k,v) (toAList t) ⇔ lookup k t = SOME v
   
   [<a name="MEM_toList-val"><b>MEM_toList</b></a>]  Theorem
      
      ⊢ ∀x t. MEM x (toList t) ⇔ ∃k. lookup k t = SOME x
   
   [<a name="MEM_toSortedAList-val"><b>MEM_toSortedAList</b></a>]  Theorem
      
      ⊢ MEM (i,x) (toSortedAList spt) ⇔ lookup i spt = SOME x
   
   [<a name="SORTED_spts_to_alist_lemma-val"><b>SORTED_spts_to_alist_lemma</b></a>]  Theorem
      
      ⊢ ∀n xs.
          rle_wf xs ⇒
          SORTED $&lt; (MAP FST (spts_to_alist n xs)) ∧
          ∀k. k ≤ n ⇒ EVERY (λt. FST t ≥ k) (spts_to_alist n xs)
   
   [<a name="SORTED_toSortedAList-val"><b>SORTED_toSortedAList</b></a>]  Theorem
      
      ⊢ SORTED $&lt; (MAP FST (toSortedAList spt))
   
   [<a name="SUM_MAP_same_LE-val"><b>SUM_MAP_same_LE</b></a>]  Theorem
      
      ⊢ EVERY (λx. f x ≤ g x) xs ⇒ SUM (MAP f xs) ≤ SUM (MAP g xs)
   
   [<a name="SUM_MAP_same_LESS-val"><b>SUM_MAP_same_LESS</b></a>]  Theorem
      
      ⊢ EVERY (λx. f x ≤ g x) xs ∧ EXISTS (λx. f x &lt; g x) xs ⇒
        SUM (MAP f xs) &lt; SUM (MAP g xs)
   
   [<a name="alist_insert_REVERSE-val"><b>alist_insert_REVERSE</b></a>]  Theorem
      
      ⊢ ∀xs ys s.
          ALL_DISTINCT xs ∧ LENGTH xs = LENGTH ys ⇒
          alist_insert (REVERSE xs) (REVERSE ys) s = alist_insert xs ys s
   
   [<a name="alist_insert_append-val"><b>alist_insert_append</b></a>]  Theorem
      
      ⊢ ∀a1 a2 s b1 b2.
          LENGTH a1 = LENGTH a2 ⇒
          alist_insert (a1 ⧺ b1) (a2 ⧺ b2) s =
          alist_insert a1 a2 (alist_insert b1 b2 s)
   
   [<a name="alist_insert_def-val"><b>alist_insert_def</b></a>]  Theorem
      
      ⊢ (∀xs t. alist_insert [] xs t = t) ∧
        (∀v6 v5 t. alist_insert (v5::v6) [] t = t) ∧
        ∀xs x vs v t.
          alist_insert (v::vs) (x::xs) t =
          insert v x (alist_insert vs xs t)
   
   [<a name="alist_insert_ind-val"><b>alist_insert_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀xs t. P [] xs t) ∧ (∀v5 v6 t. P (v5::v6) [] t) ∧
            (∀v vs x xs t. P vs xs t ⇒ P (v::vs) (x::xs) t) ⇒
            ∀v v1 v2. P v v1 v2
   
   [<a name="alist_insert_pull_insert-val"><b>alist_insert_pull_insert</b></a>]  Theorem
      
      ⊢ ∀xs ys z.
          ¬MEM x xs ⇒
          alist_insert xs ys (insert x y z) =
          insert x y (alist_insert xs ys z)
   
   [<a name="apsnd_cons_is_case-val"><b>apsnd_cons_is_case</b></a>]  Theorem
      
      ⊢ apsnd_cons x t = case t of (y,xs) =&gt; (y,x::xs)
   
   [<a name="combine_rle_def-val"><b>combine_rle_def</b></a>]  Theorem
      
      ⊢ (∀v0. combine_rle v0 [] = []) ∧ (∀v1 t. combine_rle v1 [t] = [t]) ∧
        ∀y xs x j i P.
          combine_rle P ((i,x)::(j,y)::xs) =
          if P x ∧ x = y then combine_rle P ((i + j,x)::xs)
          else (i,x)::combine_rle P ((j,y)::xs)
   
   [<a name="combine_rle_ind-val"><b>combine_rle_ind</b></a>]  Theorem
      
      ⊢ ∀P'.
          (∀v0. P' v0 []) ∧ (∀v1 t. P' v1 [t]) ∧
          (∀P i x j y xs.
             (¬(P x ∧ x = y) ⇒ P' P ((j,y)::xs)) ∧
             (P x ∧ x = y ⇒ P' P ((i + j,x)::xs)) ⇒
             P' P ((i,x)::(j,y)::xs)) ⇒
          ∀v v1. P' v v1
   
   [<a name="combine_rle_ind2-val"><b>combine_rle_ind2</b></a>]  Theorem
      
      ⊢ ∀P3 P4.
          P4 [] ∧ (∀t. P4 [t]) ∧
          (∀i x j y xs.
             ((x = y ⇒ ¬P3 y) ⇒ P4 ((j,y)::xs)) ∧
             (P3 x ∧ x = y ⇒ P4 ((i + j,y)::xs)) ⇒
             P4 ((i,x)::(j,y)::xs)) ⇒
          ∀v1. P4 v1
   
   [<a name="combine_rle_props-val"><b>combine_rle_props</b></a>]  Theorem
      
      ⊢ ∀xs.
          rle_wf xs ⇒
          rle_wf (combine_rle (λt. isEmpty t) xs) ∧
          rle_wf
            (MAP (λ(i,t). (i,spt_right t)) (combine_rle (λt. isEmpty t) xs)) ∧
          rle_wf
            (MAP (λ(i,t). (i,spt_left t)) (combine_rle (λt. isEmpty t) xs))
   
   [<a name="datatype_spt-val"><b>datatype_spt</b></a>]  Theorem
      
      ⊢ DATATYPE (spt LN LS BN BS)
   
   [<a name="delete_compute-val"><b>delete_compute</b></a>]  Theorem
      
      ⊢ delete (NUMERAL n) t = delete n t ∧ isEmpty (delete 0 LN) ∧
        isEmpty (delete 0 ⦕ 0 ↦ a ⦖) ∧ delete 0 (BN t1 t2) = BN t1 t2 ∧
        delete 0 (BS t1 a t2) = BN t1 t2 ∧ isEmpty (delete ZERO LN) ∧
        isEmpty (delete ZERO ⦕ 0 ↦ a ⦖) ∧
        delete ZERO (BN t1 t2) = BN t1 t2 ∧
        delete ZERO (BS t1 a t2) = BN t1 t2 ∧
        isEmpty (delete (BIT1 n) LN) ∧
        delete (BIT1 n) ⦕ 0 ↦ a ⦖ = ⦕ 0 ↦ a ⦖ ∧
        delete (BIT1 n) (BN t1 t2) = mk_BN t1 (delete n t2) ∧
        delete (BIT1 n) (BS t1 a t2) = mk_BS t1 a (delete n t2) ∧
        isEmpty (delete (BIT2 n) LN) ∧
        delete (BIT2 n) ⦕ 0 ↦ a ⦖ = ⦕ 0 ↦ a ⦖ ∧
        delete (BIT2 n) (BN t1 t2) = mk_BN (delete n t1) t2 ∧
        delete (BIT2 n) (BS t1 a t2) = mk_BS (delete n t1) a t2
   
   [<a name="delete_delete-val"><b>delete_delete</b></a>]  Theorem
      
      ⊢ ∀f n k.
          delete n (delete k f) =
          if n = k then delete n f else delete k (delete n f)
   
   [<a name="delete_fail-val"><b>delete_fail</b></a>]  Theorem
      
      ⊢ ∀n t. wf t ⇒ (n ∉ domain t ⇔ delete n t = t)
   
   [<a name="delete_mk_wf-val"><b>delete_mk_wf</b></a>]  Theorem
      
      ⊢ ∀x t. delete x (mk_wf t) = mk_wf (delete x t)
   
   [<a name="difference_sub-val"><b>difference_sub</b></a>]  Theorem
      
      ⊢ isEmpty (difference a b) ⇒ domain a ⊆ domain b
   
   [<a name="domain_FOLDR_delete-val"><b>domain_FOLDR_delete</b></a>]  Theorem
      
      ⊢ ∀ls live. domain (FOLDR delete live ls) = domain live DIFF set ls
   
   [<a name="domain_alist_insert-val"><b>domain_alist_insert</b></a>]  Theorem
      
      ⊢ ∀a b locs.
          LENGTH a = LENGTH b ⇒
          domain (alist_insert a b locs) = domain locs ∪ set a
   
   [<a name="domain_delete-val"><b>domain_delete</b></a>]  Theorem
      
      ⊢ domain (delete k t) = domain t DELETE k
   
   [<a name="domain_difference-val"><b>domain_difference</b></a>]  Theorem
      
      ⊢ ∀t1 t2. domain (difference t1 t2) = domain t1 DIFF domain t2
   
   [<a name="domain_empty-val"><b>domain_empty</b></a>]  Theorem
      
      ⊢ ∀t. wf t ⇒ (isEmpty t ⇔ domain t = ∅)
   
   [<a name="domain_eq-val"><b>domain_eq</b></a>]  Theorem
      
      ⊢ ∀t1 t2.
          domain t1 = domain t2 ⇔
          ∀k. lookup k t1 = NONE ⇔ lookup k t2 = NONE
   
   [<a name="domain_foldi-val"><b>domain_foldi</b></a>]  Theorem
      
      ⊢ domain t = foldi (λk v a. k INSERT a) 0 ∅ t
   
   [<a name="domain_fromAList-val"><b>domain_fromAList</b></a>]  Theorem
      
      ⊢ ∀ls. domain (fromAList ls) = set (MAP FST ls)
   
   [<a name="domain_fromList-val"><b>domain_fromList</b></a>]  Theorem
      
      ⊢ domain (fromList l) = count (LENGTH l)
   
   [<a name="domain_insert-val"><b>domain_insert</b></a>]  Theorem
      
      ⊢ domain (insert k v t) = k INSERT domain t
   
   [<a name="domain_inter-val"><b>domain_inter</b></a>]  Theorem
      
      ⊢ domain (inter t1 t2) = domain t1 ∩ domain t2
   
   [<a name="domain_list_insert-val"><b>domain_list_insert</b></a>]  Theorem
      
      ⊢ ∀xs x t. x ∈ domain (list_insert xs t) ⇔ MEM x xs ∨ x ∈ domain t
   
   [<a name="domain_list_to_num_set-val"><b>domain_list_to_num_set</b></a>]  Theorem
      
      ⊢ ∀xs. x ∈ domain (list_to_num_set xs) ⇔ MEM x xs
   
   [<a name="domain_lookup-val"><b>domain_lookup</b></a>]  Theorem
      
      ⊢ ∀t k. k ∈ domain t ⇔ ∃v. lookup k t = SOME v
   
   [<a name="domain_map-val"><b>domain_map</b></a>]  Theorem
      
      ⊢ ∀s. domain (map f s) = domain s
   
   [<a name="domain_mapi-val"><b>domain_mapi</b></a>]  Theorem
      
      ⊢ domain (mapi f x) = domain x
   
   [<a name="domain_mk_wf-val"><b>domain_mk_wf</b></a>]  Theorem
      
      ⊢ ∀t. domain (mk_wf t) = domain t
   
   [<a name="domain_sing-val"><b>domain_sing</b></a>]  Theorem
      
      ⊢ domain (insert k v LN) = {k}
   
   [<a name="domain_union-val"><b>domain_union</b></a>]  Theorem
      
      ⊢ domain (union t1 t2) = domain t1 ∪ domain t2
   
   [<a name="expand_rle_append-val"><b>expand_rle_append</b></a>]  Theorem
      
      ⊢ expand_rle (xs ⧺ ys) = expand_rle xs ⧺ expand_rle ys
   
   [<a name="expand_rle_combine_rle-val"><b>expand_rle_combine_rle</b></a>]  Theorem
      
      ⊢ ∀P xs. expand_rle (combine_rle P xs) = expand_rle xs
   
   [<a name="expand_rle_map-val"><b>expand_rle_map</b></a>]  Theorem
      
      ⊢ expand_rle (MAP (λ(i,x). (i,f x)) xs) = MAP f (expand_rle xs)
   
   [<a name="foldi_FOLDR_toAList-val"><b>foldi_FOLDR_toAList</b></a>]  Theorem
      
      ⊢ ∀f a t. foldi f 0 a t = FOLDR (UNCURRY f) a (toAList t)
   
   [<a name="fromAList_append-val"><b>fromAList_append</b></a>]  Theorem
      
      ⊢ ∀l1 l2. fromAList (l1 ⧺ l2) = union (fromAList l1) (fromAList l2)
   
   [<a name="fromAList_def-val"><b>fromAList_def</b></a>]  Theorem
      
      ⊢ isEmpty (fromAList []) ∧
        ∀y xs x. fromAList ((x,y)::xs) = insert x y (fromAList xs)
   
   [<a name="fromAList_ind-val"><b>fromAList_ind</b></a>]  Theorem
      
      ⊢ ∀P. P [] ∧ (∀x y xs. P xs ⇒ P ((x,y)::xs)) ⇒ ∀v. P v
   
   [<a name="fromAList_toAList-val"><b>fromAList_toAList</b></a>]  Theorem
      
      ⊢ ∀t. wf t ⇒ fromAList (toAList t) = t
   
   [<a name="fromList_fromAList-val"><b>fromList_fromAList</b></a>]  Theorem
      
      ⊢ ∀l. fromList l = fromAList (ZIP (COUNT_LIST (LENGTH l),l))
   
   [<a name="fst_spt_centers_imp-val"><b>fst_spt_centers_imp</b></a>]  Theorem
      
      ⊢ ∀i xs j ys.
          spt_centers i xs = (j,ys) ⇒ j = i + LENGTH (expand_rle xs)
   
   [<a name="insert_compute-val"><b>insert_compute</b></a>]  Theorem
      
      ⊢ insert (NUMERAL n) a t = insert n a t ∧ insert 0 a LN = ⦕ 0 ↦ a ⦖ ∧
        insert 0 a ⦕ 0 ↦ a' ⦖ = ⦕ 0 ↦ a ⦖ ∧
        insert 0 a (BN t1 t2) = BS t1 a t2 ∧
        insert 0 a (BS t1 a' t2) = BS t1 a t2 ∧
        insert ZERO a LN = ⦕ 0 ↦ a ⦖ ∧
        insert ZERO a ⦕ 0 ↦ a' ⦖ = ⦕ 0 ↦ a ⦖ ∧
        insert ZERO a (BN t1 t2) = BS t1 a t2 ∧
        insert ZERO a (BS t1 a' t2) = BS t1 a t2 ∧
        insert (BIT1 n) a LN = BN LN (insert n a LN) ∧
        insert (BIT1 n) a ⦕ 0 ↦ a' ⦖ = BS LN a' (insert n a LN) ∧
        insert (BIT1 n) a (BN t1 t2) = BN t1 (insert n a t2) ∧
        insert (BIT1 n) a (BS t1 a' t2) = BS t1 a' (insert n a t2) ∧
        insert (BIT2 n) a LN = BN (insert n a LN) LN ∧
        insert (BIT2 n) a ⦕ 0 ↦ a' ⦖ = BS (insert n a LN) a' LN ∧
        insert (BIT2 n) a (BN t1 t2) = BN (insert n a t1) t2 ∧
        insert (BIT2 n) a (BS t1 a' t2) = BS (insert n a t1) a' t2
   
   [<a name="insert_def-val"><b>insert_def</b></a>]  Theorem
      
      ⊢ (∀k a.
           insert k a LN =
           if k = 0 then ⦕ 0 ↦ a ⦖
           else if EVEN k then BN (insert ((k − 1) DIV 2) a LN) LN
           else BN LN (insert ((k − 1) DIV 2) a LN)) ∧
        (∀k a' a.
           insert k a ⦕ 0 ↦ a' ⦖ =
           if k = 0 then ⦕ 0 ↦ a ⦖
           else if EVEN k then BS (insert ((k − 1) DIV 2) a LN) a' LN
           else BS LN a' (insert ((k − 1) DIV 2) a LN)) ∧
        (∀t2 t1 k a.
           insert k a (BN t1 t2) =
           if k = 0 then BS t1 a t2
           else if EVEN k then BN (insert ((k − 1) DIV 2) a t1) t2
           else BN t1 (insert ((k − 1) DIV 2) a t2)) ∧
        ∀t2 t1 k a' a.
          insert k a (BS t1 a' t2) =
          if k = 0 then BS t1 a t2
          else if EVEN k then BS (insert ((k − 1) DIV 2) a t1) a' t2
          else BS t1 a' (insert ((k − 1) DIV 2) a t2)
   
   [<a name="insert_fromList_IN_domain-val"><b>insert_fromList_IN_domain</b></a>]  Theorem
      
      ⊢ ∀ls k v.
          k &lt; LENGTH ls ⇒
          insert k v (fromList ls) =
          fromList (TAKE k ls ⧺ [v] ⧺ DROP (SUC k) ls)
   
   [<a name="insert_ind-val"><b>insert_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀k a.
               (k ≠ 0 ∧ EVEN k ⇒ P ((k − 1) DIV 2) a LN) ∧
               (k ≠ 0 ∧ ¬EVEN k ⇒ P ((k − 1) DIV 2) a LN) ⇒
               P k a LN) ∧
            (∀k a a'.
               (k ≠ 0 ∧ EVEN k ⇒ P ((k − 1) DIV 2) a LN) ∧
               (k ≠ 0 ∧ ¬EVEN k ⇒ P ((k − 1) DIV 2) a LN) ⇒
               P k a ⦕ 0 ↦ a' ⦖) ∧
            (∀k a t1 t2.
               (k ≠ 0 ∧ EVEN k ⇒ P ((k − 1) DIV 2) a t1) ∧
               (k ≠ 0 ∧ ¬EVEN k ⇒ P ((k − 1) DIV 2) a t2) ⇒
               P k a (BN t1 t2)) ∧
            (∀k a t1 a' t2.
               (k ≠ 0 ∧ EVEN k ⇒ P ((k − 1) DIV 2) a t1) ∧
               (k ≠ 0 ∧ ¬EVEN k ⇒ P ((k − 1) DIV 2) a t2) ⇒
               P k a (BS t1 a' t2)) ⇒
            ∀v v1 v2. P v v1 v2
   
   [<a name="insert_insert-val"><b>insert_insert</b></a>]  Theorem
      
      ⊢ ∀x1 x2 v1 v2 t.
          insert x1 v1 (insert x2 v2 t) =
          if x1 = x2 then insert x1 v1 t else insert x2 v2 (insert x1 v1 t)
   
   [<a name="insert_mk_wf-val"><b>insert_mk_wf</b></a>]  Theorem
      
      ⊢ ∀x v t. insert x v (mk_wf t) = mk_wf (insert x v t)
   
   [<a name="insert_notEmpty-val"><b>insert_notEmpty</b></a>]  Theorem
      
      ⊢ insert k a t ≠ LN
   
   [<a name="insert_shadow-val"><b>insert_shadow</b></a>]  Theorem
      
      ⊢ ∀t a b c. insert a b (insert a c t) = insert a b t
   
   [<a name="insert_swap-val"><b>insert_swap</b></a>]  Theorem
      
      ⊢ ∀t a b c d.
          a ≠ c ⇒ insert a b (insert c d t) = insert c d (insert a b t)
   
   [<a name="insert_unchanged-val"><b>insert_unchanged</b></a>]  Theorem
      
      ⊢ ∀t x. lookup x t = SOME y ⇒ insert x y t = t
   
   [<a name="insert_union-val"><b>insert_union</b></a>]  Theorem
      
      ⊢ ∀k v s. insert k v s = union (insert k v LN) s
   
   [<a name="inter_LN-val"><b>inter_LN</b></a>]  Theorem
      
      ⊢ ∀t. isEmpty (inter t LN) ∧ isEmpty (inter LN t)
   
   [<a name="inter_assoc-val"><b>inter_assoc</b></a>]  Theorem
      
      ⊢ ∀t1 t2 t3. inter t1 (inter t2 t3) = inter (inter t1 t2) t3
   
   [<a name="inter_eq-val"><b>inter_eq</b></a>]  Theorem
      
      ⊢ ∀t1 t2 t3 t4.
          inter t1 t2 = inter t3 t4 ⇔
          ∀x. lookup x (inter t1 t2) = lookup x (inter t3 t4)
   
   [<a name="inter_eq_LN-val"><b>inter_eq_LN</b></a>]  Theorem
      
      ⊢ ∀x y. isEmpty (inter x y) ⇔ DISJOINT (domain x) (domain y)
   
   [<a name="inter_mk_wf-val"><b>inter_mk_wf</b></a>]  Theorem
      
      ⊢ ∀t1 t2. inter (mk_wf t1) (mk_wf t2) = mk_wf (inter t1 t2)
   
   [<a name="isEmpty_toList-val"><b>isEmpty_toList</b></a>]  Theorem
      
      ⊢ ∀t. wf t ⇒ (isEmpty t ⇔ toList t = [])
   
   [<a name="isEmpty_toListA-val"><b>isEmpty_toListA</b></a>]  Theorem
      
      ⊢ ∀t acc. wf t ⇒ (isEmpty t ⇔ toListA acc t = acc)
   
   [<a name="isEmpty_union-val"><b>isEmpty_union</b></a>]  Theorem
      
      ⊢ isEmpty (union m1 m2) ⇔ isEmpty m1 ∧ isEmpty m2
   
   [<a name="list_size_APPEND-val"><b>list_size_APPEND</b></a>]  Theorem
      
      ⊢ list_size f (xs ⧺ ys) = list_size f xs + list_size f ys
   
   [<a name="list_to_num_set_append-val"><b>list_to_num_set_append</b></a>]  Theorem
      
      ⊢ ∀l1 l2.
          list_to_num_set (l1 ⧺ l2) =
          union (list_to_num_set l1) (list_to_num_set l2)
   
   [<a name="lookup_0_spt_center-val"><b>lookup_0_spt_center</b></a>]  Theorem
      
      ⊢ ∀spt. lookup 0 spt = spt_center spt
   
   [<a name="lookup_FOLDL_union-val"><b>lookup_FOLDL_union</b></a>]  Theorem
      
      ⊢ lookup k (FOLDL union t ls) =
        FOLDL OPTION_CHOICE (lookup k t) (MAP (lookup k) ls)
   
   [<a name="lookup_NONE_domain-val"><b>lookup_NONE_domain</b></a>]  Theorem
      
      ⊢ lookup k t = NONE ⇔ k ∉ domain t
   
   [<a name="lookup_SOME_left_right_cases-val"><b>lookup_SOME_left_right_cases</b></a>]  Theorem
      
      ⊢ lookup i spt = SOME v ⇔
        i = 0 ∧ spt_center spt = SOME v ∨
        (∃j. i = j * 2 + 1 ∧ lookup j (spt_right spt) = SOME v) ∨
        ∃j. i = j * 2 + 2 ∧ lookup j (spt_left spt) = SOME v
   
   [<a name="lookup_alist_insert-val"><b>lookup_alist_insert</b></a>]  Theorem
      
      ⊢ ∀x y t z.
          LENGTH x = LENGTH y ⇒
          lookup z (alist_insert x y t) =
          case ALOOKUP (ZIP (x,y)) z of
            NONE =&gt; lookup z t
          | SOME a =&gt; SOME a
   
   [<a name="lookup_compute-val"><b>lookup_compute</b></a>]  Theorem
      
      ⊢ lookup (NUMERAL n) t = lookup n t ∧ lookup 0 LN = NONE ∧
        lookup 0 ⦕ 0 ↦ a ⦖ = SOME a ∧ lookup 0 (BN t1 t2) = NONE ∧
        lookup 0 (BS t1 a t2) = SOME a ∧ lookup ZERO LN = NONE ∧
        lookup ZERO ⦕ 0 ↦ a ⦖ = SOME a ∧ lookup ZERO (BN t1 t2) = NONE ∧
        lookup ZERO (BS t1 a t2) = SOME a ∧ lookup (BIT1 n) LN = NONE ∧
        lookup (BIT1 n) ⦕ 0 ↦ a ⦖ = NONE ∧
        lookup (BIT1 n) (BN t1 t2) = lookup n t2 ∧
        lookup (BIT1 n) (BS t1 a t2) = lookup n t2 ∧
        lookup (BIT2 n) LN = NONE ∧ lookup (BIT2 n) ⦕ 0 ↦ a ⦖ = NONE ∧
        lookup (BIT2 n) (BN t1 t2) = lookup n t1 ∧
        lookup (BIT2 n) (BS t1 a t2) = lookup n t1
   
   [<a name="lookup_def-val"><b>lookup_def</b></a>]  Theorem
      
      ⊢ (∀k. lookup k LN = NONE) ∧
        (∀k a. lookup k ⦕ 0 ↦ a ⦖ = if k = 0 then SOME a else NONE) ∧
        (∀t2 t1 k.
           lookup k (BN t1 t2) =
           if k = 0 then NONE
           else lookup ((k − 1) DIV 2) (if EVEN k then t1 else t2)) ∧
        ∀t2 t1 k a.
          lookup k (BS t1 a t2) =
          if k = 0 then SOME a
          else lookup ((k − 1) DIV 2) (if EVEN k then t1 else t2)
   
   [<a name="lookup_delete-val"><b>lookup_delete</b></a>]  Theorem
      
      ⊢ ∀t k1 k2.
          lookup k1 (delete k2 t) = if k1 = k2 then NONE else lookup k1 t
   
   [<a name="lookup_difference-val"><b>lookup_difference</b></a>]  Theorem
      
      ⊢ ∀m1 m2 k.
          lookup k (difference m1 m2) =
          if lookup k m2 = NONE then lookup k m1 else NONE
   
   [<a name="lookup_filter_v-val"><b>lookup_filter_v</b></a>]  Theorem
      
      ⊢ ∀k t f.
          lookup k (filter_v f t) =
          case lookup k t of
            NONE =&gt; NONE
          | SOME v =&gt; if f v then SOME v else NONE
   
   [<a name="lookup_fromAList-val"><b>lookup_fromAList</b></a>]  Theorem
      
      ⊢ ∀ls x. lookup x (fromAList ls) = ALOOKUP ls x
   
   [<a name="lookup_fromAList_toAList-val"><b>lookup_fromAList_toAList</b></a>]  Theorem
      
      ⊢ ∀t x. lookup x (fromAList (toAList t)) = lookup x t
   
   [<a name="lookup_fromList-val"><b>lookup_fromList</b></a>]  Theorem
      
      ⊢ lookup n (fromList l) =
        if n &lt; LENGTH l then SOME (EL n l) else NONE
   
   [<a name="lookup_fromList_outside-val"><b>lookup_fromList_outside</b></a>]  Theorem
      
      ⊢ ∀k. LENGTH args ≤ k ⇒ lookup k (fromList args) = NONE
   
   [<a name="lookup_ind-val"><b>lookup_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀k. P k LN) ∧ (∀k a. P k ⦕ 0 ↦ a ⦖) ∧
            (∀k t1 t2.
               (k ≠ 0 ⇒ P ((k − 1) DIV 2) (if EVEN k then t1 else t2)) ⇒
               P k (BN t1 t2)) ∧
            (∀k t1 a t2.
               (k ≠ 0 ⇒ P ((k − 1) DIV 2) (if EVEN k then t1 else t2)) ⇒
               P k (BS t1 a t2)) ⇒
            ∀v v1. P v v1
   
   [<a name="lookup_insert-val"><b>lookup_insert</b></a>]  Theorem
      
      ⊢ ∀k2 v t k1.
          lookup k1 (insert k2 v t) =
          if k1 = k2 then SOME v else lookup k1 t
   
   [<a name="lookup_insert1-val"><b>lookup_insert1</b></a>]  Theorem
      
      ⊢ ∀k a t. lookup k (insert k a t) = SOME a
   
   [<a name="lookup_inter-val"><b>lookup_inter</b></a>]  Theorem
      
      ⊢ ∀m1 m2 k.
          lookup k (inter m1 m2) =
          case (lookup k m1,lookup k m2) of
            (NONE,v4) =&gt; NONE
          | (SOME v,NONE) =&gt; NONE
          | (SOME v,SOME w) =&gt; SOME v
   
   [<a name="lookup_inter_EQ-val"><b>lookup_inter_EQ</b></a>]  Theorem
      
      ⊢ (lookup x (inter t1 t2) = SOME y ⇔
         lookup x t1 = SOME y ∧ lookup x t2 ≠ NONE) ∧
        (lookup x (inter t1 t2) = NONE ⇔
         lookup x t1 = NONE ∨ lookup x t2 = NONE)
   
   [<a name="lookup_inter_alt-val"><b>lookup_inter_alt</b></a>]  Theorem
      
      ⊢ lookup x (inter t1 t2) =
        if x ∈ domain t2 then lookup x t1 else NONE
   
   [<a name="lookup_inter_assoc-val"><b>lookup_inter_assoc</b></a>]  Theorem
      
      ⊢ lookup x (inter t1 (inter t2 t3)) =
        lookup x (inter (inter t1 t2) t3)
   
   [<a name="lookup_inter_eq-val"><b>lookup_inter_eq</b></a>]  Theorem
      
      ⊢ ∀m1 m2 k.
          lookup k (inter_eq m1 m2) =
          case lookup k m1 of
            NONE =&gt; NONE
          | SOME v =&gt; if lookup k m2 = SOME v then SOME v else NONE
   
   [<a name="lookup_list_to_num_set-val"><b>lookup_list_to_num_set</b></a>]  Theorem
      
      ⊢ ∀xs.
          lookup x (list_to_num_set xs) =
          if MEM x xs then SOME () else NONE
   
   [<a name="lookup_map-val"><b>lookup_map</b></a>]  Theorem
      
      ⊢ ∀s x. lookup x (map f s) = OPTION_MAP f (lookup x s)
   
   [<a name="lookup_map_K-val"><b>lookup_map_K</b></a>]  Theorem
      
      ⊢ ∀t n.
          lookup n (map (K x) t) = if n ∈ domain t then SOME x else NONE
   
   [<a name="lookup_mapi-val"><b>lookup_mapi</b></a>]  Theorem
      
      ⊢ lookup k (mapi f pt) = OPTION_MAP (f k) (lookup k pt)
   
   [<a name="lookup_mapi0-val"><b>lookup_mapi0</b></a>]  Theorem
      
      ⊢ ∀pt i k.
          lookup k (mapi0 f i pt) =
          case lookup k pt of
            NONE =&gt; NONE
          | SOME v =&gt; SOME (f (spt_acc i k) v)
   
   [<a name="lookup_mk_BN-val"><b>lookup_mk_BN</b></a>]  Theorem
      
      ⊢ lookup i (mk_BN t1 t2) =
        if i = 0 then NONE
        else lookup ((i − 1) DIV 2) (if EVEN i then t1 else t2)
   
   [<a name="lookup_mk_wf-val"><b>lookup_mk_wf</b></a>]  Theorem
      
      ⊢ ∀x t. lookup x (mk_wf t) = lookup x t
   
   [<a name="lookup_rwts-val"><b>lookup_rwts</b></a>]  Theorem
      
      ⊢ lookup k LN = NONE ∧ lookup 0 ⦕ 0 ↦ a ⦖ = SOME a ∧
        lookup 0 (BN t1 t2) = NONE ∧ lookup 0 (BS t1 a t2) = SOME a
   
   [<a name="lookup_spt_left-val"><b>lookup_spt_left</b></a>]  Theorem
      
      ⊢ lookup i (spt_left spt) = lookup (i * 2 + 2) spt
   
   [<a name="lookup_spt_right-val"><b>lookup_spt_right</b></a>]  Theorem
      
      ⊢ lookup i (spt_right spt) = lookup (i * 2 + 1) spt
   
   [<a name="lookup_union-val"><b>lookup_union</b></a>]  Theorem
      
      ⊢ ∀m1 m2 k.
          lookup k (union m1 m2) =
          case lookup k m1 of NONE =&gt; lookup k m2 | SOME v =&gt; SOME v
   
   [<a name="lrnext_def-val"><b>lrnext_def</b></a>]  Theorem
      
      ⊢ ∀n. sptree$lrnext n =
            if n = 0 then 1 else 2 * sptree$lrnext ((n − 1) DIV 2)
   
   [<a name="lrnext_eq-val"><b>lrnext_eq</b></a>]  Theorem
      
      ⊢ ∀n. sptree$lrnext n = 2 ** LOG 2 (n + 1)
   
   [<a name="lrnext_ind-val"><b>lrnext_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀n. (n ≠ 0 ⇒ P ((n − 1) DIV 2)) ⇒ P n) ⇒ ∀v. P v
   
   [<a name="lrnext_thm-val"><b>lrnext_thm</b></a>]  Theorem
      
      ⊢ sptree$lrnext ZERO = 1 ∧
        (∀n. sptree$lrnext (BIT1 n) = 2 * sptree$lrnext n) ∧
        (∀n. sptree$lrnext (BIT2 n) = 2 * sptree$lrnext n) ∧
        (∀a. sptree$lrnext 0 = 1) ∧
        ∀n a. sptree$lrnext (NUMERAL n) = sptree$lrnext n
   
   [<a name="map_LN-val"><b>map_LN</b></a>]  Theorem
      
      ⊢ ∀t. isEmpty (map f t) ⇔ isEmpty t
   
   [<a name="map_fromAList-val"><b>map_fromAList</b></a>]  Theorem
      
      ⊢ map f (fromAList ls) = fromAList (MAP (λ(k,v). (k,f v)) ls)
   
   [<a name="map_insert-val"><b>map_insert</b></a>]  Theorem
      
      ⊢ ∀f x y z. map f (insert x y z) = insert x (f y) (map f z)
   
   [<a name="map_map_K-val"><b>map_map_K</b></a>]  Theorem
      
      ⊢ ∀t. map (K a) (map f t) = map (K a) t
   
   [<a name="map_map_o-val"><b>map_map_o</b></a>]  Theorem
      
      ⊢ ∀t f g. map f (map g t) = map (f ∘ g) t
   
   [<a name="map_union-val"><b>map_union</b></a>]  Theorem
      
      ⊢ ∀t1 t2. map f (union t1 t2) = union (map f t1) (map f t2)
   
   [<a name="mapi_Alist-val"><b>mapi_Alist</b></a>]  Theorem
      
      ⊢ mapi f pt =
        fromAList (MAP (λkv. (FST kv,f (FST kv) (SND kv))) (toAList pt))
   
   [<a name="mapi_fromList-val"><b>mapi_fromList</b></a>]  Theorem
      
      ⊢ mapi f (fromList ls) = fromList (MAPi f ls)
   
   [<a name="mk_BN_def-val"><b>mk_BN_def</b></a>]  Theorem
      
      ⊢ isEmpty (mk_BN LN LN) ∧ mk_BN LN ⦕ 0 ↦ v14 ⦖ = ⦕ 1 ↦ v14 ⦖ ∧
        mk_BN LN (BN v15 v16) = BN LN (BN v15 v16) ∧
        mk_BN LN (BS v17 v18 v19) = BN LN (BS v17 v18 v19) ∧
        mk_BN ⦕ 0 ↦ v2 ⦖ t2 = BN ⦕ 0 ↦ v2 ⦖ t2 ∧
        mk_BN (BN v3 v4) t2 = BN (BN v3 v4) t2 ∧
        mk_BN (BS v5 v6 v7) t2 = BN (BS v5 v6 v7) t2
   
   [<a name="mk_BN_ind-val"><b>mk_BN_ind</b></a>]  Theorem
      
      ⊢ ∀P. P LN LN ∧ (∀v14. P LN ⦕ 0 ↦ v14 ⦖) ∧
            (∀v15 v16. P LN (BN v15 v16)) ∧
            (∀v17 v18 v19. P LN (BS v17 v18 v19)) ∧
            (∀v2 t2. P ⦕ 0 ↦ v2 ⦖ t2) ∧ (∀v3 v4 t2. P (BN v3 v4) t2) ∧
            (∀v5 v6 v7 t2. P (BS v5 v6 v7) t2) ⇒
            ∀v v1. P v v1
   
   [<a name="mk_BS_def-val"><b>mk_BS_def</b></a>]  Theorem
      
      ⊢ mk_BS LN x LN = ⦕ 0 ↦ x ⦖ ∧
        mk_BS ⦕ 0 ↦ v16 ⦖ x LN = ⦕ 0 ↦ x; 2 ↦ v16 ⦖ ∧
        mk_BS (BN v17 v18) x LN = BS (BN v17 v18) x LN ∧
        mk_BS (BS v19 v20 v21) x LN = BS (BS v19 v20 v21) x LN ∧
        mk_BS t1 x ⦕ 0 ↦ v4 ⦖ = BS t1 x ⦕ 0 ↦ v4 ⦖ ∧
        mk_BS t1 x (BN v5 v6) = BS t1 x (BN v5 v6) ∧
        mk_BS t1 x (BS v7 v8 v9) = BS t1 x (BS v7 v8 v9)
   
   [<a name="mk_BS_ind-val"><b>mk_BS_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀x. P LN x LN) ∧ (∀v16 x. P ⦕ 0 ↦ v16 ⦖ x LN) ∧
            (∀v17 v18 x. P (BN v17 v18) x LN) ∧
            (∀v19 v20 v21 x. P (BS v19 v20 v21) x LN) ∧
            (∀t1 x v4. P t1 x ⦕ 0 ↦ v4 ⦖) ∧
            (∀t1 x v5 v6. P t1 x (BN v5 v6)) ∧
            (∀t1 x v7 v8 v9. P t1 x (BS v7 v8 v9)) ⇒
            ∀v v1 v2. P v v1 v2
   
   [<a name="mk_wf_eq-val"><b>mk_wf_eq</b></a>]  Theorem
      
      ⊢ ∀t1 t2. mk_wf t1 = mk_wf t2 ⇔ ∀x. lookup x t1 = lookup x t2
   
   [<a name="num_set_domain_eq-val"><b>num_set_domain_eq</b></a>]  Theorem
      
      ⊢ ∀t1 t2. wf t1 ∧ wf t2 ⇒ (domain t1 = domain t2 ⇔ t1 = t2)
   
   [<a name="set_MAP_FST_toAList_domain-val"><b>set_MAP_FST_toAList_domain</b></a>]  Theorem
      
      ⊢ set (MAP FST (toAList t)) = domain t
   
   [<a name="set_foldi_keys-val"><b>set_foldi_keys</b></a>]  Theorem
      
      ⊢ ∀t a i.
          foldi (λk v a. k INSERT a) i a t =
          a ∪ IMAGE (λn. i + sptree$lrnext i * n) (domain t)
   
   [<a name="size_delete-val"><b>size_delete</b></a>]  Theorem
      
      ⊢ ∀n t.
          size (delete n t) =
          if lookup n t = NONE then size t else size t − 1
   
   [<a name="size_diff_less-val"><b>size_diff_less</b></a>]  Theorem
      
      ⊢ ∀x y z t.
          domain z ⊆ domain y ∧ t ∈ domain y ∧ t ∉ domain z ∧ t ∈ domain x ⇒
          size (difference x y) &lt; size (difference x z)
   
   [<a name="size_domain-val"><b>size_domain</b></a>]  Theorem
      
      ⊢ ∀t. size t = CARD (domain t)
   
   [<a name="size_fromList-val"><b>size_fromList</b></a>]  Theorem
      
      ⊢ size (fromList ls) = LENGTH ls
   
   [<a name="size_insert-val"><b>size_insert</b></a>]  Theorem
      
      ⊢ ∀k v m.
          size (insert k v m) = if k ∈ domain m then size m else size m + 1
   
   [<a name="size_map-val"><b>size_map</b></a>]  Theorem
      
      ⊢ size (map f t) = size t
   
   [<a name="size_mapi-val"><b>size_mapi</b></a>]  Theorem
      
      ⊢ size (mapi f t) = size t
   
   [<a name="size_zero_empty-val"><b>size_zero_empty</b></a>]  Theorem
      
      ⊢ ∀x. size x = 0 ⇔ domain x = ∅
   
   [<a name="spt_11-val"><b>spt_11</b></a>]  Theorem
      
      ⊢ (∀a a'. ⦕ 0 ↦ a ⦖ = ⦕ 0 ↦ a' ⦖ ⇔ a = a') ∧
        (∀a0 a1 a0' a1'. BN a0 a1 = BN a0' a1' ⇔ a0 = a0' ∧ a1 = a1') ∧
        ∀a0 a1 a2 a0' a1' a2'.
          BS a0 a1 a2 = BS a0' a1' a2' ⇔ a0 = a0' ∧ a1 = a1' ∧ a2 = a2'
   
   [<a name="spt_Axiom-val"><b>spt_Axiom</b></a>]  Theorem
      
      ⊢ ∀f0 f1 f2 f3. ∃fn.
          fn LN = f0 ∧ (∀a. fn ⦕ 0 ↦ a ⦖ = f1 a) ∧
          (∀a0 a1. fn (BN a0 a1) = f2 a0 a1 (fn a0) (fn a1)) ∧
          ∀a0 a1 a2. fn (BS a0 a1 a2) = f3 a1 a0 a2 (fn a0) (fn a2)
   
   [<a name="spt_acc_0-val"><b>spt_acc_0</b></a>]  Theorem
      
      ⊢ ∀k. spt_acc 0 k = k
   
   [<a name="spt_acc_compute-val"><b>spt_acc_compute</b></a>]  Theorem
      
      ⊢ (∀i. spt_acc i 0 = i) ∧
        (∀k i.
           spt_acc i (NUMERAL (BIT1 k)) =
           spt_acc
             (i +
              if EVEN (NUMERAL (BIT1 k)) then 2 * sptree$lrnext i
              else sptree$lrnext i) ((NUMERAL (BIT1 k) − 1) DIV 2)) ∧
        ∀k i.
          spt_acc i (NUMERAL (BIT2 k)) =
          spt_acc
            (i +
             if EVEN (NUMERAL (BIT2 k)) then 2 * sptree$lrnext i
             else sptree$lrnext i) (NUMERAL (BIT1 k) DIV 2)
   
   [<a name="spt_acc_def-val"><b>spt_acc_def</b></a>]  Theorem
      
      ⊢ (∀i. spt_acc i 0 = i) ∧
        ∀k i.
          spt_acc i (SUC k) =
          spt_acc
            (i +
             if EVEN (SUC k) then 2 * sptree$lrnext i else sptree$lrnext i)
            (k DIV 2)
   
   [<a name="spt_acc_eqn-val"><b>spt_acc_eqn</b></a>]  Theorem
      
      ⊢ ∀k i. spt_acc i k = sptree$lrnext i * k + i
   
   [<a name="spt_acc_ind-val"><b>spt_acc_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀i. P i 0) ∧
            (∀i k.
               P
                 (i +
                  if EVEN (SUC k) then 2 * sptree$lrnext i
                  else sptree$lrnext i) (k DIV 2) ⇒
               P i (SUC k)) ⇒
            ∀v v1. P v v1
   
   [<a name="spt_acc_thm-val"><b>spt_acc_thm</b></a>]  Theorem
      
      ⊢ spt_acc i k =
        if k = 0 then i
        else
          spt_acc
            (i + if EVEN k then 2 * sptree$lrnext i else sptree$lrnext i)
            ((k − 1) DIV 2)
   
   [<a name="spt_case_cong-val"><b>spt_case_cong</b></a>]  Theorem
      
      ⊢ ∀M M' v f f1 f2.
          M = M' ∧ (isEmpty M' ⇒ v = v') ∧
          (∀a. M' = ⦕ 0 ↦ a ⦖ ⇒ f a = f' a) ∧
          (∀a0 a1. M' = BN a0 a1 ⇒ f1 a0 a1 = f1' a0 a1) ∧
          (∀a0 a1 a2. M' = BS a0 a1 a2 ⇒ f2 a0 a1 a2 = f2' a0 a1 a2) ⇒
          spt_CASE M v f f1 f2 = spt_CASE M' v' f' f1' f2'
   
   [<a name="spt_case_eq-val"><b>spt_case_eq</b></a>]  Theorem
      
      ⊢ spt_CASE x v f f1 f2 = v' ⇔
        isEmpty x ∧ v = v' ∨ (∃a. x = ⦕ 0 ↦ a ⦖ ∧ f a = v') ∨
        (∃s s0. x = BN s s0 ∧ f1 s s0 = v') ∨
        ∃s a s0. x = BS s a s0 ∧ f2 s a s0 = v'
   
   [<a name="spt_center_def-val"><b>spt_center_def</b></a>]  Theorem
      
      ⊢ spt_center ⦕ 0 ↦ x ⦖ = SOME x ∧ spt_center (BS t1 x t2) = SOME x ∧
        spt_center LN = NONE ∧ spt_center (BN v1 v2) = NONE
   
   [<a name="spt_center_ind-val"><b>spt_center_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀x. P ⦕ 0 ↦ x ⦖) ∧ (∀t1 x t2. P (BS t1 x t2)) ∧ P LN ∧
            (∀v1 v2. P (BN v1 v2)) ⇒
            ∀v. P v
   
   [<a name="spt_centers_def-val"><b>spt_centers_def</b></a>]  Theorem
      
      ⊢ (∀i. spt_centers i [] = (i,[])) ∧
        ∀xs x j i.
          spt_centers i ((j,x)::xs) =
          case spt_center x of
            NONE =&gt; spt_centers (i + j) xs
          | SOME y =&gt; apsnd_cons (i,y) (spt_centers (i + j) xs)
   
   [<a name="spt_centers_expand_rle-val"><b>spt_centers_expand_rle</b></a>]  Theorem
      
      ⊢ ∀i xs.
          rle_wf xs ⇒
          ∀j x.
            MEM (j,x) (SND (spt_centers i xs)) ⇔
            ∃k. j = i + k ∧ k &lt; LENGTH (expand_rle xs) ∧
                spt_center (EL k (expand_rle xs)) = SOME x
   
   [<a name="spt_centers_expand_rle_imp-val"><b>spt_centers_expand_rle_imp</b></a>]  Theorem
      
      ⊢ ∀n xs.
          spt_centers n xs = (n2,centers) ∧ rle_wf xs ⇒
          ∀j x.
            MEM (j,x) centers ⇔
            ∃k. j = n + k ∧ k &lt; LENGTH (expand_rle xs) ∧
                spt_center (EL k (expand_rle xs)) = SOME x
   
   [<a name="spt_centers_ind-val"><b>spt_centers_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀i. P i []) ∧
            (∀i j x xs.
               (∀y. spt_center x = SOME y ⇒ P (i + j) xs) ∧
               (spt_center x = NONE ⇒ P (i + j) xs) ⇒
               P i ((j,x)::xs)) ⇒
            ∀v v1. P v v1
   
   [<a name="spt_centers_ord-val"><b>spt_centers_ord</b></a>]  Theorem
      
      ⊢ ∀n xs n2 ys.
          spt_centers n xs = (n2,ys) ∧ rle_wf xs ⇒
          SORTED $&lt; (MAP FST ys) ∧ (∀k. k ≤ n ⇒ EVERY (λt. FST t ≥ k) ys) ∧
          EVERY (λt. FST t &lt; n2) ys
   
   [<a name="spt_distinct-val"><b>spt_distinct</b></a>]  Theorem
      
      ⊢ (∀a. LN ≠ ⦕ 0 ↦ a ⦖) ∧ (∀a1 a0. LN ≠ BN a0 a1) ∧
        (∀a2 a1 a0. LN ≠ BS a0 a1 a2) ∧ (∀a1 a0 a. ⦕ 0 ↦ a ⦖ ≠ BN a0 a1) ∧
        (∀a2 a1 a0 a. ⦕ 0 ↦ a ⦖ ≠ BS a0 a1 a2) ∧
        ∀a2 a1' a1 a0' a0. BN a0 a1 ≠ BS a0' a1' a2
   
   [<a name="spt_eq_thm-val"><b>spt_eq_thm</b></a>]  Theorem
      
      ⊢ ∀t1 t2. wf t1 ∧ wf t2 ⇒ (t1 = t2 ⇔ ∀n. lookup n t1 = lookup n t2)
   
   [<a name="spt_induction-val"><b>spt_induction</b></a>]  Theorem
      
      ⊢ ∀P. P LN ∧ (∀a. P ⦕ 0 ↦ a ⦖) ∧ (∀s s0. P s ∧ P s0 ⇒ P (BN s s0)) ∧
            (∀s s0. P s ∧ P s0 ⇒ ∀a. P (BS s a s0)) ⇒
            ∀s. P s
   
   [<a name="spt_nchotomy-val"><b>spt_nchotomy</b></a>]  Theorem
      
      ⊢ ∀ss.
          isEmpty ss ∨ (∃a. ss = ⦕ 0 ↦ a ⦖) ∨ (∃s s0. ss = BN s s0) ∨
          ∃s a s0. ss = BS s a s0
   
   [<a name="spts_to_alist_def-val"><b>spts_to_alist_def</b></a>]  Theorem
      
      ⊢ ∀xs i.
          spts_to_alist i xs =
          (let
             ys = combine_rle (λt. isEmpty t) xs
           in
             if EVERY ((λt. isEmpty t) ∘ SND) ys then []
             else
               (let
                  (j,centers) = spt_centers i ys;
                  rights = MAP (λ(i,t). (i,spt_right t)) ys;
                  lefts = MAP (λ(i,t). (i,spt_left t)) ys
                in
                  centers ⧺ spts_to_alist j (rights ⧺ lefts)))
   
   [<a name="spts_to_alist_ind-val"><b>spts_to_alist_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀i xs.
               (∀ys j centers rights lefts.
                  ys = combine_rle (λt. isEmpty t) xs ∧
                  ¬EVERY ((λt. isEmpty t) ∘ SND) ys ∧
                  (j,centers) = spt_centers i ys ∧
                  rights = MAP (λ(i,t). (i,spt_right t)) ys ∧
                  lefts = MAP (λ(i,t). (i,spt_left t)) ys ⇒
                  P j (rights ⧺ lefts)) ⇒
               P i xs) ⇒
            ∀v v1. P v v1
   
   [<a name="subspt_FOLDL_union-val"><b>subspt_FOLDL_union</b></a>]  Theorem
      
      ⊢ ∀ls t. subspt t (FOLDL union t ls)
   
   [<a name="subspt_LN-val"><b>subspt_LN</b></a>]  Theorem
      
      ⊢ (subspt LN sp ⇔ T) ∧ (subspt sp LN ⇔ domain sp = ∅)
   
   [<a name="subspt_def-val"><b>subspt_def</b></a>]  Theorem
      
      ⊢ ∀sp1 sp2.
          subspt sp1 sp2 ⇔
          ∀k. k ∈ domain sp1 ⇒ k ∈ domain sp2 ∧ lookup k sp2 = lookup k sp1
   
   [<a name="subspt_domain-val"><b>subspt_domain</b></a>]  Theorem
      
      ⊢ ∀t1 t2. subspt t1 t2 ⇔ domain t1 ⊆ domain t2
   
   [<a name="subspt_lookup-val"><b>subspt_lookup</b></a>]  Theorem
      
      ⊢ ∀t1 t2.
          subspt t1 t2 ⇔ ∀x y. lookup x t1 = SOME y ⇒ lookup x t2 = SOME y
   
   [<a name="subspt_refl-val"><b>subspt_refl</b></a>]  Theorem
      
      ⊢ subspt sp sp
   
   [<a name="subspt_trans-val"><b>subspt_trans</b></a>]  Theorem
      
      ⊢ subspt sp1 sp2 ∧ subspt sp2 sp3 ⇒ subspt sp1 sp3
   
   [<a name="subspt_union-val"><b>subspt_union</b></a>]  Theorem
      
      ⊢ subspt s (union s t)
   
   [<a name="sum_size_combine_rle_LE-val"><b>sum_size_combine_rle_LE</b></a>]  Theorem
      
      ⊢ ∀P xs.
          SUM (MAP (f ∘ SND) (combine_rle P xs)) ≤ SUM (MAP (f ∘ SND) xs)
   
   [<a name="toListA_append-val"><b>toListA_append</b></a>]  Theorem
      
      ⊢ ∀t acc. toListA acc t = toListA [] t ⧺ acc
   
   [<a name="toList_map-val"><b>toList_map</b></a>]  Theorem
      
      ⊢ ∀s. toList (map f s) = MAP f (toList s)
   
   [<a name="toSortedAList_fromList-val"><b>toSortedAList_fromList</b></a>]  Theorem
      
      ⊢ toSortedAList (fromList ls) = ZIP (COUNT_LIST (LENGTH ls),ls)
   
   [<a name="union_LN-val"><b>union_LN</b></a>]  Theorem
      
      ⊢ ∀t. union t LN = t ∧ union LN t = t
   
   [<a name="union_assoc-val"><b>union_assoc</b></a>]  Theorem
      
      ⊢ ∀t1 t2 t3. union t1 (union t2 t3) = union (union t1 t2) t3
   
   [<a name="union_disjoint_sym-val"><b>union_disjoint_sym</b></a>]  Theorem
      
      ⊢ ∀t1 t2.
          wf t1 ∧ wf t2 ∧ DISJOINT (domain t1) (domain t2) ⇒
          union t1 t2 = union t2 t1
   
   [<a name="union_insert_LN-val"><b>union_insert_LN</b></a>]  Theorem
      
      ⊢ ∀x y t2. union (insert x y LN) t2 = insert x y t2
   
   [<a name="union_mk_wf-val"><b>union_mk_wf</b></a>]  Theorem
      
      ⊢ ∀t1 t2. union (mk_wf t1) (mk_wf t2) = mk_wf (union t1 t2)
   
   [<a name="union_num_set_sym-val"><b>union_num_set_sym</b></a>]  Theorem
      
      ⊢ ∀t1 t2. union t1 t2 = union t2 t1
   
   [<a name="wf_LN-val"><b>wf_LN</b></a>]  Theorem
      
      ⊢ wf LN
   
   [<a name="wf_delete-val"><b>wf_delete</b></a>]  Theorem
      
      ⊢ ∀t k. wf t ⇒ wf (delete k t)
   
   [<a name="wf_difference-val"><b>wf_difference</b></a>]  Theorem
      
      ⊢ ∀t1 t2. wf t1 ∧ wf t2 ⇒ wf (difference t1 t2)
   
   [<a name="wf_filter_v-val"><b>wf_filter_v</b></a>]  Theorem
      
      ⊢ ∀t f. wf t ⇒ wf (filter_v f t)
   
   [<a name="wf_fromAList-val"><b>wf_fromAList</b></a>]  Theorem
      
      ⊢ ∀ls. wf (fromAList ls)
   
   [<a name="wf_fromList-val"><b>wf_fromList</b></a>]  Theorem
      
      ⊢ wf (fromList ls)
   
   [<a name="wf_insert-val"><b>wf_insert</b></a>]  Theorem
      
      ⊢ ∀k a t. wf t ⇒ wf (insert k a t)
   
   [<a name="wf_inter-val"><b>wf_inter</b></a>]  Theorem
      
      ⊢ ∀m1 m2. wf (inter m1 m2)
   
   [<a name="wf_map-val"><b>wf_map</b></a>]  Theorem
      
      ⊢ ∀t f. wf (map f t) ⇔ wf t
   
   [<a name="wf_mapi-val"><b>wf_mapi</b></a>]  Theorem
      
      ⊢ wf (mapi f pt)
   
   [<a name="wf_mk_BN-val"><b>wf_mk_BN</b></a>]  Theorem
      
      ⊢ wf t1 ∧ wf t2 ⇒ wf (mk_BN t1 t2)
   
   [<a name="wf_mk_BS-val"><b>wf_mk_BS</b></a>]  Theorem
      
      ⊢ wf t1 ∧ wf t2 ⇒ wf (mk_BS t1 a t2)
   
   [<a name="wf_mk_id-val"><b>wf_mk_id</b></a>]  Theorem
      
      ⊢ ∀t. wf t ⇒ mk_wf t = t
   
   [<a name="wf_mk_wf-val"><b>wf_mk_wf</b></a>]  Theorem
      
      ⊢ ∀t. wf (mk_wf t)
   
   [<a name="wf_union-val"><b>wf_union</b></a>]  Theorem
      
      ⊢ ∀m1 m2. wf m1 ∧ wf m2 ⇒ wf (union m1 m2)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/finite_maps/sptreeScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-1</a></em></p></body></html>
