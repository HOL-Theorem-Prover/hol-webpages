<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: real_topology</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "real_topology"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "netsTheory.html"><span class="strong">nets</span></a>&nbsp;&nbsp;
    <a href = "real_sigmaTheory.html"><span class="strong">real_sigma</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Type <th> Arity<tr><td> <span class="strong">net</span> <td> 1
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">--></span>
    <td>
    :(α -> real) -> real -> α net -> bool
    <tr><td> <span class="strong">Bounded</span> <td> :(real -> bool) -> bool
    <tr><td>
    <span class="strong">CLOSED_interval</span>
    <td>
    :(real # real) list -> real -> bool
    <tr><td> <span class="strong">Closed</span> <td> :(real -> bool) -> bool
    <tr><td> <span class="strong">Dist</span> <td> :real # real -> real
    <tr><td>
    <span class="strong">OPEN_interval</span>
    <td>
    :real # real -> real -> bool
    <tr><td> <span class="strong">Open</span> <td> :(real -> bool) -> bool
    <tr><td> <span class="strong">at</span> <td> :real -> real net
    <tr><td> <span class="strong">at_infinity</span> <td> :real net
    <tr><td> <span class="strong">at_neginfinity</span> <td> :real net
    <tr><td> <span class="strong">at_posinfinity</span> <td> :real net
    <tr><td>
    <span class="strong">ball</span>
    <td>
    :real # real -> real -> bool
    <tr><td>
    <span class="strong">between</span>
    <td>
    :real -> real # real -> bool
    <tr><td>
    <span class="strong">bilinear</span>
    <td>
    :(real -> real -> real) -> bool
    <tr><td> <span class="strong">cauchy</span> <td> :(num -> real) -> bool
    <tr><td>
    <span class="strong">cball</span>
    <td>
    :real # real -> real -> bool
    <tr><td>
    <span class="strong">closed_segment</span>
    <td>
    :(real # real) list -> real -> bool
    <tr><td>
    <span class="strong">closest_point</span>
    <td>
    :(real -> bool) -> real -> real
    <tr><td>
    <span class="strong">closure</span>
    <td>
    :(real -> bool) -> real -> bool
    <tr><td>
    <span class="strong">collinear</span>
    <td>
    :(real -> bool) -> bool
    <tr><td> <span class="strong">compact</span> <td> :(real -> bool) -> bool
    <tr><td> <span class="strong">complete</span> <td> :(real -> bool) -> bool
    <tr><td>
    <span class="strong">components</span>
    <td>
    :(real -> bool) -> (real -> bool) -> bool
    <tr><td>
    <span class="strong">condensation_point_of</span>
    <td>
    :real -> (real -> bool) -> bool
    <tr><td>
    <span class="strong">connected</span>
    <td>
    :(real -> bool) -> bool
    <tr><td>
    <span class="strong">connected_component</span>
    <td>
    :(real -> bool) -> real -> real -> bool
    <tr><td>
    <span class="strong">content</span>
    <td>
    :real real_measure$measure
    <tr><td>
    <span class="strong">continuous</span>
    <td>
    :(α -> real) -> α net -> bool
    <tr><td>
    <span class="strong">continuous_on</span>
    <td>
    :(real -> real) -> (real -> bool) -> bool
    <tr><td>
    <span class="strong">dependent</span>
    <td>
    :(real -> bool) -> bool
    <tr><td> <span class="strong">dim</span> <td> :(real -> bool) -> num
    <tr><td> <span class="strong">euclidean</span> <td> :real topology
    <tr><td>
    <span class="strong">eventually</span>
    <td>
    :(α -> bool) -> α net -> bool
    <tr><td>
    <span class="strong">frontier</span>
    <td>
    :(real -> bool) -> real -> bool
    <tr><td>
    <span class="strong">hausdist</span>
    <td>
    :(real -> bool) # (real -> bool) -> real
    <tr><td>
    <span class="strong">homeomorphic</span>
    <td>
    :(real -> bool) -> (real -> bool) -> bool
    <tr><td>
    <span class="strong">homeomorphism</span>
    <td>
    :(real -> bool) # (real -> bool) ->
    (real -> real) # (real -> real) -> bool
    <tr><td>
    <span class="strong">in_direction</span>
    <td>
    :real -> real -> real net
    <tr><td>
    <span class="strong">independent</span>
    <td>
    :(real -> bool) -> bool
    <tr><td>
    <span class="strong">infsum</span>
    <td>
    :(num -> bool) -> (num -> real) -> real
    <tr><td>
    <span class="strong">interior</span>
    <td>
    :(real -> bool) -> real -> bool
    <tr><td>
    <span class="strong">interval_lowerbound</span>
    <td>
    :real real_measure$measure
    <tr><td>
    <span class="strong">interval_upperbound</span>
    <td>
    :real real_measure$measure
    <tr><td>
    <span class="strong">is_interval</span>
    <td>
    :(real -> bool) -> bool
    <tr><td> <span class="strong">isnet</span> <td> :(α -> β -> bool) -> bool
    <tr><td>
    <span class="strong">limit_point_of</span>
    <td>
    :real -> (real -> bool) -> bool
    <tr><td> <span class="strong">linear</span> <td> :(real -> real) -> bool
    <tr><td>
    <span class="strong">locally</span>
    <td>
    :((real -> bool) -> bool) -> (real -> bool) -> bool
    <tr><td> <span class="strong">midpoint</span> <td> :real # real -> real
    <tr><td>
    <span class="strong">mk_net</span>
    <td>
    :(α -> α -> bool) -> α net
    <tr><td> <span class="strong">netlimit</span> <td> :α net -> α
    <tr><td> <span class="strong">netord</span> <td> :α net -> α -> α -> bool
    <tr><td>
    <span class="strong">open_segment</span>
    <td>
    :real # real -> real -> bool
    <tr><td>
    <span class="strong">permutes</span>
    <td>
    :(α -> α) -> (α -> bool) -> bool
    <tr><td>
    <span class="strong">reallim</span>
    <td>
    :α net -> (α -> real) -> real
    <tr><td> <span class="strong">sequentially</span> <td> :num net
    <tr><td>
    <span class="strong">set_diameter</span>
    <td>
    :α metric -> α real_measure$measure
    <tr><td>
    <span class="strong">set_dist</span>
    <td>
    :α metric -> (α -> bool) # (α -> bool) -> real
    <tr><td>
    <span class="strong">span</span>
    <td>
    :(real -> bool) -> real -> bool
    <tr><td>
    <span class="strong">sphere</span>
    <td>
    :real # real -> real -> bool
    <tr><td> <span class="strong">subspace</span> <td> :(real -> bool) -> bool
    <tr><td>
    <span class="strong">summable</span>
    <td>
    :(num -> bool) -> (num -> real) -> bool
    <tr><td>
    <span class="strong">sums</span>
    <td>
    :(num -> real) -> real -> (num -> bool) -> bool
    <tr><td> <span class="strong">trivial_limit</span> <td> :α net -> bool
    <tr><td>
    <span class="strong">uniformly_continuous_on</span>
    <td>
    :(real -> real) -> (real -> bool) -> bool
    <tr><td>
    <span class="strong">within</span>
    <td>
    :α net -> (α -> bool) -> α net
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">CLOSED_interval</span>
<DD>
<pre>
⊢ ∀l. interval l = {x | FST (HD l) ≤ x ∧ x ≤ SND (HD l)}
</pre>

<DT><span class="strong">OPEN_interval</span>
<DD>
<pre>
⊢ ∀a b. interval (a,b) = {x | a < x ∧ x < b}
</pre>

<DT><span class="strong">at_def</span>
<DD>
<pre>
⊢ ∀z. at z = mk_net (tendsto (mr1,z))
</pre>

<DT><span class="strong">at_infinity</span>
<DD>
<pre>
⊢ at_infinity = mk_net (λx y. abs x ≥ abs y)
</pre>

<DT><span class="strong">at_neginfinity</span>
<DD>
<pre>
⊢ at_neginfinity = mk_net (λx y. x ≤ y)
</pre>

<DT><span class="strong">at_posinfinity</span>
<DD>
<pre>
⊢ at_posinfinity = mk_net (λx y. x ≥ y)
</pre>

<DT><span class="strong">ball_def</span>
<DD>
<pre>
⊢ ball = mball mr1
</pre>

<DT><span class="strong">between</span>
<DD>
<pre>
⊢ ∀x a b. between x (a,b) ⇔ (dist (a,b) = dist (a,x) + dist (x,b))
</pre>

<DT><span class="strong">bilinear</span>
<DD>
<pre>
⊢ ∀f. bilinear f ⇔ (∀x. linear (λy. f x y)) ∧ ∀y. linear (λx. f x y)
</pre>

<DT><span class="strong">bounded_def</span>
<DD>
<pre>
⊢ ∀s. bounded s ⇔ ∃a. ∀x. x ∈ s ⇒ abs x ≤ a
</pre>

<DT><span class="strong">cauchy_def</span>
<DD>
<pre>
⊢ ∀s. cauchy s ⇔ ∀e. 0 < e ⇒ ∃N. ∀m n. m ≥ N ∧ n ≥ N ⇒ dist (s m,s n) < e
</pre>

<DT><span class="strong">cball</span>
<DD>
<pre>
⊢ ∀x e. cball (x,e) = {y | dist (x,y) ≤ e}
</pre>

<DT><span class="strong">closed_segment</span>
<DD>
<pre>
⊢ ∀l. segment l = {(1 − u) * FST (HD l) + u * SND (HD l) | 0 ≤ u ∧ u ≤ 1}
</pre>

<DT><span class="strong">closest_point</span>
<DD>
<pre>
⊢ ∀s a. closest_point s a = @x. x ∈ s ∧ ∀y. y ∈ s ⇒ dist (a,x) ≤ dist (a,y)
</pre>

<DT><span class="strong">closure</span>
<DD>
<pre>
⊢ ∀s. closure s = s ∪ {x | x limit_point_of s}
</pre>

<DT><span class="strong">collinear</span>
<DD>
<pre>
⊢ ∀s. collinear s ⇔ ∃u. ∀x y. x ∈ s ∧ y ∈ s ⇒ ∃c. x − y = c * u
</pre>

<DT><span class="strong">compact</span>
<DD>
<pre>
⊢ ∀s. compact s ⇔
      ∀f. (∀n. f n ∈ s) ⇒
          ∃l r. l ∈ s ∧ (∀m n. m < n ⇒ r m < r n) ∧ (f ∘ r --> l) sequentially
</pre>

<DT><span class="strong">complete</span>
<DD>
<pre>
⊢ ∀s. complete s ⇔
      ∀f. (∀n. f n ∈ s) ∧ cauchy f ⇒ ∃l. l ∈ s ∧ (f --> l) sequentially
</pre>

<DT><span class="strong">components</span>
<DD>
<pre>
⊢ ∀s. components s = {connected_component s x | x | x ∈ s}
</pre>

<DT><span class="strong">condensation_point_of</span>
<DD>
<pre>
⊢ ∀x s. x condensation_point_of s ⇔ ∀t. x ∈ t ∧ open t ⇒ uncountable (s ∩ t)
</pre>

<DT><span class="strong">connected</span>
<DD>
<pre>
⊢ ∀s. connected s ⇔
      ¬∃e1 e2.
        open e1 ∧ open e2 ∧ s ⊆ e1 ∪ e2 ∧ (e1 ∩ e2 ∩ s = ∅) ∧ e1 ∩ s ≠ ∅ ∧
        e2 ∩ s ≠ ∅
</pre>

<DT><span class="strong">connected_component</span>
<DD>
<pre>
⊢ ∀s x y. connected_component s x y ⇔ ∃t. connected t ∧ t ⊆ s ∧ x ∈ t ∧ y ∈ t
</pre>

<DT><span class="strong">content</span>
<DD>
<pre>
⊢ ∀s. content s =
      if s = ∅ then 0 else interval_upperbound s − interval_lowerbound s
</pre>

<DT><span class="strong">continuous</span>
<DD>
<pre>
⊢ ∀f net. f continuous net ⇔ (f --> f (netlimit net)) net
</pre>

<DT><span class="strong">continuous_on</span>
<DD>
<pre>
⊢ ∀f s.
    f continuous_on s ⇔
    ∀x. x ∈ s ⇒
        ∀e. 0 < e ⇒
            ∃d. 0 < d ∧ ∀x'. x' ∈ s ∧ dist (x',x) < d ⇒ dist (f x',f x) < e
</pre>

<DT><span class="strong">dependent</span>
<DD>
<pre>
⊢ ∀s. dependent s ⇔ ∃a. a ∈ s ∧ a ∈ span (s DELETE a)
</pre>

<DT><span class="strong">dim</span>
<DD>
<pre>
⊢ ∀v. dim v = @n. ∃b. b ⊆ v ∧ independent b ∧ v ⊆ span b ∧ b HAS_SIZE n
</pre>

<DT><span class="strong">dist_def</span>
<DD>
<pre>
⊢ dist = dist mr1
</pre>

<DT><span class="strong">euclidean_closed_def</span>
<DD>
<pre>
⊢ closed = closed_in euclidean
</pre>

<DT><span class="strong">euclidean_def</span>
<DD>
<pre>
⊢ euclidean = mtop mr1
</pre>

<DT><span class="strong">euclidean_open_def</span>
<DD>
<pre>
⊢ open = open_in euclidean
</pre>

<DT><span class="strong">eventually</span>
<DD>
<pre>
⊢ ∀p net.
    eventually p net ⇔
    trivial_limit net ∨ ∃y. (∃x. netord net x y) ∧ ∀x. netord net x y ⇒ p x
</pre>

<DT><span class="strong">frontier</span>
<DD>
<pre>
⊢ ∀s. frontier s = closure s DIFF interior s
</pre>

<DT><span class="strong">hausdist</span>
<DD>
<pre>
⊢ ∀s t.
    hausdist (s,t) =
    if
      {setdist ({x},t) | x ∈ s} ∪ {setdist ({y},s) | y ∈ t} ≠ ∅ ∧
      ∃b. ∀d.
        d ∈ {setdist ({x},t) | x ∈ s} ∪ {setdist ({y},s) | y ∈ t} ⇒ d ≤ b
    then
      sup ({setdist ({x},t) | x ∈ s} ∪ {setdist ({y},s) | y ∈ t})
    else 0
</pre>

<DT><span class="strong">homeomorphic</span>
<DD>
<pre>
⊢ ∀s t. s homeomorphic t ⇔ ∃f g. homeomorphism (s,t) (f,g)
</pre>

<DT><span class="strong">homeomorphism</span>
<DD>
<pre>
⊢ ∀s t f g.
    homeomorphism (s,t) (f,g) ⇔
    (∀x. x ∈ s ⇒ (g (f x) = x)) ∧ (IMAGE f s = t) ∧ f continuous_on s ∧
    (∀y. y ∈ t ⇒ (f (g y) = y)) ∧ (IMAGE g t = s) ∧ g continuous_on t
</pre>

<DT><span class="strong">in_direction</span>
<DD>
<pre>
⊢ ∀a v. a in_direction v = at a within {b | ∃c. 0 ≤ c ∧ (b − a = c * v)}
</pre>

<DT><span class="strong">independent</span>
<DD>
<pre>
⊢ ∀s. independent s ⇔ ¬dependent s
</pre>

<DT><span class="strong">infsum</span>
<DD>
<pre>
⊢ ∀s f. suminf s f = @l. (f sums l) s
</pre>

<DT><span class="strong">interior</span>
<DD>
<pre>
⊢ ∀s. interior s = {x | ∃t. open t ∧ x ∈ t ∧ t ⊆ s}
</pre>

<DT><span class="strong">interval_lowerbound</span>
<DD>
<pre>
⊢ ∀s. interval_lowerbound s = if s = ∅ then 0 else inf s
</pre>

<DT><span class="strong">interval_upperbound</span>
<DD>
<pre>
⊢ ∀s. interval_upperbound s = if s = ∅ then 0 else sup s
</pre>

<DT><span class="strong">is_interval</span>
<DD>
<pre>
⊢ ∀s. is_interval s ⇔
      ∀a b x. a ∈ s ∧ b ∈ s ⇒ a ≤ x ∧ x ≤ b ∨ b ≤ x ∧ x ≤ a ⇒ x ∈ s
</pre>

<DT><span class="strong">isnet</span>
<DD>
<pre>
⊢ ∀g. isnet g ⇔ ∀x y. (∀z. g z x ⇒ g z y) ∨ ∀z. g z y ⇒ g z x
</pre>

<DT><span class="strong">limit_point_of_def</span>
<DD>
<pre>
⊢ ∀x s. x limit_point_of s ⇔ limpt euclidean x s
</pre>

<DT><span class="strong">linear</span>
<DD>
<pre>
⊢ ∀f. linear f ⇔ (∀x y. f (x + y) = f x + f y) ∧ ∀c x. f (c * x) = c * f x
</pre>

<DT><span class="strong">locally</span>
<DD>
<pre>
⊢ ∀P s.
    locally P s ⇔
    ∀w x.
      open_in (subtopology euclidean s) w ∧ x ∈ w ⇒
      ∃u v. open_in (subtopology euclidean s) u ∧ P v ∧ x ∈ u ∧ u ⊆ v ∧ v ⊆ w
</pre>

<DT><span class="strong">midpoint</span>
<DD>
<pre>
⊢ ∀a b. midpoint (a,b) = 2⁻¹ * (a + b)
</pre>

<DT><span class="strong">net_TY_DEF</span>
<DD>
<pre>
⊢ ∃rep. TYPE_DEFINITION isnet rep
</pre>

<DT><span class="strong">netlimit</span>
<DD>
<pre>
⊢ ∀net. netlimit net = @a. ∀x. ¬netord net x a
</pre>

<DT><span class="strong">open_segment</span>
<DD>
<pre>
⊢ ∀a b. segment (a,b) = segment [(a,b)] DIFF {a; b}
</pre>

<DT><span class="strong">permutes</span>
<DD>
<pre>
⊢ ∀p s. p permutes s ⇔ (∀x. x ∉ s ⇒ (p x = x)) ∧ ∀y. ∃!x. p x = y
</pre>

<DT><span class="strong">reallim</span>
<DD>
<pre>
⊢ ∀net f. lim net f = @l. (f --> l) net
</pre>

<DT><span class="strong">sequentially</span>
<DD>
<pre>
⊢ sequentially = mk_net (λm n. m ≥ n)
</pre>

<DT><span class="strong">set_diameter_def</span>
<DD>
<pre>
⊢ ∀d s.
    set_diameter d s = if s = ∅ then 0 else sup {dist d (x,y) | x ∈ s ∧ y ∈ s}
</pre>

<DT><span class="strong">set_dist_def</span>
<DD>
<pre>
⊢ ∀d s t.
    set_dist d (s,t) =
    if (s = ∅) ∨ (t = ∅) then 0 else inf {dist d (x,y) | x ∈ s ∧ y ∈ t}
</pre>

<DT><span class="strong">span</span>
<DD>
<pre>
⊢ ∀s. span s = subspace hull s
</pre>

<DT><span class="strong">sphere</span>
<DD>
<pre>
⊢ ∀x e. sphere (x,e) = {y | dist (x,y) = e}
</pre>

<DT><span class="strong">subspace</span>
<DD>
<pre>
⊢ ∀s. subspace s ⇔
      0 ∈ s ∧ (∀x y. x ∈ s ∧ y ∈ s ⇒ x + y ∈ s) ∧ ∀c x. x ∈ s ⇒ c * x ∈ s
</pre>

<DT><span class="strong">summable</span>
<DD>
<pre>
⊢ ∀s f. summable s f ⇔ ∃l. (f sums l) s
</pre>

<DT><span class="strong">sums</span>
<DD>
<pre>
⊢ ∀f l s. (f sums l) s ⇔ ((λn. sum (s ∩ {0 .. n}) f) --> l) sequentially
</pre>

<DT><span class="strong">tendsto_real</span>
<DD>
<pre>
⊢ ∀f l net. (f --> l) net ⇔ ∀e. 0 < e ⇒ eventually (λx. dist (f x,l) < e) net
</pre>

<DT><span class="strong">trivial_limit</span>
<DD>
<pre>
⊢ ∀net.
    trivial_limit net ⇔
    (∀a b. a = b) ∨ ∃a b. a ≠ b ∧ ∀x. ¬netord net x a ∧ ¬netord net x b
</pre>

<DT><span class="strong">uniformly_continuous_on</span>
<DD>
<pre>
⊢ ∀f s.
    f uniformly_continuous_on s ⇔
    ∀e. 0 < e ⇒
        ∃d. 0 < d ∧
            ∀x x'. x ∈ s ∧ x' ∈ s ∧ dist (x',x) < d ⇒ dist (f x',f x) < e
</pre>

<DT><span class="strong">within</span>
<DD>
<pre>
⊢ ∀net s. net within s = mk_net (λx y. netord net x y ∧ x ∈ s)
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">ABS_CAUCHY_SCHWARZ_ABS_EQ</span>
<DD>
<pre>
⊢ ∀x y.
    (abs (x * y) = abs x * abs y) ⇔
    (abs x * y = abs y * x) ∨ (abs x * y = -abs y * x)
</pre>

<DT><span class="strong">ABS_CAUCHY_SCHWARZ_EQ</span>
<DD>
<pre>
⊢ ∀x y. (x * y = abs x * abs y) ⇔ (abs x * y = abs y * x)
</pre>

<DT><span class="strong">ABS_CAUCHY_SCHWARZ_EQUAL</span>
<DD>
<pre>
⊢ ∀x y. (abs (x * y) = abs x * abs y) ⇔ collinear {0; x; y}
</pre>

<DT><span class="strong">ABS_SUM_TRIVIAL_LEMMA</span>
<DD>
<pre>
⊢ ∀e. 0 < e ⇒
      (P ⇒ abs (sum (s ∩ {m .. n}) f) < e ⇔
       P ⇒ n < m ∨ abs (sum (s ∩ {m .. n}) f) < e)
</pre>

<DT><span class="strong">ABS_TRIANGLE_EQ</span>
<DD>
<pre>
⊢ ∀x y. (abs (x + y) = abs x + abs y) ⇔ (abs x * y = abs y * x)
</pre>

<DT><span class="strong">ABS_TRIANGLE_LE</span>
<DD>
<pre>
⊢ ∀x y. abs x + abs y ≤ e ⇒ abs (x + y) ≤ e
</pre>

<DT><span class="strong">AFFINITY_INVERSES</span>
<DD>
<pre>
⊢ ∀m c.
    m ≠ 0 ⇒
    ((λx. m * x + c) ∘ (λx. m⁻¹ * x + -(m⁻¹ * c)) = (λx. x)) ∧
    ((λx. m⁻¹ * x + -(m⁻¹ * c)) ∘ (λx. m * x + c) = (λx. x))
</pre>

<DT><span class="strong">ALWAYS_EVENTUALLY</span>
<DD>
<pre>
⊢ (∀x. p x) ⇒ eventually p net
</pre>

<DT><span class="strong">APPROACHABLE_LT_LE</span>
<DD>
<pre>
⊢ ∀P f. (∃d. 0 < d ∧ ∀x. f x < d ⇒ P x) ⇔ ∃d. 0 < d ∧ ∀x. f x ≤ d ⇒ P x
</pre>

<DT><span class="strong">AT</span>
<DD>
<pre>
⊢ ∀a x y. netord (at a) x y ⇔ 0 < dist (x,a) ∧ dist (x,a) ≤ dist (y,a)
</pre>

<DT><span class="strong">AT_INFINITY</span>
<DD>
<pre>
⊢ ∀x y. netord at_infinity x y ⇔ abs x ≥ abs y
</pre>

<DT><span class="strong">AT_NEGINFINITY</span>
<DD>
<pre>
⊢ ∀x y. netord at_neginfinity x y ⇔ x ≤ y
</pre>

<DT><span class="strong">AT_POSINFINITY</span>
<DD>
<pre>
⊢ ∀x y. netord at_posinfinity x y ⇔ x ≥ y
</pre>

<DT><span class="strong">BAIRE</span>
<DD>
<pre>
⊢ ∀g s.
    locally compact s ∧ countable g ∧
    (∀t. t ∈ g ⇒ open_in (subtopology euclidean s) t ∧ s ⊆ closure t) ⇒
    s ⊆ closure (BIGINTER g)
</pre>

<DT><span class="strong">BAIRE_ALT</span>
<DD>
<pre>
⊢ ∀g s.
    locally compact s ∧ s ≠ ∅ ∧ countable g ∧ (BIGUNION g = s) ⇒
    ∃t u. t ∈ g ∧ open_in (subtopology euclidean s) u ∧ u ⊆ closure t
</pre>

<DT><span class="strong">BALL</span>
<DD>
<pre>
⊢ ∀x r.
    (cball (x,r) = interval [(x − r,x + r)]) ∧
    (ball (x,r) = interval (x − r,x + r))
</pre>

<DT><span class="strong">BALL_EMPTY</span>
<DD>
<pre>
⊢ ∀x e. e ≤ 0 ⇒ (ball (x,e) = ∅)
</pre>

<DT><span class="strong">BALL_EQ_EMPTY</span>
<DD>
<pre>
⊢ ∀x e. (ball (x,e) = ∅) ⇔ e ≤ 0
</pre>

<DT><span class="strong">BALL_INTERVAL</span>
<DD>
<pre>
⊢ ∀x e. ball (x,e) = interval (x − e,x + e)
</pre>

<DT><span class="strong">BALL_INTERVAL_0</span>
<DD>
<pre>
⊢ ∀e. ball (0,e) = interval (-e,e)
</pre>

<DT><span class="strong">BALL_LINEAR_IMAGE</span>
<DD>
<pre>
⊢ ∀f x r.
    linear f ∧ (∀y. ∃x. f x = y) ∧ (∀x. abs (f x) = abs x) ⇒
    (ball (f x,r) = IMAGE f (ball (x,r)))
</pre>

<DT><span class="strong">BALL_MAX_UNION</span>
<DD>
<pre>
⊢ ∀a r s. ball (a,max r s) = ball (a,r) ∪ ball (a,s)
</pre>

<DT><span class="strong">BALL_MIN_INTER</span>
<DD>
<pre>
⊢ ∀a r s. ball (a,min r s) = ball (a,r) ∩ ball (a,s)
</pre>

<DT><span class="strong">BALL_SCALING</span>
<DD>
<pre>
⊢ ∀c. 0 < c ⇒ ∀x r. ball (c * x,c * r) = IMAGE (λx. c * x) (ball (x,r))
</pre>

<DT><span class="strong">BALL_SUBSET_CBALL</span>
<DD>
<pre>
⊢ ∀x e. ball (x,e) ⊆ cball (x,e)
</pre>

<DT><span class="strong">BALL_TRANSLATION</span>
<DD>
<pre>
⊢ ∀a x r. ball (a + x,r) = IMAGE (λy. a + y) (ball (x,r))
</pre>

<DT><span class="strong">BALL_TRIVIAL</span>
<DD>
<pre>
⊢ ∀x. ball (x,0) = ∅
</pre>

<DT><span class="strong">BALL_UNION_SPHERE</span>
<DD>
<pre>
⊢ ∀a r. ball (a,r) ∪ sphere (a,r) = cball (a,r)
</pre>

<DT><span class="strong">BANACH_FIX</span>
<DD>
<pre>
⊢ ∀f s c.
    complete s ∧ s ≠ ∅ ∧ 0 ≤ c ∧ c < 1 ∧ IMAGE f s ⊆ s ∧
    (∀x y. x ∈ s ∧ y ∈ s ⇒ dist (f x,f y) ≤ c * dist (x,y)) ⇒
    ∃!x. x ∈ s ∧ (f x = x)
</pre>

<DT><span class="strong">BASIS_CARD_EQ_DIM</span>
<DD>
<pre>
⊢ ∀v b. b ⊆ v ∧ v ⊆ span b ∧ independent b ⇒ FINITE b ∧ (CARD b = dim v)
</pre>

<DT><span class="strong">BASIS_EXISTS</span>
<DD>
<pre>
⊢ ∀v. ∃b. b ⊆ v ∧ independent b ∧ v ⊆ span b ∧ b HAS_SIZE dim v
</pre>

<DT><span class="strong">BASIS_HAS_SIZE_DIM</span>
<DD>
<pre>
⊢ ∀v b. independent b ∧ (span b = v) ⇒ b HAS_SIZE dim v
</pre>

<DT><span class="strong">BETWEEN_ABS</span>
<DD>
<pre>
⊢ ∀a b x. between x (a,b) ⇔ (abs (x − a) * (b − x) = abs (b − x) * (x − a))
</pre>

<DT><span class="strong">BETWEEN_ANTISYM</span>
<DD>
<pre>
⊢ ∀a b c. between a (b,c) ∧ between b (a,c) ⇒ (a = b)
</pre>

<DT><span class="strong">BETWEEN_IMP_COLLINEAR</span>
<DD>
<pre>
⊢ ∀a b x. between x (a,b) ⇒ collinear {a; x; b}
</pre>

<DT><span class="strong">BETWEEN_IN_SEGMENT</span>
<DD>
<pre>
⊢ ∀x a b. between x (a,b) ⇔ x ∈ segment [(a,b)]
</pre>

<DT><span class="strong">BETWEEN_MIDPOINT</span>
<DD>
<pre>
⊢ ∀a b. between (midpoint (a,b)) (a,b) ∧ between (midpoint (a,b)) (b,a)
</pre>

<DT><span class="strong">BETWEEN_REFL</span>
<DD>
<pre>
⊢ ∀a b. between a (a,b) ∧ between b (a,b) ∧ between a (a,a)
</pre>

<DT><span class="strong">BETWEEN_REFL_EQ</span>
<DD>
<pre>
⊢ ∀a x. between x (a,a) ⇔ (x = a)
</pre>

<DT><span class="strong">BETWEEN_SYM</span>
<DD>
<pre>
⊢ ∀a b x. between x (a,b) ⇔ between x (b,a)
</pre>

<DT><span class="strong">BETWEEN_TRANS</span>
<DD>
<pre>
⊢ ∀a b c d. between a (b,c) ∧ between d (a,c) ⇒ between d (b,c)
</pre>

<DT><span class="strong">BETWEEN_TRANS_2</span>
<DD>
<pre>
⊢ ∀a b c d. between a (b,c) ∧ between d (a,b) ⇒ between a (c,d)
</pre>

<DT><span class="strong">BIGUNION_COMPONENTS</span>
<DD>
<pre>
⊢ ∀u. u = BIGUNION (components u)
</pre>

<DT><span class="strong">BIGUNION_CONNECTED_COMPONENT</span>
<DD>
<pre>
⊢ ∀s. BIGUNION {connected_component s x | x | x ∈ s} = s
</pre>

<DT><span class="strong">BIGUNION_DIFF</span>
<DD>
<pre>
⊢ ∀s t. BIGUNION s DIFF t = BIGUNION {x DIFF t | x ∈ s}
</pre>

<DT><span class="strong">BIGUNION_MONO</span>
<DD>
<pre>
⊢ (∀x. x ∈ s ⇒ ∃y. y ∈ t ∧ x ⊆ y) ⇒ BIGUNION s ⊆ BIGUNION t
</pre>

<DT><span class="strong">BIGUNION_MONO_IMAGE</span>
<DD>
<pre>
⊢ (∀x. x ∈ s ⇒ f x ⊆ g x) ⇒ BIGUNION (IMAGE f s) ⊆ BIGUNION (IMAGE g s)
</pre>

<DT><span class="strong">BILINEAR_BOUNDED</span>
<DD>
<pre>
⊢ ∀h. bilinear h ⇒ ∃B. ∀x y. abs (h x y) ≤ B * abs x * abs y
</pre>

<DT><span class="strong">BILINEAR_BOUNDED_POS</span>
<DD>
<pre>
⊢ ∀h. bilinear h ⇒ ∃B. 0 < B ∧ ∀x y. abs (h x y) ≤ B * abs x * abs y
</pre>

<DT><span class="strong">BILINEAR_CONTINUOUS_COMPOSE</span>
<DD>
<pre>
⊢ ∀net f g h.
    f continuous net ∧ g continuous net ∧ bilinear h ⇒
    (λx. h (f x) (g x)) continuous net
</pre>

<DT><span class="strong">BILINEAR_CONTINUOUS_ON_COMPOSE</span>
<DD>
<pre>
⊢ ∀f g h s.
    f continuous_on s ∧ g continuous_on s ∧ bilinear h ⇒
    (λx. h (f x) (g x)) continuous_on s
</pre>

<DT><span class="strong">BILINEAR_DOT</span>
<DD>
<pre>
⊢ bilinear (λx y. x * y)
</pre>

<DT><span class="strong">BILINEAR_LADD</span>
<DD>
<pre>
⊢ ∀h x y z. bilinear h ⇒ (h (x + y) z = h x z + h y z)
</pre>

<DT><span class="strong">BILINEAR_LMUL</span>
<DD>
<pre>
⊢ ∀h c x y. bilinear h ⇒ (h (c * x) y = c * h x y)
</pre>

<DT><span class="strong">BILINEAR_LNEG</span>
<DD>
<pre>
⊢ ∀h x y. bilinear h ⇒ (h (-x) y = -h x y)
</pre>

<DT><span class="strong">BILINEAR_LSUB</span>
<DD>
<pre>
⊢ ∀h x y z. bilinear h ⇒ (h (x − y) z = h x z − h y z)
</pre>

<DT><span class="strong">BILINEAR_LZERO</span>
<DD>
<pre>
⊢ ∀h x. bilinear h ⇒ (h 0 x = 0)
</pre>

<DT><span class="strong">BILINEAR_RADD</span>
<DD>
<pre>
⊢ ∀h x y z. bilinear h ⇒ (h x (y + z) = h x y + h x z)
</pre>

<DT><span class="strong">BILINEAR_RMUL</span>
<DD>
<pre>
⊢ ∀h c x y. bilinear h ⇒ (h x (c * y) = c * h x y)
</pre>

<DT><span class="strong">BILINEAR_RNEG</span>
<DD>
<pre>
⊢ ∀h x y. bilinear h ⇒ (h x (-y) = -h x y)
</pre>

<DT><span class="strong">BILINEAR_RSUB</span>
<DD>
<pre>
⊢ ∀h x y z. bilinear h ⇒ (h x (y − z) = h x y − h x z)
</pre>

<DT><span class="strong">BILINEAR_RZERO</span>
<DD>
<pre>
⊢ ∀h x. bilinear h ⇒ (h x 0 = 0)
</pre>

<DT><span class="strong">BILINEAR_SUM</span>
<DD>
<pre>
⊢ ∀h. bilinear h ∧ FINITE s ∧ FINITE t ⇒
      (h (sum s f) (sum t g) = sum (s × t) (λ(i,j). h (f i) (g j)))
</pre>

<DT><span class="strong">BILINEAR_SUM_PARTIAL_PRE</span>
<DD>
<pre>
⊢ ∀f g h m n.
    bilinear h ⇒
    (sum {m .. n} (λk. h (f k) (g k − g (k − 1))) =
     if m ≤ n then
       h (f (n + 1)) (g n) − h (f m) (g (m − 1)) −
       sum {m .. n} (λk. h (f (k + 1) − f k) (g k))
     else 0)
</pre>

<DT><span class="strong">BILINEAR_SUM_PARTIAL_SUC</span>
<DD>
<pre>
⊢ ∀f g h m n.
    bilinear h ⇒
    (sum {m .. n} (λk. h (f k) (g (k + 1) − g k)) =
     if m ≤ n then
       h (f (n + 1)) (g (n + 1)) − h (f m) (g m) −
       sum {m .. n} (λk. h (f (k + 1) − f k) (g (k + 1)))
     else 0)
</pre>

<DT><span class="strong">BILINEAR_SWAP</span>
<DD>
<pre>
⊢ ∀op. bilinear (λx y. op y x) ⇔ bilinear op
</pre>

<DT><span class="strong">BILINEAR_UNIFORMLY_CONTINUOUS_ON_COMPOSE</span>
<DD>
<pre>
⊢ ∀f g h s.
    f uniformly_continuous_on s ∧ g uniformly_continuous_on s ∧ bilinear h ∧
    bounded (IMAGE f s) ∧ bounded (IMAGE g s) ⇒
    (λx. h (f x) (g x)) uniformly_continuous_on s
</pre>

<DT><span class="strong">BOLZANO_WEIERSTRASS</span>
<DD>
<pre>
⊢ ∀s. bounded s ∧ INFINITE s ⇒ ∃x. x limit_point_of s
</pre>

<DT><span class="strong">BOLZANO_WEIERSTRASS_CONTRAPOS</span>
<DD>
<pre>
⊢ ∀s t. compact s ∧ t ⊆ s ∧ (∀x. x ∈ s ⇒ ¬(x limit_point_of t)) ⇒ FINITE t
</pre>

<DT><span class="strong">BOLZANO_WEIERSTRASS_IMP_BOUNDED</span>
<DD>
<pre>
⊢ ∀s. (∀t. INFINITE t ∧ t ⊆ s ⇒ ∃x. x limit_point_of t) ⇒ bounded s
</pre>

<DT><span class="strong">BOLZANO_WEIERSTRASS_IMP_CLOSED</span>
<DD>
<pre>
⊢ ∀s. (∀t. INFINITE t ∧ t ⊆ s ⇒ ∃x. x ∈ s ∧ x limit_point_of t) ⇒ closed s
</pre>

<DT><span class="strong">BOUNDED_BALL</span>
<DD>
<pre>
⊢ ∀x e. bounded (ball (x,e))
</pre>

<DT><span class="strong">BOUNDED_BIGINTER</span>
<DD>
<pre>
⊢ ∀f. (∃s. s ∈ f ∧ bounded s) ⇒ bounded (BIGINTER f)
</pre>

<DT><span class="strong">BOUNDED_BIGUNION</span>
<DD>
<pre>
⊢ ∀f. FINITE f ∧ (∀s. s ∈ f ⇒ bounded s) ⇒ bounded (BIGUNION f)
</pre>

<DT><span class="strong">BOUNDED_CBALL</span>
<DD>
<pre>
⊢ ∀x e. bounded (cball (x,e))
</pre>

<DT><span class="strong">BOUNDED_CLOSED_CHAIN</span>
<DD>
<pre>
⊢ ∀f b.
    (∀s. s ∈ f ⇒ closed s ∧ s ≠ ∅) ∧ (∀s t. s ∈ f ∧ t ∈ f ⇒ s ⊆ t ∨ t ⊆ s) ∧
    b ∈ f ∧ bounded b ⇒
    BIGINTER f ≠ ∅
</pre>

<DT><span class="strong">BOUNDED_CLOSED_IMP_COMPACT</span>
<DD>
<pre>
⊢ ∀s. bounded s ∧ closed s ⇒ compact s
</pre>

<DT><span class="strong">BOUNDED_CLOSED_INTERVAL</span>
<DD>
<pre>
⊢ ∀a b. bounded (interval [(a,b)])
</pre>

<DT><span class="strong">BOUNDED_CLOSED_NEST</span>
<DD>
<pre>
⊢ ∀s. (∀n. closed (s n)) ∧ (∀n. s n ≠ ∅) ∧ (∀m n. m ≤ n ⇒ s n ⊆ s m) ∧
      bounded (s 0) ⇒
      ∃a. ∀n. a ∈ s n
</pre>

<DT><span class="strong">BOUNDED_CLOSURE</span>
<DD>
<pre>
⊢ ∀s. bounded s ⇒ bounded (closure s)
</pre>

<DT><span class="strong">BOUNDED_CLOSURE_EQ</span>
<DD>
<pre>
⊢ ∀s. bounded (closure s) ⇔ bounded s
</pre>

<DT><span class="strong">BOUNDED_COMPONENTWISE</span>
<DD>
<pre>
⊢ ∀s. bounded s ⇔ bounded (IMAGE (λx. x) s)
</pre>

<DT><span class="strong">BOUNDED_DECREASING_CONVERGENT</span>
<DD>
<pre>
⊢ ∀s. bounded {s n | n ∈ 𝕌(:num)} ∧ (∀n. s (SUC n) ≤ s n) ⇒
      ∃l. (s --> l) sequentially
</pre>

<DT><span class="strong">BOUNDED_DIFF</span>
<DD>
<pre>
⊢ ∀s t. bounded s ⇒ bounded (s DIFF t)
</pre>

<DT><span class="strong">BOUNDED_DIFFS</span>
<DD>
<pre>
⊢ ∀s t. bounded s ∧ bounded t ⇒ bounded {x − y | x ∈ s ∧ y ∈ t}
</pre>

<DT><span class="strong">BOUNDED_EMPTY</span>
<DD>
<pre>
⊢ bounded ∅
</pre>

<DT><span class="strong">BOUNDED_EQ_BOLZANO_WEIERSTRASS</span>
<DD>
<pre>
⊢ ∀s. bounded s ⇔ ∀t. t ⊆ s ∧ INFINITE t ⇒ ∃x. x limit_point_of t
</pre>

<DT><span class="strong">BOUNDED_FRONTIER</span>
<DD>
<pre>
⊢ ∀s. bounded s ⇒ bounded (frontier s)
</pre>

<DT><span class="strong">BOUNDED_HAS_INF</span>
<DD>
<pre>
⊢ ∀s. bounded s ∧ s ≠ ∅ ⇒
      (∀x. x ∈ s ⇒ inf s ≤ x) ∧ ∀b. (∀x. x ∈ s ⇒ b ≤ x) ⇒ b ≤ inf s
</pre>

<DT><span class="strong">BOUNDED_HAS_SUP</span>
<DD>
<pre>
⊢ ∀s. bounded s ∧ s ≠ ∅ ⇒
      (∀x. x ∈ s ⇒ x ≤ sup s) ∧ ∀b. (∀x. x ∈ s ⇒ x ≤ b) ⇒ sup s ≤ b
</pre>

<DT><span class="strong">BOUNDED_INCREASING_CONVERGENT</span>
<DD>
<pre>
⊢ ∀s. bounded {s n | n ∈ 𝕌(:num)} ∧ (∀n. s n ≤ s (SUC n)) ⇒
      ∃l. (s --> l) sequentially
</pre>

<DT><span class="strong">BOUNDED_INSERT</span>
<DD>
<pre>
⊢ ∀x s. bounded (x INSERT s) ⇔ bounded s
</pre>

<DT><span class="strong">BOUNDED_INTER</span>
<DD>
<pre>
⊢ ∀s t. bounded s ∨ bounded t ⇒ bounded (s ∩ t)
</pre>

<DT><span class="strong">BOUNDED_INTERIOR</span>
<DD>
<pre>
⊢ ∀s. bounded s ⇒ bounded (interior s)
</pre>

<DT><span class="strong">BOUNDED_INTERVAL</span>
<DD>
<pre>
⊢ (∀a b. bounded (interval [(a,b)])) ∧ ∀a b. bounded (interval (a,b))
</pre>

<DT><span class="strong">BOUNDED_LINEAR_IMAGE</span>
<DD>
<pre>
⊢ ∀f s. bounded s ∧ linear f ⇒ bounded (IMAGE f s)
</pre>

<DT><span class="strong">BOUNDED_NEGATIONS</span>
<DD>
<pre>
⊢ ∀s. bounded s ⇒ bounded (IMAGE (λx. -x) s)
</pre>

<DT><span class="strong">BOUNDED_PARTIAL_SUMS</span>
<DD>
<pre>
⊢ ∀f k.
    bounded {sum {k .. n} f | n ∈ 𝕌(:num)} ⇒
    bounded {sum {m .. n} f | m ∈ 𝕌(:num) ∧ n ∈ 𝕌(:num)}
</pre>

<DT><span class="strong">BOUNDED_POS</span>
<DD>
<pre>
⊢ ∀s. bounded s ⇔ ∃b. 0 < b ∧ ∀x. x ∈ s ⇒ abs x ≤ b
</pre>

<DT><span class="strong">BOUNDED_POS_LT</span>
<DD>
<pre>
⊢ ∀s. bounded s ⇔ ∃b. 0 < b ∧ ∀x. x ∈ s ⇒ abs x < b
</pre>

<DT><span class="strong">BOUNDED_SCALING</span>
<DD>
<pre>
⊢ ∀c s. bounded s ⇒ bounded (IMAGE (λx. c * x) s)
</pre>

<DT><span class="strong">BOUNDED_SING</span>
<DD>
<pre>
⊢ ∀a. bounded {a}
</pre>

<DT><span class="strong">BOUNDED_SPHERE</span>
<DD>
<pre>
⊢ ∀a r. bounded (sphere (a,r))
</pre>

<DT><span class="strong">BOUNDED_SUBSET</span>
<DD>
<pre>
⊢ ∀s t. bounded t ∧ s ⊆ t ⇒ bounded s
</pre>

<DT><span class="strong">BOUNDED_SUBSET_BALL</span>
<DD>
<pre>
⊢ ∀s x. bounded s ⇒ ∃r. 0 < r ∧ s ⊆ ball (x,r)
</pre>

<DT><span class="strong">BOUNDED_SUBSET_CBALL</span>
<DD>
<pre>
⊢ ∀s x. bounded s ⇒ ∃r. 0 < r ∧ s ⊆ cball (x,r)
</pre>

<DT><span class="strong">BOUNDED_SUBSET_CLOSED_INTERVAL</span>
<DD>
<pre>
⊢ ∀s. bounded s ⇒ ∃a b. s ⊆ interval [(a,b)]
</pre>

<DT><span class="strong">BOUNDED_SUBSET_CLOSED_INTERVAL_SYMMETRIC</span>
<DD>
<pre>
⊢ ∀s. bounded s ⇒ ∃a. s ⊆ interval [(-a,a)]
</pre>

<DT><span class="strong">BOUNDED_SUBSET_OPEN_INTERVAL</span>
<DD>
<pre>
⊢ ∀s. bounded s ⇒ ∃a b. s ⊆ interval (a,b)
</pre>

<DT><span class="strong">BOUNDED_SUBSET_OPEN_INTERVAL_SYMMETRIC</span>
<DD>
<pre>
⊢ ∀s. bounded s ⇒ ∃a. s ⊆ interval (-a,a)
</pre>

<DT><span class="strong">BOUNDED_SUMS</span>
<DD>
<pre>
⊢ ∀s t. bounded s ∧ bounded t ⇒ bounded {x + y | x ∈ s ∧ y ∈ t}
</pre>

<DT><span class="strong">BOUNDED_SUMS_IMAGE</span>
<DD>
<pre>
⊢ ∀f g t.
    bounded {f x | x ∈ t} ∧ bounded {g x | x ∈ t} ⇒
    bounded {f x + g x | x ∈ t}
</pre>

<DT><span class="strong">BOUNDED_SUMS_IMAGES</span>
<DD>
<pre>
⊢ ∀f t s.
    FINITE s ∧ (∀a. a ∈ s ⇒ bounded {f x a | x ∈ t}) ⇒
    bounded {sum s (f x) | x ∈ t}
</pre>

<DT><span class="strong">BOUNDED_TRANSLATION</span>
<DD>
<pre>
⊢ ∀a s. bounded s ⇒ bounded (IMAGE (λx. a + x) s)
</pre>

<DT><span class="strong">BOUNDED_TRANSLATION_EQ</span>
<DD>
<pre>
⊢ ∀a s. bounded (IMAGE (λx. a + x) s) ⇔ bounded s
</pre>

<DT><span class="strong">BOUNDED_UNIFORMLY_CONTINUOUS_IMAGE</span>
<DD>
<pre>
⊢ ∀f s. f uniformly_continuous_on s ∧ bounded s ⇒ bounded (IMAGE f s)
</pre>

<DT><span class="strong">BOUNDED_UNION</span>
<DD>
<pre>
⊢ ∀s t. bounded (s ∪ t) ⇔ bounded s ∧ bounded t
</pre>

<DT><span class="strong">CARD_EQ_BALL</span>
<DD>
<pre>
⊢ ∀a r. 0 < r ⇒ ball (a,r) ≈ 𝕌(:real)
</pre>

<DT><span class="strong">CARD_EQ_CBALL</span>
<DD>
<pre>
⊢ ∀a r. 0 < r ⇒ cball (a,r) ≈ 𝕌(:real)
</pre>

<DT><span class="strong">CARD_EQ_EUCLIDEAN</span>
<DD>
<pre>
⊢ 𝕌(:real) ≈ 𝕌(:real)
</pre>

<DT><span class="strong">CARD_EQ_INTERVAL</span>
<DD>
<pre>
⊢ (∀a b. interval (a,b) ≠ ∅ ⇒ interval [(a,b)] ≈ 𝕌(:real)) ∧
  ∀a b. interval (a,b) ≠ ∅ ⇒ interval (a,b) ≈ 𝕌(:real)
</pre>

<DT><span class="strong">CARD_EQ_OPEN</span>
<DD>
<pre>
⊢ ∀s. open s ∧ s ≠ ∅ ⇒ s ≈ 𝕌(:real)
</pre>

<DT><span class="strong">CARD_EQ_REAL</span>
<DD>
<pre>
⊢ 𝕌(:real) ≈ 𝕌(:num -> bool)
</pre>

<DT><span class="strong">CARD_EQ_REAL_IMP_UNCOUNTABLE</span>
<DD>
<pre>
⊢ ∀s. s ≈ 𝕌(:real) ⇒ uncountable s
</pre>

<DT><span class="strong">CARD_FRONTIER_INTERVAL</span>
<DD>
<pre>
⊢ ∀s. is_interval s ⇒ FINITE (frontier s) ∧ CARD (frontier s) ≤ 2
</pre>

<DT><span class="strong">CARD_GE_DIM_INDEPENDENT</span>
<DD>
<pre>
⊢ ∀v b. b ⊆ v ∧ independent b ∧ dim v ≤ CARD b ⇒ v ⊆ span b
</pre>

<DT><span class="strong">CARD_STDBASIS</span>
<DD>
<pre>
⊢ CARD {1} = 1
</pre>

<DT><span class="strong">CAUCHY</span>
<DD>
<pre>
⊢ ∀s. cauchy s ⇔ ∀e. 0 < e ⇒ ∃N. ∀n. n ≥ N ⇒ dist (s n,s N) < e
</pre>

<DT><span class="strong">CAUCHY_CONTINUOUS_EXTENDS_TO_CLOSURE</span>
<DD>
<pre>
⊢ ∀f s.
    (∀x. cauchy x ∧ (∀n. x n ∈ s) ⇒ cauchy (f ∘ x)) ⇒
    ∃g. g continuous_on closure s ∧ ∀x. x ∈ s ⇒ (g x = f x)
</pre>

<DT><span class="strong">CAUCHY_CONTINUOUS_IMP_CONTINUOUS</span>
<DD>
<pre>
⊢ ∀f s. (∀x. cauchy x ∧ (∀n. x n ∈ s) ⇒ cauchy (f ∘ x)) ⇒ f continuous_on s
</pre>

<DT><span class="strong">CAUCHY_CONTINUOUS_UNIQUENESS_LEMMA</span>
<DD>
<pre>
⊢ ∀f s.
    (∀x. cauchy x ∧ (∀n. x n ∈ s) ⇒ cauchy (f ∘ x)) ⇒
    ∀a x.
      (∀n. x n ∈ s) ∧ (x --> a) sequentially ⇒
      ∃l. (f ∘ x --> l) sequentially ∧
          ∀y. (∀n. y n ∈ s) ∧ (y --> a) sequentially ⇒
              (f ∘ y --> l) sequentially
</pre>

<DT><span class="strong">CAUCHY_IMP_BOUNDED</span>
<DD>
<pre>
⊢ ∀s. cauchy s ⇒ bounded {y | (∃n. y = s n)}
</pre>

<DT><span class="strong">CAUCHY_ISOMETRIC</span>
<DD>
<pre>
⊢ ∀f s e x.
    0 < e ∧ subspace s ∧ linear f ∧ (∀x. x ∈ s ⇒ abs (f x) ≥ e * abs x) ∧
    (∀n. x n ∈ s) ∧ cauchy (f ∘ x) ⇒
    cauchy x
</pre>

<DT><span class="strong">CBALL_DIFF_BALL</span>
<DD>
<pre>
⊢ ∀a r. cball (a,r) DIFF ball (a,r) = sphere (a,r)
</pre>

<DT><span class="strong">CBALL_DIFF_SPHERE</span>
<DD>
<pre>
⊢ ∀a r. cball (a,r) DIFF sphere (a,r) = ball (a,r)
</pre>

<DT><span class="strong">CBALL_EMPTY</span>
<DD>
<pre>
⊢ ∀x e. e < 0 ⇒ (cball (x,e) = ∅)
</pre>

<DT><span class="strong">CBALL_EQ_EMPTY</span>
<DD>
<pre>
⊢ ∀x e. (cball (x,e) = ∅) ⇔ e < 0
</pre>

<DT><span class="strong">CBALL_EQ_SING</span>
<DD>
<pre>
⊢ ∀x e. (cball (x,e) = {x}) ⇔ (e = 0)
</pre>

<DT><span class="strong">CBALL_INTERVAL</span>
<DD>
<pre>
⊢ ∀x e. cball (x,e) = interval [(x − e,x + e)]
</pre>

<DT><span class="strong">CBALL_INTERVAL_0</span>
<DD>
<pre>
⊢ ∀e. cball (0,e) = interval [(-e,e)]
</pre>

<DT><span class="strong">CBALL_LINEAR_IMAGE</span>
<DD>
<pre>
⊢ ∀f x r.
    linear f ∧ (∀y. ∃x. f x = y) ∧ (∀x. abs (f x) = abs x) ⇒
    (cball (f x,r) = IMAGE f (cball (x,r)))
</pre>

<DT><span class="strong">CBALL_MAX_UNION</span>
<DD>
<pre>
⊢ ∀a r s. cball (a,max r s) = cball (a,r) ∪ cball (a,s)
</pre>

<DT><span class="strong">CBALL_MIN_INTER</span>
<DD>
<pre>
⊢ ∀x d e. cball (x,min d e) = cball (x,d) ∩ cball (x,e)
</pre>

<DT><span class="strong">CBALL_SCALING</span>
<DD>
<pre>
⊢ ∀c. 0 < c ⇒ ∀x r. cball (c * x,c * r) = IMAGE (λx. c * x) (cball (x,r))
</pre>

<DT><span class="strong">CBALL_SING</span>
<DD>
<pre>
⊢ ∀x e. (e = 0) ⇒ (cball (x,e) = {x})
</pre>

<DT><span class="strong">CBALL_TRANSLATION</span>
<DD>
<pre>
⊢ ∀a x r. cball (a + x,r) = IMAGE (λy. a + y) (cball (x,r))
</pre>

<DT><span class="strong">CBALL_TRIVIAL</span>
<DD>
<pre>
⊢ ∀x. cball (x,0) = {x}
</pre>

<DT><span class="strong">CENTRE_IN_BALL</span>
<DD>
<pre>
⊢ ∀x e. x ∈ ball (x,e) ⇔ 0 < e
</pre>

<DT><span class="strong">CENTRE_IN_CBALL</span>
<DD>
<pre>
⊢ ∀x e. x ∈ cball (x,e) ⇔ 0 ≤ e
</pre>

<DT><span class="strong">CLOPEN</span>
<DD>
<pre>
⊢ ∀s. closed s ∧ open s ⇔ (s = ∅) ∨ (s = 𝕌(:real))
</pre>

<DT><span class="strong">CLOPEN_BIGUNION_COMPONENTS</span>
<DD>
<pre>
⊢ ∀u s.
    closed_in (subtopology euclidean u) s ∧
    open_in (subtopology euclidean u) s ⇒
    ∃k. k ⊆ components u ∧ (s = BIGUNION k)
</pre>

<DT><span class="strong">CLOPEN_IN_COMPONENTS</span>
<DD>
<pre>
⊢ ∀u s.
    closed_in (subtopology euclidean u) s ∧
    open_in (subtopology euclidean u) s ∧ connected s ∧ s ≠ ∅ ⇒
    s ∈ components u
</pre>

<DT><span class="strong">CLOSED</span>
<DD>
<pre>
⊢ ∀s. closed s ⇔
      ∀x. (∀e. 0 < e ⇒ ∃x'. x' ∈ s ∧ x' ≠ x ∧ abs (x' − x) < e) ⇒ x ∈ s
</pre>

<DT><span class="strong">CLOSED_APPROACHABLE</span>
<DD>
<pre>
⊢ ∀x s. closed s ⇒ ((∀e. 0 < e ⇒ ∃y. y ∈ s ∧ dist (y,x) < e) ⇔ x ∈ s)
</pre>

<DT><span class="strong">CLOSED_AS_GDELTA</span>
<DD>
<pre>
⊢ ∀s. closed s ⇒ gdelta s
</pre>

<DT><span class="strong">CLOSED_BIGINTER</span>
<DD>
<pre>
⊢ ∀f. (∀s. s ∈ f ⇒ closed s) ⇒ closed (BIGINTER f)
</pre>

<DT><span class="strong">CLOSED_BIGINTER_COMPACT</span>
<DD>
<pre>
⊢ ∀s. closed s ⇔ ∀e. compact (cball (0,e) ∩ s)
</pre>

<DT><span class="strong">CLOSED_BIGUNION</span>
<DD>
<pre>
⊢ ∀s. FINITE s ∧ (∀t. t ∈ s ⇒ closed t) ⇒ closed (BIGUNION s)
</pre>

<DT><span class="strong">CLOSED_CBALL</span>
<DD>
<pre>
⊢ ∀x e. closed (cball (x,e))
</pre>

<DT><span class="strong">CLOSED_CLOSURE</span>
<DD>
<pre>
⊢ ∀s. closed (closure s)
</pre>

<DT><span class="strong">CLOSED_COMPACT_DIFFERENCES</span>
<DD>
<pre>
⊢ ∀s t. closed s ∧ compact t ⇒ closed {x − y | x ∈ s ∧ y ∈ t}
</pre>

<DT><span class="strong">CLOSED_COMPACT_SUMS</span>
<DD>
<pre>
⊢ ∀s t. closed s ∧ compact t ⇒ closed {x + y | x ∈ s ∧ y ∈ t}
</pre>

<DT><span class="strong">CLOSED_COMPONENTS</span>
<DD>
<pre>
⊢ ∀s c. closed s ∧ c ∈ components s ⇒ closed c
</pre>

<DT><span class="strong">CLOSED_CONNECTED_COMPONENT</span>
<DD>
<pre>
⊢ ∀s x. closed s ⇒ closed (connected_component s x)
</pre>

<DT><span class="strong">CLOSED_CONTAINS_SEQUENTIAL_LIMIT</span>
<DD>
<pre>
⊢ ∀s x l. closed s ∧ (∀n. x n ∈ s) ∧ (x --> l) sequentially ⇒ l ∈ s
</pre>

<DT><span class="strong">CLOSED_DIFF</span>
<DD>
<pre>
⊢ ∀s t. closed s ∧ open t ⇒ closed (s DIFF t)
</pre>

<DT><span class="strong">CLOSED_DIFF_OPEN_INTERVAL</span>
<DD>
<pre>
⊢ ∀a b.
    interval [(a,b)] DIFF interval (a,b) =
    if interval [(a,b)] = ∅ then ∅ else {a; b}
</pre>

<DT><span class="strong">CLOSED_EMPTY</span>
<DD>
<pre>
⊢ closed ∅
</pre>

<DT><span class="strong">CLOSED_FIP</span>
<DD>
<pre>
⊢ ∀f. (∀t. t ∈ f ⇒ closed t) ∧ (∃t. t ∈ f ∧ bounded t) ∧
      (∀f'. FINITE f' ∧ f' ⊆ f ⇒ BIGINTER f' ≠ ∅) ⇒
      BIGINTER f ≠ ∅
</pre>

<DT><span class="strong">CLOSED_FORALL</span>
<DD>
<pre>
⊢ ∀Q. (∀a. closed {x | Q a x}) ⇒ closed {x | (∀a. Q a x)}
</pre>

<DT><span class="strong">CLOSED_FORALL_IN</span>
<DD>
<pre>
⊢ ∀P Q. (∀a. P a ⇒ closed {x | Q a x}) ⇒ closed {x | (∀a. P a ⇒ Q a x)}
</pre>

<DT><span class="strong">CLOSED_HALFSPACE_COMPONENT_GE</span>
<DD>
<pre>
⊢ ∀a. closed {x | x ≥ a}
</pre>

<DT><span class="strong">CLOSED_HALFSPACE_COMPONENT_LE</span>
<DD>
<pre>
⊢ ∀a. closed {x | x ≤ a}
</pre>

<DT><span class="strong">CLOSED_HALFSPACE_GE</span>
<DD>
<pre>
⊢ ∀a b. closed {x | a * x ≥ b}
</pre>

<DT><span class="strong">CLOSED_HALFSPACE_LE</span>
<DD>
<pre>
⊢ ∀a b. closed {x | a * x ≤ b}
</pre>

<DT><span class="strong">CLOSED_HYPERPLANE</span>
<DD>
<pre>
⊢ ∀a b. closed {x | a * x = b}
</pre>

<DT><span class="strong">CLOSED_IMP_FIP</span>
<DD>
<pre>
⊢ ∀s f.
    closed s ∧ (∀t. t ∈ f ⇒ closed t) ∧ (∃t. t ∈ f ∧ bounded t) ∧
    (∀f'. FINITE f' ∧ f' ⊆ f ⇒ s ∩ BIGINTER f' ≠ ∅) ⇒
    s ∩ BIGINTER f ≠ ∅
</pre>

<DT><span class="strong">CLOSED_IMP_FIP_COMPACT</span>
<DD>
<pre>
⊢ ∀s f.
    closed s ∧ (∀t. t ∈ f ⇒ compact t) ∧
    (∀f'. FINITE f' ∧ f' ⊆ f ⇒ s ∩ BIGINTER f' ≠ ∅) ⇒
    s ∩ BIGINTER f ≠ ∅
</pre>

<DT><span class="strong">CLOSED_IMP_LOCALLY_COMPACT</span>
<DD>
<pre>
⊢ ∀s. closed s ⇒ locally compact s
</pre>

<DT><span class="strong">CLOSED_IN</span>
<DD>
<pre>
⊢ ∀s. closed s ⇔ closed_in euclidean s
</pre>

<DT><span class="strong">CLOSED_INJECTIVE_IMAGE_SUBSPACE</span>
<DD>
<pre>
⊢ ∀f s.
    subspace s ∧ linear f ∧ (∀x. x ∈ s ∧ (f x = 0) ⇒ (x = 0)) ∧ closed s ⇒
    closed (IMAGE f s)
</pre>

<DT><span class="strong">CLOSED_INJECTIVE_LINEAR_IMAGE</span>
<DD>
<pre>
⊢ ∀f. linear f ∧ (∀x y. (f x = f y) ⇒ (x = y)) ⇒
      ∀s. closed s ⇒ closed (IMAGE f s)
</pre>

<DT><span class="strong">CLOSED_INJECTIVE_LINEAR_IMAGE_EQ</span>
<DD>
<pre>
⊢ ∀f s.
    linear f ∧ (∀x y. (f x = f y) ⇒ (x = y)) ⇒ (closed (IMAGE f s) ⇔ closed s)
</pre>

<DT><span class="strong">CLOSED_INSERT</span>
<DD>
<pre>
⊢ ∀a s. closed s ⇒ closed (a INSERT s)
</pre>

<DT><span class="strong">CLOSED_INTER</span>
<DD>
<pre>
⊢ ∀s t. closed s ∧ closed t ⇒ closed (s ∩ t)
</pre>

<DT><span class="strong">CLOSED_INTERVAL</span>
<DD>
<pre>
⊢ ∀a b. closed (interval [(a,b)])
</pre>

<DT><span class="strong">CLOSED_INTERVAL_EQ</span>
<DD>
<pre>
⊢ (∀a b. closed (interval [(a,b)])) ∧
  ∀a b. closed (interval (a,b)) ⇔ (interval (a,b) = ∅)
</pre>

<DT><span class="strong">CLOSED_INTERVAL_IMAGE_UNIT_INTERVAL</span>
<DD>
<pre>
⊢ ∀a b.
    interval [(a,b)] ≠ ∅ ⇒
    (interval [(a,b)] =
     IMAGE (λx. a + x) (IMAGE (λx. @f. f = (b − a) * x) (interval [(0,1)])))
</pre>

<DT><span class="strong">CLOSED_INTERVAL_LEFT</span>
<DD>
<pre>
⊢ ∀b. closed {x | x ≤ b}
</pre>

<DT><span class="strong">CLOSED_INTERVAL_RIGHT</span>
<DD>
<pre>
⊢ ∀a. closed {x | a ≤ x}
</pre>

<DT><span class="strong">CLOSED_INTER_COMPACT</span>
<DD>
<pre>
⊢ ∀s t. closed s ∧ compact t ⇒ compact (s ∩ t)
</pre>

<DT><span class="strong">CLOSED_IN_CLOSED</span>
<DD>
<pre>
⊢ ∀s u. closed_in (subtopology euclidean u) s ⇔ ∃t. closed t ∧ (s = u ∩ t)
</pre>

<DT><span class="strong">CLOSED_IN_CLOSED_EQ</span>
<DD>
<pre>
⊢ ∀s t. closed s ⇒ (closed_in (subtopology euclidean s) t ⇔ closed t ∧ t ⊆ s)
</pre>

<DT><span class="strong">CLOSED_IN_CLOSED_INTER</span>
<DD>
<pre>
⊢ ∀u s. closed s ⇒ closed_in (subtopology euclidean u) (u ∩ s)
</pre>

<DT><span class="strong">CLOSED_IN_CLOSED_TRANS</span>
<DD>
<pre>
⊢ ∀s t. closed_in (subtopology euclidean t) s ∧ closed t ⇒ closed s
</pre>

<DT><span class="strong">CLOSED_IN_COMPACT</span>
<DD>
<pre>
⊢ ∀s t. compact s ∧ closed_in (subtopology euclidean s) t ⇒ compact t
</pre>

<DT><span class="strong">CLOSED_IN_COMPACT_EQ</span>
<DD>
<pre>
⊢ ∀s t.
    compact s ⇒ (closed_in (subtopology euclidean s) t ⇔ compact t ∧ t ⊆ s)
</pre>

<DT><span class="strong">CLOSED_IN_COMPONENT</span>
<DD>
<pre>
⊢ ∀s c. c ∈ components s ⇒ closed_in (subtopology euclidean s) c
</pre>

<DT><span class="strong">CLOSED_IN_CONNECTED_COMPONENT</span>
<DD>
<pre>
⊢ ∀s x. closed_in (subtopology euclidean s) (connected_component s x)
</pre>

<DT><span class="strong">CLOSED_IN_INTER_CLOSED</span>
<DD>
<pre>
⊢ ∀s t u.
    closed_in (subtopology euclidean u) s ∧ closed t ⇒
    closed_in (subtopology euclidean u) (s ∩ t)
</pre>

<DT><span class="strong">CLOSED_IN_INTER_CLOSURE</span>
<DD>
<pre>
⊢ ∀s t. closed_in (subtopology euclidean s) t ⇔ (s ∩ closure t = t)
</pre>

<DT><span class="strong">CLOSED_IN_LIMPT</span>
<DD>
<pre>
⊢ ∀s t.
    closed_in (subtopology euclidean t) s ⇔
    s ⊆ t ∧ ∀x. x limit_point_of s ∧ x ∈ t ⇒ x ∈ s
</pre>

<DT><span class="strong">CLOSED_IN_REFL</span>
<DD>
<pre>
⊢ ∀s. closed_in (subtopology euclidean s) s
</pre>

<DT><span class="strong">CLOSED_IN_SING</span>
<DD>
<pre>
⊢ ∀u x. closed_in (subtopology euclidean u) {x} ⇔ x ∈ u
</pre>

<DT><span class="strong">CLOSED_IN_SUBSET_TRANS</span>
<DD>
<pre>
⊢ ∀s t u.
    closed_in (subtopology euclidean u) s ∧ s ⊆ t ∧ t ⊆ u ⇒
    closed_in (subtopology euclidean t) s
</pre>

<DT><span class="strong">CLOSED_IN_TRANS</span>
<DD>
<pre>
⊢ ∀s t u.
    closed_in (subtopology euclidean t) s ∧
    closed_in (subtopology euclidean u) t ⇒
    closed_in (subtopology euclidean u) s
</pre>

<DT><span class="strong">CLOSED_IN_TRANS_EQ</span>
<DD>
<pre>
⊢ ∀s t.
    (∀u. closed_in (subtopology euclidean t) u ⇒
         closed_in (subtopology euclidean s) t) ⇔
    closed_in (subtopology euclidean s) t
</pre>

<DT><span class="strong">CLOSED_LIMPT</span>
<DD>
<pre>
⊢ ∀s. closed s ⇔ ∀x. x limit_point_of s ⇒ x ∈ s
</pre>

<DT><span class="strong">CLOSED_LIMPTS</span>
<DD>
<pre>
⊢ ∀s. closed {x | x limit_point_of s}
</pre>

<DT><span class="strong">CLOSED_MAP_CLOSURES</span>
<DD>
<pre>
⊢ ∀f. (∀s. closed s ⇒ closed (IMAGE f s)) ⇔
      ∀s. closure (IMAGE f s) ⊆ IMAGE f (closure s)
</pre>

<DT><span class="strong">CLOSED_MAP_FROM_COMPOSITION_INJECTIVE</span>
<DD>
<pre>
⊢ ∀f g s t u.
    IMAGE f s ⊆ t ∧ IMAGE g t ⊆ u ∧ g continuous_on t ∧
    (∀x y. x ∈ t ∧ y ∈ t ∧ (g x = g y) ⇒ (x = y)) ∧
    (∀k. closed_in (subtopology euclidean s) k ⇒
         closed_in (subtopology euclidean u) (IMAGE (g ∘ f) k)) ⇒
    ∀k. closed_in (subtopology euclidean s) k ⇒
        closed_in (subtopology euclidean t) (IMAGE f k)
</pre>

<DT><span class="strong">CLOSED_MAP_FROM_COMPOSITION_SURJECTIVE</span>
<DD>
<pre>
⊢ ∀f g s t u.
    f continuous_on s ∧ (IMAGE f s = t) ∧ IMAGE g t ⊆ u ∧
    (∀k. closed_in (subtopology euclidean s) k ⇒
         closed_in (subtopology euclidean u) (IMAGE (g ∘ f) k)) ⇒
    ∀k. closed_in (subtopology euclidean t) k ⇒
        closed_in (subtopology euclidean u) (IMAGE g k)
</pre>

<DT><span class="strong">CLOSED_MAP_IFF_UPPER_HEMICONTINUOUS_PREIMAGE</span>
<DD>
<pre>
⊢ ∀f s t.
    IMAGE f s ⊆ t ⇒
    ((∀u. closed_in (subtopology euclidean s) u ⇒
          closed_in (subtopology euclidean t) (IMAGE f u)) ⇔
     ∀u. open_in (subtopology euclidean s) u ⇒
         open_in (subtopology euclidean t)
           {y | y ∈ t ∧ {x | x ∈ s ∧ (f x = y)} ⊆ u})
</pre>

<DT><span class="strong">CLOSED_MAP_IMP_OPEN_MAP</span>
<DD>
<pre>
⊢ ∀f s t.
    (IMAGE f s = t) ∧
    (∀u. closed_in (subtopology euclidean s) u ⇒
         closed_in (subtopology euclidean t) (IMAGE f u)) ∧
    (∀u. open_in (subtopology euclidean s) u ⇒
         open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ IMAGE f u}) ⇒
    ∀u. open_in (subtopology euclidean s) u ⇒
        open_in (subtopology euclidean t) (IMAGE f u)
</pre>

<DT><span class="strong">CLOSED_MAP_IMP_QUOTIENT_MAP</span>
<DD>
<pre>
⊢ ∀f s.
    f continuous_on s ∧
    (∀t. closed_in (subtopology euclidean s) t ⇒
         closed_in (subtopology euclidean (IMAGE f s)) (IMAGE f t)) ⇒
    ∀t. t ⊆ IMAGE f s ⇒
        (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ t} ⇔
         open_in (subtopology euclidean (IMAGE f s)) t)
</pre>

<DT><span class="strong">CLOSED_MAP_OPEN_SUPERSET_PREIMAGE</span>
<DD>
<pre>
⊢ ∀f s t u w.
    (∀k. closed_in (subtopology euclidean s) k ⇒
         closed_in (subtopology euclidean t) (IMAGE f k)) ∧
    open_in (subtopology euclidean s) u ∧ w ⊆ t ∧ {x | x ∈ s ∧ f x ∈ w} ⊆ u ⇒
    ∃v. open_in (subtopology euclidean t) v ∧ w ⊆ v ∧
        {x | x ∈ s ∧ f x ∈ v} ⊆ u
</pre>

<DT><span class="strong">CLOSED_MAP_OPEN_SUPERSET_PREIMAGE_EQ</span>
<DD>
<pre>
⊢ ∀f s t.
    IMAGE f s ⊆ t ⇒
    ((∀k. closed_in (subtopology euclidean s) k ⇒
          closed_in (subtopology euclidean t) (IMAGE f k)) ⇔
     ∀u w.
       open_in (subtopology euclidean s) u ∧ w ⊆ t ∧ {x | x ∈ s ∧ f x ∈ w} ⊆ u ⇒
       ∃v. open_in (subtopology euclidean t) v ∧ w ⊆ v ∧
           {x | x ∈ s ∧ f x ∈ v} ⊆ u)
</pre>

<DT><span class="strong">CLOSED_MAP_OPEN_SUPERSET_PREIMAGE_POINT</span>
<DD>
<pre>
⊢ ∀f s t.
    IMAGE f s ⊆ t ⇒
    ((∀k. closed_in (subtopology euclidean s) k ⇒
          closed_in (subtopology euclidean t) (IMAGE f k)) ⇔
     ∀u y.
       open_in (subtopology euclidean s) u ∧ y ∈ t ∧
       {x | x ∈ s ∧ (f x = y)} ⊆ u ⇒
       ∃v. open_in (subtopology euclidean t) v ∧ y ∈ v ∧
           {x | x ∈ s ∧ f x ∈ v} ⊆ u)
</pre>

<DT><span class="strong">CLOSED_MAP_RESTRICT</span>
<DD>
<pre>
⊢ ∀f s t t'.
    (∀u. closed_in (subtopology euclidean s) u ⇒
         closed_in (subtopology euclidean t) (IMAGE f u)) ∧ t' ⊆ t ⇒
    ∀u. closed_in (subtopology euclidean {x | x ∈ s ∧ f x ∈ t'}) u ⇒
        closed_in (subtopology euclidean t') (IMAGE f u)
</pre>

<DT><span class="strong">CLOSED_NEGATIONS</span>
<DD>
<pre>
⊢ ∀s. closed s ⇒ closed (IMAGE (λx. -x) s)
</pre>

<DT><span class="strong">CLOSED_OPEN_INTERVAL</span>
<DD>
<pre>
⊢ ∀a b. a ≤ b ⇒ (interval [(a,b)] = interval (a,b) ∪ {a; b})
</pre>

<DT><span class="strong">CLOSED_POSITIVE_ORTHANT</span>
<DD>
<pre>
⊢ closed {x | 0 ≤ x}
</pre>

<DT><span class="strong">CLOSED_SCALING</span>
<DD>
<pre>
⊢ ∀s c. closed s ⇒ closed (IMAGE (λx. c * x) s)
</pre>

<DT><span class="strong">CLOSED_SEGMENT_LINEAR_IMAGE</span>
<DD>
<pre>
⊢ ∀f a b. linear f ⇒ (segment [(f a,f b)] = IMAGE f (segment [(a,b)]))
</pre>

<DT><span class="strong">CLOSED_SEQUENTIAL_LIMITS</span>
<DD>
<pre>
⊢ ∀s. closed s ⇔ ∀x l. (∀n. x n ∈ s) ∧ (x --> l) sequentially ⇒ l ∈ s
</pre>

<DT><span class="strong">CLOSED_SING</span>
<DD>
<pre>
⊢ ∀a. closed {a}
</pre>

<DT><span class="strong">CLOSED_SPHERE</span>
<DD>
<pre>
⊢ ∀a r. closed (sphere (a,r))
</pre>

<DT><span class="strong">CLOSED_STANDARD_HYPERPLANE</span>
<DD>
<pre>
⊢ ∀a. closed {x | x = a}
</pre>

<DT><span class="strong">CLOSED_SUBSET</span>
<DD>
<pre>
⊢ ∀s t. s ⊆ t ∧ closed s ⇒ closed_in (subtopology euclidean t) s
</pre>

<DT><span class="strong">CLOSED_SUBSET_EQ</span>
<DD>
<pre>
⊢ ∀u s. closed s ⇒ (closed_in (subtopology euclidean u) s ⇔ s ⊆ u)
</pre>

<DT><span class="strong">CLOSED_SUBSTANDARD</span>
<DD>
<pre>
⊢ closed {x | x = 0}
</pre>

<DT><span class="strong">CLOSED_UNION</span>
<DD>
<pre>
⊢ ∀s t. closed s ∧ closed t ⇒ closed (s ∪ t)
</pre>

<DT><span class="strong">CLOSED_UNION_COMPACT_SUBSETS</span>
<DD>
<pre>
⊢ ∀s. closed s ⇒
      ∃f. (∀n. compact (f n)) ∧ (∀n. f n ⊆ s) ∧ (∀n. f n ⊆ f (n + 1)) ∧
          (BIGUNION {f n | n ∈ 𝕌(:num)} = s) ∧
          ∀k. compact k ∧ k ⊆ s ⇒ ∃N. ∀n. n ≥ N ⇒ k ⊆ f n
</pre>

<DT><span class="strong">CLOSED_UNIV</span>
<DD>
<pre>
⊢ closed 𝕌(:real)
</pre>

<DT><span class="strong">CLOSEST_POINT_EXISTS</span>
<DD>
<pre>
⊢ ∀s a.
    closed s ∧ s ≠ ∅ ⇒
    closest_point s a ∈ s ∧
    ∀y. y ∈ s ⇒ dist (a,closest_point s a) ≤ dist (a,y)
</pre>

<DT><span class="strong">CLOSEST_POINT_IN_FRONTIER</span>
<DD>
<pre>
⊢ ∀s x. closed s ∧ s ≠ ∅ ∧ x ∉ interior s ⇒ closest_point s x ∈ frontier s
</pre>

<DT><span class="strong">CLOSEST_POINT_IN_INTERIOR</span>
<DD>
<pre>
⊢ ∀s x. closed s ∧ s ≠ ∅ ⇒ (closest_point s x ∈ interior s ⇔ x ∈ interior s)
</pre>

<DT><span class="strong">CLOSEST_POINT_IN_SET</span>
<DD>
<pre>
⊢ ∀s a. closed s ∧ s ≠ ∅ ⇒ closest_point s a ∈ s
</pre>

<DT><span class="strong">CLOSEST_POINT_LE</span>
<DD>
<pre>
⊢ ∀s a x. closed s ∧ x ∈ s ⇒ dist (a,closest_point s a) ≤ dist (a,x)
</pre>

<DT><span class="strong">CLOSEST_POINT_REFL</span>
<DD>
<pre>
⊢ ∀s x. closed s ∧ s ≠ ∅ ⇒ ((closest_point s x = x) ⇔ x ∈ s)
</pre>

<DT><span class="strong">CLOSEST_POINT_SELF</span>
<DD>
<pre>
⊢ ∀s x. x ∈ s ⇒ (closest_point s x = x)
</pre>

<DT><span class="strong">CLOSURE_APPROACHABLE</span>
<DD>
<pre>
⊢ ∀x s. x ∈ closure s ⇔ ∀e. 0 < e ⇒ ∃y. y ∈ s ∧ dist (y,x) < e
</pre>

<DT><span class="strong">CLOSURE_BALL</span>
<DD>
<pre>
⊢ ∀x e. 0 < e ⇒ (closure (ball (x,e)) = cball (x,e))
</pre>

<DT><span class="strong">CLOSURE_BIGINTER_SUBSET</span>
<DD>
<pre>
⊢ ∀f. closure (BIGINTER f) ⊆ BIGINTER (IMAGE closure f)
</pre>

<DT><span class="strong">CLOSURE_BIGUNION</span>
<DD>
<pre>
⊢ ∀f. FINITE f ⇒ (closure (BIGUNION f) = BIGUNION {closure s | s ∈ f})
</pre>

<DT><span class="strong">CLOSURE_BOUNDED_LINEAR_IMAGE</span>
<DD>
<pre>
⊢ ∀f s. linear f ∧ bounded s ⇒ (closure (IMAGE f s) = IMAGE f (closure s))
</pre>

<DT><span class="strong">CLOSURE_CLOSED</span>
<DD>
<pre>
⊢ ∀s. closed s ⇒ (closure s = s)
</pre>

<DT><span class="strong">CLOSURE_CLOSURE</span>
<DD>
<pre>
⊢ ∀s. closure (closure s) = closure s
</pre>

<DT><span class="strong">CLOSURE_COMPLEMENT</span>
<DD>
<pre>
⊢ ∀s. closure (𝕌(:real) DIFF s) = 𝕌(:real) DIFF interior s
</pre>

<DT><span class="strong">CLOSURE_EMPTY</span>
<DD>
<pre>
⊢ closure ∅ = ∅
</pre>

<DT><span class="strong">CLOSURE_EQ</span>
<DD>
<pre>
⊢ ∀s. (closure s = s) ⇔ closed s
</pre>

<DT><span class="strong">CLOSURE_EQ_EMPTY</span>
<DD>
<pre>
⊢ ∀s. (closure s = ∅) ⇔ (s = ∅)
</pre>

<DT><span class="strong">CLOSURE_HALFSPACE_COMPONENT_GT</span>
<DD>
<pre>
⊢ ∀a. closure {x | x > a} = {x | x ≥ a}
</pre>

<DT><span class="strong">CLOSURE_HALFSPACE_COMPONENT_LT</span>
<DD>
<pre>
⊢ ∀a. closure {x | x < a} = {x | x ≤ a}
</pre>

<DT><span class="strong">CLOSURE_HALFSPACE_GT</span>
<DD>
<pre>
⊢ ∀a b. a ≠ 0 ⇒ (closure {x | a * x > b} = {x | a * x ≥ b})
</pre>

<DT><span class="strong">CLOSURE_HALFSPACE_LT</span>
<DD>
<pre>
⊢ ∀a b. a ≠ 0 ⇒ (closure {x | a * x < b} = {x | a * x ≤ b})
</pre>

<DT><span class="strong">CLOSURE_HULL</span>
<DD>
<pre>
⊢ ∀s. closure s = closed hull s
</pre>

<DT><span class="strong">CLOSURE_HYPERPLANE</span>
<DD>
<pre>
⊢ ∀a b. closure {x | a * x = b} = {x | a * x = b}
</pre>

<DT><span class="strong">CLOSURE_IMAGE_BOUNDED</span>
<DD>
<pre>
⊢ ∀f s.
    f continuous_on closure s ∧ bounded s ⇒
    (closure (IMAGE f s) = IMAGE f (closure s))
</pre>

<DT><span class="strong">CLOSURE_IMAGE_CLOSURE</span>
<DD>
<pre>
⊢ ∀f s.
    f continuous_on closure s ⇒
    (closure (IMAGE f (closure s)) = closure (IMAGE f s))
</pre>

<DT><span class="strong">CLOSURE_INJECTIVE_LINEAR_IMAGE</span>
<DD>
<pre>
⊢ ∀f s.
    linear f ∧ (∀x y. (f x = f y) ⇒ (x = y)) ⇒
    (closure (IMAGE f s) = IMAGE f (closure s))
</pre>

<DT><span class="strong">CLOSURE_INTERIOR</span>
<DD>
<pre>
⊢ ∀s. closure s = 𝕌(:real) DIFF interior (𝕌(:real) DIFF s)
</pre>

<DT><span class="strong">CLOSURE_INTERIOR_IDEMP</span>
<DD>
<pre>
⊢ ∀s. closure (interior (closure (interior s))) = closure (interior s)
</pre>

<DT><span class="strong">CLOSURE_INTERIOR_UNION_CLOSED</span>
<DD>
<pre>
⊢ ∀s t.
    closed s ∧ closed t ⇒
    (closure (interior (s ∪ t)) = closure (interior s) ∪ closure (interior t))
</pre>

<DT><span class="strong">CLOSURE_INTERVAL</span>
<DD>
<pre>
⊢ (∀a b. closure (interval [(a,b)]) = interval [(a,b)]) ∧
  ∀a b.
    closure (interval (a,b)) =
    if interval (a,b) = ∅ then ∅ else interval [(a,b)]
</pre>

<DT><span class="strong">CLOSURE_INTER_SUBSET</span>
<DD>
<pre>
⊢ ∀s t. closure (s ∩ t) ⊆ closure s ∩ closure t
</pre>

<DT><span class="strong">CLOSURE_LINEAR_IMAGE_SUBSET</span>
<DD>
<pre>
⊢ ∀f s. linear f ⇒ IMAGE f (closure s) ⊆ closure (IMAGE f s)
</pre>

<DT><span class="strong">CLOSURE_MINIMAL</span>
<DD>
<pre>
⊢ ∀s t. s ⊆ t ∧ closed t ⇒ closure s ⊆ t
</pre>

<DT><span class="strong">CLOSURE_MINIMAL_EQ</span>
<DD>
<pre>
⊢ ∀s t. closed t ⇒ (closure s ⊆ t ⇔ s ⊆ t)
</pre>

<DT><span class="strong">CLOSURE_NEGATIONS</span>
<DD>
<pre>
⊢ ∀s. closure (IMAGE (λx. -x) s) = IMAGE (λx. -x) (closure s)
</pre>

<DT><span class="strong">CLOSURE_NONEMPTY_OPEN_INTER</span>
<DD>
<pre>
⊢ ∀s x. x ∈ closure s ⇔ ∀t. x ∈ t ∧ open t ⇒ s ∩ t ≠ ∅
</pre>

<DT><span class="strong">CLOSURE_OPEN_INTERVAL</span>
<DD>
<pre>
⊢ ∀a b. interval (a,b) ≠ ∅ ⇒ (closure (interval (a,b)) = interval [(a,b)])
</pre>

<DT><span class="strong">CLOSURE_OPEN_INTER_CLOSURE</span>
<DD>
<pre>
⊢ ∀s t. open s ⇒ (closure (s ∩ closure t) = closure (s ∩ t))
</pre>

<DT><span class="strong">CLOSURE_OPEN_INTER_SUPERSET</span>
<DD>
<pre>
⊢ ∀s t. open s ∧ s ⊆ closure t ⇒ (closure (s ∩ t) = closure s)
</pre>

<DT><span class="strong">CLOSURE_OPEN_IN_INTER_CLOSURE</span>
<DD>
<pre>
⊢ ∀s t u.
    open_in (subtopology euclidean u) s ∧ t ⊆ u ⇒
    (closure (s ∩ closure t) = closure (s ∩ t))
</pre>

<DT><span class="strong">CLOSURE_SEQUENTIAL</span>
<DD>
<pre>
⊢ ∀s l. l ∈ closure s ⇔ ∃x. (∀n. x n ∈ s) ∧ (x --> l) sequentially
</pre>

<DT><span class="strong">CLOSURE_SING</span>
<DD>
<pre>
⊢ ∀x. closure {x} = {x}
</pre>

<DT><span class="strong">CLOSURE_SUBSET</span>
<DD>
<pre>
⊢ ∀s. s ⊆ closure s
</pre>

<DT><span class="strong">CLOSURE_SUBSET_EQ</span>
<DD>
<pre>
⊢ ∀s. closure s ⊆ s ⇔ closed s
</pre>

<DT><span class="strong">CLOSURE_SUMS</span>
<DD>
<pre>
⊢ ∀s t.
    bounded s ∨ bounded t ⇒
    (closure {x + y | x ∈ s ∧ y ∈ t} = {x + y | x ∈ closure s ∧ y ∈ closure t})
</pre>

<DT><span class="strong">CLOSURE_UNION</span>
<DD>
<pre>
⊢ ∀s t. closure (s ∪ t) = closure s ∪ closure t
</pre>

<DT><span class="strong">CLOSURE_UNION_FRONTIER</span>
<DD>
<pre>
⊢ ∀s. closure s = s ∪ frontier s
</pre>

<DT><span class="strong">CLOSURE_UNIQUE</span>
<DD>
<pre>
⊢ ∀s t.
    s ⊆ t ∧ closed t ∧ (∀t'. s ⊆ t' ∧ closed t' ⇒ t ⊆ t') ⇒ (closure s = t)
</pre>

<DT><span class="strong">CLOSURE_UNIV</span>
<DD>
<pre>
⊢ closure 𝕌(:real) = 𝕌(:real)
</pre>

<DT><span class="strong">COBOUNDED_IMP_UNBOUNDED</span>
<DD>
<pre>
⊢ ∀s. bounded (𝕌(:real) DIFF s) ⇒ ¬bounded s
</pre>

<DT><span class="strong">COBOUNDED_INTER_UNBOUNDED</span>
<DD>
<pre>
⊢ ∀s t. bounded (𝕌(:real) DIFF s) ∧ ¬bounded t ⇒ s ∩ t ≠ ∅
</pre>

<DT><span class="strong">COLLINEAR_1</span>
<DD>
<pre>
⊢ ∀s. collinear s
</pre>

<DT><span class="strong">COLLINEAR_2</span>
<DD>
<pre>
⊢ ∀x y. collinear {x; y}
</pre>

<DT><span class="strong">COLLINEAR_3</span>
<DD>
<pre>
⊢ ∀x y z. collinear {x; y; z} ⇔ collinear {0; x − y; z − y}
</pre>

<DT><span class="strong">COLLINEAR_3_EXPAND</span>
<DD>
<pre>
⊢ ∀a b c. collinear {a; b; c} ⇔ (a = c) ∨ ∃u. b = u * a + (1 − u) * c
</pre>

<DT><span class="strong">COLLINEAR_3_TRANS</span>
<DD>
<pre>
⊢ ∀a b c d.
    collinear {a; b; c} ∧ collinear {b; c; d} ∧ b ≠ c ⇒ collinear {a; b; d}
</pre>

<DT><span class="strong">COLLINEAR_4_3</span>
<DD>
<pre>
⊢ ∀a b c d.
    a ≠ b ⇒
    (collinear {a; b; c; d} ⇔ collinear {a; b; c} ∧ collinear {a; b; d})
</pre>

<DT><span class="strong">COLLINEAR_BETWEEN_CASES</span>
<DD>
<pre>
⊢ ∀a b c.
    collinear {a; b; c} ⇔ between a (b,c) ∨ between b (c,a) ∨ between c (a,b)
</pre>

<DT><span class="strong">COLLINEAR_DIST_BETWEEN</span>
<DD>
<pre>
⊢ ∀a b x.
    collinear {x; a; b} ∧ dist (x,a) ≤ dist (a,b) ∧ dist (x,b) ≤ dist (a,b) ⇒
    between x (a,b)
</pre>

<DT><span class="strong">COLLINEAR_DIST_IN_CLOSED_SEGMENT</span>
<DD>
<pre>
⊢ ∀a b x.
    collinear {x; a; b} ∧ dist (x,a) ≤ dist (a,b) ∧ dist (x,b) ≤ dist (a,b) ⇒
    x ∈ segment [(a,b)]
</pre>

<DT><span class="strong">COLLINEAR_DIST_IN_OPEN_SEGMENT</span>
<DD>
<pre>
⊢ ∀a b x.
    collinear {x; a; b} ∧ dist (x,a) < dist (a,b) ∧ dist (x,b) < dist (a,b) ⇒
    x ∈ segment (a,b)
</pre>

<DT><span class="strong">COLLINEAR_EMPTY</span>
<DD>
<pre>
⊢ collinear ∅
</pre>

<DT><span class="strong">COLLINEAR_LEMMA</span>
<DD>
<pre>
⊢ ∀x y. collinear {0; x; y} ⇔ (x = 0) ∨ (y = 0) ∨ ∃c. y = c * x
</pre>

<DT><span class="strong">COLLINEAR_LEMMA_ALT</span>
<DD>
<pre>
⊢ ∀x y. collinear {0; x; y} ⇔ (x = 0) ∨ ∃c. y = c * x
</pre>

<DT><span class="strong">COLLINEAR_MIDPOINT</span>
<DD>
<pre>
⊢ ∀a b. collinear {a; midpoint (a,b); b}
</pre>

<DT><span class="strong">COLLINEAR_SING</span>
<DD>
<pre>
⊢ ∀x. collinear {x}
</pre>

<DT><span class="strong">COLLINEAR_SMALL</span>
<DD>
<pre>
⊢ ∀s. FINITE s ∧ CARD s ≤ 2 ⇒ collinear s
</pre>

<DT><span class="strong">COLLINEAR_SUBSET</span>
<DD>
<pre>
⊢ ∀s t. collinear t ∧ s ⊆ t ⇒ collinear s
</pre>

<DT><span class="strong">COLLINEAR_TRIPLES</span>
<DD>
<pre>
⊢ ∀s a b.
    a ≠ b ⇒
    (collinear (a INSERT b INSERT s) ⇔ ∀x. x ∈ s ⇒ collinear {a; b; x})
</pre>

<DT><span class="strong">COMPACT_AFFINITY</span>
<DD>
<pre>
⊢ ∀s a c. compact s ⇒ compact (IMAGE (λx. a + c * x) s)
</pre>

<DT><span class="strong">COMPACT_ATTAINS_INF</span>
<DD>
<pre>
⊢ ∀s. compact s ∧ s ≠ ∅ ⇒ ∃x. x ∈ s ∧ ∀y. y ∈ s ⇒ x ≤ y
</pre>

<DT><span class="strong">COMPACT_ATTAINS_SUP</span>
<DD>
<pre>
⊢ ∀s. compact s ∧ s ≠ ∅ ⇒ ∃x. x ∈ s ∧ ∀y. y ∈ s ⇒ y ≤ x
</pre>

<DT><span class="strong">COMPACT_BIGINTER</span>
<DD>
<pre>
⊢ ∀f. (∀s. s ∈ f ⇒ compact s) ∧ f ≠ ∅ ⇒ compact (BIGINTER f)
</pre>

<DT><span class="strong">COMPACT_BIGUNION</span>
<DD>
<pre>
⊢ ∀s. FINITE s ∧ (∀t. t ∈ s ⇒ compact t) ⇒ compact (BIGUNION s)
</pre>

<DT><span class="strong">COMPACT_CBALL</span>
<DD>
<pre>
⊢ ∀x e. compact (cball (x,e))
</pre>

<DT><span class="strong">COMPACT_CHAIN</span>
<DD>
<pre>
⊢ ∀f. (∀s. s ∈ f ⇒ compact s ∧ s ≠ ∅) ∧ (∀s t. s ∈ f ∧ t ∈ f ⇒ s ⊆ t ∨ t ⊆ s) ⇒
      BIGINTER f ≠ ∅
</pre>

<DT><span class="strong">COMPACT_CLOSED_DIFFERENCES</span>
<DD>
<pre>
⊢ ∀s t. compact s ∧ closed t ⇒ closed {x − y | x ∈ s ∧ y ∈ t}
</pre>

<DT><span class="strong">COMPACT_CLOSED_SUMS</span>
<DD>
<pre>
⊢ ∀s t. compact s ∧ closed t ⇒ closed {x + y | x ∈ s ∧ y ∈ t}
</pre>

<DT><span class="strong">COMPACT_CLOSURE</span>
<DD>
<pre>
⊢ ∀s. compact (closure s) ⇔ bounded s
</pre>

<DT><span class="strong">COMPACT_COMPONENTS</span>
<DD>
<pre>
⊢ ∀s c. compact s ∧ c ∈ components s ⇒ compact c
</pre>

<DT><span class="strong">COMPACT_CONTINUOUS_IMAGE</span>
<DD>
<pre>
⊢ ∀f s. f continuous_on s ∧ compact s ⇒ compact (IMAGE f s)
</pre>

<DT><span class="strong">COMPACT_CONTINUOUS_IMAGE_EQ</span>
<DD>
<pre>
⊢ ∀f s.
    (∀x y. x ∈ s ∧ y ∈ s ∧ (f x = f y) ⇒ (x = y)) ⇒
    (f continuous_on s ⇔ ∀t. compact t ∧ t ⊆ s ⇒ compact (IMAGE f t))
</pre>

<DT><span class="strong">COMPACT_DIFF</span>
<DD>
<pre>
⊢ ∀s t. compact s ∧ open t ⇒ compact (s DIFF t)
</pre>

<DT><span class="strong">COMPACT_EMPTY</span>
<DD>
<pre>
⊢ compact ∅
</pre>

<DT><span class="strong">COMPACT_EQ_BOLZANO_WEIERSTRASS</span>
<DD>
<pre>
⊢ ∀s. compact s ⇔ ∀t. INFINITE t ∧ t ⊆ s ⇒ ∃x. x ∈ s ∧ x limit_point_of t
</pre>

<DT><span class="strong">COMPACT_EQ_BOUNDED_CLOSED</span>
<DD>
<pre>
⊢ ∀s. compact s ⇔ bounded s ∧ closed s
</pre>

<DT><span class="strong">COMPACT_EQ_HEINE_BOREL</span>
<DD>
<pre>
⊢ ∀s. compact s ⇔
      ∀f. (∀t. t ∈ f ⇒ open t) ∧ s ⊆ BIGUNION f ⇒
          ∃f'. f' ⊆ f ∧ FINITE f' ∧ s ⊆ BIGUNION f'
</pre>

<DT><span class="strong">COMPACT_EQ_HEINE_BOREL_SUBTOPOLOGY</span>
<DD>
<pre>
⊢ ∀s. compact s ⇔
      ∀f. (∀t. t ∈ f ⇒ open_in (subtopology euclidean s) t) ∧ s ⊆ BIGUNION f ⇒
          ∃f'. f' ⊆ f ∧ FINITE f' ∧ s ⊆ BIGUNION f'
</pre>

<DT><span class="strong">COMPACT_FIP</span>
<DD>
<pre>
⊢ ∀f. (∀t. t ∈ f ⇒ compact t) ∧ (∀f'. FINITE f' ∧ f' ⊆ f ⇒ BIGINTER f' ≠ ∅) ⇒
      BIGINTER f ≠ ∅
</pre>

<DT><span class="strong">COMPACT_FRONTIER</span>
<DD>
<pre>
⊢ ∀s. compact s ⇒ compact (frontier s)
</pre>

<DT><span class="strong">COMPACT_FRONTIER_BOUNDED</span>
<DD>
<pre>
⊢ ∀s. bounded s ⇒ compact (frontier s)
</pre>

<DT><span class="strong">COMPACT_IMP_BOUNDED</span>
<DD>
<pre>
⊢ ∀s. compact s ⇒ bounded s
</pre>

<DT><span class="strong">COMPACT_IMP_CLOSED</span>
<DD>
<pre>
⊢ ∀s. compact s ⇒ closed s
</pre>

<DT><span class="strong">COMPACT_IMP_COMPLETE</span>
<DD>
<pre>
⊢ ∀s. compact s ⇒ complete s
</pre>

<DT><span class="strong">COMPACT_IMP_FIP</span>
<DD>
<pre>
⊢ ∀s f.
    compact s ∧ (∀t. t ∈ f ⇒ closed t) ∧
    (∀f'. FINITE f' ∧ f' ⊆ f ⇒ s ∩ BIGINTER f' ≠ ∅) ⇒
    s ∩ BIGINTER f ≠ ∅
</pre>

<DT><span class="strong">COMPACT_IMP_HEINE_BOREL</span>
<DD>
<pre>
⊢ ∀s. compact s ⇒
      ∀f. (∀t. t ∈ f ⇒ open t) ∧ s ⊆ BIGUNION f ⇒
          ∃f'. f' ⊆ f ∧ FINITE f' ∧ s ⊆ BIGUNION f'
</pre>

<DT><span class="strong">COMPACT_IMP_TOTALLY_BOUNDED</span>
<DD>
<pre>
⊢ ∀s. compact s ⇒
      ∀e. 0 < e ⇒
          ∃k. FINITE k ∧ k ⊆ s ∧ s ⊆ BIGUNION (IMAGE (λx. ball (x,e)) k)
</pre>

<DT><span class="strong">COMPACT_INSERT</span>
<DD>
<pre>
⊢ ∀a s. compact s ⇒ compact (a INSERT s)
</pre>

<DT><span class="strong">COMPACT_INTER</span>
<DD>
<pre>
⊢ ∀s t. compact s ∧ compact t ⇒ compact (s ∩ t)
</pre>

<DT><span class="strong">COMPACT_INTERVAL</span>
<DD>
<pre>
⊢ ∀a b. compact (interval [(a,b)])
</pre>

<DT><span class="strong">COMPACT_INTERVAL_EQ</span>
<DD>
<pre>
⊢ (∀a b. compact (interval [(a,b)])) ∧
  ∀a b. compact (interval (a,b)) ⇔ (interval (a,b) = ∅)
</pre>

<DT><span class="strong">COMPACT_INTER_CLOSED</span>
<DD>
<pre>
⊢ ∀s t. compact s ∧ closed t ⇒ compact (s ∩ t)
</pre>

<DT><span class="strong">COMPACT_LEMMA</span>
<DD>
<pre>
⊢ ∀s. bounded s ∧ (∀n. x n ∈ s) ⇒
      ∃l r.
        (∀m n. m < n ⇒ r m < r n) ∧
        ∀e. 0 < e ⇒ ∃N. ∀n i. N ≤ n ⇒ abs (x (r n) − l) < e
</pre>

<DT><span class="strong">COMPACT_LINEAR_IMAGE</span>
<DD>
<pre>
⊢ ∀f s. compact s ∧ linear f ⇒ compact (IMAGE f s)
</pre>

<DT><span class="strong">COMPACT_NEGATIONS</span>
<DD>
<pre>
⊢ ∀s. compact s ⇒ compact (IMAGE (λx. -x) s)
</pre>

<DT><span class="strong">COMPACT_NEST</span>
<DD>
<pre>
⊢ ∀s. (∀n. compact (s n) ∧ s n ≠ ∅) ∧ (∀m n. m ≤ n ⇒ s n ⊆ s m) ⇒
      BIGINTER {s n | n ∈ 𝕌(:num)} ≠ ∅
</pre>

<DT><span class="strong">COMPACT_REAL_LEMMA</span>
<DD>
<pre>
⊢ ∀s b.
    (∀n. abs (s n) ≤ b) ⇒
    ∃l r.
      (∀m n. m < n ⇒ r m < r n) ∧
      ∀e. 0 < e ⇒ ∃N. ∀n. N ≤ n ⇒ abs (s (r n) − l) < e
</pre>

<DT><span class="strong">COMPACT_SCALING</span>
<DD>
<pre>
⊢ ∀s c. compact s ⇒ compact (IMAGE (λx. c * x) s)
</pre>

<DT><span class="strong">COMPACT_SEQUENCE_WITH_LIMIT</span>
<DD>
<pre>
⊢ ∀f l. (f --> l) sequentially ⇒ compact (l INSERT IMAGE f 𝕌(:num))
</pre>

<DT><span class="strong">COMPACT_SING</span>
<DD>
<pre>
⊢ ∀a. compact {a}
</pre>

<DT><span class="strong">COMPACT_SPHERE</span>
<DD>
<pre>
⊢ ∀a r. compact (sphere (a,r))
</pre>

<DT><span class="strong">COMPACT_TRANSLATION</span>
<DD>
<pre>
⊢ ∀s a. compact s ⇒ compact (IMAGE (λx. a + x) s)
</pre>

<DT><span class="strong">COMPACT_TRANSLATION_EQ</span>
<DD>
<pre>
⊢ ∀a s. compact (IMAGE (λx. a + x) s) ⇔ compact s
</pre>

<DT><span class="strong">COMPACT_UNIFORMLY_CONTINUOUS</span>
<DD>
<pre>
⊢ ∀f s. f continuous_on s ∧ compact s ⇒ f uniformly_continuous_on s
</pre>

<DT><span class="strong">COMPACT_UNIFORMLY_EQUICONTINUOUS</span>
<DD>
<pre>
⊢ ∀fs s.
    (∀x e.
       x ∈ s ∧ 0 < e ⇒
       ∃d. 0 < d ∧
           ∀f x'. f ∈ fs ∧ x' ∈ s ∧ dist (x',x) < d ⇒ dist (f x',f x) < e) ∧
    compact s ⇒
    ∀e. 0 < e ⇒
        ∃d. 0 < d ∧
            ∀f x x'.
              f ∈ fs ∧ x ∈ s ∧ x' ∈ s ∧ dist (x',x) < d ⇒ dist (f x',f x) < e
</pre>

<DT><span class="strong">COMPACT_UNION</span>
<DD>
<pre>
⊢ ∀s t. compact s ∧ compact t ⇒ compact (s ∪ t)
</pre>

<DT><span class="strong">COMPLEMENT_CONNECTED_COMPONENT_BIGUNION</span>
<DD>
<pre>
⊢ ∀s x.
    s DIFF connected_component s x =
    BIGUNION
      ({connected_component s y | y | y ∈ s} DELETE connected_component s x)
</pre>

<DT><span class="strong">COMPLETE_EQ_CLOSED</span>
<DD>
<pre>
⊢ ∀s. complete s ⇔ closed s
</pre>

<DT><span class="strong">COMPLETE_INJECTIVE_LINEAR_IMAGE</span>
<DD>
<pre>
⊢ ∀f. linear f ∧ (∀x y. (f x = f y) ⇒ (x = y)) ⇒
      ∀s. complete s ⇒ complete (IMAGE f s)
</pre>

<DT><span class="strong">COMPLETE_INJECTIVE_LINEAR_IMAGE_EQ</span>
<DD>
<pre>
⊢ ∀f s.
    linear f ∧ (∀x y. (f x = f y) ⇒ (x = y)) ⇒
    (complete (IMAGE f s) ⇔ complete s)
</pre>

<DT><span class="strong">COMPLETE_ISOMETRIC_IMAGE</span>
<DD>
<pre>
⊢ ∀f s e.
    0 < e ∧ subspace s ∧ linear f ∧ (∀x. x ∈ s ⇒ abs (f x) ≥ e * abs x) ∧
    complete s ⇒
    complete (IMAGE f s)
</pre>

<DT><span class="strong">COMPLETE_UNIV</span>
<DD>
<pre>
⊢ complete 𝕌(:real)
</pre>

<DT><span class="strong">COMPONENTS_EMPTY</span>
<DD>
<pre>
⊢ components ∅ = ∅
</pre>

<DT><span class="strong">COMPONENTS_EQ</span>
<DD>
<pre>
⊢ ∀s c c'. c ∈ components s ∧ c' ∈ components s ⇒ ((c = c') ⇔ c ∩ c' ≠ ∅)
</pre>

<DT><span class="strong">COMPONENTS_EQ_EMPTY</span>
<DD>
<pre>
⊢ ∀s. (components s = ∅) ⇔ (s = ∅)
</pre>

<DT><span class="strong">COMPONENTS_EQ_SING</span>
<DD>
<pre>
⊢ ∀s. (components s = {s}) ⇔ connected s ∧ s ≠ ∅
</pre>

<DT><span class="strong">COMPONENTS_EQ_SING_EXISTS</span>
<DD>
<pre>
⊢ ∀s. (∃a. components s = {a}) ⇔ connected s ∧ s ≠ ∅
</pre>

<DT><span class="strong">COMPONENTS_EQ_SING_N_EXISTS</span>
<DD>
<pre>
⊢ (∀s. (components s = {s}) ⇔ connected s ∧ s ≠ ∅) ∧
  ∀s. (∃a. components s = {a}) ⇔ connected s ∧ s ≠ ∅
</pre>

<DT><span class="strong">COMPONENTS_INTERMEDIATE_SUBSET</span>
<DD>
<pre>
⊢ ∀s t u. s ∈ components u ∧ s ⊆ t ∧ t ⊆ u ⇒ s ∈ components t
</pre>

<DT><span class="strong">COMPONENTS_MAXIMAL</span>
<DD>
<pre>
⊢ ∀s t c. c ∈ components s ∧ connected t ∧ t ⊆ s ∧ c ∩ t ≠ ∅ ⇒ t ⊆ c
</pre>

<DT><span class="strong">COMPONENTS_NONOVERLAP</span>
<DD>
<pre>
⊢ ∀s c c'. c ∈ components s ∧ c' ∈ components s ⇒ ((c ∩ c' = ∅) ⇔ c ≠ c')
</pre>

<DT><span class="strong">COMPONENTS_UNIQUE</span>
<DD>
<pre>
⊢ ∀s k.
    (BIGUNION k = s) ∧
    (∀c. c ∈ k ⇒
         connected c ∧ c ≠ ∅ ∧ ∀c'. connected c' ∧ c ⊆ c' ∧ c' ⊆ s ⇒ (c' = c)) ⇒
    (components s = k)
</pre>

<DT><span class="strong">COMPONENTS_UNIQUE_EQ</span>
<DD>
<pre>
⊢ ∀s k.
    (components s = k) ⇔
    (BIGUNION k = s) ∧
    ∀c. c ∈ k ⇒
        connected c ∧ c ≠ ∅ ∧ ∀c'. connected c' ∧ c ⊆ c' ∧ c' ⊆ s ⇒ (c' = c)
</pre>

<DT><span class="strong">COMPONENTS_UNIV</span>
<DD>
<pre>
⊢ components 𝕌(:real) = {𝕌(:real)}
</pre>

<DT><span class="strong">CONDENSATION_POINT_IMP_LIMPT</span>
<DD>
<pre>
⊢ ∀x s. x condensation_point_of s ⇒ x limit_point_of s
</pre>

<DT><span class="strong">CONDENSATION_POINT_INFINITE_BALL</span>
<DD>
<pre>
⊢ ∀s x. x condensation_point_of s ⇔ ∀e. 0 < e ⇒ uncountable (s ∩ ball (x,e))
</pre>

<DT><span class="strong">CONDENSATION_POINT_INFINITE_BALL_CBALL</span>
<DD>
<pre>
⊢ (∀s x. x condensation_point_of s ⇔ ∀e. 0 < e ⇒ uncountable (s ∩ ball (x,e))) ∧
  ∀s x. x condensation_point_of s ⇔ ∀e. 0 < e ⇒ uncountable (s ∩ cball (x,e))
</pre>

<DT><span class="strong">CONDENSATION_POINT_INFINITE_CBALL</span>
<DD>
<pre>
⊢ ∀s x. x condensation_point_of s ⇔ ∀e. 0 < e ⇒ uncountable (s ∩ cball (x,e))
</pre>

<DT><span class="strong">CONDENSATION_POINT_OF_SUBSET</span>
<DD>
<pre>
⊢ ∀x s t. x condensation_point_of s ∧ s ⊆ t ⇒ x condensation_point_of t
</pre>

<DT><span class="strong">CONNECTED_BIGUNION</span>
<DD>
<pre>
⊢ ∀P. (∀s. s ∈ P ⇒ connected s) ∧ BIGINTER P ≠ ∅ ⇒ connected (BIGUNION P)
</pre>

<DT><span class="strong">CONNECTED_CHAIN</span>
<DD>
<pre>
⊢ ∀f. (∀s. s ∈ f ⇒ compact s ∧ connected s) ∧
      (∀s t. s ∈ f ∧ t ∈ f ⇒ s ⊆ t ∨ t ⊆ s) ⇒
      connected (BIGINTER f)
</pre>

<DT><span class="strong">CONNECTED_CHAIN_GEN</span>
<DD>
<pre>
⊢ ∀f. (∀s. s ∈ f ⇒ closed s ∧ connected s) ∧ (∃s. s ∈ f ∧ compact s) ∧
      (∀s t. s ∈ f ∧ t ∈ f ⇒ s ⊆ t ∨ t ⊆ s) ⇒
      connected (BIGINTER f)
</pre>

<DT><span class="strong">CONNECTED_CLOPEN</span>
<DD>
<pre>
⊢ ∀s. connected s ⇔
      ∀t. open_in (subtopology euclidean s) t ∧
          closed_in (subtopology euclidean s) t ⇒
          (t = ∅) ∨ (t = s)
</pre>

<DT><span class="strong">CONNECTED_CLOSED</span>
<DD>
<pre>
⊢ ∀s. connected s ⇔
      ¬∃e1 e2.
        closed e1 ∧ closed e2 ∧ s ⊆ e1 ∪ e2 ∧ (e1 ∩ e2 ∩ s = ∅) ∧ e1 ∩ s ≠ ∅ ∧
        e2 ∩ s ≠ ∅
</pre>

<DT><span class="strong">CONNECTED_CLOSED_IN</span>
<DD>
<pre>
⊢ ∀s. connected s ⇔
      ¬∃e1 e2.
        closed_in (subtopology euclidean s) e1 ∧
        closed_in (subtopology euclidean s) e2 ∧ s ⊆ e1 ∪ e2 ∧ (e1 ∩ e2 = ∅) ∧
        e1 ≠ ∅ ∧ e2 ≠ ∅
</pre>

<DT><span class="strong">CONNECTED_CLOSED_IN_EQ</span>
<DD>
<pre>
⊢ ∀s. connected s ⇔
      ¬∃e1 e2.
        closed_in (subtopology euclidean s) e1 ∧
        closed_in (subtopology euclidean s) e2 ∧ (e1 ∪ e2 = s) ∧
        (e1 ∩ e2 = ∅) ∧ e1 ≠ ∅ ∧ e2 ≠ ∅
</pre>

<DT><span class="strong">CONNECTED_CLOSED_MONOTONE_PREIMAGE</span>
<DD>
<pre>
⊢ ∀f s t.
    f continuous_on s ∧ (IMAGE f s = t) ∧
    (∀c. closed_in (subtopology euclidean s) c ⇒
         closed_in (subtopology euclidean t) (IMAGE f c)) ∧
    (∀y. y ∈ t ⇒ connected {x | x ∈ s ∧ (f x = y)}) ⇒
    ∀c. connected c ∧ c ⊆ t ⇒ connected {x | x ∈ s ∧ f x ∈ c}
</pre>

<DT><span class="strong">CONNECTED_CLOSED_SET</span>
<DD>
<pre>
⊢ ∀s. closed s ⇒
      (connected s ⇔
       ¬∃e1 e2.
         closed e1 ∧ closed e2 ∧ e1 ≠ ∅ ∧ e2 ≠ ∅ ∧ (e1 ∪ e2 = s) ∧
         (e1 ∩ e2 = ∅))
</pre>

<DT><span class="strong">CONNECTED_CLOSURE</span>
<DD>
<pre>
⊢ ∀s. connected s ⇒ connected (closure s)
</pre>

<DT><span class="strong">CONNECTED_COMPONENT_BIGUNION</span>
<DD>
<pre>
⊢ ∀s x. connected_component s x = BIGUNION {t | connected t ∧ x ∈ t ∧ t ⊆ s}
</pre>

<DT><span class="strong">CONNECTED_COMPONENT_DISJOINT</span>
<DD>
<pre>
⊢ ∀s a b.
    DISJOINT (connected_component s a) (connected_component s b) ⇔
    a ∉ connected_component s b
</pre>

<DT><span class="strong">CONNECTED_COMPONENT_EMPTY</span>
<DD>
<pre>
⊢ ∀x. connected_component ∅ x = ∅
</pre>

<DT><span class="strong">CONNECTED_COMPONENT_EQ</span>
<DD>
<pre>
⊢ ∀s x y.
    y ∈ connected_component s x ⇒
    (connected_component s y = connected_component s x)
</pre>

<DT><span class="strong">CONNECTED_COMPONENT_EQUIVALENCE_RELATION</span>
<DD>
<pre>
⊢ ∀R s.
    (∀x y. R x y ⇒ R y x) ∧ (∀x y z. R x y ∧ R y z ⇒ R x z) ∧
    (∀a. a ∈ s ⇒
         ∃t. open_in (subtopology euclidean s) t ∧ a ∈ t ∧ ∀x. x ∈ t ⇒ R a x) ⇒
    ∀a b. connected_component s a b ⇒ R a b
</pre>

<DT><span class="strong">CONNECTED_COMPONENT_EQ_EMPTY</span>
<DD>
<pre>
⊢ ∀s x. (connected_component s x = ∅) ⇔ x ∉ s
</pre>

<DT><span class="strong">CONNECTED_COMPONENT_EQ_EQ</span>
<DD>
<pre>
⊢ ∀s x y.
    (connected_component s x = connected_component s y) ⇔
    x ∉ s ∧ y ∉ s ∨ x ∈ s ∧ y ∈ s ∧ connected_component s x y
</pre>

<DT><span class="strong">CONNECTED_COMPONENT_EQ_SELF</span>
<DD>
<pre>
⊢ ∀s x. connected s ∧ x ∈ s ⇒ (connected_component s x = s)
</pre>

<DT><span class="strong">CONNECTED_COMPONENT_EQ_UNIV</span>
<DD>
<pre>
⊢ ∀s x. (connected_component s x = 𝕌(:real)) ⇔ (s = 𝕌(:real))
</pre>

<DT><span class="strong">CONNECTED_COMPONENT_IDEMP</span>
<DD>
<pre>
⊢ ∀s x.
    connected_component (connected_component s x) x = connected_component s x
</pre>

<DT><span class="strong">CONNECTED_COMPONENT_IN</span>
<DD>
<pre>
⊢ ∀s x y. connected_component s x y ⇒ x ∈ s ∧ y ∈ s
</pre>

<DT><span class="strong">CONNECTED_COMPONENT_INTERMEDIATE_SUBSET</span>
<DD>
<pre>
⊢ ∀t u a.
    connected_component u a ⊆ t ∧ t ⊆ u ⇒
    (connected_component t a = connected_component u a)
</pre>

<DT><span class="strong">CONNECTED_COMPONENT_MAXIMAL</span>
<DD>
<pre>
⊢ ∀s t x. x ∈ t ∧ connected t ∧ t ⊆ s ⇒ t ⊆ connected_component s x
</pre>

<DT><span class="strong">CONNECTED_COMPONENT_MONO</span>
<DD>
<pre>
⊢ ∀s t x. s ⊆ t ⇒ connected_component s x ⊆ connected_component t x
</pre>

<DT><span class="strong">CONNECTED_COMPONENT_NONOVERLAP</span>
<DD>
<pre>
⊢ ∀s a b.
    (connected_component s a ∩ connected_component s b = ∅) ⇔
    a ∉ s ∨ b ∉ s ∨ connected_component s a ≠ connected_component s b
</pre>

<DT><span class="strong">CONNECTED_COMPONENT_OF_SUBSET</span>
<DD>
<pre>
⊢ ∀s t x. s ⊆ t ∧ connected_component s x y ⇒ connected_component t x y
</pre>

<DT><span class="strong">CONNECTED_COMPONENT_OVERLAP</span>
<DD>
<pre>
⊢ ∀s a b.
    connected_component s a ∩ connected_component s b ≠ ∅ ⇔
    a ∈ s ∧ b ∈ s ∧ (connected_component s a = connected_component s b)
</pre>

<DT><span class="strong">CONNECTED_COMPONENT_REFL</span>
<DD>
<pre>
⊢ ∀s x. x ∈ s ⇒ connected_component s x x
</pre>

<DT><span class="strong">CONNECTED_COMPONENT_REFL_EQ</span>
<DD>
<pre>
⊢ ∀s x. connected_component s x x ⇔ x ∈ s
</pre>

<DT><span class="strong">CONNECTED_COMPONENT_SET</span>
<DD>
<pre>
⊢ ∀s x.
    connected_component s x = {y | ∃t. connected t ∧ t ⊆ s ∧ x ∈ t ∧ y ∈ t}
</pre>

<DT><span class="strong">CONNECTED_COMPONENT_SUBSET</span>
<DD>
<pre>
⊢ ∀s x. connected_component s x ⊆ s
</pre>

<DT><span class="strong">CONNECTED_COMPONENT_SYM</span>
<DD>
<pre>
⊢ ∀s x y. connected_component s x y ⇒ connected_component s y x
</pre>

<DT><span class="strong">CONNECTED_COMPONENT_SYM_EQ</span>
<DD>
<pre>
⊢ ∀s x y. connected_component s x y ⇔ connected_component s y x
</pre>

<DT><span class="strong">CONNECTED_COMPONENT_TRANS</span>
<DD>
<pre>
⊢ ∀s x y.
    connected_component s x y ∧ connected_component s y z ⇒
    connected_component s x z
</pre>

<DT><span class="strong">CONNECTED_COMPONENT_UNIQUE</span>
<DD>
<pre>
⊢ ∀s c x.
    x ∈ c ∧ c ⊆ s ∧ connected c ∧
    (∀c'. x ∈ c' ∧ c' ⊆ s ∧ connected c' ⇒ c' ⊆ c) ⇒
    (connected_component s x = c)
</pre>

<DT><span class="strong">CONNECTED_COMPONENT_UNIV</span>
<DD>
<pre>
⊢ ∀x. connected_component 𝕌(:real) x = 𝕌(:real)
</pre>

<DT><span class="strong">CONNECTED_CONNECTED_COMPONENT</span>
<DD>
<pre>
⊢ ∀s x. connected (connected_component s x)
</pre>

<DT><span class="strong">CONNECTED_CONNECTED_COMPONENT_SET</span>
<DD>
<pre>
⊢ ∀s. connected s ⇔ ∀x. x ∈ s ⇒ (connected_component s x = s)
</pre>

<DT><span class="strong">CONNECTED_CONTINUOUS_IMAGE</span>
<DD>
<pre>
⊢ ∀f s. f continuous_on s ∧ connected s ⇒ connected (IMAGE f s)
</pre>

<DT><span class="strong">CONNECTED_DIFF_OPEN_FROM_CLOSED</span>
<DD>
<pre>
⊢ ∀s t u.
    s ⊆ t ∧ t ⊆ u ∧ open s ∧ closed t ∧ connected u ∧ connected (t DIFF s) ⇒
    connected (u DIFF s)
</pre>

<DT><span class="strong">CONNECTED_DISJOINT_BIGUNION_OPEN_UNIQUE</span>
<DD>
<pre>
⊢ ∀f f'.
    pairwise DISJOINT f ∧ pairwise DISJOINT f' ∧
    (∀s. s ∈ f ⇒ open s ∧ connected s ∧ s ≠ ∅) ∧
    (∀s. s ∈ f' ⇒ open s ∧ connected s ∧ s ≠ ∅) ∧ (BIGUNION f = BIGUNION f') ⇒
    (f = f')
</pre>

<DT><span class="strong">CONNECTED_EMPTY</span>
<DD>
<pre>
⊢ connected ∅
</pre>

<DT><span class="strong">CONNECTED_EQUIVALENCE_RELATION</span>
<DD>
<pre>
⊢ ∀R s.
    connected s ∧ (∀x y. R x y ⇒ R y x) ∧ (∀x y z. R x y ∧ R y z ⇒ R x z) ∧
    (∀a. a ∈ s ⇒
         ∃t. open_in (subtopology euclidean s) t ∧ a ∈ t ∧ ∀x. x ∈ t ⇒ R a x) ⇒
    ∀a b. a ∈ s ∧ b ∈ s ⇒ R a b
</pre>

<DT><span class="strong">CONNECTED_EQUIVALENCE_RELATION_GEN</span>
<DD>
<pre>
⊢ ∀P R s.
    connected s ∧ (∀x y. R x y ⇒ R y x) ∧ (∀x y z. R x y ∧ R y z ⇒ R x z) ∧
    (∀t a. open_in (subtopology euclidean s) t ∧ a ∈ t ⇒ ∃z. z ∈ t ∧ P z) ∧
    (∀a. a ∈ s ⇒
         ∃t. open_in (subtopology euclidean s) t ∧ a ∈ t ∧
             ∀x y. x ∈ t ∧ y ∈ t ∧ P x ∧ P y ⇒ R x y) ⇒
    ∀a b. a ∈ s ∧ b ∈ s ∧ P a ∧ P b ⇒ R a b
</pre>

<DT><span class="strong">CONNECTED_EQ_COMPONENTS_SUBSET_SING</span>
<DD>
<pre>
⊢ ∀s. connected s ⇔ components s ⊆ {s}
</pre>

<DT><span class="strong">CONNECTED_EQ_COMPONENTS_SUBSET_SING_EXISTS</span>
<DD>
<pre>
⊢ ∀s. connected s ⇔ ∃a. components s ⊆ {a}
</pre>

<DT><span class="strong">CONNECTED_EQ_CONNECTED_COMPONENTS_EQ</span>
<DD>
<pre>
⊢ ∀s. connected s ⇔ ∀c c'. c ∈ components s ∧ c' ∈ components s ⇒ (c = c')
</pre>

<DT><span class="strong">CONNECTED_EQ_CONNECTED_COMPONENT_EQ</span>
<DD>
<pre>
⊢ ∀s. connected s ⇔
      ∀x y.
        x ∈ s ∧ y ∈ s ⇒ (connected_component s x = connected_component s y)
</pre>

<DT><span class="strong">CONNECTED_FROM_CLOSED_UNION_AND_INTER</span>
<DD>
<pre>
⊢ ∀s t.
    closed s ∧ closed t ∧ connected (s ∪ t) ∧ connected (s ∩ t) ⇒
    connected s ∧ connected t
</pre>

<DT><span class="strong">CONNECTED_FROM_OPEN_UNION_AND_INTER</span>
<DD>
<pre>
⊢ ∀s t.
    open s ∧ open t ∧ connected (s ∪ t) ∧ connected (s ∩ t) ⇒
    connected s ∧ connected t
</pre>

<DT><span class="strong">CONNECTED_IFF_CONNECTABLE_POINTS</span>
<DD>
<pre>
⊢ ∀s. connected s ⇔
      ∀a b. a ∈ s ∧ b ∈ s ⇒ ∃t. connected t ∧ t ⊆ s ∧ a ∈ t ∧ b ∈ t
</pre>

<DT><span class="strong">CONNECTED_IFF_CONNECTED_COMPONENT</span>
<DD>
<pre>
⊢ ∀s. connected s ⇔ ∀x y. x ∈ s ∧ y ∈ s ⇒ connected_component s x y
</pre>

<DT><span class="strong">CONNECTED_IMP_PERFECT</span>
<DD>
<pre>
⊢ ∀s x. connected s ∧ ¬(∃a. s = {a}) ∧ x ∈ s ⇒ x limit_point_of s
</pre>

<DT><span class="strong">CONNECTED_IMP_PERFECT_CLOSED</span>
<DD>
<pre>
⊢ ∀s x. connected s ∧ closed s ∧ ¬(∃a. s = {a}) ⇒ (x limit_point_of s ⇔ x ∈ s)
</pre>

<DT><span class="strong">CONNECTED_INDUCTION</span>
<DD>
<pre>
⊢ ∀P Q s.
    connected s ∧
    (∀t a. open_in (subtopology euclidean s) t ∧ a ∈ t ⇒ ∃z. z ∈ t ∧ P z) ∧
    (∀a. a ∈ s ⇒
         ∃t. open_in (subtopology euclidean s) t ∧ a ∈ t ∧
             ∀x y. x ∈ t ∧ y ∈ t ∧ P x ∧ P y ∧ Q x ⇒ Q y) ⇒
    ∀a b. a ∈ s ∧ b ∈ s ∧ P a ∧ P b ∧ Q a ⇒ Q b
</pre>

<DT><span class="strong">CONNECTED_INDUCTION_SIMPLE</span>
<DD>
<pre>
⊢ ∀P s.
    connected s ∧
    (∀a. a ∈ s ⇒
         ∃t. open_in (subtopology euclidean s) t ∧ a ∈ t ∧
             ∀x y. x ∈ t ∧ y ∈ t ∧ P x ⇒ P y) ⇒
    ∀a b. a ∈ s ∧ b ∈ s ∧ P a ⇒ P b
</pre>

<DT><span class="strong">CONNECTED_INTERMEDIATE_CLOSURE</span>
<DD>
<pre>
⊢ ∀s t. connected s ∧ s ⊆ t ∧ t ⊆ closure s ⇒ connected t
</pre>

<DT><span class="strong">CONNECTED_INTER_FRONTIER</span>
<DD>
<pre>
⊢ ∀s t. connected s ∧ s ∩ t ≠ ∅ ∧ s DIFF t ≠ ∅ ⇒ s ∩ frontier t ≠ ∅
</pre>

<DT><span class="strong">CONNECTED_IVT_COMPONENT</span>
<DD>
<pre>
⊢ ∀s x y a. connected s ∧ x ∈ s ∧ y ∈ s ∧ x ≤ a ∧ a ≤ y ⇒ ∃z. z ∈ s ∧ (z = a)
</pre>

<DT><span class="strong">CONNECTED_IVT_HYPERPLANE</span>
<DD>
<pre>
⊢ ∀s x y a b.
    connected s ∧ x ∈ s ∧ y ∈ s ∧ a * x ≤ b ∧ b ≤ a * y ⇒
    ∃z. z ∈ s ∧ (a * z = b)
</pre>

<DT><span class="strong">CONNECTED_LINEAR_IMAGE</span>
<DD>
<pre>
⊢ ∀f s. connected s ∧ linear f ⇒ connected (IMAGE f s)
</pre>

<DT><span class="strong">CONNECTED_MONOTONE_QUOTIENT_PREIMAGE</span>
<DD>
<pre>
⊢ ∀f s t.
    f continuous_on s ∧ (IMAGE f s = t) ∧
    (∀u. u ⊆ t ⇒
         (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇔
          open_in (subtopology euclidean t) u)) ∧
    (∀y. y ∈ t ⇒ connected {x | x ∈ s ∧ (f x = y)}) ∧ connected t ⇒
    connected s
</pre>

<DT><span class="strong">CONNECTED_MONOTONE_QUOTIENT_PREIMAGE_GEN</span>
<DD>
<pre>
⊢ ∀f s t c.
    (IMAGE f s = t) ∧
    (∀u. u ⊆ t ⇒
         (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇔
          open_in (subtopology euclidean t) u)) ∧
    (∀y. y ∈ t ⇒ connected {x | x ∈ s ∧ (f x = y)}) ∧
    (open_in (subtopology euclidean t) c ∨
     closed_in (subtopology euclidean t) c) ∧ connected c ⇒
    connected {x | x ∈ s ∧ f x ∈ c}
</pre>

<DT><span class="strong">CONNECTED_NEGATIONS</span>
<DD>
<pre>
⊢ ∀s. connected s ⇒ connected (IMAGE (λx. -x) s)
</pre>

<DT><span class="strong">CONNECTED_NEST</span>
<DD>
<pre>
⊢ ∀s. (∀n. compact (s n) ∧ connected (s n)) ∧ (∀m n. m ≤ n ⇒ s n ⊆ s m) ⇒
      connected (BIGINTER {s n | n ∈ 𝕌(:num)})
</pre>

<DT><span class="strong">CONNECTED_NEST_GEN</span>
<DD>
<pre>
⊢ ∀s. (∀n. closed (s n) ∧ connected (s n)) ∧ (∃n. compact (s n)) ∧
      (∀m n. m ≤ n ⇒ s n ⊆ s m) ⇒
      connected (BIGINTER {s n | n ∈ 𝕌(:num)})
</pre>

<DT><span class="strong">CONNECTED_OPEN_IN</span>
<DD>
<pre>
⊢ ∀s. connected s ⇔
      ¬∃e1 e2.
        open_in (subtopology euclidean s) e1 ∧
        open_in (subtopology euclidean s) e2 ∧ s ⊆ e1 ∪ e2 ∧ (e1 ∩ e2 = ∅) ∧
        e1 ≠ ∅ ∧ e2 ≠ ∅
</pre>

<DT><span class="strong">CONNECTED_OPEN_IN_EQ</span>
<DD>
<pre>
⊢ ∀s. connected s ⇔
      ¬∃e1 e2.
        open_in (subtopology euclidean s) e1 ∧
        open_in (subtopology euclidean s) e2 ∧ (e1 ∪ e2 = s) ∧ (e1 ∩ e2 = ∅) ∧
        e1 ≠ ∅ ∧ e2 ≠ ∅
</pre>

<DT><span class="strong">CONNECTED_OPEN_MONOTONE_PREIMAGE</span>
<DD>
<pre>
⊢ ∀f s t.
    f continuous_on s ∧ (IMAGE f s = t) ∧
    (∀c. open_in (subtopology euclidean s) c ⇒
         open_in (subtopology euclidean t) (IMAGE f c)) ∧
    (∀y. y ∈ t ⇒ connected {x | x ∈ s ∧ (f x = y)}) ⇒
    ∀c. connected c ∧ c ⊆ t ⇒ connected {x | x ∈ s ∧ f x ∈ c}
</pre>

<DT><span class="strong">CONNECTED_OPEN_SET</span>
<DD>
<pre>
⊢ ∀s. open s ⇒
      (connected s ⇔
       ¬∃e1 e2.
         open e1 ∧ open e2 ∧ e1 ≠ ∅ ∧ e2 ≠ ∅ ∧ (e1 ∪ e2 = s) ∧ (e1 ∩ e2 = ∅))
</pre>

<DT><span class="strong">CONNECTED_REAL_LEMMA</span>
<DD>
<pre>
⊢ ∀f a b e1 e2.
    a ≤ b ∧ f a ∈ e1 ∧ f b ∈ e2 ∧
    (∀e x.
       a ≤ x ∧ x ≤ b ∧ 0 < e ⇒
       ∃d. 0 < d ∧ ∀y. abs (y − x) < d ⇒ dist (f y,f x) < e) ∧
    (∀y. y ∈ e1 ⇒ ∃e. 0 < e ∧ ∀y'. dist (y',y) < e ⇒ y' ∈ e1) ∧
    (∀y. y ∈ e2 ⇒ ∃e. 0 < e ∧ ∀y'. dist (y',y) < e ⇒ y' ∈ e2) ∧
    ¬(∃x. a ≤ x ∧ x ≤ b ∧ f x ∈ e1 ∧ f x ∈ e2) ⇒
    ∃x. a ≤ x ∧ x ≤ b ∧ f x ∉ e1 ∧ f x ∉ e2
</pre>

<DT><span class="strong">CONNECTED_SCALING</span>
<DD>
<pre>
⊢ ∀s c. connected s ⇒ connected (IMAGE (λx. c * x) s)
</pre>

<DT><span class="strong">CONNECTED_SEGMENT</span>
<DD>
<pre>
⊢ (∀a b. connected (segment [(a,b)])) ∧ ∀a b. connected (segment (a,b))
</pre>

<DT><span class="strong">CONNECTED_SING</span>
<DD>
<pre>
⊢ ∀a. connected {a}
</pre>

<DT><span class="strong">CONNECTED_SUBSET_CLOPEN</span>
<DD>
<pre>
⊢ ∀u s c.
    closed_in (subtopology euclidean u) s ∧
    open_in (subtopology euclidean u) s ∧ connected c ∧ c ⊆ u ∧ c ∩ s ≠ ∅ ⇒
    c ⊆ s
</pre>

<DT><span class="strong">CONNECTED_TRANSLATION</span>
<DD>
<pre>
⊢ ∀a s. connected s ⇒ connected (IMAGE (λx. a + x) s)
</pre>

<DT><span class="strong">CONNECTED_TRANSLATION_EQ</span>
<DD>
<pre>
⊢ ∀a s. connected (IMAGE (λx. a + x) s) ⇔ connected s
</pre>

<DT><span class="strong">CONNECTED_UNION</span>
<DD>
<pre>
⊢ ∀s t. connected s ∧ connected t ∧ s ∩ t ≠ ∅ ⇒ connected (s ∪ t)
</pre>

<DT><span class="strong">CONNECTED_UNION_STRONG</span>
<DD>
<pre>
⊢ ∀s t. connected s ∧ connected t ∧ closure s ∩ t ≠ ∅ ⇒ connected (s ∪ t)
</pre>

<DT><span class="strong">CONNECTED_UNIV</span>
<DD>
<pre>
⊢ connected 𝕌(:real)
</pre>

<DT><span class="strong">CONTENT_0_SUBSET</span>
<DD>
<pre>
⊢ ∀s a b.
    s ⊆ interval [(a,b)] ∧ (content (interval [(a,b)]) = 0) ⇒ (content s = 0)
</pre>

<DT><span class="strong">CONTENT_0_SUBSET_GEN</span>
<DD>
<pre>
⊢ ∀s t. s ⊆ t ∧ bounded t ∧ (content t = 0) ⇒ (content s = 0)
</pre>

<DT><span class="strong">CONTENT_CLOSED_INTERVAL</span>
<DD>
<pre>
⊢ ∀a b. a ≤ b ⇒ (content (interval [(a,b)]) = b − a)
</pre>

<DT><span class="strong">CONTENT_CLOSED_INTERVAL_CASES</span>
<DD>
<pre>
⊢ ∀a b. content (interval [(a,b)]) = if a ≤ b then b − a else 0
</pre>

<DT><span class="strong">CONTENT_EMPTY</span>
<DD>
<pre>
⊢ content ∅ = 0
</pre>

<DT><span class="strong">CONTENT_EQ_0</span>
<DD>
<pre>
⊢ ∀a b. (content (interval [(a,b)]) = 0) ⇔ b ≤ a
</pre>

<DT><span class="strong">CONTENT_EQ_0_1</span>
<DD>
<pre>
⊢ ∀a b. (content (interval [(a,b)]) = 0) ⇔ b ≤ a
</pre>

<DT><span class="strong">CONTENT_EQ_0_GEN</span>
<DD>
<pre>
⊢ ∀s. bounded s ⇒ ((content s = 0) ⇔ ∃a. ∀x. x ∈ s ⇒ (x = a))
</pre>

<DT><span class="strong">CONTENT_EQ_0_INTERIOR</span>
<DD>
<pre>
⊢ ∀a b. (content (interval [(a,b)]) = 0) ⇔ (interior (interval [(a,b)]) = ∅)
</pre>

<DT><span class="strong">CONTENT_LT_NZ</span>
<DD>
<pre>
⊢ ∀a b. 0 < content (interval [(a,b)]) ⇔ content (interval [(a,b)]) ≠ 0
</pre>

<DT><span class="strong">CONTENT_POS_LE</span>
<DD>
<pre>
⊢ ∀a b. 0 ≤ content (interval [(a,b)])
</pre>

<DT><span class="strong">CONTENT_POS_LT</span>
<DD>
<pre>
⊢ ∀a b. a < b ⇒ 0 < content (interval [(a,b)])
</pre>

<DT><span class="strong">CONTENT_POS_LT_EQ</span>
<DD>
<pre>
⊢ ∀a b. 0 < content (interval [(a,b)]) ⇔ a < b
</pre>

<DT><span class="strong">CONTENT_SUBSET</span>
<DD>
<pre>
⊢ ∀a b c d.
    interval [(a,b)] ⊆ interval [(c,d)] ⇒
    content (interval [(a,b)]) ≤ content (interval [(c,d)])
</pre>

<DT><span class="strong">CONTENT_UNIT</span>
<DD>
<pre>
⊢ content (interval [(0,1)]) = 1
</pre>

<DT><span class="strong">CONTINUOUS_ABS</span>
<DD>
<pre>
⊢ ∀f net. f continuous net ⇒ (λx. abs (f x)) continuous net
</pre>

<DT><span class="strong">CONTINUOUS_ABS_COMPOSE</span>
<DD>
<pre>
⊢ ∀net f. f continuous net ⇒ (λx. abs (f x)) continuous net
</pre>

<DT><span class="strong">CONTINUOUS_ADD</span>
<DD>
<pre>
⊢ ∀f g net.
    f continuous net ∧ g continuous net ⇒ (λx. f x + g x) continuous net
</pre>

<DT><span class="strong">CONTINUOUS_AGREE_ON_CLOSURE</span>
<DD>
<pre>
⊢ ∀g h.
    g continuous_on closure s ∧ h continuous_on closure s ∧
    (∀x. x ∈ s ⇒ (g x = h x)) ⇒
    ∀x. x ∈ closure s ⇒ (g x = h x)
</pre>

<DT><span class="strong">CONTINUOUS_AT</span>
<DD>
<pre>
⊢ ∀f x. f continuous at x ⇔ (f --> f x) (at x)
</pre>

<DT><span class="strong">CONTINUOUS_ATTAINS_INF</span>
<DD>
<pre>
⊢ ∀f s.
    compact s ∧ s ≠ ∅ ∧ f continuous_on s ⇒ ∃x. x ∈ s ∧ ∀y. y ∈ s ⇒ f x ≤ f y
</pre>

<DT><span class="strong">CONTINUOUS_ATTAINS_SUP</span>
<DD>
<pre>
⊢ ∀f s.
    compact s ∧ s ≠ ∅ ∧ f continuous_on s ⇒ ∃x. x ∈ s ∧ ∀y. y ∈ s ⇒ f y ≤ f x
</pre>

<DT><span class="strong">CONTINUOUS_AT_ABS</span>
<DD>
<pre>
⊢ ∀x. abs continuous at x
</pre>

<DT><span class="strong">CONTINUOUS_AT_AVOID</span>
<DD>
<pre>
⊢ ∀f x a.
    f continuous at x ∧ f x ≠ a ⇒ ∃e. 0 < e ∧ ∀y. dist (x,y) < e ⇒ f y ≠ a
</pre>

<DT><span class="strong">CONTINUOUS_AT_BALL</span>
<DD>
<pre>
⊢ ∀f x.
    f continuous at x ⇔
    ∀e. 0 < e ⇒ ∃d. 0 < d ∧ IMAGE f (ball (x,d)) ⊆ ball (f x,e)
</pre>

<DT><span class="strong">CONTINUOUS_AT_COMPOSE</span>
<DD>
<pre>
⊢ ∀f g x. f continuous at x ∧ g continuous at (f x) ⇒ g ∘ f continuous at x
</pre>

<DT><span class="strong">CONTINUOUS_AT_COMPOSE_EQ</span>
<DD>
<pre>
⊢ ∀f g h.
    g continuous at x ∧ h continuous at (g x) ∧ (∀y. g (h y) = y) ∧
    (h (g x) = x) ⇒
    (f continuous at (g x) ⇔ (λx. f (g x)) continuous at x)
</pre>

<DT><span class="strong">CONTINUOUS_AT_DIST</span>
<DD>
<pre>
⊢ ∀a x. (λx. dist (a,x)) continuous at x
</pre>

<DT><span class="strong">CONTINUOUS_AT_DIST_CLOSEST_POINT</span>
<DD>
<pre>
⊢ ∀s x. closed s ∧ s ≠ ∅ ⇒ (λx. dist (x,closest_point s x)) continuous at x
</pre>

<DT><span class="strong">CONTINUOUS_AT_ID</span>
<DD>
<pre>
⊢ ∀a. (λx. x) continuous at a
</pre>

<DT><span class="strong">CONTINUOUS_AT_IMP_CONTINUOUS_ON</span>
<DD>
<pre>
⊢ ∀f s. (∀x. x ∈ s ⇒ f continuous at x) ⇒ f continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_AT_INV</span>
<DD>
<pre>
⊢ ∀f a. f continuous at a ∧ f a ≠ 0 ⇒ realinv ∘ f continuous at a
</pre>

<DT><span class="strong">CONTINUOUS_AT_LIFT_DOT</span>
<DD>
<pre>
⊢ ∀a x. (λy. a * y) continuous at x
</pre>

<DT><span class="strong">CONTINUOUS_AT_OPEN</span>
<DD>
<pre>
⊢ ∀f x.
    f continuous at x ⇔
    ∀t. open t ∧ f x ∈ t ⇒ ∃s. open s ∧ x ∈ s ∧ ∀x'. x' ∈ s ⇒ f x' ∈ t
</pre>

<DT><span class="strong">CONTINUOUS_AT_RANGE</span>
<DD>
<pre>
⊢ ∀f x.
    f continuous at x ⇔
    ∀e. 0 < e ⇒ ∃d. 0 < d ∧ ∀x'. abs (x' − x) < d ⇒ abs (f x' − f x) < e
</pre>

<DT><span class="strong">CONTINUOUS_AT_SEQUENTIALLY</span>
<DD>
<pre>
⊢ ∀f a.
    f continuous at a ⇔
    ∀x. (x --> a) sequentially ⇒ (f ∘ x --> f a) sequentially
</pre>

<DT><span class="strong">CONTINUOUS_AT_SETDIST</span>
<DD>
<pre>
⊢ ∀s x. (λy. setdist ({y},s)) continuous at x
</pre>

<DT><span class="strong">CONTINUOUS_AT_TRANSLATION</span>
<DD>
<pre>
⊢ ∀a z f. f continuous at (a + z) ⇔ (λx. f (a + x)) continuous at z
</pre>

<DT><span class="strong">CONTINUOUS_AT_WITHIN</span>
<DD>
<pre>
⊢ ∀f x s. f continuous at x ⇒ f continuous (at x within s)
</pre>

<DT><span class="strong">CONTINUOUS_AT_WITHIN_INV</span>
<DD>
<pre>
⊢ ∀f s a.
    f continuous (at a within s) ∧ f a ≠ 0 ⇒
    realinv ∘ f continuous (at a within s)
</pre>

<DT><span class="strong">CONTINUOUS_CLOSED_IMP_CAUCHY_CONTINUOUS</span>
<DD>
<pre>
⊢ ∀f s.
    f continuous_on s ∧ closed s ⇒
    ∀x. cauchy x ∧ (∀n. x n ∈ s) ⇒ cauchy (f ∘ x)
</pre>

<DT><span class="strong">CONTINUOUS_CLOSED_IN_PREIMAGE</span>
<DD>
<pre>
⊢ ∀f s t.
    f continuous_on s ∧ closed t ⇒
    closed_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ t}
</pre>

<DT><span class="strong">CONTINUOUS_CLOSED_IN_PREIMAGE_CONSTANT</span>
<DD>
<pre>
⊢ ∀f s a.
    f continuous_on s ⇒
    closed_in (subtopology euclidean s) {x | x ∈ s ∧ (f x = a)}
</pre>

<DT><span class="strong">CONTINUOUS_CLOSED_IN_PREIMAGE_EQ</span>
<DD>
<pre>
⊢ ∀f s.
    f continuous_on s ⇔
    ∀t. closed t ⇒ closed_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ t}
</pre>

<DT><span class="strong">CONTINUOUS_CLOSED_IN_PREIMAGE_GEN</span>
<DD>
<pre>
⊢ ∀f s t u.
    f continuous_on s ∧ IMAGE f s ⊆ t ∧ closed_in (subtopology euclidean t) u ⇒
    closed_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u}
</pre>

<DT><span class="strong">CONTINUOUS_CLOSED_PREIMAGE</span>
<DD>
<pre>
⊢ ∀f s t.
    f continuous_on s ∧ closed s ∧ closed t ⇒ closed {x | x ∈ s ∧ f x ∈ t}
</pre>

<DT><span class="strong">CONTINUOUS_CLOSED_PREIMAGE_CONSTANT</span>
<DD>
<pre>
⊢ ∀f s. f continuous_on s ∧ closed s ⇒ closed {x | x ∈ s ∧ (f x = a)}
</pre>

<DT><span class="strong">CONTINUOUS_CLOSED_PREIMAGE_UNIV</span>
<DD>
<pre>
⊢ ∀f s. (∀x. f continuous at x) ∧ closed s ⇒ closed {x | f x ∈ s}
</pre>

<DT><span class="strong">CONTINUOUS_CMUL</span>
<DD>
<pre>
⊢ ∀f c net. f continuous net ⇒ (λx. c * f x) continuous net
</pre>

<DT><span class="strong">CONTINUOUS_COMPONENT_COMPOSE</span>
<DD>
<pre>
⊢ ∀net f i. f continuous net ⇒ (λx. f x) continuous net
</pre>

<DT><span class="strong">CONTINUOUS_CONST</span>
<DD>
<pre>
⊢ ∀net c. (λx. c) continuous net
</pre>

<DT><span class="strong">CONTINUOUS_CONSTANT_ON_CLOSURE</span>
<DD>
<pre>
⊢ ∀f s a.
    f continuous_on closure s ∧ (∀x. x ∈ s ⇒ (f x = a)) ⇒
    ∀x. x ∈ closure s ⇒ (f x = a)
</pre>

<DT><span class="strong">CONTINUOUS_DIAMETER</span>
<DD>
<pre>
⊢ ∀s e.
    bounded s ∧ s ≠ ∅ ∧ 0 < e ⇒
    ∃d. 0 < d ∧
        ∀t. bounded t ∧ t ≠ ∅ ∧ hausdist (s,t) < d ⇒
            abs (diameter s − diameter t) < e
</pre>

<DT><span class="strong">CONTINUOUS_DISCONNECTED_DISCRETE_FINITE_RANGE_CONSTANT_EQ</span>
<DD>
<pre>
⊢ (∀s. connected s ⇔
       ∀f t.
         f continuous_on s ∧ IMAGE f s ⊆ t ∧
         (∀y. y ∈ t ⇒ (connected_component t y = {y})) ⇒
         ∃a. ∀x. x ∈ s ⇒ (f x = a)) ∧
  (∀s. connected s ⇔
       ∀f. f continuous_on s ∧
           (∀x. x ∈ s ⇒
                ∃e. 0 < e ∧ ∀y. y ∈ s ∧ f y ≠ f x ⇒ e ≤ abs (f y − f x)) ⇒
           ∃a. ∀x. x ∈ s ⇒ (f x = a)) ∧
  ∀s. connected s ⇔
      ∀f. f continuous_on s ∧ FINITE (IMAGE f s) ⇒ ∃a. ∀x. x ∈ s ⇒ (f x = a)
</pre>

<DT><span class="strong">CONTINUOUS_DISCONNECTED_RANGE_CONSTANT</span>
<DD>
<pre>
⊢ ∀f s.
    connected s ∧ f continuous_on s ∧ IMAGE f s ⊆ t ∧
    (∀y. y ∈ t ⇒ (connected_component t y = {y})) ⇒
    ∃a. ∀x. x ∈ s ⇒ (f x = a)
</pre>

<DT><span class="strong">CONTINUOUS_DISCONNECTED_RANGE_CONSTANT_EQ</span>
<DD>
<pre>
⊢ ∀s. connected s ⇔
      ∀f t.
        f continuous_on s ∧ IMAGE f s ⊆ t ∧
        (∀y. y ∈ t ⇒ (connected_component t y = {y})) ⇒
        ∃a. ∀x. x ∈ s ⇒ (f x = a)
</pre>

<DT><span class="strong">CONTINUOUS_DISCRETE_RANGE_CONSTANT</span>
<DD>
<pre>
⊢ ∀f s.
    connected s ∧ f continuous_on s ∧
    (∀x. x ∈ s ⇒ ∃e. 0 < e ∧ ∀y. y ∈ s ∧ f y ≠ f x ⇒ e ≤ abs (f y − f x)) ⇒
    ∃a. ∀x. x ∈ s ⇒ (f x = a)
</pre>

<DT><span class="strong">CONTINUOUS_DISCRETE_RANGE_CONSTANT_EQ</span>
<DD>
<pre>
⊢ ∀s. connected s ⇔
      ∀f. f continuous_on s ∧
          (∀x. x ∈ s ⇒ ∃e. 0 < e ∧ ∀y. y ∈ s ∧ f y ≠ f x ⇒ e ≤ abs (f y − f x)) ⇒
          ∃a. ∀x. x ∈ s ⇒ (f x = a)
</pre>

<DT><span class="strong">CONTINUOUS_DOT2</span>
<DD>
<pre>
⊢ ∀net f g.
    f continuous net ∧ g continuous net ⇒ (λx. f x * g x) continuous net
</pre>

<DT><span class="strong">CONTINUOUS_FINITE_RANGE_CONSTANT</span>
<DD>
<pre>
⊢ ∀f s.
    connected s ∧ f continuous_on s ∧ FINITE (IMAGE f s) ⇒
    ∃a. ∀x. x ∈ s ⇒ (f x = a)
</pre>

<DT><span class="strong">CONTINUOUS_FINITE_RANGE_CONSTANT_EQ</span>
<DD>
<pre>
⊢ ∀s. connected s ⇔
      ∀f. f continuous_on s ∧ FINITE (IMAGE f s) ⇒ ∃a. ∀x. x ∈ s ⇒ (f x = a)
</pre>

<DT><span class="strong">CONTINUOUS_GE_ON_CLOSURE</span>
<DD>
<pre>
⊢ ∀f s a.
    f continuous_on closure s ∧ (∀x. x ∈ s ⇒ a ≤ f x) ⇒
    ∀x. x ∈ closure s ⇒ a ≤ f x
</pre>

<DT><span class="strong">CONTINUOUS_IMP_CLOSED_MAP</span>
<DD>
<pre>
⊢ ∀f s t.
    f continuous_on s ∧ (IMAGE f s = t) ∧ compact s ⇒
    ∀u. closed_in (subtopology euclidean s) u ⇒
        closed_in (subtopology euclidean t) (IMAGE f u)
</pre>

<DT><span class="strong">CONTINUOUS_IMP_QUOTIENT_MAP</span>
<DD>
<pre>
⊢ ∀f s t.
    f continuous_on s ∧ (IMAGE f s = t) ∧ compact s ⇒
    ∀u. u ⊆ t ⇒
        (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇔
         open_in (subtopology euclidean t) u)
</pre>

<DT><span class="strong">CONTINUOUS_INV</span>
<DD>
<pre>
⊢ ∀net f. f continuous net ∧ f (netlimit net) ≠ 0 ⇒ realinv ∘ f continuous net
</pre>

<DT><span class="strong">CONTINUOUS_LEFT_INVERSE_IMP_QUOTIENT_MAP</span>
<DD>
<pre>
⊢ ∀f g s.
    f continuous_on s ∧ g continuous_on IMAGE f s ∧
    (∀x. x ∈ s ⇒ (g (f x) = x)) ⇒
    ∀u. u ⊆ IMAGE f s ⇒
        (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇔
         open_in (subtopology euclidean (IMAGE f s)) u)
</pre>

<DT><span class="strong">CONTINUOUS_LEVELSET_OPEN</span>
<DD>
<pre>
⊢ ∀f s a.
    connected s ∧ f continuous_on s ∧ open {x | x ∈ s ∧ (f x = a)} ∧
    (∃x. x ∈ s ∧ (f x = a)) ⇒
    ∀x. x ∈ s ⇒ (f x = a)
</pre>

<DT><span class="strong">CONTINUOUS_LEVELSET_OPEN_IN</span>
<DD>
<pre>
⊢ ∀f s a.
    connected s ∧ f continuous_on s ∧
    open_in (subtopology euclidean s) {x | x ∈ s ∧ (f x = a)} ∧
    (∃x. x ∈ s ∧ (f x = a)) ⇒
    ∀x. x ∈ s ⇒ (f x = a)
</pre>

<DT><span class="strong">CONTINUOUS_LEVELSET_OPEN_IN_CASES</span>
<DD>
<pre>
⊢ ∀f s a.
    connected s ∧ f continuous_on s ∧
    open_in (subtopology euclidean s) {x | x ∈ s ∧ (f x = a)} ⇒
    (∀x. x ∈ s ⇒ f x ≠ a) ∨ ∀x. x ∈ s ⇒ (f x = a)
</pre>

<DT><span class="strong">CONTINUOUS_LE_ON_CLOSURE</span>
<DD>
<pre>
⊢ ∀f s a.
    f continuous_on closure s ∧ (∀x. x ∈ s ⇒ f x ≤ a) ⇒
    ∀x. x ∈ closure s ⇒ f x ≤ a
</pre>

<DT><span class="strong">CONTINUOUS_MAP_CLOSURES</span>
<DD>
<pre>
⊢ ∀f. f continuous_on 𝕌(:real) ⇔ ∀s. IMAGE f (closure s) ⊆ closure (IMAGE f s)
</pre>

<DT><span class="strong">CONTINUOUS_MAX</span>
<DD>
<pre>
⊢ ∀f g net.
    f continuous net ∧ g continuous net ⇒ (λx. max (f x) (g x)) continuous net
</pre>

<DT><span class="strong">CONTINUOUS_MIN</span>
<DD>
<pre>
⊢ ∀f g net.
    f continuous net ∧ g continuous net ⇒ (λx. min (f x) (g x)) continuous net
</pre>

<DT><span class="strong">CONTINUOUS_MUL</span>
<DD>
<pre>
⊢ ∀net f c.
    c continuous net ∧ f continuous net ⇒ (λx. c x * f x) continuous net
</pre>

<DT><span class="strong">CONTINUOUS_NEG</span>
<DD>
<pre>
⊢ ∀f net. f continuous net ⇒ (λx. -f x) continuous net
</pre>

<DT><span class="strong">CONTINUOUS_ON</span>
<DD>
<pre>
⊢ ∀f s. f continuous_on s ⇔ ∀x. x ∈ s ⇒ (f --> f x) (at x within s)
</pre>

<DT><span class="strong">CONTINUOUS_ON_ABS</span>
<DD>
<pre>
⊢ ∀f s. f continuous_on s ⇒ (λx. abs (f x)) continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_ON_ABS_COMPOSE</span>
<DD>
<pre>
⊢ ∀f s. f continuous_on s ⇒ (λx. abs (f x)) continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_ON_ADD</span>
<DD>
<pre>
⊢ ∀f g s.
    f continuous_on s ∧ g continuous_on s ⇒ (λx. f x + g x) continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_ON_AVOID</span>
<DD>
<pre>
⊢ ∀f x s a.
    f continuous_on s ∧ x ∈ s ∧ f x ≠ a ⇒
    ∃e. 0 < e ∧ ∀y. y ∈ s ∧ dist (x,y) < e ⇒ f y ≠ a
</pre>

<DT><span class="strong">CONTINUOUS_ON_CASES</span>
<DD>
<pre>
⊢ ∀P f g s t.
    closed s ∧ closed t ∧ f continuous_on s ∧ g continuous_on t ∧
    (∀x. x ∈ s ∧ ¬P x ∨ x ∈ t ∧ P x ⇒ (f x = g x)) ⇒
    (λx. if P x then f x else g x) continuous_on s ∪ t
</pre>

<DT><span class="strong">CONTINUOUS_ON_CASES_1</span>
<DD>
<pre>
⊢ ∀f g s a.
    f continuous_on {t | t ∈ s ∧ t ≤ a} ∧
    g continuous_on equiv_class $<= s a ∧ (a ∈ s ⇒ (f a = g a)) ⇒
    (λt. if t ≤ a then f t else g t) continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_ON_CASES_LE</span>
<DD>
<pre>
⊢ ∀f g h s a.
    f continuous_on {t | t ∈ s ∧ h t ≤ a} ∧
    g continuous_on {t | t ∈ s ∧ a ≤ h t} ∧ h continuous_on s ∧
    (∀t. t ∈ s ∧ (h t = a) ⇒ (f t = g t)) ⇒
    (λt. if h t ≤ a then f t else g t) continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_ON_CASES_LOCAL</span>
<DD>
<pre>
⊢ ∀P f g s t.
    closed_in (subtopology euclidean (s ∪ t)) s ∧
    closed_in (subtopology euclidean (s ∪ t)) t ∧ f continuous_on s ∧
    g continuous_on t ∧ (∀x. x ∈ s ∧ ¬P x ∨ x ∈ t ∧ P x ⇒ (f x = g x)) ⇒
    (λx. if P x then f x else g x) continuous_on s ∪ t
</pre>

<DT><span class="strong">CONTINUOUS_ON_CASES_LOCAL_OPEN</span>
<DD>
<pre>
⊢ ∀P f g s t.
    open_in (subtopology euclidean (s ∪ t)) s ∧
    open_in (subtopology euclidean (s ∪ t)) t ∧ f continuous_on s ∧
    g continuous_on t ∧ (∀x. x ∈ s ∧ ¬P x ∨ x ∈ t ∧ P x ⇒ (f x = g x)) ⇒
    (λx. if P x then f x else g x) continuous_on s ∪ t
</pre>

<DT><span class="strong">CONTINUOUS_ON_CASES_OPEN</span>
<DD>
<pre>
⊢ ∀P f g s t.
    open s ∧ open t ∧ f continuous_on s ∧ g continuous_on t ∧
    (∀x. x ∈ s ∧ ¬P x ∨ x ∈ t ∧ P x ⇒ (f x = g x)) ⇒
    (λx. if P x then f x else g x) continuous_on s ∪ t
</pre>

<DT><span class="strong">CONTINUOUS_ON_CLOSED</span>
<DD>
<pre>
⊢ ∀f s.
    f continuous_on s ⇔
    ∀t. closed_in (subtopology euclidean (IMAGE f s)) t ⇒
        closed_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ t}
</pre>

<DT><span class="strong">CONTINUOUS_ON_CLOSED_GEN</span>
<DD>
<pre>
⊢ ∀f s t.
    IMAGE f s ⊆ t ⇒
    (f continuous_on s ⇔
     ∀u. closed_in (subtopology euclidean t) u ⇒
         closed_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u})
</pre>

<DT><span class="strong">CONTINUOUS_ON_CLOSURE</span>
<DD>
<pre>
⊢ ∀f s.
    f continuous_on closure s ⇔
    ∀x e.
      x ∈ closure s ∧ 0 < e ⇒
      ∃d. 0 < d ∧ ∀y. y ∈ s ∧ dist (y,x) < d ⇒ dist (f y,f x) < e
</pre>

<DT><span class="strong">CONTINUOUS_ON_CLOSURE_ABS_LE</span>
<DD>
<pre>
⊢ ∀f s x b.
    f continuous_on closure s ∧ (∀y. y ∈ s ⇒ abs (f y) ≤ b) ∧ x ∈ closure s ⇒
    abs (f x) ≤ b
</pre>

<DT><span class="strong">CONTINUOUS_ON_CLOSURE_COMPONENT_GE</span>
<DD>
<pre>
⊢ ∀f s x b.
    f continuous_on closure s ∧ (∀y. y ∈ s ⇒ b ≤ f y) ∧ x ∈ closure s ⇒
    b ≤ f x
</pre>

<DT><span class="strong">CONTINUOUS_ON_CLOSURE_COMPONENT_LE</span>
<DD>
<pre>
⊢ ∀f s x b.
    f continuous_on closure s ∧ (∀y. y ∈ s ⇒ f y ≤ b) ∧ x ∈ closure s ⇒
    f x ≤ b
</pre>

<DT><span class="strong">CONTINUOUS_ON_CLOSURE_SEQUENTIALLY</span>
<DD>
<pre>
⊢ ∀f s.
    f continuous_on closure s ⇔
    ∀x a.
      a ∈ closure s ∧ (∀n. x n ∈ s) ∧ (x --> a) sequentially ⇒
      (f ∘ x --> f a) sequentially
</pre>

<DT><span class="strong">CONTINUOUS_ON_CMUL</span>
<DD>
<pre>
⊢ ∀f c s. f continuous_on s ⇒ (λx. c * f x) continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_ON_COMPONENTS_FINITE</span>
<DD>
<pre>
⊢ ∀f s.
    FINITE (components s) ∧ (∀c. c ∈ components s ⇒ f continuous_on c) ⇒
    f continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_ON_COMPONENTS_GEN</span>
<DD>
<pre>
⊢ ∀f s.
    (∀c. c ∈ components s ⇒
         open_in (subtopology euclidean s) c ∧ f continuous_on c) ⇒
    f continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_ON_COMPONENT_COMPOSE</span>
<DD>
<pre>
⊢ ∀f s. f continuous_on s ⇒ (λx. f x) continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_ON_COMPOSE</span>
<DD>
<pre>
⊢ ∀f g s.
    f continuous_on s ∧ g continuous_on IMAGE f s ⇒ g ∘ f continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_ON_COMPOSE_QUOTIENT</span>
<DD>
<pre>
⊢ ∀f g s t u.
    IMAGE f s ⊆ t ∧ IMAGE g t ⊆ u ∧
    (∀v. v ⊆ t ⇒
         (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ v} ⇔
          open_in (subtopology euclidean t) v)) ∧ g ∘ f continuous_on s ⇒
    g continuous_on t
</pre>

<DT><span class="strong">CONTINUOUS_ON_CONST</span>
<DD>
<pre>
⊢ ∀s c. (λx. c) continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_ON_DIST</span>
<DD>
<pre>
⊢ ∀a s. (λx. dist (a,x)) continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_ON_DIST_CLOSEST_POINT</span>
<DD>
<pre>
⊢ ∀s t. closed s ∧ s ≠ ∅ ⇒ (λx. dist (x,closest_point s x)) continuous_on t
</pre>

<DT><span class="strong">CONTINUOUS_ON_DOT2</span>
<DD>
<pre>
⊢ ∀f g s.
    f continuous_on s ∧ g continuous_on s ⇒ (λx. f x * g x) continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_ON_EMPTY</span>
<DD>
<pre>
⊢ ∀f. f continuous_on ∅
</pre>

<DT><span class="strong">CONTINUOUS_ON_EQ</span>
<DD>
<pre>
⊢ ∀f g s. (∀x. x ∈ s ⇒ (f x = g x)) ∧ f continuous_on s ⇒ g continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_ON_EQ_CONTINUOUS_AT</span>
<DD>
<pre>
⊢ ∀f s. open s ⇒ (f continuous_on s ⇔ ∀x. x ∈ s ⇒ f continuous at x)
</pre>

<DT><span class="strong">CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN</span>
<DD>
<pre>
⊢ ∀f s. f continuous_on s ⇔ ∀x. x ∈ s ⇒ f continuous (at x within s)
</pre>

<DT><span class="strong">CONTINUOUS_ON_FINITE</span>
<DD>
<pre>
⊢ ∀f s. FINITE s ⇒ f continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_ON_ID</span>
<DD>
<pre>
⊢ ∀s. (λx. x) continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_ON_IMP_CLOSED_IN</span>
<DD>
<pre>
⊢ ∀f s t.
    f continuous_on s ∧ closed_in (subtopology euclidean (IMAGE f s)) t ⇒
    closed_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ t}
</pre>

<DT><span class="strong">CONTINUOUS_ON_IMP_OPEN_IN</span>
<DD>
<pre>
⊢ ∀f s t.
    f continuous_on s ∧ open_in (subtopology euclidean (IMAGE f s)) t ⇒
    open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ t}
</pre>

<DT><span class="strong">CONTINUOUS_ON_INTERIOR</span>
<DD>
<pre>
⊢ ∀f s x. f continuous_on s ∧ x ∈ interior s ⇒ f continuous at x
</pre>

<DT><span class="strong">CONTINUOUS_ON_INV</span>
<DD>
<pre>
⊢ ∀f s.
    f continuous_on s ∧ (∀x. x ∈ s ⇒ f x ≠ 0) ⇒ realinv ∘ f continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_ON_INVERSE</span>
<DD>
<pre>
⊢ ∀f g s.
    f continuous_on s ∧ compact s ∧ (∀x. x ∈ s ⇒ (g (f x) = x)) ⇒
    g continuous_on IMAGE f s
</pre>

<DT><span class="strong">CONTINUOUS_ON_INVERSE_CLOSED_MAP</span>
<DD>
<pre>
⊢ ∀f g s t.
    f continuous_on s ∧ (IMAGE f s = t) ∧ (∀x. x ∈ s ⇒ (g (f x) = x)) ∧
    (∀u. closed_in (subtopology euclidean s) u ⇒
         closed_in (subtopology euclidean t) (IMAGE f u)) ⇒
    g continuous_on t
</pre>

<DT><span class="strong">CONTINUOUS_ON_INVERSE_OPEN_MAP</span>
<DD>
<pre>
⊢ ∀f g s t.
    f continuous_on s ∧ (IMAGE f s = t) ∧ (∀x. x ∈ s ⇒ (g (f x) = x)) ∧
    (∀u. open_in (subtopology euclidean s) u ⇒
         open_in (subtopology euclidean t) (IMAGE f u)) ⇒
    g continuous_on t
</pre>

<DT><span class="strong">CONTINUOUS_ON_IVT</span>
<DD>
<pre>
⊢ ∀f a b y.
    a ≤ b ∧ f a ≤ y ∧ y ≤ f b ∧ f continuous_on interval [(a,b)] ⇒
    ∃x. x ∈ interval [(a,b)] ∧ (f x = y)
</pre>

<DT><span class="strong">CONTINUOUS_ON_LIFT_DOT</span>
<DD>
<pre>
⊢ ∀s. (λy. a * y) continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_ON_MAX</span>
<DD>
<pre>
⊢ ∀f g s.
    f continuous_on s ∧ g continuous_on s ⇒
    (λx. max (f x) (g x)) continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_ON_MIN</span>
<DD>
<pre>
⊢ ∀f g s.
    f continuous_on s ∧ g continuous_on s ⇒
    (λx. min (f x) (g x)) continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_ON_MUL</span>
<DD>
<pre>
⊢ ∀s c f.
    c continuous_on s ∧ f continuous_on s ⇒ (λx. c x * f x) continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_ON_NEG</span>
<DD>
<pre>
⊢ ∀f s. f continuous_on s ⇒ (λx. -f x) continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_ON_NO_LIMPT</span>
<DD>
<pre>
⊢ ∀f s. ¬(∃x. x limit_point_of s) ⇒ f continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_ON_OPEN</span>
<DD>
<pre>
⊢ ∀f s.
    f continuous_on s ⇔
    ∀t. open_in (subtopology euclidean (IMAGE f s)) t ⇒
        open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ t}
</pre>

<DT><span class="strong">CONTINUOUS_ON_OPEN_AVOID</span>
<DD>
<pre>
⊢ ∀f x s a.
    f continuous_on s ∧ open s ∧ x ∈ s ∧ f x ≠ a ⇒
    ∃e. 0 < e ∧ ∀y. dist (x,y) < e ⇒ f y ≠ a
</pre>

<DT><span class="strong">CONTINUOUS_ON_OPEN_GEN</span>
<DD>
<pre>
⊢ ∀f s t.
    IMAGE f s ⊆ t ⇒
    (f continuous_on s ⇔
     ∀u. open_in (subtopology euclidean t) u ⇒
         open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u})
</pre>

<DT><span class="strong">CONTINUOUS_ON_POW</span>
<DD>
<pre>
⊢ ∀f s n. (λx. f x) continuous_on s ⇒ (λx. f x pow n) continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_ON_PRODUCT</span>
<DD>
<pre>
⊢ ∀f s t.
    FINITE t ∧ (∀i. i ∈ t ⇒ (λx. f x i) continuous_on s) ⇒
    (λx. product t (f x)) continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_ON_RANGE</span>
<DD>
<pre>
⊢ ∀f s.
    f continuous_on s ⇔
    ∀x. x ∈ s ⇒
        ∀e. 0 < e ⇒
            ∃d. 0 < d ∧ ∀x'. x' ∈ s ∧ abs (x' − x) < d ⇒ abs (f x' − f x) < e
</pre>

<DT><span class="strong">CONTINUOUS_ON_SEQUENTIALLY</span>
<DD>
<pre>
⊢ ∀f s.
    f continuous_on s ⇔
    ∀x a.
      a ∈ s ∧ (∀n. x n ∈ s) ∧ (x --> a) sequentially ⇒
      (f ∘ x --> f a) sequentially
</pre>

<DT><span class="strong">CONTINUOUS_ON_SETDIST</span>
<DD>
<pre>
⊢ ∀s t. (λy. setdist ({y},s)) continuous_on t
</pre>

<DT><span class="strong">CONTINUOUS_ON_SING</span>
<DD>
<pre>
⊢ ∀f a. f continuous_on {a}
</pre>

<DT><span class="strong">CONTINUOUS_ON_SUB</span>
<DD>
<pre>
⊢ ∀f g s.
    f continuous_on s ∧ g continuous_on s ⇒ (λx. f x − g x) continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_ON_SUBSET</span>
<DD>
<pre>
⊢ ∀f s t. f continuous_on s ∧ t ⊆ s ⇒ f continuous_on t
</pre>

<DT><span class="strong">CONTINUOUS_ON_SUM</span>
<DD>
<pre>
⊢ ∀t f s.
    FINITE s ∧ (∀a. a ∈ s ⇒ f a continuous_on t) ⇒
    (λx. sum s (λa. f a x)) continuous_on t
</pre>

<DT><span class="strong">CONTINUOUS_ON_UNION</span>
<DD>
<pre>
⊢ ∀f s t.
    closed s ∧ closed t ∧ f continuous_on s ∧ f continuous_on t ⇒
    f continuous_on s ∪ t
</pre>

<DT><span class="strong">CONTINUOUS_ON_UNION_LOCAL</span>
<DD>
<pre>
⊢ ∀f s.
    closed_in (subtopology euclidean (s ∪ t)) s ∧
    closed_in (subtopology euclidean (s ∪ t)) t ∧ f continuous_on s ∧
    f continuous_on t ⇒
    f continuous_on s ∪ t
</pre>

<DT><span class="strong">CONTINUOUS_ON_UNION_LOCAL_OPEN</span>
<DD>
<pre>
⊢ ∀f s.
    open_in (subtopology euclidean (s ∪ t)) s ∧
    open_in (subtopology euclidean (s ∪ t)) t ∧ f continuous_on s ∧
    f continuous_on t ⇒
    f continuous_on s ∪ t
</pre>

<DT><span class="strong">CONTINUOUS_ON_UNION_OPEN</span>
<DD>
<pre>
⊢ ∀f s t.
    open s ∧ open t ∧ f continuous_on s ∧ f continuous_on t ⇒
    f continuous_on s ∪ t
</pre>

<DT><span class="strong">CONTINUOUS_ON_VMUL</span>
<DD>
<pre>
⊢ ∀s c v. c continuous_on s ⇒ (λx. c x * v) continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_OPEN_IN_PREIMAGE</span>
<DD>
<pre>
⊢ ∀f s t.
    f continuous_on s ∧ open t ⇒
    open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ t}
</pre>

<DT><span class="strong">CONTINUOUS_OPEN_IN_PREIMAGE_EQ</span>
<DD>
<pre>
⊢ ∀f s.
    f continuous_on s ⇔
    ∀t. open t ⇒ open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ t}
</pre>

<DT><span class="strong">CONTINUOUS_OPEN_IN_PREIMAGE_GEN</span>
<DD>
<pre>
⊢ ∀f s t u.
    f continuous_on s ∧ IMAGE f s ⊆ t ∧ open_in (subtopology euclidean t) u ⇒
    open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u}
</pre>

<DT><span class="strong">CONTINUOUS_OPEN_PREIMAGE</span>
<DD>
<pre>
⊢ ∀f s t. f continuous_on s ∧ open s ∧ open t ⇒ open {x | x ∈ s ∧ f x ∈ t}
</pre>

<DT><span class="strong">CONTINUOUS_OPEN_PREIMAGE_UNIV</span>
<DD>
<pre>
⊢ ∀f s. (∀x. f continuous at x) ∧ open s ⇒ open {x | f x ∈ s}
</pre>

<DT><span class="strong">CONTINUOUS_POW</span>
<DD>
<pre>
⊢ ∀net f n. (λx. f x) continuous net ⇒ (λx. f x pow n) continuous net
</pre>

<DT><span class="strong">CONTINUOUS_PRODUCT</span>
<DD>
<pre>
⊢ ∀net f t.
    FINITE t ∧ (∀i. i ∈ t ⇒ (λx. f x i) continuous net) ⇒
    (λx. product t (f x)) continuous net
</pre>

<DT><span class="strong">CONTINUOUS_RIGHT_INVERSE_IMP_QUOTIENT_MAP</span>
<DD>
<pre>
⊢ ∀f g s t.
    f continuous_on s ∧ IMAGE f s ⊆ t ∧ g continuous_on t ∧ IMAGE g t ⊆ s ∧
    (∀y. y ∈ t ⇒ (f (g y) = y)) ⇒
    ∀u. u ⊆ t ⇒
        (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇔
         open_in (subtopology euclidean t) u)
</pre>

<DT><span class="strong">CONTINUOUS_SUB</span>
<DD>
<pre>
⊢ ∀f g net.
    f continuous net ∧ g continuous net ⇒ (λx. f x − g x) continuous net
</pre>

<DT><span class="strong">CONTINUOUS_SUM</span>
<DD>
<pre>
⊢ ∀net f s.
    FINITE s ∧ (∀a. a ∈ s ⇒ f a continuous net) ⇒
    (λx. sum s (λa. f a x)) continuous net
</pre>

<DT><span class="strong">CONTINUOUS_TRANSFORM_AT</span>
<DD>
<pre>
⊢ ∀f g x d.
    0 < d ∧ (∀x'. dist (x',x) < d ⇒ (f x' = g x')) ∧ f continuous at x ⇒
    g continuous at x
</pre>

<DT><span class="strong">CONTINUOUS_TRANSFORM_WITHIN</span>
<DD>
<pre>
⊢ ∀f g s x d.
    0 < d ∧ x ∈ s ∧ (∀x'. x' ∈ s ∧ dist (x',x) < d ⇒ (f x' = g x')) ∧
    f continuous (at x within s) ⇒
    g continuous (at x within s)
</pre>

<DT><span class="strong">CONTINUOUS_TRANSFORM_WITHIN_OPEN</span>
<DD>
<pre>
⊢ ∀f g s a.
    open s ∧ a ∈ s ∧ (∀x. x ∈ s ⇒ (f x = g x)) ∧ f continuous at a ⇒
    g continuous at a
</pre>

<DT><span class="strong">CONTINUOUS_TRANSFORM_WITHIN_OPEN_IN</span>
<DD>
<pre>
⊢ ∀f g s t a.
    open_in (subtopology euclidean t) s ∧ a ∈ s ∧ (∀x. x ∈ s ⇒ (f x = g x)) ∧
    f continuous (at a within t) ⇒
    g continuous (at a within t)
</pre>

<DT><span class="strong">CONTINUOUS_TRANSFORM_WITHIN_SET_IMP</span>
<DD>
<pre>
⊢ ∀f a s t.
    eventually (λx. x ∈ t ⇒ x ∈ s) (at a) ∧ f continuous (at a within s) ⇒
    f continuous (at a within t)
</pre>

<DT><span class="strong">CONTINUOUS_TRIVIAL_LIMIT</span>
<DD>
<pre>
⊢ ∀f net. trivial_limit net ⇒ f continuous net
</pre>

<DT><span class="strong">CONTINUOUS_UNIFORM_LIMIT</span>
<DD>
<pre>
⊢ ∀net f g s.
    ¬trivial_limit net ∧ eventually (λn. f n continuous_on s) net ∧
    (∀e. 0 < e ⇒ eventually (λn. ∀x. x ∈ s ⇒ abs (f n x − g x) < e) net) ⇒
    g continuous_on s
</pre>

<DT><span class="strong">CONTINUOUS_VMUL</span>
<DD>
<pre>
⊢ ∀net c v. c continuous net ⇒ (λx. c x * v) continuous net
</pre>

<DT><span class="strong">CONTINUOUS_WITHIN</span>
<DD>
<pre>
⊢ ∀f x. f continuous (at x within s) ⇔ (f --> f x) (at x within s)
</pre>

<DT><span class="strong">CONTINUOUS_WITHIN_AVOID</span>
<DD>
<pre>
⊢ ∀f x s a.
    f continuous (at x within s) ∧ x ∈ s ∧ f x ≠ a ⇒
    ∃e. 0 < e ∧ ∀y. y ∈ s ∧ dist (x,y) < e ⇒ f y ≠ a
</pre>

<DT><span class="strong">CONTINUOUS_WITHIN_BALL</span>
<DD>
<pre>
⊢ ∀f s x.
    f continuous (at x within s) ⇔
    ∀e. 0 < e ⇒ ∃d. 0 < d ∧ IMAGE f (ball (x,d) ∩ s) ⊆ ball (f x,e)
</pre>

<DT><span class="strong">CONTINUOUS_WITHIN_CLOSED_NONTRIVIAL</span>
<DD>
<pre>
⊢ ∀a s. closed s ∧ a ∉ s ⇒ f continuous (at a within s)
</pre>

<DT><span class="strong">CONTINUOUS_WITHIN_COMPARISON</span>
<DD>
<pre>
⊢ ∀f g s a.
    g continuous (at a within s) ∧
    (∀x. x ∈ s ⇒ dist (f a,f x) ≤ dist (g a,g x)) ⇒
    f continuous (at a within s)
</pre>

<DT><span class="strong">CONTINUOUS_WITHIN_COMPOSE</span>
<DD>
<pre>
⊢ ∀f g x s.
    f continuous (at x within s) ∧ g continuous (at (f x) within IMAGE f s) ⇒
    g ∘ f continuous (at x within s)
</pre>

<DT><span class="strong">CONTINUOUS_WITHIN_ID</span>
<DD>
<pre>
⊢ ∀a s. (λx. x) continuous (at a within s)
</pre>

<DT><span class="strong">CONTINUOUS_WITHIN_OPEN</span>
<DD>
<pre>
⊢ ∀f x u.
    f continuous (at x within u) ⇔
    ∀t. open t ∧ f x ∈ t ⇒
        ∃s. open s ∧ x ∈ s ∧ ∀x'. x' ∈ s ∧ x' ∈ u ⇒ f x' ∈ t
</pre>

<DT><span class="strong">CONTINUOUS_WITHIN_SEQUENTIALLY</span>
<DD>
<pre>
⊢ ∀f s a.
    f continuous (at a within s) ⇔
    ∀x. (∀n. x n ∈ s) ∧ (x --> a) sequentially ⇒ (f ∘ x --> f a) sequentially
</pre>

<DT><span class="strong">CONTINUOUS_WITHIN_SUBSET</span>
<DD>
<pre>
⊢ ∀f s t x.
    f continuous (at x within s) ∧ t ⊆ s ⇒ f continuous (at x within t)
</pre>

<DT><span class="strong">CONTRACTION_IMP_CONTINUOUS_ON</span>
<DD>
<pre>
⊢ ∀f. (∀x y. x ∈ s ∧ y ∈ s ⇒ dist (f x,f y) ≤ dist (x,y)) ⇒ f continuous_on s
</pre>

<DT><span class="strong">CONVERGENT_BOUNDED_INCREASING</span>
<DD>
<pre>
⊢ ∀s b.
    (∀m n. m ≤ n ⇒ s m ≤ s n) ∧ (∀n. abs (s n) ≤ b) ⇒
    ∃l. ∀e. 0 < e ⇒ ∃N. ∀n. N ≤ n ⇒ abs (s n − l) < e
</pre>

<DT><span class="strong">CONVERGENT_BOUNDED_MONOTONE</span>
<DD>
<pre>
⊢ ∀s b.
    (∀n. abs (s n) ≤ b) ∧
    ((∀m n. m ≤ n ⇒ s m ≤ s n) ∨ ∀m n. m ≤ n ⇒ s n ≤ s m) ⇒
    ∃l. ∀e. 0 < e ⇒ ∃N. ∀n. N ≤ n ⇒ abs (s n − l) < e
</pre>

<DT><span class="strong">CONVERGENT_EQ_CAUCHY</span>
<DD>
<pre>
⊢ ∀s. (∃l. (s --> l) sequentially) ⇔ cauchy s
</pre>

<DT><span class="strong">CONVERGENT_IMP_BOUNDED</span>
<DD>
<pre>
⊢ ∀s l. (s --> l) sequentially ⇒ bounded (IMAGE s 𝕌(:num))
</pre>

<DT><span class="strong">CONVERGENT_IMP_CAUCHY</span>
<DD>
<pre>
⊢ ∀s l. (s --> l) sequentially ⇒ cauchy s
</pre>

<DT><span class="strong">COUNTABLE_OPEN_INTERVAL</span>
<DD>
<pre>
⊢ ∀a b. countable (interval (a,b)) ⇔ (interval (a,b) = ∅)
</pre>

<DT><span class="strong">DECREASING_CLOSED_NEST</span>
<DD>
<pre>
⊢ ∀s. (∀n. closed (s n)) ∧ (∀n. s n ≠ ∅) ∧ (∀m n. m ≤ n ⇒ s n ⊆ s m) ∧
      (∀e. 0 < e ⇒ ∃n. ∀x y. x ∈ s n ∧ y ∈ s n ⇒ dist (x,y) < e) ⇒
      ∃a. ∀n. a ∈ s n
</pre>

<DT><span class="strong">DECREASING_CLOSED_NEST_SING</span>
<DD>
<pre>
⊢ ∀s. (∀n. closed (s n)) ∧ (∀n. s n ≠ ∅) ∧ (∀m n. m ≤ n ⇒ s n ⊆ s m) ∧
      (∀e. 0 < e ⇒ ∃n. ∀x y. x ∈ s n ∧ y ∈ s n ⇒ dist (x,y) < e) ⇒
      ∃a. BIGINTER {t | (∃n. t = s n)} = {a}
</pre>

<DT><span class="strong">DENSE_IMP_PERFECT</span>
<DD>
<pre>
⊢ ∀s. (closure s = 𝕌(:real)) ⇒ ∀x. x ∈ s ⇒ x limit_point_of s
</pre>

<DT><span class="strong">DENSE_LIMIT_POINTS</span>
<DD>
<pre>
⊢ ∀x. ({x | x limit_point_of s} = 𝕌(:real)) ⇔ (closure s = 𝕌(:real))
</pre>

<DT><span class="strong">DENSE_OPEN_INTER</span>
<DD>
<pre>
⊢ ∀s t u.
    open_in (subtopology euclidean u) s ∧ t ⊆ u ∨
    open_in (subtopology euclidean u) t ∧ s ⊆ u ⇒
    (u ⊆ closure (s ∩ t) ⇔ u ⊆ closure s ∧ u ⊆ closure t)
</pre>

<DT><span class="strong">DEPENDENT_CHOICE</span>
<DD>
<pre>
⊢ ∀P R.
    (∃a. P 0 a) ∧ (∀n x. P n x ⇒ ∃y. P (SUC n) y ∧ R n x y) ⇒
    ∃f. (∀n. P n (f n)) ∧ ∀n. R n (f n) (f (SUC n))
</pre>

<DT><span class="strong">DEPENDENT_CHOICE_FIXED</span>
<DD>
<pre>
⊢ ∀P R a.
    P 0 a ∧ (∀n x. P n x ⇒ ∃y. P (SUC n) y ∧ R n x y) ⇒
    ∃f. (f 0 = a) ∧ (∀n. P n (f n)) ∧ ∀n. R n (f n) (f (SUC n))
</pre>

<DT><span class="strong">DEPENDENT_EXPLICIT</span>
<DD>
<pre>
⊢ ∀p. dependent p ⇔
      ∃s u.
        FINITE s ∧ s ⊆ p ∧ (∃v. v ∈ s ∧ u v ≠ 0) ∧ (sum s (λv. u v * v) = 0)
</pre>

<DT><span class="strong">DEPENDENT_MONO</span>
<DD>
<pre>
⊢ ∀s t. dependent s ∧ s ⊆ t ⇒ dependent t
</pre>

<DT><span class="strong">DIAMETER_BALL</span>
<DD>
<pre>
⊢ ∀a r. diameter (ball (a,r)) = if r < 0 then 0 else 2 * r
</pre>

<DT><span class="strong">DIAMETER_BOUNDED</span>
<DD>
<pre>
⊢ ∀s. bounded s ⇒
      (∀x y. x ∈ s ∧ y ∈ s ⇒ abs (x − y) ≤ diameter s) ∧
      ∀d. 0 ≤ d ∧ d < diameter s ⇒ ∃x y. x ∈ s ∧ y ∈ s ∧ abs (x − y) > d
</pre>

<DT><span class="strong">DIAMETER_BOUNDED_BOUND</span>
<DD>
<pre>
⊢ ∀s x y. bounded s ∧ x ∈ s ∧ y ∈ s ⇒ abs (x − y) ≤ diameter s
</pre>

<DT><span class="strong">DIAMETER_CBALL</span>
<DD>
<pre>
⊢ ∀a r. diameter (cball (a,r)) = if r < 0 then 0 else 2 * r
</pre>

<DT><span class="strong">DIAMETER_CLOSURE</span>
<DD>
<pre>
⊢ ∀s. bounded s ⇒ (diameter (closure s) = diameter s)
</pre>

<DT><span class="strong">DIAMETER_EMPTY</span>
<DD>
<pre>
⊢ diameter ∅ = 0
</pre>

<DT><span class="strong">DIAMETER_EQ_0</span>
<DD>
<pre>
⊢ ∀s. bounded s ⇒ ((diameter s = 0) ⇔ (s = ∅) ∨ ∃a. s = {a})
</pre>

<DT><span class="strong">DIAMETER_INTERVAL</span>
<DD>
<pre>
⊢ (∀a b.
     diameter (interval [(a,b)]) =
     if interval [(a,b)] = ∅ then 0 else abs (b − a)) ∧
  ∀a b.
    diameter (interval (a,b)) = if interval (a,b) = ∅ then 0 else abs (b − a)
</pre>

<DT><span class="strong">DIAMETER_LE</span>
<DD>
<pre>
⊢ ∀s d.
    (s ≠ ∅ ∨ 0 ≤ d) ∧ (∀x y. x ∈ s ∧ y ∈ s ⇒ abs (x − y) ≤ d) ⇒ diameter s ≤ d
</pre>

<DT><span class="strong">DIAMETER_LINEAR_IMAGE</span>
<DD>
<pre>
⊢ ∀f s.
    linear f ∧ (∀x. abs (f x) = abs x) ⇒ (diameter (IMAGE f s) = diameter s)
</pre>

<DT><span class="strong">DIAMETER_POS_LE</span>
<DD>
<pre>
⊢ ∀s. bounded s ⇒ 0 ≤ diameter s
</pre>

<DT><span class="strong">DIAMETER_SING</span>
<DD>
<pre>
⊢ ∀a. diameter {a} = 0
</pre>

<DT><span class="strong">DIAMETER_SUBSET</span>
<DD>
<pre>
⊢ ∀s t. s ⊆ t ∧ bounded t ⇒ diameter s ≤ diameter t
</pre>

<DT><span class="strong">DIAMETER_SUBSET_CBALL</span>
<DD>
<pre>
⊢ ∀s. bounded s ⇒ ∃z. s ⊆ cball (z,diameter s)
</pre>

<DT><span class="strong">DIAMETER_SUBSET_CBALL_NONEMPTY</span>
<DD>
<pre>
⊢ ∀s. bounded s ∧ s ≠ ∅ ⇒ ∃z. z ∈ s ∧ s ⊆ cball (z,diameter s)
</pre>

<DT><span class="strong">DIAMETER_SUMS</span>
<DD>
<pre>
⊢ ∀s t.
    bounded s ∧ bounded t ⇒
    diameter {x + y | x ∈ s ∧ y ∈ t} ≤ diameter s + diameter t
</pre>

<DT><span class="strong">DIFF_CLOSURE_SUBSET</span>
<DD>
<pre>
⊢ ∀s t. closure s DIFF closure t ⊆ closure (s DIFF t)
</pre>

<DT><span class="strong">DIM_LE_CARD</span>
<DD>
<pre>
⊢ ∀s. FINITE s ⇒ dim s ≤ CARD s
</pre>

<DT><span class="strong">DIM_SUBSET</span>
<DD>
<pre>
⊢ ∀s t. s ⊆ t ⇒ dim s ≤ dim t
</pre>

<DT><span class="strong">DIM_SUBSET_UNIV</span>
<DD>
<pre>
⊢ ∀s. dim s ≤ 1
</pre>

<DT><span class="strong">DIM_SUBSTANDARD</span>
<DD>
<pre>
⊢ dim {x | x = 0} = 0
</pre>

<DT><span class="strong">DIM_UNIQUE</span>
<DD>
<pre>
⊢ ∀v b. b ⊆ v ∧ v ⊆ span b ∧ independent b ∧ b HAS_SIZE n ⇒ (dim v = n)
</pre>

<DT><span class="strong">DIM_UNIV</span>
<DD>
<pre>
⊢ dim 𝕌(:real) = 1
</pre>

<DT><span class="strong">DINI</span>
<DD>
<pre>
⊢ ∀f g s.
    compact s ∧ (∀n. f n continuous_on s) ∧ g continuous_on s ∧
    (∀x. x ∈ s ⇒ ((λn. f n x) --> g x) sequentially) ∧
    (∀n x. x ∈ s ⇒ f n x ≤ f (n + 1) x) ⇒
    ∀e. 0 < e ⇒
        eventually (λn. ∀x. x ∈ s ⇒ abs (f n x − g x) < e) sequentially
</pre>

<DT><span class="strong">DISCRETE_BOUNDED_IMP_FINITE</span>
<DD>
<pre>
⊢ ∀s e.
    0 < e ∧ (∀x y. x ∈ s ∧ y ∈ s ∧ abs (y − x) < e ⇒ (y = x)) ∧ bounded s ⇒
    FINITE s
</pre>

<DT><span class="strong">DISCRETE_IMP_CLOSED</span>
<DD>
<pre>
⊢ ∀s e. 0 < e ∧ (∀x y. x ∈ s ∧ y ∈ s ∧ abs (y − x) < e ⇒ (y = x)) ⇒ closed s
</pre>

<DT><span class="strong">DISJOINT_INTERVAL</span>
<DD>
<pre>
⊢ ∀a b c d.
    ((interval [(a,b)] ∩ interval [(c,d)] = ∅) ⇔ b < a ∨ d < c ∨ b < c ∨ d < a) ∧
    ((interval [(a,b)] ∩ interval (c,d) = ∅) ⇔ b < a ∨ d ≤ c ∨ b ≤ c ∨ d ≤ a) ∧
    ((interval (a,b) ∩ interval [(c,d)] = ∅) ⇔ b ≤ a ∨ d < c ∨ b ≤ c ∨ d ≤ a) ∧
    ((interval (a,b) ∩ interval (c,d) = ∅) ⇔ b ≤ a ∨ d ≤ c ∨ b ≤ c ∨ d ≤ a)
</pre>

<DT><span class="strong">DISTANCE_ATTAINS_INF</span>
<DD>
<pre>
⊢ ∀s a. closed s ∧ s ≠ ∅ ⇒ ∃x. x ∈ s ∧ ∀y. y ∈ s ⇒ dist (a,x) ≤ dist (a,y)
</pre>

<DT><span class="strong">DISTANCE_ATTAINS_SUP</span>
<DD>
<pre>
⊢ ∀s a. compact s ∧ s ≠ ∅ ⇒ ∃x. x ∈ s ∧ ∀y. y ∈ s ⇒ dist (a,y) ≤ dist (a,x)
</pre>

<DT><span class="strong">DIST_0</span>
<DD>
<pre>
⊢ ∀x. (dist (x,0) = abs x) ∧ (dist (0,x) = abs x)
</pre>

<DT><span class="strong">DIST_CLOSEST_POINT_LIPSCHITZ</span>
<DD>
<pre>
⊢ ∀s x y.
    closed s ∧ s ≠ ∅ ⇒
    abs (dist (x,closest_point s x) − dist (y,closest_point s y)) ≤ dist (x,y)
</pre>

<DT><span class="strong">DIST_EQ</span>
<DD>
<pre>
⊢ ∀w x y z. (dist (w,x) = dist (y,z)) ⇔ ((dist (w,x))² = (dist (y,z))²)
</pre>

<DT><span class="strong">DIST_EQ_0</span>
<DD>
<pre>
⊢ ∀x y. (dist (x,y) = 0) ⇔ (x = y)
</pre>

<DT><span class="strong">DIST_IN_CLOSED_SEGMENT</span>
<DD>
<pre>
⊢ ∀a b x.
    x ∈ segment [(a,b)] ⇒ dist (x,a) ≤ dist (a,b) ∧ dist (x,b) ≤ dist (a,b)
</pre>

<DT><span class="strong">DIST_IN_OPEN_CLOSED_SEGMENT</span>
<DD>
<pre>
⊢ (∀a b x.
     x ∈ segment [(a,b)] ⇒ dist (x,a) ≤ dist (a,b) ∧ dist (x,b) ≤ dist (a,b)) ∧
  ∀a b x.
    x ∈ segment (a,b) ⇒ dist (x,a) < dist (a,b) ∧ dist (x,b) < dist (a,b)
</pre>

<DT><span class="strong">DIST_IN_OPEN_SEGMENT</span>
<DD>
<pre>
⊢ ∀a b x.
    x ∈ segment (a,b) ⇒ dist (x,a) < dist (a,b) ∧ dist (x,b) < dist (a,b)
</pre>

<DT><span class="strong">DIST_LE_0</span>
<DD>
<pre>
⊢ ∀x y. dist (x,y) ≤ 0 ⇔ (x = y)
</pre>

<DT><span class="strong">DIST_MIDPOINT</span>
<DD>
<pre>
⊢ ∀a b.
    (dist (a,midpoint (a,b)) = dist (a,b) / 2) ∧
    (dist (b,midpoint (a,b)) = dist (a,b) / 2) ∧
    (dist (midpoint (a,b),a) = dist (a,b) / 2) ∧
    (dist (midpoint (a,b),b) = dist (a,b) / 2)
</pre>

<DT><span class="strong">DIST_MUL</span>
<DD>
<pre>
⊢ ∀x y c. dist (c * x,c * y) = abs c * dist (x,y)
</pre>

<DT><span class="strong">DIST_NZ</span>
<DD>
<pre>
⊢ ∀x y. x ≠ y ⇔ 0 < dist (x,y)
</pre>

<DT><span class="strong">DIST_POS_LE</span>
<DD>
<pre>
⊢ ∀x y. 0 ≤ dist (x,y)
</pre>

<DT><span class="strong">DIST_POS_LT</span>
<DD>
<pre>
⊢ ∀x y. x ≠ y ⇒ 0 < dist (x,y)
</pre>

<DT><span class="strong">DIST_REFL</span>
<DD>
<pre>
⊢ ∀x. dist (x,x) = 0
</pre>

<DT><span class="strong">DIST_SYM</span>
<DD>
<pre>
⊢ ∀x y. dist (x,y) = dist (y,x)
</pre>

<DT><span class="strong">DIST_TRIANGLE</span>
<DD>
<pre>
⊢ ∀x y z. dist (x,z) ≤ dist (x,y) + dist (y,z)
</pre>

<DT><span class="strong">DIST_TRIANGLE_ADD</span>
<DD>
<pre>
⊢ ∀x x' y y'. dist (x + y,x' + y') ≤ dist (x,x') + dist (y,y')
</pre>

<DT><span class="strong">DIST_TRIANGLE_ADD_HALF</span>
<DD>
<pre>
⊢ ∀x x' y y'.
    dist (x,x') < e / 2 ∧ dist (y,y') < e / 2 ⇒ dist (x + y,x' + y') < e
</pre>

<DT><span class="strong">DIST_TRIANGLE_ALT</span>
<DD>
<pre>
⊢ ∀x y z. dist (y,z) ≤ dist (x,y) + dist (x,z)
</pre>

<DT><span class="strong">DIST_TRIANGLE_EQ</span>
<DD>
<pre>
⊢ ∀x y z.
    (dist (x,z) = dist (x,y) + dist (y,z)) ⇔
    (abs (x − y) * (y − z) = abs (y − z) * (x − y))
</pre>

<DT><span class="strong">DIST_TRIANGLE_HALF_L</span>
<DD>
<pre>
⊢ ∀x1 x2 y. dist (x1,y) < e / 2 ∧ dist (x2,y) < e / 2 ⇒ dist (x1,x2) < e
</pre>

<DT><span class="strong">DIST_TRIANGLE_HALF_R</span>
<DD>
<pre>
⊢ ∀x1 x2 y. dist (y,x1) < e / 2 ∧ dist (y,x2) < e / 2 ⇒ dist (x1,x2) < e
</pre>

<DT><span class="strong">DIST_TRIANGLE_LE</span>
<DD>
<pre>
⊢ ∀x y z e. dist (x,z) + dist (y,z) ≤ e ⇒ dist (x,y) ≤ e
</pre>

<DT><span class="strong">DIST_TRIANGLE_LT</span>
<DD>
<pre>
⊢ ∀x y z e. dist (x,z) + dist (y,z) < e ⇒ dist (x,y) < e
</pre>

<DT><span class="strong">DORDER_NET</span>
<DD>
<pre>
⊢ ∀n. dorder (netord n)
</pre>

<DT><span class="strong">EMPTY_AS_INTERVAL</span>
<DD>
<pre>
⊢ ∅ = interval [(1,0)]
</pre>

<DT><span class="strong">EMPTY_INTERIOR_FINITE</span>
<DD>
<pre>
⊢ ∀s. FINITE s ⇒ (interior s = ∅)
</pre>

<DT><span class="strong">ENDS_IN_INTERVAL</span>
<DD>
<pre>
⊢ (∀a b. a ∈ interval [(a,b)] ⇔ interval [(a,b)] ≠ ∅) ∧
  (∀a b. b ∈ interval [(a,b)] ⇔ interval [(a,b)] ≠ ∅) ∧
  (∀a b. a ∉ interval (a,b)) ∧ ∀a b. b ∉ interval (a,b)
</pre>

<DT><span class="strong">ENDS_IN_SEGMENT</span>
<DD>
<pre>
⊢ ∀a b. a ∈ segment [(a,b)] ∧ b ∈ segment [(a,b)]
</pre>

<DT><span class="strong">ENDS_IN_UNIT_INTERVAL</span>
<DD>
<pre>
⊢ 0 ∈ interval [(0,1)] ∧ 1 ∈ interval [(0,1)] ∧ 0 ∉ interval (0,1) ∧
  1 ∉ interval (0,1)
</pre>

<DT><span class="strong">ENDS_NOT_IN_SEGMENT</span>
<DD>
<pre>
⊢ ∀a b. a ∉ segment (a,b) ∧ b ∉ segment (a,b)
</pre>

<DT><span class="strong">EQ_BALLS</span>
<DD>
<pre>
⊢ (∀a a' r r'.
     (ball (a,r) = ball (a',r')) ⇔ (a = a') ∧ (r = r') ∨ r ≤ 0 ∧ r' ≤ 0) ∧
  (∀a a' r r'. (ball (a,r) = cball (a',r')) ⇔ r ≤ 0 ∧ r' < 0) ∧
  (∀a a' r r'. (cball (a,r) = ball (a',r')) ⇔ r < 0 ∧ r' ≤ 0) ∧
  ∀a a' r r'.
    (cball (a,r) = cball (a',r')) ⇔ (a = a') ∧ (r = r') ∨ r < 0 ∧ r' < 0
</pre>

<DT><span class="strong">EQ_INTERVAL</span>
<DD>
<pre>
⊢ (∀a b c d.
     (interval [(a,b)] = interval [(c,d)]) ⇔
     (interval [(a,b)] = ∅) ∧ (interval [(c,d)] = ∅) ∨ (a = c) ∧ (b = d)) ∧
  (∀a b c d.
     (interval [(a,b)] = interval (c,d)) ⇔
     (interval [(a,b)] = ∅) ∧ (interval (c,d) = ∅)) ∧
  (∀a b c d.
     (interval (a,b) = interval [(c,d)]) ⇔
     (interval (a,b) = ∅) ∧ (interval [(c,d)] = ∅)) ∧
  ∀a b c d.
    (interval (a,b) = interval (c,d)) ⇔
    (interval (a,b) = ∅) ∧ (interval (c,d) = ∅) ∨ (a = c) ∧ (b = d)
</pre>

<DT><span class="strong">EVENTUALLY_AND</span>
<DD>
<pre>
⊢ ∀net p q.
    eventually (λx. p x ∧ q x) net ⇔ eventually p net ∧ eventually q net
</pre>

<DT><span class="strong">EVENTUALLY_AT</span>
<DD>
<pre>
⊢ ∀a p.
    eventually p (at a) ⇔
    ∃d. 0 < d ∧ ∀x. 0 < dist (x,a) ∧ dist (x,a) < d ⇒ p x
</pre>

<DT><span class="strong">EVENTUALLY_AT_INFINITY</span>
<DD>
<pre>
⊢ ∀p. eventually p at_infinity ⇔ ∃b. ∀x. abs x ≥ b ⇒ p x
</pre>

<DT><span class="strong">EVENTUALLY_AT_INFINITY_POS</span>
<DD>
<pre>
⊢ ∀p. eventually p at_infinity ⇔ ∃b. 0 < b ∧ ∀x. abs x ≥ b ⇒ p x
</pre>

<DT><span class="strong">EVENTUALLY_AT_NEGINFINITY</span>
<DD>
<pre>
⊢ ∀p. eventually p at_neginfinity ⇔ ∃b. ∀x. x ≤ b ⇒ p x
</pre>

<DT><span class="strong">EVENTUALLY_AT_POSINFINITY</span>
<DD>
<pre>
⊢ ∀p. eventually p at_posinfinity ⇔ ∃b. ∀x. x ≥ b ⇒ p x
</pre>

<DT><span class="strong">EVENTUALLY_FALSE</span>
<DD>
<pre>
⊢ ∀net. eventually (λx. F) net ⇔ trivial_limit net
</pre>

<DT><span class="strong">EVENTUALLY_FORALL</span>
<DD>
<pre>
⊢ ∀net p s.
    FINITE s ∧ s ≠ ∅ ⇒
    (eventually (λx. ∀a. a ∈ s ⇒ p a x) net ⇔ ∀a. a ∈ s ⇒ eventually (p a) net)
</pre>

<DT><span class="strong">EVENTUALLY_HAPPENS</span>
<DD>
<pre>
⊢ ∀net p. eventually p net ⇒ trivial_limit net ∨ ∃x. p x
</pre>

<DT><span class="strong">EVENTUALLY_MONO</span>
<DD>
<pre>
⊢ ∀net p q. (∀x. p x ⇒ q x) ∧ eventually p net ⇒ eventually q net
</pre>

<DT><span class="strong">EVENTUALLY_MP</span>
<DD>
<pre>
⊢ ∀net p q.
    eventually (λx. p x ⇒ q x) net ∧ eventually p net ⇒ eventually q net
</pre>

<DT><span class="strong">EVENTUALLY_SEQUENTIALLY</span>
<DD>
<pre>
⊢ ∀p. eventually p sequentially ⇔ ∃N. ∀n. N ≤ n ⇒ p n
</pre>

<DT><span class="strong">EVENTUALLY_TRUE</span>
<DD>
<pre>
⊢ ∀net. eventually (λx. T) net ⇔ T
</pre>

<DT><span class="strong">EVENTUALLY_WITHIN</span>
<DD>
<pre>
⊢ ∀s a p.
    eventually p (at a within s) ⇔
    ∃d. 0 < d ∧ ∀x. x ∈ s ∧ 0 < dist (x,a) ∧ dist (x,a) < d ⇒ p x
</pre>

<DT><span class="strong">EVENTUALLY_WITHIN_INTERIOR</span>
<DD>
<pre>
⊢ ∀p s x.
    x ∈ interior s ⇒ (eventually p (at x within s) ⇔ eventually p (at x))
</pre>

<DT><span class="strong">EVENTUALLY_WITHIN_LE</span>
<DD>
<pre>
⊢ ∀s a p.
    eventually p (at a within s) ⇔
    ∃d. 0 < d ∧ ∀x. x ∈ s ∧ 0 < dist (x,a) ∧ dist (x,a) ≤ d ⇒ p x
</pre>

<DT><span class="strong">EXCHANGE_LEMMA</span>
<DD>
<pre>
⊢ ∀s t.
    FINITE t ∧ independent s ∧ s ⊆ span t ⇒
    ∃t'. t' HAS_SIZE CARD t ∧ s ⊆ t' ∧ t' ⊆ s ∪ t ∧ s ⊆ span t'
</pre>

<DT><span class="strong">EXISTS_COMPONENT_SUPERSET</span>
<DD>
<pre>
⊢ ∀s t. t ⊆ s ∧ s ≠ ∅ ∧ connected t ⇒ ∃c. c ∈ components s ∧ t ⊆ c
</pre>

<DT><span class="strong">EXISTS_DIFF</span>
<DD>
<pre>
⊢ (∃s. P (𝕌(:α) DIFF s)) ⇔ ∃s. P s
</pre>

<DT><span class="strong">EXISTS_IN_INSERT</span>
<DD>
<pre>
⊢ ∀P a s. (∃x. x ∈ a INSERT s ∧ P x) ⇔ P a ∨ ∃x. x ∈ s ∧ P x
</pre>

<DT><span class="strong">EXTENSION_FROM_CLOPEN</span>
<DD>
<pre>
⊢ ∀f s t u.
    open_in (subtopology euclidean s) t ∧
    closed_in (subtopology euclidean s) t ∧ f continuous_on t ∧
    IMAGE f t ⊆ u ∧ ((u = ∅) ⇒ (s = ∅)) ⇒
    ∃g. g continuous_on s ∧ IMAGE g s ⊆ u ∧ ∀x. x ∈ t ⇒ (g x = f x)
</pre>

<DT><span class="strong">FINITE_BALL</span>
<DD>
<pre>
⊢ ∀a r. FINITE (ball (a,r)) ⇔ r ≤ 0
</pre>

<DT><span class="strong">FINITE_CBALL</span>
<DD>
<pre>
⊢ ∀a r. FINITE (cball (a,r)) ⇔ r ≤ 0
</pre>

<DT><span class="strong">FINITE_IMP_BOUNDED</span>
<DD>
<pre>
⊢ ∀s. FINITE s ⇒ bounded s
</pre>

<DT><span class="strong">FINITE_IMP_CLOSED</span>
<DD>
<pre>
⊢ ∀s. FINITE s ⇒ closed s
</pre>

<DT><span class="strong">FINITE_IMP_CLOSED_IN</span>
<DD>
<pre>
⊢ ∀s t. FINITE s ∧ s ⊆ t ⇒ closed_in (subtopology euclidean t) s
</pre>

<DT><span class="strong">FINITE_IMP_COMPACT</span>
<DD>
<pre>
⊢ ∀s. FINITE s ⇒ compact s
</pre>

<DT><span class="strong">FINITE_IMP_NOT_OPEN</span>
<DD>
<pre>
⊢ ∀s. FINITE s ∧ s ≠ ∅ ⇒ ¬open s
</pre>

<DT><span class="strong">FINITE_INTERVAL</span>
<DD>
<pre>
⊢ (∀a b. FINITE (interval [(a,b)]) ⇔ b ≤ a) ∧
  ∀a b. FINITE (interval (a,b)) ⇔ b ≤ a
</pre>

<DT><span class="strong">FINITE_INTER_NUMSEG</span>
<DD>
<pre>
⊢ ∀s m n. FINITE (s ∩ {m .. n})
</pre>

<DT><span class="strong">FINITE_SET_AVOID</span>
<DD>
<pre>
⊢ ∀a s. FINITE s ⇒ ∃d. 0 < d ∧ ∀x. x ∈ s ∧ x ≠ a ⇒ d ≤ dist (a,x)
</pre>

<DT><span class="strong">FINITE_SPHERE</span>
<DD>
<pre>
⊢ ∀a r. FINITE (sphere (a,r))
</pre>

<DT><span class="strong">FORALL_EVENTUALLY</span>
<DD>
<pre>
⊢ ∀net p s.
    FINITE s ∧ s ≠ ∅ ⇒
    ((∀a. a ∈ s ⇒ eventually (p a) net) ⇔
     eventually (λx. ∀a. a ∈ s ⇒ p a x) net)
</pre>

<DT><span class="strong">FORALL_IN_CLOSURE</span>
<DD>
<pre>
⊢ ∀f s t.
    closed t ∧ f continuous_on closure s ∧ (∀x. x ∈ s ⇒ f x ∈ t) ⇒
    ∀x. x ∈ closure s ⇒ f x ∈ t
</pre>

<DT><span class="strong">FORALL_IN_CLOSURE_EQ</span>
<DD>
<pre>
⊢ ∀f s t.
    closed t ∧ f continuous_on closure s ⇒
    ((∀x. x ∈ closure s ⇒ f x ∈ t) ⇔ ∀x. x ∈ s ⇒ f x ∈ t)
</pre>

<DT><span class="strong">FORALL_POS_MONO_1</span>
<DD>
<pre>
⊢ ∀P. (∀d e. d < e ∧ P d ⇒ P e) ∧ (∀n. P (&n + 1)⁻¹) ⇒ ∀e. 0 < e ⇒ P e
</pre>

<DT><span class="strong">FRONTIER_BALL</span>
<DD>
<pre>
⊢ ∀a e. 0 < e ⇒ (frontier (ball (a,e)) = sphere (a,e))
</pre>

<DT><span class="strong">FRONTIER_CBALL</span>
<DD>
<pre>
⊢ ∀a e. frontier (cball (a,e)) = sphere (a,e)
</pre>

<DT><span class="strong">FRONTIER_CLOSED</span>
<DD>
<pre>
⊢ ∀s. closed (frontier s)
</pre>

<DT><span class="strong">FRONTIER_CLOSED_INTERVAL</span>
<DD>
<pre>
⊢ ∀a b. frontier (interval [(a,b)]) = interval [(a,b)] DIFF interval (a,b)
</pre>

<DT><span class="strong">FRONTIER_CLOSURES</span>
<DD>
<pre>
⊢ ∀s. frontier s = closure s ∩ closure (𝕌(:real) DIFF s)
</pre>

<DT><span class="strong">FRONTIER_CLOSURE_SUBSET</span>
<DD>
<pre>
⊢ ∀s. frontier (closure s) ⊆ frontier s
</pre>

<DT><span class="strong">FRONTIER_COMPLEMENT</span>
<DD>
<pre>
⊢ ∀s. frontier (𝕌(:real) DIFF s) = frontier s
</pre>

<DT><span class="strong">FRONTIER_DISJOINT_EQ</span>
<DD>
<pre>
⊢ ∀s. (frontier s ∩ s = ∅) ⇔ open s
</pre>

<DT><span class="strong">FRONTIER_EMPTY</span>
<DD>
<pre>
⊢ frontier ∅ = ∅
</pre>

<DT><span class="strong">FRONTIER_FRONTIER</span>
<DD>
<pre>
⊢ ∀s. open s ∨ closed s ⇒ (frontier (frontier s) = frontier s)
</pre>

<DT><span class="strong">FRONTIER_FRONTIER_FRONTIER</span>
<DD>
<pre>
⊢ ∀s. frontier (frontier (frontier s)) = frontier (frontier s)
</pre>

<DT><span class="strong">FRONTIER_FRONTIER_SUBSET</span>
<DD>
<pre>
⊢ ∀s. frontier (frontier s) ⊆ frontier s
</pre>

<DT><span class="strong">FRONTIER_HALFSPACE_GE</span>
<DD>
<pre>
⊢ ∀a b. ¬((a = 0) ∧ (b = 0)) ⇒ (frontier {x | a * x ≥ b} = {x | a * x = b})
</pre>

<DT><span class="strong">FRONTIER_HALFSPACE_GT</span>
<DD>
<pre>
⊢ ∀a b. ¬((a = 0) ∧ (b = 0)) ⇒ (frontier {x | a * x > b} = {x | a * x = b})
</pre>

<DT><span class="strong">FRONTIER_HALFSPACE_LE</span>
<DD>
<pre>
⊢ ∀a b. ¬((a = 0) ∧ (b = 0)) ⇒ (frontier {x | a * x ≤ b} = {x | a * x = b})
</pre>

<DT><span class="strong">FRONTIER_HALFSPACE_LT</span>
<DD>
<pre>
⊢ ∀a b. ¬((a = 0) ∧ (b = 0)) ⇒ (frontier {x | a * x < b} = {x | a * x = b})
</pre>

<DT><span class="strong">FRONTIER_INTERIORS</span>
<DD>
<pre>
⊢ ∀s. frontier s = 𝕌(:real) DIFF interior s DIFF interior (𝕌(:real) DIFF s)
</pre>

<DT><span class="strong">FRONTIER_INTERIOR_SUBSET</span>
<DD>
<pre>
⊢ ∀s. frontier (interior s) ⊆ frontier s
</pre>

<DT><span class="strong">FRONTIER_INTER_SUBSET</span>
<DD>
<pre>
⊢ ∀s t. frontier (s ∩ t) ⊆ frontier s ∪ frontier t
</pre>

<DT><span class="strong">FRONTIER_INTER_SUBSET_INTER</span>
<DD>
<pre>
⊢ ∀s t. frontier (s ∩ t) ⊆ closure s ∩ frontier t ∪ frontier s ∩ closure t
</pre>

<DT><span class="strong">FRONTIER_OPEN_INTERVAL</span>
<DD>
<pre>
⊢ ∀a b.
    frontier (interval (a,b)) =
    if interval (a,b) = ∅ then ∅ else interval [(a,b)] DIFF interval (a,b)
</pre>

<DT><span class="strong">FRONTIER_SING</span>
<DD>
<pre>
⊢ ∀a. frontier {a} = {a}
</pre>

<DT><span class="strong">FRONTIER_STRADDLE</span>
<DD>
<pre>
⊢ ∀a s.
    a ∈ frontier s ⇔
    ∀e. 0 < e ⇒ (∃x. x ∈ s ∧ dist (a,x) < e) ∧ ∃x. x ∉ s ∧ dist (a,x) < e
</pre>

<DT><span class="strong">FRONTIER_SUBSET_CLOSED</span>
<DD>
<pre>
⊢ ∀s. closed s ⇒ frontier s ⊆ s
</pre>

<DT><span class="strong">FRONTIER_SUBSET_COMPACT</span>
<DD>
<pre>
⊢ ∀s. compact s ⇒ frontier s ⊆ s
</pre>

<DT><span class="strong">FRONTIER_SUBSET_EQ</span>
<DD>
<pre>
⊢ ∀s. frontier s ⊆ s ⇔ closed s
</pre>

<DT><span class="strong">FRONTIER_UNION</span>
<DD>
<pre>
⊢ ∀s t.
    (closure s ∩ closure t = ∅) ⇒ (frontier (s ∪ t) = frontier s ∪ frontier t)
</pre>

<DT><span class="strong">FRONTIER_UNION_SUBSET</span>
<DD>
<pre>
⊢ ∀s t. frontier (s ∪ t) ⊆ frontier s ∪ frontier t
</pre>

<DT><span class="strong">FRONTIER_UNIV</span>
<DD>
<pre>
⊢ frontier 𝕌(:real) = ∅
</pre>

<DT><span class="strong">FUNCTION_FACTORS_LEFT_GEN</span>
<DD>
<pre>
⊢ ∀P f g.
    (∀x y. P x ∧ P y ∧ (g x = g y) ⇒ (f x = f y)) ⇔
    ∃h. ∀x. P x ⇒ (f x = h (g x))
</pre>

<DT><span class="strong">GDELTA_COMPLEMENT</span>
<DD>
<pre>
⊢ ∀s. gdelta (𝕌(:real) DIFF s) ⇔ fsigma s
</pre>

<DT><span class="strong">GREATER_EQ_REFL</span>
<DD>
<pre>
⊢ ∀m. m ≥ m
</pre>

<DT><span class="strong">HAS_SIZE_STDBASIS</span>
<DD>
<pre>
⊢ {i | 1 ≤ i ∧ i ≤ 1} HAS_SIZE 1
</pre>

<DT><span class="strong">HAUSDIST_ALT</span>
<DD>
<pre>
⊢ ∀s t.
    bounded s ∧ bounded t ∧ s ≠ ∅ ∧ t ≠ ∅ ⇒
    (hausdist (s,t) =
     sup {abs (setdist ({x},s) − setdist ({x},t)) | x ∈ 𝕌(:real)})
</pre>

<DT><span class="strong">HAUSDIST_BALLS</span>
<DD>
<pre>
⊢ (∀a b r s.
     hausdist (ball (a,r),ball (b,s)) =
     if r ≤ 0 ∨ s ≤ 0 then 0 else dist (a,b) + abs (r − s)) ∧
  (∀a b r s.
     hausdist (ball (a,r),cball (b,s)) =
     if r ≤ 0 ∨ s < 0 then 0 else dist (a,b) + abs (r − s)) ∧
  (∀a b r s.
     hausdist (cball (a,r),ball (b,s)) =
     if r < 0 ∨ s ≤ 0 then 0 else dist (a,b) + abs (r − s)) ∧
  ∀a b r s.
    hausdist (cball (a,r),cball (b,s)) =
    if r < 0 ∨ s < 0 then 0 else dist (a,b) + abs (r − s)
</pre>

<DT><span class="strong">HAUSDIST_CLOSURE</span>
<DD>
<pre>
⊢ (∀s t. hausdist (closure s,t) = hausdist (s,t)) ∧
  ∀s t. hausdist (s,closure t) = hausdist (s,t)
</pre>

<DT><span class="strong">HAUSDIST_COMPACT_EXISTS</span>
<DD>
<pre>
⊢ ∀s t.
    bounded s ∧ compact t ∧ t ≠ ∅ ⇒
    ∀x. x ∈ s ⇒ ∃y. y ∈ t ∧ dist (x,y) ≤ hausdist (s,t)
</pre>

<DT><span class="strong">HAUSDIST_COMPACT_NONTRIVIAL</span>
<DD>
<pre>
⊢ ∀s t.
    compact s ∧ compact t ∧ s ≠ ∅ ∧ t ≠ ∅ ⇒
    (hausdist (s,t) =
     inf
       {e |
        0 ≤ e ∧ s ⊆ {x + y | x ∈ t ∧ abs y ≤ e} ∧
        t ⊆ {x + y | x ∈ s ∧ abs y ≤ e}})
</pre>

<DT><span class="strong">HAUSDIST_COMPACT_SUMS</span>
<DD>
<pre>
⊢ ∀s t.
    bounded s ∧ compact t ∧ t ≠ ∅ ⇒
    s ⊆ {y + z | y ∈ t ∧ z ∈ cball (0,hausdist (s,t))}
</pre>

<DT><span class="strong">HAUSDIST_EMPTY</span>
<DD>
<pre>
⊢ (∀t. hausdist (∅,t) = 0) ∧ ∀s. hausdist (s,∅) = 0
</pre>

<DT><span class="strong">HAUSDIST_EQ</span>
<DD>
<pre>
⊢ ∀s t s' t'.
    (∀b. (∀x. x ∈ s ⇒ setdist ({x},t) ≤ b) ∧ (∀y. y ∈ t ⇒ setdist ({y},s) ≤ b) ⇔
         (∀x. x ∈ s' ⇒ setdist ({x},t') ≤ b) ∧
         ∀y. y ∈ t' ⇒ setdist ({y},s') ≤ b) ⇒
    (hausdist (s,t) = hausdist (s',t'))
</pre>

<DT><span class="strong">HAUSDIST_EQ_0</span>
<DD>
<pre>
⊢ ∀s t.
    bounded s ∧ bounded t ⇒
    ((hausdist (s,t) = 0) ⇔ (s = ∅) ∨ (t = ∅) ∨ (closure s = closure t))
</pre>

<DT><span class="strong">HAUSDIST_INSERT_LE</span>
<DD>
<pre>
⊢ ∀s t a.
    bounded s ∧ bounded t ∧ s ≠ ∅ ∧ t ≠ ∅ ⇒
    hausdist (a INSERT s,a INSERT t) ≤ hausdist (s,t)
</pre>

<DT><span class="strong">HAUSDIST_LINEAR_IMAGE</span>
<DD>
<pre>
⊢ ∀f s t.
    linear f ∧ (∀x. abs (f x) = abs x) ⇒
    (hausdist (IMAGE f s,IMAGE f t) = hausdist (s,t))
</pre>

<DT><span class="strong">HAUSDIST_NONTRIVIAL</span>
<DD>
<pre>
⊢ ∀s t.
    bounded s ∧ bounded t ∧ s ≠ ∅ ∧ t ≠ ∅ ⇒
    (hausdist (s,t) =
     sup ({setdist ({x},t) | x ∈ s} ∪ {setdist ({y},s) | y ∈ t}))
</pre>

<DT><span class="strong">HAUSDIST_NONTRIVIAL_ALT</span>
<DD>
<pre>
⊢ ∀s t.
    bounded s ∧ bounded t ∧ s ≠ ∅ ∧ t ≠ ∅ ⇒
    (hausdist (s,t) =
     max (sup {setdist ({x},t) | x ∈ s}) (sup {setdist ({y},s) | y ∈ t}))
</pre>

<DT><span class="strong">HAUSDIST_POS_LE</span>
<DD>
<pre>
⊢ ∀s t. 0 ≤ hausdist (s,t)
</pre>

<DT><span class="strong">HAUSDIST_REFL</span>
<DD>
<pre>
⊢ ∀s. hausdist (s,s) = 0
</pre>

<DT><span class="strong">HAUSDIST_SETDIST_TRIANGLE</span>
<DD>
<pre>
⊢ ∀s t u.
    t ≠ ∅ ∧ bounded s ∧ bounded t ⇒
    setdist (s,u) ≤ hausdist (s,t) + setdist (t,u)
</pre>

<DT><span class="strong">HAUSDIST_SINGS</span>
<DD>
<pre>
⊢ ∀x y. hausdist ({x},{y}) = dist (x,y)
</pre>

<DT><span class="strong">HAUSDIST_SYM</span>
<DD>
<pre>
⊢ ∀s t. hausdist (s,t) = hausdist (t,s)
</pre>

<DT><span class="strong">HAUSDIST_TRANS</span>
<DD>
<pre>
⊢ ∀s t u.
    bounded s ∧ bounded t ∧ bounded u ∧ t ≠ ∅ ⇒
    hausdist (s,u) ≤ hausdist (s,t) + hausdist (t,u)
</pre>

<DT><span class="strong">HAUSDIST_TRANSLATION</span>
<DD>
<pre>
⊢ ∀a s t. hausdist (IMAGE (λx. a + x) s,IMAGE (λx. a + x) t) = hausdist (s,t)
</pre>

<DT><span class="strong">HAUSDIST_TRIANGLE</span>
<DD>
<pre>
⊢ ∀s t u.
    bounded s ∧ bounded t ∧ bounded u ∧ t ≠ ∅ ⇒
    hausdist (s,u) ≤ hausdist (s,t) + hausdist (t,u)
</pre>

<DT><span class="strong">HAUSDIST_UNION_LE</span>
<DD>
<pre>
⊢ ∀s t u.
    bounded s ∧ bounded t ∧ bounded u ∧ t ≠ ∅ ∧ u ≠ ∅ ⇒
    hausdist (s ∪ t,s ∪ u) ≤ hausdist (t,u)
</pre>

<DT><span class="strong">HEINE_BOREL_IMP_BOLZANO_WEIERSTRASS</span>
<DD>
<pre>
⊢ ∀s. (∀f. (∀t. t ∈ f ⇒ open t) ∧ s ⊆ BIGUNION f ⇒
           ∃f'. f' ⊆ f ∧ FINITE f' ∧ s ⊆ BIGUNION f') ⇒
      ∀t. INFINITE t ∧ t ⊆ s ⇒ ∃x. x ∈ s ∧ x limit_point_of t
</pre>

<DT><span class="strong">HEINE_BOREL_LEMMA</span>
<DD>
<pre>
⊢ ∀s. compact s ⇒
      ∀t. s ⊆ BIGUNION t ∧ (∀b. b ∈ t ⇒ open b) ⇒
          ∃e. 0 < e ∧ ∀x. x ∈ s ⇒ ∃b. b ∈ t ∧ ball (x,e) ⊆ b
</pre>

<DT><span class="strong">HOMEOMORPHIC_AFFINITY</span>
<DD>
<pre>
⊢ ∀s a c. c ≠ 0 ⇒ s homeomorphic IMAGE (λx. a + c * x) s
</pre>

<DT><span class="strong">HOMEOMORPHIC_BALLS</span>
<DD>
<pre>
⊢ ∀a b d e. 0 < d ∧ 0 < e ⇒ ball (a,d) homeomorphic ball (b,e)
</pre>

<DT><span class="strong">HOMEOMORPHIC_BALLS_CBALL_SPHERE</span>
<DD>
<pre>
⊢ (∀a b d e. 0 < d ∧ 0 < e ⇒ ball (a,d) homeomorphic ball (b,e)) ∧
  (∀a b d e. 0 < d ∧ 0 < e ⇒ cball (a,d) homeomorphic cball (b,e)) ∧
  ∀a b d e. 0 < d ∧ 0 < e ⇒ sphere (a,d) homeomorphic sphere (b,e)
</pre>

<DT><span class="strong">HOMEOMORPHIC_CBALL</span>
<DD>
<pre>
⊢ ∀a b d e. 0 < d ∧ 0 < e ⇒ cball (a,d) homeomorphic cball (b,e)
</pre>

<DT><span class="strong">HOMEOMORPHIC_COMPACT</span>
<DD>
<pre>
⊢ ∀s f t.
    compact s ∧ f continuous_on s ∧ (IMAGE f s = t) ∧
    (∀x y. x ∈ s ∧ y ∈ s ∧ (f x = f y) ⇒ (x = y)) ⇒
    s homeomorphic t
</pre>

<DT><span class="strong">HOMEOMORPHIC_COMPACTNESS</span>
<DD>
<pre>
⊢ ∀s t. s homeomorphic t ⇒ (compact s ⇔ compact t)
</pre>

<DT><span class="strong">HOMEOMORPHIC_CONNECTEDNESS</span>
<DD>
<pre>
⊢ ∀s t. s homeomorphic t ⇒ (connected s ⇔ connected t)
</pre>

<DT><span class="strong">HOMEOMORPHIC_EMPTY</span>
<DD>
<pre>
⊢ (∀s. s homeomorphic ∅ ⇔ (s = ∅)) ∧ ∀s. ∅ homeomorphic s ⇔ (s = ∅)
</pre>

<DT><span class="strong">HOMEOMORPHIC_FINITE</span>
<DD>
<pre>
⊢ ∀s t. FINITE s ∧ FINITE t ⇒ (s homeomorphic t ⇔ (CARD s = CARD t))
</pre>

<DT><span class="strong">HOMEOMORPHIC_FINITENESS</span>
<DD>
<pre>
⊢ ∀s t. s homeomorphic t ⇒ (FINITE s ⇔ FINITE t)
</pre>

<DT><span class="strong">HOMEOMORPHIC_FINITE_STRONG</span>
<DD>
<pre>
⊢ ∀s t.
    FINITE s ∨ FINITE t ⇒
    (s homeomorphic t ⇔ FINITE s ∧ FINITE t ∧ (CARD s = CARD t))
</pre>

<DT><span class="strong">HOMEOMORPHIC_HYPERPLANES</span>
<DD>
<pre>
⊢ ∀a b c d. a ≠ 0 ∧ c ≠ 0 ⇒ {x | a * x = b} homeomorphic {x | c * x = d}
</pre>

<DT><span class="strong">HOMEOMORPHIC_HYPERPLANE_STANDARD_HYPERPLANE</span>
<DD>
<pre>
⊢ ∀a b c. a ≠ 0 ⇒ {x | a * x = b} homeomorphic {x | x = c}
</pre>

<DT><span class="strong">HOMEOMORPHIC_IMP_CARD_EQ</span>
<DD>
<pre>
⊢ ∀s t. s homeomorphic t ⇒ s ≈ t
</pre>

<DT><span class="strong">HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_LEFT_EQ</span>
<DD>
<pre>
⊢ ∀f s t.
    linear f ∧ (∀x y. (f x = f y) ⇒ (x = y)) ⇒
    (IMAGE f s homeomorphic t ⇔ s homeomorphic t)
</pre>

<DT><span class="strong">HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_RIGHT_EQ</span>
<DD>
<pre>
⊢ ∀f s t.
    linear f ∧ (∀x y. (f x = f y) ⇒ (x = y)) ⇒
    (s homeomorphic IMAGE f t ⇔ s homeomorphic t)
</pre>

<DT><span class="strong">HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_SELF</span>
<DD>
<pre>
⊢ ∀f s. linear f ∧ (∀x y. (f x = f y) ⇒ (x = y)) ⇒ IMAGE f s homeomorphic s
</pre>

<DT><span class="strong">HOMEOMORPHIC_LOCALLY</span>
<DD>
<pre>
⊢ ∀P Q.
    (∀s t. s homeomorphic t ⇒ (P s ⇔ Q t)) ⇒
    ∀s t. s homeomorphic t ⇒ (locally P s ⇔ locally Q t)
</pre>

<DT><span class="strong">HOMEOMORPHIC_LOCAL_COMPACTNESS</span>
<DD>
<pre>
⊢ ∀s t. s homeomorphic t ⇒ (locally compact s ⇔ locally compact t)
</pre>

<DT><span class="strong">HOMEOMORPHIC_MINIMAL</span>
<DD>
<pre>
⊢ ∀s t.
    s homeomorphic t ⇔
    ∃f g.
      (∀x. x ∈ s ⇒ f x ∈ t ∧ (g (f x) = x)) ∧
      (∀y. y ∈ t ⇒ g y ∈ s ∧ (f (g y) = y)) ∧ f continuous_on s ∧
      g continuous_on t
</pre>

<DT><span class="strong">HOMEOMORPHIC_ONE_POINT_COMPACTIFICATIONS</span>
<DD>
<pre>
⊢ ∀s t a b.
    compact s ∧ compact t ∧ a ∈ s ∧ b ∈ t ∧ s DELETE a homeomorphic t DELETE b ⇒
    s homeomorphic t
</pre>

<DT><span class="strong">HOMEOMORPHIC_OPEN_INTERVALS</span>
<DD>
<pre>
⊢ ∀a b c d. a < b ∧ c < d ⇒ interval (a,b) homeomorphic interval (c,d)
</pre>

<DT><span class="strong">HOMEOMORPHIC_OPEN_INTERVAL_UNIV</span>
<DD>
<pre>
⊢ ∀a b. a < b ⇒ interval (a,b) homeomorphic 𝕌(:real)
</pre>

<DT><span class="strong">HOMEOMORPHIC_REFL</span>
<DD>
<pre>
⊢ ∀s. s homeomorphic s
</pre>

<DT><span class="strong">HOMEOMORPHIC_SCALING</span>
<DD>
<pre>
⊢ ∀s c. c ≠ 0 ⇒ s homeomorphic IMAGE (λx. c * x) s
</pre>

<DT><span class="strong">HOMEOMORPHIC_SCALING_LEFT</span>
<DD>
<pre>
⊢ ∀c. 0 < c ⇒ ∀s t. IMAGE (λx. c * x) s homeomorphic t ⇔ s homeomorphic t
</pre>

<DT><span class="strong">HOMEOMORPHIC_SCALING_RIGHT</span>
<DD>
<pre>
⊢ ∀c. 0 < c ⇒ ∀s t. s homeomorphic IMAGE (λx. c * x) t ⇔ s homeomorphic t
</pre>

<DT><span class="strong">HOMEOMORPHIC_SING</span>
<DD>
<pre>
⊢ ∀a b. {a} homeomorphic {b}
</pre>

<DT><span class="strong">HOMEOMORPHIC_SPHERE</span>
<DD>
<pre>
⊢ ∀a b d e. 0 < d ∧ 0 < e ⇒ sphere (a,d) homeomorphic sphere (b,e)
</pre>

<DT><span class="strong">HOMEOMORPHIC_STANDARD_HYPERPLANE_HYPERPLANE</span>
<DD>
<pre>
⊢ ∀a b c. a ≠ 0 ⇒ {x | x = c} homeomorphic {x | a * x = b}
</pre>

<DT><span class="strong">HOMEOMORPHIC_SYM</span>
<DD>
<pre>
⊢ ∀s t. s homeomorphic t ⇔ t homeomorphic s
</pre>

<DT><span class="strong">HOMEOMORPHIC_TRANS</span>
<DD>
<pre>
⊢ ∀s t u. s homeomorphic t ∧ t homeomorphic u ⇒ s homeomorphic u
</pre>

<DT><span class="strong">HOMEOMORPHIC_TRANSLATION</span>
<DD>
<pre>
⊢ ∀s a. s homeomorphic IMAGE (λx. a + x) s
</pre>

<DT><span class="strong">HOMEOMORPHIC_TRANSLATION_LEFT_EQ</span>
<DD>
<pre>
⊢ ∀a s t. IMAGE (λx. a + x) s homeomorphic t ⇔ s homeomorphic t
</pre>

<DT><span class="strong">HOMEOMORPHIC_TRANSLATION_RIGHT_EQ</span>
<DD>
<pre>
⊢ ∀a s t. s homeomorphic IMAGE (λx. a + x) t ⇔ s homeomorphic t
</pre>

<DT><span class="strong">HOMEOMORPHIC_TRANSLATION_SELF</span>
<DD>
<pre>
⊢ ∀a s. IMAGE (λx. a + x) s homeomorphic s
</pre>

<DT><span class="strong">HOMEOMORPHISM</span>
<DD>
<pre>
⊢ ∀s t f g.
    homeomorphism (s,t) (f,g) ⇔
    f continuous_on s ∧ IMAGE f s ⊆ t ∧ g continuous_on t ∧ IMAGE g t ⊆ s ∧
    (∀x. x ∈ s ⇒ (g (f x) = x)) ∧ ∀y. y ∈ t ⇒ (f (g y) = y)
</pre>

<DT><span class="strong">HOMEOMORPHISM_COMPACT</span>
<DD>
<pre>
⊢ ∀s f t.
    compact s ∧ f continuous_on s ∧ (IMAGE f s = t) ∧
    (∀x y. x ∈ s ∧ y ∈ s ∧ (f x = f y) ⇒ (x = y)) ⇒
    ∃g. homeomorphism (s,t) (f,g)
</pre>

<DT><span class="strong">HOMEOMORPHISM_COMPOSE</span>
<DD>
<pre>
⊢ ∀f g h k s t u.
    homeomorphism (s,t) (f,g) ∧ homeomorphism (t,u) (h,k) ⇒
    homeomorphism (s,u) (h ∘ f,g ∘ k)
</pre>

<DT><span class="strong">HOMEOMORPHISM_FROM_COMPOSITION_INJECTIVE</span>
<DD>
<pre>
⊢ ∀f g s t u.
    f continuous_on s ∧ IMAGE f s ⊆ t ∧ g continuous_on t ∧ IMAGE g t ⊆ u ∧
    (∀x y. x ∈ t ∧ y ∈ t ∧ (g x = g y) ⇒ (x = y)) ∧
    (∃h. homeomorphism (s,u) (g ∘ f,h)) ⇒
    (∃f'. homeomorphism (s,t) (f,f')) ∧ ∃g'. homeomorphism (t,u) (g,g')
</pre>

<DT><span class="strong">HOMEOMORPHISM_FROM_COMPOSITION_SURJECTIVE</span>
<DD>
<pre>
⊢ ∀f g s t u.
    f continuous_on s ∧ (IMAGE f s = t) ∧ g continuous_on t ∧ IMAGE g t ⊆ u ∧
    (∃h. homeomorphism (s,u) (g ∘ f,h)) ⇒
    (∃f'. homeomorphism (s,t) (f,f')) ∧ ∃g'. homeomorphism (t,u) (g,g')
</pre>

<DT><span class="strong">HOMEOMORPHISM_ID</span>
<DD>
<pre>
⊢ ∀s. homeomorphism (s,s) ((λx. x),(λx. x))
</pre>

<DT><span class="strong">HOMEOMORPHISM_IMP_CLOSED_MAP</span>
<DD>
<pre>
⊢ ∀f g s t u.
    homeomorphism (s,t) (f,g) ∧ closed_in (subtopology euclidean s) u ⇒
    closed_in (subtopology euclidean t) (IMAGE f u)
</pre>

<DT><span class="strong">HOMEOMORPHISM_IMP_OPEN_MAP</span>
<DD>
<pre>
⊢ ∀f g s t u.
    homeomorphism (s,t) (f,g) ∧ open_in (subtopology euclidean s) u ⇒
    open_in (subtopology euclidean t) (IMAGE f u)
</pre>

<DT><span class="strong">HOMEOMORPHISM_IMP_QUOTIENT_MAP</span>
<DD>
<pre>
⊢ ∀f g s t.
    homeomorphism (s,t) (f,g) ⇒
    ∀u. u ⊆ t ⇒
        (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇔
         open_in (subtopology euclidean t) u)
</pre>

<DT><span class="strong">HOMEOMORPHISM_INJECTIVE_CLOSED_MAP</span>
<DD>
<pre>
⊢ ∀f s t.
    f continuous_on s ∧ (IMAGE f s = t) ∧
    (∀x y. x ∈ s ∧ y ∈ s ∧ (f x = f y) ⇒ (x = y)) ∧
    (∀u. closed_in (subtopology euclidean s) u ⇒
         closed_in (subtopology euclidean t) (IMAGE f u)) ⇒
    ∃g. homeomorphism (s,t) (f,g)
</pre>

<DT><span class="strong">HOMEOMORPHISM_INJECTIVE_CLOSED_MAP_EQ</span>
<DD>
<pre>
⊢ ∀f s t.
    f continuous_on s ∧ (IMAGE f s = t) ∧
    (∀x y. x ∈ s ∧ y ∈ s ∧ (f x = f y) ⇒ (x = y)) ⇒
    ((∃g. homeomorphism (s,t) (f,g)) ⇔
     ∀u. closed_in (subtopology euclidean s) u ⇒
         closed_in (subtopology euclidean t) (IMAGE f u))
</pre>

<DT><span class="strong">HOMEOMORPHISM_INJECTIVE_OPEN_MAP</span>
<DD>
<pre>
⊢ ∀f s t.
    f continuous_on s ∧ (IMAGE f s = t) ∧
    (∀x y. x ∈ s ∧ y ∈ s ∧ (f x = f y) ⇒ (x = y)) ∧
    (∀u. open_in (subtopology euclidean s) u ⇒
         open_in (subtopology euclidean t) (IMAGE f u)) ⇒
    ∃g. homeomorphism (s,t) (f,g)
</pre>

<DT><span class="strong">HOMEOMORPHISM_INJECTIVE_OPEN_MAP_EQ</span>
<DD>
<pre>
⊢ ∀f s t.
    f continuous_on s ∧ (IMAGE f s = t) ∧
    (∀x y. x ∈ s ∧ y ∈ s ∧ (f x = f y) ⇒ (x = y)) ⇒
    ((∃g. homeomorphism (s,t) (f,g)) ⇔
     ∀u. open_in (subtopology euclidean s) u ⇒
         open_in (subtopology euclidean t) (IMAGE f u))
</pre>

<DT><span class="strong">HOMEOMORPHISM_LOCALLY</span>
<DD>
<pre>
⊢ ∀P Q f g.
    (∀s t. homeomorphism (s,t) (f,g) ⇒ (P s ⇔ Q t)) ⇒
    ∀s t. homeomorphism (s,t) (f,g) ⇒ (locally P s ⇔ locally Q t)
</pre>

<DT><span class="strong">HOMEOMORPHISM_OF_SUBSETS</span>
<DD>
<pre>
⊢ ∀f g s t s' t'.
    homeomorphism (s,t) (f,g) ∧ s' ⊆ s ∧ t' ⊆ t ∧ (IMAGE f s' = t') ⇒
    homeomorphism (s',t') (f,g)
</pre>

<DT><span class="strong">HOMEOMORPHISM_SYM</span>
<DD>
<pre>
⊢ ∀f g s t. homeomorphism (s,t) (f,g) ⇔ homeomorphism (t,s) (g,f)
</pre>

<DT><span class="strong">IMAGE_AFFINITY_INTERVAL</span>
<DD>
<pre>
⊢ ∀a b m c.
    IMAGE (λx. m * x + c) (interval [(a,b)]) =
    if interval [(a,b)] = ∅ then ∅
    else if 0 ≤ m then interval [(m * a + c,m * b + c)]
    else interval [(m * b + c,m * a + c)]
</pre>

<DT><span class="strong">IMAGE_CLOSURE_SUBSET</span>
<DD>
<pre>
⊢ ∀f s t.
    f continuous_on closure s ∧ closed t ∧ IMAGE f s ⊆ t ⇒
    IMAGE f (closure s) ⊆ t
</pre>

<DT><span class="strong">IMAGE_STRETCH_INTERVAL</span>
<DD>
<pre>
⊢ ∀a b m.
    IMAGE (λx. @f. f = m 1 * x) (interval [(a,b)]) =
    if interval [(a,b)] = ∅ then ∅
    else
      interval
        [((@f. f = min (m 1 * a) (m 1 * b)),@f. f = max (m 1 * a) (m 1 * b))]
</pre>

<DT><span class="strong">IMAGE_TWIZZLE_INTERVAL</span>
<DD>
<pre>
⊢ ∀p a b. IMAGE (λx. x) (interval [(a,b)]) = interval [(a,b)]
</pre>

<DT><span class="strong">INDEPENDENT_BOUND</span>
<DD>
<pre>
⊢ ∀s. independent s ⇒ FINITE s ∧ CARD s ≤ 1
</pre>

<DT><span class="strong">INDEPENDENT_CARD_LE_DIM</span>
<DD>
<pre>
⊢ ∀v b. b ⊆ v ∧ independent b ⇒ FINITE b ∧ CARD b ≤ dim v
</pre>

<DT><span class="strong">INDEPENDENT_EMPTY</span>
<DD>
<pre>
⊢ independent ∅
</pre>

<DT><span class="strong">INDEPENDENT_INJECTIVE_IMAGE</span>
<DD>
<pre>
⊢ ∀f s.
    independent s ∧ linear f ∧ (∀x y. (f x = f y) ⇒ (x = y)) ⇒
    independent (IMAGE f s)
</pre>

<DT><span class="strong">INDEPENDENT_INJECTIVE_IMAGE_GEN</span>
<DD>
<pre>
⊢ ∀f s.
    independent s ∧ linear f ∧
    (∀x y. x ∈ span s ∧ y ∈ span s ∧ (f x = f y) ⇒ (x = y)) ⇒
    independent (IMAGE f s)
</pre>

<DT><span class="strong">INDEPENDENT_INSERT</span>
<DD>
<pre>
⊢ ∀a s.
    independent (a INSERT s) ⇔
    if a ∈ s then independent s else independent s ∧ a ∉ span s
</pre>

<DT><span class="strong">INDEPENDENT_MONO</span>
<DD>
<pre>
⊢ ∀s t. independent t ∧ s ⊆ t ⇒ independent s
</pre>

<DT><span class="strong">INDEPENDENT_NONZERO</span>
<DD>
<pre>
⊢ ∀s. independent s ⇒ 0 ∉ s
</pre>

<DT><span class="strong">INDEPENDENT_SING</span>
<DD>
<pre>
⊢ ∀x. independent {x} ⇔ x ≠ 0
</pre>

<DT><span class="strong">INDEPENDENT_SPAN_BOUND</span>
<DD>
<pre>
⊢ ∀s t. FINITE t ∧ independent s ∧ s ⊆ span t ⇒ FINITE s ∧ CARD s ≤ CARD t
</pre>

<DT><span class="strong">INDEPENDENT_STDBASIS</span>
<DD>
<pre>
⊢ independent {i | 1 ≤ i ∧ i ≤ 1}
</pre>

<DT><span class="strong">INFINITE_OPEN_IN</span>
<DD>
<pre>
⊢ ∀u s.
    open_in (subtopology euclidean u) s ∧ (∃x. x ∈ s ∧ x limit_point_of u) ⇒
    INFINITE s
</pre>

<DT><span class="strong">INFINITE_SUPERSET</span>
<DD>
<pre>
⊢ ∀s t. INFINITE s ∧ s ⊆ t ⇒ INFINITE t
</pre>

<DT><span class="strong">INFSUM_0</span>
<DD>
<pre>
⊢ suminf s (λi. 0) = 0
</pre>

<DT><span class="strong">INFSUM_ADD</span>
<DD>
<pre>
⊢ ∀x y s.
    summable s x ∧ summable s y ⇒
    (suminf s (λi. x i + y i) = suminf s x + suminf s y)
</pre>

<DT><span class="strong">INFSUM_CMUL</span>
<DD>
<pre>
⊢ ∀s x c. summable s x ⇒ (suminf s (λn. c * x n) = c * suminf s x)
</pre>

<DT><span class="strong">INFSUM_EQ</span>
<DD>
<pre>
⊢ ∀f g k.
    summable k f ∧ summable k g ∧ (∀x. x ∈ k ⇒ (f x = g x)) ⇒
    (suminf k f = suminf k g)
</pre>

<DT><span class="strong">INFSUM_LINEAR</span>
<DD>
<pre>
⊢ ∀f h s. summable s f ∧ linear h ⇒ (suminf s (λn. h (f n)) = h (suminf s f))
</pre>

<DT><span class="strong">INFSUM_NEG</span>
<DD>
<pre>
⊢ ∀s x. summable s x ⇒ (suminf s (λn. -x n) = -suminf s x)
</pre>

<DT><span class="strong">INFSUM_RESTRICT</span>
<DD>
<pre>
⊢ ∀k a. suminf 𝕌(:num) (λn. if n ∈ k then a n else 0) = suminf k a
</pre>

<DT><span class="strong">INFSUM_SUB</span>
<DD>
<pre>
⊢ ∀x y s.
    summable s x ∧ summable s y ⇒
    (suminf s (λi. x i − y i) = suminf s x − suminf s y)
</pre>

<DT><span class="strong">INFSUM_UNIQUE</span>
<DD>
<pre>
⊢ ∀f l s. (f sums l) s ⇒ (suminf s f = l)
</pre>

<DT><span class="strong">INF_INSERT</span>
<DD>
<pre>
⊢ ∀x s. bounded s ⇒ (inf (x INSERT s) = if s = ∅ then x else min x (inf s))
</pre>

<DT><span class="strong">INJECTIVE_IMP_ISOMETRIC</span>
<DD>
<pre>
⊢ ∀f s.
    closed s ∧ subspace s ∧ linear f ∧ (∀x. x ∈ s ∧ (f x = 0) ⇒ (x = 0)) ⇒
    ∃e. 0 < e ∧ ∀x. x ∈ s ⇒ abs (f x) ≥ e * abs x
</pre>

<DT><span class="strong">INJECTIVE_MAP_OPEN_IFF_CLOSED</span>
<DD>
<pre>
⊢ ∀f s t.
    f continuous_on s ∧ (IMAGE f s = t) ∧
    (∀x y. x ∈ s ∧ y ∈ s ∧ (f x = f y) ⇒ (x = y)) ⇒
    ((∀u. open_in (subtopology euclidean s) u ⇒
          open_in (subtopology euclidean t) (IMAGE f u)) ⇔
     ∀u. closed_in (subtopology euclidean s) u ⇒
         closed_in (subtopology euclidean t) (IMAGE f u))
</pre>

<DT><span class="strong">INTERIOR_BALL</span>
<DD>
<pre>
⊢ ∀a r. interior (ball (a,r)) = ball (a,r)
</pre>

<DT><span class="strong">INTERIOR_BIGINTER_SUBSET</span>
<DD>
<pre>
⊢ ∀f. interior (BIGINTER f) ⊆ BIGINTER (IMAGE interior f)
</pre>

<DT><span class="strong">INTERIOR_BIJECTIVE_LINEAR_IMAGE</span>
<DD>
<pre>
⊢ ∀f s.
    linear f ∧ (∀x y. (f x = f y) ⇒ (x = y)) ∧ (∀y. ∃x. f x = y) ⇒
    (interior (IMAGE f s) = IMAGE f (interior s))
</pre>

<DT><span class="strong">INTERIOR_CBALL</span>
<DD>
<pre>
⊢ ∀x e. interior (cball (x,e)) = ball (x,e)
</pre>

<DT><span class="strong">INTERIOR_CLOSED_EQ_EMPTY_AS_FRONTIER</span>
<DD>
<pre>
⊢ ∀s. closed s ∧ (interior s = ∅) ⇔ ∃t. open t ∧ (s = frontier t)
</pre>

<DT><span class="strong">INTERIOR_CLOSED_INTERVAL</span>
<DD>
<pre>
⊢ ∀a b. interior (interval [(a,b)]) = interval (a,b)
</pre>

<DT><span class="strong">INTERIOR_CLOSED_UNION_EMPTY_INTERIOR</span>
<DD>
<pre>
⊢ ∀s t. closed s ∧ (interior t = ∅) ⇒ (interior (s ∪ t) = interior s)
</pre>

<DT><span class="strong">INTERIOR_CLOSURE</span>
<DD>
<pre>
⊢ ∀s. interior s = 𝕌(:real) DIFF closure (𝕌(:real) DIFF s)
</pre>

<DT><span class="strong">INTERIOR_CLOSURE_IDEMP</span>
<DD>
<pre>
⊢ ∀s. interior (closure (interior (closure s))) = interior (closure s)
</pre>

<DT><span class="strong">INTERIOR_CLOSURE_INTER_OPEN</span>
<DD>
<pre>
⊢ ∀s t.
    open s ∧ open t ⇒
    (interior (closure (s ∩ t)) = interior (closure s) ∩ interior (closure t))
</pre>

<DT><span class="strong">INTERIOR_COMPLEMENT</span>
<DD>
<pre>
⊢ ∀s. interior (𝕌(:real) DIFF s) = 𝕌(:real) DIFF closure s
</pre>

<DT><span class="strong">INTERIOR_DIFF</span>
<DD>
<pre>
⊢ ∀s t. interior (s DIFF t) = interior s DIFF closure t
</pre>

<DT><span class="strong">INTERIOR_EMPTY</span>
<DD>
<pre>
⊢ interior ∅ = ∅
</pre>

<DT><span class="strong">INTERIOR_EQ</span>
<DD>
<pre>
⊢ ∀s. (interior s = s) ⇔ open s
</pre>

<DT><span class="strong">INTERIOR_EQ_EMPTY</span>
<DD>
<pre>
⊢ ∀s. (interior s = ∅) ⇔ ∀t. open t ∧ t ⊆ s ⇒ (t = ∅)
</pre>

<DT><span class="strong">INTERIOR_EQ_EMPTY_ALT</span>
<DD>
<pre>
⊢ ∀s. (interior s = ∅) ⇔ ∀t. open t ∧ t ≠ ∅ ⇒ t DIFF s ≠ ∅
</pre>

<DT><span class="strong">INTERIOR_FINITE_BIGINTER</span>
<DD>
<pre>
⊢ ∀s. FINITE s ⇒ (interior (BIGINTER s) = BIGINTER (IMAGE interior s))
</pre>

<DT><span class="strong">INTERIOR_FRONTIER</span>
<DD>
<pre>
⊢ ∀s. interior (frontier s) = interior (closure s) DIFF closure (interior s)
</pre>

<DT><span class="strong">INTERIOR_FRONTIER_EMPTY</span>
<DD>
<pre>
⊢ ∀s. open s ∨ closed s ⇒ (interior (frontier s) = ∅)
</pre>

<DT><span class="strong">INTERIOR_HALFSPACE_COMPONENT_GE</span>
<DD>
<pre>
⊢ ∀a. interior {x | x ≥ a} = {x | x > a}
</pre>

<DT><span class="strong">INTERIOR_HALFSPACE_COMPONENT_LE</span>
<DD>
<pre>
⊢ ∀a. interior {x | x ≤ a} = {x | x < a}
</pre>

<DT><span class="strong">INTERIOR_HALFSPACE_GE</span>
<DD>
<pre>
⊢ ∀a b. a ≠ 0 ⇒ (interior {x | a * x ≥ b} = {x | a * x > b})
</pre>

<DT><span class="strong">INTERIOR_HALFSPACE_LE</span>
<DD>
<pre>
⊢ ∀a b. a ≠ 0 ⇒ (interior {x | a * x ≤ b} = {x | a * x < b})
</pre>

<DT><span class="strong">INTERIOR_HYPERPLANE</span>
<DD>
<pre>
⊢ ∀a b. a ≠ 0 ⇒ (interior {x | a * x = b} = ∅)
</pre>

<DT><span class="strong">INTERIOR_IMAGE_SUBSET</span>
<DD>
<pre>
⊢ ∀f s.
    (∀x. f continuous at x) ∧ (∀x y. (f x = f y) ⇒ (x = y)) ⇒
    interior (IMAGE f s) ⊆ IMAGE f (interior s)
</pre>

<DT><span class="strong">INTERIOR_INJECTIVE_LINEAR_IMAGE</span>
<DD>
<pre>
⊢ ∀f s.
    linear f ∧ (∀x y. (f x = f y) ⇒ (x = y)) ⇒
    (interior (IMAGE f s) = IMAGE f (interior s))
</pre>

<DT><span class="strong">INTERIOR_INTER</span>
<DD>
<pre>
⊢ ∀s t. interior (s ∩ t) = interior s ∩ interior t
</pre>

<DT><span class="strong">INTERIOR_INTERIOR</span>
<DD>
<pre>
⊢ ∀s. interior (interior s) = interior s
</pre>

<DT><span class="strong">INTERIOR_INTERVAL</span>
<DD>
<pre>
⊢ (∀a b. interior (interval [(a,b)]) = interval (a,b)) ∧
  ∀a b. interior (interval (a,b)) = interval (a,b)
</pre>

<DT><span class="strong">INTERIOR_LIMIT_POINT</span>
<DD>
<pre>
⊢ ∀s x. x ∈ interior s ⇒ x limit_point_of s
</pre>

<DT><span class="strong">INTERIOR_MAXIMAL</span>
<DD>
<pre>
⊢ ∀s t. t ⊆ s ∧ open t ⇒ t ⊆ interior s
</pre>

<DT><span class="strong">INTERIOR_MAXIMAL_EQ</span>
<DD>
<pre>
⊢ ∀s t. open s ⇒ (s ⊆ interior t ⇔ s ⊆ t)
</pre>

<DT><span class="strong">INTERIOR_NEGATIONS</span>
<DD>
<pre>
⊢ ∀s. interior (IMAGE (λx. -x) s) = IMAGE (λx. -x) (interior s)
</pre>

<DT><span class="strong">INTERIOR_OPEN</span>
<DD>
<pre>
⊢ ∀s. open s ⇒ (interior s = s)
</pre>

<DT><span class="strong">INTERIOR_SING</span>
<DD>
<pre>
⊢ ∀a. interior {a} = ∅
</pre>

<DT><span class="strong">INTERIOR_STANDARD_HYPERPLANE</span>
<DD>
<pre>
⊢ ∀a. interior {x | x = a} = ∅
</pre>

<DT><span class="strong">INTERIOR_SUBSET</span>
<DD>
<pre>
⊢ ∀s. interior s ⊆ s
</pre>

<DT><span class="strong">INTERIOR_TRANSLATION</span>
<DD>
<pre>
⊢ ∀a s. interior (IMAGE (λx. a + x) s) = IMAGE (λx. a + x) (interior s)
</pre>

<DT><span class="strong">INTERIOR_UNIONS_OPEN_SUBSETS</span>
<DD>
<pre>
⊢ ∀s. BIGUNION {t | open t ∧ t ⊆ s} = interior s
</pre>

<DT><span class="strong">INTERIOR_UNION_EQ_EMPTY</span>
<DD>
<pre>
⊢ ∀s t.
    closed s ∨ closed t ⇒
    ((interior (s ∪ t) = ∅) ⇔ (interior s = ∅) ∧ (interior t = ∅))
</pre>

<DT><span class="strong">INTERIOR_UNIQUE</span>
<DD>
<pre>
⊢ ∀s t. t ⊆ s ∧ open t ∧ (∀t'. t' ⊆ s ∧ open t' ⇒ t' ⊆ t) ⇒ (interior s = t)
</pre>

<DT><span class="strong">INTERIOR_UNIV</span>
<DD>
<pre>
⊢ interior 𝕌(:real) = 𝕌(:real)
</pre>

<DT><span class="strong">INTERVAL</span>
<DD>
<pre>
⊢ (∀a b.
     interval [(a,b)] =
     if a ≤ b then cball (midpoint (a,b),dist (a,b) / 2) else ∅) ∧
  ∀a b.
    interval (a,b) = if a < b then ball (midpoint (a,b),dist (a,b) / 2) else ∅
</pre>

<DT><span class="strong">INTERVAL_BOUNDS_EMPTY</span>
<DD>
<pre>
⊢ interval_upperbound ∅ = interval_lowerbound ∅
</pre>

<DT><span class="strong">INTERVAL_BOUNDS_NULL</span>
<DD>
<pre>
⊢ ∀a b.
    (content (interval [(a,b)]) = 0) ⇒
    (interval_upperbound (interval [(a,b)]) =
     interval_lowerbound (interval [(a,b)]))
</pre>

<DT><span class="strong">INTERVAL_CASES</span>
<DD>
<pre>
⊢ ∀x. x ∈ interval [(a,b)] ⇒ x ∈ interval (a,b) ∨ (x = a) ∨ (x = b)
</pre>

<DT><span class="strong">INTERVAL_CONTAINS_COMPACT_NEIGHBOURHOOD</span>
<DD>
<pre>
⊢ ∀s x.
    is_interval s ∧ x ∈ s ⇒
    ∃a b d.
      0 < d ∧ x ∈ interval [(a,b)] ∧ interval [(a,b)] ⊆ s ∧
      ball (x,d) ∩ s ⊆ interval [(a,b)]
</pre>

<DT><span class="strong">INTERVAL_EQ_EMPTY</span>
<DD>
<pre>
⊢ ∀a b. (b < a ⇔ (interval [(a,b)] = ∅)) ∧ (b ≤ a ⇔ (interval (a,b) = ∅))
</pre>

<DT><span class="strong">INTERVAL_IMAGE_STRETCH_INTERVAL</span>
<DD>
<pre>
⊢ ∀a b m. ∃u v.
    IMAGE (λx. @f. f = m 1 * x) (interval [(a,b)]) = interval [(u,v)]
</pre>

<DT><span class="strong">INTERVAL_LOWERBOUND</span>
<DD>
<pre>
⊢ ∀a b. a ≤ b ⇒ (interval_lowerbound (interval [(a,b)]) = a)
</pre>

<DT><span class="strong">INTERVAL_LOWERBOUND_NONEMPTY</span>
<DD>
<pre>
⊢ ∀a b. interval [(a,b)] ≠ ∅ ⇒ (interval_lowerbound (interval [(a,b)]) = a)
</pre>

<DT><span class="strong">INTERVAL_NE_EMPTY</span>
<DD>
<pre>
⊢ (interval [(a,b)] ≠ ∅ ⇔ a ≤ b) ∧ (interval (a,b) ≠ ∅ ⇔ a < b)
</pre>

<DT><span class="strong">INTERVAL_OPEN_SUBSET_CLOSED</span>
<DD>
<pre>
⊢ ∀a b. interval (a,b) ⊆ interval [(a,b)]
</pre>

<DT><span class="strong">INTERVAL_SING</span>
<DD>
<pre>
⊢ (interval [(a,a)] = {a}) ∧ (interval (a,a) = ∅)
</pre>

<DT><span class="strong">INTERVAL_SUBSET_IS_INTERVAL</span>
<DD>
<pre>
⊢ ∀s a b.
    is_interval s ⇒
    (interval [(a,b)] ⊆ s ⇔ (interval [(a,b)] = ∅) ∨ a ∈ s ∧ b ∈ s)
</pre>

<DT><span class="strong">INTERVAL_TRANSLATION</span>
<DD>
<pre>
⊢ (∀c a b. interval [(c + a,c + b)] = IMAGE (λx. c + x) (interval [(a,b)])) ∧
  ∀c a b. interval (c + a,c + b) = IMAGE (λx. c + x) (interval (a,b))
</pre>

<DT><span class="strong">INTERVAL_UPPERBOUND</span>
<DD>
<pre>
⊢ ∀a b. a ≤ b ⇒ (interval_upperbound (interval [(a,b)]) = b)
</pre>

<DT><span class="strong">INTERVAL_UPPERBOUND_NONEMPTY</span>
<DD>
<pre>
⊢ ∀a b. interval [(a,b)] ≠ ∅ ⇒ (interval_upperbound (interval [(a,b)]) = b)
</pre>

<DT><span class="strong">INTER_BALLS_EQ_EMPTY</span>
<DD>
<pre>
⊢ (∀a b r s.
     (ball (a,r) ∩ ball (b,s) = ∅) ⇔ r ≤ 0 ∨ s ≤ 0 ∨ r + s ≤ dist (a,b)) ∧
  (∀a b r s.
     (ball (a,r) ∩ cball (b,s) = ∅) ⇔ r ≤ 0 ∨ s < 0 ∨ r + s ≤ dist (a,b)) ∧
  (∀a b r s.
     (cball (a,r) ∩ ball (b,s) = ∅) ⇔ r < 0 ∨ s ≤ 0 ∨ r + s ≤ dist (a,b)) ∧
  ∀a b r s.
    (cball (a,r) ∩ cball (b,s) = ∅) ⇔ r < 0 ∨ s < 0 ∨ r + s < dist (a,b)
</pre>

<DT><span class="strong">INTER_INTERVAL</span>
<DD>
<pre>
⊢ interval [(a,b)] ∩ interval [(c,d)] = interval [(max a c,min b d)]
</pre>

<DT><span class="strong">INTER_INTERVAL_MIXED_EQ_EMPTY</span>
<DD>
<pre>
⊢ ∀a b c d.
    interval (c,d) ≠ ∅ ⇒
    ((interval (a,b) ∩ interval [(c,d)] = ∅) ⇔
     (interval (a,b) ∩ interval (c,d) = ∅))
</pre>

<DT><span class="strong">IN_BALL</span>
<DD>
<pre>
⊢ ∀x y e. y ∈ ball (x,e) ⇔ dist (x,y) < e
</pre>

<DT><span class="strong">IN_BALL_0</span>
<DD>
<pre>
⊢ ∀x e. x ∈ ball (0,e) ⇔ abs x < e
</pre>

<DT><span class="strong">IN_CBALL</span>
<DD>
<pre>
⊢ ∀x y e. y ∈ cball (x,e) ⇔ dist (x,y) ≤ e
</pre>

<DT><span class="strong">IN_CBALL_0</span>
<DD>
<pre>
⊢ ∀x e. x ∈ cball (0,e) ⇔ abs x ≤ e
</pre>

<DT><span class="strong">IN_CLOSURE_DELETE</span>
<DD>
<pre>
⊢ ∀s x. x ∈ closure (s DELETE x) ⇔ x limit_point_of s
</pre>

<DT><span class="strong">IN_COMPONENTS</span>
<DD>
<pre>
⊢ ∀u s. s ∈ components u ⇔ ∃x. x ∈ u ∧ (s = connected_component u x)
</pre>

<DT><span class="strong">IN_COMPONENTS_BIGUNION_COMPLEMENT</span>
<DD>
<pre>
⊢ ∀s c. c ∈ components s ⇒ (s DIFF c = BIGUNION (components s DELETE c))
</pre>

<DT><span class="strong">IN_COMPONENTS_CONNECTED</span>
<DD>
<pre>
⊢ ∀s c. c ∈ components s ⇒ connected c
</pre>

<DT><span class="strong">IN_COMPONENTS_MAXIMAL</span>
<DD>
<pre>
⊢ ∀s c.
    c ∈ components s ⇔
    c ≠ ∅ ∧ c ⊆ s ∧ connected c ∧
    ∀c'. c' ≠ ∅ ∧ c ⊆ c' ∧ c' ⊆ s ∧ connected c' ⇒ (c' = c)
</pre>

<DT><span class="strong">IN_COMPONENTS_NONEMPTY</span>
<DD>
<pre>
⊢ ∀s c. c ∈ components s ⇒ c ≠ ∅
</pre>

<DT><span class="strong">IN_COMPONENTS_SELF</span>
<DD>
<pre>
⊢ ∀s. s ∈ components s ⇔ connected s ∧ s ≠ ∅
</pre>

<DT><span class="strong">IN_COMPONENTS_SUBSET</span>
<DD>
<pre>
⊢ ∀s c. c ∈ components s ⇒ c ⊆ s
</pre>

<DT><span class="strong">IN_DIRECTION</span>
<DD>
<pre>
⊢ ∀a v x y.
    netord (a in_direction v) x y ⇔
    0 < dist (x,a) ∧ dist (x,a) ≤ dist (y,a) ∧ ∃c. 0 ≤ c ∧ (x − a = c * v)
</pre>

<DT><span class="strong">IN_INTERIOR</span>
<DD>
<pre>
⊢ ∀x s. x ∈ interior s ⇔ ∃e. 0 < e ∧ ball (x,e) ⊆ s
</pre>

<DT><span class="strong">IN_INTERIOR_CBALL</span>
<DD>
<pre>
⊢ ∀x s. x ∈ interior s ⇔ ∃e. 0 < e ∧ cball (x,e) ⊆ s
</pre>

<DT><span class="strong">IN_INTERIOR_LINEAR_IMAGE</span>
<DD>
<pre>
⊢ ∀f g s x.
    linear f ∧ linear g ∧ (f ∘ g = I) ∧ x ∈ interior s ⇒
    f x ∈ interior (IMAGE f s)
</pre>

<DT><span class="strong">IN_INTERVAL</span>
<DD>
<pre>
⊢ (x ∈ interval (a,b) ⇔ a < x ∧ x < b) ∧
  (x ∈ interval [(a,b)] ⇔ a ≤ x ∧ x ≤ b)
</pre>

<DT><span class="strong">IN_INTERVAL_REFLECT</span>
<DD>
<pre>
⊢ (∀a b x. -x ∈ interval [(-b,-a)] ⇔ x ∈ interval [(a,b)]) ∧
  ∀a b x. -x ∈ interval (-b,-a) ⇔ x ∈ interval (a,b)
</pre>

<DT><span class="strong">IN_OPEN_SEGMENT</span>
<DD>
<pre>
⊢ ∀a b x. x ∈ segment (a,b) ⇔ x ∈ segment [(a,b)] ∧ x ≠ a ∧ x ≠ b
</pre>

<DT><span class="strong">IN_OPEN_SEGMENT_ALT</span>
<DD>
<pre>
⊢ ∀a b x. x ∈ segment (a,b) ⇔ x ∈ segment [(a,b)] ∧ x ≠ a ∧ x ≠ b ∧ a ≠ b
</pre>

<DT><span class="strong">IN_SEGMENT</span>
<DD>
<pre>
⊢ ∀a b x.
    (x ∈ segment [(a,b)] ⇔ ∃u. 0 ≤ u ∧ u ≤ 1 ∧ (x = (1 − u) * a + u * b)) ∧
    (x ∈ segment (a,b) ⇔ a ≠ b ∧ ∃u. 0 < u ∧ u < 1 ∧ (x = (1 − u) * a + u * b))
</pre>

<DT><span class="strong">IN_SEGMENT_COMPONENT</span>
<DD>
<pre>
⊢ ∀a b x i. x ∈ segment [(a,b)] ⇒ min a b ≤ x ∧ x ≤ max a b
</pre>

<DT><span class="strong">IN_SPAN_DELETE</span>
<DD>
<pre>
⊢ ∀a b s. a ∈ span s ∧ a ∉ span (s DELETE b) ⇒ b ∈ span (a INSERT s DELETE b)
</pre>

<DT><span class="strong">IN_SPAN_INSERT</span>
<DD>
<pre>
⊢ ∀a b s. a ∈ span (b INSERT s) ∧ a ∉ span s ⇒ b ∈ span (a INSERT s)
</pre>

<DT><span class="strong">IN_SPHERE</span>
<DD>
<pre>
⊢ ∀x y e. y ∈ sphere (x,e) ⇔ (dist (x,y) = e)
</pre>

<DT><span class="strong">IN_SPHERE_0</span>
<DD>
<pre>
⊢ ∀x e. x ∈ sphere (0,e) ⇔ (abs x = e)
</pre>

<DT><span class="strong">ISOMETRY_IMP_EMBEDDING</span>
<DD>
<pre>
⊢ ∀f s t.
    (IMAGE f s = t) ∧ (∀x y. x ∈ s ∧ y ∈ s ⇒ (dist (f x,f y) = dist (x,y))) ⇒
    ∃g. homeomorphism (s,t) (f,g)
</pre>

<DT><span class="strong">ISOMETRY_IMP_HOMEOMORPHISM_COMPACT</span>
<DD>
<pre>
⊢ ∀f s.
    compact s ∧ IMAGE f s ⊆ s ∧
    (∀x y. x ∈ s ∧ y ∈ s ⇒ (dist (f x,f y) = dist (x,y))) ⇒
    ∃g. homeomorphism (s,s) (f,g)
</pre>

<DT><span class="strong">ISOMETRY_IMP_OPEN_MAP</span>
<DD>
<pre>
⊢ ∀f s t u.
    (IMAGE f s = t) ∧ (∀x y. x ∈ s ∧ y ∈ s ⇒ (dist (f x,f y) = dist (x,y))) ∧
    open_in (subtopology euclidean s) u ⇒
    open_in (subtopology euclidean t) (IMAGE f u)
</pre>

<DT><span class="strong">ISOMETRY_ON_IMP_CONTINUOUS_ON</span>
<DD>
<pre>
⊢ ∀f. (∀x y. x ∈ s ∧ y ∈ s ⇒ (dist (f x,f y) = dist (x,y))) ⇒
      f continuous_on s
</pre>

<DT><span class="strong">IS_INTERVAL</span>
<DD>
<pre>
⊢ ∀s. is_interval s ⇔ ∀a b x. a ∈ s ∧ b ∈ s ∧ a ≤ x ∧ x ≤ b ⇒ x ∈ s
</pre>

<DT><span class="strong">IS_INTERVAL_CASES</span>
<DD>
<pre>
⊢ ∀s. is_interval s ⇔
      (s = ∅) ∨ (s = 𝕌(:real)) ∨ (∃a. s = {x | a < x}) ∨
      (∃a. s = {x | a ≤ x}) ∨ (∃b. s = {x | x ≤ b}) ∨ (∃b. s = {x | x < b}) ∨
      (∃a b. s = {x | a < x ∧ x < b}) ∨ (∃a b. s = {x | a < x ∧ x ≤ b}) ∨
      (∃a b. s = {x | a ≤ x ∧ x < b}) ∨ ∃a b. s = {x | a ≤ x ∧ x ≤ b}
</pre>

<DT><span class="strong">IS_INTERVAL_COMPACT</span>
<DD>
<pre>
⊢ ∀s. is_interval s ∧ compact s ⇔ ∃a b. s = interval [(a,b)]
</pre>

<DT><span class="strong">IS_INTERVAL_EMPTY</span>
<DD>
<pre>
⊢ is_interval ∅
</pre>

<DT><span class="strong">IS_INTERVAL_IMP_LOCALLY_COMPACT</span>
<DD>
<pre>
⊢ ∀s. is_interval s ⇒ locally compact s
</pre>

<DT><span class="strong">IS_INTERVAL_INTER</span>
<DD>
<pre>
⊢ ∀s t. is_interval s ∧ is_interval t ⇒ is_interval (s ∩ t)
</pre>

<DT><span class="strong">IS_INTERVAL_INTERVAL</span>
<DD>
<pre>
⊢ ∀a b. is_interval (interval (a,b)) ∧ is_interval (interval [(a,b)])
</pre>

<DT><span class="strong">IS_INTERVAL_POINTWISE</span>
<DD>
<pre>
⊢ ∀s x. is_interval s ⇒ (∃a. a ∈ s ∧ (a = x)) ⇒ x ∈ s
</pre>

<DT><span class="strong">IS_INTERVAL_SCALING</span>
<DD>
<pre>
⊢ ∀s c. is_interval s ⇒ is_interval (IMAGE (λx. c * x) s)
</pre>

<DT><span class="strong">IS_INTERVAL_SCALING_EQ</span>
<DD>
<pre>
⊢ ∀s c. is_interval (IMAGE (λx. c * x) s) ⇔ (c = 0) ∨ is_interval s
</pre>

<DT><span class="strong">IS_INTERVAL_SING</span>
<DD>
<pre>
⊢ ∀a. is_interval {a}
</pre>

<DT><span class="strong">IS_INTERVAL_SUMS</span>
<DD>
<pre>
⊢ ∀s t. is_interval s ∧ is_interval t ⇒ is_interval {x + y | x ∈ s ∧ y ∈ t}
</pre>

<DT><span class="strong">IS_INTERVAL_UNIV</span>
<DD>
<pre>
⊢ is_interval 𝕌(:real)
</pre>

<DT><span class="strong">JOINABLE_COMPONENTS_EQ</span>
<DD>
<pre>
⊢ ∀s t c1 c2.
    connected t ∧ t ⊆ s ∧ c1 ∈ components s ∧ c2 ∈ components s ∧ c1 ∩ t ≠ ∅ ∧
    c2 ∩ t ≠ ∅ ⇒
    (c1 = c2)
</pre>

<DT><span class="strong">JOINABLE_CONNECTED_COMPONENT_EQ</span>
<DD>
<pre>
⊢ ∀s t x y.
    connected t ∧ t ⊆ s ∧ connected_component s x ∩ t ≠ ∅ ∧
    connected_component s y ∩ t ≠ ∅ ⇒
    (connected_component s x = connected_component s y)
</pre>

<DT><span class="strong">LEBESGUE_COVERING_LEMMA</span>
<DD>
<pre>
⊢ ∀s c.
    compact s ∧ c ≠ ∅ ∧ s ⊆ BIGUNION c ∧ (∀b. b ∈ c ⇒ open b) ⇒
    ∃d. 0 < d ∧ ∀t. t ⊆ s ∧ diameter t ≤ d ⇒ ∃b. b ∈ c ∧ t ⊆ b
</pre>

<DT><span class="strong">LE_1</span>
<DD>
<pre>
⊢ (∀n. n ≠ 0 ⇒ 0 < n) ∧ (∀n. n ≠ 0 ⇒ 1 ≤ n) ∧ (∀n. 0 < n ⇒ n ≠ 0) ∧
  (∀n. 0 < n ⇒ 1 ≤ n) ∧ (∀n. 1 ≤ n ⇒ 0 < n) ∧ ∀n. 1 ≤ n ⇒ n ≠ 0
</pre>

<DT><span class="strong">LIFT_TO_QUOTIENT_SPACE</span>
<DD>
<pre>
⊢ ∀f h s t u.
    (IMAGE f s = t) ∧
    (∀v. v ⊆ t ⇒
         (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ v} ⇔
          open_in (subtopology euclidean t) v)) ∧ h continuous_on s ∧
    (IMAGE h s = u) ∧ (∀x y. x ∈ s ∧ y ∈ s ∧ (f x = f y) ⇒ (h x = h y)) ⇒
    ∃g. g continuous_on t ∧ (IMAGE g t = u) ∧ ∀x. x ∈ s ⇒ (h x = g (f x))
</pre>

<DT><span class="strong">LIFT_TO_QUOTIENT_SPACE_UNIQUE</span>
<DD>
<pre>
⊢ ∀f g s t u.
    (IMAGE f s = t) ∧ (IMAGE g s = u) ∧
    (∀v. v ⊆ t ⇒
         (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ v} ⇔
          open_in (subtopology euclidean t) v)) ∧
    (∀v. v ⊆ u ⇒
         (open_in (subtopology euclidean s) {x | x ∈ s ∧ g x ∈ v} ⇔
          open_in (subtopology euclidean u) v)) ∧
    (∀x y. x ∈ s ∧ y ∈ s ⇒ ((f x = f y) ⇔ (g x = g y))) ⇒
    t homeomorphic u
</pre>

<DT><span class="strong">LIMIT_POINT_FINITE</span>
<DD>
<pre>
⊢ ∀s a. FINITE s ⇒ ¬(a limit_point_of s)
</pre>

<DT><span class="strong">LIMIT_POINT_UNION</span>
<DD>
<pre>
⊢ ∀s t x. x limit_point_of s ∪ t ⇔ x limit_point_of s ∨ x limit_point_of t
</pre>

<DT><span class="strong">LIMPT_APPROACHABLE</span>
<DD>
<pre>
⊢ ∀x s.
    x limit_point_of s ⇔ ∀e. 0 < e ⇒ ∃x'. x' ∈ s ∧ x' ≠ x ∧ dist (x',x) < e
</pre>

<DT><span class="strong">LIMPT_APPROACHABLE_LE</span>
<DD>
<pre>
⊢ ∀x s.
    x limit_point_of s ⇔ ∀e. 0 < e ⇒ ∃x'. x' ∈ s ∧ x' ≠ x ∧ dist (x',x) ≤ e
</pre>

<DT><span class="strong">LIMPT_BALL</span>
<DD>
<pre>
⊢ ∀x y e. y limit_point_of ball (x,e) ⇔ 0 < e ∧ y ∈ cball (x,e)
</pre>

<DT><span class="strong">LIMPT_EMPTY</span>
<DD>
<pre>
⊢ ∀x. ¬(x limit_point_of ∅)
</pre>

<DT><span class="strong">LIMPT_INFINITE_BALL</span>
<DD>
<pre>
⊢ ∀s x. x limit_point_of s ⇔ ∀e. 0 < e ⇒ INFINITE (s ∩ ball (x,e))
</pre>

<DT><span class="strong">LIMPT_INFINITE_CBALL</span>
<DD>
<pre>
⊢ ∀s x. x limit_point_of s ⇔ ∀e. 0 < e ⇒ INFINITE (s ∩ cball (x,e))
</pre>

<DT><span class="strong">LIMPT_INFINITE_OPEN</span>
<DD>
<pre>
⊢ ∀s x. x limit_point_of s ⇔ ∀t. x ∈ t ∧ open t ⇒ INFINITE (s ∩ t)
</pre>

<DT><span class="strong">LIMPT_INFINITE_OPEN_BALL_CBALL</span>
<DD>
<pre>
⊢ (∀s x. x limit_point_of s ⇔ ∀t. x ∈ t ∧ open t ⇒ INFINITE (s ∩ t)) ∧
  (∀s x. x limit_point_of s ⇔ ∀e. 0 < e ⇒ INFINITE (s ∩ ball (x,e))) ∧
  ∀s x. x limit_point_of s ⇔ ∀e. 0 < e ⇒ INFINITE (s ∩ cball (x,e))
</pre>

<DT><span class="strong">LIMPT_INJECTIVE_LINEAR_IMAGE_EQ</span>
<DD>
<pre>
⊢ ∀f s.
    linear f ∧ (∀x y. (f x = f y) ⇒ (x = y)) ⇒
    (f x limit_point_of IMAGE f s ⇔ x limit_point_of s)
</pre>

<DT><span class="strong">LIMPT_INSERT</span>
<DD>
<pre>
⊢ ∀s x y. x limit_point_of y INSERT s ⇔ x limit_point_of s
</pre>

<DT><span class="strong">LIMPT_OF_CLOSURE</span>
<DD>
<pre>
⊢ ∀x s. x limit_point_of closure s ⇔ x limit_point_of s
</pre>

<DT><span class="strong">LIMPT_OF_LIMPTS</span>
<DD>
<pre>
⊢ ∀x s. x limit_point_of {y | y limit_point_of s} ⇒ x limit_point_of s
</pre>

<DT><span class="strong">LIMPT_OF_OPEN</span>
<DD>
<pre>
⊢ ∀s x. open s ∧ x ∈ s ⇒ x limit_point_of s
</pre>

<DT><span class="strong">LIMPT_OF_OPEN_IN</span>
<DD>
<pre>
⊢ ∀s t x.
    open_in (subtopology euclidean s) t ∧ x limit_point_of s ∧ x ∈ t ⇒
    x limit_point_of t
</pre>

<DT><span class="strong">LIMPT_OF_SEQUENCE_SUBSEQUENCE</span>
<DD>
<pre>
⊢ ∀f l.
    l limit_point_of IMAGE f 𝕌(:num) ⇒
    ∃r. (∀m n. m < n ⇒ r m < r n) ∧ (f ∘ r --> l) sequentially
</pre>

<DT><span class="strong">LIMPT_OF_UNIV</span>
<DD>
<pre>
⊢ ∀x. x limit_point_of 𝕌(:real)
</pre>

<DT><span class="strong">LIMPT_SEQUENTIAL</span>
<DD>
<pre>
⊢ ∀x s.
    x limit_point_of s ⇔ ∃f. (∀n. f n ∈ s DELETE x) ∧ (f --> x) sequentially
</pre>

<DT><span class="strong">LIMPT_SEQUENTIAL_INJ</span>
<DD>
<pre>
⊢ ∀x s.
    x limit_point_of s ⇔
    ∃f. (∀n. f n ∈ s DELETE x) ∧ (∀m n. (f m = f n) ⇔ (m = n)) ∧
        (f --> x) sequentially
</pre>

<DT><span class="strong">LIMPT_SING</span>
<DD>
<pre>
⊢ ∀x y. ¬(x limit_point_of {y})
</pre>

<DT><span class="strong">LIMPT_SUBSET</span>
<DD>
<pre>
⊢ ∀x s t. x limit_point_of s ∧ s ⊆ t ⇒ x limit_point_of t
</pre>

<DT><span class="strong">LIMPT_UNIV</span>
<DD>
<pre>
⊢ ∀x. x limit_point_of 𝕌(:real)
</pre>

<DT><span class="strong">LIM_ABS</span>
<DD>
<pre>
⊢ ∀net f l. (f --> l) net ⇒ ((λx. abs (f x)) --> abs l) net
</pre>

<DT><span class="strong">LIM_ABS_LBOUND</span>
<DD>
<pre>
⊢ ∀net f l b.
    ¬trivial_limit net ∧ (f --> l) net ∧ eventually (λx. b ≤ abs (f x)) net ⇒
    b ≤ abs l
</pre>

<DT><span class="strong">LIM_ABS_UBOUND</span>
<DD>
<pre>
⊢ ∀net f l b.
    ¬trivial_limit net ∧ (f --> l) net ∧ eventually (λx. abs (f x) ≤ b) net ⇒
    abs l ≤ b
</pre>

<DT><span class="strong">LIM_ADD</span>
<DD>
<pre>
⊢ ∀net f g l m.
    (f --> l) net ∧ (g --> m) net ⇒ ((λx. f x + g x) --> (l + m)) net
</pre>

<DT><span class="strong">LIM_AT</span>
<DD>
<pre>
⊢ ∀f l a.
    (f --> l) (at a) ⇔
    ∀e. 0 < e ⇒
        ∃d. 0 < d ∧ ∀x. 0 < dist (x,a) ∧ dist (x,a) < d ⇒ dist (f x,l) < e
</pre>

<DT><span class="strong">LIM_AT_ID</span>
<DD>
<pre>
⊢ ∀a. ((λx. x) --> a) (at a)
</pre>

<DT><span class="strong">LIM_AT_INFINITY</span>
<DD>
<pre>
⊢ ∀f l.
    (f --> l) at_infinity ⇔ ∀e. 0 < e ⇒ ∃b. ∀x. abs x ≥ b ⇒ dist (f x,l) < e
</pre>

<DT><span class="strong">LIM_AT_INFINITY_POS</span>
<DD>
<pre>
⊢ ∀f l.
    (f --> l) at_infinity ⇔
    ∀e. 0 < e ⇒ ∃b. 0 < b ∧ ∀x. abs x ≥ b ⇒ dist (f x,l) < e
</pre>

<DT><span class="strong">LIM_AT_LE</span>
<DD>
<pre>
⊢ ∀f l a.
    (f --> l) (at a) ⇔
    ∀e. 0 < e ⇒
        ∃d. 0 < d ∧ ∀x. 0 < dist (x,a) ∧ dist (x,a) ≤ d ⇒ dist (f x,l) < e
</pre>

<DT><span class="strong">LIM_AT_NEGINFINITY</span>
<DD>
<pre>
⊢ ∀f l.
    (f --> l) at_neginfinity ⇔ ∀e. 0 < e ⇒ ∃b. ∀x. x ≤ b ⇒ dist (f x,l) < e
</pre>

<DT><span class="strong">LIM_AT_POSINFINITY</span>
<DD>
<pre>
⊢ ∀f l.
    (f --> l) at_posinfinity ⇔ ∀e. 0 < e ⇒ ∃b. ∀x. x ≥ b ⇒ dist (f x,l) < e
</pre>

<DT><span class="strong">LIM_AT_WITHIN</span>
<DD>
<pre>
⊢ ∀f l a s. (f --> l) (at a) ⇒ (f --> l) (at a within s)
</pre>

<DT><span class="strong">LIM_AT_ZERO</span>
<DD>
<pre>
⊢ ∀f l a. (f --> l) (at a) ⇔ ((λx. f (a + x)) --> l) (at 0)
</pre>

<DT><span class="strong">LIM_BILINEAR</span>
<DD>
<pre>
⊢ ∀net h f g l m.
    (f --> l) net ∧ (g --> m) net ∧ bilinear h ⇒
    ((λx. h (f x) (g x)) --> h l m) net
</pre>

<DT><span class="strong">LIM_CASES_COFINITE_SEQUENTIALLY</span>
<DD>
<pre>
⊢ ∀f g l.
    FINITE {n | (¬P n)} ⇒
    (((λn. if P n then f n else g n) --> l) sequentially ⇔
     (f --> l) sequentially)
</pre>

<DT><span class="strong">LIM_CASES_FINITE_SEQUENTIALLY</span>
<DD>
<pre>
⊢ ∀f g l.
    FINITE {n | P n} ⇒
    (((λn. if P n then f n else g n) --> l) sequentially ⇔
     (g --> l) sequentially)
</pre>

<DT><span class="strong">LIM_CASES_SEQUENTIALLY</span>
<DD>
<pre>
⊢ ∀f g l m.
    (((λn. if m ≤ n then f n else g n) --> l) sequentially ⇔
     (f --> l) sequentially) ∧
    (((λn. if m < n then f n else g n) --> l) sequentially ⇔
     (f --> l) sequentially) ∧
    (((λn. if n ≤ m then f n else g n) --> l) sequentially ⇔
     (g --> l) sequentially) ∧
    (((λn. if n < m then f n else g n) --> l) sequentially ⇔
     (g --> l) sequentially)
</pre>

<DT><span class="strong">LIM_CMUL</span>
<DD>
<pre>
⊢ ∀f l c. (f --> l) net ⇒ ((λx. c * f x) --> (c * l)) net
</pre>

<DT><span class="strong">LIM_CMUL_EQ</span>
<DD>
<pre>
⊢ ∀net f l c. c ≠ 0 ⇒ (((λx. c * f x) --> (c * l)) net ⇔ (f --> l) net)
</pre>

<DT><span class="strong">LIM_COMPONENT</span>
<DD>
<pre>
⊢ ∀net f i l. (f --> l) net ⇒ ((λa. f a) --> l) net
</pre>

<DT><span class="strong">LIM_COMPONENT_EQ</span>
<DD>
<pre>
⊢ ∀net f i l b.
    (f --> l) net ∧ ¬trivial_limit net ∧ eventually (λx. f x = b) net ⇒
    (l = b)
</pre>

<DT><span class="strong">LIM_COMPONENT_LBOUND</span>
<DD>
<pre>
⊢ ∀net f l b.
    ¬trivial_limit net ∧ (f --> l) net ∧ eventually (λx. b ≤ f x) net ⇒ b ≤ l
</pre>

<DT><span class="strong">LIM_COMPONENT_LE</span>
<DD>
<pre>
⊢ ∀net f g l m.
    ¬trivial_limit net ∧ (f --> l) net ∧ (g --> m) net ∧
    eventually (λx. f x ≤ g x) net ⇒
    l ≤ m
</pre>

<DT><span class="strong">LIM_COMPONENT_UBOUND</span>
<DD>
<pre>
⊢ ∀net f l b k.
    ¬trivial_limit net ∧ (f --> l) net ∧ eventually (λx. f x ≤ b) net ⇒ l ≤ b
</pre>

<DT><span class="strong">LIM_COMPOSE_AT</span>
<DD>
<pre>
⊢ ∀net f g y z.
    (f --> y) net ∧ eventually (λw. (f w = y) ⇒ (g y = z)) net ∧
    (g --> z) (at y) ⇒
    (g ∘ f --> z) net
</pre>

<DT><span class="strong">LIM_COMPOSE_WITHIN</span>
<DD>
<pre>
⊢ ∀net f g s y z.
    (f --> y) net ∧ eventually (λw. f w ∈ s ∧ ((f w = y) ⇒ (g y = z))) net ∧
    (g --> z) (at y within s) ⇒
    (g ∘ f --> z) net
</pre>

<DT><span class="strong">LIM_CONG_AT</span>
<DD>
<pre>
⊢ (∀x. x ≠ a ⇒ (f x = g x)) ⇒ (((λx. f x) --> l) (at a) ⇔ (g --> l) (at a))
</pre>

<DT><span class="strong">LIM_CONG_WITHIN</span>
<DD>
<pre>
⊢ (∀x. x ≠ a ⇒ (f x = g x)) ⇒
  (((λx. f x) --> l) (at a within s) ⇔ (g --> l) (at a within s))
</pre>

<DT><span class="strong">LIM_CONST</span>
<DD>
<pre>
⊢ ∀net a. ((λx. a) --> a) net
</pre>

<DT><span class="strong">LIM_CONST_EQ</span>
<DD>
<pre>
⊢ ∀net c d. ((λx. c) --> d) net ⇔ trivial_limit net ∨ (c = d)
</pre>

<DT><span class="strong">LIM_CONTINUOUS_FUNCTION</span>
<DD>
<pre>
⊢ ∀f net g l. f continuous at l ∧ (g --> l) net ⇒ ((λx. f (g x)) --> f l) net
</pre>

<DT><span class="strong">LIM_DEF</span>
<DD>
<pre>
⊢ ∀f l net.
    (f --> l) net ⇔
    trivial_limit net ∨
    ∀e. 0 < e ⇒
        ∃y. (∃x. netord net x y) ∧ ∀x. netord net x y ⇒ dist (f x,l) < e
</pre>

<DT><span class="strong">LIM_DROP_LBOUND</span>
<DD>
<pre>
⊢ ∀net f l b.
    (f --> l) net ∧ ¬trivial_limit net ∧ eventually (λx. b ≤ f x) net ⇒ b ≤ l
</pre>

<DT><span class="strong">LIM_DROP_LE</span>
<DD>
<pre>
⊢ ∀net f g l m.
    ¬trivial_limit net ∧ (f --> l) net ∧ (g --> m) net ∧
    eventually (λx. f x ≤ g x) net ⇒
    l ≤ m
</pre>

<DT><span class="strong">LIM_DROP_UBOUND</span>
<DD>
<pre>
⊢ ∀net f l b.
    (f --> l) net ∧ ¬trivial_limit net ∧ eventually (λx. f x ≤ b) net ⇒ l ≤ b
</pre>

<DT><span class="strong">LIM_EVENTUALLY</span>
<DD>
<pre>
⊢ ∀net f l. eventually (λx. f x = l) net ⇒ (f --> l) net
</pre>

<DT><span class="strong">LIM_INFINITY_POSINFINITY</span>
<DD>
<pre>
⊢ ∀f l. (f --> l) at_infinity ⇒ (f --> l) at_posinfinity
</pre>

<DT><span class="strong">LIM_INV</span>
<DD>
<pre>
⊢ ∀net f l. (f --> l) net ∧ l ≠ 0 ⇒ (realinv ∘ f --> l⁻¹) net
</pre>

<DT><span class="strong">LIM_IN_CLOSED_SET</span>
<DD>
<pre>
⊢ ∀net f s l.
    closed s ∧ eventually (λx. f x ∈ s) net ∧ ¬trivial_limit net ∧
    (f --> l) net ⇒
    l ∈ s
</pre>

<DT><span class="strong">LIM_LIFT_DOT</span>
<DD>
<pre>
⊢ ∀f a. (f --> l) net ⇒ ((λy. a * f y) --> (a * l)) net
</pre>

<DT><span class="strong">LIM_LINEAR</span>
<DD>
<pre>
⊢ ∀net h f l. (f --> l) net ∧ linear h ⇒ ((λx. h (f x)) --> h l) net
</pre>

<DT><span class="strong">LIM_MAX</span>
<DD>
<pre>
⊢ ∀net f g l m.
    (f --> l) net ∧ (g --> m) net ⇒ ((λx. max (f x) (g x)) --> max l m) net
</pre>

<DT><span class="strong">LIM_MIN</span>
<DD>
<pre>
⊢ ∀net f g l m.
    (f --> l) net ∧ (g --> m) net ⇒ ((λx. min (f x) (g x)) --> min l m) net
</pre>

<DT><span class="strong">LIM_MUL</span>
<DD>
<pre>
⊢ ∀net f l c d.
    (c --> d) net ∧ (f --> l) net ⇒ ((λx. c x * f x) --> (d * l)) net
</pre>

<DT><span class="strong">LIM_NEG</span>
<DD>
<pre>
⊢ ∀net f l. (f --> l) net ⇒ ((λx. -f x) --> -l) net
</pre>

<DT><span class="strong">LIM_NEG_EQ</span>
<DD>
<pre>
⊢ ∀net f l. ((λx. -f x) --> -l) net ⇔ (f --> l) net
</pre>

<DT><span class="strong">LIM_NULL</span>
<DD>
<pre>
⊢ ∀net f l. (f --> l) net ⇔ ((λx. f x − l) --> 0) net
</pre>

<DT><span class="strong">LIM_NULL_ABS</span>
<DD>
<pre>
⊢ ∀net f. (f --> 0) net ⇔ ((λx. abs (f x)) --> 0) net
</pre>

<DT><span class="strong">LIM_NULL_ADD</span>
<DD>
<pre>
⊢ ∀net f g. (f --> 0) net ∧ (g --> 0) net ⇒ ((λx. f x + g x) --> 0) net
</pre>

<DT><span class="strong">LIM_NULL_CMUL</span>
<DD>
<pre>
⊢ ∀net f c. (f --> 0) net ⇒ ((λx. c * f x) --> 0) net
</pre>

<DT><span class="strong">LIM_NULL_CMUL_BOUNDED</span>
<DD>
<pre>
⊢ ∀f g B.
    eventually (λa. (g a = 0) ∨ abs (f a) ≤ B) net ∧ (g --> 0) net ⇒
    ((λn. f n * g n) --> 0) net
</pre>

<DT><span class="strong">LIM_NULL_CMUL_EQ</span>
<DD>
<pre>
⊢ ∀net f c. c ≠ 0 ⇒ (((λx. c * f x) --> 0) net ⇔ (f --> 0) net)
</pre>

<DT><span class="strong">LIM_NULL_COMPARISON</span>
<DD>
<pre>
⊢ ∀net f g.
    eventually (λx. abs (f x) ≤ g x) net ∧ ((λx. g x) --> 0) net ⇒
    (f --> 0) net
</pre>

<DT><span class="strong">LIM_NULL_SUB</span>
<DD>
<pre>
⊢ ∀net f g. (f --> 0) net ∧ (g --> 0) net ⇒ ((λx. f x − g x) --> 0) net
</pre>

<DT><span class="strong">LIM_NULL_SUM</span>
<DD>
<pre>
⊢ ∀net f s.
    FINITE s ∧ (∀a. a ∈ s ⇒ ((λx. f x a) --> 0) net) ⇒
    ((λx. sum s (f x)) --> 0) net
</pre>

<DT><span class="strong">LIM_POSINFINITY_SEQUENTIALLY</span>
<DD>
<pre>
⊢ ∀f l. (f --> l) at_posinfinity ⇒ ((λn. f (&n)) --> l) sequentially
</pre>

<DT><span class="strong">LIM_SEQUENTIALLY</span>
<DD>
<pre>
⊢ ∀s l. (s --> l) sequentially ⇔ ∀e. 0 < e ⇒ ∃N. ∀n. N ≤ n ⇒ dist (s n,l) < e
</pre>

<DT><span class="strong">LIM_SUB</span>
<DD>
<pre>
⊢ ∀net f g l m.
    (f --> l) net ∧ (g --> m) net ⇒ ((λx. f x − g x) --> (l − m)) net
</pre>

<DT><span class="strong">LIM_SUBSEQUENCE</span>
<DD>
<pre>
⊢ ∀s r l.
    (∀m n. m < n ⇒ r m < r n) ∧ (s --> l) sequentially ⇒
    (s ∘ r --> l) sequentially
</pre>

<DT><span class="strong">LIM_SUBSEQUENCE_WEAK</span>
<DD>
<pre>
⊢ ∀s r l.
    (∀m n. m ≤ n ⇒ r m ≤ r n) ∧ (∀n. ∃m. n ≤ r m) ∧ (s --> l) sequentially ⇒
    (s ∘ r --> l) sequentially
</pre>

<DT><span class="strong">LIM_SUM</span>
<DD>
<pre>
⊢ ∀net f l s.
    FINITE s ∧ (∀i. i ∈ s ⇒ (f i --> l i) net) ⇒
    ((λx. sum s (λi. f i x)) --> sum s l) net
</pre>

<DT><span class="strong">LIM_TRANSFORM</span>
<DD>
<pre>
⊢ ∀net f g l. ((λx. f x − g x) --> 0) net ∧ (f --> l) net ⇒ (g --> l) net
</pre>

<DT><span class="strong">LIM_TRANSFORM_AT</span>
<DD>
<pre>
⊢ ∀f g x d.
    0 < d ∧ (∀x'. 0 < dist (x',x) ∧ dist (x',x) < d ⇒ (f x' = g x')) ∧
    (f --> l) (at x) ⇒
    (g --> l) (at x)
</pre>

<DT><span class="strong">LIM_TRANSFORM_AWAY_AT</span>
<DD>
<pre>
⊢ ∀f g a b.
    a ≠ b ∧ (∀x. x ≠ a ∧ x ≠ b ⇒ (f x = g x)) ∧ (f --> l) (at a) ⇒
    (g --> l) (at a)
</pre>

<DT><span class="strong">LIM_TRANSFORM_AWAY_WITHIN</span>
<DD>
<pre>
⊢ ∀f g a b s.
    a ≠ b ∧ (∀x. x ∈ s ∧ x ≠ a ∧ x ≠ b ⇒ (f x = g x)) ∧
    (f --> l) (at a within s) ⇒
    (g --> l) (at a within s)
</pre>

<DT><span class="strong">LIM_TRANSFORM_BOUND</span>
<DD>
<pre>
⊢ ∀f g.
    eventually (λn. abs (f n) ≤ abs (g n)) net ∧ (g --> 0) net ⇒ (f --> 0) net
</pre>

<DT><span class="strong">LIM_TRANSFORM_EQ</span>
<DD>
<pre>
⊢ ∀net f g l. ((λx. f x − g x) --> 0) net ⇒ ((f --> l) net ⇔ (g --> l) net)
</pre>

<DT><span class="strong">LIM_TRANSFORM_EVENTUALLY</span>
<DD>
<pre>
⊢ ∀net f g l. eventually (λx. f x = g x) net ∧ (f --> l) net ⇒ (g --> l) net
</pre>

<DT><span class="strong">LIM_TRANSFORM_WITHIN</span>
<DD>
<pre>
⊢ ∀f g x s d.
    0 < d ∧
    (∀x'. x' ∈ s ∧ 0 < dist (x',x) ∧ dist (x',x) < d ⇒ (f x' = g x')) ∧
    (f --> l) (at x within s) ⇒
    (g --> l) (at x within s)
</pre>

<DT><span class="strong">LIM_TRANSFORM_WITHIN_OPEN</span>
<DD>
<pre>
⊢ ∀f g s a l.
    open s ∧ a ∈ s ∧ (∀x. x ∈ s ∧ x ≠ a ⇒ (f x = g x)) ∧ (f --> l) (at a) ⇒
    (g --> l) (at a)
</pre>

<DT><span class="strong">LIM_TRANSFORM_WITHIN_OPEN_IN</span>
<DD>
<pre>
⊢ ∀f g s t a l.
    open_in (subtopology euclidean t) s ∧ a ∈ s ∧
    (∀x. x ∈ s ∧ x ≠ a ⇒ (f x = g x)) ∧ (f --> l) (at a within t) ⇒
    (g --> l) (at a within t)
</pre>

<DT><span class="strong">LIM_TRANSFORM_WITHIN_SET</span>
<DD>
<pre>
⊢ ∀f a s t.
    eventually (λx. x ∈ s ⇔ x ∈ t) (at a) ⇒
    ((f --> l) (at a within s) ⇔ (f --> l) (at a within t))
</pre>

<DT><span class="strong">LIM_TRANSFORM_WITHIN_SET_IMP</span>
<DD>
<pre>
⊢ ∀f l a s t.
    eventually (λx. x ∈ t ⇒ x ∈ s) (at a) ∧ (f --> l) (at a within s) ⇒
    (f --> l) (at a within t)
</pre>

<DT><span class="strong">LIM_UNION</span>
<DD>
<pre>
⊢ ∀f x l s t.
    (f --> l) (at x within s) ∧ (f --> l) (at x within t) ⇒
    (f --> l) (at x within s ∪ t)
</pre>

<DT><span class="strong">LIM_UNION_UNIV</span>
<DD>
<pre>
⊢ ∀f x l s t.
    (f --> l) (at x within s) ∧ (f --> l) (at x within t) ∧ (s ∪ t = 𝕌(:real)) ⇒
    (f --> l) (at x)
</pre>

<DT><span class="strong">LIM_UNIQUE</span>
<DD>
<pre>
⊢ ∀net f l l'. ¬trivial_limit net ∧ (f --> l) net ∧ (f --> l') net ⇒ (l = l')
</pre>

<DT><span class="strong">LIM_VMUL</span>
<DD>
<pre>
⊢ ∀net c d v. (c --> d) net ⇒ ((λx. c x * v) --> (d * v)) net
</pre>

<DT><span class="strong">LIM_WITHIN</span>
<DD>
<pre>
⊢ ∀f l a s.
    (f --> l) (at a within s) ⇔
    ∀e. 0 < e ⇒
        ∃d. 0 < d ∧
            ∀x. x ∈ s ∧ 0 < dist (x,a) ∧ dist (x,a) < d ⇒ dist (f x,l) < e
</pre>

<DT><span class="strong">LIM_WITHIN_CLOSED_TRIVIAL</span>
<DD>
<pre>
⊢ ∀a s. closed s ∧ a ∉ s ⇒ trivial_limit (at a within s)
</pre>

<DT><span class="strong">LIM_WITHIN_EMPTY</span>
<DD>
<pre>
⊢ ∀f l x. (f --> l) (at x within ∅)
</pre>

<DT><span class="strong">LIM_WITHIN_ID</span>
<DD>
<pre>
⊢ ∀a s. ((λx. x) --> a) (at a within s)
</pre>

<DT><span class="strong">LIM_WITHIN_INTERIOR</span>
<DD>
<pre>
⊢ ∀f l s x. x ∈ interior s ⇒ ((f --> l) (at x within s) ⇔ (f --> l) (at x))
</pre>

<DT><span class="strong">LIM_WITHIN_LE</span>
<DD>
<pre>
⊢ ∀f l a s.
    (f --> l) (at a within s) ⇔
    ∀e. 0 < e ⇒
        ∃d. 0 < d ∧
            ∀x. x ∈ s ∧ 0 < dist (x,a) ∧ dist (x,a) ≤ d ⇒ dist (f x,l) < e
</pre>

<DT><span class="strong">LIM_WITHIN_OPEN</span>
<DD>
<pre>
⊢ ∀f l a s. a ∈ s ∧ open s ⇒ ((f --> l) (at a within s) ⇔ (f --> l) (at a))
</pre>

<DT><span class="strong">LIM_WITHIN_SUBSET</span>
<DD>
<pre>
⊢ ∀f l a s. (f --> l) (at a within s) ∧ t ⊆ s ⇒ (f --> l) (at a within t)
</pre>

<DT><span class="strong">LIM_WITHIN_UNION</span>
<DD>
<pre>
⊢ (f --> l) (at x within s ∪ t) ⇔
  (f --> l) (at x within s) ∧ (f --> l) (at x within t)
</pre>

<DT><span class="strong">LINEAR_0</span>
<DD>
<pre>
⊢ ∀f. linear f ⇒ (f 0 = 0)
</pre>

<DT><span class="strong">LINEAR_ADD</span>
<DD>
<pre>
⊢ ∀f x y. linear f ⇒ (f (x + y) = f x + f y)
</pre>

<DT><span class="strong">LINEAR_BOUNDED</span>
<DD>
<pre>
⊢ ∀f. linear f ⇒ ∃B. ∀x. abs (f x) ≤ B * abs x
</pre>

<DT><span class="strong">LINEAR_BOUNDED_POS</span>
<DD>
<pre>
⊢ ∀f. linear f ⇒ ∃B. 0 < B ∧ ∀x. abs (f x) ≤ B * abs x
</pre>

<DT><span class="strong">LINEAR_CMUL</span>
<DD>
<pre>
⊢ ∀f c x. linear f ⇒ (f (c * x) = c * f x)
</pre>

<DT><span class="strong">LINEAR_COMPOSE</span>
<DD>
<pre>
⊢ ∀f g. linear f ∧ linear g ⇒ linear (g ∘ f)
</pre>

<DT><span class="strong">LINEAR_COMPOSE_ADD</span>
<DD>
<pre>
⊢ ∀f g. linear f ∧ linear g ⇒ linear (λx. f x + g x)
</pre>

<DT><span class="strong">LINEAR_COMPOSE_CMUL</span>
<DD>
<pre>
⊢ ∀f c. linear f ⇒ linear (λx. c * f x)
</pre>

<DT><span class="strong">LINEAR_COMPOSE_NEG</span>
<DD>
<pre>
⊢ ∀f. linear f ⇒ linear (λx. -f x)
</pre>

<DT><span class="strong">LINEAR_COMPOSE_SUB</span>
<DD>
<pre>
⊢ ∀f g. linear f ∧ linear g ⇒ linear (λx. f x − g x)
</pre>

<DT><span class="strong">LINEAR_COMPOSE_SUM</span>
<DD>
<pre>
⊢ ∀f s. FINITE s ∧ (∀a. a ∈ s ⇒ linear (f a)) ⇒ linear (λx. sum s (λa. f a x))
</pre>

<DT><span class="strong">LINEAR_CONTINUOUS_AT</span>
<DD>
<pre>
⊢ ∀f a. linear f ⇒ f continuous at a
</pre>

<DT><span class="strong">LINEAR_CONTINUOUS_COMPOSE</span>
<DD>
<pre>
⊢ ∀net f g. f continuous net ∧ linear g ⇒ (λx. g (f x)) continuous net
</pre>

<DT><span class="strong">LINEAR_CONTINUOUS_ON</span>
<DD>
<pre>
⊢ ∀f s. linear f ⇒ f continuous_on s
</pre>

<DT><span class="strong">LINEAR_CONTINUOUS_ON_COMPOSE</span>
<DD>
<pre>
⊢ ∀f g s. f continuous_on s ∧ linear g ⇒ (λx. g (f x)) continuous_on s
</pre>

<DT><span class="strong">LINEAR_CONTINUOUS_WITHIN</span>
<DD>
<pre>
⊢ ∀f s x. linear f ⇒ f continuous (at x within s)
</pre>

<DT><span class="strong">LINEAR_EQ</span>
<DD>
<pre>
⊢ ∀f g b s.
    linear f ∧ linear g ∧ s ⊆ span b ∧ (∀x. x ∈ b ⇒ (f x = g x)) ⇒
    ∀x. x ∈ s ⇒ (f x = g x)
</pre>

<DT><span class="strong">LINEAR_EQ_0</span>
<DD>
<pre>
⊢ ∀f b s.
    linear f ∧ s ⊆ span b ∧ (∀x. x ∈ b ⇒ (f x = 0)) ⇒ ∀x. x ∈ s ⇒ (f x = 0)
</pre>

<DT><span class="strong">LINEAR_EQ_0_SPAN</span>
<DD>
<pre>
⊢ ∀f b. linear f ∧ (∀x. x ∈ b ⇒ (f x = 0)) ⇒ ∀x. x ∈ span b ⇒ (f x = 0)
</pre>

<DT><span class="strong">LINEAR_EQ_STDBASIS</span>
<DD>
<pre>
⊢ ∀f g. linear f ∧ linear g ∧ (∀i. 1 ≤ i ∧ i ≤ 1 ⇒ (f i = g i)) ⇒ (f = g)
</pre>

<DT><span class="strong">LINEAR_ID</span>
<DD>
<pre>
⊢ linear (λx. x)
</pre>

<DT><span class="strong">LINEAR_IMAGE_SUBSET_INTERIOR</span>
<DD>
<pre>
⊢ ∀f s.
    linear f ∧ (∀y. ∃x. f x = y) ⇒ IMAGE f (interior s) ⊆ interior (IMAGE f s)
</pre>

<DT><span class="strong">LINEAR_INDEPENDENT_EXTEND</span>
<DD>
<pre>
⊢ ∀f b. independent b ⇒ ∃g. linear g ∧ ∀x. x ∈ b ⇒ (g x = f x)
</pre>

<DT><span class="strong">LINEAR_INDEPENDENT_EXTEND_LEMMA</span>
<DD>
<pre>
⊢ ∀f b.
    FINITE b ⇒
    independent b ⇒
    ∃g. (∀x y. x ∈ span b ∧ y ∈ span b ⇒ (g (x + y) = g x + g y)) ∧
        (∀x c. x ∈ span b ⇒ (g (c * x) = c * g x)) ∧ ∀x. x ∈ b ⇒ (g x = f x)
</pre>

<DT><span class="strong">LINEAR_INJECTIVE_0_SUBSPACE</span>
<DD>
<pre>
⊢ ∀f s.
    linear f ∧ subspace s ⇒
    ((∀x y. x ∈ s ∧ y ∈ s ∧ (f x = f y) ⇒ (x = y)) ⇔
     ∀x. x ∈ s ∧ (f x = 0) ⇒ (x = 0))
</pre>

<DT><span class="strong">LINEAR_INJECTIVE_BOUNDED_BELOW_POS</span>
<DD>
<pre>
⊢ ∀f. linear f ∧ (∀x y. (f x = f y) ⇒ (x = y)) ⇒
      ∃B. 0 < B ∧ ∀x. abs x * B ≤ abs (f x)
</pre>

<DT><span class="strong">LINEAR_INJECTIVE_IMP_SURJECTIVE</span>
<DD>
<pre>
⊢ ∀f. linear f ∧ (∀x y. (f x = f y) ⇒ (x = y)) ⇒ ∀y. ∃x. f x = y
</pre>

<DT><span class="strong">LINEAR_INJECTIVE_LEFT_INVERSE</span>
<DD>
<pre>
⊢ ∀f. linear f ∧ (∀x y. (f x = f y) ⇒ (x = y)) ⇒
      ∃g. linear g ∧ (g ∘ f = (λx. x))
</pre>

<DT><span class="strong">LINEAR_INTERIOR_IMAGE_SUBSET</span>
<DD>
<pre>
⊢ ∀f s.
    linear f ∧ (∀x y. (f x = f y) ⇒ (x = y)) ⇒
    interior (IMAGE f s) ⊆ IMAGE f (interior s)
</pre>

<DT><span class="strong">LINEAR_INVERTIBLE_BOUNDED_BELOW</span>
<DD>
<pre>
⊢ ∀f g. linear f ∧ linear g ∧ (g ∘ f = I) ⇒ ∃B. ∀x. B * abs x ≤ abs (f x)
</pre>

<DT><span class="strong">LINEAR_INVERTIBLE_BOUNDED_BELOW_POS</span>
<DD>
<pre>
⊢ ∀f g.
    linear f ∧ linear g ∧ (g ∘ f = I) ⇒ ∃B. 0 < B ∧ ∀x. B * abs x ≤ abs (f x)
</pre>

<DT><span class="strong">LINEAR_LIM_0</span>
<DD>
<pre>
⊢ ∀f. linear f ⇒ (f --> 0) (at 0)
</pre>

<DT><span class="strong">LINEAR_MUL_COMPONENT</span>
<DD>
<pre>
⊢ ∀f v. linear f ⇒ linear (λx. f x * v)
</pre>

<DT><span class="strong">LINEAR_NEG</span>
<DD>
<pre>
⊢ ∀f x. linear f ⇒ (f (-x) = -f x)
</pre>

<DT><span class="strong">LINEAR_NEGATION</span>
<DD>
<pre>
⊢ linear (λx. -x)
</pre>

<DT><span class="strong">LINEAR_OPEN_MAPPING</span>
<DD>
<pre>
⊢ ∀f g. linear f ∧ linear g ∧ (f ∘ g = I) ⇒ ∀s. open s ⇒ open (IMAGE f s)
</pre>

<DT><span class="strong">LINEAR_SCALING</span>
<DD>
<pre>
⊢ ∀c. linear (λx. c * x)
</pre>

<DT><span class="strong">LINEAR_SUB</span>
<DD>
<pre>
⊢ ∀f x y. linear f ⇒ (f (x − y) = f x − f y)
</pre>

<DT><span class="strong">LINEAR_SUM</span>
<DD>
<pre>
⊢ ∀f g s. linear f ∧ FINITE s ⇒ (f (sum s g) = sum s (f ∘ g))
</pre>

<DT><span class="strong">LINEAR_SUM_MUL</span>
<DD>
<pre>
⊢ ∀f s c v.
    linear f ∧ FINITE s ⇒
    (f (sum s (λi. c i * v i)) = sum s (λi. c i * f (v i)))
</pre>

<DT><span class="strong">LINEAR_UNIFORMLY_CONTINUOUS_ON</span>
<DD>
<pre>
⊢ ∀f s. linear f ⇒ f uniformly_continuous_on s
</pre>

<DT><span class="strong">LINEAR_ZERO</span>
<DD>
<pre>
⊢ linear (λx. 0)
</pre>

<DT><span class="strong">LOCALLY_CLOSED</span>
<DD>
<pre>
⊢ ∀s. locally closed s ⇔ locally compact s
</pre>

<DT><span class="strong">LOCALLY_COMPACT</span>
<DD>
<pre>
⊢ ∀s. locally compact s ⇔
      ∀x. x ∈ s ⇒
          ∃u v.
            x ∈ u ∧ u ⊆ v ∧ v ⊆ s ∧ open_in (subtopology euclidean s) u ∧
            compact v
</pre>

<DT><span class="strong">LOCALLY_COMPACT_ALT</span>
<DD>
<pre>
⊢ ∀s. locally compact s ⇔
      ∀x. x ∈ s ⇒
          ∃u. x ∈ u ∧ open_in (subtopology euclidean s) u ∧
              compact (closure u) ∧ closure u ⊆ s
</pre>

<DT><span class="strong">LOCALLY_COMPACT_CLOSED_IN</span>
<DD>
<pre>
⊢ ∀s t.
    closed_in (subtopology euclidean s) t ∧ locally compact s ⇒
    locally compact t
</pre>

<DT><span class="strong">LOCALLY_COMPACT_CLOSED_INTER_OPEN</span>
<DD>
<pre>
⊢ ∀s. locally compact s ⇔ ∃t u. closed t ∧ open u ∧ (s = t ∩ u)
</pre>

<DT><span class="strong">LOCALLY_COMPACT_CLOSED_IN_OPEN</span>
<DD>
<pre>
⊢ ∀s. locally compact s ⇒ ∃t. open t ∧ closed_in (subtopology euclidean t) s
</pre>

<DT><span class="strong">LOCALLY_COMPACT_CLOSED_UNION</span>
<DD>
<pre>
⊢ ∀s t.
    locally compact s ∧ locally compact t ∧
    closed_in (subtopology euclidean (s ∪ t)) s ∧
    closed_in (subtopology euclidean (s ∪ t)) t ⇒
    locally compact (s ∪ t)
</pre>

<DT><span class="strong">LOCALLY_COMPACT_COMPACT</span>
<DD>
<pre>
⊢ ∀s. locally compact s ⇔
      ∀k. k ⊆ s ∧ compact k ⇒
          ∃u v.
            k ⊆ u ∧ u ⊆ v ∧ v ⊆ s ∧ open_in (subtopology euclidean s) u ∧
            compact v
</pre>

<DT><span class="strong">LOCALLY_COMPACT_COMPACT_ALT</span>
<DD>
<pre>
⊢ ∀s. locally compact s ⇔
      ∀k. k ⊆ s ∧ compact k ⇒
          ∃u. k ⊆ u ∧ open_in (subtopology euclidean s) u ∧
              compact (closure u) ∧ closure u ⊆ s
</pre>

<DT><span class="strong">LOCALLY_COMPACT_COMPACT_SUBOPEN</span>
<DD>
<pre>
⊢ ∀s. locally compact s ⇔
      ∀k t.
        k ⊆ s ∧ compact k ∧ open t ∧ k ⊆ t ⇒
        ∃u v.
          k ⊆ u ∧ u ⊆ v ∧ u ⊆ t ∧ v ⊆ s ∧
          open_in (subtopology euclidean s) u ∧ compact v
</pre>

<DT><span class="strong">LOCALLY_COMPACT_DELETE</span>
<DD>
<pre>
⊢ ∀s a. locally compact s ⇒ locally compact (s DELETE a)
</pre>

<DT><span class="strong">LOCALLY_COMPACT_INTER</span>
<DD>
<pre>
⊢ ∀s t. locally compact s ∧ locally compact t ⇒ locally compact (s ∩ t)
</pre>

<DT><span class="strong">LOCALLY_COMPACT_INTER_CBALL</span>
<DD>
<pre>
⊢ ∀s. locally compact s ⇔ ∀x. x ∈ s ⇒ ∃e. 0 < e ∧ closed (cball (x,e) ∩ s)
</pre>

<DT><span class="strong">LOCALLY_COMPACT_INTER_CBALLS</span>
<DD>
<pre>
⊢ ∀s. locally compact s ⇔
      ∀x. x ∈ s ⇒ ∃e. 0 < e ∧ ∀d. d ≤ e ⇒ closed (cball (x,d) ∩ s)
</pre>

<DT><span class="strong">LOCALLY_COMPACT_OPEN_IN</span>
<DD>
<pre>
⊢ ∀s t.
    open_in (subtopology euclidean s) t ∧ locally compact s ⇒
    locally compact t
</pre>

<DT><span class="strong">LOCALLY_COMPACT_OPEN_INTER_CLOSURE</span>
<DD>
<pre>
⊢ ∀s. locally compact s ⇒ ∃t. open t ∧ (s = t ∩ closure s)
</pre>

<DT><span class="strong">LOCALLY_COMPACT_OPEN_UNION</span>
<DD>
<pre>
⊢ ∀s t.
    locally compact s ∧ locally compact t ∧
    open_in (subtopology euclidean (s ∪ t)) s ∧
    open_in (subtopology euclidean (s ∪ t)) t ⇒
    locally compact (s ∪ t)
</pre>

<DT><span class="strong">LOCALLY_COMPACT_PROPER_IMAGE</span>
<DD>
<pre>
⊢ ∀f s.
    f continuous_on s ∧
    (∀k. k ⊆ IMAGE f s ∧ compact k ⇒ compact {x | x ∈ s ∧ f x ∈ k}) ∧
    locally compact s ⇒
    locally compact (IMAGE f s)
</pre>

<DT><span class="strong">LOCALLY_COMPACT_PROPER_IMAGE_EQ</span>
<DD>
<pre>
⊢ ∀f s.
    f continuous_on s ∧
    (∀k. k ⊆ IMAGE f s ∧ compact k ⇒ compact {x | x ∈ s ∧ f x ∈ k}) ⇒
    (locally compact s ⇔ locally compact (IMAGE f s))
</pre>

<DT><span class="strong">LOCALLY_COMPACT_TRANSLATION_EQ</span>
<DD>
<pre>
⊢ ∀a s. locally compact (IMAGE (λx. a + x) s) ⇔ locally compact s
</pre>

<DT><span class="strong">LOCALLY_COMPACT_UNIV</span>
<DD>
<pre>
⊢ locally compact 𝕌(:real)
</pre>

<DT><span class="strong">LOCALLY_DIFF_CLOSED</span>
<DD>
<pre>
⊢ ∀P s t.
    locally P s ∧ closed_in (subtopology euclidean s) t ⇒ locally P (s DIFF t)
</pre>

<DT><span class="strong">LOCALLY_EMPTY</span>
<DD>
<pre>
⊢ ∀P. locally P ∅
</pre>

<DT><span class="strong">LOCALLY_INJECTIVE_LINEAR_IMAGE</span>
<DD>
<pre>
⊢ ∀P Q.
    (∀f s. linear f ∧ (∀x y. (f x = f y) ⇒ (x = y)) ⇒ (P (IMAGE f s) ⇔ Q s)) ⇒
    ∀f s.
      linear f ∧ (∀x y. (f x = f y) ⇒ (x = y)) ⇒
      (locally P (IMAGE f s) ⇔ locally Q s)
</pre>

<DT><span class="strong">LOCALLY_INTER</span>
<DD>
<pre>
⊢ ∀P. (∀s t. P s ∧ P t ⇒ P (s ∩ t)) ⇒
      ∀s t. locally P s ∧ locally P t ⇒ locally P (s ∩ t)
</pre>

<DT><span class="strong">LOCALLY_MONO</span>
<DD>
<pre>
⊢ ∀P Q s. (∀t. P t ⇒ Q t) ∧ locally P s ⇒ locally Q s
</pre>

<DT><span class="strong">LOCALLY_OPEN_MAP_IMAGE</span>
<DD>
<pre>
⊢ ∀P Q f s.
    f continuous_on s ∧
    (∀t. open_in (subtopology euclidean s) t ⇒
         open_in (subtopology euclidean (IMAGE f s)) (IMAGE f t)) ∧
    (∀t. t ⊆ s ∧ P t ⇒ Q (IMAGE f t)) ∧ locally P s ⇒
    locally Q (IMAGE f s)
</pre>

<DT><span class="strong">LOCALLY_OPEN_SUBSET</span>
<DD>
<pre>
⊢ ∀P s t. locally P s ∧ open_in (subtopology euclidean s) t ⇒ locally P t
</pre>

<DT><span class="strong">LOCALLY_SING</span>
<DD>
<pre>
⊢ ∀P a. locally P {a} ⇔ P {a}
</pre>

<DT><span class="strong">LOCALLY_TRANSLATION</span>
<DD>
<pre>
⊢ ∀P. (∀a s. P (IMAGE (λx. a + x) s) ⇔ P s) ⇒
      ∀a s. locally P (IMAGE (λx. a + x) s) ⇔ locally P s
</pre>

<DT><span class="strong">LOWER_HEMICONTINUOUS</span>
<DD>
<pre>
⊢ ∀f t s.
    (∀x. x ∈ s ⇒ f x ⊆ t) ⇒
    ((∀u. closed_in (subtopology euclidean t) u ⇒
          closed_in (subtopology euclidean s) {x | x ∈ s ∧ f x ⊆ u}) ⇔
     ∀u. open_in (subtopology euclidean t) u ⇒
         open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∩ u ≠ ∅})
</pre>

<DT><span class="strong">MAPPING_CONNECTED_ONTO_SEGMENT</span>
<DD>
<pre>
⊢ ∀s a b.
    connected s ∧ ¬(∃a. s ⊆ {a}) ⇒
    ∃f. f continuous_on s ∧ (IMAGE f s = segment [(a,b)])
</pre>

<DT><span class="strong">MAXIMAL_INDEPENDENT_SUBSET</span>
<DD>
<pre>
⊢ ∀v. ∃b. b ⊆ v ∧ independent b ∧ v ⊆ span b
</pre>

<DT><span class="strong">MAXIMAL_INDEPENDENT_SUBSET_EXTEND</span>
<DD>
<pre>
⊢ ∀s v. s ⊆ v ∧ independent s ⇒ ∃b. s ⊆ b ∧ b ⊆ v ∧ independent b ∧ v ⊆ span b
</pre>

<DT><span class="strong">METRIZABLE_SPACE_EUCLIDEAN</span>
<DD>
<pre>
⊢ metrizable_space euclidean
</pre>

<DT><span class="strong">MIDPOINT_COLLINEAR</span>
<DD>
<pre>
⊢ ∀a b c.
    a ≠ c ⇒
    ((b = midpoint (a,c)) ⇔ collinear {a; b; c} ∧ (dist (a,b) = dist (b,c)))
</pre>

<DT><span class="strong">MIDPOINT_EQ_ENDPOINT</span>
<DD>
<pre>
⊢ ∀a b.
    ((midpoint (a,b) = a) ⇔ (a = b)) ∧ ((midpoint (a,b) = b) ⇔ (a = b)) ∧
    ((a = midpoint (a,b)) ⇔ (a = b)) ∧ ((b = midpoint (a,b)) ⇔ (a = b))
</pre>

<DT><span class="strong">MIDPOINT_IN_SEGMENT</span>
<DD>
<pre>
⊢ (∀a b. midpoint (a,b) ∈ segment [(a,b)]) ∧
  ∀a b. midpoint (a,b) ∈ segment (a,b) ⇔ a ≠ b
</pre>

<DT><span class="strong">MIDPOINT_LINEAR_IMAGE</span>
<DD>
<pre>
⊢ ∀f a b. linear f ⇒ (midpoint (f a,f b) = f (midpoint (a,b)))
</pre>

<DT><span class="strong">MIDPOINT_REFL</span>
<DD>
<pre>
⊢ ∀x. midpoint (x,x) = x
</pre>

<DT><span class="strong">MIDPOINT_SYM</span>
<DD>
<pre>
⊢ ∀a b. midpoint (a,b) = midpoint (b,a)
</pre>

<DT><span class="strong">MONOTONE_BIGGER</span>
<DD>
<pre>
⊢ ∀r. (∀m n. m < n ⇒ r m < r n) ⇒ ∀n. n ≤ r n
</pre>

<DT><span class="strong">MONOTONE_SUBSEQUENCE</span>
<DD>
<pre>
⊢ ∀s. ∃r.
    (∀m n. m < n ⇒ r m < r n) ∧
    ((∀m n. m ≤ n ⇒ s (r m) ≤ s (r n)) ∨ ∀m n. m ≤ n ⇒ s (r n) ≤ s (r m))
</pre>

<DT><span class="strong">MUL_CAUCHY_SCHWARZ_EQUAL</span>
<DD>
<pre>
⊢ ∀x y. ((x * y)² = x * x * (y * y)) ⇔ collinear {0; x; y}
</pre>

<DT><span class="strong">MUMFORD_LEMMA</span>
<DD>
<pre>
⊢ ∀f s t y.
    f continuous_on s ∧ IMAGE f s ⊆ t ∧ locally compact s ∧ y ∈ t ∧
    compact {x | x ∈ s ∧ (f x = y)} ⇒
    ∃u v.
      open_in (subtopology euclidean s) u ∧
      open_in (subtopology euclidean t) v ∧ {x | x ∈ s ∧ (f x = y)} ⊆ u ∧
      y ∈ v ∧ IMAGE f u ⊆ v ∧
      ∀k. k ⊆ v ∧ compact k ⇒ compact {x | x ∈ u ∧ f x ∈ k}
</pre>

<DT><span class="strong">NEGATIONS_BALL</span>
<DD>
<pre>
⊢ ∀r. IMAGE (λx. -x) (ball (0,r)) = ball (0,r)
</pre>

<DT><span class="strong">NEGATIONS_CBALL</span>
<DD>
<pre>
⊢ ∀r. IMAGE (λx. -x) (cball (0,r)) = cball (0,r)
</pre>

<DT><span class="strong">NEGATIONS_SPHERE</span>
<DD>
<pre>
⊢ ∀r. IMAGE (λx. -x) (sphere (0,r)) = sphere (0,r)
</pre>

<DT><span class="strong">NET</span>
<DD>
<pre>
⊢ ∀n x y. (∀z. netord n z x ⇒ netord n z y) ∨ ∀z. netord n z y ⇒ netord n z x
</pre>

<DT><span class="strong">NETLIMIT_AT</span>
<DD>
<pre>
⊢ ∀a. netlimit (at a) = a
</pre>

<DT><span class="strong">NETLIMIT_WITHIN</span>
<DD>
<pre>
⊢ ∀a s. ¬trivial_limit (at a within s) ⇒ (netlimit (at a within s) = a)
</pre>

<DT><span class="strong">NETLIMIT_WITHIN_INTERIOR</span>
<DD>
<pre>
⊢ ∀s x. x ∈ interior s ⇒ (netlimit (at x within s) = x)
</pre>

<DT><span class="strong">NET_DILEMMA</span>
<DD>
<pre>
⊢ ∀net.
    (∃a. (∃x. netord net x a) ∧ ∀x. netord net x a ⇒ P x) ∧
    (∃b. (∃x. netord net x b) ∧ ∀x. netord net x b ⇒ Q x) ⇒
    ∃c. (∃x. netord net x c) ∧ ∀x. netord net x c ⇒ P x ∧ Q x
</pre>

<DT><span class="strong">NONTRIVIAL_LIMIT_WITHIN</span>
<DD>
<pre>
⊢ ∀net s. trivial_limit net ⇒ trivial_limit (net within s)
</pre>

<DT><span class="strong">NOT_BOUNDED_UNIV</span>
<DD>
<pre>
⊢ ¬bounded 𝕌(:real)
</pre>

<DT><span class="strong">NOT_EVENTUALLY</span>
<DD>
<pre>
⊢ ∀net p. (∀x. ¬p x) ∧ ¬trivial_limit net ⇒ ¬eventually p net
</pre>

<DT><span class="strong">NOT_INTERVAL_UNIV</span>
<DD>
<pre>
⊢ (∀a b. interval [(a,b)] ≠ 𝕌(:real)) ∧ ∀a b. interval (a,b) ≠ 𝕌(:real)
</pre>

<DT><span class="strong">NOWHERE_DENSE</span>
<DD>
<pre>
⊢ ∀s. (interior (closure s) = ∅) ⇔
      ∀t. open t ∧ t ≠ ∅ ⇒ ∃u. open u ∧ u ≠ ∅ ∧ u ⊆ t ∧ (u ∩ s = ∅)
</pre>

<DT><span class="strong">NOWHERE_DENSE_COUNTABLE_BIGUNION</span>
<DD>
<pre>
⊢ ∀g. countable g ∧ (∀s. s ∈ g ⇒ (interior (closure s) = ∅)) ⇒
      (interior (BIGUNION g) = ∅)
</pre>

<DT><span class="strong">NOWHERE_DENSE_COUNTABLE_BIGUNION_CLOSED</span>
<DD>
<pre>
⊢ ∀g. countable g ∧ (∀s. s ∈ g ⇒ closed s ∧ (interior s = ∅)) ⇒
      (interior (BIGUNION g) = ∅)
</pre>

<DT><span class="strong">NOWHERE_DENSE_UNION</span>
<DD>
<pre>
⊢ ∀s t.
    (interior (closure (s ∪ t)) = ∅) ⇔
    (interior (closure s) = ∅) ∧ (interior (closure t) = ∅)
</pre>

<DT><span class="strong">NO_LIMIT_POINT_IMP_CLOSED</span>
<DD>
<pre>
⊢ ∀s. ¬(∃x. x limit_point_of s) ⇒ closed s
</pre>

<DT><span class="strong">OLDNET</span>
<DD>
<pre>
⊢ ∀n x y.
    netord n x x ∧ netord n y y ⇒
    ∃z. netord n z z ∧ ∀w. netord n w z ⇒ netord n w x ∧ netord n w y
</pre>

<DT><span class="strong">OPEN</span>
<DD>
<pre>
⊢ ∀s. open s ⇔ ∀x. x ∈ s ⇒ ∃e. 0 < e ∧ ∀x'. abs (x' − x) < e ⇒ x' ∈ s
</pre>

<DT><span class="strong">OPEN_AFFINITY</span>
<DD>
<pre>
⊢ ∀s a c. open s ∧ c ≠ 0 ⇒ open (IMAGE (λx. a + c * x) s)
</pre>

<DT><span class="strong">OPEN_BALL</span>
<DD>
<pre>
⊢ ∀x e. open (ball (x,e))
</pre>

<DT><span class="strong">OPEN_BIGINTER</span>
<DD>
<pre>
⊢ ∀s. FINITE s ∧ (∀t. t ∈ s ⇒ open t) ⇒ open (BIGINTER s)
</pre>

<DT><span class="strong">OPEN_BIGUNION</span>
<DD>
<pre>
⊢ ∀f. (∀s. s ∈ f ⇒ open s) ⇒ open (BIGUNION f)
</pre>

<DT><span class="strong">OPEN_BIJECTIVE_LINEAR_IMAGE_EQ</span>
<DD>
<pre>
⊢ ∀f s.
    linear f ∧ (∀x y. (f x = f y) ⇒ (x = y)) ∧ (∀y. ∃x. f x = y) ⇒
    (open (IMAGE f s) ⇔ open s)
</pre>

<DT><span class="strong">OPEN_CLOSED</span>
<DD>
<pre>
⊢ ∀s. open s ⇔ closed (𝕌(:real) DIFF s)
</pre>

<DT><span class="strong">OPEN_CLOSED_INTERVAL</span>
<DD>
<pre>
⊢ ∀a b. interval (a,b) = interval [(a,b)] DIFF {a; b}
</pre>

<DT><span class="strong">OPEN_CLOSED_INTERVAL_CONVEX</span>
<DD>
<pre>
⊢ ∀a b x y e.
    x ∈ interval (a,b) ∧ y ∈ interval [(a,b)] ∧ 0 < e ∧ e ≤ 1 ⇒
    e * x + (1 − e) * y ∈ interval (a,b)
</pre>

<DT><span class="strong">OPEN_CONTAINS_BALL</span>
<DD>
<pre>
⊢ ∀s. open s ⇔ ∀x. x ∈ s ⇒ ∃e. 0 < e ∧ ball (x,e) ⊆ s
</pre>

<DT><span class="strong">OPEN_CONTAINS_BALL_EQ</span>
<DD>
<pre>
⊢ ∀s. open s ⇒ ∀x. x ∈ s ⇔ ∃e. 0 < e ∧ ball (x,e) ⊆ s
</pre>

<DT><span class="strong">OPEN_CONTAINS_CBALL</span>
<DD>
<pre>
⊢ ∀s. open s ⇔ ∀x. x ∈ s ⇒ ∃e. 0 < e ∧ cball (x,e) ⊆ s
</pre>

<DT><span class="strong">OPEN_CONTAINS_CBALL_EQ</span>
<DD>
<pre>
⊢ ∀s. open s ⇒ ∀x. x ∈ s ⇔ ∃e. 0 < e ∧ cball (x,e) ⊆ s
</pre>

<DT><span class="strong">OPEN_CONTAINS_INTERVAL</span>
<DD>
<pre>
⊢ ∀s. open s ⇔ ∀x. x ∈ s ⇒ ∃a b. x ∈ interval (a,b) ∧ interval [(a,b)] ⊆ s
</pre>

<DT><span class="strong">OPEN_CONTAINS_INTERVAL_OPEN_INTERVAL</span>
<DD>
<pre>
⊢ (∀s. open s ⇔ ∀x. x ∈ s ⇒ ∃a b. x ∈ interval (a,b) ∧ interval [(a,b)] ⊆ s) ∧
  ∀s. open s ⇔ ∀x. x ∈ s ⇒ ∃a b. x ∈ interval (a,b) ∧ interval (a,b) ⊆ s
</pre>

<DT><span class="strong">OPEN_CONTAINS_OPEN_INTERVAL</span>
<DD>
<pre>
⊢ ∀s. open s ⇔ ∀x. x ∈ s ⇒ ∃a b. x ∈ interval (a,b) ∧ interval (a,b) ⊆ s
</pre>

<DT><span class="strong">OPEN_DELETE</span>
<DD>
<pre>
⊢ ∀s x. open s ⇒ open (s DELETE x)
</pre>

<DT><span class="strong">OPEN_DIFF</span>
<DD>
<pre>
⊢ ∀s t. open s ∧ closed t ⇒ open (s DIFF t)
</pre>

<DT><span class="strong">OPEN_EMPTY</span>
<DD>
<pre>
⊢ open ∅
</pre>

<DT><span class="strong">OPEN_EXISTS</span>
<DD>
<pre>
⊢ ∀Q. (∀a. open {x | Q a x}) ⇒ open {x | (∃a. Q a x)}
</pre>

<DT><span class="strong">OPEN_EXISTS_IN</span>
<DD>
<pre>
⊢ ∀P Q. (∀a. P a ⇒ open {x | Q a x}) ⇒ open {x | (∃a. P a ∧ Q a x)}
</pre>

<DT><span class="strong">OPEN_HALFSPACE_COMPONENT_GT</span>
<DD>
<pre>
⊢ ∀a. open {x | x > a}
</pre>

<DT><span class="strong">OPEN_HALFSPACE_COMPONENT_LT</span>
<DD>
<pre>
⊢ ∀a. open {x | x < a}
</pre>

<DT><span class="strong">OPEN_HALFSPACE_GT</span>
<DD>
<pre>
⊢ ∀a b. open {x | a * x > b}
</pre>

<DT><span class="strong">OPEN_HALFSPACE_LT</span>
<DD>
<pre>
⊢ ∀a b. open {x | a * x < b}
</pre>

<DT><span class="strong">OPEN_IMP_INFINITE</span>
<DD>
<pre>
⊢ ∀s. open s ⇒ (s = ∅) ∨ INFINITE s
</pre>

<DT><span class="strong">OPEN_IMP_LOCALLY_COMPACT</span>
<DD>
<pre>
⊢ ∀s. open s ⇒ locally compact s
</pre>

<DT><span class="strong">OPEN_IN</span>
<DD>
<pre>
⊢ ∀s. open s ⇔ open_in euclidean s
</pre>

<DT><span class="strong">OPEN_INTER</span>
<DD>
<pre>
⊢ ∀s t. open s ∧ open t ⇒ open (s ∩ t)
</pre>

<DT><span class="strong">OPEN_INTERIOR</span>
<DD>
<pre>
⊢ ∀s. open (interior s)
</pre>

<DT><span class="strong">OPEN_INTERVAL</span>
<DD>
<pre>
⊢ ∀a b. open (interval (a,b))
</pre>

<DT><span class="strong">OPEN_INTERVAL_EQ</span>
<DD>
<pre>
⊢ (∀a b. open (interval [(a,b)]) ⇔ (interval [(a,b)] = ∅)) ∧
  ∀a b. open (interval (a,b))
</pre>

<DT><span class="strong">OPEN_INTERVAL_LEFT</span>
<DD>
<pre>
⊢ ∀b. open {x | x < b}
</pre>

<DT><span class="strong">OPEN_INTERVAL_LEMMA</span>
<DD>
<pre>
⊢ ∀a b x. a < x ∧ x < b ⇒ ∃d. 0 < d ∧ ∀x'. abs (x' − x) < d ⇒ a < x' ∧ x' < b
</pre>

<DT><span class="strong">OPEN_INTERVAL_LOWERBOUND</span>
<DD>
<pre>
⊢ ∀a b. a < b ⇒ (interval_lowerbound (interval (a,b)) = a)
</pre>

<DT><span class="strong">OPEN_INTERVAL_MIDPOINT</span>
<DD>
<pre>
⊢ ∀a b. interval (a,b) ≠ ∅ ⇒ 2⁻¹ * (a + b) ∈ interval (a,b)
</pre>

<DT><span class="strong">OPEN_INTERVAL_RIGHT</span>
<DD>
<pre>
⊢ ∀a. open {x | a < x}
</pre>

<DT><span class="strong">OPEN_INTERVAL_UPPERBOUND</span>
<DD>
<pre>
⊢ ∀a b. a < b ⇒ (interval_upperbound (interval (a,b)) = b)
</pre>

<DT><span class="strong">OPEN_INTER_CLOSURE_EQ_EMPTY</span>
<DD>
<pre>
⊢ ∀s t. open s ⇒ ((s ∩ closure t = ∅) ⇔ (s ∩ t = ∅))
</pre>

<DT><span class="strong">OPEN_INTER_CLOSURE_SUBSET</span>
<DD>
<pre>
⊢ ∀s t. open s ⇒ s ∩ closure t ⊆ closure (s ∩ t)
</pre>

<DT><span class="strong">OPEN_IN_CONNECTED_COMPONENT</span>
<DD>
<pre>
⊢ ∀s x.
    FINITE {connected_component s x | x | x ∈ s} ⇒
    open_in (subtopology euclidean s) (connected_component s x)
</pre>

<DT><span class="strong">OPEN_IN_CONTAINS_BALL</span>
<DD>
<pre>
⊢ ∀s t.
    open_in (subtopology euclidean t) s ⇔
    s ⊆ t ∧ ∀x. x ∈ s ⇒ ∃e. 0 < e ∧ ball (x,e) ∩ t ⊆ s
</pre>

<DT><span class="strong">OPEN_IN_CONTAINS_CBALL</span>
<DD>
<pre>
⊢ ∀s t.
    open_in (subtopology euclidean t) s ⇔
    s ⊆ t ∧ ∀x. x ∈ s ⇒ ∃e. 0 < e ∧ cball (x,e) ∩ t ⊆ s
</pre>

<DT><span class="strong">OPEN_IN_DELETE</span>
<DD>
<pre>
⊢ ∀u s a.
    open_in (subtopology euclidean u) s ⇒
    open_in (subtopology euclidean u) (s DELETE a)
</pre>

<DT><span class="strong">OPEN_IN_INTER_OPEN</span>
<DD>
<pre>
⊢ ∀s t u.
    open_in (subtopology euclidean u) s ∧ open t ⇒
    open_in (subtopology euclidean u) (s ∩ t)
</pre>

<DT><span class="strong">OPEN_IN_LOCALLY_COMPACT</span>
<DD>
<pre>
⊢ ∀s t.
    locally compact s ⇒
    (open_in (subtopology euclidean s) t ⇔
     t ⊆ s ∧ ∀k. compact k ∧ k ⊆ s ⇒ open_in (subtopology euclidean k) (k ∩ t))
</pre>

<DT><span class="strong">OPEN_IN_OPEN</span>
<DD>
<pre>
⊢ ∀s u. open_in (subtopology euclidean u) s ⇔ ∃t. open t ∧ (s = u ∩ t)
</pre>

<DT><span class="strong">OPEN_IN_OPEN_EQ</span>
<DD>
<pre>
⊢ ∀s t. open s ⇒ (open_in (subtopology euclidean s) t ⇔ open t ∧ t ⊆ s)
</pre>

<DT><span class="strong">OPEN_IN_OPEN_INTER</span>
<DD>
<pre>
⊢ ∀u s. open s ⇒ open_in (subtopology euclidean u) (u ∩ s)
</pre>

<DT><span class="strong">OPEN_IN_OPEN_TRANS</span>
<DD>
<pre>
⊢ ∀s t. open_in (subtopology euclidean t) s ∧ open t ⇒ open s
</pre>

<DT><span class="strong">OPEN_IN_REFL</span>
<DD>
<pre>
⊢ ∀s. open_in (subtopology euclidean s) s
</pre>

<DT><span class="strong">OPEN_IN_SING</span>
<DD>
<pre>
⊢ ∀s a. open_in (subtopology euclidean s) {a} ⇔ a ∈ s ∧ ¬(a limit_point_of s)
</pre>

<DT><span class="strong">OPEN_IN_SUBSET_TRANS</span>
<DD>
<pre>
⊢ ∀s t u.
    open_in (subtopology euclidean u) s ∧ s ⊆ t ∧ t ⊆ u ⇒
    open_in (subtopology euclidean t) s
</pre>

<DT><span class="strong">OPEN_IN_SUBTOPOLOGY_INTER_SUBSET</span>
<DD>
<pre>
⊢ ∀s u v.
    open_in (subtopology euclidean u) (u ∩ s) ∧ v ⊆ u ⇒
    open_in (subtopology euclidean v) (v ∩ s)
</pre>

<DT><span class="strong">OPEN_IN_TRANS</span>
<DD>
<pre>
⊢ ∀s t u.
    open_in (subtopology euclidean t) s ∧ open_in (subtopology euclidean u) t ⇒
    open_in (subtopology euclidean u) s
</pre>

<DT><span class="strong">OPEN_IN_TRANS_EQ</span>
<DD>
<pre>
⊢ ∀s t.
    (∀u. open_in (subtopology euclidean t) u ⇒
         open_in (subtopology euclidean s) t) ⇔
    open_in (subtopology euclidean s) t
</pre>

<DT><span class="strong">OPEN_MAP_CLOSED_SUPERSET_PREIMAGE</span>
<DD>
<pre>
⊢ ∀f s t u w.
    (∀k. open_in (subtopology euclidean s) k ⇒
         open_in (subtopology euclidean t) (IMAGE f k)) ∧
    closed_in (subtopology euclidean s) u ∧ w ⊆ t ∧ {x | x ∈ s ∧ f x ∈ w} ⊆ u ⇒
    ∃v. closed_in (subtopology euclidean t) v ∧ w ⊆ v ∧
        {x | x ∈ s ∧ f x ∈ v} ⊆ u
</pre>

<DT><span class="strong">OPEN_MAP_CLOSED_SUPERSET_PREIMAGE_EQ</span>
<DD>
<pre>
⊢ ∀f s t.
    IMAGE f s ⊆ t ⇒
    ((∀k. open_in (subtopology euclidean s) k ⇒
          open_in (subtopology euclidean t) (IMAGE f k)) ⇔
     ∀u w.
       closed_in (subtopology euclidean s) u ∧ w ⊆ t ∧
       {x | x ∈ s ∧ f x ∈ w} ⊆ u ⇒
       ∃v. closed_in (subtopology euclidean t) v ∧ w ⊆ v ∧
           {x | x ∈ s ∧ f x ∈ v} ⊆ u)
</pre>

<DT><span class="strong">OPEN_MAP_FROM_COMPOSITION_INJECTIVE</span>
<DD>
<pre>
⊢ ∀f g s t u.
    IMAGE f s ⊆ t ∧ IMAGE g t ⊆ u ∧ g continuous_on t ∧
    (∀x y. x ∈ t ∧ y ∈ t ∧ (g x = g y) ⇒ (x = y)) ∧
    (∀k. open_in (subtopology euclidean s) k ⇒
         open_in (subtopology euclidean u) (IMAGE (g ∘ f) k)) ⇒
    ∀k. open_in (subtopology euclidean s) k ⇒
        open_in (subtopology euclidean t) (IMAGE f k)
</pre>

<DT><span class="strong">OPEN_MAP_FROM_COMPOSITION_SURJECTIVE</span>
<DD>
<pre>
⊢ ∀f g s t u.
    f continuous_on s ∧ (IMAGE f s = t) ∧ IMAGE g t ⊆ u ∧
    (∀k. open_in (subtopology euclidean s) k ⇒
         open_in (subtopology euclidean u) (IMAGE (g ∘ f) k)) ⇒
    ∀k. open_in (subtopology euclidean t) k ⇒
        open_in (subtopology euclidean u) (IMAGE g k)
</pre>

<DT><span class="strong">OPEN_MAP_IFF_LOWER_HEMICONTINUOUS_PREIMAGE</span>
<DD>
<pre>
⊢ ∀f s t.
    IMAGE f s ⊆ t ⇒
    ((∀u. open_in (subtopology euclidean s) u ⇒
          open_in (subtopology euclidean t) (IMAGE f u)) ⇔
     ∀u. closed_in (subtopology euclidean s) u ⇒
         closed_in (subtopology euclidean t)
           {y | y ∈ t ∧ {x | x ∈ s ∧ (f x = y)} ⊆ u})
</pre>

<DT><span class="strong">OPEN_MAP_IMP_CLOSED_MAP</span>
<DD>
<pre>
⊢ ∀f s t.
    (IMAGE f s = t) ∧
    (∀u. open_in (subtopology euclidean s) u ⇒
         open_in (subtopology euclidean t) (IMAGE f u)) ∧
    (∀u. closed_in (subtopology euclidean s) u ⇒
         closed_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ IMAGE f u}) ⇒
    ∀u. closed_in (subtopology euclidean s) u ⇒
        closed_in (subtopology euclidean t) (IMAGE f u)
</pre>

<DT><span class="strong">OPEN_MAP_IMP_QUOTIENT_MAP</span>
<DD>
<pre>
⊢ ∀f s.
    f continuous_on s ∧
    (∀t. open_in (subtopology euclidean s) t ⇒
         open_in (subtopology euclidean (IMAGE f s)) (IMAGE f t)) ⇒
    ∀t. t ⊆ IMAGE f s ⇒
        (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ t} ⇔
         open_in (subtopology euclidean (IMAGE f s)) t)
</pre>

<DT><span class="strong">OPEN_MAP_INTERIORS</span>
<DD>
<pre>
⊢ ∀f. (∀s. open s ⇒ open (IMAGE f s)) ⇔
      ∀s. IMAGE f (interior s) ⊆ interior (IMAGE f s)
</pre>

<DT><span class="strong">OPEN_MAP_RESTRICT</span>
<DD>
<pre>
⊢ ∀f s t t'.
    (∀u. open_in (subtopology euclidean s) u ⇒
         open_in (subtopology euclidean t) (IMAGE f u)) ∧ t' ⊆ t ⇒
    ∀u. open_in (subtopology euclidean {x | x ∈ s ∧ f x ∈ t'}) u ⇒
        open_in (subtopology euclidean t') (IMAGE f u)
</pre>

<DT><span class="strong">OPEN_NEGATIONS</span>
<DD>
<pre>
⊢ ∀s. open s ⇒ open (IMAGE (λx. -x) s)
</pre>

<DT><span class="strong">OPEN_OPEN_IN_TRANS</span>
<DD>
<pre>
⊢ ∀s t. open s ∧ open t ∧ t ⊆ s ⇒ open_in (subtopology euclidean s) t
</pre>

<DT><span class="strong">OPEN_POSITIVE_MULTIPLES</span>
<DD>
<pre>
⊢ ∀s. open s ⇒ open {c * x | 0 < c ∧ x ∈ s}
</pre>

<DT><span class="strong">OPEN_POSITIVE_ORTHANT</span>
<DD>
<pre>
⊢ open {x | 0 < x}
</pre>

<DT><span class="strong">OPEN_SCALING</span>
<DD>
<pre>
⊢ ∀s c. c ≠ 0 ∧ open s ⇒ open (IMAGE (λx. c * x) s)
</pre>

<DT><span class="strong">OPEN_SEGMENT</span>
<DD>
<pre>
⊢ ∀a b. open (segment (a,b))
</pre>

<DT><span class="strong">OPEN_SEGMENT_ALT</span>
<DD>
<pre>
⊢ ∀a b. a ≠ b ⇒ (segment (a,b) = {(1 − u) * a + u * b | 0 < u ∧ u < 1})
</pre>

<DT><span class="strong">OPEN_SEGMENT_LINEAR_IMAGE</span>
<DD>
<pre>
⊢ ∀f a b.
    linear f ∧ (∀x y. (f x = f y) ⇒ (x = y)) ⇒
    (segment (f a,f b) = IMAGE f (segment (a,b)))
</pre>

<DT><span class="strong">OPEN_SUBSET</span>
<DD>
<pre>
⊢ ∀s t. s ⊆ t ∧ open s ⇒ open_in (subtopology euclidean t) s
</pre>

<DT><span class="strong">OPEN_SUBSET_INTERIOR</span>
<DD>
<pre>
⊢ ∀s t. open s ⇒ (s ⊆ interior t ⇔ s ⊆ t)
</pre>

<DT><span class="strong">OPEN_SUB_OPEN</span>
<DD>
<pre>
⊢ ∀s. open s ⇔ ∀x. x ∈ s ⇒ ∃t. open t ∧ x ∈ t ∧ t ⊆ s
</pre>

<DT><span class="strong">OPEN_SUMS</span>
<DD>
<pre>
⊢ ∀s t. open s ∨ open t ⇒ open {x + y | x ∈ s ∧ y ∈ t}
</pre>

<DT><span class="strong">OPEN_SURJECTIVE_LINEAR_IMAGE</span>
<DD>
<pre>
⊢ ∀f. linear f ∧ (∀y. ∃x. f x = y) ⇒ ∀s. open s ⇒ open (IMAGE f s)
</pre>

<DT><span class="strong">OPEN_TRANSLATION</span>
<DD>
<pre>
⊢ ∀s a. open s ⇒ open (IMAGE (λx. a + x) s)
</pre>

<DT><span class="strong">OPEN_TRANSLATION_EQ</span>
<DD>
<pre>
⊢ ∀a s. open (IMAGE (λx. a + x) s) ⇔ open s
</pre>

<DT><span class="strong">OPEN_UNION</span>
<DD>
<pre>
⊢ ∀s t. open s ∧ open t ⇒ open (s ∪ t)
</pre>

<DT><span class="strong">OPEN_UNION_COMPACT_SUBSETS</span>
<DD>
<pre>
⊢ ∀s. open s ⇒
      ∃f. (∀n. compact (f n)) ∧ (∀n. f n ⊆ s) ∧
          (∀n. f n ⊆ interior (f (n + 1))) ∧
          (BIGUNION {f n | n ∈ 𝕌(:num)} = s) ∧
          ∀k. compact k ∧ k ⊆ s ⇒ ∃N. ∀n. n ≥ N ⇒ k ⊆ f n
</pre>

<DT><span class="strong">OPEN_UNIV</span>
<DD>
<pre>
⊢ open 𝕌(:real)
</pre>

<DT><span class="strong">PAIRWISE_DISJOINT_COMPONENTS</span>
<DD>
<pre>
⊢ ∀u. pairwise DISJOINT (components u)
</pre>

<DT><span class="strong">PARTIAL_SUMS_COMPONENT_LE_INFSUM</span>
<DD>
<pre>
⊢ ∀f s n.
    (∀i. i ∈ s ⇒ 0 ≤ f i) ∧ summable s f ⇒ sum (s ∩ {0 .. n}) f ≤ suminf s f
</pre>

<DT><span class="strong">PARTIAL_SUMS_DROP_LE_INFSUM</span>
<DD>
<pre>
⊢ ∀f s n.
    (∀i. i ∈ s ⇒ 0 ≤ f i) ∧ summable s f ⇒ sum (s ∩ {0 .. n}) f ≤ suminf s f
</pre>

<DT><span class="strong">PASTING_LEMMA</span>
<DD>
<pre>
⊢ ∀f g t s k.
    (∀i. i ∈ k ⇒
         open_in (subtopology euclidean s) (t i) ∧ f i continuous_on t i) ∧
    (∀i j x. i ∈ k ∧ j ∈ k ∧ x ∈ s ∩ t i ∩ t j ⇒ (f i x = f j x)) ∧
    (∀x. x ∈ s ⇒ ∃j. j ∈ k ∧ x ∈ t j ∧ (g x = f j x)) ⇒
    g continuous_on s
</pre>

<DT><span class="strong">PASTING_LEMMA_CLOSED</span>
<DD>
<pre>
⊢ ∀f g t s k.
    FINITE k ∧
    (∀i. i ∈ k ⇒
         closed_in (subtopology euclidean s) (t i) ∧ f i continuous_on t i) ∧
    (∀i j x. i ∈ k ∧ j ∈ k ∧ x ∈ s ∩ t i ∩ t j ⇒ (f i x = f j x)) ∧
    (∀x. x ∈ s ⇒ ∃j. j ∈ k ∧ x ∈ t j ∧ (g x = f j x)) ⇒
    g continuous_on s
</pre>

<DT><span class="strong">PASTING_LEMMA_EXISTS</span>
<DD>
<pre>
⊢ ∀f t s k.
    s ⊆ BIGUNION {t i | i ∈ k} ∧
    (∀i. i ∈ k ⇒
         open_in (subtopology euclidean s) (t i) ∧ f i continuous_on t i) ∧
    (∀i j x. i ∈ k ∧ j ∈ k ∧ x ∈ s ∩ t i ∩ t j ⇒ (f i x = f j x)) ⇒
    ∃g. g continuous_on s ∧ ∀x i. i ∈ k ∧ x ∈ s ∩ t i ⇒ (g x = f i x)
</pre>

<DT><span class="strong">PASTING_LEMMA_EXISTS_CLOSED</span>
<DD>
<pre>
⊢ ∀f t s k.
    FINITE k ∧ s ⊆ BIGUNION {t i | i ∈ k} ∧
    (∀i. i ∈ k ⇒
         closed_in (subtopology euclidean s) (t i) ∧ f i continuous_on t i) ∧
    (∀i j x. i ∈ k ∧ j ∈ k ∧ x ∈ s ∩ t i ∩ t j ⇒ (f i x = f j x)) ⇒
    ∃g. g continuous_on s ∧ ∀x i. i ∈ k ∧ x ∈ s ∩ t i ⇒ (g x = f i x)
</pre>

<DT><span class="strong">PERMUTES_IMAGE</span>
<DD>
<pre>
⊢ ∀p s. p permutes s ⇒ (IMAGE p s = s)
</pre>

<DT><span class="strong">PERMUTES_INJECTIVE</span>
<DD>
<pre>
⊢ ∀p s. p permutes s ⇒ ∀x y. (p x = p y) ⇔ (x = y)
</pre>

<DT><span class="strong">PROPER_MAP</span>
<DD>
<pre>
⊢ ∀f s t.
    IMAGE f s ⊆ t ⇒
    ((∀k. k ⊆ t ∧ compact k ⇒ compact {x | x ∈ s ∧ f x ∈ k}) ⇔
     (∀k. closed_in (subtopology euclidean s) k ⇒
          closed_in (subtopology euclidean t) (IMAGE f k)) ∧
     ∀a. a ∈ t ⇒ compact {x | x ∈ s ∧ (f x = a)})
</pre>

<DT><span class="strong">PROPER_MAP_COMPOSE</span>
<DD>
<pre>
⊢ ∀f g s t u.
    IMAGE f s ⊆ t ∧ (∀k. k ⊆ t ∧ compact k ⇒ compact {x | x ∈ s ∧ f x ∈ k}) ∧
    (∀k. k ⊆ u ∧ compact k ⇒ compact {x | x ∈ t ∧ g x ∈ k}) ⇒
    ∀k. k ⊆ u ∧ compact k ⇒ compact {x | x ∈ s ∧ (g ∘ f) x ∈ k}
</pre>

<DT><span class="strong">PROPER_MAP_FROM_COMPACT</span>
<DD>
<pre>
⊢ ∀f s k.
    f continuous_on s ∧ IMAGE f s ⊆ t ∧ compact s ∧
    closed_in (subtopology euclidean t) k ⇒
    compact {x | x ∈ s ∧ f x ∈ k}
</pre>

<DT><span class="strong">PROPER_MAP_FROM_COMPOSITION_LEFT</span>
<DD>
<pre>
⊢ ∀f g s t u.
    f continuous_on s ∧ (IMAGE f s = t) ∧ g continuous_on t ∧ IMAGE g t ⊆ u ∧
    (∀k. k ⊆ u ∧ compact k ⇒ compact {x | x ∈ s ∧ (g ∘ f) x ∈ k}) ⇒
    ∀k. k ⊆ u ∧ compact k ⇒ compact {x | x ∈ t ∧ g x ∈ k}
</pre>

<DT><span class="strong">PROPER_MAP_FROM_COMPOSITION_RIGHT</span>
<DD>
<pre>
⊢ ∀f g s t u.
    f continuous_on s ∧ IMAGE f s ⊆ t ∧ g continuous_on t ∧ IMAGE g t ⊆ u ∧
    (∀k. k ⊆ u ∧ compact k ⇒ compact {x | x ∈ s ∧ (g ∘ f) x ∈ k}) ⇒
    ∀k. k ⊆ t ∧ compact k ⇒ compact {x | x ∈ s ∧ f x ∈ k}
</pre>

<DT><span class="strong">QUASICOMPACT_OPEN_CLOSED</span>
<DD>
<pre>
⊢ ∀f s t.
    IMAGE f s ⊆ t ⇒
    ((∀u. u ⊆ t ⇒
          open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇒
          open_in (subtopology euclidean t) u) ⇔
     ∀u. u ⊆ t ⇒
         closed_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇒
         closed_in (subtopology euclidean t) u)
</pre>

<DT><span class="strong">QUOTIENT_MAP_CLOSED_MAP_EQ</span>
<DD>
<pre>
⊢ ∀f s t.
    IMAGE f s ⊆ t ∧
    (∀u. u ⊆ t ⇒
         (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇔
          open_in (subtopology euclidean t) u)) ⇒
    ((∀k. closed_in (subtopology euclidean s) k ⇒
          closed_in (subtopology euclidean t) (IMAGE f k)) ⇔
     ∀k. closed_in (subtopology euclidean s) k ⇒
         closed_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ IMAGE f k})
</pre>

<DT><span class="strong">QUOTIENT_MAP_COMPOSE</span>
<DD>
<pre>
⊢ ∀f g s t u.
    IMAGE f s ⊆ t ∧
    (∀v. v ⊆ t ⇒
         (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ v} ⇔
          open_in (subtopology euclidean t) v)) ∧
    (∀v. v ⊆ u ⇒
         (open_in (subtopology euclidean t) {x | x ∈ t ∧ g x ∈ v} ⇔
          open_in (subtopology euclidean u) v)) ⇒
    ∀v. v ⊆ u ⇒
        (open_in (subtopology euclidean s) {x | x ∈ s ∧ (g ∘ f) x ∈ v} ⇔
         open_in (subtopology euclidean u) v)
</pre>

<DT><span class="strong">QUOTIENT_MAP_FROM_COMPOSITION</span>
<DD>
<pre>
⊢ ∀f g s t u.
    f continuous_on s ∧ IMAGE f s ⊆ t ∧ g continuous_on t ∧ IMAGE g t ⊆ u ∧
    (∀v. v ⊆ u ⇒
         (open_in (subtopology euclidean s) {x | x ∈ s ∧ (g ∘ f) x ∈ v} ⇔
          open_in (subtopology euclidean u) v)) ⇒
    ∀v. v ⊆ u ⇒
        (open_in (subtopology euclidean t) {x | x ∈ t ∧ g x ∈ v} ⇔
         open_in (subtopology euclidean u) v)
</pre>

<DT><span class="strong">QUOTIENT_MAP_FROM_SUBSET</span>
<DD>
<pre>
⊢ ∀f s t u.
    f continuous_on t ∧ IMAGE f t ⊆ u ∧ s ⊆ t ∧ (IMAGE f s = u) ∧
    (∀v. v ⊆ u ⇒
         (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ v} ⇔
          open_in (subtopology euclidean u) v)) ⇒
    ∀v. v ⊆ u ⇒
        (open_in (subtopology euclidean t) {x | x ∈ t ∧ f x ∈ v} ⇔
         open_in (subtopology euclidean u) v)
</pre>

<DT><span class="strong">QUOTIENT_MAP_IMP_CONTINUOUS_CLOSED</span>
<DD>
<pre>
⊢ ∀f s t.
    IMAGE f s ⊆ t ∧
    (∀u. u ⊆ t ⇒
         (closed_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇔
          closed_in (subtopology euclidean t) u)) ⇒
    f continuous_on s
</pre>

<DT><span class="strong">QUOTIENT_MAP_IMP_CONTINUOUS_OPEN</span>
<DD>
<pre>
⊢ ∀f s t.
    IMAGE f s ⊆ t ∧
    (∀u. u ⊆ t ⇒
         (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇔
          open_in (subtopology euclidean t) u)) ⇒
    f continuous_on s
</pre>

<DT><span class="strong">QUOTIENT_MAP_OPEN_CLOSED</span>
<DD>
<pre>
⊢ ∀f s t.
    IMAGE f s ⊆ t ⇒
    ((∀u. u ⊆ t ⇒
          (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇔
           open_in (subtopology euclidean t) u)) ⇔
     ∀u. u ⊆ t ⇒
         (closed_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇔
          closed_in (subtopology euclidean t) u))
</pre>

<DT><span class="strong">QUOTIENT_MAP_OPEN_MAP_EQ</span>
<DD>
<pre>
⊢ ∀f s t.
    IMAGE f s ⊆ t ∧
    (∀u. u ⊆ t ⇒
         (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇔
          open_in (subtopology euclidean t) u)) ⇒
    ((∀k. open_in (subtopology euclidean s) k ⇒
          open_in (subtopology euclidean t) (IMAGE f k)) ⇔
     ∀k. open_in (subtopology euclidean s) k ⇒
         open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ IMAGE f k})
</pre>

<DT><span class="strong">QUOTIENT_MAP_RESTRICT</span>
<DD>
<pre>
⊢ ∀f s t c.
    IMAGE f s ⊆ t ∧
    (∀u. u ⊆ t ⇒
         (open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∈ u} ⇔
          open_in (subtopology euclidean t) u)) ∧
    (open_in (subtopology euclidean t) c ∨
     closed_in (subtopology euclidean t) c) ⇒
    ∀u. u ⊆ c ⇒
        (open_in (subtopology euclidean {x | x ∈ s ∧ f x ∈ c})
           {x | x ∈ {x | x ∈ s ∧ f x ∈ c} ∧ f x ∈ u} ⇔
         open_in (subtopology euclidean c) u)
</pre>

<DT><span class="strong">REAL_AFFINITY_EQ</span>
<DD>
<pre>
⊢ ∀m c x y. m ≠ 0 ⇒ ((m * x + c = y) ⇔ (x = m⁻¹ * y + -(c / m)))
</pre>

<DT><span class="strong">REAL_AFFINITY_LE</span>
<DD>
<pre>
⊢ ∀m c x y. 0 < m ⇒ (m * x + c ≤ y ⇔ x ≤ m⁻¹ * y + -(c / m))
</pre>

<DT><span class="strong">REAL_AFFINITY_LT</span>
<DD>
<pre>
⊢ ∀m c x y. 0 < m ⇒ (m * x + c < y ⇔ x < m⁻¹ * y + -(c / m))
</pre>

<DT><span class="strong">REAL_ARCH_RDIV_EQ_0</span>
<DD>
<pre>
⊢ ∀x c. 0 ≤ x ∧ 0 ≤ c ∧ (∀m. 0 < m ⇒ &m * x ≤ c) ⇒ (x = 0)
</pre>

<DT><span class="strong">REAL_CHOOSE_DIST</span>
<DD>
<pre>
⊢ ∀x e. 0 ≤ e ⇒ ∃y. dist (x,y) = e
</pre>

<DT><span class="strong">REAL_CHOOSE_SIZE</span>
<DD>
<pre>
⊢ ∀c. 0 ≤ c ⇒ ∃x. abs x = c
</pre>

<DT><span class="strong">REAL_CONVEX_BOUND_LE</span>
<DD>
<pre>
⊢ ∀x y a u v. x ≤ a ∧ y ≤ a ∧ 0 ≤ u ∧ 0 ≤ v ∧ (u + v = 1) ⇒ u * x + v * y ≤ a
</pre>

<DT><span class="strong">REAL_EQ_AFFINITY</span>
<DD>
<pre>
⊢ ∀m c x y. m ≠ 0 ⇒ ((y = m * x + c) ⇔ (m⁻¹ * y + -(c / m) = x))
</pre>

<DT><span class="strong">REAL_EQ_LINV</span>
<DD>
<pre>
⊢ ∀x. (-x = x) ⇔ (x = 0)
</pre>

<DT><span class="strong">REAL_EQ_RINV</span>
<DD>
<pre>
⊢ ∀x. (x = -x) ⇔ (x = 0)
</pre>

<DT><span class="strong">REAL_HAUSDIST_LE</span>
<DD>
<pre>
⊢ ∀s t b.
    s ≠ ∅ ∧ t ≠ ∅ ∧ (∀x. x ∈ s ⇒ setdist ({x},t) ≤ b) ∧
    (∀y. y ∈ t ⇒ setdist ({y},s) ≤ b) ⇒
    hausdist (s,t) ≤ b
</pre>

<DT><span class="strong">REAL_HAUSDIST_LE_EQ</span>
<DD>
<pre>
⊢ ∀s t b.
    s ≠ ∅ ∧ t ≠ ∅ ∧ bounded s ∧ bounded t ⇒
    (hausdist (s,t) ≤ b ⇔
     (∀x. x ∈ s ⇒ setdist ({x},t) ≤ b) ∧ ∀y. y ∈ t ⇒ setdist ({y},s) ≤ b)
</pre>

<DT><span class="strong">REAL_HAUSDIST_LE_SUMS</span>
<DD>
<pre>
⊢ ∀s t b.
    s ≠ ∅ ∧ t ≠ ∅ ∧ s ⊆ {y + z | y ∈ t ∧ z ∈ cball (0,b)} ∧
    t ⊆ {y + z | y ∈ s ∧ z ∈ cball (0,b)} ⇒
    hausdist (s,t) ≤ b
</pre>

<DT><span class="strong">REAL_LE_AFFINITY</span>
<DD>
<pre>
⊢ ∀m c x y. 0 < m ⇒ (y ≤ m * x + c ⇔ m⁻¹ * y + -(c / m) ≤ x)
</pre>

<DT><span class="strong">REAL_LE_HAUSDIST</span>
<DD>
<pre>
⊢ ∀s t a b c z.
    s ≠ ∅ ∧ t ≠ ∅ ∧ (∀x. x ∈ s ⇒ setdist ({x},t) ≤ b) ∧
    (∀y. y ∈ t ⇒ setdist ({y},s) ≤ c) ∧
    (z ∈ s ∧ a ≤ setdist ({z},t) ∨ z ∈ t ∧ a ≤ setdist ({z},s)) ⇒
    a ≤ hausdist (s,t)
</pre>

<DT><span class="strong">REAL_LE_SETDIST</span>
<DD>
<pre>
⊢ ∀s t d.
    s ≠ ∅ ∧ t ≠ ∅ ∧ (∀x y. x ∈ s ∧ y ∈ t ⇒ d ≤ dist (x,y)) ⇒ d ≤ setdist (s,t)
</pre>

<DT><span class="strong">REAL_LE_SETDIST_EQ</span>
<DD>
<pre>
⊢ ∀d s t.
    d ≤ setdist (s,t) ⇔
    (∀x y. x ∈ s ∧ y ∈ t ⇒ d ≤ dist (x,y)) ∧ ((s = ∅) ∨ (t = ∅) ⇒ d ≤ 0)
</pre>

<DT><span class="strong">REAL_LT_AFFINITY</span>
<DD>
<pre>
⊢ ∀m c x y. 0 < m ⇒ (y < m * x + c ⇔ m⁻¹ * y + -(c / m) < x)
</pre>

<DT><span class="strong">REAL_LT_HAUSDIST_POINT_EXISTS</span>
<DD>
<pre>
⊢ ∀s t x d.
    bounded s ∧ bounded t ∧ t ≠ ∅ ∧ hausdist (s,t) < d ∧ x ∈ s ⇒
    ∃y. y ∈ t ∧ dist (x,y) < d
</pre>

<DT><span class="strong">REAL_SETDIST_LT_EXISTS</span>
<DD>
<pre>
⊢ ∀s t b.
    s ≠ ∅ ∧ t ≠ ∅ ∧ setdist (s,t) < b ⇒ ∃x y. x ∈ s ∧ y ∈ t ∧ dist (x,y) < b
</pre>

<DT><span class="strong">REFLECT_INTERVAL</span>
<DD>
<pre>
⊢ (∀a b. IMAGE (λx. -x) (interval [(a,b)]) = interval [(-b,-a)]) ∧
  ∀a b. IMAGE (λx. -x) (interval (a,b)) = interval (-b,-a)
</pre>

<DT><span class="strong">REGULAR_CLOSED_BIGUNION</span>
<DD>
<pre>
⊢ ∀f. FINITE f ∧ (∀t. t ∈ f ⇒ (closure (interior t) = t)) ⇒
      (closure (interior (BIGUNION f)) = BIGUNION f)
</pre>

<DT><span class="strong">REGULAR_CLOSED_UNION</span>
<DD>
<pre>
⊢ ∀s t.
    (closure (interior s) = s) ∧ (closure (interior t) = t) ⇒
    (closure (interior (s ∪ t)) = s ∪ t)
</pre>

<DT><span class="strong">REGULAR_OPEN_INTER</span>
<DD>
<pre>
⊢ ∀s t.
    (interior (closure s) = s) ∧ (interior (closure t) = t) ⇒
    (interior (closure (s ∩ t)) = s ∩ t)
</pre>

<DT><span class="strong">SEGMENT</span>
<DD>
<pre>
⊢ (∀a b.
     segment [(a,b)] = if a ≤ b then interval [(a,b)] else interval [(b,a)]) ∧
  ∀a b. segment (a,b) = if a ≤ b then interval (a,b) else interval (b,a)
</pre>

<DT><span class="strong">SEGMENT_CLOSED_OPEN</span>
<DD>
<pre>
⊢ ∀a b. segment [(a,b)] = segment (a,b) ∪ {a; b}
</pre>

<DT><span class="strong">SEGMENT_OPEN_SUBSET_CLOSED</span>
<DD>
<pre>
⊢ ∀a b. segment (a,b) ⊆ segment [(a,b)]
</pre>

<DT><span class="strong">SEGMENT_REFL</span>
<DD>
<pre>
⊢ (∀a. segment [(a,a)] = {a}) ∧ ∀a. segment (a,a) = ∅
</pre>

<DT><span class="strong">SEGMENT_SCALAR_MULTIPLE</span>
<DD>
<pre>
⊢ (∀a b v. segment [(a * v,b * v)] = {x * v | a ≤ x ∧ x ≤ b ∨ b ≤ x ∧ x ≤ a}) ∧
  ∀a b v.
    v ≠ 0 ⇒ (segment (a * v,b * v) = {x * v | a < x ∧ x < b ∨ b < x ∧ x < a})
</pre>

<DT><span class="strong">SEGMENT_SYM</span>
<DD>
<pre>
⊢ (∀a b. segment [(a,b)] = segment [(b,a)]) ∧
  ∀a b. segment (a,b) = segment (b,a)
</pre>

<DT><span class="strong">SEGMENT_TO_CLOSEST_POINT</span>
<DD>
<pre>
⊢ ∀s a. closed s ∧ s ≠ ∅ ⇒ (segment (a,closest_point s a) ∩ s = ∅)
</pre>

<DT><span class="strong">SEGMENT_TO_POINT_EXISTS</span>
<DD>
<pre>
⊢ ∀s a. closed s ∧ s ≠ ∅ ⇒ ∃b. b ∈ s ∧ (segment (a,b) ∩ s = ∅)
</pre>

<DT><span class="strong">SEGMENT_TRANSLATION</span>
<DD>
<pre>
⊢ (∀c a b. segment [(c + a,c + b)] = IMAGE (λx. c + x) (segment [(a,b)])) ∧
  ∀c a b. segment (c + a,c + b) = IMAGE (λx. c + x) (segment (a,b))
</pre>

<DT><span class="strong">SEPARATE_CLOSED_COMPACT</span>
<DD>
<pre>
⊢ ∀s t.
    closed s ∧ compact t ∧ (s ∩ t = ∅) ⇒
    ∃d. 0 < d ∧ ∀x y. x ∈ s ∧ y ∈ t ⇒ d ≤ dist (x,y)
</pre>

<DT><span class="strong">SEPARATE_COMPACT_CLOSED</span>
<DD>
<pre>
⊢ ∀s t.
    compact s ∧ closed t ∧ (s ∩ t = ∅) ⇒
    ∃d. 0 < d ∧ ∀x y. x ∈ s ∧ y ∈ t ⇒ d ≤ dist (x,y)
</pre>

<DT><span class="strong">SEPARATE_POINT_CLOSED</span>
<DD>
<pre>
⊢ ∀s a. closed s ∧ a ∉ s ⇒ ∃d. 0 < d ∧ ∀x. x ∈ s ⇒ d ≤ dist (a,x)
</pre>

<DT><span class="strong">SEPARATION_CLOSURES</span>
<DD>
<pre>
⊢ ∀s t.
    (s ∩ closure t = ∅) ∧ (t ∩ closure s = ∅) ⇒
    ∃u v. DISJOINT u v ∧ open u ∧ open v ∧ s ⊆ u ∧ t ⊆ v
</pre>

<DT><span class="strong">SEPARATION_HAUSDORFF</span>
<DD>
<pre>
⊢ ∀x y. x ≠ y ⇒ ∃u v. open u ∧ open v ∧ x ∈ u ∧ y ∈ v ∧ (u ∩ v = ∅)
</pre>

<DT><span class="strong">SEPARATION_NORMAL</span>
<DD>
<pre>
⊢ ∀s t.
    closed s ∧ closed t ∧ (s ∩ t = ∅) ⇒
    ∃u v. open u ∧ open v ∧ s ⊆ u ∧ t ⊆ v ∧ (u ∩ v = ∅)
</pre>

<DT><span class="strong">SEPARATION_NORMAL_COMPACT</span>
<DD>
<pre>
⊢ ∀s t.
    compact s ∧ closed t ∧ (s ∩ t = ∅) ⇒
    ∃u v. open u ∧ compact (closure u) ∧ open v ∧ s ⊆ u ∧ t ⊆ v ∧ (u ∩ v = ∅)
</pre>

<DT><span class="strong">SEPARATION_NORMAL_LOCAL</span>
<DD>
<pre>
⊢ ∀s t u.
    closed_in (subtopology euclidean u) s ∧
    closed_in (subtopology euclidean u) t ∧ (s ∩ t = ∅) ⇒
    ∃s' t'.
      open_in (subtopology euclidean u) s' ∧
      open_in (subtopology euclidean u) t' ∧ s ⊆ s' ∧ t ⊆ t' ∧ (s' ∩ t' = ∅)
</pre>

<DT><span class="strong">SEPARATION_T0</span>
<DD>
<pre>
⊢ ∀x y. x ≠ y ⇔ ∃u. open u ∧ (x ∈ u ⇎ y ∈ u)
</pre>

<DT><span class="strong">SEPARATION_T1</span>
<DD>
<pre>
⊢ ∀x y. x ≠ y ⇔ ∃u v. open u ∧ open v ∧ x ∈ u ∧ y ∉ u ∧ x ∉ v ∧ y ∈ v
</pre>

<DT><span class="strong">SEPARATION_T2</span>
<DD>
<pre>
⊢ ∀x y. x ≠ y ⇔ ∃u v. open u ∧ open v ∧ x ∈ u ∧ y ∈ v ∧ (u ∩ v = ∅)
</pre>

<DT><span class="strong">SEQUENCE_CAUCHY_WLOG</span>
<DD>
<pre>
⊢ ∀P s.
    (∀m n. P m ∧ P n ⇒ dist (s m,s n) < e) ⇔
    ∀m n. P m ∧ P n ∧ m ≤ n ⇒ dist (s m,s n) < e
</pre>

<DT><span class="strong">SEQUENCE_INFINITE_LEMMA</span>
<DD>
<pre>
⊢ ∀f l. (∀n. f n ≠ l) ∧ (f --> l) sequentially ⇒ INFINITE {y | (∃n. y = f n)}
</pre>

<DT><span class="strong">SEQUENCE_UNIQUE_LIMPT</span>
<DD>
<pre>
⊢ ∀f l l'.
    (f --> l) sequentially ∧ l' limit_point_of {y | ∃n. y = f n} ⇒ (l' = l)
</pre>

<DT><span class="strong">SEQUENTIALLY</span>
<DD>
<pre>
⊢ ∀m n. netord sequentially m n ⇔ m ≥ n
</pre>

<DT><span class="strong">SEQ_HARMONIC</span>
<DD>
<pre>
⊢ ((λn. (&n)⁻¹) --> 0) sequentially
</pre>

<DT><span class="strong">SEQ_HARMONIC_OFFSET</span>
<DD>
<pre>
⊢ ∀a. ((λn. (&n + a)⁻¹) --> 0) sequentially
</pre>

<DT><span class="strong">SEQ_OFFSET</span>
<DD>
<pre>
⊢ ∀f l k. (f --> l) sequentially ⇒ ((λi. f (i + k)) --> l) sequentially
</pre>

<DT><span class="strong">SEQ_OFFSET_NEG</span>
<DD>
<pre>
⊢ ∀f l k. (f --> l) sequentially ⇒ ((λi. f (i − k)) --> l) sequentially
</pre>

<DT><span class="strong">SEQ_OFFSET_REV</span>
<DD>
<pre>
⊢ ∀f l k. ((λi. f (i + k)) --> l) sequentially ⇒ (f --> l) sequentially
</pre>

<DT><span class="strong">SERIES_0</span>
<DD>
<pre>
⊢ ∀s. ((λn. 0) sums 0) s
</pre>

<DT><span class="strong">SERIES_ABSCONV_IMP_CONV</span>
<DD>
<pre>
⊢ ∀x k. summable k (λn. abs (x n)) ⇒ summable k x
</pre>

<DT><span class="strong">SERIES_ADD</span>
<DD>
<pre>
⊢ ∀x x0 y y0 s.
    (x sums x0) s ∧ (y sums y0) s ⇒ ((λn. x n + y n) sums (x0 + y0)) s
</pre>

<DT><span class="strong">SERIES_BOUND</span>
<DD>
<pre>
⊢ ∀f g s a b.
    (f sums a) s ∧ (g sums b) s ∧ (∀i. i ∈ s ⇒ abs (f i) ≤ g i) ⇒ abs a ≤ b
</pre>

<DT><span class="strong">SERIES_CAUCHY</span>
<DD>
<pre>
⊢ ∀f s.
    (∃l. (f sums l) s) ⇔
    ∀e. 0 < e ⇒ ∃N. ∀m n. m ≥ N ⇒ abs (sum (s ∩ {m .. n}) f) < e
</pre>

<DT><span class="strong">SERIES_CAUCHY_UNIFORM</span>
<DD>
<pre>
⊢ ∀P f k.
    (∃l. ∀e.
       0 < e ⇒ ∃N. ∀n x. N ≤ n ∧ P x ⇒ dist (sum (k ∩ {0 .. n}) (f x),l x) < e) ⇔
    ∀e. 0 < e ⇒ ∃N. ∀m n x. N ≤ m ∧ P x ⇒ abs (sum (k ∩ {m .. n}) (f x)) < e
</pre>

<DT><span class="strong">SERIES_CMUL</span>
<DD>
<pre>
⊢ ∀x x0 c s. (x sums x0) s ⇒ ((λn. c * x n) sums (c * x0)) s
</pre>

<DT><span class="strong">SERIES_COMPARISON</span>
<DD>
<pre>
⊢ ∀f g s.
    (∃l. (g sums l) s) ∧ (∃N. ∀n. n ≥ N ∧ n ∈ s ⇒ abs (f n) ≤ g n) ⇒
    ∃l. (f sums l) s
</pre>

<DT><span class="strong">SERIES_COMPARISON_BOUND</span>
<DD>
<pre>
⊢ ∀f g s a.
    (g sums a) s ∧ (∀i. i ∈ s ⇒ abs (f i) ≤ g i) ⇒
    ∃l. (f sums l) s ∧ abs l ≤ a
</pre>

<DT><span class="strong">SERIES_COMPARISON_UNIFORM</span>
<DD>
<pre>
⊢ ∀f g P s.
    (∃l. (g sums l) s) ∧ (∃N. ∀n x. N ≤ n ∧ n ∈ s ∧ P x ⇒ abs (f x n) ≤ g n) ⇒
    ∃l. ∀e.
      0 < e ⇒ ∃N. ∀n x. N ≤ n ∧ P x ⇒ dist (sum (s ∩ {0 .. n}) (f x),l x) < e
</pre>

<DT><span class="strong">SERIES_COMPONENT</span>
<DD>
<pre>
⊢ ∀f s l. (f sums l) s ⇒ ((λi. f i) sums l) s
</pre>

<DT><span class="strong">SERIES_DIFFS</span>
<DD>
<pre>
⊢ ∀f k. (f --> 0) sequentially ⇒ ((λn. f n − f (n + 1)) sums f k) (from k)
</pre>

<DT><span class="strong">SERIES_DIRICHLET</span>
<DD>
<pre>
⊢ ∀f g N k m.
    bounded {sum {m .. n} f | n ∈ 𝕌(:num)} ∧ (∀n. N ≤ n ⇒ g (n + 1) ≤ g n) ∧
    (g --> 0) sequentially ⇒
    summable (from k) (λn. g n * f n)
</pre>

<DT><span class="strong">SERIES_DIRICHLET_BILINEAR</span>
<DD>
<pre>
⊢ ∀f g h k m p l.
    bilinear h ∧ bounded {sum {m .. n} f | n ∈ 𝕌(:num)} ∧
    summable (from p) (λn. abs (g (n + 1) − g n)) ∧
    ((λn. h (g (n + 1)) (sum {1 .. n} f)) --> l) sequentially ⇒
    summable (from k) (λn. h (g n) (f n))
</pre>

<DT><span class="strong">SERIES_DROP_LE</span>
<DD>
<pre>
⊢ ∀f g s a b. (f sums a) s ∧ (g sums b) s ∧ (∀x. x ∈ s ⇒ f x ≤ g x) ⇒ a ≤ b
</pre>

<DT><span class="strong">SERIES_DROP_POS</span>
<DD>
<pre>
⊢ ∀f s a. (f sums a) s ∧ (∀x. x ∈ s ⇒ 0 ≤ f x) ⇒ 0 ≤ a
</pre>

<DT><span class="strong">SERIES_FINITE</span>
<DD>
<pre>
⊢ ∀f s. FINITE s ⇒ (f sums sum s f) s
</pre>

<DT><span class="strong">SERIES_FINITE_SUPPORT</span>
<DD>
<pre>
⊢ ∀f s k.
    FINITE (s ∩ k) ∧ (∀x. x ∈ k ∧ x ∉ s ⇒ (f x = 0)) ⇒
    (f sums sum (s ∩ k) f) k
</pre>

<DT><span class="strong">SERIES_FROM</span>
<DD>
<pre>
⊢ ∀f l k. (f sums l) (from k) ⇔ ((λn. sum {k .. n} f) --> l) sequentially
</pre>

<DT><span class="strong">SERIES_GOESTOZERO</span>
<DD>
<pre>
⊢ ∀s x.
    summable s x ⇒
    ∀e. 0 < e ⇒ eventually (λn. n ∈ s ⇒ abs (x n) < e) sequentially
</pre>

<DT><span class="strong">SERIES_INJECTIVE_IMAGE</span>
<DD>
<pre>
⊢ ∀x s f l.
    summable (IMAGE f s) (λn. abs (x n)) ∧
    (∀m n. m ∈ s ∧ n ∈ s ∧ (f m = f n) ⇒ (m = n)) ⇒
    ((x ∘ f sums l) s ⇔ (x sums l) (IMAGE f s))
</pre>

<DT><span class="strong">SERIES_INJECTIVE_IMAGE_STRONG</span>
<DD>
<pre>
⊢ ∀x s f.
    summable (IMAGE f s) (λn. abs (x n)) ∧
    (∀m n. m ∈ s ∧ n ∈ s ∧ (f m = f n) ⇒ (m = n)) ⇒
    ((λn. sum (IMAGE f s ∩ {0 .. n}) x − sum (s ∩ {0 .. n}) (x ∘ f)) --> 0)
      sequentially
</pre>

<DT><span class="strong">SERIES_LINEAR</span>
<DD>
<pre>
⊢ ∀f h l s. (f sums l) s ∧ linear h ⇒ ((λn. h (f n)) sums h l) s
</pre>

<DT><span class="strong">SERIES_NEG</span>
<DD>
<pre>
⊢ ∀x x0 s. (x sums x0) s ⇒ ((λn. -x n) sums -x0) s
</pre>

<DT><span class="strong">SERIES_RATIO</span>
<DD>
<pre>
⊢ ∀c a s N.
    c < 1 ∧ (∀n. n ≥ N ⇒ abs (a (SUC n)) ≤ c * abs (a n)) ⇒ ∃l. (a sums l) s
</pre>

<DT><span class="strong">SERIES_REARRANGE</span>
<DD>
<pre>
⊢ ∀x s p l.
    summable s (λn. abs (x n)) ∧ p permutes s ∧ (x sums l) s ⇒
    (x ∘ p sums l) s
</pre>

<DT><span class="strong">SERIES_REARRANGE_EQ</span>
<DD>
<pre>
⊢ ∀x s p l.
    summable s (λn. abs (x n)) ∧ p permutes s ⇒
    ((x ∘ p sums l) s ⇔ (x sums l) s)
</pre>

<DT><span class="strong">SERIES_RESTRICT</span>
<DD>
<pre>
⊢ ∀f k l. ((λn. if n ∈ k then f n else 0) sums l) 𝕌(:num) ⇔ (f sums l) k
</pre>

<DT><span class="strong">SERIES_SUB</span>
<DD>
<pre>
⊢ ∀x x0 y y0 s.
    (x sums x0) s ∧ (y sums y0) s ⇒ ((λn. x n − y n) sums (x0 − y0)) s
</pre>

<DT><span class="strong">SERIES_SUBSET</span>
<DD>
<pre>
⊢ ∀x s t l. s ⊆ t ∧ ((λi. if i ∈ s then x i else 0) sums l) t ⇒ (x sums l) s
</pre>

<DT><span class="strong">SERIES_SUM</span>
<DD>
<pre>
⊢ ∀f l k s.
    FINITE s ∧ s ⊆ k ∧ (∀x. x ∉ s ⇒ (f x = 0)) ∧ (sum s f = l) ⇒ (f sums l) k
</pre>

<DT><span class="strong">SERIES_TERMS_TOZERO</span>
<DD>
<pre>
⊢ ∀f l n. (f sums l) (from n) ⇒ (f --> 0) sequentially
</pre>

<DT><span class="strong">SERIES_TRIVIAL</span>
<DD>
<pre>
⊢ ∀f. (f sums 0) ∅
</pre>

<DT><span class="strong">SERIES_UNIQUE</span>
<DD>
<pre>
⊢ ∀f l l' s. (f sums l) s ∧ (f sums l') s ⇒ (l = l')
</pre>

<DT><span class="strong">SETDIST_BALLS</span>
<DD>
<pre>
⊢ (∀a b r s.
     setdist (ball (a,r),ball (b,s)) =
     if r ≤ 0 ∨ s ≤ 0 then 0 else max 0 (dist (a,b) − (r + s))) ∧
  (∀a b r s.
     setdist (ball (a,r),cball (b,s)) =
     if r ≤ 0 ∨ s < 0 then 0 else max 0 (dist (a,b) − (r + s))) ∧
  (∀a b r s.
     setdist (cball (a,r),ball (b,s)) =
     if r < 0 ∨ s ≤ 0 then 0 else max 0 (dist (a,b) − (r + s))) ∧
  ∀a b r s.
    setdist (cball (a,r),cball (b,s)) =
    if r < 0 ∨ s < 0 then 0 else max 0 (dist (a,b) − (r + s))
</pre>

<DT><span class="strong">SETDIST_CLOSED_COMPACT</span>
<DD>
<pre>
⊢ ∀s t.
    closed s ∧ compact t ∧ s ≠ ∅ ∧ t ≠ ∅ ⇒
    ∃x y. x ∈ s ∧ y ∈ t ∧ (dist (x,y) = setdist (s,t))
</pre>

<DT><span class="strong">SETDIST_CLOSEST_POINT</span>
<DD>
<pre>
⊢ ∀a s. closed s ∧ s ≠ ∅ ⇒ (setdist ({a},s) = dist (a,closest_point s a))
</pre>

<DT><span class="strong">SETDIST_CLOSURE</span>
<DD>
<pre>
⊢ (∀s t. setdist (closure s,t) = setdist (s,t)) ∧
  ∀s t. setdist (s,closure t) = setdist (s,t)
</pre>

<DT><span class="strong">SETDIST_COMPACT_CLOSED</span>
<DD>
<pre>
⊢ ∀s t.
    compact s ∧ closed t ∧ s ≠ ∅ ∧ t ≠ ∅ ⇒
    ∃x y. x ∈ s ∧ y ∈ t ∧ (dist (x,y) = setdist (s,t))
</pre>

<DT><span class="strong">SETDIST_DIFFERENCES</span>
<DD>
<pre>
⊢ ∀s t. setdist (s,t) = setdist ({0},{x − y | x ∈ s ∧ y ∈ t})
</pre>

<DT><span class="strong">SETDIST_EMPTY</span>
<DD>
<pre>
⊢ (∀t. setdist (∅,t) = 0) ∧ ∀s. setdist (s,∅) = 0
</pre>

<DT><span class="strong">SETDIST_EQ_0_BOUNDED</span>
<DD>
<pre>
⊢ ∀s t.
    bounded s ∨ bounded t ⇒
    ((setdist (s,t) = 0) ⇔ (s = ∅) ∨ (t = ∅) ∨ closure s ∩ closure t ≠ ∅)
</pre>

<DT><span class="strong">SETDIST_EQ_0_CLOSED</span>
<DD>
<pre>
⊢ ∀s x. closed s ⇒ ((setdist ({x},s) = 0) ⇔ (s = ∅) ∨ x ∈ s)
</pre>

<DT><span class="strong">SETDIST_EQ_0_CLOSED_COMPACT</span>
<DD>
<pre>
⊢ ∀s t.
    closed s ∧ compact t ⇒
    ((setdist (s,t) = 0) ⇔ (s = ∅) ∨ (t = ∅) ∨ s ∩ t ≠ ∅)
</pre>

<DT><span class="strong">SETDIST_EQ_0_CLOSED_IN</span>
<DD>
<pre>
⊢ ∀u s x.
    closed_in (subtopology euclidean u) s ∧ x ∈ u ⇒
    ((setdist ({x},s) = 0) ⇔ (s = ∅) ∨ x ∈ s)
</pre>

<DT><span class="strong">SETDIST_EQ_0_COMPACT_CLOSED</span>
<DD>
<pre>
⊢ ∀s t.
    compact s ∧ closed t ⇒
    ((setdist (s,t) = 0) ⇔ (s = ∅) ∨ (t = ∅) ∨ s ∩ t ≠ ∅)
</pre>

<DT><span class="strong">SETDIST_EQ_0_SING</span>
<DD>
<pre>
⊢ (∀s x. (setdist ({x},s) = 0) ⇔ (s = ∅) ∨ x ∈ closure s) ∧
  ∀s x. (setdist (s,{x}) = 0) ⇔ (s = ∅) ∨ x ∈ closure s
</pre>

<DT><span class="strong">SETDIST_FRONTIER</span>
<DD>
<pre>
⊢ (∀s t. DISJOINT s t ⇒ (setdist (frontier s,t) = setdist (s,t))) ∧
  ∀s t. DISJOINT s t ⇒ (setdist (s,frontier t) = setdist (s,t))
</pre>

<DT><span class="strong">SETDIST_FRONTIERS</span>
<DD>
<pre>
⊢ ∀s t.
    setdist (s,t) =
    if DISJOINT s t then setdist (frontier s,frontier t) else 0
</pre>

<DT><span class="strong">SETDIST_HAUSDIST_TRIANGLE</span>
<DD>
<pre>
⊢ ∀s t u.
    t ≠ ∅ ∧ bounded t ∧ bounded u ⇒
    setdist (s,u) ≤ setdist (s,t) + hausdist (t,u)
</pre>

<DT><span class="strong">SETDIST_LE_DIST</span>
<DD>
<pre>
⊢ ∀s t x y. x ∈ s ∧ y ∈ t ⇒ setdist (s,t) ≤ dist (x,y)
</pre>

<DT><span class="strong">SETDIST_LE_HAUSDIST</span>
<DD>
<pre>
⊢ ∀s t. bounded s ∧ bounded t ⇒ setdist (s,t) ≤ hausdist (s,t)
</pre>

<DT><span class="strong">SETDIST_LE_SING</span>
<DD>
<pre>
⊢ ∀s t x. x ∈ s ⇒ setdist (s,t) ≤ setdist ({x},t)
</pre>

<DT><span class="strong">SETDIST_LINEAR_IMAGE</span>
<DD>
<pre>
⊢ ∀f s t.
    linear f ∧ (∀x. abs (f x) = abs x) ⇒
    (setdist (IMAGE f s,IMAGE f t) = setdist (s,t))
</pre>

<DT><span class="strong">SETDIST_LIPSCHITZ</span>
<DD>
<pre>
⊢ ∀s t x y. abs (setdist ({x},s) − setdist ({y},s)) ≤ dist (x,y)
</pre>

<DT><span class="strong">SETDIST_POS_LE</span>
<DD>
<pre>
⊢ ∀s t. 0 ≤ setdist (s,t)
</pre>

<DT><span class="strong">SETDIST_REFL</span>
<DD>
<pre>
⊢ ∀s. setdist (s,s) = 0
</pre>

<DT><span class="strong">SETDIST_SINGS</span>
<DD>
<pre>
⊢ ∀x y. setdist ({x},{y}) = dist (x,y)
</pre>

<DT><span class="strong">SETDIST_SING_FRONTIER</span>
<DD>
<pre>
⊢ ∀s x. x ∉ s ⇒ (setdist ({x},frontier s) = setdist ({x},s))
</pre>

<DT><span class="strong">SETDIST_SING_FRONTIER_CASES</span>
<DD>
<pre>
⊢ ∀s x. setdist ({x},s) = if x ∈ s then 0 else setdist ({x},frontier s)
</pre>

<DT><span class="strong">SETDIST_SING_IN_SET</span>
<DD>
<pre>
⊢ ∀x s. x ∈ s ⇒ (setdist ({x},s) = 0)
</pre>

<DT><span class="strong">SETDIST_SING_LE_HAUSDIST</span>
<DD>
<pre>
⊢ ∀s t x. bounded s ∧ bounded t ∧ x ∈ s ⇒ setdist ({x},t) ≤ hausdist (s,t)
</pre>

<DT><span class="strong">SETDIST_SING_TRIANGLE</span>
<DD>
<pre>
⊢ ∀s x y. abs (setdist ({x},s) − setdist ({y},s)) ≤ dist (x,y)
</pre>

<DT><span class="strong">SETDIST_SUBSETS_EQ</span>
<DD>
<pre>
⊢ ∀s t s' t'.
    s' ⊆ s ∧ t' ⊆ t ∧
    (∀x y.
       x ∈ s ∧ y ∈ t ⇒ ∃x' y'. x' ∈ s' ∧ y' ∈ t' ∧ dist (x',y') ≤ dist (x,y)) ⇒
    (setdist (s',t') = setdist (s,t))
</pre>

<DT><span class="strong">SETDIST_SUBSET_LEFT</span>
<DD>
<pre>
⊢ ∀s t u. s ≠ ∅ ∧ s ⊆ t ⇒ setdist (t,u) ≤ setdist (s,u)
</pre>

<DT><span class="strong">SETDIST_SUBSET_RIGHT</span>
<DD>
<pre>
⊢ ∀s t u. t ≠ ∅ ∧ t ⊆ u ⇒ setdist (s,u) ≤ setdist (s,t)
</pre>

<DT><span class="strong">SETDIST_SYM</span>
<DD>
<pre>
⊢ ∀s t. setdist (s,t) = setdist (t,s)
</pre>

<DT><span class="strong">SETDIST_TRANSLATION</span>
<DD>
<pre>
⊢ ∀a s t. setdist (IMAGE (λx. a + x) s,IMAGE (λx. a + x) t) = setdist (s,t)
</pre>

<DT><span class="strong">SETDIST_TRIANGLE</span>
<DD>
<pre>
⊢ ∀s a t. setdist (s,t) ≤ setdist (s,{a}) + setdist ({a},t)
</pre>

<DT><span class="strong">SETDIST_UNIQUE</span>
<DD>
<pre>
⊢ ∀s t a b d.
    a ∈ s ∧ b ∈ t ∧ (dist (a,b) = d) ∧
    (∀x y. x ∈ s ∧ y ∈ t ⇒ dist (a,b) ≤ dist (x,y)) ⇒
    (setdist (s,t) = d)
</pre>

<DT><span class="strong">SETDIST_UNIV</span>
<DD>
<pre>
⊢ (∀s. setdist (s,𝕌(:real)) = 0) ∧ ∀t. setdist (𝕌(:real),t) = 0
</pre>

<DT><span class="strong">SETDIST_ZERO</span>
<DD>
<pre>
⊢ ∀s t. ¬DISJOINT s t ⇒ (setdist (s,t) = 0)
</pre>

<DT><span class="strong">SETDIST_ZERO_STRONG</span>
<DD>
<pre>
⊢ ∀s t. ¬DISJOINT (closure s) (closure t) ⇒ (setdist (s,t) = 0)
</pre>

<DT><span class="strong">SET_DIFF_FRONTIER</span>
<DD>
<pre>
⊢ ∀s. s DIFF frontier s = interior s
</pre>

<DT><span class="strong">SPANNING_SUBSET_INDEPENDENT</span>
<DD>
<pre>
⊢ ∀s t. t ⊆ s ∧ independent s ∧ s ⊆ span t ⇒ (s = t)
</pre>

<DT><span class="strong">SPAN_0</span>
<DD>
<pre>
⊢ 0 ∈ span s
</pre>

<DT><span class="strong">SPAN_ADD</span>
<DD>
<pre>
⊢ ∀x y s. x ∈ span s ∧ y ∈ span s ⇒ x + y ∈ span s
</pre>

<DT><span class="strong">SPAN_ADD_EQ</span>
<DD>
<pre>
⊢ ∀s x y. x ∈ span s ⇒ (x + y ∈ span s ⇔ y ∈ span s)
</pre>

<DT><span class="strong">SPAN_BREAKDOWN</span>
<DD>
<pre>
⊢ ∀b s a. b ∈ s ∧ a ∈ span s ⇒ ∃k. a − k * b ∈ span (s DELETE b)
</pre>

<DT><span class="strong">SPAN_BREAKDOWN_EQ</span>
<DD>
<pre>
⊢ ∀a s. x ∈ span (a INSERT s) ⇔ ∃k. x − k * a ∈ span s
</pre>

<DT><span class="strong">SPAN_CARD_GE_DIM</span>
<DD>
<pre>
⊢ ∀v b. v ⊆ span b ∧ FINITE b ⇒ dim v ≤ CARD b
</pre>

<DT><span class="strong">SPAN_CLAUSES</span>
<DD>
<pre>
⊢ (∀a s. a ∈ s ⇒ a ∈ span s) ∧ 0 ∈ span s ∧
  (∀x y s. x ∈ span s ∧ y ∈ span s ⇒ x + y ∈ span s) ∧
  ∀x c s. x ∈ span s ⇒ c * x ∈ span s
</pre>

<DT><span class="strong">SPAN_EMPTY</span>
<DD>
<pre>
⊢ span ∅ = {0}
</pre>

<DT><span class="strong">SPAN_EQ_SELF</span>
<DD>
<pre>
⊢ ∀s. (span s = s) ⇔ subspace s
</pre>

<DT><span class="strong">SPAN_EXPLICIT</span>
<DD>
<pre>
⊢ ∀p. span p = {y | ∃s u. FINITE s ∧ s ⊆ p ∧ (sum s (λv. u v * v) = y)}
</pre>

<DT><span class="strong">SPAN_INC</span>
<DD>
<pre>
⊢ ∀s. s ⊆ span s
</pre>

<DT><span class="strong">SPAN_INDUCT</span>
<DD>
<pre>
⊢ ∀s h. (∀x. x ∈ s ⇒ x ∈ h) ∧ subspace h ⇒ ∀x. x ∈ span s ⇒ h x
</pre>

<DT><span class="strong">SPAN_INDUCT_ALT</span>
<DD>
<pre>
⊢ ∀s h. h 0 ∧ (∀c x y. x ∈ s ∧ h y ⇒ h (c * x + y)) ⇒ ∀x. x ∈ span s ⇒ h x
</pre>

<DT><span class="strong">SPAN_LINEAR_IMAGE</span>
<DD>
<pre>
⊢ ∀f s. linear f ⇒ (span (IMAGE f s) = IMAGE f (span s))
</pre>

<DT><span class="strong">SPAN_MONO</span>
<DD>
<pre>
⊢ ∀s t. s ⊆ t ⇒ span s ⊆ span t
</pre>

<DT><span class="strong">SPAN_MUL</span>
<DD>
<pre>
⊢ ∀x c s. x ∈ span s ⇒ c * x ∈ span s
</pre>

<DT><span class="strong">SPAN_MUL_EQ</span>
<DD>
<pre>
⊢ ∀x c s. c ≠ 0 ⇒ (c * x ∈ span s ⇔ x ∈ span s)
</pre>

<DT><span class="strong">SPAN_NEG</span>
<DD>
<pre>
⊢ ∀x s. x ∈ span s ⇒ -x ∈ span s
</pre>

<DT><span class="strong">SPAN_NEG_EQ</span>
<DD>
<pre>
⊢ ∀x s. -x ∈ span s ⇔ x ∈ span s
</pre>

<DT><span class="strong">SPAN_SPAN</span>
<DD>
<pre>
⊢ ∀s. span (span s) = span s
</pre>

<DT><span class="strong">SPAN_STDBASIS</span>
<DD>
<pre>
⊢ span {i | 1 ≤ i ∧ i ≤ 1} = 𝕌(:real)
</pre>

<DT><span class="strong">SPAN_SUB</span>
<DD>
<pre>
⊢ ∀x y s. x ∈ span s ∧ y ∈ span s ⇒ x − y ∈ span s
</pre>

<DT><span class="strong">SPAN_SUBSET_SUBSPACE</span>
<DD>
<pre>
⊢ ∀s t. s ⊆ t ∧ subspace t ⇒ span s ⊆ t
</pre>

<DT><span class="strong">SPAN_SUBSPACE</span>
<DD>
<pre>
⊢ ∀b s. b ⊆ s ∧ s ⊆ span b ∧ subspace s ⇒ (span b = s)
</pre>

<DT><span class="strong">SPAN_SUM</span>
<DD>
<pre>
⊢ ∀s f t. FINITE t ∧ (∀x. x ∈ t ⇒ f x ∈ span s) ⇒ sum t f ∈ span s
</pre>

<DT><span class="strong">SPAN_SUPERSET</span>
<DD>
<pre>
⊢ ∀x. x ∈ s ⇒ x ∈ span s
</pre>

<DT><span class="strong">SPAN_TRANS</span>
<DD>
<pre>
⊢ ∀x y s. x ∈ span s ∧ y ∈ span (x INSERT s) ⇒ y ∈ span s
</pre>

<DT><span class="strong">SPAN_UNION</span>
<DD>
<pre>
⊢ ∀s t. span (s ∪ t) = {x + y | x ∈ span s ∧ y ∈ span t}
</pre>

<DT><span class="strong">SPAN_UNION_SUBSET</span>
<DD>
<pre>
⊢ ∀s t. span s ∪ span t ⊆ span (s ∪ t)
</pre>

<DT><span class="strong">SPAN_UNIV</span>
<DD>
<pre>
⊢ span 𝕌(:real) = 𝕌(:real)
</pre>

<DT><span class="strong">SPHERE</span>
<DD>
<pre>
⊢ ∀a r. sphere (a,r) = if r < 0 then ∅ else {a − r; a + r}
</pre>

<DT><span class="strong">SPHERE_EMPTY</span>
<DD>
<pre>
⊢ ∀a r. r < 0 ⇒ (sphere (a,r) = ∅)
</pre>

<DT><span class="strong">SPHERE_EQ_EMPTY</span>
<DD>
<pre>
⊢ ∀a r. (sphere (a,r) = ∅) ⇔ r < 0
</pre>

<DT><span class="strong">SPHERE_EQ_SING</span>
<DD>
<pre>
⊢ ∀a r x. (sphere (a,r) = {x}) ⇔ (x = a) ∧ (r = 0)
</pre>

<DT><span class="strong">SPHERE_LINEAR_IMAGE</span>
<DD>
<pre>
⊢ ∀f x r.
    linear f ∧ (∀y. ∃x. f x = y) ∧ (∀x. abs (f x) = abs x) ⇒
    (sphere (f x,r) = IMAGE f (sphere (x,r)))
</pre>

<DT><span class="strong">SPHERE_SING</span>
<DD>
<pre>
⊢ ∀x e. (e = 0) ⇒ (sphere (x,e) = {x})
</pre>

<DT><span class="strong">SPHERE_SUBSET_CBALL</span>
<DD>
<pre>
⊢ ∀x e. sphere (x,e) ⊆ cball (x,e)
</pre>

<DT><span class="strong">SPHERE_TRANSLATION</span>
<DD>
<pre>
⊢ ∀a x r. sphere (a + x,r) = IMAGE (λy. a + y) (sphere (x,r))
</pre>

<DT><span class="strong">SPHERE_UNION_BALL</span>
<DD>
<pre>
⊢ ∀a r. sphere (a,r) ∪ ball (a,r) = cball (a,r)
</pre>

<DT><span class="strong">SUBORDINATE_PARTITION_OF_UNITY</span>
<DD>
<pre>
⊢ ∀c s.
    s ⊆ BIGUNION c ∧ (∀u. u ∈ c ⇒ open u) ∧
    (∀x. x ∈ s ⇒ ∃v. open v ∧ x ∈ v ∧ FINITE {u | u ∈ c ∧ u ∩ v ≠ ∅}) ⇒
    ∃f. (∀u. u ∈ c ⇒ f u continuous_on s ∧ ∀x. x ∈ s ⇒ 0 ≤ f u x) ∧
        (∀x u. u ∈ c ∧ x ∈ s ∧ x ∉ u ⇒ (f u x = 0)) ∧
        (∀x. x ∈ s ⇒ (sum c (λu. f u x) = 1)) ∧
        ∀x. x ∈ s ⇒
            ∃n. open n ∧ x ∈ n ∧ FINITE {u | u ∈ c ∧ ¬∀x. x ∈ n ⇒ (f u x = 0)}
</pre>

<DT><span class="strong">SUBSET_BALL</span>
<DD>
<pre>
⊢ ∀x d e. d ≤ e ⇒ ball (x,d) ⊆ ball (x,e)
</pre>

<DT><span class="strong">SUBSET_BALLS</span>
<DD>
<pre>
⊢ (∀a a' r r'. ball (a,r) ⊆ ball (a',r') ⇔ dist (a,a') + r ≤ r' ∨ r ≤ 0) ∧
  (∀a a' r r'. ball (a,r) ⊆ cball (a',r') ⇔ dist (a,a') + r ≤ r' ∨ r ≤ 0) ∧
  (∀a a' r r'. cball (a,r) ⊆ ball (a',r') ⇔ dist (a,a') + r < r' ∨ r < 0) ∧
  ∀a a' r r'. cball (a,r) ⊆ cball (a',r') ⇔ dist (a,a') + r ≤ r' ∨ r < 0
</pre>

<DT><span class="strong">SUBSET_CBALL</span>
<DD>
<pre>
⊢ ∀x d e. d ≤ e ⇒ cball (x,d) ⊆ cball (x,e)
</pre>

<DT><span class="strong">SUBSET_CLOSURE</span>
<DD>
<pre>
⊢ ∀s t. s ⊆ t ⇒ closure s ⊆ closure t
</pre>

<DT><span class="strong">SUBSET_INTERIOR</span>
<DD>
<pre>
⊢ ∀s t. s ⊆ t ⇒ interior s ⊆ interior t
</pre>

<DT><span class="strong">SUBSET_INTERIOR_EQ</span>
<DD>
<pre>
⊢ ∀s. s ⊆ interior s ⇔ open s
</pre>

<DT><span class="strong">SUBSET_INTERVAL</span>
<DD>
<pre>
⊢ (interval [(c,d)] ⊆ interval [(a,b)] ⇔ c ≤ d ⇒ a ≤ c ∧ d ≤ b) ∧
  (interval [(c,d)] ⊆ interval (a,b) ⇔ c ≤ d ⇒ a < c ∧ d < b) ∧
  (interval (c,d) ⊆ interval [(a,b)] ⇔ c < d ⇒ a ≤ c ∧ d ≤ b) ∧
  (interval (c,d) ⊆ interval (a,b) ⇔ c < d ⇒ a ≤ c ∧ d ≤ b)
</pre>

<DT><span class="strong">SUBSET_INTERVAL_IMP</span>
<DD>
<pre>
⊢ (a ≤ c ∧ d ≤ b ⇒ interval [(c,d)] ⊆ interval [(a,b)]) ∧
  (a < c ∧ d < b ⇒ interval [(c,d)] ⊆ interval (a,b)) ∧
  (a ≤ c ∧ d ≤ b ⇒ interval (c,d) ⊆ interval [(a,b)]) ∧
  (a ≤ c ∧ d ≤ b ⇒ interval (c,d) ⊆ interval (a,b))
</pre>

<DT><span class="strong">SUBSPACE_0</span>
<DD>
<pre>
⊢ subspace s ⇒ 0 ∈ s
</pre>

<DT><span class="strong">SUBSPACE_ADD</span>
<DD>
<pre>
⊢ ∀x y s. subspace s ∧ x ∈ s ∧ y ∈ s ⇒ x + y ∈ s
</pre>

<DT><span class="strong">SUBSPACE_BIGINTER</span>
<DD>
<pre>
⊢ ∀f. (∀s. s ∈ f ⇒ subspace s) ⇒ subspace (BIGINTER f)
</pre>

<DT><span class="strong">SUBSPACE_BOUNDED_EQ_TRIVIAL</span>
<DD>
<pre>
⊢ ∀s. subspace s ⇒ (bounded s ⇔ (s = {0}))
</pre>

<DT><span class="strong">SUBSPACE_IMP_NONEMPTY</span>
<DD>
<pre>
⊢ ∀s. subspace s ⇒ s ≠ ∅
</pre>

<DT><span class="strong">SUBSPACE_INTER</span>
<DD>
<pre>
⊢ ∀s t. subspace s ∧ subspace t ⇒ subspace (s ∩ t)
</pre>

<DT><span class="strong">SUBSPACE_KERNEL</span>
<DD>
<pre>
⊢ ∀f. linear f ⇒ subspace {x | f x = 0}
</pre>

<DT><span class="strong">SUBSPACE_LINEAR_IMAGE</span>
<DD>
<pre>
⊢ ∀f s. linear f ∧ subspace s ⇒ subspace (IMAGE f s)
</pre>

<DT><span class="strong">SUBSPACE_LINEAR_PREIMAGE</span>
<DD>
<pre>
⊢ ∀f s. linear f ∧ subspace s ⇒ subspace {x | f x ∈ s}
</pre>

<DT><span class="strong">SUBSPACE_MUL</span>
<DD>
<pre>
⊢ ∀x c s. subspace s ∧ x ∈ s ⇒ c * x ∈ s
</pre>

<DT><span class="strong">SUBSPACE_NEG</span>
<DD>
<pre>
⊢ ∀x s. subspace s ∧ x ∈ s ⇒ -x ∈ s
</pre>

<DT><span class="strong">SUBSPACE_SPAN</span>
<DD>
<pre>
⊢ ∀s. subspace (span s)
</pre>

<DT><span class="strong">SUBSPACE_SUB</span>
<DD>
<pre>
⊢ ∀x y s. subspace s ∧ x ∈ s ∧ y ∈ s ⇒ x − y ∈ s
</pre>

<DT><span class="strong">SUBSPACE_SUBSTANDARD</span>
<DD>
<pre>
⊢ subspace {x | x = 0}
</pre>

<DT><span class="strong">SUBSPACE_SUM</span>
<DD>
<pre>
⊢ ∀s f t. subspace s ∧ FINITE t ∧ (∀x. x ∈ t ⇒ f x ∈ s) ⇒ sum t f ∈ s
</pre>

<DT><span class="strong">SUBSPACE_SUMS</span>
<DD>
<pre>
⊢ ∀s t. subspace s ∧ subspace t ⇒ subspace {x + y | x ∈ s ∧ y ∈ t}
</pre>

<DT><span class="strong">SUBSPACE_TRANSLATION_SELF</span>
<DD>
<pre>
⊢ ∀s a. subspace s ∧ a ∈ s ⇒ (IMAGE (λx. a + x) s = s)
</pre>

<DT><span class="strong">SUBSPACE_TRANSLATION_SELF_EQ</span>
<DD>
<pre>
⊢ ∀s a. subspace s ⇒ ((IMAGE (λx. a + x) s = s) ⇔ a ∈ s)
</pre>

<DT><span class="strong">SUBSPACE_TRIVIAL</span>
<DD>
<pre>
⊢ subspace {0}
</pre>

<DT><span class="strong">SUBSPACE_UNION_CHAIN</span>
<DD>
<pre>
⊢ ∀s t. subspace s ∧ subspace t ∧ subspace (s ∪ t) ⇒ s ⊆ t ∨ t ⊆ s
</pre>

<DT><span class="strong">SUBSPACE_UNIV</span>
<DD>
<pre>
⊢ subspace 𝕌(:real)
</pre>

<DT><span class="strong">SUMMABLE_0</span>
<DD>
<pre>
⊢ ∀s. summable s (λn. 0)
</pre>

<DT><span class="strong">SUMMABLE_ADD</span>
<DD>
<pre>
⊢ ∀x y s. summable s x ∧ summable s y ⇒ summable s (λn. x n + y n)
</pre>

<DT><span class="strong">SUMMABLE_BILINEAR_PARTIAL_PRE</span>
<DD>
<pre>
⊢ ∀f g h l k.
    bilinear h ∧ ((λn. h (f (n + 1)) (g n)) --> l) sequentially ∧
    summable (from k) (λn. h (f (n + 1) − f n) (g n)) ⇒
    summable (from k) (λn. h (f n) (g n − g (n − 1)))
</pre>

<DT><span class="strong">SUMMABLE_CAUCHY</span>
<DD>
<pre>
⊢ ∀f s.
    summable s f ⇔
    ∀e. 0 < e ⇒ ∃N. ∀m n. m ≥ N ⇒ abs (sum (s ∩ {m .. n}) f) < e
</pre>

<DT><span class="strong">SUMMABLE_CMUL</span>
<DD>
<pre>
⊢ ∀s x c. summable s x ⇒ summable s (λn. c * x n)
</pre>

<DT><span class="strong">SUMMABLE_COMPARISON</span>
<DD>
<pre>
⊢ ∀f g s.
    summable s g ∧ (∃N. ∀n. n ≥ N ∧ n ∈ s ⇒ abs (f n) ≤ g n) ⇒ summable s f
</pre>

<DT><span class="strong">SUMMABLE_COMPONENT</span>
<DD>
<pre>
⊢ ∀f s. summable s f ⇒ summable s (λi. f i)
</pre>

<DT><span class="strong">SUMMABLE_EQ</span>
<DD>
<pre>
⊢ ∀f g k. (∀x. x ∈ k ⇒ (f x = g x)) ∧ summable k f ⇒ summable k g
</pre>

<DT><span class="strong">SUMMABLE_EQ_COFINITE</span>
<DD>
<pre>
⊢ ∀f s t. FINITE (s DIFF t ∪ (t DIFF s)) ∧ summable s f ⇒ summable t f
</pre>

<DT><span class="strong">SUMMABLE_EQ_EVENTUALLY</span>
<DD>
<pre>
⊢ ∀f g k. (∃N. ∀n. N ≤ n ∧ n ∈ k ⇒ (f n = g n)) ∧ summable k f ⇒ summable k g
</pre>

<DT><span class="strong">SUMMABLE_FROM_ELSEWHERE</span>
<DD>
<pre>
⊢ ∀f m n. summable (from m) f ⇒ summable (from n) f
</pre>

<DT><span class="strong">SUMMABLE_IFF</span>
<DD>
<pre>
⊢ ∀f g k. (∀x. x ∈ k ⇒ (f x = g x)) ⇒ (summable k f ⇔ summable k g)
</pre>

<DT><span class="strong">SUMMABLE_IFF_COFINITE</span>
<DD>
<pre>
⊢ ∀f s t. FINITE (s DIFF t ∪ (t DIFF s)) ⇒ (summable s f ⇔ summable t f)
</pre>

<DT><span class="strong">SUMMABLE_IFF_EVENTUALLY</span>
<DD>
<pre>
⊢ ∀f g k.
    (∃N. ∀n. N ≤ n ∧ n ∈ k ⇒ (f n = g n)) ⇒ (summable k f ⇔ summable k g)
</pre>

<DT><span class="strong">SUMMABLE_IMP_BOUNDED</span>
<DD>
<pre>
⊢ ∀f k. summable k f ⇒ bounded (IMAGE f k)
</pre>

<DT><span class="strong">SUMMABLE_IMP_SUMS_BOUNDED</span>
<DD>
<pre>
⊢ ∀f k. summable (from k) f ⇒ bounded {sum {k .. n} f | n ∈ 𝕌(:num)}
</pre>

<DT><span class="strong">SUMMABLE_IMP_TOZERO</span>
<DD>
<pre>
⊢ ∀f k. summable k f ⇒ ((λn. if n ∈ k then f n else 0) --> 0) sequentially
</pre>

<DT><span class="strong">SUMMABLE_LINEAR</span>
<DD>
<pre>
⊢ ∀f h s. summable s f ∧ linear h ⇒ summable s (λn. h (f n))
</pre>

<DT><span class="strong">SUMMABLE_NEG</span>
<DD>
<pre>
⊢ ∀x s. summable s x ⇒ summable s (λn. -x n)
</pre>

<DT><span class="strong">SUMMABLE_REARRANGE</span>
<DD>
<pre>
⊢ ∀x s p. summable s (λn. abs (x n)) ∧ p permutes s ⇒ summable s (x ∘ p)
</pre>

<DT><span class="strong">SUMMABLE_REINDEX</span>
<DD>
<pre>
⊢ ∀k a n. summable (from n) (λx. a (x + k)) ⇔ summable (from (n + k)) a
</pre>

<DT><span class="strong">SUMMABLE_RESTRICT</span>
<DD>
<pre>
⊢ ∀f k. summable 𝕌(:num) (λn. if n ∈ k then f n else 0) ⇔ summable k f
</pre>

<DT><span class="strong">SUMMABLE_SUB</span>
<DD>
<pre>
⊢ ∀x y s. summable s x ∧ summable s y ⇒ summable s (λn. x n − y n)
</pre>

<DT><span class="strong">SUMMABLE_SUBSET</span>
<DD>
<pre>
⊢ ∀x s t. s ⊆ t ∧ summable t (λi. if i ∈ s then x i else 0) ⇒ summable s x
</pre>

<DT><span class="strong">SUMMABLE_SUBSET_ABSCONV</span>
<DD>
<pre>
⊢ ∀x s t. summable s (λn. abs (x n)) ∧ t ⊆ s ⇒ summable t (λn. abs (x n))
</pre>

<DT><span class="strong">SUMMABLE_TRIVIAL</span>
<DD>
<pre>
⊢ ∀f. summable ∅ f
</pre>

<DT><span class="strong">SUMS_0</span>
<DD>
<pre>
⊢ ∀f s. (∀n. n ∈ s ⇒ (f n = 0)) ⇒ (f sums 0) s
</pre>

<DT><span class="strong">SUMS_EQ</span>
<DD>
<pre>
⊢ ∀f g k. (∀x. x ∈ k ⇒ (f x = g x)) ∧ (f sums l) k ⇒ (g sums l) k
</pre>

<DT><span class="strong">SUMS_FINITE_DIFF</span>
<DD>
<pre>
⊢ ∀f t s l.
    t ⊆ s ∧ FINITE t ∧ (f sums l) s ⇒ (f sums (l − sum t f)) (s DIFF t)
</pre>

<DT><span class="strong">SUMS_FINITE_UNION</span>
<DD>
<pre>
⊢ ∀f s t l. FINITE t ∧ (f sums l) s ⇒ (f sums (l + sum (t DIFF s) f)) (s ∪ t)
</pre>

<DT><span class="strong">SUMS_IFF</span>
<DD>
<pre>
⊢ ∀f g k. (∀x. x ∈ k ⇒ (f x = g x)) ⇒ ((f sums l) k ⇔ (g sums l) k)
</pre>

<DT><span class="strong">SUMS_INFSUM</span>
<DD>
<pre>
⊢ ∀f s. (f sums suminf s f) s ⇔ summable s f
</pre>

<DT><span class="strong">SUMS_INTERVALS</span>
<DD>
<pre>
⊢ (∀a b c d.
     interval [(a,b)] ≠ ∅ ∧ interval [(c,d)] ≠ ∅ ⇒
     ({x + y | x ∈ interval [(a,b)] ∧ y ∈ interval [(c,d)]} =
      interval [(a + c,b + d)])) ∧
  ∀a b c d.
    interval (a,b) ≠ ∅ ∧ interval (c,d) ≠ ∅ ⇒
    ({x + y | x ∈ interval (a,b) ∧ y ∈ interval (c,d)} =
     interval (a + c,b + d))
</pre>

<DT><span class="strong">SUMS_LIM</span>
<DD>
<pre>
⊢ ∀f s. (f sums lim sequentially (λn. sum (s ∩ {0 .. n}) f)) s ⇔ summable s f
</pre>

<DT><span class="strong">SUMS_OFFSET</span>
<DD>
<pre>
⊢ ∀f l m n.
    (f sums l) (from m) ∧ 0 < n ∧ m ≤ n ⇒
    (f sums (l − sum {m .. n − 1} f)) (from n)
</pre>

<DT><span class="strong">SUMS_OFFSET_REV</span>
<DD>
<pre>
⊢ ∀f l m n.
    (f sums l) (from m) ∧ 0 < m ∧ n ≤ m ⇒
    (f sums (l + sum {n .. m − 1} f)) (from n)
</pre>

<DT><span class="strong">SUMS_REINDEX</span>
<DD>
<pre>
⊢ ∀k a l n. ((λx. a (x + k)) sums l) (from n) ⇔ (a sums l) (from (n + k))
</pre>

<DT><span class="strong">SUMS_REINDEX_GEN</span>
<DD>
<pre>
⊢ ∀k a l s. ((λx. a (x + k)) sums l) s ⇔ (a sums l) (IMAGE (λi. i + k) s)
</pre>

<DT><span class="strong">SUMS_SUMMABLE</span>
<DD>
<pre>
⊢ ∀f l s. (f sums l) s ⇒ summable s f
</pre>

<DT><span class="strong">SUM_DIFF_LEMMA</span>
<DD>
<pre>
⊢ ∀f k m n.
    m ≤ n ⇒
    (sum (k ∩ {0 .. n}) f − sum (k ∩ {0 .. m}) f = sum (k ∩ {m + 1 .. n}) f)
</pre>

<DT><span class="strong">SUP_INSERT</span>
<DD>
<pre>
⊢ ∀x s. bounded s ⇒ (sup (x INSERT s) = if s = ∅ then x else max x (sup s))
</pre>

<DT><span class="strong">SURJECTIVE_IMAGE_EQ</span>
<DD>
<pre>
⊢ ∀s t. (∀y. y ∈ t ⇒ ∃x. f x = y) ∧ (∀x. f x ∈ t ⇔ x ∈ s) ⇒ (IMAGE f s = t)
</pre>

<DT><span class="strong">SYMMETRIC_CLOSURE</span>
<DD>
<pre>
⊢ ∀s. (∀x. x ∈ s ⇒ -x ∈ s) ⇒ ∀x. x ∈ closure s ⇒ -x ∈ closure s
</pre>

<DT><span class="strong">SYMMETRIC_INTERIOR</span>
<DD>
<pre>
⊢ ∀s. (∀x. x ∈ s ⇒ -x ∈ s) ⇒ ∀x. x ∈ interior s ⇒ -x ∈ interior s
</pre>

<DT><span class="strong">SYMMETRIC_LINEAR_IMAGE</span>
<DD>
<pre>
⊢ ∀f s. (∀x. x ∈ s ⇒ -x ∈ s) ∧ linear f ⇒ ∀x. x ∈ IMAGE f s ⇒ -x ∈ IMAGE f s
</pre>

<DT><span class="strong">TENDSTO_LIM</span>
<DD>
<pre>
⊢ ∀net f l. ¬trivial_limit net ∧ (f --> l) net ⇒ (lim net f = l)
</pre>

<DT><span class="strong">TOPSPACE_EUCLIDEAN</span>
<DD>
<pre>
⊢ topspace euclidean = 𝕌(:real)
</pre>

<DT><span class="strong">TOPSPACE_EUCLIDEAN_SUBTOPOLOGY</span>
<DD>
<pre>
⊢ ∀s. topspace (subtopology euclidean s) = s
</pre>

<DT><span class="strong">TRANSITIVE_STEPWISE_LT</span>
<DD>
<pre>
⊢ ∀R. (∀x y z. R x y ∧ R y z ⇒ R x z) ∧ (∀n. R n (SUC n)) ⇒
      ∀m n. m < n ⇒ R m n
</pre>

<DT><span class="strong">TRANSITIVE_STEPWISE_LT_EQ</span>
<DD>
<pre>
⊢ ∀R. (∀x y z. R x y ∧ R y z ⇒ R x z) ⇒
      ((∀m n. m < n ⇒ R m n) ⇔ ∀n. R n (SUC n))
</pre>

<DT><span class="strong">TRANSLATION_DIFF</span>
<DD>
<pre>
⊢ ∀s t.
    IMAGE (λx. a + x) (s DIFF t) =
    IMAGE (λx. a + x) s DIFF IMAGE (λx. a + x) t
</pre>

<DT><span class="strong">TRIVIAL_LIMIT_AT</span>
<DD>
<pre>
⊢ ∀a. ¬trivial_limit (at a)
</pre>

<DT><span class="strong">TRIVIAL_LIMIT_AT_INFINITY</span>
<DD>
<pre>
⊢ ¬trivial_limit at_infinity
</pre>

<DT><span class="strong">TRIVIAL_LIMIT_AT_NEGINFINITY</span>
<DD>
<pre>
⊢ ¬trivial_limit at_neginfinity
</pre>

<DT><span class="strong">TRIVIAL_LIMIT_AT_POSINFINITY</span>
<DD>
<pre>
⊢ ¬trivial_limit at_posinfinity
</pre>

<DT><span class="strong">TRIVIAL_LIMIT_SEQUENTIALLY</span>
<DD>
<pre>
⊢ ¬trivial_limit sequentially
</pre>

<DT><span class="strong">TRIVIAL_LIMIT_WITHIN</span>
<DD>
<pre>
⊢ ∀a. trivial_limit (at a within s) ⇔ ¬(a limit_point_of s)
</pre>

<DT><span class="strong">UNBOUNDED_HALFSPACE_COMPONENT_GE</span>
<DD>
<pre>
⊢ ∀a. ¬bounded {x | x ≥ a}
</pre>

<DT><span class="strong">UNBOUNDED_HALFSPACE_COMPONENT_GT</span>
<DD>
<pre>
⊢ ∀a. ¬bounded {x | x > a}
</pre>

<DT><span class="strong">UNBOUNDED_HALFSPACE_COMPONENT_LE</span>
<DD>
<pre>
⊢ ∀a. ¬bounded {x | x ≤ a}
</pre>

<DT><span class="strong">UNBOUNDED_HALFSPACE_COMPONENT_LT</span>
<DD>
<pre>
⊢ ∀a. ¬bounded {x | x < a}
</pre>

<DT><span class="strong">UNBOUNDED_INTER_COBOUNDED</span>
<DD>
<pre>
⊢ ∀s t. ¬bounded s ∧ bounded (𝕌(:real) DIFF t) ⇒ s ∩ t ≠ ∅
</pre>

<DT><span class="strong">UNCOUNTABLE_EUCLIDEAN</span>
<DD>
<pre>
⊢ uncountable 𝕌(:real)
</pre>

<DT><span class="strong">UNCOUNTABLE_INTERVAL</span>
<DD>
<pre>
⊢ (∀a b. interval (a,b) ≠ ∅ ⇒ uncountable (interval [(a,b)])) ∧
  ∀a b. interval (a,b) ≠ ∅ ⇒ uncountable (interval (a,b))
</pre>

<DT><span class="strong">UNCOUNTABLE_OPEN</span>
<DD>
<pre>
⊢ ∀s. open s ∧ s ≠ ∅ ⇒ uncountable s
</pre>

<DT><span class="strong">UNCOUNTABLE_REAL</span>
<DD>
<pre>
⊢ uncountable 𝕌(:real)
</pre>

<DT><span class="strong">UNIFORMLY_CAUCHY_IMP_UNIFORMLY_CONVERGENT</span>
<DD>
<pre>
⊢ ∀P s l.
    (∀e. 0 < e ⇒ ∃N. ∀m n x. N ≤ m ∧ N ≤ n ∧ P x ⇒ dist (s m x,s n x) < e) ∧
    (∀x. P x ⇒ ∀e. 0 < e ⇒ ∃N. ∀n. N ≤ n ⇒ dist (s n x,l x) < e) ⇒
    ∀e. 0 < e ⇒ ∃N. ∀n x. N ≤ n ∧ P x ⇒ dist (s n x,l x) < e
</pre>

<DT><span class="strong">UNIFORMLY_CONTINUOUS_EXTENDS_TO_CLOSURE</span>
<DD>
<pre>
⊢ ∀f s.
    f uniformly_continuous_on s ⇒
    ∃g. g uniformly_continuous_on closure s ∧ (∀x. x ∈ s ⇒ (g x = f x)) ∧
        ∀h. h continuous_on closure s ∧ (∀x. x ∈ s ⇒ (h x = f x)) ⇒
            ∀x. x ∈ closure s ⇒ (h x = g x)
</pre>

<DT><span class="strong">UNIFORMLY_CONTINUOUS_IMP_CAUCHY_CONTINUOUS</span>
<DD>
<pre>
⊢ ∀f s.
    f uniformly_continuous_on s ⇒
    ∀x. cauchy x ∧ (∀n. x n ∈ s) ⇒ cauchy (f ∘ x)
</pre>

<DT><span class="strong">UNIFORMLY_CONTINUOUS_IMP_CONTINUOUS</span>
<DD>
<pre>
⊢ ∀f s. f uniformly_continuous_on s ⇒ f continuous_on s
</pre>

<DT><span class="strong">UNIFORMLY_CONTINUOUS_ON_ADD</span>
<DD>
<pre>
⊢ ∀f g s.
    f uniformly_continuous_on s ∧ g uniformly_continuous_on s ⇒
    (λx. f x + g x) uniformly_continuous_on s
</pre>

<DT><span class="strong">UNIFORMLY_CONTINUOUS_ON_CLOSURE</span>
<DD>
<pre>
⊢ ∀f s.
    f uniformly_continuous_on s ∧ f continuous_on closure s ⇒
    f uniformly_continuous_on closure s
</pre>

<DT><span class="strong">UNIFORMLY_CONTINUOUS_ON_CMUL</span>
<DD>
<pre>
⊢ ∀f c s.
    f uniformly_continuous_on s ⇒ (λx. c * f x) uniformly_continuous_on s
</pre>

<DT><span class="strong">UNIFORMLY_CONTINUOUS_ON_COMPOSE</span>
<DD>
<pre>
⊢ ∀f g s.
    f uniformly_continuous_on s ∧ g uniformly_continuous_on IMAGE f s ⇒
    g ∘ f uniformly_continuous_on s
</pre>

<DT><span class="strong">UNIFORMLY_CONTINUOUS_ON_CONST</span>
<DD>
<pre>
⊢ ∀s c. (λx. c) uniformly_continuous_on s
</pre>

<DT><span class="strong">UNIFORMLY_CONTINUOUS_ON_DIST_CLOSEST_POINT</span>
<DD>
<pre>
⊢ ∀s t.
    closed s ∧ s ≠ ∅ ⇒
    (λx. dist (x,closest_point s x)) uniformly_continuous_on t
</pre>

<DT><span class="strong">UNIFORMLY_CONTINUOUS_ON_EQ</span>
<DD>
<pre>
⊢ ∀f g s.
    (∀x. x ∈ s ⇒ (f x = g x)) ∧ f uniformly_continuous_on s ⇒
    g uniformly_continuous_on s
</pre>

<DT><span class="strong">UNIFORMLY_CONTINUOUS_ON_ID</span>
<DD>
<pre>
⊢ ∀s. (λx. x) uniformly_continuous_on s
</pre>

<DT><span class="strong">UNIFORMLY_CONTINUOUS_ON_MUL</span>
<DD>
<pre>
⊢ ∀f g s.
    f uniformly_continuous_on s ∧ g uniformly_continuous_on s ∧
    bounded (IMAGE f s) ∧ bounded (IMAGE g s) ⇒
    (λx. f x * g x) uniformly_continuous_on s
</pre>

<DT><span class="strong">UNIFORMLY_CONTINUOUS_ON_NEG</span>
<DD>
<pre>
⊢ ∀f s. f uniformly_continuous_on s ⇒ (λx. -f x) uniformly_continuous_on s
</pre>

<DT><span class="strong">UNIFORMLY_CONTINUOUS_ON_SEQUENTIALLY</span>
<DD>
<pre>
⊢ ∀f s.
    f uniformly_continuous_on s ⇔
    ∀x y.
      (∀n. x n ∈ s) ∧ (∀n. y n ∈ s) ∧ ((λn. x n − y n) --> 0) sequentially ⇒
      ((λn. f (x n) − f (y n)) --> 0) sequentially
</pre>

<DT><span class="strong">UNIFORMLY_CONTINUOUS_ON_SETDIST</span>
<DD>
<pre>
⊢ ∀s t. (λy. setdist ({y},s)) uniformly_continuous_on t
</pre>

<DT><span class="strong">UNIFORMLY_CONTINUOUS_ON_SUB</span>
<DD>
<pre>
⊢ ∀f g s.
    f uniformly_continuous_on s ∧ g uniformly_continuous_on s ⇒
    (λx. f x − g x) uniformly_continuous_on s
</pre>

<DT><span class="strong">UNIFORMLY_CONTINUOUS_ON_SUBSET</span>
<DD>
<pre>
⊢ ∀f s t. f uniformly_continuous_on s ∧ t ⊆ s ⇒ f uniformly_continuous_on t
</pre>

<DT><span class="strong">UNIFORMLY_CONTINUOUS_ON_SUM</span>
<DD>
<pre>
⊢ ∀t f s.
    FINITE s ∧ (∀a. a ∈ s ⇒ f a uniformly_continuous_on t) ⇒
    (λx. sum s (λa. f a x)) uniformly_continuous_on t
</pre>

<DT><span class="strong">UNIFORMLY_CONTINUOUS_ON_VMUL</span>
<DD>
<pre>
⊢ ∀s c v.
    c uniformly_continuous_on s ⇒ (λx. c x * v) uniformly_continuous_on s
</pre>

<DT><span class="strong">UNIFORMLY_CONVERGENT_EQ_CAUCHY</span>
<DD>
<pre>
⊢ ∀P s.
    (∃l. ∀e. 0 < e ⇒ ∃N. ∀n x. N ≤ n ∧ P x ⇒ dist (s n x,l x) < e) ⇔
    ∀e. 0 < e ⇒ ∃N. ∀m n x. N ≤ m ∧ N ≤ n ∧ P x ⇒ dist (s m x,s n x) < e
</pre>

<DT><span class="strong">UNIFORMLY_CONVERGENT_EQ_CAUCHY_ALT</span>
<DD>
<pre>
⊢ ∀P s.
    (∃l. ∀e. 0 < e ⇒ ∃N. ∀n x. N ≤ n ∧ P x ⇒ dist (s n x,l x) < e) ⇔
    ∀e. 0 < e ⇒
        ∃N. ∀m n x. N ≤ m ∧ N ≤ n ∧ m < n ∧ P x ⇒ dist (s m x,s n x) < e
</pre>

<DT><span class="strong">UNIFORM_LIM_ADD</span>
<DD>
<pre>
⊢ ∀net P f g l m.
    (∀e. 0 < e ⇒ eventually (λx. ∀n. P n ⇒ abs (f n x − l n) < e) net) ∧
    (∀e. 0 < e ⇒ eventually (λx. ∀n. P n ⇒ abs (g n x − m n) < e) net) ⇒
    ∀e. 0 < e ⇒
        eventually (λx. ∀n. P n ⇒ abs (f n x + g n x − (l n + m n)) < e) net
</pre>

<DT><span class="strong">UNIFORM_LIM_BILINEAR</span>
<DD>
<pre>
⊢ ∀net P h f g l m b1 b2.
    bilinear h ∧ eventually (λx. ∀n. P n ⇒ abs (l n) ≤ b1) net ∧
    eventually (λx. ∀n. P n ⇒ abs (m n) ≤ b2) net ∧
    (∀e. 0 < e ⇒ eventually (λx. ∀n. P n ⇒ abs (f n x − l n) < e) net) ∧
    (∀e. 0 < e ⇒ eventually (λx. ∀n. P n ⇒ abs (g n x − m n) < e) net) ⇒
    ∀e. 0 < e ⇒
        eventually (λx. ∀n. P n ⇒ abs (h (f n x) (g n x) − h (l n) (m n)) < e)
          net
</pre>

<DT><span class="strong">UNIFORM_LIM_SUB</span>
<DD>
<pre>
⊢ ∀net P f g l m.
    (∀e. 0 < e ⇒ eventually (λx. ∀n. P n ⇒ abs (f n x − l n) < e) net) ∧
    (∀e. 0 < e ⇒ eventually (λx. ∀n. P n ⇒ abs (g n x − m n) < e) net) ⇒
    ∀e. 0 < e ⇒
        eventually (λx. ∀n. P n ⇒ abs (f n x − g n x − (l n − m n)) < e) net
</pre>

<DT><span class="strong">UNION_FRONTIER</span>
<DD>
<pre>
⊢ ∀s t.
    frontier s ∪ frontier t =
    frontier (s ∪ t) ∪ frontier (s ∩ t) ∪ frontier s ∩ frontier t
</pre>

<DT><span class="strong">UNION_INTERIOR_SUBSET</span>
<DD>
<pre>
⊢ ∀s t. interior s ∪ interior t ⊆ interior (s ∪ t)
</pre>

<DT><span class="strong">UNIT_INTERVAL_NONEMPTY</span>
<DD>
<pre>
⊢ interval [(0,1)] ≠ ∅ ∧ interval (0,1) ≠ ∅
</pre>

<DT><span class="strong">UPPER_HEMICONTINUOUS</span>
<DD>
<pre>
⊢ ∀f t s.
    (∀x. x ∈ s ⇒ f x ⊆ t) ⇒
    ((∀u. open_in (subtopology euclidean t) u ⇒
          open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ⊆ u}) ⇔
     ∀u. closed_in (subtopology euclidean t) u ⇒
         closed_in (subtopology euclidean s) {x | x ∈ s ∧ f x ∩ u ≠ ∅})
</pre>

<DT><span class="strong">UPPER_LOWER_HEMICONTINUOUS</span>
<DD>
<pre>
⊢ ∀f t s.
    (∀x. x ∈ s ⇒ f x ⊆ t) ∧
    (∀u. open_in (subtopology euclidean t) u ⇒
         open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ⊆ u}) ∧
    (∀u. closed_in (subtopology euclidean t) u ⇒
         closed_in (subtopology euclidean s) {x | x ∈ s ∧ f x ⊆ u}) ⇒
    ∀x e.
      x ∈ s ∧ 0 < e ∧ bounded (f x) ⇒
      ∃d. 0 < d ∧ ∀x'. x' ∈ s ∧ dist (x,x') < d ⇒ hausdist (f x,f x') < e
</pre>

<DT><span class="strong">UPPER_LOWER_HEMICONTINUOUS_EXPLICIT</span>
<DD>
<pre>
⊢ ∀f t s.
    (∀x. x ∈ s ⇒ f x ⊆ t) ∧
    (∀u. open_in (subtopology euclidean t) u ⇒
         open_in (subtopology euclidean s) {x | x ∈ s ∧ f x ⊆ u}) ∧
    (∀u. closed_in (subtopology euclidean t) u ⇒
         closed_in (subtopology euclidean s) {x | x ∈ s ∧ f x ⊆ u}) ⇒
    ∀x e.
      x ∈ s ∧ 0 < e ∧ bounded (f x) ∧ f x ≠ ∅ ⇒
      ∃d. 0 < d ∧
          ∀x'.
            x' ∈ s ∧ dist (x,x') < d ⇒
            (∀y. y ∈ f x ⇒ ∃y'. y' ∈ f x' ∧ dist (y,y') < e) ∧
            ∀y'. y' ∈ f x' ⇒ ∃y. y ∈ f x ∧ dist (y',y) < e
</pre>

<DT><span class="strong">URYSOHN</span>
<DD>
<pre>
⊢ ∀s t a b.
    closed s ∧ closed t ∧ (s ∩ t = ∅) ⇒
    ∃f. f continuous_on 𝕌(:real) ∧ (∀x. f x ∈ segment [(a,b)]) ∧
        (∀x. x ∈ s ⇒ (f x = a)) ∧ ∀x. x ∈ t ⇒ (f x = b)
</pre>

<DT><span class="strong">URYSOHN_LOCAL</span>
<DD>
<pre>
⊢ ∀s t u a b.
    closed_in (subtopology euclidean u) s ∧
    closed_in (subtopology euclidean u) t ∧ (s ∩ t = ∅) ⇒
    ∃f. f continuous_on u ∧ (∀x. x ∈ u ⇒ f x ∈ segment [(a,b)]) ∧
        (∀x. x ∈ s ⇒ (f x = a)) ∧ ∀x. x ∈ t ⇒ (f x = b)
</pre>

<DT><span class="strong">URYSOHN_LOCAL_STRONG</span>
<DD>
<pre>
⊢ ∀s t u a b.
    closed_in (subtopology euclidean u) s ∧
    closed_in (subtopology euclidean u) t ∧ (s ∩ t = ∅) ∧ a ≠ b ⇒
    ∃f. f continuous_on u ∧ (∀x. x ∈ u ⇒ f x ∈ segment [(a,b)]) ∧
        (∀x. x ∈ u ⇒ ((f x = a) ⇔ x ∈ s)) ∧ ∀x. x ∈ u ⇒ ((f x = b) ⇔ x ∈ t)
</pre>

<DT><span class="strong">URYSOHN_STRONG</span>
<DD>
<pre>
⊢ ∀s t a b.
    closed s ∧ closed t ∧ (s ∩ t = ∅) ∧ a ≠ b ⇒
    ∃f. f continuous_on 𝕌(:real) ∧ (∀x. f x ∈ segment [(a,b)]) ∧
        (∀x. (f x = a) ⇔ x ∈ s) ∧ ∀x. (f x = b) ⇔ x ∈ t
</pre>

<DT><span class="strong">WITHIN</span>
<DD>
<pre>
⊢ ∀n s x y. netord (n within s) x y ⇔ netord n x y ∧ x ∈ s
</pre>

<DT><span class="strong">WITHIN_UNIV</span>
<DD>
<pre>
⊢ ∀x. at x within 𝕌(:real) = at x
</pre>

<DT><span class="strong">WITHIN_WITHIN</span>
<DD>
<pre>
⊢ ∀net s t. (net within s) within t = net within s ∩ t
</pre>

<DT><span class="strong">WLOG_LT</span>
<DD>
<pre>
⊢ (∀m. P m m) ∧ (∀m n. P m n ⇔ P n m) ∧ (∀m n. m < n ⇒ P m n) ⇒ ∀m y. P m y
</pre>

<DT><span class="strong">at</span>
<DD>
<pre>
⊢ ∀a. at a = mk_net (λx y. 0 < dist (x,a) ∧ dist (x,a) ≤ dist (y,a))
</pre>

<DT><span class="strong">ball</span>
<DD>
<pre>
⊢ ∀x e. ball (x,e) = {y | dist (x,y) < e}
</pre>

<DT><span class="strong">closed_def</span>
<DD>
<pre>
⊢ ∀s. closed s ⇔ open (𝕌(:real) DIFF s)
</pre>

<DT><span class="strong">continuous_at</span>
<DD>
<pre>
⊢ f continuous at x ⇔
  ∀e. 0 < e ⇒ ∃d. 0 < d ∧ ∀x'. dist (x',x) < d ⇒ dist (f x',f x) < e
</pre>

<DT><span class="strong">continuous_within</span>
<DD>
<pre>
⊢ f continuous (at x within s) ⇔
  ∀e. 0 < e ⇒ ∃d. 0 < d ∧ ∀x'. x' ∈ s ∧ dist (x',x) < d ⇒ dist (f x',f x) < e
</pre>

<DT><span class="strong">diameter</span>
<DD>
<pre>
⊢ ∀s. diameter s = if s = ∅ then 0 else sup {abs (x − y) | x ∈ s ∧ y ∈ s}
</pre>

<DT><span class="strong">dist</span>
<DD>
<pre>
⊢ ∀x y. dist (x,y) = abs (x − y)
</pre>

<DT><span class="strong">euclidean</span>
<DD>
<pre>
⊢ euclidean = topology open
</pre>

<DT><span class="strong">fsigma</span>
<DD>
<pre>
⊢ ∀s. fsigma s ⇔ ∃g. countable g ∧ (∀c. c ∈ g ⇒ closed c) ∧ (BIGUNION g = s)
</pre>

<DT><span class="strong">gdelta</span>
<DD>
<pre>
⊢ ∀s. gdelta s ⇔ ∃g. countable g ∧ (∀u. u ∈ g ⇒ open u) ∧ (BIGINTER g = s)
</pre>

<DT><span class="strong">interval</span>
<DD>
<pre>
⊢ (interval (a,b) = {x | a < x ∧ x < b}) ∧
  (interval [(a,b)] = {x | a ≤ x ∧ x ≤ b})
</pre>

<DT><span class="strong">limit_point_of</span>
<DD>
<pre>
⊢ ∀x s. x limit_point_of s ⇔ ∀t. x ∈ t ∧ open t ⇒ ∃y. y ≠ x ∧ y ∈ s ∧ y ∈ t
</pre>

<DT><span class="strong">net_tybij</span>
<DD>
<pre>
⊢ (∀a. mk_net (netord a) = a) ∧
  ∀r. (∀x y. (∀z. r z x ⇒ r z y) ∨ ∀z. r z y ⇒ r z x) ⇔
      (netord (mk_net r) = r)
</pre>

<DT><span class="strong">open_def</span>
<DD>
<pre>
⊢ ∀s. open s ⇔ ∀x. x ∈ s ⇒ ∃e. 0 < e ∧ ∀x'. dist (x',x) < e ⇒ x' ∈ s
</pre>

<DT><span class="strong">open_in</span>
<DD>
<pre>
⊢ ∀u s.
    open_in (subtopology euclidean u) s ⇔
    s ⊆ u ∧ ∀x. x ∈ s ⇒ ∃e. 0 < e ∧ ∀x'. x' ∈ u ∧ dist (x',x) < e ⇒ x' ∈ s
</pre>

<DT><span class="strong">segment</span>
<DD>
<pre>
⊢ (segment [(a,b)] = {(1 − u) * a + u * b | 0 ≤ u ∧ u ≤ 1}) ∧
  (segment (a,b) = segment [(a,b)] DIFF {a; b})
</pre>

<DT><span class="strong">setdist</span>
<DD>
<pre>
⊢ ∀s t.
    setdist (s,t) =
    if (s = ∅) ∨ (t = ∅) then 0 else inf {dist (x,y) | x ∈ s ∧ y ∈ t}
</pre>

</DL>



<hr>
</body>
</html>
