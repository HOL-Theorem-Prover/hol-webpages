<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: toto</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "toto"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "stringTheory.html"><span class="strong">string</span></a>&nbsp;&nbsp;
    <a href = "wellorderTheory.html"><span class="strong">wellorder</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Type <th> Arity<tr><td>
    <span class="strong">num_dt</span>
    <td>
    0
    <tr><td> <span class="strong">toto</span> <td> 1
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">ListOrd</span>
    <td>
    :α toto -> α list -> α list -> ordering
    <tr><td>
    <span class="strong">StrongLinearOrder_of_TO</span>
    <td>
    :(α -> α -> ordering) -> α -> α -> bool
    <tr><td>
    <span class="strong">TO</span>
    <td>
    :(α -> α -> ordering) -> α toto
    <tr><td>
    <span class="strong">TO_inv</span>
    <td>
    :(α -> α -> ordering) -> α -> α -> ordering
    <tr><td>
    <span class="strong">TO_of_LinearOrder</span>
    <td>
    :(α -> α -> bool) -> α -> α -> ordering
    <tr><td>
    <span class="strong">TotOrd</span>
    <td>
    :(α -> α -> ordering) -> bool
    <tr><td>
    <span class="strong">WeakLinearOrder_of_TO</span>
    <td>
    :(α -> α -> ordering) -> α -> α -> bool
    <tr><td>
    <span class="strong">apto</span>
    <td>
    :α toto -> α -> α -> ordering
    <tr><td> <span class="strong">bit1</span> <td> :num_dt -> num_dt
    <tr><td> <span class="strong">bit2</span> <td> :num_dt -> num_dt
    <tr><td>
    <span class="strong">charOrd</span>
    <td>
    :char -> char -> ordering
    <tr><td> <span class="strong">charto</span> <td> :char toto
    <tr><td>
    <span class="strong">imageOrd</span>
    <td>
    :(α -> γ) -> (γ -> γ -> ordering) -> α -> α -> ordering
    <tr><td>
    <span class="strong">lexTO</span>
    <td>
    :(α -> α -> ordering) ->
    (β -> β -> ordering) -> α # β -> α # β -> ordering
    <tr><td>
    <span class="strong">lextoto</span>
    <td>
    :α toto -> β toto -> (α # β) toto
    <tr><td>
    <span class="strong">listorder</span>
    <td>
    :(α -> α -> bool) -> α list -> α list -> bool
    <tr><td> <span class="strong">listoto</span> <td> :α toto -> α list toto
    <tr><td> <span class="strong">numOrd</span> <td> :num -> num -> ordering
    <tr><td>
    <span class="strong">num_dtOrd</span>
    <td>
    :num_dt -> num_dt -> ordering
    <tr><td>
    <span class="strong">num_dt_CASE</span>
    <td>
    :num_dt -> α -> (num_dt -> α) -> (num_dt -> α) -> α
    <tr><td> <span class="strong">num_dt_size</span> <td> :num_dt -> num
    <tr><td> <span class="strong">num_to_dt</span> <td> :num -> num_dt
    <tr><td> <span class="strong">numto</span> <td> :num toto
    <tr><td>
    <span class="strong">qk_numOrd</span>
    <td>
    :num -> num -> ordering
    <tr><td> <span class="strong">qk_numto</span> <td> :num toto
    <tr><td> <span class="strong">stringto</span> <td> :string toto
    <tr><td> <span class="strong">toto_inv</span> <td> :α toto -> α toto
    <tr><td>
    <span class="strong">toto_of_LinearOrder</span>
    <td>
    :(α -> α -> bool) -> α toto
    <tr><td> <span class="strong">zer</span> <td> :num_dt
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">ListOrd</span>
<DD>
<pre>
⊢ ∀c. ListOrd c =
      TO_of_LinearOrder (listorder (StrongLinearOrder_of_TO (apto c)))
</pre>

<DT><span class="strong">StrongLinearOrder_of_TO</span>
<DD>
<pre>
⊢ ∀c x y.
    StrongLinearOrder_of_TO c x y ⇔
    case c x y of Less => T | Equal => F | Greater => F
</pre>

<DT><span class="strong">TO_inv</span>
<DD>
<pre>
⊢ ∀c x y. TO_inv c x y = c y x
</pre>

<DT><span class="strong">TO_of_LinearOrder</span>
<DD>
<pre>
⊢ ∀r x y.
    TO_of_LinearOrder r x y =
    if x = y then Equal else if r x y then Less else Greater
</pre>

<DT><span class="strong">TotOrd</span>
<DD>
<pre>
⊢ ∀c. TotOrd c ⇔
      (∀x y. (c x y = Equal) ⇔ (x = y)) ∧
      (∀x y. (c x y = Greater) ⇔ (c y x = Less)) ∧
      ∀x y z. (c x y = Less) ∧ (c y z = Less) ⇒ (c x z = Less)
</pre>

<DT><span class="strong">WeakLinearOrder_of_TO</span>
<DD>
<pre>
⊢ ∀c x y.
    WeakLinearOrder_of_TO c x y ⇔
    case c x y of Less => T | Equal => T | Greater => F
</pre>

<DT><span class="strong">charOrd</span>
<DD>
<pre>
⊢ ∀a b. charOrd a b = numOrd (ORD a) (ORD b)
</pre>

<DT><span class="strong">charto</span>
<DD>
<pre>
⊢ charto = TO charOrd
</pre>

<DT><span class="strong">imageOrd</span>
<DD>
<pre>
⊢ ∀f cp a b. imageOrd f cp a b = cp (f a) (f b)
</pre>

<DT><span class="strong">lexTO</span>
<DD>
<pre>
⊢ ∀R V.
    R lexTO V =
    TO_of_LinearOrder
      (StrongLinearOrder_of_TO R LEX StrongLinearOrder_of_TO V)
</pre>

<DT><span class="strong">lextoto</span>
<DD>
<pre>
⊢ ∀c v. c lextoto v = TO (apto c lexTO apto v)
</pre>

<DT><span class="strong">listoto</span>
<DD>
<pre>
⊢ ∀c. listoto c = TO (ListOrd c)
</pre>

<DT><span class="strong">numOrd</span>
<DD>
<pre>
⊢ numOrd = TO_of_LinearOrder $<
</pre>

<DT><span class="strong">num_dt_TY_DEF</span>
<DD>
<pre>
⊢ ∃rep.
    TYPE_DEFINITION
      (λa0.
           ∀ $var$('num_dt').
             (∀a0.
                (a0 = ind_type$CONSTR 0 ARB (λn. ind_type$BOTTOM)) ∨
                (∃a. (a0 =
                      (λa.
                           ind_type$CONSTR (SUC 0) ARB
                             (ind_type$FCONS a (λn. ind_type$BOTTOM))) a) ∧
                     $var$('num_dt') a) ∨
                (∃a. (a0 =
                      (λa.
                           ind_type$CONSTR (SUC (SUC 0)) ARB
                             (ind_type$FCONS a (λn. ind_type$BOTTOM))) a) ∧
                     $var$('num_dt') a) ⇒
                $var$('num_dt') a0) ⇒
             $var$('num_dt') a0) rep
</pre>

<DT><span class="strong">num_dt_case_def</span>
<DD>
<pre>
⊢ (∀v f f1. num_dt_CASE zer v f f1 = v) ∧
  (∀a v f f1. num_dt_CASE (bit1 a) v f f1 = f a) ∧
  ∀a v f f1. num_dt_CASE (bit2 a) v f f1 = f1 a
</pre>

<DT><span class="strong">num_dt_size_def</span>
<DD>
<pre>
⊢ (num_dt_size zer = 0) ∧ (∀a. num_dt_size (bit1 a) = 1 + num_dt_size a) ∧
  ∀a. num_dt_size (bit2 a) = 1 + num_dt_size a
</pre>

<DT><span class="strong">num_to_dt_primitive</span>
<DD>
<pre>
⊢ num_to_dt =
  WFREC
    (@R. WF R ∧ (∀n. n ≠ 0 ∧ ODD n ⇒ R (DIV2 (n − 1)) n) ∧
         ∀n. n ≠ 0 ∧ ¬ODD n ⇒ R (DIV2 (n − 2)) n)
    (λnum_to_dt a.
         I
           (if a = 0 then zer
            else if ODD a then bit1 (num_to_dt (DIV2 (a − 1)))
            else bit2 (num_to_dt (DIV2 (a − 2)))))
</pre>

<DT><span class="strong">numto</span>
<DD>
<pre>
⊢ numto = TO numOrd
</pre>

<DT><span class="strong">qk_numOrd_def</span>
<DD>
<pre>
⊢ ∀m n. qk_numOrd m n = num_dtOrd (num_to_dt m) (num_to_dt n)
</pre>

<DT><span class="strong">qk_numto</span>
<DD>
<pre>
⊢ qk_numto = TO qk_numOrd
</pre>

<DT><span class="strong">stringto</span>
<DD>
<pre>
⊢ stringto = listoto charto
</pre>

<DT><span class="strong">to_bij</span>
<DD>
<pre>
⊢ (∀a. TO (apto a) = a) ∧ ∀r. TotOrd r ⇔ (apto (TO r) = r)
</pre>

<DT><span class="strong">toto_TY_DEF</span>
<DD>
<pre>
⊢ ∃rep. TYPE_DEFINITION TotOrd rep
</pre>

<DT><span class="strong">toto_inv</span>
<DD>
<pre>
⊢ ∀c. toto_inv c = TO (TO_inv (apto c))
</pre>

<DT><span class="strong">toto_of_LinearOrder</span>
<DD>
<pre>
⊢ ∀r. toto_of_LinearOrder r = TO (TO_of_LinearOrder r)
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">LEX_ALT</span>
<DD>
<pre>
⊢ ∀R U c d.
    (R LEX U) c d ⇔ R (FST c) (FST d) ∨ (FST c = FST d) ∧ U (SND c) (SND d)
</pre>

<DT><span class="strong">ListOrd_THM</span>
<DD>
<pre>
⊢ ∀c. (ListOrd c [] [] = Equal) ∧ (∀b y. ListOrd c [] (b::y) = Less) ∧
      (∀a x. ListOrd c (a::x) [] = Greater) ∧
      ∀a x b y.
        ListOrd c (a::x) (b::y) =
        case apto c a b of
          Less => Less
        | Equal => ListOrd c x y
        | Greater => Greater
</pre>

<DT><span class="strong">NOT_EQ_LESS_IMP</span>
<DD>
<pre>
⊢ ∀cmp x y. apto cmp x y ≠ Less ⇒ (x = y) ∨ (apto cmp y x = Less)
</pre>

<DT><span class="strong">SLO_LEX</span>
<DD>
<pre>
⊢ ∀R V.
    StrongLinearOrder R ∧ StrongLinearOrder V ⇒ StrongLinearOrder (R LEX V)
</pre>

<DT><span class="strong">SLO_listorder</span>
<DD>
<pre>
⊢ ∀V. StrongLinearOrder V ⇒ StrongLinearOrder (listorder V)
</pre>

<DT><span class="strong">SPLIT_PAIRS</span>
<DD>
<pre>
⊢ ∀x y. (x = y) ⇔ (FST x = FST y) ∧ (SND x = SND y)
</pre>

<DT><span class="strong">STRORD_SLO</span>
<DD>
<pre>
⊢ ∀R. WeakLinearOrder R ⇒ StrongLinearOrder (STRORD R)
</pre>

<DT><span class="strong">StrongLinearOrderExists</span>
<DD>
<pre>
⊢ ∃R. StrongLinearOrder R
</pre>

<DT><span class="strong">StrongLinearOrder_LESS</span>
<DD>
<pre>
⊢ StrongLinearOrder $<
</pre>

<DT><span class="strong">StrongLinearOrder_of_TO_TO_of_LinearOrder</span>
<DD>
<pre>
⊢ ∀R. irreflexive R ⇒ (StrongLinearOrder_of_TO (TO_of_LinearOrder R) = R)
</pre>

<DT><span class="strong">StrongOrder_ALT</span>
<DD>
<pre>
⊢ ∀Z. StrongOrder Z ⇔ irreflexive Z ∧ transitive Z
</pre>

<DT><span class="strong">Strong_Strong_of</span>
<DD>
<pre>
⊢ ∀c. StrongLinearOrder (StrongLinearOrder_of_TO (apto c))
</pre>

<DT><span class="strong">Strong_Strong_of_TO</span>
<DD>
<pre>
⊢ ∀c. TotOrd c ⇒ StrongLinearOrder (StrongLinearOrder_of_TO c)
</pre>

<DT><span class="strong">Strong_toto_inv</span>
<DD>
<pre>
⊢ ∀c. StrongLinearOrder_of_TO (apto (toto_inv c)) =
      (StrongLinearOrder_of_TO (apto c))ᵀ
</pre>

<DT><span class="strong">Strong_toto_thm</span>
<DD>
<pre>
⊢ ∀r. StrongLinearOrder r ⇒
      (StrongLinearOrder_of_TO (apto (toto_of_LinearOrder r)) = r)
</pre>

<DT><span class="strong">Strongof_toto_STRORD</span>
<DD>
<pre>
⊢ ∀c. StrongLinearOrder_of_TO (apto c) =
      STRORD (WeakLinearOrder_of_TO (apto c))
</pre>

<DT><span class="strong">TO_11</span>
<DD>
<pre>
⊢ ∀r r'. TotOrd r ⇒ TotOrd r' ⇒ ((TO r = TO r') ⇔ (r = r'))
</pre>

<DT><span class="strong">TO_ListOrd</span>
<DD>
<pre>
⊢ ∀c. TotOrd (ListOrd c)
</pre>

<DT><span class="strong">TO_antisym</span>
<DD>
<pre>
⊢ ∀c. TotOrd c ⇒ ∀x y. (c x y = Greater) ⇔ (c y x = Less)
</pre>

<DT><span class="strong">TO_apto_ID</span>
<DD>
<pre>
⊢ ∀a. TO (apto a) = a
</pre>

<DT><span class="strong">TO_apto_TO_ID</span>
<DD>
<pre>
⊢ ∀r. TotOrd r ⇔ (apto (TO r) = r)
</pre>

<DT><span class="strong">TO_apto_TO_IMP</span>
<DD>
<pre>
⊢ ∀r. TotOrd r ⇒ (apto (TO r) = r)
</pre>

<DT><span class="strong">TO_charOrd</span>
<DD>
<pre>
⊢ TotOrd charOrd
</pre>

<DT><span class="strong">TO_cpn_eqn</span>
<DD>
<pre>
⊢ ∀c. TotOrd c ⇒
      (∀x y. (c x y = Less) ⇒ x ≠ y) ∧ (∀x y. (c x y = Greater) ⇒ x ≠ y) ∧
      ∀x y. (c x y = Equal) ⇒ (x = y)
</pre>

<DT><span class="strong">TO_equal_eq</span>
<DD>
<pre>
⊢ ∀c. TotOrd c ⇒ ∀x y. (c x y = Equal) ⇔ (x = y)
</pre>

<DT><span class="strong">TO_exists</span>
<DD>
<pre>
⊢ ∃x. TotOrd x
</pre>

<DT><span class="strong">TO_injection</span>
<DD>
<pre>
⊢ ∀cp. TotOrd cp ⇒ ∀f. ONE_ONE f ⇒ TotOrd (imageOrd f cp)
</pre>

<DT><span class="strong">TO_inv_Ord</span>
<DD>
<pre>
⊢ ∀r. TO_of_LinearOrder rᵀ = TO_inv (TO_of_LinearOrder r)
</pre>

<DT><span class="strong">TO_inv_TO_inv</span>
<DD>
<pre>
⊢ ∀c. TO_inv (TO_inv c) = c
</pre>

<DT><span class="strong">TO_lexTO</span>
<DD>
<pre>
⊢ ∀R V. TotOrd R ∧ TotOrd V ⇒ TotOrd (R lexTO V)
</pre>

<DT><span class="strong">TO_numOrd</span>
<DD>
<pre>
⊢ TotOrd numOrd
</pre>

<DT><span class="strong">TO_of_LinearOrder_LEX</span>
<DD>
<pre>
⊢ ∀R V.
    irreflexive R ∧ irreflexive V ⇒
    (TO_of_LinearOrder (R LEX V) =
     TO_of_LinearOrder R lexTO TO_of_LinearOrder V)
</pre>

<DT><span class="strong">TO_of_greater_ler</span>
<DD>
<pre>
⊢ ∀r. StrongLinearOrder r ⇒ ∀x y. (TO_of_LinearOrder r x y = Greater) ⇔ r y x
</pre>

<DT><span class="strong">TO_of_less_rel</span>
<DD>
<pre>
⊢ ∀r. StrongLinearOrder r ⇒ ∀x y. (TO_of_LinearOrder r x y = Less) ⇔ r x y
</pre>

<DT><span class="strong">TO_onto</span>
<DD>
<pre>
⊢ ∀a. ∃r. (a = TO r) ∧ TotOrd r
</pre>

<DT><span class="strong">TO_qk_numOrd</span>
<DD>
<pre>
⊢ TotOrd qk_numOrd
</pre>

<DT><span class="strong">TO_refl</span>
<DD>
<pre>
⊢ ∀c. TotOrd c ⇒ ∀x. c x x = Equal
</pre>

<DT><span class="strong">TotOrd_TO_of_LO</span>
<DD>
<pre>
⊢ ∀r. LinearOrder r ⇒ TotOrd (TO_of_LinearOrder r)
</pre>

<DT><span class="strong">TotOrd_TO_of_Strong</span>
<DD>
<pre>
⊢ ∀r. StrongLinearOrder r ⇒ TotOrd (TO_of_LinearOrder r)
</pre>

<DT><span class="strong">TotOrd_TO_of_Weak</span>
<DD>
<pre>
⊢ ∀r. WeakLinearOrder r ⇒ TotOrd (TO_of_LinearOrder r)
</pre>

<DT><span class="strong">TotOrd_apto</span>
<DD>
<pre>
⊢ ∀c. TotOrd (apto c)
</pre>

<DT><span class="strong">TotOrd_inv</span>
<DD>
<pre>
⊢ ∀c. TotOrd c ⇒ TotOrd (TO_inv c)
</pre>

<DT><span class="strong">Weak_Weak_of</span>
<DD>
<pre>
⊢ ∀c. WeakLinearOrder (WeakLinearOrder_of_TO (apto c))
</pre>

<DT><span class="strong">Weak_toto_inv</span>
<DD>
<pre>
⊢ ∀c. WeakLinearOrder_of_TO (apto (toto_inv c)) =
      (WeakLinearOrder_of_TO (apto c))ᵀ
</pre>

<DT><span class="strong">Weak_toto_thm</span>
<DD>
<pre>
⊢ ∀r. WeakLinearOrder r ⇒
      (WeakLinearOrder_of_TO (apto (toto_of_LinearOrder r)) = r)
</pre>

<DT><span class="strong">all_cpn_distinct</span>
<DD>
<pre>
⊢ (Less ≠ Equal ∧ Less ≠ Greater ∧ Equal ≠ Greater) ∧ Equal ≠ Less ∧
  Greater ≠ Less ∧ Greater ≠ Equal
</pre>

<DT><span class="strong">ap_qk_numto_thm</span>
<DD>
<pre>
⊢ apto qk_numto = qk_numOrd
</pre>

<DT><span class="strong">apcharto_thm</span>
<DD>
<pre>
⊢ apto charto = charOrd
</pre>

<DT><span class="strong">aplextoto</span>
<DD>
<pre>
⊢ ∀c v x1 x2 y1 y2.
    apto (c lextoto v) (x1,x2) (y1,y2) =
    case apto c x1 y1 of
      Less => Less
    | Equal => apto v x2 y2
    | Greater => Greater
</pre>

<DT><span class="strong">aplistoto</span>
<DD>
<pre>
⊢ ∀c. (apto (listoto c) [] [] = Equal) ∧
      (∀b y. apto (listoto c) [] (b::y) = Less) ∧
      (∀a x. apto (listoto c) (a::x) [] = Greater) ∧
      ∀a x b y.
        apto (listoto c) (a::x) (b::y) =
        case apto c a b of
          Less => Less
        | Equal => apto (listoto c) x y
        | Greater => Greater
</pre>

<DT><span class="strong">apnumto_thm</span>
<DD>
<pre>
⊢ apto numto = numOrd
</pre>

<DT><span class="strong">apto_inv</span>
<DD>
<pre>
⊢ ∀c. apto (toto_inv c) = TO_inv (apto c)
</pre>

<DT><span class="strong">charOrd_eq_lem</span>
<DD>
<pre>
⊢ ∀a b. (numOrd a b = Equal) ⇒ (charOrd (CHR a) (CHR b) = Equal)
</pre>

<DT><span class="strong">charOrd_gt_lem</span>
<DD>
<pre>
⊢ ∀a b.
    (numOrd a b = Greater) ⇒
    (a < 256 ⇔ T) ⇒
    (charOrd (CHR a) (CHR b) = Greater)
</pre>

<DT><span class="strong">charOrd_lt_lem</span>
<DD>
<pre>
⊢ ∀a b. (numOrd a b = Less) ⇒ (b < 256 ⇔ T) ⇒ (charOrd (CHR a) (CHR b) = Less)
</pre>

<DT><span class="strong">charOrd_thm</span>
<DD>
<pre>
⊢ charOrd = TO_of_LinearOrder char_lt
</pre>

<DT><span class="strong">datatype_num_dt</span>
<DD>
<pre>
⊢ DATATYPE (num_dt zer bit1 bit2)
</pre>

<DT><span class="strong">inv_TO</span>
<DD>
<pre>
⊢ ∀r. TotOrd r ⇒ (toto_inv (TO r) = TO (TO_inv r))
</pre>

<DT><span class="strong">lexTO_ALT</span>
<DD>
<pre>
⊢ ∀R V.
    TotOrd R ∧ TotOrd V ⇒
    ∀(r,u) (r',u').
      (R lexTO V) (r,u) (r',u') =
      case R r r' of Less => Less | Equal => V u u' | Greater => Greater
</pre>

<DT><span class="strong">lexTO_thm</span>
<DD>
<pre>
⊢ ∀R V.
    TotOrd R ∧ TotOrd V ⇒
    ∀x y.
      (R lexTO V) x y =
      case R (FST x) (FST y) of
        Less => Less
      | Equal => V (SND x) (SND y)
      | Greater => Greater
</pre>

<DT><span class="strong">listorder</span>
<DD>
<pre>
⊢ (∀l V. listorder V l [] ⇔ F) ∧ (∀s m V. listorder V [] (s::m) ⇔ T) ∧
  ∀s r m l V. listorder V (r::l) (s::m) ⇔ V r s ∨ (r = s) ∧ listorder V l m
</pre>

<DT><span class="strong">listorder_ind</span>
<DD>
<pre>
⊢ ∀P. (∀V l. P V l []) ∧ (∀V s m. P V [] (s::m)) ∧
      (∀V r l s m. P V l m ⇒ P V (r::l) (s::m)) ⇒
      ∀v v1 v2. P v v1 v2
</pre>

<DT><span class="strong">num_dtOrd</span>
<DD>
<pre>
⊢ (num_dtOrd zer zer = Equal) ∧ (∀x. num_dtOrd zer (bit1 x) = Less) ∧
  (∀x. num_dtOrd zer (bit2 x) = Less) ∧
  (∀x. num_dtOrd (bit1 x) zer = Greater) ∧
  (∀x. num_dtOrd (bit2 x) zer = Greater) ∧
  (∀y x. num_dtOrd (bit1 x) (bit2 y) = Less) ∧
  (∀y x. num_dtOrd (bit2 x) (bit1 y) = Greater) ∧
  (∀y x. num_dtOrd (bit1 x) (bit1 y) = num_dtOrd x y) ∧
  ∀y x. num_dtOrd (bit2 x) (bit2 y) = num_dtOrd x y
</pre>

<DT><span class="strong">num_dtOrd_ind</span>
<DD>
<pre>
⊢ ∀P. P zer zer ∧ (∀x. P zer (bit1 x)) ∧ (∀x. P zer (bit2 x)) ∧
      (∀x. P (bit1 x) zer) ∧ (∀x. P (bit2 x) zer) ∧
      (∀x y. P (bit1 x) (bit2 y)) ∧ (∀x y. P (bit2 x) (bit1 y)) ∧
      (∀x y. P x y ⇒ P (bit1 x) (bit1 y)) ∧
      (∀x y. P x y ⇒ P (bit2 x) (bit2 y)) ⇒
      ∀v v1. P v v1
</pre>

<DT><span class="strong">num_dt_11</span>
<DD>
<pre>
⊢ (∀a a'. (bit1 a = bit1 a') ⇔ (a = a')) ∧
  ∀a a'. (bit2 a = bit2 a') ⇔ (a = a')
</pre>

<DT><span class="strong">num_dt_Axiom</span>
<DD>
<pre>
⊢ ∀f0 f1 f2. ∃fn.
    (fn zer = f0) ∧ (∀a. fn (bit1 a) = f1 a (fn a)) ∧
    ∀a. fn (bit2 a) = f2 a (fn a)
</pre>

<DT><span class="strong">num_dt_case_cong</span>
<DD>
<pre>
⊢ ∀M M' v f f1.
    (M = M') ∧ ((M' = zer) ⇒ (v = v')) ∧ (∀a. (M' = bit1 a) ⇒ (f a = f' a)) ∧
    (∀a. (M' = bit2 a) ⇒ (f1 a = f1' a)) ⇒
    (num_dt_CASE M v f f1 = num_dt_CASE M' v' f' f1')
</pre>

<DT><span class="strong">num_dt_case_eq</span>
<DD>
<pre>
⊢ (num_dt_CASE x v f f1 = v') ⇔
  (x = zer) ∧ (v = v') ∨ (∃n. (x = bit1 n) ∧ (f n = v')) ∨
  ∃n. (x = bit2 n) ∧ (f1 n = v')
</pre>

<DT><span class="strong">num_dt_distinct</span>
<DD>
<pre>
⊢ (∀a. zer ≠ bit1 a) ∧ (∀a. zer ≠ bit2 a) ∧ ∀a' a. bit1 a ≠ bit2 a'
</pre>

<DT><span class="strong">num_dt_induction</span>
<DD>
<pre>
⊢ ∀P. P zer ∧ (∀n. P n ⇒ P (bit1 n)) ∧ (∀n. P n ⇒ P (bit2 n)) ⇒ ∀n. P n
</pre>

<DT><span class="strong">num_dt_nchotomy</span>
<DD>
<pre>
⊢ ∀nn. (nn = zer) ∨ (∃n. nn = bit1 n) ∨ ∃n. nn = bit2 n
</pre>

<DT><span class="strong">numeralOrd</span>
<DD>
<pre>
⊢ ∀x y.
    (numOrd ZERO ZERO = Equal) ∧ (numOrd ZERO (BIT1 y) = Less) ∧
    (numOrd ZERO (BIT2 y) = Less) ∧ (numOrd (BIT1 x) ZERO = Greater) ∧
    (numOrd (BIT2 x) ZERO = Greater) ∧
    (numOrd (BIT1 x) (BIT1 y) = numOrd x y) ∧
    (numOrd (BIT2 x) (BIT2 y) = numOrd x y) ∧
    (numOrd (BIT1 x) (BIT2 y) =
     case numOrd x y of Less => Less | Equal => Less | Greater => Greater) ∧
    (numOrd (BIT2 x) (BIT1 y) =
     case numOrd x y of Less => Less | Equal => Greater | Greater => Greater)
</pre>

<DT><span class="strong">onto_apto</span>
<DD>
<pre>
⊢ ∀r. TotOrd r ⇔ ∃a. r = apto a
</pre>

<DT><span class="strong">pre_aplextoto</span>
<DD>
<pre>
⊢ ∀c v x y.
    apto (c lextoto v) x y =
    case apto c (FST x) (FST y) of
      Less => Less
    | Equal => apto v (SND x) (SND y)
    | Greater => Greater
</pre>

<DT><span class="strong">qk_numeralOrd</span>
<DD>
<pre>
⊢ ∀x y.
    (qk_numOrd ZERO ZERO = Equal) ∧ (qk_numOrd ZERO (BIT1 y) = Less) ∧
    (qk_numOrd ZERO (BIT2 y) = Less) ∧ (qk_numOrd (BIT1 x) ZERO = Greater) ∧
    (qk_numOrd (BIT2 x) ZERO = Greater) ∧
    (qk_numOrd (BIT1 x) (BIT1 y) = qk_numOrd x y) ∧
    (qk_numOrd (BIT2 x) (BIT2 y) = qk_numOrd x y) ∧
    (qk_numOrd (BIT1 x) (BIT2 y) = Less) ∧
    (qk_numOrd (BIT2 x) (BIT1 y) = Greater)
</pre>

<DT><span class="strong">totoEEtrans</span>
<DD>
<pre>
⊢ ∀c x y z.
    ((apto c x y = Equal) ∧ (apto c y z = Equal) ⇒ (apto c x z = Equal)) ∧
    ((apto c x y = Equal) ∧ (apto c z y = Equal) ⇒ (apto c x z = Equal))
</pre>

<DT><span class="strong">totoELtrans</span>
<DD>
<pre>
⊢ ∀c x y z. (apto c x y = Equal) ∧ (apto c y z = Less) ⇒ (apto c x z = Less)
</pre>

<DT><span class="strong">totoGGtrans</span>
<DD>
<pre>
⊢ ∀c x y z.
    (apto c y x = Greater) ∧ (apto c z y = Greater) ⇒ (apto c x z = Less)
</pre>

<DT><span class="strong">totoGLtrans</span>
<DD>
<pre>
⊢ ∀c x y z. (apto c y x = Greater) ∧ (apto c y z = Less) ⇒ (apto c x z = Less)
</pre>

<DT><span class="strong">totoLEtrans</span>
<DD>
<pre>
⊢ ∀c x y z. (apto c x y = Less) ∧ (apto c y z = Equal) ⇒ (apto c x z = Less)
</pre>

<DT><span class="strong">totoLGtrans</span>
<DD>
<pre>
⊢ ∀c x y z. (apto c x y = Less) ∧ (apto c z y = Greater) ⇒ (apto c x z = Less)
</pre>

<DT><span class="strong">totoLLtrans</span>
<DD>
<pre>
⊢ ∀c x y z. (apto c x y = Less) ∧ (apto c y z = Less) ⇒ (apto c x z = Less)
</pre>

<DT><span class="strong">toto_Strong_thm</span>
<DD>
<pre>
⊢ ∀c. toto_of_LinearOrder (StrongLinearOrder_of_TO (apto c)) = c
</pre>

<DT><span class="strong">toto_Weak_thm</span>
<DD>
<pre>
⊢ ∀c. toto_of_LinearOrder (WeakLinearOrder_of_TO (apto c)) = c
</pre>

<DT><span class="strong">toto_antisym</span>
<DD>
<pre>
⊢ ∀c x y. (apto c x y = Greater) ⇔ (apto c y x = Less)
</pre>

<DT><span class="strong">toto_cpn_eqn</span>
<DD>
<pre>
⊢ (∀c x y. (apto c x y = Equal) ⇒ (x = y)) ∧
  (∀c x y. (apto c x y = Less) ⇒ x ≠ y) ∧
  ∀c x y. (apto c x y = Greater) ⇒ x ≠ y
</pre>

<DT><span class="strong">toto_equal_eq</span>
<DD>
<pre>
⊢ ∀c x y. (apto c x y = Equal) ⇔ (x = y)
</pre>

<DT><span class="strong">toto_equal_imp</span>
<DD>
<pre>
⊢ ∀cmp phi.
    LinearOrder phi ∧ (cmp = toto_of_LinearOrder phi) ⇒
    ∀x y. ((x = y) ⇔ T) ⇒ (apto cmp x y = Equal)
</pre>

<DT><span class="strong">toto_equal_imp_eq</span>
<DD>
<pre>
⊢ ∀c x y. (apto c x y = Equal) ⇒ (x = y)
</pre>

<DT><span class="strong">toto_equal_sym</span>
<DD>
<pre>
⊢ ∀c x y. (apto c x y = Equal) ⇔ (apto c y x = Equal)
</pre>

<DT><span class="strong">toto_glneq</span>
<DD>
<pre>
⊢ (∀c x y. (apto c x y = Less) ⇒ x ≠ y) ∧
  ∀c x y. (apto c x y = Greater) ⇒ x ≠ y
</pre>

<DT><span class="strong">toto_inv_toto_inv</span>
<DD>
<pre>
⊢ ∀c. toto_inv (toto_inv c) = c
</pre>

<DT><span class="strong">toto_not_less_refl</span>
<DD>
<pre>
⊢ ∀cmp h. (apto cmp h h = Less) ⇔ F
</pre>

<DT><span class="strong">toto_refl</span>
<DD>
<pre>
⊢ ∀c x. apto c x x = Equal
</pre>

<DT><span class="strong">toto_swap_cases</span>
<DD>
<pre>
⊢ ∀c x y.
    apto c y x =
    case apto c x y of Less => Greater | Equal => Equal | Greater => Less
</pre>

<DT><span class="strong">toto_thm</span>
<DD>
<pre>
⊢ ∀c. (∀x y. (apto c x y = Equal) ⇔ (x = y)) ∧
      (∀x y. (apto c x y = Greater) ⇔ (apto c y x = Less)) ∧
      ∀x y z. (apto c x y = Less) ∧ (apto c y z = Less) ⇒ (apto c x z = Less)
</pre>

<DT><span class="strong">toto_trans_less</span>
<DD>
<pre>
⊢ (∀c x y z. (apto c x y = Less) ∧ (apto c y z = Less) ⇒ (apto c x z = Less)) ∧
  (∀c x y z.
     (apto c x y = Less) ∧ (apto c z y = Greater) ⇒ (apto c x z = Less)) ∧
  (∀c x y z.
     (apto c y x = Greater) ∧ (apto c z y = Greater) ⇒ (apto c x z = Less)) ∧
  (∀c x y z.
     (apto c y x = Greater) ∧ (apto c y z = Less) ⇒ (apto c x z = Less)) ∧
  (∀c x y z. (apto c x y = Less) ∧ (apto c y z = Equal) ⇒ (apto c x z = Less)) ∧
  ∀c x y z. (apto c x y = Equal) ∧ (apto c y z = Less) ⇒ (apto c x z = Less)
</pre>

<DT><span class="strong">toto_unequal_imp</span>
<DD>
<pre>
⊢ ∀cmp phi.
    LinearOrder phi ∧ (cmp = toto_of_LinearOrder phi) ⇒
    ∀x y.
      ((x = y) ⇔ F) ⇒
      if phi x y then apto cmp x y = Less else apto cmp x y = Greater
</pre>

<DT><span class="strong">trichotomous_ALT</span>
<DD>
<pre>
⊢ ∀R. trichotomous R ⇔ ∀x y. ¬R x y ∧ ¬R y x ⇒ (x = y)
</pre>

</DL>



<hr>
</body>
</html>
