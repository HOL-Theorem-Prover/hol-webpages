<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: fcp</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "fcp"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "indexedListsTheory.html"><span class="strong">indexedLists</span></a>&nbsp;&nbsp;
    <a href = "patternMatchesTheory.html"><span class="strong">patternMatches</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Type <th> Arity<tr><td> <span class="strong">bit0</span> <td> 1
    <tr><td> <span class="strong">bit1</span> <td> 1
    <tr><td> <span class="strong">cart</span> <td> 2
    <tr><td> <span class="strong">finite_image</span> <td> 1
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">:+</span>
    <td>
    :num -> Î± -> Î±[Î²] -> Î±[Î²]
    <tr><td> <span class="strong">BIT0A</span> <td> :Î± -> Î± bit0
    <tr><td> <span class="strong">BIT0B</span> <td> :Î± -> Î± bit0
    <tr><td> <span class="strong">BIT1A</span> <td> :Î± -> Î± bit1
    <tr><td> <span class="strong">BIT1B</span> <td> :Î± -> Î± bit1
    <tr><td> <span class="strong">BIT1C</span> <td> :Î± bit1
    <tr><td> <span class="strong">FCP</span> <td> :(num -> Î±) -> Î±[Î²]
    <tr><td>
    <span class="strong">FCP_CONCAT</span>
    <td>
    :Î±[Î²] -> Î±[Î³] -> Î±[Î² + Î³]
    <tr><td> <span class="strong">FCP_CONS</span> <td> :Î± -> Î±[Î²] -> Î±[Î³]
    <tr><td>
    <span class="strong">FCP_EVERY</span>
    <td>
    :(Î² -> bool) -> Î²[Î±] -> bool
    <tr><td>
    <span class="strong">FCP_EXISTS</span>
    <td>
    :(Î² -> bool) -> Î²[Î±] -> bool
    <tr><td>
    <span class="strong">FCP_FOLD</span>
    <td>
    :(Î² -> Î± -> Î²) -> Î² -> Î±[Î³] -> Î²
    <tr><td> <span class="strong">FCP_FST</span> <td> :Î±[Î² + Î³] -> Î±[Î²]
    <tr><td> <span class="strong">FCP_HD</span> <td> :Î±[Î²] -> Î±
    <tr><td>
    <span class="strong">FCP_MAP</span>
    <td>
    :(Î± -> Î²) -> Î±[Î³] -> Î²[Î³]
    <tr><td> <span class="strong">FCP_SND</span> <td> :Î±[Î² + Î³] -> Î±[Î³]
    <tr><td> <span class="strong">FCP_TL</span> <td> :Î±[Î³] -> Î±[Î²]
    <tr><td>
    <span class="strong">FCP_ZIP</span>
    <td>
    :Î±[Î²] -> Î³[Î²] -> (Î± # Î³)[Î²]
    <tr><td> <span class="strong">L2V</span> <td> :Î± list -> Î±[Î²]
    <tr><td> <span class="strong">V2L</span> <td> :Î±[Î²] -> Î± list
    <tr><td>
    <span class="strong">bit0_CASE</span>
    <td>
    :Î± bit0 -> (Î± -> Î²) -> (Î± -> Î²) -> Î²
    <tr><td>
    <span class="strong">bit0_size</span>
    <td>
    :(Î± -> num) -> Î± bit0 -> num
    <tr><td>
    <span class="strong">bit1_CASE</span>
    <td>
    :Î± bit1 -> (Î± -> Î²) -> (Î± -> Î²) -> Î² -> Î²
    <tr><td>
    <span class="strong">bit1_size</span>
    <td>
    :(Î± -> num) -> Î± bit1 -> num
    <tr><td>
    <span class="strong">dest_cart</span>
    <td>
    :Î±[Î²] -> Î² finite_image -> Î±
    <tr><td>
    <span class="strong">dest_finite_image</span>
    <td>
    :Î± finite_image -> Î±
    <tr><td> <span class="strong">dimindex</span> <td> :Î± itself -> num
    <tr><td>
    <span class="strong">fcp_CASE</span>
    <td>
    :Î±[Î²] -> ((Î² finite_image -> Î±) -> Î³) -> Î³
    <tr><td> <span class="strong">fcp_index</span> <td> :Î±[Î²] -> num -> Î±
    <tr><td> <span class="strong">finite_index</span> <td> :num -> Î±
    <tr><td>
    <span class="strong">mk_cart</span>
    <td>
    :(Î² finite_image -> Î±) -> Î±[Î²]
    <tr><td>
    <span class="strong">mk_finite_image</span>
    <td>
    :Î± -> Î± finite_image
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">FCP</span>
<DD>
<pre>
âŠ¢ $FCP = (Î»g. @f. âˆ€i. i < dimindex (:Î²) â‡’ (f ' i = g i))
</pre>

<DT><span class="strong">FCP_CONCAT_def</span>
<DD>
<pre>
âŠ¢ âˆ€a b.
    FCP_CONCAT a b =
    FCP i. if i < dimindex (:Î³) then b ' i else a ' (i âˆ’ dimindex (:Î³))
</pre>

<DT><span class="strong">FCP_CONS_def</span>
<DD>
<pre>
âŠ¢ âˆ€h v. FCP_CONS h v = (0 :+ h) (FCP i. v ' (PRE i))
</pre>

<DT><span class="strong">FCP_EVERY_def</span>
<DD>
<pre>
âŠ¢ âˆ€P v. FCP_EVERY P v â‡” âˆ€i. dimindex (:Î±) â‰¤ i âˆ¨ P (v ' i)
</pre>

<DT><span class="strong">FCP_EXISTS_def</span>
<DD>
<pre>
âŠ¢ âˆ€P v. FCP_EXISTS P v â‡” âˆƒi. i < dimindex (:Î±) âˆ§ P (v ' i)
</pre>

<DT><span class="strong">FCP_FOLD_def</span>
<DD>
<pre>
âŠ¢ âˆ€f i v. FCP_FOLD f i v = FOLDL f i (V2L v)
</pre>

<DT><span class="strong">FCP_FST_def</span>
<DD>
<pre>
âŠ¢ âˆ€v. FCP_FST v = FCP i. v ' (i + dimindex (:Î³))
</pre>

<DT><span class="strong">FCP_HD_def</span>
<DD>
<pre>
âŠ¢ âˆ€v. FCP_HD v = v ' 0
</pre>

<DT><span class="strong">FCP_MAP_def</span>
<DD>
<pre>
âŠ¢ âˆ€f v. FCP_MAP f v = FCP i. f (v ' i)
</pre>

<DT><span class="strong">FCP_SND_def</span>
<DD>
<pre>
âŠ¢ âˆ€v. FCP_SND v = FCP i. v ' i
</pre>

<DT><span class="strong">FCP_TL_def</span>
<DD>
<pre>
âŠ¢ âˆ€v. FCP_TL v = FCP i. v ' (SUC i)
</pre>

<DT><span class="strong">FCP_UPDATE_def</span>
<DD>
<pre>
âŠ¢ âˆ€a b. a :+ b = (Î»m. FCP c. if a = c then b else m ' c)
</pre>

<DT><span class="strong">FCP_ZIP_def</span>
<DD>
<pre>
âŠ¢ âˆ€a b. FCP_ZIP a b = FCP i. (a ' i,b ' i)
</pre>

<DT><span class="strong">L2V_def</span>
<DD>
<pre>
âŠ¢ âˆ€L. L2V L = FCP i. EL i L
</pre>

<DT><span class="strong">V2L_def</span>
<DD>
<pre>
âŠ¢ âˆ€v. V2L v = GENLIST ($' v) (dimindex (:Î²))
</pre>

<DT><span class="strong">bit0_TY_DEF</span>
<DD>
<pre>
âŠ¢ âˆƒrep.
    TYPE_DEFINITION
      (Î»a0.
           âˆ€ $var$('bit0').
             (âˆ€a0.
                (âˆƒa. a0 = (Î»a. ind_type$CONSTR 0 a (Î»n. ind_type$BOTTOM)) a) âˆ¨
                (âˆƒa. a0 =
                     (Î»a. ind_type$CONSTR (SUC 0) a (Î»n. ind_type$BOTTOM)) a) â‡’
                $var$('bit0') a0) â‡’
             $var$('bit0') a0) rep
</pre>

<DT><span class="strong">bit0_case_def</span>
<DD>
<pre>
âŠ¢ (âˆ€a f f1. bit0_CASE (BIT0A a) f f1 = f a) âˆ§
  âˆ€a f f1. bit0_CASE (BIT0B a) f f1 = f1 a
</pre>

<DT><span class="strong">bit0_size_def</span>
<DD>
<pre>
âŠ¢ (âˆ€f a. bit0_size f (BIT0A a) = 1 + f a) âˆ§
  âˆ€f a. bit0_size f (BIT0B a) = 1 + f a
</pre>

<DT><span class="strong">bit1_TY_DEF</span>
<DD>
<pre>
âŠ¢ âˆƒrep.
    TYPE_DEFINITION
      (Î»a0.
           âˆ€ $var$('bit1').
             (âˆ€a0.
                (âˆƒa. a0 = (Î»a. ind_type$CONSTR 0 a (Î»n. ind_type$BOTTOM)) a) âˆ¨
                (âˆƒa. a0 =
                     (Î»a. ind_type$CONSTR (SUC 0) a (Î»n. ind_type$BOTTOM)) a) âˆ¨
                (a0 = ind_type$CONSTR (SUC (SUC 0)) ARB (Î»n. ind_type$BOTTOM)) â‡’
                $var$('bit1') a0) â‡’
             $var$('bit1') a0) rep
</pre>

<DT><span class="strong">bit1_case_def</span>
<DD>
<pre>
âŠ¢ (âˆ€a f f1 v. bit1_CASE (BIT1A a) f f1 v = f a) âˆ§
  (âˆ€a f f1 v. bit1_CASE (BIT1B a) f f1 v = f1 a) âˆ§
  âˆ€f f1 v. bit1_CASE BIT1C f f1 v = v
</pre>

<DT><span class="strong">bit1_size_def</span>
<DD>
<pre>
âŠ¢ (âˆ€f a. bit1_size f (BIT1A a) = 1 + f a) âˆ§
  (âˆ€f a. bit1_size f (BIT1B a) = 1 + f a) âˆ§ âˆ€f. bit1_size f BIT1C = 0
</pre>

<DT><span class="strong">cart_TY_DEF</span>
<DD>
<pre>
âŠ¢ âˆƒrep. TYPE_DEFINITION (Î»f. T) rep
</pre>

<DT><span class="strong">cart_tybij</span>
<DD>
<pre>
âŠ¢ (âˆ€a. mk_cart (dest_cart a) = a) âˆ§
  âˆ€r. (Î»f. T) r â‡” (dest_cart (mk_cart r) = r)
</pre>

<DT><span class="strong">dimindex_def</span>
<DD>
<pre>
âŠ¢ dimindex (:Î±) = if FINITE ğ•Œ(:Î±) then CARD ğ•Œ(:Î±) else 1
</pre>

<DT><span class="strong">fcp_case_def</span>
<DD>
<pre>
âŠ¢ âˆ€h f. fcp_CASE (mk_cart h) f = f h
</pre>

<DT><span class="strong">fcp_index</span>
<DD>
<pre>
âŠ¢ âˆ€x i. x ' i = dest_cart x (finite_index i)
</pre>

<DT><span class="strong">finite_image_TY_DEF</span>
<DD>
<pre>
âŠ¢ âˆƒrep. TYPE_DEFINITION (Î»x. (x = ARB) âˆ¨ FINITE ğ•Œ(:Î±)) rep
</pre>

<DT><span class="strong">finite_image_tybij</span>
<DD>
<pre>
âŠ¢ (âˆ€a. mk_finite_image (dest_finite_image a) = a) âˆ§
  âˆ€r. (Î»x. (x = ARB) âˆ¨ FINITE ğ•Œ(:Î±)) r â‡”
      (dest_finite_image (mk_finite_image r) = r)
</pre>

<DT><span class="strong">finite_index_def</span>
<DD>
<pre>
âŠ¢ finite_index = @f. âˆ€x. âˆƒ!n. n < dimindex (:Î±) âˆ§ (f n = x)
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">APPLY_FCP_UPDATE_ID</span>
<DD>
<pre>
âŠ¢ âˆ€m a. (a :+ m ' a) m = m
</pre>

<DT><span class="strong">CART_EQ</span>
<DD>
<pre>
âŠ¢ âˆ€x y. (x = y) â‡” âˆ€i. i < dimindex (:Î²) â‡’ (x ' i = y ' i)
</pre>

<DT><span class="strong">DIMINDEX_GE_1</span>
<DD>
<pre>
âŠ¢ 1 â‰¤ dimindex (:Î±)
</pre>

<DT><span class="strong">DIMINDEX_GT_0</span>
<DD>
<pre>
âŠ¢ 0 < dimindex (:Î±)
</pre>

<DT><span class="strong">DIMINDEX_NONZERO</span>
<DD>
<pre>
âŠ¢ dimindex (:Î±) â‰  0
</pre>

<DT><span class="strong">EL_V2L</span>
<DD>
<pre>
âŠ¢ âˆ€i v. i < dimindex (:Î²) â‡’ (EL i (V2L v) = v ' i)
</pre>

<DT><span class="strong">FCP_APPLY_UPDATE_THM</span>
<DD>
<pre>
âŠ¢ âˆ€m a w b.
    (a :+ w) m ' b =
    if b < dimindex (:Î²) then if a = b then w else m ' b
    else FAIL $' $var$(index out of range) ((a :+ w) m) b
</pre>

<DT><span class="strong">FCP_BETA</span>
<DD>
<pre>
âŠ¢ âˆ€i. i < dimindex (:Î²) â‡’ ($FCP g ' i = g i)
</pre>

<DT><span class="strong">FCP_CONCAT_11</span>
<DD>
<pre>
âŠ¢ âˆ€a b c d.
    FINITE ğ•Œ(:Î²) âˆ§ FINITE ğ•Œ(:Î³) âˆ§ (FCP_CONCAT a b = FCP_CONCAT c d) â‡’
    (a = c) âˆ§ (b = d)
</pre>

<DT><span class="strong">FCP_CONCAT_REDUCE</span>
<DD>
<pre>
âŠ¢ âˆ€x. FINITE ğ•Œ(:Î²) âˆ§ FINITE ğ•Œ(:Î³) â‡’ (FCP_CONCAT (FCP_FST x) (FCP_SND x) = x)
</pre>

<DT><span class="strong">FCP_CONCAT_THM</span>
<DD>
<pre>
âŠ¢ âˆ€a b.
    FINITE ğ•Œ(:Î²) âˆ§ FINITE ğ•Œ(:Î³) â‡’
    (FCP_FST (FCP_CONCAT a b) = a) âˆ§ (FCP_SND (FCP_CONCAT a b) = b)
</pre>

<DT><span class="strong">FCP_CONS</span>
<DD>
<pre>
âŠ¢ âˆ€a v. FCP_CONS a v = L2V (a::V2L v)
</pre>

<DT><span class="strong">FCP_ETA</span>
<DD>
<pre>
âŠ¢ âˆ€g. (FCP i. g ' i) = g
</pre>

<DT><span class="strong">FCP_EVERY</span>
<DD>
<pre>
âŠ¢ âˆ€P v. FCP_EVERY P v â‡” EVERY P (V2L v)
</pre>

<DT><span class="strong">FCP_EXISTS</span>
<DD>
<pre>
âŠ¢ âˆ€P v. FCP_EXISTS P v â‡” EXISTS P (V2L v)
</pre>

<DT><span class="strong">FCP_HD</span>
<DD>
<pre>
âŠ¢ âˆ€v. FCP_HD v = HD (V2L v)
</pre>

<DT><span class="strong">FCP_MAP</span>
<DD>
<pre>
âŠ¢ âˆ€f v. FCP_MAP f v = L2V (MAP f (V2L v))
</pre>

<DT><span class="strong">FCP_TL</span>
<DD>
<pre>
âŠ¢ âˆ€v. 1 < dimindex (:Î²) âˆ§ (dimindex (:Î³) = dimindex (:Î²) âˆ’ 1) â‡’
      (FCP_TL v = L2V (TL (V2L v)))
</pre>

<DT><span class="strong">FCP_UNIQUE</span>
<DD>
<pre>
âŠ¢ âˆ€f g. (âˆ€i. i < dimindex (:Î²) â‡’ (f ' i = g i)) â‡” ($FCP g = f)
</pre>

<DT><span class="strong">FCP_UPDATE_COMMUTES</span>
<DD>
<pre>
âŠ¢ âˆ€m a b c d. a â‰  b â‡’ ((a :+ c) ((b :+ d) m) = (b :+ d) ((a :+ c) m))
</pre>

<DT><span class="strong">FCP_UPDATE_EQ</span>
<DD>
<pre>
âŠ¢ âˆ€m a b c. (a :+ c) ((a :+ b) m) = (a :+ c) m
</pre>

<DT><span class="strong">FCP_UPDATE_IMP_ID</span>
<DD>
<pre>
âŠ¢ âˆ€m a v. (m ' a = v) â‡’ ((a :+ v) m = m)
</pre>

<DT><span class="strong">LENGTH_V2L</span>
<DD>
<pre>
âŠ¢ âˆ€v. LENGTH (V2L v) = dimindex (:Î²)
</pre>

<DT><span class="strong">NOT_FINITE_IMP_dimindex_1</span>
<DD>
<pre>
âŠ¢ INFINITE ğ•Œ(:Î±) â‡’ (dimindex (:Î±) = 1)
</pre>

<DT><span class="strong">NULL_V2L</span>
<DD>
<pre>
âŠ¢ âˆ€v. Â¬NULL (V2L v)
</pre>

<DT><span class="strong">READ_L2V</span>
<DD>
<pre>
âŠ¢ âˆ€i a. i < dimindex (:Î²) â‡’ (L2V a ' i = EL i a)
</pre>

<DT><span class="strong">READ_TL</span>
<DD>
<pre>
âŠ¢ âˆ€i a. i < dimindex (:Î²) â‡’ (FCP_TL a ' i = a ' (SUC i))
</pre>

<DT><span class="strong">V2L_L2V</span>
<DD>
<pre>
âŠ¢ âˆ€x. (dimindex (:Î²) = LENGTH x) â‡’ (V2L (L2V x) = x)
</pre>

<DT><span class="strong">bit0_11</span>
<DD>
<pre>
âŠ¢ (âˆ€a a'. (BIT0A a = BIT0A a') â‡” (a = a')) âˆ§
  âˆ€a a'. (BIT0B a = BIT0B a') â‡” (a = a')
</pre>

<DT><span class="strong">bit0_Axiom</span>
<DD>
<pre>
âŠ¢ âˆ€f0 f1. âˆƒfn. (âˆ€a. fn (BIT0A a) = f0 a) âˆ§ âˆ€a. fn (BIT0B a) = f1 a
</pre>

<DT><span class="strong">bit0_case_cong</span>
<DD>
<pre>
âŠ¢ âˆ€M M' f f1.
    (M = M') âˆ§ (âˆ€a. (M' = BIT0A a) â‡’ (f a = f' a)) âˆ§
    (âˆ€a. (M' = BIT0B a) â‡’ (f1 a = f1' a)) â‡’
    (bit0_CASE M f f1 = bit0_CASE M' f' f1')
</pre>

<DT><span class="strong">bit0_case_eq</span>
<DD>
<pre>
âŠ¢ (bit0_CASE x f f1 = v) â‡”
  (âˆƒa. (x = BIT0A a) âˆ§ (f a = v)) âˆ¨ âˆƒa. (x = BIT0B a) âˆ§ (f1 a = v)
</pre>

<DT><span class="strong">bit0_distinct</span>
<DD>
<pre>
âŠ¢ âˆ€a' a. BIT0A a â‰  BIT0B a'
</pre>

<DT><span class="strong">bit0_induction</span>
<DD>
<pre>
âŠ¢ âˆ€P. (âˆ€a. P (BIT0A a)) âˆ§ (âˆ€a. P (BIT0B a)) â‡’ âˆ€b. P b
</pre>

<DT><span class="strong">bit0_nchotomy</span>
<DD>
<pre>
âŠ¢ âˆ€bb. (âˆƒa. bb = BIT0A a) âˆ¨ âˆƒa. bb = BIT0B a
</pre>

<DT><span class="strong">bit1_11</span>
<DD>
<pre>
âŠ¢ (âˆ€a a'. (BIT1A a = BIT1A a') â‡” (a = a')) âˆ§
  âˆ€a a'. (BIT1B a = BIT1B a') â‡” (a = a')
</pre>

<DT><span class="strong">bit1_Axiom</span>
<DD>
<pre>
âŠ¢ âˆ€f0 f1 f2. âˆƒfn.
    (âˆ€a. fn (BIT1A a) = f0 a) âˆ§ (âˆ€a. fn (BIT1B a) = f1 a) âˆ§ (fn BIT1C = f2)
</pre>

<DT><span class="strong">bit1_case_cong</span>
<DD>
<pre>
âŠ¢ âˆ€M M' f f1 v.
    (M = M') âˆ§ (âˆ€a. (M' = BIT1A a) â‡’ (f a = f' a)) âˆ§
    (âˆ€a. (M' = BIT1B a) â‡’ (f1 a = f1' a)) âˆ§ ((M' = BIT1C) â‡’ (v = v')) â‡’
    (bit1_CASE M f f1 v = bit1_CASE M' f' f1' v')
</pre>

<DT><span class="strong">bit1_case_eq</span>
<DD>
<pre>
âŠ¢ (bit1_CASE x f f1 v = v') â‡”
  (âˆƒa. (x = BIT1A a) âˆ§ (f a = v')) âˆ¨ (âˆƒa. (x = BIT1B a) âˆ§ (f1 a = v')) âˆ¨
  (x = BIT1C) âˆ§ (v = v')
</pre>

<DT><span class="strong">bit1_distinct</span>
<DD>
<pre>
âŠ¢ (âˆ€a' a. BIT1A a â‰  BIT1B a') âˆ§ (âˆ€a. BIT1A a â‰  BIT1C) âˆ§ âˆ€a. BIT1B a â‰  BIT1C
</pre>

<DT><span class="strong">bit1_induction</span>
<DD>
<pre>
âŠ¢ âˆ€P. (âˆ€a. P (BIT1A a)) âˆ§ (âˆ€a. P (BIT1B a)) âˆ§ P BIT1C â‡’ âˆ€b. P b
</pre>

<DT><span class="strong">bit1_nchotomy</span>
<DD>
<pre>
âŠ¢ âˆ€bb. (âˆƒa. bb = BIT1A a) âˆ¨ (âˆƒa. bb = BIT1B a) âˆ¨ (bb = BIT1C)
</pre>

<DT><span class="strong">card_dimindex</span>
<DD>
<pre>
âŠ¢ FINITE ğ•Œ(:Î±) â‡’ (CARD ğ•Œ(:Î±) = dimindex (:Î±))
</pre>

<DT><span class="strong">datatype_bit0</span>
<DD>
<pre>
âŠ¢ DATATYPE (bit0 BIT0A BIT0B)
</pre>

<DT><span class="strong">datatype_bit1</span>
<DD>
<pre>
âŠ¢ DATATYPE (bit1 BIT1A BIT1B BIT1C)
</pre>

<DT><span class="strong">fcp_Axiom</span>
<DD>
<pre>
âŠ¢ âˆ€f. âˆƒg. âˆ€h. g (mk_cart h) = f h
</pre>

<DT><span class="strong">fcp_ind</span>
<DD>
<pre>
âŠ¢ âˆ€P. (âˆ€f. P (mk_cart f)) â‡’ âˆ€a. P a
</pre>

<DT><span class="strong">fcp_subst_comp</span>
<DD>
<pre>
âŠ¢ âˆ€a b f. (x :+ y) ($FCP f) = FCP c. if x = c then y else f c
</pre>

<DT><span class="strong">finite_bit0</span>
<DD>
<pre>
âŠ¢ FINITE ğ•Œ(:Î± bit0) â‡” FINITE ğ•Œ(:Î±)
</pre>

<DT><span class="strong">finite_bit1</span>
<DD>
<pre>
âŠ¢ FINITE ğ•Œ(:Î± bit1) â‡” FINITE ğ•Œ(:Î±)
</pre>

<DT><span class="strong">finite_one</span>
<DD>
<pre>
âŠ¢ FINITE ğ•Œ(:unit)
</pre>

<DT><span class="strong">finite_sum</span>
<DD>
<pre>
âŠ¢ FINITE ğ•Œ(:Î± + Î²) â‡” FINITE ğ•Œ(:Î±) âˆ§ FINITE ğ•Œ(:Î²)
</pre>

<DT><span class="strong">index_bit0</span>
<DD>
<pre>
âŠ¢ dimindex (:Î± bit0) = if FINITE ğ•Œ(:Î±) then 2 * dimindex (:Î±) else 1
</pre>

<DT><span class="strong">index_bit1</span>
<DD>
<pre>
âŠ¢ dimindex (:Î± bit1) = if FINITE ğ•Œ(:Î±) then 2 * dimindex (:Î±) + 1 else 1
</pre>

<DT><span class="strong">index_comp</span>
<DD>
<pre>
âŠ¢ âˆ€f n.
    $FCP f ' n =
    if n < dimindex (:Î²) then f n
    else FAIL $' $var$(FCP out of bounds) ($FCP f) n
</pre>

<DT><span class="strong">index_one</span>
<DD>
<pre>
âŠ¢ dimindex (:unit) = 1
</pre>

<DT><span class="strong">index_sum</span>
<DD>
<pre>
âŠ¢ dimindex (:Î± + Î²) =
  if FINITE ğ•Œ(:Î±) âˆ§ FINITE ğ•Œ(:Î²) then dimindex (:Î±) + dimindex (:Î²) else 1
</pre>

</DL>



<hr>
</body>
</html>
