<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: itreeTau</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "itreeTau"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "alistTheory.html"><span class="strong">alist</span></a>&nbsp;&nbsp;
    <a href = "llistTheory.html"><span class="strong">llist</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Type <th> Arity<tr><td> <span class="strong">itree</span> <td> 3
    <tr><td> <span class="strong">itree_el</span> <td> 2
    <tr><td> <span class="strong">itree_next</span> <td> 4
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">Event</span>
    <td>
    :ε -> (ε, ς) itreeTau$itree_el
    <tr><td>
    <span class="strong">Ret</span>
    <td>
    :γ -> (α, β, γ) itreeTau$itree
    <tr><td>
    <span class="strong">Ret'</span>
    <td>
    :ς -> (α, ε, ς, 'seed) itreeTau$itree_next
    <tr><td>
    <span class="strong">Ret_rep</span>
    <td>
    :ς -> α list -> (β, ς) itreeTau$itree_el
    <tr><td>
    <span class="strong">Return</span>
    <td>
    :ς -> (ε, ς) itreeTau$itree_el
    <tr><td>
    <span class="strong">Silence</span>
    <td>
    :(ε, ς) itreeTau$itree_el
    <tr><td>
    <span class="strong">Tau</span>
    <td>
    :(α, β, γ) itreeTau$itree -> (α, β, γ) itreeTau$itree
    <tr><td>
    <span class="strong">Tau'</span>
    <td>
    :'seed -> (α, ε, ς, 'seed) itreeTau$itree_next
    <tr><td>
    <span class="strong">Tau_rep</span>
    <td>
    :(α option list -> (ε, ς) itreeTau$itree_el) ->
    α option list -> (ε, ς) itreeTau$itree_el
    <tr><td>
    <span class="strong">Vis</span>
    <td>
    :β -> (α -> (α, β, γ) itreeTau$itree) -> (α, β, γ) itreeTau$itree
    <tr><td>
    <span class="strong">Vis'</span>
    <td>
    :ε -> (α -> 'seed) -> (α, ε, ς, 'seed) itreeTau$itree_next
    <tr><td>
    <span class="strong">Vis_rep</span>
    <td>
    :β ->
    (α -> α option list -> (β, γ) itreeTau$itree_el) ->
    α option list -> (β, γ) itreeTau$itree_el
    <tr><td>
    <span class="strong">itree_CASE</span>
    <td>
    :(α, ε, ς) itreeTau$itree ->
    (ς -> β) ->
    ((α, ε, ς) itreeTau$itree -> β) ->
    (ε -> (α -> (α, ε, ς) itreeTau$itree) -> β) -> β
    <tr><td>
    <span class="strong">itree_abs</span>
    <td>
    :(α option list -> (ε, ς) itreeTau$itree_el) -> (α, ε, ς) itreeTau$itree
    <tr><td>
    <span class="strong">itree_el</span>
    <td>
    :(γ, α, β) itreeTau$itree -> γ option list -> (α, β) itreeTau$itree_el
    <tr><td>
    <span class="strong">itree_el_CASE</span>
    <td>
    :(ε, ς) itreeTau$itree_el -> (ε -> α) -> (ς -> α) -> α -> α
    <tr><td>
    <span class="strong">itree_el_size</span>
    <td>
    :(ε -> num) -> (ς -> num) -> (ε, ς) itreeTau$itree_el -> num
    <tr><td>
    <span class="strong">itree_next_CASE</span>
    <td>
    :(α, ε, ς, 'seed) itreeTau$itree_next ->
    (ς -> β) -> ('seed -> β) -> (ε -> (α -> 'seed) -> β) -> β
    <tr><td>
    <span class="strong">itree_next_size</span>
    <td>
    :(α -> num) ->
    (ε -> num) ->
    (ς -> num) ->
    ('seed -> num) -> (α, ε, ς, 'seed) itreeTau$itree_next -> num
    <tr><td>
    <span class="strong">itree_rep</span>
    <td>
    :(α, ε, ς) itreeTau$itree -> α option list -> (ε, ς) itreeTau$itree_el
    <tr><td>
    <span class="strong">itree_rep_ok</span>
    <td>
    :(α option list -> (ε, ς) itreeTau$itree_el) -> bool
    <tr><td>
    <span class="strong">itree_unfold</span>
    <td>
    :(δ -> (α, β, γ, δ) itreeTau$itree_next) -> δ -> (α, β, γ) itreeTau$itree
    <tr><td>
    <span class="strong">itree_unfold_path</span>
    <td>
    :(γ -> (δ, α, β, γ) itreeTau$itree_next) ->
    γ -> δ option list -> (α, β) itreeTau$itree_el
    <tr><td>
    <span class="strong">path_ok</span>
    <td>
    :α option list -> (α option list -> (ε, ς) itreeTau$itree_el) -> bool
    <tr><td> <span class="strong">spin</span> <td> :(α, β, γ) itreeTau$itree
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">itree_TY_DEF</span>
<DD>
<pre>
⊢ ∃rep. TYPE_DEFINITION itree_rep_ok rep
</pre>

<DT><span class="strong">itree_el_case_def</span>
<DD>
<pre>
⊢ (∀a f f1 v. itree_el_CASE (Event a) f f1 v = f a) ∧
  (∀a f f1 v. itree_el_CASE (Return a) f f1 v = f1 a) ∧
  ∀f f1 v. itree_el_CASE Silence f f1 v = v
</pre>

<DT><span class="strong">itree_el_size_def</span>
<DD>
<pre>
⊢ (∀f f1 a. itree_el_size f f1 (Event a) = 1 + f a) ∧
  (∀f f1 a. itree_el_size f f1 (Return a) = 1 + f1 a) ∧
  ∀f f1. itree_el_size f f1 Silence = 0
</pre>

<DT><span class="strong">itree_next_case_def</span>
<DD>
<pre>
⊢ (∀a f f1 f2. itree_next_CASE (Ret' a) f f1 f2 = f a) ∧
  (∀a f f1 f2. itree_next_CASE (Tau' a) f f1 f2 = f1 a) ∧
  ∀a0 a1 f f1 f2. itree_next_CASE (Vis' a0 a1) f f1 f2 = f2 a0 a1
</pre>

<DT><span class="strong">itree_next_size_def</span>
<DD>
<pre>
⊢ (∀f f1 f2 f3 a. itree_next_size f f1 f2 f3 (Ret' a) = 1 + f2 a) ∧
  (∀f f1 f2 f3 a. itree_next_size f f1 f2 f3 (Tau' a) = 1 + f3 a) ∧
  ∀f f1 f2 f3 a0 a1. itree_next_size f f1 f2 f3 (Vis' a0 a1) = 1 + f1 a0
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">Ret_11</span>
<DD>
<pre>
⊢ ∀x y. (Ret x = Ret y) ⇔ (x = y)
</pre>

<DT><span class="strong">Tau_11</span>
<DD>
<pre>
⊢ ∀x y. (Tau x = Tau y) ⇔ (x = y)
</pre>

<DT><span class="strong">Vis_11</span>
<DD>
<pre>
⊢ ∀x f y g. (Vis x f = Vis y g) ⇔ (x = y) ∧ (f = g)
</pre>

<DT><span class="strong">datatype_itree</span>
<DD>
<pre>
⊢ DATATYPE (itree Ret Tau Vis)
</pre>

<DT><span class="strong">datatype_itree_el</span>
<DD>
<pre>
⊢ DATATYPE (itree_el Event Return Silence)
</pre>

<DT><span class="strong">datatype_itree_next</span>
<DD>
<pre>
⊢ DATATYPE (itree_next Ret' Tau' Vis')
</pre>

<DT><span class="strong">itree_11</span>
<DD>
<pre>
⊢ (∀x y. (Ret x = Ret y) ⇔ (x = y)) ∧ (∀x y. (Tau x = Tau y) ⇔ (x = y)) ∧
  ∀x f y g. (Vis x f = Vis y g) ⇔ (x = y) ∧ (f = g)
</pre>

<DT><span class="strong">itree_CASE</span>
<DD>
<pre>
⊢ (itree_CASE (Ret r) ret tau vis = ret r) ∧
  (itree_CASE (Tau t) ret tau vis = tau t) ∧
  (itree_CASE (Vis a g) ret tau vis = vis a g)
</pre>

<DT><span class="strong">itree_CASE_cong</span>
<DD>
<pre>
⊢ ∀M M' ret tau vis ret' tau' vis'.
    (M = M') ∧ (∀x. (M' = Ret x) ⇒ (ret x = ret' x)) ∧
    (∀t. (M' = Tau t) ⇒ (tau t = tau' t)) ∧
    (∀a g. (M' = Vis a g) ⇒ (vis a g = vis' a g)) ⇒
    (itree_CASE M ret tau vis = itree_CASE M' ret' tau' vis')
</pre>

<DT><span class="strong">itree_CASE_eq</span>
<DD>
<pre>
⊢ (itree_CASE t ret tau vis = v) ⇔
  (∃r. (t = Ret r) ∧ (ret r = v)) ∨ (∃u. (t = Tau u) ∧ (tau u = v)) ∨
  ∃a g. (t = Vis a g) ∧ (vis a g = v)
</pre>

<DT><span class="strong">itree_bisimulation</span>
<DD>
<pre>
⊢ ∀t1 t2.
    (t1 = t2) ⇔
    ∃R. R t1 t2 ∧ (∀x t. R (Ret x) t ⇒ (t = Ret x)) ∧
        (∀u t. R (Tau u) t ⇒ ∃v. (t = Tau v) ∧ R u v) ∧
        ∀a f t. R (Vis a f) t ⇒ ∃b g. (t = Vis a g) ∧ ∀s. R (f s) (g s)
</pre>

<DT><span class="strong">itree_cases</span>
<DD>
<pre>
⊢ ∀t. (∃x. t = Ret x) ∨ (∃u. t = Tau u) ∨ ∃a g. t = Vis a g
</pre>

<DT><span class="strong">itree_distinct</span>
<DD>
<pre>
⊢ Ret x ≠ Tau t ∧ Ret x ≠ Vis e g ∧ Tau t ≠ Vis e g
</pre>

<DT><span class="strong">itree_el_11</span>
<DD>
<pre>
⊢ (∀a a'. (Event a = Event a') ⇔ (a = a')) ∧
  ∀a a'. (Return a = Return a') ⇔ (a = a')
</pre>

<DT><span class="strong">itree_el_Axiom</span>
<DD>
<pre>
⊢ ∀f0 f1 f2. ∃fn.
    (∀a. fn (Event a) = f0 a) ∧ (∀a. fn (Return a) = f1 a) ∧ (fn Silence = f2)
</pre>

<DT><span class="strong">itree_el_case_cong</span>
<DD>
<pre>
⊢ ∀M M' f f1 v.
    (M = M') ∧ (∀a. (M' = Event a) ⇒ (f a = f' a)) ∧
    (∀a. (M' = Return a) ⇒ (f1 a = f1' a)) ∧ ((M' = Silence) ⇒ (v = v')) ⇒
    (itree_el_CASE M f f1 v = itree_el_CASE M' f' f1' v')
</pre>

<DT><span class="strong">itree_el_case_eq</span>
<DD>
<pre>
⊢ (itree_el_CASE x f f1 v = v') ⇔
  (∃e. (x = Event e) ∧ (f e = v')) ∨ (∃r. (x = Return r) ∧ (f1 r = v')) ∨
  (x = Silence) ∧ (v = v')
</pre>

<DT><span class="strong">itree_el_def</span>
<DD>
<pre>
⊢ (itree_el (Ret r) [] = Return r) ∧ (itree_el (Tau t) [] = Silence) ∧
  (itree_el (Vis e g) [] = Event e) ∧
  (itree_el (Ret r) (NONE::ns) = Silence) ∧
  (itree_el (Tau t) (NONE::ns) = itree_el t ns) ∧
  (itree_el (Vis e g) (NONE::ns) = Silence) ∧
  (itree_el (Ret r) (SOME a::ns) = Silence) ∧
  (itree_el (Tau t) (SOME a::ns) = Silence) ∧
  (itree_el (Vis e g) (SOME a::ns) = itree_el (g a) ns)
</pre>

<DT><span class="strong">itree_el_distinct</span>
<DD>
<pre>
⊢ (∀a' a. Event a ≠ Return a') ∧ (∀a. Event a ≠ Silence) ∧
  ∀a. Return a ≠ Silence
</pre>

<DT><span class="strong">itree_el_eqv</span>
<DD>
<pre>
⊢ ∀t1 t2. (t1 = t2) ⇔ ∀path. itree_el t1 path = itree_el t2 path
</pre>

<DT><span class="strong">itree_el_ind</span>
<DD>
<pre>
⊢ ∀P. (∀t. P t []) ∧ (∀t ns. (∀t'. P t' ns) ⇒ P t (NONE::ns)) ∧
      (∀t a ns. (∀g. P (g a) ns) ⇒ P t (SOME a::ns)) ⇒
      ∀v v1. P v v1
</pre>

<DT><span class="strong">itree_el_induction</span>
<DD>
<pre>
⊢ ∀P. (∀e. P (Event e)) ∧ (∀r. P (Return r)) ∧ P Silence ⇒ ∀i. P i
</pre>

<DT><span class="strong">itree_el_nchotomy</span>
<DD>
<pre>
⊢ ∀ii. (∃e. ii = Event e) ∨ (∃r. ii = Return r) ∨ (ii = Silence)
</pre>

<DT><span class="strong">itree_next_11</span>
<DD>
<pre>
⊢ (∀a a'. (Ret' a = Ret' a') ⇔ (a = a')) ∧
  (∀a a'. (Tau' a = Tau' a') ⇔ (a = a')) ∧
  ∀a0 a1 a0' a1'. (Vis' a0 a1 = Vis' a0' a1') ⇔ (a0 = a0') ∧ (a1 = a1')
</pre>

<DT><span class="strong">itree_next_Axiom</span>
<DD>
<pre>
⊢ ∀f0 f1 f2. ∃fn.
    (∀a. fn (Ret' a) = f0 a) ∧ (∀a. fn (Tau' a) = f1 a) ∧
    ∀a0 a1. fn (Vis' a0 a1) = f2 a0 a1
</pre>

<DT><span class="strong">itree_next_case_cong</span>
<DD>
<pre>
⊢ ∀M M' f f1 f2.
    (M = M') ∧ (∀a. (M' = Ret' a) ⇒ (f a = f' a)) ∧
    (∀a. (M' = Tau' a) ⇒ (f1 a = f1' a)) ∧
    (∀a0 a1. (M' = Vis' a0 a1) ⇒ (f2 a0 a1 = f2' a0 a1)) ⇒
    (itree_next_CASE M f f1 f2 = itree_next_CASE M' f' f1' f2')
</pre>

<DT><span class="strong">itree_next_case_eq</span>
<DD>
<pre>
⊢ (itree_next_CASE x f f1 f2 = v) ⇔
  (∃r. (x = Ret' r) ∧ (f r = v)) ∨ (∃s. (x = Tau' s) ∧ (f1 s = v)) ∨
  ∃e f'. (x = Vis' e f') ∧ (f2 e f' = v)
</pre>

<DT><span class="strong">itree_next_distinct</span>
<DD>
<pre>
⊢ (∀a' a. Ret' a ≠ Tau' a') ∧ (∀a1 a0 a. Ret' a ≠ Vis' a0 a1) ∧
  ∀a1 a0 a. Tau' a ≠ Vis' a0 a1
</pre>

<DT><span class="strong">itree_next_induction</span>
<DD>
<pre>
⊢ ∀P. (∀r. P (Ret' r)) ∧ (∀s. P (Tau' s)) ∧ (∀e f. P (Vis' e f)) ⇒ ∀i. P i
</pre>

<DT><span class="strong">itree_next_nchotomy</span>
<DD>
<pre>
⊢ ∀ii. (∃r. ii = Ret' r) ∨ (∃s. ii = Tau' s) ∨ ∃e f. ii = Vis' e f
</pre>

<DT><span class="strong">itree_unfold</span>
<DD>
<pre>
⊢ itree_unfold f seed =
  case f seed of
    Ret' r => Ret r
  | Tau' s => Tau (itree_unfold f s)
  | Vis' e g => Vis e (itree_unfold f ∘ g)
</pre>

<DT><span class="strong">spin</span>
<DD>
<pre>
⊢ spin = Tau spin
</pre>

</DL>



<hr>
</body>
</html>
