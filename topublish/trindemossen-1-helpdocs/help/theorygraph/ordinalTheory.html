<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: ordinal</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "ordinal"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "quotient_sumTheory.html"><span class="strong">quotient_sum</span></a>&nbsp;&nbsp;
    <a href = "quotient_pairTheory.html"><span class="strong">quotient_pair</span></a>&nbsp;&nbsp;
    <a href = "quotient_optionTheory.html"><span class="strong">quotient_option</span></a>&nbsp;&nbsp;
    <a href = "quotient_listTheory.html"><span class="strong">quotient_list</span></a>&nbsp;&nbsp;
    <a href = "topologyTheory.html"><span class="strong">topology</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Type <th> Arity<tr><td>
    <span class="strong">ordinal</span>
    <td>
    1
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">allOrds</span>
    <td>
    :Î± ordinal wellorder
    <tr><td>
    <span class="strong">cardSUC</span>
    <td>
    :(Î± -> bool) -> (Î± + num -> bool) ordinal -> bool
    <tr><td>
    <span class="strong">csuc</span>
    <td>
    :Î± ordinal -> (Î± + num -> bool) ordinal
    <tr><td>
    <span class="strong">dclose</span>
    <td>
    :(Î± ordinal -> bool) -> Î± ordinal -> bool
    <tr><td>
    <span class="strong">downward_closed</span>
    <td>
    :(Î± ordinal -> bool) -> bool
    <tr><td> <span class="strong">epsilon0</span> <td> :Î± ordinal
    <tr><td>
    <span class="strong">eval_poly</span>
    <td>
    :Î± ordinal -> (Î± ordinal # Î± ordinal) list -> Î± ordinal
    <tr><td> <span class="strong">fromNat</span> <td> :num -> Î± ordinal
    <tr><td>
    <span class="strong">is_polyform</span>
    <td>
    :Î± ordinal -> (Î± ordinal # Î² ordinal) list -> bool
    <tr><td>
    <span class="strong">ival</span>
    <td>
    :Î± ordinal -> Î± ordinal -> Î± ordinal -> bool
    <tr><td>
    <span class="strong">oleast</span>
    <td>
    :(Î± ordinal -> bool) -> Î± ordinal
    <tr><td>
    <span class="strong">omax</span>
    <td>
    :(Î± ordinal -> bool) -> Î± ordinal option
    <tr><td> <span class="strong">omega</span> <td> :Î± ordinal
    <tr><td>
    <span class="strong">omega1</span>
    <td>
    :(Î± + num -> bool) ordinal
    <tr><td>
    <span class="strong">ordADD</span>
    <td>
    :Î± ordinal -> Î± ordinal -> Î± ordinal
    <tr><td>
    <span class="strong">ordDIV</span>
    <td>
    :Î± ordinal -> Î± ordinal -> Î± ordinal
    <tr><td>
    <span class="strong">ordDIVMOD</span>
    <td>
    :Î± ordinal -> Î± ordinal -> Î± ordinal # Î± ordinal
    <tr><td>
    <span class="strong">ordEXP</span>
    <td>
    :Î± ordinal -> Î± ordinal -> Î± ordinal
    <tr><td>
    <span class="strong">ordMOD</span>
    <td>
    :Î± ordinal -> Î± ordinal -> Î± ordinal
    <tr><td>
    <span class="strong">ordMULT</span>
    <td>
    :Î± ordinal -> Î± ordinal -> Î± ordinal
    <tr><td> <span class="strong">ordSUC</span> <td> :Î± ordinal -> Î± ordinal
    <tr><td>
    <span class="strong">ordinal_ABS</span>
    <td>
    :(num + Î±) wellorder -> Î± ordinal
    <tr><td>
    <span class="strong">ordinal_ABS_CLASS</span>
    <td>
    :((num + Î±) wellorder -> bool) -> Î± ordinal
    <tr><td>
    <span class="strong">ordinal_REP</span>
    <td>
    :Î± ordinal -> (num + Î±) wellorder
    <tr><td>
    <span class="strong">ordinal_REP_CLASS</span>
    <td>
    :Î± ordinal -> (num + Î±) wellorder -> bool
    <tr><td>
    <span class="strong">ordlt</span>
    <td>
    :Î± ordinal -> Î± ordinal -> bool
    <tr><td> <span class="strong">ordlt_top</span> <td> :Î± ordinal topology
    <tr><td>
    <span class="strong">polyform</span>
    <td>
    :Î± ordinal -> Î± ordinal -> (Î± ordinal # Î± ordinal) list
    <tr><td>
    <span class="strong">preds</span>
    <td>
    :Î± ordinal -> Î± ordinal -> bool
    <tr><td>
    <span class="strong">sup</span>
    <td>
    :(Î± ordinal -> bool) -> Î± ordinal
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">allOrds_def</span>
<DD>
<pre>
âŠ¢ allOrds = mkWO {(x,y) | (x = y) âˆ¨ x < y}
</pre>

<DT><span class="strong">cardSUC_def</span>
<DD>
<pre>
âŠ¢ âˆ€s. cardSUC s = preds (csuc (oleast a. preds a â‰ˆ s))
</pre>

<DT><span class="strong">csuc_def</span>
<DD>
<pre>
âŠ¢ âˆ€a. csuc a = oleast b. preds a â‰º preds b
</pre>

<DT><span class="strong">dclose_def</span>
<DD>
<pre>
âŠ¢ âˆ€s. dclose s = {x | âˆƒy. y âˆˆ s âˆ§ x < y}
</pre>

<DT><span class="strong">downward_closed_def</span>
<DD>
<pre>
âŠ¢ âˆ€s. downward_closed s â‡” âˆ€a b. a âˆˆ s âˆ§ b < a â‡’ b âˆˆ s
</pre>

<DT><span class="strong">epsilon0_def</span>
<DD>
<pre>
âŠ¢ Îµâ‚€ = oleast x. Ï‰ ** x = x
</pre>

<DT><span class="strong">fromNat_def</span>
<DD>
<pre>
âŠ¢ (0 = oleast a. T) âˆ§ âˆ€n. &SUC n = (&n)âº
</pre>

<DT><span class="strong">ival_def</span>
<DD>
<pre>
âŠ¢ âˆ€a b. ival a b = {e | a < e âˆ§ e < b}
</pre>

<DT><span class="strong">oleast_def</span>
<DD>
<pre>
âŠ¢ âˆ€P. $oleast P = @x. P x âˆ§ âˆ€y. y < x â‡’ Â¬P y
</pre>

<DT><span class="strong">omax_def</span>
<DD>
<pre>
âŠ¢ âˆ€s. omax s = some a. maximal_elements s {(x,y) | x â‰¤ y} = {a}
</pre>

<DT><span class="strong">omega1_def</span>
<DD>
<pre>
âŠ¢ Ï‰â‚ = sup {a | countableOrd a}
</pre>

<DT><span class="strong">omega_def</span>
<DD>
<pre>
âŠ¢ Ï‰ = sup {(&i) | T}
</pre>

<DT><span class="strong">ordADD_def</span>
<DD>
<pre>
âŠ¢ âˆ€b. (b + 0 = b) âˆ§ (âˆ€a. b + aâº = (b + a)âº) âˆ§
      âˆ€a. 0 < a âˆ§ islimit a â‡’ (b + a = sup (IMAGE ($+ b) (preds a)))
</pre>

<DT><span class="strong">ordDIV</span>
<DD>
<pre>
âŠ¢ âˆ€a b. a / b = FST (ordDIVMOD a b)
</pre>

<DT><span class="strong">ordDIVMOD</span>
<DD>
<pre>
âŠ¢ âˆ€a b.
    0 < b â‡’
    (a = b * FST (ordDIVMOD a b) + SND (ordDIVMOD a b)) âˆ§
    SND (ordDIVMOD a b) < b
</pre>

<DT><span class="strong">ordEXP_def</span>
<DD>
<pre>
âŠ¢ (âˆ€a. a ** 0 = 1) âˆ§ (âˆ€a a'. a ** a'âº = a ** a' * a) âˆ§
  âˆ€a a'. 0 < a' âˆ§ islimit a' â‡’ (a ** a' = sup (IMAGE ($** a) (preds a')))
</pre>

<DT><span class="strong">ordMOD</span>
<DD>
<pre>
âŠ¢ âˆ€a b. a % b = SND (ordDIVMOD a b)
</pre>

<DT><span class="strong">ordMULT_def</span>
<DD>
<pre>
âŠ¢ âˆ€b. (b * 0 = 0) âˆ§ (âˆ€a. b * aâº = b * a + b) âˆ§
      âˆ€a. 0 < a âˆ§ islimit a â‡’ (b * a = sup (IMAGE ($* b) (preds a)))
</pre>

<DT><span class="strong">ordSUC_def</span>
<DD>
<pre>
âŠ¢ âˆ€a. aâº = oleast b. a < b
</pre>

<DT><span class="strong">ordinal_ABS_def</span>
<DD>
<pre>
âŠ¢ âˆ€r. mkOrdinal r = ordinal_ABS_CLASS (orderiso r)
</pre>

<DT><span class="strong">ordinal_REP_def</span>
<DD>
<pre>
âŠ¢ âˆ€a. ordinal_REP a = $@ (ordinal_REP_CLASS a)
</pre>

<DT><span class="strong">ordinal_TY_DEF</span>
<DD>
<pre>
âŠ¢ âˆƒrep. TYPE_DEFINITION (Î»c. âˆƒr. orderiso r r âˆ§ (c = orderiso r)) rep
</pre>

<DT><span class="strong">ordinal_bijections</span>
<DD>
<pre>
âŠ¢ (âˆ€a. ordinal_ABS_CLASS (ordinal_REP_CLASS a) = a) âˆ§
  âˆ€r. (Î»c. âˆƒr. orderiso r r âˆ§ (c = orderiso r)) r â‡”
      (ordinal_REP_CLASS (ordinal_ABS_CLASS r) = r)
</pre>

<DT><span class="strong">ordlt_def</span>
<DD>
<pre>
âŠ¢ âˆ€T1 T2. T1 < T2 â‡” orderlt (ordinal_REP T1) (ordinal_REP T2)
</pre>

<DT><span class="strong">ordlt_top_def</span>
<DD>
<pre>
âŠ¢ ordlt_top =
  topology
    {s |
     (âˆ€e. e âˆˆ s â‡’
          (âˆƒa b. e âˆˆ ival a b âˆ§ ival a b âŠ† s) âˆ¨ âˆƒb. e < b âˆ§ âˆ€d. d < b â‡’ d âˆˆ s)}
</pre>

<DT><span class="strong">polyform_def</span>
<DD>
<pre>
âŠ¢ âˆ€a b.
    1 < a â‡’ is_polyform a (polyform a b) âˆ§ (b = eval_poly a (polyform a b))
</pre>

<DT><span class="strong">preds_def</span>
<DD>
<pre>
âŠ¢ âˆ€w. preds w = {w0 | w0 < w}
</pre>

<DT><span class="strong">sup_def</span>
<DD>
<pre>
âŠ¢ âˆ€ordset. sup ordset = oleast a. a âˆ‰ BIGUNION (IMAGE preds ordset)
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">ADD1R</span>
<DD>
<pre>
âŠ¢ a + 1 = aâº
</pre>

<DT><span class="strong">CARD_FINITE_preds</span>
<DD>
<pre>
âŠ¢ CARD (preds (&n)) = CARD (preds (&n))
</pre>

<DT><span class="strong">CNF_nat</span>
<DD>
<pre>
âŠ¢ CNF (&n) = if n = 0 then [] else [(&n,0)]
</pre>

<DT><span class="strong">CNF_thm</span>
<DD>
<pre>
âŠ¢ âˆ€b. is_polyform Ï‰ (CNF b) âˆ§ (b = eval_poly Ï‰ (CNF b))
</pre>

<DT><span class="strong">FINITE_cardSUC</span>
<DD>
<pre>
âŠ¢ FINITE (cardSUC A) â‡” FINITE A
</pre>

<DT><span class="strong">FINITE_omax_IS_SOME</span>
<DD>
<pre>
âŠ¢ s â‰  âˆ… âˆ§ FINITE s â‡’ âˆƒa. omax s = SOME a
</pre>

<DT><span class="strong">FINITE_preds</span>
<DD>
<pre>
âŠ¢ FINITE (preds a) â‡” âˆƒn. a = &n
</pre>

<DT><span class="strong">IFF_ZERO_lt</span>
<DD>
<pre>
âŠ¢ (x â‰  0 â‡” 0 < x) âˆ§ (1 â‰¤ x â‡” 0 < x)
</pre>

<DT><span class="strong">IMAGE_EQ_SING</span>
<DD>
<pre>
âŠ¢ (IMAGE f s = {x}) â‡” (âˆƒy. y âˆˆ s) âˆ§ âˆ€y. y âˆˆ s â‡’ (f y = x)
</pre>

<DT><span class="strong">INFINITE_eqpreds</span>
<DD>
<pre>
âŠ¢ Ï‰ â‰¤ x â‡’ INFINITE {y | preds y â‰ˆ preds x}
</pre>

<DT><span class="strong">IN_preds</span>
<DD>
<pre>
âŠ¢ x âˆˆ preds w â‡” x < w
</pre>

<DT><span class="strong">ORD_ONE</span>
<DD>
<pre>
âŠ¢ 0âº = 1
</pre>

<DT><span class="strong">Unum_cardle_ucinf</span>
<DD>
<pre>
âŠ¢ ğ•Œ(:num) â‰¼ ğ•Œ(:num + (Î± + num -> bool))
</pre>

<DT><span class="strong">Unum_cardlt_ucinf</span>
<DD>
<pre>
âŠ¢ ğ•Œ(:num) â‰º ğ•Œ(:num + (Î± + num -> bool))
</pre>

<DT><span class="strong">Unum_cle_Uinf</span>
<DD>
<pre>
âŠ¢ ğ•Œ(:num) â‰¼ ğ•Œ(:num + Î±)
</pre>

<DT><span class="strong">WIN_allOrds</span>
<DD>
<pre>
âŠ¢ (x,y) WIN allOrds â‡” x < y
</pre>

<DT><span class="strong">ZERO_LT_csuc</span>
<DD>
<pre>
âŠ¢ 0o < csuc a âˆ§ csuc a â‰  0o
</pre>

<DT><span class="strong">ZERO_lt_ordEXP</span>
<DD>
<pre>
âŠ¢ 0 < a ** x â‡” 0 < a âˆ¨ islimit x
</pre>

<DT><span class="strong">ZERO_lt_ordEXP_I</span>
<DD>
<pre>
âŠ¢ âˆ€a x. 0 < a â‡’ 0 < a ** x
</pre>

<DT><span class="strong">addL_fixpoint_iff</span>
<DD>
<pre>
âŠ¢ (a + b = b) â‡” a * Ï‰ â‰¤ b
</pre>

<DT><span class="strong">add_nat_islimit</span>
<DD>
<pre>
âŠ¢ 0 < n â‡’ (islimit (a + &n) â‡” F)
</pre>

<DT><span class="strong">add_omega_islimit</span>
<DD>
<pre>
âŠ¢ islimit (a + Ï‰)
</pre>

<DT><span class="strong">bumpUNIV_cardlt</span>
<DD>
<pre>
âŠ¢ ğ•Œ(:num + Î±) â‰º ğ•Œ(:num + (Î± + num -> bool))
</pre>

<DT><span class="strong">cardSUC_EQ0</span>
<DD>
<pre>
âŠ¢ cardSUC A â‰  âˆ…
</pre>

<DT><span class="strong">cardeq_ordinals_exist</span>
<DD>
<pre>
âŠ¢ s â‰¼ ğ•Œ(:num + Î±) â‡’ âˆƒa. preds a â‰ˆ s
</pre>

<DT><span class="strong">cardinality_bump_exists</span>
<DD>
<pre>
âŠ¢ âˆ€x. âˆƒy. preds x â‰º preds y
</pre>

<DT><span class="strong">cardle_preds_EQ_cardeq_preds</span>
<DD>
<pre>
âŠ¢ Ï‰ â‰¤ x â‡’ {y | preds y â‰¼ preds x} â‰ˆ {y | preds y â‰ˆ preds x}
</pre>

<DT><span class="strong">cardleq_preds_csuc</span>
<DD>
<pre>
âŠ¢ preds a â‰¼ preds b â‡’ preds (csuc a) â‰¼ preds (csuc b)
</pre>

<DT><span class="strong">cardlt_eqpreds</span>
<DD>
<pre>
âŠ¢ Ï‰ â‰¤ x â‡’ preds x â‰º {y | preds y â‰ˆ preds x}
</pre>

<DT><span class="strong">cardlt_lepreds</span>
<DD>
<pre>
âŠ¢ preds x â‰º {y | preds y â‰¼ preds x}
</pre>

<DT><span class="strong">cardlt_preds</span>
<DD>
<pre>
âŠ¢ preds x â‰º preds y â‡’ x < y
</pre>

<DT><span class="strong">closed_sing</span>
<DD>
<pre>
âŠ¢ closed_in ordlt_top {x}
</pre>

<DT><span class="strong">cord_countable_preds</span>
<DD>
<pre>
âŠ¢ countableOrd ord
</pre>

<DT><span class="strong">countableOrds_dclosed</span>
<DD>
<pre>
âŠ¢ a < b âˆ§ countableOrd b â‡’ countableOrd a
</pre>

<DT><span class="strong">countableOrds_uncountable</span>
<DD>
<pre>
âŠ¢ uncountable {a | countableOrd a}
</pre>

<DT><span class="strong">csuc_EQ_N</span>
<DD>
<pre>
âŠ¢ (csuc a = &n) â‡” âˆƒm. (n = SUC m) âˆ§ (a = &m)
</pre>

<DT><span class="strong">csuc_is_nonzero_limit</span>
<DD>
<pre>
âŠ¢ Ï‰ â‰¤ a â‡’ islimit (csuc a) âˆ§ 0o < csuc a
</pre>

<DT><span class="strong">csuc_nat</span>
<DD>
<pre>
âŠ¢ csuc (&n) = (&n)âº
</pre>

<DT><span class="strong">csuc_omega</span>
<DD>
<pre>
âŠ¢ csuc Ï‰ = Ï‰â‚
</pre>

<DT><span class="strong">csup_lesup</span>
<DD>
<pre>
âŠ¢ countable s â‡’ âˆ€d. d âˆˆ s â‡’ d â‰¤ sup s
</pre>

<DT><span class="strong">csup_suple</span>
<DD>
<pre>
âŠ¢ countable s â‡’ (sup s â‰¤ b â‡” âˆ€d. d âˆˆ s â‡’ d â‰¤ b)
</pre>

<DT><span class="strong">csup_thm</span>
<DD>
<pre>
âŠ¢ countable s â‡’ âˆ€b. b < sup s â‡” âˆƒd. d âˆˆ s âˆ§ b < d
</pre>

<DT><span class="strong">cx_lt_x</span>
<DD>
<pre>
âŠ¢ x * c < x â‡” 0 < x âˆ§ (c = 0)
</pre>

<DT><span class="strong">dclose_BIGUNION</span>
<DD>
<pre>
âŠ¢ dclose s = BIGUNION (IMAGE preds s)
</pre>

<DT><span class="strong">dclose_cardleq_univinf</span>
<DD>
<pre>
âŠ¢ s â‰¼ ğ•Œ(:num + Î±) â‡’ dclose s â‰¼ ğ•Œ(:num + Î±)
</pre>

<DT><span class="strong">elsOf_allOrds</span>
<DD>
<pre>
âŠ¢ elsOf allOrds = ğ•Œ(:Î± ordinal)
</pre>

<DT><span class="strong">epsilon0_fixpoint</span>
<DD>
<pre>
âŠ¢ Ï‰ ** Îµâ‚€ = Îµâ‚€
</pre>

<DT><span class="strong">epsilon0_least_fixpoint</span>
<DD>
<pre>
âŠ¢ âˆ€a. a < Îµâ‚€ â‡’ a < Ï‰ ** a âˆ§ Ï‰ ** a < Îµâ‚€
</pre>

<DT><span class="strong">eval_poly_def</span>
<DD>
<pre>
âŠ¢ (âˆ€a. eval_poly a [] = 0) âˆ§
  âˆ€t e c a. eval_poly a ((c,e)::t) = a ** e * c + eval_poly a t
</pre>

<DT><span class="strong">eval_poly_ind</span>
<DD>
<pre>
âŠ¢ âˆ€P. (âˆ€a. P a []) âˆ§ (âˆ€a c e t. P a t â‡’ P a ((c,e)::t)) â‡’ âˆ€v v1. P v v1
</pre>

<DT><span class="strong">expbound_add</span>
<DD>
<pre>
âŠ¢ âˆ€a x y. x < Ï‰ ** a âˆ§ y < Ï‰ ** a â‡’ x + y < Ï‰ ** a
</pre>

<DT><span class="strong">fixpoints_exist</span>
<DD>
<pre>
âŠ¢ (âˆ€s. s â‰  âˆ… âˆ§ s â‰¼ ğ•Œ(:num + Î±) â‡’ (f (sup s) = sup (IMAGE f s))) âˆ§
  (âˆ€x. x â‰¤ f x) â‡’
  âˆ€a. âˆƒb. a â‰¤ b âˆ§ (f b = b)
</pre>

<DT><span class="strong">fromNat_11</span>
<DD>
<pre>
âŠ¢ âˆ€x y. (&x = &y) â‡” (x = y)
</pre>

<DT><span class="strong">fromNat_SUC</span>
<DD>
<pre>
âŠ¢ âˆ€n. &SUC n = (&n)âº
</pre>

<DT><span class="strong">fromNat_compute</span>
<DD>
<pre>
âŠ¢ (0 = oleast a. T) âˆ§ (âˆ€n. &NUMERAL (BIT1 n) = (&(NUMERAL (BIT1 n) âˆ’ 1))âº) âˆ§
  âˆ€n. &NUMERAL (BIT2 n) = (&NUMERAL (BIT1 n))âº
</pre>

<DT><span class="strong">fromNat_eq_omega</span>
<DD>
<pre>
âŠ¢ âˆ€n. &n â‰  Ï‰
</pre>

<DT><span class="strong">fromNat_lt_epsilon0</span>
<DD>
<pre>
âŠ¢ &n < Îµâ‚€
</pre>

<DT><span class="strong">fromNat_lt_omega</span>
<DD>
<pre>
âŠ¢ âˆ€n. &n < Ï‰
</pre>

<DT><span class="strong">fromNat_ordlt</span>
<DD>
<pre>
âŠ¢ &n < &m â‡” n < m
</pre>

<DT><span class="strong">generic_continuity</span>
<DD>
<pre>
âŠ¢ (âˆ€a. 0 < a âˆ§ islimit a â‡’ (f a = sup (IMAGE f (preds a)))) âˆ§
  (âˆ€x y. x â‰¤ y â‡’ f x â‰¤ f y) â‡’
  âˆ€s. s â‰¼ ğ•Œ(:num + Î±) âˆ§ s â‰  âˆ… â‡’ (f (sup s) = sup (IMAGE f s))
</pre>

<DT><span class="strong">is_polyform_CONS_E</span>
<DD>
<pre>
âŠ¢ is_polyform a ((c,e)::t) â‡’ 0 < c âˆ§ c < a âˆ§ is_polyform a t
</pre>

<DT><span class="strong">is_polyform_ELthm</span>
<DD>
<pre>
âŠ¢ is_polyform a ces â‡”
  (âˆ€i j. i < j âˆ§ j < LENGTH ces â‡’ SND (EL j ces) < SND (EL i ces)) âˆ§
  âˆ€c e. MEM (c,e) ces â‡’ 0 < c âˆ§ c < a
</pre>

<DT><span class="strong">is_polyform_def</span>
<DD>
<pre>
âŠ¢ (âˆ€a. is_polyform a [] â‡” T) âˆ§
  (âˆ€e c a. is_polyform a [(c,e)] â‡” 0 < c âˆ§ c < a) âˆ§
  âˆ€t e2 e1 c2 c1 a.
    is_polyform a ((c1,e1)::(c2,e2)::t) â‡”
    0 < c1 âˆ§ c1 < a âˆ§ e2 < e1 âˆ§ is_polyform a ((c2,e2)::t)
</pre>

<DT><span class="strong">is_polyform_head_dominates_tail</span>
<DD>
<pre>
âŠ¢ 1 < a âˆ§ is_polyform a ((c,e)::t) â‡’ eval_poly a t < a ** e
</pre>

<DT><span class="strong">is_polyform_ind</span>
<DD>
<pre>
âŠ¢ âˆ€P. (âˆ€a. P a []) âˆ§ (âˆ€a c e. P a [(c,e)]) âˆ§
      (âˆ€a c1 e1 c2 e2 t. P a ((c2,e2)::t) â‡’ P a ((c1,e1)::(c2,e2)::t)) â‡’
      âˆ€v v1. P v v1
</pre>

<DT><span class="strong">islimit_0</span>
<DD>
<pre>
âŠ¢ islimit 0
</pre>

<DT><span class="strong">islimit_SUC</span>
<DD>
<pre>
âŠ¢ islimit xâº â‡” F
</pre>

<DT><span class="strong">islimit_SUC_lt</span>
<DD>
<pre>
âŠ¢ islimit b âˆ§ a < b â‡’ aâº < b
</pre>

<DT><span class="strong">islimit_fromNat</span>
<DD>
<pre>
âŠ¢ islimit (&x) â‡” (x = 0)
</pre>

<DT><span class="strong">islimit_mul_R</span>
<DD>
<pre>
âŠ¢ âˆ€a. islimit a â‡’ islimit (b * a)
</pre>

<DT><span class="strong">le_cardSUC</span>
<DD>
<pre>
âŠ¢ A â‰¼ cardSUC A
</pre>

<DT><span class="strong">leqLEFT_CANCEL</span>
<DD>
<pre>
âŠ¢ âˆ€x a. x â‰¤ a + x
</pre>

<DT><span class="strong">limpt_islimit</span>
<DD>
<pre>
âŠ¢ limpt ordlt_top a (preds a) â‡” islimit a âˆ§ a â‰  0
</pre>

<DT><span class="strong">lt_cardSUC</span>
<DD>
<pre>
âŠ¢ A â‰º cardSUC A
</pre>

<DT><span class="strong">lt_csuc</span>
<DD>
<pre>
âŠ¢ x < csuc y â‡” preds x â‰¼ preds y
</pre>

<DT><span class="strong">lt_omega</span>
<DD>
<pre>
âŠ¢ âˆ€a. a < Ï‰ â‡” âˆƒm. a = &m
</pre>

<DT><span class="strong">lt_suppreds</span>
<DD>
<pre>
âŠ¢ âˆ€b. b < sup (preds a) â‡” âˆƒd. d < a âˆ§ b < d
</pre>

<DT><span class="strong">mul_omega_islimit</span>
<DD>
<pre>
âŠ¢ islimit (Ï‰ * a)
</pre>

<DT><span class="strong">no_maximal_ordinal</span>
<DD>
<pre>
âŠ¢ âˆ€a. âˆƒb. a < b
</pre>

<DT><span class="strong">oleast_intro</span>
<DD>
<pre>
âŠ¢ âˆ€Q P. (âˆƒa. P a) âˆ§ (âˆ€a. (âˆ€b. b < a â‡’ Â¬P b) âˆ§ P a â‡’ Q a) â‡’ Q ($oleast P)
</pre>

<DT><span class="strong">olog_correct</span>
<DD>
<pre>
âŠ¢ 0 < x â‡’ Ï‰ ** olog x â‰¤ x âˆ§ âˆ€a. olog x < a â‡’ x < Ï‰ ** a
</pre>

<DT><span class="strong">omax_EMPTY</span>
<DD>
<pre>
âŠ¢ omax âˆ… = NONE
</pre>

<DT><span class="strong">omax_INSERT</span>
<DD>
<pre>
âŠ¢ omax (x INSERT y) = if âˆ€e. e âˆˆ y â‡’ e â‰¤ x then SOME x else omax y
</pre>

<DT><span class="strong">omax_NONE</span>
<DD>
<pre>
âŠ¢ (omax s = NONE) â‡” âˆ€a. a âˆˆ s â‡’ âˆƒb. b âˆˆ s âˆ§ a < b
</pre>

<DT><span class="strong">omax_SOME</span>
<DD>
<pre>
âŠ¢ (omax s = SOME a) â‡” a âˆˆ s âˆ§ âˆ€b. b âˆˆ s â‡’ b â‰¤ a
</pre>

<DT><span class="strong">omax_preds_SUC</span>
<DD>
<pre>
âŠ¢ omax (preds aâº) = SOME a
</pre>

<DT><span class="strong">omax_preds_omega</span>
<DD>
<pre>
âŠ¢ islimit Ï‰
</pre>

<DT><span class="strong">omax_sup</span>
<DD>
<pre>
âŠ¢ (omax s = SOME a) â‡’ (sup s = a)
</pre>

<DT><span class="strong">omega1_not_countable</span>
<DD>
<pre>
âŠ¢ uncountable (preds Ï‰â‚)
</pre>

<DT><span class="strong">omega_LEQ_INFINITE_preds</span>
<DD>
<pre>
âŠ¢ INFINITE (preds a) â‡’ Ï‰ â‰¤ a
</pre>

<DT><span class="strong">omega_MUL_fromNat</span>
<DD>
<pre>
âŠ¢ 0 < n â‡’ (&n * Ï‰ = Ï‰)
</pre>

<DT><span class="strong">omega_exp_islimit</span>
<DD>
<pre>
âŠ¢ 0 < a â‡’ islimit (Ï‰ ** a)
</pre>

<DT><span class="strong">omega_islimit</span>
<DD>
<pre>
âŠ¢ islimit Ï‰
</pre>

<DT><span class="strong">omega_lt_epsilon0</span>
<DD>
<pre>
âŠ¢ Ï‰ < Îµâ‚€
</pre>

<DT><span class="strong">open_in_ordlt</span>
<DD>
<pre>
âŠ¢ open_in ordlt_top s â‡”
  âˆ€e. e âˆˆ s â‡’
      (âˆƒa b. e âˆˆ ival a b âˆ§ ival a b âŠ† s) âˆ¨ âˆƒb. e < b âˆ§ âˆ€d. d < b â‡’ d âˆˆ s
</pre>

<DT><span class="strong">open_sing_nonlimit</span>
<DD>
<pre>
âŠ¢ open_in ordlt_top {x} â‡” omax (preds x) â‰  NONE âˆ¨ (x = 0)
</pre>

<DT><span class="strong">ordADD_0L</span>
<DD>
<pre>
âŠ¢ âˆ€a. 0 + a = a
</pre>

<DT><span class="strong">ordADD_ASSOC</span>
<DD>
<pre>
âŠ¢ âˆ€a b c. a + (b + c) = a + b + c
</pre>

<DT><span class="strong">ordADD_CANCEL1</span>
<DD>
<pre>
âŠ¢ (âˆ€c a. (a = a + c) â‡” (c = 0)) âˆ§ âˆ€c a. (a + c = a) â‡” (c = 0)
</pre>

<DT><span class="strong">ordADD_EQ_0</span>
<DD>
<pre>
âŠ¢ âˆ€y x. (x + y = 0) â‡” (x = 0) âˆ§ (y = 0)
</pre>

<DT><span class="strong">ordADD_MONO</span>
<DD>
<pre>
âŠ¢ âˆ€b a c. a < b â‡’ c + a < c + b
</pre>

<DT><span class="strong">ordADD_RIGHT_CANCEL</span>
<DD>
<pre>
âŠ¢ âˆ€b a c. (a + b = a + c) â‡” (b = c)
</pre>

<DT><span class="strong">ordADD_continuous</span>
<DD>
<pre>
âŠ¢ âˆ€s. s â‰¼ ğ•Œ(:num + Î±) âˆ§ s â‰  âˆ… â‡’ (a + sup s = sup (IMAGE ($+ a) s))
</pre>

<DT><span class="strong">ordADD_fromNat</span>
<DD>
<pre>
âŠ¢ &n + &m = &(n + m)
</pre>

<DT><span class="strong">ordADD_fromNat_omega</span>
<DD>
<pre>
âŠ¢ &n + Ï‰ = Ï‰
</pre>

<DT><span class="strong">ordADD_le_MONO_L</span>
<DD>
<pre>
âŠ¢ x â‰¤ y â‡’ x + z â‰¤ y + z
</pre>

<DT><span class="strong">ordADD_under_epsilon0</span>
<DD>
<pre>
âŠ¢ x < Îµâ‚€ âˆ§ y < Îµâ‚€ â‡’ x + y < Îµâ‚€
</pre>

<DT><span class="strong">ordADD_weak_MONO</span>
<DD>
<pre>
âŠ¢ âˆ€c a b. a < b â‡’ a + c â‰¤ b + c
</pre>

<DT><span class="strong">ordDIVISION</span>
<DD>
<pre>
âŠ¢ âˆ€a b. 0 < b â‡’ (a = b * (a / b) + a % b) âˆ§ a % b < b
</pre>

<DT><span class="strong">ordDIV_UNIQUE</span>
<DD>
<pre>
âŠ¢ âˆ€a b q r. 0 < b âˆ§ (a = b * q + r) âˆ§ r < b â‡’ (a / b = q)
</pre>

<DT><span class="strong">ordEXP_1L</span>
<DD>
<pre>
âŠ¢ âˆ€a. 1 ** a = 1
</pre>

<DT><span class="strong">ordEXP_1R</span>
<DD>
<pre>
âŠ¢ a ** 1 = a
</pre>

<DT><span class="strong">ordEXP_2R</span>
<DD>
<pre>
âŠ¢ a ** 2 = a * a
</pre>

<DT><span class="strong">ordEXP_ADD</span>
<DD>
<pre>
âŠ¢ 0 < x â‡’ (x ** (y + z) = x ** y * x ** z)
</pre>

<DT><span class="strong">ordEXP_EQ_0</span>
<DD>
<pre>
âŠ¢ âˆ€y x. (x ** y = 0) â‡” (x = 0) âˆ§ omax (preds y) â‰  NONE
</pre>

<DT><span class="strong">ordEXP_MUL</span>
<DD>
<pre>
âŠ¢ 0 < x â‡’ (x ** (y * z) = (x ** y) ** z)
</pre>

<DT><span class="strong">ordEXP_ZERO_limit</span>
<DD>
<pre>
âŠ¢ âˆ€x. islimit x â‡’ (0 ** x = 1)
</pre>

<DT><span class="strong">ordEXP_ZERO_nonlimit</span>
<DD>
<pre>
âŠ¢ omax (preds x) â‰  NONE â‡’ (0 ** x = 0)
</pre>

<DT><span class="strong">ordEXP_continuous</span>
<DD>
<pre>
âŠ¢ âˆ€a s. 0 < a âˆ§ s â‰¼ ğ•Œ(:num + Î±) âˆ§ s â‰  âˆ… â‡’ (a ** sup s = sup (IMAGE ($** a) s))
</pre>

<DT><span class="strong">ordEXP_fromNat</span>
<DD>
<pre>
âŠ¢ &x ** &n = &(x ** n)
</pre>

<DT><span class="strong">ordEXP_le_MONO_L</span>
<DD>
<pre>
âŠ¢ âˆ€x a b. a â‰¤ b â‡’ a ** x â‰¤ b ** x
</pre>

<DT><span class="strong">ordEXP_le_MONO_R</span>
<DD>
<pre>
âŠ¢ âˆ€x y a. 0 < a âˆ§ x â‰¤ y â‡’ a ** x â‰¤ a ** y
</pre>

<DT><span class="strong">ordEXP_lt_IFF</span>
<DD>
<pre>
âŠ¢ âˆ€x y a. 1 < a â‡’ (a ** x < a ** y â‡” x < y)
</pre>

<DT><span class="strong">ordEXP_lt_MONO_R</span>
<DD>
<pre>
âŠ¢ âˆ€y x a. 1 < a âˆ§ x < y â‡’ a ** x < a ** y
</pre>

<DT><span class="strong">ordEXP_under_epsilon0</span>
<DD>
<pre>
âŠ¢ a < Îµâ‚€ âˆ§ b < Îµâ‚€ â‡’ a ** b < Îµâ‚€
</pre>

<DT><span class="strong">ordLOG_correct</span>
<DD>
<pre>
âŠ¢ 1 < b âˆ§ 0 < x â‡’ b ** ordLOG b x â‰¤ x âˆ§ âˆ€a. ordLOG b x < a â‡’ x < b ** a
</pre>

<DT><span class="strong">ordMOD_UNIQUE</span>
<DD>
<pre>
âŠ¢ âˆ€a b q r. 0 < b âˆ§ (a = b * q + r) âˆ§ r < b â‡’ (a % b = r)
</pre>

<DT><span class="strong">ordMULT_0L</span>
<DD>
<pre>
âŠ¢ âˆ€a. 0 * a = 0
</pre>

<DT><span class="strong">ordMULT_0R</span>
<DD>
<pre>
âŠ¢ âˆ€a. a * 0 = 0
</pre>

<DT><span class="strong">ordMULT_1L</span>
<DD>
<pre>
âŠ¢ âˆ€a. 1 * a = a
</pre>

<DT><span class="strong">ordMULT_1R</span>
<DD>
<pre>
âŠ¢ âˆ€a. a * 1 = a
</pre>

<DT><span class="strong">ordMULT_2R</span>
<DD>
<pre>
âŠ¢ a * 2 = a + a
</pre>

<DT><span class="strong">ordMULT_ASSOC</span>
<DD>
<pre>
âŠ¢ âˆ€a b c. a * (b * c) = a * b * c
</pre>

<DT><span class="strong">ordMULT_CANCEL_R</span>
<DD>
<pre>
âŠ¢ (z * x = z * y) â‡” (z = 0) âˆ¨ (x = y)
</pre>

<DT><span class="strong">ordMULT_EQ_0</span>
<DD>
<pre>
âŠ¢ âˆ€x y. (x * y = 0) â‡” (x = 0) âˆ¨ (y = 0)
</pre>

<DT><span class="strong">ordMULT_LDISTRIB</span>
<DD>
<pre>
âŠ¢ âˆ€a b c. c * (a + b) = c * a + c * b
</pre>

<DT><span class="strong">ordMULT_continuous</span>
<DD>
<pre>
âŠ¢ âˆ€s. s â‰¼ ğ•Œ(:num + Î±) â‡’ (a * sup s = sup (IMAGE ($* a) s))
</pre>

<DT><span class="strong">ordMULT_fromNat</span>
<DD>
<pre>
âŠ¢ &n * &m = &(n * m)
</pre>

<DT><span class="strong">ordMULT_le_MONO_L</span>
<DD>
<pre>
âŠ¢ âˆ€a b c. a â‰¤ b â‡’ a * c â‰¤ b * c
</pre>

<DT><span class="strong">ordMULT_le_MONO_R</span>
<DD>
<pre>
âŠ¢ âˆ€a b c. a â‰¤ b â‡’ c * a â‰¤ c * b
</pre>

<DT><span class="strong">ordMULT_lt_MONO_R</span>
<DD>
<pre>
âŠ¢ âˆ€a b c. a < b âˆ§ 0 < c â‡’ c * a < c * b
</pre>

<DT><span class="strong">ordMULT_lt_MONO_R_EQN</span>
<DD>
<pre>
âŠ¢ c * a < c * b â‡” a < b âˆ§ 0 < c
</pre>

<DT><span class="strong">ordMUL_under_epsilon0</span>
<DD>
<pre>
âŠ¢ x < Îµâ‚€ âˆ§ y < Îµâ‚€ â‡’ x * y < Îµâ‚€
</pre>

<DT><span class="strong">ordSUC_11</span>
<DD>
<pre>
âŠ¢ (aâº = bâº) â‡” (a = b)
</pre>

<DT><span class="strong">ordSUC_MONO</span>
<DD>
<pre>
âŠ¢ aâº < bâº â‡” a < b
</pre>

<DT><span class="strong">ordSUC_NUMERAL</span>
<DD>
<pre>
âŠ¢ (&NUMERAL n)âº = &(NUMERAL n + 1)
</pre>

<DT><span class="strong">ordSUC_ZERO</span>
<DD>
<pre>
âŠ¢ aâº â‰  0
</pre>

<DT><span class="strong">ordZERO_ltSUC</span>
<DD>
<pre>
âŠ¢ 0 < xâº
</pre>

<DT><span class="strong">ord_CASES</span>
<DD>
<pre>
âŠ¢ âˆ€a. (a = 0) âˆ¨ (âˆƒa0. a = a0âº) âˆ¨ 0 < a âˆ§ islimit a
</pre>

<DT><span class="strong">ord_RECURSION</span>
<DD>
<pre>
âŠ¢ âˆ€z sf lf. âˆƒh.
    (h 0 = z) âˆ§ (âˆ€a. h aâº = sf a (h a)) âˆ§
    âˆ€a. 0 < a âˆ§ islimit a â‡’ (h a = lf a (IMAGE h (preds a)))
</pre>

<DT><span class="strong">ord_induction</span>
<DD>
<pre>
âŠ¢ (âˆ€min. (âˆ€b. b < min â‡’ P b) â‡’ P min) â‡’ âˆ€a. P a
</pre>

<DT><span class="strong">order_topology_exists</span>
<DD>
<pre>
âŠ¢ istopology
    {s |
     (âˆ€e. e âˆˆ s â‡’
          (âˆƒa b. e âˆˆ ival a b âˆ§ ival a b âŠ† s) âˆ¨ âˆƒb. e < b âˆ§ âˆ€d. d < b â‡’ d âˆˆ s)}
</pre>

<DT><span class="strong">orderiso_cardeq_elsOf</span>
<DD>
<pre>
âŠ¢ orderiso w1 w2 â‡’ elsOf w1 â‰ˆ elsOf w2
</pre>

<DT><span class="strong">orderiso_wobound2</span>
<DD>
<pre>
âŠ¢ orderiso (wobound x w) (wobound y w) â‡’ (x,y) âˆ‰ strict (destWO w)
</pre>

<DT><span class="strong">orderlt_iso_REFL</span>
<DD>
<pre>
âŠ¢ orderiso w1 w2 â‡’ Â¬orderlt w1 w2
</pre>

<DT><span class="strong">ordinal_ABS_REP_CLASS</span>
<DD>
<pre>
âŠ¢ (âˆ€a. ordinal_ABS_CLASS (ordinal_REP_CLASS a) = a) âˆ§
  âˆ€c. (âˆƒr. orderiso r r âˆ§ (c = orderiso r)) â‡”
      (ordinal_REP_CLASS (ordinal_ABS_CLASS c) = c)
</pre>

<DT><span class="strong">ordinal_IVT</span>
<DD>
<pre>
âŠ¢ (âˆ€a. 0 < a âˆ§ islimit a â‡’ (f a = sup (IMAGE f (preds a)))) âˆ§
  (âˆ€x y. x â‰¤ y â‡’ f x â‰¤ f y) âˆ§ a1 < a2 âˆ§ f a1 â‰¤ c âˆ§ c < f a2 â‡’
  âˆƒb. a1 â‰¤ b âˆ§ b < a2 âˆ§ f b â‰¤ c âˆ§ c < f bâº
</pre>

<DT><span class="strong">ordinal_QUOTIENT</span>
<DD>
<pre>
âŠ¢ QUOTIENT orderiso mkOrdinal ordinal_REP
</pre>

<DT><span class="strong">ordle_ANTISYM</span>
<DD>
<pre>
âŠ¢ a â‰¤ b âˆ§ b â‰¤ a â‡’ (a = b)
</pre>

<DT><span class="strong">ordle_CANCEL_ADDR</span>
<DD>
<pre>
âŠ¢ x â‰¤ x + a
</pre>

<DT><span class="strong">ordle_EXISTS_ADD</span>
<DD>
<pre>
âŠ¢ âˆ€a b. a â‰¤ b â‡” âˆƒc. b = a + c
</pre>

<DT><span class="strong">ordle_TRANS</span>
<DD>
<pre>
âŠ¢ âˆ€x y z. x â‰¤ y âˆ§ y â‰¤ z â‡’ x â‰¤ z
</pre>

<DT><span class="strong">ordle_lteq</span>
<DD>
<pre>
âŠ¢ a â‰¤ b â‡” a < b âˆ¨ (a = b)
</pre>

<DT><span class="strong">ordleq0</span>
<DD>
<pre>
âŠ¢ x â‰¤ 0 â‡” (x = 0)
</pre>

<DT><span class="strong">ordlet_TRANS</span>
<DD>
<pre>
âŠ¢ âˆ€x y z. x â‰¤ y âˆ§ y < z â‡’ x < z
</pre>

<DT><span class="strong">ordlt_CANCEL</span>
<DD>
<pre>
âŠ¢ âˆ€b a c. c + a < c + b â‡” a < b
</pre>

<DT><span class="strong">ordlt_CANCEL_ADDL</span>
<DD>
<pre>
âŠ¢ a + b < a â‡” F
</pre>

<DT><span class="strong">ordlt_CANCEL_ADDR</span>
<DD>
<pre>
âŠ¢ âˆ€b a. a < a + b â‡” 0 < b
</pre>

<DT><span class="strong">ordlt_DISCRETE1</span>
<DD>
<pre>
âŠ¢ Â¬(a < b âˆ§ b < aâº)
</pre>

<DT><span class="strong">ordlt_EXISTS_ADD</span>
<DD>
<pre>
âŠ¢ âˆ€a b. a < b â‡” âˆƒc. c â‰  0 âˆ§ (b = a + c)
</pre>

<DT><span class="strong">ordlt_REFL</span>
<DD>
<pre>
âŠ¢ âˆ€w. w â‰¤ w
</pre>

<DT><span class="strong">ordlt_SUC</span>
<DD>
<pre>
âŠ¢ a < aâº
</pre>

<DT><span class="strong">ordlt_SUC_DISCRETE</span>
<DD>
<pre>
âŠ¢ a < bâº â‡” a < b âˆ¨ (a = b)
</pre>

<DT><span class="strong">ordlt_TRANS</span>
<DD>
<pre>
âŠ¢ âˆ€w1 w2 w3. w1 < w2 âˆ§ w2 < w3 â‡’ w1 < w3
</pre>

<DT><span class="strong">ordlt_WF</span>
<DD>
<pre>
âŠ¢ WF $<
</pre>

<DT><span class="strong">ordlt_ZERO</span>
<DD>
<pre>
âŠ¢ 0 â‰¤ a
</pre>

<DT><span class="strong">ordlt_fromNat</span>
<DD>
<pre>
âŠ¢ âˆ€n x. x < &n â‡” âˆƒm. (x = &m) âˆ§ m < n
</pre>

<DT><span class="strong">ordlt_mkOrdinal</span>
<DD>
<pre>
âŠ¢ o1 < o2 â‡” âˆ€w1 w2. (mkOrdinal w1 = o1) âˆ§ (mkOrdinal w2 = o2) â‡’ orderlt w1 w2
</pre>

<DT><span class="strong">ordlt_preds_mono</span>
<DD>
<pre>
âŠ¢ a < b â‡’ preds a â‰¼ preds b
</pre>

<DT><span class="strong">ordlt_trichotomy</span>
<DD>
<pre>
âŠ¢ âˆ€w2 w1. w1 < w2 âˆ¨ (w1 = w2) âˆ¨ w2 < w1
</pre>

<DT><span class="strong">ordlte_TRANS</span>
<DD>
<pre>
âŠ¢ âˆ€x y z. x < y âˆ§ y â‰¤ z â‡’ x < z
</pre>

<DT><span class="strong">polyform_0</span>
<DD>
<pre>
âŠ¢ 1 < a â‡’ (polyform a 0 = [])
</pre>

<DT><span class="strong">polyform_EQ_NIL</span>
<DD>
<pre>
âŠ¢ 1 < a â‡’ ((polyform a x = []) â‡” (x = 0))
</pre>

<DT><span class="strong">polyform_UNIQUE</span>
<DD>
<pre>
âŠ¢ âˆ€a b ces.
    1 < a âˆ§ is_polyform a ces âˆ§ (b = eval_poly a ces) â‡’ (polyform a b = ces)
</pre>

<DT><span class="strong">polyform_eval_poly</span>
<DD>
<pre>
âŠ¢ 1 < a âˆ§ is_polyform a b â‡’ (polyform a (eval_poly a b) = b)
</pre>

<DT><span class="strong">polyform_exists</span>
<DD>
<pre>
âŠ¢ âˆ€a b. 1 < a â‡’ âˆƒces. is_polyform a ces âˆ§ (b = eval_poly a ces)
</pre>

<DT><span class="strong">predimage_sup_thm</span>
<DD>
<pre>
âŠ¢ âˆ€b. b < sup (IMAGE f (preds a)) â‡” âˆƒd. d < a âˆ§ b < f d
</pre>

<DT><span class="strong">predimage_suplt_ELIM</span>
<DD>
<pre>
âŠ¢ sup (IMAGE f (preds a)) < b â‡’ âˆ€d. d < a â‡’ f d â‰¤ b
</pre>

<DT><span class="strong">preds_0</span>
<DD>
<pre>
âŠ¢ preds 0 = âˆ…
</pre>

<DT><span class="strong">preds_11</span>
<DD>
<pre>
âŠ¢ (preds w1 = preds w2) â‡” (w1 = w2)
</pre>

<DT><span class="strong">preds_EQ_EMPTY</span>
<DD>
<pre>
âŠ¢ (preds x = âˆ…) â‡” (x = 0)
</pre>

<DT><span class="strong">preds_bij</span>
<DD>
<pre>
âŠ¢ BIJ preds ğ•Œ(:Î± ordinal) (downward_closed DELETE ğ•Œ(:Î± ordinal))
</pre>

<DT><span class="strong">preds_downward_closed</span>
<DD>
<pre>
âŠ¢ downward_closed (preds w)
</pre>

<DT><span class="strong">preds_inj_univ</span>
<DD>
<pre>
âŠ¢ preds ord â‰¼ ğ•Œ(:num + Î±)
</pre>

<DT><span class="strong">preds_lesup</span>
<DD>
<pre>
âŠ¢ downward_closed s âˆ§ s â‰  ğ•Œ(:Î± ordinal) â‡’ âˆ€d. d âˆˆ s â‡’ d â‰¤ sup s
</pre>

<DT><span class="strong">preds_lt_PSUBSET</span>
<DD>
<pre>
âŠ¢ w1 < w2 â‡” preds w1 âŠ‚ preds w2
</pre>

<DT><span class="strong">preds_nat</span>
<DD>
<pre>
âŠ¢ preds (&n) = IMAGE $& (count n)
</pre>

<DT><span class="strong">preds_omax_SOME_SUC</span>
<DD>
<pre>
âŠ¢ (omax (preds a) = SOME b) â‡” (a = bâº)
</pre>

<DT><span class="strong">preds_omega_UNIV</span>
<DD>
<pre>
âŠ¢ preds Ï‰ â‰ˆ ğ•Œ(:num)
</pre>

<DT><span class="strong">preds_omega_lt_preds_omega1</span>
<DD>
<pre>
âŠ¢ preds Ï‰ â‰º preds Ï‰â‚
</pre>

<DT><span class="strong">preds_ordSUC</span>
<DD>
<pre>
âŠ¢ preds aâº = a INSERT preds a
</pre>

<DT><span class="strong">preds_sup</span>
<DD>
<pre>
âŠ¢ s â‰¼ ğ•Œ(:num + Î±) â‡’ (preds (sup s) = dclose s)
</pre>

<DT><span class="strong">preds_sup_thm</span>
<DD>
<pre>
âŠ¢ downward_closed s âˆ§ s â‰  ğ•Œ(:Î± ordinal) â‡’ âˆ€b. b < sup s â‡” âˆƒd. d âˆˆ s âˆ§ b < d
</pre>

<DT><span class="strong">preds_suple</span>
<DD>
<pre>
âŠ¢ downward_closed s âˆ§ s â‰  ğ•Œ(:Î± ordinal) â‡’ (sup s â‰¤ b â‡” âˆ€d. d âˆˆ s â‡’ d â‰¤ b)
</pre>

<DT><span class="strong">preds_surj</span>
<DD>
<pre>
âŠ¢ âˆ€x. downward_closed x âˆ§ x â‰  ğ•Œ(:Î± ordinal) â‡’ âˆƒy. preds y = x
</pre>

<DT><span class="strong">preds_wobound</span>
<DD>
<pre>
âŠ¢ preds ord = elsOf (wobound ord allOrds)
</pre>

<DT><span class="strong">rays_open</span>
<DD>
<pre>
âŠ¢ open_in ordlt_top {x | x < a} âˆ§ open_in ordlt_top {x | a < x}
</pre>

<DT><span class="strong">simple_ord_induction</span>
<DD>
<pre>
âŠ¢ âˆ€P. P 0 âˆ§ (âˆ€a. P a â‡’ P aâº) âˆ§
      (âˆ€a. islimit a âˆ§ 0 < a âˆ§ (âˆ€b. b < a â‡’ P b) â‡’ P a) â‡’
      âˆ€a. P a
</pre>

<DT><span class="strong">strict_continuity_preserves_islimit</span>
<DD>
<pre>
âŠ¢ (âˆ€s. s â‰¼ ğ•Œ(:num + Î±) âˆ§ s â‰  âˆ… â‡’ (f (sup s) = sup (IMAGE f s))) âˆ§
  (âˆ€x y. x < y â‡’ f x < f y) âˆ§ islimit a âˆ§ a â‰  0 â‡’
  islimit (f a)
</pre>

<DT><span class="strong">sup_EMPTY</span>
<DD>
<pre>
âŠ¢ sup âˆ… = 0
</pre>

<DT><span class="strong">sup_EQ_0</span>
<DD>
<pre>
âŠ¢ s â‰¼ ğ•Œ(:num + Î±) â‡’ ((sup s = 0) â‡” (s = âˆ…) âˆ¨ (s = {0}))
</pre>

<DT><span class="strong">sup_SING</span>
<DD>
<pre>
âŠ¢ sup {a} = a
</pre>

<DT><span class="strong">sup_eq_SUC</span>
<DD>
<pre>
âŠ¢ s â‰¼ ğ•Œ(:num + Î±) âˆ§ (sup s = aâº) â‡’ aâº âˆˆ s
</pre>

<DT><span class="strong">sup_eq_max</span>
<DD>
<pre>
âŠ¢ (âˆ€b. b âˆˆ s â‡’ b â‰¤ a) âˆ§ a âˆˆ s â‡’ (sup s = a)
</pre>

<DT><span class="strong">sup_eq_sup</span>
<DD>
<pre>
âŠ¢ s1 â‰¼ ğ•Œ(:num + Î±) âˆ§ s2 â‰¼ ğ•Œ(:num + Î±) âˆ§ (âˆ€a. a âˆˆ s1 â‡’ âˆƒb. b âˆˆ s2 âˆ§ a â‰¤ b) âˆ§
  (âˆ€b. b âˆˆ s2 â‡’ âˆƒa. a âˆˆ s1 âˆ§ b â‰¤ a) â‡’
  (sup s1 = sup s2)
</pre>

<DT><span class="strong">sup_lt_implies</span>
<DD>
<pre>
âŠ¢ s â‰¼ ğ•Œ(:num + Î±) âˆ§ sup s < a âˆ§ b âˆˆ s â‡’ b < a
</pre>

<DT><span class="strong">sup_preds_SUC</span>
<DD>
<pre>
âŠ¢ sup (preds aâº) = a
</pre>

<DT><span class="strong">sup_preds_omax_NONE</span>
<DD>
<pre>
âŠ¢ islimit a â‡” (sup (preds a) = a)
</pre>

<DT><span class="strong">sup_thm</span>
<DD>
<pre>
âŠ¢ s â‰¼ ğ•Œ(:num + Î±) â‡’ âˆ€a. a < sup s â‡” âˆƒb. b âˆˆ s âˆ§ a < b
</pre>

<DT><span class="strong">suple_thm</span>
<DD>
<pre>
âŠ¢ âˆ€b s. s â‰¼ ğ•Œ(:num + Î±) âˆ§ b âˆˆ s â‡’ b â‰¤ sup s
</pre>

<DT><span class="strong">suppred_suplt_ELIM</span>
<DD>
<pre>
âŠ¢ sup (preds a) < b â‡’ âˆ€d. d < a â‡’ d â‰¤ b
</pre>

<DT><span class="strong">topspace_ordlt_top</span>
<DD>
<pre>
âŠ¢ topspace ordlt_top = ğ•Œ(:Î± ordinal)
</pre>

<DT><span class="strong">transfer_ordinals</span>
<DD>
<pre>
âŠ¢ âˆ€a. preds a â‰¼ ğ•Œ(:num + Î²) â‡’
      âˆƒb. orderiso (wobound a allOrds) (wobound b allOrds) âˆ§ preds a â‰ˆ preds b
</pre>

<DT><span class="strong">ubsup_thm</span>
<DD>
<pre>
âŠ¢ (âˆ€a. a âˆˆ s â‡’ a < b) â‡’ âˆ€c. c < sup s â‡” âˆƒd. d âˆˆ s âˆ§ c < d
</pre>

<DT><span class="strong">ucinf_uncountable</span>
<DD>
<pre>
âŠ¢ uncountable ğ•Œ(:num + (Î± + num -> bool))
</pre>

<DT><span class="strong">ucord_sup_exists_lemma</span>
<DD>
<pre>
âŠ¢ {a | countableOrd a} â‰¼ ğ•Œ(:num + (Î± + num -> bool))
</pre>

<DT><span class="strong">unitinf_univnum</span>
<DD>
<pre>
âŠ¢ ğ•Œ(:num + unit) â‰ˆ ğ•Œ(:num)
</pre>

<DT><span class="strong">univ_cord_uncountable</span>
<DD>
<pre>
âŠ¢ uncountable ğ•Œ(:unit ordinal)
</pre>

<DT><span class="strong">univ_ord_greater_cardinal</span>
<DD>
<pre>
âŠ¢ ğ•Œ(:num + Î±) â‰º ğ•Œ(:Î± ordinal)
</pre>

<DT><span class="strong">wellorder_allOrds</span>
<DD>
<pre>
âŠ¢ wellorder {(x,y) | (x = y) âˆ¨ x < y}
</pre>

<DT><span class="strong">wellorder_ordinal_isomorphism</span>
<DD>
<pre>
âŠ¢ âˆ€w. orderiso w (wobound (mkOrdinal w) allOrds)
</pre>

<DT><span class="strong">x_le_ordEXP_x</span>
<DD>
<pre>
âŠ¢ âˆ€a x. 1 < a â‡’ x â‰¤ a ** x
</pre>

<DT><span class="strong">x_lt_omega1_countable</span>
<DD>
<pre>
âŠ¢ x < Ï‰â‚ â‡” countableOrd x
</pre>

</DL>



<hr>
</body>
</html>
