<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: res_quan</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "res_quan"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "pred_setTheory.html"><span class="strong">pred_set</span></a>

<h1>Theorems</h1>
<DL>
<DT><span class="strong">IN_BIGINTER_RES_FORALL</span>
<DD>
<pre>
⊢ ∀x sos. x ∈ BIGINTER sos ⇔ ∀s::sos. x ∈ s
</pre>

<DT><span class="strong">IN_BIGUNION_RES_EXISTS</span>
<DD>
<pre>
⊢ ∀x sos. x ∈ BIGUNION sos ⇔ ∃s::sos. x ∈ s
</pre>

<DT><span class="strong">NOT_RES_EXISTS</span>
<DD>
<pre>
⊢ ∀P s. ¬(∃x::s. P x) ⇔ ∀x::s. ¬P x
</pre>

<DT><span class="strong">NOT_RES_FORALL</span>
<DD>
<pre>
⊢ ∀P s. ¬(∀x::s. P x) ⇔ ∃x::s. ¬P x
</pre>

<DT><span class="strong">RES_ABSTRACT</span>
<DD>
<pre>
⊢ ∀p m x. x ∈ p ⇒ (RES_ABSTRACT p m x = m x)
</pre>

<DT><span class="strong">RES_ABSTRACT_EQUAL</span>
<DD>
<pre>
⊢ ∀p m1 m2.
    (∀x. x ∈ p ⇒ (m1 x = m2 x)) ⇒ (RES_ABSTRACT p m1 = RES_ABSTRACT p m2)
</pre>

<DT><span class="strong">RES_ABSTRACT_EQUAL_EQ</span>
<DD>
<pre>
⊢ ∀p m1 m2.
    (RES_ABSTRACT p m1 = RES_ABSTRACT p m2) ⇔ ∀x. x ∈ p ⇒ (m1 x = m2 x)
</pre>

<DT><span class="strong">RES_ABSTRACT_IDEMPOT</span>
<DD>
<pre>
⊢ ∀p m. RES_ABSTRACT p (RES_ABSTRACT p m) = RES_ABSTRACT p m
</pre>

<DT><span class="strong">RES_ABSTRACT_UNIV</span>
<DD>
<pre>
⊢ ∀m. RES_ABSTRACT 𝕌(:α) m = m
</pre>

<DT><span class="strong">RES_DISJ_EXISTS_DIST</span>
<DD>
<pre>
⊢ ∀P Q R. (∃i::(λi. P i ∨ Q i). R i) ⇔ (∃i::P. R i) ∨ ∃i::Q. R i
</pre>

<DT><span class="strong">RES_EXISTS</span>
<DD>
<pre>
⊢ ∀P f. RES_EXISTS P f ⇔ ∃x. x ∈ P ∧ f x
</pre>

<DT><span class="strong">RES_EXISTS_ALT</span>
<DD>
<pre>
⊢ ∀p m. RES_EXISTS p m ⇔ RES_SELECT p m ∈ p ∧ m (RES_SELECT p m)
</pre>

<DT><span class="strong">RES_EXISTS_BIGINTER</span>
<DD>
<pre>
⊢ ∀P sos. (∃x::BIGINTER sos. P x) ⇔ ∃x. (∀s::sos. x ∈ s) ∧ P x
</pre>

<DT><span class="strong">RES_EXISTS_BIGUNION</span>
<DD>
<pre>
⊢ ∀P sos. (∃x::BIGUNION sos. P x) ⇔ ∃(s::sos) (x::s). P x
</pre>

<DT><span class="strong">RES_EXISTS_DIFF</span>
<DD>
<pre>
⊢ ∀P s t x. (∃x::s DIFF t. P x) ⇔ ∃x::s. x ∉ t ∧ P x
</pre>

<DT><span class="strong">RES_EXISTS_DISJ_DIST</span>
<DD>
<pre>
⊢ ∀P Q R. (∃i::P. Q i ∨ R i) ⇔ (∃i::P. Q i) ∨ ∃i::P. R i
</pre>

<DT><span class="strong">RES_EXISTS_EMPTY</span>
<DD>
<pre>
⊢ ∀p. ¬RES_EXISTS ∅ p
</pre>

<DT><span class="strong">RES_EXISTS_EQUAL</span>
<DD>
<pre>
⊢ ∀P j. (∃i:: $= j. P i) ⇔ P j
</pre>

<DT><span class="strong">RES_EXISTS_F</span>
<DD>
<pre>
⊢ ∀P s x. ¬∃s::x. F
</pre>

<DT><span class="strong">RES_EXISTS_NOT_EMPTY</span>
<DD>
<pre>
⊢ ∀P s. RES_EXISTS s P ⇒ s ≠ ∅
</pre>

<DT><span class="strong">RES_EXISTS_NULL</span>
<DD>
<pre>
⊢ ∀p m. (∃x::p. m) ⇔ p ≠ ∅ ∧ m
</pre>

<DT><span class="strong">RES_EXISTS_REORDER</span>
<DD>
<pre>
⊢ ∀P Q R. (∃(i::P) (j::Q). R i j) ⇔ ∃(j::Q) (i::P). R i j
</pre>

<DT><span class="strong">RES_EXISTS_SUBSET</span>
<DD>
<pre>
⊢ ∀P s t. s ⊆ t ⇒ RES_EXISTS s P ⇒ RES_EXISTS t P
</pre>

<DT><span class="strong">RES_EXISTS_T</span>
<DD>
<pre>
⊢ ∀P s x. (∃x::s. T) ⇔ s ≠ ∅
</pre>

<DT><span class="strong">RES_EXISTS_UNION</span>
<DD>
<pre>
⊢ ∀P s t. RES_EXISTS (s ∪ t) P ⇔ RES_EXISTS s P ∨ RES_EXISTS t P
</pre>

<DT><span class="strong">RES_EXISTS_UNIQUE</span>
<DD>
<pre>
⊢ ∀P f. RES_EXISTS_UNIQUE P f ⇔ (∃x::P. f x) ∧ ∀x y::P. f x ∧ f y ⇒ (x = y)
</pre>

<DT><span class="strong">RES_EXISTS_UNIQUE_ALT</span>
<DD>
<pre>
⊢ ∀p m. RES_EXISTS_UNIQUE p m ⇔ ∃x::p. m x ∧ ∀y::p. m y ⇒ (y = x)
</pre>

<DT><span class="strong">RES_EXISTS_UNIQUE_ELIM</span>
<DD>
<pre>
⊢ ∀P s. (∃!x::s. P x) ⇔ ∃!x. x ∈ s ∧ P x
</pre>

<DT><span class="strong">RES_EXISTS_UNIQUE_EMPTY</span>
<DD>
<pre>
⊢ ∀p. ¬RES_EXISTS_UNIQUE ∅ p
</pre>

<DT><span class="strong">RES_EXISTS_UNIQUE_EXISTS</span>
<DD>
<pre>
⊢ ∀P s. RES_EXISTS_UNIQUE P s ⇒ RES_EXISTS P s
</pre>

<DT><span class="strong">RES_EXISTS_UNIQUE_F</span>
<DD>
<pre>
⊢ ∀P s x. ¬∃!x::s. F
</pre>

<DT><span class="strong">RES_EXISTS_UNIQUE_NOT_EMPTY</span>
<DD>
<pre>
⊢ ∀P s. RES_EXISTS_UNIQUE s P ⇒ s ≠ ∅
</pre>

<DT><span class="strong">RES_EXISTS_UNIQUE_NULL</span>
<DD>
<pre>
⊢ ∀p m. (∃!x::p. m) ⇔ (∃x. p = {x}) ∧ m
</pre>

<DT><span class="strong">RES_EXISTS_UNIQUE_SING</span>
<DD>
<pre>
⊢ ∀P s x. (∃!x::s. T) ⇔ ∃y. s = {y}
</pre>

<DT><span class="strong">RES_EXISTS_UNIQUE_T</span>
<DD>
<pre>
⊢ ∀P s x. (∃!x::s. T) ⇔ ∃!x. x ∈ s
</pre>

<DT><span class="strong">RES_EXISTS_UNIQUE_UNIV</span>
<DD>
<pre>
⊢ ∀p. RES_EXISTS_UNIQUE 𝕌(:α) p ⇔ $?! p
</pre>

<DT><span class="strong">RES_EXISTS_UNIV</span>
<DD>
<pre>
⊢ ∀p. RES_EXISTS 𝕌(:α) p ⇔ $? p
</pre>

<DT><span class="strong">RES_FORALL</span>
<DD>
<pre>
⊢ ∀P f. RES_FORALL P f ⇔ ∀x. x ∈ P ⇒ f x
</pre>

<DT><span class="strong">RES_FORALL_BIGINTER</span>
<DD>
<pre>
⊢ ∀P sos. (∀x::BIGINTER sos. P x) ⇔ ∀x. (∀s::sos. x ∈ s) ⇒ P x
</pre>

<DT><span class="strong">RES_FORALL_BIGUNION</span>
<DD>
<pre>
⊢ ∀P sos. (∀x::BIGUNION sos. P x) ⇔ ∀(s::sos) (x::s). P x
</pre>

<DT><span class="strong">RES_FORALL_CONJ_DIST</span>
<DD>
<pre>
⊢ ∀P Q R. (∀i::P. Q i ∧ R i) ⇔ (∀i::P. Q i) ∧ ∀i::P. R i
</pre>

<DT><span class="strong">RES_FORALL_DIFF</span>
<DD>
<pre>
⊢ ∀P s t x. (∀x::s DIFF t. P x) ⇔ ∀x::s. x ∉ t ⇒ P x
</pre>

<DT><span class="strong">RES_FORALL_DISJ_DIST</span>
<DD>
<pre>
⊢ ∀P Q R. (∀i::(λj. P j ∨ Q j). R i) ⇔ (∀i::P. R i) ∧ ∀i::Q. R i
</pre>

<DT><span class="strong">RES_FORALL_EMPTY</span>
<DD>
<pre>
⊢ ∀p. RES_FORALL ∅ p
</pre>

<DT><span class="strong">RES_FORALL_F</span>
<DD>
<pre>
⊢ ∀P s x. (∀x::s. F) ⇔ (s = ∅)
</pre>

<DT><span class="strong">RES_FORALL_FORALL</span>
<DD>
<pre>
⊢ ∀P R x. (∀x (i::P). R i x) ⇔ ∀(i::P) x. R i x
</pre>

<DT><span class="strong">RES_FORALL_NOT_EMPTY</span>
<DD>
<pre>
⊢ ∀P s. ¬RES_FORALL s P ⇒ s ≠ ∅
</pre>

<DT><span class="strong">RES_FORALL_NULL</span>
<DD>
<pre>
⊢ ∀p m. (∀x::p. m) ⇔ (p = ∅) ∨ m
</pre>

<DT><span class="strong">RES_FORALL_REORDER</span>
<DD>
<pre>
⊢ ∀P Q R. (∀(i::P) (j::Q). R i j) ⇔ ∀(j::Q) (i::P). R i j
</pre>

<DT><span class="strong">RES_FORALL_SUBSET</span>
<DD>
<pre>
⊢ ∀P s t. s ⊆ t ⇒ RES_FORALL t P ⇒ RES_FORALL s P
</pre>

<DT><span class="strong">RES_FORALL_T</span>
<DD>
<pre>
⊢ ∀P s x (x::s). T
</pre>

<DT><span class="strong">RES_FORALL_UNION</span>
<DD>
<pre>
⊢ ∀P s t. RES_FORALL (s ∪ t) P ⇔ RES_FORALL s P ∧ RES_FORALL t P
</pre>

<DT><span class="strong">RES_FORALL_UNIQUE</span>
<DD>
<pre>
⊢ ∀P j. (∀i:: $= j. P i) ⇔ P j
</pre>

<DT><span class="strong">RES_FORALL_UNIV</span>
<DD>
<pre>
⊢ ∀p. RES_FORALL 𝕌(:α) p ⇔ $! p
</pre>

<DT><span class="strong">RES_SELECT</span>
<DD>
<pre>
⊢ ∀P f. RES_SELECT P f = @x. x ∈ P ∧ f x
</pre>

<DT><span class="strong">RES_SELECT_EMPTY</span>
<DD>
<pre>
⊢ ∀p. RES_SELECT ∅ p = @x. F
</pre>

<DT><span class="strong">RES_SELECT_UNIV</span>
<DD>
<pre>
⊢ ∀p. RES_SELECT 𝕌(:α) p = $@ p
</pre>

</DL>



<hr>
</body>
</html>
