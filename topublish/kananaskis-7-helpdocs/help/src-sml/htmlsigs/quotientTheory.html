<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure quotientTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure quotientTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/quotient/src/quotientScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature quotientTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val ?!! : thm
<a name="line7"></a>    val EQUIV_def : thm
<a name="line8"></a>    val FUN_MAP : thm
<a name="line9"></a>    val FUN_REL : thm
<a name="line10"></a>    val PARTIAL_EQUIV_def : thm
<a name="line11"></a>    val QUOTIENT_def : thm
<a name="line12"></a>    val RES_EXISTS_EQUIV_DEF : thm
<a name="line13"></a>    val respects_def : thm
<a name="line14"></a>  
<a name="line15"></a>  (*  Theorems  *)
<a name="line16"></a>    val ABSTRACT_PRS : thm
<a name="line17"></a>    val ABSTRACT_RES_ABSTRACT : thm
<a name="line18"></a>    val APPLY_PRS : thm
<a name="line19"></a>    val APPLY_RSP : thm
<a name="line20"></a>    val COND_PRS : thm
<a name="line21"></a>    val COND_RSP : thm
<a name="line22"></a>    val CONJ_IMPLIES : thm
<a name="line23"></a>    val C_PRS : thm
<a name="line24"></a>    val C_RSP : thm
<a name="line25"></a>    val DISJ_IMPLIES : thm
<a name="line26"></a>    val EQUALS_EQUIV_IMPLIES : thm
<a name="line27"></a>    val EQUALS_IMPLIES : thm
<a name="line28"></a>    val EQUALS_PRS : thm
<a name="line29"></a>    val EQUALS_RSP : thm
<a name="line30"></a>    val EQUIV_IMP_PARTIAL_EQUIV : thm
<a name="line31"></a>    val EQUIV_REFL_SYM_TRANS : thm
<a name="line32"></a>    val EQUIV_RES_ABSTRACT_LEFT : thm
<a name="line33"></a>    val EQUIV_RES_ABSTRACT_RIGHT : thm
<a name="line34"></a>    val EQUIV_RES_EXISTS : thm
<a name="line35"></a>    val EQUIV_RES_EXISTS_UNIQUE : thm
<a name="line36"></a>    val EQUIV_RES_FORALL : thm
<a name="line37"></a>    val EQ_IMPLIES : thm
<a name="line38"></a>    val EXISTS_PRS : thm
<a name="line39"></a>    val EXISTS_REGULAR : thm
<a name="line40"></a>    val EXISTS_UNIQUE_PRS : thm
<a name="line41"></a>    val EXISTS_UNIQUE_REGULAR : thm
<a name="line42"></a>    val FORALL_PRS : thm
<a name="line43"></a>    val FORALL_REGULAR : thm
<a name="line44"></a>    val FUN_MAP_I : thm
<a name="line45"></a>    val FUN_MAP_THM : thm
<a name="line46"></a>    val FUN_QUOTIENT : thm
<a name="line47"></a>    val FUN_REL_EQ : thm
<a name="line48"></a>    val FUN_REL_EQUALS : thm
<a name="line49"></a>    val FUN_REL_EQ_REL : thm
<a name="line50"></a>    val FUN_REL_IMP : thm
<a name="line51"></a>    val FUN_REL_MP : thm
<a name="line52"></a>    val IDENTITY_EQUIV : thm
<a name="line53"></a>    val IDENTITY_QUOTIENT : thm
<a name="line54"></a>    val IMP_IMPLIES : thm
<a name="line55"></a>    val IN_FUN : thm
<a name="line56"></a>    val IN_RESPECTS : thm
<a name="line57"></a>    val I_PRS : thm
<a name="line58"></a>    val I_RSP : thm
<a name="line59"></a>    val K_PRS : thm
<a name="line60"></a>    val K_RSP : thm
<a name="line61"></a>    val LAMBDA_PRS : thm
<a name="line62"></a>    val LAMBDA_PRS1 : thm
<a name="line63"></a>    val LAMBDA_REP_ABS_RSP : thm
<a name="line64"></a>    val LAMBDA_RSP : thm
<a name="line65"></a>    val LEFT_RES_EXISTS_REGULAR : thm
<a name="line66"></a>    val LEFT_RES_FORALL_REGULAR : thm
<a name="line67"></a>    val LET_PRS : thm
<a name="line68"></a>    val LET_RES_ABSTRACT : thm
<a name="line69"></a>    val LET_RSP : thm
<a name="line70"></a>    val NOT_IMPLIES : thm
<a name="line71"></a>    val QUOTIENT_ABS_REP : thm
<a name="line72"></a>    val QUOTIENT_REL : thm
<a name="line73"></a>    val QUOTIENT_REL_ABS : thm
<a name="line74"></a>    val QUOTIENT_REL_ABS_EQ : thm
<a name="line75"></a>    val QUOTIENT_REL_REP : thm
<a name="line76"></a>    val QUOTIENT_REP_ABS : thm
<a name="line77"></a>    val QUOTIENT_REP_REFL : thm
<a name="line78"></a>    val QUOTIENT_SYM : thm
<a name="line79"></a>    val QUOTIENT_TRANS : thm
<a name="line80"></a>    val REP_ABS_RSP : thm
<a name="line81"></a>    val RESPECTS : thm
<a name="line82"></a>    val RESPECTS_MP : thm
<a name="line83"></a>    val RESPECTS_REP_ABS : thm
<a name="line84"></a>    val RESPECTS_THM : thm
<a name="line85"></a>    val RESPECTS_o : thm
<a name="line86"></a>    val RES_ABSTRACT_ABSTRACT : thm
<a name="line87"></a>    val RES_ABSTRACT_RSP : thm
<a name="line88"></a>    val RES_EXISTS_EQUIV : thm
<a name="line89"></a>    val RES_EXISTS_EQUIV_RSP : thm
<a name="line90"></a>    val RES_EXISTS_PRS : thm
<a name="line91"></a>    val RES_EXISTS_REGULAR : thm
<a name="line92"></a>    val RES_EXISTS_RSP : thm
<a name="line93"></a>    val RES_EXISTS_UNIQUE_REGULAR : thm
<a name="line94"></a>    val RES_EXISTS_UNIQUE_REGULAR_SAME : thm
<a name="line95"></a>    val RES_EXISTS_UNIQUE_RESPECTS_REGULAR : thm
<a name="line96"></a>    val RES_FORALL_PRS : thm
<a name="line97"></a>    val RES_FORALL_REGULAR : thm
<a name="line98"></a>    val RES_FORALL_RSP : thm
<a name="line99"></a>    val RIGHT_RES_EXISTS_REGULAR : thm
<a name="line100"></a>    val RIGHT_RES_FORALL_REGULAR : thm
<a name="line101"></a>    val W_PRS : thm
<a name="line102"></a>    val W_RSP : thm
<a name="line103"></a>    val literal_case_PRS : thm
<a name="line104"></a>    val literal_case_RSP : thm
<a name="line105"></a>    val o_PRS : thm
<a name="line106"></a>    val o_RSP : thm
<a name="line107"></a>  
<a name="line108"></a>  val quotient_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line109"></a>(*
   [res_quan] Parent theory of "quotient"
   
   [?!!]  Definition
      
      |- ∀P. $?!! P ⇔ $?! P
   
   [EQUIV_def]  Definition
      
      |- ∀E. EQUIV E ⇔ ∀x y. E x y ⇔ (E x = E y)
   
   [FUN_MAP]  Definition
      
      |- ∀f g. f --&gt; g = (λh x. g (h (f x)))
   
   [FUN_REL]  Definition
      
      |- ∀R1 R2 f g. (R1 ===&gt; R2) f g ⇔ ∀x y. R1 x y ⇒ R2 (f x) (g y)
   
   [PARTIAL_EQUIV_def]  Definition
      
      |- ∀R.
           PARTIAL_EQUIV R ⇔
           (∃x. R x x) ∧ ∀x y. R x y ⇔ R x x ∧ R y y ∧ (R x = R y)
   
   [QUOTIENT_def]  Definition
      
      |- ∀R abs rep.
           QUOTIENT R abs rep ⇔
           (∀a. abs (rep a) = a) ∧ (∀a. R (rep a) (rep a)) ∧
           ∀r s. R r s ⇔ R r r ∧ R s s ∧ (abs r = abs s)
   
   [RES_EXISTS_EQUIV_DEF]  Definition
      
      |- RES_EXISTS_EQUIV =
         (λR P.
            (∃x::respects R. P x) ∧ ∀x y::respects R. P x ∧ P y ⇒ R x y)
   
   [respects_def]  Definition
      
      |- respects = W
   
   [ABSTRACT_PRS]  Theorem
      
      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f.
               f =
               (rep1 --&gt; abs2)
                 (RES_ABSTRACT (respects R1) ((abs1 --&gt; rep2) f))
   
   [ABSTRACT_RES_ABSTRACT]  Theorem
      
      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 f g.
             (R1 ===&gt; R2) f g ⇒
             (R1 ===&gt; R2) f (RES_ABSTRACT (respects R1) g)
   
   [APPLY_PRS]  Theorem
      
      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f x. f x = abs2 ((abs1 --&gt; rep2) f (rep1 x))
   
   [APPLY_RSP]  Theorem
      
      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f g x y. (R1 ===&gt; R2) f g ∧ R1 x y ⇒ R2 (f x) (g y)
   
   [COND_PRS]  Theorem
      
      |- ∀R abs rep.
           QUOTIENT R abs rep ⇒
           ∀a b c. (if a then b else c) = abs (if a then rep b else rep c)
   
   [COND_RSP]  Theorem
      
      |- ∀R abs rep.
           QUOTIENT R abs rep ⇒
           ∀a1 a2 b1 b2 c1 c2.
             (a1 ⇔ a2) ∧ R b1 b2 ∧ R c1 c2 ⇒
             R (if a1 then b1 else c1) (if a2 then b2 else c2)
   
   [CONJ_IMPLIES]  Theorem
      
      |- ∀P P' Q Q'. (P ⇒ Q) ∧ (P' ⇒ Q') ⇒ P ∧ P' ⇒ Q ∧ Q'
   
   [C_PRS]  Theorem
      
      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀R3 abs3 rep3.
               QUOTIENT R3 abs3 rep3 ⇒
               ∀f x y.
                 combin$C f x y =
                 abs3
                   (combin$C ((abs1 --&gt; abs2 --&gt; rep3) f) (rep2 x)
                      (rep1 y))
   
   [C_RSP]  Theorem
      
      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀R3 abs3 rep3.
               QUOTIENT R3 abs3 rep3 ⇒
               ∀f1 f2 x1 x2 y1 y2.
                 (R1 ===&gt; R2 ===&gt; R3) f1 f2 ∧ R2 x1 x2 ∧ R1 y1 y2 ⇒
                 R3 (combin$C f1 x1 y1) (combin$C f2 x2 y2)
   
   [DISJ_IMPLIES]  Theorem
      
      |- ∀P P' Q Q'. (P ⇒ Q) ∧ (P' ⇒ Q') ⇒ P ∨ P' ⇒ Q ∨ Q'
   
   [EQUALS_EQUIV_IMPLIES]  Theorem
      
      |- ∀R. EQUIV R ⇒ R a1 a2 ∧ R b1 b2 ⇒ (a1 = b1) ⇒ R a2 b2
   
   [EQUALS_IMPLIES]  Theorem
      
      |- ∀P P' Q Q'. (P = Q) ∧ (P' = Q') ⇒ (P = P') ⇒ (Q = Q')
   
   [EQUALS_PRS]  Theorem
      
      |- ∀R abs rep. QUOTIENT R abs rep ⇒ ∀x y. (x = y) ⇔ R (rep x) (rep y)
   
   [EQUALS_RSP]  Theorem
      
      |- ∀R abs rep.
           QUOTIENT R abs rep ⇒
           ∀x1 x2 y1 y2. R x1 x2 ∧ R y1 y2 ⇒ (R x1 y1 ⇔ R x2 y2)
   
   [EQUIV_IMP_PARTIAL_EQUIV]  Theorem
      
      |- ∀R. EQUIV R ⇒ PARTIAL_EQUIV R
   
   [EQUIV_REFL_SYM_TRANS]  Theorem
      
      |- ∀R.
           (∀x y. R x y ⇔ (R x = R y)) ⇔
           (∀x. R x x) ∧ (∀x y. R x y ⇒ R y x) ∧
           ∀x y z. R x y ∧ R y z ⇒ R x z
   
   [EQUIV_RES_ABSTRACT_LEFT]  Theorem
      
      |- ∀R1 R2 f1 f2 x1 x2.
           R2 (f1 x1) (f2 x2) ∧ R1 x1 x1 ⇒
           R2 (RES_ABSTRACT (respects R1) f1 x1) (f2 x2)
   
   [EQUIV_RES_ABSTRACT_RIGHT]  Theorem
      
      |- ∀R1 R2 f1 f2 x1 x2.
           R2 (f1 x1) (f2 x2) ∧ R1 x2 x2 ⇒
           R2 (f1 x1) (RES_ABSTRACT (respects R1) f2 x2)
   
   [EQUIV_RES_EXISTS]  Theorem
      
      |- ∀E P. EQUIV E ⇒ (RES_EXISTS (respects E) P ⇔ $? P)
   
   [EQUIV_RES_EXISTS_UNIQUE]  Theorem
      
      |- ∀E P. EQUIV E ⇒ (RES_EXISTS_UNIQUE (respects E) P ⇔ $?! P)
   
   [EQUIV_RES_FORALL]  Theorem
      
      |- ∀E P. EQUIV E ⇒ (RES_FORALL (respects E) P ⇔ $! P)
   
   [EQ_IMPLIES]  Theorem
      
      |- ∀P Q. (P ⇔ Q) ⇒ P ⇒ Q
   
   [EXISTS_PRS]  Theorem
      
      |- ∀R abs rep.
           QUOTIENT R abs rep ⇒
           ∀f. $? f ⇔ RES_EXISTS (respects R) ((abs --&gt; I) f)
   
   [EXISTS_REGULAR]  Theorem
      
      |- ∀P Q. (∀x. P x ⇒ Q x) ⇒ $? P ⇒ $? Q
   
   [EXISTS_UNIQUE_PRS]  Theorem
      
      |- ∀R abs rep.
           QUOTIENT R abs rep ⇒
           ∀f. $?! f ⇔ RES_EXISTS_EQUIV R ((abs --&gt; I) f)
   
   [EXISTS_UNIQUE_REGULAR]  Theorem
      
      |- ∀P E Q.
           (∀x. P x ⇒ respects E x ∧ Q x) ∧
           (∀x y. respects E x ∧ Q x ∧ respects E y ∧ Q y ⇒ E x y) ⇒
           $?! P ⇒
           RES_EXISTS_EQUIV E Q
   
   [FORALL_PRS]  Theorem
      
      |- ∀R abs rep.
           QUOTIENT R abs rep ⇒
           ∀f. $! f ⇔ RES_FORALL (respects R) ((abs --&gt; I) f)
   
   [FORALL_REGULAR]  Theorem
      
      |- ∀P Q. (∀x. P x ⇒ Q x) ⇒ $! P ⇒ $! Q
   
   [FUN_MAP_I]  Theorem
      
      |- I --&gt; I = I
   
   [FUN_MAP_THM]  Theorem
      
      |- ∀f g h x. (f --&gt; g) h x = g (h (f x))
   
   [FUN_QUOTIENT]  Theorem
      
      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             QUOTIENT (R1 ===&gt; R2) (rep1 --&gt; abs2) (abs1 --&gt; rep2)
   
   [FUN_REL_EQ]  Theorem
      
      |- $= ===&gt; $= = $=
   
   [FUN_REL_EQUALS]  Theorem
      
      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f g.
               respects (R1 ===&gt; R2) f ∧ respects (R1 ===&gt; R2) g ⇒
               (((rep1 --&gt; abs2) f = (rep1 --&gt; abs2) g) ⇔
                ∀x y. R1 x y ⇒ R2 (f x) (g y))
   
   [FUN_REL_EQ_REL]  Theorem
      
      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f g.
               (R1 ===&gt; R2) f g ⇔
               respects (R1 ===&gt; R2) f ∧ respects (R1 ===&gt; R2) g ∧
               ((rep1 --&gt; abs2) f = (rep1 --&gt; abs2) g)
   
   [FUN_REL_IMP]  Theorem
      
      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f g.
               respects (R1 ===&gt; R2) f ∧ respects (R1 ===&gt; R2) g ∧
               ((rep1 --&gt; abs2) f = (rep1 --&gt; abs2) g) ⇒
               ∀x y. R1 x y ⇒ R2 (f x) (g y)
   
   [FUN_REL_MP]  Theorem
      
      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f g x y. (R1 ===&gt; R2) f g ∧ R1 x y ⇒ R2 (f x) (g y)
   
   [IDENTITY_EQUIV]  Theorem
      
      |- EQUIV $=
   
   [IDENTITY_QUOTIENT]  Theorem
      
      |- QUOTIENT $= I I
   
   [IMP_IMPLIES]  Theorem
      
      |- ∀P P' Q Q'. (Q ⇒ P) ∧ (P' ⇒ Q') ⇒ (P ⇒ P') ⇒ Q ⇒ Q'
   
   [IN_FUN]  Theorem
      
      |- ∀f g s x. x ∈ (f --&gt; g) s ⇔ g (f x ∈ s)
   
   [IN_RESPECTS]  Theorem
      
      |- ∀R x. x ∈ respects R ⇔ R x x
   
   [I_PRS]  Theorem
      
      |- ∀R abs rep. QUOTIENT R abs rep ⇒ ∀e. I e = abs (I (rep e))
   
   [I_RSP]  Theorem
      
      |- ∀R abs rep. QUOTIENT R abs rep ⇒ ∀e1 e2. R e1 e2 ⇒ R (I e1) (I e2)
   
   [K_PRS]  Theorem
      
      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀x y. K x y = abs1 (K (rep1 x) (rep2 y))
   
   [K_RSP]  Theorem
      
      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀x1 x2 y1 y2. R1 x1 x2 ∧ R2 y1 y2 ⇒ R1 (K x1 y1) (K x2 y2)
   
   [LAMBDA_PRS]  Theorem
      
      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f. (λx. f x) = (rep1 --&gt; abs2) (λx. rep2 (f (abs1 x)))
   
   [LAMBDA_PRS1]  Theorem
      
      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f. (λx. f x) = (rep1 --&gt; abs2) (λx. (abs1 --&gt; rep2) f x)
   
   [LAMBDA_REP_ABS_RSP]  Theorem
      
      |- ∀REL1 abs1 rep1 REL2 abs2 rep2 f1 f2.
           ((∀r r'. REL1 r r' ⇒ REL1 r (rep1 (abs1 r'))) ∧
            ∀r r'. REL2 r r' ⇒ REL2 r (rep2 (abs2 r'))) ∧
           (REL1 ===&gt; REL2) f1 f2 ⇒
           (REL1 ===&gt; REL2) f1 ((abs1 --&gt; rep2) ((rep1 --&gt; abs2) f2))
   
   [LAMBDA_RSP]  Theorem
      
      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f1 f2.
               (R1 ===&gt; R2) f1 f2 ⇒ (R1 ===&gt; R2) (λx. f1 x) (λy. f2 y)
   
   [LEFT_RES_EXISTS_REGULAR]  Theorem
      
      |- ∀P R Q. (∀x. R x ⇒ Q x ⇒ P x) ⇒ RES_EXISTS R Q ⇒ $? P
   
   [LEFT_RES_FORALL_REGULAR]  Theorem
      
      |- ∀P R Q. (∀x. R x ∧ (Q x ⇒ P x)) ⇒ RES_FORALL R Q ⇒ $! P
   
   [LET_PRS]  Theorem
      
      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f x. LET f x = abs2 (LET ((abs1 --&gt; rep2) f) (rep1 x))
   
   [LET_RES_ABSTRACT]  Theorem
      
      |- ∀r lam v. v ∈ r ⇒ (LET (RES_ABSTRACT r lam) v = LET lam v)
   
   [LET_RSP]  Theorem
      
      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f g x y. (R1 ===&gt; R2) f g ∧ R1 x y ⇒ R2 (LET f x) (LET g y)
   
   [NOT_IMPLIES]  Theorem
      
      |- ∀P Q. (Q ⇒ P) ⇒ ¬P ⇒ ¬Q
   
   [QUOTIENT_ABS_REP]  Theorem
      
      |- ∀R abs rep. QUOTIENT R abs rep ⇒ ∀a. abs (rep a) = a
   
   [QUOTIENT_REL]  Theorem
      
      |- ∀R abs rep.
           QUOTIENT R abs rep ⇒
           ∀r s. R r s ⇔ R r r ∧ R s s ∧ (abs r = abs s)
   
   [QUOTIENT_REL_ABS]  Theorem
      
      |- ∀R abs rep. QUOTIENT R abs rep ⇒ ∀r s. R r s ⇒ (abs r = abs s)
   
   [QUOTIENT_REL_ABS_EQ]  Theorem
      
      |- ∀R abs rep.
           QUOTIENT R abs rep ⇒
           ∀r s. R r r ⇒ R s s ⇒ (R r s ⇔ (abs r = abs s))
   
   [QUOTIENT_REL_REP]  Theorem
      
      |- ∀R abs rep. QUOTIENT R abs rep ⇒ ∀a b. R (rep a) (rep b) ⇔ (a = b)
   
   [QUOTIENT_REP_ABS]  Theorem
      
      |- ∀R abs rep. QUOTIENT R abs rep ⇒ ∀r. R r r ⇒ R (rep (abs r)) r
   
   [QUOTIENT_REP_REFL]  Theorem
      
      |- ∀R abs rep. QUOTIENT R abs rep ⇒ ∀a. R (rep a) (rep a)
   
   [QUOTIENT_SYM]  Theorem
      
      |- ∀R abs rep. QUOTIENT R abs rep ⇒ ∀x y. R x y ⇒ R y x
   
   [QUOTIENT_TRANS]  Theorem
      
      |- ∀R abs rep. QUOTIENT R abs rep ⇒ ∀x y z. R x y ∧ R y z ⇒ R x z
   
   [REP_ABS_RSP]  Theorem
      
      |- ∀REL abs rep.
           QUOTIENT REL abs rep ⇒ ∀x1 x2. REL x1 x2 ⇒ REL x1 (rep (abs x2))
   
   [RESPECTS]  Theorem
      
      |- ∀R x. respects R x ⇔ R x x
   
   [RESPECTS_MP]  Theorem
      
      |- ∀R1 R2 f x y. respects (R1 ===&gt; R2) f ∧ R1 x y ⇒ R2 (f x) (f y)
   
   [RESPECTS_REP_ABS]  Theorem
      
      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 f x.
             respects (R1 ===&gt; R2) f ∧ R1 x x ⇒
             R2 (f (rep1 (abs1 x))) (f x)
   
   [RESPECTS_THM]  Theorem
      
      |- ∀R1 R2 f. respects (R1 ===&gt; R2) f ⇔ ∀x y. R1 x y ⇒ R2 (f x) (f y)
   
   [RESPECTS_o]  Theorem
      
      |- ∀R1 R2 R3 f g.
           respects (R2 ===&gt; R3) f ∧ respects (R1 ===&gt; R2) g ⇒
           respects (R1 ===&gt; R3) (f o g)
   
   [RES_ABSTRACT_ABSTRACT]  Theorem
      
      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 f g.
             (R1 ===&gt; R2) f g ⇒
             (R1 ===&gt; R2) (RES_ABSTRACT (respects R1) f) g
   
   [RES_ABSTRACT_RSP]  Theorem
      
      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f1 f2.
               (R1 ===&gt; R2) f1 f2 ⇒
               (R1 ===&gt; R2) (RES_ABSTRACT (respects R1) f1)
                 (RES_ABSTRACT (respects R1) f2)
   
   [RES_EXISTS_EQUIV]  Theorem
      
      |- ∀R m.
           RES_EXISTS_EQUIV R m ⇔
           (∃x::respects R. m x) ∧ ∀x y::respects R. m x ∧ m y ⇒ R x y
   
   [RES_EXISTS_EQUIV_RSP]  Theorem
      
      |- ∀R abs rep.
           QUOTIENT R abs rep ⇒
           ∀f g.
             (R ===&gt; $&lt;=&gt;) f g ⇒
             (RES_EXISTS_EQUIV R f ⇔ RES_EXISTS_EQUIV R g)
   
   [RES_EXISTS_PRS]  Theorem
      
      |- ∀R abs rep.
           QUOTIENT R abs rep ⇒
           ∀P f.
             RES_EXISTS P f ⇔ RES_EXISTS ((abs --&gt; I) P) ((abs --&gt; I) f)
   
   [RES_EXISTS_REGULAR]  Theorem
      
      |- ∀P Q R. (∀x. R x ⇒ P x ⇒ Q x) ⇒ RES_EXISTS R P ⇒ RES_EXISTS R Q
   
   [RES_EXISTS_RSP]  Theorem
      
      |- ∀R abs rep.
           QUOTIENT R abs rep ⇒
           ∀f g.
             (R ===&gt; $&lt;=&gt;) f g ⇒
             (RES_EXISTS (respects R) f ⇔ RES_EXISTS (respects R) g)
   
   [RES_EXISTS_UNIQUE_REGULAR]  Theorem
      
      |- ∀P R Q.
           (∀x. P x ⇒ Q x) ∧
           (∀x y. respects R x ∧ Q x ∧ respects R y ∧ Q y ⇒ R x y) ⇒
           RES_EXISTS_UNIQUE (respects R) P ⇒
           RES_EXISTS_EQUIV R Q
   
   [RES_EXISTS_UNIQUE_REGULAR_SAME]  Theorem
      
      |- ∀R P Q.
           (R ===&gt; $&lt;=&gt;) P Q ⇒
           RES_EXISTS_UNIQUE (respects R) P ⇒
           RES_EXISTS_EQUIV R Q
   
   [RES_EXISTS_UNIQUE_RESPECTS_REGULAR]  Theorem
      
      |- ∀R P. RES_EXISTS_UNIQUE (respects R) P ⇒ RES_EXISTS_EQUIV R P
   
   [RES_FORALL_PRS]  Theorem
      
      |- ∀R abs rep.
           QUOTIENT R abs rep ⇒
           ∀P f.
             RES_FORALL P f ⇔ RES_FORALL ((abs --&gt; I) P) ((abs --&gt; I) f)
   
   [RES_FORALL_REGULAR]  Theorem
      
      |- ∀P Q R. (∀x. R x ⇒ P x ⇒ Q x) ⇒ RES_FORALL R P ⇒ RES_FORALL R Q
   
   [RES_FORALL_RSP]  Theorem
      
      |- ∀R abs rep.
           QUOTIENT R abs rep ⇒
           ∀f g.
             (R ===&gt; $&lt;=&gt;) f g ⇒
             (RES_FORALL (respects R) f ⇔ RES_FORALL (respects R) g)
   
   [RIGHT_RES_EXISTS_REGULAR]  Theorem
      
      |- ∀P R Q. (∀x. R x ∧ (P x ⇒ Q x)) ⇒ $? P ⇒ RES_EXISTS R Q
   
   [RIGHT_RES_FORALL_REGULAR]  Theorem
      
      |- ∀P R Q. (∀x. R x ⇒ P x ⇒ Q x) ⇒ $! P ⇒ RES_FORALL R Q
   
   [W_PRS]  Theorem
      
      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f x. W f x = abs2 (W ((abs1 --&gt; abs1 --&gt; rep2) f) (rep1 x))
   
   [W_RSP]  Theorem
      
      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f1 f2 x1 x2.
               (R1 ===&gt; R1 ===&gt; R2) f1 f2 ∧ R1 x1 x2 ⇒
               R2 (W f1 x1) (W f2 x2)
   
   [literal_case_PRS]  Theorem
      
      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f x.
               literal_case f x =
               abs2 (literal_case ((abs1 --&gt; rep2) f) (rep1 x))
   
   [literal_case_RSP]  Theorem
      
      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f g x y.
               (R1 ===&gt; R2) f g ∧ R1 x y ⇒
               R2 (literal_case f x) (literal_case g y)
   
   [o_PRS]  Theorem
      
      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀R3 abs3 rep3.
               QUOTIENT R3 abs3 rep3 ⇒
               ∀f g.
                 f o g =
                 (rep1 --&gt; abs3) ((abs2 --&gt; rep3) f o (abs1 --&gt; rep2) g)
   
   [o_RSP]  Theorem
      
      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀R3 abs3 rep3.
               QUOTIENT R3 abs3 rep3 ⇒
               ∀f1 f2 g1 g2.
                 (R2 ===&gt; R3) f1 f2 ∧ (R1 ===&gt; R2) g1 g2 ⇒
                 (R1 ===&gt; R3) (f1 o g1) (f2 o g2)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/quotient/src/quotientScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-7</a></em></p></body></html>
