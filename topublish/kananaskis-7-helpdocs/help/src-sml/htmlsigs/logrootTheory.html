<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure logrootTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure logrootTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/num/extra_theories/logrootScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature logrootTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val LOG : thm
<a name="line7"></a>    val ROOT : thm
<a name="line8"></a>    val SQRTd_def : thm
<a name="line9"></a>    val iSQRT0_def : thm
<a name="line10"></a>    val iSQRT1_def : thm
<a name="line11"></a>    val iSQRT2_def : thm
<a name="line12"></a>    val iSQRT3_def : thm
<a name="line13"></a>    val iSQRTd_def : thm
<a name="line14"></a>  
<a name="line15"></a>  (*  Theorems  *)
<a name="line16"></a>    val EXP_LE_ISO : thm
<a name="line17"></a>    val EXP_LT_ISO : thm
<a name="line18"></a>    val EXP_MUL : thm
<a name="line19"></a>    val LE_EXP_ISO : thm
<a name="line20"></a>    val LOG_1 : thm
<a name="line21"></a>    val LOG_ADD : thm
<a name="line22"></a>    val LOG_ADD1 : thm
<a name="line23"></a>    val LOG_BASE : thm
<a name="line24"></a>    val LOG_DIV : thm
<a name="line25"></a>    val LOG_EXP : thm
<a name="line26"></a>    val LOG_LE_MONO : thm
<a name="line27"></a>    val LOG_MOD : thm
<a name="line28"></a>    val LOG_ROOT : thm
<a name="line29"></a>    val LOG_UNIQUE : thm
<a name="line30"></a>    val LOG_exists : thm
<a name="line31"></a>    val LT_EXP_ISO : thm
<a name="line32"></a>    val ROOT_COMPUTE : thm
<a name="line33"></a>    val ROOT_DIV : thm
<a name="line34"></a>    val ROOT_LE_MONO : thm
<a name="line35"></a>    val ROOT_UNIQUE : thm
<a name="line36"></a>    val ROOT_exists : thm
<a name="line37"></a>    val numeral_root2 : thm
<a name="line38"></a>  
<a name="line39"></a>  val logroot_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line40"></a>(*
   [basicSize] Parent theory of "logroot"
   
   [while] Parent theory of "logroot"
   
   [LOG]  Definition
      
      |- ∀a n. 1 &lt; a ∧ 0 &lt; n ⇒ a ** LOG a n ≤ n ∧ n &lt; a ** SUC (LOG a n)
   
   [ROOT]  Definition
      
      |- ∀r n. 0 &lt; r ⇒ ROOT r n ** r ≤ n ∧ n &lt; SUC (ROOT r n) ** r
   
   [SQRTd_def]  Definition
      
      |- ∀n. SQRTd n = (ROOT 2 n,n − ROOT 2 n * ROOT 2 n)
   
   [iSQRT0_def]  Definition
      
      |- ∀n.
           iSQRT0 n =
           (let p = SQRTd n in
            let d = SND p − FST p
            in
              if d = 0 then
                (2 * FST p,4 * SND p)
              else
                (SUC (2 * FST p),4 * d − 1))
   
   [iSQRT1_def]  Definition
      
      |- ∀n.
           iSQRT1 n =
           (let p = SQRTd n in
            let d = SUC (SND p) − FST p
            in
              if d = 0 then
                (2 * FST p,SUC (4 * SND p))
              else
                (SUC (2 * FST p),4 * (d − 1)))
   
   [iSQRT2_def]  Definition
      
      |- ∀n.
           iSQRT2 n =
           (let p = SQRTd n in
            let d = 2 * FST p in
            let c = SUC (2 * SND p) in
            let e = c − d
            in
              if e = 0 then (d,2 * c) else (SUC d,2 * e − 1))
   
   [iSQRT3_def]  Definition
      
      |- ∀n.
           iSQRT3 n =
           (let p = SQRTd n in
            let d = 2 * FST p in
            let c = SUC (2 * SND p) in
            let e = SUC c − d
            in
              if e = 0 then (d,SUC (2 * c)) else (SUC d,2 * (e − 1)))
   
   [iSQRTd_def]  Definition
      
      |- ∀x n.
           iSQRTd (x,n) =
           (let p = SQRTd n in
            let next = 4 * SND p + x in
            let ndiff = 4 * FST p + 1
            in
              if next &lt; ndiff then
                (2 * FST p,next)
              else
                (2 * FST p + 1,next − ndiff))
   
   [EXP_LE_ISO]  Theorem
      
      |- ∀a b r. 0 &lt; r ⇒ (a ≤ b ⇔ a ** r ≤ b ** r)
   
   [EXP_LT_ISO]  Theorem
      
      |- ∀a b r. 0 &lt; r ⇒ (a &lt; b ⇔ a ** r &lt; b ** r)
   
   [EXP_MUL]  Theorem
      
      |- (a ** b) ** c = a ** (b * c)
   
   [LE_EXP_ISO]  Theorem
      
      |- ∀e a b. 1 &lt; e ⇒ (a ≤ b ⇔ e ** a ≤ e ** b)
   
   [LOG_1]  Theorem
      
      |- ∀a. 1 &lt; a ⇒ (LOG a 1 = 0)
   
   [LOG_ADD]  Theorem
      
      |- ∀a b c. 1 &lt; a ∧ b &lt; a ** c ⇒ (LOG a (b + a ** c) = c)
   
   [LOG_ADD1]  Theorem
      
      |- ∀n a b.
           0 &lt; n ∧ 1 &lt; a ∧ 0 &lt; b ⇒
           (LOG a (a ** SUC n * b) = SUC (LOG a (a ** n * b)))
   
   [LOG_BASE]  Theorem
      
      |- ∀a. 1 &lt; a ⇒ (LOG a a = 1)
   
   [LOG_DIV]  Theorem
      
      |- ∀a x. 1 &lt; a ∧ a ≤ x ⇒ (LOG a x = 1 + LOG a (x DIV a))
   
   [LOG_EXP]  Theorem
      
      |- ∀n a b. 1 &lt; a ∧ 0 &lt; b ⇒ (LOG a (a ** n * b) = n + LOG a b)
   
   [LOG_LE_MONO]  Theorem
      
      |- ∀a x y. 1 &lt; a ∧ 0 &lt; x ⇒ x ≤ y ⇒ LOG a x ≤ LOG a y
   
   [LOG_MOD]  Theorem
      
      |- 0 &lt; n ⇒ (n = 2 ** LOG 2 n + n MOD 2 ** LOG 2 n)
   
   [LOG_ROOT]  Theorem
      
      |- 1 &lt; a ∧ 0 &lt; x ∧ 0 &lt; r ⇒ (LOG a (ROOT r x) = LOG a x DIV r)
   
   [LOG_UNIQUE]  Theorem
      
      |- ∀n p. a ** p ≤ n ∧ n &lt; a ** SUC p ⇒ (LOG a n = p)
   
   [LOG_exists]  Theorem
      
      |- ∃f. ∀a n. 1 &lt; a ∧ 0 &lt; n ⇒ a ** f a n ≤ n ∧ n &lt; a ** SUC (f a n)
   
   [LT_EXP_ISO]  Theorem
      
      |- ∀e a b. 1 &lt; e ⇒ (a &lt; b ⇔ e ** a &lt; e ** b)
   
   [ROOT_COMPUTE]  Theorem
      
      |- ∀r n.
           0 &lt; r ⇒
           (ROOT r 0 = 0) ∧
           (ROOT r n =
            (let x = 2 * ROOT r (n DIV 2 ** r)
             in
               if n &lt; SUC x ** r then x else SUC x))
   
   [ROOT_DIV]  Theorem
      
      |- ∀r x y. 0 &lt; r ∧ 0 &lt; y ⇒ (ROOT r x DIV y = ROOT r (x DIV y ** r))
   
   [ROOT_LE_MONO]  Theorem
      
      |- ∀r x y. 0 &lt; r ⇒ x ≤ y ⇒ ROOT r x ≤ ROOT r y
   
   [ROOT_UNIQUE]  Theorem
      
      |- ∀r n p. p ** r ≤ n ∧ n &lt; SUC p ** r ⇒ (ROOT r n = p)
   
   [ROOT_exists]  Theorem
      
      |- ∀r n. 0 &lt; r ⇒ ∃rt. rt ** r ≤ n ∧ n &lt; SUC rt ** r
   
   [numeral_root2]  Theorem
      
      |- ROOT 2 (NUMERAL n) = FST (SQRTd n)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/num/extra_theories/logrootScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-7</a></em></p></body></html>
