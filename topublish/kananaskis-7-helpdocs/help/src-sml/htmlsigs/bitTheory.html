<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure bitTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure bitTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/n-bit/bitScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature bitTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#BITS_def-val">BITS_def</a> : thm
<a name="line7"></a>    val <a href="#BITV_def-val">BITV_def</a> : thm
<a name="line8"></a>    val <a href="#BITWISE_def-val">BITWISE_def</a> : thm
<a name="line9"></a>    val <a href="#BIT_MODIFY_def-val">BIT_MODIFY_def</a> : thm
<a name="line10"></a>    val <a href="#BIT_REVERSE_def-val">BIT_REVERSE_def</a> : thm
<a name="line11"></a>    val <a href="#BIT_def-val">BIT_def</a> : thm
<a name="line12"></a>    val <a href="#BOOLIFY_def-val">BOOLIFY_def</a> : thm
<a name="line13"></a>    val <a href="#DIVMOD_2EXP_def-val">DIVMOD_2EXP_def</a> : thm
<a name="line14"></a>    val <a href="#HEX_primitive_def-val">HEX_primitive_def</a> : thm
<a name="line15"></a>    val <a href="#LOG2_def-val">LOG2_def</a> : thm
<a name="line16"></a>    val <a href="#LOWEST_SET_BIT_def-val">LOWEST_SET_BIT_def</a> : thm
<a name="line17"></a>    val <a href="#LSB_def-val">LSB_def</a> : thm
<a name="line18"></a>    val <a href="#MOD_2EXP_EQ_def-val">MOD_2EXP_EQ_def</a> : thm
<a name="line19"></a>    val <a href="#MOD_2EXP_MAX_def-val">MOD_2EXP_MAX_def</a> : thm
<a name="line20"></a>    val <a href="#SBIT_def-val">SBIT_def</a> : thm
<a name="line21"></a>    val <a href="#SIGN_EXTEND_def-val">SIGN_EXTEND_def</a> : thm
<a name="line22"></a>    val <a href="#SLICE_def-val">SLICE_def</a> : thm
<a name="line23"></a>    val <a href="#TIMES_2EXP_def-val">TIMES_2EXP_def</a> : thm
<a name="line24"></a>    val <a href="#UNHEX_primitive_def-val">UNHEX_primitive_def</a> : thm
<a name="line25"></a>    val <a href="#l2n_def-val">l2n_def</a> : thm
<a name="line26"></a>    val <a href="#n2l_curried_def-val">n2l_curried_def</a> : thm
<a name="line27"></a>    val <a href="#n2l_tupled_primitive_def-val">n2l_tupled_primitive_def</a> : thm
<a name="line28"></a>    val <a href="#n2s_def-val">n2s_def</a> : thm
<a name="line29"></a>    val <a href="#num_from_bin_list_def-val">num_from_bin_list_def</a> : thm
<a name="line30"></a>    val <a href="#num_from_bin_string_def-val">num_from_bin_string_def</a> : thm
<a name="line31"></a>    val <a href="#num_from_dec_list_def-val">num_from_dec_list_def</a> : thm
<a name="line32"></a>    val <a href="#num_from_dec_string_def-val">num_from_dec_string_def</a> : thm
<a name="line33"></a>    val <a href="#num_from_hex_list_def-val">num_from_hex_list_def</a> : thm
<a name="line34"></a>    val <a href="#num_from_hex_string_def-val">num_from_hex_string_def</a> : thm
<a name="line35"></a>    val <a href="#num_from_oct_list_def-val">num_from_oct_list_def</a> : thm
<a name="line36"></a>    val <a href="#num_from_oct_string_def-val">num_from_oct_string_def</a> : thm
<a name="line37"></a>    val <a href="#num_to_bin_list_def-val">num_to_bin_list_def</a> : thm
<a name="line38"></a>    val <a href="#num_to_bin_string_def-val">num_to_bin_string_def</a> : thm
<a name="line39"></a>    val <a href="#num_to_dec_list_def-val">num_to_dec_list_def</a> : thm
<a name="line40"></a>    val <a href="#num_to_dec_string_def-val">num_to_dec_string_def</a> : thm
<a name="line41"></a>    val <a href="#num_to_hex_list_def-val">num_to_hex_list_def</a> : thm
<a name="line42"></a>    val <a href="#num_to_hex_string_def-val">num_to_hex_string_def</a> : thm
<a name="line43"></a>    val <a href="#num_to_oct_list_def-val">num_to_oct_list_def</a> : thm
<a name="line44"></a>    val <a href="#num_to_oct_string_def-val">num_to_oct_string_def</a> : thm
<a name="line45"></a>    val <a href="#s2n_def-val">s2n_def</a> : thm
<a name="line46"></a>  
<a name="line47"></a>  (*  Theorems  *)
<a name="line48"></a>    val <a href="#ADD_BIT0-val">ADD_BIT0</a> : thm
<a name="line49"></a>    val <a href="#ADD_BITS_SUC-val">ADD_BITS_SUC</a> : thm
<a name="line50"></a>    val <a href="#ADD_BIT_SUC-val">ADD_BIT_SUC</a> : thm
<a name="line51"></a>    val <a href="#BITSLT_THM-val">BITSLT_THM</a> : thm
<a name="line52"></a>    val <a href="#BITSLT_THM2-val">BITSLT_THM2</a> : thm
<a name="line53"></a>    val <a href="#BITS_COMP_THM-val">BITS_COMP_THM</a> : thm
<a name="line54"></a>    val <a href="#BITS_COMP_THM2-val">BITS_COMP_THM2</a> : thm
<a name="line55"></a>    val <a href="#BITS_DIV_THM-val">BITS_DIV_THM</a> : thm
<a name="line56"></a>    val <a href="#BITS_LEQ-val">BITS_LEQ</a> : thm
<a name="line57"></a>    val <a href="#BITS_LT_HIGH-val">BITS_LT_HIGH</a> : thm
<a name="line58"></a>    val <a href="#BITS_LT_LOW-val">BITS_LT_LOW</a> : thm
<a name="line59"></a>    val <a href="#BITS_MUL-val">BITS_MUL</a> : thm
<a name="line60"></a>    val <a href="#BITS_SLICE_THM-val">BITS_SLICE_THM</a> : thm
<a name="line61"></a>    val <a href="#BITS_SLICE_THM2-val">BITS_SLICE_THM2</a> : thm
<a name="line62"></a>    val <a href="#BITS_SUC-val">BITS_SUC</a> : thm
<a name="line63"></a>    val <a href="#BITS_SUC_THM-val">BITS_SUC_THM</a> : thm
<a name="line64"></a>    val <a href="#BITS_SUM-val">BITS_SUM</a> : thm
<a name="line65"></a>    val <a href="#BITS_SUM2-val">BITS_SUM2</a> : thm
<a name="line66"></a>    val <a href="#BITS_SUM3-val">BITS_SUM3</a> : thm
<a name="line67"></a>    val <a href="#BITS_THM-val">BITS_THM</a> : thm
<a name="line68"></a>    val <a href="#BITS_THM2-val">BITS_THM2</a> : thm
<a name="line69"></a>    val <a href="#BITS_ZERO-val">BITS_ZERO</a> : thm
<a name="line70"></a>    val <a href="#BITS_ZERO2-val">BITS_ZERO2</a> : thm
<a name="line71"></a>    val <a href="#BITS_ZERO3-val">BITS_ZERO3</a> : thm
<a name="line72"></a>    val <a href="#BITS_ZERO4-val">BITS_ZERO4</a> : thm
<a name="line73"></a>    val <a href="#BITS_ZERO5-val">BITS_ZERO5</a> : thm
<a name="line74"></a>    val <a href="#BITS_ZEROL-val">BITS_ZEROL</a> : thm
<a name="line75"></a>    val <a href="#BITV_THM-val">BITV_THM</a> : thm
<a name="line76"></a>    val <a href="#BITWISE_BITS-val">BITWISE_BITS</a> : thm
<a name="line77"></a>    val <a href="#BITWISE_COR-val">BITWISE_COR</a> : thm
<a name="line78"></a>    val <a href="#BITWISE_EVAL-val">BITWISE_EVAL</a> : thm
<a name="line79"></a>    val <a href="#BITWISE_LT_2EXP-val">BITWISE_LT_2EXP</a> : thm
<a name="line80"></a>    val <a href="#BITWISE_NOT_COR-val">BITWISE_NOT_COR</a> : thm
<a name="line81"></a>    val <a href="#BITWISE_ONE_COMP_LEM-val">BITWISE_ONE_COMP_LEM</a> : thm
<a name="line82"></a>    val <a href="#BITWISE_THM-val">BITWISE_THM</a> : thm
<a name="line83"></a>    val <a href="#BIT_B-val">BIT_B</a> : thm
<a name="line84"></a>    val <a href="#BIT_BITS_THM-val">BIT_BITS_THM</a> : thm
<a name="line85"></a>    val <a href="#BIT_B_NEQ-val">BIT_B_NEQ</a> : thm
<a name="line86"></a>    val <a href="#BIT_COMPLEMENT-val">BIT_COMPLEMENT</a> : thm
<a name="line87"></a>    val <a href="#BIT_COMP_THM3-val">BIT_COMP_THM3</a> : thm
<a name="line88"></a>    val <a href="#BIT_DIV2-val">BIT_DIV2</a> : thm
<a name="line89"></a>    val <a href="#BIT_EXP_SUB1-val">BIT_EXP_SUB1</a> : thm
<a name="line90"></a>    val <a href="#BIT_IMP_GE_TWOEXP-val">BIT_IMP_GE_TWOEXP</a> : thm
<a name="line91"></a>    val <a href="#BIT_LOG2-val">BIT_LOG2</a> : thm
<a name="line92"></a>    val <a href="#BIT_MODIFY_THM-val">BIT_MODIFY_THM</a> : thm
<a name="line93"></a>    val <a href="#BIT_OF_BITS_THM-val">BIT_OF_BITS_THM</a> : thm
<a name="line94"></a>    val <a href="#BIT_OF_BITS_THM2-val">BIT_OF_BITS_THM2</a> : thm
<a name="line95"></a>    val <a href="#BIT_REVERSE_THM-val">BIT_REVERSE_THM</a> : thm
<a name="line96"></a>    val <a href="#BIT_SHIFT_THM-val">BIT_SHIFT_THM</a> : thm
<a name="line97"></a>    val <a href="#BIT_SHIFT_THM2-val">BIT_SHIFT_THM2</a> : thm
<a name="line98"></a>    val <a href="#BIT_SHIFT_THM3-val">BIT_SHIFT_THM3</a> : thm
<a name="line99"></a>    val <a href="#BIT_SHIFT_THM4-val">BIT_SHIFT_THM4</a> : thm
<a name="line100"></a>    val <a href="#BIT_SHIFT_THM5-val">BIT_SHIFT_THM5</a> : thm
<a name="line101"></a>    val <a href="#BIT_SIGN_EXTEND-val">BIT_SIGN_EXTEND</a> : thm
<a name="line102"></a>    val <a href="#BIT_SLICE-val">BIT_SLICE</a> : thm
<a name="line103"></a>    val <a href="#BIT_SLICE_LEM-val">BIT_SLICE_LEM</a> : thm
<a name="line104"></a>    val <a href="#BIT_SLICE_THM-val">BIT_SLICE_THM</a> : thm
<a name="line105"></a>    val <a href="#BIT_SLICE_THM2-val">BIT_SLICE_THM2</a> : thm
<a name="line106"></a>    val <a href="#BIT_SLICE_THM3-val">BIT_SLICE_THM3</a> : thm
<a name="line107"></a>    val <a href="#BIT_SLICE_THM4-val">BIT_SLICE_THM4</a> : thm
<a name="line108"></a>    val <a href="#BIT_ZERO-val">BIT_ZERO</a> : thm
<a name="line109"></a>    val <a href="#BIT_num_from_bin_list-val">BIT_num_from_bin_list</a> : thm
<a name="line110"></a>    val <a href="#BIT_num_from_bin_string-val">BIT_num_from_bin_string</a> : thm
<a name="line111"></a>    val <a href="#DEC_UNDEC-val">DEC_UNDEC</a> : thm
<a name="line112"></a>    val <a href="#DIVMOD_2EXP-val">DIVMOD_2EXP</a> : thm
<a name="line113"></a>    val <a href="#DIV_0_IMP_LT-val">DIV_0_IMP_LT</a> : thm
<a name="line114"></a>    val <a href="#DIV_GT0-val">DIV_GT0</a> : thm
<a name="line115"></a>    val <a href="#DIV_LT-val">DIV_LT</a> : thm
<a name="line116"></a>    val <a href="#DIV_MULT_1-val">DIV_MULT_1</a> : thm
<a name="line117"></a>    val <a href="#DIV_MULT_THM-val">DIV_MULT_THM</a> : thm
<a name="line118"></a>    val <a href="#DIV_MULT_THM2-val">DIV_MULT_THM2</a> : thm
<a name="line119"></a>    val <a href="#DIV_SUB1-val">DIV_SUB1</a> : thm
<a name="line120"></a>    val <a href="#EL_TAKE-val">EL_TAKE</a> : thm
<a name="line121"></a>    val <a href="#EL_n2l-val">EL_n2l</a> : thm
<a name="line122"></a>    val <a href="#EL_num_to_bin_list-val">EL_num_to_bin_list</a> : thm
<a name="line123"></a>    val <a href="#EXISTS_BIT_IN_RANGE-val">EXISTS_BIT_IN_RANGE</a> : thm
<a name="line124"></a>    val <a href="#EXISTS_BIT_LT-val">EXISTS_BIT_LT</a> : thm
<a name="line125"></a>    val <a href="#EXP_SUB_LESS_EQ-val">EXP_SUB_LESS_EQ</a> : thm
<a name="line126"></a>    val <a href="#HEX_UNHEX-val">HEX_UNHEX</a> : thm
<a name="line127"></a>    val <a href="#HEX_def-val">HEX_def</a> : thm
<a name="line128"></a>    val <a href="#HEX_ind-val">HEX_ind</a> : thm
<a name="line129"></a>    val <a href="#LEAST_THM-val">LEAST_THM</a> : thm
<a name="line130"></a>    val <a href="#LENGTH_l2n-val">LENGTH_l2n</a> : thm
<a name="line131"></a>    val <a href="#LENGTH_n2l-val">LENGTH_n2l</a> : thm
<a name="line132"></a>    val <a href="#LESS_EQ_EXP_MULT-val">LESS_EQ_EXP_MULT</a> : thm
<a name="line133"></a>    val <a href="#LESS_MULT_MONO2-val">LESS_MULT_MONO2</a> : thm
<a name="line134"></a>    val <a href="#LOG2_LE_MONO-val">LOG2_LE_MONO</a> : thm
<a name="line135"></a>    val <a href="#LOG2_TWOEXP-val">LOG2_TWOEXP</a> : thm
<a name="line136"></a>    val <a href="#LOG2_UNIQUE-val">LOG2_UNIQUE</a> : thm
<a name="line137"></a>    val <a href="#LOG_RWT-val">LOG_RWT</a> : thm
<a name="line138"></a>    val <a href="#LSB_ODD-val">LSB_ODD</a> : thm
<a name="line139"></a>    val <a href="#LT_TWOEXP-val">LT_TWOEXP</a> : thm
<a name="line140"></a>    val <a href="#MOD_2EXP_LT-val">MOD_2EXP_LT</a> : thm
<a name="line141"></a>    val <a href="#MOD_2EXP_MONO-val">MOD_2EXP_MONO</a> : thm
<a name="line142"></a>    val <a href="#MOD_ADD_1-val">MOD_ADD_1</a> : thm
<a name="line143"></a>    val <a href="#MOD_LEQ-val">MOD_LEQ</a> : thm
<a name="line144"></a>    val <a href="#MOD_PLUS_1-val">MOD_PLUS_1</a> : thm
<a name="line145"></a>    val <a href="#MOD_PLUS_LEFT-val">MOD_PLUS_LEFT</a> : thm
<a name="line146"></a>    val <a href="#MOD_PLUS_RIGHT-val">MOD_PLUS_RIGHT</a> : thm
<a name="line147"></a>    val <a href="#MOD_ZERO_GT-val">MOD_ZERO_GT</a> : thm
<a name="line148"></a>    val <a href="#NOT_BIT-val">NOT_BIT</a> : thm
<a name="line149"></a>    val <a href="#NOT_BITS-val">NOT_BITS</a> : thm
<a name="line150"></a>    val <a href="#NOT_BITS2-val">NOT_BITS2</a> : thm
<a name="line151"></a>    val <a href="#NOT_BIT_GT_BITWISE-val">NOT_BIT_GT_BITWISE</a> : thm
<a name="line152"></a>    val <a href="#NOT_BIT_GT_LOG2-val">NOT_BIT_GT_LOG2</a> : thm
<a name="line153"></a>    val <a href="#NOT_BIT_GT_TWOEXP-val">NOT_BIT_GT_TWOEXP</a> : thm
<a name="line154"></a>    val <a href="#NOT_MOD2_LEM-val">NOT_MOD2_LEM</a> : thm
<a name="line155"></a>    val <a href="#NOT_MOD2_LEM2-val">NOT_MOD2_LEM2</a> : thm
<a name="line156"></a>    val <a href="#NOT_ZERO_ADD1-val">NOT_ZERO_ADD1</a> : thm
<a name="line157"></a>    val <a href="#ODD_MOD2_LEM-val">ODD_MOD2_LEM</a> : thm
<a name="line158"></a>    val <a href="#ONE_LE_TWOEXP-val">ONE_LE_TWOEXP</a> : thm
<a name="line159"></a>    val <a href="#SBIT_DIV-val">SBIT_DIV</a> : thm
<a name="line160"></a>    val <a href="#SBIT_MULT-val">SBIT_MULT</a> : thm
<a name="line161"></a>    val <a href="#SLICELT_THM-val">SLICELT_THM</a> : thm
<a name="line162"></a>    val <a href="#SLICE_COMP_RWT-val">SLICE_COMP_RWT</a> : thm
<a name="line163"></a>    val <a href="#SLICE_COMP_THM-val">SLICE_COMP_THM</a> : thm
<a name="line164"></a>    val <a href="#SLICE_COMP_THM2-val">SLICE_COMP_THM2</a> : thm
<a name="line165"></a>    val <a href="#SLICE_THM-val">SLICE_THM</a> : thm
<a name="line166"></a>    val <a href="#SLICE_ZERO-val">SLICE_ZERO</a> : thm
<a name="line167"></a>    val <a href="#SLICE_ZERO2-val">SLICE_ZERO2</a> : thm
<a name="line168"></a>    val <a href="#SLICE_ZERO_THM-val">SLICE_ZERO_THM</a> : thm
<a name="line169"></a>    val <a href="#SUB_num_to_bin_string-val">SUB_num_to_bin_string</a> : thm
<a name="line170"></a>    val <a href="#SUC_SUB-val">SUC_SUB</a> : thm
<a name="line171"></a>    val <a href="#TRANS_THMS-val">TRANS_THMS</a> : thm
<a name="line172"></a>    val <a href="#TWOEXP_DIVISION-val">TWOEXP_DIVISION</a> : thm
<a name="line173"></a>    val <a href="#TWOEXP_LE_IMP_LE_LOG2-val">TWOEXP_LE_IMP_LE_LOG2</a> : thm
<a name="line174"></a>    val <a href="#TWOEXP_MONO-val">TWOEXP_MONO</a> : thm
<a name="line175"></a>    val <a href="#TWOEXP_MONO2-val">TWOEXP_MONO2</a> : thm
<a name="line176"></a>    val <a href="#TWOEXP_NOT_ZERO-val">TWOEXP_NOT_ZERO</a> : thm
<a name="line177"></a>    val <a href="#UNHEX_HEX-val">UNHEX_HEX</a> : thm
<a name="line178"></a>    val <a href="#UNHEX_def-val">UNHEX_def</a> : thm
<a name="line179"></a>    val <a href="#UNHEX_ind-val">UNHEX_ind</a> : thm
<a name="line180"></a>    val <a href="#ZERO_LT_TWOEXP-val">ZERO_LT_TWOEXP</a> : thm
<a name="line181"></a>    val <a href="#l2n_DIGIT-val">l2n_DIGIT</a> : thm
<a name="line182"></a>    val <a href="#l2n_n2l-val">l2n_n2l</a> : thm
<a name="line183"></a>    val <a href="#n2l_BOUND-val">n2l_BOUND</a> : thm
<a name="line184"></a>    val <a href="#n2l_def-val">n2l_def</a> : thm
<a name="line185"></a>    val <a href="#n2l_ind-val">n2l_ind</a> : thm
<a name="line186"></a>    val <a href="#n2l_l2n-val">n2l_l2n</a> : thm
<a name="line187"></a>    val <a href="#n2s_compute-val">n2s_compute</a> : thm
<a name="line188"></a>    val <a href="#n2s_s2n-val">n2s_s2n</a> : thm
<a name="line189"></a>    val <a href="#num_bin_list-val">num_bin_list</a> : thm
<a name="line190"></a>    val <a href="#num_bin_string-val">num_bin_string</a> : thm
<a name="line191"></a>    val <a href="#num_dec_list-val">num_dec_list</a> : thm
<a name="line192"></a>    val <a href="#num_dec_string-val">num_dec_string</a> : thm
<a name="line193"></a>    val <a href="#num_hex_list-val">num_hex_list</a> : thm
<a name="line194"></a>    val <a href="#num_hex_string-val">num_hex_string</a> : thm
<a name="line195"></a>    val <a href="#num_oct_list-val">num_oct_list</a> : thm
<a name="line196"></a>    val <a href="#num_oct_string-val">num_oct_string</a> : thm
<a name="line197"></a>    val <a href="#s2n_compute-val">s2n_compute</a> : thm
<a name="line198"></a>    val <a href="#s2n_n2s-val">s2n_n2s</a> : thm
<a name="line199"></a>  
<a name="line200"></a>  val bit_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line201"></a>(*
   [logroot] Parent theory of "bit"
   
   [string] Parent theory of "bit"
   
   [<a name="BITS_def-val"><b>BITS_def</b></a>]  Definition
      
      |- ∀h l n. BITS h l n = MOD_2EXP (SUC h − l) (DIV_2EXP l n)
   
   [<a name="BITV_def-val"><b>BITV_def</b></a>]  Definition
      
      |- ∀n b. BITV n b = BITS b b n
   
   [<a name="BITWISE_def-val"><b>BITWISE_def</b></a>]  Definition
      
      |- (∀op x y. BITWISE 0 op x y = 0) ∧
         ∀n op x y.
           BITWISE (SUC n) op x y =
           BITWISE n op x y + SBIT (op (BIT n x) (BIT n y)) n
   
   [<a name="BIT_MODIFY_def-val"><b>BIT_MODIFY_def</b></a>]  Definition
      
      |- (∀f x. BIT_MODIFY 0 f x = 0) ∧
         ∀n f x.
           BIT_MODIFY (SUC n) f x =
           BIT_MODIFY n f x + SBIT (f n (BIT n x)) n
   
   [<a name="BIT_REVERSE_def-val"><b>BIT_REVERSE_def</b></a>]  Definition
      
      |- (∀x. BIT_REVERSE 0 x = 0) ∧
         ∀n x.
           BIT_REVERSE (SUC n) x = BIT_REVERSE n x * 2 + SBIT (BIT n x) 0
   
   [<a name="BIT_def-val"><b>BIT_def</b></a>]  Definition
      
      |- ∀b n. BIT b n ⇔ (BITS b b n = 1)
   
   [<a name="BOOLIFY_def-val"><b>BOOLIFY_def</b></a>]  Definition
      
      |- (∀m a. BOOLIFY 0 m a = a) ∧
         ∀n m a. BOOLIFY (SUC n) m a = BOOLIFY n (DIV2 m) (ODD m::a)
   
   [<a name="DIVMOD_2EXP_def-val"><b>DIVMOD_2EXP_def</b></a>]  Definition
      
      |- ∀x n. DIVMOD_2EXP x n = (n DIV 2 ** x,n MOD 2 ** x)
   
   [<a name="HEX_primitive_def-val"><b>HEX_primitive_def</b></a>]  Definition
      
      |- HEX =
         WFREC (@R. WF R)
           (λHEX a.
              case a of
                 0 -&gt; I #"0"
              || 1 -&gt; I #"1"
              || 2 -&gt; I #"2"
              || 3 -&gt; I #"3"
              || 4 -&gt; I #"4"
              || 5 -&gt; I #"5"
              || 6 -&gt; I #"6"
              || 7 -&gt; I #"7"
              || 8 -&gt; I #"8"
              || 9 -&gt; I #"9"
              || 10 -&gt; I #"A"
              || 11 -&gt; I #"B"
              || 12 -&gt; I #"C"
              || 13 -&gt; I #"D"
              || 14 -&gt; I #"E"
              || 15 -&gt; I #"F"
              || v -&gt; ARB)
   
   [<a name="LOG2_def-val"><b>LOG2_def</b></a>]  Definition
      
      |- LOG2 = LOG 2
   
   [<a name="LOWEST_SET_BIT_def-val"><b>LOWEST_SET_BIT_def</b></a>]  Definition
      
      |- ∀n. LOWEST_SET_BIT n = LEAST i. BIT i n
   
   [<a name="LSB_def-val"><b>LSB_def</b></a>]  Definition
      
      |- LSB = BIT 0
   
   [<a name="MOD_2EXP_EQ_def-val"><b>MOD_2EXP_EQ_def</b></a>]  Definition
      
      |- ∀n a b. MOD_2EXP_EQ n a b ⇔ (MOD_2EXP n a = MOD_2EXP n b)
   
   [<a name="MOD_2EXP_MAX_def-val"><b>MOD_2EXP_MAX_def</b></a>]  Definition
      
      |- ∀n a. MOD_2EXP_MAX n a ⇔ (MOD_2EXP n a = 2 ** n − 1)
   
   [<a name="SBIT_def-val"><b>SBIT_def</b></a>]  Definition
      
      |- ∀b n. SBIT b n = if b then 2 ** n else 0
   
   [<a name="SIGN_EXTEND_def-val"><b>SIGN_EXTEND_def</b></a>]  Definition
      
      |- ∀l h n.
           SIGN_EXTEND l h n =
           (let m = n MOD 2 ** l
            in
              if BIT (l − 1) n then 2 ** h − 2 ** l + m else m)
   
   [<a name="SLICE_def-val"><b>SLICE_def</b></a>]  Definition
      
      |- ∀h l n. SLICE h l n = MOD_2EXP (SUC h) n − MOD_2EXP l n
   
   [<a name="TIMES_2EXP_def-val"><b>TIMES_2EXP_def</b></a>]  Definition
      
      |- ∀x n. TIMES_2EXP x n = n * 2 ** x
   
   [<a name="UNHEX_primitive_def-val"><b>UNHEX_primitive_def</b></a>]  Definition
      
      |- UNHEX =
         WFREC (@R. WF R)
           (λUNHEX a.
              case a of
                 #"0" -&gt; I 0
              || #"1" -&gt; I 1
              || #"2" -&gt; I 2
              || #"3" -&gt; I 3
              || #"4" -&gt; I 4
              || #"5" -&gt; I 5
              || #"6" -&gt; I 6
              || #"7" -&gt; I 7
              || #"8" -&gt; I 8
              || #"9" -&gt; I 9
              || #"a" -&gt; I 10
              || #"b" -&gt; I 11
              || #"c" -&gt; I 12
              || #"d" -&gt; I 13
              || #"e" -&gt; I 14
              || #"f" -&gt; I 15
              || #"A" -&gt; I 10
              || #"B" -&gt; I 11
              || #"C" -&gt; I 12
              || #"D" -&gt; I 13
              || #"E" -&gt; I 14
              || #"F" -&gt; I 15
              || v -&gt; ARB)
   
   [<a name="l2n_def-val"><b>l2n_def</b></a>]  Definition
      
      |- (∀b. l2n b [] = 0) ∧ ∀b h t. l2n b (h::t) = h MOD b + b * l2n b t
   
   [<a name="n2l_curried_def-val"><b>n2l_curried_def</b></a>]  Definition
      
      |- ∀x x1. n2l x x1 = n2l_tupled (x,x1)
   
   [<a name="n2l_tupled_primitive_def-val"><b>n2l_tupled_primitive_def</b></a>]  Definition
      
      |- n2l_tupled =
         WFREC (@R. WF R ∧ ∀b n. ¬(n &lt; b ∨ b &lt; 2) ⇒ R (b,n DIV b) (b,n))
           (λn2l_tupled a.
              case a of
                 (b,n) -&gt;
                   I
                     (if n &lt; b ∨ b &lt; 2 then
                        [n MOD b]
                      else
                        n MOD b::n2l_tupled (b,n DIV b)))
   
   [<a name="n2s_def-val"><b>n2s_def</b></a>]  Definition
      
      |- ∀b f n. n2s b f n = REVERSE (MAP f (n2l b n))
   
   [<a name="num_from_bin_list_def-val"><b>num_from_bin_list_def</b></a>]  Definition
      
      |- num_from_bin_list = l2n 2
   
   [<a name="num_from_bin_string_def-val"><b>num_from_bin_string_def</b></a>]  Definition
      
      |- num_from_bin_string = s2n 2 UNHEX
   
   [<a name="num_from_dec_list_def-val"><b>num_from_dec_list_def</b></a>]  Definition
      
      |- num_from_dec_list = l2n 10
   
   [<a name="num_from_dec_string_def-val"><b>num_from_dec_string_def</b></a>]  Definition
      
      |- num_from_dec_string = s2n 10 UNHEX
   
   [<a name="num_from_hex_list_def-val"><b>num_from_hex_list_def</b></a>]  Definition
      
      |- num_from_hex_list = l2n 16
   
   [<a name="num_from_hex_string_def-val"><b>num_from_hex_string_def</b></a>]  Definition
      
      |- num_from_hex_string = s2n 16 UNHEX
   
   [<a name="num_from_oct_list_def-val"><b>num_from_oct_list_def</b></a>]  Definition
      
      |- num_from_oct_list = l2n 8
   
   [<a name="num_from_oct_string_def-val"><b>num_from_oct_string_def</b></a>]  Definition
      
      |- num_from_oct_string = s2n 8 UNHEX
   
   [<a name="num_to_bin_list_def-val"><b>num_to_bin_list_def</b></a>]  Definition
      
      |- num_to_bin_list = n2l 2
   
   [<a name="num_to_bin_string_def-val"><b>num_to_bin_string_def</b></a>]  Definition
      
      |- num_to_bin_string = n2s 2 HEX
   
   [<a name="num_to_dec_list_def-val"><b>num_to_dec_list_def</b></a>]  Definition
      
      |- num_to_dec_list = n2l 10
   
   [<a name="num_to_dec_string_def-val"><b>num_to_dec_string_def</b></a>]  Definition
      
      |- num_to_dec_string = n2s 10 HEX
   
   [<a name="num_to_hex_list_def-val"><b>num_to_hex_list_def</b></a>]  Definition
      
      |- num_to_hex_list = n2l 16
   
   [<a name="num_to_hex_string_def-val"><b>num_to_hex_string_def</b></a>]  Definition
      
      |- num_to_hex_string = n2s 16 HEX
   
   [<a name="num_to_oct_list_def-val"><b>num_to_oct_list_def</b></a>]  Definition
      
      |- num_to_oct_list = n2l 8
   
   [<a name="num_to_oct_string_def-val"><b>num_to_oct_string_def</b></a>]  Definition
      
      |- num_to_oct_string = n2s 8 HEX
   
   [<a name="s2n_def-val"><b>s2n_def</b></a>]  Definition
      
      |- ∀b f s. s2n b f s = l2n b (MAP f (REVERSE s))
   
   [<a name="ADD_BIT0-val"><b>ADD_BIT0</b></a>]  Theorem
      
      |- ∀m n. BIT 0 (m + n) ⇔ (BIT 0 m ⇎ BIT 0 n)
   
   [<a name="ADD_BITS_SUC-val"><b>ADD_BITS_SUC</b></a>]  Theorem
      
      |- ∀n a b.
           BITS (SUC n) (SUC n) (a + b) =
           (BITS (SUC n) (SUC n) a + BITS (SUC n) (SUC n) b +
            BITS (SUC n) (SUC n) (BITS n 0 a + BITS n 0 b)) MOD 2
   
   [<a name="ADD_BIT_SUC-val"><b>ADD_BIT_SUC</b></a>]  Theorem
      
      |- ∀n a b.
           BIT (SUC n) (a + b) ⇔
           if BIT (SUC n) (BITS n 0 a + BITS n 0 b) then
             BIT (SUC n) a ⇔ BIT (SUC n) b
           else
             BIT (SUC n) a ⇎ BIT (SUC n) b
   
   [<a name="BITSLT_THM-val"><b>BITSLT_THM</b></a>]  Theorem
      
      |- ∀h l n. BITS h l n &lt; 2 ** (SUC h − l)
   
   [<a name="BITSLT_THM2-val"><b>BITSLT_THM2</b></a>]  Theorem
      
      |- ∀h l n. BITS h l n &lt; 2 ** SUC h
   
   [<a name="BITS_COMP_THM-val"><b>BITS_COMP_THM</b></a>]  Theorem
      
      |- ∀h1 l1 h2 l2 n.
           h2 + l1 ≤ h1 ⇒
           (BITS h2 l2 (BITS h1 l1 n) = BITS (h2 + l1) (l2 + l1) n)
   
   [<a name="BITS_COMP_THM2-val"><b>BITS_COMP_THM2</b></a>]  Theorem
      
      |- ∀h1 l1 h2 l2 n.
           BITS h2 l2 (BITS h1 l1 n) = BITS (MIN h1 (h2 + l1)) (l2 + l1) n
   
   [<a name="BITS_DIV_THM-val"><b>BITS_DIV_THM</b></a>]  Theorem
      
      |- ∀h l x n. BITS h l x DIV 2 ** n = BITS h (l + n) x
   
   [<a name="BITS_LEQ-val"><b>BITS_LEQ</b></a>]  Theorem
      
      |- ∀h l n. BITS h l n ≤ n
   
   [<a name="BITS_LT_HIGH-val"><b>BITS_LT_HIGH</b></a>]  Theorem
      
      |- ∀h l n. n &lt; 2 ** SUC h ⇒ (BITS h l n = n DIV 2 ** l)
   
   [<a name="BITS_LT_LOW-val"><b>BITS_LT_LOW</b></a>]  Theorem
      
      |- ∀h l n. n &lt; 2 ** l ⇒ (BITS h l n = 0)
   
   [<a name="BITS_MUL-val"><b>BITS_MUL</b></a>]  Theorem
      
      |- ∀h a b. BITS h 0 (BITS h 0 a * BITS h 0 b) = BITS h 0 (a * b)
   
   [<a name="BITS_SLICE_THM-val"><b>BITS_SLICE_THM</b></a>]  Theorem
      
      |- ∀h l n. BITS h l (SLICE h l n) = BITS h l n
   
   [<a name="BITS_SLICE_THM2-val"><b>BITS_SLICE_THM2</b></a>]  Theorem
      
      |- ∀h h2 l n. h ≤ h2 ⇒ (BITS h2 l (SLICE h l n) = BITS h l n)
   
   [<a name="BITS_SUC-val"><b>BITS_SUC</b></a>]  Theorem
      
      |- ∀h l n.
           l ≤ SUC h ⇒
           (SBIT (BIT (SUC h) n) (SUC h − l) + BITS h l n =
            BITS (SUC h) l n)
   
   [<a name="BITS_SUC_THM-val"><b>BITS_SUC_THM</b></a>]  Theorem
      
      |- ∀h l n.
           BITS (SUC h) l n =
           if SUC h &lt; l then
             0
           else
             SBIT (BIT (SUC h) n) (SUC h − l) + BITS h l n
   
   [<a name="BITS_SUM-val"><b>BITS_SUM</b></a>]  Theorem
      
      |- ∀h l a b.
           b &lt; 2 ** l ⇒ (BITS h l (a * 2 ** l + b) = BITS h l (a * 2 ** l))
   
   [<a name="BITS_SUM2-val"><b>BITS_SUM2</b></a>]  Theorem
      
      |- ∀h l a b. BITS h l (a * 2 ** SUC h + b) = BITS h l b
   
   [<a name="BITS_SUM3-val"><b>BITS_SUM3</b></a>]  Theorem
      
      |- ∀h a b. BITS h 0 (BITS h 0 a + BITS h 0 b) = BITS h 0 (a + b)
   
   [<a name="BITS_THM-val"><b>BITS_THM</b></a>]  Theorem
      
      |- ∀h l n. BITS h l n = (n DIV 2 ** l) MOD 2 ** (SUC h − l)
   
   [<a name="BITS_THM2-val"><b>BITS_THM2</b></a>]  Theorem
      
      |- ∀h l n. BITS h l n = n MOD 2 ** SUC h DIV 2 ** l
   
   [<a name="BITS_ZERO-val"><b>BITS_ZERO</b></a>]  Theorem
      
      |- ∀h l n. h &lt; l ⇒ (BITS h l n = 0)
   
   [<a name="BITS_ZERO2-val"><b>BITS_ZERO2</b></a>]  Theorem
      
      |- ∀h l. BITS h l 0 = 0
   
   [<a name="BITS_ZERO3-val"><b>BITS_ZERO3</b></a>]  Theorem
      
      |- ∀h n. BITS h 0 n = n MOD 2 ** SUC h
   
   [<a name="BITS_ZERO4-val"><b>BITS_ZERO4</b></a>]  Theorem
      
      |- ∀h l a. l ≤ h ⇒ (BITS h l (a * 2 ** l) = BITS (h − l) 0 a)
   
   [<a name="BITS_ZERO5-val"><b>BITS_ZERO5</b></a>]  Theorem
      
      |- ∀n m. (∀i. i ≤ n ⇒ ¬BIT i m) ⇒ (BITS n 0 m = 0)
   
   [<a name="BITS_ZEROL-val"><b>BITS_ZEROL</b></a>]  Theorem
      
      |- ∀h a. a &lt; 2 ** SUC h ⇒ (BITS h 0 a = a)
   
   [<a name="BITV_THM-val"><b>BITV_THM</b></a>]  Theorem
      
      |- ∀b n. BITV n b = SBIT (BIT b n) 0
   
   [<a name="BITWISE_BITS-val"><b>BITWISE_BITS</b></a>]  Theorem
      
      |- ∀wl op a b.
           BITWISE (SUC wl) op (BITS wl 0 a) (BITS wl 0 b) =
           BITWISE (SUC wl) op a b
   
   [<a name="BITWISE_COR-val"><b>BITWISE_COR</b></a>]  Theorem
      
      |- ∀x n op a b.
           x &lt; n ⇒
           op (BIT x a) (BIT x b) ⇒
           ((BITWISE n op a b DIV 2 ** x) MOD 2 = 1)
   
   [<a name="BITWISE_EVAL-val"><b>BITWISE_EVAL</b></a>]  Theorem
      
      |- ∀n op a b.
           BITWISE (SUC n) op a b =
           2 * BITWISE n op (a DIV 2) (b DIV 2) +
           SBIT (op (LSB a) (LSB b)) 0
   
   [<a name="BITWISE_LT_2EXP-val"><b>BITWISE_LT_2EXP</b></a>]  Theorem
      
      |- ∀n op a b. BITWISE n op a b &lt; 2 ** n
   
   [<a name="BITWISE_NOT_COR-val"><b>BITWISE_NOT_COR</b></a>]  Theorem
      
      |- ∀x n op a b.
           x &lt; n ⇒
           ¬op (BIT x a) (BIT x b) ⇒
           ((BITWISE n op a b DIV 2 ** x) MOD 2 = 0)
   
   [<a name="BITWISE_ONE_COMP_LEM-val"><b>BITWISE_ONE_COMP_LEM</b></a>]  Theorem
      
      |- ∀n a b.
           BITWISE (SUC n) (λx y. ¬x) a b = 2 ** SUC n − 1 − BITS n 0 a
   
   [<a name="BITWISE_THM-val"><b>BITWISE_THM</b></a>]  Theorem
      
      |- ∀x n op a b.
           x &lt; n ⇒ (BIT x (BITWISE n op a b) ⇔ op (BIT x a) (BIT x b))
   
   [<a name="BIT_B-val"><b>BIT_B</b></a>]  Theorem
      
      |- ∀b. BIT b (2 ** b)
   
   [<a name="BIT_BITS_THM-val"><b>BIT_BITS_THM</b></a>]  Theorem
      
      |- ∀h l a b.
           (∀x. l ≤ x ∧ x ≤ h ⇒ (BIT x a ⇔ BIT x b)) ⇔
           (BITS h l a = BITS h l b)
   
   [<a name="BIT_B_NEQ-val"><b>BIT_B_NEQ</b></a>]  Theorem
      
      |- ∀a b. a ≠ b ⇒ ¬BIT a (2 ** b)
   
   [<a name="BIT_COMPLEMENT-val"><b>BIT_COMPLEMENT</b></a>]  Theorem
      
      |- ∀n i a.
           BIT i (2 ** n − a MOD 2 ** n) ⇔
           (a MOD 2 ** n = 0) ∧ (i = n) ∨
           a MOD 2 ** n ≠ 0 ∧ i &lt; n ∧ ¬BIT i (a MOD 2 ** n − 1)
   
   [<a name="BIT_COMP_THM3-val"><b>BIT_COMP_THM3</b></a>]  Theorem
      
      |- ∀h m l n.
           SUC m ≤ h ∧ l ≤ m ⇒
           (BITS h (SUC m) n * 2 ** (SUC m − l) + BITS m l n = BITS h l n)
   
   [<a name="BIT_DIV2-val"><b>BIT_DIV2</b></a>]  Theorem
      
      |- ∀n i. BIT n (i DIV 2) ⇔ BIT (SUC n) i
   
   [<a name="BIT_EXP_SUB1-val"><b>BIT_EXP_SUB1</b></a>]  Theorem
      
      |- ∀b n. BIT b (2 ** n − 1) ⇔ b &lt; n
   
   [<a name="BIT_IMP_GE_TWOEXP-val"><b>BIT_IMP_GE_TWOEXP</b></a>]  Theorem
      
      |- ∀i n. BIT i n ⇒ 2 ** i ≤ n
   
   [<a name="BIT_LOG2-val"><b>BIT_LOG2</b></a>]  Theorem
      
      |- ∀n. n ≠ 0 ⇒ BIT (LOG2 n) n
   
   [<a name="BIT_MODIFY_THM-val"><b>BIT_MODIFY_THM</b></a>]  Theorem
      
      |- ∀x n f a. x &lt; n ⇒ (BIT x (BIT_MODIFY n f a) ⇔ f x (BIT x a))
   
   [<a name="BIT_OF_BITS_THM-val"><b>BIT_OF_BITS_THM</b></a>]  Theorem
      
      |- ∀n h l a. l + n ≤ h ⇒ (BIT n (BITS h l a) ⇔ BIT (l + n) a)
   
   [<a name="BIT_OF_BITS_THM2-val"><b>BIT_OF_BITS_THM2</b></a>]  Theorem
      
      |- ∀h l x n. h &lt; l + x ⇒ ¬BIT x (BITS h l n)
   
   [<a name="BIT_REVERSE_THM-val"><b>BIT_REVERSE_THM</b></a>]  Theorem
      
      |- ∀x n a. x &lt; n ⇒ (BIT x (BIT_REVERSE n a) ⇔ BIT (n − 1 − x) a)
   
   [<a name="BIT_SHIFT_THM-val"><b>BIT_SHIFT_THM</b></a>]  Theorem
      
      |- ∀n a s. BIT (n + s) (a * 2 ** s) ⇔ BIT n a
   
   [<a name="BIT_SHIFT_THM2-val"><b>BIT_SHIFT_THM2</b></a>]  Theorem
      
      |- ∀n a s. s ≤ n ⇒ (BIT n (a * 2 ** s) ⇔ BIT (n − s) a)
   
   [<a name="BIT_SHIFT_THM3-val"><b>BIT_SHIFT_THM3</b></a>]  Theorem
      
      |- ∀n a s. n &lt; s ⇒ ¬BIT n (a * 2 ** s)
   
   [<a name="BIT_SHIFT_THM4-val"><b>BIT_SHIFT_THM4</b></a>]  Theorem
      
      |- ∀n i a. BIT i (a DIV 2 ** n) ⇔ BIT (i + n) a
   
   [<a name="BIT_SHIFT_THM5-val"><b>BIT_SHIFT_THM5</b></a>]  Theorem
      
      |- ∀n m i a.
           i + n &lt; m ∧ a &lt; 2 ** m ⇒
           (BIT i
              (2 ** m −
               (a DIV 2 ** n + if a MOD 2 ** n = 0 then 0 else 1) MOD
               2 ** m) ⇔ BIT (i + n) (2 ** m − a MOD 2 ** m))
   
   [<a name="BIT_SIGN_EXTEND-val"><b>BIT_SIGN_EXTEND</b></a>]  Theorem
      
      |- ∀l h n i.
           l ≠ 0 ⇒
           (BIT i (SIGN_EXTEND l h n) ⇔
            if l ≤ h ⇒ i &lt; l then
              BIT i (n MOD 2 ** l)
            else
              i &lt; h ∧ BIT (l − 1) n)
   
   [<a name="BIT_SLICE-val"><b>BIT_SLICE</b></a>]  Theorem
      
      |- ∀n a b. (BIT n a ⇔ BIT n b) ⇔ (SLICE n n a = SLICE n n b)
   
   [<a name="BIT_SLICE_LEM-val"><b>BIT_SLICE_LEM</b></a>]  Theorem
      
      |- ∀y x n. SBIT (BIT x n) (x + y) = SLICE x x n * 2 ** y
   
   [<a name="BIT_SLICE_THM-val"><b>BIT_SLICE_THM</b></a>]  Theorem
      
      |- ∀x n. SBIT (BIT x n) x = SLICE x x n
   
   [<a name="BIT_SLICE_THM2-val"><b>BIT_SLICE_THM2</b></a>]  Theorem
      
      |- ∀b n. BIT b n ⇔ (SLICE b b n = 2 ** b)
   
   [<a name="BIT_SLICE_THM3-val"><b>BIT_SLICE_THM3</b></a>]  Theorem
      
      |- ∀b n. ¬BIT b n ⇔ (SLICE b b n = 0)
   
   [<a name="BIT_SLICE_THM4-val"><b>BIT_SLICE_THM4</b></a>]  Theorem
      
      |- ∀b h l n. BIT b (SLICE h l n) ⇔ l ≤ b ∧ b ≤ h ∧ BIT b n
   
   [<a name="BIT_ZERO-val"><b>BIT_ZERO</b></a>]  Theorem
      
      |- ∀b. ¬BIT b 0
   
   [<a name="BIT_num_from_bin_list-val"><b>BIT_num_from_bin_list</b></a>]  Theorem
      
      |- ∀x l.
           EVERY ($&gt; 2) l ∧ x &lt; LENGTH l ⇒
           (BIT x (num_from_bin_list l) ⇔ (EL x l = 1))
   
   [<a name="BIT_num_from_bin_string-val"><b>BIT_num_from_bin_string</b></a>]  Theorem
      
      |- ∀x s.
           EVERY ($&gt; 2 o UNHEX) s ∧ x &lt; STRLEN s ⇒
           (BIT x (num_from_bin_string s) ⇔
            (UNHEX (SUB (s,PRE (STRLEN s − x))) = 1))
   
   [<a name="DEC_UNDEC-val"><b>DEC_UNDEC</b></a>]  Theorem
      
      |- ∀c. isDigit c ⇒ (HEX (UNHEX c) = c)
   
   [<a name="DIVMOD_2EXP-val"><b>DIVMOD_2EXP</b></a>]  Theorem
      
      |- ∀x n. DIVMOD_2EXP x n = (DIV_2EXP x n,MOD_2EXP x n)
   
   [<a name="DIV_0_IMP_LT-val"><b>DIV_0_IMP_LT</b></a>]  Theorem
      
      |- ∀b n. 1 &lt; b ∧ (n DIV b = 0) ⇒ n &lt; b
   
   [<a name="DIV_GT0-val"><b>DIV_GT0</b></a>]  Theorem
      
      |- ∀a b. b ≤ a ∧ 0 &lt; b ⇒ 0 &lt; a DIV b
   
   [<a name="DIV_LT-val"><b>DIV_LT</b></a>]  Theorem
      
      |- ∀n m a. n &lt; m ∧ a &lt; 2 ** m ⇒ a DIV 2 ** n &lt; 2 ** m
   
   [<a name="DIV_MULT_1-val"><b>DIV_MULT_1</b></a>]  Theorem
      
      |- ∀r n. r &lt; n ⇒ ((n + r) DIV n = 1)
   
   [<a name="DIV_MULT_THM-val"><b>DIV_MULT_THM</b></a>]  Theorem
      
      |- ∀x n. n DIV 2 ** x * 2 ** x = n − n MOD 2 ** x
   
   [<a name="DIV_MULT_THM2-val"><b>DIV_MULT_THM2</b></a>]  Theorem
      
      |- ∀n. 2 * (n DIV 2) = n − n MOD 2
   
   [<a name="DIV_SUB1-val"><b>DIV_SUB1</b></a>]  Theorem
      
      |- ∀a b.
           2 ** b ≤ a ∧ (a MOD 2 ** b = 0) ⇒
           (a DIV 2 ** b − 1 = (a − 1) DIV 2 ** b)
   
   [<a name="EL_TAKE-val"><b>EL_TAKE</b></a>]  Theorem
      
      |- ∀x n l. x &lt; n ∧ n ≤ LENGTH l ⇒ (EL x (TAKE n l) = EL x l)
   
   [<a name="EL_n2l-val"><b>EL_n2l</b></a>]  Theorem
      
      |- ∀b x n.
           1 &lt; b ∧ x &lt; LENGTH (n2l b n) ⇒
           (EL x (n2l b n) = (n DIV b ** x) MOD b)
   
   [<a name="EL_num_to_bin_list-val"><b>EL_num_to_bin_list</b></a>]  Theorem
      
      |- ∀x n.
           x &lt; LENGTH (num_to_bin_list n) ⇒
           (EL x (num_to_bin_list n) = BITV n x)
   
   [<a name="EXISTS_BIT_IN_RANGE-val"><b>EXISTS_BIT_IN_RANGE</b></a>]  Theorem
      
      |- ∀a b n.
           n ≠ 0 ∧ 2 ** a ≤ n ∧ n &lt; 2 ** b ⇒ ∃i. a ≤ i ∧ i &lt; b ∧ BIT i n
   
   [<a name="EXISTS_BIT_LT-val"><b>EXISTS_BIT_LT</b></a>]  Theorem
      
      |- ∀b n. n ≠ 0 ∧ n &lt; 2 ** b ⇒ ∃i. i &lt; b ∧ BIT i n
   
   [<a name="EXP_SUB_LESS_EQ-val"><b>EXP_SUB_LESS_EQ</b></a>]  Theorem
      
      |- ∀a b. 2 ** (a − b) ≤ 2 ** a
   
   [<a name="HEX_UNHEX-val"><b>HEX_UNHEX</b></a>]  Theorem
      
      |- ∀c. isHexDigit c ⇒ (HEX (UNHEX c) = toUpper c)
   
   [<a name="HEX_def-val"><b>HEX_def</b></a>]  Theorem
      
      |- (HEX 0 = #"0") ∧ (HEX 1 = #"1") ∧ (HEX 2 = #"2") ∧
         (HEX 3 = #"3") ∧ (HEX 4 = #"4") ∧ (HEX 5 = #"5") ∧
         (HEX 6 = #"6") ∧ (HEX 7 = #"7") ∧ (HEX 8 = #"8") ∧
         (HEX 9 = #"9") ∧ (HEX 10 = #"A") ∧ (HEX 11 = #"B") ∧
         (HEX 12 = #"C") ∧ (HEX 13 = #"D") ∧ (HEX 14 = #"E") ∧
         (HEX 15 = #"F")
   
   [<a name="HEX_ind-val"><b>HEX_ind</b></a>]  Theorem
      
      |- ∀P.
           P 0 ∧ P 1 ∧ P 2 ∧ P 3 ∧ P 4 ∧ P 5 ∧ P 6 ∧ P 7 ∧ P 8 ∧ P 9 ∧
           P 10 ∧ P 11 ∧ P 12 ∧ P 13 ∧ P 14 ∧ P 15 ∧ (∀v18. P v18) ⇒
           ∀v. P v
   
   [<a name="LEAST_THM-val"><b>LEAST_THM</b></a>]  Theorem
      
      |- ∀n P. (∀m. m &lt; n ⇒ ¬P m) ∧ P n ⇒ ($LEAST P = n)
   
   [<a name="LENGTH_l2n-val"><b>LENGTH_l2n</b></a>]  Theorem
      
      |- ∀b l.
           1 &lt; b ∧ EVERY ($&gt; b) l ∧ l2n b l ≠ 0 ⇒
           SUC (LOG b (l2n b l)) ≤ LENGTH l
   
   [<a name="LENGTH_n2l-val"><b>LENGTH_n2l</b></a>]  Theorem
      
      |- ∀b n.
           1 &lt; b ⇒ (LENGTH (n2l b n) = if n = 0 then 1 else SUC (LOG b n))
   
   [<a name="LESS_EQ_EXP_MULT-val"><b>LESS_EQ_EXP_MULT</b></a>]  Theorem
      
      |- ∀a b. a ≤ b ⇒ ∃p. 2 ** b = p * 2 ** a
   
   [<a name="LESS_MULT_MONO2-val"><b>LESS_MULT_MONO2</b></a>]  Theorem
      
      |- ∀a b x y. a &lt; x ∧ b &lt; y ⇒ a * b &lt; x * y
   
   [<a name="LOG2_LE_MONO-val"><b>LOG2_LE_MONO</b></a>]  Theorem
      
      |- ∀x y. 0 &lt; x ⇒ x ≤ y ⇒ LOG2 x ≤ LOG2 y
   
   [<a name="LOG2_TWOEXP-val"><b>LOG2_TWOEXP</b></a>]  Theorem
      
      |- ∀n. LOG2 (2 ** n) = n
   
   [<a name="LOG2_UNIQUE-val"><b>LOG2_UNIQUE</b></a>]  Theorem
      
      |- ∀n p. 2 ** p ≤ n ∧ n &lt; 2 ** SUC p ⇒ (LOG2 n = p)
   
   [<a name="LOG_RWT-val"><b>LOG_RWT</b></a>]  Theorem
      
      |- ∀m n.
           1 &lt; m ∧ 0 &lt; n ⇒
           (LOG m n = if n &lt; m then 0 else SUC (LOG m (n DIV m)))
   
   [<a name="LSB_ODD-val"><b>LSB_ODD</b></a>]  Theorem
      
      |- LSB = ODD
   
   [<a name="LT_TWOEXP-val"><b>LT_TWOEXP</b></a>]  Theorem
      
      |- ∀x n. x &lt; 2 ** n ⇔ (x = 0) ∨ LOG2 x &lt; n
   
   [<a name="MOD_2EXP_LT-val"><b>MOD_2EXP_LT</b></a>]  Theorem
      
      |- ∀n k. k MOD 2 ** n &lt; 2 ** n
   
   [<a name="MOD_2EXP_MONO-val"><b>MOD_2EXP_MONO</b></a>]  Theorem
      
      |- ∀n h l. l ≤ h ⇒ n MOD 2 ** l ≤ n MOD 2 ** SUC h
   
   [<a name="MOD_ADD_1-val"><b>MOD_ADD_1</b></a>]  Theorem
      
      |- ∀n. 0 &lt; n ⇒ ∀x. (x + 1) MOD n ≠ 0 ⇒ ((x + 1) MOD n = x MOD n + 1)
   
   [<a name="MOD_LEQ-val"><b>MOD_LEQ</b></a>]  Theorem
      
      |- ∀a b. 0 &lt; b ⇒ a MOD b ≤ a
   
   [<a name="MOD_PLUS_1-val"><b>MOD_PLUS_1</b></a>]  Theorem
      
      |- ∀n. 0 &lt; n ⇒ ∀x. ((x + 1) MOD n = 0) ⇔ (x MOD n + 1 = n)
   
   [<a name="MOD_PLUS_LEFT-val"><b>MOD_PLUS_LEFT</b></a>]  Theorem
      
      |- ∀n. 0 &lt; n ⇒ ∀j k. (k MOD n + j) MOD n = (k + j) MOD n
   
   [<a name="MOD_PLUS_RIGHT-val"><b>MOD_PLUS_RIGHT</b></a>]  Theorem
      
      |- ∀n. 0 &lt; n ⇒ ∀j k. (j + k MOD n) MOD n = (j + k) MOD n
   
   [<a name="MOD_ZERO_GT-val"><b>MOD_ZERO_GT</b></a>]  Theorem
      
      |- ∀n a. a ≠ 0 ∧ (a MOD 2 ** n = 0) ⇒ 2 ** n ≤ a
   
   [<a name="NOT_BIT-val"><b>NOT_BIT</b></a>]  Theorem
      
      |- ∀n a. ¬BIT n a ⇔ (BITS n n a = 0)
   
   [<a name="NOT_BITS-val"><b>NOT_BITS</b></a>]  Theorem
      
      |- ∀n a. BITS n n a ≠ 0 ⇔ (BITS n n a = 1)
   
   [<a name="NOT_BITS2-val"><b>NOT_BITS2</b></a>]  Theorem
      
      |- ∀n a. BITS n n a ≠ 1 ⇔ (BITS n n a = 0)
   
   [<a name="NOT_BIT_GT_BITWISE-val"><b>NOT_BIT_GT_BITWISE</b></a>]  Theorem
      
      |- ∀i n op a b. n ≤ i ⇒ ¬BIT i (BITWISE n op a b)
   
   [<a name="NOT_BIT_GT_LOG2-val"><b>NOT_BIT_GT_LOG2</b></a>]  Theorem
      
      |- ∀i n. LOG2 n &lt; i ⇒ ¬BIT i n
   
   [<a name="NOT_BIT_GT_TWOEXP-val"><b>NOT_BIT_GT_TWOEXP</b></a>]  Theorem
      
      |- ∀i n. n &lt; 2 ** i ⇒ ¬BIT i n
   
   [<a name="NOT_MOD2_LEM-val"><b>NOT_MOD2_LEM</b></a>]  Theorem
      
      |- ∀n. n MOD 2 ≠ 0 ⇔ (n MOD 2 = 1)
   
   [<a name="NOT_MOD2_LEM2-val"><b>NOT_MOD2_LEM2</b></a>]  Theorem
      
      |- ∀n. n MOD 2 ≠ 1 ⇔ (n MOD 2 = 0)
   
   [<a name="NOT_ZERO_ADD1-val"><b>NOT_ZERO_ADD1</b></a>]  Theorem
      
      |- ∀m. m ≠ 0 ⇒ ∃p. m = SUC p
   
   [<a name="ODD_MOD2_LEM-val"><b>ODD_MOD2_LEM</b></a>]  Theorem
      
      |- ∀n. ODD n ⇔ (n MOD 2 = 1)
   
   [<a name="ONE_LE_TWOEXP-val"><b>ONE_LE_TWOEXP</b></a>]  Theorem
      
      |- ∀n. 1 ≤ 2 ** n
   
   [<a name="SBIT_DIV-val"><b>SBIT_DIV</b></a>]  Theorem
      
      |- ∀b m n. n &lt; m ⇒ (SBIT b (m − n) = SBIT b m DIV 2 ** n)
   
   [<a name="SBIT_MULT-val"><b>SBIT_MULT</b></a>]  Theorem
      
      |- ∀b m n. SBIT b n * 2 ** m = SBIT b (n + m)
   
   [<a name="SLICELT_THM-val"><b>SLICELT_THM</b></a>]  Theorem
      
      |- ∀h l n. SLICE h l n &lt; 2 ** SUC h
   
   [<a name="SLICE_COMP_RWT-val"><b>SLICE_COMP_RWT</b></a>]  Theorem
      
      |- ∀h m' m l n.
           l ≤ m ∧ (m' = m + 1) ∧ m &lt; h ⇒
           (SLICE h m' n + SLICE m l n = SLICE h l n)
   
   [<a name="SLICE_COMP_THM-val"><b>SLICE_COMP_THM</b></a>]  Theorem
      
      |- ∀h m l n.
           SUC m ≤ h ∧ l ≤ m ⇒
           (SLICE h (SUC m) n + SLICE m l n = SLICE h l n)
   
   [<a name="SLICE_COMP_THM2-val"><b>SLICE_COMP_THM2</b></a>]  Theorem
      
      |- ∀h l x y n.
           h ≤ x ∧ y ≤ l ⇒ (SLICE h l (SLICE x y n) = SLICE h l n)
   
   [<a name="SLICE_THM-val"><b>SLICE_THM</b></a>]  Theorem
      
      |- ∀n h l. SLICE h l n = BITS h l n * 2 ** l
   
   [<a name="SLICE_ZERO-val"><b>SLICE_ZERO</b></a>]  Theorem
      
      |- ∀h l n. h &lt; l ⇒ (SLICE h l n = 0)
   
   [<a name="SLICE_ZERO2-val"><b>SLICE_ZERO2</b></a>]  Theorem
      
      |- ∀l h. SLICE h l 0 = 0
   
   [<a name="SLICE_ZERO_THM-val"><b>SLICE_ZERO_THM</b></a>]  Theorem
      
      |- ∀n h. SLICE h 0 n = BITS h 0 n
   
   [<a name="SUB_num_to_bin_string-val"><b>SUB_num_to_bin_string</b></a>]  Theorem
      
      |- ∀x n.
           x &lt; STRLEN (num_to_bin_string n) ⇒
           (SUB (num_to_bin_string n,x) =
            HEX (BITV n (PRE (STRLEN (num_to_bin_string n) − x))))
   
   [<a name="SUC_SUB-val"><b>SUC_SUB</b></a>]  Theorem
      
      |- SUC a − a = 1
   
   [<a name="TRANS_THMS-val"><b>TRANS_THMS</b></a>]  Theorem
      
      |- (∀m n p. m &lt; n ∧ n &lt; p ⇒ m &lt; p) ∧
         (∀m n p. m ≤ n ∧ n &lt; p ⇒ m &lt; p) ∧
         (∀m n p. m &lt; n ∧ n ≤ p ⇒ m &lt; p) ∧ ∀m n p. m ≤ n ∧ n ≤ p ⇒ m ≤ p
   
   [<a name="TWOEXP_DIVISION-val"><b>TWOEXP_DIVISION</b></a>]  Theorem
      
      |- ∀n k. k = k DIV 2 ** n * 2 ** n + k MOD 2 ** n
   
   [<a name="TWOEXP_LE_IMP_LE_LOG2-val"><b>TWOEXP_LE_IMP_LE_LOG2</b></a>]  Theorem
      
      |- (∀x y. 2 ** x ≤ y ⇒ x ≤ LOG2 y) ∧
         ∀y x. 0 &lt; x ⇒ x ≤ 2 ** y ⇒ LOG2 x ≤ y
   
   [<a name="TWOEXP_MONO-val"><b>TWOEXP_MONO</b></a>]  Theorem
      
      |- ∀a b. a &lt; b ⇒ 2 ** a &lt; 2 ** b
   
   [<a name="TWOEXP_MONO2-val"><b>TWOEXP_MONO2</b></a>]  Theorem
      
      |- ∀a b. a ≤ b ⇒ 2 ** a ≤ 2 ** b
   
   [<a name="TWOEXP_NOT_ZERO-val"><b>TWOEXP_NOT_ZERO</b></a>]  Theorem
      
      |- ∀n. 2 ** n ≠ 0
   
   [<a name="UNHEX_HEX-val"><b>UNHEX_HEX</b></a>]  Theorem
      
      |- ∀n. n &lt; 16 ⇒ (UNHEX (HEX n) = n)
   
   [<a name="UNHEX_def-val"><b>UNHEX_def</b></a>]  Theorem
      
      |- (UNHEX #"0" = 0) ∧ (UNHEX #"1" = 1) ∧ (UNHEX #"2" = 2) ∧
         (UNHEX #"3" = 3) ∧ (UNHEX #"4" = 4) ∧ (UNHEX #"5" = 5) ∧
         (UNHEX #"6" = 6) ∧ (UNHEX #"7" = 7) ∧ (UNHEX #"8" = 8) ∧
         (UNHEX #"9" = 9) ∧ (UNHEX #"a" = 10) ∧ (UNHEX #"b" = 11) ∧
         (UNHEX #"c" = 12) ∧ (UNHEX #"d" = 13) ∧ (UNHEX #"e" = 14) ∧
         (UNHEX #"f" = 15) ∧ (UNHEX #"A" = 10) ∧ (UNHEX #"B" = 11) ∧
         (UNHEX #"C" = 12) ∧ (UNHEX #"D" = 13) ∧ (UNHEX #"E" = 14) ∧
         (UNHEX #"F" = 15)
   
   [<a name="UNHEX_ind-val"><b>UNHEX_ind</b></a>]  Theorem
      
      |- ∀P.
           P #"0" ∧ P #"1" ∧ P #"2" ∧ P #"3" ∧ P #"4" ∧ P #"5" ∧ P #"6" ∧
           P #"7" ∧ P #"8" ∧ P #"9" ∧ P #"a" ∧ P #"b" ∧ P #"c" ∧ P #"d" ∧
           P #"e" ∧ P #"f" ∧ P #"A" ∧ P #"B" ∧ P #"C" ∧ P #"D" ∧ P #"E" ∧
           P #"F" ∧ (∀v24. P v24) ⇒
           ∀v. P v
   
   [<a name="ZERO_LT_TWOEXP-val"><b>ZERO_LT_TWOEXP</b></a>]  Theorem
      
      |- ∀n. 0 &lt; 2 ** n
   
   [<a name="l2n_DIGIT-val"><b>l2n_DIGIT</b></a>]  Theorem
      
      |- ∀b l x.
           1 &lt; b ∧ EVERY ($&gt; b) l ∧ x &lt; LENGTH l ⇒
           ((l2n b l DIV b ** x) MOD b = EL x l)
   
   [<a name="l2n_n2l-val"><b>l2n_n2l</b></a>]  Theorem
      
      |- ∀b n. 1 &lt; b ⇒ (l2n b (n2l b n) = n)
   
   [<a name="n2l_BOUND-val"><b>n2l_BOUND</b></a>]  Theorem
      
      |- ∀b n. 0 &lt; b ⇒ EVERY ($&gt; b) (n2l b n)
   
   [<a name="n2l_def-val"><b>n2l_def</b></a>]  Theorem
      
      |- ∀n b.
           n2l b n =
           if n &lt; b ∨ b &lt; 2 then [n MOD b] else n MOD b::n2l b (n DIV b)
   
   [<a name="n2l_ind-val"><b>n2l_ind</b></a>]  Theorem
      
      |- ∀P.
           (∀b n. (¬(n &lt; b ∨ b &lt; 2) ⇒ P b (n DIV b)) ⇒ P b n) ⇒
           ∀v v1. P v v1
   
   [<a name="n2l_l2n-val"><b>n2l_l2n</b></a>]  Theorem
      
      |- ∀b l.
           1 &lt; b ∧ EVERY ($&gt; b) l ⇒
           (n2l b (l2n b l) =
            if l2n b l = 0 then [0] else TAKE (SUC (LOG b (l2n b l))) l)
   
   [<a name="n2s_compute-val"><b>n2s_compute</b></a>]  Theorem
      
      |- n2s b f n = IMPLODE (REVERSE (MAP f (n2l b n)))
   
   [<a name="n2s_s2n-val"><b>n2s_s2n</b></a>]  Theorem
      
      |- ∀c2n n2c b s.
           1 &lt; b ∧ EVERY ($&gt; b o c2n) s ⇒
           (n2s b n2c (s2n b c2n s) =
            if s2n b c2n s = 0 then
              STRING (n2c 0) ""
            else
              MAP (n2c o c2n) (LASTN (SUC (LOG b (s2n b c2n s))) s))
   
   [<a name="num_bin_list-val"><b>num_bin_list</b></a>]  Theorem
      
      |- num_from_bin_list o num_to_bin_list = I
   
   [<a name="num_bin_string-val"><b>num_bin_string</b></a>]  Theorem
      
      |- num_from_bin_string o num_to_bin_string = I
   
   [<a name="num_dec_list-val"><b>num_dec_list</b></a>]  Theorem
      
      |- num_from_dec_list o num_to_dec_list = I
   
   [<a name="num_dec_string-val"><b>num_dec_string</b></a>]  Theorem
      
      |- num_from_dec_string o num_to_dec_string = I
   
   [<a name="num_hex_list-val"><b>num_hex_list</b></a>]  Theorem
      
      |- num_from_hex_list o num_to_hex_list = I
   
   [<a name="num_hex_string-val"><b>num_hex_string</b></a>]  Theorem
      
      |- num_from_hex_string o num_to_hex_string = I
   
   [<a name="num_oct_list-val"><b>num_oct_list</b></a>]  Theorem
      
      |- num_from_oct_list o num_to_oct_list = I
   
   [<a name="num_oct_string-val"><b>num_oct_string</b></a>]  Theorem
      
      |- num_from_oct_string o num_to_oct_string = I
   
   [<a name="s2n_compute-val"><b>s2n_compute</b></a>]  Theorem
      
      |- s2n b f s = l2n b (MAP f (REVERSE (EXPLODE s)))
   
   [<a name="s2n_n2s-val"><b>s2n_n2s</b></a>]  Theorem
      
      |- ∀c2n n2c b n.
           1 &lt; b ∧ (∀x. x &lt; b ⇒ (c2n (n2c x) = x)) ⇒
           (s2n b c2n (n2s b n2c n) = n)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/n-bit/bitScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-7</a></em></p></body></html>
