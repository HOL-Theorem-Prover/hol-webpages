<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure updateTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure updateTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/update/updateScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature updateTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val FIND_def : thm
<a name="line7"></a>    val LIST_UPDATE_def : thm
<a name="line8"></a>    val OVERRIDE_primitive_def : thm
<a name="line9"></a>  
<a name="line10"></a>  (*  Theorems  *)
<a name="line11"></a>    val APPLY_UPDATE_ID : thm
<a name="line12"></a>    val APPLY_UPDATE_THM : thm
<a name="line13"></a>    val LIST_UPDATE_ALL_DISTINCT : thm
<a name="line14"></a>    val LIST_UPDATE_LOOKUP : thm
<a name="line15"></a>    val LIST_UPDATE_OVERRIDE : thm
<a name="line16"></a>    val LIST_UPDATE_SORT_OVERRIDE : thm
<a name="line17"></a>    val LIST_UPDATE_THMS : thm
<a name="line18"></a>    val OVERRIDE_def : thm
<a name="line19"></a>    val OVERRIDE_ind : thm
<a name="line20"></a>    val SAME_KEY_UPDATE_DIFFER : thm
<a name="line21"></a>    val UPDATE_APPLY_ID : thm
<a name="line22"></a>    val UPDATE_APPLY_IMP_ID : thm
<a name="line23"></a>    val UPDATE_COMMUTES : thm
<a name="line24"></a>    val UPDATE_EQ : thm
<a name="line25"></a>    val UPDATE_def : thm
<a name="line26"></a>  
<a name="line27"></a>  val update_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line28"></a>(*
   [sorting] Parent theory of "update"
   
   [FIND_def]  Definition
      
      |- (∀P. FIND P [] = NONE) ∧
         ∀P h t. FIND P (h::t) = if P h then SOME h else FIND P t
   
   [LIST_UPDATE_def]  Definition
      
      |- (LIST_UPDATE [] = I) ∧
         ∀h t. LIST_UPDATE (h::t) = (FST h =+ SND h) o LIST_UPDATE t
   
   [OVERRIDE_primitive_def]  Definition
      
      |- OVERRIDE =
         WFREC (@R. WF R ∧ ∀t x. R (FILTER (λy. FST x ≠ FST y) t) (x::t))
           (λOVERRIDE a.
              case a of
                 [] -&gt; I []
              || x::t -&gt; I (x::OVERRIDE (FILTER (λy. FST x ≠ FST y) t)))
   
   [APPLY_UPDATE_ID]  Theorem
      
      |- ∀f a. (a =+ f a) f = f
   
   [APPLY_UPDATE_THM]  Theorem
      
      |- ∀f a b c. (a =+ b) f c = if a = c then b else f c
   
   [LIST_UPDATE_ALL_DISTINCT]  Theorem
      
      |- ∀l1 l2.
           ALL_DISTINCT (MAP FST l2) ∧ PERM l1 l2 ⇒
           (LIST_UPDATE l1 = LIST_UPDATE l2)
   
   [LIST_UPDATE_LOOKUP]  Theorem
      
      |- ∀l f i.
           LIST_UPDATE l f i =
           case FIND (λx. FST x = i) l of NONE -&gt; f i || SOME (v1,e) -&gt; e
   
   [LIST_UPDATE_OVERRIDE]  Theorem
      
      |- ∀l. LIST_UPDATE l = LIST_UPDATE (OVERRIDE l)
   
   [LIST_UPDATE_SORT_OVERRIDE]  Theorem
      
      |- ∀R l. LIST_UPDATE l = LIST_UPDATE (QSORT R (OVERRIDE l))
   
   [LIST_UPDATE_THMS]  Theorem
      
      |- ((∀l1 l2 r1 r2.
             (l1 =+ r1) o (l2 =+ r2) = LIST_UPDATE [(l1,r1); (l2,r2)]) ∧
          (∀l r t. (l =+ r) o LIST_UPDATE t = LIST_UPDATE ((l,r)::t)) ∧
          (∀l1 l2 r1 r2 f.
             (l1 =+ r1) ((l2 =+ r2) f) =
             LIST_UPDATE [(l1,r1); (l2,r2)] f) ∧
          ∀l r t f.
            (l =+ r) (LIST_UPDATE t f) = LIST_UPDATE ((l,r)::t) f) ∧
         (∀l1 l2.
            LIST_UPDATE l1 o LIST_UPDATE l2 = LIST_UPDATE (l1 ++ l2)) ∧
         (∀l1 l2 r.
            LIST_UPDATE l1 o (l2 =+ r) = LIST_UPDATE (SNOC (l2,r) l1)) ∧
         (∀l1 l2 f.
            LIST_UPDATE l1 (LIST_UPDATE l2 f) = LIST_UPDATE (l1 ++ l2) f) ∧
         ∀l1 l2 r f.
           LIST_UPDATE l1 ((l2 =+ r) f) = LIST_UPDATE (SNOC (l2,r) l1) f
   
   [OVERRIDE_def]  Theorem
      
      |- (OVERRIDE [] = []) ∧
         (OVERRIDE (x::t) = x::OVERRIDE (FILTER (λy. FST x ≠ FST y) t))
   
   [OVERRIDE_ind]  Theorem
      
      |- ∀P.
           P [] ∧ (∀x t. P (FILTER (λy. FST x ≠ FST y) t) ⇒ P (x::t)) ⇒
           ∀v. P v
   
   [SAME_KEY_UPDATE_DIFFER]  Theorem
      
      |- ∀f1 f2 a b c. b ≠ c ⇒ (a =+ b) f ≠ (a =+ c) f
   
   [UPDATE_APPLY_ID]  Theorem
      
      |- ∀f a b. (f a = b) ⇔ ((a =+ b) f = f)
   
   [UPDATE_APPLY_IMP_ID]  Theorem
      
      |- ∀f b a. (f a = b) ⇒ ((a =+ b) f = f)
   
   [UPDATE_COMMUTES]  Theorem
      
      |- ∀f a b c d.
           a ≠ b ⇒ ((a =+ c) ((b =+ d) f) = (b =+ d) ((a =+ c) f))
   
   [UPDATE_EQ]  Theorem
      
      |- ∀f a b c. (a =+ c) ((a =+ b) f) = (a =+ c) f
   
   [UPDATE_def]  Theorem
      
      |- ∀a b. a =+ b = (λf c. if a = c then b else f c)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/update/updateScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-7</a></em></p></body></html>
