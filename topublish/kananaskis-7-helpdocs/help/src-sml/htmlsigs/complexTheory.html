<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure complexTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure complexTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/complex/complexScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature complexTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val IM : thm
<a name="line7"></a>    val RE : thm
<a name="line8"></a>    val arg : thm
<a name="line9"></a>    val complex_add : thm
<a name="line10"></a>    val complex_div : thm
<a name="line11"></a>    val complex_exp : thm
<a name="line12"></a>    val complex_inv : thm
<a name="line13"></a>    val complex_mul : thm
<a name="line14"></a>    val complex_neg : thm
<a name="line15"></a>    val complex_of_num : thm
<a name="line16"></a>    val complex_of_real : thm
<a name="line17"></a>    val complex_pow_def : thm
<a name="line18"></a>    val complex_scalar_lmul : thm
<a name="line19"></a>    val complex_scalar_rmul : thm
<a name="line20"></a>    val complex_sub : thm
<a name="line21"></a>    val conj : thm
<a name="line22"></a>    val i : thm
<a name="line23"></a>    val modu : thm
<a name="line24"></a>  
<a name="line25"></a>  (*  Theorems  *)
<a name="line26"></a>    val ARG_COS : thm
<a name="line27"></a>    val ARG_SIN : thm
<a name="line28"></a>    val COMPLEX : thm
<a name="line29"></a>    val COMPLEX_0 : thm
<a name="line30"></a>    val COMPLEX_0_THM : thm
<a name="line31"></a>    val COMPLEX_1 : thm
<a name="line32"></a>    val COMPLEX_10 : thm
<a name="line33"></a>    val COMPLEX_ADD2_SUB2 : thm
<a name="line34"></a>    val COMPLEX_ADD_ASSOC : thm
<a name="line35"></a>    val COMPLEX_ADD_COMM : thm
<a name="line36"></a>    val COMPLEX_ADD_LDISTRIB : thm
<a name="line37"></a>    val COMPLEX_ADD_LID : thm
<a name="line38"></a>    val COMPLEX_ADD_LID_UNIQ : thm
<a name="line39"></a>    val COMPLEX_ADD_LINV : thm
<a name="line40"></a>    val COMPLEX_ADD_RAT : thm
<a name="line41"></a>    val COMPLEX_ADD_RDISTRIB : thm
<a name="line42"></a>    val COMPLEX_ADD_RID : thm
<a name="line43"></a>    val COMPLEX_ADD_RID_UNIQ : thm
<a name="line44"></a>    val COMPLEX_ADD_RINV : thm
<a name="line45"></a>    val COMPLEX_ADD_RSCALAR_RMUL : thm
<a name="line46"></a>    val COMPLEX_ADD_SCALAR_LMUL : thm
<a name="line47"></a>    val COMPLEX_ADD_SUB : thm
<a name="line48"></a>    val COMPLEX_ADD_SUB2 : thm
<a name="line49"></a>    val COMPLEX_DIFFSQ : thm
<a name="line50"></a>    val COMPLEX_DIV1 : thm
<a name="line51"></a>    val COMPLEX_DIV_ADD : thm
<a name="line52"></a>    val COMPLEX_DIV_ARG : thm
<a name="line53"></a>    val COMPLEX_DIV_DENOM_CANCEL : thm
<a name="line54"></a>    val COMPLEX_DIV_INNER_CANCEL : thm
<a name="line55"></a>    val COMPLEX_DIV_LMUL_CANCEL : thm
<a name="line56"></a>    val COMPLEX_DIV_LZERO : thm
<a name="line57"></a>    val COMPLEX_DIV_MUL2 : thm
<a name="line58"></a>    val COMPLEX_DIV_OUTER_CANCEL : thm
<a name="line59"></a>    val COMPLEX_DIV_REFL : thm
<a name="line60"></a>    val COMPLEX_DIV_RMUL_CANCEL : thm
<a name="line61"></a>    val COMPLEX_DIV_SUB : thm
<a name="line62"></a>    val COMPLEX_DOUBLE : thm
<a name="line63"></a>    val COMPLEX_ENTIRE : thm
<a name="line64"></a>    val COMPLEX_EQ_LADD : thm
<a name="line65"></a>    val COMPLEX_EQ_LDIV_EQ : thm
<a name="line66"></a>    val COMPLEX_EQ_LMUL : thm
<a name="line67"></a>    val COMPLEX_EQ_LMUL2 : thm
<a name="line68"></a>    val COMPLEX_EQ_LMUL_IMP : thm
<a name="line69"></a>    val COMPLEX_EQ_NEG : thm
<a name="line70"></a>    val COMPLEX_EQ_RADD : thm
<a name="line71"></a>    val COMPLEX_EQ_RDIV_EQ : thm
<a name="line72"></a>    val COMPLEX_EQ_RMUL_IMP : thm
<a name="line73"></a>    val COMPLEX_EQ_SCALAR_LMUL : thm
<a name="line74"></a>    val COMPLEX_EQ_SUB_LADD : thm
<a name="line75"></a>    val COMPLEX_EQ_SUB_RADD : thm
<a name="line76"></a>    val COMPLEX_EXP_0 : thm
<a name="line77"></a>    val COMPLEX_EXP_ADD : thm
<a name="line78"></a>    val COMPLEX_EXP_ADD_MUL : thm
<a name="line79"></a>    val COMPLEX_EXP_N : thm
<a name="line80"></a>    val COMPLEX_EXP_N2 : thm
<a name="line81"></a>    val COMPLEX_EXP_NEG : thm
<a name="line82"></a>    val COMPLEX_EXP_NEG_MUL : thm
<a name="line83"></a>    val COMPLEX_EXP_NEG_MUL2 : thm
<a name="line84"></a>    val COMPLEX_EXP_NZ : thm
<a name="line85"></a>    val COMPLEX_EXP_SUB : thm
<a name="line86"></a>    val COMPLEX_INV1 : thm
<a name="line87"></a>    val COMPLEX_INVINV : thm
<a name="line88"></a>    val COMPLEX_INV_0 : thm
<a name="line89"></a>    val COMPLEX_INV_1OVER : thm
<a name="line90"></a>    val COMPLEX_INV_ARG : thm
<a name="line91"></a>    val COMPLEX_INV_EQ_0 : thm
<a name="line92"></a>    val COMPLEX_INV_INJ : thm
<a name="line93"></a>    val COMPLEX_INV_INV : thm
<a name="line94"></a>    val COMPLEX_INV_MUL : thm
<a name="line95"></a>    val COMPLEX_INV_NEG : thm
<a name="line96"></a>    val COMPLEX_INV_NZ : thm
<a name="line97"></a>    val COMPLEX_INV_SCALAR_LMUL : thm
<a name="line98"></a>    val COMPLEX_LEMMA1 : thm
<a name="line99"></a>    val COMPLEX_LEMMA2 : thm
<a name="line100"></a>    val COMPLEX_LINV_UNIQ : thm
<a name="line101"></a>    val COMPLEX_LMUL_SCALAR_LMUL : thm
<a name="line102"></a>    val COMPLEX_LNEG_UNIQ : thm
<a name="line103"></a>    val COMPLEX_MODU_ARG_EQ : thm
<a name="line104"></a>    val COMPLEX_MUL_ARG : thm
<a name="line105"></a>    val COMPLEX_MUL_ASSOC : thm
<a name="line106"></a>    val COMPLEX_MUL_COMM : thm
<a name="line107"></a>    val COMPLEX_MUL_LCONJ1 : thm
<a name="line108"></a>    val COMPLEX_MUL_LID : thm
<a name="line109"></a>    val COMPLEX_MUL_LINV : thm
<a name="line110"></a>    val COMPLEX_MUL_LNEG : thm
<a name="line111"></a>    val COMPLEX_MUL_LZERO : thm
<a name="line112"></a>    val COMPLEX_MUL_RCONJ : thm
<a name="line113"></a>    val COMPLEX_MUL_RCONJ1 : thm
<a name="line114"></a>    val COMPLEX_MUL_RID : thm
<a name="line115"></a>    val COMPLEX_MUL_RINV : thm
<a name="line116"></a>    val COMPLEX_MUL_RNEG : thm
<a name="line117"></a>    val COMPLEX_MUL_RZERO : thm
<a name="line118"></a>    val COMPLEX_MUL_SCALAR_LMUL2 : thm
<a name="line119"></a>    val COMPLEX_NEGNEG : thm
<a name="line120"></a>    val COMPLEX_NEG_0 : thm
<a name="line121"></a>    val COMPLEX_NEG_ADD : thm
<a name="line122"></a>    val COMPLEX_NEG_DIV2 : thm
<a name="line123"></a>    val COMPLEX_NEG_INV : thm
<a name="line124"></a>    val COMPLEX_NEG_LDIV : thm
<a name="line125"></a>    val COMPLEX_NEG_LMUL : thm
<a name="line126"></a>    val COMPLEX_NEG_MUL2 : thm
<a name="line127"></a>    val COMPLEX_NEG_Q : thm
<a name="line128"></a>    val COMPLEX_NEG_RDIV : thm
<a name="line129"></a>    val COMPLEX_NEG_RMUL : thm
<a name="line130"></a>    val COMPLEX_NEG_SCALAR_LMUL : thm
<a name="line131"></a>    val COMPLEX_NEG_SCALAR_RMUL : thm
<a name="line132"></a>    val COMPLEX_NEG_SUB : thm
<a name="line133"></a>    val COMPLEX_OF_NUM_ADD : thm
<a name="line134"></a>    val COMPLEX_OF_NUM_EQ : thm
<a name="line135"></a>    val COMPLEX_OF_NUM_MUL : thm
<a name="line136"></a>    val COMPLEX_OF_REAL_ADD : thm
<a name="line137"></a>    val COMPLEX_OF_REAL_DIV : thm
<a name="line138"></a>    val COMPLEX_OF_REAL_EQ : thm
<a name="line139"></a>    val COMPLEX_OF_REAL_INV : thm
<a name="line140"></a>    val COMPLEX_OF_REAL_MUL : thm
<a name="line141"></a>    val COMPLEX_OF_REAL_NEG : thm
<a name="line142"></a>    val COMPLEX_OF_REAL_SUB : thm
<a name="line143"></a>    val COMPLEX_POWINV : thm
<a name="line144"></a>    val COMPLEX_POW_0 : thm
<a name="line145"></a>    val COMPLEX_POW_1 : thm
<a name="line146"></a>    val COMPLEX_POW_2 : thm
<a name="line147"></a>    val COMPLEX_POW_ADD : thm
<a name="line148"></a>    val COMPLEX_POW_DIV : thm
<a name="line149"></a>    val COMPLEX_POW_INV : thm
<a name="line150"></a>    val COMPLEX_POW_L : thm
<a name="line151"></a>    val COMPLEX_POW_MUL : thm
<a name="line152"></a>    val COMPLEX_POW_NZ : thm
<a name="line153"></a>    val COMPLEX_POW_ONE : thm
<a name="line154"></a>    val COMPLEX_POW_POW : thm
<a name="line155"></a>    val COMPLEX_POW_ZERO : thm
<a name="line156"></a>    val COMPLEX_POW_ZERO_EQ : thm
<a name="line157"></a>    val COMPLEX_RE_IM_EQ : thm
<a name="line158"></a>    val COMPLEX_RINV_UNIQ : thm
<a name="line159"></a>    val COMPLEX_RMUL_SCALAR_LMUL : thm
<a name="line160"></a>    val COMPLEX_RNEG_UNIQ : thm
<a name="line161"></a>    val COMPLEX_RSCALAR_RMUL_SUB : thm
<a name="line162"></a>    val COMPLEX_SCALAR_LMUL : thm
<a name="line163"></a>    val COMPLEX_SCALAR_LMUL_ADD : thm
<a name="line164"></a>    val COMPLEX_SCALAR_LMUL_DIV2 : thm
<a name="line165"></a>    val COMPLEX_SCALAR_LMUL_ENTIRE : thm
<a name="line166"></a>    val COMPLEX_SCALAR_LMUL_EQ : thm
<a name="line167"></a>    val COMPLEX_SCALAR_LMUL_EQ1 : thm
<a name="line168"></a>    val COMPLEX_SCALAR_LMUL_NEG : thm
<a name="line169"></a>    val COMPLEX_SCALAR_LMUL_NEG1 : thm
<a name="line170"></a>    val COMPLEX_SCALAR_LMUL_ONE : thm
<a name="line171"></a>    val COMPLEX_SCALAR_LMUL_SUB : thm
<a name="line172"></a>    val COMPLEX_SCALAR_LMUL_ZERO : thm
<a name="line173"></a>    val COMPLEX_SCALAR_MUL_COMM : thm
<a name="line174"></a>    val COMPLEX_SCALAR_RMUL : thm
<a name="line175"></a>    val COMPLEX_SCALAR_RMUL_ADD : thm
<a name="line176"></a>    val COMPLEX_SCALAR_RMUL_NEG : thm
<a name="line177"></a>    val COMPLEX_SCALAR_RMUL_NEG1 : thm
<a name="line178"></a>    val COMPLEX_SCALAR_RMUL_ONE : thm
<a name="line179"></a>    val COMPLEX_SCALAR_RMUL_ZERO : thm
<a name="line180"></a>    val COMPLEX_SUB_0 : thm
<a name="line181"></a>    val COMPLEX_SUB_ADD : thm
<a name="line182"></a>    val COMPLEX_SUB_ADD2 : thm
<a name="line183"></a>    val COMPLEX_SUB_G : thm
<a name="line184"></a>    val COMPLEX_SUB_INV2 : thm
<a name="line185"></a>    val COMPLEX_SUB_LZERO : thm
<a name="line186"></a>    val COMPLEX_SUB_NEG2 : thm
<a name="line187"></a>    val COMPLEX_SUB_RAT : thm
<a name="line188"></a>    val COMPLEX_SUB_REFL : thm
<a name="line189"></a>    val COMPLEX_SUB_RNEG : thm
<a name="line190"></a>    val COMPLEX_SUB_RZERO : thm
<a name="line191"></a>    val COMPLEX_SUB_SCALAR_LMUL : thm
<a name="line192"></a>    val COMPLEX_SUB_SCALAR_RMUL : thm
<a name="line193"></a>    val COMPLEX_SUB_SUB : thm
<a name="line194"></a>    val COMPLEX_SUB_SUB2 : thm
<a name="line195"></a>    val COMPLEX_SUB_TRIANGLE : thm
<a name="line196"></a>    val COMPLEX_TRIANGLE : thm
<a name="line197"></a>    val COMPLEX_ZERO_SCALAR_LMUL : thm
<a name="line198"></a>    val COMPLEX_ZERO_SCALAR_RMUL : thm
<a name="line199"></a>    val CONJ_ADD : thm
<a name="line200"></a>    val CONJ_CONJ : thm
<a name="line201"></a>    val CONJ_DIV : thm
<a name="line202"></a>    val CONJ_EQ : thm
<a name="line203"></a>    val CONJ_EQ2 : thm
<a name="line204"></a>    val CONJ_INV : thm
<a name="line205"></a>    val CONJ_MUL : thm
<a name="line206"></a>    val CONJ_NEG : thm
<a name="line207"></a>    val CONJ_NUM_REFL : thm
<a name="line208"></a>    val CONJ_REAL_REFL : thm
<a name="line209"></a>    val CONJ_SCALAR_LMUL : thm
<a name="line210"></a>    val CONJ_SUB : thm
<a name="line211"></a>    val CONJ_ZERO : thm
<a name="line212"></a>    val DE_MOIVRE_LEMMA : thm
<a name="line213"></a>    val DE_MOIVRE_THM : thm
<a name="line214"></a>    val EULER_FORMULE : thm
<a name="line215"></a>    val EXP_IMAGINARY : thm
<a name="line216"></a>    val IM_COMPLEX_OF_REAL : thm
<a name="line217"></a>    val IM_DIV_MODU_ASN_BOUNDS : thm
<a name="line218"></a>    val IM_DIV_MODU_ASN_SIN : thm
<a name="line219"></a>    val IM_DIV_MODU_BOUNDS : thm
<a name="line220"></a>    val IM_MODU_ARG : thm
<a name="line221"></a>    val MODU_0 : thm
<a name="line222"></a>    val MODU_1 : thm
<a name="line223"></a>    val MODU_CASES : thm
<a name="line224"></a>    val MODU_COMPLEX_INV : thm
<a name="line225"></a>    val MODU_COMPLEX_POW : thm
<a name="line226"></a>    val MODU_CONJ : thm
<a name="line227"></a>    val MODU_DIV : thm
<a name="line228"></a>    val MODU_MUL : thm
<a name="line229"></a>    val MODU_NEG : thm
<a name="line230"></a>    val MODU_NUM : thm
<a name="line231"></a>    val MODU_NZ : thm
<a name="line232"></a>    val MODU_POS : thm
<a name="line233"></a>    val MODU_POW2 : thm
<a name="line234"></a>    val MODU_REAL : thm
<a name="line235"></a>    val MODU_SCALAR_LMUL : thm
<a name="line236"></a>    val MODU_SUB : thm
<a name="line237"></a>    val MODU_UNIT : thm
<a name="line238"></a>    val MODU_ZERO : thm
<a name="line239"></a>    val RE_COMPLEX_OF_REAL : thm
<a name="line240"></a>    val RE_DIV_MODU_ACS_BOUNDS : thm
<a name="line241"></a>    val RE_DIV_MODU_ACS_COS : thm
<a name="line242"></a>    val RE_DIV_MODU_BOUNDS : thm
<a name="line243"></a>    val RE_IM_LE_MODU : thm
<a name="line244"></a>    val RE_MODU_ARG : thm
<a name="line245"></a>  
<a name="line246"></a>  val complex_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line247"></a>(*
   [poly] Parent theory of "complex"
   
   [transc] Parent theory of "complex"
   
   [IM]  Definition
      
      |- ∀z. IM z = SND z
   
   [RE]  Definition
      
      |- ∀z. RE z = FST z
   
   [arg]  Definition
      
      |- ∀z.
           arg z =
           if 0 ≤ IM z then
             acs (RE z / modu z)
           else
             -acs (RE z / modu z) + 2 * pi
   
   [complex_add]  Definition
      
      |- ∀z w. z + w = (RE z + RE w,IM z + IM w)
   
   [complex_div]  Definition
      
      |- ∀z w. z / w = z * inv w
   
   [complex_exp]  Definition
      
      |- ∀z. exp z = exp (RE z) * (cos (IM z),sin (IM z))
   
   [complex_inv]  Definition
      
      |- ∀z.
           inv z =
           (RE z / (RE z pow 2 + IM z pow 2),
            -IM z / (RE z pow 2 + IM z pow 2))
   
   [complex_mul]  Definition
      
      |- ∀z w.
           z * w = (RE z * RE w − IM z * IM w,RE z * IM w + IM z * RE w)
   
   [complex_neg]  Definition
      
      |- ∀z. -z = (-RE z,-IM z)
   
   [complex_of_num]  Definition
      
      |- ∀n. &n = complex_of_real (&n)
   
   [complex_of_real]  Definition
      
      |- ∀x. complex_of_real x = (x,0)
   
   [complex_pow_def]  Definition
      
      |- (∀z. z pow 0 = 1) ∧ ∀z n. z pow SUC n = z * z pow n
   
   [complex_scalar_lmul]  Definition
      
      |- ∀k z. k * z = (k * RE z,k * IM z)
   
   [complex_scalar_rmul]  Definition
      
      |- ∀z k. z * k = (RE z * k,IM z * k)
   
   [complex_sub]  Definition
      
      |- ∀z w. z − w = z + -w
   
   [conj]  Definition
      
      |- ∀z. conj z = (RE z,-IM z)
   
   [i]  Definition
      
      |- i = (0,1)
   
   [modu]  Definition
      
      |- ∀z. modu z = sqrt (RE z pow 2 + IM z pow 2)
   
   [ARG_COS]  Theorem
      
      |- ∀z. z ≠ 0 ⇒ (cos (arg z) = RE z / modu z)
   
   [ARG_SIN]  Theorem
      
      |- ∀z. z ≠ 0 ⇒ (sin (arg z) = IM z / modu z)
   
   [COMPLEX]  Theorem
      
      |- ∀z. (RE z,IM z) = z
   
   [COMPLEX_0]  Theorem
      
      |- 0 = complex_of_real 0
   
   [COMPLEX_0_THM]  Theorem
      
      |- ∀z. (z = 0) ⇔ (RE z pow 2 + IM z pow 2 = 0)
   
   [COMPLEX_1]  Theorem
      
      |- 1 = complex_of_real 1
   
   [COMPLEX_10]  Theorem
      
      |- 1 ≠ 0
   
   [COMPLEX_ADD2_SUB2]  Theorem
      
      |- ∀z w u v. z + w − (u + v) = z − u + (w − v)
   
   [COMPLEX_ADD_ASSOC]  Theorem
      
      |- ∀z w v. z + (w + v) = z + w + v
   
   [COMPLEX_ADD_COMM]  Theorem
      
      |- ∀z w. z + w = w + z
   
   [COMPLEX_ADD_LDISTRIB]  Theorem
      
      |- ∀z w v. z * (w − v) = z * w − z * v
   
   [COMPLEX_ADD_LID]  Theorem
      
      |- ∀z. 0 + z = z
   
   [COMPLEX_ADD_LID_UNIQ]  Theorem
      
      |- ∀z w. (z + w = w) ⇔ (z = 0)
   
   [COMPLEX_ADD_LINV]  Theorem
      
      |- ∀z. -z + z = 0
   
   [COMPLEX_ADD_RAT]  Theorem
      
      |- ∀z w u v.
           w ≠ 0 ∧ v ≠ 0 ⇒ (z / w + u / v = (z * v + w * u) / (w * v))
   
   [COMPLEX_ADD_RDISTRIB]  Theorem
      
      |- ∀z w v. (z − w) * v = z * v − w * v
   
   [COMPLEX_ADD_RID]  Theorem
      
      |- ∀z. z + 0 = z
   
   [COMPLEX_ADD_RID_UNIQ]  Theorem
      
      |- ∀z w. (z + w = z) ⇔ (w = 0)
   
   [COMPLEX_ADD_RINV]  Theorem
      
      |- ∀z. z + -z = 0
   
   [COMPLEX_ADD_RSCALAR_RMUL]  Theorem
      
      |- ∀k z w. (z + w) * k = z * k + w * k
   
   [COMPLEX_ADD_SCALAR_LMUL]  Theorem
      
      |- ∀k z w. k * (z + w) = k * z + k * w
   
   [COMPLEX_ADD_SUB]  Theorem
      
      |- ∀z w. z + w − z = w
   
   [COMPLEX_ADD_SUB2]  Theorem
      
      |- ∀z w. z − (z + w) = -w
   
   [COMPLEX_DIFFSQ]  Theorem
      
      |- ∀z w. (z + w) * (z − w) = z * z − w * w
   
   [COMPLEX_DIV1]  Theorem
      
      |- ∀z. z / 1 = z
   
   [COMPLEX_DIV_ADD]  Theorem
      
      |- ∀z w v. z / v + w / v = (z + w) / v
   
   [COMPLEX_DIV_ARG]  Theorem
      
      |- ∀x y. (cos x,sin x) / (cos y,sin y) = (cos (x − y),sin (x − y))
   
   [COMPLEX_DIV_DENOM_CANCEL]  Theorem
      
      |- ∀z w v. z ≠ 0 ⇒ (w / z / (v / z) = w / v)
   
   [COMPLEX_DIV_INNER_CANCEL]  Theorem
      
      |- ∀z w v. z ≠ 0 ⇒ (w / z * (z / v) = w / v)
   
   [COMPLEX_DIV_LMUL_CANCEL]  Theorem
      
      |- ∀v z w. v ≠ 0 ⇒ (v * z / (v * w) = z / w)
   
   [COMPLEX_DIV_LZERO]  Theorem
      
      |- ∀z. 0 / z = 0
   
   [COMPLEX_DIV_MUL2]  Theorem
      
      |- ∀z w. z ≠ 0 ∧ w ≠ 0 ⇒ ∀v. v / w = z * v / (z * w)
   
   [COMPLEX_DIV_OUTER_CANCEL]  Theorem
      
      |- ∀z w v. z ≠ 0 ⇒ (z / w * (v / z) = v / w)
   
   [COMPLEX_DIV_REFL]  Theorem
      
      |- ∀z. z ≠ 0 ⇒ (z / z = 1)
   
   [COMPLEX_DIV_RMUL_CANCEL]  Theorem
      
      |- ∀v z w. v ≠ 0 ⇒ (z * v / (w * v) = z / w)
   
   [COMPLEX_DIV_SUB]  Theorem
      
      |- ∀z w v. z / v − w / v = (z − w) / v
   
   [COMPLEX_DOUBLE]  Theorem
      
      |- ∀z. z + z = 2 * z
   
   [COMPLEX_ENTIRE]  Theorem
      
      |- ∀z w. (z * w = 0) ⇔ (z = 0) ∨ (w = 0)
   
   [COMPLEX_EQ_LADD]  Theorem
      
      |- ∀z w v. (z + w = z + v) ⇔ (w = v)
   
   [COMPLEX_EQ_LDIV_EQ]  Theorem
      
      |- ∀z w v. v ≠ 0 ⇒ ((z / v = w) ⇔ (z = w * v))
   
   [COMPLEX_EQ_LMUL]  Theorem
      
      |- ∀z w v. (z * v = w * v) ⇔ (v = 0) ∨ (z = w)
   
   [COMPLEX_EQ_LMUL2]  Theorem
      
      |- ∀z w v. z ≠ 0 ⇒ ((w = v) ⇔ (z * w = z * v))
   
   [COMPLEX_EQ_LMUL_IMP]  Theorem
      
      |- ∀z w v. z ≠ 0 ∧ (z * w = z * v) ⇒ (w = v)
   
   [COMPLEX_EQ_NEG]  Theorem
      
      |- ∀z w. (-z = -w) ⇔ (z = w)
   
   [COMPLEX_EQ_RADD]  Theorem
      
      |- ∀z w v. (z + v = w + v) ⇔ (z = w)
   
   [COMPLEX_EQ_RDIV_EQ]  Theorem
      
      |- ∀z w v. v ≠ 0 ⇒ ((z = w / v) ⇔ (z * v = w))
   
   [COMPLEX_EQ_RMUL_IMP]  Theorem
      
      |- ∀z w v. z ≠ 0 ∧ (w * z = v * z) ⇒ (w = v)
   
   [COMPLEX_EQ_SCALAR_LMUL]  Theorem
      
      |- ∀k z w. (k * z = k * w) ⇔ (k = 0) ∨ (z = w)
   
   [COMPLEX_EQ_SUB_LADD]  Theorem
      
      |- ∀z w v. (z = w − v) ⇔ (z + v = w)
   
   [COMPLEX_EQ_SUB_RADD]  Theorem
      
      |- ∀z w v. (z − w = v) ⇔ (z = v + w)
   
   [COMPLEX_EXP_0]  Theorem
      
      |- exp 0 = 1
   
   [COMPLEX_EXP_ADD]  Theorem
      
      |- ∀z w. exp (z + w) = exp z * exp w
   
   [COMPLEX_EXP_ADD_MUL]  Theorem
      
      |- ∀z w. exp (z + w) * exp (-z) = exp w
   
   [COMPLEX_EXP_N]  Theorem
      
      |- ∀z n. exp (&n * z) = exp z pow n
   
   [COMPLEX_EXP_N2]  Theorem
      
      |- ∀z n. exp (&n * z) = exp z pow n
   
   [COMPLEX_EXP_NEG]  Theorem
      
      |- ∀z. exp (-z) = inv (exp z)
   
   [COMPLEX_EXP_NEG_MUL]  Theorem
      
      |- ∀z. exp z * exp (-z) = 1
   
   [COMPLEX_EXP_NEG_MUL2]  Theorem
      
      |- ∀z. exp (-z) * exp z = 1
   
   [COMPLEX_EXP_NZ]  Theorem
      
      |- ∀z. exp z ≠ 0
   
   [COMPLEX_EXP_SUB]  Theorem
      
      |- ∀z w. exp (z − w) = exp z / exp w
   
   [COMPLEX_INV1]  Theorem
      
      |- inv 1 = 1
   
   [COMPLEX_INVINV]  Theorem
      
      |- ∀z. z ≠ 0 ⇒ (inv (inv z) = z)
   
   [COMPLEX_INV_0]  Theorem
      
      |- inv 0 = 0
   
   [COMPLEX_INV_1OVER]  Theorem
      
      |- ∀z. inv z = 1 / z
   
   [COMPLEX_INV_ARG]  Theorem
      
      |- ∀x. inv (cos x,sin x) = (cos (-x),sin (-x))
   
   [COMPLEX_INV_EQ_0]  Theorem
      
      |- ∀z. (inv z = 0) ⇔ (z = 0)
   
   [COMPLEX_INV_INJ]  Theorem
      
      |- ∀z w. (inv z = inv w) ⇔ (z = w)
   
   [COMPLEX_INV_INV]  Theorem
      
      |- ∀z. inv (inv z) = z
   
   [COMPLEX_INV_MUL]  Theorem
      
      |- ∀z w. z ≠ 0 ∧ w ≠ 0 ⇒ (inv (z * w) = inv z * inv w)
   
   [COMPLEX_INV_NEG]  Theorem
      
      |- ∀z. inv (-z) = -inv z
   
   [COMPLEX_INV_NZ]  Theorem
      
      |- ∀z. z ≠ 0 ⇒ inv z ≠ 0
   
   [COMPLEX_INV_SCALAR_LMUL]  Theorem
      
      |- ∀k z. k ≠ 0 ∧ z ≠ 0 ⇒ (inv (k * z) = inv k * inv z)
   
   [COMPLEX_LEMMA1]  Theorem
      
      |- ∀a b c d.
           (a * c − b * d) pow 2 + (a * d + b * c) pow 2 =
           (a pow 2 + b pow 2) * (c pow 2 + d pow 2)
   
   [COMPLEX_LEMMA2]  Theorem
      
      |- ∀x y. abs x ≤ sqrt (x pow 2 + y pow 2)
   
   [COMPLEX_LINV_UNIQ]  Theorem
      
      |- ∀z w. (z * w = 1) ⇒ (z = inv w)
   
   [COMPLEX_LMUL_SCALAR_LMUL]  Theorem
      
      |- ∀k z w. k * z * w = k * (z * w)
   
   [COMPLEX_LNEG_UNIQ]  Theorem
      
      |- ∀z w. (z + w = 0) ⇔ (z = -w)
   
   [COMPLEX_MODU_ARG_EQ]  Theorem
      
      |- ∀z w. (z = w) ⇔ (modu z = modu w) ∧ (arg z = arg w)
   
   [COMPLEX_MUL_ARG]  Theorem
      
      |- ∀x y. (cos x,sin x) * (cos y,sin y) = (cos (x + y),sin (x + y))
   
   [COMPLEX_MUL_ASSOC]  Theorem
      
      |- ∀z w v. z * (w * v) = z * w * v
   
   [COMPLEX_MUL_COMM]  Theorem
      
      |- ∀z w. z * w = w * z
   
   [COMPLEX_MUL_LCONJ1]  Theorem
      
      |- ∀z. conj z * z = complex_of_real (modu z pow 2)
   
   [COMPLEX_MUL_LID]  Theorem
      
      |- ∀z. 1 * z = z
   
   [COMPLEX_MUL_LINV]  Theorem
      
      |- ∀z. z ≠ 0 ⇒ (inv z * z = 1)
   
   [COMPLEX_MUL_LNEG]  Theorem
      
      |- ∀z w. -z * w = -(z * w)
   
   [COMPLEX_MUL_LZERO]  Theorem
      
      |- ∀z. 0 * z = 0
   
   [COMPLEX_MUL_RCONJ]  Theorem
      
      |- ∀z. conj z * z = complex_of_real (RE z pow 2 + IM z pow 2)
   
   [COMPLEX_MUL_RCONJ1]  Theorem
      
      |- ∀z. z * conj z = complex_of_real (modu z pow 2)
   
   [COMPLEX_MUL_RID]  Theorem
      
      |- ∀z. z * 1 = z
   
   [COMPLEX_MUL_RINV]  Theorem
      
      |- ∀z. z ≠ 0 ⇒ (z * inv z = 1)
   
   [COMPLEX_MUL_RNEG]  Theorem
      
      |- ∀z w. z * -w = -(z * w)
   
   [COMPLEX_MUL_RZERO]  Theorem
      
      |- ∀z. z * 0 = 0
   
   [COMPLEX_MUL_SCALAR_LMUL2]  Theorem
      
      |- ∀k l z w. k * z * (l * w) = k * l * (z * w)
   
   [COMPLEX_NEGNEG]  Theorem
      
      |- ∀z. --z = z
   
   [COMPLEX_NEG_0]  Theorem
      
      |- ∀z. (-z = 0) ⇔ (z = 0)
   
   [COMPLEX_NEG_ADD]  Theorem
      
      |- ∀z w. -(z + w) = -z + -w
   
   [COMPLEX_NEG_DIV2]  Theorem
      
      |- ∀z w. -z / -w = z / w
   
   [COMPLEX_NEG_INV]  Theorem
      
      |- ∀z. z ≠ 0 ⇒ (inv (-z) = -inv z)
   
   [COMPLEX_NEG_LDIV]  Theorem
      
      |- ∀z w. -(z / w) = -z / w
   
   [COMPLEX_NEG_LMUL]  Theorem
      
      |- ∀z w. -(z * w) = -z * w
   
   [COMPLEX_NEG_MUL2]  Theorem
      
      |- ∀z w. -z * -w = z * w
   
   [COMPLEX_NEG_Q]  Theorem
      
      |- ∀z w. (-z = w) ⇔ (z = -w)
   
   [COMPLEX_NEG_RDIV]  Theorem
      
      |- ∀z w. -(z / w) = z / -w
   
   [COMPLEX_NEG_RMUL]  Theorem
      
      |- ∀z w. -(z * w) = z * -w
   
   [COMPLEX_NEG_SCALAR_LMUL]  Theorem
      
      |- ∀k z. k * -z = -k * z
   
   [COMPLEX_NEG_SCALAR_RMUL]  Theorem
      
      |- ∀k z. -z * k = z * -k
   
   [COMPLEX_NEG_SUB]  Theorem
      
      |- ∀z w. -(z − w) = w − z
   
   [COMPLEX_OF_NUM_ADD]  Theorem
      
      |- ∀m n. &m + &n = &(m + n)
   
   [COMPLEX_OF_NUM_EQ]  Theorem
      
      |- ∀m n. (&m = &n) ⇔ (m = n)
   
   [COMPLEX_OF_NUM_MUL]  Theorem
      
      |- ∀m n. &m * &n = &(m * n)
   
   [COMPLEX_OF_REAL_ADD]  Theorem
      
      |- ∀x y.
           complex_of_real x + complex_of_real y = complex_of_real (x + y)
   
   [COMPLEX_OF_REAL_DIV]  Theorem
      
      |- ∀x y.
           complex_of_real x / complex_of_real y = complex_of_real (x / y)
   
   [COMPLEX_OF_REAL_EQ]  Theorem
      
      |- ∀x y. (complex_of_real x = complex_of_real y) ⇔ (x = y)
   
   [COMPLEX_OF_REAL_INV]  Theorem
      
      |- ∀x. inv (complex_of_real x) = complex_of_real (inv x)
   
   [COMPLEX_OF_REAL_MUL]  Theorem
      
      |- ∀x y.
           complex_of_real x * complex_of_real y = complex_of_real (x * y)
   
   [COMPLEX_OF_REAL_NEG]  Theorem
      
      |- ∀x. -complex_of_real x = complex_of_real (-x)
   
   [COMPLEX_OF_REAL_SUB]  Theorem
      
      |- ∀x y.
           complex_of_real x − complex_of_real y = complex_of_real (x − y)
   
   [COMPLEX_POWINV]  Theorem
      
      |- ∀z. z ≠ 0 ⇒ ∀n. inv (z pow n) = inv z pow n
   
   [COMPLEX_POW_0]  Theorem
      
      |- ∀n. 0 pow SUC n = 0
   
   [COMPLEX_POW_1]  Theorem
      
      |- ∀z. z pow 1 = z
   
   [COMPLEX_POW_2]  Theorem
      
      |- ∀z. z pow 2 = z * z
   
   [COMPLEX_POW_ADD]  Theorem
      
      |- ∀z m n. z pow (m + n) = z pow m * z pow n
   
   [COMPLEX_POW_DIV]  Theorem
      
      |- ∀z w n. (z / w) pow n = z pow n / w pow n
   
   [COMPLEX_POW_INV]  Theorem
      
      |- ∀z n. inv z pow n = inv (z pow n)
   
   [COMPLEX_POW_L]  Theorem
      
      |- ∀n k z. (k * z) pow n = k pow n * z pow n
   
   [COMPLEX_POW_MUL]  Theorem
      
      |- ∀n z w. (z * w) pow n = z pow n * w pow n
   
   [COMPLEX_POW_NZ]  Theorem
      
      |- ∀z n. z ≠ 0 ⇒ z pow n ≠ 0
   
   [COMPLEX_POW_ONE]  Theorem
      
      |- ∀n. 1 pow n = 1
   
   [COMPLEX_POW_POW]  Theorem
      
      |- ∀z m n. (z pow m) pow n = z pow (m * n)
   
   [COMPLEX_POW_ZERO]  Theorem
      
      |- ∀n z. (z pow n = 0) ⇒ (z = 0)
   
   [COMPLEX_POW_ZERO_EQ]  Theorem
      
      |- ∀n z. (z pow SUC n = 0) ⇔ (z = 0)
   
   [COMPLEX_RE_IM_EQ]  Theorem
      
      |- ∀z w. (z = w) ⇔ (RE z = RE w) ∧ (IM z = IM w)
   
   [COMPLEX_RINV_UNIQ]  Theorem
      
      |- ∀z w. (z * w = 1) ⇒ (w = inv z)
   
   [COMPLEX_RMUL_SCALAR_LMUL]  Theorem
      
      |- ∀k z w. z * (k * w) = k * (z * w)
   
   [COMPLEX_RNEG_UNIQ]  Theorem
      
      |- ∀z w. (z + w = 0) ⇔ (w = -z)
   
   [COMPLEX_RSCALAR_RMUL_SUB]  Theorem
      
      |- ∀k l z. z * (k − l) = z * k − z * l
   
   [COMPLEX_SCALAR_LMUL]  Theorem
      
      |- ∀k l z. k * (l * z) = k * l * z
   
   [COMPLEX_SCALAR_LMUL_ADD]  Theorem
      
      |- ∀k l z. (k + l) * z = k * z + l * z
   
   [COMPLEX_SCALAR_LMUL_DIV2]  Theorem
      
      |- ∀k l z w. l ≠ 0 ∧ w ≠ 0 ⇒ (k * z / (l * w) = k / l * (z / w))
   
   [COMPLEX_SCALAR_LMUL_ENTIRE]  Theorem
      
      |- ∀k z. (k * z = 0) ⇔ (k = 0) ∨ (z = 0)
   
   [COMPLEX_SCALAR_LMUL_EQ]  Theorem
      
      |- ∀k l z. (k * z = l * z) ⇔ (k = l) ∨ (z = 0)
   
   [COMPLEX_SCALAR_LMUL_EQ1]  Theorem
      
      |- ∀k z. (k * z = z) ⇔ (k = 1) ∨ (z = 0)
   
   [COMPLEX_SCALAR_LMUL_NEG]  Theorem
      
      |- ∀k z. -(k * z) = -k * z
   
   [COMPLEX_SCALAR_LMUL_NEG1]  Theorem
      
      |- ∀z. -1 * z = -z
   
   [COMPLEX_SCALAR_LMUL_ONE]  Theorem
      
      |- ∀z. 1 * z = z
   
   [COMPLEX_SCALAR_LMUL_SUB]  Theorem
      
      |- ∀k l z. (k − l) * z = k * z − l * z
   
   [COMPLEX_SCALAR_LMUL_ZERO]  Theorem
      
      |- ∀z. 0 * z = 0
   
   [COMPLEX_SCALAR_MUL_COMM]  Theorem
      
      |- ∀k z. k * z = z * k
   
   [COMPLEX_SCALAR_RMUL]  Theorem
      
      |- ∀k l z. z * k * l = z * (k * l)
   
   [COMPLEX_SCALAR_RMUL_ADD]  Theorem
      
      |- ∀k l z. z * (k + l) = z * k + z * l
   
   [COMPLEX_SCALAR_RMUL_NEG]  Theorem
      
      |- ∀k z. -(z * k) = z * -k
   
   [COMPLEX_SCALAR_RMUL_NEG1]  Theorem
      
      |- ∀z. z * -1 = -z
   
   [COMPLEX_SCALAR_RMUL_ONE]  Theorem
      
      |- ∀z. z * 1 = z
   
   [COMPLEX_SCALAR_RMUL_ZERO]  Theorem
      
      |- ∀z. z * 0 = 0
   
   [COMPLEX_SUB_0]  Theorem
      
      |- ∀z w. (z − w = 0) ⇔ (z = w)
   
   [COMPLEX_SUB_ADD]  Theorem
      
      |- ∀z w. z − w + w = z
   
   [COMPLEX_SUB_ADD2]  Theorem
      
      |- ∀z w. w + (z − w) = z
   
   [COMPLEX_SUB_G]  Theorem
      
      |- ∀z w. -z − w = -(z + w)
   
   [COMPLEX_SUB_INV2]  Theorem
      
      |- ∀z w. z ≠ 0 ∧ w ≠ 0 ⇒ (inv z − inv w = (w − z) / (z * w))
   
   [COMPLEX_SUB_LZERO]  Theorem
      
      |- ∀z. 0 − z = -z
   
   [COMPLEX_SUB_NEG2]  Theorem
      
      |- ∀z w. -z − -w = w − z
   
   [COMPLEX_SUB_RAT]  Theorem
      
      |- ∀z w u v.
           w ≠ 0 ∧ v ≠ 0 ⇒ (z / w − u / v = (z * v − w * u) / (w * v))
   
   [COMPLEX_SUB_REFL]  Theorem
      
      |- ∀z. z − z = 0
   
   [COMPLEX_SUB_RNEG]  Theorem
      
      |- ∀z w. z − -w = z + w
   
   [COMPLEX_SUB_RZERO]  Theorem
      
      |- ∀z. z − 0 = z
   
   [COMPLEX_SUB_SCALAR_LMUL]  Theorem
      
      |- ∀k z w. k * (z − w) = k * z − k * w
   
   [COMPLEX_SUB_SCALAR_RMUL]  Theorem
      
      |- ∀k z w. (z − w) * k = z * k − w * k
   
   [COMPLEX_SUB_SUB]  Theorem
      
      |- ∀z w. z − w − z = -w
   
   [COMPLEX_SUB_SUB2]  Theorem
      
      |- ∀z w. z − (z − w) = w
   
   [COMPLEX_SUB_TRIANGLE]  Theorem
      
      |- ∀z w v. z − w + (w − v) = z − v
   
   [COMPLEX_TRIANGLE]  Theorem
      
      |- ∀z. modu z * (cos (arg z),sin (arg z)) = z
   
   [COMPLEX_ZERO_SCALAR_LMUL]  Theorem
      
      |- ∀k. k * 0 = 0
   
   [COMPLEX_ZERO_SCALAR_RMUL]  Theorem
      
      |- ∀k. 0 * k = 0
   
   [CONJ_ADD]  Theorem
      
      |- ∀z w. conj (z + w) = conj z + conj w
   
   [CONJ_CONJ]  Theorem
      
      |- ∀z. conj (conj z) = z
   
   [CONJ_DIV]  Theorem
      
      |- ∀z w. conj (z / w) = conj z / conj w
   
   [CONJ_EQ]  Theorem
      
      |- ∀z w. (conj z = w) ⇔ (z = conj w)
   
   [CONJ_EQ2]  Theorem
      
      |- ∀z w. (conj z = conj w) ⇔ (z = w)
   
   [CONJ_INV]  Theorem
      
      |- ∀z. conj (inv z) = inv (conj z)
   
   [CONJ_MUL]  Theorem
      
      |- ∀z w. conj (z * w) = conj z * conj w
   
   [CONJ_NEG]  Theorem
      
      |- ∀z. conj (-z) = -conj z
   
   [CONJ_NUM_REFL]  Theorem
      
      |- ∀n. conj (&n) = &n
   
   [CONJ_REAL_REFL]  Theorem
      
      |- ∀x. conj (complex_of_real x) = complex_of_real x
   
   [CONJ_SCALAR_LMUL]  Theorem
      
      |- ∀k z. conj (k * z) = k * conj z
   
   [CONJ_SUB]  Theorem
      
      |- ∀z w. conj (z − w) = conj z − conj w
   
   [CONJ_ZERO]  Theorem
      
      |- conj 0 = 0
   
   [DE_MOIVRE_LEMMA]  Theorem
      
      |- ∀x n. (cos x,sin x) pow n = (cos (&n * x),sin (&n * x))
   
   [DE_MOIVRE_THM]  Theorem
      
      |- ∀z n.
           (modu z * (cos (arg z),sin (arg z))) pow n =
           modu z pow n * (cos (&n * arg z),sin (&n * arg z))
   
   [EULER_FORMULE]  Theorem
      
      |- ∀z. modu z * exp (i * arg z) = z
   
   [EXP_IMAGINARY]  Theorem
      
      |- ∀x. exp (i * x) = (cos x,sin x)
   
   [IM_COMPLEX_OF_REAL]  Theorem
      
      |- ∀x. IM (complex_of_real x) = 0
   
   [IM_DIV_MODU_ASN_BOUNDS]  Theorem
      
      |- ∀z.
           z ≠ 0 ⇒
           -(pi / 2) ≤ asn (IM z / modu z) ∧ asn (IM z / modu z) ≤ pi / 2
   
   [IM_DIV_MODU_ASN_SIN]  Theorem
      
      |- ∀z. z ≠ 0 ⇒ (sin (asn (IM z / modu z)) = IM z / modu z)
   
   [IM_DIV_MODU_BOUNDS]  Theorem
      
      |- ∀z. z ≠ 0 ⇒ -1 ≤ IM z / modu z ∧ IM z / modu z ≤ 1
   
   [IM_MODU_ARG]  Theorem
      
      |- ∀z. IM z = modu z * sin (arg z)
   
   [MODU_0]  Theorem
      
      |- modu 0 = 0
   
   [MODU_1]  Theorem
      
      |- modu 1 = 1
   
   [MODU_CASES]  Theorem
      
      |- ∀z. (z = 0) ∨ 0 &lt; modu z
   
   [MODU_COMPLEX_INV]  Theorem
      
      |- ∀z. z ≠ 0 ⇒ (modu (inv z) = inv (modu z))
   
   [MODU_COMPLEX_POW]  Theorem
      
      |- ∀z n. modu (z pow n) = modu z pow n
   
   [MODU_CONJ]  Theorem
      
      |- ∀z. modu (conj z) = modu z
   
   [MODU_DIV]  Theorem
      
      |- ∀z w. w ≠ 0 ⇒ (modu (z / w) = modu z / modu w)
   
   [MODU_MUL]  Theorem
      
      |- ∀z w. modu (z * w) = modu z * modu w
   
   [MODU_NEG]  Theorem
      
      |- ∀z. modu (-z) = modu z
   
   [MODU_NUM]  Theorem
      
      |- ∀n. modu (&n) = &n
   
   [MODU_NZ]  Theorem
      
      |- ∀z. z ≠ 0 ⇔ 0 &lt; modu z
   
   [MODU_POS]  Theorem
      
      |- ∀z. 0 ≤ modu z
   
   [MODU_POW2]  Theorem
      
      |- ∀z. modu z pow 2 = RE z pow 2 + IM z pow 2
   
   [MODU_REAL]  Theorem
      
      |- ∀x. modu (complex_of_real x) = abs x
   
   [MODU_SCALAR_LMUL]  Theorem
      
      |- ∀k z. modu (k * z) = abs k * modu z
   
   [MODU_SUB]  Theorem
      
      |- ∀z w. modu (z − w) = modu (w − z)
   
   [MODU_UNIT]  Theorem
      
      |- ∀x y. modu (cos x,sin x) = 1
   
   [MODU_ZERO]  Theorem
      
      |- ∀z. (z = 0) ⇔ (modu z = 0)
   
   [RE_COMPLEX_OF_REAL]  Theorem
      
      |- ∀x. RE (complex_of_real x) = x
   
   [RE_DIV_MODU_ACS_BOUNDS]  Theorem
      
      |- ∀z. z ≠ 0 ⇒ 0 ≤ acs (RE z / modu z) ∧ acs (RE z / modu z) ≤ pi
   
   [RE_DIV_MODU_ACS_COS]  Theorem
      
      |- ∀z. z ≠ 0 ⇒ (cos (acs (RE z / modu z)) = RE z / modu z)
   
   [RE_DIV_MODU_BOUNDS]  Theorem
      
      |- ∀z. z ≠ 0 ⇒ -1 ≤ RE z / modu z ∧ RE z / modu z ≤ 1
   
   [RE_IM_LE_MODU]  Theorem
      
      |- ∀z. abs (RE z) ≤ modu z ∧ abs (IM z) ≤ modu z
   
   [RE_MODU_ARG]  Theorem
      
      |- ∀z. RE z = modu z * cos (arg z)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/complex/complexScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-7</a></em></p></body></html>
