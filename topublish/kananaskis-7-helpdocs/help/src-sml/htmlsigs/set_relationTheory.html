<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure set_relationTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure set_relationTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/pred_set/src/set_relationScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature set_relationTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val acyclic_def : thm
<a name="line7"></a>    val all_choices_def : thm
<a name="line8"></a>    val antisym_def : thm
<a name="line9"></a>    val chain_def : thm
<a name="line10"></a>    val domain_def : thm
<a name="line11"></a>    val fchains_def : thm
<a name="line12"></a>    val finite_prefixes_def : thm
<a name="line13"></a>    val get_min_def : thm
<a name="line14"></a>    val irreflexive_def : thm
<a name="line15"></a>    val linear_order_def : thm
<a name="line16"></a>    val maximal_elements_def : thm
<a name="line17"></a>    val minimal_elements_def : thm
<a name="line18"></a>    val nth_min_curried_def : thm
<a name="line19"></a>    val nth_min_tupled_primitive_def : thm
<a name="line20"></a>    val num_order_def : thm
<a name="line21"></a>    val partial_order_def : thm
<a name="line22"></a>    val per_def : thm
<a name="line23"></a>    val per_restrict_def : thm
<a name="line24"></a>    val range_def : thm
<a name="line25"></a>    val rcomp_def : thm
<a name="line26"></a>    val reflexive_def : thm
<a name="line27"></a>    val rrestrict_def : thm
<a name="line28"></a>    val strict_def : thm
<a name="line29"></a>    val strict_linear_order_def : thm
<a name="line30"></a>    val tc_def : thm
<a name="line31"></a>    val transitive_def : thm
<a name="line32"></a>    val univ_reln_def : thm
<a name="line33"></a>    val upper_bounds_def : thm
<a name="line34"></a>  
<a name="line35"></a>  (*  Theorems  *)
<a name="line36"></a>    val acyclic_bigunion : thm
<a name="line37"></a>    val acyclic_irreflexive : thm
<a name="line38"></a>    val acyclic_rrestrict : thm
<a name="line39"></a>    val acyclic_subset : thm
<a name="line40"></a>    val acyclic_union : thm
<a name="line41"></a>    val all_choices_thm : thm
<a name="line42"></a>    val countable_per : thm
<a name="line43"></a>    val empty_linear_order : thm
<a name="line44"></a>    val empty_strict_linear_order : thm
<a name="line45"></a>    val extend_linear_order : thm
<a name="line46"></a>    val finite_acyclic_has_maximal : thm
<a name="line47"></a>    val finite_acyclic_has_maximal_path : thm
<a name="line48"></a>    val finite_acyclic_has_minimal : thm
<a name="line49"></a>    val finite_acyclic_has_minimal_path : thm
<a name="line50"></a>    val finite_linear_order_has_maximal : thm
<a name="line51"></a>    val finite_linear_order_has_minimal : thm
<a name="line52"></a>    val finite_prefix_linear_order_has_unique_minimal : thm
<a name="line53"></a>    val finite_prefix_po_has_minimal_path : thm
<a name="line54"></a>    val finite_prefixes_comp : thm
<a name="line55"></a>    val finite_prefixes_inj_image : thm
<a name="line56"></a>    val finite_prefixes_range : thm
<a name="line57"></a>    val finite_prefixes_subset : thm
<a name="line58"></a>    val finite_prefixes_union : thm
<a name="line59"></a>    val finite_strict_linear_order_has_maximal : thm
<a name="line60"></a>    val finite_strict_linear_order_has_minimal : thm
<a name="line61"></a>    val in_domain : thm
<a name="line62"></a>    val in_range : thm
<a name="line63"></a>    val in_rrestrict : thm
<a name="line64"></a>    val linear_order : thm
<a name="line65"></a>    val linear_order_dom_rng : thm
<a name="line66"></a>    val linear_order_num_order : thm
<a name="line67"></a>    val linear_order_of_countable_po : thm
<a name="line68"></a>    val linear_order_restrict : thm
<a name="line69"></a>    val linear_order_subset : thm
<a name="line70"></a>    val maximal_TC : thm
<a name="line71"></a>    val maximal_linear_order : thm
<a name="line72"></a>    val maximal_union : thm
<a name="line73"></a>    val minimal_TC : thm
<a name="line74"></a>    val minimal_linear_order : thm
<a name="line75"></a>    val minimal_linear_order_unique : thm
<a name="line76"></a>    val minimal_union : thm
<a name="line77"></a>    val nat_order_iso_thm : thm
<a name="line78"></a>    val nth_min_def : thm
<a name="line79"></a>    val nth_min_ind : thm
<a name="line80"></a>    val num_order_finite_prefix : thm
<a name="line81"></a>    val partial_order_dom_rng : thm
<a name="line82"></a>    val partial_order_linear_order : thm
<a name="line83"></a>    val partial_order_subset : thm
<a name="line84"></a>    val per_delete : thm
<a name="line85"></a>    val per_restrict_per : thm
<a name="line86"></a>    val rextension : thm
<a name="line87"></a>    val rrestrict_rrestrict : thm
<a name="line88"></a>    val rrestrict_tc : thm
<a name="line89"></a>    val rrestrict_union : thm
<a name="line90"></a>    val rtc_ind_right : thm
<a name="line91"></a>    val strict_linear_order : thm
<a name="line92"></a>    val strict_linear_order_acyclic : thm
<a name="line93"></a>    val strict_linear_order_dom_rng : thm
<a name="line94"></a>    val strict_linear_order_restrict : thm
<a name="line95"></a>    val strict_linear_order_union_acyclic : thm
<a name="line96"></a>    val strict_partial_order : thm
<a name="line97"></a>    val strict_partial_order_acyclic : thm
<a name="line98"></a>    val strict_rrestrict : thm
<a name="line99"></a>    val tc_cases : thm
<a name="line100"></a>    val tc_cases_left : thm
<a name="line101"></a>    val tc_cases_right : thm
<a name="line102"></a>    val tc_domain_range : thm
<a name="line103"></a>    val tc_empty : thm
<a name="line104"></a>    val tc_implication : thm
<a name="line105"></a>    val tc_ind : thm
<a name="line106"></a>    val tc_ind_left : thm
<a name="line107"></a>    val tc_ind_right : thm
<a name="line108"></a>    val tc_rules : thm
<a name="line109"></a>    val tc_strongind : thm
<a name="line110"></a>    val tc_strongind_left : thm
<a name="line111"></a>    val tc_strongind_right : thm
<a name="line112"></a>    val tc_transitive : thm
<a name="line113"></a>    val tc_union : thm
<a name="line114"></a>    val transitive_tc : thm
<a name="line115"></a>    val upper_bounds_lem : thm
<a name="line116"></a>    val zorns_lemma : thm
<a name="line117"></a>  
<a name="line118"></a>  val set_relation_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line119"></a>(*
   [pred_set] Parent theory of "set_relation"
   
   [acyclic_def]  Definition
      
      |- ∀r. acyclic r ⇔ ∀x. (x,x) ∉ tc r
   
   [all_choices_def]  Definition
      
      |- ∀xss.
           all_choices xss =
           {IMAGE choice xss | choice | ∀xs. xs ∈ xss ⇒ choice xs ∈ xs}
   
   [antisym_def]  Definition
      
      |- ∀r. antisym r ⇔ ∀x y. (x,y) ∈ r ∧ (y,x) ∈ r ⇒ (x = y)
   
   [chain_def]  Definition
      
      |- ∀s r. chain s r ⇔ ∀x y. x ∈ s ∧ y ∈ s ⇒ (x,y) ∈ r ∨ (y,x) ∈ r
   
   [domain_def]  Definition
      
      |- ∀r. domain r = {x | ∃y. (x,y) ∈ r}
   
   [fchains_def]  Definition
      
      |- ∀r.
           fchains r =
           {k |
            chain k r ∧ k ≠ ∅ ∧
            ∀C.
              chain C r ∧ C ⊆ k ∧ (upper_bounds C r DIFF C) ∩ k ≠ ∅ ⇒
              CHOICE (upper_bounds C r DIFF C) ∈
              minimal_elements ((upper_bounds C r DIFF C) ∩ k) r}
   
   [finite_prefixes_def]  Definition
      
      |- ∀r s. finite_prefixes r s ⇔ ∀e. e ∈ s ⇒ FINITE {e' | (e',e) ∈ r}
   
   [get_min_def]  Definition
      
      |- ∀r' s r.
           get_min r' (s,r) =
           (let mins = minimal_elements (minimal_elements s r) r'
            in
              if SING mins then SOME (CHOICE mins) else NONE)
   
   [irreflexive_def]  Definition
      
      |- ∀r s. irreflexive r s ⇔ ∀x. x ∈ s ⇒ (x,x) ∉ r
   
   [linear_order_def]  Definition
      
      |- ∀r s.
           linear_order r s ⇔
           domain r ⊆ s ∧ range r ⊆ s ∧ transitive r ∧ antisym r ∧
           ∀x y. x ∈ s ∧ y ∈ s ⇒ (x,y) ∈ r ∨ (y,x) ∈ r
   
   [maximal_elements_def]  Definition
      
      |- ∀xs r.
           maximal_elements xs r =
           {x | x ∈ xs ∧ ∀x'. x' ∈ xs ∧ (x,x') ∈ r ⇒ (x = x')}
   
   [minimal_elements_def]  Definition
      
      |- ∀xs r.
           minimal_elements xs r =
           {x | x ∈ xs ∧ ∀x'. x' ∈ xs ∧ (x',x) ∈ r ⇒ (x = x')}
   
   [nth_min_curried_def]  Definition
      
      |- ∀x x1 x2. nth_min x x1 x2 = nth_min_tupled (x,x1,x2)
   
   [nth_min_tupled_primitive_def]  Definition
      
      |- nth_min_tupled =
         WFREC
           (@R.
              WF R ∧
              ∀n r s r' min.
                (min = get_min r' (s,r)) ∧ min ≠ NONE ⇒
                R (r',(s DELETE THE min,r),n) (r',(s,r),SUC n))
           (λnth_min_tupled a.
              case a of
                 (r',(s,r),0) -&gt; I (get_min r' (s,r))
              || (r',(s,r),SUC n) -&gt;
                   I
                     (let min = get_min r' (s,r)
                      in
                        if min = NONE then
                          NONE
                        else
                          nth_min_tupled (r',(s DELETE THE min,r),n)))
   
   [num_order_def]  Definition
      
      |- ∀f s. num_order f s = {(x,y) | x ∈ s ∧ y ∈ s ∧ f x ≤ f y}
   
   [partial_order_def]  Definition
      
      |- ∀r s.
           partial_order r s ⇔
           domain r ⊆ s ∧ range r ⊆ s ∧ transitive r ∧ reflexive r s ∧
           antisym r
   
   [per_def]  Definition
      
      |- ∀xs xss.
           per xs xss ⇔
           BIGUNION xss ⊆ xs ∧ ∅ ∉ xss ∧
           ∀xs1 xs2. xs1 ∈ xss ∧ xs2 ∈ xss ∧ xs1 ≠ xs2 ⇒ DISJOINT xs1 xs2
   
   [per_restrict_def]  Definition
      
      |- ∀xss xs. per_restrict xss xs = {xs' ∩ xs | xs' ∈ xss} DELETE ∅
   
   [range_def]  Definition
      
      |- ∀r. range r = {y | ∃x. (x,y) ∈ r}
   
   [rcomp_def]  Definition
      
      |- ∀r1 r2. r1 OO r2 = {(x,y) | ∃z. (x,z) ∈ r1 ∧ (z,y) ∈ r2}
   
   [reflexive_def]  Definition
      
      |- ∀r s. reflexive r s ⇔ ∀x. x ∈ s ⇒ (x,x) ∈ r
   
   [rrestrict_def]  Definition
      
      |- ∀r s. rrestrict r s = {(x,y) | (x,y) ∈ r ∧ x ∈ s ∧ y ∈ s}
   
   [strict_def]  Definition
      
      |- ∀r. strict r = {(x,y) | (x,y) ∈ r ∧ x ≠ y}
   
   [strict_linear_order_def]  Definition
      
      |- ∀r s.
           strict_linear_order r s ⇔
           domain r ⊆ s ∧ range r ⊆ s ∧ transitive r ∧ (∀x. (x,x) ∉ r) ∧
           ∀x y. x ∈ s ∧ y ∈ s ∧ x ≠ y ⇒ (x,y) ∈ r ∨ (y,x) ∈ r
   
   [tc_def]  Definition
      
      |- tc =
         (λr a0.
            ∀tc'.
              (∀a0.
                 (∃x y. (a0 = (x,y)) ∧ r (x,y)) ∨
                 (∃x y. (a0 = (x,y)) ∧ ∃z. tc' (x,z) ∧ tc' (z,y)) ⇒
                 tc' a0) ⇒
              tc' a0)
   
   [transitive_def]  Definition
      
      |- ∀r. transitive r ⇔ ∀x y z. (x,y) ∈ r ∧ (y,z) ∈ r ⇒ (x,z) ∈ r
   
   [univ_reln_def]  Definition
      
      |- ∀xs. univ_reln xs = {(x1,x2) | x1 ∈ xs ∧ x2 ∈ xs}
   
   [upper_bounds_def]  Definition
      
      |- ∀s r. upper_bounds s r = {x | x ∈ range r ∧ ∀y. y ∈ s ⇒ (y,x) ∈ r}
   
   [acyclic_bigunion]  Theorem
      
      |- ∀rs.
           (∀r r'.
              r ∈ rs ∧ r' ∈ rs ∧ r ≠ r' ⇒
              DISJOINT (domain r ∪ range r) (domain r' ∪ range r')) ∧
           (∀r. r ∈ rs ⇒ acyclic r) ⇒
           acyclic (BIGUNION rs)
   
   [acyclic_irreflexive]  Theorem
      
      |- ∀r x. acyclic r ⇒ (x,x) ∉ r
   
   [acyclic_rrestrict]  Theorem
      
      |- ∀r s. acyclic r ⇒ acyclic (rrestrict r s)
   
   [acyclic_subset]  Theorem
      
      |- ∀r1 r2. acyclic r1 ∧ r2 ⊆ r1 ⇒ acyclic r2
   
   [acyclic_union]  Theorem
      
      |- ∀r r'.
           DISJOINT (domain r ∪ range r) (domain r' ∪ range r') ∧
           acyclic r ∧ acyclic r' ⇒
           acyclic (r ∪ r')
   
   [all_choices_thm]  Theorem
      
      |- ∀x s y. x ∈ all_choices s ∧ y ∈ x ⇒ ∃z. z ∈ s ∧ y ∈ z
   
   [countable_per]  Theorem
      
      |- ∀xs xss. countable xs ∧ per xs xss ⇒ countable xss
   
   [empty_linear_order]  Theorem
      
      |- ∀r. linear_order r ∅ ⇔ (r = ∅)
   
   [empty_strict_linear_order]  Theorem
      
      |- ∀r. strict_linear_order r ∅ ⇔ (r = ∅)
   
   [extend_linear_order]  Theorem
      
      |- ∀r s x.
           x ∉ s ∧ linear_order r s ⇒
           linear_order (r ∪ {(y,x) | y | y ∈ s ∪ {x}}) (s ∪ {x})
   
   [finite_acyclic_has_maximal]  Theorem
      
      |- ∀s.
           FINITE s ⇒ s ≠ ∅ ⇒ ∀r. acyclic r ⇒ ∃x. x ∈ maximal_elements s r
   
   [finite_acyclic_has_maximal_path]  Theorem
      
      |- ∀s r x.
           FINITE s ∧ acyclic r ∧ x ∈ s ∧ x ∉ maximal_elements s r ⇒
           ∃y. y ∈ maximal_elements s r ∧ (x,y) ∈ tc r
   
   [finite_acyclic_has_minimal]  Theorem
      
      |- ∀s.
           FINITE s ⇒ s ≠ ∅ ⇒ ∀r. acyclic r ⇒ ∃x. x ∈ minimal_elements s r
   
   [finite_acyclic_has_minimal_path]  Theorem
      
      |- ∀s r x.
           FINITE s ∧ acyclic r ∧ x ∈ s ∧ x ∉ minimal_elements s r ⇒
           ∃y. y ∈ minimal_elements s r ∧ (y,x) ∈ tc r
   
   [finite_linear_order_has_maximal]  Theorem
      
      |- ∀s r.
           FINITE s ∧ linear_order r s ∧ s ≠ ∅ ⇒
           ∃x. x ∈ maximal_elements s r
   
   [finite_linear_order_has_minimal]  Theorem
      
      |- ∀s r.
           FINITE s ∧ linear_order r s ∧ s ≠ ∅ ⇒
           ∃x. x ∈ minimal_elements s r
   
   [finite_prefix_linear_order_has_unique_minimal]  Theorem
      
      |- ∀r s s'.
           linear_order r s ∧ finite_prefixes r s ∧ x ∈ s' ∧ s' ⊆ s ⇒
           SING (minimal_elements s' r)
   
   [finite_prefix_po_has_minimal_path]  Theorem
      
      |- ∀r s x s'.
           partial_order r s ∧ finite_prefixes r s ∧
           x ∉ minimal_elements s' r ∧ x ∈ s' ∧ s' ⊆ s ⇒
           ∃x'. x' ∈ minimal_elements s' r ∧ (x',x) ∈ r
   
   [finite_prefixes_comp]  Theorem
      
      |- ∀r1 r2 s1 s2.
           finite_prefixes r1 s1 ∧ finite_prefixes r2 s2 ∧
           {x | ∃y. y ∈ s2 ∧ (x,y) ∈ r2} ⊆ s1 ⇒
           finite_prefixes (r1 OO r2) s2
   
   [finite_prefixes_inj_image]  Theorem
      
      |- ∀f r s.
           (∀x y. (f x = f y) ⇒ (x = y)) ∧ finite_prefixes r s ⇒
           finite_prefixes {(f x,f y) | (x,y) ∈ r} (IMAGE f s)
   
   [finite_prefixes_range]  Theorem
      
      |- ∀r s t.
           finite_prefixes r s ∧ DISJOINT t (range r) ⇒
           finite_prefixes r (s ∪ t)
   
   [finite_prefixes_subset]  Theorem
      
      |- ∀r s s'.
           finite_prefixes r s ∧ s' ⊆ s ⇒
           finite_prefixes r s' ∧ finite_prefixes (rrestrict r s') s'
   
   [finite_prefixes_union]  Theorem
      
      |- ∀r1 r2 s1 s2.
           finite_prefixes r1 s1 ∧ finite_prefixes r2 s2 ⇒
           finite_prefixes (r1 ∪ r2) (s1 ∩ s2)
   
   [finite_strict_linear_order_has_maximal]  Theorem
      
      |- ∀s r.
           FINITE s ∧ strict_linear_order r s ∧ s ≠ ∅ ⇒
           ∃x. x ∈ maximal_elements s r
   
   [finite_strict_linear_order_has_minimal]  Theorem
      
      |- ∀s r.
           FINITE s ∧ strict_linear_order r s ∧ s ≠ ∅ ⇒
           ∃x. x ∈ minimal_elements s r
   
   [in_domain]  Theorem
      
      |- ∀x r. x ∈ domain r ⇔ ∃y. (x,y) ∈ r
   
   [in_range]  Theorem
      
      |- ∀y r. y ∈ range r ⇔ ∃x. (x,y) ∈ r
   
   [in_rrestrict]  Theorem
      
      |- ∀x y r s. (x,y) ∈ rrestrict r s ⇔ (x,y) ∈ r ∧ x ∈ s ∧ y ∈ s
   
   [linear_order]  Theorem
      
      |- ∀r s.
           strict_linear_order r s ⇒ linear_order (r ∪ {(x,x) | x ∈ s}) s
   
   [linear_order_dom_rng]  Theorem
      
      |- ∀r s x y. (x,y) ∈ r ∧ linear_order r s ⇒ x ∈ s ∧ y ∈ s
   
   [linear_order_num_order]  Theorem
      
      |- ∀f s t. INJ f s t ⇒ linear_order (num_order f s) s
   
   [linear_order_of_countable_po]  Theorem
      
      |- ∀r s.
           countable s ∧ partial_order r s ∧ finite_prefixes r s ⇒
           ∃r'. linear_order r' s ∧ finite_prefixes r' s ∧ r ⊆ r'
   
   [linear_order_restrict]  Theorem
      
      |- ∀s r s'. linear_order r s ⇒ linear_order (rrestrict r s') (s ∩ s')
   
   [linear_order_subset]  Theorem
      
      |- ∀r s s'.
           linear_order r s ∧ s' ⊆ s ⇒ linear_order (rrestrict r s') s'
   
   [maximal_TC]  Theorem
      
      |- ∀s r.
           domain r ⊆ s ∧ range r ⊆ s ⇒
           (maximal_elements s (tc r) = maximal_elements s r)
   
   [maximal_linear_order]  Theorem
      
      |- ∀s r x y.
           y ∈ s ∧ linear_order r s ∧ x ∈ maximal_elements s r ⇒ (y,x) ∈ r
   
   [maximal_union]  Theorem
      
      |- ∀e s r1 r2.
           e ∈ maximal_elements s (r1 ∪ r2) ⇒
           e ∈ maximal_elements s r1 ∧ e ∈ maximal_elements s r2
   
   [minimal_TC]  Theorem
      
      |- ∀s r.
           domain r ⊆ s ∧ range r ⊆ s ⇒
           (minimal_elements s (tc r) = minimal_elements s r)
   
   [minimal_linear_order]  Theorem
      
      |- ∀s r x y.
           y ∈ s ∧ linear_order r s ∧ x ∈ minimal_elements s r ⇒ (x,y) ∈ r
   
   [minimal_linear_order_unique]  Theorem
      
      |- ∀r s s' x y.
           linear_order r s ∧ x ∈ minimal_elements s' r ∧
           y ∈ minimal_elements s' r ∧ s' ⊆ s ⇒
           (x = y)
   
   [minimal_union]  Theorem
      
      |- ∀e s r1 r2.
           e ∈ minimal_elements s (r1 ∪ r2) ⇒
           e ∈ minimal_elements s r1 ∧ e ∈ minimal_elements s r2
   
   [nat_order_iso_thm]  Theorem
      
      |- ∀f s.
           (∀n m. (f m = f n) ∧ f m ≠ NONE ⇒ (m = n)) ∧
           (∀x. x ∈ s ⇒ ∃m. f m = SOME x) ∧
           (∀m x. (f m = SOME x) ⇒ x ∈ s) ⇒
           linear_order
             {(x,y) | ∃m n. m ≤ n ∧ (f m = SOME x) ∧ (f n = SOME y)} s ∧
           finite_prefixes
             {(x,y) | ∃m n. m ≤ n ∧ (f m = SOME x) ∧ (f n = SOME y)} s
   
   [nth_min_def]  Theorem
      
      |- (∀s r' r. nth_min r' (s,r) 0 = get_min r' (s,r)) ∧
         ∀s r' r n.
           nth_min r' (s,r) (SUC n) =
           (let min = get_min r' (s,r)
            in
              if min = NONE then
                NONE
              else
                nth_min r' (s DELETE THE min,r) n)
   
   [nth_min_ind]  Theorem
      
      |- ∀P.
           (∀r' s r. P r' (s,r) 0) ∧
           (∀r' s r n.
              (∀min.
                 (min = get_min r' (s,r)) ∧ min ≠ NONE ⇒
                 P r' (s DELETE THE min,r) n) ⇒
              P r' (s,r) (SUC n)) ⇒
           ∀v v1 v2 v3. P v (v1,v2) v3
   
   [num_order_finite_prefix]  Theorem
      
      |- ∀f s t. INJ f s t ⇒ finite_prefixes (num_order f s) s
   
   [partial_order_dom_rng]  Theorem
      
      |- ∀r s x y. (x,y) ∈ r ∧ partial_order r s ⇒ x ∈ s ∧ y ∈ s
   
   [partial_order_linear_order]  Theorem
      
      |- ∀r s. linear_order r s ⇒ partial_order r s
   
   [partial_order_subset]  Theorem
      
      |- ∀r s s'.
           partial_order r s ∧ s' ⊆ s ⇒ partial_order (rrestrict r s') s'
   
   [per_delete]  Theorem
      
      |- ∀xs xss e.
           per xs xss ⇒
           per (xs DELETE e)
             {es | es ∈ IMAGE (λes. es DELETE e) xss ∧ es ≠ ∅}
   
   [per_restrict_per]  Theorem
      
      |- ∀r s s'. per s r ⇒ per s' (per_restrict r s')
   
   [rextension]  Theorem
      
      |- ∀s t. (s = t) ⇔ ∀x y. (x,y) ∈ s ⇔ (x,y) ∈ t
   
   [rrestrict_rrestrict]  Theorem
      
      |- ∀r x y. rrestrict (rrestrict r x) y = rrestrict r (x ∩ y)
   
   [rrestrict_tc]  Theorem
      
      |- ∀e e'. (e,e') ∈ tc (rrestrict r x) ⇒ (e,e') ∈ tc r
   
   [rrestrict_union]  Theorem
      
      |- ∀r1 r2 s. rrestrict (r1 ∪ r2) s = rrestrict r1 s ∪ rrestrict r2 s
   
   [rtc_ind_right]  Theorem
      
      |- ∀r tc'.
           (∀x. x ∈ domain r ∨ x ∈ range r ⇒ tc' x x) ∧
           (∀x y. (∃z. tc' x z ∧ (z,y) ∈ r) ⇒ tc' x y) ⇒
           ∀x y. (x,y) ∈ tc r ⇒ tc' x y
   
   [strict_linear_order]  Theorem
      
      |- ∀r s. linear_order r s ⇒ strict_linear_order (strict r) s
   
   [strict_linear_order_acyclic]  Theorem
      
      |- ∀r s. strict_linear_order r s ⇒ acyclic r
   
   [strict_linear_order_dom_rng]  Theorem
      
      |- ∀r s x y. (x,y) ∈ r ∧ strict_linear_order r s ⇒ x ∈ s ∧ y ∈ s
   
   [strict_linear_order_restrict]  Theorem
      
      |- ∀s r s'.
           strict_linear_order r s ⇒
           strict_linear_order (rrestrict r s') (s ∩ s')
   
   [strict_linear_order_union_acyclic]  Theorem
      
      |- ∀r1 r2 s.
           strict_linear_order r1 s ∧ domain r2 ∪ range r2 ⊆ s ⇒
           (acyclic (r1 ∪ r2) ⇔ r2 ⊆ r1)
   
   [strict_partial_order]  Theorem
      
      |- ∀r s.
           partial_order r s ⇒
           domain (strict r) ⊆ s ∧ range (strict r) ⊆ s ∧
           transitive (strict r) ∧ antisym (strict r)
   
   [strict_partial_order_acyclic]  Theorem
      
      |- ∀r s. partial_order r s ⇒ acyclic (strict r)
   
   [strict_rrestrict]  Theorem
      
      |- ∀r s. strict (rrestrict r s) = rrestrict (strict r) s
   
   [tc_cases]  Theorem
      
      |- ∀r x y. (x,y) ∈ tc r ⇔ (x,y) ∈ r ∨ ∃z. (x,z) ∈ tc r ∧ (z,y) ∈ tc r
   
   [tc_cases_left]  Theorem
      
      |- ∀r x y. (x,y) ∈ tc r ⇔ (x,y) ∈ r ∨ ∃z. (x,z) ∈ r ∧ (z,y) ∈ tc r
   
   [tc_cases_right]  Theorem
      
      |- ∀r x y. (x,y) ∈ tc r ⇔ (x,y) ∈ r ∨ ∃z. (x,z) ∈ tc r ∧ (z,y) ∈ r
   
   [tc_domain_range]  Theorem
      
      |- ∀x y. (x,y) ∈ tc r ⇒ x ∈ domain r ∧ y ∈ range r
   
   [tc_empty]  Theorem
      
      |- ∀x y. (x,y) ∉ tc ∅
   
   [tc_implication]  Theorem
      
      |- ∀r1 r2.
           (∀x y. (x,y) ∈ r1 ⇒ (x,y) ∈ r2) ⇒
           ∀x y. (x,y) ∈ tc r1 ⇒ (x,y) ∈ tc r2
   
   [tc_ind]  Theorem
      
      |- ∀r tc'.
           (∀x y. (x,y) ∈ r ⇒ tc' x y) ∧
           (∀x y. (∃z. tc' x z ∧ tc' z y) ⇒ tc' x y) ⇒
           ∀x y. (x,y) ∈ tc r ⇒ tc' x y
   
   [tc_ind_left]  Theorem
      
      |- ∀r tc'.
           (∀x y. (x,y) ∈ r ⇒ tc' x y) ∧
           (∀x y. (∃z. (x,z) ∈ r ∧ tc' z y) ⇒ tc' x y) ⇒
           ∀x y. (x,y) ∈ tc r ⇒ tc' x y
   
   [tc_ind_right]  Theorem
      
      |- ∀r tc'.
           (∀x y. (x,y) ∈ r ⇒ tc' x y) ∧
           (∀x y. (∃z. tc' x z ∧ (z,y) ∈ r) ⇒ tc' x y) ⇒
           ∀x y. (x,y) ∈ tc r ⇒ tc' x y
   
   [tc_rules]  Theorem
      
      |- ∀r.
           (∀x y. (x,y) ∈ r ⇒ (x,y) ∈ tc r) ∧
           ∀x y. (∃z. (x,z) ∈ tc r ∧ (z,y) ∈ tc r) ⇒ (x,y) ∈ tc r
   
   [tc_strongind]  Theorem
      
      |- ∀r tc'.
           (∀x y. (x,y) ∈ r ⇒ tc' x y) ∧
           (∀x y.
              (∃z. (x,z) ∈ tc r ∧ tc' x z ∧ (z,y) ∈ tc r ∧ tc' z y) ⇒
              tc' x y) ⇒
           ∀x y. (x,y) ∈ tc r ⇒ tc' x y
   
   [tc_strongind_left]  Theorem
      
      |- ∀r tc'.
           (∀x y. (x,y) ∈ r ⇒ tc' x y) ∧
           (∀x y. (∃z. (x,z) ∈ r ∧ (z,y) ∈ tc r ∧ tc' z y) ⇒ tc' x y) ⇒
           ∀x y. (x,y) ∈ tc r ⇒ tc' x y
   
   [tc_strongind_right]  Theorem
      
      |- ∀r tc'.
           (∀x y. (x,y) ∈ r ⇒ tc' x y) ∧
           (∀x y. (∃z. (x,z) ∈ tc r ∧ tc' x z ∧ (z,y) ∈ r) ⇒ tc' x y) ⇒
           ∀x y. (x,y) ∈ tc r ⇒ tc' x y
   
   [tc_transitive]  Theorem
      
      |- ∀r. transitive (tc r)
   
   [tc_union]  Theorem
      
      |- ∀x y. (x,y) ∈ tc r1 ⇒ ∀r2. (x,y) ∈ tc (r1 ∪ r2)
   
   [transitive_tc]  Theorem
      
      |- ∀r. transitive r ⇒ (tc r = r)
   
   [upper_bounds_lem]  Theorem
      
      |- ∀r s x1 x2.
           transitive r ∧ x1 ∈ upper_bounds s r ∧ (x1,x2) ∈ r ⇒
           x2 ∈ upper_bounds s r
   
   [zorns_lemma]  Theorem
      
      |- ∀r s.
           s ≠ ∅ ∧ partial_order r s ∧
           (∀t. chain t r ⇒ upper_bounds t r ≠ ∅) ⇒
           ∃x. x ∈ maximal_elements s r
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/pred_set/src/set_relationScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-7</a></em></p></body></html>
