<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: prob_indep</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "prob_indep"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "state_transformerTheory.html"><span class="strong">state_transformer</span></a>&nbsp;&nbsp;
    <a href = "probTheory.html"><span class="strong">prob</span></a>

<h1>Signature</h1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr>
    <th>
    Constant
    <th>
    Type<tr><td>
            <span class="strong">alg_cover</span>
            <td>
            :bool list list -> (num -> bool) -> bool list
    <tr><td>
        <span class="strong">alg_cover_set</span>
        <td>
        :bool list list -> bool
    <tr><td>
        <span class="strong">indep</span>
        <td>
        :((num -> bool) -> Î± # (num -> bool)) -> bool
    <tr><td>
        <span class="strong">indep_set</span>
        <td>
        :((num -> bool) -> bool) -> ((num -> bool) -> bool) -> bool
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">indep_set_def</span>
<DD>
<pre>
|- âˆ€p q.
     indep_set p q â‡”
     measurable p âˆ§ measurable q âˆ§ (prob (p âˆ© q) = prob p * prob q)
</pre>

<DT><span class="strong">alg_cover_set_def</span>
<DD>
<pre>
|- âˆ€l.
     alg_cover_set l â‡”
     alg_sorted l âˆ§ alg_prefixfree l âˆ§ (algebra_embed l = ð•Œ(:num -> bool))
</pre>

<DT><span class="strong">alg_cover_def</span>
<DD>
<pre>
|- âˆ€l x. alg_cover l x = @b. MEM b l âˆ§ alg_embed b x
</pre>

<DT><span class="strong">indep_def</span>
<DD>
<pre>
|- âˆ€f.
     indep f â‡”
     âˆƒl r.
       alg_cover_set l âˆ§
       âˆ€s. f s = (let c = alg_cover l s in (r c,SDROP (LENGTH c) s))
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">INDEP_SET_BASIC</span>
<DD>
<pre>
|- âˆ€p. measurable p â‡’ indep_set âˆ… p âˆ§ indep_set ð•Œ(:num -> bool) p
</pre>

<DT><span class="strong">INDEP_SET_SYM</span>
<DD>
<pre>
|- âˆ€p q. indep_set p q â‡” indep_set p q
</pre>

<DT><span class="strong">INDEP_SET_DISJOINT_DECOMP</span>
<DD>
<pre>
|- âˆ€p q r. indep_set p r âˆ§ indep_set q r âˆ§ (p âˆ© q = âˆ…) â‡’ indep_set (p âˆª q) r
</pre>

<DT><span class="strong">ALG_COVER_SET_BASIC</span>
<DD>
<pre>
|- Â¬alg_cover_set [] âˆ§ alg_cover_set [[]] âˆ§ alg_cover_set [[T]; [F]]
</pre>

<DT><span class="strong">ALG_COVER_WELL_DEFINED</span>
<DD>
<pre>
|- âˆ€l x. alg_cover_set l â‡’ MEM (alg_cover l x) l âˆ§ alg_embed (alg_cover l x) x
</pre>

<DT><span class="strong">ALG_COVER_UNIV</span>
<DD>
<pre>
|- alg_cover [[]] = K []
</pre>

<DT><span class="strong">MAP_CONS_TL_FILTER</span>
<DD>
<pre>
|- âˆ€l b.
     Â¬MEM [] l â‡’
     (MAP (CONS b) (MAP TL (FILTER (Î»x. HD x â‡” b) l)) =
      FILTER (Î»x. HD x â‡” b) l)
</pre>

<DT><span class="strong">ALG_COVER_SET_CASES_THM</span>
<DD>
<pre>
|- âˆ€l.
     alg_cover_set l â‡”
     (l = [[]]) âˆ¨
     âˆƒl1 l2.
       alg_cover_set l1 âˆ§ alg_cover_set l2 âˆ§
       (l = MAP (CONS T) l1 ++ MAP (CONS F) l2)
</pre>

<DT><span class="strong">ALG_COVER_SET_CASES</span>
<DD>
<pre>
|- âˆ€P.
     P [[]] âˆ§
     (âˆ€l1 l2.
        alg_cover_set l1 âˆ§ alg_cover_set l2 âˆ§
        alg_cover_set (MAP (CONS T) l1 ++ MAP (CONS F) l2) â‡’
        P (MAP (CONS T) l1 ++ MAP (CONS F) l2)) â‡’
     âˆ€l. alg_cover_set l â‡’ P l
</pre>

<DT><span class="strong">ALG_COVER_SET_INDUCTION</span>
<DD>
<pre>
|- âˆ€P.
     P [[]] âˆ§
     (âˆ€l1 l2.
        alg_cover_set l1 âˆ§ alg_cover_set l2 âˆ§ P l1 âˆ§ P l2 âˆ§
        alg_cover_set (MAP (CONS T) l1 ++ MAP (CONS F) l2) â‡’
        P (MAP (CONS T) l1 ++ MAP (CONS F) l2)) â‡’
     âˆ€l. alg_cover_set l â‡’ P l
</pre>

<DT><span class="strong">ALG_COVER_EXISTS_UNIQUE</span>
<DD>
<pre>
|- âˆ€l. alg_cover_set l â‡’ âˆ€s. âˆƒ!x. MEM x l âˆ§ alg_embed x s
</pre>

<DT><span class="strong">ALG_COVER_UNIQUE</span>
<DD>
<pre>
|- âˆ€l x s. alg_cover_set l âˆ§ MEM x l âˆ§ alg_embed x s â‡’ (alg_cover l s = x)
</pre>

<DT><span class="strong">ALG_COVER_STEP</span>
<DD>
<pre>
|- âˆ€l1 l2 h t.
     alg_cover_set l1 âˆ§ alg_cover_set l2 â‡’
     (alg_cover (MAP (CONS T) l1 ++ MAP (CONS F) l2) (SCONS h t) =
      if h then T::alg_cover l1 t else F::alg_cover l2 t)
</pre>

<DT><span class="strong">ALG_COVER_HEAD</span>
<DD>
<pre>
|- âˆ€l. alg_cover_set l â‡’ âˆ€f. f o alg_cover l = algebra_embed (FILTER f l)
</pre>

<DT><span class="strong">ALG_COVER_TAIL_STEP</span>
<DD>
<pre>
|- âˆ€l1 l2 q.
     alg_cover_set l1 âˆ§ alg_cover_set l2 â‡’
     (q o
      (Î»x.
         SDROP (LENGTH (alg_cover (MAP (CONS T) l1 ++ MAP (CONS F) l2) x))
           x) =
      (Î»x. SHD x â‡” T) âˆ© q o (Î»x. SDROP (LENGTH (alg_cover l1 x)) x) o STL âˆª
      (Î»x. SHD x â‡” F) âˆ© q o (Î»x. SDROP (LENGTH (alg_cover l2 x)) x) o STL)
</pre>

<DT><span class="strong">ALG_COVER_TAIL_MEASURABLE</span>
<DD>
<pre>
|- âˆ€l.
     alg_cover_set l â‡’
     âˆ€q.
       measurable (q o (Î»x. SDROP (LENGTH (alg_cover l x)) x)) â‡” measurable q
</pre>

<DT><span class="strong">ALG_COVER_TAIL_PROB</span>
<DD>
<pre>
|- âˆ€l.
     alg_cover_set l â‡’
     âˆ€q.
       measurable q â‡’
       (prob (q o (Î»x. SDROP (LENGTH (alg_cover l x)) x)) = prob q)
</pre>

<DT><span class="strong">INDEP_INDEP_SET_LEMMA</span>
<DD>
<pre>
|- âˆ€l.
     alg_cover_set l â‡’
     âˆ€q.
       measurable q â‡’
       âˆ€x.
         MEM x l â‡’
         (prob (alg_embed x âˆ© q o (Î»x. SDROP (LENGTH (alg_cover l x)) x)) =
          (1 / 2) pow LENGTH x * prob q)
</pre>

<DT><span class="strong">INDEP_SET_LIST</span>
<DD>
<pre>
|- âˆ€q l.
     alg_sorted l âˆ§ alg_prefixfree l âˆ§ measurable q âˆ§
     (âˆ€x. MEM x l â‡’ indep_set (alg_embed x) q) â‡’
     indep_set (algebra_embed l) q
</pre>

<DT><span class="strong">INDEP_INDEP_SET</span>
<DD>
<pre>
|- âˆ€f p q. indep f âˆ§ measurable q â‡’ indep_set (p o FST o f) (q o SND o f)
</pre>

<DT><span class="strong">INDEP_UNIT</span>
<DD>
<pre>
|- âˆ€x. indep (UNIT x)
</pre>

<DT><span class="strong">INDEP_SDEST</span>
<DD>
<pre>
|- indep SDEST
</pre>

<DT><span class="strong">BIND_STEP</span>
<DD>
<pre>
|- âˆ€f. BIND SDEST (Î»k. f o SCONS k) = f
</pre>

<DT><span class="strong">INDEP_BIND_SDEST</span>
<DD>
<pre>
|- âˆ€f. (âˆ€x. indep (f x)) â‡’ indep (BIND SDEST f)
</pre>

<DT><span class="strong">INDEP_BIND</span>
<DD>
<pre>
|- âˆ€f g. indep f âˆ§ (âˆ€x. indep (g x)) â‡’ indep (BIND f g)
</pre>

<DT><span class="strong">INDEP_PROB</span>
<DD>
<pre>
|- âˆ€f p q.
     indep f âˆ§ measurable q â‡’
     (prob (p o FST o f âˆ© q o SND o f) = prob (p o FST o f) * prob q)
</pre>

<DT><span class="strong">INDEP_MEASURABLE1</span>
<DD>
<pre>
|- âˆ€f p. indep f â‡’ measurable (p o FST o f)
</pre>

<DT><span class="strong">INDEP_MEASURABLE2</span>
<DD>
<pre>
|- âˆ€f q. indep f âˆ§ measurable q â‡’ measurable (q o SND o f)
</pre>

<DT><span class="strong">PROB_INDEP_BOUND</span>
<DD>
<pre>
|- âˆ€f n.
     indep f â‡’
     (prob (Î»s. FST (f s) < SUC n) =
      prob (Î»s. FST (f s) < n) + prob (Î»s. FST (f s) = n))
</pre>

</DL>



<hr>
</body>
</html>
