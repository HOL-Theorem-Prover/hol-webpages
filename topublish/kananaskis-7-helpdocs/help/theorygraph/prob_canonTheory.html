<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: prob_canon</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "prob_canon"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "prob_extraTheory.html"><span class="strong">prob_extra</span></a>

<h1>Signature</h1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr>
    <th>
    Constant
    <th>
    Type<tr><td>
            <span class="strong">alg_canon</span>
            <td>
            :bool list list -> bool list list
    <tr><td>
        <span class="strong">alg_canon1</span>
        <td>
        :bool list list -> bool list list
    <tr><td>
        <span class="strong">alg_canon2</span>
        <td>
        :bool list list -> bool list list
    <tr><td>
        <span class="strong">alg_canon_find</span>
        <td>
        :bool list -> bool list list -> bool list list
    <tr><td>
        <span class="strong">alg_canon_merge</span>
        <td>
        :bool list -> bool list list -> bool list list
    <tr><td>
        <span class="strong">alg_canon_prefs</span>
        <td>
        :bool list -> bool list list -> bool list list
    <tr><td>
        <span class="strong">alg_longest</span>
        <td>
        :bool list list -> num
    <tr><td>
        <span class="strong">alg_order</span>
        <td>
        :bool list -> bool list -> bool
    <tr><td> <span class="strong">alg_order_tupled</span> <td> :bool list reln
    <tr><td>
        <span class="strong">alg_prefixfree</span>
        <td>
        :bool list list -> bool
    <tr><td>
        <span class="strong">alg_sorted</span>
        <td>
        :bool list list -> bool
    <tr><td>
        <span class="strong">alg_twin</span>
        <td>
        :bool list -> bool list -> bool
    <tr><td>
        <span class="strong">alg_twinfree</span>
        <td>
        :bool list list -> bool
    <tr><td>
        <span class="strong">algebra_canon</span>
        <td>
        :bool list list -> bool
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">alg_twin_def</span>
<DD>
<pre>
|- ∀x y. alg_twin x y ⇔ ∃l. (x = SNOC T l) ∧ (y = SNOC F l)
</pre>

<DT><span class="strong">alg_order_tupled_primitive_def</span>
<DD>
<pre>
|- alg_order_tupled =
   WFREC (@R. WF R ∧ ∀h' h t' t. R (t,t') (h::t,h'::t'))
     (λalg_order_tupled a.
        case a of
           ([],[]) -> I T
        || ([],v9::v10) -> I T
        || (h::t,[]) -> I F
        || (h::t,h'::t') ->
             I ((h ⇔ T) ∧ (h' ⇔ F) ∨ (h ⇔ h') ∧ alg_order_tupled (t,t')))
</pre>

<DT><span class="strong">alg_order_curried_def</span>
<DD>
<pre>
|- ∀x x1. alg_order x x1 ⇔ alg_order_tupled (x,x1)
</pre>

<DT><span class="strong">alg_sorted_primitive_def</span>
<DD>
<pre>
|- alg_sorted =
   WFREC (@R. WF R ∧ ∀x z y. R (y::z) (x::y::z))
     (λalg_sorted a.
        case a of
           [] -> I T
        || [x] -> I T
        || x::y::z -> I (alg_order x y ∧ alg_sorted (y::z)))
</pre>

<DT><span class="strong">alg_prefixfree_primitive_def</span>
<DD>
<pre>
|- alg_prefixfree =
   WFREC (@R. WF R ∧ ∀x z y. R (y::z) (x::y::z))
     (λalg_prefixfree a.
        case a of
           [] -> I T
        || [x] -> I T
        || x::y::z -> I (¬(x ≼ y) ∧ alg_prefixfree (y::z)))
</pre>

<DT><span class="strong">alg_twinfree_primitive_def</span>
<DD>
<pre>
|- alg_twinfree =
   WFREC (@R. WF R ∧ ∀x z y. R (y::z) (x::y::z))
     (λalg_twinfree a.
        case a of
           [] -> I T
        || [x] -> I T
        || x::y::z -> I (¬alg_twin x y ∧ alg_twinfree (y::z)))
</pre>

<DT><span class="strong">alg_longest_def</span>
<DD>
<pre>
|- alg_longest = FOLDR (λh t. if t ≤ LENGTH h then LENGTH h else t) 0
</pre>

<DT><span class="strong">alg_canon_prefs_def</span>
<DD>
<pre>
|- (∀l. alg_canon_prefs l [] = [l]) ∧
   ∀l h t.
     alg_canon_prefs l (h::t) = if l ≼ h then alg_canon_prefs l t else l::h::t
</pre>

<DT><span class="strong">alg_canon_find_def</span>
<DD>
<pre>
|- (∀l. alg_canon_find l [] = [l]) ∧
   ∀l h t.
     alg_canon_find l (h::t) =
     if alg_order h l then
       if h ≼ l then h::t else h::alg_canon_find l t
     else
       alg_canon_prefs l (h::t)
</pre>

<DT><span class="strong">alg_canon1_def</span>
<DD>
<pre>
|- alg_canon1 = FOLDR alg_canon_find []
</pre>

<DT><span class="strong">alg_canon_merge_def</span>
<DD>
<pre>
|- (∀l. alg_canon_merge l [] = [l]) ∧
   ∀l h t.
     alg_canon_merge l (h::t) =
     if alg_twin l h then alg_canon_merge (FRONT h) t else l::h::t
</pre>

<DT><span class="strong">alg_canon2_def</span>
<DD>
<pre>
|- alg_canon2 = FOLDR alg_canon_merge []
</pre>

<DT><span class="strong">alg_canon_def</span>
<DD>
<pre>
|- ∀l. alg_canon l = alg_canon2 (alg_canon1 l)
</pre>

<DT><span class="strong">algebra_canon_def</span>
<DD>
<pre>
|- ∀l. algebra_canon l ⇔ (alg_canon l = l)
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">alg_order_ind</span>
<DD>
<pre>
|- ∀P.
     P [] [] ∧ (∀v7 v8. P [] (v7::v8)) ∧ (∀v3 v4. P (v3::v4) []) ∧
     (∀h t h' t'. P t t' ⇒ P (h::t) (h'::t')) ⇒
     ∀v v1. P v v1
</pre>

<DT><span class="strong">alg_order_def</span>
<DD>
<pre>
|- (alg_order [] [] ⇔ T) ∧ (∀v8 v7. alg_order [] (v7::v8) ⇔ T) ∧
   (∀v4 v3. alg_order (v3::v4) [] ⇔ F) ∧
   ∀t' t h' h.
     alg_order (h::t) (h'::t') ⇔
     (h ⇔ T) ∧ (h' ⇔ F) ∨ (h ⇔ h') ∧ alg_order t t'
</pre>

<DT><span class="strong">alg_sorted_ind</span>
<DD>
<pre>
|- ∀P. (∀x y z. P (y::z) ⇒ P (x::y::z)) ∧ P [] ∧ (∀v. P [v]) ⇒ ∀v. P v
</pre>

<DT><span class="strong">alg_sorted_def</span>
<DD>
<pre>
|- (∀z y x. alg_sorted (x::y::z) ⇔ alg_order x y ∧ alg_sorted (y::z)) ∧
   (alg_sorted [] ⇔ T) ∧ ∀v. alg_sorted [v] ⇔ T
</pre>

<DT><span class="strong">alg_prefixfree_ind</span>
<DD>
<pre>
|- ∀P. (∀x y z. P (y::z) ⇒ P (x::y::z)) ∧ P [] ∧ (∀v. P [v]) ⇒ ∀v. P v
</pre>

<DT><span class="strong">alg_prefixfree_def</span>
<DD>
<pre>
|- (∀z y x. alg_prefixfree (x::y::z) ⇔ ¬(x ≼ y) ∧ alg_prefixfree (y::z)) ∧
   (alg_prefixfree [] ⇔ T) ∧ ∀v. alg_prefixfree [v] ⇔ T
</pre>

<DT><span class="strong">alg_twinfree_ind</span>
<DD>
<pre>
|- ∀P. (∀x y z. P (y::z) ⇒ P (x::y::z)) ∧ P [] ∧ (∀v. P [v]) ⇒ ∀v. P v
</pre>

<DT><span class="strong">alg_twinfree_def</span>
<DD>
<pre>
|- (∀z y x. alg_twinfree (x::y::z) ⇔ ¬alg_twin x y ∧ alg_twinfree (y::z)) ∧
   (alg_twinfree [] ⇔ T) ∧ ∀v. alg_twinfree [v] ⇔ T
</pre>

<DT><span class="strong">ALG_TWIN_NIL</span>
<DD>
<pre>
|- ∀l. ¬alg_twin l [] ∧ ¬alg_twin [] l
</pre>

<DT><span class="strong">ALG_TWIN_SING</span>
<DD>
<pre>
|- ∀x l.
     (alg_twin [x] l ⇔ (x ⇔ T) ∧ (l = [F])) ∧
     (alg_twin l [x] ⇔ (l = [T]) ∧ (x ⇔ F))
</pre>

<DT><span class="strong">ALG_TWIN_CONS</span>
<DD>
<pre>
|- ∀x y z h t.
     (alg_twin (x::y::z) (h::t) ⇔ (x ⇔ h) ∧ alg_twin (y::z) t) ∧
     (alg_twin (h::t) (x::y::z) ⇔ (x ⇔ h) ∧ alg_twin t (y::z))
</pre>

<DT><span class="strong">ALG_TWIN_REDUCE</span>
<DD>
<pre>
|- ∀h t t'. alg_twin (h::t) (h::t') ⇔ alg_twin t t'
</pre>

<DT><span class="strong">ALG_TWINS_PREFIX</span>
<DD>
<pre>
|- ∀x l. l ≼ x ⇒ (x = l) ∨ SNOC T l ≼ x ∨ SNOC F l ≼ x
</pre>

<DT><span class="strong">ALG_ORDER_NIL</span>
<DD>
<pre>
|- ∀x. alg_order [] x ∧ (alg_order x [] ⇔ (x = []))
</pre>

<DT><span class="strong">ALG_ORDER_REFL</span>
<DD>
<pre>
|- ∀x. alg_order x x
</pre>

<DT><span class="strong">ALG_ORDER_ANTISYM</span>
<DD>
<pre>
|- ∀x y. alg_order x y ∧ alg_order y x ⇒ (x = y)
</pre>

<DT><span class="strong">ALG_ORDER_TRANS</span>
<DD>
<pre>
|- ∀x y z. alg_order x y ∧ alg_order y z ⇒ alg_order x z
</pre>

<DT><span class="strong">ALG_ORDER_TOTAL</span>
<DD>
<pre>
|- ∀x y. alg_order x y ∨ alg_order y x
</pre>

<DT><span class="strong">ALG_ORDER_PREFIX</span>
<DD>
<pre>
|- ∀x y. x ≼ y ⇒ alg_order x y
</pre>

<DT><span class="strong">ALG_ORDER_PREFIX_ANTI</span>
<DD>
<pre>
|- ∀x y. alg_order x y ∧ y ≼ x ⇒ (x = y)
</pre>

<DT><span class="strong">ALG_ORDER_PREFIX_MONO</span>
<DD>
<pre>
|- ∀x y z. alg_order x y ∧ alg_order y z ∧ x ≼ z ⇒ x ≼ y
</pre>

<DT><span class="strong">ALG_ORDER_PREFIX_TRANS</span>
<DD>
<pre>
|- ∀x y z. alg_order x y ∧ z ≼ y ⇒ alg_order x z ∨ z ≼ x
</pre>

<DT><span class="strong">ALG_ORDER_SNOC</span>
<DD>
<pre>
|- ∀x l. ¬alg_order (SNOC x l) l
</pre>

<DT><span class="strong">ALG_SORTED_MIN</span>
<DD>
<pre>
|- ∀h t. alg_sorted (h::t) ⇒ ∀x. MEM x t ⇒ alg_order h x
</pre>

<DT><span class="strong">ALG_SORTED_DEF_ALT</span>
<DD>
<pre>
|- ∀h t. alg_sorted (h::t) ⇔ (∀x. MEM x t ⇒ alg_order h x) ∧ alg_sorted t
</pre>

<DT><span class="strong">ALG_SORTED_TL</span>
<DD>
<pre>
|- ∀h t. alg_sorted (h::t) ⇒ alg_sorted t
</pre>

<DT><span class="strong">ALG_SORTED_MONO</span>
<DD>
<pre>
|- ∀x y z. alg_sorted (x::y::z) ⇒ alg_sorted (x::z)
</pre>

<DT><span class="strong">ALG_SORTED_TLS</span>
<DD>
<pre>
|- ∀l b. alg_sorted (MAP (CONS b) l) ⇔ alg_sorted l
</pre>

<DT><span class="strong">ALG_SORTED_STEP</span>
<DD>
<pre>
|- ∀l1 l2.
     alg_sorted (MAP (CONS T) l1 ++ MAP (CONS F) l2) ⇔
     alg_sorted l1 ∧ alg_sorted l2
</pre>

<DT><span class="strong">ALG_SORTED_APPEND</span>
<DD>
<pre>
|- ∀h h' t t'.
     alg_sorted (h::t ++ h'::t') ⇔
     alg_sorted (h::t) ∧ alg_sorted (h'::t') ∧ alg_order (LAST (h::t)) h'
</pre>

<DT><span class="strong">ALG_SORTED_FILTER</span>
<DD>
<pre>
|- ∀P b. alg_sorted b ⇒ alg_sorted (FILTER P b)
</pre>

<DT><span class="strong">ALG_PREFIXFREE_TL</span>
<DD>
<pre>
|- ∀h t. alg_prefixfree (h::t) ⇒ alg_prefixfree t
</pre>

<DT><span class="strong">ALG_PREFIXFREE_MONO</span>
<DD>
<pre>
|- ∀x y z.
     alg_sorted (x::y::z) ∧ alg_prefixfree (x::y::z) ⇒ alg_prefixfree (x::z)
</pre>

<DT><span class="strong">ALG_PREFIXFREE_ELT</span>
<DD>
<pre>
|- ∀h t.
     alg_sorted (h::t) ∧ alg_prefixfree (h::t) ⇒
     ∀x. MEM x t ⇒ ¬(h ≼ x) ∧ ¬(x ≼ h)
</pre>

<DT><span class="strong">ALG_PREFIXFREE_TLS</span>
<DD>
<pre>
|- ∀l b. alg_prefixfree (MAP (CONS b) l) ⇔ alg_prefixfree l
</pre>

<DT><span class="strong">ALG_PREFIXFREE_STEP</span>
<DD>
<pre>
|- ∀l1 l2.
     alg_prefixfree (MAP (CONS T) l1 ++ MAP (CONS F) l2) ⇔
     alg_prefixfree l1 ∧ alg_prefixfree l2
</pre>

<DT><span class="strong">ALG_PREFIXFREE_APPEND</span>
<DD>
<pre>
|- ∀h h' t t'.
     alg_prefixfree (h::t ++ h'::t') ⇔
     alg_prefixfree (h::t) ∧ alg_prefixfree (h'::t') ∧ ¬(LAST (h::t) ≼ h')
</pre>

<DT><span class="strong">ALG_PREFIXFREE_FILTER</span>
<DD>
<pre>
|- ∀P b. alg_sorted b ∧ alg_prefixfree b ⇒ alg_prefixfree (FILTER P b)
</pre>

<DT><span class="strong">ALG_TWINFREE_TL</span>
<DD>
<pre>
|- ∀h t. alg_twinfree (h::t) ⇒ alg_twinfree t
</pre>

<DT><span class="strong">ALG_TWINFREE_TLS</span>
<DD>
<pre>
|- ∀l b. alg_twinfree (MAP (CONS b) l) ⇔ alg_twinfree l
</pre>

<DT><span class="strong">ALG_TWINFREE_STEP1</span>
<DD>
<pre>
|- ∀l1 l2.
     alg_twinfree (MAP (CONS T) l1 ++ MAP (CONS F) l2) ⇒
     alg_twinfree l1 ∧ alg_twinfree l2
</pre>

<DT><span class="strong">ALG_TWINFREE_STEP2</span>
<DD>
<pre>
|- ∀l1 l2.
     (¬MEM [] l1 ∨ ¬MEM [] l2) ∧ alg_twinfree l1 ∧ alg_twinfree l2 ⇒
     alg_twinfree (MAP (CONS T) l1 ++ MAP (CONS F) l2)
</pre>

<DT><span class="strong">ALG_TWINFREE_STEP</span>
<DD>
<pre>
|- ∀l1 l2.
     ¬MEM [] l1 ∨ ¬MEM [] l2 ⇒
     (alg_twinfree (MAP (CONS T) l1 ++ MAP (CONS F) l2) ⇔
      alg_twinfree l1 ∧ alg_twinfree l2)
</pre>

<DT><span class="strong">ALG_LONGEST_HD</span>
<DD>
<pre>
|- ∀h t. LENGTH h ≤ alg_longest (h::t)
</pre>

<DT><span class="strong">ALG_LONGEST_TL</span>
<DD>
<pre>
|- ∀h t. alg_longest t ≤ alg_longest (h::t)
</pre>

<DT><span class="strong">ALG_LONGEST_TLS</span>
<DD>
<pre>
|- ∀h t b. alg_longest (MAP (CONS b) (h::t)) = SUC (alg_longest (h::t))
</pre>

<DT><span class="strong">ALG_LONGEST_APPEND</span>
<DD>
<pre>
|- ∀l1 l2.
     alg_longest l1 ≤ alg_longest (l1 ++ l2) ∧
     alg_longest l2 ≤ alg_longest (l1 ++ l2)
</pre>

<DT><span class="strong">ALG_CANON_PREFS_HD</span>
<DD>
<pre>
|- ∀l b. HD (alg_canon_prefs l b) = l
</pre>

<DT><span class="strong">ALG_CANON_PREFS_DELETES</span>
<DD>
<pre>
|- ∀l b x. MEM x (alg_canon_prefs l b) ⇒ MEM x (l::b)
</pre>

<DT><span class="strong">ALG_CANON_PREFS_SORTED</span>
<DD>
<pre>
|- ∀l b. alg_sorted (l::b) ⇒ alg_sorted (alg_canon_prefs l b)
</pre>

<DT><span class="strong">ALG_CANON_PREFS_PREFIXFREE</span>
<DD>
<pre>
|- ∀l b.
     alg_sorted b ∧ alg_prefixfree b ⇒ alg_prefixfree (alg_canon_prefs l b)
</pre>

<DT><span class="strong">ALG_CANON_PREFS_CONSTANT</span>
<DD>
<pre>
|- ∀l b. alg_prefixfree (l::b) ⇒ (alg_canon_prefs l b = l::b)
</pre>

<DT><span class="strong">ALG_CANON_FIND_HD</span>
<DD>
<pre>
|- ∀l h t.
     (HD (alg_canon_find l (h::t)) = l) ∨ (HD (alg_canon_find l (h::t)) = h)
</pre>

<DT><span class="strong">ALG_CANON_FIND_DELETES</span>
<DD>
<pre>
|- ∀l b x. MEM x (alg_canon_find l b) ⇒ MEM x (l::b)
</pre>

<DT><span class="strong">ALG_CANON_FIND_SORTED</span>
<DD>
<pre>
|- ∀l b. alg_sorted b ⇒ alg_sorted (alg_canon_find l b)
</pre>

<DT><span class="strong">ALG_CANON_FIND_PREFIXFREE</span>
<DD>
<pre>
|- ∀l b. alg_sorted b ∧ alg_prefixfree b ⇒ alg_prefixfree (alg_canon_find l b)
</pre>

<DT><span class="strong">ALG_CANON_FIND_CONSTANT</span>
<DD>
<pre>
|- ∀l b.
     alg_sorted (l::b) ∧ alg_prefixfree (l::b) ⇒ (alg_canon_find l b = l::b)
</pre>

<DT><span class="strong">ALG_CANON1_SORTED</span>
<DD>
<pre>
|- ∀l. alg_sorted (alg_canon1 l)
</pre>

<DT><span class="strong">ALG_CANON1_PREFIXFREE</span>
<DD>
<pre>
|- ∀l. alg_prefixfree (alg_canon1 l)
</pre>

<DT><span class="strong">ALG_CANON1_CONSTANT</span>
<DD>
<pre>
|- ∀l. alg_sorted l ∧ alg_prefixfree l ⇒ (alg_canon1 l = l)
</pre>

<DT><span class="strong">ALG_CANON_MERGE_SORTED_PREFIXFREE_TWINFREE</span>
<DD>
<pre>
|- ∀l b.
     alg_sorted (l::b) ∧ alg_prefixfree (l::b) ∧ alg_twinfree b ⇒
     alg_sorted (alg_canon_merge l b) ∧ alg_prefixfree (alg_canon_merge l b) ∧
     alg_twinfree (alg_canon_merge l b)
</pre>

<DT><span class="strong">ALG_CANON_MERGE_PREFIXFREE_PRESERVE</span>
<DD>
<pre>
|- ∀l b h.
     (∀x. MEM x (l::b) ⇒ ¬(x ≼ h) ∧ ¬(h ≼ x)) ⇒
     ∀x. MEM x (alg_canon_merge l b) ⇒ ¬(x ≼ h) ∧ ¬(h ≼ x)
</pre>

<DT><span class="strong">ALG_CANON_MERGE_SHORTENS</span>
<DD>
<pre>
|- ∀l b x. MEM x (alg_canon_merge l b) ⇒ ∃y. MEM y (l::b) ∧ x ≼ y
</pre>

<DT><span class="strong">ALG_CANON_MERGE_CONSTANT</span>
<DD>
<pre>
|- ∀l b. alg_twinfree (l::b) ⇒ (alg_canon_merge l b = l::b)
</pre>

<DT><span class="strong">ALG_CANON2_PREFIXFREE_PRESERVE</span>
<DD>
<pre>
|- ∀l h.
     (∀x. MEM x l ⇒ ¬(x ≼ h) ∧ ¬(h ≼ x)) ⇒
     ∀x. MEM x (alg_canon2 l) ⇒ ¬(x ≼ h) ∧ ¬(h ≼ x)
</pre>

<DT><span class="strong">ALG_CANON2_SHORTENS</span>
<DD>
<pre>
|- ∀l x. MEM x (alg_canon2 l) ⇒ ∃y. MEM y l ∧ x ≼ y
</pre>

<DT><span class="strong">ALG_CANON2_SORTED_PREFIXFREE_TWINFREE</span>
<DD>
<pre>
|- ∀l.
     alg_sorted l ∧ alg_prefixfree l ⇒
     alg_sorted (alg_canon2 l) ∧ alg_prefixfree (alg_canon2 l) ∧
     alg_twinfree (alg_canon2 l)
</pre>

<DT><span class="strong">ALG_CANON2_CONSTANT</span>
<DD>
<pre>
|- ∀l. alg_twinfree l ⇒ (alg_canon2 l = l)
</pre>

<DT><span class="strong">ALG_CANON_SORTED_PREFIXFREE_TWINFREE</span>
<DD>
<pre>
|- ∀l.
     alg_sorted (alg_canon l) ∧ alg_prefixfree (alg_canon l) ∧
     alg_twinfree (alg_canon l)
</pre>

<DT><span class="strong">ALG_CANON_CONSTANT</span>
<DD>
<pre>
|- ∀l. alg_sorted l ∧ alg_prefixfree l ∧ alg_twinfree l ⇒ (alg_canon l = l)
</pre>

<DT><span class="strong">ALG_CANON_IDEMPOT</span>
<DD>
<pre>
|- ∀l. alg_canon (alg_canon l) = alg_canon l
</pre>

<DT><span class="strong">ALGEBRA_CANON_DEF_ALT</span>
<DD>
<pre>
|- ∀l. algebra_canon l ⇔ alg_sorted l ∧ alg_prefixfree l ∧ alg_twinfree l
</pre>

<DT><span class="strong">ALGEBRA_CANON_BASIC</span>
<DD>
<pre>
|- algebra_canon [] ∧ algebra_canon [[]] ∧ ∀x. algebra_canon [x]
</pre>

<DT><span class="strong">ALG_CANON_BASIC</span>
<DD>
<pre>
|- (alg_canon [] = []) ∧ (alg_canon [[]] = [[]]) ∧ ∀x. alg_canon [x] = [x]
</pre>

<DT><span class="strong">ALGEBRA_CANON_TL</span>
<DD>
<pre>
|- ∀h t. algebra_canon (h::t) ⇒ algebra_canon t
</pre>

<DT><span class="strong">ALGEBRA_CANON_NIL_MEM</span>
<DD>
<pre>
|- ∀l. algebra_canon l ∧ MEM [] l ⇔ (l = [[]])
</pre>

<DT><span class="strong">ALGEBRA_CANON_TLS</span>
<DD>
<pre>
|- ∀l b. algebra_canon (MAP (CONS b) l) ⇔ algebra_canon l
</pre>

<DT><span class="strong">ALGEBRA_CANON_STEP1</span>
<DD>
<pre>
|- ∀l1 l2.
     algebra_canon (MAP (CONS T) l1 ++ MAP (CONS F) l2) ⇒
     algebra_canon l1 ∧ algebra_canon l2
</pre>

<DT><span class="strong">ALGEBRA_CANON_STEP2</span>
<DD>
<pre>
|- ∀l1 l2.
     (l1 ≠ [[]] ∨ l2 ≠ [[]]) ∧ algebra_canon l1 ∧ algebra_canon l2 ⇒
     algebra_canon (MAP (CONS T) l1 ++ MAP (CONS F) l2)
</pre>

<DT><span class="strong">ALGEBRA_CANON_STEP</span>
<DD>
<pre>
|- ∀l1 l2.
     l1 ≠ [[]] ∨ l2 ≠ [[]] ⇒
     (algebra_canon (MAP (CONS T) l1 ++ MAP (CONS F) l2) ⇔
      algebra_canon l1 ∧ algebra_canon l2)
</pre>

<DT><span class="strong">ALGEBRA_CANON_CASES_THM</span>
<DD>
<pre>
|- ∀l.
     algebra_canon l ⇒
     (l = []) ∨ (l = [[]]) ∨
     ∃l1 l2.
       algebra_canon l1 ∧ algebra_canon l2 ∧
       (l = MAP (CONS T) l1 ++ MAP (CONS F) l2)
</pre>

<DT><span class="strong">ALGEBRA_CANON_CASES</span>
<DD>
<pre>
|- ∀P.
     P [] ∧ P [[]] ∧
     (∀l1 l2.
        algebra_canon l1 ∧ algebra_canon l2 ∧
        algebra_canon (MAP (CONS T) l1 ++ MAP (CONS F) l2) ⇒
        P (MAP (CONS T) l1 ++ MAP (CONS F) l2)) ⇒
     ∀l. algebra_canon l ⇒ P l
</pre>

<DT><span class="strong">ALGEBRA_CANON_INDUCTION</span>
<DD>
<pre>
|- ∀P.
     P [] ∧ P [[]] ∧
     (∀l1 l2.
        algebra_canon l1 ∧ algebra_canon l2 ∧ P l1 ∧ P l2 ∧
        algebra_canon (MAP (CONS T) l1 ++ MAP (CONS F) l2) ⇒
        P (MAP (CONS T) l1 ++ MAP (CONS F) l2)) ⇒
     ∀l. algebra_canon l ⇒ P l
</pre>

<DT><span class="strong">MEM_NIL_STEP</span>
<DD>
<pre>
|- ∀l1 l2. ¬MEM [] (MAP (CONS T) l1 ++ MAP (CONS F) l2)
</pre>

<DT><span class="strong">ALG_SORTED_PREFIXFREE_MEM_NIL</span>
<DD>
<pre>
|- ∀l. alg_sorted l ∧ alg_prefixfree l ∧ MEM [] l ⇔ (l = [[]])
</pre>

<DT><span class="strong">ALG_SORTED_PREFIXFREE_EQUALITY</span>
<DD>
<pre>
|- ∀l l'.
     (∀x. MEM x l ⇔ MEM x l') ∧ alg_sorted l ∧ alg_sorted l' ∧
     alg_prefixfree l ∧ alg_prefixfree l' ⇒
     (l = l')
</pre>

</DL>



<hr>
</body>
</html>
