<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure fcpTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure fcpTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/n-bit/fcpScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature fcpTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#EQUAL_def-val">EQUAL_def</a> : thm
<a name="line7"></a>    val <a href="#FCP-val">FCP</a> : thm
<a name="line8"></a>    val <a href="#FCP_CONS_def-val">FCP_CONS_def</a> : thm
<a name="line9"></a>    val <a href="#FCP_EVERY_def-val">FCP_EVERY_def</a> : thm
<a name="line10"></a>    val <a href="#FCP_EXISTS_def-val">FCP_EXISTS_def</a> : thm
<a name="line11"></a>    val <a href="#FCP_HD_def-val">FCP_HD_def</a> : thm
<a name="line12"></a>    val <a href="#FCP_MAP_def-val">FCP_MAP_def</a> : thm
<a name="line13"></a>    val <a href="#FCP_TL_def-val">FCP_TL_def</a> : thm
<a name="line14"></a>    val <a href="#FCP_UPDATE_def-val">FCP_UPDATE_def</a> : thm
<a name="line15"></a>    val <a href="#HAS_SIZE_def-val">HAS_SIZE_def</a> : thm
<a name="line16"></a>    val <a href="#IS_BIT0A_def-val">IS_BIT0A_def</a> : thm
<a name="line17"></a>    val <a href="#IS_BIT0B_def-val">IS_BIT0B_def</a> : thm
<a name="line18"></a>    val <a href="#IS_BIT1A_def-val">IS_BIT1A_def</a> : thm
<a name="line19"></a>    val <a href="#IS_BIT1B_def-val">IS_BIT1B_def</a> : thm
<a name="line20"></a>    val <a href="#IS_BIT1C_def-val">IS_BIT1C_def</a> : thm
<a name="line21"></a>    val <a href="#L2V_def-val">L2V_def</a> : thm
<a name="line22"></a>    val <a href="#V2L_def-val">V2L_def</a> : thm
<a name="line23"></a>    val <a href="#abs_sub1_def-val">abs_sub1_def</a> : thm
<a name="line24"></a>    val <a href="#bit0_TY_DEF-val">bit0_TY_DEF</a> : thm
<a name="line25"></a>    val <a href="#bit0_case_def-val">bit0_case_def</a> : thm
<a name="line26"></a>    val <a href="#bit0_repfns-val">bit0_repfns</a> : thm
<a name="line27"></a>    val <a href="#bit0_size_def-val">bit0_size_def</a> : thm
<a name="line28"></a>    val <a href="#bit1_TY_DEF-val">bit1_TY_DEF</a> : thm
<a name="line29"></a>    val <a href="#bit1_case_def-val">bit1_case_def</a> : thm
<a name="line30"></a>    val <a href="#bit1_repfns-val">bit1_repfns</a> : thm
<a name="line31"></a>    val <a href="#bit1_size_def-val">bit1_size_def</a> : thm
<a name="line32"></a>    val <a href="#cart_TY_DEF-val">cart_TY_DEF</a> : thm
<a name="line33"></a>    val <a href="#cart_tybij-val">cart_tybij</a> : thm
<a name="line34"></a>    val <a href="#dimindex_def-val">dimindex_def</a> : thm
<a name="line35"></a>    val <a href="#fcp_case_def-val">fcp_case_def</a> : thm
<a name="line36"></a>    val <a href="#fcp_index-val">fcp_index</a> : thm
<a name="line37"></a>    val <a href="#finite_image_TY_DEF-val">finite_image_TY_DEF</a> : thm
<a name="line38"></a>    val <a href="#finite_image_tybij-val">finite_image_tybij</a> : thm
<a name="line39"></a>    val <a href="#finite_index_def-val">finite_index_def</a> : thm
<a name="line40"></a>    val <a href="#rep_sub1_def-val">rep_sub1_def</a> : thm
<a name="line41"></a>    val <a href="#sub1_TY_DEF-val">sub1_TY_DEF</a> : thm
<a name="line42"></a>    val <a href="#sub1_bijections-val">sub1_bijections</a> : thm
<a name="line43"></a>    val <a href="#sub_equiv_def-val">sub_equiv_def</a> : thm
<a name="line44"></a>  
<a name="line45"></a>  (*  Theorems  *)
<a name="line46"></a>    val <a href="#APPLY_FCP_UPDATE_ID-val">APPLY_FCP_UPDATE_ID</a> : thm
<a name="line47"></a>    val <a href="#CART_EQ-val">CART_EQ</a> : thm
<a name="line48"></a>    val <a href="#DIMINDEX_GE_1-val">DIMINDEX_GE_1</a> : thm
<a name="line49"></a>    val <a href="#EL_V2L-val">EL_V2L</a> : thm
<a name="line50"></a>    val <a href="#FCP_APPLY_UPDATE_THM-val">FCP_APPLY_UPDATE_THM</a> : thm
<a name="line51"></a>    val <a href="#FCP_BETA-val">FCP_BETA</a> : thm
<a name="line52"></a>    val <a href="#FCP_CONS-val">FCP_CONS</a> : thm
<a name="line53"></a>    val <a href="#FCP_ETA-val">FCP_ETA</a> : thm
<a name="line54"></a>    val <a href="#FCP_EVERY-val">FCP_EVERY</a> : thm
<a name="line55"></a>    val <a href="#FCP_EXISTS-val">FCP_EXISTS</a> : thm
<a name="line56"></a>    val <a href="#FCP_HD-val">FCP_HD</a> : thm
<a name="line57"></a>    val <a href="#FCP_MAP-val">FCP_MAP</a> : thm
<a name="line58"></a>    val <a href="#FCP_TL-val">FCP_TL</a> : thm
<a name="line59"></a>    val <a href="#FCP_UPDATE_COMMUTES-val">FCP_UPDATE_COMMUTES</a> : thm
<a name="line60"></a>    val <a href="#FCP_UPDATE_EQ-val">FCP_UPDATE_EQ</a> : thm
<a name="line61"></a>    val <a href="#FCP_UPDATE_IMP_ID-val">FCP_UPDATE_IMP_ID</a> : thm
<a name="line62"></a>    val <a href="#INDEX_SUB1-val">INDEX_SUB1</a> : thm
<a name="line63"></a>    val <a href="#LENGTH_V2L-val">LENGTH_V2L</a> : thm
<a name="line64"></a>    val <a href="#LISTS_EQ-val">LISTS_EQ</a> : thm
<a name="line65"></a>    val <a href="#NOT_FINITE_IMP_dimindex_1-val">NOT_FINITE_IMP_dimindex_1</a> : thm
<a name="line66"></a>    val <a href="#NULL_V2L-val">NULL_V2L</a> : thm
<a name="line67"></a>    val <a href="#READ_L2V-val">READ_L2V</a> : thm
<a name="line68"></a>    val <a href="#READ_TL-val">READ_TL</a> : thm
<a name="line69"></a>    val <a href="#V2L_L2V-val">V2L_L2V</a> : thm
<a name="line70"></a>    val <a href="#V2L_RECURSIVE-val">V2L_RECURSIVE</a> : thm
<a name="line71"></a>    val <a href="#bit0_11-val">bit0_11</a> : thm
<a name="line72"></a>    val <a href="#bit0_Axiom-val">bit0_Axiom</a> : thm
<a name="line73"></a>    val <a href="#bit0_case_cong-val">bit0_case_cong</a> : thm
<a name="line74"></a>    val <a href="#bit0_distinct-val">bit0_distinct</a> : thm
<a name="line75"></a>    val <a href="#bit0_induction-val">bit0_induction</a> : thm
<a name="line76"></a>    val <a href="#bit0_nchotomy-val">bit0_nchotomy</a> : thm
<a name="line77"></a>    val <a href="#bit1_11-val">bit1_11</a> : thm
<a name="line78"></a>    val <a href="#bit1_Axiom-val">bit1_Axiom</a> : thm
<a name="line79"></a>    val <a href="#bit1_case_cong-val">bit1_case_cong</a> : thm
<a name="line80"></a>    val <a href="#bit1_distinct-val">bit1_distinct</a> : thm
<a name="line81"></a>    val <a href="#bit1_induction-val">bit1_induction</a> : thm
<a name="line82"></a>    val <a href="#bit1_nchotomy-val">bit1_nchotomy</a> : thm
<a name="line83"></a>    val <a href="#card_dimindex-val">card_dimindex</a> : thm
<a name="line84"></a>    val <a href="#datatype_bit0-val">datatype_bit0</a> : thm
<a name="line85"></a>    val <a href="#datatype_bit1-val">datatype_bit1</a> : thm
<a name="line86"></a>    val <a href="#dimindex-val">dimindex</a> : thm
<a name="line87"></a>    val <a href="#exists_v2l_thm-val">exists_v2l_thm</a> : thm
<a name="line88"></a>    val <a href="#fcp_Axiom-val">fcp_Axiom</a> : thm
<a name="line89"></a>    val <a href="#fcp_ind-val">fcp_ind</a> : thm
<a name="line90"></a>    val <a href="#fcp_subst_comp-val">fcp_subst_comp</a> : thm
<a name="line91"></a>    val <a href="#finite_bit0-val">finite_bit0</a> : thm
<a name="line92"></a>    val <a href="#finite_bit1-val">finite_bit1</a> : thm
<a name="line93"></a>    val <a href="#finite_one-val">finite_one</a> : thm
<a name="line94"></a>    val <a href="#finite_sub1-val">finite_sub1</a> : thm
<a name="line95"></a>    val <a href="#finite_sum-val">finite_sum</a> : thm
<a name="line96"></a>    val <a href="#index_bit0-val">index_bit0</a> : thm
<a name="line97"></a>    val <a href="#index_bit1-val">index_bit1</a> : thm
<a name="line98"></a>    val <a href="#index_comp-val">index_comp</a> : thm
<a name="line99"></a>    val <a href="#index_one-val">index_one</a> : thm
<a name="line100"></a>    val <a href="#index_sum-val">index_sum</a> : thm
<a name="line101"></a>    val <a href="#sub1_ABS_REP_CLASS-val">sub1_ABS_REP_CLASS</a> : thm
<a name="line102"></a>    val <a href="#sub1_QUOTIENT-val">sub1_QUOTIENT</a> : thm
<a name="line103"></a>  
<a name="line104"></a>  val fcp_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line105"></a>(*
   [quotient_list] Parent theory of "fcp"
   
   [quotient_option] Parent theory of "fcp"
   
   [quotient_pair] Parent theory of "fcp"
   
   [quotient_sum] Parent theory of "fcp"
   
   [<a name="EQUAL_def-val"><b>EQUAL_def</b></a>]  Definition
      
      |- EQUAL = {CHOICE ùïå(:Œ±); CHOICE (REST ùïå(:Œ±))}
   
   [<a name="FCP-val"><b>FCP</b></a>]  Definition
      
      |- $FCP = (Œªg. @f. ‚àÄi. i &lt; dimindex (:Œ≤) ‚áí (f ' i = g i))
   
   [<a name="FCP_CONS_def-val"><b>FCP_CONS_def</b></a>]  Definition
      
      |- ‚àÄh v. FCP_CONS h v = (0 :+ h) (FCP i. v ' (PRE i))
   
   [<a name="FCP_EVERY_def-val"><b>FCP_EVERY_def</b></a>]  Definition
      
      |- ‚àÄP v. FCP_EVERY P v ‚áî ‚àÄi. dimindex (:Œ±) ‚â§ i ‚à® P (v ' i)
   
   [<a name="FCP_EXISTS_def-val"><b>FCP_EXISTS_def</b></a>]  Definition
      
      |- ‚àÄP v. FCP_EXISTS P v ‚áî ‚àÉi. i &lt; dimindex (:Œ±) ‚àß P (v ' i)
   
   [<a name="FCP_HD_def-val"><b>FCP_HD_def</b></a>]  Definition
      
      |- ‚àÄv. FCP_HD v = v ' 0
   
   [<a name="FCP_MAP_def-val"><b>FCP_MAP_def</b></a>]  Definition
      
      |- ‚àÄf v. FCP_MAP f v = FCP i. f (v ' i)
   
   [<a name="FCP_TL_def-val"><b>FCP_TL_def</b></a>]  Definition
      
      |- ‚àÄv. FCP_TL v = FCP i. v ' (SUC i)
   
   [<a name="FCP_UPDATE_def-val"><b>FCP_UPDATE_def</b></a>]  Definition
      
      |- ‚àÄa b. a :+ b = (Œªm. FCP c. if a = c then b else m ' c)
   
   [<a name="HAS_SIZE_def-val"><b>HAS_SIZE_def</b></a>]  Definition
      
      |- ‚àÄs n. (s HAS_SIZE n) ‚áî FINITE s ‚àß (CARD s = n)
   
   [<a name="IS_BIT0A_def-val"><b>IS_BIT0A_def</b></a>]  Definition
      
      |- (‚àÄx. IS_BIT0A (BIT0A x) ‚áî T) ‚àß ‚àÄx. IS_BIT0A (BIT0B x) ‚áî F
   
   [<a name="IS_BIT0B_def-val"><b>IS_BIT0B_def</b></a>]  Definition
      
      |- (‚àÄx. IS_BIT0B (BIT0A x) ‚áî F) ‚àß ‚àÄx. IS_BIT0B (BIT0B x) ‚áî T
   
   [<a name="IS_BIT1A_def-val"><b>IS_BIT1A_def</b></a>]  Definition
      
      |- (‚àÄx. IS_BIT1A (BIT1A x) ‚áî T) ‚àß (‚àÄx. IS_BIT1A (BIT1B x) ‚áî F) ‚àß
         (IS_BIT1A BIT1C ‚áî F)
   
   [<a name="IS_BIT1B_def-val"><b>IS_BIT1B_def</b></a>]  Definition
      
      |- (‚àÄx. IS_BIT1B (BIT1A x) ‚áî F) ‚àß (‚àÄx. IS_BIT1B (BIT1B x) ‚áî T) ‚àß
         (IS_BIT1B BIT1C ‚áî F)
   
   [<a name="IS_BIT1C_def-val"><b>IS_BIT1C_def</b></a>]  Definition
      
      |- (‚àÄx. IS_BIT1C (BIT1A x) ‚áî F) ‚àß (‚àÄx. IS_BIT1C (BIT1B x) ‚áî F) ‚àß
         (IS_BIT1C BIT1C ‚áî T)
   
   [<a name="L2V_def-val"><b>L2V_def</b></a>]  Definition
      
      |- ‚àÄL. L2V L = FCP i. EL i L
   
   [<a name="V2L_def-val"><b>V2L_def</b></a>]  Definition
      
      |- ‚àÄv.
           V2L v =
           @L. (LENGTH L = dimindex (:Œ≤)) ‚àß ‚àÄi. i &lt; dimindex (:Œ≤) ‚áí (EL i L = v ' i)
   
   [<a name="abs_sub1_def-val"><b>abs_sub1_def</b></a>]  Definition
      
      |- ‚àÄr. abs_sub1 r = abs_sub1_CLASS (sub_equiv r)
   
   [<a name="bit0_TY_DEF-val"><b>bit0_TY_DEF</b></a>]  Definition
      
      |- ‚àÉrep.
           TYPE_DEFINITION
             (Œªa0.
                ‚àÄ'bit0' .
                  (‚àÄa0.
                     (‚àÉa. a0 = (Œªa. ind_type$CONSTR 0 a (Œªn. ind_type$BOTTOM)) a) ‚à®
                     (‚àÉa.
                        a0 =
                        (Œªa. ind_type$CONSTR (SUC 0) a (Œªn. ind_type$BOTTOM)) a) ‚áí
                     'bit0' a0) ‚áí
                  'bit0' a0) rep
   
   [<a name="bit0_case_def-val"><b>bit0_case_def</b></a>]  Definition
      
      |- (‚àÄf f1 a. bit0_case f f1 (BIT0A a) = f a) ‚àß
         ‚àÄf f1 a. bit0_case f f1 (BIT0B a) = f1 a
   
   [<a name="bit0_repfns-val"><b>bit0_repfns</b></a>]  Definition
      
      |- (‚àÄa. mk_bit0 (dest_bit0 a) = a) ‚àß
         ‚àÄr.
           (Œªa0.
              ‚àÄ'bit0' .
                (‚àÄa0.
                   (‚àÉa. a0 = (Œªa. ind_type$CONSTR 0 a (Œªn. ind_type$BOTTOM)) a) ‚à®
                   (‚àÉa.
                      a0 = (Œªa. ind_type$CONSTR (SUC 0) a (Œªn. ind_type$BOTTOM)) a) ‚áí
                   'bit0' a0) ‚áí
                'bit0' a0) r ‚áî (dest_bit0 (mk_bit0 r) = r)
   
   [<a name="bit0_size_def-val"><b>bit0_size_def</b></a>]  Definition
      
      |- (‚àÄf a. bit0_size f (BIT0A a) = 1 + f a) ‚àß
         ‚àÄf a. bit0_size f (BIT0B a) = 1 + f a
   
   [<a name="bit1_TY_DEF-val"><b>bit1_TY_DEF</b></a>]  Definition
      
      |- ‚àÉrep.
           TYPE_DEFINITION
             (Œªa0.
                ‚àÄ'bit1' .
                  (‚àÄa0.
                     (‚àÉa. a0 = (Œªa. ind_type$CONSTR 0 a (Œªn. ind_type$BOTTOM)) a) ‚à®
                     (‚àÉa.
                        a0 =
                        (Œªa. ind_type$CONSTR (SUC 0) a (Œªn. ind_type$BOTTOM)) a) ‚à®
                     (a0 = ind_type$CONSTR (SUC (SUC 0)) ARB (Œªn. ind_type$BOTTOM)) ‚áí
                     'bit1' a0) ‚áí
                  'bit1' a0) rep
   
   [<a name="bit1_case_def-val"><b>bit1_case_def</b></a>]  Definition
      
      |- (‚àÄf f1 v a. bit1_case f f1 v (BIT1A a) = f a) ‚àß
         (‚àÄf f1 v a. bit1_case f f1 v (BIT1B a) = f1 a) ‚àß
         ‚àÄf f1 v. bit1_case f f1 v BIT1C = v
   
   [<a name="bit1_repfns-val"><b>bit1_repfns</b></a>]  Definition
      
      |- (‚àÄa. mk_bit1 (dest_bit1 a) = a) ‚àß
         ‚àÄr.
           (Œªa0.
              ‚àÄ'bit1' .
                (‚àÄa0.
                   (‚àÉa. a0 = (Œªa. ind_type$CONSTR 0 a (Œªn. ind_type$BOTTOM)) a) ‚à®
                   (‚àÉa.
                      a0 = (Œªa. ind_type$CONSTR (SUC 0) a (Œªn. ind_type$BOTTOM)) a) ‚à®
                   (a0 = ind_type$CONSTR (SUC (SUC 0)) ARB (Œªn. ind_type$BOTTOM)) ‚áí
                   'bit1' a0) ‚áí
                'bit1' a0) r ‚áî (dest_bit1 (mk_bit1 r) = r)
   
   [<a name="bit1_size_def-val"><b>bit1_size_def</b></a>]  Definition
      
      |- (‚àÄf a. bit1_size f (BIT1A a) = 1 + f a) ‚àß
         (‚àÄf a. bit1_size f (BIT1B a) = 1 + f a) ‚àß ‚àÄf. bit1_size f BIT1C = 0
   
   [<a name="cart_TY_DEF-val"><b>cart_TY_DEF</b></a>]  Definition
      
      |- ‚àÉrep. TYPE_DEFINITION (Œªf. T) rep
   
   [<a name="cart_tybij-val"><b>cart_tybij</b></a>]  Definition
      
      |- (‚àÄa. mk_cart (dest_cart a) = a) ‚àß
         ‚àÄr. (Œªf. T) r ‚áî (dest_cart (mk_cart r) = r)
   
   [<a name="dimindex_def-val"><b>dimindex_def</b></a>]  Definition
      
      |- dimindex (:Œ±) = if FINITE ùïå(:Œ±) then CARD ùïå(:Œ±) else 1
   
   [<a name="fcp_case_def-val"><b>fcp_case_def</b></a>]  Definition
      
      |- ‚àÄf' h. fcp_case f' (mk_cart h) = f' h
   
   [<a name="fcp_index-val"><b>fcp_index</b></a>]  Definition
      
      |- ‚àÄx i. x ' i = dest_cart x (finite_index i)
   
   [<a name="finite_image_TY_DEF-val"><b>finite_image_TY_DEF</b></a>]  Definition
      
      |- ‚àÉrep. TYPE_DEFINITION (Œªx. (x = ARB) ‚à® FINITE ùïå(:Œ±)) rep
   
   [<a name="finite_image_tybij-val"><b>finite_image_tybij</b></a>]  Definition
      
      |- (‚àÄa. mk_finite_image (dest_finite_image a) = a) ‚àß
         ‚àÄr.
           (Œªx. (x = ARB) ‚à® FINITE ùïå(:Œ±)) r ‚áî
           (dest_finite_image (mk_finite_image r) = r)
   
   [<a name="finite_index_def-val"><b>finite_index_def</b></a>]  Definition
      
      |- finite_index = @f. ‚àÄx. ‚àÉ!n. n &lt; dimindex (:Œ±) ‚àß (f n = x)
   
   [<a name="rep_sub1_def-val"><b>rep_sub1_def</b></a>]  Definition
      
      |- ‚àÄa. rep_sub1 a = $@ (rep_sub1_CLASS a)
   
   [<a name="sub1_TY_DEF-val"><b>sub1_TY_DEF</b></a>]  Definition
      
      |- ‚àÉrep. TYPE_DEFINITION (Œªc. ‚àÉr. sub_equiv r r ‚àß (c = sub_equiv r)) rep
   
   [<a name="sub1_bijections-val"><b>sub1_bijections</b></a>]  Definition
      
      |- (‚àÄa. abs_sub1_CLASS (rep_sub1_CLASS a) = a) ‚àß
         ‚àÄr.
           (Œªc. ‚àÉr. sub_equiv r r ‚àß (c = sub_equiv r)) r ‚áî
           (rep_sub1_CLASS (abs_sub1_CLASS r) = r)
   
   [<a name="sub_equiv_def-val"><b>sub_equiv_def</b></a>]  Definition
      
      |- ‚àÄa b. sub_equiv a b ‚áî a ‚àà EQUAL ‚àß b ‚àà EQUAL ‚à® (a = b)
   
   [<a name="APPLY_FCP_UPDATE_ID-val"><b>APPLY_FCP_UPDATE_ID</b></a>]  Theorem
      
      |- ‚àÄm a. (a :+ m ' a) m = m
   
   [<a name="CART_EQ-val"><b>CART_EQ</b></a>]  Theorem
      
      |- ‚àÄx y. (x = y) ‚áî ‚àÄi. i &lt; dimindex (:Œ≤) ‚áí (x ' i = y ' i)
   
   [<a name="DIMINDEX_GE_1-val"><b>DIMINDEX_GE_1</b></a>]  Theorem
      
      |- 1 ‚â§ dimindex (:Œ±)
   
   [<a name="EL_V2L-val"><b>EL_V2L</b></a>]  Theorem
      
      |- i &lt; dimindex (:Œ≤) ‚áí (EL i (V2L v) = v ' i)
   
   [<a name="FCP_APPLY_UPDATE_THM-val"><b>FCP_APPLY_UPDATE_THM</b></a>]  Theorem
      
      |- ‚àÄm a w b.
           (a :+ w) m ' b =
           if b &lt; dimindex (:Œ≤) then
             if a = b then w else m ' b
           else
             FAIL $' index out of range ((a :+ w) m) b
   
   [<a name="FCP_BETA-val"><b>FCP_BETA</b></a>]  Theorem
      
      |- ‚àÄi. i &lt; dimindex (:Œ≤) ‚áí ($FCP g ' i = g i)
   
   [<a name="FCP_CONS-val"><b>FCP_CONS</b></a>]  Theorem
      
      |- FCP_CONS a v = L2V (a::V2L v)
   
   [<a name="FCP_ETA-val"><b>FCP_ETA</b></a>]  Theorem
      
      |- ‚àÄg. (FCP i. g ' i) = g
   
   [<a name="FCP_EVERY-val"><b>FCP_EVERY</b></a>]  Theorem
      
      |- FCP_EVERY P v ‚áî EVERY P (V2L v)
   
   [<a name="FCP_EXISTS-val"><b>FCP_EXISTS</b></a>]  Theorem
      
      |- FCP_EXISTS P v ‚áî EXISTS P (V2L v)
   
   [<a name="FCP_HD-val"><b>FCP_HD</b></a>]  Theorem
      
      |- FCP_HD v = HD (V2L v)
   
   [<a name="FCP_MAP-val"><b>FCP_MAP</b></a>]  Theorem
      
      |- FCP_MAP f v = L2V (MAP f (V2L v))
   
   [<a name="FCP_TL-val"><b>FCP_TL</b></a>]  Theorem
      
      |- 1 &lt; dimindex (:Œ≤) ‚áí (FCP_TL v = L2V (TL (V2L v)))
   
   [<a name="FCP_UPDATE_COMMUTES-val"><b>FCP_UPDATE_COMMUTES</b></a>]  Theorem
      
      |- ‚àÄm a b c d. a ‚â† b ‚áí ((a :+ c) ((b :+ d) m) = (b :+ d) ((a :+ c) m))
   
   [<a name="FCP_UPDATE_EQ-val"><b>FCP_UPDATE_EQ</b></a>]  Theorem
      
      |- ‚àÄm a b c. (a :+ c) ((a :+ b) m) = (a :+ c) m
   
   [<a name="FCP_UPDATE_IMP_ID-val"><b>FCP_UPDATE_IMP_ID</b></a>]  Theorem
      
      |- ‚àÄm a v. (m ' a = v) ‚áí ((a :+ v) m = m)
   
   [<a name="INDEX_SUB1-val"><b>INDEX_SUB1</b></a>]  Theorem
      
      |- dimindex (:Œ± sub1) = if 1 &lt; dimindex (:Œ±) then PRE (dimindex (:Œ±)) else 1
   
   [<a name="LENGTH_V2L-val"><b>LENGTH_V2L</b></a>]  Theorem
      
      |- LENGTH (V2L v) = dimindex (:Œ≤)
   
   [<a name="LISTS_EQ-val"><b>LISTS_EQ</b></a>]  Theorem
      
      |- (x = y) ‚áî (LENGTH x = LENGTH y) ‚àß ‚àÄi. i &lt; LENGTH x ‚áí (EL i x = EL i y)
   
   [<a name="NOT_FINITE_IMP_dimindex_1-val"><b>NOT_FINITE_IMP_dimindex_1</b></a>]  Theorem
      
      |- INFINITE ùïå(:Œ±) ‚áí (dimindex (:Œ±) = 1)
   
   [<a name="NULL_V2L-val"><b>NULL_V2L</b></a>]  Theorem
      
      |- ¬¨NULL (V2L v)
   
   [<a name="READ_L2V-val"><b>READ_L2V</b></a>]  Theorem
      
      |- i &lt; dimindex (:Œ≤) ‚áí (L2V a ' i = EL i a)
   
   [<a name="READ_TL-val"><b>READ_TL</b></a>]  Theorem
      
      |- i &lt; dimindex (:Œ≤) ‚áí (FCP_TL a ' i = a ' (SUC i))
   
   [<a name="V2L_L2V-val"><b>V2L_L2V</b></a>]  Theorem
      
      |- ‚àÄx. (dimindex (:Œ≤) = LENGTH x) ‚áí (V2L (L2V x) = x)
   
   [<a name="V2L_RECURSIVE-val"><b>V2L_RECURSIVE</b></a>]  Theorem
      
      |- V2L v = FCP_HD v::if dimindex (:Œ≤) = 1 then [] else V2L (FCP_TL v)
   
   [<a name="bit0_11-val"><b>bit0_11</b></a>]  Theorem
      
      |- (‚àÄa a'. (BIT0A a = BIT0A a') ‚áî (a = a')) ‚àß
         ‚àÄa a'. (BIT0B a = BIT0B a') ‚áî (a = a')
   
   [<a name="bit0_Axiom-val"><b>bit0_Axiom</b></a>]  Theorem
      
      |- ‚àÄf0 f1. ‚àÉfn. (‚àÄa. fn (BIT0A a) = f0 a) ‚àß ‚àÄa. fn (BIT0B a) = f1 a
   
   [<a name="bit0_case_cong-val"><b>bit0_case_cong</b></a>]  Theorem
      
      |- ‚àÄM M' f f1.
           (M = M') ‚àß (‚àÄa. (M' = BIT0A a) ‚áí (f a = f' a)) ‚àß
           (‚àÄa. (M' = BIT0B a) ‚áí (f1 a = f1' a)) ‚áí
           (bit0_case f f1 M = bit0_case f' f1' M')
   
   [<a name="bit0_distinct-val"><b>bit0_distinct</b></a>]  Theorem
      
      |- ‚àÄa' a. BIT0A a ‚â† BIT0B a'
   
   [<a name="bit0_induction-val"><b>bit0_induction</b></a>]  Theorem
      
      |- ‚àÄP. (‚àÄa. P (BIT0A a)) ‚àß (‚àÄa. P (BIT0B a)) ‚áí ‚àÄb. P b
   
   [<a name="bit0_nchotomy-val"><b>bit0_nchotomy</b></a>]  Theorem
      
      |- ‚àÄbb. (‚àÉa. bb = BIT0A a) ‚à® ‚àÉa. bb = BIT0B a
   
   [<a name="bit1_11-val"><b>bit1_11</b></a>]  Theorem
      
      |- (‚àÄa a'. (BIT1A a = BIT1A a') ‚áî (a = a')) ‚àß
         ‚àÄa a'. (BIT1B a = BIT1B a') ‚áî (a = a')
   
   [<a name="bit1_Axiom-val"><b>bit1_Axiom</b></a>]  Theorem
      
      |- ‚àÄf0 f1 f2.
           ‚àÉfn.
             (‚àÄa. fn (BIT1A a) = f0 a) ‚àß (‚àÄa. fn (BIT1B a) = f1 a) ‚àß (fn BIT1C = f2)
   
   [<a name="bit1_case_cong-val"><b>bit1_case_cong</b></a>]  Theorem
      
      |- ‚àÄM M' f f1 v.
           (M = M') ‚àß (‚àÄa. (M' = BIT1A a) ‚áí (f a = f' a)) ‚àß
           (‚àÄa. (M' = BIT1B a) ‚áí (f1 a = f1' a)) ‚àß ((M' = BIT1C) ‚áí (v = v')) ‚áí
           (bit1_case f f1 v M = bit1_case f' f1' v' M')
   
   [<a name="bit1_distinct-val"><b>bit1_distinct</b></a>]  Theorem
      
      |- (‚àÄa' a. BIT1A a ‚â† BIT1B a') ‚àß (‚àÄa. BIT1A a ‚â† BIT1C) ‚àß ‚àÄa. BIT1B a ‚â† BIT1C
   
   [<a name="bit1_induction-val"><b>bit1_induction</b></a>]  Theorem
      
      |- ‚àÄP. (‚àÄa. P (BIT1A a)) ‚àß (‚àÄa. P (BIT1B a)) ‚àß P BIT1C ‚áí ‚àÄb. P b
   
   [<a name="bit1_nchotomy-val"><b>bit1_nchotomy</b></a>]  Theorem
      
      |- ‚àÄbb. (‚àÉa. bb = BIT1A a) ‚à® (‚àÉa. bb = BIT1B a) ‚à® (bb = BIT1C)
   
   [<a name="card_dimindex-val"><b>card_dimindex</b></a>]  Theorem
      
      |- FINITE ùïå(:Œ±) ‚áí (CARD ùïå(:Œ±) = dimindex (:Œ±))
   
   [<a name="datatype_bit0-val"><b>datatype_bit0</b></a>]  Theorem
      
      |- DATATYPE (bit0 BIT0A BIT0B)
   
   [<a name="datatype_bit1-val"><b>datatype_bit1</b></a>]  Theorem
      
      |- DATATYPE (bit1 BIT1A BIT1B BIT1C)
   
   [<a name="dimindex-val"><b>dimindex</b></a>]  Theorem
      
      |- dimindex (:Œ±) = if FINITE ùïå(:Œ±) then CARD ùïå(:Œ±) else 1
   
   [<a name="exists_v2l_thm-val"><b>exists_v2l_thm</b></a>]  Theorem
      
      |- ‚àÉx. (LENGTH x = dimindex (:Œ≤)) ‚àß ‚àÄi. i &lt; dimindex (:Œ≤) ‚áí (EL i x = v ' i)
   
   [<a name="fcp_Axiom-val"><b>fcp_Axiom</b></a>]  Theorem
      
      |- ‚àÄf. ‚àÉg. ‚àÄh. g (mk_cart h) = f h
   
   [<a name="fcp_ind-val"><b>fcp_ind</b></a>]  Theorem
      
      |- ‚àÄP. (‚àÄf. P (mk_cart f)) ‚áí ‚àÄa. P a
   
   [<a name="fcp_subst_comp-val"><b>fcp_subst_comp</b></a>]  Theorem
      
      |- ‚àÄa b f. (x :+ y) ($FCP f) = FCP c. if x = c then y else f c
   
   [<a name="finite_bit0-val"><b>finite_bit0</b></a>]  Theorem
      
      |- FINITE ùïå(:Œ± bit0) ‚áî FINITE ùïå(:Œ±)
   
   [<a name="finite_bit1-val"><b>finite_bit1</b></a>]  Theorem
      
      |- FINITE ùïå(:Œ± bit1) ‚áî FINITE ùïå(:Œ±)
   
   [<a name="finite_one-val"><b>finite_one</b></a>]  Theorem
      
      |- FINITE ùïå(:unit)
   
   [<a name="finite_sub1-val"><b>finite_sub1</b></a>]  Theorem
      
      |- FINITE ùïå(:Œ± sub1) ‚áî FINITE ùïå(:Œ±)
   
   [<a name="finite_sum-val"><b>finite_sum</b></a>]  Theorem
      
      |- FINITE ùïå(:Œ± + Œ≤) ‚áî FINITE ùïå(:Œ±) ‚àß FINITE ùïå(:Œ≤)
   
   [<a name="index_bit0-val"><b>index_bit0</b></a>]  Theorem
      
      |- dimindex (:Œ± bit0) = if FINITE ùïå(:Œ±) then 2 * dimindex (:Œ±) else 1
   
   [<a name="index_bit1-val"><b>index_bit1</b></a>]  Theorem
      
      |- dimindex (:Œ± bit1) = if FINITE ùïå(:Œ±) then 2 * dimindex (:Œ±) + 1 else 1
   
   [<a name="index_comp-val"><b>index_comp</b></a>]  Theorem
      
      |- ‚àÄf n.
           $FCP f ' n =
           if n &lt; dimindex (:Œ≤) then f n else FAIL $' FCP out of bounds ($FCP f) n
   
   [<a name="index_one-val"><b>index_one</b></a>]  Theorem
      
      |- dimindex (:unit) = 1
   
   [<a name="index_sum-val"><b>index_sum</b></a>]  Theorem
      
      |- dimindex (:Œ± + Œ≤) =
         if FINITE ùïå(:Œ±) ‚àß FINITE ùïå(:Œ≤) then dimindex (:Œ±) + dimindex (:Œ≤) else 1
   
   [<a name="sub1_ABS_REP_CLASS-val"><b>sub1_ABS_REP_CLASS</b></a>]  Theorem
      
      |- (‚àÄa. abs_sub1_CLASS (rep_sub1_CLASS a) = a) ‚àß
         ‚àÄc.
           (‚àÉr. sub_equiv r r ‚àß (c = sub_equiv r)) ‚áî
           (rep_sub1_CLASS (abs_sub1_CLASS c) = c)
   
   [<a name="sub1_QUOTIENT-val"><b>sub1_QUOTIENT</b></a>]  Theorem
      
      |- QUOTIENT sub_equiv abs_sub1 rep_sub1
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/n-bit/fcpScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-6</a></em></p></body></html>
