<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure boolTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure boolTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/bool/boolScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature boolTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Axioms  *)
<a name="line6"></a>    val <a href="#BOOL_CASES_AX-val">BOOL_CASES_AX</a> : thm
<a name="line7"></a>    val <a href="#ETA_AX-val">ETA_AX</a> : thm
<a name="line8"></a>    val <a href="#INFINITY_AX-val">INFINITY_AX</a> : thm
<a name="line9"></a>    val <a href="#SELECT_AX-val">SELECT_AX</a> : thm
<a name="line10"></a>  
<a name="line11"></a>  (*  Definitions  *)
<a name="line12"></a>    val <a href="#AND_DEF-val">AND_DEF</a> : thm
<a name="line13"></a>    val <a href="#BOUNDED_DEF-val">BOUNDED_DEF</a> : thm
<a name="line14"></a>    val <a href="#COND_DEF-val">COND_DEF</a> : thm
<a name="line15"></a>    val <a href="#DATATYPE_TAG_DEF-val">DATATYPE_TAG_DEF</a> : thm
<a name="line16"></a>    val <a href="#EXISTS_DEF-val">EXISTS_DEF</a> : thm
<a name="line17"></a>    val <a href="#EXISTS_UNIQUE_DEF-val">EXISTS_UNIQUE_DEF</a> : thm
<a name="line18"></a>    val <a href="#FORALL_DEF-val">FORALL_DEF</a> : thm
<a name="line19"></a>    val <a href="#F_DEF-val">F_DEF</a> : thm
<a name="line20"></a>    val <a href="#IN_DEF-val">IN_DEF</a> : thm
<a name="line21"></a>    val <a href="#LET_DEF-val">LET_DEF</a> : thm
<a name="line22"></a>    val <a href="#NOT_DEF-val">NOT_DEF</a> : thm
<a name="line23"></a>    val <a href="#ONE_ONE_DEF-val">ONE_ONE_DEF</a> : thm
<a name="line24"></a>    val <a href="#ONTO_DEF-val">ONTO_DEF</a> : thm
<a name="line25"></a>    val <a href="#OR_DEF-val">OR_DEF</a> : thm
<a name="line26"></a>    val <a href="#RES_ABSTRACT_DEF-val">RES_ABSTRACT_DEF</a> : thm
<a name="line27"></a>    val <a href="#RES_EXISTS_DEF-val">RES_EXISTS_DEF</a> : thm
<a name="line28"></a>    val <a href="#RES_EXISTS_UNIQUE_DEF-val">RES_EXISTS_UNIQUE_DEF</a> : thm
<a name="line29"></a>    val <a href="#RES_FORALL_DEF-val">RES_FORALL_DEF</a> : thm
<a name="line30"></a>    val <a href="#RES_SELECT_DEF-val">RES_SELECT_DEF</a> : thm
<a name="line31"></a>    val <a href="#TYPE_DEFINITION-val">TYPE_DEFINITION</a> : thm
<a name="line32"></a>    val <a href="#T_DEF-val">T_DEF</a> : thm
<a name="line33"></a>    val <a href="#bool_case_DEF-val">bool_case_DEF</a> : thm
<a name="line34"></a>    val <a href="#itself_TY_DEF-val">itself_TY_DEF</a> : thm
<a name="line35"></a>    val <a href="#itself_case_thm-val">itself_case_thm</a> : thm
<a name="line36"></a>    val <a href="#literal_case_DEF-val">literal_case_DEF</a> : thm
<a name="line37"></a>  
<a name="line38"></a>  (*  Theorems  *)
<a name="line39"></a>    val <a href="#ABS_REP_THM-val">ABS_REP_THM</a> : thm
<a name="line40"></a>    val <a href="#ABS_SIMP-val">ABS_SIMP</a> : thm
<a name="line41"></a>    val <a href="#AND1_THM-val">AND1_THM</a> : thm
<a name="line42"></a>    val <a href="#AND2_THM-val">AND2_THM</a> : thm
<a name="line43"></a>    val <a href="#AND_CLAUSES-val">AND_CLAUSES</a> : thm
<a name="line44"></a>    val <a href="#AND_CONG-val">AND_CONG</a> : thm
<a name="line45"></a>    val <a href="#AND_IMP_INTRO-val">AND_IMP_INTRO</a> : thm
<a name="line46"></a>    val <a href="#AND_INTRO_THM-val">AND_INTRO_THM</a> : thm
<a name="line47"></a>    val <a href="#BETA_THM-val">BETA_THM</a> : thm
<a name="line48"></a>    val <a href="#BOOL_EQ_DISTINCT-val">BOOL_EQ_DISTINCT</a> : thm
<a name="line49"></a>    val <a href="#BOOL_FUN_CASES_THM-val">BOOL_FUN_CASES_THM</a> : thm
<a name="line50"></a>    val <a href="#BOOL_FUN_INDUCT-val">BOOL_FUN_INDUCT</a> : thm
<a name="line51"></a>    val <a href="#BOTH_EXISTS_AND_THM-val">BOTH_EXISTS_AND_THM</a> : thm
<a name="line52"></a>    val <a href="#BOTH_EXISTS_IMP_THM-val">BOTH_EXISTS_IMP_THM</a> : thm
<a name="line53"></a>    val <a href="#BOTH_FORALL_IMP_THM-val">BOTH_FORALL_IMP_THM</a> : thm
<a name="line54"></a>    val <a href="#BOTH_FORALL_OR_THM-val">BOTH_FORALL_OR_THM</a> : thm
<a name="line55"></a>    val <a href="#BOUNDED_THM-val">BOUNDED_THM</a> : thm
<a name="line56"></a>    val <a href="#COND_ABS-val">COND_ABS</a> : thm
<a name="line57"></a>    val <a href="#COND_CLAUSES-val">COND_CLAUSES</a> : thm
<a name="line58"></a>    val <a href="#COND_CONG-val">COND_CONG</a> : thm
<a name="line59"></a>    val <a href="#COND_EXPAND-val">COND_EXPAND</a> : thm
<a name="line60"></a>    val <a href="#COND_EXPAND_IMP-val">COND_EXPAND_IMP</a> : thm
<a name="line61"></a>    val <a href="#COND_EXPAND_OR-val">COND_EXPAND_OR</a> : thm
<a name="line62"></a>    val <a href="#COND_ID-val">COND_ID</a> : thm
<a name="line63"></a>    val <a href="#COND_RAND-val">COND_RAND</a> : thm
<a name="line64"></a>    val <a href="#COND_RATOR-val">COND_RATOR</a> : thm
<a name="line65"></a>    val <a href="#CONJ_ASSOC-val">CONJ_ASSOC</a> : thm
<a name="line66"></a>    val <a href="#CONJ_COMM-val">CONJ_COMM</a> : thm
<a name="line67"></a>    val <a href="#CONJ_SYM-val">CONJ_SYM</a> : thm
<a name="line68"></a>    val <a href="#DATATYPE_BOOL-val">DATATYPE_BOOL</a> : thm
<a name="line69"></a>    val <a href="#DATATYPE_TAG_THM-val">DATATYPE_TAG_THM</a> : thm
<a name="line70"></a>    val <a href="#DE_MORGAN_THM-val">DE_MORGAN_THM</a> : thm
<a name="line71"></a>    val <a href="#DISJ_ASSOC-val">DISJ_ASSOC</a> : thm
<a name="line72"></a>    val <a href="#DISJ_COMM-val">DISJ_COMM</a> : thm
<a name="line73"></a>    val <a href="#DISJ_IMP_THM-val">DISJ_IMP_THM</a> : thm
<a name="line74"></a>    val <a href="#DISJ_SYM-val">DISJ_SYM</a> : thm
<a name="line75"></a>    val <a href="#EQ_CLAUSES-val">EQ_CLAUSES</a> : thm
<a name="line76"></a>    val <a href="#EQ_EXPAND-val">EQ_EXPAND</a> : thm
<a name="line77"></a>    val <a href="#EQ_EXT-val">EQ_EXT</a> : thm
<a name="line78"></a>    val <a href="#EQ_IMP_THM-val">EQ_IMP_THM</a> : thm
<a name="line79"></a>    val <a href="#EQ_REFL-val">EQ_REFL</a> : thm
<a name="line80"></a>    val <a href="#EQ_SYM-val">EQ_SYM</a> : thm
<a name="line81"></a>    val <a href="#EQ_SYM_EQ-val">EQ_SYM_EQ</a> : thm
<a name="line82"></a>    val <a href="#EQ_TRANS-val">EQ_TRANS</a> : thm
<a name="line83"></a>    val <a href="#ETA_THM-val">ETA_THM</a> : thm
<a name="line84"></a>    val <a href="#EXCLUDED_MIDDLE-val">EXCLUDED_MIDDLE</a> : thm
<a name="line85"></a>    val <a href="#EXISTS_OR_THM-val">EXISTS_OR_THM</a> : thm
<a name="line86"></a>    val <a href="#EXISTS_REFL-val">EXISTS_REFL</a> : thm
<a name="line87"></a>    val <a href="#EXISTS_SIMP-val">EXISTS_SIMP</a> : thm
<a name="line88"></a>    val <a href="#EXISTS_THM-val">EXISTS_THM</a> : thm
<a name="line89"></a>    val <a href="#EXISTS_UNIQUE_REFL-val">EXISTS_UNIQUE_REFL</a> : thm
<a name="line90"></a>    val <a href="#EXISTS_UNIQUE_THM-val">EXISTS_UNIQUE_THM</a> : thm
<a name="line91"></a>    val <a href="#FALSITY-val">FALSITY</a> : thm
<a name="line92"></a>    val <a href="#FORALL_AND_THM-val">FORALL_AND_THM</a> : thm
<a name="line93"></a>    val <a href="#FORALL_BOOL-val">FORALL_BOOL</a> : thm
<a name="line94"></a>    val <a href="#FORALL_SIMP-val">FORALL_SIMP</a> : thm
<a name="line95"></a>    val <a href="#FORALL_THM-val">FORALL_THM</a> : thm
<a name="line96"></a>    val <a href="#FUN_EQ_THM-val">FUN_EQ_THM</a> : thm
<a name="line97"></a>    val <a href="#F_IMP-val">F_IMP</a> : thm
<a name="line98"></a>    val <a href="#IMP_ANTISYM_AX-val">IMP_ANTISYM_AX</a> : thm
<a name="line99"></a>    val <a href="#IMP_CLAUSES-val">IMP_CLAUSES</a> : thm
<a name="line100"></a>    val <a href="#IMP_CONG-val">IMP_CONG</a> : thm
<a name="line101"></a>    val <a href="#IMP_CONJ_THM-val">IMP_CONJ_THM</a> : thm
<a name="line102"></a>    val <a href="#IMP_DISJ_THM-val">IMP_DISJ_THM</a> : thm
<a name="line103"></a>    val <a href="#IMP_F-val">IMP_F</a> : thm
<a name="line104"></a>    val <a href="#IMP_F_EQ_F-val">IMP_F_EQ_F</a> : thm
<a name="line105"></a>    val <a href="#ITSELF_UNIQUE-val">ITSELF_UNIQUE</a> : thm
<a name="line106"></a>    val <a href="#JRH_INDUCT_UTIL-val">JRH_INDUCT_UTIL</a> : thm
<a name="line107"></a>    val <a href="#LCOMM_THM-val">LCOMM_THM</a> : thm
<a name="line108"></a>    val <a href="#LEFT_AND_CONG-val">LEFT_AND_CONG</a> : thm
<a name="line109"></a>    val <a href="#LEFT_AND_FORALL_THM-val">LEFT_AND_FORALL_THM</a> : thm
<a name="line110"></a>    val <a href="#LEFT_AND_OVER_OR-val">LEFT_AND_OVER_OR</a> : thm
<a name="line111"></a>    val <a href="#LEFT_EXISTS_AND_THM-val">LEFT_EXISTS_AND_THM</a> : thm
<a name="line112"></a>    val <a href="#LEFT_EXISTS_IMP_THM-val">LEFT_EXISTS_IMP_THM</a> : thm
<a name="line113"></a>    val <a href="#LEFT_FORALL_IMP_THM-val">LEFT_FORALL_IMP_THM</a> : thm
<a name="line114"></a>    val <a href="#LEFT_FORALL_OR_THM-val">LEFT_FORALL_OR_THM</a> : thm
<a name="line115"></a>    val <a href="#LEFT_OR_CONG-val">LEFT_OR_CONG</a> : thm
<a name="line116"></a>    val <a href="#LEFT_OR_EXISTS_THM-val">LEFT_OR_EXISTS_THM</a> : thm
<a name="line117"></a>    val <a href="#LEFT_OR_OVER_AND-val">LEFT_OR_OVER_AND</a> : thm
<a name="line118"></a>    val <a href="#LET_CONG-val">LET_CONG</a> : thm
<a name="line119"></a>    val <a href="#LET_RAND-val">LET_RAND</a> : thm
<a name="line120"></a>    val <a href="#LET_RATOR-val">LET_RATOR</a> : thm
<a name="line121"></a>    val <a href="#LET_THM-val">LET_THM</a> : thm
<a name="line122"></a>    val <a href="#MONO_ALL-val">MONO_ALL</a> : thm
<a name="line123"></a>    val <a href="#MONO_AND-val">MONO_AND</a> : thm
<a name="line124"></a>    val <a href="#MONO_COND-val">MONO_COND</a> : thm
<a name="line125"></a>    val <a href="#MONO_EXISTS-val">MONO_EXISTS</a> : thm
<a name="line126"></a>    val <a href="#MONO_IMP-val">MONO_IMP</a> : thm
<a name="line127"></a>    val <a href="#MONO_NOT-val">MONO_NOT</a> : thm
<a name="line128"></a>    val <a href="#MONO_NOT_EQ-val">MONO_NOT_EQ</a> : thm
<a name="line129"></a>    val <a href="#MONO_OR-val">MONO_OR</a> : thm
<a name="line130"></a>    val <a href="#NOT_AND-val">NOT_AND</a> : thm
<a name="line131"></a>    val <a href="#NOT_CLAUSES-val">NOT_CLAUSES</a> : thm
<a name="line132"></a>    val <a href="#NOT_EXISTS_THM-val">NOT_EXISTS_THM</a> : thm
<a name="line133"></a>    val <a href="#NOT_F-val">NOT_F</a> : thm
<a name="line134"></a>    val <a href="#NOT_FORALL_THM-val">NOT_FORALL_THM</a> : thm
<a name="line135"></a>    val <a href="#NOT_IMP-val">NOT_IMP</a> : thm
<a name="line136"></a>    val <a href="#ONE_ONE_THM-val">ONE_ONE_THM</a> : thm
<a name="line137"></a>    val <a href="#ONTO_THM-val">ONTO_THM</a> : thm
<a name="line138"></a>    val <a href="#OR_CLAUSES-val">OR_CLAUSES</a> : thm
<a name="line139"></a>    val <a href="#OR_CONG-val">OR_CONG</a> : thm
<a name="line140"></a>    val <a href="#OR_ELIM_THM-val">OR_ELIM_THM</a> : thm
<a name="line141"></a>    val <a href="#OR_IMP_THM-val">OR_IMP_THM</a> : thm
<a name="line142"></a>    val <a href="#OR_INTRO_THM1-val">OR_INTRO_THM1</a> : thm
<a name="line143"></a>    val <a href="#OR_INTRO_THM2-val">OR_INTRO_THM2</a> : thm
<a name="line144"></a>    val <a href="#PEIRCE-val">PEIRCE</a> : thm
<a name="line145"></a>    val <a href="#REFL_CLAUSE-val">REFL_CLAUSE</a> : thm
<a name="line146"></a>    val <a href="#RES_EXISTS_CONG-val">RES_EXISTS_CONG</a> : thm
<a name="line147"></a>    val <a href="#RES_EXISTS_FALSE-val">RES_EXISTS_FALSE</a> : thm
<a name="line148"></a>    val <a href="#RES_EXISTS_THM-val">RES_EXISTS_THM</a> : thm
<a name="line149"></a>    val <a href="#RES_EXISTS_UNIQUE_THM-val">RES_EXISTS_UNIQUE_THM</a> : thm
<a name="line150"></a>    val <a href="#RES_FORALL_CONG-val">RES_FORALL_CONG</a> : thm
<a name="line151"></a>    val <a href="#RES_FORALL_THM-val">RES_FORALL_THM</a> : thm
<a name="line152"></a>    val <a href="#RES_FORALL_TRUE-val">RES_FORALL_TRUE</a> : thm
<a name="line153"></a>    val <a href="#RES_SELECT_THM-val">RES_SELECT_THM</a> : thm
<a name="line154"></a>    val <a href="#RIGHT_AND_FORALL_THM-val">RIGHT_AND_FORALL_THM</a> : thm
<a name="line155"></a>    val <a href="#RIGHT_AND_OVER_OR-val">RIGHT_AND_OVER_OR</a> : thm
<a name="line156"></a>    val <a href="#RIGHT_EXISTS_AND_THM-val">RIGHT_EXISTS_AND_THM</a> : thm
<a name="line157"></a>    val <a href="#RIGHT_EXISTS_IMP_THM-val">RIGHT_EXISTS_IMP_THM</a> : thm
<a name="line158"></a>    val <a href="#RIGHT_FORALL_IMP_THM-val">RIGHT_FORALL_IMP_THM</a> : thm
<a name="line159"></a>    val <a href="#RIGHT_FORALL_OR_THM-val">RIGHT_FORALL_OR_THM</a> : thm
<a name="line160"></a>    val <a href="#RIGHT_OR_EXISTS_THM-val">RIGHT_OR_EXISTS_THM</a> : thm
<a name="line161"></a>    val <a href="#RIGHT_OR_OVER_AND-val">RIGHT_OR_OVER_AND</a> : thm
<a name="line162"></a>    val <a href="#SELECT_ELIM_THM-val">SELECT_ELIM_THM</a> : thm
<a name="line163"></a>    val <a href="#SELECT_REFL-val">SELECT_REFL</a> : thm
<a name="line164"></a>    val <a href="#SELECT_REFL_2-val">SELECT_REFL_2</a> : thm
<a name="line165"></a>    val <a href="#SELECT_THM-val">SELECT_THM</a> : thm
<a name="line166"></a>    val <a href="#SELECT_UNIQUE-val">SELECT_UNIQUE</a> : thm
<a name="line167"></a>    val <a href="#SKOLEM_THM-val">SKOLEM_THM</a> : thm
<a name="line168"></a>    val <a href="#SWAP_EXISTS_THM-val">SWAP_EXISTS_THM</a> : thm
<a name="line169"></a>    val <a href="#SWAP_FORALL_THM-val">SWAP_FORALL_THM</a> : thm
<a name="line170"></a>    val <a href="#TRUTH-val">TRUTH</a> : thm
<a name="line171"></a>    val <a href="#TYPE_DEFINITION_THM-val">TYPE_DEFINITION_THM</a> : thm
<a name="line172"></a>    val <a href="#UEXISTS_OR_THM-val">UEXISTS_OR_THM</a> : thm
<a name="line173"></a>    val <a href="#UEXISTS_SIMP-val">UEXISTS_SIMP</a> : thm
<a name="line174"></a>    val <a href="#UNWIND_FORALL_THM1-val">UNWIND_FORALL_THM1</a> : thm
<a name="line175"></a>    val <a href="#UNWIND_FORALL_THM2-val">UNWIND_FORALL_THM2</a> : thm
<a name="line176"></a>    val <a href="#UNWIND_THM1-val">UNWIND_THM1</a> : thm
<a name="line177"></a>    val <a href="#UNWIND_THM2-val">UNWIND_THM2</a> : thm
<a name="line178"></a>    val <a href="#boolAxiom-val">boolAxiom</a> : thm
<a name="line179"></a>    val <a href="#bool_INDUCT-val">bool_INDUCT</a> : thm
<a name="line180"></a>    val <a href="#bool_case_CONG-val">bool_case_CONG</a> : thm
<a name="line181"></a>    val <a href="#bool_case_EQ_COND-val">bool_case_EQ_COND</a> : thm
<a name="line182"></a>    val <a href="#bool_case_ID-val">bool_case_ID</a> : thm
<a name="line183"></a>    val <a href="#bool_case_thm-val">bool_case_thm</a> : thm
<a name="line184"></a>    val <a href="#itself_Axiom-val">itself_Axiom</a> : thm
<a name="line185"></a>    val <a href="#itself_induction-val">itself_induction</a> : thm
<a name="line186"></a>    val <a href="#literal_case_CONG-val">literal_case_CONG</a> : thm
<a name="line187"></a>    val <a href="#literal_case_RAND-val">literal_case_RAND</a> : thm
<a name="line188"></a>    val <a href="#literal_case_RATOR-val">literal_case_RATOR</a> : thm
<a name="line189"></a>    val <a href="#literal_case_THM-val">literal_case_THM</a> : thm
<a name="line190"></a>    val <a href="#literal_case_id-val">literal_case_id</a> : thm
<a name="line191"></a>  
<a name="line192"></a>  val bool_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line193"></a>(*
   [min] Parent theory of "bool"
   
   [<a name="BOOL_CASES_AX-val"><b>BOOL_CASES_AX</b></a>]  Axiom
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀t. (t ⇔ T) ∨ (t ⇔ F)
   
   [<a name="ETA_AX-val"><b>ETA_AX</b></a>]  Axiom
      
      [oracles: ] [axioms: ETA_AX] [] |- ∀t. (λx. t x) = t
   
   [<a name="INFINITY_AX-val"><b>INFINITY_AX</b></a>]  Axiom
      
      [oracles: ] [axioms: INFINITY_AX] [] |- ∃f. ONE_ONE f ∧ ¬ONTO f
   
   [<a name="SELECT_AX-val"><b>SELECT_AX</b></a>]  Axiom
      
      [oracles: ] [axioms: SELECT_AX] [] |- ∀P x. P x ⇒ P ($@ P)
   
   [<a name="AND_DEF-val"><b>AND_DEF</b></a>]  Definition
      
      |- $/\ = (λt1 t2. ∀t. (t1 ⇒ t2 ⇒ t) ⇒ t)
   
   [<a name="BOUNDED_DEF-val"><b>BOUNDED_DEF</b></a>]  Definition
      
      |- BOUNDED = (λv. T)
   
   [<a name="COND_DEF-val"><b>COND_DEF</b></a>]  Definition
      
      |- COND = (λt t1 t2. @x. ((t ⇔ T) ⇒ (x = t1)) ∧ ((t ⇔ F) ⇒ (x = t2)))
   
   [<a name="DATATYPE_TAG_DEF-val"><b>DATATYPE_TAG_DEF</b></a>]  Definition
      
      |- DATATYPE = (λx. T)
   
   [<a name="EXISTS_DEF-val"><b>EXISTS_DEF</b></a>]  Definition
      
      |- $? = (λP. P ($@ P))
   
   [<a name="EXISTS_UNIQUE_DEF-val"><b>EXISTS_UNIQUE_DEF</b></a>]  Definition
      
      |- $?! = (λP. $? P ∧ ∀x y. P x ∧ P y ⇒ (x = y))
   
   [<a name="FORALL_DEF-val"><b>FORALL_DEF</b></a>]  Definition
      
      |- $! = (λP. P = (λx. T))
   
   [<a name="F_DEF-val"><b>F_DEF</b></a>]  Definition
      
      |- F ⇔ ∀t. t
   
   [<a name="IN_DEF-val"><b>IN_DEF</b></a>]  Definition
      
      |- $IN = (λx f. f x)
   
   [<a name="LET_DEF-val"><b>LET_DEF</b></a>]  Definition
      
      |- LET = (λf x. f x)
   
   [<a name="NOT_DEF-val"><b>NOT_DEF</b></a>]  Definition
      
      |- $~ = (λt. t ⇒ F)
   
   [<a name="ONE_ONE_DEF-val"><b>ONE_ONE_DEF</b></a>]  Definition
      
      |- ONE_ONE = (λf. ∀x1 x2. (f x1 = f x2) ⇒ (x1 = x2))
   
   [<a name="ONTO_DEF-val"><b>ONTO_DEF</b></a>]  Definition
      
      |- ONTO = (λf. ∀y. ∃x. y = f x)
   
   [<a name="OR_DEF-val"><b>OR_DEF</b></a>]  Definition
      
      |- $\/ = (λt1 t2. ∀t. (t1 ⇒ t) ⇒ (t2 ⇒ t) ⇒ t)
   
   [<a name="RES_ABSTRACT_DEF-val"><b>RES_ABSTRACT_DEF</b></a>]  Definition
      
      [oracles: ] [axioms: ETA_AX, BOOL_CASES_AX, SELECT_AX] []
      |- (∀p m x. x ∈ p ⇒ (RES_ABSTRACT p m x = m x)) ∧
         ∀p m1 m2.
           (∀x. x ∈ p ⇒ (m1 x = m2 x)) ⇒ (RES_ABSTRACT p m1 = RES_ABSTRACT p m2)
   
   [<a name="RES_EXISTS_DEF-val"><b>RES_EXISTS_DEF</b></a>]  Definition
      
      |- RES_EXISTS = (λp m. ∃x. x ∈ p ∧ m x)
   
   [<a name="RES_EXISTS_UNIQUE_DEF-val"><b>RES_EXISTS_UNIQUE_DEF</b></a>]  Definition
      
      |- RES_EXISTS_UNIQUE = (λp m. (∃x::p. m x) ∧ ∀x y::p. m x ∧ m y ⇒ (x = y))
   
   [<a name="RES_FORALL_DEF-val"><b>RES_FORALL_DEF</b></a>]  Definition
      
      |- RES_FORALL = (λp m. ∀x. x ∈ p ⇒ m x)
   
   [<a name="RES_SELECT_DEF-val"><b>RES_SELECT_DEF</b></a>]  Definition
      
      |- RES_SELECT = (λp m. @x. x ∈ p ∧ m x)
   
   [<a name="TYPE_DEFINITION-val"><b>TYPE_DEFINITION</b></a>]  Definition
      
      |- TYPE_DEFINITION =
         (λP rep.
            (∀x' x''. (rep x' = rep x'') ⇒ (x' = x'')) ∧ ∀x. P x ⇔ ∃x'. x = rep x')
   
   [<a name="T_DEF-val"><b>T_DEF</b></a>]  Definition
      
      |- T ⇔ ((λx. x) = (λx. x))
   
   [<a name="bool_case_DEF-val"><b>bool_case_DEF</b></a>]  Definition
      
      |- bool_case = (λx y b. if b then x else y)
   
   [<a name="itself_TY_DEF-val"><b>itself_TY_DEF</b></a>]  Definition
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∃rep. TYPE_DEFINITION ($= ARB) rep
   
   [<a name="itself_case_thm-val"><b>itself_case_thm</b></a>]  Definition
      
      |- ∀b. itself_case b (:α) = b
   
   [<a name="literal_case_DEF-val"><b>literal_case_DEF</b></a>]  Definition
      
      |- literal_case = (λf x. f x)
   
   [<a name="ABS_REP_THM-val"><b>ABS_REP_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] []
      |- ∀P.
           (∃rep. TYPE_DEFINITION P rep) ⇒
           ∃rep abs. (∀a. abs (rep a) = a) ∧ ∀r. P r ⇔ (rep (abs r) = r)
   
   [<a name="ABS_SIMP-val"><b>ABS_SIMP</b></a>]  Theorem
      
      |- ∀t1 t2. (λx. t1) t2 = t1
   
   [<a name="AND1_THM-val"><b>AND1_THM</b></a>]  Theorem
      
      |- ∀t1 t2. t1 ∧ t2 ⇒ t1
   
   [<a name="AND2_THM-val"><b>AND2_THM</b></a>]  Theorem
      
      |- ∀t1 t2. t1 ∧ t2 ⇒ t2
   
   [<a name="AND_CLAUSES-val"><b>AND_CLAUSES</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- ∀t. (T ∧ t ⇔ t) ∧ (t ∧ T ⇔ t) ∧ (F ∧ t ⇔ F) ∧ (t ∧ F ⇔ F) ∧ (t ∧ t ⇔ t)
   
   [<a name="AND_CONG-val"><b>AND_CONG</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- ∀P P' Q Q'. (Q ⇒ (P ⇔ P')) ∧ (P' ⇒ (Q ⇔ Q')) ⇒ (P ∧ Q ⇔ P' ∧ Q')
   
   [<a name="AND_IMP_INTRO-val"><b>AND_IMP_INTRO</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- ∀t1 t2 t3. t1 ⇒ t2 ⇒ t3 ⇔ t1 ∧ t2 ⇒ t3
   
   [<a name="AND_INTRO_THM-val"><b>AND_INTRO_THM</b></a>]  Theorem
      
      |- ∀t1 t2. t1 ⇒ t2 ⇒ t1 ∧ t2
   
   [<a name="BETA_THM-val"><b>BETA_THM</b></a>]  Theorem
      
      |- ∀f y. (λx. f x) y = f y
   
   [<a name="BOOL_EQ_DISTINCT-val"><b>BOOL_EQ_DISTINCT</b></a>]  Theorem
      
      |- (T ⇎ F) ∧ (F ⇎ T)
   
   [<a name="BOOL_FUN_CASES_THM-val"><b>BOOL_FUN_CASES_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, ETA_AX] []
      |- ∀f. (f = (λb. T)) ∨ (f = (λb. F)) ∨ (f = (λb. b)) ∨ (f = (λb. ¬b))
   
   [<a name="BOOL_FUN_INDUCT-val"><b>BOOL_FUN_INDUCT</b></a>]  Theorem
      
      [oracles: ] [axioms: ETA_AX, BOOL_CASES_AX] []
      |- ∀P. P (λb. T) ∧ P (λb. F) ∧ P (λb. b) ∧ P (λb. ¬b) ⇒ ∀f. P f
   
   [<a name="BOTH_EXISTS_AND_THM-val"><b>BOTH_EXISTS_AND_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀P Q. (∃x. P ∧ Q) ⇔ (∃x. P) ∧ ∃x. Q
   
   [<a name="BOTH_EXISTS_IMP_THM-val"><b>BOTH_EXISTS_IMP_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀P Q. (∃x. P ⇒ Q) ⇔ (∀x. P) ⇒ ∃x. Q
   
   [<a name="BOTH_FORALL_IMP_THM-val"><b>BOTH_FORALL_IMP_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀P Q. (∀x. P ⇒ Q) ⇔ (∃x. P) ⇒ ∀x. Q
   
   [<a name="BOTH_FORALL_OR_THM-val"><b>BOTH_FORALL_OR_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀P Q. (∀x. P ∨ Q) ⇔ (∀x. P) ∨ ∀x. Q
   
   [<a name="BOUNDED_THM-val"><b>BOUNDED_THM</b></a>]  Theorem
      
      |- ∀v. BOUNDED v ⇔ T
   
   [<a name="COND_ABS-val"><b>COND_ABS</b></a>]  Theorem
      
      [oracles: ] [axioms: SELECT_AX, BOOL_CASES_AX, ETA_AX] []
      |- ∀b f g. (λx. if b then f x else g x) = if b then f else g
   
   [<a name="COND_CLAUSES-val"><b>COND_CLAUSES</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] []
      |- ∀t1 t2. ((if T then t1 else t2) = t1) ∧ ((if F then t1 else t2) = t2)
   
   [<a name="COND_CONG-val"><b>COND_CONG</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] []
      |- ∀P Q x x' y y'.
           (P ⇔ Q) ∧ (Q ⇒ (x = x')) ∧ (¬Q ⇒ (y = y')) ⇒
           ((if P then x else y) = if Q then x' else y')
   
   [<a name="COND_EXPAND-val"><b>COND_EXPAND</b></a>]  Theorem
      
      [oracles: ] [axioms: SELECT_AX, BOOL_CASES_AX] []
      |- ∀b t1 t2. (if b then t1 else t2) ⇔ (¬b ∨ t1) ∧ (b ∨ t2)
   
   [<a name="COND_EXPAND_IMP-val"><b>COND_EXPAND_IMP</b></a>]  Theorem
      
      [oracles: ] [axioms: SELECT_AX, BOOL_CASES_AX] []
      |- ∀b t1 t2. (if b then t1 else t2) ⇔ (b ⇒ t1) ∧ (¬b ⇒ t2)
   
   [<a name="COND_EXPAND_OR-val"><b>COND_EXPAND_OR</b></a>]  Theorem
      
      [oracles: ] [axioms: SELECT_AX, BOOL_CASES_AX] []
      |- ∀b t1 t2. (if b then t1 else t2) ⇔ b ∧ t1 ∨ ¬b ∧ t2
   
   [<a name="COND_ID-val"><b>COND_ID</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] []
      |- ∀b t. (if b then t else t) = t
   
   [<a name="COND_RAND-val"><b>COND_RAND</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] []
      |- ∀f b x y. f (if b then x else y) = if b then f x else f y
   
   [<a name="COND_RATOR-val"><b>COND_RATOR</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] []
      |- ∀b f g x. (if b then f else g) x = if b then f x else g x
   
   [<a name="CONJ_ASSOC-val"><b>CONJ_ASSOC</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- ∀t1 t2 t3. t1 ∧ t2 ∧ t3 ⇔ (t1 ∧ t2) ∧ t3
   
   [<a name="CONJ_COMM-val"><b>CONJ_COMM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀t1 t2. t1 ∧ t2 ⇔ t2 ∧ t1
   
   [<a name="CONJ_SYM-val"><b>CONJ_SYM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀t1 t2. t1 ∧ t2 ⇔ t2 ∧ t1
   
   [<a name="DATATYPE_BOOL-val"><b>DATATYPE_BOOL</b></a>]  Theorem
      
      |- DATATYPE (bool T F) ⇔ T
   
   [<a name="DATATYPE_TAG_THM-val"><b>DATATYPE_TAG_THM</b></a>]  Theorem
      
      |- ∀x. DATATYPE x ⇔ T
   
   [<a name="DE_MORGAN_THM-val"><b>DE_MORGAN_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- ∀A B. (¬(A ∧ B) ⇔ ¬A ∨ ¬B) ∧ (¬(A ∨ B) ⇔ ¬A ∧ ¬B)
   
   [<a name="DISJ_ASSOC-val"><b>DISJ_ASSOC</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀A B C. A ∨ B ∨ C ⇔ (A ∨ B) ∨ C
   
   [<a name="DISJ_COMM-val"><b>DISJ_COMM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀A B. A ∨ B ⇔ B ∨ A
   
   [<a name="DISJ_IMP_THM-val"><b>DISJ_IMP_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀P Q R. P ∨ Q ⇒ R ⇔ (P ⇒ R) ∧ (Q ⇒ R)
   
   [<a name="DISJ_SYM-val"><b>DISJ_SYM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀A B. A ∨ B ⇔ B ∨ A
   
   [<a name="EQ_CLAUSES-val"><b>EQ_CLAUSES</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- ∀t. ((T ⇔ t) ⇔ t) ∧ ((t ⇔ T) ⇔ t) ∧ ((F ⇔ t) ⇔ ¬t) ∧ ((t ⇔ F) ⇔ ¬t)
   
   [<a name="EQ_EXPAND-val"><b>EQ_EXPAND</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- ∀t1 t2. (t1 ⇔ t2) ⇔ t1 ∧ t2 ∨ ¬t1 ∧ ¬t2
   
   [<a name="EQ_EXT-val"><b>EQ_EXT</b></a>]  Theorem
      
      [oracles: ] [axioms: ETA_AX] [] |- ∀f g. (∀x. f x = g x) ⇒ (f = g)
   
   [<a name="EQ_IMP_THM-val"><b>EQ_IMP_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- ∀t1 t2. (t1 ⇔ t2) ⇔ (t1 ⇒ t2) ∧ (t2 ⇒ t1)
   
   [<a name="EQ_REFL-val"><b>EQ_REFL</b></a>]  Theorem
      
      |- ∀x. x = x
   
   [<a name="EQ_SYM-val"><b>EQ_SYM</b></a>]  Theorem
      
      |- ∀x y. (x = y) ⇒ (y = x)
   
   [<a name="EQ_SYM_EQ-val"><b>EQ_SYM_EQ</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀x y. (x = y) ⇔ (y = x)
   
   [<a name="EQ_TRANS-val"><b>EQ_TRANS</b></a>]  Theorem
      
      |- ∀x y z. (x = y) ∧ (y = z) ⇒ (x = z)
   
   [<a name="ETA_THM-val"><b>ETA_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: ETA_AX] [] |- ∀M. (λx. M x) = M
   
   [<a name="EXCLUDED_MIDDLE-val"><b>EXCLUDED_MIDDLE</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀t. t ∨ ¬t
   
   [<a name="EXISTS_OR_THM-val"><b>EXISTS_OR_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- ∀P Q. (∃x. P x ∨ Q x) ⇔ (∃x. P x) ∨ ∃x. Q x
   
   [<a name="EXISTS_REFL-val"><b>EXISTS_REFL</b></a>]  Theorem
      
      |- ∀a. ∃x. x = a
   
   [<a name="EXISTS_SIMP-val"><b>EXISTS_SIMP</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀t. (∃x. t) ⇔ t
   
   [<a name="EXISTS_THM-val"><b>EXISTS_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: ETA_AX] [] |- $? f ⇔ ∃x. f x
   
   [<a name="EXISTS_UNIQUE_REFL-val"><b>EXISTS_UNIQUE_REFL</b></a>]  Theorem
      
      |- ∀a. ∃!x. x = a
   
   [<a name="EXISTS_UNIQUE_THM-val"><b>EXISTS_UNIQUE_THM</b></a>]  Theorem
      
      |- (∃!x. P x) ⇔ (∃x. P x) ∧ ∀x y. P x ∧ P y ⇒ (x = y)
   
   [<a name="FALSITY-val"><b>FALSITY</b></a>]  Theorem
      
      |- ∀t. F ⇒ t
   
   [<a name="FORALL_AND_THM-val"><b>FORALL_AND_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- ∀P Q. (∀x. P x ∧ Q x) ⇔ (∀x. P x) ∧ ∀x. Q x
   
   [<a name="FORALL_BOOL-val"><b>FORALL_BOOL</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- (∀b. P b) ⇔ P T ∧ P F
   
   [<a name="FORALL_SIMP-val"><b>FORALL_SIMP</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀t. (∀x. t) ⇔ t
   
   [<a name="FORALL_THM-val"><b>FORALL_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: ETA_AX] [] |- $! f ⇔ ∀x. f x
   
   [<a name="FUN_EQ_THM-val"><b>FUN_EQ_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, ETA_AX] [] |- ∀f g. (f = g) ⇔ ∀x. f x = g x
   
   [<a name="F_IMP-val"><b>F_IMP</b></a>]  Theorem
      
      |- ∀t. ¬t ⇒ t ⇒ F
   
   [<a name="IMP_ANTISYM_AX-val"><b>IMP_ANTISYM_AX</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- ∀t1 t2. (t1 ⇒ t2) ⇒ (t2 ⇒ t1) ⇒ (t1 ⇔ t2)
   
   [<a name="IMP_CLAUSES-val"><b>IMP_CLAUSES</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- ∀t. (T ⇒ t ⇔ t) ∧ (t ⇒ T ⇔ T) ∧ (F ⇒ t ⇔ T) ∧ (t ⇒ t ⇔ T) ∧ (t ⇒ F ⇔ ¬t)
   
   [<a name="IMP_CONG-val"><b>IMP_CONG</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- ∀x x' y y'. (x ⇔ x') ∧ (x' ⇒ (y ⇔ y')) ⇒ (x ⇒ y ⇔ x' ⇒ y')
   
   [<a name="IMP_CONJ_THM-val"><b>IMP_CONJ_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀P Q R. P ⇒ Q ∧ R ⇔ (P ⇒ Q) ∧ (P ⇒ R)
   
   [<a name="IMP_DISJ_THM-val"><b>IMP_DISJ_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀A B. A ⇒ B ⇔ ¬A ∨ B
   
   [<a name="IMP_F-val"><b>IMP_F</b></a>]  Theorem
      
      |- ∀t. (t ⇒ F) ⇒ ¬t
   
   [<a name="IMP_F_EQ_F-val"><b>IMP_F_EQ_F</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀t. t ⇒ F ⇔ (t ⇔ F)
   
   [<a name="ITSELF_UNIQUE-val"><b>ITSELF_UNIQUE</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀i. i = (:α)
   
   [<a name="JRH_INDUCT_UTIL-val"><b>JRH_INDUCT_UTIL</b></a>]  Theorem
      
      [oracles: ] [axioms: ETA_AX] [] |- ∀P t. (∀x. (x = t) ⇒ P x) ⇒ $? P
   
   [<a name="LCOMM_THM-val"><b>LCOMM_THM</b></a>]  Theorem
      
      |- ∀f.
           (∀x y z. f x (f y z) = f (f x y) z) ⇒
           (∀x y. f x y = f y x) ⇒
           ∀x y z. f x (f y z) = f y (f x z)
   
   [<a name="LEFT_AND_CONG-val"><b>LEFT_AND_CONG</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- ∀P P' Q Q'. (P ⇔ P') ∧ (P' ⇒ (Q ⇔ Q')) ⇒ (P ∧ Q ⇔ P' ∧ Q')
   
   [<a name="LEFT_AND_FORALL_THM-val"><b>LEFT_AND_FORALL_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀P Q. (∀x. P x) ∧ Q ⇔ ∀x. P x ∧ Q
   
   [<a name="LEFT_AND_OVER_OR-val"><b>LEFT_AND_OVER_OR</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀A B C. A ∧ (B ∨ C) ⇔ A ∧ B ∨ A ∧ C
   
   [<a name="LEFT_EXISTS_AND_THM-val"><b>LEFT_EXISTS_AND_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀P Q. (∃x. P x ∧ Q) ⇔ (∃x. P x) ∧ Q
   
   [<a name="LEFT_EXISTS_IMP_THM-val"><b>LEFT_EXISTS_IMP_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀P Q. (∃x. P x ⇒ Q) ⇔ (∀x. P x) ⇒ Q
   
   [<a name="LEFT_FORALL_IMP_THM-val"><b>LEFT_FORALL_IMP_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀P Q. (∀x. P x ⇒ Q) ⇔ (∃x. P x) ⇒ Q
   
   [<a name="LEFT_FORALL_OR_THM-val"><b>LEFT_FORALL_OR_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀Q P. (∀x. P x ∨ Q) ⇔ (∀x. P x) ∨ Q
   
   [<a name="LEFT_OR_CONG-val"><b>LEFT_OR_CONG</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- ∀P P' Q Q'. (P ⇔ P') ∧ (¬P' ⇒ (Q ⇔ Q')) ⇒ (P ∨ Q ⇔ P' ∨ Q')
   
   [<a name="LEFT_OR_EXISTS_THM-val"><b>LEFT_OR_EXISTS_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀P Q. (∃x. P x) ∨ Q ⇔ ∃x. P x ∨ Q
   
   [<a name="LEFT_OR_OVER_AND-val"><b>LEFT_OR_OVER_AND</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀A B C. A ∨ B ∧ C ⇔ (A ∨ B) ∧ (A ∨ C)
   
   [<a name="LET_CONG-val"><b>LET_CONG</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- ∀f g M N. (M = N) ∧ (∀x. (x = N) ⇒ (f x = g x)) ⇒ (LET f M = LET g N)
   
   [<a name="LET_RAND-val"><b>LET_RAND</b></a>]  Theorem
      
      |- P (let x = M in N x) ⇔ (let x = M in P (N x))
   
   [<a name="LET_RATOR-val"><b>LET_RATOR</b></a>]  Theorem
      
      |- (let x = M in N x) b = (let x = M in N x b)
   
   [<a name="LET_THM-val"><b>LET_THM</b></a>]  Theorem
      
      |- ∀f x. LET f x = f x
   
   [<a name="MONO_ALL-val"><b>MONO_ALL</b></a>]  Theorem
      
      |- (∀x. P x ⇒ Q x) ⇒ (∀x. P x) ⇒ ∀x. Q x
   
   [<a name="MONO_AND-val"><b>MONO_AND</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- (x ⇒ y) ∧ (z ⇒ w) ⇒ x ∧ z ⇒ y ∧ w
   
   [<a name="MONO_COND-val"><b>MONO_COND</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] []
      |- (x ⇒ y) ⇒ (z ⇒ w) ⇒ (if b then x else z) ⇒ if b then y else w
   
   [<a name="MONO_EXISTS-val"><b>MONO_EXISTS</b></a>]  Theorem
      
      |- (∀x. P x ⇒ Q x) ⇒ (∃x. P x) ⇒ ∃x. Q x
   
   [<a name="MONO_IMP-val"><b>MONO_IMP</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- (y ⇒ x) ∧ (z ⇒ w) ⇒ (x ⇒ z) ⇒ y ⇒ w
   
   [<a name="MONO_NOT-val"><b>MONO_NOT</b></a>]  Theorem
      
      |- (y ⇒ x) ⇒ ¬x ⇒ ¬y
   
   [<a name="MONO_NOT_EQ-val"><b>MONO_NOT_EQ</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- y ⇒ x ⇔ ¬x ⇒ ¬y
   
   [<a name="MONO_OR-val"><b>MONO_OR</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- (x ⇒ y) ∧ (z ⇒ w) ⇒ x ∨ z ⇒ y ∨ w
   
   [<a name="NOT_AND-val"><b>NOT_AND</b></a>]  Theorem
      
      |- ¬(t ∧ ¬t)
   
   [<a name="NOT_CLAUSES-val"><b>NOT_CLAUSES</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- (∀t. ¬ ¬t ⇔ t) ∧ (¬T ⇔ F) ∧ (¬F ⇔ T)
   
   [<a name="NOT_EXISTS_THM-val"><b>NOT_EXISTS_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀P. ¬(∃x. P x) ⇔ ∀x. ¬P x
   
   [<a name="NOT_F-val"><b>NOT_F</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀t. ¬t ⇒ (t ⇔ F)
   
   [<a name="NOT_FORALL_THM-val"><b>NOT_FORALL_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀P. ¬(∀x. P x) ⇔ ∃x. ¬P x
   
   [<a name="NOT_IMP-val"><b>NOT_IMP</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀A B. ¬(A ⇒ B) ⇔ A ∧ ¬B
   
   [<a name="ONE_ONE_THM-val"><b>ONE_ONE_THM</b></a>]  Theorem
      
      |- ∀f. ONE_ONE f ⇔ ∀x1 x2. (f x1 = f x2) ⇒ (x1 = x2)
   
   [<a name="ONTO_THM-val"><b>ONTO_THM</b></a>]  Theorem
      
      |- ∀f. ONTO f ⇔ ∀y. ∃x. y = f x
   
   [<a name="OR_CLAUSES-val"><b>OR_CLAUSES</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- ∀t. (T ∨ t ⇔ T) ∧ (t ∨ T ⇔ T) ∧ (F ∨ t ⇔ t) ∧ (t ∨ F ⇔ t) ∧ (t ∨ t ⇔ t)
   
   [<a name="OR_CONG-val"><b>OR_CONG</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- ∀P P' Q Q'. (¬Q ⇒ (P ⇔ P')) ∧ (¬P' ⇒ (Q ⇔ Q')) ⇒ (P ∨ Q ⇔ P' ∨ Q')
   
   [<a name="OR_ELIM_THM-val"><b>OR_ELIM_THM</b></a>]  Theorem
      
      |- ∀t t1 t2. t1 ∨ t2 ⇒ (t1 ⇒ t) ⇒ (t2 ⇒ t) ⇒ t
   
   [<a name="OR_IMP_THM-val"><b>OR_IMP_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀A B. (A ⇔ B ∨ A) ⇔ B ⇒ A
   
   [<a name="OR_INTRO_THM1-val"><b>OR_INTRO_THM1</b></a>]  Theorem
      
      |- ∀t1 t2. t1 ⇒ t1 ∨ t2
   
   [<a name="OR_INTRO_THM2-val"><b>OR_INTRO_THM2</b></a>]  Theorem
      
      |- ∀t1 t2. t2 ⇒ t1 ∨ t2
   
   [<a name="PEIRCE-val"><b>PEIRCE</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ((P ⇒ Q) ⇒ P) ⇒ P
   
   [<a name="REFL_CLAUSE-val"><b>REFL_CLAUSE</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀x. (x = x) ⇔ T
   
   [<a name="RES_EXISTS_CONG-val"><b>RES_EXISTS_CONG</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- (P = Q) ⇒ (∀x. x ∈ Q ⇒ (f x ⇔ g x)) ⇒ (RES_EXISTS P f ⇔ RES_EXISTS Q g)
   
   [<a name="RES_EXISTS_FALSE-val"><b>RES_EXISTS_FALSE</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- (∃x::P. F) ⇔ F
   
   [<a name="RES_EXISTS_THM-val"><b>RES_EXISTS_THM</b></a>]  Theorem
      
      |- ∀P f. RES_EXISTS P f ⇔ ∃x. x ∈ P ∧ f x
   
   [<a name="RES_EXISTS_UNIQUE_THM-val"><b>RES_EXISTS_UNIQUE_THM</b></a>]  Theorem
      
      |- ∀P f. RES_EXISTS_UNIQUE P f ⇔ (∃x::P. f x) ∧ ∀x y::P. f x ∧ f y ⇒ (x = y)
   
   [<a name="RES_FORALL_CONG-val"><b>RES_FORALL_CONG</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- (P = Q) ⇒ (∀x. x ∈ Q ⇒ (f x ⇔ g x)) ⇒ (RES_FORALL P f ⇔ RES_FORALL Q g)
   
   [<a name="RES_FORALL_THM-val"><b>RES_FORALL_THM</b></a>]  Theorem
      
      |- ∀P f. RES_FORALL P f ⇔ ∀x. x ∈ P ⇒ f x
   
   [<a name="RES_FORALL_TRUE-val"><b>RES_FORALL_TRUE</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- (∀x::P. T) ⇔ T
   
   [<a name="RES_SELECT_THM-val"><b>RES_SELECT_THM</b></a>]  Theorem
      
      |- ∀P f. RES_SELECT P f = @x. x ∈ P ∧ f x
   
   [<a name="RIGHT_AND_FORALL_THM-val"><b>RIGHT_AND_FORALL_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀P Q. P ∧ (∀x. Q x) ⇔ ∀x. P ∧ Q x
   
   [<a name="RIGHT_AND_OVER_OR-val"><b>RIGHT_AND_OVER_OR</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀A B C. (B ∨ C) ∧ A ⇔ B ∧ A ∨ C ∧ A
   
   [<a name="RIGHT_EXISTS_AND_THM-val"><b>RIGHT_EXISTS_AND_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀P Q. (∃x. P ∧ Q x) ⇔ P ∧ ∃x. Q x
   
   [<a name="RIGHT_EXISTS_IMP_THM-val"><b>RIGHT_EXISTS_IMP_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀P Q. (∃x. P ⇒ Q x) ⇔ P ⇒ ∃x. Q x
   
   [<a name="RIGHT_FORALL_IMP_THM-val"><b>RIGHT_FORALL_IMP_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀P Q. (∀x. P ⇒ Q x) ⇔ P ⇒ ∀x. Q x
   
   [<a name="RIGHT_FORALL_OR_THM-val"><b>RIGHT_FORALL_OR_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀P Q. (∀x. P ∨ Q x) ⇔ P ∨ ∀x. Q x
   
   [<a name="RIGHT_OR_EXISTS_THM-val"><b>RIGHT_OR_EXISTS_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀P Q. P ∨ (∃x. Q x) ⇔ ∃x. P ∨ Q x
   
   [<a name="RIGHT_OR_OVER_AND-val"><b>RIGHT_OR_OVER_AND</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀A B C. B ∧ C ∨ A ⇔ (B ∨ A) ∧ (C ∨ A)
   
   [<a name="SELECT_ELIM_THM-val"><b>SELECT_ELIM_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: SELECT_AX] []
      |- ∀P Q. (∃x. P x) ∧ (∀x. P x ⇒ Q x) ⇒ Q ($@ P)
   
   [<a name="SELECT_REFL-val"><b>SELECT_REFL</b></a>]  Theorem
      
      [oracles: ] [axioms: SELECT_AX] [] |- ∀x. (@y. y = x) = x
   
   [<a name="SELECT_REFL_2-val"><b>SELECT_REFL_2</b></a>]  Theorem
      
      [oracles: ] [axioms: SELECT_AX] [] |- ∀x. (@y. x = y) = x
   
   [<a name="SELECT_THM-val"><b>SELECT_THM</b></a>]  Theorem
      
      |- ∀P. P (@x. P x) ⇔ ∃x. P x
   
   [<a name="SELECT_UNIQUE-val"><b>SELECT_UNIQUE</b></a>]  Theorem
      
      [oracles: ] [axioms: ETA_AX, BOOL_CASES_AX, SELECT_AX] []
      |- ∀P x. (∀y. P y ⇔ (y = x)) ⇒ ($@ P = x)
   
   [<a name="SKOLEM_THM-val"><b>SKOLEM_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] []
      |- ∀P. (∀x. ∃y. P x y) ⇔ ∃f. ∀x. P x (f x)
   
   [<a name="SWAP_EXISTS_THM-val"><b>SWAP_EXISTS_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀P. (∃x y. P x y) ⇔ ∃y x. P x y
   
   [<a name="SWAP_FORALL_THM-val"><b>SWAP_FORALL_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀P. (∀x y. P x y) ⇔ ∀y x. P x y
   
   [<a name="TRUTH-val"><b>TRUTH</b></a>]  Theorem
      
      |- T
   
   [<a name="TYPE_DEFINITION_THM-val"><b>TYPE_DEFINITION_THM</b></a>]  Theorem
      
      |- ∀P rep.
           TYPE_DEFINITION P rep ⇔
           (∀x' x''. (rep x' = rep x'') ⇒ (x' = x'')) ∧ ∀x. P x ⇔ ∃x'. x = rep x'
   
   [<a name="UEXISTS_OR_THM-val"><b>UEXISTS_OR_THM</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- ∀P Q. (∃!x. P x ∨ Q x) ⇒ (∃!x. P x) ∨ ∃!x. Q x
   
   [<a name="UEXISTS_SIMP-val"><b>UEXISTS_SIMP</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- (∃!x. t) ⇔ t ∧ ∀x y. x = y
   
   [<a name="UNWIND_FORALL_THM1-val"><b>UNWIND_FORALL_THM1</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀f v. (∀x. (v = x) ⇒ f x) ⇔ f v
   
   [<a name="UNWIND_FORALL_THM2-val"><b>UNWIND_FORALL_THM2</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀f v. (∀x. (x = v) ⇒ f x) ⇔ f v
   
   [<a name="UNWIND_THM1-val"><b>UNWIND_THM1</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀P a. (∃x. (a = x) ∧ P x) ⇔ P a
   
   [<a name="UNWIND_THM2-val"><b>UNWIND_THM2</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀P a. (∃x. (x = a) ∧ P x) ⇔ P a
   
   [<a name="boolAxiom-val"><b>boolAxiom</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] []
      |- ∀e0 e1. ∃fn. (fn T = e0) ∧ (fn F = e1)
   
   [<a name="bool_INDUCT-val"><b>bool_INDUCT</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀P. P T ∧ P F ⇒ ∀b. P b
   
   [<a name="bool_case_CONG-val"><b>bool_case_CONG</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] []
      |- ∀P Q x x' y y'.
           (P ⇔ Q) ∧ (Q ⇒ (x = x')) ∧ (¬Q ⇒ (y = y')) ⇒
           (bool_case x y P = if Q then x' else y')
   
   [<a name="bool_case_EQ_COND-val"><b>bool_case_EQ_COND</b></a>]  Theorem
      
      |- ∀b x y. bool_case x y b = if b then x else y
   
   [<a name="bool_case_ID-val"><b>bool_case_ID</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] [] |- ∀x b. bool_case x x b = x
   
   [<a name="bool_case_thm-val"><b>bool_case_thm</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] []
      |- (∀e0 e1. bool_case e0 e1 T = e0) ∧ ∀e0 e1. bool_case e0 e1 F = e1
   
   [<a name="itself_Axiom-val"><b>itself_Axiom</b></a>]  Theorem
      
      |- ∀e. ∃f. f (:β) = e
   
   [<a name="itself_induction-val"><b>itself_induction</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ∀P. P (:α) ⇒ ∀i. P i
   
   [<a name="literal_case_CONG-val"><b>literal_case_CONG</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- ∀f g M N.
           (M = N) ∧ (∀x. (x = N) ⇒ (f x = g x)) ⇒
           (literal_case f M = literal_case g N)
   
   [<a name="literal_case_RAND-val"><b>literal_case_RAND</b></a>]  Theorem
      
      |- P (literal_case (λx. N x) M) ⇔ literal_case (λx. P (N x)) M
   
   [<a name="literal_case_RATOR-val"><b>literal_case_RATOR</b></a>]  Theorem
      
      |- literal_case (λx. N x) M b = literal_case (λx. N x b) M
   
   [<a name="literal_case_THM-val"><b>literal_case_THM</b></a>]  Theorem
      
      |- ∀f x. literal_case f x = f x
   
   [<a name="literal_case_id-val"><b>literal_case_id</b></a>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] []
      |- literal_case (λx. bool_case t u (x = a)) a = t
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/bool/boolScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-6</a></em></p></body></html>
