<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure quantHeuristicsLib</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure quantHeuristicsLib</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/quantHeuristics/quantHeuristicsLib.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature quantHeuristicsLib =
<a name="line2"></a>sig
<a name="line3"></a>  include Abbrev
<a name="line4"></a>
<a name="line5"></a>
<a name="line6"></a>(*some general conversions, that might be useful
<a name="line7"></a>  in other context as well *)
<a name="line8"></a>  val TOP_ONCE_REWRITE_CONV        : thm list -&gt; conv;
<a name="line9"></a>  val NEG_NEG_INTRO_CONV           : conv;
<a name="line10"></a>  val NEG_NEG_ELIM_CONV            : conv;
<a name="line11"></a>  val NOT_FORALL_LIST_CONV         : conv;
<a name="line12"></a>  val NOT_EXISTS_LIST_CONV         : conv;
<a name="line13"></a>  val STRIP_NUM_QUANT_CONV         : int -&gt; conv -&gt; conv;
<a name="line14"></a>  val BOUNDED_NOT_EXISTS_LIST_CONV : int -&gt; conv;
<a name="line15"></a>  val BOUNDED_REPEATC              : int -&gt; conv -&gt; conv;
<a name="line16"></a>
<a name="line17"></a>  val EXISTS_NOT_LIST_CONV         : conv;
<a name="line18"></a>  val FORALL_NOT_LIST_CONV         : conv;
<a name="line19"></a>  val QUANT_SIMP_CONV              : conv;
<a name="line20"></a>
<a name="line21"></a>  val NOT_OR_CONV                  : conv;
<a name="line22"></a>  val NOT_AND_CONV                 : conv;
<a name="line23"></a>  val AND_NOT_CONV                 : conv;
<a name="line24"></a>  val OR_NOT_CONV                  : conv;
<a name="line25"></a>
<a name="line26"></a>  val VARIANT_TAC                  : term list -&gt; tactic
<a name="line27"></a>  val VARIANT_CONV                 : term list -&gt; conv
<a name="line28"></a>
<a name="line29"></a>
<a name="line30"></a>(*Guesses*)
<a name="line31"></a>
<a name="line32"></a>  datatype guess =
<a name="line33"></a>    (*A guess with no particular reason at all, no justification. This
<a name="line34"></a>      is for example used by EXISTS_TAC.
<a name="line35"></a>
<a name="line36"></a>      guess_general (i, [fv1,...,fvn])
<a name="line37"></a>
<a name="line38"></a>      can be used to proof
<a name="line39"></a>
<a name="line40"></a>      ?fv1 ... fvn. P i ==&gt; ?v. P v   and
<a name="line41"></a>      !v. P v ==&gt; !fv1 ... fvn. P i
<a name="line42"></a>
<a name="line43"></a>      or if one want's to use equations
<a name="line44"></a>
<a name="line45"></a>      ?v. P v = (?fv1 ... fvn. P i) \/
<a name="line46"></a>                   ?v. (!fv1 ... fvn. ~(i = v)) /\ (P v)  and
<a name="line47"></a>
<a name="line48"></a>      !v. P v = (!fv1 ... fvn. P i) /\
<a name="line49"></a>		   (!v. (?fv1 ... fvn. ~(i = v)) ==&gt; P v)
<a name="line50"></a>
<a name="line51"></a>
<a name="line52"></a>      These two possibilies are always available and
<a name="line53"></a>      choosen if the other guesses don't provide a theorem.
<a name="line54"></a>    *)
<a name="line55"></a>    guess_general of term * term list
<a name="line56"></a>
<a name="line57"></a>    (*i makes P i false
<a name="line58"></a>
<a name="line59"></a>      This can be used to proof
<a name="line60"></a>      !v. P v = F
<a name="line61"></a>
<a name="line62"></a>      If a theorem is provided it has to be of the form
<a name="line63"></a>      !fv1 ... fvn. ~(P i)
<a name="line64"></a>    *)
<a name="line65"></a>  | guess_false of term * term list * (unit -&gt; thm) option
<a name="line66"></a>
<a name="line67"></a>    (*i makes P i true
<a name="line68"></a>
<a name="line69"></a>      This can be used to proof
<a name="line70"></a>      ?v. P v = T
<a name="line71"></a>
<a name="line72"></a>      The theorem has to be of the form
<a name="line73"></a>      !fv1 ... fvn. P i
<a name="line74"></a>    *)
<a name="line75"></a>  | guess_true of term * term list * (unit -&gt; thm) option
<a name="line76"></a>
<a name="line77"></a>    (*if i does satisfy P then all other i' as well
<a name="line78"></a>
<a name="line79"></a>      This can be used to proof
<a name="line80"></a>      !v. P v = !fv1 ... fvn. P i
<a name="line81"></a>
<a name="line82"></a>
<a name="line83"></a>      The theorem has to be of the form
<a name="line84"></a>      (!fv1 ... fvn. P i) ==&gt; !v. P v
<a name="line85"></a>    *)
<a name="line86"></a>  | guess_only_not_possible of term * term list * (unit -&gt; thm) option
<a name="line87"></a>
<a name="line88"></a>    (*if i does not satisfy P then all other i' don't as well
<a name="line89"></a>
<a name="line90"></a>      This can be used to proof
<a name="line91"></a>      ?v. P v = ?fv1 ... fvn. P i
<a name="line92"></a>
<a name="line93"></a>      The theorem has to be of the form
<a name="line94"></a>      (!fv1 ... fvn. ~(P i)) ==&gt; !v. ~(P v)
<a name="line95"></a>    *)
<a name="line96"></a>  | guess_only_possible of term * term list * (unit -&gt; thm) option
<a name="line97"></a>
<a name="line98"></a>    (*all instantiations except i do not satisfy P
<a name="line99"></a>
<a name="line100"></a>      This can be used to proof
<a name="line101"></a>      ?v. P v = ?fv1 ... fvn. P i
<a name="line102"></a>
<a name="line103"></a>      The theorem has to be of the form
<a name="line104"></a>      !v. (!fv1 ... fvn. ~(v = i)) ==&gt; ~P v
<a name="line105"></a>    *)
<a name="line106"></a>  | guess_others_not_possible of term * term list * (unit -&gt; thm) option
<a name="line107"></a>
<a name="line108"></a>    (*all instantiations except i do satisfy P
<a name="line109"></a>
<a name="line110"></a>      This can be used to proof
<a name="line111"></a>      !v. P v = !fv1 ... fvn. P i
<a name="line112"></a>
<a name="line113"></a>      The theorem has to be of the form
<a name="line114"></a>      !v. (!fv1 ... fvn. ~(v = i)) ==&gt; P v
<a name="line115"></a>    *)
<a name="line116"></a>  | guess_others_satisfied of term * term list * (unit -&gt; thm) option;
<a name="line117"></a>
<a name="line118"></a>
<a name="line119"></a>  val is_guess_general             : guess -&gt; bool
<a name="line120"></a>  val is_guess_true                : bool -&gt; guess -&gt; bool
<a name="line121"></a>  val is_guess_false               : bool -&gt; guess -&gt; bool
<a name="line122"></a>  val is_guess_only_possible       : bool -&gt; guess -&gt; bool
<a name="line123"></a>  val is_guess_only_not_possible   : bool -&gt; guess -&gt; bool
<a name="line124"></a>  val is_guess_others_not_possible : bool -&gt; guess -&gt; bool
<a name="line125"></a>  val is_guess_others_satisfied    : bool -&gt; guess -&gt; bool
<a name="line126"></a>
<a name="line127"></a>  val guess_set_thm_opt            : (unit -&gt; thm) option -&gt; guess -&gt; guess
<a name="line128"></a>  val guess_remove_thm             : guess -&gt; guess
<a name="line129"></a>  val make_guess_thm_term          : term -&gt; term -&gt; guess -&gt; term option
<a name="line130"></a>  val make_guess_thm_opt           : term -&gt; term -&gt; guess -&gt; conv -&gt; (unit -&gt; thm) option
<a name="line131"></a>  val make_set_guess_thm_opt       : term -&gt; term -&gt; guess -&gt; conv -&gt; guess
<a name="line132"></a>
<a name="line133"></a>  (*Warning: this one is for debugging only. It uses mk_thm to
<a name="line134"></a>    create the thm added to the guess*)
<a name="line135"></a>  val make_guess_thm_opt___dummy : term -&gt; term -&gt; guess -&gt; (unit -&gt; thm) option
<a name="line136"></a>  val make_set_guess_thm_opt___dummy : term -&gt; term -&gt; guess -&gt; guess
<a name="line137"></a>
<a name="line138"></a>
<a name="line139"></a>  val guess_extract : guess -&gt; term * term list * (unit -&gt; thm) option
<a name="line140"></a>  val guess_to_string : bool -&gt; guess -&gt; string
<a name="line141"></a>
<a name="line142"></a>
<a name="line143"></a>  (*guesses are organised in collections. They are used to
<a name="line144"></a>    store the different types of guesses separately. Moreover,
<a name="line145"></a>    rewrite theorems, that might come in handy, are there as well.*)
<a name="line146"></a>  type guess_collection =
<a name="line147"></a>   {rewrites            : thm list,
<a name="line148"></a>    general             : guess list,
<a name="line149"></a>    true                : guess list,
<a name="line150"></a>    false               : guess list,
<a name="line151"></a>    only_possible       : guess list,
<a name="line152"></a>    only_not_possible   : guess list,
<a name="line153"></a>    others_not_possible : guess list,
<a name="line154"></a>    others_satisfied    : guess list}
<a name="line155"></a>
<a name="line156"></a>
<a name="line157"></a>  val empty_guess_collection   : guess_collection;
<a name="line158"></a>  val is_empty_guess_collection   : guess_collection -&gt; bool;
<a name="line159"></a>  val guess_collection_append  : guess_collection -&gt; guess_collection -&gt; guess_collection;
<a name="line160"></a>  val guess_collection_flatten : guess_collection option list -&gt; guess_collection;
<a name="line161"></a>  val guess_list2collection    : thm list * guess list -&gt; guess_collection;
<a name="line162"></a>  val guess_collection2list    : guess_collection -&gt; thm list * guess list;
<a name="line163"></a>  val guess_collection___get_only_possible_weaken : guess_collection -&gt; guess list;
<a name="line164"></a>  val guess_collection___get_only_not_possible_weaken : guess_collection -&gt; guess list;
<a name="line165"></a>
<a name="line166"></a>  val guess_weaken       : term -&gt; term -&gt; guess -&gt; guess
<a name="line167"></a>  val check_guess        : term -&gt; term -&gt; guess -&gt; bool
<a name="line168"></a>  val correct_guess      : term -&gt; term -&gt; guess -&gt; guess option
<a name="line169"></a>  val correct_guess_list : term -&gt; term -&gt; guess list -&gt; guess list;
<a name="line170"></a>  val correct_guess_collection :
<a name="line171"></a>     term -&gt; term -&gt; guess_collection -&gt; guess_collection
<a name="line172"></a>
<a name="line173"></a>
<a name="line174"></a>  val term_variant : term list -&gt; term list -&gt; term -&gt; term * term list
<a name="line175"></a>
<a name="line176"></a>
<a name="line177"></a>
<a name="line178"></a>  exception QUANT_INSTANTIATE_HEURISTIC___no_guess_exp;
<a name="line179"></a>
<a name="line180"></a>(*Some types*)
<a name="line181"></a>  type quant_heuristic = term list -&gt; term -&gt; term -&gt; guess_collection;
<a name="line182"></a>  type quant_param =
<a name="line183"></a>    {distinct_thms      : thm list,
<a name="line184"></a>     cases_thms         : thm list,
<a name="line185"></a>     rewrite_thms       : thm list,
<a name="line186"></a>     convs              : conv list,
<a name="line187"></a>     heuristics         : (quant_heuristic -&gt; quant_heuristic) list,
<a name="line188"></a>     final_rewrite_thms : thm list};
<a name="line189"></a>  type quant_heuristic_cache;
<a name="line190"></a>
<a name="line191"></a>
<a name="line192"></a>  val mk_quant_heuristic_cache : unit -&gt; quant_heuristic_cache;
<a name="line193"></a>
<a name="line194"></a>
<a name="line195"></a>
<a name="line196"></a>(*Heuristics that might be useful to write own ones*)
<a name="line197"></a>  val QUANT_INSTANTIATE_HEURISTIC___REWRITE :
<a name="line198"></a>  quant_heuristic -&gt; term list -&gt; term -&gt; thm -&gt; guess_collection
<a name="line199"></a>  val QUANT_INSTANTIATE_HEURISTIC___CONV :
<a name="line200"></a>  conv -&gt; quant_heuristic -&gt; quant_heuristic;
<a name="line201"></a>  val QUANT_INSTANTIATE_HEURISTIC___EQUATION_distinct : thm list -&gt; quant_heuristic -&gt; quant_heuristic;
<a name="line202"></a>  val QUANT_INSTANTIATE_HEURISTIC___EQUATION_cases    : thm -&gt; quant_heuristic -&gt; quant_heuristic;
<a name="line203"></a>  val QUANT_INSTANTIATE_HEURISTIC___one_case          : thm -&gt; quant_heuristic -&gt; quant_heuristic;
<a name="line204"></a>  val QUANT_INSTANTIATE_GUESSES___one_case            : thm -&gt; term -&gt; (term list * term * term) * guess list
<a name="line205"></a>  val QUANT_INSTANTIATE_HEURISTIC___cases             : thm -&gt; quant_heuristic -&gt; quant_heuristic;
<a name="line206"></a>
<a name="line207"></a>
<a name="line208"></a>
<a name="line209"></a>  val QUANT_INSTANTIATE_HEURISTIC___max_rec_depth : int ref
<a name="line210"></a>
<a name="line211"></a>  val QUANT_INSTANTIATE_HEURISTIC___COMBINE :
<a name="line212"></a>    ((quant_heuristic -&gt; quant_heuristic) list) -&gt; quant_heuristic_cache ref option -&gt; quant_heuristic;
<a name="line213"></a>
<a name="line214"></a>
<a name="line215"></a>  val COMBINE_HEURISTIC_FUNS : (unit -&gt; guess_collection) list -&gt; guess_collection;
<a name="line216"></a>
<a name="line217"></a>
<a name="line218"></a>  (*use this to create sys for debugging own heuristics*)
<a name="line219"></a>  val QUANT_INSTANTIATE_HEURISTIC___PURE_COMBINE : quant_param -&gt;
<a name="line220"></a>       quant_heuristic_cache ref option -&gt;
<a name="line221"></a>       term list -&gt; term -&gt; term -&gt; guess_collection
<a name="line222"></a>
<a name="line223"></a>(*The most important functions *)
<a name="line224"></a>  val EXTENSIBLE_QUANT_INSTANTIATE_CONV : quant_heuristic_cache ref option -&gt;
<a name="line225"></a>      bool -&gt; (term -&gt; bool) -&gt; bool -&gt; bool -&gt; quant_param list -&gt; conv;
<a name="line226"></a>  val QUANT_INSTANTIATE_CONV    : quant_param list -&gt; conv;
<a name="line227"></a>  val QUANT_INSTANTIATE_TAC     : quant_param list -&gt; tactic;
<a name="line228"></a>  val ASM_QUANT_INSTANTIATE_TAC : quant_param list -&gt; tactic;
<a name="line229"></a>  val FAST_QUANT_INSTANTIATE_CONV    : quant_param list -&gt; conv;
<a name="line230"></a>  val FAST_QUANT_INSTANTIATE_TAC     : quant_param list -&gt; tactic;
<a name="line231"></a>  val ASM_FAST_QUANT_INSTANTIATE_TAC : quant_param list -&gt; tactic;
<a name="line232"></a>
<a name="line233"></a>
<a name="line234"></a>  val EXTENSIBLE_QUANT_INSTANTIATE_STEP_CONSEQ_CONV : 
<a name="line235"></a>      quant_heuristic_cache ref option -&gt; (term -&gt; bool) -&gt; bool -&gt; quant_param list -&gt; ConseqConv.directed_conseq_conv;
<a name="line236"></a>  val EXTENSIBLE_QUANT_INSTANTIATE_CONSEQ_CONV : 
<a name="line237"></a>      quant_heuristic_cache ref option -&gt; bool -&gt; (term -&gt; bool) -&gt; bool -&gt; quant_param list -&gt; ConseqConv.directed_conseq_conv;
<a name="line238"></a>  val QUANT_INSTANTIATE_CONSEQ_CONV :
<a name="line239"></a>      quant_param list -&gt; ConseqConv.directed_conseq_conv;
<a name="line240"></a>  val FAST_QUANT_INSTANTIATE_CONSEQ_CONV :
<a name="line241"></a>      quant_param list -&gt; ConseqConv.directed_conseq_conv;
<a name="line242"></a>
<a name="line243"></a>
<a name="line244"></a>  val QUANT_INST_CONV : (string * Parse.term Lib.frag list * Parse.term Parse.frag list list) list
<a name="line245"></a>   -&gt; conv;
<a name="line246"></a>  val QUANT_INST_TAC  : (string * Parse.term Lib.frag list * Parse.term Parse.frag list list) list
<a name="line247"></a>   -&gt; tactic;
<a name="line248"></a>
<a name="line249"></a>
<a name="line250"></a>
<a name="line251"></a>
<a name="line252"></a>
<a name="line253"></a>(*functions to add stuff to QUANT_INSTANTIATE_CONV*)
<a name="line254"></a>
<a name="line255"></a>  val clear_stateful_qp : unit -&gt; unit
<a name="line256"></a>  val stateful_qp___add_combine_arguments :
<a name="line257"></a>     quant_param list -&gt; unit;
<a name="line258"></a>
<a name="line259"></a>  val QUANT_INSTANTIATE_HEURISTIC___STATEFUL : quant_heuristic -&gt; quant_heuristic;
<a name="line260"></a>
<a name="line261"></a>  val empty_qp           : quant_param;
<a name="line262"></a>  val stateful_qp        : quant_param;
<a name="line263"></a>  val pure_stateful_qp   : quant_param;
<a name="line264"></a>  val TypeBase_qp        : quant_param
<a name="line265"></a>  val get_qp___for_types : hol_type list -&gt; quant_param
<a name="line266"></a>
<a name="line267"></a>
<a name="line268"></a>  val combine_qp :
<a name="line269"></a>     quant_param -&gt; quant_param -&gt;
<a name="line270"></a>     quant_param;
<a name="line271"></a>
<a name="line272"></a>  val combine_qps :
<a name="line273"></a>     quant_param list -&gt; quant_param;
<a name="line274"></a>
<a name="line275"></a>  val distinct_qp      : thm list -&gt; quant_param
<a name="line276"></a>  val rewrite_qp       : thm list -&gt; quant_param
<a name="line277"></a>  val final_rewrite_qp : thm list -&gt; quant_param
<a name="line278"></a>  val cases_qp         : thm list -&gt; quant_param
<a name="line279"></a>  val convs_qp         : conv list -&gt; quant_param
<a name="line280"></a>  val heuristics_qp    : (quant_heuristic -&gt; quant_heuristic) list -&gt;
<a name="line281"></a>                           quant_param
<a name="line282"></a>
<a name="line283"></a>
<a name="line284"></a>(*combination with simplifier*)
<a name="line285"></a>  val QUANT_INST_ss      : quant_param list -&gt; simpLib.ssfrag;
<a name="line286"></a>
<a name="line287"></a>(* Traces *)
<a name="line288"></a>(* "QUANT_INSTANTIATE_HEURISTIC" can be used to get debug information on
<a name="line289"></a>   how guesses are obtained *)
<a name="line290"></a>
<a name="line291"></a>
<a name="line292"></a>
<a name="line293"></a>end
<a name="line294"></a>
</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/quantHeuristics/quantHeuristicsLib.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-6</a></em></p></body></html>
