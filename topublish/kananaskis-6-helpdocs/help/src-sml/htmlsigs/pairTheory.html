<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure pairTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure pairTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/pair/src/pairScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature pairTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#ABS_REP_prod-val">ABS_REP_prod</a> : thm
<a name="line7"></a>    val <a href="#COMMA_DEF-val">COMMA_DEF</a> : thm
<a name="line8"></a>    val <a href="#CURRY_DEF-val">CURRY_DEF</a> : thm
<a name="line9"></a>    val <a href="#LEX_DEF-val">LEX_DEF</a> : thm
<a name="line10"></a>    val <a href="#PAIR-val">PAIR</a> : thm
<a name="line11"></a>    val <a href="#PAIR_MAP-val">PAIR_MAP</a> : thm
<a name="line12"></a>    val <a href="#RPROD_DEF-val">RPROD_DEF</a> : thm
<a name="line13"></a>    val <a href="#UNCURRY-val">UNCURRY</a> : thm
<a name="line14"></a>    val <a href="#pair_case_def-val">pair_case_def</a> : thm
<a name="line15"></a>    val <a href="#prod_TY_DEF-val">prod_TY_DEF</a> : thm
<a name="line16"></a>  
<a name="line17"></a>  (*  Theorems  *)
<a name="line18"></a>    val <a href="#ABS_PAIR_THM-val">ABS_PAIR_THM</a> : thm
<a name="line19"></a>    val <a href="#CLOSED_PAIR_EQ-val">CLOSED_PAIR_EQ</a> : thm
<a name="line20"></a>    val <a href="#CURRY_ONE_ONE_THM-val">CURRY_ONE_ONE_THM</a> : thm
<a name="line21"></a>    val <a href="#CURRY_UNCURRY_THM-val">CURRY_UNCURRY_THM</a> : thm
<a name="line22"></a>    val <a href="#C_UNCURRY_L-val">C_UNCURRY_L</a> : thm
<a name="line23"></a>    val <a href="#ELIM_PEXISTS-val">ELIM_PEXISTS</a> : thm
<a name="line24"></a>    val <a href="#ELIM_PEXISTS_EVAL-val">ELIM_PEXISTS_EVAL</a> : thm
<a name="line25"></a>    val <a href="#ELIM_PFORALL-val">ELIM_PFORALL</a> : thm
<a name="line26"></a>    val <a href="#ELIM_PFORALL_EVAL-val">ELIM_PFORALL_EVAL</a> : thm
<a name="line27"></a>    val <a href="#ELIM_UNCURRY-val">ELIM_UNCURRY</a> : thm
<a name="line28"></a>    val <a href="#EXISTS_PROD-val">EXISTS_PROD</a> : thm
<a name="line29"></a>    val <a href="#FORALL_PROD-val">FORALL_PROD</a> : thm
<a name="line30"></a>    val <a href="#FORALL_UNCURRY-val">FORALL_UNCURRY</a> : thm
<a name="line31"></a>    val <a href="#FST-val">FST</a> : thm
<a name="line32"></a>    val <a href="#FST_PAIR_MAP-val">FST_PAIR_MAP</a> : thm
<a name="line33"></a>    val <a href="#LAMBDA_PROD-val">LAMBDA_PROD</a> : thm
<a name="line34"></a>    val <a href="#LET2_RAND-val">LET2_RAND</a> : thm
<a name="line35"></a>    val <a href="#LET2_RATOR-val">LET2_RATOR</a> : thm
<a name="line36"></a>    val <a href="#LEX_DEF_THM-val">LEX_DEF_THM</a> : thm
<a name="line37"></a>    val <a href="#PAIR_EQ-val">PAIR_EQ</a> : thm
<a name="line38"></a>    val <a href="#PAIR_FST_SND_EQ-val">PAIR_FST_SND_EQ</a> : thm
<a name="line39"></a>    val <a href="#PAIR_FUN_THM-val">PAIR_FUN_THM</a> : thm
<a name="line40"></a>    val <a href="#PAIR_MAP_THM-val">PAIR_MAP_THM</a> : thm
<a name="line41"></a>    val <a href="#PEXISTS_THM-val">PEXISTS_THM</a> : thm
<a name="line42"></a>    val <a href="#PFORALL_THM-val">PFORALL_THM</a> : thm
<a name="line43"></a>    val <a href="#SND-val">SND</a> : thm
<a name="line44"></a>    val <a href="#SND_PAIR_MAP-val">SND_PAIR_MAP</a> : thm
<a name="line45"></a>    val <a href="#S_UNCURRY_R-val">S_UNCURRY_R</a> : thm
<a name="line46"></a>    val <a href="#UNCURRY_CONG-val">UNCURRY_CONG</a> : thm
<a name="line47"></a>    val <a href="#UNCURRY_CURRY_THM-val">UNCURRY_CURRY_THM</a> : thm
<a name="line48"></a>    val <a href="#UNCURRY_DEF-val">UNCURRY_DEF</a> : thm
<a name="line49"></a>    val <a href="#UNCURRY_ONE_ONE_THM-val">UNCURRY_ONE_ONE_THM</a> : thm
<a name="line50"></a>    val <a href="#UNCURRY_VAR-val">UNCURRY_VAR</a> : thm
<a name="line51"></a>    val <a href="#WF_LEX-val">WF_LEX</a> : thm
<a name="line52"></a>    val <a href="#WF_RPROD-val">WF_RPROD</a> : thm
<a name="line53"></a>    val <a href="#o_UNCURRY_R-val">o_UNCURRY_R</a> : thm
<a name="line54"></a>    val <a href="#pair_Axiom-val">pair_Axiom</a> : thm
<a name="line55"></a>    val <a href="#pair_CASES-val">pair_CASES</a> : thm
<a name="line56"></a>    val <a href="#pair_case_cong-val">pair_case_cong</a> : thm
<a name="line57"></a>    val <a href="#pair_case_thm-val">pair_case_thm</a> : thm
<a name="line58"></a>    val <a href="#pair_induction-val">pair_induction</a> : thm
<a name="line59"></a>  
<a name="line60"></a>  val pair_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line61"></a>  
<a name="line62"></a>  val pair_rws : thm list
<a name="line63"></a>  
<a name="line64"></a>  
<a name="line65"></a>  type hol_type = Abbrev.hol_type
<a name="line66"></a>  type term     = Abbrev.term
<a name="line67"></a>  type conv     = Abbrev.conv
<a name="line68"></a>  
<a name="line69"></a>  val uncurry_tm       : term
<a name="line70"></a>  val comma_tm         : term
<a name="line71"></a>  val dest_pair        : term -&gt; term * term
<a name="line72"></a>  val strip_pair       : term -&gt; term list
<a name="line73"></a>  val spine_pair       : term -&gt; term list
<a name="line74"></a>  val is_vstruct       : term -&gt; bool
<a name="line75"></a>  val mk_pabs          : term * term -&gt; term
<a name="line76"></a>  val PAIRED_BETA_CONV : conv
<a name="line77"></a>  
<a name="line78"></a>(*
   [relation] Parent theory of "pair"
   
   [<a name="ABS_REP_prod-val"><b>ABS_REP_prod</b></a>]  Definition
      
      |- (∀a. ABS_prod (REP_prod a) = a) ∧
         ∀r.
           (λp. ∃x y. p = (λa b. (a = x) ∧ (b = y))) r ⇔ (REP_prod (ABS_prod r) = r)
   
   [<a name="COMMA_DEF-val"><b>COMMA_DEF</b></a>]  Definition
      
      |- ∀x y. (x,y) = ABS_prod (λa b. (a = x) ∧ (b = y))
   
   [<a name="CURRY_DEF-val"><b>CURRY_DEF</b></a>]  Definition
      
      |- ∀f x y. CURRY f x y = f (x,y)
   
   [<a name="LEX_DEF-val"><b>LEX_DEF</b></a>]  Definition
      
      |- ∀R1 R2. R1 LEX R2 = (λ(s,t) (u,v). R1 s u ∨ (s = u) ∧ R2 t v)
   
   [<a name="PAIR-val"><b>PAIR</b></a>]  Definition
      
      |- ∀x. (FST x,SND x) = x
   
   [<a name="PAIR_MAP-val"><b>PAIR_MAP</b></a>]  Definition
      
      |- ∀f g p. (f ## g) p = (f (FST p),g (SND p))
   
   [<a name="RPROD_DEF-val"><b>RPROD_DEF</b></a>]  Definition
      
      |- ∀R1 R2. RPROD R1 R2 = (λ(s,t) (u,v). R1 s u ∧ R2 t v)
   
   [<a name="UNCURRY-val"><b>UNCURRY</b></a>]  Definition
      
      |- ∀f v. UNCURRY f v = f (FST v) (SND v)
   
   [<a name="pair_case_def-val"><b>pair_case_def</b></a>]  Definition
      
      |- pair_case = UNCURRY
   
   [<a name="prod_TY_DEF-val"><b>prod_TY_DEF</b></a>]  Definition
      
      |- ∃rep. TYPE_DEFINITION (λp. ∃x y. p = (λa b. (a = x) ∧ (b = y))) rep
   
   [<a name="ABS_PAIR_THM-val"><b>ABS_PAIR_THM</b></a>]  Theorem
      
      |- ∀x. ∃q r. x = (q,r)
   
   [<a name="CLOSED_PAIR_EQ-val"><b>CLOSED_PAIR_EQ</b></a>]  Theorem
      
      |- ∀x y a b. ((x,y) = (a,b)) ⇔ (x = a) ∧ (y = b)
   
   [<a name="CURRY_ONE_ONE_THM-val"><b>CURRY_ONE_ONE_THM</b></a>]  Theorem
      
      |- (CURRY f = CURRY g) ⇔ (f = g)
   
   [<a name="CURRY_UNCURRY_THM-val"><b>CURRY_UNCURRY_THM</b></a>]  Theorem
      
      |- ∀f. CURRY (UNCURRY f) = f
   
   [<a name="C_UNCURRY_L-val"><b>C_UNCURRY_L</b></a>]  Theorem
      
      |- combin$C (UNCURRY f) x = UNCURRY (combin$C (combin$C o f) x)
   
   [<a name="ELIM_PEXISTS-val"><b>ELIM_PEXISTS</b></a>]  Theorem
      
      |- (∃p. P (FST p) (SND p)) ⇔ ∃p1 p2. P p1 p2
   
   [<a name="ELIM_PEXISTS_EVAL-val"><b>ELIM_PEXISTS_EVAL</b></a>]  Theorem
      
      |- $? (UNCURRY (λx. P x)) ⇔ ∃x. $? (P x)
   
   [<a name="ELIM_PFORALL-val"><b>ELIM_PFORALL</b></a>]  Theorem
      
      |- (∀p. P (FST p) (SND p)) ⇔ ∀p1 p2. P p1 p2
   
   [<a name="ELIM_PFORALL_EVAL-val"><b>ELIM_PFORALL_EVAL</b></a>]  Theorem
      
      |- $! (UNCURRY (λx. P x)) ⇔ ∀x. $! (P x)
   
   [<a name="ELIM_UNCURRY-val"><b>ELIM_UNCURRY</b></a>]  Theorem
      
      |- ∀f. UNCURRY f = (λx. f (FST x) (SND x))
   
   [<a name="EXISTS_PROD-val"><b>EXISTS_PROD</b></a>]  Theorem
      
      |- (∃p. P p) ⇔ ∃p_1 p_2. P (p_1,p_2)
   
   [<a name="FORALL_PROD-val"><b>FORALL_PROD</b></a>]  Theorem
      
      |- (∀p. P p) ⇔ ∀p_1 p_2. P (p_1,p_2)
   
   [<a name="FORALL_UNCURRY-val"><b>FORALL_UNCURRY</b></a>]  Theorem
      
      |- $! (UNCURRY f) ⇔ $! ($! o f)
   
   [<a name="FST-val"><b>FST</b></a>]  Theorem
      
      |- ∀x y. FST (x,y) = x
   
   [<a name="FST_PAIR_MAP-val"><b>FST_PAIR_MAP</b></a>]  Theorem
      
      |- ∀p f g. FST ((f ## g) p) = f (FST p)
   
   [<a name="LAMBDA_PROD-val"><b>LAMBDA_PROD</b></a>]  Theorem
      
      |- ∀P. (λp. P p) = (λ(p1,p2). P (p1,p2))
   
   [<a name="LET2_RAND-val"><b>LET2_RAND</b></a>]  Theorem
      
      |- ∀P M N. P (let (x,y) = M in N x y) = (let (x,y) = M in P (N x y))
   
   [<a name="LET2_RATOR-val"><b>LET2_RATOR</b></a>]  Theorem
      
      |- ∀M N b. (let (x,y) = M in N x y) b = (let (x,y) = M in N x y b)
   
   [<a name="LEX_DEF_THM-val"><b>LEX_DEF_THM</b></a>]  Theorem
      
      |- (R1 LEX R2) (a,b) (c,d) ⇔ R1 a c ∨ (a = c) ∧ R2 b d
   
   [<a name="PAIR_EQ-val"><b>PAIR_EQ</b></a>]  Theorem
      
      |- ((x,y) = (a,b)) ⇔ (x = a) ∧ (y = b)
   
   [<a name="PAIR_FST_SND_EQ-val"><b>PAIR_FST_SND_EQ</b></a>]  Theorem
      
      |- ∀p q. (p = q) ⇔ (FST p = FST q) ∧ (SND p = SND q)
   
   [<a name="PAIR_FUN_THM-val"><b>PAIR_FUN_THM</b></a>]  Theorem
      
      |- ∀P. (∃!f. P f) ⇔ ∃!p. P (λa. (FST p a,SND p a))
   
   [<a name="PAIR_MAP_THM-val"><b>PAIR_MAP_THM</b></a>]  Theorem
      
      |- ∀f g x y. (f ## g) (x,y) = (f x,g y)
   
   [<a name="PEXISTS_THM-val"><b>PEXISTS_THM</b></a>]  Theorem
      
      |- ∀P. (∃x y. P x y) ⇔ ∃(x,y). P x y
   
   [<a name="PFORALL_THM-val"><b>PFORALL_THM</b></a>]  Theorem
      
      |- ∀P. (∀x y. P x y) ⇔ ∀(x,y). P x y
   
   [<a name="SND-val"><b>SND</b></a>]  Theorem
      
      |- ∀x y. SND (x,y) = y
   
   [<a name="SND_PAIR_MAP-val"><b>SND_PAIR_MAP</b></a>]  Theorem
      
      |- ∀p f g. SND ((f ## g) p) = g (SND p)
   
   [<a name="S_UNCURRY_R-val"><b>S_UNCURRY_R</b></a>]  Theorem
      
      |- S f (UNCURRY g) = UNCURRY (S (S o $o f o $,) g)
   
   [<a name="UNCURRY_CONG-val"><b>UNCURRY_CONG</b></a>]  Theorem
      
      |- ∀M M' f.
           (M = M') ∧ (∀x y. (M' = (x,y)) ⇒ (f x y = f' x y)) ⇒
           (UNCURRY f M = UNCURRY f' M')
   
   [<a name="UNCURRY_CURRY_THM-val"><b>UNCURRY_CURRY_THM</b></a>]  Theorem
      
      |- ∀f. UNCURRY (CURRY f) = f
   
   [<a name="UNCURRY_DEF-val"><b>UNCURRY_DEF</b></a>]  Theorem
      
      |- ∀f x y. UNCURRY f (x,y) = f x y
   
   [<a name="UNCURRY_ONE_ONE_THM-val"><b>UNCURRY_ONE_ONE_THM</b></a>]  Theorem
      
      |- (UNCURRY f = UNCURRY g) ⇔ (f = g)
   
   [<a name="UNCURRY_VAR-val"><b>UNCURRY_VAR</b></a>]  Theorem
      
      |- ∀f v. UNCURRY f v = f (FST v) (SND v)
   
   [<a name="WF_LEX-val"><b>WF_LEX</b></a>]  Theorem
      
      |- ∀R Q. WF R ∧ WF Q ⇒ WF (R LEX Q)
   
   [<a name="WF_RPROD-val"><b>WF_RPROD</b></a>]  Theorem
      
      |- ∀R Q. WF R ∧ WF Q ⇒ WF (RPROD R Q)
   
   [<a name="o_UNCURRY_R-val"><b>o_UNCURRY_R</b></a>]  Theorem
      
      |- f o UNCURRY g = UNCURRY ($o f o g)
   
   [<a name="pair_Axiom-val"><b>pair_Axiom</b></a>]  Theorem
      
      |- ∀f. ∃fn. ∀x y. fn (x,y) = f x y
   
   [<a name="pair_CASES-val"><b>pair_CASES</b></a>]  Theorem
      
      |- ∀x. ∃q r. x = (q,r)
   
   [<a name="pair_case_cong-val"><b>pair_case_cong</b></a>]  Theorem
      
      |- ∀M M' f.
           (M = M') ∧ (∀x y. (M' = (x,y)) ⇒ (f x y = f' x y)) ⇒
           (pair_case f M = pair_case f' M')
   
   [<a name="pair_case_thm-val"><b>pair_case_thm</b></a>]  Theorem
      
      |- pair_case f (x,y) = f x y
   
   [<a name="pair_induction-val"><b>pair_induction</b></a>]  Theorem
      
      |- (∀p_1 p_2. P (p_1,p_2)) ⇒ ∀p. P p
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/pair/src/pairScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-6</a></em></p></body></html>
