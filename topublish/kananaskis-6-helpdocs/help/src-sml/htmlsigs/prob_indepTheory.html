<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure prob_indepTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure prob_indepTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/prob/prob_indepScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature prob_indepTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#alg_cover_def-val">alg_cover_def</a> : thm
<a name="line7"></a>    val <a href="#alg_cover_set_def-val">alg_cover_set_def</a> : thm
<a name="line8"></a>    val <a href="#indep_def-val">indep_def</a> : thm
<a name="line9"></a>    val <a href="#indep_set_def-val">indep_set_def</a> : thm
<a name="line10"></a>  
<a name="line11"></a>  (*  Theorems  *)
<a name="line12"></a>    val <a href="#ALG_COVER_EXISTS_UNIQUE-val">ALG_COVER_EXISTS_UNIQUE</a> : thm
<a name="line13"></a>    val <a href="#ALG_COVER_HEAD-val">ALG_COVER_HEAD</a> : thm
<a name="line14"></a>    val <a href="#ALG_COVER_SET_BASIC-val">ALG_COVER_SET_BASIC</a> : thm
<a name="line15"></a>    val <a href="#ALG_COVER_SET_CASES-val">ALG_COVER_SET_CASES</a> : thm
<a name="line16"></a>    val <a href="#ALG_COVER_SET_CASES_THM-val">ALG_COVER_SET_CASES_THM</a> : thm
<a name="line17"></a>    val <a href="#ALG_COVER_SET_INDUCTION-val">ALG_COVER_SET_INDUCTION</a> : thm
<a name="line18"></a>    val <a href="#ALG_COVER_STEP-val">ALG_COVER_STEP</a> : thm
<a name="line19"></a>    val <a href="#ALG_COVER_TAIL_MEASURABLE-val">ALG_COVER_TAIL_MEASURABLE</a> : thm
<a name="line20"></a>    val <a href="#ALG_COVER_TAIL_PROB-val">ALG_COVER_TAIL_PROB</a> : thm
<a name="line21"></a>    val <a href="#ALG_COVER_TAIL_STEP-val">ALG_COVER_TAIL_STEP</a> : thm
<a name="line22"></a>    val <a href="#ALG_COVER_UNIQUE-val">ALG_COVER_UNIQUE</a> : thm
<a name="line23"></a>    val <a href="#ALG_COVER_UNIV-val">ALG_COVER_UNIV</a> : thm
<a name="line24"></a>    val <a href="#ALG_COVER_WELL_DEFINED-val">ALG_COVER_WELL_DEFINED</a> : thm
<a name="line25"></a>    val <a href="#BIND_STEP-val">BIND_STEP</a> : thm
<a name="line26"></a>    val <a href="#INDEP_BIND-val">INDEP_BIND</a> : thm
<a name="line27"></a>    val <a href="#INDEP_BIND_SDEST-val">INDEP_BIND_SDEST</a> : thm
<a name="line28"></a>    val <a href="#INDEP_INDEP_SET-val">INDEP_INDEP_SET</a> : thm
<a name="line29"></a>    val <a href="#INDEP_INDEP_SET_LEMMA-val">INDEP_INDEP_SET_LEMMA</a> : thm
<a name="line30"></a>    val <a href="#INDEP_MEASURABLE1-val">INDEP_MEASURABLE1</a> : thm
<a name="line31"></a>    val <a href="#INDEP_MEASURABLE2-val">INDEP_MEASURABLE2</a> : thm
<a name="line32"></a>    val <a href="#INDEP_PROB-val">INDEP_PROB</a> : thm
<a name="line33"></a>    val <a href="#INDEP_SDEST-val">INDEP_SDEST</a> : thm
<a name="line34"></a>    val <a href="#INDEP_SET_BASIC-val">INDEP_SET_BASIC</a> : thm
<a name="line35"></a>    val <a href="#INDEP_SET_DISJOINT_DECOMP-val">INDEP_SET_DISJOINT_DECOMP</a> : thm
<a name="line36"></a>    val <a href="#INDEP_SET_LIST-val">INDEP_SET_LIST</a> : thm
<a name="line37"></a>    val <a href="#INDEP_SET_SYM-val">INDEP_SET_SYM</a> : thm
<a name="line38"></a>    val <a href="#INDEP_UNIT-val">INDEP_UNIT</a> : thm
<a name="line39"></a>    val <a href="#MAP_CONS_TL_FILTER-val">MAP_CONS_TL_FILTER</a> : thm
<a name="line40"></a>    val <a href="#PROB_INDEP_BOUND-val">PROB_INDEP_BOUND</a> : thm
<a name="line41"></a>  
<a name="line42"></a>  val prob_indep_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line43"></a>(*
   [prob] Parent theory of "prob_indep"
   
   [state_transformer] Parent theory of "prob_indep"
   
   [<a name="alg_cover_def-val"><b>alg_cover_def</b></a>]  Definition
      
      |- ‚àÄl x. alg_cover l x = @b. MEM b l ‚àß alg_embed b x
   
   [<a name="alg_cover_set_def-val"><b>alg_cover_set_def</b></a>]  Definition
      
      |- ‚àÄl.
           alg_cover_set l ‚áî
           alg_sorted l ‚àß alg_prefixfree l ‚àß (algebra_embed l = ùïå(:num -&gt; bool))
   
   [<a name="indep_def-val"><b>indep_def</b></a>]  Definition
      
      |- ‚àÄf.
           indep f ‚áî
           ‚àÉl r.
             alg_cover_set l ‚àß
             ‚àÄs. f s = (let c = alg_cover l s in (r c,SDROP (LENGTH c) s))
   
   [<a name="indep_set_def-val"><b>indep_set_def</b></a>]  Definition
      
      |- ‚àÄp q.
           indep_set p q ‚áî
           measurable p ‚àß measurable q ‚àß (prob (p ‚à© q) = prob p * prob q)
   
   [<a name="ALG_COVER_EXISTS_UNIQUE-val"><b>ALG_COVER_EXISTS_UNIQUE</b></a>]  Theorem
      
      |- ‚àÄl. alg_cover_set l ‚áí ‚àÄs. ‚àÉ!x. MEM x l ‚àß alg_embed x s
   
   [<a name="ALG_COVER_HEAD-val"><b>ALG_COVER_HEAD</b></a>]  Theorem
      
      |- ‚àÄl. alg_cover_set l ‚áí ‚àÄf. f o alg_cover l = algebra_embed (FILTER f l)
   
   [<a name="ALG_COVER_SET_BASIC-val"><b>ALG_COVER_SET_BASIC</b></a>]  Theorem
      
      |- ¬¨alg_cover_set [] ‚àß alg_cover_set [[]] ‚àß alg_cover_set [[T]; [F]]
   
   [<a name="ALG_COVER_SET_CASES-val"><b>ALG_COVER_SET_CASES</b></a>]  Theorem
      
      |- ‚àÄP.
           P [[]] ‚àß
           (‚àÄl1 l2.
              alg_cover_set l1 ‚àß alg_cover_set l2 ‚àß
              alg_cover_set (MAP (CONS T) l1 ++ MAP (CONS F) l2) ‚áí
              P (MAP (CONS T) l1 ++ MAP (CONS F) l2)) ‚áí
           ‚àÄl. alg_cover_set l ‚áí P l
   
   [<a name="ALG_COVER_SET_CASES_THM-val"><b>ALG_COVER_SET_CASES_THM</b></a>]  Theorem
      
      |- ‚àÄl.
           alg_cover_set l ‚áî
           (l = [[]]) ‚à®
           ‚àÉl1 l2.
             alg_cover_set l1 ‚àß alg_cover_set l2 ‚àß
             (l = MAP (CONS T) l1 ++ MAP (CONS F) l2)
   
   [<a name="ALG_COVER_SET_INDUCTION-val"><b>ALG_COVER_SET_INDUCTION</b></a>]  Theorem
      
      |- ‚àÄP.
           P [[]] ‚àß
           (‚àÄl1 l2.
              alg_cover_set l1 ‚àß alg_cover_set l2 ‚àß P l1 ‚àß P l2 ‚àß
              alg_cover_set (MAP (CONS T) l1 ++ MAP (CONS F) l2) ‚áí
              P (MAP (CONS T) l1 ++ MAP (CONS F) l2)) ‚áí
           ‚àÄl. alg_cover_set l ‚áí P l
   
   [<a name="ALG_COVER_STEP-val"><b>ALG_COVER_STEP</b></a>]  Theorem
      
      |- ‚àÄl1 l2 h t.
           alg_cover_set l1 ‚àß alg_cover_set l2 ‚áí
           (alg_cover (MAP (CONS T) l1 ++ MAP (CONS F) l2) (SCONS h t) =
            if h then T::alg_cover l1 t else F::alg_cover l2 t)
   
   [<a name="ALG_COVER_TAIL_MEASURABLE-val"><b>ALG_COVER_TAIL_MEASURABLE</b></a>]  Theorem
      
      |- ‚àÄl.
           alg_cover_set l ‚áí
           ‚àÄq. measurable (q o (Œªx. SDROP (LENGTH (alg_cover l x)) x)) ‚áî measurable q
   
   [<a name="ALG_COVER_TAIL_PROB-val"><b>ALG_COVER_TAIL_PROB</b></a>]  Theorem
      
      |- ‚àÄl.
           alg_cover_set l ‚áí
           ‚àÄq.
             measurable q ‚áí
             (prob (q o (Œªx. SDROP (LENGTH (alg_cover l x)) x)) = prob q)
   
   [<a name="ALG_COVER_TAIL_STEP-val"><b>ALG_COVER_TAIL_STEP</b></a>]  Theorem
      
      |- ‚àÄl1 l2 q.
           alg_cover_set l1 ‚àß alg_cover_set l2 ‚áí
           (q o
            (Œªx.
               SDROP (LENGTH (alg_cover (MAP (CONS T) l1 ++ MAP (CONS F) l2) x)) x) =
            (Œªx. SHD x ‚áî T) ‚à© q o (Œªx. SDROP (LENGTH (alg_cover l1 x)) x) o STL ‚à™
            (Œªx. SHD x ‚áî F) ‚à© q o (Œªx. SDROP (LENGTH (alg_cover l2 x)) x) o STL)
   
   [<a name="ALG_COVER_UNIQUE-val"><b>ALG_COVER_UNIQUE</b></a>]  Theorem
      
      |- ‚àÄl x s. alg_cover_set l ‚àß MEM x l ‚àß alg_embed x s ‚áí (alg_cover l s = x)
   
   [<a name="ALG_COVER_UNIV-val"><b>ALG_COVER_UNIV</b></a>]  Theorem
      
      |- alg_cover [[]] = K []
   
   [<a name="ALG_COVER_WELL_DEFINED-val"><b>ALG_COVER_WELL_DEFINED</b></a>]  Theorem
      
      |- ‚àÄl x. alg_cover_set l ‚áí MEM (alg_cover l x) l ‚àß alg_embed (alg_cover l x) x
   
   [<a name="BIND_STEP-val"><b>BIND_STEP</b></a>]  Theorem
      
      |- ‚àÄf. BIND SDEST (Œªk. f o SCONS k) = f
   
   [<a name="INDEP_BIND-val"><b>INDEP_BIND</b></a>]  Theorem
      
      |- ‚àÄf g. indep f ‚àß (‚àÄx. indep (g x)) ‚áí indep (BIND f g)
   
   [<a name="INDEP_BIND_SDEST-val"><b>INDEP_BIND_SDEST</b></a>]  Theorem
      
      |- ‚àÄf. (‚àÄx. indep (f x)) ‚áí indep (BIND SDEST f)
   
   [<a name="INDEP_INDEP_SET-val"><b>INDEP_INDEP_SET</b></a>]  Theorem
      
      |- ‚àÄf p q. indep f ‚àß measurable q ‚áí indep_set (p o FST o f) (q o SND o f)
   
   [<a name="INDEP_INDEP_SET_LEMMA-val"><b>INDEP_INDEP_SET_LEMMA</b></a>]  Theorem
      
      |- ‚àÄl.
           alg_cover_set l ‚áí
           ‚àÄq.
             measurable q ‚áí
             ‚àÄx.
               MEM x l ‚áí
               (prob (alg_embed x ‚à© q o (Œªx. SDROP (LENGTH (alg_cover l x)) x)) =
                (1 / 2) pow LENGTH x * prob q)
   
   [<a name="INDEP_MEASURABLE1-val"><b>INDEP_MEASURABLE1</b></a>]  Theorem
      
      |- ‚àÄf p. indep f ‚áí measurable (p o FST o f)
   
   [<a name="INDEP_MEASURABLE2-val"><b>INDEP_MEASURABLE2</b></a>]  Theorem
      
      |- ‚àÄf q. indep f ‚àß measurable q ‚áí measurable (q o SND o f)
   
   [<a name="INDEP_PROB-val"><b>INDEP_PROB</b></a>]  Theorem
      
      |- ‚àÄf p q.
           indep f ‚àß measurable q ‚áí
           (prob (p o FST o f ‚à© q o SND o f) = prob (p o FST o f) * prob q)
   
   [<a name="INDEP_SDEST-val"><b>INDEP_SDEST</b></a>]  Theorem
      
      |- indep SDEST
   
   [<a name="INDEP_SET_BASIC-val"><b>INDEP_SET_BASIC</b></a>]  Theorem
      
      |- ‚àÄp. measurable p ‚áí indep_set ‚àÖ p ‚àß indep_set ùïå(:num -&gt; bool) p
   
   [<a name="INDEP_SET_DISJOINT_DECOMP-val"><b>INDEP_SET_DISJOINT_DECOMP</b></a>]  Theorem
      
      |- ‚àÄp q r. indep_set p r ‚àß indep_set q r ‚àß (p ‚à© q = ‚àÖ) ‚áí indep_set (p ‚à™ q) r
   
   [<a name="INDEP_SET_LIST-val"><b>INDEP_SET_LIST</b></a>]  Theorem
      
      |- ‚àÄq l.
           alg_sorted l ‚àß alg_prefixfree l ‚àß measurable q ‚àß
           (‚àÄx. MEM x l ‚áí indep_set (alg_embed x) q) ‚áí
           indep_set (algebra_embed l) q
   
   [<a name="INDEP_SET_SYM-val"><b>INDEP_SET_SYM</b></a>]  Theorem
      
      |- ‚àÄp q. indep_set p q ‚áî indep_set p q
   
   [<a name="INDEP_UNIT-val"><b>INDEP_UNIT</b></a>]  Theorem
      
      |- ‚àÄx. indep (UNIT x)
   
   [<a name="MAP_CONS_TL_FILTER-val"><b>MAP_CONS_TL_FILTER</b></a>]  Theorem
      
      |- ‚àÄl b.
           ¬¨MEM [] l ‚áí
           (MAP (CONS b) (MAP TL (FILTER (Œªx. HD x ‚áî b) l)) =
            FILTER (Œªx. HD x ‚áî b) l)
   
   [<a name="PROB_INDEP_BOUND-val"><b>PROB_INDEP_BOUND</b></a>]  Theorem
      
      |- ‚àÄf n.
           indep f ‚áí
           (prob (Œªs. FST (f s) &lt; SUC n) =
            prob (Œªs. FST (f s) &lt; n) + prob (Œªs. FST (f s) = n))
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/prob/prob_indepScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-6</a></em></p></body></html>
