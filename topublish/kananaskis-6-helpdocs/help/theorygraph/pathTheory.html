<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: path</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "path"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "llistTheory.html"><span class="strong">llist</span></a>&nbsp;&nbsp;
    <a href = "fixedPointTheory.html"><span class="strong">fixedPoint</span></a>

<h1>Signature</h1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr> <th> Type <th> Arity<tr><td> <span class="strong">path</span> <td> 2
    <tr>
    <th>
    Constant
    <th>
    Type<tr><td>
            <span class="strong">PL</span>
            <td>
            :(Î±, Î²) path -> num -> bool
    <tr><td>
        <span class="strong">SN</span>
        <td>
        :(Î± -> Î² -> Î± -> bool) -> bool
    <tr><td>
        <span class="strong">drop</span>
        <td>
        :num -> (Î±, Î²) path -> (Î±, Î²) path
    <tr><td> <span class="strong">el</span> <td> :num -> (Î±, Î²) path -> Î±
    <tr><td>
        <span class="strong">every</span>
        <td>
        :(Î± -> bool) -> (Î±, Î²) path -> bool
    <tr><td>
        <span class="strong">exists</span>
        <td>
        :(Î± -> bool) -> (Î±, Î²) path -> bool
    <tr><td>
        <span class="strong">filter</span>
        <td>
        :(Î± -> bool) -> (Î±, Î²) path -> (Î±, Î²) path
    <tr><td> <span class="strong">finite</span> <td> :(Î±, Î²) path -> bool
    <tr><td> <span class="strong">first</span> <td> :(Î±, Î²) path -> Î±
    <tr><td>
        <span class="strong">firstP_at</span>
        <td>
        :(Î± -> bool) -> (Î±, Î²) path -> num -> bool
    <tr><td> <span class="strong">first_label</span> <td> :(Î±, Î²) path -> Î²
    <tr><td>
        <span class="strong">fromPath</span>
        <td>
        :(Î±, Î²) path -> Î± # (Î² # Î±) llist
    <tr><td> <span class="strong">is_stopped</span> <td> :(Î±, Î²) path -> bool
    <tr><td> <span class="strong">labels</span> <td> :(Î±, Î²) path -> Î² llist
    <tr><td> <span class="strong">last</span> <td> :(Î±, Î²) path -> Î±
    <tr><td>
        <span class="strong">length</span>
        <td>
        :(Î±, Î²) path -> num option
    <tr><td> <span class="strong">mem</span> <td> :Î± -> (Î±, Î²) path -> bool
    <tr><td>
        <span class="strong">nth_label</span>
        <td>
        :num -> (Î², Î±) path -> Î±
    <tr><td>
        <span class="strong">okpath</span>
        <td>
        :(Î± -> Î² -> Î± -> bool) -> (Î±, Î²) path -> bool
    <tr><td>
        <span class="strong">okpath_f</span>
        <td>
        :(Î± -> Î² -> Î± -> bool) -> ((Î±, Î²) path -> bool) -> (Î±, Î²) path -> bool
    <tr><td>
        <span class="strong">pconcat</span>
        <td>
        :(Î±, Î²) path -> Î² -> (Î±, Î²) path -> (Î±, Î²) path
    <tr><td>
        <span class="strong">pcons</span>
        <td>
        :Î± -> Î² -> (Î±, Î²) path -> (Î±, Î²) path
    <tr><td>
        <span class="strong">pgenerate</span>
        <td>
        :(num -> Î±) -> (num -> Î²) -> (Î±, Î²) path
    <tr><td>
        <span class="strong">plink</span>
        <td>
        :(Î±, Î²) path -> (Î±, Î²) path -> (Î±, Î²) path
    <tr><td>
        <span class="strong">pmap</span>
        <td>
        :(Î± -> Î³) -> (Î² -> Î´) -> (Î±, Î²) path -> (Î³, Î´) path
    <tr><td>
        <span class="strong">seg</span>
        <td>
        :num -> num -> (Î±, Î²) path -> (Î±, Î²) path
    <tr><td> <span class="strong">stopped_at</span> <td> :Î± -> (Î±, Î²) path
    <tr><td> <span class="strong">tail</span> <td> :(Î±, Î²) path -> (Î±, Î²) path
    <tr><td>
        <span class="strong">take</span>
        <td>
        :num -> (Î±, Î²) path -> (Î±, Î²) path
    <tr><td>
        <span class="strong">toPath</span>
        <td>
        :Î± # (Î² # Î±) llist -> (Î±, Î²) path
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">path_TY_DEF</span>
<DD>
<pre>
|- âˆƒrep. TYPE_DEFINITION (Î»x. T) rep
</pre>

<DT><span class="strong">path_absrep_bijections</span>
<DD>
<pre>
|- (âˆ€a. toPath (fromPath a) = a) âˆ§ âˆ€r. (Î»x. T) r â‡” (fromPath (toPath r) = r)
</pre>

<DT><span class="strong">first_def</span>
<DD>
<pre>
|- âˆ€p. first p = FST (fromPath p)
</pre>

<DT><span class="strong">stopped_at_def</span>
<DD>
<pre>
|- âˆ€x. stopped_at x = toPath (x,[||])
</pre>

<DT><span class="strong">pcons_def</span>
<DD>
<pre>
|- âˆ€x r p. pcons x r p = toPath (x,(r,first p):::SND (fromPath p))
</pre>

<DT><span class="strong">finite_def</span>
<DD>
<pre>
|- âˆ€sigma. finite sigma â‡” LFINITE (SND (fromPath sigma))
</pre>

<DT><span class="strong">last_thm</span>
<DD>
<pre>
|- (âˆ€x. last (stopped_at x) = x) âˆ§ âˆ€x r p. last (pcons x r p) = last p
</pre>

<DT><span class="strong">pmap_def</span>
<DD>
<pre>
|- âˆ€f g p. pmap f g p = toPath ((f ## LMAP (g ## f)) (fromPath p))
</pre>

<DT><span class="strong">tail_def</span>
<DD>
<pre>
|- âˆ€x r p. tail (pcons x r p) = p
</pre>

<DT><span class="strong">first_label_def</span>
<DD>
<pre>
|- âˆ€x r p. first_label (pcons x r p) = r
</pre>

<DT><span class="strong">length_def</span>
<DD>
<pre>
|- âˆ€p.
     length p =
     if finite p then
       SOME (LENGTH (THE (toList (SND (fromPath p)))) + 1)
     else
       NONE
</pre>

<DT><span class="strong">el_def</span>
<DD>
<pre>
|- (âˆ€p. el 0 p = first p) âˆ§ âˆ€n p. el (SUC n) p = el n (tail p)
</pre>

<DT><span class="strong">nth_label_def</span>
<DD>
<pre>
|- (âˆ€p. nth_label 0 p = first_label p) âˆ§
   âˆ€n p. nth_label (SUC n) p = nth_label n (tail p)
</pre>

<DT><span class="strong">pconcat_def</span>
<DD>
<pre>
|- âˆ€p1 lab p2.
     pconcat p1 lab p2 =
     toPath
       (first p1,
        LAPPEND (SND (fromPath p1)) ((lab,first p2):::SND (fromPath p2)))
</pre>

<DT><span class="strong">PL_def</span>
<DD>
<pre>
|- âˆ€p. PL p = {i | finite p â‡’ i < THE (length p)}
</pre>

<DT><span class="strong">firstP_at_def</span>
<DD>
<pre>
|- âˆ€P p i. firstP_at P p i â‡” i âˆˆ PL p âˆ§ P (el i p) âˆ§ âˆ€j. j < i â‡’ Â¬P (el j p)
</pre>

<DT><span class="strong">exists_def</span>
<DD>
<pre>
|- âˆ€P p. exists P p â‡” âˆƒi. firstP_at P p i
</pre>

<DT><span class="strong">every_def</span>
<DD>
<pre>
|- âˆ€P p. every P p â‡” Â¬exists ($~ o P) p
</pre>

<DT><span class="strong">mem_def</span>
<DD>
<pre>
|- âˆ€s p. mem s p â‡” âˆƒi. i âˆˆ PL p âˆ§ (s = el i p)
</pre>

<DT><span class="strong">drop_def</span>
<DD>
<pre>
|- (âˆ€p. drop 0 p = p) âˆ§ âˆ€n p. drop (SUC n) p = drop n (tail p)
</pre>

<DT><span class="strong">take_def</span>
<DD>
<pre>
|- (âˆ€p. take 0 p = stopped_at (first p)) âˆ§
   âˆ€n p. take (SUC n) p = pcons (first p) (first_label p) (take n (tail p))
</pre>

<DT><span class="strong">seg_def</span>
<DD>
<pre>
|- âˆ€i j p. seg i j p = take (j âˆ’ i) (drop i p)
</pre>

<DT><span class="strong">labels_def</span>
<DD>
<pre>
|- (âˆ€x. labels (stopped_at x) = [||]) âˆ§
   âˆ€x r p. labels (pcons x r p) = r:::labels p
</pre>

<DT><span class="strong">is_stopped_def</span>
<DD>
<pre>
|- âˆ€p. is_stopped p â‡” âˆƒx. p = stopped_at x
</pre>

<DT><span class="strong">filter_def</span>
<DD>
<pre>
|- âˆ€P.
     (âˆ€x. P x â‡’ (filter P (stopped_at x) = stopped_at x)) âˆ§
     âˆ€x r p.
       filter P (pcons x r p) =
       if P x then
         if exists P p then pcons x r (filter P p) else stopped_at x
       else
         filter P p
</pre>

<DT><span class="strong">pgenerate_def</span>
<DD>
<pre>
|- âˆ€f g. pgenerate f g = pcons (f 0) (g 0) (pgenerate (f o SUC) (g o SUC))
</pre>

<DT><span class="strong">okpath_f_def</span>
<DD>
<pre>
|- âˆ€R X.
     okpath_f R X =
     {stopped_at x | x âˆˆ ğ•Œ(:Î±)} âˆª {pcons x r p | R x r (first p) âˆ§ p âˆˆ X}
</pre>

<DT><span class="strong">okpath_def</span>
<DD>
<pre>
|- âˆ€R. okpath R = gfp (okpath_f R)
</pre>

<DT><span class="strong">plink_def</span>
<DD>
<pre>
|- (âˆ€x p. plink (stopped_at x) p = p) âˆ§
   âˆ€x r p1 p2. plink (pcons x r p1) p2 = pcons x r (plink p1 p2)
</pre>

<DT><span class="strong">SN_def</span>
<DD>
<pre>
|- âˆ€R. SN R â‡” WF (Î»x y. âˆƒl. R y l x)
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">path_rep_bijections_thm</span>
<DD>
<pre>
|- (âˆ€a. toPath (fromPath a) = a) âˆ§ âˆ€r. fromPath (toPath r) = r
</pre>

<DT><span class="strong">toPath_11</span>
<DD>
<pre>
|- âˆ€r r'. (toPath r = toPath r') â‡” (r = r')
</pre>

<DT><span class="strong">fromPath_11</span>
<DD>
<pre>
|- âˆ€a a'. (fromPath a = fromPath a') â‡” (a = a')
</pre>

<DT><span class="strong">fromPath_onto</span>
<DD>
<pre>
|- âˆ€r. âˆƒa. r = fromPath a
</pre>

<DT><span class="strong">toPath_onto</span>
<DD>
<pre>
|- âˆ€a. âˆƒr. a = toPath r
</pre>

<DT><span class="strong">stopped_at_11</span>
<DD>
<pre>
|- âˆ€x y. (stopped_at x = stopped_at y) â‡” (x = y)
</pre>

<DT><span class="strong">pcons_11</span>
<DD>
<pre>
|- âˆ€x r p y s q. (pcons x r p = pcons y s q) â‡” (x = y) âˆ§ (r = s) âˆ§ (p = q)
</pre>

<DT><span class="strong">stopped_at_not_pcons</span>
<DD>
<pre>
|- âˆ€x y r p. stopped_at x â‰  pcons y r p âˆ§ pcons y r p â‰  stopped_at x
</pre>

<DT><span class="strong">path_cases</span>
<DD>
<pre>
|- âˆ€p. (âˆƒx. p = stopped_at x) âˆ¨ âˆƒx r q. p = pcons x r q
</pre>

<DT><span class="strong">FORALL_path</span>
<DD>
<pre>
|- âˆ€P. (âˆ€p. P p) â‡” (âˆ€x. P (stopped_at x)) âˆ§ âˆ€x r p. P (pcons x r p)
</pre>

<DT><span class="strong">EXISTS_path</span>
<DD>
<pre>
|- âˆ€P. (âˆƒp. P p) â‡” (âˆƒx. P (stopped_at x)) âˆ¨ âˆƒx r p. P (pcons x r p)
</pre>

<DT><span class="strong">first_thm</span>
<DD>
<pre>
|- (âˆ€x. first (stopped_at x) = x) âˆ§ âˆ€x r p. first (pcons x r p) = x
</pre>

<DT><span class="strong">finite_thm</span>
<DD>
<pre>
|- (âˆ€x. finite (stopped_at x) â‡” T) âˆ§ âˆ€x r p. finite (pcons x r p) â‡” finite p
</pre>

<DT><span class="strong">path_bisimulation</span>
<DD>
<pre>
|- âˆ€p1 p2.
     (p1 = p2) â‡”
     âˆƒR.
       R p1 p2 âˆ§
       âˆ€q1 q2.
         R q1 q2 â‡’
         (âˆƒx. (q1 = stopped_at x) âˆ§ (q2 = stopped_at x)) âˆ¨
         âˆƒx r q1' q2'. (q1 = pcons x r q1') âˆ§ (q2 = pcons x r q2') âˆ§ R q1' q2'
</pre>

<DT><span class="strong">finite_path_ind</span>
<DD>
<pre>
|- âˆ€P.
     (âˆ€x. P (stopped_at x)) âˆ§ (âˆ€x r p. finite p âˆ§ P p â‡’ P (pcons x r p)) â‡’
     âˆ€q. finite q â‡’ P q
</pre>

<DT><span class="strong">pmap_thm</span>
<DD>
<pre>
|- (âˆ€x. pmap f g (stopped_at x) = stopped_at (f x)) âˆ§
   âˆ€x r p. pmap f g (pcons x r p) = pcons (f x) (g r) (pmap f g p)
</pre>

<DT><span class="strong">first_pmap</span>
<DD>
<pre>
|- âˆ€p. first (pmap f g p) = f (first p)
</pre>

<DT><span class="strong">last_pmap</span>
<DD>
<pre>
|- âˆ€p. finite p â‡’ (last (pmap f g p) = f (last p))
</pre>

<DT><span class="strong">finite_pmap</span>
<DD>
<pre>
|- âˆ€f g p. finite (pmap f g p) â‡” finite p
</pre>

<DT><span class="strong">length_thm</span>
<DD>
<pre>
|- (âˆ€x. length (stopped_at x) = SOME 1) âˆ§
   âˆ€x r p.
     length (pcons x r p) =
     if finite p then SOME (THE (length p) + 1) else NONE
</pre>

<DT><span class="strong">alt_length_thm</span>
<DD>
<pre>
|- (âˆ€x. length (stopped_at x) = SOME 1) âˆ§
   âˆ€x r p. length (pcons x r p) = OPTION_MAP SUC (length p)
</pre>

<DT><span class="strong">length_never_zero</span>
<DD>
<pre>
|- âˆ€p. length p â‰  SOME 0
</pre>

<DT><span class="strong">finite_length</span>
<DD>
<pre>
|- âˆ€p. (finite p â‡” âˆƒn. length p = SOME n) âˆ§ (Â¬finite p â‡” (length p = NONE))
</pre>

<DT><span class="strong">length_pmap</span>
<DD>
<pre>
|- âˆ€f g p. length (pmap f g p) = length p
</pre>

<DT><span class="strong">path_Axiom</span>
<DD>
<pre>
|- âˆ€f.
     âˆƒg.
       âˆ€x.
         g x =
         case f x of
            (y,NONE) -> stopped_at y
         || (y,SOME (l,v)) -> pcons y l (g v)
</pre>

<DT><span class="strong">pconcat_thm</span>
<DD>
<pre>
|- (âˆ€x lab p2. pconcat (stopped_at x) lab p2 = pcons x lab p2) âˆ§
   âˆ€x r p lab p2. pconcat (pcons x r p) lab p2 = pcons x r (pconcat p lab p2)
</pre>

<DT><span class="strong">pconcat_eq_stopped</span>
<DD>
<pre>
|- âˆ€p1 lab p2 x.
     pconcat p1 lab p2 â‰  stopped_at x âˆ§ stopped_at x â‰  pconcat p1 lab p2
</pre>

<DT><span class="strong">pconcat_eq_pcons</span>
<DD>
<pre>
|- âˆ€x r p p1 lab p2.
     ((pconcat p1 lab p2 = pcons x r p) â‡”
      (lab = r) âˆ§ (p1 = stopped_at x) âˆ§ (p = p2) âˆ¨
      âˆƒp1'. (p1 = pcons x r p1') âˆ§ (p = pconcat p1' lab p2)) âˆ§
     ((pcons x r p = pconcat p1 lab p2) â‡”
      (lab = r) âˆ§ (p1 = stopped_at x) âˆ§ (p = p2) âˆ¨
      âˆƒp1'. (p1 = pcons x r p1') âˆ§ (p = pconcat p1' lab p2))
</pre>

<DT><span class="strong">finite_pconcat</span>
<DD>
<pre>
|- âˆ€p1 lab p2. finite (pconcat p1 lab p2) â‡” finite p1 âˆ§ finite p2
</pre>

<DT><span class="strong">infinite_PL</span>
<DD>
<pre>
|- âˆ€p. Â¬finite p â‡’ âˆ€i. i âˆˆ PL p
</pre>

<DT><span class="strong">PL_pcons</span>
<DD>
<pre>
|- âˆ€x r q. PL (pcons x r q) = 0 INSERT IMAGE SUC (PL q)
</pre>

<DT><span class="strong">PL_stopped_at</span>
<DD>
<pre>
|- âˆ€x. PL (stopped_at x) = {0}
</pre>

<DT><span class="strong">PL_thm</span>
<DD>
<pre>
|- (âˆ€x. PL (stopped_at x) = {0}) âˆ§
   âˆ€x r q. PL (pcons x r q) = 0 INSERT IMAGE SUC (PL q)
</pre>

<DT><span class="strong">PL_0</span>
<DD>
<pre>
|- âˆ€p. 0 âˆˆ PL p
</pre>

<DT><span class="strong">PL_downward_closed</span>
<DD>
<pre>
|- âˆ€i p. i âˆˆ PL p â‡’ âˆ€j. j < i â‡’ j âˆˆ PL p
</pre>

<DT><span class="strong">PL_pmap</span>
<DD>
<pre>
|- PL (pmap f g p) = PL p
</pre>

<DT><span class="strong">el_pmap</span>
<DD>
<pre>
|- âˆ€i p. i âˆˆ PL p â‡’ (el i (pmap f g p) = f (el i p))
</pre>

<DT><span class="strong">nth_label_pmap</span>
<DD>
<pre>
|- âˆ€i p. SUC i âˆˆ PL p â‡’ (nth_label i (pmap f g p) = g (nth_label i p))
</pre>

<DT><span class="strong">firstP_at_thm</span>
<DD>
<pre>
|- (âˆ€P x n. firstP_at P (stopped_at x) n â‡” (n = 0) âˆ§ P x) âˆ§
   âˆ€P n x r p.
     firstP_at P (pcons x r p) n â‡”
     (n = 0) âˆ§ P x âˆ¨ 0 < n âˆ§ Â¬P x âˆ§ firstP_at P p (n âˆ’ 1)
</pre>

<DT><span class="strong">firstP_at_zero</span>
<DD>
<pre>
|- âˆ€P p. firstP_at P p 0 â‡” P (first p)
</pre>

<DT><span class="strong">exists_thm</span>
<DD>
<pre>
|- âˆ€P.
     (âˆ€x. exists P (stopped_at x) â‡” P x) âˆ§
     âˆ€x r p. exists P (pcons x r p) â‡” P x âˆ¨ exists P p
</pre>

<DT><span class="strong">every_thm</span>
<DD>
<pre>
|- âˆ€P.
     (âˆ€x. every P (stopped_at x) â‡” P x) âˆ§
     âˆ€x r p. every P (pcons x r p) â‡” P x âˆ§ every P p
</pre>

<DT><span class="strong">not_every</span>
<DD>
<pre>
|- âˆ€P p. Â¬every P p â‡” exists ($~ o P) p
</pre>

<DT><span class="strong">not_exists</span>
<DD>
<pre>
|- âˆ€P p. Â¬exists P p â‡” every ($~ o P) p
</pre>

<DT><span class="strong">exists_el</span>
<DD>
<pre>
|- âˆ€P p. exists P p â‡” âˆƒi. i âˆˆ PL p âˆ§ P (el i p)
</pre>

<DT><span class="strong">every_el</span>
<DD>
<pre>
|- âˆ€P p. every P p â‡” âˆ€i. i âˆˆ PL p â‡’ P (el i p)
</pre>

<DT><span class="strong">every_coinduction</span>
<DD>
<pre>
|- âˆ€P Q.
     (âˆ€x. P (stopped_at x) â‡’ Q x) âˆ§ (âˆ€x r p. P (pcons x r p) â‡’ Q x âˆ§ P p) â‡’
     âˆ€p. P p â‡’ every Q p
</pre>

<DT><span class="strong">exists_induction</span>
<DD>
<pre>
|- (âˆ€x. Q x â‡’ P (stopped_at x)) âˆ§ (âˆ€x r p. Q x â‡’ P (pcons x r p)) âˆ§
   (âˆ€x r p. P p â‡’ P (pcons x r p)) â‡’
   âˆ€p. exists Q p â‡’ P p
</pre>

<DT><span class="strong">mem_thm</span>
<DD>
<pre>
|- (âˆ€x s. mem s (stopped_at x) â‡” (s = x)) âˆ§
   âˆ€x r p s. mem s (pcons x r p) â‡” (s = x) âˆ¨ mem s p
</pre>

<DT><span class="strong">numeral_drop</span>
<DD>
<pre>
|- (âˆ€n p. drop (NUMERAL (BIT1 n)) p = drop (NUMERAL (BIT1 n) âˆ’ 1) (tail p)) âˆ§
   âˆ€n p. drop (NUMERAL (BIT2 n)) p = drop (NUMERAL (BIT1 n)) (tail p)
</pre>

<DT><span class="strong">finite_drop</span>
<DD>
<pre>
|- âˆ€p n. n âˆˆ PL p â‡’ (finite (drop n p) â‡” finite p)
</pre>

<DT><span class="strong">length_drop</span>
<DD>
<pre>
|- âˆ€p n.
     n âˆˆ PL p â‡’
     (length (drop n p) =
      case length p of NONE -> NONE || SOME m -> SOME (m âˆ’ n))
</pre>

<DT><span class="strong">PL_drop</span>
<DD>
<pre>
|- âˆ€p i. i âˆˆ PL p â‡’ (PL (drop i p) = IMAGE (Î»n. n âˆ’ i) (PL p))
</pre>

<DT><span class="strong">IN_PL_drop</span>
<DD>
<pre>
|- âˆ€i j p. i âˆˆ PL p â‡’ (j âˆˆ PL (drop i p) â‡” i + j âˆˆ PL p)
</pre>

<DT><span class="strong">first_drop</span>
<DD>
<pre>
|- âˆ€i p. i âˆˆ PL p â‡’ (first (drop i p) = el i p)
</pre>

<DT><span class="strong">first_label_drop</span>
<DD>
<pre>
|- âˆ€i p. i âˆˆ PL p â‡’ (first_label (drop i p) = nth_label i p)
</pre>

<DT><span class="strong">tail_drop</span>
<DD>
<pre>
|- âˆ€i p. i + 1 âˆˆ PL p â‡’ (tail (drop i p) = drop (i + 1) p)
</pre>

<DT><span class="strong">el_drop</span>
<DD>
<pre>
|- âˆ€i j p. i + j âˆˆ PL p â‡’ (el i (drop j p) = el (i + j) p)
</pre>

<DT><span class="strong">nth_label_drop</span>
<DD>
<pre>
|- âˆ€i j p. SUC (i + j) âˆˆ PL p â‡’ (nth_label i (drop j p) = nth_label (i + j) p)
</pre>

<DT><span class="strong">first_take</span>
<DD>
<pre>
|- âˆ€p i. first (take i p) = first p
</pre>

<DT><span class="strong">finite_take</span>
<DD>
<pre>
|- âˆ€p i. i âˆˆ PL p â‡’ finite (take i p)
</pre>

<DT><span class="strong">length_take</span>
<DD>
<pre>
|- âˆ€p i. i âˆˆ PL p â‡’ (length (take i p) = SOME (i + 1))
</pre>

<DT><span class="strong">PL_take</span>
<DD>
<pre>
|- âˆ€p i. i âˆˆ PL p â‡’ (PL (take i p) = {n | n â‰¤ i})
</pre>

<DT><span class="strong">last_take</span>
<DD>
<pre>
|- âˆ€i p. i âˆˆ PL p â‡’ (last (take i p) = el i p)
</pre>

<DT><span class="strong">nth_label_take</span>
<DD>
<pre>
|- âˆ€n p i. i < n âˆ§ n âˆˆ PL p â‡’ (nth_label i (take n p) = nth_label i p)
</pre>

<DT><span class="strong">singleton_seg</span>
<DD>
<pre>
|- âˆ€i p. i âˆˆ PL p â‡’ (seg i i p = stopped_at (el i p))
</pre>

<DT><span class="strong">recursive_seg</span>
<DD>
<pre>
|- âˆ€i j p.
     i < j âˆ§ j âˆˆ PL p â‡’
     (seg i j p = pcons (el i p) (nth_label i p) (seg (i + 1) j p))
</pre>

<DT><span class="strong">PL_seg</span>
<DD>
<pre>
|- âˆ€i j p. i â‰¤ j âˆ§ j âˆˆ PL p â‡’ (PL (seg i j p) = {n | n â‰¤ j âˆ’ i})
</pre>

<DT><span class="strong">finite_seg</span>
<DD>
<pre>
|- âˆ€p i j. i â‰¤ j âˆ§ j âˆˆ PL p â‡’ finite (seg i j p)
</pre>

<DT><span class="strong">first_seg</span>
<DD>
<pre>
|- âˆ€i j p. i â‰¤ j âˆ§ j âˆˆ PL p â‡’ (first (seg i j p) = el i p)
</pre>

<DT><span class="strong">last_seg</span>
<DD>
<pre>
|- âˆ€i j p. i â‰¤ j âˆ§ j âˆˆ PL p â‡’ (last (seg i j p) = el j p)
</pre>

<DT><span class="strong">firstP_at_unique</span>
<DD>
<pre>
|- âˆ€P p n. firstP_at P p n â‡’ âˆ€m. firstP_at P p m â‡” (m = n)
</pre>

<DT><span class="strong">is_stopped_thm</span>
<DD>
<pre>
|- (âˆ€x. is_stopped (stopped_at x) â‡” T) âˆ§ âˆ€x r p. is_stopped (pcons x r p) â‡” F
</pre>

<DT><span class="strong">filter_every</span>
<DD>
<pre>
|- âˆ€P p. exists P p â‡’ every P (filter P p)
</pre>

<DT><span class="strong">pgenerate_infinite</span>
<DD>
<pre>
|- âˆ€f g. Â¬finite (pgenerate f g)
</pre>

<DT><span class="strong">pgenerate_not_stopped</span>
<DD>
<pre>
|- âˆ€f g x. stopped_at x â‰  pgenerate f g
</pre>

<DT><span class="strong">el_pgenerate</span>
<DD>
<pre>
|- âˆ€n f g. el n (pgenerate f g) = f n
</pre>

<DT><span class="strong">nth_label_pgenerate</span>
<DD>
<pre>
|- âˆ€n f g. nth_label n (pgenerate f g) = g n
</pre>

<DT><span class="strong">pgenerate_11</span>
<DD>
<pre>
|- âˆ€f1 g1 f2 g2. (pgenerate f1 g1 = pgenerate f2 g2) â‡” (f1 = f2) âˆ§ (g1 = g2)
</pre>

<DT><span class="strong">pgenerate_onto</span>
<DD>
<pre>
|- âˆ€p. Â¬finite p â‡’ âˆƒf g. p = pgenerate f g
</pre>

<DT><span class="strong">okpath_monotone</span>
<DD>
<pre>
|- âˆ€R. monotone (okpath_f R)
</pre>

<DT><span class="strong">okpath_co_ind</span>
<DD>
<pre>
|- âˆ€P.
     (âˆ€x r p. P (pcons x r p) â‡’ R x r (first p) âˆ§ P p) â‡’ âˆ€p. P p â‡’ okpath R p
</pre>

<DT><span class="strong">okpath_cases</span>
<DD>
<pre>
|- âˆ€R x.
     okpath R x â‡”
     (âˆƒx'. x = stopped_at x') âˆ¨
     âˆƒx' r p. (x = pcons x' r p) âˆ§ R x' r (first p) âˆ§ okpath R p
</pre>

<DT><span class="strong">okpath_thm</span>
<DD>
<pre>
|- âˆ€R.
     (âˆ€x. okpath R (stopped_at x)) âˆ§
     âˆ€x r p. okpath R (pcons x r p) â‡” R x r (first p) âˆ§ okpath R p
</pre>

<DT><span class="strong">finite_okpath_ind</span>
<DD>
<pre>
|- âˆ€R.
     (âˆ€x. P (stopped_at x)) âˆ§
     (âˆ€x r p.
        okpath R p âˆ§ finite p âˆ§ R x r (first p) âˆ§ P p â‡’ P (pcons x r p)) â‡’
     âˆ€sigma. okpath R sigma âˆ§ finite sigma â‡’ P sigma
</pre>

<DT><span class="strong">okpath_pmap</span>
<DD>
<pre>
|- âˆ€R f g p.
     okpath R p âˆ§ (âˆ€x r y. R x r y â‡’ R (f x) (g r) (f y)) â‡’
     okpath R (pmap f g p)
</pre>

<DT><span class="strong">finite_plink</span>
<DD>
<pre>
|- âˆ€p1 p2. finite (plink p1 p2) â‡” finite p1 âˆ§ finite p2
</pre>

<DT><span class="strong">first_plink</span>
<DD>
<pre>
|- âˆ€p1 p2. (last p1 = first p2) â‡’ (first (plink p1 p2) = first p1)
</pre>

<DT><span class="strong">last_plink</span>
<DD>
<pre>
|- âˆ€p1 p2.
     finite p1 âˆ§ finite p2 âˆ§ (last p1 = first p2) â‡’
     (last (plink p1 p2) = last p2)
</pre>

<DT><span class="strong">okpath_plink</span>
<DD>
<pre>
|- âˆ€R p1 p2.
     finite p1 âˆ§ (last p1 = first p2) â‡’
     (okpath R (plink p1 p2) â‡” okpath R p1 âˆ§ okpath R p2)
</pre>

<DT><span class="strong">okpath_take</span>
<DD>
<pre>
|- âˆ€R p i. i âˆˆ PL p âˆ§ okpath R p â‡’ okpath R (take i p)
</pre>

<DT><span class="strong">okpath_drop</span>
<DD>
<pre>
|- âˆ€R p i. i âˆˆ PL p âˆ§ okpath R p â‡’ okpath R (drop i p)
</pre>

<DT><span class="strong">okpath_seg</span>
<DD>
<pre>
|- âˆ€R p i j. i â‰¤ j âˆ§ j âˆˆ PL p âˆ§ okpath R p â‡’ okpath R (seg i j p)
</pre>

<DT><span class="strong">SN_finite_paths</span>
<DD>
<pre>
|- âˆ€R p. SN R âˆ§ okpath R p â‡’ finite p
</pre>

<DT><span class="strong">finite_paths_SN</span>
<DD>
<pre>
|- âˆ€R. (âˆ€p. okpath R p â‡’ finite p) â‡’ SN R
</pre>

<DT><span class="strong">SN_finite_paths_EQ</span>
<DD>
<pre>
|- âˆ€R. SN R â‡” âˆ€p. okpath R p â‡’ finite p
</pre>

</DL>



<hr>
</body>
</html>
