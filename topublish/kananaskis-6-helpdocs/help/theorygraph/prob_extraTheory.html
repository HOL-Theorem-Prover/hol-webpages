<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: prob_extra</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "prob_extra"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "transcTheory.html"><span class="strong">transc</span></a>&nbsp;&nbsp;
    <a href = "polyTheory.html"><span class="strong">poly</span></a>

<h1>Signature</h1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr>
    <th>
    Constant
    <th>
    Type<tr><td> <span class="strong">inf</span> <td> :(real -> bool) -> real
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">inf_def</span>
<DD>
<pre>
|- ∀P. inf P = -sup (IMAGE numeric_negate P)
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">EQ_EXT_EQ</span>
<DD>
<pre>
|- ∀f g. (∀x. f x = g x) ⇔ (f = g)
</pre>

<DT><span class="strong">RAND_THM</span>
<DD>
<pre>
|- ∀f x y. (x = y) ⇒ (f x = f y)
</pre>

<DT><span class="strong">BOOL_BOOL_CASES_THM</span>
<DD>
<pre>
|- ∀f. (f = (λb. F)) ∨ (f = (λb. T)) ∨ (f = (λb. b)) ∨ (f = (λb. ¬b))
</pre>

<DT><span class="strong">BOOL_BOOL_CASES</span>
<DD>
<pre>
|- ∀P. P (λb. F) ∧ P (λb. T) ∧ P (λb. b) ∧ P (λb. ¬b) ⇒ ∀f. P f
</pre>

<DT><span class="strong">EVEN_ODD_BASIC</span>
<DD>
<pre>
|- EVEN 0 ∧ ¬EVEN 1 ∧ EVEN 2 ∧ ¬ODD 0 ∧ ODD 1 ∧ ¬ODD 2
</pre>

<DT><span class="strong">EVEN_ODD_EXISTS_EQ</span>
<DD>
<pre>
|- ∀n. (EVEN n ⇔ ∃m. n = 2 * m) ∧ (ODD n ⇔ ∃m. n = SUC (2 * m))
</pre>

<DT><span class="strong">DIV_THEN_MULT</span>
<DD>
<pre>
|- ∀p q. SUC q * (p DIV SUC q) ≤ p
</pre>

<DT><span class="strong">DIV_TWO_UNIQUE</span>
<DD>
<pre>
|- ∀n q r.
     (n = 2 * q + r) ∧ ((r = 0) ∨ (r = 1)) ⇒ (q = n DIV 2) ∧ (r = n MOD 2)
</pre>

<DT><span class="strong">DIVISION_TWO</span>
<DD>
<pre>
|- ∀n. (n = 2 * (n DIV 2) + n MOD 2) ∧ ((n MOD 2 = 0) ∨ (n MOD 2 = 1))
</pre>

<DT><span class="strong">DIV_TWO</span>
<DD>
<pre>
|- ∀n. n = 2 * (n DIV 2) + n MOD 2
</pre>

<DT><span class="strong">MOD_TWO</span>
<DD>
<pre>
|- ∀n. n MOD 2 = if EVEN n then 0 else 1
</pre>

<DT><span class="strong">DIV_TWO_BASIC</span>
<DD>
<pre>
|- (0 DIV 2 = 0) ∧ (1 DIV 2 = 0) ∧ (2 DIV 2 = 1)
</pre>

<DT><span class="strong">DIV_TWO_MONO</span>
<DD>
<pre>
|- ∀m n. m DIV 2 < n DIV 2 ⇒ m < n
</pre>

<DT><span class="strong">DIV_TWO_MONO_EVEN</span>
<DD>
<pre>
|- ∀m n. EVEN n ⇒ (m DIV 2 < n DIV 2 ⇔ m < n)
</pre>

<DT><span class="strong">DIV_TWO_CANCEL</span>
<DD>
<pre>
|- ∀n. (2 * n DIV 2 = n) ∧ (SUC (2 * n) DIV 2 = n)
</pre>

<DT><span class="strong">EXP_DIV_TWO</span>
<DD>
<pre>
|- ∀n. 2 ** SUC n DIV 2 = 2 ** n
</pre>

<DT><span class="strong">EVEN_EXP_TWO</span>
<DD>
<pre>
|- ∀n. EVEN (2 ** n) ⇔ n ≠ 0
</pre>

<DT><span class="strong">DIV_TWO_EXP</span>
<DD>
<pre>
|- ∀n k. k DIV 2 < 2 ** n ⇔ k < 2 ** SUC n
</pre>

<DT><span class="strong">INF_DEF_ALT</span>
<DD>
<pre>
|- ∀P. inf P = -sup (λr. P (-r))
</pre>

<DT><span class="strong">REAL_LE_EQ</span>
<DD>
<pre>
|- ∀x y. x ≤ y ∧ y ≤ x ⇒ (x = y)
</pre>

<DT><span class="strong">REAL_SUP_EXISTS_UNIQUE</span>
<DD>
<pre>
|- ∀P. (∃x. P x) ∧ (∃z. ∀x. P x ⇒ x ≤ z) ⇒ ∃!s. ∀y. (∃x. P x ∧ y < x) ⇔ y < s
</pre>

<DT><span class="strong">REAL_SUP_MAX</span>
<DD>
<pre>
|- ∀P z. P z ∧ (∀x. P x ⇒ x ≤ z) ⇒ (sup P = z)
</pre>

<DT><span class="strong">REAL_INF_MIN</span>
<DD>
<pre>
|- ∀P z. P z ∧ (∀x. P x ⇒ z ≤ x) ⇒ (inf P = z)
</pre>

<DT><span class="strong">HALF_POS</span>
<DD>
<pre>
|- 0 < 1 / 2
</pre>

<DT><span class="strong">HALF_CANCEL</span>
<DD>
<pre>
|- 2 * (1 / 2) = 1
</pre>

<DT><span class="strong">POW_HALF_POS</span>
<DD>
<pre>
|- ∀n. 0 < (1 / 2) pow n
</pre>

<DT><span class="strong">POW_HALF_MONO</span>
<DD>
<pre>
|- ∀m n. m ≤ n ⇒ (1 / 2) pow n ≤ (1 / 2) pow m
</pre>

<DT><span class="strong">POW_HALF_TWICE</span>
<DD>
<pre>
|- ∀n. (1 / 2) pow n = 2 * (1 / 2) pow SUC n
</pre>

<DT><span class="strong">X_HALF_HALF</span>
<DD>
<pre>
|- ∀x. 1 / 2 * x + 1 / 2 * x = x
</pre>

<DT><span class="strong">REAL_SUP_LE_X</span>
<DD>
<pre>
|- ∀P x. (∃r. P r) ∧ (∀r. P r ⇒ r ≤ x) ⇒ sup P ≤ x
</pre>

<DT><span class="strong">REAL_X_LE_SUP</span>
<DD>
<pre>
|- ∀P x. (∃r. P r) ∧ (∃z. ∀r. P r ⇒ r ≤ z) ∧ (∃r. P r ∧ x ≤ r) ⇒ x ≤ sup P
</pre>

<DT><span class="strong">REAL_INVINV_ALL</span>
<DD>
<pre>
|- ∀x. inv (inv x) = x
</pre>

<DT><span class="strong">ABS_BETWEEN_LE</span>
<DD>
<pre>
|- ∀x y d. 0 ≤ d ∧ x − d ≤ y ∧ y ≤ x + d ⇔ abs (y − x) ≤ d
</pre>

<DT><span class="strong">ONE_MINUS_HALF</span>
<DD>
<pre>
|- 1 − 1 / 2 = 1 / 2
</pre>

<DT><span class="strong">HALF_LT_1</span>
<DD>
<pre>
|- 1 / 2 < 1
</pre>

<DT><span class="strong">REAL_POW</span>
<DD>
<pre>
|- ∀m n. &m pow n = &(m ** n)
</pre>

<DT><span class="strong">POW_HALF_EXP</span>
<DD>
<pre>
|- ∀n. (1 / 2) pow n = inv (&(2 ** n))
</pre>

<DT><span class="strong">REAL_LE_INV_LE</span>
<DD>
<pre>
|- ∀x y. 0 < x ∧ x ≤ y ⇒ inv y ≤ inv x
</pre>

<DT><span class="strong">INV_SUC_POS</span>
<DD>
<pre>
|- ∀n. 0 < 1 / &SUC n
</pre>

<DT><span class="strong">INV_SUC_MAX</span>
<DD>
<pre>
|- ∀n. 1 / &SUC n ≤ 1
</pre>

<DT><span class="strong">INV_SUC</span>
<DD>
<pre>
|- ∀n. 0 < 1 / &SUC n ∧ 1 / &SUC n ≤ 1
</pre>

<DT><span class="strong">ABS_UNIT_INTERVAL</span>
<DD>
<pre>
|- ∀x y. 0 ≤ x ∧ x ≤ 1 ∧ 0 ≤ y ∧ y ≤ 1 ⇒ abs (x − y) ≤ 1
</pre>

<DT><span class="strong">MEM_NIL</span>
<DD>
<pre>
|- ∀l. (∀x. ¬MEM x l) ⇔ (l = [])
</pre>

<DT><span class="strong">MAP_ID</span>
<DD>
<pre>
|- ∀l. MAP (λx. x) l = l
</pre>

<DT><span class="strong">MAP_MEM</span>
<DD>
<pre>
|- ∀f l x. MEM x (MAP f l) ⇔ ∃y. MEM y l ∧ (x = f y)
</pre>

<DT><span class="strong">APPEND_MEM</span>
<DD>
<pre>
|- ∀x l1 l2. MEM x (l1 ++ l2) ⇔ MEM x l1 ∨ MEM x l2
</pre>

<DT><span class="strong">MEM_NIL_MAP_CONS</span>
<DD>
<pre>
|- ∀x l. ¬MEM [] (MAP (CONS x) l)
</pre>

<DT><span class="strong">FILTER_TRUE</span>
<DD>
<pre>
|- ∀l. FILTER (λx. T) l = l
</pre>

<DT><span class="strong">FILTER_FALSE</span>
<DD>
<pre>
|- ∀l. FILTER (λx. F) l = []
</pre>

<DT><span class="strong">LENGTH_FILTER</span>
<DD>
<pre>
|- ∀P l. LENGTH (FILTER P l) ≤ LENGTH l
</pre>

<DT><span class="strong">FILTER_MEM</span>
<DD>
<pre>
|- ∀P x l. MEM x (FILTER P l) ⇒ P x
</pre>

<DT><span class="strong">MEM_FILTER</span>
<DD>
<pre>
|- ∀P l x. MEM x (FILTER P l) ⇒ MEM x l
</pre>

<DT><span class="strong">FILTER_OUT_ELT</span>
<DD>
<pre>
|- ∀x l. MEM x l ∨ (FILTER (λy. y ≠ x) l = l)
</pre>

<DT><span class="strong">IS_PREFIX_NIL</span>
<DD>
<pre>
|- ∀x. [] ≼ x ∧ (x ≼ [] ⇔ (x = []))
</pre>

<DT><span class="strong">IS_PREFIX_REFL</span>
<DD>
<pre>
|- ∀x. x ≼ x
</pre>

<DT><span class="strong">IS_PREFIX_ANTISYM</span>
<DD>
<pre>
|- ∀x y. x ≼ y ∧ y ≼ x ⇒ (x = y)
</pre>

<DT><span class="strong">IS_PREFIX_TRANS</span>
<DD>
<pre>
|- ∀x y z. y ≼ x ∧ z ≼ y ⇒ z ≼ x
</pre>

<DT><span class="strong">IS_PREFIX_BUTLAST</span>
<DD>
<pre>
|- ∀x y. FRONT (x::y) ≼ x::y
</pre>

<DT><span class="strong">IS_PREFIX_LENGTH</span>
<DD>
<pre>
|- ∀x y. x ≼ y ⇒ LENGTH x ≤ LENGTH y
</pre>

<DT><span class="strong">IS_PREFIX_LENGTH_ANTI</span>
<DD>
<pre>
|- ∀x y. x ≼ y ∧ (LENGTH x = LENGTH y) ⇒ (x = y)
</pre>

<DT><span class="strong">IS_PREFIX_SNOC</span>
<DD>
<pre>
|- ∀x y z. z ≼ SNOC x y ⇔ z ≼ y ∨ (z = SNOC x y)
</pre>

<DT><span class="strong">FOLDR_MAP</span>
<DD>
<pre>
|- ∀f e g l. FOLDR f e (MAP g l) = FOLDR (λx y. f (g x) y) e l
</pre>

<DT><span class="strong">LAST_MEM</span>
<DD>
<pre>
|- ∀h t. MEM (LAST (h::t)) (h::t)
</pre>

<DT><span class="strong">LAST_MAP_CONS</span>
<DD>
<pre>
|- ∀b h t. ∃x. LAST (MAP (CONS b) (h::t)) = b::x
</pre>

<DT><span class="strong">EXISTS_LONGEST</span>
<DD>
<pre>
|- ∀x y. ∃z. MEM z (x::y) ∧ ∀w. MEM w (x::y) ⇒ LENGTH w ≤ LENGTH z
</pre>

<DT><span class="strong">SET_EQ_EXT</span>
<DD>
<pre>
|- ∀s t. (s = t) ⇔ ∀v. v ∈ s ⇔ v ∈ t
</pre>

<DT><span class="strong">UNION_DEF_ALT</span>
<DD>
<pre>
|- ∀s t. s ∪ t = (λx. s x ∨ t x)
</pre>

<DT><span class="strong">INTER_UNION_RDISTRIB</span>
<DD>
<pre>
|- ∀p q r. (p ∪ q) ∩ r = p ∩ r ∪ q ∩ r
</pre>

<DT><span class="strong">SUBSET_EQ</span>
<DD>
<pre>
|- ∀s t. (s = t) ⇔ s ⊆ t ∧ t ⊆ s
</pre>

<DT><span class="strong">SUBSET_EQ_DECOMP</span>
<DD>
<pre>
|- ∀s t. s ⊆ t ∧ t ⊆ s ⇒ (s = t)
</pre>

<DT><span class="strong">INTER_IS_EMPTY</span>
<DD>
<pre>
|- ∀s t. (s ∩ t = ∅) ⇔ ∀x. ¬s x ∨ ¬t x
</pre>

<DT><span class="strong">UNION_DISJOINT_SPLIT</span>
<DD>
<pre>
|- ∀s t u. (s ∪ t = s ∪ u) ∧ (s ∩ t = ∅) ∧ (s ∩ u = ∅) ⇒ (t = u)
</pre>

<DT><span class="strong">IN_COMPL</span>
<DD>
<pre>
|- ∀x s. x ∈ COMPL s ⇔ x ∉ s
</pre>

<DT><span class="strong">IN_EMPTY</span>
<DD>
<pre>
|- ∀x. x ∉ ∅
</pre>

<DT><span class="strong">GSPEC_DEF_ALT</span>
<DD>
<pre>
|- ∀f. GSPEC f = (λv. ∃x. (v,T) = f x)
</pre>

<DT><span class="strong">COMPL_COMPL</span>
<DD>
<pre>
|- ∀s. COMPL (COMPL s) = s
</pre>

<DT><span class="strong">COMPL_CLAUSES</span>
<DD>
<pre>
|- ∀s. (COMPL s ∩ s = ∅) ∧ (COMPL s ∪ s = 𝕌(:α))
</pre>

<DT><span class="strong">COMPL_SPLITS</span>
<DD>
<pre>
|- ∀p q. p ∩ q ∪ COMPL p ∩ q = q
</pre>

<DT><span class="strong">INTER_UNION_COMPL</span>
<DD>
<pre>
|- ∀s t. s ∩ t = COMPL (COMPL s ∪ COMPL t)
</pre>

</DL>



<hr>
</body>
</html>
