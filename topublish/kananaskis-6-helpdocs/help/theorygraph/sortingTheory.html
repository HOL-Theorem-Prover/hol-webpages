<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: sorting</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "sorting"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "listTheory.html"><span class="strong">list</span></a>

<h1>Signature</h1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr>
    <th>
    Constant
    <th>
    Type<tr><td>
            <span class="strong">PART</span>
            <td>
            :(α -> bool) -> α list -> α list -> α list -> α list # α list
    <tr><td>
        <span class="strong">PARTITION</span>
        <td>
        :(α -> bool) -> α list -> α list # α list
    <tr><td> <span class="strong">PERM</span> <td> :α list -> α list -> bool
    <tr><td>
        <span class="strong">PERM_SINGLE_SWAP</span>
        <td>
        :α list -> α list -> bool
    <tr><td>
        <span class="strong">QSORT</span>
        <td>
        :(α -> α -> bool) -> α list -> α list
    <tr><td>
        <span class="strong">QSORT_tupled</span>
        <td>
        :(α -> α -> bool) # α list -> α list
    <tr><td>
        <span class="strong">SORTED</span>
        <td>
        :(α -> α -> bool) -> α list -> bool
    <tr><td>
        <span class="strong">SORTED_tupled</span>
        <td>
        :(α -> α -> bool) # α list -> bool
    <tr><td>
        <span class="strong">SORTS</span>
        <td>
        :((α -> α -> bool) -> α list -> α list) -> (α -> α -> bool) -> bool
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">PERM_DEF</span>
<DD>
<pre>
|- ∀L1 L2. PERM L1 L2 ⇔ ∀x. FILTER ($= x) L1 = FILTER ($= x) L2
</pre>

<DT><span class="strong">SORTED_tupled_primitive_DEF</span>
<DD>
<pre>
|- SORTED_tupled =
   WFREC (@R'. WF R' ∧ ∀x rst y R. R' (R,y::rst) (R,x::y::rst))
     (λSORTED_tupled a.
        case a of
           (R,[]) -> I T
        || (R,[x]) -> I T
        || (R,x::y::rst) -> I (R x y ∧ SORTED_tupled (R,y::rst)))
</pre>

<DT><span class="strong">SORTED_curried_DEF</span>
<DD>
<pre>
|- ∀x x1. SORTED x x1 ⇔ SORTED_tupled (x,x1)
</pre>

<DT><span class="strong">SORTS_DEF</span>
<DD>
<pre>
|- ∀f R. SORTS f R ⇔ ∀l. PERM l (f R l) ∧ SORTED R (f R l)
</pre>

<DT><span class="strong">PART_DEF</span>
<DD>
<pre>
|- (∀P l1 l2. PART P [] l1 l2 = (l1,l2)) ∧
   ∀P h rst l1 l2.
     PART P (h::rst) l1 l2 =
     if P h then PART P rst (h::l1) l2 else PART P rst l1 (h::l2)
</pre>

<DT><span class="strong">PARTITION_DEF</span>
<DD>
<pre>
|- ∀P l. PARTITION P l = PART P l [] []
</pre>

<DT><span class="strong">QSORT_tupled_primitive_DEF</span>
<DD>
<pre>
|- QSORT_tupled =
   WFREC
     (@R.
        WF R ∧
        (∀t h ord l1 l2.
           ((l1,l2) = PARTITION (λy. ord y h) t) ⇒ R (ord,l2) (ord,h::t)) ∧
        ∀t h ord l1 l2.
          ((l1,l2) = PARTITION (λy. ord y h) t) ⇒ R (ord,l1) (ord,h::t))
     (λQSORT_tupled a.
        case a of
           (ord,[]) -> I []
        || (ord,h::t) ->
             I
               (let (l1,l2) = PARTITION (λy. ord y h) t
                in
                  QSORT_tupled (ord,l1) ++ [h] ++ QSORT_tupled (ord,l2)))
</pre>

<DT><span class="strong">QSORT_curried_DEF</span>
<DD>
<pre>
|- ∀x x1. QSORT x x1 = QSORT_tupled (x,x1)
</pre>

<DT><span class="strong">PERM_SINGLE_SWAP_DEF</span>
<DD>
<pre>
|- ∀l1 l2.
     PERM_SINGLE_SWAP l1 l2 ⇔
     ∃x1 x2 x3. (l1 = x1 ++ x2 ++ x3) ∧ (l2 = x1 ++ x3 ++ x2)
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">PERM_FUN_APPEND_APPEND_2</span>
<DD>
<pre>
|- ∀l1 l2 l3 l4.
     (PERM l1 = PERM (l2 ++ l3)) ⇒ (PERM (l4 ++ l1) = PERM (l2 ++ (l4 ++ l3)))
</pre>

<DT><span class="strong">PERM_FUN_APPEND_APPEND_1</span>
<DD>
<pre>
|- ∀l1 l2 l3 l4.
     (PERM l1 = PERM (l2 ++ l3)) ⇒ (PERM (l1 ++ l4) = PERM (l2 ++ (l3 ++ l4)))
</pre>

<DT><span class="strong">PERM_FUN_CONS_APPEND_2</span>
<DD>
<pre>
|- ∀l l1 x l2.
     (PERM l1 = PERM (x::l2)) ⇒ (PERM (l ++ l1) = PERM (x::(l ++ l2)))
</pre>

<DT><span class="strong">PERM_FUN_CONS_APPEND_1</span>
<DD>
<pre>
|- ∀l l1 x l2.
     (PERM l1 = PERM (x::l2)) ⇒ (PERM (l1 ++ l) = PERM (x::(l2 ++ l)))
</pre>

<DT><span class="strong">PERM_FUN_CONS_11_APPEND</span>
<DD>
<pre>
|- ∀y l1 l2 l3.
     (PERM l1 = PERM (l2 ++ l3)) ⇒ (PERM (y::l1) = PERM (l2 ++ y::l3))
</pre>

<DT><span class="strong">PERM_FUN_CONS_11_SWAP_AT_FRONT</span>
<DD>
<pre>
|- ∀y l1 x l2. (PERM l1 = PERM (x::l2)) ⇒ (PERM (y::l1) = PERM (x::y::l2))
</pre>

<DT><span class="strong">PERM_FUN_SWAP_AT_FRONT</span>
<DD>
<pre>
|- ∀x y l. PERM (x::y::l) = PERM (y::x::l)
</pre>

<DT><span class="strong">PERM_FUN_APPEND_CONS</span>
<DD>
<pre>
|- ∀x l1 l2. PERM (l1 ++ x::l2) = PERM (x::l1 ++ l2)
</pre>

<DT><span class="strong">PERM_FUN_CONS</span>
<DD>
<pre>
|- ∀x l1 l1'. (PERM l1 = PERM l1') ⇒ (PERM (x::l1) = PERM (x::l1'))
</pre>

<DT><span class="strong">PERM_REFL</span>
<DD>
<pre>
|- ∀L. PERM L L
</pre>

<DT><span class="strong">PERM_INTRO</span>
<DD>
<pre>
|- ∀x y. (x = y) ⇒ PERM x y
</pre>

<DT><span class="strong">PERM_transitive</span>
<DD>
<pre>
|- transitive PERM
</pre>

<DT><span class="strong">PERM_TRANS</span>
<DD>
<pre>
|- ∀x y z. PERM x y ∧ PERM y z ⇒ PERM x z
</pre>

<DT><span class="strong">PERM_SYM</span>
<DD>
<pre>
|- ∀l1 l2. PERM l1 l2 ⇔ PERM l2 l1
</pre>

<DT><span class="strong">PERM_CONG</span>
<DD>
<pre>
|- ∀L1 L2 L3 L4. PERM L1 L3 ∧ PERM L2 L4 ⇒ PERM (L1 ++ L2) (L3 ++ L4)
</pre>

<DT><span class="strong">PERM_MONO</span>
<DD>
<pre>
|- ∀l1 l2 x. PERM l1 l2 ⇒ PERM (x::l1) (x::l2)
</pre>

<DT><span class="strong">PERM_CONS_IFF</span>
<DD>
<pre>
|- ∀x l2 l1. PERM (x::l1) (x::l2) ⇔ PERM l1 l2
</pre>

<DT><span class="strong">PERM_NIL</span>
<DD>
<pre>
|- ∀L. (PERM L [] ⇔ (L = [])) ∧ (PERM [] L ⇔ (L = []))
</pre>

<DT><span class="strong">PERM_SING</span>
<DD>
<pre>
|- (PERM L [x] ⇔ (L = [x])) ∧ (PERM [x] L ⇔ (L = [x]))
</pre>

<DT><span class="strong">PERM_CONS_EQ_APPEND</span>
<DD>
<pre>
|- ∀L h. PERM (h::t) L ⇔ ∃M N. (L = M ++ h::N) ∧ PERM t (M ++ N)
</pre>

<DT><span class="strong">PERM_APPEND</span>
<DD>
<pre>
|- ∀l1 l2. PERM (l1 ++ l2) (l2 ++ l1)
</pre>

<DT><span class="strong">CONS_PERM</span>
<DD>
<pre>
|- ∀x L M N. PERM L (M ++ N) ⇒ PERM (x::L) (M ++ x::N)
</pre>

<DT><span class="strong">APPEND_PERM_SYM</span>
<DD>
<pre>
|- ∀A B C. PERM (A ++ B) C ⇒ PERM (B ++ A) C
</pre>

<DT><span class="strong">PERM_SPLIT</span>
<DD>
<pre>
|- ∀P l. PERM l (FILTER P l ++ FILTER ($~ o P) l)
</pre>

<DT><span class="strong">PERM_IND</span>
<DD>
<pre>
|- ∀P.
     P [] [] ∧ (∀x l1 l2. P l1 l2 ⇒ P (x::l1) (x::l2)) ∧
     (∀x y l1 l2. P l1 l2 ⇒ P (x::y::l1) (y::x::l2)) ∧
     (∀l1 l2 l3. P l1 l2 ∧ P l2 l3 ⇒ P l1 l3) ⇒
     ∀l1 l2. PERM l1 l2 ⇒ P l1 l2
</pre>

<DT><span class="strong">PERM_SWAP_AT_FRONT</span>
<DD>
<pre>
|- PERM (x::y::l1) (y::x::l2) ⇔ PERM l1 l2
</pre>

<DT><span class="strong">PERM_LENGTH</span>
<DD>
<pre>
|- ∀l1 l2. PERM l1 l2 ⇒ (LENGTH l1 = LENGTH l2)
</pre>

<DT><span class="strong">PERM_MEM_EQ</span>
<DD>
<pre>
|- ∀l1 l2. PERM l1 l2 ⇒ ∀x. MEM x l1 ⇔ MEM x l2
</pre>

<DT><span class="strong">SORTED_IND</span>
<DD>
<pre>
|- ∀P.
     (∀R. P R []) ∧ (∀R x. P R [x]) ∧
     (∀R x y rst. P R (y::rst) ⇒ P R (x::y::rst)) ⇒
     ∀v v1. P v v1
</pre>

<DT><span class="strong">SORTED_DEF</span>
<DD>
<pre>
|- (∀R. SORTED R [] ⇔ T) ∧ (∀x R. SORTED R [x] ⇔ T) ∧
   ∀y x rst R. SORTED R (x::y::rst) ⇔ R x y ∧ SORTED R (y::rst)
</pre>

<DT><span class="strong">SORTED_EQ</span>
<DD>
<pre>
|- ∀R L x. transitive R ⇒ (SORTED R (x::L) ⇔ SORTED R L ∧ ∀y. MEM y L ⇒ R x y)
</pre>

<DT><span class="strong">SORTED_APPEND</span>
<DD>
<pre>
|- ∀R L1 L2.
     transitive R ∧ SORTED R L1 ∧ SORTED R L2 ∧
     (∀x y. MEM x L1 ∧ MEM y L2 ⇒ R x y) ⇒
     SORTED R (L1 ++ L2)
</pre>

<DT><span class="strong">PART_LENGTH</span>
<DD>
<pre>
|- ∀P L l1 l2 p q.
     ((p,q) = PART P L l1 l2) ⇒
     (LENGTH L + LENGTH l1 + LENGTH l2 = LENGTH p + LENGTH q)
</pre>

<DT><span class="strong">PART_LENGTH_LEM</span>
<DD>
<pre>
|- ∀P L l1 l2 p q.
     ((p,q) = PART P L l1 l2) ⇒
     LENGTH p ≤ LENGTH L + LENGTH l1 + LENGTH l2 ∧
     LENGTH q ≤ LENGTH L + LENGTH l1 + LENGTH l2
</pre>

<DT><span class="strong">PARTs_HAVE_PROP</span>
<DD>
<pre>
|- ∀P L A B l1 l2.
     ((A,B) = PART P L l1 l2) ∧ (∀x. MEM x l1 ⇒ P x) ∧ (∀x. MEM x l2 ⇒ ¬P x) ⇒
     (∀z. MEM z A ⇒ P z) ∧ ∀z. MEM z B ⇒ ¬P z
</pre>

<DT><span class="strong">PART_MEM</span>
<DD>
<pre>
|- ∀P L a1 a2 l1 l2.
     ((a1,a2) = PART P L l1 l2) ⇒
     ∀x. MEM x (L ++ (l1 ++ l2)) ⇔ MEM x (a1 ++ a2)
</pre>

<DT><span class="strong">QSORT_IND</span>
<DD>
<pre>
|- ∀P.
     (∀ord. P ord []) ∧
     (∀ord h t.
        (∀l1 l2. ((l1,l2) = PARTITION (λy. ord y h) t) ⇒ P ord l2) ∧
        (∀l1 l2. ((l1,l2) = PARTITION (λy. ord y h) t) ⇒ P ord l1) ⇒
        P ord (h::t)) ⇒
     ∀v v1. P v v1
</pre>

<DT><span class="strong">QSORT_DEF</span>
<DD>
<pre>
|- (QSORT ord [] = []) ∧
   (QSORT ord (h::t) =
    (let (l1,l2) = PARTITION (λy. ord y h) t
     in
       QSORT ord l1 ++ [h] ++ QSORT ord l2))
</pre>

<DT><span class="strong">QSORT_MEM</span>
<DD>
<pre>
|- ∀R L x. MEM x (QSORT R L) ⇔ MEM x L
</pre>

<DT><span class="strong">QSORT_PERM</span>
<DD>
<pre>
|- ∀R L. PERM L (QSORT R L)
</pre>

<DT><span class="strong">QSORT_SORTED</span>
<DD>
<pre>
|- ∀R L. transitive R ∧ total R ⇒ SORTED R (QSORT R L)
</pre>

<DT><span class="strong">QSORT_SORTS</span>
<DD>
<pre>
|- ∀R. transitive R ∧ total R ⇒ SORTS QSORT R
</pre>

<DT><span class="strong">PERM_APPEND_IFF</span>
<DD>
<pre>
|- (∀l l1 l2. PERM (l ++ l1) (l ++ l2) ⇔ PERM l1 l2) ∧
   ∀l l1 l2. PERM (l1 ++ l) (l2 ++ l) ⇔ PERM l1 l2
</pre>

<DT><span class="strong">PERM_SINGLE_SWAP_REFL</span>
<DD>
<pre>
|- ∀l. PERM_SINGLE_SWAP l l
</pre>

<DT><span class="strong">PERM_SINGLE_SWAP_SYM</span>
<DD>
<pre>
|- ∀l1 l2. PERM_SINGLE_SWAP l1 l2 ⇔ PERM_SINGLE_SWAP l2 l1
</pre>

<DT><span class="strong">PERM_TC</span>
<DD>
<pre>
|- PERM = PERM_SINGLE_SWAP⁺
</pre>

<DT><span class="strong">PERM_RTC</span>
<DD>
<pre>
|- PERM = PERM_SINGLE_SWAP^*
</pre>

<DT><span class="strong">PERM_EQC</span>
<DD>
<pre>
|- PERM = PERM_SINGLE_SWAP^=
</pre>

<DT><span class="strong">PERM_lifts_transitive_relations</span>
<DD>
<pre>
|- ∀f Q.
     (∀x1 x2 x3. Q (f (x1 ++ x2 ++ x3)) (f (x1 ++ x3 ++ x2))) ∧ transitive Q ⇒
     ∀x y. PERM x y ⇒ Q (f x) (f y)
</pre>

<DT><span class="strong">PERM_lifts_equalities</span>
<DD>
<pre>
|- ∀f.
     (∀x1 x2 x3. f (x1 ++ x2 ++ x3) = f (x1 ++ x3 ++ x2)) ⇒
     ∀x y. PERM x y ⇒ (f x = f y)
</pre>

<DT><span class="strong">PERM_lifts_invariants</span>
<DD>
<pre>
|- ∀P.
     (∀x1 x2 x3. P (x1 ++ x2 ++ x3) ⇒ P (x1 ++ x3 ++ x2)) ⇒
     ∀x y. P x ∧ PERM x y ⇒ P y
</pre>

<DT><span class="strong">PERM_lifts_monotonicities</span>
<DD>
<pre>
|- ∀f.
     (∀x1 x2 x3.
        ∃x1' x2' x3'.
          (f (x1 ++ x2 ++ x3) = x1' ++ x2' ++ x3') ∧
          (f (x1 ++ x3 ++ x2) = x1' ++ x3' ++ x2')) ⇒
     ∀x y. PERM x y ⇒ PERM (f x) (f y)
</pre>

<DT><span class="strong">PERM_EQUIVALENCE</span>
<DD>
<pre>
|- equivalence PERM
</pre>

<DT><span class="strong">PERM_EQUIVALENCE_ALT_DEF</span>
<DD>
<pre>
|- ∀x y. PERM x y ⇔ (PERM x = PERM y)
</pre>

<DT><span class="strong">ALL_DISTINCT_PERM</span>
<DD>
<pre>
|- ∀l1 l2. PERM l1 l2 ⇒ (ALL_DISTINCT l1 ⇔ ALL_DISTINCT l2)
</pre>

<DT><span class="strong">PERM_ALL_DISTINCT</span>
<DD>
<pre>
|- ∀l1 l2.
     ALL_DISTINCT l1 ∧ ALL_DISTINCT l2 ∧ (∀x. MEM x l1 ⇔ MEM x l2) ⇒
     PERM l1 l2
</pre>

<DT><span class="strong">PERM_MAP</span>
<DD>
<pre>
|- ∀f l1 l2. PERM l1 l2 ⇒ PERM (MAP f l1) (MAP f l2)
</pre>

<DT><span class="strong">PERM_FILTER</span>
<DD>
<pre>
|- ∀P l1 l2. PERM l1 l2 ⇒ PERM (FILTER P l1) (FILTER P l2)
</pre>

<DT><span class="strong">PERM_REVERSE</span>
<DD>
<pre>
|- PERM ls (REVERSE ls)
</pre>

<DT><span class="strong">PERM_REVERSE_EQ</span>
<DD>
<pre>
|- (PERM (REVERSE l1) l2 ⇔ PERM l1 l2) ∧ (PERM l1 (REVERSE l2) ⇔ PERM l1 l2)
</pre>

<DT><span class="strong">FOLDR_PERM</span>
<DD>
<pre>
|- ∀f l1 l2 e. ASSOC f ∧ COMM f ⇒ PERM l1 l2 ⇒ (FOLDR f e l1 = FOLDR f e l2)
</pre>

<DT><span class="strong">PERM_FUN_APPEND</span>
<DD>
<pre>
|- ∀l1 l2. PERM (l1 ++ l2) = PERM (l2 ++ l1)
</pre>

<DT><span class="strong">PERM_FUN_CONS_IFF</span>
<DD>
<pre>
|- ∀x l1 l2. (PERM l1 = PERM l2) ⇒ (PERM (x::l1) = PERM (x::l2))
</pre>

<DT><span class="strong">PERM_FUN_APPEND_IFF</span>
<DD>
<pre>
|- ∀l l1 l2. (PERM l1 = PERM l2) ⇒ (PERM (l ++ l1) = PERM (l ++ l2))
</pre>

<DT><span class="strong">PERM_FUN_CONG</span>
<DD>
<pre>
|- ∀l1 l1' l2 l2'.
     (PERM l1 = PERM l1') ⇒ (PERM l2 = PERM l2') ⇒ (PERM l1 l2 ⇔ PERM l1' l2')
</pre>

<DT><span class="strong">PERM_CONG_2</span>
<DD>
<pre>
|- ∀l1 l1' l2 l2'. PERM l1 l1' ⇒ PERM l2 l2' ⇒ (PERM l1 l2 ⇔ PERM l1' l2')
</pre>

<DT><span class="strong">PERM_CONG_APPEND_IFF</span>
<DD>
<pre>
|- ∀l l1 l1' l2 l2'.
     PERM l1 (l ++ l1') ⇒ PERM l2 (l ++ l2') ⇒ (PERM l1 l2 ⇔ PERM l1' l2')
</pre>

<DT><span class="strong">PERM_FUN_SPLIT</span>
<DD>
<pre>
|- ∀l l1 l1' l2. PERM l (l1 ++ l2) ⇒ PERM l1' l1 ⇒ PERM l (l1' ++ l2)
</pre>

<DT><span class="strong">PERM_REWR</span>
<DD>
<pre>
|- ∀l r l1 l2. PERM l r ⇒ (PERM (l ++ l1) l2 ⇔ PERM (r ++ l1) l2)
</pre>

</DL>



<hr>
</body>
</html>
