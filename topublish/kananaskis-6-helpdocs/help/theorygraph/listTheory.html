<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: list</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "list"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "pred_setTheory.html"><span class="strong">pred_set</span></a>&nbsp;&nbsp;
    <a href = "operatorTheory.html"><span class="strong">operator</span></a>&nbsp;&nbsp;
    <a href = "ind_typeTheory.html"><span class="strong">ind_type</span></a>

<h1>Signature</h1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr> <th> Type <th> Arity<tr><td> <span class="strong">list</span> <td> 1
    <tr>
    <th>
    Constant
    <th>
    Type<tr><td> <span class="strong">ALL_DISTINCT</span> <td> :Œ± list -> bool
    <tr><td>
        <span class="strong">APPEND</span>
        <td>
        :Œ± list -> Œ± list -> Œ± list
    <tr><td> <span class="strong">CONS</span> <td> :Œ± -> Œ± list -> Œ± list
    <tr><td> <span class="strong">DROP</span> <td> :num -> Œ± list -> Œ± list
    <tr><td> <span class="strong">EL</span> <td> :num -> Œ± list -> Œ±
    <tr><td>
        <span class="strong">EVERY</span>
        <td>
        :(Œ± -> bool) -> Œ± list -> bool
    <tr><td>
        <span class="strong">EXISTS</span>
        <td>
        :(Œ± -> bool) -> Œ± list -> bool
    <tr><td>
        <span class="strong">FILTER</span>
        <td>
        :(Œ± -> bool) -> Œ± list -> Œ± list
    <tr><td> <span class="strong">FLAT</span> <td> :Œ± list list -> Œ± list
    <tr><td>
        <span class="strong">FOLDL</span>
        <td>
        :(Œ≤ -> Œ± -> Œ≤) -> Œ≤ -> Œ± list -> Œ≤
    <tr><td>
        <span class="strong">FOLDR</span>
        <td>
        :(Œ± -> Œ≤ -> Œ≤) -> Œ≤ -> Œ± list -> Œ≤
    <tr><td> <span class="strong">FRONT</span> <td> :Œ± list -> Œ± list
    <tr><td> <span class="strong">HD</span> <td> :Œ± list -> Œ±
    <tr><td> <span class="strong">LAST</span> <td> :Œ± list -> Œ±
    <tr><td> <span class="strong">LEN</span> <td> :Œ± list -> num -> num
    <tr><td> <span class="strong">LENGTH</span> <td> :Œ± list -> num
    <tr><td> <span class="strong">LIST_TO_SET</span> <td> :Œ± list -> Œ± -> bool
    <tr><td>
        <span class="strong">LRC</span>
        <td>
        :(Œ± -> Œ± -> bool) -> Œ± list -> Œ± -> Œ± -> bool
    <tr><td>
        <span class="strong">MAP</span>
        <td>
        :(Œ± -> Œ≤) -> Œ± list -> Œ≤ list
    <tr><td>
        <span class="strong">MAP2</span>
        <td>
        :(Œ± -> Œ≤ -> Œ≥) -> Œ± list -> Œ≤ list -> Œ≥ list
    <tr><td> <span class="strong">MEM</span> <td> :Œ± -> Œ± list -> bool
    <tr><td> <span class="strong">NIL</span> <td> :Œ± list
    <tr><td> <span class="strong">NULL</span> <td> :Œ± list -> bool
    <tr><td> <span class="strong">REV</span> <td> :Œ± list -> Œ± list -> Œ± list
    <tr><td> <span class="strong">REVERSE</span> <td> :Œ± list -> Œ± list
    <tr><td>
        <span class="strong">SET_TO_LIST</span>
        <td>
        :(Œ± -> bool) -> Œ± list
    <tr><td> <span class="strong">SNOC</span> <td> :Œ± -> Œ± list -> Œ± list
    <tr><td> <span class="strong">SUM</span> <td> :num list -> num
    <tr><td> <span class="strong">TAKE</span> <td> :num -> Œ± list -> Œ± list
    <tr><td> <span class="strong">TL</span> <td> :Œ± list -> Œ± list
    <tr><td>
        <span class="strong">UNZIP</span>
        <td>
        :(Œ± # Œ≤) list -> Œ± list # Œ≤ list
    <tr><td>
        <span class="strong">ZIP</span>
        <td>
        :Œ± list # Œ≤ list -> (Œ± # Œ≤) list
    <tr><td> <span class="strong">dest_list</span> <td> :Œ± list -> Œ± recspace
    <tr><td>
        <span class="strong">isPREFIX</span>
        <td>
        :Œ± list -> Œ± list -> bool
    <tr><td>
        <span class="strong">listRel</span>
        <td>
        :(Œ± -> Œ≤ -> bool) -> Œ± list -> Œ≤ list -> bool
    <tr><td>
        <span class="strong">list_case</span>
        <td>
        :Œ≤ -> (Œ± -> Œ± list -> Œ≤) -> Œ± list -> Œ≤
    <tr><td>
        <span class="strong">list_size</span>
        <td>
        :(Œ± -> num) -> Œ± list -> num
    <tr><td> <span class="strong">mk_list</span> <td> :Œ± recspace -> Œ± list
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">MAP2</span>
<DD>
<pre>
|- (‚àÄf. MAP2 f [] [] = []) ‚àß
   ‚àÄf h1 t1 h2 t2. MAP2 f (h1::t1) (h2::t2) = f h1 h2::MAP2 f t1 t2
</pre>

<DT><span class="strong">EL</span>
<DD>
<pre>
|- (‚àÄl. EL 0 l = HD l) ‚àß ‚àÄl n. EL (SUC n) l = EL n (TL l)
</pre>

<DT><span class="strong">EXISTS_DEF</span>
<DD>
<pre>
|- (‚àÄP. EXISTS P [] ‚áî F) ‚àß ‚àÄP h t. EXISTS P (h::t) ‚áî P h ‚à® EXISTS P t
</pre>

<DT><span class="strong">EVERY_DEF</span>
<DD>
<pre>
|- (‚àÄP. EVERY P [] ‚áî T) ‚àß ‚àÄP h t. EVERY P (h::t) ‚áî P h ‚àß EVERY P t
</pre>

<DT><span class="strong">FOLDL</span>
<DD>
<pre>
|- (‚àÄf e. FOLDL f e [] = e) ‚àß ‚àÄf e x l. FOLDL f e (x::l) = FOLDL f (f e x) l
</pre>

<DT><span class="strong">FOLDR</span>
<DD>
<pre>
|- (‚àÄf e. FOLDR f e [] = e) ‚àß ‚àÄf e x l. FOLDR f e (x::l) = f x (FOLDR f e l)
</pre>

<DT><span class="strong">FILTER</span>
<DD>
<pre>
|- (‚àÄP. FILTER P [] = []) ‚àß
   ‚àÄP h t. FILTER P (h::t) = if P h then h::FILTER P t else FILTER P t
</pre>

<DT><span class="strong">MEM</span>
<DD>
<pre>
|- (‚àÄx. MEM x [] ‚áî F) ‚àß ‚àÄx h t. MEM x (h::t) ‚áî (x = h) ‚à® MEM x t
</pre>

<DT><span class="strong">MAP</span>
<DD>
<pre>
|- (‚àÄf. MAP f [] = []) ‚àß ‚àÄf h t. MAP f (h::t) = f h::MAP f t
</pre>

<DT><span class="strong">LENGTH</span>
<DD>
<pre>
|- (LENGTH [] = 0) ‚àß ‚àÄh t. LENGTH (h::t) = SUC (LENGTH t)
</pre>

<DT><span class="strong">FLAT</span>
<DD>
<pre>
|- (FLAT [] = []) ‚àß ‚àÄh t. FLAT (h::t) = h ++ FLAT t
</pre>

<DT><span class="strong">APPEND</span>
<DD>
<pre>
|- (‚àÄl. [] ++ l = l) ‚àß ‚àÄl1 l2 h. h::l1 ++ l2 = h::(l1 ++ l2)
</pre>

<DT><span class="strong">SUM</span>
<DD>
<pre>
|- (SUM [] = 0) ‚àß ‚àÄh t. SUM (h::t) = h + SUM t
</pre>

<DT><span class="strong">TL</span>
<DD>
<pre>
|- ‚àÄh t. TL (h::t) = t
</pre>

<DT><span class="strong">HD</span>
<DD>
<pre>
|- ‚àÄh t. HD (h::t) = h
</pre>

<DT><span class="strong">NULL_DEF</span>
<DD>
<pre>
|- (NULL [] ‚áî T) ‚àß ‚àÄh t. NULL (h::t) ‚áî F
</pre>

<DT><span class="strong">list_TY_DEF</span>
<DD>
<pre>
|- ‚àÉrep.
     TYPE_DEFINITION
       (Œªa0'.
          ‚àÄ'list' .
            (‚àÄa0'.
               (a0' = ind_type$CONSTR 0 ARB (Œªn. ind_type$BOTTOM)) ‚à®
               (‚àÉa0 a1.
                  (a0' =
                   (Œªa0 a1.
                      ind_type$CONSTR (SUC 0) a0
                        (ind_type$FCONS a1 (Œªn. ind_type$BOTTOM))) a0 a1) ‚àß
                  'list' a1) ‚áí
               'list' a0') ‚áí
            'list' a0') rep
</pre>

<DT><span class="strong">list_repfns</span>
<DD>
<pre>
|- (‚àÄa. mk_list (dest_list a) = a) ‚àß
   ‚àÄr.
     (Œªa0'.
        ‚àÄ'list' .
          (‚àÄa0'.
             (a0' = ind_type$CONSTR 0 ARB (Œªn. ind_type$BOTTOM)) ‚à®
             (‚àÉa0 a1.
                (a0' =
                 (Œªa0 a1.
                    ind_type$CONSTR (SUC 0) a0
                      (ind_type$FCONS a1 (Œªn. ind_type$BOTTOM))) a0 a1) ‚àß
                'list' a1) ‚áí
             'list' a0') ‚áí
          'list' a0') r ‚áî (dest_list (mk_list r) = r)
</pre>

<DT><span class="strong">list_case_def</span>
<DD>
<pre>
|- (‚àÄv f. list_case v f [] = v) ‚àß ‚àÄv f a0 a1. list_case v f (a0::a1) = f a0 a1
</pre>

<DT><span class="strong">list_size_def</span>
<DD>
<pre>
|- (‚àÄf. list_size f [] = 0) ‚àß
   ‚àÄf a0 a1. list_size f (a0::a1) = 1 + (f a0 + list_size f a1)
</pre>

<DT><span class="strong">ZIP</span>
<DD>
<pre>
|- (ZIP ([],[]) = []) ‚àß
   ‚àÄx1 l1 x2 l2. ZIP (x1::l1,x2::l2) = (x1,x2)::ZIP (l1,l2)
</pre>

<DT><span class="strong">UNZIP</span>
<DD>
<pre>
|- (UNZIP [] = ([],[])) ‚àß
   ‚àÄx l. UNZIP (x::l) = (FST x::FST (UNZIP l),SND x::SND (UNZIP l))
</pre>

<DT><span class="strong">REVERSE_DEF</span>
<DD>
<pre>
|- (REVERSE [] = []) ‚àß ‚àÄh t. REVERSE (h::t) = REVERSE t ++ [h]
</pre>

<DT><span class="strong">LAST_DEF</span>
<DD>
<pre>
|- ‚àÄh t. LAST (h::t) = if t = [] then h else LAST t
</pre>

<DT><span class="strong">FRONT_DEF</span>
<DD>
<pre>
|- ‚àÄh t. FRONT (h::t) = if t = [] then [] else h::FRONT t
</pre>

<DT><span class="strong">TAKE_def</span>
<DD>
<pre>
|- (‚àÄn. TAKE n [] = []) ‚àß
   ‚àÄn x xs. TAKE n (x::xs) = if n = 0 then [] else x::TAKE (n ‚àí 1) xs
</pre>

<DT><span class="strong">DROP_def</span>
<DD>
<pre>
|- (‚àÄn. DROP n [] = []) ‚àß
   ‚àÄn x xs. DROP n (x::xs) = if n = 0 then x::xs else DROP (n ‚àí 1) xs
</pre>

<DT><span class="strong">ALL_DISTINCT</span>
<DD>
<pre>
|- (ALL_DISTINCT [] ‚áî T) ‚àß
   ‚àÄh t. ALL_DISTINCT (h::t) ‚áî ¬¨MEM h t ‚àß ALL_DISTINCT t
</pre>

<DT><span class="strong">LRC_def</span>
<DD>
<pre>
|- (‚àÄR x y. LRC R [] x y ‚áî (x = y)) ‚àß
   ‚àÄR h t x y. LRC R (h::t) x y ‚áî (x = h) ‚àß ‚àÉz. R x z ‚àß LRC R t z y
</pre>

<DT><span class="strong">LIST_TO_SET</span>
<DD>
<pre>
|- LIST_TO_SET = combin$C MEM
</pre>

<DT><span class="strong">SET_TO_LIST_primitive</span>
<DD>
<pre>
|- SET_TO_LIST =
   WFREC (@R. WF R ‚àß ‚àÄs. FINITE s ‚àß s ‚â† ‚àÖ ‚áí R (REST s) s)
     (ŒªSET_TO_LIST s.
        I
          (if FINITE s then
             if s = ‚àÖ then [] else CHOICE s::SET_TO_LIST (REST s)
           else
             ARB))
</pre>

<DT><span class="strong">listRel</span>
<DD>
<pre>
|- listRel =
   (ŒªR a0 a1.
      ‚àÄlistRel'.
        (‚àÄa0 a1.
           (a0 = []) ‚àß (a1 = []) ‚à®
           (‚àÉh1 h2 t1 t2.
              (a0 = h1::t1) ‚àß (a1 = h2::t2) ‚àß R h1 h2 ‚àß listRel' t1 t2) ‚áí
           listRel' a0 a1) ‚áí
        listRel' a0 a1)
</pre>

<DT><span class="strong">isPREFIX</span>
<DD>
<pre>
|- (‚àÄl. [] ‚âº l ‚áî T) ‚àß
   ‚àÄh t l. h::t ‚âº l ‚áî case l of [] -> F || h'::t' -> (h = h') ‚àß t ‚âº t'
</pre>

<DT><span class="strong">SNOC</span>
<DD>
<pre>
|- (‚àÄx. SNOC x [] = [x]) ‚àß ‚àÄx x' l. SNOC x (x'::l) = x'::SNOC x l
</pre>

<DT><span class="strong">LEN_DEF</span>
<DD>
<pre>
|- (‚àÄn. LEN [] n = n) ‚àß ‚àÄh t n. LEN (h::t) n = LEN t (n + 1)
</pre>

<DT><span class="strong">REV_DEF</span>
<DD>
<pre>
|- (‚àÄacc. REV [] acc = acc) ‚àß ‚àÄh t acc. REV (h::t) acc = REV t (h::acc)
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">list_CASES</span>
<DD>
<pre>
|- ‚àÄl. (l = []) ‚à® ‚àÉt h. l = h::t
</pre>

<DT><span class="strong">FORALL_LIST</span>
<DD>
<pre>
|- (‚àÄl. P l) ‚áî P [] ‚àß ‚àÄh t. P t ‚áí P (h::t)
</pre>

<DT><span class="strong">list_induction</span>
<DD>
<pre>
|- ‚àÄP. P [] ‚àß (‚àÄt. P t ‚áí ‚àÄh. P (h::t)) ‚áí ‚àÄl. P l
</pre>

<DT><span class="strong">list_Axiom</span>
<DD>
<pre>
|- ‚àÄf0 f1. ‚àÉfn. (fn [] = f0) ‚àß ‚àÄa0 a1. fn (a0::a1) = f1 a0 a1 (fn a1)
</pre>

<DT><span class="strong">list_INDUCT</span>
<DD>
<pre>
|- ‚àÄP. P [] ‚àß (‚àÄt. P t ‚áí ‚àÄh. P (h::t)) ‚áí ‚àÄl. P l
</pre>

<DT><span class="strong">NULL</span>
<DD>
<pre>
|- NULL [] ‚àß ‚àÄh t. ¬¨NULL (h::t)
</pre>

<DT><span class="strong">list_Axiom_old</span>
<DD>
<pre>
|- ‚àÄx f. ‚àÉ!fn1. (fn1 [] = x) ‚àß ‚àÄh t. fn1 (h::t) = f (fn1 t) h t
</pre>

<DT><span class="strong">datatype_list</span>
<DD>
<pre>
|- DATATYPE (list [] CONS)
</pre>

<DT><span class="strong">list_11</span>
<DD>
<pre>
|- ‚àÄa0 a1 a0' a1'. (a0::a1 = a0'::a1') ‚áî (a0 = a0') ‚àß (a1 = a1')
</pre>

<DT><span class="strong">list_distinct</span>
<DD>
<pre>
|- ‚àÄa1 a0. [] ‚â† a0::a1
</pre>

<DT><span class="strong">list_case_cong</span>
<DD>
<pre>
|- ‚àÄM M' v f.
     (M = M') ‚àß ((M' = []) ‚áí (v = v')) ‚àß
     (‚àÄa0 a1. (M' = a0::a1) ‚áí (f a0 a1 = f' a0 a1)) ‚áí
     (list_case v f M = list_case v' f' M')
</pre>

<DT><span class="strong">list_nchotomy</span>
<DD>
<pre>
|- ‚àÄl. (l = []) ‚à® ‚àÉt h. l = h::t
</pre>

<DT><span class="strong">list_case_compute</span>
<DD>
<pre>
|- ‚àÄl. list_case b f l = if NULL l then b else f (HD l) (TL l)
</pre>

<DT><span class="strong">CONS_11</span>
<DD>
<pre>
|- ‚àÄa0 a1 a0' a1'. (a0::a1 = a0'::a1') ‚áî (a0 = a0') ‚àß (a1 = a1')
</pre>

<DT><span class="strong">NOT_NIL_CONS</span>
<DD>
<pre>
|- ‚àÄa1 a0. [] ‚â† a0::a1
</pre>

<DT><span class="strong">NOT_CONS_NIL</span>
<DD>
<pre>
|- ‚àÄa1 a0. a0::a1 ‚â† []
</pre>

<DT><span class="strong">LIST_NOT_EQ</span>
<DD>
<pre>
|- ‚àÄl1 l2. l1 ‚â† l2 ‚áí ‚àÄh1 h2. h1::l1 ‚â† h2::l2
</pre>

<DT><span class="strong">NOT_EQ_LIST</span>
<DD>
<pre>
|- ‚àÄh1 h2. h1 ‚â† h2 ‚áí ‚àÄl1 l2. h1::l1 ‚â† h2::l2
</pre>

<DT><span class="strong">EQ_LIST</span>
<DD>
<pre>
|- ‚àÄh1 h2. (h1 = h2) ‚áí ‚àÄl1 l2. (l1 = l2) ‚áí (h1::l1 = h2::l2)
</pre>

<DT><span class="strong">CONS</span>
<DD>
<pre>
|- ‚àÄl. ¬¨NULL l ‚áí (HD l::TL l = l)
</pre>

<DT><span class="strong">APPEND_NIL</span>
<DD>
<pre>
|- ‚àÄl. l ++ [] = l
</pre>

<DT><span class="strong">APPEND_ASSOC</span>
<DD>
<pre>
|- ‚àÄl1 l2 l3. l1 ++ (l2 ++ l3) = l1 ++ l2 ++ l3
</pre>

<DT><span class="strong">LENGTH_APPEND</span>
<DD>
<pre>
|- ‚àÄl1 l2. LENGTH (l1 ++ l2) = LENGTH l1 + LENGTH l2
</pre>

<DT><span class="strong">MAP_APPEND</span>
<DD>
<pre>
|- ‚àÄf l1 l2. MAP f (l1 ++ l2) = MAP f l1 ++ MAP f l2
</pre>

<DT><span class="strong">MAP_ID</span>
<DD>
<pre>
|- (MAP (Œªx. x) l = l) ‚àß (MAP I l = l)
</pre>

<DT><span class="strong">LENGTH_MAP</span>
<DD>
<pre>
|- ‚àÄl f. LENGTH (MAP f l) = LENGTH l
</pre>

<DT><span class="strong">MAP_EQ_NIL</span>
<DD>
<pre>
|- ‚àÄl f. ((MAP f l = []) ‚áî (l = [])) ‚àß (([] = MAP f l) ‚áî (l = []))
</pre>

<DT><span class="strong">EVERY_EL</span>
<DD>
<pre>
|- ‚àÄl P. EVERY P l ‚áî ‚àÄn. n < LENGTH l ‚áí P (EL n l)
</pre>

<DT><span class="strong">EVERY_CONJ</span>
<DD>
<pre>
|- ‚àÄl. EVERY (Œªx. P x ‚àß Q x) l ‚áî EVERY P l ‚àß EVERY Q l
</pre>

<DT><span class="strong">EVERY_MEM</span>
<DD>
<pre>
|- ‚àÄP l. EVERY P l ‚áî ‚àÄe. MEM e l ‚áí P e
</pre>

<DT><span class="strong">EVERY_MAP</span>
<DD>
<pre>
|- ‚àÄP f l. EVERY P (MAP f l) ‚áî EVERY (Œªx. P (f x)) l
</pre>

<DT><span class="strong">EVERY_SIMP</span>
<DD>
<pre>
|- ‚àÄc l. EVERY (Œªx. c) l ‚áî (l = []) ‚à® c
</pre>

<DT><span class="strong">MONO_EVERY</span>
<DD>
<pre>
|- (‚àÄx. P x ‚áí Q x) ‚áí EVERY P l ‚áí EVERY Q l
</pre>

<DT><span class="strong">EXISTS_MEM</span>
<DD>
<pre>
|- ‚àÄP l. EXISTS P l ‚áî ‚àÉe. MEM e l ‚àß P e
</pre>

<DT><span class="strong">EXISTS_MAP</span>
<DD>
<pre>
|- ‚àÄP f l. EXISTS P (MAP f l) ‚áî EXISTS (Œªx. P (f x)) l
</pre>

<DT><span class="strong">EXISTS_SIMP</span>
<DD>
<pre>
|- ‚àÄc l. EXISTS (Œªx. c) l ‚áî l ‚â† [] ‚àß c
</pre>

<DT><span class="strong">MONO_EXISTS</span>
<DD>
<pre>
|- (‚àÄx. P x ‚áí Q x) ‚áí EXISTS P l ‚áí EXISTS Q l
</pre>

<DT><span class="strong">EVERY_NOT_EXISTS</span>
<DD>
<pre>
|- ‚àÄP l. EVERY P l ‚áî ¬¨EXISTS (Œªx. ¬¨P x) l
</pre>

<DT><span class="strong">EXISTS_NOT_EVERY</span>
<DD>
<pre>
|- ‚àÄP l. EXISTS P l ‚áî ¬¨EVERY (Œªx. ¬¨P x) l
</pre>

<DT><span class="strong">MEM_APPEND</span>
<DD>
<pre>
|- ‚àÄe l1 l2. MEM e (l1 ++ l2) ‚áî MEM e l1 ‚à® MEM e l2
</pre>

<DT><span class="strong">MEM_FILTER</span>
<DD>
<pre>
|- ‚àÄP L x. MEM x (FILTER P L) ‚áî P x ‚àß MEM x L
</pre>

<DT><span class="strong">MEM_FLAT</span>
<DD>
<pre>
|- ‚àÄx L. MEM x (FLAT L) ‚áî ‚àÉl. MEM l L ‚àß MEM x l
</pre>

<DT><span class="strong">EVERY_APPEND</span>
<DD>
<pre>
|- ‚àÄP l1 l2. EVERY P (l1 ++ l2) ‚áî EVERY P l1 ‚àß EVERY P l2
</pre>

<DT><span class="strong">EXISTS_APPEND</span>
<DD>
<pre>
|- ‚àÄP l1 l2. EXISTS P (l1 ++ l2) ‚áî EXISTS P l1 ‚à® EXISTS P l2
</pre>

<DT><span class="strong">NOT_EVERY</span>
<DD>
<pre>
|- ‚àÄP l. ¬¨EVERY P l ‚áî EXISTS ($~ o P) l
</pre>

<DT><span class="strong">NOT_EXISTS</span>
<DD>
<pre>
|- ‚àÄP l. ¬¨EXISTS P l ‚áî EVERY ($~ o P) l
</pre>

<DT><span class="strong">MEM_MAP</span>
<DD>
<pre>
|- ‚àÄl f x. MEM x (MAP f l) ‚áî ‚àÉy. (x = f y) ‚àß MEM y l
</pre>

<DT><span class="strong">LENGTH_NIL</span>
<DD>
<pre>
|- ‚àÄl. (LENGTH l = 0) ‚áî (l = [])
</pre>

<DT><span class="strong">LENGTH_NIL_SYM</span>
<DD>
<pre>
|- (0 = LENGTH l) ‚áî (l = [])
</pre>

<DT><span class="strong">NULL_EQ</span>
<DD>
<pre>
|- ‚àÄl. NULL l ‚áî (l = [])
</pre>

<DT><span class="strong">NULL_LENGTH</span>
<DD>
<pre>
|- ‚àÄl. NULL l ‚áî (LENGTH l = 0)
</pre>

<DT><span class="strong">LENGTH_CONS</span>
<DD>
<pre>
|- ‚àÄl n. (LENGTH l = SUC n) ‚áî ‚àÉh l'. (LENGTH l' = n) ‚àß (l = h::l')
</pre>

<DT><span class="strong">LENGTH_EQ_CONS</span>
<DD>
<pre>
|- ‚àÄP n.
     (‚àÄl. (LENGTH l = SUC n) ‚áí P l) ‚áî
     ‚àÄl. (LENGTH l = n) ‚áí (Œªl. ‚àÄx. P (x::l)) l
</pre>

<DT><span class="strong">LENGTH_EQ_SUM</span>
<DD>
<pre>
|- ‚àÄl n1 n2.
     (LENGTH l = n1 + n2) ‚áî
     ‚àÉl1 l2. (LENGTH l1 = n1) ‚àß (LENGTH l2 = n2) ‚àß (l = l1 ++ l2)
</pre>

<DT><span class="strong">LENGTH_EQ_NUM</span>
<DD>
<pre>
|- (‚àÄl. (LENGTH l = 0) ‚áî (l = [])) ‚àß
   (‚àÄl n. (LENGTH l = SUC n) ‚áî ‚àÉh l'. (LENGTH l' = n) ‚àß (l = h::l')) ‚àß
   ‚àÄl n1 n2.
     (LENGTH l = n1 + n2) ‚áî
     ‚àÉl1 l2. (LENGTH l1 = n1) ‚àß (LENGTH l2 = n2) ‚àß (l = l1 ++ l2)
</pre>

<DT><span class="strong">LENGTH_EQ_NUM_compute</span>
<DD>
<pre>
|- (‚àÄl. (LENGTH l = 0) ‚áî (l = [])) ‚àß
   (‚àÄl n.
      (LENGTH l = NUMERAL (BIT1 n)) ‚áî
      ‚àÉh l'. (LENGTH l' = NUMERAL (BIT1 n) ‚àí 1) ‚àß (l = h::l')) ‚àß
   (‚àÄl n.
      (LENGTH l = NUMERAL (BIT2 n)) ‚áî
      ‚àÉh l'. (LENGTH l' = NUMERAL (BIT1 n)) ‚àß (l = h::l')) ‚àß
   ‚àÄl n1 n2.
     (LENGTH l = n1 + n2) ‚áî
     ‚àÉl1 l2. (LENGTH l1 = n1) ‚àß (LENGTH l2 = n2) ‚àß (l = l1 ++ l2)
</pre>

<DT><span class="strong">LENGTH_EQ_NIL</span>
<DD>
<pre>
|- ‚àÄP. (‚àÄl. (LENGTH l = 0) ‚áí P l) ‚áî P []
</pre>

<DT><span class="strong">CONS_ACYCLIC</span>
<DD>
<pre>
|- ‚àÄl x. l ‚â† x::l ‚àß x::l ‚â† l
</pre>

<DT><span class="strong">APPEND_eq_NIL</span>
<DD>
<pre>
|- (‚àÄl1 l2. ([] = l1 ++ l2) ‚áî (l1 = []) ‚àß (l2 = [])) ‚àß
   ‚àÄl1 l2. (l1 ++ l2 = []) ‚áî (l1 = []) ‚àß (l2 = [])
</pre>

<DT><span class="strong">APPEND_EQ_SING</span>
<DD>
<pre>
|- (l1 ++ l2 = [e]) ‚áî (l1 = [e]) ‚àß (l2 = []) ‚à® (l1 = []) ‚àß (l2 = [e])
</pre>

<DT><span class="strong">APPEND_11</span>
<DD>
<pre>
|- (‚àÄl1 l2 l3. (l1 ++ l2 = l1 ++ l3) ‚áî (l2 = l3)) ‚àß
   ‚àÄl1 l2 l3. (l2 ++ l1 = l3 ++ l1) ‚áî (l2 = l3)
</pre>

<DT><span class="strong">APPEND_LENGTH_EQ</span>
<DD>
<pre>
|- ‚àÄl1 l1'.
     (LENGTH l1 = LENGTH l1') ‚áí
     ‚àÄl2 l2'.
       (LENGTH l2 = LENGTH l2') ‚áí
       ((l1 ++ l2 = l1' ++ l2') ‚áî (l1 = l1') ‚àß (l2 = l2'))
</pre>

<DT><span class="strong">APPEND_11_LENGTH</span>
<DD>
<pre>
|- (‚àÄl1 l2 l1' l2'.
      (LENGTH l1 = LENGTH l1') ‚áí
      ((l1 ++ l2 = l1' ++ l2') ‚áî (l1 = l1') ‚àß (l2 = l2'))) ‚àß
   ‚àÄl1 l2 l1' l2'.
     (LENGTH l2 = LENGTH l2') ‚áí
     ((l1 ++ l2 = l1' ++ l2') ‚áî (l1 = l1') ‚àß (l2 = l2'))
</pre>

<DT><span class="strong">APPEND_EQ_SELF</span>
<DD>
<pre>
|- (‚àÄl1 l2. (l1 ++ l2 = l1) ‚áî (l2 = [])) ‚àß
   (‚àÄl1 l2. (l1 ++ l2 = l2) ‚áî (l1 = [])) ‚àß
   (‚àÄl1 l2. (l1 = l1 ++ l2) ‚áî (l2 = [])) ‚àß ‚àÄl1 l2. (l2 = l1 ++ l2) ‚áî (l1 = [])
</pre>

<DT><span class="strong">MEM_SPLIT</span>
<DD>
<pre>
|- ‚àÄx l. MEM x l ‚áî ‚àÉl1 l2. l = l1 ++ x::l2
</pre>

<DT><span class="strong">LIST_EQ_REWRITE</span>
<DD>
<pre>
|- ‚àÄl1 l2.
     (l1 = l2) ‚áî
     (LENGTH l1 = LENGTH l2) ‚àß ‚àÄx. x < LENGTH l1 ‚áí (EL x l1 = EL x l2)
</pre>

<DT><span class="strong">LIST_EQ</span>
<DD>
<pre>
|- ‚àÄl1 l2.
     (LENGTH l1 = LENGTH l2) ‚àß (‚àÄx. x < LENGTH l1 ‚áí (EL x l1 = EL x l2)) ‚áí
     (l1 = l2)
</pre>

<DT><span class="strong">FOLDL_EQ_FOLDR</span>
<DD>
<pre>
|- ‚àÄf l e. ASSOC f ‚àß COMM f ‚áí (FOLDL f e l = FOLDR f e l)
</pre>

<DT><span class="strong">LENGTH_TL</span>
<DD>
<pre>
|- ‚àÄl. 0 < LENGTH l ‚áí (LENGTH (TL l) = LENGTH l ‚àí 1)
</pre>

<DT><span class="strong">FILTER_EQ_NIL</span>
<DD>
<pre>
|- ‚àÄP l. (FILTER P l = []) ‚áî EVERY (Œªx. ¬¨P x) l
</pre>

<DT><span class="strong">FILTER_NEQ_NIL</span>
<DD>
<pre>
|- ‚àÄP l. FILTER P l ‚â† [] ‚áî ‚àÉx. MEM x l ‚àß P x
</pre>

<DT><span class="strong">FILTER_EQ_ID</span>
<DD>
<pre>
|- ‚àÄP l. (FILTER P l = l) ‚áî EVERY P l
</pre>

<DT><span class="strong">FILTER_NEQ_ID</span>
<DD>
<pre>
|- ‚àÄP l. FILTER P l ‚â† l ‚áî ‚àÉx. MEM x l ‚àß ¬¨P x
</pre>

<DT><span class="strong">FILTER_EQ_CONS</span>
<DD>
<pre>
|- ‚àÄP l h lr.
     (FILTER P l = h::lr) ‚áî
     ‚àÉl1 l2.
       (l = l1 ++ [h] ++ l2) ‚àß (FILTER P l1 = []) ‚àß (FILTER P l2 = lr) ‚àß P h
</pre>

<DT><span class="strong">FILTER_APPEND_DISTRIB</span>
<DD>
<pre>
|- ‚àÄP L M. FILTER P (L ++ M) = FILTER P L ++ FILTER P M
</pre>

<DT><span class="strong">FILTER_EQ_APPEND</span>
<DD>
<pre>
|- ‚àÄP l l1 l2.
     (FILTER P l = l1 ++ l2) ‚áî
     ‚àÉl3 l4. (l = l3 ++ l4) ‚àß (FILTER P l3 = l1) ‚àß (FILTER P l4 = l2)
</pre>

<DT><span class="strong">EVERY_FILTER</span>
<DD>
<pre>
|- ‚àÄP1 P2 l. EVERY P1 (FILTER P2 l) ‚áî EVERY (Œªx. P2 x ‚áí P1 x) l
</pre>

<DT><span class="strong">EVERY_FILTER_IMP</span>
<DD>
<pre>
|- ‚àÄP1 P2 l. EVERY P1 l ‚áí EVERY P1 (FILTER P2 l)
</pre>

<DT><span class="strong">FILTER_COND_REWRITE</span>
<DD>
<pre>
|- (FILTER P [] = []) ‚àß (‚àÄh. P h ‚áí (FILTER P (h::l) = h::FILTER P l)) ‚àß
   ‚àÄh. ¬¨P h ‚áí (FILTER P (h::l) = FILTER P l)
</pre>

<DT><span class="strong">NOT_NULL_MEM</span>
<DD>
<pre>
|- ‚àÄl. ¬¨NULL l ‚áî ‚àÉe. MEM e l
</pre>

<DT><span class="strong">EL_compute</span>
<DD>
<pre>
|- ‚àÄn. EL n l = if n = 0 then HD l else EL (PRE n) (TL l)
</pre>

<DT><span class="strong">EL_simp</span>
<DD>
<pre>
|- (EL (NUMERAL (BIT1 n)) l = EL (PRE (NUMERAL (BIT1 n))) (TL l)) ‚àß
   (EL (NUMERAL (BIT2 n)) l = EL (NUMERAL (BIT1 n)) (TL l))
</pre>

<DT><span class="strong">EL_restricted</span>
<DD>
<pre>
|- (EL 0 = HD) ‚àß (EL (SUC n) (l::ls) = EL n ls)
</pre>

<DT><span class="strong">EL_simp_restricted</span>
<DD>
<pre>
|- (EL (NUMERAL (BIT1 n)) (l::ls) = EL (PRE (NUMERAL (BIT1 n))) ls) ‚àß
   (EL (NUMERAL (BIT2 n)) (l::ls) = EL (NUMERAL (BIT1 n)) ls)
</pre>

<DT><span class="strong">WF_LIST_PRED</span>
<DD>
<pre>
|- WF (ŒªL1 L2. ‚àÉh. L2 = h::L1)
</pre>

<DT><span class="strong">list_size_cong</span>
<DD>
<pre>
|- ‚àÄM N f f'.
     (M = N) ‚àß (‚àÄx. MEM x N ‚áí (f x = f' x)) ‚áí (list_size f M = list_size f' N)
</pre>

<DT><span class="strong">FOLDR_CONG</span>
<DD>
<pre>
|- ‚àÄl l' b b' f f'.
     (l = l') ‚àß (b = b') ‚àß (‚àÄx a. MEM x l' ‚áí (f x a = f' x a)) ‚áí
     (FOLDR f b l = FOLDR f' b' l')
</pre>

<DT><span class="strong">FOLDL_CONG</span>
<DD>
<pre>
|- ‚àÄl l' b b' f f'.
     (l = l') ‚àß (b = b') ‚àß (‚àÄx a. MEM x l' ‚áí (f a x = f' a x)) ‚áí
     (FOLDL f b l = FOLDL f' b' l')
</pre>

<DT><span class="strong">MAP_CONG</span>
<DD>
<pre>
|- ‚àÄl1 l2 f f'.
     (l1 = l2) ‚àß (‚àÄx. MEM x l2 ‚áí (f x = f' x)) ‚áí (MAP f l1 = MAP f' l2)
</pre>

<DT><span class="strong">EXISTS_CONG</span>
<DD>
<pre>
|- ‚àÄl1 l2 P P'.
     (l1 = l2) ‚àß (‚àÄx. MEM x l2 ‚áí (P x ‚áî P' x)) ‚áí (EXISTS P l1 ‚áî EXISTS P' l2)
</pre>

<DT><span class="strong">EVERY_CONG</span>
<DD>
<pre>
|- ‚àÄl1 l2 P P'.
     (l1 = l2) ‚àß (‚àÄx. MEM x l2 ‚áí (P x ‚áî P' x)) ‚áí (EVERY P l1 ‚áî EVERY P' l2)
</pre>

<DT><span class="strong">EVERY_MONOTONIC</span>
<DD>
<pre>
|- ‚àÄP Q. (‚àÄx. P x ‚áí Q x) ‚áí ‚àÄl. EVERY P l ‚áí EVERY Q l
</pre>

<DT><span class="strong">UNZIP_THM</span>
<DD>
<pre>
|- (UNZIP [] = ([],[])) ‚àß
   (UNZIP ((x,y)::t) = (let (L1,L2) = UNZIP t in (x::L1,y::L2)))
</pre>

<DT><span class="strong">UNZIP_MAP</span>
<DD>
<pre>
|- ‚àÄL. UNZIP L = (MAP FST L,MAP SND L)
</pre>

<DT><span class="strong">LENGTH_ZIP</span>
<DD>
<pre>
|- ‚àÄl1 l2.
     (LENGTH l1 = LENGTH l2) ‚áí
     (LENGTH (ZIP (l1,l2)) = LENGTH l1) ‚àß (LENGTH (ZIP (l1,l2)) = LENGTH l2)
</pre>

<DT><span class="strong">LENGTH_UNZIP</span>
<DD>
<pre>
|- ‚àÄpl.
     (LENGTH (FST (UNZIP pl)) = LENGTH pl) ‚àß
     (LENGTH (SND (UNZIP pl)) = LENGTH pl)
</pre>

<DT><span class="strong">ZIP_UNZIP</span>
<DD>
<pre>
|- ‚àÄl. ZIP (UNZIP l) = l
</pre>

<DT><span class="strong">UNZIP_ZIP</span>
<DD>
<pre>
|- ‚àÄl1 l2. (LENGTH l1 = LENGTH l2) ‚áí (UNZIP (ZIP (l1,l2)) = (l1,l2))
</pre>

<DT><span class="strong">ZIP_MAP</span>
<DD>
<pre>
|- ‚àÄl1 l2 f1 f2.
     (LENGTH l1 = LENGTH l2) ‚áí
     (ZIP (MAP f1 l1,l2) = MAP (Œªp. (f1 (FST p),SND p)) (ZIP (l1,l2))) ‚àß
     (ZIP (l1,MAP f2 l2) = MAP (Œªp. (FST p,f2 (SND p))) (ZIP (l1,l2)))
</pre>

<DT><span class="strong">MEM_ZIP</span>
<DD>
<pre>
|- ‚àÄl1 l2 p.
     (LENGTH l1 = LENGTH l2) ‚áí
     (MEM p (ZIP (l1,l2)) ‚áî ‚àÉn. n < LENGTH l1 ‚àß (p = (EL n l1,EL n l2)))
</pre>

<DT><span class="strong">EL_ZIP</span>
<DD>
<pre>
|- ‚àÄl1 l2 n.
     (LENGTH l1 = LENGTH l2) ‚àß n < LENGTH l1 ‚áí
     (EL n (ZIP (l1,l2)) = (EL n l1,EL n l2))
</pre>

<DT><span class="strong">MAP2_ZIP</span>
<DD>
<pre>
|- ‚àÄl1 l2.
     (LENGTH l1 = LENGTH l2) ‚áí
     ‚àÄf. MAP2 f l1 l2 = MAP (UNCURRY f) (ZIP (l1,l2))
</pre>

<DT><span class="strong">MAP_ZIP</span>
<DD>
<pre>
|- (LENGTH l1 = LENGTH l2) ‚áí
   (MAP FST (ZIP (l1,l2)) = l1) ‚àß (MAP SND (ZIP (l1,l2)) = l2) ‚àß
   (MAP (f o FST) (ZIP (l1,l2)) = MAP f l1) ‚àß
   (MAP (g o SND) (ZIP (l1,l2)) = MAP g l2)
</pre>

<DT><span class="strong">MEM_EL</span>
<DD>
<pre>
|- ‚àÄl x. MEM x l ‚áî ‚àÉn. n < LENGTH l ‚àß (x = EL n l)
</pre>

<DT><span class="strong">REVERSE_APPEND</span>
<DD>
<pre>
|- ‚àÄl1 l2. REVERSE (l1 ++ l2) = REVERSE l2 ++ REVERSE l1
</pre>

<DT><span class="strong">REVERSE_REVERSE</span>
<DD>
<pre>
|- ‚àÄl. REVERSE (REVERSE l) = l
</pre>

<DT><span class="strong">MEM_REVERSE</span>
<DD>
<pre>
|- ‚àÄl x. MEM x (REVERSE l) ‚áî MEM x l
</pre>

<DT><span class="strong">LENGTH_REVERSE</span>
<DD>
<pre>
|- ‚àÄl. LENGTH (REVERSE l) = LENGTH l
</pre>

<DT><span class="strong">REVERSE_EQ_NIL</span>
<DD>
<pre>
|- (REVERSE l = []) ‚áî (l = [])
</pre>

<DT><span class="strong">REVERSE_EQ_SING</span>
<DD>
<pre>
|- (REVERSE l = [e]) ‚áî (l = [e])
</pre>

<DT><span class="strong">FILTER_REVERSE</span>
<DD>
<pre>
|- ‚àÄl P. FILTER P (REVERSE l) = REVERSE (FILTER P l)
</pre>

<DT><span class="strong">LAST_CONS</span>
<DD>
<pre>
|- (‚àÄx. LAST [x] = x) ‚àß ‚àÄx y z. LAST (x::y::z) = LAST (y::z)
</pre>

<DT><span class="strong">FRONT_CONS</span>
<DD>
<pre>
|- (‚àÄx. FRONT [x] = []) ‚àß ‚àÄx y z. FRONT (x::y::z) = x::FRONT (y::z)
</pre>

<DT><span class="strong">LENGTH_FRONT_CONS</span>
<DD>
<pre>
|- ‚àÄx xs. LENGTH (FRONT (x::xs)) = LENGTH xs
</pre>

<DT><span class="strong">FRONT_CONS_EQ_NIL</span>
<DD>
<pre>
|- (‚àÄx xs. (FRONT (x::xs) = []) ‚áî (xs = [])) ‚àß
   (‚àÄx xs. ([] = FRONT (x::xs)) ‚áî (xs = [])) ‚àß
   ‚àÄx xs. NULL (FRONT (x::xs)) ‚áî NULL xs
</pre>

<DT><span class="strong">APPEND_FRONT_LAST</span>
<DD>
<pre>
|- ‚àÄl. l ‚â† [] ‚áí (FRONT l ++ [LAST l] = l)
</pre>

<DT><span class="strong">LAST_CONS_cond</span>
<DD>
<pre>
|- LAST (h::t) = if t = [] then h else LAST t
</pre>

<DT><span class="strong">LAST_APPEND_CONS</span>
<DD>
<pre>
|- LAST (l1 ++ h::l2) = LAST (h::l2)
</pre>

<DT><span class="strong">TAKE_0</span>
<DD>
<pre>
|- TAKE 0 l = []
</pre>

<DT><span class="strong">TAKE_LENGTH_ID</span>
<DD>
<pre>
|- TAKE (LENGTH l) l = l
</pre>

<DT><span class="strong">LENGTH_TAKE</span>
<DD>
<pre>
|- ‚àÄn. n ‚â§ LENGTH l ‚áí (LENGTH (TAKE n l) = n)
</pre>

<DT><span class="strong">TAKE_APPEND1</span>
<DD>
<pre>
|- ‚àÄn. n ‚â§ LENGTH l1 ‚áí (TAKE n (l1 ++ l2) = TAKE n l1)
</pre>

<DT><span class="strong">TAKE_APPEND2</span>
<DD>
<pre>
|- ‚àÄn. LENGTH l1 < n ‚áí (TAKE n (l1 ++ l2) = l1 ++ TAKE (n ‚àí LENGTH l1) l2)
</pre>

<DT><span class="strong">DROP_0</span>
<DD>
<pre>
|- DROP 0 l = l
</pre>

<DT><span class="strong">TAKE_DROP</span>
<DD>
<pre>
|- ‚àÄn. TAKE n l ++ DROP n l = l
</pre>

<DT><span class="strong">LENGTH_DROP</span>
<DD>
<pre>
|- ‚àÄn. LENGTH (DROP n l) = LENGTH l ‚àí n
</pre>

<DT><span class="strong">ALL_DISTINCT_FILTER</span>
<DD>
<pre>
|- ‚àÄl. ALL_DISTINCT l ‚áî ‚àÄx. MEM x l ‚áí (FILTER ($= x) l = [x])
</pre>

<DT><span class="strong">FILTER_ALL_DISTINCT</span>
<DD>
<pre>
|- ‚àÄP l. ALL_DISTINCT l ‚áí ALL_DISTINCT (FILTER P l)
</pre>

<DT><span class="strong">EL_ALL_DISTINCT_EL_EQ</span>
<DD>
<pre>
|- ‚àÄl.
     ALL_DISTINCT l ‚áî
     ‚àÄn1 n2. n1 < LENGTH l ‚àß n2 < LENGTH l ‚áí ((EL n1 l = EL n2 l) ‚áî (n1 = n2))
</pre>

<DT><span class="strong">ALL_DISTINCT_EL_IMP</span>
<DD>
<pre>
|- ‚àÄl n1 n2.
     ALL_DISTINCT l ‚àß n1 < LENGTH l ‚àß n2 < LENGTH l ‚áí
     ((EL n1 l = EL n2 l) ‚áî (n1 = n2))
</pre>

<DT><span class="strong">ALL_DISTINCT_APPEND</span>
<DD>
<pre>
|- ‚àÄl1 l2.
     ALL_DISTINCT (l1 ++ l2) ‚áî
     ALL_DISTINCT l1 ‚àß ALL_DISTINCT l2 ‚àß ‚àÄe. MEM e l1 ‚áí ¬¨MEM e l2
</pre>

<DT><span class="strong">ALL_DISTINCT_SING</span>
<DD>
<pre>
|- ‚àÄx. ALL_DISTINCT [x]
</pre>

<DT><span class="strong">ALL_DISTINCT_ZIP</span>
<DD>
<pre>
|- ‚àÄl1 l2.
     ALL_DISTINCT l1 ‚àß (LENGTH l1 = LENGTH l2) ‚áí ALL_DISTINCT (ZIP (l1,l2))
</pre>

<DT><span class="strong">ALL_DISTINCT_ZIP_SWAP</span>
<DD>
<pre>
|- ‚àÄl1 l2.
     ALL_DISTINCT (ZIP (l1,l2)) ‚àß (LENGTH l1 = LENGTH l2) ‚áí
     ALL_DISTINCT (ZIP (l2,l1))
</pre>

<DT><span class="strong">ALL_DISTINCT_REVERSE</span>
<DD>
<pre>
|- ‚àÄl. ALL_DISTINCT (REVERSE l) ‚áî ALL_DISTINCT l
</pre>

<DT><span class="strong">NRC_LRC</span>
<DD>
<pre>
|- NRC R n x y ‚áî ‚àÉls. LRC R ls x y ‚àß (LENGTH ls = n)
</pre>

<DT><span class="strong">LRC_MEM</span>
<DD>
<pre>
|- LRC R ls x y ‚àß MEM e ls ‚áí ‚àÉz t. R e z ‚àß LRC R t z y
</pre>

<DT><span class="strong">LRC_MEM_right</span>
<DD>
<pre>
|- LRC R (h::t) x y ‚àß MEM e t ‚áí ‚àÉz p. R z e ‚àß LRC R p x z
</pre>

<DT><span class="strong">IN_LIST_TO_SET</span>
<DD>
<pre>
|- x ‚àà LIST_TO_SET l ‚áî MEM x l
</pre>

<DT><span class="strong">LIST_TO_SET_THM</span>
<DD>
<pre>
|- (LIST_TO_SET [] = ‚àÖ) ‚àß (LIST_TO_SET (h::t) = h INSERT LIST_TO_SET t)
</pre>

<DT><span class="strong">LIST_TO_SET_APPEND</span>
<DD>
<pre>
|- ‚àÄl1 l2. LIST_TO_SET (l1 ++ l2) = LIST_TO_SET l1 ‚à™ LIST_TO_SET l2
</pre>

<DT><span class="strong">UNION_APPEND</span>
<DD>
<pre>
|- ‚àÄl1 l2. LIST_TO_SET l1 ‚à™ LIST_TO_SET l2 = LIST_TO_SET (l1 ++ l2)
</pre>

<DT><span class="strong">LIST_TO_SET_EQ_EMPTY</span>
<DD>
<pre>
|- ((LIST_TO_SET l = ‚àÖ) ‚áî (l = [])) ‚àß ((‚àÖ = LIST_TO_SET l) ‚áî (l = []))
</pre>

<DT><span class="strong">FINITE_LIST_TO_SET</span>
<DD>
<pre>
|- ‚àÄl. FINITE (LIST_TO_SET l)
</pre>

<DT><span class="strong">CARD_LIST_TO_SET</span>
<DD>
<pre>
|- CARD (LIST_TO_SET ls) ‚â§ LENGTH ls
</pre>

<DT><span class="strong">ALL_DISTINCT_CARD_LIST_TO_SET</span>
<DD>
<pre>
|- ‚àÄls. ALL_DISTINCT ls ‚áí (CARD (LIST_TO_SET ls) = LENGTH ls)
</pre>

<DT><span class="strong">LIST_TO_SET_REVERSE</span>
<DD>
<pre>
|- ‚àÄls. LIST_TO_SET (REVERSE ls) = LIST_TO_SET ls
</pre>

<DT><span class="strong">LIST_TO_SET_MAP</span>
<DD>
<pre>
|- ‚àÄf l. LIST_TO_SET (MAP f l) = IMAGE f (LIST_TO_SET l)
</pre>

<DT><span class="strong">SET_TO_LIST_THM</span>
<DD>
<pre>
|- FINITE s ‚áí
   (SET_TO_LIST s = if s = ‚àÖ then [] else CHOICE s::SET_TO_LIST (REST s))
</pre>

<DT><span class="strong">SET_TO_LIST_IND</span>
<DD>
<pre>
|- ‚àÄP. (‚àÄs. (FINITE s ‚àß s ‚â† ‚àÖ ‚áí P (REST s)) ‚áí P s) ‚áí ‚àÄv. P v
</pre>

<DT><span class="strong">SET_TO_LIST_INV</span>
<DD>
<pre>
|- ‚àÄs. FINITE s ‚áí (LIST_TO_SET (SET_TO_LIST s) = s)
</pre>

<DT><span class="strong">SET_TO_LIST_CARD</span>
<DD>
<pre>
|- ‚àÄs. FINITE s ‚áí (LENGTH (SET_TO_LIST s) = CARD s)
</pre>

<DT><span class="strong">SET_TO_LIST_IN_MEM</span>
<DD>
<pre>
|- ‚àÄs. FINITE s ‚áí ‚àÄx. x ‚àà s ‚áî MEM x (SET_TO_LIST s)
</pre>

<DT><span class="strong">MEM_SET_TO_LIST</span>
<DD>
<pre>
|- ‚àÄs. FINITE s ‚áí ‚àÄx. MEM x (SET_TO_LIST s) ‚áî x ‚àà s
</pre>

<DT><span class="strong">SET_TO_LIST_SING</span>
<DD>
<pre>
|- SET_TO_LIST {x} = [x]
</pre>

<DT><span class="strong">ALL_DISTINCT_SET_TO_LIST</span>
<DD>
<pre>
|- ‚àÄs. FINITE s ‚áí ALL_DISTINCT (SET_TO_LIST s)
</pre>

<DT><span class="strong">listRel_rules</span>
<DD>
<pre>
|- ‚àÄR.
     listRel R [] [] ‚àß
     ‚àÄh1 h2 t1 t2. R h1 h2 ‚àß listRel R t1 t2 ‚áí listRel R (h1::t1) (h2::t2)
</pre>

<DT><span class="strong">listRel_ind</span>
<DD>
<pre>
|- ‚àÄR listRel'.
     listRel' [] [] ‚àß
     (‚àÄh1 h2 t1 t2. R h1 h2 ‚àß listRel' t1 t2 ‚áí listRel' (h1::t1) (h2::t2)) ‚áí
     ‚àÄa0 a1. listRel R a0 a1 ‚áí listRel' a0 a1
</pre>

<DT><span class="strong">listRel_strongind</span>
<DD>
<pre>
|- ‚àÄR listRel'.
     listRel' [] [] ‚àß
     (‚àÄh1 h2 t1 t2.
        R h1 h2 ‚àß listRel R t1 t2 ‚àß listRel' t1 t2 ‚áí
        listRel' (h1::t1) (h2::t2)) ‚áí
     ‚àÄa0 a1. listRel R a0 a1 ‚áí listRel' a0 a1
</pre>

<DT><span class="strong">listRel_cases</span>
<DD>
<pre>
|- ‚àÄR a0 a1.
     listRel R a0 a1 ‚áî
     (a0 = []) ‚àß (a1 = []) ‚à®
     ‚àÉh1 h2 t1 t2. (a0 = h1::t1) ‚àß (a1 = h2::t2) ‚àß R h1 h2 ‚àß listRel R t1 t2
</pre>

<DT><span class="strong">listRel_NIL</span>
<DD>
<pre>
|- (listRel R [] y ‚áî (y = [])) ‚àß (listRel R x [] ‚áî (x = []))
</pre>

<DT><span class="strong">listRel_CONS</span>
<DD>
<pre>
|- (listRel R (h::t) y ‚áî ‚àÉh' t'. (y = h'::t') ‚àß R h h' ‚àß listRel R t t') ‚àß
   (listRel R x (h'::t') ‚áî ‚àÉh t. (x = h::t) ‚àß R h h' ‚àß listRel R t t')
</pre>

<DT><span class="strong">listRel_LENGTH</span>
<DD>
<pre>
|- ‚àÄx y. listRel R x y ‚áí (LENGTH x = LENGTH y)
</pre>

<DT><span class="strong">listRel_strong_ind</span>
<DD>
<pre>
|- ‚àÄR listRel'.
     listRel' [] [] ‚àß
     (‚àÄh1 h2 t1 t2.
        R h1 h2 ‚àß listRel R t1 t2 ‚àß listRel' t1 t2 ‚áí
        listRel' (h1::t1) (h2::t2)) ‚áí
     ‚àÄa0 a1. listRel R a0 a1 ‚áí listRel' a0 a1
</pre>

<DT><span class="strong">MONO_listRel</span>
<DD>
<pre>
|- (‚àÄx y. R x y ‚áí R' x y) ‚áí listRel R x y ‚áí listRel R' x y
</pre>

<DT><span class="strong">isPREFIX_THM</span>
<DD>
<pre>
|- ([] ‚âº l ‚áî T) ‚àß (h::t ‚âº [] ‚áî F) ‚àß (h1::t1 ‚âº h2::t2 ‚áî (h1 = h2) ‚àß t1 ‚âº t2)
</pre>

<DT><span class="strong">LENGTH_SNOC</span>
<DD>
<pre>
|- ‚àÄx l. LENGTH (SNOC x l) = SUC (LENGTH l)
</pre>

<DT><span class="strong">LAST_SNOC</span>
<DD>
<pre>
|- ‚àÄx l. LAST (SNOC x l) = x
</pre>

<DT><span class="strong">FRONT_SNOC</span>
<DD>
<pre>
|- ‚àÄx l. FRONT (SNOC x l) = l
</pre>

<DT><span class="strong">SNOC_APPEND</span>
<DD>
<pre>
|- ‚àÄx l. SNOC x l = l ++ [x]
</pre>

<DT><span class="strong">LIST_TO_SET_SNOC</span>
<DD>
<pre>
|- LIST_TO_SET (SNOC x ls) = x INSERT LIST_TO_SET ls
</pre>

<DT><span class="strong">INFINITE_LIST_UNIV</span>
<DD>
<pre>
|- INFINITE ùïå(:Œ± list)
</pre>

<DT><span class="strong">LEN_LENGTH_LEM</span>
<DD>
<pre>
|- ‚àÄL n. LEN L n = LENGTH L + n
</pre>

<DT><span class="strong">REV_REVERSE_LEM</span>
<DD>
<pre>
|- ‚àÄL1 L2. REV L1 L2 = REVERSE L1 ++ L2
</pre>

<DT><span class="strong">LENGTH_LEN</span>
<DD>
<pre>
|- ‚àÄL. LENGTH L = LEN L 0
</pre>

<DT><span class="strong">REVERSE_REV</span>
<DD>
<pre>
|- ‚àÄL. REVERSE L = REV L []
</pre>

</DL>



<hr>
</body>
</html>
