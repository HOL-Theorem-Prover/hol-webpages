<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: ieee</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "ieee"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "transcTheory.html"><span class="strong">transc</span></a>

<h1>Signature</h1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr> <th> Type <th> Arity<tr><td> <span class="strong">ccode</span> <td> 0
    <tr><td> <span class="strong">float</span> <td> 0
    <tr><td> <span class="strong">roundmode</span> <td> 0
    <tr>
    <th>
    Constant
    <th>
    Type<tr><td> <span class="strong">Eq</span> <td> :ccode
    <tr><td> <span class="strong">Exponent</span> <td> :float -> num
    <tr><td> <span class="strong">Finite</span> <td> :float -> bool
    <tr><td> <span class="strong">Float</span> <td> :real -> float
    <tr><td> <span class="strong">Fraction</span> <td> :float -> num
    <tr><td> <span class="strong">Gt</span> <td> :ccode
    <tr><td> <span class="strong">Infinity</span> <td> :float -> bool
    <tr><td> <span class="strong">Isdenormal</span> <td> :float -> bool
    <tr><td> <span class="strong">Isintegral</span> <td> :float -> bool
    <tr><td> <span class="strong">Isnan</span> <td> :float -> bool
    <tr><td> <span class="strong">Isnormal</span> <td> :float -> bool
    <tr><td> <span class="strong">Iszero</span> <td> :float -> bool
    <tr><td> <span class="strong">Lt</span> <td> :ccode
    <tr><td> <span class="strong">Minus_infinity</span> <td> :float
    <tr><td> <span class="strong">Minus_zero</span> <td> :float
    <tr><td> <span class="strong">Plus_infinity</span> <td> :float
    <tr><td> <span class="strong">Plus_zero</span> <td> :float
    <tr><td> <span class="strong">ROUNDFLOAT</span> <td> :float -> float
    <tr><td> <span class="strong">Sign</span> <td> :float -> num
    <tr><td> <span class="strong">To_nearest</span> <td> :roundmode
    <tr><td> <span class="strong">To_ninfinity</span> <td> :roundmode
    <tr><td> <span class="strong">To_pinfinity</span> <td> :roundmode
    <tr><td> <span class="strong">Ulp</span> <td> :float -> real
    <tr><td> <span class="strong">Un</span> <td> :ccode
    <tr><td> <span class="strong">Val</span> <td> :float -> real
    <tr><td> <span class="strong">bias</span> <td> :num # num -> num
    <tr><td>
        <span class="strong">bottomfloat</span>
        <td>
        :num # num -> num # num # num
    <tr><td> <span class="strong">ccode2num</span> <td> :ccode -> num
    <tr><td>
        <span class="strong">ccode_case</span>
        <td>
        :α -> α -> α -> α -> ccode -> α
    <tr><td> <span class="strong">ccode_size</span> <td> :ccode -> num
    <tr><td>
        <span class="strong">closest</span>
        <td>
        :(α -> real) -> (α -> bool) -> (α -> bool) -> real -> α
    <tr><td>
        <span class="strong">defloat</span>
        <td>
        :float -> num # num # num
    <tr><td> <span class="strong">emax</span> <td> :num # num -> num
    <tr><td>
        <span class="strong">encoding</span>
        <td>
        :num # num -> num # num # num -> num
    <tr><td> <span class="strong">exponent</span> <td> :num # num # num -> num
    <tr><td> <span class="strong">expwidth</span> <td> :num # num -> num
    <tr><td>
        <span class="strong">fadd</span>
        <td>
        :num # num ->
         roundmode -> num # num # num -> num # num # num -> num # num # num
    <tr><td>
        <span class="strong">fcompare</span>
        <td>
        :num # num -> num # num # num -> num # num # num -> ccode
    <tr><td>
        <span class="strong">fdiv</span>
        <td>
        :num # num ->
         roundmode -> num # num # num -> num # num # num -> num # num # num
    <tr><td>
        <span class="strong">feq</span>
        <td>
        :num # num -> num # num # num -> num # num # num -> bool
    <tr><td>
        <span class="strong">fge</span>
        <td>
        :num # num -> num # num # num -> num # num # num -> bool
    <tr><td>
        <span class="strong">fgt</span>
        <td>
        :num # num -> num # num # num -> num # num # num -> bool
    <tr><td>
        <span class="strong">fintrnd</span>
        <td>
        :num # num -> roundmode -> num # num # num -> num # num # num
    <tr><td>
        <span class="strong">fle</span>
        <td>
        :num # num -> num # num # num -> num # num # num -> bool
    <tr><td> <span class="strong">float</span> <td> :num # num # num -> float
    <tr><td> <span class="strong">float_To_zero</span> <td> :roundmode
    <tr><td> <span class="strong">float_abs</span> <td> :float -> float
    <tr><td>
        <span class="strong">float_add</span>
        <td>
        :float -> float -> float
    <tr><td>
        <span class="strong">float_div</span>
        <td>
        :float -> float -> float
    <tr><td> <span class="strong">float_eq</span> <td> :float -> float -> bool
    <tr><td> <span class="strong">float_format</span> <td> :num # num
    <tr><td> <span class="strong">float_ge</span> <td> :float -> float -> bool
    <tr><td> <span class="strong">float_gt</span> <td> :float -> float -> bool
    <tr><td> <span class="strong">float_le</span> <td> :float -> float -> bool
    <tr><td> <span class="strong">float_lt</span> <td> :float -> float -> bool
    <tr><td>
        <span class="strong">float_mul</span>
        <td>
        :float -> float -> float
    <tr><td> <span class="strong">float_neg</span> <td> :float -> float
    <tr><td>
        <span class="strong">float_rem</span>
        <td>
        :float -> float -> float
    <tr><td> <span class="strong">float_sqrt</span> <td> :float -> float
    <tr><td>
        <span class="strong">float_sub</span>
        <td>
        :float -> float -> float
    <tr><td>
        <span class="strong">flt</span>
        <td>
        :num # num -> num # num # num -> num # num # num -> bool
    <tr><td>
        <span class="strong">fmul</span>
        <td>
        :num # num ->
         roundmode -> num # num # num -> num # num # num -> num # num # num
    <tr><td>
        <span class="strong">fneg</span>
        <td>
        :num # num -> roundmode -> num # num # num -> num # num # num
    <tr><td> <span class="strong">fraction</span> <td> :num # num # num -> num
    <tr><td> <span class="strong">fracwidth</span> <td> :num # num -> num
    <tr><td>
        <span class="strong">frem</span>
        <td>
        :num # num ->
         roundmode -> num # num # num -> num # num # num -> num # num # num
    <tr><td>
        <span class="strong">fsqrt</span>
        <td>
        :num # num -> roundmode -> num # num # num -> num # num # num
    <tr><td>
        <span class="strong">fsub</span>
        <td>
        :num # num ->
         roundmode -> num # num # num -> num # num # num -> num # num # num
    <tr><td>
        <span class="strong">intround</span>
        <td>
        :num # num -> roundmode -> real -> num # num # num
    <tr><td>
        <span class="strong">is_closest</span>
        <td>
        :(α -> real) -> (α -> bool) -> real -> α -> bool
    <tr><td>
        <span class="strong">is_denormal</span>
        <td>
        :num # num -> num # num # num -> bool
    <tr><td> <span class="strong">is_double</span> <td> :num # num -> bool
    <tr><td>
        <span class="strong">is_double_extended</span>
        <td>
        :num # num -> bool
    <tr><td>
        <span class="strong">is_finite</span>
        <td>
        :num # num -> num # num # num -> bool
    <tr><td>
        <span class="strong">is_infinity</span>
        <td>
        :num # num -> num # num # num -> bool
    <tr><td>
        <span class="strong">is_integral</span>
        <td>
        :num # num -> num # num # num -> bool
    <tr><td>
        <span class="strong">is_nan</span>
        <td>
        :num # num -> num # num # num -> bool
    <tr><td>
        <span class="strong">is_normal</span>
        <td>
        :num # num -> num # num # num -> bool
    <tr><td> <span class="strong">is_single</span> <td> :num # num -> bool
    <tr><td>
        <span class="strong">is_single_extended</span>
        <td>
        :num # num -> bool
    <tr><td>
        <span class="strong">is_valid</span>
        <td>
        :num # num -> num # num # num -> bool
    <tr><td>
        <span class="strong">is_zero</span>
        <td>
        :num # num -> num # num # num -> bool
    <tr><td> <span class="strong">largest</span> <td> :num # num -> real
    <tr><td>
        <span class="strong">minus</span>
        <td>
        :num # num -> num # num # num -> num # num # num
    <tr><td>
        <span class="strong">minus_infinity</span>
        <td>
        :num # num -> num # num # num
    <tr><td>
        <span class="strong">minus_zero</span>
        <td>
        :num # num -> num # num # num
    <tr><td> <span class="strong">num2ccode</span> <td> :num -> ccode
    <tr><td> <span class="strong">num2roundmode</span> <td> :num -> roundmode
    <tr><td>
        <span class="strong">plus_infinity</span>
        <td>
        :num # num -> num # num # num
    <tr><td>
        <span class="strong">plus_zero</span>
        <td>
        :num # num -> num # num # num
    <tr><td> <span class="strong">rem</span> <td> :real -> real -> real
    <tr><td>
        <span class="strong">round</span>
        <td>
        :num # num -> roundmode -> real -> num # num # num
    <tr><td> <span class="strong">roundmode2num</span> <td> :roundmode -> num
    <tr><td>
        <span class="strong">roundmode_case</span>
        <td>
        :α -> α -> α -> α -> roundmode -> α
    <tr><td> <span class="strong">roundmode_size</span> <td> :roundmode -> num
    <tr><td> <span class="strong">sign</span> <td> :num # num # num -> num
    <tr><td>
        <span class="strong">some_nan</span>
        <td>
        :num # num -> num # num # num
    <tr><td> <span class="strong">threshold</span> <td> :num # num -> real
    <tr><td>
        <span class="strong">topfloat</span>
        <td>
        :num # num -> num # num # num
    <tr><td>
        <span class="strong">ulp</span>
        <td>
        :num # num -> num # num # num -> real
    <tr><td>
        <span class="strong">valof</span>
        <td>
        :num # num -> num # num # num -> real
    <tr><td> <span class="strong">wordlength</span> <td> :num # num -> num
    <tr><td>
        <span class="strong">zerosign</span>
        <td>
        :num # num -> num -> num # num # num -> num # num # num
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">expwidth</span>
<DD>
<pre>
|- ∀ew fw. expwidth (ew,fw) = ew
</pre>

<DT><span class="strong">fracwidth</span>
<DD>
<pre>
|- ∀ew fw. fracwidth (ew,fw) = fw
</pre>

<DT><span class="strong">wordlength</span>
<DD>
<pre>
|- ∀X. wordlength X = expwidth X + fracwidth X + 1
</pre>

<DT><span class="strong">emax</span>
<DD>
<pre>
|- ∀X. emax X = 2 ** expwidth X − 1
</pre>

<DT><span class="strong">bias</span>
<DD>
<pre>
|- ∀X. bias X = 2 ** (expwidth X − 1) − 1
</pre>

<DT><span class="strong">is_single</span>
<DD>
<pre>
|- ∀X. is_single X ⇔ (expwidth X = 8) ∧ (wordlength X = 32)
</pre>

<DT><span class="strong">is_double</span>
<DD>
<pre>
|- ∀X. is_double X ⇔ (expwidth X = 11) ∧ (wordlength X = 64)
</pre>

<DT><span class="strong">is_single_extended</span>
<DD>
<pre>
|- ∀X. is_single_extended X ⇔ expwidth X ≥ 11 ∧ wordlength X ≥ 43
</pre>

<DT><span class="strong">is_double_extended</span>
<DD>
<pre>
|- ∀X. is_double_extended X ⇔ expwidth X ≥ 15 ∧ wordlength X ≥ 79
</pre>

<DT><span class="strong">sign</span>
<DD>
<pre>
|- ∀s e f. sign (s,e,f) = s
</pre>

<DT><span class="strong">exponent</span>
<DD>
<pre>
|- ∀s e f. exponent (s,e,f) = e
</pre>

<DT><span class="strong">fraction</span>
<DD>
<pre>
|- ∀s e f. fraction (s,e,f) = f
</pre>

<DT><span class="strong">is_nan</span>
<DD>
<pre>
|- ∀X a. is_nan X a ⇔ (exponent a = emax X) ∧ fraction a ≠ 0
</pre>

<DT><span class="strong">is_infinity</span>
<DD>
<pre>
|- ∀X a. is_infinity X a ⇔ (exponent a = emax X) ∧ (fraction a = 0)
</pre>

<DT><span class="strong">is_normal</span>
<DD>
<pre>
|- ∀X a. is_normal X a ⇔ 0 < exponent a ∧ exponent a < emax X
</pre>

<DT><span class="strong">is_denormal</span>
<DD>
<pre>
|- ∀X a. is_denormal X a ⇔ (exponent a = 0) ∧ fraction a ≠ 0
</pre>

<DT><span class="strong">is_zero</span>
<DD>
<pre>
|- ∀X a. is_zero X a ⇔ (exponent a = 0) ∧ (fraction a = 0)
</pre>

<DT><span class="strong">is_valid</span>
<DD>
<pre>
|- ∀X s e f.
     is_valid X (s,e,f) ⇔
     s < SUC (SUC 0) ∧ e < 2 ** expwidth X ∧ f < 2 ** fracwidth X
</pre>

<DT><span class="strong">is_finite</span>
<DD>
<pre>
|- ∀X a.
     is_finite X a ⇔
     is_valid X a ∧ (is_normal X a ∨ is_denormal X a ∨ is_zero X a)
</pre>

<DT><span class="strong">plus_infinity</span>
<DD>
<pre>
|- ∀X. plus_infinity X = (0,emax X,0)
</pre>

<DT><span class="strong">minus_infinity</span>
<DD>
<pre>
|- ∀X. minus_infinity X = (1,emax X,0)
</pre>

<DT><span class="strong">plus_zero</span>
<DD>
<pre>
|- ∀X. plus_zero X = (0,0,0)
</pre>

<DT><span class="strong">minus_zero</span>
<DD>
<pre>
|- ∀X. minus_zero X = (1,0,0)
</pre>

<DT><span class="strong">topfloat</span>
<DD>
<pre>
|- ∀X. topfloat X = (0,emax X − 1,2 ** fracwidth X − 1)
</pre>

<DT><span class="strong">bottomfloat</span>
<DD>
<pre>
|- ∀X. bottomfloat X = (1,emax X − 1,2 ** fracwidth X − 1)
</pre>

<DT><span class="strong">minus</span>
<DD>
<pre>
|- ∀X a. minus X a = (1 − sign a,exponent a,fraction a)
</pre>

<DT><span class="strong">encoding</span>
<DD>
<pre>
|- ∀X s e f.
     encoding X (s,e,f) =
     s * 2 ** (wordlength X − 1) + e * 2 ** fracwidth X + f
</pre>

<DT><span class="strong">valof</span>
<DD>
<pre>
|- ∀X s e f.
     valof X (s,e,f) =
     if e = 0 then
       -1 pow s * (2 / 2 pow bias X) * (&f / 2 pow fracwidth X)
     else
       -1 pow s * (2 pow e / 2 pow bias X) * (1 + &f / 2 pow fracwidth X)
</pre>

<DT><span class="strong">largest</span>
<DD>
<pre>
|- ∀X.
     largest X =
     2 pow (emax X − 1) / 2 pow bias X * (2 − inv (2 pow fracwidth X))
</pre>

<DT><span class="strong">threshold</span>
<DD>
<pre>
|- ∀X.
     threshold X =
     2 pow (emax X − 1) / 2 pow bias X * (2 − inv (2 pow SUC (fracwidth X)))
</pre>

<DT><span class="strong">ulp</span>
<DD>
<pre>
|- ∀X a. ulp X a = valof X (0,exponent a,1) − valof X (0,exponent a,0)
</pre>

<DT><span class="strong">roundmode_TY_DEF</span>
<DD>
<pre>
|- ∃rep. TYPE_DEFINITION (λn. n < 4) rep
</pre>

<DT><span class="strong">roundmode_BIJ</span>
<DD>
<pre>
|- (∀a. num2roundmode (roundmode2num a) = a) ∧
   ∀r. (λn. n < 4) r ⇔ (roundmode2num (num2roundmode r) = r)
</pre>

<DT><span class="strong">To_nearest</span>
<DD>
<pre>
|- To_nearest = num2roundmode 0
</pre>

<DT><span class="strong">float_To_zero</span>
<DD>
<pre>
|- float_To_zero = num2roundmode 1
</pre>

<DT><span class="strong">To_pinfinity</span>
<DD>
<pre>
|- To_pinfinity = num2roundmode 2
</pre>

<DT><span class="strong">To_ninfinity</span>
<DD>
<pre>
|- To_ninfinity = num2roundmode 3
</pre>

<DT><span class="strong">roundmode_size_def</span>
<DD>
<pre>
|- ∀x. roundmode_size x = 0
</pre>

<DT><span class="strong">roundmode_case</span>
<DD>
<pre>
|- ∀v0 v1 v2 v3 x.
     (case x of
         To_nearest -> v0
      || float_To_zero -> v1
      || To_pinfinity -> v2
      || To_ninfinity -> v3) =
     (λm.
        if m < 1 then v0 else if m < 2 then v1 else if m = 2 then v2 else v3)
       (roundmode2num x)
</pre>

<DT><span class="strong">is_closest</span>
<DD>
<pre>
|- ∀v s x a.
     is_closest v s x a ⇔ a ∈ s ∧ ∀b. b ∈ s ⇒ abs (v a − x) ≤ abs (v b − x)
</pre>

<DT><span class="strong">closest</span>
<DD>
<pre>
|- ∀v p s x.
     closest v p s x =
     @a. is_closest v s x a ∧ ((∃b. is_closest v s x b ∧ p b) ⇒ p a)
</pre>

<DT><span class="strong">round_def</span>
<DD>
<pre>
|- (∀X x.
      round X To_nearest x =
      if x ≤ -threshold X then
        minus_infinity X
      else if x ≥ threshold X then
        plus_infinity X
      else
        closest (valof X) (λa. EVEN (fraction a)) {a | is_finite X a} x) ∧
   (∀X x.
      round X float_To_zero x =
      if x < -largest X then
        bottomfloat X
      else if x > largest X then
        topfloat X
      else
        closest (valof X) (λx. T)
          {a | is_finite X a ∧ abs (valof X a) ≤ abs x} x) ∧
   (∀X x.
      round X To_pinfinity x =
      if x < -largest X then
        bottomfloat X
      else if x > largest X then
        plus_infinity X
      else
        closest (valof X) (λx. T) {a | is_finite X a ∧ valof X a ≥ x} x) ∧
   ∀X x.
     round X To_ninfinity x =
     if x < -largest X then
       minus_infinity X
     else if x > largest X then
       topfloat X
     else
       closest (valof X) (λx. T) {a | is_finite X a ∧ valof X a ≤ x} x
</pre>

<DT><span class="strong">is_integral</span>
<DD>
<pre>
|- ∀X a. is_integral X a ⇔ is_finite X a ∧ ∃n. abs (valof X a) = &n
</pre>

<DT><span class="strong">intround_def</span>
<DD>
<pre>
|- (∀X x.
      intround X To_nearest x =
      if x ≤ -threshold X then
        minus_infinity X
      else if x ≥ threshold X then
        plus_infinity X
      else
        closest (valof X) (λa. ∃n. EVEN n ∧ (abs (valof X a) = &n))
          {a | is_integral X a} x) ∧
   (∀X x.
      intround X float_To_zero x =
      if x < -largest X then
        bottomfloat X
      else if x > largest X then
        topfloat X
      else
        closest (valof X) (λx. T)
          {a | is_integral X a ∧ abs (valof X a) ≤ abs x} x) ∧
   (∀X x.
      intround X To_pinfinity x =
      if x < -largest X then
        bottomfloat X
      else if x > largest X then
        plus_infinity X
      else
        closest (valof X) (λx. T) {a | is_integral X a ∧ valof X a ≥ x} x) ∧
   ∀X x.
     intround X To_ninfinity x =
     if x < -largest X then
       minus_infinity X
     else if x > largest X then
       topfloat X
     else
       closest (valof X) (λx. T) {a | is_integral X a ∧ valof X a ≤ x} x
</pre>

<DT><span class="strong">some_nan</span>
<DD>
<pre>
|- ∀X. some_nan X = @a. is_nan X a
</pre>

<DT><span class="strong">zerosign</span>
<DD>
<pre>
|- ∀X s a.
     zerosign X s a =
     if is_zero X a then if s = 0 then plus_zero X else minus_zero X else a
</pre>

<DT><span class="strong">rem</span>
<DD>
<pre>
|- ∀x y.
     x rem y =
     (let n =
            closest I (λx. ∃n. EVEN n ∧ (abs x = &n)) {x | ∃n. abs x = &n}
              (x / y)
      in
        x − n * y)
</pre>

<DT><span class="strong">fintrnd</span>
<DD>
<pre>
|- ∀X m a.
     fintrnd X m a =
     if is_nan X a then
       some_nan X
     else if is_infinity X a then
       a
     else
       zerosign X (sign a) (intround X m (valof X a))
</pre>

<DT><span class="strong">fadd</span>
<DD>
<pre>
|- ∀X m a b.
     fadd X m a b =
     if
       is_nan X a ∨ is_nan X b ∨
       is_infinity X a ∧ is_infinity X b ∧ sign a ≠ sign b
     then
       some_nan X
     else if is_infinity X a then
       a
     else if is_infinity X b then
       b
     else
       zerosign X
         (if is_zero X a ∧ is_zero X b ∧ (sign a = sign b) then
            sign a
          else if m = To_ninfinity then
            1
          else
            0) (round X m (valof X a + valof X b))
</pre>

<DT><span class="strong">fsub</span>
<DD>
<pre>
|- ∀X m a b.
     fsub X m a b =
     if
       is_nan X a ∨ is_nan X b ∨
       is_infinity X a ∧ is_infinity X b ∧ (sign a = sign b)
     then
       some_nan X
     else if is_infinity X a then
       a
     else if is_infinity X b then
       minus X b
     else
       zerosign X
         (if is_zero X a ∧ is_zero X b ∧ sign a ≠ sign b then
            sign a
          else if m = To_ninfinity then
            1
          else
            0) (round X m (valof X a − valof X b))
</pre>

<DT><span class="strong">fmul</span>
<DD>
<pre>
|- ∀X m a b.
     fmul X m a b =
     if
       is_nan X a ∨ is_nan X b ∨ is_zero X a ∧ is_infinity X b ∨
       is_infinity X a ∧ is_zero X b
     then
       some_nan X
     else if is_infinity X a ∨ is_infinity X b then
       if sign a = sign b then plus_infinity X else minus_infinity X
     else
       zerosign X (if sign a = sign b then 0 else 1)
         (round X m (valof X a * valof X b))
</pre>

<DT><span class="strong">fdiv</span>
<DD>
<pre>
|- ∀X m a b.
     fdiv X m a b =
     if
       is_nan X a ∨ is_nan X b ∨ is_zero X a ∧ is_zero X b ∨
       is_infinity X a ∧ is_infinity X b
     then
       some_nan X
     else if is_infinity X a ∨ is_zero X b then
       if sign a = sign b then plus_infinity X else minus_infinity X
     else if is_infinity X b then
       if sign a = sign b then plus_zero X else minus_zero X
     else
       zerosign X (if sign a = sign b then 0 else 1)
         (round X m (valof X a / valof X b))
</pre>

<DT><span class="strong">fsqrt</span>
<DD>
<pre>
|- ∀X m a.
     fsqrt X m a =
     if is_nan X a then
       some_nan X
     else if is_zero X a ∨ is_infinity X a ∧ (sign a = 0) then
       a
     else if sign a = 1 then
       some_nan X
     else
       zerosign X (sign a) (round X m (sqrt (valof X a)))
</pre>

<DT><span class="strong">frem</span>
<DD>
<pre>
|- ∀X m a b.
     frem X m a b =
     if is_nan X a ∨ is_nan X b ∨ is_infinity X a ∨ is_zero X b then
       some_nan X
     else if is_infinity X b then
       a
     else
       zerosign X (sign a) (round X m (valof X a rem valof X b))
</pre>

<DT><span class="strong">fneg</span>
<DD>
<pre>
|- ∀X m a. fneg X m a = (1 − sign a,exponent a,fraction a)
</pre>

<DT><span class="strong">ccode_TY_DEF</span>
<DD>
<pre>
|- ∃rep. TYPE_DEFINITION (λn. n < 4) rep
</pre>

<DT><span class="strong">ccode_BIJ</span>
<DD>
<pre>
|- (∀a. num2ccode (ccode2num a) = a) ∧
   ∀r. (λn. n < 4) r ⇔ (ccode2num (num2ccode r) = r)
</pre>

<DT><span class="strong">Gt</span>
<DD>
<pre>
|- Gt = num2ccode 0
</pre>

<DT><span class="strong">Lt</span>
<DD>
<pre>
|- Lt = num2ccode 1
</pre>

<DT><span class="strong">Eq</span>
<DD>
<pre>
|- Eq = num2ccode 2
</pre>

<DT><span class="strong">Un</span>
<DD>
<pre>
|- Un = num2ccode 3
</pre>

<DT><span class="strong">ccode_size_def</span>
<DD>
<pre>
|- ∀x. ccode_size x = 0
</pre>

<DT><span class="strong">ccode_case</span>
<DD>
<pre>
|- ∀v0 v1 v2 v3 x.
     (case x of Gt -> v0 || Lt -> v1 || Eq -> v2 || Un -> v3) =
     (λm.
        if m < 1 then v0 else if m < 2 then v1 else if m = 2 then v2 else v3)
       (ccode2num x)
</pre>

<DT><span class="strong">fcompare</span>
<DD>
<pre>
|- ∀X a b.
     fcompare X a b =
     if is_nan X a ∨ is_nan X b then
       Un
     else if is_infinity X a ∧ (sign a = 1) then
       if is_infinity X b ∧ (sign b = 1) then Eq else Lt
     else if is_infinity X a ∧ (sign a = 0) then
       if is_infinity X b ∧ (sign b = 0) then Eq else Gt
     else if is_infinity X b ∧ (sign b = 1) then
       Gt
     else if is_infinity X b ∧ (sign b = 0) then
       Lt
     else if valof X a < valof X b then
       Lt
     else if valof X a = valof X b then
       Eq
     else
       Gt
</pre>

<DT><span class="strong">flt</span>
<DD>
<pre>
|- ∀X a b. flt X a b ⇔ (fcompare X a b = Lt)
</pre>

<DT><span class="strong">fle</span>
<DD>
<pre>
|- ∀X a b. fle X a b ⇔ (fcompare X a b = Lt) ∨ (fcompare X a b = Eq)
</pre>

<DT><span class="strong">fgt</span>
<DD>
<pre>
|- ∀X a b. fgt X a b ⇔ (fcompare X a b = Gt)
</pre>

<DT><span class="strong">fge</span>
<DD>
<pre>
|- ∀X a b. fge X a b ⇔ (fcompare X a b = Gt) ∨ (fcompare X a b = Eq)
</pre>

<DT><span class="strong">feq</span>
<DD>
<pre>
|- ∀X a b. feq X a b ⇔ (fcompare X a b = Eq)
</pre>

<DT><span class="strong">float_format</span>
<DD>
<pre>
|- float_format = (8,23)
</pre>

<DT><span class="strong">float_TY_DEF</span>
<DD>
<pre>
|- ∃rep. TYPE_DEFINITION (is_valid float_format) rep
</pre>

<DT><span class="strong">float_tybij</span>
<DD>
<pre>
|- (∀a. float (defloat a) = a) ∧
   ∀r. is_valid float_format r ⇔ (defloat (float r) = r)
</pre>

<DT><span class="strong">Val</span>
<DD>
<pre>
|- ∀a. Val a = valof float_format (defloat a)
</pre>

<DT><span class="strong">Float</span>
<DD>
<pre>
|- ∀x. Float x = float (round float_format To_nearest x)
</pre>

<DT><span class="strong">Sign</span>
<DD>
<pre>
|- ∀a. Sign a = sign (defloat a)
</pre>

<DT><span class="strong">Exponent</span>
<DD>
<pre>
|- ∀a. Exponent a = exponent (defloat a)
</pre>

<DT><span class="strong">Fraction</span>
<DD>
<pre>
|- ∀a. Fraction a = fraction (defloat a)
</pre>

<DT><span class="strong">Ulp</span>
<DD>
<pre>
|- ∀a. Ulp a = ulp float_format (defloat a)
</pre>

<DT><span class="strong">Isnan</span>
<DD>
<pre>
|- ∀a. Isnan a ⇔ is_nan float_format (defloat a)
</pre>

<DT><span class="strong">Infinity</span>
<DD>
<pre>
|- ∀a. Infinity a ⇔ is_infinity float_format (defloat a)
</pre>

<DT><span class="strong">Isnormal</span>
<DD>
<pre>
|- ∀a. Isnormal a ⇔ is_normal float_format (defloat a)
</pre>

<DT><span class="strong">Isdenormal</span>
<DD>
<pre>
|- ∀a. Isdenormal a ⇔ is_denormal float_format (defloat a)
</pre>

<DT><span class="strong">Iszero</span>
<DD>
<pre>
|- ∀a. Iszero a ⇔ is_zero float_format (defloat a)
</pre>

<DT><span class="strong">Finite</span>
<DD>
<pre>
|- ∀a. Finite a ⇔ Isnormal a ∨ Isdenormal a ∨ Iszero a
</pre>

<DT><span class="strong">Isintegral</span>
<DD>
<pre>
|- ∀a. Isintegral a ⇔ is_integral float_format (defloat a)
</pre>

<DT><span class="strong">Plus_zero</span>
<DD>
<pre>
|- Plus_zero = float (plus_zero float_format)
</pre>

<DT><span class="strong">Minus_zero</span>
<DD>
<pre>
|- Minus_zero = float (minus_zero float_format)
</pre>

<DT><span class="strong">Minus_infinity</span>
<DD>
<pre>
|- Minus_infinity = float (minus_infinity float_format)
</pre>

<DT><span class="strong">Plus_infinity</span>
<DD>
<pre>
|- Plus_infinity = float (plus_infinity float_format)
</pre>

<DT><span class="strong">float_add</span>
<DD>
<pre>
|- ∀a b. a + b = float (fadd float_format To_nearest (defloat a) (defloat b))
</pre>

<DT><span class="strong">float_sub</span>
<DD>
<pre>
|- ∀a b. a − b = float (fsub float_format To_nearest (defloat a) (defloat b))
</pre>

<DT><span class="strong">float_mul</span>
<DD>
<pre>
|- ∀a b. a * b = float (fmul float_format To_nearest (defloat a) (defloat b))
</pre>

<DT><span class="strong">float_div</span>
<DD>
<pre>
|- ∀a b. a / b = float (fdiv float_format To_nearest (defloat a) (defloat b))
</pre>

<DT><span class="strong">float_rem</span>
<DD>
<pre>
|- ∀a b.
     a float_rem b =
     float (frem float_format To_nearest (defloat a) (defloat b))
</pre>

<DT><span class="strong">float_sqrt</span>
<DD>
<pre>
|- ∀a. float_sqrt a = float (fsqrt float_format To_nearest (defloat a))
</pre>

<DT><span class="strong">ROUNDFLOAT</span>
<DD>
<pre>
|- ∀a. ROUNDFLOAT a = float (fintrnd float_format To_nearest (defloat a))
</pre>

<DT><span class="strong">float_lt</span>
<DD>
<pre>
|- ∀a b. a < b ⇔ flt float_format (defloat a) (defloat b)
</pre>

<DT><span class="strong">float_le</span>
<DD>
<pre>
|- ∀a b. a ≤ b ⇔ fle float_format (defloat a) (defloat b)
</pre>

<DT><span class="strong">float_gt</span>
<DD>
<pre>
|- ∀a b. a > b ⇔ fgt float_format (defloat a) (defloat b)
</pre>

<DT><span class="strong">float_ge</span>
<DD>
<pre>
|- ∀a b. a ≥ b ⇔ fge float_format (defloat a) (defloat b)
</pre>

<DT><span class="strong">float_eq</span>
<DD>
<pre>
|- ∀a b. a == b ⇔ feq float_format (defloat a) (defloat b)
</pre>

<DT><span class="strong">float_neg</span>
<DD>
<pre>
|- ∀a. ¬a = float (fneg float_format To_nearest (defloat a))
</pre>

<DT><span class="strong">float_abs</span>
<DD>
<pre>
|- ∀a. float_abs a = if a ≥ Plus_zero then a else ¬a
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">num2roundmode_roundmode2num</span>
<DD>
<pre>
|- ∀a. num2roundmode (roundmode2num a) = a
</pre>

<DT><span class="strong">roundmode2num_num2roundmode</span>
<DD>
<pre>
|- ∀r. r < 4 ⇔ (roundmode2num (num2roundmode r) = r)
</pre>

<DT><span class="strong">num2roundmode_11</span>
<DD>
<pre>
|- ∀r r'. r < 4 ⇒ r' < 4 ⇒ ((num2roundmode r = num2roundmode r') ⇔ (r = r'))
</pre>

<DT><span class="strong">roundmode2num_11</span>
<DD>
<pre>
|- ∀a a'. (roundmode2num a = roundmode2num a') ⇔ (a = a')
</pre>

<DT><span class="strong">num2roundmode_ONTO</span>
<DD>
<pre>
|- ∀a. ∃r. (a = num2roundmode r) ∧ r < 4
</pre>

<DT><span class="strong">roundmode2num_ONTO</span>
<DD>
<pre>
|- ∀r. r < 4 ⇔ ∃a. r = roundmode2num a
</pre>

<DT><span class="strong">num2roundmode_thm</span>
<DD>
<pre>
|- (num2roundmode 0 = To_nearest) ∧ (num2roundmode 1 = float_To_zero) ∧
   (num2roundmode 2 = To_pinfinity) ∧ (num2roundmode 3 = To_ninfinity)
</pre>

<DT><span class="strong">roundmode2num_thm</span>
<DD>
<pre>
|- (roundmode2num To_nearest = 0) ∧ (roundmode2num float_To_zero = 1) ∧
   (roundmode2num To_pinfinity = 2) ∧ (roundmode2num To_ninfinity = 3)
</pre>

<DT><span class="strong">roundmode_EQ_roundmode</span>
<DD>
<pre>
|- ∀a a'. (a = a') ⇔ (roundmode2num a = roundmode2num a')
</pre>

<DT><span class="strong">roundmode_case_def</span>
<DD>
<pre>
|- (∀v0 v1 v2 v3.
      (case To_nearest of
          To_nearest -> v0
       || float_To_zero -> v1
       || To_pinfinity -> v2
       || To_ninfinity -> v3) =
      v0) ∧
   (∀v0 v1 v2 v3.
      (case float_To_zero of
          To_nearest -> v0
       || float_To_zero -> v1
       || To_pinfinity -> v2
       || To_ninfinity -> v3) =
      v1) ∧
   (∀v0 v1 v2 v3.
      (case To_pinfinity of
          To_nearest -> v0
       || float_To_zero -> v1
       || To_pinfinity -> v2
       || To_ninfinity -> v3) =
      v2) ∧
   ∀v0 v1 v2 v3.
     (case To_ninfinity of
         To_nearest -> v0
      || float_To_zero -> v1
      || To_pinfinity -> v2
      || To_ninfinity -> v3) =
     v3
</pre>

<DT><span class="strong">datatype_roundmode</span>
<DD>
<pre>
|- DATATYPE (roundmode To_nearest float_To_zero To_pinfinity To_ninfinity)
</pre>

<DT><span class="strong">roundmode_distinct</span>
<DD>
<pre>
|- To_nearest ≠ float_To_zero ∧ To_nearest ≠ To_pinfinity ∧
   To_nearest ≠ To_ninfinity ∧ float_To_zero ≠ To_pinfinity ∧
   float_To_zero ≠ To_ninfinity ∧ To_pinfinity ≠ To_ninfinity
</pre>

<DT><span class="strong">roundmode_case_cong</span>
<DD>
<pre>
|- ∀M M' v0 v1 v2 v3.
     (M = M') ∧ ((M' = To_nearest) ⇒ (v0 = v0')) ∧
     ((M' = float_To_zero) ⇒ (v1 = v1')) ∧
     ((M' = To_pinfinity) ⇒ (v2 = v2')) ∧ ((M' = To_ninfinity) ⇒ (v3 = v3')) ⇒
     ((case M of
          To_nearest -> v0
       || float_To_zero -> v1
       || To_pinfinity -> v2
       || To_ninfinity -> v3) =
      case M' of
         To_nearest -> v0'
      || float_To_zero -> v1'
      || To_pinfinity -> v2'
      || To_ninfinity -> v3')
</pre>

<DT><span class="strong">roundmode_nchotomy</span>
<DD>
<pre>
|- ∀a.
     (a = To_nearest) ∨ (a = float_To_zero) ∨ (a = To_pinfinity) ∨
     (a = To_ninfinity)
</pre>

<DT><span class="strong">roundmode_Axiom</span>
<DD>
<pre>
|- ∀x0 x1 x2 x3.
     ∃f.
       (f To_nearest = x0) ∧ (f float_To_zero = x1) ∧ (f To_pinfinity = x2) ∧
       (f To_ninfinity = x3)
</pre>

<DT><span class="strong">roundmode_induction</span>
<DD>
<pre>
|- ∀P.
     P To_nearest ∧ P To_ninfinity ∧ P To_pinfinity ∧ P float_To_zero ⇒
     ∀a. P a
</pre>

<DT><span class="strong">num2ccode_ccode2num</span>
<DD>
<pre>
|- ∀a. num2ccode (ccode2num a) = a
</pre>

<DT><span class="strong">ccode2num_num2ccode</span>
<DD>
<pre>
|- ∀r. r < 4 ⇔ (ccode2num (num2ccode r) = r)
</pre>

<DT><span class="strong">num2ccode_11</span>
<DD>
<pre>
|- ∀r r'. r < 4 ⇒ r' < 4 ⇒ ((num2ccode r = num2ccode r') ⇔ (r = r'))
</pre>

<DT><span class="strong">ccode2num_11</span>
<DD>
<pre>
|- ∀a a'. (ccode2num a = ccode2num a') ⇔ (a = a')
</pre>

<DT><span class="strong">num2ccode_ONTO</span>
<DD>
<pre>
|- ∀a. ∃r. (a = num2ccode r) ∧ r < 4
</pre>

<DT><span class="strong">ccode2num_ONTO</span>
<DD>
<pre>
|- ∀r. r < 4 ⇔ ∃a. r = ccode2num a
</pre>

<DT><span class="strong">num2ccode_thm</span>
<DD>
<pre>
|- (num2ccode 0 = Gt) ∧ (num2ccode 1 = Lt) ∧ (num2ccode 2 = Eq) ∧
   (num2ccode 3 = Un)
</pre>

<DT><span class="strong">ccode2num_thm</span>
<DD>
<pre>
|- (ccode2num Gt = 0) ∧ (ccode2num Lt = 1) ∧ (ccode2num Eq = 2) ∧
   (ccode2num Un = 3)
</pre>

<DT><span class="strong">ccode_EQ_ccode</span>
<DD>
<pre>
|- ∀a a'. (a = a') ⇔ (ccode2num a = ccode2num a')
</pre>

<DT><span class="strong">ccode_case_def</span>
<DD>
<pre>
|- (∀v0 v1 v2 v3.
      (case Gt of Gt -> v0 || Lt -> v1 || Eq -> v2 || Un -> v3) = v0) ∧
   (∀v0 v1 v2 v3.
      (case Lt of Gt -> v0 || Lt -> v1 || Eq -> v2 || Un -> v3) = v1) ∧
   (∀v0 v1 v2 v3.
      (case Eq of Gt -> v0 || Lt -> v1 || Eq -> v2 || Un -> v3) = v2) ∧
   ∀v0 v1 v2 v3.
     (case Un of Gt -> v0 || Lt -> v1 || Eq -> v2 || Un -> v3) = v3
</pre>

<DT><span class="strong">datatype_ccode</span>
<DD>
<pre>
|- DATATYPE (ccode Gt Lt Eq Un)
</pre>

<DT><span class="strong">ccode_distinct</span>
<DD>
<pre>
|- Gt ≠ Lt ∧ Gt ≠ Eq ∧ Gt ≠ Un ∧ Lt ≠ Eq ∧ Lt ≠ Un ∧ Eq ≠ Un
</pre>

<DT><span class="strong">ccode_case_cong</span>
<DD>
<pre>
|- ∀M M' v0 v1 v2 v3.
     (M = M') ∧ ((M' = Gt) ⇒ (v0 = v0')) ∧ ((M' = Lt) ⇒ (v1 = v1')) ∧
     ((M' = Eq) ⇒ (v2 = v2')) ∧ ((M' = Un) ⇒ (v3 = v3')) ⇒
     ((case M of Gt -> v0 || Lt -> v1 || Eq -> v2 || Un -> v3) =
      case M' of Gt -> v0' || Lt -> v1' || Eq -> v2' || Un -> v3')
</pre>

<DT><span class="strong">ccode_nchotomy</span>
<DD>
<pre>
|- ∀a. (a = Gt) ∨ (a = Lt) ∨ (a = Eq) ∨ (a = Un)
</pre>

<DT><span class="strong">ccode_Axiom</span>
<DD>
<pre>
|- ∀x0 x1 x2 x3. ∃f. (f Gt = x0) ∧ (f Lt = x1) ∧ (f Eq = x2) ∧ (f Un = x3)
</pre>

<DT><span class="strong">ccode_induction</span>
<DD>
<pre>
|- ∀P. P Eq ∧ P Gt ∧ P Lt ∧ P Un ⇒ ∀a. P a
</pre>

</DL>



<hr>
</body>
</html>
