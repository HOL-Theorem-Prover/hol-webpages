<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: prob_indep</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "prob_indep"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "state_transformerTheory.html"><span class="strong">state_transformer</span></a>&nbsp;&nbsp;
    <a href = "probTheory.html"><span class="strong">prob</span></a>

<h1>Signature</h1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr>
    <th>
    Constant
    <th>
    Type<tr><td>
            <span class="strong">alg_cover</span>
            <td>
            :bool list list -> (num -> bool) -> bool list
    <tr><td>
        <span class="strong">alg_cover_set</span>
        <td>
        :bool list list -> bool
    <tr><td>
        <span class="strong">indep</span>
        <td>
        :((num -> bool) -> α # (num -> bool)) -> bool
    <tr><td>
        <span class="strong">indep_set</span>
        <td>
        :((num -> bool) -> bool) -> ((num -> bool) -> bool) -> bool
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">indep_set_def</span>
<DD>
<pre>
|- ∀p q.
     indep_set p q ⇔
     measurable p ∧ measurable q ∧ (prob (p ∩ q) = prob p * prob q)
</pre>

<DT><span class="strong">alg_cover_set_def</span>
<DD>
<pre>
|- ∀l.
     alg_cover_set l ⇔
     alg_sorted l ∧ alg_prefixfree l ∧ (algebra_embed l = 𝕌(:num -> bool))
</pre>

<DT><span class="strong">alg_cover_def</span>
<DD>
<pre>
|- ∀l x. alg_cover l x = @b. MEM b l ∧ alg_embed b x
</pre>

<DT><span class="strong">indep_def</span>
<DD>
<pre>
|- ∀f.
     indep f ⇔
     ∃l r.
       alg_cover_set l ∧
       ∀s. f s = (let c = alg_cover l s in (r c,SDROP (LENGTH c) s))
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">INDEP_SET_BASIC</span>
<DD>
<pre>
|- ∀p. measurable p ⇒ indep_set ∅ p ∧ indep_set 𝕌(:num -> bool) p
</pre>

<DT><span class="strong">INDEP_SET_SYM</span>
<DD>
<pre>
|- ∀p q. indep_set p q ⇔ indep_set p q
</pre>

<DT><span class="strong">INDEP_SET_DISJOINT_DECOMP</span>
<DD>
<pre>
|- ∀p q r. indep_set p r ∧ indep_set q r ∧ (p ∩ q = ∅) ⇒ indep_set (p ∪ q) r
</pre>

<DT><span class="strong">ALG_COVER_SET_BASIC</span>
<DD>
<pre>
|- ¬alg_cover_set [] ∧ alg_cover_set [[]] ∧ alg_cover_set [[T]; [F]]
</pre>

<DT><span class="strong">ALG_COVER_WELL_DEFINED</span>
<DD>
<pre>
|- ∀l x. alg_cover_set l ⇒ MEM (alg_cover l x) l ∧ alg_embed (alg_cover l x) x
</pre>

<DT><span class="strong">ALG_COVER_UNIV</span>
<DD>
<pre>
|- alg_cover [[]] = K []
</pre>

<DT><span class="strong">MAP_CONS_TL_FILTER</span>
<DD>
<pre>
|- ∀l b.
     ¬MEM [] l ⇒
     (MAP (CONS b) (MAP TL (FILTER (λx. HD x ⇔ b) l)) =
      FILTER (λx. HD x ⇔ b) l)
</pre>

<DT><span class="strong">ALG_COVER_SET_CASES_THM</span>
<DD>
<pre>
|- ∀l.
     alg_cover_set l ⇔
     (l = [[]]) ∨
     ∃l1 l2.
       alg_cover_set l1 ∧ alg_cover_set l2 ∧
       (l = MAP (CONS T) l1 ++ MAP (CONS F) l2)
</pre>

<DT><span class="strong">ALG_COVER_SET_CASES</span>
<DD>
<pre>
|- ∀P.
     P [[]] ∧
     (∀l1 l2.
        alg_cover_set l1 ∧ alg_cover_set l2 ∧
        alg_cover_set (MAP (CONS T) l1 ++ MAP (CONS F) l2) ⇒
        P (MAP (CONS T) l1 ++ MAP (CONS F) l2)) ⇒
     ∀l. alg_cover_set l ⇒ P l
</pre>

<DT><span class="strong">ALG_COVER_SET_INDUCTION</span>
<DD>
<pre>
|- ∀P.
     P [[]] ∧
     (∀l1 l2.
        alg_cover_set l1 ∧ alg_cover_set l2 ∧ P l1 ∧ P l2 ∧
        alg_cover_set (MAP (CONS T) l1 ++ MAP (CONS F) l2) ⇒
        P (MAP (CONS T) l1 ++ MAP (CONS F) l2)) ⇒
     ∀l. alg_cover_set l ⇒ P l
</pre>

<DT><span class="strong">ALG_COVER_EXISTS_UNIQUE</span>
<DD>
<pre>
|- ∀l. alg_cover_set l ⇒ ∀s. ∃!x. MEM x l ∧ alg_embed x s
</pre>

<DT><span class="strong">ALG_COVER_UNIQUE</span>
<DD>
<pre>
|- ∀l x s. alg_cover_set l ∧ MEM x l ∧ alg_embed x s ⇒ (alg_cover l s = x)
</pre>

<DT><span class="strong">ALG_COVER_STEP</span>
<DD>
<pre>
|- ∀l1 l2 h t.
     alg_cover_set l1 ∧ alg_cover_set l2 ⇒
     (alg_cover (MAP (CONS T) l1 ++ MAP (CONS F) l2) (SCONS h t) =
      if h then T::alg_cover l1 t else F::alg_cover l2 t)
</pre>

<DT><span class="strong">ALG_COVER_HEAD</span>
<DD>
<pre>
|- ∀l. alg_cover_set l ⇒ ∀f. f o alg_cover l = algebra_embed (FILTER f l)
</pre>

<DT><span class="strong">ALG_COVER_TAIL_STEP</span>
<DD>
<pre>
|- ∀l1 l2 q.
     alg_cover_set l1 ∧ alg_cover_set l2 ⇒
     (q o
      (λx.
         SDROP (LENGTH (alg_cover (MAP (CONS T) l1 ++ MAP (CONS F) l2) x))
           x) =
      (λx. SHD x ⇔ T) ∩ q o (λx. SDROP (LENGTH (alg_cover l1 x)) x) o STL ∪
      (λx. SHD x ⇔ F) ∩ q o (λx. SDROP (LENGTH (alg_cover l2 x)) x) o STL)
</pre>

<DT><span class="strong">ALG_COVER_TAIL_MEASURABLE</span>
<DD>
<pre>
|- ∀l.
     alg_cover_set l ⇒
     ∀q.
       measurable (q o (λx. SDROP (LENGTH (alg_cover l x)) x)) ⇔ measurable q
</pre>

<DT><span class="strong">ALG_COVER_TAIL_PROB</span>
<DD>
<pre>
|- ∀l.
     alg_cover_set l ⇒
     ∀q.
       measurable q ⇒
       (prob (q o (λx. SDROP (LENGTH (alg_cover l x)) x)) = prob q)
</pre>

<DT><span class="strong">INDEP_INDEP_SET_LEMMA</span>
<DD>
<pre>
|- ∀l.
     alg_cover_set l ⇒
     ∀q.
       measurable q ⇒
       ∀x.
         MEM x l ⇒
         (prob (alg_embed x ∩ q o (λx. SDROP (LENGTH (alg_cover l x)) x)) =
          (1 / 2) pow LENGTH x * prob q)
</pre>

<DT><span class="strong">INDEP_SET_LIST</span>
<DD>
<pre>
|- ∀q l.
     alg_sorted l ∧ alg_prefixfree l ∧ measurable q ∧
     (∀x. MEM x l ⇒ indep_set (alg_embed x) q) ⇒
     indep_set (algebra_embed l) q
</pre>

<DT><span class="strong">INDEP_INDEP_SET</span>
<DD>
<pre>
|- ∀f p q. indep f ∧ measurable q ⇒ indep_set (p o FST o f) (q o SND o f)
</pre>

<DT><span class="strong">INDEP_UNIT</span>
<DD>
<pre>
|- ∀x. indep (UNIT x)
</pre>

<DT><span class="strong">INDEP_SDEST</span>
<DD>
<pre>
|- indep SDEST
</pre>

<DT><span class="strong">BIND_STEP</span>
<DD>
<pre>
|- ∀f. BIND SDEST (λk. f o SCONS k) = f
</pre>

<DT><span class="strong">INDEP_BIND_SDEST</span>
<DD>
<pre>
|- ∀f. (∀x. indep (f x)) ⇒ indep (BIND SDEST f)
</pre>

<DT><span class="strong">INDEP_BIND</span>
<DD>
<pre>
|- ∀f g. indep f ∧ (∀x. indep (g x)) ⇒ indep (BIND f g)
</pre>

<DT><span class="strong">INDEP_PROB</span>
<DD>
<pre>
|- ∀f p q.
     indep f ∧ measurable q ⇒
     (prob (p o FST o f ∩ q o SND o f) = prob (p o FST o f) * prob q)
</pre>

<DT><span class="strong">INDEP_MEASURABLE1</span>
<DD>
<pre>
|- ∀f p. indep f ⇒ measurable (p o FST o f)
</pre>

<DT><span class="strong">INDEP_MEASURABLE2</span>
<DD>
<pre>
|- ∀f q. indep f ∧ measurable q ⇒ measurable (q o SND o f)
</pre>

<DT><span class="strong">PROB_INDEP_BOUND</span>
<DD>
<pre>
|- ∀f n.
     indep f ⇒
     (prob (λs. FST (f s) < SUC n) =
      prob (λs. FST (f s) < n) + prob (λs. FST (f s) = n))
</pre>

</DL>



<hr>
</body>
</html>
