<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: prob_uniform</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "prob_uniform"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "prob_indepTheory.html"><span class="strong">prob_indep</span></a>

<h1>Signature</h1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr>
    <th>
    Constant
    <th>
    Type<tr><td>
            <span class="strong">unif</span>
            <td>
            :num -> (num -> bool) -> num # (num -> bool)
    <tr><td> <span class="strong">unif_bound</span> <td> :num -> num
    <tr><td>
        <span class="strong">unif_tupled</span>
        <td>
        :num # (num -> bool) -> num # (num -> bool)
    <tr><td>
        <span class="strong">uniform</span>
        <td>
        :num -> num -> (num -> bool) -> num # (num -> bool)
    <tr><td>
        <span class="strong">uniform_tupled</span>
        <td>
        :num # num # (num -> bool) -> num # (num -> bool)
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">unif_bound_primitive_def</span>
<DD>
<pre>
|- unif_bound =
   WFREC (@R. WF R ∧ ∀v. R (SUC v DIV 2) (SUC v))
     (λunif_bound a.
        case a of 0 -> I 0 || SUC v1 -> I (SUC (unif_bound (SUC v1 DIV 2))))
</pre>

<DT><span class="strong">unif_tupled_primitive_def</span>
<DD>
<pre>
|- unif_tupled =
   WFREC (@R. WF R ∧ ∀s v2. R (SUC v2 DIV 2,s) (SUC v2,s))
     (λunif_tupled a.
        case a of
           (0,s) -> I (0,s)
        || (SUC v3,s) ->
             I
               (let (m,s') = unif_tupled (SUC v3 DIV 2,s)
                in
                  (if SHD s' then 2 * m + 1 else 2 * m,STL s')))
</pre>

<DT><span class="strong">unif_curried_def</span>
<DD>
<pre>
|- ∀x x1. unif x x1 = unif_tupled (x,x1)
</pre>

<DT><span class="strong">uniform_tupled_primitive_def</span>
<DD>
<pre>
|- uniform_tupled =
   WFREC
     (@R.
        WF R ∧
        ∀t s n res s'.
          ((res,s') = unif n s) ∧ ¬(res < SUC n) ⇒
          R (t,SUC n,s') (SUC t,SUC n,s))
     (λuniform_tupled a.
        case a of
           (0,0,s) -> ARB
        || (0,SUC n,s) -> I (0,s)
        || (SUC t,0,s') -> ARB
        || (SUC t,SUC n',s') ->
             I
               (let (res,s') = unif n' s'
                in
                  if res < SUC n' then
                    (res,s')
                  else
                    uniform_tupled (t,SUC n',s')))
</pre>

<DT><span class="strong">uniform_curried_def</span>
<DD>
<pre>
|- ∀x x1 x2. uniform x x1 x2 = uniform_tupled (x,x1,x2)
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">unif_bound_def</span>
<DD>
<pre>
|- (unif_bound 0 = 0) ∧ (unif_bound (SUC v) = SUC (unif_bound (SUC v DIV 2)))
</pre>

<DT><span class="strong">unif_bound_ind</span>
<DD>
<pre>
|- ∀P. P 0 ∧ (∀v. P (SUC v DIV 2) ⇒ P (SUC v)) ⇒ ∀v. P v
</pre>

<DT><span class="strong">unif_def</span>
<DD>
<pre>
|- (unif 0 s = (0,s)) ∧
   (unif (SUC v2) s =
    (let (m,s') = unif (SUC v2 DIV 2) s
     in
       (if SHD s' then 2 * m + 1 else 2 * m,STL s')))
</pre>

<DT><span class="strong">unif_ind</span>
<DD>
<pre>
|- ∀P.
     (∀s. P 0 s) ∧ (∀v2 s. P (SUC v2 DIV 2) s ⇒ P (SUC v2) s) ⇒ ∀v v1. P v v1
</pre>

<DT><span class="strong">uniform_ind</span>
<DD>
<pre>
|- ∀P.
     (∀n s. P 0 (SUC n) s) ∧
     (∀t n s.
        (∀res s'. ((res,s') = unif n s) ∧ ¬(res < SUC n) ⇒ P t (SUC n) s') ⇒
        P (SUC t) (SUC n) s) ∧ (∀v6. P 0 0 v6) ∧ (∀t v10. P (SUC t) 0 v10) ⇒
     ∀v v1 v2. P v v1 v2
</pre>

<DT><span class="strong">uniform_def</span>
<DD>
<pre>
|- (∀s n. uniform 0 (SUC n) s = (0,s)) ∧
   ∀t s n.
     uniform (SUC t) (SUC n) s =
     (let (res,s') = unif n s
      in
        if res < SUC n then (res,s') else uniform t (SUC n) s')
</pre>

<DT><span class="strong">SUC_DIV_TWO_ZERO</span>
<DD>
<pre>
|- ∀n. (SUC n DIV 2 = 0) ⇔ (n = 0)
</pre>

<DT><span class="strong">UNIF_BOUND_LOWER</span>
<DD>
<pre>
|- ∀n. n < 2 ** unif_bound n
</pre>

<DT><span class="strong">UNIF_BOUND_LOWER_SUC</span>
<DD>
<pre>
|- ∀n. SUC n ≤ 2 ** unif_bound n
</pre>

<DT><span class="strong">UNIF_BOUND_UPPER</span>
<DD>
<pre>
|- ∀n. n ≠ 0 ⇒ 2 ** unif_bound n ≤ 2 * n
</pre>

<DT><span class="strong">UNIF_BOUND_UPPER_SUC</span>
<DD>
<pre>
|- ∀n. 2 ** unif_bound n ≤ SUC (2 * n)
</pre>

<DT><span class="strong">UNIF_DEF_MONAD</span>
<DD>
<pre>
|- (unif 0 = UNIT 0) ∧
   ∀n.
     unif (SUC n) =
     BIND (unif (SUC n DIV 2))
       (λm. BIND SDEST (λb. UNIT (if b then 2 * m + 1 else 2 * m)))
</pre>

<DT><span class="strong">UNIFORM_DEF_MONAD</span>
<DD>
<pre>
|- (∀n. uniform 0 (SUC n) = UNIT 0) ∧
   ∀t n.
     uniform (SUC t) (SUC n) =
     BIND (unif n) (λm. if m < SUC n then UNIT m else uniform t (SUC n))
</pre>

<DT><span class="strong">INDEP_UNIF</span>
<DD>
<pre>
|- ∀n. indep (unif n)
</pre>

<DT><span class="strong">INDEP_UNIFORM</span>
<DD>
<pre>
|- ∀t n. indep (uniform t (SUC n))
</pre>

<DT><span class="strong">PROB_UNIF</span>
<DD>
<pre>
|- ∀n k.
     prob (λs. FST (unif n s) = k) =
     if k < 2 ** unif_bound n then (1 / 2) pow unif_bound n else 0
</pre>

<DT><span class="strong">UNIF_RANGE</span>
<DD>
<pre>
|- ∀n s. FST (unif n s) < 2 ** unif_bound n
</pre>

<DT><span class="strong">PROB_UNIF_PAIR</span>
<DD>
<pre>
|- ∀n k k'.
     (prob (λs. FST (unif n s) = k) = prob (λs. FST (unif n s) = k')) ⇔
     (k < 2 ** unif_bound n ⇔ k' < 2 ** unif_bound n)
</pre>

<DT><span class="strong">PROB_UNIF_BOUND</span>
<DD>
<pre>
|- ∀n k.
     k ≤ 2 ** unif_bound n ⇒
     (prob (λs. FST (unif n s) < k) = &k * (1 / 2) pow unif_bound n)
</pre>

<DT><span class="strong">PROB_UNIF_GOOD</span>
<DD>
<pre>
|- ∀n. 1 / 2 ≤ prob (λs. FST (unif n s) < SUC n)
</pre>

<DT><span class="strong">UNIFORM_RANGE</span>
<DD>
<pre>
|- ∀t n s. FST (uniform t (SUC n) s) < SUC n
</pre>

<DT><span class="strong">PROB_UNIFORM_LOWER_BOUND</span>
<DD>
<pre>
|- ∀b.
     (∀k. k < SUC n ⇒ prob (λs. FST (uniform t (SUC n) s) = k) < b) ⇒
     ∀m. m < SUC n ⇒ prob (λs. FST (uniform t (SUC n) s) < SUC m) < &SUC m * b
</pre>

<DT><span class="strong">PROB_UNIFORM_UPPER_BOUND</span>
<DD>
<pre>
|- ∀b.
     (∀k. k < SUC n ⇒ b < prob (λs. FST (uniform t (SUC n) s) = k)) ⇒
     ∀m. m < SUC n ⇒ &SUC m * b < prob (λs. FST (uniform t (SUC n) s) < SUC m)
</pre>

<DT><span class="strong">PROB_UNIFORM_PAIR_SUC</span>
<DD>
<pre>
|- ∀t n k k'.
     k < SUC n ∧ k' < SUC n ⇒
     abs
       (prob (λs. FST (uniform t (SUC n) s) = k) −
        prob (λs. FST (uniform t (SUC n) s) = k')) ≤ (1 / 2) pow t
</pre>

<DT><span class="strong">PROB_UNIFORM_SUC</span>
<DD>
<pre>
|- ∀t n k.
     k < SUC n ⇒
     abs (prob (λs. FST (uniform t (SUC n) s) = k) − 1 / &SUC n) ≤
     (1 / 2) pow t
</pre>

<DT><span class="strong">PROB_UNIFORM</span>
<DD>
<pre>
|- ∀t n k.
     k < n ⇒ abs (prob (λs. FST (uniform t n s) = k) − 1 / &n) ≤ (1 / 2) pow t
</pre>

</DL>



<hr>
</body>
</html>
