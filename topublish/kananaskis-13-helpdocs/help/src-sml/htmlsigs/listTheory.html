<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure listTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure listTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/list/src/listScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature listTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#ALL_DISTINCT-val">ALL_DISTINCT</a> : thm
<a name="line7"></a>    val <a href="#APPEND-val">APPEND</a> : thm
<a name="line8"></a>    val <a href="#DROP_def-val">DROP_def</a> : thm
<a name="line9"></a>    val <a href="#EL-val">EL</a> : thm
<a name="line10"></a>    val <a href="#EVERY_DEF-val">EVERY_DEF</a> : thm
<a name="line11"></a>    val <a href="#EVERYi_def-val">EVERYi_def</a> : thm
<a name="line12"></a>    val <a href="#EXISTS_DEF-val">EXISTS_DEF</a> : thm
<a name="line13"></a>    val <a href="#FILTER-val">FILTER</a> : thm
<a name="line14"></a>    val <a href="#FIND_def-val">FIND_def</a> : thm
<a name="line15"></a>    val <a href="#FLAT-val">FLAT</a> : thm
<a name="line16"></a>    val <a href="#FOLDL-val">FOLDL</a> : thm
<a name="line17"></a>    val <a href="#FOLDR-val">FOLDR</a> : thm
<a name="line18"></a>    val <a href="#FRONT_DEF-val">FRONT_DEF</a> : thm
<a name="line19"></a>    val <a href="#GENLIST-val">GENLIST</a> : thm
<a name="line20"></a>    val <a href="#GENLIST_AUX-val">GENLIST_AUX</a> : thm
<a name="line21"></a>    val <a href="#HD-val">HD</a> : thm
<a name="line22"></a>    val <a href="#INDEX_FIND_def-val">INDEX_FIND_def</a> : thm
<a name="line23"></a>    val <a href="#INDEX_OF_def-val">INDEX_OF_def</a> : thm
<a name="line24"></a>    val <a href="#LAST_DEF-val">LAST_DEF</a> : thm
<a name="line25"></a>    val <a href="#LENGTH-val">LENGTH</a> : thm
<a name="line26"></a>    val <a href="#LEN_DEF-val">LEN_DEF</a> : thm
<a name="line27"></a>    val <a href="#LIST_APPLY_def-val">LIST_APPLY_def</a> : thm
<a name="line28"></a>    val <a href="#LIST_BIND_def-val">LIST_BIND_def</a> : thm
<a name="line29"></a>    val <a href="#LIST_GUARD_def-val">LIST_GUARD_def</a> : thm
<a name="line30"></a>    val <a href="#LIST_IGNORE_BIND_def-val">LIST_IGNORE_BIND_def</a> : thm
<a name="line31"></a>    val <a href="#LIST_LIFT2_def-val">LIST_LIFT2_def</a> : thm
<a name="line32"></a>    val <a href="#LIST_TO_SET_DEF-val">LIST_TO_SET_DEF</a> : thm
<a name="line33"></a>    val <a href="#LLEX_def-val">LLEX_def</a> : thm
<a name="line34"></a>    val <a href="#LRC_def-val">LRC_def</a> : thm
<a name="line35"></a>    val <a href="#LUPDATE_def-val">LUPDATE_def</a> : thm
<a name="line36"></a>    val <a href="#MAP-val">MAP</a> : thm
<a name="line37"></a>    val <a href="#NULL_DEF-val">NULL_DEF</a> : thm
<a name="line38"></a>    val <a href="#OPT_MMAP_def-val">OPT_MMAP_def</a> : thm
<a name="line39"></a>    val <a href="#PAD_LEFT-val">PAD_LEFT</a> : thm
<a name="line40"></a>    val <a href="#PAD_RIGHT-val">PAD_RIGHT</a> : thm
<a name="line41"></a>    val <a href="#REVERSE_DEF-val">REVERSE_DEF</a> : thm
<a name="line42"></a>    val <a href="#REV_DEF-val">REV_DEF</a> : thm
<a name="line43"></a>    val <a href="#SET_TO_LIST_primitive_def-val">SET_TO_LIST_primitive_def</a> : thm
<a name="line44"></a>    val <a href="#SHORTLEX_def-val">SHORTLEX_def</a> : thm
<a name="line45"></a>    val <a href="#SNOC-val">SNOC</a> : thm
<a name="line46"></a>    val <a href="#SUM-val">SUM</a> : thm
<a name="line47"></a>    val <a href="#SUM_ACC_DEF-val">SUM_ACC_DEF</a> : thm
<a name="line48"></a>    val <a href="#TAKE_def-val">TAKE_def</a> : thm
<a name="line49"></a>    val <a href="#TL_DEF-val">TL_DEF</a> : thm
<a name="line50"></a>    val <a href="#UNIQUE_DEF-val">UNIQUE_DEF</a> : thm
<a name="line51"></a>    val <a href="#UNZIP-val">UNZIP</a> : thm
<a name="line52"></a>    val <a href="#ZIP_def-val">ZIP_def</a> : thm
<a name="line53"></a>    val <a href="#dropWhile_def-val">dropWhile_def</a> : thm
<a name="line54"></a>    val <a href="#isPREFIX-val">isPREFIX</a> : thm
<a name="line55"></a>    val <a href="#list_TY_DEF-val">list_TY_DEF</a> : thm
<a name="line56"></a>    val <a href="#list_case_def-val">list_case_def</a> : thm
<a name="line57"></a>    val <a href="#list_size_def-val">list_size_def</a> : thm
<a name="line58"></a>    val <a href="#nub_def-val">nub_def</a> : thm
<a name="line59"></a>    val <a href="#oEL_def-val">oEL_def</a> : thm
<a name="line60"></a>    val <a href="#oHD_def-val">oHD_def</a> : thm
<a name="line61"></a>    val <a href="#splitAtPki_def-val">splitAtPki_def</a> : thm
<a name="line62"></a>  
<a name="line63"></a>  (*  Theorems  *)
<a name="line64"></a>    val <a href="#ALL_DISTINCT_APPEND-val">ALL_DISTINCT_APPEND</a> : thm
<a name="line65"></a>    val <a href="#ALL_DISTINCT_CARD_LIST_TO_SET-val">ALL_DISTINCT_CARD_LIST_TO_SET</a> : thm
<a name="line66"></a>    val <a href="#ALL_DISTINCT_DROP-val">ALL_DISTINCT_DROP</a> : thm
<a name="line67"></a>    val <a href="#ALL_DISTINCT_EL_IMP-val">ALL_DISTINCT_EL_IMP</a> : thm
<a name="line68"></a>    val <a href="#ALL_DISTINCT_FILTER-val">ALL_DISTINCT_FILTER</a> : thm
<a name="line69"></a>    val <a href="#ALL_DISTINCT_FILTER_EL_IMP-val">ALL_DISTINCT_FILTER_EL_IMP</a> : thm
<a name="line70"></a>    val <a href="#ALL_DISTINCT_FLAT_REVERSE-val">ALL_DISTINCT_FLAT_REVERSE</a> : thm
<a name="line71"></a>    val <a href="#ALL_DISTINCT_GENLIST-val">ALL_DISTINCT_GENLIST</a> : thm
<a name="line72"></a>    val <a href="#ALL_DISTINCT_MAP-val">ALL_DISTINCT_MAP</a> : thm
<a name="line73"></a>    val <a href="#ALL_DISTINCT_MAP_INJ-val">ALL_DISTINCT_MAP_INJ</a> : thm
<a name="line74"></a>    val <a href="#ALL_DISTINCT_REVERSE-val">ALL_DISTINCT_REVERSE</a> : thm
<a name="line75"></a>    val <a href="#ALL_DISTINCT_SET_TO_LIST-val">ALL_DISTINCT_SET_TO_LIST</a> : thm
<a name="line76"></a>    val <a href="#ALL_DISTINCT_SING-val">ALL_DISTINCT_SING</a> : thm
<a name="line77"></a>    val <a href="#ALL_DISTINCT_SNOC-val">ALL_DISTINCT_SNOC</a> : thm
<a name="line78"></a>    val <a href="#ALL_DISTINCT_ZIP-val">ALL_DISTINCT_ZIP</a> : thm
<a name="line79"></a>    val <a href="#ALL_DISTINCT_ZIP_SWAP-val">ALL_DISTINCT_ZIP_SWAP</a> : thm
<a name="line80"></a>    val <a href="#APPEND_11-val">APPEND_11</a> : thm
<a name="line81"></a>    val <a href="#APPEND_11_LENGTH-val">APPEND_11_LENGTH</a> : thm
<a name="line82"></a>    val <a href="#APPEND_ASSOC-val">APPEND_ASSOC</a> : thm
<a name="line83"></a>    val <a href="#APPEND_EQ_APPEND-val">APPEND_EQ_APPEND</a> : thm
<a name="line84"></a>    val <a href="#APPEND_EQ_APPEND_MID-val">APPEND_EQ_APPEND_MID</a> : thm
<a name="line85"></a>    val <a href="#APPEND_EQ_CONS-val">APPEND_EQ_CONS</a> : thm
<a name="line86"></a>    val <a href="#APPEND_EQ_SELF-val">APPEND_EQ_SELF</a> : thm
<a name="line87"></a>    val <a href="#APPEND_EQ_SING-val">APPEND_EQ_SING</a> : thm
<a name="line88"></a>    val <a href="#APPEND_FRONT_LAST-val">APPEND_FRONT_LAST</a> : thm
<a name="line89"></a>    val <a href="#APPEND_LENGTH_EQ-val">APPEND_LENGTH_EQ</a> : thm
<a name="line90"></a>    val <a href="#APPEND_NIL-val">APPEND_NIL</a> : thm
<a name="line91"></a>    val <a href="#APPEND_SNOC-val">APPEND_SNOC</a> : thm
<a name="line92"></a>    val <a href="#APPEND_eq_NIL-val">APPEND_eq_NIL</a> : thm
<a name="line93"></a>    val <a href="#BIGUNION_IMAGE_set_SUBSET-val">BIGUNION_IMAGE_set_SUBSET</a> : thm
<a name="line94"></a>    val <a href="#CARD_LIST_TO_SET-val">CARD_LIST_TO_SET</a> : thm
<a name="line95"></a>    val <a href="#CARD_LIST_TO_SET_ALL_DISTINCT-val">CARD_LIST_TO_SET_ALL_DISTINCT</a> : thm
<a name="line96"></a>    val <a href="#CONS-val">CONS</a> : thm
<a name="line97"></a>    val <a href="#CONS_11-val">CONS_11</a> : thm
<a name="line98"></a>    val <a href="#CONS_ACYCLIC-val">CONS_ACYCLIC</a> : thm
<a name="line99"></a>    val <a href="#DISJOINT_GENLIST_PLUS-val">DISJOINT_GENLIST_PLUS</a> : thm
<a name="line100"></a>    val <a href="#DROP_0-val">DROP_0</a> : thm
<a name="line101"></a>    val <a href="#DROP_GENLIST-val">DROP_GENLIST</a> : thm
<a name="line102"></a>    val <a href="#DROP_LENGTH_TOO_LONG-val">DROP_LENGTH_TOO_LONG</a> : thm
<a name="line103"></a>    val <a href="#DROP_NIL-val">DROP_NIL</a> : thm
<a name="line104"></a>    val <a href="#DROP_compute-val">DROP_compute</a> : thm
<a name="line105"></a>    val <a href="#DROP_cons-val">DROP_cons</a> : thm
<a name="line106"></a>    val <a href="#DROP_nil-val">DROP_nil</a> : thm
<a name="line107"></a>    val <a href="#DROP_splitAtPki-val">DROP_splitAtPki</a> : thm
<a name="line108"></a>    val <a href="#EL_ALL_DISTINCT_EL_EQ-val">EL_ALL_DISTINCT_EL_EQ</a> : thm
<a name="line109"></a>    val <a href="#EL_APPEND_EQN-val">EL_APPEND_EQN</a> : thm
<a name="line110"></a>    val <a href="#EL_DROP-val">EL_DROP</a> : thm
<a name="line111"></a>    val <a href="#EL_GENLIST-val">EL_GENLIST</a> : thm
<a name="line112"></a>    val <a href="#EL_LENGTH_SNOC-val">EL_LENGTH_SNOC</a> : thm
<a name="line113"></a>    val <a href="#EL_LENGTH_dropWhile_REVERSE-val">EL_LENGTH_dropWhile_REVERSE</a> : thm
<a name="line114"></a>    val <a href="#EL_LUPDATE-val">EL_LUPDATE</a> : thm
<a name="line115"></a>    val <a href="#EL_MAP-val">EL_MAP</a> : thm
<a name="line116"></a>    val <a href="#EL_MAP2-val">EL_MAP2</a> : thm
<a name="line117"></a>    val <a href="#EL_REVERSE-val">EL_REVERSE</a> : thm
<a name="line118"></a>    val <a href="#EL_SNOC-val">EL_SNOC</a> : thm
<a name="line119"></a>    val <a href="#EL_TAKE-val">EL_TAKE</a> : thm
<a name="line120"></a>    val <a href="#EL_ZIP-val">EL_ZIP</a> : thm
<a name="line121"></a>    val <a href="#EL_compute-val">EL_compute</a> : thm
<a name="line122"></a>    val <a href="#EL_restricted-val">EL_restricted</a> : thm
<a name="line123"></a>    val <a href="#EL_simp-val">EL_simp</a> : thm
<a name="line124"></a>    val <a href="#EL_simp_restricted-val">EL_simp_restricted</a> : thm
<a name="line125"></a>    val <a href="#EQ_LIST-val">EQ_LIST</a> : thm
<a name="line126"></a>    val <a href="#EVERY2_EVERY-val">EVERY2_EVERY</a> : thm
<a name="line127"></a>    val <a href="#EVERY2_LENGTH-val">EVERY2_LENGTH</a> : thm
<a name="line128"></a>    val <a href="#EVERY2_LUPDATE_same-val">EVERY2_LUPDATE_same</a> : thm
<a name="line129"></a>    val <a href="#EVERY2_MAP-val">EVERY2_MAP</a> : thm
<a name="line130"></a>    val <a href="#EVERY2_MEM_MONO-val">EVERY2_MEM_MONO</a> : thm
<a name="line131"></a>    val <a href="#EVERY2_REVERSE-val">EVERY2_REVERSE</a> : thm
<a name="line132"></a>    val <a href="#EVERY2_THM-val">EVERY2_THM</a> : thm
<a name="line133"></a>    val <a href="#EVERY2_cong-val">EVERY2_cong</a> : thm
<a name="line134"></a>    val <a href="#EVERY2_mono-val">EVERY2_mono</a> : thm
<a name="line135"></a>    val <a href="#EVERY2_refl-val">EVERY2_refl</a> : thm
<a name="line136"></a>    val <a href="#EVERY2_sym-val">EVERY2_sym</a> : thm
<a name="line137"></a>    val <a href="#EVERY2_trans-val">EVERY2_trans</a> : thm
<a name="line138"></a>    val <a href="#EVERY_APPEND-val">EVERY_APPEND</a> : thm
<a name="line139"></a>    val <a href="#EVERY_CONG-val">EVERY_CONG</a> : thm
<a name="line140"></a>    val <a href="#EVERY_CONJ-val">EVERY_CONJ</a> : thm
<a name="line141"></a>    val <a href="#EVERY_EL-val">EVERY_EL</a> : thm
<a name="line142"></a>    val <a href="#EVERY_FILTER-val">EVERY_FILTER</a> : thm
<a name="line143"></a>    val <a href="#EVERY_FILTER_IMP-val">EVERY_FILTER_IMP</a> : thm
<a name="line144"></a>    val <a href="#EVERY_FLAT-val">EVERY_FLAT</a> : thm
<a name="line145"></a>    val <a href="#EVERY_GENLIST-val">EVERY_GENLIST</a> : thm
<a name="line146"></a>    val <a href="#EVERY_MAP-val">EVERY_MAP</a> : thm
<a name="line147"></a>    val <a href="#EVERY_MEM-val">EVERY_MEM</a> : thm
<a name="line148"></a>    val <a href="#EVERY_MEM_MONO-val">EVERY_MEM_MONO</a> : thm
<a name="line149"></a>    val <a href="#EVERY_MONOTONIC-val">EVERY_MONOTONIC</a> : thm
<a name="line150"></a>    val <a href="#EVERY_NOT_EXISTS-val">EVERY_NOT_EXISTS</a> : thm
<a name="line151"></a>    val <a href="#EVERY_SIMP-val">EVERY_SIMP</a> : thm
<a name="line152"></a>    val <a href="#EVERY_SNOC-val">EVERY_SNOC</a> : thm
<a name="line153"></a>    val <a href="#EXISTS_APPEND-val">EXISTS_APPEND</a> : thm
<a name="line154"></a>    val <a href="#EXISTS_CONG-val">EXISTS_CONG</a> : thm
<a name="line155"></a>    val <a href="#EXISTS_GENLIST-val">EXISTS_GENLIST</a> : thm
<a name="line156"></a>    val <a href="#EXISTS_LIST-val">EXISTS_LIST</a> : thm
<a name="line157"></a>    val <a href="#EXISTS_LIST_EQ_MAP-val">EXISTS_LIST_EQ_MAP</a> : thm
<a name="line158"></a>    val <a href="#EXISTS_MAP-val">EXISTS_MAP</a> : thm
<a name="line159"></a>    val <a href="#EXISTS_MEM-val">EXISTS_MEM</a> : thm
<a name="line160"></a>    val <a href="#EXISTS_NOT_EVERY-val">EXISTS_NOT_EVERY</a> : thm
<a name="line161"></a>    val <a href="#EXISTS_SIMP-val">EXISTS_SIMP</a> : thm
<a name="line162"></a>    val <a href="#EXISTS_SNOC-val">EXISTS_SNOC</a> : thm
<a name="line163"></a>    val <a href="#FILTER_ALL_DISTINCT-val">FILTER_ALL_DISTINCT</a> : thm
<a name="line164"></a>    val <a href="#FILTER_APPEND_DISTRIB-val">FILTER_APPEND_DISTRIB</a> : thm
<a name="line165"></a>    val <a href="#FILTER_COND_REWRITE-val">FILTER_COND_REWRITE</a> : thm
<a name="line166"></a>    val <a href="#FILTER_EQ_APPEND-val">FILTER_EQ_APPEND</a> : thm
<a name="line167"></a>    val <a href="#FILTER_EQ_CONS-val">FILTER_EQ_CONS</a> : thm
<a name="line168"></a>    val <a href="#FILTER_EQ_ID-val">FILTER_EQ_ID</a> : thm
<a name="line169"></a>    val <a href="#FILTER_EQ_NIL-val">FILTER_EQ_NIL</a> : thm
<a name="line170"></a>    val <a href="#FILTER_F-val">FILTER_F</a> : thm
<a name="line171"></a>    val <a href="#FILTER_NEQ_ID-val">FILTER_NEQ_ID</a> : thm
<a name="line172"></a>    val <a href="#FILTER_NEQ_NIL-val">FILTER_NEQ_NIL</a> : thm
<a name="line173"></a>    val <a href="#FILTER_REVERSE-val">FILTER_REVERSE</a> : thm
<a name="line174"></a>    val <a href="#FILTER_T-val">FILTER_T</a> : thm
<a name="line175"></a>    val <a href="#FINITE_LIST_TO_SET-val">FINITE_LIST_TO_SET</a> : thm
<a name="line176"></a>    val <a href="#FLAT_APPEND-val">FLAT_APPEND</a> : thm
<a name="line177"></a>    val <a href="#FLAT_EQ_NIL-val">FLAT_EQ_NIL</a> : thm
<a name="line178"></a>    val <a href="#FLAT_compute-val">FLAT_compute</a> : thm
<a name="line179"></a>    val <a href="#FOLDL2_FOLDL-val">FOLDL2_FOLDL</a> : thm
<a name="line180"></a>    val <a href="#FOLDL2_cong-val">FOLDL2_cong</a> : thm
<a name="line181"></a>    val <a href="#FOLDL2_def-val">FOLDL2_def</a> : thm
<a name="line182"></a>    val <a href="#FOLDL2_ind-val">FOLDL2_ind</a> : thm
<a name="line183"></a>    val <a href="#FOLDL_CONG-val">FOLDL_CONG</a> : thm
<a name="line184"></a>    val <a href="#FOLDL_EQ_FOLDR-val">FOLDL_EQ_FOLDR</a> : thm
<a name="line185"></a>    val <a href="#FOLDL_SNOC-val">FOLDL_SNOC</a> : thm
<a name="line186"></a>    val <a href="#FOLDL_UNION_BIGUNION-val">FOLDL_UNION_BIGUNION</a> : thm
<a name="line187"></a>    val <a href="#FOLDL_UNION_BIGUNION_paired-val">FOLDL_UNION_BIGUNION_paired</a> : thm
<a name="line188"></a>    val <a href="#FOLDL_ZIP_SAME-val">FOLDL_ZIP_SAME</a> : thm
<a name="line189"></a>    val <a href="#FOLDR_CONG-val">FOLDR_CONG</a> : thm
<a name="line190"></a>    val <a href="#FOLDR_CONS-val">FOLDR_CONS</a> : thm
<a name="line191"></a>    val <a href="#FORALL_LIST-val">FORALL_LIST</a> : thm
<a name="line192"></a>    val <a href="#FRONT_CONS-val">FRONT_CONS</a> : thm
<a name="line193"></a>    val <a href="#FRONT_CONS_EQ_NIL-val">FRONT_CONS_EQ_NIL</a> : thm
<a name="line194"></a>    val <a href="#FRONT_SNOC-val">FRONT_SNOC</a> : thm
<a name="line195"></a>    val <a href="#GENLIST_APPEND-val">GENLIST_APPEND</a> : thm
<a name="line196"></a>    val <a href="#GENLIST_AUX_compute-val">GENLIST_AUX_compute</a> : thm
<a name="line197"></a>    val <a href="#GENLIST_CONS-val">GENLIST_CONS</a> : thm
<a name="line198"></a>    val <a href="#GENLIST_EL-val">GENLIST_EL</a> : thm
<a name="line199"></a>    val <a href="#GENLIST_EL_MAP-val">GENLIST_EL_MAP</a> : thm
<a name="line200"></a>    val <a href="#GENLIST_FUN_EQ-val">GENLIST_FUN_EQ</a> : thm
<a name="line201"></a>    val <a href="#GENLIST_GENLIST_AUX-val">GENLIST_GENLIST_AUX</a> : thm
<a name="line202"></a>    val <a href="#GENLIST_ID-val">GENLIST_ID</a> : thm
<a name="line203"></a>    val <a href="#GENLIST_NUMERALS-val">GENLIST_NUMERALS</a> : thm
<a name="line204"></a>    val <a href="#GENLIST_PLUS_APPEND-val">GENLIST_PLUS_APPEND</a> : thm
<a name="line205"></a>    val <a href="#HD_DROP-val">HD_DROP</a> : thm
<a name="line206"></a>    val <a href="#HD_GENLIST-val">HD_GENLIST</a> : thm
<a name="line207"></a>    val <a href="#HD_GENLIST_COR-val">HD_GENLIST_COR</a> : thm
<a name="line208"></a>    val <a href="#HD_REVERSE-val">HD_REVERSE</a> : thm
<a name="line209"></a>    val <a href="#HD_dropWhile-val">HD_dropWhile</a> : thm
<a name="line210"></a>    val <a href="#IMAGE_EL_count_LENGTH-val">IMAGE_EL_count_LENGTH</a> : thm
<a name="line211"></a>    val <a href="#IMP_EVERY_LUPDATE-val">IMP_EVERY_LUPDATE</a> : thm
<a name="line212"></a>    val <a href="#INFINITE_LIST_UNIV-val">INFINITE_LIST_UNIV</a> : thm
<a name="line213"></a>    val <a href="#INJ_MAP_EQ-val">INJ_MAP_EQ</a> : thm
<a name="line214"></a>    val <a href="#INJ_MAP_EQ_IFF-val">INJ_MAP_EQ_IFF</a> : thm
<a name="line215"></a>    val <a href="#ITSET_eq_FOLDL_SET_TO_LIST-val">ITSET_eq_FOLDL_SET_TO_LIST</a> : thm
<a name="line216"></a>    val <a href="#LAST_APPEND_CONS-val">LAST_APPEND_CONS</a> : thm
<a name="line217"></a>    val <a href="#LAST_CONS-val">LAST_CONS</a> : thm
<a name="line218"></a>    val <a href="#LAST_CONS_cond-val">LAST_CONS_cond</a> : thm
<a name="line219"></a>    val <a href="#LAST_EL-val">LAST_EL</a> : thm
<a name="line220"></a>    val <a href="#LAST_MAP-val">LAST_MAP</a> : thm
<a name="line221"></a>    val <a href="#LAST_REVERSE-val">LAST_REVERSE</a> : thm
<a name="line222"></a>    val <a href="#LAST_SNOC-val">LAST_SNOC</a> : thm
<a name="line223"></a>    val <a href="#LAST_compute-val">LAST_compute</a> : thm
<a name="line224"></a>    val <a href="#LENGTH_APPEND-val">LENGTH_APPEND</a> : thm
<a name="line225"></a>    val <a href="#LENGTH_CONS-val">LENGTH_CONS</a> : thm
<a name="line226"></a>    val <a href="#LENGTH_DROP-val">LENGTH_DROP</a> : thm
<a name="line227"></a>    val <a href="#LENGTH_EQ_CONS-val">LENGTH_EQ_CONS</a> : thm
<a name="line228"></a>    val <a href="#LENGTH_EQ_NIL-val">LENGTH_EQ_NIL</a> : thm
<a name="line229"></a>    val <a href="#LENGTH_EQ_NUM-val">LENGTH_EQ_NUM</a> : thm
<a name="line230"></a>    val <a href="#LENGTH_EQ_NUM_compute-val">LENGTH_EQ_NUM_compute</a> : thm
<a name="line231"></a>    val <a href="#LENGTH_EQ_SUM-val">LENGTH_EQ_SUM</a> : thm
<a name="line232"></a>    val <a href="#LENGTH_FILTER_LEQ_MONO-val">LENGTH_FILTER_LEQ_MONO</a> : thm
<a name="line233"></a>    val <a href="#LENGTH_FRONT_CONS-val">LENGTH_FRONT_CONS</a> : thm
<a name="line234"></a>    val <a href="#LENGTH_GENLIST-val">LENGTH_GENLIST</a> : thm
<a name="line235"></a>    val <a href="#LENGTH_LEN-val">LENGTH_LEN</a> : thm
<a name="line236"></a>    val <a href="#LENGTH_LT_SHORTLEX-val">LENGTH_LT_SHORTLEX</a> : thm
<a name="line237"></a>    val <a href="#LENGTH_LUPDATE-val">LENGTH_LUPDATE</a> : thm
<a name="line238"></a>    val <a href="#LENGTH_MAP-val">LENGTH_MAP</a> : thm
<a name="line239"></a>    val <a href="#LENGTH_MAP2-val">LENGTH_MAP2</a> : thm
<a name="line240"></a>    val <a href="#LENGTH_NIL-val">LENGTH_NIL</a> : thm
<a name="line241"></a>    val <a href="#LENGTH_NIL_SYM-val">LENGTH_NIL_SYM</a> : thm
<a name="line242"></a>    val <a href="#LENGTH_REVERSE-val">LENGTH_REVERSE</a> : thm
<a name="line243"></a>    val <a href="#LENGTH_SNOC-val">LENGTH_SNOC</a> : thm
<a name="line244"></a>    val <a href="#LENGTH_TAKE-val">LENGTH_TAKE</a> : thm
<a name="line245"></a>    val <a href="#LENGTH_TAKE_EQ-val">LENGTH_TAKE_EQ</a> : thm
<a name="line246"></a>    val <a href="#LENGTH_TL-val">LENGTH_TL</a> : thm
<a name="line247"></a>    val <a href="#LENGTH_UNZIP-val">LENGTH_UNZIP</a> : thm
<a name="line248"></a>    val <a href="#LENGTH_ZIP-val">LENGTH_ZIP</a> : thm
<a name="line249"></a>    val <a href="#LENGTH_ZIP_MIN-val">LENGTH_ZIP_MIN</a> : thm
<a name="line250"></a>    val <a href="#LENGTH_dropWhile_LESS_EQ-val">LENGTH_dropWhile_LESS_EQ</a> : thm
<a name="line251"></a>    val <a href="#LENGTH_o_REVERSE-val">LENGTH_o_REVERSE</a> : thm
<a name="line252"></a>    val <a href="#LEN_LENGTH_LEM-val">LEN_LENGTH_LEM</a> : thm
<a name="line253"></a>    val <a href="#LIST_APPLY_o-val">LIST_APPLY_o</a> : thm
<a name="line254"></a>    val <a href="#LIST_BIND_APPEND-val">LIST_BIND_APPEND</a> : thm
<a name="line255"></a>    val <a href="#LIST_BIND_ID-val">LIST_BIND_ID</a> : thm
<a name="line256"></a>    val <a href="#LIST_BIND_LIST_BIND-val">LIST_BIND_LIST_BIND</a> : thm
<a name="line257"></a>    val <a href="#LIST_BIND_MAP-val">LIST_BIND_MAP</a> : thm
<a name="line258"></a>    val <a href="#LIST_BIND_THM-val">LIST_BIND_THM</a> : thm
<a name="line259"></a>    val <a href="#LIST_EQ-val">LIST_EQ</a> : thm
<a name="line260"></a>    val <a href="#LIST_EQ_MAP_PAIR-val">LIST_EQ_MAP_PAIR</a> : thm
<a name="line261"></a>    val <a href="#LIST_EQ_REWRITE-val">LIST_EQ_REWRITE</a> : thm
<a name="line262"></a>    val <a href="#LIST_NOT_EQ-val">LIST_NOT_EQ</a> : thm
<a name="line263"></a>    val <a href="#LIST_REL_APPEND-val">LIST_REL_APPEND</a> : thm
<a name="line264"></a>    val <a href="#LIST_REL_APPEND_EQ-val">LIST_REL_APPEND_EQ</a> : thm
<a name="line265"></a>    val <a href="#LIST_REL_APPEND_IMP-val">LIST_REL_APPEND_IMP</a> : thm
<a name="line266"></a>    val <a href="#LIST_REL_APPEND_suff-val">LIST_REL_APPEND_suff</a> : thm
<a name="line267"></a>    val <a href="#LIST_REL_CONJ-val">LIST_REL_CONJ</a> : thm
<a name="line268"></a>    val <a href="#LIST_REL_CONS1-val">LIST_REL_CONS1</a> : thm
<a name="line269"></a>    val <a href="#LIST_REL_CONS2-val">LIST_REL_CONS2</a> : thm
<a name="line270"></a>    val <a href="#LIST_REL_EL_EQN-val">LIST_REL_EL_EQN</a> : thm
<a name="line271"></a>    val <a href="#LIST_REL_EVERY_ZIP-val">LIST_REL_EVERY_ZIP</a> : thm
<a name="line272"></a>    val <a href="#LIST_REL_LENGTH-val">LIST_REL_LENGTH</a> : thm
<a name="line273"></a>    val <a href="#LIST_REL_MAP1-val">LIST_REL_MAP1</a> : thm
<a name="line274"></a>    val <a href="#LIST_REL_MAP2-val">LIST_REL_MAP2</a> : thm
<a name="line275"></a>    val <a href="#LIST_REL_MAP_inv_image-val">LIST_REL_MAP_inv_image</a> : thm
<a name="line276"></a>    val <a href="#LIST_REL_MEM_IMP-val">LIST_REL_MEM_IMP</a> : thm
<a name="line277"></a>    val <a href="#LIST_REL_NIL-val">LIST_REL_NIL</a> : thm
<a name="line278"></a>    val <a href="#LIST_REL_O-val">LIST_REL_O</a> : thm
<a name="line279"></a>    val <a href="#LIST_REL_SNOC-val">LIST_REL_SNOC</a> : thm
<a name="line280"></a>    val <a href="#LIST_REL_SPLIT1-val">LIST_REL_SPLIT1</a> : thm
<a name="line281"></a>    val <a href="#LIST_REL_SPLIT2-val">LIST_REL_SPLIT2</a> : thm
<a name="line282"></a>    val <a href="#LIST_REL_cases-val">LIST_REL_cases</a> : thm
<a name="line283"></a>    val <a href="#LIST_REL_def-val">LIST_REL_def</a> : thm
<a name="line284"></a>    val <a href="#LIST_REL_eq-val">LIST_REL_eq</a> : thm
<a name="line285"></a>    val <a href="#LIST_REL_ind-val">LIST_REL_ind</a> : thm
<a name="line286"></a>    val <a href="#LIST_REL_mono-val">LIST_REL_mono</a> : thm
<a name="line287"></a>    val <a href="#LIST_REL_rules-val">LIST_REL_rules</a> : thm
<a name="line288"></a>    val <a href="#LIST_REL_strongind-val">LIST_REL_strongind</a> : thm
<a name="line289"></a>    val <a href="#LIST_REL_trans-val">LIST_REL_trans</a> : thm
<a name="line290"></a>    val <a href="#LIST_TO_SET-val">LIST_TO_SET</a> : thm
<a name="line291"></a>    val <a href="#LIST_TO_SET_APPEND-val">LIST_TO_SET_APPEND</a> : thm
<a name="line292"></a>    val <a href="#LIST_TO_SET_EQ_EMPTY-val">LIST_TO_SET_EQ_EMPTY</a> : thm
<a name="line293"></a>    val <a href="#LIST_TO_SET_FILTER-val">LIST_TO_SET_FILTER</a> : thm
<a name="line294"></a>    val <a href="#LIST_TO_SET_FLAT-val">LIST_TO_SET_FLAT</a> : thm
<a name="line295"></a>    val <a href="#LIST_TO_SET_GENLIST-val">LIST_TO_SET_GENLIST</a> : thm
<a name="line296"></a>    val <a href="#LIST_TO_SET_MAP-val">LIST_TO_SET_MAP</a> : thm
<a name="line297"></a>    val <a href="#LIST_TO_SET_REVERSE-val">LIST_TO_SET_REVERSE</a> : thm
<a name="line298"></a>    val <a href="#LIST_TO_SET_SNOC-val">LIST_TO_SET_SNOC</a> : thm
<a name="line299"></a>    val <a href="#LIST_TO_SET_THM-val">LIST_TO_SET_THM</a> : thm
<a name="line300"></a>    val <a href="#LLEX_CONG-val">LLEX_CONG</a> : thm
<a name="line301"></a>    val <a href="#LLEX_EL_THM-val">LLEX_EL_THM</a> : thm
<a name="line302"></a>    val <a href="#LLEX_MONO-val">LLEX_MONO</a> : thm
<a name="line303"></a>    val <a href="#LLEX_NIL2-val">LLEX_NIL2</a> : thm
<a name="line304"></a>    val <a href="#LLEX_THM-val">LLEX_THM</a> : thm
<a name="line305"></a>    val <a href="#LLEX_not_WF-val">LLEX_not_WF</a> : thm
<a name="line306"></a>    val <a href="#LLEX_total-val">LLEX_total</a> : thm
<a name="line307"></a>    val <a href="#LLEX_transitive-val">LLEX_transitive</a> : thm
<a name="line308"></a>    val <a href="#LRC_MEM-val">LRC_MEM</a> : thm
<a name="line309"></a>    val <a href="#LRC_MEM_right-val">LRC_MEM_right</a> : thm
<a name="line310"></a>    val <a href="#LUPDATE_LENGTH-val">LUPDATE_LENGTH</a> : thm
<a name="line311"></a>    val <a href="#LUPDATE_MAP-val">LUPDATE_MAP</a> : thm
<a name="line312"></a>    val <a href="#LUPDATE_NIL-val">LUPDATE_NIL</a> : thm
<a name="line313"></a>    val <a href="#LUPDATE_SAME-val">LUPDATE_SAME</a> : thm
<a name="line314"></a>    val <a href="#LUPDATE_SEM-val">LUPDATE_SEM</a> : thm
<a name="line315"></a>    val <a href="#LUPDATE_SNOC-val">LUPDATE_SNOC</a> : thm
<a name="line316"></a>    val <a href="#LUPDATE_SOME_MAP-val">LUPDATE_SOME_MAP</a> : thm
<a name="line317"></a>    val <a href="#LUPDATE_compute-val">LUPDATE_compute</a> : thm
<a name="line318"></a>    val <a href="#MAP2-val">MAP2</a> : thm
<a name="line319"></a>    val <a href="#MAP2_APPEND-val">MAP2_APPEND</a> : thm
<a name="line320"></a>    val <a href="#MAP2_CONG-val">MAP2_CONG</a> : thm
<a name="line321"></a>    val <a href="#MAP2_DEF-val">MAP2_DEF</a> : thm
<a name="line322"></a>    val <a href="#MAP2_MAP-val">MAP2_MAP</a> : thm
<a name="line323"></a>    val <a href="#MAP2_NIL-val">MAP2_NIL</a> : thm
<a name="line324"></a>    val <a href="#MAP2_ZIP-val">MAP2_ZIP</a> : thm
<a name="line325"></a>    val <a href="#MAP2_ind-val">MAP2_ind</a> : thm
<a name="line326"></a>    val <a href="#MAP_APPEND-val">MAP_APPEND</a> : thm
<a name="line327"></a>    val <a href="#MAP_APPEND_MAP_EQ-val">MAP_APPEND_MAP_EQ</a> : thm
<a name="line328"></a>    val <a href="#MAP_CONG-val">MAP_CONG</a> : thm
<a name="line329"></a>    val <a href="#MAP_DROP-val">MAP_DROP</a> : thm
<a name="line330"></a>    val <a href="#MAP_EQ_APPEND-val">MAP_EQ_APPEND</a> : thm
<a name="line331"></a>    val <a href="#MAP_EQ_CONS-val">MAP_EQ_CONS</a> : thm
<a name="line332"></a>    val <a href="#MAP_EQ_EVERY2-val">MAP_EQ_EVERY2</a> : thm
<a name="line333"></a>    val <a href="#MAP_EQ_NIL-val">MAP_EQ_NIL</a> : thm
<a name="line334"></a>    val <a href="#MAP_EQ_SING-val">MAP_EQ_SING</a> : thm
<a name="line335"></a>    val <a href="#MAP_EQ_f-val">MAP_EQ_f</a> : thm
<a name="line336"></a>    val <a href="#MAP_FLAT-val">MAP_FLAT</a> : thm
<a name="line337"></a>    val <a href="#MAP_FRONT-val">MAP_FRONT</a> : thm
<a name="line338"></a>    val <a href="#MAP_GENLIST-val">MAP_GENLIST</a> : thm
<a name="line339"></a>    val <a href="#MAP_ID-val">MAP_ID</a> : thm
<a name="line340"></a>    val <a href="#MAP_LIST_BIND-val">MAP_LIST_BIND</a> : thm
<a name="line341"></a>    val <a href="#MAP_MAP_o-val">MAP_MAP_o</a> : thm
<a name="line342"></a>    val <a href="#MAP_SNOC-val">MAP_SNOC</a> : thm
<a name="line343"></a>    val <a href="#MAP_TAKE-val">MAP_TAKE</a> : thm
<a name="line344"></a>    val <a href="#MAP_TL-val">MAP_TL</a> : thm
<a name="line345"></a>    val <a href="#MAP_ZIP-val">MAP_ZIP</a> : thm
<a name="line346"></a>    val <a href="#MAP_ZIP_SAME-val">MAP_ZIP_SAME</a> : thm
<a name="line347"></a>    val <a href="#MAP_o-val">MAP_o</a> : thm
<a name="line348"></a>    val <a href="#MEM-val">MEM</a> : thm
<a name="line349"></a>    val <a href="#MEM_APPEND-val">MEM_APPEND</a> : thm
<a name="line350"></a>    val <a href="#MEM_APPEND_lemma-val">MEM_APPEND_lemma</a> : thm
<a name="line351"></a>    val <a href="#MEM_DROP-val">MEM_DROP</a> : thm
<a name="line352"></a>    val <a href="#MEM_EL-val">MEM_EL</a> : thm
<a name="line353"></a>    val <a href="#MEM_FILTER-val">MEM_FILTER</a> : thm
<a name="line354"></a>    val <a href="#MEM_FLAT-val">MEM_FLAT</a> : thm
<a name="line355"></a>    val <a href="#MEM_GENLIST-val">MEM_GENLIST</a> : thm
<a name="line356"></a>    val <a href="#MEM_LUPDATE-val">MEM_LUPDATE</a> : thm
<a name="line357"></a>    val <a href="#MEM_LUPDATE_E-val">MEM_LUPDATE_E</a> : thm
<a name="line358"></a>    val <a href="#MEM_MAP-val">MEM_MAP</a> : thm
<a name="line359"></a>    val <a href="#MEM_REVERSE-val">MEM_REVERSE</a> : thm
<a name="line360"></a>    val <a href="#MEM_SET_TO_LIST-val">MEM_SET_TO_LIST</a> : thm
<a name="line361"></a>    val <a href="#MEM_SNOC-val">MEM_SNOC</a> : thm
<a name="line362"></a>    val <a href="#MEM_SPLIT-val">MEM_SPLIT</a> : thm
<a name="line363"></a>    val <a href="#MEM_SPLIT_APPEND_first-val">MEM_SPLIT_APPEND_first</a> : thm
<a name="line364"></a>    val <a href="#MEM_SPLIT_APPEND_last-val">MEM_SPLIT_APPEND_last</a> : thm
<a name="line365"></a>    val <a href="#MEM_ZIP-val">MEM_ZIP</a> : thm
<a name="line366"></a>    val <a href="#MEM_ZIP_MEM_MAP-val">MEM_ZIP_MEM_MAP</a> : thm
<a name="line367"></a>    val <a href="#MEM_dropWhile_IMP-val">MEM_dropWhile_IMP</a> : thm
<a name="line368"></a>    val <a href="#MONO_EVERY-val">MONO_EVERY</a> : thm
<a name="line369"></a>    val <a href="#MONO_EXISTS-val">MONO_EXISTS</a> : thm
<a name="line370"></a>    val <a href="#NOT_CONS_NIL-val">NOT_CONS_NIL</a> : thm
<a name="line371"></a>    val <a href="#NOT_EQ_LIST-val">NOT_EQ_LIST</a> : thm
<a name="line372"></a>    val <a href="#NOT_EVERY-val">NOT_EVERY</a> : thm
<a name="line373"></a>    val <a href="#NOT_EXISTS-val">NOT_EXISTS</a> : thm
<a name="line374"></a>    val <a href="#NOT_NIL_CONS-val">NOT_NIL_CONS</a> : thm
<a name="line375"></a>    val <a href="#NOT_NIL_EQ_LENGTH_NOT_0-val">NOT_NIL_EQ_LENGTH_NOT_0</a> : thm
<a name="line376"></a>    val <a href="#NOT_NULL_MEM-val">NOT_NULL_MEM</a> : thm
<a name="line377"></a>    val <a href="#NRC_LRC-val">NRC_LRC</a> : thm
<a name="line378"></a>    val <a href="#NULL-val">NULL</a> : thm
<a name="line379"></a>    val <a href="#NULL_APPEND-val">NULL_APPEND</a> : thm
<a name="line380"></a>    val <a href="#NULL_EQ-val">NULL_EQ</a> : thm
<a name="line381"></a>    val <a href="#NULL_FILTER-val">NULL_FILTER</a> : thm
<a name="line382"></a>    val <a href="#NULL_GENLIST-val">NULL_GENLIST</a> : thm
<a name="line383"></a>    val <a href="#NULL_LENGTH-val">NULL_LENGTH</a> : thm
<a name="line384"></a>    val <a href="#OPT_MMAP_cong-val">OPT_MMAP_cong</a> : thm
<a name="line385"></a>    val <a href="#REVERSE_11-val">REVERSE_11</a> : thm
<a name="line386"></a>    val <a href="#REVERSE_APPEND-val">REVERSE_APPEND</a> : thm
<a name="line387"></a>    val <a href="#REVERSE_EQ_NIL-val">REVERSE_EQ_NIL</a> : thm
<a name="line388"></a>    val <a href="#REVERSE_EQ_SING-val">REVERSE_EQ_SING</a> : thm
<a name="line389"></a>    val <a href="#REVERSE_GENLIST-val">REVERSE_GENLIST</a> : thm
<a name="line390"></a>    val <a href="#REVERSE_REV-val">REVERSE_REV</a> : thm
<a name="line391"></a>    val <a href="#REVERSE_REVERSE-val">REVERSE_REVERSE</a> : thm
<a name="line392"></a>    val <a href="#REVERSE_SNOC-val">REVERSE_SNOC</a> : thm
<a name="line393"></a>    val <a href="#REVERSE_SNOC_DEF-val">REVERSE_SNOC_DEF</a> : thm
<a name="line394"></a>    val <a href="#REVERSE_o_REVERSE-val">REVERSE_o_REVERSE</a> : thm
<a name="line395"></a>    val <a href="#REV_REVERSE_LEM-val">REV_REVERSE_LEM</a> : thm
<a name="line396"></a>    val <a href="#SET_TO_LIST_CARD-val">SET_TO_LIST_CARD</a> : thm
<a name="line397"></a>    val <a href="#SET_TO_LIST_EMPTY-val">SET_TO_LIST_EMPTY</a> : thm
<a name="line398"></a>    val <a href="#SET_TO_LIST_IND-val">SET_TO_LIST_IND</a> : thm
<a name="line399"></a>    val <a href="#SET_TO_LIST_INV-val">SET_TO_LIST_INV</a> : thm
<a name="line400"></a>    val <a href="#SET_TO_LIST_IN_MEM-val">SET_TO_LIST_IN_MEM</a> : thm
<a name="line401"></a>    val <a href="#SET_TO_LIST_SING-val">SET_TO_LIST_SING</a> : thm
<a name="line402"></a>    val <a href="#SET_TO_LIST_THM-val">SET_TO_LIST_THM</a> : thm
<a name="line403"></a>    val <a href="#SHORTLEX_LENGTH_LE-val">SHORTLEX_LENGTH_LE</a> : thm
<a name="line404"></a>    val <a href="#SHORTLEX_MONO-val">SHORTLEX_MONO</a> : thm
<a name="line405"></a>    val <a href="#SHORTLEX_NIL2-val">SHORTLEX_NIL2</a> : thm
<a name="line406"></a>    val <a href="#SHORTLEX_THM-val">SHORTLEX_THM</a> : thm
<a name="line407"></a>    val <a href="#SHORTLEX_total-val">SHORTLEX_total</a> : thm
<a name="line408"></a>    val <a href="#SHORTLEX_transitive-val">SHORTLEX_transitive</a> : thm
<a name="line409"></a>    val <a href="#SINGL_APPLY_MAP-val">SINGL_APPLY_MAP</a> : thm
<a name="line410"></a>    val <a href="#SINGL_APPLY_PERMUTE-val">SINGL_APPLY_PERMUTE</a> : thm
<a name="line411"></a>    val <a href="#SINGL_LIST_APPLY_L-val">SINGL_LIST_APPLY_L</a> : thm
<a name="line412"></a>    val <a href="#SINGL_LIST_APPLY_R-val">SINGL_LIST_APPLY_R</a> : thm
<a name="line413"></a>    val <a href="#SINGL_SINGL_APPLY-val">SINGL_SINGL_APPLY</a> : thm
<a name="line414"></a>    val <a href="#SING_HD-val">SING_HD</a> : thm
<a name="line415"></a>    val <a href="#SNOC_11-val">SNOC_11</a> : thm
<a name="line416"></a>    val <a href="#SNOC_APPEND-val">SNOC_APPEND</a> : thm
<a name="line417"></a>    val <a href="#SNOC_Axiom-val">SNOC_Axiom</a> : thm
<a name="line418"></a>    val <a href="#SNOC_CASES-val">SNOC_CASES</a> : thm
<a name="line419"></a>    val <a href="#SNOC_INDUCT-val">SNOC_INDUCT</a> : thm
<a name="line420"></a>    val <a href="#SUM_ACC_SUM_LEM-val">SUM_ACC_SUM_LEM</a> : thm
<a name="line421"></a>    val <a href="#SUM_APPEND-val">SUM_APPEND</a> : thm
<a name="line422"></a>    val <a href="#SUM_IMAGE_LIST_TO_SET_upper_bound-val">SUM_IMAGE_LIST_TO_SET_upper_bound</a> : thm
<a name="line423"></a>    val <a href="#SUM_IMAGE_eq_SUM_MAP_SET_TO_LIST-val">SUM_IMAGE_eq_SUM_MAP_SET_TO_LIST</a> : thm
<a name="line424"></a>    val <a href="#SUM_MAP_FOLDL-val">SUM_MAP_FOLDL</a> : thm
<a name="line425"></a>    val <a href="#SUM_MAP_MEM_bound-val">SUM_MAP_MEM_bound</a> : thm
<a name="line426"></a>    val <a href="#SUM_MAP_PLUS-val">SUM_MAP_PLUS</a> : thm
<a name="line427"></a>    val <a href="#SUM_MAP_PLUS_ZIP-val">SUM_MAP_PLUS_ZIP</a> : thm
<a name="line428"></a>    val <a href="#SUM_SNOC-val">SUM_SNOC</a> : thm
<a name="line429"></a>    val <a href="#SUM_SUM_ACC-val">SUM_SUM_ACC</a> : thm
<a name="line430"></a>    val <a href="#SUM_eq_0-val">SUM_eq_0</a> : thm
<a name="line431"></a>    val <a href="#SWAP_REVERSE-val">SWAP_REVERSE</a> : thm
<a name="line432"></a>    val <a href="#SWAP_REVERSE_SYM-val">SWAP_REVERSE_SYM</a> : thm
<a name="line433"></a>    val <a href="#TAKE1-val">TAKE1</a> : thm
<a name="line434"></a>    val <a href="#TAKE1_DROP-val">TAKE1_DROP</a> : thm
<a name="line435"></a>    val <a href="#TAKE_0-val">TAKE_0</a> : thm
<a name="line436"></a>    val <a href="#TAKE_APPEND1-val">TAKE_APPEND1</a> : thm
<a name="line437"></a>    val <a href="#TAKE_APPEND2-val">TAKE_APPEND2</a> : thm
<a name="line438"></a>    val <a href="#TAKE_DROP-val">TAKE_DROP</a> : thm
<a name="line439"></a>    val <a href="#TAKE_EQ_NIL-val">TAKE_EQ_NIL</a> : thm
<a name="line440"></a>    val <a href="#TAKE_GENLIST-val">TAKE_GENLIST</a> : thm
<a name="line441"></a>    val <a href="#TAKE_LENGTH_ID-val">TAKE_LENGTH_ID</a> : thm
<a name="line442"></a>    val <a href="#TAKE_LENGTH_ID_rwt-val">TAKE_LENGTH_ID_rwt</a> : thm
<a name="line443"></a>    val <a href="#TAKE_LENGTH_TOO_LONG-val">TAKE_LENGTH_TOO_LONG</a> : thm
<a name="line444"></a>    val <a href="#TAKE_SUM-val">TAKE_SUM</a> : thm
<a name="line445"></a>    val <a href="#TAKE_TAKE_MIN-val">TAKE_TAKE_MIN</a> : thm
<a name="line446"></a>    val <a href="#TAKE_compute-val">TAKE_compute</a> : thm
<a name="line447"></a>    val <a href="#TAKE_cons-val">TAKE_cons</a> : thm
<a name="line448"></a>    val <a href="#TAKE_nil-val">TAKE_nil</a> : thm
<a name="line449"></a>    val <a href="#TAKE_splitAtPki-val">TAKE_splitAtPki</a> : thm
<a name="line450"></a>    val <a href="#TL-val">TL</a> : thm
<a name="line451"></a>    val <a href="#TL_GENLIST-val">TL_GENLIST</a> : thm
<a name="line452"></a>    val <a href="#UNION_APPEND-val">UNION_APPEND</a> : thm
<a name="line453"></a>    val <a href="#UNIQUE_FILTER-val">UNIQUE_FILTER</a> : thm
<a name="line454"></a>    val <a href="#UNIQUE_LENGTH_FILTER-val">UNIQUE_LENGTH_FILTER</a> : thm
<a name="line455"></a>    val <a href="#UNZIP_MAP-val">UNZIP_MAP</a> : thm
<a name="line456"></a>    val <a href="#UNZIP_THM-val">UNZIP_THM</a> : thm
<a name="line457"></a>    val <a href="#UNZIP_ZIP-val">UNZIP_ZIP</a> : thm
<a name="line458"></a>    val <a href="#WF_LIST_PRED-val">WF_LIST_PRED</a> : thm
<a name="line459"></a>    val <a href="#WF_SHORTLEX-val">WF_SHORTLEX</a> : thm
<a name="line460"></a>    val <a href="#WF_SHORTLEX_same_lengths-val">WF_SHORTLEX_same_lengths</a> : thm
<a name="line461"></a>    val <a href="#ZIP-val">ZIP</a> : thm
<a name="line462"></a>    val <a href="#ZIP_DROP-val">ZIP_DROP</a> : thm
<a name="line463"></a>    val <a href="#ZIP_EQ_NIL-val">ZIP_EQ_NIL</a> : thm
<a name="line464"></a>    val <a href="#ZIP_GENLIST-val">ZIP_GENLIST</a> : thm
<a name="line465"></a>    val <a href="#ZIP_MAP-val">ZIP_MAP</a> : thm
<a name="line466"></a>    val <a href="#ZIP_UNZIP-val">ZIP_UNZIP</a> : thm
<a name="line467"></a>    val <a href="#all_distinct_nub-val">all_distinct_nub</a> : thm
<a name="line468"></a>    val <a href="#datatype_list-val">datatype_list</a> : thm
<a name="line469"></a>    val <a href="#dropWhile_APPEND_EVERY-val">dropWhile_APPEND_EVERY</a> : thm
<a name="line470"></a>    val <a href="#dropWhile_APPEND_EXISTS-val">dropWhile_APPEND_EXISTS</a> : thm
<a name="line471"></a>    val <a href="#dropWhile_eq_nil-val">dropWhile_eq_nil</a> : thm
<a name="line472"></a>    val <a href="#dropWhile_splitAtPki-val">dropWhile_splitAtPki</a> : thm
<a name="line473"></a>    val <a href="#el_append3-val">el_append3</a> : thm
<a name="line474"></a>    val <a href="#every_zip_fst-val">every_zip_fst</a> : thm
<a name="line475"></a>    val <a href="#every_zip_snd-val">every_zip_snd</a> : thm
<a name="line476"></a>    val <a href="#exists_list_GENLIST-val">exists_list_GENLIST</a> : thm
<a name="line477"></a>    val <a href="#isPREFIX_CONSR-val">isPREFIX_CONSR</a> : thm
<a name="line478"></a>    val <a href="#isPREFIX_NILR-val">isPREFIX_NILR</a> : thm
<a name="line479"></a>    val <a href="#isPREFIX_THM-val">isPREFIX_THM</a> : thm
<a name="line480"></a>    val <a href="#last_drop-val">last_drop</a> : thm
<a name="line481"></a>    val <a href="#lazy_list_case_compute-val">lazy_list_case_compute</a> : thm
<a name="line482"></a>    val <a href="#length_nub_append-val">length_nub_append</a> : thm
<a name="line483"></a>    val <a href="#list_11-val">list_11</a> : thm
<a name="line484"></a>    val <a href="#list_Axiom-val">list_Axiom</a> : thm
<a name="line485"></a>    val <a href="#list_Axiom_old-val">list_Axiom_old</a> : thm
<a name="line486"></a>    val <a href="#list_CASES-val">list_CASES</a> : thm
<a name="line487"></a>    val <a href="#list_INDUCT-val">list_INDUCT</a> : thm
<a name="line488"></a>    val <a href="#list_INDUCT0-val">list_INDUCT0</a> : thm
<a name="line489"></a>    val <a href="#list_case_compute-val">list_case_compute</a> : thm
<a name="line490"></a>    val <a href="#list_case_cong-val">list_case_cong</a> : thm
<a name="line491"></a>    val <a href="#list_case_eq-val">list_case_eq</a> : thm
<a name="line492"></a>    val <a href="#list_distinct-val">list_distinct</a> : thm
<a name="line493"></a>    val <a href="#list_induction-val">list_induction</a> : thm
<a name="line494"></a>    val <a href="#list_nchotomy-val">list_nchotomy</a> : thm
<a name="line495"></a>    val <a href="#list_size_cong-val">list_size_cong</a> : thm
<a name="line496"></a>    val <a href="#list_to_set_diff-val">list_to_set_diff</a> : thm
<a name="line497"></a>    val <a href="#lupdate_append-val">lupdate_append</a> : thm
<a name="line498"></a>    val <a href="#lupdate_append2-val">lupdate_append2</a> : thm
<a name="line499"></a>    val <a href="#mem_exists_set-val">mem_exists_set</a> : thm
<a name="line500"></a>    val <a href="#nub_append-val">nub_append</a> : thm
<a name="line501"></a>    val <a href="#nub_set-val">nub_set</a> : thm
<a name="line502"></a>    val <a href="#oEL_DROP-val">oEL_DROP</a> : thm
<a name="line503"></a>    val <a href="#oEL_EQ_EL-val">oEL_EQ_EL</a> : thm
<a name="line504"></a>    val <a href="#oEL_LUPDATE-val">oEL_LUPDATE</a> : thm
<a name="line505"></a>    val <a href="#oEL_TAKE_E-val">oEL_TAKE_E</a> : thm
<a name="line506"></a>    val <a href="#oEL_THM-val">oEL_THM</a> : thm
<a name="line507"></a>    val <a href="#oHD_thm-val">oHD_thm</a> : thm
<a name="line508"></a>    val <a href="#splitAtPki_APPEND-val">splitAtPki_APPEND</a> : thm
<a name="line509"></a>    val <a href="#splitAtPki_EQN-val">splitAtPki_EQN</a> : thm
<a name="line510"></a>    val <a href="#splitAtPki_MAP-val">splitAtPki_MAP</a> : thm
<a name="line511"></a>    val <a href="#splitAtPki_RAND-val">splitAtPki_RAND</a> : thm
<a name="line512"></a>    val <a href="#splitAtPki_change_predicate-val">splitAtPki_change_predicate</a> : thm
<a name="line513"></a>  
<a name="line514"></a>  val list_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line515"></a>(*
   [ind_type] Parent theory of "list"
   
   [pred_set] Parent theory of "list"
   
   [<a name="ALL_DISTINCT-val"><b>ALL_DISTINCT</b></a>]  Definition
      
      ⊢ (ALL_DISTINCT [] ⇔ T) ∧
        ∀h t. ALL_DISTINCT (h::t) ⇔ ¬MEM h t ∧ ALL_DISTINCT t
   
   [<a name="APPEND-val"><b>APPEND</b></a>]  Definition
      
      ⊢ (∀l. [] ⧺ l = l) ∧ ∀l1 l2 h. h::l1 ⧺ l2 = h::(l1 ⧺ l2)
   
   [<a name="DROP_def-val"><b>DROP_def</b></a>]  Definition
      
      ⊢ (∀n. DROP n [] = []) ∧
        ∀n x xs. DROP n (x::xs) = if n = 0 then x::xs else DROP (n − 1) xs
   
   [<a name="EL-val"><b>EL</b></a>]  Definition
      
      ⊢ (∀l. EL 0 l = HD l) ∧ ∀l n. EL (SUC n) l = EL n (TL l)
   
   [<a name="EVERY_DEF-val"><b>EVERY_DEF</b></a>]  Definition
      
      ⊢ (∀P. EVERY P [] ⇔ T) ∧ ∀P h t. EVERY P (h::t) ⇔ P h ∧ EVERY P t
   
   [<a name="EVERYi_def-val"><b>EVERYi_def</b></a>]  Definition
      
      ⊢ (∀P. EVERYi P [] ⇔ T) ∧
        ∀P h t. EVERYi P (h::t) ⇔ P 0 h ∧ EVERYi (P ∘ SUC) t
   
   [<a name="EXISTS_DEF-val"><b>EXISTS_DEF</b></a>]  Definition
      
      ⊢ (∀P. EXISTS P [] ⇔ F) ∧ ∀P h t. EXISTS P (h::t) ⇔ P h ∨ EXISTS P t
   
   [<a name="FILTER-val"><b>FILTER</b></a>]  Definition
      
      ⊢ (∀P. FILTER P [] = []) ∧
        ∀P h t. FILTER P (h::t) = if P h then h::FILTER P t else FILTER P t
   
   [<a name="FIND_def-val"><b>FIND_def</b></a>]  Definition
      
      ⊢ ∀P. FIND P = OPTION_MAP SND ∘ INDEX_FIND 0 P
   
   [<a name="FLAT-val"><b>FLAT</b></a>]  Definition
      
      ⊢ FLAT [] = [] ∧ ∀h t. FLAT (h::t) = h ⧺ FLAT t
   
   [<a name="FOLDL-val"><b>FOLDL</b></a>]  Definition
      
      ⊢ (∀f e. FOLDL f e [] = e) ∧
        ∀f e x l. FOLDL f e (x::l) = FOLDL f (f e x) l
   
   [<a name="FOLDR-val"><b>FOLDR</b></a>]  Definition
      
      ⊢ (∀f e. FOLDR f e [] = e) ∧
        ∀f e x l. FOLDR f e (x::l) = f x (FOLDR f e l)
   
   [<a name="FRONT_DEF-val"><b>FRONT_DEF</b></a>]  Definition
      
      ⊢ ∀h t. FRONT (h::t) = if t = [] then [] else h::FRONT t
   
   [<a name="GENLIST-val"><b>GENLIST</b></a>]  Definition
      
      ⊢ (∀f. GENLIST f 0 = []) ∧
        ∀f n. GENLIST f (SUC n) = SNOC (f n) (GENLIST f n)
   
   [<a name="GENLIST_AUX-val"><b>GENLIST_AUX</b></a>]  Definition
      
      ⊢ (∀f l. GENLIST_AUX f 0 l = l) ∧
        ∀f n l. GENLIST_AUX f (SUC n) l = GENLIST_AUX f n (f n::l)
   
   [<a name="HD-val"><b>HD</b></a>]  Definition
      
      ⊢ ∀h t. HD (h::t) = h
   
   [<a name="INDEX_FIND_def-val"><b>INDEX_FIND_def</b></a>]  Definition
      
      ⊢ (∀i P. INDEX_FIND i P [] = NONE) ∧
        ∀i P h t.
            INDEX_FIND i P (h::t) =
            if P h then SOME (i,h) else INDEX_FIND (SUC i) P t
   
   [<a name="INDEX_OF_def-val"><b>INDEX_OF_def</b></a>]  Definition
      
      ⊢ ∀x. INDEX_OF x = OPTION_MAP FST ∘ INDEX_FIND 0 ($= x)
   
   [<a name="LAST_DEF-val"><b>LAST_DEF</b></a>]  Definition
      
      ⊢ ∀h t. LAST (h::t) = if t = [] then h else LAST t
   
   [<a name="LENGTH-val"><b>LENGTH</b></a>]  Definition
      
      ⊢ LENGTH [] = 0 ∧ ∀h t. LENGTH (h::t) = SUC (LENGTH t)
   
   [<a name="LEN_DEF-val"><b>LEN_DEF</b></a>]  Definition
      
      ⊢ (∀n. LEN [] n = n) ∧ ∀h t n. LEN (h::t) n = LEN t (n + 1)
   
   [<a name="LIST_APPLY_def-val"><b>LIST_APPLY_def</b></a>]  Definition
      
      ⊢ ∀fs xs. fs &lt;*&gt; xs = LIST_BIND fs (combin$C MAP xs)
   
   [<a name="LIST_BIND_def-val"><b>LIST_BIND_def</b></a>]  Definition
      
      ⊢ ∀l f. LIST_BIND l f = FLAT (MAP f l)
   
   [<a name="LIST_GUARD_def-val"><b>LIST_GUARD_def</b></a>]  Definition
      
      ⊢ ∀b. LIST_GUARD b = if b then [()] else []
   
   [<a name="LIST_IGNORE_BIND_def-val"><b>LIST_IGNORE_BIND_def</b></a>]  Definition
      
      ⊢ ∀m1 m2. LIST_IGNORE_BIND m1 m2 = LIST_BIND m1 (K m2)
   
   [<a name="LIST_LIFT2_def-val"><b>LIST_LIFT2_def</b></a>]  Definition
      
      ⊢ ∀f xs ys. LIST_LIFT2 f xs ys = MAP f xs &lt;*&gt; ys
   
   [<a name="LIST_TO_SET_DEF-val"><b>LIST_TO_SET_DEF</b></a>]  Definition
      
      ⊢ (∀x. set [] x ⇔ F) ∧ ∀h t x. set (h::t) x ⇔ x = h ∨ set t x
   
   [<a name="LLEX_def-val"><b>LLEX_def</b></a>]  Definition
      
      ⊢ (∀R l2. LLEX R [] l2 ⇔ l2 ≠ []) ∧
        ∀R h1 t1 l2.
            LLEX R (h1::t1) l2 ⇔
            case l2 of
              [] =&gt; F
            | h2::t2 =&gt;
              if R h1 h2 then T else if h1 = h2 then LLEX R t1 t2 else F
   
   [<a name="LRC_def-val"><b>LRC_def</b></a>]  Definition
      
      ⊢ (∀R x y. LRC R [] x y ⇔ x = y) ∧
        ∀R h t x y. LRC R (h::t) x y ⇔ x = h ∧ ∃z. R x z ∧ LRC R t z y
   
   [<a name="LUPDATE_def-val"><b>LUPDATE_def</b></a>]  Definition
      
      ⊢ (∀e n. LUPDATE e n [] = []) ∧ (∀e x l. LUPDATE e 0 (x::l) = e::l) ∧
        ∀e n x l. LUPDATE e (SUC n) (x::l) = x::LUPDATE e n l
   
   [<a name="MAP-val"><b>MAP</b></a>]  Definition
      
      ⊢ (∀f. MAP f [] = []) ∧ ∀f h t. MAP f (h::t) = f h::MAP f t
   
   [<a name="NULL_DEF-val"><b>NULL_DEF</b></a>]  Definition
      
      ⊢ (NULL [] ⇔ T) ∧ ∀h t. NULL (h::t) ⇔ F
   
   [<a name="OPT_MMAP_def-val"><b>OPT_MMAP_def</b></a>]  Definition
      
      ⊢ (∀f. OPT_MMAP f [] = SOME []) ∧
        ∀f h0 t0.
            OPT_MMAP f (h0::t0) =
            OPTION_BIND (f h0)
              (λh. OPTION_BIND (OPT_MMAP f t0) (λt. SOME (h::t)))
   
   [<a name="PAD_LEFT-val"><b>PAD_LEFT</b></a>]  Definition
      
      ⊢ ∀c n s. PAD_LEFT c n s = GENLIST (K c) (n − LENGTH s) ⧺ s
   
   [<a name="PAD_RIGHT-val"><b>PAD_RIGHT</b></a>]  Definition
      
      ⊢ ∀c n s. PAD_RIGHT c n s = s ⧺ GENLIST (K c) (n − LENGTH s)
   
   [<a name="REVERSE_DEF-val"><b>REVERSE_DEF</b></a>]  Definition
      
      ⊢ REVERSE [] = [] ∧ ∀h t. REVERSE (h::t) = REVERSE t ⧺ [h]
   
   [<a name="REV_DEF-val"><b>REV_DEF</b></a>]  Definition
      
      ⊢ (∀acc. REV [] acc = acc) ∧
        ∀h t acc. REV (h::t) acc = REV t (h::acc)
   
   [<a name="SET_TO_LIST_primitive_def-val"><b>SET_TO_LIST_primitive_def</b></a>]  Definition
      
      ⊢ SET_TO_LIST =
        WFREC (@R. WF R ∧ ∀s. FINITE s ∧ s ≠ ∅ ⇒ R (REST s) s)
          (λSET_TO_LIST a.
               I
                 (if FINITE a then
                    if a = ∅ then [] else CHOICE a::SET_TO_LIST (REST a)
                  else ARB))
   
   [<a name="SHORTLEX_def-val"><b>SHORTLEX_def</b></a>]  Definition
      
      ⊢ (∀R l2. SHORTLEX R [] l2 ⇔ l2 ≠ []) ∧
        ∀R h1 t1 l2.
            SHORTLEX R (h1::t1) l2 ⇔
            case l2 of
              [] =&gt; F
            | h2::t2 =&gt;
              if LENGTH t1 &lt; LENGTH t2 then T
              else if LENGTH t1 = LENGTH t2 then
                if R h1 h2 then T
                else if h1 = h2 then SHORTLEX R t1 t2
                else F
              else F
   
   [<a name="SNOC-val"><b>SNOC</b></a>]  Definition
      
      ⊢ (∀x. SNOC x [] = [x]) ∧ ∀x x' l. SNOC x (x'::l) = x'::SNOC x l
   
   [<a name="SUM-val"><b>SUM</b></a>]  Definition
      
      ⊢ SUM [] = 0 ∧ ∀h t. SUM (h::t) = h + SUM t
   
   [<a name="SUM_ACC_DEF-val"><b>SUM_ACC_DEF</b></a>]  Definition
      
      ⊢ (∀acc. SUM_ACC [] acc = acc) ∧
        ∀h t acc. SUM_ACC (h::t) acc = SUM_ACC t (h + acc)
   
   [<a name="TAKE_def-val"><b>TAKE_def</b></a>]  Definition
      
      ⊢ (∀n. TAKE n [] = []) ∧
        ∀n x xs. TAKE n (x::xs) = if n = 0 then [] else x::TAKE (n − 1) xs
   
   [<a name="TL_DEF-val"><b>TL_DEF</b></a>]  Definition
      
      ⊢ TL [] = [] ∧ ∀h t. TL (h::t) = t
   
   [<a name="UNIQUE_DEF-val"><b>UNIQUE_DEF</b></a>]  Definition
      
      ⊢ ∀e L.
            UNIQUE e L ⇔ ∃L1 L2. L1 ⧺ [e] ⧺ L2 = L ∧ ¬MEM e L1 ∧ ¬MEM e L2
   
   [<a name="UNZIP-val"><b>UNZIP</b></a>]  Definition
      
      ⊢ UNZIP [] = ([],[]) ∧
        ∀x l. UNZIP (x::l) = (FST x::FST (UNZIP l),SND x::SND (UNZIP l))
   
   [<a name="ZIP_def-val"><b>ZIP_def</b></a>]  Definition
      
      ⊢ (∀l2. ZIP ([],l2) = []) ∧ (∀l1. ZIP (l1,[]) = []) ∧
        ∀x1 l1 x2 l2. ZIP (x1::l1,x2::l2) = (x1,x2)::ZIP (l1,l2)
   
   [<a name="dropWhile_def-val"><b>dropWhile_def</b></a>]  Definition
      
      ⊢ (∀P. dropWhile P [] = []) ∧
        ∀P h t. dropWhile P (h::t) = if P h then dropWhile P t else h::t
   
   [<a name="isPREFIX-val"><b>isPREFIX</b></a>]  Definition
      
      ⊢ (∀l. [] ≼ l ⇔ T) ∧
        ∀h t l. h::t ≼ l ⇔ case l of [] =&gt; F | h'::t' =&gt; h = h' ∧ t ≼ t'
   
   [<a name="list_TY_DEF-val"><b>list_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep.
            TYPE_DEFINITION
              (λa0'.
                   ∀ $var$('list').
                       (∀a0'.
                            a0' =
                            ind_type$CONSTR 0 ARB (λn. ind_type$BOTTOM) ∨
                            (∃a0 a1.
                                 a0' =
                                 (λa0 a1.
                                      ind_type$CONSTR (SUC 0) a0
                                        (ind_type$FCONS a1
                                           (λn. ind_type$BOTTOM))) a0 a1 ∧
                                 $var$('list') a1) ⇒
                            $var$('list') a0') ⇒
                       $var$('list') a0') rep
   
   [<a name="list_case_def-val"><b>list_case_def</b></a>]  Definition
      
      ⊢ (∀v f. list_CASE [] v f = v) ∧
        ∀a0 a1 v f. list_CASE (a0::a1) v f = f a0 a1
   
   [<a name="list_size_def-val"><b>list_size_def</b></a>]  Definition
      
      ⊢ (∀f. list_size f [] = 0) ∧
        ∀f a0 a1. list_size f (a0::a1) = 1 + (f a0 + list_size f a1)
   
   [<a name="nub_def-val"><b>nub_def</b></a>]  Definition
      
      ⊢ nub [] = [] ∧
        ∀x l. nub (x::l) = if MEM x l then nub l else x::nub l
   
   [<a name="oEL_def-val"><b>oEL_def</b></a>]  Definition
      
      ⊢ (∀n. oEL n [] = NONE) ∧
        ∀n x xs. oEL n (x::xs) = if n = 0 then SOME x else oEL (n − 1) xs
   
   [<a name="oHD_def-val"><b>oHD_def</b></a>]  Definition
      
      ⊢ ∀l. oHD l = case l of [] =&gt; NONE | h::v1 =&gt; SOME h
   
   [<a name="splitAtPki_def-val"><b>splitAtPki_def</b></a>]  Definition
      
      ⊢ (∀P k. splitAtPki P k [] = k [] []) ∧
        ∀P k h t.
            splitAtPki P k (h::t) =
            if P 0 h then k [] (h::t)
            else splitAtPki (P ∘ SUC) (λp s. k (h::p) s) t
   
   [<a name="ALL_DISTINCT_APPEND-val"><b>ALL_DISTINCT_APPEND</b></a>]  Theorem
      
      ⊢ ∀l1 l2.
            ALL_DISTINCT (l1 ⧺ l2) ⇔
            ALL_DISTINCT l1 ∧ ALL_DISTINCT l2 ∧ ∀e. MEM e l1 ⇒ ¬MEM e l2
   
   [<a name="ALL_DISTINCT_CARD_LIST_TO_SET-val"><b>ALL_DISTINCT_CARD_LIST_TO_SET</b></a>]  Theorem
      
      ⊢ ∀ls. ALL_DISTINCT ls ⇒ CARD (set ls) = LENGTH ls
   
   [<a name="ALL_DISTINCT_DROP-val"><b>ALL_DISTINCT_DROP</b></a>]  Theorem
      
      ⊢ ∀ls n. ALL_DISTINCT ls ⇒ ALL_DISTINCT (DROP n ls)
   
   [<a name="ALL_DISTINCT_EL_IMP-val"><b>ALL_DISTINCT_EL_IMP</b></a>]  Theorem
      
      ⊢ ∀l n1 n2.
            ALL_DISTINCT l ∧ n1 &lt; LENGTH l ∧ n2 &lt; LENGTH l ⇒
            (EL n1 l = EL n2 l ⇔ n1 = n2)
   
   [<a name="ALL_DISTINCT_FILTER-val"><b>ALL_DISTINCT_FILTER</b></a>]  Theorem
      
      ⊢ ∀l. ALL_DISTINCT l ⇔ ∀x. MEM x l ⇒ FILTER ($= x) l = [x]
   
   [<a name="ALL_DISTINCT_FILTER_EL_IMP-val"><b>ALL_DISTINCT_FILTER_EL_IMP</b></a>]  Theorem
      
      ⊢ ∀P l n1 n2.
            ALL_DISTINCT (FILTER P l) ∧ n1 &lt; LENGTH l ∧ n2 &lt; LENGTH l ∧
            P (EL n1 l) ∧ EL n1 l = EL n2 l ⇒
            n1 = n2
   
   [<a name="ALL_DISTINCT_FLAT_REVERSE-val"><b>ALL_DISTINCT_FLAT_REVERSE</b></a>]  Theorem
      
      ⊢ ∀xs. ALL_DISTINCT (FLAT (REVERSE xs)) ⇔ ALL_DISTINCT (FLAT xs)
   
   [<a name="ALL_DISTINCT_GENLIST-val"><b>ALL_DISTINCT_GENLIST</b></a>]  Theorem
      
      ⊢ ALL_DISTINCT (GENLIST f n) ⇔
        ∀m1 m2. m1 &lt; n ∧ m2 &lt; n ∧ f m1 = f m2 ⇒ m1 = m2
   
   [<a name="ALL_DISTINCT_MAP-val"><b>ALL_DISTINCT_MAP</b></a>]  Theorem
      
      ⊢ ∀f ls. ALL_DISTINCT (MAP f ls) ⇒ ALL_DISTINCT ls
   
   [<a name="ALL_DISTINCT_MAP_INJ-val"><b>ALL_DISTINCT_MAP_INJ</b></a>]  Theorem
      
      ⊢ ∀ls f.
            (∀x y. MEM x ls ∧ MEM y ls ∧ f x = f y ⇒ x = y) ∧
            ALL_DISTINCT ls ⇒
            ALL_DISTINCT (MAP f ls)
   
   [<a name="ALL_DISTINCT_REVERSE-val"><b>ALL_DISTINCT_REVERSE</b></a>]  Theorem
      
      ⊢ ∀l. ALL_DISTINCT (REVERSE l) ⇔ ALL_DISTINCT l
   
   [<a name="ALL_DISTINCT_SET_TO_LIST-val"><b>ALL_DISTINCT_SET_TO_LIST</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ALL_DISTINCT (SET_TO_LIST s)
   
   [<a name="ALL_DISTINCT_SING-val"><b>ALL_DISTINCT_SING</b></a>]  Theorem
      
      ⊢ ∀x. ALL_DISTINCT [x]
   
   [<a name="ALL_DISTINCT_SNOC-val"><b>ALL_DISTINCT_SNOC</b></a>]  Theorem
      
      ⊢ ∀x l. ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l
   
   [<a name="ALL_DISTINCT_ZIP-val"><b>ALL_DISTINCT_ZIP</b></a>]  Theorem
      
      ⊢ ∀l1 l2.
            ALL_DISTINCT l1 ∧ LENGTH l1 = LENGTH l2 ⇒
            ALL_DISTINCT (ZIP (l1,l2))
   
   [<a name="ALL_DISTINCT_ZIP_SWAP-val"><b>ALL_DISTINCT_ZIP_SWAP</b></a>]  Theorem
      
      ⊢ ∀l1 l2.
            ALL_DISTINCT (ZIP (l1,l2)) ∧ LENGTH l1 = LENGTH l2 ⇒
            ALL_DISTINCT (ZIP (l2,l1))
   
   [<a name="APPEND_11-val"><b>APPEND_11</b></a>]  Theorem
      
      ⊢ (∀l1 l2 l3. l1 ⧺ l2 = l1 ⧺ l3 ⇔ l2 = l3) ∧
        ∀l1 l2 l3. l2 ⧺ l1 = l3 ⧺ l1 ⇔ l2 = l3
   
   [<a name="APPEND_11_LENGTH-val"><b>APPEND_11_LENGTH</b></a>]  Theorem
      
      ⊢ (∀l1 l2 l1' l2'.
             LENGTH l1 = LENGTH l1' ⇒
             (l1 ⧺ l2 = l1' ⧺ l2' ⇔ l1 = l1' ∧ l2 = l2')) ∧
        ∀l1 l2 l1' l2'.
            LENGTH l2 = LENGTH l2' ⇒
            (l1 ⧺ l2 = l1' ⧺ l2' ⇔ l1 = l1' ∧ l2 = l2')
   
   [<a name="APPEND_ASSOC-val"><b>APPEND_ASSOC</b></a>]  Theorem
      
      ⊢ ∀l1 l2 l3. l1 ⧺ (l2 ⧺ l3) = l1 ⧺ l2 ⧺ l3
   
   [<a name="APPEND_EQ_APPEND-val"><b>APPEND_EQ_APPEND</b></a>]  Theorem
      
      ⊢ l1 ⧺ l2 = m1 ⧺ m2 ⇔
        (∃l. l1 = m1 ⧺ l ∧ m2 = l ⧺ l2) ∨ ∃l. m1 = l1 ⧺ l ∧ l2 = l ⧺ m2
   
   [<a name="APPEND_EQ_APPEND_MID-val"><b>APPEND_EQ_APPEND_MID</b></a>]  Theorem
      
      ⊢ l1 ⧺ [e] ⧺ l2 = m1 ⧺ m2 ⇔
        (∃l. m1 = l1 ⧺ [e] ⧺ l ∧ l2 = l ⧺ m2) ∨
        ∃l. l1 = m1 ⧺ l ∧ m2 = l ⧺ [e] ⧺ l2
   
   [<a name="APPEND_EQ_CONS-val"><b>APPEND_EQ_CONS</b></a>]  Theorem
      
      ⊢ l1 ⧺ l2 = h::t ⇔
        l1 = [] ∧ l2 = h::t ∨ ∃lt. l1 = h::lt ∧ t = lt ⧺ l2
   
   [<a name="APPEND_EQ_SELF-val"><b>APPEND_EQ_SELF</b></a>]  Theorem
      
      ⊢ (∀l1 l2. l1 ⧺ l2 = l1 ⇔ l2 = []) ∧
        (∀l1 l2. l1 ⧺ l2 = l2 ⇔ l1 = []) ∧
        (∀l1 l2. l1 = l1 ⧺ l2 ⇔ l2 = []) ∧ ∀l1 l2. l2 = l1 ⧺ l2 ⇔ l1 = []
   
   [<a name="APPEND_EQ_SING-val"><b>APPEND_EQ_SING</b></a>]  Theorem
      
      ⊢ l1 ⧺ l2 = [e] ⇔ l1 = [e] ∧ l2 = [] ∨ l1 = [] ∧ l2 = [e]
   
   [<a name="APPEND_FRONT_LAST-val"><b>APPEND_FRONT_LAST</b></a>]  Theorem
      
      ⊢ ∀l. l ≠ [] ⇒ FRONT l ⧺ [LAST l] = l
   
   [<a name="APPEND_LENGTH_EQ-val"><b>APPEND_LENGTH_EQ</b></a>]  Theorem
      
      ⊢ ∀l1 l1'.
            LENGTH l1 = LENGTH l1' ⇒
            ∀l2 l2'.
                LENGTH l2 = LENGTH l2' ⇒
                (l1 ⧺ l2 = l1' ⧺ l2' ⇔ l1 = l1' ∧ l2 = l2')
   
   [<a name="APPEND_NIL-val"><b>APPEND_NIL</b></a>]  Theorem
      
      ⊢ ∀l. l ⧺ [] = l
   
   [<a name="APPEND_SNOC-val"><b>APPEND_SNOC</b></a>]  Theorem
      
      ⊢ ∀l1 x l2. l1 ⧺ SNOC x l2 = SNOC x (l1 ⧺ l2)
   
   [<a name="APPEND_eq_NIL-val"><b>APPEND_eq_NIL</b></a>]  Theorem
      
      ⊢ (∀l1 l2. [] = l1 ⧺ l2 ⇔ l1 = [] ∧ l2 = []) ∧
        ∀l1 l2. l1 ⧺ l2 = [] ⇔ l1 = [] ∧ l2 = []
   
   [<a name="BIGUNION_IMAGE_set_SUBSET-val"><b>BIGUNION_IMAGE_set_SUBSET</b></a>]  Theorem
      
      ⊢ BIGUNION (IMAGE f (set ls)) ⊆ s ⇔ ∀x. MEM x ls ⇒ f x ⊆ s
   
   [<a name="CARD_LIST_TO_SET-val"><b>CARD_LIST_TO_SET</b></a>]  Theorem
      
      ⊢ CARD (set ls) ≤ LENGTH ls
   
   [<a name="CARD_LIST_TO_SET_ALL_DISTINCT-val"><b>CARD_LIST_TO_SET_ALL_DISTINCT</b></a>]  Theorem
      
      ⊢ ∀ls. CARD (set ls) = LENGTH ls ⇒ ALL_DISTINCT ls
   
   [<a name="CONS-val"><b>CONS</b></a>]  Theorem
      
      ⊢ ∀l. ¬NULL l ⇒ HD l::TL l = l
   
   [<a name="CONS_11-val"><b>CONS_11</b></a>]  Theorem
      
      ⊢ ∀a0 a1 a0' a1'. a0::a1 = a0'::a1' ⇔ a0 = a0' ∧ a1 = a1'
   
   [<a name="CONS_ACYCLIC-val"><b>CONS_ACYCLIC</b></a>]  Theorem
      
      ⊢ ∀l x. l ≠ x::l ∧ x::l ≠ l
   
   [<a name="DISJOINT_GENLIST_PLUS-val"><b>DISJOINT_GENLIST_PLUS</b></a>]  Theorem
      
      ⊢ DISJOINT x (set (GENLIST ($+ n) (a + b))) ⇒
        DISJOINT x (set (GENLIST ($+ n) a)) ∧
        DISJOINT x (set (GENLIST ($+ (n + a)) b))
   
   [<a name="DROP_0-val"><b>DROP_0</b></a>]  Theorem
      
      ⊢ DROP 0 l = l
   
   [<a name="DROP_GENLIST-val"><b>DROP_GENLIST</b></a>]  Theorem
      
      ⊢ DROP n (GENLIST f m) = GENLIST (f ∘ $+ n) (m − n)
   
   [<a name="DROP_LENGTH_TOO_LONG-val"><b>DROP_LENGTH_TOO_LONG</b></a>]  Theorem
      
      ⊢ ∀l n. LENGTH l ≤ n ⇒ DROP n l = []
   
   [<a name="DROP_NIL-val"><b>DROP_NIL</b></a>]  Theorem
      
      ⊢ ∀ls n. DROP n ls = [] ⇔ n ≥ LENGTH ls
   
   [<a name="DROP_compute-val"><b>DROP_compute</b></a>]  Theorem
      
      ⊢ (∀l. DROP 0 l = l) ∧ (∀n. DROP (NUMERAL (BIT1 n)) [] = []) ∧
        (∀n. DROP (NUMERAL (BIT2 n)) [] = []) ∧
        (∀n h t.
             DROP (NUMERAL (BIT1 n)) (h::t) = DROP (NUMERAL (BIT1 n) − 1) t) ∧
        ∀n h t. DROP (NUMERAL (BIT2 n)) (h::t) = DROP (NUMERAL (BIT1 n)) t
   
   [<a name="DROP_cons-val"><b>DROP_cons</b></a>]  Theorem
      
      ⊢ 0 &lt; n ⇒ DROP n (x::xs) = DROP (n − 1) xs
   
   [<a name="DROP_nil-val"><b>DROP_nil</b></a>]  Theorem
      
      ⊢ ∀n. DROP n [] = []
   
   [<a name="DROP_splitAtPki-val"><b>DROP_splitAtPki</b></a>]  Theorem
      
      ⊢ DROP n l = splitAtPki (K ∘ $= n) (K I) l
   
   [<a name="EL_ALL_DISTINCT_EL_EQ-val"><b>EL_ALL_DISTINCT_EL_EQ</b></a>]  Theorem
      
      ⊢ ∀l.
            ALL_DISTINCT l ⇔
            ∀n1 n2.
                n1 &lt; LENGTH l ∧ n2 &lt; LENGTH l ⇒
                (EL n1 l = EL n2 l ⇔ n1 = n2)
   
   [<a name="EL_APPEND_EQN-val"><b>EL_APPEND_EQN</b></a>]  Theorem
      
      ⊢ ∀l1 l2 n.
            EL n (l1 ⧺ l2) =
            if n &lt; LENGTH l1 then EL n l1 else EL (n − LENGTH l1) l2
   
   [<a name="EL_DROP-val"><b>EL_DROP</b></a>]  Theorem
      
      ⊢ ∀m n l. m + n &lt; LENGTH l ⇒ EL m (DROP n l) = EL (m + n) l
   
   [<a name="EL_GENLIST-val"><b>EL_GENLIST</b></a>]  Theorem
      
      ⊢ ∀f n x. x &lt; n ⇒ EL x (GENLIST f n) = f x
   
   [<a name="EL_LENGTH_SNOC-val"><b>EL_LENGTH_SNOC</b></a>]  Theorem
      
      ⊢ ∀l x. EL (LENGTH l) (SNOC x l) = x
   
   [<a name="EL_LENGTH_dropWhile_REVERSE-val"><b>EL_LENGTH_dropWhile_REVERSE</b></a>]  Theorem
      
      ⊢ ∀P ls k.
            LENGTH (dropWhile P (REVERSE ls)) ≤ k ∧ k &lt; LENGTH ls ⇒
            P (EL k ls)
   
   [<a name="EL_LUPDATE-val"><b>EL_LUPDATE</b></a>]  Theorem
      
      ⊢ ∀ys x i k.
            EL i (LUPDATE x k ys) =
            if i = k ∧ k &lt; LENGTH ys then x else EL i ys
   
   [<a name="EL_MAP-val"><b>EL_MAP</b></a>]  Theorem
      
      ⊢ ∀n l. n &lt; LENGTH l ⇒ ∀f. EL n (MAP f l) = f (EL n l)
   
   [<a name="EL_MAP2-val"><b>EL_MAP2</b></a>]  Theorem
      
      ⊢ ∀ts tt n.
            n &lt; MIN (LENGTH ts) (LENGTH tt) ⇒
            EL n (MAP2 f ts tt) = f (EL n ts) (EL n tt)
   
   [<a name="EL_REVERSE-val"><b>EL_REVERSE</b></a>]  Theorem
      
      ⊢ ∀n l. n &lt; LENGTH l ⇒ EL n (REVERSE l) = EL (PRE (LENGTH l − n)) l
   
   [<a name="EL_SNOC-val"><b>EL_SNOC</b></a>]  Theorem
      
      ⊢ ∀n l. n &lt; LENGTH l ⇒ ∀x. EL n (SNOC x l) = EL n l
   
   [<a name="EL_TAKE-val"><b>EL_TAKE</b></a>]  Theorem
      
      ⊢ ∀n x l. x &lt; n ⇒ EL x (TAKE n l) = EL x l
   
   [<a name="EL_ZIP-val"><b>EL_ZIP</b></a>]  Theorem
      
      ⊢ ∀l1 l2 n.
            LENGTH l1 = LENGTH l2 ∧ n &lt; LENGTH l1 ⇒
            EL n (ZIP (l1,l2)) = (EL n l1,EL n l2)
   
   [<a name="EL_compute-val"><b>EL_compute</b></a>]  Theorem
      
      ⊢ ∀n. EL n l = if n = 0 then HD l else EL (PRE n) (TL l)
   
   [<a name="EL_restricted-val"><b>EL_restricted</b></a>]  Theorem
      
      ⊢ EL 0 = HD ∧ EL (SUC n) (l::ls) = EL n ls
   
   [<a name="EL_simp-val"><b>EL_simp</b></a>]  Theorem
      
      ⊢ EL (NUMERAL (BIT1 n)) l = EL (PRE (NUMERAL (BIT1 n))) (TL l) ∧
        EL (NUMERAL (BIT2 n)) l = EL (NUMERAL (BIT1 n)) (TL l)
   
   [<a name="EL_simp_restricted-val"><b>EL_simp_restricted</b></a>]  Theorem
      
      ⊢ EL (NUMERAL (BIT1 n)) (l::ls) = EL (PRE (NUMERAL (BIT1 n))) ls ∧
        EL (NUMERAL (BIT2 n)) (l::ls) = EL (NUMERAL (BIT1 n)) ls
   
   [<a name="EQ_LIST-val"><b>EQ_LIST</b></a>]  Theorem
      
      ⊢ ∀h1 h2. h1 = h2 ⇒ ∀l1 l2. l1 = l2 ⇒ h1::l1 = h2::l2
   
   [<a name="EVERY2_EVERY-val"><b>EVERY2_EVERY</b></a>]  Theorem
      
      ⊢ ∀l1 l2 f.
            LIST_REL f l1 l2 ⇔
            LENGTH l1 = LENGTH l2 ∧ EVERY (UNCURRY f) (ZIP (l1,l2))
   
   [<a name="EVERY2_LENGTH-val"><b>EVERY2_LENGTH</b></a>]  Theorem
      
      ⊢ ∀P l1 l2. LIST_REL P l1 l2 ⇒ LENGTH l1 = LENGTH l2
   
   [<a name="EVERY2_LUPDATE_same-val"><b>EVERY2_LUPDATE_same</b></a>]  Theorem
      
      ⊢ ∀P l1 l2 v1 v2 n.
            P v1 v2 ∧ LIST_REL P l1 l2 ⇒
            LIST_REL P (LUPDATE v1 n l1) (LUPDATE v2 n l2)
   
   [<a name="EVERY2_MAP-val"><b>EVERY2_MAP</b></a>]  Theorem
      
      ⊢ (LIST_REL P (MAP f l1) l2 ⇔ LIST_REL (λx y. P (f x) y) l1 l2) ∧
        (LIST_REL Q l1 (MAP g l2) ⇔ LIST_REL (λx y. Q x (g y)) l1 l2)
   
   [<a name="EVERY2_MEM_MONO-val"><b>EVERY2_MEM_MONO</b></a>]  Theorem
      
      ⊢ ∀P Q l1 l2.
            (∀x. MEM x (ZIP (l1,l2)) ∧ UNCURRY P x ⇒ UNCURRY Q x) ∧
            LIST_REL P l1 l2 ⇒
            LIST_REL Q l1 l2
   
   [<a name="EVERY2_REVERSE-val"><b>EVERY2_REVERSE</b></a>]  Theorem
      
      ⊢ ∀R l1 l2. LIST_REL R l1 l2 ⇒ LIST_REL R (REVERSE l1) (REVERSE l2)
   
   [<a name="EVERY2_THM-val"><b>EVERY2_THM</b></a>]  Theorem
      
      ⊢ (∀P ys. LIST_REL P [] ys ⇔ ys = []) ∧
        (∀P yys x xs.
             LIST_REL P (x::xs) yys ⇔
             ∃y ys. yys = y::ys ∧ P x y ∧ LIST_REL P xs ys) ∧
        (∀P xs. LIST_REL P xs [] ⇔ xs = []) ∧
        ∀P xxs y ys.
            LIST_REL P xxs (y::ys) ⇔
            ∃x xs. xxs = x::xs ∧ P x y ∧ LIST_REL P xs ys
   
   [<a name="EVERY2_cong-val"><b>EVERY2_cong</b></a>]  Theorem
      
      ⊢ ∀l1 l1' l2 l2' P P'.
            l1 = l1' ∧ l2 = l2' ∧
            (∀x y. MEM x l1' ∧ MEM y l2' ⇒ (P x y ⇔ P' x y)) ⇒
            (LIST_REL P l1 l2 ⇔ LIST_REL P' l1' l2')
   
   [<a name="EVERY2_mono-val"><b>EVERY2_mono</b></a>]  Theorem
      
      ⊢ (∀x y. R1 x y ⇒ R2 x y) ⇒ LIST_REL R1 l1 l2 ⇒ LIST_REL R2 l1 l2
   
   [<a name="EVERY2_refl-val"><b>EVERY2_refl</b></a>]  Theorem
      
      ⊢ (∀x. MEM x ls ⇒ R x x) ⇒ LIST_REL R ls ls
   
   [<a name="EVERY2_sym-val"><b>EVERY2_sym</b></a>]  Theorem
      
      ⊢ (∀x y. R1 x y ⇒ R2 y x) ⇒ ∀x y. LIST_REL R1 x y ⇒ LIST_REL R2 y x
   
   [<a name="EVERY2_trans-val"><b>EVERY2_trans</b></a>]  Theorem
      
      ⊢ (∀x y z. R x y ∧ R y z ⇒ R x z) ⇒
        ∀x y z. LIST_REL R x y ∧ LIST_REL R y z ⇒ LIST_REL R x z
   
   [<a name="EVERY_APPEND-val"><b>EVERY_APPEND</b></a>]  Theorem
      
      ⊢ ∀P l1 l2. EVERY P (l1 ⧺ l2) ⇔ EVERY P l1 ∧ EVERY P l2
   
   [<a name="EVERY_CONG-val"><b>EVERY_CONG</b></a>]  Theorem
      
      ⊢ ∀l1 l2 P P'.
            l1 = l2 ∧ (∀x. MEM x l2 ⇒ (P x ⇔ P' x)) ⇒
            (EVERY P l1 ⇔ EVERY P' l2)
   
   [<a name="EVERY_CONJ-val"><b>EVERY_CONJ</b></a>]  Theorem
      
      ⊢ ∀P Q l. EVERY (λx. P x ∧ Q x) l ⇔ EVERY P l ∧ EVERY Q l
   
   [<a name="EVERY_EL-val"><b>EVERY_EL</b></a>]  Theorem
      
      ⊢ ∀l P. EVERY P l ⇔ ∀n. n &lt; LENGTH l ⇒ P (EL n l)
   
   [<a name="EVERY_FILTER-val"><b>EVERY_FILTER</b></a>]  Theorem
      
      ⊢ ∀P1 P2 l. EVERY P1 (FILTER P2 l) ⇔ EVERY (λx. P2 x ⇒ P1 x) l
   
   [<a name="EVERY_FILTER_IMP-val"><b>EVERY_FILTER_IMP</b></a>]  Theorem
      
      ⊢ ∀P1 P2 l. EVERY P1 l ⇒ EVERY P1 (FILTER P2 l)
   
   [<a name="EVERY_FLAT-val"><b>EVERY_FLAT</b></a>]  Theorem
      
      ⊢ EVERY P (FLAT ls) ⇔ EVERY (EVERY P) ls
   
   [<a name="EVERY_GENLIST-val"><b>EVERY_GENLIST</b></a>]  Theorem
      
      ⊢ ∀n. EVERY P (GENLIST f n) ⇔ ∀i. i &lt; n ⇒ P (f i)
   
   [<a name="EVERY_MAP-val"><b>EVERY_MAP</b></a>]  Theorem
      
      ⊢ ∀P f l. EVERY P (MAP f l) ⇔ EVERY (λx. P (f x)) l
   
   [<a name="EVERY_MEM-val"><b>EVERY_MEM</b></a>]  Theorem
      
      ⊢ ∀P l. EVERY P l ⇔ ∀e. MEM e l ⇒ P e
   
   [<a name="EVERY_MEM_MONO-val"><b>EVERY_MEM_MONO</b></a>]  Theorem
      
      ⊢ ∀P Q l. (∀x. MEM x l ∧ P x ⇒ Q x) ∧ EVERY P l ⇒ EVERY Q l
   
   [<a name="EVERY_MONOTONIC-val"><b>EVERY_MONOTONIC</b></a>]  Theorem
      
      ⊢ ∀P Q. (∀x. P x ⇒ Q x) ⇒ ∀l. EVERY P l ⇒ EVERY Q l
   
   [<a name="EVERY_NOT_EXISTS-val"><b>EVERY_NOT_EXISTS</b></a>]  Theorem
      
      ⊢ ∀P l. EVERY P l ⇔ ¬EXISTS (λx. ¬P x) l
   
   [<a name="EVERY_SIMP-val"><b>EVERY_SIMP</b></a>]  Theorem
      
      ⊢ ∀c l. EVERY (λx. c) l ⇔ l = [] ∨ c
   
   [<a name="EVERY_SNOC-val"><b>EVERY_SNOC</b></a>]  Theorem
      
      ⊢ ∀P x l. EVERY P (SNOC x l) ⇔ EVERY P l ∧ P x
   
   [<a name="EXISTS_APPEND-val"><b>EXISTS_APPEND</b></a>]  Theorem
      
      ⊢ ∀P l1 l2. EXISTS P (l1 ⧺ l2) ⇔ EXISTS P l1 ∨ EXISTS P l2
   
   [<a name="EXISTS_CONG-val"><b>EXISTS_CONG</b></a>]  Theorem
      
      ⊢ ∀l1 l2 P P'.
            l1 = l2 ∧ (∀x. MEM x l2 ⇒ (P x ⇔ P' x)) ⇒
            (EXISTS P l1 ⇔ EXISTS P' l2)
   
   [<a name="EXISTS_GENLIST-val"><b>EXISTS_GENLIST</b></a>]  Theorem
      
      ⊢ ∀n. EXISTS P (GENLIST f n) ⇔ ∃i. i &lt; n ∧ P (f i)
   
   [<a name="EXISTS_LIST-val"><b>EXISTS_LIST</b></a>]  Theorem
      
      ⊢ (∃l. P l) ⇔ P [] ∨ ∃h t. P (h::t)
   
   [<a name="EXISTS_LIST_EQ_MAP-val"><b>EXISTS_LIST_EQ_MAP</b></a>]  Theorem
      
      ⊢ ∀ls f. EVERY (λx. ∃y. x = f y) ls ⇒ ∃l. ls = MAP f l
   
   [<a name="EXISTS_MAP-val"><b>EXISTS_MAP</b></a>]  Theorem
      
      ⊢ ∀P f l. EXISTS P (MAP f l) ⇔ EXISTS (λx. P (f x)) l
   
   [<a name="EXISTS_MEM-val"><b>EXISTS_MEM</b></a>]  Theorem
      
      ⊢ ∀P l. EXISTS P l ⇔ ∃e. MEM e l ∧ P e
   
   [<a name="EXISTS_NOT_EVERY-val"><b>EXISTS_NOT_EVERY</b></a>]  Theorem
      
      ⊢ ∀P l. EXISTS P l ⇔ ¬EVERY (λx. ¬P x) l
   
   [<a name="EXISTS_SIMP-val"><b>EXISTS_SIMP</b></a>]  Theorem
      
      ⊢ ∀c l. EXISTS (λx. c) l ⇔ l ≠ [] ∧ c
   
   [<a name="EXISTS_SNOC-val"><b>EXISTS_SNOC</b></a>]  Theorem
      
      ⊢ ∀P x l. EXISTS P (SNOC x l) ⇔ P x ∨ EXISTS P l
   
   [<a name="FILTER_ALL_DISTINCT-val"><b>FILTER_ALL_DISTINCT</b></a>]  Theorem
      
      ⊢ ∀P l. ALL_DISTINCT l ⇒ ALL_DISTINCT (FILTER P l)
   
   [<a name="FILTER_APPEND_DISTRIB-val"><b>FILTER_APPEND_DISTRIB</b></a>]  Theorem
      
      ⊢ ∀P L M. FILTER P (L ⧺ M) = FILTER P L ⧺ FILTER P M
   
   [<a name="FILTER_COND_REWRITE-val"><b>FILTER_COND_REWRITE</b></a>]  Theorem
      
      ⊢ FILTER P [] = [] ∧ (∀h. P h ⇒ FILTER P (h::l) = h::FILTER P l) ∧
        ∀h. ¬P h ⇒ FILTER P (h::l) = FILTER P l
   
   [<a name="FILTER_EQ_APPEND-val"><b>FILTER_EQ_APPEND</b></a>]  Theorem
      
      ⊢ ∀P l l1 l2.
            FILTER P l = l1 ⧺ l2 ⇔
            ∃l3 l4. l = l3 ⧺ l4 ∧ FILTER P l3 = l1 ∧ FILTER P l4 = l2
   
   [<a name="FILTER_EQ_CONS-val"><b>FILTER_EQ_CONS</b></a>]  Theorem
      
      ⊢ ∀P l h lr.
            FILTER P l = h::lr ⇔
            ∃l1 l2.
                l = l1 ⧺ [h] ⧺ l2 ∧ FILTER P l1 = [] ∧ FILTER P l2 = lr ∧
                P h
   
   [<a name="FILTER_EQ_ID-val"><b>FILTER_EQ_ID</b></a>]  Theorem
      
      ⊢ ∀P l. FILTER P l = l ⇔ EVERY P l
   
   [<a name="FILTER_EQ_NIL-val"><b>FILTER_EQ_NIL</b></a>]  Theorem
      
      ⊢ ∀P l. FILTER P l = [] ⇔ EVERY (λx. ¬P x) l
   
   [<a name="FILTER_F-val"><b>FILTER_F</b></a>]  Theorem
      
      ⊢ ∀xs. FILTER (λx. F) xs = []
   
   [<a name="FILTER_NEQ_ID-val"><b>FILTER_NEQ_ID</b></a>]  Theorem
      
      ⊢ ∀P l. FILTER P l ≠ l ⇔ ∃x. MEM x l ∧ ¬P x
   
   [<a name="FILTER_NEQ_NIL-val"><b>FILTER_NEQ_NIL</b></a>]  Theorem
      
      ⊢ ∀P l. FILTER P l ≠ [] ⇔ ∃x. MEM x l ∧ P x
   
   [<a name="FILTER_REVERSE-val"><b>FILTER_REVERSE</b></a>]  Theorem
      
      ⊢ ∀l P. FILTER P (REVERSE l) = REVERSE (FILTER P l)
   
   [<a name="FILTER_T-val"><b>FILTER_T</b></a>]  Theorem
      
      ⊢ ∀xs. FILTER (λx. T) xs = xs
   
   [<a name="FINITE_LIST_TO_SET-val"><b>FINITE_LIST_TO_SET</b></a>]  Theorem
      
      ⊢ ∀l. FINITE (set l)
   
   [<a name="FLAT_APPEND-val"><b>FLAT_APPEND</b></a>]  Theorem
      
      ⊢ ∀l1 l2. FLAT (l1 ⧺ l2) = FLAT l1 ⧺ FLAT l2
   
   [<a name="FLAT_EQ_NIL-val"><b>FLAT_EQ_NIL</b></a>]  Theorem
      
      ⊢ ∀ls. FLAT ls = [] ⇔ EVERY ($= []) ls
   
   [<a name="FLAT_compute-val"><b>FLAT_compute</b></a>]  Theorem
      
      ⊢ FLAT [] = [] ∧ FLAT ([]::t) = FLAT t ∧
        FLAT ((h::t1)::t2) = h::FLAT (t1::t2)
   
   [<a name="FOLDL2_FOLDL-val"><b>FOLDL2_FOLDL</b></a>]  Theorem
      
      ⊢ ∀l1 l2.
            LENGTH l1 = LENGTH l2 ⇒
            ∀f a.
                FOLDL2 f a l1 l2 =
                FOLDL (λa. UNCURRY (f a)) a (ZIP (l1,l2))
   
   [<a name="FOLDL2_cong-val"><b>FOLDL2_cong</b></a>]  Theorem
      
      ⊢ ∀l1 l1' l2 l2' a a' f f'.
            l1 = l1' ∧ l2 = l2' ∧ a = a' ∧
            (∀z b c. MEM b l1' ∧ MEM c l2' ⇒ f z b c = f' z b c) ⇒
            FOLDL2 f a l1 l2 = FOLDL2 f' a' l1' l2'
   
   [<a name="FOLDL2_def-val"><b>FOLDL2_def</b></a>]  Theorem
      
      ⊢ (∀f cs c bs b a.
             FOLDL2 f a (b::bs) (c::cs) = FOLDL2 f (f a b c) bs cs) ∧
        (∀f cs a. FOLDL2 f a [] cs = a) ∧
        ∀v7 v6 f a. FOLDL2 f a (v6::v7) [] = a
   
   [<a name="FOLDL2_ind-val"><b>FOLDL2_ind</b></a>]  Theorem
      
      ⊢ ∀P.
            (∀f a b bs c cs. P f (f a b c) bs cs ⇒ P f a (b::bs) (c::cs)) ∧
            (∀f a cs. P f a [] cs) ∧ (∀f a v6 v7. P f a (v6::v7) []) ⇒
            ∀v v1 v2 v3. P v v1 v2 v3
   
   [<a name="FOLDL_CONG-val"><b>FOLDL_CONG</b></a>]  Theorem
      
      ⊢ ∀l l' b b' f f'.
            l = l' ∧ b = b' ∧ (∀x a. MEM x l' ⇒ f a x = f' a x) ⇒
            FOLDL f b l = FOLDL f' b' l'
   
   [<a name="FOLDL_EQ_FOLDR-val"><b>FOLDL_EQ_FOLDR</b></a>]  Theorem
      
      ⊢ ∀f l e. ASSOC f ∧ COMM f ⇒ FOLDL f e l = FOLDR f e l
   
   [<a name="FOLDL_SNOC-val"><b>FOLDL_SNOC</b></a>]  Theorem
      
      ⊢ ∀f e x l. FOLDL f e (SNOC x l) = f (FOLDL f e l) x
   
   [<a name="FOLDL_UNION_BIGUNION-val"><b>FOLDL_UNION_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀f ls s.
            FOLDL (λs x. s ∪ f x) s ls = s ∪ BIGUNION (IMAGE f (set ls))
   
   [<a name="FOLDL_UNION_BIGUNION_paired-val"><b>FOLDL_UNION_BIGUNION_paired</b></a>]  Theorem
      
      ⊢ ∀f ls s.
            FOLDL (λs (x,y). s ∪ f x y) s ls =
            s ∪ BIGUNION (IMAGE (UNCURRY f) (set ls))
   
   [<a name="FOLDL_ZIP_SAME-val"><b>FOLDL_ZIP_SAME</b></a>]  Theorem
      
      ⊢ ∀ls f e. FOLDL f e (ZIP (ls,ls)) = FOLDL (λx y. f x (y,y)) e ls
   
   [<a name="FOLDR_CONG-val"><b>FOLDR_CONG</b></a>]  Theorem
      
      ⊢ ∀l l' b b' f f'.
            l = l' ∧ b = b' ∧ (∀x a. MEM x l' ⇒ f x a = f' x a) ⇒
            FOLDR f b l = FOLDR f' b' l'
   
   [<a name="FOLDR_CONS-val"><b>FOLDR_CONS</b></a>]  Theorem
      
      ⊢ ∀f ls a. FOLDR (λx y. f x::y) a ls = MAP f ls ⧺ a
   
   [<a name="FORALL_LIST-val"><b>FORALL_LIST</b></a>]  Theorem
      
      ⊢ (∀l. P l) ⇔ P [] ∧ ∀h t. P (h::t)
   
   [<a name="FRONT_CONS-val"><b>FRONT_CONS</b></a>]  Theorem
      
      ⊢ (∀x. FRONT [x] = []) ∧ ∀x y z. FRONT (x::y::z) = x::FRONT (y::z)
   
   [<a name="FRONT_CONS_EQ_NIL-val"><b>FRONT_CONS_EQ_NIL</b></a>]  Theorem
      
      ⊢ (∀x xs. FRONT (x::xs) = [] ⇔ xs = []) ∧
        (∀x xs. [] = FRONT (x::xs) ⇔ xs = []) ∧
        ∀x xs. NULL (FRONT (x::xs)) ⇔ NULL xs
   
   [<a name="FRONT_SNOC-val"><b>FRONT_SNOC</b></a>]  Theorem
      
      ⊢ ∀x l. FRONT (SNOC x l) = l
   
   [<a name="GENLIST_APPEND-val"><b>GENLIST_APPEND</b></a>]  Theorem
      
      ⊢ ∀f a b. GENLIST f (a + b) = GENLIST f b ⧺ GENLIST (λt. f (t + b)) a
   
   [<a name="GENLIST_AUX_compute-val"><b>GENLIST_AUX_compute</b></a>]  Theorem
      
      ⊢ (∀f l. GENLIST_AUX f 0 l = l) ∧
        (∀f n l.
             GENLIST_AUX f (NUMERAL (BIT1 n)) l =
             GENLIST_AUX f (NUMERAL (BIT1 n) − 1)
               (f (NUMERAL (BIT1 n) − 1)::l)) ∧
        ∀f n l.
            GENLIST_AUX f (NUMERAL (BIT2 n)) l =
            GENLIST_AUX f (NUMERAL (BIT1 n)) (f (NUMERAL (BIT1 n))::l)
   
   [<a name="GENLIST_CONS-val"><b>GENLIST_CONS</b></a>]  Theorem
      
      ⊢ GENLIST f (SUC n) = f 0::GENLIST (f ∘ SUC) n
   
   [<a name="GENLIST_EL-val"><b>GENLIST_EL</b></a>]  Theorem
      
      ⊢ ∀ls f n.
            n = LENGTH ls ∧ (∀i. i &lt; n ⇒ f i = EL i ls) ⇒ GENLIST f n = ls
   
   [<a name="GENLIST_EL_MAP-val"><b>GENLIST_EL_MAP</b></a>]  Theorem
      
      ⊢ ∀f ls. GENLIST (λn. f (EL n ls)) (LENGTH ls) = MAP f ls
   
   [<a name="GENLIST_FUN_EQ-val"><b>GENLIST_FUN_EQ</b></a>]  Theorem
      
      ⊢ ∀n f g. GENLIST f n = GENLIST g n ⇔ ∀x. x &lt; n ⇒ f x = g x
   
   [<a name="GENLIST_GENLIST_AUX-val"><b>GENLIST_GENLIST_AUX</b></a>]  Theorem
      
      ⊢ ∀n. GENLIST f n = GENLIST_AUX f n []
   
   [<a name="GENLIST_ID-val"><b>GENLIST_ID</b></a>]  Theorem
      
      ⊢ ∀x. GENLIST (λi. EL i x) (LENGTH x) = x
   
   [<a name="GENLIST_NUMERALS-val"><b>GENLIST_NUMERALS</b></a>]  Theorem
      
      ⊢ GENLIST f 0 = [] ∧
        GENLIST f (NUMERAL n) = GENLIST_AUX f (NUMERAL n) []
   
   [<a name="GENLIST_PLUS_APPEND-val"><b>GENLIST_PLUS_APPEND</b></a>]  Theorem
      
      ⊢ GENLIST ($+ a) n1 ⧺ GENLIST ($+ (n1 + a)) n2 =
        GENLIST ($+ a) (n1 + n2)
   
   [<a name="HD_DROP-val"><b>HD_DROP</b></a>]  Theorem
      
      ⊢ ∀n l. n &lt; LENGTH l ⇒ HD (DROP n l) = EL n l
   
   [<a name="HD_GENLIST-val"><b>HD_GENLIST</b></a>]  Theorem
      
      ⊢ HD (GENLIST f (SUC n)) = f 0
   
   [<a name="HD_GENLIST_COR-val"><b>HD_GENLIST_COR</b></a>]  Theorem
      
      ⊢ ∀n f. 0 &lt; n ⇒ HD (GENLIST f n) = f 0
   
   [<a name="HD_REVERSE-val"><b>HD_REVERSE</b></a>]  Theorem
      
      ⊢ ∀x. x ≠ [] ⇒ HD (REVERSE x) = LAST x
   
   [<a name="HD_dropWhile-val"><b>HD_dropWhile</b></a>]  Theorem
      
      ⊢ ∀P ls. EXISTS ($~ ∘ P) ls ⇒ ¬P (HD (dropWhile P ls))
   
   [<a name="IMAGE_EL_count_LENGTH-val"><b>IMAGE_EL_count_LENGTH</b></a>]  Theorem
      
      ⊢ ∀f ls.
            IMAGE (λn. f (EL n ls)) (count (LENGTH ls)) = IMAGE f (set ls)
   
   [<a name="IMP_EVERY_LUPDATE-val"><b>IMP_EVERY_LUPDATE</b></a>]  Theorem
      
      ⊢ ∀xs h i. P h ∧ EVERY P xs ⇒ EVERY P (LUPDATE h i xs)
   
   [<a name="INFINITE_LIST_UNIV-val"><b>INFINITE_LIST_UNIV</b></a>]  Theorem
      
      ⊢ INFINITE 𝕌(:α list)
   
   [<a name="INJ_MAP_EQ-val"><b>INJ_MAP_EQ</b></a>]  Theorem
      
      ⊢ ∀f l1 l2.
            INJ f (set l1 ∪ set l2) 𝕌(:β) ∧ MAP f l1 = MAP f l2 ⇒ l1 = l2
   
   [<a name="INJ_MAP_EQ_IFF-val"><b>INJ_MAP_EQ_IFF</b></a>]  Theorem
      
      ⊢ ∀f l1 l2.
            INJ f (set l1 ∪ set l2) 𝕌(:β) ⇒ (MAP f l1 = MAP f l2 ⇔ l1 = l2)
   
   [<a name="ITSET_eq_FOLDL_SET_TO_LIST-val"><b>ITSET_eq_FOLDL_SET_TO_LIST</b></a>]  Theorem
      
      ⊢ ∀s.
            FINITE s ⇒
            ∀f a. ITSET f s a = FOLDL (combin$C f) a (SET_TO_LIST s)
   
   [<a name="LAST_APPEND_CONS-val"><b>LAST_APPEND_CONS</b></a>]  Theorem
      
      ⊢ ∀h l1 l2. LAST (l1 ⧺ h::l2) = LAST (h::l2)
   
   [<a name="LAST_CONS-val"><b>LAST_CONS</b></a>]  Theorem
      
      ⊢ (∀x. LAST [x] = x) ∧ ∀x y z. LAST (x::y::z) = LAST (y::z)
   
   [<a name="LAST_CONS_cond-val"><b>LAST_CONS_cond</b></a>]  Theorem
      
      ⊢ LAST (h::t) = if t = [] then h else LAST t
   
   [<a name="LAST_EL-val"><b>LAST_EL</b></a>]  Theorem
      
      ⊢ ∀ls. ls ≠ [] ⇒ LAST ls = EL (PRE (LENGTH ls)) ls
   
   [<a name="LAST_MAP-val"><b>LAST_MAP</b></a>]  Theorem
      
      ⊢ ∀l f. l ≠ [] ⇒ LAST (MAP f l) = f (LAST l)
   
   [<a name="LAST_REVERSE-val"><b>LAST_REVERSE</b></a>]  Theorem
      
      ⊢ ∀ls. ls ≠ [] ⇒ LAST (REVERSE ls) = HD ls
   
   [<a name="LAST_SNOC-val"><b>LAST_SNOC</b></a>]  Theorem
      
      ⊢ ∀x l. LAST (SNOC x l) = x
   
   [<a name="LAST_compute-val"><b>LAST_compute</b></a>]  Theorem
      
      ⊢ (∀x. LAST [x] = x) ∧ ∀h1 h2 t. LAST (h1::h2::t) = LAST (h2::t)
   
   [<a name="LENGTH_APPEND-val"><b>LENGTH_APPEND</b></a>]  Theorem
      
      ⊢ ∀l1 l2. LENGTH (l1 ⧺ l2) = LENGTH l1 + LENGTH l2
   
   [<a name="LENGTH_CONS-val"><b>LENGTH_CONS</b></a>]  Theorem
      
      ⊢ ∀l n. LENGTH l = SUC n ⇔ ∃h l'. LENGTH l' = n ∧ l = h::l'
   
   [<a name="LENGTH_DROP-val"><b>LENGTH_DROP</b></a>]  Theorem
      
      ⊢ ∀n l. LENGTH (DROP n l) = LENGTH l − n
   
   [<a name="LENGTH_EQ_CONS-val"><b>LENGTH_EQ_CONS</b></a>]  Theorem
      
      ⊢ ∀P n.
            (∀l. LENGTH l = SUC n ⇒ P l) ⇔
            ∀l. LENGTH l = n ⇒ (λl. ∀x. P (x::l)) l
   
   [<a name="LENGTH_EQ_NIL-val"><b>LENGTH_EQ_NIL</b></a>]  Theorem
      
      ⊢ ∀P. (∀l. LENGTH l = 0 ⇒ P l) ⇔ P []
   
   [<a name="LENGTH_EQ_NUM-val"><b>LENGTH_EQ_NUM</b></a>]  Theorem
      
      ⊢ (∀l. LENGTH l = 0 ⇔ l = []) ∧
        (∀l n. LENGTH l = SUC n ⇔ ∃h l'. LENGTH l' = n ∧ l = h::l') ∧
        ∀l n1 n2.
            LENGTH l = n1 + n2 ⇔
            ∃l1 l2. LENGTH l1 = n1 ∧ LENGTH l2 = n2 ∧ l = l1 ⧺ l2
   
   [<a name="LENGTH_EQ_NUM_compute-val"><b>LENGTH_EQ_NUM_compute</b></a>]  Theorem
      
      ⊢ (∀l. LENGTH l = 0 ⇔ l = []) ∧
        (∀l n.
             LENGTH l = NUMERAL (BIT1 n) ⇔
             ∃h l'. LENGTH l' = NUMERAL (BIT1 n) − 1 ∧ l = h::l') ∧
        (∀l n.
             LENGTH l = NUMERAL (BIT2 n) ⇔
             ∃h l'. LENGTH l' = NUMERAL (BIT1 n) ∧ l = h::l') ∧
        ∀l n1 n2.
            LENGTH l = n1 + n2 ⇔
            ∃l1 l2. LENGTH l1 = n1 ∧ LENGTH l2 = n2 ∧ l = l1 ⧺ l2
   
   [<a name="LENGTH_EQ_SUM-val"><b>LENGTH_EQ_SUM</b></a>]  Theorem
      
      ⊢ ∀l n1 n2.
            LENGTH l = n1 + n2 ⇔
            ∃l1 l2. LENGTH l1 = n1 ∧ LENGTH l2 = n2 ∧ l = l1 ⧺ l2
   
   [<a name="LENGTH_FILTER_LEQ_MONO-val"><b>LENGTH_FILTER_LEQ_MONO</b></a>]  Theorem
      
      ⊢ ∀P Q.
            (∀x. P x ⇒ Q x) ⇒
            ∀ls. LENGTH (FILTER P ls) ≤ LENGTH (FILTER Q ls)
   
   [<a name="LENGTH_FRONT_CONS-val"><b>LENGTH_FRONT_CONS</b></a>]  Theorem
      
      ⊢ ∀x xs. LENGTH (FRONT (x::xs)) = LENGTH xs
   
   [<a name="LENGTH_GENLIST-val"><b>LENGTH_GENLIST</b></a>]  Theorem
      
      ⊢ ∀f n. LENGTH (GENLIST f n) = n
   
   [<a name="LENGTH_LEN-val"><b>LENGTH_LEN</b></a>]  Theorem
      
      ⊢ ∀L. LENGTH L = LEN L 0
   
   [<a name="LENGTH_LT_SHORTLEX-val"><b>LENGTH_LT_SHORTLEX</b></a>]  Theorem
      
      ⊢ ∀l1 l2. LENGTH l1 &lt; LENGTH l2 ⇒ SHORTLEX R l1 l2
   
   [<a name="LENGTH_LUPDATE-val"><b>LENGTH_LUPDATE</b></a>]  Theorem
      
      ⊢ ∀x n ys. LENGTH (LUPDATE x n ys) = LENGTH ys
   
   [<a name="LENGTH_MAP-val"><b>LENGTH_MAP</b></a>]  Theorem
      
      ⊢ ∀l f. LENGTH (MAP f l) = LENGTH l
   
   [<a name="LENGTH_MAP2-val"><b>LENGTH_MAP2</b></a>]  Theorem
      
      ⊢ ∀xs ys. LENGTH (MAP2 f xs ys) = MIN (LENGTH xs) (LENGTH ys)
   
   [<a name="LENGTH_NIL-val"><b>LENGTH_NIL</b></a>]  Theorem
      
      ⊢ ∀l. LENGTH l = 0 ⇔ l = []
   
   [<a name="LENGTH_NIL_SYM-val"><b>LENGTH_NIL_SYM</b></a>]  Theorem
      
      ⊢ 0 = LENGTH l ⇔ l = []
   
   [<a name="LENGTH_REVERSE-val"><b>LENGTH_REVERSE</b></a>]  Theorem
      
      ⊢ ∀l. LENGTH (REVERSE l) = LENGTH l
   
   [<a name="LENGTH_SNOC-val"><b>LENGTH_SNOC</b></a>]  Theorem
      
      ⊢ ∀x l. LENGTH (SNOC x l) = SUC (LENGTH l)
   
   [<a name="LENGTH_TAKE-val"><b>LENGTH_TAKE</b></a>]  Theorem
      
      ⊢ ∀n l. n ≤ LENGTH l ⇒ LENGTH (TAKE n l) = n
   
   [<a name="LENGTH_TAKE_EQ-val"><b>LENGTH_TAKE_EQ</b></a>]  Theorem
      
      ⊢ LENGTH (TAKE n xs) = if n ≤ LENGTH xs then n else LENGTH xs
   
   [<a name="LENGTH_TL-val"><b>LENGTH_TL</b></a>]  Theorem
      
      ⊢ ∀l. 0 &lt; LENGTH l ⇒ LENGTH (TL l) = LENGTH l − 1
   
   [<a name="LENGTH_UNZIP-val"><b>LENGTH_UNZIP</b></a>]  Theorem
      
      ⊢ ∀pl.
            LENGTH (FST (UNZIP pl)) = LENGTH pl ∧
            LENGTH (SND (UNZIP pl)) = LENGTH pl
   
   [<a name="LENGTH_ZIP-val"><b>LENGTH_ZIP</b></a>]  Theorem
      
      ⊢ ∀l1 l2.
            LENGTH l1 = LENGTH l2 ⇒
            LENGTH (ZIP (l1,l2)) = LENGTH l1 ∧
            LENGTH (ZIP (l1,l2)) = LENGTH l2
   
   [<a name="LENGTH_ZIP_MIN-val"><b>LENGTH_ZIP_MIN</b></a>]  Theorem
      
      ⊢ ∀xs ys. LENGTH (ZIP (xs,ys)) = MIN (LENGTH xs) (LENGTH ys)
   
   [<a name="LENGTH_dropWhile_LESS_EQ-val"><b>LENGTH_dropWhile_LESS_EQ</b></a>]  Theorem
      
      ⊢ ∀P ls. LENGTH (dropWhile P ls) ≤ LENGTH ls
   
   [<a name="LENGTH_o_REVERSE-val"><b>LENGTH_o_REVERSE</b></a>]  Theorem
      
      ⊢ LENGTH ∘ REVERSE = LENGTH ∧ LENGTH ∘ REVERSE ∘ f = LENGTH ∘ f
   
   [<a name="LEN_LENGTH_LEM-val"><b>LEN_LENGTH_LEM</b></a>]  Theorem
      
      ⊢ ∀L n. LEN L n = LENGTH L + n
   
   [<a name="LIST_APPLY_o-val"><b>LIST_APPLY_o</b></a>]  Theorem
      
      ⊢ [$o] &lt;*&gt; fs &lt;*&gt; gs &lt;*&gt; xs = fs &lt;*&gt; (gs &lt;*&gt; xs)
   
   [<a name="LIST_BIND_APPEND-val"><b>LIST_BIND_APPEND</b></a>]  Theorem
      
      ⊢ LIST_BIND (l1 ⧺ l2) f = LIST_BIND l1 f ⧺ LIST_BIND l2 f
   
   [<a name="LIST_BIND_ID-val"><b>LIST_BIND_ID</b></a>]  Theorem
      
      ⊢ LIST_BIND l (λx. x) = FLAT l ∧ LIST_BIND l I = FLAT l
   
   [<a name="LIST_BIND_LIST_BIND-val"><b>LIST_BIND_LIST_BIND</b></a>]  Theorem
      
      ⊢ LIST_BIND (LIST_BIND l g) f =
        LIST_BIND l (combin$C LIST_BIND f ∘ g)
   
   [<a name="LIST_BIND_MAP-val"><b>LIST_BIND_MAP</b></a>]  Theorem
      
      ⊢ LIST_BIND (MAP f l) g = LIST_BIND l (g ∘ f)
   
   [<a name="LIST_BIND_THM-val"><b>LIST_BIND_THM</b></a>]  Theorem
      
      ⊢ LIST_BIND [] f = [] ∧ LIST_BIND (h::t) f = f h ⧺ LIST_BIND t f
   
   [<a name="LIST_EQ-val"><b>LIST_EQ</b></a>]  Theorem
      
      ⊢ ∀l1 l2.
            LENGTH l1 = LENGTH l2 ∧ (∀x. x &lt; LENGTH l1 ⇒ EL x l1 = EL x l2) ⇒
            l1 = l2
   
   [<a name="LIST_EQ_MAP_PAIR-val"><b>LIST_EQ_MAP_PAIR</b></a>]  Theorem
      
      ⊢ ∀l1 l2. MAP FST l1 = MAP FST l2 ∧ MAP SND l1 = MAP SND l2 ⇒ l1 = l2
   
   [<a name="LIST_EQ_REWRITE-val"><b>LIST_EQ_REWRITE</b></a>]  Theorem
      
      ⊢ ∀l1 l2.
            l1 = l2 ⇔
            LENGTH l1 = LENGTH l2 ∧ ∀x. x &lt; LENGTH l1 ⇒ EL x l1 = EL x l2
   
   [<a name="LIST_NOT_EQ-val"><b>LIST_NOT_EQ</b></a>]  Theorem
      
      ⊢ ∀l1 l2. l1 ≠ l2 ⇒ ∀h1 h2. h1::l1 ≠ h2::l2
   
   [<a name="LIST_REL_APPEND-val"><b>LIST_REL_APPEND</b></a>]  Theorem
      
      ⊢ LIST_REL R l1 l2 ∧ LIST_REL R l3 l4 ⇔
        LIST_REL R (l1 ⧺ l3) (l2 ⧺ l4) ∧ LENGTH l1 = LENGTH l2 ∧
        LENGTH l3 = LENGTH l4
   
   [<a name="LIST_REL_APPEND_EQ-val"><b>LIST_REL_APPEND_EQ</b></a>]  Theorem
      
      ⊢ LENGTH x1 = LENGTH x2 ⇒
        (LIST_REL R (x1 ⧺ y1) (x2 ⧺ y2) ⇔
         LIST_REL R x1 x2 ∧ LIST_REL R y1 y2)
   
   [<a name="LIST_REL_APPEND_IMP-val"><b>LIST_REL_APPEND_IMP</b></a>]  Theorem
      
      ⊢ ∀xs ys xs1 ys1.
            LIST_REL P (xs ⧺ xs1) (ys ⧺ ys1) ∧ LENGTH xs = LENGTH ys ⇒
            LIST_REL P xs ys ∧ LIST_REL P xs1 ys1
   
   [<a name="LIST_REL_APPEND_suff-val"><b>LIST_REL_APPEND_suff</b></a>]  Theorem
      
      ⊢ LIST_REL R l1 l2 ∧ LIST_REL R l3 l4 ⇒
        LIST_REL R (l1 ⧺ l3) (l2 ⧺ l4)
   
   [<a name="LIST_REL_CONJ-val"><b>LIST_REL_CONJ</b></a>]  Theorem
      
      ⊢ LIST_REL (λa b. P a b ∧ Q a b) l1 l2 ⇔
        LIST_REL (λa b. P a b) l1 l2 ∧ LIST_REL (λa b. Q a b) l1 l2
   
   [<a name="LIST_REL_CONS1-val"><b>LIST_REL_CONS1</b></a>]  Theorem
      
      ⊢ LIST_REL R (h::t) xs ⇔
        ∃h' t'. xs = h'::t' ∧ R h h' ∧ LIST_REL R t t'
   
   [<a name="LIST_REL_CONS2-val"><b>LIST_REL_CONS2</b></a>]  Theorem
      
      ⊢ LIST_REL R xs (h::t) ⇔
        ∃h' t'. xs = h'::t' ∧ R h' h ∧ LIST_REL R t' t
   
   [<a name="LIST_REL_EL_EQN-val"><b>LIST_REL_EL_EQN</b></a>]  Theorem
      
      ⊢ ∀R l1 l2.
            LIST_REL R l1 l2 ⇔
            LENGTH l1 = LENGTH l2 ∧
            ∀n. n &lt; LENGTH l1 ⇒ R (EL n l1) (EL n l2)
   
   [<a name="LIST_REL_EVERY_ZIP-val"><b>LIST_REL_EVERY_ZIP</b></a>]  Theorem
      
      ⊢ ∀R l1 l2.
            LIST_REL R l1 l2 ⇔
            LENGTH l1 = LENGTH l2 ∧ EVERY (UNCURRY R) (ZIP (l1,l2))
   
   [<a name="LIST_REL_LENGTH-val"><b>LIST_REL_LENGTH</b></a>]  Theorem
      
      ⊢ ∀x y. LIST_REL R x y ⇒ LENGTH x = LENGTH y
   
   [<a name="LIST_REL_MAP1-val"><b>LIST_REL_MAP1</b></a>]  Theorem
      
      ⊢ LIST_REL R (MAP f l1) l2 ⇔ LIST_REL (R ∘ f) l1 l2
   
   [<a name="LIST_REL_MAP2-val"><b>LIST_REL_MAP2</b></a>]  Theorem
      
      ⊢ LIST_REL (λa b. R a b) l1 (MAP f l2) ⇔
        LIST_REL (λa b. R a (f b)) l1 l2
   
   [<a name="LIST_REL_MAP_inv_image-val"><b>LIST_REL_MAP_inv_image</b></a>]  Theorem
      
      ⊢ LIST_REL R (MAP f l1) (MAP f l2) ⇔ LIST_REL (inv_image R f) l1 l2
   
   [<a name="LIST_REL_MEM_IMP-val"><b>LIST_REL_MEM_IMP</b></a>]  Theorem
      
      ⊢ ∀xs ys P x. LIST_REL P xs ys ∧ MEM x xs ⇒ ∃y. MEM y ys ∧ P x y
   
   [<a name="LIST_REL_NIL-val"><b>LIST_REL_NIL</b></a>]  Theorem
      
      ⊢ (LIST_REL R [] y ⇔ y = []) ∧ (LIST_REL R x [] ⇔ x = [])
   
   [<a name="LIST_REL_O-val"><b>LIST_REL_O</b></a>]  Theorem
      
      ⊢ ∀R1 R2. LIST_REL (R1 ∘ᵣ R2) = LIST_REL R1 ∘ᵣ LIST_REL R2
   
   [<a name="LIST_REL_SNOC-val"><b>LIST_REL_SNOC</b></a>]  Theorem
      
      ⊢ (LIST_REL R (SNOC x xs) yys ⇔
         ∃y ys. yys = SNOC y ys ∧ LIST_REL R xs ys ∧ R x y) ∧
        (LIST_REL R xxs (SNOC y ys) ⇔
         ∃x xs. xxs = SNOC x xs ∧ LIST_REL R xs ys ∧ R x y)
   
   [<a name="LIST_REL_SPLIT1-val"><b>LIST_REL_SPLIT1</b></a>]  Theorem
      
      ⊢ ∀xs1 zs.
            LIST_REL P (xs1 ⧺ xs2) zs ⇔
            ∃ys1 ys2.
                zs = ys1 ⧺ ys2 ∧ LIST_REL P xs1 ys1 ∧ LIST_REL P xs2 ys2
   
   [<a name="LIST_REL_SPLIT2-val"><b>LIST_REL_SPLIT2</b></a>]  Theorem
      
      ⊢ ∀xs1 zs.
            LIST_REL P zs (xs1 ⧺ xs2) ⇔
            ∃ys1 ys2.
                zs = ys1 ⧺ ys2 ∧ LIST_REL P ys1 xs1 ∧ LIST_REL P ys2 xs2
   
   [<a name="LIST_REL_cases-val"><b>LIST_REL_cases</b></a>]  Theorem
      
      ⊢ ∀R a0 a1.
            LIST_REL R a0 a1 ⇔
            a0 = [] ∧ a1 = [] ∨
            ∃h1 h2 t1 t2.
                a0 = h1::t1 ∧ a1 = h2::t2 ∧ R h1 h2 ∧ LIST_REL R t1 t2
   
   [<a name="LIST_REL_def-val"><b>LIST_REL_def</b></a>]  Theorem
      
      ⊢ (LIST_REL R [] [] ⇔ T) ∧ (LIST_REL R (a::as) [] ⇔ F) ∧
        (LIST_REL R [] (b::bs) ⇔ F) ∧
        (LIST_REL R (a::as) (b::bs) ⇔ R a b ∧ LIST_REL R as bs)
   
   [<a name="LIST_REL_eq-val"><b>LIST_REL_eq</b></a>]  Theorem
      
      ⊢ LIST_REL $= = $=
   
   [<a name="LIST_REL_ind-val"><b>LIST_REL_ind</b></a>]  Theorem
      
      ⊢ ∀R LIST_REL'.
            LIST_REL' [] [] ∧
            (∀h1 h2 t1 t2.
                 R h1 h2 ∧ LIST_REL' t1 t2 ⇒ LIST_REL' (h1::t1) (h2::t2)) ⇒
            ∀a0 a1. LIST_REL R a0 a1 ⇒ LIST_REL' a0 a1
   
   [<a name="LIST_REL_mono-val"><b>LIST_REL_mono</b></a>]  Theorem
      
      ⊢ (∀x y. R1 x y ⇒ R2 x y) ⇒ LIST_REL R1 l1 l2 ⇒ LIST_REL R2 l1 l2
   
   [<a name="LIST_REL_rules-val"><b>LIST_REL_rules</b></a>]  Theorem
      
      ⊢ ∀R.
            LIST_REL R [] [] ∧
            ∀h1 h2 t1 t2.
                R h1 h2 ∧ LIST_REL R t1 t2 ⇒ LIST_REL R (h1::t1) (h2::t2)
   
   [<a name="LIST_REL_strongind-val"><b>LIST_REL_strongind</b></a>]  Theorem
      
      ⊢ ∀R LIST_REL'.
            LIST_REL' [] [] ∧
            (∀h1 h2 t1 t2.
                 R h1 h2 ∧ LIST_REL R t1 t2 ∧ LIST_REL' t1 t2 ⇒
                 LIST_REL' (h1::t1) (h2::t2)) ⇒
            ∀a0 a1. LIST_REL R a0 a1 ⇒ LIST_REL' a0 a1
   
   [<a name="LIST_REL_trans-val"><b>LIST_REL_trans</b></a>]  Theorem
      
      ⊢ ∀l1 l2 l3.
            (∀n.
                 n &lt; LENGTH l1 ∧ R (EL n l1) (EL n l2) ∧
                 R (EL n l2) (EL n l3) ⇒
                 R (EL n l1) (EL n l3)) ∧ LIST_REL R l1 l2 ∧
            LIST_REL R l2 l3 ⇒
            LIST_REL R l1 l3
   
   [<a name="LIST_TO_SET-val"><b>LIST_TO_SET</b></a>]  Theorem
      
      ⊢ set [] = ∅ ∧ set (h::t) = h INSERT set t
   
   [<a name="LIST_TO_SET_APPEND-val"><b>LIST_TO_SET_APPEND</b></a>]  Theorem
      
      ⊢ ∀l1 l2. set (l1 ⧺ l2) = set l1 ∪ set l2
   
   [<a name="LIST_TO_SET_EQ_EMPTY-val"><b>LIST_TO_SET_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ (set l = ∅ ⇔ l = []) ∧ (∅ = set l ⇔ l = [])
   
   [<a name="LIST_TO_SET_FILTER-val"><b>LIST_TO_SET_FILTER</b></a>]  Theorem
      
      ⊢ set (FILTER P l) = {x | P x} ∩ set l
   
   [<a name="LIST_TO_SET_FLAT-val"><b>LIST_TO_SET_FLAT</b></a>]  Theorem
      
      ⊢ ∀ls. set (FLAT ls) = BIGUNION (set (MAP set ls))
   
   [<a name="LIST_TO_SET_GENLIST-val"><b>LIST_TO_SET_GENLIST</b></a>]  Theorem
      
      ⊢ ∀f n. set (GENLIST f n) = IMAGE f (count n)
   
   [<a name="LIST_TO_SET_MAP-val"><b>LIST_TO_SET_MAP</b></a>]  Theorem
      
      ⊢ ∀f l. set (MAP f l) = IMAGE f (set l)
   
   [<a name="LIST_TO_SET_REVERSE-val"><b>LIST_TO_SET_REVERSE</b></a>]  Theorem
      
      ⊢ ∀ls. set (REVERSE ls) = set ls
   
   [<a name="LIST_TO_SET_SNOC-val"><b>LIST_TO_SET_SNOC</b></a>]  Theorem
      
      ⊢ set (SNOC x ls) = x INSERT set ls
   
   [<a name="LIST_TO_SET_THM-val"><b>LIST_TO_SET_THM</b></a>]  Theorem
      
      ⊢ set [] = ∅ ∧ set (h::t) = h INSERT set t
   
   [<a name="LLEX_CONG-val"><b>LLEX_CONG</b></a>]  Theorem
      
      ⊢ ∀R l1 l2 R' l1' l2'.
            l1 = l1' ∧ l2 = l2' ∧
            (∀a b. MEM a l1' ∧ MEM b l2' ⇒ (R a b ⇔ R' a b)) ⇒
            (LLEX R l1 l2 ⇔ LLEX R' l1' l2')
   
   [<a name="LLEX_EL_THM-val"><b>LLEX_EL_THM</b></a>]  Theorem
      
      ⊢ ∀R l1 l2.
            LLEX R l1 l2 ⇔
            ∃n.
                n ≤ LENGTH l1 ∧ n &lt; LENGTH l2 ∧ TAKE n l1 = TAKE n l2 ∧
                (n &lt; LENGTH l1 ⇒ R (EL n l1) (EL n l2))
   
   [<a name="LLEX_MONO-val"><b>LLEX_MONO</b></a>]  Theorem
      
      ⊢ (∀x y. R1 x y ⇒ R2 x y) ⇒ LLEX R1 x y ⇒ LLEX R2 x y
   
   [<a name="LLEX_NIL2-val"><b>LLEX_NIL2</b></a>]  Theorem
      
      ⊢ ¬LLEX R l []
   
   [<a name="LLEX_THM-val"><b>LLEX_THM</b></a>]  Theorem
      
      ⊢ (¬LLEX R [] [] ∧ ¬LLEX R (h1::t1) []) ∧ LLEX R [] (h2::t2) ∧
        (LLEX R (h1::t1) (h2::t2) ⇔ R h1 h2 ∨ h1 = h2 ∧ LLEX R t1 t2)
   
   [<a name="LLEX_not_WF-val"><b>LLEX_not_WF</b></a>]  Theorem
      
      ⊢ (∃a b. R a b) ⇒ ¬WF (LLEX R)
   
   [<a name="LLEX_total-val"><b>LLEX_total</b></a>]  Theorem
      
      ⊢ total (RC R) ⇒ total (RC (LLEX R))
   
   [<a name="LLEX_transitive-val"><b>LLEX_transitive</b></a>]  Theorem
      
      ⊢ transitive R ⇒ transitive (LLEX R)
   
   [<a name="LRC_MEM-val"><b>LRC_MEM</b></a>]  Theorem
      
      ⊢ LRC R ls x y ∧ MEM e ls ⇒ ∃z t. R e z ∧ LRC R t z y
   
   [<a name="LRC_MEM_right-val"><b>LRC_MEM_right</b></a>]  Theorem
      
      ⊢ LRC R (h::t) x y ∧ MEM e t ⇒ ∃z p. R z e ∧ LRC R p x z
   
   [<a name="LUPDATE_LENGTH-val"><b>LUPDATE_LENGTH</b></a>]  Theorem
      
      ⊢ ∀xs x y ys. LUPDATE x (LENGTH xs) (xs ⧺ y::ys) = xs ⧺ x::ys
   
   [<a name="LUPDATE_MAP-val"><b>LUPDATE_MAP</b></a>]  Theorem
      
      ⊢ ∀x n l f. MAP f (LUPDATE x n l) = LUPDATE (f x) n (MAP f l)
   
   [<a name="LUPDATE_NIL-val"><b>LUPDATE_NIL</b></a>]  Theorem
      
      ⊢ ∀xs n x. LUPDATE x n xs = [] ⇔ xs = []
   
   [<a name="LUPDATE_SAME-val"><b>LUPDATE_SAME</b></a>]  Theorem
      
      ⊢ ∀n ls. n &lt; LENGTH ls ⇒ LUPDATE (EL n ls) n ls = ls
   
   [<a name="LUPDATE_SEM-val"><b>LUPDATE_SEM</b></a>]  Theorem
      
      ⊢ (∀e n l. LENGTH (LUPDATE e n l) = LENGTH l) ∧
        ∀e n l p.
            p &lt; LENGTH l ⇒
            EL p (LUPDATE e n l) = if p = n then e else EL p l
   
   [<a name="LUPDATE_SNOC-val"><b>LUPDATE_SNOC</b></a>]  Theorem
      
      ⊢ ∀ys k x y.
            LUPDATE x k (SNOC y ys) =
            if k = LENGTH ys then SNOC x ys else SNOC y (LUPDATE x k ys)
   
   [<a name="LUPDATE_SOME_MAP-val"><b>LUPDATE_SOME_MAP</b></a>]  Theorem
      
      ⊢ ∀xs n f h.
            LUPDATE (SOME (f h)) n (MAP (OPTION_MAP f) xs) =
            MAP (OPTION_MAP f) (LUPDATE (SOME h) n xs)
   
   [<a name="LUPDATE_compute-val"><b>LUPDATE_compute</b></a>]  Theorem
      
      ⊢ (∀e n. LUPDATE e n [] = []) ∧ (∀e x l. LUPDATE e 0 (x::l) = e::l) ∧
        (∀e n x l.
             LUPDATE e (NUMERAL (BIT1 n)) (x::l) =
             x::LUPDATE e (NUMERAL (BIT1 n) − 1) l) ∧
        ∀e n x l.
            LUPDATE e (NUMERAL (BIT2 n)) (x::l) =
            x::LUPDATE e (NUMERAL (BIT1 n)) l
   
   [<a name="MAP2-val"><b>MAP2</b></a>]  Theorem
      
      ⊢ (∀f. MAP2 f [] [] = []) ∧
        ∀f h1 t1 h2 t2. MAP2 f (h1::t1) (h2::t2) = f h1 h2::MAP2 f t1 t2
   
   [<a name="MAP2_APPEND-val"><b>MAP2_APPEND</b></a>]  Theorem
      
      ⊢ ∀xs ys xs1 ys1 f.
            LENGTH xs = LENGTH xs1 ⇒
            MAP2 f (xs ⧺ ys) (xs1 ⧺ ys1) = MAP2 f xs xs1 ⧺ MAP2 f ys ys1
   
   [<a name="MAP2_CONG-val"><b>MAP2_CONG</b></a>]  Theorem
      
      ⊢ ∀l1 l1' l2 l2' f f'.
            l1 = l1' ∧ l2 = l2' ∧
            (∀x y. MEM x l1' ∧ MEM y l2' ⇒ f x y = f' x y) ⇒
            MAP2 f l1 l2 = MAP2 f' l1' l2'
   
   [<a name="MAP2_DEF-val"><b>MAP2_DEF</b></a>]  Theorem
      
      ⊢ (∀t2 t1 h2 h1 f. MAP2 f (h1::t1) (h2::t2) = f h1 h2::MAP2 f t1 t2) ∧
        (∀y f. MAP2 f [] y = []) ∧ ∀v5 v4 f. MAP2 f (v4::v5) [] = []
   
   [<a name="MAP2_MAP-val"><b>MAP2_MAP</b></a>]  Theorem
      
      ⊢ ∀l1 l2.
            LENGTH l1 = LENGTH l2 ⇒
            ∀f. MAP2 f l1 l2 = MAP (UNCURRY f) (ZIP (l1,l2))
   
   [<a name="MAP2_NIL-val"><b>MAP2_NIL</b></a>]  Theorem
      
      ⊢ MAP2 f x [] = []
   
   [<a name="MAP2_ZIP-val"><b>MAP2_ZIP</b></a>]  Theorem
      
      ⊢ ∀l1 l2.
            LENGTH l1 = LENGTH l2 ⇒
            ∀f. MAP2 f l1 l2 = MAP (UNCURRY f) (ZIP (l1,l2))
   
   [<a name="MAP2_ind-val"><b>MAP2_ind</b></a>]  Theorem
      
      ⊢ ∀P.
            (∀f h1 t1 h2 t2. P f t1 t2 ⇒ P f (h1::t1) (h2::t2)) ∧
            (∀f y. P f [] y) ∧ (∀f v4 v5. P f (v4::v5) []) ⇒
            ∀v v1 v2. P v v1 v2
   
   [<a name="MAP_APPEND-val"><b>MAP_APPEND</b></a>]  Theorem
      
      ⊢ ∀f l1 l2. MAP f (l1 ⧺ l2) = MAP f l1 ⧺ MAP f l2
   
   [<a name="MAP_APPEND_MAP_EQ-val"><b>MAP_APPEND_MAP_EQ</b></a>]  Theorem
      
      ⊢ ∀xs ys.
            MAP f1 xs ⧺ MAP g1 ys = MAP f2 xs ⧺ MAP g2 ys ⇔
            MAP f1 xs = MAP f2 xs ∧ MAP g1 ys = MAP g2 ys
   
   [<a name="MAP_CONG-val"><b>MAP_CONG</b></a>]  Theorem
      
      ⊢ ∀l1 l2 f f'.
            l1 = l2 ∧ (∀x. MEM x l2 ⇒ f x = f' x) ⇒ MAP f l1 = MAP f' l2
   
   [<a name="MAP_DROP-val"><b>MAP_DROP</b></a>]  Theorem
      
      ⊢ ∀l i. MAP f (DROP i l) = DROP i (MAP f l)
   
   [<a name="MAP_EQ_APPEND-val"><b>MAP_EQ_APPEND</b></a>]  Theorem
      
      ⊢ MAP f l = l1 ⧺ l2 ⇔
        ∃l10 l20. l = l10 ⧺ l20 ∧ l1 = MAP f l10 ∧ l2 = MAP f l20
   
   [<a name="MAP_EQ_CONS-val"><b>MAP_EQ_CONS</b></a>]  Theorem
      
      ⊢ MAP f l = h::t ⇔ ∃x0 t0. l = x0::t0 ∧ h = f x0 ∧ t = MAP f t0
   
   [<a name="MAP_EQ_EVERY2-val"><b>MAP_EQ_EVERY2</b></a>]  Theorem
      
      ⊢ ∀f1 f2 l1 l2.
            MAP f1 l1 = MAP f2 l2 ⇔
            LENGTH l1 = LENGTH l2 ∧ LIST_REL (λx y. f1 x = f2 y) l1 l2
   
   [<a name="MAP_EQ_NIL-val"><b>MAP_EQ_NIL</b></a>]  Theorem
      
      ⊢ ∀l f. (MAP f l = [] ⇔ l = []) ∧ ([] = MAP f l ⇔ l = [])
   
   [<a name="MAP_EQ_SING-val"><b>MAP_EQ_SING</b></a>]  Theorem
      
      ⊢ MAP f l = [x] ⇔ ∃x0. l = [x0] ∧ x = f x0
   
   [<a name="MAP_EQ_f-val"><b>MAP_EQ_f</b></a>]  Theorem
      
      ⊢ ∀f1 f2 l. MAP f1 l = MAP f2 l ⇔ ∀e. MEM e l ⇒ f1 e = f2 e
   
   [<a name="MAP_FLAT-val"><b>MAP_FLAT</b></a>]  Theorem
      
      ⊢ MAP f (FLAT l) = FLAT (MAP (MAP f) l)
   
   [<a name="MAP_FRONT-val"><b>MAP_FRONT</b></a>]  Theorem
      
      ⊢ ∀ls. ls ≠ [] ⇒ MAP f (FRONT ls) = FRONT (MAP f ls)
   
   [<a name="MAP_GENLIST-val"><b>MAP_GENLIST</b></a>]  Theorem
      
      ⊢ ∀f g n. MAP f (GENLIST g n) = GENLIST (f ∘ g) n
   
   [<a name="MAP_ID-val"><b>MAP_ID</b></a>]  Theorem
      
      ⊢ MAP (λx. x) l = l ∧ MAP I l = l
   
   [<a name="MAP_LIST_BIND-val"><b>MAP_LIST_BIND</b></a>]  Theorem
      
      ⊢ MAP f (LIST_BIND l g) = LIST_BIND l (MAP f ∘ g)
   
   [<a name="MAP_MAP_o-val"><b>MAP_MAP_o</b></a>]  Theorem
      
      ⊢ ∀f g l. MAP f (MAP g l) = MAP (f ∘ g) l
   
   [<a name="MAP_SNOC-val"><b>MAP_SNOC</b></a>]  Theorem
      
      ⊢ ∀f x l. MAP f (SNOC x l) = SNOC (f x) (MAP f l)
   
   [<a name="MAP_TAKE-val"><b>MAP_TAKE</b></a>]  Theorem
      
      ⊢ ∀f n l. MAP f (TAKE n l) = TAKE n (MAP f l)
   
   [<a name="MAP_TL-val"><b>MAP_TL</b></a>]  Theorem
      
      ⊢ ∀l f. ¬NULL l ⇒ MAP f (TL l) = TL (MAP f l)
   
   [<a name="MAP_ZIP-val"><b>MAP_ZIP</b></a>]  Theorem
      
      ⊢ LENGTH l1 = LENGTH l2 ⇒
        MAP FST (ZIP (l1,l2)) = l1 ∧ MAP SND (ZIP (l1,l2)) = l2 ∧
        MAP (f ∘ FST) (ZIP (l1,l2)) = MAP f l1 ∧
        MAP (g ∘ SND) (ZIP (l1,l2)) = MAP g l2
   
   [<a name="MAP_ZIP_SAME-val"><b>MAP_ZIP_SAME</b></a>]  Theorem
      
      ⊢ ∀ls f. MAP f (ZIP (ls,ls)) = MAP (λx. f (x,x)) ls
   
   [<a name="MAP_o-val"><b>MAP_o</b></a>]  Theorem
      
      ⊢ ∀f g. MAP (f ∘ g) = MAP f ∘ MAP g
   
   [<a name="MEM-val"><b>MEM</b></a>]  Theorem
      
      ⊢ (∀x. MEM x [] ⇔ F) ∧ ∀x h t. MEM x (h::t) ⇔ x = h ∨ MEM x t
   
   [<a name="MEM_APPEND-val"><b>MEM_APPEND</b></a>]  Theorem
      
      ⊢ ∀e l1 l2. MEM e (l1 ⧺ l2) ⇔ MEM e l1 ∨ MEM e l2
   
   [<a name="MEM_APPEND_lemma-val"><b>MEM_APPEND_lemma</b></a>]  Theorem
      
      ⊢ ∀a b c d x.
            a ⧺ [x] ⧺ b = c ⧺ [x] ⧺ d ∧ ¬MEM x b ∧ ¬MEM x a ⇒ a = c ∧ b = d
   
   [<a name="MEM_DROP-val"><b>MEM_DROP</b></a>]  Theorem
      
      ⊢ ∀x ls n.
            MEM x (DROP n ls) ⇔ ∃m. m + n &lt; LENGTH ls ∧ x = EL (m + n) ls
   
   [<a name="MEM_EL-val"><b>MEM_EL</b></a>]  Theorem
      
      ⊢ ∀l x. MEM x l ⇔ ∃n. n &lt; LENGTH l ∧ x = EL n l
   
   [<a name="MEM_FILTER-val"><b>MEM_FILTER</b></a>]  Theorem
      
      ⊢ ∀P L x. MEM x (FILTER P L) ⇔ P x ∧ MEM x L
   
   [<a name="MEM_FLAT-val"><b>MEM_FLAT</b></a>]  Theorem
      
      ⊢ ∀x L. MEM x (FLAT L) ⇔ ∃l. MEM l L ∧ MEM x l
   
   [<a name="MEM_GENLIST-val"><b>MEM_GENLIST</b></a>]  Theorem
      
      ⊢ MEM x (GENLIST f n) ⇔ ∃m. m &lt; n ∧ x = f m
   
   [<a name="MEM_LUPDATE-val"><b>MEM_LUPDATE</b></a>]  Theorem
      
      ⊢ ∀l x y i.
            MEM x (LUPDATE y i l) ⇔
            i &lt; LENGTH l ∧ x = y ∨ ∃j. j &lt; LENGTH l ∧ i ≠ j ∧ EL j l = x
   
   [<a name="MEM_LUPDATE_E-val"><b>MEM_LUPDATE_E</b></a>]  Theorem
      
      ⊢ ∀l x y i. MEM x (LUPDATE y i l) ⇒ x = y ∨ MEM x l
   
   [<a name="MEM_MAP-val"><b>MEM_MAP</b></a>]  Theorem
      
      ⊢ ∀l f x. MEM x (MAP f l) ⇔ ∃y. x = f y ∧ MEM y l
   
   [<a name="MEM_REVERSE-val"><b>MEM_REVERSE</b></a>]  Theorem
      
      ⊢ ∀l x. MEM x (REVERSE l) ⇔ MEM x l
   
   [<a name="MEM_SET_TO_LIST-val"><b>MEM_SET_TO_LIST</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀x. MEM x (SET_TO_LIST s) ⇔ x ∈ s
   
   [<a name="MEM_SNOC-val"><b>MEM_SNOC</b></a>]  Theorem
      
      ⊢ ∀y x l. MEM y (SNOC x l) ⇔ y = x ∨ MEM y l
   
   [<a name="MEM_SPLIT-val"><b>MEM_SPLIT</b></a>]  Theorem
      
      ⊢ ∀x l. MEM x l ⇔ ∃l1 l2. l = l1 ⧺ x::l2
   
   [<a name="MEM_SPLIT_APPEND_first-val"><b>MEM_SPLIT_APPEND_first</b></a>]  Theorem
      
      ⊢ MEM e l ⇔ ∃pfx sfx. l = pfx ⧺ [e] ⧺ sfx ∧ ¬MEM e pfx
   
   [<a name="MEM_SPLIT_APPEND_last-val"><b>MEM_SPLIT_APPEND_last</b></a>]  Theorem
      
      ⊢ MEM e l ⇔ ∃pfx sfx. l = pfx ⧺ [e] ⧺ sfx ∧ ¬MEM e sfx
   
   [<a name="MEM_ZIP-val"><b>MEM_ZIP</b></a>]  Theorem
      
      ⊢ ∀l1 l2 p.
            LENGTH l1 = LENGTH l2 ⇒
            (MEM p (ZIP (l1,l2)) ⇔
             ∃n. n &lt; LENGTH l1 ∧ p = (EL n l1,EL n l2))
   
   [<a name="MEM_ZIP_MEM_MAP-val"><b>MEM_ZIP_MEM_MAP</b></a>]  Theorem
      
      ⊢ LENGTH (FST ps) = LENGTH (SND ps) ∧ MEM p (ZIP ps) ⇒
        MEM (FST p) (FST ps) ∧ MEM (SND p) (SND ps)
   
   [<a name="MEM_dropWhile_IMP-val"><b>MEM_dropWhile_IMP</b></a>]  Theorem
      
      ⊢ ∀P ls x. MEM x (dropWhile P ls) ⇒ MEM x ls
   
   [<a name="MONO_EVERY-val"><b>MONO_EVERY</b></a>]  Theorem
      
      ⊢ (∀x. P x ⇒ Q x) ⇒ EVERY P l ⇒ EVERY Q l
   
   [<a name="MONO_EXISTS-val"><b>MONO_EXISTS</b></a>]  Theorem
      
      ⊢ (∀x. P x ⇒ Q x) ⇒ EXISTS P l ⇒ EXISTS Q l
   
   [<a name="NOT_CONS_NIL-val"><b>NOT_CONS_NIL</b></a>]  Theorem
      
      ⊢ ∀a1 a0. a0::a1 ≠ []
   
   [<a name="NOT_EQ_LIST-val"><b>NOT_EQ_LIST</b></a>]  Theorem
      
      ⊢ ∀h1 h2. h1 ≠ h2 ⇒ ∀l1 l2. h1::l1 ≠ h2::l2
   
   [<a name="NOT_EVERY-val"><b>NOT_EVERY</b></a>]  Theorem
      
      ⊢ ∀P l. ¬EVERY P l ⇔ EXISTS ($~ ∘ P) l
   
   [<a name="NOT_EXISTS-val"><b>NOT_EXISTS</b></a>]  Theorem
      
      ⊢ ∀P l. ¬EXISTS P l ⇔ EVERY ($~ ∘ P) l
   
   [<a name="NOT_NIL_CONS-val"><b>NOT_NIL_CONS</b></a>]  Theorem
      
      ⊢ ∀a1 a0. [] ≠ a0::a1
   
   [<a name="NOT_NIL_EQ_LENGTH_NOT_0-val"><b>NOT_NIL_EQ_LENGTH_NOT_0</b></a>]  Theorem
      
      ⊢ x ≠ [] ⇔ 0 &lt; LENGTH x
   
   [<a name="NOT_NULL_MEM-val"><b>NOT_NULL_MEM</b></a>]  Theorem
      
      ⊢ ∀l. ¬NULL l ⇔ ∃e. MEM e l
   
   [<a name="NRC_LRC-val"><b>NRC_LRC</b></a>]  Theorem
      
      ⊢ NRC R n x y ⇔ ∃ls. LRC R ls x y ∧ LENGTH ls = n
   
   [<a name="NULL-val"><b>NULL</b></a>]  Theorem
      
      ⊢ NULL [] ∧ ∀h t. ¬NULL (h::t)
   
   [<a name="NULL_APPEND-val"><b>NULL_APPEND</b></a>]  Theorem
      
      ⊢ NULL (l1 ⧺ l2) ⇔ NULL l1 ∧ NULL l2
   
   [<a name="NULL_EQ-val"><b>NULL_EQ</b></a>]  Theorem
      
      ⊢ ∀l. NULL l ⇔ l = []
   
   [<a name="NULL_FILTER-val"><b>NULL_FILTER</b></a>]  Theorem
      
      ⊢ ∀P ls. NULL (FILTER P ls) ⇔ ∀x. MEM x ls ⇒ ¬P x
   
   [<a name="NULL_GENLIST-val"><b>NULL_GENLIST</b></a>]  Theorem
      
      ⊢ ∀n f. NULL (GENLIST f n) ⇔ n = 0
   
   [<a name="NULL_LENGTH-val"><b>NULL_LENGTH</b></a>]  Theorem
      
      ⊢ ∀l. NULL l ⇔ LENGTH l = 0
   
   [<a name="OPT_MMAP_cong-val"><b>OPT_MMAP_cong</b></a>]  Theorem
      
      ⊢ ∀f1 f2 x1 x2.
            x1 = x2 ∧ (∀a. MEM a x2 ⇒ f1 a = f2 a) ⇒
            OPT_MMAP f1 x1 = OPT_MMAP f2 x2
   
   [<a name="REVERSE_11-val"><b>REVERSE_11</b></a>]  Theorem
      
      ⊢ ∀l1 l2. REVERSE l1 = REVERSE l2 ⇔ l1 = l2
   
   [<a name="REVERSE_APPEND-val"><b>REVERSE_APPEND</b></a>]  Theorem
      
      ⊢ ∀l1 l2. REVERSE (l1 ⧺ l2) = REVERSE l2 ⧺ REVERSE l1
   
   [<a name="REVERSE_EQ_NIL-val"><b>REVERSE_EQ_NIL</b></a>]  Theorem
      
      ⊢ REVERSE l = [] ⇔ l = []
   
   [<a name="REVERSE_EQ_SING-val"><b>REVERSE_EQ_SING</b></a>]  Theorem
      
      ⊢ REVERSE l = [e] ⇔ l = [e]
   
   [<a name="REVERSE_GENLIST-val"><b>REVERSE_GENLIST</b></a>]  Theorem
      
      ⊢ REVERSE (GENLIST f n) = GENLIST (λm. f (PRE n − m)) n
   
   [<a name="REVERSE_REV-val"><b>REVERSE_REV</b></a>]  Theorem
      
      ⊢ ∀L. REVERSE L = REV L []
   
   [<a name="REVERSE_REVERSE-val"><b>REVERSE_REVERSE</b></a>]  Theorem
      
      ⊢ ∀l. REVERSE (REVERSE l) = l
   
   [<a name="REVERSE_SNOC-val"><b>REVERSE_SNOC</b></a>]  Theorem
      
      ⊢ ∀x l. REVERSE (SNOC x l) = x::REVERSE l
   
   [<a name="REVERSE_SNOC_DEF-val"><b>REVERSE_SNOC_DEF</b></a>]  Theorem
      
      ⊢ REVERSE [] = [] ∧ ∀x l. REVERSE (x::l) = SNOC x (REVERSE l)
   
   [<a name="REVERSE_o_REVERSE-val"><b>REVERSE_o_REVERSE</b></a>]  Theorem
      
      ⊢ REVERSE ∘ REVERSE ∘ f = f
   
   [<a name="REV_REVERSE_LEM-val"><b>REV_REVERSE_LEM</b></a>]  Theorem
      
      ⊢ ∀L1 L2. REV L1 L2 = REVERSE L1 ⧺ L2
   
   [<a name="SET_TO_LIST_CARD-val"><b>SET_TO_LIST_CARD</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ LENGTH (SET_TO_LIST s) = CARD s
   
   [<a name="SET_TO_LIST_EMPTY-val"><b>SET_TO_LIST_EMPTY</b></a>]  Theorem
      
      ⊢ SET_TO_LIST ∅ = []
   
   [<a name="SET_TO_LIST_IND-val"><b>SET_TO_LIST_IND</b></a>]  Theorem
      
      ⊢ ∀P. (∀s. (FINITE s ∧ s ≠ ∅ ⇒ P (REST s)) ⇒ P s) ⇒ ∀v. P v
   
   [<a name="SET_TO_LIST_INV-val"><b>SET_TO_LIST_INV</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ set (SET_TO_LIST s) = s
   
   [<a name="SET_TO_LIST_IN_MEM-val"><b>SET_TO_LIST_IN_MEM</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀x. x ∈ s ⇔ MEM x (SET_TO_LIST s)
   
   [<a name="SET_TO_LIST_SING-val"><b>SET_TO_LIST_SING</b></a>]  Theorem
      
      ⊢ SET_TO_LIST {x} = [x]
   
   [<a name="SET_TO_LIST_THM-val"><b>SET_TO_LIST_THM</b></a>]  Theorem
      
      ⊢ FINITE s ⇒
        SET_TO_LIST s =
        if s = ∅ then [] else CHOICE s::SET_TO_LIST (REST s)
   
   [<a name="SHORTLEX_LENGTH_LE-val"><b>SHORTLEX_LENGTH_LE</b></a>]  Theorem
      
      ⊢ ∀l1 l2. SHORTLEX R l1 l2 ⇒ LENGTH l1 ≤ LENGTH l2
   
   [<a name="SHORTLEX_MONO-val"><b>SHORTLEX_MONO</b></a>]  Theorem
      
      ⊢ (∀x y. R1 x y ⇒ R2 x y) ⇒ SHORTLEX R1 x y ⇒ SHORTLEX R2 x y
   
   [<a name="SHORTLEX_NIL2-val"><b>SHORTLEX_NIL2</b></a>]  Theorem
      
      ⊢ ¬SHORTLEX R l []
   
   [<a name="SHORTLEX_THM-val"><b>SHORTLEX_THM</b></a>]  Theorem
      
      ⊢ (¬SHORTLEX R [] [] ∧ ¬SHORTLEX R (h1::t1) []) ∧
        SHORTLEX R [] (h2::t2) ∧
        (SHORTLEX R (h1::t1) (h2::t2) ⇔
         LENGTH t1 &lt; LENGTH t2 ∨
         LENGTH t1 = LENGTH t2 ∧ (R h1 h2 ∨ h1 = h2 ∧ SHORTLEX R t1 t2))
   
   [<a name="SHORTLEX_total-val"><b>SHORTLEX_total</b></a>]  Theorem
      
      ⊢ total (RC R) ⇒ total (RC (SHORTLEX R))
   
   [<a name="SHORTLEX_transitive-val"><b>SHORTLEX_transitive</b></a>]  Theorem
      
      ⊢ transitive R ⇒ transitive (SHORTLEX R)
   
   [<a name="SINGL_APPLY_MAP-val"><b>SINGL_APPLY_MAP</b></a>]  Theorem
      
      ⊢ [f] &lt;*&gt; l = MAP f l
   
   [<a name="SINGL_APPLY_PERMUTE-val"><b>SINGL_APPLY_PERMUTE</b></a>]  Theorem
      
      ⊢ fs &lt;*&gt; [x] = [(λf. f x)] &lt;*&gt; fs
   
   [<a name="SINGL_LIST_APPLY_L-val"><b>SINGL_LIST_APPLY_L</b></a>]  Theorem
      
      ⊢ LIST_BIND [x] f = f x
   
   [<a name="SINGL_LIST_APPLY_R-val"><b>SINGL_LIST_APPLY_R</b></a>]  Theorem
      
      ⊢ LIST_BIND l (λx. [x]) = l
   
   [<a name="SINGL_SINGL_APPLY-val"><b>SINGL_SINGL_APPLY</b></a>]  Theorem
      
      ⊢ [f] &lt;*&gt; [x] = [f x]
   
   [<a name="SING_HD-val"><b>SING_HD</b></a>]  Theorem
      
      ⊢ ([HD xs] = xs ⇔ LENGTH xs = 1) ∧ (xs = [HD xs] ⇔ LENGTH xs = 1)
   
   [<a name="SNOC_11-val"><b>SNOC_11</b></a>]  Theorem
      
      ⊢ ∀x y a b. SNOC x y = SNOC a b ⇔ x = a ∧ y = b
   
   [<a name="SNOC_APPEND-val"><b>SNOC_APPEND</b></a>]  Theorem
      
      ⊢ ∀x l. SNOC x l = l ⧺ [x]
   
   [<a name="SNOC_Axiom-val"><b>SNOC_Axiom</b></a>]  Theorem
      
      ⊢ ∀e f. ∃fn. fn [] = e ∧ ∀x l. fn (SNOC x l) = f x l (fn l)
   
   [<a name="SNOC_CASES-val"><b>SNOC_CASES</b></a>]  Theorem
      
      ⊢ ∀ll. ll = [] ∨ ∃x l. ll = SNOC x l
   
   [<a name="SNOC_INDUCT-val"><b>SNOC_INDUCT</b></a>]  Theorem
      
      ⊢ ∀P. P [] ∧ (∀l. P l ⇒ ∀x. P (SNOC x l)) ⇒ ∀l. P l
   
   [<a name="SUM_ACC_SUM_LEM-val"><b>SUM_ACC_SUM_LEM</b></a>]  Theorem
      
      ⊢ ∀L n. SUM_ACC L n = SUM L + n
   
   [<a name="SUM_APPEND-val"><b>SUM_APPEND</b></a>]  Theorem
      
      ⊢ ∀l1 l2. SUM (l1 ⧺ l2) = SUM l1 + SUM l2
   
   [<a name="SUM_IMAGE_LIST_TO_SET_upper_bound-val"><b>SUM_IMAGE_LIST_TO_SET_upper_bound</b></a>]  Theorem
      
      ⊢ ∀ls. ∑ f (set ls) ≤ SUM (MAP f ls)
   
   [<a name="SUM_IMAGE_eq_SUM_MAP_SET_TO_LIST-val"><b>SUM_IMAGE_eq_SUM_MAP_SET_TO_LIST</b></a>]  Theorem
      
      ⊢ FINITE s ⇒ ∑ f s = SUM (MAP f (SET_TO_LIST s))
   
   [<a name="SUM_MAP_FOLDL-val"><b>SUM_MAP_FOLDL</b></a>]  Theorem
      
      ⊢ ∀ls. SUM (MAP f ls) = FOLDL (λa e. a + f e) 0 ls
   
   [<a name="SUM_MAP_MEM_bound-val"><b>SUM_MAP_MEM_bound</b></a>]  Theorem
      
      ⊢ ∀f x ls. MEM x ls ⇒ f x ≤ SUM (MAP f ls)
   
   [<a name="SUM_MAP_PLUS-val"><b>SUM_MAP_PLUS</b></a>]  Theorem
      
      ⊢ ∀f g ls.
            SUM (MAP (λx. f x + g x) ls) = SUM (MAP f ls) + SUM (MAP g ls)
   
   [<a name="SUM_MAP_PLUS_ZIP-val"><b>SUM_MAP_PLUS_ZIP</b></a>]  Theorem
      
      ⊢ ∀ls1 ls2.
            LENGTH ls1 = LENGTH ls2 ∧ (∀x y. f (x,y) = g x + h y) ⇒
            SUM (MAP f (ZIP (ls1,ls2))) = SUM (MAP g ls1) + SUM (MAP h ls2)
   
   [<a name="SUM_SNOC-val"><b>SUM_SNOC</b></a>]  Theorem
      
      ⊢ ∀x l. SUM (SNOC x l) = SUM l + x
   
   [<a name="SUM_SUM_ACC-val"><b>SUM_SUM_ACC</b></a>]  Theorem
      
      ⊢ ∀L. SUM L = SUM_ACC L 0
   
   [<a name="SUM_eq_0-val"><b>SUM_eq_0</b></a>]  Theorem
      
      ⊢ ∀ls. SUM ls = 0 ⇔ ∀x. MEM x ls ⇒ x = 0
   
   [<a name="SWAP_REVERSE-val"><b>SWAP_REVERSE</b></a>]  Theorem
      
      ⊢ ∀l1 l2. l1 = REVERSE l2 ⇔ l2 = REVERSE l1
   
   [<a name="SWAP_REVERSE_SYM-val"><b>SWAP_REVERSE_SYM</b></a>]  Theorem
      
      ⊢ ∀l1 l2. REVERSE l1 = l2 ⇔ l1 = REVERSE l2
   
   [<a name="TAKE1-val"><b>TAKE1</b></a>]  Theorem
      
      ⊢ ∀l. l ≠ [] ⇒ TAKE 1 l = [EL 0 l]
   
   [<a name="TAKE1_DROP-val"><b>TAKE1_DROP</b></a>]  Theorem
      
      ⊢ ∀n l. n &lt; LENGTH l ⇒ TAKE 1 (DROP n l) = [EL n l]
   
   [<a name="TAKE_0-val"><b>TAKE_0</b></a>]  Theorem
      
      ⊢ TAKE 0 l = []
   
   [<a name="TAKE_APPEND1-val"><b>TAKE_APPEND1</b></a>]  Theorem
      
      ⊢ ∀n. n ≤ LENGTH l1 ⇒ TAKE n (l1 ⧺ l2) = TAKE n l1
   
   [<a name="TAKE_APPEND2-val"><b>TAKE_APPEND2</b></a>]  Theorem
      
      ⊢ ∀n. LENGTH l1 &lt; n ⇒ TAKE n (l1 ⧺ l2) = l1 ⧺ TAKE (n − LENGTH l1) l2
   
   [<a name="TAKE_DROP-val"><b>TAKE_DROP</b></a>]  Theorem
      
      ⊢ ∀n l. TAKE n l ⧺ DROP n l = l
   
   [<a name="TAKE_EQ_NIL-val"><b>TAKE_EQ_NIL</b></a>]  Theorem
      
      ⊢ TAKE n l = [] ⇔ n = 0 ∨ l = []
   
   [<a name="TAKE_GENLIST-val"><b>TAKE_GENLIST</b></a>]  Theorem
      
      ⊢ TAKE n (GENLIST f m) = GENLIST f (MIN n m)
   
   [<a name="TAKE_LENGTH_ID-val"><b>TAKE_LENGTH_ID</b></a>]  Theorem
      
      ⊢ ∀l. TAKE (LENGTH l) l = l
   
   [<a name="TAKE_LENGTH_ID_rwt-val"><b>TAKE_LENGTH_ID_rwt</b></a>]  Theorem
      
      ⊢ ∀l m. m = LENGTH l ⇒ TAKE m l = l
   
   [<a name="TAKE_LENGTH_TOO_LONG-val"><b>TAKE_LENGTH_TOO_LONG</b></a>]  Theorem
      
      ⊢ ∀l n. LENGTH l ≤ n ⇒ TAKE n l = l
   
   [<a name="TAKE_SUM-val"><b>TAKE_SUM</b></a>]  Theorem
      
      ⊢ ∀n m l. TAKE (n + m) l = TAKE n l ⧺ TAKE m (DROP n l)
   
   [<a name="TAKE_TAKE_MIN-val"><b>TAKE_TAKE_MIN</b></a>]  Theorem
      
      ⊢ ∀m n. TAKE n (TAKE m l) = TAKE (MIN n m) l
   
   [<a name="TAKE_compute-val"><b>TAKE_compute</b></a>]  Theorem
      
      ⊢ (∀l. TAKE 0 l = []) ∧ (∀n. TAKE (NUMERAL (BIT1 n)) [] = []) ∧
        (∀n. TAKE (NUMERAL (BIT2 n)) [] = []) ∧
        (∀n h t.
             TAKE (NUMERAL (BIT1 n)) (h::t) =
             h::TAKE (NUMERAL (BIT1 n) − 1) t) ∧
        ∀n h t.
            TAKE (NUMERAL (BIT2 n)) (h::t) = h::TAKE (NUMERAL (BIT1 n)) t
   
   [<a name="TAKE_cons-val"><b>TAKE_cons</b></a>]  Theorem
      
      ⊢ 0 &lt; n ⇒ TAKE n (x::xs) = x::TAKE (n − 1) xs
   
   [<a name="TAKE_nil-val"><b>TAKE_nil</b></a>]  Theorem
      
      ⊢ ∀n. TAKE n [] = []
   
   [<a name="TAKE_splitAtPki-val"><b>TAKE_splitAtPki</b></a>]  Theorem
      
      ⊢ TAKE n l = splitAtPki (K ∘ $= n) K l
   
   [<a name="TL-val"><b>TL</b></a>]  Theorem
      
      ⊢ ∀h t. TL (h::t) = t
   
   [<a name="TL_GENLIST-val"><b>TL_GENLIST</b></a>]  Theorem
      
      ⊢ ∀f n. TL (GENLIST f (SUC n)) = GENLIST (f ∘ SUC) n
   
   [<a name="UNION_APPEND-val"><b>UNION_APPEND</b></a>]  Theorem
      
      ⊢ ∀l1 l2. set l1 ∪ set l2 = set (l1 ⧺ l2)
   
   [<a name="UNIQUE_FILTER-val"><b>UNIQUE_FILTER</b></a>]  Theorem
      
      ⊢ ∀e L. UNIQUE e L ⇔ FILTER ($= e) L = [e]
   
   [<a name="UNIQUE_LENGTH_FILTER-val"><b>UNIQUE_LENGTH_FILTER</b></a>]  Theorem
      
      ⊢ ∀e L. UNIQUE e L ⇔ LENGTH (FILTER ($= e) L) = 1
   
   [<a name="UNZIP_MAP-val"><b>UNZIP_MAP</b></a>]  Theorem
      
      ⊢ ∀L. UNZIP L = (MAP FST L,MAP SND L)
   
   [<a name="UNZIP_THM-val"><b>UNZIP_THM</b></a>]  Theorem
      
      ⊢ UNZIP [] = ([],[]) ∧
        UNZIP ((x,y)::t) = (let (L1,L2) = UNZIP t in (x::L1,y::L2))
   
   [<a name="UNZIP_ZIP-val"><b>UNZIP_ZIP</b></a>]  Theorem
      
      ⊢ ∀l1 l2. LENGTH l1 = LENGTH l2 ⇒ UNZIP (ZIP (l1,l2)) = (l1,l2)
   
   [<a name="WF_LIST_PRED-val"><b>WF_LIST_PRED</b></a>]  Theorem
      
      ⊢ WF (λL1 L2. ∃h. L2 = h::L1)
   
   [<a name="WF_SHORTLEX-val"><b>WF_SHORTLEX</b></a>]  Theorem
      
      ⊢ WF R ⇒ WF (SHORTLEX R)
   
   [<a name="WF_SHORTLEX_same_lengths-val"><b>WF_SHORTLEX_same_lengths</b></a>]  Theorem
      
      ⊢ WF R ⇒
        ∀l s.
            (∀d. d ∈ s ⇒ LENGTH d = l) ∧ (∃a. a ∈ s) ⇒
            ∃b. b ∈ s ∧ ∀c. SHORTLEX R c b ⇒ c ∉ s
   
   [<a name="ZIP-val"><b>ZIP</b></a>]  Theorem
      
      ⊢ ZIP ([],[]) = [] ∧
        ∀x1 l1 x2 l2. ZIP (x1::l1,x2::l2) = (x1,x2)::ZIP (l1,l2)
   
   [<a name="ZIP_DROP-val"><b>ZIP_DROP</b></a>]  Theorem
      
      ⊢ ∀a b n.
            n ≤ LENGTH a ∧ LENGTH a = LENGTH b ⇒
            ZIP (DROP n a,DROP n b) = DROP n (ZIP (a,b))
   
   [<a name="ZIP_EQ_NIL-val"><b>ZIP_EQ_NIL</b></a>]  Theorem
      
      ⊢ ∀l1 l2.
            LENGTH l1 = LENGTH l2 ⇒ (ZIP (l1,l2) = [] ⇔ l1 = [] ∧ l2 = [])
   
   [<a name="ZIP_GENLIST-val"><b>ZIP_GENLIST</b></a>]  Theorem
      
      ⊢ ∀l f n.
            LENGTH l = n ⇒
            ZIP (l,GENLIST f n) = GENLIST (λx. (EL x l,f x)) n
   
   [<a name="ZIP_MAP-val"><b>ZIP_MAP</b></a>]  Theorem
      
      ⊢ ∀l1 l2 f1 f2.
            LENGTH l1 = LENGTH l2 ⇒
            ZIP (MAP f1 l1,l2) = MAP (λp. (f1 (FST p),SND p)) (ZIP (l1,l2)) ∧
            ZIP (l1,MAP f2 l2) = MAP (λp. (FST p,f2 (SND p))) (ZIP (l1,l2))
   
   [<a name="ZIP_UNZIP-val"><b>ZIP_UNZIP</b></a>]  Theorem
      
      ⊢ ∀l. ZIP (UNZIP l) = l
   
   [<a name="all_distinct_nub-val"><b>all_distinct_nub</b></a>]  Theorem
      
      ⊢ ∀l. ALL_DISTINCT (nub l)
   
   [<a name="datatype_list-val"><b>datatype_list</b></a>]  Theorem
      
      ⊢ DATATYPE (list [] CONS)
   
   [<a name="dropWhile_APPEND_EVERY-val"><b>dropWhile_APPEND_EVERY</b></a>]  Theorem
      
      ⊢ ∀P l1 l2. EVERY P l1 ⇒ dropWhile P (l1 ⧺ l2) = dropWhile P l2
   
   [<a name="dropWhile_APPEND_EXISTS-val"><b>dropWhile_APPEND_EXISTS</b></a>]  Theorem
      
      ⊢ ∀P l1 l2.
            EXISTS ($~ ∘ P) l1 ⇒
            dropWhile P (l1 ⧺ l2) = dropWhile P l1 ⧺ l2
   
   [<a name="dropWhile_eq_nil-val"><b>dropWhile_eq_nil</b></a>]  Theorem
      
      ⊢ ∀P ls. dropWhile P ls = [] ⇔ EVERY P ls
   
   [<a name="dropWhile_splitAtPki-val"><b>dropWhile_splitAtPki</b></a>]  Theorem
      
      ⊢ ∀P. dropWhile P = splitAtPki (combin$C (K ∘ $~ ∘ P)) (K I)
   
   [<a name="el_append3-val"><b>el_append3</b></a>]  Theorem
      
      ⊢ ∀l1 x l2. EL (LENGTH l1) (l1 ⧺ [x] ⧺ l2) = x
   
   [<a name="every_zip_fst-val"><b>every_zip_fst</b></a>]  Theorem
      
      ⊢ ∀l1 l2 P.
            LENGTH l1 = LENGTH l2 ⇒
            (EVERY (λx. P (FST x)) (ZIP (l1,l2)) ⇔ EVERY P l1)
   
   [<a name="every_zip_snd-val"><b>every_zip_snd</b></a>]  Theorem
      
      ⊢ ∀l1 l2 P.
            LENGTH l1 = LENGTH l2 ⇒
            (EVERY (λx. P (SND x)) (ZIP (l1,l2)) ⇔ EVERY P l2)
   
   [<a name="exists_list_GENLIST-val"><b>exists_list_GENLIST</b></a>]  Theorem
      
      ⊢ (∃ls. P ls) ⇔ ∃n f. P (GENLIST f n)
   
   [<a name="isPREFIX_CONSR-val"><b>isPREFIX_CONSR</b></a>]  Theorem
      
      ⊢ x ≼ y::ys ⇔ x = [] ∨ ∃xs. x = y::xs ∧ xs ≼ ys
   
   [<a name="isPREFIX_NILR-val"><b>isPREFIX_NILR</b></a>]  Theorem
      
      ⊢ x ≼ [] ⇔ x = []
   
   [<a name="isPREFIX_THM-val"><b>isPREFIX_THM</b></a>]  Theorem
      
      ⊢ ([] ≼ l ⇔ T) ∧ (h::t ≼ [] ⇔ F) ∧
        (h1::t1 ≼ h2::t2 ⇔ h1 = h2 ∧ t1 ≼ t2)
   
   [<a name="last_drop-val"><b>last_drop</b></a>]  Theorem
      
      ⊢ ∀l n. n &lt; LENGTH l ⇒ LAST (DROP n l) = LAST l
   
   [<a name="lazy_list_case_compute-val"><b>lazy_list_case_compute</b></a>]  Theorem
      
      ⊢ list_CASE = (λl b f. if NULL l then b else f (HD l) (TL l))
   
   [<a name="length_nub_append-val"><b>length_nub_append</b></a>]  Theorem
      
      ⊢ ∀l1 l2.
            LENGTH (nub (l1 ⧺ l2)) =
            LENGTH (nub l1) + LENGTH (nub (FILTER (λx. ¬MEM x l1) l2))
   
   [<a name="list_11-val"><b>list_11</b></a>]  Theorem
      
      ⊢ ∀a0 a1 a0' a1'. a0::a1 = a0'::a1' ⇔ a0 = a0' ∧ a1 = a1'
   
   [<a name="list_Axiom-val"><b>list_Axiom</b></a>]  Theorem
      
      ⊢ ∀f0 f1. ∃fn. fn [] = f0 ∧ ∀a0 a1. fn (a0::a1) = f1 a0 a1 (fn a1)
   
   [<a name="list_Axiom_old-val"><b>list_Axiom_old</b></a>]  Theorem
      
      ⊢ ∀x f. ∃!fn1. fn1 [] = x ∧ ∀h t. fn1 (h::t) = f (fn1 t) h t
   
   [<a name="list_CASES-val"><b>list_CASES</b></a>]  Theorem
      
      ⊢ ∀l. l = [] ∨ ∃h t. l = h::t
   
   [<a name="list_INDUCT-val"><b>list_INDUCT</b></a>]  Theorem
      
      ⊢ ∀P. P [] ∧ (∀t. P t ⇒ ∀h. P (h::t)) ⇒ ∀l. P l
   
   [<a name="list_INDUCT0-val"><b>list_INDUCT0</b></a>]  Theorem
      
      ⊢ ∀P. P [] ∧ (∀l. P l ⇒ ∀a. P (a::l)) ⇒ ∀l. P l
   
   [<a name="list_case_compute-val"><b>list_case_compute</b></a>]  Theorem
      
      ⊢ ∀l. list_CASE l b f = if NULL l then b else f (HD l) (TL l)
   
   [<a name="list_case_cong-val"><b>list_case_cong</b></a>]  Theorem
      
      ⊢ ∀M M' v f.
            M = M' ∧ (M' = [] ⇒ v = v') ∧
            (∀a0 a1. M' = a0::a1 ⇒ f a0 a1 = f' a0 a1) ⇒
            list_CASE M v f = list_CASE M' v' f'
   
   [<a name="list_case_eq-val"><b>list_case_eq</b></a>]  Theorem
      
      ⊢ list_CASE x v f = v' ⇔
        x = [] ∧ v = v' ∨ ∃a l. x = a::l ∧ f a l = v'
   
   [<a name="list_distinct-val"><b>list_distinct</b></a>]  Theorem
      
      ⊢ ∀a1 a0. [] ≠ a0::a1
   
   [<a name="list_induction-val"><b>list_induction</b></a>]  Theorem
      
      ⊢ ∀P. P [] ∧ (∀t. P t ⇒ ∀h. P (h::t)) ⇒ ∀l. P l
   
   [<a name="list_nchotomy-val"><b>list_nchotomy</b></a>]  Theorem
      
      ⊢ ∀l. l = [] ∨ ∃h t. l = h::t
   
   [<a name="list_size_cong-val"><b>list_size_cong</b></a>]  Theorem
      
      ⊢ ∀M N f f'.
            M = N ∧ (∀x. MEM x N ⇒ f x = f' x) ⇒
            list_size f M = list_size f' N
   
   [<a name="list_to_set_diff-val"><b>list_to_set_diff</b></a>]  Theorem
      
      ⊢ ∀l1 l2. set l2 DIFF set l1 = set (FILTER (λx. ¬MEM x l1) l2)
   
   [<a name="lupdate_append-val"><b>lupdate_append</b></a>]  Theorem
      
      ⊢ ∀x n l1 l2.
            n &lt; LENGTH l1 ⇒ LUPDATE x n (l1 ⧺ l2) = LUPDATE x n l1 ⧺ l2
   
   [<a name="lupdate_append2-val"><b>lupdate_append2</b></a>]  Theorem
      
      ⊢ ∀v l1 x l2 l3.
            LUPDATE v (LENGTH l1) (l1 ⧺ [x] ⧺ l2) = l1 ⧺ [v] ⧺ l2
   
   [<a name="mem_exists_set-val"><b>mem_exists_set</b></a>]  Theorem
      
      ⊢ ∀x y l. MEM (x,y) l ⇒ ∃z. x = FST z ∧ MEM z l
   
   [<a name="nub_append-val"><b>nub_append</b></a>]  Theorem
      
      ⊢ ∀l1 l2. nub (l1 ⧺ l2) = nub (FILTER (λx. ¬MEM x l2) l1) ⧺ nub l2
   
   [<a name="nub_set-val"><b>nub_set</b></a>]  Theorem
      
      ⊢ ∀l. set (nub l) = set l
   
   [<a name="oEL_DROP-val"><b>oEL_DROP</b></a>]  Theorem
      
      ⊢ oEL n (DROP m xs) = oEL (m + n) xs
   
   [<a name="oEL_EQ_EL-val"><b>oEL_EQ_EL</b></a>]  Theorem
      
      ⊢ ∀xs n y. oEL n xs = SOME y ⇔ n &lt; LENGTH xs ∧ y = EL n xs
   
   [<a name="oEL_LUPDATE-val"><b>oEL_LUPDATE</b></a>]  Theorem
      
      ⊢ ∀xs i n x.
            oEL n (LUPDATE x i xs) =
            if i ≠ n then oEL n xs
            else if i &lt; LENGTH xs then SOME x
            else NONE
   
   [<a name="oEL_TAKE_E-val"><b>oEL_TAKE_E</b></a>]  Theorem
      
      ⊢ oEL n (TAKE m xs) = SOME x ⇒ oEL n xs = SOME x
   
   [<a name="oEL_THM-val"><b>oEL_THM</b></a>]  Theorem
      
      ⊢ ∀xs n. oEL n xs = if n &lt; LENGTH xs then SOME (EL n xs) else NONE
   
   [<a name="oHD_thm-val"><b>oHD_thm</b></a>]  Theorem
      
      ⊢ oHD [] = NONE ∧ oHD (h::t) = SOME h
   
   [<a name="splitAtPki_APPEND-val"><b>splitAtPki_APPEND</b></a>]  Theorem
      
      ⊢ ∀l1 l2 P k.
            EVERYi (λi. $~ ∘ P i) l1 ∧
            (0 &lt; LENGTH l2 ⇒ P (LENGTH l1) (HD l2)) ⇒
            splitAtPki P k (l1 ⧺ l2) = k l1 l2
   
   [<a name="splitAtPki_EQN-val"><b>splitAtPki_EQN</b></a>]  Theorem
      
      ⊢ splitAtPki P k l =
        case OLEAST i. i &lt; LENGTH l ∧ P i (EL i l) of
          NONE =&gt; k l []
        | SOME i =&gt; k (TAKE i l) (DROP i l)
   
   [<a name="splitAtPki_MAP-val"><b>splitAtPki_MAP</b></a>]  Theorem
      
      ⊢ splitAtPki P k (MAP f l) =
        splitAtPki (combin$C ($o ∘ P) f)
          (combin$C ($o ∘ k ∘ MAP f) (MAP f)) l
   
   [<a name="splitAtPki_RAND-val"><b>splitAtPki_RAND</b></a>]  Theorem
      
      ⊢ f (splitAtPki P k l) = splitAtPki P ($o f ∘ k) l
   
   [<a name="splitAtPki_change_predicate-val"><b>splitAtPki_change_predicate</b></a>]  Theorem
      
      ⊢ (∀i. i &lt; LENGTH l ⇒ (P1 i (EL i l) ⇔ P2 i (EL i l))) ⇒
        splitAtPki P1 k l = splitAtPki P2 k l
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/list/src/listScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-13</a></em></p></body></html>
