<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure patternMatchesSyntax</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure patternMatchesSyntax</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/pattern_matches/patternMatchesSyntax.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature patternMatchesSyntax =
<a name="line2"></a>sig
<a name="line3"></a>  include Abbrev
<a name="line4"></a>
<a name="line5"></a>
<a name="line6"></a>  (******************)
<a name="line7"></a>  (* PMATCH_ROW     *)
<a name="line8"></a>  (******************)
<a name="line9"></a>
<a name="line10"></a>  val PMATCH_ROW_tm   : term
<a name="line11"></a>
<a name="line12"></a>  (* dest_PMATCH_ROW ``PMATCH_ROW p g r``
<a name="line13"></a>     returns (``p``, ``g``, ``r``). *)
<a name="line14"></a>  val dest_PMATCH_ROW : term -&gt; (term * term * term)
<a name="line15"></a>
<a name="line16"></a>  val is_PMATCH_ROW   : term -&gt; bool
<a name="line17"></a>
<a name="line18"></a>  (* [mk_PMATCH_ROW (p, g, rh)] constructs the term
<a name="line19"></a>     ``PMATCH_ROW p g rh``. *)
<a name="line20"></a>  val mk_PMATCH_ROW : term * term * term -&gt; term
<a name="line21"></a>
<a name="line22"></a>  (* [mk_PMATCH_ROW_PABS vars (p, g, rh)] constructs the term
<a name="line23"></a>     ``PMATCH_ROW (\vars. p) (\vars. g) (\vars. rh)``. *)
<a name="line24"></a>  val mk_PMATCH_ROW_PABS : term list -&gt; term * term * term -&gt; term
<a name="line25"></a>
<a name="line26"></a>  (* a wrapper for [mk_PMATCH_ROW_PABS] automatically renames
<a name="line27"></a>     the used variables to mark them as wildcards. Moreover
<a name="line28"></a>     it removes unused vars.
<a name="line29"></a>     It returns the constructed term with a flag of whether
<a name="line30"></a>     the result differs from a naive call of [mk_PMATCH_ROW_PABS]. *)
<a name="line31"></a>  val mk_PMATCH_ROW_PABS_WILDCARDS : term list -&gt; term * term * term -&gt;
<a name="line32"></a>                                     (bool * term)
<a name="line33"></a>
<a name="line34"></a>  (* dest_PMATCH_ROW_ABS ``PMATCH_ROW (\(x,y). p x y)
<a name="line35"></a>        (\(x,y). g x y) (\(x,y). r x y)``
<a name="line36"></a>     returns (``(x,y)``, ``p x y``, ``g x y``, ``r x y``).
<a name="line37"></a>     It fails, if not all paired abstractions use the same
<a name="line38"></a>     variable names. *)
<a name="line39"></a>  val dest_PMATCH_ROW_ABS : term -&gt; (term * term * term * term)
<a name="line40"></a>
<a name="line41"></a>  (* calls dest_PMATCH_ROW_ABS and renames the abstracted vars
<a name="line42"></a>     consistently to be different from the list of given vars. *)
<a name="line43"></a>  val dest_PMATCH_ROW_ABS_VARIANT : term list -&gt; term -&gt;
<a name="line44"></a>                                    (term * term * term * term)
<a name="line45"></a>
<a name="line46"></a>
<a name="line47"></a>  (* [PMATCH_ROW_PABS_ELIM_CONV t]
<a name="line48"></a>     replaces paired lambda abstraction in t with a normal lambda
<a name="line49"></a>     abstraction.  It returns a theorem stating the equivalence as
<a name="line50"></a>     well as the original varstruct of p removed. *)
<a name="line51"></a>  val PMATCH_ROW_PABS_ELIM_CONV : term -&gt; (term * thm)
<a name="line52"></a>
<a name="line53"></a>  (* [PMATCH_ROW_PABS_INTRO_CONV vars t] reintroduces
<a name="line54"></a>     paired abstraction again after being removed by e.g.
<a name="line55"></a>     [PMATCH_ROW_PABS_ELIM_CONV]. It uses [vars] for the newly
<a name="line56"></a>     introduced varstruct. *)
<a name="line57"></a>  val PMATCH_ROW_PABS_INTRO_CONV : term -&gt; conv
<a name="line58"></a>
<a name="line59"></a>  (* [PMATCH_ROW_FORCE_SAME_VARS_CONV] renames the
<a name="line60"></a>     abstracted variables for the pattern, guard and right hand side
<a name="line61"></a>     of a row to match with each other. This invariant
<a name="line62"></a>     is required by many operations working on PMATCH_ROW *)
<a name="line63"></a>  val PMATCH_ROW_FORCE_SAME_VARS_CONV : conv
<a name="line64"></a>  val PMATCH_FORCE_SAME_VARS_CONV : conv
<a name="line65"></a>
<a name="line66"></a>  (* [PMATCH_ROW_INTRO_WILDCARDS_CONV] renames the
<a name="line67"></a>     abstracted variables for the pattern, guard and right hand side
<a name="line68"></a>     where appropriate to start with '_'. This is printed
<a name="line69"></a>     as a wildcard. *)
<a name="line70"></a>  val PMATCH_ROW_INTRO_WILDCARDS_CONV : conv
<a name="line71"></a>  val PMATCH_INTRO_WILDCARDS_CONV : conv
<a name="line72"></a>
<a name="line73"></a>
<a name="line74"></a>  (******************)
<a name="line75"></a>  (* PMATCH         *)
<a name="line76"></a>  (******************)
<a name="line77"></a>
<a name="line78"></a>  val PMATCH_tm       : term
<a name="line79"></a>
<a name="line80"></a>  (* [dest_PMATCH ``PMATCH v rows``] returns (``v``, ``rows``). *)
<a name="line81"></a>  val dest_PMATCH     : term -&gt; (term * term list)
<a name="line82"></a>
<a name="line83"></a>  val is_PMATCH       : term -&gt; bool
<a name="line84"></a>
<a name="line85"></a>  val mk_PMATCH       : term -&gt; term -&gt; term
<a name="line86"></a>
<a name="line87"></a>  (* [dest_PMATCH_COLS ``PMATCH v rows``] tries to extract the columns
<a name="line88"></a>     of the pattern match. Each column consists of the value of v,
<a name="line89"></a>     the free variables in the pattern and the column of the pattern
<a name="line90"></a>     for each row. *)
<a name="line91"></a>  val dest_PMATCH_COLS : term -&gt; (term * (term list * term) list) list
<a name="line92"></a>
<a name="line93"></a>  (* internally, the columns come from a list of atterns. Sometimes
<a name="line94"></a>     this interface is useful as well. *)
<a name="line95"></a>  val dest_PATLIST_COLS : term -&gt; term list -&gt;
<a name="line96"></a>                          (term * (term list * term) list) list
<a name="line97"></a>
<a name="line98"></a>  (* applies a conversion to all rows of a pmatch *)
<a name="line99"></a>  val PMATCH_ROWS_CONV : conv -&gt; conv
<a name="line100"></a>
<a name="line101"></a>  (* Often one wants to work on the PMATCH structure without
<a name="line102"></a>     touching the concrete patterns or right-hand-sides.
<a name="line103"></a>     "PMATCH_INTRO_GENVARS t" replaces in "t" all
<a name="line104"></a>     patterns, guards and right-hand-sides with freshly
<a name="line105"></a>     generated variables and returns a  substitution
<a name="line106"></a>     s and a term t' such that "subst s t'" is alpha-equivalent
<a name="line107"></a>     to "t". *)
<a name="line108"></a>  val PMATCH_INTRO_GENVARS : term -&gt; term * (term, term) Term.subst
<a name="line109"></a>
<a name="line110"></a>  (*******************)
<a name="line111"></a>  (* PMATCH_ROW_COND *)
<a name="line112"></a>  (*******************)
<a name="line113"></a>
<a name="line114"></a>  val PMATCH_ROW_COND_tm   : term
<a name="line115"></a>  val dest_PMATCH_ROW_COND : term -&gt; (term * term * term * term)
<a name="line116"></a>  val is_PMATCH_ROW_COND   : term -&gt; bool
<a name="line117"></a>  val mk_PMATCH_ROW_COND : term * term * term * term -&gt; term
<a name="line118"></a>  val mk_PMATCH_ROW_COND_PABS : term list -&gt; term * term * term * term -&gt; term
<a name="line119"></a>  val dest_PMATCH_ROW_COND_ABS : term -&gt; (term * term * term * term * term)
<a name="line120"></a>
<a name="line121"></a>  val PMATCH_ROW_COND_EX_tm : term
<a name="line122"></a>  val dest_PMATCH_ROW_COND_EX : term -&gt; term * term * term
<a name="line123"></a>  val dest_PMATCH_ROW_COND_EX_ABS : term -&gt; term * term * term * term
<a name="line124"></a>  val is_PMATCH_ROW_COND_EX : term -&gt; bool
<a name="line125"></a>  val mk_PMATCH_ROW_COND_EX : term * term * term -&gt; term
<a name="line126"></a>  val mk_PMATCH_ROW_COND_EX_PABS : term list -&gt; term * term * term -&gt; term
<a name="line127"></a>  val mk_PMATCH_ROW_COND_EX_pat : term -&gt; term -&gt; term
<a name="line128"></a>  val mk_PMATCH_ROW_COND_EX_ROW : term -&gt; term -&gt; term
<a name="line129"></a>
<a name="line130"></a>  val PMATCH_ROW_COND_EX_ELIM_CONV : conv
<a name="line131"></a>
<a name="line132"></a>  (* [PMATCH_ROW_COND_EX_INTRO_CONV_GEN find_guard_term v t] tries
<a name="line133"></a>     to introduce [PMATCH_ROW_COND_EX] terms. For
<a name="line134"></a>     t of the form ``?x1 ... xn. v = f x1 ... xn /\ g1 x1 ... xn /\ ...``
<a name="line135"></a>     it extracts the pattern [f x1 ... xn] and guard [g1 x1 ... xn /\ ...].
<a name="line136"></a>
<a name="line137"></a>     The function [find_guard_term] is used to find subterms of [f x1
<a name="line138"></a>     ... xn] that should be abbreviated by a new variable and moved to
<a name="line139"></a>     the guard. It gets the list of free variables and the pattern.
<a name="line140"></a>  *)
<a name="line141"></a>  val PMATCH_ROW_COND_EX_INTRO_CONV_GEN :
<a name="line142"></a>      (term list -&gt; term -&gt; term option) -&gt; term -&gt; conv
<a name="line143"></a>  val PMATCH_ROW_COND_EX_INTRO_CONV : term -&gt; conv
<a name="line144"></a>
<a name="line145"></a>  (* apply PMATCH_ROW_COND_EX_INTRO_CONV to all disjuncts of an nchotomy
<a name="line146"></a>     theorem. *)
<a name="line147"></a>  val nchotomy2PMATCH_ROW_COND_EX_CONV_GEN :
<a name="line148"></a>      (term list -&gt; term -&gt; term option) -&gt; conv
<a name="line149"></a>  val nchotomy2PMATCH_ROW_COND_EX_CONV : conv
<a name="line150"></a>
<a name="line151"></a>  (* A version of making PMATCH_ROW_COND_EX that does the move to guards. *)
<a name="line152"></a>  val mk_PMATCH_ROW_COND_EX_PABS_MOVE_TO_GUARDS :
<a name="line153"></a>     (term list -&gt; term -&gt; term option) -&gt;
<a name="line154"></a>     term list -&gt; term * term * term -&gt; term
<a name="line155"></a>
<a name="line156"></a>
<a name="line157"></a>  (********)
<a name="line158"></a>  (* MISC *)
<a name="line159"></a>  (********)
<a name="line160"></a>
<a name="line161"></a>  val PMATCH_IS_EXHAUSTIVE_tm   : term
<a name="line162"></a>  val dest_PMATCH_IS_EXHAUSTIVE : term -&gt; (term * term list)
<a name="line163"></a>  val is_PMATCH_IS_EXHAUSTIVE   : term -&gt; bool
<a name="line164"></a>  val mk_PMATCH_IS_EXHAUSTIVE   : term -&gt; term -&gt; term
<a name="line165"></a>
<a name="line166"></a>  (*****************************)
<a name="line167"></a>  (* Pretty printer and Parser *)
<a name="line168"></a>  (*****************************)
<a name="line169"></a>
<a name="line170"></a>  (* A pretty printer is defined and added for PMATCH.
<a name="line171"></a>     Whether it is use can be controled via the trace
<a name="line172"></a>
<a name="line173"></a>     "use pmatch_pp"
<a name="line174"></a>  *)
<a name="line175"></a>
<a name="line176"></a>  (* Enable Parser *)
<a name="line177"></a>  val ENABLE_PMATCH_CASES : unit -&gt; unit
<a name="line178"></a>
<a name="line179"></a>  val grammar_add_pmatch : term_grammar.grammar -&gt; term_grammar.grammar
<a name="line180"></a>
<a name="line181"></a>
<a name="line182"></a>  (**************************)
<a name="line183"></a>  (* Labels (see markerLib) *)
<a name="line184"></a>  (**************************)
<a name="line185"></a>
<a name="line186"></a>  (* strips multiple applications of labels *)
<a name="line187"></a>  val strip_labels : term -&gt; string list * term
<a name="line188"></a>
<a name="line189"></a>  (* add a list of labels to a term *)
<a name="line190"></a>  val add_labels_CONV : string list -&gt; conv
<a name="line191"></a>
<a name="line192"></a>  (* apply a conversion under a sequence
<a name="line193"></a>     of labels *)
<a name="line194"></a>  val strip_labels_CONV : conv -&gt; conv
<a name="line195"></a>
<a name="line196"></a>  (* similar to [strip_labels_CONV] but fails if not at least
<a name="line197"></a>     one of the stripped labels has a lbl in the given list *)
<a name="line198"></a>  val guarded_strip_labels_CONV :
<a name="line199"></a>    string list -&gt; conv -&gt; conv
<a name="line200"></a>
<a name="line201"></a>
<a name="line202"></a>  (*******************)
<a name="line203"></a>  (* Auxiliary stuff *)
<a name="line204"></a>  (*******************)
<a name="line205"></a>
<a name="line206"></a>  (* [pick_element p l] gets the first element of l that satisfies p
<a name="line207"></a>     and removes this occurence from the list.
<a name="line208"></a>     If no such element exists, the function fails. *)
<a name="line209"></a>  val pick_element : ('a -&gt; bool) -&gt; ('a list) -&gt; 'a * 'a list
<a name="line210"></a>
<a name="line211"></a>  (* [has_subterm p t] checks whether [t] has a subterm satisfying
<a name="line212"></a>     predicate [p]. *)
<a name="line213"></a>  val has_subterm : (term -&gt; bool) -&gt; term -&gt; bool
<a name="line214"></a>
<a name="line215"></a>  (* Like [prove], but quiet in case it fails. This is useful,
<a name="line216"></a>     when trying to prove things and are not sure, whether they
<a name="line217"></a>     hold. *)
<a name="line218"></a>  val prove_attempt : term * tactic -&gt; thm
<a name="line219"></a>
<a name="line220"></a>  (* List strip_comb, but with a maximum bound. *)
<a name="line221"></a>  val strip_comb_bounded : int -&gt; term -&gt; term * term list
<a name="line222"></a>
<a name="line223"></a>  (* auxiliary function that introduces fresh
<a name="line224"></a>     typevars for all type-vars used by
<a name="line225"></a>     free vars of a thm *)
<a name="line226"></a>  val FRESH_TY_VARS_RULE : rule
<a name="line227"></a>
<a name="line228"></a>  (* transforms a term to a alpha-equivalent
<a name="line229"></a>     one that does not use the same variable name in
<a name="line230"></a>     different bindings in the term. *)
<a name="line231"></a>  val REMOVE_REBIND_CONV : conv
<a name="line232"></a>
<a name="line233"></a>  (* strips lambda abstractions *)
<a name="line234"></a>  val STRIP_ABS_CONV : conv -&gt; conv
<a name="line235"></a>
<a name="line236"></a>  (* strip a large disjunction and apply a conversion to all
<a name="line237"></a>     leafs. *)
<a name="line238"></a>  val ALL_DISJ_CONV : conv -&gt; conv
<a name="line239"></a>
<a name="line240"></a>  (* strip a large disjunction and apply a conversion to all
<a name="line241"></a>     leafs. Eliminate T and F from the resulting term by
<a name="line242"></a>     applying rewrites. This might be more efficient than
<a name="line243"></a>     ALL_DISJ_CONV, since it stops, once a T-disjunct is found. *)
<a name="line244"></a>  val ALL_DISJ_TF_ELIM_CONV : conv -&gt; conv
<a name="line245"></a>
<a name="line246"></a>  (* strip a large conjunction and apply a conversion to all
<a name="line247"></a>     leafs. *)
<a name="line248"></a>  val ALL_CONJ_CONV : conv -&gt; conv
<a name="line249"></a>
<a name="line250"></a>  (* [DESCEND_CONV c_desc c] applies [c] and then uses
<a name="line251"></a>     [c_desc] to descend into the result via [c_desc] and
<a name="line252"></a>     repeat. *)
<a name="line253"></a>  val DESCEND_CONV : (conv -&gt; conv) -&gt; conv -&gt; conv
<a name="line254"></a>
<a name="line255"></a>  (* Apply a conversion to all elements of a list (build
<a name="line256"></a>     only by cons and nil) *)
<a name="line257"></a>  val list_CONV : conv -&gt; conv
<a name="line258"></a>
<a name="line259"></a>  (* Apply a conversion to the nth elements of a list.
<a name="line260"></a>     Counting starts with 0. *)
<a name="line261"></a>  val list_nth_CONV : int -&gt; conv -&gt; conv
<a name="line262"></a>
<a name="line263"></a>  (* Given a prefix [pr] and a list of variables to avoid [avoid],
<a name="line264"></a>     [mk_var_gen pr avoid] generates a variable generator that
<a name="line265"></a>     generates variable, whose name starts with [pr] and who
<a name="line266"></a>     are all distinct to each other and the vars in list [avoid]. *)
<a name="line267"></a>  val mk_var_gen : string -&gt; term list -&gt; (hol_type -&gt; term)
<a name="line268"></a>
<a name="line269"></a>  (* Given a prefix [pr], [mk_new_label_gen pr] generate a string
<a name="line270"></a>     generator for strings starting with [pr], which are all distinct
<a name="line271"></a>     from each other *)
<a name="line272"></a>  val mk_new_label_gen : string -&gt; (unit -&gt; string)
<a name="line273"></a>
<a name="line274"></a>end
<a name="line275"></a>
</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/pattern_matches/patternMatchesSyntax.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-13</a></em></p></body></html>
