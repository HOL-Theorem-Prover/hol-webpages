<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure indexedListsTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure indexedListsTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/list/src/indexedListsScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature indexedListsTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#FOLDRi_def-val">FOLDRi_def</a> : thm
<a name="line7"></a>    val <a href="#LIST_RELi_def-val">LIST_RELi_def</a> : thm
<a name="line8"></a>    val <a href="#MAPi_ACC_def-val">MAPi_ACC_def</a> : thm
<a name="line9"></a>    val <a href="#MAPi_def-val">MAPi_def</a> : thm
<a name="line10"></a>    val <a href="#delN_def-val">delN_def</a> : thm
<a name="line11"></a>    val <a href="#findi_def-val">findi_def</a> : thm
<a name="line12"></a>  
<a name="line13"></a>  (*  Theorems  *)
<a name="line14"></a>    val <a href="#EL_MAP2i-val">EL_MAP2i</a> : thm
<a name="line15"></a>    val <a href="#EL_MAPi-val">EL_MAPi</a> : thm
<a name="line16"></a>    val <a href="#EL_delN_AFTER-val">EL_delN_AFTER</a> : thm
<a name="line17"></a>    val <a href="#EL_delN_BEFORE-val">EL_delN_BEFORE</a> : thm
<a name="line18"></a>    val <a href="#EL_findi-val">EL_findi</a> : thm
<a name="line19"></a>    val <a href="#FOLDR_MAPi-val">FOLDR_MAPi</a> : thm
<a name="line20"></a>    val <a href="#FOLDRi_APPEND-val">FOLDRi_APPEND</a> : thm
<a name="line21"></a>    val <a href="#FOLDRi_CONG-val">FOLDRi_CONG</a> : thm
<a name="line22"></a>    val <a href="#FOLDRi_CONG'-val">FOLDRi_CONG'</a> : thm
<a name="line23"></a>    val <a href="#GENLIST_CONG-val">GENLIST_CONG</a> : thm
<a name="line24"></a>    val <a href="#LENGTH_MAP2i-val">LENGTH_MAP2i</a> : thm
<a name="line25"></a>    val <a href="#LENGTH_MAPi-val">LENGTH_MAPi</a> : thm
<a name="line26"></a>    val <a href="#LIST_RELi_APPEND_I-val">LIST_RELi_APPEND_I</a> : thm
<a name="line27"></a>    val <a href="#LIST_RELi_EL_EQN-val">LIST_RELi_EL_EQN</a> : thm
<a name="line28"></a>    val <a href="#LIST_RELi_LENGTH-val">LIST_RELi_LENGTH</a> : thm
<a name="line29"></a>    val <a href="#LIST_RELi_cases-val">LIST_RELi_cases</a> : thm
<a name="line30"></a>    val <a href="#LIST_RELi_ind-val">LIST_RELi_ind</a> : thm
<a name="line31"></a>    val <a href="#LIST_RELi_rules-val">LIST_RELi_rules</a> : thm
<a name="line32"></a>    val <a href="#LIST_RELi_strongind-val">LIST_RELi_strongind</a> : thm
<a name="line33"></a>    val <a href="#LIST_RELi_thm-val">LIST_RELi_thm</a> : thm
<a name="line34"></a>    val <a href="#LT_SUC-val">LT_SUC</a> : thm
<a name="line35"></a>    val <a href="#MAP2i_NIL2-val">MAP2i_NIL2</a> : thm
<a name="line36"></a>    val <a href="#MAP2i_compute-val">MAP2i_compute</a> : thm
<a name="line37"></a>    val <a href="#MAP2i_def-val">MAP2i_def</a> : thm
<a name="line38"></a>    val <a href="#MAP2i_ind-val">MAP2i_ind</a> : thm
<a name="line39"></a>    val <a href="#MAP2ia_NIL2-val">MAP2ia_NIL2</a> : thm
<a name="line40"></a>    val <a href="#MAP2ia_def-val">MAP2ia_def</a> : thm
<a name="line41"></a>    val <a href="#MAP2ia_ind-val">MAP2ia_ind</a> : thm
<a name="line42"></a>    val <a href="#MAP_MAPi-val">MAP_MAPi</a> : thm
<a name="line43"></a>    val <a href="#MAPi_ACC_MAPi-val">MAPi_ACC_MAPi</a> : thm
<a name="line44"></a>    val <a href="#MAPi_APPEND-val">MAPi_APPEND</a> : thm
<a name="line45"></a>    val <a href="#MAPi_CONG-val">MAPi_CONG</a> : thm
<a name="line46"></a>    val <a href="#MAPi_CONG'-val">MAPi_CONG'</a> : thm
<a name="line47"></a>    val <a href="#MAPi_GENLIST-val">MAPi_GENLIST</a> : thm
<a name="line48"></a>    val <a href="#MAPi_compute-val">MAPi_compute</a> : thm
<a name="line49"></a>    val <a href="#MEM_MAPi-val">MEM_MAPi</a> : thm
<a name="line50"></a>    val <a href="#MEM_findi-val">MEM_findi</a> : thm
<a name="line51"></a>    val <a href="#delN_shortens-val">delN_shortens</a> : thm
<a name="line52"></a>    val <a href="#findi_EL-val">findi_EL</a> : thm
<a name="line53"></a>    val <a href="#fupdLast_EQ_NIL-val">fupdLast_EQ_NIL</a> : thm
<a name="line54"></a>    val <a href="#fupdLast_FRONT_LAST-val">fupdLast_FRONT_LAST</a> : thm
<a name="line55"></a>    val <a href="#fupdLast_def-val">fupdLast_def</a> : thm
<a name="line56"></a>    val <a href="#fupdLast_ind-val">fupdLast_ind</a> : thm
<a name="line57"></a>  
<a name="line58"></a>  val indexedLists_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line59"></a>(*
   [rich_list] Parent theory of "indexedLists"
   
   [<a name="FOLDRi_def-val"><b>FOLDRi_def</b></a>]  Definition
      
      ⊢ (∀f a. FOLDRi f a [] = a) ∧
        ∀f a h t. FOLDRi f a (h::t) = f 0 h (FOLDRi (f ∘ SUC) a t)
   
   [<a name="LIST_RELi_def-val"><b>LIST_RELi_def</b></a>]  Definition
      
      ⊢ LIST_RELi =
        (λR a0 a1.
             ∀LIST_RELi'.
                 (∀a0 a1.
                      a0 = [] ∧ a1 = [] ∨
                      (∃h1 h2 l1 l2.
                           a0 = l1 ⧺ [h1] ∧ a1 = l2 ⧺ [h2] ∧
                           R (LENGTH l1) h1 h2 ∧ LIST_RELi' l1 l2) ⇒
                      LIST_RELi' a0 a1) ⇒
                 LIST_RELi' a0 a1)
   
   [<a name="MAPi_ACC_def-val"><b>MAPi_ACC_def</b></a>]  Definition
      
      ⊢ (∀f i a. MAPi_ACC f i a [] = REVERSE a) ∧
        ∀f i a h t. MAPi_ACC f i a (h::t) = MAPi_ACC f (i + 1) (f i h::a) t
   
   [<a name="MAPi_def-val"><b>MAPi_def</b></a>]  Definition
      
      ⊢ (∀f. MAPi f [] = []) ∧
        ∀f h t. MAPi f (h::t) = f 0 h::MAPi (f ∘ SUC) t
   
   [<a name="delN_def-val"><b>delN_def</b></a>]  Definition
      
      ⊢ (∀i. delN i [] = []) ∧
        ∀i h t. delN i (h::t) = if i = 0 then t else h::delN (i − 1) t
   
   [<a name="findi_def-val"><b>findi_def</b></a>]  Definition
      
      ⊢ (∀x. findi x [] = 0) ∧
        ∀x h t. findi x (h::t) = if x = h then 0 else 1 + findi x t
   
   [<a name="EL_MAP2i-val"><b>EL_MAP2i</b></a>]  Theorem
      
      ⊢ ∀f l1 l2 n.
            n &lt; LENGTH l1 ∧ n &lt; LENGTH l2 ⇒
            EL n (MAP2i f l1 l2) = f n (EL n l1) (EL n l2)
   
   [<a name="EL_MAPi-val"><b>EL_MAPi</b></a>]  Theorem
      
      ⊢ ∀f n l. n &lt; LENGTH l ⇒ EL n (MAPi f l) = f n (EL n l)
   
   [<a name="EL_delN_AFTER-val"><b>EL_delN_AFTER</b></a>]  Theorem
      
      ⊢ ∀l i j. j ≤ i ∧ i + 1 &lt; LENGTH l ⇒ EL i (delN j l) = EL (i + 1) l
   
   [<a name="EL_delN_BEFORE-val"><b>EL_delN_BEFORE</b></a>]  Theorem
      
      ⊢ ∀l i j. i &lt; j ∧ j &lt; LENGTH l ⇒ EL i (delN j l) = EL i l
   
   [<a name="EL_findi-val"><b>EL_findi</b></a>]  Theorem
      
      ⊢ ∀l x. MEM x l ⇒ EL (findi x l) l = x
   
   [<a name="FOLDR_MAPi-val"><b>FOLDR_MAPi</b></a>]  Theorem
      
      ⊢ ∀f g a l. FOLDR f a (MAPi g l) = FOLDRi ($o f ∘ g) a l
   
   [<a name="FOLDRi_APPEND-val"><b>FOLDRi_APPEND</b></a>]  Theorem
      
      ⊢ ∀f.
            FOLDRi f a (l1 ⧺ l2) =
            FOLDRi f (FOLDRi (f ∘ $+ (LENGTH l1)) a l2) l1
   
   [<a name="FOLDRi_CONG-val"><b>FOLDRi_CONG</b></a>]  Theorem
      
      ⊢ l1 = l2 ⇒
        (∀n e a. n &lt; LENGTH l2 ⇒ MEM e l2 ⇒ f1 n e a = f2 n e a) ⇒
        a1 = a2 ⇒
        FOLDRi f1 a1 l1 = FOLDRi f2 a2 l2
   
   [<a name="FOLDRi_CONG'-val"><b>FOLDRi_CONG'</b></a>]  Theorem
      
      ⊢ l1 = l2 ∧
        (∀n a. n &lt; LENGTH l2 ⇒ f1 n (EL n l2) a = f2 n (EL n l2) a) ∧
        a1 = a2 ⇒
        FOLDRi f1 a1 l1 = FOLDRi f2 a2 l2
   
   [<a name="GENLIST_CONG-val"><b>GENLIST_CONG</b></a>]  Theorem
      
      ⊢ (∀m. m &lt; n ⇒ f1 m = f2 m) ⇒ GENLIST f1 n = GENLIST f2 n
   
   [<a name="LENGTH_MAP2i-val"><b>LENGTH_MAP2i</b></a>]  Theorem
      
      ⊢ ∀f l1 l2. LENGTH (MAP2i f l1 l2) = MIN (LENGTH l1) (LENGTH l2)
   
   [<a name="LENGTH_MAPi-val"><b>LENGTH_MAPi</b></a>]  Theorem
      
      ⊢ ∀f l. LENGTH (MAPi f l) = LENGTH l
   
   [<a name="LIST_RELi_APPEND_I-val"><b>LIST_RELi_APPEND_I</b></a>]  Theorem
      
      ⊢ LIST_RELi R l1 l2 ∧ LIST_RELi (R ∘ $+ (LENGTH l1)) m1 m2 ⇒
        LIST_RELi R (l1 ⧺ m1) (l2 ⧺ m2)
   
   [<a name="LIST_RELi_EL_EQN-val"><b>LIST_RELi_EL_EQN</b></a>]  Theorem
      
      ⊢ LIST_RELi R l1 l2 ⇔
        LENGTH l1 = LENGTH l2 ∧ ∀i. i &lt; LENGTH l1 ⇒ R i (EL i l1) (EL i l2)
   
   [<a name="LIST_RELi_LENGTH-val"><b>LIST_RELi_LENGTH</b></a>]  Theorem
      
      ⊢ ∀l1 l2. LIST_RELi R l1 l2 ⇒ LENGTH l1 = LENGTH l2
   
   [<a name="LIST_RELi_cases-val"><b>LIST_RELi_cases</b></a>]  Theorem
      
      ⊢ ∀R a0 a1.
            LIST_RELi R a0 a1 ⇔
            a0 = [] ∧ a1 = [] ∨
            ∃h1 h2 l1 l2.
                a0 = l1 ⧺ [h1] ∧ a1 = l2 ⧺ [h2] ∧ R (LENGTH l1) h1 h2 ∧
                LIST_RELi R l1 l2
   
   [<a name="LIST_RELi_ind-val"><b>LIST_RELi_ind</b></a>]  Theorem
      
      ⊢ ∀R LIST_RELi'.
            LIST_RELi' [] [] ∧
            (∀h1 h2 l1 l2.
                 R (LENGTH l1) h1 h2 ∧ LIST_RELi' l1 l2 ⇒
                 LIST_RELi' (l1 ⧺ [h1]) (l2 ⧺ [h2])) ⇒
            ∀a0 a1. LIST_RELi R a0 a1 ⇒ LIST_RELi' a0 a1
   
   [<a name="LIST_RELi_rules-val"><b>LIST_RELi_rules</b></a>]  Theorem
      
      ⊢ ∀R.
            LIST_RELi R [] [] ∧
            ∀h1 h2 l1 l2.
                R (LENGTH l1) h1 h2 ∧ LIST_RELi R l1 l2 ⇒
                LIST_RELi R (l1 ⧺ [h1]) (l2 ⧺ [h2])
   
   [<a name="LIST_RELi_strongind-val"><b>LIST_RELi_strongind</b></a>]  Theorem
      
      ⊢ ∀R LIST_RELi'.
            LIST_RELi' [] [] ∧
            (∀h1 h2 l1 l2.
                 R (LENGTH l1) h1 h2 ∧ LIST_RELi R l1 l2 ∧ LIST_RELi' l1 l2 ⇒
                 LIST_RELi' (l1 ⧺ [h1]) (l2 ⧺ [h2])) ⇒
            ∀a0 a1. LIST_RELi R a0 a1 ⇒ LIST_RELi' a0 a1
   
   [<a name="LIST_RELi_thm-val"><b>LIST_RELi_thm</b></a>]  Theorem
      
      ⊢ (LIST_RELi R [] x ⇔ x = []) ∧
        (LIST_RELi R (h::t) l ⇔
         ∃h' t'. l = h'::t' ∧ R 0 h h' ∧ LIST_RELi (R ∘ SUC) t t')
   
   [<a name="LT_SUC-val"><b>LT_SUC</b></a>]  Theorem
      
      ⊢ n &lt; SUC m ⇔ n = 0 ∨ ∃n0. n = SUC n0 ∧ n0 &lt; m
   
   [<a name="MAP2i_NIL2-val"><b>MAP2i_NIL2</b></a>]  Theorem
      
      ⊢ MAP2i f l1 [] = []
   
   [<a name="MAP2i_compute-val"><b>MAP2i_compute</b></a>]  Theorem
      
      ⊢ MAP2i f l1 l2 = indexedLists$MAP2ia f 0 l1 l2
   
   [<a name="MAP2i_def-val"><b>MAP2i_def</b></a>]  Theorem
      
      ⊢ (∀v0 f. MAP2i f [] v0 = []) ∧
        (∀v6 v5 f. MAP2i f (v5::v6) [] = []) ∧
        ∀t2 t1 h2 h1 f.
            MAP2i f (h1::t1) (h2::t2) = f 0 h1 h2::MAP2i (f ∘ SUC) t1 t2
   
   [<a name="MAP2i_ind-val"><b>MAP2i_ind</b></a>]  Theorem
      
      ⊢ ∀P.
            (∀f v0. P f [] v0) ∧ (∀f v5 v6. P f (v5::v6) []) ∧
            (∀f h1 t1 h2 t2. P (f ∘ SUC) t1 t2 ⇒ P f (h1::t1) (h2::t2)) ⇒
            ∀v v1 v2. P v v1 v2
   
   [<a name="MAP2ia_NIL2-val"><b>MAP2ia_NIL2</b></a>]  Theorem
      
      ⊢ indexedLists$MAP2ia f i l1 [] = []
   
   [<a name="MAP2ia_def-val"><b>MAP2ia_def</b></a>]  Theorem
      
      ⊢ (∀v0 i f. indexedLists$MAP2ia f i [] v0 = []) ∧
        (∀v8 v7 i f. indexedLists$MAP2ia f i (v7::v8) [] = []) ∧
        ∀t2 t1 i h2 h1 f.
            indexedLists$MAP2ia f i (h1::t1) (h2::t2) =
            f i h1 h2::indexedLists$MAP2ia f (i + 1) t1 t2
   
   [<a name="MAP2ia_ind-val"><b>MAP2ia_ind</b></a>]  Theorem
      
      ⊢ ∀P.
            (∀f i v0. P f i [] v0) ∧ (∀f i v7 v8. P f i (v7::v8) []) ∧
            (∀f i h1 t1 h2 t2. P f (i + 1) t1 t2 ⇒ P f i (h1::t1) (h2::t2)) ⇒
            ∀v v1 v2 v3. P v v1 v2 v3
   
   [<a name="MAP_MAPi-val"><b>MAP_MAPi</b></a>]  Theorem
      
      ⊢ ∀f g l. MAP f (MAPi g l) = MAPi ($o f ∘ g) l
   
   [<a name="MAPi_ACC_MAPi-val"><b>MAPi_ACC_MAPi</b></a>]  Theorem
      
      ⊢ MAPi_ACC f n a l = REVERSE a ⧺ MAPi (f ∘ $+ n) l
   
   [<a name="MAPi_APPEND-val"><b>MAPi_APPEND</b></a>]  Theorem
      
      ⊢ ∀l1 l2 f.
            MAPi f (l1 ⧺ l2) = MAPi f l1 ⧺ MAPi (f ∘ $+ (LENGTH l1)) l2
   
   [<a name="MAPi_CONG-val"><b>MAPi_CONG</b></a>]  Theorem
      
      ⊢ ∀l1 l2 f1 f2.
            l1 = l2 ∧ (∀x n. MEM x l2 ⇒ f1 n x = f2 n x) ⇒
            MAPi f1 l1 = MAPi f2 l2
   
   [<a name="MAPi_CONG'-val"><b>MAPi_CONG'</b></a>]  Theorem
      
      ⊢ l1 = l2 ⇒
        (∀x n. x = EL n l2 ⇒ n &lt; LENGTH l2 ⇒ f1 n x = f2 n x) ⇒
        MAPi f1 l1 = MAPi f2 l2
   
   [<a name="MAPi_GENLIST-val"><b>MAPi_GENLIST</b></a>]  Theorem
      
      ⊢ ∀l f. MAPi f l = GENLIST (S f (combin$C EL l)) (LENGTH l)
   
   [<a name="MAPi_compute-val"><b>MAPi_compute</b></a>]  Theorem
      
      ⊢ MAPi f l = MAPi_ACC f 0 [] l
   
   [<a name="MEM_MAPi-val"><b>MEM_MAPi</b></a>]  Theorem
      
      ⊢ ∀x f l. MEM x (MAPi f l) ⇔ ∃n. n &lt; LENGTH l ∧ x = f n (EL n l)
   
   [<a name="MEM_findi-val"><b>MEM_findi</b></a>]  Theorem
      
      ⊢ MEM x l ⇒ findi x l &lt; LENGTH l
   
   [<a name="delN_shortens-val"><b>delN_shortens</b></a>]  Theorem
      
      ⊢ ∀l i. i &lt; LENGTH l ⇒ LENGTH (delN i l) = LENGTH l − 1
   
   [<a name="findi_EL-val"><b>findi_EL</b></a>]  Theorem
      
      ⊢ ∀l n. n &lt; LENGTH l ∧ ALL_DISTINCT l ⇒ findi (EL n l) l = n
   
   [<a name="fupdLast_EQ_NIL-val"><b>fupdLast_EQ_NIL</b></a>]  Theorem
      
      ⊢ (fupdLast f x = [] ⇔ x = []) ∧ ([] = fupdLast f x ⇔ x = [])
   
   [<a name="fupdLast_FRONT_LAST-val"><b>fupdLast_FRONT_LAST</b></a>]  Theorem
      
      ⊢ fupdLast f l = if l = [] then [] else FRONT l ⧺ [f (LAST l)]
   
   [<a name="fupdLast_def-val"><b>fupdLast_def</b></a>]  Theorem
      
      ⊢ (∀f. fupdLast f [] = []) ∧ (∀h f. fupdLast f [h] = [f h]) ∧
        ∀v5 v4 h f. fupdLast f (h::v4::v5) = h::fupdLast f (v4::v5)
   
   [<a name="fupdLast_ind-val"><b>fupdLast_ind</b></a>]  Theorem
      
      ⊢ ∀P.
            (∀f. P f []) ∧ (∀f h. P f [h]) ∧
            (∀f h v4 v5. P f (v4::v5) ⇒ P f (h::v4::v5)) ⇒
            ∀v v1. P v v1
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/list/src/indexedListsScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-13</a></em></p></body></html>
