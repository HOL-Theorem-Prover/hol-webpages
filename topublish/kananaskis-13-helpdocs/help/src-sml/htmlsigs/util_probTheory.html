<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure util_probTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure util_probTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/probability/util_probScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature util_probTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#disjoint_def-val">disjoint_def</a> : thm
<a name="line7"></a>    val <a href="#from_def-val">from_def</a> : thm
<a name="line8"></a>    val <a href="#lg_def-val">lg_def</a> : thm
<a name="line9"></a>    val <a href="#logr_def-val">logr_def</a> : thm
<a name="line10"></a>    val <a href="#minimal_def-val">minimal_def</a> : thm
<a name="line11"></a>    val <a href="#pair_def-val">pair_def</a> : thm
<a name="line12"></a>    val <a href="#powr_def-val">powr_def</a> : thm
<a name="line13"></a>    val <a href="#prod_sets_def-val">prod_sets_def</a> : thm
<a name="line14"></a>  
<a name="line15"></a>  (*  Theorems  *)
<a name="line16"></a>    val <a href="#DISJOINT_COUNT_FROM-val">DISJOINT_COUNT_FROM</a> : thm
<a name="line17"></a>    val <a href="#DISJOINT_FROM_COUNT-val">DISJOINT_FROM_COUNT</a> : thm
<a name="line18"></a>    val <a href="#EQ_T_IMP-val">EQ_T_IMP</a> : thm
<a name="line19"></a>    val <a href="#FROM_0-val">FROM_0</a> : thm
<a name="line20"></a>    val <a href="#GBIGUNION_IMAGE-val">GBIGUNION_IMAGE</a> : thm
<a name="line21"></a>    val <a href="#INF_CLOSE-val">INF_CLOSE</a> : thm
<a name="line22"></a>    val <a href="#INF_DEF_ALT-val">INF_DEF_ALT</a> : thm
<a name="line23"></a>    val <a href="#INF_GREATER-val">INF_GREATER</a> : thm
<a name="line24"></a>    val <a href="#INF_LE-val">INF_LE</a> : thm
<a name="line25"></a>    val <a href="#IN_FROM-val">IN_FROM</a> : thm
<a name="line26"></a>    val <a href="#IN_PAIR-val">IN_PAIR</a> : thm
<a name="line27"></a>    val <a href="#IN_PROD_SETS-val">IN_PROD_SETS</a> : thm
<a name="line28"></a>    val <a href="#IN_o-val">IN_o</a> : thm
<a name="line29"></a>    val <a href="#LE_INF-val">LE_INF</a> : thm
<a name="line30"></a>    val <a href="#LOGR_MONO_LE-val">LOGR_MONO_LE</a> : thm
<a name="line31"></a>    val <a href="#LOGR_MONO_LE_IMP-val">LOGR_MONO_LE_IMP</a> : thm
<a name="line32"></a>    val <a href="#MINIMAL_EQ-val">MINIMAL_EQ</a> : thm
<a name="line33"></a>    val <a href="#MINIMAL_EQ_IMP-val">MINIMAL_EQ_IMP</a> : thm
<a name="line34"></a>    val <a href="#MINIMAL_EXISTS-val">MINIMAL_EXISTS</a> : thm
<a name="line35"></a>    val <a href="#MINIMAL_EXISTS0-val">MINIMAL_EXISTS0</a> : thm
<a name="line36"></a>    val <a href="#MINIMAL_EXISTS_IMP-val">MINIMAL_EXISTS_IMP</a> : thm
<a name="line37"></a>    val <a href="#MINIMAL_SUC-val">MINIMAL_SUC</a> : thm
<a name="line38"></a>    val <a href="#MINIMAL_SUC_IMP-val">MINIMAL_SUC_IMP</a> : thm
<a name="line39"></a>    val <a href="#NUM_2D_BIJ-val">NUM_2D_BIJ</a> : thm
<a name="line40"></a>    val <a href="#NUM_2D_BIJ_INV-val">NUM_2D_BIJ_INV</a> : thm
<a name="line41"></a>    val <a href="#NUM_2D_BIJ_NZ-val">NUM_2D_BIJ_NZ</a> : thm
<a name="line42"></a>    val <a href="#NUM_2D_BIJ_NZ_ALT-val">NUM_2D_BIJ_NZ_ALT</a> : thm
<a name="line43"></a>    val <a href="#NUM_2D_BIJ_NZ_ALT2-val">NUM_2D_BIJ_NZ_ALT2</a> : thm
<a name="line44"></a>    val <a href="#NUM_2D_BIJ_NZ_ALT2_INV-val">NUM_2D_BIJ_NZ_ALT2_INV</a> : thm
<a name="line45"></a>    val <a href="#NUM_2D_BIJ_NZ_ALT_INV-val">NUM_2D_BIJ_NZ_ALT_INV</a> : thm
<a name="line46"></a>    val <a href="#NUM_2D_BIJ_NZ_INV-val">NUM_2D_BIJ_NZ_INV</a> : thm
<a name="line47"></a>    val <a href="#PAIRED_BETA_THM-val">PAIRED_BETA_THM</a> : thm
<a name="line48"></a>    val <a href="#PAIR_UNIV-val">PAIR_UNIV</a> : thm
<a name="line49"></a>    val <a href="#POW_HALF_MONO-val">POW_HALF_MONO</a> : thm
<a name="line50"></a>    val <a href="#POW_HALF_POS-val">POW_HALF_POS</a> : thm
<a name="line51"></a>    val <a href="#POW_HALF_SMALL-val">POW_HALF_SMALL</a> : thm
<a name="line52"></a>    val <a href="#POW_NEG_ODD-val">POW_NEG_ODD</a> : thm
<a name="line53"></a>    val <a href="#POW_POS_EVEN-val">POW_POS_EVEN</a> : thm
<a name="line54"></a>    val <a href="#PREIMAGE_REAL_COMPL1-val">PREIMAGE_REAL_COMPL1</a> : thm
<a name="line55"></a>    val <a href="#PREIMAGE_REAL_COMPL2-val">PREIMAGE_REAL_COMPL2</a> : thm
<a name="line56"></a>    val <a href="#PREIMAGE_REAL_COMPL3-val">PREIMAGE_REAL_COMPL3</a> : thm
<a name="line57"></a>    val <a href="#PREIMAGE_REAL_COMPL4-val">PREIMAGE_REAL_COMPL4</a> : thm
<a name="line58"></a>    val <a href="#REAL_LE_LT_MUL-val">REAL_LE_LT_MUL</a> : thm
<a name="line59"></a>    val <a href="#REAL_LE_RDIV_EQ_NEG-val">REAL_LE_RDIV_EQ_NEG</a> : thm
<a name="line60"></a>    val <a href="#REAL_LT_LE_MUL-val">REAL_LT_LE_MUL</a> : thm
<a name="line61"></a>    val <a href="#REAL_LT_LMUL_0_NEG-val">REAL_LT_LMUL_0_NEG</a> : thm
<a name="line62"></a>    val <a href="#REAL_LT_LMUL_NEG_0-val">REAL_LT_LMUL_NEG_0</a> : thm
<a name="line63"></a>    val <a href="#REAL_LT_LMUL_NEG_0_NEG-val">REAL_LT_LMUL_NEG_0_NEG</a> : thm
<a name="line64"></a>    val <a href="#REAL_LT_RDIV_EQ_NEG-val">REAL_LT_RDIV_EQ_NEG</a> : thm
<a name="line65"></a>    val <a href="#REAL_LT_RMUL_0_NEG-val">REAL_LT_RMUL_0_NEG</a> : thm
<a name="line66"></a>    val <a href="#REAL_LT_RMUL_NEG_0-val">REAL_LT_RMUL_NEG_0</a> : thm
<a name="line67"></a>    val <a href="#REAL_LT_RMUL_NEG_0_NEG-val">REAL_LT_RMUL_NEG_0_NEG</a> : thm
<a name="line68"></a>    val <a href="#REAL_MUL_IDEMPOT-val">REAL_MUL_IDEMPOT</a> : thm
<a name="line69"></a>    val <a href="#REAL_NEG_NZ-val">REAL_NEG_NZ</a> : thm
<a name="line70"></a>    val <a href="#REAL_SUP_LE_X-val">REAL_SUP_LE_X</a> : thm
<a name="line71"></a>    val <a href="#REAL_X_LE_SUP-val">REAL_X_LE_SUP</a> : thm
<a name="line72"></a>    val <a href="#UNION_COUNT_FROM-val">UNION_COUNT_FROM</a> : thm
<a name="line73"></a>    val <a href="#UNION_FROM_COUNT-val">UNION_FROM_COUNT</a> : thm
<a name="line74"></a>    val <a href="#disjointD-val">disjointD</a> : thm
<a name="line75"></a>    val <a href="#disjointI-val">disjointI</a> : thm
<a name="line76"></a>    val <a href="#disjoint_empty-val">disjoint_empty</a> : thm
<a name="line77"></a>    val <a href="#disjoint_sing-val">disjoint_sing</a> : thm
<a name="line78"></a>    val <a href="#disjoint_union-val">disjoint_union</a> : thm
<a name="line79"></a>    val <a href="#finite_enumeration_of_sets_has_max_non_empty-val">finite_enumeration_of_sets_has_max_non_empty</a> : thm
<a name="line80"></a>    val <a href="#lg_1-val">lg_1</a> : thm
<a name="line81"></a>    val <a href="#lg_2-val">lg_2</a> : thm
<a name="line82"></a>    val <a href="#lg_inv-val">lg_inv</a> : thm
<a name="line83"></a>    val <a href="#lg_mul-val">lg_mul</a> : thm
<a name="line84"></a>    val <a href="#lg_nonzero-val">lg_nonzero</a> : thm
<a name="line85"></a>    val <a href="#lg_pow-val">lg_pow</a> : thm
<a name="line86"></a>    val <a href="#logr_1-val">logr_1</a> : thm
<a name="line87"></a>    val <a href="#logr_div-val">logr_div</a> : thm
<a name="line88"></a>    val <a href="#logr_inv-val">logr_inv</a> : thm
<a name="line89"></a>    val <a href="#logr_mul-val">logr_mul</a> : thm
<a name="line90"></a>    val <a href="#neg_lg-val">neg_lg</a> : thm
<a name="line91"></a>    val <a href="#neg_logr-val">neg_logr</a> : thm
<a name="line92"></a>  
<a name="line93"></a>  val util_prob_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line94"></a>(*
   [real_sigma] Parent theory of "util_prob"
   
   [<a name="disjoint_def-val"><b>disjoint_def</b></a>]  Definition
      
      âŠ¢ âˆ€A. disjoint A â‡” âˆ€a b. a âˆˆ A âˆ§ b âˆˆ A âˆ§ a â‰  b â‡’ DISJOINT a b
   
   [<a name="from_def-val"><b>from_def</b></a>]  Definition
      
      âŠ¢ âˆ€n. from n = {m | n â‰¤ m}
   
   [<a name="lg_def-val"><b>lg_def</b></a>]  Definition
      
      âŠ¢ âˆ€x. lg x = logr 2 x
   
   [<a name="logr_def-val"><b>logr_def</b></a>]  Definition
      
      âŠ¢ âˆ€a x. logr a x = ln x / ln a
   
   [<a name="minimal_def-val"><b>minimal_def</b></a>]  Definition
      
      âŠ¢ âˆ€p. minimal p = @n. p n âˆ§ âˆ€m. m &lt; n â‡’ Â¬p m
   
   [<a name="pair_def-val"><b>pair_def</b></a>]  Definition
      
      âŠ¢ âˆ€X Y. pair X Y = (Î»(x,y). x âˆˆ X âˆ§ y âˆˆ Y)
   
   [<a name="powr_def-val"><b>powr_def</b></a>]  Definition
      
      âŠ¢ âˆ€x a. x powr a = exp (a * ln x)
   
   [<a name="prod_sets_def-val"><b>prod_sets_def</b></a>]  Definition
      
      âŠ¢ âˆ€a b. prod_sets a b = {s Ã— t | s âˆˆ a âˆ§ t âˆˆ b}
   
   [<a name="DISJOINT_COUNT_FROM-val"><b>DISJOINT_COUNT_FROM</b></a>]  Theorem
      
      âŠ¢ âˆ€n. DISJOINT (count n) (from n)
   
   [<a name="DISJOINT_FROM_COUNT-val"><b>DISJOINT_FROM_COUNT</b></a>]  Theorem
      
      âŠ¢ âˆ€n. DISJOINT (from n) (count n)
   
   [<a name="EQ_T_IMP-val"><b>EQ_T_IMP</b></a>]  Theorem
      
      âŠ¢ âˆ€x. x â‡” T â‡’ x
   
   [<a name="FROM_0-val"><b>FROM_0</b></a>]  Theorem
      
      âŠ¢ from 0 = ğ•Œ(:num)
   
   [<a name="GBIGUNION_IMAGE-val"><b>GBIGUNION_IMAGE</b></a>]  Theorem
      
      âŠ¢ âˆ€s p n. {s | âˆƒn. p s n} = BIGUNION (IMAGE (Î»n. {s | p s n}) ğ•Œ(:Î³))
   
   [<a name="INF_CLOSE-val"><b>INF_CLOSE</b></a>]  Theorem
      
      âŠ¢ âˆ€p e. (âˆƒx. x âˆˆ p) âˆ§ 0 &lt; e â‡’ âˆƒx. x âˆˆ p âˆ§ x &lt; inf p + e
   
   [<a name="INF_DEF_ALT-val"><b>INF_DEF_ALT</b></a>]  Theorem
      
      âŠ¢ âˆ€p. inf p = -sup (Î»r. -r âˆˆ p)
   
   [<a name="INF_GREATER-val"><b>INF_GREATER</b></a>]  Theorem
      
      âŠ¢ âˆ€p z. (âˆƒx. x âˆˆ p) âˆ§ inf p &lt; z â‡’ âˆƒx. x âˆˆ p âˆ§ x &lt; z
   
   [<a name="INF_LE-val"><b>INF_LE</b></a>]  Theorem
      
      âŠ¢ âˆ€p r. (âˆƒz. âˆ€x. x âˆˆ p â‡’ z â‰¤ x) âˆ§ (âˆƒx. x âˆˆ p âˆ§ x â‰¤ r) â‡’ inf p â‰¤ r
   
   [<a name="IN_FROM-val"><b>IN_FROM</b></a>]  Theorem
      
      âŠ¢ âˆ€m n. m âˆˆ from n â‡” n â‰¤ m
   
   [<a name="IN_PAIR-val"><b>IN_PAIR</b></a>]  Theorem
      
      âŠ¢ âˆ€x X Y. x âˆˆ pair X Y â‡” FST x âˆˆ X âˆ§ SND x âˆˆ Y
   
   [<a name="IN_PROD_SETS-val"><b>IN_PROD_SETS</b></a>]  Theorem
      
      âŠ¢ âˆ€s a b. s âˆˆ prod_sets a b â‡” âˆƒt u. (s = t Ã— u) âˆ§ t âˆˆ a âˆ§ u âˆˆ b
   
   [<a name="IN_o-val"><b>IN_o</b></a>]  Theorem
      
      âŠ¢ âˆ€x f s. x âˆˆ s âˆ˜ f â‡” f x âˆˆ s
   
   [<a name="LE_INF-val"><b>LE_INF</b></a>]  Theorem
      
      âŠ¢ âˆ€p r. (âˆƒx. x âˆˆ p) âˆ§ (âˆ€x. x âˆˆ p â‡’ r â‰¤ x) â‡’ r â‰¤ inf p
   
   [<a name="LOGR_MONO_LE-val"><b>LOGR_MONO_LE</b></a>]  Theorem
      
      âŠ¢ âˆ€x y b. 0 &lt; x âˆ§ 0 &lt; y âˆ§ 1 &lt; b â‡’ (logr b x â‰¤ logr b y â‡” x â‰¤ y)
   
   [<a name="LOGR_MONO_LE_IMP-val"><b>LOGR_MONO_LE_IMP</b></a>]  Theorem
      
      âŠ¢ âˆ€x y b. 0 &lt; x âˆ§ x â‰¤ y âˆ§ 1 â‰¤ b â‡’ logr b x â‰¤ logr b y
   
   [<a name="MINIMAL_EQ-val"><b>MINIMAL_EQ</b></a>]  Theorem
      
      âŠ¢ âˆ€p m. p m âˆ§ (m = minimal p) â‡” p m âˆ§ âˆ€n. n &lt; m â‡’ Â¬p n
   
   [<a name="MINIMAL_EQ_IMP-val"><b>MINIMAL_EQ_IMP</b></a>]  Theorem
      
      âŠ¢ âˆ€m p. p m âˆ§ (âˆ€n. n &lt; m â‡’ Â¬p n) â‡’ (m = minimal p)
   
   [<a name="MINIMAL_EXISTS-val"><b>MINIMAL_EXISTS</b></a>]  Theorem
      
      âŠ¢ âˆ€P. (âˆƒn. P n) â‡” P (minimal P) âˆ§ âˆ€n. n &lt; minimal P â‡’ Â¬P n
   
   [<a name="MINIMAL_EXISTS0-val"><b>MINIMAL_EXISTS0</b></a>]  Theorem
      
      âŠ¢ (âˆƒn. P n) â‡” âˆƒn. P n âˆ§ âˆ€m. m &lt; n â‡’ Â¬P m
   
   [<a name="MINIMAL_EXISTS_IMP-val"><b>MINIMAL_EXISTS_IMP</b></a>]  Theorem
      
      âŠ¢ âˆ€P. (âˆƒn. P n) â‡’ âˆƒm. P m âˆ§ âˆ€n. n &lt; m â‡’ Â¬P n
   
   [<a name="MINIMAL_SUC-val"><b>MINIMAL_SUC</b></a>]  Theorem
      
      âŠ¢ âˆ€n p.
            (SUC n = minimal p) âˆ§ p (SUC n) â‡”
            Â¬p 0 âˆ§ (n = minimal (p âˆ˜ SUC)) âˆ§ p (SUC n)
   
   [<a name="MINIMAL_SUC_IMP-val"><b>MINIMAL_SUC_IMP</b></a>]  Theorem
      
      âŠ¢ âˆ€n p.
            p (SUC n) âˆ§ Â¬p 0 âˆ§ (n = minimal (p âˆ˜ SUC)) â‡’
            (SUC n = minimal p)
   
   [<a name="NUM_2D_BIJ-val"><b>NUM_2D_BIJ</b></a>]  Theorem
      
      âŠ¢ âˆƒf. BIJ f (ğ•Œ(:num) Ã— ğ•Œ(:num)) ğ•Œ(:num)
   
   [<a name="NUM_2D_BIJ_INV-val"><b>NUM_2D_BIJ_INV</b></a>]  Theorem
      
      âŠ¢ âˆƒf. BIJ f ğ•Œ(:num) (ğ•Œ(:num) Ã— ğ•Œ(:num))
   
   [<a name="NUM_2D_BIJ_NZ-val"><b>NUM_2D_BIJ_NZ</b></a>]  Theorem
      
      âŠ¢ âˆƒf. BIJ f (ğ•Œ(:num) Ã— (ğ•Œ(:num) DIFF {0})) ğ•Œ(:num)
   
   [<a name="NUM_2D_BIJ_NZ_ALT-val"><b>NUM_2D_BIJ_NZ_ALT</b></a>]  Theorem
      
      âŠ¢ âˆƒf. BIJ f (ğ•Œ(:num) Ã— ğ•Œ(:num)) (ğ•Œ(:num) DIFF {0})
   
   [<a name="NUM_2D_BIJ_NZ_ALT2-val"><b>NUM_2D_BIJ_NZ_ALT2</b></a>]  Theorem
      
      âŠ¢ âˆƒf. BIJ f ((ğ•Œ(:num) DIFF {0}) Ã— (ğ•Œ(:num) DIFF {0})) ğ•Œ(:num)
   
   [<a name="NUM_2D_BIJ_NZ_ALT2_INV-val"><b>NUM_2D_BIJ_NZ_ALT2_INV</b></a>]  Theorem
      
      âŠ¢ âˆƒf. BIJ f ğ•Œ(:num) ((ğ•Œ(:num) DIFF {0}) Ã— (ğ•Œ(:num) DIFF {0}))
   
   [<a name="NUM_2D_BIJ_NZ_ALT_INV-val"><b>NUM_2D_BIJ_NZ_ALT_INV</b></a>]  Theorem
      
      âŠ¢ âˆƒf. BIJ f (ğ•Œ(:num) DIFF {0}) (ğ•Œ(:num) Ã— ğ•Œ(:num))
   
   [<a name="NUM_2D_BIJ_NZ_INV-val"><b>NUM_2D_BIJ_NZ_INV</b></a>]  Theorem
      
      âŠ¢ âˆƒf. BIJ f ğ•Œ(:num) (ğ•Œ(:num) Ã— (ğ•Œ(:num) DIFF {0}))
   
   [<a name="PAIRED_BETA_THM-val"><b>PAIRED_BETA_THM</b></a>]  Theorem
      
      âŠ¢ âˆ€f z. UNCURRY f z = f (FST z) (SND z)
   
   [<a name="PAIR_UNIV-val"><b>PAIR_UNIV</b></a>]  Theorem
      
      âŠ¢ pair ğ•Œ(:Î±) ğ•Œ(:Î²) = ğ•Œ(:Î± # Î²)
   
   [<a name="POW_HALF_MONO-val"><b>POW_HALF_MONO</b></a>]  Theorem
      
      âŠ¢ âˆ€m n. m â‰¤ n â‡’ (1 / 2) pow n â‰¤ (1 / 2) pow m
   
   [<a name="POW_HALF_POS-val"><b>POW_HALF_POS</b></a>]  Theorem
      
      âŠ¢ âˆ€n. 0 &lt; (1 / 2) pow n
   
   [<a name="POW_HALF_SMALL-val"><b>POW_HALF_SMALL</b></a>]  Theorem
      
      âŠ¢ âˆ€e. 0 &lt; e â‡’ âˆƒn. (1 / 2) pow n &lt; e
   
   [<a name="POW_NEG_ODD-val"><b>POW_NEG_ODD</b></a>]  Theorem
      
      âŠ¢ âˆ€x. x &lt; 0 â‡’ (x pow n &lt; 0 â‡” ODD n)
   
   [<a name="POW_POS_EVEN-val"><b>POW_POS_EVEN</b></a>]  Theorem
      
      âŠ¢ âˆ€x. x &lt; 0 â‡’ (0 &lt; x pow n â‡” EVEN n)
   
   [<a name="PREIMAGE_REAL_COMPL1-val"><b>PREIMAGE_REAL_COMPL1</b></a>]  Theorem
      
      âŠ¢ âˆ€c. COMPL {x | c &lt; x} = {x | x â‰¤ c}
   
   [<a name="PREIMAGE_REAL_COMPL2-val"><b>PREIMAGE_REAL_COMPL2</b></a>]  Theorem
      
      âŠ¢ âˆ€c. COMPL {x | c â‰¤ x} = {x | x &lt; c}
   
   [<a name="PREIMAGE_REAL_COMPL3-val"><b>PREIMAGE_REAL_COMPL3</b></a>]  Theorem
      
      âŠ¢ âˆ€c. COMPL {x | x â‰¤ c} = {x | c &lt; x}
   
   [<a name="PREIMAGE_REAL_COMPL4-val"><b>PREIMAGE_REAL_COMPL4</b></a>]  Theorem
      
      âŠ¢ âˆ€c. COMPL {x | x &lt; c} = {x | c â‰¤ x}
   
   [<a name="REAL_LE_LT_MUL-val"><b>REAL_LE_LT_MUL</b></a>]  Theorem
      
      âŠ¢ âˆ€x y. 0 â‰¤ x âˆ§ 0 &lt; y â‡’ 0 â‰¤ x * y
   
   [<a name="REAL_LE_RDIV_EQ_NEG-val"><b>REAL_LE_RDIV_EQ_NEG</b></a>]  Theorem
      
      âŠ¢ âˆ€x y z. z &lt; 0 â‡’ (y / z â‰¤ x â‡” x * z â‰¤ y)
   
   [<a name="REAL_LT_LE_MUL-val"><b>REAL_LT_LE_MUL</b></a>]  Theorem
      
      âŠ¢ âˆ€x y. 0 &lt; x âˆ§ 0 â‰¤ y â‡’ 0 â‰¤ x * y
   
   [<a name="REAL_LT_LMUL_0_NEG-val"><b>REAL_LT_LMUL_0_NEG</b></a>]  Theorem
      
      âŠ¢ âˆ€x y. 0 &lt; x * y âˆ§ x &lt; 0 â‡’ y &lt; 0
   
   [<a name="REAL_LT_LMUL_NEG_0-val"><b>REAL_LT_LMUL_NEG_0</b></a>]  Theorem
      
      âŠ¢ âˆ€x y. x * y &lt; 0 âˆ§ 0 &lt; x â‡’ y &lt; 0
   
   [<a name="REAL_LT_LMUL_NEG_0_NEG-val"><b>REAL_LT_LMUL_NEG_0_NEG</b></a>]  Theorem
      
      âŠ¢ âˆ€x y. x * y &lt; 0 âˆ§ x &lt; 0 â‡’ 0 &lt; y
   
   [<a name="REAL_LT_RDIV_EQ_NEG-val"><b>REAL_LT_RDIV_EQ_NEG</b></a>]  Theorem
      
      âŠ¢ âˆ€x y z. z &lt; 0 â‡’ (y / z &lt; x â‡” x * z &lt; y)
   
   [<a name="REAL_LT_RMUL_0_NEG-val"><b>REAL_LT_RMUL_0_NEG</b></a>]  Theorem
      
      âŠ¢ âˆ€x y. 0 &lt; x * y âˆ§ y &lt; 0 â‡’ x &lt; 0
   
   [<a name="REAL_LT_RMUL_NEG_0-val"><b>REAL_LT_RMUL_NEG_0</b></a>]  Theorem
      
      âŠ¢ âˆ€x y. x * y &lt; 0 âˆ§ 0 &lt; y â‡’ x &lt; 0
   
   [<a name="REAL_LT_RMUL_NEG_0_NEG-val"><b>REAL_LT_RMUL_NEG_0_NEG</b></a>]  Theorem
      
      âŠ¢ âˆ€x y. x * y &lt; 0 âˆ§ y &lt; 0 â‡’ 0 &lt; x
   
   [<a name="REAL_MUL_IDEMPOT-val"><b>REAL_MUL_IDEMPOT</b></a>]  Theorem
      
      âŠ¢ âˆ€r. (r * r = r) â‡” (r = 0) âˆ¨ (r = 1)
   
   [<a name="REAL_NEG_NZ-val"><b>REAL_NEG_NZ</b></a>]  Theorem
      
      âŠ¢ âˆ€x. x &lt; 0 â‡’ x â‰  0
   
   [<a name="REAL_SUP_LE_X-val"><b>REAL_SUP_LE_X</b></a>]  Theorem
      
      âŠ¢ âˆ€P x. (âˆƒr. P r) âˆ§ (âˆ€r. P r â‡’ r â‰¤ x) â‡’ sup P â‰¤ x
   
   [<a name="REAL_X_LE_SUP-val"><b>REAL_X_LE_SUP</b></a>]  Theorem
      
      âŠ¢ âˆ€P x.
            (âˆƒr. P r) âˆ§ (âˆƒz. âˆ€r. P r â‡’ r â‰¤ z) âˆ§ (âˆƒr. P r âˆ§ x â‰¤ r) â‡’
            x â‰¤ sup P
   
   [<a name="UNION_COUNT_FROM-val"><b>UNION_COUNT_FROM</b></a>]  Theorem
      
      âŠ¢ âˆ€n. count n âˆª from n = ğ•Œ(:num)
   
   [<a name="UNION_FROM_COUNT-val"><b>UNION_FROM_COUNT</b></a>]  Theorem
      
      âŠ¢ âˆ€n. from n âˆª count n = ğ•Œ(:num)
   
   [<a name="disjointD-val"><b>disjointD</b></a>]  Theorem
      
      âŠ¢ âˆ€A a b. disjoint A â‡’ a âˆˆ A â‡’ b âˆˆ A â‡’ a â‰  b â‡’ DISJOINT a b
   
   [<a name="disjointI-val"><b>disjointI</b></a>]  Theorem
      
      âŠ¢ âˆ€A. (âˆ€a b. a âˆˆ A â‡’ b âˆˆ A â‡’ a â‰  b â‡’ DISJOINT a b) â‡’ disjoint A
   
   [<a name="disjoint_empty-val"><b>disjoint_empty</b></a>]  Theorem
      
      âŠ¢ disjoint âˆ…
   
   [<a name="disjoint_sing-val"><b>disjoint_sing</b></a>]  Theorem
      
      âŠ¢ âˆ€a. disjoint {a}
   
   [<a name="disjoint_union-val"><b>disjoint_union</b></a>]  Theorem
      
      âŠ¢ âˆ€A B.
            disjoint A âˆ§ disjoint B âˆ§ (BIGUNION A âˆ© BIGUNION B = âˆ…) â‡’
            disjoint (A âˆª B)
   
   [<a name="finite_enumeration_of_sets_has_max_non_empty-val"><b>finite_enumeration_of_sets_has_max_non_empty</b></a>]  Theorem
      
      âŠ¢ âˆ€f s.
            FINITE s âˆ§ (âˆ€x. f x âˆˆ s) âˆ§ (âˆ€m n. m â‰  n â‡’ DISJOINT (f m) (f n)) â‡’
            âˆƒN. âˆ€n. n â‰¥ N â‡’ (f n = âˆ…)
   
   [<a name="lg_1-val"><b>lg_1</b></a>]  Theorem
      
      âŠ¢ lg 1 = 0
   
   [<a name="lg_2-val"><b>lg_2</b></a>]  Theorem
      
      âŠ¢ lg 2 = 1
   
   [<a name="lg_inv-val"><b>lg_inv</b></a>]  Theorem
      
      âŠ¢ âˆ€x. 0 &lt; x â‡’ (lg xâ»Â¹ = -lg x)
   
   [<a name="lg_mul-val"><b>lg_mul</b></a>]  Theorem
      
      âŠ¢ âˆ€x y. 0 &lt; x âˆ§ 0 &lt; y â‡’ (lg (x * y) = lg x + lg y)
   
   [<a name="lg_nonzero-val"><b>lg_nonzero</b></a>]  Theorem
      
      âŠ¢ âˆ€x. x â‰  0 âˆ§ 0 â‰¤ x â‡’ (lg x â‰  0 â‡” x â‰  1)
   
   [<a name="lg_pow-val"><b>lg_pow</b></a>]  Theorem
      
      âŠ¢ âˆ€n. lg (2 pow n) = &n
   
   [<a name="logr_1-val"><b>logr_1</b></a>]  Theorem
      
      âŠ¢ âˆ€b. logr b 1 = 0
   
   [<a name="logr_div-val"><b>logr_div</b></a>]  Theorem
      
      âŠ¢ âˆ€b x y. 0 &lt; x âˆ§ 0 &lt; y â‡’ (logr b (x / y) = logr b x âˆ’ logr b y)
   
   [<a name="logr_inv-val"><b>logr_inv</b></a>]  Theorem
      
      âŠ¢ âˆ€b x. 0 &lt; x â‡’ (logr b xâ»Â¹ = -logr b x)
   
   [<a name="logr_mul-val"><b>logr_mul</b></a>]  Theorem
      
      âŠ¢ âˆ€b x y. 0 &lt; x âˆ§ 0 &lt; y â‡’ (logr b (x * y) = logr b x + logr b y)
   
   [<a name="neg_lg-val"><b>neg_lg</b></a>]  Theorem
      
      âŠ¢ âˆ€x. 0 &lt; x â‡’ (-lg x = lg xâ»Â¹)
   
   [<a name="neg_logr-val"><b>neg_logr</b></a>]  Theorem
      
      âŠ¢ âˆ€b x. 0 &lt; x â‡’ (-logr b x = logr b xâ»Â¹)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/probability/util_probScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-13</a></em></p></body></html>
