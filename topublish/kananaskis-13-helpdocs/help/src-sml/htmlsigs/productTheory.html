<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure productTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure productTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/probability/productScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature productTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#nproduct-val">nproduct</a> : thm
<a name="line7"></a>    val <a href="#product-val">product</a> : thm
<a name="line8"></a>  
<a name="line9"></a>  (*  Theorems  *)
<a name="line10"></a>    val <a href="#MULT_AC-val">MULT_AC</a> : thm
<a name="line11"></a>    val <a href="#NPRODUCT_ADD_SPLIT-val">NPRODUCT_ADD_SPLIT</a> : thm
<a name="line12"></a>    val <a href="#NPRODUCT_CLAUSES-val">NPRODUCT_CLAUSES</a> : thm
<a name="line13"></a>    val <a href="#NPRODUCT_CLAUSES_LEFT-val">NPRODUCT_CLAUSES_LEFT</a> : thm
<a name="line14"></a>    val <a href="#NPRODUCT_CLAUSES_NUMSEG-val">NPRODUCT_CLAUSES_NUMSEG</a> : thm
<a name="line15"></a>    val <a href="#NPRODUCT_CLAUSES_RIGHT-val">NPRODUCT_CLAUSES_RIGHT</a> : thm
<a name="line16"></a>    val <a href="#NPRODUCT_CLOSED-val">NPRODUCT_CLOSED</a> : thm
<a name="line17"></a>    val <a href="#NPRODUCT_CONST-val">NPRODUCT_CONST</a> : thm
<a name="line18"></a>    val <a href="#NPRODUCT_CONST_NUMSEG-val">NPRODUCT_CONST_NUMSEG</a> : thm
<a name="line19"></a>    val <a href="#NPRODUCT_CONST_NUMSEG_1-val">NPRODUCT_CONST_NUMSEG_1</a> : thm
<a name="line20"></a>    val <a href="#NPRODUCT_DELETE-val">NPRODUCT_DELETE</a> : thm
<a name="line21"></a>    val <a href="#NPRODUCT_DELTA-val">NPRODUCT_DELTA</a> : thm
<a name="line22"></a>    val <a href="#NPRODUCT_EQ-val">NPRODUCT_EQ</a> : thm
<a name="line23"></a>    val <a href="#NPRODUCT_EQ_0-val">NPRODUCT_EQ_0</a> : thm
<a name="line24"></a>    val <a href="#NPRODUCT_EQ_0_NUMSEG-val">NPRODUCT_EQ_0_NUMSEG</a> : thm
<a name="line25"></a>    val <a href="#NPRODUCT_EQ_1-val">NPRODUCT_EQ_1</a> : thm
<a name="line26"></a>    val <a href="#NPRODUCT_EQ_1_NUMSEG-val">NPRODUCT_EQ_1_NUMSEG</a> : thm
<a name="line27"></a>    val <a href="#NPRODUCT_EQ_NUMSEG-val">NPRODUCT_EQ_NUMSEG</a> : thm
<a name="line28"></a>    val <a href="#NPRODUCT_FACT-val">NPRODUCT_FACT</a> : thm
<a name="line29"></a>    val <a href="#NPRODUCT_IMAGE-val">NPRODUCT_IMAGE</a> : thm
<a name="line30"></a>    val <a href="#NPRODUCT_LE-val">NPRODUCT_LE</a> : thm
<a name="line31"></a>    val <a href="#NPRODUCT_LE_NUMSEG-val">NPRODUCT_LE_NUMSEG</a> : thm
<a name="line32"></a>    val <a href="#NPRODUCT_MUL-val">NPRODUCT_MUL</a> : thm
<a name="line33"></a>    val <a href="#NPRODUCT_MUL_GEN-val">NPRODUCT_MUL_GEN</a> : thm
<a name="line34"></a>    val <a href="#NPRODUCT_MUL_NUMSEG-val">NPRODUCT_MUL_NUMSEG</a> : thm
<a name="line35"></a>    val <a href="#NPRODUCT_OFFSET-val">NPRODUCT_OFFSET</a> : thm
<a name="line36"></a>    val <a href="#NPRODUCT_ONE-val">NPRODUCT_ONE</a> : thm
<a name="line37"></a>    val <a href="#NPRODUCT_PAIR-val">NPRODUCT_PAIR</a> : thm
<a name="line38"></a>    val <a href="#NPRODUCT_POS_LT-val">NPRODUCT_POS_LT</a> : thm
<a name="line39"></a>    val <a href="#NPRODUCT_POS_LT_NUMSEG-val">NPRODUCT_POS_LT_NUMSEG</a> : thm
<a name="line40"></a>    val <a href="#NPRODUCT_SING-val">NPRODUCT_SING</a> : thm
<a name="line41"></a>    val <a href="#NPRODUCT_SING_NUMSEG-val">NPRODUCT_SING_NUMSEG</a> : thm
<a name="line42"></a>    val <a href="#NPRODUCT_SUPERSET-val">NPRODUCT_SUPERSET</a> : thm
<a name="line43"></a>    val <a href="#NPRODUCT_SUPPORT-val">NPRODUCT_SUPPORT</a> : thm
<a name="line44"></a>    val <a href="#NPRODUCT_UNION-val">NPRODUCT_UNION</a> : thm
<a name="line45"></a>    val <a href="#PRODUCT_ABS-val">PRODUCT_ABS</a> : thm
<a name="line46"></a>    val <a href="#PRODUCT_ADD_SPLIT-val">PRODUCT_ADD_SPLIT</a> : thm
<a name="line47"></a>    val <a href="#PRODUCT_CLAUSES-val">PRODUCT_CLAUSES</a> : thm
<a name="line48"></a>    val <a href="#PRODUCT_CLAUSES_LEFT-val">PRODUCT_CLAUSES_LEFT</a> : thm
<a name="line49"></a>    val <a href="#PRODUCT_CLAUSES_NUMSEG-val">PRODUCT_CLAUSES_NUMSEG</a> : thm
<a name="line50"></a>    val <a href="#PRODUCT_CLAUSES_RIGHT-val">PRODUCT_CLAUSES_RIGHT</a> : thm
<a name="line51"></a>    val <a href="#PRODUCT_CLOSED-val">PRODUCT_CLOSED</a> : thm
<a name="line52"></a>    val <a href="#PRODUCT_CONG-val">PRODUCT_CONG</a> : thm
<a name="line53"></a>    val <a href="#PRODUCT_CONST-val">PRODUCT_CONST</a> : thm
<a name="line54"></a>    val <a href="#PRODUCT_CONST_NUMSEG-val">PRODUCT_CONST_NUMSEG</a> : thm
<a name="line55"></a>    val <a href="#PRODUCT_CONST_NUMSEG_1-val">PRODUCT_CONST_NUMSEG_1</a> : thm
<a name="line56"></a>    val <a href="#PRODUCT_DELETE-val">PRODUCT_DELETE</a> : thm
<a name="line57"></a>    val <a href="#PRODUCT_DELTA-val">PRODUCT_DELTA</a> : thm
<a name="line58"></a>    val <a href="#PRODUCT_DIV-val">PRODUCT_DIV</a> : thm
<a name="line59"></a>    val <a href="#PRODUCT_DIV_NUMSEG-val">PRODUCT_DIV_NUMSEG</a> : thm
<a name="line60"></a>    val <a href="#PRODUCT_EQ-val">PRODUCT_EQ</a> : thm
<a name="line61"></a>    val <a href="#PRODUCT_EQ_0-val">PRODUCT_EQ_0</a> : thm
<a name="line62"></a>    val <a href="#PRODUCT_EQ_0_NUMSEG-val">PRODUCT_EQ_0_NUMSEG</a> : thm
<a name="line63"></a>    val <a href="#PRODUCT_EQ_1-val">PRODUCT_EQ_1</a> : thm
<a name="line64"></a>    val <a href="#PRODUCT_EQ_1_NUMSEG-val">PRODUCT_EQ_1_NUMSEG</a> : thm
<a name="line65"></a>    val <a href="#PRODUCT_EQ_NUMSEG-val">PRODUCT_EQ_NUMSEG</a> : thm
<a name="line66"></a>    val <a href="#PRODUCT_IMAGE-val">PRODUCT_IMAGE</a> : thm
<a name="line67"></a>    val <a href="#PRODUCT_INV-val">PRODUCT_INV</a> : thm
<a name="line68"></a>    val <a href="#PRODUCT_LE-val">PRODUCT_LE</a> : thm
<a name="line69"></a>    val <a href="#PRODUCT_LE_1-val">PRODUCT_LE_1</a> : thm
<a name="line70"></a>    val <a href="#PRODUCT_LE_NUMSEG-val">PRODUCT_LE_NUMSEG</a> : thm
<a name="line71"></a>    val <a href="#PRODUCT_MUL-val">PRODUCT_MUL</a> : thm
<a name="line72"></a>    val <a href="#PRODUCT_MUL_GEN-val">PRODUCT_MUL_GEN</a> : thm
<a name="line73"></a>    val <a href="#PRODUCT_MUL_NUMSEG-val">PRODUCT_MUL_NUMSEG</a> : thm
<a name="line74"></a>    val <a href="#PRODUCT_NEG-val">PRODUCT_NEG</a> : thm
<a name="line75"></a>    val <a href="#PRODUCT_NEG_NUMSEG-val">PRODUCT_NEG_NUMSEG</a> : thm
<a name="line76"></a>    val <a href="#PRODUCT_NEG_NUMSEG_1-val">PRODUCT_NEG_NUMSEG_1</a> : thm
<a name="line77"></a>    val <a href="#PRODUCT_OFFSET-val">PRODUCT_OFFSET</a> : thm
<a name="line78"></a>    val <a href="#PRODUCT_ONE-val">PRODUCT_ONE</a> : thm
<a name="line79"></a>    val <a href="#PRODUCT_PAIR-val">PRODUCT_PAIR</a> : thm
<a name="line80"></a>    val <a href="#PRODUCT_POS_LE-val">PRODUCT_POS_LE</a> : thm
<a name="line81"></a>    val <a href="#PRODUCT_POS_LE_NUMSEG-val">PRODUCT_POS_LE_NUMSEG</a> : thm
<a name="line82"></a>    val <a href="#PRODUCT_POS_LT-val">PRODUCT_POS_LT</a> : thm
<a name="line83"></a>    val <a href="#PRODUCT_POS_LT_NUMSEG-val">PRODUCT_POS_LT_NUMSEG</a> : thm
<a name="line84"></a>    val <a href="#PRODUCT_SING-val">PRODUCT_SING</a> : thm
<a name="line85"></a>    val <a href="#PRODUCT_SING_NUMSEG-val">PRODUCT_SING_NUMSEG</a> : thm
<a name="line86"></a>    val <a href="#PRODUCT_SUPERSET-val">PRODUCT_SUPERSET</a> : thm
<a name="line87"></a>    val <a href="#PRODUCT_SUPPORT-val">PRODUCT_SUPPORT</a> : thm
<a name="line88"></a>    val <a href="#PRODUCT_UNION-val">PRODUCT_UNION</a> : thm
<a name="line89"></a>    val <a href="#REAL_ADD_AC-val">REAL_ADD_AC</a> : thm
<a name="line90"></a>    val <a href="#REAL_OF_NUM_NPRODUCT-val">REAL_OF_NUM_NPRODUCT</a> : thm
<a name="line91"></a>    val <a href="#th-val">th</a> : thm
<a name="line92"></a>  
<a name="line93"></a>  val product_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line94"></a>(*
   [iterate] Parent theory of "product"
   
   [<a name="nproduct-val"><b>nproduct</b></a>]  Definition
      
      ⊢ nproduct = iterate $*
   
   [<a name="product-val"><b>product</b></a>]  Definition
      
      ⊢ product = iterate $*
   
   [<a name="MULT_AC-val"><b>MULT_AC</b></a>]  Theorem
      
      ⊢ m * n = n * m ∧ m * n * p = m * (n * p) ∧ m * (n * p) = n * (m * p)
   
   [<a name="NPRODUCT_ADD_SPLIT-val"><b>NPRODUCT_ADD_SPLIT</b></a>]  Theorem
      
      ⊢ ∀f m n p.
            m ≤ n + 1 ⇒
            nproduct (m .. n + p) f =
            nproduct (m .. n) f * nproduct (n + 1 .. n + p) f
   
   [<a name="NPRODUCT_CLAUSES-val"><b>NPRODUCT_CLAUSES</b></a>]  Theorem
      
      ⊢ (∀f. nproduct ∅ f = 1) ∧
        ∀x f s.
            FINITE s ⇒
            nproduct (x INSERT s) f =
            if x ∈ s then nproduct s f else f x * nproduct s f
   
   [<a name="NPRODUCT_CLAUSES_LEFT-val"><b>NPRODUCT_CLAUSES_LEFT</b></a>]  Theorem
      
      ⊢ ∀f m n. m ≤ n ⇒ nproduct (m .. n) f = f m * nproduct (m + 1 .. n) f
   
   [<a name="NPRODUCT_CLAUSES_NUMSEG-val"><b>NPRODUCT_CLAUSES_NUMSEG</b></a>]  Theorem
      
      ⊢ (∀m. nproduct (m .. 0) f = if m = 0 then f 0 else 1) ∧
        ∀m n.
            nproduct (m .. SUC n) f =
            if m ≤ SUC n then nproduct (m .. n) f * f (SUC n)
            else nproduct (m .. n) f
   
   [<a name="NPRODUCT_CLAUSES_RIGHT-val"><b>NPRODUCT_CLAUSES_RIGHT</b></a>]  Theorem
      
      ⊢ ∀f m n.
            0 &lt; n ∧ m ≤ n ⇒
            nproduct (m .. n) f = nproduct (m .. n − 1) f * f n
   
   [<a name="NPRODUCT_CLOSED-val"><b>NPRODUCT_CLOSED</b></a>]  Theorem
      
      ⊢ ∀P f s.
            P 1 ∧ (∀x y. P x ∧ P y ⇒ P (x * y)) ∧ (∀a. a ∈ s ⇒ P (f a)) ⇒
            P (nproduct s f)
   
   [<a name="NPRODUCT_CONST-val"><b>NPRODUCT_CONST</b></a>]  Theorem
      
      ⊢ ∀c s. FINITE s ⇒ nproduct s (λx. c) = c ** CARD s
   
   [<a name="NPRODUCT_CONST_NUMSEG-val"><b>NPRODUCT_CONST_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀c m n. nproduct (m .. n) (λx. c) = c ** (n + 1 − m)
   
   [<a name="NPRODUCT_CONST_NUMSEG_1-val"><b>NPRODUCT_CONST_NUMSEG_1</b></a>]  Theorem
      
      ⊢ ∀c n. nproduct (1 .. n) (λx. c) = c ** n
   
   [<a name="NPRODUCT_DELETE-val"><b>NPRODUCT_DELETE</b></a>]  Theorem
      
      ⊢ ∀f s a.
            FINITE s ∧ a ∈ s ⇒ f a * nproduct (s DELETE a) f = nproduct s f
   
   [<a name="NPRODUCT_DELTA-val"><b>NPRODUCT_DELTA</b></a>]  Theorem
      
      ⊢ ∀s a.
            nproduct s (λx. if x = a then b else 1) =
            if a ∈ s then b else 1
   
   [<a name="NPRODUCT_EQ-val"><b>NPRODUCT_EQ</b></a>]  Theorem
      
      ⊢ ∀f g s. (∀x. x ∈ s ⇒ f x = g x) ⇒ nproduct s f = nproduct s g
   
   [<a name="NPRODUCT_EQ_0-val"><b>NPRODUCT_EQ_0</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ⇒ (nproduct s f = 0 ⇔ ∃x. x ∈ s ∧ f x = 0)
   
   [<a name="NPRODUCT_EQ_0_NUMSEG-val"><b>NPRODUCT_EQ_0_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n. nproduct (m .. n) f = 0 ⇔ ∃x. m ≤ x ∧ x ≤ n ∧ f x = 0
   
   [<a name="NPRODUCT_EQ_1-val"><b>NPRODUCT_EQ_1</b></a>]  Theorem
      
      ⊢ ∀f s. (∀x. x ∈ s ⇒ f x = 1) ⇒ nproduct s f = 1
   
   [<a name="NPRODUCT_EQ_1_NUMSEG-val"><b>NPRODUCT_EQ_1_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n. (∀i. m ≤ i ∧ i ≤ n ⇒ f i = 1) ⇒ nproduct (m .. n) f = 1
   
   [<a name="NPRODUCT_EQ_NUMSEG-val"><b>NPRODUCT_EQ_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f g m n.
            (∀i. m ≤ i ∧ i ≤ n ⇒ f i = g i) ⇒
            nproduct (m .. n) f = nproduct (m .. n) g
   
   [<a name="NPRODUCT_FACT-val"><b>NPRODUCT_FACT</b></a>]  Theorem
      
      ⊢ ∀n. nproduct (1 .. n) (λm. m) = FACT n
   
   [<a name="NPRODUCT_IMAGE-val"><b>NPRODUCT_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f g s.
            (∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y) ⇒
            nproduct (IMAGE f s) g = nproduct s (g ∘ f)
   
   [<a name="NPRODUCT_LE-val"><b>NPRODUCT_LE</b></a>]  Theorem
      
      ⊢ ∀f s.
            FINITE s ∧ (∀x. x ∈ s ⇒ 0 ≤ f x ∧ f x ≤ g x) ⇒
            nproduct s f ≤ nproduct s g
   
   [<a name="NPRODUCT_LE_NUMSEG-val"><b>NPRODUCT_LE_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n.
            (∀i. m ≤ i ∧ i ≤ n ⇒ 0 ≤ f i ∧ f i ≤ g i) ⇒
            nproduct (m .. n) f ≤ nproduct (m .. n) g
   
   [<a name="NPRODUCT_MUL-val"><b>NPRODUCT_MUL</b></a>]  Theorem
      
      ⊢ ∀f g s.
            FINITE s ⇒
            nproduct s (λx. f x * g x) = nproduct s f * nproduct s g
   
   [<a name="NPRODUCT_MUL_GEN-val"><b>NPRODUCT_MUL_GEN</b></a>]  Theorem
      
      ⊢ ∀f g s.
            FINITE {x | x ∈ s ∧ f x ≠ 1} ∧ FINITE {x | x ∈ s ∧ g x ≠ 1} ⇒
            nproduct s (λx. f x * g x) = nproduct s f * nproduct s g
   
   [<a name="NPRODUCT_MUL_NUMSEG-val"><b>NPRODUCT_MUL_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f g m n.
            nproduct (m .. n) (λx. f x * g x) =
            nproduct (m .. n) f * nproduct (m .. n) g
   
   [<a name="NPRODUCT_OFFSET-val"><b>NPRODUCT_OFFSET</b></a>]  Theorem
      
      ⊢ ∀f m p.
            nproduct (m + p .. n + p) f = nproduct (m .. n) (λi. f (i + p))
   
   [<a name="NPRODUCT_ONE-val"><b>NPRODUCT_ONE</b></a>]  Theorem
      
      ⊢ ∀s. nproduct s (λn. 1) = 1
   
   [<a name="NPRODUCT_PAIR-val"><b>NPRODUCT_PAIR</b></a>]  Theorem
      
      ⊢ ∀f m n.
            nproduct (2 * m .. 2 * n + 1) f =
            nproduct (m .. n) (λi. f (2 * i) * f (2 * i + 1))
   
   [<a name="NPRODUCT_POS_LT-val"><b>NPRODUCT_POS_LT</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ∧ (∀x. x ∈ s ⇒ 0 &lt; f x) ⇒ 0 &lt; nproduct s f
   
   [<a name="NPRODUCT_POS_LT_NUMSEG-val"><b>NPRODUCT_POS_LT_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n. (∀x. m ≤ x ∧ x ≤ n ⇒ 0 &lt; f x) ⇒ 0 &lt; nproduct (m .. n) f
   
   [<a name="NPRODUCT_SING-val"><b>NPRODUCT_SING</b></a>]  Theorem
      
      ⊢ ∀f x. nproduct {x} f = f x
   
   [<a name="NPRODUCT_SING_NUMSEG-val"><b>NPRODUCT_SING_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f n. nproduct (n .. n) f = f n
   
   [<a name="NPRODUCT_SUPERSET-val"><b>NPRODUCT_SUPERSET</b></a>]  Theorem
      
      ⊢ ∀f u v.
            u ⊆ v ∧ (∀x. x ∈ v ∧ x ∉ u ⇒ f x = 1) ⇒
            nproduct v f = nproduct u f
   
   [<a name="NPRODUCT_SUPPORT-val"><b>NPRODUCT_SUPPORT</b></a>]  Theorem
      
      ⊢ ∀f s. nproduct (support $* f s) f = nproduct s f
   
   [<a name="NPRODUCT_UNION-val"><b>NPRODUCT_UNION</b></a>]  Theorem
      
      ⊢ ∀f s t.
            FINITE s ∧ FINITE t ∧ DISJOINT s t ⇒
            nproduct (s ∪ t) f = nproduct s f * nproduct t f
   
   [<a name="PRODUCT_ABS-val"><b>PRODUCT_ABS</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ⇒ product s (λx. abs (f x)) = abs (product s f)
   
   [<a name="PRODUCT_ADD_SPLIT-val"><b>PRODUCT_ADD_SPLIT</b></a>]  Theorem
      
      ⊢ ∀f m n p.
            m ≤ n + 1 ⇒
            product (m .. n + p) f =
            product (m .. n) f * product (n + 1 .. n + p) f
   
   [<a name="PRODUCT_CLAUSES-val"><b>PRODUCT_CLAUSES</b></a>]  Theorem
      
      ⊢ (∀f. product ∅ f = 1) ∧
        ∀x f s.
            FINITE s ⇒
            product (x INSERT s) f =
            if x ∈ s then product s f else f x * product s f
   
   [<a name="PRODUCT_CLAUSES_LEFT-val"><b>PRODUCT_CLAUSES_LEFT</b></a>]  Theorem
      
      ⊢ ∀f m n. m ≤ n ⇒ product (m .. n) f = f m * product (m + 1 .. n) f
   
   [<a name="PRODUCT_CLAUSES_NUMSEG-val"><b>PRODUCT_CLAUSES_NUMSEG</b></a>]  Theorem
      
      ⊢ (∀m. product (m .. 0) f = if m = 0 then f 0 else 1) ∧
        ∀m n.
            product (m .. SUC n) f =
            if m ≤ SUC n then product (m .. n) f * f (SUC n)
            else product (m .. n) f
   
   [<a name="PRODUCT_CLAUSES_RIGHT-val"><b>PRODUCT_CLAUSES_RIGHT</b></a>]  Theorem
      
      ⊢ ∀f m n.
            0 &lt; n ∧ m ≤ n ⇒
            product (m .. n) f = product (m .. n − 1) f * f n
   
   [<a name="PRODUCT_CLOSED-val"><b>PRODUCT_CLOSED</b></a>]  Theorem
      
      ⊢ ∀P f s.
            P 1 ∧ (∀x y. P x ∧ P y ⇒ P (x * y)) ∧ (∀a. a ∈ s ⇒ P (f a)) ⇒
            P (product s f)
   
   [<a name="PRODUCT_CONG-val"><b>PRODUCT_CONG</b></a>]  Theorem
      
      ⊢ (∀f g s.
             (∀x. x ∈ s ⇒ f x = g x) ⇒ product s (λi. f i) = product s g) ∧
        (∀f g a b.
             (∀i. a ≤ i ∧ i ≤ b ⇒ f i = g i) ⇒
             product (a .. b) (λi. f i) = product (a .. b) g) ∧
        ∀f g p.
            (∀x. p x ⇒ f x = g x) ⇒
            product {y | p y} (λi. f i) = product {y | p y} g
   
   [<a name="PRODUCT_CONST-val"><b>PRODUCT_CONST</b></a>]  Theorem
      
      ⊢ ∀c s. FINITE s ⇒ product s (λx. c) = c pow CARD s
   
   [<a name="PRODUCT_CONST_NUMSEG-val"><b>PRODUCT_CONST_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀c m n. product (m .. n) (λx. c) = c pow (n + 1 − m)
   
   [<a name="PRODUCT_CONST_NUMSEG_1-val"><b>PRODUCT_CONST_NUMSEG_1</b></a>]  Theorem
      
      ⊢ ∀c n. product (1 .. n) (λx. c) = c pow n
   
   [<a name="PRODUCT_DELETE-val"><b>PRODUCT_DELETE</b></a>]  Theorem
      
      ⊢ ∀f s a.
            FINITE s ∧ a ∈ s ⇒ f a * product (s DELETE a) f = product s f
   
   [<a name="PRODUCT_DELTA-val"><b>PRODUCT_DELTA</b></a>]  Theorem
      
      ⊢ ∀s a.
            product s (λx. if x = a then b else 1) = if a ∈ s then b else 1
   
   [<a name="PRODUCT_DIV-val"><b>PRODUCT_DIV</b></a>]  Theorem
      
      ⊢ ∀f g s.
            FINITE s ⇒
            product s (λx. f x / g x) = product s f / product s g
   
   [<a name="PRODUCT_DIV_NUMSEG-val"><b>PRODUCT_DIV_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f g m n.
            product (m .. n) (λx. f x / g x) =
            product (m .. n) f / product (m .. n) g
   
   [<a name="PRODUCT_EQ-val"><b>PRODUCT_EQ</b></a>]  Theorem
      
      ⊢ ∀f g s. (∀x. x ∈ s ⇒ f x = g x) ⇒ product s f = product s g
   
   [<a name="PRODUCT_EQ_0-val"><b>PRODUCT_EQ_0</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ⇒ (product s f = 0 ⇔ ∃x. x ∈ s ∧ f x = 0)
   
   [<a name="PRODUCT_EQ_0_NUMSEG-val"><b>PRODUCT_EQ_0_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n. product (m .. n) f = 0 ⇔ ∃x. m ≤ x ∧ x ≤ n ∧ f x = 0
   
   [<a name="PRODUCT_EQ_1-val"><b>PRODUCT_EQ_1</b></a>]  Theorem
      
      ⊢ ∀f s. (∀x. x ∈ s ⇒ f x = 1) ⇒ product s f = 1
   
   [<a name="PRODUCT_EQ_1_NUMSEG-val"><b>PRODUCT_EQ_1_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n. (∀i. m ≤ i ∧ i ≤ n ⇒ f i = 1) ⇒ product (m .. n) f = 1
   
   [<a name="PRODUCT_EQ_NUMSEG-val"><b>PRODUCT_EQ_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f g m n.
            (∀i. m ≤ i ∧ i ≤ n ⇒ f i = g i) ⇒
            product (m .. n) f = product (m .. n) g
   
   [<a name="PRODUCT_IMAGE-val"><b>PRODUCT_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f g s.
            (∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y) ⇒
            product (IMAGE f s) g = product s (g ∘ f)
   
   [<a name="PRODUCT_INV-val"><b>PRODUCT_INV</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ⇒ product s (λx. (f x)⁻¹) = (product s f)⁻¹
   
   [<a name="PRODUCT_LE-val"><b>PRODUCT_LE</b></a>]  Theorem
      
      ⊢ ∀f s.
            FINITE s ∧ (∀x. x ∈ s ⇒ 0 ≤ f x ∧ f x ≤ g x) ⇒
            product s f ≤ product s g
   
   [<a name="PRODUCT_LE_1-val"><b>PRODUCT_LE_1</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ∧ (∀x. x ∈ s ⇒ 0 ≤ f x ∧ f x ≤ 1) ⇒ product s f ≤ 1
   
   [<a name="PRODUCT_LE_NUMSEG-val"><b>PRODUCT_LE_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n.
            (∀i. m ≤ i ∧ i ≤ n ⇒ 0 ≤ f i ∧ f i ≤ g i) ⇒
            product (m .. n) f ≤ product (m .. n) g
   
   [<a name="PRODUCT_MUL-val"><b>PRODUCT_MUL</b></a>]  Theorem
      
      ⊢ ∀f g s.
            FINITE s ⇒
            product s (λx. f x * g x) = product s f * product s g
   
   [<a name="PRODUCT_MUL_GEN-val"><b>PRODUCT_MUL_GEN</b></a>]  Theorem
      
      ⊢ ∀f g s.
            FINITE {x | x ∈ s ∧ f x ≠ 1} ∧ FINITE {x | x ∈ s ∧ g x ≠ 1} ⇒
            product s (λx. f x * g x) = product s f * product s g
   
   [<a name="PRODUCT_MUL_NUMSEG-val"><b>PRODUCT_MUL_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f g m n.
            product (m .. n) (λx. f x * g x) =
            product (m .. n) f * product (m .. n) g
   
   [<a name="PRODUCT_NEG-val"><b>PRODUCT_NEG</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ⇒ product s (λi. -f i) = -1 pow CARD s * product s f
   
   [<a name="PRODUCT_NEG_NUMSEG-val"><b>PRODUCT_NEG_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n.
            product (m .. n) (λi. -f i) =
            -1 pow (n + 1 − m) * product (m .. n) f
   
   [<a name="PRODUCT_NEG_NUMSEG_1-val"><b>PRODUCT_NEG_NUMSEG_1</b></a>]  Theorem
      
      ⊢ ∀f n. product (1 .. n) (λi. -f i) = -1 pow n * product (1 .. n) f
   
   [<a name="PRODUCT_OFFSET-val"><b>PRODUCT_OFFSET</b></a>]  Theorem
      
      ⊢ ∀f m p.
            product (m + p .. n + p) f = product (m .. n) (λi. f (i + p))
   
   [<a name="PRODUCT_ONE-val"><b>PRODUCT_ONE</b></a>]  Theorem
      
      ⊢ ∀s. product s (λn. 1) = 1
   
   [<a name="PRODUCT_PAIR-val"><b>PRODUCT_PAIR</b></a>]  Theorem
      
      ⊢ ∀f m n.
            product (2 * m .. 2 * n + 1) f =
            product (m .. n) (λi. f (2 * i) * f (2 * i + 1))
   
   [<a name="PRODUCT_POS_LE-val"><b>PRODUCT_POS_LE</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ∧ (∀x. x ∈ s ⇒ 0 ≤ f x) ⇒ 0 ≤ product s f
   
   [<a name="PRODUCT_POS_LE_NUMSEG-val"><b>PRODUCT_POS_LE_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n. (∀x. m ≤ x ∧ x ≤ n ⇒ 0 ≤ f x) ⇒ 0 ≤ product (m .. n) f
   
   [<a name="PRODUCT_POS_LT-val"><b>PRODUCT_POS_LT</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ∧ (∀x. x ∈ s ⇒ 0 &lt; f x) ⇒ 0 &lt; product s f
   
   [<a name="PRODUCT_POS_LT_NUMSEG-val"><b>PRODUCT_POS_LT_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f m n. (∀x. m ≤ x ∧ x ≤ n ⇒ 0 &lt; f x) ⇒ 0 &lt; product (m .. n) f
   
   [<a name="PRODUCT_SING-val"><b>PRODUCT_SING</b></a>]  Theorem
      
      ⊢ ∀f x. product {x} f = f x
   
   [<a name="PRODUCT_SING_NUMSEG-val"><b>PRODUCT_SING_NUMSEG</b></a>]  Theorem
      
      ⊢ ∀f n. product (n .. n) f = f n
   
   [<a name="PRODUCT_SUPERSET-val"><b>PRODUCT_SUPERSET</b></a>]  Theorem
      
      ⊢ ∀f u v.
            u ⊆ v ∧ (∀x. x ∈ v ∧ x ∉ u ⇒ f x = 1) ⇒
            product v f = product u f
   
   [<a name="PRODUCT_SUPPORT-val"><b>PRODUCT_SUPPORT</b></a>]  Theorem
      
      ⊢ ∀f s. product (support $* f s) f = product s f
   
   [<a name="PRODUCT_UNION-val"><b>PRODUCT_UNION</b></a>]  Theorem
      
      ⊢ ∀f s t.
            FINITE s ∧ FINITE t ∧ DISJOINT s t ⇒
            product (s ∪ t) f = product s f * product t f
   
   [<a name="REAL_ADD_AC-val"><b>REAL_ADD_AC</b></a>]  Theorem
      
      ⊢ m + n = n + m ∧ m + n + p = m + (n + p) ∧ m + (n + p) = n + (m + p)
   
   [<a name="REAL_OF_NUM_NPRODUCT-val"><b>REAL_OF_NUM_NPRODUCT</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ⇒ &nproduct s f = product s (λx. &f x)
   
   [<a name="th-val"><b>th</b></a>]  Theorem
      
      ⊢ (∀f g s.
             (∀x. x ∈ s ⇒ f x = g x) ⇒ nproduct s (λi. f i) = nproduct s g) ∧
        (∀f g a b.
             (∀i. a ≤ i ∧ i ≤ b ⇒ f i = g i) ⇒
             nproduct (a .. b) (λi. f i) = nproduct (a .. b) g) ∧
        ∀f g p.
            (∀x. p x ⇒ f x = g x) ⇒
            nproduct {y | p y} (λi. f i) = nproduct {y | p y} g
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/probability/productScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-13</a></em></p></body></html>
