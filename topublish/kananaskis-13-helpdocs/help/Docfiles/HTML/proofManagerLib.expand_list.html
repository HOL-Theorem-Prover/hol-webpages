<!DOCTYPE html>
<HTML>
<HEAD>
<META CHARSET="utf-8">
<TITLE>proofManagerLib.expand_list</TITLE>
<LINK REL = "STYLESHEET" HREF = "../doc.css" TYPE = "text/css"></HEAD>
<BODY>

<DIV class = "TYPE"><PRE>expand_list : list_tactic -&gt; proof</PRE></DIV>

<DL>
<DT><SPAN class = "FIELD-NAME">STRUCTURE</SPAN></DT>
<DD><DIV class = "FIELD-BODY"><A HREF = "../../src-sml/htmlsigs/proofManagerLib.html">proofManagerLib</A></DIV></DD>
<DT><SPAN class = "FIELD-NAME">SYNOPSIS</SPAN></DT>
<DD><DIV class = "FIELD-BODY"><SPAN class = "TEXT">Applies a list-tactic to replace the current goal list.</SPAN></DIV></DD>
<DT><SPAN class = "FIELD-NAME">DESCRIPTION</SPAN></DT>
<DD><DIV class = "FIELD-BODY"><SPAN class = "TEXT">The function </SPAN><SPAN class = "BRKT">expand_list</SPAN><SPAN class = "TEXT"> is part of the subgoal package.
It may be abbreviated by the function </SPAN><SPAN class = "BRKT">elt</SPAN><SPAN class = "TEXT">.
It applies a tactic to the current goal list (that is,
the list of goals produced by the most recent use of </SPAN><SPAN class = "BRKT">expand</SPAN><SPAN class = "TEXT"> or </SPAN><SPAN class = "BRKT">expand_list</SPAN><SPAN class = "TEXT">)
to give a new proof state.
The previous state is stored on the backup list. If the list-tactic produces
subgoals, the new proof state is formed from the old one by removing the
current goal list from the goal stack and replacing it by the list of subgoals
produced by the list-tactic.
The corresponding justification is modified accordingly,
appropriate to the new goal list.
The new subgoals are printed. If more than one subgoal is produced, they are
printed from the bottom of the stack so that the new current goal is  printed
last.</SPAN>
<P>
<SPAN class = "TEXT">If a list-tactic solves the current goal list (returns an empty subgoal list),
then its justification is used to prove a corresponding theorem.  This theorem
is incorporated into the justification of the parent goal and printed.
That level of goals is removed and the parent
goal is proved using  its (new) justification. This process is repeated until a
level with unproven subgoals is reached. The next goal on the goal stack then
becomes the current goal. This goal is printed. If all the subgoals are proved,
the resulting proof state consists of the theorem proved by the justifications.</SPAN>
<P>
<SPAN class = "TEXT">The list-tactic applied is a validating version of the list-tactic given.
It ensures that
the justification of the list-tactic does provide a proof of the goals from the
subgoals generated by the tactic. It will cause failure if this is not so. The
tactical </SPAN><SPAN class = "BRKT">VALID_LT</SPAN><SPAN class = "TEXT"> performs this validation.</SPAN>
<P>
<SPAN class = "TEXT">For a description of the subgoal package, see  </SPAN><SPAN class = "BRKT">set_goal</SPAN><SPAN class = "TEXT">.</SPAN></DIV></DD>
<DT><SPAN class = "FIELD-NAME">FAILURE</SPAN></DT>
<DD><DIV class = "FIELD-BODY"><SPAN class = "TEXT"></SPAN><SPAN class = "BRKT">expand_list&nbsp;ltac</SPAN><SPAN class = "TEXT"> fails if the tactic </SPAN><SPAN class = "BRKT">ltac</SPAN><SPAN class = "TEXT"> fails for the current goal list.
It will diverge if the list-tactic diverges for the goal. It will fail if there are no unproven goals.
This could be because no goal has been set using </SPAN><SPAN class = "BRKT">set_goal</SPAN><SPAN class = "TEXT"> or because
the last goal set has been completely proved. It will also fail in cases when
the list-tactic is invalid.</SPAN></DIV></DD>
<DT><SPAN class = "FIELD-NAME">EXAMPLE</SPAN></DT>
<DD><DIV class = "FIELD-BODY"><SPAN class = "TEXT"></SPAN><DIV class = "XMPL"><pre>
&gt; expand_list (ALLGOALS CONJ_TAC) ;
OK..
NO_PROOFSException- NO_PROOFS raised

&gt; g `(HD[1;2;3] = 1) /\ (TL[1;2;3] = [2;3])`;
&gt; val it =
    Proof manager status: 1 proof.
    1. Incomplete:
         Initial goal:
         (HD [1; 2; 3] = 1) /\ (TL [1; 2; 3] = [2; 3])

     : proofs

&gt; expand CONJ_TAC;
OK..
2 subgoals:
&gt; val it =
    TL [1; 2; 3] = [2; 3]


    HD [1; 2; 3] = 1

     : proof

&gt; expand_list (ALLGOALS (REWRITE_TAC[listTheory.HD,listTheory.TL])) ;
OK..
val it =
   Initial goal proved.
   |- (HD [1; 2; 3] = 1) /\ (TL [1; 2; 3] = [2; 3]):
      proof

</pre></DIV>
</DIV></DD>
<DT><SPAN class = "FIELD-NAME">USES</SPAN></DT>
<DD><DIV class = "FIELD-BODY"><SPAN class = "TEXT">Doing a step in an interactive goal-directed proof,
in particular, a step which affects all the subgoals generated by the
preceding step.</SPAN></DIV></DD>
<dt><span class = "FIELD-NAME">SEEALSO</span></dt>
<dd><div class = "FIELD-BODY"><A HREF = "proofManagerLib.set_goal.html">set_goal</A>,
<A HREF = "proofManagerLib.restart.html">restart</A>,
<A HREF = "proofManagerLib.backup.html">backup</A>,
<A HREF = "proofManagerLib.restore.html">restore</A>,
<A HREF = "proofManagerLib.save.html">save</A>,
<A HREF = "proofManagerLib.set_backup.html">set_backup</A>,
<A HREF = "proofManagerLib.expand.html">expand</A>,
<A HREF = "proofManagerLib.expandf.html">expandf</A>,
<A HREF = "proofManagerLib.expand_listf.html">expand_listf</A>,
<A HREF = "proofManagerLib.flatn.html">flatn</A>,
<A HREF = "proofManagerLib.p.html">p</A>,
<A HREF = "proofManagerLib.top_thm.html">top_thm</A>,
<A HREF = "proofManagerLib.top_goal.html">top_goal</A></div></dd>
</DL>

<div class = "HOL"><A HREF="http://hol.sourceforge.net">HOL</A>&nbsp;&nbsp;Kananaskis-13</div></BODY></HTML>
