<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: list</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "list"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "pred_setTheory.html"><span class="strong">pred_set</span></a>&nbsp;&nbsp;
    <a href = "ind_typeTheory.html"><span class="strong">ind_type</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Type <th> Arity<tr><td> <span class="strong">list</span> <td> 1
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">ALL_DISTINCT</span>
    <td>
    :α list -> bool
    <tr><td>
    <span class="strong">APPEND</span>
    <td>
    :α list -> α list -> α list
    <tr><td> <span class="strong">CONS</span> <td> :α -> α list -> α list
    <tr><td> <span class="strong">DROP</span> <td> :num -> α list -> α list
    <tr><td> <span class="strong">EL</span> <td> :num -> α list -> α
    <tr><td>
    <span class="strong">EVERY</span>
    <td>
    :(α -> bool) -> α list -> bool
    <tr><td>
    <span class="strong">EVERYi</span>
    <td>
    :(num -> α -> bool) -> α list -> bool
    <tr><td>
    <span class="strong">EXISTS</span>
    <td>
    :(α -> bool) -> α list -> bool
    <tr><td>
    <span class="strong">FILTER</span>
    <td>
    :(α -> bool) -> α list -> α list
    <tr><td>
    <span class="strong">FIND</span>
    <td>
    :(α -> bool) -> α list -> α option
    <tr><td> <span class="strong">FLAT</span> <td> :α list list -> α list
    <tr><td>
    <span class="strong">FOLDL</span>
    <td>
    :(β -> α -> β) -> β -> α list -> β
    <tr><td>
    <span class="strong">FOLDL2</span>
    <td>
    :(α -> β -> γ -> α) -> α -> β list -> γ list -> α
    <tr><td>
    <span class="strong">FOLDR</span>
    <td>
    :(α -> β -> β) -> β -> α list -> β
    <tr><td> <span class="strong">FRONT</span> <td> :α list -> α list
    <tr><td>
    <span class="strong">GENLIST</span>
    <td>
    :(num -> α) -> num -> α list
    <tr><td>
    <span class="strong">GENLIST_AUX</span>
    <td>
    :(num -> α) -> num -> α list -> α list
    <tr><td> <span class="strong">HD</span> <td> :α list -> α
    <tr><td>
    <span class="strong">INDEX_FIND</span>
    <td>
    :num -> (α -> bool) -> α list -> (num # α) option
    <tr><td>
    <span class="strong">INDEX_OF</span>
    <td>
    :α -> α list -> num option
    <tr><td> <span class="strong">LAST</span> <td> :α list -> α
    <tr><td> <span class="strong">LEN</span> <td> :α list -> num -> num
    <tr><td> <span class="strong">LENGTH</span> <td> :α list -> num
    <tr><td>
    <span class="strong">LIST_APPLY</span>
    <td>
    :(β -> α) list -> β list -> α list
    <tr><td>
    <span class="strong">LIST_BIND</span>
    <td>
    :β list -> (β -> α list) -> α list
    <tr><td> <span class="strong">LIST_GUARD</span> <td> :bool -> unit list
    <tr><td>
    <span class="strong">LIST_IGNORE_BIND</span>
    <td>
    :β list -> α list -> α list
    <tr><td>
    <span class="strong">LIST_LIFT2</span>
    <td>
    :(β -> γ -> α) -> β list -> γ list -> α list
    <tr><td>
    <span class="strong">LIST_REL</span>
    <td>
    :(α -> β -> bool) -> α list -> β list -> bool
    <tr><td> <span class="strong">LIST_TO_SET</span> <td> :α list -> α -> bool
    <tr><td>
    <span class="strong">LLEX</span>
    <td>
    :(α -> α -> bool) -> α list -> α list -> bool
    <tr><td>
    <span class="strong">LRC</span>
    <td>
    :(α -> α -> bool) -> α list -> α -> α -> bool
    <tr><td>
    <span class="strong">LUPDATE</span>
    <td>
    :α -> num -> α list -> α list
    <tr><td>
    <span class="strong">MAP</span>
    <td>
    :(α -> β) -> α list -> β list
    <tr><td>
    <span class="strong">MAP2</span>
    <td>
    :(β -> γ -> α) -> β list -> γ list -> α list
    <tr><td> <span class="strong">NIL</span> <td> :α list
    <tr><td> <span class="strong">NULL</span> <td> :α list -> bool
    <tr><td>
    <span class="strong">OPT_MMAP</span>
    <td>
    :(β -> α option) -> β list -> α list option
    <tr><td>
    <span class="strong">PAD_LEFT</span>
    <td>
    :α -> num -> α list -> α list
    <tr><td>
    <span class="strong">PAD_RIGHT</span>
    <td>
    :α -> num -> α list -> α list
    <tr><td> <span class="strong">REV</span> <td> :α list -> α list -> α list
    <tr><td> <span class="strong">REVERSE</span> <td> :α list -> α list
    <tr><td>
    <span class="strong">SET_TO_LIST</span>
    <td>
    :(α -> bool) -> α list
    <tr><td>
    <span class="strong">SHORTLEX</span>
    <td>
    :(α -> α -> bool) -> α list -> α list -> bool
    <tr><td> <span class="strong">SNOC</span> <td> :α -> α list -> α list
    <tr><td> <span class="strong">SUM</span> <td> :num list -> num
    <tr><td> <span class="strong">SUM_ACC</span> <td> :num list -> num -> num
    <tr><td> <span class="strong">TAKE</span> <td> :num -> α list -> α list
    <tr><td> <span class="strong">TL</span> <td> :α list -> α list
    <tr><td> <span class="strong">UNIQUE</span> <td> :α -> α list -> bool
    <tr><td>
    <span class="strong">UNZIP</span>
    <td>
    :(α # β) list -> α list # β list
    <tr><td>
    <span class="strong">ZIP</span>
    <td>
    :α list # β list -> (α # β) list
    <tr><td>
    <span class="strong">dropWhile</span>
    <td>
    :(α -> bool) -> α list -> α list
    <tr><td>
    <span class="strong">isPREFIX</span>
    <td>
    :α list -> α list -> bool
    <tr><td>
    <span class="strong">list_CASE</span>
    <td>
    :α list -> β -> (α -> α list -> β) -> β
    <tr><td>
    <span class="strong">list_size</span>
    <td>
    :(α -> num) -> α list -> num
    <tr><td> <span class="strong">nub</span> <td> :α list -> α list
    <tr><td> <span class="strong">oEL</span> <td> :num -> α list -> α option
    <tr><td> <span class="strong">oHD</span> <td> :α list -> α option
    <tr><td>
    <span class="strong">splitAtPki</span>
    <td>
    :(num -> β -> bool) -> (β list -> β list -> α) -> β list -> α
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">ZIP_def</span>
<DD>
<pre>
⊢ (∀l2. ZIP ([],l2) = []) ∧ (∀l1. ZIP (l1,[]) = []) ∧
  ∀x1 l1 x2 l2. ZIP (x1::l1,x2::l2) = (x1,x2)::ZIP (l1,l2)
</pre>

<DT><span class="strong">UNZIP</span>
<DD>
<pre>
⊢ (UNZIP [] = ([],[])) ∧
  ∀x l. UNZIP (x::l) = (FST x::FST (UNZIP l),SND x::SND (UNZIP l))
</pre>

<DT><span class="strong">UNIQUE_DEF</span>
<DD>
<pre>
⊢ ∀e L. UNIQUE e L ⇔ ∃L1 L2. (L1 ++ [e] ++ L2 = L) ∧ ¬MEM e L1 ∧ ¬MEM e L2
</pre>

<DT><span class="strong">TL_DEF</span>
<DD>
<pre>
⊢ (TL [] = []) ∧ ∀h t. TL (h::t) = t
</pre>

<DT><span class="strong">TAKE_def</span>
<DD>
<pre>
⊢ (∀n. TAKE n [] = []) ∧
  ∀n x xs. TAKE n (x::xs) = if n = 0 then [] else x::TAKE (n − 1) xs
</pre>

<DT><span class="strong">SUM_ACC_DEF</span>
<DD>
<pre>
⊢ (∀acc. SUM_ACC [] acc = acc) ∧
  ∀h t acc. SUM_ACC (h::t) acc = SUM_ACC t (h + acc)
</pre>

<DT><span class="strong">SUM</span>
<DD>
<pre>
⊢ (SUM [] = 0) ∧ ∀h t. SUM (h::t) = h + SUM t
</pre>

<DT><span class="strong">splitAtPki_def</span>
<DD>
<pre>
⊢ (∀P k. splitAtPki P k [] = k [] []) ∧
  ∀P k h t.
      splitAtPki P k (h::t) =
      if P 0 h then k [] (h::t) else splitAtPki (P ∘ SUC) (λp s. k (h::p) s) t
</pre>

<DT><span class="strong">SNOC</span>
<DD>
<pre>
⊢ (∀x. SNOC x [] = [x]) ∧ ∀x x' l. SNOC x (x'::l) = x'::SNOC x l
</pre>

<DT><span class="strong">SHORTLEX_def</span>
<DD>
<pre>
⊢ (∀R l2. SHORTLEX R [] l2 ⇔ l2 ≠ []) ∧
  ∀R h1 t1 l2.
      SHORTLEX R (h1::t1) l2 ⇔
      case l2 of
        [] => F
      | h2::t2 =>
        if LENGTH t1 < LENGTH t2 then T
        else if LENGTH t1 = LENGTH t2 then
          if R h1 h2 then T else if h1 = h2 then SHORTLEX R t1 t2 else F
        else F
</pre>

<DT><span class="strong">SET_TO_LIST_primitive_def</span>
<DD>
<pre>
⊢ SET_TO_LIST =
  WFREC (@R. WF R ∧ ∀s. FINITE s ∧ s ≠ ∅ ⇒ R (REST s) s)
    (λSET_TO_LIST a.
         I
           (if FINITE a then
              if a = ∅ then [] else CHOICE a::SET_TO_LIST (REST a)
            else ARB))
</pre>

<DT><span class="strong">REVERSE_DEF</span>
<DD>
<pre>
⊢ (REVERSE [] = []) ∧ ∀h t. REVERSE (h::t) = REVERSE t ++ [h]
</pre>

<DT><span class="strong">REV_DEF</span>
<DD>
<pre>
⊢ (∀acc. REV [] acc = acc) ∧ ∀h t acc. REV (h::t) acc = REV t (h::acc)
</pre>

<DT><span class="strong">PAD_RIGHT</span>
<DD>
<pre>
⊢ ∀c n s. PAD_RIGHT c n s = s ++ GENLIST (K c) (n − LENGTH s)
</pre>

<DT><span class="strong">PAD_LEFT</span>
<DD>
<pre>
⊢ ∀c n s. PAD_LEFT c n s = GENLIST (K c) (n − LENGTH s) ++ s
</pre>

<DT><span class="strong">OPT_MMAP_def</span>
<DD>
<pre>
⊢ (∀f. OPT_MMAP f [] = SOME []) ∧
  ∀f h0 t0.
      OPT_MMAP f (h0::t0) =
      OPTION_BIND (f h0) (λh. OPTION_BIND (OPT_MMAP f t0) (λt. SOME (h::t)))
</pre>

<DT><span class="strong">oHD_def</span>
<DD>
<pre>
⊢ ∀l. oHD l = case l of [] => NONE | h::v1 => SOME h
</pre>

<DT><span class="strong">oEL_def</span>
<DD>
<pre>
⊢ (∀n. oEL n [] = NONE) ∧
  ∀n x xs. oEL n (x::xs) = if n = 0 then SOME x else oEL (n − 1) xs
</pre>

<DT><span class="strong">NULL_DEF</span>
<DD>
<pre>
⊢ (NULL [] ⇔ T) ∧ ∀h t. NULL (h::t) ⇔ F
</pre>

<DT><span class="strong">nub_def</span>
<DD>
<pre>
⊢ (nub [] = []) ∧ ∀x l. nub (x::l) = if MEM x l then nub l else x::nub l
</pre>

<DT><span class="strong">MAP</span>
<DD>
<pre>
⊢ (∀f. MAP f [] = []) ∧ ∀f h t. MAP f (h::t) = f h::MAP f t
</pre>

<DT><span class="strong">LUPDATE_def</span>
<DD>
<pre>
⊢ (∀e n. LUPDATE e n [] = []) ∧ (∀e x l. LUPDATE e 0 (x::l) = e::l) ∧
  ∀e n x l. LUPDATE e (SUC n) (x::l) = x::LUPDATE e n l
</pre>

<DT><span class="strong">LRC_def</span>
<DD>
<pre>
⊢ (∀R x y. LRC R [] x y ⇔ (x = y)) ∧
  ∀R h t x y. LRC R (h::t) x y ⇔ (x = h) ∧ ∃z. R x z ∧ LRC R t z y
</pre>

<DT><span class="strong">LLEX_def</span>
<DD>
<pre>
⊢ (∀R l2. LLEX R [] l2 ⇔ l2 ≠ []) ∧
  ∀R h1 t1 l2.
      LLEX R (h1::t1) l2 ⇔
      case l2 of
        [] => F
      | h2::t2 => if R h1 h2 then T else if h1 = h2 then LLEX R t1 t2 else F
</pre>

<DT><span class="strong">list_TY_DEF</span>
<DD>
<pre>
⊢ ∃rep.
      TYPE_DEFINITION
        (λa0'.
             ∀ $var$('list').
                 (∀a0'.
                      (a0' = ind_type$CONSTR 0 ARB (λn. ind_type$BOTTOM)) ∨
                      (∃a0 a1.
                           (a0' =
                            (λa0 a1.
                                 ind_type$CONSTR (SUC 0) a0
                                   (ind_type$FCONS a1 (λn. ind_type$BOTTOM)))
                              a0 a1) ∧ $var$('list') a1) ⇒
                      $var$('list') a0') ⇒
                 $var$('list') a0') rep
</pre>

<DT><span class="strong">LIST_TO_SET_DEF</span>
<DD>
<pre>
⊢ (∀x. LIST_TO_SET [] x ⇔ F) ∧
  ∀h t x. LIST_TO_SET (h::t) x ⇔ (x = h) ∨ LIST_TO_SET t x
</pre>

<DT><span class="strong">list_size_def</span>
<DD>
<pre>
⊢ (∀f. list_size f [] = 0) ∧
  ∀f a0 a1. list_size f (a0::a1) = 1 + (f a0 + list_size f a1)
</pre>

<DT><span class="strong">LIST_LIFT2_def</span>
<DD>
<pre>
⊢ ∀f xs ys. LIST_LIFT2 f xs ys = MAP f xs <*> ys
</pre>

<DT><span class="strong">LIST_IGNORE_BIND_def</span>
<DD>
<pre>
⊢ ∀m1 m2. LIST_IGNORE_BIND m1 m2 = LIST_BIND m1 (K m2)
</pre>

<DT><span class="strong">LIST_GUARD_def</span>
<DD>
<pre>
⊢ ∀b. LIST_GUARD b = if b then [()] else []
</pre>

<DT><span class="strong">list_case_def</span>
<DD>
<pre>
⊢ (∀v f. list_CASE [] v f = v) ∧ ∀a0 a1 v f. list_CASE (a0::a1) v f = f a0 a1
</pre>

<DT><span class="strong">LIST_BIND_def</span>
<DD>
<pre>
⊢ ∀l f. LIST_BIND l f = FLAT (MAP f l)
</pre>

<DT><span class="strong">LIST_APPLY_def</span>
<DD>
<pre>
⊢ ∀fs xs. fs <*> xs = LIST_BIND fs (combin$C MAP xs)
</pre>

<DT><span class="strong">LENGTH</span>
<DD>
<pre>
⊢ (LENGTH [] = 0) ∧ ∀h t. LENGTH (h::t) = SUC (LENGTH t)
</pre>

<DT><span class="strong">LEN_DEF</span>
<DD>
<pre>
⊢ (∀n. LEN [] n = n) ∧ ∀h t n. LEN (h::t) n = LEN t (n + 1)
</pre>

<DT><span class="strong">LAST_DEF</span>
<DD>
<pre>
⊢ ∀h t. LAST (h::t) = if t = [] then h else LAST t
</pre>

<DT><span class="strong">isPREFIX</span>
<DD>
<pre>
⊢ (∀l. [] ≼ l ⇔ T) ∧
  ∀h t l. h::t ≼ l ⇔ case l of [] => F | h'::t' => (h = h') ∧ t ≼ t'
</pre>

<DT><span class="strong">INDEX_OF_def</span>
<DD>
<pre>
⊢ ∀x. INDEX_OF x = OPTION_MAP FST ∘ INDEX_FIND 0 ($= x)
</pre>

<DT><span class="strong">INDEX_FIND_def</span>
<DD>
<pre>
⊢ (∀i P. INDEX_FIND i P [] = NONE) ∧
  ∀i P h t.
      INDEX_FIND i P (h::t) =
      if P h then SOME (i,h) else INDEX_FIND (SUC i) P t
</pre>

<DT><span class="strong">HD</span>
<DD>
<pre>
⊢ ∀h t. HD (h::t) = h
</pre>

<DT><span class="strong">GENLIST_AUX</span>
<DD>
<pre>
⊢ (∀f l. GENLIST_AUX f 0 l = l) ∧
  ∀f n l. GENLIST_AUX f (SUC n) l = GENLIST_AUX f n (f n::l)
</pre>

<DT><span class="strong">GENLIST</span>
<DD>
<pre>
⊢ (∀f. GENLIST f 0 = []) ∧ ∀f n. GENLIST f (SUC n) = SNOC (f n) (GENLIST f n)
</pre>

<DT><span class="strong">FRONT_DEF</span>
<DD>
<pre>
⊢ ∀h t. FRONT (h::t) = if t = [] then [] else h::FRONT t
</pre>

<DT><span class="strong">FOLDR</span>
<DD>
<pre>
⊢ (∀f e. FOLDR f e [] = e) ∧ ∀f e x l. FOLDR f e (x::l) = f x (FOLDR f e l)
</pre>

<DT><span class="strong">FOLDL</span>
<DD>
<pre>
⊢ (∀f e. FOLDL f e [] = e) ∧ ∀f e x l. FOLDL f e (x::l) = FOLDL f (f e x) l
</pre>

<DT><span class="strong">FLAT</span>
<DD>
<pre>
⊢ (FLAT [] = []) ∧ ∀h t. FLAT (h::t) = h ++ FLAT t
</pre>

<DT><span class="strong">FIND_def</span>
<DD>
<pre>
⊢ ∀P. FIND P = OPTION_MAP SND ∘ INDEX_FIND 0 P
</pre>

<DT><span class="strong">FILTER</span>
<DD>
<pre>
⊢ (∀P. FILTER P [] = []) ∧
  ∀P h t. FILTER P (h::t) = if P h then h::FILTER P t else FILTER P t
</pre>

<DT><span class="strong">EXISTS_DEF</span>
<DD>
<pre>
⊢ (∀P. EXISTS P [] ⇔ F) ∧ ∀P h t. EXISTS P (h::t) ⇔ P h ∨ EXISTS P t
</pre>

<DT><span class="strong">EVERYi_def</span>
<DD>
<pre>
⊢ (∀P. EVERYi P [] ⇔ T) ∧ ∀P h t. EVERYi P (h::t) ⇔ P 0 h ∧ EVERYi (P ∘ SUC) t
</pre>

<DT><span class="strong">EVERY_DEF</span>
<DD>
<pre>
⊢ (∀P. EVERY P [] ⇔ T) ∧ ∀P h t. EVERY P (h::t) ⇔ P h ∧ EVERY P t
</pre>

<DT><span class="strong">EL</span>
<DD>
<pre>
⊢ (∀l. EL 0 l = HD l) ∧ ∀l n. EL (SUC n) l = EL n (TL l)
</pre>

<DT><span class="strong">dropWhile_def</span>
<DD>
<pre>
⊢ (∀P. dropWhile P [] = []) ∧
  ∀P h t. dropWhile P (h::t) = if P h then dropWhile P t else h::t
</pre>

<DT><span class="strong">DROP_def</span>
<DD>
<pre>
⊢ (∀n. DROP n [] = []) ∧
  ∀n x xs. DROP n (x::xs) = if n = 0 then x::xs else DROP (n − 1) xs
</pre>

<DT><span class="strong">APPEND</span>
<DD>
<pre>
⊢ (∀l. [] ++ l = l) ∧ ∀l1 l2 h. h::l1 ++ l2 = h::(l1 ++ l2)
</pre>

<DT><span class="strong">ALL_DISTINCT</span>
<DD>
<pre>
⊢ (ALL_DISTINCT [] ⇔ T) ∧
  ∀h t. ALL_DISTINCT (h::t) ⇔ ¬MEM h t ∧ ALL_DISTINCT t
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">ZIP_UNZIP</span>
<DD>
<pre>
⊢ ∀l. ZIP (UNZIP l) = l
</pre>

<DT><span class="strong">ZIP_MAP</span>
<DD>
<pre>
⊢ ∀l1 l2 f1 f2.
      (LENGTH l1 = LENGTH l2) ⇒
      (ZIP (MAP f1 l1,l2) = MAP (λp. (f1 (FST p),SND p)) (ZIP (l1,l2))) ∧
      (ZIP (l1,MAP f2 l2) = MAP (λp. (FST p,f2 (SND p))) (ZIP (l1,l2)))
</pre>

<DT><span class="strong">ZIP_GENLIST</span>
<DD>
<pre>
⊢ ∀l f n.
      (LENGTH l = n) ⇒ (ZIP (l,GENLIST f n) = GENLIST (λx. (EL x l,f x)) n)
</pre>

<DT><span class="strong">ZIP_EQ_NIL</span>
<DD>
<pre>
⊢ ∀l1 l2.
      (LENGTH l1 = LENGTH l2) ⇒ ((ZIP (l1,l2) = []) ⇔ (l1 = []) ∧ (l2 = []))
</pre>

<DT><span class="strong">ZIP_DROP</span>
<DD>
<pre>
⊢ ∀a b n.
      n ≤ LENGTH a ∧ (LENGTH a = LENGTH b) ⇒
      (ZIP (DROP n a,DROP n b) = DROP n (ZIP (a,b)))
</pre>

<DT><span class="strong">ZIP</span>
<DD>
<pre>
⊢ (ZIP ([],[]) = []) ∧
  ∀x1 l1 x2 l2. ZIP (x1::l1,x2::l2) = (x1,x2)::ZIP (l1,l2)
</pre>

<DT><span class="strong">WF_SHORTLEX_same_lengths</span>
<DD>
<pre>
⊢ WF R ⇒
  ∀l s.
      (∀d. d ∈ s ⇒ (LENGTH d = l)) ∧ (∃a. a ∈ s) ⇒
      ∃b. b ∈ s ∧ ∀c. SHORTLEX R c b ⇒ c ∉ s
</pre>

<DT><span class="strong">WF_SHORTLEX</span>
<DD>
<pre>
⊢ WF R ⇒ WF (SHORTLEX R)
</pre>

<DT><span class="strong">WF_LIST_PRED</span>
<DD>
<pre>
⊢ WF (λL1 L2. ∃h. L2 = h::L1)
</pre>

<DT><span class="strong">UNZIP_ZIP</span>
<DD>
<pre>
⊢ ∀l1 l2. (LENGTH l1 = LENGTH l2) ⇒ (UNZIP (ZIP (l1,l2)) = (l1,l2))
</pre>

<DT><span class="strong">UNZIP_THM</span>
<DD>
<pre>
⊢ (UNZIP [] = ([],[])) ∧
  (UNZIP ((x,y)::t) = (let (L1,L2) = UNZIP t in (x::L1,y::L2)))
</pre>

<DT><span class="strong">UNZIP_MAP</span>
<DD>
<pre>
⊢ ∀L. UNZIP L = (MAP FST L,MAP SND L)
</pre>

<DT><span class="strong">UNIQUE_LENGTH_FILTER</span>
<DD>
<pre>
⊢ ∀e L. UNIQUE e L ⇔ (LENGTH (FILTER ($= e) L) = 1)
</pre>

<DT><span class="strong">UNIQUE_FILTER</span>
<DD>
<pre>
⊢ ∀e L. UNIQUE e L ⇔ (FILTER ($= e) L = [e])
</pre>

<DT><span class="strong">UNION_APPEND</span>
<DD>
<pre>
⊢ ∀l1 l2. LIST_TO_SET l1 ∪ LIST_TO_SET l2 = LIST_TO_SET (l1 ++ l2)
</pre>

<DT><span class="strong">TL_GENLIST</span>
<DD>
<pre>
⊢ ∀f n. TL (GENLIST f (SUC n)) = GENLIST (f ∘ SUC) n
</pre>

<DT><span class="strong">TL</span>
<DD>
<pre>
⊢ ∀h t. TL (h::t) = t
</pre>

<DT><span class="strong">TAKE_TAKE_MIN</span>
<DD>
<pre>
⊢ ∀m n. TAKE n (TAKE m l) = TAKE (MIN n m) l
</pre>

<DT><span class="strong">TAKE_SUM</span>
<DD>
<pre>
⊢ ∀n m l. TAKE (n + m) l = TAKE n l ++ TAKE m (DROP n l)
</pre>

<DT><span class="strong">TAKE_splitAtPki</span>
<DD>
<pre>
⊢ TAKE n l = splitAtPki (K ∘ $= n) K l
</pre>

<DT><span class="strong">TAKE_nil</span>
<DD>
<pre>
⊢ ∀n. TAKE n [] = []
</pre>

<DT><span class="strong">TAKE_LENGTH_TOO_LONG</span>
<DD>
<pre>
⊢ ∀l n. LENGTH l ≤ n ⇒ (TAKE n l = l)
</pre>

<DT><span class="strong">TAKE_LENGTH_ID_rwt</span>
<DD>
<pre>
⊢ ∀l m. (m = LENGTH l) ⇒ (TAKE m l = l)
</pre>

<DT><span class="strong">TAKE_LENGTH_ID</span>
<DD>
<pre>
⊢ ∀l. TAKE (LENGTH l) l = l
</pre>

<DT><span class="strong">TAKE_GENLIST</span>
<DD>
<pre>
⊢ TAKE n (GENLIST f m) = GENLIST f (MIN n m)
</pre>

<DT><span class="strong">TAKE_EQ_NIL</span>
<DD>
<pre>
⊢ (TAKE n l = []) ⇔ (n = 0) ∨ (l = [])
</pre>

<DT><span class="strong">TAKE_DROP</span>
<DD>
<pre>
⊢ ∀n l. TAKE n l ++ DROP n l = l
</pre>

<DT><span class="strong">TAKE_cons</span>
<DD>
<pre>
⊢ 0 < n ⇒ (TAKE n (x::xs) = x::TAKE (n − 1) xs)
</pre>

<DT><span class="strong">TAKE_compute</span>
<DD>
<pre>
⊢ (∀l. TAKE 0 l = []) ∧ (∀n. TAKE (NUMERAL (BIT1 n)) [] = []) ∧
  (∀n. TAKE (NUMERAL (BIT2 n)) [] = []) ∧
  (∀n h t. TAKE (NUMERAL (BIT1 n)) (h::t) = h::TAKE (NUMERAL (BIT1 n) − 1) t) ∧
  ∀n h t. TAKE (NUMERAL (BIT2 n)) (h::t) = h::TAKE (NUMERAL (BIT1 n)) t
</pre>

<DT><span class="strong">TAKE_APPEND2</span>
<DD>
<pre>
⊢ ∀n. LENGTH l1 < n ⇒ (TAKE n (l1 ++ l2) = l1 ++ TAKE (n − LENGTH l1) l2)
</pre>

<DT><span class="strong">TAKE_APPEND1</span>
<DD>
<pre>
⊢ ∀n. n ≤ LENGTH l1 ⇒ (TAKE n (l1 ++ l2) = TAKE n l1)
</pre>

<DT><span class="strong">TAKE_0</span>
<DD>
<pre>
⊢ TAKE 0 l = []
</pre>

<DT><span class="strong">TAKE1_DROP</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ (TAKE 1 (DROP n l) = [EL n l])
</pre>

<DT><span class="strong">TAKE1</span>
<DD>
<pre>
⊢ ∀l. l ≠ [] ⇒ (TAKE 1 l = [EL 0 l])
</pre>

<DT><span class="strong">SWAP_REVERSE_SYM</span>
<DD>
<pre>
⊢ ∀l1 l2. (REVERSE l1 = l2) ⇔ (l1 = REVERSE l2)
</pre>

<DT><span class="strong">SWAP_REVERSE</span>
<DD>
<pre>
⊢ ∀l1 l2. (l1 = REVERSE l2) ⇔ (l2 = REVERSE l1)
</pre>

<DT><span class="strong">SUM_SUM_ACC</span>
<DD>
<pre>
⊢ ∀L. SUM L = SUM_ACC L 0
</pre>

<DT><span class="strong">SUM_SNOC</span>
<DD>
<pre>
⊢ ∀x l. SUM (SNOC x l) = SUM l + x
</pre>

<DT><span class="strong">SUM_MAP_PLUS_ZIP</span>
<DD>
<pre>
⊢ ∀ls1 ls2.
      (LENGTH ls1 = LENGTH ls2) ∧ (∀x y. f (x,y) = g x + h y) ⇒
      (SUM (MAP f (ZIP (ls1,ls2))) = SUM (MAP g ls1) + SUM (MAP h ls2))
</pre>

<DT><span class="strong">SUM_MAP_PLUS</span>
<DD>
<pre>
⊢ ∀f g ls. SUM (MAP (λx. f x + g x) ls) = SUM (MAP f ls) + SUM (MAP g ls)
</pre>

<DT><span class="strong">SUM_MAP_MEM_bound</span>
<DD>
<pre>
⊢ ∀f x ls. MEM x ls ⇒ f x ≤ SUM (MAP f ls)
</pre>

<DT><span class="strong">SUM_MAP_FOLDL</span>
<DD>
<pre>
⊢ ∀ls. SUM (MAP f ls) = FOLDL (λa e. a + f e) 0 ls
</pre>

<DT><span class="strong">SUM_IMAGE_LIST_TO_SET_upper_bound</span>
<DD>
<pre>
⊢ ∀ls. ∑ f (LIST_TO_SET ls) ≤ SUM (MAP f ls)
</pre>

<DT><span class="strong">SUM_IMAGE_eq_SUM_MAP_SET_TO_LIST</span>
<DD>
<pre>
⊢ FINITE s ⇒ (∑ f s = SUM (MAP f (SET_TO_LIST s)))
</pre>

<DT><span class="strong">SUM_eq_0</span>
<DD>
<pre>
⊢ ∀ls. (SUM ls = 0) ⇔ ∀x. MEM x ls ⇒ (x = 0)
</pre>

<DT><span class="strong">SUM_APPEND</span>
<DD>
<pre>
⊢ ∀l1 l2. SUM (l1 ++ l2) = SUM l1 + SUM l2
</pre>

<DT><span class="strong">SUM_ACC_SUM_LEM</span>
<DD>
<pre>
⊢ ∀L n. SUM_ACC L n = SUM L + n
</pre>

<DT><span class="strong">splitAtPki_RAND</span>
<DD>
<pre>
⊢ f (splitAtPki P k l) = splitAtPki P ($o f ∘ k) l
</pre>

<DT><span class="strong">splitAtPki_MAP</span>
<DD>
<pre>
⊢ splitAtPki P k (MAP f l) =
  splitAtPki (combin$C ($o ∘ P) f) (combin$C ($o ∘ k ∘ MAP f) (MAP f)) l
</pre>

<DT><span class="strong">splitAtPki_EQN</span>
<DD>
<pre>
⊢ splitAtPki P k l =
  case OLEAST i. i < LENGTH l ∧ P i (EL i l) of
    NONE => k l []
  | SOME i => k (TAKE i l) (DROP i l)
</pre>

<DT><span class="strong">splitAtPki_change_predicate</span>
<DD>
<pre>
⊢ (∀i. i < LENGTH l ⇒ (P1 i (EL i l) ⇔ P2 i (EL i l))) ⇒
  (splitAtPki P1 k l = splitAtPki P2 k l)
</pre>

<DT><span class="strong">splitAtPki_APPEND</span>
<DD>
<pre>
⊢ ∀l1 l2 P k.
      EVERYi (λi. $~ ∘ P i) l1 ∧ (0 < LENGTH l2 ⇒ P (LENGTH l1) (HD l2)) ⇒
      (splitAtPki P k (l1 ++ l2) = k l1 l2)
</pre>

<DT><span class="strong">SNOC_INDUCT</span>
<DD>
<pre>
⊢ ∀P. P [] ∧ (∀l. P l ⇒ ∀x. P (SNOC x l)) ⇒ ∀l. P l
</pre>

<DT><span class="strong">SNOC_CASES</span>
<DD>
<pre>
⊢ ∀ll. (ll = []) ∨ ∃x l. ll = SNOC x l
</pre>

<DT><span class="strong">SNOC_Axiom</span>
<DD>
<pre>
⊢ ∀e f. ∃fn. (fn [] = e) ∧ ∀x l. fn (SNOC x l) = f x l (fn l)
</pre>

<DT><span class="strong">SNOC_APPEND</span>
<DD>
<pre>
⊢ ∀x l. SNOC x l = l ++ [x]
</pre>

<DT><span class="strong">SNOC_11</span>
<DD>
<pre>
⊢ ∀x y a b. (SNOC x y = SNOC a b) ⇔ (x = a) ∧ (y = b)
</pre>

<DT><span class="strong">SINGL_SINGL_APPLY</span>
<DD>
<pre>
⊢ [f] <*> [x] = [f x]
</pre>

<DT><span class="strong">SINGL_LIST_APPLY_R</span>
<DD>
<pre>
⊢ LIST_BIND l (λx. [x]) = l
</pre>

<DT><span class="strong">SINGL_LIST_APPLY_L</span>
<DD>
<pre>
⊢ LIST_BIND [x] f = f x
</pre>

<DT><span class="strong">SINGL_APPLY_PERMUTE</span>
<DD>
<pre>
⊢ fs <*> [x] = [(λf. f x)] <*> fs
</pre>

<DT><span class="strong">SINGL_APPLY_MAP</span>
<DD>
<pre>
⊢ [f] <*> l = MAP f l
</pre>

<DT><span class="strong">SING_HD</span>
<DD>
<pre>
⊢ (([HD xs] = xs) ⇔ (LENGTH xs = 1)) ∧ ((xs = [HD xs]) ⇔ (LENGTH xs = 1))
</pre>

<DT><span class="strong">SHORTLEX_transitive</span>
<DD>
<pre>
⊢ transitive R ⇒ transitive (SHORTLEX R)
</pre>

<DT><span class="strong">SHORTLEX_total</span>
<DD>
<pre>
⊢ total (RC R) ⇒ total (RC (SHORTLEX R))
</pre>

<DT><span class="strong">SHORTLEX_THM</span>
<DD>
<pre>
⊢ (¬SHORTLEX R [] [] ∧ ¬SHORTLEX R (h1::t1) []) ∧ SHORTLEX R [] (h2::t2) ∧
  (SHORTLEX R (h1::t1) (h2::t2) ⇔
   LENGTH t1 < LENGTH t2 ∨
   (LENGTH t1 = LENGTH t2) ∧ (R h1 h2 ∨ (h1 = h2) ∧ SHORTLEX R t1 t2))
</pre>

<DT><span class="strong">SHORTLEX_NIL2</span>
<DD>
<pre>
⊢ ¬SHORTLEX R l []
</pre>

<DT><span class="strong">SHORTLEX_MONO</span>
<DD>
<pre>
⊢ (∀x y. R1 x y ⇒ R2 x y) ⇒ SHORTLEX R1 x y ⇒ SHORTLEX R2 x y
</pre>

<DT><span class="strong">SHORTLEX_LENGTH_LE</span>
<DD>
<pre>
⊢ ∀l1 l2. SHORTLEX R l1 l2 ⇒ LENGTH l1 ≤ LENGTH l2
</pre>

<DT><span class="strong">SET_TO_LIST_THM</span>
<DD>
<pre>
⊢ FINITE s ⇒
  (SET_TO_LIST s = if s = ∅ then [] else CHOICE s::SET_TO_LIST (REST s))
</pre>

<DT><span class="strong">SET_TO_LIST_SING</span>
<DD>
<pre>
⊢ SET_TO_LIST {x} = [x]
</pre>

<DT><span class="strong">SET_TO_LIST_INV</span>
<DD>
<pre>
⊢ ∀s. FINITE s ⇒ (LIST_TO_SET (SET_TO_LIST s) = s)
</pre>

<DT><span class="strong">SET_TO_LIST_IND</span>
<DD>
<pre>
⊢ ∀P. (∀s. (FINITE s ∧ s ≠ ∅ ⇒ P (REST s)) ⇒ P s) ⇒ ∀v. P v
</pre>

<DT><span class="strong">SET_TO_LIST_IN_MEM</span>
<DD>
<pre>
⊢ ∀s. FINITE s ⇒ ∀x. x ∈ s ⇔ MEM x (SET_TO_LIST s)
</pre>

<DT><span class="strong">SET_TO_LIST_EMPTY</span>
<DD>
<pre>
⊢ SET_TO_LIST ∅ = []
</pre>

<DT><span class="strong">SET_TO_LIST_CARD</span>
<DD>
<pre>
⊢ ∀s. FINITE s ⇒ (LENGTH (SET_TO_LIST s) = CARD s)
</pre>

<DT><span class="strong">REVERSE_SNOC_DEF</span>
<DD>
<pre>
⊢ (REVERSE [] = []) ∧ ∀x l. REVERSE (x::l) = SNOC x (REVERSE l)
</pre>

<DT><span class="strong">REVERSE_SNOC</span>
<DD>
<pre>
⊢ ∀x l. REVERSE (SNOC x l) = x::REVERSE l
</pre>

<DT><span class="strong">REVERSE_REVERSE</span>
<DD>
<pre>
⊢ ∀l. REVERSE (REVERSE l) = l
</pre>

<DT><span class="strong">REVERSE_REV</span>
<DD>
<pre>
⊢ ∀L. REVERSE L = REV L []
</pre>

<DT><span class="strong">REVERSE_o_REVERSE</span>
<DD>
<pre>
⊢ REVERSE ∘ REVERSE ∘ f = f
</pre>

<DT><span class="strong">REVERSE_GENLIST</span>
<DD>
<pre>
⊢ REVERSE (GENLIST f n) = GENLIST (λm. f (PRE n − m)) n
</pre>

<DT><span class="strong">REVERSE_EQ_SING</span>
<DD>
<pre>
⊢ (REVERSE l = [e]) ⇔ (l = [e])
</pre>

<DT><span class="strong">REVERSE_EQ_NIL</span>
<DD>
<pre>
⊢ (REVERSE l = []) ⇔ (l = [])
</pre>

<DT><span class="strong">REVERSE_APPEND</span>
<DD>
<pre>
⊢ ∀l1 l2. REVERSE (l1 ++ l2) = REVERSE l2 ++ REVERSE l1
</pre>

<DT><span class="strong">REVERSE_11</span>
<DD>
<pre>
⊢ ∀l1 l2. (REVERSE l1 = REVERSE l2) ⇔ (l1 = l2)
</pre>

<DT><span class="strong">REV_REVERSE_LEM</span>
<DD>
<pre>
⊢ ∀L1 L2. REV L1 L2 = REVERSE L1 ++ L2
</pre>

<DT><span class="strong">OPT_MMAP_cong</span>
<DD>
<pre>
⊢ ∀f1 f2 x1 x2.
      (x1 = x2) ∧ (∀a. MEM a x2 ⇒ (f1 a = f2 a)) ⇒
      (OPT_MMAP f1 x1 = OPT_MMAP f2 x2)
</pre>

<DT><span class="strong">oHD_thm</span>
<DD>
<pre>
⊢ (oHD [] = NONE) ∧ (oHD (h::t) = SOME h)
</pre>

<DT><span class="strong">oEL_THM</span>
<DD>
<pre>
⊢ ∀xs n. oEL n xs = if n < LENGTH xs then SOME (EL n xs) else NONE
</pre>

<DT><span class="strong">oEL_TAKE_E</span>
<DD>
<pre>
⊢ (oEL n (TAKE m xs) = SOME x) ⇒ (oEL n xs = SOME x)
</pre>

<DT><span class="strong">oEL_LUPDATE</span>
<DD>
<pre>
⊢ ∀xs i n x.
      oEL n (LUPDATE x i xs) =
      if i ≠ n then oEL n xs else if i < LENGTH xs then SOME x else NONE
</pre>

<DT><span class="strong">oEL_EQ_EL</span>
<DD>
<pre>
⊢ ∀xs n y. (oEL n xs = SOME y) ⇔ n < LENGTH xs ∧ (y = EL n xs)
</pre>

<DT><span class="strong">oEL_DROP</span>
<DD>
<pre>
⊢ oEL n (DROP m xs) = oEL (m + n) xs
</pre>

<DT><span class="strong">NULL_LENGTH</span>
<DD>
<pre>
⊢ ∀l. NULL l ⇔ (LENGTH l = 0)
</pre>

<DT><span class="strong">NULL_GENLIST</span>
<DD>
<pre>
⊢ ∀n f. NULL (GENLIST f n) ⇔ (n = 0)
</pre>

<DT><span class="strong">NULL_FILTER</span>
<DD>
<pre>
⊢ ∀P ls. NULL (FILTER P ls) ⇔ ∀x. MEM x ls ⇒ ¬P x
</pre>

<DT><span class="strong">NULL_EQ</span>
<DD>
<pre>
⊢ ∀l. NULL l ⇔ (l = [])
</pre>

<DT><span class="strong">NULL_APPEND</span>
<DD>
<pre>
⊢ NULL (l1 ++ l2) ⇔ NULL l1 ∧ NULL l2
</pre>

<DT><span class="strong">NULL</span>
<DD>
<pre>
⊢ NULL [] ∧ ∀h t. ¬NULL (h::t)
</pre>

<DT><span class="strong">nub_set</span>
<DD>
<pre>
⊢ ∀l. LIST_TO_SET (nub l) = LIST_TO_SET l
</pre>

<DT><span class="strong">nub_append</span>
<DD>
<pre>
⊢ ∀l1 l2. nub (l1 ++ l2) = nub (FILTER (λx. ¬MEM x l2) l1) ++ nub l2
</pre>

<DT><span class="strong">NRC_LRC</span>
<DD>
<pre>
⊢ NRC R n x y ⇔ ∃ls. LRC R ls x y ∧ (LENGTH ls = n)
</pre>

<DT><span class="strong">NOT_NULL_MEM</span>
<DD>
<pre>
⊢ ∀l. ¬NULL l ⇔ ∃e. MEM e l
</pre>

<DT><span class="strong">NOT_NIL_EQ_LENGTH_NOT_0</span>
<DD>
<pre>
⊢ x ≠ [] ⇔ 0 < LENGTH x
</pre>

<DT><span class="strong">NOT_NIL_CONS</span>
<DD>
<pre>
⊢ ∀a1 a0. [] ≠ a0::a1
</pre>

<DT><span class="strong">NOT_EXISTS</span>
<DD>
<pre>
⊢ ∀P l. ¬EXISTS P l ⇔ EVERY ($~ ∘ P) l
</pre>

<DT><span class="strong">NOT_EVERY</span>
<DD>
<pre>
⊢ ∀P l. ¬EVERY P l ⇔ EXISTS ($~ ∘ P) l
</pre>

<DT><span class="strong">NOT_EQ_LIST</span>
<DD>
<pre>
⊢ ∀h1 h2. h1 ≠ h2 ⇒ ∀l1 l2. h1::l1 ≠ h2::l2
</pre>

<DT><span class="strong">NOT_CONS_NIL</span>
<DD>
<pre>
⊢ ∀a1 a0. a0::a1 ≠ []
</pre>

<DT><span class="strong">MONO_EXISTS</span>
<DD>
<pre>
⊢ (∀x. P x ⇒ Q x) ⇒ EXISTS P l ⇒ EXISTS Q l
</pre>

<DT><span class="strong">MONO_EVERY</span>
<DD>
<pre>
⊢ (∀x. P x ⇒ Q x) ⇒ EVERY P l ⇒ EVERY Q l
</pre>

<DT><span class="strong">MEM_ZIP_MEM_MAP</span>
<DD>
<pre>
⊢ (LENGTH (FST ps) = LENGTH (SND ps)) ∧ MEM p (ZIP ps) ⇒
  MEM (FST p) (FST ps) ∧ MEM (SND p) (SND ps)
</pre>

<DT><span class="strong">MEM_ZIP</span>
<DD>
<pre>
⊢ ∀l1 l2 p.
      (LENGTH l1 = LENGTH l2) ⇒
      (MEM p (ZIP (l1,l2)) ⇔ ∃n. n < LENGTH l1 ∧ (p = (EL n l1,EL n l2)))
</pre>

<DT><span class="strong">MEM_SPLIT_APPEND_last</span>
<DD>
<pre>
⊢ MEM e l ⇔ ∃pfx sfx. (l = pfx ++ [e] ++ sfx) ∧ ¬MEM e sfx
</pre>

<DT><span class="strong">MEM_SPLIT_APPEND_first</span>
<DD>
<pre>
⊢ MEM e l ⇔ ∃pfx sfx. (l = pfx ++ [e] ++ sfx) ∧ ¬MEM e pfx
</pre>

<DT><span class="strong">MEM_SPLIT</span>
<DD>
<pre>
⊢ ∀x l. MEM x l ⇔ ∃l1 l2. l = l1 ++ x::l2
</pre>

<DT><span class="strong">MEM_SNOC</span>
<DD>
<pre>
⊢ ∀y x l. MEM y (SNOC x l) ⇔ (y = x) ∨ MEM y l
</pre>

<DT><span class="strong">MEM_SET_TO_LIST</span>
<DD>
<pre>
⊢ ∀s. FINITE s ⇒ ∀x. MEM x (SET_TO_LIST s) ⇔ x ∈ s
</pre>

<DT><span class="strong">MEM_REVERSE</span>
<DD>
<pre>
⊢ ∀l x. MEM x (REVERSE l) ⇔ MEM x l
</pre>

<DT><span class="strong">MEM_MAP</span>
<DD>
<pre>
⊢ ∀l f x. MEM x (MAP f l) ⇔ ∃y. (x = f y) ∧ MEM y l
</pre>

<DT><span class="strong">MEM_LUPDATE_E</span>
<DD>
<pre>
⊢ ∀l x y i. MEM x (LUPDATE y i l) ⇒ (x = y) ∨ MEM x l
</pre>

<DT><span class="strong">MEM_LUPDATE</span>
<DD>
<pre>
⊢ ∀l x y i.
      MEM x (LUPDATE y i l) ⇔
      i < LENGTH l ∧ (x = y) ∨ ∃j. j < LENGTH l ∧ i ≠ j ∧ (EL j l = x)
</pre>

<DT><span class="strong">MEM_GENLIST</span>
<DD>
<pre>
⊢ MEM x (GENLIST f n) ⇔ ∃m. m < n ∧ (x = f m)
</pre>

<DT><span class="strong">MEM_FLAT</span>
<DD>
<pre>
⊢ ∀x L. MEM x (FLAT L) ⇔ ∃l. MEM l L ∧ MEM x l
</pre>

<DT><span class="strong">MEM_FILTER</span>
<DD>
<pre>
⊢ ∀P L x. MEM x (FILTER P L) ⇔ P x ∧ MEM x L
</pre>

<DT><span class="strong">mem_exists_set</span>
<DD>
<pre>
⊢ ∀x y l. MEM (x,y) l ⇒ ∃z. (x = FST z) ∧ MEM z l
</pre>

<DT><span class="strong">MEM_EL</span>
<DD>
<pre>
⊢ ∀l x. MEM x l ⇔ ∃n. n < LENGTH l ∧ (x = EL n l)
</pre>

<DT><span class="strong">MEM_dropWhile_IMP</span>
<DD>
<pre>
⊢ ∀P ls x. MEM x (dropWhile P ls) ⇒ MEM x ls
</pre>

<DT><span class="strong">MEM_DROP</span>
<DD>
<pre>
⊢ ∀x ls n. MEM x (DROP n ls) ⇔ ∃m. m + n < LENGTH ls ∧ (x = EL (m + n) ls)
</pre>

<DT><span class="strong">MEM_APPEND_lemma</span>
<DD>
<pre>
⊢ ∀a b c d x.
      (a ++ [x] ++ b = c ++ [x] ++ d) ∧ ¬MEM x b ∧ ¬MEM x a ⇒
      (a = c) ∧ (b = d)
</pre>

<DT><span class="strong">MEM_APPEND</span>
<DD>
<pre>
⊢ ∀e l1 l2. MEM e (l1 ++ l2) ⇔ MEM e l1 ∨ MEM e l2
</pre>

<DT><span class="strong">MEM</span>
<DD>
<pre>
⊢ (∀x. MEM x [] ⇔ F) ∧ ∀x h t. MEM x (h::t) ⇔ (x = h) ∨ MEM x t
</pre>

<DT><span class="strong">MAP_ZIP_SAME</span>
<DD>
<pre>
⊢ ∀ls f. MAP f (ZIP (ls,ls)) = MAP (λx. f (x,x)) ls
</pre>

<DT><span class="strong">MAP_ZIP</span>
<DD>
<pre>
⊢ (LENGTH l1 = LENGTH l2) ⇒
  (MAP FST (ZIP (l1,l2)) = l1) ∧ (MAP SND (ZIP (l1,l2)) = l2) ∧
  (MAP (f ∘ FST) (ZIP (l1,l2)) = MAP f l1) ∧
  (MAP (g ∘ SND) (ZIP (l1,l2)) = MAP g l2)
</pre>

<DT><span class="strong">MAP_TL</span>
<DD>
<pre>
⊢ ∀l f. ¬NULL l ⇒ (MAP f (TL l) = TL (MAP f l))
</pre>

<DT><span class="strong">MAP_TAKE</span>
<DD>
<pre>
⊢ ∀f n l. MAP f (TAKE n l) = TAKE n (MAP f l)
</pre>

<DT><span class="strong">MAP_SNOC</span>
<DD>
<pre>
⊢ ∀f x l. MAP f (SNOC x l) = SNOC (f x) (MAP f l)
</pre>

<DT><span class="strong">MAP_o</span>
<DD>
<pre>
⊢ ∀f g. MAP (f ∘ g) = MAP f ∘ MAP g
</pre>

<DT><span class="strong">MAP_MAP_o</span>
<DD>
<pre>
⊢ ∀f g l. MAP f (MAP g l) = MAP (f ∘ g) l
</pre>

<DT><span class="strong">MAP_LIST_BIND</span>
<DD>
<pre>
⊢ MAP f (LIST_BIND l g) = LIST_BIND l (MAP f ∘ g)
</pre>

<DT><span class="strong">MAP_ID</span>
<DD>
<pre>
⊢ (MAP (λx. x) l = l) ∧ (MAP I l = l)
</pre>

<DT><span class="strong">MAP_GENLIST</span>
<DD>
<pre>
⊢ ∀f g n. MAP f (GENLIST g n) = GENLIST (f ∘ g) n
</pre>

<DT><span class="strong">MAP_FRONT</span>
<DD>
<pre>
⊢ ∀ls. ls ≠ [] ⇒ (MAP f (FRONT ls) = FRONT (MAP f ls))
</pre>

<DT><span class="strong">MAP_FLAT</span>
<DD>
<pre>
⊢ MAP f (FLAT l) = FLAT (MAP (MAP f) l)
</pre>

<DT><span class="strong">MAP_EQ_SING</span>
<DD>
<pre>
⊢ (MAP f l = [x]) ⇔ ∃x0. (l = [x0]) ∧ (x = f x0)
</pre>

<DT><span class="strong">MAP_EQ_NIL</span>
<DD>
<pre>
⊢ ∀l f. ((MAP f l = []) ⇔ (l = [])) ∧ (([] = MAP f l) ⇔ (l = []))
</pre>

<DT><span class="strong">MAP_EQ_f</span>
<DD>
<pre>
⊢ ∀f1 f2 l. (MAP f1 l = MAP f2 l) ⇔ ∀e. MEM e l ⇒ (f1 e = f2 e)
</pre>

<DT><span class="strong">MAP_EQ_EVERY2</span>
<DD>
<pre>
⊢ ∀f1 f2 l1 l2.
      (MAP f1 l1 = MAP f2 l2) ⇔
      (LENGTH l1 = LENGTH l2) ∧ LIST_REL (λx y. f1 x = f2 y) l1 l2
</pre>

<DT><span class="strong">MAP_EQ_CONS</span>
<DD>
<pre>
⊢ (MAP f l = h::t) ⇔ ∃x0 t0. (l = x0::t0) ∧ (h = f x0) ∧ (t = MAP f t0)
</pre>

<DT><span class="strong">MAP_EQ_APPEND</span>
<DD>
<pre>
⊢ (MAP f l = l1 ++ l2) ⇔
  ∃l10 l20. (l = l10 ++ l20) ∧ (l1 = MAP f l10) ∧ (l2 = MAP f l20)
</pre>

<DT><span class="strong">MAP_DROP</span>
<DD>
<pre>
⊢ ∀l i. MAP f (DROP i l) = DROP i (MAP f l)
</pre>

<DT><span class="strong">MAP_CONG</span>
<DD>
<pre>
⊢ ∀l1 l2 f f'.
      (l1 = l2) ∧ (∀x. MEM x l2 ⇒ (f x = f' x)) ⇒ (MAP f l1 = MAP f' l2)
</pre>

<DT><span class="strong">MAP_APPEND_MAP_EQ</span>
<DD>
<pre>
⊢ ∀xs ys.
      (MAP f1 xs ++ MAP g1 ys = MAP f2 xs ++ MAP g2 ys) ⇔
      (MAP f1 xs = MAP f2 xs) ∧ (MAP g1 ys = MAP g2 ys)
</pre>

<DT><span class="strong">MAP_APPEND</span>
<DD>
<pre>
⊢ ∀f l1 l2. MAP f (l1 ++ l2) = MAP f l1 ++ MAP f l2
</pre>

<DT><span class="strong">MAP2_ZIP</span>
<DD>
<pre>
⊢ ∀l1 l2.
      (LENGTH l1 = LENGTH l2) ⇒
      ∀f. MAP2 f l1 l2 = MAP (UNCURRY f) (ZIP (l1,l2))
</pre>

<DT><span class="strong">MAP2_NIL</span>
<DD>
<pre>
⊢ MAP2 f x [] = []
</pre>

<DT><span class="strong">MAP2_MAP</span>
<DD>
<pre>
⊢ ∀l1 l2.
      (LENGTH l1 = LENGTH l2) ⇒
      ∀f. MAP2 f l1 l2 = MAP (UNCURRY f) (ZIP (l1,l2))
</pre>

<DT><span class="strong">MAP2_ind</span>
<DD>
<pre>
⊢ ∀P.
      (∀f h1 t1 h2 t2. P f t1 t2 ⇒ P f (h1::t1) (h2::t2)) ∧ (∀f y. P f [] y) ∧
      (∀f v4 v5. P f (v4::v5) []) ⇒
      ∀v v1 v2. P v v1 v2
</pre>

<DT><span class="strong">MAP2_DEF</span>
<DD>
<pre>
⊢ (∀t2 t1 h2 h1 f. MAP2 f (h1::t1) (h2::t2) = f h1 h2::MAP2 f t1 t2) ∧
  (∀y f. MAP2 f [] y = []) ∧ ∀v5 v4 f. MAP2 f (v4::v5) [] = []
</pre>

<DT><span class="strong">MAP2_CONG</span>
<DD>
<pre>
⊢ ∀l1 l1' l2 l2' f f'.
      (l1 = l1') ∧ (l2 = l2') ∧
      (∀x y. MEM x l1' ∧ MEM y l2' ⇒ (f x y = f' x y)) ⇒
      (MAP2 f l1 l2 = MAP2 f' l1' l2')
</pre>

<DT><span class="strong">MAP2_APPEND</span>
<DD>
<pre>
⊢ ∀xs ys xs1 ys1 f.
      (LENGTH xs = LENGTH xs1) ⇒
      (MAP2 f (xs ++ ys) (xs1 ++ ys1) = MAP2 f xs xs1 ++ MAP2 f ys ys1)
</pre>

<DT><span class="strong">MAP2</span>
<DD>
<pre>
⊢ (∀f. MAP2 f [] [] = []) ∧
  ∀f h1 t1 h2 t2. MAP2 f (h1::t1) (h2::t2) = f h1 h2::MAP2 f t1 t2
</pre>

<DT><span class="strong">LUPDATE_SOME_MAP</span>
<DD>
<pre>
⊢ ∀xs n f h.
      LUPDATE (SOME (f h)) n (MAP (OPTION_MAP f) xs) =
      MAP (OPTION_MAP f) (LUPDATE (SOME h) n xs)
</pre>

<DT><span class="strong">LUPDATE_SNOC</span>
<DD>
<pre>
⊢ ∀ys k x y.
      LUPDATE x k (SNOC y ys) =
      if k = LENGTH ys then SNOC x ys else SNOC y (LUPDATE x k ys)
</pre>

<DT><span class="strong">LUPDATE_SEM</span>
<DD>
<pre>
⊢ (∀e n l. LENGTH (LUPDATE e n l) = LENGTH l) ∧
  ∀e n l p.
      p < LENGTH l ⇒ (EL p (LUPDATE e n l) = if p = n then e else EL p l)
</pre>

<DT><span class="strong">LUPDATE_SAME</span>
<DD>
<pre>
⊢ ∀n ls. n < LENGTH ls ⇒ (LUPDATE (EL n ls) n ls = ls)
</pre>

<DT><span class="strong">LUPDATE_NIL</span>
<DD>
<pre>
⊢ ∀xs n x. (LUPDATE x n xs = []) ⇔ (xs = [])
</pre>

<DT><span class="strong">LUPDATE_MAP</span>
<DD>
<pre>
⊢ ∀x n l f. MAP f (LUPDATE x n l) = LUPDATE (f x) n (MAP f l)
</pre>

<DT><span class="strong">LUPDATE_LENGTH</span>
<DD>
<pre>
⊢ ∀xs x y ys. LUPDATE x (LENGTH xs) (xs ++ y::ys) = xs ++ x::ys
</pre>

<DT><span class="strong">LUPDATE_compute</span>
<DD>
<pre>
⊢ (∀e n. LUPDATE e n [] = []) ∧ (∀e x l. LUPDATE e 0 (x::l) = e::l) ∧
  (∀e n x l.
       LUPDATE e (NUMERAL (BIT1 n)) (x::l) =
       x::LUPDATE e (NUMERAL (BIT1 n) − 1) l) ∧
  ∀e n x l.
      LUPDATE e (NUMERAL (BIT2 n)) (x::l) = x::LUPDATE e (NUMERAL (BIT1 n)) l
</pre>

<DT><span class="strong">lupdate_append2</span>
<DD>
<pre>
⊢ ∀v l1 x l2 l3. LUPDATE v (LENGTH l1) (l1 ++ [x] ++ l2) = l1 ++ [v] ++ l2
</pre>

<DT><span class="strong">lupdate_append</span>
<DD>
<pre>
⊢ ∀x n l1 l2. n < LENGTH l1 ⇒ (LUPDATE x n (l1 ++ l2) = LUPDATE x n l1 ++ l2)
</pre>

<DT><span class="strong">LRC_MEM_right</span>
<DD>
<pre>
⊢ LRC R (h::t) x y ∧ MEM e t ⇒ ∃z p. R z e ∧ LRC R p x z
</pre>

<DT><span class="strong">LRC_MEM</span>
<DD>
<pre>
⊢ LRC R ls x y ∧ MEM e ls ⇒ ∃z t. R e z ∧ LRC R t z y
</pre>

<DT><span class="strong">LLEX_transitive</span>
<DD>
<pre>
⊢ transitive R ⇒ transitive (LLEX R)
</pre>

<DT><span class="strong">LLEX_total</span>
<DD>
<pre>
⊢ total (RC R) ⇒ total (RC (LLEX R))
</pre>

<DT><span class="strong">LLEX_THM</span>
<DD>
<pre>
⊢ (¬LLEX R [] [] ∧ ¬LLEX R (h1::t1) []) ∧ LLEX R [] (h2::t2) ∧
  (LLEX R (h1::t1) (h2::t2) ⇔ R h1 h2 ∨ (h1 = h2) ∧ LLEX R t1 t2)
</pre>

<DT><span class="strong">LLEX_not_WF</span>
<DD>
<pre>
⊢ (∃a b. R a b) ⇒ ¬WF (LLEX R)
</pre>

<DT><span class="strong">LLEX_NIL2</span>
<DD>
<pre>
⊢ ¬LLEX R l []
</pre>

<DT><span class="strong">LLEX_MONO</span>
<DD>
<pre>
⊢ (∀x y. R1 x y ⇒ R2 x y) ⇒ LLEX R1 x y ⇒ LLEX R2 x y
</pre>

<DT><span class="strong">LLEX_EL_THM</span>
<DD>
<pre>
⊢ ∀R l1 l2.
      LLEX R l1 l2 ⇔
      ∃n.
          n ≤ LENGTH l1 ∧ n < LENGTH l2 ∧ (TAKE n l1 = TAKE n l2) ∧
          (n < LENGTH l1 ⇒ R (EL n l1) (EL n l2))
</pre>

<DT><span class="strong">LLEX_CONG</span>
<DD>
<pre>
⊢ ∀R l1 l2 R' l1' l2'.
      (l1 = l1') ∧ (l2 = l2') ∧
      (∀a b. MEM a l1' ∧ MEM b l2' ⇒ (R a b ⇔ R' a b)) ⇒
      (LLEX R l1 l2 ⇔ LLEX R' l1' l2')
</pre>

<DT><span class="strong">LIST_TO_SET_THM</span>
<DD>
<pre>
⊢ (LIST_TO_SET [] = ∅) ∧ (LIST_TO_SET (h::t) = h INSERT LIST_TO_SET t)
</pre>

<DT><span class="strong">LIST_TO_SET_SNOC</span>
<DD>
<pre>
⊢ LIST_TO_SET (SNOC x ls) = x INSERT LIST_TO_SET ls
</pre>

<DT><span class="strong">LIST_TO_SET_REVERSE</span>
<DD>
<pre>
⊢ ∀ls. LIST_TO_SET (REVERSE ls) = LIST_TO_SET ls
</pre>

<DT><span class="strong">LIST_TO_SET_MAP</span>
<DD>
<pre>
⊢ ∀f l. LIST_TO_SET (MAP f l) = IMAGE f (LIST_TO_SET l)
</pre>

<DT><span class="strong">LIST_TO_SET_GENLIST</span>
<DD>
<pre>
⊢ ∀f n. LIST_TO_SET (GENLIST f n) = IMAGE f (count n)
</pre>

<DT><span class="strong">LIST_TO_SET_FLAT</span>
<DD>
<pre>
⊢ ∀ls. LIST_TO_SET (FLAT ls) = BIGUNION (LIST_TO_SET (MAP LIST_TO_SET ls))
</pre>

<DT><span class="strong">LIST_TO_SET_FILTER</span>
<DD>
<pre>
⊢ LIST_TO_SET (FILTER P l) = {x | P x} ∩ LIST_TO_SET l
</pre>

<DT><span class="strong">LIST_TO_SET_EQ_EMPTY</span>
<DD>
<pre>
⊢ ((LIST_TO_SET l = ∅) ⇔ (l = [])) ∧ ((∅ = LIST_TO_SET l) ⇔ (l = []))
</pre>

<DT><span class="strong">list_to_set_diff</span>
<DD>
<pre>
⊢ ∀l1 l2.
      LIST_TO_SET l2 DIFF LIST_TO_SET l1 =
      LIST_TO_SET (FILTER (λx. ¬MEM x l1) l2)
</pre>

<DT><span class="strong">LIST_TO_SET_APPEND</span>
<DD>
<pre>
⊢ ∀l1 l2. LIST_TO_SET (l1 ++ l2) = LIST_TO_SET l1 ∪ LIST_TO_SET l2
</pre>

<DT><span class="strong">LIST_TO_SET</span>
<DD>
<pre>
⊢ (LIST_TO_SET [] = ∅) ∧ (LIST_TO_SET (h::t) = h INSERT LIST_TO_SET t)
</pre>

<DT><span class="strong">list_size_cong</span>
<DD>
<pre>
⊢ ∀M N f f'.
      (M = N) ∧ (∀x. MEM x N ⇒ (f x = f' x)) ⇒
      (list_size f M = list_size f' N)
</pre>

<DT><span class="strong">LIST_REL_trans</span>
<DD>
<pre>
⊢ ∀l1 l2 l3.
      (∀n.
           n < LENGTH l1 ∧ R (EL n l1) (EL n l2) ∧ R (EL n l2) (EL n l3) ⇒
           R (EL n l1) (EL n l3)) ∧ LIST_REL R l1 l2 ∧ LIST_REL R l2 l3 ⇒
      LIST_REL R l1 l3
</pre>

<DT><span class="strong">LIST_REL_strongind</span>
<DD>
<pre>
⊢ ∀R LIST_REL'.
      LIST_REL' [] [] ∧
      (∀h1 h2 t1 t2.
           R h1 h2 ∧ LIST_REL R t1 t2 ∧ LIST_REL' t1 t2 ⇒
           LIST_REL' (h1::t1) (h2::t2)) ⇒
      ∀a0 a1. LIST_REL R a0 a1 ⇒ LIST_REL' a0 a1
</pre>

<DT><span class="strong">LIST_REL_SPLIT2</span>
<DD>
<pre>
⊢ ∀xs1 zs.
      LIST_REL P zs (xs1 ++ xs2) ⇔
      ∃ys1 ys2. (zs = ys1 ++ ys2) ∧ LIST_REL P ys1 xs1 ∧ LIST_REL P ys2 xs2
</pre>

<DT><span class="strong">LIST_REL_SPLIT1</span>
<DD>
<pre>
⊢ ∀xs1 zs.
      LIST_REL P (xs1 ++ xs2) zs ⇔
      ∃ys1 ys2. (zs = ys1 ++ ys2) ∧ LIST_REL P xs1 ys1 ∧ LIST_REL P xs2 ys2
</pre>

<DT><span class="strong">LIST_REL_SNOC</span>
<DD>
<pre>
⊢ (LIST_REL R (SNOC x xs) yys ⇔
   ∃y ys. (yys = SNOC y ys) ∧ LIST_REL R xs ys ∧ R x y) ∧
  (LIST_REL R xxs (SNOC y ys) ⇔
   ∃x xs. (xxs = SNOC x xs) ∧ LIST_REL R xs ys ∧ R x y)
</pre>

<DT><span class="strong">LIST_REL_rules</span>
<DD>
<pre>
⊢ ∀R.
      LIST_REL R [] [] ∧
      ∀h1 h2 t1 t2. R h1 h2 ∧ LIST_REL R t1 t2 ⇒ LIST_REL R (h1::t1) (h2::t2)
</pre>

<DT><span class="strong">LIST_REL_O</span>
<DD>
<pre>
⊢ ∀R1 R2. LIST_REL (R1 ∘ᵣ R2) = LIST_REL R1 ∘ᵣ LIST_REL R2
</pre>

<DT><span class="strong">LIST_REL_NIL</span>
<DD>
<pre>
⊢ (LIST_REL R [] y ⇔ (y = [])) ∧ (LIST_REL R x [] ⇔ (x = []))
</pre>

<DT><span class="strong">LIST_REL_mono</span>
<DD>
<pre>
⊢ (∀x y. R1 x y ⇒ R2 x y) ⇒ LIST_REL R1 l1 l2 ⇒ LIST_REL R2 l1 l2
</pre>

<DT><span class="strong">LIST_REL_MEM_IMP</span>
<DD>
<pre>
⊢ ∀xs ys P x. LIST_REL P xs ys ∧ MEM x xs ⇒ ∃y. MEM y ys ∧ P x y
</pre>

<DT><span class="strong">LIST_REL_MAP_inv_image</span>
<DD>
<pre>
⊢ LIST_REL R (MAP f l1) (MAP f l2) ⇔ LIST_REL (inv_image R f) l1 l2
</pre>

<DT><span class="strong">LIST_REL_MAP2</span>
<DD>
<pre>
⊢ LIST_REL (λa b. R a b) l1 (MAP f l2) ⇔ LIST_REL (λa b. R a (f b)) l1 l2
</pre>

<DT><span class="strong">LIST_REL_MAP1</span>
<DD>
<pre>
⊢ LIST_REL R (MAP f l1) l2 ⇔ LIST_REL (R ∘ f) l1 l2
</pre>

<DT><span class="strong">LIST_REL_LENGTH</span>
<DD>
<pre>
⊢ ∀x y. LIST_REL R x y ⇒ (LENGTH x = LENGTH y)
</pre>

<DT><span class="strong">LIST_REL_ind</span>
<DD>
<pre>
⊢ ∀R LIST_REL'.
      LIST_REL' [] [] ∧
      (∀h1 h2 t1 t2. R h1 h2 ∧ LIST_REL' t1 t2 ⇒ LIST_REL' (h1::t1) (h2::t2)) ⇒
      ∀a0 a1. LIST_REL R a0 a1 ⇒ LIST_REL' a0 a1
</pre>

<DT><span class="strong">LIST_REL_EVERY_ZIP</span>
<DD>
<pre>
⊢ ∀R l1 l2.
      LIST_REL R l1 l2 ⇔
      (LENGTH l1 = LENGTH l2) ∧ EVERY (UNCURRY R) (ZIP (l1,l2))
</pre>

<DT><span class="strong">LIST_REL_eq</span>
<DD>
<pre>
⊢ LIST_REL $= = $=
</pre>

<DT><span class="strong">LIST_REL_EL_EQN</span>
<DD>
<pre>
⊢ ∀R l1 l2.
      LIST_REL R l1 l2 ⇔
      (LENGTH l1 = LENGTH l2) ∧ ∀n. n < LENGTH l1 ⇒ R (EL n l1) (EL n l2)
</pre>

<DT><span class="strong">LIST_REL_def</span>
<DD>
<pre>
⊢ (LIST_REL R [] [] ⇔ T) ∧ (LIST_REL R (a::as) [] ⇔ F) ∧
  (LIST_REL R [] (b::bs) ⇔ F) ∧
  (LIST_REL R (a::as) (b::bs) ⇔ R a b ∧ LIST_REL R as bs)
</pre>

<DT><span class="strong">LIST_REL_CONS2</span>
<DD>
<pre>
⊢ LIST_REL R xs (h::t) ⇔ ∃h' t'. (xs = h'::t') ∧ R h' h ∧ LIST_REL R t' t
</pre>

<DT><span class="strong">LIST_REL_CONS1</span>
<DD>
<pre>
⊢ LIST_REL R (h::t) xs ⇔ ∃h' t'. (xs = h'::t') ∧ R h h' ∧ LIST_REL R t t'
</pre>

<DT><span class="strong">LIST_REL_CONJ</span>
<DD>
<pre>
⊢ LIST_REL (λa b. P a b ∧ Q a b) l1 l2 ⇔
  LIST_REL (λa b. P a b) l1 l2 ∧ LIST_REL (λa b. Q a b) l1 l2
</pre>

<DT><span class="strong">LIST_REL_cases</span>
<DD>
<pre>
⊢ ∀R a0 a1.
      LIST_REL R a0 a1 ⇔
      (a0 = []) ∧ (a1 = []) ∨
      ∃h1 h2 t1 t2. (a0 = h1::t1) ∧ (a1 = h2::t2) ∧ R h1 h2 ∧ LIST_REL R t1 t2
</pre>

<DT><span class="strong">LIST_REL_APPEND_suff</span>
<DD>
<pre>
⊢ LIST_REL R l1 l2 ∧ LIST_REL R l3 l4 ⇒ LIST_REL R (l1 ++ l3) (l2 ++ l4)
</pre>

<DT><span class="strong">LIST_REL_APPEND_IMP</span>
<DD>
<pre>
⊢ ∀xs ys xs1 ys1.
      LIST_REL P (xs ++ xs1) (ys ++ ys1) ∧ (LENGTH xs = LENGTH ys) ⇒
      LIST_REL P xs ys ∧ LIST_REL P xs1 ys1
</pre>

<DT><span class="strong">LIST_REL_APPEND_EQ</span>
<DD>
<pre>
⊢ (LENGTH x1 = LENGTH x2) ⇒
  (LIST_REL R (x1 ++ y1) (x2 ++ y2) ⇔ LIST_REL R x1 x2 ∧ LIST_REL R y1 y2)
</pre>

<DT><span class="strong">LIST_REL_APPEND</span>
<DD>
<pre>
⊢ LIST_REL R l1 l2 ∧ LIST_REL R l3 l4 ⇔
  LIST_REL R (l1 ++ l3) (l2 ++ l4) ∧ (LENGTH l1 = LENGTH l2) ∧
  (LENGTH l3 = LENGTH l4)
</pre>

<DT><span class="strong">LIST_NOT_EQ</span>
<DD>
<pre>
⊢ ∀l1 l2. l1 ≠ l2 ⇒ ∀h1 h2. h1::l1 ≠ h2::l2
</pre>

<DT><span class="strong">list_nchotomy</span>
<DD>
<pre>
⊢ ∀l. (l = []) ∨ ∃h t. l = h::t
</pre>

<DT><span class="strong">list_induction</span>
<DD>
<pre>
⊢ ∀P. P [] ∧ (∀t. P t ⇒ ∀h. P (h::t)) ⇒ ∀l. P l
</pre>

<DT><span class="strong">list_INDUCT0</span>
<DD>
<pre>
⊢ ∀P. P [] ∧ (∀l. P l ⇒ ∀a. P (a::l)) ⇒ ∀l. P l
</pre>

<DT><span class="strong">list_INDUCT</span>
<DD>
<pre>
⊢ ∀P. P [] ∧ (∀t. P t ⇒ ∀h. P (h::t)) ⇒ ∀l. P l
</pre>

<DT><span class="strong">LIST_EQ_REWRITE</span>
<DD>
<pre>
⊢ ∀l1 l2.
      (l1 = l2) ⇔
      (LENGTH l1 = LENGTH l2) ∧ ∀x. x < LENGTH l1 ⇒ (EL x l1 = EL x l2)
</pre>

<DT><span class="strong">LIST_EQ_MAP_PAIR</span>
<DD>
<pre>
⊢ ∀l1 l2. (MAP FST l1 = MAP FST l2) ∧ (MAP SND l1 = MAP SND l2) ⇒ (l1 = l2)
</pre>

<DT><span class="strong">LIST_EQ</span>
<DD>
<pre>
⊢ ∀l1 l2.
      (LENGTH l1 = LENGTH l2) ∧ (∀x. x < LENGTH l1 ⇒ (EL x l1 = EL x l2)) ⇒
      (l1 = l2)
</pre>

<DT><span class="strong">list_distinct</span>
<DD>
<pre>
⊢ ∀a1 a0. [] ≠ a0::a1
</pre>

<DT><span class="strong">list_CASES</span>
<DD>
<pre>
⊢ ∀l. (l = []) ∨ ∃h t. l = h::t
</pre>

<DT><span class="strong">list_case_eq</span>
<DD>
<pre>
⊢ (list_CASE x v f = v') ⇔
  (x = []) ∧ (v = v') ∨ ∃a l. (x = a::l) ∧ (f a l = v')
</pre>

<DT><span class="strong">list_case_cong</span>
<DD>
<pre>
⊢ ∀M M' v f.
      (M = M') ∧ ((M' = []) ⇒ (v = v')) ∧
      (∀a0 a1. (M' = a0::a1) ⇒ (f a0 a1 = f' a0 a1)) ⇒
      (list_CASE M v f = list_CASE M' v' f')
</pre>

<DT><span class="strong">list_case_compute</span>
<DD>
<pre>
⊢ ∀l. list_CASE l b f = if NULL l then b else f (HD l) (TL l)
</pre>

<DT><span class="strong">LIST_BIND_THM</span>
<DD>
<pre>
⊢ (LIST_BIND [] f = []) ∧ (LIST_BIND (h::t) f = f h ++ LIST_BIND t f)
</pre>

<DT><span class="strong">LIST_BIND_MAP</span>
<DD>
<pre>
⊢ LIST_BIND (MAP f l) g = LIST_BIND l (g ∘ f)
</pre>

<DT><span class="strong">LIST_BIND_LIST_BIND</span>
<DD>
<pre>
⊢ LIST_BIND (LIST_BIND l g) f = LIST_BIND l (combin$C LIST_BIND f ∘ g)
</pre>

<DT><span class="strong">LIST_BIND_ID</span>
<DD>
<pre>
⊢ (LIST_BIND l (λx. x) = FLAT l) ∧ (LIST_BIND l I = FLAT l)
</pre>

<DT><span class="strong">LIST_BIND_APPEND</span>
<DD>
<pre>
⊢ LIST_BIND (l1 ++ l2) f = LIST_BIND l1 f ++ LIST_BIND l2 f
</pre>

<DT><span class="strong">list_Axiom_old</span>
<DD>
<pre>
⊢ ∀x f. ∃!fn1. (fn1 [] = x) ∧ ∀h t. fn1 (h::t) = f (fn1 t) h t
</pre>

<DT><span class="strong">list_Axiom</span>
<DD>
<pre>
⊢ ∀f0 f1. ∃fn. (fn [] = f0) ∧ ∀a0 a1. fn (a0::a1) = f1 a0 a1 (fn a1)
</pre>

<DT><span class="strong">LIST_APPLY_o</span>
<DD>
<pre>
⊢ [$o] <*> fs <*> gs <*> xs = fs <*> (gs <*> xs)
</pre>

<DT><span class="strong">list_11</span>
<DD>
<pre>
⊢ ∀a0 a1 a0' a1'. (a0::a1 = a0'::a1') ⇔ (a0 = a0') ∧ (a1 = a1')
</pre>

<DT><span class="strong">LENGTH_ZIP_MIN</span>
<DD>
<pre>
⊢ ∀xs ys. LENGTH (ZIP (xs,ys)) = MIN (LENGTH xs) (LENGTH ys)
</pre>

<DT><span class="strong">LENGTH_ZIP</span>
<DD>
<pre>
⊢ ∀l1 l2.
      (LENGTH l1 = LENGTH l2) ⇒
      (LENGTH (ZIP (l1,l2)) = LENGTH l1) ∧ (LENGTH (ZIP (l1,l2)) = LENGTH l2)
</pre>

<DT><span class="strong">LENGTH_UNZIP</span>
<DD>
<pre>
⊢ ∀pl.
      (LENGTH (FST (UNZIP pl)) = LENGTH pl) ∧
      (LENGTH (SND (UNZIP pl)) = LENGTH pl)
</pre>

<DT><span class="strong">LENGTH_TL</span>
<DD>
<pre>
⊢ ∀l. 0 < LENGTH l ⇒ (LENGTH (TL l) = LENGTH l − 1)
</pre>

<DT><span class="strong">LENGTH_TAKE_EQ</span>
<DD>
<pre>
⊢ LENGTH (TAKE n xs) = if n ≤ LENGTH xs then n else LENGTH xs
</pre>

<DT><span class="strong">LENGTH_TAKE</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ (LENGTH (TAKE n l) = n)
</pre>

<DT><span class="strong">LENGTH_SNOC</span>
<DD>
<pre>
⊢ ∀x l. LENGTH (SNOC x l) = SUC (LENGTH l)
</pre>

<DT><span class="strong">LENGTH_REVERSE</span>
<DD>
<pre>
⊢ ∀l. LENGTH (REVERSE l) = LENGTH l
</pre>

<DT><span class="strong">LENGTH_o_REVERSE</span>
<DD>
<pre>
⊢ (LENGTH ∘ REVERSE = LENGTH) ∧ (LENGTH ∘ REVERSE ∘ f = LENGTH ∘ f)
</pre>

<DT><span class="strong">length_nub_append</span>
<DD>
<pre>
⊢ ∀l1 l2.
      LENGTH (nub (l1 ++ l2)) =
      LENGTH (nub l1) + LENGTH (nub (FILTER (λx. ¬MEM x l1) l2))
</pre>

<DT><span class="strong">LENGTH_NIL_SYM</span>
<DD>
<pre>
⊢ (0 = LENGTH l) ⇔ (l = [])
</pre>

<DT><span class="strong">LENGTH_NIL</span>
<DD>
<pre>
⊢ ∀l. (LENGTH l = 0) ⇔ (l = [])
</pre>

<DT><span class="strong">LENGTH_MAP2</span>
<DD>
<pre>
⊢ ∀xs ys. LENGTH (MAP2 f xs ys) = MIN (LENGTH xs) (LENGTH ys)
</pre>

<DT><span class="strong">LENGTH_MAP</span>
<DD>
<pre>
⊢ ∀l f. LENGTH (MAP f l) = LENGTH l
</pre>

<DT><span class="strong">LENGTH_LUPDATE</span>
<DD>
<pre>
⊢ ∀x n ys. LENGTH (LUPDATE x n ys) = LENGTH ys
</pre>

<DT><span class="strong">LENGTH_LT_SHORTLEX</span>
<DD>
<pre>
⊢ ∀l1 l2. LENGTH l1 < LENGTH l2 ⇒ SHORTLEX R l1 l2
</pre>

<DT><span class="strong">LENGTH_LEN</span>
<DD>
<pre>
⊢ ∀L. LENGTH L = LEN L 0
</pre>

<DT><span class="strong">LENGTH_GENLIST</span>
<DD>
<pre>
⊢ ∀f n. LENGTH (GENLIST f n) = n
</pre>

<DT><span class="strong">LENGTH_FRONT_CONS</span>
<DD>
<pre>
⊢ ∀x xs. LENGTH (FRONT (x::xs)) = LENGTH xs
</pre>

<DT><span class="strong">LENGTH_FILTER_LEQ_MONO</span>
<DD>
<pre>
⊢ ∀P Q. (∀x. P x ⇒ Q x) ⇒ ∀ls. LENGTH (FILTER P ls) ≤ LENGTH (FILTER Q ls)
</pre>

<DT><span class="strong">LENGTH_EQ_SUM</span>
<DD>
<pre>
⊢ ∀l n1 n2.
      (LENGTH l = n1 + n2) ⇔
      ∃l1 l2. (LENGTH l1 = n1) ∧ (LENGTH l2 = n2) ∧ (l = l1 ++ l2)
</pre>

<DT><span class="strong">LENGTH_EQ_NUM_compute</span>
<DD>
<pre>
⊢ (∀l. (LENGTH l = 0) ⇔ (l = [])) ∧
  (∀l n.
       (LENGTH l = NUMERAL (BIT1 n)) ⇔
       ∃h l'. (LENGTH l' = NUMERAL (BIT1 n) − 1) ∧ (l = h::l')) ∧
  (∀l n.
       (LENGTH l = NUMERAL (BIT2 n)) ⇔
       ∃h l'. (LENGTH l' = NUMERAL (BIT1 n)) ∧ (l = h::l')) ∧
  ∀l n1 n2.
      (LENGTH l = n1 + n2) ⇔
      ∃l1 l2. (LENGTH l1 = n1) ∧ (LENGTH l2 = n2) ∧ (l = l1 ++ l2)
</pre>

<DT><span class="strong">LENGTH_EQ_NUM</span>
<DD>
<pre>
⊢ (∀l. (LENGTH l = 0) ⇔ (l = [])) ∧
  (∀l n. (LENGTH l = SUC n) ⇔ ∃h l'. (LENGTH l' = n) ∧ (l = h::l')) ∧
  ∀l n1 n2.
      (LENGTH l = n1 + n2) ⇔
      ∃l1 l2. (LENGTH l1 = n1) ∧ (LENGTH l2 = n2) ∧ (l = l1 ++ l2)
</pre>

<DT><span class="strong">LENGTH_EQ_NIL</span>
<DD>
<pre>
⊢ ∀P. (∀l. (LENGTH l = 0) ⇒ P l) ⇔ P []
</pre>

<DT><span class="strong">LENGTH_EQ_CONS</span>
<DD>
<pre>
⊢ ∀P n.
      (∀l. (LENGTH l = SUC n) ⇒ P l) ⇔
      ∀l. (LENGTH l = n) ⇒ (λl. ∀x. P (x::l)) l
</pre>

<DT><span class="strong">LENGTH_dropWhile_LESS_EQ</span>
<DD>
<pre>
⊢ ∀P ls. LENGTH (dropWhile P ls) ≤ LENGTH ls
</pre>

<DT><span class="strong">LENGTH_DROP</span>
<DD>
<pre>
⊢ ∀n l. LENGTH (DROP n l) = LENGTH l − n
</pre>

<DT><span class="strong">LENGTH_CONS</span>
<DD>
<pre>
⊢ ∀l n. (LENGTH l = SUC n) ⇔ ∃h l'. (LENGTH l' = n) ∧ (l = h::l')
</pre>

<DT><span class="strong">LENGTH_APPEND</span>
<DD>
<pre>
⊢ ∀l1 l2. LENGTH (l1 ++ l2) = LENGTH l1 + LENGTH l2
</pre>

<DT><span class="strong">LEN_LENGTH_LEM</span>
<DD>
<pre>
⊢ ∀L n. LEN L n = LENGTH L + n
</pre>

<DT><span class="strong">lazy_list_case_compute</span>
<DD>
<pre>
⊢ list_CASE = (λl b f. if NULL l then b else f (HD l) (TL l))
</pre>

<DT><span class="strong">LAST_SNOC</span>
<DD>
<pre>
⊢ ∀x l. LAST (SNOC x l) = x
</pre>

<DT><span class="strong">LAST_REVERSE</span>
<DD>
<pre>
⊢ ∀ls. ls ≠ [] ⇒ (LAST (REVERSE ls) = HD ls)
</pre>

<DT><span class="strong">LAST_MAP</span>
<DD>
<pre>
⊢ ∀l f. l ≠ [] ⇒ (LAST (MAP f l) = f (LAST l))
</pre>

<DT><span class="strong">LAST_EL</span>
<DD>
<pre>
⊢ ∀ls. ls ≠ [] ⇒ (LAST ls = EL (PRE (LENGTH ls)) ls)
</pre>

<DT><span class="strong">last_drop</span>
<DD>
<pre>
⊢ ∀l n. n < LENGTH l ⇒ (LAST (DROP n l) = LAST l)
</pre>

<DT><span class="strong">LAST_CONS_cond</span>
<DD>
<pre>
⊢ LAST (h::t) = if t = [] then h else LAST t
</pre>

<DT><span class="strong">LAST_CONS</span>
<DD>
<pre>
⊢ (∀x. LAST [x] = x) ∧ ∀x y z. LAST (x::y::z) = LAST (y::z)
</pre>

<DT><span class="strong">LAST_compute</span>
<DD>
<pre>
⊢ (∀x. LAST [x] = x) ∧ ∀h1 h2 t. LAST (h1::h2::t) = LAST (h2::t)
</pre>

<DT><span class="strong">LAST_APPEND_CONS</span>
<DD>
<pre>
⊢ ∀h l1 l2. LAST (l1 ++ h::l2) = LAST (h::l2)
</pre>

<DT><span class="strong">ITSET_eq_FOLDL_SET_TO_LIST</span>
<DD>
<pre>
⊢ ∀s. FINITE s ⇒ ∀f a. ITSET f s a = FOLDL (combin$C f) a (SET_TO_LIST s)
</pre>

<DT><span class="strong">isPREFIX_THM</span>
<DD>
<pre>
⊢ ([] ≼ l ⇔ T) ∧ (h::t ≼ [] ⇔ F) ∧ (h1::t1 ≼ h2::t2 ⇔ (h1 = h2) ∧ t1 ≼ t2)
</pre>

<DT><span class="strong">isPREFIX_NILR</span>
<DD>
<pre>
⊢ x ≼ [] ⇔ (x = [])
</pre>

<DT><span class="strong">isPREFIX_CONSR</span>
<DD>
<pre>
⊢ x ≼ y::ys ⇔ (x = []) ∨ ∃xs. (x = y::xs) ∧ xs ≼ ys
</pre>

<DT><span class="strong">INJ_MAP_EQ_IFF</span>
<DD>
<pre>
⊢ ∀f l1 l2.
      INJ f (LIST_TO_SET l1 ∪ LIST_TO_SET l2) 𝕌(:β) ⇒
      ((MAP f l1 = MAP f l2) ⇔ (l1 = l2))
</pre>

<DT><span class="strong">INJ_MAP_EQ</span>
<DD>
<pre>
⊢ ∀f l1 l2.
      INJ f (LIST_TO_SET l1 ∪ LIST_TO_SET l2) 𝕌(:β) ∧ (MAP f l1 = MAP f l2) ⇒
      (l1 = l2)
</pre>

<DT><span class="strong">INFINITE_LIST_UNIV</span>
<DD>
<pre>
⊢ INFINITE 𝕌(:α list)
</pre>

<DT><span class="strong">IMP_EVERY_LUPDATE</span>
<DD>
<pre>
⊢ ∀xs h i. P h ∧ EVERY P xs ⇒ EVERY P (LUPDATE h i xs)
</pre>

<DT><span class="strong">IMAGE_EL_count_LENGTH</span>
<DD>
<pre>
⊢ ∀f ls.
      IMAGE (λn. f (EL n ls)) (count (LENGTH ls)) = IMAGE f (LIST_TO_SET ls)
</pre>

<DT><span class="strong">HD_REVERSE</span>
<DD>
<pre>
⊢ ∀x. x ≠ [] ⇒ (HD (REVERSE x) = LAST x)
</pre>

<DT><span class="strong">HD_GENLIST_COR</span>
<DD>
<pre>
⊢ ∀n f. 0 < n ⇒ (HD (GENLIST f n) = f 0)
</pre>

<DT><span class="strong">HD_GENLIST</span>
<DD>
<pre>
⊢ HD (GENLIST f (SUC n)) = f 0
</pre>

<DT><span class="strong">HD_dropWhile</span>
<DD>
<pre>
⊢ ∀P ls. EXISTS ($~ ∘ P) ls ⇒ ¬P (HD (dropWhile P ls))
</pre>

<DT><span class="strong">HD_DROP</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ (HD (DROP n l) = EL n l)
</pre>

<DT><span class="strong">GENLIST_PLUS_APPEND</span>
<DD>
<pre>
⊢ GENLIST ($+ a) n1 ++ GENLIST ($+ (n1 + a)) n2 = GENLIST ($+ a) (n1 + n2)
</pre>

<DT><span class="strong">GENLIST_NUMERALS</span>
<DD>
<pre>
⊢ (GENLIST f 0 = []) ∧ (GENLIST f (NUMERAL n) = GENLIST_AUX f (NUMERAL n) [])
</pre>

<DT><span class="strong">GENLIST_ID</span>
<DD>
<pre>
⊢ ∀x. GENLIST (λi. EL i x) (LENGTH x) = x
</pre>

<DT><span class="strong">GENLIST_GENLIST_AUX</span>
<DD>
<pre>
⊢ ∀n. GENLIST f n = GENLIST_AUX f n []
</pre>

<DT><span class="strong">GENLIST_FUN_EQ</span>
<DD>
<pre>
⊢ ∀n f g. (GENLIST f n = GENLIST g n) ⇔ ∀x. x < n ⇒ (f x = g x)
</pre>

<DT><span class="strong">GENLIST_EL_MAP</span>
<DD>
<pre>
⊢ ∀f ls. GENLIST (λn. f (EL n ls)) (LENGTH ls) = MAP f ls
</pre>

<DT><span class="strong">GENLIST_EL</span>
<DD>
<pre>
⊢ ∀ls f n.
      (n = LENGTH ls) ∧ (∀i. i < n ⇒ (f i = EL i ls)) ⇒ (GENLIST f n = ls)
</pre>

<DT><span class="strong">GENLIST_CONS</span>
<DD>
<pre>
⊢ GENLIST f (SUC n) = f 0::GENLIST (f ∘ SUC) n
</pre>

<DT><span class="strong">GENLIST_AUX_compute</span>
<DD>
<pre>
⊢ (∀f l. GENLIST_AUX f 0 l = l) ∧
  (∀f n l.
       GENLIST_AUX f (NUMERAL (BIT1 n)) l =
       GENLIST_AUX f (NUMERAL (BIT1 n) − 1) (f (NUMERAL (BIT1 n) − 1)::l)) ∧
  ∀f n l.
      GENLIST_AUX f (NUMERAL (BIT2 n)) l =
      GENLIST_AUX f (NUMERAL (BIT1 n)) (f (NUMERAL (BIT1 n))::l)
</pre>

<DT><span class="strong">GENLIST_APPEND</span>
<DD>
<pre>
⊢ ∀f a b. GENLIST f (a + b) = GENLIST f b ++ GENLIST (λt. f (t + b)) a
</pre>

<DT><span class="strong">FRONT_SNOC</span>
<DD>
<pre>
⊢ ∀x l. FRONT (SNOC x l) = l
</pre>

<DT><span class="strong">FRONT_CONS_EQ_NIL</span>
<DD>
<pre>
⊢ (∀x xs. (FRONT (x::xs) = []) ⇔ (xs = [])) ∧
  (∀x xs. ([] = FRONT (x::xs)) ⇔ (xs = [])) ∧
  ∀x xs. NULL (FRONT (x::xs)) ⇔ NULL xs
</pre>

<DT><span class="strong">FRONT_CONS</span>
<DD>
<pre>
⊢ (∀x. FRONT [x] = []) ∧ ∀x y z. FRONT (x::y::z) = x::FRONT (y::z)
</pre>

<DT><span class="strong">FORALL_LIST</span>
<DD>
<pre>
⊢ (∀l. P l) ⇔ P [] ∧ ∀h t. P (h::t)
</pre>

<DT><span class="strong">FOLDR_CONS</span>
<DD>
<pre>
⊢ ∀f ls a. FOLDR (λx y. f x::y) a ls = MAP f ls ++ a
</pre>

<DT><span class="strong">FOLDR_CONG</span>
<DD>
<pre>
⊢ ∀l l' b b' f f'.
      (l = l') ∧ (b = b') ∧ (∀x a. MEM x l' ⇒ (f x a = f' x a)) ⇒
      (FOLDR f b l = FOLDR f' b' l')
</pre>

<DT><span class="strong">FOLDL_ZIP_SAME</span>
<DD>
<pre>
⊢ ∀ls f e. FOLDL f e (ZIP (ls,ls)) = FOLDL (λx y. f x (y,y)) e ls
</pre>

<DT><span class="strong">FOLDL_UNION_BIGUNION_paired</span>
<DD>
<pre>
⊢ ∀f ls s.
      FOLDL (λs (x,y). s ∪ f x y) s ls =
      s ∪ BIGUNION (IMAGE (UNCURRY f) (LIST_TO_SET ls))
</pre>

<DT><span class="strong">FOLDL_UNION_BIGUNION</span>
<DD>
<pre>
⊢ ∀f ls s.
      FOLDL (λs x. s ∪ f x) s ls = s ∪ BIGUNION (IMAGE f (LIST_TO_SET ls))
</pre>

<DT><span class="strong">FOLDL_SNOC</span>
<DD>
<pre>
⊢ ∀f e x l. FOLDL f e (SNOC x l) = f (FOLDL f e l) x
</pre>

<DT><span class="strong">FOLDL_EQ_FOLDR</span>
<DD>
<pre>
⊢ ∀f l e. ASSOC f ∧ COMM f ⇒ (FOLDL f e l = FOLDR f e l)
</pre>

<DT><span class="strong">FOLDL_CONG</span>
<DD>
<pre>
⊢ ∀l l' b b' f f'.
      (l = l') ∧ (b = b') ∧ (∀x a. MEM x l' ⇒ (f a x = f' a x)) ⇒
      (FOLDL f b l = FOLDL f' b' l')
</pre>

<DT><span class="strong">FOLDL2_ind</span>
<DD>
<pre>
⊢ ∀P.
      (∀f a b bs c cs. P f (f a b c) bs cs ⇒ P f a (b::bs) (c::cs)) ∧
      (∀f a cs. P f a [] cs) ∧ (∀f a v6 v7. P f a (v6::v7) []) ⇒
      ∀v v1 v2 v3. P v v1 v2 v3
</pre>

<DT><span class="strong">FOLDL2_FOLDL</span>
<DD>
<pre>
⊢ ∀l1 l2.
      (LENGTH l1 = LENGTH l2) ⇒
      ∀f a. FOLDL2 f a l1 l2 = FOLDL (λa. UNCURRY (f a)) a (ZIP (l1,l2))
</pre>

<DT><span class="strong">FOLDL2_def</span>
<DD>
<pre>
⊢ (∀f cs c bs b a. FOLDL2 f a (b::bs) (c::cs) = FOLDL2 f (f a b c) bs cs) ∧
  (∀f cs a. FOLDL2 f a [] cs = a) ∧ ∀v7 v6 f a. FOLDL2 f a (v6::v7) [] = a
</pre>

<DT><span class="strong">FOLDL2_cong</span>
<DD>
<pre>
⊢ ∀l1 l1' l2 l2' a a' f f'.
      (l1 = l1') ∧ (l2 = l2') ∧ (a = a') ∧
      (∀z b c. MEM b l1' ∧ MEM c l2' ⇒ (f z b c = f' z b c)) ⇒
      (FOLDL2 f a l1 l2 = FOLDL2 f' a' l1' l2')
</pre>

<DT><span class="strong">FLAT_EQ_NIL</span>
<DD>
<pre>
⊢ ∀ls. (FLAT ls = []) ⇔ EVERY ($= []) ls
</pre>

<DT><span class="strong">FLAT_compute</span>
<DD>
<pre>
⊢ (FLAT [] = []) ∧ (FLAT ([]::t) = FLAT t) ∧
  (FLAT ((h::t1)::t2) = h::FLAT (t1::t2))
</pre>

<DT><span class="strong">FLAT_APPEND</span>
<DD>
<pre>
⊢ ∀l1 l2. FLAT (l1 ++ l2) = FLAT l1 ++ FLAT l2
</pre>

<DT><span class="strong">FINITE_LIST_TO_SET</span>
<DD>
<pre>
⊢ ∀l. FINITE (LIST_TO_SET l)
</pre>

<DT><span class="strong">FILTER_T</span>
<DD>
<pre>
⊢ ∀xs. FILTER (λx. T) xs = xs
</pre>

<DT><span class="strong">FILTER_REVERSE</span>
<DD>
<pre>
⊢ ∀l P. FILTER P (REVERSE l) = REVERSE (FILTER P l)
</pre>

<DT><span class="strong">FILTER_NEQ_NIL</span>
<DD>
<pre>
⊢ ∀P l. FILTER P l ≠ [] ⇔ ∃x. MEM x l ∧ P x
</pre>

<DT><span class="strong">FILTER_NEQ_ID</span>
<DD>
<pre>
⊢ ∀P l. FILTER P l ≠ l ⇔ ∃x. MEM x l ∧ ¬P x
</pre>

<DT><span class="strong">FILTER_F</span>
<DD>
<pre>
⊢ ∀xs. FILTER (λx. F) xs = []
</pre>

<DT><span class="strong">FILTER_EQ_NIL</span>
<DD>
<pre>
⊢ ∀P l. (FILTER P l = []) ⇔ EVERY (λx. ¬P x) l
</pre>

<DT><span class="strong">FILTER_EQ_ID</span>
<DD>
<pre>
⊢ ∀P l. (FILTER P l = l) ⇔ EVERY P l
</pre>

<DT><span class="strong">FILTER_EQ_CONS</span>
<DD>
<pre>
⊢ ∀P l h lr.
      (FILTER P l = h::lr) ⇔
      ∃l1 l2.
          (l = l1 ++ [h] ++ l2) ∧ (FILTER P l1 = []) ∧ (FILTER P l2 = lr) ∧
          P h
</pre>

<DT><span class="strong">FILTER_EQ_APPEND</span>
<DD>
<pre>
⊢ ∀P l l1 l2.
      (FILTER P l = l1 ++ l2) ⇔
      ∃l3 l4. (l = l3 ++ l4) ∧ (FILTER P l3 = l1) ∧ (FILTER P l4 = l2)
</pre>

<DT><span class="strong">FILTER_COND_REWRITE</span>
<DD>
<pre>
⊢ (FILTER P [] = []) ∧ (∀h. P h ⇒ (FILTER P (h::l) = h::FILTER P l)) ∧
  ∀h. ¬P h ⇒ (FILTER P (h::l) = FILTER P l)
</pre>

<DT><span class="strong">FILTER_APPEND_DISTRIB</span>
<DD>
<pre>
⊢ ∀P L M. FILTER P (L ++ M) = FILTER P L ++ FILTER P M
</pre>

<DT><span class="strong">FILTER_ALL_DISTINCT</span>
<DD>
<pre>
⊢ ∀P l. ALL_DISTINCT l ⇒ ALL_DISTINCT (FILTER P l)
</pre>

<DT><span class="strong">EXISTS_SNOC</span>
<DD>
<pre>
⊢ ∀P x l. EXISTS P (SNOC x l) ⇔ P x ∨ EXISTS P l
</pre>

<DT><span class="strong">EXISTS_SIMP</span>
<DD>
<pre>
⊢ ∀c l. EXISTS (λx. c) l ⇔ l ≠ [] ∧ c
</pre>

<DT><span class="strong">EXISTS_NOT_EVERY</span>
<DD>
<pre>
⊢ ∀P l. EXISTS P l ⇔ ¬EVERY (λx. ¬P x) l
</pre>

<DT><span class="strong">EXISTS_MEM</span>
<DD>
<pre>
⊢ ∀P l. EXISTS P l ⇔ ∃e. MEM e l ∧ P e
</pre>

<DT><span class="strong">EXISTS_MAP</span>
<DD>
<pre>
⊢ ∀P f l. EXISTS P (MAP f l) ⇔ EXISTS (λx. P (f x)) l
</pre>

<DT><span class="strong">exists_list_GENLIST</span>
<DD>
<pre>
⊢ (∃ls. P ls) ⇔ ∃n f. P (GENLIST f n)
</pre>

<DT><span class="strong">EXISTS_LIST_EQ_MAP</span>
<DD>
<pre>
⊢ ∀ls f. EVERY (λx. ∃y. x = f y) ls ⇒ ∃l. ls = MAP f l
</pre>

<DT><span class="strong">EXISTS_LIST</span>
<DD>
<pre>
⊢ (∃l. P l) ⇔ P [] ∨ ∃h t. P (h::t)
</pre>

<DT><span class="strong">EXISTS_GENLIST</span>
<DD>
<pre>
⊢ ∀n. EXISTS P (GENLIST f n) ⇔ ∃i. i < n ∧ P (f i)
</pre>

<DT><span class="strong">EXISTS_CONG</span>
<DD>
<pre>
⊢ ∀l1 l2 P P'.
      (l1 = l2) ∧ (∀x. MEM x l2 ⇒ (P x ⇔ P' x)) ⇒ (EXISTS P l1 ⇔ EXISTS P' l2)
</pre>

<DT><span class="strong">EXISTS_APPEND</span>
<DD>
<pre>
⊢ ∀P l1 l2. EXISTS P (l1 ++ l2) ⇔ EXISTS P l1 ∨ EXISTS P l2
</pre>

<DT><span class="strong">every_zip_snd</span>
<DD>
<pre>
⊢ ∀l1 l2 P.
      (LENGTH l1 = LENGTH l2) ⇒
      (EVERY (λx. P (SND x)) (ZIP (l1,l2)) ⇔ EVERY P l2)
</pre>

<DT><span class="strong">every_zip_fst</span>
<DD>
<pre>
⊢ ∀l1 l2 P.
      (LENGTH l1 = LENGTH l2) ⇒
      (EVERY (λx. P (FST x)) (ZIP (l1,l2)) ⇔ EVERY P l1)
</pre>

<DT><span class="strong">EVERY_SNOC</span>
<DD>
<pre>
⊢ ∀P x l. EVERY P (SNOC x l) ⇔ EVERY P l ∧ P x
</pre>

<DT><span class="strong">EVERY_SIMP</span>
<DD>
<pre>
⊢ ∀c l. EVERY (λx. c) l ⇔ (l = []) ∨ c
</pre>

<DT><span class="strong">EVERY_NOT_EXISTS</span>
<DD>
<pre>
⊢ ∀P l. EVERY P l ⇔ ¬EXISTS (λx. ¬P x) l
</pre>

<DT><span class="strong">EVERY_MONOTONIC</span>
<DD>
<pre>
⊢ ∀P Q. (∀x. P x ⇒ Q x) ⇒ ∀l. EVERY P l ⇒ EVERY Q l
</pre>

<DT><span class="strong">EVERY_MEM_MONO</span>
<DD>
<pre>
⊢ ∀P Q l. (∀x. MEM x l ∧ P x ⇒ Q x) ∧ EVERY P l ⇒ EVERY Q l
</pre>

<DT><span class="strong">EVERY_MEM</span>
<DD>
<pre>
⊢ ∀P l. EVERY P l ⇔ ∀e. MEM e l ⇒ P e
</pre>

<DT><span class="strong">EVERY_MAP</span>
<DD>
<pre>
⊢ ∀P f l. EVERY P (MAP f l) ⇔ EVERY (λx. P (f x)) l
</pre>

<DT><span class="strong">EVERY_GENLIST</span>
<DD>
<pre>
⊢ ∀n. EVERY P (GENLIST f n) ⇔ ∀i. i < n ⇒ P (f i)
</pre>

<DT><span class="strong">EVERY_FLAT</span>
<DD>
<pre>
⊢ EVERY P (FLAT ls) ⇔ EVERY (EVERY P) ls
</pre>

<DT><span class="strong">EVERY_FILTER_IMP</span>
<DD>
<pre>
⊢ ∀P1 P2 l. EVERY P1 l ⇒ EVERY P1 (FILTER P2 l)
</pre>

<DT><span class="strong">EVERY_FILTER</span>
<DD>
<pre>
⊢ ∀P1 P2 l. EVERY P1 (FILTER P2 l) ⇔ EVERY (λx. P2 x ⇒ P1 x) l
</pre>

<DT><span class="strong">EVERY_EL</span>
<DD>
<pre>
⊢ ∀l P. EVERY P l ⇔ ∀n. n < LENGTH l ⇒ P (EL n l)
</pre>

<DT><span class="strong">EVERY_CONJ</span>
<DD>
<pre>
⊢ ∀P Q l. EVERY (λx. P x ∧ Q x) l ⇔ EVERY P l ∧ EVERY Q l
</pre>

<DT><span class="strong">EVERY_CONG</span>
<DD>
<pre>
⊢ ∀l1 l2 P P'.
      (l1 = l2) ∧ (∀x. MEM x l2 ⇒ (P x ⇔ P' x)) ⇒ (EVERY P l1 ⇔ EVERY P' l2)
</pre>

<DT><span class="strong">EVERY_APPEND</span>
<DD>
<pre>
⊢ ∀P l1 l2. EVERY P (l1 ++ l2) ⇔ EVERY P l1 ∧ EVERY P l2
</pre>

<DT><span class="strong">EVERY2_trans</span>
<DD>
<pre>
⊢ (∀x y z. R x y ∧ R y z ⇒ R x z) ⇒
  ∀x y z. LIST_REL R x y ∧ LIST_REL R y z ⇒ LIST_REL R x z
</pre>

<DT><span class="strong">EVERY2_THM</span>
<DD>
<pre>
⊢ (∀P ys. LIST_REL P [] ys ⇔ (ys = [])) ∧
  (∀P yys x xs.
       LIST_REL P (x::xs) yys ⇔
       ∃y ys. (yys = y::ys) ∧ P x y ∧ LIST_REL P xs ys) ∧
  (∀P xs. LIST_REL P xs [] ⇔ (xs = [])) ∧
  ∀P xxs y ys.
      LIST_REL P xxs (y::ys) ⇔ ∃x xs. (xxs = x::xs) ∧ P x y ∧ LIST_REL P xs ys
</pre>

<DT><span class="strong">EVERY2_sym</span>
<DD>
<pre>
⊢ (∀x y. R1 x y ⇒ R2 y x) ⇒ ∀x y. LIST_REL R1 x y ⇒ LIST_REL R2 y x
</pre>

<DT><span class="strong">EVERY2_REVERSE</span>
<DD>
<pre>
⊢ ∀R l1 l2. LIST_REL R l1 l2 ⇒ LIST_REL R (REVERSE l1) (REVERSE l2)
</pre>

<DT><span class="strong">EVERY2_refl</span>
<DD>
<pre>
⊢ (∀x. MEM x ls ⇒ R x x) ⇒ LIST_REL R ls ls
</pre>

<DT><span class="strong">EVERY2_mono</span>
<DD>
<pre>
⊢ (∀x y. R1 x y ⇒ R2 x y) ⇒ LIST_REL R1 l1 l2 ⇒ LIST_REL R2 l1 l2
</pre>

<DT><span class="strong">EVERY2_MEM_MONO</span>
<DD>
<pre>
⊢ ∀P Q l1 l2.
      (∀x. MEM x (ZIP (l1,l2)) ∧ UNCURRY P x ⇒ UNCURRY Q x) ∧ LIST_REL P l1 l2 ⇒
      LIST_REL Q l1 l2
</pre>

<DT><span class="strong">EVERY2_MAP</span>
<DD>
<pre>
⊢ (LIST_REL P (MAP f l1) l2 ⇔ LIST_REL (λx y. P (f x) y) l1 l2) ∧
  (LIST_REL Q l1 (MAP g l2) ⇔ LIST_REL (λx y. Q x (g y)) l1 l2)
</pre>

<DT><span class="strong">EVERY2_LUPDATE_same</span>
<DD>
<pre>
⊢ ∀P l1 l2 v1 v2 n.
      P v1 v2 ∧ LIST_REL P l1 l2 ⇒
      LIST_REL P (LUPDATE v1 n l1) (LUPDATE v2 n l2)
</pre>

<DT><span class="strong">EVERY2_LENGTH</span>
<DD>
<pre>
⊢ ∀P l1 l2. LIST_REL P l1 l2 ⇒ (LENGTH l1 = LENGTH l2)
</pre>

<DT><span class="strong">EVERY2_EVERY</span>
<DD>
<pre>
⊢ ∀l1 l2 f.
      LIST_REL f l1 l2 ⇔
      (LENGTH l1 = LENGTH l2) ∧ EVERY (UNCURRY f) (ZIP (l1,l2))
</pre>

<DT><span class="strong">EVERY2_cong</span>
<DD>
<pre>
⊢ ∀l1 l1' l2 l2' P P'.
      (l1 = l1') ∧ (l2 = l2') ∧
      (∀x y. MEM x l1' ∧ MEM y l2' ⇒ (P x y ⇔ P' x y)) ⇒
      (LIST_REL P l1 l2 ⇔ LIST_REL P' l1' l2')
</pre>

<DT><span class="strong">EQ_LIST</span>
<DD>
<pre>
⊢ ∀h1 h2. (h1 = h2) ⇒ ∀l1 l2. (l1 = l2) ⇒ (h1::l1 = h2::l2)
</pre>

<DT><span class="strong">EL_ZIP</span>
<DD>
<pre>
⊢ ∀l1 l2 n.
      (LENGTH l1 = LENGTH l2) ∧ n < LENGTH l1 ⇒
      (EL n (ZIP (l1,l2)) = (EL n l1,EL n l2))
</pre>

<DT><span class="strong">EL_TAKE</span>
<DD>
<pre>
⊢ ∀n x l. x < n ⇒ (EL x (TAKE n l) = EL x l)
</pre>

<DT><span class="strong">EL_SNOC</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ ∀x. EL n (SNOC x l) = EL n l
</pre>

<DT><span class="strong">EL_simp_restricted</span>
<DD>
<pre>
⊢ (EL (NUMERAL (BIT1 n)) (l::ls) = EL (PRE (NUMERAL (BIT1 n))) ls) ∧
  (EL (NUMERAL (BIT2 n)) (l::ls) = EL (NUMERAL (BIT1 n)) ls)
</pre>

<DT><span class="strong">EL_simp</span>
<DD>
<pre>
⊢ (EL (NUMERAL (BIT1 n)) l = EL (PRE (NUMERAL (BIT1 n))) (TL l)) ∧
  (EL (NUMERAL (BIT2 n)) l = EL (NUMERAL (BIT1 n)) (TL l))
</pre>

<DT><span class="strong">EL_REVERSE</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ (EL n (REVERSE l) = EL (PRE (LENGTH l − n)) l)
</pre>

<DT><span class="strong">EL_restricted</span>
<DD>
<pre>
⊢ (EL 0 = HD) ∧ (EL (SUC n) (l::ls) = EL n ls)
</pre>

<DT><span class="strong">EL_MAP2</span>
<DD>
<pre>
⊢ ∀ts tt n.
      n < MIN (LENGTH ts) (LENGTH tt) ⇒
      (EL n (MAP2 f ts tt) = f (EL n ts) (EL n tt))
</pre>

<DT><span class="strong">EL_MAP</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ ∀f. EL n (MAP f l) = f (EL n l)
</pre>

<DT><span class="strong">EL_LUPDATE</span>
<DD>
<pre>
⊢ ∀ys x i k.
      EL i (LUPDATE x k ys) = if (i = k) ∧ k < LENGTH ys then x else EL i ys
</pre>

<DT><span class="strong">EL_LENGTH_SNOC</span>
<DD>
<pre>
⊢ ∀l x. EL (LENGTH l) (SNOC x l) = x
</pre>

<DT><span class="strong">EL_LENGTH_dropWhile_REVERSE</span>
<DD>
<pre>
⊢ ∀P ls k. LENGTH (dropWhile P (REVERSE ls)) ≤ k ∧ k < LENGTH ls ⇒ P (EL k ls)
</pre>

<DT><span class="strong">EL_GENLIST</span>
<DD>
<pre>
⊢ ∀f n x. x < n ⇒ (EL x (GENLIST f n) = f x)
</pre>

<DT><span class="strong">EL_DROP</span>
<DD>
<pre>
⊢ ∀m n l. m + n < LENGTH l ⇒ (EL m (DROP n l) = EL (m + n) l)
</pre>

<DT><span class="strong">EL_compute</span>
<DD>
<pre>
⊢ ∀n. EL n l = if n = 0 then HD l else EL (PRE n) (TL l)
</pre>

<DT><span class="strong">EL_APPEND_EQN</span>
<DD>
<pre>
⊢ ∀l1 l2 n.
      EL n (l1 ++ l2) =
      if n < LENGTH l1 then EL n l1 else EL (n − LENGTH l1) l2
</pre>

<DT><span class="strong">el_append3</span>
<DD>
<pre>
⊢ ∀l1 x l2. EL (LENGTH l1) (l1 ++ [x] ++ l2) = x
</pre>

<DT><span class="strong">EL_ALL_DISTINCT_EL_EQ</span>
<DD>
<pre>
⊢ ∀l.
      ALL_DISTINCT l ⇔
      ∀n1 n2.
          n1 < LENGTH l ∧ n2 < LENGTH l ⇒ ((EL n1 l = EL n2 l) ⇔ (n1 = n2))
</pre>

<DT><span class="strong">dropWhile_splitAtPki</span>
<DD>
<pre>
⊢ ∀P. dropWhile P = splitAtPki (combin$C (K ∘ $~ ∘ P)) (K I)
</pre>

<DT><span class="strong">dropWhile_eq_nil</span>
<DD>
<pre>
⊢ ∀P ls. (dropWhile P ls = []) ⇔ EVERY P ls
</pre>

<DT><span class="strong">dropWhile_APPEND_EXISTS</span>
<DD>
<pre>
⊢ ∀P l1 l2.
      EXISTS ($~ ∘ P) l1 ⇒ (dropWhile P (l1 ++ l2) = dropWhile P l1 ++ l2)
</pre>

<DT><span class="strong">dropWhile_APPEND_EVERY</span>
<DD>
<pre>
⊢ ∀P l1 l2. EVERY P l1 ⇒ (dropWhile P (l1 ++ l2) = dropWhile P l2)
</pre>

<DT><span class="strong">DROP_splitAtPki</span>
<DD>
<pre>
⊢ DROP n l = splitAtPki (K ∘ $= n) (K I) l
</pre>

<DT><span class="strong">DROP_nil</span>
<DD>
<pre>
⊢ ∀n. DROP n [] = []
</pre>

<DT><span class="strong">DROP_NIL</span>
<DD>
<pre>
⊢ ∀ls n. (DROP n ls = []) ⇔ n ≥ LENGTH ls
</pre>

<DT><span class="strong">DROP_LENGTH_TOO_LONG</span>
<DD>
<pre>
⊢ ∀l n. LENGTH l ≤ n ⇒ (DROP n l = [])
</pre>

<DT><span class="strong">DROP_GENLIST</span>
<DD>
<pre>
⊢ DROP n (GENLIST f m) = GENLIST (f ∘ $+ n) (m − n)
</pre>

<DT><span class="strong">DROP_cons</span>
<DD>
<pre>
⊢ 0 < n ⇒ (DROP n (x::xs) = DROP (n − 1) xs)
</pre>

<DT><span class="strong">DROP_compute</span>
<DD>
<pre>
⊢ (∀l. DROP 0 l = l) ∧ (∀n. DROP (NUMERAL (BIT1 n)) [] = []) ∧
  (∀n. DROP (NUMERAL (BIT2 n)) [] = []) ∧
  (∀n h t. DROP (NUMERAL (BIT1 n)) (h::t) = DROP (NUMERAL (BIT1 n) − 1) t) ∧
  ∀n h t. DROP (NUMERAL (BIT2 n)) (h::t) = DROP (NUMERAL (BIT1 n)) t
</pre>

<DT><span class="strong">DROP_0</span>
<DD>
<pre>
⊢ DROP 0 l = l
</pre>

<DT><span class="strong">DISJOINT_GENLIST_PLUS</span>
<DD>
<pre>
⊢ DISJOINT x (LIST_TO_SET (GENLIST ($+ n) (a + b))) ⇒
  DISJOINT x (LIST_TO_SET (GENLIST ($+ n) a)) ∧
  DISJOINT x (LIST_TO_SET (GENLIST ($+ (n + a)) b))
</pre>

<DT><span class="strong">datatype_list</span>
<DD>
<pre>
⊢ DATATYPE (list [] CONS)
</pre>

<DT><span class="strong">CONS_ACYCLIC</span>
<DD>
<pre>
⊢ ∀l x. l ≠ x::l ∧ x::l ≠ l
</pre>

<DT><span class="strong">CONS_11</span>
<DD>
<pre>
⊢ ∀a0 a1 a0' a1'. (a0::a1 = a0'::a1') ⇔ (a0 = a0') ∧ (a1 = a1')
</pre>

<DT><span class="strong">CONS</span>
<DD>
<pre>
⊢ ∀l. ¬NULL l ⇒ (HD l::TL l = l)
</pre>

<DT><span class="strong">CARD_LIST_TO_SET_ALL_DISTINCT</span>
<DD>
<pre>
⊢ ∀ls. (CARD (LIST_TO_SET ls) = LENGTH ls) ⇒ ALL_DISTINCT ls
</pre>

<DT><span class="strong">CARD_LIST_TO_SET</span>
<DD>
<pre>
⊢ CARD (LIST_TO_SET ls) ≤ LENGTH ls
</pre>

<DT><span class="strong">BIGUNION_IMAGE_set_SUBSET</span>
<DD>
<pre>
⊢ BIGUNION (IMAGE f (LIST_TO_SET ls)) ⊆ s ⇔ ∀x. MEM x ls ⇒ f x ⊆ s
</pre>

<DT><span class="strong">APPEND_SNOC</span>
<DD>
<pre>
⊢ ∀l1 x l2. l1 ++ SNOC x l2 = SNOC x (l1 ++ l2)
</pre>

<DT><span class="strong">APPEND_NIL</span>
<DD>
<pre>
⊢ ∀l. l ++ [] = l
</pre>

<DT><span class="strong">APPEND_LENGTH_EQ</span>
<DD>
<pre>
⊢ ∀l1 l1'.
      (LENGTH l1 = LENGTH l1') ⇒
      ∀l2 l2'.
          (LENGTH l2 = LENGTH l2') ⇒
          ((l1 ++ l2 = l1' ++ l2') ⇔ (l1 = l1') ∧ (l2 = l2'))
</pre>

<DT><span class="strong">APPEND_FRONT_LAST</span>
<DD>
<pre>
⊢ ∀l. l ≠ [] ⇒ (FRONT l ++ [LAST l] = l)
</pre>

<DT><span class="strong">APPEND_EQ_SING</span>
<DD>
<pre>
⊢ (l1 ++ l2 = [e]) ⇔ (l1 = [e]) ∧ (l2 = []) ∨ (l1 = []) ∧ (l2 = [e])
</pre>

<DT><span class="strong">APPEND_EQ_SELF</span>
<DD>
<pre>
⊢ (∀l1 l2. (l1 ++ l2 = l1) ⇔ (l2 = [])) ∧
  (∀l1 l2. (l1 ++ l2 = l2) ⇔ (l1 = [])) ∧
  (∀l1 l2. (l1 = l1 ++ l2) ⇔ (l2 = [])) ∧ ∀l1 l2. (l2 = l1 ++ l2) ⇔ (l1 = [])
</pre>

<DT><span class="strong">APPEND_eq_NIL</span>
<DD>
<pre>
⊢ (∀l1 l2. ([] = l1 ++ l2) ⇔ (l1 = []) ∧ (l2 = [])) ∧
  ∀l1 l2. (l1 ++ l2 = []) ⇔ (l1 = []) ∧ (l2 = [])
</pre>

<DT><span class="strong">APPEND_EQ_CONS</span>
<DD>
<pre>
⊢ (l1 ++ l2 = h::t) ⇔
  (l1 = []) ∧ (l2 = h::t) ∨ ∃lt. (l1 = h::lt) ∧ (t = lt ++ l2)
</pre>

<DT><span class="strong">APPEND_EQ_APPEND_MID</span>
<DD>
<pre>
⊢ (l1 ++ [e] ++ l2 = m1 ++ m2) ⇔
  (∃l. (m1 = l1 ++ [e] ++ l) ∧ (l2 = l ++ m2)) ∨
  ∃l. (l1 = m1 ++ l) ∧ (m2 = l ++ [e] ++ l2)
</pre>

<DT><span class="strong">APPEND_EQ_APPEND</span>
<DD>
<pre>
⊢ (l1 ++ l2 = m1 ++ m2) ⇔
  (∃l. (l1 = m1 ++ l) ∧ (m2 = l ++ l2)) ∨ ∃l. (m1 = l1 ++ l) ∧ (l2 = l ++ m2)
</pre>

<DT><span class="strong">APPEND_ASSOC</span>
<DD>
<pre>
⊢ ∀l1 l2 l3. l1 ++ (l2 ++ l3) = l1 ++ l2 ++ l3
</pre>

<DT><span class="strong">APPEND_11_LENGTH</span>
<DD>
<pre>
⊢ (∀l1 l2 l1' l2'.
       (LENGTH l1 = LENGTH l1') ⇒
       ((l1 ++ l2 = l1' ++ l2') ⇔ (l1 = l1') ∧ (l2 = l2'))) ∧
  ∀l1 l2 l1' l2'.
      (LENGTH l2 = LENGTH l2') ⇒
      ((l1 ++ l2 = l1' ++ l2') ⇔ (l1 = l1') ∧ (l2 = l2'))
</pre>

<DT><span class="strong">APPEND_11</span>
<DD>
<pre>
⊢ (∀l1 l2 l3. (l1 ++ l2 = l1 ++ l3) ⇔ (l2 = l3)) ∧
  ∀l1 l2 l3. (l2 ++ l1 = l3 ++ l1) ⇔ (l2 = l3)
</pre>

<DT><span class="strong">ALL_DISTINCT_ZIP_SWAP</span>
<DD>
<pre>
⊢ ∀l1 l2.
      ALL_DISTINCT (ZIP (l1,l2)) ∧ (LENGTH l1 = LENGTH l2) ⇒
      ALL_DISTINCT (ZIP (l2,l1))
</pre>

<DT><span class="strong">ALL_DISTINCT_ZIP</span>
<DD>
<pre>
⊢ ∀l1 l2.
      ALL_DISTINCT l1 ∧ (LENGTH l1 = LENGTH l2) ⇒ ALL_DISTINCT (ZIP (l1,l2))
</pre>

<DT><span class="strong">ALL_DISTINCT_SNOC</span>
<DD>
<pre>
⊢ ∀x l. ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l
</pre>

<DT><span class="strong">ALL_DISTINCT_SING</span>
<DD>
<pre>
⊢ ∀x. ALL_DISTINCT [x]
</pre>

<DT><span class="strong">ALL_DISTINCT_SET_TO_LIST</span>
<DD>
<pre>
⊢ ∀s. FINITE s ⇒ ALL_DISTINCT (SET_TO_LIST s)
</pre>

<DT><span class="strong">ALL_DISTINCT_REVERSE</span>
<DD>
<pre>
⊢ ∀l. ALL_DISTINCT (REVERSE l) ⇔ ALL_DISTINCT l
</pre>

<DT><span class="strong">all_distinct_nub</span>
<DD>
<pre>
⊢ ∀l. ALL_DISTINCT (nub l)
</pre>

<DT><span class="strong">ALL_DISTINCT_MAP_INJ</span>
<DD>
<pre>
⊢ ∀ls f.
      (∀x y. MEM x ls ∧ MEM y ls ∧ (f x = f y) ⇒ (x = y)) ∧ ALL_DISTINCT ls ⇒
      ALL_DISTINCT (MAP f ls)
</pre>

<DT><span class="strong">ALL_DISTINCT_MAP</span>
<DD>
<pre>
⊢ ∀f ls. ALL_DISTINCT (MAP f ls) ⇒ ALL_DISTINCT ls
</pre>

<DT><span class="strong">ALL_DISTINCT_GENLIST</span>
<DD>
<pre>
⊢ ALL_DISTINCT (GENLIST f n) ⇔
  ∀m1 m2. m1 < n ∧ m2 < n ∧ (f m1 = f m2) ⇒ (m1 = m2)
</pre>

<DT><span class="strong">ALL_DISTINCT_FLAT_REVERSE</span>
<DD>
<pre>
⊢ ∀xs. ALL_DISTINCT (FLAT (REVERSE xs)) ⇔ ALL_DISTINCT (FLAT xs)
</pre>

<DT><span class="strong">ALL_DISTINCT_FILTER_EL_IMP</span>
<DD>
<pre>
⊢ ∀P l n1 n2.
      ALL_DISTINCT (FILTER P l) ∧ n1 < LENGTH l ∧ n2 < LENGTH l ∧
      P (EL n1 l) ∧ (EL n1 l = EL n2 l) ⇒
      (n1 = n2)
</pre>

<DT><span class="strong">ALL_DISTINCT_FILTER</span>
<DD>
<pre>
⊢ ∀l. ALL_DISTINCT l ⇔ ∀x. MEM x l ⇒ (FILTER ($= x) l = [x])
</pre>

<DT><span class="strong">ALL_DISTINCT_EL_IMP</span>
<DD>
<pre>
⊢ ∀l n1 n2.
      ALL_DISTINCT l ∧ n1 < LENGTH l ∧ n2 < LENGTH l ⇒
      ((EL n1 l = EL n2 l) ⇔ (n1 = n2))
</pre>

<DT><span class="strong">ALL_DISTINCT_DROP</span>
<DD>
<pre>
⊢ ∀ls n. ALL_DISTINCT ls ⇒ ALL_DISTINCT (DROP n ls)
</pre>

<DT><span class="strong">ALL_DISTINCT_CARD_LIST_TO_SET</span>
<DD>
<pre>
⊢ ∀ls. ALL_DISTINCT ls ⇒ (CARD (LIST_TO_SET ls) = LENGTH ls)
</pre>

<DT><span class="strong">ALL_DISTINCT_APPEND</span>
<DD>
<pre>
⊢ ∀l1 l2.
      ALL_DISTINCT (l1 ++ l2) ⇔
      ALL_DISTINCT l1 ∧ ALL_DISTINCT l2 ∧ ∀e. MEM e l1 ⇒ ¬MEM e l2
</pre>

</DL>



<hr>
</body>
</html>
