<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure netsTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure netsTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/real/.hol/objs/netsScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature netsTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#at_def-val">at_def</a> : thm
<a name="line7"></a>    val <a href="#at_infinity-val">at_infinity</a> : thm
<a name="line8"></a>    val <a href="#at_neginfinity-val">at_neginfinity</a> : thm
<a name="line9"></a>    val <a href="#at_posinfinity-val">at_posinfinity</a> : thm
<a name="line10"></a>    val <a href="#bounded-val">bounded</a> : thm
<a name="line11"></a>    val <a href="#dorder-val">dorder</a> : thm
<a name="line12"></a>    val <a href="#eventually-val">eventually</a> : thm
<a name="line13"></a>    val <a href="#in_direction-val">in_direction</a> : thm
<a name="line14"></a>    val <a href="#isnet-val">isnet</a> : thm
<a name="line15"></a>    val <a href="#limit-val">limit</a> : thm
<a name="line16"></a>    val <a href="#net_TY_DEF-val">net_TY_DEF</a> : thm
<a name="line17"></a>    val <a href="#netlimit-val">netlimit</a> : thm
<a name="line18"></a>    val <a href="#sequentially-val">sequentially</a> : thm
<a name="line19"></a>    val <a href="#tends-val">tends</a> : thm
<a name="line20"></a>    val <a href="#tendsto-val">tendsto</a> : thm
<a name="line21"></a>    val <a href="#trivial_limit-val">trivial_limit</a> : thm
<a name="line22"></a>    val <a href="#within-val">within</a> : thm
<a name="line23"></a>  
<a name="line24"></a>  (*  Theorems  *)
<a name="line25"></a>    val <a href="#ALWAYS_EVENTUALLY-val">ALWAYS_EVENTUALLY</a> : thm
<a name="line26"></a>    val <a href="#AT-val">AT</a> : thm
<a name="line27"></a>    val <a href="#AT_INFINITY-val">AT_INFINITY</a> : thm
<a name="line28"></a>    val <a href="#AT_NEGINFINITY-val">AT_NEGINFINITY</a> : thm
<a name="line29"></a>    val <a href="#AT_POSINFINITY-val">AT_POSINFINITY</a> : thm
<a name="line30"></a>    val <a href="#DORDER_LEMMA-val">DORDER_LEMMA</a> : thm
<a name="line31"></a>    val <a href="#DORDER_NET-val">DORDER_NET</a> : thm
<a name="line32"></a>    val <a href="#DORDER_NGE-val">DORDER_NGE</a> : thm
<a name="line33"></a>    val <a href="#DORDER_TENDSTO-val">DORDER_TENDSTO</a> : thm
<a name="line34"></a>    val <a href="#EVENTUALLY_AND-val">EVENTUALLY_AND</a> : thm
<a name="line35"></a>    val <a href="#EVENTUALLY_AT_INFINITY-val">EVENTUALLY_AT_INFINITY</a> : thm
<a name="line36"></a>    val <a href="#EVENTUALLY_AT_INFINITY_POS-val">EVENTUALLY_AT_INFINITY_POS</a> : thm
<a name="line37"></a>    val <a href="#EVENTUALLY_AT_NEGINFINITY-val">EVENTUALLY_AT_NEGINFINITY</a> : thm
<a name="line38"></a>    val <a href="#EVENTUALLY_AT_POSINFINITY-val">EVENTUALLY_AT_POSINFINITY</a> : thm
<a name="line39"></a>    val <a href="#EVENTUALLY_FALSE-val">EVENTUALLY_FALSE</a> : thm
<a name="line40"></a>    val <a href="#EVENTUALLY_FORALL-val">EVENTUALLY_FORALL</a> : thm
<a name="line41"></a>    val <a href="#EVENTUALLY_HAPPENS-val">EVENTUALLY_HAPPENS</a> : thm
<a name="line42"></a>    val <a href="#EVENTUALLY_MONO-val">EVENTUALLY_MONO</a> : thm
<a name="line43"></a>    val <a href="#EVENTUALLY_MP-val">EVENTUALLY_MP</a> : thm
<a name="line44"></a>    val <a href="#EVENTUALLY_SEQUENTIALLY-val">EVENTUALLY_SEQUENTIALLY</a> : thm
<a name="line45"></a>    val <a href="#EVENTUALLY_TRUE-val">EVENTUALLY_TRUE</a> : thm
<a name="line46"></a>    val <a href="#FORALL_EVENTUALLY-val">FORALL_EVENTUALLY</a> : thm
<a name="line47"></a>    val <a href="#IN_DIRECTION-val">IN_DIRECTION</a> : thm
<a name="line48"></a>    val <a href="#LIM_TENDS-val">LIM_TENDS</a> : thm
<a name="line49"></a>    val <a href="#LIM_TENDS2-val">LIM_TENDS2</a> : thm
<a name="line50"></a>    val <a href="#MR1_BOUNDED-val">MR1_BOUNDED</a> : thm
<a name="line51"></a>    val <a href="#MTOP_TENDS-val">MTOP_TENDS</a> : thm
<a name="line52"></a>    val <a href="#MTOP_TENDS_UNIQ-val">MTOP_TENDS_UNIQ</a> : thm
<a name="line53"></a>    val <a href="#NET-val">NET</a> : thm
<a name="line54"></a>    val <a href="#NETLIMIT_WITHIN-val">NETLIMIT_WITHIN</a> : thm
<a name="line55"></a>    val <a href="#NET_ABS-val">NET_ABS</a> : thm
<a name="line56"></a>    val <a href="#NET_ADD-val">NET_ADD</a> : thm
<a name="line57"></a>    val <a href="#NET_CONV_BOUNDED-val">NET_CONV_BOUNDED</a> : thm
<a name="line58"></a>    val <a href="#NET_CONV_IBOUNDED-val">NET_CONV_IBOUNDED</a> : thm
<a name="line59"></a>    val <a href="#NET_CONV_NZ-val">NET_CONV_NZ</a> : thm
<a name="line60"></a>    val <a href="#NET_DILEMMA-val">NET_DILEMMA</a> : thm
<a name="line61"></a>    val <a href="#NET_DIV-val">NET_DIV</a> : thm
<a name="line62"></a>    val <a href="#NET_INV-val">NET_INV</a> : thm
<a name="line63"></a>    val <a href="#NET_LE-val">NET_LE</a> : thm
<a name="line64"></a>    val <a href="#NET_MUL-val">NET_MUL</a> : thm
<a name="line65"></a>    val <a href="#NET_NEG-val">NET_NEG</a> : thm
<a name="line66"></a>    val <a href="#NET_NULL-val">NET_NULL</a> : thm
<a name="line67"></a>    val <a href="#NET_NULL_ADD-val">NET_NULL_ADD</a> : thm
<a name="line68"></a>    val <a href="#NET_NULL_CMUL-val">NET_NULL_CMUL</a> : thm
<a name="line69"></a>    val <a href="#NET_NULL_MUL-val">NET_NULL_MUL</a> : thm
<a name="line70"></a>    val <a href="#NET_SUB-val">NET_SUB</a> : thm
<a name="line71"></a>    val <a href="#NONTRIVIAL_LIMIT_WITHIN-val">NONTRIVIAL_LIMIT_WITHIN</a> : thm
<a name="line72"></a>    val <a href="#NOT_EVENTUALLY-val">NOT_EVENTUALLY</a> : thm
<a name="line73"></a>    val <a href="#OLDNET-val">OLDNET</a> : thm
<a name="line74"></a>    val <a href="#REAL_CHOOSE_SIZE-val">REAL_CHOOSE_SIZE</a> : thm
<a name="line75"></a>    val <a href="#SEQUENTIALLY-val">SEQUENTIALLY</a> : thm
<a name="line76"></a>    val <a href="#SEQ_TENDS-val">SEQ_TENDS</a> : thm
<a name="line77"></a>    val <a href="#TRIVIAL_LIMIT_AT_INFINITY-val">TRIVIAL_LIMIT_AT_INFINITY</a> : thm
<a name="line78"></a>    val <a href="#TRIVIAL_LIMIT_AT_NEGINFINITY-val">TRIVIAL_LIMIT_AT_NEGINFINITY</a> : thm
<a name="line79"></a>    val <a href="#TRIVIAL_LIMIT_AT_POSINFINITY-val">TRIVIAL_LIMIT_AT_POSINFINITY</a> : thm
<a name="line80"></a>    val <a href="#TRIVIAL_LIMIT_SEQUENTIALLY-val">TRIVIAL_LIMIT_SEQUENTIALLY</a> : thm
<a name="line81"></a>    val <a href="#WITHIN-val">WITHIN</a> : thm
<a name="line82"></a>    val <a href="#WITHIN_UNIV-val">WITHIN_UNIV</a> : thm
<a name="line83"></a>    val <a href="#WITHIN_WITHIN-val">WITHIN_WITHIN</a> : thm
<a name="line84"></a>    val <a href="#at-val">at</a> : thm
<a name="line85"></a>    val <a href="#limit_alt_tends-val">limit_alt_tends</a> : thm
<a name="line86"></a>    val <a href="#net_tybij-val">net_tybij</a> : thm
<a name="line87"></a>    val <a href="#tends_imp_limit-val">tends_imp_limit</a> : thm
<a name="line88"></a>    val <a href="#tendsto_mr1-val">tendsto_mr1</a> : thm
<a name="line89"></a>    val <a href="#trivial_limit_def-val">trivial_limit_def</a> : thm
<a name="line90"></a>(*
   [metric] Parent theory of "nets"
   
   [<a name="at_def-val"><b>at_def</b></a>]  Definition
      
      ⊢ ∀z. at z = mk_net (tendsto (mr1,z))
   
   [<a name="at_infinity-val"><b>at_infinity</b></a>]  Definition
      
      ⊢ at_infinity = mk_net (λx y. abs x ≥ abs y)
   
   [<a name="at_neginfinity-val"><b>at_neginfinity</b></a>]  Definition
      
      ⊢ at_neginfinity = mk_net (λx y. x ≤ y)
   
   [<a name="at_posinfinity-val"><b>at_posinfinity</b></a>]  Definition
      
      ⊢ at_posinfinity = mk_net (λx y. x ≥ y)
   
   [<a name="bounded-val"><b>bounded</b></a>]  Definition
      
      ⊢ ∀m g f.
          bounded (m,g) f ⇔ ∃k x N. g N N ∧ ∀n. g n N ⇒ dist m (f n,x) &lt; k
   
   [<a name="dorder-val"><b>dorder</b></a>]  Definition
      
      ⊢ ∀g. dorder g ⇔
            ∀x y. g x x ∧ g y y ⇒ ∃z. g z z ∧ ∀w. g w z ⇒ g w x ∧ g w y
   
   [<a name="eventually-val"><b>eventually</b></a>]  Definition
      
      ⊢ ∀p net.
          eventually p net ⇔
          trivial_limit net ∨
          ∃y. (∃x. netord net x y) ∧ ∀x. netord net x y ⇒ p x
   
   [<a name="in_direction-val"><b>in_direction</b></a>]  Definition
      
      ⊢ ∀a v.
          (a in_direction v) =
          (at a within {b | ∃c. 0 ≤ c ∧ b − a = c * v})
   
   [<a name="isnet-val"><b>isnet</b></a>]  Definition
      
      ⊢ ∀g. isnet g ⇔ ∀x y. (∀z. g z x ⇒ g z y) ∨ ∀z. g z y ⇒ g z x
   
   [<a name="limit-val"><b>limit</b></a>]  Definition
      
      ⊢ ∀top f l net.
          limit top f l net ⇔
          l ∈ topspace top ∧
          ∀u. open_in top u ∧ l ∈ u ⇒ eventually (λx. f x ∈ u) net
   
   [<a name="net_TY_DEF-val"><b>net_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep. TYPE_DEFINITION isnet rep
   
   [<a name="netlimit-val"><b>netlimit</b></a>]  Definition
      
      ⊢ ∀net. netlimit net = @a. ∀x. ¬netord net x a
   
   [<a name="sequentially-val"><b>sequentially</b></a>]  Definition
      
      ⊢ sequentially = mk_net (λm n. m ≥ n)
   
   [<a name="tends-val"><b>tends</b></a>]  Definition
      
      ⊢ ∀s l top g.
          (s tends l) (top,g) ⇔
          ∀N. neigh top (N,l) ⇒ ∃n. g n n ∧ ∀m. g m n ⇒ N (s m)
   
   [<a name="tendsto-val"><b>tendsto</b></a>]  Definition
      
      ⊢ ∀m x y z.
          tendsto (m,x) y z ⇔
          0 &lt; dist m (x,y) ∧ dist m (x,y) ≤ dist m (x,z)
   
   [<a name="trivial_limit-val"><b>trivial_limit</b></a>]  Definition
      
      ⊢ ∀net.
          trivial_limit net ⇔
          (∀a b. a = b) ∨
          ∃a b. a ≠ b ∧ ∀x. ¬netord net x a ∧ ¬netord net x b
   
   [<a name="within-val"><b>within</b></a>]  Definition
      
      ⊢ ∀net s. (net within s) = mk_net (λx y. netord net x y ∧ x ∈ s)
   
   [<a name="ALWAYS_EVENTUALLY-val"><b>ALWAYS_EVENTUALLY</b></a>]  Theorem
      
      ⊢ ∀net p. (∀x. p x) ⇒ eventually p net
   
   [<a name="AT-val"><b>AT</b></a>]  Theorem
      
      ⊢ ∀a x y.
          netord (at a) x y ⇔ 0 &lt; dist (x,a) ∧ dist (x,a) ≤ dist (y,a)
   
   [<a name="AT_INFINITY-val"><b>AT_INFINITY</b></a>]  Theorem
      
      ⊢ ∀x y. netord at_infinity x y ⇔ abs x ≥ abs y
   
   [<a name="AT_NEGINFINITY-val"><b>AT_NEGINFINITY</b></a>]  Theorem
      
      ⊢ ∀x y. netord at_neginfinity x y ⇔ x ≤ y
   
   [<a name="AT_POSINFINITY-val"><b>AT_POSINFINITY</b></a>]  Theorem
      
      ⊢ ∀x y. netord at_posinfinity x y ⇔ x ≥ y
   
   [<a name="DORDER_LEMMA-val"><b>DORDER_LEMMA</b></a>]  Theorem
      
      ⊢ ∀g. dorder g ⇒
            ∀P Q.
              (∃n. g n n ∧ ∀m. g m n ⇒ P m) ∧ (∃n. g n n ∧ ∀m. g m n ⇒ Q m) ⇒
              ∃n. g n n ∧ ∀m. g m n ⇒ P m ∧ Q m
   
   [<a name="DORDER_NET-val"><b>DORDER_NET</b></a>]  Theorem
      
      ⊢ ∀n. dorder (netord n)
   
   [<a name="DORDER_NGE-val"><b>DORDER_NGE</b></a>]  Theorem
      
      ⊢ dorder $&gt;=
   
   [<a name="DORDER_TENDSTO-val"><b>DORDER_TENDSTO</b></a>]  Theorem
      
      ⊢ ∀m x. dorder (tendsto (m,x))
   
   [<a name="EVENTUALLY_AND-val"><b>EVENTUALLY_AND</b></a>]  Theorem
      
      ⊢ ∀net p q.
          eventually (λx. p x ∧ q x) net ⇔
          eventually p net ∧ eventually q net
   
   [<a name="EVENTUALLY_AT_INFINITY-val"><b>EVENTUALLY_AT_INFINITY</b></a>]  Theorem
      
      ⊢ ∀p. eventually p at_infinity ⇔ ∃b. ∀x. abs x ≥ b ⇒ p x
   
   [<a name="EVENTUALLY_AT_INFINITY_POS-val"><b>EVENTUALLY_AT_INFINITY_POS</b></a>]  Theorem
      
      ⊢ ∀p. eventually p at_infinity ⇔ ∃b. 0 &lt; b ∧ ∀x. abs x ≥ b ⇒ p x
   
   [<a name="EVENTUALLY_AT_NEGINFINITY-val"><b>EVENTUALLY_AT_NEGINFINITY</b></a>]  Theorem
      
      ⊢ ∀p. eventually p at_neginfinity ⇔ ∃b. ∀x. x ≤ b ⇒ p x
   
   [<a name="EVENTUALLY_AT_POSINFINITY-val"><b>EVENTUALLY_AT_POSINFINITY</b></a>]  Theorem
      
      ⊢ ∀p. eventually p at_posinfinity ⇔ ∃b. ∀x. x ≥ b ⇒ p x
   
   [<a name="EVENTUALLY_FALSE-val"><b>EVENTUALLY_FALSE</b></a>]  Theorem
      
      ⊢ ∀net. eventually (λx. F) net ⇔ trivial_limit net
   
   [<a name="EVENTUALLY_FORALL-val"><b>EVENTUALLY_FORALL</b></a>]  Theorem
      
      ⊢ ∀net p s.
          FINITE s ∧ s ≠ ∅ ⇒
          (eventually (λx. ∀a. a ∈ s ⇒ p a x) net ⇔
           ∀a. a ∈ s ⇒ eventually (p a) net)
   
   [<a name="EVENTUALLY_HAPPENS-val"><b>EVENTUALLY_HAPPENS</b></a>]  Theorem
      
      ⊢ ∀net p. eventually p net ⇒ trivial_limit net ∨ ∃x. p x
   
   [<a name="EVENTUALLY_MONO-val"><b>EVENTUALLY_MONO</b></a>]  Theorem
      
      ⊢ ∀net p q. (∀x. p x ⇒ q x) ∧ eventually p net ⇒ eventually q net
   
   [<a name="EVENTUALLY_MP-val"><b>EVENTUALLY_MP</b></a>]  Theorem
      
      ⊢ ∀net p q.
          eventually (λx. p x ⇒ q x) net ∧ eventually p net ⇒
          eventually q net
   
   [<a name="EVENTUALLY_SEQUENTIALLY-val"><b>EVENTUALLY_SEQUENTIALLY</b></a>]  Theorem
      
      ⊢ ∀p. eventually p sequentially ⇔ ∃N. ∀n. N ≤ n ⇒ p n
   
   [<a name="EVENTUALLY_TRUE-val"><b>EVENTUALLY_TRUE</b></a>]  Theorem
      
      ⊢ ∀net. eventually (λx. T) net ⇔ T
   
   [<a name="FORALL_EVENTUALLY-val"><b>FORALL_EVENTUALLY</b></a>]  Theorem
      
      ⊢ ∀net p s.
          FINITE s ∧ s ≠ ∅ ⇒
          ((∀a. a ∈ s ⇒ eventually (p a) net) ⇔
           eventually (λx. ∀a. a ∈ s ⇒ p a x) net)
   
   [<a name="IN_DIRECTION-val"><b>IN_DIRECTION</b></a>]  Theorem
      
      ⊢ ∀a v x y.
          netord (a in_direction v) x y ⇔
          0 &lt; dist (x,a) ∧ dist (x,a) ≤ dist (y,a) ∧
          ∃c. 0 ≤ c ∧ x − a = c * v
   
   [<a name="LIM_TENDS-val"><b>LIM_TENDS</b></a>]  Theorem
      
      ⊢ ∀m1 m2 f x0 y0.
          limpt (mtop m1) x0 𝕌(:α) ⇒
          ((f tends y0) (mtop m2,tendsto (m1,x0)) ⇔
           ∀e. 0 &lt; e ⇒
               ∃d. 0 &lt; d ∧
                   ∀x. 0 &lt; dist m1 (x,x0) ∧ dist m1 (x,x0) ≤ d ⇒
                       dist m2 (f x,y0) &lt; e)
   
   [<a name="LIM_TENDS2-val"><b>LIM_TENDS2</b></a>]  Theorem
      
      ⊢ ∀m1 m2 f x0 y0.
          limpt (mtop m1) x0 𝕌(:α) ⇒
          ((f tends y0) (mtop m2,tendsto (m1,x0)) ⇔
           ∀e. 0 &lt; e ⇒
               ∃d. 0 &lt; d ∧
                   ∀x. 0 &lt; dist m1 (x,x0) ∧ dist m1 (x,x0) &lt; d ⇒
                       dist m2 (f x,y0) &lt; e)
   
   [<a name="MR1_BOUNDED-val"><b>MR1_BOUNDED</b></a>]  Theorem
      
      ⊢ ∀g f. bounded (mr1,g) f ⇔ ∃k N. g N N ∧ ∀n. g n N ⇒ abs (f n) &lt; k
   
   [<a name="MTOP_TENDS-val"><b>MTOP_TENDS</b></a>]  Theorem
      
      ⊢ ∀d g x x0.
          (x tends x0) (mtop d,g) ⇔
          ∀e. 0 &lt; e ⇒ ∃n. g n n ∧ ∀m. g m n ⇒ dist d (x m,x0) &lt; e
   
   [<a name="MTOP_TENDS_UNIQ-val"><b>MTOP_TENDS_UNIQ</b></a>]  Theorem
      
      ⊢ ∀g d.
          dorder g ⇒
          (x tends x0) (mtop d,g) ∧ (x tends x1) (mtop d,g) ⇒
          x0 = x1
   
   [<a name="NET-val"><b>NET</b></a>]  Theorem
      
      ⊢ ∀n x y.
          (∀z. netord n z x ⇒ netord n z y) ∨
          ∀z. netord n z y ⇒ netord n z x
   
   [<a name="NETLIMIT_WITHIN-val"><b>NETLIMIT_WITHIN</b></a>]  Theorem
      
      ⊢ ∀a s. ¬trivial_limit (at a within s) ⇒ netlimit (at a within s) = a
   
   [<a name="NET_ABS-val"><b>NET_ABS</b></a>]  Theorem
      
      ⊢ ∀g x x0.
          (x tends x0) (mtop mr1,g) ⇒
          ((λn. abs (x n)) tends abs x0) (mtop mr1,g)
   
   [<a name="NET_ADD-val"><b>NET_ADD</b></a>]  Theorem
      
      ⊢ ∀g. dorder g ⇒
            ∀x x0 y y0.
              (x tends x0) (mtop mr1,g) ∧ (y tends y0) (mtop mr1,g) ⇒
              ((λn. x n + y n) tends (x0 + y0)) (mtop mr1,g)
   
   [<a name="NET_CONV_BOUNDED-val"><b>NET_CONV_BOUNDED</b></a>]  Theorem
      
      ⊢ ∀g x x0. (x tends x0) (mtop mr1,g) ⇒ bounded (mr1,g) x
   
   [<a name="NET_CONV_IBOUNDED-val"><b>NET_CONV_IBOUNDED</b></a>]  Theorem
      
      ⊢ ∀g x x0.
          (x tends x0) (mtop mr1,g) ∧ x0 ≠ 0 ⇒
          bounded (mr1,g) (λn. (x n)⁻¹)
   
   [<a name="NET_CONV_NZ-val"><b>NET_CONV_NZ</b></a>]  Theorem
      
      ⊢ ∀g x x0.
          (x tends x0) (mtop mr1,g) ∧ x0 ≠ 0 ⇒
          ∃N. g N N ∧ ∀n. g n N ⇒ x n ≠ 0
   
   [<a name="NET_DILEMMA-val"><b>NET_DILEMMA</b></a>]  Theorem
      
      ⊢ ∀net.
          (∃a. (∃x. netord net x a) ∧ ∀x. netord net x a ⇒ P x) ∧
          (∃b. (∃x. netord net x b) ∧ ∀x. netord net x b ⇒ Q x) ⇒
          ∃c. (∃x. netord net x c) ∧ ∀x. netord net x c ⇒ P x ∧ Q x
   
   [<a name="NET_DIV-val"><b>NET_DIV</b></a>]  Theorem
      
      ⊢ ∀g. dorder g ⇒
            ∀x x0 y y0.
              (x tends x0) (mtop mr1,g) ∧ (y tends y0) (mtop mr1,g) ∧
              y0 ≠ 0 ⇒
              ((λn. x n / y n) tends (x0 / y0)) (mtop mr1,g)
   
   [<a name="NET_INV-val"><b>NET_INV</b></a>]  Theorem
      
      ⊢ ∀g. dorder g ⇒
            ∀x x0.
              (x tends x0) (mtop mr1,g) ∧ x0 ≠ 0 ⇒
              ((λn. (x n)⁻¹) tends x0⁻¹) (mtop mr1,g)
   
   [<a name="NET_LE-val"><b>NET_LE</b></a>]  Theorem
      
      ⊢ ∀g. dorder g ⇒
            ∀x x0 y y0.
              (x tends x0) (mtop mr1,g) ∧ (y tends y0) (mtop mr1,g) ∧
              (∃N. g N N ∧ ∀n. g n N ⇒ x n ≤ y n) ⇒
              x0 ≤ y0
   
   [<a name="NET_MUL-val"><b>NET_MUL</b></a>]  Theorem
      
      ⊢ ∀g. dorder g ⇒
            ∀x y x0 y0.
              (x tends x0) (mtop mr1,g) ∧ (y tends y0) (mtop mr1,g) ⇒
              ((λn. x n * y n) tends (x0 * y0)) (mtop mr1,g)
   
   [<a name="NET_NEG-val"><b>NET_NEG</b></a>]  Theorem
      
      ⊢ ∀g. dorder g ⇒
            ∀x x0.
              (x tends x0) (mtop mr1,g) ⇔
              ((λn. -x n) tends -x0) (mtop mr1,g)
   
   [<a name="NET_NULL-val"><b>NET_NULL</b></a>]  Theorem
      
      ⊢ ∀g x x0.
          (x tends x0) (mtop mr1,g) ⇔ ((λn. x n − x0) tends 0) (mtop mr1,g)
   
   [<a name="NET_NULL_ADD-val"><b>NET_NULL_ADD</b></a>]  Theorem
      
      ⊢ ∀g. dorder g ⇒
            ∀x y.
              (x tends 0) (mtop mr1,g) ∧ (y tends 0) (mtop mr1,g) ⇒
              ((λn. x n + y n) tends 0) (mtop mr1,g)
   
   [<a name="NET_NULL_CMUL-val"><b>NET_NULL_CMUL</b></a>]  Theorem
      
      ⊢ ∀g k x.
          (x tends 0) (mtop mr1,g) ⇒ ((λn. k * x n) tends 0) (mtop mr1,g)
   
   [<a name="NET_NULL_MUL-val"><b>NET_NULL_MUL</b></a>]  Theorem
      
      ⊢ ∀g. dorder g ⇒
            ∀x y.
              bounded (mr1,g) x ∧ (y tends 0) (mtop mr1,g) ⇒
              ((λn. x n * y n) tends 0) (mtop mr1,g)
   
   [<a name="NET_SUB-val"><b>NET_SUB</b></a>]  Theorem
      
      ⊢ ∀g. dorder g ⇒
            ∀x x0 y y0.
              (x tends x0) (mtop mr1,g) ∧ (y tends y0) (mtop mr1,g) ⇒
              ((λn. x n − y n) tends (x0 − y0)) (mtop mr1,g)
   
   [<a name="NONTRIVIAL_LIMIT_WITHIN-val"><b>NONTRIVIAL_LIMIT_WITHIN</b></a>]  Theorem
      
      ⊢ ∀net s. trivial_limit net ⇒ trivial_limit (net within s)
   
   [<a name="NOT_EVENTUALLY-val"><b>NOT_EVENTUALLY</b></a>]  Theorem
      
      ⊢ ∀net p. (∀x. ¬p x) ∧ ¬trivial_limit net ⇒ ¬eventually p net
   
   [<a name="OLDNET-val"><b>OLDNET</b></a>]  Theorem
      
      ⊢ ∀n x y.
          netord n x x ∧ netord n y y ⇒
          ∃z. netord n z z ∧ ∀w. netord n w z ⇒ netord n w x ∧ netord n w y
   
   [<a name="REAL_CHOOSE_SIZE-val"><b>REAL_CHOOSE_SIZE</b></a>]  Theorem
      
      ⊢ ∀c. 0 ≤ c ⇒ ∃x. abs x = c
   
   [<a name="SEQUENTIALLY-val"><b>SEQUENTIALLY</b></a>]  Theorem
      
      ⊢ ∀m n. netord sequentially m n ⇔ m ≥ n
   
   [<a name="SEQ_TENDS-val"><b>SEQ_TENDS</b></a>]  Theorem
      
      ⊢ ∀d x x0.
          (x tends x0) (mtop d,$&gt;=) ⇔
          ∀e. 0 &lt; e ⇒ ∃N. ∀n. n ≥ N ⇒ dist d (x n,x0) &lt; e
   
   [<a name="TRIVIAL_LIMIT_AT_INFINITY-val"><b>TRIVIAL_LIMIT_AT_INFINITY</b></a>]  Theorem
      
      ⊢ ¬trivial_limit at_infinity
   
   [<a name="TRIVIAL_LIMIT_AT_NEGINFINITY-val"><b>TRIVIAL_LIMIT_AT_NEGINFINITY</b></a>]  Theorem
      
      ⊢ ¬trivial_limit at_neginfinity
   
   [<a name="TRIVIAL_LIMIT_AT_POSINFINITY-val"><b>TRIVIAL_LIMIT_AT_POSINFINITY</b></a>]  Theorem
      
      ⊢ ¬trivial_limit at_posinfinity
   
   [<a name="TRIVIAL_LIMIT_SEQUENTIALLY-val"><b>TRIVIAL_LIMIT_SEQUENTIALLY</b></a>]  Theorem
      
      ⊢ ¬trivial_limit sequentially
   
   [<a name="WITHIN-val"><b>WITHIN</b></a>]  Theorem
      
      ⊢ ∀n s x y. netord (n within s) x y ⇔ netord n x y ∧ x ∈ s
   
   [<a name="WITHIN_UNIV-val"><b>WITHIN_UNIV</b></a>]  Theorem
      
      ⊢ ∀x. (at x within 𝕌(:real)) = at x
   
   [<a name="WITHIN_WITHIN-val"><b>WITHIN_WITHIN</b></a>]  Theorem
      
      ⊢ ∀net s t. ((net within s) within t) = (net within s ∩ t)
   
   [<a name="at-val"><b>at</b></a>]  Theorem
      
      ⊢ ∀a. at a = mk_net (λx y. 0 &lt; dist (x,a) ∧ dist (x,a) ≤ dist (y,a))
   
   [<a name="limit_alt_tends-val"><b>limit_alt_tends</b></a>]  Theorem
      
      ⊢ ∀top f l net.
          ¬trivial_limit net ∧ l ∈ topspace top ∧
          (∀x y. netord net x y ⇒ netord net y y) ⇒
          (limit top f l net ⇔ (f tends l) (top,netord net))
   
   [<a name="net_tybij-val"><b>net_tybij</b></a>]  Theorem
      
      ⊢ (∀a. mk_net (netord a) = a) ∧
        ∀r. (∀x y. (∀z. r z x ⇒ r z y) ∨ ∀z. r z y ⇒ r z x) ⇔
            netord (mk_net r) = r
   
   [<a name="tends_imp_limit-val"><b>tends_imp_limit</b></a>]  Theorem
      
      ⊢ ∀top f l net.
          ¬trivial_limit net ∧ l ∈ topspace top ⇒
          (f tends l) (top,netord net) ⇒
          limit top f l net
   
   [<a name="tendsto_mr1-val"><b>tendsto_mr1</b></a>]  Theorem
      
      ⊢ ∀m a. tendsto (mr1,a) = netord (at a)
   
   [<a name="trivial_limit_def-val"><b>trivial_limit_def</b></a>]  Theorem
      
      ⊢ ∀net. trivial_limit net ⇔ eventually (λx. F) net
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/real/.hol/objs/netsScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-2</a></em></p></body></html>
