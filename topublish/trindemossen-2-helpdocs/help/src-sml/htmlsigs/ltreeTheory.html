<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure ltreeTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure ltreeTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/coalgebras/.hol/objs/ltreeScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature ltreeTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#finite_branching_def-val">finite_branching_def</a> : thm
<a name="line7"></a>    val <a href="#ltree_TY_DEF-val">ltree_TY_DEF</a> : thm
<a name="line8"></a>    val <a href="#ltree_branching_def-val">ltree_branching_def</a> : thm
<a name="line9"></a>    val <a href="#ltree_children_def_primitive-val">ltree_children_def_primitive</a> : thm
<a name="line10"></a>    val <a href="#ltree_delete_def-val">ltree_delete_def</a> : thm
<a name="line11"></a>    val <a href="#ltree_insert_def-val">ltree_insert_def</a> : thm
<a name="line12"></a>    val <a href="#ltree_map_def-val">ltree_map_def</a> : thm
<a name="line13"></a>    val <a href="#ltree_node_def_primitive-val">ltree_node_def_primitive</a> : thm
<a name="line14"></a>    val <a href="#ltree_paths_def-val">ltree_paths_def</a> : thm
<a name="line15"></a>    val <a href="#ltree_rel_def-val">ltree_rel_def</a> : thm
<a name="line16"></a>    val <a href="#ltree_set_def-val">ltree_set_def</a> : thm
<a name="line17"></a>    val <a href="#parent_inclusive_def-val">parent_inclusive_def</a> : thm
<a name="line18"></a>    val <a href="#path_index_def-val">path_index_def</a> : thm
<a name="line19"></a>    val <a href="#rose_children_def-val">rose_children_def</a> : thm
<a name="line20"></a>    val <a href="#rose_node_def-val">rose_node_def</a> : thm
<a name="line21"></a>    val <a href="#rose_tree_TY_DEF-val">rose_tree_TY_DEF</a> : thm
<a name="line22"></a>    val <a href="#rose_tree_case_def-val">rose_tree_case_def</a> : thm
<a name="line23"></a>    val <a href="#rose_tree_size_def-val">rose_tree_size_def</a> : thm
<a name="line24"></a>    val <a href="#sibling_inclusive_def-val">sibling_inclusive_def</a> : thm
<a name="line25"></a>    val <a href="#subtrees_def-val">subtrees_def</a> : thm
<a name="line26"></a>    val <a href="#to_rose_def-val">to_rose_def</a> : thm
<a name="line27"></a>  
<a name="line28"></a>  (*  Theorems  *)
<a name="line29"></a>    val <a href="#Branch_11-val">Branch_11</a> : thm
<a name="line30"></a>    val <a href="#IN_ltree_paths-val">IN_ltree_paths</a> : thm
<a name="line31"></a>    val <a href="#NIL_IN_ltree_paths-val">NIL_IN_ltree_paths</a> : thm
<a name="line32"></a>    val <a href="#datatype_ltree-val">datatype_ltree</a> : thm
<a name="line33"></a>    val <a href="#datatype_rose_tree-val">datatype_rose_tree</a> : thm
<a name="line34"></a>    val <a href="#finite_branching_cases-val">finite_branching_cases</a> : thm
<a name="line35"></a>    val <a href="#finite_branching_cases'-val">finite_branching_cases'</a> : thm
<a name="line36"></a>    val <a href="#finite_branching_coind-val">finite_branching_coind</a> : thm
<a name="line37"></a>    val <a href="#finite_branching_coind'-val">finite_branching_coind'</a> : thm
<a name="line38"></a>    val <a href="#finite_branching_ltree_el_cases-val">finite_branching_ltree_el_cases</a> : thm
<a name="line39"></a>    val <a href="#finite_branching_rewrite-val">finite_branching_rewrite</a> : thm
<a name="line40"></a>    val <a href="#finite_branching_rules-val">finite_branching_rules</a> : thm
<a name="line41"></a>    val <a href="#finite_branching_rules'-val">finite_branching_rules'</a> : thm
<a name="line42"></a>    val <a href="#from_rose-val">from_rose</a> : thm
<a name="line43"></a>    val <a href="#from_rose_11-val">from_rose_11</a> : thm
<a name="line44"></a>    val <a href="#from_rose_def-val">from_rose_def</a> : thm
<a name="line45"></a>    val <a href="#from_rose_ind-val">from_rose_ind</a> : thm
<a name="line46"></a>    val <a href="#gen_ltree-val">gen_ltree</a> : thm
<a name="line47"></a>    val <a href="#gen_ltree_LNIL-val">gen_ltree_LNIL</a> : thm
<a name="line48"></a>    val <a href="#gen_ltree_unchanged-val">gen_ltree_unchanged</a> : thm
<a name="line49"></a>    val <a href="#gen_ltree_unchanged_extra-val">gen_ltree_unchanged_extra</a> : thm
<a name="line50"></a>    val <a href="#ltree_CASE-val">ltree_CASE</a> : thm
<a name="line51"></a>    val <a href="#ltree_CASE_cong-val">ltree_CASE_cong</a> : thm
<a name="line52"></a>    val <a href="#ltree_CASE_elim-val">ltree_CASE_elim</a> : thm
<a name="line53"></a>    val <a href="#ltree_CASE_eq-val">ltree_CASE_eq</a> : thm
<a name="line54"></a>    val <a href="#ltree_bisimulation-val">ltree_bisimulation</a> : thm
<a name="line55"></a>    val <a href="#ltree_branching_CONS-val">ltree_branching_CONS</a> : thm
<a name="line56"></a>    val <a href="#ltree_branching_NIL-val">ltree_branching_NIL</a> : thm
<a name="line57"></a>    val <a href="#ltree_branching_alt_ltree_lookup-val">ltree_branching_alt_ltree_lookup</a> : thm
<a name="line58"></a>    val <a href="#ltree_branching_ltree_paths-val">ltree_branching_ltree_paths</a> : thm
<a name="line59"></a>    val <a href="#ltree_cases-val">ltree_cases</a> : thm
<a name="line60"></a>    val <a href="#ltree_children_def-val">ltree_children_def</a> : thm
<a name="line61"></a>    val <a href="#ltree_children_ind-val">ltree_children_ind</a> : thm
<a name="line62"></a>    val <a href="#ltree_delete_CONS-val">ltree_delete_CONS</a> : thm
<a name="line63"></a>    val <a href="#ltree_delete_NIL-val">ltree_delete_NIL</a> : thm
<a name="line64"></a>    val <a href="#ltree_delete_path_stable-val">ltree_delete_path_stable</a> : thm
<a name="line65"></a>    val <a href="#ltree_delete_paths-val">ltree_delete_paths</a> : thm
<a name="line66"></a>    val <a href="#ltree_el-val">ltree_el</a> : thm
<a name="line67"></a>    val <a href="#ltree_el_alt_ltree_lookup-val">ltree_el_alt_ltree_lookup</a> : thm
<a name="line68"></a>    val <a href="#ltree_el_def-val">ltree_el_def</a> : thm
<a name="line69"></a>    val <a href="#ltree_el_eqv-val">ltree_el_eqv</a> : thm
<a name="line70"></a>    val <a href="#ltree_el_ltree_delete-val">ltree_el_ltree_delete</a> : thm
<a name="line71"></a>    val <a href="#ltree_el_ltree_delete'-val">ltree_el_ltree_delete'</a> : thm
<a name="line72"></a>    val <a href="#ltree_el_ltree_insert-val">ltree_el_ltree_insert</a> : thm
<a name="line73"></a>    val <a href="#ltree_el_ltree_insert'-val">ltree_el_ltree_insert'</a> : thm
<a name="line74"></a>    val <a href="#ltree_el_valid-val">ltree_el_valid</a> : thm
<a name="line75"></a>    val <a href="#ltree_el_valid_inclusive-val">ltree_el_valid_inclusive</a> : thm
<a name="line76"></a>    val <a href="#ltree_every_cases-val">ltree_every_cases</a> : thm
<a name="line77"></a>    val <a href="#ltree_every_coind-val">ltree_every_coind</a> : thm
<a name="line78"></a>    val <a href="#ltree_every_rewrite-val">ltree_every_rewrite</a> : thm
<a name="line79"></a>    val <a href="#ltree_every_rules-val">ltree_every_rules</a> : thm
<a name="line80"></a>    val <a href="#ltree_finite-val">ltree_finite</a> : thm
<a name="line81"></a>    val <a href="#ltree_finite_alt_ltree_paths-val">ltree_finite_alt_ltree_paths</a> : thm
<a name="line82"></a>    val <a href="#ltree_finite_by_unfolding-val">ltree_finite_by_unfolding</a> : thm
<a name="line83"></a>    val <a href="#ltree_finite_by_unfolding'-val">ltree_finite_by_unfolding'</a> : thm
<a name="line84"></a>    val <a href="#ltree_finite_cases-val">ltree_finite_cases</a> : thm
<a name="line85"></a>    val <a href="#ltree_finite_from_rose-val">ltree_finite_from_rose</a> : thm
<a name="line86"></a>    val <a href="#ltree_finite_imp_finite_branching-val">ltree_finite_imp_finite_branching</a> : thm
<a name="line87"></a>    val <a href="#ltree_finite_imp_finite_ltree_paths-val">ltree_finite_imp_finite_ltree_paths</a> : thm
<a name="line88"></a>    val <a href="#ltree_finite_ind-val">ltree_finite_ind</a> : thm
<a name="line89"></a>    val <a href="#ltree_finite_ltree_insert-val">ltree_finite_ltree_insert</a> : thm
<a name="line90"></a>    val <a href="#ltree_finite_rules-val">ltree_finite_rules</a> : thm
<a name="line91"></a>    val <a href="#ltree_finite_strongind-val">ltree_finite_strongind</a> : thm
<a name="line92"></a>    val <a href="#ltree_insert_CONS-val">ltree_insert_CONS</a> : thm
<a name="line93"></a>    val <a href="#ltree_insert_NIL-val">ltree_insert_NIL</a> : thm
<a name="line94"></a>    val <a href="#ltree_insert_delete-val">ltree_insert_delete</a> : thm
<a name="line95"></a>    val <a href="#ltree_insert_delete'-val">ltree_insert_delete'</a> : thm
<a name="line96"></a>    val <a href="#ltree_insert_path_stable-val">ltree_insert_path_stable</a> : thm
<a name="line97"></a>    val <a href="#ltree_insert_paths-val">ltree_insert_paths</a> : thm
<a name="line98"></a>    val <a href="#ltree_lookup-val">ltree_lookup</a> : thm
<a name="line99"></a>    val <a href="#ltree_lookup_SNOC-val">ltree_lookup_SNOC</a> : thm
<a name="line100"></a>    val <a href="#ltree_lookup_append-val">ltree_lookup_append</a> : thm
<a name="line101"></a>    val <a href="#ltree_lookup_def-val">ltree_lookup_def</a> : thm
<a name="line102"></a>    val <a href="#ltree_lookup_valid-val">ltree_lookup_valid</a> : thm
<a name="line103"></a>    val <a href="#ltree_lookup_valid_inclusive-val">ltree_lookup_valid_inclusive</a> : thm
<a name="line104"></a>    val <a href="#ltree_map-val">ltree_map</a> : thm
<a name="line105"></a>    val <a href="#ltree_map_id-val">ltree_map_id</a> : thm
<a name="line106"></a>    val <a href="#ltree_map_map-val">ltree_map_map</a> : thm
<a name="line107"></a>    val <a href="#ltree_node_children_reduce-val">ltree_node_children_reduce</a> : thm
<a name="line108"></a>    val <a href="#ltree_node_def-val">ltree_node_def</a> : thm
<a name="line109"></a>    val <a href="#ltree_node_ind-val">ltree_node_ind</a> : thm
<a name="line110"></a>    val <a href="#ltree_path_le_total-val">ltree_path_le_total</a> : thm
<a name="line111"></a>    val <a href="#ltree_path_lt-val">ltree_path_lt</a> : thm
<a name="line112"></a>    val <a href="#ltree_path_lt_antisymmetric-val">ltree_path_lt_antisymmetric</a> : thm
<a name="line113"></a>    val <a href="#ltree_path_lt_irreflexive-val">ltree_path_lt_irreflexive</a> : thm
<a name="line114"></a>    val <a href="#ltree_path_lt_sibling-val">ltree_path_lt_sibling</a> : thm
<a name="line115"></a>    val <a href="#ltree_path_lt_sibling'-val">ltree_path_lt_sibling'</a> : thm
<a name="line116"></a>    val <a href="#ltree_path_lt_transitive-val">ltree_path_lt_transitive</a> : thm
<a name="line117"></a>    val <a href="#ltree_paths_alt_ltree_el-val">ltree_paths_alt_ltree_el</a> : thm
<a name="line118"></a>    val <a href="#ltree_paths_inclusive-val">ltree_paths_inclusive</a> : thm
<a name="line119"></a>    val <a href="#ltree_paths_map_cong-val">ltree_paths_map_cong</a> : thm
<a name="line120"></a>    val <a href="#ltree_rel-val">ltree_rel</a> : thm
<a name="line121"></a>    val <a href="#ltree_rel_O-val">ltree_rel_O</a> : thm
<a name="line122"></a>    val <a href="#ltree_rel_eq-val">ltree_rel_eq</a> : thm
<a name="line123"></a>    val <a href="#ltree_set-val">ltree_set</a> : thm
<a name="line124"></a>    val <a href="#ltree_set_map-val">ltree_set_map</a> : thm
<a name="line125"></a>    val <a href="#ltree_unfold-val">ltree_unfold</a> : thm
<a name="line126"></a>    val <a href="#parent_inclusive_ltree_paths-val">parent_inclusive_ltree_paths</a> : thm
<a name="line127"></a>    val <a href="#parent_inclusive_union-val">parent_inclusive_union</a> : thm
<a name="line128"></a>    val <a href="#path_index_in_paths-val">path_index_in_paths</a> : thm
<a name="line129"></a>    val <a href="#path_index_thm-val">path_index_thm</a> : thm
<a name="line130"></a>    val <a href="#rose_children_to_rose-val">rose_children_to_rose</a> : thm
<a name="line131"></a>    val <a href="#rose_children_to_rose'-val">rose_children_to_rose'</a> : thm
<a name="line132"></a>    val <a href="#rose_node_to_rose-val">rose_node_to_rose</a> : thm
<a name="line133"></a>    val <a href="#rose_reduce-val">rose_reduce</a> : thm
<a name="line134"></a>    val <a href="#rose_reduce_def-val">rose_reduce_def</a> : thm
<a name="line135"></a>    val <a href="#rose_reduce_ind-val">rose_reduce_ind</a> : thm
<a name="line136"></a>    val <a href="#rose_tree_11-val">rose_tree_11</a> : thm
<a name="line137"></a>    val <a href="#rose_tree_Axiom-val">rose_tree_Axiom</a> : thm
<a name="line138"></a>    val <a href="#rose_tree_case_cong-val">rose_tree_case_cong</a> : thm
<a name="line139"></a>    val <a href="#rose_tree_case_eq-val">rose_tree_case_eq</a> : thm
<a name="line140"></a>    val <a href="#rose_tree_induction-val">rose_tree_induction</a> : thm
<a name="line141"></a>    val <a href="#rose_tree_nchotomy-val">rose_tree_nchotomy</a> : thm
<a name="line142"></a>    val <a href="#sibling_inclusive_ltree_paths-val">sibling_inclusive_ltree_paths</a> : thm
<a name="line143"></a>    val <a href="#sibling_inclusive_union-val">sibling_inclusive_union</a> : thm
<a name="line144"></a>    val <a href="#subtrees-val">subtrees</a> : thm
<a name="line145"></a>    val <a href="#to_rose_thm-val">to_rose_thm</a> : thm
<a name="line146"></a>(*
   [alist] Parent theory of "ltree"
   
   [iterate] Parent theory of "ltree"
   
   [llist] Parent theory of "ltree"
   
   [<a name="finite_branching_def-val"><b>finite_branching_def</b></a>]  Definition
      
      ⊢ finite_branching = ltree_every (λa ts. LFINITE ts)
   
   [<a name="ltree_TY_DEF-val"><b>ltree_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep. TYPE_DEFINITION ltree_rep_ok rep
   
   [<a name="ltree_branching_def-val"><b>ltree_branching_def</b></a>]  Definition
      
      ⊢ ∀t p. ltree_branching t p = SND (THE (ltree_el t p))
   
   [<a name="ltree_children_def_primitive-val"><b>ltree_children_def_primitive</b></a>]  Definition
      
      ⊢ ltree_children =
        WFREC (@R. WF R)
          (λltree_children a'. case a' of Branch a ts =&gt; I ts)
   
   [<a name="ltree_delete_def-val"><b>ltree_delete_def</b></a>]  Definition
      
      ⊢ ∀f t p.
          ltree_delete f t p =
          gen_ltree
            (λns.
                 (let
                    (d,len) = THE (ltree_el t ns);
                    m = THE len
                  in
                    if ns = p ∧ len ≠ NONE ∧ 0 &lt; m then (f d,SOME (m − 1))
                    else (d,len)))
   
   [<a name="ltree_insert_def-val"><b>ltree_insert_def</b></a>]  Definition
      
      ⊢ ∀f t p t0.
          ltree_insert f t p t0 =
          gen_ltree
            (λns.
                 if ltree_el t ns ≠ NONE then
                   (let
                      (d,len) = THE (ltree_el t ns);
                      m = THE len
                    in
                      if ns = p ∧ len ≠ NONE then (f d,SOME (m + 1))
                      else (d,len))
                 else THE (ltree_el t0 (DROP (LENGTH p + 1) ns)))
   
   [<a name="ltree_map_def-val"><b>ltree_map_def</b></a>]  Definition
      
      ⊢ ∀f. ltree_map f =
            ltree_unfold (λt. case t of Branch a ts =&gt; (f a,ts))
   
   [<a name="ltree_node_def_primitive-val"><b>ltree_node_def_primitive</b></a>]  Definition
      
      ⊢ ltree_node =
        WFREC (@R. WF R) (λltree_node a'. case a' of Branch a ts =&gt; I a)
   
   [<a name="ltree_paths_def-val"><b>ltree_paths_def</b></a>]  Definition
      
      ⊢ ∀t. ltree_paths t = {p | ltree_lookup t p ≠ NONE}
   
   [<a name="ltree_rel_def-val"><b>ltree_rel_def</b></a>]  Definition
      
      ⊢ ∀R x y.
          ltree_rel R x y ⇔
          ∀path.
            OPTREL (λx y. R (FST x) (FST y) ∧ SND x = SND y)
              (ltree_el x path) (ltree_el y path)
   
   [<a name="ltree_set_def-val"><b>ltree_set_def</b></a>]  Definition
      
      ⊢ ∀t. ltree_set t = {a | ∃ts. Branch a ts ∈ subtrees t}
   
   [<a name="parent_inclusive_def-val"><b>parent_inclusive_def</b></a>]  Definition
      
      ⊢ ∀s. parent_inclusive s ⇔ ∀p q. p ∈ s ∧ q ≼ p ⇒ q ∈ s
   
   [<a name="path_index_def-val"><b>path_index_def</b></a>]  Definition
      
      ⊢ ∀s. FINITE s ⇒
            s = IMAGE (path_index s) (count (CARD s)) ∧
            ∀j k.
              j &lt; CARD s ∧ k &lt; CARD s ∧ j &lt; k ⇒
              ¬ltree_path_lt (path_index s k) (path_index s j)
   
   [<a name="rose_children_def-val"><b>rose_children_def</b></a>]  Definition
      
      ⊢ ∀a ts. rose_children (Rose a ts) = ts
   
   [<a name="rose_node_def-val"><b>rose_node_def</b></a>]  Definition
      
      ⊢ ∀a ts. rose_node (Rose a ts) = a
   
   [<a name="rose_tree_TY_DEF-val"><b>rose_tree_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep.
          TYPE_DEFINITION
            (λa0'.
                 ∀ $var$('rose_tree') $var$('@temp@ind_typeltree0list').
                   (∀a0'.
                      (∃a0 a1.
                         a0' =
                         (λa0 a1.
                              ind_type$CONSTR 0 a0
                                (ind_type$FCONS a1 (λn. ind_type$BOTTOM)))
                           a0 a1 ∧ $var$('@temp@ind_typeltree0list') a1) ⇒
                      $var$('rose_tree') a0') ∧
                   (∀a1'.
                      a1' =
                      ind_type$CONSTR (SUC 0) ARB (λn. ind_type$BOTTOM) ∨
                      (∃a0 a1.
                         a1' =
                         (λa0 a1.
                              ind_type$CONSTR (SUC (SUC 0)) ARB
                                (ind_type$FCONS a0
                                   (ind_type$FCONS a1 (λn. ind_type$BOTTOM))))
                           a0 a1 ∧ $var$('rose_tree') a0 ∧
                         $var$('@temp@ind_typeltree0list') a1) ⇒
                      $var$('@temp@ind_typeltree0list') a1') ⇒
                   $var$('rose_tree') a0') rep
   
   [<a name="rose_tree_case_def-val"><b>rose_tree_case_def</b></a>]  Definition
      
      ⊢ ∀a0 a1 f. rose_tree_CASE (Rose a0 a1) f = f a0 a1
   
   [<a name="rose_tree_size_def-val"><b>rose_tree_size_def</b></a>]  Definition
      
      ⊢ (∀f a0 a1.
           rose_tree_size f (Rose a0 a1) =
           1 + (f a0 + rose_tree1_size f a1)) ∧
        (∀f. rose_tree1_size f [] = 0) ∧
        ∀f a0 a1.
          rose_tree1_size f (a0::a1) =
          1 + (rose_tree_size f a0 + rose_tree1_size f a1)
   
   [<a name="sibling_inclusive_def-val"><b>sibling_inclusive_def</b></a>]  Definition
      
      ⊢ ∀s. sibling_inclusive s ⇔
            ∀p q.
              p ∈ s ∧ p ≠ [] ∧ q ≠ [] ∧ FRONT q = FRONT p ∧ LAST q &lt; LAST p ⇒
              q ∈ s
   
   [<a name="subtrees_def-val"><b>subtrees_def</b></a>]  Definition
      
      ⊢ ∀t. subtrees t = {u | ∃path. ltree_lookup t path = SOME u}
   
   [<a name="to_rose_def-val"><b>to_rose_def</b></a>]  Definition
      
      ⊢ ∀t. ltree_finite t ⇒ from_rose (to_rose t) = t
   
   [<a name="Branch_11-val"><b>Branch_11</b></a>]  Theorem
      
      ⊢ ∀a1 a2 ts1 ts2. Branch a1 ts1 = Branch a2 ts2 ⇔ a1 = a2 ∧ ts1 = ts2
   
   [<a name="IN_ltree_paths-val"><b>IN_ltree_paths</b></a>]  Theorem
      
      ⊢ ∀p t. p ∈ ltree_paths t ⇔ ltree_lookup t p ≠ NONE
   
   [<a name="NIL_IN_ltree_paths-val"><b>NIL_IN_ltree_paths</b></a>]  Theorem
      
      ⊢ [] ∈ ltree_paths t
   
   [<a name="datatype_ltree-val"><b>datatype_ltree</b></a>]  Theorem
      
      ⊢ DATATYPE (ltree Branch)
   
   [<a name="datatype_rose_tree-val"><b>datatype_rose_tree</b></a>]  Theorem
      
      ⊢ DATATYPE (rose_tree Rose)
   
   [<a name="finite_branching_cases-val"><b>finite_branching_cases</b></a>]  Theorem
      
      ⊢ ∀t. finite_branching t ⇔
            ∃a ts. t = Branch a (fromList ts) ∧ EVERY finite_branching ts
   
   [<a name="finite_branching_cases'-val"><b>finite_branching_cases'</b></a>]  Theorem
      
      ⊢ ∀t. finite_branching t ⇔
            ∃a ts. t = Branch a ts ∧ LFINITE ts ∧ every finite_branching ts
   
   [<a name="finite_branching_coind-val"><b>finite_branching_coind</b></a>]  Theorem
      
      ⊢ ∀P. (∀t. P t ⇒ ∃a ts. t = Branch a (fromList ts) ∧ EVERY P ts) ⇒
            ∀t. P t ⇒ finite_branching t
   
   [<a name="finite_branching_coind'-val"><b>finite_branching_coind'</b></a>]  Theorem
      
      ⊢ ∀P. (∀t. P t ⇒ ∃a ts. t = Branch a ts ∧ LFINITE ts ∧ every P ts) ⇒
            ∀t. P t ⇒ finite_branching t
   
   [<a name="finite_branching_ltree_el_cases-val"><b>finite_branching_ltree_el_cases</b></a>]  Theorem
      
      ⊢ ∀p t.
          finite_branching t ∧ p ∈ ltree_paths t ⇒
          ∃d m. ltree_el t p = SOME (d,SOME m)
   
   [<a name="finite_branching_rewrite-val"><b>finite_branching_rewrite</b></a>]  Theorem
      
      ⊢ finite_branching (Branch a ts) ⇔
        LFINITE ts ∧ every finite_branching ts
   
   [<a name="finite_branching_rules-val"><b>finite_branching_rules</b></a>]  Theorem
      
      ⊢ ∀a ts.
          EVERY finite_branching ts ⇒
          finite_branching (Branch a (fromList ts))
   
   [<a name="finite_branching_rules'-val"><b>finite_branching_rules'</b></a>]  Theorem
      
      ⊢ ∀a ts.
          LFINITE ts ∧ every finite_branching ts ⇒
          finite_branching (Branch a ts)
   
   [<a name="from_rose-val"><b>from_rose</b></a>]  Theorem
      
      ⊢ ∀t. from_rose t =
            Branch (rose_node t)
              (fromList (MAP from_rose (rose_children t)))
   
   [<a name="from_rose_11-val"><b>from_rose_11</b></a>]  Theorem
      
      ⊢ ∀r1 r2. from_rose r1 = from_rose r2 ⇔ r1 = r2
   
   [<a name="from_rose_def-val"><b>from_rose_def</b></a>]  Theorem
      
      ⊢ ∀ts a.
          from_rose (Rose a ts) = Branch a (fromList (MAP from_rose ts))
   
   [<a name="from_rose_ind-val"><b>from_rose_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀a ts. (∀a'. MEM a' ts ⇒ P a') ⇒ P (Rose a ts)) ⇒ ∀v. P v
   
   [<a name="gen_ltree-val"><b>gen_ltree</b></a>]  Theorem
      
      ⊢ gen_ltree f =
        (let
           (a,len) = f []
         in
           Branch a (LGENLIST (λn. gen_ltree (λpath. f (n::path))) len))
   
   [<a name="gen_ltree_LNIL-val"><b>gen_ltree_LNIL</b></a>]  Theorem
      
      ⊢ gen_ltree f = Branch a [||] ⇔ f [] = (a,SOME 0)
   
   [<a name="gen_ltree_unchanged-val"><b>gen_ltree_unchanged</b></a>]  Theorem
      
      ⊢ ∀t. gen_ltree (λp. THE (ltree_el t p)) = t
   
   [<a name="gen_ltree_unchanged_extra-val"><b>gen_ltree_unchanged_extra</b></a>]  Theorem
      
      ⊢ ∀t f.
          gen_ltree
            (λp. if ltree_el t p ≠ NONE then THE (ltree_el t p) else f p) =
          t
   
   [<a name="ltree_CASE-val"><b>ltree_CASE</b></a>]  Theorem
      
      ⊢ ltree_CASE (Branch a ts) f = f a ts
   
   [<a name="ltree_CASE_cong-val"><b>ltree_CASE_cong</b></a>]  Theorem
      
      ⊢ ∀M M' f f'.
          M = M' ∧ (∀a ts. M' = Branch a ts ⇒ f a ts = f' a ts) ⇒
          ltree_CASE M f = ltree_CASE M' f'
   
   [<a name="ltree_CASE_elim-val"><b>ltree_CASE_elim</b></a>]  Theorem
      
      ⊢ ∀f'. f' (ltree_CASE t f) ⇔ ∃a ts. t = Branch a ts ∧ f' (f a ts)
   
   [<a name="ltree_CASE_eq-val"><b>ltree_CASE_eq</b></a>]  Theorem
      
      ⊢ ltree_CASE t f = v ⇔ ∃a ts. t = Branch a ts ∧ f a ts = v
   
   [<a name="ltree_bisimulation-val"><b>ltree_bisimulation</b></a>]  Theorem
      
      ⊢ ∀t1 t2.
          t1 = t2 ⇔
          ∃R. R t1 t2 ∧
              ∀a ts a' ts'.
                R (Branch a ts) (Branch a' ts') ⇒
                a = a' ∧ llist_rel R ts ts'
   
   [<a name="ltree_branching_CONS-val"><b>ltree_branching_CONS</b></a>]  Theorem
      
      ⊢ ∀h p a ts.
          h::p ∈ ltree_paths (Branch a ts) ⇒
          ltree_branching (Branch a ts) (h::p) =
          ltree_branching (THE (LNTH h ts)) p
   
   [<a name="ltree_branching_NIL-val"><b>ltree_branching_NIL</b></a>]  Theorem
      
      ⊢ ∀a ts. ltree_branching (Branch a ts) [] = LLENGTH ts
   
   [<a name="ltree_branching_alt_ltree_lookup-val"><b>ltree_branching_alt_ltree_lookup</b></a>]  Theorem
      
      ⊢ ∀p t.
          p ∈ ltree_paths t ⇒
          ltree_branching t p =
          LLENGTH (ltree_children (THE (ltree_lookup t p)))
   
   [<a name="ltree_branching_ltree_paths-val"><b>ltree_branching_ltree_paths</b></a>]  Theorem
      
      ⊢ ∀p t m.
          p ∈ ltree_paths t ∧ ltree_branching t p = SOME m ⇒
          ∀h. h &lt; m ⇔ SNOC h p ∈ ltree_paths t
   
   [<a name="ltree_cases-val"><b>ltree_cases</b></a>]  Theorem
      
      ⊢ ∀t. ∃a ts. t = Branch a ts
   
   [<a name="ltree_children_def-val"><b>ltree_children_def</b></a>]  Theorem
      
      ⊢ ltree_children (Branch a ts) = ts
   
   [<a name="ltree_children_ind-val"><b>ltree_children_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀a ts. P (Branch a ts)) ⇒ ∀v. P v
   
   [<a name="ltree_delete_CONS-val"><b>ltree_delete_CONS</b></a>]  Theorem
      
      ⊢ ∀f a ts h p t.
          LNTH h ts = SOME t ∧ ltree_el t p ≠ NONE ⇒
          ltree_delete f (Branch a ts) (h::p) =
          Branch a
            (LGENLIST
               (λi.
                    if i = h then ltree_delete f (THE (LNTH h ts)) p
                    else THE (LNTH i ts)) (LLENGTH ts))
   
   [<a name="ltree_delete_NIL-val"><b>ltree_delete_NIL</b></a>]  Theorem
      
      ⊢ ∀f a ts.
          ltree_delete f (Branch a ts) [] =
          if LFINITE ts ∧ 0 &lt; THE (LLENGTH ts) then
            Branch (f a)
              (LGENLIST (λi. THE (LNTH i ts)) (SOME (THE (LLENGTH ts) − 1)))
          else Branch a ts
   
   [<a name="ltree_delete_path_stable-val"><b>ltree_delete_path_stable</b></a>]  Theorem
      
      ⊢ ∀f p t. p ∈ ltree_paths t ⇒ p ∈ ltree_paths (ltree_delete f t p)
   
   [<a name="ltree_delete_paths-val"><b>ltree_delete_paths</b></a>]  Theorem
      
      ⊢ ∀f p t n.
          p ∈ ltree_paths t ∧ ltree_branching t p = SOME (SUC n) ⇒
          ltree_paths (ltree_delete f t p) =
          ltree_paths t DIFF
          IMAGE (λq. SNOC n p ⧺ q)
            (ltree_paths (THE (ltree_lookup t (SNOC n p))))
   
   [<a name="ltree_el-val"><b>ltree_el</b></a>]  Theorem
      
      ⊢ ltree_el t [] = SOME (ltree_node t,LLENGTH (ltree_children t)) ∧
        ltree_el t (n::ns) =
        case LNTH n (ltree_children t) of
          NONE =&gt; NONE
        | SOME a =&gt; ltree_el a ns
   
   [<a name="ltree_el_alt_ltree_lookup-val"><b>ltree_el_alt_ltree_lookup</b></a>]  Theorem
      
      ⊢ ∀p t.
          p ∈ ltree_paths t ⇒
          ltree_el t p =
          do
            t' &lt;- ltree_lookup t p;
            SOME (ltree_node t',LLENGTH (ltree_children t'))
          od
   
   [<a name="ltree_el_def-val"><b>ltree_el_def</b></a>]  Theorem
      
      ⊢ ltree_el (Branch a ts) [] = SOME (a,LLENGTH ts) ∧
        ltree_el (Branch a ts) (n::ns) =
        case LNTH n ts of NONE =&gt; NONE | SOME t =&gt; ltree_el t ns
   
   [<a name="ltree_el_eqv-val"><b>ltree_el_eqv</b></a>]  Theorem
      
      ⊢ ∀t1 t2. t1 = t2 ⇔ ∀path. ltree_el t1 path = ltree_el t2 path
   
   [<a name="ltree_el_ltree_delete-val"><b>ltree_el_ltree_delete</b></a>]  Theorem
      
      ⊢ ∀f p t.
          ltree_el t p = SOME (a,SOME (SUC n)) ⇒
          ltree_el (ltree_delete f t p) p = SOME (f a,SOME n)
   
   [<a name="ltree_el_ltree_delete'-val"><b>ltree_el_ltree_delete'</b></a>]  Theorem
      
      ⊢ ∀p t.
          ltree_el t p = SOME (a,SOME (SUC n)) ⇒
          ltree_el (ltree_delete' t p) p = SOME (a,SOME n)
   
   [<a name="ltree_el_ltree_insert-val"><b>ltree_el_ltree_insert</b></a>]  Theorem
      
      ⊢ ∀f p t t0.
          ltree_el t p = SOME (a,SOME n) ⇒
          ltree_el (ltree_insert f t p t0) p = SOME (f a,SOME (SUC n))
   
   [<a name="ltree_el_ltree_insert'-val"><b>ltree_el_ltree_insert'</b></a>]  Theorem
      
      ⊢ ∀p t t0.
          ltree_el t p = SOME (a,SOME n) ⇒
          ltree_el (ltree_insert' t p t0) p = SOME (a,SOME (SUC n))
   
   [<a name="ltree_el_valid-val"><b>ltree_el_valid</b></a>]  Theorem
      
      ⊢ ∀p t. p ∈ ltree_paths t ⇔ ltree_el t p ≠ NONE
   
   [<a name="ltree_el_valid_inclusive-val"><b>ltree_el_valid_inclusive</b></a>]  Theorem
      
      ⊢ ∀p t. p ∈ ltree_paths t ⇔ ∀p'. p' ≼ p ⇒ ltree_el t p' ≠ NONE
   
   [<a name="ltree_every_cases-val"><b>ltree_every_cases</b></a>]  Theorem
      
      ⊢ ∀P a0.
          ltree_every P a0 ⇔
          ∃a ts. a0 = Branch a ts ∧ P a ts ∧ every (ltree_every P) ts
   
   [<a name="ltree_every_coind-val"><b>ltree_every_coind</b></a>]  Theorem
      
      ⊢ ∀P ltree_every'.
          (∀a0.
             ltree_every' a0 ⇒
             ∃a ts. a0 = Branch a ts ∧ P a ts ∧ every ltree_every' ts) ⇒
          ∀a0. ltree_every' a0 ⇒ ltree_every P a0
   
   [<a name="ltree_every_rewrite-val"><b>ltree_every_rewrite</b></a>]  Theorem
      
      ⊢ ltree_every P (Branch a ts) ⇔ P a ts ∧ every (ltree_every P) ts
   
   [<a name="ltree_every_rules-val"><b>ltree_every_rules</b></a>]  Theorem
      
      ⊢ ∀P a ts.
          P a ts ∧ every (ltree_every P) ts ⇒ ltree_every P (Branch a ts)
   
   [<a name="ltree_finite-val"><b>ltree_finite</b></a>]  Theorem
      
      ⊢ ltree_finite (Branch a ts) ⇔
        LFINITE ts ∧ ∀t. t ∈ LSET ts ⇒ ltree_finite t
   
   [<a name="ltree_finite_alt_ltree_paths-val"><b>ltree_finite_alt_ltree_paths</b></a>]  Theorem
      
      ⊢ ∀t. ltree_finite t ⇔ FINITE (ltree_paths t)
   
   [<a name="ltree_finite_by_unfolding-val"><b>ltree_finite_by_unfolding</b></a>]  Theorem
      
      ⊢ ∀P f.
          (∃m. ∀seed.
             P seed ⇒
             (let
                (a,seeds) = f seed
              in
                LFINITE seeds ∧ every (λe. P e ∧ m e &lt; m seed) seeds)) ⇒
          ∀seed. P seed ⇒ ltree_finite (ltree_unfold f seed)
   
   [<a name="ltree_finite_by_unfolding'-val"><b>ltree_finite_by_unfolding'</b></a>]  Theorem
      
      ⊢ ∀f. (∃m. ∀seed.
               (let
                  (a,seeds) = f seed
                in
                  LFINITE seeds ∧ every (λe. m e &lt; m seed) seeds)) ⇒
            ∀seed. ltree_finite (ltree_unfold f seed)
   
   [<a name="ltree_finite_cases-val"><b>ltree_finite_cases</b></a>]  Theorem
      
      ⊢ ∀a0.
          ltree_finite a0 ⇔
          ∃a ts. a0 = Branch a (fromList ts) ∧ EVERY ltree_finite ts
   
   [<a name="ltree_finite_from_rose-val"><b>ltree_finite_from_rose</b></a>]  Theorem
      
      ⊢ ltree_finite t ⇔ ∃r. from_rose r = t
   
   [<a name="ltree_finite_imp_finite_branching-val"><b>ltree_finite_imp_finite_branching</b></a>]  Theorem
      
      ⊢ ∀t. ltree_finite t ⇒ finite_branching t
   
   [<a name="ltree_finite_imp_finite_ltree_paths-val"><b>ltree_finite_imp_finite_ltree_paths</b></a>]  Theorem
      
      ⊢ ∀t. ltree_finite t ⇒ FINITE (ltree_paths t)
   
   [<a name="ltree_finite_ind-val"><b>ltree_finite_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀a ts. EVERY P ts ⇒ P (Branch a (fromList ts))) ⇒
            ∀t. ltree_finite t ⇒ P t
   
   [<a name="ltree_finite_ltree_insert-val"><b>ltree_finite_ltree_insert</b></a>]  Theorem
      
      ⊢ ∀f p t t0.
          ltree_finite t ∧ p ∈ ltree_paths t ∧ ltree_finite t0 ⇒
          ltree_finite (ltree_insert f t p t0)
   
   [<a name="ltree_finite_rules-val"><b>ltree_finite_rules</b></a>]  Theorem
      
      ⊢ ∀a ts.
          EVERY ltree_finite ts ⇒ ltree_finite (Branch a (fromList ts))
   
   [<a name="ltree_finite_strongind-val"><b>ltree_finite_strongind</b></a>]  Theorem
      
      ⊢ ∀P. (∀a ts.
               EVERY (λa0. ltree_finite a0 ∧ P a0) ts ⇒
               P (Branch a (fromList ts))) ⇒
            ∀t. ltree_finite t ⇒ P t
   
   [<a name="ltree_insert_CONS-val"><b>ltree_insert_CONS</b></a>]  Theorem
      
      ⊢ ∀f a ts h p t t0.
          LNTH h ts = SOME t ∧ ltree_el t p ≠ NONE ⇒
          ltree_insert f (Branch a ts) (h::p) t0 =
          Branch a
            (LGENLIST
               (λi.
                    if i = h then ltree_insert f (THE (LNTH h ts)) p t0
                    else THE (LNTH i ts)) (LLENGTH ts))
   
   [<a name="ltree_insert_NIL-val"><b>ltree_insert_NIL</b></a>]  Theorem
      
      ⊢ ∀f a ts t0.
          ltree_insert f (Branch a ts) [] t0 =
          if LFINITE ts then
            Branch (f a)
              (LGENLIST
                 (λi. if i &lt; THE (LLENGTH ts) then THE (LNTH i ts) else t0)
                 (SOME (THE (LLENGTH ts) + 1)))
          else Branch a ts
   
   [<a name="ltree_insert_delete-val"><b>ltree_insert_delete</b></a>]  Theorem
      
      ⊢ ∀n p t t0 f g d len.
          ltree_branching t p = SOME (SUC n) ∧
          ltree_lookup t (SNOC n p) = SOME t0 ∧
          ltree_el t p = SOME (d,len) ∧ f (g d) = d ⇒
          ltree_insert f (ltree_delete g t p) p t0 = t
   
   [<a name="ltree_insert_delete'-val"><b>ltree_insert_delete'</b></a>]  Theorem
      
      ⊢ ∀n p t t0.
          ltree_branching t p = SOME (SUC n) ∧
          ltree_lookup t (SNOC n p) = SOME t0 ⇒
          ltree_insert' (ltree_delete' t p) p t0 = t
   
   [<a name="ltree_insert_path_stable-val"><b>ltree_insert_path_stable</b></a>]  Theorem
      
      ⊢ ∀f p t t0.
          p ∈ ltree_paths t ⇒ p ∈ ltree_paths (ltree_insert f t p t0)
   
   [<a name="ltree_insert_paths-val"><b>ltree_insert_paths</b></a>]  Theorem
      
      ⊢ ∀f p t n t0.
          p ∈ ltree_paths t ∧ ltree_branching t p = SOME n ⇒
          ltree_paths (ltree_insert f t p t0) =
          ltree_paths t ∪ IMAGE (λq. SNOC n p ⧺ q) (ltree_paths t0)
   
   [<a name="ltree_lookup-val"><b>ltree_lookup</b></a>]  Theorem
      
      ⊢ ltree_lookup t [] = SOME t ∧
        ltree_lookup t (n::ns) =
        case LNTH n (ltree_children t) of
          NONE =&gt; NONE
        | SOME a =&gt; ltree_lookup a ns
   
   [<a name="ltree_lookup_SNOC-val"><b>ltree_lookup_SNOC</b></a>]  Theorem
      
      ⊢ ∀t x xs.
          ltree_lookup t xs ≠ NONE ⇒
          ltree_lookup t (SNOC x xs) =
          ltree_lookup (THE (ltree_lookup t xs)) [x]
   
   [<a name="ltree_lookup_append-val"><b>ltree_lookup_append</b></a>]  Theorem
      
      ⊢ ∀l1 l2 t.
          ltree_lookup t l1 ≠ NONE ⇒
          ltree_lookup t (l1 ⧺ l2) =
          ltree_lookup (THE (ltree_lookup t l1)) l2
   
   [<a name="ltree_lookup_def-val"><b>ltree_lookup_def</b></a>]  Theorem
      
      ⊢ ltree_lookup t [] = SOME t ∧
        ltree_lookup (Branch a ts) (n::ns) =
        case LNTH n ts of NONE =&gt; NONE | SOME t =&gt; ltree_lookup t ns
   
   [<a name="ltree_lookup_valid-val"><b>ltree_lookup_valid</b></a>]  Theorem
      
      ⊢ ∀p t. p ∈ ltree_paths t ⇔ ltree_lookup t p ≠ NONE
   
   [<a name="ltree_lookup_valid_inclusive-val"><b>ltree_lookup_valid_inclusive</b></a>]  Theorem
      
      ⊢ ∀p t. p ∈ ltree_paths t ⇔ ∀p'. p' ≼ p ⇒ ltree_lookup t p' ≠ NONE
   
   [<a name="ltree_map-val"><b>ltree_map</b></a>]  Theorem
      
      ⊢ ltree_map f (Branch a xs) = Branch (f a) (LMAP (ltree_map f) xs)
   
   [<a name="ltree_map_id-val"><b>ltree_map_id</b></a>]  Theorem
      
      ⊢ ltree_map I t = t
   
   [<a name="ltree_map_map-val"><b>ltree_map_map</b></a>]  Theorem
      
      ⊢ ltree_map f (ltree_map g t) = ltree_map (f ∘ g) t
   
   [<a name="ltree_node_children_reduce-val"><b>ltree_node_children_reduce</b></a>]  Theorem
      
      ⊢ Branch (ltree_node t) (ltree_children t) = t
   
   [<a name="ltree_node_def-val"><b>ltree_node_def</b></a>]  Theorem
      
      ⊢ ltree_node (Branch a ts) = a
   
   [<a name="ltree_node_ind-val"><b>ltree_node_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀a ts. P (Branch a ts)) ⇒ ∀v. P v
   
   [<a name="ltree_path_le_total-val"><b>ltree_path_le_total</b></a>]  Theorem
      
      ⊢ total ltree_path_le
   
   [<a name="ltree_path_lt-val"><b>ltree_path_lt</b></a>]  Theorem
      
      ⊢ (¬ltree_path_lt [] [] ∧ ¬ltree_path_lt (h1::t1) []) ∧
        ltree_path_lt [] (h2::t2) ∧
        (ltree_path_lt (h1::t1) (h2::t2) ⇔
         LENGTH t1 &lt; LENGTH t2 ∨
         LENGTH t1 = LENGTH t2 ∧ (h1 &lt; h2 ∨ h1 = h2 ∧ ltree_path_lt t1 t2))
   
   [<a name="ltree_path_lt_antisymmetric-val"><b>ltree_path_lt_antisymmetric</b></a>]  Theorem
      
      ⊢ antisymmetric ltree_path_lt
   
   [<a name="ltree_path_lt_irreflexive-val"><b>ltree_path_lt_irreflexive</b></a>]  Theorem
      
      ⊢ irreflexive ltree_path_lt
   
   [<a name="ltree_path_lt_sibling-val"><b>ltree_path_lt_sibling</b></a>]  Theorem
      
      ⊢ ∀p q.
          p ≠ [] ∧ q ≠ [] ∧ FRONT p = FRONT q ∧ LAST p &lt; LAST q ⇒
          ltree_path_lt p q
   
   [<a name="ltree_path_lt_sibling'-val"><b>ltree_path_lt_sibling'</b></a>]  Theorem
      
      ⊢ ∀x y xs. x &lt; y ⇒ ltree_path_lt (SNOC x xs) (SNOC y xs)
   
   [<a name="ltree_path_lt_transitive-val"><b>ltree_path_lt_transitive</b></a>]  Theorem
      
      ⊢ transitive ltree_path_lt
   
   [<a name="ltree_paths_alt_ltree_el-val"><b>ltree_paths_alt_ltree_el</b></a>]  Theorem
      
      ⊢ ∀t. ltree_paths t = {p | ltree_el t p ≠ NONE}
   
   [<a name="ltree_paths_inclusive-val"><b>ltree_paths_inclusive</b></a>]  Theorem
      
      ⊢ ∀l1 l2 t. l1 ≼ l2 ∧ l2 ∈ ltree_paths t ⇒ l1 ∈ ltree_paths t
   
   [<a name="ltree_paths_map_cong-val"><b>ltree_paths_map_cong</b></a>]  Theorem
      
      ⊢ ∀f t. ltree_paths (ltree_map f t) = ltree_paths t
   
   [<a name="ltree_rel-val"><b>ltree_rel</b></a>]  Theorem
      
      ⊢ ltree_rel R (Branch a ts) (Branch b us) ⇔
        R a b ∧ llist_rel (ltree_rel R) ts us
   
   [<a name="ltree_rel_O-val"><b>ltree_rel_O</b></a>]  Theorem
      
      ⊢ ltree_rel R1 ∘ᵣ ltree_rel R2 ⊆ᵣ ltree_rel (R1 ∘ᵣ R2)
   
   [<a name="ltree_rel_eq-val"><b>ltree_rel_eq</b></a>]  Theorem
      
      ⊢ ltree_rel $= x y ⇔ x = y
   
   [<a name="ltree_set-val"><b>ltree_set</b></a>]  Theorem
      
      ⊢ ltree_set (Branch a ts) =
        a INSERT BIGUNION (IMAGE ltree_set (LSET ts))
   
   [<a name="ltree_set_map-val"><b>ltree_set_map</b></a>]  Theorem
      
      ⊢ ltree_set (ltree_map f t) = IMAGE f (ltree_set t)
   
   [<a name="ltree_unfold-val"><b>ltree_unfold</b></a>]  Theorem
      
      ⊢ ltree_unfold f seed =
        (let (a,seeds) = f seed in Branch a (LMAP (ltree_unfold f) seeds))
   
   [<a name="parent_inclusive_ltree_paths-val"><b>parent_inclusive_ltree_paths</b></a>]  Theorem
      
      ⊢ ∀t. parent_inclusive (ltree_paths t)
   
   [<a name="parent_inclusive_union-val"><b>parent_inclusive_union</b></a>]  Theorem
      
      ⊢ ∀s1 s2.
          parent_inclusive s1 ∧ parent_inclusive s2 ⇒
          parent_inclusive (s1 ∪ s2)
   
   [<a name="path_index_in_paths-val"><b>path_index_in_paths</b></a>]  Theorem
      
      ⊢ ∀s i. FINITE s ∧ i &lt; CARD s ⇒ path_index s i ∈ s
   
   [<a name="path_index_thm-val"><b>path_index_thm</b></a>]  Theorem
      
      ⊢ ∀s n.
          s HAS_SIZE n ⇒
          BIJ (path_index s) (count n) s ∧
          ∀j k.
            j &lt; n ∧ k &lt; n ⇒
            (ltree_path_lt (path_index s j) (path_index s k) ⇔ j &lt; k)
   
   [<a name="rose_children_to_rose-val"><b>rose_children_to_rose</b></a>]  Theorem
      
      ⊢ ∀t. ltree_finite t ⇒
            rose_children (to_rose t) =
            MAP to_rose (THE (toList (ltree_children t)))
   
   [<a name="rose_children_to_rose'-val"><b>rose_children_to_rose'</b></a>]  Theorem
      
      ⊢ ∀t. ltree_finite t ⇒
            rose_children (to_rose t) =
            THE (toList (LMAP to_rose (ltree_children t)))
   
   [<a name="rose_node_to_rose-val"><b>rose_node_to_rose</b></a>]  Theorem
      
      ⊢ ∀t. ltree_finite t ⇒ rose_node (to_rose t) = ltree_node t
   
   [<a name="rose_reduce-val"><b>rose_reduce</b></a>]  Theorem
      
      ⊢ ∀f t.
          rose_reduce f t =
          f (rose_node t) (MAP (rose_reduce f) (rose_children t))
   
   [<a name="rose_reduce_def-val"><b>rose_reduce_def</b></a>]  Theorem
      
      ⊢ ∀f a ts. rose_reduce f (Rose a ts) = f a (MAP (rose_reduce f) ts)
   
   [<a name="rose_reduce_ind-val"><b>rose_reduce_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀f a ts. (∀a'. MEM a' ts ⇒ P f a') ⇒ P f (Rose a ts)) ⇒
            ∀v v1. P v v1
   
   [<a name="rose_tree_11-val"><b>rose_tree_11</b></a>]  Theorem
      
      ⊢ ∀a0 a1 a0' a1'. Rose a0 a1 = Rose a0' a1' ⇔ a0 = a0' ∧ a1 = a1'
   
   [<a name="rose_tree_Axiom-val"><b>rose_tree_Axiom</b></a>]  Theorem
      
      ⊢ ∀f0 f1 f2. ∃fn0 fn1.
          (∀a0 a1. fn0 (Rose a0 a1) = f0 a0 a1 (fn1 a1)) ∧ fn1 [] = f1 ∧
          ∀a0 a1. fn1 (a0::a1) = f2 a0 a1 (fn0 a0) (fn1 a1)
   
   [<a name="rose_tree_case_cong-val"><b>rose_tree_case_cong</b></a>]  Theorem
      
      ⊢ ∀M M' f.
          M = M' ∧ (∀a0 a1. M' = Rose a0 a1 ⇒ f a0 a1 = f' a0 a1) ⇒
          rose_tree_CASE M f = rose_tree_CASE M' f'
   
   [<a name="rose_tree_case_eq-val"><b>rose_tree_case_eq</b></a>]  Theorem
      
      ⊢ rose_tree_CASE x f = v ⇔ ∃a l. x = Rose a l ∧ f a l = v
   
   [<a name="rose_tree_induction-val"><b>rose_tree_induction</b></a>]  Theorem
      
      ⊢ ∀P. (∀a ts. (∀a'. MEM a' ts ⇒ P a') ⇒ P (Rose a ts)) ⇒ ∀v. P v
   
   [<a name="rose_tree_nchotomy-val"><b>rose_tree_nchotomy</b></a>]  Theorem
      
      ⊢ ∀rr. ∃a l. rr = Rose a l
   
   [<a name="sibling_inclusive_ltree_paths-val"><b>sibling_inclusive_ltree_paths</b></a>]  Theorem
      
      ⊢ ∀t. sibling_inclusive (ltree_paths t)
   
   [<a name="sibling_inclusive_union-val"><b>sibling_inclusive_union</b></a>]  Theorem
      
      ⊢ ∀s1 s2.
          sibling_inclusive s1 ∧ sibling_inclusive s2 ⇒
          sibling_inclusive (s1 ∪ s2)
   
   [<a name="subtrees-val"><b>subtrees</b></a>]  Theorem
      
      ⊢ subtrees (Branch a ts) =
        Branch a ts INSERT BIGUNION (IMAGE subtrees (LSET ts))
   
   [<a name="to_rose_thm-val"><b>to_rose_thm</b></a>]  Theorem
      
      ⊢ ∀r. to_rose (from_rose r) = r
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/coalgebras/.hol/objs/ltreeScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-2</a></em></p></body></html>
