<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure monoidTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure monoidTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/algebra/construction/.hol/objs/monoidScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature monoidTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#AbelianMonoid_def-val">AbelianMonoid_def</a> : thm
<a name="line7"></a>    val <a href="#FiniteAbelianMonoid_def-val">FiniteAbelianMonoid_def</a> : thm
<a name="line8"></a>    val <a href="#FiniteMonoid_def-val">FiniteMonoid_def</a> : thm
<a name="line9"></a>    val <a href="#GPROD_SET_def-val">GPROD_SET_def</a> : thm
<a name="line10"></a>    val <a href="#Invertibles_def-val">Invertibles_def</a> : thm
<a name="line11"></a>    val <a href="#MonoidAuto_def-val">MonoidAuto_def</a> : thm
<a name="line12"></a>    val <a href="#MonoidEndo_def-val">MonoidEndo_def</a> : thm
<a name="line13"></a>    val <a href="#MonoidHomo_def-val">MonoidHomo_def</a> : thm
<a name="line14"></a>    val <a href="#MonoidIso_def-val">MonoidIso_def</a> : thm
<a name="line15"></a>    val <a href="#Monoid_def-val">Monoid_def</a> : thm
<a name="line16"></a>    val <a href="#Submonoid_def-val">Submonoid_def</a> : thm
<a name="line17"></a>    val <a href="#WeakHomo_def-val">WeakHomo_def</a> : thm
<a name="line18"></a>    val <a href="#WeakIso_def-val">WeakIso_def</a> : thm
<a name="line19"></a>    val <a href="#addition_monoid_def-val">addition_monoid_def</a> : thm
<a name="line20"></a>    val <a href="#extend_def-val">extend_def</a> : thm
<a name="line21"></a>    val <a href="#homo_monoid_def-val">homo_monoid_def</a> : thm
<a name="line22"></a>    val <a href="#image_op_def-val">image_op_def</a> : thm
<a name="line23"></a>    val <a href="#lists_def-val">lists_def</a> : thm
<a name="line24"></a>    val <a href="#monoid_TY_DEF-val">monoid_TY_DEF</a> : thm
<a name="line25"></a>    val <a href="#monoid_case_def-val">monoid_case_def</a> : thm
<a name="line26"></a>    val <a href="#monoid_exp_def-val">monoid_exp_def</a> : thm
<a name="line27"></a>    val <a href="#monoid_inj_image_def-val">monoid_inj_image_def</a> : thm
<a name="line28"></a>    val <a href="#monoid_intersect_def-val">monoid_intersect_def</a> : thm
<a name="line29"></a>    val <a href="#monoid_inv_def-val">monoid_inv_def</a> : thm
<a name="line30"></a>    val <a href="#monoid_invertibles_def-val">monoid_invertibles_def</a> : thm
<a name="line31"></a>    val <a href="#monoid_size_def-val">monoid_size_def</a> : thm
<a name="line32"></a>    val <a href="#multiplication_monoid_def-val">multiplication_monoid_def</a> : thm
<a name="line33"></a>    val <a href="#order_def-val">order_def</a> : thm
<a name="line34"></a>    val <a href="#orders_def-val">orders_def</a> : thm
<a name="line35"></a>    val <a href="#period_def-val">period_def</a> : thm
<a name="line36"></a>    val <a href="#plus_mod_def-val">plus_mod_def</a> : thm
<a name="line37"></a>    val <a href="#power_monoid_def-val">power_monoid_def</a> : thm
<a name="line38"></a>    val <a href="#recordtype_monoid_seldef_carrier_def-val">recordtype_monoid_seldef_carrier_def</a> : thm
<a name="line39"></a>    val <a href="#recordtype_monoid_seldef_carrier_fupd_def-val">recordtype_monoid_seldef_carrier_fupd_def</a> : thm
<a name="line40"></a>    val <a href="#recordtype_monoid_seldef_id_def-val">recordtype_monoid_seldef_id_def</a> : thm
<a name="line41"></a>    val <a href="#recordtype_monoid_seldef_id_fupd_def-val">recordtype_monoid_seldef_id_fupd_def</a> : thm
<a name="line42"></a>    val <a href="#recordtype_monoid_seldef_op_def-val">recordtype_monoid_seldef_op_def</a> : thm
<a name="line43"></a>    val <a href="#recordtype_monoid_seldef_op_fupd_def-val">recordtype_monoid_seldef_op_fupd_def</a> : thm
<a name="line44"></a>    val <a href="#set_inter_def-val">set_inter_def</a> : thm
<a name="line45"></a>    val <a href="#set_union_def-val">set_union_def</a> : thm
<a name="line46"></a>    val <a href="#submonoid_big_intersect_def-val">submonoid_big_intersect_def</a> : thm
<a name="line47"></a>    val <a href="#submonoid_def-val">submonoid_def</a> : thm
<a name="line48"></a>    val <a href="#times_mod_def-val">times_mod_def</a> : thm
<a name="line49"></a>    val <a href="#trivial_monoid_def-val">trivial_monoid_def</a> : thm
<a name="line50"></a>  
<a name="line51"></a>  (*  Theorems  *)
<a name="line52"></a>    val <a href="#COMMUTING_GITBAG_INSERT-val">COMMUTING_GITBAG_INSERT</a> : thm
<a name="line53"></a>    val <a href="#COMMUTING_GITSET_INSERT-val">COMMUTING_GITSET_INSERT</a> : thm
<a name="line54"></a>    val <a href="#COMMUTING_GITSET_RECURSES-val">COMMUTING_GITSET_RECURSES</a> : thm
<a name="line55"></a>    val <a href="#COMMUTING_GITSET_REDUCTION-val">COMMUTING_GITSET_REDUCTION</a> : thm
<a name="line56"></a>    val <a href="#EXISTS_monoid-val">EXISTS_monoid</a> : thm
<a name="line57"></a>    val <a href="#FORALL_monoid-val">FORALL_monoid</a> : thm
<a name="line58"></a>    val <a href="#FiniteAbelianMonoid_def_alt-val">FiniteAbelianMonoid_def_alt</a> : thm
<a name="line59"></a>    val <a href="#GBAG_IMAGE_FILTER-val">GBAG_IMAGE_FILTER</a> : thm
<a name="line60"></a>    val <a href="#GBAG_IMAGE_PARTITION-val">GBAG_IMAGE_PARTITION</a> : thm
<a name="line61"></a>    val <a href="#GBAG_INSERT-val">GBAG_INSERT</a> : thm
<a name="line62"></a>    val <a href="#GBAG_PARTITION-val">GBAG_PARTITION</a> : thm
<a name="line63"></a>    val <a href="#GBAG_UNION-val">GBAG_UNION</a> : thm
<a name="line64"></a>    val <a href="#GBAG_in_carrier-val">GBAG_in_carrier</a> : thm
<a name="line65"></a>    val <a href="#GITBAG_BAG_IMAGE_op-val">GITBAG_BAG_IMAGE_op</a> : thm
<a name="line66"></a>    val <a href="#GITBAG_CONG-val">GITBAG_CONG</a> : thm
<a name="line67"></a>    val <a href="#GITBAG_EMPTY-val">GITBAG_EMPTY</a> : thm
<a name="line68"></a>    val <a href="#GITBAG_GBAG-val">GITBAG_GBAG</a> : thm
<a name="line69"></a>    val <a href="#GITBAG_INSERT-val">GITBAG_INSERT</a> : thm
<a name="line70"></a>    val <a href="#GITBAG_INSERT_THM-val">GITBAG_INSERT_THM</a> : thm
<a name="line71"></a>    val <a href="#GITBAG_THM-val">GITBAG_THM</a> : thm
<a name="line72"></a>    val <a href="#GITBAG_UNION-val">GITBAG_UNION</a> : thm
<a name="line73"></a>    val <a href="#GITBAG_in_carrier-val">GITBAG_in_carrier</a> : thm
<a name="line74"></a>    val <a href="#GITBAG_same_op-val">GITBAG_same_op</a> : thm
<a name="line75"></a>    val <a href="#GITSET_EMPTY-val">GITSET_EMPTY</a> : thm
<a name="line76"></a>    val <a href="#GITSET_INSERT-val">GITSET_INSERT</a> : thm
<a name="line77"></a>    val <a href="#GITSET_PROPERTY-val">GITSET_PROPERTY</a> : thm
<a name="line78"></a>    val <a href="#GITSET_THM-val">GITSET_THM</a> : thm
<a name="line79"></a>    val <a href="#GPROD_SET_EMPTY-val">GPROD_SET_EMPTY</a> : thm
<a name="line80"></a>    val <a href="#GPROD_SET_PROPERTY-val">GPROD_SET_PROPERTY</a> : thm
<a name="line81"></a>    val <a href="#GPROD_SET_SING-val">GPROD_SET_SING</a> : thm
<a name="line82"></a>    val <a href="#GPROD_SET_THM-val">GPROD_SET_THM</a> : thm
<a name="line83"></a>    val <a href="#IMP_GBAG_EQ_EXP-val">IMP_GBAG_EQ_EXP</a> : thm
<a name="line84"></a>    val <a href="#IMP_GBAG_EQ_ID-val">IMP_GBAG_EQ_ID</a> : thm
<a name="line85"></a>    val <a href="#Invertibles_carrier-val">Invertibles_carrier</a> : thm
<a name="line86"></a>    val <a href="#Invertibles_order-val">Invertibles_order</a> : thm
<a name="line87"></a>    val <a href="#Invertibles_property-val">Invertibles_property</a> : thm
<a name="line88"></a>    val <a href="#Invertibles_subset-val">Invertibles_subset</a> : thm
<a name="line89"></a>    val <a href="#MonoidHomo_GBAG-val">MonoidHomo_GBAG</a> : thm
<a name="line90"></a>    val <a href="#SUBSET_COMMUTING_ITBAG_INSERT-val">SUBSET_COMMUTING_ITBAG_INSERT</a> : thm
<a name="line91"></a>    val <a href="#abelian_monoid_op_closure_comm_assoc_fun-val">abelian_monoid_op_closure_comm_assoc_fun</a> : thm
<a name="line92"></a>    val <a href="#abelian_monoid_order_common-val">abelian_monoid_order_common</a> : thm
<a name="line93"></a>    val <a href="#abelian_monoid_order_common_coprime-val">abelian_monoid_order_common_coprime</a> : thm
<a name="line94"></a>    val <a href="#abelian_monoid_order_lcm-val">abelian_monoid_order_lcm</a> : thm
<a name="line95"></a>    val <a href="#addition_monoid_abelian_monoid-val">addition_monoid_abelian_monoid</a> : thm
<a name="line96"></a>    val <a href="#addition_monoid_monoid-val">addition_monoid_monoid</a> : thm
<a name="line97"></a>    val <a href="#addition_monoid_property-val">addition_monoid_property</a> : thm
<a name="line98"></a>    val <a href="#datatype_monoid-val">datatype_monoid</a> : thm
<a name="line99"></a>    val <a href="#extend_carrier-val">extend_carrier</a> : thm
<a name="line100"></a>    val <a href="#extend_id-val">extend_id</a> : thm
<a name="line101"></a>    val <a href="#extend_is_monoid-val">extend_is_monoid</a> : thm
<a name="line102"></a>    val <a href="#extend_op-val">extend_op</a> : thm
<a name="line103"></a>    val <a href="#finite_monoid_exp_not_distinct-val">finite_monoid_exp_not_distinct</a> : thm
<a name="line104"></a>    val <a href="#homo_monoid_I-val">homo_monoid_I</a> : thm
<a name="line105"></a>    val <a href="#homo_monoid_abelian_monoid-val">homo_monoid_abelian_monoid</a> : thm
<a name="line106"></a>    val <a href="#homo_monoid_assoc-val">homo_monoid_assoc</a> : thm
<a name="line107"></a>    val <a href="#homo_monoid_by_inj-val">homo_monoid_by_inj</a> : thm
<a name="line108"></a>    val <a href="#homo_monoid_closure-val">homo_monoid_closure</a> : thm
<a name="line109"></a>    val <a href="#homo_monoid_comm-val">homo_monoid_comm</a> : thm
<a name="line110"></a>    val <a href="#homo_monoid_element-val">homo_monoid_element</a> : thm
<a name="line111"></a>    val <a href="#homo_monoid_id-val">homo_monoid_id</a> : thm
<a name="line112"></a>    val <a href="#homo_monoid_id_property-val">homo_monoid_id_property</a> : thm
<a name="line113"></a>    val <a href="#homo_monoid_monoid-val">homo_monoid_monoid</a> : thm
<a name="line114"></a>    val <a href="#homo_monoid_op_inj-val">homo_monoid_op_inj</a> : thm
<a name="line115"></a>    val <a href="#homo_monoid_property-val">homo_monoid_property</a> : thm
<a name="line116"></a>    val <a href="#image_op_inj-val">image_op_inj</a> : thm
<a name="line117"></a>    val <a href="#lists_monoid-val">lists_monoid</a> : thm
<a name="line118"></a>    val <a href="#maximal_order_alt-val">maximal_order_alt</a> : thm
<a name="line119"></a>    val <a href="#monoid_11-val">monoid_11</a> : thm
<a name="line120"></a>    val <a href="#monoid_Axiom-val">monoid_Axiom</a> : thm
<a name="line121"></a>    val <a href="#monoid_accessors-val">monoid_accessors</a> : thm
<a name="line122"></a>    val <a href="#monoid_accfupds-val">monoid_accfupds</a> : thm
<a name="line123"></a>    val <a href="#monoid_assoc-val">monoid_assoc</a> : thm
<a name="line124"></a>    val <a href="#monoid_auto_I-val">monoid_auto_I</a> : thm
<a name="line125"></a>    val <a href="#monoid_auto_bij-val">monoid_auto_bij</a> : thm
<a name="line126"></a>    val <a href="#monoid_auto_compose-val">monoid_auto_compose</a> : thm
<a name="line127"></a>    val <a href="#monoid_auto_element-val">monoid_auto_element</a> : thm
<a name="line128"></a>    val <a href="#monoid_auto_exp-val">monoid_auto_exp</a> : thm
<a name="line129"></a>    val <a href="#monoid_auto_id-val">monoid_auto_id</a> : thm
<a name="line130"></a>    val <a href="#monoid_auto_linv_auto-val">monoid_auto_linv_auto</a> : thm
<a name="line131"></a>    val <a href="#monoid_auto_order-val">monoid_auto_order</a> : thm
<a name="line132"></a>    val <a href="#monoid_carrier_nonempty-val">monoid_carrier_nonempty</a> : thm
<a name="line133"></a>    val <a href="#monoid_case_cong-val">monoid_case_cong</a> : thm
<a name="line134"></a>    val <a href="#monoid_case_eq-val">monoid_case_eq</a> : thm
<a name="line135"></a>    val <a href="#monoid_comm_exp-val">monoid_comm_exp</a> : thm
<a name="line136"></a>    val <a href="#monoid_comm_exp_exp-val">monoid_comm_exp_exp</a> : thm
<a name="line137"></a>    val <a href="#monoid_comm_op_exp-val">monoid_comm_op_exp</a> : thm
<a name="line138"></a>    val <a href="#monoid_component_equality-val">monoid_component_equality</a> : thm
<a name="line139"></a>    val <a href="#monoid_exp_0-val">monoid_exp_0</a> : thm
<a name="line140"></a>    val <a href="#monoid_exp_1-val">monoid_exp_1</a> : thm
<a name="line141"></a>    val <a href="#monoid_exp_SUC-val">monoid_exp_SUC</a> : thm
<a name="line142"></a>    val <a href="#monoid_exp_add-val">monoid_exp_add</a> : thm
<a name="line143"></a>    val <a href="#monoid_exp_comm-val">monoid_exp_comm</a> : thm
<a name="line144"></a>    val <a href="#monoid_exp_element-val">monoid_exp_element</a> : thm
<a name="line145"></a>    val <a href="#monoid_exp_mod_order-val">monoid_exp_mod_order</a> : thm
<a name="line146"></a>    val <a href="#monoid_exp_mult-val">monoid_exp_mult</a> : thm
<a name="line147"></a>    val <a href="#monoid_exp_mult_comm-val">monoid_exp_mult_comm</a> : thm
<a name="line148"></a>    val <a href="#monoid_exp_suc-val">monoid_exp_suc</a> : thm
<a name="line149"></a>    val <a href="#monoid_fn_updates-val">monoid_fn_updates</a> : thm
<a name="line150"></a>    val <a href="#monoid_fupdcanon-val">monoid_fupdcanon</a> : thm
<a name="line151"></a>    val <a href="#monoid_fupdcanon_comp-val">monoid_fupdcanon_comp</a> : thm
<a name="line152"></a>    val <a href="#monoid_fupdfupds-val">monoid_fupdfupds</a> : thm
<a name="line153"></a>    val <a href="#monoid_fupdfupds_comp-val">monoid_fupdfupds_comp</a> : thm
<a name="line154"></a>    val <a href="#monoid_homo_I_refl-val">monoid_homo_I_refl</a> : thm
<a name="line155"></a>    val <a href="#monoid_homo_compose-val">monoid_homo_compose</a> : thm
<a name="line156"></a>    val <a href="#monoid_homo_cong-val">monoid_homo_cong</a> : thm
<a name="line157"></a>    val <a href="#monoid_homo_element-val">monoid_homo_element</a> : thm
<a name="line158"></a>    val <a href="#monoid_homo_exp-val">monoid_homo_exp</a> : thm
<a name="line159"></a>    val <a href="#monoid_homo_id-val">monoid_homo_id</a> : thm
<a name="line160"></a>    val <a href="#monoid_homo_sym-val">monoid_homo_sym</a> : thm
<a name="line161"></a>    val <a href="#monoid_homo_sym_any-val">monoid_homo_sym_any</a> : thm
<a name="line162"></a>    val <a href="#monoid_homo_trans-val">monoid_homo_trans</a> : thm
<a name="line163"></a>    val <a href="#monoid_id-val">monoid_id</a> : thm
<a name="line164"></a>    val <a href="#monoid_id_element-val">monoid_id_element</a> : thm
<a name="line165"></a>    val <a href="#monoid_id_exp-val">monoid_id_exp</a> : thm
<a name="line166"></a>    val <a href="#monoid_id_id-val">monoid_id_id</a> : thm
<a name="line167"></a>    val <a href="#monoid_id_invertible-val">monoid_id_invertible</a> : thm
<a name="line168"></a>    val <a href="#monoid_id_unique-val">monoid_id_unique</a> : thm
<a name="line169"></a>    val <a href="#monoid_induction-val">monoid_induction</a> : thm
<a name="line170"></a>    val <a href="#monoid_inj_image_abelian_monoid-val">monoid_inj_image_abelian_monoid</a> : thm
<a name="line171"></a>    val <a href="#monoid_inj_image_monoid-val">monoid_inj_image_monoid</a> : thm
<a name="line172"></a>    val <a href="#monoid_inj_image_monoid_homo-val">monoid_inj_image_monoid_homo</a> : thm
<a name="line173"></a>    val <a href="#monoid_intersect_element-val">monoid_intersect_element</a> : thm
<a name="line174"></a>    val <a href="#monoid_intersect_id-val">monoid_intersect_id</a> : thm
<a name="line175"></a>    val <a href="#monoid_intersect_property-val">monoid_intersect_property</a> : thm
<a name="line176"></a>    val <a href="#monoid_inv_def_alt-val">monoid_inv_def_alt</a> : thm
<a name="line177"></a>    val <a href="#monoid_inv_element-val">monoid_inv_element</a> : thm
<a name="line178"></a>    val <a href="#monoid_inv_from_invertibles-val">monoid_inv_from_invertibles</a> : thm
<a name="line179"></a>    val <a href="#monoid_inv_invertible-val">monoid_inv_invertible</a> : thm
<a name="line180"></a>    val <a href="#monoid_inv_op_invertible-val">monoid_inv_op_invertible</a> : thm
<a name="line181"></a>    val <a href="#monoid_invertibles_element-val">monoid_invertibles_element</a> : thm
<a name="line182"></a>    val <a href="#monoid_invertibles_is_monoid-val">monoid_invertibles_is_monoid</a> : thm
<a name="line183"></a>    val <a href="#monoid_iso_I_refl-val">monoid_iso_I_refl</a> : thm
<a name="line184"></a>    val <a href="#monoid_iso_bij-val">monoid_iso_bij</a> : thm
<a name="line185"></a>    val <a href="#monoid_iso_card_eq-val">monoid_iso_card_eq</a> : thm
<a name="line186"></a>    val <a href="#monoid_iso_compose-val">monoid_iso_compose</a> : thm
<a name="line187"></a>    val <a href="#monoid_iso_element-val">monoid_iso_element</a> : thm
<a name="line188"></a>    val <a href="#monoid_iso_eq_id-val">monoid_iso_eq_id</a> : thm
<a name="line189"></a>    val <a href="#monoid_iso_exp-val">monoid_iso_exp</a> : thm
<a name="line190"></a>    val <a href="#monoid_iso_id-val">monoid_iso_id</a> : thm
<a name="line191"></a>    val <a href="#monoid_iso_linv_iso-val">monoid_iso_linv_iso</a> : thm
<a name="line192"></a>    val <a href="#monoid_iso_monoid-val">monoid_iso_monoid</a> : thm
<a name="line193"></a>    val <a href="#monoid_iso_order-val">monoid_iso_order</a> : thm
<a name="line194"></a>    val <a href="#monoid_iso_property-val">monoid_iso_property</a> : thm
<a name="line195"></a>    val <a href="#monoid_iso_sym-val">monoid_iso_sym</a> : thm
<a name="line196"></a>    val <a href="#monoid_iso_trans-val">monoid_iso_trans</a> : thm
<a name="line197"></a>    val <a href="#monoid_lid-val">monoid_lid</a> : thm
<a name="line198"></a>    val <a href="#monoid_lid_unique-val">monoid_lid_unique</a> : thm
<a name="line199"></a>    val <a href="#monoid_literal_11-val">monoid_literal_11</a> : thm
<a name="line200"></a>    val <a href="#monoid_literal_nchotomy-val">monoid_literal_nchotomy</a> : thm
<a name="line201"></a>    val <a href="#monoid_nchotomy-val">monoid_nchotomy</a> : thm
<a name="line202"></a>    val <a href="#monoid_op_element-val">monoid_op_element</a> : thm
<a name="line203"></a>    val <a href="#monoid_order_cofactor-val">monoid_order_cofactor</a> : thm
<a name="line204"></a>    val <a href="#monoid_order_common-val">monoid_order_common</a> : thm
<a name="line205"></a>    val <a href="#monoid_order_common_coprime-val">monoid_order_common_coprime</a> : thm
<a name="line206"></a>    val <a href="#monoid_order_condition-val">monoid_order_condition</a> : thm
<a name="line207"></a>    val <a href="#monoid_order_divides_exp-val">monoid_order_divides_exp</a> : thm
<a name="line208"></a>    val <a href="#monoid_order_divides_maximal-val">monoid_order_divides_maximal</a> : thm
<a name="line209"></a>    val <a href="#monoid_order_divisor-val">monoid_order_divisor</a> : thm
<a name="line210"></a>    val <a href="#monoid_order_eq_1-val">monoid_order_eq_1</a> : thm
<a name="line211"></a>    val <a href="#monoid_order_id-val">monoid_order_id</a> : thm
<a name="line212"></a>    val <a href="#monoid_order_nonzero-val">monoid_order_nonzero</a> : thm
<a name="line213"></a>    val <a href="#monoid_order_power-val">monoid_order_power</a> : thm
<a name="line214"></a>    val <a href="#monoid_order_power_coprime-val">monoid_order_power_coprime</a> : thm
<a name="line215"></a>    val <a href="#monoid_order_power_eq_0-val">monoid_order_power_eq_0</a> : thm
<a name="line216"></a>    val <a href="#monoid_order_power_eqn-val">monoid_order_power_eqn</a> : thm
<a name="line217"></a>    val <a href="#monoid_rid-val">monoid_rid</a> : thm
<a name="line218"></a>    val <a href="#monoid_rid_unique-val">monoid_rid_unique</a> : thm
<a name="line219"></a>    val <a href="#monoid_updates_eq_literal-val">monoid_updates_eq_literal</a> : thm
<a name="line220"></a>    val <a href="#monoid_weak_iso_id-val">monoid_weak_iso_id</a> : thm
<a name="line221"></a>    val <a href="#multiplication_monoid_abelian_monoid-val">multiplication_monoid_abelian_monoid</a> : thm
<a name="line222"></a>    val <a href="#multiplication_monoid_monoid-val">multiplication_monoid_monoid</a> : thm
<a name="line223"></a>    val <a href="#multiplication_monoid_property-val">multiplication_monoid_property</a> : thm
<a name="line224"></a>    val <a href="#order_alt-val">order_alt</a> : thm
<a name="line225"></a>    val <a href="#order_eq_0-val">order_eq_0</a> : thm
<a name="line226"></a>    val <a href="#order_minimal-val">order_minimal</a> : thm
<a name="line227"></a>    val <a href="#order_period-val">order_period</a> : thm
<a name="line228"></a>    val <a href="#order_property-val">order_property</a> : thm
<a name="line229"></a>    val <a href="#order_thm-val">order_thm</a> : thm
<a name="line230"></a>    val <a href="#orders_element-val">orders_element</a> : thm
<a name="line231"></a>    val <a href="#orders_eq_1-val">orders_eq_1</a> : thm
<a name="line232"></a>    val <a href="#orders_finite-val">orders_finite</a> : thm
<a name="line233"></a>    val <a href="#orders_subset-val">orders_subset</a> : thm
<a name="line234"></a>    val <a href="#plus_mod_abelian_monoid-val">plus_mod_abelian_monoid</a> : thm
<a name="line235"></a>    val <a href="#plus_mod_exp-val">plus_mod_exp</a> : thm
<a name="line236"></a>    val <a href="#plus_mod_finite-val">plus_mod_finite</a> : thm
<a name="line237"></a>    val <a href="#plus_mod_finite_abelian_monoid-val">plus_mod_finite_abelian_monoid</a> : thm
<a name="line238"></a>    val <a href="#plus_mod_finite_monoid-val">plus_mod_finite_monoid</a> : thm
<a name="line239"></a>    val <a href="#plus_mod_monoid-val">plus_mod_monoid</a> : thm
<a name="line240"></a>    val <a href="#plus_mod_property-val">plus_mod_property</a> : thm
<a name="line241"></a>    val <a href="#power_monoid_abelian_monoid-val">power_monoid_abelian_monoid</a> : thm
<a name="line242"></a>    val <a href="#power_monoid_monoid-val">power_monoid_monoid</a> : thm
<a name="line243"></a>    val <a href="#power_monoid_property-val">power_monoid_property</a> : thm
<a name="line244"></a>    val <a href="#power_to_addition_homo-val">power_to_addition_homo</a> : thm
<a name="line245"></a>    val <a href="#power_to_addition_iso-val">power_to_addition_iso</a> : thm
<a name="line246"></a>    val <a href="#set_inter_abelian_monoid-val">set_inter_abelian_monoid</a> : thm
<a name="line247"></a>    val <a href="#set_inter_monoid-val">set_inter_monoid</a> : thm
<a name="line248"></a>    val <a href="#set_union_abelian_monoid-val">set_union_abelian_monoid</a> : thm
<a name="line249"></a>    val <a href="#set_union_monoid-val">set_union_monoid</a> : thm
<a name="line250"></a>    val <a href="#submonoid_I_antisym-val">submonoid_I_antisym</a> : thm
<a name="line251"></a>    val <a href="#submonoid_alt-val">submonoid_alt</a> : thm
<a name="line252"></a>    val <a href="#submonoid_antisymmetric-val">submonoid_antisymmetric</a> : thm
<a name="line253"></a>    val <a href="#submonoid_big_intersect_element-val">submonoid_big_intersect_element</a> : thm
<a name="line254"></a>    val <a href="#submonoid_big_intersect_has_id-val">submonoid_big_intersect_has_id</a> : thm
<a name="line255"></a>    val <a href="#submonoid_big_intersect_monoid-val">submonoid_big_intersect_monoid</a> : thm
<a name="line256"></a>    val <a href="#submonoid_big_intersect_op_element-val">submonoid_big_intersect_op_element</a> : thm
<a name="line257"></a>    val <a href="#submonoid_big_intersect_property-val">submonoid_big_intersect_property</a> : thm
<a name="line258"></a>    val <a href="#submonoid_big_intersect_submonoid-val">submonoid_big_intersect_submonoid</a> : thm
<a name="line259"></a>    val <a href="#submonoid_big_intersect_subset-val">submonoid_big_intersect_subset</a> : thm
<a name="line260"></a>    val <a href="#submonoid_carrier_antisym-val">submonoid_carrier_antisym</a> : thm
<a name="line261"></a>    val <a href="#submonoid_carrier_subset-val">submonoid_carrier_subset</a> : thm
<a name="line262"></a>    val <a href="#submonoid_element-val">submonoid_element</a> : thm
<a name="line263"></a>    val <a href="#submonoid_eqn-val">submonoid_eqn</a> : thm
<a name="line264"></a>    val <a href="#submonoid_exp-val">submonoid_exp</a> : thm
<a name="line265"></a>    val <a href="#submonoid_homo_homo-val">submonoid_homo_homo</a> : thm
<a name="line266"></a>    val <a href="#submonoid_homomorphism-val">submonoid_homomorphism</a> : thm
<a name="line267"></a>    val <a href="#submonoid_id-val">submonoid_id</a> : thm
<a name="line268"></a>    val <a href="#submonoid_intersect_monoid-val">submonoid_intersect_monoid</a> : thm
<a name="line269"></a>    val <a href="#submonoid_intersect_property-val">submonoid_intersect_property</a> : thm
<a name="line270"></a>    val <a href="#submonoid_intersect_submonoid-val">submonoid_intersect_submonoid</a> : thm
<a name="line271"></a>    val <a href="#submonoid_monoid-val">submonoid_monoid</a> : thm
<a name="line272"></a>    val <a href="#submonoid_op-val">submonoid_op</a> : thm
<a name="line273"></a>    val <a href="#submonoid_order-val">submonoid_order</a> : thm
<a name="line274"></a>    val <a href="#submonoid_order_eqn-val">submonoid_order_eqn</a> : thm
<a name="line275"></a>    val <a href="#submonoid_property-val">submonoid_property</a> : thm
<a name="line276"></a>    val <a href="#submonoid_refl-val">submonoid_refl</a> : thm
<a name="line277"></a>    val <a href="#submonoid_reflexive-val">submonoid_reflexive</a> : thm
<a name="line278"></a>    val <a href="#submonoid_subset-val">submonoid_subset</a> : thm
<a name="line279"></a>    val <a href="#submonoid_trans-val">submonoid_trans</a> : thm
<a name="line280"></a>    val <a href="#submonoid_transitive-val">submonoid_transitive</a> : thm
<a name="line281"></a>    val <a href="#times_mod_abelian_monoid-val">times_mod_abelian_monoid</a> : thm
<a name="line282"></a>    val <a href="#times_mod_eval-val">times_mod_eval</a> : thm
<a name="line283"></a>    val <a href="#times_mod_exp-val">times_mod_exp</a> : thm
<a name="line284"></a>    val <a href="#times_mod_finite-val">times_mod_finite</a> : thm
<a name="line285"></a>    val <a href="#times_mod_finite_abelian_monoid-val">times_mod_finite_abelian_monoid</a> : thm
<a name="line286"></a>    val <a href="#times_mod_finite_monoid-val">times_mod_finite_monoid</a> : thm
<a name="line287"></a>    val <a href="#times_mod_monoid-val">times_mod_monoid</a> : thm
<a name="line288"></a>    val <a href="#times_mod_property-val">times_mod_property</a> : thm
<a name="line289"></a>    val <a href="#trivial_monoid-val">trivial_monoid</a> : thm
<a name="line290"></a>(*
   [bag] Parent theory of "monoid"
   
   [prime] Parent theory of "monoid"
   
   [<a name="AbelianMonoid_def-val"><b>AbelianMonoid_def</b></a>]  Definition
      
      ⊢ ∀g. AbelianMonoid g ⇔
            Monoid g ∧ ∀x y. x ∈ G ∧ y ∈ G ⇒ x * y = y * x
   
   [<a name="FiniteAbelianMonoid_def-val"><b>FiniteAbelianMonoid_def</b></a>]  Definition
      
      ⊢ ∀g. FiniteAbelianMonoid g ⇔ AbelianMonoid g ∧ FINITE G
   
   [<a name="FiniteMonoid_def-val"><b>FiniteMonoid_def</b></a>]  Definition
      
      ⊢ ∀g. FiniteMonoid g ⇔ Monoid g ∧ FINITE G
   
   [<a name="GPROD_SET_def-val"><b>GPROD_SET_def</b></a>]  Definition
      
      ⊢ ∀g s. GPROD_SET g s = GITSET g s #e
   
   [<a name="Invertibles_def-val"><b>Invertibles_def</b></a>]  Definition
      
      ⊢ ∀g. Invertibles g = &lt;|carrier := G*; op := $*; id := #e|&gt;
   
   [<a name="MonoidAuto_def-val"><b>MonoidAuto_def</b></a>]  Definition
      
      ⊢ ∀f g. MonoidAuto f g ⇔ MonoidIso f g g
   
   [<a name="MonoidEndo_def-val"><b>MonoidEndo_def</b></a>]  Definition
      
      ⊢ ∀f g. MonoidEndo f g ⇔ MonoidHomo f g g
   
   [<a name="MonoidHomo_def-val"><b>MonoidHomo_def</b></a>]  Definition
      
      ⊢ ∀f g h.
          MonoidHomo f g h ⇔
          (∀x. x ∈ G ⇒ f x ∈ h.carrier) ∧
          (∀x y. x ∈ G ∧ y ∈ G ⇒ f (x * y) = h.op (f x) (f y)) ∧
          f #e = h.id
   
   [<a name="MonoidIso_def-val"><b>MonoidIso_def</b></a>]  Definition
      
      ⊢ ∀f g h. MonoidIso f g h ⇔ MonoidHomo f g h ∧ BIJ f G h.carrier
   
   [<a name="Monoid_def-val"><b>Monoid_def</b></a>]  Definition
      
      ⊢ ∀g. Monoid g ⇔
            (∀x y. x ∈ G ∧ y ∈ G ⇒ x * y ∈ G) ∧
            (∀x y z. x ∈ G ∧ y ∈ G ∧ z ∈ G ⇒ x * y * z = x * (y * z)) ∧
            #e ∈ G ∧ ∀x. x ∈ G ⇒ #e * x = x ∧ x * #e = x
   
   [<a name="Submonoid_def-val"><b>Submonoid_def</b></a>]  Definition
      
      ⊢ ∀h g. h &lt;&lt; g ⇔ Monoid h ∧ Monoid g ∧ H ⊆ G ∧ $o = $* ∧ #i = #e
   
   [<a name="WeakHomo_def-val"><b>WeakHomo_def</b></a>]  Definition
      
      ⊢ ∀f g h.
          WeakHomo f g h ⇔
          (∀x. x ∈ G ⇒ f x ∈ h.carrier) ∧
          ∀x y. x ∈ G ∧ y ∈ G ⇒ f (x * y) = h.op (f x) (f y)
   
   [<a name="WeakIso_def-val"><b>WeakIso_def</b></a>]  Definition
      
      ⊢ ∀f g h. WeakIso f g h ⇔ WeakHomo f g h ∧ BIJ f G h.carrier
   
   [<a name="addition_monoid_def-val"><b>addition_monoid_def</b></a>]  Definition
      
      ⊢ addition_monoid = &lt;|carrier := 𝕌(:num); op := $+; id := 0|&gt;
   
   [<a name="extend_def-val"><b>extend_def</b></a>]  Definition
      
      ⊢ ∀m. extend m =
            &lt;|carrier := 𝕌(:α); id := m.id;
              op :=
                (λx y.
                     if x ∈ m.carrier then
                       if y ∈ m.carrier then m.op x y else y
                     else x)|&gt;
   
   [<a name="homo_monoid_def-val"><b>homo_monoid_def</b></a>]  Definition
      
      ⊢ ∀g f.
          homo_monoid g f =
          &lt;|carrier := IMAGE f G; op := image_op g f; id := f #e|&gt;
   
   [<a name="image_op_def-val"><b>image_op_def</b></a>]  Definition
      
      ⊢ ∀g f x y.
          image_op g f x y =
          f (CHOICE (preimage f G x) * CHOICE (preimage f G y))
   
   [<a name="lists_def-val"><b>lists_def</b></a>]  Definition
      
      ⊢ lists = &lt;|carrier := 𝕌(:α list); id := []; op := $++ |&gt;
   
   [<a name="monoid_TY_DEF-val"><b>monoid_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep.
          TYPE_DEFINITION
            (λa0'.
                 ∀ $var$('monoid').
                   (∀a0'.
                      (∃a0 a1 a2.
                         a0' =
                         (λa0 a1 a2.
                              ind_type$CONSTR 0 (a0,a1,a2)
                                (λn. ind_type$BOTTOM)) a0 a1 a2) ⇒
                      $var$('monoid') a0') ⇒
                   $var$('monoid') a0') rep
   
   [<a name="monoid_case_def-val"><b>monoid_case_def</b></a>]  Definition
      
      ⊢ ∀a0 a1 a2 f. monoid_CASE (monoid a0 a1 a2) f = f a0 a1 a2
   
   [<a name="monoid_exp_def-val"><b>monoid_exp_def</b></a>]  Definition
      
      ⊢ ∀g x n. x ** n = FUNPOW ($* x) n #e
   
   [<a name="monoid_inj_image_def-val"><b>monoid_inj_image_def</b></a>]  Definition
      
      ⊢ ∀g f.
          monoid_inj_image g f =
          &lt;|carrier := IMAGE f G;
            op := (let t = LINV f G in λx y. f (t x * t y)); id := f #e|&gt;
   
   [<a name="monoid_intersect_def-val"><b>monoid_intersect_def</b></a>]  Definition
      
      ⊢ ∀g h. (g mINTER h) = &lt;|carrier := G ∩ H; op := $*; id := #e|&gt;
   
   [<a name="monoid_inv_def-val"><b>monoid_inv_def</b></a>]  Definition
      
      ⊢ ∀g x. Monoid g ∧ x ∈ G* ⇒ |/ x ∈ G ∧ x * |/ x = #e ∧ |/ x * x = #e
   
   [<a name="monoid_invertibles_def-val"><b>monoid_invertibles_def</b></a>]  Definition
      
      ⊢ ∀g. G* = {x | x ∈ G ∧ ∃y. y ∈ G ∧ x * y = #e ∧ y * x = #e}
   
   [<a name="monoid_size_def-val"><b>monoid_size_def</b></a>]  Definition
      
      ⊢ ∀f a0 a1 a2. monoid_size f (monoid a0 a1 a2) = 1 + f a2
   
   [<a name="multiplication_monoid_def-val"><b>multiplication_monoid_def</b></a>]  Definition
      
      ⊢ multiplication_monoid = &lt;|carrier := 𝕌(:num); op := $*; id := 1|&gt;
   
   [<a name="order_def-val"><b>order_def</b></a>]  Definition
      
      ⊢ ∀g x.
          ord x = case OLEAST k. period g x k of NONE =&gt; 0 | SOME k =&gt; k
   
   [<a name="orders_def-val"><b>orders_def</b></a>]  Definition
      
      ⊢ ∀g n. orders g n = {x | x ∈ G ∧ ord x = n}
   
   [<a name="period_def-val"><b>period_def</b></a>]  Definition
      
      ⊢ ∀g x k. period g x k ⇔ 0 &lt; k ∧ x ** k = #e
   
   [<a name="plus_mod_def-val"><b>plus_mod_def</b></a>]  Definition
      
      ⊢ ∀n. plus_mod n =
            &lt;|carrier := count n; id := 0; op := (λi j. (i + j) MOD n)|&gt;
   
   [<a name="power_monoid_def-val"><b>power_monoid_def</b></a>]  Definition
      
      ⊢ ∀b. power_monoid b =
            &lt;|carrier := {b ** j | j ∈ 𝕌(:num)}; op := $*; id := 1|&gt;
   
   [<a name="recordtype_monoid_seldef_carrier_def-val"><b>recordtype_monoid_seldef_carrier_def</b></a>]  Definition
      
      ⊢ ∀f f0 a. (monoid f f0 a).carrier = f
   
   [<a name="recordtype_monoid_seldef_carrier_fupd_def-val"><b>recordtype_monoid_seldef_carrier_fupd_def</b></a>]  Definition
      
      ⊢ ∀f1 f f0 a.
          monoid f f0 a with carrier updated_by f1 = monoid (f1 f) f0 a
   
   [<a name="recordtype_monoid_seldef_id_def-val"><b>recordtype_monoid_seldef_id_def</b></a>]  Definition
      
      ⊢ ∀f f0 a. (monoid f f0 a).id = a
   
   [<a name="recordtype_monoid_seldef_id_fupd_def-val"><b>recordtype_monoid_seldef_id_fupd_def</b></a>]  Definition
      
      ⊢ ∀f1 f f0 a.
          monoid f f0 a with id updated_by f1 = monoid f f0 (f1 a)
   
   [<a name="recordtype_monoid_seldef_op_def-val"><b>recordtype_monoid_seldef_op_def</b></a>]  Definition
      
      ⊢ ∀f f0 a. (monoid f f0 a).op = f0
   
   [<a name="recordtype_monoid_seldef_op_fupd_def-val"><b>recordtype_monoid_seldef_op_fupd_def</b></a>]  Definition
      
      ⊢ ∀f1 f f0 a.
          monoid f f0 a with op updated_by f1 = monoid f (f1 f0) a
   
   [<a name="set_inter_def-val"><b>set_inter_def</b></a>]  Definition
      
      ⊢ set_inter = &lt;|carrier := 𝕌(:α -&gt; bool); id := 𝕌(:α); op := $INTER|&gt;
   
   [<a name="set_union_def-val"><b>set_union_def</b></a>]  Definition
      
      ⊢ set_union = &lt;|carrier := 𝕌(:α -&gt; bool); id := ∅; op := $UNION|&gt;
   
   [<a name="submonoid_big_intersect_def-val"><b>submonoid_big_intersect_def</b></a>]  Definition
      
      ⊢ ∀g. smbINTER g =
            &lt;|carrier := BIGINTER (IMAGE (λh. H) {h | h &lt;&lt; g}); op := $*;
              id := #e|&gt;
   
   [<a name="submonoid_def-val"><b>submonoid_def</b></a>]  Definition
      
      ⊢ ∀h g. submonoid h g ⇔ MonoidHomo I h g
   
   [<a name="times_mod_def-val"><b>times_mod_def</b></a>]  Definition
      
      ⊢ ∀n. times_mod n =
            &lt;|carrier := count n; id := if n = 1 then 0 else 1;
              op := (λi j. (i * j) MOD n)|&gt;
   
   [<a name="trivial_monoid_def-val"><b>trivial_monoid_def</b></a>]  Definition
      
      ⊢ ∀e. trivial_monoid e = &lt;|carrier := {e}; id := e; op := (λx y. e)|&gt;
   
   [<a name="COMMUTING_GITBAG_INSERT-val"><b>COMMUTING_GITBAG_INSERT</b></a>]  Theorem
      
      ⊢ ∀g b.
          AbelianMonoid g ∧ FINITE_BAG b ∧ SET_OF_BAG b ⊆ G ⇒
          ∀x a::G. GITBAG g (BAG_INSERT x b) a = GITBAG g b (x * a)
   
   [<a name="COMMUTING_GITSET_INSERT-val"><b>COMMUTING_GITSET_INSERT</b></a>]  Theorem
      
      ⊢ ∀g s.
          AbelianMonoid g ∧ FINITE s ∧ s ⊆ G ⇒
          ∀b x::G. GITSET g (x INSERT s) b = GITSET g (s DELETE x) (x * b)
   
   [<a name="COMMUTING_GITSET_RECURSES-val"><b>COMMUTING_GITSET_RECURSES</b></a>]  Theorem
      
      ⊢ ∀g s.
          AbelianMonoid g ∧ FINITE s ∧ s ⊆ G ⇒
          ∀b x::G. GITSET g (x INSERT s) b = x * GITSET g (s DELETE x) b
   
   [<a name="COMMUTING_GITSET_REDUCTION-val"><b>COMMUTING_GITSET_REDUCTION</b></a>]  Theorem
      
      ⊢ ∀g s.
          AbelianMonoid g ∧ FINITE s ∧ s ⊆ G ⇒
          ∀b x::G. GITSET g s (x * b) = x * GITSET g s b
   
   [<a name="EXISTS_monoid-val"><b>EXISTS_monoid</b></a>]  Theorem
      
      ⊢ ∀P. (∃m. P m) ⇔ ∃f0 f a. P &lt;|carrier := f0; op := f; id := a|&gt;
   
   [<a name="FORALL_monoid-val"><b>FORALL_monoid</b></a>]  Theorem
      
      ⊢ ∀P. (∀m. P m) ⇔ ∀f0 f a. P &lt;|carrier := f0; op := f; id := a|&gt;
   
   [<a name="FiniteAbelianMonoid_def_alt-val"><b>FiniteAbelianMonoid_def_alt</b></a>]  Theorem
      
      ⊢ ∀g. FiniteAbelianMonoid g ⇔
            FiniteMonoid g ∧ ∀x y. x ∈ G ∧ y ∈ G ⇒ x * y = y * x
   
   [<a name="GBAG_IMAGE_FILTER-val"><b>GBAG_IMAGE_FILTER</b></a>]  Theorem
      
      ⊢ AbelianMonoid g ⇒
        ∀b. FINITE_BAG b ⇒
            IMAGE f (SET_OF_BAG b ∩ P) ⊆ G ⇒
            GBAG g (BAG_IMAGE f (BAG_FILTER P b)) =
            GBAG g (BAG_IMAGE (λx. if P x then f x else #e) b)
   
   [<a name="GBAG_IMAGE_PARTITION-val"><b>GBAG_IMAGE_PARTITION</b></a>]  Theorem
      
      ⊢ AbelianMonoid g ∧ FINITE s ⇒
        ∀b. FINITE_BAG b ⇒
            IMAGE f (SET_OF_BAG b) ⊆ G ∧ (∀x. x ⋲ b ⇒ ∃P. P ∈ s ∧ P x) ∧
            (∀x P1 P2. x ⋲ b ∧ P1 ∈ s ∧ P2 ∈ s ∧ P1 x ∧ P2 x ⇒ P1 = P2) ⇒
            GBAG g
              (BAG_IMAGE (λP. GBAG g (BAG_IMAGE f (BAG_FILTER P b)))
                 (BAG_OF_SET s)) =
            GBAG g (BAG_IMAGE f b)
   
   [<a name="GBAG_INSERT-val"><b>GBAG_INSERT</b></a>]  Theorem
      
      ⊢ AbelianMonoid g ∧ FINITE_BAG b ∧ SET_OF_BAG b ⊆ G ∧ x ∈ G ⇒
        GBAG g (BAG_INSERT x b) = x * GBAG g b
   
   [<a name="GBAG_PARTITION-val"><b>GBAG_PARTITION</b></a>]  Theorem
      
      ⊢ AbelianMonoid g ∧ FINITE s ∧ FINITE_BAG b ∧ SET_OF_BAG b ⊆ G ∧
        (∀x. x ⋲ b ⇒ ∃P. P ∈ s ∧ P x) ∧
        (∀x P1 P2. x ⋲ b ∧ P1 ∈ s ∧ P2 ∈ s ∧ P1 x ∧ P2 x ⇒ P1 = P2) ⇒
        GBAG g (BAG_IMAGE (λP. GBAG g (BAG_FILTER P b)) (BAG_OF_SET s)) =
        GBAG g b
   
   [<a name="GBAG_UNION-val"><b>GBAG_UNION</b></a>]  Theorem
      
      ⊢ AbelianMonoid g ∧ FINITE_BAG b1 ∧ FINITE_BAG b2 ∧
        SET_OF_BAG b1 ⊆ G ∧ SET_OF_BAG b2 ⊆ G ⇒
        GBAG g (b1 ⊎ b2) = GBAG g b1 * GBAG g b2
   
   [<a name="GBAG_in_carrier-val"><b>GBAG_in_carrier</b></a>]  Theorem
      
      ⊢ ∀g b.
          AbelianMonoid g ∧ FINITE_BAG b ∧ SET_OF_BAG b ⊆ G ⇒ GBAG g b ∈ G
   
   [<a name="GITBAG_BAG_IMAGE_op-val"><b>GITBAG_BAG_IMAGE_op</b></a>]  Theorem
      
      ⊢ ∀g. AbelianMonoid g ⇒
            ∀b. FINITE_BAG b ⇒
                ∀p q a.
                  IMAGE p (SET_OF_BAG b) ⊆ G ∧ IMAGE q (SET_OF_BAG b) ⊆ G ∧
                  a ∈ G ⇒
                  GITBAG g (BAG_IMAGE (λx. p x * q x) b) a =
                  GITBAG g (BAG_IMAGE p b) a * GBAG g (BAG_IMAGE q b)
   
   [<a name="GITBAG_CONG-val"><b>GITBAG_CONG</b></a>]  Theorem
      
      ⊢ ∀g. AbelianMonoid g ⇒
            ∀b. FINITE_BAG b ⇒
                ∀b' a a'.
                  FINITE_BAG b' ∧ a ∈ G ∧ SET_OF_BAG b ⊆ G ∧
                  SET_OF_BAG b' ⊆ G ∧
                  (∀x. x ⋲ b ⊎ b' ∧ x ≠ #e ⇒ b x = b' x) ⇒
                  GITBAG g b a = GITBAG g b' a
   
   [<a name="GITBAG_EMPTY-val"><b>GITBAG_EMPTY</b></a>]  Theorem
      
      ⊢ ∀g a. GITBAG g {||} a = a
   
   [<a name="GITBAG_GBAG-val"><b>GITBAG_GBAG</b></a>]  Theorem
      
      ⊢ ∀g. AbelianMonoid g ⇒
            ∀b. FINITE_BAG b ⇒
                ∀a. a ∈ G ∧ SET_OF_BAG b ⊆ G ⇒ GITBAG g b a = a * GBAG g b
   
   [<a name="GITBAG_INSERT-val"><b>GITBAG_INSERT</b></a>]  Theorem
      
      ⊢ ∀b. FINITE_BAG b ⇒
            ∀g x a.
              GITBAG g (BAG_INSERT x b) a =
              GITBAG g (BAG_REST (BAG_INSERT x b))
                (BAG_CHOICE (BAG_INSERT x b) * a)
   
   [<a name="GITBAG_INSERT_THM-val"><b>GITBAG_INSERT_THM</b></a>]  Theorem
      
      ⊢ ∀g b x a.
          (AbelianMonoid g ∧ FINITE_BAG b ∧ SET_OF_BAG b ⊆ G) ∧ x ∈ G ∧
          a ∈ G ⇒
          GITBAG g (BAG_INSERT x b) a = GITBAG g b (x * a)
   
   [<a name="GITBAG_THM-val"><b>GITBAG_THM</b></a>]  Theorem
      
      ⊢ ∀g b acc.
          FINITE_BAG b ⇒
          GITBAG g b acc =
          if b = {||} then acc
          else GITBAG g (BAG_REST b) (BAG_CHOICE b * acc)
   
   [<a name="GITBAG_UNION-val"><b>GITBAG_UNION</b></a>]  Theorem
      
      ⊢ ∀g. AbelianMonoid g ⇒
            ∀b1.
              FINITE_BAG b1 ⇒
              ∀b2.
                FINITE_BAG b2 ∧ SET_OF_BAG b1 ⊆ G ∧ SET_OF_BAG b2 ⊆ G ⇒
                ∀a. a ∈ G ⇒
                    GITBAG g (b1 ⊎ b2) a = GITBAG g b2 (GITBAG g b1 a)
   
   [<a name="GITBAG_in_carrier-val"><b>GITBAG_in_carrier</b></a>]  Theorem
      
      ⊢ ∀g. AbelianMonoid g ⇒
            ∀b. FINITE_BAG b ⇒
                ∀a. SET_OF_BAG b ⊆ G ∧ a ∈ G ⇒ GITBAG g b a ∈ G
   
   [<a name="GITBAG_same_op-val"><b>GITBAG_same_op</b></a>]  Theorem
      
      ⊢ g1.op = g2.op ⇒
        ∀b. FINITE_BAG b ⇒ ∀a. GITBAG g1 b a = GITBAG g2 b a
   
   [<a name="GITSET_EMPTY-val"><b>GITSET_EMPTY</b></a>]  Theorem
      
      ⊢ ∀g b. GITSET g ∅ b = b
   
   [<a name="GITSET_INSERT-val"><b>GITSET_INSERT</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒
            ∀x g b.
              GITSET g (x INSERT s) b =
              GITSET g (REST (x INSERT s)) (CHOICE (x INSERT s) * b)
   
   [<a name="GITSET_PROPERTY-val"><b>GITSET_PROPERTY</b></a>]  Theorem
      
      ⊢ ∀g s.
          FINITE s ∧ s ≠ ∅ ⇒
          ∀b. GITSET g s b = GITSET g (REST s) (CHOICE s * b)
   
   [<a name="GITSET_THM-val"><b>GITSET_THM</b></a>]  Theorem
      
      ⊢ ∀s g b.
          FINITE s ⇒
          GITSET g s b =
          if s = ∅ then b else GITSET g (REST s) (CHOICE s * b)
   
   [<a name="GPROD_SET_EMPTY-val"><b>GPROD_SET_EMPTY</b></a>]  Theorem
      
      ⊢ ∀g s. GPROD_SET g ∅ = #e
   
   [<a name="GPROD_SET_PROPERTY-val"><b>GPROD_SET_PROPERTY</b></a>]  Theorem
      
      ⊢ ∀g s. AbelianMonoid g ∧ FINITE s ∧ s ⊆ G ⇒ GPROD_SET g s ∈ G
   
   [<a name="GPROD_SET_SING-val"><b>GPROD_SET_SING</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ GPROD_SET g {x} = x
   
   [<a name="GPROD_SET_THM-val"><b>GPROD_SET_THM</b></a>]  Theorem
      
      ⊢ ∀g s.
          GPROD_SET g ∅ = #e ∧
          (AbelianMonoid g ∧ FINITE s ∧ s ⊆ G ⇒
           ∀x::G. GPROD_SET g (x INSERT s) = x * GPROD_SET g (s DELETE x))
   
   [<a name="IMP_GBAG_EQ_EXP-val"><b>IMP_GBAG_EQ_EXP</b></a>]  Theorem
      
      ⊢ AbelianMonoid g ∧ x ∈ G ∧ SET_OF_BAG b ⊆ {x} ⇒ GBAG g b = x ** b x
   
   [<a name="IMP_GBAG_EQ_ID-val"><b>IMP_GBAG_EQ_ID</b></a>]  Theorem
      
      ⊢ AbelianMonoid g ⇒ ∀b. BAG_EVERY ($= #e) b ⇒ GBAG g b = #e
   
   [<a name="Invertibles_carrier-val"><b>Invertibles_carrier</b></a>]  Theorem
      
      ⊢ ∀g. (Invertibles g).carrier = G*
   
   [<a name="Invertibles_order-val"><b>Invertibles_order</b></a>]  Theorem
      
      ⊢ ∀g x. order (Invertibles g) x = ord x
   
   [<a name="Invertibles_property-val"><b>Invertibles_property</b></a>]  Theorem
      
      ⊢ ∀g. (Invertibles g).carrier = G* ∧ (Invertibles g).op = $* ∧
            (Invertibles g).id = #e ∧ (Invertibles g).exp = $**
   
   [<a name="Invertibles_subset-val"><b>Invertibles_subset</b></a>]  Theorem
      
      ⊢ ∀g. (Invertibles g).carrier ⊆ G
   
   [<a name="MonoidHomo_GBAG-val"><b>MonoidHomo_GBAG</b></a>]  Theorem
      
      ⊢ AbelianMonoid g ∧ AbelianMonoid h ∧ MonoidHomo f g h ∧
        FINITE_BAG b ∧ SET_OF_BAG b ⊆ G ⇒
        f (GBAG g b) = GBAG h (BAG_IMAGE f b)
   
   [<a name="SUBSET_COMMUTING_ITBAG_INSERT-val"><b>SUBSET_COMMUTING_ITBAG_INSERT</b></a>]  Theorem
      
      ⊢ ∀f b t.
          SET_OF_BAG b ⊆ t ∧ closure_comm_assoc_fun f t ∧ FINITE_BAG b ⇒
          ∀x a::t. ITBAG f (BAG_INSERT x b) a = ITBAG f b (f x a)
   
   [<a name="abelian_monoid_op_closure_comm_assoc_fun-val"><b>abelian_monoid_op_closure_comm_assoc_fun</b></a>]  Theorem
      
      ⊢ ∀g. AbelianMonoid g ⇒ closure_comm_assoc_fun $* G
   
   [<a name="abelian_monoid_order_common-val"><b>abelian_monoid_order_common</b></a>]  Theorem
      
      ⊢ ∀g. AbelianMonoid g ⇒
            ∀x y.
              x ∈ G ∧ y ∈ G ⇒
              ∃z. z ∈ G ∧ ord z * gcd (ord x) (ord y) = lcm (ord x) (ord y)
   
   [<a name="abelian_monoid_order_common_coprime-val"><b>abelian_monoid_order_common_coprime</b></a>]  Theorem
      
      ⊢ ∀g. AbelianMonoid g ⇒
            ∀x y.
              x ∈ G ∧ y ∈ G ∧ coprime (ord x) (ord y) ⇒
              ∃z. z ∈ G ∧ ord z = ord x * ord y
   
   [<a name="abelian_monoid_order_lcm-val"><b>abelian_monoid_order_lcm</b></a>]  Theorem
      
      ⊢ ∀g. AbelianMonoid g ⇒
            ∀x y. x ∈ G ∧ y ∈ G ⇒ ∃z. z ∈ G ∧ ord z = lcm (ord x) (ord y)
   
   [<a name="addition_monoid_abelian_monoid-val"><b>addition_monoid_abelian_monoid</b></a>]  Theorem
      
      ⊢ AbelianMonoid addition_monoid
   
   [<a name="addition_monoid_monoid-val"><b>addition_monoid_monoid</b></a>]  Theorem
      
      ⊢ Monoid addition_monoid
   
   [<a name="addition_monoid_property-val"><b>addition_monoid_property</b></a>]  Theorem
      
      ⊢ addition_monoid.carrier = 𝕌(:num) ∧ addition_monoid.op = $+ ∧
        addition_monoid.id = 0
   
   [<a name="datatype_monoid-val"><b>datatype_monoid</b></a>]  Theorem
      
      ⊢ DATATYPE (record monoid carrier op id)
   
   [<a name="extend_carrier-val"><b>extend_carrier</b></a>]  Theorem
      
      ⊢ (extend m).carrier = 𝕌(:α)
   
   [<a name="extend_id-val"><b>extend_id</b></a>]  Theorem
      
      ⊢ (extend m).id = m.id
   
   [<a name="extend_is_monoid-val"><b>extend_is_monoid</b></a>]  Theorem
      
      ⊢ ∀m. Monoid m ⇒ Monoid (extend m)
   
   [<a name="extend_op-val"><b>extend_op</b></a>]  Theorem
      
      ⊢ x ∈ m.carrier ∧ y ∈ m.carrier ⇒ (extend m).op x y = m.op x y
   
   [<a name="finite_monoid_exp_not_distinct-val"><b>finite_monoid_exp_not_distinct</b></a>]  Theorem
      
      ⊢ ∀g. FiniteMonoid g ⇒ ∀x. x ∈ G ⇒ ∃h k. x ** h = x ** k ∧ h ≠ k
   
   [<a name="homo_monoid_I-val"><b>homo_monoid_I</b></a>]  Theorem
      
      ⊢ ∀g. MonoidIso I (homo_monoid g I) g
   
   [<a name="homo_monoid_abelian_monoid-val"><b>homo_monoid_abelian_monoid</b></a>]  Theorem
      
      ⊢ ∀g f.
          AbelianMonoid g ∧ MonoidHomo f g (homo_monoid g f) ⇒
          AbelianMonoid (homo_monoid g f)
   
   [<a name="homo_monoid_assoc-val"><b>homo_monoid_assoc</b></a>]  Theorem
      
      ⊢ ∀g f.
          Monoid g ∧ MonoidHomo f g (homo_monoid g f) ⇒
          ∀x y z. x ∈ fG ∧ y ∈ fG ∧ z ∈ fG ⇒ (x ∘ y) ∘ z = x ∘ y ∘ z
   
   [<a name="homo_monoid_by_inj-val"><b>homo_monoid_by_inj</b></a>]  Theorem
      
      ⊢ ∀g f. Monoid g ∧ INJ f G 𝕌(:β) ⇒ MonoidHomo f g (homo_monoid g f)
   
   [<a name="homo_monoid_closure-val"><b>homo_monoid_closure</b></a>]  Theorem
      
      ⊢ ∀g f.
          Monoid g ∧ MonoidHomo f g (homo_monoid g f) ⇒
          ∀x y. x ∈ fG ∧ y ∈ fG ⇒ x ∘ y ∈ fG
   
   [<a name="homo_monoid_comm-val"><b>homo_monoid_comm</b></a>]  Theorem
      
      ⊢ ∀g f.
          AbelianMonoid g ∧ MonoidHomo f g (homo_monoid g f) ⇒
          ∀x y. x ∈ fG ∧ y ∈ fG ⇒ x ∘ y = y ∘ x
   
   [<a name="homo_monoid_element-val"><b>homo_monoid_element</b></a>]  Theorem
      
      ⊢ ∀g f x. x ∈ G ⇒ f x ∈ fG
   
   [<a name="homo_monoid_id-val"><b>homo_monoid_id</b></a>]  Theorem
      
      ⊢ ∀g f. f #e = #i
   
   [<a name="homo_monoid_id_property-val"><b>homo_monoid_id_property</b></a>]  Theorem
      
      ⊢ ∀g f.
          Monoid g ∧ MonoidHomo f g (homo_monoid g f) ⇒
          #i ∈ fG ∧ ∀x. x ∈ fG ⇒ #i ∘ x = x ∧ x ∘ #i = x
   
   [<a name="homo_monoid_monoid-val"><b>homo_monoid_monoid</b></a>]  Theorem
      
      ⊢ ∀g f.
          Monoid g ∧ MonoidHomo f g (homo_monoid g f) ⇒
          Monoid (homo_monoid g f)
   
   [<a name="homo_monoid_op_inj-val"><b>homo_monoid_op_inj</b></a>]  Theorem
      
      ⊢ ∀g f. INJ f G 𝕌(:β) ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ f (x * y) = f x ∘ f y
   
   [<a name="homo_monoid_property-val"><b>homo_monoid_property</b></a>]  Theorem
      
      ⊢ ∀g f.
          fG = IMAGE f G ∧
          (∀x y.
             x ∈ fG ∧ y ∈ fG ⇒
             x ∘ y = f (CHOICE (preimage f G x) * CHOICE (preimage f G y))) ∧
          #i = f #e
   
   [<a name="image_op_inj-val"><b>image_op_inj</b></a>]  Theorem
      
      ⊢ ∀g f.
          INJ f G 𝕌(:β) ⇒
          ∀x y. x ∈ G ∧ y ∈ G ⇒ image_op g f (f x) (f y) = f (x * y)
   
   [<a name="lists_monoid-val"><b>lists_monoid</b></a>]  Theorem
      
      ⊢ Monoid lists
   
   [<a name="maximal_order_alt-val"><b>maximal_order_alt</b></a>]  Theorem
      
      ⊢ ∀g. maximal_order g = MAX_SET {ord z | z | z ∈ G}
   
   [<a name="monoid_11-val"><b>monoid_11</b></a>]  Theorem
      
      ⊢ ∀a0 a1 a2 a0' a1' a2'.
          monoid a0 a1 a2 = monoid a0' a1' a2' ⇔
          a0 = a0' ∧ a1 = a1' ∧ a2 = a2'
   
   [<a name="monoid_Axiom-val"><b>monoid_Axiom</b></a>]  Theorem
      
      ⊢ ∀f. ∃fn. ∀a0 a1 a2. fn (monoid a0 a1 a2) = f a0 a1 a2
   
   [<a name="monoid_accessors-val"><b>monoid_accessors</b></a>]  Theorem
      
      ⊢ (∀f f0 a. (monoid f f0 a).carrier = f) ∧
        (∀f f0 a. (monoid f f0 a).op = f0) ∧
        ∀f f0 a. (monoid f f0 a).id = a
   
   [<a name="monoid_accfupds-val"><b>monoid_accfupds</b></a>]  Theorem
      
      ⊢ (∀m f. (m with op updated_by f).carrier = m.carrier) ∧
        (∀m f. (m with id updated_by f).carrier = m.carrier) ∧
        (∀m f. (m with carrier updated_by f).op = m.op) ∧
        (∀m f. (m with id updated_by f).op = m.op) ∧
        (∀m f. (m with carrier updated_by f).id = m.id) ∧
        (∀m f. (m with op updated_by f).id = m.id) ∧
        (∀m f. (m with carrier updated_by f).carrier = f m.carrier) ∧
        (∀m f. (m with op updated_by f).op = f m.op) ∧
        ∀m f. (m with id updated_by f).id = f m.id
   
   [<a name="monoid_assoc-val"><b>monoid_assoc</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒
            ∀x y z. x ∈ G ∧ y ∈ G ∧ z ∈ G ⇒ x * y * z = x * (y * z)
   
   [<a name="monoid_auto_I-val"><b>monoid_auto_I</b></a>]  Theorem
      
      ⊢ ∀g. MonoidAuto I g
   
   [<a name="monoid_auto_bij-val"><b>monoid_auto_bij</b></a>]  Theorem
      
      ⊢ ∀g f. MonoidAuto f g ⇒ f PERMUTES G
   
   [<a name="monoid_auto_compose-val"><b>monoid_auto_compose</b></a>]  Theorem
      
      ⊢ ∀g f1 f2.
          MonoidAuto f1 g ∧ MonoidAuto f2 g ⇒ MonoidAuto (f1 ∘ f2) g
   
   [<a name="monoid_auto_element-val"><b>monoid_auto_element</b></a>]  Theorem
      
      ⊢ ∀f g. MonoidAuto f g ⇒ ∀x. x ∈ G ⇒ f x ∈ G
   
   [<a name="monoid_auto_exp-val"><b>monoid_auto_exp</b></a>]  Theorem
      
      ⊢ ∀f g.
          Monoid g ∧ MonoidAuto f g ⇒ ∀x. x ∈ G ⇒ ∀n. f (x ** n) = f x ** n
   
   [<a name="monoid_auto_id-val"><b>monoid_auto_id</b></a>]  Theorem
      
      ⊢ ∀f g. MonoidAuto f g ⇒ f #e = #e
   
   [<a name="monoid_auto_linv_auto-val"><b>monoid_auto_linv_auto</b></a>]  Theorem
      
      ⊢ ∀g f. Monoid g ∧ MonoidAuto f g ⇒ MonoidAuto (LINV f G) g
   
   [<a name="monoid_auto_order-val"><b>monoid_auto_order</b></a>]  Theorem
      
      ⊢ ∀g f. Monoid g ∧ MonoidAuto f g ⇒ ∀x. x ∈ G ⇒ ord (f x) = ord x
   
   [<a name="monoid_carrier_nonempty-val"><b>monoid_carrier_nonempty</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ G ≠ ∅
   
   [<a name="monoid_case_cong-val"><b>monoid_case_cong</b></a>]  Theorem
      
      ⊢ ∀M M' f.
          M = M' ∧
          (∀a0 a1 a2. M' = monoid a0 a1 a2 ⇒ f a0 a1 a2 = f' a0 a1 a2) ⇒
          monoid_CASE M f = monoid_CASE M' f'
   
   [<a name="monoid_case_eq-val"><b>monoid_case_eq</b></a>]  Theorem
      
      ⊢ monoid_CASE x f = v ⇔ ∃f' f0 a. x = monoid f' f0 a ∧ f f' f0 a = v
   
   [<a name="monoid_comm_exp-val"><b>monoid_comm_exp</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒
            ∀x y.
              x ∈ G ∧ y ∈ G ⇒ x * y = y * x ⇒ ∀n. x ** n * y = y * x ** n
   
   [<a name="monoid_comm_exp_exp-val"><b>monoid_comm_exp_exp</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒
            ∀x y.
              x ∈ G ∧ y ∈ G ∧ x * y = y * x ⇒
              ∀n m. x ** n * y ** m = y ** m * x ** n
   
   [<a name="monoid_comm_op_exp-val"><b>monoid_comm_op_exp</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒
            ∀x y.
              x ∈ G ∧ y ∈ G ∧ x * y = y * x ⇒
              ∀n. (x * y) ** n = x ** n * y ** n
   
   [<a name="monoid_component_equality-val"><b>monoid_component_equality</b></a>]  Theorem
      
      ⊢ ∀m1 m2.
          m1 = m2 ⇔ m1.carrier = m2.carrier ∧ m1.op = m2.op ∧ m1.id = m2.id
   
   [<a name="monoid_exp_0-val"><b>monoid_exp_0</b></a>]  Theorem
      
      ⊢ ∀g x. x ** 0 = #e
   
   [<a name="monoid_exp_1-val"><b>monoid_exp_1</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ x ** 1 = x
   
   [<a name="monoid_exp_SUC-val"><b>monoid_exp_SUC</b></a>]  Theorem
      
      ⊢ ∀g x n. x ** SUC n = x * x ** n
   
   [<a name="monoid_exp_add-val"><b>monoid_exp_add</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ ∀n k. x ** (n + k) = x ** n * x ** k
   
   [<a name="monoid_exp_comm-val"><b>monoid_exp_comm</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ ∀n. x ** n * x = x * x ** n
   
   [<a name="monoid_exp_element-val"><b>monoid_exp_element</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ ∀n. x ** n ∈ G
   
   [<a name="monoid_exp_mod_order-val"><b>monoid_exp_mod_order</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒
            ∀x. x ∈ G ∧ 0 &lt; ord x ⇒ ∀n. x ** n = x ** (n MOD ord x)
   
   [<a name="monoid_exp_mult-val"><b>monoid_exp_mult</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ ∀n k. x ** (n * k) = (x ** n) ** k
   
   [<a name="monoid_exp_mult_comm-val"><b>monoid_exp_mult_comm</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ ∀m n. (x ** m) ** n = (x ** n) ** m
   
   [<a name="monoid_exp_suc-val"><b>monoid_exp_suc</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ ∀n. x ** SUC n = x ** n * x
   
   [<a name="monoid_fn_updates-val"><b>monoid_fn_updates</b></a>]  Theorem
      
      ⊢ (∀f1 f f0 a.
           monoid f f0 a with carrier updated_by f1 = monoid (f1 f) f0 a) ∧
        (∀f1 f f0 a.
           monoid f f0 a with op updated_by f1 = monoid f (f1 f0) a) ∧
        ∀f1 f f0 a.
          monoid f f0 a with id updated_by f1 = monoid f f0 (f1 a)
   
   [<a name="monoid_fupdcanon-val"><b>monoid_fupdcanon</b></a>]  Theorem
      
      ⊢ (∀m g f.
           m with &lt;|op updated_by f; carrier updated_by g|&gt; =
           m with &lt;|carrier updated_by g; op updated_by f|&gt;) ∧
        (∀m g f.
           m with &lt;|id updated_by f; carrier updated_by g|&gt; =
           m with &lt;|carrier updated_by g; id updated_by f|&gt;) ∧
        ∀m g f.
          m with &lt;|id updated_by f; op updated_by g|&gt; =
          m with &lt;|op updated_by g; id updated_by f|&gt;
   
   [<a name="monoid_fupdcanon_comp-val"><b>monoid_fupdcanon_comp</b></a>]  Theorem
      
      ⊢ ((∀g f. op_fupd f ∘ carrier_fupd g = carrier_fupd g ∘ op_fupd f) ∧
         ∀h g f.
           op_fupd f ∘ carrier_fupd g ∘ h = carrier_fupd g ∘ op_fupd f ∘ h) ∧
        ((∀g f. id_fupd f ∘ carrier_fupd g = carrier_fupd g ∘ id_fupd f) ∧
         ∀h g f.
           id_fupd f ∘ carrier_fupd g ∘ h = carrier_fupd g ∘ id_fupd f ∘ h) ∧
        (∀g f. id_fupd f ∘ op_fupd g = op_fupd g ∘ id_fupd f) ∧
        ∀h g f. id_fupd f ∘ op_fupd g ∘ h = op_fupd g ∘ id_fupd f ∘ h
   
   [<a name="monoid_fupdfupds-val"><b>monoid_fupdfupds</b></a>]  Theorem
      
      ⊢ (∀m g f.
           m with &lt;|carrier updated_by f; carrier updated_by g|&gt; =
           m with carrier updated_by f ∘ g) ∧
        (∀m g f.
           m with &lt;|op updated_by f; op updated_by g|&gt; =
           m with op updated_by f ∘ g) ∧
        ∀m g f.
          m with &lt;|id updated_by f; id updated_by g|&gt; =
          m with id updated_by f ∘ g
   
   [<a name="monoid_fupdfupds_comp-val"><b>monoid_fupdfupds_comp</b></a>]  Theorem
      
      ⊢ ((∀g f. carrier_fupd f ∘ carrier_fupd g = carrier_fupd (f ∘ g)) ∧
         ∀h g f.
           carrier_fupd f ∘ carrier_fupd g ∘ h = carrier_fupd (f ∘ g) ∘ h) ∧
        ((∀g f. op_fupd f ∘ op_fupd g = op_fupd (f ∘ g)) ∧
         ∀h g f. op_fupd f ∘ op_fupd g ∘ h = op_fupd (f ∘ g) ∘ h) ∧
        (∀g f. id_fupd f ∘ id_fupd g = id_fupd (f ∘ g)) ∧
        ∀h g f. id_fupd f ∘ id_fupd g ∘ h = id_fupd (f ∘ g) ∘ h
   
   [<a name="monoid_homo_I_refl-val"><b>monoid_homo_I_refl</b></a>]  Theorem
      
      ⊢ ∀g. MonoidHomo I g g
   
   [<a name="monoid_homo_compose-val"><b>monoid_homo_compose</b></a>]  Theorem
      
      ⊢ ∀g h k f1 f2.
          MonoidHomo f1 g h ∧ MonoidHomo f2 h k ⇒ MonoidHomo (f2 ∘ f1) g k
   
   [<a name="monoid_homo_cong-val"><b>monoid_homo_cong</b></a>]  Theorem
      
      ⊢ ∀g h f1 f2.
          Monoid g ∧ Monoid h ∧ (∀x. x ∈ G ⇒ f1 x = f2 x) ⇒
          (MonoidHomo f1 g h ⇔ MonoidHomo f2 g h)
   
   [<a name="monoid_homo_element-val"><b>monoid_homo_element</b></a>]  Theorem
      
      ⊢ ∀f g h. MonoidHomo f g h ⇒ ∀x. x ∈ G ⇒ f x ∈ h.carrier
   
   [<a name="monoid_homo_exp-val"><b>monoid_homo_exp</b></a>]  Theorem
      
      ⊢ ∀g h f.
          Monoid g ∧ MonoidHomo f g h ⇒
          ∀x. x ∈ G ⇒ ∀n. f (x ** n) = h.exp (f x) n
   
   [<a name="monoid_homo_id-val"><b>monoid_homo_id</b></a>]  Theorem
      
      ⊢ ∀f g h. MonoidHomo f g h ⇒ f #e = h.id
   
   [<a name="monoid_homo_sym-val"><b>monoid_homo_sym</b></a>]  Theorem
      
      ⊢ ∀g h f.
          Monoid g ∧ MonoidHomo f g h ∧ BIJ f G h.carrier ⇒
          MonoidHomo (LINV f G) h g
   
   [<a name="monoid_homo_sym_any-val"><b>monoid_homo_sym_any</b></a>]  Theorem
      
      ⊢ Monoid g ∧ MonoidHomo f g h ∧
        (∀x. x ∈ h.carrier ⇒ i x ∈ G ∧ f (i x) = x) ∧
        (∀x. x ∈ G ⇒ i (f x) = x) ⇒
        MonoidHomo i h g
   
   [<a name="monoid_homo_trans-val"><b>monoid_homo_trans</b></a>]  Theorem
      
      ⊢ ∀g h k f1 f2.
          MonoidHomo f1 g h ∧ MonoidHomo f2 h k ⇒ MonoidHomo (f2 ∘ f1) g k
   
   [<a name="monoid_id-val"><b>monoid_id</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ #e * x = x ∧ x * #e = x
   
   [<a name="monoid_id_element-val"><b>monoid_id_element</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ #e ∈ G
   
   [<a name="monoid_id_exp-val"><b>monoid_id_exp</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ ∀n. #e ** n = #e
   
   [<a name="monoid_id_id-val"><b>monoid_id_id</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ #e * #e = #e
   
   [<a name="monoid_id_invertible-val"><b>monoid_id_invertible</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ #e ∈ G*
   
   [<a name="monoid_id_unique-val"><b>monoid_id_unique</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒
            ∀e. e ∈ G ⇒ ((∀x. x ∈ G ⇒ x * e = x ∧ e * x = x) ⇔ e = #e)
   
   [<a name="monoid_induction-val"><b>monoid_induction</b></a>]  Theorem
      
      ⊢ ∀P. (∀f f0 a. P (monoid f f0 a)) ⇒ ∀m. P m
   
   [<a name="monoid_inj_image_abelian_monoid-val"><b>monoid_inj_image_abelian_monoid</b></a>]  Theorem
      
      ⊢ ∀g f.
          AbelianMonoid g ∧ INJ f G 𝕌(:β) ⇒
          AbelianMonoid (monoid_inj_image g f)
   
   [<a name="monoid_inj_image_monoid-val"><b>monoid_inj_image_monoid</b></a>]  Theorem
      
      ⊢ ∀g f. Monoid g ∧ INJ f G 𝕌(:β) ⇒ Monoid (monoid_inj_image g f)
   
   [<a name="monoid_inj_image_monoid_homo-val"><b>monoid_inj_image_monoid_homo</b></a>]  Theorem
      
      ⊢ ∀g f. INJ f G 𝕌(:β) ⇒ MonoidHomo f g (monoid_inj_image g f)
   
   [<a name="monoid_intersect_element-val"><b>monoid_intersect_element</b></a>]  Theorem
      
      ⊢ ∀g h x. x ∈ (g mINTER h).carrier ⇒ x ∈ G ∧ x ∈ H
   
   [<a name="monoid_intersect_id-val"><b>monoid_intersect_id</b></a>]  Theorem
      
      ⊢ ∀g h. (g mINTER h).id = #e
   
   [<a name="monoid_intersect_property-val"><b>monoid_intersect_property</b></a>]  Theorem
      
      ⊢ ∀g h.
          (g mINTER h).carrier = G ∩ H ∧ (g mINTER h).op = $* ∧
          (g mINTER h).id = #e
   
   [<a name="monoid_inv_def_alt-val"><b>monoid_inv_def_alt</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒
            ∀x. x ∈ G* ⇔ x ∈ G ∧ |/ x ∈ G ∧ x * |/ x = #e ∧ |/ x * x = #e
   
   [<a name="monoid_inv_element-val"><b>monoid_inv_element</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G* ⇒ x ∈ G
   
   [<a name="monoid_inv_from_invertibles-val"><b>monoid_inv_from_invertibles</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G* ⇒ ∃y. y ∈ G ∧ x * y = #e ∧ y * x = #e
   
   [<a name="monoid_inv_invertible-val"><b>monoid_inv_invertible</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G* ⇒ |/ x ∈ G*
   
   [<a name="monoid_inv_op_invertible-val"><b>monoid_inv_op_invertible</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ ∀x y. x ∈ G* ∧ y ∈ G* ⇒ x * y ∈ G*
   
   [<a name="monoid_invertibles_element-val"><b>monoid_invertibles_element</b></a>]  Theorem
      
      ⊢ ∀g x. x ∈ G* ⇔ x ∈ G ∧ ∃y. y ∈ G ∧ x * y = #e ∧ y * x = #e
   
   [<a name="monoid_invertibles_is_monoid-val"><b>monoid_invertibles_is_monoid</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ Monoid (Invertibles g)
   
   [<a name="monoid_iso_I_refl-val"><b>monoid_iso_I_refl</b></a>]  Theorem
      
      ⊢ ∀g. MonoidIso I g g
   
   [<a name="monoid_iso_bij-val"><b>monoid_iso_bij</b></a>]  Theorem
      
      ⊢ ∀g h f. MonoidIso f g h ⇒ BIJ f G h.carrier
   
   [<a name="monoid_iso_card_eq-val"><b>monoid_iso_card_eq</b></a>]  Theorem
      
      ⊢ ∀g h f. MonoidIso f g h ∧ FINITE G ⇒ CARD G = CARD h.carrier
   
   [<a name="monoid_iso_compose-val"><b>monoid_iso_compose</b></a>]  Theorem
      
      ⊢ ∀g h k f1 f2.
          MonoidIso f1 g h ∧ MonoidIso f2 h k ⇒ MonoidIso (f2 ∘ f1) g k
   
   [<a name="monoid_iso_element-val"><b>monoid_iso_element</b></a>]  Theorem
      
      ⊢ ∀f g h. MonoidIso f g h ⇒ ∀x. x ∈ G ⇒ f x ∈ h.carrier
   
   [<a name="monoid_iso_eq_id-val"><b>monoid_iso_eq_id</b></a>]  Theorem
      
      ⊢ ∀g h f.
          Monoid g ∧ Monoid h ∧ MonoidIso f g h ⇒
          ∀x. x ∈ G ⇒ (f x = h.id ⇔ x = #e)
   
   [<a name="monoid_iso_exp-val"><b>monoid_iso_exp</b></a>]  Theorem
      
      ⊢ ∀g h f.
          Monoid g ∧ MonoidIso f g h ⇒
          ∀x. x ∈ G ⇒ ∀n. f (x ** n) = h.exp (f x) n
   
   [<a name="monoid_iso_id-val"><b>monoid_iso_id</b></a>]  Theorem
      
      ⊢ ∀f g h. MonoidIso f g h ⇒ f #e = h.id
   
   [<a name="monoid_iso_linv_iso-val"><b>monoid_iso_linv_iso</b></a>]  Theorem
      
      ⊢ ∀g h f. Monoid g ∧ MonoidIso f g h ⇒ MonoidIso (LINV f G) h g
   
   [<a name="monoid_iso_monoid-val"><b>monoid_iso_monoid</b></a>]  Theorem
      
      ⊢ ∀g h f. Monoid g ∧ MonoidIso f g h ⇒ Monoid h
   
   [<a name="monoid_iso_order-val"><b>monoid_iso_order</b></a>]  Theorem
      
      ⊢ ∀g h f.
          Monoid g ∧ Monoid h ∧ MonoidIso f g h ⇒
          ∀x. x ∈ G ⇒ order h (f x) = ord x
   
   [<a name="monoid_iso_property-val"><b>monoid_iso_property</b></a>]  Theorem
      
      ⊢ ∀f g h.
          MonoidIso f g h ⇔
          MonoidHomo f g h ∧ ∀y. y ∈ h.carrier ⇒ ∃!x. x ∈ G ∧ f x = y
   
   [<a name="monoid_iso_sym-val"><b>monoid_iso_sym</b></a>]  Theorem
      
      ⊢ ∀g h f. Monoid g ∧ MonoidIso f g h ⇒ MonoidIso (LINV f G) h g
   
   [<a name="monoid_iso_trans-val"><b>monoid_iso_trans</b></a>]  Theorem
      
      ⊢ ∀g h k f1 f2.
          MonoidIso f1 g h ∧ MonoidIso f2 h k ⇒ MonoidIso (f2 ∘ f1) g k
   
   [<a name="monoid_lid-val"><b>monoid_lid</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ #e * x = x
   
   [<a name="monoid_lid_unique-val"><b>monoid_lid_unique</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ ∀e. e ∈ G ⇒ (∀x. x ∈ G ⇒ e * x = x) ⇒ e = #e
   
   [<a name="monoid_literal_11-val"><b>monoid_literal_11</b></a>]  Theorem
      
      ⊢ ∀f01 f1 a1 f02 f2 a2.
          &lt;|carrier := f01; op := f1; id := a1|&gt; =
          &lt;|carrier := f02; op := f2; id := a2|&gt; ⇔
          f01 = f02 ∧ f1 = f2 ∧ a1 = a2
   
   [<a name="monoid_literal_nchotomy-val"><b>monoid_literal_nchotomy</b></a>]  Theorem
      
      ⊢ ∀m. ∃f0 f a. m = &lt;|carrier := f0; op := f; id := a|&gt;
   
   [<a name="monoid_nchotomy-val"><b>monoid_nchotomy</b></a>]  Theorem
      
      ⊢ ∀mm. ∃f f0 a. mm = monoid f f0 a
   
   [<a name="monoid_op_element-val"><b>monoid_op_element</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ x * y ∈ G
   
   [<a name="monoid_order_cofactor-val"><b>monoid_order_cofactor</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒
            ∀x n.
              x ∈ G ∧ 0 &lt; ord x ∧ n divides ord x ⇒
              ord (x ** (ord x DIV n)) = n
   
   [<a name="monoid_order_common-val"><b>monoid_order_common</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒
            ∀x y.
              x ∈ G ∧ y ∈ G ∧ x * y = y * x ⇒
              ∃z. z ∈ G ∧ ord z * gcd (ord x) (ord y) = lcm (ord x) (ord y)
   
   [<a name="monoid_order_common_coprime-val"><b>monoid_order_common_coprime</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒
            ∀x y.
              x ∈ G ∧ y ∈ G ∧ x * y = y * x ∧ coprime (ord x) (ord y) ⇒
              ∃z. z ∈ G ∧ ord z = ord x * ord y
   
   [<a name="monoid_order_condition-val"><b>monoid_order_condition</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ ∀m. x ** m = #e ⇔ ord x divides m
   
   [<a name="monoid_order_divides_exp-val"><b>monoid_order_divides_exp</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ ∀x n. x ∈ G ⇒ (x ** n = #e ⇔ ord x divides n)
   
   [<a name="monoid_order_divides_maximal-val"><b>monoid_order_divides_maximal</b></a>]  Theorem
      
      ⊢ ∀g. FiniteAbelianMonoid g ⇒
            ∀x. x ∈ G ∧ 0 &lt; ord x ⇒ ord x divides maximal_order g
   
   [<a name="monoid_order_divisor-val"><b>monoid_order_divisor</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒
            ∀x m.
              x ∈ G ∧ 0 &lt; ord x ∧ m divides ord x ⇒ ∃y. y ∈ G ∧ ord y = m
   
   [<a name="monoid_order_eq_1-val"><b>monoid_order_eq_1</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ (ord x = 1 ⇔ x = #e)
   
   [<a name="monoid_order_id-val"><b>monoid_order_id</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ ord #e = 1
   
   [<a name="monoid_order_nonzero-val"><b>monoid_order_nonzero</b></a>]  Theorem
      
      ⊢ ∀g x. Monoid g ∧ x ∈ G ∧ 0 &lt; ord x ⇒ x ∈ G*
   
   [<a name="monoid_order_power-val"><b>monoid_order_power</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ ∀k. ord (x ** k) * gcd (ord x) k = ord x
   
   [<a name="monoid_order_power_coprime-val"><b>monoid_order_power_coprime</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒
            ∀x. x ∈ G ⇒ ∀n. coprime n (ord x) ⇒ ord (x ** n) = ord x
   
   [<a name="monoid_order_power_eq_0-val"><b>monoid_order_power_eq_0</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ ∀k. ord (x ** k) = 0 ⇔ 0 &lt; k ∧ ord x = 0
   
   [<a name="monoid_order_power_eqn-val"><b>monoid_order_power_eqn</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒
            ∀x k. x ∈ G ∧ 0 &lt; k ⇒ ord (x ** k) = ord x DIV gcd k (ord x)
   
   [<a name="monoid_rid-val"><b>monoid_rid</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ x * #e = x
   
   [<a name="monoid_rid_unique-val"><b>monoid_rid_unique</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ ∀e. e ∈ G ⇒ (∀x. x ∈ G ⇒ x * e = x) ⇒ e = #e
   
   [<a name="monoid_updates_eq_literal-val"><b>monoid_updates_eq_literal</b></a>]  Theorem
      
      ⊢ ∀m f0 f a.
          m with &lt;|carrier := f0; op := f; id := a|&gt; =
          &lt;|carrier := f0; op := f; id := a|&gt;
   
   [<a name="monoid_weak_iso_id-val"><b>monoid_weak_iso_id</b></a>]  Theorem
      
      ⊢ ∀f g h. Monoid g ∧ Monoid h ∧ WeakIso f g h ⇒ f #e = h.id
   
   [<a name="multiplication_monoid_abelian_monoid-val"><b>multiplication_monoid_abelian_monoid</b></a>]  Theorem
      
      ⊢ AbelianMonoid multiplication_monoid
   
   [<a name="multiplication_monoid_monoid-val"><b>multiplication_monoid_monoid</b></a>]  Theorem
      
      ⊢ Monoid multiplication_monoid
   
   [<a name="multiplication_monoid_property-val"><b>multiplication_monoid_property</b></a>]  Theorem
      
      ⊢ multiplication_monoid.carrier = 𝕌(:num) ∧
        multiplication_monoid.op = $* ∧ multiplication_monoid.id = 1
   
   [<a name="order_alt-val"><b>order_alt</b></a>]  Theorem
      
      ⊢ ∀g x.
          ord x =
          case OLEAST k. 0 &lt; k ∧ x ** k = #e of NONE =&gt; 0 | SOME k =&gt; k
   
   [<a name="order_eq_0-val"><b>order_eq_0</b></a>]  Theorem
      
      ⊢ ∀g x. ord x = 0 ⇔ ∀n. 0 &lt; n ⇒ x ** n ≠ #e
   
   [<a name="order_minimal-val"><b>order_minimal</b></a>]  Theorem
      
      ⊢ ∀g x n. 0 &lt; n ∧ n &lt; ord x ⇒ x ** n ≠ #e
   
   [<a name="order_period-val"><b>order_period</b></a>]  Theorem
      
      ⊢ ∀g x. 0 &lt; ord x ⇒ period g x (ord x)
   
   [<a name="order_property-val"><b>order_property</b></a>]  Theorem
      
      ⊢ ∀g x. x ** ord x = #e
   
   [<a name="order_thm-val"><b>order_thm</b></a>]  Theorem
      
      ⊢ ∀g x n.
          0 &lt; n ⇒
          (ord x = n ⇔ x ** n = #e ∧ ∀m. 0 &lt; m ∧ m &lt; n ⇒ x ** m ≠ #e)
   
   [<a name="orders_element-val"><b>orders_element</b></a>]  Theorem
      
      ⊢ ∀g x n. x ∈ orders g n ⇔ x ∈ G ∧ ord x = n
   
   [<a name="orders_eq_1-val"><b>orders_eq_1</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ orders g 1 = {#e}
   
   [<a name="orders_finite-val"><b>orders_finite</b></a>]  Theorem
      
      ⊢ ∀g. FINITE G ⇒ ∀n. FINITE (orders g n)
   
   [<a name="orders_subset-val"><b>orders_subset</b></a>]  Theorem
      
      ⊢ ∀g n. orders g n ⊆ G
   
   [<a name="plus_mod_abelian_monoid-val"><b>plus_mod_abelian_monoid</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ AbelianMonoid (plus_mod n)
   
   [<a name="plus_mod_exp-val"><b>plus_mod_exp</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀x k. (plus_mod n).exp x k = (k * x) MOD n
   
   [<a name="plus_mod_finite-val"><b>plus_mod_finite</b></a>]  Theorem
      
      ⊢ ∀n. FINITE (plus_mod n).carrier
   
   [<a name="plus_mod_finite_abelian_monoid-val"><b>plus_mod_finite_abelian_monoid</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ FiniteAbelianMonoid (plus_mod n)
   
   [<a name="plus_mod_finite_monoid-val"><b>plus_mod_finite_monoid</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ FiniteMonoid (plus_mod n)
   
   [<a name="plus_mod_monoid-val"><b>plus_mod_monoid</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ Monoid (plus_mod n)
   
   [<a name="plus_mod_property-val"><b>plus_mod_property</b></a>]  Theorem
      
      ⊢ ∀n. (plus_mod n).carrier = count n ∧
            (plus_mod n).op = (λi j. (i + j) MOD n) ∧ (plus_mod n).id = 0 ∧
            (∀x. x ∈ (plus_mod n).carrier ⇒ x &lt; n) ∧
            FINITE (plus_mod n).carrier ∧ CARD (plus_mod n).carrier = n
   
   [<a name="power_monoid_abelian_monoid-val"><b>power_monoid_abelian_monoid</b></a>]  Theorem
      
      ⊢ ∀b. AbelianMonoid (power_monoid b)
   
   [<a name="power_monoid_monoid-val"><b>power_monoid_monoid</b></a>]  Theorem
      
      ⊢ ∀b. Monoid (power_monoid b)
   
   [<a name="power_monoid_property-val"><b>power_monoid_property</b></a>]  Theorem
      
      ⊢ ∀b. (power_monoid b).carrier = {b ** j | j ∈ 𝕌(:num)} ∧
            (power_monoid b).op = $* ∧ (power_monoid b).id = 1
   
   [<a name="power_to_addition_homo-val"><b>power_to_addition_homo</b></a>]  Theorem
      
      ⊢ ∀b. 1 &lt; b ⇒ MonoidHomo (LOG b) (power_monoid b) addition_monoid
   
   [<a name="power_to_addition_iso-val"><b>power_to_addition_iso</b></a>]  Theorem
      
      ⊢ ∀b. 1 &lt; b ⇒ MonoidIso (LOG b) (power_monoid b) addition_monoid
   
   [<a name="set_inter_abelian_monoid-val"><b>set_inter_abelian_monoid</b></a>]  Theorem
      
      ⊢ AbelianMonoid set_inter
   
   [<a name="set_inter_monoid-val"><b>set_inter_monoid</b></a>]  Theorem
      
      ⊢ Monoid set_inter
   
   [<a name="set_union_abelian_monoid-val"><b>set_union_abelian_monoid</b></a>]  Theorem
      
      ⊢ AbelianMonoid set_union
   
   [<a name="set_union_monoid-val"><b>set_union_monoid</b></a>]  Theorem
      
      ⊢ Monoid set_union
   
   [<a name="submonoid_I_antisym-val"><b>submonoid_I_antisym</b></a>]  Theorem
      
      ⊢ ∀g h. submonoid h g ∧ submonoid g h ⇒ MonoidIso I h g
   
   [<a name="submonoid_alt-val"><b>submonoid_alt</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒
            ∀h. h &lt;&lt; g ⇔
                H ⊆ G ∧ (∀x y. x ∈ H ∧ y ∈ H ⇒ x ∘ y ∈ H) ∧ #i ∈ H ∧
                $o = $* ∧ #i = #e
   
   [<a name="submonoid_antisymmetric-val"><b>submonoid_antisymmetric</b></a>]  Theorem
      
      ⊢ ∀g h. h &lt;&lt; g ∧ g &lt;&lt; h ⇒ h = g
   
   [<a name="submonoid_big_intersect_element-val"><b>submonoid_big_intersect_element</b></a>]  Theorem
      
      ⊢ ∀g x. x ∈ (smbINTER g).carrier ⇔ ∀h. h &lt;&lt; g ⇒ x ∈ H
   
   [<a name="submonoid_big_intersect_has_id-val"><b>submonoid_big_intersect_has_id</b></a>]  Theorem
      
      ⊢ ∀g. (smbINTER g).id ∈ (smbINTER g).carrier
   
   [<a name="submonoid_big_intersect_monoid-val"><b>submonoid_big_intersect_monoid</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ Monoid (smbINTER g)
   
   [<a name="submonoid_big_intersect_op_element-val"><b>submonoid_big_intersect_op_element</b></a>]  Theorem
      
      ⊢ ∀g x y.
          x ∈ (smbINTER g).carrier ∧ y ∈ (smbINTER g).carrier ⇒
          (smbINTER g).op x y ∈ (smbINTER g).carrier
   
   [<a name="submonoid_big_intersect_property-val"><b>submonoid_big_intersect_property</b></a>]  Theorem
      
      ⊢ ∀g. (smbINTER g).carrier = BIGINTER (IMAGE (λh. H) {h | h &lt;&lt; g}) ∧
            (∀x y.
               x ∈ (smbINTER g).carrier ∧ y ∈ (smbINTER g).carrier ⇒
               (smbINTER g).op x y = x * y) ∧ (smbINTER g).id = #e
   
   [<a name="submonoid_big_intersect_submonoid-val"><b>submonoid_big_intersect_submonoid</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ smbINTER g &lt;&lt; g
   
   [<a name="submonoid_big_intersect_subset-val"><b>submonoid_big_intersect_subset</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ (smbINTER g).carrier ⊆ G
   
   [<a name="submonoid_carrier_antisym-val"><b>submonoid_carrier_antisym</b></a>]  Theorem
      
      ⊢ ∀g h. submonoid h g ∧ G ⊆ H ⇒ MonoidIso I h g
   
   [<a name="submonoid_carrier_subset-val"><b>submonoid_carrier_subset</b></a>]  Theorem
      
      ⊢ ∀g h. h &lt;&lt; g ⇒ H ⊆ G
   
   [<a name="submonoid_element-val"><b>submonoid_element</b></a>]  Theorem
      
      ⊢ ∀g h. h &lt;&lt; g ⇒ ∀x. x ∈ H ⇒ x ∈ G
   
   [<a name="submonoid_eqn-val"><b>submonoid_eqn</b></a>]  Theorem
      
      ⊢ ∀g h.
          submonoid h g ⇔
          H ⊆ G ∧ (∀x y. x ∈ H ∧ y ∈ H ⇒ x ∘ y = x * y) ∧ #i = #e
   
   [<a name="submonoid_exp-val"><b>submonoid_exp</b></a>]  Theorem
      
      ⊢ ∀g h. h &lt;&lt; g ⇒ ∀x. x ∈ H ⇒ ∀n. h.exp x n = x ** n
   
   [<a name="submonoid_homo_homo-val"><b>submonoid_homo_homo</b></a>]  Theorem
      
      ⊢ ∀g h k f. submonoid h g ∧ MonoidHomo f g k ⇒ MonoidHomo f h k
   
   [<a name="submonoid_homomorphism-val"><b>submonoid_homomorphism</b></a>]  Theorem
      
      ⊢ ∀g h. h &lt;&lt; g ⇒ Monoid h ∧ Monoid g ∧ submonoid h g
   
   [<a name="submonoid_id-val"><b>submonoid_id</b></a>]  Theorem
      
      ⊢ ∀g h. h &lt;&lt; g ⇒ #i = #e
   
   [<a name="submonoid_intersect_monoid-val"><b>submonoid_intersect_monoid</b></a>]  Theorem
      
      ⊢ ∀g h k. h &lt;&lt; g ∧ k &lt;&lt; g ⇒ Monoid (h mINTER k)
   
   [<a name="submonoid_intersect_property-val"><b>submonoid_intersect_property</b></a>]  Theorem
      
      ⊢ ∀g h k.
          h &lt;&lt; g ∧ k &lt;&lt; g ⇒
          (h mINTER k).carrier = H ∩ K ∧
          (∀x y. x ∈ H ∩ K ∧ y ∈ H ∩ K ⇒ (h mINTER k).op x y = x * y) ∧
          (h mINTER k).id = #e
   
   [<a name="submonoid_intersect_submonoid-val"><b>submonoid_intersect_submonoid</b></a>]  Theorem
      
      ⊢ ∀g h k. h &lt;&lt; g ∧ k &lt;&lt; g ⇒ (h mINTER k) &lt;&lt; g
   
   [<a name="submonoid_monoid-val"><b>submonoid_monoid</b></a>]  Theorem
      
      ⊢ ∀g h. h &lt;&lt; g ⇒ Monoid h
   
   [<a name="submonoid_op-val"><b>submonoid_op</b></a>]  Theorem
      
      ⊢ ∀g h. h &lt;&lt; g ⇒ $o = $*
   
   [<a name="submonoid_order-val"><b>submonoid_order</b></a>]  Theorem
      
      ⊢ ∀g h. h &lt;&lt; g ⇒ ∀x. x ∈ H ⇒ order h x = ord x
   
   [<a name="submonoid_order_eqn-val"><b>submonoid_order_eqn</b></a>]  Theorem
      
      ⊢ ∀g h.
          Monoid g ∧ Monoid h ∧ submonoid h g ⇒
          ∀x. x ∈ H ⇒ order h x = ord x
   
   [<a name="submonoid_property-val"><b>submonoid_property</b></a>]  Theorem
      
      ⊢ ∀g h.
          h &lt;&lt; g ⇒
          Monoid h ∧ Monoid g ∧ H ⊆ G ∧
          (∀x y. x ∈ H ∧ y ∈ H ⇒ x ∘ y = x * y) ∧ #i = #e
   
   [<a name="submonoid_refl-val"><b>submonoid_refl</b></a>]  Theorem
      
      ⊢ ∀g. submonoid g g
   
   [<a name="submonoid_reflexive-val"><b>submonoid_reflexive</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ g &lt;&lt; g
   
   [<a name="submonoid_subset-val"><b>submonoid_subset</b></a>]  Theorem
      
      ⊢ ∀g h. submonoid h g ⇒ H ⊆ G
   
   [<a name="submonoid_trans-val"><b>submonoid_trans</b></a>]  Theorem
      
      ⊢ ∀g h k. submonoid g h ∧ submonoid h k ⇒ submonoid g k
   
   [<a name="submonoid_transitive-val"><b>submonoid_transitive</b></a>]  Theorem
      
      ⊢ ∀g h k. k &lt;&lt; h ∧ h &lt;&lt; g ⇒ k &lt;&lt; g
   
   [<a name="times_mod_abelian_monoid-val"><b>times_mod_abelian_monoid</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ AbelianMonoid (times_mod n)
   
   [<a name="times_mod_eval-val"><b>times_mod_eval</b></a>]  Theorem
      
      ⊢ ∀n. (times_mod n).carrier = count n ∧
            (∀x y. (times_mod n).op x y = (x * y) MOD n) ∧
            (times_mod n).id = if n = 1 then 0 else 1
   
   [<a name="times_mod_exp-val"><b>times_mod_exp</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀x k. (times_mod n).exp x k = (x MOD n) ** k MOD n
   
   [<a name="times_mod_finite-val"><b>times_mod_finite</b></a>]  Theorem
      
      ⊢ ∀n. FINITE (times_mod n).carrier
   
   [<a name="times_mod_finite_abelian_monoid-val"><b>times_mod_finite_abelian_monoid</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ FiniteAbelianMonoid (times_mod n)
   
   [<a name="times_mod_finite_monoid-val"><b>times_mod_finite_monoid</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ FiniteMonoid (times_mod n)
   
   [<a name="times_mod_monoid-val"><b>times_mod_monoid</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ Monoid (times_mod n)
   
   [<a name="times_mod_property-val"><b>times_mod_property</b></a>]  Theorem
      
      ⊢ ∀n. (times_mod n).carrier = count n ∧
            (times_mod n).op = (λi j. (i * j) MOD n) ∧
            (times_mod n).id = (if n = 1 then 0 else 1) ∧
            (∀x. x ∈ (times_mod n).carrier ⇒ x &lt; n) ∧
            FINITE (times_mod n).carrier ∧ CARD (times_mod n).carrier = n
   
   [<a name="trivial_monoid-val"><b>trivial_monoid</b></a>]  Theorem
      
      ⊢ ∀e. FiniteAbelianMonoid (trivial_monoid e)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/algebra/construction/.hol/objs/monoidScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-2</a></em></p></body></html>
