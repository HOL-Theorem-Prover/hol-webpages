<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure monoidTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure monoidTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/algebra/construction/.hol/objs/monoidScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature monoidTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#AbelianMonoid_def-val">AbelianMonoid_def</a> : thm
<a name="line7"></a>    val <a href="#FiniteAbelianMonoid_def-val">FiniteAbelianMonoid_def</a> : thm
<a name="line8"></a>    val <a href="#FiniteMonoid_def-val">FiniteMonoid_def</a> : thm
<a name="line9"></a>    val <a href="#GPROD_SET_def-val">GPROD_SET_def</a> : thm
<a name="line10"></a>    val <a href="#Invertibles_def-val">Invertibles_def</a> : thm
<a name="line11"></a>    val <a href="#MonoidAuto_def-val">MonoidAuto_def</a> : thm
<a name="line12"></a>    val <a href="#MonoidEndo_def-val">MonoidEndo_def</a> : thm
<a name="line13"></a>    val <a href="#MonoidHomo_def-val">MonoidHomo_def</a> : thm
<a name="line14"></a>    val <a href="#MonoidIso_def-val">MonoidIso_def</a> : thm
<a name="line15"></a>    val <a href="#Monoid_def-val">Monoid_def</a> : thm
<a name="line16"></a>    val <a href="#Submonoid_def-val">Submonoid_def</a> : thm
<a name="line17"></a>    val <a href="#WeakHomo_def-val">WeakHomo_def</a> : thm
<a name="line18"></a>    val <a href="#WeakIso_def-val">WeakIso_def</a> : thm
<a name="line19"></a>    val <a href="#addition_monoid_def-val">addition_monoid_def</a> : thm
<a name="line20"></a>    val <a href="#extend_def-val">extend_def</a> : thm
<a name="line21"></a>    val <a href="#homo_monoid_def-val">homo_monoid_def</a> : thm
<a name="line22"></a>    val <a href="#image_op_def-val">image_op_def</a> : thm
<a name="line23"></a>    val <a href="#lists_def-val">lists_def</a> : thm
<a name="line24"></a>    val <a href="#monoid_TY_DEF-val">monoid_TY_DEF</a> : thm
<a name="line25"></a>    val <a href="#monoid_case_def-val">monoid_case_def</a> : thm
<a name="line26"></a>    val <a href="#monoid_exp_def-val">monoid_exp_def</a> : thm
<a name="line27"></a>    val <a href="#monoid_inj_image_def-val">monoid_inj_image_def</a> : thm
<a name="line28"></a>    val <a href="#monoid_intersect_def-val">monoid_intersect_def</a> : thm
<a name="line29"></a>    val <a href="#monoid_inv_def-val">monoid_inv_def</a> : thm
<a name="line30"></a>    val <a href="#monoid_invertibles_def-val">monoid_invertibles_def</a> : thm
<a name="line31"></a>    val <a href="#monoid_size_def-val">monoid_size_def</a> : thm
<a name="line32"></a>    val <a href="#multiplication_monoid_def-val">multiplication_monoid_def</a> : thm
<a name="line33"></a>    val <a href="#order_def-val">order_def</a> : thm
<a name="line34"></a>    val <a href="#orders_def-val">orders_def</a> : thm
<a name="line35"></a>    val <a href="#period_def-val">period_def</a> : thm
<a name="line36"></a>    val <a href="#plus_mod_def-val">plus_mod_def</a> : thm
<a name="line37"></a>    val <a href="#power_monoid_def-val">power_monoid_def</a> : thm
<a name="line38"></a>    val <a href="#recordtype_monoid_seldef_carrier_def-val">recordtype_monoid_seldef_carrier_def</a> : thm
<a name="line39"></a>    val <a href="#recordtype_monoid_seldef_carrier_fupd_def-val">recordtype_monoid_seldef_carrier_fupd_def</a> : thm
<a name="line40"></a>    val <a href="#recordtype_monoid_seldef_id_def-val">recordtype_monoid_seldef_id_def</a> : thm
<a name="line41"></a>    val <a href="#recordtype_monoid_seldef_id_fupd_def-val">recordtype_monoid_seldef_id_fupd_def</a> : thm
<a name="line42"></a>    val <a href="#recordtype_monoid_seldef_op_def-val">recordtype_monoid_seldef_op_def</a> : thm
<a name="line43"></a>    val <a href="#recordtype_monoid_seldef_op_fupd_def-val">recordtype_monoid_seldef_op_fupd_def</a> : thm
<a name="line44"></a>    val <a href="#set_inter_def-val">set_inter_def</a> : thm
<a name="line45"></a>    val <a href="#set_union_def-val">set_union_def</a> : thm
<a name="line46"></a>    val <a href="#submonoid_big_intersect_def-val">submonoid_big_intersect_def</a> : thm
<a name="line47"></a>    val <a href="#submonoid_def-val">submonoid_def</a> : thm
<a name="line48"></a>    val <a href="#times_mod_def-val">times_mod_def</a> : thm
<a name="line49"></a>    val <a href="#trivial_monoid_def-val">trivial_monoid_def</a> : thm
<a name="line50"></a>  
<a name="line51"></a>  (*  Theorems  *)
<a name="line52"></a>    val <a href="#COMMUTING_GITBAG_INSERT-val">COMMUTING_GITBAG_INSERT</a> : thm
<a name="line53"></a>    val <a href="#COMMUTING_GITSET_INSERT-val">COMMUTING_GITSET_INSERT</a> : thm
<a name="line54"></a>    val <a href="#COMMUTING_GITSET_RECURSES-val">COMMUTING_GITSET_RECURSES</a> : thm
<a name="line55"></a>    val <a href="#COMMUTING_GITSET_REDUCTION-val">COMMUTING_GITSET_REDUCTION</a> : thm
<a name="line56"></a>    val <a href="#EXISTS_monoid-val">EXISTS_monoid</a> : thm
<a name="line57"></a>    val <a href="#FORALL_monoid-val">FORALL_monoid</a> : thm
<a name="line58"></a>    val <a href="#FiniteAbelianMonoid_def_alt-val">FiniteAbelianMonoid_def_alt</a> : thm
<a name="line59"></a>    val <a href="#GBAG_IMAGE_FILTER-val">GBAG_IMAGE_FILTER</a> : thm
<a name="line60"></a>    val <a href="#GBAG_IMAGE_PARTITION-val">GBAG_IMAGE_PARTITION</a> : thm
<a name="line61"></a>    val <a href="#GBAG_INSERT-val">GBAG_INSERT</a> : thm
<a name="line62"></a>    val <a href="#GBAG_PARTITION-val">GBAG_PARTITION</a> : thm
<a name="line63"></a>    val <a href="#GBAG_UNION-val">GBAG_UNION</a> : thm
<a name="line64"></a>    val <a href="#GBAG_in_carrier-val">GBAG_in_carrier</a> : thm
<a name="line65"></a>    val <a href="#GITBAG_BAG_IMAGE_op-val">GITBAG_BAG_IMAGE_op</a> : thm
<a name="line66"></a>    val <a href="#GITBAG_CONG-val">GITBAG_CONG</a> : thm
<a name="line67"></a>    val <a href="#GITBAG_EMPTY-val">GITBAG_EMPTY</a> : thm
<a name="line68"></a>    val <a href="#GITBAG_GBAG-val">GITBAG_GBAG</a> : thm
<a name="line69"></a>    val <a href="#GITBAG_INSERT-val">GITBAG_INSERT</a> : thm
<a name="line70"></a>    val <a href="#GITBAG_INSERT_THM-val">GITBAG_INSERT_THM</a> : thm
<a name="line71"></a>    val <a href="#GITBAG_THM-val">GITBAG_THM</a> : thm
<a name="line72"></a>    val <a href="#GITBAG_UNION-val">GITBAG_UNION</a> : thm
<a name="line73"></a>    val <a href="#GITBAG_in_carrier-val">GITBAG_in_carrier</a> : thm
<a name="line74"></a>    val <a href="#GITBAG_same_op-val">GITBAG_same_op</a> : thm
<a name="line75"></a>    val <a href="#GITSET_EMPTY-val">GITSET_EMPTY</a> : thm
<a name="line76"></a>    val <a href="#GITSET_INSERT-val">GITSET_INSERT</a> : thm
<a name="line77"></a>    val <a href="#GITSET_PROPERTY-val">GITSET_PROPERTY</a> : thm
<a name="line78"></a>    val <a href="#GITSET_THM-val">GITSET_THM</a> : thm
<a name="line79"></a>    val <a href="#GPROD_SET_EMPTY-val">GPROD_SET_EMPTY</a> : thm
<a name="line80"></a>    val <a href="#GPROD_SET_PROPERTY-val">GPROD_SET_PROPERTY</a> : thm
<a name="line81"></a>    val <a href="#GPROD_SET_SING-val">GPROD_SET_SING</a> : thm
<a name="line82"></a>    val <a href="#GPROD_SET_THM-val">GPROD_SET_THM</a> : thm
<a name="line83"></a>    val <a href="#IMP_GBAG_EQ_EXP-val">IMP_GBAG_EQ_EXP</a> : thm
<a name="line84"></a>    val <a href="#IMP_GBAG_EQ_ID-val">IMP_GBAG_EQ_ID</a> : thm
<a name="line85"></a>    val <a href="#Invertibles_carrier-val">Invertibles_carrier</a> : thm
<a name="line86"></a>    val <a href="#Invertibles_order-val">Invertibles_order</a> : thm
<a name="line87"></a>    val <a href="#Invertibles_property-val">Invertibles_property</a> : thm
<a name="line88"></a>    val <a href="#Invertibles_subset-val">Invertibles_subset</a> : thm
<a name="line89"></a>    val <a href="#MonoidHomo_GBAG-val">MonoidHomo_GBAG</a> : thm
<a name="line90"></a>    val <a href="#SUBSET_COMMUTING_ITBAG_INSERT-val">SUBSET_COMMUTING_ITBAG_INSERT</a> : thm
<a name="line91"></a>    val <a href="#abelian_monoid_op_closure_comm_assoc_fun-val">abelian_monoid_op_closure_comm_assoc_fun</a> : thm
<a name="line92"></a>    val <a href="#abelian_monoid_order_common-val">abelian_monoid_order_common</a> : thm
<a name="line93"></a>    val <a href="#abelian_monoid_order_common_coprime-val">abelian_monoid_order_common_coprime</a> : thm
<a name="line94"></a>    val <a href="#abelian_monoid_order_lcm-val">abelian_monoid_order_lcm</a> : thm
<a name="line95"></a>    val <a href="#addition_monoid_abelian_monoid-val">addition_monoid_abelian_monoid</a> : thm
<a name="line96"></a>    val <a href="#addition_monoid_monoid-val">addition_monoid_monoid</a> : thm
<a name="line97"></a>    val <a href="#addition_monoid_property-val">addition_monoid_property</a> : thm
<a name="line98"></a>    val <a href="#datatype_monoid-val">datatype_monoid</a> : thm
<a name="line99"></a>    val <a href="#extend_carrier-val">extend_carrier</a> : thm
<a name="line100"></a>    val <a href="#extend_id-val">extend_id</a> : thm
<a name="line101"></a>    val <a href="#extend_is_monoid-val">extend_is_monoid</a> : thm
<a name="line102"></a>    val <a href="#extend_op-val">extend_op</a> : thm
<a name="line103"></a>    val <a href="#finite_monoid_exp_not_distinct-val">finite_monoid_exp_not_distinct</a> : thm
<a name="line104"></a>    val <a href="#homo_monoid_I-val">homo_monoid_I</a> : thm
<a name="line105"></a>    val <a href="#homo_monoid_abelian_monoid-val">homo_monoid_abelian_monoid</a> : thm
<a name="line106"></a>    val <a href="#homo_monoid_assoc-val">homo_monoid_assoc</a> : thm
<a name="line107"></a>    val <a href="#homo_monoid_by_inj-val">homo_monoid_by_inj</a> : thm
<a name="line108"></a>    val <a href="#homo_monoid_closure-val">homo_monoid_closure</a> : thm
<a name="line109"></a>    val <a href="#homo_monoid_comm-val">homo_monoid_comm</a> : thm
<a name="line110"></a>    val <a href="#homo_monoid_element-val">homo_monoid_element</a> : thm
<a name="line111"></a>    val <a href="#homo_monoid_id-val">homo_monoid_id</a> : thm
<a name="line112"></a>    val <a href="#homo_monoid_id_property-val">homo_monoid_id_property</a> : thm
<a name="line113"></a>    val <a href="#homo_monoid_monoid-val">homo_monoid_monoid</a> : thm
<a name="line114"></a>    val <a href="#homo_monoid_op_inj-val">homo_monoid_op_inj</a> : thm
<a name="line115"></a>    val <a href="#homo_monoid_property-val">homo_monoid_property</a> : thm
<a name="line116"></a>    val <a href="#image_op_inj-val">image_op_inj</a> : thm
<a name="line117"></a>    val <a href="#lists_monoid-val">lists_monoid</a> : thm
<a name="line118"></a>    val <a href="#maximal_order_alt-val">maximal_order_alt</a> : thm
<a name="line119"></a>    val <a href="#monoid_11-val">monoid_11</a> : thm
<a name="line120"></a>    val <a href="#monoid_Axiom-val">monoid_Axiom</a> : thm
<a name="line121"></a>    val <a href="#monoid_accessors-val">monoid_accessors</a> : thm
<a name="line122"></a>    val <a href="#monoid_accfupds-val">monoid_accfupds</a> : thm
<a name="line123"></a>    val <a href="#monoid_assoc-val">monoid_assoc</a> : thm
<a name="line124"></a>    val <a href="#monoid_auto_I-val">monoid_auto_I</a> : thm
<a name="line125"></a>    val <a href="#monoid_auto_bij-val">monoid_auto_bij</a> : thm
<a name="line126"></a>    val <a href="#monoid_auto_compose-val">monoid_auto_compose</a> : thm
<a name="line127"></a>    val <a href="#monoid_auto_element-val">monoid_auto_element</a> : thm
<a name="line128"></a>    val <a href="#monoid_auto_exp-val">monoid_auto_exp</a> : thm
<a name="line129"></a>    val <a href="#monoid_auto_id-val">monoid_auto_id</a> : thm
<a name="line130"></a>    val <a href="#monoid_auto_linv_auto-val">monoid_auto_linv_auto</a> : thm
<a name="line131"></a>    val <a href="#monoid_auto_order-val">monoid_auto_order</a> : thm
<a name="line132"></a>    val <a href="#monoid_carrier_nonempty-val">monoid_carrier_nonempty</a> : thm
<a name="line133"></a>    val <a href="#monoid_case_cong-val">monoid_case_cong</a> : thm
<a name="line134"></a>    val <a href="#monoid_case_eq-val">monoid_case_eq</a> : thm
<a name="line135"></a>    val <a href="#monoid_comm_exp-val">monoid_comm_exp</a> : thm
<a name="line136"></a>    val <a href="#monoid_comm_exp_exp-val">monoid_comm_exp_exp</a> : thm
<a name="line137"></a>    val <a href="#monoid_comm_op_exp-val">monoid_comm_op_exp</a> : thm
<a name="line138"></a>    val <a href="#monoid_component_equality-val">monoid_component_equality</a> : thm
<a name="line139"></a>    val <a href="#monoid_exp_0-val">monoid_exp_0</a> : thm
<a name="line140"></a>    val <a href="#monoid_exp_1-val">monoid_exp_1</a> : thm
<a name="line141"></a>    val <a href="#monoid_exp_SUC-val">monoid_exp_SUC</a> : thm
<a name="line142"></a>    val <a href="#monoid_exp_add-val">monoid_exp_add</a> : thm
<a name="line143"></a>    val <a href="#monoid_exp_comm-val">monoid_exp_comm</a> : thm
<a name="line144"></a>    val <a href="#monoid_exp_element-val">monoid_exp_element</a> : thm
<a name="line145"></a>    val <a href="#monoid_exp_mod_order-val">monoid_exp_mod_order</a> : thm
<a name="line146"></a>    val <a href="#monoid_exp_mult-val">monoid_exp_mult</a> : thm
<a name="line147"></a>    val <a href="#monoid_exp_mult_comm-val">monoid_exp_mult_comm</a> : thm
<a name="line148"></a>    val <a href="#monoid_exp_suc-val">monoid_exp_suc</a> : thm
<a name="line149"></a>    val <a href="#monoid_fn_updates-val">monoid_fn_updates</a> : thm
<a name="line150"></a>    val <a href="#monoid_fupdcanon-val">monoid_fupdcanon</a> : thm
<a name="line151"></a>    val <a href="#monoid_fupdcanon_comp-val">monoid_fupdcanon_comp</a> : thm
<a name="line152"></a>    val <a href="#monoid_fupdfupds-val">monoid_fupdfupds</a> : thm
<a name="line153"></a>    val <a href="#monoid_fupdfupds_comp-val">monoid_fupdfupds_comp</a> : thm
<a name="line154"></a>    val <a href="#monoid_homo_I_refl-val">monoid_homo_I_refl</a> : thm
<a name="line155"></a>    val <a href="#monoid_homo_compose-val">monoid_homo_compose</a> : thm
<a name="line156"></a>    val <a href="#monoid_homo_cong-val">monoid_homo_cong</a> : thm
<a name="line157"></a>    val <a href="#monoid_homo_element-val">monoid_homo_element</a> : thm
<a name="line158"></a>    val <a href="#monoid_homo_exp-val">monoid_homo_exp</a> : thm
<a name="line159"></a>    val <a href="#monoid_homo_id-val">monoid_homo_id</a> : thm
<a name="line160"></a>    val <a href="#monoid_homo_sym-val">monoid_homo_sym</a> : thm
<a name="line161"></a>    val <a href="#monoid_homo_sym_any-val">monoid_homo_sym_any</a> : thm
<a name="line162"></a>    val <a href="#monoid_homo_trans-val">monoid_homo_trans</a> : thm
<a name="line163"></a>    val <a href="#monoid_id-val">monoid_id</a> : thm
<a name="line164"></a>    val <a href="#monoid_id_element-val">monoid_id_element</a> : thm
<a name="line165"></a>    val <a href="#monoid_id_exp-val">monoid_id_exp</a> : thm
<a name="line166"></a>    val <a href="#monoid_id_id-val">monoid_id_id</a> : thm
<a name="line167"></a>    val <a href="#monoid_id_invertible-val">monoid_id_invertible</a> : thm
<a name="line168"></a>    val <a href="#monoid_id_unique-val">monoid_id_unique</a> : thm
<a name="line169"></a>    val <a href="#monoid_induction-val">monoid_induction</a> : thm
<a name="line170"></a>    val <a href="#monoid_inj_image_abelian_monoid-val">monoid_inj_image_abelian_monoid</a> : thm
<a name="line171"></a>    val <a href="#monoid_inj_image_monoid-val">monoid_inj_image_monoid</a> : thm
<a name="line172"></a>    val <a href="#monoid_inj_image_monoid_homo-val">monoid_inj_image_monoid_homo</a> : thm
<a name="line173"></a>    val <a href="#monoid_intersect_element-val">monoid_intersect_element</a> : thm
<a name="line174"></a>    val <a href="#monoid_intersect_id-val">monoid_intersect_id</a> : thm
<a name="line175"></a>    val <a href="#monoid_intersect_property-val">monoid_intersect_property</a> : thm
<a name="line176"></a>    val <a href="#monoid_inv_def_alt-val">monoid_inv_def_alt</a> : thm
<a name="line177"></a>    val <a href="#monoid_inv_element-val">monoid_inv_element</a> : thm
<a name="line178"></a>    val <a href="#monoid_inv_from_invertibles-val">monoid_inv_from_invertibles</a> : thm
<a name="line179"></a>    val <a href="#monoid_inv_invertible-val">monoid_inv_invertible</a> : thm
<a name="line180"></a>    val <a href="#monoid_inv_op_invertible-val">monoid_inv_op_invertible</a> : thm
<a name="line181"></a>    val <a href="#monoid_invertibles_element-val">monoid_invertibles_element</a> : thm
<a name="line182"></a>    val <a href="#monoid_invertibles_is_monoid-val">monoid_invertibles_is_monoid</a> : thm
<a name="line183"></a>    val <a href="#monoid_iso_I_refl-val">monoid_iso_I_refl</a> : thm
<a name="line184"></a>    val <a href="#monoid_iso_bij-val">monoid_iso_bij</a> : thm
<a name="line185"></a>    val <a href="#monoid_iso_card_eq-val">monoid_iso_card_eq</a> : thm
<a name="line186"></a>    val <a href="#monoid_iso_compose-val">monoid_iso_compose</a> : thm
<a name="line187"></a>    val <a href="#monoid_iso_element-val">monoid_iso_element</a> : thm
<a name="line188"></a>    val <a href="#monoid_iso_eq_id-val">monoid_iso_eq_id</a> : thm
<a name="line189"></a>    val <a href="#monoid_iso_exp-val">monoid_iso_exp</a> : thm
<a name="line190"></a>    val <a href="#monoid_iso_id-val">monoid_iso_id</a> : thm
<a name="line191"></a>    val <a href="#monoid_iso_linv_iso-val">monoid_iso_linv_iso</a> : thm
<a name="line192"></a>    val <a href="#monoid_iso_monoid-val">monoid_iso_monoid</a> : thm
<a name="line193"></a>    val <a href="#monoid_iso_order-val">monoid_iso_order</a> : thm
<a name="line194"></a>    val <a href="#monoid_iso_property-val">monoid_iso_property</a> : thm
<a name="line195"></a>    val <a href="#monoid_iso_sym-val">monoid_iso_sym</a> : thm
<a name="line196"></a>    val <a href="#monoid_iso_trans-val">monoid_iso_trans</a> : thm
<a name="line197"></a>    val <a href="#monoid_lid-val">monoid_lid</a> : thm
<a name="line198"></a>    val <a href="#monoid_lid_unique-val">monoid_lid_unique</a> : thm
<a name="line199"></a>    val <a href="#monoid_literal_11-val">monoid_literal_11</a> : thm
<a name="line200"></a>    val <a href="#monoid_literal_nchotomy-val">monoid_literal_nchotomy</a> : thm
<a name="line201"></a>    val <a href="#monoid_nchotomy-val">monoid_nchotomy</a> : thm
<a name="line202"></a>    val <a href="#monoid_op_element-val">monoid_op_element</a> : thm
<a name="line203"></a>    val <a href="#monoid_order_cofactor-val">monoid_order_cofactor</a> : thm
<a name="line204"></a>    val <a href="#monoid_order_common-val">monoid_order_common</a> : thm
<a name="line205"></a>    val <a href="#monoid_order_common_coprime-val">monoid_order_common_coprime</a> : thm
<a name="line206"></a>    val <a href="#monoid_order_condition-val">monoid_order_condition</a> : thm
<a name="line207"></a>    val <a href="#monoid_order_divides_exp-val">monoid_order_divides_exp</a> : thm
<a name="line208"></a>    val <a href="#monoid_order_divides_maximal-val">monoid_order_divides_maximal</a> : thm
<a name="line209"></a>    val <a href="#monoid_order_divisor-val">monoid_order_divisor</a> : thm
<a name="line210"></a>    val <a href="#monoid_order_eq_1-val">monoid_order_eq_1</a> : thm
<a name="line211"></a>    val <a href="#monoid_order_id-val">monoid_order_id</a> : thm
<a name="line212"></a>    val <a href="#monoid_order_nonzero-val">monoid_order_nonzero</a> : thm
<a name="line213"></a>    val <a href="#monoid_order_power-val">monoid_order_power</a> : thm
<a name="line214"></a>    val <a href="#monoid_order_power_coprime-val">monoid_order_power_coprime</a> : thm
<a name="line215"></a>    val <a href="#monoid_order_power_eq_0-val">monoid_order_power_eq_0</a> : thm
<a name="line216"></a>    val <a href="#monoid_order_power_eqn-val">monoid_order_power_eqn</a> : thm
<a name="line217"></a>    val <a href="#monoid_rid-val">monoid_rid</a> : thm
<a name="line218"></a>    val <a href="#monoid_rid_unique-val">monoid_rid_unique</a> : thm
<a name="line219"></a>    val <a href="#monoid_updates_eq_literal-val">monoid_updates_eq_literal</a> : thm
<a name="line220"></a>    val <a href="#monoid_weak_iso_id-val">monoid_weak_iso_id</a> : thm
<a name="line221"></a>    val <a href="#multiplication_monoid_abelian_monoid-val">multiplication_monoid_abelian_monoid</a> : thm
<a name="line222"></a>    val <a href="#multiplication_monoid_monoid-val">multiplication_monoid_monoid</a> : thm
<a name="line223"></a>    val <a href="#multiplication_monoid_property-val">multiplication_monoid_property</a> : thm
<a name="line224"></a>    val <a href="#order_alt-val">order_alt</a> : thm
<a name="line225"></a>    val <a href="#order_eq_0-val">order_eq_0</a> : thm
<a name="line226"></a>    val <a href="#order_minimal-val">order_minimal</a> : thm
<a name="line227"></a>    val <a href="#order_period-val">order_period</a> : thm
<a name="line228"></a>    val <a href="#order_property-val">order_property</a> : thm
<a name="line229"></a>    val <a href="#order_thm-val">order_thm</a> : thm
<a name="line230"></a>    val <a href="#orders_element-val">orders_element</a> : thm
<a name="line231"></a>    val <a href="#orders_eq_1-val">orders_eq_1</a> : thm
<a name="line232"></a>    val <a href="#orders_finite-val">orders_finite</a> : thm
<a name="line233"></a>    val <a href="#orders_subset-val">orders_subset</a> : thm
<a name="line234"></a>    val <a href="#plus_mod_abelian_monoid-val">plus_mod_abelian_monoid</a> : thm
<a name="line235"></a>    val <a href="#plus_mod_exp-val">plus_mod_exp</a> : thm
<a name="line236"></a>    val <a href="#plus_mod_finite-val">plus_mod_finite</a> : thm
<a name="line237"></a>    val <a href="#plus_mod_finite_abelian_monoid-val">plus_mod_finite_abelian_monoid</a> : thm
<a name="line238"></a>    val <a href="#plus_mod_finite_monoid-val">plus_mod_finite_monoid</a> : thm
<a name="line239"></a>    val <a href="#plus_mod_monoid-val">plus_mod_monoid</a> : thm
<a name="line240"></a>    val <a href="#plus_mod_property-val">plus_mod_property</a> : thm
<a name="line241"></a>    val <a href="#power_monoid_abelian_monoid-val">power_monoid_abelian_monoid</a> : thm
<a name="line242"></a>    val <a href="#power_monoid_monoid-val">power_monoid_monoid</a> : thm
<a name="line243"></a>    val <a href="#power_monoid_property-val">power_monoid_property</a> : thm
<a name="line244"></a>    val <a href="#power_to_addition_homo-val">power_to_addition_homo</a> : thm
<a name="line245"></a>    val <a href="#power_to_addition_iso-val">power_to_addition_iso</a> : thm
<a name="line246"></a>    val <a href="#set_inter_abelian_monoid-val">set_inter_abelian_monoid</a> : thm
<a name="line247"></a>    val <a href="#set_inter_monoid-val">set_inter_monoid</a> : thm
<a name="line248"></a>    val <a href="#set_union_abelian_monoid-val">set_union_abelian_monoid</a> : thm
<a name="line249"></a>    val <a href="#set_union_monoid-val">set_union_monoid</a> : thm
<a name="line250"></a>    val <a href="#submonoid_I_antisym-val">submonoid_I_antisym</a> : thm
<a name="line251"></a>    val <a href="#submonoid_alt-val">submonoid_alt</a> : thm
<a name="line252"></a>    val <a href="#submonoid_antisymmetric-val">submonoid_antisymmetric</a> : thm
<a name="line253"></a>    val <a href="#submonoid_big_intersect_element-val">submonoid_big_intersect_element</a> : thm
<a name="line254"></a>    val <a href="#submonoid_big_intersect_has_id-val">submonoid_big_intersect_has_id</a> : thm
<a name="line255"></a>    val <a href="#submonoid_big_intersect_monoid-val">submonoid_big_intersect_monoid</a> : thm
<a name="line256"></a>    val <a href="#submonoid_big_intersect_op_element-val">submonoid_big_intersect_op_element</a> : thm
<a name="line257"></a>    val <a href="#submonoid_big_intersect_property-val">submonoid_big_intersect_property</a> : thm
<a name="line258"></a>    val <a href="#submonoid_big_intersect_submonoid-val">submonoid_big_intersect_submonoid</a> : thm
<a name="line259"></a>    val <a href="#submonoid_big_intersect_subset-val">submonoid_big_intersect_subset</a> : thm
<a name="line260"></a>    val <a href="#submonoid_carrier_antisym-val">submonoid_carrier_antisym</a> : thm
<a name="line261"></a>    val <a href="#submonoid_carrier_subset-val">submonoid_carrier_subset</a> : thm
<a name="line262"></a>    val <a href="#submonoid_element-val">submonoid_element</a> : thm
<a name="line263"></a>    val <a href="#submonoid_eqn-val">submonoid_eqn</a> : thm
<a name="line264"></a>    val <a href="#submonoid_exp-val">submonoid_exp</a> : thm
<a name="line265"></a>    val <a href="#submonoid_homo_homo-val">submonoid_homo_homo</a> : thm
<a name="line266"></a>    val <a href="#submonoid_homomorphism-val">submonoid_homomorphism</a> : thm
<a name="line267"></a>    val <a href="#submonoid_id-val">submonoid_id</a> : thm
<a name="line268"></a>    val <a href="#submonoid_intersect_monoid-val">submonoid_intersect_monoid</a> : thm
<a name="line269"></a>    val <a href="#submonoid_intersect_property-val">submonoid_intersect_property</a> : thm
<a name="line270"></a>    val <a href="#submonoid_intersect_submonoid-val">submonoid_intersect_submonoid</a> : thm
<a name="line271"></a>    val <a href="#submonoid_monoid-val">submonoid_monoid</a> : thm
<a name="line272"></a>    val <a href="#submonoid_op-val">submonoid_op</a> : thm
<a name="line273"></a>    val <a href="#submonoid_order-val">submonoid_order</a> : thm
<a name="line274"></a>    val <a href="#submonoid_order_eqn-val">submonoid_order_eqn</a> : thm
<a name="line275"></a>    val <a href="#submonoid_property-val">submonoid_property</a> : thm
<a name="line276"></a>    val <a href="#submonoid_refl-val">submonoid_refl</a> : thm
<a name="line277"></a>    val <a href="#submonoid_reflexive-val">submonoid_reflexive</a> : thm
<a name="line278"></a>    val <a href="#submonoid_subset-val">submonoid_subset</a> : thm
<a name="line279"></a>    val <a href="#submonoid_trans-val">submonoid_trans</a> : thm
<a name="line280"></a>    val <a href="#submonoid_transitive-val">submonoid_transitive</a> : thm
<a name="line281"></a>    val <a href="#times_mod_abelian_monoid-val">times_mod_abelian_monoid</a> : thm
<a name="line282"></a>    val <a href="#times_mod_eval-val">times_mod_eval</a> : thm
<a name="line283"></a>    val <a href="#times_mod_exp-val">times_mod_exp</a> : thm
<a name="line284"></a>    val <a href="#times_mod_finite-val">times_mod_finite</a> : thm
<a name="line285"></a>    val <a href="#times_mod_finite_abelian_monoid-val">times_mod_finite_abelian_monoid</a> : thm
<a name="line286"></a>    val <a href="#times_mod_finite_monoid-val">times_mod_finite_monoid</a> : thm
<a name="line287"></a>    val <a href="#times_mod_monoid-val">times_mod_monoid</a> : thm
<a name="line288"></a>    val <a href="#times_mod_property-val">times_mod_property</a> : thm
<a name="line289"></a>    val <a href="#trivial_monoid-val">trivial_monoid</a> : thm
<a name="line290"></a>(*
   [bag] Parent theory of "monoid"
   
   [prime] Parent theory of "monoid"
   
   [<a name="AbelianMonoid_def-val"><b>AbelianMonoid_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄg. AbelianMonoid g ‚áî
            Monoid g ‚àß ‚àÄx y. x ‚àà G ‚àß y ‚àà G ‚áí x * y = y * x
   
   [<a name="FiniteAbelianMonoid_def-val"><b>FiniteAbelianMonoid_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄg. FiniteAbelianMonoid g ‚áî AbelianMonoid g ‚àß FINITE G
   
   [<a name="FiniteMonoid_def-val"><b>FiniteMonoid_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄg. FiniteMonoid g ‚áî Monoid g ‚àß FINITE G
   
   [<a name="GPROD_SET_def-val"><b>GPROD_SET_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄg s. GPROD_SET g s = GITSET g s #e
   
   [<a name="Invertibles_def-val"><b>Invertibles_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄg. Invertibles g = &lt;|carrier := G*; op := $*; id := #e|&gt;
   
   [<a name="MonoidAuto_def-val"><b>MonoidAuto_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄf g. MonoidAuto f g ‚áî MonoidIso f g g
   
   [<a name="MonoidEndo_def-val"><b>MonoidEndo_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄf g. MonoidEndo f g ‚áî MonoidHomo f g g
   
   [<a name="MonoidHomo_def-val"><b>MonoidHomo_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄf g h.
          MonoidHomo f g h ‚áî
          (‚àÄx. x ‚àà G ‚áí f x ‚àà h.carrier) ‚àß
          (‚àÄx y. x ‚àà G ‚àß y ‚àà G ‚áí f (x * y) = h.op (f x) (f y)) ‚àß
          f #e = h.id
   
   [<a name="MonoidIso_def-val"><b>MonoidIso_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄf g h. MonoidIso f g h ‚áî MonoidHomo f g h ‚àß BIJ f G h.carrier
   
   [<a name="Monoid_def-val"><b>Monoid_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄg. Monoid g ‚áî
            (‚àÄx y. x ‚àà G ‚àß y ‚àà G ‚áí x * y ‚àà G) ‚àß
            (‚àÄx y z. x ‚àà G ‚àß y ‚àà G ‚àß z ‚àà G ‚áí x * y * z = x * (y * z)) ‚àß
            #e ‚àà G ‚àß ‚àÄx. x ‚àà G ‚áí #e * x = x ‚àß x * #e = x
   
   [<a name="Submonoid_def-val"><b>Submonoid_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄh g. h &lt;&lt; g ‚áî Monoid h ‚àß Monoid g ‚àß H ‚äÜ G ‚àß $o = $* ‚àß #i = #e
   
   [<a name="WeakHomo_def-val"><b>WeakHomo_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄf g h.
          WeakHomo f g h ‚áî
          (‚àÄx. x ‚àà G ‚áí f x ‚àà h.carrier) ‚àß
          ‚àÄx y. x ‚àà G ‚àß y ‚àà G ‚áí f (x * y) = h.op (f x) (f y)
   
   [<a name="WeakIso_def-val"><b>WeakIso_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄf g h. WeakIso f g h ‚áî WeakHomo f g h ‚àß BIJ f G h.carrier
   
   [<a name="addition_monoid_def-val"><b>addition_monoid_def</b></a>]  Definition
      
      ‚ä¢ addition_monoid = &lt;|carrier := ùïå(:num); op := $+; id := 0|&gt;
   
   [<a name="extend_def-val"><b>extend_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄm. extend m =
            &lt;|carrier := ùïå(:Œ±); id := m.id;
              op :=
                (Œªx y.
                     if x ‚àà m.carrier then
                       if y ‚àà m.carrier then m.op x y else y
                     else x)|&gt;
   
   [<a name="homo_monoid_def-val"><b>homo_monoid_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄg f.
          homo_monoid g f =
          &lt;|carrier := IMAGE f G; op := image_op g f; id := f #e|&gt;
   
   [<a name="image_op_def-val"><b>image_op_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄg f x y.
          image_op g f x y =
          f (CHOICE (preimage f G x) * CHOICE (preimage f G y))
   
   [<a name="lists_def-val"><b>lists_def</b></a>]  Definition
      
      ‚ä¢ lists = &lt;|carrier := ùïå(:Œ± list); id := []; op := $++ |&gt;
   
   [<a name="monoid_TY_DEF-val"><b>monoid_TY_DEF</b></a>]  Definition
      
      ‚ä¢ ‚àÉrep.
          TYPE_DEFINITION
            (Œªa0'.
                 ‚àÄ $var$('monoid').
                   (‚àÄa0'.
                      (‚àÉa0 a1 a2.
                         a0' =
                         (Œªa0 a1 a2.
                              ind_type$CONSTR 0 (a0,a1,a2)
                                (Œªn. ind_type$BOTTOM)) a0 a1 a2) ‚áí
                      $var$('monoid') a0') ‚áí
                   $var$('monoid') a0') rep
   
   [<a name="monoid_case_def-val"><b>monoid_case_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄa0 a1 a2 f. monoid_CASE (monoid a0 a1 a2) f = f a0 a1 a2
   
   [<a name="monoid_exp_def-val"><b>monoid_exp_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄg x n. x ** n = FUNPOW ($* x) n #e
   
   [<a name="monoid_inj_image_def-val"><b>monoid_inj_image_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄg f.
          monoid_inj_image g f =
          &lt;|carrier := IMAGE f G;
            op := (let t = LINV f G in Œªx y. f (t x * t y)); id := f #e|&gt;
   
   [<a name="monoid_intersect_def-val"><b>monoid_intersect_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄg h. (g mINTER h) = &lt;|carrier := G ‚à© H; op := $*; id := #e|&gt;
   
   [<a name="monoid_inv_def-val"><b>monoid_inv_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄg x. Monoid g ‚àß x ‚àà G* ‚áí |/ x ‚àà G ‚àß x * |/ x = #e ‚àß |/ x * x = #e
   
   [<a name="monoid_invertibles_def-val"><b>monoid_invertibles_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄg. G* = {x | x ‚àà G ‚àß ‚àÉy. y ‚àà G ‚àß x * y = #e ‚àß y * x = #e}
   
   [<a name="monoid_size_def-val"><b>monoid_size_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄf a0 a1 a2. monoid_size f (monoid a0 a1 a2) = 1 + f a2
   
   [<a name="multiplication_monoid_def-val"><b>multiplication_monoid_def</b></a>]  Definition
      
      ‚ä¢ multiplication_monoid = &lt;|carrier := ùïå(:num); op := $*; id := 1|&gt;
   
   [<a name="order_def-val"><b>order_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄg x.
          ord x = case OLEAST k. period g x k of NONE =&gt; 0 | SOME k =&gt; k
   
   [<a name="orders_def-val"><b>orders_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄg n. orders g n = {x | x ‚àà G ‚àß ord x = n}
   
   [<a name="period_def-val"><b>period_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄg x k. period g x k ‚áî 0 &lt; k ‚àß x ** k = #e
   
   [<a name="plus_mod_def-val"><b>plus_mod_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄn. plus_mod n =
            &lt;|carrier := count n; id := 0; op := (Œªi j. (i + j) MOD n)|&gt;
   
   [<a name="power_monoid_def-val"><b>power_monoid_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄb. power_monoid b =
            &lt;|carrier := {b ** j | j ‚àà ùïå(:num)}; op := $*; id := 1|&gt;
   
   [<a name="recordtype_monoid_seldef_carrier_def-val"><b>recordtype_monoid_seldef_carrier_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄf f0 a. (monoid f f0 a).carrier = f
   
   [<a name="recordtype_monoid_seldef_carrier_fupd_def-val"><b>recordtype_monoid_seldef_carrier_fupd_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄf1 f f0 a.
          monoid f f0 a with carrier updated_by f1 = monoid (f1 f) f0 a
   
   [<a name="recordtype_monoid_seldef_id_def-val"><b>recordtype_monoid_seldef_id_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄf f0 a. (monoid f f0 a).id = a
   
   [<a name="recordtype_monoid_seldef_id_fupd_def-val"><b>recordtype_monoid_seldef_id_fupd_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄf1 f f0 a.
          monoid f f0 a with id updated_by f1 = monoid f f0 (f1 a)
   
   [<a name="recordtype_monoid_seldef_op_def-val"><b>recordtype_monoid_seldef_op_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄf f0 a. (monoid f f0 a).op = f0
   
   [<a name="recordtype_monoid_seldef_op_fupd_def-val"><b>recordtype_monoid_seldef_op_fupd_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄf1 f f0 a.
          monoid f f0 a with op updated_by f1 = monoid f (f1 f0) a
   
   [<a name="set_inter_def-val"><b>set_inter_def</b></a>]  Definition
      
      ‚ä¢ set_inter = &lt;|carrier := ùïå(:Œ± -&gt; bool); id := ùïå(:Œ±); op := $INTER|&gt;
   
   [<a name="set_union_def-val"><b>set_union_def</b></a>]  Definition
      
      ‚ä¢ set_union = &lt;|carrier := ùïå(:Œ± -&gt; bool); id := ‚àÖ; op := $UNION|&gt;
   
   [<a name="submonoid_big_intersect_def-val"><b>submonoid_big_intersect_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄg. smbINTER g =
            &lt;|carrier := BIGINTER (IMAGE (Œªh. H) {h | h &lt;&lt; g}); op := $*;
              id := #e|&gt;
   
   [<a name="submonoid_def-val"><b>submonoid_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄh g. submonoid h g ‚áî MonoidHomo I h g
   
   [<a name="times_mod_def-val"><b>times_mod_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄn. times_mod n =
            &lt;|carrier := count n; id := if n = 1 then 0 else 1;
              op := (Œªi j. (i * j) MOD n)|&gt;
   
   [<a name="trivial_monoid_def-val"><b>trivial_monoid_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄe. trivial_monoid e = &lt;|carrier := {e}; id := e; op := (Œªx y. e)|&gt;
   
   [<a name="COMMUTING_GITBAG_INSERT-val"><b>COMMUTING_GITBAG_INSERT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg b.
          AbelianMonoid g ‚àß FINITE_BAG b ‚àß SET_OF_BAG b ‚äÜ G ‚áí
          ‚àÄx a::G. GITBAG g (BAG_INSERT x b) a = GITBAG g b (x * a)
   
   [<a name="COMMUTING_GITSET_INSERT-val"><b>COMMUTING_GITSET_INSERT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg s.
          AbelianMonoid g ‚àß FINITE s ‚àß s ‚äÜ G ‚áí
          ‚àÄb x::G. GITSET g (x INSERT s) b = GITSET g (s DELETE x) (x * b)
   
   [<a name="COMMUTING_GITSET_RECURSES-val"><b>COMMUTING_GITSET_RECURSES</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg s.
          AbelianMonoid g ‚àß FINITE s ‚àß s ‚äÜ G ‚áí
          ‚àÄb x::G. GITSET g (x INSERT s) b = x * GITSET g (s DELETE x) b
   
   [<a name="COMMUTING_GITSET_REDUCTION-val"><b>COMMUTING_GITSET_REDUCTION</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg s.
          AbelianMonoid g ‚àß FINITE s ‚àß s ‚äÜ G ‚áí
          ‚àÄb x::G. GITSET g s (x * b) = x * GITSET g s b
   
   [<a name="EXISTS_monoid-val"><b>EXISTS_monoid</b></a>]  Theorem
      
      ‚ä¢ ‚àÄP. (‚àÉm. P m) ‚áî ‚àÉf0 f a. P &lt;|carrier := f0; op := f; id := a|&gt;
   
   [<a name="FORALL_monoid-val"><b>FORALL_monoid</b></a>]  Theorem
      
      ‚ä¢ ‚àÄP. (‚àÄm. P m) ‚áî ‚àÄf0 f a. P &lt;|carrier := f0; op := f; id := a|&gt;
   
   [<a name="FiniteAbelianMonoid_def_alt-val"><b>FiniteAbelianMonoid_def_alt</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. FiniteAbelianMonoid g ‚áî
            FiniteMonoid g ‚àß ‚àÄx y. x ‚àà G ‚àß y ‚àà G ‚áí x * y = y * x
   
   [<a name="GBAG_IMAGE_FILTER-val"><b>GBAG_IMAGE_FILTER</b></a>]  Theorem
      
      ‚ä¢ AbelianMonoid g ‚áí
        ‚àÄb. FINITE_BAG b ‚áí
            IMAGE f (SET_OF_BAG b ‚à© P) ‚äÜ G ‚áí
            GBAG g (BAG_IMAGE f (BAG_FILTER P b)) =
            GBAG g (BAG_IMAGE (Œªx. if P x then f x else #e) b)
   
   [<a name="GBAG_IMAGE_PARTITION-val"><b>GBAG_IMAGE_PARTITION</b></a>]  Theorem
      
      ‚ä¢ AbelianMonoid g ‚àß FINITE s ‚áí
        ‚àÄb. FINITE_BAG b ‚áí
            IMAGE f (SET_OF_BAG b) ‚äÜ G ‚àß (‚àÄx. x ‚ã≤ b ‚áí ‚àÉP. P ‚àà s ‚àß P x) ‚àß
            (‚àÄx P1 P2. x ‚ã≤ b ‚àß P1 ‚àà s ‚àß P2 ‚àà s ‚àß P1 x ‚àß P2 x ‚áí P1 = P2) ‚áí
            GBAG g
              (BAG_IMAGE (ŒªP. GBAG g (BAG_IMAGE f (BAG_FILTER P b)))
                 (BAG_OF_SET s)) =
            GBAG g (BAG_IMAGE f b)
   
   [<a name="GBAG_INSERT-val"><b>GBAG_INSERT</b></a>]  Theorem
      
      ‚ä¢ AbelianMonoid g ‚àß FINITE_BAG b ‚àß SET_OF_BAG b ‚äÜ G ‚àß x ‚àà G ‚áí
        GBAG g (BAG_INSERT x b) = x * GBAG g b
   
   [<a name="GBAG_PARTITION-val"><b>GBAG_PARTITION</b></a>]  Theorem
      
      ‚ä¢ AbelianMonoid g ‚àß FINITE s ‚àß FINITE_BAG b ‚àß SET_OF_BAG b ‚äÜ G ‚àß
        (‚àÄx. x ‚ã≤ b ‚áí ‚àÉP. P ‚àà s ‚àß P x) ‚àß
        (‚àÄx P1 P2. x ‚ã≤ b ‚àß P1 ‚àà s ‚àß P2 ‚àà s ‚àß P1 x ‚àß P2 x ‚áí P1 = P2) ‚áí
        GBAG g (BAG_IMAGE (ŒªP. GBAG g (BAG_FILTER P b)) (BAG_OF_SET s)) =
        GBAG g b
   
   [<a name="GBAG_UNION-val"><b>GBAG_UNION</b></a>]  Theorem
      
      ‚ä¢ AbelianMonoid g ‚àß FINITE_BAG b1 ‚àß FINITE_BAG b2 ‚àß
        SET_OF_BAG b1 ‚äÜ G ‚àß SET_OF_BAG b2 ‚äÜ G ‚áí
        GBAG g (b1 ‚äé b2) = GBAG g b1 * GBAG g b2
   
   [<a name="GBAG_in_carrier-val"><b>GBAG_in_carrier</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg b.
          AbelianMonoid g ‚àß FINITE_BAG b ‚àß SET_OF_BAG b ‚äÜ G ‚áí GBAG g b ‚àà G
   
   [<a name="GITBAG_BAG_IMAGE_op-val"><b>GITBAG_BAG_IMAGE_op</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. AbelianMonoid g ‚áí
            ‚àÄb. FINITE_BAG b ‚áí
                ‚àÄp q a.
                  IMAGE p (SET_OF_BAG b) ‚äÜ G ‚àß IMAGE q (SET_OF_BAG b) ‚äÜ G ‚àß
                  a ‚àà G ‚áí
                  GITBAG g (BAG_IMAGE (Œªx. p x * q x) b) a =
                  GITBAG g (BAG_IMAGE p b) a * GBAG g (BAG_IMAGE q b)
   
   [<a name="GITBAG_CONG-val"><b>GITBAG_CONG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. AbelianMonoid g ‚áí
            ‚àÄb. FINITE_BAG b ‚áí
                ‚àÄb' a a'.
                  FINITE_BAG b' ‚àß a ‚àà G ‚àß SET_OF_BAG b ‚äÜ G ‚àß
                  SET_OF_BAG b' ‚äÜ G ‚àß
                  (‚àÄx. x ‚ã≤ b ‚äé b' ‚àß x ‚â† #e ‚áí b x = b' x) ‚áí
                  GITBAG g b a = GITBAG g b' a
   
   [<a name="GITBAG_EMPTY-val"><b>GITBAG_EMPTY</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg a. GITBAG g {||} a = a
   
   [<a name="GITBAG_GBAG-val"><b>GITBAG_GBAG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. AbelianMonoid g ‚áí
            ‚àÄb. FINITE_BAG b ‚áí
                ‚àÄa. a ‚àà G ‚àß SET_OF_BAG b ‚äÜ G ‚áí GITBAG g b a = a * GBAG g b
   
   [<a name="GITBAG_INSERT-val"><b>GITBAG_INSERT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄb. FINITE_BAG b ‚áí
            ‚àÄg x a.
              GITBAG g (BAG_INSERT x b) a =
              GITBAG g (BAG_REST (BAG_INSERT x b))
                (BAG_CHOICE (BAG_INSERT x b) * a)
   
   [<a name="GITBAG_INSERT_THM-val"><b>GITBAG_INSERT_THM</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg b x a.
          (AbelianMonoid g ‚àß FINITE_BAG b ‚àß SET_OF_BAG b ‚äÜ G) ‚àß x ‚àà G ‚àß
          a ‚àà G ‚áí
          GITBAG g (BAG_INSERT x b) a = GITBAG g b (x * a)
   
   [<a name="GITBAG_THM-val"><b>GITBAG_THM</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg b acc.
          FINITE_BAG b ‚áí
          GITBAG g b acc =
          if b = {||} then acc
          else GITBAG g (BAG_REST b) (BAG_CHOICE b * acc)
   
   [<a name="GITBAG_UNION-val"><b>GITBAG_UNION</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. AbelianMonoid g ‚áí
            ‚àÄb1.
              FINITE_BAG b1 ‚áí
              ‚àÄb2.
                FINITE_BAG b2 ‚àß SET_OF_BAG b1 ‚äÜ G ‚àß SET_OF_BAG b2 ‚äÜ G ‚áí
                ‚àÄa. a ‚àà G ‚áí
                    GITBAG g (b1 ‚äé b2) a = GITBAG g b2 (GITBAG g b1 a)
   
   [<a name="GITBAG_in_carrier-val"><b>GITBAG_in_carrier</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. AbelianMonoid g ‚áí
            ‚àÄb. FINITE_BAG b ‚áí
                ‚àÄa. SET_OF_BAG b ‚äÜ G ‚àß a ‚àà G ‚áí GITBAG g b a ‚àà G
   
   [<a name="GITBAG_same_op-val"><b>GITBAG_same_op</b></a>]  Theorem
      
      ‚ä¢ g1.op = g2.op ‚áí
        ‚àÄb. FINITE_BAG b ‚áí ‚àÄa. GITBAG g1 b a = GITBAG g2 b a
   
   [<a name="GITSET_EMPTY-val"><b>GITSET_EMPTY</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg b. GITSET g ‚àÖ b = b
   
   [<a name="GITSET_INSERT-val"><b>GITSET_INSERT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs. FINITE s ‚áí
            ‚àÄx g b.
              GITSET g (x INSERT s) b =
              GITSET g (REST (x INSERT s)) (CHOICE (x INSERT s) * b)
   
   [<a name="GITSET_PROPERTY-val"><b>GITSET_PROPERTY</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg s.
          FINITE s ‚àß s ‚â† ‚àÖ ‚áí
          ‚àÄb. GITSET g s b = GITSET g (REST s) (CHOICE s * b)
   
   [<a name="GITSET_THM-val"><b>GITSET_THM</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs g b.
          FINITE s ‚áí
          GITSET g s b =
          if s = ‚àÖ then b else GITSET g (REST s) (CHOICE s * b)
   
   [<a name="GPROD_SET_EMPTY-val"><b>GPROD_SET_EMPTY</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg s. GPROD_SET g ‚àÖ = #e
   
   [<a name="GPROD_SET_PROPERTY-val"><b>GPROD_SET_PROPERTY</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg s. AbelianMonoid g ‚àß FINITE s ‚àß s ‚äÜ G ‚áí GPROD_SET g s ‚àà G
   
   [<a name="GPROD_SET_SING-val"><b>GPROD_SET_SING</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí ‚àÄx. x ‚àà G ‚áí GPROD_SET g {x} = x
   
   [<a name="GPROD_SET_THM-val"><b>GPROD_SET_THM</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg s.
          GPROD_SET g ‚àÖ = #e ‚àß
          (AbelianMonoid g ‚àß FINITE s ‚àß s ‚äÜ G ‚áí
           ‚àÄx::G. GPROD_SET g (x INSERT s) = x * GPROD_SET g (s DELETE x))
   
   [<a name="IMP_GBAG_EQ_EXP-val"><b>IMP_GBAG_EQ_EXP</b></a>]  Theorem
      
      ‚ä¢ AbelianMonoid g ‚àß x ‚àà G ‚àß SET_OF_BAG b ‚äÜ {x} ‚áí GBAG g b = x ** b x
   
   [<a name="IMP_GBAG_EQ_ID-val"><b>IMP_GBAG_EQ_ID</b></a>]  Theorem
      
      ‚ä¢ AbelianMonoid g ‚áí ‚àÄb. BAG_EVERY ($= #e) b ‚áí GBAG g b = #e
   
   [<a name="Invertibles_carrier-val"><b>Invertibles_carrier</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. (Invertibles g).carrier = G*
   
   [<a name="Invertibles_order-val"><b>Invertibles_order</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg x. order (Invertibles g) x = ord x
   
   [<a name="Invertibles_property-val"><b>Invertibles_property</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. (Invertibles g).carrier = G* ‚àß (Invertibles g).op = $* ‚àß
            (Invertibles g).id = #e ‚àß (Invertibles g).exp = $**
   
   [<a name="Invertibles_subset-val"><b>Invertibles_subset</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. (Invertibles g).carrier ‚äÜ G
   
   [<a name="MonoidHomo_GBAG-val"><b>MonoidHomo_GBAG</b></a>]  Theorem
      
      ‚ä¢ AbelianMonoid g ‚àß AbelianMonoid h ‚àß MonoidHomo f g h ‚àß
        FINITE_BAG b ‚àß SET_OF_BAG b ‚äÜ G ‚áí
        f (GBAG g b) = GBAG h (BAG_IMAGE f b)
   
   [<a name="SUBSET_COMMUTING_ITBAG_INSERT-val"><b>SUBSET_COMMUTING_ITBAG_INSERT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf b t.
          SET_OF_BAG b ‚äÜ t ‚àß closure_comm_assoc_fun f t ‚àß FINITE_BAG b ‚áí
          ‚àÄx a::t. ITBAG f (BAG_INSERT x b) a = ITBAG f b (f x a)
   
   [<a name="abelian_monoid_op_closure_comm_assoc_fun-val"><b>abelian_monoid_op_closure_comm_assoc_fun</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. AbelianMonoid g ‚áí closure_comm_assoc_fun $* G
   
   [<a name="abelian_monoid_order_common-val"><b>abelian_monoid_order_common</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. AbelianMonoid g ‚áí
            ‚àÄx y.
              x ‚àà G ‚àß y ‚àà G ‚áí
              ‚àÉz. z ‚àà G ‚àß ord z * gcd (ord x) (ord y) = lcm (ord x) (ord y)
   
   [<a name="abelian_monoid_order_common_coprime-val"><b>abelian_monoid_order_common_coprime</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. AbelianMonoid g ‚áí
            ‚àÄx y.
              x ‚àà G ‚àß y ‚àà G ‚àß coprime (ord x) (ord y) ‚áí
              ‚àÉz. z ‚àà G ‚àß ord z = ord x * ord y
   
   [<a name="abelian_monoid_order_lcm-val"><b>abelian_monoid_order_lcm</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. AbelianMonoid g ‚áí
            ‚àÄx y. x ‚àà G ‚àß y ‚àà G ‚áí ‚àÉz. z ‚àà G ‚àß ord z = lcm (ord x) (ord y)
   
   [<a name="addition_monoid_abelian_monoid-val"><b>addition_monoid_abelian_monoid</b></a>]  Theorem
      
      ‚ä¢ AbelianMonoid addition_monoid
   
   [<a name="addition_monoid_monoid-val"><b>addition_monoid_monoid</b></a>]  Theorem
      
      ‚ä¢ Monoid addition_monoid
   
   [<a name="addition_monoid_property-val"><b>addition_monoid_property</b></a>]  Theorem
      
      ‚ä¢ addition_monoid.carrier = ùïå(:num) ‚àß addition_monoid.op = $+ ‚àß
        addition_monoid.id = 0
   
   [<a name="datatype_monoid-val"><b>datatype_monoid</b></a>]  Theorem
      
      ‚ä¢ DATATYPE (record monoid carrier op id)
   
   [<a name="extend_carrier-val"><b>extend_carrier</b></a>]  Theorem
      
      ‚ä¢ (extend m).carrier = ùïå(:Œ±)
   
   [<a name="extend_id-val"><b>extend_id</b></a>]  Theorem
      
      ‚ä¢ (extend m).id = m.id
   
   [<a name="extend_is_monoid-val"><b>extend_is_monoid</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm. Monoid m ‚áí Monoid (extend m)
   
   [<a name="extend_op-val"><b>extend_op</b></a>]  Theorem
      
      ‚ä¢ x ‚àà m.carrier ‚àß y ‚àà m.carrier ‚áí (extend m).op x y = m.op x y
   
   [<a name="finite_monoid_exp_not_distinct-val"><b>finite_monoid_exp_not_distinct</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. FiniteMonoid g ‚áí ‚àÄx. x ‚àà G ‚áí ‚àÉh k. x ** h = x ** k ‚àß h ‚â† k
   
   [<a name="homo_monoid_I-val"><b>homo_monoid_I</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. MonoidIso I (homo_monoid g I) g
   
   [<a name="homo_monoid_abelian_monoid-val"><b>homo_monoid_abelian_monoid</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg f.
          AbelianMonoid g ‚àß MonoidHomo f g (homo_monoid g f) ‚áí
          AbelianMonoid (homo_monoid g f)
   
   [<a name="homo_monoid_assoc-val"><b>homo_monoid_assoc</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg f.
          Monoid g ‚àß MonoidHomo f g (homo_monoid g f) ‚áí
          ‚àÄx y z. x ‚àà fG ‚àß y ‚àà fG ‚àß z ‚àà fG ‚áí (x ‚àò y) ‚àò z = x ‚àò y ‚àò z
   
   [<a name="homo_monoid_by_inj-val"><b>homo_monoid_by_inj</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg f. Monoid g ‚àß INJ f G ùïå(:Œ≤) ‚áí MonoidHomo f g (homo_monoid g f)
   
   [<a name="homo_monoid_closure-val"><b>homo_monoid_closure</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg f.
          Monoid g ‚àß MonoidHomo f g (homo_monoid g f) ‚áí
          ‚àÄx y. x ‚àà fG ‚àß y ‚àà fG ‚áí x ‚àò y ‚àà fG
   
   [<a name="homo_monoid_comm-val"><b>homo_monoid_comm</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg f.
          AbelianMonoid g ‚àß MonoidHomo f g (homo_monoid g f) ‚áí
          ‚àÄx y. x ‚àà fG ‚àß y ‚àà fG ‚áí x ‚àò y = y ‚àò x
   
   [<a name="homo_monoid_element-val"><b>homo_monoid_element</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg f x. x ‚àà G ‚áí f x ‚àà fG
   
   [<a name="homo_monoid_id-val"><b>homo_monoid_id</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg f. f #e = #i
   
   [<a name="homo_monoid_id_property-val"><b>homo_monoid_id_property</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg f.
          Monoid g ‚àß MonoidHomo f g (homo_monoid g f) ‚áí
          #i ‚àà fG ‚àß ‚àÄx. x ‚àà fG ‚áí #i ‚àò x = x ‚àß x ‚àò #i = x
   
   [<a name="homo_monoid_monoid-val"><b>homo_monoid_monoid</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg f.
          Monoid g ‚àß MonoidHomo f g (homo_monoid g f) ‚áí
          Monoid (homo_monoid g f)
   
   [<a name="homo_monoid_op_inj-val"><b>homo_monoid_op_inj</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg f. INJ f G ùïå(:Œ≤) ‚áí ‚àÄx y. x ‚àà G ‚àß y ‚àà G ‚áí f (x * y) = f x ‚àò f y
   
   [<a name="homo_monoid_property-val"><b>homo_monoid_property</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg f.
          fG = IMAGE f G ‚àß
          (‚àÄx y.
             x ‚àà fG ‚àß y ‚àà fG ‚áí
             x ‚àò y = f (CHOICE (preimage f G x) * CHOICE (preimage f G y))) ‚àß
          #i = f #e
   
   [<a name="image_op_inj-val"><b>image_op_inj</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg f.
          INJ f G ùïå(:Œ≤) ‚áí
          ‚àÄx y. x ‚àà G ‚àß y ‚àà G ‚áí image_op g f (f x) (f y) = f (x * y)
   
   [<a name="lists_monoid-val"><b>lists_monoid</b></a>]  Theorem
      
      ‚ä¢ Monoid lists
   
   [<a name="maximal_order_alt-val"><b>maximal_order_alt</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. maximal_order g = MAX_SET {ord z | z | z ‚àà G}
   
   [<a name="monoid_11-val"><b>monoid_11</b></a>]  Theorem
      
      ‚ä¢ ‚àÄa0 a1 a2 a0' a1' a2'.
          monoid a0 a1 a2 = monoid a0' a1' a2' ‚áî
          a0 = a0' ‚àß a1 = a1' ‚àß a2 = a2'
   
   [<a name="monoid_Axiom-val"><b>monoid_Axiom</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf. ‚àÉfn. ‚àÄa0 a1 a2. fn (monoid a0 a1 a2) = f a0 a1 a2
   
   [<a name="monoid_accessors-val"><b>monoid_accessors</b></a>]  Theorem
      
      ‚ä¢ (‚àÄf f0 a. (monoid f f0 a).carrier = f) ‚àß
        (‚àÄf f0 a. (monoid f f0 a).op = f0) ‚àß
        ‚àÄf f0 a. (monoid f f0 a).id = a
   
   [<a name="monoid_accfupds-val"><b>monoid_accfupds</b></a>]  Theorem
      
      ‚ä¢ (‚àÄm f. (m with op updated_by f).carrier = m.carrier) ‚àß
        (‚àÄm f. (m with id updated_by f).carrier = m.carrier) ‚àß
        (‚àÄm f. (m with carrier updated_by f).op = m.op) ‚àß
        (‚àÄm f. (m with id updated_by f).op = m.op) ‚àß
        (‚àÄm f. (m with carrier updated_by f).id = m.id) ‚àß
        (‚àÄm f. (m with op updated_by f).id = m.id) ‚àß
        (‚àÄm f. (m with carrier updated_by f).carrier = f m.carrier) ‚àß
        (‚àÄm f. (m with op updated_by f).op = f m.op) ‚àß
        ‚àÄm f. (m with id updated_by f).id = f m.id
   
   [<a name="monoid_assoc-val"><b>monoid_assoc</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí
            ‚àÄx y z. x ‚àà G ‚àß y ‚àà G ‚àß z ‚àà G ‚áí x * y * z = x * (y * z)
   
   [<a name="monoid_auto_I-val"><b>monoid_auto_I</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. MonoidAuto I g
   
   [<a name="monoid_auto_bij-val"><b>monoid_auto_bij</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg f. MonoidAuto f g ‚áí f PERMUTES G
   
   [<a name="monoid_auto_compose-val"><b>monoid_auto_compose</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg f1 f2.
          MonoidAuto f1 g ‚àß MonoidAuto f2 g ‚áí MonoidAuto (f1 ‚àò f2) g
   
   [<a name="monoid_auto_element-val"><b>monoid_auto_element</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g. MonoidAuto f g ‚áí ‚àÄx. x ‚àà G ‚áí f x ‚àà G
   
   [<a name="monoid_auto_exp-val"><b>monoid_auto_exp</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g.
          Monoid g ‚àß MonoidAuto f g ‚áí ‚àÄx. x ‚àà G ‚áí ‚àÄn. f (x ** n) = f x ** n
   
   [<a name="monoid_auto_id-val"><b>monoid_auto_id</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g. MonoidAuto f g ‚áí f #e = #e
   
   [<a name="monoid_auto_linv_auto-val"><b>monoid_auto_linv_auto</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg f. Monoid g ‚àß MonoidAuto f g ‚áí MonoidAuto (LINV f G) g
   
   [<a name="monoid_auto_order-val"><b>monoid_auto_order</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg f. Monoid g ‚àß MonoidAuto f g ‚áí ‚àÄx. x ‚àà G ‚áí ord (f x) = ord x
   
   [<a name="monoid_carrier_nonempty-val"><b>monoid_carrier_nonempty</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí G ‚â† ‚àÖ
   
   [<a name="monoid_case_cong-val"><b>monoid_case_cong</b></a>]  Theorem
      
      ‚ä¢ ‚àÄM M' f.
          M = M' ‚àß
          (‚àÄa0 a1 a2. M' = monoid a0 a1 a2 ‚áí f a0 a1 a2 = f' a0 a1 a2) ‚áí
          monoid_CASE M f = monoid_CASE M' f'
   
   [<a name="monoid_case_eq-val"><b>monoid_case_eq</b></a>]  Theorem
      
      ‚ä¢ monoid_CASE x f = v ‚áî ‚àÉf' f0 a. x = monoid f' f0 a ‚àß f f' f0 a = v
   
   [<a name="monoid_comm_exp-val"><b>monoid_comm_exp</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí
            ‚àÄx y.
              x ‚àà G ‚àß y ‚àà G ‚áí x * y = y * x ‚áí ‚àÄn. x ** n * y = y * x ** n
   
   [<a name="monoid_comm_exp_exp-val"><b>monoid_comm_exp_exp</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí
            ‚àÄx y.
              x ‚àà G ‚àß y ‚àà G ‚àß x * y = y * x ‚áí
              ‚àÄn m. x ** n * y ** m = y ** m * x ** n
   
   [<a name="monoid_comm_op_exp-val"><b>monoid_comm_op_exp</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí
            ‚àÄx y.
              x ‚àà G ‚àß y ‚àà G ‚àß x * y = y * x ‚áí
              ‚àÄn. (x * y) ** n = x ** n * y ** n
   
   [<a name="monoid_component_equality-val"><b>monoid_component_equality</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm1 m2.
          m1 = m2 ‚áî m1.carrier = m2.carrier ‚àß m1.op = m2.op ‚àß m1.id = m2.id
   
   [<a name="monoid_exp_0-val"><b>monoid_exp_0</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg x. x ** 0 = #e
   
   [<a name="monoid_exp_1-val"><b>monoid_exp_1</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí ‚àÄx. x ‚àà G ‚áí x ** 1 = x
   
   [<a name="monoid_exp_SUC-val"><b>monoid_exp_SUC</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg x n. x ** SUC n = x * x ** n
   
   [<a name="monoid_exp_add-val"><b>monoid_exp_add</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí ‚àÄx. x ‚àà G ‚áí ‚àÄn k. x ** (n + k) = x ** n * x ** k
   
   [<a name="monoid_exp_comm-val"><b>monoid_exp_comm</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí ‚àÄx. x ‚àà G ‚áí ‚àÄn. x ** n * x = x * x ** n
   
   [<a name="monoid_exp_element-val"><b>monoid_exp_element</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí ‚àÄx. x ‚àà G ‚áí ‚àÄn. x ** n ‚àà G
   
   [<a name="monoid_exp_mod_order-val"><b>monoid_exp_mod_order</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí
            ‚àÄx. x ‚àà G ‚àß 0 &lt; ord x ‚áí ‚àÄn. x ** n = x ** (n MOD ord x)
   
   [<a name="monoid_exp_mult-val"><b>monoid_exp_mult</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí ‚àÄx. x ‚àà G ‚áí ‚àÄn k. x ** (n * k) = (x ** n) ** k
   
   [<a name="monoid_exp_mult_comm-val"><b>monoid_exp_mult_comm</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí ‚àÄx. x ‚àà G ‚áí ‚àÄm n. (x ** m) ** n = (x ** n) ** m
   
   [<a name="monoid_exp_suc-val"><b>monoid_exp_suc</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí ‚àÄx. x ‚àà G ‚áí ‚àÄn. x ** SUC n = x ** n * x
   
   [<a name="monoid_fn_updates-val"><b>monoid_fn_updates</b></a>]  Theorem
      
      ‚ä¢ (‚àÄf1 f f0 a.
           monoid f f0 a with carrier updated_by f1 = monoid (f1 f) f0 a) ‚àß
        (‚àÄf1 f f0 a.
           monoid f f0 a with op updated_by f1 = monoid f (f1 f0) a) ‚àß
        ‚àÄf1 f f0 a.
          monoid f f0 a with id updated_by f1 = monoid f f0 (f1 a)
   
   [<a name="monoid_fupdcanon-val"><b>monoid_fupdcanon</b></a>]  Theorem
      
      ‚ä¢ (‚àÄm g f.
           m with &lt;|op updated_by f; carrier updated_by g|&gt; =
           m with &lt;|carrier updated_by g; op updated_by f|&gt;) ‚àß
        (‚àÄm g f.
           m with &lt;|id updated_by f; carrier updated_by g|&gt; =
           m with &lt;|carrier updated_by g; id updated_by f|&gt;) ‚àß
        ‚àÄm g f.
          m with &lt;|id updated_by f; op updated_by g|&gt; =
          m with &lt;|op updated_by g; id updated_by f|&gt;
   
   [<a name="monoid_fupdcanon_comp-val"><b>monoid_fupdcanon_comp</b></a>]  Theorem
      
      ‚ä¢ ((‚àÄg f. op_fupd f ‚àò carrier_fupd g = carrier_fupd g ‚àò op_fupd f) ‚àß
         ‚àÄh g f.
           op_fupd f ‚àò carrier_fupd g ‚àò h = carrier_fupd g ‚àò op_fupd f ‚àò h) ‚àß
        ((‚àÄg f. id_fupd f ‚àò carrier_fupd g = carrier_fupd g ‚àò id_fupd f) ‚àß
         ‚àÄh g f.
           id_fupd f ‚àò carrier_fupd g ‚àò h = carrier_fupd g ‚àò id_fupd f ‚àò h) ‚àß
        (‚àÄg f. id_fupd f ‚àò op_fupd g = op_fupd g ‚àò id_fupd f) ‚àß
        ‚àÄh g f. id_fupd f ‚àò op_fupd g ‚àò h = op_fupd g ‚àò id_fupd f ‚àò h
   
   [<a name="monoid_fupdfupds-val"><b>monoid_fupdfupds</b></a>]  Theorem
      
      ‚ä¢ (‚àÄm g f.
           m with &lt;|carrier updated_by f; carrier updated_by g|&gt; =
           m with carrier updated_by f ‚àò g) ‚àß
        (‚àÄm g f.
           m with &lt;|op updated_by f; op updated_by g|&gt; =
           m with op updated_by f ‚àò g) ‚àß
        ‚àÄm g f.
          m with &lt;|id updated_by f; id updated_by g|&gt; =
          m with id updated_by f ‚àò g
   
   [<a name="monoid_fupdfupds_comp-val"><b>monoid_fupdfupds_comp</b></a>]  Theorem
      
      ‚ä¢ ((‚àÄg f. carrier_fupd f ‚àò carrier_fupd g = carrier_fupd (f ‚àò g)) ‚àß
         ‚àÄh g f.
           carrier_fupd f ‚àò carrier_fupd g ‚àò h = carrier_fupd (f ‚àò g) ‚àò h) ‚àß
        ((‚àÄg f. op_fupd f ‚àò op_fupd g = op_fupd (f ‚àò g)) ‚àß
         ‚àÄh g f. op_fupd f ‚àò op_fupd g ‚àò h = op_fupd (f ‚àò g) ‚àò h) ‚àß
        (‚àÄg f. id_fupd f ‚àò id_fupd g = id_fupd (f ‚àò g)) ‚àß
        ‚àÄh g f. id_fupd f ‚àò id_fupd g ‚àò h = id_fupd (f ‚àò g) ‚àò h
   
   [<a name="monoid_homo_I_refl-val"><b>monoid_homo_I_refl</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. MonoidHomo I g g
   
   [<a name="monoid_homo_compose-val"><b>monoid_homo_compose</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h k f1 f2.
          MonoidHomo f1 g h ‚àß MonoidHomo f2 h k ‚áí MonoidHomo (f2 ‚àò f1) g k
   
   [<a name="monoid_homo_cong-val"><b>monoid_homo_cong</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h f1 f2.
          Monoid g ‚àß Monoid h ‚àß (‚àÄx. x ‚àà G ‚áí f1 x = f2 x) ‚áí
          (MonoidHomo f1 g h ‚áî MonoidHomo f2 g h)
   
   [<a name="monoid_homo_element-val"><b>monoid_homo_element</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g h. MonoidHomo f g h ‚áí ‚àÄx. x ‚àà G ‚áí f x ‚àà h.carrier
   
   [<a name="monoid_homo_exp-val"><b>monoid_homo_exp</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h f.
          Monoid g ‚àß MonoidHomo f g h ‚áí
          ‚àÄx. x ‚àà G ‚áí ‚àÄn. f (x ** n) = h.exp (f x) n
   
   [<a name="monoid_homo_id-val"><b>monoid_homo_id</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g h. MonoidHomo f g h ‚áí f #e = h.id
   
   [<a name="monoid_homo_sym-val"><b>monoid_homo_sym</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h f.
          Monoid g ‚àß MonoidHomo f g h ‚àß BIJ f G h.carrier ‚áí
          MonoidHomo (LINV f G) h g
   
   [<a name="monoid_homo_sym_any-val"><b>monoid_homo_sym_any</b></a>]  Theorem
      
      ‚ä¢ Monoid g ‚àß MonoidHomo f g h ‚àß
        (‚àÄx. x ‚àà h.carrier ‚áí i x ‚àà G ‚àß f (i x) = x) ‚àß
        (‚àÄx. x ‚àà G ‚áí i (f x) = x) ‚áí
        MonoidHomo i h g
   
   [<a name="monoid_homo_trans-val"><b>monoid_homo_trans</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h k f1 f2.
          MonoidHomo f1 g h ‚àß MonoidHomo f2 h k ‚áí MonoidHomo (f2 ‚àò f1) g k
   
   [<a name="monoid_id-val"><b>monoid_id</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí ‚àÄx. x ‚àà G ‚áí #e * x = x ‚àß x * #e = x
   
   [<a name="monoid_id_element-val"><b>monoid_id_element</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí #e ‚àà G
   
   [<a name="monoid_id_exp-val"><b>monoid_id_exp</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí ‚àÄn. #e ** n = #e
   
   [<a name="monoid_id_id-val"><b>monoid_id_id</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí #e * #e = #e
   
   [<a name="monoid_id_invertible-val"><b>monoid_id_invertible</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí #e ‚àà G*
   
   [<a name="monoid_id_unique-val"><b>monoid_id_unique</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí
            ‚àÄe. e ‚àà G ‚áí ((‚àÄx. x ‚àà G ‚áí x * e = x ‚àß e * x = x) ‚áî e = #e)
   
   [<a name="monoid_induction-val"><b>monoid_induction</b></a>]  Theorem
      
      ‚ä¢ ‚àÄP. (‚àÄf f0 a. P (monoid f f0 a)) ‚áí ‚àÄm. P m
   
   [<a name="monoid_inj_image_abelian_monoid-val"><b>monoid_inj_image_abelian_monoid</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg f.
          AbelianMonoid g ‚àß INJ f G ùïå(:Œ≤) ‚áí
          AbelianMonoid (monoid_inj_image g f)
   
   [<a name="monoid_inj_image_monoid-val"><b>monoid_inj_image_monoid</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg f. Monoid g ‚àß INJ f G ùïå(:Œ≤) ‚áí Monoid (monoid_inj_image g f)
   
   [<a name="monoid_inj_image_monoid_homo-val"><b>monoid_inj_image_monoid_homo</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg f. INJ f G ùïå(:Œ≤) ‚áí MonoidHomo f g (monoid_inj_image g f)
   
   [<a name="monoid_intersect_element-val"><b>monoid_intersect_element</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h x. x ‚àà (g mINTER h).carrier ‚áí x ‚àà G ‚àß x ‚àà H
   
   [<a name="monoid_intersect_id-val"><b>monoid_intersect_id</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h. (g mINTER h).id = #e
   
   [<a name="monoid_intersect_property-val"><b>monoid_intersect_property</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h.
          (g mINTER h).carrier = G ‚à© H ‚àß (g mINTER h).op = $* ‚àß
          (g mINTER h).id = #e
   
   [<a name="monoid_inv_def_alt-val"><b>monoid_inv_def_alt</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí
            ‚àÄx. x ‚àà G* ‚áî x ‚àà G ‚àß |/ x ‚àà G ‚àß x * |/ x = #e ‚àß |/ x * x = #e
   
   [<a name="monoid_inv_element-val"><b>monoid_inv_element</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí ‚àÄx. x ‚àà G* ‚áí x ‚àà G
   
   [<a name="monoid_inv_from_invertibles-val"><b>monoid_inv_from_invertibles</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí ‚àÄx. x ‚àà G* ‚áí ‚àÉy. y ‚àà G ‚àß x * y = #e ‚àß y * x = #e
   
   [<a name="monoid_inv_invertible-val"><b>monoid_inv_invertible</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí ‚àÄx. x ‚àà G* ‚áí |/ x ‚àà G*
   
   [<a name="monoid_inv_op_invertible-val"><b>monoid_inv_op_invertible</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí ‚àÄx y. x ‚àà G* ‚àß y ‚àà G* ‚áí x * y ‚àà G*
   
   [<a name="monoid_invertibles_element-val"><b>monoid_invertibles_element</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg x. x ‚àà G* ‚áî x ‚àà G ‚àß ‚àÉy. y ‚àà G ‚àß x * y = #e ‚àß y * x = #e
   
   [<a name="monoid_invertibles_is_monoid-val"><b>monoid_invertibles_is_monoid</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí Monoid (Invertibles g)
   
   [<a name="monoid_iso_I_refl-val"><b>monoid_iso_I_refl</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. MonoidIso I g g
   
   [<a name="monoid_iso_bij-val"><b>monoid_iso_bij</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h f. MonoidIso f g h ‚áí BIJ f G h.carrier
   
   [<a name="monoid_iso_card_eq-val"><b>monoid_iso_card_eq</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h f. MonoidIso f g h ‚àß FINITE G ‚áí CARD G = CARD h.carrier
   
   [<a name="monoid_iso_compose-val"><b>monoid_iso_compose</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h k f1 f2.
          MonoidIso f1 g h ‚àß MonoidIso f2 h k ‚áí MonoidIso (f2 ‚àò f1) g k
   
   [<a name="monoid_iso_element-val"><b>monoid_iso_element</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g h. MonoidIso f g h ‚áí ‚àÄx. x ‚àà G ‚áí f x ‚àà h.carrier
   
   [<a name="monoid_iso_eq_id-val"><b>monoid_iso_eq_id</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h f.
          Monoid g ‚àß Monoid h ‚àß MonoidIso f g h ‚áí
          ‚àÄx. x ‚àà G ‚áí (f x = h.id ‚áî x = #e)
   
   [<a name="monoid_iso_exp-val"><b>monoid_iso_exp</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h f.
          Monoid g ‚àß MonoidIso f g h ‚áí
          ‚àÄx. x ‚àà G ‚áí ‚àÄn. f (x ** n) = h.exp (f x) n
   
   [<a name="monoid_iso_id-val"><b>monoid_iso_id</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g h. MonoidIso f g h ‚áí f #e = h.id
   
   [<a name="monoid_iso_linv_iso-val"><b>monoid_iso_linv_iso</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h f. Monoid g ‚àß MonoidIso f g h ‚áí MonoidIso (LINV f G) h g
   
   [<a name="monoid_iso_monoid-val"><b>monoid_iso_monoid</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h f. Monoid g ‚àß MonoidIso f g h ‚áí Monoid h
   
   [<a name="monoid_iso_order-val"><b>monoid_iso_order</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h f.
          Monoid g ‚àß Monoid h ‚àß MonoidIso f g h ‚áí
          ‚àÄx. x ‚àà G ‚áí order h (f x) = ord x
   
   [<a name="monoid_iso_property-val"><b>monoid_iso_property</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g h.
          MonoidIso f g h ‚áî
          MonoidHomo f g h ‚àß ‚àÄy. y ‚àà h.carrier ‚áí ‚àÉ!x. x ‚àà G ‚àß f x = y
   
   [<a name="monoid_iso_sym-val"><b>monoid_iso_sym</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h f. Monoid g ‚àß MonoidIso f g h ‚áí MonoidIso (LINV f G) h g
   
   [<a name="monoid_iso_trans-val"><b>monoid_iso_trans</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h k f1 f2.
          MonoidIso f1 g h ‚àß MonoidIso f2 h k ‚áí MonoidIso (f2 ‚àò f1) g k
   
   [<a name="monoid_lid-val"><b>monoid_lid</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí ‚àÄx. x ‚àà G ‚áí #e * x = x
   
   [<a name="monoid_lid_unique-val"><b>monoid_lid_unique</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí ‚àÄe. e ‚àà G ‚áí (‚àÄx. x ‚àà G ‚áí e * x = x) ‚áí e = #e
   
   [<a name="monoid_literal_11-val"><b>monoid_literal_11</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf01 f1 a1 f02 f2 a2.
          &lt;|carrier := f01; op := f1; id := a1|&gt; =
          &lt;|carrier := f02; op := f2; id := a2|&gt; ‚áî
          f01 = f02 ‚àß f1 = f2 ‚àß a1 = a2
   
   [<a name="monoid_literal_nchotomy-val"><b>monoid_literal_nchotomy</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm. ‚àÉf0 f a. m = &lt;|carrier := f0; op := f; id := a|&gt;
   
   [<a name="monoid_nchotomy-val"><b>monoid_nchotomy</b></a>]  Theorem
      
      ‚ä¢ ‚àÄmm. ‚àÉf f0 a. mm = monoid f f0 a
   
   [<a name="monoid_op_element-val"><b>monoid_op_element</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí ‚àÄx y. x ‚àà G ‚àß y ‚àà G ‚áí x * y ‚àà G
   
   [<a name="monoid_order_cofactor-val"><b>monoid_order_cofactor</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí
            ‚àÄx n.
              x ‚àà G ‚àß 0 &lt; ord x ‚àß n divides ord x ‚áí
              ord (x ** (ord x DIV n)) = n
   
   [<a name="monoid_order_common-val"><b>monoid_order_common</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí
            ‚àÄx y.
              x ‚àà G ‚àß y ‚àà G ‚àß x * y = y * x ‚áí
              ‚àÉz. z ‚àà G ‚àß ord z * gcd (ord x) (ord y) = lcm (ord x) (ord y)
   
   [<a name="monoid_order_common_coprime-val"><b>monoid_order_common_coprime</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí
            ‚àÄx y.
              x ‚àà G ‚àß y ‚àà G ‚àß x * y = y * x ‚àß coprime (ord x) (ord y) ‚áí
              ‚àÉz. z ‚àà G ‚àß ord z = ord x * ord y
   
   [<a name="monoid_order_condition-val"><b>monoid_order_condition</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí ‚àÄx. x ‚àà G ‚áí ‚àÄm. x ** m = #e ‚áî ord x divides m
   
   [<a name="monoid_order_divides_exp-val"><b>monoid_order_divides_exp</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí ‚àÄx n. x ‚àà G ‚áí (x ** n = #e ‚áî ord x divides n)
   
   [<a name="monoid_order_divides_maximal-val"><b>monoid_order_divides_maximal</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. FiniteAbelianMonoid g ‚áí
            ‚àÄx. x ‚àà G ‚àß 0 &lt; ord x ‚áí ord x divides maximal_order g
   
   [<a name="monoid_order_divisor-val"><b>monoid_order_divisor</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí
            ‚àÄx m.
              x ‚àà G ‚àß 0 &lt; ord x ‚àß m divides ord x ‚áí ‚àÉy. y ‚àà G ‚àß ord y = m
   
   [<a name="monoid_order_eq_1-val"><b>monoid_order_eq_1</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí ‚àÄx. x ‚àà G ‚áí (ord x = 1 ‚áî x = #e)
   
   [<a name="monoid_order_id-val"><b>monoid_order_id</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí ord #e = 1
   
   [<a name="monoid_order_nonzero-val"><b>monoid_order_nonzero</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg x. Monoid g ‚àß x ‚àà G ‚àß 0 &lt; ord x ‚áí x ‚àà G*
   
   [<a name="monoid_order_power-val"><b>monoid_order_power</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí ‚àÄx. x ‚àà G ‚áí ‚àÄk. ord (x ** k) * gcd (ord x) k = ord x
   
   [<a name="monoid_order_power_coprime-val"><b>monoid_order_power_coprime</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí
            ‚àÄx. x ‚àà G ‚áí ‚àÄn. coprime n (ord x) ‚áí ord (x ** n) = ord x
   
   [<a name="monoid_order_power_eq_0-val"><b>monoid_order_power_eq_0</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí ‚àÄx. x ‚àà G ‚áí ‚àÄk. ord (x ** k) = 0 ‚áî 0 &lt; k ‚àß ord x = 0
   
   [<a name="monoid_order_power_eqn-val"><b>monoid_order_power_eqn</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí
            ‚àÄx k. x ‚àà G ‚àß 0 &lt; k ‚áí ord (x ** k) = ord x DIV gcd k (ord x)
   
   [<a name="monoid_rid-val"><b>monoid_rid</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí ‚àÄx. x ‚àà G ‚áí x * #e = x
   
   [<a name="monoid_rid_unique-val"><b>monoid_rid_unique</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí ‚àÄe. e ‚àà G ‚áí (‚àÄx. x ‚àà G ‚áí x * e = x) ‚áí e = #e
   
   [<a name="monoid_updates_eq_literal-val"><b>monoid_updates_eq_literal</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm f0 f a.
          m with &lt;|carrier := f0; op := f; id := a|&gt; =
          &lt;|carrier := f0; op := f; id := a|&gt;
   
   [<a name="monoid_weak_iso_id-val"><b>monoid_weak_iso_id</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g h. Monoid g ‚àß Monoid h ‚àß WeakIso f g h ‚áí f #e = h.id
   
   [<a name="multiplication_monoid_abelian_monoid-val"><b>multiplication_monoid_abelian_monoid</b></a>]  Theorem
      
      ‚ä¢ AbelianMonoid multiplication_monoid
   
   [<a name="multiplication_monoid_monoid-val"><b>multiplication_monoid_monoid</b></a>]  Theorem
      
      ‚ä¢ Monoid multiplication_monoid
   
   [<a name="multiplication_monoid_property-val"><b>multiplication_monoid_property</b></a>]  Theorem
      
      ‚ä¢ multiplication_monoid.carrier = ùïå(:num) ‚àß
        multiplication_monoid.op = $* ‚àß multiplication_monoid.id = 1
   
   [<a name="order_alt-val"><b>order_alt</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg x.
          ord x =
          case OLEAST k. 0 &lt; k ‚àß x ** k = #e of NONE =&gt; 0 | SOME k =&gt; k
   
   [<a name="order_eq_0-val"><b>order_eq_0</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg x. ord x = 0 ‚áî ‚àÄn. 0 &lt; n ‚áí x ** n ‚â† #e
   
   [<a name="order_minimal-val"><b>order_minimal</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg x n. 0 &lt; n ‚àß n &lt; ord x ‚áí x ** n ‚â† #e
   
   [<a name="order_period-val"><b>order_period</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg x. 0 &lt; ord x ‚áí period g x (ord x)
   
   [<a name="order_property-val"><b>order_property</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg x. x ** ord x = #e
   
   [<a name="order_thm-val"><b>order_thm</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg x n.
          0 &lt; n ‚áí
          (ord x = n ‚áî x ** n = #e ‚àß ‚àÄm. 0 &lt; m ‚àß m &lt; n ‚áí x ** m ‚â† #e)
   
   [<a name="orders_element-val"><b>orders_element</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg x n. x ‚àà orders g n ‚áî x ‚àà G ‚àß ord x = n
   
   [<a name="orders_eq_1-val"><b>orders_eq_1</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí orders g 1 = {#e}
   
   [<a name="orders_finite-val"><b>orders_finite</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. FINITE G ‚áí ‚àÄn. FINITE (orders g n)
   
   [<a name="orders_subset-val"><b>orders_subset</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg n. orders g n ‚äÜ G
   
   [<a name="plus_mod_abelian_monoid-val"><b>plus_mod_abelian_monoid</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. 0 &lt; n ‚áí AbelianMonoid (plus_mod n)
   
   [<a name="plus_mod_exp-val"><b>plus_mod_exp</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. 0 &lt; n ‚áí ‚àÄx k. (plus_mod n).exp x k = (k * x) MOD n
   
   [<a name="plus_mod_finite-val"><b>plus_mod_finite</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. FINITE (plus_mod n).carrier
   
   [<a name="plus_mod_finite_abelian_monoid-val"><b>plus_mod_finite_abelian_monoid</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. 0 &lt; n ‚áí FiniteAbelianMonoid (plus_mod n)
   
   [<a name="plus_mod_finite_monoid-val"><b>plus_mod_finite_monoid</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. 0 &lt; n ‚áí FiniteMonoid (plus_mod n)
   
   [<a name="plus_mod_monoid-val"><b>plus_mod_monoid</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. 0 &lt; n ‚áí Monoid (plus_mod n)
   
   [<a name="plus_mod_property-val"><b>plus_mod_property</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. (plus_mod n).carrier = count n ‚àß
            (plus_mod n).op = (Œªi j. (i + j) MOD n) ‚àß (plus_mod n).id = 0 ‚àß
            (‚àÄx. x ‚àà (plus_mod n).carrier ‚áí x &lt; n) ‚àß
            FINITE (plus_mod n).carrier ‚àß CARD (plus_mod n).carrier = n
   
   [<a name="power_monoid_abelian_monoid-val"><b>power_monoid_abelian_monoid</b></a>]  Theorem
      
      ‚ä¢ ‚àÄb. AbelianMonoid (power_monoid b)
   
   [<a name="power_monoid_monoid-val"><b>power_monoid_monoid</b></a>]  Theorem
      
      ‚ä¢ ‚àÄb. Monoid (power_monoid b)
   
   [<a name="power_monoid_property-val"><b>power_monoid_property</b></a>]  Theorem
      
      ‚ä¢ ‚àÄb. (power_monoid b).carrier = {b ** j | j ‚àà ùïå(:num)} ‚àß
            (power_monoid b).op = $* ‚àß (power_monoid b).id = 1
   
   [<a name="power_to_addition_homo-val"><b>power_to_addition_homo</b></a>]  Theorem
      
      ‚ä¢ ‚àÄb. 1 &lt; b ‚áí MonoidHomo (LOG b) (power_monoid b) addition_monoid
   
   [<a name="power_to_addition_iso-val"><b>power_to_addition_iso</b></a>]  Theorem
      
      ‚ä¢ ‚àÄb. 1 &lt; b ‚áí MonoidIso (LOG b) (power_monoid b) addition_monoid
   
   [<a name="set_inter_abelian_monoid-val"><b>set_inter_abelian_monoid</b></a>]  Theorem
      
      ‚ä¢ AbelianMonoid set_inter
   
   [<a name="set_inter_monoid-val"><b>set_inter_monoid</b></a>]  Theorem
      
      ‚ä¢ Monoid set_inter
   
   [<a name="set_union_abelian_monoid-val"><b>set_union_abelian_monoid</b></a>]  Theorem
      
      ‚ä¢ AbelianMonoid set_union
   
   [<a name="set_union_monoid-val"><b>set_union_monoid</b></a>]  Theorem
      
      ‚ä¢ Monoid set_union
   
   [<a name="submonoid_I_antisym-val"><b>submonoid_I_antisym</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h. submonoid h g ‚àß submonoid g h ‚áí MonoidIso I h g
   
   [<a name="submonoid_alt-val"><b>submonoid_alt</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí
            ‚àÄh. h &lt;&lt; g ‚áî
                H ‚äÜ G ‚àß (‚àÄx y. x ‚àà H ‚àß y ‚àà H ‚áí x ‚àò y ‚àà H) ‚àß #i ‚àà H ‚àß
                $o = $* ‚àß #i = #e
   
   [<a name="submonoid_antisymmetric-val"><b>submonoid_antisymmetric</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h. h &lt;&lt; g ‚àß g &lt;&lt; h ‚áí h = g
   
   [<a name="submonoid_big_intersect_element-val"><b>submonoid_big_intersect_element</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg x. x ‚àà (smbINTER g).carrier ‚áî ‚àÄh. h &lt;&lt; g ‚áí x ‚àà H
   
   [<a name="submonoid_big_intersect_has_id-val"><b>submonoid_big_intersect_has_id</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. (smbINTER g).id ‚àà (smbINTER g).carrier
   
   [<a name="submonoid_big_intersect_monoid-val"><b>submonoid_big_intersect_monoid</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí Monoid (smbINTER g)
   
   [<a name="submonoid_big_intersect_op_element-val"><b>submonoid_big_intersect_op_element</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg x y.
          x ‚àà (smbINTER g).carrier ‚àß y ‚àà (smbINTER g).carrier ‚áí
          (smbINTER g).op x y ‚àà (smbINTER g).carrier
   
   [<a name="submonoid_big_intersect_property-val"><b>submonoid_big_intersect_property</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. (smbINTER g).carrier = BIGINTER (IMAGE (Œªh. H) {h | h &lt;&lt; g}) ‚àß
            (‚àÄx y.
               x ‚àà (smbINTER g).carrier ‚àß y ‚àà (smbINTER g).carrier ‚áí
               (smbINTER g).op x y = x * y) ‚àß (smbINTER g).id = #e
   
   [<a name="submonoid_big_intersect_submonoid-val"><b>submonoid_big_intersect_submonoid</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí smbINTER g &lt;&lt; g
   
   [<a name="submonoid_big_intersect_subset-val"><b>submonoid_big_intersect_subset</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí (smbINTER g).carrier ‚äÜ G
   
   [<a name="submonoid_carrier_antisym-val"><b>submonoid_carrier_antisym</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h. submonoid h g ‚àß G ‚äÜ H ‚áí MonoidIso I h g
   
   [<a name="submonoid_carrier_subset-val"><b>submonoid_carrier_subset</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h. h &lt;&lt; g ‚áí H ‚äÜ G
   
   [<a name="submonoid_element-val"><b>submonoid_element</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h. h &lt;&lt; g ‚áí ‚àÄx. x ‚àà H ‚áí x ‚àà G
   
   [<a name="submonoid_eqn-val"><b>submonoid_eqn</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h.
          submonoid h g ‚áî
          H ‚äÜ G ‚àß (‚àÄx y. x ‚àà H ‚àß y ‚àà H ‚áí x ‚àò y = x * y) ‚àß #i = #e
   
   [<a name="submonoid_exp-val"><b>submonoid_exp</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h. h &lt;&lt; g ‚áí ‚àÄx. x ‚àà H ‚áí ‚àÄn. h.exp x n = x ** n
   
   [<a name="submonoid_homo_homo-val"><b>submonoid_homo_homo</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h k f. submonoid h g ‚àß MonoidHomo f g k ‚áí MonoidHomo f h k
   
   [<a name="submonoid_homomorphism-val"><b>submonoid_homomorphism</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h. h &lt;&lt; g ‚áí Monoid h ‚àß Monoid g ‚àß submonoid h g
   
   [<a name="submonoid_id-val"><b>submonoid_id</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h. h &lt;&lt; g ‚áí #i = #e
   
   [<a name="submonoid_intersect_monoid-val"><b>submonoid_intersect_monoid</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h k. h &lt;&lt; g ‚àß k &lt;&lt; g ‚áí Monoid (h mINTER k)
   
   [<a name="submonoid_intersect_property-val"><b>submonoid_intersect_property</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h k.
          h &lt;&lt; g ‚àß k &lt;&lt; g ‚áí
          (h mINTER k).carrier = H ‚à© K ‚àß
          (‚àÄx y. x ‚àà H ‚à© K ‚àß y ‚àà H ‚à© K ‚áí (h mINTER k).op x y = x * y) ‚àß
          (h mINTER k).id = #e
   
   [<a name="submonoid_intersect_submonoid-val"><b>submonoid_intersect_submonoid</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h k. h &lt;&lt; g ‚àß k &lt;&lt; g ‚áí (h mINTER k) &lt;&lt; g
   
   [<a name="submonoid_monoid-val"><b>submonoid_monoid</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h. h &lt;&lt; g ‚áí Monoid h
   
   [<a name="submonoid_op-val"><b>submonoid_op</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h. h &lt;&lt; g ‚áí $o = $*
   
   [<a name="submonoid_order-val"><b>submonoid_order</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h. h &lt;&lt; g ‚áí ‚àÄx. x ‚àà H ‚áí order h x = ord x
   
   [<a name="submonoid_order_eqn-val"><b>submonoid_order_eqn</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h.
          Monoid g ‚àß Monoid h ‚àß submonoid h g ‚áí
          ‚àÄx. x ‚àà H ‚áí order h x = ord x
   
   [<a name="submonoid_property-val"><b>submonoid_property</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h.
          h &lt;&lt; g ‚áí
          Monoid h ‚àß Monoid g ‚àß H ‚äÜ G ‚àß
          (‚àÄx y. x ‚àà H ‚àß y ‚àà H ‚áí x ‚àò y = x * y) ‚àß #i = #e
   
   [<a name="submonoid_refl-val"><b>submonoid_refl</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. submonoid g g
   
   [<a name="submonoid_reflexive-val"><b>submonoid_reflexive</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. Monoid g ‚áí g &lt;&lt; g
   
   [<a name="submonoid_subset-val"><b>submonoid_subset</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h. submonoid h g ‚áí H ‚äÜ G
   
   [<a name="submonoid_trans-val"><b>submonoid_trans</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h k. submonoid g h ‚àß submonoid h k ‚áí submonoid g k
   
   [<a name="submonoid_transitive-val"><b>submonoid_transitive</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg h k. k &lt;&lt; h ‚àß h &lt;&lt; g ‚áí k &lt;&lt; g
   
   [<a name="times_mod_abelian_monoid-val"><b>times_mod_abelian_monoid</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. 0 &lt; n ‚áí AbelianMonoid (times_mod n)
   
   [<a name="times_mod_eval-val"><b>times_mod_eval</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. (times_mod n).carrier = count n ‚àß
            (‚àÄx y. (times_mod n).op x y = (x * y) MOD n) ‚àß
            (times_mod n).id = if n = 1 then 0 else 1
   
   [<a name="times_mod_exp-val"><b>times_mod_exp</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. 0 &lt; n ‚áí ‚àÄx k. (times_mod n).exp x k = (x MOD n) ** k MOD n
   
   [<a name="times_mod_finite-val"><b>times_mod_finite</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. FINITE (times_mod n).carrier
   
   [<a name="times_mod_finite_abelian_monoid-val"><b>times_mod_finite_abelian_monoid</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. 0 &lt; n ‚áí FiniteAbelianMonoid (times_mod n)
   
   [<a name="times_mod_finite_monoid-val"><b>times_mod_finite_monoid</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. 0 &lt; n ‚áí FiniteMonoid (times_mod n)
   
   [<a name="times_mod_monoid-val"><b>times_mod_monoid</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. 0 &lt; n ‚áí Monoid (times_mod n)
   
   [<a name="times_mod_property-val"><b>times_mod_property</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. (times_mod n).carrier = count n ‚àß
            (times_mod n).op = (Œªi j. (i * j) MOD n) ‚àß
            (times_mod n).id = (if n = 1 then 0 else 1) ‚àß
            (‚àÄx. x ‚àà (times_mod n).carrier ‚áí x &lt; n) ‚àß
            FINITE (times_mod n).carrier ‚àß CARD (times_mod n).carrier = n
   
   [<a name="trivial_monoid-val"><b>trivial_monoid</b></a>]  Theorem
      
      ‚ä¢ ‚àÄe. FiniteAbelianMonoid (trivial_monoid e)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/algebra/construction/.hol/objs/monoidScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-2</a></em></p></body></html>
