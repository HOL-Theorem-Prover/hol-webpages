<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure martingaleTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure martingaleTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/probability/.hol/objs/martingaleScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature martingaleTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#RN_deriv_def-val">RN_deriv_def</a> : thm
<a name="line7"></a>    val <a href="#fcp_cross_def-val">fcp_cross_def</a> : thm
<a name="line8"></a>    val <a href="#fcp_prod_def-val">fcp_prod_def</a> : thm
<a name="line9"></a>    val <a href="#fcp_sigma_def-val">fcp_sigma_def</a> : thm
<a name="line10"></a>    val <a href="#filtered_measure_space_def-val">filtered_measure_space_def</a> : thm
<a name="line11"></a>    val <a href="#filtration_def-val">filtration_def</a> : thm
<a name="line12"></a>    val <a href="#finite_measure_space-val">finite_measure_space</a> : thm
<a name="line13"></a>    val <a href="#general_cross_def-val">general_cross_def</a> : thm
<a name="line14"></a>    val <a href="#general_prod_def-val">general_prod_def</a> : thm
<a name="line15"></a>    val <a href="#general_sigma_def-val">general_sigma_def</a> : thm
<a name="line16"></a>    val <a href="#infty_sigma_algebra_def-val">infty_sigma_algebra_def</a> : thm
<a name="line17"></a>    val <a href="#lborel_2d_def-val">lborel_2d_def</a> : thm
<a name="line18"></a>    val <a href="#lp_space_def-val">lp_space_def</a> : thm
<a name="line19"></a>    val <a href="#martingale_def-val">martingale_def</a> : thm
<a name="line20"></a>    val <a href="#pair_operation_def-val">pair_operation_def</a> : thm
<a name="line21"></a>    val <a href="#prod_measure_def-val">prod_measure_def</a> : thm
<a name="line22"></a>    val <a href="#prod_measure_space_def-val">prod_measure_space_def</a> : thm
<a name="line23"></a>    val <a href="#seminorm_def-val">seminorm_def</a> : thm
<a name="line24"></a>    val <a href="#sigma_finite_filtered_measure_space_def-val">sigma_finite_filtered_measure_space_def</a> : thm
<a name="line25"></a>    val <a href="#sub_martingale_def-val">sub_martingale_def</a> : thm
<a name="line26"></a>    val <a href="#sub_sigma_algebra_def-val">sub_sigma_algebra_def</a> : thm
<a name="line27"></a>    val <a href="#super_martingale_def-val">super_martingale_def</a> : thm
<a name="line28"></a>  
<a name="line29"></a>  (*  Theorems  *)
<a name="line30"></a>    val <a href="#CROSS_ALT-val">CROSS_ALT</a> : thm
<a name="line31"></a>    val <a href="#Cauchy_Schwarz_inequality-val">Cauchy_Schwarz_inequality</a> : thm
<a name="line32"></a>    val <a href="#Cauchy_Schwarz_inequality'-val">Cauchy_Schwarz_inequality'</a> : thm
<a name="line33"></a>    val <a href="#EXISTENCE_OF_PROD_MEASURE-val">EXISTENCE_OF_PROD_MEASURE</a> : thm
<a name="line34"></a>    val <a href="#EXISTENCE_OF_PROD_MEASURE'-val">EXISTENCE_OF_PROD_MEASURE'</a> : thm
<a name="line35"></a>    val <a href="#FCP_BIGUNION_CROSS-val">FCP_BIGUNION_CROSS</a> : thm
<a name="line36"></a>    val <a href="#FCP_CROSS_BIGUNION-val">FCP_CROSS_BIGUNION</a> : thm
<a name="line37"></a>    val <a href="#FCP_CROSS_DIFF-val">FCP_CROSS_DIFF</a> : thm
<a name="line38"></a>    val <a href="#FCP_CROSS_DIFF'-val">FCP_CROSS_DIFF'</a> : thm
<a name="line39"></a>    val <a href="#FCP_INTER_CROSS-val">FCP_INTER_CROSS</a> : thm
<a name="line40"></a>    val <a href="#FCP_SUBSET_CROSS-val">FCP_SUBSET_CROSS</a> : thm
<a name="line41"></a>    val <a href="#FILTRATION-val">FILTRATION</a> : thm
<a name="line42"></a>    val <a href="#FILTRATION_BOUNDED-val">FILTRATION_BOUNDED</a> : thm
<a name="line43"></a>    val <a href="#FILTRATION_MONO-val">FILTRATION_MONO</a> : thm
<a name="line44"></a>    val <a href="#FILTRATION_SUBSETS-val">FILTRATION_SUBSETS</a> : thm
<a name="line45"></a>    val <a href="#FUBINI-val">FUBINI</a> : thm
<a name="line46"></a>    val <a href="#FUBINI'-val">FUBINI'</a> : thm
<a name="line47"></a>    val <a href="#Fubini-val">Fubini</a> : thm
<a name="line48"></a>    val <a href="#Fubini'-val">Fubini'</a> : thm
<a name="line49"></a>    val <a href="#Hoelder_inequality-val">Hoelder_inequality</a> : thm
<a name="line50"></a>    val <a href="#Hoelder_inequality'-val">Hoelder_inequality'</a> : thm
<a name="line51"></a>    val <a href="#INDICATOR_FN_FCP_CROSS-val">INDICATOR_FN_FCP_CROSS</a> : thm
<a name="line52"></a>    val <a href="#INFTY_SIGMA_ALGEBRA_BOUNDED-val">INFTY_SIGMA_ALGEBRA_BOUNDED</a> : thm
<a name="line53"></a>    val <a href="#INFTY_SIGMA_ALGEBRA_MAXIMAL-val">INFTY_SIGMA_ALGEBRA_MAXIMAL</a> : thm
<a name="line54"></a>    val <a href="#IN_FCP_CROSS-val">IN_FCP_CROSS</a> : thm
<a name="line55"></a>    val <a href="#IN_FCP_PROD-val">IN_FCP_PROD</a> : thm
<a name="line56"></a>    val <a href="#IN_MEASURABLE_BOREL_FROM_PROD_SIGMA-val">IN_MEASURABLE_BOREL_FROM_PROD_SIGMA</a> : thm
<a name="line57"></a>    val <a href="#IN_general_cross-val">IN_general_cross</a> : thm
<a name="line58"></a>    val <a href="#IN_general_prod-val">IN_general_prod</a> : thm
<a name="line59"></a>    val <a href="#L1_space_alt_integrable-val">L1_space_alt_integrable</a> : thm
<a name="line60"></a>    val <a href="#L2_space_alt_integrable_square-val">L2_space_alt_integrable_square</a> : thm
<a name="line61"></a>    val <a href="#LIM_SEQUENTIALLY_CESARO-val">LIM_SEQUENTIALLY_CESARO</a> : thm
<a name="line62"></a>    val <a href="#LIM_SEQUENTIALLY_real_normal-val">LIM_SEQUENTIALLY_real_normal</a> : thm
<a name="line63"></a>    val <a href="#MARTINGALE_EQ_SUB_SUPER-val">MARTINGALE_EQ_SUB_SUPER</a> : thm
<a name="line64"></a>    val <a href="#MEASURABLE_SPACE_PROD-val">MEASURABLE_SPACE_PROD</a> : thm
<a name="line65"></a>    val <a href="#Minkowski_inequality-val">Minkowski_inequality</a> : thm
<a name="line66"></a>    val <a href="#Minkowski_inequality'-val">Minkowski_inequality'</a> : thm
<a name="line67"></a>    val <a href="#PROD_MEASURE_CROSS-val">PROD_MEASURE_CROSS</a> : thm
<a name="line68"></a>    val <a href="#PROD_SIGMA_OF_GENERATOR-val">PROD_SIGMA_OF_GENERATOR</a> : thm
<a name="line69"></a>    val <a href="#RN_derivI-val">RN_derivI</a> : thm
<a name="line70"></a>    val <a href="#RN_deriv_positive_integral-val">RN_deriv_positive_integral</a> : thm
<a name="line71"></a>    val <a href="#RN_deriv_thm-val">RN_deriv_thm</a> : thm
<a name="line72"></a>    val <a href="#RN_deriv_thm'-val">RN_deriv_thm'</a> : thm
<a name="line73"></a>    val <a href="#SIGMA_FINITE_FILTERED_MEASURE_SPACE-val">SIGMA_FINITE_FILTERED_MEASURE_SPACE</a> : thm
<a name="line74"></a>    val <a href="#SPACE_PROD-val">SPACE_PROD</a> : thm
<a name="line75"></a>    val <a href="#SUB_SIGMA_ALGEBRA_ANTISYM-val">SUB_SIGMA_ALGEBRA_ANTISYM</a> : thm
<a name="line76"></a>    val <a href="#SUB_SIGMA_ALGEBRA_MEASURE_SPACE-val">SUB_SIGMA_ALGEBRA_MEASURE_SPACE</a> : thm
<a name="line77"></a>    val <a href="#SUB_SIGMA_ALGEBRA_ORDER-val">SUB_SIGMA_ALGEBRA_ORDER</a> : thm
<a name="line78"></a>    val <a href="#SUB_SIGMA_ALGEBRA_REFL-val">SUB_SIGMA_ALGEBRA_REFL</a> : thm
<a name="line79"></a>    val <a href="#SUB_SIGMA_ALGEBRA_TRANS-val">SUB_SIGMA_ALGEBRA_TRANS</a> : thm
<a name="line80"></a>    val <a href="#TONELLI-val">TONELLI</a> : thm
<a name="line81"></a>    val <a href="#UNIQUENESS_OF_PROD_MEASURE-val">UNIQUENESS_OF_PROD_MEASURE</a> : thm
<a name="line82"></a>    val <a href="#UNIQUENESS_OF_PROD_MEASURE'-val">UNIQUENESS_OF_PROD_MEASURE'</a> : thm
<a name="line83"></a>    val <a href="#countably_additive_eq-val">countably_additive_eq</a> : thm
<a name="line84"></a>    val <a href="#density_RN_deriv-val">density_RN_deriv</a> : thm
<a name="line85"></a>    val <a href="#density_eq-val">density_eq</a> : thm
<a name="line86"></a>    val <a href="#density_of_pos_fn-val">density_of_pos_fn</a> : thm
<a name="line87"></a>    val <a href="#exhausting_sequence_CROSS-val">exhausting_sequence_CROSS</a> : thm
<a name="line88"></a>    val <a href="#exhausting_sequence_cross-val">exhausting_sequence_cross</a> : thm
<a name="line89"></a>    val <a href="#exhausting_sequence_general_cross-val">exhausting_sequence_general_cross</a> : thm
<a name="line90"></a>    val <a href="#existence_of_prod_measure-val">existence_of_prod_measure</a> : thm
<a name="line91"></a>    val <a href="#existence_of_prod_measure_general-val">existence_of_prod_measure_general</a> : thm
<a name="line92"></a>    val <a href="#ext_liminf_imp_subseq-val">ext_liminf_imp_subseq</a> : thm
<a name="line93"></a>    val <a href="#ext_liminf_le_subseq-val">ext_liminf_le_subseq</a> : thm
<a name="line94"></a>    val <a href="#ext_limsup_imp_subseq-val">ext_limsup_imp_subseq</a> : thm
<a name="line95"></a>    val <a href="#ext_limsup_le_subseq-val">ext_limsup_le_subseq</a> : thm
<a name="line96"></a>    val <a href="#ext_limsup_thm-val">ext_limsup_thm</a> : thm
<a name="line97"></a>    val <a href="#fatou_lemma-val">fatou_lemma</a> : thm
<a name="line98"></a>    val <a href="#fatou_lemma'-val">fatou_lemma'</a> : thm
<a name="line99"></a>    val <a href="#fcp_cross_UNIV-val">fcp_cross_UNIV</a> : thm
<a name="line100"></a>    val <a href="#fcp_cross_alt-val">fcp_cross_alt</a> : thm
<a name="line101"></a>    val <a href="#fcp_prod_alt-val">fcp_prod_alt</a> : thm
<a name="line102"></a>    val <a href="#fcp_sigma_alt-val">fcp_sigma_alt</a> : thm
<a name="line103"></a>    val <a href="#filtration_from_measurable_functions-val">filtration_from_measurable_functions</a> : thm
<a name="line104"></a>    val <a href="#finite_measure_space_def-val">finite_measure_space_def</a> : thm
<a name="line105"></a>    val <a href="#general_BIGUNION_CROSS-val">general_BIGUNION_CROSS</a> : thm
<a name="line106"></a>    val <a href="#general_CROSS_BIGUNION-val">general_CROSS_BIGUNION</a> : thm
<a name="line107"></a>    val <a href="#general_CROSS_DIFF-val">general_CROSS_DIFF</a> : thm
<a name="line108"></a>    val <a href="#general_CROSS_DIFF'-val">general_CROSS_DIFF'</a> : thm
<a name="line109"></a>    val <a href="#general_INTER_CROSS-val">general_INTER_CROSS</a> : thm
<a name="line110"></a>    val <a href="#general_SUBSET_CROSS-val">general_SUBSET_CROSS</a> : thm
<a name="line111"></a>    val <a href="#general_sigma_of_generator-val">general_sigma_of_generator</a> : thm
<a name="line112"></a>    val <a href="#indicator_fn_general_cross-val">indicator_fn_general_cross</a> : thm
<a name="line113"></a>    val <a href="#integrable_AE_finite-val">integrable_AE_finite</a> : thm
<a name="line114"></a>    val <a href="#integrable_add'-val">integrable_add'</a> : thm
<a name="line115"></a>    val <a href="#integrable_cong_AE-val">integrable_cong_AE</a> : thm
<a name="line116"></a>    val <a href="#integrable_cong_AE_alt-val">integrable_cong_AE_alt</a> : thm
<a name="line117"></a>    val <a href="#integrable_cong_measure-val">integrable_cong_measure</a> : thm
<a name="line118"></a>    val <a href="#integrable_cong_measure'-val">integrable_cong_measure'</a> : thm
<a name="line119"></a>    val <a href="#integrable_eq_AE_alt-val">integrable_eq_AE_alt</a> : thm
<a name="line120"></a>    val <a href="#integrable_measurable-val">integrable_measurable</a> : thm
<a name="line121"></a>    val <a href="#integrable_sub'-val">integrable_sub'</a> : thm
<a name="line122"></a>    val <a href="#integrable_sum'-val">integrable_sum'</a> : thm
<a name="line123"></a>    val <a href="#integral_add'-val">integral_add'</a> : thm
<a name="line124"></a>    val <a href="#integral_add3-val">integral_add3</a> : thm
<a name="line125"></a>    val <a href="#integral_cong_measure-val">integral_cong_measure</a> : thm
<a name="line126"></a>    val <a href="#integral_cong_measure'-val">integral_cong_measure'</a> : thm
<a name="line127"></a>    val <a href="#integral_distr-val">integral_distr</a> : thm
<a name="line128"></a>    val <a href="#integral_mono_AE-val">integral_mono_AE</a> : thm
<a name="line129"></a>    val <a href="#integral_sub'-val">integral_sub'</a> : thm
<a name="line130"></a>    val <a href="#integral_sum'-val">integral_sum'</a> : thm
<a name="line131"></a>    val <a href="#lborel_2d_prod_measure-val">lborel_2d_prod_measure</a> : thm
<a name="line132"></a>    val <a href="#lebesgue_dominated_convergence-val">lebesgue_dominated_convergence</a> : thm
<a name="line133"></a>    val <a href="#lp_space_AE_normal-val">lp_space_AE_normal</a> : thm
<a name="line134"></a>    val <a href="#lp_space_add-val">lp_space_add</a> : thm
<a name="line135"></a>    val <a href="#lp_space_add_cmul-val">lp_space_add_cmul</a> : thm
<a name="line136"></a>    val <a href="#lp_space_alt_finite-val">lp_space_alt_finite</a> : thm
<a name="line137"></a>    val <a href="#lp_space_alt_finite'-val">lp_space_alt_finite'</a> : thm
<a name="line138"></a>    val <a href="#lp_space_alt_infinite-val">lp_space_alt_infinite</a> : thm
<a name="line139"></a>    val <a href="#lp_space_alt_seminorm-val">lp_space_alt_seminorm</a> : thm
<a name="line140"></a>    val <a href="#lp_space_cmul-val">lp_space_cmul</a> : thm
<a name="line141"></a>    val <a href="#lp_space_cong-val">lp_space_cong</a> : thm
<a name="line142"></a>    val <a href="#lp_space_cong_AE-val">lp_space_cong_AE</a> : thm
<a name="line143"></a>    val <a href="#lp_space_sub-val">lp_space_sub</a> : thm
<a name="line144"></a>    val <a href="#martingale_alt-val">martingale_alt</a> : thm
<a name="line145"></a>    val <a href="#martingale_alt_generator-val">martingale_alt_generator</a> : thm
<a name="line146"></a>    val <a href="#measure_of_eq-val">measure_of_eq</a> : thm
<a name="line147"></a>    val <a href="#measure_of_eq'-val">measure_of_eq'</a> : thm
<a name="line148"></a>    val <a href="#measure_of_reduce-val">measure_of_reduce</a> : thm
<a name="line149"></a>    val <a href="#measure_space_prod_measure-val">measure_space_prod_measure</a> : thm
<a name="line150"></a>    val <a href="#measure_space_sigma_sets_eq-val">measure_space_sigma_sets_eq</a> : thm
<a name="line151"></a>    val <a href="#pair_operation_CONS-val">pair_operation_CONS</a> : thm
<a name="line152"></a>    val <a href="#pair_operation_FCP_CONCAT-val">pair_operation_FCP_CONCAT</a> : thm
<a name="line153"></a>    val <a href="#pair_operation_pair-val">pair_operation_pair</a> : thm
<a name="line154"></a>    val <a href="#pos_fn_integrable_AE_finite-val">pos_fn_integrable_AE_finite</a> : thm
<a name="line155"></a>    val <a href="#pos_fn_integral_add3-val">pos_fn_integral_add3</a> : thm
<a name="line156"></a>    val <a href="#pos_fn_integral_cong_measure-val">pos_fn_integral_cong_measure</a> : thm
<a name="line157"></a>    val <a href="#pos_fn_integral_cong_measure'-val">pos_fn_integral_cong_measure'</a> : thm
<a name="line158"></a>    val <a href="#pos_fn_integral_density-val">pos_fn_integral_density</a> : thm
<a name="line159"></a>    val <a href="#pos_fn_integral_density_of-val">pos_fn_integral_density_of</a> : thm
<a name="line160"></a>    val <a href="#pos_fn_integral_density_of_reduce-val">pos_fn_integral_density_of_reduce</a> : thm
<a name="line161"></a>    val <a href="#pos_fn_integral_density_reduce-val">pos_fn_integral_density_reduce</a> : thm
<a name="line162"></a>    val <a href="#pos_fn_integral_distr-val">pos_fn_integral_distr</a> : thm
<a name="line163"></a>    val <a href="#pos_fn_integral_distr_of-val">pos_fn_integral_distr_of</a> : thm
<a name="line164"></a>    val <a href="#pos_fn_integral_exchange-val">pos_fn_integral_exchange</a> : thm
<a name="line165"></a>    val <a href="#positive_cong_eq-val">positive_cong_eq</a> : thm
<a name="line166"></a>    val <a href="#prod_measure_space_alt-val">prod_measure_space_alt</a> : thm
<a name="line167"></a>    val <a href="#prod_sets_alt-val">prod_sets_alt</a> : thm
<a name="line168"></a>    val <a href="#prod_sigma_alt-val">prod_sigma_alt</a> : thm
<a name="line169"></a>    val <a href="#prod_sigma_of_generator-val">prod_sigma_of_generator</a> : thm
<a name="line170"></a>    val <a href="#seminorm_cmul-val">seminorm_cmul</a> : thm
<a name="line171"></a>    val <a href="#seminorm_cong-val">seminorm_cong</a> : thm
<a name="line172"></a>    val <a href="#seminorm_cong_AE-val">seminorm_cong_AE</a> : thm
<a name="line173"></a>    val <a href="#seminorm_eq_0-val">seminorm_eq_0</a> : thm
<a name="line174"></a>    val <a href="#seminorm_infty-val">seminorm_infty</a> : thm
<a name="line175"></a>    val <a href="#seminorm_infty_AE_bound-val">seminorm_infty_AE_bound</a> : thm
<a name="line176"></a>    val <a href="#seminorm_infty_alt-val">seminorm_infty_alt</a> : thm
<a name="line177"></a>    val <a href="#seminorm_normal-val">seminorm_normal</a> : thm
<a name="line178"></a>    val <a href="#seminorm_not_infty-val">seminorm_not_infty</a> : thm
<a name="line179"></a>    val <a href="#seminorm_one-val">seminorm_one</a> : thm
<a name="line180"></a>    val <a href="#seminorm_pos-val">seminorm_pos</a> : thm
<a name="line181"></a>    val <a href="#seminorm_powr-val">seminorm_powr</a> : thm
<a name="line182"></a>    val <a href="#seminorm_two-val">seminorm_two</a> : thm
<a name="line183"></a>    val <a href="#seminorm_zero-val">seminorm_zero</a> : thm
<a name="line184"></a>    val <a href="#sigma_algebra_general_sigma-val">sigma_algebra_general_sigma</a> : thm
<a name="line185"></a>    val <a href="#sigma_algebra_prod_sigma-val">sigma_algebra_prod_sigma</a> : thm
<a name="line186"></a>    val <a href="#sigma_algebra_prod_sigma'-val">sigma_algebra_prod_sigma'</a> : thm
<a name="line187"></a>    val <a href="#sigma_finite_filtered_measure_space_alt-val">sigma_finite_filtered_measure_space_alt</a> : thm
<a name="line188"></a>    val <a href="#sigma_finite_filtered_measure_space_alt_all-val">sigma_finite_filtered_measure_space_alt_all</a> : thm
<a name="line189"></a>    val <a href="#sub_martingale_alt-val">sub_martingale_alt</a> : thm
<a name="line190"></a>    val <a href="#sub_martingale_alt_generator-val">sub_martingale_alt_generator</a> : thm
<a name="line191"></a>    val <a href="#super_martingale_alt-val">super_martingale_alt</a> : thm
<a name="line192"></a>    val <a href="#super_martingale_alt_generator-val">super_martingale_alt_generator</a> : thm
<a name="line193"></a>    val <a href="#uniqueness_of_prod_measure-val">uniqueness_of_prod_measure</a> : thm
<a name="line194"></a>    val <a href="#uniqueness_of_prod_measure'-val">uniqueness_of_prod_measure'</a> : thm
<a name="line195"></a>    val <a href="#uniqueness_of_prod_measure_general-val">uniqueness_of_prod_measure_general</a> : thm
<a name="line196"></a>    val <a href="#uniqueness_of_prod_measure_general'-val">uniqueness_of_prod_measure_general'</a> : thm
<a name="line197"></a>(*
   [fcp] Parent theory of "martingale"
   
   [lebesgue] Parent theory of "martingale"
   
   [<a name="RN_deriv_def-val"><b>RN_deriv_def</b></a>]  Definition
      
      ⊢ ∀v m.
          v / m =
          @f. f ∈ Borel_measurable (measurable_space m) ∧
              (∀x. x ∈ m_space m ⇒ 0 ≤ f x) ∧
              ∀s. s ∈ measurable_sets m ⇒ (f * m) s = v s
   
   [<a name="fcp_cross_def-val"><b>fcp_cross_def</b></a>]  Definition
      
      ⊢ ∀A B. fcp_cross A B = {FCP_CONCAT a b | a ∈ A ∧ b ∈ B}
   
   [<a name="fcp_prod_def-val"><b>fcp_prod_def</b></a>]  Definition
      
      ⊢ ∀a b. fcp_prod a b = {fcp_cross s t | s ∈ a ∧ t ∈ b}
   
   [<a name="fcp_sigma_def-val"><b>fcp_sigma_def</b></a>]  Definition
      
      ⊢ ∀a b.
          fcp_sigma a b =
          sigma (fcp_cross (space a) (space b))
            (fcp_prod (subsets a) (subsets b))
   
   [<a name="filtered_measure_space_def-val"><b>filtered_measure_space_def</b></a>]  Definition
      
      ⊢ ∀m a.
          filtered_measure_space m a ⇔
          measure_space m ∧ filtration (measurable_space m) a
   
   [<a name="filtration_def-val"><b>filtration_def</b></a>]  Definition
      
      ⊢ ∀A a.
          filtration A a ⇔
          (∀n. sub_sigma_algebra (a n) A) ∧
          ∀i j. i ≤ j ⇒ subsets (a i) ⊆ subsets (a j)
   
   [<a name="finite_measure_space-val"><b>finite_measure_space</b></a>]  Definition
      
      ⊢ ∀m. finite_measure_space m ⇔
            sigma_finite_measure_space m ∧ measure m (m_space m) ≠ +∞
   
   [<a name="general_cross_def-val"><b>general_cross_def</b></a>]  Definition
      
      ⊢ ∀cons A B. general_cross cons A B = {cons a b | a ∈ A ∧ b ∈ B}
   
   [<a name="general_prod_def-val"><b>general_prod_def</b></a>]  Definition
      
      ⊢ ∀cons A B.
          general_prod cons A B = {general_cross cons a b | a ∈ A ∧ b ∈ B}
   
   [<a name="general_sigma_def-val"><b>general_sigma_def</b></a>]  Definition
      
      ⊢ ∀cons A B.
          general_sigma cons A B =
          sigma (general_cross cons (space A) (space B))
            (general_prod cons (subsets A) (subsets B))
   
   [<a name="infty_sigma_algebra_def-val"><b>infty_sigma_algebra_def</b></a>]  Definition
      
      ⊢ ∀sp a.
          infty_sigma_algebra sp a =
          sigma sp (BIGUNION (IMAGE (λi. subsets (a i)) 𝕌(:num)))
   
   [<a name="lborel_2d_def-val"><b>lborel_2d_def</b></a>]  Definition
      
      ⊢ sigma_finite_measure_space lborel_2d ∧
        m_space lborel_2d = 𝕌(:real) × 𝕌(:real) ∧
        measurable_sets lborel_2d =
        subsets ((𝕌(:real),subsets borel) × (𝕌(:real),subsets borel)) ∧
        (∀s t.
           s ∈ subsets borel ∧ t ∈ subsets borel ⇒
           measure lborel_2d (s × t) = lambda s * lambda t) ∧
        ∀s. s ∈ measurable_sets lborel_2d ⇒
            (∀x. (λy. 𝟙 s (x,y)) ∈ Borel_measurable borel) ∧
            (∀y. (λx. 𝟙 s (x,y)) ∈ Borel_measurable borel) ∧
            (λy. ∫⁺ lborel (λx. 𝟙 s (x,y))) ∈ Borel_measurable borel ∧
            (λx. ∫⁺ lborel (λy. 𝟙 s (x,y))) ∈ Borel_measurable borel ∧
            measure lborel_2d s = ∫⁺ lborel (λy. ∫⁺ lborel (λx. 𝟙 s (x,y))) ∧
            measure lborel_2d s = ∫⁺ lborel (λx. ∫⁺ lborel (λy. 𝟙 s (x,y)))
   
   [<a name="lp_space_def-val"><b>lp_space_def</b></a>]  Definition
      
      ⊢ ∀p m.
          lp_space p m =
          {f |
           f ∈ Borel_measurable (measurable_space m) ∧
           if p = +∞ then
             ∃c. 0 &lt; c ∧ c ≠ +∞ ∧
                 measure m {x | x ∈ m_space m ∧ c ≤ abs (f x)} = 0
           else ∫⁺ m (λx. abs (f x) powr p) ≠ +∞}
   
   [<a name="martingale_def-val"><b>martingale_def</b></a>]  Definition
      
      ⊢ ∀m a u.
          martingale m a u ⇔
          sigma_finite_filtered_measure_space m a ∧
          (∀n. integrable m (u n)) ∧
          ∀n s.
            s ∈ subsets (a n) ⇒
            ∫ m (λx. u (SUC n) x * 𝟙 s x) = ∫ m (λx. u n x * 𝟙 s x)
   
   [<a name="pair_operation_def-val"><b>pair_operation_def</b></a>]  Definition
      
      ⊢ ∀cons car cdr.
          pair_operation cons car cdr ⇔
          (∀a b. car (cons a b) = a ∧ cdr (cons a b) = b) ∧
          ∀a b c d. cons a b = cons c d ⇔ a = c ∧ b = d
   
   [<a name="prod_measure_def-val"><b>prod_measure_def</b></a>]  Definition
      
      ⊢ ∀m1 m2.
          prod_measure m1 m2 = (λs. ∫⁺ m2 (λy. ∫⁺ m1 (λx. 𝟙 s (x,y))))
   
   [<a name="prod_measure_space_def-val"><b>prod_measure_space_def</b></a>]  Definition
      
      ⊢ ∀m1 m2.
          m1 × m2 =
          (m_space m1 × m_space m2,
           subsets (measurable_space m1 × measurable_space m2),
           prod_measure m1 m2)
   
   [<a name="seminorm_def-val"><b>seminorm_def</b></a>]  Definition
      
      ⊢ ∀p m f.
          seminorm p m f =
          if p = +∞ then
            inf
              {c |
               0 &lt; c ∧ measure m {x | x ∈ m_space m ∧ c ≤ abs (f x)} = 0}
          else ∫⁺ m (λx. abs (f x) powr p) powr p⁻¹
   
   [<a name="sigma_finite_filtered_measure_space_def-val"><b>sigma_finite_filtered_measure_space_def</b></a>]  Definition
      
      ⊢ ∀m a.
          sigma_finite_filtered_measure_space m a ⇔
          filtered_measure_space m a ∧
          sigma_finite (m_space m,subsets (a 0),measure m)
   
   [<a name="sub_martingale_def-val"><b>sub_martingale_def</b></a>]  Definition
      
      ⊢ ∀m a u.
          sub_martingale m a u ⇔
          sigma_finite_filtered_measure_space m a ∧
          (∀n. integrable m (u n)) ∧
          ∀n s.
            s ∈ subsets (a n) ⇒
            ∫ m (λx. u n x * 𝟙 s x) ≤ ∫ m (λx. u (SUC n) x * 𝟙 s x)
   
   [<a name="sub_sigma_algebra_def-val"><b>sub_sigma_algebra_def</b></a>]  Definition
      
      ⊢ ∀a b.
          sub_sigma_algebra a b ⇔
          sigma_algebra a ∧ sigma_algebra b ∧ space a = space b ∧
          subsets a ⊆ subsets b
   
   [<a name="super_martingale_def-val"><b>super_martingale_def</b></a>]  Definition
      
      ⊢ ∀m a u.
          super_martingale m a u ⇔
          sigma_finite_filtered_measure_space m a ∧
          (∀n. integrable m (u n)) ∧
          ∀n s.
            s ∈ subsets (a n) ⇒
            ∫ m (λx. u (SUC n) x * 𝟙 s x) ≤ ∫ m (λx. u n x * 𝟙 s x)
   
   [<a name="CROSS_ALT-val"><b>CROSS_ALT</b></a>]  Theorem
      
      ⊢ ∀A B. A × B = general_cross $, A B
   
   [<a name="Cauchy_Schwarz_inequality-val"><b>Cauchy_Schwarz_inequality</b></a>]  Theorem
      
      ⊢ ∀m u v.
          measure_space m ∧ u ∈ L2_space m ∧ v ∈ L2_space m ⇒
          integrable m (λx. u x * v x) ∧
          ∫ m (λx. abs (u x * v x)) ≤ seminorm 2 m u * seminorm 2 m v
   
   [<a name="Cauchy_Schwarz_inequality'-val"><b>Cauchy_Schwarz_inequality'</b></a>]  Theorem
      
      ⊢ ∀m u v.
          measure_space m ∧ u ∈ L2_space m ∧ v ∈ L2_space m ⇒
          ∫⁺ m (λx. abs (u x * v x)) ≤
          sqrt (∫⁺ m (λx. (u x)²) * ∫⁺ m (λx. (v x)²))
   
   [<a name="EXISTENCE_OF_PROD_MEASURE-val"><b>EXISTENCE_OF_PROD_MEASURE</b></a>]  Theorem
      
      ⊢ ∀X Y A B u v m0.
          sigma_finite_measure_space (X,A,u) ∧
          sigma_finite_measure_space (Y,B,v) ∧
          (∀s t. s ∈ A ∧ t ∈ B ⇒ m0 (s × t) = u s * v t) ⇒
          (∀s. s ∈ subsets ((X,A) × (Y,B)) ⇒
               (∀x. x ∈ X ⇒ (λy. 𝟙 s (x,y)) ∈ Borel_measurable (Y,B)) ∧
               (∀y. y ∈ Y ⇒ (λx. 𝟙 s (x,y)) ∈ Borel_measurable (X,A)) ∧
               (λy. ∫⁺ (X,A,u) (λx. 𝟙 s (x,y))) ∈ Borel_measurable (Y,B) ∧
               (λx. ∫⁺ (Y,B,v) (λy. 𝟙 s (x,y))) ∈ Borel_measurable (X,A)) ∧
          ∃m. sigma_finite_measure_space (X × Y,subsets ((X,A) × (Y,B)),m) ∧
              (∀s. s ∈ prod_sets A B ⇒ m s = m0 s) ∧
              ∀s. s ∈ subsets ((X,A) × (Y,B)) ⇒
                  m s = ∫⁺ (Y,B,v) (λy. ∫⁺ (X,A,u) (λx. 𝟙 s (x,y))) ∧
                  m s = ∫⁺ (X,A,u) (λx. ∫⁺ (Y,B,v) (λy. 𝟙 s (x,y)))
   
   [<a name="EXISTENCE_OF_PROD_MEASURE'-val"><b>EXISTENCE_OF_PROD_MEASURE'</b></a>]  Theorem
      
      ⊢ ∀X Y A B u v m0.
          sigma_finite_measure_space (X,A,u) ∧
          sigma_finite_measure_space (Y,B,v) ∧
          (∀s t. s ∈ A ∧ t ∈ B ⇒ m0 (s × t) = u s * v t) ⇒
          (∀s. s ∈ subsets ((X,A) × (Y,B)) ⇒
               (∀x. x ∈ X ⇒ (λy. 𝟙 s (x,y)) ∈ Borel_measurable (Y,B)) ∧
               (∀y. y ∈ Y ⇒ (λx. 𝟙 s (x,y)) ∈ Borel_measurable (X,A)) ∧
               (λy. ∫ (X,A,u) (λx. 𝟙 s (x,y))) ∈ Borel_measurable (Y,B) ∧
               (λx. ∫ (Y,B,v) (λy. 𝟙 s (x,y))) ∈ Borel_measurable (X,A)) ∧
          ∃m. sigma_finite_measure_space (X × Y,subsets ((X,A) × (Y,B)),m) ∧
              (∀s. s ∈ prod_sets A B ⇒ m s = m0 s) ∧
              ∀s. s ∈ subsets ((X,A) × (Y,B)) ⇒
                  m s = ∫ (Y,B,v) (λy. ∫ (X,A,u) (λx. 𝟙 s (x,y))) ∧
                  m s = ∫ (X,A,u) (λx. ∫ (Y,B,v) (λy. 𝟙 s (x,y)))
   
   [<a name="FCP_BIGUNION_CROSS-val"><b>FCP_BIGUNION_CROSS</b></a>]  Theorem
      
      ⊢ ∀f s t.
          fcp_cross (BIGUNION (IMAGE f s)) t =
          BIGUNION (IMAGE (λn. fcp_cross (f n) t) s)
   
   [<a name="FCP_CROSS_BIGUNION-val"><b>FCP_CROSS_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀f s t.
          fcp_cross t (BIGUNION (IMAGE f s)) =
          BIGUNION (IMAGE (λn. fcp_cross t (f n)) s)
   
   [<a name="FCP_CROSS_DIFF-val"><b>FCP_CROSS_DIFF</b></a>]  Theorem
      
      ⊢ ∀X s t.
          FINITE 𝕌(:β) ∧ FINITE 𝕌(:γ) ⇒
          fcp_cross (X DIFF s) t = fcp_cross X t DIFF fcp_cross s t
   
   [<a name="FCP_CROSS_DIFF'-val"><b>FCP_CROSS_DIFF'</b></a>]  Theorem
      
      ⊢ ∀s X t.
          FINITE 𝕌(:β) ∧ FINITE 𝕌(:γ) ⇒
          fcp_cross s (X DIFF t) = fcp_cross s X DIFF fcp_cross s t
   
   [<a name="FCP_INTER_CROSS-val"><b>FCP_INTER_CROSS</b></a>]  Theorem
      
      ⊢ ∀a b c d.
          FINITE 𝕌(:β) ∧ FINITE 𝕌(:γ) ⇒
          fcp_cross a b ∩ fcp_cross c d = fcp_cross (a ∩ c) (b ∩ d)
   
   [<a name="FCP_SUBSET_CROSS-val"><b>FCP_SUBSET_CROSS</b></a>]  Theorem
      
      ⊢ ∀a b c d. a ⊆ b ∧ c ⊆ d ⇒ fcp_cross a c ⊆ fcp_cross b d
   
   [<a name="FILTRATION-val"><b>FILTRATION</b></a>]  Theorem
      
      ⊢ ∀A a.
          filtration A a ⇔
          (∀n. sub_sigma_algebra (a n) A) ∧
          (∀n. subsets (a n) ⊆ subsets A) ∧
          ∀i j. i ≤ j ⇒ subsets (a i) ⊆ subsets (a j)
   
   [<a name="FILTRATION_BOUNDED-val"><b>FILTRATION_BOUNDED</b></a>]  Theorem
      
      ⊢ ∀A a. filtration A a ⇒ ∀n. sub_sigma_algebra (a n) A
   
   [<a name="FILTRATION_MONO-val"><b>FILTRATION_MONO</b></a>]  Theorem
      
      ⊢ ∀A a. filtration A a ⇒ ∀i j. i ≤ j ⇒ subsets (a i) ⊆ subsets (a j)
   
   [<a name="FILTRATION_SUBSETS-val"><b>FILTRATION_SUBSETS</b></a>]  Theorem
      
      ⊢ ∀A a. filtration A a ⇒ ∀n. subsets (a n) ⊆ subsets A
   
   [<a name="FUBINI-val"><b>FUBINI</b></a>]  Theorem
      
      ⊢ ∀X Y A B u v f.
          sigma_finite_measure_space (X,A,u) ∧
          sigma_finite_measure_space (Y,B,v) ∧
          f ∈ Borel_measurable ((X,A) × (Y,B)) ∧
          (∫⁺ ((X,A,u) × (Y,B,v)) (abs ∘ f) ≠ +∞ ∨
           ∫⁺ (Y,B,v) (λy. ∫⁺ (X,A,u) (λx. (abs ∘ f) (x,y))) ≠ +∞ ∨
           ∫⁺ (X,A,u) (λx. ∫⁺ (Y,B,v) (λy. (abs ∘ f) (x,y))) ≠ +∞) ⇒
          ∫⁺ ((X,A,u) × (Y,B,v)) (abs ∘ f) ≠ +∞ ∧
          ∫⁺ (Y,B,v) (λy. ∫⁺ (X,A,u) (λx. (abs ∘ f) (x,y))) ≠ +∞ ∧
          ∫⁺ (X,A,u) (λx. ∫⁺ (Y,B,v) (λy. (abs ∘ f) (x,y))) ≠ +∞ ∧
          integrable ((X,A,u) × (Y,B,v)) f ∧
          (AE y::(Y,B,v). integrable (X,A,u) (λx. f (x,y))) ∧
          (AE x::(X,A,u). integrable (Y,B,v) (λy. f (x,y))) ∧
          integrable (X,A,u) (λx. ∫ (Y,B,v) (λy. f (x,y))) ∧
          integrable (Y,B,v) (λy. ∫ (X,A,u) (λx. f (x,y))) ∧
          ∫ ((X,A,u) × (Y,B,v)) f = ∫ (Y,B,v) (λy. ∫ (X,A,u) (λx. f (x,y))) ∧
          ∫ ((X,A,u) × (Y,B,v)) f = ∫ (X,A,u) (λx. ∫ (Y,B,v) (λy. f (x,y)))
   
   [<a name="FUBINI'-val"><b>FUBINI'</b></a>]  Theorem
      
      ⊢ ∀X Y A B u v f.
          sigma_finite_measure_space (X,A,u) ∧
          sigma_finite_measure_space (Y,B,v) ∧
          f ∈ Borel_measurable ((X,A) × (Y,B)) ∧
          (∫ ((X,A,u) × (Y,B,v)) (abs ∘ f) ≠ +∞ ∨
           ∫ (Y,B,v) (λy. ∫ (X,A,u) (λx. (abs ∘ f) (x,y))) ≠ +∞ ∨
           ∫ (X,A,u) (λx. ∫ (Y,B,v) (λy. (abs ∘ f) (x,y))) ≠ +∞) ⇒
          ∫ ((X,A,u) × (Y,B,v)) (abs ∘ f) ≠ +∞ ∧
          ∫ (Y,B,v) (λy. ∫ (X,A,u) (λx. (abs ∘ f) (x,y))) ≠ +∞ ∧
          ∫ (X,A,u) (λx. ∫ (Y,B,v) (λy. (abs ∘ f) (x,y))) ≠ +∞ ∧
          integrable ((X,A,u) × (Y,B,v)) f ∧
          (AE y::(Y,B,v). integrable (X,A,u) (λx. f (x,y))) ∧
          (AE x::(X,A,u). integrable (Y,B,v) (λy. f (x,y))) ∧
          integrable (X,A,u) (λx. ∫ (Y,B,v) (λy. f (x,y))) ∧
          integrable (Y,B,v) (λy. ∫ (X,A,u) (λx. f (x,y))) ∧
          ∫ ((X,A,u) × (Y,B,v)) f = ∫ (Y,B,v) (λy. ∫ (X,A,u) (λx. f (x,y))) ∧
          ∫ ((X,A,u) × (Y,B,v)) f = ∫ (X,A,u) (λx. ∫ (Y,B,v) (λy. f (x,y)))
   
   [<a name="Fubini-val"><b>Fubini</b></a>]  Theorem
      
      ⊢ ∀m1 m2 f.
          sigma_finite_measure_space m1 ∧ sigma_finite_measure_space m2 ∧
          f ∈ Borel_measurable (measurable_space m1 × measurable_space m2) ∧
          (∫⁺ (m1 × m2) (abs ∘ f) ≠ +∞ ∨
           ∫⁺ m2 (λy. ∫⁺ m1 (λx. (abs ∘ f) (x,y))) ≠ +∞ ∨
           ∫⁺ m1 (λx. ∫⁺ m2 (λy. (abs ∘ f) (x,y))) ≠ +∞) ⇒
          ∫⁺ (m1 × m2) (abs ∘ f) ≠ +∞ ∧
          ∫⁺ m2 (λy. ∫⁺ m1 (λx. (abs ∘ f) (x,y))) ≠ +∞ ∧
          ∫⁺ m1 (λx. ∫⁺ m2 (λy. (abs ∘ f) (x,y))) ≠ +∞ ∧
          integrable (m1 × m2) f ∧
          (AE y::m2. integrable m1 (λx. f (x,y))) ∧
          (AE x::m1. integrable m2 (λy. f (x,y))) ∧
          integrable m1 (λx. ∫ m2 (λy. f (x,y))) ∧
          integrable m2 (λy. ∫ m1 (λx. f (x,y))) ∧
          ∫ (m1 × m2) f = ∫ m2 (λy. ∫ m1 (λx. f (x,y))) ∧
          ∫ (m1 × m2) f = ∫ m1 (λx. ∫ m2 (λy. f (x,y)))
   
   [<a name="Fubini'-val"><b>Fubini'</b></a>]  Theorem
      
      ⊢ ∀m1 m2 f.
          sigma_finite_measure_space m1 ∧ sigma_finite_measure_space m2 ∧
          f ∈ Borel_measurable (measurable_space m1 × measurable_space m2) ∧
          (∫ (m1 × m2) (abs ∘ f) ≠ +∞ ∨
           ∫ m2 (λy. ∫ m1 (λx. (abs ∘ f) (x,y))) ≠ +∞ ∨
           ∫ m1 (λx. ∫ m2 (λy. (abs ∘ f) (x,y))) ≠ +∞) ⇒
          ∫ (m1 × m2) (abs ∘ f) ≠ +∞ ∧
          ∫ m2 (λy. ∫ m1 (λx. (abs ∘ f) (x,y))) ≠ +∞ ∧
          ∫ m1 (λx. ∫ m2 (λy. (abs ∘ f) (x,y))) ≠ +∞ ∧
          integrable (m1 × m2) f ∧
          (AE y::m2. integrable m1 (λx. f (x,y))) ∧
          (AE x::m1. integrable m2 (λy. f (x,y))) ∧
          integrable m1 (λx. ∫ m2 (λy. f (x,y))) ∧
          integrable m2 (λy. ∫ m1 (λx. f (x,y))) ∧
          ∫ (m1 × m2) f = ∫ m2 (λy. ∫ m1 (λx. f (x,y))) ∧
          ∫ (m1 × m2) f = ∫ m1 (λx. ∫ m2 (λy. f (x,y)))
   
   [<a name="Hoelder_inequality-val"><b>Hoelder_inequality</b></a>]  Theorem
      
      ⊢ ∀m u v p q.
          measure_space m ∧ 0 &lt; p ∧ 0 &lt; q ∧ p⁻¹ + q⁻¹ = 1 ∧
          u ∈ lp_space p m ∧ v ∈ lp_space q m ⇒
          integrable m (λx. u x * v x) ∧
          ∫ m (λx. abs (u x * v x)) ≤ seminorm p m u * seminorm q m v
   
   [<a name="Hoelder_inequality'-val"><b>Hoelder_inequality'</b></a>]  Theorem
      
      ⊢ ∀m u v p q.
          measure_space m ∧ 0 &lt; p ∧ 0 &lt; q ∧ p⁻¹ + q⁻¹ = 1 ∧
          u ∈ lp_space p m ∧ v ∈ lp_space q m ⇒
          ∫⁺ m (λx. abs (u x * v x)) ≤ seminorm p m u * seminorm q m v
   
   [<a name="INDICATOR_FN_FCP_CROSS-val"><b>INDICATOR_FN_FCP_CROSS</b></a>]  Theorem
      
      ⊢ ∀s t x y.
          FINITE 𝕌(:β) ∧ FINITE 𝕌(:γ) ⇒
          𝟙 (fcp_cross s t) (FCP_CONCAT x y) = 𝟙 s x * 𝟙 t y
   
   [<a name="INFTY_SIGMA_ALGEBRA_BOUNDED-val"><b>INFTY_SIGMA_ALGEBRA_BOUNDED</b></a>]  Theorem
      
      ⊢ ∀A a.
          filtration A a ⇒
          sub_sigma_algebra (infty_sigma_algebra (space A) a) A
   
   [<a name="INFTY_SIGMA_ALGEBRA_MAXIMAL-val"><b>INFTY_SIGMA_ALGEBRA_MAXIMAL</b></a>]  Theorem
      
      ⊢ ∀A a.
          filtration A a ⇒
          ∀n. sub_sigma_algebra (a n) (infty_sigma_algebra (space A) a)
   
   [<a name="IN_FCP_CROSS-val"><b>IN_FCP_CROSS</b></a>]  Theorem
      
      ⊢ ∀s a b.
          s ∈ fcp_cross a b ⇔ ∃t u. s = FCP_CONCAT t u ∧ t ∈ a ∧ u ∈ b
   
   [<a name="IN_FCP_PROD-val"><b>IN_FCP_PROD</b></a>]  Theorem
      
      ⊢ ∀s A B. s ∈ fcp_prod A B ⇔ ∃a b. s = fcp_cross a b ∧ a ∈ A ∧ b ∈ B
   
   [<a name="IN_MEASURABLE_BOREL_FROM_PROD_SIGMA-val"><b>IN_MEASURABLE_BOREL_FROM_PROD_SIGMA</b></a>]  Theorem
      
      ⊢ ∀X Y A B f.
          sigma_algebra (X,A) ∧ sigma_algebra (Y,B) ∧
          f ∈ Borel_measurable ((X,A) × (Y,B)) ⇒
          (∀y. y ∈ Y ⇒ (λx. f (x,y)) ∈ Borel_measurable (X,A)) ∧
          ∀x. x ∈ X ⇒ (λy. f (x,y)) ∈ Borel_measurable (Y,B)
   
   [<a name="IN_general_cross-val"><b>IN_general_cross</b></a>]  Theorem
      
      ⊢ ∀cons s A B.
          s ∈ general_cross cons A B ⇔ ∃a b. s = cons a b ∧ a ∈ A ∧ b ∈ B
   
   [<a name="IN_general_prod-val"><b>IN_general_prod</b></a>]  Theorem
      
      ⊢ ∀cons s A B.
          s ∈ general_prod cons A B ⇔
          ∃a b. s = general_cross cons a b ∧ a ∈ A ∧ b ∈ B
   
   [<a name="L1_space_alt_integrable-val"><b>L1_space_alt_integrable</b></a>]  Theorem
      
      ⊢ ∀m f. measure_space m ⇒ (f ∈ L1_space m ⇔ integrable m f)
   
   [<a name="L2_space_alt_integrable_square-val"><b>L2_space_alt_integrable_square</b></a>]  Theorem
      
      ⊢ ∀m f.
          measure_space m ⇒
          (f ∈ L2_space m ⇔
           f ∈ Borel_measurable (measurable_space m) ∧
           integrable m (λx. (f x)²))
   
   [<a name="LIM_SEQUENTIALLY_CESARO-val"><b>LIM_SEQUENTIALLY_CESARO</b></a>]  Theorem
      
      ⊢ ∀f l.
          ((λn. f n) ⟶ l) sequentially ⇒
          ((λn. ∑ f (count1 n) / &SUC n) ⟶ l) sequentially
   
   [<a name="LIM_SEQUENTIALLY_real_normal-val"><b>LIM_SEQUENTIALLY_real_normal</b></a>]  Theorem
      
      ⊢ ∀a l.
          (∀n. a n ≠ +∞ ∧ a n ≠ −∞) ⇒
          ((real ∘ a ⟶ l) sequentially ⇔
           ∀e. 0 &lt; e ⇒ ∃N. ∀n. N ≤ n ⇒ abs (a n − Normal l) &lt; Normal e)
   
   [<a name="MARTINGALE_EQ_SUB_SUPER-val"><b>MARTINGALE_EQ_SUB_SUPER</b></a>]  Theorem
      
      ⊢ ∀m a u.
          martingale m a u ⇔ sub_martingale m a u ∧ super_martingale m a u
   
   [<a name="MEASURABLE_SPACE_PROD-val"><b>MEASURABLE_SPACE_PROD</b></a>]  Theorem
      
      ⊢ ∀M1 M2.
          measure_space M1 ∧ measure_space M2 ⇒
          measurable_space (M1 × M2) =
          measurable_space M1 × measurable_space M2
   
   [<a name="Minkowski_inequality-val"><b>Minkowski_inequality</b></a>]  Theorem
      
      ⊢ ∀p m u v.
          measure_space m ∧ 1 ≤ p ∧ u ∈ lp_space p m ∧ v ∈ lp_space p m ⇒
          (λx. u x + v x) ∈ lp_space p m ∧
          seminorm p m (λx. u x + v x) ≤ seminorm p m u + seminorm p m v
   
   [<a name="Minkowski_inequality'-val"><b>Minkowski_inequality'</b></a>]  Theorem
      
      ⊢ ∀p m u v.
          measure_space m ∧ 1 ≤ p ∧ u ∈ lp_space p m ∧ v ∈ lp_space p m ⇒
          seminorm p m (λx. u x + v x) ≤ seminorm p m u + seminorm p m v
   
   [<a name="PROD_MEASURE_CROSS-val"><b>PROD_MEASURE_CROSS</b></a>]  Theorem
      
      ⊢ ∀M1 M2 s t.
          measure_space M1 ∧ measure_space M2 ∧ s ∈ measurable_sets M1 ∧
          t ∈ measurable_sets M2 ⇒
          prod_measure M1 M2 (s × t) = measure M1 s * measure M2 t
   
   [<a name="PROD_SIGMA_OF_GENERATOR-val"><b>PROD_SIGMA_OF_GENERATOR</b></a>]  Theorem
      
      ⊢ ∀X Y E G.
          subset_class X E ∧ subset_class Y G ∧
          has_exhausting_sequence (X,E) ∧ has_exhausting_sequence (Y,G) ⇒
          (X,E) × (Y,G) = sigma X E × sigma Y G
   
   [<a name="RN_derivI-val"><b>RN_derivI</b></a>]  Theorem
      
      ⊢ ∀f M N.
          measure_space M ∧ measure_space N ∧
          f ∈ Borel_measurable (measurable_space M) ∧
          (∀x. x ∈ m_space M ⇒ 0 ≤ f x) ∧ density_of M f = measure_of N ∧
          measure_space M ∧ measure_space N ∧
          measurable_sets M = measurable_sets N ⇒
          density_of M (RN_deriv' M N) = measure_of N
   
   [<a name="RN_deriv_positive_integral-val"><b>RN_deriv_positive_integral</b></a>]  Theorem
      
      ⊢ ∀M N f.
          sigma_finite_measure_space M ∧ measure_space N ∧
          measure_absolutely_continuous' N M ∧
          measurable_sets M = measurable_sets N ∧
          f ∈ Borel_measurable (measurable_space M) ∧
          (∀x. x ∈ m_space M ⇒ 0 ≤ f x) ⇒
          ∫⁺ N f = ∫⁺ (density_of M (RN_deriv' M N)) f
   
   [<a name="RN_deriv_thm-val"><b>RN_deriv_thm</b></a>]  Theorem
      
      ⊢ ∀m v.
          measure_space m ∧
          (∃f. f ∈ Borel_measurable (measurable_space m) ∧
               (∀x. x ∈ m_space m ⇒ 0 ≤ f x) ∧
               ∀s. s ∈ measurable_sets m ⇒ (f * m) s = v s) ⇒
          ∀s. s ∈ measurable_sets m ⇒ (v / m * m) s = v s
   
   [<a name="RN_deriv_thm'-val"><b>RN_deriv_thm'</b></a>]  Theorem
      
      ⊢ ∀f m v.
          measure_space m ∧ f ∈ Borel_measurable (measurable_space m) ∧
          (∀x. x ∈ m_space m ⇒ 0 ≤ f x) ∧
          (∀s. s ∈ measurable_sets m ⇒ (f * m) s = v s) ⇒
          measure_space_eq (density m (v / m))
            (m_space m,measurable_sets m,v)
   
   [<a name="SIGMA_FINITE_FILTERED_MEASURE_SPACE-val"><b>SIGMA_FINITE_FILTERED_MEASURE_SPACE</b></a>]  Theorem
      
      ⊢ ∀m a.
          sigma_finite_filtered_measure_space m a ⇒
          ∀n. sigma_finite (m_space m,subsets (a n),measure m)
   
   [<a name="SPACE_PROD-val"><b>SPACE_PROD</b></a>]  Theorem
      
      ⊢ ∀M1 M2.
          measure_space M1 ∧ measure_space M2 ⇒
          m_space (M1 × M2) = m_space M1 × m_space M2
   
   [<a name="SUB_SIGMA_ALGEBRA_ANTISYM-val"><b>SUB_SIGMA_ALGEBRA_ANTISYM</b></a>]  Theorem
      
      ⊢ ∀a b. sub_sigma_algebra a b ∧ sub_sigma_algebra b a ⇒ a = b
   
   [<a name="SUB_SIGMA_ALGEBRA_MEASURE_SPACE-val"><b>SUB_SIGMA_ALGEBRA_MEASURE_SPACE</b></a>]  Theorem
      
      ⊢ ∀m a.
          measure_space m ∧ sub_sigma_algebra a (measurable_space m) ⇒
          measure_space (m_space m,subsets a,measure m)
   
   [<a name="SUB_SIGMA_ALGEBRA_ORDER-val"><b>SUB_SIGMA_ALGEBRA_ORDER</b></a>]  Theorem
      
      ⊢ Order sub_sigma_algebra
   
   [<a name="SUB_SIGMA_ALGEBRA_REFL-val"><b>SUB_SIGMA_ALGEBRA_REFL</b></a>]  Theorem
      
      ⊢ ∀a. sigma_algebra a ⇒ sub_sigma_algebra a a
   
   [<a name="SUB_SIGMA_ALGEBRA_TRANS-val"><b>SUB_SIGMA_ALGEBRA_TRANS</b></a>]  Theorem
      
      ⊢ ∀a b c.
          sub_sigma_algebra a b ∧ sub_sigma_algebra b c ⇒
          sub_sigma_algebra a c
   
   [<a name="TONELLI-val"><b>TONELLI</b></a>]  Theorem
      
      ⊢ ∀X Y A B u v f.
          sigma_finite_measure_space (X,A,u) ∧
          sigma_finite_measure_space (Y,B,v) ∧
          f ∈ Borel_measurable ((X,A) × (Y,B)) ∧ (∀s. s ∈ X × Y ⇒ 0 ≤ f s) ⇒
          (∀y. y ∈ Y ⇒ (λx. f (x,y)) ∈ Borel_measurable (X,A)) ∧
          (∀x. x ∈ X ⇒ (λy. f (x,y)) ∈ Borel_measurable (Y,B)) ∧
          (λx. ∫⁺ (Y,B,v) (λy. f (x,y))) ∈ Borel_measurable (X,A) ∧
          (λy. ∫⁺ (X,A,u) (λx. f (x,y))) ∈ Borel_measurable (Y,B) ∧
          ∫⁺ ((X,A,u) × (Y,B,v)) f =
          ∫⁺ (Y,B,v) (λy. ∫⁺ (X,A,u) (λx. f (x,y))) ∧
          ∫⁺ ((X,A,u) × (Y,B,v)) f =
          ∫⁺ (X,A,u) (λx. ∫⁺ (Y,B,v) (λy. f (x,y)))
   
   [<a name="UNIQUENESS_OF_PROD_MEASURE-val"><b>UNIQUENESS_OF_PROD_MEASURE</b></a>]  Theorem
      
      ⊢ ∀X Y E G A B u v m m'.
          subset_class X E ∧ subset_class Y G ∧ sigma_finite (X,E,u) ∧
          sigma_finite (Y,G,v) ∧ (∀s t. s ∈ E ∧ t ∈ E ⇒ s ∩ t ∈ E) ∧
          (∀s t. s ∈ G ∧ t ∈ G ⇒ s ∩ t ∈ G) ∧ A = sigma X E ∧
          B = sigma Y G ∧ measure_space (X,subsets A,u) ∧
          measure_space (Y,subsets B,v) ∧
          measure_space (X × Y,subsets (A × B),m) ∧
          measure_space (X × Y,subsets (A × B),m') ∧
          (∀s t. s ∈ E ∧ t ∈ G ⇒ m (s × t) = u s * v t) ∧
          (∀s t. s ∈ E ∧ t ∈ G ⇒ m' (s × t) = u s * v t) ⇒
          ∀x. x ∈ subsets (A × B) ⇒ m x = m' x
   
   [<a name="UNIQUENESS_OF_PROD_MEASURE'-val"><b>UNIQUENESS_OF_PROD_MEASURE'</b></a>]  Theorem
      
      ⊢ ∀X Y A B u v m m'.
          sigma_finite_measure_space (X,A,u) ∧
          sigma_finite_measure_space (Y,B,v) ∧
          measure_space (X × Y,subsets ((X,A) × (Y,B)),m) ∧
          measure_space (X × Y,subsets ((X,A) × (Y,B)),m') ∧
          (∀s t. s ∈ A ∧ t ∈ B ⇒ m (s × t) = u s * v t) ∧
          (∀s t. s ∈ A ∧ t ∈ B ⇒ m' (s × t) = u s * v t) ⇒
          ∀x. x ∈ subsets ((X,A) × (Y,B)) ⇒ m x = m' x
   
   [<a name="countably_additive_eq-val"><b>countably_additive_eq</b></a>]  Theorem
      
      ⊢ ∀sp M u u'.
          (∀a. a ∈ M ⇒ u' a = u a) ⇒
          (countably_additive (sp,M,u') ⇔ countably_additive (sp,M,u))
   
   [<a name="density_RN_deriv-val"><b>density_RN_deriv</b></a>]  Theorem
      
      ⊢ ∀M N.
          sigma_finite_measure_space M ∧ measure_space N ∧
          measure_absolutely_continuous' N M ∧
          measurable_sets M = measurable_sets N ⇒
          density_of M (RN_deriv' M N) = measure_of N
   
   [<a name="density_eq-val"><b>density_eq</b></a>]  Theorem
      
      ⊢ ∀m f g.
          measure_space m ∧ (∀x. x ∈ m_space m ⇒ 0 ≤ g x) ∧
          (∀x. x ∈ m_space m ⇒ f x = g x) ⇒
          density m f = density m g
   
   [<a name="density_of_pos_fn-val"><b>density_of_pos_fn</b></a>]  Theorem
      
      ⊢ ∀M f.
          measure_space M ∧ (∀x. x ∈ m_space M ⇒ 0 ≤ f x) ⇒
          density_of M f =
          (m_space M,measurable_sets M,
           (λs. if s ∈ measurable_sets M then ∫⁺ M (λx. f x * 𝟙 s x) else 0))
   
   [<a name="exhausting_sequence_CROSS-val"><b>exhausting_sequence_CROSS</b></a>]  Theorem
      
      ⊢ ∀X Y A B f g.
          exhausting_sequence (X,A) f ∧ exhausting_sequence (Y,B) g ⇒
          exhausting_sequence (X × Y,prod_sets A B) (λn. f n × g n)
   
   [<a name="exhausting_sequence_cross-val"><b>exhausting_sequence_cross</b></a>]  Theorem
      
      ⊢ ∀X Y A B f g.
          exhausting_sequence (X,A) f ∧ exhausting_sequence (Y,B) g ⇒
          exhausting_sequence (fcp_cross X Y,fcp_prod A B)
            (λn. fcp_cross (f n) (g n))
   
   [<a name="exhausting_sequence_general_cross-val"><b>exhausting_sequence_general_cross</b></a>]  Theorem
      
      ⊢ ∀cons X Y A B f g.
          exhausting_sequence (X,A) f ∧ exhausting_sequence (Y,B) g ⇒
          exhausting_sequence
            (general_cross cons X Y,general_prod cons A B)
            (λn. general_cross cons (f n) (g n))
   
   [<a name="existence_of_prod_measure-val"><b>existence_of_prod_measure</b></a>]  Theorem
      
      ⊢ ∀X Y A B u v m0.
          FINITE 𝕌(:β) ∧ FINITE 𝕌(:γ) ∧
          sigma_finite_measure_space (X,A,u) ∧
          sigma_finite_measure_space (Y,B,v) ∧
          (∀s t. s ∈ A ∧ t ∈ B ⇒ m0 (fcp_cross s t) = u s * v t) ⇒
          (∀s. s ∈ subsets (fcp_sigma (X,A) (Y,B)) ⇒
               (∀x. x ∈ X ⇒
                    (λy. 𝟙 s (FCP_CONCAT x y)) ∈ Borel_measurable (Y,B)) ∧
               (∀y. y ∈ Y ⇒
                    (λx. 𝟙 s (FCP_CONCAT x y)) ∈ Borel_measurable (X,A)) ∧
               (λy. ∫⁺ (X,A,u) (λx. 𝟙 s (FCP_CONCAT x y))) ∈
               Borel_measurable (Y,B) ∧
               (λx. ∫⁺ (Y,B,v) (λy. 𝟙 s (FCP_CONCAT x y))) ∈
               Borel_measurable (X,A)) ∧
          ∃m. sigma_finite_measure_space
                (fcp_cross X Y,subsets (fcp_sigma (X,A) (Y,B)),m) ∧
              (∀s. s ∈ fcp_prod A B ⇒ m s = m0 s) ∧
              ∀s. s ∈ subsets (fcp_sigma (X,A) (Y,B)) ⇒
                  m s =
                  ∫⁺ (Y,B,v) (λy. ∫⁺ (X,A,u) (λx. 𝟙 s (FCP_CONCAT x y))) ∧
                  m s =
                  ∫⁺ (X,A,u) (λx. ∫⁺ (Y,B,v) (λy. 𝟙 s (FCP_CONCAT x y)))
   
   [<a name="existence_of_prod_measure_general-val"><b>existence_of_prod_measure_general</b></a>]  Theorem
      
      ⊢ ∀cons car cdr X Y A B u v m0.
          pair_operation cons car cdr ∧
          sigma_finite_measure_space (X,A,u) ∧
          sigma_finite_measure_space (Y,B,v) ∧
          (∀s t. s ∈ A ∧ t ∈ B ⇒ m0 (general_cross cons s t) = u s * v t) ⇒
          (∀s. s ∈ subsets (general_sigma cons (X,A) (Y,B)) ⇒
               (∀x. x ∈ X ⇒ (λy. 𝟙 s (cons x y)) ∈ Borel_measurable (Y,B)) ∧
               (∀y. y ∈ Y ⇒ (λx. 𝟙 s (cons x y)) ∈ Borel_measurable (X,A)) ∧
               (λy. ∫⁺ (X,A,u) (λx. 𝟙 s (cons x y))) ∈
               Borel_measurable (Y,B) ∧
               (λx. ∫⁺ (Y,B,v) (λy. 𝟙 s (cons x y))) ∈
               Borel_measurable (X,A)) ∧
          ∃m. sigma_finite_measure_space
                (general_cross cons X Y,
                 subsets (general_sigma cons (X,A) (Y,B)),m) ∧
              (∀s. s ∈ general_prod cons A B ⇒ m s = m0 s) ∧
              ∀s. s ∈ subsets (general_sigma cons (X,A) (Y,B)) ⇒
                  m s = ∫⁺ (Y,B,v) (λy. ∫⁺ (X,A,u) (λx. 𝟙 s (cons x y))) ∧
                  m s = ∫⁺ (X,A,u) (λx. ∫⁺ (Y,B,v) (λy. 𝟙 s (cons x y)))
   
   [<a name="ext_liminf_imp_subseq-val"><b>ext_liminf_imp_subseq</b></a>]  Theorem
      
      ⊢ ∀a. (∀n. a n ≠ +∞ ∧ a n ≠ −∞) ∧ liminf a ≠ +∞ ∧ liminf a ≠ −∞ ⇒
            ∃f. (∀m n. m &lt; n ⇒ f m &lt; f n) ∧
                (real ∘ a ∘ f ⟶ real (liminf a)) sequentially
   
   [<a name="ext_liminf_le_subseq-val"><b>ext_liminf_le_subseq</b></a>]  Theorem
      
      ⊢ ∀a f l.
          (∀n. a n ≠ +∞ ∧ a n ≠ −∞) ∧ (∀m n. m &lt; n ⇒ f m &lt; f n) ∧
          (real ∘ a ∘ f ⟶ l) sequentially ⇒
          liminf a ≤ Normal l
   
   [<a name="ext_limsup_imp_subseq-val"><b>ext_limsup_imp_subseq</b></a>]  Theorem
      
      ⊢ ∀a. (∀n. a n ≠ +∞ ∧ a n ≠ −∞) ∧ limsup a ≠ +∞ ∧ limsup a ≠ −∞ ⇒
            ∃f. (∀m n. m &lt; n ⇒ f m &lt; f n) ∧
                (real ∘ a ∘ f ⟶ real (limsup a)) sequentially
   
   [<a name="ext_limsup_le_subseq-val"><b>ext_limsup_le_subseq</b></a>]  Theorem
      
      ⊢ ∀a f l.
          (∀n. a n ≠ +∞ ∧ a n ≠ −∞) ∧ (∀m n. m &lt; n ⇒ f m &lt; f n) ∧
          (real ∘ a ∘ f ⟶ l) sequentially ⇒
          Normal l ≤ limsup a
   
   [<a name="ext_limsup_thm-val"><b>ext_limsup_thm</b></a>]  Theorem
      
      ⊢ ∀a l.
          (∀n. a n ≠ +∞ ∧ a n ≠ −∞) ⇒
          ((real ∘ a ⟶ l) sequentially ⇔
           limsup a = Normal l ∧ liminf a = Normal l)
   
   [<a name="fatou_lemma-val"><b>fatou_lemma</b></a>]  Theorem
      
      ⊢ ∀m f.
          measure_space m ∧ (∀x n. x ∈ m_space m ⇒ 0 ≤ f n x) ∧
          (∀n. f n ∈ Borel_measurable (measurable_space m)) ⇒
          ∫⁺ m (λx. liminf (λn. f n x)) ≤ liminf (λn. ∫⁺ m (f n))
   
   [<a name="fatou_lemma'-val"><b>fatou_lemma'</b></a>]  Theorem
      
      ⊢ ∀m f w.
          measure_space m ∧ ∫⁺ m w &lt; +∞ ∧
          (∀x n. x ∈ m_space m ⇒ 0 ≤ f n x ∧ f n x ≤ w x ∧ w x &lt; +∞) ∧
          (∀n. f n ∈ Borel_measurable (measurable_space m)) ⇒
          limsup (λn. ∫⁺ m (f n)) ≤ ∫⁺ m (λx. limsup (λn. f n x))
   
   [<a name="fcp_cross_UNIV-val"><b>fcp_cross_UNIV</b></a>]  Theorem
      
      ⊢ FINITE 𝕌(:β) ∧ FINITE 𝕌(:γ) ⇒
        fcp_cross 𝕌(:α[β]) 𝕌(:α[γ]) = 𝕌(:α[β + γ])
   
   [<a name="fcp_cross_alt-val"><b>fcp_cross_alt</b></a>]  Theorem
      
      ⊢ ∀A B. fcp_cross A B = general_cross FCP_CONCAT A B
   
   [<a name="fcp_prod_alt-val"><b>fcp_prod_alt</b></a>]  Theorem
      
      ⊢ ∀A B. fcp_prod A B = general_prod FCP_CONCAT A B
   
   [<a name="fcp_sigma_alt-val"><b>fcp_sigma_alt</b></a>]  Theorem
      
      ⊢ ∀A B. fcp_sigma A B = general_sigma FCP_CONCAT A B
   
   [<a name="filtration_from_measurable_functions-val"><b>filtration_from_measurable_functions</b></a>]  Theorem
      
      ⊢ ∀m X A.
          measure_space m ∧
          (∀n. X n ∈ Borel_measurable (measurable_space m)) ∧
          (∀n. A n = sigma (m_space m) (λn. Borel) X (count1 n)) ⇒
          filtration (measurable_space m) A
   
   [<a name="finite_measure_space_def-val"><b>finite_measure_space_def</b></a>]  Theorem
      
      ⊢ ∀m. finite_measure_space m ⇔
            measure_space m ∧ measure m (m_space m) ≠ +∞
   
   [<a name="general_BIGUNION_CROSS-val"><b>general_BIGUNION_CROSS</b></a>]  Theorem
      
      ⊢ ∀cons f s t.
          general_cross cons (BIGUNION (IMAGE f s)) t =
          BIGUNION (IMAGE (λn. general_cross cons (f n) t) s)
   
   [<a name="general_CROSS_BIGUNION-val"><b>general_CROSS_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀cons f s t.
          general_cross cons t (BIGUNION (IMAGE f s)) =
          BIGUNION (IMAGE (λn. general_cross cons t (f n)) s)
   
   [<a name="general_CROSS_DIFF-val"><b>general_CROSS_DIFF</b></a>]  Theorem
      
      ⊢ ∀cons car cdr X s t.
          pair_operation cons car cdr ⇒
          general_cross cons (X DIFF s) t =
          general_cross cons X t DIFF general_cross cons s t
   
   [<a name="general_CROSS_DIFF'-val"><b>general_CROSS_DIFF'</b></a>]  Theorem
      
      ⊢ ∀cons car cdr s X t.
          pair_operation cons car cdr ⇒
          general_cross cons s (X DIFF t) =
          general_cross cons s X DIFF general_cross cons s t
   
   [<a name="general_INTER_CROSS-val"><b>general_INTER_CROSS</b></a>]  Theorem
      
      ⊢ ∀cons car cdr a b c d.
          pair_operation cons car cdr ⇒
          general_cross cons a b ∩ general_cross cons c d =
          general_cross cons (a ∩ c) (b ∩ d)
   
   [<a name="general_SUBSET_CROSS-val"><b>general_SUBSET_CROSS</b></a>]  Theorem
      
      ⊢ ∀cons a b c d.
          a ⊆ b ∧ c ⊆ d ⇒ general_cross cons a c ⊆ general_cross cons b d
   
   [<a name="general_sigma_of_generator-val"><b>general_sigma_of_generator</b></a>]  Theorem
      
      ⊢ ∀cons car cdr X Y E G.
          pair_operation cons car cdr ∧ subset_class X E ∧
          subset_class Y G ∧ has_exhausting_sequence (X,E) ∧
          has_exhausting_sequence (Y,G) ⇒
          general_sigma cons (X,E) (Y,G) =
          general_sigma cons (sigma X E) (sigma Y G)
   
   [<a name="indicator_fn_general_cross-val"><b>indicator_fn_general_cross</b></a>]  Theorem
      
      ⊢ ∀cons car cdr s t x y.
          pair_operation cons car cdr ⇒
          𝟙 (general_cross cons s t) (cons x y) = 𝟙 s x * 𝟙 t y
   
   [<a name="integrable_AE_finite-val"><b>integrable_AE_finite</b></a>]  Theorem
      
      ⊢ ∀m f.
          measure_space m ∧ integrable m f ⇒
          AE x::m. f x = (Normal ∘ real ∘ f) x
   
   [<a name="integrable_add'-val"><b>integrable_add'</b></a>]  Theorem
      
      ⊢ ∀m f g.
          measure_space m ∧ integrable m f ∧ integrable m g ⇒
          integrable m (λx. f x + g x)
   
   [<a name="integrable_cong_AE-val"><b>integrable_cong_AE</b></a>]  Theorem
      
      ⊢ ∀m f g.
          complete_measure_space m ∧ (AE x::m. f x = g x) ⇒
          (integrable m f ⇔ integrable m g)
   
   [<a name="integrable_cong_AE_alt-val"><b>integrable_cong_AE_alt</b></a>]  Theorem
      
      ⊢ ∀m f g.
          measure_space m ∧ (AE x::m. f x = g x) ∧
          f ∈ Borel_measurable (measurable_space m) ∧
          g ∈ Borel_measurable (measurable_space m) ⇒
          (integrable m f ⇔ integrable m g)
   
   [<a name="integrable_cong_measure-val"><b>integrable_cong_measure</b></a>]  Theorem
      
      ⊢ ∀sp sts u v f.
          measure_space (sp,sts,u) ∧ measure_space (sp,sts,v) ∧
          (∀s. s ∈ sts ⇒ u s = v s) ⇒
          (integrable (sp,sts,u) f ⇔ integrable (sp,sts,v) f)
   
   [<a name="integrable_cong_measure'-val"><b>integrable_cong_measure'</b></a>]  Theorem
      
      ⊢ ∀m1 m2 f.
          measure_space m1 ∧ measure_space m2 ∧ measure_space_eq m1 m2 ⇒
          (integrable m1 f ⇔ integrable m2 f)
   
   [<a name="integrable_eq_AE_alt-val"><b>integrable_eq_AE_alt</b></a>]  Theorem
      
      ⊢ ∀m f g.
          measure_space m ∧ integrable m f ∧ (AE x::m. f x = g x) ∧
          g ∈ Borel_measurable (measurable_space m) ⇒
          integrable m g
   
   [<a name="integrable_measurable-val"><b>integrable_measurable</b></a>]  Theorem
      
      ⊢ ∀m f. integrable m f ⇒ f ∈ Borel_measurable (measurable_space m)
   
   [<a name="integrable_sub'-val"><b>integrable_sub'</b></a>]  Theorem
      
      ⊢ ∀m f g.
          measure_space m ∧ integrable m f ∧ integrable m g ⇒
          integrable m (λx. f x − g x)
   
   [<a name="integrable_sum'-val"><b>integrable_sum'</b></a>]  Theorem
      
      ⊢ ∀m f s.
          FINITE s ∧ measure_space m ∧ (∀i. i ∈ s ⇒ integrable m (f i)) ⇒
          integrable m (λx. ∑ (λi. f i x) s)
   
   [<a name="integral_add'-val"><b>integral_add'</b></a>]  Theorem
      
      ⊢ ∀m f g.
          measure_space m ∧ integrable m f ∧ integrable m g ⇒
          ∫ m (λx. f x + g x) = ∫ m f + ∫ m g
   
   [<a name="integral_add3-val"><b>integral_add3</b></a>]  Theorem
      
      ⊢ ∀m f g h.
          measure_space m ∧ integrable m f ∧ integrable m g ∧
          integrable m h ⇒
          ∫ m (λx. f x + g x + h x) = ∫ m f + ∫ m g + ∫ m h
   
   [<a name="integral_cong_measure-val"><b>integral_cong_measure</b></a>]  Theorem
      
      ⊢ ∀sp sts u v f.
          measure_space (sp,sts,u) ∧ measure_space (sp,sts,v) ∧
          (∀s. s ∈ sts ⇒ u s = v s) ⇒
          ∫ (sp,sts,u) f = ∫ (sp,sts,v) f
   
   [<a name="integral_cong_measure'-val"><b>integral_cong_measure'</b></a>]  Theorem
      
      ⊢ ∀m1 m2 f.
          measure_space m1 ∧ measure_space m2 ∧ measure_space_eq m1 m2 ⇒
          ∫ m1 f = ∫ m2 f
   
   [<a name="integral_distr-val"><b>integral_distr</b></a>]  Theorem
      
      ⊢ ∀M B f u.
          measure_space M ∧ sigma_algebra B ∧
          f ∈ measurable (measurable_space M) B ∧ u ∈ Borel_measurable B ⇒
          ∫ (space B,subsets B,distr M f) u = ∫ M (u ∘ f) ∧
          (integrable (space B,subsets B,distr M f) u ⇔
           integrable M (u ∘ f))
   
   [<a name="integral_mono_AE-val"><b>integral_mono_AE</b></a>]  Theorem
      
      ⊢ ∀m f g. measure_space m ∧ (AE x::m. f x ≤ g x) ⇒ ∫ m f ≤ ∫ m g
   
   [<a name="integral_sub'-val"><b>integral_sub'</b></a>]  Theorem
      
      ⊢ ∀m f g.
          measure_space m ∧ integrable m f ∧ integrable m g ⇒
          ∫ m (λx. f x − g x) = ∫ m f − ∫ m g
   
   [<a name="integral_sum'-val"><b>integral_sum'</b></a>]  Theorem
      
      ⊢ ∀m f s.
          FINITE s ∧ measure_space m ∧ (∀i. i ∈ s ⇒ integrable m (f i)) ⇒
          ∫ m (λx. ∑ (λi. f i x) s) = ∑ (λi. ∫ m (f i)) s
   
   [<a name="lborel_2d_prod_measure-val"><b>lborel_2d_prod_measure</b></a>]  Theorem
      
      ⊢ ∀s. s ∈ measurable_sets lborel_2d ⇒
            measure lborel_2d s = measure (lborel × lborel) s
   
   [<a name="lebesgue_dominated_convergence-val"><b>lebesgue_dominated_convergence</b></a>]  Theorem
      
      ⊢ ∀m f fi.
          measure_space m ∧ (∀i. integrable m (fi i)) ∧ integrable m f ∧
          (∀i x. x ∈ m_space m ⇒ fi i x ≠ +∞ ∧ fi i x ≠ −∞) ∧
          (∀x. x ∈ m_space m ⇒ f x ≠ +∞ ∧ f x ≠ −∞) ∧
          (∀x. x ∈ m_space m ⇒
               ((λi. real (fi i x)) ⟶ real (f x)) sequentially) ∧
          (∃w. integrable m w ∧ (∀x. x ∈ m_space m ⇒ 0 ≤ w x ∧ w x ≠ +∞) ∧
               ∀i x. x ∈ m_space m ⇒ abs (fi i x) ≤ w x) ⇒
          ((λi. real (∫ m (fi i))) ⟶ real (∫ m f)) sequentially
   
   [<a name="lp_space_AE_normal-val"><b>lp_space_AE_normal</b></a>]  Theorem
      
      ⊢ ∀p m f.
          measure_space m ∧ 0 &lt; p ∧ f ∈ lp_space p m ⇒
          AE x::m. f x ≠ +∞ ∧ f x ≠ −∞
   
   [<a name="lp_space_add-val"><b>lp_space_add</b></a>]  Theorem
      
      ⊢ ∀p m u v.
          measure_space m ∧ 0 &lt; p ∧ u ∈ lp_space p m ∧ v ∈ lp_space p m ⇒
          (λx. u x + v x) ∈ lp_space p m
   
   [<a name="lp_space_add_cmul-val"><b>lp_space_add_cmul</b></a>]  Theorem
      
      ⊢ ∀p m u v a b.
          measure_space m ∧ 0 &lt; p ∧ u ∈ lp_space p m ∧ v ∈ lp_space p m ⇒
          (λx. Normal a * u x + Normal b * v x) ∈ lp_space p m
   
   [<a name="lp_space_alt_finite-val"><b>lp_space_alt_finite</b></a>]  Theorem
      
      ⊢ ∀p m f.
          0 &lt; p ∧ p ≠ +∞ ⇒
          (f ∈ lp_space p m ⇔
           f ∈ Borel_measurable (measurable_space m) ∧
           ∫⁺ m (λx. abs (f x) powr p) ≠ +∞)
   
   [<a name="lp_space_alt_finite'-val"><b>lp_space_alt_finite'</b></a>]  Theorem
      
      ⊢ ∀p m f.
          measure_space m ∧ 0 &lt; p ∧ p ≠ +∞ ⇒
          (f ∈ lp_space p m ⇔
           f ∈ Borel_measurable (measurable_space m) ∧
           ∫ m (λx. abs (f x) powr p) ≠ +∞)
   
   [<a name="lp_space_alt_infinite-val"><b>lp_space_alt_infinite</b></a>]  Theorem
      
      ⊢ ∀m f.
          measure_space m ⇒
          (f ∈ L_PosInf m ⇔
           f ∈ Borel_measurable (measurable_space m) ∧
           ∃c. 0 &lt; c ∧ c ≠ +∞ ∧ AE x::m. abs (f x) &lt; c)
   
   [<a name="lp_space_alt_seminorm-val"><b>lp_space_alt_seminorm</b></a>]  Theorem
      
      ⊢ ∀p m f.
          measure_space m ∧ 0 &lt; p ⇒
          (f ∈ lp_space p m ⇔
           f ∈ Borel_measurable (measurable_space m) ∧ seminorm p m f &lt; +∞)
   
   [<a name="lp_space_cmul-val"><b>lp_space_cmul</b></a>]  Theorem
      
      ⊢ ∀p m u r.
          measure_space m ∧ 0 &lt; p ∧ u ∈ lp_space p m ⇒
          (λx. Normal r * u x) ∈ lp_space p m
   
   [<a name="lp_space_cong-val"><b>lp_space_cong</b></a>]  Theorem
      
      ⊢ ∀p m u v.
          measure_space m ∧ 0 &lt; p ∧ (∀x. x ∈ m_space m ⇒ u x = v x) ⇒
          (u ∈ lp_space p m ⇔ v ∈ lp_space p m)
   
   [<a name="lp_space_cong_AE-val"><b>lp_space_cong_AE</b></a>]  Theorem
      
      ⊢ ∀p m u v.
          measure_space m ∧ 0 &lt; p ∧
          u ∈ Borel_measurable (measurable_space m) ∧
          v ∈ Borel_measurable (measurable_space m) ∧ (AE x::m. u x = v x) ⇒
          (u ∈ lp_space p m ⇔ v ∈ lp_space p m)
   
   [<a name="lp_space_sub-val"><b>lp_space_sub</b></a>]  Theorem
      
      ⊢ ∀p m u v.
          measure_space m ∧ 0 &lt; p ∧ u ∈ lp_space p m ∧ v ∈ lp_space p m ⇒
          (λx. u x − v x) ∈ lp_space p m
   
   [<a name="martingale_alt-val"><b>martingale_alt</b></a>]  Theorem
      
      ⊢ ∀m a u.
          martingale m a u ⇔
          sigma_finite_filtered_measure_space m a ∧
          (∀n. integrable m (u n)) ∧
          ∀i j s.
            i ≤ j ∧ s ∈ subsets (a i) ⇒
            ∫ m (λx. u i x * 𝟙 s x) = ∫ m (λx. u j x * 𝟙 s x)
   
   [<a name="martingale_alt_generator-val"><b>martingale_alt_generator</b></a>]  Theorem
      
      ⊢ ∀m a u g.
          (∀n. a n = sigma (m_space m) (g n)) ∧
          (∀n. has_exhausting_sequence (m_space m,g n)) ∧
          (∀n s. s ∈ g n ⇒ measure m s &lt; +∞) ∧
          (∀n s t. s ∈ g n ∧ t ∈ g n ⇒ s ∩ t ∈ g n) ⇒
          (martingale m a u ⇔
           filtered_measure_space m a ∧ (∀n. integrable m (u n)) ∧
           ∀i j s.
             i ≤ j ∧ s ∈ g i ⇒
             ∫ m (λx. u i x * 𝟙 s x) = ∫ m (λx. u j x * 𝟙 s x))
   
   [<a name="measure_of_eq-val"><b>measure_of_eq</b></a>]  Theorem
      
      ⊢ ∀sp A u u'.
          A ⊆ POW sp ∧ (∀a. a ∈ sigma_sets sp A ⇒ u a = u' a) ⇒
          measure_of (sp,A,u) = measure_of (sp,A,u')
   
   [<a name="measure_of_eq'-val"><b>measure_of_eq'</b></a>]  Theorem
      
      ⊢ ∀M N.
          measure_space M ∧ measure_space N ∧
          measurable_sets M = measurable_sets N ∧
          (∀A. A ∈ measurable_sets M ⇒ measure M A = measure N A) ⇒
          measure_of M = measure_of N
   
   [<a name="measure_of_reduce-val"><b>measure_of_reduce</b></a>]  Theorem
      
      ⊢ ∀M. measure_of M =
            measure_of (m_space M,measurable_sets M,measure M)
   
   [<a name="measure_space_prod_measure-val"><b>measure_space_prod_measure</b></a>]  Theorem
      
      ⊢ ∀m1 m2.
          sigma_finite_measure_space m1 ∧ sigma_finite_measure_space m2 ⇒
          measure_space (m1 × m2)
   
   [<a name="measure_space_sigma_sets_eq-val"><b>measure_space_sigma_sets_eq</b></a>]  Theorem
      
      ⊢ ∀sp A u u'.
          A ⊆ POW sp ∧ (∀a. a ∈ sigma_sets sp A ⇒ u a = u' a) ⇒
          (measure_space (sp,sigma_sets sp A,u) ⇔
           measure_space (sp,sigma_sets sp A,u'))
   
   [<a name="pair_operation_CONS-val"><b>pair_operation_CONS</b></a>]  Theorem
      
      ⊢ pair_operation CONS HD TL
   
   [<a name="pair_operation_FCP_CONCAT-val"><b>pair_operation_FCP_CONCAT</b></a>]  Theorem
      
      ⊢ FINITE 𝕌(:β) ∧ FINITE 𝕌(:γ) ⇒
        pair_operation FCP_CONCAT FCP_FST FCP_SND
   
   [<a name="pair_operation_pair-val"><b>pair_operation_pair</b></a>]  Theorem
      
      ⊢ pair_operation $, FST SND
   
   [<a name="pos_fn_integrable_AE_finite-val"><b>pos_fn_integrable_AE_finite</b></a>]  Theorem
      
      ⊢ ∀m f.
          measure_space m ∧ (∀x. x ∈ m_space m ⇒ 0 ≤ f x) ∧
          f ∈ Borel_measurable (measurable_space m) ∧ ∫⁺ m f ≠ +∞ ⇒
          AE x::m. f x = (Normal ∘ real ∘ f) x
   
   [<a name="pos_fn_integral_add3-val"><b>pos_fn_integral_add3</b></a>]  Theorem
      
      ⊢ ∀m f g h.
          measure_space m ∧ (∀x. x ∈ m_space m ⇒ 0 ≤ f x) ∧
          (∀x. x ∈ m_space m ⇒ 0 ≤ g x) ∧ (∀x. x ∈ m_space m ⇒ 0 ≤ h x) ∧
          f ∈ Borel_measurable (measurable_space m) ∧
          g ∈ Borel_measurable (measurable_space m) ∧
          h ∈ Borel_measurable (measurable_space m) ⇒
          ∫⁺ m (λx. f x + g x + h x) = ∫⁺ m f + ∫⁺ m g + ∫⁺ m h
   
   [<a name="pos_fn_integral_cong_measure-val"><b>pos_fn_integral_cong_measure</b></a>]  Theorem
      
      ⊢ ∀sp sts u v f.
          measure_space (sp,sts,u) ∧ measure_space (sp,sts,v) ∧
          (∀s. s ∈ sts ⇒ u s = v s) ∧ (∀x. x ∈ sp ⇒ 0 ≤ f x) ⇒
          ∫⁺ (sp,sts,u) f = ∫⁺ (sp,sts,v) f
   
   [<a name="pos_fn_integral_cong_measure'-val"><b>pos_fn_integral_cong_measure'</b></a>]  Theorem
      
      ⊢ ∀m1 m2 f.
          measure_space m1 ∧ measure_space m2 ∧ measure_space_eq m1 m2 ∧
          (∀x. x ∈ m_space m1 ⇒ 0 ≤ f x) ⇒
          ∫⁺ m1 f = ∫⁺ m2 f
   
   [<a name="pos_fn_integral_density-val"><b>pos_fn_integral_density</b></a>]  Theorem
      
      ⊢ ∀m f g.
          measure_space m ∧ f ∈ Borel_measurable (measurable_space m) ∧
          g ∈ Borel_measurable (measurable_space m) ∧ (AE x::m. 0 ≤ f x) ∧
          (∀x. 0 ≤ g x) ⇒
          ∫⁺ (density m f⁺) g = ∫⁺ m (λx. f⁺ x * g x)
   
   [<a name="pos_fn_integral_density_of-val"><b>pos_fn_integral_density_of</b></a>]  Theorem
      
      ⊢ ∀m f g.
          measure_space m ∧ (∀x. x ∈ m_space m ⇒ 0 ≤ f x) ∧
          (∀x. x ∈ m_space m ⇒ 0 ≤ g x) ∧
          f ∈ Borel_measurable (measurable_space m) ⇒
          ∫⁺ (density_of m f) g = ∫⁺ (density m f) g
   
   [<a name="pos_fn_integral_density_of_reduce-val"><b>pos_fn_integral_density_of_reduce</b></a>]  Theorem
      
      ⊢ ∀m f g.
          measure_space m ∧ f ∈ Borel_measurable (measurable_space m) ∧
          g ∈ Borel_measurable (measurable_space m) ∧
          (∀x. x ∈ m_space m ⇒ 0 ≤ f x) ∧ (∀x. x ∈ m_space m ⇒ 0 ≤ g x) ⇒
          ∫⁺ (density_of m f) g = ∫⁺ m (λx. f x * g x)
   
   [<a name="pos_fn_integral_density_reduce-val"><b>pos_fn_integral_density_reduce</b></a>]  Theorem
      
      ⊢ ∀m f g.
          measure_space m ∧ f ∈ Borel_measurable (measurable_space m) ∧
          g ∈ Borel_measurable (measurable_space m) ∧
          (∀x. x ∈ m_space m ⇒ 0 ≤ f x) ∧ (∀x. x ∈ m_space m ⇒ 0 ≤ g x) ⇒
          ∫⁺ (density m f) g = ∫⁺ m (λx. f x * g x)
   
   [<a name="pos_fn_integral_distr-val"><b>pos_fn_integral_distr</b></a>]  Theorem
      
      ⊢ ∀M B f u.
          measure_space M ∧ sigma_algebra B ∧
          f ∈ measurable (measurable_space M) B ∧ u ∈ Borel_measurable B ∧
          (∀x. x ∈ space B ⇒ 0 ≤ u x) ⇒
          ∫⁺ (space B,subsets B,distr M f) u = ∫⁺ M (u ∘ f)
   
   [<a name="pos_fn_integral_distr_of-val"><b>pos_fn_integral_distr_of</b></a>]  Theorem
      
      ⊢ ∀M N f u.
          measure_space M ∧ measure_space N ∧
          f ∈ measurable (measurable_space M) (measurable_space N) ∧
          u ∈ Borel_measurable (measurable_space N) ∧
          (∀x. x ∈ m_space N ⇒ 0 ≤ u x) ⇒
          ∫⁺ (distr_of M N f) u = ∫⁺ M (u ∘ f)
   
   [<a name="pos_fn_integral_exchange-val"><b>pos_fn_integral_exchange</b></a>]  Theorem
      
      ⊢ ∀m1 m2 f.
          sigma_finite_measure_space m1 ∧ sigma_finite_measure_space m2 ∧
          f ∈ Borel_measurable (measurable_space m1 × measurable_space m2) ∧
          (∀z. z ∈ m_space m1 × m_space m2 ⇒ 0 ≤ f z) ⇒
          ∫⁺ m1 (λx. ∫⁺ m2 (λy. f (x,y))) = ∫⁺ m2 (λy. ∫⁺ m1 (λx. f (x,y)))
   
   [<a name="positive_cong_eq-val"><b>positive_cong_eq</b></a>]  Theorem
      
      ⊢ ∀sp M u u'.
          ring (sp,M) ∧ (∀a. a ∈ M ⇒ u' a = u a) ⇒
          (positive (sp,M,u) ⇔ positive (sp,M,u'))
   
   [<a name="prod_measure_space_alt-val"><b>prod_measure_space_alt</b></a>]  Theorem
      
      ⊢ ∀m1 m2.
          m1 × m2 =
          (m_space m1 × m_space m2,
           subsets (measurable_space m1 × measurable_space m2),
           (λs. ∫⁺ m2 (λy. ∫⁺ m1 (λx. 𝟙 s (x,y)))))
   
   [<a name="prod_sets_alt-val"><b>prod_sets_alt</b></a>]  Theorem
      
      ⊢ ∀A B. prod_sets A B = general_prod $, A B
   
   [<a name="prod_sigma_alt-val"><b>prod_sigma_alt</b></a>]  Theorem
      
      ⊢ ∀A B. A × B = general_sigma $, A B
   
   [<a name="prod_sigma_of_generator-val"><b>prod_sigma_of_generator</b></a>]  Theorem
      
      ⊢ ∀X Y E G.
          FINITE 𝕌(:β) ∧ FINITE 𝕌(:γ) ∧ subset_class X E ∧
          subset_class Y G ∧ has_exhausting_sequence (X,E) ∧
          has_exhausting_sequence (Y,G) ⇒
          fcp_sigma (X,E) (Y,G) = fcp_sigma (sigma X E) (sigma Y G)
   
   [<a name="seminorm_cmul-val"><b>seminorm_cmul</b></a>]  Theorem
      
      ⊢ ∀p m u r.
          measure_space m ∧ 0 &lt; p ∧
          u ∈ Borel_measurable (measurable_space m) ⇒
          seminorm p m (λx. Normal r * u x) =
          Normal (abs r) * seminorm p m u
   
   [<a name="seminorm_cong-val"><b>seminorm_cong</b></a>]  Theorem
      
      ⊢ ∀m u v p.
          measure_space m ∧ 0 &lt; p ∧
          (u ∈ Borel_measurable (measurable_space m) ∨
           v ∈ Borel_measurable (measurable_space m)) ∧
          (∀x. x ∈ m_space m ⇒ u x = v x) ⇒
          seminorm p m u = seminorm p m v
   
   [<a name="seminorm_cong_AE-val"><b>seminorm_cong_AE</b></a>]  Theorem
      
      ⊢ ∀m u v p.
          measure_space m ∧ 0 &lt; p ∧
          u ∈ Borel_measurable (measurable_space m) ∧
          v ∈ Borel_measurable (measurable_space m) ∧ (AE x::m. u x = v x) ⇒
          seminorm p m u = seminorm p m v
   
   [<a name="seminorm_eq_0-val"><b>seminorm_eq_0</b></a>]  Theorem
      
      ⊢ ∀p m f.
          measure_space m ∧ 0 &lt; p ∧
          f ∈ Borel_measurable (measurable_space m) ⇒
          (seminorm p m f = 0 ⇔ AE x::m. f x = 0)
   
   [<a name="seminorm_infty-val"><b>seminorm_infty</b></a>]  Theorem
      
      ⊢ ∀m f.
          seminorm +∞ m f =
          inf
            {c | 0 &lt; c ∧ measure m {x | x ∈ m_space m ∧ c ≤ abs (f x)} = 0}
   
   [<a name="seminorm_infty_AE_bound-val"><b>seminorm_infty_AE_bound</b></a>]  Theorem
      
      ⊢ ∀m f.
          measure_space m ∧ f ∈ Borel_measurable (measurable_space m) ⇒
          AE x::m. abs (f x) ≤ seminorm +∞ m f
   
   [<a name="seminorm_infty_alt-val"><b>seminorm_infty_alt</b></a>]  Theorem
      
      ⊢ ∀m f.
          measure_space m ∧ f ∈ Borel_measurable (measurable_space m) ⇒
          seminorm +∞ m f = inf {c | 0 &lt; c ∧ AE x::m. abs (f x) &lt; c}
   
   [<a name="seminorm_normal-val"><b>seminorm_normal</b></a>]  Theorem
      
      ⊢ ∀p m f.
          0 &lt; p ∧ p ≠ +∞ ⇒
          seminorm p m f = ∫⁺ m (λx. abs (f x) powr p) powr p⁻¹
   
   [<a name="seminorm_not_infty-val"><b>seminorm_not_infty</b></a>]  Theorem
      
      ⊢ ∀p m f.
          measure_space m ∧ 0 &lt; p ∧ f ∈ lp_space p m ⇒
          seminorm p m f ≠ +∞ ∧ seminorm p m f ≠ −∞
   
   [<a name="seminorm_one-val"><b>seminorm_one</b></a>]  Theorem
      
      ⊢ ∀m f. measure_space m ⇒ seminorm 1 m f = ∫⁺ m (abs ∘ f)
   
   [<a name="seminorm_pos-val"><b>seminorm_pos</b></a>]  Theorem
      
      ⊢ ∀p m f. 0 &lt; p ⇒ 0 ≤ seminorm p m f
   
   [<a name="seminorm_powr-val"><b>seminorm_powr</b></a>]  Theorem
      
      ⊢ ∀p m f.
          measure_space m ∧ 0 &lt; p ∧ p ≠ +∞ ⇒
          seminorm p m f powr p = ∫⁺ m (λx. abs (f x) powr p)
   
   [<a name="seminorm_two-val"><b>seminorm_two</b></a>]  Theorem
      
      ⊢ ∀m f. measure_space m ⇒ seminorm 2 m f = sqrt (∫⁺ m (λx. (f x)²))
   
   [<a name="seminorm_zero-val"><b>seminorm_zero</b></a>]  Theorem
      
      ⊢ ∀p m. measure_space m ∧ 0 &lt; p ⇒ seminorm p m (λx. 0) = 0
   
   [<a name="sigma_algebra_general_sigma-val"><b>sigma_algebra_general_sigma</b></a>]  Theorem
      
      ⊢ ∀cons A B.
          subset_class (space A) (subsets A) ∧
          subset_class (space B) (subsets B) ⇒
          sigma_algebra (general_sigma cons A B)
   
   [<a name="sigma_algebra_prod_sigma-val"><b>sigma_algebra_prod_sigma</b></a>]  Theorem
      
      ⊢ ∀a b.
          subset_class (space a) (subsets a) ∧
          subset_class (space b) (subsets b) ⇒
          sigma_algebra (fcp_sigma a b)
   
   [<a name="sigma_algebra_prod_sigma'-val"><b>sigma_algebra_prod_sigma'</b></a>]  Theorem
      
      ⊢ ∀X Y A B.
          subset_class X A ∧ subset_class Y B ⇒
          sigma_algebra (fcp_sigma (X,A) (Y,B))
   
   [<a name="sigma_finite_filtered_measure_space_alt-val"><b>sigma_finite_filtered_measure_space_alt</b></a>]  Theorem
      
      ⊢ ∀m a.
          sigma_finite_filtered_measure_space m a ⇔
          (measure_space m ∧ filtration (measurable_space m) a) ∧
          sigma_finite (m_space m,subsets (a 0),measure m)
   
   [<a name="sigma_finite_filtered_measure_space_alt_all-val"><b>sigma_finite_filtered_measure_space_alt_all</b></a>]  Theorem
      
      ⊢ ∀m a.
          sigma_finite_filtered_measure_space m a ⇔
          measure_space m ∧ filtration (measurable_space m) a ∧
          ∀n. sigma_finite (m_space m,subsets (a n),measure m)
   
   [<a name="sub_martingale_alt-val"><b>sub_martingale_alt</b></a>]  Theorem
      
      ⊢ ∀m a u.
          sub_martingale m a u ⇔
          sigma_finite_filtered_measure_space m a ∧
          (∀n. integrable m (u n)) ∧
          ∀i j s.
            i ≤ j ∧ s ∈ subsets (a i) ⇒
            ∫ m (λx. u i x * 𝟙 s x) ≤ ∫ m (λx. u j x * 𝟙 s x)
   
   [<a name="sub_martingale_alt_generator-val"><b>sub_martingale_alt_generator</b></a>]  Theorem
      
      ⊢ ∀m a u g.
          (∀n. a n = sigma (m_space m) (g n)) ∧
          (∀n. has_exhausting_sequence (m_space m,g n)) ∧
          (∀n s. s ∈ g n ⇒ measure m s &lt; +∞) ∧
          (∀n. semiring (m_space m,g n)) ⇒
          (sub_martingale m a u ⇔
           filtered_measure_space m a ∧ (∀n. integrable m (u n)) ∧
           ∀i j s.
             i ≤ j ∧ s ∈ g i ⇒
             ∫ m (λx. u i x * 𝟙 s x) ≤ ∫ m (λx. u j x * 𝟙 s x))
   
   [<a name="super_martingale_alt-val"><b>super_martingale_alt</b></a>]  Theorem
      
      ⊢ ∀m a u.
          super_martingale m a u ⇔
          sigma_finite_filtered_measure_space m a ∧
          (∀n. integrable m (u n)) ∧
          ∀i j s.
            i ≤ j ∧ s ∈ subsets (a i) ⇒
            ∫ m (λx. u j x * 𝟙 s x) ≤ ∫ m (λx. u i x * 𝟙 s x)
   
   [<a name="super_martingale_alt_generator-val"><b>super_martingale_alt_generator</b></a>]  Theorem
      
      ⊢ ∀m a u g.
          (∀n. a n = sigma (m_space m) (g n)) ∧
          (∀n. has_exhausting_sequence (m_space m,g n)) ∧
          (∀n s. s ∈ g n ⇒ measure m s &lt; +∞) ∧
          (∀n. semiring (m_space m,g n)) ⇒
          (super_martingale m a u ⇔
           filtered_measure_space m a ∧ (∀n. integrable m (u n)) ∧
           ∀i j s.
             i ≤ j ∧ s ∈ g i ⇒
             ∫ m (λx. u j x * 𝟙 s x) ≤ ∫ m (λx. u i x * 𝟙 s x))
   
   [<a name="uniqueness_of_prod_measure-val"><b>uniqueness_of_prod_measure</b></a>]  Theorem
      
      ⊢ ∀X Y E G A B u v m m'.
          FINITE 𝕌(:β) ∧ FINITE 𝕌(:γ) ∧ subset_class X E ∧
          subset_class Y G ∧ sigma_finite (X,E,u) ∧ sigma_finite (Y,G,v) ∧
          (∀s t. s ∈ E ∧ t ∈ E ⇒ s ∩ t ∈ E) ∧
          (∀s t. s ∈ G ∧ t ∈ G ⇒ s ∩ t ∈ G) ∧ A = sigma X E ∧
          B = sigma Y G ∧ measure_space (X,subsets A,u) ∧
          measure_space (Y,subsets B,v) ∧
          measure_space (fcp_cross X Y,subsets (fcp_sigma A B),m) ∧
          measure_space (fcp_cross X Y,subsets (fcp_sigma A B),m') ∧
          (∀s t. s ∈ E ∧ t ∈ G ⇒ m (fcp_cross s t) = u s * v t) ∧
          (∀s t. s ∈ E ∧ t ∈ G ⇒ m' (fcp_cross s t) = u s * v t) ⇒
          ∀x. x ∈ subsets (fcp_sigma A B) ⇒ m x = m' x
   
   [<a name="uniqueness_of_prod_measure'-val"><b>uniqueness_of_prod_measure'</b></a>]  Theorem
      
      ⊢ ∀X Y A B u v m m'.
          FINITE 𝕌(:β) ∧ FINITE 𝕌(:γ) ∧
          sigma_finite_measure_space (X,A,u) ∧
          sigma_finite_measure_space (Y,B,v) ∧
          measure_space (fcp_cross X Y,subsets (fcp_sigma (X,A) (Y,B)),m) ∧
          measure_space (fcp_cross X Y,subsets (fcp_sigma (X,A) (Y,B)),m') ∧
          (∀s t. s ∈ A ∧ t ∈ B ⇒ m (fcp_cross s t) = u s * v t) ∧
          (∀s t. s ∈ A ∧ t ∈ B ⇒ m' (fcp_cross s t) = u s * v t) ⇒
          ∀x. x ∈ subsets (fcp_sigma (X,A) (Y,B)) ⇒ m x = m' x
   
   [<a name="uniqueness_of_prod_measure_general-val"><b>uniqueness_of_prod_measure_general</b></a>]  Theorem
      
      ⊢ ∀cons car cdr X Y E G A B u v m m'.
          pair_operation cons car cdr ∧ subset_class X E ∧
          subset_class Y G ∧ sigma_finite (X,E,u) ∧ sigma_finite (Y,G,v) ∧
          (∀s t. s ∈ E ∧ t ∈ E ⇒ s ∩ t ∈ E) ∧
          (∀s t. s ∈ G ∧ t ∈ G ⇒ s ∩ t ∈ G) ∧ A = sigma X E ∧
          B = sigma Y G ∧ measure_space (X,subsets A,u) ∧
          measure_space (Y,subsets B,v) ∧
          measure_space
            (general_cross cons X Y,subsets (general_sigma cons A B),m) ∧
          measure_space
            (general_cross cons X Y,subsets (general_sigma cons A B),m') ∧
          (∀s t. s ∈ E ∧ t ∈ G ⇒ m (general_cross cons s t) = u s * v t) ∧
          (∀s t. s ∈ E ∧ t ∈ G ⇒ m' (general_cross cons s t) = u s * v t) ⇒
          ∀x. x ∈ subsets (general_sigma cons A B) ⇒ m x = m' x
   
   [<a name="uniqueness_of_prod_measure_general'-val"><b>uniqueness_of_prod_measure_general'</b></a>]  Theorem
      
      ⊢ ∀cons car cdr X Y A B u v m m'.
          pair_operation cons car cdr ∧
          sigma_finite_measure_space (X,A,u) ∧
          sigma_finite_measure_space (Y,B,v) ∧
          measure_space
            (general_cross cons X Y,
             subsets (general_sigma cons (X,A) (Y,B)),m) ∧
          measure_space
            (general_cross cons X Y,
             subsets (general_sigma cons (X,A) (Y,B)),m') ∧
          (∀s t. s ∈ A ∧ t ∈ B ⇒ m (general_cross cons s t) = u s * v t) ∧
          (∀s t. s ∈ A ∧ t ∈ B ⇒ m' (general_cross cons s t) = u s * v t) ⇒
          ∀x. x ∈ subsets (general_sigma cons (X,A) (Y,B)) ⇒ m x = m' x
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/probability/.hol/objs/martingaleScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-2</a></em></p></body></html>
