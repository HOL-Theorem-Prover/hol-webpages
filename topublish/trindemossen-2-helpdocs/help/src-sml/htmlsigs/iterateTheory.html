<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure iterateTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure iterateTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/pred_set/src/iterateScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature iterateTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#FINREC_def-val">FINREC_def</a> : thm
<a name="line7"></a>    val <a href="#from_def-val">from_def</a> : thm
<a name="line8"></a>    val <a href="#iterate-val">iterate</a> : thm
<a name="line9"></a>    val <a href="#monoidal-val">monoidal</a> : thm
<a name="line10"></a>    val <a href="#neutral-val">neutral</a> : thm
<a name="line11"></a>    val <a href="#nproduct-val">nproduct</a> : thm
<a name="line12"></a>    val <a href="#nsum-val">nsum</a> : thm
<a name="line13"></a>    val <a href="#numseg-val">numseg</a> : thm
<a name="line14"></a>    val <a href="#support-val">support</a> : thm
<a name="line15"></a>  
<a name="line16"></a>  (*  Theorems  *)
<a name="line17"></a>    val <a href="#ADD_SUB2-val">ADD_SUB2</a> : thm
<a name="line18"></a>    val <a href="#ADD_SUBR-val">ADD_SUBR</a> : thm
<a name="line19"></a>    val <a href="#ADD_SUBR2-val">ADD_SUBR2</a> : thm
<a name="line20"></a>    val <a href="#BIGINTER_BIGUNION-val">BIGINTER_BIGUNION</a> : thm
<a name="line21"></a>    val <a href="#BIGUNION_BIGINTER-val">BIGUNION_BIGINTER</a> : thm
<a name="line22"></a>    val <a href="#BOUNDS_LINEAR-val">BOUNDS_LINEAR</a> : thm
<a name="line23"></a>    val <a href="#BOUNDS_LINEAR_0-val">BOUNDS_LINEAR_0</a> : thm
<a name="line24"></a>    val <a href="#CARD_BIGUNION-val">CARD_BIGUNION</a> : thm
<a name="line25"></a>    val <a href="#CARD_EQ_NSUM-val">CARD_EQ_NSUM</a> : thm
<a name="line26"></a>    val <a href="#CARD_NUMSEG-val">CARD_NUMSEG</a> : thm
<a name="line27"></a>    val <a href="#CARD_NUMSEG_1-val">CARD_NUMSEG_1</a> : thm
<a name="line28"></a>    val <a href="#CARD_NUMSEG_LEMMA-val">CARD_NUMSEG_LEMMA</a> : thm
<a name="line29"></a>    val <a href="#CARD_UNION_EQ-val">CARD_UNION_EQ</a> : thm
<a name="line30"></a>    val <a href="#CHOOSE_SUBSET-val">CHOOSE_SUBSET</a> : thm
<a name="line31"></a>    val <a href="#CHOOSE_SUBSET_STRONG-val">CHOOSE_SUBSET_STRONG</a> : thm
<a name="line32"></a>    val <a href="#COUNTABLE_FROM-val">COUNTABLE_FROM</a> : thm
<a name="line33"></a>    val <a href="#COUNT_NUMSEG-val">COUNT_NUMSEG</a> : thm
<a name="line34"></a>    val <a href="#DIFF_BIGINTER2-val">DIFF_BIGINTER2</a> : thm
<a name="line35"></a>    val <a href="#DISJOINT_COUNT_FROM-val">DISJOINT_COUNT_FROM</a> : thm
<a name="line36"></a>    val <a href="#DISJOINT_FROM_COUNT-val">DISJOINT_FROM_COUNT</a> : thm
<a name="line37"></a>    val <a href="#DISJOINT_NUMSEG-val">DISJOINT_NUMSEG</a> : thm
<a name="line38"></a>    val <a href="#EMPTY_BIGUNION-val">EMPTY_BIGUNION</a> : thm
<a name="line39"></a>    val <a href="#EXISTS_FINITE_SUBSET_IMAGE-val">EXISTS_FINITE_SUBSET_IMAGE</a> : thm
<a name="line40"></a>    val <a href="#FINITE_INDEX_NUMBERS-val">FINITE_INDEX_NUMBERS</a> : thm
<a name="line41"></a>    val <a href="#FINITE_INDEX_NUMSEG-val">FINITE_INDEX_NUMSEG</a> : thm
<a name="line42"></a>    val <a href="#FINITE_NUMSEG-val">FINITE_NUMSEG</a> : thm
<a name="line43"></a>    val <a href="#FINITE_NUMSEG_LE-val">FINITE_NUMSEG_LE</a> : thm
<a name="line44"></a>    val <a href="#FINITE_NUMSEG_LT-val">FINITE_NUMSEG_LT</a> : thm
<a name="line45"></a>    val <a href="#FINITE_POWERSET-val">FINITE_POWERSET</a> : thm
<a name="line46"></a>    val <a href="#FINITE_RECURSION-val">FINITE_RECURSION</a> : thm
<a name="line47"></a>    val <a href="#FINITE_RESTRICT-val">FINITE_RESTRICT</a> : thm
<a name="line48"></a>    val <a href="#FINITE_SUBSET_IMAGE-val">FINITE_SUBSET_IMAGE</a> : thm
<a name="line49"></a>    val <a href="#FINITE_SUPPORT-val">FINITE_SUPPORT</a> : thm
<a name="line50"></a>    val <a href="#FINITE_SUPPORT_DELTA-val">FINITE_SUPPORT_DELTA</a> : thm
<a name="line51"></a>    val <a href="#FINREC_1_LEMMA-val">FINREC_1_LEMMA</a> : thm
<a name="line52"></a>    val <a href="#FINREC_EXISTS_LEMMA-val">FINREC_EXISTS_LEMMA</a> : thm
<a name="line53"></a>    val <a href="#FINREC_FUN-val">FINREC_FUN</a> : thm
<a name="line54"></a>    val <a href="#FINREC_FUN_LEMMA-val">FINREC_FUN_LEMMA</a> : thm
<a name="line55"></a>    val <a href="#FINREC_SUC_LEMMA-val">FINREC_SUC_LEMMA</a> : thm
<a name="line56"></a>    val <a href="#FINREC_UNIQUE_LEMMA-val">FINREC_UNIQUE_LEMMA</a> : thm
<a name="line57"></a>    val <a href="#FINREC_compute-val">FINREC_compute</a> : thm
<a name="line58"></a>    val <a href="#FORALL_FINITE_SUBSET_IMAGE-val">FORALL_FINITE_SUBSET_IMAGE</a> : thm
<a name="line59"></a>    val <a href="#FROM_0-val">FROM_0</a> : thm
<a name="line60"></a>    val <a href="#FROM_INTER_NUMSEG-val">FROM_INTER_NUMSEG</a> : thm
<a name="line61"></a>    val <a href="#FROM_INTER_NUMSEG_GEN-val">FROM_INTER_NUMSEG_GEN</a> : thm
<a name="line62"></a>    val <a href="#FROM_INTER_NUMSEG_MAX-val">FROM_INTER_NUMSEG_MAX</a> : thm
<a name="line63"></a>    val <a href="#FROM_NOT_EMPTY-val">FROM_NOT_EMPTY</a> : thm
<a name="line64"></a>    val <a href="#FUN_IN_IMAGE-val">FUN_IN_IMAGE</a> : thm
<a name="line65"></a>    val <a href="#HAS_SIZE_NUMSEG-val">HAS_SIZE_NUMSEG</a> : thm
<a name="line66"></a>    val <a href="#HAS_SIZE_NUMSEG_1-val">HAS_SIZE_NUMSEG_1</a> : thm
<a name="line67"></a>    val <a href="#HAS_SIZE_NUMSEG_LE-val">HAS_SIZE_NUMSEG_LE</a> : thm
<a name="line68"></a>    val <a href="#HAS_SIZE_NUMSEG_LT-val">HAS_SIZE_NUMSEG_LT</a> : thm
<a name="line69"></a>    val <a href="#INFINITE_FROM-val">INFINITE_FROM</a> : thm
<a name="line70"></a>    val <a href="#IN_FROM-val">IN_FROM</a> : thm
<a name="line71"></a>    val <a href="#IN_NUMSEG-val">IN_NUMSEG</a> : thm
<a name="line72"></a>    val <a href="#IN_NUMSEG_0-val">IN_NUMSEG_0</a> : thm
<a name="line73"></a>    val <a href="#IN_SUPPORT-val">IN_SUPPORT</a> : thm
<a name="line74"></a>    val <a href="#ITERATE_AND-val">ITERATE_AND</a> : thm
<a name="line75"></a>    val <a href="#ITERATE_BIJECTION-val">ITERATE_BIJECTION</a> : thm
<a name="line76"></a>    val <a href="#ITERATE_CASES-val">ITERATE_CASES</a> : thm
<a name="line77"></a>    val <a href="#ITERATE_CLAUSES-val">ITERATE_CLAUSES</a> : thm
<a name="line78"></a>    val <a href="#ITERATE_CLAUSES_GEN-val">ITERATE_CLAUSES_GEN</a> : thm
<a name="line79"></a>    val <a href="#ITERATE_CLAUSES_NUMSEG-val">ITERATE_CLAUSES_NUMSEG</a> : thm
<a name="line80"></a>    val <a href="#ITERATE_CLOSED-val">ITERATE_CLOSED</a> : thm
<a name="line81"></a>    val <a href="#ITERATE_DELETE-val">ITERATE_DELETE</a> : thm
<a name="line82"></a>    val <a href="#ITERATE_DELTA-val">ITERATE_DELTA</a> : thm
<a name="line83"></a>    val <a href="#ITERATE_DIFF-val">ITERATE_DIFF</a> : thm
<a name="line84"></a>    val <a href="#ITERATE_DIFF_GEN-val">ITERATE_DIFF_GEN</a> : thm
<a name="line85"></a>    val <a href="#ITERATE_EQ-val">ITERATE_EQ</a> : thm
<a name="line86"></a>    val <a href="#ITERATE_EQ_GENERAL-val">ITERATE_EQ_GENERAL</a> : thm
<a name="line87"></a>    val <a href="#ITERATE_EQ_GENERAL_INVERSES-val">ITERATE_EQ_GENERAL_INVERSES</a> : thm
<a name="line88"></a>    val <a href="#ITERATE_EQ_NEUTRAL-val">ITERATE_EQ_NEUTRAL</a> : thm
<a name="line89"></a>    val <a href="#ITERATE_EXPAND_CASES-val">ITERATE_EXPAND_CASES</a> : thm
<a name="line90"></a>    val <a href="#ITERATE_IMAGE-val">ITERATE_IMAGE</a> : thm
<a name="line91"></a>    val <a href="#ITERATE_IMAGE_NONZERO-val">ITERATE_IMAGE_NONZERO</a> : thm
<a name="line92"></a>    val <a href="#ITERATE_INCL_EXCL-val">ITERATE_INCL_EXCL</a> : thm
<a name="line93"></a>    val <a href="#ITERATE_INJECTION-val">ITERATE_INJECTION</a> : thm
<a name="line94"></a>    val <a href="#ITERATE_ITERATE_PRODUCT-val">ITERATE_ITERATE_PRODUCT</a> : thm
<a name="line95"></a>    val <a href="#ITERATE_OP-val">ITERATE_OP</a> : thm
<a name="line96"></a>    val <a href="#ITERATE_OP_GEN-val">ITERATE_OP_GEN</a> : thm
<a name="line97"></a>    val <a href="#ITERATE_PAIR-val">ITERATE_PAIR</a> : thm
<a name="line98"></a>    val <a href="#ITERATE_PERMUTE-val">ITERATE_PERMUTE</a> : thm
<a name="line99"></a>    val <a href="#ITERATE_PERMUTES-val">ITERATE_PERMUTES</a> : thm
<a name="line100"></a>    val <a href="#ITERATE_RELATED-val">ITERATE_RELATED</a> : thm
<a name="line101"></a>    val <a href="#ITERATE_SING-val">ITERATE_SING</a> : thm
<a name="line102"></a>    val <a href="#ITERATE_SOME-val">ITERATE_SOME</a> : thm
<a name="line103"></a>    val <a href="#ITERATE_SUPERSET-val">ITERATE_SUPERSET</a> : thm
<a name="line104"></a>    val <a href="#ITERATE_SUPPORT-val">ITERATE_SUPPORT</a> : thm
<a name="line105"></a>    val <a href="#ITERATE_UNION-val">ITERATE_UNION</a> : thm
<a name="line106"></a>    val <a href="#ITERATE_UNION_GEN-val">ITERATE_UNION_GEN</a> : thm
<a name="line107"></a>    val <a href="#ITERATE_UNION_NONZERO-val">ITERATE_UNION_NONZERO</a> : thm
<a name="line108"></a>    val <a href="#ITSET_alt-val">ITSET_alt</a> : thm
<a name="line109"></a>    val <a href="#LAMBDA_PAIR-val">LAMBDA_PAIR</a> : thm
<a name="line110"></a>    val <a href="#LE_ADD-val">LE_ADD</a> : thm
<a name="line111"></a>    val <a href="#LE_ADDR-val">LE_ADDR</a> : thm
<a name="line112"></a>    val <a href="#MOD_NSUM_MOD-val">MOD_NSUM_MOD</a> : thm
<a name="line113"></a>    val <a href="#MOD_NSUM_MOD_NUMSEG-val">MOD_NSUM_MOD_NUMSEG</a> : thm
<a name="line114"></a>    val <a href="#MONOIDAL_AC-val">MONOIDAL_AC</a> : thm
<a name="line115"></a>    val <a href="#MONOIDAL_ADD-val">MONOIDAL_ADD</a> : thm
<a name="line116"></a>    val <a href="#MONOIDAL_AND-val">MONOIDAL_AND</a> : thm
<a name="line117"></a>    val <a href="#MONOIDAL_LIFTED-val">MONOIDAL_LIFTED</a> : thm
<a name="line118"></a>    val <a href="#MONOIDAL_MUL-val">MONOIDAL_MUL</a> : thm
<a name="line119"></a>    val <a href="#NEUTRAL_ADD-val">NEUTRAL_ADD</a> : thm
<a name="line120"></a>    val <a href="#NEUTRAL_AND-val">NEUTRAL_AND</a> : thm
<a name="line121"></a>    val <a href="#NEUTRAL_LIFTED-val">NEUTRAL_LIFTED</a> : thm
<a name="line122"></a>    val <a href="#NEUTRAL_MUL-val">NEUTRAL_MUL</a> : thm
<a name="line123"></a>    val <a href="#NOT_EQ-val">NOT_EQ</a> : thm
<a name="line124"></a>    val <a href="#NPRODUCT_ADD_SPLIT-val">NPRODUCT_ADD_SPLIT</a> : thm
<a name="line125"></a>    val <a href="#NPRODUCT_CLAUSES-val">NPRODUCT_CLAUSES</a> : thm
<a name="line126"></a>    val <a href="#NPRODUCT_CLAUSES_LEFT-val">NPRODUCT_CLAUSES_LEFT</a> : thm
<a name="line127"></a>    val <a href="#NPRODUCT_CLAUSES_NUMSEG-val">NPRODUCT_CLAUSES_NUMSEG</a> : thm
<a name="line128"></a>    val <a href="#NPRODUCT_CLAUSES_RIGHT-val">NPRODUCT_CLAUSES_RIGHT</a> : thm
<a name="line129"></a>    val <a href="#NPRODUCT_CLOSED-val">NPRODUCT_CLOSED</a> : thm
<a name="line130"></a>    val <a href="#NPRODUCT_CONG-val">NPRODUCT_CONG</a> : thm
<a name="line131"></a>    val <a href="#NPRODUCT_CONST-val">NPRODUCT_CONST</a> : thm
<a name="line132"></a>    val <a href="#NPRODUCT_CONST_NUMSEG-val">NPRODUCT_CONST_NUMSEG</a> : thm
<a name="line133"></a>    val <a href="#NPRODUCT_CONST_NUMSEG_1-val">NPRODUCT_CONST_NUMSEG_1</a> : thm
<a name="line134"></a>    val <a href="#NPRODUCT_DELETE-val">NPRODUCT_DELETE</a> : thm
<a name="line135"></a>    val <a href="#NPRODUCT_DELTA-val">NPRODUCT_DELTA</a> : thm
<a name="line136"></a>    val <a href="#NPRODUCT_EQ-val">NPRODUCT_EQ</a> : thm
<a name="line137"></a>    val <a href="#NPRODUCT_EQ_0-val">NPRODUCT_EQ_0</a> : thm
<a name="line138"></a>    val <a href="#NPRODUCT_EQ_0_NUMSEG-val">NPRODUCT_EQ_0_NUMSEG</a> : thm
<a name="line139"></a>    val <a href="#NPRODUCT_EQ_1-val">NPRODUCT_EQ_1</a> : thm
<a name="line140"></a>    val <a href="#NPRODUCT_EQ_1_NUMSEG-val">NPRODUCT_EQ_1_NUMSEG</a> : thm
<a name="line141"></a>    val <a href="#NPRODUCT_EQ_NUMSEG-val">NPRODUCT_EQ_NUMSEG</a> : thm
<a name="line142"></a>    val <a href="#NPRODUCT_FACT-val">NPRODUCT_FACT</a> : thm
<a name="line143"></a>    val <a href="#NPRODUCT_IMAGE-val">NPRODUCT_IMAGE</a> : thm
<a name="line144"></a>    val <a href="#NPRODUCT_LE-val">NPRODUCT_LE</a> : thm
<a name="line145"></a>    val <a href="#NPRODUCT_LE_NUMSEG-val">NPRODUCT_LE_NUMSEG</a> : thm
<a name="line146"></a>    val <a href="#NPRODUCT_MUL-val">NPRODUCT_MUL</a> : thm
<a name="line147"></a>    val <a href="#NPRODUCT_MUL_GEN-val">NPRODUCT_MUL_GEN</a> : thm
<a name="line148"></a>    val <a href="#NPRODUCT_MUL_NUMSEG-val">NPRODUCT_MUL_NUMSEG</a> : thm
<a name="line149"></a>    val <a href="#NPRODUCT_OFFSET-val">NPRODUCT_OFFSET</a> : thm
<a name="line150"></a>    val <a href="#NPRODUCT_ONE-val">NPRODUCT_ONE</a> : thm
<a name="line151"></a>    val <a href="#NPRODUCT_PAIR-val">NPRODUCT_PAIR</a> : thm
<a name="line152"></a>    val <a href="#NPRODUCT_POS_LT-val">NPRODUCT_POS_LT</a> : thm
<a name="line153"></a>    val <a href="#NPRODUCT_POS_LT_NUMSEG-val">NPRODUCT_POS_LT_NUMSEG</a> : thm
<a name="line154"></a>    val <a href="#NPRODUCT_SING-val">NPRODUCT_SING</a> : thm
<a name="line155"></a>    val <a href="#NPRODUCT_SING_NUMSEG-val">NPRODUCT_SING_NUMSEG</a> : thm
<a name="line156"></a>    val <a href="#NPRODUCT_SUPERSET-val">NPRODUCT_SUPERSET</a> : thm
<a name="line157"></a>    val <a href="#NPRODUCT_SUPPORT-val">NPRODUCT_SUPPORT</a> : thm
<a name="line158"></a>    val <a href="#NPRODUCT_UNION-val">NPRODUCT_UNION</a> : thm
<a name="line159"></a>    val <a href="#NSUM_0-val">NSUM_0</a> : thm
<a name="line160"></a>    val <a href="#NSUM_ADD-val">NSUM_ADD</a> : thm
<a name="line161"></a>    val <a href="#NSUM_ADD_GEN-val">NSUM_ADD_GEN</a> : thm
<a name="line162"></a>    val <a href="#NSUM_ADD_NUMSEG-val">NSUM_ADD_NUMSEG</a> : thm
<a name="line163"></a>    val <a href="#NSUM_ADD_SPLIT-val">NSUM_ADD_SPLIT</a> : thm
<a name="line164"></a>    val <a href="#NSUM_BIGUNION_NONZERO-val">NSUM_BIGUNION_NONZERO</a> : thm
<a name="line165"></a>    val <a href="#NSUM_BIJECTION-val">NSUM_BIJECTION</a> : thm
<a name="line166"></a>    val <a href="#NSUM_BOUND-val">NSUM_BOUND</a> : thm
<a name="line167"></a>    val <a href="#NSUM_BOUND_GEN-val">NSUM_BOUND_GEN</a> : thm
<a name="line168"></a>    val <a href="#NSUM_BOUND_LT-val">NSUM_BOUND_LT</a> : thm
<a name="line169"></a>    val <a href="#NSUM_BOUND_LT_ALL-val">NSUM_BOUND_LT_ALL</a> : thm
<a name="line170"></a>    val <a href="#NSUM_BOUND_LT_GEN-val">NSUM_BOUND_LT_GEN</a> : thm
<a name="line171"></a>    val <a href="#NSUM_CASES-val">NSUM_CASES</a> : thm
<a name="line172"></a>    val <a href="#NSUM_CLAUSES-val">NSUM_CLAUSES</a> : thm
<a name="line173"></a>    val <a href="#NSUM_CLAUSES_LEFT-val">NSUM_CLAUSES_LEFT</a> : thm
<a name="line174"></a>    val <a href="#NSUM_CLAUSES_NUMSEG-val">NSUM_CLAUSES_NUMSEG</a> : thm
<a name="line175"></a>    val <a href="#NSUM_CLAUSES_RIGHT-val">NSUM_CLAUSES_RIGHT</a> : thm
<a name="line176"></a>    val <a href="#NSUM_CLOSED-val">NSUM_CLOSED</a> : thm
<a name="line177"></a>    val <a href="#NSUM_CONG-val">NSUM_CONG</a> : thm
<a name="line178"></a>    val <a href="#NSUM_CONST-val">NSUM_CONST</a> : thm
<a name="line179"></a>    val <a href="#NSUM_CONST_NUMSEG-val">NSUM_CONST_NUMSEG</a> : thm
<a name="line180"></a>    val <a href="#NSUM_DEGENERATE-val">NSUM_DEGENERATE</a> : thm
<a name="line181"></a>    val <a href="#NSUM_DELETE-val">NSUM_DELETE</a> : thm
<a name="line182"></a>    val <a href="#NSUM_DELTA-val">NSUM_DELTA</a> : thm
<a name="line183"></a>    val <a href="#NSUM_DIFF-val">NSUM_DIFF</a> : thm
<a name="line184"></a>    val <a href="#NSUM_EQ-val">NSUM_EQ</a> : thm
<a name="line185"></a>    val <a href="#NSUM_EQ_0-val">NSUM_EQ_0</a> : thm
<a name="line186"></a>    val <a href="#NSUM_EQ_0_IFF-val">NSUM_EQ_0_IFF</a> : thm
<a name="line187"></a>    val <a href="#NSUM_EQ_0_IFF_NUMSEG-val">NSUM_EQ_0_IFF_NUMSEG</a> : thm
<a name="line188"></a>    val <a href="#NSUM_EQ_0_NUMSEG-val">NSUM_EQ_0_NUMSEG</a> : thm
<a name="line189"></a>    val <a href="#NSUM_EQ_GENERAL-val">NSUM_EQ_GENERAL</a> : thm
<a name="line190"></a>    val <a href="#NSUM_EQ_GENERAL_INVERSES-val">NSUM_EQ_GENERAL_INVERSES</a> : thm
<a name="line191"></a>    val <a href="#NSUM_EQ_NUMSEG-val">NSUM_EQ_NUMSEG</a> : thm
<a name="line192"></a>    val <a href="#NSUM_EQ_SUPERSET-val">NSUM_EQ_SUPERSET</a> : thm
<a name="line193"></a>    val <a href="#NSUM_GROUP-val">NSUM_GROUP</a> : thm
<a name="line194"></a>    val <a href="#NSUM_IMAGE-val">NSUM_IMAGE</a> : thm
<a name="line195"></a>    val <a href="#NSUM_IMAGE_GEN-val">NSUM_IMAGE_GEN</a> : thm
<a name="line196"></a>    val <a href="#NSUM_IMAGE_NONZERO-val">NSUM_IMAGE_NONZERO</a> : thm
<a name="line197"></a>    val <a href="#NSUM_INCL_EXCL-val">NSUM_INCL_EXCL</a> : thm
<a name="line198"></a>    val <a href="#NSUM_INJECTION-val">NSUM_INJECTION</a> : thm
<a name="line199"></a>    val <a href="#NSUM_LE-val">NSUM_LE</a> : thm
<a name="line200"></a>    val <a href="#NSUM_LE_GEN-val">NSUM_LE_GEN</a> : thm
<a name="line201"></a>    val <a href="#NSUM_LE_NUMSEG-val">NSUM_LE_NUMSEG</a> : thm
<a name="line202"></a>    val <a href="#NSUM_LMUL-val">NSUM_LMUL</a> : thm
<a name="line203"></a>    val <a href="#NSUM_LT-val">NSUM_LT</a> : thm
<a name="line204"></a>    val <a href="#NSUM_LT_ALL-val">NSUM_LT_ALL</a> : thm
<a name="line205"></a>    val <a href="#NSUM_MULTICOUNT-val">NSUM_MULTICOUNT</a> : thm
<a name="line206"></a>    val <a href="#NSUM_MULTICOUNT_GEN-val">NSUM_MULTICOUNT_GEN</a> : thm
<a name="line207"></a>    val <a href="#NSUM_NSUM_PRODUCT-val">NSUM_NSUM_PRODUCT</a> : thm
<a name="line208"></a>    val <a href="#NSUM_NSUM_RESTRICT-val">NSUM_NSUM_RESTRICT</a> : thm
<a name="line209"></a>    val <a href="#NSUM_OFFSET-val">NSUM_OFFSET</a> : thm
<a name="line210"></a>    val <a href="#NSUM_OFFSET_0-val">NSUM_OFFSET_0</a> : thm
<a name="line211"></a>    val <a href="#NSUM_PAIR-val">NSUM_PAIR</a> : thm
<a name="line212"></a>    val <a href="#NSUM_PERMUTE-val">NSUM_PERMUTE</a> : thm
<a name="line213"></a>    val <a href="#NSUM_PERMUTE_COUNT-val">NSUM_PERMUTE_COUNT</a> : thm
<a name="line214"></a>    val <a href="#NSUM_PERMUTE_NUMSEG-val">NSUM_PERMUTE_NUMSEG</a> : thm
<a name="line215"></a>    val <a href="#NSUM_POS_BOUND-val">NSUM_POS_BOUND</a> : thm
<a name="line216"></a>    val <a href="#NSUM_POS_LT-val">NSUM_POS_LT</a> : thm
<a name="line217"></a>    val <a href="#NSUM_POS_LT_ALL-val">NSUM_POS_LT_ALL</a> : thm
<a name="line218"></a>    val <a href="#NSUM_RESTRICT-val">NSUM_RESTRICT</a> : thm
<a name="line219"></a>    val <a href="#NSUM_RESTRICT_SET-val">NSUM_RESTRICT_SET</a> : thm
<a name="line220"></a>    val <a href="#NSUM_RMUL-val">NSUM_RMUL</a> : thm
<a name="line221"></a>    val <a href="#NSUM_SING-val">NSUM_SING</a> : thm
<a name="line222"></a>    val <a href="#NSUM_SING_NUMSEG-val">NSUM_SING_NUMSEG</a> : thm
<a name="line223"></a>    val <a href="#NSUM_SUBSET-val">NSUM_SUBSET</a> : thm
<a name="line224"></a>    val <a href="#NSUM_SUBSET_SIMPLE-val">NSUM_SUBSET_SIMPLE</a> : thm
<a name="line225"></a>    val <a href="#NSUM_SUPERSET-val">NSUM_SUPERSET</a> : thm
<a name="line226"></a>    val <a href="#NSUM_SUPPORT-val">NSUM_SUPPORT</a> : thm
<a name="line227"></a>    val <a href="#NSUM_SWAP-val">NSUM_SWAP</a> : thm
<a name="line228"></a>    val <a href="#NSUM_SWAP_NUMSEG-val">NSUM_SWAP_NUMSEG</a> : thm
<a name="line229"></a>    val <a href="#NSUM_TRIV_NUMSEG-val">NSUM_TRIV_NUMSEG</a> : thm
<a name="line230"></a>    val <a href="#NSUM_UNION-val">NSUM_UNION</a> : thm
<a name="line231"></a>    val <a href="#NSUM_UNION_EQ-val">NSUM_UNION_EQ</a> : thm
<a name="line232"></a>    val <a href="#NSUM_UNION_LZERO-val">NSUM_UNION_LZERO</a> : thm
<a name="line233"></a>    val <a href="#NSUM_UNION_NONZERO-val">NSUM_UNION_NONZERO</a> : thm
<a name="line234"></a>    val <a href="#NSUM_UNION_RZERO-val">NSUM_UNION_RZERO</a> : thm
<a name="line235"></a>    val <a href="#NUMSEG_ADD_SPLIT-val">NUMSEG_ADD_SPLIT</a> : thm
<a name="line236"></a>    val <a href="#NUMSEG_CLAUSES-val">NUMSEG_CLAUSES</a> : thm
<a name="line237"></a>    val <a href="#NUMSEG_COMBINE_L-val">NUMSEG_COMBINE_L</a> : thm
<a name="line238"></a>    val <a href="#NUMSEG_COMBINE_R-val">NUMSEG_COMBINE_R</a> : thm
<a name="line239"></a>    val <a href="#NUMSEG_EMPTY-val">NUMSEG_EMPTY</a> : thm
<a name="line240"></a>    val <a href="#NUMSEG_LE-val">NUMSEG_LE</a> : thm
<a name="line241"></a>    val <a href="#NUMSEG_LREC-val">NUMSEG_LREC</a> : thm
<a name="line242"></a>    val <a href="#NUMSEG_LT-val">NUMSEG_LT</a> : thm
<a name="line243"></a>    val <a href="#NUMSEG_OFFSET_IMAGE-val">NUMSEG_OFFSET_IMAGE</a> : thm
<a name="line244"></a>    val <a href="#NUMSEG_REC-val">NUMSEG_REC</a> : thm
<a name="line245"></a>    val <a href="#NUMSEG_RREC-val">NUMSEG_RREC</a> : thm
<a name="line246"></a>    val <a href="#NUMSEG_SING-val">NUMSEG_SING</a> : thm
<a name="line247"></a>    val <a href="#POWERSET_CLAUSES-val">POWERSET_CLAUSES</a> : thm
<a name="line248"></a>    val <a href="#SET_PROVE_CASES-val">SET_PROVE_CASES</a> : thm
<a name="line249"></a>    val <a href="#SET_RECURSION_LEMMA-val">SET_RECURSION_LEMMA</a> : thm
<a name="line250"></a>    val <a href="#SIMPLE_IMAGE_GEN-val">SIMPLE_IMAGE_GEN</a> : thm
<a name="line251"></a>    val <a href="#SUBSET_NUMSEG-val">SUBSET_NUMSEG</a> : thm
<a name="line252"></a>    val <a href="#SUBSET_RESTRICT-val">SUBSET_RESTRICT</a> : thm
<a name="line253"></a>    val <a href="#SUPPORT_CLAUSES-val">SUPPORT_CLAUSES</a> : thm
<a name="line254"></a>    val <a href="#SUPPORT_DELTA-val">SUPPORT_DELTA</a> : thm
<a name="line255"></a>    val <a href="#SUPPORT_EMPTY-val">SUPPORT_EMPTY</a> : thm
<a name="line256"></a>    val <a href="#SUPPORT_SUBSET-val">SUPPORT_SUBSET</a> : thm
<a name="line257"></a>    val <a href="#SUPPORT_SUPPORT-val">SUPPORT_SUPPORT</a> : thm
<a name="line258"></a>    val <a href="#TOPOLOGICAL_SORT-val">TOPOLOGICAL_SORT</a> : thm
<a name="line259"></a>    val <a href="#TOPOLOGICAL_SORT'-val">TOPOLOGICAL_SORT'</a> : thm
<a name="line260"></a>    val <a href="#TRANSFORM_2D_NUM-val">TRANSFORM_2D_NUM</a> : thm
<a name="line261"></a>    val <a href="#TRANSITIVE_STEPWISE_LE-val">TRANSITIVE_STEPWISE_LE</a> : thm
<a name="line262"></a>    val <a href="#TRANSITIVE_STEPWISE_LE_EQ-val">TRANSITIVE_STEPWISE_LE_EQ</a> : thm
<a name="line263"></a>    val <a href="#TRIANGLE_2D_NUM-val">TRIANGLE_2D_NUM</a> : thm
<a name="line264"></a>    val <a href="#UNION_COUNT_FROM-val">UNION_COUNT_FROM</a> : thm
<a name="line265"></a>    val <a href="#UNION_FROM_COUNT-val">UNION_FROM_COUNT</a> : thm
<a name="line266"></a>    val <a href="#UPPER_BOUND_FINITE_SET-val">UPPER_BOUND_FINITE_SET</a> : thm
<a name="line267"></a>    val <a href="#lifted-val">lifted</a> : thm
<a name="line268"></a>    val <a href="#lifted_ind-val">lifted_ind</a> : thm
<a name="line269"></a>(*
   [permutes] Parent theory of "iterate"
   
   [<a name="FINREC_def-val"><b>FINREC_def</b></a>]  Definition
      
      ‚ä¢ (‚àÄf b s a. FINREC f b s a 0 ‚áî s = ‚àÖ ‚àß a = b) ‚àß
        ‚àÄf b s a n.
          FINREC f b s a (SUC n) ‚áî
          ‚àÉx c. x ‚àà s ‚àß FINREC f b (s DELETE x) c n ‚àß a = f x c
   
   [<a name="from_def-val"><b>from_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄn. from n = {m | n ‚â§ m}
   
   [<a name="iterate-val"><b>iterate</b></a>]  Definition
      
      ‚ä¢ ‚àÄop s f.
          iterate op s f =
          if FINITE (support op f s) then
            ITSET (Œªx a. op (f x) a) (support op f s) (neutral op)
          else neutral op
   
   [<a name="monoidal-val"><b>monoidal</b></a>]  Definition
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áî
          (‚àÄx y. op x y = op y x) ‚àß
          (‚àÄx y z. op x (op y z) = op (op x y) z) ‚àß
          ‚àÄx. op (neutral op) x = x
   
   [<a name="neutral-val"><b>neutral</b></a>]  Definition
      
      ‚ä¢ ‚àÄop. neutral op = @x. ‚àÄy. op x y = y ‚àß op y x = y
   
   [<a name="nproduct-val"><b>nproduct</b></a>]  Definition
      
      ‚ä¢ nproduct = iterate $*
   
   [<a name="nsum-val"><b>nsum</b></a>]  Definition
      
      ‚ä¢ nsum = iterate $+
   
   [<a name="numseg-val"><b>numseg</b></a>]  Definition
      
      ‚ä¢ ‚àÄm n. {m .. n} = {x | m ‚â§ x ‚àß x ‚â§ n}
   
   [<a name="support-val"><b>support</b></a>]  Definition
      
      ‚ä¢ ‚àÄop f s. support op f s = {x | x ‚àà s ‚àß f x ‚â† neutral op}
   
   [<a name="ADD_SUB2-val"><b>ADD_SUB2</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm n. m + n ‚àí m = n
   
   [<a name="ADD_SUBR-val"><b>ADD_SUBR</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm n. n ‚àí (m + n) = 0
   
   [<a name="ADD_SUBR2-val"><b>ADD_SUBR2</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm n. m ‚àí (m + n) = 0
   
   [<a name="BIGINTER_BIGUNION-val"><b>BIGINTER_BIGUNION</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs. BIGINTER s = ùïå(:Œ±) DIFF BIGUNION {ùïå(:Œ±) DIFF t | t ‚àà s}
   
   [<a name="BIGUNION_BIGINTER-val"><b>BIGUNION_BIGINTER</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs. BIGUNION s = ùïå(:Œ±) DIFF BIGINTER {ùïå(:Œ±) DIFF t | t ‚àà s}
   
   [<a name="BOUNDS_LINEAR-val"><b>BOUNDS_LINEAR</b></a>]  Theorem
      
      ‚ä¢ ‚àÄA B C. (‚àÄn. A * n ‚â§ B * n + C) ‚áî A ‚â§ B
   
   [<a name="BOUNDS_LINEAR_0-val"><b>BOUNDS_LINEAR_0</b></a>]  Theorem
      
      ‚ä¢ ‚àÄA B. (‚àÄn. A * n ‚â§ B) ‚áî A = 0
   
   [<a name="CARD_BIGUNION-val"><b>CARD_BIGUNION</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs. FINITE s ‚àß (‚àÄt. t ‚àà s ‚áí FINITE t) ‚àß
            (‚àÄt u. t ‚àà s ‚àß u ‚àà s ‚àß t ‚â† u ‚áí t ‚à© u = ‚àÖ) ‚áí
            CARD (BIGUNION s) = nsum s CARD
   
   [<a name="CARD_EQ_NSUM-val"><b>CARD_EQ_NSUM</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs. FINITE s ‚áí CARD s = nsum s (Œªx. 1)
   
   [<a name="CARD_NUMSEG-val"><b>CARD_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm n. CARD {m .. n} = n + 1 ‚àí m
   
   [<a name="CARD_NUMSEG_1-val"><b>CARD_NUMSEG_1</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. CARD {1 .. n} = n
   
   [<a name="CARD_NUMSEG_LEMMA-val"><b>CARD_NUMSEG_LEMMA</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm d. CARD {m .. m + d} = d + 1
   
   [<a name="CARD_UNION_EQ-val"><b>CARD_UNION_EQ</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs t u. FINITE u ‚àß s ‚à© t = ‚àÖ ‚àß s ‚à™ t = u ‚áí CARD s + CARD t = CARD u
   
   [<a name="CHOOSE_SUBSET-val"><b>CHOOSE_SUBSET</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs. FINITE s ‚áí ‚àÄn. n ‚â§ CARD s ‚áí ‚àÉt. t ‚äÜ s ‚àß t HAS_SIZE n
   
   [<a name="CHOOSE_SUBSET_STRONG-val"><b>CHOOSE_SUBSET_STRONG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn s. (FINITE s ‚áí n ‚â§ CARD s) ‚áí ‚àÉt. t ‚äÜ s ‚àß t HAS_SIZE n
   
   [<a name="COUNTABLE_FROM-val"><b>COUNTABLE_FROM</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. countable (from n)
   
   [<a name="COUNT_NUMSEG-val"><b>COUNT_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. 0 &lt; n ‚áí count n = {0 .. n ‚àí 1}
   
   [<a name="DIFF_BIGINTER2-val"><b>DIFF_BIGINTER2</b></a>]  Theorem
      
      ‚ä¢ ‚àÄu s. u DIFF BIGINTER s = BIGUNION {u DIFF t | t ‚àà s}
   
   [<a name="DISJOINT_COUNT_FROM-val"><b>DISJOINT_COUNT_FROM</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. DISJOINT (count n) (from n)
   
   [<a name="DISJOINT_FROM_COUNT-val"><b>DISJOINT_FROM_COUNT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. DISJOINT (from n) (count n)
   
   [<a name="DISJOINT_NUMSEG-val"><b>DISJOINT_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm n p q.
          DISJOINT {m .. n} {p .. q} ‚áî n &lt; p ‚à® q &lt; m ‚à® n &lt; m ‚à® q &lt; p
   
   [<a name="EMPTY_BIGUNION-val"><b>EMPTY_BIGUNION</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs. BIGUNION s = ‚àÖ ‚áî ‚àÄt. t ‚àà s ‚áí t = ‚àÖ
   
   [<a name="EXISTS_FINITE_SUBSET_IMAGE-val"><b>EXISTS_FINITE_SUBSET_IMAGE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄP f s.
          (‚àÉt. FINITE t ‚àß t ‚äÜ IMAGE f s ‚àß P t) ‚áî
          ‚àÉt. FINITE t ‚àß t ‚äÜ s ‚àß P (IMAGE f t)
   
   [<a name="FINITE_INDEX_NUMBERS-val"><b>FINITE_INDEX_NUMBERS</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs. FINITE s ‚áî
            ‚àÉk f.
              (‚àÄi j. i ‚àà k ‚àß j ‚àà k ‚àß f i = f j ‚áí i = j) ‚àß FINITE k ‚àß
              s = IMAGE f k
   
   [<a name="FINITE_INDEX_NUMSEG-val"><b>FINITE_INDEX_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs. FINITE s ‚áî
            ‚àÉf. (‚àÄi j.
                   i ‚àà {1 .. CARD s} ‚àß j ‚àà {1 .. CARD s} ‚àß f i = f j ‚áí
                   i = j) ‚àß s = IMAGE f {1 .. CARD s}
   
   [<a name="FINITE_NUMSEG-val"><b>FINITE_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm n. FINITE {m .. n}
   
   [<a name="FINITE_NUMSEG_LE-val"><b>FINITE_NUMSEG_LE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. FINITE {m | m ‚â§ n}
   
   [<a name="FINITE_NUMSEG_LT-val"><b>FINITE_NUMSEG_LT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. FINITE {m | m &lt; n}
   
   [<a name="FINITE_POWERSET-val"><b>FINITE_POWERSET</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs. FINITE s ‚áí FINITE {t | t ‚äÜ s}
   
   [<a name="FINITE_RECURSION-val"><b>FINITE_RECURSION</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf b.
          (‚àÄx y s. x ‚â† y ‚áí f x (f y s) = f y (f x s)) ‚áí
          ITSET f ‚àÖ b = b ‚àß
          ‚àÄx s.
            FINITE s ‚áí
            ITSET f (x INSERT s) b =
            if x ‚àà s then ITSET f s b else f x (ITSET f s b)
   
   [<a name="FINITE_RESTRICT-val"><b>FINITE_RESTRICT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs P. FINITE s ‚áí FINITE {x | x ‚àà s ‚àß P x}
   
   [<a name="FINITE_SUBSET_IMAGE-val"><b>FINITE_SUBSET_IMAGE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf s t.
          FINITE t ‚àß t ‚äÜ IMAGE f s ‚áî
          ‚àÉs'. FINITE s' ‚àß s' ‚äÜ s ‚àß t = IMAGE f s'
   
   [<a name="FINITE_SUPPORT-val"><b>FINITE_SUPPORT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop f s. FINITE s ‚áí FINITE (support op f s)
   
   [<a name="FINITE_SUPPORT_DELTA-val"><b>FINITE_SUPPORT_DELTA</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop f a.
          FINITE (support op (Œªx. if x = a then f x else neutral op) s)
   
   [<a name="FINREC_1_LEMMA-val"><b>FINREC_1_LEMMA</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf b s a. FINREC f b s a (SUC 0) ‚áî ‚àÉx. s = {x} ‚àß a = f x b
   
   [<a name="FINREC_EXISTS_LEMMA-val"><b>FINREC_EXISTS_LEMMA</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf b s. FINITE s ‚áí ‚àÉa n. FINREC f b s a n
   
   [<a name="FINREC_FUN-val"><b>FINREC_FUN</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf b.
          (‚àÄx y s. x ‚â† y ‚áí f x (f y s) = f y (f x s)) ‚áí
          ‚àÉg. g ‚àÖ = b ‚àß ‚àÄs x. FINITE s ‚àß x ‚àà s ‚áí g s = f x (g (s DELETE x))
   
   [<a name="FINREC_FUN_LEMMA-val"><b>FINREC_FUN_LEMMA</b></a>]  Theorem
      
      ‚ä¢ ‚àÄP R.
          (‚àÄs. P s ‚áí ‚àÉa n. R s a n) ‚àß
          (‚àÄn1 n2 s a1 a2. R s a1 n1 ‚àß R s a2 n2 ‚áí a1 = a2 ‚àß n1 = n2) ‚áí
          ‚àÉf. ‚àÄs a. P s ‚áí ((‚àÉn. R s a n) ‚áî f s = a)
   
   [<a name="FINREC_SUC_LEMMA-val"><b>FINREC_SUC_LEMMA</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf b.
          (‚àÄx y s. x ‚â† y ‚áí f x (f y s) = f y (f x s)) ‚áí
          ‚àÄn s z.
            FINREC f b s z (SUC n) ‚áí
            ‚àÄx. x ‚àà s ‚áí ‚àÉw. FINREC f b (s DELETE x) w n ‚àß z = f x w
   
   [<a name="FINREC_UNIQUE_LEMMA-val"><b>FINREC_UNIQUE_LEMMA</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf b.
          (‚àÄx y s. x ‚â† y ‚áí f x (f y s) = f y (f x s)) ‚áí
          ‚àÄn1 n2 s a1 a2.
            FINREC f b s a1 n1 ‚àß FINREC f b s a2 n2 ‚áí a1 = a2 ‚àß n1 = n2
   
   [<a name="FINREC_compute-val"><b>FINREC_compute</b></a>]  Theorem
      
      ‚ä¢ (‚àÄf b s a. FINREC f b s a 0 ‚áî s = ‚àÖ ‚àß a = b) ‚àß
        (‚àÄf b s a n.
           FINREC f b s a &lt;..num comp'n..&gt; ‚áî
           ‚àÉx c.
             x ‚àà s ‚àß FINREC f b (s DELETE x) c (&lt;..num comp'n..&gt; ‚àí 1) ‚àß
             a = f x c) ‚àß
        ‚àÄf b s a n.
          FINREC f b s a &lt;..num comp'n..&gt; ‚áî
          ‚àÉx c.
            x ‚àà s ‚àß FINREC f b (s DELETE x) c &lt;..num comp'n..&gt; ‚àß a = f x c
   
   [<a name="FORALL_FINITE_SUBSET_IMAGE-val"><b>FORALL_FINITE_SUBSET_IMAGE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄP f s.
          (‚àÄt. FINITE t ‚àß t ‚äÜ IMAGE f s ‚áí P t) ‚áî
          ‚àÄt. FINITE t ‚àß t ‚äÜ s ‚áí P (IMAGE f t)
   
   [<a name="FROM_0-val"><b>FROM_0</b></a>]  Theorem
      
      ‚ä¢ from 0 = ùïå(:num)
   
   [<a name="FROM_INTER_NUMSEG-val"><b>FROM_INTER_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄk n. from k ‚à© {0 .. n} = {k .. n}
   
   [<a name="FROM_INTER_NUMSEG_GEN-val"><b>FROM_INTER_NUMSEG_GEN</b></a>]  Theorem
      
      ‚ä¢ ‚àÄk m n. from k ‚à© {m .. n} = if m &lt; k then {k .. n} else {m .. n}
   
   [<a name="FROM_INTER_NUMSEG_MAX-val"><b>FROM_INTER_NUMSEG_MAX</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm n p. from p ‚à© {m .. n} = {MAX p m .. n}
   
   [<a name="FROM_NOT_EMPTY-val"><b>FROM_NOT_EMPTY</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. from n ‚â† ‚àÖ
   
   [<a name="FUN_IN_IMAGE-val"><b>FUN_IN_IMAGE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf s x. x ‚àà s ‚áí f x ‚àà IMAGE f s
   
   [<a name="HAS_SIZE_NUMSEG-val"><b>HAS_SIZE_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm n. {m .. n} HAS_SIZE n + 1 ‚àí m
   
   [<a name="HAS_SIZE_NUMSEG_1-val"><b>HAS_SIZE_NUMSEG_1</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. {1 .. n} HAS_SIZE n
   
   [<a name="HAS_SIZE_NUMSEG_LE-val"><b>HAS_SIZE_NUMSEG_LE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. {m | m ‚â§ n} HAS_SIZE n + 1
   
   [<a name="HAS_SIZE_NUMSEG_LT-val"><b>HAS_SIZE_NUMSEG_LT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. {m | m &lt; n} HAS_SIZE n
   
   [<a name="INFINITE_FROM-val"><b>INFINITE_FROM</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. INFINITE (from n)
   
   [<a name="IN_FROM-val"><b>IN_FROM</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm n. m ‚àà from n ‚áî n ‚â§ m
   
   [<a name="IN_NUMSEG-val"><b>IN_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ x ‚àà {m .. n} ‚áî m ‚â§ x ‚àß x ‚â§ n
   
   [<a name="IN_NUMSEG_0-val"><b>IN_NUMSEG_0</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm n. m ‚àà {0 .. n} ‚áî m ‚â§ n
   
   [<a name="IN_SUPPORT-val"><b>IN_SUPPORT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop f x s. x ‚àà support op f s ‚áî x ‚àà s ‚àß f x ‚â† neutral op
   
   [<a name="ITERATE_AND-val"><b>ITERATE_AND</b></a>]  Theorem
      
      ‚ä¢ ‚àÄp s. FINITE s ‚áí (iterate $/\ s p ‚áî ‚àÄx. x ‚àà s ‚áí p x)
   
   [<a name="ITERATE_BIJECTION-val"><b>ITERATE_BIJECTION</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          ‚àÄf p s.
            (‚àÄx. x ‚àà s ‚áí p x ‚àà s) ‚àß (‚àÄy. y ‚àà s ‚áí ‚àÉ!x. x ‚àà s ‚àß p x = y) ‚áí
            iterate op s f = iterate op s (f ‚àò p)
   
   [<a name="ITERATE_CASES-val"><b>ITERATE_CASES</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          ‚àÄs P f g.
            FINITE s ‚áí
            iterate op s (Œªx. if P x then f x else g x) =
            op (iterate op {x | x ‚àà s ‚àß P x} f)
              (iterate op {x | x ‚àà s ‚àß ¬¨P x} g)
   
   [<a name="ITERATE_CLAUSES-val"><b>ITERATE_CLAUSES</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          (‚àÄf. iterate op ‚àÖ f = neutral op) ‚àß
          ‚àÄf x s.
            FINITE s ‚áí
            iterate op (x INSERT s) f =
            if x ‚àà s then iterate op s f else op (f x) (iterate op s f)
   
   [<a name="ITERATE_CLAUSES_GEN-val"><b>ITERATE_CLAUSES_GEN</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          (‚àÄf. iterate op ‚àÖ f = neutral op) ‚àß
          ‚àÄf x s.
            monoidal op ‚àß FINITE (support op f s) ‚áí
            iterate op (x INSERT s) f =
            if x ‚àà s then iterate op s f else op (f x) (iterate op s f)
   
   [<a name="ITERATE_CLAUSES_NUMSEG-val"><b>ITERATE_CLAUSES_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          (‚àÄm. iterate op {m .. 0} f = if m = 0 then f 0 else neutral op) ‚àß
          ‚àÄm n.
            iterate op {m .. SUC n} f =
            if m ‚â§ SUC n then op (iterate op {m .. n} f) (f (SUC n))
            else iterate op {m .. n} f
   
   [<a name="ITERATE_CLOSED-val"><b>ITERATE_CLOSED</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          ‚àÄP. P (neutral op) ‚àß (‚àÄx y. P x ‚àß P y ‚áí P (op x y)) ‚áí
              ‚àÄf s.
                (‚àÄx. x ‚àà s ‚àß f x ‚â† neutral op ‚áí P (f x)) ‚áí
                P (iterate op s f)
   
   [<a name="ITERATE_DELETE-val"><b>ITERATE_DELETE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          ‚àÄf s a.
            FINITE s ‚àß a ‚àà s ‚áí
            op (f a) (iterate op (s DELETE a) f) = iterate op s f
   
   [<a name="ITERATE_DELTA-val"><b>ITERATE_DELTA</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          ‚àÄf a s.
            iterate op s (Œªx. if x = a then f x else neutral op) =
            if a ‚àà s then f a else neutral op
   
   [<a name="ITERATE_DIFF-val"><b>ITERATE_DIFF</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          ‚àÄf s t.
            FINITE s ‚àß t ‚äÜ s ‚áí
            op (iterate op (s DIFF t) f) (iterate op t f) = iterate op s f
   
   [<a name="ITERATE_DIFF_GEN-val"><b>ITERATE_DIFF_GEN</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          ‚àÄf s t.
            FINITE (support op f s) ‚àß support op f t ‚äÜ support op f s ‚áí
            op (iterate op (s DIFF t) f) (iterate op t f) = iterate op s f
   
   [<a name="ITERATE_EQ-val"><b>ITERATE_EQ</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          ‚àÄf g s. (‚àÄx. x ‚àà s ‚áí f x = g x) ‚áí iterate op s f = iterate op s g
   
   [<a name="ITERATE_EQ_GENERAL-val"><b>ITERATE_EQ_GENERAL</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          ‚àÄs t f g h.
            (‚àÄy. y ‚àà t ‚áí ‚àÉ!x. x ‚àà s ‚àß h x = y) ‚àß
            (‚àÄx. x ‚àà s ‚áí h x ‚àà t ‚àß g (h x) = f x) ‚áí
            iterate op s f = iterate op t g
   
   [<a name="ITERATE_EQ_GENERAL_INVERSES-val"><b>ITERATE_EQ_GENERAL_INVERSES</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          ‚àÄs t f g h k.
            (‚àÄy. y ‚àà t ‚áí k y ‚àà s ‚àß h (k y) = y) ‚àß
            (‚àÄx. x ‚àà s ‚áí h x ‚àà t ‚àß k (h x) = x ‚àß g (h x) = f x) ‚áí
            iterate op s f = iterate op t g
   
   [<a name="ITERATE_EQ_NEUTRAL-val"><b>ITERATE_EQ_NEUTRAL</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          ‚àÄf s.
            (‚àÄx. x ‚àà s ‚áí f x = neutral op) ‚áí iterate op s f = neutral op
   
   [<a name="ITERATE_EXPAND_CASES-val"><b>ITERATE_EXPAND_CASES</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop f s.
          iterate op s f =
          if FINITE (support op f s) then iterate op (support op f s) f
          else neutral op
   
   [<a name="ITERATE_IMAGE-val"><b>ITERATE_IMAGE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          ‚àÄf g s.
            (‚àÄx y. x ‚àà s ‚àß y ‚àà s ‚àß f x = f y ‚áí x = y) ‚áí
            iterate op (IMAGE f s) g = iterate op s (g ‚àò f)
   
   [<a name="ITERATE_IMAGE_NONZERO-val"><b>ITERATE_IMAGE_NONZERO</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          ‚àÄg f s.
            FINITE s ‚àß
            (‚àÄx y. x ‚àà s ‚àß y ‚àà s ‚àß x ‚â† y ‚àß f x = f y ‚áí g (f x) = neutral op) ‚áí
            iterate op (IMAGE f s) g = iterate op s (g ‚àò f)
   
   [<a name="ITERATE_INCL_EXCL-val"><b>ITERATE_INCL_EXCL</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          ‚àÄs t f.
            FINITE s ‚àß FINITE t ‚áí
            op (iterate op s f) (iterate op t f) =
            op (iterate op (s ‚à™ t) f) (iterate op (s ‚à© t) f)
   
   [<a name="ITERATE_INJECTION-val"><b>ITERATE_INJECTION</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          ‚àÄf p s.
            FINITE s ‚àß (‚àÄx. x ‚àà s ‚áí p x ‚àà s) ‚àß
            (‚àÄx y. x ‚àà s ‚àß y ‚àà s ‚àß p x = p y ‚áí x = y) ‚áí
            iterate op s (f ‚àò p) = iterate op s f
   
   [<a name="ITERATE_ITERATE_PRODUCT-val"><b>ITERATE_ITERATE_PRODUCT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          ‚àÄs t x.
            FINITE s ‚àß (‚àÄi. i ‚àà s ‚áí FINITE (t i)) ‚áí
            iterate op s (Œªi. iterate op (t i) (x i)) =
            iterate op {(i,j) | i ‚àà s ‚àß j ‚àà t i} (Œª(i,j). x i j)
   
   [<a name="ITERATE_OP-val"><b>ITERATE_OP</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          ‚àÄf g s.
            FINITE s ‚áí
            iterate op s (Œªx. op (f x) (g x)) =
            op (iterate op s f) (iterate op s g)
   
   [<a name="ITERATE_OP_GEN-val"><b>ITERATE_OP_GEN</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          ‚àÄf g s.
            FINITE (support op f s) ‚àß FINITE (support op g s) ‚áí
            iterate op s (Œªx. op (f x) (g x)) =
            op (iterate op s f) (iterate op s g)
   
   [<a name="ITERATE_PAIR-val"><b>ITERATE_PAIR</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          ‚àÄf m n.
            iterate op {2 * m .. 2 * n + 1} f =
            iterate op {m .. n} (Œªi. op (f (2 * i)) (f (2 * i + 1)))
   
   [<a name="ITERATE_PERMUTE-val"><b>ITERATE_PERMUTE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          ‚àÄf p s. p permutes s ‚áí iterate op s f = iterate op s (f ‚àò p)
   
   [<a name="ITERATE_PERMUTES-val"><b>ITERATE_PERMUTES</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          ‚àÄf p s. p PERMUTES s ‚áí iterate op s f = iterate op s (f ‚àò p)
   
   [<a name="ITERATE_RELATED-val"><b>ITERATE_RELATED</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          ‚àÄR. R (neutral op) (neutral op) ‚àß
              (‚àÄx1 y1 x2 y2. R x1 x2 ‚àß R y1 y2 ‚áí R (op x1 y1) (op x2 y2)) ‚áí
              ‚àÄf g s.
                FINITE s ‚àß (‚àÄx. x ‚àà s ‚áí R (f x) (g x)) ‚áí
                R (iterate op s f) (iterate op s g)
   
   [<a name="ITERATE_SING-val"><b>ITERATE_SING</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop. monoidal op ‚áí ‚àÄf x. iterate op {x} f = f x
   
   [<a name="ITERATE_SOME-val"><b>ITERATE_SOME</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          ‚àÄf s.
            FINITE s ‚áí
            iterate (lifted op) s (Œªx. SOME (f x)) = SOME (iterate op s f)
   
   [<a name="ITERATE_SUPERSET-val"><b>ITERATE_SUPERSET</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          ‚àÄf u v.
            u ‚äÜ v ‚àß (‚àÄx. x ‚àà v ‚àß x ‚àâ u ‚áí f x = neutral op) ‚áí
            iterate op v f = iterate op u f
   
   [<a name="ITERATE_SUPPORT-val"><b>ITERATE_SUPPORT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop f s. iterate op (support op f s) f = iterate op s f
   
   [<a name="ITERATE_UNION-val"><b>ITERATE_UNION</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          ‚àÄf s t.
            FINITE s ‚àß FINITE t ‚àß DISJOINT s t ‚áí
            iterate op (s ‚à™ t) f = op (iterate op s f) (iterate op t f)
   
   [<a name="ITERATE_UNION_GEN-val"><b>ITERATE_UNION_GEN</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          ‚àÄf s t.
            FINITE (support op f s) ‚àß FINITE (support op f t) ‚àß
            DISJOINT (support op f s) (support op f t) ‚áí
            iterate op (s ‚à™ t) f = op (iterate op s f) (iterate op t f)
   
   [<a name="ITERATE_UNION_NONZERO-val"><b>ITERATE_UNION_NONZERO</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          ‚àÄf s t.
            FINITE s ‚àß FINITE t ‚àß (‚àÄx. x ‚àà s ‚à© t ‚áí f x = neutral op) ‚áí
            iterate op (s ‚à™ t) f = op (iterate op s f) (iterate op t f)
   
   [<a name="ITSET_alt-val"><b>ITSET_alt</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf s b.
          (‚àÄx y z. f x (f y z) = f y (f x z)) ‚àß FINITE s ‚áí
          ITSET f s b =
          (@g. g ‚àÖ = b ‚àß
               ‚àÄx s.
                 FINITE s ‚áí
                 g (x INSERT s) = if x ‚àà s then g s else f x (g s)) s
   
   [<a name="LAMBDA_PAIR-val"><b>LAMBDA_PAIR</b></a>]  Theorem
      
      ‚ä¢ (Œª(x,y). P x y) = (Œªp. P (FST p) (SND p))
   
   [<a name="LE_ADD-val"><b>LE_ADD</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm n. m ‚â§ m + n
   
   [<a name="LE_ADDR-val"><b>LE_ADDR</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm n. n ‚â§ m + n
   
   [<a name="MOD_NSUM_MOD-val"><b>MOD_NSUM_MOD</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf n s.
          FINITE s ‚àß n ‚â† 0 ‚áí nsum s f MOD n = nsum s (Œªi. f i MOD n) MOD n
   
   [<a name="MOD_NSUM_MOD_NUMSEG-val"><b>MOD_NSUM_MOD_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf a b n.
          n ‚â† 0 ‚áí
          nsum {a .. b} f MOD n = nsum {a .. b} (Œªi. f i MOD n) MOD n
   
   [<a name="MONOIDAL_AC-val"><b>MONOIDAL_AC</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop.
          monoidal op ‚áí
          (‚àÄa. op (neutral op) a = a) ‚àß (‚àÄa. op a (neutral op) = a) ‚àß
          (‚àÄa b. op a b = op b a) ‚àß
          (‚àÄa b c. op (op a b) c = op a (op b c)) ‚àß
          ‚àÄa b c. op a (op b c) = op b (op a c)
   
   [<a name="MONOIDAL_ADD-val"><b>MONOIDAL_ADD</b></a>]  Theorem
      
      ‚ä¢ monoidal $+
   
   [<a name="MONOIDAL_AND-val"><b>MONOIDAL_AND</b></a>]  Theorem
      
      ‚ä¢ monoidal $/\
   
   [<a name="MONOIDAL_LIFTED-val"><b>MONOIDAL_LIFTED</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop. monoidal op ‚áí monoidal (lifted op)
   
   [<a name="MONOIDAL_MUL-val"><b>MONOIDAL_MUL</b></a>]  Theorem
      
      ‚ä¢ monoidal $*
   
   [<a name="NEUTRAL_ADD-val"><b>NEUTRAL_ADD</b></a>]  Theorem
      
      ‚ä¢ neutral $+ = 0
   
   [<a name="NEUTRAL_AND-val"><b>NEUTRAL_AND</b></a>]  Theorem
      
      ‚ä¢ neutral $/\ ‚áî T
   
   [<a name="NEUTRAL_LIFTED-val"><b>NEUTRAL_LIFTED</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop. monoidal op ‚áí neutral (lifted op) = SOME (neutral op)
   
   [<a name="NEUTRAL_MUL-val"><b>NEUTRAL_MUL</b></a>]  Theorem
      
      ‚ä¢ neutral $* = 1
   
   [<a name="NOT_EQ-val"><b>NOT_EQ</b></a>]  Theorem
      
      ‚ä¢ ‚àÄa b. a ‚â† b ‚áî a ‚â† b
   
   [<a name="NPRODUCT_ADD_SPLIT-val"><b>NPRODUCT_ADD_SPLIT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf m n p.
          m ‚â§ n + 1 ‚áí
          nproduct {m .. n + p} f =
          nproduct {m .. n} f * nproduct {n + 1 .. n + p} f
   
   [<a name="NPRODUCT_CLAUSES-val"><b>NPRODUCT_CLAUSES</b></a>]  Theorem
      
      ‚ä¢ (‚àÄf. nproduct ‚àÖ f = 1) ‚àß
        ‚àÄx f s.
          FINITE s ‚áí
          nproduct (x INSERT s) f =
          if x ‚àà s then nproduct s f else f x * nproduct s f
   
   [<a name="NPRODUCT_CLAUSES_LEFT-val"><b>NPRODUCT_CLAUSES_LEFT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf m n. m ‚â§ n ‚áí nproduct {m .. n} f = f m * nproduct {m + 1 .. n} f
   
   [<a name="NPRODUCT_CLAUSES_NUMSEG-val"><b>NPRODUCT_CLAUSES_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ (‚àÄm. nproduct {m .. 0} f = if m = 0 then f 0 else 1) ‚àß
        ‚àÄm n.
          nproduct {m .. SUC n} f =
          if m ‚â§ SUC n then nproduct {m .. n} f * f (SUC n)
          else nproduct {m .. n} f
   
   [<a name="NPRODUCT_CLAUSES_RIGHT-val"><b>NPRODUCT_CLAUSES_RIGHT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf m n.
          0 &lt; n ‚àß m ‚â§ n ‚áí
          nproduct {m .. n} f = nproduct {m .. n ‚àí 1} f * f n
   
   [<a name="NPRODUCT_CLOSED-val"><b>NPRODUCT_CLOSED</b></a>]  Theorem
      
      ‚ä¢ ‚àÄP f s.
          P 1 ‚àß (‚àÄx y. P x ‚àß P y ‚áí P (x * y)) ‚àß (‚àÄa. a ‚àà s ‚áí P (f a)) ‚áí
          P (nproduct s f)
   
   [<a name="NPRODUCT_CONG-val"><b>NPRODUCT_CONG</b></a>]  Theorem
      
      ‚ä¢ (‚àÄf g s.
           (‚àÄx. x ‚àà s ‚áí f x = g x) ‚áí nproduct s (Œªi. f i) = nproduct s g) ‚àß
        (‚àÄf g a b.
           (‚àÄi. a ‚â§ i ‚àß i ‚â§ b ‚áí f i = g i) ‚áí
           nproduct {a .. b} (Œªi. f i) = nproduct {a .. b} g) ‚àß
        ‚àÄf g p.
          (‚àÄx. p x ‚áí f x = g x) ‚áí
          nproduct {y | p y} (Œªi. f i) = nproduct {y | p y} g
   
   [<a name="NPRODUCT_CONST-val"><b>NPRODUCT_CONST</b></a>]  Theorem
      
      ‚ä¢ ‚àÄc s. FINITE s ‚áí nproduct s (Œªx. c) = c ** CARD s
   
   [<a name="NPRODUCT_CONST_NUMSEG-val"><b>NPRODUCT_CONST_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄc m n. nproduct {m .. n} (Œªx. c) = c ** (n + 1 ‚àí m)
   
   [<a name="NPRODUCT_CONST_NUMSEG_1-val"><b>NPRODUCT_CONST_NUMSEG_1</b></a>]  Theorem
      
      ‚ä¢ ‚àÄc n. nproduct {1 .. n} (Œªx. c) = c ** n
   
   [<a name="NPRODUCT_DELETE-val"><b>NPRODUCT_DELETE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf s a.
          FINITE s ‚àß a ‚àà s ‚áí f a * nproduct (s DELETE a) f = nproduct s f
   
   [<a name="NPRODUCT_DELTA-val"><b>NPRODUCT_DELTA</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs a.
          nproduct s (Œªx. if x = a then b else 1) = if a ‚àà s then b else 1
   
   [<a name="NPRODUCT_EQ-val"><b>NPRODUCT_EQ</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g s. (‚àÄx. x ‚àà s ‚áí f x = g x) ‚áí nproduct s f = nproduct s g
   
   [<a name="NPRODUCT_EQ_0-val"><b>NPRODUCT_EQ_0</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf s. FINITE s ‚áí (nproduct s f = 0 ‚áî ‚àÉx. x ‚àà s ‚àß f x = 0)
   
   [<a name="NPRODUCT_EQ_0_NUMSEG-val"><b>NPRODUCT_EQ_0_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf m n. nproduct {m .. n} f = 0 ‚áî ‚àÉx. m ‚â§ x ‚àß x ‚â§ n ‚àß f x = 0
   
   [<a name="NPRODUCT_EQ_1-val"><b>NPRODUCT_EQ_1</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf s. (‚àÄx. x ‚àà s ‚áí f x = 1) ‚áí nproduct s f = 1
   
   [<a name="NPRODUCT_EQ_1_NUMSEG-val"><b>NPRODUCT_EQ_1_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf m n. (‚àÄi. m ‚â§ i ‚àß i ‚â§ n ‚áí f i = 1) ‚áí nproduct {m .. n} f = 1
   
   [<a name="NPRODUCT_EQ_NUMSEG-val"><b>NPRODUCT_EQ_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g m n.
          (‚àÄi. m ‚â§ i ‚àß i ‚â§ n ‚áí f i = g i) ‚áí
          nproduct {m .. n} f = nproduct {m .. n} g
   
   [<a name="NPRODUCT_FACT-val"><b>NPRODUCT_FACT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. nproduct {1 .. n} (Œªm. m) = FACT n
   
   [<a name="NPRODUCT_IMAGE-val"><b>NPRODUCT_IMAGE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g s.
          (‚àÄx y. x ‚àà s ‚àß y ‚àà s ‚àß f x = f y ‚áí x = y) ‚áí
          nproduct (IMAGE f s) g = nproduct s (g ‚àò f)
   
   [<a name="NPRODUCT_LE-val"><b>NPRODUCT_LE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf s.
          FINITE s ‚àß (‚àÄx. x ‚àà s ‚áí 0 ‚â§ f x ‚àß f x ‚â§ g x) ‚áí
          nproduct s f ‚â§ nproduct s g
   
   [<a name="NPRODUCT_LE_NUMSEG-val"><b>NPRODUCT_LE_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf m n.
          (‚àÄi. m ‚â§ i ‚àß i ‚â§ n ‚áí 0 ‚â§ f i ‚àß f i ‚â§ g i) ‚áí
          nproduct {m .. n} f ‚â§ nproduct {m .. n} g
   
   [<a name="NPRODUCT_MUL-val"><b>NPRODUCT_MUL</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g s.
          FINITE s ‚áí
          nproduct s (Œªx. f x * g x) = nproduct s f * nproduct s g
   
   [<a name="NPRODUCT_MUL_GEN-val"><b>NPRODUCT_MUL_GEN</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g s.
          FINITE {x | x ‚àà s ‚àß f x ‚â† 1} ‚àß FINITE {x | x ‚àà s ‚àß g x ‚â† 1} ‚áí
          nproduct s (Œªx. f x * g x) = nproduct s f * nproduct s g
   
   [<a name="NPRODUCT_MUL_NUMSEG-val"><b>NPRODUCT_MUL_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g m n.
          nproduct {m .. n} (Œªx. f x * g x) =
          nproduct {m .. n} f * nproduct {m .. n} g
   
   [<a name="NPRODUCT_OFFSET-val"><b>NPRODUCT_OFFSET</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf m p.
          nproduct {m + p .. n + p} f = nproduct {m .. n} (Œªi. f (i + p))
   
   [<a name="NPRODUCT_ONE-val"><b>NPRODUCT_ONE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs. nproduct s (Œªn. 1) = 1
   
   [<a name="NPRODUCT_PAIR-val"><b>NPRODUCT_PAIR</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf m n.
          nproduct {2 * m .. 2 * n + 1} f =
          nproduct {m .. n} (Œªi. f (2 * i) * f (2 * i + 1))
   
   [<a name="NPRODUCT_POS_LT-val"><b>NPRODUCT_POS_LT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf s. FINITE s ‚àß (‚àÄx. x ‚àà s ‚áí 0 &lt; f x) ‚áí 0 &lt; nproduct s f
   
   [<a name="NPRODUCT_POS_LT_NUMSEG-val"><b>NPRODUCT_POS_LT_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf m n. (‚àÄx. m ‚â§ x ‚àß x ‚â§ n ‚áí 0 &lt; f x) ‚áí 0 &lt; nproduct {m .. n} f
   
   [<a name="NPRODUCT_SING-val"><b>NPRODUCT_SING</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf x. nproduct {x} f = f x
   
   [<a name="NPRODUCT_SING_NUMSEG-val"><b>NPRODUCT_SING_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf n. nproduct {n .. n} f = f n
   
   [<a name="NPRODUCT_SUPERSET-val"><b>NPRODUCT_SUPERSET</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf u v.
          u ‚äÜ v ‚àß (‚àÄx. x ‚àà v ‚àß x ‚àâ u ‚áí f x = 1) ‚áí
          nproduct v f = nproduct u f
   
   [<a name="NPRODUCT_SUPPORT-val"><b>NPRODUCT_SUPPORT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf s. nproduct (support $* f s) f = nproduct s f
   
   [<a name="NPRODUCT_UNION-val"><b>NPRODUCT_UNION</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf s t.
          FINITE s ‚àß FINITE t ‚àß DISJOINT s t ‚áí
          nproduct (s ‚à™ t) f = nproduct s f * nproduct t f
   
   [<a name="NSUM_0-val"><b>NSUM_0</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs. nsum s (Œªn. 0) = 0
   
   [<a name="NSUM_ADD-val"><b>NSUM_ADD</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g s. FINITE s ‚áí nsum s (Œªx. f x + g x) = nsum s f + nsum s g
   
   [<a name="NSUM_ADD_GEN-val"><b>NSUM_ADD_GEN</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g s.
          FINITE {x | x ‚àà s ‚àß f x ‚â† 0} ‚àß FINITE {x | x ‚àà s ‚àß g x ‚â† 0} ‚áí
          nsum s (Œªx. f x + g x) = nsum s f + nsum s g
   
   [<a name="NSUM_ADD_NUMSEG-val"><b>NSUM_ADD_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g m n.
          nsum {m .. n} (Œªi. f i + g i) = nsum {m .. n} f + nsum {m .. n} g
   
   [<a name="NSUM_ADD_SPLIT-val"><b>NSUM_ADD_SPLIT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf m n p.
          m ‚â§ n + 1 ‚áí
          nsum {m .. n + p} f = nsum {m .. n} f + nsum {n + 1 .. n + p} f
   
   [<a name="NSUM_BIGUNION_NONZERO-val"><b>NSUM_BIGUNION_NONZERO</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf s.
          FINITE s ‚àß (‚àÄt. t ‚àà s ‚áí FINITE t) ‚àß
          (‚àÄt1 t2 x. t1 ‚àà s ‚àß t2 ‚àà s ‚àß t1 ‚â† t2 ‚àß x ‚àà t1 ‚àß x ‚àà t2 ‚áí f x = 0) ‚áí
          nsum (BIGUNION s) f = nsum s (Œªt. nsum t f)
   
   [<a name="NSUM_BIJECTION-val"><b>NSUM_BIJECTION</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf p s.
          (‚àÄx. x ‚àà s ‚áí p x ‚àà s) ‚àß (‚àÄy. y ‚àà s ‚áí ‚àÉ!x. x ‚àà s ‚àß p x = y) ‚áí
          nsum s f = nsum s (f ‚àò p)
   
   [<a name="NSUM_BOUND-val"><b>NSUM_BOUND</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs f b. FINITE s ‚àß (‚àÄx. x ‚àà s ‚áí f x ‚â§ b) ‚áí nsum s f ‚â§ CARD s * b
   
   [<a name="NSUM_BOUND_GEN-val"><b>NSUM_BOUND_GEN</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs f b.
          FINITE s ‚àß s ‚â† ‚àÖ ‚àß (‚àÄx. x ‚àà s ‚áí f x ‚â§ b DIV CARD s) ‚áí
          nsum s f ‚â§ b
   
   [<a name="NSUM_BOUND_LT-val"><b>NSUM_BOUND_LT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs f b.
          FINITE s ‚àß (‚àÄx. x ‚àà s ‚áí f x ‚â§ b) ‚àß (‚àÉx. x ‚àà s ‚àß f x &lt; b) ‚áí
          nsum s f &lt; CARD s * b
   
   [<a name="NSUM_BOUND_LT_ALL-val"><b>NSUM_BOUND_LT_ALL</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs f b.
          FINITE s ‚àß s ‚â† ‚àÖ ‚àß (‚àÄx. x ‚àà s ‚áí f x &lt; b) ‚áí nsum s f &lt; CARD s * b
   
   [<a name="NSUM_BOUND_LT_GEN-val"><b>NSUM_BOUND_LT_GEN</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs f b.
          FINITE s ‚àß s ‚â† ‚àÖ ‚àß (‚àÄx. x ‚àà s ‚áí f x &lt; b DIV CARD s) ‚áí
          nsum s f &lt; b
   
   [<a name="NSUM_CASES-val"><b>NSUM_CASES</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs P f g.
          FINITE s ‚áí
          nsum s (Œªx. if P x then f x else g x) =
          nsum {x | x ‚àà s ‚àß P x} f + nsum {x | x ‚àà s ‚àß ¬¨P x} g
   
   [<a name="NSUM_CLAUSES-val"><b>NSUM_CLAUSES</b></a>]  Theorem
      
      ‚ä¢ (‚àÄf. nsum ‚àÖ f = 0) ‚àß
        ‚àÄx f s.
          FINITE s ‚áí
          nsum (x INSERT s) f = if x ‚àà s then nsum s f else f x + nsum s f
   
   [<a name="NSUM_CLAUSES_LEFT-val"><b>NSUM_CLAUSES_LEFT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf m n. m ‚â§ n ‚áí nsum {m .. n} f = f m + nsum {m + 1 .. n} f
   
   [<a name="NSUM_CLAUSES_NUMSEG-val"><b>NSUM_CLAUSES_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ (‚àÄm. nsum {m .. 0} f = if m = 0 then f 0 else 0) ‚àß
        ‚àÄm n.
          nsum {m .. SUC n} f =
          if m ‚â§ SUC n then nsum {m .. n} f + f (SUC n)
          else nsum {m .. n} f
   
   [<a name="NSUM_CLAUSES_RIGHT-val"><b>NSUM_CLAUSES_RIGHT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf m n. 0 &lt; n ‚àß m ‚â§ n ‚áí nsum {m .. n} f = nsum {m .. n ‚àí 1} f + f n
   
   [<a name="NSUM_CLOSED-val"><b>NSUM_CLOSED</b></a>]  Theorem
      
      ‚ä¢ ‚àÄP f s.
          P 0 ‚àß (‚àÄx y. P x ‚àß P y ‚áí P (x + y)) ‚àß (‚àÄa. a ‚àà s ‚áí P (f a)) ‚áí
          P (nsum s f)
   
   [<a name="NSUM_CONG-val"><b>NSUM_CONG</b></a>]  Theorem
      
      ‚ä¢ (‚àÄf g s. (‚àÄx. x ‚àà s ‚áí f x = g x) ‚áí nsum s (Œªi. f i) = nsum s g) ‚àß
        (‚àÄf g a b.
           (‚àÄi. a ‚â§ i ‚àß i ‚â§ b ‚áí f i = g i) ‚áí
           nsum {a .. b} (Œªi. f i) = nsum {a .. b} g) ‚àß
        ‚àÄf g p.
          (‚àÄx. p x ‚áí f x = g x) ‚áí
          nsum {y | p y} (Œªi. f i) = nsum {y | p y} g
   
   [<a name="NSUM_CONST-val"><b>NSUM_CONST</b></a>]  Theorem
      
      ‚ä¢ ‚àÄc s. FINITE s ‚áí nsum s (Œªn. c) = CARD s * c
   
   [<a name="NSUM_CONST_NUMSEG-val"><b>NSUM_CONST_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄc m n. nsum {m .. n} (Œªn. c) = (n + 1 ‚àí m) * c
   
   [<a name="NSUM_DEGENERATE-val"><b>NSUM_DEGENERATE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf s. INFINITE {x | x ‚àà s ‚àß f x ‚â† 0} ‚áí nsum s f = 0
   
   [<a name="NSUM_DELETE-val"><b>NSUM_DELETE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf s a. FINITE s ‚àß a ‚àà s ‚áí f a + nsum (s DELETE a) f = nsum s f
   
   [<a name="NSUM_DELTA-val"><b>NSUM_DELTA</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs a. nsum s (Œªx. if x = a then b else 0) = if a ‚àà s then b else 0
   
   [<a name="NSUM_DIFF-val"><b>NSUM_DIFF</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf s t. FINITE s ‚àß t ‚äÜ s ‚áí nsum (s DIFF t) f = nsum s f ‚àí nsum t f
   
   [<a name="NSUM_EQ-val"><b>NSUM_EQ</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g s. (‚àÄx. x ‚àà s ‚áí f x = g x) ‚áí nsum s f = nsum s g
   
   [<a name="NSUM_EQ_0-val"><b>NSUM_EQ_0</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf s. (‚àÄx. x ‚àà s ‚áí f x = 0) ‚áí nsum s f = 0
   
   [<a name="NSUM_EQ_0_IFF-val"><b>NSUM_EQ_0_IFF</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs. FINITE s ‚áí (nsum s f = 0 ‚áî ‚àÄx. x ‚àà s ‚áí f x = 0)
   
   [<a name="NSUM_EQ_0_IFF_NUMSEG-val"><b>NSUM_EQ_0_IFF_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf m n. nsum {m .. n} f = 0 ‚áî ‚àÄi. m ‚â§ i ‚àß i ‚â§ n ‚áí f i = 0
   
   [<a name="NSUM_EQ_0_NUMSEG-val"><b>NSUM_EQ_0_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf m n. (‚àÄi. m ‚â§ i ‚àß i ‚â§ n ‚áí f i = 0) ‚áí nsum {m .. n} f = 0
   
   [<a name="NSUM_EQ_GENERAL-val"><b>NSUM_EQ_GENERAL</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs t f g h.
          (‚àÄy. y ‚àà t ‚áí ‚àÉ!x. x ‚àà s ‚àß h x = y) ‚àß
          (‚àÄx. x ‚àà s ‚áí h x ‚àà t ‚àß g (h x) = f x) ‚áí
          nsum s f = nsum t g
   
   [<a name="NSUM_EQ_GENERAL_INVERSES-val"><b>NSUM_EQ_GENERAL_INVERSES</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs t f g h k.
          (‚àÄy. y ‚àà t ‚áí k y ‚àà s ‚àß h (k y) = y) ‚àß
          (‚àÄx. x ‚àà s ‚áí h x ‚àà t ‚àß k (h x) = x ‚àß g (h x) = f x) ‚áí
          nsum s f = nsum t g
   
   [<a name="NSUM_EQ_NUMSEG-val"><b>NSUM_EQ_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g m n.
          (‚àÄi. m ‚â§ i ‚àß i ‚â§ n ‚áí f i = g i) ‚áí
          nsum {m .. n} f = nsum {m .. n} g
   
   [<a name="NSUM_EQ_SUPERSET-val"><b>NSUM_EQ_SUPERSET</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf s t.
          FINITE t ‚àß t ‚äÜ s ‚àß (‚àÄx. x ‚àà t ‚áí f x = g x) ‚àß
          (‚àÄx. x ‚àà s ‚àß x ‚àâ t ‚áí f x = 0) ‚áí
          nsum s f = nsum t g
   
   [<a name="NSUM_GROUP-val"><b>NSUM_GROUP</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g s t.
          FINITE s ‚àß IMAGE f s ‚äÜ t ‚áí
          nsum t (Œªy. nsum {x | x ‚àà s ‚àß f x = y} g) = nsum s g
   
   [<a name="NSUM_IMAGE-val"><b>NSUM_IMAGE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g s.
          (‚àÄx y. x ‚àà s ‚àß y ‚àà s ‚àß f x = f y ‚áí x = y) ‚áí
          nsum (IMAGE f s) g = nsum s (g ‚àò f)
   
   [<a name="NSUM_IMAGE_GEN-val"><b>NSUM_IMAGE_GEN</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g s.
          FINITE s ‚áí
          nsum s g = nsum (IMAGE f s) (Œªy. nsum {x | x ‚àà s ‚àß f x = y} g)
   
   [<a name="NSUM_IMAGE_NONZERO-val"><b>NSUM_IMAGE_NONZERO</b></a>]  Theorem
      
      ‚ä¢ ‚àÄd i s.
          FINITE s ‚àß
          (‚àÄx y. x ‚àà s ‚àß y ‚àà s ‚àß x ‚â† y ‚àß i x = i y ‚áí d (i x) = 0) ‚áí
          nsum (IMAGE i s) d = nsum s (d ‚àò i)
   
   [<a name="NSUM_INCL_EXCL-val"><b>NSUM_INCL_EXCL</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs t f.
          FINITE s ‚àß FINITE t ‚áí
          nsum s f + nsum t f = nsum (s ‚à™ t) f + nsum (s ‚à© t) f
   
   [<a name="NSUM_INJECTION-val"><b>NSUM_INJECTION</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf p s.
          FINITE s ‚àß (‚àÄx. x ‚àà s ‚áí p x ‚àà s) ‚àß
          (‚àÄx y. x ‚àà s ‚àß y ‚àà s ‚àß p x = p y ‚áí x = y) ‚áí
          nsum s (f ‚àò p) = nsum s f
   
   [<a name="NSUM_LE-val"><b>NSUM_LE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g s. FINITE s ‚àß (‚àÄx. x ‚àà s ‚áí f x ‚â§ g x) ‚áí nsum s f ‚â§ nsum s g
   
   [<a name="NSUM_LE_GEN-val"><b>NSUM_LE_GEN</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g s.
          (‚àÄx. x ‚àà s ‚áí f x ‚â§ g x) ‚àß FINITE {x | x ‚àà s ‚àß g x ‚â† 0} ‚áí
          nsum s f ‚â§ nsum s g
   
   [<a name="NSUM_LE_NUMSEG-val"><b>NSUM_LE_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g m n.
          (‚àÄi. m ‚â§ i ‚àß i ‚â§ n ‚áí f i ‚â§ g i) ‚áí
          nsum {m .. n} f ‚â§ nsum {m .. n} g
   
   [<a name="NSUM_LMUL-val"><b>NSUM_LMUL</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf c s. nsum s (Œªx. c * f x) = c * nsum s f
   
   [<a name="NSUM_LT-val"><b>NSUM_LT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g s.
          FINITE s ‚àß (‚àÄx. x ‚àà s ‚áí f x ‚â§ g x) ‚àß (‚àÉx. x ‚àà s ‚àß f x &lt; g x) ‚áí
          nsum s f &lt; nsum s g
   
   [<a name="NSUM_LT_ALL-val"><b>NSUM_LT_ALL</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g s.
          FINITE s ‚àß s ‚â† ‚àÖ ‚àß (‚àÄx. x ‚àà s ‚áí f x &lt; g x) ‚áí nsum s f &lt; nsum s g
   
   [<a name="NSUM_MULTICOUNT-val"><b>NSUM_MULTICOUNT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄR s t k.
          FINITE s ‚àß FINITE t ‚àß (‚àÄj. j ‚àà t ‚áí CARD {i | i ‚àà s ‚àß R i j} = k) ‚áí
          nsum s (Œªi. CARD (equiv_class R t i)) = k * CARD t
   
   [<a name="NSUM_MULTICOUNT_GEN-val"><b>NSUM_MULTICOUNT_GEN</b></a>]  Theorem
      
      ‚ä¢ ‚àÄR s t k.
          FINITE s ‚àß FINITE t ‚àß
          (‚àÄj. j ‚àà t ‚áí CARD {i | i ‚àà s ‚àß R i j} = k j) ‚áí
          nsum s (Œªi. CARD (equiv_class R t i)) = nsum t (Œªi. k i)
   
   [<a name="NSUM_NSUM_PRODUCT-val"><b>NSUM_NSUM_PRODUCT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs t x.
          FINITE s ‚àß (‚àÄi. i ‚àà s ‚áí FINITE (t i)) ‚áí
          nsum s (Œªi. nsum (t i) (x i)) =
          nsum {(i,j) | i ‚àà s ‚àß j ‚àà t i} (Œª(i,j). x i j)
   
   [<a name="NSUM_NSUM_RESTRICT-val"><b>NSUM_NSUM_RESTRICT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄR f s t.
          FINITE s ‚àß FINITE t ‚áí
          nsum s (Œªx. nsum (equiv_class R t x) (Œªy. f x y)) =
          nsum t (Œªy. nsum {x | x ‚àà s ‚àß R x y} (Œªx. f x y))
   
   [<a name="NSUM_OFFSET-val"><b>NSUM_OFFSET</b></a>]  Theorem
      
      ‚ä¢ ‚àÄp f m n. nsum {m + p .. n + p} f = nsum {m .. n} (Œªi. f (i + p))
   
   [<a name="NSUM_OFFSET_0-val"><b>NSUM_OFFSET_0</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf m n. m ‚â§ n ‚áí nsum {m .. n} f = nsum {0 .. n ‚àí m} (Œªi. f (i + m))
   
   [<a name="NSUM_PAIR-val"><b>NSUM_PAIR</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf m n.
          nsum {2 * m .. 2 * n + 1} f =
          nsum {m .. n} (Œªi. f (2 * i) + f (2 * i + 1))
   
   [<a name="NSUM_PERMUTE-val"><b>NSUM_PERMUTE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf p s. p permutes s ‚áí nsum s f = nsum s (f ‚àò p)
   
   [<a name="NSUM_PERMUTE_COUNT-val"><b>NSUM_PERMUTE_COUNT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf p n.
          p permutes count n ‚áí nsum (count n) f = nsum (count n) (f ‚àò p)
   
   [<a name="NSUM_PERMUTE_NUMSEG-val"><b>NSUM_PERMUTE_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf p m n.
          p permutes count n DIFF count m ‚áí
          nsum (count n DIFF count m) f =
          nsum (count n DIFF count m) (f ‚àò p)
   
   [<a name="NSUM_POS_BOUND-val"><b>NSUM_POS_BOUND</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf b s. FINITE s ‚àß nsum s f ‚â§ b ‚áí ‚àÄx. x ‚àà s ‚áí f x ‚â§ b
   
   [<a name="NSUM_POS_LT-val"><b>NSUM_POS_LT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf s. FINITE s ‚àß (‚àÉx. x ‚àà s ‚àß 0 &lt; f x) ‚áí 0 &lt; nsum s f
   
   [<a name="NSUM_POS_LT_ALL-val"><b>NSUM_POS_LT_ALL</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs f. FINITE s ‚àß s ‚â† ‚àÖ ‚àß (‚àÄi. i ‚àà s ‚áí 0 &lt; f i) ‚áí 0 &lt; nsum s f
   
   [<a name="NSUM_RESTRICT-val"><b>NSUM_RESTRICT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf s. FINITE s ‚áí nsum s (Œªx. if x ‚àà s then f x else 0) = nsum s f
   
   [<a name="NSUM_RESTRICT_SET-val"><b>NSUM_RESTRICT_SET</b></a>]  Theorem
      
      ‚ä¢ ‚àÄP s f.
          nsum {x | x ‚àà s ‚àß P x} f = nsum s (Œªx. if P x then f x else 0)
   
   [<a name="NSUM_RMUL-val"><b>NSUM_RMUL</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf c s. nsum s (Œªx. f x * c) = nsum s f * c
   
   [<a name="NSUM_SING-val"><b>NSUM_SING</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf x. nsum {x} f = f x
   
   [<a name="NSUM_SING_NUMSEG-val"><b>NSUM_SING_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf n. nsum {n .. n} f = f n
   
   [<a name="NSUM_SUBSET-val"><b>NSUM_SUBSET</b></a>]  Theorem
      
      ‚ä¢ ‚àÄu v f.
          FINITE u ‚àß FINITE v ‚àß (‚àÄx. x ‚àà u DIFF v ‚áí f x = 0) ‚áí
          nsum u f ‚â§ nsum v f
   
   [<a name="NSUM_SUBSET_SIMPLE-val"><b>NSUM_SUBSET_SIMPLE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄu v f. FINITE v ‚àß u ‚äÜ v ‚áí nsum u f ‚â§ nsum v f
   
   [<a name="NSUM_SUPERSET-val"><b>NSUM_SUPERSET</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf u v. u ‚äÜ v ‚àß (‚àÄx. x ‚àà v ‚àß x ‚àâ u ‚áí f x = 0) ‚áí nsum v f = nsum u f
   
   [<a name="NSUM_SUPPORT-val"><b>NSUM_SUPPORT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf s. nsum (support $+ f s) f = nsum s f
   
   [<a name="NSUM_SWAP-val"><b>NSUM_SWAP</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf s t.
          FINITE s ‚àß FINITE t ‚áí
          nsum s (Œªi. nsum t (f i)) = nsum t (Œªj. nsum s (Œªi. f i j))
   
   [<a name="NSUM_SWAP_NUMSEG-val"><b>NSUM_SWAP_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄa b c d f.
          nsum {a .. b} (Œªi. nsum {c .. d} (f i)) =
          nsum {c .. d} (Œªj. nsum {a .. b} (Œªi. f i j))
   
   [<a name="NSUM_TRIV_NUMSEG-val"><b>NSUM_TRIV_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf m n. n &lt; m ‚áí nsum {m .. n} f = 0
   
   [<a name="NSUM_UNION-val"><b>NSUM_UNION</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf s t.
          FINITE s ‚àß FINITE t ‚àß DISJOINT s t ‚áí
          nsum (s ‚à™ t) f = nsum s f + nsum t f
   
   [<a name="NSUM_UNION_EQ-val"><b>NSUM_UNION_EQ</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs t u.
          FINITE u ‚àß s ‚à© t = ‚àÖ ‚àß s ‚à™ t = u ‚áí nsum s f + nsum t f = nsum u f
   
   [<a name="NSUM_UNION_LZERO-val"><b>NSUM_UNION_LZERO</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf u v.
          FINITE v ‚àß (‚àÄx. x ‚àà u ‚àß x ‚àâ v ‚áí f x = 0) ‚áí
          nsum (u ‚à™ v) f = nsum v f
   
   [<a name="NSUM_UNION_NONZERO-val"><b>NSUM_UNION_NONZERO</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf s t.
          FINITE s ‚àß FINITE t ‚àß (‚àÄx. x ‚àà s ‚à© t ‚áí f x = 0) ‚áí
          nsum (s ‚à™ t) f = nsum s f + nsum t f
   
   [<a name="NSUM_UNION_RZERO-val"><b>NSUM_UNION_RZERO</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf u v.
          FINITE u ‚àß (‚àÄx. x ‚àà v ‚àß x ‚àâ u ‚áí f x = 0) ‚áí
          nsum (u ‚à™ v) f = nsum u f
   
   [<a name="NUMSEG_ADD_SPLIT-val"><b>NUMSEG_ADD_SPLIT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm n p. m ‚â§ n + 1 ‚áí {m .. n + p} = {m .. n} ‚à™ {n + 1 .. n + p}
   
   [<a name="NUMSEG_CLAUSES-val"><b>NUMSEG_CLAUSES</b></a>]  Theorem
      
      ‚ä¢ (‚àÄm. {m .. 0} = if m = 0 then {0} else ‚àÖ) ‚àß
        ‚àÄm n.
          {m .. SUC n} =
          if m ‚â§ SUC n then SUC n INSERT {m .. n} else {m .. n}
   
   [<a name="NUMSEG_COMBINE_L-val"><b>NUMSEG_COMBINE_L</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm p n. m ‚â§ p ‚àß p ‚â§ n + 1 ‚áí {m .. p ‚àí 1} ‚à™ {p .. n} = {m .. n}
   
   [<a name="NUMSEG_COMBINE_R-val"><b>NUMSEG_COMBINE_R</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm p n. m ‚â§ p + 1 ‚àß p ‚â§ n ‚áí {m .. p} ‚à™ {p + 1 .. n} = {m .. n}
   
   [<a name="NUMSEG_EMPTY-val"><b>NUMSEG_EMPTY</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm n. {m .. n} = ‚àÖ ‚áî n &lt; m
   
   [<a name="NUMSEG_LE-val"><b>NUMSEG_LE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. {x | x ‚â§ n} = {0 .. n}
   
   [<a name="NUMSEG_LREC-val"><b>NUMSEG_LREC</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm n. m ‚â§ n ‚áí m INSERT {m + 1 .. n} = {m .. n}
   
   [<a name="NUMSEG_LT-val"><b>NUMSEG_LT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. {x | x &lt; n} = if n = 0 then ‚àÖ else {0 .. n ‚àí 1}
   
   [<a name="NUMSEG_OFFSET_IMAGE-val"><b>NUMSEG_OFFSET_IMAGE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm n p. {m + p .. n + p} = IMAGE (Œªi. i + p) {m .. n}
   
   [<a name="NUMSEG_REC-val"><b>NUMSEG_REC</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm n. m ‚â§ SUC n ‚áí {m .. SUC n} = SUC n INSERT {m .. n}
   
   [<a name="NUMSEG_RREC-val"><b>NUMSEG_RREC</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm n. m ‚â§ n ‚áí n INSERT {m .. n ‚àí 1} = {m .. n}
   
   [<a name="NUMSEG_SING-val"><b>NUMSEG_SING</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. {n .. n} = {n}
   
   [<a name="POWERSET_CLAUSES-val"><b>POWERSET_CLAUSES</b></a>]  Theorem
      
      ‚ä¢ {s | s ‚äÜ ‚àÖ} = {‚àÖ} ‚àß
        ‚àÄa t.
          {s | s ‚äÜ a INSERT t} =
          {s | s ‚äÜ t} ‚à™ IMAGE (Œªs. a INSERT s) {s | s ‚äÜ t}
   
   [<a name="SET_PROVE_CASES-val"><b>SET_PROVE_CASES</b></a>]  Theorem
      
      ‚ä¢ ‚àÄP. P ‚àÖ ‚àß (‚àÄa s. a ‚àâ s ‚áí P (a INSERT s)) ‚áí ‚àÄs. P s
   
   [<a name="SET_RECURSION_LEMMA-val"><b>SET_RECURSION_LEMMA</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf b.
          (‚àÄx y s. x ‚â† y ‚áí f x (f y s) = f y (f x s)) ‚áí
          ‚àÉg. g ‚àÖ = b ‚àß
              ‚àÄx s.
                FINITE s ‚áí
                g (x INSERT s) = if x ‚àà s then g s else f x (g s)
   
   [<a name="SIMPLE_IMAGE_GEN-val"><b>SIMPLE_IMAGE_GEN</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf P. {f x | P x} = IMAGE f {x | P x}
   
   [<a name="SUBSET_NUMSEG-val"><b>SUBSET_NUMSEG</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm n p q. {m .. n} ‚äÜ {p .. q} ‚áî n &lt; m ‚à® p ‚â§ m ‚àß n ‚â§ q
   
   [<a name="SUBSET_RESTRICT-val"><b>SUBSET_RESTRICT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs P. {x | x ‚àà s ‚àß P x} ‚äÜ s
   
   [<a name="SUPPORT_CLAUSES-val"><b>SUPPORT_CLAUSES</b></a>]  Theorem
      
      ‚ä¢ (‚àÄf. support op f ‚àÖ = ‚àÖ) ‚àß
        (‚àÄf x s.
           support op f (x INSERT s) =
           if f x = neutral op then support op f s
           else x INSERT support op f s) ‚àß
        (‚àÄf x s. support op f (s DELETE x) = support op f s DELETE x) ‚àß
        (‚àÄf s t. support op f (s ‚à™ t) = support op f s ‚à™ support op f t) ‚àß
        (‚àÄf s t. support op f (s ‚à© t) = support op f s ‚à© support op f t) ‚àß
        (‚àÄf s t.
           support op f (s DIFF t) = support op f s DIFF support op f t) ‚àß
        ‚àÄf g s. support op g (IMAGE f s) = IMAGE f (support op (g ‚àò f) s)
   
   [<a name="SUPPORT_DELTA-val"><b>SUPPORT_DELTA</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop s f a.
          support op (Œªx. if x = a then f x else neutral op) s =
          if a ‚àà s then support op f {a} else ‚àÖ
   
   [<a name="SUPPORT_EMPTY-val"><b>SUPPORT_EMPTY</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop f s. (‚àÄx. x ‚àà s ‚áí f x = neutral op) ‚áî support op f s = ‚àÖ
   
   [<a name="SUPPORT_SUBSET-val"><b>SUPPORT_SUBSET</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop f s. support op f s ‚äÜ s
   
   [<a name="SUPPORT_SUPPORT-val"><b>SUPPORT_SUPPORT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄop f s. support op f (support op f s) = support op f s
   
   [<a name="TOPOLOGICAL_SORT-val"><b>TOPOLOGICAL_SORT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄ $&lt;&lt;.
          (‚àÄx y. x &lt;&lt; y ‚àß y &lt;&lt; x ‚áí x = y) ‚àß
          (‚àÄx y z. x &lt;&lt; y ‚àß y &lt;&lt; z ‚áí x &lt;&lt; z) ‚áí
          ‚àÄn s.
            s HAS_SIZE n ‚áí
            ‚àÉf. s = IMAGE f {1 .. n} ‚àß
                ‚àÄj k. j ‚àà {1 .. n} ‚àß k ‚àà {1 .. n} ‚àß j &lt; k ‚áí ¬¨(f k &lt;&lt; f j)
   
   [<a name="TOPOLOGICAL_SORT'-val"><b>TOPOLOGICAL_SORT'</b></a>]  Theorem
      
      ‚ä¢ ‚àÄR s n.
          transitive R ‚àß antisymmetric R ‚àß s HAS_SIZE n ‚áí
          ‚àÉf. s = IMAGE f (count n) ‚àß
              ‚àÄj k. j &lt; n ‚àß k &lt; n ‚àß j &lt; k ‚áí ¬¨R (f k) (f j)
   
   [<a name="TRANSFORM_2D_NUM-val"><b>TRANSFORM_2D_NUM</b></a>]  Theorem
      
      ‚ä¢ ‚àÄP. (‚àÄm n. P m n ‚áí P n m) ‚àß (‚àÄm n. P m (m + n)) ‚áí ‚àÄm n. P m n
   
   [<a name="TRANSITIVE_STEPWISE_LE-val"><b>TRANSITIVE_STEPWISE_LE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄR. (‚àÄx. R x x) ‚àß (‚àÄx y z. R x y ‚àß R y z ‚áí R x z) ‚àß
            (‚àÄn. R n (SUC n)) ‚áí
            ‚àÄm n. m ‚â§ n ‚áí R m n
   
   [<a name="TRANSITIVE_STEPWISE_LE_EQ-val"><b>TRANSITIVE_STEPWISE_LE_EQ</b></a>]  Theorem
      
      ‚ä¢ ‚àÄR. (‚àÄx. R x x) ‚àß (‚àÄx y z. R x y ‚àß R y z ‚áí R x z) ‚áí
            ((‚àÄm n. m ‚â§ n ‚áí R m n) ‚áî ‚àÄn. R n (SUC n))
   
   [<a name="TRIANGLE_2D_NUM-val"><b>TRIANGLE_2D_NUM</b></a>]  Theorem
      
      ‚ä¢ ‚àÄP. (‚àÄd n. P n (d + n)) ‚áí ‚àÄm n. m ‚â§ n ‚áí P m n
   
   [<a name="UNION_COUNT_FROM-val"><b>UNION_COUNT_FROM</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. count n ‚à™ from n = ùïå(:num)
   
   [<a name="UNION_FROM_COUNT-val"><b>UNION_FROM_COUNT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. from n ‚à™ count n = ùïå(:num)
   
   [<a name="UPPER_BOUND_FINITE_SET-val"><b>UPPER_BOUND_FINITE_SET</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf s. FINITE s ‚áí ‚àÉa. ‚àÄx. x ‚àà s ‚áí f x ‚â§ a
   
   [<a name="lifted-val"><b>lifted</b></a>]  Theorem
      
      ‚ä¢ lifted op NONE v0 = NONE ‚àß lifted op (SOME v5) NONE = NONE ‚àß
        lifted op (SOME x) (SOME y) = SOME (op x y)
   
   [<a name="lifted_ind-val"><b>lifted_ind</b></a>]  Theorem
      
      ‚ä¢ ‚àÄP. (‚àÄop v0. P op NONE v0) ‚àß (‚àÄop v5. P op (SOME v5) NONE) ‚àß
            (‚àÄop x y. P op (SOME x) (SOME y)) ‚áí
            ‚àÄv v1 v2. P v v1 v2
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/pred_set/src/iterateScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-2</a></em></p></body></html>
