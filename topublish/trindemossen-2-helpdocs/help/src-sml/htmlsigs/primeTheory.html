<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure primeTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure primeTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/algebra/base/.hol/objs/primeScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature primeTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#coprimes_by_def-val">coprimes_by_def</a> : thm
<a name="line7"></a>    val <a href="#divisors_def-val">divisors_def</a> : thm
<a name="line8"></a>    val <a href="#gcd_matches_def-val">gcd_matches_def</a> : thm
<a name="line9"></a>    val <a href="#halves_def_primitive-val">halves_def_primitive</a> : thm
<a name="line10"></a>    val <a href="#lcm_fun_def-val">lcm_fun_def</a> : thm
<a name="line11"></a>    val <a href="#multiples_upto_def-val">multiples_upto_def</a> : thm
<a name="line12"></a>    val <a href="#perfect_power_def-val">perfect_power_def</a> : thm
<a name="line13"></a>    val <a href="#phi_def-val">phi_def</a> : thm
<a name="line14"></a>    val <a href="#power_free_def-val">power_free_def</a> : thm
<a name="line15"></a>    val <a href="#power_free_test_def-val">power_free_test_def</a> : thm
<a name="line16"></a>    val <a href="#power_free_upto_def-val">power_free_upto_def</a> : thm
<a name="line17"></a>    val <a href="#prime_divisors_def-val">prime_divisors_def</a> : thm
<a name="line18"></a>    val <a href="#prime_factors_def-val">prime_factors_def</a> : thm
<a name="line19"></a>    val <a href="#prime_power_divisors_def-val">prime_power_divisors_def</a> : thm
<a name="line20"></a>    val <a href="#prime_power_index_def-val">prime_power_index_def</a> : thm
<a name="line21"></a>    val <a href="#prime_powers_upto_def-val">prime_powers_upto_def</a> : thm
<a name="line22"></a>    val <a href="#prime_test_def-val">prime_test_def</a> : thm
<a name="line23"></a>    val <a href="#primes_upto_def-val">primes_upto_def</a> : thm
<a name="line24"></a>    val <a href="#rec_phi_def_primitive-val">rec_phi_def_primitive</a> : thm
<a name="line25"></a>    val <a href="#square_def-val">square_def</a> : thm
<a name="line26"></a>    val <a href="#square_free_def-val">square_free_def</a> : thm
<a name="line27"></a>    val <a href="#ulog_def-val">ulog_def</a> : thm
<a name="line28"></a>  
<a name="line29"></a>  (*  Theorems  *)
<a name="line30"></a>    val <a href="#Gauss_little_thm-val">Gauss_little_thm</a> : thm
<a name="line31"></a>    val <a href="#LOG2_BY_HALF-val">LOG2_BY_HALF</a> : thm
<a name="line32"></a>    val <a href="#LOG2_DIV_EXP-val">LOG2_DIV_EXP</a> : thm
<a name="line33"></a>    val <a href="#LOG2_HALF-val">LOG2_HALF</a> : thm
<a name="line34"></a>    val <a href="#LOG2_SUC_TIMES_SQ_DIV_2_POS-val">LOG2_SUC_TIMES_SQ_DIV_2_POS</a> : thm
<a name="line35"></a>    val <a href="#LOG2_compute-val">LOG2_compute</a> : thm
<a name="line36"></a>    val <a href="#LOG_SUC-val">LOG_SUC</a> : thm
<a name="line37"></a>    val <a href="#ROOT_EQN-val">ROOT_EQN</a> : thm
<a name="line38"></a>    val <a href="#SQRT_LE_IMP-val">SQRT_LE_IMP</a> : thm
<a name="line39"></a>    val <a href="#SQRT_LE_SELF-val">SQRT_LE_SELF</a> : thm
<a name="line40"></a>    val <a href="#SQRT_MULT_LE-val">SQRT_MULT_LE</a> : thm
<a name="line41"></a>    val <a href="#SQRT_SQ-val">SQRT_SQ</a> : thm
<a name="line42"></a>    val <a href="#SQ_SQRT_LE-val">SQ_SQRT_LE</a> : thm
<a name="line43"></a>    val <a href="#SQ_SQRT_LE_alt-val">SQ_SQRT_LE_alt</a> : thm
<a name="line44"></a>    val <a href="#SQ_SQRT_LT-val">SQ_SQRT_LT</a> : thm
<a name="line45"></a>    val <a href="#SQ_SQRT_LT_alt-val">SQ_SQRT_LT_alt</a> : thm
<a name="line46"></a>    val <a href="#basic_prime_factorisation-val">basic_prime_factorisation</a> : thm
<a name="line47"></a>    val <a href="#common_prime_divisors_element-val">common_prime_divisors_element</a> : thm
<a name="line48"></a>    val <a href="#common_prime_divisors_finite-val">common_prime_divisors_finite</a> : thm
<a name="line49"></a>    val <a href="#common_prime_divisors_min_image_pairwise_coprime-val">common_prime_divisors_min_image_pairwise_coprime</a> : thm
<a name="line50"></a>    val <a href="#common_prime_divisors_pairwise_coprime-val">common_prime_divisors_pairwise_coprime</a> : thm
<a name="line51"></a>    val <a href="#coprimes_by_0-val">coprimes_by_0</a> : thm
<a name="line52"></a>    val <a href="#coprimes_by_by_0-val">coprimes_by_by_0</a> : thm
<a name="line53"></a>    val <a href="#coprimes_by_by_1-val">coprimes_by_by_1</a> : thm
<a name="line54"></a>    val <a href="#coprimes_by_by_divisor-val">coprimes_by_by_divisor</a> : thm
<a name="line55"></a>    val <a href="#coprimes_by_by_last-val">coprimes_by_by_last</a> : thm
<a name="line56"></a>    val <a href="#coprimes_by_divisors_card-val">coprimes_by_divisors_card</a> : thm
<a name="line57"></a>    val <a href="#coprimes_by_element-val">coprimes_by_element</a> : thm
<a name="line58"></a>    val <a href="#coprimes_by_eq_empty-val">coprimes_by_eq_empty</a> : thm
<a name="line59"></a>    val <a href="#coprimes_by_finite-val">coprimes_by_finite</a> : thm
<a name="line60"></a>    val <a href="#coprimes_by_with_card-val">coprimes_by_with_card</a> : thm
<a name="line61"></a>    val <a href="#coprimes_eq_Euler-val">coprimes_eq_Euler</a> : thm
<a name="line62"></a>    val <a href="#coprimes_from_not_1_inj-val">coprimes_from_not_1_inj</a> : thm
<a name="line63"></a>    val <a href="#coprimes_map_cross_inj-val">coprimes_map_cross_inj</a> : thm
<a name="line64"></a>    val <a href="#coprimes_mult_by_image-val">coprimes_mult_by_image</a> : thm
<a name="line65"></a>    val <a href="#coprimes_prime-val">coprimes_prime</a> : thm
<a name="line66"></a>    val <a href="#coprimes_prime_power-val">coprimes_prime_power</a> : thm
<a name="line67"></a>    val <a href="#coprimes_thm-val">coprimes_thm</a> : thm
<a name="line68"></a>    val <a href="#count_up_def-val">count_up_def</a> : thm
<a name="line69"></a>    val <a href="#count_up_exit-val">count_up_exit</a> : thm
<a name="line70"></a>    val <a href="#count_up_exit_eqn-val">count_up_exit_eqn</a> : thm
<a name="line71"></a>    val <a href="#count_up_ind-val">count_up_ind</a> : thm
<a name="line72"></a>    val <a href="#count_up_suc-val">count_up_suc</a> : thm
<a name="line73"></a>    val <a href="#count_up_suc_eqn-val">count_up_suc_eqn</a> : thm
<a name="line74"></a>    val <a href="#divisor_gt_cofactor_le-val">divisor_gt_cofactor_le</a> : thm
<a name="line75"></a>    val <a href="#divisor_le_cofactor_ge-val">divisor_le_cofactor_ge</a> : thm
<a name="line76"></a>    val <a href="#divisor_prime_factorisation-val">divisor_prime_factorisation</a> : thm
<a name="line77"></a>    val <a href="#divisors_0-val">divisors_0</a> : thm
<a name="line78"></a>    val <a href="#divisors_1-val">divisors_1</a> : thm
<a name="line79"></a>    val <a href="#divisors_card_upper-val">divisors_card_upper</a> : thm
<a name="line80"></a>    val <a href="#divisors_cofactor_inj-val">divisors_cofactor_inj</a> : thm
<a name="line81"></a>    val <a href="#divisors_delete_last-val">divisors_delete_last</a> : thm
<a name="line82"></a>    val <a href="#divisors_divisors_bij-val">divisors_divisors_bij</a> : thm
<a name="line83"></a>    val <a href="#divisors_element-val">divisors_element</a> : thm
<a name="line84"></a>    val <a href="#divisors_element_alt-val">divisors_element_alt</a> : thm
<a name="line85"></a>    val <a href="#divisors_eq_empty-val">divisors_eq_empty</a> : thm
<a name="line86"></a>    val <a href="#divisors_eq_gcd_image-val">divisors_eq_gcd_image</a> : thm
<a name="line87"></a>    val <a href="#divisors_eq_image_gcd_count-val">divisors_eq_image_gcd_count</a> : thm
<a name="line88"></a>    val <a href="#divisors_eq_image_gcd_natural-val">divisors_eq_image_gcd_natural</a> : thm
<a name="line89"></a>    val <a href="#divisors_eq_image_gcd_upto-val">divisors_eq_image_gcd_upto</a> : thm
<a name="line90"></a>    val <a href="#divisors_eqn-val">divisors_eqn</a> : thm
<a name="line91"></a>    val <a href="#divisors_finite-val">divisors_finite</a> : thm
<a name="line92"></a>    val <a href="#divisors_has_1-val">divisors_has_1</a> : thm
<a name="line93"></a>    val <a href="#divisors_has_cofactor-val">divisors_has_cofactor</a> : thm
<a name="line94"></a>    val <a href="#divisors_has_element-val">divisors_has_element</a> : thm
<a name="line95"></a>    val <a href="#divisors_has_factor-val">divisors_has_factor</a> : thm
<a name="line96"></a>    val <a href="#divisors_has_last-val">divisors_has_last</a> : thm
<a name="line97"></a>    val <a href="#divisors_nonzero-val">divisors_nonzero</a> : thm
<a name="line98"></a>    val <a href="#divisors_not_empty-val">divisors_not_empty</a> : thm
<a name="line99"></a>    val <a href="#divisors_subset_natural-val">divisors_subset_natural</a> : thm
<a name="line100"></a>    val <a href="#even_sq_free_element-val">even_sq_free_element</a> : thm
<a name="line101"></a>    val <a href="#even_sq_free_finite-val">even_sq_free_finite</a> : thm
<a name="line102"></a>    val <a href="#even_sq_free_subset-val">even_sq_free_subset</a> : thm
<a name="line103"></a>    val <a href="#exp_to_ulog-val">exp_to_ulog</a> : thm
<a name="line104"></a>    val <a href="#factor_seek_bound-val">factor_seek_bound</a> : thm
<a name="line105"></a>    val <a href="#factor_seek_def-val">factor_seek_def</a> : thm
<a name="line106"></a>    val <a href="#factor_seek_ind-val">factor_seek_ind</a> : thm
<a name="line107"></a>    val <a href="#factor_seek_thm-val">factor_seek_thm</a> : thm
<a name="line108"></a>    val <a href="#gcd_eq_count_partition_by_divisors-val">gcd_eq_count_partition_by_divisors</a> : thm
<a name="line109"></a>    val <a href="#gcd_eq_equiv_class-val">gcd_eq_equiv_class</a> : thm
<a name="line110"></a>    val <a href="#gcd_eq_equiv_class_fun-val">gcd_eq_equiv_class_fun</a> : thm
<a name="line111"></a>    val <a href="#gcd_eq_equiv_on_count-val">gcd_eq_equiv_on_count</a> : thm
<a name="line112"></a>    val <a href="#gcd_eq_equiv_on_natural-val">gcd_eq_equiv_on_natural</a> : thm
<a name="line113"></a>    val <a href="#gcd_eq_equiv_on_upto-val">gcd_eq_equiv_on_upto</a> : thm
<a name="line114"></a>    val <a href="#gcd_eq_natural_partition_by_divisors-val">gcd_eq_natural_partition_by_divisors</a> : thm
<a name="line115"></a>    val <a href="#gcd_eq_partition_by_divisors-val">gcd_eq_partition_by_divisors</a> : thm
<a name="line116"></a>    val <a href="#gcd_eq_upto_partition_by_divisors-val">gcd_eq_upto_partition_by_divisors</a> : thm
<a name="line117"></a>    val <a href="#gcd_matches_0-val">gcd_matches_0</a> : thm
<a name="line118"></a>    val <a href="#gcd_matches_1-val">gcd_matches_1</a> : thm
<a name="line119"></a>    val <a href="#gcd_matches_alt-val">gcd_matches_alt</a> : thm
<a name="line120"></a>    val <a href="#gcd_matches_and_coprimes_by_same_size-val">gcd_matches_and_coprimes_by_same_size</a> : thm
<a name="line121"></a>    val <a href="#gcd_matches_bij_coprimes-val">gcd_matches_bij_coprimes</a> : thm
<a name="line122"></a>    val <a href="#gcd_matches_bij_coprimes_by-val">gcd_matches_bij_coprimes_by</a> : thm
<a name="line123"></a>    val <a href="#gcd_matches_divisor_element-val">gcd_matches_divisor_element</a> : thm
<a name="line124"></a>    val <a href="#gcd_matches_element-val">gcd_matches_element</a> : thm
<a name="line125"></a>    val <a href="#gcd_matches_element_divides-val">gcd_matches_element_divides</a> : thm
<a name="line126"></a>    val <a href="#gcd_matches_eq_empty-val">gcd_matches_eq_empty</a> : thm
<a name="line127"></a>    val <a href="#gcd_matches_finite-val">gcd_matches_finite</a> : thm
<a name="line128"></a>    val <a href="#gcd_matches_from_divisors_inj-val">gcd_matches_from_divisors_inj</a> : thm
<a name="line129"></a>    val <a href="#gcd_matches_has_divisor-val">gcd_matches_has_divisor</a> : thm
<a name="line130"></a>    val <a href="#gcd_matches_subset-val">gcd_matches_subset</a> : thm
<a name="line131"></a>    val <a href="#gcd_matches_with_0-val">gcd_matches_with_0</a> : thm
<a name="line132"></a>    val <a href="#gcd_park_decompose-val">gcd_park_decompose</a> : thm
<a name="line133"></a>    val <a href="#gcd_park_decomposition-val">gcd_park_decomposition</a> : thm
<a name="line134"></a>    val <a href="#gcd_prime_factorisation-val">gcd_prime_factorisation</a> : thm
<a name="line135"></a>    val <a href="#gcd_prime_power_cofactor_coprime-val">gcd_prime_power_cofactor_coprime</a> : thm
<a name="line136"></a>    val <a href="#gcd_prime_power_divisibility-val">gcd_prime_power_divisibility</a> : thm
<a name="line137"></a>    val <a href="#gcd_prime_power_factor-val">gcd_prime_power_factor</a> : thm
<a name="line138"></a>    val <a href="#gcd_prime_power_factor_divides_gcd-val">gcd_prime_power_factor_divides_gcd</a> : thm
<a name="line139"></a>    val <a href="#gcd_prime_power_index-val">gcd_prime_power_index</a> : thm
<a name="line140"></a>    val <a href="#halves_0-val">halves_0</a> : thm
<a name="line141"></a>    val <a href="#halves_1-val">halves_1</a> : thm
<a name="line142"></a>    val <a href="#halves_2-val">halves_2</a> : thm
<a name="line143"></a>    val <a href="#halves_alt-val">halves_alt</a> : thm
<a name="line144"></a>    val <a href="#halves_by_LOG2-val">halves_by_LOG2</a> : thm
<a name="line145"></a>    val <a href="#halves_def-val">halves_def</a> : thm
<a name="line146"></a>    val <a href="#halves_eq_0-val">halves_eq_0</a> : thm
<a name="line147"></a>    val <a href="#halves_eq_1-val">halves_eq_1</a> : thm
<a name="line148"></a>    val <a href="#halves_ind-val">halves_ind</a> : thm
<a name="line149"></a>    val <a href="#halves_le-val">halves_le</a> : thm
<a name="line150"></a>    val <a href="#halves_pos-val">halves_pos</a> : thm
<a name="line151"></a>    val <a href="#lcm_fun_0-val">lcm_fun_0</a> : thm
<a name="line152"></a>    val <a href="#lcm_fun_1-val">lcm_fun_1</a> : thm
<a name="line153"></a>    val <a href="#lcm_fun_2-val">lcm_fun_2</a> : thm
<a name="line154"></a>    val <a href="#lcm_fun_SUC-val">lcm_fun_SUC</a> : thm
<a name="line155"></a>    val <a href="#lcm_fun_compute-val">lcm_fun_compute</a> : thm
<a name="line156"></a>    val <a href="#lcm_fun_lower_bound-val">lcm_fun_lower_bound</a> : thm
<a name="line157"></a>    val <a href="#lcm_fun_lower_bound_alt-val">lcm_fun_lower_bound_alt</a> : thm
<a name="line158"></a>    val <a href="#lcm_fun_suc_none-val">lcm_fun_suc_none</a> : thm
<a name="line159"></a>    val <a href="#lcm_fun_suc_some-val">lcm_fun_suc_some</a> : thm
<a name="line160"></a>    val <a href="#lcm_gcd_park_decompose-val">lcm_gcd_park_decompose</a> : thm
<a name="line161"></a>    val <a href="#lcm_park_decompose-val">lcm_park_decompose</a> : thm
<a name="line162"></a>    val <a href="#lcm_park_decomposition-val">lcm_park_decomposition</a> : thm
<a name="line163"></a>    val <a href="#lcm_prime_factorisation-val">lcm_prime_factorisation</a> : thm
<a name="line164"></a>    val <a href="#lcm_prime_power_cofactor_coprime-val">lcm_prime_power_cofactor_coprime</a> : thm
<a name="line165"></a>    val <a href="#lcm_prime_power_divisibility-val">lcm_prime_power_divisibility</a> : thm
<a name="line166"></a>    val <a href="#lcm_prime_power_factor-val">lcm_prime_power_factor</a> : thm
<a name="line167"></a>    val <a href="#lcm_prime_power_factor_divides_lcm-val">lcm_prime_power_factor_divides_lcm</a> : thm
<a name="line168"></a>    val <a href="#lcm_prime_power_index-val">lcm_prime_power_index</a> : thm
<a name="line169"></a>    val <a href="#lcm_run_eq_prod_set_prime_powers-val">lcm_run_eq_prod_set_prime_powers</a> : thm
<a name="line170"></a>    val <a href="#lcm_run_eq_set_lcm_prime_powers-val">lcm_run_eq_set_lcm_prime_powers</a> : thm
<a name="line171"></a>    val <a href="#lcm_run_lower_by_primes_count-val">lcm_run_lower_by_primes_count</a> : thm
<a name="line172"></a>    val <a href="#lcm_run_lower_by_primes_product-val">lcm_run_lower_by_primes_product</a> : thm
<a name="line173"></a>    val <a href="#lcm_run_upper_by_primes_count-val">lcm_run_upper_by_primes_count</a> : thm
<a name="line174"></a>    val <a href="#lcm_special_for_coprime_factors-val">lcm_special_for_coprime_factors</a> : thm
<a name="line175"></a>    val <a href="#lcm_special_for_prime_power-val">lcm_special_for_prime_power</a> : thm
<a name="line176"></a>    val <a href="#less_divisors_0-val">less_divisors_0</a> : thm
<a name="line177"></a>    val <a href="#less_divisors_1-val">less_divisors_1</a> : thm
<a name="line178"></a>    val <a href="#less_divisors_element-val">less_divisors_element</a> : thm
<a name="line179"></a>    val <a href="#less_divisors_finite-val">less_divisors_finite</a> : thm
<a name="line180"></a>    val <a href="#less_divisors_has_1-val">less_divisors_has_1</a> : thm
<a name="line181"></a>    val <a href="#less_divisors_has_cofactor-val">less_divisors_has_cofactor</a> : thm
<a name="line182"></a>    val <a href="#less_divisors_max-val">less_divisors_max</a> : thm
<a name="line183"></a>    val <a href="#less_divisors_min-val">less_divisors_min</a> : thm
<a name="line184"></a>    val <a href="#less_divisors_nonzero-val">less_divisors_nonzero</a> : thm
<a name="line185"></a>    val <a href="#less_divisors_prime-val">less_divisors_prime</a> : thm
<a name="line186"></a>    val <a href="#less_divisors_subset_divisors-val">less_divisors_subset_divisors</a> : thm
<a name="line187"></a>    val <a href="#less_divisors_subset_natural-val">less_divisors_subset_natural</a> : thm
<a name="line188"></a>    val <a href="#list_lcm_by_last_non_prime_power-val">list_lcm_by_last_non_prime_power</a> : thm
<a name="line189"></a>    val <a href="#list_lcm_by_last_prime_power-val">list_lcm_by_last_prime_power</a> : thm
<a name="line190"></a>    val <a href="#list_lcm_eq_lcm_fun-val">list_lcm_eq_lcm_fun</a> : thm
<a name="line191"></a>    val <a href="#list_lcm_option_last_non_prime_power-val">list_lcm_option_last_non_prime_power</a> : thm
<a name="line192"></a>    val <a href="#list_lcm_option_last_prime_power-val">list_lcm_option_last_prime_power</a> : thm
<a name="line193"></a>    val <a href="#list_lcm_option_recurrence-val">list_lcm_option_recurrence</a> : thm
<a name="line194"></a>    val <a href="#list_lcm_prime_power_divisibility-val">list_lcm_prime_power_divisibility</a> : thm
<a name="line195"></a>    val <a href="#list_lcm_prime_power_factor_divides-val">list_lcm_prime_power_factor_divides</a> : thm
<a name="line196"></a>    val <a href="#list_lcm_prime_power_factor_member-val">list_lcm_prime_power_factor_member</a> : thm
<a name="line197"></a>    val <a href="#list_lcm_prime_power_index-val">list_lcm_prime_power_index</a> : thm
<a name="line198"></a>    val <a href="#list_lcm_prime_power_index_lower-val">list_lcm_prime_power_index_lower</a> : thm
<a name="line199"></a>    val <a href="#list_lcm_recurrence-val">list_lcm_recurrence</a> : thm
<a name="line200"></a>    val <a href="#list_lcm_with_last_non_prime_power-val">list_lcm_with_last_non_prime_power</a> : thm
<a name="line201"></a>    val <a href="#list_lcm_with_last_prime_power-val">list_lcm_with_last_prime_power</a> : thm
<a name="line202"></a>    val <a href="#multiples_upto_0_n-val">multiples_upto_0_n</a> : thm
<a name="line203"></a>    val <a href="#multiples_upto_1_n-val">multiples_upto_1_n</a> : thm
<a name="line204"></a>    val <a href="#multiples_upto_alt-val">multiples_upto_alt</a> : thm
<a name="line205"></a>    val <a href="#multiples_upto_card-val">multiples_upto_card</a> : thm
<a name="line206"></a>    val <a href="#multiples_upto_element-val">multiples_upto_element</a> : thm
<a name="line207"></a>    val <a href="#multiples_upto_element_alt-val">multiples_upto_element_alt</a> : thm
<a name="line208"></a>    val <a href="#multiples_upto_eqn-val">multiples_upto_eqn</a> : thm
<a name="line209"></a>    val <a href="#multiples_upto_finite-val">multiples_upto_finite</a> : thm
<a name="line210"></a>    val <a href="#multiples_upto_m_0-val">multiples_upto_m_0</a> : thm
<a name="line211"></a>    val <a href="#multiples_upto_m_1-val">multiples_upto_m_1</a> : thm
<a name="line212"></a>    val <a href="#multiples_upto_subset-val">multiples_upto_subset</a> : thm
<a name="line213"></a>    val <a href="#multiples_upto_thm-val">multiples_upto_thm</a> : thm
<a name="line214"></a>    val <a href="#non_prime_power_coprime_factors-val">non_prime_power_coprime_factors</a> : thm
<a name="line215"></a>    val <a href="#non_sq_free_element-val">non_sq_free_element</a> : thm
<a name="line216"></a>    val <a href="#non_sq_free_finite-val">non_sq_free_finite</a> : thm
<a name="line217"></a>    val <a href="#non_sq_free_subset-val">non_sq_free_subset</a> : thm
<a name="line218"></a>    val <a href="#odd_sq_free_element-val">odd_sq_free_element</a> : thm
<a name="line219"></a>    val <a href="#odd_sq_free_finite-val">odd_sq_free_finite</a> : thm
<a name="line220"></a>    val <a href="#odd_sq_free_subset-val">odd_sq_free_subset</a> : thm
<a name="line221"></a>    val <a href="#odd_square_lt-val">odd_square_lt</a> : thm
<a name="line222"></a>    val <a href="#pairwise_coprime_for_prime_powers-val">pairwise_coprime_for_prime_powers</a> : thm
<a name="line223"></a>    val <a href="#park_off_alt-val">park_off_alt</a> : thm
<a name="line224"></a>    val <a href="#park_off_element-val">park_off_element</a> : thm
<a name="line225"></a>    val <a href="#park_off_image_has_not_1-val">park_off_image_has_not_1</a> : thm
<a name="line226"></a>    val <a href="#park_off_subset_common-val">park_off_subset_common</a> : thm
<a name="line227"></a>    val <a href="#park_off_subset_total-val">park_off_subset_total</a> : thm
<a name="line228"></a>    val <a href="#park_on_element-val">park_on_element</a> : thm
<a name="line229"></a>    val <a href="#park_on_off_common_image_partition-val">park_on_off_common_image_partition</a> : thm
<a name="line230"></a>    val <a href="#park_on_off_partition-val">park_on_off_partition</a> : thm
<a name="line231"></a>    val <a href="#park_on_off_total_image_partition-val">park_on_off_total_image_partition</a> : thm
<a name="line232"></a>    val <a href="#park_on_subset_common-val">park_on_subset_common</a> : thm
<a name="line233"></a>    val <a href="#park_on_subset_total-val">park_on_subset_total</a> : thm
<a name="line234"></a>    val <a href="#perfect_power_0_m-val">perfect_power_0_m</a> : thm
<a name="line235"></a>    val <a href="#perfect_power_1_m-val">perfect_power_1_m</a> : thm
<a name="line236"></a>    val <a href="#perfect_power_2_odd-val">perfect_power_2_odd</a> : thm
<a name="line237"></a>    val <a href="#perfect_power_bound_LOG2-val">perfect_power_bound_LOG2</a> : thm
<a name="line238"></a>    val <a href="#perfect_power_bound_ulog-val">perfect_power_bound_ulog</a> : thm
<a name="line239"></a>    val <a href="#perfect_power_cofactor-val">perfect_power_cofactor</a> : thm
<a name="line240"></a>    val <a href="#perfect_power_cofactor_alt-val">perfect_power_cofactor_alt</a> : thm
<a name="line241"></a>    val <a href="#perfect_power_condition-val">perfect_power_condition</a> : thm
<a name="line242"></a>    val <a href="#perfect_power_half_inequality_1-val">perfect_power_half_inequality_1</a> : thm
<a name="line243"></a>    val <a href="#perfect_power_half_inequality_2-val">perfect_power_half_inequality_2</a> : thm
<a name="line244"></a>    val <a href="#perfect_power_mod_eq_0-val">perfect_power_mod_eq_0</a> : thm
<a name="line245"></a>    val <a href="#perfect_power_mod_ne_0-val">perfect_power_mod_ne_0</a> : thm
<a name="line246"></a>    val <a href="#perfect_power_n_0-val">perfect_power_n_0</a> : thm
<a name="line247"></a>    val <a href="#perfect_power_n_1-val">perfect_power_n_1</a> : thm
<a name="line248"></a>    val <a href="#perfect_power_not_suc-val">perfect_power_not_suc</a> : thm
<a name="line249"></a>    val <a href="#perfect_power_self-val">perfect_power_self</a> : thm
<a name="line250"></a>    val <a href="#perfect_power_special_inequality-val">perfect_power_special_inequality</a> : thm
<a name="line251"></a>    val <a href="#perfect_power_suc-val">perfect_power_suc</a> : thm
<a name="line252"></a>    val <a href="#perfect_power_test-val">perfect_power_test</a> : thm
<a name="line253"></a>    val <a href="#phi_0-val">phi_0</a> : thm
<a name="line254"></a>    val <a href="#phi_1-val">phi_1</a> : thm
<a name="line255"></a>    val <a href="#phi_2-val">phi_2</a> : thm
<a name="line256"></a>    val <a href="#phi_eq_0-val">phi_eq_0</a> : thm
<a name="line257"></a>    val <a href="#phi_eq_totient-val">phi_eq_totient</a> : thm
<a name="line258"></a>    val <a href="#phi_fun-val">phi_fun</a> : thm
<a name="line259"></a>    val <a href="#phi_gt_1-val">phi_gt_1</a> : thm
<a name="line260"></a>    val <a href="#phi_le-val">phi_le</a> : thm
<a name="line261"></a>    val <a href="#phi_lt-val">phi_lt</a> : thm
<a name="line262"></a>    val <a href="#phi_mult-val">phi_mult</a> : thm
<a name="line263"></a>    val <a href="#phi_pos-val">phi_pos</a> : thm
<a name="line264"></a>    val <a href="#phi_prime-val">phi_prime</a> : thm
<a name="line265"></a>    val <a href="#phi_prime_power-val">phi_prime_power</a> : thm
<a name="line266"></a>    val <a href="#phi_prime_sq-val">phi_prime_sq</a> : thm
<a name="line267"></a>    val <a href="#phi_primes-val">phi_primes</a> : thm
<a name="line268"></a>    val <a href="#phi_primes_distinct-val">phi_primes_distinct</a> : thm
<a name="line269"></a>    val <a href="#phi_thm-val">phi_thm</a> : thm
<a name="line270"></a>    val <a href="#power_free_0-val">power_free_0</a> : thm
<a name="line271"></a>    val <a href="#power_free_1-val">power_free_1</a> : thm
<a name="line272"></a>    val <a href="#power_free_2-val">power_free_2</a> : thm
<a name="line273"></a>    val <a href="#power_free_3-val">power_free_3</a> : thm
<a name="line274"></a>    val <a href="#power_free_alt-val">power_free_alt</a> : thm
<a name="line275"></a>    val <a href="#power_free_by_power_index_LOG2-val">power_free_by_power_index_LOG2</a> : thm
<a name="line276"></a>    val <a href="#power_free_by_power_index_ulog-val">power_free_by_power_index_ulog</a> : thm
<a name="line277"></a>    val <a href="#power_free_check_all-val">power_free_check_all</a> : thm
<a name="line278"></a>    val <a href="#power_free_check_upto-val">power_free_check_upto</a> : thm
<a name="line279"></a>    val <a href="#power_free_check_upto_LOG2-val">power_free_check_upto_LOG2</a> : thm
<a name="line280"></a>    val <a href="#power_free_check_upto_ulog-val">power_free_check_upto_ulog</a> : thm
<a name="line281"></a>    val <a href="#power_free_gt_1-val">power_free_gt_1</a> : thm
<a name="line282"></a>    val <a href="#power_free_perfect_power-val">power_free_perfect_power</a> : thm
<a name="line283"></a>    val <a href="#power_free_property-val">power_free_property</a> : thm
<a name="line284"></a>    val <a href="#power_free_test_eqn-val">power_free_test_eqn</a> : thm
<a name="line285"></a>    val <a href="#power_free_test_upto_LOG2-val">power_free_test_upto_LOG2</a> : thm
<a name="line286"></a>    val <a href="#power_free_test_upto_ulog-val">power_free_test_upto_ulog</a> : thm
<a name="line287"></a>    val <a href="#power_free_upto_0-val">power_free_upto_0</a> : thm
<a name="line288"></a>    val <a href="#power_free_upto_1-val">power_free_upto_1</a> : thm
<a name="line289"></a>    val <a href="#power_free_upto_suc-val">power_free_upto_suc</a> : thm
<a name="line290"></a>    val <a href="#power_index_0-val">power_index_0</a> : thm
<a name="line291"></a>    val <a href="#power_index_1-val">power_index_1</a> : thm
<a name="line292"></a>    val <a href="#power_index_def-val">power_index_def</a> : thm
<a name="line293"></a>    val <a href="#power_index_eqn-val">power_index_eqn</a> : thm
<a name="line294"></a>    val <a href="#power_index_equal-val">power_index_equal</a> : thm
<a name="line295"></a>    val <a href="#power_index_exact_root-val">power_index_exact_root</a> : thm
<a name="line296"></a>    val <a href="#power_index_ind-val">power_index_ind</a> : thm
<a name="line297"></a>    val <a href="#power_index_lower-val">power_index_lower</a> : thm
<a name="line298"></a>    val <a href="#power_index_no_exact_roots-val">power_index_no_exact_roots</a> : thm
<a name="line299"></a>    val <a href="#power_index_not_exact_root-val">power_index_not_exact_root</a> : thm
<a name="line300"></a>    val <a href="#power_index_of_1-val">power_index_of_1</a> : thm
<a name="line301"></a>    val <a href="#power_index_pos-val">power_index_pos</a> : thm
<a name="line302"></a>    val <a href="#power_index_property-val">power_index_property</a> : thm
<a name="line303"></a>    val <a href="#power_index_root-val">power_index_root</a> : thm
<a name="line304"></a>    val <a href="#power_index_upper-val">power_index_upper</a> : thm
<a name="line305"></a>    val <a href="#prime_by_sqrt_factors-val">prime_by_sqrt_factors</a> : thm
<a name="line306"></a>    val <a href="#prime_divisors_0-val">prime_divisors_0</a> : thm
<a name="line307"></a>    val <a href="#prime_divisors_0_not_sing-val">prime_divisors_0_not_sing</a> : thm
<a name="line308"></a>    val <a href="#prime_divisors_1-val">prime_divisors_1</a> : thm
<a name="line309"></a>    val <a href="#prime_divisors_common_divisor-val">prime_divisors_common_divisor</a> : thm
<a name="line310"></a>    val <a href="#prime_divisors_common_multiple-val">prime_divisors_common_multiple</a> : thm
<a name="line311"></a>    val <a href="#prime_divisors_divisor_subset-val">prime_divisors_divisor_subset</a> : thm
<a name="line312"></a>    val <a href="#prime_divisors_element-val">prime_divisors_element</a> : thm
<a name="line313"></a>    val <a href="#prime_divisors_empty_iff-val">prime_divisors_empty_iff</a> : thm
<a name="line314"></a>    val <a href="#prime_divisors_finite-val">prime_divisors_finite</a> : thm
<a name="line315"></a>    val <a href="#prime_divisors_nonempty-val">prime_divisors_nonempty</a> : thm
<a name="line316"></a>    val <a href="#prime_divisors_prime-val">prime_divisors_prime</a> : thm
<a name="line317"></a>    val <a href="#prime_divisors_prime_power-val">prime_divisors_prime_power</a> : thm
<a name="line318"></a>    val <a href="#prime_divisors_sing-val">prime_divisors_sing</a> : thm
<a name="line319"></a>    val <a href="#prime_divisors_sing_alt-val">prime_divisors_sing_alt</a> : thm
<a name="line320"></a>    val <a href="#prime_divisors_sing_property-val">prime_divisors_sing_property</a> : thm
<a name="line321"></a>    val <a href="#prime_divisors_subset_natural-val">prime_divisors_subset_natural</a> : thm
<a name="line322"></a>    val <a href="#prime_divisors_subset_prime-val">prime_divisors_subset_prime</a> : thm
<a name="line323"></a>    val <a href="#prime_factor_estimate-val">prime_factor_estimate</a> : thm
<a name="line324"></a>    val <a href="#prime_factorisation-val">prime_factorisation</a> : thm
<a name="line325"></a>    val <a href="#prime_factors_element-val">prime_factors_element</a> : thm
<a name="line326"></a>    val <a href="#prime_factors_finite-val">prime_factors_finite</a> : thm
<a name="line327"></a>    val <a href="#prime_factors_subset-val">prime_factors_subset</a> : thm
<a name="line328"></a>    val <a href="#prime_is_power_free-val">prime_is_power_free</a> : thm
<a name="line329"></a>    val <a href="#prime_non_square-val">prime_non_square</a> : thm
<a name="line330"></a>    val <a href="#prime_power_cofactor_coprime-val">prime_power_cofactor_coprime</a> : thm
<a name="line331"></a>    val <a href="#prime_power_divisibility-val">prime_power_divisibility</a> : thm
<a name="line332"></a>    val <a href="#prime_power_divisors_1-val">prime_power_divisors_1</a> : thm
<a name="line333"></a>    val <a href="#prime_power_divisors_element-val">prime_power_divisors_element</a> : thm
<a name="line334"></a>    val <a href="#prime_power_divisors_element_alt-val">prime_power_divisors_element_alt</a> : thm
<a name="line335"></a>    val <a href="#prime_power_divisors_finite-val">prime_power_divisors_finite</a> : thm
<a name="line336"></a>    val <a href="#prime_power_divisors_pairwise_coprime-val">prime_power_divisors_pairwise_coprime</a> : thm
<a name="line337"></a>    val <a href="#prime_power_eqn-val">prime_power_eqn</a> : thm
<a name="line338"></a>    val <a href="#prime_power_factor_divides-val">prime_power_factor_divides</a> : thm
<a name="line339"></a>    val <a href="#prime_power_index_1-val">prime_power_index_1</a> : thm
<a name="line340"></a>    val <a href="#prime_power_index_common_divisor-val">prime_power_index_common_divisor</a> : thm
<a name="line341"></a>    val <a href="#prime_power_index_common_multiple-val">prime_power_index_common_multiple</a> : thm
<a name="line342"></a>    val <a href="#prime_power_index_eq_0-val">prime_power_index_eq_0</a> : thm
<a name="line343"></a>    val <a href="#prime_power_index_eqn-val">prime_power_index_eqn</a> : thm
<a name="line344"></a>    val <a href="#prime_power_index_exists-val">prime_power_index_exists</a> : thm
<a name="line345"></a>    val <a href="#prime_power_index_le_log_index-val">prime_power_index_le_log_index</a> : thm
<a name="line346"></a>    val <a href="#prime_power_index_maximal-val">prime_power_index_maximal</a> : thm
<a name="line347"></a>    val <a href="#prime_power_index_of_divisor-val">prime_power_index_of_divisor</a> : thm
<a name="line348"></a>    val <a href="#prime_power_index_pos-val">prime_power_index_pos</a> : thm
<a name="line349"></a>    val <a href="#prime_power_index_prime-val">prime_power_index_prime</a> : thm
<a name="line350"></a>    val <a href="#prime_power_index_prime_power-val">prime_power_index_prime_power</a> : thm
<a name="line351"></a>    val <a href="#prime_power_index_suc_property-val">prime_power_index_suc_property</a> : thm
<a name="line352"></a>    val <a href="#prime_power_index_suc_special-val">prime_power_index_suc_special</a> : thm
<a name="line353"></a>    val <a href="#prime_power_index_test-val">prime_power_index_test</a> : thm
<a name="line354"></a>    val <a href="#prime_power_or_coprime_factors-val">prime_power_or_coprime_factors</a> : thm
<a name="line355"></a>    val <a href="#prime_powers_upto_0-val">prime_powers_upto_0</a> : thm
<a name="line356"></a>    val <a href="#prime_powers_upto_1-val">prime_powers_upto_1</a> : thm
<a name="line357"></a>    val <a href="#prime_powers_upto_element-val">prime_powers_upto_element</a> : thm
<a name="line358"></a>    val <a href="#prime_powers_upto_element_alt-val">prime_powers_upto_element_alt</a> : thm
<a name="line359"></a>    val <a href="#prime_powers_upto_finite-val">prime_powers_upto_finite</a> : thm
<a name="line360"></a>    val <a href="#prime_powers_upto_lcm_divisor-val">prime_powers_upto_lcm_divisor</a> : thm
<a name="line361"></a>    val <a href="#prime_powers_upto_lcm_prime_divisor-val">prime_powers_upto_lcm_prime_divisor</a> : thm
<a name="line362"></a>    val <a href="#prime_powers_upto_lcm_prime_to_log_divisor-val">prime_powers_upto_lcm_prime_to_log_divisor</a> : thm
<a name="line363"></a>    val <a href="#prime_powers_upto_lcm_prime_to_power_divisor-val">prime_powers_upto_lcm_prime_to_power_divisor</a> : thm
<a name="line364"></a>    val <a href="#prime_powers_upto_list_mem-val">prime_powers_upto_list_mem</a> : thm
<a name="line365"></a>    val <a href="#prime_powers_upto_pairwise_coprime-val">prime_powers_upto_pairwise_coprime</a> : thm
<a name="line366"></a>    val <a href="#prime_powers_upto_prod_set_ge-val">prime_powers_upto_prod_set_ge</a> : thm
<a name="line367"></a>    val <a href="#prime_powers_upto_prod_set_le-val">prime_powers_upto_prod_set_le</a> : thm
<a name="line368"></a>    val <a href="#prime_powers_upto_prod_set_mix_ge-val">prime_powers_upto_prod_set_mix_ge</a> : thm
<a name="line369"></a>    val <a href="#prime_test_thm-val">prime_test_thm</a> : thm
<a name="line370"></a>    val <a href="#primes_count_0-val">primes_count_0</a> : thm
<a name="line371"></a>    val <a href="#primes_count_1-val">primes_count_1</a> : thm
<a name="line372"></a>    val <a href="#primes_count_upper_by_lcm_run-val">primes_count_upper_by_lcm_run</a> : thm
<a name="line373"></a>    val <a href="#primes_count_upper_by_product-val">primes_count_upper_by_product</a> : thm
<a name="line374"></a>    val <a href="#primes_upto_0-val">primes_upto_0</a> : thm
<a name="line375"></a>    val <a href="#primes_upto_1-val">primes_upto_1</a> : thm
<a name="line376"></a>    val <a href="#primes_upto_element-val">primes_upto_element</a> : thm
<a name="line377"></a>    val <a href="#primes_upto_finite-val">primes_upto_finite</a> : thm
<a name="line378"></a>    val <a href="#primes_upto_pairwise_coprime-val">primes_upto_pairwise_coprime</a> : thm
<a name="line379"></a>    val <a href="#primes_upto_subset_natural-val">primes_upto_subset_natural</a> : thm
<a name="line380"></a>    val <a href="#proper_divisors_0-val">proper_divisors_0</a> : thm
<a name="line381"></a>    val <a href="#proper_divisors_1-val">proper_divisors_1</a> : thm
<a name="line382"></a>    val <a href="#proper_divisors_by_less_divisors-val">proper_divisors_by_less_divisors</a> : thm
<a name="line383"></a>    val <a href="#proper_divisors_element-val">proper_divisors_element</a> : thm
<a name="line384"></a>    val <a href="#proper_divisors_finite-val">proper_divisors_finite</a> : thm
<a name="line385"></a>    val <a href="#proper_divisors_has_cofactor-val">proper_divisors_has_cofactor</a> : thm
<a name="line386"></a>    val <a href="#proper_divisors_max_min-val">proper_divisors_max_min</a> : thm
<a name="line387"></a>    val <a href="#proper_divisors_min_gt_1-val">proper_divisors_min_gt_1</a> : thm
<a name="line388"></a>    val <a href="#proper_divisors_not_1-val">proper_divisors_not_1</a> : thm
<a name="line389"></a>    val <a href="#proper_divisors_prime-val">proper_divisors_prime</a> : thm
<a name="line390"></a>    val <a href="#proper_divisors_subset-val">proper_divisors_subset</a> : thm
<a name="line391"></a>    val <a href="#rec_phi_0-val">rec_phi_0</a> : thm
<a name="line392"></a>    val <a href="#rec_phi_1-val">rec_phi_1</a> : thm
<a name="line393"></a>    val <a href="#rec_phi_def-val">rec_phi_def</a> : thm
<a name="line394"></a>    val <a href="#rec_phi_eq_phi-val">rec_phi_eq_phi</a> : thm
<a name="line395"></a>    val <a href="#rec_phi_ind-val">rec_phi_ind</a> : thm
<a name="line396"></a>    val <a href="#self_to_log_index_member-val">self_to_log_index_member</a> : thm
<a name="line397"></a>    val <a href="#set_lcm_prime_powers_upto_eqn-val">set_lcm_prime_powers_upto_eqn</a> : thm
<a name="line398"></a>    val <a href="#sigma_eq_perfect_power_bounds_1-val">sigma_eq_perfect_power_bounds_1</a> : thm
<a name="line399"></a>    val <a href="#sigma_eq_perfect_power_bounds_2-val">sigma_eq_perfect_power_bounds_2</a> : thm
<a name="line400"></a>    val <a href="#sq_free_disjoint-val">sq_free_disjoint</a> : thm
<a name="line401"></a>    val <a href="#sq_free_disjoint_even_odd-val">sq_free_disjoint_even_odd</a> : thm
<a name="line402"></a>    val <a href="#sq_free_element-val">sq_free_element</a> : thm
<a name="line403"></a>    val <a href="#sq_free_finite-val">sq_free_finite</a> : thm
<a name="line404"></a>    val <a href="#sq_free_inter-val">sq_free_inter</a> : thm
<a name="line405"></a>    val <a href="#sq_free_inter_even_odd-val">sq_free_inter_even_odd</a> : thm
<a name="line406"></a>    val <a href="#sq_free_split-val">sq_free_split</a> : thm
<a name="line407"></a>    val <a href="#sq_free_split_even_odd-val">sq_free_split_even_odd</a> : thm
<a name="line408"></a>    val <a href="#sq_free_subset-val">sq_free_subset</a> : thm
<a name="line409"></a>    val <a href="#sq_free_union-val">sq_free_union</a> : thm
<a name="line410"></a>    val <a href="#sq_free_union_even_odd-val">sq_free_union_even_odd</a> : thm
<a name="line411"></a>    val <a href="#sqrt_upper-val">sqrt_upper</a> : thm
<a name="line412"></a>    val <a href="#square_0-val">square_0</a> : thm
<a name="line413"></a>    val <a href="#square_1-val">square_1</a> : thm
<a name="line414"></a>    val <a href="#square_alt-val">square_alt</a> : thm
<a name="line415"></a>    val <a href="#square_eqn-val">square_eqn</a> : thm
<a name="line416"></a>    val <a href="#square_free_1-val">square_free_1</a> : thm
<a name="line417"></a>    val <a href="#square_free_prime-val">square_free_prime</a> : thm
<a name="line418"></a>    val <a href="#sum_image_divisors_cong-val">sum_image_divisors_cong</a> : thm
<a name="line419"></a>    val <a href="#sum_over_count_by_divisors-val">sum_over_count_by_divisors</a> : thm
<a name="line420"></a>    val <a href="#sum_over_count_by_gcd_partition-val">sum_over_count_by_gcd_partition</a> : thm
<a name="line421"></a>    val <a href="#sum_over_natural_by_divisors-val">sum_over_natural_by_divisors</a> : thm
<a name="line422"></a>    val <a href="#sum_over_natural_by_gcd_partition-val">sum_over_natural_by_gcd_partition</a> : thm
<a name="line423"></a>    val <a href="#sum_over_natural_by_preimage_divisors-val">sum_over_natural_by_preimage_divisors</a> : thm
<a name="line424"></a>    val <a href="#sum_over_upto_by_divisors-val">sum_over_upto_by_divisors</a> : thm
<a name="line425"></a>    val <a href="#sum_over_upto_by_gcd_partition-val">sum_over_upto_by_gcd_partition</a> : thm
<a name="line426"></a>    val <a href="#total_prime_divisors_element-val">total_prime_divisors_element</a> : thm
<a name="line427"></a>    val <a href="#total_prime_divisors_finite-val">total_prime_divisors_finite</a> : thm
<a name="line428"></a>    val <a href="#total_prime_divisors_max_image_pairwise_coprime-val">total_prime_divisors_max_image_pairwise_coprime</a> : thm
<a name="line429"></a>    val <a href="#total_prime_divisors_pairwise_coprime-val">total_prime_divisors_pairwise_coprime</a> : thm
<a name="line430"></a>    val <a href="#two_factors_property-val">two_factors_property</a> : thm
<a name="line431"></a>    val <a href="#two_factors_property_1-val">two_factors_property_1</a> : thm
<a name="line432"></a>    val <a href="#two_factors_property_2-val">two_factors_property_2</a> : thm
<a name="line433"></a>    val <a href="#ulog_0-val">ulog_0</a> : thm
<a name="line434"></a>    val <a href="#ulog_1-val">ulog_1</a> : thm
<a name="line435"></a>    val <a href="#ulog_2-val">ulog_2</a> : thm
<a name="line436"></a>    val <a href="#ulog_2_exp-val">ulog_2_exp</a> : thm
<a name="line437"></a>    val <a href="#ulog_LOG2-val">ulog_LOG2</a> : thm
<a name="line438"></a>    val <a href="#ulog_alt-val">ulog_alt</a> : thm
<a name="line439"></a>    val <a href="#ulog_def_alt-val">ulog_def_alt</a> : thm
<a name="line440"></a>    val <a href="#ulog_eq_0-val">ulog_eq_0</a> : thm
<a name="line441"></a>    val <a href="#ulog_eq_1-val">ulog_eq_1</a> : thm
<a name="line442"></a>    val <a href="#ulog_eq_self-val">ulog_eq_self</a> : thm
<a name="line443"></a>    val <a href="#ulog_eqn-val">ulog_eqn</a> : thm
<a name="line444"></a>    val <a href="#ulog_even-val">ulog_even</a> : thm
<a name="line445"></a>    val <a href="#ulog_exp-val">ulog_exp</a> : thm
<a name="line446"></a>    val <a href="#ulog_exp_exact-val">ulog_exp_exact</a> : thm
<a name="line447"></a>    val <a href="#ulog_exp_not_exact-val">ulog_exp_not_exact</a> : thm
<a name="line448"></a>    val <a href="#ulog_ge_1-val">ulog_ge_1</a> : thm
<a name="line449"></a>    val <a href="#ulog_half-val">ulog_half</a> : thm
<a name="line450"></a>    val <a href="#ulog_le-val">ulog_le</a> : thm
<a name="line451"></a>    val <a href="#ulog_le_1-val">ulog_le_1</a> : thm
<a name="line452"></a>    val <a href="#ulog_le_self-val">ulog_le_self</a> : thm
<a name="line453"></a>    val <a href="#ulog_lt-val">ulog_lt</a> : thm
<a name="line454"></a>    val <a href="#ulog_lt_self-val">ulog_lt_self</a> : thm
<a name="line455"></a>    val <a href="#ulog_mult-val">ulog_mult</a> : thm
<a name="line456"></a>    val <a href="#ulog_odd-val">ulog_odd</a> : thm
<a name="line457"></a>    val <a href="#ulog_pos-val">ulog_pos</a> : thm
<a name="line458"></a>    val <a href="#ulog_property-val">ulog_property</a> : thm
<a name="line459"></a>    val <a href="#ulog_property_not_exact-val">ulog_property_not_exact</a> : thm
<a name="line460"></a>    val <a href="#ulog_property_odd-val">ulog_property_odd</a> : thm
<a name="line461"></a>    val <a href="#ulog_sq_gt_1-val">ulog_sq_gt_1</a> : thm
<a name="line462"></a>    val <a href="#ulog_suc-val">ulog_suc</a> : thm
<a name="line463"></a>    val <a href="#ulog_thm-val">ulog_thm</a> : thm
<a name="line464"></a>    val <a href="#ulog_twice_sq-val">ulog_twice_sq</a> : thm
<a name="line465"></a>    val <a href="#ulog_unique-val">ulog_unique</a> : thm
<a name="line466"></a>(*
   [combinatorics] Parent theory of "prime"
   
   [<a name="coprimes_by_def-val"><b>coprimes_by_def</b></a>]  Definition
      
      ⊢ ∀n d.
          coprimes_by n d =
          if 0 &lt; n ∧ d divides n then coprimes (n DIV d) else ∅
   
   [<a name="divisors_def-val"><b>divisors_def</b></a>]  Definition
      
      ⊢ ∀n. divisors n = {d | 0 &lt; d ∧ d ≤ n ∧ d divides n}
   
   [<a name="gcd_matches_def-val"><b>gcd_matches_def</b></a>]  Definition
      
      ⊢ ∀n d. gcd_matches n d = {j | j ∈ natural n ∧ gcd j n = d}
   
   [<a name="halves_def_primitive-val"><b>halves_def_primitive</b></a>]  Definition
      
      ⊢ halves =
        WFREC (@R. WF R ∧ ∀n. n ≠ 0 ⇒ R (HALF n) n)
          (λhalves a. I (if a = 0 then 0 else SUC (halves (HALF a))))
   
   [<a name="lcm_fun_def-val"><b>lcm_fun_def</b></a>]  Definition
      
      ⊢ lcm_fun 0 = 1 ∧
        ∀n. lcm_fun (SUC n) =
            if n = 0 then 1
            else
              case some p. ∃k. 0 &lt; k ∧ prime p ∧ SUC n = p ** k of
                NONE =&gt; lcm_fun n
              | SOME p =&gt; p * lcm_fun n
   
   [<a name="multiples_upto_def-val"><b>multiples_upto_def</b></a>]  Definition
      
      ⊢ ∀m n. m multiples_upto n = {x | m divides x ∧ 0 &lt; x ∧ x ≤ n}
   
   [<a name="perfect_power_def-val"><b>perfect_power_def</b></a>]  Definition
      
      ⊢ ∀n m. n power_of m ⇔ ∃e. n = m ** e
   
   [<a name="phi_def-val"><b>phi_def</b></a>]  Definition
      
      ⊢ ∀n. phi n = CARD (coprimes n)
   
   [<a name="power_free_def-val"><b>power_free_def</b></a>]  Definition
      
      ⊢ ∀n. power_free n ⇔ ∀m e. n = m ** e ⇒ m = n ∧ e = 1
   
   [<a name="power_free_test_def-val"><b>power_free_test_def</b></a>]  Definition
      
      ⊢ ∀n. power_free_test n ⇔ 1 &lt; n ∧ n power_free_upto ulog n
   
   [<a name="power_free_upto_def-val"><b>power_free_upto_def</b></a>]  Definition
      
      ⊢ ∀n k. n power_free_upto k ⇔ ∀j. 1 &lt; j ∧ j ≤ k ⇒ ROOT j n ** j ≠ n
   
   [<a name="prime_divisors_def-val"><b>prime_divisors_def</b></a>]  Definition
      
      ⊢ ∀n. prime_divisors n = {p | prime p ∧ p divides n}
   
   [<a name="prime_factors_def-val"><b>prime_factors_def</b></a>]  Definition
      
      ⊢ ∀n. prime_factors n = {p | prime p ∧ p ∈ divisors n}
   
   [<a name="prime_power_divisors_def-val"><b>prime_power_divisors_def</b></a>]  Definition
      
      ⊢ ∀n. prime_power_divisors n =
            IMAGE (λp. p ** ppidx n) (prime_divisors n)
   
   [<a name="prime_power_index_def-val"><b>prime_power_index_def</b></a>]  Definition
      
      ⊢ ∀p n.
          0 &lt; n ∧ prime p ⇒
          p ** ppidx n divides n ∧ coprime p (n DIV p ** ppidx n)
   
   [<a name="prime_powers_upto_def-val"><b>prime_powers_upto_def</b></a>]  Definition
      
      ⊢ ∀n. prime_powers_upto n = IMAGE (λp. p ** LOG p n) (primes_upto n)
   
   [<a name="prime_test_def-val"><b>prime_test_def</b></a>]  Definition
      
      ⊢ ∀n. prime_test n ⇔
            if n ≤ 1 then F else factor_seek n (1 + SQRT n) 2 = n
   
   [<a name="primes_upto_def-val"><b>primes_upto_def</b></a>]  Definition
      
      ⊢ ∀n. primes_upto n = {p | prime p ∧ p ≤ n}
   
   [<a name="rec_phi_def_primitive-val"><b>rec_phi_def_primitive</b></a>]  Definition
      
      ⊢ rec_phi =
        WFREC
          (@R. WF R ∧
               ∀n a. n ≠ 0 ∧ n ≠ 1 ∧ a ∈ {m | m &lt; n ∧ m divides n} ⇒ R a n)
          (λrec_phi a'.
               I
                 (if a' = 0 then 0
                  else if a' = 1 then 1
                  else a' − ∑ (λa. rec_phi a) {m | m &lt; a' ∧ m divides a'}))
   
   [<a name="square_def-val"><b>square_def</b></a>]  Definition
      
      ⊢ ∀n. square n ⇔ ∃k. n = SQ k
   
   [<a name="square_free_def-val"><b>square_free_def</b></a>]  Definition
      
      ⊢ ∀n. square_free n ⇔ ∀p. prime p ∧ p divides n ⇒ ¬(SQ p divides n)
   
   [<a name="ulog_def-val"><b>ulog_def</b></a>]  Definition
      
      ⊢ ∀n. ulog n = count_up n 1 0
   
   [<a name="Gauss_little_thm-val"><b>Gauss_little_thm</b></a>]  Theorem
      
      ⊢ ∀n. ∑ phi (divisors n) = n
   
   [<a name="LOG2_BY_HALF-val"><b>LOG2_BY_HALF</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ LOG2 n = 1 + LOG2 (HALF n)
   
   [<a name="LOG2_DIV_EXP-val"><b>LOG2_DIV_EXP</b></a>]  Theorem
      
      ⊢ ∀n m. 2 ** m &lt; n ⇒ LOG2 (n DIV 2 ** m) = LOG2 n − m
   
   [<a name="LOG2_HALF-val"><b>LOG2_HALF</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ LOG2 (HALF n) = LOG2 n − 1
   
   [<a name="LOG2_SUC_TIMES_SQ_DIV_2_POS-val"><b>LOG2_SUC_TIMES_SQ_DIV_2_POS</b></a>]  Theorem
      
      ⊢ ∀n m. 1 &lt; m ⇒ 0 &lt; SUC (LOG2 n) * HALF m²
   
   [<a name="LOG2_compute-val"><b>LOG2_compute</b></a>]  Theorem
      
      ⊢ ∀n. LOG2 n = if n = 0 then LOG2 0 else halves n − 1
   
   [<a name="LOG_SUC-val"><b>LOG_SUC</b></a>]  Theorem
      
      ⊢ ∀b n.
          1 &lt; b ∧ 0 &lt; n ⇒
          LOG b (SUC n) = LOG b n + if SUC n power_of b then 1 else 0
   
   [<a name="ROOT_EQN-val"><b>ROOT_EQN</b></a>]  Theorem
      
      ⊢ ∀r n.
          0 &lt; r ⇒
          ROOT r n =
          (let
             m = TWICE (ROOT r (n DIV 2 ** r))
           in
             m + if (m + 1) ** r ≤ n then 1 else 0)
   
   [<a name="SQRT_LE_IMP-val"><b>SQRT_LE_IMP</b></a>]  Theorem
      
      ⊢ ∀n m. SQRT n ≤ m ⇒ n ≤ 3 * m²
   
   [<a name="SQRT_LE_SELF-val"><b>SQRT_LE_SELF</b></a>]  Theorem
      
      ⊢ ∀n. SQRT n ≤ n
   
   [<a name="SQRT_MULT_LE-val"><b>SQRT_MULT_LE</b></a>]  Theorem
      
      ⊢ ∀n m. SQRT n * SQRT m ≤ SQRT (n * m)
   
   [<a name="SQRT_SQ-val"><b>SQRT_SQ</b></a>]  Theorem
      
      ⊢ ∀n. SQRT (SQ n) = n
   
   [<a name="SQ_SQRT_LE-val"><b>SQ_SQRT_LE</b></a>]  Theorem
      
      ⊢ ∀n. SQ (SQRT n) ≤ n
   
   [<a name="SQ_SQRT_LE_alt-val"><b>SQ_SQRT_LE_alt</b></a>]  Theorem
      
      ⊢ ∀n. (SQRT n)² ≤ n
   
   [<a name="SQ_SQRT_LT-val"><b>SQ_SQRT_LT</b></a>]  Theorem
      
      ⊢ ∀n. ¬square n ⇒ SQ (SQRT n) &lt; n
   
   [<a name="SQ_SQRT_LT_alt-val"><b>SQ_SQRT_LT_alt</b></a>]  Theorem
      
      ⊢ ∀n. ¬square n ⇒ (SQRT n)² &lt; n
   
   [<a name="basic_prime_factorisation-val"><b>basic_prime_factorisation</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒
            n = PROD_SET (IMAGE (λp. p ** ppidx n) (prime_divisors n))
   
   [<a name="common_prime_divisors_element-val"><b>common_prime_divisors_element</b></a>]  Theorem
      
      ⊢ ∀m n p.
          p ∈ common_prime_divisors m n ⇔
          p ∈ prime_divisors m ∧ p ∈ prime_divisors n
   
   [<a name="common_prime_divisors_finite-val"><b>common_prime_divisors_finite</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ∧ 0 &lt; n ⇒ FINITE (common_prime_divisors m n)
   
   [<a name="common_prime_divisors_min_image_pairwise_coprime-val"><b>common_prime_divisors_min_image_pairwise_coprime</b></a>]  Theorem
      
      ⊢ ∀m n x y.
          x ∈
          IMAGE (λp. p ** MIN (ppidx m) (ppidx n))
            (common_prime_divisors m n) ∧
          y ∈
          IMAGE (λp. p ** MIN (ppidx m) (ppidx n))
            (common_prime_divisors m n) ∧ x ≠ y ⇒
          coprime x y
   
   [<a name="common_prime_divisors_pairwise_coprime-val"><b>common_prime_divisors_pairwise_coprime</b></a>]  Theorem
      
      ⊢ ∀m n x y.
          x ∈ common_prime_divisors m n ∧ y ∈ common_prime_divisors m n ∧
          x ≠ y ⇒
          coprime x y
   
   [<a name="coprimes_by_0-val"><b>coprimes_by_0</b></a>]  Theorem
      
      ⊢ ∀d. coprimes_by 0 d = ∅
   
   [<a name="coprimes_by_by_0-val"><b>coprimes_by_by_0</b></a>]  Theorem
      
      ⊢ ∀n. coprimes_by n 0 = ∅
   
   [<a name="coprimes_by_by_1-val"><b>coprimes_by_by_1</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ coprimes_by n 1 = coprimes n
   
   [<a name="coprimes_by_by_divisor-val"><b>coprimes_by_by_divisor</b></a>]  Theorem
      
      ⊢ ∀n d. 0 &lt; n ∧ d divides n ⇒ coprimes_by n d = coprimes (n DIV d)
   
   [<a name="coprimes_by_by_last-val"><b>coprimes_by_by_last</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ coprimes_by n n = {1}
   
   [<a name="coprimes_by_divisors_card-val"><b>coprimes_by_divisors_card</b></a>]  Theorem
      
      ⊢ ∀n x.
          x ∈ divisors n ⇒ (CARD ∘ coprimes_by n) x = (λd. phi (n DIV d)) x
   
   [<a name="coprimes_by_element-val"><b>coprimes_by_element</b></a>]  Theorem
      
      ⊢ ∀n d j.
          j ∈ coprimes_by n d ⇔
          0 &lt; n ∧ d divides n ∧ j ∈ coprimes (n DIV d)
   
   [<a name="coprimes_by_eq_empty-val"><b>coprimes_by_eq_empty</b></a>]  Theorem
      
      ⊢ ∀n d. 0 &lt; n ⇒ (coprimes_by n d = ∅ ⇔ ¬(d divides n))
   
   [<a name="coprimes_by_finite-val"><b>coprimes_by_finite</b></a>]  Theorem
      
      ⊢ ∀n d. FINITE (coprimes_by n d)
   
   [<a name="coprimes_by_with_card-val"><b>coprimes_by_with_card</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒
            CARD ∘ coprimes_by n =
            (λd. phi (if d ∈ divisors n then n DIV d else 0))
   
   [<a name="coprimes_eq_Euler-val"><b>coprimes_eq_Euler</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ coprimes n = Euler n
   
   [<a name="coprimes_from_not_1_inj-val"><b>coprimes_from_not_1_inj</b></a>]  Theorem
      
      ⊢ INJ coprimes (𝕌(:num) DIFF {1}) 𝕌(:num -&gt; bool)
   
   [<a name="coprimes_map_cross_inj-val"><b>coprimes_map_cross_inj</b></a>]  Theorem
      
      ⊢ ∀m n.
          coprime m n ⇒
          INJ
            (λ(x,y). if m * n = 1 then 1 else (x * n + y * m) MOD (m * n))
            (coprimes m × coprimes n) 𝕌(:num)
   
   [<a name="coprimes_mult_by_image-val"><b>coprimes_mult_by_image</b></a>]  Theorem
      
      ⊢ ∀m n.
          coprime m n ⇒
          coprimes (m * n) =
          IMAGE
            (λ(x,y). if m * n = 1 then 1 else (x * n + y * m) MOD (m * n))
            (coprimes m × coprimes n)
   
   [<a name="coprimes_prime-val"><b>coprimes_prime</b></a>]  Theorem
      
      ⊢ ∀n. prime n ⇒ coprimes n = residue n
   
   [<a name="coprimes_prime_power-val"><b>coprimes_prime_power</b></a>]  Theorem
      
      ⊢ ∀p n.
          prime p ⇒
          coprimes (p ** n) = natural (p ** n) DIFF p multiples_upto p ** n
   
   [<a name="coprimes_thm-val"><b>coprimes_thm</b></a>]  Theorem
      
      ⊢ ∀n. coprimes n = set (FILTER (λj. coprime j n) (GENLIST SUC n))
   
   [<a name="count_up_def-val"><b>count_up_def</b></a>]  Theorem
      
      ⊢ ∀n m k.
          count_up n m k =
          if m = 0 then 0
          else if n ≤ m then k
          else count_up n (TWICE m) (SUC k)
   
   [<a name="count_up_exit-val"><b>count_up_exit</b></a>]  Theorem
      
      ⊢ ∀m n. m ≠ 0 ∧ n ≤ m ⇒ ∀k. count_up n m k = k
   
   [<a name="count_up_exit_eqn-val"><b>count_up_exit_eqn</b></a>]  Theorem
      
      ⊢ ∀m. m ≠ 0 ⇒
            ∀n t.
              2 ** t * m &lt; TWICE n ∧ n ≤ 2 ** t * m ⇒
              ∀k. count_up n m k = k + t
   
   [<a name="count_up_ind-val"><b>count_up_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀n m k. (m ≠ 0 ∧ ¬(n ≤ m) ⇒ P n (TWICE m) (SUC k)) ⇒ P n m k) ⇒
            ∀v v1 v2. P v v1 v2
   
   [<a name="count_up_suc-val"><b>count_up_suc</b></a>]  Theorem
      
      ⊢ ∀m n.
          m ≠ 0 ∧ m &lt; n ⇒ ∀k. count_up n m k = count_up n (TWICE m) (SUC k)
   
   [<a name="count_up_suc_eqn-val"><b>count_up_suc_eqn</b></a>]  Theorem
      
      ⊢ ∀m. m ≠ 0 ⇒
            ∀n t.
              2 ** t * m &lt; n ⇒
              ∀k. count_up n m k = count_up n (2 ** SUC t * m) (SUC k + t)
   
   [<a name="divisor_gt_cofactor_le-val"><b>divisor_gt_cofactor_le</b></a>]  Theorem
      
      ⊢ ∀n p. 0 &lt; p ∧ p divides n ∧ SQRT n &lt; p ⇒ n DIV p ≤ SQRT n
   
   [<a name="divisor_le_cofactor_ge-val"><b>divisor_le_cofactor_ge</b></a>]  Theorem
      
      ⊢ ∀n p. 0 &lt; p ∧ p divides n ∧ p ≤ SQRT n ⇒ SQRT n ≤ n DIV p
   
   [<a name="divisor_prime_factorisation-val"><b>divisor_prime_factorisation</b></a>]  Theorem
      
      ⊢ ∀m n.
          0 &lt; n ∧ m divides n ⇒
          m = PROD_SET (IMAGE (λp. p ** ppidx m) (prime_divisors n))
   
   [<a name="divisors_0-val"><b>divisors_0</b></a>]  Theorem
      
      ⊢ divisors 0 = ∅
   
   [<a name="divisors_1-val"><b>divisors_1</b></a>]  Theorem
      
      ⊢ divisors 1 = {1}
   
   [<a name="divisors_card_upper-val"><b>divisors_card_upper</b></a>]  Theorem
      
      ⊢ ∀n. CARD (divisors n) ≤ TWICE (SQRT n)
   
   [<a name="divisors_cofactor_inj-val"><b>divisors_cofactor_inj</b></a>]  Theorem
      
      ⊢ ∀n. INJ (λj. n DIV j) (divisors n) 𝕌(:num)
   
   [<a name="divisors_delete_last-val"><b>divisors_delete_last</b></a>]  Theorem
      
      ⊢ ∀n. divisors n DELETE n = {m | 0 &lt; m ∧ m &lt; n ∧ m divides n}
   
   [<a name="divisors_divisors_bij-val"><b>divisors_divisors_bij</b></a>]  Theorem
      
      ⊢ ∀n. (λd. n DIV d) PERMUTES divisors n
   
   [<a name="divisors_element-val"><b>divisors_element</b></a>]  Theorem
      
      ⊢ ∀n d. d ∈ divisors n ⇔ 0 &lt; d ∧ d ≤ n ∧ d divides n
   
   [<a name="divisors_element_alt-val"><b>divisors_element_alt</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀d. d ∈ divisors n ⇔ d divides n
   
   [<a name="divisors_eq_empty-val"><b>divisors_eq_empty</b></a>]  Theorem
      
      ⊢ ∀n. divisors n = ∅ ⇔ n = 0
   
   [<a name="divisors_eq_gcd_image-val"><b>divisors_eq_gcd_image</b></a>]  Theorem
      
      ⊢ ∀n. divisors n = IMAGE (gcd n) (natural n)
   
   [<a name="divisors_eq_image_gcd_count-val"><b>divisors_eq_image_gcd_count</b></a>]  Theorem
      
      ⊢ ∀n. divisors n = IMAGE (gcd n) (count n)
   
   [<a name="divisors_eq_image_gcd_natural-val"><b>divisors_eq_image_gcd_natural</b></a>]  Theorem
      
      ⊢ ∀n. divisors n = IMAGE (gcd n) (natural n)
   
   [<a name="divisors_eq_image_gcd_upto-val"><b>divisors_eq_image_gcd_upto</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ divisors n = IMAGE (gcd n) (upto n)
   
   [<a name="divisors_eqn-val"><b>divisors_eqn</b></a>]  Theorem
      
      ⊢ ∀n. divisors n =
            IMAGE (λj. if j + 1 divides n then j + 1 else 1) (count n)
   
   [<a name="divisors_finite-val"><b>divisors_finite</b></a>]  Theorem
      
      ⊢ ∀n. FINITE (divisors n)
   
   [<a name="divisors_has_1-val"><b>divisors_has_1</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ 1 ∈ divisors n
   
   [<a name="divisors_has_cofactor-val"><b>divisors_has_cofactor</b></a>]  Theorem
      
      ⊢ ∀n d. d ∈ divisors n ⇒ n DIV d ∈ divisors n
   
   [<a name="divisors_has_element-val"><b>divisors_has_element</b></a>]  Theorem
      
      ⊢ ∀n d. d ∈ divisors n ⇒ 0 &lt; n
   
   [<a name="divisors_has_factor-val"><b>divisors_has_factor</b></a>]  Theorem
      
      ⊢ ∀n p q. 0 &lt; n ∧ n = p * q ⇒ p ∈ divisors n ∧ q ∈ divisors n
   
   [<a name="divisors_has_last-val"><b>divisors_has_last</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ n ∈ divisors n
   
   [<a name="divisors_nonzero-val"><b>divisors_nonzero</b></a>]  Theorem
      
      ⊢ ∀n d. d ∈ divisors n ⇒ 0 &lt; d
   
   [<a name="divisors_not_empty-val"><b>divisors_not_empty</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ divisors n ≠ ∅
   
   [<a name="divisors_subset_natural-val"><b>divisors_subset_natural</b></a>]  Theorem
      
      ⊢ ∀n. divisors n ⊆ natural n
   
   [<a name="even_sq_free_element-val"><b>even_sq_free_element</b></a>]  Theorem
      
      ⊢ ∀s n.
          n ∈ even_sq_free s ⇔
          n ∈ s ∧ square_free n ∧ EVEN (CARD (prime_factors n))
   
   [<a name="even_sq_free_finite-val"><b>even_sq_free_finite</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ FINITE (even_sq_free s)
   
   [<a name="even_sq_free_subset-val"><b>even_sq_free_subset</b></a>]  Theorem
      
      ⊢ ∀s. even_sq_free s ⊆ s
   
   [<a name="exp_to_ulog-val"><b>exp_to_ulog</b></a>]  Theorem
      
      ⊢ ∀m n. n ≤ 2 ** m ⇒ ulog n ≤ m
   
   [<a name="factor_seek_bound-val"><b>factor_seek_bound</b></a>]  Theorem
      
      ⊢ ∀n c q. 0 &lt; n ⇒ factor_seek n c q ≤ n
   
   [<a name="factor_seek_def-val"><b>factor_seek_def</b></a>]  Theorem
      
      ⊢ ∀q n c.
          factor_seek n c q =
          if c ≤ q then n
          else if 1 &lt; q ∧ n MOD q = 0 then q
          else factor_seek n c (q + 1)
   
   [<a name="factor_seek_ind-val"><b>factor_seek_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀n c q.
               (¬(c ≤ q) ∧ ¬(1 &lt; q ∧ n MOD q = 0) ⇒ P n c (q + 1)) ⇒
               P n c q) ⇒
            ∀v v1 v2. P v v1 v2
   
   [<a name="factor_seek_thm-val"><b>factor_seek_thm</b></a>]  Theorem
      
      ⊢ ∀n c q.
          1 &lt; q ∧ q ≤ c ∧ c ≤ n ⇒
          (factor_seek n c q = n ⇔ ∀p. q ≤ p ∧ p &lt; c ⇒ ¬(p divides n))
   
   [<a name="gcd_eq_count_partition_by_divisors-val"><b>gcd_eq_count_partition_by_divisors</b></a>]  Theorem
      
      ⊢ ∀n. partition (feq (gcd n)) (count n) =
            IMAGE (preimage (gcd n) (count n)) (divisors n)
   
   [<a name="gcd_eq_equiv_class-val"><b>gcd_eq_equiv_class</b></a>]  Theorem
      
      ⊢ ∀n d. preimage (gcd n) (natural n) d = gcd_matches n d
   
   [<a name="gcd_eq_equiv_class_fun-val"><b>gcd_eq_equiv_class_fun</b></a>]  Theorem
      
      ⊢ ∀n. preimage (gcd n) (natural n) = gcd_matches n
   
   [<a name="gcd_eq_equiv_on_count-val"><b>gcd_eq_equiv_on_count</b></a>]  Theorem
      
      ⊢ ∀n. feq (gcd n) equiv_on count n
   
   [<a name="gcd_eq_equiv_on_natural-val"><b>gcd_eq_equiv_on_natural</b></a>]  Theorem
      
      ⊢ ∀n. feq (gcd n) equiv_on natural n
   
   [<a name="gcd_eq_equiv_on_upto-val"><b>gcd_eq_equiv_on_upto</b></a>]  Theorem
      
      ⊢ ∀n. feq (gcd n) equiv_on upto n
   
   [<a name="gcd_eq_natural_partition_by_divisors-val"><b>gcd_eq_natural_partition_by_divisors</b></a>]  Theorem
      
      ⊢ ∀n. partition (feq (gcd n)) (natural n) =
            IMAGE (preimage (gcd n) (natural n)) (divisors n)
   
   [<a name="gcd_eq_partition_by_divisors-val"><b>gcd_eq_partition_by_divisors</b></a>]  Theorem
      
      ⊢ ∀n. partition (feq (gcd n)) (natural n) =
            IMAGE (gcd_matches n) (divisors n)
   
   [<a name="gcd_eq_upto_partition_by_divisors-val"><b>gcd_eq_upto_partition_by_divisors</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒
            partition (feq (gcd n)) (upto n) =
            IMAGE (preimage (gcd n) (upto n)) (divisors n)
   
   [<a name="gcd_matches_0-val"><b>gcd_matches_0</b></a>]  Theorem
      
      ⊢ ∀d. gcd_matches 0 d = ∅
   
   [<a name="gcd_matches_1-val"><b>gcd_matches_1</b></a>]  Theorem
      
      ⊢ ∀d. gcd_matches 1 d = if d = 1 then {1} else ∅
   
   [<a name="gcd_matches_alt-val"><b>gcd_matches_alt</b></a>]  Theorem
      
      ⊢ ∀n d. gcd_matches n d = natural n ∩ {j | gcd j n = d}
   
   [<a name="gcd_matches_and_coprimes_by_same_size-val"><b>gcd_matches_and_coprimes_by_same_size</b></a>]  Theorem
      
      ⊢ ∀n. CARD ∘ gcd_matches n = CARD ∘ coprimes_by n
   
   [<a name="gcd_matches_bij_coprimes-val"><b>gcd_matches_bij_coprimes</b></a>]  Theorem
      
      ⊢ ∀n d.
          0 &lt; n ∧ d divides n ⇒
          BIJ (λj. j DIV d) (gcd_matches n d) (coprimes (n DIV d))
   
   [<a name="gcd_matches_bij_coprimes_by-val"><b>gcd_matches_bij_coprimes_by</b></a>]  Theorem
      
      ⊢ ∀n d.
          d divides n ⇒
          BIJ (λj. j DIV d) (gcd_matches n d) (coprimes_by n d)
   
   [<a name="gcd_matches_divisor_element-val"><b>gcd_matches_divisor_element</b></a>]  Theorem
      
      ⊢ ∀n d.
          d divides n ⇒ ∀j. j ∈ gcd_matches n d ⇒ j DIV d ∈ coprimes_by n d
   
   [<a name="gcd_matches_element-val"><b>gcd_matches_element</b></a>]  Theorem
      
      ⊢ ∀n d j. j ∈ gcd_matches n d ⇔ 0 &lt; j ∧ j ≤ n ∧ gcd j n = d
   
   [<a name="gcd_matches_element_divides-val"><b>gcd_matches_element_divides</b></a>]  Theorem
      
      ⊢ ∀n d j. j ∈ gcd_matches n d ⇒ d divides j ∧ d divides n
   
   [<a name="gcd_matches_eq_empty-val"><b>gcd_matches_eq_empty</b></a>]  Theorem
      
      ⊢ ∀n d. 0 &lt; n ⇒ (gcd_matches n d = ∅ ⇔ ¬(d divides n))
   
   [<a name="gcd_matches_finite-val"><b>gcd_matches_finite</b></a>]  Theorem
      
      ⊢ ∀n d. FINITE (gcd_matches n d)
   
   [<a name="gcd_matches_from_divisors_inj-val"><b>gcd_matches_from_divisors_inj</b></a>]  Theorem
      
      ⊢ ∀n. INJ (gcd_matches n) (divisors n) 𝕌(:num -&gt; bool)
   
   [<a name="gcd_matches_has_divisor-val"><b>gcd_matches_has_divisor</b></a>]  Theorem
      
      ⊢ ∀n d. 0 &lt; n ∧ d divides n ⇒ d ∈ gcd_matches n d
   
   [<a name="gcd_matches_subset-val"><b>gcd_matches_subset</b></a>]  Theorem
      
      ⊢ ∀n d. gcd_matches n d ⊆ natural n
   
   [<a name="gcd_matches_with_0-val"><b>gcd_matches_with_0</b></a>]  Theorem
      
      ⊢ ∀n. gcd_matches n 0 = ∅
   
   [<a name="gcd_park_decompose-val"><b>gcd_park_decompose</b></a>]  Theorem
      
      ⊢ ∀m n.
          0 &lt; m ∧ 0 &lt; n ⇒
          (let
             a = park m n;
             b = gcd m n DIV a
           in
             gcd m n = a * b ∧ coprime a b)
   
   [<a name="gcd_park_decomposition-val"><b>gcd_park_decomposition</b></a>]  Theorem
      
      ⊢ ∀m n.
          0 &lt; m ∧ 0 &lt; n ⇒
          (let
             a = park m n;
             b = gcd m n DIV a
           in
             b = PROD_SET (IMAGE (λp. p ** ppidx n) (park_off m n)) ∧
             gcd m n = a * b ∧ coprime a b)
   
   [<a name="gcd_prime_factorisation-val"><b>gcd_prime_factorisation</b></a>]  Theorem
      
      ⊢ ∀m n.
          0 &lt; m ∧ 0 &lt; n ⇒
          gcd m n =
          PROD_SET
            (IMAGE (λp. p ** MIN (ppidx m) (ppidx n))
               (common_prime_divisors m n))
   
   [<a name="gcd_prime_power_cofactor_coprime-val"><b>gcd_prime_power_cofactor_coprime</b></a>]  Theorem
      
      ⊢ ∀a b p.
          0 &lt; a ∧ 0 &lt; b ∧ prime p ⇒
          coprime p (gcd (a DIV p ** ppidx a) (b DIV p ** ppidx b))
   
   [<a name="gcd_prime_power_divisibility-val"><b>gcd_prime_power_divisibility</b></a>]  Theorem
      
      ⊢ ∀a b p.
          0 &lt; a ∧ 0 &lt; b ∧ prime p ⇒
          ∀k. p ** k divides gcd a b ⇒ k ≤ MIN (ppidx a) (ppidx b)
   
   [<a name="gcd_prime_power_factor-val"><b>gcd_prime_power_factor</b></a>]  Theorem
      
      ⊢ ∀a b p.
          0 &lt; a ∧ 0 &lt; b ∧ prime p ⇒
          gcd a b =
          p ** MIN (ppidx a) (ppidx b) *
          gcd (a DIV p ** ppidx a) (b DIV p ** ppidx b)
   
   [<a name="gcd_prime_power_factor_divides_gcd-val"><b>gcd_prime_power_factor_divides_gcd</b></a>]  Theorem
      
      ⊢ ∀a b p.
          0 &lt; a ∧ 0 &lt; b ∧ prime p ⇒
          p ** MIN (ppidx a) (ppidx b) divides gcd a b
   
   [<a name="gcd_prime_power_index-val"><b>gcd_prime_power_index</b></a>]  Theorem
      
      ⊢ ∀a b p.
          0 &lt; a ∧ 0 &lt; b ∧ prime p ⇒
          ppidx (gcd a b) = MIN (ppidx a) (ppidx b)
   
   [<a name="halves_0-val"><b>halves_0</b></a>]  Theorem
      
      ⊢ halves 0 = 0
   
   [<a name="halves_1-val"><b>halves_1</b></a>]  Theorem
      
      ⊢ halves 1 = SUC (halves 0)
   
   [<a name="halves_2-val"><b>halves_2</b></a>]  Theorem
      
      ⊢ halves 2 = SUC (SUC (halves 0))
   
   [<a name="halves_alt-val"><b>halves_alt</b></a>]  Theorem
      
      ⊢ ∀n. halves n = if n = 0 then 0 else 1 + halves (HALF n)
   
   [<a name="halves_by_LOG2-val"><b>halves_by_LOG2</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ halves n = 1 + LOG2 n
   
   [<a name="halves_def-val"><b>halves_def</b></a>]  Theorem
      
      ⊢ ∀n. halves n = if n = 0 then 0 else SUC (halves (HALF n))
   
   [<a name="halves_eq_0-val"><b>halves_eq_0</b></a>]  Theorem
      
      ⊢ ∀n. halves n = 0 ⇔ n = 0
   
   [<a name="halves_eq_1-val"><b>halves_eq_1</b></a>]  Theorem
      
      ⊢ ∀n. halves n = 1 ⇔ n = 1
   
   [<a name="halves_ind-val"><b>halves_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀n. (n ≠ 0 ⇒ P (HALF n)) ⇒ P n) ⇒ ∀v. P v
   
   [<a name="halves_le-val"><b>halves_le</b></a>]  Theorem
      
      ⊢ MONO halves
   
   [<a name="halves_pos-val"><b>halves_pos</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ 0 &lt; halves n
   
   [<a name="lcm_fun_0-val"><b>lcm_fun_0</b></a>]  Theorem
      
      ⊢ lcm_fun 0 = 1
   
   [<a name="lcm_fun_1-val"><b>lcm_fun_1</b></a>]  Theorem
      
      ⊢ lcm_fun 1 = 1
   
   [<a name="lcm_fun_2-val"><b>lcm_fun_2</b></a>]  Theorem
      
      ⊢ lcm_fun 2 = 2
   
   [<a name="lcm_fun_SUC-val"><b>lcm_fun_SUC</b></a>]  Theorem
      
      ⊢ ∀n. lcm_fun (SUC n) =
            if n = 0 then 1
            else
              case some p. ∃k. 0 &lt; k ∧ prime p ∧ SUC n = p ** k of
                NONE =&gt; lcm_fun n
              | SOME p =&gt; p * lcm_fun n
   
   [<a name="lcm_fun_compute-val"><b>lcm_fun_compute</b></a>]  Theorem
      
      ⊢ lcm_fun 0 = 1 ∧
        (∀n. lcm_fun (NUMERAL (BIT1 n)) =
             if NUMERAL (BIT1 n) − 1 = 0 then 1
             else
               case
                 some p. ∃k. 0 &lt; k ∧ prime p ∧ NUMERAL (BIT1 n) = p ** k
               of
                 NONE =&gt; lcm_fun (NUMERAL (BIT1 n) − 1)
               | SOME p =&gt; p * lcm_fun (NUMERAL (BIT1 n) − 1)) ∧
        ∀n. lcm_fun (NUMERAL (BIT2 n)) =
            if NUMERAL (BIT1 n) = 0 then 1
            else
              case
                some p. ∃k. 0 &lt; k ∧ prime p ∧ NUMERAL (BIT2 n) = p ** k
              of
                NONE =&gt; lcm_fun (NUMERAL (BIT1 n))
              | SOME p =&gt; p * lcm_fun (NUMERAL (BIT1 n))
   
   [<a name="lcm_fun_lower_bound-val"><b>lcm_fun_lower_bound</b></a>]  Theorem
      
      ⊢ ∀n. 2 ** n ≤ lcm_fun (n + 1)
   
   [<a name="lcm_fun_lower_bound_alt-val"><b>lcm_fun_lower_bound_alt</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ 2 ** (n − 1) ≤ lcm_fun n
   
   [<a name="lcm_fun_suc_none-val"><b>lcm_fun_suc_none</b></a>]  Theorem
      
      ⊢ ∀n. ¬(∃p k. 0 &lt; k ∧ prime p ∧ SUC n = p ** k) ⇒
            lcm_fun (SUC n) = lcm_fun n
   
   [<a name="lcm_fun_suc_some-val"><b>lcm_fun_suc_some</b></a>]  Theorem
      
      ⊢ ∀n p.
          prime p ∧ (∃k. 0 &lt; k ∧ SUC n = p ** k) ⇒
          lcm_fun (SUC n) = p * lcm_fun n
   
   [<a name="lcm_gcd_park_decompose-val"><b>lcm_gcd_park_decompose</b></a>]  Theorem
      
      ⊢ ∀m n.
          0 &lt; m ∧ 0 &lt; n ⇒
          (let
             a = park m n;
             b = gcd m n DIV a;
             p = m DIV a;
             q = a * n DIV gcd m n
           in
             lcm m n = p * q ∧ coprime p q ∧ gcd m n = a * b ∧ m = a * p ∧
             n = b * q)
   
   [<a name="lcm_park_decompose-val"><b>lcm_park_decompose</b></a>]  Theorem
      
      ⊢ ∀m n.
          0 &lt; m ∧ 0 &lt; n ⇒
          (let
             a = park m n;
             p = m DIV a;
             q = a * n DIV gcd m n
           in
             lcm m n = p * q ∧ coprime p q)
   
   [<a name="lcm_park_decomposition-val"><b>lcm_park_decomposition</b></a>]  Theorem
      
      ⊢ ∀m n.
          0 &lt; m ∧ 0 &lt; n ⇒
          (let
             a = park m n;
             b = gcd m n DIV a;
             p = m DIV a;
             q = a * n DIV gcd m n
           in
             b = PROD_SET (IMAGE (λp. p ** ppidx n) (park_off m n)) ∧
             p =
             PROD_SET
               (IMAGE (λp. p ** ppidx m)
                  (prime_divisors m DIFF park_on m n)) ∧
             q =
             PROD_SET
               (IMAGE (λp. p ** ppidx n)
                  (prime_divisors n DIFF park_off m n)) ∧ lcm m n = p * q ∧
             coprime p q ∧ gcd m n = a * b ∧ m = a * p ∧ n = b * q)
   
   [<a name="lcm_prime_factorisation-val"><b>lcm_prime_factorisation</b></a>]  Theorem
      
      ⊢ ∀m n.
          0 &lt; m ∧ 0 &lt; n ⇒
          lcm m n =
          PROD_SET
            (IMAGE (λp. p ** MAX (ppidx m) (ppidx n))
               (total_prime_divisors m n))
   
   [<a name="lcm_prime_power_cofactor_coprime-val"><b>lcm_prime_power_cofactor_coprime</b></a>]  Theorem
      
      ⊢ ∀a b p.
          0 &lt; a ∧ 0 &lt; b ∧ prime p ⇒
          coprime p (lcm (a DIV p ** ppidx a) (b DIV p ** ppidx b))
   
   [<a name="lcm_prime_power_divisibility-val"><b>lcm_prime_power_divisibility</b></a>]  Theorem
      
      ⊢ ∀a b p.
          0 &lt; a ∧ 0 &lt; b ∧ prime p ⇒
          ∀k. p ** k divides lcm a b ⇒ k ≤ MAX (ppidx a) (ppidx b)
   
   [<a name="lcm_prime_power_factor-val"><b>lcm_prime_power_factor</b></a>]  Theorem
      
      ⊢ ∀a b p.
          0 &lt; a ∧ 0 &lt; b ∧ prime p ⇒
          lcm a b =
          p ** MAX (ppidx a) (ppidx b) *
          lcm (a DIV p ** ppidx a) (b DIV p ** ppidx b)
   
   [<a name="lcm_prime_power_factor_divides_lcm-val"><b>lcm_prime_power_factor_divides_lcm</b></a>]  Theorem
      
      ⊢ ∀a b p.
          0 &lt; a ∧ 0 &lt; b ∧ prime p ⇒
          p ** MAX (ppidx a) (ppidx b) divides lcm a b
   
   [<a name="lcm_prime_power_index-val"><b>lcm_prime_power_index</b></a>]  Theorem
      
      ⊢ ∀a b p.
          0 &lt; a ∧ 0 &lt; b ∧ prime p ⇒
          ppidx (lcm a b) = MAX (ppidx a) (ppidx b)
   
   [<a name="lcm_run_eq_prod_set_prime_powers-val"><b>lcm_run_eq_prod_set_prime_powers</b></a>]  Theorem
      
      ⊢ ∀n. lcm_run n = PROD_SET (prime_powers_upto n)
   
   [<a name="lcm_run_eq_set_lcm_prime_powers-val"><b>lcm_run_eq_set_lcm_prime_powers</b></a>]  Theorem
      
      ⊢ ∀n. lcm_run n = set_lcm (prime_powers_upto n)
   
   [<a name="lcm_run_lower_by_primes_count-val"><b>lcm_run_lower_by_primes_count</b></a>]  Theorem
      
      ⊢ ∀n. SQRT (n ** primes_count n) ≤ lcm_run n
   
   [<a name="lcm_run_lower_by_primes_product-val"><b>lcm_run_lower_by_primes_product</b></a>]  Theorem
      
      ⊢ ∀n. PROD_SET (primes_upto n) ≤ lcm_run n
   
   [<a name="lcm_run_upper_by_primes_count-val"><b>lcm_run_upper_by_primes_count</b></a>]  Theorem
      
      ⊢ ∀n. lcm_run n ≤ n ** primes_count n
   
   [<a name="lcm_special_for_coprime_factors-val"><b>lcm_special_for_coprime_factors</b></a>]  Theorem
      
      ⊢ ∀n a b.
          n = a * b ∧ coprime a b ⇒
          ∀m. a divides m ∧ b divides m ⇒ lcm n m = m
   
   [<a name="lcm_special_for_prime_power-val"><b>lcm_special_for_prime_power</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇒ ∀m n. n = p ** SUC (ppidx m) ⇒ lcm n m = p * m
   
   [<a name="less_divisors_0-val"><b>less_divisors_0</b></a>]  Theorem
      
      ⊢ less_divisors 0 = ∅
   
   [<a name="less_divisors_1-val"><b>less_divisors_1</b></a>]  Theorem
      
      ⊢ less_divisors 1 = ∅
   
   [<a name="less_divisors_element-val"><b>less_divisors_element</b></a>]  Theorem
      
      ⊢ ∀n x. x ∈ less_divisors n ⇔ 0 &lt; x ∧ x &lt; n ∧ x divides n
   
   [<a name="less_divisors_finite-val"><b>less_divisors_finite</b></a>]  Theorem
      
      ⊢ ∀n. FINITE (less_divisors n)
   
   [<a name="less_divisors_has_1-val"><b>less_divisors_has_1</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ 1 ∈ less_divisors n
   
   [<a name="less_divisors_has_cofactor-val"><b>less_divisors_has_cofactor</b></a>]  Theorem
      
      ⊢ ∀n d. 1 &lt; d ∧ d ∈ less_divisors n ⇒ n DIV d ∈ less_divisors n
   
   [<a name="less_divisors_max-val"><b>less_divisors_max</b></a>]  Theorem
      
      ⊢ ∀n. MAX_SET (less_divisors n) ≤ HALF n
   
   [<a name="less_divisors_min-val"><b>less_divisors_min</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ MIN_SET (less_divisors n) = 1
   
   [<a name="less_divisors_nonzero-val"><b>less_divisors_nonzero</b></a>]  Theorem
      
      ⊢ ∀n x. x ∈ less_divisors n ⇒ 0 &lt; x
   
   [<a name="less_divisors_prime-val"><b>less_divisors_prime</b></a>]  Theorem
      
      ⊢ ∀n. prime n ⇒ less_divisors n = {1}
   
   [<a name="less_divisors_subset_divisors-val"><b>less_divisors_subset_divisors</b></a>]  Theorem
      
      ⊢ ∀n. less_divisors n ⊆ divisors n
   
   [<a name="less_divisors_subset_natural-val"><b>less_divisors_subset_natural</b></a>]  Theorem
      
      ⊢ ∀n. less_divisors n ⊆ natural (HALF n)
   
   [<a name="list_lcm_by_last_non_prime_power-val"><b>list_lcm_by_last_non_prime_power</b></a>]  Theorem
      
      ⊢ ∀n. ¬SING (prime_divisors (n + 1)) ⇒ lcm_run (n + 1) = lcm_run n
   
   [<a name="list_lcm_by_last_prime_power-val"><b>list_lcm_by_last_prime_power</b></a>]  Theorem
      
      ⊢ ∀n. SING (prime_divisors (n + 1)) ⇒
            lcm_run (n + 1) = CHOICE (prime_divisors (n + 1)) * lcm_run n
   
   [<a name="list_lcm_eq_lcm_fun-val"><b>list_lcm_eq_lcm_fun</b></a>]  Theorem
      
      ⊢ ∀n. lcm_run (n + 1) = lcm_fun (n + 1)
   
   [<a name="list_lcm_option_last_non_prime_power-val"><b>list_lcm_option_last_non_prime_power</b></a>]  Theorem
      
      ⊢ ∀n. (∀p. prime_divisors (n + 1) ≠ {p}) ⇒
            lcm_run (n + 1) = lcm_run n
   
   [<a name="list_lcm_option_last_prime_power-val"><b>list_lcm_option_last_prime_power</b></a>]  Theorem
      
      ⊢ ∀n p.
          prime_divisors (n + 1) = {p} ⇒ lcm_run (n + 1) = p * lcm_run n
   
   [<a name="list_lcm_option_recurrence-val"><b>list_lcm_option_recurrence</b></a>]  Theorem
      
      ⊢ ∀n. lcm_run (n + 1) =
            case some p. prime_divisors (n + 1) = {p} of
              NONE =&gt; lcm_run n
            | SOME p =&gt; p * lcm_run n
   
   [<a name="list_lcm_prime_power_divisibility-val"><b>list_lcm_prime_power_divisibility</b></a>]  Theorem
      
      ⊢ ∀l p.
          prime p ∧ POSITIVE l ⇒
          ∀k. p ** k divides list_lcm l ⇒ k ≤ MAX_LIST (MAP ppidx l)
   
   [<a name="list_lcm_prime_power_factor_divides-val"><b>list_lcm_prime_power_factor_divides</b></a>]  Theorem
      
      ⊢ ∀l p. prime p ⇒ p ** MAX_LIST (MAP ppidx l) divides list_lcm l
   
   [<a name="list_lcm_prime_power_factor_member-val"><b>list_lcm_prime_power_factor_member</b></a>]  Theorem
      
      ⊢ ∀l p.
          prime p ∧ l ≠ [] ∧ POSITIVE l ⇒
          ∀k. p ** k divides list_lcm l ⇒ ∃x. MEM x l ∧ p ** k divides x
   
   [<a name="list_lcm_prime_power_index-val"><b>list_lcm_prime_power_index</b></a>]  Theorem
      
      ⊢ ∀l p.
          prime p ∧ POSITIVE l ⇒
          ppidx (list_lcm l) = MAX_LIST (MAP ppidx l)
   
   [<a name="list_lcm_prime_power_index_lower-val"><b>list_lcm_prime_power_index_lower</b></a>]  Theorem
      
      ⊢ ∀l p.
          prime p ∧ l ≠ [] ∧ POSITIVE l ⇒
          ∀x. MEM x l ⇒ ppidx x ≤ ppidx (list_lcm l)
   
   [<a name="list_lcm_recurrence-val"><b>list_lcm_recurrence</b></a>]  Theorem
      
      ⊢ ∀n. lcm_run (n + 1) =
            (let
               s = prime_divisors (n + 1)
             in
               if SING s then CHOICE s * lcm_run n else lcm_run n)
   
   [<a name="list_lcm_with_last_non_prime_power-val"><b>list_lcm_with_last_non_prime_power</b></a>]  Theorem
      
      ⊢ ∀n. (∀p k. k = 0 ∨ ¬prime p ∨ n + 2 ≠ p ** k) ⇒
            lcm_run (n + 2) = lcm_run (n + 1)
   
   [<a name="list_lcm_with_last_prime_power-val"><b>list_lcm_with_last_prime_power</b></a>]  Theorem
      
      ⊢ ∀n p k.
          prime p ∧ n + 2 = p ** k ⇒ lcm_run (n + 2) = p * lcm_run (n + 1)
   
   [<a name="multiples_upto_0_n-val"><b>multiples_upto_0_n</b></a>]  Theorem
      
      ⊢ ∀n. 0 multiples_upto n = ∅
   
   [<a name="multiples_upto_1_n-val"><b>multiples_upto_1_n</b></a>]  Theorem
      
      ⊢ ∀n. 1 multiples_upto n = natural n
   
   [<a name="multiples_upto_alt-val"><b>multiples_upto_alt</b></a>]  Theorem
      
      ⊢ ∀m n. m multiples_upto n = {x | ∃k. x = k * m ∧ 0 &lt; x ∧ x ≤ n}
   
   [<a name="multiples_upto_card-val"><b>multiples_upto_card</b></a>]  Theorem
      
      ⊢ ∀m n. CARD (m multiples_upto n) = if m = 0 then 0 else n DIV m
   
   [<a name="multiples_upto_element-val"><b>multiples_upto_element</b></a>]  Theorem
      
      ⊢ ∀m n x. x ∈ m multiples_upto n ⇔ m divides x ∧ 0 &lt; x ∧ x ≤ n
   
   [<a name="multiples_upto_element_alt-val"><b>multiples_upto_element_alt</b></a>]  Theorem
      
      ⊢ ∀m n x. x ∈ m multiples_upto n ⇔ ∃k. x = k * m ∧ 0 &lt; x ∧ x ≤ n
   
   [<a name="multiples_upto_eqn-val"><b>multiples_upto_eqn</b></a>]  Theorem
      
      ⊢ ∀m n. m multiples_upto n = {x | m divides x ∧ x ∈ natural n}
   
   [<a name="multiples_upto_finite-val"><b>multiples_upto_finite</b></a>]  Theorem
      
      ⊢ ∀m n. FINITE (m multiples_upto n)
   
   [<a name="multiples_upto_m_0-val"><b>multiples_upto_m_0</b></a>]  Theorem
      
      ⊢ ∀m. m multiples_upto 0 = ∅
   
   [<a name="multiples_upto_m_1-val"><b>multiples_upto_m_1</b></a>]  Theorem
      
      ⊢ ∀m. m multiples_upto 1 = if m = 1 then {1} else ∅
   
   [<a name="multiples_upto_subset-val"><b>multiples_upto_subset</b></a>]  Theorem
      
      ⊢ ∀m n. m multiples_upto n ⊆ natural n
   
   [<a name="multiples_upto_thm-val"><b>multiples_upto_thm</b></a>]  Theorem
      
      ⊢ ∀m n.
          m multiples_upto n =
          if m = 0 then ∅ else IMAGE ($* m) (natural (n DIV m))
   
   [<a name="non_prime_power_coprime_factors-val"><b>non_prime_power_coprime_factors</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ∧ ¬(∃p k. 0 &lt; k ∧ prime p ∧ n = p ** k) ⇒
            ∃a b. n = a * b ∧ coprime a b ∧ 1 &lt; a ∧ a &lt; n ∧ 1 &lt; b ∧ b &lt; n
   
   [<a name="non_sq_free_element-val"><b>non_sq_free_element</b></a>]  Theorem
      
      ⊢ ∀s n. n ∈ non_sq_free s ⇔ n ∈ s ∧ ¬square_free n
   
   [<a name="non_sq_free_finite-val"><b>non_sq_free_finite</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ FINITE (non_sq_free s)
   
   [<a name="non_sq_free_subset-val"><b>non_sq_free_subset</b></a>]  Theorem
      
      ⊢ ∀s. non_sq_free s ⊆ s
   
   [<a name="odd_sq_free_element-val"><b>odd_sq_free_element</b></a>]  Theorem
      
      ⊢ ∀s n.
          n ∈ odd_sq_free s ⇔
          n ∈ s ∧ square_free n ∧ ODD (CARD (prime_factors n))
   
   [<a name="odd_sq_free_finite-val"><b>odd_sq_free_finite</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ FINITE (odd_sq_free s)
   
   [<a name="odd_sq_free_subset-val"><b>odd_sq_free_subset</b></a>]  Theorem
      
      ⊢ ∀s. odd_sq_free s ⊆ s
   
   [<a name="odd_square_lt-val"><b>odd_square_lt</b></a>]  Theorem
      
      ⊢ ∀n m. ¬square n ⇒ ((TWICE m + 1)² &lt; n ⇔ m &lt; HALF (1 + SQRT n))
   
   [<a name="pairwise_coprime_for_prime_powers-val"><b>pairwise_coprime_for_prime_powers</b></a>]  Theorem
      
      ⊢ ∀s f. s ⊆ prime ⇒ PAIRWISE_COPRIME (IMAGE (λp. p ** f p) s)
   
   [<a name="park_off_alt-val"><b>park_off_alt</b></a>]  Theorem
      
      ⊢ ∀m n. park_off m n = common_prime_divisors m n DIFF park_on m n
   
   [<a name="park_off_element-val"><b>park_off_element</b></a>]  Theorem
      
      ⊢ ∀m n p.
          p ∈ park_off m n ⇔
          p ∈ prime_divisors m ∧ p ∈ prime_divisors n ∧ ppidx n &lt; ppidx m
   
   [<a name="park_off_image_has_not_1-val"><b>park_off_image_has_not_1</b></a>]  Theorem
      
      ⊢ ∀m n. 1 ∉ IMAGE (λp. p ** ppidx m) (park_off m n)
   
   [<a name="park_off_subset_common-val"><b>park_off_subset_common</b></a>]  Theorem
      
      ⊢ ∀m n. park_off m n ⊆ common_prime_divisors m n
   
   [<a name="park_off_subset_total-val"><b>park_off_subset_total</b></a>]  Theorem
      
      ⊢ ∀m n. park_off m n ⊆ total_prime_divisors m n
   
   [<a name="park_on_element-val"><b>park_on_element</b></a>]  Theorem
      
      ⊢ ∀m n p.
          p ∈ park_on m n ⇔
          p ∈ prime_divisors m ∧ p ∈ prime_divisors n ∧ ppidx m ≤ ppidx n
   
   [<a name="park_on_off_common_image_partition-val"><b>park_on_off_common_image_partition</b></a>]  Theorem
      
      ⊢ ∀m n.
          (let
             s =
               IMAGE (λp. p ** MIN (ppidx m) (ppidx n))
                 (common_prime_divisors m n);
             u = IMAGE (λp. p ** ppidx m) (park_on m n);
             v = IMAGE (λp. p ** ppidx n) (park_off m n)
           in
             0 &lt; m ⇒ s =|= u # v)
   
   [<a name="park_on_off_partition-val"><b>park_on_off_partition</b></a>]  Theorem
      
      ⊢ ∀m n. common_prime_divisors m n =|= park_on m n # park_off m n
   
   [<a name="park_on_off_total_image_partition-val"><b>park_on_off_total_image_partition</b></a>]  Theorem
      
      ⊢ ∀m n.
          (let
             s =
               IMAGE (λp. p ** MAX (ppidx m) (ppidx n))
                 (total_prime_divisors m n);
             u =
               IMAGE (λp. p ** ppidx m) (prime_divisors m DIFF park_on m n);
             v =
               IMAGE (λp. p ** ppidx n)
                 (prime_divisors n DIFF park_off m n)
           in
             0 &lt; m ∧ 0 &lt; n ⇒ s =|= u # v)
   
   [<a name="park_on_subset_common-val"><b>park_on_subset_common</b></a>]  Theorem
      
      ⊢ ∀m n. park_on m n ⊆ common_prime_divisors m n
   
   [<a name="park_on_subset_total-val"><b>park_on_subset_total</b></a>]  Theorem
      
      ⊢ ∀m n. park_on m n ⊆ total_prime_divisors m n
   
   [<a name="perfect_power_0_m-val"><b>perfect_power_0_m</b></a>]  Theorem
      
      ⊢ ∀m. 0 power_of m ⇔ m = 0
   
   [<a name="perfect_power_1_m-val"><b>perfect_power_1_m</b></a>]  Theorem
      
      ⊢ ∀m. 1 power_of m
   
   [<a name="perfect_power_2_odd-val"><b>perfect_power_2_odd</b></a>]  Theorem
      
      ⊢ ∀n. n power_of 2 ⇒ (ODD n ⇔ n = 1)
   
   [<a name="perfect_power_bound_LOG2-val"><b>perfect_power_bound_LOG2</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀m. n power_of m ⇔ ∃k. k ≤ LOG2 n ∧ n = m ** k
   
   [<a name="perfect_power_bound_ulog-val"><b>perfect_power_bound_ulog</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀m. n power_of m ⇔ ∃k. k ≤ ulog n ∧ n = m ** k
   
   [<a name="perfect_power_cofactor-val"><b>perfect_power_cofactor</b></a>]  Theorem
      
      ⊢ ∀n p. 0 &lt; p ∧ p divides n ⇒ (n power_of p ⇔ n DIV p power_of p)
   
   [<a name="perfect_power_cofactor_alt-val"><b>perfect_power_cofactor_alt</b></a>]  Theorem
      
      ⊢ ∀n p. 0 &lt; n ∧ p divides n ⇒ (n power_of p ⇔ n DIV p power_of p)
   
   [<a name="perfect_power_condition-val"><b>perfect_power_condition</b></a>]  Theorem
      
      ⊢ ∀p q. prime p ∧ (∃x y. 0 &lt; x ∧ p ** x = q ** y) ⇒ q power_of p
   
   [<a name="perfect_power_half_inequality_1-val"><b>perfect_power_half_inequality_1</b></a>]  Theorem
      
      ⊢ ∀p n. 1 &lt; p ∧ 0 &lt; n ⇒ TWICE (p ** HALF n) ≤ p ** n
   
   [<a name="perfect_power_half_inequality_2-val"><b>perfect_power_half_inequality_2</b></a>]  Theorem
      
      ⊢ ∀p n.
          1 &lt; p ∧ 0 &lt; n ⇒
          (p ** HALF n − 2) * p ** HALF n ≤ p ** n − TWICE (p ** HALF n)
   
   [<a name="perfect_power_mod_eq_0-val"><b>perfect_power_mod_eq_0</b></a>]  Theorem
      
      ⊢ ∀n m.
          0 &lt; m ∧ 1 &lt; n ∧ n MOD m = 0 ⇒ (n power_of m ⇔ n DIV m power_of m)
   
   [<a name="perfect_power_mod_ne_0-val"><b>perfect_power_mod_ne_0</b></a>]  Theorem
      
      ⊢ ∀n m. 0 &lt; m ∧ 1 &lt; n ∧ n MOD m ≠ 0 ⇒ ¬(n power_of m)
   
   [<a name="perfect_power_n_0-val"><b>perfect_power_n_0</b></a>]  Theorem
      
      ⊢ ∀n. n power_of 0 ⇔ n = 0 ∨ n = 1
   
   [<a name="perfect_power_n_1-val"><b>perfect_power_n_1</b></a>]  Theorem
      
      ⊢ ∀n. n power_of 1 ⇔ n = 1
   
   [<a name="perfect_power_not_suc-val"><b>perfect_power_not_suc</b></a>]  Theorem
      
      ⊢ ∀m n. 1 &lt; m ∧ 1 &lt; n ∧ n power_of m ⇒ ¬(SUC n power_of m)
   
   [<a name="perfect_power_self-val"><b>perfect_power_self</b></a>]  Theorem
      
      ⊢ ∀n. n power_of n
   
   [<a name="perfect_power_special_inequality-val"><b>perfect_power_special_inequality</b></a>]  Theorem
      
      ⊢ ∀p. 1 &lt; p ⇒ ∀n. p * tops p n &lt; (p − 1) * TWICE (p ** n)
   
   [<a name="perfect_power_suc-val"><b>perfect_power_suc</b></a>]  Theorem
      
      ⊢ ∀m n. 1 &lt; m ∧ n power_of m ∧ SUC n power_of m ⇒ m = 2 ∧ n = 1
   
   [<a name="perfect_power_test-val"><b>perfect_power_test</b></a>]  Theorem
      
      ⊢ ∀n m.
          n power_of m ⇔
          if n = 0 then m = 0
          else if n = 1 then T
          else if m = 0 then n ≤ 1
          else if m = 1 then n = 1
          else if n MOD m = 0 then n DIV m power_of m
          else F
   
   [<a name="phi_0-val"><b>phi_0</b></a>]  Theorem
      
      ⊢ phi 0 = 0
   
   [<a name="phi_1-val"><b>phi_1</b></a>]  Theorem
      
      ⊢ phi 1 = 1
   
   [<a name="phi_2-val"><b>phi_2</b></a>]  Theorem
      
      ⊢ phi 2 = 1
   
   [<a name="phi_eq_0-val"><b>phi_eq_0</b></a>]  Theorem
      
      ⊢ ∀n. phi n = 0 ⇔ n = 0
   
   [<a name="phi_eq_totient-val"><b>phi_eq_totient</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ phi n = totient n
   
   [<a name="phi_fun-val"><b>phi_fun</b></a>]  Theorem
      
      ⊢ phi = CARD ∘ coprimes
   
   [<a name="phi_gt_1-val"><b>phi_gt_1</b></a>]  Theorem
      
      ⊢ ∀n. 2 &lt; n ⇒ 1 &lt; phi n
   
   [<a name="phi_le-val"><b>phi_le</b></a>]  Theorem
      
      ⊢ ∀n. phi n ≤ n
   
   [<a name="phi_lt-val"><b>phi_lt</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ phi n &lt; n
   
   [<a name="phi_mult-val"><b>phi_mult</b></a>]  Theorem
      
      ⊢ ∀m n. coprime m n ⇒ phi (m * n) = phi m * phi n
   
   [<a name="phi_pos-val"><b>phi_pos</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ 0 &lt; phi n
   
   [<a name="phi_prime-val"><b>phi_prime</b></a>]  Theorem
      
      ⊢ ∀n. prime n ⇒ phi n = n − 1
   
   [<a name="phi_prime_power-val"><b>phi_prime_power</b></a>]  Theorem
      
      ⊢ ∀p n. prime p ⇒ phi (p ** SUC n) = (p − 1) * p ** n
   
   [<a name="phi_prime_sq-val"><b>phi_prime_sq</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇒ phi (SQ p) = p * (p − 1)
   
   [<a name="phi_primes-val"><b>phi_primes</b></a>]  Theorem
      
      ⊢ ∀p q.
          prime p ∧ prime q ⇒
          phi (p * q) = if p = q then p * (p − 1) else (p − 1) * (q − 1)
   
   [<a name="phi_primes_distinct-val"><b>phi_primes_distinct</b></a>]  Theorem
      
      ⊢ ∀p q. prime p ∧ prime q ∧ p ≠ q ⇒ phi (p * q) = (p − 1) * (q − 1)
   
   [<a name="phi_thm-val"><b>phi_thm</b></a>]  Theorem
      
      ⊢ ∀n. phi n = LENGTH (FILTER (λj. coprime j n) (GENLIST SUC n))
   
   [<a name="power_free_0-val"><b>power_free_0</b></a>]  Theorem
      
      ⊢ power_free 0 ⇔ F
   
   [<a name="power_free_1-val"><b>power_free_1</b></a>]  Theorem
      
      ⊢ power_free 1 ⇔ F
   
   [<a name="power_free_2-val"><b>power_free_2</b></a>]  Theorem
      
      ⊢ power_free 2
   
   [<a name="power_free_3-val"><b>power_free_3</b></a>]  Theorem
      
      ⊢ power_free 3
   
   [<a name="power_free_alt-val"><b>power_free_alt</b></a>]  Theorem
      
      ⊢ power_free n ⇔ 1 &lt; n ∧ ∀m. n power_of m ⇒ n = m
   
   [<a name="power_free_by_power_index_LOG2-val"><b>power_free_by_power_index_LOG2</b></a>]  Theorem
      
      ⊢ ∀n. power_free n ⇔ 1 &lt; n ∧ power_index n (LOG2 n) = 1
   
   [<a name="power_free_by_power_index_ulog-val"><b>power_free_by_power_index_ulog</b></a>]  Theorem
      
      ⊢ ∀n. power_free n ⇔ 1 &lt; n ∧ power_index n (ulog n) = 1
   
   [<a name="power_free_check_all-val"><b>power_free_check_all</b></a>]  Theorem
      
      ⊢ ∀n. power_free n ⇔ 1 &lt; n ∧ ∀j. 1 &lt; j ⇒ ROOT j n ** j ≠ n
   
   [<a name="power_free_check_upto-val"><b>power_free_check_upto</b></a>]  Theorem
      
      ⊢ ∀n b. LOG2 n ≤ b ⇒ (power_free n ⇔ 1 &lt; n ∧ n power_free_upto b)
   
   [<a name="power_free_check_upto_LOG2-val"><b>power_free_check_upto_LOG2</b></a>]  Theorem
      
      ⊢ ∀n. power_free n ⇔ 1 &lt; n ∧ n power_free_upto LOG2 n
   
   [<a name="power_free_check_upto_ulog-val"><b>power_free_check_upto_ulog</b></a>]  Theorem
      
      ⊢ ∀n. power_free n ⇔ 1 &lt; n ∧ n power_free_upto ulog n
   
   [<a name="power_free_gt_1-val"><b>power_free_gt_1</b></a>]  Theorem
      
      ⊢ ∀n. power_free n ⇒ 1 &lt; n
   
   [<a name="power_free_perfect_power-val"><b>power_free_perfect_power</b></a>]  Theorem
      
      ⊢ ∀m n. power_free n ∧ n power_of m ⇒ n = m
   
   [<a name="power_free_property-val"><b>power_free_property</b></a>]  Theorem
      
      ⊢ ∀n. power_free n ⇒ ∀j. 1 &lt; j ⇒ ROOT j n ** j ≠ n
   
   [<a name="power_free_test_eqn-val"><b>power_free_test_eqn</b></a>]  Theorem
      
      ⊢ ∀n. power_free_test n ⇔ power_free n
   
   [<a name="power_free_test_upto_LOG2-val"><b>power_free_test_upto_LOG2</b></a>]  Theorem
      
      ⊢ ∀n. power_free n ⇔
            1 &lt; n ∧ ∀j. 1 &lt; j ∧ j ≤ LOG2 n ⇒ ROOT j n ** j ≠ n
   
   [<a name="power_free_test_upto_ulog-val"><b>power_free_test_upto_ulog</b></a>]  Theorem
      
      ⊢ ∀n. power_free n ⇔
            1 &lt; n ∧ ∀j. 1 &lt; j ∧ j ≤ ulog n ⇒ ROOT j n ** j ≠ n
   
   [<a name="power_free_upto_0-val"><b>power_free_upto_0</b></a>]  Theorem
      
      ⊢ ∀n. n power_free_upto 0 ⇔ T
   
   [<a name="power_free_upto_1-val"><b>power_free_upto_1</b></a>]  Theorem
      
      ⊢ ∀n. n power_free_upto 1 ⇔ T
   
   [<a name="power_free_upto_suc-val"><b>power_free_upto_suc</b></a>]  Theorem
      
      ⊢ ∀n k.
          0 &lt; k ∧ n power_free_upto k ⇒
          (n power_free_upto k + 1 ⇔ ROOT (k + 1) n ** (k + 1) ≠ n)
   
   [<a name="power_index_0-val"><b>power_index_0</b></a>]  Theorem
      
      ⊢ ∀n. power_index n 0 = 1
   
   [<a name="power_index_1-val"><b>power_index_1</b></a>]  Theorem
      
      ⊢ ∀n. power_index n 1 = 1
   
   [<a name="power_index_def-val"><b>power_index_def</b></a>]  Theorem
      
      ⊢ ∀n k.
          power_index n k =
          if k ≤ 1 then 1
          else if ROOT k n ** k = n then k
          else power_index n (k − 1)
   
   [<a name="power_index_eqn-val"><b>power_index_eqn</b></a>]  Theorem
      
      ⊢ ∀n k. ROOT (power_index n k) n ** power_index n k = n
   
   [<a name="power_index_equal-val"><b>power_index_equal</b></a>]  Theorem
      
      ⊢ ∀m n k.
          0 &lt; k ∧ k ≤ m ⇒
          (power_index n m = power_index n k ⇔
           ∀j. k &lt; j ∧ j ≤ m ⇒ ROOT j n ** j ≠ n)
   
   [<a name="power_index_exact_root-val"><b>power_index_exact_root</b></a>]  Theorem
      
      ⊢ ∀n k. 0 &lt; k ∧ ROOT k n ** k = n ⇒ power_index n k = k
   
   [<a name="power_index_ind-val"><b>power_index_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀n k. (¬(k ≤ 1) ∧ ROOT k n ** k ≠ n ⇒ P n (k − 1)) ⇒ P n k) ⇒
            ∀v v1. P v v1
   
   [<a name="power_index_lower-val"><b>power_index_lower</b></a>]  Theorem
      
      ⊢ ∀m n k. k ≤ m ∧ ROOT k n ** k = n ⇒ k ≤ power_index n m
   
   [<a name="power_index_no_exact_roots-val"><b>power_index_no_exact_roots</b></a>]  Theorem
      
      ⊢ ∀m n k.
          k ≤ m ∧ (∀j. k &lt; j ∧ j ≤ m ⇒ ROOT j n ** j ≠ n) ⇒
          power_index n m = power_index n k
   
   [<a name="power_index_not_exact_root-val"><b>power_index_not_exact_root</b></a>]  Theorem
      
      ⊢ ∀n k. ROOT k n ** k ≠ n ⇒ power_index n k = power_index n (k − 1)
   
   [<a name="power_index_of_1-val"><b>power_index_of_1</b></a>]  Theorem
      
      ⊢ ∀k. power_index 1 k = if k = 0 then 1 else k
   
   [<a name="power_index_pos-val"><b>power_index_pos</b></a>]  Theorem
      
      ⊢ ∀n k. 0 &lt; power_index n k
   
   [<a name="power_index_property-val"><b>power_index_property</b></a>]  Theorem
      
      ⊢ ∀m n k. power_index n m = k ⇒ ∀j. k &lt; j ∧ j ≤ m ⇒ ROOT j n ** j ≠ n
   
   [<a name="power_index_root-val"><b>power_index_root</b></a>]  Theorem
      
      ⊢ ∀n k. n power_of ROOT (power_index n k) n
   
   [<a name="power_index_upper-val"><b>power_index_upper</b></a>]  Theorem
      
      ⊢ ∀n k. 0 &lt; k ⇒ power_index n k ≤ k
   
   [<a name="prime_by_sqrt_factors-val"><b>prime_by_sqrt_factors</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇔ 1 &lt; p ∧ ∀q. 1 &lt; q ∧ q ≤ SQRT p ⇒ ¬(q divides p)
   
   [<a name="prime_divisors_0-val"><b>prime_divisors_0</b></a>]  Theorem
      
      ⊢ prime_divisors 0 = {p | prime p}
   
   [<a name="prime_divisors_0_not_sing-val"><b>prime_divisors_0_not_sing</b></a>]  Theorem
      
      ⊢ ¬SING (prime_divisors 0)
   
   [<a name="prime_divisors_1-val"><b>prime_divisors_1</b></a>]  Theorem
      
      ⊢ prime_divisors 1 = ∅
   
   [<a name="prime_divisors_common_divisor-val"><b>prime_divisors_common_divisor</b></a>]  Theorem
      
      ⊢ ∀n m x.
          x divides m ∧ x divides n ⇒
          prime_divisors x ⊆ common_prime_divisors m n
   
   [<a name="prime_divisors_common_multiple-val"><b>prime_divisors_common_multiple</b></a>]  Theorem
      
      ⊢ ∀n m x.
          m divides x ∧ n divides x ⇒
          total_prime_divisors m n ⊆ prime_divisors x
   
   [<a name="prime_divisors_divisor_subset-val"><b>prime_divisors_divisor_subset</b></a>]  Theorem
      
      ⊢ ∀m n. m divides n ⇒ prime_divisors m ⊆ prime_divisors n
   
   [<a name="prime_divisors_element-val"><b>prime_divisors_element</b></a>]  Theorem
      
      ⊢ ∀n p. p ∈ prime_divisors n ⇔ prime p ∧ p divides n
   
   [<a name="prime_divisors_empty_iff-val"><b>prime_divisors_empty_iff</b></a>]  Theorem
      
      ⊢ ∀n. prime_divisors n = ∅ ⇔ n = 1
   
   [<a name="prime_divisors_finite-val"><b>prime_divisors_finite</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ FINITE (prime_divisors n)
   
   [<a name="prime_divisors_nonempty-val"><b>prime_divisors_nonempty</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ prime_divisors n ≠ ∅
   
   [<a name="prime_divisors_prime-val"><b>prime_divisors_prime</b></a>]  Theorem
      
      ⊢ ∀n. prime n ⇒ prime_divisors n = {n}
   
   [<a name="prime_divisors_prime_power-val"><b>prime_divisors_prime_power</b></a>]  Theorem
      
      ⊢ ∀n. prime n ⇒ ∀k. 0 &lt; k ⇒ prime_divisors (n ** k) = {n}
   
   [<a name="prime_divisors_sing-val"><b>prime_divisors_sing</b></a>]  Theorem
      
      ⊢ ∀n. SING (prime_divisors n) ⇔ ∃p k. prime p ∧ 0 &lt; k ∧ n = p ** k
   
   [<a name="prime_divisors_sing_alt-val"><b>prime_divisors_sing_alt</b></a>]  Theorem
      
      ⊢ ∀n p. prime_divisors n = {p} ⇔ ∃k. prime p ∧ 0 &lt; k ∧ n = p ** k
   
   [<a name="prime_divisors_sing_property-val"><b>prime_divisors_sing_property</b></a>]  Theorem
      
      ⊢ ∀n. SING (prime_divisors n) ⇒
            (let
               p = CHOICE (prime_divisors n)
             in
               prime p ∧ n = p ** ppidx n)
   
   [<a name="prime_divisors_subset_natural-val"><b>prime_divisors_subset_natural</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ prime_divisors n ⊆ natural n
   
   [<a name="prime_divisors_subset_prime-val"><b>prime_divisors_subset_prime</b></a>]  Theorem
      
      ⊢ ∀n. prime_divisors n ⊆ prime
   
   [<a name="prime_factor_estimate-val"><b>prime_factor_estimate</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ (¬prime n ⇔ ∃p. prime p ∧ p divides n ∧ p ≤ SQRT n)
   
   [<a name="prime_factorisation-val"><b>prime_factorisation</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ n = PROD_SET (prime_power_divisors n)
   
   [<a name="prime_factors_element-val"><b>prime_factors_element</b></a>]  Theorem
      
      ⊢ ∀n p. p ∈ prime_factors n ⇔ prime p ∧ p ≤ n ∧ p divides n
   
   [<a name="prime_factors_finite-val"><b>prime_factors_finite</b></a>]  Theorem
      
      ⊢ ∀n. FINITE (prime_factors n)
   
   [<a name="prime_factors_subset-val"><b>prime_factors_subset</b></a>]  Theorem
      
      ⊢ ∀n. prime_factors n ⊆ divisors n
   
   [<a name="prime_is_power_free-val"><b>prime_is_power_free</b></a>]  Theorem
      
      ⊢ ∀n. prime n ⇒ power_free n
   
   [<a name="prime_non_square-val"><b>prime_non_square</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇒ ¬square p
   
   [<a name="prime_power_cofactor_coprime-val"><b>prime_power_cofactor_coprime</b></a>]  Theorem
      
      ⊢ ∀n p. 0 &lt; n ∧ prime p ⇒ coprime p (n DIV p ** ppidx n)
   
   [<a name="prime_power_divisibility-val"><b>prime_power_divisibility</b></a>]  Theorem
      
      ⊢ ∀n p. 0 &lt; n ∧ prime p ⇒ ∀k. p ** k divides n ⇔ k ≤ ppidx n
   
   [<a name="prime_power_divisors_1-val"><b>prime_power_divisors_1</b></a>]  Theorem
      
      ⊢ prime_power_divisors 1 = ∅
   
   [<a name="prime_power_divisors_element-val"><b>prime_power_divisors_element</b></a>]  Theorem
      
      ⊢ ∀n x.
          x ∈ prime_power_divisors n ⇔
          ∃p. x = p ** ppidx n ∧ prime p ∧ p divides n
   
   [<a name="prime_power_divisors_element_alt-val"><b>prime_power_divisors_element_alt</b></a>]  Theorem
      
      ⊢ ∀p n. prime p ∧ p divides n ⇒ p ** ppidx n ∈ prime_power_divisors n
   
   [<a name="prime_power_divisors_finite-val"><b>prime_power_divisors_finite</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ FINITE (prime_power_divisors n)
   
   [<a name="prime_power_divisors_pairwise_coprime-val"><b>prime_power_divisors_pairwise_coprime</b></a>]  Theorem
      
      ⊢ ∀n x y.
          x ∈ prime_power_divisors n ∧ y ∈ prime_power_divisors n ∧ x ≠ y ⇒
          coprime x y
   
   [<a name="prime_power_eqn-val"><b>prime_power_eqn</b></a>]  Theorem
      
      ⊢ ∀n p. 0 &lt; n ∧ prime p ⇒ n = p ** ppidx n * (n DIV p ** ppidx n)
   
   [<a name="prime_power_factor_divides-val"><b>prime_power_factor_divides</b></a>]  Theorem
      
      ⊢ ∀n p. prime p ⇒ p ** ppidx n divides n
   
   [<a name="prime_power_index_1-val"><b>prime_power_index_1</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇒ ppidx 1 = 0
   
   [<a name="prime_power_index_common_divisor-val"><b>prime_power_index_common_divisor</b></a>]  Theorem
      
      ⊢ ∀n m x.
          0 &lt; m ∧ 0 &lt; n ∧ x divides m ∧ x divides n ⇒
          ∀p. prime p ⇒ ppidx x ≤ MIN (ppidx m) (ppidx n)
   
   [<a name="prime_power_index_common_multiple-val"><b>prime_power_index_common_multiple</b></a>]  Theorem
      
      ⊢ ∀n m x.
          0 &lt; x ∧ m divides x ∧ n divides x ⇒
          ∀p. prime p ⇒ MAX (ppidx m) (ppidx n) ≤ ppidx x
   
   [<a name="prime_power_index_eq_0-val"><b>prime_power_index_eq_0</b></a>]  Theorem
      
      ⊢ ∀n p. 0 &lt; n ∧ prime p ∧ ¬(p divides n) ⇒ ppidx n = 0
   
   [<a name="prime_power_index_eqn-val"><b>prime_power_index_eqn</b></a>]  Theorem
      
      ⊢ ∀n p.
          0 &lt; n ∧ prime p ⇒
          (let
             q = n DIV p ** ppidx n
           in
             n = p ** ppidx n * q ∧ coprime p q)
   
   [<a name="prime_power_index_exists-val"><b>prime_power_index_exists</b></a>]  Theorem
      
      ⊢ ∀n p.
          0 &lt; n ∧ prime p ⇒ ∃m. p ** m divides n ∧ coprime p (n DIV p ** m)
   
   [<a name="prime_power_index_le_log_index-val"><b>prime_power_index_le_log_index</b></a>]  Theorem
      
      ⊢ ∀n p. 0 &lt; n ∧ prime p ⇒ ppidx n ≤ LOG p n
   
   [<a name="prime_power_index_maximal-val"><b>prime_power_index_maximal</b></a>]  Theorem
      
      ⊢ ∀n p. 0 &lt; n ∧ prime p ⇒ ∀k. k &gt; ppidx n ⇒ ¬(p ** k divides n)
   
   [<a name="prime_power_index_of_divisor-val"><b>prime_power_index_of_divisor</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; n ∧ m divides n ⇒ ∀p. prime p ⇒ ppidx m ≤ ppidx n
   
   [<a name="prime_power_index_pos-val"><b>prime_power_index_pos</b></a>]  Theorem
      
      ⊢ ∀n p. 0 &lt; n ∧ prime p ∧ p divides n ⇒ 0 &lt; ppidx n
   
   [<a name="prime_power_index_prime-val"><b>prime_power_index_prime</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇒ ppidx p = 1
   
   [<a name="prime_power_index_prime_power-val"><b>prime_power_index_prime_power</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇒ ∀k. ppidx (p ** k) = k
   
   [<a name="prime_power_index_suc_property-val"><b>prime_power_index_suc_property</b></a>]  Theorem
      
      ⊢ ∀n p.
          0 &lt; n ∧ prime p ∧ n + 1 = p ** ppidx (n + 1) ⇒
          ppidx (n + 1) = 1 + ppidx (lcm_run n)
   
   [<a name="prime_power_index_suc_special-val"><b>prime_power_index_suc_special</b></a>]  Theorem
      
      ⊢ ∀n p.
          0 &lt; n ∧ prime p ∧ SUC n = p ** ppidx (SUC n) ⇒
          ppidx (SUC n) = SUC (ppidx (lcm_run n))
   
   [<a name="prime_power_index_test-val"><b>prime_power_index_test</b></a>]  Theorem
      
      ⊢ ∀n p.
          0 &lt; n ∧ prime p ⇒
          ∀k. k = ppidx n ⇔ ∃q. n = p ** k * q ∧ coprime p q
   
   [<a name="prime_power_or_coprime_factors-val"><b>prime_power_or_coprime_factors</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒
            (∃p k. 0 &lt; k ∧ prime p ∧ n = p ** k) ∨
            ∃a b. n = a * b ∧ coprime a b ∧ 1 &lt; a ∧ 1 &lt; b ∧ a &lt; n ∧ b &lt; n
   
   [<a name="prime_powers_upto_0-val"><b>prime_powers_upto_0</b></a>]  Theorem
      
      ⊢ prime_powers_upto 0 = ∅
   
   [<a name="prime_powers_upto_1-val"><b>prime_powers_upto_1</b></a>]  Theorem
      
      ⊢ prime_powers_upto 1 = ∅
   
   [<a name="prime_powers_upto_element-val"><b>prime_powers_upto_element</b></a>]  Theorem
      
      ⊢ ∀n x.
          x ∈ prime_powers_upto n ⇔ ∃p. x = p ** LOG p n ∧ prime p ∧ p ≤ n
   
   [<a name="prime_powers_upto_element_alt-val"><b>prime_powers_upto_element_alt</b></a>]  Theorem
      
      ⊢ ∀p n. prime p ∧ p ≤ n ⇒ p ** LOG p n ∈ prime_powers_upto n
   
   [<a name="prime_powers_upto_finite-val"><b>prime_powers_upto_finite</b></a>]  Theorem
      
      ⊢ ∀n. FINITE (prime_powers_upto n)
   
   [<a name="prime_powers_upto_lcm_divisor-val"><b>prime_powers_upto_lcm_divisor</b></a>]  Theorem
      
      ⊢ ∀n x. 0 &lt; x ∧ x ≤ n ⇒ x divides set_lcm (prime_powers_upto n)
   
   [<a name="prime_powers_upto_lcm_prime_divisor-val"><b>prime_powers_upto_lcm_prime_divisor</b></a>]  Theorem
      
      ⊢ ∀n p. prime p ∧ p ≤ n ⇒ p divides set_lcm (prime_powers_upto n)
   
   [<a name="prime_powers_upto_lcm_prime_to_log_divisor-val"><b>prime_powers_upto_lcm_prime_to_log_divisor</b></a>]  Theorem
      
      ⊢ ∀n p.
          prime p ∧ p ≤ n ⇒
          p ** LOG p n divides set_lcm (prime_powers_upto n)
   
   [<a name="prime_powers_upto_lcm_prime_to_power_divisor-val"><b>prime_powers_upto_lcm_prime_to_power_divisor</b></a>]  Theorem
      
      ⊢ ∀n p.
          prime p ∧ p ≤ n ⇒
          p ** ppidx n divides set_lcm (prime_powers_upto n)
   
   [<a name="prime_powers_upto_list_mem-val"><b>prime_powers_upto_list_mem</b></a>]  Theorem
      
      ⊢ ∀n x.
          MEM x (SET_TO_LIST (prime_powers_upto n)) ⇔
          ∃p. x = p ** LOG p n ∧ prime p ∧ p ≤ n
   
   [<a name="prime_powers_upto_pairwise_coprime-val"><b>prime_powers_upto_pairwise_coprime</b></a>]  Theorem
      
      ⊢ ∀n x y.
          x ∈ prime_powers_upto n ∧ y ∈ prime_powers_upto n ∧ x ≠ y ⇒
          coprime x y
   
   [<a name="prime_powers_upto_prod_set_ge-val"><b>prime_powers_upto_prod_set_ge</b></a>]  Theorem
      
      ⊢ ∀n. PROD_SET (primes_upto n) ≤ PROD_SET (prime_powers_upto n)
   
   [<a name="prime_powers_upto_prod_set_le-val"><b>prime_powers_upto_prod_set_le</b></a>]  Theorem
      
      ⊢ ∀n. PROD_SET (prime_powers_upto n) ≤ n ** primes_count n
   
   [<a name="prime_powers_upto_prod_set_mix_ge-val"><b>prime_powers_upto_prod_set_mix_ge</b></a>]  Theorem
      
      ⊢ ∀n. n ** primes_count n ≤
            PROD_SET (primes_upto n) * PROD_SET (prime_powers_upto n)
   
   [<a name="prime_test_thm-val"><b>prime_test_thm</b></a>]  Theorem
      
      ⊢ ∀n. prime n ⇔ prime_test n
   
   [<a name="primes_count_0-val"><b>primes_count_0</b></a>]  Theorem
      
      ⊢ primes_count 0 = 0
   
   [<a name="primes_count_1-val"><b>primes_count_1</b></a>]  Theorem
      
      ⊢ primes_count 1 = 0
   
   [<a name="primes_count_upper_by_lcm_run-val"><b>primes_count_upper_by_lcm_run</b></a>]  Theorem
      
      ⊢ ∀n. n ** primes_count n ≤ (lcm_run n)²
   
   [<a name="primes_count_upper_by_product-val"><b>primes_count_upper_by_product</b></a>]  Theorem
      
      ⊢ ∀n. n ** primes_count n ≤ PROD_SET (primes_upto n) * lcm_run n
   
   [<a name="primes_upto_0-val"><b>primes_upto_0</b></a>]  Theorem
      
      ⊢ primes_upto 0 = ∅
   
   [<a name="primes_upto_1-val"><b>primes_upto_1</b></a>]  Theorem
      
      ⊢ primes_upto 1 = ∅
   
   [<a name="primes_upto_element-val"><b>primes_upto_element</b></a>]  Theorem
      
      ⊢ ∀n p. p ∈ primes_upto n ⇔ prime p ∧ p ≤ n
   
   [<a name="primes_upto_finite-val"><b>primes_upto_finite</b></a>]  Theorem
      
      ⊢ ∀n. FINITE (primes_upto n)
   
   [<a name="primes_upto_pairwise_coprime-val"><b>primes_upto_pairwise_coprime</b></a>]  Theorem
      
      ⊢ ∀n x y. x ∈ primes_upto n ∧ y ∈ primes_upto n ∧ x ≠ y ⇒ coprime x y
   
   [<a name="primes_upto_subset_natural-val"><b>primes_upto_subset_natural</b></a>]  Theorem
      
      ⊢ ∀n. primes_upto n ⊆ natural n
   
   [<a name="proper_divisors_0-val"><b>proper_divisors_0</b></a>]  Theorem
      
      ⊢ proper_divisors 0 = ∅
   
   [<a name="proper_divisors_1-val"><b>proper_divisors_1</b></a>]  Theorem
      
      ⊢ proper_divisors 1 = ∅
   
   [<a name="proper_divisors_by_less_divisors-val"><b>proper_divisors_by_less_divisors</b></a>]  Theorem
      
      ⊢ ∀n. proper_divisors n = less_divisors n DELETE 1
   
   [<a name="proper_divisors_element-val"><b>proper_divisors_element</b></a>]  Theorem
      
      ⊢ ∀n x. x ∈ proper_divisors n ⇔ 1 &lt; x ∧ x &lt; n ∧ x divides n
   
   [<a name="proper_divisors_finite-val"><b>proper_divisors_finite</b></a>]  Theorem
      
      ⊢ ∀n. FINITE (proper_divisors n)
   
   [<a name="proper_divisors_has_cofactor-val"><b>proper_divisors_has_cofactor</b></a>]  Theorem
      
      ⊢ ∀n d. d ∈ proper_divisors n ⇒ n DIV d ∈ proper_divisors n
   
   [<a name="proper_divisors_max_min-val"><b>proper_divisors_max_min</b></a>]  Theorem
      
      ⊢ ∀n. proper_divisors n ≠ ∅ ⇒
            MAX_SET (proper_divisors n) = n DIV MIN_SET (proper_divisors n) ∧
            MIN_SET (proper_divisors n) = n DIV MAX_SET (proper_divisors n)
   
   [<a name="proper_divisors_min_gt_1-val"><b>proper_divisors_min_gt_1</b></a>]  Theorem
      
      ⊢ ∀n. proper_divisors n ≠ ∅ ⇒ 1 &lt; MIN_SET (proper_divisors n)
   
   [<a name="proper_divisors_not_1-val"><b>proper_divisors_not_1</b></a>]  Theorem
      
      ⊢ ∀n. 1 ∉ proper_divisors n
   
   [<a name="proper_divisors_prime-val"><b>proper_divisors_prime</b></a>]  Theorem
      
      ⊢ ∀n. prime n ⇒ proper_divisors n = ∅
   
   [<a name="proper_divisors_subset-val"><b>proper_divisors_subset</b></a>]  Theorem
      
      ⊢ ∀n. proper_divisors n ⊆ less_divisors n
   
   [<a name="rec_phi_0-val"><b>rec_phi_0</b></a>]  Theorem
      
      ⊢ rec_phi 0 = 0
   
   [<a name="rec_phi_1-val"><b>rec_phi_1</b></a>]  Theorem
      
      ⊢ rec_phi 1 = 1
   
   [<a name="rec_phi_def-val"><b>rec_phi_def</b></a>]  Theorem
      
      ⊢ ∀n. rec_phi n =
            if n = 0 then 0
            else if n = 1 then 1
            else n − ∑ (λa. rec_phi a) {m | m &lt; n ∧ m divides n}
   
   [<a name="rec_phi_eq_phi-val"><b>rec_phi_eq_phi</b></a>]  Theorem
      
      ⊢ ∀n. rec_phi n = phi n
   
   [<a name="rec_phi_ind-val"><b>rec_phi_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀n. (∀a. n ≠ 0 ∧ n ≠ 1 ∧ a ∈ {m | m &lt; n ∧ m divides n} ⇒ P a) ⇒
                 P n) ⇒
            ∀v. P v
   
   [<a name="self_to_log_index_member-val"><b>self_to_log_index_member</b></a>]  Theorem
      
      ⊢ ∀n x. MEM x [1 .. n] ⇒ MEM (x ** LOG x n) [1 .. n]
   
   [<a name="set_lcm_prime_powers_upto_eqn-val"><b>set_lcm_prime_powers_upto_eqn</b></a>]  Theorem
      
      ⊢ ∀n. set_lcm (prime_powers_upto n) = PROD_SET (prime_powers_upto n)
   
   [<a name="sigma_eq_perfect_power_bounds_1-val"><b>sigma_eq_perfect_power_bounds_1</b></a>]  Theorem
      
      ⊢ ∀p. 1 &lt; p ⇒
            ∀f. (∀n. 0 &lt; n ⇒ p ** n = ∑ (λd. d * f d) (divisors n)) ⇒
                (∀n. 0 &lt; n ⇒ n * f n ≤ p ** n) ∧
                ∀n. 0 &lt; n ⇒ p ** n − TWICE (p ** HALF n) &lt; n * f n
   
   [<a name="sigma_eq_perfect_power_bounds_2-val"><b>sigma_eq_perfect_power_bounds_2</b></a>]  Theorem
      
      ⊢ ∀p. 1 &lt; p ⇒
            ∀f. (∀n. 0 &lt; n ⇒ p ** n = ∑ (λd. d * f d) (divisors n)) ⇒
                (∀n. 0 &lt; n ⇒ n * f n ≤ p ** n) ∧
                ∀n. 0 &lt; n ⇒ (p ** HALF n − 2) * p ** HALF n &lt; n * f n
   
   [<a name="sq_free_disjoint-val"><b>sq_free_disjoint</b></a>]  Theorem
      
      ⊢ ∀s. DISJOINT (sq_free s) (non_sq_free s)
   
   [<a name="sq_free_disjoint_even_odd-val"><b>sq_free_disjoint_even_odd</b></a>]  Theorem
      
      ⊢ ∀s. DISJOINT (even_sq_free s) (odd_sq_free s)
   
   [<a name="sq_free_element-val"><b>sq_free_element</b></a>]  Theorem
      
      ⊢ ∀s n. n ∈ sq_free s ⇔ n ∈ s ∧ square_free n
   
   [<a name="sq_free_finite-val"><b>sq_free_finite</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ FINITE (sq_free s)
   
   [<a name="sq_free_inter-val"><b>sq_free_inter</b></a>]  Theorem
      
      ⊢ ∀s. sq_free s ∩ non_sq_free s = ∅
   
   [<a name="sq_free_inter_even_odd-val"><b>sq_free_inter_even_odd</b></a>]  Theorem
      
      ⊢ ∀s. even_sq_free s ∩ odd_sq_free s = ∅
   
   [<a name="sq_free_split-val"><b>sq_free_split</b></a>]  Theorem
      
      ⊢ ∀s. s = sq_free s ∪ non_sq_free s ∧ sq_free s ∩ non_sq_free s = ∅
   
   [<a name="sq_free_split_even_odd-val"><b>sq_free_split_even_odd</b></a>]  Theorem
      
      ⊢ ∀s. sq_free s = even_sq_free s ∪ odd_sq_free s ∧
            even_sq_free s ∩ odd_sq_free s = ∅
   
   [<a name="sq_free_subset-val"><b>sq_free_subset</b></a>]  Theorem
      
      ⊢ ∀s. sq_free s ⊆ s
   
   [<a name="sq_free_union-val"><b>sq_free_union</b></a>]  Theorem
      
      ⊢ ∀s. s = sq_free s ∪ non_sq_free s
   
   [<a name="sq_free_union_even_odd-val"><b>sq_free_union_even_odd</b></a>]  Theorem
      
      ⊢ ∀s. sq_free s = even_sq_free s ∪ odd_sq_free s
   
   [<a name="sqrt_upper-val"><b>sqrt_upper</b></a>]  Theorem
      
      ⊢ ∀n. SQRT n ≤ 2 ** ulog n
   
   [<a name="square_0-val"><b>square_0</b></a>]  Theorem
      
      ⊢ square 0
   
   [<a name="square_1-val"><b>square_1</b></a>]  Theorem
      
      ⊢ square 1
   
   [<a name="square_alt-val"><b>square_alt</b></a>]  Theorem
      
      ⊢ ∀n. square n ⇔ ∃k. n = k²
   
   [<a name="square_eqn-val"><b>square_eqn</b></a>]  Theorem
      
      ⊢ ∀n. square n ⇔ (SQRT n)² = n
   
   [<a name="square_free_1-val"><b>square_free_1</b></a>]  Theorem
      
      ⊢ square_free 1
   
   [<a name="square_free_prime-val"><b>square_free_prime</b></a>]  Theorem
      
      ⊢ ∀n. prime n ⇒ square_free n
   
   [<a name="sum_image_divisors_cong-val"><b>sum_image_divisors_cong</b></a>]  Theorem
      
      ⊢ ∀f g. f 0 = g 0 ∧ (∀n. ∑ f (divisors n) = ∑ g (divisors n)) ⇒ f = g
   
   [<a name="sum_over_count_by_divisors-val"><b>sum_over_count_by_divisors</b></a>]  Theorem
      
      ⊢ ∀f n.
          ∑ f (count n) =
          ∑ (∑ f) (IMAGE (preimage (gcd n) (count n)) (divisors n))
   
   [<a name="sum_over_count_by_gcd_partition-val"><b>sum_over_count_by_gcd_partition</b></a>]  Theorem
      
      ⊢ ∀f n. ∑ f (count n) = ∑ (∑ f) (partition (feq (gcd n)) (count n))
   
   [<a name="sum_over_natural_by_divisors-val"><b>sum_over_natural_by_divisors</b></a>]  Theorem
      
      ⊢ ∀f n.
          ∑ f (natural n) = ∑ (∑ f) (IMAGE (gcd_matches n) (divisors n))
   
   [<a name="sum_over_natural_by_gcd_partition-val"><b>sum_over_natural_by_gcd_partition</b></a>]  Theorem
      
      ⊢ ∀f n.
          ∑ f (natural n) = ∑ (∑ f) (partition (feq (gcd n)) (natural n))
   
   [<a name="sum_over_natural_by_preimage_divisors-val"><b>sum_over_natural_by_preimage_divisors</b></a>]  Theorem
      
      ⊢ ∀f n.
          ∑ f (natural n) =
          ∑ (∑ f) (IMAGE (preimage (gcd n) (natural n)) (divisors n))
   
   [<a name="sum_over_upto_by_divisors-val"><b>sum_over_upto_by_divisors</b></a>]  Theorem
      
      ⊢ ∀f n.
          0 &lt; n ⇒
          ∑ f (upto n) =
          ∑ (∑ f) (IMAGE (preimage (gcd n) (upto n)) (divisors n))
   
   [<a name="sum_over_upto_by_gcd_partition-val"><b>sum_over_upto_by_gcd_partition</b></a>]  Theorem
      
      ⊢ ∀f n. ∑ f (upto n) = ∑ (∑ f) (partition (feq (gcd n)) (upto n))
   
   [<a name="total_prime_divisors_element-val"><b>total_prime_divisors_element</b></a>]  Theorem
      
      ⊢ ∀m n p.
          p ∈ total_prime_divisors m n ⇔
          p ∈ prime_divisors m ∨ p ∈ prime_divisors n
   
   [<a name="total_prime_divisors_finite-val"><b>total_prime_divisors_finite</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ∧ 0 &lt; n ⇒ FINITE (total_prime_divisors m n)
   
   [<a name="total_prime_divisors_max_image_pairwise_coprime-val"><b>total_prime_divisors_max_image_pairwise_coprime</b></a>]  Theorem
      
      ⊢ ∀m n x y.
          x ∈
          IMAGE (λp. p ** MAX (ppidx m) (ppidx n))
            (total_prime_divisors m n) ∧
          y ∈
          IMAGE (λp. p ** MAX (ppidx m) (ppidx n))
            (total_prime_divisors m n) ∧ x ≠ y ⇒
          coprime x y
   
   [<a name="total_prime_divisors_pairwise_coprime-val"><b>total_prime_divisors_pairwise_coprime</b></a>]  Theorem
      
      ⊢ ∀m n x y.
          x ∈ total_prime_divisors m n ∧ y ∈ total_prime_divisors m n ∧
          x ≠ y ⇒
          coprime x y
   
   [<a name="two_factors_property-val"><b>two_factors_property</b></a>]  Theorem
      
      ⊢ ∀n a b. n = a * b ⇒ a ≤ SQRT n ∨ b ≤ SQRT n
   
   [<a name="two_factors_property_1-val"><b>two_factors_property_1</b></a>]  Theorem
      
      ⊢ ∀n a b. n = a * b ∧ a &lt; SQRT n ⇒ SQRT n ≤ b
   
   [<a name="two_factors_property_2-val"><b>two_factors_property_2</b></a>]  Theorem
      
      ⊢ ∀n a b. n = a * b ∧ SQRT n &lt; a ⇒ b ≤ SQRT n
   
   [<a name="ulog_0-val"><b>ulog_0</b></a>]  Theorem
      
      ⊢ ulog 0 = 0
   
   [<a name="ulog_1-val"><b>ulog_1</b></a>]  Theorem
      
      ⊢ ulog 1 = 0
   
   [<a name="ulog_2-val"><b>ulog_2</b></a>]  Theorem
      
      ⊢ ulog 2 = 1
   
   [<a name="ulog_2_exp-val"><b>ulog_2_exp</b></a>]  Theorem
      
      ⊢ ∀n. ulog (2 ** n) = n
   
   [<a name="ulog_LOG2-val"><b>ulog_LOG2</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ LOG2 n ≤ ulog n ∧ ulog n ≤ 1 + LOG2 n
   
   [<a name="ulog_alt-val"><b>ulog_alt</b></a>]  Theorem
      
      ⊢ ∀n. ulog n =
            if n = 0 then 0
            else if n power_of 2 then LOG2 n
            else SUC (LOG2 n)
   
   [<a name="ulog_def_alt-val"><b>ulog_def_alt</b></a>]  Theorem
      
      ⊢ ulog 0 = 0 ∧
        ∀n. 0 &lt; n ⇒ ∀m. ulog n = m ⇔ n ≤ 2 ** m ∧ 2 ** m &lt; TWICE n
   
   [<a name="ulog_eq_0-val"><b>ulog_eq_0</b></a>]  Theorem
      
      ⊢ ∀n. ulog n = 0 ⇔ n = 0 ∨ n = 1
   
   [<a name="ulog_eq_1-val"><b>ulog_eq_1</b></a>]  Theorem
      
      ⊢ ∀n. ulog n = 1 ⇔ n = 2
   
   [<a name="ulog_eq_self-val"><b>ulog_eq_self</b></a>]  Theorem
      
      ⊢ ∀n. ulog n = n ⇔ n = 0
   
   [<a name="ulog_eqn-val"><b>ulog_eqn</b></a>]  Theorem
      
      ⊢ ∀n. ulog n = if 1 &lt; n then SUC (LOG2 (n − 1)) else 0
   
   [<a name="ulog_even-val"><b>ulog_even</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ∧ EVEN n ⇒ ulog n = 1 + ulog (HALF n)
   
   [<a name="ulog_exp-val"><b>ulog_exp</b></a>]  Theorem
      
      ⊢ ∀m n. ulog (m ** n) ≤ n * ulog m
   
   [<a name="ulog_exp_exact-val"><b>ulog_exp_exact</b></a>]  Theorem
      
      ⊢ ∀n. 2 ** ulog n = n ⇔ n power_of 2
   
   [<a name="ulog_exp_not_exact-val"><b>ulog_exp_not_exact</b></a>]  Theorem
      
      ⊢ ∀n. ¬(n power_of 2) ⇒ 2 ** ulog n ≠ n
   
   [<a name="ulog_ge_1-val"><b>ulog_ge_1</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ 1 ≤ ulog n
   
   [<a name="ulog_half-val"><b>ulog_half</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ ulog (HALF n) + 1 ≤ ulog n
   
   [<a name="ulog_le-val"><b>ulog_le</b></a>]  Theorem
      
      ⊢ ∀m n. n ≤ m ⇒ ulog n ≤ ulog m
   
   [<a name="ulog_le_1-val"><b>ulog_le_1</b></a>]  Theorem
      
      ⊢ ∀n. ulog n ≤ 1 ⇔ n ≤ 2
   
   [<a name="ulog_le_self-val"><b>ulog_le_self</b></a>]  Theorem
      
      ⊢ ∀n. ulog n ≤ n
   
   [<a name="ulog_lt-val"><b>ulog_lt</b></a>]  Theorem
      
      ⊢ ∀m n. n &lt; m ⇒ ulog n ≤ ulog m
   
   [<a name="ulog_lt_self-val"><b>ulog_lt_self</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ulog n &lt; n
   
   [<a name="ulog_mult-val"><b>ulog_mult</b></a>]  Theorem
      
      ⊢ ∀m n. ulog (m * n) ≤ ulog m + ulog n
   
   [<a name="ulog_odd-val"><b>ulog_odd</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ∧ ODD n ⇒ ulog (HALF n) + 1 ≤ ulog n
   
   [<a name="ulog_pos-val"><b>ulog_pos</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ 0 &lt; ulog n
   
   [<a name="ulog_property-val"><b>ulog_property</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ 2 ** ulog n &lt; TWICE n ∧ n ≤ 2 ** ulog n
   
   [<a name="ulog_property_not_exact-val"><b>ulog_property_not_exact</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ∧ ¬(n power_of 2) ⇒ n &lt; 2 ** ulog n
   
   [<a name="ulog_property_odd-val"><b>ulog_property_odd</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ∧ ODD n ⇒ n &lt; 2 ** ulog n
   
   [<a name="ulog_sq_gt_1-val"><b>ulog_sq_gt_1</b></a>]  Theorem
      
      ⊢ ∀n. 2 &lt; n ⇒ 1 &lt; (ulog n)²
   
   [<a name="ulog_suc-val"><b>ulog_suc</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ulog (SUC n) = SUC (LOG2 n)
   
   [<a name="ulog_thm-val"><b>ulog_thm</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀m. ulog n = m ⇔ 2 ** m &lt; TWICE n ∧ n ≤ 2 ** m
   
   [<a name="ulog_twice_sq-val"><b>ulog_twice_sq</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ 4 ≤ (TWICE (ulog n))²
   
   [<a name="ulog_unique-val"><b>ulog_unique</b></a>]  Theorem
      
      ⊢ ∀m n. 2 ** m &lt; TWICE n ∧ n ≤ 2 ** m ⇒ ulog n = m
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/algebra/base/.hol/objs/primeScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-2</a></em></p></body></html>
