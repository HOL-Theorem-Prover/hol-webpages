<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure combinatoricsTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure combinatoricsTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/algebra/base/.hol/objs/combinatoricsScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature combinatoricsTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#MDILATE_def-val">MDILATE_def</a> : thm
<a name="line7"></a>    val <a href="#PROD-val">PROD</a> : thm
<a name="line8"></a>    val <a href="#PROD_ACC_DEF-val">PROD_ACC_DEF</a> : thm
<a name="line9"></a>    val <a href="#arrange_def-val">arrange_def</a> : thm
<a name="line10"></a>    val <a href="#choose_def-val">choose_def</a> : thm
<a name="line11"></a>    val <a href="#interleave_def-val">interleave_def</a> : thm
<a name="line12"></a>    val <a href="#lcm_upto_def-val">lcm_upto_def</a> : thm
<a name="line13"></a>    val <a href="#leibniz_def-val">leibniz_def</a> : thm
<a name="line14"></a>    val <a href="#leibniz_zigzag_def-val">leibniz_zigzag_def</a> : thm
<a name="line15"></a>    val <a href="#list_count_def-val">list_count_def</a> : thm
<a name="line16"></a>    val <a href="#list_lcm_def-val">list_lcm_def</a> : thm
<a name="line17"></a>    val <a href="#monocoloured_def-val">monocoloured_def</a> : thm
<a name="line18"></a>    val <a href="#multicoloured_def-val">multicoloured_def</a> : thm
<a name="line19"></a>    val <a href="#necklace_def-val">necklace_def</a> : thm
<a name="line20"></a>    val <a href="#perm_count_def-val">perm_count_def</a> : thm
<a name="line21"></a>    val <a href="#perm_def-val">perm_def</a> : thm
<a name="line22"></a>    val <a href="#perm_set_def-val">perm_set_def</a> : thm
<a name="line23"></a>    val <a href="#recordtype_triple_seldef_a_def-val">recordtype_triple_seldef_a_def</a> : thm
<a name="line24"></a>    val <a href="#recordtype_triple_seldef_a_fupd_def-val">recordtype_triple_seldef_a_fupd_def</a> : thm
<a name="line25"></a>    val <a href="#recordtype_triple_seldef_b_def-val">recordtype_triple_seldef_b_def</a> : thm
<a name="line26"></a>    val <a href="#recordtype_triple_seldef_b_fupd_def-val">recordtype_triple_seldef_b_fupd_def</a> : thm
<a name="line27"></a>    val <a href="#recordtype_triple_seldef_c_def-val">recordtype_triple_seldef_c_def</a> : thm
<a name="line28"></a>    val <a href="#recordtype_triple_seldef_c_fupd_def-val">recordtype_triple_seldef_c_fupd_def</a> : thm
<a name="line29"></a>    val <a href="#rotate_def-val">rotate_def</a> : thm
<a name="line30"></a>    val <a href="#set_lcm_def-val">set_lcm_def</a> : thm
<a name="line31"></a>    val <a href="#sub_count_def-val">sub_count_def</a> : thm
<a name="line32"></a>    val <a href="#sub_sets_def-val">sub_sets_def</a> : thm
<a name="line33"></a>    val <a href="#triple_TY_DEF-val">triple_TY_DEF</a> : thm
<a name="line34"></a>    val <a href="#triple_case_def-val">triple_case_def</a> : thm
<a name="line35"></a>    val <a href="#triple_size_def-val">triple_size_def</a> : thm
<a name="line36"></a>    val <a href="#triplet_def-val">triplet_def</a> : thm
<a name="line37"></a>    val <a href="#turn_def-val">turn_def</a> : thm
<a name="line38"></a>  
<a name="line39"></a>  (*  Theorems  *)
<a name="line40"></a>    val <a href="#CARD_LIST_TO_SET_EQ-val">CARD_LIST_TO_SET_EQ</a> : thm
<a name="line41"></a>    val <a href="#DILATE_0_0-val">DILATE_0_0</a> : thm
<a name="line42"></a>    val <a href="#DILATE_0_CONS-val">DILATE_0_CONS</a> : thm
<a name="line43"></a>    val <a href="#DILATE_0_EL-val">DILATE_0_EL</a> : thm
<a name="line44"></a>    val <a href="#DILATE_0_EQ_NIL-val">DILATE_0_EQ_NIL</a> : thm
<a name="line45"></a>    val <a href="#DILATE_0_LAST-val">DILATE_0_LAST</a> : thm
<a name="line46"></a>    val <a href="#DILATE_0_LENGTH-val">DILATE_0_LENGTH</a> : thm
<a name="line47"></a>    val <a href="#DILATE_0_LENGTH_LOWER-val">DILATE_0_LENGTH_LOWER</a> : thm
<a name="line48"></a>    val <a href="#DILATE_0_LENGTH_UPPER-val">DILATE_0_LENGTH_UPPER</a> : thm
<a name="line49"></a>    val <a href="#DILATE_0_SUC-val">DILATE_0_SUC</a> : thm
<a name="line50"></a>    val <a href="#DILATE_CONS-val">DILATE_CONS</a> : thm
<a name="line51"></a>    val <a href="#DILATE_NIL-val">DILATE_NIL</a> : thm
<a name="line52"></a>    val <a href="#DILATE_SING-val">DILATE_SING</a> : thm
<a name="line53"></a>    val <a href="#DILATE_def-val">DILATE_def</a> : thm
<a name="line54"></a>    val <a href="#DILATE_ind-val">DILATE_ind</a> : thm
<a name="line55"></a>    val <a href="#EL_ALL_PROPERTY-val">EL_ALL_PROPERTY</a> : thm
<a name="line56"></a>    val <a href="#EL_MAP3-val">EL_MAP3</a> : thm
<a name="line57"></a>    val <a href="#EVERY_ELEMENT_PROPERTY-val">EVERY_ELEMENT_PROPERTY</a> : thm
<a name="line58"></a>    val <a href="#EVERY_LT_IMP_EVERY_LE-val">EVERY_LT_IMP_EVERY_LE</a> : thm
<a name="line59"></a>    val <a href="#EVERY_MONOTONIC_MAP-val">EVERY_MONOTONIC_MAP</a> : thm
<a name="line60"></a>    val <a href="#EXISTS_triple-val">EXISTS_triple</a> : thm
<a name="line61"></a>    val <a href="#FILTER_EL_NEXT_IDX-val">FILTER_EL_NEXT_IDX</a> : thm
<a name="line62"></a>    val <a href="#FINITE_SURJ_IFF-val">FINITE_SURJ_IFF</a> : thm
<a name="line63"></a>    val <a href="#FORALL_triple-val">FORALL_triple</a> : thm
<a name="line64"></a>    val <a href="#FUNPOW_cons_eq_map_0-val">FUNPOW_cons_eq_map_0</a> : thm
<a name="line65"></a>    val <a href="#FUNPOW_cons_eq_map_1-val">FUNPOW_cons_eq_map_1</a> : thm
<a name="line66"></a>    val <a href="#FUNPOW_cons_head-val">FUNPOW_cons_head</a> : thm
<a name="line67"></a>    val <a href="#FUNSET_ALT-val">FUNSET_ALT</a> : thm
<a name="line68"></a>    val <a href="#GENLIST_MONO_DEC-val">GENLIST_MONO_DEC</a> : thm
<a name="line69"></a>    val <a href="#GENLIST_MONO_INC-val">GENLIST_MONO_INC</a> : thm
<a name="line70"></a>    val <a href="#GENLIST_binomial_index_shift-val">GENLIST_binomial_index_shift</a> : thm
<a name="line71"></a>    val <a href="#INJ_IFF_BIJ_IMAGE-val">INJ_IFF_BIJ_IMAGE</a> : thm
<a name="line72"></a>    val <a href="#INJ_IMAGE_BIJ_IFF-val">INJ_IMAGE_BIJ_IFF</a> : thm
<a name="line73"></a>    val <a href="#INJ_IMAGE_IFF-val">INJ_IMAGE_IFF</a> : thm
<a name="line74"></a>    val <a href="#LENGTH_MAP3-val">LENGTH_MAP3</a> : thm
<a name="line75"></a>    val <a href="#LIST_TO_SET_REDUCTION-val">LIST_TO_SET_REDUCTION</a> : thm
<a name="line76"></a>    val <a href="#LUPDATE_APPEND_0-val">LUPDATE_APPEND_0</a> : thm
<a name="line77"></a>    val <a href="#LUPDATE_APPEND_0_1-val">LUPDATE_APPEND_0_1</a> : thm
<a name="line78"></a>    val <a href="#LUPDATE_APPEND_1-val">LUPDATE_APPEND_1</a> : thm
<a name="line79"></a>    val <a href="#LUPDATE_DIFF_SPOT-val">LUPDATE_DIFF_SPOT</a> : thm
<a name="line80"></a>    val <a href="#LUPDATE_EL-val">LUPDATE_EL</a> : thm
<a name="line81"></a>    val <a href="#LUPDATE_LEN-val">LUPDATE_LEN</a> : thm
<a name="line82"></a>    val <a href="#LUPDATE_SAME_SPOT-val">LUPDATE_SAME_SPOT</a> : thm
<a name="line83"></a>    val <a href="#MAP2_LE-val">MAP2_LE</a> : thm
<a name="line84"></a>    val <a href="#MAP3-val">MAP3</a> : thm
<a name="line85"></a>    val <a href="#MAP3_DEF-val">MAP3_DEF</a> : thm
<a name="line86"></a>    val <a href="#MAP3_IND-val">MAP3_IND</a> : thm
<a name="line87"></a>    val <a href="#MAP3_LE-val">MAP3_LE</a> : thm
<a name="line88"></a>    val <a href="#MAP_LE-val">MAP_LE</a> : thm
<a name="line89"></a>    val <a href="#MAX_LIST_MONO_MAP-val">MAX_LIST_MONO_MAP</a> : thm
<a name="line90"></a>    val <a href="#MDILATE_0-val">MDILATE_0</a> : thm
<a name="line91"></a>    val <a href="#MDILATE_1-val">MDILATE_1</a> : thm
<a name="line92"></a>    val <a href="#MDILATE_CONS-val">MDILATE_CONS</a> : thm
<a name="line93"></a>    val <a href="#MDILATE_EL-val">MDILATE_EL</a> : thm
<a name="line94"></a>    val <a href="#MDILATE_EQ_NIL-val">MDILATE_EQ_NIL</a> : thm
<a name="line95"></a>    val <a href="#MDILATE_LAST-val">MDILATE_LAST</a> : thm
<a name="line96"></a>    val <a href="#MDILATE_LENGTH-val">MDILATE_LENGTH</a> : thm
<a name="line97"></a>    val <a href="#MDILATE_LENGTH_LOWER-val">MDILATE_LENGTH_LOWER</a> : thm
<a name="line98"></a>    val <a href="#MDILATE_LENGTH_UPPER-val">MDILATE_LENGTH_UPPER</a> : thm
<a name="line99"></a>    val <a href="#MDILATE_NIL-val">MDILATE_NIL</a> : thm
<a name="line100"></a>    val <a href="#MDILATE_SING-val">MDILATE_SING</a> : thm
<a name="line101"></a>    val <a href="#MEM_MAP2-val">MEM_MAP2</a> : thm
<a name="line102"></a>    val <a href="#MEM_MAP2_LOWER-val">MEM_MAP2_LOWER</a> : thm
<a name="line103"></a>    val <a href="#MEM_MAP2_UPPER-val">MEM_MAP2_UPPER</a> : thm
<a name="line104"></a>    val <a href="#MEM_MAP3-val">MEM_MAP3</a> : thm
<a name="line105"></a>    val <a href="#MEM_MAP3_LOWER-val">MEM_MAP3_LOWER</a> : thm
<a name="line106"></a>    val <a href="#MEM_MAP3_UPPER-val">MEM_MAP3_UPPER</a> : thm
<a name="line107"></a>    val <a href="#MEM_MAP_LOWER-val">MEM_MAP_LOWER</a> : thm
<a name="line108"></a>    val <a href="#MEM_MAP_UPPER-val">MEM_MAP_UPPER</a> : thm
<a name="line109"></a>    val <a href="#MIN_LIST_MONO_MAP-val">MIN_LIST_MONO_MAP</a> : thm
<a name="line110"></a>    val <a href="#MONO_LIST_TO_SET-val">MONO_LIST_TO_SET</a> : thm
<a name="line111"></a>    val <a href="#PAD_LEFT_0-val">PAD_LEFT_0</a> : thm
<a name="line112"></a>    val <a href="#PAD_LEFT_BY_LEFT-val">PAD_LEFT_BY_LEFT</a> : thm
<a name="line113"></a>    val <a href="#PAD_LEFT_BY_RIGHT-val">PAD_LEFT_BY_RIGHT</a> : thm
<a name="line114"></a>    val <a href="#PAD_LEFT_CONS-val">PAD_LEFT_CONS</a> : thm
<a name="line115"></a>    val <a href="#PAD_LEFT_EQ_NIL-val">PAD_LEFT_EQ_NIL</a> : thm
<a name="line116"></a>    val <a href="#PAD_LEFT_ID-val">PAD_LEFT_ID</a> : thm
<a name="line117"></a>    val <a href="#PAD_LEFT_LAST-val">PAD_LEFT_LAST</a> : thm
<a name="line118"></a>    val <a href="#PAD_LEFT_LENGTH-val">PAD_LEFT_LENGTH</a> : thm
<a name="line119"></a>    val <a href="#PAD_LEFT_NIL-val">PAD_LEFT_NIL</a> : thm
<a name="line120"></a>    val <a href="#PAD_LEFT_NIL_EQ-val">PAD_LEFT_NIL_EQ</a> : thm
<a name="line121"></a>    val <a href="#PAD_RIGHT_0-val">PAD_RIGHT_0</a> : thm
<a name="line122"></a>    val <a href="#PAD_RIGHT_BY_LEFT-val">PAD_RIGHT_BY_LEFT</a> : thm
<a name="line123"></a>    val <a href="#PAD_RIGHT_BY_RIGHT-val">PAD_RIGHT_BY_RIGHT</a> : thm
<a name="line124"></a>    val <a href="#PAD_RIGHT_CONS-val">PAD_RIGHT_CONS</a> : thm
<a name="line125"></a>    val <a href="#PAD_RIGHT_EQ_NIL-val">PAD_RIGHT_EQ_NIL</a> : thm
<a name="line126"></a>    val <a href="#PAD_RIGHT_ID-val">PAD_RIGHT_ID</a> : thm
<a name="line127"></a>    val <a href="#PAD_RIGHT_LENGTH-val">PAD_RIGHT_LENGTH</a> : thm
<a name="line128"></a>    val <a href="#PAD_RIGHT_NIL-val">PAD_RIGHT_NIL</a> : thm
<a name="line129"></a>    val <a href="#PAD_RIGHT_NIL_EQ-val">PAD_RIGHT_NIL_EQ</a> : thm
<a name="line130"></a>    val <a href="#PAD_RIGHT_SNOC-val">PAD_RIGHT_SNOC</a> : thm
<a name="line131"></a>    val <a href="#POSITIVE_THM-val">POSITIVE_THM</a> : thm
<a name="line132"></a>    val <a href="#PROD_ACC_PROD_LEM-val">PROD_ACC_PROD_LEM</a> : thm
<a name="line133"></a>    val <a href="#PROD_ACC_SUM_LEM-val">PROD_ACC_SUM_LEM</a> : thm
<a name="line134"></a>    val <a href="#PROD_APPEND-val">PROD_APPEND</a> : thm
<a name="line135"></a>    val <a href="#PROD_CONS-val">PROD_CONS</a> : thm
<a name="line136"></a>    val <a href="#PROD_CONSTANT-val">PROD_CONSTANT</a> : thm
<a name="line137"></a>    val <a href="#PROD_EQ_0-val">PROD_EQ_0</a> : thm
<a name="line138"></a>    val <a href="#PROD_GENLIST_K-val">PROD_GENLIST_K</a> : thm
<a name="line139"></a>    val <a href="#PROD_IMAGE_eq_PROD_MAP_SET_TO_LIST-val">PROD_IMAGE_eq_PROD_MAP_SET_TO_LIST</a> : thm
<a name="line140"></a>    val <a href="#PROD_MAP_FOLDL-val">PROD_MAP_FOLDL</a> : thm
<a name="line141"></a>    val <a href="#PROD_NIL-val">PROD_NIL</a> : thm
<a name="line142"></a>    val <a href="#PROD_POS-val">PROD_POS</a> : thm
<a name="line143"></a>    val <a href="#PROD_POS_ALT-val">PROD_POS_ALT</a> : thm
<a name="line144"></a>    val <a href="#PROD_PROD_ACC-val">PROD_PROD_ACC</a> : thm
<a name="line145"></a>    val <a href="#PROD_SING-val">PROD_SING</a> : thm
<a name="line146"></a>    val <a href="#PROD_SNOC-val">PROD_SNOC</a> : thm
<a name="line147"></a>    val <a href="#PROD_SQUARING_LIST-val">PROD_SQUARING_LIST</a> : thm
<a name="line148"></a>    val <a href="#PROD_eq_1-val">PROD_eq_1</a> : thm
<a name="line149"></a>    val <a href="#PROD_eval-val">PROD_eval</a> : thm
<a name="line150"></a>    val <a href="#SUM_ADD_GENLIST-val">SUM_ADD_GENLIST</a> : thm
<a name="line151"></a>    val <a href="#SUM_CONS-val">SUM_CONS</a> : thm
<a name="line152"></a>    val <a href="#SUM_CONSTANT-val">SUM_CONSTANT</a> : thm
<a name="line153"></a>    val <a href="#SUM_DECOMPOSE_FIRST-val">SUM_DECOMPOSE_FIRST</a> : thm
<a name="line154"></a>    val <a href="#SUM_DECOMPOSE_FIRST_LAST-val">SUM_DECOMPOSE_FIRST_LAST</a> : thm
<a name="line155"></a>    val <a href="#SUM_DECOMPOSE_LAST-val">SUM_DECOMPOSE_LAST</a> : thm
<a name="line156"></a>    val <a href="#SUM_DOUBLING_LIST-val">SUM_DOUBLING_LIST</a> : thm
<a name="line157"></a>    val <a href="#SUM_EQ_0-val">SUM_EQ_0</a> : thm
<a name="line158"></a>    val <a href="#SUM_GENLIST-val">SUM_GENLIST</a> : thm
<a name="line159"></a>    val <a href="#SUM_GENLIST_APPEND-val">SUM_GENLIST_APPEND</a> : thm
<a name="line160"></a>    val <a href="#SUM_GENLIST_K-val">SUM_GENLIST_K</a> : thm
<a name="line161"></a>    val <a href="#SUM_GENLIST_MOD-val">SUM_GENLIST_MOD</a> : thm
<a name="line162"></a>    val <a href="#SUM_GENLIST_REVERSE-val">SUM_GENLIST_REVERSE</a> : thm
<a name="line163"></a>    val <a href="#SUM_IMAGE_count-val">SUM_IMAGE_count</a> : thm
<a name="line164"></a>    val <a href="#SUM_IMAGE_upto-val">SUM_IMAGE_upto</a> : thm
<a name="line165"></a>    val <a href="#SUM_LE-val">SUM_LE</a> : thm
<a name="line166"></a>    val <a href="#SUM_LEFT_ADD_DISTRIB-val">SUM_LEFT_ADD_DISTRIB</a> : thm
<a name="line167"></a>    val <a href="#SUM_LE_EL-val">SUM_LE_EL</a> : thm
<a name="line168"></a>    val <a href="#SUM_LE_MEM-val">SUM_LE_MEM</a> : thm
<a name="line169"></a>    val <a href="#SUM_LE_SUM_EL-val">SUM_LE_SUM_EL</a> : thm
<a name="line170"></a>    val <a href="#SUM_LOWER-val">SUM_LOWER</a> : thm
<a name="line171"></a>    val <a href="#SUM_MAP2_K-val">SUM_MAP2_K</a> : thm
<a name="line172"></a>    val <a href="#SUM_MAP2_UPPER-val">SUM_MAP2_UPPER</a> : thm
<a name="line173"></a>    val <a href="#SUM_MAP3_K-val">SUM_MAP3_K</a> : thm
<a name="line174"></a>    val <a href="#SUM_MAP3_UPPER-val">SUM_MAP3_UPPER</a> : thm
<a name="line175"></a>    val <a href="#SUM_MAP_K-val">SUM_MAP_K</a> : thm
<a name="line176"></a>    val <a href="#SUM_MAP_K_LE-val">SUM_MAP_K_LE</a> : thm
<a name="line177"></a>    val <a href="#SUM_MAP_LE-val">SUM_MAP_LE</a> : thm
<a name="line178"></a>    val <a href="#SUM_MAP_LT-val">SUM_MAP_LT</a> : thm
<a name="line179"></a>    val <a href="#SUM_MAP_UPPER-val">SUM_MAP_UPPER</a> : thm
<a name="line180"></a>    val <a href="#SUM_MOD-val">SUM_MOD</a> : thm
<a name="line181"></a>    val <a href="#SUM_MONO_MAP-val">SUM_MONO_MAP</a> : thm
<a name="line182"></a>    val <a href="#SUM_MONO_MAP2-val">SUM_MONO_MAP2</a> : thm
<a name="line183"></a>    val <a href="#SUM_MONO_MAP3-val">SUM_MONO_MAP3</a> : thm
<a name="line184"></a>    val <a href="#SUM_MULT-val">SUM_MULT</a> : thm
<a name="line185"></a>    val <a href="#SUM_NIL-val">SUM_NIL</a> : thm
<a name="line186"></a>    val <a href="#SUM_RIGHT_ADD_DISTRIB-val">SUM_RIGHT_ADD_DISTRIB</a> : thm
<a name="line187"></a>    val <a href="#SUM_SING-val">SUM_SING</a> : thm
<a name="line188"></a>    val <a href="#SUM_UPPER-val">SUM_UPPER</a> : thm
<a name="line189"></a>    val <a href="#SURJ_CARD_IMAGE_EQ-val">SURJ_CARD_IMAGE_EQ</a> : thm
<a name="line190"></a>    val <a href="#arithmetic_sum_eqn-val">arithmetic_sum_eqn</a> : thm
<a name="line191"></a>    val <a href="#arithmetic_sum_eqn_alt-val">arithmetic_sum_eqn_alt</a> : thm
<a name="line192"></a>    val <a href="#arrange_0_n-val">arrange_0_n</a> : thm
<a name="line193"></a>    val <a href="#arrange_alt-val">arrange_alt</a> : thm
<a name="line194"></a>    val <a href="#arrange_eq_0-val">arrange_eq_0</a> : thm
<a name="line195"></a>    val <a href="#arrange_eqn-val">arrange_eqn</a> : thm
<a name="line196"></a>    val <a href="#arrange_formula-val">arrange_formula</a> : thm
<a name="line197"></a>    val <a href="#arrange_formula2-val">arrange_formula2</a> : thm
<a name="line198"></a>    val <a href="#arrange_n_0-val">arrange_n_0</a> : thm
<a name="line199"></a>    val <a href="#arrange_n_n-val">arrange_n_n</a> : thm
<a name="line200"></a>    val <a href="#arrange_n_n_alt-val">arrange_n_n_alt</a> : thm
<a name="line201"></a>    val <a href="#beta_0_n-val">beta_0_n</a> : thm
<a name="line202"></a>    val <a href="#beta_alt-val">beta_alt</a> : thm
<a name="line203"></a>    val <a href="#beta_divides_beta_factor-val">beta_divides_beta_factor</a> : thm
<a name="line204"></a>    val <a href="#beta_eq_0-val">beta_eq_0</a> : thm
<a name="line205"></a>    val <a href="#beta_eqn-val">beta_eqn</a> : thm
<a name="line206"></a>    val <a href="#beta_horizontal_0-val">beta_horizontal_0</a> : thm
<a name="line207"></a>    val <a href="#beta_horizontal_alt-val">beta_horizontal_alt</a> : thm
<a name="line208"></a>    val <a href="#beta_horizontal_element-val">beta_horizontal_element</a> : thm
<a name="line209"></a>    val <a href="#beta_horizontal_eqn-val">beta_horizontal_eqn</a> : thm
<a name="line210"></a>    val <a href="#beta_horizontal_len-val">beta_horizontal_len</a> : thm
<a name="line211"></a>    val <a href="#beta_horizontal_mem-val">beta_horizontal_mem</a> : thm
<a name="line212"></a>    val <a href="#beta_horizontal_mem_iff-val">beta_horizontal_mem_iff</a> : thm
<a name="line213"></a>    val <a href="#beta_horizontal_member-val">beta_horizontal_member</a> : thm
<a name="line214"></a>    val <a href="#beta_less_0-val">beta_less_0</a> : thm
<a name="line215"></a>    val <a href="#beta_n_0-val">beta_n_0</a> : thm
<a name="line216"></a>    val <a href="#beta_pos-val">beta_pos</a> : thm
<a name="line217"></a>    val <a href="#beta_sym-val">beta_sym</a> : thm
<a name="line218"></a>    val <a href="#big_lcm_corner_transform-val">big_lcm_corner_transform</a> : thm
<a name="line219"></a>    val <a href="#big_lcm_count_lower_bound-val">big_lcm_count_lower_bound</a> : thm
<a name="line220"></a>    val <a href="#big_lcm_eq_list_lcm-val">big_lcm_eq_list_lcm</a> : thm
<a name="line221"></a>    val <a href="#big_lcm_ge_max-val">big_lcm_ge_max</a> : thm
<a name="line222"></a>    val <a href="#big_lcm_lower_bound-val">big_lcm_lower_bound</a> : thm
<a name="line223"></a>    val <a href="#big_lcm_natural_eqn-val">big_lcm_natural_eqn</a> : thm
<a name="line224"></a>    val <a href="#big_lcm_non_decreasing-val">big_lcm_non_decreasing</a> : thm
<a name="line225"></a>    val <a href="#big_lcm_row_transform-val">big_lcm_row_transform</a> : thm
<a name="line226"></a>    val <a href="#big_lcm_seg_transform-val">big_lcm_seg_transform</a> : thm
<a name="line227"></a>    val <a href="#bij_eq_card-val">bij_eq_card</a> : thm
<a name="line228"></a>    val <a href="#bij_eq_card_eq-val">bij_eq_card_eq</a> : thm
<a name="line229"></a>    val <a href="#bij_eq_count-val">bij_eq_count</a> : thm
<a name="line230"></a>    val <a href="#bij_eq_empty-val">bij_eq_empty</a> : thm
<a name="line231"></a>    val <a href="#bij_eq_equiv_on-val">bij_eq_equiv_on</a> : thm
<a name="line232"></a>    val <a href="#bij_eq_finite-val">bij_eq_finite</a> : thm
<a name="line233"></a>    val <a href="#bij_eq_refl-val">bij_eq_refl</a> : thm
<a name="line234"></a>    val <a href="#bij_eq_sym-val">bij_eq_sym</a> : thm
<a name="line235"></a>    val <a href="#bij_eq_trans-val">bij_eq_trans</a> : thm
<a name="line236"></a>    val <a href="#bij_iff_preimage_card_eq_1-val">bij_iff_preimage_card_eq_1</a> : thm
<a name="line237"></a>    val <a href="#bij_preimage_sing-val">bij_preimage_sing</a> : thm
<a name="line238"></a>    val <a href="#binomial_0_n-val">binomial_0_n</a> : thm
<a name="line239"></a>    val <a href="#binomial_1_n-val">binomial_1_n</a> : thm
<a name="line240"></a>    val <a href="#binomial_alt-val">binomial_alt</a> : thm
<a name="line241"></a>    val <a href="#binomial_compute-val">binomial_compute</a> : thm
<a name="line242"></a>    val <a href="#binomial_def-val">binomial_def</a> : thm
<a name="line243"></a>    val <a href="#binomial_eq_0-val">binomial_eq_0</a> : thm
<a name="line244"></a>    val <a href="#binomial_fact-val">binomial_fact</a> : thm
<a name="line245"></a>    val <a href="#binomial_formula-val">binomial_formula</a> : thm
<a name="line246"></a>    val <a href="#binomial_formula2-val">binomial_formula2</a> : thm
<a name="line247"></a>    val <a href="#binomial_formula3-val">binomial_formula3</a> : thm
<a name="line248"></a>    val <a href="#binomial_horizontal_0-val">binomial_horizontal_0</a> : thm
<a name="line249"></a>    val <a href="#binomial_horizontal_element-val">binomial_horizontal_element</a> : thm
<a name="line250"></a>    val <a href="#binomial_horizontal_len-val">binomial_horizontal_len</a> : thm
<a name="line251"></a>    val <a href="#binomial_horizontal_max-val">binomial_horizontal_max</a> : thm
<a name="line252"></a>    val <a href="#binomial_horizontal_mem-val">binomial_horizontal_mem</a> : thm
<a name="line253"></a>    val <a href="#binomial_horizontal_mem_iff-val">binomial_horizontal_mem_iff</a> : thm
<a name="line254"></a>    val <a href="#binomial_horizontal_member-val">binomial_horizontal_member</a> : thm
<a name="line255"></a>    val <a href="#binomial_horizontal_pos-val">binomial_horizontal_pos</a> : thm
<a name="line256"></a>    val <a href="#binomial_horizontal_pos_alt-val">binomial_horizontal_pos_alt</a> : thm
<a name="line257"></a>    val <a href="#binomial_horizontal_sum-val">binomial_horizontal_sum</a> : thm
<a name="line258"></a>    val <a href="#binomial_iff-val">binomial_iff</a> : thm
<a name="line259"></a>    val <a href="#binomial_ind-val">binomial_ind</a> : thm
<a name="line260"></a>    val <a href="#binomial_index_shift-val">binomial_index_shift</a> : thm
<a name="line261"></a>    val <a href="#binomial_is_integer-val">binomial_is_integer</a> : thm
<a name="line262"></a>    val <a href="#binomial_less_0-val">binomial_less_0</a> : thm
<a name="line263"></a>    val <a href="#binomial_max-val">binomial_max</a> : thm
<a name="line264"></a>    val <a href="#binomial_middle_by_stirling-val">binomial_middle_by_stirling</a> : thm
<a name="line265"></a>    val <a href="#binomial_middle_upper_bound-val">binomial_middle_upper_bound</a> : thm
<a name="line266"></a>    val <a href="#binomial_mod_zero-val">binomial_mod_zero</a> : thm
<a name="line267"></a>    val <a href="#binomial_mod_zero_alt-val">binomial_mod_zero_alt</a> : thm
<a name="line268"></a>    val <a href="#binomial_monotone-val">binomial_monotone</a> : thm
<a name="line269"></a>    val <a href="#binomial_n_0-val">binomial_n_0</a> : thm
<a name="line270"></a>    val <a href="#binomial_n_1-val">binomial_n_1</a> : thm
<a name="line271"></a>    val <a href="#binomial_n_k-val">binomial_n_k</a> : thm
<a name="line272"></a>    val <a href="#binomial_n_n-val">binomial_n_n</a> : thm
<a name="line273"></a>    val <a href="#binomial_pos-val">binomial_pos</a> : thm
<a name="line274"></a>    val <a href="#binomial_product_identity-val">binomial_product_identity</a> : thm
<a name="line275"></a>    val <a href="#binomial_range_shift-val">binomial_range_shift</a> : thm
<a name="line276"></a>    val <a href="#binomial_range_shift_alt-val">binomial_range_shift_alt</a> : thm
<a name="line277"></a>    val <a href="#binomial_recurrence-val">binomial_recurrence</a> : thm
<a name="line278"></a>    val <a href="#binomial_right-val">binomial_right</a> : thm
<a name="line279"></a>    val <a href="#binomial_right_eqn-val">binomial_right_eqn</a> : thm
<a name="line280"></a>    val <a href="#binomial_row_max-val">binomial_row_max</a> : thm
<a name="line281"></a>    val <a href="#binomial_sum-val">binomial_sum</a> : thm
<a name="line282"></a>    val <a href="#binomial_sum_alt-val">binomial_sum_alt</a> : thm
<a name="line283"></a>    val <a href="#binomial_sym-val">binomial_sym</a> : thm
<a name="line284"></a>    val <a href="#binomial_term_merge_x-val">binomial_term_merge_x</a> : thm
<a name="line285"></a>    val <a href="#binomial_term_merge_y-val">binomial_term_merge_y</a> : thm
<a name="line286"></a>    val <a href="#binomial_thm-val">binomial_thm</a> : thm
<a name="line287"></a>    val <a href="#binomial_thm_alt-val">binomial_thm_alt</a> : thm
<a name="line288"></a>    val <a href="#binomial_thm_prime-val">binomial_thm_prime</a> : thm
<a name="line289"></a>    val <a href="#binomial_up-val">binomial_up</a> : thm
<a name="line290"></a>    val <a href="#binomial_up_eqn-val">binomial_up_eqn</a> : thm
<a name="line291"></a>    val <a href="#choose_0_n-val">choose_0_n</a> : thm
<a name="line292"></a>    val <a href="#choose_1_n-val">choose_1_n</a> : thm
<a name="line293"></a>    val <a href="#choose_alt-val">choose_alt</a> : thm
<a name="line294"></a>    val <a href="#choose_eq_0-val">choose_eq_0</a> : thm
<a name="line295"></a>    val <a href="#choose_eqn-val">choose_eqn</a> : thm
<a name="line296"></a>    val <a href="#choose_n_0-val">choose_n_0</a> : thm
<a name="line297"></a>    val <a href="#choose_n_1-val">choose_n_1</a> : thm
<a name="line298"></a>    val <a href="#choose_n_n-val">choose_n_n</a> : thm
<a name="line299"></a>    val <a href="#choose_recurrence-val">choose_recurrence</a> : thm
<a name="line300"></a>    val <a href="#choose_sum_over_all-val">choose_sum_over_all</a> : thm
<a name="line301"></a>    val <a href="#choose_sum_over_count-val">choose_sum_over_count</a> : thm
<a name="line302"></a>    val <a href="#count_power_partition-val">count_power_partition</a> : thm
<a name="line303"></a>    val <a href="#datatype_triple-val">datatype_triple</a> : thm
<a name="line304"></a>    val <a href="#divides_binomials_imp_prime-val">divides_binomials_imp_prime</a> : thm
<a name="line305"></a>    val <a href="#feq_set_equiv-val">feq_set_equiv</a> : thm
<a name="line306"></a>    val <a href="#finite_surj_inj_iff-val">finite_surj_inj_iff</a> : thm
<a name="line307"></a>    val <a href="#gcd_prime_product_property-val">gcd_prime_product_property</a> : thm
<a name="line308"></a>    val <a href="#geometric_sum_eqn-val">geometric_sum_eqn</a> : thm
<a name="line309"></a>    val <a href="#geometric_sum_eqn_alt-val">geometric_sum_eqn_alt</a> : thm
<a name="line310"></a>    val <a href="#head_turn-val">head_turn</a> : thm
<a name="line311"></a>    val <a href="#head_turn_exp-val">head_turn_exp</a> : thm
<a name="line312"></a>    val <a href="#inj_iff_preimage_card_le_1-val">inj_iff_preimage_card_le_1</a> : thm
<a name="line313"></a>    val <a href="#inj_preimage_empty_or_sing-val">inj_preimage_empty_or_sing</a> : thm
<a name="line314"></a>    val <a href="#interleave_alt-val">interleave_alt</a> : thm
<a name="line315"></a>    val <a href="#interleave_card-val">interleave_card</a> : thm
<a name="line316"></a>    val <a href="#interleave_count_inj-val">interleave_count_inj</a> : thm
<a name="line317"></a>    val <a href="#interleave_disjoint-val">interleave_disjoint</a> : thm
<a name="line318"></a>    val <a href="#interleave_distinct-val">interleave_distinct</a> : thm
<a name="line319"></a>    val <a href="#interleave_distinct_alt-val">interleave_distinct_alt</a> : thm
<a name="line320"></a>    val <a href="#interleave_element-val">interleave_element</a> : thm
<a name="line321"></a>    val <a href="#interleave_eq-val">interleave_eq</a> : thm
<a name="line322"></a>    val <a href="#interleave_finite-val">interleave_finite</a> : thm
<a name="line323"></a>    val <a href="#interleave_has_cons-val">interleave_has_cons</a> : thm
<a name="line324"></a>    val <a href="#interleave_length-val">interleave_length</a> : thm
<a name="line325"></a>    val <a href="#interleave_nil-val">interleave_nil</a> : thm
<a name="line326"></a>    val <a href="#interleave_not_empty-val">interleave_not_empty</a> : thm
<a name="line327"></a>    val <a href="#interleave_revert-val">interleave_revert</a> : thm
<a name="line328"></a>    val <a href="#interleave_revert_count-val">interleave_revert_count</a> : thm
<a name="line329"></a>    val <a href="#interleave_set-val">interleave_set</a> : thm
<a name="line330"></a>    val <a href="#interleave_set_alt-val">interleave_set_alt</a> : thm
<a name="line331"></a>    val <a href="#lcm_lower_bound-val">lcm_lower_bound</a> : thm
<a name="line332"></a>    val <a href="#lcm_lower_bound_by_big_lcm-val">lcm_lower_bound_by_big_lcm</a> : thm
<a name="line333"></a>    val <a href="#lcm_lower_bound_by_big_lcm_stirling-val">lcm_lower_bound_by_big_lcm_stirling</a> : thm
<a name="line334"></a>    val <a href="#lcm_lower_bound_by_list_lcm-val">lcm_lower_bound_by_list_lcm</a> : thm
<a name="line335"></a>    val <a href="#lcm_lower_bound_by_list_lcm_stirling-val">lcm_lower_bound_by_list_lcm_stirling</a> : thm
<a name="line336"></a>    val <a href="#lcm_prime_product_property-val">lcm_prime_product_property</a> : thm
<a name="line337"></a>    val <a href="#lcm_run_0-val">lcm_run_0</a> : thm
<a name="line338"></a>    val <a href="#lcm_run_1-val">lcm_run_1</a> : thm
<a name="line339"></a>    val <a href="#lcm_run_alt-val">lcm_run_alt</a> : thm
<a name="line340"></a>    val <a href="#lcm_run_beta_divisor-val">lcm_run_beta_divisor</a> : thm
<a name="line341"></a>    val <a href="#lcm_run_bound_recurrence-val">lcm_run_bound_recurrence</a> : thm
<a name="line342"></a>    val <a href="#lcm_run_by_FOLDL-val">lcm_run_by_FOLDL</a> : thm
<a name="line343"></a>    val <a href="#lcm_run_by_FOLDR-val">lcm_run_by_FOLDR</a> : thm
<a name="line344"></a>    val <a href="#lcm_run_by_beta_horizontal-val">lcm_run_by_beta_horizontal</a> : thm
<a name="line345"></a>    val <a href="#lcm_run_divides_property-val">lcm_run_divides_property</a> : thm
<a name="line346"></a>    val <a href="#lcm_run_divides_property_alt-val">lcm_run_divides_property_alt</a> : thm
<a name="line347"></a>    val <a href="#lcm_run_divisors-val">lcm_run_divisors</a> : thm
<a name="line348"></a>    val <a href="#lcm_run_even_lower-val">lcm_run_even_lower</a> : thm
<a name="line349"></a>    val <a href="#lcm_run_even_lower_alt-val">lcm_run_even_lower_alt</a> : thm
<a name="line350"></a>    val <a href="#lcm_run_leibniz_divisor-val">lcm_run_leibniz_divisor</a> : thm
<a name="line351"></a>    val <a href="#lcm_run_lower-val">lcm_run_lower</a> : thm
<a name="line352"></a>    val <a href="#lcm_run_lower_better-val">lcm_run_lower_better</a> : thm
<a name="line353"></a>    val <a href="#lcm_run_lower_better_iff-val">lcm_run_lower_better_iff</a> : thm
<a name="line354"></a>    val <a href="#lcm_run_lower_even-val">lcm_run_lower_even</a> : thm
<a name="line355"></a>    val <a href="#lcm_run_lower_even_iff-val">lcm_run_lower_even_iff</a> : thm
<a name="line356"></a>    val <a href="#lcm_run_lower_good-val">lcm_run_lower_good</a> : thm
<a name="line357"></a>    val <a href="#lcm_run_lower_odd-val">lcm_run_lower_odd</a> : thm
<a name="line358"></a>    val <a href="#lcm_run_lower_odd_iff-val">lcm_run_lower_odd_iff</a> : thm
<a name="line359"></a>    val <a href="#lcm_run_lower_simple-val">lcm_run_lower_simple</a> : thm
<a name="line360"></a>    val <a href="#lcm_run_monotone-val">lcm_run_monotone</a> : thm
<a name="line361"></a>    val <a href="#lcm_run_odd_factor-val">lcm_run_odd_factor</a> : thm
<a name="line362"></a>    val <a href="#lcm_run_odd_lower-val">lcm_run_odd_lower</a> : thm
<a name="line363"></a>    val <a href="#lcm_run_odd_lower_alt-val">lcm_run_odd_lower_alt</a> : thm
<a name="line364"></a>    val <a href="#lcm_run_pos-val">lcm_run_pos</a> : thm
<a name="line365"></a>    val <a href="#lcm_run_small-val">lcm_run_small</a> : thm
<a name="line366"></a>    val <a href="#lcm_run_suc-val">lcm_run_suc</a> : thm
<a name="line367"></a>    val <a href="#lcm_run_upper_bound-val">lcm_run_upper_bound</a> : thm
<a name="line368"></a>    val <a href="#lcm_upto_0-val">lcm_upto_0</a> : thm
<a name="line369"></a>    val <a href="#lcm_upto_1-val">lcm_upto_1</a> : thm
<a name="line370"></a>    val <a href="#lcm_upto_SUC-val">lcm_upto_SUC</a> : thm
<a name="line371"></a>    val <a href="#lcm_upto_alt-val">lcm_upto_alt</a> : thm
<a name="line372"></a>    val <a href="#lcm_upto_compute-val">lcm_upto_compute</a> : thm
<a name="line373"></a>    val <a href="#lcm_upto_divisors-val">lcm_upto_divisors</a> : thm
<a name="line374"></a>    val <a href="#lcm_upto_eq_list_lcm-val">lcm_upto_eq_list_lcm</a> : thm
<a name="line375"></a>    val <a href="#lcm_upto_leibniz_divisor-val">lcm_upto_leibniz_divisor</a> : thm
<a name="line376"></a>    val <a href="#lcm_upto_lower-val">lcm_upto_lower</a> : thm
<a name="line377"></a>    val <a href="#lcm_upto_lower_better-val">lcm_upto_lower_better</a> : thm
<a name="line378"></a>    val <a href="#lcm_upto_lower_even-val">lcm_upto_lower_even</a> : thm
<a name="line379"></a>    val <a href="#lcm_upto_lower_odd-val">lcm_upto_lower_odd</a> : thm
<a name="line380"></a>    val <a href="#lcm_upto_monotone-val">lcm_upto_monotone</a> : thm
<a name="line381"></a>    val <a href="#lcm_upto_pos-val">lcm_upto_pos</a> : thm
<a name="line382"></a>    val <a href="#lcm_upto_small-val">lcm_upto_small</a> : thm
<a name="line383"></a>    val <a href="#leibniz_0_n-val">leibniz_0_n</a> : thm
<a name="line384"></a>    val <a href="#leibniz_alt-val">leibniz_alt</a> : thm
<a name="line385"></a>    val <a href="#leibniz_binomial_identity-val">leibniz_binomial_identity</a> : thm
<a name="line386"></a>    val <a href="#leibniz_col_arm_0-val">leibniz_col_arm_0</a> : thm
<a name="line387"></a>    val <a href="#leibniz_col_arm_1-val">leibniz_col_arm_1</a> : thm
<a name="line388"></a>    val <a href="#leibniz_col_arm_cons-val">leibniz_col_arm_cons</a> : thm
<a name="line389"></a>    val <a href="#leibniz_col_arm_el-val">leibniz_col_arm_el</a> : thm
<a name="line390"></a>    val <a href="#leibniz_col_arm_len-val">leibniz_col_arm_len</a> : thm
<a name="line391"></a>    val <a href="#leibniz_col_arm_n_0-val">leibniz_col_arm_n_0</a> : thm
<a name="line392"></a>    val <a href="#leibniz_col_arm_wriggle_row_arm-val">leibniz_col_arm_wriggle_row_arm</a> : thm
<a name="line393"></a>    val <a href="#leibniz_col_def-val">leibniz_col_def</a> : thm
<a name="line394"></a>    val <a href="#leibniz_col_eq_natural-val">leibniz_col_eq_natural</a> : thm
<a name="line395"></a>    val <a href="#leibniz_def_alt-val">leibniz_def_alt</a> : thm
<a name="line396"></a>    val <a href="#leibniz_divides_leibniz_factor-val">leibniz_divides_leibniz_factor</a> : thm
<a name="line397"></a>    val <a href="#leibniz_eq_0-val">leibniz_eq_0</a> : thm
<a name="line398"></a>    val <a href="#leibniz_eqn-val">leibniz_eqn</a> : thm
<a name="line399"></a>    val <a href="#leibniz_formula-val">leibniz_formula</a> : thm
<a name="line400"></a>    val <a href="#leibniz_horizontal_0-val">leibniz_horizontal_0</a> : thm
<a name="line401"></a>    val <a href="#leibniz_horizontal_alt-val">leibniz_horizontal_alt</a> : thm
<a name="line402"></a>    val <a href="#leibniz_horizontal_average-val">leibniz_horizontal_average</a> : thm
<a name="line403"></a>    val <a href="#leibniz_horizontal_average_eqn-val">leibniz_horizontal_average_eqn</a> : thm
<a name="line404"></a>    val <a href="#leibniz_horizontal_divisor-val">leibniz_horizontal_divisor</a> : thm
<a name="line405"></a>    val <a href="#leibniz_horizontal_el-val">leibniz_horizontal_el</a> : thm
<a name="line406"></a>    val <a href="#leibniz_horizontal_element-val">leibniz_horizontal_element</a> : thm
<a name="line407"></a>    val <a href="#leibniz_horizontal_head-val">leibniz_horizontal_head</a> : thm
<a name="line408"></a>    val <a href="#leibniz_horizontal_lcm_alt-val">leibniz_horizontal_lcm_alt</a> : thm
<a name="line409"></a>    val <a href="#leibniz_horizontal_lcm_lower-val">leibniz_horizontal_lcm_lower</a> : thm
<a name="line410"></a>    val <a href="#leibniz_horizontal_len-val">leibniz_horizontal_len</a> : thm
<a name="line411"></a>    val <a href="#leibniz_horizontal_mem-val">leibniz_horizontal_mem</a> : thm
<a name="line412"></a>    val <a href="#leibniz_horizontal_mem_iff-val">leibniz_horizontal_mem_iff</a> : thm
<a name="line413"></a>    val <a href="#leibniz_horizontal_member-val">leibniz_horizontal_member</a> : thm
<a name="line414"></a>    val <a href="#leibniz_horizontal_member_divides-val">leibniz_horizontal_member_divides</a> : thm
<a name="line415"></a>    val <a href="#leibniz_horizontal_pos-val">leibniz_horizontal_pos</a> : thm
<a name="line416"></a>    val <a href="#leibniz_horizontal_pos_alt-val">leibniz_horizontal_pos_alt</a> : thm
<a name="line417"></a>    val <a href="#leibniz_horizontal_sum-val">leibniz_horizontal_sum</a> : thm
<a name="line418"></a>    val <a href="#leibniz_horizontal_sum_eqn-val">leibniz_horizontal_sum_eqn</a> : thm
<a name="line419"></a>    val <a href="#leibniz_horizontal_wriggle-val">leibniz_horizontal_wriggle</a> : thm
<a name="line420"></a>    val <a href="#leibniz_horizontal_wriggle_step-val">leibniz_horizontal_wriggle_step</a> : thm
<a name="line421"></a>    val <a href="#leibniz_horizontal_zigzag-val">leibniz_horizontal_zigzag</a> : thm
<a name="line422"></a>    val <a href="#leibniz_lcm_exchange-val">leibniz_lcm_exchange</a> : thm
<a name="line423"></a>    val <a href="#leibniz_lcm_invariance-val">leibniz_lcm_invariance</a> : thm
<a name="line424"></a>    val <a href="#leibniz_lcm_property-val">leibniz_lcm_property</a> : thm
<a name="line425"></a>    val <a href="#leibniz_less_0-val">leibniz_less_0</a> : thm
<a name="line426"></a>    val <a href="#leibniz_middle_lower-val">leibniz_middle_lower</a> : thm
<a name="line427"></a>    val <a href="#leibniz_monotone-val">leibniz_monotone</a> : thm
<a name="line428"></a>    val <a href="#leibniz_n_0-val">leibniz_n_0</a> : thm
<a name="line429"></a>    val <a href="#leibniz_n_k-val">leibniz_n_k</a> : thm
<a name="line430"></a>    val <a href="#leibniz_n_n-val">leibniz_n_n</a> : thm
<a name="line431"></a>    val <a href="#leibniz_pos-val">leibniz_pos</a> : thm
<a name="line432"></a>    val <a href="#leibniz_property-val">leibniz_property</a> : thm
<a name="line433"></a>    val <a href="#leibniz_recurrence-val">leibniz_recurrence</a> : thm
<a name="line434"></a>    val <a href="#leibniz_right-val">leibniz_right</a> : thm
<a name="line435"></a>    val <a href="#leibniz_right_alt-val">leibniz_right_alt</a> : thm
<a name="line436"></a>    val <a href="#leibniz_right_entry-val">leibniz_right_entry</a> : thm
<a name="line437"></a>    val <a href="#leibniz_right_eqn-val">leibniz_right_eqn</a> : thm
<a name="line438"></a>    val <a href="#leibniz_row_def-val">leibniz_row_def</a> : thm
<a name="line439"></a>    val <a href="#leibniz_seg_arm_0-val">leibniz_seg_arm_0</a> : thm
<a name="line440"></a>    val <a href="#leibniz_seg_arm_1-val">leibniz_seg_arm_1</a> : thm
<a name="line441"></a>    val <a href="#leibniz_seg_arm_el-val">leibniz_seg_arm_el</a> : thm
<a name="line442"></a>    val <a href="#leibniz_seg_arm_head-val">leibniz_seg_arm_head</a> : thm
<a name="line443"></a>    val <a href="#leibniz_seg_arm_len-val">leibniz_seg_arm_len</a> : thm
<a name="line444"></a>    val <a href="#leibniz_seg_arm_n_0-val">leibniz_seg_arm_n_0</a> : thm
<a name="line445"></a>    val <a href="#leibniz_seg_arm_wriggle_row_arm-val">leibniz_seg_arm_wriggle_row_arm</a> : thm
<a name="line446"></a>    val <a href="#leibniz_seg_arm_wriggle_step-val">leibniz_seg_arm_wriggle_step</a> : thm
<a name="line447"></a>    val <a href="#leibniz_seg_arm_zigzag_step-val">leibniz_seg_arm_zigzag_step</a> : thm
<a name="line448"></a>    val <a href="#leibniz_seg_def-val">leibniz_seg_def</a> : thm
<a name="line449"></a>    val <a href="#leibniz_sym-val">leibniz_sym</a> : thm
<a name="line450"></a>    val <a href="#leibniz_triplet_0-val">leibniz_triplet_0</a> : thm
<a name="line451"></a>    val <a href="#leibniz_triplet_lcm-val">leibniz_triplet_lcm</a> : thm
<a name="line452"></a>    val <a href="#leibniz_triplet_member-val">leibniz_triplet_member</a> : thm
<a name="line453"></a>    val <a href="#leibniz_triplet_property-val">leibniz_triplet_property</a> : thm
<a name="line454"></a>    val <a href="#leibniz_up-val">leibniz_up</a> : thm
<a name="line455"></a>    val <a href="#leibniz_up_0-val">leibniz_up_0</a> : thm
<a name="line456"></a>    val <a href="#leibniz_up_alt-val">leibniz_up_alt</a> : thm
<a name="line457"></a>    val <a href="#leibniz_up_cons-val">leibniz_up_cons</a> : thm
<a name="line458"></a>    val <a href="#leibniz_up_entry-val">leibniz_up_entry</a> : thm
<a name="line459"></a>    val <a href="#leibniz_up_eqn-val">leibniz_up_eqn</a> : thm
<a name="line460"></a>    val <a href="#leibniz_up_lcm_eq_horizontal_lcm-val">leibniz_up_lcm_eq_horizontal_lcm</a> : thm
<a name="line461"></a>    val <a href="#leibniz_up_len-val">leibniz_up_len</a> : thm
<a name="line462"></a>    val <a href="#leibniz_up_mem-val">leibniz_up_mem</a> : thm
<a name="line463"></a>    val <a href="#leibniz_up_pos-val">leibniz_up_pos</a> : thm
<a name="line464"></a>    val <a href="#leibniz_up_wriggle_horizontal-val">leibniz_up_wriggle_horizontal</a> : thm
<a name="line465"></a>    val <a href="#leibniz_up_wriggle_horizontal_alt-val">leibniz_up_wriggle_horizontal_alt</a> : thm
<a name="line466"></a>    val <a href="#leibniz_vertical_0-val">leibniz_vertical_0</a> : thm
<a name="line467"></a>    val <a href="#leibniz_vertical_alt-val">leibniz_vertical_alt</a> : thm
<a name="line468"></a>    val <a href="#leibniz_vertical_divisor-val">leibniz_vertical_divisor</a> : thm
<a name="line469"></a>    val <a href="#leibniz_vertical_lcm_lower-val">leibniz_vertical_lcm_lower</a> : thm
<a name="line470"></a>    val <a href="#leibniz_vertical_len-val">leibniz_vertical_len</a> : thm
<a name="line471"></a>    val <a href="#leibniz_vertical_mem-val">leibniz_vertical_mem</a> : thm
<a name="line472"></a>    val <a href="#leibniz_vertical_not_nil-val">leibniz_vertical_not_nil</a> : thm
<a name="line473"></a>    val <a href="#leibniz_vertical_pos-val">leibniz_vertical_pos</a> : thm
<a name="line474"></a>    val <a href="#leibniz_vertical_pos_alt-val">leibniz_vertical_pos_alt</a> : thm
<a name="line475"></a>    val <a href="#leibniz_vertical_snoc-val">leibniz_vertical_snoc</a> : thm
<a name="line476"></a>    val <a href="#leibniz_wriggle_refl-val">leibniz_wriggle_refl</a> : thm
<a name="line477"></a>    val <a href="#leibniz_wriggle_tail-val">leibniz_wriggle_tail</a> : thm
<a name="line478"></a>    val <a href="#leibniz_wriggle_trans-val">leibniz_wriggle_trans</a> : thm
<a name="line479"></a>    val <a href="#leibniz_zigzag_tail-val">leibniz_zigzag_tail</a> : thm
<a name="line480"></a>    val <a href="#leibniz_zigzag_wriggle-val">leibniz_zigzag_wriggle</a> : thm
<a name="line481"></a>    val <a href="#listRangeINC_MONO_INC-val">listRangeINC_MONO_INC</a> : thm
<a name="line482"></a>    val <a href="#listRangeINC_PROD-val">listRangeINC_PROD</a> : thm
<a name="line483"></a>    val <a href="#listRangeINC_PROD_pos-val">listRangeINC_PROD_pos</a> : thm
<a name="line484"></a>    val <a href="#listRangeLHI_MONO_INC-val">listRangeLHI_MONO_INC</a> : thm
<a name="line485"></a>    val <a href="#listRangeLHI_PROD-val">listRangeLHI_PROD</a> : thm
<a name="line486"></a>    val <a href="#listRangeLHI_PROD_pos-val">listRangeLHI_PROD_pos</a> : thm
<a name="line487"></a>    val <a href="#list_count_0_n-val">list_count_0_n</a> : thm
<a name="line488"></a>    val <a href="#list_count_alt-val">list_count_alt</a> : thm
<a name="line489"></a>    val <a href="#list_count_by_image-val">list_count_by_image</a> : thm
<a name="line490"></a>    val <a href="#list_count_element-val">list_count_element</a> : thm
<a name="line491"></a>    val <a href="#list_count_element_alt-val">list_count_element_alt</a> : thm
<a name="line492"></a>    val <a href="#list_count_element_perm_set_not_empty-val">list_count_element_perm_set_not_empty</a> : thm
<a name="line493"></a>    val <a href="#list_count_element_set_card-val">list_count_element_set_card</a> : thm
<a name="line494"></a>    val <a href="#list_count_eq_empty-val">list_count_eq_empty</a> : thm
<a name="line495"></a>    val <a href="#list_count_eqn-val">list_count_eqn</a> : thm
<a name="line496"></a>    val <a href="#list_count_finite-val">list_count_finite</a> : thm
<a name="line497"></a>    val <a href="#list_count_n_0-val">list_count_n_0</a> : thm
<a name="line498"></a>    val <a href="#list_count_n_n-val">list_count_n_n</a> : thm
<a name="line499"></a>    val <a href="#list_count_set_eq_class-val">list_count_set_eq_class</a> : thm
<a name="line500"></a>    val <a href="#list_count_set_eq_class_card-val">list_count_set_eq_class_card</a> : thm
<a name="line501"></a>    val <a href="#list_count_set_map_bij-val">list_count_set_map_bij</a> : thm
<a name="line502"></a>    val <a href="#list_count_set_map_element-val">list_count_set_map_element</a> : thm
<a name="line503"></a>    val <a href="#list_count_set_map_inj-val">list_count_set_map_inj</a> : thm
<a name="line504"></a>    val <a href="#list_count_set_map_surj-val">list_count_set_map_surj</a> : thm
<a name="line505"></a>    val <a href="#list_count_set_partititon_element_card-val">list_count_set_partititon_element_card</a> : thm
<a name="line506"></a>    val <a href="#list_count_subset-val">list_count_subset</a> : thm
<a name="line507"></a>    val <a href="#list_lcm_absorption-val">list_lcm_absorption</a> : thm
<a name="line508"></a>    val <a href="#list_lcm_append-val">list_lcm_append</a> : thm
<a name="line509"></a>    val <a href="#list_lcm_append_3-val">list_lcm_append_3</a> : thm
<a name="line510"></a>    val <a href="#list_lcm_by_FOLDL-val">list_lcm_by_FOLDL</a> : thm
<a name="line511"></a>    val <a href="#list_lcm_by_FOLDR-val">list_lcm_by_FOLDR</a> : thm
<a name="line512"></a>    val <a href="#list_lcm_cons-val">list_lcm_cons</a> : thm
<a name="line513"></a>    val <a href="#list_lcm_divisor_lcm_pair-val">list_lcm_divisor_lcm_pair</a> : thm
<a name="line514"></a>    val <a href="#list_lcm_eq_if_set_eq-val">list_lcm_eq_if_set_eq</a> : thm
<a name="line515"></a>    val <a href="#list_lcm_ge_max-val">list_lcm_ge_max</a> : thm
<a name="line516"></a>    val <a href="#list_lcm_is_common_multiple-val">list_lcm_is_common_multiple</a> : thm
<a name="line517"></a>    val <a href="#list_lcm_is_least_common_multiple-val">list_lcm_is_least_common_multiple</a> : thm
<a name="line518"></a>    val <a href="#list_lcm_lower_bound-val">list_lcm_lower_bound</a> : thm
<a name="line519"></a>    val <a href="#list_lcm_lower_bound_alt-val">list_lcm_lower_bound_alt</a> : thm
<a name="line520"></a>    val <a href="#list_lcm_lower_by_lcm_pair-val">list_lcm_lower_by_lcm_pair</a> : thm
<a name="line521"></a>    val <a href="#list_lcm_map_times-val">list_lcm_map_times</a> : thm
<a name="line522"></a>    val <a href="#list_lcm_nil-val">list_lcm_nil</a> : thm
<a name="line523"></a>    val <a href="#list_lcm_nonempty_lower-val">list_lcm_nonempty_lower</a> : thm
<a name="line524"></a>    val <a href="#list_lcm_nonempty_lower_alt-val">list_lcm_nonempty_lower_alt</a> : thm
<a name="line525"></a>    val <a href="#list_lcm_nub-val">list_lcm_nub</a> : thm
<a name="line526"></a>    val <a href="#list_lcm_nub_eq_if_set_eq-val">list_lcm_nub_eq_if_set_eq</a> : thm
<a name="line527"></a>    val <a href="#list_lcm_pos-val">list_lcm_pos</a> : thm
<a name="line528"></a>    val <a href="#list_lcm_pos_alt-val">list_lcm_pos_alt</a> : thm
<a name="line529"></a>    val <a href="#list_lcm_prime_factor-val">list_lcm_prime_factor</a> : thm
<a name="line530"></a>    val <a href="#list_lcm_prime_factor_member-val">list_lcm_prime_factor_member</a> : thm
<a name="line531"></a>    val <a href="#list_lcm_reverse-val">list_lcm_reverse</a> : thm
<a name="line532"></a>    val <a href="#list_lcm_sing-val">list_lcm_sing</a> : thm
<a name="line533"></a>    val <a href="#list_lcm_snoc-val">list_lcm_snoc</a> : thm
<a name="line534"></a>    val <a href="#list_lcm_suc-val">list_lcm_suc</a> : thm
<a name="line535"></a>    val <a href="#list_lcm_upper_by_common_multiple-val">list_lcm_upper_by_common_multiple</a> : thm
<a name="line536"></a>    val <a href="#list_lcm_wriggle-val">list_lcm_wriggle</a> : thm
<a name="line537"></a>    val <a href="#list_lcm_zigzag-val">list_lcm_zigzag</a> : thm
<a name="line538"></a>    val <a href="#list_length_eq_sum-val">list_length_eq_sum</a> : thm
<a name="line539"></a>    val <a href="#list_length_le_sum-val">list_length_le_sum</a> : thm
<a name="line540"></a>    val <a href="#list_product_prime_factor-val">list_product_prime_factor</a> : thm
<a name="line541"></a>    val <a href="#monocoloured_0-val">monocoloured_0</a> : thm
<a name="line542"></a>    val <a href="#monocoloured_0_card-val">monocoloured_0_card</a> : thm
<a name="line543"></a>    val <a href="#monocoloured_1-val">monocoloured_1</a> : thm
<a name="line544"></a>    val <a href="#monocoloured_card-val">monocoloured_card</a> : thm
<a name="line545"></a>    val <a href="#monocoloured_card_eqn-val">monocoloured_card_eqn</a> : thm
<a name="line546"></a>    val <a href="#monocoloured_element-val">monocoloured_element</a> : thm
<a name="line547"></a>    val <a href="#monocoloured_empty-val">monocoloured_empty</a> : thm
<a name="line548"></a>    val <a href="#monocoloured_eqn-val">monocoloured_eqn</a> : thm
<a name="line549"></a>    val <a href="#monocoloured_finite-val">monocoloured_finite</a> : thm
<a name="line550"></a>    val <a href="#monocoloured_mono-val">monocoloured_mono</a> : thm
<a name="line551"></a>    val <a href="#monocoloured_necklace-val">monocoloured_necklace</a> : thm
<a name="line552"></a>    val <a href="#monocoloured_subset-val">monocoloured_subset</a> : thm
<a name="line553"></a>    val <a href="#monocoloured_suc-val">monocoloured_suc</a> : thm
<a name="line554"></a>    val <a href="#multi_mono_disjoint-val">multi_mono_disjoint</a> : thm
<a name="line555"></a>    val <a href="#multi_mono_exhaust-val">multi_mono_exhaust</a> : thm
<a name="line556"></a>    val <a href="#multicoloured_0-val">multicoloured_0</a> : thm
<a name="line557"></a>    val <a href="#multicoloured_1-val">multicoloured_1</a> : thm
<a name="line558"></a>    val <a href="#multicoloured_card-val">multicoloured_card</a> : thm
<a name="line559"></a>    val <a href="#multicoloured_card_eqn-val">multicoloured_card_eqn</a> : thm
<a name="line560"></a>    val <a href="#multicoloured_element-val">multicoloured_element</a> : thm
<a name="line561"></a>    val <a href="#multicoloured_empty-val">multicoloured_empty</a> : thm
<a name="line562"></a>    val <a href="#multicoloured_finite-val">multicoloured_finite</a> : thm
<a name="line563"></a>    val <a href="#multicoloured_n_0-val">multicoloured_n_0</a> : thm
<a name="line564"></a>    val <a href="#multicoloured_n_1-val">multicoloured_n_1</a> : thm
<a name="line565"></a>    val <a href="#multicoloured_necklace-val">multicoloured_necklace</a> : thm
<a name="line566"></a>    val <a href="#multicoloured_nonempty-val">multicoloured_nonempty</a> : thm
<a name="line567"></a>    val <a href="#multicoloured_not_monocoloured-val">multicoloured_not_monocoloured</a> : thm
<a name="line568"></a>    val <a href="#multicoloured_not_monocoloured_iff-val">multicoloured_not_monocoloured_iff</a> : thm
<a name="line569"></a>    val <a href="#multicoloured_or_monocoloured-val">multicoloured_or_monocoloured</a> : thm
<a name="line570"></a>    val <a href="#multicoloured_subset-val">multicoloured_subset</a> : thm
<a name="line571"></a>    val <a href="#necklace_0-val">necklace_0</a> : thm
<a name="line572"></a>    val <a href="#necklace_1-val">necklace_1</a> : thm
<a name="line573"></a>    val <a href="#necklace_1_monocoloured-val">necklace_1_monocoloured</a> : thm
<a name="line574"></a>    val <a href="#necklace_card-val">necklace_card</a> : thm
<a name="line575"></a>    val <a href="#necklace_colors-val">necklace_colors</a> : thm
<a name="line576"></a>    val <a href="#necklace_element-val">necklace_element</a> : thm
<a name="line577"></a>    val <a href="#necklace_empty-val">necklace_empty</a> : thm
<a name="line578"></a>    val <a href="#necklace_eqn-val">necklace_eqn</a> : thm
<a name="line579"></a>    val <a href="#necklace_finite-val">necklace_finite</a> : thm
<a name="line580"></a>    val <a href="#necklace_length-val">necklace_length</a> : thm
<a name="line581"></a>    val <a href="#necklace_not_nil-val">necklace_not_nil</a> : thm
<a name="line582"></a>    val <a href="#necklace_property-val">necklace_property</a> : thm
<a name="line583"></a>    val <a href="#necklace_suc-val">necklace_suc</a> : thm
<a name="line584"></a>    val <a href="#nub_all_distinct-val">nub_all_distinct</a> : thm
<a name="line585"></a>    val <a href="#nub_cons-val">nub_cons</a> : thm
<a name="line586"></a>    val <a href="#nub_nil-val">nub_nil</a> : thm
<a name="line587"></a>    val <a href="#nub_sing-val">nub_sing</a> : thm
<a name="line588"></a>    val <a href="#over_bij-val">over_bij</a> : thm
<a name="line589"></a>    val <a href="#over_inj-val">over_inj</a> : thm
<a name="line590"></a>    val <a href="#over_surj-val">over_surj</a> : thm
<a name="line591"></a>    val <a href="#pairwise_coprime_prod_set_divides-val">pairwise_coprime_prod_set_divides</a> : thm
<a name="line592"></a>    val <a href="#pairwise_coprime_prod_set_eq_set_lcm-val">pairwise_coprime_prod_set_eq_set_lcm</a> : thm
<a name="line593"></a>    val <a href="#perm_0-val">perm_0</a> : thm
<a name="line594"></a>    val <a href="#perm_1-val">perm_1</a> : thm
<a name="line595"></a>    val <a href="#perm_alt-val">perm_alt</a> : thm
<a name="line596"></a>    val <a href="#perm_count_0-val">perm_count_0</a> : thm
<a name="line597"></a>    val <a href="#perm_count_1-val">perm_count_1</a> : thm
<a name="line598"></a>    val <a href="#perm_count_element-val">perm_count_element</a> : thm
<a name="line599"></a>    val <a href="#perm_count_element_length-val">perm_count_element_length</a> : thm
<a name="line600"></a>    val <a href="#perm_count_element_no_self-val">perm_count_element_no_self</a> : thm
<a name="line601"></a>    val <a href="#perm_count_eqn-val">perm_count_eqn</a> : thm
<a name="line602"></a>    val <a href="#perm_count_finite-val">perm_count_finite</a> : thm
<a name="line603"></a>    val <a href="#perm_count_interleave_card-val">perm_count_interleave_card</a> : thm
<a name="line604"></a>    val <a href="#perm_count_interleave_disjoint-val">perm_count_interleave_disjoint</a> : thm
<a name="line605"></a>    val <a href="#perm_count_interleave_finite-val">perm_count_interleave_finite</a> : thm
<a name="line606"></a>    val <a href="#perm_count_interleave_inj-val">perm_count_interleave_inj</a> : thm
<a name="line607"></a>    val <a href="#perm_count_subset-val">perm_count_subset</a> : thm
<a name="line608"></a>    val <a href="#perm_count_suc-val">perm_count_suc</a> : thm
<a name="line609"></a>    val <a href="#perm_count_suc_alt-val">perm_count_suc_alt</a> : thm
<a name="line610"></a>    val <a href="#perm_eq_fact-val">perm_eq_fact</a> : thm
<a name="line611"></a>    val <a href="#perm_set_bij_eq_perm_count-val">perm_set_bij_eq_perm_count</a> : thm
<a name="line612"></a>    val <a href="#perm_set_card-val">perm_set_card</a> : thm
<a name="line613"></a>    val <a href="#perm_set_card_alt-val">perm_set_card_alt</a> : thm
<a name="line614"></a>    val <a href="#perm_set_element-val">perm_set_element</a> : thm
<a name="line615"></a>    val <a href="#perm_set_empty-val">perm_set_empty</a> : thm
<a name="line616"></a>    val <a href="#perm_set_eq_empty_sing-val">perm_set_eq_empty_sing</a> : thm
<a name="line617"></a>    val <a href="#perm_set_finite-val">perm_set_finite</a> : thm
<a name="line618"></a>    val <a href="#perm_set_has_self_list-val">perm_set_has_self_list</a> : thm
<a name="line619"></a>    val <a href="#perm_set_list_not_empty-val">perm_set_list_not_empty</a> : thm
<a name="line620"></a>    val <a href="#perm_set_map_bij-val">perm_set_map_bij</a> : thm
<a name="line621"></a>    val <a href="#perm_set_map_element-val">perm_set_map_element</a> : thm
<a name="line622"></a>    val <a href="#perm_set_map_inj-val">perm_set_map_inj</a> : thm
<a name="line623"></a>    val <a href="#perm_set_map_surj-val">perm_set_map_surj</a> : thm
<a name="line624"></a>    val <a href="#perm_set_not_empty-val">perm_set_not_empty</a> : thm
<a name="line625"></a>    val <a href="#perm_set_perm_count-val">perm_set_perm_count</a> : thm
<a name="line626"></a>    val <a href="#perm_set_sing-val">perm_set_sing</a> : thm
<a name="line627"></a>    val <a href="#perm_suc-val">perm_suc</a> : thm
<a name="line628"></a>    val <a href="#perm_suc_alt-val">perm_suc_alt</a> : thm
<a name="line629"></a>    val <a href="#power_predecessor_eqn-val">power_predecessor_eqn</a> : thm
<a name="line630"></a>    val <a href="#prime_divides_binomials-val">prime_divides_binomials</a> : thm
<a name="line631"></a>    val <a href="#prime_divides_binomials_alt-val">prime_divides_binomials_alt</a> : thm
<a name="line632"></a>    val <a href="#prime_divisor_property-val">prime_divisor_property</a> : thm
<a name="line633"></a>    val <a href="#prime_iff_divides_binomials-val">prime_iff_divides_binomials</a> : thm
<a name="line634"></a>    val <a href="#prime_iff_divides_binomials_alt-val">prime_iff_divides_binomials_alt</a> : thm
<a name="line635"></a>    val <a href="#prod_1_to_n_eq_fact_n-val">prod_1_to_n_eq_fact_n</a> : thm
<a name="line636"></a>    val <a href="#rotate_0-val">rotate_0</a> : thm
<a name="line637"></a>    val <a href="#rotate_add-val">rotate_add</a> : thm
<a name="line638"></a>    val <a href="#rotate_full-val">rotate_full</a> : thm
<a name="line639"></a>    val <a href="#rotate_lcancel-val">rotate_lcancel</a> : thm
<a name="line640"></a>    val <a href="#rotate_nil-val">rotate_nil</a> : thm
<a name="line641"></a>    val <a href="#rotate_rcancel-val">rotate_rcancel</a> : thm
<a name="line642"></a>    val <a href="#rotate_same_length-val">rotate_same_length</a> : thm
<a name="line643"></a>    val <a href="#rotate_same_set-val">rotate_same_set</a> : thm
<a name="line644"></a>    val <a href="#rotate_shift_element-val">rotate_shift_element</a> : thm
<a name="line645"></a>    val <a href="#rotate_suc-val">rotate_suc</a> : thm
<a name="line646"></a>    val <a href="#set_lcm_empty-val">set_lcm_empty</a> : thm
<a name="line647"></a>    val <a href="#set_lcm_eq_big_lcm-val">set_lcm_eq_big_lcm</a> : thm
<a name="line648"></a>    val <a href="#set_lcm_eq_list_lcm-val">set_lcm_eq_list_lcm</a> : thm
<a name="line649"></a>    val <a href="#set_lcm_insert-val">set_lcm_insert</a> : thm
<a name="line650"></a>    val <a href="#set_lcm_is_common_multiple-val">set_lcm_is_common_multiple</a> : thm
<a name="line651"></a>    val <a href="#set_lcm_is_least_common_multiple-val">set_lcm_is_least_common_multiple</a> : thm
<a name="line652"></a>    val <a href="#set_lcm_nonempty-val">set_lcm_nonempty</a> : thm
<a name="line653"></a>    val <a href="#set_lcm_sing-val">set_lcm_sing</a> : thm
<a name="line654"></a>    val <a href="#sub_count_0_n-val">sub_count_0_n</a> : thm
<a name="line655"></a>    val <a href="#sub_count_alt-val">sub_count_alt</a> : thm
<a name="line656"></a>    val <a href="#sub_count_count_inj-val">sub_count_count_inj</a> : thm
<a name="line657"></a>    val <a href="#sub_count_disjoint-val">sub_count_disjoint</a> : thm
<a name="line658"></a>    val <a href="#sub_count_element-val">sub_count_element</a> : thm
<a name="line659"></a>    val <a href="#sub_count_element_finite-val">sub_count_element_finite</a> : thm
<a name="line660"></a>    val <a href="#sub_count_element_no_self-val">sub_count_element_no_self</a> : thm
<a name="line661"></a>    val <a href="#sub_count_eq_empty-val">sub_count_eq_empty</a> : thm
<a name="line662"></a>    val <a href="#sub_count_eqn-val">sub_count_eqn</a> : thm
<a name="line663"></a>    val <a href="#sub_count_equiv_class-val">sub_count_equiv_class</a> : thm
<a name="line664"></a>    val <a href="#sub_count_finite-val">sub_count_finite</a> : thm
<a name="line665"></a>    val <a href="#sub_count_insert-val">sub_count_insert</a> : thm
<a name="line666"></a>    val <a href="#sub_count_insert_card-val">sub_count_insert_card</a> : thm
<a name="line667"></a>    val <a href="#sub_count_n_0-val">sub_count_n_0</a> : thm
<a name="line668"></a>    val <a href="#sub_count_n_1-val">sub_count_n_1</a> : thm
<a name="line669"></a>    val <a href="#sub_count_n_n-val">sub_count_n_n</a> : thm
<a name="line670"></a>    val <a href="#sub_count_subset-val">sub_count_subset</a> : thm
<a name="line671"></a>    val <a href="#sub_count_union-val">sub_count_union</a> : thm
<a name="line672"></a>    val <a href="#sub_sets_element-val">sub_sets_element</a> : thm
<a name="line673"></a>    val <a href="#sub_sets_equiv_class-val">sub_sets_equiv_class</a> : thm
<a name="line674"></a>    val <a href="#sub_sets_sub_count-val">sub_sets_sub_count</a> : thm
<a name="line675"></a>    val <a href="#sum_1_to_n_double-val">sum_1_to_n_double</a> : thm
<a name="line676"></a>    val <a href="#sum_1_to_n_eq_tri_n-val">sum_1_to_n_eq_tri_n</a> : thm
<a name="line677"></a>    val <a href="#sum_1_to_n_eqn-val">sum_1_to_n_eqn</a> : thm
<a name="line678"></a>    val <a href="#surj_iff_preimage_card_not_0-val">surj_iff_preimage_card_not_0</a> : thm
<a name="line679"></a>    val <a href="#surj_preimage_not_empty-val">surj_preimage_not_empty</a> : thm
<a name="line680"></a>    val <a href="#tail_turn-val">tail_turn</a> : thm
<a name="line681"></a>    val <a href="#triple_11-val">triple_11</a> : thm
<a name="line682"></a>    val <a href="#triple_Axiom-val">triple_Axiom</a> : thm
<a name="line683"></a>    val <a href="#triple_accessors-val">triple_accessors</a> : thm
<a name="line684"></a>    val <a href="#triple_accfupds-val">triple_accfupds</a> : thm
<a name="line685"></a>    val <a href="#triple_case_cong-val">triple_case_cong</a> : thm
<a name="line686"></a>    val <a href="#triple_case_eq-val">triple_case_eq</a> : thm
<a name="line687"></a>    val <a href="#triple_component_equality-val">triple_component_equality</a> : thm
<a name="line688"></a>    val <a href="#triple_fn_updates-val">triple_fn_updates</a> : thm
<a name="line689"></a>    val <a href="#triple_fupdcanon-val">triple_fupdcanon</a> : thm
<a name="line690"></a>    val <a href="#triple_fupdcanon_comp-val">triple_fupdcanon_comp</a> : thm
<a name="line691"></a>    val <a href="#triple_fupdfupds-val">triple_fupdfupds</a> : thm
<a name="line692"></a>    val <a href="#triple_fupdfupds_comp-val">triple_fupdfupds_comp</a> : thm
<a name="line693"></a>    val <a href="#triple_induction-val">triple_induction</a> : thm
<a name="line694"></a>    val <a href="#triple_literal_11-val">triple_literal_11</a> : thm
<a name="line695"></a>    val <a href="#triple_literal_nchotomy-val">triple_literal_nchotomy</a> : thm
<a name="line696"></a>    val <a href="#triple_nchotomy-val">triple_nchotomy</a> : thm
<a name="line697"></a>    val <a href="#triple_updates_eq_literal-val">triple_updates_eq_literal</a> : thm
<a name="line698"></a>    val <a href="#turn_eq_nil-val">turn_eq_nil</a> : thm
<a name="line699"></a>    val <a href="#turn_exp_0-val">turn_exp_0</a> : thm
<a name="line700"></a>    val <a href="#turn_exp_1-val">turn_exp_1</a> : thm
<a name="line701"></a>    val <a href="#turn_exp_2-val">turn_exp_2</a> : thm
<a name="line702"></a>    val <a href="#turn_exp_SUC-val">turn_exp_SUC</a> : thm
<a name="line703"></a>    val <a href="#turn_exp_length-val">turn_exp_length</a> : thm
<a name="line704"></a>    val <a href="#turn_exp_suc-val">turn_exp_suc</a> : thm
<a name="line705"></a>    val <a href="#turn_length-val">turn_length</a> : thm
<a name="line706"></a>    val <a href="#turn_nil-val">turn_nil</a> : thm
<a name="line707"></a>    val <a href="#turn_not_nil-val">turn_not_nil</a> : thm
<a name="line708"></a>    val <a href="#turn_snoc-val">turn_snoc</a> : thm
<a name="line709"></a>(*
   [number] Parent theory of "combinatorics"
   
   [<a name="MDILATE_def-val"><b>MDILATE_def</b></a>]  Definition
      
      ⊢ (∀e n. MDILATE e n [] = []) ∧
        ∀e n h t.
          MDILATE e n (h::t) =
          if t = [] then [h] else h::GENLIST (K e) (PRE n) ⧺ MDILATE e n t
   
   [<a name="PROD-val"><b>PROD</b></a>]  Definition
      
      ⊢ PROD [] = 1 ∧ ∀h t. PROD (h::t) = h * PROD t
   
   [<a name="PROD_ACC_DEF-val"><b>PROD_ACC_DEF</b></a>]  Definition
      
      ⊢ (∀acc. PROD_ACC [] acc = acc) ∧
        ∀h t acc. PROD_ACC (h::t) acc = PROD_ACC t (h * acc)
   
   [<a name="arrange_def-val"><b>arrange_def</b></a>]  Definition
      
      ⊢ ∀n k. n arrange k = CARD (list_count n k)
   
   [<a name="choose_def-val"><b>choose_def</b></a>]  Definition
      
      ⊢ ∀n k. n choose k = CARD (sub_count n k)
   
   [<a name="interleave_def-val"><b>interleave_def</b></a>]  Definition
      
      ⊢ ∀x ls.
          x interleave ls =
          IMAGE (λk. TAKE k ls ⧺ x::DROP k ls) (upto (LENGTH ls))
   
   [<a name="lcm_upto_def-val"><b>lcm_upto_def</b></a>]  Definition
      
      ⊢ lcm_upto 0 = 1 ∧ ∀n. lcm_upto (SUC n) = lcm (SUC n) (lcm_upto n)
   
   [<a name="leibniz_def-val"><b>leibniz_def</b></a>]  Definition
      
      ⊢ ∀n k. leibniz n k = (n + 1) * binomial n k
   
   [<a name="leibniz_zigzag_def-val"><b>leibniz_zigzag_def</b></a>]  Definition
      
      ⊢ ∀p1 p2.
          p1 zigzag p2 ⇔
          ∃n k x y. p1 = x ⧺ [tb; ta] ⧺ y ∧ p2 = x ⧺ [tb; tc] ⧺ y
   
   [<a name="list_count_def-val"><b>list_count_def</b></a>]  Definition
      
      ⊢ ∀n k.
          list_count n k =
          {ls | ALL_DISTINCT ls ∧ set ls ⊆ count n ∧ LENGTH ls = k}
   
   [<a name="list_lcm_def-val"><b>list_lcm_def</b></a>]  Definition
      
      ⊢ list_lcm [] = 1 ∧ ∀h t. list_lcm (h::t) = lcm h (list_lcm t)
   
   [<a name="monocoloured_def-val"><b>monocoloured_def</b></a>]  Definition
      
      ⊢ ∀n a.
          monocoloured n a =
          {ls | ls ∈ necklace n a ∧ (ls ≠ [] ⇒ SING (set ls))}
   
   [<a name="multicoloured_def-val"><b>multicoloured_def</b></a>]  Definition
      
      ⊢ ∀n a. multicoloured n a = necklace n a DIFF monocoloured n a
   
   [<a name="necklace_def-val"><b>necklace_def</b></a>]  Definition
      
      ⊢ ∀n a. necklace n a = {ls | LENGTH ls = n ∧ set ls ⊆ count a}
   
   [<a name="perm_count_def-val"><b>perm_count_def</b></a>]  Definition
      
      ⊢ ∀n. perm_count n = {ls | ALL_DISTINCT ls ∧ set ls = count n}
   
   [<a name="perm_def-val"><b>perm_def</b></a>]  Definition
      
      ⊢ ∀n. perm n = CARD (perm_count n)
   
   [<a name="perm_set_def-val"><b>perm_set_def</b></a>]  Definition
      
      ⊢ ∀s. perm_set s = {ls | ALL_DISTINCT ls ∧ set ls = s}
   
   [<a name="recordtype_triple_seldef_a_def-val"><b>recordtype_triple_seldef_a_def</b></a>]  Definition
      
      ⊢ ∀n n0 n1. (triple n n0 n1).a = n
   
   [<a name="recordtype_triple_seldef_a_fupd_def-val"><b>recordtype_triple_seldef_a_fupd_def</b></a>]  Definition
      
      ⊢ ∀f n n0 n1. triple n n0 n1 with a updated_by f = triple (f n) n0 n1
   
   [<a name="recordtype_triple_seldef_b_def-val"><b>recordtype_triple_seldef_b_def</b></a>]  Definition
      
      ⊢ ∀n n0 n1. (triple n n0 n1).b = n0
   
   [<a name="recordtype_triple_seldef_b_fupd_def-val"><b>recordtype_triple_seldef_b_fupd_def</b></a>]  Definition
      
      ⊢ ∀f n n0 n1. triple n n0 n1 with b updated_by f = triple n (f n0) n1
   
   [<a name="recordtype_triple_seldef_c_def-val"><b>recordtype_triple_seldef_c_def</b></a>]  Definition
      
      ⊢ ∀n n0 n1. (triple n n0 n1).c = n1
   
   [<a name="recordtype_triple_seldef_c_fupd_def-val"><b>recordtype_triple_seldef_c_fupd_def</b></a>]  Definition
      
      ⊢ ∀f n n0 n1. triple n n0 n1 with c updated_by f = triple n n0 (f n1)
   
   [<a name="rotate_def-val"><b>rotate_def</b></a>]  Definition
      
      ⊢ ∀n l. rotate n l = DROP n l ⧺ TAKE n l
   
   [<a name="set_lcm_def-val"><b>set_lcm_def</b></a>]  Definition
      
      ⊢ ∀s. set_lcm s = list_lcm (SET_TO_LIST s)
   
   [<a name="sub_count_def-val"><b>sub_count_def</b></a>]  Definition
      
      ⊢ ∀n k. sub_count n k = {s | s ⊆ count n ∧ CARD s = k}
   
   [<a name="sub_sets_def-val"><b>sub_sets_def</b></a>]  Definition
      
      ⊢ ∀P k. sub_sets P k = {s | s ⊆ P ∧ CARD s = k}
   
   [<a name="triple_TY_DEF-val"><b>triple_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep.
          TYPE_DEFINITION
            (λa0'.
                 ∀ $var$('triple').
                   (∀a0'.
                      (∃a0 a1 a2.
                         a0' =
                         (λa0 a1 a2.
                              ind_type$CONSTR 0 (a0,a1,a2)
                                (λn. ind_type$BOTTOM)) a0 a1 a2) ⇒
                      $var$('triple') a0') ⇒
                   $var$('triple') a0') rep
   
   [<a name="triple_case_def-val"><b>triple_case_def</b></a>]  Definition
      
      ⊢ ∀a0 a1 a2 f. triple_CASE (triple a0 a1 a2) f = f a0 a1 a2
   
   [<a name="triple_size_def-val"><b>triple_size_def</b></a>]  Definition
      
      ⊢ ∀a0 a1 a2. triple_size (triple a0 a1 a2) = 1 + (a0 + (a1 + a2))
   
   [<a name="triplet_def-val"><b>triplet_def</b></a>]  Definition
      
      ⊢ ∀n k.
          triplet n k =
          &lt;|a := leibniz n k; b := leibniz (n + 1) k;
            c := leibniz (n + 1) (k + 1)|&gt;
   
   [<a name="turn_def-val"><b>turn_def</b></a>]  Definition
      
      ⊢ ∀l. turn l = if l = [] then [] else LAST l::FRONT l
   
   [<a name="CARD_LIST_TO_SET_EQ-val"><b>CARD_LIST_TO_SET_EQ</b></a>]  Theorem
      
      ⊢ ∀l. CARD (set l) = LENGTH (nub l)
   
   [<a name="DILATE_0_0-val"><b>DILATE_0_0</b></a>]  Theorem
      
      ⊢ ∀l e. DILATE e 0 0 l = l
   
   [<a name="DILATE_0_CONS-val"><b>DILATE_0_CONS</b></a>]  Theorem
      
      ⊢ ∀n h t e.
          DILATE e 0 n (h::t) =
          if t = [] then [h] else h::(GENLIST (K e) n ⧺ DILATE e 0 n t)
   
   [<a name="DILATE_0_EL-val"><b>DILATE_0_EL</b></a>]  Theorem
      
      ⊢ ∀l e n k.
          k &lt; LENGTH (DILATE e 0 n l) ⇒
          EL k (DILATE e 0 n l) =
          if k MOD SUC n = 0 then EL (k DIV SUC n) l else e
   
   [<a name="DILATE_0_EQ_NIL-val"><b>DILATE_0_EQ_NIL</b></a>]  Theorem
      
      ⊢ ∀l e n. DILATE e 0 n l = [] ⇔ l = []
   
   [<a name="DILATE_0_LAST-val"><b>DILATE_0_LAST</b></a>]  Theorem
      
      ⊢ ∀l e n. LAST (DILATE e 0 n l) = LAST l
   
   [<a name="DILATE_0_LENGTH-val"><b>DILATE_0_LENGTH</b></a>]  Theorem
      
      ⊢ ∀l e n.
          LENGTH (DILATE e 0 n l) =
          if l = [] then 0 else SUC (SUC n * PRE (LENGTH l))
   
   [<a name="DILATE_0_LENGTH_LOWER-val"><b>DILATE_0_LENGTH_LOWER</b></a>]  Theorem
      
      ⊢ ∀l e n. LENGTH l ≤ LENGTH (DILATE e 0 n l)
   
   [<a name="DILATE_0_LENGTH_UPPER-val"><b>DILATE_0_LENGTH_UPPER</b></a>]  Theorem
      
      ⊢ ∀l e n. LENGTH (DILATE e 0 n l) ≤ SUC (SUC n * PRE (LENGTH l))
   
   [<a name="DILATE_0_SUC-val"><b>DILATE_0_SUC</b></a>]  Theorem
      
      ⊢ ∀l e n. DILATE e 0 (SUC n) l = DILATE e n 1 (DILATE e 0 n l)
   
   [<a name="DILATE_CONS-val"><b>DILATE_CONS</b></a>]  Theorem
      
      ⊢ ∀n m h t e.
          DILATE e n m (h::t) =
          if t = [] then [h]
          else h::(TAKE n t ⧺ GENLIST (K e) m ⧺ DILATE e n m (DROP n t))
   
   [<a name="DILATE_NIL-val"><b>DILATE_NIL</b></a>]  Theorem
      
      ⊢ ∀n m e. DILATE e n m [] = []
   
   [<a name="DILATE_SING-val"><b>DILATE_SING</b></a>]  Theorem
      
      ⊢ ∀n m h e. DILATE e n m [h] = [h]
   
   [<a name="DILATE_def-val"><b>DILATE_def</b></a>]  Theorem
      
      ⊢ (∀n m e. DILATE e n m [] = []) ∧
        (∀n m h e. DILATE e n m [h] = [h]) ∧
        ∀v9 v8 n m h e.
          DILATE e n m (h::v8::v9) =
          h::
            (TAKE n (v8::v9) ⧺ GENLIST (K e) m ⧺
             DILATE e n m (DROP n (v8::v9)))
   
   [<a name="DILATE_ind-val"><b>DILATE_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀e n m. P e n m []) ∧ (∀e n m h. P e n m [h]) ∧
            (∀e n m h v8 v9.
               P e n m (DROP n (v8::v9)) ⇒ P e n m (h::v8::v9)) ⇒
            ∀v v1 v2 v3. P v v1 v2 v3
   
   [<a name="EL_ALL_PROPERTY-val"><b>EL_ALL_PROPERTY</b></a>]  Theorem
      
      ⊢ ∀h1 t1 h2 t2 P.
          LENGTH (h1::t1) = LENGTH (h2::t2) ∧
          (∀k. k &lt; LENGTH (h1::t1) ⇒ P (EL k (h1::t1)) (EL k (h2::t2))) ⇒
          P h1 h2 ∧ ∀k. k &lt; LENGTH t1 ⇒ P (EL k t1) (EL k t2)
   
   [<a name="EL_MAP3-val"><b>EL_MAP3</b></a>]  Theorem
      
      ⊢ ∀lx ly lz n.
          n &lt; MIN (MIN (LENGTH lx) (LENGTH ly)) (LENGTH lz) ⇒
          ∀f. EL n (MAP3 f lx ly lz) = f (EL n lx) (EL n ly) (EL n lz)
   
   [<a name="EVERY_ELEMENT_PROPERTY-val"><b>EVERY_ELEMENT_PROPERTY</b></a>]  Theorem
      
      ⊢ ∀p R. EVERY (λc. c ∈ R) p ⇒ ∀k. k &lt; LENGTH p ⇒ EL k p ∈ R
   
   [<a name="EVERY_LT_IMP_EVERY_LE-val"><b>EVERY_LT_IMP_EVERY_LE</b></a>]  Theorem
      
      ⊢ ∀ls n. EVERY (λj. j &lt; n) ls ⇒ EVERY (λj. j ≤ n) ls
   
   [<a name="EVERY_MONOTONIC_MAP-val"><b>EVERY_MONOTONIC_MAP</b></a>]  Theorem
      
      ⊢ ∀l f P Q. (∀x. P x ⇒ (Q ∘ f) x) ∧ EVERY P l ⇒ EVERY Q (MAP f l)
   
   [<a name="EXISTS_triple-val"><b>EXISTS_triple</b></a>]  Theorem
      
      ⊢ ∀P. (∃t. P t) ⇔ ∃n1 n0 n. P &lt;|a := n1; b := n0; c := n|&gt;
   
   [<a name="FILTER_EL_NEXT_IDX-val"><b>FILTER_EL_NEXT_IDX</b></a>]  Theorem
      
      ⊢ ∀P ls l1 l2 l3 x y.
          (let
             fs = FILTER P ls
           in
             ALL_DISTINCT ls ∧ ls = l1 ⧺ x::l2 ⧺ y::l3 ∧ P x ∧ P y ⇒
             (findi y fs = 1 + findi x fs ⇔ FILTER P l2 = []))
   
   [<a name="FINITE_SURJ_IFF-val"><b>FINITE_SURJ_IFF</b></a>]  Theorem
      
      ⊢ ∀f s t.
          FINITE t ⇒ (SURJ f s t ⇔ CARD (IMAGE f s) = CARD t ∧ over f s t)
   
   [<a name="FORALL_triple-val"><b>FORALL_triple</b></a>]  Theorem
      
      ⊢ ∀P. (∀t. P t) ⇔ ∀n1 n0 n. P &lt;|a := n1; b := n0; c := n|&gt;
   
   [<a name="FUNPOW_cons_eq_map_0-val"><b>FUNPOW_cons_eq_map_0</b></a>]  Theorem
      
      ⊢ ∀f u n.
          FUNPOW (λls. f (HD ls)::ls) n [u] =
          MAP (λj. FUNPOW f j u) (n downto 0)
   
   [<a name="FUNPOW_cons_eq_map_1-val"><b>FUNPOW_cons_eq_map_1</b></a>]  Theorem
      
      ⊢ ∀f u n.
          0 &lt; n ⇒
          FUNPOW (λls. f (HD ls)::ls) (n − 1) [f u] =
          MAP (λj. FUNPOW f j u) (n downto 1)
   
   [<a name="FUNPOW_cons_head-val"><b>FUNPOW_cons_head</b></a>]  Theorem
      
      ⊢ ∀f n ls. HD (FUNPOW (λls. f (HD ls)::ls) n ls) = FUNPOW f n (HD ls)
   
   [<a name="FUNSET_ALT-val"><b>FUNSET_ALT</b></a>]  Theorem
      
      ⊢ ∀P Q. FUNSET P Q = {f | over f P Q}
   
   [<a name="GENLIST_MONO_DEC-val"><b>GENLIST_MONO_DEC</b></a>]  Theorem
      
      ⊢ ∀f n. RMONO f ⇒ MONO_DEC (GENLIST f n)
   
   [<a name="GENLIST_MONO_INC-val"><b>GENLIST_MONO_INC</b></a>]  Theorem
      
      ⊢ ∀f n. MONO f ⇒ MONO_INC (GENLIST f n)
   
   [<a name="GENLIST_binomial_index_shift-val"><b>GENLIST_binomial_index_shift</b></a>]  Theorem
      
      ⊢ ∀n x y.
          GENLIST ((λk. binomial n k * x ** SUC (n − k) * y ** k) ∘ SUC) n =
          GENLIST (λk. binomial n (SUC k) * x ** (n − k) * y ** SUC k) n
   
   [<a name="INJ_IFF_BIJ_IMAGE-val"><b>INJ_IFF_BIJ_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s t. over f s t ⇒ (INJ f s t ⇔ BIJ f s (IMAGE f s))
   
   [<a name="INJ_IMAGE_BIJ_IFF-val"><b>INJ_IMAGE_BIJ_IFF</b></a>]  Theorem
      
      ⊢ ∀f s t. INJ f s t ⇔ BIJ f s (IMAGE f s) ∧ over f s t
   
   [<a name="INJ_IMAGE_IFF-val"><b>INJ_IMAGE_IFF</b></a>]  Theorem
      
      ⊢ ∀f s t. INJ f s t ⇔ INJ f s (IMAGE f s) ∧ over f s t
   
   [<a name="LENGTH_MAP3-val"><b>LENGTH_MAP3</b></a>]  Theorem
      
      ⊢ ∀lx ly lz f.
          LENGTH (MAP3 f lx ly lz) =
          MIN (MIN (LENGTH lx) (LENGTH ly)) (LENGTH lz)
   
   [<a name="LIST_TO_SET_REDUCTION-val"><b>LIST_TO_SET_REDUCTION</b></a>]  Theorem
      
      ⊢ ∀l1 l2 h.
          ¬MEM h l1 ∧ set (h::l1) = set l2 ⇒
          ∃p1 p2.
            ¬MEM h p1 ∧ ¬MEM h p2 ∧ nub l2 = p1 ⧺ [h] ⧺ p2 ∧
            set l1 = set (p1 ⧺ p2)
   
   [<a name="LUPDATE_APPEND_0-val"><b>LUPDATE_APPEND_0</b></a>]  Theorem
      
      ⊢ ∀ls a h t. LUPDATE a (LENGTH ls) (ls ⧺ h::t) = ls ⧺ a::t
   
   [<a name="LUPDATE_APPEND_0_1-val"><b>LUPDATE_APPEND_0_1</b></a>]  Theorem
      
      ⊢ ∀ls a b h k t.
          LUPDATE b (LENGTH ls + 1) (LUPDATE a (LENGTH ls) (ls ⧺ h::k::t)) =
          ls ⧺ a::b::t
   
   [<a name="LUPDATE_APPEND_1-val"><b>LUPDATE_APPEND_1</b></a>]  Theorem
      
      ⊢ ∀ls b h k t.
          LUPDATE b (LENGTH ls + 1) (ls ⧺ h::k::t) = ls ⧺ h::b::t
   
   [<a name="LUPDATE_DIFF_SPOT-val"><b>LUPDATE_DIFF_SPOT</b></a>]  Theorem
      
      ⊢ ∀ls m n p q.
          m ≠ n ⇒
          LUPDATE q n (LUPDATE p m ls) = LUPDATE p m (LUPDATE q n ls)
   
   [<a name="LUPDATE_EL-val"><b>LUPDATE_EL</b></a>]  Theorem
      
      ⊢ ∀e n l p.
          p &lt; LENGTH l ⇒ EL p (LUPDATE e n l) = if p = n then e else EL p l
   
   [<a name="LUPDATE_LEN-val"><b>LUPDATE_LEN</b></a>]  Theorem
      
      ⊢ ∀e n l. LENGTH (LUPDATE e n l) = LENGTH l
   
   [<a name="LUPDATE_SAME_SPOT-val"><b>LUPDATE_SAME_SPOT</b></a>]  Theorem
      
      ⊢ ∀ls n p q. LUPDATE q n (LUPDATE p n ls) = LUPDATE q n ls
   
   [<a name="MAP2_LE-val"><b>MAP2_LE</b></a>]  Theorem
      
      ⊢ ∀f g.
          (∀x y. f x y ≤ g x y) ⇒
          ∀lx ly n. EL n (MAP2 f lx ly) ≤ EL n (MAP2 g lx ly)
   
   [<a name="MAP3-val"><b>MAP3</b></a>]  Theorem
      
      ⊢ (∀f. MAP3 f [] [] [] = []) ∧
        ∀f h1 t1 h2 t2 h3 t3.
          MAP3 f (h1::t1) (h2::t2) (h3::t3) = f h1 h2 h3::MAP3 f t1 t2 t3
   
   [<a name="MAP3_DEF-val"><b>MAP3_DEF</b></a>]  Theorem
      
      ⊢ (∀t3 t2 t1 h3 h2 h1 f.
           MAP3 f (h1::t1) (h2::t2) (h3::t3) = f h1 h2 h3::MAP3 f t1 t2 t3) ∧
        (∀z y f. MAP3 f [] y z = []) ∧
        (∀z v5 v4 f. MAP3 f (v4::v5) [] z = []) ∧
        ∀v5 v4 v13 v12 f. MAP3 f (v4::v5) (v12::v13) [] = []
   
   [<a name="MAP3_IND-val"><b>MAP3_IND</b></a>]  Theorem
      
      ⊢ ∀P. (∀f h1 t1 h2 t2 h3 t3.
               P f t1 t2 t3 ⇒ P f (h1::t1) (h2::t2) (h3::t3)) ∧
            (∀f y z. P f [] y z) ∧ (∀f v4 v5 z. P f (v4::v5) [] z) ∧
            (∀f v4 v5 v12 v13. P f (v4::v5) (v12::v13) []) ⇒
            ∀v v1 v2 v3. P v v1 v2 v3
   
   [<a name="MAP3_LE-val"><b>MAP3_LE</b></a>]  Theorem
      
      ⊢ ∀f g.
          (∀x y z. f x y z ≤ g x y z) ⇒
          ∀lx ly lz n. EL n (MAP3 f lx ly lz) ≤ EL n (MAP3 g lx ly lz)
   
   [<a name="MAP_LE-val"><b>MAP_LE</b></a>]  Theorem
      
      ⊢ ∀f g. (∀x. f x ≤ g x) ⇒ ∀ls n. EL n (MAP f ls) ≤ EL n (MAP g ls)
   
   [<a name="MAX_LIST_MONO_MAP-val"><b>MAX_LIST_MONO_MAP</b></a>]  Theorem
      
      ⊢ ∀f. MONO f ⇒ ∀ls. ls ≠ [] ⇒ MAX_LIST (MAP f ls) = f (MAX_LIST ls)
   
   [<a name="MDILATE_0-val"><b>MDILATE_0</b></a>]  Theorem
      
      ⊢ ∀l e. MDILATE e 0 l = l
   
   [<a name="MDILATE_1-val"><b>MDILATE_1</b></a>]  Theorem
      
      ⊢ ∀l e. MDILATE e 1 l = l
   
   [<a name="MDILATE_CONS-val"><b>MDILATE_CONS</b></a>]  Theorem
      
      ⊢ ∀e n h t.
          MDILATE e n (h::t) =
          if t = [] then [h] else h::GENLIST (K e) (PRE n) ⧺ MDILATE e n t
   
   [<a name="MDILATE_EL-val"><b>MDILATE_EL</b></a>]  Theorem
      
      ⊢ ∀l e n k.
          k &lt; LENGTH (MDILATE e n l) ⇒
          EL k (MDILATE e n l) =
          if n = 0 then EL k l
          else if k MOD n = 0 then EL (k DIV n) l
          else e
   
   [<a name="MDILATE_EQ_NIL-val"><b>MDILATE_EQ_NIL</b></a>]  Theorem
      
      ⊢ ∀l e n. MDILATE e n l = [] ⇔ l = []
   
   [<a name="MDILATE_LAST-val"><b>MDILATE_LAST</b></a>]  Theorem
      
      ⊢ ∀l e n. LAST (MDILATE e n l) = LAST l
   
   [<a name="MDILATE_LENGTH-val"><b>MDILATE_LENGTH</b></a>]  Theorem
      
      ⊢ ∀l e n.
          LENGTH (MDILATE e n l) =
          if n = 0 then LENGTH l
          else if l = [] then 0
          else SUC (n * PRE (LENGTH l))
   
   [<a name="MDILATE_LENGTH_LOWER-val"><b>MDILATE_LENGTH_LOWER</b></a>]  Theorem
      
      ⊢ ∀l e n. LENGTH l ≤ LENGTH (MDILATE e n l)
   
   [<a name="MDILATE_LENGTH_UPPER-val"><b>MDILATE_LENGTH_UPPER</b></a>]  Theorem
      
      ⊢ ∀l e n. 0 &lt; n ⇒ LENGTH (MDILATE e n l) ≤ SUC (n * PRE (LENGTH l))
   
   [<a name="MDILATE_NIL-val"><b>MDILATE_NIL</b></a>]  Theorem
      
      ⊢ ∀e n. MDILATE e n [] = []
   
   [<a name="MDILATE_SING-val"><b>MDILATE_SING</b></a>]  Theorem
      
      ⊢ ∀e n x. MDILATE e n [x] = [x]
   
   [<a name="MEM_MAP2-val"><b>MEM_MAP2</b></a>]  Theorem
      
      ⊢ ∀f x l1 l2.
          MEM x (MAP2 f l1 l2) ⇒
          ∃y1 y2. x = f y1 y2 ∧ MEM y1 l1 ∧ MEM y2 l2
   
   [<a name="MEM_MAP2_LOWER-val"><b>MEM_MAP2_LOWER</b></a>]  Theorem
      
      ⊢ ∀f. MONO2 f ⇒
            ∀lx ly e.
              MEM e (MAP2 f lx ly) ⇒ f (MIN_LIST lx) (MIN_LIST ly) ≤ e
   
   [<a name="MEM_MAP2_UPPER-val"><b>MEM_MAP2_UPPER</b></a>]  Theorem
      
      ⊢ ∀f. MONO2 f ⇒
            ∀lx ly e.
              MEM e (MAP2 f lx ly) ⇒ e ≤ f (MAX_LIST lx) (MAX_LIST ly)
   
   [<a name="MEM_MAP3-val"><b>MEM_MAP3</b></a>]  Theorem
      
      ⊢ ∀f x l1 l2 l3.
          MEM x (MAP3 f l1 l2 l3) ⇒
          ∃y1 y2 y3. x = f y1 y2 y3 ∧ MEM y1 l1 ∧ MEM y2 l2 ∧ MEM y3 l3
   
   [<a name="MEM_MAP3_LOWER-val"><b>MEM_MAP3_LOWER</b></a>]  Theorem
      
      ⊢ ∀f. MONO3 f ⇒
            ∀lx ly lz e.
              MEM e (MAP3 f lx ly lz) ⇒
              f (MIN_LIST lx) (MIN_LIST ly) (MIN_LIST lz) ≤ e
   
   [<a name="MEM_MAP3_UPPER-val"><b>MEM_MAP3_UPPER</b></a>]  Theorem
      
      ⊢ ∀f. MONO3 f ⇒
            ∀lx ly lz e.
              MEM e (MAP3 f lx ly lz) ⇒
              e ≤ f (MAX_LIST lx) (MAX_LIST ly) (MAX_LIST lz)
   
   [<a name="MEM_MAP_LOWER-val"><b>MEM_MAP_LOWER</b></a>]  Theorem
      
      ⊢ ∀f. MONO f ⇒ ∀ls e. MEM e (MAP f ls) ⇒ f (MIN_LIST ls) ≤ e
   
   [<a name="MEM_MAP_UPPER-val"><b>MEM_MAP_UPPER</b></a>]  Theorem
      
      ⊢ ∀f. MONO f ⇒ ∀ls e. MEM e (MAP f ls) ⇒ e ≤ f (MAX_LIST ls)
   
   [<a name="MIN_LIST_MONO_MAP-val"><b>MIN_LIST_MONO_MAP</b></a>]  Theorem
      
      ⊢ ∀f. MONO f ⇒ ∀ls. ls ≠ [] ⇒ MIN_LIST (MAP f ls) = f (MIN_LIST ls)
   
   [<a name="MONO_LIST_TO_SET-val"><b>MONO_LIST_TO_SET</b></a>]  Theorem
      
      ⊢ ∀x. set [x] = {x}
   
   [<a name="PAD_LEFT_0-val"><b>PAD_LEFT_0</b></a>]  Theorem
      
      ⊢ ∀l c. PAD_LEFT c 0 l = l
   
   [<a name="PAD_LEFT_BY_LEFT-val"><b>PAD_LEFT_BY_LEFT</b></a>]  Theorem
      
      ⊢ ∀ls c n. PAD_LEFT c n ls = PAD_LEFT c (n − LENGTH ls) [] ⧺ ls
   
   [<a name="PAD_LEFT_BY_RIGHT-val"><b>PAD_LEFT_BY_RIGHT</b></a>]  Theorem
      
      ⊢ ∀ls c n. PAD_LEFT c n ls = PAD_RIGHT c (n − LENGTH ls) [] ⧺ ls
   
   [<a name="PAD_LEFT_CONS-val"><b>PAD_LEFT_CONS</b></a>]  Theorem
      
      ⊢ ∀l n. LENGTH l ≤ n ⇒ ∀c. PAD_LEFT c (SUC n) l = c::PAD_LEFT c n l
   
   [<a name="PAD_LEFT_EQ_NIL-val"><b>PAD_LEFT_EQ_NIL</b></a>]  Theorem
      
      ⊢ ∀l c n. PAD_LEFT c n l = [] ⇔ l = [] ∧ n = 0
   
   [<a name="PAD_LEFT_ID-val"><b>PAD_LEFT_ID</b></a>]  Theorem
      
      ⊢ ∀l c n. n ≤ LENGTH l ⇒ PAD_LEFT c n l = l
   
   [<a name="PAD_LEFT_LAST-val"><b>PAD_LEFT_LAST</b></a>]  Theorem
      
      ⊢ ∀l c n. l ≠ [] ⇒ LAST (PAD_LEFT c n l) = LAST l
   
   [<a name="PAD_LEFT_LENGTH-val"><b>PAD_LEFT_LENGTH</b></a>]  Theorem
      
      ⊢ ∀n c s. LENGTH (PAD_LEFT c n s) = MAX n (LENGTH s)
   
   [<a name="PAD_LEFT_NIL-val"><b>PAD_LEFT_NIL</b></a>]  Theorem
      
      ⊢ ∀n c. PAD_LEFT c n [] = GENLIST (K c) n
   
   [<a name="PAD_LEFT_NIL_EQ-val"><b>PAD_LEFT_NIL_EQ</b></a>]  Theorem
      
      ⊢ ∀n c. 0 &lt; n ⇒ PAD_LEFT c n [] = PAD_LEFT c n [c]
   
   [<a name="PAD_RIGHT_0-val"><b>PAD_RIGHT_0</b></a>]  Theorem
      
      ⊢ ∀l c. PAD_RIGHT c 0 l = l
   
   [<a name="PAD_RIGHT_BY_LEFT-val"><b>PAD_RIGHT_BY_LEFT</b></a>]  Theorem
      
      ⊢ ∀ls c n. PAD_RIGHT c n ls = ls ⧺ PAD_LEFT c (n − LENGTH ls) []
   
   [<a name="PAD_RIGHT_BY_RIGHT-val"><b>PAD_RIGHT_BY_RIGHT</b></a>]  Theorem
      
      ⊢ ∀ls c n. PAD_RIGHT c n ls = ls ⧺ PAD_RIGHT c (n − LENGTH ls) []
   
   [<a name="PAD_RIGHT_CONS-val"><b>PAD_RIGHT_CONS</b></a>]  Theorem
      
      ⊢ ∀h t c n. h::PAD_RIGHT c n t = PAD_RIGHT c (SUC n) (h::t)
   
   [<a name="PAD_RIGHT_EQ_NIL-val"><b>PAD_RIGHT_EQ_NIL</b></a>]  Theorem
      
      ⊢ ∀l c n. PAD_RIGHT c n l = [] ⇔ l = [] ∧ n = 0
   
   [<a name="PAD_RIGHT_ID-val"><b>PAD_RIGHT_ID</b></a>]  Theorem
      
      ⊢ ∀l c n. n ≤ LENGTH l ⇒ PAD_RIGHT c n l = l
   
   [<a name="PAD_RIGHT_LENGTH-val"><b>PAD_RIGHT_LENGTH</b></a>]  Theorem
      
      ⊢ ∀n c s. LENGTH (PAD_RIGHT c n s) = MAX n (LENGTH s)
   
   [<a name="PAD_RIGHT_NIL-val"><b>PAD_RIGHT_NIL</b></a>]  Theorem
      
      ⊢ ∀n c. PAD_RIGHT c n [] = GENLIST (K c) n
   
   [<a name="PAD_RIGHT_NIL_EQ-val"><b>PAD_RIGHT_NIL_EQ</b></a>]  Theorem
      
      ⊢ ∀n c. 0 &lt; n ⇒ PAD_RIGHT c n [] = PAD_RIGHT c n [c]
   
   [<a name="PAD_RIGHT_SNOC-val"><b>PAD_RIGHT_SNOC</b></a>]  Theorem
      
      ⊢ ∀l n.
          LENGTH l ≤ n ⇒
          ∀c. PAD_RIGHT c (SUC n) l = SNOC c (PAD_RIGHT c n l)
   
   [<a name="POSITIVE_THM-val"><b>POSITIVE_THM</b></a>]  Theorem
      
      ⊢ ∀ls. EVERY_POSITIVE ls ⇔ POSITIVE ls
   
   [<a name="PROD_ACC_PROD_LEM-val"><b>PROD_ACC_PROD_LEM</b></a>]  Theorem
      
      ⊢ ∀L n. PROD_ACC L n = PROD L * n
   
   [<a name="PROD_ACC_SUM_LEM-val"><b>PROD_ACC_SUM_LEM</b></a>]  Theorem
      
      ⊢ ∀L n. PROD_ACC L n = PROD L * n
   
   [<a name="PROD_APPEND-val"><b>PROD_APPEND</b></a>]  Theorem
      
      ⊢ ∀l1 l2. PROD (l1 ⧺ l2) = PROD l1 * PROD l2
   
   [<a name="PROD_CONS-val"><b>PROD_CONS</b></a>]  Theorem
      
      ⊢ ∀h t. PROD (h::t) = h * PROD t
   
   [<a name="PROD_CONSTANT-val"><b>PROD_CONSTANT</b></a>]  Theorem
      
      ⊢ ∀n x. PROD (GENLIST (λj. x) n) = x ** n
   
   [<a name="PROD_EQ_0-val"><b>PROD_EQ_0</b></a>]  Theorem
      
      ⊢ ∀l. PROD l = 0 ⇔ MEM 0 l
   
   [<a name="PROD_GENLIST_K-val"><b>PROD_GENLIST_K</b></a>]  Theorem
      
      ⊢ ∀m n. PROD (GENLIST (K m) n) = m ** n
   
   [<a name="PROD_IMAGE_eq_PROD_MAP_SET_TO_LIST-val"><b>PROD_IMAGE_eq_PROD_MAP_SET_TO_LIST</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀f. Π f s = PROD (MAP f (SET_TO_LIST s))
   
   [<a name="PROD_MAP_FOLDL-val"><b>PROD_MAP_FOLDL</b></a>]  Theorem
      
      ⊢ ∀ls f. PROD (MAP f ls) = FOLDL (λa e. a * f e) 1 ls
   
   [<a name="PROD_NIL-val"><b>PROD_NIL</b></a>]  Theorem
      
      ⊢ PROD [] = 1
   
   [<a name="PROD_POS-val"><b>PROD_POS</b></a>]  Theorem
      
      ⊢ ∀l. EVERY_POSITIVE l ⇒ 0 &lt; PROD l
   
   [<a name="PROD_POS_ALT-val"><b>PROD_POS_ALT</b></a>]  Theorem
      
      ⊢ ∀l. POSITIVE l ⇒ 0 &lt; PROD l
   
   [<a name="PROD_PROD_ACC-val"><b>PROD_PROD_ACC</b></a>]  Theorem
      
      ⊢ ∀L. PROD L = PROD_ACC L 1
   
   [<a name="PROD_SING-val"><b>PROD_SING</b></a>]  Theorem
      
      ⊢ ∀n. PROD [n] = n
   
   [<a name="PROD_SNOC-val"><b>PROD_SNOC</b></a>]  Theorem
      
      ⊢ ∀x l. PROD (SNOC x l) = PROD l * x
   
   [<a name="PROD_SQUARING_LIST-val"><b>PROD_SQUARING_LIST</b></a>]  Theorem
      
      ⊢ ∀m n. PROD (GENLIST (λj. n ** 2 ** j) m) = n ** tops 2 m
   
   [<a name="PROD_eq_1-val"><b>PROD_eq_1</b></a>]  Theorem
      
      ⊢ ∀ls. PROD ls = 1 ⇔ ∀x. MEM x ls ⇒ x = 1
   
   [<a name="PROD_eval-val"><b>PROD_eval</b></a>]  Theorem
      
      ⊢ ∀ls. PROD ls = if ls = [] then 1 else HD ls * PROD (TL ls)
   
   [<a name="SUM_ADD_GENLIST-val"><b>SUM_ADD_GENLIST</b></a>]  Theorem
      
      ⊢ ∀a b n.
          SUM (GENLIST a n) + SUM (GENLIST b n) =
          SUM (GENLIST (λk. a k + b k) n)
   
   [<a name="SUM_CONS-val"><b>SUM_CONS</b></a>]  Theorem
      
      ⊢ ∀h t. SUM (h::t) = h + SUM t
   
   [<a name="SUM_CONSTANT-val"><b>SUM_CONSTANT</b></a>]  Theorem
      
      ⊢ ∀n x. SUM (GENLIST (λj. x) n) = n * x
   
   [<a name="SUM_DECOMPOSE_FIRST-val"><b>SUM_DECOMPOSE_FIRST</b></a>]  Theorem
      
      ⊢ ∀f n. SUM (GENLIST f (SUC n)) = f 0 + SUM (GENLIST (f ∘ SUC) n)
   
   [<a name="SUM_DECOMPOSE_FIRST_LAST-val"><b>SUM_DECOMPOSE_FIRST_LAST</b></a>]  Theorem
      
      ⊢ ∀f n.
          0 &lt; n ⇒
          SUM (GENLIST f (SUC n)) =
          f 0 + SUM (GENLIST (f ∘ SUC) (PRE n)) + f n
   
   [<a name="SUM_DECOMPOSE_LAST-val"><b>SUM_DECOMPOSE_LAST</b></a>]  Theorem
      
      ⊢ ∀f n. SUM (GENLIST f (SUC n)) = SUM (GENLIST f n) + f n
   
   [<a name="SUM_DOUBLING_LIST-val"><b>SUM_DOUBLING_LIST</b></a>]  Theorem
      
      ⊢ ∀m n. SUM (GENLIST (λj. n * 2 ** j) m) = n * tops 2 m
   
   [<a name="SUM_EQ_0-val"><b>SUM_EQ_0</b></a>]  Theorem
      
      ⊢ ∀l. SUM l = 0 ⇔ EVERY (λx. x = 0) l
   
   [<a name="SUM_GENLIST-val"><b>SUM_GENLIST</b></a>]  Theorem
      
      ⊢ ∀f n. SUM (GENLIST f n) = ∑ f (count n)
   
   [<a name="SUM_GENLIST_APPEND-val"><b>SUM_GENLIST_APPEND</b></a>]  Theorem
      
      ⊢ ∀a b n.
          SUM (GENLIST a n ⧺ GENLIST b n) = SUM (GENLIST (λk. a k + b k) n)
   
   [<a name="SUM_GENLIST_K-val"><b>SUM_GENLIST_K</b></a>]  Theorem
      
      ⊢ ∀m n. SUM (GENLIST (K m) n) = m * n
   
   [<a name="SUM_GENLIST_MOD-val"><b>SUM_GENLIST_MOD</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒
            ∀f. SUM (GENLIST ((λk. f k) ∘ SUC) (PRE n)) MOD n =
                SUM (GENLIST ((λk. f k MOD n) ∘ SUC) (PRE n)) MOD n
   
   [<a name="SUM_GENLIST_REVERSE-val"><b>SUM_GENLIST_REVERSE</b></a>]  Theorem
      
      ⊢ ∀f n. SUM (GENLIST (λj. f (n − j)) n) = SUM (MAP f [1 .. n])
   
   [<a name="SUM_IMAGE_count-val"><b>SUM_IMAGE_count</b></a>]  Theorem
      
      ⊢ ∀f n. ∑ f (count n) = SUM (MAP f [0 ..&lt; n])
   
   [<a name="SUM_IMAGE_upto-val"><b>SUM_IMAGE_upto</b></a>]  Theorem
      
      ⊢ ∀f n. ∑ f (upto n) = SUM (MAP f [0 .. n])
   
   [<a name="SUM_LE-val"><b>SUM_LE</b></a>]  Theorem
      
      ⊢ ∀l1 l2.
          LENGTH l1 = LENGTH l2 ∧ (∀k. k &lt; LENGTH l1 ⇒ EL k l1 ≤ EL k l2) ⇒
          SUM l1 ≤ SUM l2
   
   [<a name="SUM_LEFT_ADD_DISTRIB-val"><b>SUM_LEFT_ADD_DISTRIB</b></a>]  Theorem
      
      ⊢ ∀s m n. SUM s * (m + n) = SUM (MAP ($* m) s) + SUM (MAP ($* n) s)
   
   [<a name="SUM_LE_EL-val"><b>SUM_LE_EL</b></a>]  Theorem
      
      ⊢ ∀l n. n &lt; LENGTH l ⇒ EL n l ≤ SUM l
   
   [<a name="SUM_LE_MEM-val"><b>SUM_LE_MEM</b></a>]  Theorem
      
      ⊢ ∀l x. MEM x l ⇒ x ≤ SUM l
   
   [<a name="SUM_LE_SUM_EL-val"><b>SUM_LE_SUM_EL</b></a>]  Theorem
      
      ⊢ ∀l m n. m &lt; n ∧ n &lt; LENGTH l ⇒ EL m l + EL n l ≤ SUM l
   
   [<a name="SUM_LOWER-val"><b>SUM_LOWER</b></a>]  Theorem
      
      ⊢ ∀ls. MIN_LIST ls * LENGTH ls ≤ SUM ls
   
   [<a name="SUM_MAP2_K-val"><b>SUM_MAP2_K</b></a>]  Theorem
      
      ⊢ ∀lx ly c.
          SUM (MAP2 (λx y. c) lx ly) = c * LENGTH (MAP2 (λx y. c) lx ly)
   
   [<a name="SUM_MAP2_UPPER-val"><b>SUM_MAP2_UPPER</b></a>]  Theorem
      
      ⊢ ∀f. MONO2 f ⇒
            ∀lx ly.
              SUM (MAP2 f lx ly) ≤
              f (MAX_LIST lx) (MAX_LIST ly) * LENGTH (MAP2 f lx ly)
   
   [<a name="SUM_MAP3_K-val"><b>SUM_MAP3_K</b></a>]  Theorem
      
      ⊢ ∀lx ly lz c.
          SUM (MAP3 (λx y z. c) lx ly lz) =
          c * LENGTH (MAP3 (λx y z. c) lx ly lz)
   
   [<a name="SUM_MAP3_UPPER-val"><b>SUM_MAP3_UPPER</b></a>]  Theorem
      
      ⊢ ∀f. MONO3 f ⇒
            ∀lx ly lz.
              SUM (MAP3 f lx ly lz) ≤
              f (MAX_LIST lx) (MAX_LIST ly) (MAX_LIST lz) *
              LENGTH (MAP3 f lx ly lz)
   
   [<a name="SUM_MAP_K-val"><b>SUM_MAP_K</b></a>]  Theorem
      
      ⊢ ∀ls c. SUM (MAP (K c) ls) = c * LENGTH ls
   
   [<a name="SUM_MAP_K_LE-val"><b>SUM_MAP_K_LE</b></a>]  Theorem
      
      ⊢ ∀ls a b. a ≤ b ⇒ SUM (MAP (K a) ls) ≤ SUM (MAP (K b) ls)
   
   [<a name="SUM_MAP_LE-val"><b>SUM_MAP_LE</b></a>]  Theorem
      
      ⊢ ∀f g ls. EVERY (λx. f x ≤ g x) ls ⇒ SUM (MAP f ls) ≤ SUM (MAP g ls)
   
   [<a name="SUM_MAP_LT-val"><b>SUM_MAP_LT</b></a>]  Theorem
      
      ⊢ ∀f g ls.
          EVERY (λx. f x &lt; g x) ls ∧ ls ≠ [] ⇒
          SUM (MAP f ls) &lt; SUM (MAP g ls)
   
   [<a name="SUM_MAP_UPPER-val"><b>SUM_MAP_UPPER</b></a>]  Theorem
      
      ⊢ ∀f. MONO f ⇒ ∀ls. SUM (MAP f ls) ≤ f (MAX_LIST ls) * LENGTH ls
   
   [<a name="SUM_MOD-val"><b>SUM_MOD</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀l. SUM l MOD n = SUM (MAP (λx. x MOD n) l) MOD n
   
   [<a name="SUM_MONO_MAP-val"><b>SUM_MONO_MAP</b></a>]  Theorem
      
      ⊢ ∀f1 f2. (∀x. f1 x ≤ f2 x) ⇒ ∀ls. SUM (MAP f1 ls) ≤ SUM (MAP f2 ls)
   
   [<a name="SUM_MONO_MAP2-val"><b>SUM_MONO_MAP2</b></a>]  Theorem
      
      ⊢ ∀f1 f2.
          (∀x y. f1 x y ≤ f2 x y) ⇒
          ∀lx ly. SUM (MAP2 f1 lx ly) ≤ SUM (MAP2 f2 lx ly)
   
   [<a name="SUM_MONO_MAP3-val"><b>SUM_MONO_MAP3</b></a>]  Theorem
      
      ⊢ ∀f1 f2.
          (∀x y z. f1 x y z ≤ f2 x y z) ⇒
          ∀lx ly lz. SUM (MAP3 f1 lx ly lz) ≤ SUM (MAP3 f2 lx ly lz)
   
   [<a name="SUM_MULT-val"><b>SUM_MULT</b></a>]  Theorem
      
      ⊢ ∀s k. k * SUM s = SUM (MAP ($* k) s)
   
   [<a name="SUM_NIL-val"><b>SUM_NIL</b></a>]  Theorem
      
      ⊢ SUM [] = 0
   
   [<a name="SUM_RIGHT_ADD_DISTRIB-val"><b>SUM_RIGHT_ADD_DISTRIB</b></a>]  Theorem
      
      ⊢ ∀s m n. (m + n) * SUM s = SUM (MAP ($* m) s) + SUM (MAP ($* n) s)
   
   [<a name="SUM_SING-val"><b>SUM_SING</b></a>]  Theorem
      
      ⊢ ∀n. SUM [n] = n
   
   [<a name="SUM_UPPER-val"><b>SUM_UPPER</b></a>]  Theorem
      
      ⊢ ∀ls. SUM ls ≤ MAX_LIST ls * LENGTH ls
   
   [<a name="SURJ_CARD_IMAGE_EQ-val"><b>SURJ_CARD_IMAGE_EQ</b></a>]  Theorem
      
      ⊢ ∀f s t.
          FINITE t ∧ over f s t ⇒ (SURJ f s t ⇔ CARD (IMAGE f s) = CARD t)
   
   [<a name="arithmetic_sum_eqn-val"><b>arithmetic_sum_eqn</b></a>]  Theorem
      
      ⊢ ∀n. SUM [1 ..&lt; n] = HALF (n * (n − 1))
   
   [<a name="arithmetic_sum_eqn_alt-val"><b>arithmetic_sum_eqn_alt</b></a>]  Theorem
      
      ⊢ ∀n. SUM [1 .. n] = HALF (n * (n + 1))
   
   [<a name="arrange_0_n-val"><b>arrange_0_n</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ 0 arrange n = 0
   
   [<a name="arrange_alt-val"><b>arrange_alt</b></a>]  Theorem
      
      ⊢ ∀n k. n arrange k = (n choose k) * FACT k
   
   [<a name="arrange_eq_0-val"><b>arrange_eq_0</b></a>]  Theorem
      
      ⊢ ∀n k. n arrange k = 0 ⇔ n &lt; k
   
   [<a name="arrange_eqn-val"><b>arrange_eqn</b></a>]  Theorem
      
      ⊢ ∀n k. n arrange k = (n choose k) * perm k
   
   [<a name="arrange_formula-val"><b>arrange_formula</b></a>]  Theorem
      
      ⊢ ∀n k. n arrange k = binomial n k * FACT k
   
   [<a name="arrange_formula2-val"><b>arrange_formula2</b></a>]  Theorem
      
      ⊢ ∀n k. k ≤ n ⇒ n arrange k = FACT n DIV FACT (n − k)
   
   [<a name="arrange_n_0-val"><b>arrange_n_0</b></a>]  Theorem
      
      ⊢ ∀n. n arrange 0 = 1
   
   [<a name="arrange_n_n-val"><b>arrange_n_n</b></a>]  Theorem
      
      ⊢ ∀n. n arrange n = perm n
   
   [<a name="arrange_n_n_alt-val"><b>arrange_n_n_alt</b></a>]  Theorem
      
      ⊢ ∀n. n arrange n = FACT n
   
   [<a name="beta_0_n-val"><b>beta_0_n</b></a>]  Theorem
      
      ⊢ ∀n. beta 0 n = 0
   
   [<a name="beta_alt-val"><b>beta_alt</b></a>]  Theorem
      
      ⊢ ∀n k. 0 &lt; n ∧ 0 &lt; k ⇒ beta n k = leibniz (n − 1) (k − 1)
   
   [<a name="beta_divides_beta_factor-val"><b>beta_divides_beta_factor</b></a>]  Theorem
      
      ⊢ ∀m n k. k ≤ m ∧ m ≤ n ⇒ beta n k divides beta m k * binomial n m
   
   [<a name="beta_eq_0-val"><b>beta_eq_0</b></a>]  Theorem
      
      ⊢ ∀n k. beta n k = 0 ⇔ k = 0 ∨ n &lt; k
   
   [<a name="beta_eqn-val"><b>beta_eqn</b></a>]  Theorem
      
      ⊢ ∀n k. beta (n + 1) (k + 1) = leibniz n k
   
   [<a name="beta_horizontal_0-val"><b>beta_horizontal_0</b></a>]  Theorem
      
      ⊢ beta_horizontal 0 = []
   
   [<a name="beta_horizontal_alt-val"><b>beta_horizontal_alt</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ beta_horizontal n = leibniz_horizontal (n − 1)
   
   [<a name="beta_horizontal_element-val"><b>beta_horizontal_element</b></a>]  Theorem
      
      ⊢ ∀n k. k &lt; n ⇒ EL k (beta_horizontal n) = beta n (k + 1)
   
   [<a name="beta_horizontal_eqn-val"><b>beta_horizontal_eqn</b></a>]  Theorem
      
      ⊢ ∀n. beta_horizontal (n + 1) = leibniz_horizontal n
   
   [<a name="beta_horizontal_len-val"><b>beta_horizontal_len</b></a>]  Theorem
      
      ⊢ ∀n. LENGTH (beta_horizontal n) = n
   
   [<a name="beta_horizontal_mem-val"><b>beta_horizontal_mem</b></a>]  Theorem
      
      ⊢ ∀n k. 0 &lt; k ∧ k ≤ n ⇒ MEM (beta n k) (beta_horizontal n)
   
   [<a name="beta_horizontal_mem_iff-val"><b>beta_horizontal_mem_iff</b></a>]  Theorem
      
      ⊢ ∀n k. MEM (beta n k) (beta_horizontal n) ⇔ 0 &lt; k ∧ k ≤ n
   
   [<a name="beta_horizontal_member-val"><b>beta_horizontal_member</b></a>]  Theorem
      
      ⊢ ∀n x. MEM x (beta_horizontal n) ⇔ ∃k. 0 &lt; k ∧ k ≤ n ∧ x = beta n k
   
   [<a name="beta_less_0-val"><b>beta_less_0</b></a>]  Theorem
      
      ⊢ ∀n k. n &lt; k ⇒ beta n k = 0
   
   [<a name="beta_n_0-val"><b>beta_n_0</b></a>]  Theorem
      
      ⊢ ∀n. beta n 0 = 0
   
   [<a name="beta_pos-val"><b>beta_pos</b></a>]  Theorem
      
      ⊢ ∀n k. 0 &lt; k ∧ k ≤ n ⇒ 0 &lt; beta n k
   
   [<a name="beta_sym-val"><b>beta_sym</b></a>]  Theorem
      
      ⊢ ∀n k. k ≤ n ⇒ beta n k = beta n (n − k + 1)
   
   [<a name="big_lcm_corner_transform-val"><b>big_lcm_corner_transform</b></a>]  Theorem
      
      ⊢ ∀n. big_lcm (leibniz_col (n + 1)) = big_lcm (leibniz_row n (n + 1))
   
   [<a name="big_lcm_count_lower_bound-val"><b>big_lcm_count_lower_bound</b></a>]  Theorem
      
      ⊢ ∀f n.
          (∀x. x ∈ count (n + 1) ⇒ 0 &lt; f x) ⇒
          SUM (GENLIST f (n + 1)) ≤
          (n + 1) * big_lcm (IMAGE f (count (n + 1)))
   
   [<a name="big_lcm_eq_list_lcm-val"><b>big_lcm_eq_list_lcm</b></a>]  Theorem
      
      ⊢ ∀l. big_lcm (set l) = list_lcm l
   
   [<a name="big_lcm_ge_max-val"><b>big_lcm_ge_max</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ∧ (∀x. x ∈ s ⇒ 0 &lt; x) ⇒ MAX_SET s ≤ big_lcm s
   
   [<a name="big_lcm_lower_bound-val"><b>big_lcm_lower_bound</b></a>]  Theorem
      
      ⊢ ∀n. 2 ** n ≤ big_lcm (natural (n + 1))
   
   [<a name="big_lcm_natural_eqn-val"><b>big_lcm_natural_eqn</b></a>]  Theorem
      
      ⊢ ∀n. big_lcm (natural (n + 1)) =
            (n + 1) * big_lcm (IMAGE (binomial n) (count (n + 1)))
   
   [<a name="big_lcm_non_decreasing-val"><b>big_lcm_non_decreasing</b></a>]  Theorem
      
      ⊢ ∀n. big_lcm (natural n) ≤ big_lcm (natural (n + 1))
   
   [<a name="big_lcm_row_transform-val"><b>big_lcm_row_transform</b></a>]  Theorem
      
      ⊢ ∀n h.
          lcm (leibniz (n + 1) 0) (big_lcm (leibniz_row n h)) =
          big_lcm (leibniz_row (n + 1) (h + 1))
   
   [<a name="big_lcm_seg_transform-val"><b>big_lcm_seg_transform</b></a>]  Theorem
      
      ⊢ ∀n k h.
          lcm (leibniz (n + 1) k) (big_lcm (leibniz_seg n k h)) =
          big_lcm (leibniz_seg (n + 1) k (h + 1))
   
   [<a name="bij_eq_card-val"><b>bij_eq_card</b></a>]  Theorem
      
      ⊢ ∀s t. s =b= t ∧ (FINITE s ∨ FINITE t) ⇒ CARD s = CARD t
   
   [<a name="bij_eq_card_eq-val"><b>bij_eq_card_eq</b></a>]  Theorem
      
      ⊢ ∀s t. FINITE s ∧ FINITE t ⇒ (s =b= t ⇔ CARD s = CARD t)
   
   [<a name="bij_eq_count-val"><b>bij_eq_count</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ s =b= count (CARD s)
   
   [<a name="bij_eq_empty-val"><b>bij_eq_empty</b></a>]  Theorem
      
      ⊢ ∀s t. s =b= t ⇒ (s = ∅ ⇔ t = ∅)
   
   [<a name="bij_eq_equiv_on-val"><b>bij_eq_equiv_on</b></a>]  Theorem
      
      ⊢ ∀P. (λs t. s =b= t) equiv_on P
   
   [<a name="bij_eq_finite-val"><b>bij_eq_finite</b></a>]  Theorem
      
      ⊢ ∀s t. s =b= t ⇒ (FINITE s ⇔ FINITE t)
   
   [<a name="bij_eq_refl-val"><b>bij_eq_refl</b></a>]  Theorem
      
      ⊢ ∀s. s =b= s
   
   [<a name="bij_eq_sym-val"><b>bij_eq_sym</b></a>]  Theorem
      
      ⊢ ∀s t. s =b= t ⇔ t =b= s
   
   [<a name="bij_eq_trans-val"><b>bij_eq_trans</b></a>]  Theorem
      
      ⊢ ∀s t u. s =b= t ∧ t =b= u ⇒ s =b= u
   
   [<a name="bij_iff_preimage_card_eq_1-val"><b>bij_iff_preimage_card_eq_1</b></a>]  Theorem
      
      ⊢ ∀f s t.
          FINITE s ∧ over f s t ⇒
          (BIJ f s t ⇔ ∀y. y ∈ t ⇒ CARD (preimage f s y) = 1)
   
   [<a name="bij_preimage_sing-val"><b>bij_preimage_sing</b></a>]  Theorem
      
      ⊢ ∀f s t. BIJ f s t ⇔ over f s t ∧ ∀y. y ∈ t ⇒ SING (preimage f s y)
   
   [<a name="binomial_0_n-val"><b>binomial_0_n</b></a>]  Theorem
      
      ⊢ ∀n. binomial 0 n = if n = 0 then 1 else 0
   
   [<a name="binomial_1_n-val"><b>binomial_1_n</b></a>]  Theorem
      
      ⊢ ∀n. binomial 1 n = if 1 &lt; n then 0 else 1
   
   [<a name="binomial_alt-val"><b>binomial_alt</b></a>]  Theorem
      
      ⊢ ∀n k.
          binomial n 0 = 1 ∧ binomial 0 (k + 1) = 0 ∧
          binomial (n + 1) (k + 1) = binomial n k + binomial n (k + 1)
   
   [<a name="binomial_compute-val"><b>binomial_compute</b></a>]  Theorem
      
      ⊢ binomial 0 0 = 1 ∧ (∀n. binomial (NUMERAL (BIT1 n)) 0 = 1) ∧
        (∀n. binomial (NUMERAL (BIT2 n)) 0 = 1) ∧
        (∀k. binomial 0 (NUMERAL (BIT1 k)) = 0) ∧
        (∀k. binomial 0 (NUMERAL (BIT2 k)) = 0) ∧
        (∀n k.
           binomial (NUMERAL (BIT1 n)) (NUMERAL (BIT1 k)) =
           binomial (NUMERAL (BIT1 n) − 1) (NUMERAL (BIT1 k) − 1) +
           binomial (NUMERAL (BIT1 n) − 1) (NUMERAL (BIT1 k))) ∧
        (∀n k.
           binomial (NUMERAL (BIT2 n)) (NUMERAL (BIT1 k)) =
           binomial (NUMERAL (BIT1 n)) (NUMERAL (BIT1 k) − 1) +
           binomial (NUMERAL (BIT1 n)) (NUMERAL (BIT1 k))) ∧
        (∀n k.
           binomial (NUMERAL (BIT1 n)) (NUMERAL (BIT2 k)) =
           binomial (NUMERAL (BIT1 n) − 1) (NUMERAL (BIT1 k)) +
           binomial (NUMERAL (BIT1 n) − 1) (NUMERAL (BIT2 k))) ∧
        ∀n k.
          binomial (NUMERAL (BIT2 n)) (NUMERAL (BIT2 k)) =
          binomial (NUMERAL (BIT1 n)) (NUMERAL (BIT1 k)) +
          binomial (NUMERAL (BIT1 n)) (NUMERAL (BIT2 k))
   
   [<a name="binomial_def-val"><b>binomial_def</b></a>]  Theorem
      
      ⊢ binomial 0 0 = 1 ∧ (∀n. binomial (SUC n) 0 = 1) ∧
        (∀k. binomial 0 (SUC k) = 0) ∧
        ∀n k. binomial (SUC n) (SUC k) = binomial n k + binomial n (SUC k)
   
   [<a name="binomial_eq_0-val"><b>binomial_eq_0</b></a>]  Theorem
      
      ⊢ ∀n k. binomial n k = 0 ⇔ n &lt; k
   
   [<a name="binomial_fact-val"><b>binomial_fact</b></a>]  Theorem
      
      ⊢ ∀n k. k ≤ n ⇒ binomial n k = FACT n DIV (FACT k * FACT (n − k))
   
   [<a name="binomial_formula-val"><b>binomial_formula</b></a>]  Theorem
      
      ⊢ ∀n k. binomial (n + k) k * (FACT n * FACT k) = FACT (n + k)
   
   [<a name="binomial_formula2-val"><b>binomial_formula2</b></a>]  Theorem
      
      ⊢ ∀n k. k ≤ n ⇒ FACT n = binomial n k * (FACT (n − k) * FACT k)
   
   [<a name="binomial_formula3-val"><b>binomial_formula3</b></a>]  Theorem
      
      ⊢ ∀n k. k ≤ n ⇒ binomial n k = FACT n DIV (FACT k * FACT (n − k))
   
   [<a name="binomial_horizontal_0-val"><b>binomial_horizontal_0</b></a>]  Theorem
      
      ⊢ binomial_horizontal 0 = [1]
   
   [<a name="binomial_horizontal_element-val"><b>binomial_horizontal_element</b></a>]  Theorem
      
      ⊢ ∀n k. k ≤ n ⇒ EL k (binomial_horizontal n) = binomial n k
   
   [<a name="binomial_horizontal_len-val"><b>binomial_horizontal_len</b></a>]  Theorem
      
      ⊢ ∀n. LENGTH (binomial_horizontal n) = n + 1
   
   [<a name="binomial_horizontal_max-val"><b>binomial_horizontal_max</b></a>]  Theorem
      
      ⊢ ∀n. MAX_LIST (binomial_horizontal n) = binomial n (HALF n)
   
   [<a name="binomial_horizontal_mem-val"><b>binomial_horizontal_mem</b></a>]  Theorem
      
      ⊢ ∀n k. k &lt; n + 1 ⇒ MEM (binomial n k) (binomial_horizontal n)
   
   [<a name="binomial_horizontal_mem_iff-val"><b>binomial_horizontal_mem_iff</b></a>]  Theorem
      
      ⊢ ∀n k. MEM (binomial n k) (binomial_horizontal n) ⇔ k ≤ n
   
   [<a name="binomial_horizontal_member-val"><b>binomial_horizontal_member</b></a>]  Theorem
      
      ⊢ ∀n x. MEM x (binomial_horizontal n) ⇔ ∃k. k ≤ n ∧ x = binomial n k
   
   [<a name="binomial_horizontal_pos-val"><b>binomial_horizontal_pos</b></a>]  Theorem
      
      ⊢ ∀n. EVERY_POSITIVE (binomial_horizontal n)
   
   [<a name="binomial_horizontal_pos_alt-val"><b>binomial_horizontal_pos_alt</b></a>]  Theorem
      
      ⊢ ∀n x. MEM x (binomial_horizontal n) ⇒ 0 &lt; x
   
   [<a name="binomial_horizontal_sum-val"><b>binomial_horizontal_sum</b></a>]  Theorem
      
      ⊢ ∀n. SUM (binomial_horizontal n) = 2 ** n
   
   [<a name="binomial_iff-val"><b>binomial_iff</b></a>]  Theorem
      
      ⊢ ∀f. f = binomial ⇔
            ∀n k.
              f n 0 = 1 ∧ f 0 (k + 1) = 0 ∧
              f (n + 1) (k + 1) = f n k + f n (k + 1)
   
   [<a name="binomial_ind-val"><b>binomial_ind</b></a>]  Theorem
      
      ⊢ ∀P. P 0 0 ∧ (∀n. P (SUC n) 0) ∧ (∀k. P 0 (SUC k)) ∧
            (∀n k. P n k ∧ P n (SUC k) ⇒ P (SUC n) (SUC k)) ⇒
            ∀v v1. P v v1
   
   [<a name="binomial_index_shift-val"><b>binomial_index_shift</b></a>]  Theorem
      
      ⊢ ∀n x y.
          (λk. binomial (SUC n) k * x ** (SUC n − k) * y ** k) ∘ SUC =
          (λk. binomial (SUC n) (SUC k) * x ** (n − k) * y ** SUC k)
   
   [<a name="binomial_is_integer-val"><b>binomial_is_integer</b></a>]  Theorem
      
      ⊢ ∀n k. k ≤ n ⇒ FACT k * FACT (n − k) divides FACT n
   
   [<a name="binomial_less_0-val"><b>binomial_less_0</b></a>]  Theorem
      
      ⊢ ∀n k. n &lt; k ⇒ binomial n k = 0
   
   [<a name="binomial_max-val"><b>binomial_max</b></a>]  Theorem
      
      ⊢ ∀n k. binomial n k ≤ binomial n (HALF n)
   
   [<a name="binomial_middle_by_stirling-val"><b>binomial_middle_by_stirling</b></a>]  Theorem
      
      ⊢ Stirling ⇒
        ∀n. 0 &lt; n ∧ EVEN n ⇒
            binomial n (HALF n) = 2 ** (n + 1) DIV SQRT (TWICE pi * n)
   
   [<a name="binomial_middle_upper_bound-val"><b>binomial_middle_upper_bound</b></a>]  Theorem
      
      ⊢ ∀n. binomial n (HALF n) ≤ 4 ** HALF n
   
   [<a name="binomial_mod_zero-val"><b>binomial_mod_zero</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒
            ∀k. binomial n k MOD n = 0 ⇔
                ∀x y. (binomial n k * x ** (n − k) * y ** k) MOD n = 0
   
   [<a name="binomial_mod_zero_alt-val"><b>binomial_mod_zero_alt</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒
            ((∀k. 0 &lt; k ∧ k &lt; n ⇒ binomial n k MOD n = 0) ⇔
             ∀x y.
               SUM
                 (GENLIST
                    ((λk. (binomial n k * x ** (n − k) * y ** k) MOD n) ∘
                     SUC) (PRE n)) =
               0)
   
   [<a name="binomial_monotone-val"><b>binomial_monotone</b></a>]  Theorem
      
      ⊢ ∀n k. k &lt; HALF n ⇒ binomial n k &lt; binomial n (k + 1)
   
   [<a name="binomial_n_0-val"><b>binomial_n_0</b></a>]  Theorem
      
      ⊢ ∀n. binomial n 0 = 1
   
   [<a name="binomial_n_1-val"><b>binomial_n_1</b></a>]  Theorem
      
      ⊢ ∀n. binomial n 1 = n
   
   [<a name="binomial_n_k-val"><b>binomial_n_k</b></a>]  Theorem
      
      ⊢ ∀n k. k ≤ n ⇒ binomial n k = FACT n DIV FACT k DIV FACT (n − k)
   
   [<a name="binomial_n_n-val"><b>binomial_n_n</b></a>]  Theorem
      
      ⊢ ∀n. binomial n n = 1
   
   [<a name="binomial_pos-val"><b>binomial_pos</b></a>]  Theorem
      
      ⊢ ∀n k. k ≤ n ⇒ 0 &lt; binomial n k
   
   [<a name="binomial_product_identity-val"><b>binomial_product_identity</b></a>]  Theorem
      
      ⊢ ∀m n k.
          k ≤ m ∧ m ≤ n ⇒
          binomial m k * binomial n m =
          binomial n k * binomial (n − k) (m − k)
   
   [<a name="binomial_range_shift-val"><b>binomial_range_shift</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒
            ((∀k. 0 &lt; k ∧ k &lt; n ⇒ binomial n k MOD n = 0) ⇔
             ∀h. h &lt; PRE n ⇒ binomial n (SUC h) MOD n = 0)
   
   [<a name="binomial_range_shift_alt-val"><b>binomial_range_shift_alt</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒
            ((∀k. 0 &lt; k ∧ k &lt; n ⇒
                  ∀x y. (binomial n k * x ** (n − k) * y ** k) MOD n = 0) ⇔
             ∀h. h &lt; PRE n ⇒
                 ∀x y.
                   (binomial n (SUC h) * x ** (n − SUC h) * y ** SUC h) MOD
                   n =
                   0)
   
   [<a name="binomial_recurrence-val"><b>binomial_recurrence</b></a>]  Theorem
      
      ⊢ ∀n k. binomial (SUC n) (SUC k) = binomial n k + binomial n (SUC k)
   
   [<a name="binomial_right-val"><b>binomial_right</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒
            ∀k. binomial n (k + 1) = (n − k) * binomial n k DIV (k + 1)
   
   [<a name="binomial_right_eqn-val"><b>binomial_right_eqn</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀k. beta n (k + 1) = (n − k) * binomial n k
   
   [<a name="binomial_row_max-val"><b>binomial_row_max</b></a>]  Theorem
      
      ⊢ ∀n. MAX_SET (IMAGE (binomial n) (count (n + 1))) =
            binomial n (HALF n)
   
   [<a name="binomial_sum-val"><b>binomial_sum</b></a>]  Theorem
      
      ⊢ ∀n. SUM (GENLIST (binomial n) (SUC n)) = 2 ** n
   
   [<a name="binomial_sum_alt-val"><b>binomial_sum_alt</b></a>]  Theorem
      
      ⊢ ∀n. SUM (binomial_horizontal n) = 2 ** n
   
   [<a name="binomial_sym-val"><b>binomial_sym</b></a>]  Theorem
      
      ⊢ ∀n k. k ≤ n ⇒ binomial n k = binomial n (n − k)
   
   [<a name="binomial_term_merge_x-val"><b>binomial_term_merge_x</b></a>]  Theorem
      
      ⊢ ∀n x y.
          (λk. x * k) ∘ (λk. binomial n k * x ** (n − k) * y ** k) =
          (λk. binomial n k * x ** SUC (n − k) * y ** k)
   
   [<a name="binomial_term_merge_y-val"><b>binomial_term_merge_y</b></a>]  Theorem
      
      ⊢ ∀n x y.
          (λk. y * k) ∘ (λk. binomial n k * x ** (n − k) * y ** k) =
          (λk. binomial n k * x ** (n − k) * y ** SUC k)
   
   [<a name="binomial_thm-val"><b>binomial_thm</b></a>]  Theorem
      
      ⊢ ∀n x y.
          (x + y) ** n =
          SUM (GENLIST (λk. binomial n k * x ** (n − k) * y ** k) (SUC n))
   
   [<a name="binomial_thm_alt-val"><b>binomial_thm_alt</b></a>]  Theorem
      
      ⊢ ∀n x y.
          (x + y) ** n =
          SUM (GENLIST (λk. binomial n k * x ** (n − k) * y ** k) (n + 1))
   
   [<a name="binomial_thm_prime-val"><b>binomial_thm_prime</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇒ ∀x y. (x + y) ** p MOD p = (x ** p + y ** p) MOD p
   
   [<a name="binomial_up-val"><b>binomial_up</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀k. binomial (n − 1) k = (n − k) * binomial n k DIV n
   
   [<a name="binomial_up_eqn-val"><b>binomial_up_eqn</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀k. n * binomial (n − 1) k = (n − k) * binomial n k
   
   [<a name="choose_0_n-val"><b>choose_0_n</b></a>]  Theorem
      
      ⊢ ∀n. 0 choose n = if n = 0 then 1 else 0
   
   [<a name="choose_1_n-val"><b>choose_1_n</b></a>]  Theorem
      
      ⊢ ∀n. 1 choose n = if 1 &lt; n then 0 else 1
   
   [<a name="choose_alt-val"><b>choose_alt</b></a>]  Theorem
      
      ⊢ ∀n k.
          n choose 0 = 1 ∧ 0 choose (k + 1) = 0 ∧
          (n + 1) choose (k + 1) = n choose k + n choose (k + 1)
   
   [<a name="choose_eq_0-val"><b>choose_eq_0</b></a>]  Theorem
      
      ⊢ ∀n k. n choose k = 0 ⇔ n &lt; k
   
   [<a name="choose_eqn-val"><b>choose_eqn</b></a>]  Theorem
      
      ⊢ ∀n k. n choose k = binomial n k
   
   [<a name="choose_n_0-val"><b>choose_n_0</b></a>]  Theorem
      
      ⊢ ∀n. n choose 0 = 1
   
   [<a name="choose_n_1-val"><b>choose_n_1</b></a>]  Theorem
      
      ⊢ ∀n. n choose 1 = n
   
   [<a name="choose_n_n-val"><b>choose_n_n</b></a>]  Theorem
      
      ⊢ ∀n. n choose n = 1
   
   [<a name="choose_recurrence-val"><b>choose_recurrence</b></a>]  Theorem
      
      ⊢ ∀n k. (n + 1) choose (k + 1) = n choose k + n choose (k + 1)
   
   [<a name="choose_sum_over_all-val"><b>choose_sum_over_all</b></a>]  Theorem
      
      ⊢ ∀n. SUM (MAP ($choose n) [0 .. n]) = 2 ** n
   
   [<a name="choose_sum_over_count-val"><b>choose_sum_over_count</b></a>]  Theorem
      
      ⊢ ∀n. ∑ ($choose n) (upto n) = 2 ** n
   
   [<a name="count_power_partition-val"><b>count_power_partition</b></a>]  Theorem
      
      ⊢ ∀n. partition (λs t. s =b= t) (POW (count n)) =
            IMAGE (sub_count n) (upto n)
   
   [<a name="datatype_triple-val"><b>datatype_triple</b></a>]  Theorem
      
      ⊢ DATATYPE (record triple a b c)
   
   [<a name="divides_binomials_imp_prime-val"><b>divides_binomials_imp_prime</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ∧ (∀k. 0 &lt; k ∧ k &lt; n ⇒ n divides binomial n k) ⇒ prime n
   
   [<a name="feq_set_equiv-val"><b>feq_set_equiv</b></a>]  Theorem
      
      ⊢ ∀s. feq set equiv_on s
   
   [<a name="finite_surj_inj_iff-val"><b>finite_surj_inj_iff</b></a>]  Theorem
      
      ⊢ ∀f s t.
          FINITE s ∧ SURJ f s t ⇒
          (INJ f s t ⇔ ∀e. e ∈ IMAGE (preimage f s) t ⇒ CARD e = 1)
   
   [<a name="gcd_prime_product_property-val"><b>gcd_prime_product_property</b></a>]  Theorem
      
      ⊢ ∀p m n.
          prime p ∧ m divides n ∧ ¬(p * m divides n) ⇒ gcd (p * m) n = m
   
   [<a name="geometric_sum_eqn-val"><b>geometric_sum_eqn</b></a>]  Theorem
      
      ⊢ ∀t n.
          1 &lt; t ⇒ SUM (MAP (λj. t ** j) [0 ..&lt; n]) = tops t n DIV (t − 1)
   
   [<a name="geometric_sum_eqn_alt-val"><b>geometric_sum_eqn_alt</b></a>]  Theorem
      
      ⊢ ∀t n.
          1 &lt; t ⇒
          SUM (MAP (λj. t ** j) [0 .. n]) = tops t (n + 1) DIV (t − 1)
   
   [<a name="head_turn-val"><b>head_turn</b></a>]  Theorem
      
      ⊢ ∀ls. ls ≠ [] ⇒ HD (turn ls) = LAST ls
   
   [<a name="head_turn_exp-val"><b>head_turn_exp</b></a>]  Theorem
      
      ⊢ ∀ls n.
          n &lt; LENGTH ls ⇒
          HD (turn_exp ls n) = EL (if n = 0 then 0 else (LENGTH ls − n)) ls
   
   [<a name="inj_iff_preimage_card_le_1-val"><b>inj_iff_preimage_card_le_1</b></a>]  Theorem
      
      ⊢ ∀f s t.
          FINITE s ∧ over f s t ⇒
          (INJ f s t ⇔ ∀y. y ∈ t ⇒ CARD (preimage f s y) ≤ 1)
   
   [<a name="inj_preimage_empty_or_sing-val"><b>inj_preimage_empty_or_sing</b></a>]  Theorem
      
      ⊢ ∀f s t.
          INJ f s t ⇔
          over f s t ∧
          ∀y. y ∈ t ⇒ preimage f s y = ∅ ∨ SING (preimage f s y)
   
   [<a name="interleave_alt-val"><b>interleave_alt</b></a>]  Theorem
      
      ⊢ ∀ls x.
          x interleave ls = {TAKE k ls ⧺ x::DROP k ls | k | k ≤ LENGTH ls}
   
   [<a name="interleave_card-val"><b>interleave_card</b></a>]  Theorem
      
      ⊢ ∀ls x. ¬MEM x ls ⇒ CARD (x interleave ls) = 1 + LENGTH ls
   
   [<a name="interleave_count_inj-val"><b>interleave_count_inj</b></a>]  Theorem
      
      ⊢ ∀ls x.
          ¬MEM x ls ⇒
          INJ (λk. TAKE k ls ⧺ x::DROP k ls) (upto (LENGTH ls)) 𝕌(:α list)
   
   [<a name="interleave_disjoint-val"><b>interleave_disjoint</b></a>]  Theorem
      
      ⊢ ∀l1 l2 x.
          ¬MEM x l1 ∧ l1 ≠ l2 ⇒
          DISJOINT (x interleave l1) (x interleave l2)
   
   [<a name="interleave_distinct-val"><b>interleave_distinct</b></a>]  Theorem
      
      ⊢ ∀ls x y.
          ALL_DISTINCT (x::ls) ∧ y ∈ x interleave ls ⇒ ALL_DISTINCT y
   
   [<a name="interleave_distinct_alt-val"><b>interleave_distinct_alt</b></a>]  Theorem
      
      ⊢ ∀ls x y.
          ALL_DISTINCT ls ∧ ¬MEM x ls ∧ y ∈ x interleave ls ⇒
          ALL_DISTINCT y
   
   [<a name="interleave_element-val"><b>interleave_element</b></a>]  Theorem
      
      ⊢ ∀ls x y.
          y ∈ x interleave ls ⇔
          ∃k. k ≤ LENGTH ls ∧ y = TAKE k ls ⧺ x::DROP k ls
   
   [<a name="interleave_eq-val"><b>interleave_eq</b></a>]  Theorem
      
      ⊢ ∀n x y.
          ¬MEM n x ∧ ¬MEM n y ⇒ (n interleave x = n interleave y ⇔ x = y)
   
   [<a name="interleave_finite-val"><b>interleave_finite</b></a>]  Theorem
      
      ⊢ ∀ls x. FINITE (x interleave ls)
   
   [<a name="interleave_has_cons-val"><b>interleave_has_cons</b></a>]  Theorem
      
      ⊢ ∀ls x. x::ls ∈ x interleave ls
   
   [<a name="interleave_length-val"><b>interleave_length</b></a>]  Theorem
      
      ⊢ ∀ls x y. y ∈ x interleave ls ⇒ LENGTH y = 1 + LENGTH ls
   
   [<a name="interleave_nil-val"><b>interleave_nil</b></a>]  Theorem
      
      ⊢ ∀x. x interleave [] = {[x]}
   
   [<a name="interleave_not_empty-val"><b>interleave_not_empty</b></a>]  Theorem
      
      ⊢ ∀ls x. x interleave ls ≠ ∅
   
   [<a name="interleave_revert-val"><b>interleave_revert</b></a>]  Theorem
      
      ⊢ ∀ls h.
          ALL_DISTINCT ls ∧ MEM h ls ⇒
          ∃t. ALL_DISTINCT t ∧ ls ∈ h interleave t ∧
              set t = set ls DELETE h
   
   [<a name="interleave_revert_count-val"><b>interleave_revert_count</b></a>]  Theorem
      
      ⊢ ∀ls n.
          ALL_DISTINCT ls ∧ set ls = upto n ⇒
          ∃t. ALL_DISTINCT t ∧ ls ∈ n interleave t ∧ set t = count n
   
   [<a name="interleave_set-val"><b>interleave_set</b></a>]  Theorem
      
      ⊢ ∀ls x y. y ∈ x interleave ls ⇒ set y = set (x::ls)
   
   [<a name="interleave_set_alt-val"><b>interleave_set_alt</b></a>]  Theorem
      
      ⊢ ∀ls x y. y ∈ x interleave ls ⇒ set y = x INSERT set ls
   
   [<a name="lcm_lower_bound-val"><b>lcm_lower_bound</b></a>]  Theorem
      
      ⊢ ∀n. 2 ** n ≤ lcm_run (n + 1)
   
   [<a name="lcm_lower_bound_by_big_lcm-val"><b>lcm_lower_bound_by_big_lcm</b></a>]  Theorem
      
      ⊢ ∀n. (n + 1) * binomial n (HALF n) ≤ big_lcm (natural (n + 1))
   
   [<a name="lcm_lower_bound_by_big_lcm_stirling-val"><b>lcm_lower_bound_by_big_lcm_stirling</b></a>]  Theorem
      
      ⊢ Stirling ∧ (∀n c. n DIV SQRT (c * (n − 1)) = SQRT (n DIV c)) ⇒
        ∀n. ODD n ⇒ SQRT (n DIV TWICE pi) * 2 ** n ≤ big_lcm (natural n)
   
   [<a name="lcm_lower_bound_by_list_lcm-val"><b>lcm_lower_bound_by_list_lcm</b></a>]  Theorem
      
      ⊢ ∀n. (n + 1) * binomial n (HALF n) ≤ lcm_run (n + 1)
   
   [<a name="lcm_lower_bound_by_list_lcm_stirling-val"><b>lcm_lower_bound_by_list_lcm_stirling</b></a>]  Theorem
      
      ⊢ Stirling ∧ (∀n c. n DIV SQRT (c * (n − 1)) = SQRT (n DIV c)) ⇒
        ∀n. ODD n ⇒ SQRT (n DIV TWICE pi) * 2 ** n ≤ lcm_run n
   
   [<a name="lcm_prime_product_property-val"><b>lcm_prime_product_property</b></a>]  Theorem
      
      ⊢ ∀p m n.
          prime p ∧ m divides n ∧ ¬(p * m divides n) ⇒
          lcm (p * m) n = p * n
   
   [<a name="lcm_run_0-val"><b>lcm_run_0</b></a>]  Theorem
      
      ⊢ lcm_run 0 = 1
   
   [<a name="lcm_run_1-val"><b>lcm_run_1</b></a>]  Theorem
      
      ⊢ lcm_run 1 = 1
   
   [<a name="lcm_run_alt-val"><b>lcm_run_alt</b></a>]  Theorem
      
      ⊢ ∀n. lcm_run n = lcm_run (n − 1 + 1)
   
   [<a name="lcm_run_beta_divisor-val"><b>lcm_run_beta_divisor</b></a>]  Theorem
      
      ⊢ ∀n k. 0 &lt; k ∧ k ≤ n ⇒ beta n k divides lcm_run n
   
   [<a name="lcm_run_bound_recurrence-val"><b>lcm_run_bound_recurrence</b></a>]  Theorem
      
      ⊢ ∀m n. n ≤ TWICE m ∧ m ≤ n ⇒ lcm_run n ≤ lcm_run m * binomial n m
   
   [<a name="lcm_run_by_FOLDL-val"><b>lcm_run_by_FOLDL</b></a>]  Theorem
      
      ⊢ ∀n. lcm_run n = FOLDL lcm 1 [1 .. n]
   
   [<a name="lcm_run_by_FOLDR-val"><b>lcm_run_by_FOLDR</b></a>]  Theorem
      
      ⊢ ∀n. lcm_run n = FOLDR lcm 1 [1 .. n]
   
   [<a name="lcm_run_by_beta_horizontal-val"><b>lcm_run_by_beta_horizontal</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ lcm_run n = list_lcm (beta_horizontal n)
   
   [<a name="lcm_run_divides_property-val"><b>lcm_run_divides_property</b></a>]  Theorem
      
      ⊢ ∀m n.
          n ≤ TWICE m ∧ m ≤ n ⇒ lcm_run n divides lcm_run m * binomial n m
   
   [<a name="lcm_run_divides_property_alt-val"><b>lcm_run_divides_property_alt</b></a>]  Theorem
      
      ⊢ ∀m n.
          n ≤ TWICE m ∧ m ≤ n ⇒ lcm_run n divides binomial n m * lcm_run m
   
   [<a name="lcm_run_divisors-val"><b>lcm_run_divisors</b></a>]  Theorem
      
      ⊢ ∀n. n + 1 divides lcm_run (n + 1) ∧
            lcm_run n divides lcm_run (n + 1)
   
   [<a name="lcm_run_even_lower-val"><b>lcm_run_even_lower</b></a>]  Theorem
      
      ⊢ ∀n. EVEN n ⇒ HALF (n − 2) * HALF (HALF (2 ** n)) ≤ lcm_run n
   
   [<a name="lcm_run_even_lower_alt-val"><b>lcm_run_even_lower_alt</b></a>]  Theorem
      
      ⊢ ∀n. EVEN n ∧ 8 ≤ n ⇒ 2 ** n ≤ lcm_run n
   
   [<a name="lcm_run_leibniz_divisor-val"><b>lcm_run_leibniz_divisor</b></a>]  Theorem
      
      ⊢ ∀n k. k ≤ n ⇒ leibniz n k divides lcm_run (n + 1)
   
   [<a name="lcm_run_lower-val"><b>lcm_run_lower</b></a>]  Theorem
      
      ⊢ ∀n. 2 ** n ≤ lcm_run (n + 1)
   
   [<a name="lcm_run_lower_better-val"><b>lcm_run_lower_better</b></a>]  Theorem
      
      ⊢ ∀n. 7 ≤ n ⇒ 2 ** n ≤ lcm_run n
   
   [<a name="lcm_run_lower_better_iff-val"><b>lcm_run_lower_better_iff</b></a>]  Theorem
      
      ⊢ ∀n. 2 ** n ≤ lcm_run n ⇔ n = 0 ∨ n = 5 ∨ 7 ≤ n
   
   [<a name="lcm_run_lower_even-val"><b>lcm_run_lower_even</b></a>]  Theorem
      
      ⊢ ∀n. n * 4 ** n ≤ lcm_run (TWICE (n + 1))
   
   [<a name="lcm_run_lower_even_iff-val"><b>lcm_run_lower_even_iff</b></a>]  Theorem
      
      ⊢ ∀n. EVEN n ⇒ (2 ** n ≤ lcm_run n ⇔ n = 0 ∨ 8 ≤ n)
   
   [<a name="lcm_run_lower_good-val"><b>lcm_run_lower_good</b></a>]  Theorem
      
      ⊢ ∀n. 2 ** (n − 1) ≤ lcm_run n
   
   [<a name="lcm_run_lower_odd-val"><b>lcm_run_lower_odd</b></a>]  Theorem
      
      ⊢ ∀n. n * 4 ** n ≤ lcm_run (TWICE n + 1)
   
   [<a name="lcm_run_lower_odd_iff-val"><b>lcm_run_lower_odd_iff</b></a>]  Theorem
      
      ⊢ ∀n. ODD n ⇒ (2 ** n ≤ lcm_run n ⇔ 5 ≤ n)
   
   [<a name="lcm_run_lower_simple-val"><b>lcm_run_lower_simple</b></a>]  Theorem
      
      ⊢ ∀n. HALF (n + 1) ≤ lcm_run n
   
   [<a name="lcm_run_monotone-val"><b>lcm_run_monotone</b></a>]  Theorem
      
      ⊢ ∀n. lcm_run n ≤ lcm_run (n + 1)
   
   [<a name="lcm_run_odd_factor-val"><b>lcm_run_odd_factor</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ n * leibniz (TWICE n) n divides lcm_run (TWICE n + 1)
   
   [<a name="lcm_run_odd_lower-val"><b>lcm_run_odd_lower</b></a>]  Theorem
      
      ⊢ ∀n. ODD n ⇒ HALF n * HALF (2 ** n) ≤ lcm_run n
   
   [<a name="lcm_run_odd_lower_alt-val"><b>lcm_run_odd_lower_alt</b></a>]  Theorem
      
      ⊢ ∀n. ODD n ∧ 5 ≤ n ⇒ 2 ** n ≤ lcm_run n
   
   [<a name="lcm_run_pos-val"><b>lcm_run_pos</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; lcm_run n
   
   [<a name="lcm_run_small-val"><b>lcm_run_small</b></a>]  Theorem
      
      ⊢ lcm_run 2 = 2 ∧ lcm_run 3 = 6 ∧ lcm_run 4 = 12 ∧ lcm_run 5 = 60 ∧
        lcm_run 6 = 60 ∧ lcm_run 7 = 420 ∧ lcm_run 8 = 840 ∧
        lcm_run 9 = 2520
   
   [<a name="lcm_run_suc-val"><b>lcm_run_suc</b></a>]  Theorem
      
      ⊢ ∀n. lcm_run (n + 1) = lcm (n + 1) (lcm_run n)
   
   [<a name="lcm_run_upper_bound-val"><b>lcm_run_upper_bound</b></a>]  Theorem
      
      ⊢ ∀n. lcm_run n ≤ 4 ** n
   
   [<a name="lcm_upto_0-val"><b>lcm_upto_0</b></a>]  Theorem
      
      ⊢ lcm_upto 0 = 1
   
   [<a name="lcm_upto_1-val"><b>lcm_upto_1</b></a>]  Theorem
      
      ⊢ lcm_upto 1 = 1
   
   [<a name="lcm_upto_SUC-val"><b>lcm_upto_SUC</b></a>]  Theorem
      
      ⊢ ∀n. lcm_upto (SUC n) = lcm (SUC n) (lcm_upto n)
   
   [<a name="lcm_upto_alt-val"><b>lcm_upto_alt</b></a>]  Theorem
      
      ⊢ lcm_upto 0 = 1 ∧ ∀n. lcm_upto (n + 1) = lcm (n + 1) (lcm_upto n)
   
   [<a name="lcm_upto_compute-val"><b>lcm_upto_compute</b></a>]  Theorem
      
      ⊢ lcm_upto 0 = 1 ∧
        (∀n. lcm_upto (NUMERAL (BIT1 n)) =
             lcm (NUMERAL (BIT1 n)) (lcm_upto (NUMERAL (BIT1 n) − 1))) ∧
        ∀n. lcm_upto (NUMERAL (BIT2 n)) =
            lcm (NUMERAL (BIT2 n)) (lcm_upto (NUMERAL (BIT1 n)))
   
   [<a name="lcm_upto_divisors-val"><b>lcm_upto_divisors</b></a>]  Theorem
      
      ⊢ ∀n. n + 1 divides lcm_upto (n + 1) ∧
            lcm_upto n divides lcm_upto (n + 1)
   
   [<a name="lcm_upto_eq_list_lcm-val"><b>lcm_upto_eq_list_lcm</b></a>]  Theorem
      
      ⊢ ∀n. lcm_upto n = lcm_run n
   
   [<a name="lcm_upto_leibniz_divisor-val"><b>lcm_upto_leibniz_divisor</b></a>]  Theorem
      
      ⊢ ∀n k. k ≤ n ⇒ leibniz n k divides lcm_upto (n + 1)
   
   [<a name="lcm_upto_lower-val"><b>lcm_upto_lower</b></a>]  Theorem
      
      ⊢ ∀n. 2 ** n ≤ lcm_upto (n + 1)
   
   [<a name="lcm_upto_lower_better-val"><b>lcm_upto_lower_better</b></a>]  Theorem
      
      ⊢ ∀n. 7 ≤ n ⇒ 2 ** n ≤ lcm_upto n
   
   [<a name="lcm_upto_lower_even-val"><b>lcm_upto_lower_even</b></a>]  Theorem
      
      ⊢ ∀n. n * 4 ** n ≤ lcm_upto (TWICE (n + 1))
   
   [<a name="lcm_upto_lower_odd-val"><b>lcm_upto_lower_odd</b></a>]  Theorem
      
      ⊢ ∀n. n * 4 ** n ≤ lcm_upto (TWICE n + 1)
   
   [<a name="lcm_upto_monotone-val"><b>lcm_upto_monotone</b></a>]  Theorem
      
      ⊢ ∀n. lcm_upto n ≤ lcm_upto (n + 1)
   
   [<a name="lcm_upto_pos-val"><b>lcm_upto_pos</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; lcm_upto (n + 1)
   
   [<a name="lcm_upto_small-val"><b>lcm_upto_small</b></a>]  Theorem
      
      ⊢ lcm_upto 2 = 2 ∧ lcm_upto 3 = 6 ∧ lcm_upto 4 = 12 ∧
        lcm_upto 5 = 60 ∧ lcm_upto 6 = 60 ∧ lcm_upto 7 = 420 ∧
        lcm_upto 8 = 840 ∧ lcm_upto 9 = 2520 ∧ lcm_upto 10 = 2520
   
   [<a name="leibniz_0_n-val"><b>leibniz_0_n</b></a>]  Theorem
      
      ⊢ ∀n. leibniz 0 n = if n = 0 then 1 else 0
   
   [<a name="leibniz_alt-val"><b>leibniz_alt</b></a>]  Theorem
      
      ⊢ ∀n. leibniz n = (λj. (n + 1) * j) ∘ binomial n
   
   [<a name="leibniz_binomial_identity-val"><b>leibniz_binomial_identity</b></a>]  Theorem
      
      ⊢ ∀m n k.
          k ≤ m ∧ m ≤ n ⇒
          leibniz n k * binomial (n − k) (m − k) =
          leibniz m k * binomial (n + 1) (m + 1)
   
   [<a name="leibniz_col_arm_0-val"><b>leibniz_col_arm_0</b></a>]  Theorem
      
      ⊢ ∀a b. leibniz_col_arm a b 0 = []
   
   [<a name="leibniz_col_arm_1-val"><b>leibniz_col_arm_1</b></a>]  Theorem
      
      ⊢ ∀a b. leibniz_col_arm a b 1 = [leibniz a b]
   
   [<a name="leibniz_col_arm_cons-val"><b>leibniz_col_arm_cons</b></a>]  Theorem
      
      ⊢ ∀a b n.
          leibniz_col_arm (a + 1) b (n + 1) =
          leibniz (a + 1) b::leibniz_col_arm a b n
   
   [<a name="leibniz_col_arm_el-val"><b>leibniz_col_arm_el</b></a>]  Theorem
      
      ⊢ ∀n k.
          k &lt; n ⇒ ∀a b. EL k (leibniz_col_arm a b n) = leibniz (a − k) b
   
   [<a name="leibniz_col_arm_len-val"><b>leibniz_col_arm_len</b></a>]  Theorem
      
      ⊢ ∀a b n. LENGTH (leibniz_col_arm a b n) = n
   
   [<a name="leibniz_col_arm_n_0-val"><b>leibniz_col_arm_n_0</b></a>]  Theorem
      
      ⊢ ∀n. leibniz_col_arm n 0 (n + 1) = leibniz_up n
   
   [<a name="leibniz_col_arm_wriggle_row_arm-val"><b>leibniz_col_arm_wriggle_row_arm</b></a>]  Theorem
      
      ⊢ ∀a b n.
          b ≤ a ∧ n ≤ a + 1 − b ⇒
          leibniz_col_arm a b n wriggle leibniz_seg_arm a b n
   
   [<a name="leibniz_col_def-val"><b>leibniz_col_def</b></a>]  Theorem
      
      ⊢ ∀h. leibniz_col h = {leibniz j 0 | j ∈ count h}
   
   [<a name="leibniz_col_eq_natural-val"><b>leibniz_col_eq_natural</b></a>]  Theorem
      
      ⊢ ∀n. leibniz_col n = natural n
   
   [<a name="leibniz_def_alt-val"><b>leibniz_def_alt</b></a>]  Theorem
      
      ⊢ ∀n k. leibniz n k = (λj. (n + 1) * j) (binomial n k)
   
   [<a name="leibniz_divides_leibniz_factor-val"><b>leibniz_divides_leibniz_factor</b></a>]  Theorem
      
      ⊢ ∀m n k.
          k ≤ m ∧ m ≤ n ⇒
          leibniz n k divides leibniz m k * binomial (n + 1) (m + 1)
   
   [<a name="leibniz_eq_0-val"><b>leibniz_eq_0</b></a>]  Theorem
      
      ⊢ ∀n k. leibniz n k = 0 ⇔ n &lt; k
   
   [<a name="leibniz_eqn-val"><b>leibniz_eqn</b></a>]  Theorem
      
      ⊢ ∀n k. leibniz n k = (n + 1 − k) * binomial (n + 1) k
   
   [<a name="leibniz_formula-val"><b>leibniz_formula</b></a>]  Theorem
      
      ⊢ ∀n k.
          k ≤ n ⇒
          leibniz n k = (n + 1) * FACT n DIV (FACT k * FACT (n − k))
   
   [<a name="leibniz_horizontal_0-val"><b>leibniz_horizontal_0</b></a>]  Theorem
      
      ⊢ leibniz_horizontal 0 = [1]
   
   [<a name="leibniz_horizontal_alt-val"><b>leibniz_horizontal_alt</b></a>]  Theorem
      
      ⊢ ∀n. leibniz_horizontal n =
            MAP (λj. (n + 1) * j) (binomial_horizontal n)
   
   [<a name="leibniz_horizontal_average-val"><b>leibniz_horizontal_average</b></a>]  Theorem
      
      ⊢ ∀n. SUM (leibniz_horizontal n) DIV LENGTH (leibniz_horizontal n) =
            SUM (binomial_horizontal n)
   
   [<a name="leibniz_horizontal_average_eqn-val"><b>leibniz_horizontal_average_eqn</b></a>]  Theorem
      
      ⊢ ∀n. SUM (leibniz_horizontal n) DIV LENGTH (leibniz_horizontal n) =
            2 ** n
   
   [<a name="leibniz_horizontal_divisor-val"><b>leibniz_horizontal_divisor</b></a>]  Theorem
      
      ⊢ ∀n k. k ≤ n ⇒ leibniz n k divides list_lcm (leibniz_horizontal n)
   
   [<a name="leibniz_horizontal_el-val"><b>leibniz_horizontal_el</b></a>]  Theorem
      
      ⊢ ∀n k. k ≤ n ⇒ EL k (leibniz_horizontal n) = leibniz n k
   
   [<a name="leibniz_horizontal_element-val"><b>leibniz_horizontal_element</b></a>]  Theorem
      
      ⊢ ∀n k. k ≤ n ⇒ EL k (leibniz_horizontal n) = leibniz n k
   
   [<a name="leibniz_horizontal_head-val"><b>leibniz_horizontal_head</b></a>]  Theorem
      
      ⊢ ∀n. TAKE 1 (leibniz_horizontal (n + 1)) = [n + 2]
   
   [<a name="leibniz_horizontal_lcm_alt-val"><b>leibniz_horizontal_lcm_alt</b></a>]  Theorem
      
      ⊢ ∀n. list_lcm (leibniz_horizontal n) =
            (n + 1) * list_lcm (binomial_horizontal n)
   
   [<a name="leibniz_horizontal_lcm_lower-val"><b>leibniz_horizontal_lcm_lower</b></a>]  Theorem
      
      ⊢ ∀n. 2 ** n ≤ list_lcm (leibniz_horizontal n)
   
   [<a name="leibniz_horizontal_len-val"><b>leibniz_horizontal_len</b></a>]  Theorem
      
      ⊢ ∀n. LENGTH (leibniz_horizontal n) = n + 1
   
   [<a name="leibniz_horizontal_mem-val"><b>leibniz_horizontal_mem</b></a>]  Theorem
      
      ⊢ ∀n k. k ≤ n ⇒ MEM (leibniz n k) (leibniz_horizontal n)
   
   [<a name="leibniz_horizontal_mem_iff-val"><b>leibniz_horizontal_mem_iff</b></a>]  Theorem
      
      ⊢ ∀n k. MEM (leibniz n k) (leibniz_horizontal n) ⇔ k ≤ n
   
   [<a name="leibniz_horizontal_member-val"><b>leibniz_horizontal_member</b></a>]  Theorem
      
      ⊢ ∀n x. MEM x (leibniz_horizontal n) ⇔ ∃k. k ≤ n ∧ x = leibniz n k
   
   [<a name="leibniz_horizontal_member_divides-val"><b>leibniz_horizontal_member_divides</b></a>]  Theorem
      
      ⊢ ∀m n x.
          n ≤ TWICE m + 1 ∧ m ≤ n ∧ MEM x (leibniz_horizontal n) ⇒
          x divides
          list_lcm (leibniz_horizontal m) * binomial (n + 1) (m + 1)
   
   [<a name="leibniz_horizontal_pos-val"><b>leibniz_horizontal_pos</b></a>]  Theorem
      
      ⊢ ∀n. EVERY_POSITIVE (leibniz_horizontal n)
   
   [<a name="leibniz_horizontal_pos_alt-val"><b>leibniz_horizontal_pos_alt</b></a>]  Theorem
      
      ⊢ ∀n x. MEM x (leibniz_horizontal n) ⇒ 0 &lt; x
   
   [<a name="leibniz_horizontal_sum-val"><b>leibniz_horizontal_sum</b></a>]  Theorem
      
      ⊢ ∀n. SUM (leibniz_horizontal n) =
            (n + 1) * SUM (binomial_horizontal n)
   
   [<a name="leibniz_horizontal_sum_eqn-val"><b>leibniz_horizontal_sum_eqn</b></a>]  Theorem
      
      ⊢ ∀n. SUM (leibniz_horizontal n) = (n + 1) * 2 ** n
   
   [<a name="leibniz_horizontal_wriggle-val"><b>leibniz_horizontal_wriggle</b></a>]  Theorem
      
      ⊢ ∀n. [leibniz (n + 1) 0] ⧺ leibniz_horizontal n wriggle
            leibniz_horizontal (n + 1)
   
   [<a name="leibniz_horizontal_wriggle_step-val"><b>leibniz_horizontal_wriggle_step</b></a>]  Theorem
      
      ⊢ ∀n k.
          k ≤ n + 1 ⇒
          TAKE (k + 1) (leibniz_horizontal (n + 1)) ⧺
          DROP k (leibniz_horizontal n) wriggle leibniz_horizontal (n + 1)
   
   [<a name="leibniz_horizontal_zigzag-val"><b>leibniz_horizontal_zigzag</b></a>]  Theorem
      
      ⊢ ∀n k.
          k ≤ n ⇒
          TAKE (k + 1) (leibniz_horizontal (n + 1)) ⧺
          DROP k (leibniz_horizontal n) zigzag
          TAKE (k + 2) (leibniz_horizontal (n + 1)) ⧺
          DROP (k + 1) (leibniz_horizontal n)
   
   [<a name="leibniz_lcm_exchange-val"><b>leibniz_lcm_exchange</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒
            ∀k. lcm (leibniz n k) (leibniz (n − 1) k) =
                lcm (leibniz n k) (leibniz n (k + 1))
   
   [<a name="leibniz_lcm_invariance-val"><b>leibniz_lcm_invariance</b></a>]  Theorem
      
      ⊢ ∀a b n.
          b ≤ a ∧ n ≤ a + 1 − b ⇒
          list_lcm (leibniz_col_arm a b n) =
          list_lcm (leibniz_seg_arm a b n)
   
   [<a name="leibniz_lcm_property-val"><b>leibniz_lcm_property</b></a>]  Theorem
      
      ⊢ ∀n. lcm_run (n + 1) = list_lcm (leibniz_horizontal n)
   
   [<a name="leibniz_less_0-val"><b>leibniz_less_0</b></a>]  Theorem
      
      ⊢ ∀n k. n &lt; k ⇒ leibniz n k = 0
   
   [<a name="leibniz_middle_lower-val"><b>leibniz_middle_lower</b></a>]  Theorem
      
      ⊢ ∀n. 4 ** n ≤ leibniz (TWICE n) n
   
   [<a name="leibniz_monotone-val"><b>leibniz_monotone</b></a>]  Theorem
      
      ⊢ ∀n k. k &lt; HALF n ⇒ leibniz n k &lt; leibniz n (k + 1)
   
   [<a name="leibniz_n_0-val"><b>leibniz_n_0</b></a>]  Theorem
      
      ⊢ ∀n. leibniz n 0 = n + 1
   
   [<a name="leibniz_n_k-val"><b>leibniz_n_k</b></a>]  Theorem
      
      ⊢ ∀n k.
          0 &lt; k ∧ k ≤ n ⇒
          leibniz n k =
          leibniz n (k − 1) * leibniz (n − 1) (k − 1) DIV
          (leibniz n (k − 1) − leibniz (n − 1) (k − 1))
   
   [<a name="leibniz_n_n-val"><b>leibniz_n_n</b></a>]  Theorem
      
      ⊢ ∀n. leibniz n n = n + 1
   
   [<a name="leibniz_pos-val"><b>leibniz_pos</b></a>]  Theorem
      
      ⊢ ∀n k. k ≤ n ⇒ 0 &lt; leibniz n k
   
   [<a name="leibniz_property-val"><b>leibniz_property</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒
            ∀k. leibniz n k * leibniz (n − 1) k =
                leibniz n (k + 1) * (leibniz n k − leibniz (n − 1) k)
   
   [<a name="leibniz_recurrence-val"><b>leibniz_recurrence</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒
            ∀k. k &lt; n ⇒
                leibniz n (k + 1) =
                leibniz n k * leibniz (n − 1) k DIV
                (leibniz n k − leibniz (n − 1) k)
   
   [<a name="leibniz_right-val"><b>leibniz_right</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒
            ∀k. leibniz n (k + 1) = (n − k) * leibniz n k DIV (k + 1)
   
   [<a name="leibniz_right_alt-val"><b>leibniz_right_alt</b></a>]  Theorem
      
      ⊢ ∀n k. leibniz n (k + 1) = (n − k) * binomial (n + 1) (k + 1)
   
   [<a name="leibniz_right_entry-val"><b>leibniz_right_entry</b></a>]  Theorem
      
      ⊢ ∀n k. (k + 1) * tc = (n + 1 − k) * tb
   
   [<a name="leibniz_right_eqn-val"><b>leibniz_right_eqn</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀k. (k + 1) * leibniz n (k + 1) = (n − k) * leibniz n k
   
   [<a name="leibniz_row_def-val"><b>leibniz_row_def</b></a>]  Theorem
      
      ⊢ ∀n h. leibniz_row n h = {leibniz n j | j ∈ count h}
   
   [<a name="leibniz_seg_arm_0-val"><b>leibniz_seg_arm_0</b></a>]  Theorem
      
      ⊢ ∀a b. leibniz_seg_arm a b 0 = []
   
   [<a name="leibniz_seg_arm_1-val"><b>leibniz_seg_arm_1</b></a>]  Theorem
      
      ⊢ ∀a b. leibniz_seg_arm a b 1 = [leibniz a b]
   
   [<a name="leibniz_seg_arm_el-val"><b>leibniz_seg_arm_el</b></a>]  Theorem
      
      ⊢ ∀n k.
          k &lt; n ⇒ ∀a b. EL k (leibniz_seg_arm a b n) = leibniz a (b + k)
   
   [<a name="leibniz_seg_arm_head-val"><b>leibniz_seg_arm_head</b></a>]  Theorem
      
      ⊢ ∀a b n. TAKE 1 (leibniz_seg_arm a b (n + 1)) = [leibniz a b]
   
   [<a name="leibniz_seg_arm_len-val"><b>leibniz_seg_arm_len</b></a>]  Theorem
      
      ⊢ ∀a b n. LENGTH (leibniz_seg_arm a b n) = n
   
   [<a name="leibniz_seg_arm_n_0-val"><b>leibniz_seg_arm_n_0</b></a>]  Theorem
      
      ⊢ ∀n. leibniz_seg_arm n 0 (n + 1) = leibniz_horizontal n
   
   [<a name="leibniz_seg_arm_wriggle_row_arm-val"><b>leibniz_seg_arm_wriggle_row_arm</b></a>]  Theorem
      
      ⊢ ∀a b n.
          [leibniz (a + 1) b] ⧺ leibniz_seg_arm a b n wriggle
          leibniz_seg_arm (a + 1) b (n + 1)
   
   [<a name="leibniz_seg_arm_wriggle_step-val"><b>leibniz_seg_arm_wriggle_step</b></a>]  Theorem
      
      ⊢ ∀n k.
          k &lt; n + 1 ⇒
          ∀a b.
            TAKE (k + 1) (leibniz_seg_arm (a + 1) b (n + 1)) ⧺
            DROP k (leibniz_seg_arm a b n) wriggle
            leibniz_seg_arm (a + 1) b (n + 1)
   
   [<a name="leibniz_seg_arm_zigzag_step-val"><b>leibniz_seg_arm_zigzag_step</b></a>]  Theorem
      
      ⊢ ∀n k.
          k &lt; n ⇒
          ∀a b.
            TAKE (k + 1) (leibniz_seg_arm (a + 1) b (n + 1)) ⧺
            DROP k (leibniz_seg_arm a b n) zigzag
            TAKE (k + 2) (leibniz_seg_arm (a + 1) b (n + 1)) ⧺
            DROP (k + 1) (leibniz_seg_arm a b n)
   
   [<a name="leibniz_seg_def-val"><b>leibniz_seg_def</b></a>]  Theorem
      
      ⊢ ∀n k h. leibniz_seg n k h = {leibniz n (k + j) | j ∈ count h}
   
   [<a name="leibniz_sym-val"><b>leibniz_sym</b></a>]  Theorem
      
      ⊢ ∀n k. k ≤ n ⇒ leibniz n k = leibniz n (n − k)
   
   [<a name="leibniz_triplet_0-val"><b>leibniz_triplet_0</b></a>]  Theorem
      
      ⊢ leibniz_up 1 zigzag leibniz_horizontal 1
   
   [<a name="leibniz_triplet_lcm-val"><b>leibniz_triplet_lcm</b></a>]  Theorem
      
      ⊢ ∀n k. lcm tb ta = lcm tb tc
   
   [<a name="leibniz_triplet_member-val"><b>leibniz_triplet_member</b></a>]  Theorem
      
      ⊢ ∀n k.
          ta = leibniz n k ∧ tb = leibniz (n + 1) k ∧
          tc = leibniz (n + 1) (k + 1)
   
   [<a name="leibniz_triplet_property-val"><b>leibniz_triplet_property</b></a>]  Theorem
      
      ⊢ ∀n' k. ta * tb = tc * (tb − ta)
   
   [<a name="leibniz_up-val"><b>leibniz_up</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒
            ∀k. leibniz (n − 1) k = (n − k) * leibniz n k DIV (n + 1)
   
   [<a name="leibniz_up_0-val"><b>leibniz_up_0</b></a>]  Theorem
      
      ⊢ leibniz_up 0 = [1]
   
   [<a name="leibniz_up_alt-val"><b>leibniz_up_alt</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀k. leibniz (n − 1) k = (n − k) * binomial n k
   
   [<a name="leibniz_up_cons-val"><b>leibniz_up_cons</b></a>]  Theorem
      
      ⊢ ∀n. leibniz_up (n + 1) = n + 2::leibniz_up n
   
   [<a name="leibniz_up_entry-val"><b>leibniz_up_entry</b></a>]  Theorem
      
      ⊢ ∀n k. (n + 2) * ta = (n + 1 − k) * tb
   
   [<a name="leibniz_up_eqn-val"><b>leibniz_up_eqn</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀k. (n + 1) * leibniz (n − 1) k = (n − k) * leibniz n k
   
   [<a name="leibniz_up_lcm_eq_horizontal_lcm-val"><b>leibniz_up_lcm_eq_horizontal_lcm</b></a>]  Theorem
      
      ⊢ ∀n. list_lcm (leibniz_up n) = list_lcm (leibniz_horizontal n)
   
   [<a name="leibniz_up_len-val"><b>leibniz_up_len</b></a>]  Theorem
      
      ⊢ ∀n. LENGTH (leibniz_up n) = n + 1
   
   [<a name="leibniz_up_mem-val"><b>leibniz_up_mem</b></a>]  Theorem
      
      ⊢ ∀n x. 0 &lt; x ∧ x ≤ n + 1 ⇔ MEM x (leibniz_up n)
   
   [<a name="leibniz_up_pos-val"><b>leibniz_up_pos</b></a>]  Theorem
      
      ⊢ ∀n. EVERY_POSITIVE (leibniz_up n)
   
   [<a name="leibniz_up_wriggle_horizontal-val"><b>leibniz_up_wriggle_horizontal</b></a>]  Theorem
      
      ⊢ ∀n. leibniz_up n wriggle leibniz_horizontal n
   
   [<a name="leibniz_up_wriggle_horizontal_alt-val"><b>leibniz_up_wriggle_horizontal_alt</b></a>]  Theorem
      
      ⊢ ∀n. leibniz_up n wriggle leibniz_horizontal n
   
   [<a name="leibniz_vertical_0-val"><b>leibniz_vertical_0</b></a>]  Theorem
      
      ⊢ leibniz_vertical 0 = [1]
   
   [<a name="leibniz_vertical_alt-val"><b>leibniz_vertical_alt</b></a>]  Theorem
      
      ⊢ ∀n. leibniz_vertical n = GENLIST (λi. 1 + i) (n + 1)
   
   [<a name="leibniz_vertical_divisor-val"><b>leibniz_vertical_divisor</b></a>]  Theorem
      
      ⊢ ∀n k. k ≤ n ⇒ leibniz n k divides lcm_run (n + 1)
   
   [<a name="leibniz_vertical_lcm_lower-val"><b>leibniz_vertical_lcm_lower</b></a>]  Theorem
      
      ⊢ ∀n. 2 ** n ≤ lcm_run (n + 1)
   
   [<a name="leibniz_vertical_len-val"><b>leibniz_vertical_len</b></a>]  Theorem
      
      ⊢ ∀n. LENGTH (leibniz_vertical n) = n + 1
   
   [<a name="leibniz_vertical_mem-val"><b>leibniz_vertical_mem</b></a>]  Theorem
      
      ⊢ ∀n x. 0 &lt; x ∧ x ≤ n + 1 ⇔ MEM x (leibniz_vertical n)
   
   [<a name="leibniz_vertical_not_nil-val"><b>leibniz_vertical_not_nil</b></a>]  Theorem
      
      ⊢ ∀n. leibniz_vertical n ≠ []
   
   [<a name="leibniz_vertical_pos-val"><b>leibniz_vertical_pos</b></a>]  Theorem
      
      ⊢ ∀n. EVERY_POSITIVE (leibniz_vertical n)
   
   [<a name="leibniz_vertical_pos_alt-val"><b>leibniz_vertical_pos_alt</b></a>]  Theorem
      
      ⊢ ∀n x. MEM x (leibniz_vertical n) ⇒ 0 &lt; x
   
   [<a name="leibniz_vertical_snoc-val"><b>leibniz_vertical_snoc</b></a>]  Theorem
      
      ⊢ ∀n. leibniz_vertical (n + 1) = SNOC (n + 2) (leibniz_vertical n)
   
   [<a name="leibniz_wriggle_refl-val"><b>leibniz_wriggle_refl</b></a>]  Theorem
      
      ⊢ ∀p1. p1 wriggle p1
   
   [<a name="leibniz_wriggle_tail-val"><b>leibniz_wriggle_tail</b></a>]  Theorem
      
      ⊢ ∀p1 p2. p1 wriggle p2 ⇒ ∀x. [x] ⧺ p1 wriggle [x] ⧺ p2
   
   [<a name="leibniz_wriggle_trans-val"><b>leibniz_wriggle_trans</b></a>]  Theorem
      
      ⊢ ∀p1 p2 p3. p1 wriggle p2 ∧ p2 wriggle p3 ⇒ p1 wriggle p3
   
   [<a name="leibniz_zigzag_tail-val"><b>leibniz_zigzag_tail</b></a>]  Theorem
      
      ⊢ ∀p1 p2. p1 zigzag p2 ⇒ ∀x. [x] ⧺ p1 zigzag [x] ⧺ p2
   
   [<a name="leibniz_zigzag_wriggle-val"><b>leibniz_zigzag_wriggle</b></a>]  Theorem
      
      ⊢ ∀p1 p2. p1 zigzag p2 ⇒ p1 wriggle p2
   
   [<a name="listRangeINC_MONO_INC-val"><b>listRangeINC_MONO_INC</b></a>]  Theorem
      
      ⊢ ∀m n m' n'.
          m' ≤ n' ∧ n' &lt; LENGTH [m .. n] ⇒ EL m' [m .. n] ≤ EL n' [m .. n]
   
   [<a name="listRangeINC_PROD-val"><b>listRangeINC_PROD</b></a>]  Theorem
      
      ⊢ ∀m n.
          0 &lt; m ∧ m ≤ n ⇒
          PROD [m .. n] = PROD [1 .. n] DIV PROD [1 .. m − 1]
   
   [<a name="listRangeINC_PROD_pos-val"><b>listRangeINC_PROD_pos</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ⇒ 0 &lt; PROD [m .. n]
   
   [<a name="listRangeLHI_MONO_INC-val"><b>listRangeLHI_MONO_INC</b></a>]  Theorem
      
      ⊢ ∀m n m' n'.
          m' ≤ n' ∧ n' &lt; LENGTH [m ..&lt; n] ⇒
          EL m' [m ..&lt; n] ≤ EL n' [m ..&lt; n]
   
   [<a name="listRangeLHI_PROD-val"><b>listRangeLHI_PROD</b></a>]  Theorem
      
      ⊢ ∀m n.
          0 &lt; m ∧ m ≤ n ⇒
          PROD [m ..&lt; n] = PROD [1 ..&lt; n] DIV PROD [1 ..&lt; m]
   
   [<a name="listRangeLHI_PROD_pos-val"><b>listRangeLHI_PROD_pos</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ⇒ 0 &lt; PROD [m ..&lt; n]
   
   [<a name="list_count_0_n-val"><b>list_count_0_n</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ list_count 0 n = ∅
   
   [<a name="list_count_alt-val"><b>list_count_alt</b></a>]  Theorem
      
      ⊢ ∀n k.
          list_count n k =
          {ls | ALL_DISTINCT ls ∧ set ls ⊆ count n ∧ CARD (set ls) = k}
   
   [<a name="list_count_by_image-val"><b>list_count_by_image</b></a>]  Theorem
      
      ⊢ ∀n k.
          0 &lt; k ⇒
          list_count n k =
          IMAGE (λls. if ALL_DISTINCT ls then ls else []) (necklace k n) DELETE
          []
   
   [<a name="list_count_element-val"><b>list_count_element</b></a>]  Theorem
      
      ⊢ ∀ls n k.
          ls ∈ list_count n k ⇔
          ALL_DISTINCT ls ∧ set ls ⊆ count n ∧ LENGTH ls = k
   
   [<a name="list_count_element_alt-val"><b>list_count_element_alt</b></a>]  Theorem
      
      ⊢ ∀ls n k.
          ls ∈ list_count n k ⇔
          ALL_DISTINCT ls ∧ set ls ⊆ count n ∧ CARD (set ls) = k
   
   [<a name="list_count_element_perm_set_not_empty-val"><b>list_count_element_perm_set_not_empty</b></a>]  Theorem
      
      ⊢ ∀ls n k. ls ∈ list_count n k ⇒ perm_set (set ls) ≠ ∅
   
   [<a name="list_count_element_set_card-val"><b>list_count_element_set_card</b></a>]  Theorem
      
      ⊢ ∀ls n k. ls ∈ list_count n k ⇒ CARD (set ls) = k
   
   [<a name="list_count_eq_empty-val"><b>list_count_eq_empty</b></a>]  Theorem
      
      ⊢ ∀n k. list_count n k = ∅ ⇔ n &lt; k
   
   [<a name="list_count_eqn-val"><b>list_count_eqn</b></a>]  Theorem
      
      ⊢ ∀n k.
          list_count n k =
          if k = 0 then {[]}
          else
            IMAGE (λls. if ALL_DISTINCT ls then ls else []) (necklace k n) DELETE
            []
   
   [<a name="list_count_finite-val"><b>list_count_finite</b></a>]  Theorem
      
      ⊢ ∀n k. FINITE (list_count n k)
   
   [<a name="list_count_n_0-val"><b>list_count_n_0</b></a>]  Theorem
      
      ⊢ ∀n. list_count n 0 = {[]}
   
   [<a name="list_count_n_n-val"><b>list_count_n_n</b></a>]  Theorem
      
      ⊢ ∀n. list_count n n = perm_count n
   
   [<a name="list_count_set_eq_class-val"><b>list_count_set_eq_class</b></a>]  Theorem
      
      ⊢ ∀ls n k.
          ls ∈ list_count n k ⇒
          equiv_class (feq set) (list_count n k) ls = perm_set (set ls)
   
   [<a name="list_count_set_eq_class_card-val"><b>list_count_set_eq_class_card</b></a>]  Theorem
      
      ⊢ ∀ls n k.
          ls ∈ list_count n k ⇒
          CARD (equiv_class (feq set) (list_count n k) ls) = perm k
   
   [<a name="list_count_set_map_bij-val"><b>list_count_set_map_bij</b></a>]  Theorem
      
      ⊢ ∀n k.
          BIJ (set ∘ CHOICE) (partition (feq set) (list_count n k))
            (sub_count n k)
   
   [<a name="list_count_set_map_element-val"><b>list_count_set_map_element</b></a>]  Theorem
      
      ⊢ ∀s n k.
          s ∈ partition (feq set) (list_count n k) ⇒
          (set ∘ CHOICE) s ∈ sub_count n k
   
   [<a name="list_count_set_map_inj-val"><b>list_count_set_map_inj</b></a>]  Theorem
      
      ⊢ ∀n k.
          INJ (set ∘ CHOICE) (partition (feq set) (list_count n k))
            (sub_count n k)
   
   [<a name="list_count_set_map_surj-val"><b>list_count_set_map_surj</b></a>]  Theorem
      
      ⊢ ∀n k.
          SURJ (set ∘ CHOICE) (partition (feq set) (list_count n k))
            (sub_count n k)
   
   [<a name="list_count_set_partititon_element_card-val"><b>list_count_set_partititon_element_card</b></a>]  Theorem
      
      ⊢ ∀n k e. e ∈ partition (feq set) (list_count n k) ⇒ CARD e = perm k
   
   [<a name="list_count_subset-val"><b>list_count_subset</b></a>]  Theorem
      
      ⊢ ∀n k. list_count n k ⊆ necklace k n
   
   [<a name="list_lcm_absorption-val"><b>list_lcm_absorption</b></a>]  Theorem
      
      ⊢ ∀x l. MEM x l ⇒ list_lcm (x::l) = list_lcm l
   
   [<a name="list_lcm_append-val"><b>list_lcm_append</b></a>]  Theorem
      
      ⊢ ∀l1 l2. list_lcm (l1 ⧺ l2) = lcm (list_lcm l1) (list_lcm l2)
   
   [<a name="list_lcm_append_3-val"><b>list_lcm_append_3</b></a>]  Theorem
      
      ⊢ ∀l1 l2 l3.
          list_lcm (l1 ⧺ l2 ⧺ l3) =
          list_lcm [list_lcm l1; list_lcm l2; list_lcm l3]
   
   [<a name="list_lcm_by_FOLDL-val"><b>list_lcm_by_FOLDL</b></a>]  Theorem
      
      ⊢ ∀ls. list_lcm ls = FOLDL lcm 1 ls
   
   [<a name="list_lcm_by_FOLDR-val"><b>list_lcm_by_FOLDR</b></a>]  Theorem
      
      ⊢ ∀ls. list_lcm ls = FOLDR lcm 1 ls
   
   [<a name="list_lcm_cons-val"><b>list_lcm_cons</b></a>]  Theorem
      
      ⊢ ∀h t. list_lcm (h::t) = lcm h (list_lcm t)
   
   [<a name="list_lcm_divisor_lcm_pair-val"><b>list_lcm_divisor_lcm_pair</b></a>]  Theorem
      
      ⊢ ∀l x y. MEM x l ∧ MEM y l ⇒ lcm x y divides list_lcm l
   
   [<a name="list_lcm_eq_if_set_eq-val"><b>list_lcm_eq_if_set_eq</b></a>]  Theorem
      
      ⊢ ∀l1 l2. set l1 = set l2 ⇒ list_lcm l1 = list_lcm l2
   
   [<a name="list_lcm_ge_max-val"><b>list_lcm_ge_max</b></a>]  Theorem
      
      ⊢ ∀l. POSITIVE l ⇒ MAX_LIST l ≤ list_lcm l
   
   [<a name="list_lcm_is_common_multiple-val"><b>list_lcm_is_common_multiple</b></a>]  Theorem
      
      ⊢ ∀x l. MEM x l ⇒ x divides list_lcm l
   
   [<a name="list_lcm_is_least_common_multiple-val"><b>list_lcm_is_least_common_multiple</b></a>]  Theorem
      
      ⊢ ∀l m. (∀x. MEM x l ⇒ x divides m) ⇒ list_lcm l divides m
   
   [<a name="list_lcm_lower_bound-val"><b>list_lcm_lower_bound</b></a>]  Theorem
      
      ⊢ ∀l. EVERY_POSITIVE l ⇒ SUM l ≤ LENGTH l * list_lcm l
   
   [<a name="list_lcm_lower_bound_alt-val"><b>list_lcm_lower_bound_alt</b></a>]  Theorem
      
      ⊢ ∀l. POSITIVE l ⇒ SUM l ≤ LENGTH l * list_lcm l
   
   [<a name="list_lcm_lower_by_lcm_pair-val"><b>list_lcm_lower_by_lcm_pair</b></a>]  Theorem
      
      ⊢ ∀l x y. POSITIVE l ∧ MEM x l ∧ MEM y l ⇒ lcm x y ≤ list_lcm l
   
   [<a name="list_lcm_map_times-val"><b>list_lcm_map_times</b></a>]  Theorem
      
      ⊢ ∀n l.
          list_lcm (MAP (λk. n * k) l) =
          if l = [] then 1 else n * list_lcm l
   
   [<a name="list_lcm_nil-val"><b>list_lcm_nil</b></a>]  Theorem
      
      ⊢ list_lcm [] = 1
   
   [<a name="list_lcm_nonempty_lower-val"><b>list_lcm_nonempty_lower</b></a>]  Theorem
      
      ⊢ ∀l. l ≠ [] ∧ EVERY_POSITIVE l ⇒ SUM l DIV LENGTH l ≤ list_lcm l
   
   [<a name="list_lcm_nonempty_lower_alt-val"><b>list_lcm_nonempty_lower_alt</b></a>]  Theorem
      
      ⊢ ∀l. l ≠ [] ∧ POSITIVE l ⇒ SUM l DIV LENGTH l ≤ list_lcm l
   
   [<a name="list_lcm_nub-val"><b>list_lcm_nub</b></a>]  Theorem
      
      ⊢ ∀l. list_lcm (nub l) = list_lcm l
   
   [<a name="list_lcm_nub_eq_if_set_eq-val"><b>list_lcm_nub_eq_if_set_eq</b></a>]  Theorem
      
      ⊢ ∀l1 l2. set l1 = set l2 ⇒ list_lcm (nub l1) = list_lcm (nub l2)
   
   [<a name="list_lcm_pos-val"><b>list_lcm_pos</b></a>]  Theorem
      
      ⊢ ∀l. EVERY_POSITIVE l ⇒ 0 &lt; list_lcm l
   
   [<a name="list_lcm_pos_alt-val"><b>list_lcm_pos_alt</b></a>]  Theorem
      
      ⊢ ∀l. POSITIVE l ⇒ 0 &lt; list_lcm l
   
   [<a name="list_lcm_prime_factor-val"><b>list_lcm_prime_factor</b></a>]  Theorem
      
      ⊢ ∀p l. prime p ∧ p divides list_lcm l ⇒ p divides PROD_SET (set l)
   
   [<a name="list_lcm_prime_factor_member-val"><b>list_lcm_prime_factor_member</b></a>]  Theorem
      
      ⊢ ∀p l. prime p ∧ p divides list_lcm l ⇒ ∃x. MEM x l ∧ p divides x
   
   [<a name="list_lcm_reverse-val"><b>list_lcm_reverse</b></a>]  Theorem
      
      ⊢ ∀l. list_lcm (REVERSE l) = list_lcm l
   
   [<a name="list_lcm_sing-val"><b>list_lcm_sing</b></a>]  Theorem
      
      ⊢ ∀x. list_lcm [x] = x
   
   [<a name="list_lcm_snoc-val"><b>list_lcm_snoc</b></a>]  Theorem
      
      ⊢ ∀x l. list_lcm (SNOC x l) = lcm x (list_lcm l)
   
   [<a name="list_lcm_suc-val"><b>list_lcm_suc</b></a>]  Theorem
      
      ⊢ ∀n. lcm_run (n + 1) = lcm (n + 1) (lcm_run n)
   
   [<a name="list_lcm_upper_by_common_multiple-val"><b>list_lcm_upper_by_common_multiple</b></a>]  Theorem
      
      ⊢ ∀l m. 0 &lt; m ∧ (∀x. MEM x l ⇒ x divides m) ⇒ list_lcm l ≤ m
   
   [<a name="list_lcm_wriggle-val"><b>list_lcm_wriggle</b></a>]  Theorem
      
      ⊢ ∀p1 p2. p1 wriggle p2 ⇒ list_lcm p1 = list_lcm p2
   
   [<a name="list_lcm_zigzag-val"><b>list_lcm_zigzag</b></a>]  Theorem
      
      ⊢ ∀p1 p2. p1 zigzag p2 ⇒ list_lcm p1 = list_lcm p2
   
   [<a name="list_length_eq_sum-val"><b>list_length_eq_sum</b></a>]  Theorem
      
      ⊢ ∀ls. EVERY_POSITIVE ls ∧ LENGTH ls = SUM ls ⇒ EVERY (λx. x = 1) ls
   
   [<a name="list_length_le_sum-val"><b>list_length_le_sum</b></a>]  Theorem
      
      ⊢ ∀ls. EVERY_POSITIVE ls ⇒ LENGTH ls ≤ SUM ls
   
   [<a name="list_product_prime_factor-val"><b>list_product_prime_factor</b></a>]  Theorem
      
      ⊢ ∀p l.
          prime p ∧ p divides PROD_SET (set l) ⇒ ∃x. MEM x l ∧ p divides x
   
   [<a name="monocoloured_0-val"><b>monocoloured_0</b></a>]  Theorem
      
      ⊢ ∀a. monocoloured 0 a = {[]}
   
   [<a name="monocoloured_0_card-val"><b>monocoloured_0_card</b></a>]  Theorem
      
      ⊢ ∀a. CARD (monocoloured 0 a) = 1
   
   [<a name="monocoloured_1-val"><b>monocoloured_1</b></a>]  Theorem
      
      ⊢ ∀a. monocoloured 1 a = necklace 1 a
   
   [<a name="monocoloured_card-val"><b>monocoloured_card</b></a>]  Theorem
      
      ⊢ ∀n a. 0 &lt; n ⇒ CARD (monocoloured n a) = a
   
   [<a name="monocoloured_card_eqn-val"><b>monocoloured_card_eqn</b></a>]  Theorem
      
      ⊢ ∀n a. CARD (monocoloured n a) = if n = 0 then 1 else a
   
   [<a name="monocoloured_element-val"><b>monocoloured_element</b></a>]  Theorem
      
      ⊢ ∀n a ls.
          ls ∈ monocoloured n a ⇔
          ls ∈ necklace n a ∧ (ls ≠ [] ⇒ SING (set ls))
   
   [<a name="monocoloured_empty-val"><b>monocoloured_empty</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ monocoloured n 0 = ∅
   
   [<a name="monocoloured_eqn-val"><b>monocoloured_eqn</b></a>]  Theorem
      
      ⊢ ∀n a.
          monocoloured n a =
          if n = 0 then {[]} else IMAGE (λc. GENLIST (K c) n) (count a)
   
   [<a name="monocoloured_finite-val"><b>monocoloured_finite</b></a>]  Theorem
      
      ⊢ ∀n a. FINITE (monocoloured n a)
   
   [<a name="monocoloured_mono-val"><b>monocoloured_mono</b></a>]  Theorem
      
      ⊢ ∀n. monocoloured n 1 = necklace n 1
   
   [<a name="monocoloured_necklace-val"><b>monocoloured_necklace</b></a>]  Theorem
      
      ⊢ ∀n a ls. ls ∈ monocoloured n a ⇒ ls ∈ necklace n a
   
   [<a name="monocoloured_subset-val"><b>monocoloured_subset</b></a>]  Theorem
      
      ⊢ ∀n a. monocoloured n a ⊆ necklace n a
   
   [<a name="monocoloured_suc-val"><b>monocoloured_suc</b></a>]  Theorem
      
      ⊢ ∀n a.
          0 &lt; n ⇒
          monocoloured (SUC n) a =
          IMAGE (λls. HD ls::ls) (monocoloured n a)
   
   [<a name="multi_mono_disjoint-val"><b>multi_mono_disjoint</b></a>]  Theorem
      
      ⊢ ∀n a. DISJOINT (multicoloured n a) (monocoloured n a)
   
   [<a name="multi_mono_exhaust-val"><b>multi_mono_exhaust</b></a>]  Theorem
      
      ⊢ ∀n a. necklace n a = multicoloured n a ∪ monocoloured n a
   
   [<a name="multicoloured_0-val"><b>multicoloured_0</b></a>]  Theorem
      
      ⊢ ∀a. multicoloured 0 a = ∅
   
   [<a name="multicoloured_1-val"><b>multicoloured_1</b></a>]  Theorem
      
      ⊢ ∀a. multicoloured 1 a = ∅
   
   [<a name="multicoloured_card-val"><b>multicoloured_card</b></a>]  Theorem
      
      ⊢ ∀n a. 0 &lt; n ⇒ CARD (multicoloured n a) = a ** n − a
   
   [<a name="multicoloured_card_eqn-val"><b>multicoloured_card_eqn</b></a>]  Theorem
      
      ⊢ ∀n a. CARD (multicoloured n a) = if n = 0 then 0 else a ** n − a
   
   [<a name="multicoloured_element-val"><b>multicoloured_element</b></a>]  Theorem
      
      ⊢ ∀n a ls.
          ls ∈ multicoloured n a ⇔
          ls ∈ necklace n a ∧ ls ≠ [] ∧ ¬SING (set ls)
   
   [<a name="multicoloured_empty-val"><b>multicoloured_empty</b></a>]  Theorem
      
      ⊢ ∀n. multicoloured n 0 = ∅ ∧ multicoloured n 1 = ∅
   
   [<a name="multicoloured_finite-val"><b>multicoloured_finite</b></a>]  Theorem
      
      ⊢ ∀n a. FINITE (multicoloured n a)
   
   [<a name="multicoloured_n_0-val"><b>multicoloured_n_0</b></a>]  Theorem
      
      ⊢ ∀n. multicoloured n 0 = ∅
   
   [<a name="multicoloured_n_1-val"><b>multicoloured_n_1</b></a>]  Theorem
      
      ⊢ ∀n. multicoloured n 1 = ∅
   
   [<a name="multicoloured_necklace-val"><b>multicoloured_necklace</b></a>]  Theorem
      
      ⊢ ∀n a ls. ls ∈ multicoloured n a ⇒ ls ∈ necklace n a
   
   [<a name="multicoloured_nonempty-val"><b>multicoloured_nonempty</b></a>]  Theorem
      
      ⊢ ∀n a. 1 &lt; n ∧ 1 &lt; a ⇒ multicoloured n a ≠ ∅
   
   [<a name="multicoloured_not_monocoloured-val"><b>multicoloured_not_monocoloured</b></a>]  Theorem
      
      ⊢ ∀n a ls. ls ∈ multicoloured n a ⇒ ls ∉ monocoloured n a
   
   [<a name="multicoloured_not_monocoloured_iff-val"><b>multicoloured_not_monocoloured_iff</b></a>]  Theorem
      
      ⊢ ∀n a ls.
          ls ∈ necklace n a ⇒
          (ls ∈ multicoloured n a ⇔ ls ∉ monocoloured n a)
   
   [<a name="multicoloured_or_monocoloured-val"><b>multicoloured_or_monocoloured</b></a>]  Theorem
      
      ⊢ ∀n a ls.
          ls ∈ necklace n a ⇒
          ls ∈ multicoloured n a ∨ ls ∈ monocoloured n a
   
   [<a name="multicoloured_subset-val"><b>multicoloured_subset</b></a>]  Theorem
      
      ⊢ ∀n a. multicoloured n a ⊆ necklace n a
   
   [<a name="necklace_0-val"><b>necklace_0</b></a>]  Theorem
      
      ⊢ ∀a. necklace 0 a = {[]}
   
   [<a name="necklace_1-val"><b>necklace_1</b></a>]  Theorem
      
      ⊢ ∀a. necklace 1 a = {[e] | e ∈ count a}
   
   [<a name="necklace_1_monocoloured-val"><b>necklace_1_monocoloured</b></a>]  Theorem
      
      ⊢ ∀a. necklace 1 a = monocoloured 1 a
   
   [<a name="necklace_card-val"><b>necklace_card</b></a>]  Theorem
      
      ⊢ ∀n a. CARD (necklace n a) = a ** n
   
   [<a name="necklace_colors-val"><b>necklace_colors</b></a>]  Theorem
      
      ⊢ ∀n a ls. ls ∈ necklace n a ⇒ set ls ⊆ count a
   
   [<a name="necklace_element-val"><b>necklace_element</b></a>]  Theorem
      
      ⊢ ∀n a ls. ls ∈ necklace n a ⇔ LENGTH ls = n ∧ set ls ⊆ count a
   
   [<a name="necklace_empty-val"><b>necklace_empty</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ necklace n 0 = ∅
   
   [<a name="necklace_eqn-val"><b>necklace_eqn</b></a>]  Theorem
      
      ⊢ ∀n a.
          necklace n a =
          if n = 0 then {[]}
          else IMAGE (λ(c,ls). c::ls) (count a × necklace (n − 1) a)
   
   [<a name="necklace_finite-val"><b>necklace_finite</b></a>]  Theorem
      
      ⊢ ∀n a. FINITE (necklace n a)
   
   [<a name="necklace_length-val"><b>necklace_length</b></a>]  Theorem
      
      ⊢ ∀n a ls. ls ∈ necklace n a ⇒ LENGTH ls = n
   
   [<a name="necklace_not_nil-val"><b>necklace_not_nil</b></a>]  Theorem
      
      ⊢ ∀n a ls. 0 &lt; n ∧ ls ∈ necklace n a ⇒ ls ≠ []
   
   [<a name="necklace_property-val"><b>necklace_property</b></a>]  Theorem
      
      ⊢ ∀n a ls. ls ∈ necklace n a ⇒ LENGTH ls = n ∧ set ls ⊆ count a
   
   [<a name="necklace_suc-val"><b>necklace_suc</b></a>]  Theorem
      
      ⊢ ∀n a.
          necklace (SUC n) a =
          IMAGE (λ(c,ls). c::ls) (count a × necklace n a)
   
   [<a name="nub_all_distinct-val"><b>nub_all_distinct</b></a>]  Theorem
      
      ⊢ ∀l. ALL_DISTINCT (nub l)
   
   [<a name="nub_cons-val"><b>nub_cons</b></a>]  Theorem
      
      ⊢ ∀x l. nub (x::l) = if MEM x l then nub l else x::nub l
   
   [<a name="nub_nil-val"><b>nub_nil</b></a>]  Theorem
      
      ⊢ nub [] = []
   
   [<a name="nub_sing-val"><b>nub_sing</b></a>]  Theorem
      
      ⊢ ∀x. nub [x] = [x]
   
   [<a name="over_bij-val"><b>over_bij</b></a>]  Theorem
      
      ⊢ ∀f s t. BIJ f s t ⇒ over f s t
   
   [<a name="over_inj-val"><b>over_inj</b></a>]  Theorem
      
      ⊢ ∀f s t. INJ f s t ⇒ over f s t
   
   [<a name="over_surj-val"><b>over_surj</b></a>]  Theorem
      
      ⊢ ∀f s t. SURJ f s t ⇒ over f s t
   
   [<a name="pairwise_coprime_prod_set_divides-val"><b>pairwise_coprime_prod_set_divides</b></a>]  Theorem
      
      ⊢ ∀s m.
          FINITE s ∧ PAIRWISE_COPRIME s ∧ (∀x. x ∈ s ⇒ x divides m) ⇒
          PROD_SET s divides m
   
   [<a name="pairwise_coprime_prod_set_eq_set_lcm-val"><b>pairwise_coprime_prod_set_eq_set_lcm</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ∧ PAIRWISE_COPRIME s ⇒ set_lcm s = PROD_SET s
   
   [<a name="perm_0-val"><b>perm_0</b></a>]  Theorem
      
      ⊢ perm 0 = 1
   
   [<a name="perm_1-val"><b>perm_1</b></a>]  Theorem
      
      ⊢ perm 1 = 1
   
   [<a name="perm_alt-val"><b>perm_alt</b></a>]  Theorem
      
      ⊢ perm 0 = 1 ∧ ∀n. perm (n + 1) = (n + 1) * perm n
   
   [<a name="perm_count_0-val"><b>perm_count_0</b></a>]  Theorem
      
      ⊢ perm_count 0 = {[]}
   
   [<a name="perm_count_1-val"><b>perm_count_1</b></a>]  Theorem
      
      ⊢ perm_count 1 = {[0]}
   
   [<a name="perm_count_element-val"><b>perm_count_element</b></a>]  Theorem
      
      ⊢ ∀ls n. ls ∈ perm_count n ⇔ ALL_DISTINCT ls ∧ set ls = count n
   
   [<a name="perm_count_element_length-val"><b>perm_count_element_length</b></a>]  Theorem
      
      ⊢ ∀ls n. ls ∈ perm_count n ⇒ LENGTH ls = n
   
   [<a name="perm_count_element_no_self-val"><b>perm_count_element_no_self</b></a>]  Theorem
      
      ⊢ ∀ls n. ls ∈ perm_count n ⇒ ¬MEM n ls
   
   [<a name="perm_count_eqn-val"><b>perm_count_eqn</b></a>]  Theorem
      
      ⊢ ∀n. perm_count n =
            if n = 0 then {[]}
            else
              BIGUNION (IMAGE ($interleave (n − 1)) (perm_count (n − 1)))
   
   [<a name="perm_count_finite-val"><b>perm_count_finite</b></a>]  Theorem
      
      ⊢ ∀n. FINITE (perm_count n)
   
   [<a name="perm_count_interleave_card-val"><b>perm_count_interleave_card</b></a>]  Theorem
      
      ⊢ ∀n e. e ∈ IMAGE ($interleave n) (perm_count n) ⇒ CARD e = n + 1
   
   [<a name="perm_count_interleave_disjoint-val"><b>perm_count_interleave_disjoint</b></a>]  Theorem
      
      ⊢ ∀n e s t.
          s ∈ IMAGE ($interleave n) (perm_count n) ∧
          t ∈ IMAGE ($interleave n) (perm_count n) ∧ s ≠ t ⇒
          DISJOINT s t
   
   [<a name="perm_count_interleave_finite-val"><b>perm_count_interleave_finite</b></a>]  Theorem
      
      ⊢ ∀n e. e ∈ IMAGE ($interleave n) (perm_count n) ⇒ FINITE e
   
   [<a name="perm_count_interleave_inj-val"><b>perm_count_interleave_inj</b></a>]  Theorem
      
      ⊢ ∀n. INJ ($interleave n) (perm_count n) 𝕌(:num list -&gt; bool)
   
   [<a name="perm_count_subset-val"><b>perm_count_subset</b></a>]  Theorem
      
      ⊢ ∀n. perm_count n ⊆ necklace n n
   
   [<a name="perm_count_suc-val"><b>perm_count_suc</b></a>]  Theorem
      
      ⊢ ∀n. perm_count (SUC n) =
            BIGUNION (IMAGE ($interleave n) (perm_count n))
   
   [<a name="perm_count_suc_alt-val"><b>perm_count_suc_alt</b></a>]  Theorem
      
      ⊢ ∀n. perm_count (n + 1) =
            BIGUNION (IMAGE ($interleave n) (perm_count n))
   
   [<a name="perm_eq_fact-val"><b>perm_eq_fact</b></a>]  Theorem
      
      ⊢ ∀n. perm n = FACT n
   
   [<a name="perm_set_bij_eq_perm_count-val"><b>perm_set_bij_eq_perm_count</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ perm_set s =b= perm_count (CARD s)
   
   [<a name="perm_set_card-val"><b>perm_set_card</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ CARD (perm_set s) = perm (CARD s)
   
   [<a name="perm_set_card_alt-val"><b>perm_set_card_alt</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ CARD (perm_set s) = FACT (CARD s)
   
   [<a name="perm_set_element-val"><b>perm_set_element</b></a>]  Theorem
      
      ⊢ ∀ls s. ls ∈ perm_set s ⇔ ALL_DISTINCT ls ∧ set ls = s
   
   [<a name="perm_set_empty-val"><b>perm_set_empty</b></a>]  Theorem
      
      ⊢ perm_set ∅ = {[]}
   
   [<a name="perm_set_eq_empty_sing-val"><b>perm_set_eq_empty_sing</b></a>]  Theorem
      
      ⊢ ∀s. perm_set s = {[]} ⇔ s = ∅
   
   [<a name="perm_set_finite-val"><b>perm_set_finite</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ FINITE (perm_set s)
   
   [<a name="perm_set_has_self_list-val"><b>perm_set_has_self_list</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ SET_TO_LIST s ∈ perm_set s
   
   [<a name="perm_set_list_not_empty-val"><b>perm_set_list_not_empty</b></a>]  Theorem
      
      ⊢ ∀ls. perm_set (set ls) ≠ ∅
   
   [<a name="perm_set_map_bij-val"><b>perm_set_map_bij</b></a>]  Theorem
      
      ⊢ ∀f s n. BIJ f s (count n) ⇒ BIJ (MAP f) (perm_set s) (perm_count n)
   
   [<a name="perm_set_map_element-val"><b>perm_set_map_element</b></a>]  Theorem
      
      ⊢ ∀ls f s n.
          ls ∈ perm_set s ∧ BIJ f s (count n) ⇒ MAP f ls ∈ perm_count n
   
   [<a name="perm_set_map_inj-val"><b>perm_set_map_inj</b></a>]  Theorem
      
      ⊢ ∀f s n. BIJ f s (count n) ⇒ INJ (MAP f) (perm_set s) (perm_count n)
   
   [<a name="perm_set_map_surj-val"><b>perm_set_map_surj</b></a>]  Theorem
      
      ⊢ ∀f s n.
          BIJ f s (count n) ⇒ SURJ (MAP f) (perm_set s) (perm_count n)
   
   [<a name="perm_set_not_empty-val"><b>perm_set_not_empty</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ perm_set s ≠ ∅
   
   [<a name="perm_set_perm_count-val"><b>perm_set_perm_count</b></a>]  Theorem
      
      ⊢ ∀n. perm_set (count n) = perm_count n
   
   [<a name="perm_set_sing-val"><b>perm_set_sing</b></a>]  Theorem
      
      ⊢ ∀x. perm_set {x} = {[x]}
   
   [<a name="perm_suc-val"><b>perm_suc</b></a>]  Theorem
      
      ⊢ ∀n. perm (SUC n) = SUC n * perm n
   
   [<a name="perm_suc_alt-val"><b>perm_suc_alt</b></a>]  Theorem
      
      ⊢ ∀n. perm (n + 1) = (n + 1) * perm n
   
   [<a name="power_predecessor_eqn-val"><b>power_predecessor_eqn</b></a>]  Theorem
      
      ⊢ ∀t n. tops t n = (t − 1) * SUM (MAP (λj. t ** j) [0 ..&lt; n])
   
   [<a name="prime_divides_binomials-val"><b>prime_divides_binomials</b></a>]  Theorem
      
      ⊢ ∀n. prime n ⇒ 1 &lt; n ∧ ∀k. 0 &lt; k ∧ k &lt; n ⇒ n divides binomial n k
   
   [<a name="prime_divides_binomials_alt-val"><b>prime_divides_binomials_alt</b></a>]  Theorem
      
      ⊢ ∀n k. prime n ∧ 0 &lt; k ∧ k &lt; n ⇒ n divides binomial n k
   
   [<a name="prime_divisor_property-val"><b>prime_divisor_property</b></a>]  Theorem
      
      ⊢ ∀n p.
          1 &lt; n ∧ p &lt; n ∧ prime p ∧ p divides n ⇒
          ¬(p divides FACT (n − 1) DIV FACT (n − p))
   
   [<a name="prime_iff_divides_binomials-val"><b>prime_iff_divides_binomials</b></a>]  Theorem
      
      ⊢ ∀n. prime n ⇔ 1 &lt; n ∧ ∀k. 0 &lt; k ∧ k &lt; n ⇒ n divides binomial n k
   
   [<a name="prime_iff_divides_binomials_alt-val"><b>prime_iff_divides_binomials_alt</b></a>]  Theorem
      
      ⊢ ∀n. prime n ⇔ 1 &lt; n ∧ ∀k. 0 &lt; k ∧ k &lt; n ⇒ binomial n k MOD n = 0
   
   [<a name="prod_1_to_n_eq_fact_n-val"><b>prod_1_to_n_eq_fact_n</b></a>]  Theorem
      
      ⊢ ∀n. PROD [1 .. n] = FACT n
   
   [<a name="rotate_0-val"><b>rotate_0</b></a>]  Theorem
      
      ⊢ ∀l. rotate 0 l = l
   
   [<a name="rotate_add-val"><b>rotate_add</b></a>]  Theorem
      
      ⊢ ∀n m l. n + m ≤ LENGTH l ⇒ rotate n (rotate m l) = rotate (n + m) l
   
   [<a name="rotate_full-val"><b>rotate_full</b></a>]  Theorem
      
      ⊢ ∀l. rotate (LENGTH l) l = l
   
   [<a name="rotate_lcancel-val"><b>rotate_lcancel</b></a>]  Theorem
      
      ⊢ ∀k l. k &lt; LENGTH l ⇒ rotate (LENGTH l − k) (rotate k l) = l
   
   [<a name="rotate_nil-val"><b>rotate_nil</b></a>]  Theorem
      
      ⊢ ∀n. rotate n [] = []
   
   [<a name="rotate_rcancel-val"><b>rotate_rcancel</b></a>]  Theorem
      
      ⊢ ∀k l. k &lt; LENGTH l ⇒ rotate k (rotate (LENGTH l − k) l) = l
   
   [<a name="rotate_same_length-val"><b>rotate_same_length</b></a>]  Theorem
      
      ⊢ ∀l n. LENGTH (rotate n l) = LENGTH l
   
   [<a name="rotate_same_set-val"><b>rotate_same_set</b></a>]  Theorem
      
      ⊢ ∀l n. set (rotate n l) = set l
   
   [<a name="rotate_shift_element-val"><b>rotate_shift_element</b></a>]  Theorem
      
      ⊢ ∀l n.
          n &lt; LENGTH l ⇒ rotate n l = EL n l::(DROP (SUC n) l ⧺ TAKE n l)
   
   [<a name="rotate_suc-val"><b>rotate_suc</b></a>]  Theorem
      
      ⊢ ∀l n. n &lt; LENGTH l ⇒ rotate (SUC n) l = rotate 1 (rotate n l)
   
   [<a name="set_lcm_empty-val"><b>set_lcm_empty</b></a>]  Theorem
      
      ⊢ set_lcm ∅ = 1
   
   [<a name="set_lcm_eq_big_lcm-val"><b>set_lcm_eq_big_lcm</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ big_lcm s = set_lcm s
   
   [<a name="set_lcm_eq_list_lcm-val"><b>set_lcm_eq_list_lcm</b></a>]  Theorem
      
      ⊢ ∀l. set_lcm (set l) = list_lcm l
   
   [<a name="set_lcm_insert-val"><b>set_lcm_insert</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀x. set_lcm (x INSERT s) = lcm x (set_lcm s)
   
   [<a name="set_lcm_is_common_multiple-val"><b>set_lcm_is_common_multiple</b></a>]  Theorem
      
      ⊢ ∀x s. FINITE s ∧ x ∈ s ⇒ x divides set_lcm s
   
   [<a name="set_lcm_is_least_common_multiple-val"><b>set_lcm_is_least_common_multiple</b></a>]  Theorem
      
      ⊢ ∀s m. FINITE s ∧ (∀x. x ∈ s ⇒ x divides m) ⇒ set_lcm s divides m
   
   [<a name="set_lcm_nonempty-val"><b>set_lcm_nonempty</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ∧ s ≠ ∅ ⇒
            set_lcm s = lcm (CHOICE s) (set_lcm (REST s))
   
   [<a name="set_lcm_sing-val"><b>set_lcm_sing</b></a>]  Theorem
      
      ⊢ ∀x. set_lcm {x} = x
   
   [<a name="sub_count_0_n-val"><b>sub_count_0_n</b></a>]  Theorem
      
      ⊢ ∀n. sub_count 0 n = if n = 0 then {∅} else ∅
   
   [<a name="sub_count_alt-val"><b>sub_count_alt</b></a>]  Theorem
      
      ⊢ ∀n k.
          sub_count n 0 = {∅} ∧ sub_count 0 (k + 1) = ∅ ∧
          sub_count (n + 1) (k + 1) =
          IMAGE (λs. n INSERT s) (sub_count n k) ∪ sub_count n (k + 1)
   
   [<a name="sub_count_count_inj-val"><b>sub_count_count_inj</b></a>]  Theorem
      
      ⊢ ∀n m. INJ (sub_count n) (upto n) 𝕌(:(num -&gt; bool) -&gt; bool)
   
   [<a name="sub_count_disjoint-val"><b>sub_count_disjoint</b></a>]  Theorem
      
      ⊢ ∀n k.
          DISJOINT (IMAGE (λs. n INSERT s) (sub_count n k))
            (sub_count n (k + 1))
   
   [<a name="sub_count_element-val"><b>sub_count_element</b></a>]  Theorem
      
      ⊢ ∀n k s. s ∈ sub_count n k ⇔ s ⊆ count n ∧ CARD s = k
   
   [<a name="sub_count_element_finite-val"><b>sub_count_element_finite</b></a>]  Theorem
      
      ⊢ ∀n k s. s ∈ sub_count n k ⇒ FINITE s
   
   [<a name="sub_count_element_no_self-val"><b>sub_count_element_no_self</b></a>]  Theorem
      
      ⊢ ∀n k s. s ∈ sub_count n k ⇒ n ∉ s
   
   [<a name="sub_count_eq_empty-val"><b>sub_count_eq_empty</b></a>]  Theorem
      
      ⊢ ∀n k. sub_count n k = ∅ ⇔ n &lt; k
   
   [<a name="sub_count_eqn-val"><b>sub_count_eqn</b></a>]  Theorem
      
      ⊢ ∀n k.
          sub_count n k =
          if k = 0 then {∅}
          else if n = 0 then ∅
          else
            IMAGE (λs. n − 1 INSERT s) (sub_count (n − 1) (k − 1)) ∪
            sub_count (n − 1) k
   
   [<a name="sub_count_equiv_class-val"><b>sub_count_equiv_class</b></a>]  Theorem
      
      ⊢ ∀n s.
          s ⊆ count n ⇒
          sub_count n (CARD s) =
          equiv_class (λs t. s =b= t) (POW (count n)) s
   
   [<a name="sub_count_finite-val"><b>sub_count_finite</b></a>]  Theorem
      
      ⊢ ∀n k. FINITE (sub_count n k)
   
   [<a name="sub_count_insert-val"><b>sub_count_insert</b></a>]  Theorem
      
      ⊢ ∀n k s. s ∈ sub_count n k ⇒ n INSERT s ∈ sub_count (n + 1) (k + 1)
   
   [<a name="sub_count_insert_card-val"><b>sub_count_insert_card</b></a>]  Theorem
      
      ⊢ ∀n k. CARD (IMAGE (λs. n INSERT s) (sub_count n k)) = n choose k
   
   [<a name="sub_count_n_0-val"><b>sub_count_n_0</b></a>]  Theorem
      
      ⊢ ∀n. sub_count n 0 = {∅}
   
   [<a name="sub_count_n_1-val"><b>sub_count_n_1</b></a>]  Theorem
      
      ⊢ ∀n. sub_count n 1 = {{j} | j &lt; n}
   
   [<a name="sub_count_n_n-val"><b>sub_count_n_n</b></a>]  Theorem
      
      ⊢ ∀n. sub_count n n = {count n}
   
   [<a name="sub_count_subset-val"><b>sub_count_subset</b></a>]  Theorem
      
      ⊢ ∀n k. sub_count n k ⊆ POW (count n)
   
   [<a name="sub_count_union-val"><b>sub_count_union</b></a>]  Theorem
      
      ⊢ ∀n k.
          sub_count (n + 1) (k + 1) =
          IMAGE (λs. n INSERT s) (sub_count n k) ∪ sub_count n (k + 1)
   
   [<a name="sub_sets_element-val"><b>sub_sets_element</b></a>]  Theorem
      
      ⊢ ∀P k s. s ∈ sub_sets P k ⇔ s ⊆ P ∧ CARD s = k
   
   [<a name="sub_sets_equiv_class-val"><b>sub_sets_equiv_class</b></a>]  Theorem
      
      ⊢ ∀s t.
          FINITE t ∧ s ⊆ t ⇒
          sub_sets t (CARD s) = equiv_class (λs t. s =b= t) (POW t) s
   
   [<a name="sub_sets_sub_count-val"><b>sub_sets_sub_count</b></a>]  Theorem
      
      ⊢ ∀n k. sub_sets (count n) k = sub_count n k
   
   [<a name="sum_1_to_n_double-val"><b>sum_1_to_n_double</b></a>]  Theorem
      
      ⊢ ∀n. TWICE (SUM [1 .. n]) = n * (n + 1)
   
   [<a name="sum_1_to_n_eq_tri_n-val"><b>sum_1_to_n_eq_tri_n</b></a>]  Theorem
      
      ⊢ ∀n. SUM [1 .. n] = tri n
   
   [<a name="sum_1_to_n_eqn-val"><b>sum_1_to_n_eqn</b></a>]  Theorem
      
      ⊢ ∀n. SUM [1 .. n] = HALF (n * (n + 1))
   
   [<a name="surj_iff_preimage_card_not_0-val"><b>surj_iff_preimage_card_not_0</b></a>]  Theorem
      
      ⊢ ∀f s t.
          FINITE s ∧ over f s t ⇒
          (SURJ f s t ⇔ ∀y. y ∈ t ⇒ CARD (preimage f s y) ≠ 0)
   
   [<a name="surj_preimage_not_empty-val"><b>surj_preimage_not_empty</b></a>]  Theorem
      
      ⊢ ∀f s t. SURJ f s t ⇔ over f s t ∧ ∀y. y ∈ t ⇒ preimage f s y ≠ ∅
   
   [<a name="tail_turn-val"><b>tail_turn</b></a>]  Theorem
      
      ⊢ ∀ls. ls ≠ [] ⇒ TL (turn ls) = FRONT ls
   
   [<a name="triple_11-val"><b>triple_11</b></a>]  Theorem
      
      ⊢ ∀a0 a1 a2 a0' a1' a2'.
          triple a0 a1 a2 = triple a0' a1' a2' ⇔
          a0 = a0' ∧ a1 = a1' ∧ a2 = a2'
   
   [<a name="triple_Axiom-val"><b>triple_Axiom</b></a>]  Theorem
      
      ⊢ ∀f. ∃fn. ∀a0 a1 a2. fn (triple a0 a1 a2) = f a0 a1 a2
   
   [<a name="triple_accessors-val"><b>triple_accessors</b></a>]  Theorem
      
      ⊢ (∀n n0 n1. (triple n n0 n1).a = n) ∧
        (∀n n0 n1. (triple n n0 n1).b = n0) ∧
        ∀n n0 n1. (triple n n0 n1).c = n1
   
   [<a name="triple_accfupds-val"><b>triple_accfupds</b></a>]  Theorem
      
      ⊢ (∀t f. (t with b updated_by f).a = t.a) ∧
        (∀t f. (t with c updated_by f).a = t.a) ∧
        (∀t f. (t with a updated_by f).b = t.b) ∧
        (∀t f. (t with c updated_by f).b = t.b) ∧
        (∀t f. (t with a updated_by f).c = t.c) ∧
        (∀t f. (t with b updated_by f).c = t.c) ∧
        (∀t f. (t with a updated_by f).a = f t.a) ∧
        (∀t f. (t with b updated_by f).b = f t.b) ∧
        ∀t f. (t with c updated_by f).c = f t.c
   
   [<a name="triple_case_cong-val"><b>triple_case_cong</b></a>]  Theorem
      
      ⊢ ∀M M' f.
          M = M' ∧
          (∀a0 a1 a2. M' = triple a0 a1 a2 ⇒ f a0 a1 a2 = f' a0 a1 a2) ⇒
          triple_CASE M f = triple_CASE M' f'
   
   [<a name="triple_case_eq-val"><b>triple_case_eq</b></a>]  Theorem
      
      ⊢ triple_CASE x f = v ⇔ ∃n n0 n1. x = triple n n0 n1 ∧ f n n0 n1 = v
   
   [<a name="triple_component_equality-val"><b>triple_component_equality</b></a>]  Theorem
      
      ⊢ ∀t1 t2. t1 = t2 ⇔ t1.a = t2.a ∧ t1.b = t2.b ∧ t1.c = t2.c
   
   [<a name="triple_fn_updates-val"><b>triple_fn_updates</b></a>]  Theorem
      
      ⊢ (∀f n n0 n1.
           triple n n0 n1 with a updated_by f = triple (f n) n0 n1) ∧
        (∀f n n0 n1.
           triple n n0 n1 with b updated_by f = triple n (f n0) n1) ∧
        ∀f n n0 n1. triple n n0 n1 with c updated_by f = triple n n0 (f n1)
   
   [<a name="triple_fupdcanon-val"><b>triple_fupdcanon</b></a>]  Theorem
      
      ⊢ (∀t g f.
           t with &lt;|b updated_by f; a updated_by g|&gt; =
           t with &lt;|a updated_by g; b updated_by f|&gt;) ∧
        (∀t g f.
           t with &lt;|c updated_by f; a updated_by g|&gt; =
           t with &lt;|a updated_by g; c updated_by f|&gt;) ∧
        ∀t g f.
          t with &lt;|c updated_by f; b updated_by g|&gt; =
          t with &lt;|b updated_by g; c updated_by f|&gt;
   
   [<a name="triple_fupdcanon_comp-val"><b>triple_fupdcanon_comp</b></a>]  Theorem
      
      ⊢ ((∀g f. b_fupd f ∘ a_fupd g = a_fupd g ∘ b_fupd f) ∧
         ∀h g f. b_fupd f ∘ a_fupd g ∘ h = a_fupd g ∘ b_fupd f ∘ h) ∧
        ((∀g f. c_fupd f ∘ a_fupd g = a_fupd g ∘ c_fupd f) ∧
         ∀h g f. c_fupd f ∘ a_fupd g ∘ h = a_fupd g ∘ c_fupd f ∘ h) ∧
        (∀g f. c_fupd f ∘ b_fupd g = b_fupd g ∘ c_fupd f) ∧
        ∀h g f. c_fupd f ∘ b_fupd g ∘ h = b_fupd g ∘ c_fupd f ∘ h
   
   [<a name="triple_fupdfupds-val"><b>triple_fupdfupds</b></a>]  Theorem
      
      ⊢ (∀t g f.
           t with &lt;|a updated_by f; a updated_by g|&gt; =
           t with a updated_by f ∘ g) ∧
        (∀t g f.
           t with &lt;|b updated_by f; b updated_by g|&gt; =
           t with b updated_by f ∘ g) ∧
        ∀t g f.
          t with &lt;|c updated_by f; c updated_by g|&gt; =
          t with c updated_by f ∘ g
   
   [<a name="triple_fupdfupds_comp-val"><b>triple_fupdfupds_comp</b></a>]  Theorem
      
      ⊢ ((∀g f. a_fupd f ∘ a_fupd g = a_fupd (f ∘ g)) ∧
         ∀h g f. a_fupd f ∘ a_fupd g ∘ h = a_fupd (f ∘ g) ∘ h) ∧
        ((∀g f. b_fupd f ∘ b_fupd g = b_fupd (f ∘ g)) ∧
         ∀h g f. b_fupd f ∘ b_fupd g ∘ h = b_fupd (f ∘ g) ∘ h) ∧
        (∀g f. c_fupd f ∘ c_fupd g = c_fupd (f ∘ g)) ∧
        ∀h g f. c_fupd f ∘ c_fupd g ∘ h = c_fupd (f ∘ g) ∘ h
   
   [<a name="triple_induction-val"><b>triple_induction</b></a>]  Theorem
      
      ⊢ ∀P. (∀n n0 n1. P (triple n n0 n1)) ⇒ ∀t. P t
   
   [<a name="triple_literal_11-val"><b>triple_literal_11</b></a>]  Theorem
      
      ⊢ ∀n11 n01 n1 n12 n02 n2.
          &lt;|a := n11; b := n01; c := n1|&gt; = &lt;|a := n12; b := n02; c := n2|&gt; ⇔
          n11 = n12 ∧ n01 = n02 ∧ n1 = n2
   
   [<a name="triple_literal_nchotomy-val"><b>triple_literal_nchotomy</b></a>]  Theorem
      
      ⊢ ∀t. ∃n1 n0 n. t = &lt;|a := n1; b := n0; c := n|&gt;
   
   [<a name="triple_nchotomy-val"><b>triple_nchotomy</b></a>]  Theorem
      
      ⊢ ∀tt. ∃n n0 n1. tt = triple n n0 n1
   
   [<a name="triple_updates_eq_literal-val"><b>triple_updates_eq_literal</b></a>]  Theorem
      
      ⊢ ∀t n1 n0 n.
          t with &lt;|a := n1; b := n0; c := n|&gt; =
          &lt;|a := n1; b := n0; c := n|&gt;
   
   [<a name="turn_eq_nil-val"><b>turn_eq_nil</b></a>]  Theorem
      
      ⊢ ∀p. turn p = [] ⇔ p = []
   
   [<a name="turn_exp_0-val"><b>turn_exp_0</b></a>]  Theorem
      
      ⊢ ∀l. turn_exp l 0 = l
   
   [<a name="turn_exp_1-val"><b>turn_exp_1</b></a>]  Theorem
      
      ⊢ ∀l. turn_exp l 1 = turn l
   
   [<a name="turn_exp_2-val"><b>turn_exp_2</b></a>]  Theorem
      
      ⊢ ∀l. turn_exp l 2 = turn (turn l)
   
   [<a name="turn_exp_SUC-val"><b>turn_exp_SUC</b></a>]  Theorem
      
      ⊢ ∀l n. turn_exp l (SUC n) = turn_exp (turn l) n
   
   [<a name="turn_exp_length-val"><b>turn_exp_length</b></a>]  Theorem
      
      ⊢ ∀l n. LENGTH (turn_exp l n) = LENGTH l
   
   [<a name="turn_exp_suc-val"><b>turn_exp_suc</b></a>]  Theorem
      
      ⊢ ∀l n. turn_exp l (SUC n) = turn (turn_exp l n)
   
   [<a name="turn_length-val"><b>turn_length</b></a>]  Theorem
      
      ⊢ ∀l. LENGTH (turn l) = LENGTH l
   
   [<a name="turn_nil-val"><b>turn_nil</b></a>]  Theorem
      
      ⊢ turn [] = []
   
   [<a name="turn_not_nil-val"><b>turn_not_nil</b></a>]  Theorem
      
      ⊢ ∀l. l ≠ [] ⇒ turn l = LAST l::FRONT l
   
   [<a name="turn_snoc-val"><b>turn_snoc</b></a>]  Theorem
      
      ⊢ ∀ls x. turn (SNOC x ls) = x::ls
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/algebra/base/.hol/objs/combinatoricsScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-2</a></em></p></body></html>
