<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure combinatoricsTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure combinatoricsTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/algebra/base/.hol/objs/combinatoricsScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature combinatoricsTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#MDILATE_def-val">MDILATE_def</a> : thm
<a name="line7"></a>    val <a href="#PROD-val">PROD</a> : thm
<a name="line8"></a>    val <a href="#PROD_ACC_DEF-val">PROD_ACC_DEF</a> : thm
<a name="line9"></a>    val <a href="#arrange_def-val">arrange_def</a> : thm
<a name="line10"></a>    val <a href="#choose_def-val">choose_def</a> : thm
<a name="line11"></a>    val <a href="#interleave_def-val">interleave_def</a> : thm
<a name="line12"></a>    val <a href="#lcm_upto_def-val">lcm_upto_def</a> : thm
<a name="line13"></a>    val <a href="#leibniz_def-val">leibniz_def</a> : thm
<a name="line14"></a>    val <a href="#leibniz_zigzag_def-val">leibniz_zigzag_def</a> : thm
<a name="line15"></a>    val <a href="#list_count_def-val">list_count_def</a> : thm
<a name="line16"></a>    val <a href="#list_lcm_def-val">list_lcm_def</a> : thm
<a name="line17"></a>    val <a href="#monocoloured_def-val">monocoloured_def</a> : thm
<a name="line18"></a>    val <a href="#multicoloured_def-val">multicoloured_def</a> : thm
<a name="line19"></a>    val <a href="#necklace_def-val">necklace_def</a> : thm
<a name="line20"></a>    val <a href="#perm_count_def-val">perm_count_def</a> : thm
<a name="line21"></a>    val <a href="#perm_def-val">perm_def</a> : thm
<a name="line22"></a>    val <a href="#perm_set_def-val">perm_set_def</a> : thm
<a name="line23"></a>    val <a href="#recordtype_triple_seldef_a_def-val">recordtype_triple_seldef_a_def</a> : thm
<a name="line24"></a>    val <a href="#recordtype_triple_seldef_a_fupd_def-val">recordtype_triple_seldef_a_fupd_def</a> : thm
<a name="line25"></a>    val <a href="#recordtype_triple_seldef_b_def-val">recordtype_triple_seldef_b_def</a> : thm
<a name="line26"></a>    val <a href="#recordtype_triple_seldef_b_fupd_def-val">recordtype_triple_seldef_b_fupd_def</a> : thm
<a name="line27"></a>    val <a href="#recordtype_triple_seldef_c_def-val">recordtype_triple_seldef_c_def</a> : thm
<a name="line28"></a>    val <a href="#recordtype_triple_seldef_c_fupd_def-val">recordtype_triple_seldef_c_fupd_def</a> : thm
<a name="line29"></a>    val <a href="#rotate_def-val">rotate_def</a> : thm
<a name="line30"></a>    val <a href="#set_lcm_def-val">set_lcm_def</a> : thm
<a name="line31"></a>    val <a href="#sub_count_def-val">sub_count_def</a> : thm
<a name="line32"></a>    val <a href="#sub_sets_def-val">sub_sets_def</a> : thm
<a name="line33"></a>    val <a href="#triple_TY_DEF-val">triple_TY_DEF</a> : thm
<a name="line34"></a>    val <a href="#triple_case_def-val">triple_case_def</a> : thm
<a name="line35"></a>    val <a href="#triple_size_def-val">triple_size_def</a> : thm
<a name="line36"></a>    val <a href="#triplet_def-val">triplet_def</a> : thm
<a name="line37"></a>    val <a href="#turn_def-val">turn_def</a> : thm
<a name="line38"></a>  
<a name="line39"></a>  (*  Theorems  *)
<a name="line40"></a>    val <a href="#CARD_LIST_TO_SET_EQ-val">CARD_LIST_TO_SET_EQ</a> : thm
<a name="line41"></a>    val <a href="#DILATE_0_0-val">DILATE_0_0</a> : thm
<a name="line42"></a>    val <a href="#DILATE_0_CONS-val">DILATE_0_CONS</a> : thm
<a name="line43"></a>    val <a href="#DILATE_0_EL-val">DILATE_0_EL</a> : thm
<a name="line44"></a>    val <a href="#DILATE_0_EQ_NIL-val">DILATE_0_EQ_NIL</a> : thm
<a name="line45"></a>    val <a href="#DILATE_0_LAST-val">DILATE_0_LAST</a> : thm
<a name="line46"></a>    val <a href="#DILATE_0_LENGTH-val">DILATE_0_LENGTH</a> : thm
<a name="line47"></a>    val <a href="#DILATE_0_LENGTH_LOWER-val">DILATE_0_LENGTH_LOWER</a> : thm
<a name="line48"></a>    val <a href="#DILATE_0_LENGTH_UPPER-val">DILATE_0_LENGTH_UPPER</a> : thm
<a name="line49"></a>    val <a href="#DILATE_0_SUC-val">DILATE_0_SUC</a> : thm
<a name="line50"></a>    val <a href="#DILATE_CONS-val">DILATE_CONS</a> : thm
<a name="line51"></a>    val <a href="#DILATE_NIL-val">DILATE_NIL</a> : thm
<a name="line52"></a>    val <a href="#DILATE_SING-val">DILATE_SING</a> : thm
<a name="line53"></a>    val <a href="#DILATE_def-val">DILATE_def</a> : thm
<a name="line54"></a>    val <a href="#DILATE_ind-val">DILATE_ind</a> : thm
<a name="line55"></a>    val <a href="#EL_ALL_PROPERTY-val">EL_ALL_PROPERTY</a> : thm
<a name="line56"></a>    val <a href="#EL_MAP3-val">EL_MAP3</a> : thm
<a name="line57"></a>    val <a href="#EVERY_ELEMENT_PROPERTY-val">EVERY_ELEMENT_PROPERTY</a> : thm
<a name="line58"></a>    val <a href="#EVERY_LT_IMP_EVERY_LE-val">EVERY_LT_IMP_EVERY_LE</a> : thm
<a name="line59"></a>    val <a href="#EVERY_MONOTONIC_MAP-val">EVERY_MONOTONIC_MAP</a> : thm
<a name="line60"></a>    val <a href="#EXISTS_triple-val">EXISTS_triple</a> : thm
<a name="line61"></a>    val <a href="#FILTER_EL_NEXT_IDX-val">FILTER_EL_NEXT_IDX</a> : thm
<a name="line62"></a>    val <a href="#FINITE_SURJ_IFF-val">FINITE_SURJ_IFF</a> : thm
<a name="line63"></a>    val <a href="#FORALL_triple-val">FORALL_triple</a> : thm
<a name="line64"></a>    val <a href="#FUNPOW_cons_eq_map_0-val">FUNPOW_cons_eq_map_0</a> : thm
<a name="line65"></a>    val <a href="#FUNPOW_cons_eq_map_1-val">FUNPOW_cons_eq_map_1</a> : thm
<a name="line66"></a>    val <a href="#FUNPOW_cons_head-val">FUNPOW_cons_head</a> : thm
<a name="line67"></a>    val <a href="#FUNSET_ALT-val">FUNSET_ALT</a> : thm
<a name="line68"></a>    val <a href="#GENLIST_MONO_DEC-val">GENLIST_MONO_DEC</a> : thm
<a name="line69"></a>    val <a href="#GENLIST_MONO_INC-val">GENLIST_MONO_INC</a> : thm
<a name="line70"></a>    val <a href="#GENLIST_binomial_index_shift-val">GENLIST_binomial_index_shift</a> : thm
<a name="line71"></a>    val <a href="#INJ_IFF_BIJ_IMAGE-val">INJ_IFF_BIJ_IMAGE</a> : thm
<a name="line72"></a>    val <a href="#INJ_IMAGE_BIJ_IFF-val">INJ_IMAGE_BIJ_IFF</a> : thm
<a name="line73"></a>    val <a href="#INJ_IMAGE_IFF-val">INJ_IMAGE_IFF</a> : thm
<a name="line74"></a>    val <a href="#LENGTH_MAP3-val">LENGTH_MAP3</a> : thm
<a name="line75"></a>    val <a href="#LIST_TO_SET_REDUCTION-val">LIST_TO_SET_REDUCTION</a> : thm
<a name="line76"></a>    val <a href="#LUPDATE_APPEND_0-val">LUPDATE_APPEND_0</a> : thm
<a name="line77"></a>    val <a href="#LUPDATE_APPEND_0_1-val">LUPDATE_APPEND_0_1</a> : thm
<a name="line78"></a>    val <a href="#LUPDATE_APPEND_1-val">LUPDATE_APPEND_1</a> : thm
<a name="line79"></a>    val <a href="#LUPDATE_DIFF_SPOT-val">LUPDATE_DIFF_SPOT</a> : thm
<a name="line80"></a>    val <a href="#LUPDATE_EL-val">LUPDATE_EL</a> : thm
<a name="line81"></a>    val <a href="#LUPDATE_LEN-val">LUPDATE_LEN</a> : thm
<a name="line82"></a>    val <a href="#LUPDATE_SAME_SPOT-val">LUPDATE_SAME_SPOT</a> : thm
<a name="line83"></a>    val <a href="#MAP2_LE-val">MAP2_LE</a> : thm
<a name="line84"></a>    val <a href="#MAP3-val">MAP3</a> : thm
<a name="line85"></a>    val <a href="#MAP3_DEF-val">MAP3_DEF</a> : thm
<a name="line86"></a>    val <a href="#MAP3_IND-val">MAP3_IND</a> : thm
<a name="line87"></a>    val <a href="#MAP3_LE-val">MAP3_LE</a> : thm
<a name="line88"></a>    val <a href="#MAP_LE-val">MAP_LE</a> : thm
<a name="line89"></a>    val <a href="#MAX_LIST_MONO_MAP-val">MAX_LIST_MONO_MAP</a> : thm
<a name="line90"></a>    val <a href="#MDILATE_0-val">MDILATE_0</a> : thm
<a name="line91"></a>    val <a href="#MDILATE_1-val">MDILATE_1</a> : thm
<a name="line92"></a>    val <a href="#MDILATE_CONS-val">MDILATE_CONS</a> : thm
<a name="line93"></a>    val <a href="#MDILATE_EL-val">MDILATE_EL</a> : thm
<a name="line94"></a>    val <a href="#MDILATE_EQ_NIL-val">MDILATE_EQ_NIL</a> : thm
<a name="line95"></a>    val <a href="#MDILATE_LAST-val">MDILATE_LAST</a> : thm
<a name="line96"></a>    val <a href="#MDILATE_LENGTH-val">MDILATE_LENGTH</a> : thm
<a name="line97"></a>    val <a href="#MDILATE_LENGTH_LOWER-val">MDILATE_LENGTH_LOWER</a> : thm
<a name="line98"></a>    val <a href="#MDILATE_LENGTH_UPPER-val">MDILATE_LENGTH_UPPER</a> : thm
<a name="line99"></a>    val <a href="#MDILATE_NIL-val">MDILATE_NIL</a> : thm
<a name="line100"></a>    val <a href="#MDILATE_SING-val">MDILATE_SING</a> : thm
<a name="line101"></a>    val <a href="#MEM_MAP2-val">MEM_MAP2</a> : thm
<a name="line102"></a>    val <a href="#MEM_MAP2_LOWER-val">MEM_MAP2_LOWER</a> : thm
<a name="line103"></a>    val <a href="#MEM_MAP2_UPPER-val">MEM_MAP2_UPPER</a> : thm
<a name="line104"></a>    val <a href="#MEM_MAP3-val">MEM_MAP3</a> : thm
<a name="line105"></a>    val <a href="#MEM_MAP3_LOWER-val">MEM_MAP3_LOWER</a> : thm
<a name="line106"></a>    val <a href="#MEM_MAP3_UPPER-val">MEM_MAP3_UPPER</a> : thm
<a name="line107"></a>    val <a href="#MEM_MAP_LOWER-val">MEM_MAP_LOWER</a> : thm
<a name="line108"></a>    val <a href="#MEM_MAP_UPPER-val">MEM_MAP_UPPER</a> : thm
<a name="line109"></a>    val <a href="#MIN_LIST_MONO_MAP-val">MIN_LIST_MONO_MAP</a> : thm
<a name="line110"></a>    val <a href="#MONO_LIST_TO_SET-val">MONO_LIST_TO_SET</a> : thm
<a name="line111"></a>    val <a href="#PAD_LEFT_0-val">PAD_LEFT_0</a> : thm
<a name="line112"></a>    val <a href="#PAD_LEFT_BY_LEFT-val">PAD_LEFT_BY_LEFT</a> : thm
<a name="line113"></a>    val <a href="#PAD_LEFT_BY_RIGHT-val">PAD_LEFT_BY_RIGHT</a> : thm
<a name="line114"></a>    val <a href="#PAD_LEFT_CONS-val">PAD_LEFT_CONS</a> : thm
<a name="line115"></a>    val <a href="#PAD_LEFT_EQ_NIL-val">PAD_LEFT_EQ_NIL</a> : thm
<a name="line116"></a>    val <a href="#PAD_LEFT_ID-val">PAD_LEFT_ID</a> : thm
<a name="line117"></a>    val <a href="#PAD_LEFT_LAST-val">PAD_LEFT_LAST</a> : thm
<a name="line118"></a>    val <a href="#PAD_LEFT_LENGTH-val">PAD_LEFT_LENGTH</a> : thm
<a name="line119"></a>    val <a href="#PAD_LEFT_NIL-val">PAD_LEFT_NIL</a> : thm
<a name="line120"></a>    val <a href="#PAD_LEFT_NIL_EQ-val">PAD_LEFT_NIL_EQ</a> : thm
<a name="line121"></a>    val <a href="#PAD_RIGHT_0-val">PAD_RIGHT_0</a> : thm
<a name="line122"></a>    val <a href="#PAD_RIGHT_BY_LEFT-val">PAD_RIGHT_BY_LEFT</a> : thm
<a name="line123"></a>    val <a href="#PAD_RIGHT_BY_RIGHT-val">PAD_RIGHT_BY_RIGHT</a> : thm
<a name="line124"></a>    val <a href="#PAD_RIGHT_CONS-val">PAD_RIGHT_CONS</a> : thm
<a name="line125"></a>    val <a href="#PAD_RIGHT_EQ_NIL-val">PAD_RIGHT_EQ_NIL</a> : thm
<a name="line126"></a>    val <a href="#PAD_RIGHT_ID-val">PAD_RIGHT_ID</a> : thm
<a name="line127"></a>    val <a href="#PAD_RIGHT_LENGTH-val">PAD_RIGHT_LENGTH</a> : thm
<a name="line128"></a>    val <a href="#PAD_RIGHT_NIL-val">PAD_RIGHT_NIL</a> : thm
<a name="line129"></a>    val <a href="#PAD_RIGHT_NIL_EQ-val">PAD_RIGHT_NIL_EQ</a> : thm
<a name="line130"></a>    val <a href="#PAD_RIGHT_SNOC-val">PAD_RIGHT_SNOC</a> : thm
<a name="line131"></a>    val <a href="#POSITIVE_THM-val">POSITIVE_THM</a> : thm
<a name="line132"></a>    val <a href="#PROD_ACC_PROD_LEM-val">PROD_ACC_PROD_LEM</a> : thm
<a name="line133"></a>    val <a href="#PROD_ACC_SUM_LEM-val">PROD_ACC_SUM_LEM</a> : thm
<a name="line134"></a>    val <a href="#PROD_APPEND-val">PROD_APPEND</a> : thm
<a name="line135"></a>    val <a href="#PROD_CONS-val">PROD_CONS</a> : thm
<a name="line136"></a>    val <a href="#PROD_CONSTANT-val">PROD_CONSTANT</a> : thm
<a name="line137"></a>    val <a href="#PROD_EQ_0-val">PROD_EQ_0</a> : thm
<a name="line138"></a>    val <a href="#PROD_GENLIST_K-val">PROD_GENLIST_K</a> : thm
<a name="line139"></a>    val <a href="#PROD_IMAGE_eq_PROD_MAP_SET_TO_LIST-val">PROD_IMAGE_eq_PROD_MAP_SET_TO_LIST</a> : thm
<a name="line140"></a>    val <a href="#PROD_MAP_FOLDL-val">PROD_MAP_FOLDL</a> : thm
<a name="line141"></a>    val <a href="#PROD_NIL-val">PROD_NIL</a> : thm
<a name="line142"></a>    val <a href="#PROD_POS-val">PROD_POS</a> : thm
<a name="line143"></a>    val <a href="#PROD_POS_ALT-val">PROD_POS_ALT</a> : thm
<a name="line144"></a>    val <a href="#PROD_PROD_ACC-val">PROD_PROD_ACC</a> : thm
<a name="line145"></a>    val <a href="#PROD_SING-val">PROD_SING</a> : thm
<a name="line146"></a>    val <a href="#PROD_SNOC-val">PROD_SNOC</a> : thm
<a name="line147"></a>    val <a href="#PROD_SQUARING_LIST-val">PROD_SQUARING_LIST</a> : thm
<a name="line148"></a>    val <a href="#PROD_eq_1-val">PROD_eq_1</a> : thm
<a name="line149"></a>    val <a href="#PROD_eval-val">PROD_eval</a> : thm
<a name="line150"></a>    val <a href="#SUM_ADD_GENLIST-val">SUM_ADD_GENLIST</a> : thm
<a name="line151"></a>    val <a href="#SUM_CONS-val">SUM_CONS</a> : thm
<a name="line152"></a>    val <a href="#SUM_CONSTANT-val">SUM_CONSTANT</a> : thm
<a name="line153"></a>    val <a href="#SUM_DECOMPOSE_FIRST-val">SUM_DECOMPOSE_FIRST</a> : thm
<a name="line154"></a>    val <a href="#SUM_DECOMPOSE_FIRST_LAST-val">SUM_DECOMPOSE_FIRST_LAST</a> : thm
<a name="line155"></a>    val <a href="#SUM_DECOMPOSE_LAST-val">SUM_DECOMPOSE_LAST</a> : thm
<a name="line156"></a>    val <a href="#SUM_DOUBLING_LIST-val">SUM_DOUBLING_LIST</a> : thm
<a name="line157"></a>    val <a href="#SUM_EQ_0-val">SUM_EQ_0</a> : thm
<a name="line158"></a>    val <a href="#SUM_GENLIST-val">SUM_GENLIST</a> : thm
<a name="line159"></a>    val <a href="#SUM_GENLIST_APPEND-val">SUM_GENLIST_APPEND</a> : thm
<a name="line160"></a>    val <a href="#SUM_GENLIST_K-val">SUM_GENLIST_K</a> : thm
<a name="line161"></a>    val <a href="#SUM_GENLIST_MOD-val">SUM_GENLIST_MOD</a> : thm
<a name="line162"></a>    val <a href="#SUM_GENLIST_REVERSE-val">SUM_GENLIST_REVERSE</a> : thm
<a name="line163"></a>    val <a href="#SUM_IMAGE_count-val">SUM_IMAGE_count</a> : thm
<a name="line164"></a>    val <a href="#SUM_IMAGE_upto-val">SUM_IMAGE_upto</a> : thm
<a name="line165"></a>    val <a href="#SUM_LE-val">SUM_LE</a> : thm
<a name="line166"></a>    val <a href="#SUM_LEFT_ADD_DISTRIB-val">SUM_LEFT_ADD_DISTRIB</a> : thm
<a name="line167"></a>    val <a href="#SUM_LE_EL-val">SUM_LE_EL</a> : thm
<a name="line168"></a>    val <a href="#SUM_LE_MEM-val">SUM_LE_MEM</a> : thm
<a name="line169"></a>    val <a href="#SUM_LE_SUM_EL-val">SUM_LE_SUM_EL</a> : thm
<a name="line170"></a>    val <a href="#SUM_LOWER-val">SUM_LOWER</a> : thm
<a name="line171"></a>    val <a href="#SUM_MAP2_K-val">SUM_MAP2_K</a> : thm
<a name="line172"></a>    val <a href="#SUM_MAP2_UPPER-val">SUM_MAP2_UPPER</a> : thm
<a name="line173"></a>    val <a href="#SUM_MAP3_K-val">SUM_MAP3_K</a> : thm
<a name="line174"></a>    val <a href="#SUM_MAP3_UPPER-val">SUM_MAP3_UPPER</a> : thm
<a name="line175"></a>    val <a href="#SUM_MAP_K-val">SUM_MAP_K</a> : thm
<a name="line176"></a>    val <a href="#SUM_MAP_K_LE-val">SUM_MAP_K_LE</a> : thm
<a name="line177"></a>    val <a href="#SUM_MAP_LE-val">SUM_MAP_LE</a> : thm
<a name="line178"></a>    val <a href="#SUM_MAP_LT-val">SUM_MAP_LT</a> : thm
<a name="line179"></a>    val <a href="#SUM_MAP_UPPER-val">SUM_MAP_UPPER</a> : thm
<a name="line180"></a>    val <a href="#SUM_MOD-val">SUM_MOD</a> : thm
<a name="line181"></a>    val <a href="#SUM_MONO_MAP-val">SUM_MONO_MAP</a> : thm
<a name="line182"></a>    val <a href="#SUM_MONO_MAP2-val">SUM_MONO_MAP2</a> : thm
<a name="line183"></a>    val <a href="#SUM_MONO_MAP3-val">SUM_MONO_MAP3</a> : thm
<a name="line184"></a>    val <a href="#SUM_MULT-val">SUM_MULT</a> : thm
<a name="line185"></a>    val <a href="#SUM_NIL-val">SUM_NIL</a> : thm
<a name="line186"></a>    val <a href="#SUM_RIGHT_ADD_DISTRIB-val">SUM_RIGHT_ADD_DISTRIB</a> : thm
<a name="line187"></a>    val <a href="#SUM_SING-val">SUM_SING</a> : thm
<a name="line188"></a>    val <a href="#SUM_UPPER-val">SUM_UPPER</a> : thm
<a name="line189"></a>    val <a href="#SURJ_CARD_IMAGE_EQ-val">SURJ_CARD_IMAGE_EQ</a> : thm
<a name="line190"></a>    val <a href="#arithmetic_sum_eqn-val">arithmetic_sum_eqn</a> : thm
<a name="line191"></a>    val <a href="#arithmetic_sum_eqn_alt-val">arithmetic_sum_eqn_alt</a> : thm
<a name="line192"></a>    val <a href="#arrange_0_n-val">arrange_0_n</a> : thm
<a name="line193"></a>    val <a href="#arrange_alt-val">arrange_alt</a> : thm
<a name="line194"></a>    val <a href="#arrange_eq_0-val">arrange_eq_0</a> : thm
<a name="line195"></a>    val <a href="#arrange_eqn-val">arrange_eqn</a> : thm
<a name="line196"></a>    val <a href="#arrange_formula-val">arrange_formula</a> : thm
<a name="line197"></a>    val <a href="#arrange_formula2-val">arrange_formula2</a> : thm
<a name="line198"></a>    val <a href="#arrange_n_0-val">arrange_n_0</a> : thm
<a name="line199"></a>    val <a href="#arrange_n_n-val">arrange_n_n</a> : thm
<a name="line200"></a>    val <a href="#arrange_n_n_alt-val">arrange_n_n_alt</a> : thm
<a name="line201"></a>    val <a href="#beta_0_n-val">beta_0_n</a> : thm
<a name="line202"></a>    val <a href="#beta_alt-val">beta_alt</a> : thm
<a name="line203"></a>    val <a href="#beta_divides_beta_factor-val">beta_divides_beta_factor</a> : thm
<a name="line204"></a>    val <a href="#beta_eq_0-val">beta_eq_0</a> : thm
<a name="line205"></a>    val <a href="#beta_eqn-val">beta_eqn</a> : thm
<a name="line206"></a>    val <a href="#beta_horizontal_0-val">beta_horizontal_0</a> : thm
<a name="line207"></a>    val <a href="#beta_horizontal_alt-val">beta_horizontal_alt</a> : thm
<a name="line208"></a>    val <a href="#beta_horizontal_element-val">beta_horizontal_element</a> : thm
<a name="line209"></a>    val <a href="#beta_horizontal_eqn-val">beta_horizontal_eqn</a> : thm
<a name="line210"></a>    val <a href="#beta_horizontal_len-val">beta_horizontal_len</a> : thm
<a name="line211"></a>    val <a href="#beta_horizontal_mem-val">beta_horizontal_mem</a> : thm
<a name="line212"></a>    val <a href="#beta_horizontal_mem_iff-val">beta_horizontal_mem_iff</a> : thm
<a name="line213"></a>    val <a href="#beta_horizontal_member-val">beta_horizontal_member</a> : thm
<a name="line214"></a>    val <a href="#beta_less_0-val">beta_less_0</a> : thm
<a name="line215"></a>    val <a href="#beta_n_0-val">beta_n_0</a> : thm
<a name="line216"></a>    val <a href="#beta_pos-val">beta_pos</a> : thm
<a name="line217"></a>    val <a href="#beta_sym-val">beta_sym</a> : thm
<a name="line218"></a>    val <a href="#big_lcm_corner_transform-val">big_lcm_corner_transform</a> : thm
<a name="line219"></a>    val <a href="#big_lcm_count_lower_bound-val">big_lcm_count_lower_bound</a> : thm
<a name="line220"></a>    val <a href="#big_lcm_eq_list_lcm-val">big_lcm_eq_list_lcm</a> : thm
<a name="line221"></a>    val <a href="#big_lcm_ge_max-val">big_lcm_ge_max</a> : thm
<a name="line222"></a>    val <a href="#big_lcm_lower_bound-val">big_lcm_lower_bound</a> : thm
<a name="line223"></a>    val <a href="#big_lcm_natural_eqn-val">big_lcm_natural_eqn</a> : thm
<a name="line224"></a>    val <a href="#big_lcm_non_decreasing-val">big_lcm_non_decreasing</a> : thm
<a name="line225"></a>    val <a href="#big_lcm_row_transform-val">big_lcm_row_transform</a> : thm
<a name="line226"></a>    val <a href="#big_lcm_seg_transform-val">big_lcm_seg_transform</a> : thm
<a name="line227"></a>    val <a href="#bij_eq_card-val">bij_eq_card</a> : thm
<a name="line228"></a>    val <a href="#bij_eq_card_eq-val">bij_eq_card_eq</a> : thm
<a name="line229"></a>    val <a href="#bij_eq_count-val">bij_eq_count</a> : thm
<a name="line230"></a>    val <a href="#bij_eq_empty-val">bij_eq_empty</a> : thm
<a name="line231"></a>    val <a href="#bij_eq_equiv_on-val">bij_eq_equiv_on</a> : thm
<a name="line232"></a>    val <a href="#bij_eq_finite-val">bij_eq_finite</a> : thm
<a name="line233"></a>    val <a href="#bij_eq_refl-val">bij_eq_refl</a> : thm
<a name="line234"></a>    val <a href="#bij_eq_sym-val">bij_eq_sym</a> : thm
<a name="line235"></a>    val <a href="#bij_eq_trans-val">bij_eq_trans</a> : thm
<a name="line236"></a>    val <a href="#bij_iff_preimage_card_eq_1-val">bij_iff_preimage_card_eq_1</a> : thm
<a name="line237"></a>    val <a href="#bij_preimage_sing-val">bij_preimage_sing</a> : thm
<a name="line238"></a>    val <a href="#binomial_0_n-val">binomial_0_n</a> : thm
<a name="line239"></a>    val <a href="#binomial_1_n-val">binomial_1_n</a> : thm
<a name="line240"></a>    val <a href="#binomial_alt-val">binomial_alt</a> : thm
<a name="line241"></a>    val <a href="#binomial_compute-val">binomial_compute</a> : thm
<a name="line242"></a>    val <a href="#binomial_def-val">binomial_def</a> : thm
<a name="line243"></a>    val <a href="#binomial_eq_0-val">binomial_eq_0</a> : thm
<a name="line244"></a>    val <a href="#binomial_fact-val">binomial_fact</a> : thm
<a name="line245"></a>    val <a href="#binomial_formula-val">binomial_formula</a> : thm
<a name="line246"></a>    val <a href="#binomial_formula2-val">binomial_formula2</a> : thm
<a name="line247"></a>    val <a href="#binomial_formula3-val">binomial_formula3</a> : thm
<a name="line248"></a>    val <a href="#binomial_horizontal_0-val">binomial_horizontal_0</a> : thm
<a name="line249"></a>    val <a href="#binomial_horizontal_element-val">binomial_horizontal_element</a> : thm
<a name="line250"></a>    val <a href="#binomial_horizontal_len-val">binomial_horizontal_len</a> : thm
<a name="line251"></a>    val <a href="#binomial_horizontal_max-val">binomial_horizontal_max</a> : thm
<a name="line252"></a>    val <a href="#binomial_horizontal_mem-val">binomial_horizontal_mem</a> : thm
<a name="line253"></a>    val <a href="#binomial_horizontal_mem_iff-val">binomial_horizontal_mem_iff</a> : thm
<a name="line254"></a>    val <a href="#binomial_horizontal_member-val">binomial_horizontal_member</a> : thm
<a name="line255"></a>    val <a href="#binomial_horizontal_pos-val">binomial_horizontal_pos</a> : thm
<a name="line256"></a>    val <a href="#binomial_horizontal_pos_alt-val">binomial_horizontal_pos_alt</a> : thm
<a name="line257"></a>    val <a href="#binomial_horizontal_sum-val">binomial_horizontal_sum</a> : thm
<a name="line258"></a>    val <a href="#binomial_iff-val">binomial_iff</a> : thm
<a name="line259"></a>    val <a href="#binomial_ind-val">binomial_ind</a> : thm
<a name="line260"></a>    val <a href="#binomial_index_shift-val">binomial_index_shift</a> : thm
<a name="line261"></a>    val <a href="#binomial_is_integer-val">binomial_is_integer</a> : thm
<a name="line262"></a>    val <a href="#binomial_less_0-val">binomial_less_0</a> : thm
<a name="line263"></a>    val <a href="#binomial_max-val">binomial_max</a> : thm
<a name="line264"></a>    val <a href="#binomial_middle_by_stirling-val">binomial_middle_by_stirling</a> : thm
<a name="line265"></a>    val <a href="#binomial_middle_upper_bound-val">binomial_middle_upper_bound</a> : thm
<a name="line266"></a>    val <a href="#binomial_mod_zero-val">binomial_mod_zero</a> : thm
<a name="line267"></a>    val <a href="#binomial_mod_zero_alt-val">binomial_mod_zero_alt</a> : thm
<a name="line268"></a>    val <a href="#binomial_monotone-val">binomial_monotone</a> : thm
<a name="line269"></a>    val <a href="#binomial_n_0-val">binomial_n_0</a> : thm
<a name="line270"></a>    val <a href="#binomial_n_1-val">binomial_n_1</a> : thm
<a name="line271"></a>    val <a href="#binomial_n_k-val">binomial_n_k</a> : thm
<a name="line272"></a>    val <a href="#binomial_n_n-val">binomial_n_n</a> : thm
<a name="line273"></a>    val <a href="#binomial_pos-val">binomial_pos</a> : thm
<a name="line274"></a>    val <a href="#binomial_product_identity-val">binomial_product_identity</a> : thm
<a name="line275"></a>    val <a href="#binomial_range_shift-val">binomial_range_shift</a> : thm
<a name="line276"></a>    val <a href="#binomial_range_shift_alt-val">binomial_range_shift_alt</a> : thm
<a name="line277"></a>    val <a href="#binomial_recurrence-val">binomial_recurrence</a> : thm
<a name="line278"></a>    val <a href="#binomial_right-val">binomial_right</a> : thm
<a name="line279"></a>    val <a href="#binomial_right_eqn-val">binomial_right_eqn</a> : thm
<a name="line280"></a>    val <a href="#binomial_row_max-val">binomial_row_max</a> : thm
<a name="line281"></a>    val <a href="#binomial_sum-val">binomial_sum</a> : thm
<a name="line282"></a>    val <a href="#binomial_sum_alt-val">binomial_sum_alt</a> : thm
<a name="line283"></a>    val <a href="#binomial_sym-val">binomial_sym</a> : thm
<a name="line284"></a>    val <a href="#binomial_term_merge_x-val">binomial_term_merge_x</a> : thm
<a name="line285"></a>    val <a href="#binomial_term_merge_y-val">binomial_term_merge_y</a> : thm
<a name="line286"></a>    val <a href="#binomial_thm-val">binomial_thm</a> : thm
<a name="line287"></a>    val <a href="#binomial_thm_alt-val">binomial_thm_alt</a> : thm
<a name="line288"></a>    val <a href="#binomial_thm_prime-val">binomial_thm_prime</a> : thm
<a name="line289"></a>    val <a href="#binomial_up-val">binomial_up</a> : thm
<a name="line290"></a>    val <a href="#binomial_up_eqn-val">binomial_up_eqn</a> : thm
<a name="line291"></a>    val <a href="#choose_0_n-val">choose_0_n</a> : thm
<a name="line292"></a>    val <a href="#choose_1_n-val">choose_1_n</a> : thm
<a name="line293"></a>    val <a href="#choose_alt-val">choose_alt</a> : thm
<a name="line294"></a>    val <a href="#choose_eq_0-val">choose_eq_0</a> : thm
<a name="line295"></a>    val <a href="#choose_eqn-val">choose_eqn</a> : thm
<a name="line296"></a>    val <a href="#choose_n_0-val">choose_n_0</a> : thm
<a name="line297"></a>    val <a href="#choose_n_1-val">choose_n_1</a> : thm
<a name="line298"></a>    val <a href="#choose_n_n-val">choose_n_n</a> : thm
<a name="line299"></a>    val <a href="#choose_recurrence-val">choose_recurrence</a> : thm
<a name="line300"></a>    val <a href="#choose_sum_over_all-val">choose_sum_over_all</a> : thm
<a name="line301"></a>    val <a href="#choose_sum_over_count-val">choose_sum_over_count</a> : thm
<a name="line302"></a>    val <a href="#count_power_partition-val">count_power_partition</a> : thm
<a name="line303"></a>    val <a href="#datatype_triple-val">datatype_triple</a> : thm
<a name="line304"></a>    val <a href="#divides_binomials_imp_prime-val">divides_binomials_imp_prime</a> : thm
<a name="line305"></a>    val <a href="#feq_set_equiv-val">feq_set_equiv</a> : thm
<a name="line306"></a>    val <a href="#finite_surj_inj_iff-val">finite_surj_inj_iff</a> : thm
<a name="line307"></a>    val <a href="#gcd_prime_product_property-val">gcd_prime_product_property</a> : thm
<a name="line308"></a>    val <a href="#geometric_sum_eqn-val">geometric_sum_eqn</a> : thm
<a name="line309"></a>    val <a href="#geometric_sum_eqn_alt-val">geometric_sum_eqn_alt</a> : thm
<a name="line310"></a>    val <a href="#head_turn-val">head_turn</a> : thm
<a name="line311"></a>    val <a href="#head_turn_exp-val">head_turn_exp</a> : thm
<a name="line312"></a>    val <a href="#inj_iff_preimage_card_le_1-val">inj_iff_preimage_card_le_1</a> : thm
<a name="line313"></a>    val <a href="#inj_preimage_empty_or_sing-val">inj_preimage_empty_or_sing</a> : thm
<a name="line314"></a>    val <a href="#interleave_alt-val">interleave_alt</a> : thm
<a name="line315"></a>    val <a href="#interleave_card-val">interleave_card</a> : thm
<a name="line316"></a>    val <a href="#interleave_count_inj-val">interleave_count_inj</a> : thm
<a name="line317"></a>    val <a href="#interleave_disjoint-val">interleave_disjoint</a> : thm
<a name="line318"></a>    val <a href="#interleave_distinct-val">interleave_distinct</a> : thm
<a name="line319"></a>    val <a href="#interleave_distinct_alt-val">interleave_distinct_alt</a> : thm
<a name="line320"></a>    val <a href="#interleave_element-val">interleave_element</a> : thm
<a name="line321"></a>    val <a href="#interleave_eq-val">interleave_eq</a> : thm
<a name="line322"></a>    val <a href="#interleave_finite-val">interleave_finite</a> : thm
<a name="line323"></a>    val <a href="#interleave_has_cons-val">interleave_has_cons</a> : thm
<a name="line324"></a>    val <a href="#interleave_length-val">interleave_length</a> : thm
<a name="line325"></a>    val <a href="#interleave_nil-val">interleave_nil</a> : thm
<a name="line326"></a>    val <a href="#interleave_not_empty-val">interleave_not_empty</a> : thm
<a name="line327"></a>    val <a href="#interleave_revert-val">interleave_revert</a> : thm
<a name="line328"></a>    val <a href="#interleave_revert_count-val">interleave_revert_count</a> : thm
<a name="line329"></a>    val <a href="#interleave_set-val">interleave_set</a> : thm
<a name="line330"></a>    val <a href="#interleave_set_alt-val">interleave_set_alt</a> : thm
<a name="line331"></a>    val <a href="#lcm_lower_bound-val">lcm_lower_bound</a> : thm
<a name="line332"></a>    val <a href="#lcm_lower_bound_by_big_lcm-val">lcm_lower_bound_by_big_lcm</a> : thm
<a name="line333"></a>    val <a href="#lcm_lower_bound_by_big_lcm_stirling-val">lcm_lower_bound_by_big_lcm_stirling</a> : thm
<a name="line334"></a>    val <a href="#lcm_lower_bound_by_list_lcm-val">lcm_lower_bound_by_list_lcm</a> : thm
<a name="line335"></a>    val <a href="#lcm_lower_bound_by_list_lcm_stirling-val">lcm_lower_bound_by_list_lcm_stirling</a> : thm
<a name="line336"></a>    val <a href="#lcm_prime_product_property-val">lcm_prime_product_property</a> : thm
<a name="line337"></a>    val <a href="#lcm_run_0-val">lcm_run_0</a> : thm
<a name="line338"></a>    val <a href="#lcm_run_1-val">lcm_run_1</a> : thm
<a name="line339"></a>    val <a href="#lcm_run_alt-val">lcm_run_alt</a> : thm
<a name="line340"></a>    val <a href="#lcm_run_beta_divisor-val">lcm_run_beta_divisor</a> : thm
<a name="line341"></a>    val <a href="#lcm_run_bound_recurrence-val">lcm_run_bound_recurrence</a> : thm
<a name="line342"></a>    val <a href="#lcm_run_by_FOLDL-val">lcm_run_by_FOLDL</a> : thm
<a name="line343"></a>    val <a href="#lcm_run_by_FOLDR-val">lcm_run_by_FOLDR</a> : thm
<a name="line344"></a>    val <a href="#lcm_run_by_beta_horizontal-val">lcm_run_by_beta_horizontal</a> : thm
<a name="line345"></a>    val <a href="#lcm_run_divides_property-val">lcm_run_divides_property</a> : thm
<a name="line346"></a>    val <a href="#lcm_run_divides_property_alt-val">lcm_run_divides_property_alt</a> : thm
<a name="line347"></a>    val <a href="#lcm_run_divisors-val">lcm_run_divisors</a> : thm
<a name="line348"></a>    val <a href="#lcm_run_even_lower-val">lcm_run_even_lower</a> : thm
<a name="line349"></a>    val <a href="#lcm_run_even_lower_alt-val">lcm_run_even_lower_alt</a> : thm
<a name="line350"></a>    val <a href="#lcm_run_leibniz_divisor-val">lcm_run_leibniz_divisor</a> : thm
<a name="line351"></a>    val <a href="#lcm_run_lower-val">lcm_run_lower</a> : thm
<a name="line352"></a>    val <a href="#lcm_run_lower_better-val">lcm_run_lower_better</a> : thm
<a name="line353"></a>    val <a href="#lcm_run_lower_better_iff-val">lcm_run_lower_better_iff</a> : thm
<a name="line354"></a>    val <a href="#lcm_run_lower_even-val">lcm_run_lower_even</a> : thm
<a name="line355"></a>    val <a href="#lcm_run_lower_even_iff-val">lcm_run_lower_even_iff</a> : thm
<a name="line356"></a>    val <a href="#lcm_run_lower_good-val">lcm_run_lower_good</a> : thm
<a name="line357"></a>    val <a href="#lcm_run_lower_odd-val">lcm_run_lower_odd</a> : thm
<a name="line358"></a>    val <a href="#lcm_run_lower_odd_iff-val">lcm_run_lower_odd_iff</a> : thm
<a name="line359"></a>    val <a href="#lcm_run_lower_simple-val">lcm_run_lower_simple</a> : thm
<a name="line360"></a>    val <a href="#lcm_run_monotone-val">lcm_run_monotone</a> : thm
<a name="line361"></a>    val <a href="#lcm_run_odd_factor-val">lcm_run_odd_factor</a> : thm
<a name="line362"></a>    val <a href="#lcm_run_odd_lower-val">lcm_run_odd_lower</a> : thm
<a name="line363"></a>    val <a href="#lcm_run_odd_lower_alt-val">lcm_run_odd_lower_alt</a> : thm
<a name="line364"></a>    val <a href="#lcm_run_pos-val">lcm_run_pos</a> : thm
<a name="line365"></a>    val <a href="#lcm_run_small-val">lcm_run_small</a> : thm
<a name="line366"></a>    val <a href="#lcm_run_suc-val">lcm_run_suc</a> : thm
<a name="line367"></a>    val <a href="#lcm_run_upper_bound-val">lcm_run_upper_bound</a> : thm
<a name="line368"></a>    val <a href="#lcm_upto_0-val">lcm_upto_0</a> : thm
<a name="line369"></a>    val <a href="#lcm_upto_1-val">lcm_upto_1</a> : thm
<a name="line370"></a>    val <a href="#lcm_upto_SUC-val">lcm_upto_SUC</a> : thm
<a name="line371"></a>    val <a href="#lcm_upto_alt-val">lcm_upto_alt</a> : thm
<a name="line372"></a>    val <a href="#lcm_upto_compute-val">lcm_upto_compute</a> : thm
<a name="line373"></a>    val <a href="#lcm_upto_divisors-val">lcm_upto_divisors</a> : thm
<a name="line374"></a>    val <a href="#lcm_upto_eq_list_lcm-val">lcm_upto_eq_list_lcm</a> : thm
<a name="line375"></a>    val <a href="#lcm_upto_leibniz_divisor-val">lcm_upto_leibniz_divisor</a> : thm
<a name="line376"></a>    val <a href="#lcm_upto_lower-val">lcm_upto_lower</a> : thm
<a name="line377"></a>    val <a href="#lcm_upto_lower_better-val">lcm_upto_lower_better</a> : thm
<a name="line378"></a>    val <a href="#lcm_upto_lower_even-val">lcm_upto_lower_even</a> : thm
<a name="line379"></a>    val <a href="#lcm_upto_lower_odd-val">lcm_upto_lower_odd</a> : thm
<a name="line380"></a>    val <a href="#lcm_upto_monotone-val">lcm_upto_monotone</a> : thm
<a name="line381"></a>    val <a href="#lcm_upto_pos-val">lcm_upto_pos</a> : thm
<a name="line382"></a>    val <a href="#lcm_upto_small-val">lcm_upto_small</a> : thm
<a name="line383"></a>    val <a href="#leibniz_0_n-val">leibniz_0_n</a> : thm
<a name="line384"></a>    val <a href="#leibniz_alt-val">leibniz_alt</a> : thm
<a name="line385"></a>    val <a href="#leibniz_binomial_identity-val">leibniz_binomial_identity</a> : thm
<a name="line386"></a>    val <a href="#leibniz_col_arm_0-val">leibniz_col_arm_0</a> : thm
<a name="line387"></a>    val <a href="#leibniz_col_arm_1-val">leibniz_col_arm_1</a> : thm
<a name="line388"></a>    val <a href="#leibniz_col_arm_cons-val">leibniz_col_arm_cons</a> : thm
<a name="line389"></a>    val <a href="#leibniz_col_arm_el-val">leibniz_col_arm_el</a> : thm
<a name="line390"></a>    val <a href="#leibniz_col_arm_len-val">leibniz_col_arm_len</a> : thm
<a name="line391"></a>    val <a href="#leibniz_col_arm_n_0-val">leibniz_col_arm_n_0</a> : thm
<a name="line392"></a>    val <a href="#leibniz_col_arm_wriggle_row_arm-val">leibniz_col_arm_wriggle_row_arm</a> : thm
<a name="line393"></a>    val <a href="#leibniz_col_def-val">leibniz_col_def</a> : thm
<a name="line394"></a>    val <a href="#leibniz_col_eq_natural-val">leibniz_col_eq_natural</a> : thm
<a name="line395"></a>    val <a href="#leibniz_def_alt-val">leibniz_def_alt</a> : thm
<a name="line396"></a>    val <a href="#leibniz_divides_leibniz_factor-val">leibniz_divides_leibniz_factor</a> : thm
<a name="line397"></a>    val <a href="#leibniz_eq_0-val">leibniz_eq_0</a> : thm
<a name="line398"></a>    val <a href="#leibniz_eqn-val">leibniz_eqn</a> : thm
<a name="line399"></a>    val <a href="#leibniz_formula-val">leibniz_formula</a> : thm
<a name="line400"></a>    val <a href="#leibniz_horizontal_0-val">leibniz_horizontal_0</a> : thm
<a name="line401"></a>    val <a href="#leibniz_horizontal_alt-val">leibniz_horizontal_alt</a> : thm
<a name="line402"></a>    val <a href="#leibniz_horizontal_average-val">leibniz_horizontal_average</a> : thm
<a name="line403"></a>    val <a href="#leibniz_horizontal_average_eqn-val">leibniz_horizontal_average_eqn</a> : thm
<a name="line404"></a>    val <a href="#leibniz_horizontal_divisor-val">leibniz_horizontal_divisor</a> : thm
<a name="line405"></a>    val <a href="#leibniz_horizontal_el-val">leibniz_horizontal_el</a> : thm
<a name="line406"></a>    val <a href="#leibniz_horizontal_element-val">leibniz_horizontal_element</a> : thm
<a name="line407"></a>    val <a href="#leibniz_horizontal_head-val">leibniz_horizontal_head</a> : thm
<a name="line408"></a>    val <a href="#leibniz_horizontal_lcm_alt-val">leibniz_horizontal_lcm_alt</a> : thm
<a name="line409"></a>    val <a href="#leibniz_horizontal_lcm_lower-val">leibniz_horizontal_lcm_lower</a> : thm
<a name="line410"></a>    val <a href="#leibniz_horizontal_len-val">leibniz_horizontal_len</a> : thm
<a name="line411"></a>    val <a href="#leibniz_horizontal_mem-val">leibniz_horizontal_mem</a> : thm
<a name="line412"></a>    val <a href="#leibniz_horizontal_mem_iff-val">leibniz_horizontal_mem_iff</a> : thm
<a name="line413"></a>    val <a href="#leibniz_horizontal_member-val">leibniz_horizontal_member</a> : thm
<a name="line414"></a>    val <a href="#leibniz_horizontal_member_divides-val">leibniz_horizontal_member_divides</a> : thm
<a name="line415"></a>    val <a href="#leibniz_horizontal_pos-val">leibniz_horizontal_pos</a> : thm
<a name="line416"></a>    val <a href="#leibniz_horizontal_pos_alt-val">leibniz_horizontal_pos_alt</a> : thm
<a name="line417"></a>    val <a href="#leibniz_horizontal_sum-val">leibniz_horizontal_sum</a> : thm
<a name="line418"></a>    val <a href="#leibniz_horizontal_sum_eqn-val">leibniz_horizontal_sum_eqn</a> : thm
<a name="line419"></a>    val <a href="#leibniz_horizontal_wriggle-val">leibniz_horizontal_wriggle</a> : thm
<a name="line420"></a>    val <a href="#leibniz_horizontal_wriggle_step-val">leibniz_horizontal_wriggle_step</a> : thm
<a name="line421"></a>    val <a href="#leibniz_horizontal_zigzag-val">leibniz_horizontal_zigzag</a> : thm
<a name="line422"></a>    val <a href="#leibniz_lcm_exchange-val">leibniz_lcm_exchange</a> : thm
<a name="line423"></a>    val <a href="#leibniz_lcm_invariance-val">leibniz_lcm_invariance</a> : thm
<a name="line424"></a>    val <a href="#leibniz_lcm_property-val">leibniz_lcm_property</a> : thm
<a name="line425"></a>    val <a href="#leibniz_less_0-val">leibniz_less_0</a> : thm
<a name="line426"></a>    val <a href="#leibniz_middle_lower-val">leibniz_middle_lower</a> : thm
<a name="line427"></a>    val <a href="#leibniz_monotone-val">leibniz_monotone</a> : thm
<a name="line428"></a>    val <a href="#leibniz_n_0-val">leibniz_n_0</a> : thm
<a name="line429"></a>    val <a href="#leibniz_n_k-val">leibniz_n_k</a> : thm
<a name="line430"></a>    val <a href="#leibniz_n_n-val">leibniz_n_n</a> : thm
<a name="line431"></a>    val <a href="#leibniz_pos-val">leibniz_pos</a> : thm
<a name="line432"></a>    val <a href="#leibniz_property-val">leibniz_property</a> : thm
<a name="line433"></a>    val <a href="#leibniz_recurrence-val">leibniz_recurrence</a> : thm
<a name="line434"></a>    val <a href="#leibniz_right-val">leibniz_right</a> : thm
<a name="line435"></a>    val <a href="#leibniz_right_alt-val">leibniz_right_alt</a> : thm
<a name="line436"></a>    val <a href="#leibniz_right_entry-val">leibniz_right_entry</a> : thm
<a name="line437"></a>    val <a href="#leibniz_right_eqn-val">leibniz_right_eqn</a> : thm
<a name="line438"></a>    val <a href="#leibniz_row_def-val">leibniz_row_def</a> : thm
<a name="line439"></a>    val <a href="#leibniz_seg_arm_0-val">leibniz_seg_arm_0</a> : thm
<a name="line440"></a>    val <a href="#leibniz_seg_arm_1-val">leibniz_seg_arm_1</a> : thm
<a name="line441"></a>    val <a href="#leibniz_seg_arm_el-val">leibniz_seg_arm_el</a> : thm
<a name="line442"></a>    val <a href="#leibniz_seg_arm_head-val">leibniz_seg_arm_head</a> : thm
<a name="line443"></a>    val <a href="#leibniz_seg_arm_len-val">leibniz_seg_arm_len</a> : thm
<a name="line444"></a>    val <a href="#leibniz_seg_arm_n_0-val">leibniz_seg_arm_n_0</a> : thm
<a name="line445"></a>    val <a href="#leibniz_seg_arm_wriggle_row_arm-val">leibniz_seg_arm_wriggle_row_arm</a> : thm
<a name="line446"></a>    val <a href="#leibniz_seg_arm_wriggle_step-val">leibniz_seg_arm_wriggle_step</a> : thm
<a name="line447"></a>    val <a href="#leibniz_seg_arm_zigzag_step-val">leibniz_seg_arm_zigzag_step</a> : thm
<a name="line448"></a>    val <a href="#leibniz_seg_def-val">leibniz_seg_def</a> : thm
<a name="line449"></a>    val <a href="#leibniz_sym-val">leibniz_sym</a> : thm
<a name="line450"></a>    val <a href="#leibniz_triplet_0-val">leibniz_triplet_0</a> : thm
<a name="line451"></a>    val <a href="#leibniz_triplet_lcm-val">leibniz_triplet_lcm</a> : thm
<a name="line452"></a>    val <a href="#leibniz_triplet_member-val">leibniz_triplet_member</a> : thm
<a name="line453"></a>    val <a href="#leibniz_triplet_property-val">leibniz_triplet_property</a> : thm
<a name="line454"></a>    val <a href="#leibniz_up-val">leibniz_up</a> : thm
<a name="line455"></a>    val <a href="#leibniz_up_0-val">leibniz_up_0</a> : thm
<a name="line456"></a>    val <a href="#leibniz_up_alt-val">leibniz_up_alt</a> : thm
<a name="line457"></a>    val <a href="#leibniz_up_cons-val">leibniz_up_cons</a> : thm
<a name="line458"></a>    val <a href="#leibniz_up_entry-val">leibniz_up_entry</a> : thm
<a name="line459"></a>    val <a href="#leibniz_up_eqn-val">leibniz_up_eqn</a> : thm
<a name="line460"></a>    val <a href="#leibniz_up_lcm_eq_horizontal_lcm-val">leibniz_up_lcm_eq_horizontal_lcm</a> : thm
<a name="line461"></a>    val <a href="#leibniz_up_len-val">leibniz_up_len</a> : thm
<a name="line462"></a>    val <a href="#leibniz_up_mem-val">leibniz_up_mem</a> : thm
<a name="line463"></a>    val <a href="#leibniz_up_pos-val">leibniz_up_pos</a> : thm
<a name="line464"></a>    val <a href="#leibniz_up_wriggle_horizontal-val">leibniz_up_wriggle_horizontal</a> : thm
<a name="line465"></a>    val <a href="#leibniz_up_wriggle_horizontal_alt-val">leibniz_up_wriggle_horizontal_alt</a> : thm
<a name="line466"></a>    val <a href="#leibniz_vertical_0-val">leibniz_vertical_0</a> : thm
<a name="line467"></a>    val <a href="#leibniz_vertical_alt-val">leibniz_vertical_alt</a> : thm
<a name="line468"></a>    val <a href="#leibniz_vertical_divisor-val">leibniz_vertical_divisor</a> : thm
<a name="line469"></a>    val <a href="#leibniz_vertical_lcm_lower-val">leibniz_vertical_lcm_lower</a> : thm
<a name="line470"></a>    val <a href="#leibniz_vertical_len-val">leibniz_vertical_len</a> : thm
<a name="line471"></a>    val <a href="#leibniz_vertical_mem-val">leibniz_vertical_mem</a> : thm
<a name="line472"></a>    val <a href="#leibniz_vertical_not_nil-val">leibniz_vertical_not_nil</a> : thm
<a name="line473"></a>    val <a href="#leibniz_vertical_pos-val">leibniz_vertical_pos</a> : thm
<a name="line474"></a>    val <a href="#leibniz_vertical_pos_alt-val">leibniz_vertical_pos_alt</a> : thm
<a name="line475"></a>    val <a href="#leibniz_vertical_snoc-val">leibniz_vertical_snoc</a> : thm
<a name="line476"></a>    val <a href="#leibniz_wriggle_refl-val">leibniz_wriggle_refl</a> : thm
<a name="line477"></a>    val <a href="#leibniz_wriggle_tail-val">leibniz_wriggle_tail</a> : thm
<a name="line478"></a>    val <a href="#leibniz_wriggle_trans-val">leibniz_wriggle_trans</a> : thm
<a name="line479"></a>    val <a href="#leibniz_zigzag_tail-val">leibniz_zigzag_tail</a> : thm
<a name="line480"></a>    val <a href="#leibniz_zigzag_wriggle-val">leibniz_zigzag_wriggle</a> : thm
<a name="line481"></a>    val <a href="#listRangeINC_MONO_INC-val">listRangeINC_MONO_INC</a> : thm
<a name="line482"></a>    val <a href="#listRangeINC_PROD-val">listRangeINC_PROD</a> : thm
<a name="line483"></a>    val <a href="#listRangeINC_PROD_pos-val">listRangeINC_PROD_pos</a> : thm
<a name="line484"></a>    val <a href="#listRangeLHI_MONO_INC-val">listRangeLHI_MONO_INC</a> : thm
<a name="line485"></a>    val <a href="#listRangeLHI_PROD-val">listRangeLHI_PROD</a> : thm
<a name="line486"></a>    val <a href="#listRangeLHI_PROD_pos-val">listRangeLHI_PROD_pos</a> : thm
<a name="line487"></a>    val <a href="#list_count_0_n-val">list_count_0_n</a> : thm
<a name="line488"></a>    val <a href="#list_count_alt-val">list_count_alt</a> : thm
<a name="line489"></a>    val <a href="#list_count_by_image-val">list_count_by_image</a> : thm
<a name="line490"></a>    val <a href="#list_count_element-val">list_count_element</a> : thm
<a name="line491"></a>    val <a href="#list_count_element_alt-val">list_count_element_alt</a> : thm
<a name="line492"></a>    val <a href="#list_count_element_perm_set_not_empty-val">list_count_element_perm_set_not_empty</a> : thm
<a name="line493"></a>    val <a href="#list_count_element_set_card-val">list_count_element_set_card</a> : thm
<a name="line494"></a>    val <a href="#list_count_eq_empty-val">list_count_eq_empty</a> : thm
<a name="line495"></a>    val <a href="#list_count_eqn-val">list_count_eqn</a> : thm
<a name="line496"></a>    val <a href="#list_count_finite-val">list_count_finite</a> : thm
<a name="line497"></a>    val <a href="#list_count_n_0-val">list_count_n_0</a> : thm
<a name="line498"></a>    val <a href="#list_count_n_n-val">list_count_n_n</a> : thm
<a name="line499"></a>    val <a href="#list_count_set_eq_class-val">list_count_set_eq_class</a> : thm
<a name="line500"></a>    val <a href="#list_count_set_eq_class_card-val">list_count_set_eq_class_card</a> : thm
<a name="line501"></a>    val <a href="#list_count_set_map_bij-val">list_count_set_map_bij</a> : thm
<a name="line502"></a>    val <a href="#list_count_set_map_element-val">list_count_set_map_element</a> : thm
<a name="line503"></a>    val <a href="#list_count_set_map_inj-val">list_count_set_map_inj</a> : thm
<a name="line504"></a>    val <a href="#list_count_set_map_surj-val">list_count_set_map_surj</a> : thm
<a name="line505"></a>    val <a href="#list_count_set_partititon_element_card-val">list_count_set_partititon_element_card</a> : thm
<a name="line506"></a>    val <a href="#list_count_subset-val">list_count_subset</a> : thm
<a name="line507"></a>    val <a href="#list_lcm_absorption-val">list_lcm_absorption</a> : thm
<a name="line508"></a>    val <a href="#list_lcm_append-val">list_lcm_append</a> : thm
<a name="line509"></a>    val <a href="#list_lcm_append_3-val">list_lcm_append_3</a> : thm
<a name="line510"></a>    val <a href="#list_lcm_by_FOLDL-val">list_lcm_by_FOLDL</a> : thm
<a name="line511"></a>    val <a href="#list_lcm_by_FOLDR-val">list_lcm_by_FOLDR</a> : thm
<a name="line512"></a>    val <a href="#list_lcm_cons-val">list_lcm_cons</a> : thm
<a name="line513"></a>    val <a href="#list_lcm_divisor_lcm_pair-val">list_lcm_divisor_lcm_pair</a> : thm
<a name="line514"></a>    val <a href="#list_lcm_eq_if_set_eq-val">list_lcm_eq_if_set_eq</a> : thm
<a name="line515"></a>    val <a href="#list_lcm_ge_max-val">list_lcm_ge_max</a> : thm
<a name="line516"></a>    val <a href="#list_lcm_is_common_multiple-val">list_lcm_is_common_multiple</a> : thm
<a name="line517"></a>    val <a href="#list_lcm_is_least_common_multiple-val">list_lcm_is_least_common_multiple</a> : thm
<a name="line518"></a>    val <a href="#list_lcm_lower_bound-val">list_lcm_lower_bound</a> : thm
<a name="line519"></a>    val <a href="#list_lcm_lower_bound_alt-val">list_lcm_lower_bound_alt</a> : thm
<a name="line520"></a>    val <a href="#list_lcm_lower_by_lcm_pair-val">list_lcm_lower_by_lcm_pair</a> : thm
<a name="line521"></a>    val <a href="#list_lcm_map_times-val">list_lcm_map_times</a> : thm
<a name="line522"></a>    val <a href="#list_lcm_nil-val">list_lcm_nil</a> : thm
<a name="line523"></a>    val <a href="#list_lcm_nonempty_lower-val">list_lcm_nonempty_lower</a> : thm
<a name="line524"></a>    val <a href="#list_lcm_nonempty_lower_alt-val">list_lcm_nonempty_lower_alt</a> : thm
<a name="line525"></a>    val <a href="#list_lcm_nub-val">list_lcm_nub</a> : thm
<a name="line526"></a>    val <a href="#list_lcm_nub_eq_if_set_eq-val">list_lcm_nub_eq_if_set_eq</a> : thm
<a name="line527"></a>    val <a href="#list_lcm_pos-val">list_lcm_pos</a> : thm
<a name="line528"></a>    val <a href="#list_lcm_pos_alt-val">list_lcm_pos_alt</a> : thm
<a name="line529"></a>    val <a href="#list_lcm_prime_factor-val">list_lcm_prime_factor</a> : thm
<a name="line530"></a>    val <a href="#list_lcm_prime_factor_member-val">list_lcm_prime_factor_member</a> : thm
<a name="line531"></a>    val <a href="#list_lcm_reverse-val">list_lcm_reverse</a> : thm
<a name="line532"></a>    val <a href="#list_lcm_sing-val">list_lcm_sing</a> : thm
<a name="line533"></a>    val <a href="#list_lcm_snoc-val">list_lcm_snoc</a> : thm
<a name="line534"></a>    val <a href="#list_lcm_suc-val">list_lcm_suc</a> : thm
<a name="line535"></a>    val <a href="#list_lcm_upper_by_common_multiple-val">list_lcm_upper_by_common_multiple</a> : thm
<a name="line536"></a>    val <a href="#list_lcm_wriggle-val">list_lcm_wriggle</a> : thm
<a name="line537"></a>    val <a href="#list_lcm_zigzag-val">list_lcm_zigzag</a> : thm
<a name="line538"></a>    val <a href="#list_length_eq_sum-val">list_length_eq_sum</a> : thm
<a name="line539"></a>    val <a href="#list_length_le_sum-val">list_length_le_sum</a> : thm
<a name="line540"></a>    val <a href="#list_product_prime_factor-val">list_product_prime_factor</a> : thm
<a name="line541"></a>    val <a href="#monocoloured_0-val">monocoloured_0</a> : thm
<a name="line542"></a>    val <a href="#monocoloured_0_card-val">monocoloured_0_card</a> : thm
<a name="line543"></a>    val <a href="#monocoloured_1-val">monocoloured_1</a> : thm
<a name="line544"></a>    val <a href="#monocoloured_card-val">monocoloured_card</a> : thm
<a name="line545"></a>    val <a href="#monocoloured_card_eqn-val">monocoloured_card_eqn</a> : thm
<a name="line546"></a>    val <a href="#monocoloured_element-val">monocoloured_element</a> : thm
<a name="line547"></a>    val <a href="#monocoloured_empty-val">monocoloured_empty</a> : thm
<a name="line548"></a>    val <a href="#monocoloured_eqn-val">monocoloured_eqn</a> : thm
<a name="line549"></a>    val <a href="#monocoloured_finite-val">monocoloured_finite</a> : thm
<a name="line550"></a>    val <a href="#monocoloured_mono-val">monocoloured_mono</a> : thm
<a name="line551"></a>    val <a href="#monocoloured_necklace-val">monocoloured_necklace</a> : thm
<a name="line552"></a>    val <a href="#monocoloured_subset-val">monocoloured_subset</a> : thm
<a name="line553"></a>    val <a href="#monocoloured_suc-val">monocoloured_suc</a> : thm
<a name="line554"></a>    val <a href="#multi_mono_disjoint-val">multi_mono_disjoint</a> : thm
<a name="line555"></a>    val <a href="#multi_mono_exhaust-val">multi_mono_exhaust</a> : thm
<a name="line556"></a>    val <a href="#multicoloured_0-val">multicoloured_0</a> : thm
<a name="line557"></a>    val <a href="#multicoloured_1-val">multicoloured_1</a> : thm
<a name="line558"></a>    val <a href="#multicoloured_card-val">multicoloured_card</a> : thm
<a name="line559"></a>    val <a href="#multicoloured_card_eqn-val">multicoloured_card_eqn</a> : thm
<a name="line560"></a>    val <a href="#multicoloured_element-val">multicoloured_element</a> : thm
<a name="line561"></a>    val <a href="#multicoloured_empty-val">multicoloured_empty</a> : thm
<a name="line562"></a>    val <a href="#multicoloured_finite-val">multicoloured_finite</a> : thm
<a name="line563"></a>    val <a href="#multicoloured_n_0-val">multicoloured_n_0</a> : thm
<a name="line564"></a>    val <a href="#multicoloured_n_1-val">multicoloured_n_1</a> : thm
<a name="line565"></a>    val <a href="#multicoloured_necklace-val">multicoloured_necklace</a> : thm
<a name="line566"></a>    val <a href="#multicoloured_nonempty-val">multicoloured_nonempty</a> : thm
<a name="line567"></a>    val <a href="#multicoloured_not_monocoloured-val">multicoloured_not_monocoloured</a> : thm
<a name="line568"></a>    val <a href="#multicoloured_not_monocoloured_iff-val">multicoloured_not_monocoloured_iff</a> : thm
<a name="line569"></a>    val <a href="#multicoloured_or_monocoloured-val">multicoloured_or_monocoloured</a> : thm
<a name="line570"></a>    val <a href="#multicoloured_subset-val">multicoloured_subset</a> : thm
<a name="line571"></a>    val <a href="#necklace_0-val">necklace_0</a> : thm
<a name="line572"></a>    val <a href="#necklace_1-val">necklace_1</a> : thm
<a name="line573"></a>    val <a href="#necklace_1_monocoloured-val">necklace_1_monocoloured</a> : thm
<a name="line574"></a>    val <a href="#necklace_card-val">necklace_card</a> : thm
<a name="line575"></a>    val <a href="#necklace_colors-val">necklace_colors</a> : thm
<a name="line576"></a>    val <a href="#necklace_element-val">necklace_element</a> : thm
<a name="line577"></a>    val <a href="#necklace_empty-val">necklace_empty</a> : thm
<a name="line578"></a>    val <a href="#necklace_eqn-val">necklace_eqn</a> : thm
<a name="line579"></a>    val <a href="#necklace_finite-val">necklace_finite</a> : thm
<a name="line580"></a>    val <a href="#necklace_length-val">necklace_length</a> : thm
<a name="line581"></a>    val <a href="#necklace_not_nil-val">necklace_not_nil</a> : thm
<a name="line582"></a>    val <a href="#necklace_property-val">necklace_property</a> : thm
<a name="line583"></a>    val <a href="#necklace_suc-val">necklace_suc</a> : thm
<a name="line584"></a>    val <a href="#nub_all_distinct-val">nub_all_distinct</a> : thm
<a name="line585"></a>    val <a href="#nub_cons-val">nub_cons</a> : thm
<a name="line586"></a>    val <a href="#nub_nil-val">nub_nil</a> : thm
<a name="line587"></a>    val <a href="#nub_sing-val">nub_sing</a> : thm
<a name="line588"></a>    val <a href="#over_bij-val">over_bij</a> : thm
<a name="line589"></a>    val <a href="#over_inj-val">over_inj</a> : thm
<a name="line590"></a>    val <a href="#over_surj-val">over_surj</a> : thm
<a name="line591"></a>    val <a href="#pairwise_coprime_prod_set_divides-val">pairwise_coprime_prod_set_divides</a> : thm
<a name="line592"></a>    val <a href="#pairwise_coprime_prod_set_eq_set_lcm-val">pairwise_coprime_prod_set_eq_set_lcm</a> : thm
<a name="line593"></a>    val <a href="#perm_0-val">perm_0</a> : thm
<a name="line594"></a>    val <a href="#perm_1-val">perm_1</a> : thm
<a name="line595"></a>    val <a href="#perm_alt-val">perm_alt</a> : thm
<a name="line596"></a>    val <a href="#perm_count_0-val">perm_count_0</a> : thm
<a name="line597"></a>    val <a href="#perm_count_1-val">perm_count_1</a> : thm
<a name="line598"></a>    val <a href="#perm_count_element-val">perm_count_element</a> : thm
<a name="line599"></a>    val <a href="#perm_count_element_length-val">perm_count_element_length</a> : thm
<a name="line600"></a>    val <a href="#perm_count_element_no_self-val">perm_count_element_no_self</a> : thm
<a name="line601"></a>    val <a href="#perm_count_eqn-val">perm_count_eqn</a> : thm
<a name="line602"></a>    val <a href="#perm_count_finite-val">perm_count_finite</a> : thm
<a name="line603"></a>    val <a href="#perm_count_interleave_card-val">perm_count_interleave_card</a> : thm
<a name="line604"></a>    val <a href="#perm_count_interleave_disjoint-val">perm_count_interleave_disjoint</a> : thm
<a name="line605"></a>    val <a href="#perm_count_interleave_finite-val">perm_count_interleave_finite</a> : thm
<a name="line606"></a>    val <a href="#perm_count_interleave_inj-val">perm_count_interleave_inj</a> : thm
<a name="line607"></a>    val <a href="#perm_count_subset-val">perm_count_subset</a> : thm
<a name="line608"></a>    val <a href="#perm_count_suc-val">perm_count_suc</a> : thm
<a name="line609"></a>    val <a href="#perm_count_suc_alt-val">perm_count_suc_alt</a> : thm
<a name="line610"></a>    val <a href="#perm_eq_fact-val">perm_eq_fact</a> : thm
<a name="line611"></a>    val <a href="#perm_set_bij_eq_perm_count-val">perm_set_bij_eq_perm_count</a> : thm
<a name="line612"></a>    val <a href="#perm_set_card-val">perm_set_card</a> : thm
<a name="line613"></a>    val <a href="#perm_set_card_alt-val">perm_set_card_alt</a> : thm
<a name="line614"></a>    val <a href="#perm_set_element-val">perm_set_element</a> : thm
<a name="line615"></a>    val <a href="#perm_set_empty-val">perm_set_empty</a> : thm
<a name="line616"></a>    val <a href="#perm_set_eq_empty_sing-val">perm_set_eq_empty_sing</a> : thm
<a name="line617"></a>    val <a href="#perm_set_finite-val">perm_set_finite</a> : thm
<a name="line618"></a>    val <a href="#perm_set_has_self_list-val">perm_set_has_self_list</a> : thm
<a name="line619"></a>    val <a href="#perm_set_list_not_empty-val">perm_set_list_not_empty</a> : thm
<a name="line620"></a>    val <a href="#perm_set_map_bij-val">perm_set_map_bij</a> : thm
<a name="line621"></a>    val <a href="#perm_set_map_element-val">perm_set_map_element</a> : thm
<a name="line622"></a>    val <a href="#perm_set_map_inj-val">perm_set_map_inj</a> : thm
<a name="line623"></a>    val <a href="#perm_set_map_surj-val">perm_set_map_surj</a> : thm
<a name="line624"></a>    val <a href="#perm_set_not_empty-val">perm_set_not_empty</a> : thm
<a name="line625"></a>    val <a href="#perm_set_perm_count-val">perm_set_perm_count</a> : thm
<a name="line626"></a>    val <a href="#perm_set_sing-val">perm_set_sing</a> : thm
<a name="line627"></a>    val <a href="#perm_suc-val">perm_suc</a> : thm
<a name="line628"></a>    val <a href="#perm_suc_alt-val">perm_suc_alt</a> : thm
<a name="line629"></a>    val <a href="#power_predecessor_eqn-val">power_predecessor_eqn</a> : thm
<a name="line630"></a>    val <a href="#prime_divides_binomials-val">prime_divides_binomials</a> : thm
<a name="line631"></a>    val <a href="#prime_divides_binomials_alt-val">prime_divides_binomials_alt</a> : thm
<a name="line632"></a>    val <a href="#prime_divisor_property-val">prime_divisor_property</a> : thm
<a name="line633"></a>    val <a href="#prime_iff_divides_binomials-val">prime_iff_divides_binomials</a> : thm
<a name="line634"></a>    val <a href="#prime_iff_divides_binomials_alt-val">prime_iff_divides_binomials_alt</a> : thm
<a name="line635"></a>    val <a href="#prod_1_to_n_eq_fact_n-val">prod_1_to_n_eq_fact_n</a> : thm
<a name="line636"></a>    val <a href="#rotate_0-val">rotate_0</a> : thm
<a name="line637"></a>    val <a href="#rotate_add-val">rotate_add</a> : thm
<a name="line638"></a>    val <a href="#rotate_full-val">rotate_full</a> : thm
<a name="line639"></a>    val <a href="#rotate_lcancel-val">rotate_lcancel</a> : thm
<a name="line640"></a>    val <a href="#rotate_nil-val">rotate_nil</a> : thm
<a name="line641"></a>    val <a href="#rotate_rcancel-val">rotate_rcancel</a> : thm
<a name="line642"></a>    val <a href="#rotate_same_length-val">rotate_same_length</a> : thm
<a name="line643"></a>    val <a href="#rotate_same_set-val">rotate_same_set</a> : thm
<a name="line644"></a>    val <a href="#rotate_shift_element-val">rotate_shift_element</a> : thm
<a name="line645"></a>    val <a href="#rotate_suc-val">rotate_suc</a> : thm
<a name="line646"></a>    val <a href="#set_lcm_empty-val">set_lcm_empty</a> : thm
<a name="line647"></a>    val <a href="#set_lcm_eq_big_lcm-val">set_lcm_eq_big_lcm</a> : thm
<a name="line648"></a>    val <a href="#set_lcm_eq_list_lcm-val">set_lcm_eq_list_lcm</a> : thm
<a name="line649"></a>    val <a href="#set_lcm_insert-val">set_lcm_insert</a> : thm
<a name="line650"></a>    val <a href="#set_lcm_is_common_multiple-val">set_lcm_is_common_multiple</a> : thm
<a name="line651"></a>    val <a href="#set_lcm_is_least_common_multiple-val">set_lcm_is_least_common_multiple</a> : thm
<a name="line652"></a>    val <a href="#set_lcm_nonempty-val">set_lcm_nonempty</a> : thm
<a name="line653"></a>    val <a href="#set_lcm_sing-val">set_lcm_sing</a> : thm
<a name="line654"></a>    val <a href="#sub_count_0_n-val">sub_count_0_n</a> : thm
<a name="line655"></a>    val <a href="#sub_count_alt-val">sub_count_alt</a> : thm
<a name="line656"></a>    val <a href="#sub_count_count_inj-val">sub_count_count_inj</a> : thm
<a name="line657"></a>    val <a href="#sub_count_disjoint-val">sub_count_disjoint</a> : thm
<a name="line658"></a>    val <a href="#sub_count_element-val">sub_count_element</a> : thm
<a name="line659"></a>    val <a href="#sub_count_element_finite-val">sub_count_element_finite</a> : thm
<a name="line660"></a>    val <a href="#sub_count_element_no_self-val">sub_count_element_no_self</a> : thm
<a name="line661"></a>    val <a href="#sub_count_eq_empty-val">sub_count_eq_empty</a> : thm
<a name="line662"></a>    val <a href="#sub_count_eqn-val">sub_count_eqn</a> : thm
<a name="line663"></a>    val <a href="#sub_count_equiv_class-val">sub_count_equiv_class</a> : thm
<a name="line664"></a>    val <a href="#sub_count_finite-val">sub_count_finite</a> : thm
<a name="line665"></a>    val <a href="#sub_count_insert-val">sub_count_insert</a> : thm
<a name="line666"></a>    val <a href="#sub_count_insert_card-val">sub_count_insert_card</a> : thm
<a name="line667"></a>    val <a href="#sub_count_n_0-val">sub_count_n_0</a> : thm
<a name="line668"></a>    val <a href="#sub_count_n_1-val">sub_count_n_1</a> : thm
<a name="line669"></a>    val <a href="#sub_count_n_n-val">sub_count_n_n</a> : thm
<a name="line670"></a>    val <a href="#sub_count_subset-val">sub_count_subset</a> : thm
<a name="line671"></a>    val <a href="#sub_count_union-val">sub_count_union</a> : thm
<a name="line672"></a>    val <a href="#sub_sets_element-val">sub_sets_element</a> : thm
<a name="line673"></a>    val <a href="#sub_sets_equiv_class-val">sub_sets_equiv_class</a> : thm
<a name="line674"></a>    val <a href="#sub_sets_sub_count-val">sub_sets_sub_count</a> : thm
<a name="line675"></a>    val <a href="#sum_1_to_n_double-val">sum_1_to_n_double</a> : thm
<a name="line676"></a>    val <a href="#sum_1_to_n_eq_tri_n-val">sum_1_to_n_eq_tri_n</a> : thm
<a name="line677"></a>    val <a href="#sum_1_to_n_eqn-val">sum_1_to_n_eqn</a> : thm
<a name="line678"></a>    val <a href="#surj_iff_preimage_card_not_0-val">surj_iff_preimage_card_not_0</a> : thm
<a name="line679"></a>    val <a href="#surj_preimage_not_empty-val">surj_preimage_not_empty</a> : thm
<a name="line680"></a>    val <a href="#tail_turn-val">tail_turn</a> : thm
<a name="line681"></a>    val <a href="#triple_11-val">triple_11</a> : thm
<a name="line682"></a>    val <a href="#triple_Axiom-val">triple_Axiom</a> : thm
<a name="line683"></a>    val <a href="#triple_accessors-val">triple_accessors</a> : thm
<a name="line684"></a>    val <a href="#triple_accfupds-val">triple_accfupds</a> : thm
<a name="line685"></a>    val <a href="#triple_case_cong-val">triple_case_cong</a> : thm
<a name="line686"></a>    val <a href="#triple_case_eq-val">triple_case_eq</a> : thm
<a name="line687"></a>    val <a href="#triple_component_equality-val">triple_component_equality</a> : thm
<a name="line688"></a>    val <a href="#triple_fn_updates-val">triple_fn_updates</a> : thm
<a name="line689"></a>    val <a href="#triple_fupdcanon-val">triple_fupdcanon</a> : thm
<a name="line690"></a>    val <a href="#triple_fupdcanon_comp-val">triple_fupdcanon_comp</a> : thm
<a name="line691"></a>    val <a href="#triple_fupdfupds-val">triple_fupdfupds</a> : thm
<a name="line692"></a>    val <a href="#triple_fupdfupds_comp-val">triple_fupdfupds_comp</a> : thm
<a name="line693"></a>    val <a href="#triple_induction-val">triple_induction</a> : thm
<a name="line694"></a>    val <a href="#triple_literal_11-val">triple_literal_11</a> : thm
<a name="line695"></a>    val <a href="#triple_literal_nchotomy-val">triple_literal_nchotomy</a> : thm
<a name="line696"></a>    val <a href="#triple_nchotomy-val">triple_nchotomy</a> : thm
<a name="line697"></a>    val <a href="#triple_updates_eq_literal-val">triple_updates_eq_literal</a> : thm
<a name="line698"></a>    val <a href="#turn_eq_nil-val">turn_eq_nil</a> : thm
<a name="line699"></a>    val <a href="#turn_exp_0-val">turn_exp_0</a> : thm
<a name="line700"></a>    val <a href="#turn_exp_1-val">turn_exp_1</a> : thm
<a name="line701"></a>    val <a href="#turn_exp_2-val">turn_exp_2</a> : thm
<a name="line702"></a>    val <a href="#turn_exp_SUC-val">turn_exp_SUC</a> : thm
<a name="line703"></a>    val <a href="#turn_exp_length-val">turn_exp_length</a> : thm
<a name="line704"></a>    val <a href="#turn_exp_suc-val">turn_exp_suc</a> : thm
<a name="line705"></a>    val <a href="#turn_length-val">turn_length</a> : thm
<a name="line706"></a>    val <a href="#turn_nil-val">turn_nil</a> : thm
<a name="line707"></a>    val <a href="#turn_not_nil-val">turn_not_nil</a> : thm
<a name="line708"></a>    val <a href="#turn_snoc-val">turn_snoc</a> : thm
<a name="line709"></a>(*
   [number] Parent theory of "combinatorics"
   
   [<a name="MDILATE_def-val"><b>MDILATE_def</b></a>]  Definition
      
       (e n. MDILATE e n [] = []) 
        e n h t.
          MDILATE e n (h::t) =
          if t = [] then [h] else h::GENLIST (K e) (PRE n)  MDILATE e n t
   
   [<a name="PROD-val"><b>PROD</b></a>]  Definition
      
       PROD [] = 1  h t. PROD (h::t) = h * PROD t
   
   [<a name="PROD_ACC_DEF-val"><b>PROD_ACC_DEF</b></a>]  Definition
      
       (acc. PROD_ACC [] acc = acc) 
        h t acc. PROD_ACC (h::t) acc = PROD_ACC t (h * acc)
   
   [<a name="arrange_def-val"><b>arrange_def</b></a>]  Definition
      
       n k. n arrange k = CARD (list_count n k)
   
   [<a name="choose_def-val"><b>choose_def</b></a>]  Definition
      
       n k. n choose k = CARD (sub_count n k)
   
   [<a name="interleave_def-val"><b>interleave_def</b></a>]  Definition
      
       x ls.
          x interleave ls =
          IMAGE (k. TAKE k ls  x::DROP k ls) (upto (LENGTH ls))
   
   [<a name="lcm_upto_def-val"><b>lcm_upto_def</b></a>]  Definition
      
       lcm_upto 0 = 1  n. lcm_upto (SUC n) = lcm (SUC n) (lcm_upto n)
   
   [<a name="leibniz_def-val"><b>leibniz_def</b></a>]  Definition
      
       n k. leibniz n k = (n + 1) * binomial n k
   
   [<a name="leibniz_zigzag_def-val"><b>leibniz_zigzag_def</b></a>]  Definition
      
       p1 p2.
          p1 zigzag p2 
          n k x y. p1 = x  [tb; ta]  y  p2 = x  [tb; tc]  y
   
   [<a name="list_count_def-val"><b>list_count_def</b></a>]  Definition
      
       n k.
          list_count n k =
          {ls | ALL_DISTINCT ls  set ls  count n  LENGTH ls = k}
   
   [<a name="list_lcm_def-val"><b>list_lcm_def</b></a>]  Definition
      
       list_lcm [] = 1  h t. list_lcm (h::t) = lcm h (list_lcm t)
   
   [<a name="monocoloured_def-val"><b>monocoloured_def</b></a>]  Definition
      
       n a.
          monocoloured n a =
          {ls | ls  necklace n a  (ls  []  SING (set ls))}
   
   [<a name="multicoloured_def-val"><b>multicoloured_def</b></a>]  Definition
      
       n a. multicoloured n a = necklace n a DIFF monocoloured n a
   
   [<a name="necklace_def-val"><b>necklace_def</b></a>]  Definition
      
       n a. necklace n a = {ls | LENGTH ls = n  set ls  count a}
   
   [<a name="perm_count_def-val"><b>perm_count_def</b></a>]  Definition
      
       n. perm_count n = {ls | ALL_DISTINCT ls  set ls = count n}
   
   [<a name="perm_def-val"><b>perm_def</b></a>]  Definition
      
       n. perm n = CARD (perm_count n)
   
   [<a name="perm_set_def-val"><b>perm_set_def</b></a>]  Definition
      
       s. perm_set s = {ls | ALL_DISTINCT ls  set ls = s}
   
   [<a name="recordtype_triple_seldef_a_def-val"><b>recordtype_triple_seldef_a_def</b></a>]  Definition
      
       n n0 n1. (triple n n0 n1).a = n
   
   [<a name="recordtype_triple_seldef_a_fupd_def-val"><b>recordtype_triple_seldef_a_fupd_def</b></a>]  Definition
      
       f n n0 n1. triple n n0 n1 with a updated_by f = triple (f n) n0 n1
   
   [<a name="recordtype_triple_seldef_b_def-val"><b>recordtype_triple_seldef_b_def</b></a>]  Definition
      
       n n0 n1. (triple n n0 n1).b = n0
   
   [<a name="recordtype_triple_seldef_b_fupd_def-val"><b>recordtype_triple_seldef_b_fupd_def</b></a>]  Definition
      
       f n n0 n1. triple n n0 n1 with b updated_by f = triple n (f n0) n1
   
   [<a name="recordtype_triple_seldef_c_def-val"><b>recordtype_triple_seldef_c_def</b></a>]  Definition
      
       n n0 n1. (triple n n0 n1).c = n1
   
   [<a name="recordtype_triple_seldef_c_fupd_def-val"><b>recordtype_triple_seldef_c_fupd_def</b></a>]  Definition
      
       f n n0 n1. triple n n0 n1 with c updated_by f = triple n n0 (f n1)
   
   [<a name="rotate_def-val"><b>rotate_def</b></a>]  Definition
      
       n l. rotate n l = DROP n l  TAKE n l
   
   [<a name="set_lcm_def-val"><b>set_lcm_def</b></a>]  Definition
      
       s. set_lcm s = list_lcm (SET_TO_LIST s)
   
   [<a name="sub_count_def-val"><b>sub_count_def</b></a>]  Definition
      
       n k. sub_count n k = {s | s  count n  CARD s = k}
   
   [<a name="sub_sets_def-val"><b>sub_sets_def</b></a>]  Definition
      
       P k. sub_sets P k = {s | s  P  CARD s = k}
   
   [<a name="triple_TY_DEF-val"><b>triple_TY_DEF</b></a>]  Definition
      
       rep.
          TYPE_DEFINITION
            (a0'.
                  $var$('triple').
                   (a0'.
                      (a0 a1 a2.
                         a0' =
                         (a0 a1 a2.
                              ind_type$CONSTR 0 (a0,a1,a2)
                                (n. ind_type$BOTTOM)) a0 a1 a2) 
                      $var$('triple') a0') 
                   $var$('triple') a0') rep
   
   [<a name="triple_case_def-val"><b>triple_case_def</b></a>]  Definition
      
       a0 a1 a2 f. triple_CASE (triple a0 a1 a2) f = f a0 a1 a2
   
   [<a name="triple_size_def-val"><b>triple_size_def</b></a>]  Definition
      
       a0 a1 a2. triple_size (triple a0 a1 a2) = 1 + (a0 + (a1 + a2))
   
   [<a name="triplet_def-val"><b>triplet_def</b></a>]  Definition
      
       n k.
          triplet n k =
          &lt;|a := leibniz n k; b := leibniz (n + 1) k;
            c := leibniz (n + 1) (k + 1)|&gt;
   
   [<a name="turn_def-val"><b>turn_def</b></a>]  Definition
      
       l. turn l = if l = [] then [] else LAST l::FRONT l
   
   [<a name="CARD_LIST_TO_SET_EQ-val"><b>CARD_LIST_TO_SET_EQ</b></a>]  Theorem
      
       l. CARD (set l) = LENGTH (nub l)
   
   [<a name="DILATE_0_0-val"><b>DILATE_0_0</b></a>]  Theorem
      
       l e. DILATE e 0 0 l = l
   
   [<a name="DILATE_0_CONS-val"><b>DILATE_0_CONS</b></a>]  Theorem
      
       n h t e.
          DILATE e 0 n (h::t) =
          if t = [] then [h] else h::(GENLIST (K e) n  DILATE e 0 n t)
   
   [<a name="DILATE_0_EL-val"><b>DILATE_0_EL</b></a>]  Theorem
      
       l e n k.
          k &lt; LENGTH (DILATE e 0 n l) 
          EL k (DILATE e 0 n l) =
          if k MOD SUC n = 0 then EL (k DIV SUC n) l else e
   
   [<a name="DILATE_0_EQ_NIL-val"><b>DILATE_0_EQ_NIL</b></a>]  Theorem
      
       l e n. DILATE e 0 n l = []  l = []
   
   [<a name="DILATE_0_LAST-val"><b>DILATE_0_LAST</b></a>]  Theorem
      
       l e n. LAST (DILATE e 0 n l) = LAST l
   
   [<a name="DILATE_0_LENGTH-val"><b>DILATE_0_LENGTH</b></a>]  Theorem
      
       l e n.
          LENGTH (DILATE e 0 n l) =
          if l = [] then 0 else SUC (SUC n * PRE (LENGTH l))
   
   [<a name="DILATE_0_LENGTH_LOWER-val"><b>DILATE_0_LENGTH_LOWER</b></a>]  Theorem
      
       l e n. LENGTH l  LENGTH (DILATE e 0 n l)
   
   [<a name="DILATE_0_LENGTH_UPPER-val"><b>DILATE_0_LENGTH_UPPER</b></a>]  Theorem
      
       l e n. LENGTH (DILATE e 0 n l)  SUC (SUC n * PRE (LENGTH l))
   
   [<a name="DILATE_0_SUC-val"><b>DILATE_0_SUC</b></a>]  Theorem
      
       l e n. DILATE e 0 (SUC n) l = DILATE e n 1 (DILATE e 0 n l)
   
   [<a name="DILATE_CONS-val"><b>DILATE_CONS</b></a>]  Theorem
      
       n m h t e.
          DILATE e n m (h::t) =
          if t = [] then [h]
          else h::(TAKE n t  GENLIST (K e) m  DILATE e n m (DROP n t))
   
   [<a name="DILATE_NIL-val"><b>DILATE_NIL</b></a>]  Theorem
      
       n m e. DILATE e n m [] = []
   
   [<a name="DILATE_SING-val"><b>DILATE_SING</b></a>]  Theorem
      
       n m h e. DILATE e n m [h] = [h]
   
   [<a name="DILATE_def-val"><b>DILATE_def</b></a>]  Theorem
      
       (n m e. DILATE e n m [] = []) 
        (n m h e. DILATE e n m [h] = [h]) 
        v9 v8 n m h e.
          DILATE e n m (h::v8::v9) =
          h::
            (TAKE n (v8::v9)  GENLIST (K e) m 
             DILATE e n m (DROP n (v8::v9)))
   
   [<a name="DILATE_ind-val"><b>DILATE_ind</b></a>]  Theorem
      
       P. (e n m. P e n m [])  (e n m h. P e n m [h]) 
            (e n m h v8 v9.
               P e n m (DROP n (v8::v9))  P e n m (h::v8::v9)) 
            v v1 v2 v3. P v v1 v2 v3
   
   [<a name="EL_ALL_PROPERTY-val"><b>EL_ALL_PROPERTY</b></a>]  Theorem
      
       h1 t1 h2 t2 P.
          LENGTH (h1::t1) = LENGTH (h2::t2) 
          (k. k &lt; LENGTH (h1::t1)  P (EL k (h1::t1)) (EL k (h2::t2))) 
          P h1 h2  k. k &lt; LENGTH t1  P (EL k t1) (EL k t2)
   
   [<a name="EL_MAP3-val"><b>EL_MAP3</b></a>]  Theorem
      
       lx ly lz n.
          n &lt; MIN (MIN (LENGTH lx) (LENGTH ly)) (LENGTH lz) 
          f. EL n (MAP3 f lx ly lz) = f (EL n lx) (EL n ly) (EL n lz)
   
   [<a name="EVERY_ELEMENT_PROPERTY-val"><b>EVERY_ELEMENT_PROPERTY</b></a>]  Theorem
      
       p R. EVERY (c. c  R) p  k. k &lt; LENGTH p  EL k p  R
   
   [<a name="EVERY_LT_IMP_EVERY_LE-val"><b>EVERY_LT_IMP_EVERY_LE</b></a>]  Theorem
      
       ls n. EVERY (j. j &lt; n) ls  EVERY (j. j  n) ls
   
   [<a name="EVERY_MONOTONIC_MAP-val"><b>EVERY_MONOTONIC_MAP</b></a>]  Theorem
      
       l f P Q. (x. P x  (Q  f) x)  EVERY P l  EVERY Q (MAP f l)
   
   [<a name="EXISTS_triple-val"><b>EXISTS_triple</b></a>]  Theorem
      
       P. (t. P t)  n1 n0 n. P &lt;|a := n1; b := n0; c := n|&gt;
   
   [<a name="FILTER_EL_NEXT_IDX-val"><b>FILTER_EL_NEXT_IDX</b></a>]  Theorem
      
       P ls l1 l2 l3 x y.
          (let
             fs = FILTER P ls
           in
             ALL_DISTINCT ls  ls = l1  x::l2  y::l3  P x  P y 
             (findi y fs = 1 + findi x fs  FILTER P l2 = []))
   
   [<a name="FINITE_SURJ_IFF-val"><b>FINITE_SURJ_IFF</b></a>]  Theorem
      
       f s t.
          FINITE t  (SURJ f s t  CARD (IMAGE f s) = CARD t  over f s t)
   
   [<a name="FORALL_triple-val"><b>FORALL_triple</b></a>]  Theorem
      
       P. (t. P t)  n1 n0 n. P &lt;|a := n1; b := n0; c := n|&gt;
   
   [<a name="FUNPOW_cons_eq_map_0-val"><b>FUNPOW_cons_eq_map_0</b></a>]  Theorem
      
       f u n.
          FUNPOW (ls. f (HD ls)::ls) n [u] =
          MAP (j. FUNPOW f j u) (n downto 0)
   
   [<a name="FUNPOW_cons_eq_map_1-val"><b>FUNPOW_cons_eq_map_1</b></a>]  Theorem
      
       f u n.
          0 &lt; n 
          FUNPOW (ls. f (HD ls)::ls) (n  1) [f u] =
          MAP (j. FUNPOW f j u) (n downto 1)
   
   [<a name="FUNPOW_cons_head-val"><b>FUNPOW_cons_head</b></a>]  Theorem
      
       f n ls. HD (FUNPOW (ls. f (HD ls)::ls) n ls) = FUNPOW f n (HD ls)
   
   [<a name="FUNSET_ALT-val"><b>FUNSET_ALT</b></a>]  Theorem
      
       P Q. FUNSET P Q = {f | over f P Q}
   
   [<a name="GENLIST_MONO_DEC-val"><b>GENLIST_MONO_DEC</b></a>]  Theorem
      
       f n. RMONO f  MONO_DEC (GENLIST f n)
   
   [<a name="GENLIST_MONO_INC-val"><b>GENLIST_MONO_INC</b></a>]  Theorem
      
       f n. MONO f  MONO_INC (GENLIST f n)
   
   [<a name="GENLIST_binomial_index_shift-val"><b>GENLIST_binomial_index_shift</b></a>]  Theorem
      
       n x y.
          GENLIST ((k. binomial n k * x ** SUC (n  k) * y ** k)  SUC) n =
          GENLIST (k. binomial n (SUC k) * x ** (n  k) * y ** SUC k) n
   
   [<a name="INJ_IFF_BIJ_IMAGE-val"><b>INJ_IFF_BIJ_IMAGE</b></a>]  Theorem
      
       f s t. over f s t  (INJ f s t  BIJ f s (IMAGE f s))
   
   [<a name="INJ_IMAGE_BIJ_IFF-val"><b>INJ_IMAGE_BIJ_IFF</b></a>]  Theorem
      
       f s t. INJ f s t  BIJ f s (IMAGE f s)  over f s t
   
   [<a name="INJ_IMAGE_IFF-val"><b>INJ_IMAGE_IFF</b></a>]  Theorem
      
       f s t. INJ f s t  INJ f s (IMAGE f s)  over f s t
   
   [<a name="LENGTH_MAP3-val"><b>LENGTH_MAP3</b></a>]  Theorem
      
       lx ly lz f.
          LENGTH (MAP3 f lx ly lz) =
          MIN (MIN (LENGTH lx) (LENGTH ly)) (LENGTH lz)
   
   [<a name="LIST_TO_SET_REDUCTION-val"><b>LIST_TO_SET_REDUCTION</b></a>]  Theorem
      
       l1 l2 h.
          MEM h l1  set (h::l1) = set l2 
          p1 p2.
            MEM h p1  MEM h p2  nub l2 = p1  [h]  p2 
            set l1 = set (p1  p2)
   
   [<a name="LUPDATE_APPEND_0-val"><b>LUPDATE_APPEND_0</b></a>]  Theorem
      
       ls a h t. LUPDATE a (LENGTH ls) (ls  h::t) = ls  a::t
   
   [<a name="LUPDATE_APPEND_0_1-val"><b>LUPDATE_APPEND_0_1</b></a>]  Theorem
      
       ls a b h k t.
          LUPDATE b (LENGTH ls + 1) (LUPDATE a (LENGTH ls) (ls  h::k::t)) =
          ls  a::b::t
   
   [<a name="LUPDATE_APPEND_1-val"><b>LUPDATE_APPEND_1</b></a>]  Theorem
      
       ls b h k t.
          LUPDATE b (LENGTH ls + 1) (ls  h::k::t) = ls  h::b::t
   
   [<a name="LUPDATE_DIFF_SPOT-val"><b>LUPDATE_DIFF_SPOT</b></a>]  Theorem
      
       ls m n p q.
          m  n 
          LUPDATE q n (LUPDATE p m ls) = LUPDATE p m (LUPDATE q n ls)
   
   [<a name="LUPDATE_EL-val"><b>LUPDATE_EL</b></a>]  Theorem
      
       e n l p.
          p &lt; LENGTH l  EL p (LUPDATE e n l) = if p = n then e else EL p l
   
   [<a name="LUPDATE_LEN-val"><b>LUPDATE_LEN</b></a>]  Theorem
      
       e n l. LENGTH (LUPDATE e n l) = LENGTH l
   
   [<a name="LUPDATE_SAME_SPOT-val"><b>LUPDATE_SAME_SPOT</b></a>]  Theorem
      
       ls n p q. LUPDATE q n (LUPDATE p n ls) = LUPDATE q n ls
   
   [<a name="MAP2_LE-val"><b>MAP2_LE</b></a>]  Theorem
      
       f g.
          (x y. f x y  g x y) 
          lx ly n. EL n (MAP2 f lx ly)  EL n (MAP2 g lx ly)
   
   [<a name="MAP3-val"><b>MAP3</b></a>]  Theorem
      
       (f. MAP3 f [] [] [] = []) 
        f h1 t1 h2 t2 h3 t3.
          MAP3 f (h1::t1) (h2::t2) (h3::t3) = f h1 h2 h3::MAP3 f t1 t2 t3
   
   [<a name="MAP3_DEF-val"><b>MAP3_DEF</b></a>]  Theorem
      
       (t3 t2 t1 h3 h2 h1 f.
           MAP3 f (h1::t1) (h2::t2) (h3::t3) = f h1 h2 h3::MAP3 f t1 t2 t3) 
        (z y f. MAP3 f [] y z = []) 
        (z v5 v4 f. MAP3 f (v4::v5) [] z = []) 
        v5 v4 v13 v12 f. MAP3 f (v4::v5) (v12::v13) [] = []
   
   [<a name="MAP3_IND-val"><b>MAP3_IND</b></a>]  Theorem
      
       P. (f h1 t1 h2 t2 h3 t3.
               P f t1 t2 t3  P f (h1::t1) (h2::t2) (h3::t3)) 
            (f y z. P f [] y z)  (f v4 v5 z. P f (v4::v5) [] z) 
            (f v4 v5 v12 v13. P f (v4::v5) (v12::v13) []) 
            v v1 v2 v3. P v v1 v2 v3
   
   [<a name="MAP3_LE-val"><b>MAP3_LE</b></a>]  Theorem
      
       f g.
          (x y z. f x y z  g x y z) 
          lx ly lz n. EL n (MAP3 f lx ly lz)  EL n (MAP3 g lx ly lz)
   
   [<a name="MAP_LE-val"><b>MAP_LE</b></a>]  Theorem
      
       f g. (x. f x  g x)  ls n. EL n (MAP f ls)  EL n (MAP g ls)
   
   [<a name="MAX_LIST_MONO_MAP-val"><b>MAX_LIST_MONO_MAP</b></a>]  Theorem
      
       f. MONO f  ls. ls  []  MAX_LIST (MAP f ls) = f (MAX_LIST ls)
   
   [<a name="MDILATE_0-val"><b>MDILATE_0</b></a>]  Theorem
      
       l e. MDILATE e 0 l = l
   
   [<a name="MDILATE_1-val"><b>MDILATE_1</b></a>]  Theorem
      
       l e. MDILATE e 1 l = l
   
   [<a name="MDILATE_CONS-val"><b>MDILATE_CONS</b></a>]  Theorem
      
       e n h t.
          MDILATE e n (h::t) =
          if t = [] then [h] else h::GENLIST (K e) (PRE n)  MDILATE e n t
   
   [<a name="MDILATE_EL-val"><b>MDILATE_EL</b></a>]  Theorem
      
       l e n k.
          k &lt; LENGTH (MDILATE e n l) 
          EL k (MDILATE e n l) =
          if n = 0 then EL k l
          else if k MOD n = 0 then EL (k DIV n) l
          else e
   
   [<a name="MDILATE_EQ_NIL-val"><b>MDILATE_EQ_NIL</b></a>]  Theorem
      
       l e n. MDILATE e n l = []  l = []
   
   [<a name="MDILATE_LAST-val"><b>MDILATE_LAST</b></a>]  Theorem
      
       l e n. LAST (MDILATE e n l) = LAST l
   
   [<a name="MDILATE_LENGTH-val"><b>MDILATE_LENGTH</b></a>]  Theorem
      
       l e n.
          LENGTH (MDILATE e n l) =
          if n = 0 then LENGTH l
          else if l = [] then 0
          else SUC (n * PRE (LENGTH l))
   
   [<a name="MDILATE_LENGTH_LOWER-val"><b>MDILATE_LENGTH_LOWER</b></a>]  Theorem
      
       l e n. LENGTH l  LENGTH (MDILATE e n l)
   
   [<a name="MDILATE_LENGTH_UPPER-val"><b>MDILATE_LENGTH_UPPER</b></a>]  Theorem
      
       l e n. 0 &lt; n  LENGTH (MDILATE e n l)  SUC (n * PRE (LENGTH l))
   
   [<a name="MDILATE_NIL-val"><b>MDILATE_NIL</b></a>]  Theorem
      
       e n. MDILATE e n [] = []
   
   [<a name="MDILATE_SING-val"><b>MDILATE_SING</b></a>]  Theorem
      
       e n x. MDILATE e n [x] = [x]
   
   [<a name="MEM_MAP2-val"><b>MEM_MAP2</b></a>]  Theorem
      
       f x l1 l2.
          MEM x (MAP2 f l1 l2) 
          y1 y2. x = f y1 y2  MEM y1 l1  MEM y2 l2
   
   [<a name="MEM_MAP2_LOWER-val"><b>MEM_MAP2_LOWER</b></a>]  Theorem
      
       f. MONO2 f 
            lx ly e.
              MEM e (MAP2 f lx ly)  f (MIN_LIST lx) (MIN_LIST ly)  e
   
   [<a name="MEM_MAP2_UPPER-val"><b>MEM_MAP2_UPPER</b></a>]  Theorem
      
       f. MONO2 f 
            lx ly e.
              MEM e (MAP2 f lx ly)  e  f (MAX_LIST lx) (MAX_LIST ly)
   
   [<a name="MEM_MAP3-val"><b>MEM_MAP3</b></a>]  Theorem
      
       f x l1 l2 l3.
          MEM x (MAP3 f l1 l2 l3) 
          y1 y2 y3. x = f y1 y2 y3  MEM y1 l1  MEM y2 l2  MEM y3 l3
   
   [<a name="MEM_MAP3_LOWER-val"><b>MEM_MAP3_LOWER</b></a>]  Theorem
      
       f. MONO3 f 
            lx ly lz e.
              MEM e (MAP3 f lx ly lz) 
              f (MIN_LIST lx) (MIN_LIST ly) (MIN_LIST lz)  e
   
   [<a name="MEM_MAP3_UPPER-val"><b>MEM_MAP3_UPPER</b></a>]  Theorem
      
       f. MONO3 f 
            lx ly lz e.
              MEM e (MAP3 f lx ly lz) 
              e  f (MAX_LIST lx) (MAX_LIST ly) (MAX_LIST lz)
   
   [<a name="MEM_MAP_LOWER-val"><b>MEM_MAP_LOWER</b></a>]  Theorem
      
       f. MONO f  ls e. MEM e (MAP f ls)  f (MIN_LIST ls)  e
   
   [<a name="MEM_MAP_UPPER-val"><b>MEM_MAP_UPPER</b></a>]  Theorem
      
       f. MONO f  ls e. MEM e (MAP f ls)  e  f (MAX_LIST ls)
   
   [<a name="MIN_LIST_MONO_MAP-val"><b>MIN_LIST_MONO_MAP</b></a>]  Theorem
      
       f. MONO f  ls. ls  []  MIN_LIST (MAP f ls) = f (MIN_LIST ls)
   
   [<a name="MONO_LIST_TO_SET-val"><b>MONO_LIST_TO_SET</b></a>]  Theorem
      
       x. set [x] = {x}
   
   [<a name="PAD_LEFT_0-val"><b>PAD_LEFT_0</b></a>]  Theorem
      
       l c. PAD_LEFT c 0 l = l
   
   [<a name="PAD_LEFT_BY_LEFT-val"><b>PAD_LEFT_BY_LEFT</b></a>]  Theorem
      
       ls c n. PAD_LEFT c n ls = PAD_LEFT c (n  LENGTH ls) []  ls
   
   [<a name="PAD_LEFT_BY_RIGHT-val"><b>PAD_LEFT_BY_RIGHT</b></a>]  Theorem
      
       ls c n. PAD_LEFT c n ls = PAD_RIGHT c (n  LENGTH ls) []  ls
   
   [<a name="PAD_LEFT_CONS-val"><b>PAD_LEFT_CONS</b></a>]  Theorem
      
       l n. LENGTH l  n  c. PAD_LEFT c (SUC n) l = c::PAD_LEFT c n l
   
   [<a name="PAD_LEFT_EQ_NIL-val"><b>PAD_LEFT_EQ_NIL</b></a>]  Theorem
      
       l c n. PAD_LEFT c n l = []  l = []  n = 0
   
   [<a name="PAD_LEFT_ID-val"><b>PAD_LEFT_ID</b></a>]  Theorem
      
       l c n. n  LENGTH l  PAD_LEFT c n l = l
   
   [<a name="PAD_LEFT_LAST-val"><b>PAD_LEFT_LAST</b></a>]  Theorem
      
       l c n. l  []  LAST (PAD_LEFT c n l) = LAST l
   
   [<a name="PAD_LEFT_LENGTH-val"><b>PAD_LEFT_LENGTH</b></a>]  Theorem
      
       n c s. LENGTH (PAD_LEFT c n s) = MAX n (LENGTH s)
   
   [<a name="PAD_LEFT_NIL-val"><b>PAD_LEFT_NIL</b></a>]  Theorem
      
       n c. PAD_LEFT c n [] = GENLIST (K c) n
   
   [<a name="PAD_LEFT_NIL_EQ-val"><b>PAD_LEFT_NIL_EQ</b></a>]  Theorem
      
       n c. 0 &lt; n  PAD_LEFT c n [] = PAD_LEFT c n [c]
   
   [<a name="PAD_RIGHT_0-val"><b>PAD_RIGHT_0</b></a>]  Theorem
      
       l c. PAD_RIGHT c 0 l = l
   
   [<a name="PAD_RIGHT_BY_LEFT-val"><b>PAD_RIGHT_BY_LEFT</b></a>]  Theorem
      
       ls c n. PAD_RIGHT c n ls = ls  PAD_LEFT c (n  LENGTH ls) []
   
   [<a name="PAD_RIGHT_BY_RIGHT-val"><b>PAD_RIGHT_BY_RIGHT</b></a>]  Theorem
      
       ls c n. PAD_RIGHT c n ls = ls  PAD_RIGHT c (n  LENGTH ls) []
   
   [<a name="PAD_RIGHT_CONS-val"><b>PAD_RIGHT_CONS</b></a>]  Theorem
      
       h t c n. h::PAD_RIGHT c n t = PAD_RIGHT c (SUC n) (h::t)
   
   [<a name="PAD_RIGHT_EQ_NIL-val"><b>PAD_RIGHT_EQ_NIL</b></a>]  Theorem
      
       l c n. PAD_RIGHT c n l = []  l = []  n = 0
   
   [<a name="PAD_RIGHT_ID-val"><b>PAD_RIGHT_ID</b></a>]  Theorem
      
       l c n. n  LENGTH l  PAD_RIGHT c n l = l
   
   [<a name="PAD_RIGHT_LENGTH-val"><b>PAD_RIGHT_LENGTH</b></a>]  Theorem
      
       n c s. LENGTH (PAD_RIGHT c n s) = MAX n (LENGTH s)
   
   [<a name="PAD_RIGHT_NIL-val"><b>PAD_RIGHT_NIL</b></a>]  Theorem
      
       n c. PAD_RIGHT c n [] = GENLIST (K c) n
   
   [<a name="PAD_RIGHT_NIL_EQ-val"><b>PAD_RIGHT_NIL_EQ</b></a>]  Theorem
      
       n c. 0 &lt; n  PAD_RIGHT c n [] = PAD_RIGHT c n [c]
   
   [<a name="PAD_RIGHT_SNOC-val"><b>PAD_RIGHT_SNOC</b></a>]  Theorem
      
       l n.
          LENGTH l  n 
          c. PAD_RIGHT c (SUC n) l = SNOC c (PAD_RIGHT c n l)
   
   [<a name="POSITIVE_THM-val"><b>POSITIVE_THM</b></a>]  Theorem
      
       ls. EVERY_POSITIVE ls  POSITIVE ls
   
   [<a name="PROD_ACC_PROD_LEM-val"><b>PROD_ACC_PROD_LEM</b></a>]  Theorem
      
       L n. PROD_ACC L n = PROD L * n
   
   [<a name="PROD_ACC_SUM_LEM-val"><b>PROD_ACC_SUM_LEM</b></a>]  Theorem
      
       L n. PROD_ACC L n = PROD L * n
   
   [<a name="PROD_APPEND-val"><b>PROD_APPEND</b></a>]  Theorem
      
       l1 l2. PROD (l1  l2) = PROD l1 * PROD l2
   
   [<a name="PROD_CONS-val"><b>PROD_CONS</b></a>]  Theorem
      
       h t. PROD (h::t) = h * PROD t
   
   [<a name="PROD_CONSTANT-val"><b>PROD_CONSTANT</b></a>]  Theorem
      
       n x. PROD (GENLIST (j. x) n) = x ** n
   
   [<a name="PROD_EQ_0-val"><b>PROD_EQ_0</b></a>]  Theorem
      
       l. PROD l = 0  MEM 0 l
   
   [<a name="PROD_GENLIST_K-val"><b>PROD_GENLIST_K</b></a>]  Theorem
      
       m n. PROD (GENLIST (K m) n) = m ** n
   
   [<a name="PROD_IMAGE_eq_PROD_MAP_SET_TO_LIST-val"><b>PROD_IMAGE_eq_PROD_MAP_SET_TO_LIST</b></a>]  Theorem
      
       s. FINITE s  f.  f s = PROD (MAP f (SET_TO_LIST s))
   
   [<a name="PROD_MAP_FOLDL-val"><b>PROD_MAP_FOLDL</b></a>]  Theorem
      
       ls f. PROD (MAP f ls) = FOLDL (a e. a * f e) 1 ls
   
   [<a name="PROD_NIL-val"><b>PROD_NIL</b></a>]  Theorem
      
       PROD [] = 1
   
   [<a name="PROD_POS-val"><b>PROD_POS</b></a>]  Theorem
      
       l. EVERY_POSITIVE l  0 &lt; PROD l
   
   [<a name="PROD_POS_ALT-val"><b>PROD_POS_ALT</b></a>]  Theorem
      
       l. POSITIVE l  0 &lt; PROD l
   
   [<a name="PROD_PROD_ACC-val"><b>PROD_PROD_ACC</b></a>]  Theorem
      
       L. PROD L = PROD_ACC L 1
   
   [<a name="PROD_SING-val"><b>PROD_SING</b></a>]  Theorem
      
       n. PROD [n] = n
   
   [<a name="PROD_SNOC-val"><b>PROD_SNOC</b></a>]  Theorem
      
       x l. PROD (SNOC x l) = PROD l * x
   
   [<a name="PROD_SQUARING_LIST-val"><b>PROD_SQUARING_LIST</b></a>]  Theorem
      
       m n. PROD (GENLIST (j. n ** 2 ** j) m) = n ** tops 2 m
   
   [<a name="PROD_eq_1-val"><b>PROD_eq_1</b></a>]  Theorem
      
       ls. PROD ls = 1  x. MEM x ls  x = 1
   
   [<a name="PROD_eval-val"><b>PROD_eval</b></a>]  Theorem
      
       ls. PROD ls = if ls = [] then 1 else HD ls * PROD (TL ls)
   
   [<a name="SUM_ADD_GENLIST-val"><b>SUM_ADD_GENLIST</b></a>]  Theorem
      
       a b n.
          SUM (GENLIST a n) + SUM (GENLIST b n) =
          SUM (GENLIST (k. a k + b k) n)
   
   [<a name="SUM_CONS-val"><b>SUM_CONS</b></a>]  Theorem
      
       h t. SUM (h::t) = h + SUM t
   
   [<a name="SUM_CONSTANT-val"><b>SUM_CONSTANT</b></a>]  Theorem
      
       n x. SUM (GENLIST (j. x) n) = n * x
   
   [<a name="SUM_DECOMPOSE_FIRST-val"><b>SUM_DECOMPOSE_FIRST</b></a>]  Theorem
      
       f n. SUM (GENLIST f (SUC n)) = f 0 + SUM (GENLIST (f  SUC) n)
   
   [<a name="SUM_DECOMPOSE_FIRST_LAST-val"><b>SUM_DECOMPOSE_FIRST_LAST</b></a>]  Theorem
      
       f n.
          0 &lt; n 
          SUM (GENLIST f (SUC n)) =
          f 0 + SUM (GENLIST (f  SUC) (PRE n)) + f n
   
   [<a name="SUM_DECOMPOSE_LAST-val"><b>SUM_DECOMPOSE_LAST</b></a>]  Theorem
      
       f n. SUM (GENLIST f (SUC n)) = SUM (GENLIST f n) + f n
   
   [<a name="SUM_DOUBLING_LIST-val"><b>SUM_DOUBLING_LIST</b></a>]  Theorem
      
       m n. SUM (GENLIST (j. n * 2 ** j) m) = n * tops 2 m
   
   [<a name="SUM_EQ_0-val"><b>SUM_EQ_0</b></a>]  Theorem
      
       l. SUM l = 0  EVERY (x. x = 0) l
   
   [<a name="SUM_GENLIST-val"><b>SUM_GENLIST</b></a>]  Theorem
      
       f n. SUM (GENLIST f n) =  f (count n)
   
   [<a name="SUM_GENLIST_APPEND-val"><b>SUM_GENLIST_APPEND</b></a>]  Theorem
      
       a b n.
          SUM (GENLIST a n  GENLIST b n) = SUM (GENLIST (k. a k + b k) n)
   
   [<a name="SUM_GENLIST_K-val"><b>SUM_GENLIST_K</b></a>]  Theorem
      
       m n. SUM (GENLIST (K m) n) = m * n
   
   [<a name="SUM_GENLIST_MOD-val"><b>SUM_GENLIST_MOD</b></a>]  Theorem
      
       n. 0 &lt; n 
            f. SUM (GENLIST ((k. f k)  SUC) (PRE n)) MOD n =
                SUM (GENLIST ((k. f k MOD n)  SUC) (PRE n)) MOD n
   
   [<a name="SUM_GENLIST_REVERSE-val"><b>SUM_GENLIST_REVERSE</b></a>]  Theorem
      
       f n. SUM (GENLIST (j. f (n  j)) n) = SUM (MAP f [1 .. n])
   
   [<a name="SUM_IMAGE_count-val"><b>SUM_IMAGE_count</b></a>]  Theorem
      
       f n.  f (count n) = SUM (MAP f [0 ..&lt; n])
   
   [<a name="SUM_IMAGE_upto-val"><b>SUM_IMAGE_upto</b></a>]  Theorem
      
       f n.  f (upto n) = SUM (MAP f [0 .. n])
   
   [<a name="SUM_LE-val"><b>SUM_LE</b></a>]  Theorem
      
       l1 l2.
          LENGTH l1 = LENGTH l2  (k. k &lt; LENGTH l1  EL k l1  EL k l2) 
          SUM l1  SUM l2
   
   [<a name="SUM_LEFT_ADD_DISTRIB-val"><b>SUM_LEFT_ADD_DISTRIB</b></a>]  Theorem
      
       s m n. SUM s * (m + n) = SUM (MAP ($* m) s) + SUM (MAP ($* n) s)
   
   [<a name="SUM_LE_EL-val"><b>SUM_LE_EL</b></a>]  Theorem
      
       l n. n &lt; LENGTH l  EL n l  SUM l
   
   [<a name="SUM_LE_MEM-val"><b>SUM_LE_MEM</b></a>]  Theorem
      
       l x. MEM x l  x  SUM l
   
   [<a name="SUM_LE_SUM_EL-val"><b>SUM_LE_SUM_EL</b></a>]  Theorem
      
       l m n. m &lt; n  n &lt; LENGTH l  EL m l + EL n l  SUM l
   
   [<a name="SUM_LOWER-val"><b>SUM_LOWER</b></a>]  Theorem
      
       ls. MIN_LIST ls * LENGTH ls  SUM ls
   
   [<a name="SUM_MAP2_K-val"><b>SUM_MAP2_K</b></a>]  Theorem
      
       lx ly c.
          SUM (MAP2 (x y. c) lx ly) = c * LENGTH (MAP2 (x y. c) lx ly)
   
   [<a name="SUM_MAP2_UPPER-val"><b>SUM_MAP2_UPPER</b></a>]  Theorem
      
       f. MONO2 f 
            lx ly.
              SUM (MAP2 f lx ly) 
              f (MAX_LIST lx) (MAX_LIST ly) * LENGTH (MAP2 f lx ly)
   
   [<a name="SUM_MAP3_K-val"><b>SUM_MAP3_K</b></a>]  Theorem
      
       lx ly lz c.
          SUM (MAP3 (x y z. c) lx ly lz) =
          c * LENGTH (MAP3 (x y z. c) lx ly lz)
   
   [<a name="SUM_MAP3_UPPER-val"><b>SUM_MAP3_UPPER</b></a>]  Theorem
      
       f. MONO3 f 
            lx ly lz.
              SUM (MAP3 f lx ly lz) 
              f (MAX_LIST lx) (MAX_LIST ly) (MAX_LIST lz) *
              LENGTH (MAP3 f lx ly lz)
   
   [<a name="SUM_MAP_K-val"><b>SUM_MAP_K</b></a>]  Theorem
      
       ls c. SUM (MAP (K c) ls) = c * LENGTH ls
   
   [<a name="SUM_MAP_K_LE-val"><b>SUM_MAP_K_LE</b></a>]  Theorem
      
       ls a b. a  b  SUM (MAP (K a) ls)  SUM (MAP (K b) ls)
   
   [<a name="SUM_MAP_LE-val"><b>SUM_MAP_LE</b></a>]  Theorem
      
       f g ls. EVERY (x. f x  g x) ls  SUM (MAP f ls)  SUM (MAP g ls)
   
   [<a name="SUM_MAP_LT-val"><b>SUM_MAP_LT</b></a>]  Theorem
      
       f g ls.
          EVERY (x. f x &lt; g x) ls  ls  [] 
          SUM (MAP f ls) &lt; SUM (MAP g ls)
   
   [<a name="SUM_MAP_UPPER-val"><b>SUM_MAP_UPPER</b></a>]  Theorem
      
       f. MONO f  ls. SUM (MAP f ls)  f (MAX_LIST ls) * LENGTH ls
   
   [<a name="SUM_MOD-val"><b>SUM_MOD</b></a>]  Theorem
      
       n. 0 &lt; n  l. SUM l MOD n = SUM (MAP (x. x MOD n) l) MOD n
   
   [<a name="SUM_MONO_MAP-val"><b>SUM_MONO_MAP</b></a>]  Theorem
      
       f1 f2. (x. f1 x  f2 x)  ls. SUM (MAP f1 ls)  SUM (MAP f2 ls)
   
   [<a name="SUM_MONO_MAP2-val"><b>SUM_MONO_MAP2</b></a>]  Theorem
      
       f1 f2.
          (x y. f1 x y  f2 x y) 
          lx ly. SUM (MAP2 f1 lx ly)  SUM (MAP2 f2 lx ly)
   
   [<a name="SUM_MONO_MAP3-val"><b>SUM_MONO_MAP3</b></a>]  Theorem
      
       f1 f2.
          (x y z. f1 x y z  f2 x y z) 
          lx ly lz. SUM (MAP3 f1 lx ly lz)  SUM (MAP3 f2 lx ly lz)
   
   [<a name="SUM_MULT-val"><b>SUM_MULT</b></a>]  Theorem
      
       s k. k * SUM s = SUM (MAP ($* k) s)
   
   [<a name="SUM_NIL-val"><b>SUM_NIL</b></a>]  Theorem
      
       SUM [] = 0
   
   [<a name="SUM_RIGHT_ADD_DISTRIB-val"><b>SUM_RIGHT_ADD_DISTRIB</b></a>]  Theorem
      
       s m n. (m + n) * SUM s = SUM (MAP ($* m) s) + SUM (MAP ($* n) s)
   
   [<a name="SUM_SING-val"><b>SUM_SING</b></a>]  Theorem
      
       n. SUM [n] = n
   
   [<a name="SUM_UPPER-val"><b>SUM_UPPER</b></a>]  Theorem
      
       ls. SUM ls  MAX_LIST ls * LENGTH ls
   
   [<a name="SURJ_CARD_IMAGE_EQ-val"><b>SURJ_CARD_IMAGE_EQ</b></a>]  Theorem
      
       f s t.
          FINITE t  over f s t  (SURJ f s t  CARD (IMAGE f s) = CARD t)
   
   [<a name="arithmetic_sum_eqn-val"><b>arithmetic_sum_eqn</b></a>]  Theorem
      
       n. SUM [1 ..&lt; n] = HALF (n * (n  1))
   
   [<a name="arithmetic_sum_eqn_alt-val"><b>arithmetic_sum_eqn_alt</b></a>]  Theorem
      
       n. SUM [1 .. n] = HALF (n * (n + 1))
   
   [<a name="arrange_0_n-val"><b>arrange_0_n</b></a>]  Theorem
      
       n. 0 &lt; n  0 arrange n = 0
   
   [<a name="arrange_alt-val"><b>arrange_alt</b></a>]  Theorem
      
       n k. n arrange k = (n choose k) * FACT k
   
   [<a name="arrange_eq_0-val"><b>arrange_eq_0</b></a>]  Theorem
      
       n k. n arrange k = 0  n &lt; k
   
   [<a name="arrange_eqn-val"><b>arrange_eqn</b></a>]  Theorem
      
       n k. n arrange k = (n choose k) * perm k
   
   [<a name="arrange_formula-val"><b>arrange_formula</b></a>]  Theorem
      
       n k. n arrange k = binomial n k * FACT k
   
   [<a name="arrange_formula2-val"><b>arrange_formula2</b></a>]  Theorem
      
       n k. k  n  n arrange k = FACT n DIV FACT (n  k)
   
   [<a name="arrange_n_0-val"><b>arrange_n_0</b></a>]  Theorem
      
       n. n arrange 0 = 1
   
   [<a name="arrange_n_n-val"><b>arrange_n_n</b></a>]  Theorem
      
       n. n arrange n = perm n
   
   [<a name="arrange_n_n_alt-val"><b>arrange_n_n_alt</b></a>]  Theorem
      
       n. n arrange n = FACT n
   
   [<a name="beta_0_n-val"><b>beta_0_n</b></a>]  Theorem
      
       n. beta 0 n = 0
   
   [<a name="beta_alt-val"><b>beta_alt</b></a>]  Theorem
      
       n k. 0 &lt; n  0 &lt; k  beta n k = leibniz (n  1) (k  1)
   
   [<a name="beta_divides_beta_factor-val"><b>beta_divides_beta_factor</b></a>]  Theorem
      
       m n k. k  m  m  n  beta n k divides beta m k * binomial n m
   
   [<a name="beta_eq_0-val"><b>beta_eq_0</b></a>]  Theorem
      
       n k. beta n k = 0  k = 0  n &lt; k
   
   [<a name="beta_eqn-val"><b>beta_eqn</b></a>]  Theorem
      
       n k. beta (n + 1) (k + 1) = leibniz n k
   
   [<a name="beta_horizontal_0-val"><b>beta_horizontal_0</b></a>]  Theorem
      
       beta_horizontal 0 = []
   
   [<a name="beta_horizontal_alt-val"><b>beta_horizontal_alt</b></a>]  Theorem
      
       n. 0 &lt; n  beta_horizontal n = leibniz_horizontal (n  1)
   
   [<a name="beta_horizontal_element-val"><b>beta_horizontal_element</b></a>]  Theorem
      
       n k. k &lt; n  EL k (beta_horizontal n) = beta n (k + 1)
   
   [<a name="beta_horizontal_eqn-val"><b>beta_horizontal_eqn</b></a>]  Theorem
      
       n. beta_horizontal (n + 1) = leibniz_horizontal n
   
   [<a name="beta_horizontal_len-val"><b>beta_horizontal_len</b></a>]  Theorem
      
       n. LENGTH (beta_horizontal n) = n
   
   [<a name="beta_horizontal_mem-val"><b>beta_horizontal_mem</b></a>]  Theorem
      
       n k. 0 &lt; k  k  n  MEM (beta n k) (beta_horizontal n)
   
   [<a name="beta_horizontal_mem_iff-val"><b>beta_horizontal_mem_iff</b></a>]  Theorem
      
       n k. MEM (beta n k) (beta_horizontal n)  0 &lt; k  k  n
   
   [<a name="beta_horizontal_member-val"><b>beta_horizontal_member</b></a>]  Theorem
      
       n x. MEM x (beta_horizontal n)  k. 0 &lt; k  k  n  x = beta n k
   
   [<a name="beta_less_0-val"><b>beta_less_0</b></a>]  Theorem
      
       n k. n &lt; k  beta n k = 0
   
   [<a name="beta_n_0-val"><b>beta_n_0</b></a>]  Theorem
      
       n. beta n 0 = 0
   
   [<a name="beta_pos-val"><b>beta_pos</b></a>]  Theorem
      
       n k. 0 &lt; k  k  n  0 &lt; beta n k
   
   [<a name="beta_sym-val"><b>beta_sym</b></a>]  Theorem
      
       n k. k  n  beta n k = beta n (n  k + 1)
   
   [<a name="big_lcm_corner_transform-val"><b>big_lcm_corner_transform</b></a>]  Theorem
      
       n. big_lcm (leibniz_col (n + 1)) = big_lcm (leibniz_row n (n + 1))
   
   [<a name="big_lcm_count_lower_bound-val"><b>big_lcm_count_lower_bound</b></a>]  Theorem
      
       f n.
          (x. x  count (n + 1)  0 &lt; f x) 
          SUM (GENLIST f (n + 1)) 
          (n + 1) * big_lcm (IMAGE f (count (n + 1)))
   
   [<a name="big_lcm_eq_list_lcm-val"><b>big_lcm_eq_list_lcm</b></a>]  Theorem
      
       l. big_lcm (set l) = list_lcm l
   
   [<a name="big_lcm_ge_max-val"><b>big_lcm_ge_max</b></a>]  Theorem
      
       s. FINITE s  (x. x  s  0 &lt; x)  MAX_SET s  big_lcm s
   
   [<a name="big_lcm_lower_bound-val"><b>big_lcm_lower_bound</b></a>]  Theorem
      
       n. 2 ** n  big_lcm (natural (n + 1))
   
   [<a name="big_lcm_natural_eqn-val"><b>big_lcm_natural_eqn</b></a>]  Theorem
      
       n. big_lcm (natural (n + 1)) =
            (n + 1) * big_lcm (IMAGE (binomial n) (count (n + 1)))
   
   [<a name="big_lcm_non_decreasing-val"><b>big_lcm_non_decreasing</b></a>]  Theorem
      
       n. big_lcm (natural n)  big_lcm (natural (n + 1))
   
   [<a name="big_lcm_row_transform-val"><b>big_lcm_row_transform</b></a>]  Theorem
      
       n h.
          lcm (leibniz (n + 1) 0) (big_lcm (leibniz_row n h)) =
          big_lcm (leibniz_row (n + 1) (h + 1))
   
   [<a name="big_lcm_seg_transform-val"><b>big_lcm_seg_transform</b></a>]  Theorem
      
       n k h.
          lcm (leibniz (n + 1) k) (big_lcm (leibniz_seg n k h)) =
          big_lcm (leibniz_seg (n + 1) k (h + 1))
   
   [<a name="bij_eq_card-val"><b>bij_eq_card</b></a>]  Theorem
      
       s t. s =b= t  (FINITE s  FINITE t)  CARD s = CARD t
   
   [<a name="bij_eq_card_eq-val"><b>bij_eq_card_eq</b></a>]  Theorem
      
       s t. FINITE s  FINITE t  (s =b= t  CARD s = CARD t)
   
   [<a name="bij_eq_count-val"><b>bij_eq_count</b></a>]  Theorem
      
       s. FINITE s  s =b= count (CARD s)
   
   [<a name="bij_eq_empty-val"><b>bij_eq_empty</b></a>]  Theorem
      
       s t. s =b= t  (s =   t = )
   
   [<a name="bij_eq_equiv_on-val"><b>bij_eq_equiv_on</b></a>]  Theorem
      
       P. (s t. s =b= t) equiv_on P
   
   [<a name="bij_eq_finite-val"><b>bij_eq_finite</b></a>]  Theorem
      
       s t. s =b= t  (FINITE s  FINITE t)
   
   [<a name="bij_eq_refl-val"><b>bij_eq_refl</b></a>]  Theorem
      
       s. s =b= s
   
   [<a name="bij_eq_sym-val"><b>bij_eq_sym</b></a>]  Theorem
      
       s t. s =b= t  t =b= s
   
   [<a name="bij_eq_trans-val"><b>bij_eq_trans</b></a>]  Theorem
      
       s t u. s =b= t  t =b= u  s =b= u
   
   [<a name="bij_iff_preimage_card_eq_1-val"><b>bij_iff_preimage_card_eq_1</b></a>]  Theorem
      
       f s t.
          FINITE s  over f s t 
          (BIJ f s t  y. y  t  CARD (preimage f s y) = 1)
   
   [<a name="bij_preimage_sing-val"><b>bij_preimage_sing</b></a>]  Theorem
      
       f s t. BIJ f s t  over f s t  y. y  t  SING (preimage f s y)
   
   [<a name="binomial_0_n-val"><b>binomial_0_n</b></a>]  Theorem
      
       n. binomial 0 n = if n = 0 then 1 else 0
   
   [<a name="binomial_1_n-val"><b>binomial_1_n</b></a>]  Theorem
      
       n. binomial 1 n = if 1 &lt; n then 0 else 1
   
   [<a name="binomial_alt-val"><b>binomial_alt</b></a>]  Theorem
      
       n k.
          binomial n 0 = 1  binomial 0 (k + 1) = 0 
          binomial (n + 1) (k + 1) = binomial n k + binomial n (k + 1)
   
   [<a name="binomial_compute-val"><b>binomial_compute</b></a>]  Theorem
      
       binomial 0 0 = 1  (n. binomial (NUMERAL (BIT1 n)) 0 = 1) 
        (n. binomial (NUMERAL (BIT2 n)) 0 = 1) 
        (k. binomial 0 (NUMERAL (BIT1 k)) = 0) 
        (k. binomial 0 (NUMERAL (BIT2 k)) = 0) 
        (n k.
           binomial (NUMERAL (BIT1 n)) (NUMERAL (BIT1 k)) =
           binomial (NUMERAL (BIT1 n)  1) (NUMERAL (BIT1 k)  1) +
           binomial (NUMERAL (BIT1 n)  1) (NUMERAL (BIT1 k))) 
        (n k.
           binomial (NUMERAL (BIT2 n)) (NUMERAL (BIT1 k)) =
           binomial (NUMERAL (BIT1 n)) (NUMERAL (BIT1 k)  1) +
           binomial (NUMERAL (BIT1 n)) (NUMERAL (BIT1 k))) 
        (n k.
           binomial (NUMERAL (BIT1 n)) (NUMERAL (BIT2 k)) =
           binomial (NUMERAL (BIT1 n)  1) (NUMERAL (BIT1 k)) +
           binomial (NUMERAL (BIT1 n)  1) (NUMERAL (BIT2 k))) 
        n k.
          binomial (NUMERAL (BIT2 n)) (NUMERAL (BIT2 k)) =
          binomial (NUMERAL (BIT1 n)) (NUMERAL (BIT1 k)) +
          binomial (NUMERAL (BIT1 n)) (NUMERAL (BIT2 k))
   
   [<a name="binomial_def-val"><b>binomial_def</b></a>]  Theorem
      
       binomial 0 0 = 1  (n. binomial (SUC n) 0 = 1) 
        (k. binomial 0 (SUC k) = 0) 
        n k. binomial (SUC n) (SUC k) = binomial n k + binomial n (SUC k)
   
   [<a name="binomial_eq_0-val"><b>binomial_eq_0</b></a>]  Theorem
      
       n k. binomial n k = 0  n &lt; k
   
   [<a name="binomial_fact-val"><b>binomial_fact</b></a>]  Theorem
      
       n k. k  n  binomial n k = FACT n DIV (FACT k * FACT (n  k))
   
   [<a name="binomial_formula-val"><b>binomial_formula</b></a>]  Theorem
      
       n k. binomial (n + k) k * (FACT n * FACT k) = FACT (n + k)
   
   [<a name="binomial_formula2-val"><b>binomial_formula2</b></a>]  Theorem
      
       n k. k  n  FACT n = binomial n k * (FACT (n  k) * FACT k)
   
   [<a name="binomial_formula3-val"><b>binomial_formula3</b></a>]  Theorem
      
       n k. k  n  binomial n k = FACT n DIV (FACT k * FACT (n  k))
   
   [<a name="binomial_horizontal_0-val"><b>binomial_horizontal_0</b></a>]  Theorem
      
       binomial_horizontal 0 = [1]
   
   [<a name="binomial_horizontal_element-val"><b>binomial_horizontal_element</b></a>]  Theorem
      
       n k. k  n  EL k (binomial_horizontal n) = binomial n k
   
   [<a name="binomial_horizontal_len-val"><b>binomial_horizontal_len</b></a>]  Theorem
      
       n. LENGTH (binomial_horizontal n) = n + 1
   
   [<a name="binomial_horizontal_max-val"><b>binomial_horizontal_max</b></a>]  Theorem
      
       n. MAX_LIST (binomial_horizontal n) = binomial n (HALF n)
   
   [<a name="binomial_horizontal_mem-val"><b>binomial_horizontal_mem</b></a>]  Theorem
      
       n k. k &lt; n + 1  MEM (binomial n k) (binomial_horizontal n)
   
   [<a name="binomial_horizontal_mem_iff-val"><b>binomial_horizontal_mem_iff</b></a>]  Theorem
      
       n k. MEM (binomial n k) (binomial_horizontal n)  k  n
   
   [<a name="binomial_horizontal_member-val"><b>binomial_horizontal_member</b></a>]  Theorem
      
       n x. MEM x (binomial_horizontal n)  k. k  n  x = binomial n k
   
   [<a name="binomial_horizontal_pos-val"><b>binomial_horizontal_pos</b></a>]  Theorem
      
       n. EVERY_POSITIVE (binomial_horizontal n)
   
   [<a name="binomial_horizontal_pos_alt-val"><b>binomial_horizontal_pos_alt</b></a>]  Theorem
      
       n x. MEM x (binomial_horizontal n)  0 &lt; x
   
   [<a name="binomial_horizontal_sum-val"><b>binomial_horizontal_sum</b></a>]  Theorem
      
       n. SUM (binomial_horizontal n) = 2 ** n
   
   [<a name="binomial_iff-val"><b>binomial_iff</b></a>]  Theorem
      
       f. f = binomial 
            n k.
              f n 0 = 1  f 0 (k + 1) = 0 
              f (n + 1) (k + 1) = f n k + f n (k + 1)
   
   [<a name="binomial_ind-val"><b>binomial_ind</b></a>]  Theorem
      
       P. P 0 0  (n. P (SUC n) 0)  (k. P 0 (SUC k)) 
            (n k. P n k  P n (SUC k)  P (SUC n) (SUC k)) 
            v v1. P v v1
   
   [<a name="binomial_index_shift-val"><b>binomial_index_shift</b></a>]  Theorem
      
       n x y.
          (k. binomial (SUC n) k * x ** (SUC n  k) * y ** k)  SUC =
          (k. binomial (SUC n) (SUC k) * x ** (n  k) * y ** SUC k)
   
   [<a name="binomial_is_integer-val"><b>binomial_is_integer</b></a>]  Theorem
      
       n k. k  n  FACT k * FACT (n  k) divides FACT n
   
   [<a name="binomial_less_0-val"><b>binomial_less_0</b></a>]  Theorem
      
       n k. n &lt; k  binomial n k = 0
   
   [<a name="binomial_max-val"><b>binomial_max</b></a>]  Theorem
      
       n k. binomial n k  binomial n (HALF n)
   
   [<a name="binomial_middle_by_stirling-val"><b>binomial_middle_by_stirling</b></a>]  Theorem
      
       Stirling 
        n. 0 &lt; n  EVEN n 
            binomial n (HALF n) = 2 ** (n + 1) DIV SQRT (TWICE pi * n)
   
   [<a name="binomial_middle_upper_bound-val"><b>binomial_middle_upper_bound</b></a>]  Theorem
      
       n. binomial n (HALF n)  4 ** HALF n
   
   [<a name="binomial_mod_zero-val"><b>binomial_mod_zero</b></a>]  Theorem
      
       n. 0 &lt; n 
            k. binomial n k MOD n = 0 
                x y. (binomial n k * x ** (n  k) * y ** k) MOD n = 0
   
   [<a name="binomial_mod_zero_alt-val"><b>binomial_mod_zero_alt</b></a>]  Theorem
      
       n. 0 &lt; n 
            ((k. 0 &lt; k  k &lt; n  binomial n k MOD n = 0) 
             x y.
               SUM
                 (GENLIST
                    ((k. (binomial n k * x ** (n  k) * y ** k) MOD n) 
                     SUC) (PRE n)) =
               0)
   
   [<a name="binomial_monotone-val"><b>binomial_monotone</b></a>]  Theorem
      
       n k. k &lt; HALF n  binomial n k &lt; binomial n (k + 1)
   
   [<a name="binomial_n_0-val"><b>binomial_n_0</b></a>]  Theorem
      
       n. binomial n 0 = 1
   
   [<a name="binomial_n_1-val"><b>binomial_n_1</b></a>]  Theorem
      
       n. binomial n 1 = n
   
   [<a name="binomial_n_k-val"><b>binomial_n_k</b></a>]  Theorem
      
       n k. k  n  binomial n k = FACT n DIV FACT k DIV FACT (n  k)
   
   [<a name="binomial_n_n-val"><b>binomial_n_n</b></a>]  Theorem
      
       n. binomial n n = 1
   
   [<a name="binomial_pos-val"><b>binomial_pos</b></a>]  Theorem
      
       n k. k  n  0 &lt; binomial n k
   
   [<a name="binomial_product_identity-val"><b>binomial_product_identity</b></a>]  Theorem
      
       m n k.
          k  m  m  n 
          binomial m k * binomial n m =
          binomial n k * binomial (n  k) (m  k)
   
   [<a name="binomial_range_shift-val"><b>binomial_range_shift</b></a>]  Theorem
      
       n. 0 &lt; n 
            ((k. 0 &lt; k  k &lt; n  binomial n k MOD n = 0) 
             h. h &lt; PRE n  binomial n (SUC h) MOD n = 0)
   
   [<a name="binomial_range_shift_alt-val"><b>binomial_range_shift_alt</b></a>]  Theorem
      
       n. 0 &lt; n 
            ((k. 0 &lt; k  k &lt; n 
                  x y. (binomial n k * x ** (n  k) * y ** k) MOD n = 0) 
             h. h &lt; PRE n 
                 x y.
                   (binomial n (SUC h) * x ** (n  SUC h) * y ** SUC h) MOD
                   n =
                   0)
   
   [<a name="binomial_recurrence-val"><b>binomial_recurrence</b></a>]  Theorem
      
       n k. binomial (SUC n) (SUC k) = binomial n k + binomial n (SUC k)
   
   [<a name="binomial_right-val"><b>binomial_right</b></a>]  Theorem
      
       n. 0 &lt; n 
            k. binomial n (k + 1) = (n  k) * binomial n k DIV (k + 1)
   
   [<a name="binomial_right_eqn-val"><b>binomial_right_eqn</b></a>]  Theorem
      
       n. 0 &lt; n  k. beta n (k + 1) = (n  k) * binomial n k
   
   [<a name="binomial_row_max-val"><b>binomial_row_max</b></a>]  Theorem
      
       n. MAX_SET (IMAGE (binomial n) (count (n + 1))) =
            binomial n (HALF n)
   
   [<a name="binomial_sum-val"><b>binomial_sum</b></a>]  Theorem
      
       n. SUM (GENLIST (binomial n) (SUC n)) = 2 ** n
   
   [<a name="binomial_sum_alt-val"><b>binomial_sum_alt</b></a>]  Theorem
      
       n. SUM (binomial_horizontal n) = 2 ** n
   
   [<a name="binomial_sym-val"><b>binomial_sym</b></a>]  Theorem
      
       n k. k  n  binomial n k = binomial n (n  k)
   
   [<a name="binomial_term_merge_x-val"><b>binomial_term_merge_x</b></a>]  Theorem
      
       n x y.
          (k. x * k)  (k. binomial n k * x ** (n  k) * y ** k) =
          (k. binomial n k * x ** SUC (n  k) * y ** k)
   
   [<a name="binomial_term_merge_y-val"><b>binomial_term_merge_y</b></a>]  Theorem
      
       n x y.
          (k. y * k)  (k. binomial n k * x ** (n  k) * y ** k) =
          (k. binomial n k * x ** (n  k) * y ** SUC k)
   
   [<a name="binomial_thm-val"><b>binomial_thm</b></a>]  Theorem
      
       n x y.
          (x + y) ** n =
          SUM (GENLIST (k. binomial n k * x ** (n  k) * y ** k) (SUC n))
   
   [<a name="binomial_thm_alt-val"><b>binomial_thm_alt</b></a>]  Theorem
      
       n x y.
          (x + y) ** n =
          SUM (GENLIST (k. binomial n k * x ** (n  k) * y ** k) (n + 1))
   
   [<a name="binomial_thm_prime-val"><b>binomial_thm_prime</b></a>]  Theorem
      
       p. prime p  x y. (x + y) ** p MOD p = (x ** p + y ** p) MOD p
   
   [<a name="binomial_up-val"><b>binomial_up</b></a>]  Theorem
      
       n. 0 &lt; n  k. binomial (n  1) k = (n  k) * binomial n k DIV n
   
   [<a name="binomial_up_eqn-val"><b>binomial_up_eqn</b></a>]  Theorem
      
       n. 0 &lt; n  k. n * binomial (n  1) k = (n  k) * binomial n k
   
   [<a name="choose_0_n-val"><b>choose_0_n</b></a>]  Theorem
      
       n. 0 choose n = if n = 0 then 1 else 0
   
   [<a name="choose_1_n-val"><b>choose_1_n</b></a>]  Theorem
      
       n. 1 choose n = if 1 &lt; n then 0 else 1
   
   [<a name="choose_alt-val"><b>choose_alt</b></a>]  Theorem
      
       n k.
          n choose 0 = 1  0 choose (k + 1) = 0 
          (n + 1) choose (k + 1) = n choose k + n choose (k + 1)
   
   [<a name="choose_eq_0-val"><b>choose_eq_0</b></a>]  Theorem
      
       n k. n choose k = 0  n &lt; k
   
   [<a name="choose_eqn-val"><b>choose_eqn</b></a>]  Theorem
      
       n k. n choose k = binomial n k
   
   [<a name="choose_n_0-val"><b>choose_n_0</b></a>]  Theorem
      
       n. n choose 0 = 1
   
   [<a name="choose_n_1-val"><b>choose_n_1</b></a>]  Theorem
      
       n. n choose 1 = n
   
   [<a name="choose_n_n-val"><b>choose_n_n</b></a>]  Theorem
      
       n. n choose n = 1
   
   [<a name="choose_recurrence-val"><b>choose_recurrence</b></a>]  Theorem
      
       n k. (n + 1) choose (k + 1) = n choose k + n choose (k + 1)
   
   [<a name="choose_sum_over_all-val"><b>choose_sum_over_all</b></a>]  Theorem
      
       n. SUM (MAP ($choose n) [0 .. n]) = 2 ** n
   
   [<a name="choose_sum_over_count-val"><b>choose_sum_over_count</b></a>]  Theorem
      
       n.  ($choose n) (upto n) = 2 ** n
   
   [<a name="count_power_partition-val"><b>count_power_partition</b></a>]  Theorem
      
       n. partition (s t. s =b= t) (POW (count n)) =
            IMAGE (sub_count n) (upto n)
   
   [<a name="datatype_triple-val"><b>datatype_triple</b></a>]  Theorem
      
       DATATYPE (record triple a b c)
   
   [<a name="divides_binomials_imp_prime-val"><b>divides_binomials_imp_prime</b></a>]  Theorem
      
       n. 1 &lt; n  (k. 0 &lt; k  k &lt; n  n divides binomial n k)  prime n
   
   [<a name="feq_set_equiv-val"><b>feq_set_equiv</b></a>]  Theorem
      
       s. feq set equiv_on s
   
   [<a name="finite_surj_inj_iff-val"><b>finite_surj_inj_iff</b></a>]  Theorem
      
       f s t.
          FINITE s  SURJ f s t 
          (INJ f s t  e. e  IMAGE (preimage f s) t  CARD e = 1)
   
   [<a name="gcd_prime_product_property-val"><b>gcd_prime_product_property</b></a>]  Theorem
      
       p m n.
          prime p  m divides n  (p * m divides n)  gcd (p * m) n = m
   
   [<a name="geometric_sum_eqn-val"><b>geometric_sum_eqn</b></a>]  Theorem
      
       t n.
          1 &lt; t  SUM (MAP (j. t ** j) [0 ..&lt; n]) = tops t n DIV (t  1)
   
   [<a name="geometric_sum_eqn_alt-val"><b>geometric_sum_eqn_alt</b></a>]  Theorem
      
       t n.
          1 &lt; t 
          SUM (MAP (j. t ** j) [0 .. n]) = tops t (n + 1) DIV (t  1)
   
   [<a name="head_turn-val"><b>head_turn</b></a>]  Theorem
      
       ls. ls  []  HD (turn ls) = LAST ls
   
   [<a name="head_turn_exp-val"><b>head_turn_exp</b></a>]  Theorem
      
       ls n.
          n &lt; LENGTH ls 
          HD (turn_exp ls n) = EL (if n = 0 then 0 else (LENGTH ls  n)) ls
   
   [<a name="inj_iff_preimage_card_le_1-val"><b>inj_iff_preimage_card_le_1</b></a>]  Theorem
      
       f s t.
          FINITE s  over f s t 
          (INJ f s t  y. y  t  CARD (preimage f s y)  1)
   
   [<a name="inj_preimage_empty_or_sing-val"><b>inj_preimage_empty_or_sing</b></a>]  Theorem
      
       f s t.
          INJ f s t 
          over f s t 
          y. y  t  preimage f s y =   SING (preimage f s y)
   
   [<a name="interleave_alt-val"><b>interleave_alt</b></a>]  Theorem
      
       ls x.
          x interleave ls = {TAKE k ls  x::DROP k ls | k | k  LENGTH ls}
   
   [<a name="interleave_card-val"><b>interleave_card</b></a>]  Theorem
      
       ls x. MEM x ls  CARD (x interleave ls) = 1 + LENGTH ls
   
   [<a name="interleave_count_inj-val"><b>interleave_count_inj</b></a>]  Theorem
      
       ls x.
          MEM x ls 
          INJ (k. TAKE k ls  x::DROP k ls) (upto (LENGTH ls)) (: list)
   
   [<a name="interleave_disjoint-val"><b>interleave_disjoint</b></a>]  Theorem
      
       l1 l2 x.
          MEM x l1  l1  l2 
          DISJOINT (x interleave l1) (x interleave l2)
   
   [<a name="interleave_distinct-val"><b>interleave_distinct</b></a>]  Theorem
      
       ls x y.
          ALL_DISTINCT (x::ls)  y  x interleave ls  ALL_DISTINCT y
   
   [<a name="interleave_distinct_alt-val"><b>interleave_distinct_alt</b></a>]  Theorem
      
       ls x y.
          ALL_DISTINCT ls  MEM x ls  y  x interleave ls 
          ALL_DISTINCT y
   
   [<a name="interleave_element-val"><b>interleave_element</b></a>]  Theorem
      
       ls x y.
          y  x interleave ls 
          k. k  LENGTH ls  y = TAKE k ls  x::DROP k ls
   
   [<a name="interleave_eq-val"><b>interleave_eq</b></a>]  Theorem
      
       n x y.
          MEM n x  MEM n y  (n interleave x = n interleave y  x = y)
   
   [<a name="interleave_finite-val"><b>interleave_finite</b></a>]  Theorem
      
       ls x. FINITE (x interleave ls)
   
   [<a name="interleave_has_cons-val"><b>interleave_has_cons</b></a>]  Theorem
      
       ls x. x::ls  x interleave ls
   
   [<a name="interleave_length-val"><b>interleave_length</b></a>]  Theorem
      
       ls x y. y  x interleave ls  LENGTH y = 1 + LENGTH ls
   
   [<a name="interleave_nil-val"><b>interleave_nil</b></a>]  Theorem
      
       x. x interleave [] = {[x]}
   
   [<a name="interleave_not_empty-val"><b>interleave_not_empty</b></a>]  Theorem
      
       ls x. x interleave ls  
   
   [<a name="interleave_revert-val"><b>interleave_revert</b></a>]  Theorem
      
       ls h.
          ALL_DISTINCT ls  MEM h ls 
          t. ALL_DISTINCT t  ls  h interleave t 
              set t = set ls DELETE h
   
   [<a name="interleave_revert_count-val"><b>interleave_revert_count</b></a>]  Theorem
      
       ls n.
          ALL_DISTINCT ls  set ls = upto n 
          t. ALL_DISTINCT t  ls  n interleave t  set t = count n
   
   [<a name="interleave_set-val"><b>interleave_set</b></a>]  Theorem
      
       ls x y. y  x interleave ls  set y = set (x::ls)
   
   [<a name="interleave_set_alt-val"><b>interleave_set_alt</b></a>]  Theorem
      
       ls x y. y  x interleave ls  set y = x INSERT set ls
   
   [<a name="lcm_lower_bound-val"><b>lcm_lower_bound</b></a>]  Theorem
      
       n. 2 ** n  lcm_run (n + 1)
   
   [<a name="lcm_lower_bound_by_big_lcm-val"><b>lcm_lower_bound_by_big_lcm</b></a>]  Theorem
      
       n. (n + 1) * binomial n (HALF n)  big_lcm (natural (n + 1))
   
   [<a name="lcm_lower_bound_by_big_lcm_stirling-val"><b>lcm_lower_bound_by_big_lcm_stirling</b></a>]  Theorem
      
       Stirling  (n c. n DIV SQRT (c * (n  1)) = SQRT (n DIV c)) 
        n. ODD n  SQRT (n DIV TWICE pi) * 2 ** n  big_lcm (natural n)
   
   [<a name="lcm_lower_bound_by_list_lcm-val"><b>lcm_lower_bound_by_list_lcm</b></a>]  Theorem
      
       n. (n + 1) * binomial n (HALF n)  lcm_run (n + 1)
   
   [<a name="lcm_lower_bound_by_list_lcm_stirling-val"><b>lcm_lower_bound_by_list_lcm_stirling</b></a>]  Theorem
      
       Stirling  (n c. n DIV SQRT (c * (n  1)) = SQRT (n DIV c)) 
        n. ODD n  SQRT (n DIV TWICE pi) * 2 ** n  lcm_run n
   
   [<a name="lcm_prime_product_property-val"><b>lcm_prime_product_property</b></a>]  Theorem
      
       p m n.
          prime p  m divides n  (p * m divides n) 
          lcm (p * m) n = p * n
   
   [<a name="lcm_run_0-val"><b>lcm_run_0</b></a>]  Theorem
      
       lcm_run 0 = 1
   
   [<a name="lcm_run_1-val"><b>lcm_run_1</b></a>]  Theorem
      
       lcm_run 1 = 1
   
   [<a name="lcm_run_alt-val"><b>lcm_run_alt</b></a>]  Theorem
      
       n. lcm_run n = lcm_run (n  1 + 1)
   
   [<a name="lcm_run_beta_divisor-val"><b>lcm_run_beta_divisor</b></a>]  Theorem
      
       n k. 0 &lt; k  k  n  beta n k divides lcm_run n
   
   [<a name="lcm_run_bound_recurrence-val"><b>lcm_run_bound_recurrence</b></a>]  Theorem
      
       m n. n  TWICE m  m  n  lcm_run n  lcm_run m * binomial n m
   
   [<a name="lcm_run_by_FOLDL-val"><b>lcm_run_by_FOLDL</b></a>]  Theorem
      
       n. lcm_run n = FOLDL lcm 1 [1 .. n]
   
   [<a name="lcm_run_by_FOLDR-val"><b>lcm_run_by_FOLDR</b></a>]  Theorem
      
       n. lcm_run n = FOLDR lcm 1 [1 .. n]
   
   [<a name="lcm_run_by_beta_horizontal-val"><b>lcm_run_by_beta_horizontal</b></a>]  Theorem
      
       n. 0 &lt; n  lcm_run n = list_lcm (beta_horizontal n)
   
   [<a name="lcm_run_divides_property-val"><b>lcm_run_divides_property</b></a>]  Theorem
      
       m n.
          n  TWICE m  m  n  lcm_run n divides lcm_run m * binomial n m
   
   [<a name="lcm_run_divides_property_alt-val"><b>lcm_run_divides_property_alt</b></a>]  Theorem
      
       m n.
          n  TWICE m  m  n  lcm_run n divides binomial n m * lcm_run m
   
   [<a name="lcm_run_divisors-val"><b>lcm_run_divisors</b></a>]  Theorem
      
       n. n + 1 divides lcm_run (n + 1) 
            lcm_run n divides lcm_run (n + 1)
   
   [<a name="lcm_run_even_lower-val"><b>lcm_run_even_lower</b></a>]  Theorem
      
       n. EVEN n  HALF (n  2) * HALF (HALF (2 ** n))  lcm_run n
   
   [<a name="lcm_run_even_lower_alt-val"><b>lcm_run_even_lower_alt</b></a>]  Theorem
      
       n. EVEN n  8  n  2 ** n  lcm_run n
   
   [<a name="lcm_run_leibniz_divisor-val"><b>lcm_run_leibniz_divisor</b></a>]  Theorem
      
       n k. k  n  leibniz n k divides lcm_run (n + 1)
   
   [<a name="lcm_run_lower-val"><b>lcm_run_lower</b></a>]  Theorem
      
       n. 2 ** n  lcm_run (n + 1)
   
   [<a name="lcm_run_lower_better-val"><b>lcm_run_lower_better</b></a>]  Theorem
      
       n. 7  n  2 ** n  lcm_run n
   
   [<a name="lcm_run_lower_better_iff-val"><b>lcm_run_lower_better_iff</b></a>]  Theorem
      
       n. 2 ** n  lcm_run n  n = 0  n = 5  7  n
   
   [<a name="lcm_run_lower_even-val"><b>lcm_run_lower_even</b></a>]  Theorem
      
       n. n * 4 ** n  lcm_run (TWICE (n + 1))
   
   [<a name="lcm_run_lower_even_iff-val"><b>lcm_run_lower_even_iff</b></a>]  Theorem
      
       n. EVEN n  (2 ** n  lcm_run n  n = 0  8  n)
   
   [<a name="lcm_run_lower_good-val"><b>lcm_run_lower_good</b></a>]  Theorem
      
       n. 2 ** (n  1)  lcm_run n
   
   [<a name="lcm_run_lower_odd-val"><b>lcm_run_lower_odd</b></a>]  Theorem
      
       n. n * 4 ** n  lcm_run (TWICE n + 1)
   
   [<a name="lcm_run_lower_odd_iff-val"><b>lcm_run_lower_odd_iff</b></a>]  Theorem
      
       n. ODD n  (2 ** n  lcm_run n  5  n)
   
   [<a name="lcm_run_lower_simple-val"><b>lcm_run_lower_simple</b></a>]  Theorem
      
       n. HALF (n + 1)  lcm_run n
   
   [<a name="lcm_run_monotone-val"><b>lcm_run_monotone</b></a>]  Theorem
      
       n. lcm_run n  lcm_run (n + 1)
   
   [<a name="lcm_run_odd_factor-val"><b>lcm_run_odd_factor</b></a>]  Theorem
      
       n. 0 &lt; n  n * leibniz (TWICE n) n divides lcm_run (TWICE n + 1)
   
   [<a name="lcm_run_odd_lower-val"><b>lcm_run_odd_lower</b></a>]  Theorem
      
       n. ODD n  HALF n * HALF (2 ** n)  lcm_run n
   
   [<a name="lcm_run_odd_lower_alt-val"><b>lcm_run_odd_lower_alt</b></a>]  Theorem
      
       n. ODD n  5  n  2 ** n  lcm_run n
   
   [<a name="lcm_run_pos-val"><b>lcm_run_pos</b></a>]  Theorem
      
       n. 0 &lt; lcm_run n
   
   [<a name="lcm_run_small-val"><b>lcm_run_small</b></a>]  Theorem
      
       lcm_run 2 = 2  lcm_run 3 = 6  lcm_run 4 = 12  lcm_run 5 = 60 
        lcm_run 6 = 60  lcm_run 7 = 420  lcm_run 8 = 840 
        lcm_run 9 = 2520
   
   [<a name="lcm_run_suc-val"><b>lcm_run_suc</b></a>]  Theorem
      
       n. lcm_run (n + 1) = lcm (n + 1) (lcm_run n)
   
   [<a name="lcm_run_upper_bound-val"><b>lcm_run_upper_bound</b></a>]  Theorem
      
       n. lcm_run n  4 ** n
   
   [<a name="lcm_upto_0-val"><b>lcm_upto_0</b></a>]  Theorem
      
       lcm_upto 0 = 1
   
   [<a name="lcm_upto_1-val"><b>lcm_upto_1</b></a>]  Theorem
      
       lcm_upto 1 = 1
   
   [<a name="lcm_upto_SUC-val"><b>lcm_upto_SUC</b></a>]  Theorem
      
       n. lcm_upto (SUC n) = lcm (SUC n) (lcm_upto n)
   
   [<a name="lcm_upto_alt-val"><b>lcm_upto_alt</b></a>]  Theorem
      
       lcm_upto 0 = 1  n. lcm_upto (n + 1) = lcm (n + 1) (lcm_upto n)
   
   [<a name="lcm_upto_compute-val"><b>lcm_upto_compute</b></a>]  Theorem
      
       lcm_upto 0 = 1 
        (n. lcm_upto (NUMERAL (BIT1 n)) =
             lcm (NUMERAL (BIT1 n)) (lcm_upto (NUMERAL (BIT1 n)  1))) 
        n. lcm_upto (NUMERAL (BIT2 n)) =
            lcm (NUMERAL (BIT2 n)) (lcm_upto (NUMERAL (BIT1 n)))
   
   [<a name="lcm_upto_divisors-val"><b>lcm_upto_divisors</b></a>]  Theorem
      
       n. n + 1 divides lcm_upto (n + 1) 
            lcm_upto n divides lcm_upto (n + 1)
   
   [<a name="lcm_upto_eq_list_lcm-val"><b>lcm_upto_eq_list_lcm</b></a>]  Theorem
      
       n. lcm_upto n = lcm_run n
   
   [<a name="lcm_upto_leibniz_divisor-val"><b>lcm_upto_leibniz_divisor</b></a>]  Theorem
      
       n k. k  n  leibniz n k divides lcm_upto (n + 1)
   
   [<a name="lcm_upto_lower-val"><b>lcm_upto_lower</b></a>]  Theorem
      
       n. 2 ** n  lcm_upto (n + 1)
   
   [<a name="lcm_upto_lower_better-val"><b>lcm_upto_lower_better</b></a>]  Theorem
      
       n. 7  n  2 ** n  lcm_upto n
   
   [<a name="lcm_upto_lower_even-val"><b>lcm_upto_lower_even</b></a>]  Theorem
      
       n. n * 4 ** n  lcm_upto (TWICE (n + 1))
   
   [<a name="lcm_upto_lower_odd-val"><b>lcm_upto_lower_odd</b></a>]  Theorem
      
       n. n * 4 ** n  lcm_upto (TWICE n + 1)
   
   [<a name="lcm_upto_monotone-val"><b>lcm_upto_monotone</b></a>]  Theorem
      
       n. lcm_upto n  lcm_upto (n + 1)
   
   [<a name="lcm_upto_pos-val"><b>lcm_upto_pos</b></a>]  Theorem
      
       n. 0 &lt; lcm_upto (n + 1)
   
   [<a name="lcm_upto_small-val"><b>lcm_upto_small</b></a>]  Theorem
      
       lcm_upto 2 = 2  lcm_upto 3 = 6  lcm_upto 4 = 12 
        lcm_upto 5 = 60  lcm_upto 6 = 60  lcm_upto 7 = 420 
        lcm_upto 8 = 840  lcm_upto 9 = 2520  lcm_upto 10 = 2520
   
   [<a name="leibniz_0_n-val"><b>leibniz_0_n</b></a>]  Theorem
      
       n. leibniz 0 n = if n = 0 then 1 else 0
   
   [<a name="leibniz_alt-val"><b>leibniz_alt</b></a>]  Theorem
      
       n. leibniz n = (j. (n + 1) * j)  binomial n
   
   [<a name="leibniz_binomial_identity-val"><b>leibniz_binomial_identity</b></a>]  Theorem
      
       m n k.
          k  m  m  n 
          leibniz n k * binomial (n  k) (m  k) =
          leibniz m k * binomial (n + 1) (m + 1)
   
   [<a name="leibniz_col_arm_0-val"><b>leibniz_col_arm_0</b></a>]  Theorem
      
       a b. leibniz_col_arm a b 0 = []
   
   [<a name="leibniz_col_arm_1-val"><b>leibniz_col_arm_1</b></a>]  Theorem
      
       a b. leibniz_col_arm a b 1 = [leibniz a b]
   
   [<a name="leibniz_col_arm_cons-val"><b>leibniz_col_arm_cons</b></a>]  Theorem
      
       a b n.
          leibniz_col_arm (a + 1) b (n + 1) =
          leibniz (a + 1) b::leibniz_col_arm a b n
   
   [<a name="leibniz_col_arm_el-val"><b>leibniz_col_arm_el</b></a>]  Theorem
      
       n k.
          k &lt; n  a b. EL k (leibniz_col_arm a b n) = leibniz (a  k) b
   
   [<a name="leibniz_col_arm_len-val"><b>leibniz_col_arm_len</b></a>]  Theorem
      
       a b n. LENGTH (leibniz_col_arm a b n) = n
   
   [<a name="leibniz_col_arm_n_0-val"><b>leibniz_col_arm_n_0</b></a>]  Theorem
      
       n. leibniz_col_arm n 0 (n + 1) = leibniz_up n
   
   [<a name="leibniz_col_arm_wriggle_row_arm-val"><b>leibniz_col_arm_wriggle_row_arm</b></a>]  Theorem
      
       a b n.
          b  a  n  a + 1  b 
          leibniz_col_arm a b n wriggle leibniz_seg_arm a b n
   
   [<a name="leibniz_col_def-val"><b>leibniz_col_def</b></a>]  Theorem
      
       h. leibniz_col h = {leibniz j 0 | j  count h}
   
   [<a name="leibniz_col_eq_natural-val"><b>leibniz_col_eq_natural</b></a>]  Theorem
      
       n. leibniz_col n = natural n
   
   [<a name="leibniz_def_alt-val"><b>leibniz_def_alt</b></a>]  Theorem
      
       n k. leibniz n k = (j. (n + 1) * j) (binomial n k)
   
   [<a name="leibniz_divides_leibniz_factor-val"><b>leibniz_divides_leibniz_factor</b></a>]  Theorem
      
       m n k.
          k  m  m  n 
          leibniz n k divides leibniz m k * binomial (n + 1) (m + 1)
   
   [<a name="leibniz_eq_0-val"><b>leibniz_eq_0</b></a>]  Theorem
      
       n k. leibniz n k = 0  n &lt; k
   
   [<a name="leibniz_eqn-val"><b>leibniz_eqn</b></a>]  Theorem
      
       n k. leibniz n k = (n + 1  k) * binomial (n + 1) k
   
   [<a name="leibniz_formula-val"><b>leibniz_formula</b></a>]  Theorem
      
       n k.
          k  n 
          leibniz n k = (n + 1) * FACT n DIV (FACT k * FACT (n  k))
   
   [<a name="leibniz_horizontal_0-val"><b>leibniz_horizontal_0</b></a>]  Theorem
      
       leibniz_horizontal 0 = [1]
   
   [<a name="leibniz_horizontal_alt-val"><b>leibniz_horizontal_alt</b></a>]  Theorem
      
       n. leibniz_horizontal n =
            MAP (j. (n + 1) * j) (binomial_horizontal n)
   
   [<a name="leibniz_horizontal_average-val"><b>leibniz_horizontal_average</b></a>]  Theorem
      
       n. SUM (leibniz_horizontal n) DIV LENGTH (leibniz_horizontal n) =
            SUM (binomial_horizontal n)
   
   [<a name="leibniz_horizontal_average_eqn-val"><b>leibniz_horizontal_average_eqn</b></a>]  Theorem
      
       n. SUM (leibniz_horizontal n) DIV LENGTH (leibniz_horizontal n) =
            2 ** n
   
   [<a name="leibniz_horizontal_divisor-val"><b>leibniz_horizontal_divisor</b></a>]  Theorem
      
       n k. k  n  leibniz n k divides list_lcm (leibniz_horizontal n)
   
   [<a name="leibniz_horizontal_el-val"><b>leibniz_horizontal_el</b></a>]  Theorem
      
       n k. k  n  EL k (leibniz_horizontal n) = leibniz n k
   
   [<a name="leibniz_horizontal_element-val"><b>leibniz_horizontal_element</b></a>]  Theorem
      
       n k. k  n  EL k (leibniz_horizontal n) = leibniz n k
   
   [<a name="leibniz_horizontal_head-val"><b>leibniz_horizontal_head</b></a>]  Theorem
      
       n. TAKE 1 (leibniz_horizontal (n + 1)) = [n + 2]
   
   [<a name="leibniz_horizontal_lcm_alt-val"><b>leibniz_horizontal_lcm_alt</b></a>]  Theorem
      
       n. list_lcm (leibniz_horizontal n) =
            (n + 1) * list_lcm (binomial_horizontal n)
   
   [<a name="leibniz_horizontal_lcm_lower-val"><b>leibniz_horizontal_lcm_lower</b></a>]  Theorem
      
       n. 2 ** n  list_lcm (leibniz_horizontal n)
   
   [<a name="leibniz_horizontal_len-val"><b>leibniz_horizontal_len</b></a>]  Theorem
      
       n. LENGTH (leibniz_horizontal n) = n + 1
   
   [<a name="leibniz_horizontal_mem-val"><b>leibniz_horizontal_mem</b></a>]  Theorem
      
       n k. k  n  MEM (leibniz n k) (leibniz_horizontal n)
   
   [<a name="leibniz_horizontal_mem_iff-val"><b>leibniz_horizontal_mem_iff</b></a>]  Theorem
      
       n k. MEM (leibniz n k) (leibniz_horizontal n)  k  n
   
   [<a name="leibniz_horizontal_member-val"><b>leibniz_horizontal_member</b></a>]  Theorem
      
       n x. MEM x (leibniz_horizontal n)  k. k  n  x = leibniz n k
   
   [<a name="leibniz_horizontal_member_divides-val"><b>leibniz_horizontal_member_divides</b></a>]  Theorem
      
       m n x.
          n  TWICE m + 1  m  n  MEM x (leibniz_horizontal n) 
          x divides
          list_lcm (leibniz_horizontal m) * binomial (n + 1) (m + 1)
   
   [<a name="leibniz_horizontal_pos-val"><b>leibniz_horizontal_pos</b></a>]  Theorem
      
       n. EVERY_POSITIVE (leibniz_horizontal n)
   
   [<a name="leibniz_horizontal_pos_alt-val"><b>leibniz_horizontal_pos_alt</b></a>]  Theorem
      
       n x. MEM x (leibniz_horizontal n)  0 &lt; x
   
   [<a name="leibniz_horizontal_sum-val"><b>leibniz_horizontal_sum</b></a>]  Theorem
      
       n. SUM (leibniz_horizontal n) =
            (n + 1) * SUM (binomial_horizontal n)
   
   [<a name="leibniz_horizontal_sum_eqn-val"><b>leibniz_horizontal_sum_eqn</b></a>]  Theorem
      
       n. SUM (leibniz_horizontal n) = (n + 1) * 2 ** n
   
   [<a name="leibniz_horizontal_wriggle-val"><b>leibniz_horizontal_wriggle</b></a>]  Theorem
      
       n. [leibniz (n + 1) 0]  leibniz_horizontal n wriggle
            leibniz_horizontal (n + 1)
   
   [<a name="leibniz_horizontal_wriggle_step-val"><b>leibniz_horizontal_wriggle_step</b></a>]  Theorem
      
       n k.
          k  n + 1 
          TAKE (k + 1) (leibniz_horizontal (n + 1)) 
          DROP k (leibniz_horizontal n) wriggle leibniz_horizontal (n + 1)
   
   [<a name="leibniz_horizontal_zigzag-val"><b>leibniz_horizontal_zigzag</b></a>]  Theorem
      
       n k.
          k  n 
          TAKE (k + 1) (leibniz_horizontal (n + 1)) 
          DROP k (leibniz_horizontal n) zigzag
          TAKE (k + 2) (leibniz_horizontal (n + 1)) 
          DROP (k + 1) (leibniz_horizontal n)
   
   [<a name="leibniz_lcm_exchange-val"><b>leibniz_lcm_exchange</b></a>]  Theorem
      
       n. 0 &lt; n 
            k. lcm (leibniz n k) (leibniz (n  1) k) =
                lcm (leibniz n k) (leibniz n (k + 1))
   
   [<a name="leibniz_lcm_invariance-val"><b>leibniz_lcm_invariance</b></a>]  Theorem
      
       a b n.
          b  a  n  a + 1  b 
          list_lcm (leibniz_col_arm a b n) =
          list_lcm (leibniz_seg_arm a b n)
   
   [<a name="leibniz_lcm_property-val"><b>leibniz_lcm_property</b></a>]  Theorem
      
       n. lcm_run (n + 1) = list_lcm (leibniz_horizontal n)
   
   [<a name="leibniz_less_0-val"><b>leibniz_less_0</b></a>]  Theorem
      
       n k. n &lt; k  leibniz n k = 0
   
   [<a name="leibniz_middle_lower-val"><b>leibniz_middle_lower</b></a>]  Theorem
      
       n. 4 ** n  leibniz (TWICE n) n
   
   [<a name="leibniz_monotone-val"><b>leibniz_monotone</b></a>]  Theorem
      
       n k. k &lt; HALF n  leibniz n k &lt; leibniz n (k + 1)
   
   [<a name="leibniz_n_0-val"><b>leibniz_n_0</b></a>]  Theorem
      
       n. leibniz n 0 = n + 1
   
   [<a name="leibniz_n_k-val"><b>leibniz_n_k</b></a>]  Theorem
      
       n k.
          0 &lt; k  k  n 
          leibniz n k =
          leibniz n (k  1) * leibniz (n  1) (k  1) DIV
          (leibniz n (k  1)  leibniz (n  1) (k  1))
   
   [<a name="leibniz_n_n-val"><b>leibniz_n_n</b></a>]  Theorem
      
       n. leibniz n n = n + 1
   
   [<a name="leibniz_pos-val"><b>leibniz_pos</b></a>]  Theorem
      
       n k. k  n  0 &lt; leibniz n k
   
   [<a name="leibniz_property-val"><b>leibniz_property</b></a>]  Theorem
      
       n. 0 &lt; n 
            k. leibniz n k * leibniz (n  1) k =
                leibniz n (k + 1) * (leibniz n k  leibniz (n  1) k)
   
   [<a name="leibniz_recurrence-val"><b>leibniz_recurrence</b></a>]  Theorem
      
       n. 0 &lt; n 
            k. k &lt; n 
                leibniz n (k + 1) =
                leibniz n k * leibniz (n  1) k DIV
                (leibniz n k  leibniz (n  1) k)
   
   [<a name="leibniz_right-val"><b>leibniz_right</b></a>]  Theorem
      
       n. 0 &lt; n 
            k. leibniz n (k + 1) = (n  k) * leibniz n k DIV (k + 1)
   
   [<a name="leibniz_right_alt-val"><b>leibniz_right_alt</b></a>]  Theorem
      
       n k. leibniz n (k + 1) = (n  k) * binomial (n + 1) (k + 1)
   
   [<a name="leibniz_right_entry-val"><b>leibniz_right_entry</b></a>]  Theorem
      
       n k. (k + 1) * tc = (n + 1  k) * tb
   
   [<a name="leibniz_right_eqn-val"><b>leibniz_right_eqn</b></a>]  Theorem
      
       n. 0 &lt; n  k. (k + 1) * leibniz n (k + 1) = (n  k) * leibniz n k
   
   [<a name="leibniz_row_def-val"><b>leibniz_row_def</b></a>]  Theorem
      
       n h. leibniz_row n h = {leibniz n j | j  count h}
   
   [<a name="leibniz_seg_arm_0-val"><b>leibniz_seg_arm_0</b></a>]  Theorem
      
       a b. leibniz_seg_arm a b 0 = []
   
   [<a name="leibniz_seg_arm_1-val"><b>leibniz_seg_arm_1</b></a>]  Theorem
      
       a b. leibniz_seg_arm a b 1 = [leibniz a b]
   
   [<a name="leibniz_seg_arm_el-val"><b>leibniz_seg_arm_el</b></a>]  Theorem
      
       n k.
          k &lt; n  a b. EL k (leibniz_seg_arm a b n) = leibniz a (b + k)
   
   [<a name="leibniz_seg_arm_head-val"><b>leibniz_seg_arm_head</b></a>]  Theorem
      
       a b n. TAKE 1 (leibniz_seg_arm a b (n + 1)) = [leibniz a b]
   
   [<a name="leibniz_seg_arm_len-val"><b>leibniz_seg_arm_len</b></a>]  Theorem
      
       a b n. LENGTH (leibniz_seg_arm a b n) = n
   
   [<a name="leibniz_seg_arm_n_0-val"><b>leibniz_seg_arm_n_0</b></a>]  Theorem
      
       n. leibniz_seg_arm n 0 (n + 1) = leibniz_horizontal n
   
   [<a name="leibniz_seg_arm_wriggle_row_arm-val"><b>leibniz_seg_arm_wriggle_row_arm</b></a>]  Theorem
      
       a b n.
          [leibniz (a + 1) b]  leibniz_seg_arm a b n wriggle
          leibniz_seg_arm (a + 1) b (n + 1)
   
   [<a name="leibniz_seg_arm_wriggle_step-val"><b>leibniz_seg_arm_wriggle_step</b></a>]  Theorem
      
       n k.
          k &lt; n + 1 
          a b.
            TAKE (k + 1) (leibniz_seg_arm (a + 1) b (n + 1)) 
            DROP k (leibniz_seg_arm a b n) wriggle
            leibniz_seg_arm (a + 1) b (n + 1)
   
   [<a name="leibniz_seg_arm_zigzag_step-val"><b>leibniz_seg_arm_zigzag_step</b></a>]  Theorem
      
       n k.
          k &lt; n 
          a b.
            TAKE (k + 1) (leibniz_seg_arm (a + 1) b (n + 1)) 
            DROP k (leibniz_seg_arm a b n) zigzag
            TAKE (k + 2) (leibniz_seg_arm (a + 1) b (n + 1)) 
            DROP (k + 1) (leibniz_seg_arm a b n)
   
   [<a name="leibniz_seg_def-val"><b>leibniz_seg_def</b></a>]  Theorem
      
       n k h. leibniz_seg n k h = {leibniz n (k + j) | j  count h}
   
   [<a name="leibniz_sym-val"><b>leibniz_sym</b></a>]  Theorem
      
       n k. k  n  leibniz n k = leibniz n (n  k)
   
   [<a name="leibniz_triplet_0-val"><b>leibniz_triplet_0</b></a>]  Theorem
      
       leibniz_up 1 zigzag leibniz_horizontal 1
   
   [<a name="leibniz_triplet_lcm-val"><b>leibniz_triplet_lcm</b></a>]  Theorem
      
       n k. lcm tb ta = lcm tb tc
   
   [<a name="leibniz_triplet_member-val"><b>leibniz_triplet_member</b></a>]  Theorem
      
       n k.
          ta = leibniz n k  tb = leibniz (n + 1) k 
          tc = leibniz (n + 1) (k + 1)
   
   [<a name="leibniz_triplet_property-val"><b>leibniz_triplet_property</b></a>]  Theorem
      
       n' k. ta * tb = tc * (tb  ta)
   
   [<a name="leibniz_up-val"><b>leibniz_up</b></a>]  Theorem
      
       n. 0 &lt; n 
            k. leibniz (n  1) k = (n  k) * leibniz n k DIV (n + 1)
   
   [<a name="leibniz_up_0-val"><b>leibniz_up_0</b></a>]  Theorem
      
       leibniz_up 0 = [1]
   
   [<a name="leibniz_up_alt-val"><b>leibniz_up_alt</b></a>]  Theorem
      
       n. 0 &lt; n  k. leibniz (n  1) k = (n  k) * binomial n k
   
   [<a name="leibniz_up_cons-val"><b>leibniz_up_cons</b></a>]  Theorem
      
       n. leibniz_up (n + 1) = n + 2::leibniz_up n
   
   [<a name="leibniz_up_entry-val"><b>leibniz_up_entry</b></a>]  Theorem
      
       n k. (n + 2) * ta = (n + 1  k) * tb
   
   [<a name="leibniz_up_eqn-val"><b>leibniz_up_eqn</b></a>]  Theorem
      
       n. 0 &lt; n  k. (n + 1) * leibniz (n  1) k = (n  k) * leibniz n k
   
   [<a name="leibniz_up_lcm_eq_horizontal_lcm-val"><b>leibniz_up_lcm_eq_horizontal_lcm</b></a>]  Theorem
      
       n. list_lcm (leibniz_up n) = list_lcm (leibniz_horizontal n)
   
   [<a name="leibniz_up_len-val"><b>leibniz_up_len</b></a>]  Theorem
      
       n. LENGTH (leibniz_up n) = n + 1
   
   [<a name="leibniz_up_mem-val"><b>leibniz_up_mem</b></a>]  Theorem
      
       n x. 0 &lt; x  x  n + 1  MEM x (leibniz_up n)
   
   [<a name="leibniz_up_pos-val"><b>leibniz_up_pos</b></a>]  Theorem
      
       n. EVERY_POSITIVE (leibniz_up n)
   
   [<a name="leibniz_up_wriggle_horizontal-val"><b>leibniz_up_wriggle_horizontal</b></a>]  Theorem
      
       n. leibniz_up n wriggle leibniz_horizontal n
   
   [<a name="leibniz_up_wriggle_horizontal_alt-val"><b>leibniz_up_wriggle_horizontal_alt</b></a>]  Theorem
      
       n. leibniz_up n wriggle leibniz_horizontal n
   
   [<a name="leibniz_vertical_0-val"><b>leibniz_vertical_0</b></a>]  Theorem
      
       leibniz_vertical 0 = [1]
   
   [<a name="leibniz_vertical_alt-val"><b>leibniz_vertical_alt</b></a>]  Theorem
      
       n. leibniz_vertical n = GENLIST (i. 1 + i) (n + 1)
   
   [<a name="leibniz_vertical_divisor-val"><b>leibniz_vertical_divisor</b></a>]  Theorem
      
       n k. k  n  leibniz n k divides lcm_run (n + 1)
   
   [<a name="leibniz_vertical_lcm_lower-val"><b>leibniz_vertical_lcm_lower</b></a>]  Theorem
      
       n. 2 ** n  lcm_run (n + 1)
   
   [<a name="leibniz_vertical_len-val"><b>leibniz_vertical_len</b></a>]  Theorem
      
       n. LENGTH (leibniz_vertical n) = n + 1
   
   [<a name="leibniz_vertical_mem-val"><b>leibniz_vertical_mem</b></a>]  Theorem
      
       n x. 0 &lt; x  x  n + 1  MEM x (leibniz_vertical n)
   
   [<a name="leibniz_vertical_not_nil-val"><b>leibniz_vertical_not_nil</b></a>]  Theorem
      
       n. leibniz_vertical n  []
   
   [<a name="leibniz_vertical_pos-val"><b>leibniz_vertical_pos</b></a>]  Theorem
      
       n. EVERY_POSITIVE (leibniz_vertical n)
   
   [<a name="leibniz_vertical_pos_alt-val"><b>leibniz_vertical_pos_alt</b></a>]  Theorem
      
       n x. MEM x (leibniz_vertical n)  0 &lt; x
   
   [<a name="leibniz_vertical_snoc-val"><b>leibniz_vertical_snoc</b></a>]  Theorem
      
       n. leibniz_vertical (n + 1) = SNOC (n + 2) (leibniz_vertical n)
   
   [<a name="leibniz_wriggle_refl-val"><b>leibniz_wriggle_refl</b></a>]  Theorem
      
       p1. p1 wriggle p1
   
   [<a name="leibniz_wriggle_tail-val"><b>leibniz_wriggle_tail</b></a>]  Theorem
      
       p1 p2. p1 wriggle p2  x. [x]  p1 wriggle [x]  p2
   
   [<a name="leibniz_wriggle_trans-val"><b>leibniz_wriggle_trans</b></a>]  Theorem
      
       p1 p2 p3. p1 wriggle p2  p2 wriggle p3  p1 wriggle p3
   
   [<a name="leibniz_zigzag_tail-val"><b>leibniz_zigzag_tail</b></a>]  Theorem
      
       p1 p2. p1 zigzag p2  x. [x]  p1 zigzag [x]  p2
   
   [<a name="leibniz_zigzag_wriggle-val"><b>leibniz_zigzag_wriggle</b></a>]  Theorem
      
       p1 p2. p1 zigzag p2  p1 wriggle p2
   
   [<a name="listRangeINC_MONO_INC-val"><b>listRangeINC_MONO_INC</b></a>]  Theorem
      
       m n m' n'.
          m'  n'  n' &lt; LENGTH [m .. n]  EL m' [m .. n]  EL n' [m .. n]
   
   [<a name="listRangeINC_PROD-val"><b>listRangeINC_PROD</b></a>]  Theorem
      
       m n.
          0 &lt; m  m  n 
          PROD [m .. n] = PROD [1 .. n] DIV PROD [1 .. m  1]
   
   [<a name="listRangeINC_PROD_pos-val"><b>listRangeINC_PROD_pos</b></a>]  Theorem
      
       m n. 0 &lt; m  0 &lt; PROD [m .. n]
   
   [<a name="listRangeLHI_MONO_INC-val"><b>listRangeLHI_MONO_INC</b></a>]  Theorem
      
       m n m' n'.
          m'  n'  n' &lt; LENGTH [m ..&lt; n] 
          EL m' [m ..&lt; n]  EL n' [m ..&lt; n]
   
   [<a name="listRangeLHI_PROD-val"><b>listRangeLHI_PROD</b></a>]  Theorem
      
       m n.
          0 &lt; m  m  n 
          PROD [m ..&lt; n] = PROD [1 ..&lt; n] DIV PROD [1 ..&lt; m]
   
   [<a name="listRangeLHI_PROD_pos-val"><b>listRangeLHI_PROD_pos</b></a>]  Theorem
      
       m n. 0 &lt; m  0 &lt; PROD [m ..&lt; n]
   
   [<a name="list_count_0_n-val"><b>list_count_0_n</b></a>]  Theorem
      
       n. 0 &lt; n  list_count 0 n = 
   
   [<a name="list_count_alt-val"><b>list_count_alt</b></a>]  Theorem
      
       n k.
          list_count n k =
          {ls | ALL_DISTINCT ls  set ls  count n  CARD (set ls) = k}
   
   [<a name="list_count_by_image-val"><b>list_count_by_image</b></a>]  Theorem
      
       n k.
          0 &lt; k 
          list_count n k =
          IMAGE (ls. if ALL_DISTINCT ls then ls else []) (necklace k n) DELETE
          []
   
   [<a name="list_count_element-val"><b>list_count_element</b></a>]  Theorem
      
       ls n k.
          ls  list_count n k 
          ALL_DISTINCT ls  set ls  count n  LENGTH ls = k
   
   [<a name="list_count_element_alt-val"><b>list_count_element_alt</b></a>]  Theorem
      
       ls n k.
          ls  list_count n k 
          ALL_DISTINCT ls  set ls  count n  CARD (set ls) = k
   
   [<a name="list_count_element_perm_set_not_empty-val"><b>list_count_element_perm_set_not_empty</b></a>]  Theorem
      
       ls n k. ls  list_count n k  perm_set (set ls)  
   
   [<a name="list_count_element_set_card-val"><b>list_count_element_set_card</b></a>]  Theorem
      
       ls n k. ls  list_count n k  CARD (set ls) = k
   
   [<a name="list_count_eq_empty-val"><b>list_count_eq_empty</b></a>]  Theorem
      
       n k. list_count n k =   n &lt; k
   
   [<a name="list_count_eqn-val"><b>list_count_eqn</b></a>]  Theorem
      
       n k.
          list_count n k =
          if k = 0 then {[]}
          else
            IMAGE (ls. if ALL_DISTINCT ls then ls else []) (necklace k n) DELETE
            []
   
   [<a name="list_count_finite-val"><b>list_count_finite</b></a>]  Theorem
      
       n k. FINITE (list_count n k)
   
   [<a name="list_count_n_0-val"><b>list_count_n_0</b></a>]  Theorem
      
       n. list_count n 0 = {[]}
   
   [<a name="list_count_n_n-val"><b>list_count_n_n</b></a>]  Theorem
      
       n. list_count n n = perm_count n
   
   [<a name="list_count_set_eq_class-val"><b>list_count_set_eq_class</b></a>]  Theorem
      
       ls n k.
          ls  list_count n k 
          equiv_class (feq set) (list_count n k) ls = perm_set (set ls)
   
   [<a name="list_count_set_eq_class_card-val"><b>list_count_set_eq_class_card</b></a>]  Theorem
      
       ls n k.
          ls  list_count n k 
          CARD (equiv_class (feq set) (list_count n k) ls) = perm k
   
   [<a name="list_count_set_map_bij-val"><b>list_count_set_map_bij</b></a>]  Theorem
      
       n k.
          BIJ (set  CHOICE) (partition (feq set) (list_count n k))
            (sub_count n k)
   
   [<a name="list_count_set_map_element-val"><b>list_count_set_map_element</b></a>]  Theorem
      
       s n k.
          s  partition (feq set) (list_count n k) 
          (set  CHOICE) s  sub_count n k
   
   [<a name="list_count_set_map_inj-val"><b>list_count_set_map_inj</b></a>]  Theorem
      
       n k.
          INJ (set  CHOICE) (partition (feq set) (list_count n k))
            (sub_count n k)
   
   [<a name="list_count_set_map_surj-val"><b>list_count_set_map_surj</b></a>]  Theorem
      
       n k.
          SURJ (set  CHOICE) (partition (feq set) (list_count n k))
            (sub_count n k)
   
   [<a name="list_count_set_partititon_element_card-val"><b>list_count_set_partititon_element_card</b></a>]  Theorem
      
       n k e. e  partition (feq set) (list_count n k)  CARD e = perm k
   
   [<a name="list_count_subset-val"><b>list_count_subset</b></a>]  Theorem
      
       n k. list_count n k  necklace k n
   
   [<a name="list_lcm_absorption-val"><b>list_lcm_absorption</b></a>]  Theorem
      
       x l. MEM x l  list_lcm (x::l) = list_lcm l
   
   [<a name="list_lcm_append-val"><b>list_lcm_append</b></a>]  Theorem
      
       l1 l2. list_lcm (l1  l2) = lcm (list_lcm l1) (list_lcm l2)
   
   [<a name="list_lcm_append_3-val"><b>list_lcm_append_3</b></a>]  Theorem
      
       l1 l2 l3.
          list_lcm (l1  l2  l3) =
          list_lcm [list_lcm l1; list_lcm l2; list_lcm l3]
   
   [<a name="list_lcm_by_FOLDL-val"><b>list_lcm_by_FOLDL</b></a>]  Theorem
      
       ls. list_lcm ls = FOLDL lcm 1 ls
   
   [<a name="list_lcm_by_FOLDR-val"><b>list_lcm_by_FOLDR</b></a>]  Theorem
      
       ls. list_lcm ls = FOLDR lcm 1 ls
   
   [<a name="list_lcm_cons-val"><b>list_lcm_cons</b></a>]  Theorem
      
       h t. list_lcm (h::t) = lcm h (list_lcm t)
   
   [<a name="list_lcm_divisor_lcm_pair-val"><b>list_lcm_divisor_lcm_pair</b></a>]  Theorem
      
       l x y. MEM x l  MEM y l  lcm x y divides list_lcm l
   
   [<a name="list_lcm_eq_if_set_eq-val"><b>list_lcm_eq_if_set_eq</b></a>]  Theorem
      
       l1 l2. set l1 = set l2  list_lcm l1 = list_lcm l2
   
   [<a name="list_lcm_ge_max-val"><b>list_lcm_ge_max</b></a>]  Theorem
      
       l. POSITIVE l  MAX_LIST l  list_lcm l
   
   [<a name="list_lcm_is_common_multiple-val"><b>list_lcm_is_common_multiple</b></a>]  Theorem
      
       x l. MEM x l  x divides list_lcm l
   
   [<a name="list_lcm_is_least_common_multiple-val"><b>list_lcm_is_least_common_multiple</b></a>]  Theorem
      
       l m. (x. MEM x l  x divides m)  list_lcm l divides m
   
   [<a name="list_lcm_lower_bound-val"><b>list_lcm_lower_bound</b></a>]  Theorem
      
       l. EVERY_POSITIVE l  SUM l  LENGTH l * list_lcm l
   
   [<a name="list_lcm_lower_bound_alt-val"><b>list_lcm_lower_bound_alt</b></a>]  Theorem
      
       l. POSITIVE l  SUM l  LENGTH l * list_lcm l
   
   [<a name="list_lcm_lower_by_lcm_pair-val"><b>list_lcm_lower_by_lcm_pair</b></a>]  Theorem
      
       l x y. POSITIVE l  MEM x l  MEM y l  lcm x y  list_lcm l
   
   [<a name="list_lcm_map_times-val"><b>list_lcm_map_times</b></a>]  Theorem
      
       n l.
          list_lcm (MAP (k. n * k) l) =
          if l = [] then 1 else n * list_lcm l
   
   [<a name="list_lcm_nil-val"><b>list_lcm_nil</b></a>]  Theorem
      
       list_lcm [] = 1
   
   [<a name="list_lcm_nonempty_lower-val"><b>list_lcm_nonempty_lower</b></a>]  Theorem
      
       l. l  []  EVERY_POSITIVE l  SUM l DIV LENGTH l  list_lcm l
   
   [<a name="list_lcm_nonempty_lower_alt-val"><b>list_lcm_nonempty_lower_alt</b></a>]  Theorem
      
       l. l  []  POSITIVE l  SUM l DIV LENGTH l  list_lcm l
   
   [<a name="list_lcm_nub-val"><b>list_lcm_nub</b></a>]  Theorem
      
       l. list_lcm (nub l) = list_lcm l
   
   [<a name="list_lcm_nub_eq_if_set_eq-val"><b>list_lcm_nub_eq_if_set_eq</b></a>]  Theorem
      
       l1 l2. set l1 = set l2  list_lcm (nub l1) = list_lcm (nub l2)
   
   [<a name="list_lcm_pos-val"><b>list_lcm_pos</b></a>]  Theorem
      
       l. EVERY_POSITIVE l  0 &lt; list_lcm l
   
   [<a name="list_lcm_pos_alt-val"><b>list_lcm_pos_alt</b></a>]  Theorem
      
       l. POSITIVE l  0 &lt; list_lcm l
   
   [<a name="list_lcm_prime_factor-val"><b>list_lcm_prime_factor</b></a>]  Theorem
      
       p l. prime p  p divides list_lcm l  p divides PROD_SET (set l)
   
   [<a name="list_lcm_prime_factor_member-val"><b>list_lcm_prime_factor_member</b></a>]  Theorem
      
       p l. prime p  p divides list_lcm l  x. MEM x l  p divides x
   
   [<a name="list_lcm_reverse-val"><b>list_lcm_reverse</b></a>]  Theorem
      
       l. list_lcm (REVERSE l) = list_lcm l
   
   [<a name="list_lcm_sing-val"><b>list_lcm_sing</b></a>]  Theorem
      
       x. list_lcm [x] = x
   
   [<a name="list_lcm_snoc-val"><b>list_lcm_snoc</b></a>]  Theorem
      
       x l. list_lcm (SNOC x l) = lcm x (list_lcm l)
   
   [<a name="list_lcm_suc-val"><b>list_lcm_suc</b></a>]  Theorem
      
       n. lcm_run (n + 1) = lcm (n + 1) (lcm_run n)
   
   [<a name="list_lcm_upper_by_common_multiple-val"><b>list_lcm_upper_by_common_multiple</b></a>]  Theorem
      
       l m. 0 &lt; m  (x. MEM x l  x divides m)  list_lcm l  m
   
   [<a name="list_lcm_wriggle-val"><b>list_lcm_wriggle</b></a>]  Theorem
      
       p1 p2. p1 wriggle p2  list_lcm p1 = list_lcm p2
   
   [<a name="list_lcm_zigzag-val"><b>list_lcm_zigzag</b></a>]  Theorem
      
       p1 p2. p1 zigzag p2  list_lcm p1 = list_lcm p2
   
   [<a name="list_length_eq_sum-val"><b>list_length_eq_sum</b></a>]  Theorem
      
       ls. EVERY_POSITIVE ls  LENGTH ls = SUM ls  EVERY (x. x = 1) ls
   
   [<a name="list_length_le_sum-val"><b>list_length_le_sum</b></a>]  Theorem
      
       ls. EVERY_POSITIVE ls  LENGTH ls  SUM ls
   
   [<a name="list_product_prime_factor-val"><b>list_product_prime_factor</b></a>]  Theorem
      
       p l.
          prime p  p divides PROD_SET (set l)  x. MEM x l  p divides x
   
   [<a name="monocoloured_0-val"><b>monocoloured_0</b></a>]  Theorem
      
       a. monocoloured 0 a = {[]}
   
   [<a name="monocoloured_0_card-val"><b>monocoloured_0_card</b></a>]  Theorem
      
       a. CARD (monocoloured 0 a) = 1
   
   [<a name="monocoloured_1-val"><b>monocoloured_1</b></a>]  Theorem
      
       a. monocoloured 1 a = necklace 1 a
   
   [<a name="monocoloured_card-val"><b>monocoloured_card</b></a>]  Theorem
      
       n a. 0 &lt; n  CARD (monocoloured n a) = a
   
   [<a name="monocoloured_card_eqn-val"><b>monocoloured_card_eqn</b></a>]  Theorem
      
       n a. CARD (monocoloured n a) = if n = 0 then 1 else a
   
   [<a name="monocoloured_element-val"><b>monocoloured_element</b></a>]  Theorem
      
       n a ls.
          ls  monocoloured n a 
          ls  necklace n a  (ls  []  SING (set ls))
   
   [<a name="monocoloured_empty-val"><b>monocoloured_empty</b></a>]  Theorem
      
       n. 0 &lt; n  monocoloured n 0 = 
   
   [<a name="monocoloured_eqn-val"><b>monocoloured_eqn</b></a>]  Theorem
      
       n a.
          monocoloured n a =
          if n = 0 then {[]} else IMAGE (c. GENLIST (K c) n) (count a)
   
   [<a name="monocoloured_finite-val"><b>monocoloured_finite</b></a>]  Theorem
      
       n a. FINITE (monocoloured n a)
   
   [<a name="monocoloured_mono-val"><b>monocoloured_mono</b></a>]  Theorem
      
       n. monocoloured n 1 = necklace n 1
   
   [<a name="monocoloured_necklace-val"><b>monocoloured_necklace</b></a>]  Theorem
      
       n a ls. ls  monocoloured n a  ls  necklace n a
   
   [<a name="monocoloured_subset-val"><b>monocoloured_subset</b></a>]  Theorem
      
       n a. monocoloured n a  necklace n a
   
   [<a name="monocoloured_suc-val"><b>monocoloured_suc</b></a>]  Theorem
      
       n a.
          0 &lt; n 
          monocoloured (SUC n) a =
          IMAGE (ls. HD ls::ls) (monocoloured n a)
   
   [<a name="multi_mono_disjoint-val"><b>multi_mono_disjoint</b></a>]  Theorem
      
       n a. DISJOINT (multicoloured n a) (monocoloured n a)
   
   [<a name="multi_mono_exhaust-val"><b>multi_mono_exhaust</b></a>]  Theorem
      
       n a. necklace n a = multicoloured n a  monocoloured n a
   
   [<a name="multicoloured_0-val"><b>multicoloured_0</b></a>]  Theorem
      
       a. multicoloured 0 a = 
   
   [<a name="multicoloured_1-val"><b>multicoloured_1</b></a>]  Theorem
      
       a. multicoloured 1 a = 
   
   [<a name="multicoloured_card-val"><b>multicoloured_card</b></a>]  Theorem
      
       n a. 0 &lt; n  CARD (multicoloured n a) = a ** n  a
   
   [<a name="multicoloured_card_eqn-val"><b>multicoloured_card_eqn</b></a>]  Theorem
      
       n a. CARD (multicoloured n a) = if n = 0 then 0 else a ** n  a
   
   [<a name="multicoloured_element-val"><b>multicoloured_element</b></a>]  Theorem
      
       n a ls.
          ls  multicoloured n a 
          ls  necklace n a  ls  []  SING (set ls)
   
   [<a name="multicoloured_empty-val"><b>multicoloured_empty</b></a>]  Theorem
      
       n. multicoloured n 0 =   multicoloured n 1 = 
   
   [<a name="multicoloured_finite-val"><b>multicoloured_finite</b></a>]  Theorem
      
       n a. FINITE (multicoloured n a)
   
   [<a name="multicoloured_n_0-val"><b>multicoloured_n_0</b></a>]  Theorem
      
       n. multicoloured n 0 = 
   
   [<a name="multicoloured_n_1-val"><b>multicoloured_n_1</b></a>]  Theorem
      
       n. multicoloured n 1 = 
   
   [<a name="multicoloured_necklace-val"><b>multicoloured_necklace</b></a>]  Theorem
      
       n a ls. ls  multicoloured n a  ls  necklace n a
   
   [<a name="multicoloured_nonempty-val"><b>multicoloured_nonempty</b></a>]  Theorem
      
       n a. 1 &lt; n  1 &lt; a  multicoloured n a  
   
   [<a name="multicoloured_not_monocoloured-val"><b>multicoloured_not_monocoloured</b></a>]  Theorem
      
       n a ls. ls  multicoloured n a  ls  monocoloured n a
   
   [<a name="multicoloured_not_monocoloured_iff-val"><b>multicoloured_not_monocoloured_iff</b></a>]  Theorem
      
       n a ls.
          ls  necklace n a 
          (ls  multicoloured n a  ls  monocoloured n a)
   
   [<a name="multicoloured_or_monocoloured-val"><b>multicoloured_or_monocoloured</b></a>]  Theorem
      
       n a ls.
          ls  necklace n a 
          ls  multicoloured n a  ls  monocoloured n a
   
   [<a name="multicoloured_subset-val"><b>multicoloured_subset</b></a>]  Theorem
      
       n a. multicoloured n a  necklace n a
   
   [<a name="necklace_0-val"><b>necklace_0</b></a>]  Theorem
      
       a. necklace 0 a = {[]}
   
   [<a name="necklace_1-val"><b>necklace_1</b></a>]  Theorem
      
       a. necklace 1 a = {[e] | e  count a}
   
   [<a name="necklace_1_monocoloured-val"><b>necklace_1_monocoloured</b></a>]  Theorem
      
       a. necklace 1 a = monocoloured 1 a
   
   [<a name="necklace_card-val"><b>necklace_card</b></a>]  Theorem
      
       n a. CARD (necklace n a) = a ** n
   
   [<a name="necklace_colors-val"><b>necklace_colors</b></a>]  Theorem
      
       n a ls. ls  necklace n a  set ls  count a
   
   [<a name="necklace_element-val"><b>necklace_element</b></a>]  Theorem
      
       n a ls. ls  necklace n a  LENGTH ls = n  set ls  count a
   
   [<a name="necklace_empty-val"><b>necklace_empty</b></a>]  Theorem
      
       n. 0 &lt; n  necklace n 0 = 
   
   [<a name="necklace_eqn-val"><b>necklace_eqn</b></a>]  Theorem
      
       n a.
          necklace n a =
          if n = 0 then {[]}
          else IMAGE ((c,ls). c::ls) (count a  necklace (n  1) a)
   
   [<a name="necklace_finite-val"><b>necklace_finite</b></a>]  Theorem
      
       n a. FINITE (necklace n a)
   
   [<a name="necklace_length-val"><b>necklace_length</b></a>]  Theorem
      
       n a ls. ls  necklace n a  LENGTH ls = n
   
   [<a name="necklace_not_nil-val"><b>necklace_not_nil</b></a>]  Theorem
      
       n a ls. 0 &lt; n  ls  necklace n a  ls  []
   
   [<a name="necklace_property-val"><b>necklace_property</b></a>]  Theorem
      
       n a ls. ls  necklace n a  LENGTH ls = n  set ls  count a
   
   [<a name="necklace_suc-val"><b>necklace_suc</b></a>]  Theorem
      
       n a.
          necklace (SUC n) a =
          IMAGE ((c,ls). c::ls) (count a  necklace n a)
   
   [<a name="nub_all_distinct-val"><b>nub_all_distinct</b></a>]  Theorem
      
       l. ALL_DISTINCT (nub l)
   
   [<a name="nub_cons-val"><b>nub_cons</b></a>]  Theorem
      
       x l. nub (x::l) = if MEM x l then nub l else x::nub l
   
   [<a name="nub_nil-val"><b>nub_nil</b></a>]  Theorem
      
       nub [] = []
   
   [<a name="nub_sing-val"><b>nub_sing</b></a>]  Theorem
      
       x. nub [x] = [x]
   
   [<a name="over_bij-val"><b>over_bij</b></a>]  Theorem
      
       f s t. BIJ f s t  over f s t
   
   [<a name="over_inj-val"><b>over_inj</b></a>]  Theorem
      
       f s t. INJ f s t  over f s t
   
   [<a name="over_surj-val"><b>over_surj</b></a>]  Theorem
      
       f s t. SURJ f s t  over f s t
   
   [<a name="pairwise_coprime_prod_set_divides-val"><b>pairwise_coprime_prod_set_divides</b></a>]  Theorem
      
       s m.
          FINITE s  PAIRWISE_COPRIME s  (x. x  s  x divides m) 
          PROD_SET s divides m
   
   [<a name="pairwise_coprime_prod_set_eq_set_lcm-val"><b>pairwise_coprime_prod_set_eq_set_lcm</b></a>]  Theorem
      
       s. FINITE s  PAIRWISE_COPRIME s  set_lcm s = PROD_SET s
   
   [<a name="perm_0-val"><b>perm_0</b></a>]  Theorem
      
       perm 0 = 1
   
   [<a name="perm_1-val"><b>perm_1</b></a>]  Theorem
      
       perm 1 = 1
   
   [<a name="perm_alt-val"><b>perm_alt</b></a>]  Theorem
      
       perm 0 = 1  n. perm (n + 1) = (n + 1) * perm n
   
   [<a name="perm_count_0-val"><b>perm_count_0</b></a>]  Theorem
      
       perm_count 0 = {[]}
   
   [<a name="perm_count_1-val"><b>perm_count_1</b></a>]  Theorem
      
       perm_count 1 = {[0]}
   
   [<a name="perm_count_element-val"><b>perm_count_element</b></a>]  Theorem
      
       ls n. ls  perm_count n  ALL_DISTINCT ls  set ls = count n
   
   [<a name="perm_count_element_length-val"><b>perm_count_element_length</b></a>]  Theorem
      
       ls n. ls  perm_count n  LENGTH ls = n
   
   [<a name="perm_count_element_no_self-val"><b>perm_count_element_no_self</b></a>]  Theorem
      
       ls n. ls  perm_count n  MEM n ls
   
   [<a name="perm_count_eqn-val"><b>perm_count_eqn</b></a>]  Theorem
      
       n. perm_count n =
            if n = 0 then {[]}
            else
              BIGUNION (IMAGE ($interleave (n  1)) (perm_count (n  1)))
   
   [<a name="perm_count_finite-val"><b>perm_count_finite</b></a>]  Theorem
      
       n. FINITE (perm_count n)
   
   [<a name="perm_count_interleave_card-val"><b>perm_count_interleave_card</b></a>]  Theorem
      
       n e. e  IMAGE ($interleave n) (perm_count n)  CARD e = n + 1
   
   [<a name="perm_count_interleave_disjoint-val"><b>perm_count_interleave_disjoint</b></a>]  Theorem
      
       n e s t.
          s  IMAGE ($interleave n) (perm_count n) 
          t  IMAGE ($interleave n) (perm_count n)  s  t 
          DISJOINT s t
   
   [<a name="perm_count_interleave_finite-val"><b>perm_count_interleave_finite</b></a>]  Theorem
      
       n e. e  IMAGE ($interleave n) (perm_count n)  FINITE e
   
   [<a name="perm_count_interleave_inj-val"><b>perm_count_interleave_inj</b></a>]  Theorem
      
       n. INJ ($interleave n) (perm_count n) (:num list -&gt; bool)
   
   [<a name="perm_count_subset-val"><b>perm_count_subset</b></a>]  Theorem
      
       n. perm_count n  necklace n n
   
   [<a name="perm_count_suc-val"><b>perm_count_suc</b></a>]  Theorem
      
       n. perm_count (SUC n) =
            BIGUNION (IMAGE ($interleave n) (perm_count n))
   
   [<a name="perm_count_suc_alt-val"><b>perm_count_suc_alt</b></a>]  Theorem
      
       n. perm_count (n + 1) =
            BIGUNION (IMAGE ($interleave n) (perm_count n))
   
   [<a name="perm_eq_fact-val"><b>perm_eq_fact</b></a>]  Theorem
      
       n. perm n = FACT n
   
   [<a name="perm_set_bij_eq_perm_count-val"><b>perm_set_bij_eq_perm_count</b></a>]  Theorem
      
       s. FINITE s  perm_set s =b= perm_count (CARD s)
   
   [<a name="perm_set_card-val"><b>perm_set_card</b></a>]  Theorem
      
       s. FINITE s  CARD (perm_set s) = perm (CARD s)
   
   [<a name="perm_set_card_alt-val"><b>perm_set_card_alt</b></a>]  Theorem
      
       s. FINITE s  CARD (perm_set s) = FACT (CARD s)
   
   [<a name="perm_set_element-val"><b>perm_set_element</b></a>]  Theorem
      
       ls s. ls  perm_set s  ALL_DISTINCT ls  set ls = s
   
   [<a name="perm_set_empty-val"><b>perm_set_empty</b></a>]  Theorem
      
       perm_set  = {[]}
   
   [<a name="perm_set_eq_empty_sing-val"><b>perm_set_eq_empty_sing</b></a>]  Theorem
      
       s. perm_set s = {[]}  s = 
   
   [<a name="perm_set_finite-val"><b>perm_set_finite</b></a>]  Theorem
      
       s. FINITE s  FINITE (perm_set s)
   
   [<a name="perm_set_has_self_list-val"><b>perm_set_has_self_list</b></a>]  Theorem
      
       s. FINITE s  SET_TO_LIST s  perm_set s
   
   [<a name="perm_set_list_not_empty-val"><b>perm_set_list_not_empty</b></a>]  Theorem
      
       ls. perm_set (set ls)  
   
   [<a name="perm_set_map_bij-val"><b>perm_set_map_bij</b></a>]  Theorem
      
       f s n. BIJ f s (count n)  BIJ (MAP f) (perm_set s) (perm_count n)
   
   [<a name="perm_set_map_element-val"><b>perm_set_map_element</b></a>]  Theorem
      
       ls f s n.
          ls  perm_set s  BIJ f s (count n)  MAP f ls  perm_count n
   
   [<a name="perm_set_map_inj-val"><b>perm_set_map_inj</b></a>]  Theorem
      
       f s n. BIJ f s (count n)  INJ (MAP f) (perm_set s) (perm_count n)
   
   [<a name="perm_set_map_surj-val"><b>perm_set_map_surj</b></a>]  Theorem
      
       f s n.
          BIJ f s (count n)  SURJ (MAP f) (perm_set s) (perm_count n)
   
   [<a name="perm_set_not_empty-val"><b>perm_set_not_empty</b></a>]  Theorem
      
       s. FINITE s  perm_set s  
   
   [<a name="perm_set_perm_count-val"><b>perm_set_perm_count</b></a>]  Theorem
      
       n. perm_set (count n) = perm_count n
   
   [<a name="perm_set_sing-val"><b>perm_set_sing</b></a>]  Theorem
      
       x. perm_set {x} = {[x]}
   
   [<a name="perm_suc-val"><b>perm_suc</b></a>]  Theorem
      
       n. perm (SUC n) = SUC n * perm n
   
   [<a name="perm_suc_alt-val"><b>perm_suc_alt</b></a>]  Theorem
      
       n. perm (n + 1) = (n + 1) * perm n
   
   [<a name="power_predecessor_eqn-val"><b>power_predecessor_eqn</b></a>]  Theorem
      
       t n. tops t n = (t  1) * SUM (MAP (j. t ** j) [0 ..&lt; n])
   
   [<a name="prime_divides_binomials-val"><b>prime_divides_binomials</b></a>]  Theorem
      
       n. prime n  1 &lt; n  k. 0 &lt; k  k &lt; n  n divides binomial n k
   
   [<a name="prime_divides_binomials_alt-val"><b>prime_divides_binomials_alt</b></a>]  Theorem
      
       n k. prime n  0 &lt; k  k &lt; n  n divides binomial n k
   
   [<a name="prime_divisor_property-val"><b>prime_divisor_property</b></a>]  Theorem
      
       n p.
          1 &lt; n  p &lt; n  prime p  p divides n 
          (p divides FACT (n  1) DIV FACT (n  p))
   
   [<a name="prime_iff_divides_binomials-val"><b>prime_iff_divides_binomials</b></a>]  Theorem
      
       n. prime n  1 &lt; n  k. 0 &lt; k  k &lt; n  n divides binomial n k
   
   [<a name="prime_iff_divides_binomials_alt-val"><b>prime_iff_divides_binomials_alt</b></a>]  Theorem
      
       n. prime n  1 &lt; n  k. 0 &lt; k  k &lt; n  binomial n k MOD n = 0
   
   [<a name="prod_1_to_n_eq_fact_n-val"><b>prod_1_to_n_eq_fact_n</b></a>]  Theorem
      
       n. PROD [1 .. n] = FACT n
   
   [<a name="rotate_0-val"><b>rotate_0</b></a>]  Theorem
      
       l. rotate 0 l = l
   
   [<a name="rotate_add-val"><b>rotate_add</b></a>]  Theorem
      
       n m l. n + m  LENGTH l  rotate n (rotate m l) = rotate (n + m) l
   
   [<a name="rotate_full-val"><b>rotate_full</b></a>]  Theorem
      
       l. rotate (LENGTH l) l = l
   
   [<a name="rotate_lcancel-val"><b>rotate_lcancel</b></a>]  Theorem
      
       k l. k &lt; LENGTH l  rotate (LENGTH l  k) (rotate k l) = l
   
   [<a name="rotate_nil-val"><b>rotate_nil</b></a>]  Theorem
      
       n. rotate n [] = []
   
   [<a name="rotate_rcancel-val"><b>rotate_rcancel</b></a>]  Theorem
      
       k l. k &lt; LENGTH l  rotate k (rotate (LENGTH l  k) l) = l
   
   [<a name="rotate_same_length-val"><b>rotate_same_length</b></a>]  Theorem
      
       l n. LENGTH (rotate n l) = LENGTH l
   
   [<a name="rotate_same_set-val"><b>rotate_same_set</b></a>]  Theorem
      
       l n. set (rotate n l) = set l
   
   [<a name="rotate_shift_element-val"><b>rotate_shift_element</b></a>]  Theorem
      
       l n.
          n &lt; LENGTH l  rotate n l = EL n l::(DROP (SUC n) l  TAKE n l)
   
   [<a name="rotate_suc-val"><b>rotate_suc</b></a>]  Theorem
      
       l n. n &lt; LENGTH l  rotate (SUC n) l = rotate 1 (rotate n l)
   
   [<a name="set_lcm_empty-val"><b>set_lcm_empty</b></a>]  Theorem
      
       set_lcm  = 1
   
   [<a name="set_lcm_eq_big_lcm-val"><b>set_lcm_eq_big_lcm</b></a>]  Theorem
      
       s. FINITE s  big_lcm s = set_lcm s
   
   [<a name="set_lcm_eq_list_lcm-val"><b>set_lcm_eq_list_lcm</b></a>]  Theorem
      
       l. set_lcm (set l) = list_lcm l
   
   [<a name="set_lcm_insert-val"><b>set_lcm_insert</b></a>]  Theorem
      
       s. FINITE s  x. set_lcm (x INSERT s) = lcm x (set_lcm s)
   
   [<a name="set_lcm_is_common_multiple-val"><b>set_lcm_is_common_multiple</b></a>]  Theorem
      
       x s. FINITE s  x  s  x divides set_lcm s
   
   [<a name="set_lcm_is_least_common_multiple-val"><b>set_lcm_is_least_common_multiple</b></a>]  Theorem
      
       s m. FINITE s  (x. x  s  x divides m)  set_lcm s divides m
   
   [<a name="set_lcm_nonempty-val"><b>set_lcm_nonempty</b></a>]  Theorem
      
       s. FINITE s  s   
            set_lcm s = lcm (CHOICE s) (set_lcm (REST s))
   
   [<a name="set_lcm_sing-val"><b>set_lcm_sing</b></a>]  Theorem
      
       x. set_lcm {x} = x
   
   [<a name="sub_count_0_n-val"><b>sub_count_0_n</b></a>]  Theorem
      
       n. sub_count 0 n = if n = 0 then {} else 
   
   [<a name="sub_count_alt-val"><b>sub_count_alt</b></a>]  Theorem
      
       n k.
          sub_count n 0 = {}  sub_count 0 (k + 1) =  
          sub_count (n + 1) (k + 1) =
          IMAGE (s. n INSERT s) (sub_count n k)  sub_count n (k + 1)
   
   [<a name="sub_count_count_inj-val"><b>sub_count_count_inj</b></a>]  Theorem
      
       n m. INJ (sub_count n) (upto n) (:(num -&gt; bool) -&gt; bool)
   
   [<a name="sub_count_disjoint-val"><b>sub_count_disjoint</b></a>]  Theorem
      
       n k.
          DISJOINT (IMAGE (s. n INSERT s) (sub_count n k))
            (sub_count n (k + 1))
   
   [<a name="sub_count_element-val"><b>sub_count_element</b></a>]  Theorem
      
       n k s. s  sub_count n k  s  count n  CARD s = k
   
   [<a name="sub_count_element_finite-val"><b>sub_count_element_finite</b></a>]  Theorem
      
       n k s. s  sub_count n k  FINITE s
   
   [<a name="sub_count_element_no_self-val"><b>sub_count_element_no_self</b></a>]  Theorem
      
       n k s. s  sub_count n k  n  s
   
   [<a name="sub_count_eq_empty-val"><b>sub_count_eq_empty</b></a>]  Theorem
      
       n k. sub_count n k =   n &lt; k
   
   [<a name="sub_count_eqn-val"><b>sub_count_eqn</b></a>]  Theorem
      
       n k.
          sub_count n k =
          if k = 0 then {}
          else if n = 0 then 
          else
            IMAGE (s. n  1 INSERT s) (sub_count (n  1) (k  1)) 
            sub_count (n  1) k
   
   [<a name="sub_count_equiv_class-val"><b>sub_count_equiv_class</b></a>]  Theorem
      
       n s.
          s  count n 
          sub_count n (CARD s) =
          equiv_class (s t. s =b= t) (POW (count n)) s
   
   [<a name="sub_count_finite-val"><b>sub_count_finite</b></a>]  Theorem
      
       n k. FINITE (sub_count n k)
   
   [<a name="sub_count_insert-val"><b>sub_count_insert</b></a>]  Theorem
      
       n k s. s  sub_count n k  n INSERT s  sub_count (n + 1) (k + 1)
   
   [<a name="sub_count_insert_card-val"><b>sub_count_insert_card</b></a>]  Theorem
      
       n k. CARD (IMAGE (s. n INSERT s) (sub_count n k)) = n choose k
   
   [<a name="sub_count_n_0-val"><b>sub_count_n_0</b></a>]  Theorem
      
       n. sub_count n 0 = {}
   
   [<a name="sub_count_n_1-val"><b>sub_count_n_1</b></a>]  Theorem
      
       n. sub_count n 1 = {{j} | j &lt; n}
   
   [<a name="sub_count_n_n-val"><b>sub_count_n_n</b></a>]  Theorem
      
       n. sub_count n n = {count n}
   
   [<a name="sub_count_subset-val"><b>sub_count_subset</b></a>]  Theorem
      
       n k. sub_count n k  POW (count n)
   
   [<a name="sub_count_union-val"><b>sub_count_union</b></a>]  Theorem
      
       n k.
          sub_count (n + 1) (k + 1) =
          IMAGE (s. n INSERT s) (sub_count n k)  sub_count n (k + 1)
   
   [<a name="sub_sets_element-val"><b>sub_sets_element</b></a>]  Theorem
      
       P k s. s  sub_sets P k  s  P  CARD s = k
   
   [<a name="sub_sets_equiv_class-val"><b>sub_sets_equiv_class</b></a>]  Theorem
      
       s t.
          FINITE t  s  t 
          sub_sets t (CARD s) = equiv_class (s t. s =b= t) (POW t) s
   
   [<a name="sub_sets_sub_count-val"><b>sub_sets_sub_count</b></a>]  Theorem
      
       n k. sub_sets (count n) k = sub_count n k
   
   [<a name="sum_1_to_n_double-val"><b>sum_1_to_n_double</b></a>]  Theorem
      
       n. TWICE (SUM [1 .. n]) = n * (n + 1)
   
   [<a name="sum_1_to_n_eq_tri_n-val"><b>sum_1_to_n_eq_tri_n</b></a>]  Theorem
      
       n. SUM [1 .. n] = tri n
   
   [<a name="sum_1_to_n_eqn-val"><b>sum_1_to_n_eqn</b></a>]  Theorem
      
       n. SUM [1 .. n] = HALF (n * (n + 1))
   
   [<a name="surj_iff_preimage_card_not_0-val"><b>surj_iff_preimage_card_not_0</b></a>]  Theorem
      
       f s t.
          FINITE s  over f s t 
          (SURJ f s t  y. y  t  CARD (preimage f s y)  0)
   
   [<a name="surj_preimage_not_empty-val"><b>surj_preimage_not_empty</b></a>]  Theorem
      
       f s t. SURJ f s t  over f s t  y. y  t  preimage f s y  
   
   [<a name="tail_turn-val"><b>tail_turn</b></a>]  Theorem
      
       ls. ls  []  TL (turn ls) = FRONT ls
   
   [<a name="triple_11-val"><b>triple_11</b></a>]  Theorem
      
       a0 a1 a2 a0' a1' a2'.
          triple a0 a1 a2 = triple a0' a1' a2' 
          a0 = a0'  a1 = a1'  a2 = a2'
   
   [<a name="triple_Axiom-val"><b>triple_Axiom</b></a>]  Theorem
      
       f. fn. a0 a1 a2. fn (triple a0 a1 a2) = f a0 a1 a2
   
   [<a name="triple_accessors-val"><b>triple_accessors</b></a>]  Theorem
      
       (n n0 n1. (triple n n0 n1).a = n) 
        (n n0 n1. (triple n n0 n1).b = n0) 
        n n0 n1. (triple n n0 n1).c = n1
   
   [<a name="triple_accfupds-val"><b>triple_accfupds</b></a>]  Theorem
      
       (t f. (t with b updated_by f).a = t.a) 
        (t f. (t with c updated_by f).a = t.a) 
        (t f. (t with a updated_by f).b = t.b) 
        (t f. (t with c updated_by f).b = t.b) 
        (t f. (t with a updated_by f).c = t.c) 
        (t f. (t with b updated_by f).c = t.c) 
        (t f. (t with a updated_by f).a = f t.a) 
        (t f. (t with b updated_by f).b = f t.b) 
        t f. (t with c updated_by f).c = f t.c
   
   [<a name="triple_case_cong-val"><b>triple_case_cong</b></a>]  Theorem
      
       M M' f.
          M = M' 
          (a0 a1 a2. M' = triple a0 a1 a2  f a0 a1 a2 = f' a0 a1 a2) 
          triple_CASE M f = triple_CASE M' f'
   
   [<a name="triple_case_eq-val"><b>triple_case_eq</b></a>]  Theorem
      
       triple_CASE x f = v  n n0 n1. x = triple n n0 n1  f n n0 n1 = v
   
   [<a name="triple_component_equality-val"><b>triple_component_equality</b></a>]  Theorem
      
       t1 t2. t1 = t2  t1.a = t2.a  t1.b = t2.b  t1.c = t2.c
   
   [<a name="triple_fn_updates-val"><b>triple_fn_updates</b></a>]  Theorem
      
       (f n n0 n1.
           triple n n0 n1 with a updated_by f = triple (f n) n0 n1) 
        (f n n0 n1.
           triple n n0 n1 with b updated_by f = triple n (f n0) n1) 
        f n n0 n1. triple n n0 n1 with c updated_by f = triple n n0 (f n1)
   
   [<a name="triple_fupdcanon-val"><b>triple_fupdcanon</b></a>]  Theorem
      
       (t g f.
           t with &lt;|b updated_by f; a updated_by g|&gt; =
           t with &lt;|a updated_by g; b updated_by f|&gt;) 
        (t g f.
           t with &lt;|c updated_by f; a updated_by g|&gt; =
           t with &lt;|a updated_by g; c updated_by f|&gt;) 
        t g f.
          t with &lt;|c updated_by f; b updated_by g|&gt; =
          t with &lt;|b updated_by g; c updated_by f|&gt;
   
   [<a name="triple_fupdcanon_comp-val"><b>triple_fupdcanon_comp</b></a>]  Theorem
      
       ((g f. b_fupd f  a_fupd g = a_fupd g  b_fupd f) 
         h g f. b_fupd f  a_fupd g  h = a_fupd g  b_fupd f  h) 
        ((g f. c_fupd f  a_fupd g = a_fupd g  c_fupd f) 
         h g f. c_fupd f  a_fupd g  h = a_fupd g  c_fupd f  h) 
        (g f. c_fupd f  b_fupd g = b_fupd g  c_fupd f) 
        h g f. c_fupd f  b_fupd g  h = b_fupd g  c_fupd f  h
   
   [<a name="triple_fupdfupds-val"><b>triple_fupdfupds</b></a>]  Theorem
      
       (t g f.
           t with &lt;|a updated_by f; a updated_by g|&gt; =
           t with a updated_by f  g) 
        (t g f.
           t with &lt;|b updated_by f; b updated_by g|&gt; =
           t with b updated_by f  g) 
        t g f.
          t with &lt;|c updated_by f; c updated_by g|&gt; =
          t with c updated_by f  g
   
   [<a name="triple_fupdfupds_comp-val"><b>triple_fupdfupds_comp</b></a>]  Theorem
      
       ((g f. a_fupd f  a_fupd g = a_fupd (f  g)) 
         h g f. a_fupd f  a_fupd g  h = a_fupd (f  g)  h) 
        ((g f. b_fupd f  b_fupd g = b_fupd (f  g)) 
         h g f. b_fupd f  b_fupd g  h = b_fupd (f  g)  h) 
        (g f. c_fupd f  c_fupd g = c_fupd (f  g)) 
        h g f. c_fupd f  c_fupd g  h = c_fupd (f  g)  h
   
   [<a name="triple_induction-val"><b>triple_induction</b></a>]  Theorem
      
       P. (n n0 n1. P (triple n n0 n1))  t. P t
   
   [<a name="triple_literal_11-val"><b>triple_literal_11</b></a>]  Theorem
      
       n11 n01 n1 n12 n02 n2.
          &lt;|a := n11; b := n01; c := n1|&gt; = &lt;|a := n12; b := n02; c := n2|&gt; 
          n11 = n12  n01 = n02  n1 = n2
   
   [<a name="triple_literal_nchotomy-val"><b>triple_literal_nchotomy</b></a>]  Theorem
      
       t. n1 n0 n. t = &lt;|a := n1; b := n0; c := n|&gt;
   
   [<a name="triple_nchotomy-val"><b>triple_nchotomy</b></a>]  Theorem
      
       tt. n n0 n1. tt = triple n n0 n1
   
   [<a name="triple_updates_eq_literal-val"><b>triple_updates_eq_literal</b></a>]  Theorem
      
       t n1 n0 n.
          t with &lt;|a := n1; b := n0; c := n|&gt; =
          &lt;|a := n1; b := n0; c := n|&gt;
   
   [<a name="turn_eq_nil-val"><b>turn_eq_nil</b></a>]  Theorem
      
       p. turn p = []  p = []
   
   [<a name="turn_exp_0-val"><b>turn_exp_0</b></a>]  Theorem
      
       l. turn_exp l 0 = l
   
   [<a name="turn_exp_1-val"><b>turn_exp_1</b></a>]  Theorem
      
       l. turn_exp l 1 = turn l
   
   [<a name="turn_exp_2-val"><b>turn_exp_2</b></a>]  Theorem
      
       l. turn_exp l 2 = turn (turn l)
   
   [<a name="turn_exp_SUC-val"><b>turn_exp_SUC</b></a>]  Theorem
      
       l n. turn_exp l (SUC n) = turn_exp (turn l) n
   
   [<a name="turn_exp_length-val"><b>turn_exp_length</b></a>]  Theorem
      
       l n. LENGTH (turn_exp l n) = LENGTH l
   
   [<a name="turn_exp_suc-val"><b>turn_exp_suc</b></a>]  Theorem
      
       l n. turn_exp l (SUC n) = turn (turn_exp l n)
   
   [<a name="turn_length-val"><b>turn_length</b></a>]  Theorem
      
       l. LENGTH (turn l) = LENGTH l
   
   [<a name="turn_nil-val"><b>turn_nil</b></a>]  Theorem
      
       turn [] = []
   
   [<a name="turn_not_nil-val"><b>turn_not_nil</b></a>]  Theorem
      
       l. l  []  turn l = LAST l::FRONT l
   
   [<a name="turn_snoc-val"><b>turn_snoc</b></a>]  Theorem
      
       ls x. turn (SNOC x ls) = x::ls
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/algebra/base/.hol/objs/combinatoricsScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-2</a></em></p></body></html>
