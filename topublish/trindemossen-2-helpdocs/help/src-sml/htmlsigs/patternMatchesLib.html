<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure patternMatchesLib</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure patternMatchesLib</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/pattern_matches/patternMatchesLib.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature patternMatchesLib =
<a name="line2"></a>sig
<a name="line3"></a>  include Abbrev
<a name="line4"></a>  type ssfrag = simpLib.ssfrag
<a name="line5"></a>
<a name="line6"></a>  (********************************)
<a name="line7"></a>  (* parsing                      *)
<a name="line8"></a>  (********************************)
<a name="line9"></a>
<a name="line10"></a>  (* ENABLE_PMATCH_CASES() turns on parsing for
<a name="line11"></a>     PMATCH style case expressions. After calling it
<a name="line12"></a>     expressions like `case ... of ...` are not parsed
<a name="line13"></a>     to decision trees any more, but to PMATCH expressions.
<a name="line14"></a>     Decision tree case expressions are afterwards available
<a name="line15"></a>     via `dtcase ... of ...`. *)
<a name="line16"></a>  val ENABLE_PMATCH_CASES : unit -&gt; unit
<a name="line17"></a>
<a name="line18"></a>
<a name="line19"></a>  (********************************)
<a name="line20"></a>  (* Naming conventions           *)
<a name="line21"></a>  (********************************)
<a name="line22"></a>
<a name="line23"></a>  (* Many PMATCH related tools need to prove various forms of
<a name="line24"></a>     preconditions, in particular they need to prove that certain
<a name="line25"></a>     patterns are injective or don't overlap. For this they need
<a name="line26"></a>     information about the used constructors, in particular
<a name="line27"></a>     injectivity theorems about the used constructors and theorems
<a name="line28"></a>     about the distinctiveness of constructors. For most conversions
<a name="line29"></a>     there are therefore 4 forms:
<a name="line30"></a>
<a name="line31"></a>     XXX_CONV : conv
<a name="line32"></a>
<a name="line33"></a>     uses a default set of theorem for proving preconditions enriched
<a name="line34"></a>     with information from TypeBase.
<a name="line35"></a>
<a name="line36"></a>     XXX_CONV_GEN : ssfrag list -&gt; conv
<a name="line37"></a>
<a name="line38"></a>     additionally uses the given list of ssfrags for proving preconditions.
<a name="line39"></a>
<a name="line40"></a>     XXX_ss : ssfrag
<a name="line41"></a>
<a name="line42"></a>     uses the default set + the simplifier using it as a callback to prove
<a name="line43"></a>     preconditions.
<a name="line44"></a>
<a name="line45"></a>     XXX_ss_GEN : ssfrag list -&gt; ssfrag
<a name="line46"></a>
<a name="line47"></a>     uses additionally the given list of ssfrags.
<a name="line48"></a>  *)
<a name="line49"></a>
<a name="line50"></a>
<a name="line51"></a>  (********************************)
<a name="line52"></a>  (* Normalise PMATCH-terms       *)
<a name="line53"></a>  (********************************)
<a name="line54"></a>
<a name="line55"></a>  (* remove unused pattern variables *)
<a name="line56"></a>  val PMATCH_CLEANUP_PVARS_CONV : conv
<a name="line57"></a>
<a name="line58"></a>  (* Use same variable names for pattern, guard and rhs *)
<a name="line59"></a>  val PMATCH_FORCE_SAME_VARS_CONV : conv
<a name="line60"></a>
<a name="line61"></a>  (* Rename pattern variables unused in guard and rhs into
<a name="line62"></a>     wildcards. *)
<a name="line63"></a>  val PMATCH_INTRO_WILDCARDS_CONV : conv
<a name="line64"></a>
<a name="line65"></a>  (* Enforce each pattern to have the same number of columns, i.e.
<a name="line66"></a>     explicit elements of a top-level tuple. *)
<a name="line67"></a>  val PMATCH_EXPAND_COLS_CONV : conv
<a name="line68"></a>
<a name="line69"></a>  (* A combination of the normalisations above. *)
<a name="line70"></a>  val PMATCH_NORMALISE_CONV : conv
<a name="line71"></a>  val PMATCH_NORMALISE_ss : simpLib.ssfrag
<a name="line72"></a>
<a name="line73"></a>  (********************************)
<a name="line74"></a>  (* Evaluate PMATCH-terms        *)
<a name="line75"></a>  (********************************)
<a name="line76"></a>
<a name="line77"></a>  (* PMATCH_CLEANUP_CONV removes rows that can't match,
<a name="line78"></a>     removes all rows after the first matching row and
<a name="line79"></a>     evaluates the whole expression in case the first row matches. *)
<a name="line80"></a>  val PMATCH_CLEANUP_CONV : conv
<a name="line81"></a>  val PMATCH_CLEANUP_CONV_GEN : ssfrag list -&gt; conv
<a name="line82"></a>
<a name="line83"></a>  val PMATCH_CLEANUP_GEN_ss : ssfrag list -&gt; ssfrag
<a name="line84"></a>  val PMATCH_CLEANUP_ss : ssfrag
<a name="line85"></a>
<a name="line86"></a>  (* PMATCH_SIMP_COLS_CONV partially evaluates columns that all contain
<a name="line87"></a>     either the same constructor or a variable. *)
<a name="line88"></a>  val PMATCH_SIMP_COLS_CONV : conv
<a name="line89"></a>  val PMATCH_SIMP_COLS_CONV_GEN : ssfrag list -&gt; conv
<a name="line90"></a>
<a name="line91"></a>  (* A combination of PMATCH_CLEANUP_CONV and PMATCH_SIMP_COLS_CONV *)
<a name="line92"></a>  val PMATCH_FAST_SIMP_CONV : conv
<a name="line93"></a>  val PMATCH_FAST_SIMP_CONV_GEN : ssfrag list -&gt; conv
<a name="line94"></a>  val PMATCH_FAST_SIMP_GEN_ss : ssfrag list -&gt; ssfrag
<a name="line95"></a>  val PMATCH_FAST_SIMP_ss : ssfrag
<a name="line96"></a>
<a name="line97"></a>
<a name="line98"></a>  (********************************)
<a name="line99"></a>  (* simplify PMATCH-terms        *)
<a name="line100"></a>  (********************************)
<a name="line101"></a>
<a name="line102"></a>  (* Remove easily detectable redundant rows *)
<a name="line103"></a>  val PMATCH_REMOVE_FAST_REDUNDANT_CONV : conv
<a name="line104"></a>  val PMATCH_REMOVE_FAST_REDUNDANT_CONV_GEN : ssfrag list -&gt; conv
<a name="line105"></a>
<a name="line106"></a>  (* Remove easily detectable subsumed rows *)
<a name="line107"></a>  val PMATCH_REMOVE_FAST_SUBSUMED_CONV : bool -&gt; conv
<a name="line108"></a>  val PMATCH_REMOVE_FAST_SUBSUMED_CONV_GEN : bool -&gt; ssfrag list -&gt; conv
<a name="line109"></a>
<a name="line110"></a>  (* Full simplification of PMATCH expressions:
<a name="line111"></a>     normalise, partially evaluate rows and columns and
<a name="line112"></a>     try to remove redundant and subsumed rows. *)
<a name="line113"></a>  val PMATCH_SIMP_CONV : conv
<a name="line114"></a>  val PMATCH_SIMP_CONV_GEN : ssfrag list -&gt; conv
<a name="line115"></a>  val PMATCH_SIMP_GEN_ss : ssfrag list -&gt; ssfrag
<a name="line116"></a>  val PMATCH_SIMP_ss : ssfrag
<a name="line117"></a>
<a name="line118"></a>
<a name="line119"></a>  (********************************)
<a name="line120"></a>  (* removing double variable     *)
<a name="line121"></a>  (* bindings                     *)
<a name="line122"></a>  (********************************)
<a name="line123"></a>
<a name="line124"></a>  val PMATCH_REMOVE_DOUBLE_BIND_CONV_GEN : ssfrag list -&gt; conv
<a name="line125"></a>  val PMATCH_REMOVE_DOUBLE_BIND_CONV : conv
<a name="line126"></a>  val PMATCH_REMOVE_DOUBLE_BIND_GEN_ss : ssfrag list -&gt; ssfrag
<a name="line127"></a>  val PMATCH_REMOVE_DOUBLE_BIND_ss : ssfrag
<a name="line128"></a>
<a name="line129"></a>
<a name="line130"></a>  (********************************)
<a name="line131"></a>  (* removing GUARDS              *)
<a name="line132"></a>  (********************************)
<a name="line133"></a>
<a name="line134"></a>  val PMATCH_REMOVE_GUARDS_CONV_GEN : ssfrag list -&gt; conv
<a name="line135"></a>  val PMATCH_REMOVE_GUARDS_CONV : conv
<a name="line136"></a>  val PMATCH_REMOVE_GUARDS_GEN_ss : ssfrag list -&gt; ssfrag
<a name="line137"></a>  val PMATCH_REMOVE_GUARDS_ss : ssfrag
<a name="line138"></a>
<a name="line139"></a>
<a name="line140"></a>  (********************************)
<a name="line141"></a>  (* extending input              *)
<a name="line142"></a>  (********************************)
<a name="line143"></a>
<a name="line144"></a>  val PMATCH_EXTEND_INPUT_CONV_GEN : ssfrag list -&gt; term -&gt; conv
<a name="line145"></a>  val PMATCH_EXTEND_INPUT_CONV : term -&gt; conv
<a name="line146"></a>
<a name="line147"></a>  (********************************)
<a name="line148"></a>  (* removing PMATCH-terms        *)
<a name="line149"></a>  (* via lifting it to the nearest*)
<a name="line150"></a>  (* boolean term and then        *)
<a name="line151"></a>  (* unfolding                    *)
<a name="line152"></a>  (********************************)
<a name="line153"></a>
<a name="line154"></a>  (* One can eliminate PMATCHs by unfolding all
<a name="line155"></a>     cases explicitly. This is often handy to
<a name="line156"></a>     prove properties about functions defined
<a name="line157"></a>     via pattern matches without the need to
<a name="line158"></a>     do the case-splits manually.
<a name="line159"></a>
<a name="line160"></a>     This tactic looks for the smallest wrapper
<a name="line161"></a>     around a PMATCH such that the term is of type
<a name="line162"></a>     bool. This term is then expanded into a big
<a name="line163"></a>     conjunction. For each case of the pattern match,
<a name="line164"></a>     one conjunct is created.
<a name="line165"></a>
<a name="line166"></a>     If the flag "check_exh" is is set to true, the
<a name="line167"></a>     conversion tries to prove the exhaustiveness of
<a name="line168"></a>     the expanded pattern match. This is slow, but if
<a name="line169"></a>     successful allows to eliminate the last
<a name="line170"></a>     generated conjunct.
<a name="line171"></a>  *)
<a name="line172"></a>  val PMATCH_LIFT_BOOL_CONV : bool -&gt; conv
<a name="line173"></a>
<a name="line174"></a>  (* There is also a more generic version that
<a name="line175"></a>     allows to provide extra ssfrags. This might
<a name="line176"></a>     be handy, if the PMATCH contains functions
<a name="line177"></a>     not known by the default methods. *)
<a name="line178"></a>  val PMATCH_LIFT_BOOL_CONV_GEN : ssfrag list -&gt; bool -&gt; conv
<a name="line179"></a>
<a name="line180"></a>  (* corresponding ssfrags *)
<a name="line181"></a>  val PMATCH_LIFT_BOOL_GEN_ss : ssfrag list -&gt; bool -&gt; ssfrag
<a name="line182"></a>  val PMATCH_LIFT_BOOL_ss : bool -&gt; ssfrag
<a name="line183"></a>
<a name="line184"></a>  (* A special case of lifting are function definitions,
<a name="line185"></a>     which use PMATCH. In order to use such definitions
<a name="line186"></a>     with the rewriting tools, it is often handy to
<a name="line187"></a>     move the PMATCH to the toplevel and introduce
<a name="line188"></a>     multiple cases, one case for each row of the
<a name="line189"></a>     PMATCH. This is automated by the following rules. *)
<a name="line190"></a>  val PMATCH_TO_TOP_RULE_GEN : ssfrag list -&gt; rule
<a name="line191"></a>  val PMATCH_TO_TOP_RULE : rule
<a name="line192"></a>
<a name="line193"></a>  (********************************)
<a name="line194"></a>  (* convert between              *)
<a name="line195"></a>  (* case and pmatch              *)
<a name="line196"></a>  (********************************)
<a name="line197"></a>
<a name="line198"></a>  (* without proof convert a case to a pmatch expression.
<a name="line199"></a>     If the flag is set, optimise the result by
<a name="line200"></a>     introducing wildcards reordering rows ... *)
<a name="line201"></a>  val case2pmatch : bool -&gt; term -&gt; term
<a name="line202"></a>
<a name="line203"></a>  (* convert a pmatch expression to a case expression.
<a name="line204"></a>     Fails, if the pmatch expression uses guards or
<a name="line205"></a>     non-constructor patterns. *)
<a name="line206"></a>  val pmatch2case : term -&gt; term
<a name="line207"></a>
<a name="line208"></a>  (* The following conversions call
<a name="line209"></a>     case2pmatch and pmatch2case and
<a name="line210"></a>     afterwards prove the equivalence of
<a name="line211"></a>     the result. *)
<a name="line212"></a>  val PMATCH_INTRO_CONV : conv
<a name="line213"></a>  val PMATCH_INTRO_CONV_NO_OPTIMISE : conv
<a name="line214"></a>  val PMATCH_ELIM_CONV : conv
<a name="line215"></a>
<a name="line216"></a>
<a name="line217"></a>  (*************************************)
<a name="line218"></a>  (* Analyse PMATCH expressions to     *)
<a name="line219"></a>  (* check whether they can be         *)
<a name="line220"></a>  (* translated to ML or OCAML         *)
<a name="line221"></a>  (*************************************)
<a name="line222"></a>
<a name="line223"></a>  (* Record storing detailed information about a PMATCH *)
<a name="line224"></a>  type pmatch_info = {
<a name="line225"></a>    (* Is it a well formed PMATCH, i.e. is it of
<a name="line226"></a>       the from PMATCH input row_list, where
<a name="line227"></a>       every row is given explicitly via PMATCH_MATCH_ROW
<a name="line228"></a>       and is wellformed itself? *)
<a name="line229"></a>    pmi_is_well_formed            : bool,
<a name="line230"></a>
<a name="line231"></a>    (* List of all rows that are not well-formed.
<a name="line232"></a>       If this list is non-empty, pmi_is_well_formed is false. *)
<a name="line233"></a>    pmi_ill_formed_rows           : int list,
<a name="line234"></a>
<a name="line235"></a>    (* List of rows that have guards *)
<a name="line236"></a>    pmi_has_guards                : int list,
<a name="line237"></a>
<a name="line238"></a>    (* List of rows that contain variables in a pattern that
<a name="line239"></a>       are not bound by the pattern. These free vars are
<a name="line240"></a>       returned explicitly. *)
<a name="line241"></a>    pmi_has_free_pat_vars         : (int * term list) list,
<a name="line242"></a>
<a name="line243"></a>    (* List of rows whose patterns bind variables that they
<a name="line244"></a>       do not use. These unused vars are returned explicitly. *)
<a name="line245"></a>    pmi_has_unused_pat_vars       : (int * term list) list,
<a name="line246"></a>
<a name="line247"></a>    (* List of rows whose patterns use a bound variable
<a name="line248"></a>       multiple times. These vars are returned explicitly. *)
<a name="line249"></a>    pmi_has_double_bound_pat_vars : (int * term list) list,
<a name="line250"></a>
<a name="line251"></a>    (* List of rows that uses constants that are neither
<a name="line252"></a>       literals nor datatype-constructors in
<a name="line253"></a>       patterns. These constants are returned. *)
<a name="line254"></a>    pmi_has_non_contr_in_pat      : (int * term list) list,
<a name="line255"></a>
<a name="line256"></a>    (* List of rows that use lambda-abstractions in patterns. *)
<a name="line257"></a>    pmi_has_lambda_in_pat         : int list,
<a name="line258"></a>
<a name="line259"></a>    (* Optional information about exhaustiveness.
<a name="line260"></a>       Checking exhaustiveness is expensive, therefore it
<a name="line261"></a>       can be skipped. However, if a theorem is stored here,
<a name="line262"></a>       it is of the form `|- ~(cond) -&gt; exhaustive`.
<a name="line263"></a>       There are no other guarantees. We don't guarantee that
<a name="line264"></a>       if the condition holds, the pattern match is inexhaustive.
<a name="line265"></a>       This is usually the case, put we don't guarantee it.
<a name="line266"></a>       To check, whether the match is exhaustive, check whether
<a name="line267"></a>       the guard is T. See below for functions using this
<a name="line268"></a>       field.
<a name="line269"></a>     *)
<a name="line270"></a>    pmi_exhaustiveness_cond       : thm option
<a name="line271"></a>  }
<a name="line272"></a>
<a name="line273"></a>  (* Analyse a PMATCH term and return the result. If
<a name="line274"></a>     the flag is set to true, an exhaustiveness check is
<a name="line275"></a>     attempted, if no syntactic checks indicate that this
<a name="line276"></a>     one would most likely fail. *)
<a name="line277"></a>  val analyse_pmatch : bool -&gt; term -&gt; pmatch_info
<a name="line278"></a>
<a name="line279"></a>  (* Check whether the PMATCH is syntactically well-formed. *)
<a name="line280"></a>  val is_well_formed_pmatch : pmatch_info -&gt; bool
<a name="line281"></a>
<a name="line282"></a>  (* Check whether the PMATCH is falling into the subset
<a name="line283"></a>     supported by OCAML *)
<a name="line284"></a>  val is_ocaml_pmatch : pmatch_info -&gt; bool
<a name="line285"></a>
<a name="line286"></a>  (* Check whether the PMATCH is falling into the subset
<a name="line287"></a>     supported by SML. *)
<a name="line288"></a>  val is_sml_pmatch : pmatch_info -&gt; bool;
<a name="line289"></a>
<a name="line290"></a>  (* Was it proved that the PMATCH is exhaustive? If
<a name="line291"></a>     the answer is no, we don't know much. *)
<a name="line292"></a>  val is_proven_exhaustive_pmatch : pmatch_info -&gt; bool
<a name="line293"></a>
<a name="line294"></a>  (* Get the list of patterns that are possibly missing.
<a name="line295"></a>     If no exhaustiveness information is available, NONE
<a name="line296"></a>     is returned. The missing patterns are returns as a list
<a name="line297"></a>     of triples (`bound-vars`, `pattern`, `guard`) *)
<a name="line298"></a>  val get_possibly_missing_patterns : pmatch_info -&gt;
<a name="line299"></a>    (term * term * term) list option
<a name="line300"></a>
<a name="line301"></a>  (** extend_possibly_missing_patterns t pmi
<a name="line302"></a>      tries to extend the original pattern match t with
<a name="line303"></a>      rows derived from the exhaustiveness information
<a name="line304"></a>      from its info. It fails, if no exhaustiveness
<a name="line305"></a>      information is available. The result should
<a name="line306"></a>      be an exhaustive match, which is equivalent to
<a name="line307"></a>      the input `t`. If you need a proof, use
<a name="line308"></a>      PMATCH_COMPLETE_CONV and similar functions instead
<a name="line309"></a>      of this syntactic one. *)
<a name="line310"></a>  val extend_possibly_missing_patterns : term -&gt; pmatch_info -&gt; term
<a name="line311"></a>
<a name="line312"></a>
<a name="line313"></a>  (********************************)
<a name="line314"></a>  (* CASE SPLIT (pattern compile) *)
<a name="line315"></a>  (********************************)
<a name="line316"></a>
<a name="line317"></a>  (*------------*)
<a name="line318"></a>  (* Heuristics *)
<a name="line319"></a>  (*------------*)
<a name="line320"></a>
<a name="line321"></a>  (* A column heuristic is used to figure out, in
<a name="line322"></a>     which order to process columns. It gets a list of columns
<a name="line323"></a>     and returns, which one to pick. *)
<a name="line324"></a>  type column_heuristic = (term * (term list * term) list) list -&gt; int
<a name="line325"></a>
<a name="line326"></a>  (* Many heuristics are build on ranking funs.
<a name="line327"></a>     A ranking fun assigns an integer to a column. Larger
<a name="line328"></a>     numbers are preferred. If two columns have the same
<a name="line329"></a>     value, either another ranking fun is used to decide or
<a name="line330"></a>     just the first one is used, if no ranking fun is available. *)
<a name="line331"></a>  type column_ranking_fun = term * (term list * term) list -&gt; int
<a name="line332"></a>  val colHeu_rank : column_ranking_fun list -&gt; column_heuristic
<a name="line333"></a>
<a name="line334"></a>  val colRank_first_row : column_ranking_fun
<a name="line335"></a>  val colRank_first_row_constr : constrFamiliesLib.pmatch_compile_db -&gt;
<a name="line336"></a>                                 column_ranking_fun
<a name="line337"></a>  val colRank_arity : constrFamiliesLib.pmatch_compile_db -&gt; column_ranking_fun
<a name="line338"></a>  val colRank_constr_prefix : column_ranking_fun
<a name="line339"></a>  val colRank_small_branching_factor : constrFamiliesLib.pmatch_compile_db -&gt;
<a name="line340"></a>                                       column_ranking_fun
<a name="line341"></a>
<a name="line342"></a>  (* Some heuristics *)
<a name="line343"></a>  val colHeu_first_col : column_heuristic
<a name="line344"></a>  val colHeu_last_col : column_heuristic
<a name="line345"></a>  val colHeu_first_row : column_heuristic
<a name="line346"></a>  val colHeu_constr_prefix : column_heuristic
<a name="line347"></a>  val colHeu_cqba : constrFamiliesLib.pmatch_compile_db -&gt; column_heuristic
<a name="line348"></a>  val colHeu_qba : constrFamiliesLib.pmatch_compile_db -&gt; column_heuristic
<a name="line349"></a>
<a name="line350"></a>  (* the default heuristic, currently it is
<a name="line351"></a>     colHeu_qba applied to the default db. However,
<a name="line352"></a>     this might change. You can just rely on a decent heuristic,
<a name="line353"></a>     that often works. No specific properties guaranteed. *)
<a name="line354"></a>  val colHeu_default : column_heuristic
<a name="line355"></a>
<a name="line356"></a>
<a name="line357"></a>  (*---------------------*)
<a name="line358"></a>  (* PATTERN COMPILATION *)
<a name="line359"></a>  (*---------------------*)
<a name="line360"></a>
<a name="line361"></a>  (* [PMATCH_CASE_SPLIT_CONV_GEN ssl db col_heu]
<a name="line362"></a>     is a conversion that tries to compile PMATCH expressions
<a name="line363"></a>     to decision trees using database [db], column heuristic
<a name="line364"></a>     [col_heu] and additional ssfrags [ssl]. *)
<a name="line365"></a>  val PMATCH_CASE_SPLIT_CONV_GEN :
<a name="line366"></a>     ssfrag list -&gt;
<a name="line367"></a>     constrFamiliesLib.pmatch_compile_db -&gt;
<a name="line368"></a>     column_heuristic -&gt; conv
<a name="line369"></a>
<a name="line370"></a>  (* A simplified version of PMATCH_CASE_SPLIT_CONV that
<a name="line371"></a>     uses the default database and default column heuristic as
<a name="line372"></a>     well as no extra ssfrags. *)
<a name="line373"></a>  val PMATCH_CASE_SPLIT_CONV : conv
<a name="line374"></a>
<a name="line375"></a>  (* lets choose at least the heuristic *)
<a name="line376"></a>  val PMATCH_CASE_SPLIT_CONV_HEU : column_heuristic -&gt; conv
<a name="line377"></a>
<a name="line378"></a>  (* ssfrag corresponding to PMATCH_CASE_SPLIT_CONV_GEN *)
<a name="line379"></a>  val PMATCH_CASE_SPLIT_GEN_ss :
<a name="line380"></a>     ssfrag list -&gt;
<a name="line381"></a>     constrFamiliesLib.pmatch_compile_db -&gt;
<a name="line382"></a>     column_heuristic -&gt; ssfrag
<a name="line383"></a>
<a name="line384"></a>  (* ssfrag corresponding to PMATCH_CASE_SPLIT_CONV, since
<a name="line385"></a>     it needs to get the current version of the default db,
<a name="line386"></a>     it gets a unit argument. *)
<a name="line387"></a>  val PMATCH_CASE_SPLIT_ss : unit -&gt; ssfrag
<a name="line388"></a>
<a name="line389"></a>  (* lets choose at least the heuristic *)
<a name="line390"></a>  val PMATCH_CASE_SPLIT_HEU_ss : column_heuristic -&gt; ssfrag
<a name="line391"></a>
<a name="line392"></a>
<a name="line393"></a>  (* Pattern compilation builds for a list of patterns, implicitly
<a name="line394"></a>     a nchotomy theorem, i.e. a list of patterns that cover all the
<a name="line395"></a>     original ones and are exhaustive. Moreover these patterns usually
<a name="line396"></a>     have some nice properties like e.g. not overlapping with each other.
<a name="line397"></a>     Such a nchotomy theorem is often handy. We use it to check for
<a name="line398"></a>     exhaustiveness for example. The interface
<a name="line399"></a>     to compute such an nchotomy is exposed here as well. *)
<a name="line400"></a>
<a name="line401"></a>  (* [nchotomy_of_pats_GEN db colHeu pats] computes an nchotomy-theorem
<a name="line402"></a>     for a list of patterns. A pattern is written as for PMATCH, i.e. in the form ``\(v1, ..., vn). p v1 ... vn``. *)
<a name="line403"></a>  val nchotomy_of_pats_GEN : constrFamiliesLib.pmatch_compile_db -&gt;
<a name="line404"></a>                             column_heuristic -&gt; term list -&gt; thm
<a name="line405"></a>  val nchotomy_of_pats : term list -&gt; thm
<a name="line406"></a>
<a name="line407"></a>
<a name="line408"></a>  (*-----------------------*)
<a name="line409"></a>  (* Remove redundant rows *)
<a name="line410"></a>  (*-----------------------*)
<a name="line411"></a>
<a name="line412"></a>  (* fancy, slow conversion for detecting and removing
<a name="line413"></a>     redundant rows. Internally this uses [nchotomy_of_pats] and
<a name="line414"></a>     therefore requires a pmatch-compile db and a column-heuristic. *)
<a name="line415"></a>  val PMATCH_REMOVE_REDUNDANT_CONV_GEN :
<a name="line416"></a>    constrFamiliesLib.pmatch_compile_db -&gt; column_heuristic -&gt; ssfrag list -&gt;
<a name="line417"></a>    conv
<a name="line418"></a>  val PMATCH_REMOVE_REDUNDANT_CONV : conv
<a name="line419"></a>
<a name="line420"></a>  val PMATCH_REMOVE_REDUNDANT_GEN_ss :
<a name="line421"></a>    constrFamiliesLib.pmatch_compile_db -&gt; column_heuristic -&gt; ssfrag list -&gt;
<a name="line422"></a>    ssfrag
<a name="line423"></a>  val PMATCH_REMOVE_REDUNDANT_ss : unit -&gt; ssfrag
<a name="line424"></a>
<a name="line425"></a>
<a name="line426"></a>  (* The redundancy removal conversion works by
<a name="line427"></a>     first creating a is-redundant-rows-info theorem and
<a name="line428"></a>     then turning it into a PMATCH equation. One can
<a name="line429"></a>     separate these steps, this allows using interactive proofs
<a name="line430"></a>     for showing that a row is redundant. *)
<a name="line431"></a>  val COMPUTE_REDUNDANT_ROWS_INFO_OF_PMATCH_GEN :
<a name="line432"></a>    ssfrag list -&gt; constrFamiliesLib.pmatch_compile_db -&gt; column_heuristic -&gt;
<a name="line433"></a>    term -&gt; thm
<a name="line434"></a>  val COMPUTE_REDUNDANT_ROWS_INFO_OF_PMATCH : term -&gt; thm
<a name="line435"></a>
<a name="line436"></a>  (* Apply the resulting redundant rows-info *)
<a name="line437"></a>  val IS_REDUNDANT_ROWS_INFO_TO_PMATCH_EQ_THM : thm -&gt; thm
<a name="line438"></a>
<a name="line439"></a>
<a name="line440"></a>  (* prove redundancy of given row given an info-thm *)
<a name="line441"></a>  val IS_REDUNDANT_ROWS_INFO_SHOW_ROW_IS_REDUNDANT :
<a name="line442"></a>    thm -&gt; int -&gt; tactic -&gt; thm
<a name="line443"></a>
<a name="line444"></a>  val IS_REDUNDANT_ROWS_INFO_SHOW_ROW_IS_REDUNDANT_set_goal :
<a name="line445"></a>    thm -&gt; int -&gt; proofManagerLib.proofs
<a name="line446"></a>
<a name="line447"></a>
<a name="line448"></a>  (*-----------------------*)
<a name="line449"></a>  (* Exhaustiveness        *)
<a name="line450"></a>  (*-----------------------*)
<a name="line451"></a>
<a name="line452"></a>  (* A IS_REDUNDANT_ROW_INFO theorem contains already
<a name="line453"></a>     information, whether the pattern match is exhaustive.
<a name="line454"></a>
<a name="line455"></a>     IS_REDUNDANT_ROWS_INFO_TO_PMATCH_IS_EXHAUSTIVE extracts
<a name="line456"></a>     this information in the form of an implication. Ideally,
<a name="line457"></a>     the precondition is ~F, but the user has to check. *)
<a name="line458"></a>
<a name="line459"></a>  val IS_REDUNDANT_ROWS_INFO_TO_PMATCH_IS_EXHAUSTIVE : thm -&gt; thm
<a name="line460"></a>
<a name="line461"></a>  (* For convenience this is combined with the computation of the
<a name="line462"></a>     IS_REDUNDANT_ROWS_INFO. So given a PMATCH term, the following
<a name="line463"></a>     functions compute an implication, whose conclusion is the
<a name="line464"></a>     exhaustiveness of the PMATCH. *)
<a name="line465"></a>
<a name="line466"></a>  val PMATCH_IS_EXHAUSTIVE_COMPILE_CONSEQ_CHECK : term -&gt; thm
<a name="line467"></a>  val PMATCH_IS_EXHAUSTIVE_COMPILE_CONSEQ_CHECK_GEN :
<a name="line468"></a>     ssfrag list -&gt; term -&gt; thm
<a name="line469"></a>  val PMATCH_IS_EXHAUSTIVE_COMPILE_CONSEQ_CHECK_FULLGEN :
<a name="line470"></a>     constrFamiliesLib.pmatch_compile_db -&gt; column_heuristic -&gt;
<a name="line471"></a>     (ssfrag list * conv option) -&gt; term -&gt; thm
<a name="line472"></a>
<a name="line473"></a>  (* One can usually even derive an equality.  *)
<a name="line474"></a>
<a name="line475"></a>  val PMATCH_IS_EXHAUSTIVE_COMPILE_CHECK : term -&gt; thm
<a name="line476"></a>  val PMATCH_IS_EXHAUSTIVE_COMPILE_CHECK_GEN :
<a name="line477"></a>     ssfrag list -&gt; term -&gt; thm
<a name="line478"></a>  val PMATCH_IS_EXHAUSTIVE_COMPILE_CHECK_FULLGEN :
<a name="line479"></a>     constrFamiliesLib.pmatch_compile_db -&gt; column_heuristic -&gt;
<a name="line480"></a>     (ssfrag list * conv option) -&gt; term -&gt; thm
<a name="line481"></a>
<a name="line482"></a>
<a name="line483"></a>  (* Computing the IS_REDUNDANT_ROWS_INFO takes time and
<a name="line484"></a>      is often not necessary. Many pattern matches contain
<a name="line485"></a>      for example and catch-all pattern as the last row.
<a name="line486"></a>      The following functions try to compute the redundancy
<a name="line487"></a>      fast by searching such rows. If they succeed they result
<a name="line488"></a>      in a theorem of the form
<a name="line489"></a>
<a name="line490"></a>      EHX_STATEMENT = T
<a name="line491"></a>
<a name="line492"></a>      or
<a name="line493"></a>
<a name="line494"></a>      EHX_STATEMENT = F
<a name="line495"></a>
<a name="line496"></a>      So, this time, there is an equation, not an implication
<a name="line497"></a>      and the right-hand-side is always T or F.
<a name="line498"></a>   *)
<a name="line499"></a>   val PMATCH_IS_EXHAUSTIVE_FAST_CHECK : term -&gt; thm
<a name="line500"></a>   val PMATCH_IS_EXHAUSTIVE_FAST_CHECK_GEN : ssfrag list -&gt; term -&gt; thm
<a name="line501"></a>
<a name="line502"></a>
<a name="line503"></a>   (* Both methods can be combined to combine the speed of
<a name="line504"></a>      the fast version with the power of the slow one.
<a name="line505"></a>
<a name="line506"></a>      There are two versions of this, one resulting in an
<a name="line507"></a>      equation and one resulting in an implication. The
<a name="line508"></a>      equation one is suitable, if one just wants yes/no
<a name="line509"></a>      answers, the implicational one to analyse what is missing
<a name="line510"></a>      to make the pattern match exhaustive. *)
<a name="line511"></a>
<a name="line512"></a>   val PMATCH_IS_EXHAUSTIVE_CHECK : term -&gt; thm
<a name="line513"></a>   val PMATCH_IS_EXHAUSTIVE_CHECK_GEN : ssfrag list -&gt; term -&gt; thm
<a name="line514"></a>   val PMATCH_IS_EXHAUSTIVE_CHECK_FULLGEN :
<a name="line515"></a>      constrFamiliesLib.pmatch_compile_db -&gt; column_heuristic -&gt;
<a name="line516"></a>      (ssfrag list * conv option) -&gt; term -&gt; thm
<a name="line517"></a>
<a name="line518"></a>   val PMATCH_IS_EXHAUSTIVE_CONSEQ_CHECK : term -&gt; thm
<a name="line519"></a>   val PMATCH_IS_EXHAUSTIVE_CONSEQ_CHECK_GEN : ssfrag list -&gt; term -&gt; thm
<a name="line520"></a>   val PMATCH_IS_EXHAUSTIVE_CONSEQ_CHECK_FULLGEN :
<a name="line521"></a>      constrFamiliesLib.pmatch_compile_db -&gt; column_heuristic -&gt;
<a name="line522"></a>      (ssfrag list * conv option) -&gt; term -&gt; thm
<a name="line523"></a>
<a name="line524"></a>
<a name="line525"></a>   (* More interesting than just computing whether a PMATCH
<a name="line526"></a>      expression is exhaustive might be adding at the end
<a name="line527"></a>      additional rows that explicitly list the missing pats
<a name="line528"></a>      and return ARB for them. This is achieved by the following
<a name="line529"></a>      functions.
<a name="line530"></a>
<a name="line531"></a>      The additional patterns can use guards or not. If not
<a name="line532"></a>      guards are used, the added patterns are more coarse, but
<a name="line533"></a>      simpler. *)
<a name="line534"></a>
<a name="line535"></a>   val PMATCH_COMPLETE_CONV : bool -&gt; conv
<a name="line536"></a>   val PMATCH_COMPLETE_ss : bool -&gt; ssfrag
<a name="line537"></a>
<a name="line538"></a>   (* and as usual more general versions that allows using
<a name="line539"></a>      own pattern compilation settings *)
<a name="line540"></a>   val PMATCH_COMPLETE_CONV_GEN : ssfrag list -&gt;
<a name="line541"></a>     constrFamiliesLib.pmatch_compile_db -&gt; column_heuristic -&gt;
<a name="line542"></a>     bool -&gt; conv
<a name="line543"></a>
<a name="line544"></a>   val PMATCH_COMPLETE_GEN_ss :
<a name="line545"></a>     ssfrag list -&gt;
<a name="line546"></a>     constrFamiliesLib.pmatch_compile_db -&gt;
<a name="line547"></a>     column_heuristic -&gt; bool -&gt; ssfrag
<a name="line548"></a>
<a name="line549"></a>
<a name="line550"></a>   (* Versions with suffix "WITH_EXH_PROOF" return a theorem stating
<a name="line551"></a>      that the resulting case split is exhaustive is returned as well.
<a name="line552"></a>      In case the original case split is already exhaustive, no
<a name="line553"></a>      conversion theorem is returned. However a theorem stating that the
<a name="line554"></a>      original case split is exhaustive is still computed. *)
<a name="line555"></a>   val PMATCH_COMPLETE_CONV_WITH_EXH_PROOF : bool -&gt; (term -&gt; (thm option * thm))
<a name="line556"></a>
<a name="line557"></a>   val PMATCH_COMPLETE_CONV_GEN_WITH_EXH_PROOF : ssfrag list -&gt;
<a name="line558"></a>     constrFamiliesLib.pmatch_compile_db -&gt; column_heuristic -&gt;
<a name="line559"></a>     bool -&gt; (term -&gt; (thm option * thm))
<a name="line560"></a>
<a name="line561"></a>  (*-----------------------*)
<a name="line562"></a>  (* Show nchotomy         *)
<a name="line563"></a>  (*-----------------------*)
<a name="line564"></a>
<a name="line565"></a>  (* [show_nchotomy t] tries to prove an nchotomy-theorem.
<a name="line566"></a>     Given an nchotomy theorem of the form
<a name="line567"></a>     ``!x. (?xs1. v = p1 xs1 /\ g1 xs1) \/ ... \/
<a name="line568"></a>           (?xsn. v = pn xsn /\ gn xsn)``.
<a name="line569"></a>     It returns a theorem that is an implication with
<a name="line570"></a>     the input as conclusion. *)
<a name="line571"></a>  val SHOW_NCHOTOMY_CONSEQ_CONV : ConseqConv.conseq_conv
<a name="line572"></a>
<a name="line573"></a>  (* A generalised version that allows specifying additional
<a name="line574"></a>     parameters. *)
<a name="line575"></a>  val SHOW_NCHOTOMY_CONSEQ_CONV_GEN :
<a name="line576"></a>    ssfrag list -&gt; constrFamiliesLib.pmatch_compile_db -&gt;
<a name="line577"></a>    column_heuristic -&gt; ConseqConv.conseq_conv
<a name="line578"></a>
<a name="line579"></a>
<a name="line580"></a>  (********************************)
<a name="line581"></a>  (* General Lifting              *)
<a name="line582"></a>  (********************************)
<a name="line583"></a>
<a name="line584"></a>  (* One can also lift to arbitrary levels. This requires forcing the
<a name="line585"></a>     lifted case expression to be exhaustive though.  Therefore,
<a name="line586"></a>     PMATCH_COMPLETE_CONV is used internally and a compilation database
<a name="line587"></a>     and a column heuristic are needed. Similarly to lifting, there is
<a name="line588"></a>     also a version that returns an exhaustiveness statement of the
<a name="line589"></a>     result. *)
<a name="line590"></a>
<a name="line591"></a>  val PMATCH_LIFT_CONV : conv
<a name="line592"></a>
<a name="line593"></a>  val PMATCH_LIFT_CONV_GEN : ssfrag list -&gt;
<a name="line594"></a>     constrFamiliesLib.pmatch_compile_db -&gt; column_heuristic -&gt;
<a name="line595"></a>     conv
<a name="line596"></a>
<a name="line597"></a>  val PMATCH_LIFT_CONV_WITH_EXH_PROOF : term -&gt; (thm * thm)
<a name="line598"></a>
<a name="line599"></a>  val PMATCH_LIFT_CONV_GEN_WITH_EXH_PROOF : ssfrag list -&gt;
<a name="line600"></a>     constrFamiliesLib.pmatch_compile_db -&gt; column_heuristic -&gt;
<a name="line601"></a>     term -&gt; (thm * thm)
<a name="line602"></a>
<a name="line603"></a>
<a name="line604"></a>  (********************************)
<a name="line605"></a>  (* Flattening                   *)
<a name="line606"></a>  (********************************)
<a name="line607"></a>
<a name="line608"></a>  (* Flattening tries to flatten nested PMATCH case expressions into a
<a name="line609"></a>     single one. It needs to enforce exhaustiveness. Therefore a
<a name="line610"></a>     compilation database and a column heuristic are needed.  The
<a name="line611"></a>     additional flag states whether lifting should be attempted.  If
<a name="line612"></a>     set to false, only nested PMATCH expressions directly at the top
<a name="line613"></a>     of the rhs of a row are considered for flattening. Otherwise,
<a name="line614"></a>     lifting is attempted. *)
<a name="line615"></a>
<a name="line616"></a>  val PMATCH_FLATTEN_CONV_GEN : ssfrag list -&gt;
<a name="line617"></a>     constrFamiliesLib.pmatch_compile_db -&gt; column_heuristic -&gt;
<a name="line618"></a>     bool -&gt; conv
<a name="line619"></a>
<a name="line620"></a>  val PMATCH_FLATTEN_CONV : bool -&gt; conv
<a name="line621"></a>
<a name="line622"></a>  val PMATCH_FLATTEN_GEN_ss : ssfrag list -&gt;
<a name="line623"></a>     constrFamiliesLib.pmatch_compile_db -&gt; column_heuristic -&gt;
<a name="line624"></a>     bool -&gt; ssfrag
<a name="line625"></a>
<a name="line626"></a>  val PMATCH_FLATTEN_ss : bool -&gt; ssfrag
<a name="line627"></a>
<a name="line628"></a>  (********************************)
<a name="line629"></a>  (* eliminating select           *)
<a name="line630"></a>  (********************************)
<a name="line631"></a>
<a name="line632"></a>  (* PMATCH leads to selects consisting of
<a name="line633"></a>     conjunctions that determine the value of one
<a name="line634"></a>     component of the variable. An example is
<a name="line635"></a>
<a name="line636"></a>     @x. SND (SND x = ..) /\ (FST x = ..) /\ (FST (SND x) = ..)
<a name="line637"></a>
<a name="line638"></a>     by resorting these conjunctions, one can
<a name="line639"></a>     easily derive a form
<a name="line640"></a>
<a name="line641"></a>     @x. x = ..
<a name="line642"></a>
<a name="line643"></a>     and therefore eliminate the select operator.
<a name="line644"></a>     This is done by the following conversion + ssfrag.
<a name="line645"></a>     These are used internally by the pattern matches
<a name="line646"></a>     infrastructure. *)
<a name="line647"></a>  val ELIM_FST_SND_SELECT_CONV : conv
<a name="line648"></a>  val elim_fst_snd_select_ss : ssfrag
<a name="line649"></a>
<a name="line650"></a>end
<a name="line651"></a>
</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/pattern_matches/patternMatchesLib.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-2</a></em></p></body></html>
