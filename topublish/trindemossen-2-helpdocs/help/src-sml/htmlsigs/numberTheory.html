<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure numberTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure numberTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/algebra/base/.hol/objs/numberScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature numberTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#Euler_def-val">Euler_def</a> : thm
<a name="line7"></a>    val <a href="#GEN_MULT_INV_DEF-val">GEN_MULT_INV_DEF</a> : thm
<a name="line8"></a>    val <a href="#MOD_MULT_INV_DEF-val">MOD_MULT_INV_DEF</a> : thm
<a name="line9"></a>    val <a href="#fequiv_def-val">fequiv_def</a> : thm
<a name="line10"></a>    val <a href="#preimage_def-val">preimage_def</a> : thm
<a name="line11"></a>    val <a href="#residue_def-val">residue_def</a> : thm
<a name="line12"></a>    val <a href="#totient_def-val">totient_def</a> : thm
<a name="line13"></a>  
<a name="line14"></a>  (*  Theorems  *)
<a name="line15"></a>    val <a href="#ADD_EQ_2-val">ADD_EQ_2</a> : thm
<a name="line16"></a>    val <a href="#ADD_SUB_SUB-val">ADD_SUB_SUB</a> : thm
<a name="line17"></a>    val <a href="#ALL_PRIME_FACTORS_MOD_EQ_1-val">ALL_PRIME_FACTORS_MOD_EQ_1</a> : thm
<a name="line18"></a>    val <a href="#AND_IMP_IMP-val">AND_IMP_IMP</a> : thm
<a name="line19"></a>    val <a href="#AND_IMP_OR_NEG-val">AND_IMP_OR_NEG</a> : thm
<a name="line20"></a>    val <a href="#BIGUNION_ELEMENTS_SING-val">BIGUNION_ELEMENTS_SING</a> : thm
<a name="line21"></a>    val <a href="#BIJ_LINV_ELEMENT-val">BIJ_LINV_ELEMENT</a> : thm
<a name="line22"></a>    val <a href="#BIJ_LINV_THM-val">BIJ_LINV_THM</a> : thm
<a name="line23"></a>    val <a href="#BIJ_RINV_BIJ-val">BIJ_RINV_BIJ</a> : thm
<a name="line24"></a>    val <a href="#BIJ_RINV_INV-val">BIJ_RINV_INV</a> : thm
<a name="line25"></a>    val <a href="#BOOL_EQ-val">BOOL_EQ</a> : thm
<a name="line26"></a>    val <a href="#CARD_BIGUNION_PAIR_DISJOINT-val">CARD_BIGUNION_PAIR_DISJOINT</a> : thm
<a name="line27"></a>    val <a href="#CARD_EQ_1-val">CARD_EQ_1</a> : thm
<a name="line28"></a>    val <a href="#CARD_PPOW-val">CARD_PPOW</a> : thm
<a name="line29"></a>    val <a href="#CARD_PPOW_EQN-val">CARD_PPOW_EQN</a> : thm
<a name="line30"></a>    val <a href="#CARD_UNION_3_DISJOINT-val">CARD_UNION_3_DISJOINT</a> : thm
<a name="line31"></a>    val <a href="#CARD_UNION_3_EQN-val">CARD_UNION_3_EQN</a> : thm
<a name="line32"></a>    val <a href="#COUNT_0-val">COUNT_0</a> : thm
<a name="line33"></a>    val <a href="#COUNT_1-val">COUNT_1</a> : thm
<a name="line34"></a>    val <a href="#COUNT_NOT_SELF-val">COUNT_NOT_SELF</a> : thm
<a name="line35"></a>    val <a href="#COUNT_SUBSET-val">COUNT_SUBSET</a> : thm
<a name="line36"></a>    val <a href="#COUNT_SUC_BY_SUC-val">COUNT_SUC_BY_SUC</a> : thm
<a name="line37"></a>    val <a href="#COUNT_SUC_SUBSET-val">COUNT_SUC_SUBSET</a> : thm
<a name="line38"></a>    val <a href="#DIFF_COUNT_SUC-val">DIFF_COUNT_SUC</a> : thm
<a name="line39"></a>    val <a href="#DIFF_DELETE-val">DIFF_DELETE</a> : thm
<a name="line40"></a>    val <a href="#DIFF_DIFF_EQ_INTER-val">DIFF_DIFF_EQ_INTER</a> : thm
<a name="line41"></a>    val <a href="#DISJOINT_DIFF-val">DISJOINT_DIFF</a> : thm
<a name="line42"></a>    val <a href="#DISJOINT_DIFF_IFF-val">DISJOINT_DIFF_IFF</a> : thm
<a name="line43"></a>    val <a href="#DIVIDES_CANCEL-val">DIVIDES_CANCEL</a> : thm
<a name="line44"></a>    val <a href="#DIVIDES_CANCEL_COMM-val">DIVIDES_CANCEL_COMM</a> : thm
<a name="line45"></a>    val <a href="#DIVIDES_COFACTOR-val">DIVIDES_COFACTOR</a> : thm
<a name="line46"></a>    val <a href="#DIVIDES_FACTORS-val">DIVIDES_FACTORS</a> : thm
<a name="line47"></a>    val <a href="#DIVIDES_MOD_MOD-val">DIVIDES_MOD_MOD</a> : thm
<a name="line48"></a>    val <a href="#DIVIDES_MULTIPLE_IFF-val">DIVIDES_MULTIPLE_IFF</a> : thm
<a name="line49"></a>    val <a href="#DIV_COMMON_FACTOR-val">DIV_COMMON_FACTOR</a> : thm
<a name="line50"></a>    val <a href="#DIV_DIV_MULT-val">DIV_DIV_MULT</a> : thm
<a name="line51"></a>    val <a href="#DIV_LT_MONOTONE_REVERSE-val">DIV_LT_MONOTONE_REVERSE</a> : thm
<a name="line52"></a>    val <a href="#DIV_LT_SUC-val">DIV_LT_SUC</a> : thm
<a name="line53"></a>    val <a href="#DIV_MULT_LESS_EQ-val">DIV_MULT_LESS_EQ</a> : thm
<a name="line54"></a>    val <a href="#EQ_IMP2_THM-val">EQ_IMP2_THM</a> : thm
<a name="line55"></a>    val <a href="#EQ_PARITY-val">EQ_PARITY</a> : thm
<a name="line56"></a>    val <a href="#EVEN_0-val">EVEN_0</a> : thm
<a name="line57"></a>    val <a href="#EVEN_2-val">EVEN_2</a> : thm
<a name="line58"></a>    val <a href="#EVEN_HALF-val">EVEN_HALF</a> : thm
<a name="line59"></a>    val <a href="#EVEN_MOD_EVEN-val">EVEN_MOD_EVEN</a> : thm
<a name="line60"></a>    val <a href="#EVEN_MOD_ODD-val">EVEN_MOD_ODD</a> : thm
<a name="line61"></a>    val <a href="#EVEN_ODD_PRE-val">EVEN_ODD_PRE</a> : thm
<a name="line62"></a>    val <a href="#EVEN_ODD_SUC-val">EVEN_ODD_SUC</a> : thm
<a name="line63"></a>    val <a href="#EVEN_PARTNERS-val">EVEN_PARTNERS</a> : thm
<a name="line64"></a>    val <a href="#EVEN_PRIME-val">EVEN_PRIME</a> : thm
<a name="line65"></a>    val <a href="#EVEN_SQ-val">EVEN_SQ</a> : thm
<a name="line66"></a>    val <a href="#EVEN_SUC_HALF-val">EVEN_SUC_HALF</a> : thm
<a name="line67"></a>    val <a href="#EXP_2_EQ_0-val">EXP_2_EQ_0</a> : thm
<a name="line68"></a>    val <a href="#EXP_2_EVEN-val">EXP_2_EVEN</a> : thm
<a name="line69"></a>    val <a href="#EXP_2_HALF-val">EXP_2_HALF</a> : thm
<a name="line70"></a>    val <a href="#EXP_2_PRE_ODD-val">EXP_2_PRE_ODD</a> : thm
<a name="line71"></a>    val <a href="#EXP_ALT_EQN-val">EXP_ALT_EQN</a> : thm
<a name="line72"></a>    val <a href="#EXP_BY_ADD_SUB_LE-val">EXP_BY_ADD_SUB_LE</a> : thm
<a name="line73"></a>    val <a href="#EXP_BY_ADD_SUB_LT-val">EXP_BY_ADD_SUB_LT</a> : thm
<a name="line74"></a>    val <a href="#EXP_EQN-val">EXP_EQN</a> : thm
<a name="line75"></a>    val <a href="#EXP_EQN_ALT-val">EXP_EQN_ALT</a> : thm
<a name="line76"></a>    val <a href="#EXP_EVEN-val">EXP_EVEN</a> : thm
<a name="line77"></a>    val <a href="#EXP_EXP_BASE_LE-val">EXP_EXP_BASE_LE</a> : thm
<a name="line78"></a>    val <a href="#EXP_EXP_LE_MONO_IMP-val">EXP_EXP_LE_MONO_IMP</a> : thm
<a name="line79"></a>    val <a href="#EXP_EXP_SUC-val">EXP_EXP_SUC</a> : thm
<a name="line80"></a>    val <a href="#EXP_LOWER_LE_HIGH-val">EXP_LOWER_LE_HIGH</a> : thm
<a name="line81"></a>    val <a href="#EXP_LOWER_LE_LOW-val">EXP_LOWER_LE_LOW</a> : thm
<a name="line82"></a>    val <a href="#EXP_LOWER_LT_LOW-val">EXP_LOWER_LT_LOW</a> : thm
<a name="line83"></a>    val <a href="#EXP_MOD_ALT-val">EXP_MOD_ALT</a> : thm
<a name="line84"></a>    val <a href="#EXP_MOD_EQN-val">EXP_MOD_EQN</a> : thm
<a name="line85"></a>    val <a href="#EXP_ODD-val">EXP_ODD</a> : thm
<a name="line86"></a>    val <a href="#EXP_SUC_DIV-val">EXP_SUC_DIV</a> : thm
<a name="line87"></a>    val <a href="#EXP_THM-val">EXP_THM</a> : thm
<a name="line88"></a>    val <a href="#Euler_0-val">Euler_0</a> : thm
<a name="line89"></a>    val <a href="#Euler_1-val">Euler_1</a> : thm
<a name="line90"></a>    val <a href="#Euler_card_bounds-val">Euler_card_bounds</a> : thm
<a name="line91"></a>    val <a href="#Euler_card_prime-val">Euler_card_prime</a> : thm
<a name="line92"></a>    val <a href="#Euler_card_upper_le-val">Euler_card_upper_le</a> : thm
<a name="line93"></a>    val <a href="#Euler_card_upper_lt-val">Euler_card_upper_lt</a> : thm
<a name="line94"></a>    val <a href="#Euler_element-val">Euler_element</a> : thm
<a name="line95"></a>    val <a href="#Euler_empty-val">Euler_empty</a> : thm
<a name="line96"></a>    val <a href="#Euler_finite-val">Euler_finite</a> : thm
<a name="line97"></a>    val <a href="#Euler_has_1-val">Euler_has_1</a> : thm
<a name="line98"></a>    val <a href="#Euler_nonempty-val">Euler_nonempty</a> : thm
<a name="line99"></a>    val <a href="#Euler_prime-val">Euler_prime</a> : thm
<a name="line100"></a>    val <a href="#Euler_thm-val">Euler_thm</a> : thm
<a name="line101"></a>    val <a href="#FACTOR_OUT_POWER-val">FACTOR_OUT_POWER</a> : thm
<a name="line102"></a>    val <a href="#FACTOR_OUT_PRIME-val">FACTOR_OUT_PRIME</a> : thm
<a name="line103"></a>    val <a href="#FACT_EQ_PROD-val">FACT_EQ_PROD</a> : thm
<a name="line104"></a>    val <a href="#FACT_REDUCTION-val">FACT_REDUCTION</a> : thm
<a name="line105"></a>    val <a href="#FILTER_element_order-val">FILTER_element_order</a> : thm
<a name="line106"></a>    val <a href="#FINITE_BIJ_COUNT_CARD-val">FINITE_BIJ_COUNT_CARD</a> : thm
<a name="line107"></a>    val <a href="#FINITE_COUNT_IMAGE-val">FINITE_COUNT_IMAGE</a> : thm
<a name="line108"></a>    val <a href="#FINITE_INJ_AS_SURJ-val">FINITE_INJ_AS_SURJ</a> : thm
<a name="line109"></a>    val <a href="#FINITE_INJ_IS_BIJ-val">FINITE_INJ_IS_BIJ</a> : thm
<a name="line110"></a>    val <a href="#FINITE_INJ_IS_SURJ-val">FINITE_INJ_IS_SURJ</a> : thm
<a name="line111"></a>    val <a href="#FINITE_PPOW-val">FINITE_PPOW</a> : thm
<a name="line112"></a>    val <a href="#FINITE_SURJ_IS_INJ-val">FINITE_SURJ_IS_INJ</a> : thm
<a name="line113"></a>    val <a href="#FIVE-val">FIVE</a> : thm
<a name="line114"></a>    val <a href="#FOUR-val">FOUR</a> : thm
<a name="line115"></a>    val <a href="#FUNPOW_ADD1-val">FUNPOW_ADD1</a> : thm
<a name="line116"></a>    val <a href="#FUNPOW_DIV-val">FUNPOW_DIV</a> : thm
<a name="line117"></a>    val <a href="#FUNPOW_EQ_LINV-val">FUNPOW_EQ_LINV</a> : thm
<a name="line118"></a>    val <a href="#FUNPOW_GE_MONO-val">FUNPOW_GE_MONO</a> : thm
<a name="line119"></a>    val <a href="#FUNPOW_LE_FALLING-val">FUNPOW_LE_FALLING</a> : thm
<a name="line120"></a>    val <a href="#FUNPOW_LE_MONO-val">FUNPOW_LE_MONO</a> : thm
<a name="line121"></a>    val <a href="#FUNPOW_LE_RISING-val">FUNPOW_LE_RISING</a> : thm
<a name="line122"></a>    val <a href="#FUNPOW_LINV_EQ-val">FUNPOW_LINV_EQ</a> : thm
<a name="line123"></a>    val <a href="#FUNPOW_LINV_INV-val">FUNPOW_LINV_INV</a> : thm
<a name="line124"></a>    val <a href="#FUNPOW_LINV_SUB1-val">FUNPOW_LINV_SUB1</a> : thm
<a name="line125"></a>    val <a href="#FUNPOW_LINV_SUB2-val">FUNPOW_LINV_SUB2</a> : thm
<a name="line126"></a>    val <a href="#FUNPOW_LINV_closure-val">FUNPOW_LINV_closure</a> : thm
<a name="line127"></a>    val <a href="#FUNPOW_LINV_permutes-val">FUNPOW_LINV_permutes</a> : thm
<a name="line128"></a>    val <a href="#FUNPOW_MAX-val">FUNPOW_MAX</a> : thm
<a name="line129"></a>    val <a href="#FUNPOW_MIN-val">FUNPOW_MIN</a> : thm
<a name="line130"></a>    val <a href="#FUNPOW_MOD-val">FUNPOW_MOD</a> : thm
<a name="line131"></a>    val <a href="#FUNPOW_MUL-val">FUNPOW_MUL</a> : thm
<a name="line132"></a>    val <a href="#FUNPOW_MULTIPLE-val">FUNPOW_MULTIPLE</a> : thm
<a name="line133"></a>    val <a href="#FUNPOW_PAIR-val">FUNPOW_PAIR</a> : thm
<a name="line134"></a>    val <a href="#FUNPOW_SQ-val">FUNPOW_SQ</a> : thm
<a name="line135"></a>    val <a href="#FUNPOW_SQ_MOD-val">FUNPOW_SQ_MOD</a> : thm
<a name="line136"></a>    val <a href="#FUNPOW_SUB1-val">FUNPOW_SUB1</a> : thm
<a name="line137"></a>    val <a href="#FUNPOW_SUB_LINV1-val">FUNPOW_SUB_LINV1</a> : thm
<a name="line138"></a>    val <a href="#FUNPOW_SUB_LINV2-val">FUNPOW_SUB_LINV2</a> : thm
<a name="line139"></a>    val <a href="#FUNPOW_TRIPLE-val">FUNPOW_TRIPLE</a> : thm
<a name="line140"></a>    val <a href="#FUNPOW_closure-val">FUNPOW_closure</a> : thm
<a name="line141"></a>    val <a href="#FUNPOW_permutes-val">FUNPOW_permutes</a> : thm
<a name="line142"></a>    val <a href="#GCD_MOD_MULT_INV-val">GCD_MOD_MULT_INV</a> : thm
<a name="line143"></a>    val <a href="#GCD_SUB_MULTIPLE-val">GCD_SUB_MULTIPLE</a> : thm
<a name="line144"></a>    val <a href="#GCD_SUB_MULTIPLE_COMM-val">GCD_SUB_MULTIPLE_COMM</a> : thm
<a name="line145"></a>    val <a href="#HALF_ADD1_LE-val">HALF_ADD1_LE</a> : thm
<a name="line146"></a>    val <a href="#HALF_ADD1_LT-val">HALF_ADD1_LT</a> : thm
<a name="line147"></a>    val <a href="#HALF_DIV_TWO_POWER-val">HALF_DIV_TWO_POWER</a> : thm
<a name="line148"></a>    val <a href="#HALF_EQ_0-val">HALF_EQ_0</a> : thm
<a name="line149"></a>    val <a href="#HALF_EQ_SELF-val">HALF_EQ_SELF</a> : thm
<a name="line150"></a>    val <a href="#HALF_EVEN_LE-val">HALF_EVEN_LE</a> : thm
<a name="line151"></a>    val <a href="#HALF_EXP_5-val">HALF_EXP_5</a> : thm
<a name="line152"></a>    val <a href="#HALF_LE-val">HALF_LE</a> : thm
<a name="line153"></a>    val <a href="#HALF_LE_MONO-val">HALF_LE_MONO</a> : thm
<a name="line154"></a>    val <a href="#HALF_LT-val">HALF_LT</a> : thm
<a name="line155"></a>    val <a href="#HALF_MULT-val">HALF_MULT</a> : thm
<a name="line156"></a>    val <a href="#HALF_MULT_EVEN-val">HALF_MULT_EVEN</a> : thm
<a name="line157"></a>    val <a href="#HALF_ODD_LT-val">HALF_ODD_LT</a> : thm
<a name="line158"></a>    val <a href="#HALF_SQ_LE-val">HALF_SQ_LE</a> : thm
<a name="line159"></a>    val <a href="#HALF_SUC-val">HALF_SUC</a> : thm
<a name="line160"></a>    val <a href="#HALF_SUC_LE-val">HALF_SUC_LE</a> : thm
<a name="line161"></a>    val <a href="#HALF_SUC_SUC-val">HALF_SUC_SUC</a> : thm
<a name="line162"></a>    val <a href="#HALF_TWICE-val">HALF_TWICE</a> : thm
<a name="line163"></a>    val <a href="#IMAGE_COUNT_SUC-val">IMAGE_COUNT_SUC</a> : thm
<a name="line164"></a>    val <a href="#IMAGE_COUNT_SUC_BY_SUC-val">IMAGE_COUNT_SUC_BY_SUC</a> : thm
<a name="line165"></a>    val <a href="#IMAGE_DIFF-val">IMAGE_DIFF</a> : thm
<a name="line166"></a>    val <a href="#IMAGE_ELEMENT_CONDITION-val">IMAGE_ELEMENT_CONDITION</a> : thm
<a name="line167"></a>    val <a href="#IMAGE_K-val">IMAGE_K</a> : thm
<a name="line168"></a>    val <a href="#IMAGE_SUBSET_TARGET-val">IMAGE_SUBSET_TARGET</a> : thm
<a name="line169"></a>    val <a href="#INJ_CARD_IMAGE_EQN-val">INJ_CARD_IMAGE_EQN</a> : thm
<a name="line170"></a>    val <a href="#INJ_IMAGE_BIJ_ALT-val">INJ_IMAGE_BIJ_ALT</a> : thm
<a name="line171"></a>    val <a href="#INJ_UNIV-val">INJ_UNIV</a> : thm
<a name="line172"></a>    val <a href="#INSERT_DELETE_COMM-val">INSERT_DELETE_COMM</a> : thm
<a name="line173"></a>    val <a href="#INSERT_DELETE_NON_ELEMENT-val">INSERT_DELETE_NON_ELEMENT</a> : thm
<a name="line174"></a>    val <a href="#INSERT_SUBSET_SUBSET-val">INSERT_SUBSET_SUBSET</a> : thm
<a name="line175"></a>    val <a href="#INTER_DIFF-val">INTER_DIFF</a> : thm
<a name="line176"></a>    val <a href="#IN_PPOW-val">IN_PPOW</a> : thm
<a name="line177"></a>    val <a href="#IN_SING_OR_EMPTY-val">IN_SING_OR_EMPTY</a> : thm
<a name="line178"></a>    val <a href="#LCM_EXCHANGE-val">LCM_EXCHANGE</a> : thm
<a name="line179"></a>    val <a href="#LESS_HALF_IFF-val">LESS_HALF_IFF</a> : thm
<a name="line180"></a>    val <a href="#LESS_SUC-val">LESS_SUC</a> : thm
<a name="line181"></a>    val <a href="#LE_IMP_REVERSE_LT-val">LE_IMP_REVERSE_LT</a> : thm
<a name="line182"></a>    val <a href="#LE_MONO_ADD2-val">LE_MONO_ADD2</a> : thm
<a name="line183"></a>    val <a href="#LE_MONO_MULT2-val">LE_MONO_MULT2</a> : thm
<a name="line184"></a>    val <a href="#LE_MULT_LCANCEL_IMP-val">LE_MULT_LCANCEL_IMP</a> : thm
<a name="line185"></a>    val <a href="#LE_ONE-val">LE_ONE</a> : thm
<a name="line186"></a>    val <a href="#LE_TWICE_ALT-val">LE_TWICE_ALT</a> : thm
<a name="line187"></a>    val <a href="#LINV_SUBSET-val">LINV_SUBSET</a> : thm
<a name="line188"></a>    val <a href="#LINV_permutes-val">LINV_permutes</a> : thm
<a name="line189"></a>    val <a href="#LT_MONO_ADD2-val">LT_MONO_ADD2</a> : thm
<a name="line190"></a>    val <a href="#LT_MONO_MULT2-val">LT_MONO_MULT2</a> : thm
<a name="line191"></a>    val <a href="#MAX_1_EXP-val">MAX_1_EXP</a> : thm
<a name="line192"></a>    val <a href="#MAX_1_POS-val">MAX_1_POS</a> : thm
<a name="line193"></a>    val <a href="#MAX_ADD-val">MAX_ADD</a> : thm
<a name="line194"></a>    val <a href="#MAX_ALT-val">MAX_ALT</a> : thm
<a name="line195"></a>    val <a href="#MAX_ID-val">MAX_ID</a> : thm
<a name="line196"></a>    val <a href="#MAX_IS_MAX-val">MAX_IS_MAX</a> : thm
<a name="line197"></a>    val <a href="#MAX_LESS-val">MAX_LESS</a> : thm
<a name="line198"></a>    val <a href="#MAX_LE_PAIR-val">MAX_LE_PAIR</a> : thm
<a name="line199"></a>    val <a href="#MAX_LE_SUM-val">MAX_LE_SUM</a> : thm
<a name="line200"></a>    val <a href="#MAX_SET_DELETE-val">MAX_SET_DELETE</a> : thm
<a name="line201"></a>    val <a href="#MAX_SET_IMAGE_SUC_COUNT-val">MAX_SET_IMAGE_SUC_COUNT</a> : thm
<a name="line202"></a>    val <a href="#MAX_SET_IMAGE_with_DEC-val">MAX_SET_IMAGE_with_DEC</a> : thm
<a name="line203"></a>    val <a href="#MAX_SET_IMAGE_with_DIV-val">MAX_SET_IMAGE_with_DIV</a> : thm
<a name="line204"></a>    val <a href="#MAX_SET_IMAGE_with_HALF-val">MAX_SET_IMAGE_with_HALF</a> : thm
<a name="line205"></a>    val <a href="#MAX_SUC-val">MAX_SUC</a> : thm
<a name="line206"></a>    val <a href="#MAX_SWAP-val">MAX_SWAP</a> : thm
<a name="line207"></a>    val <a href="#MIN_1_EXP-val">MIN_1_EXP</a> : thm
<a name="line208"></a>    val <a href="#MIN_1_POS-val">MIN_1_POS</a> : thm
<a name="line209"></a>    val <a href="#MIN_ADD-val">MIN_ADD</a> : thm
<a name="line210"></a>    val <a href="#MIN_ALT-val">MIN_ALT</a> : thm
<a name="line211"></a>    val <a href="#MIN_ID-val">MIN_ID</a> : thm
<a name="line212"></a>    val <a href="#MIN_IS_MIN-val">MIN_IS_MIN</a> : thm
<a name="line213"></a>    val <a href="#MIN_LE_PAIR-val">MIN_LE_PAIR</a> : thm
<a name="line214"></a>    val <a href="#MIN_LE_SUM-val">MIN_LE_SUM</a> : thm
<a name="line215"></a>    val <a href="#MIN_SUC-val">MIN_SUC</a> : thm
<a name="line216"></a>    val <a href="#MIN_SWAP-val">MIN_SWAP</a> : thm
<a name="line217"></a>    val <a href="#MOD_MULT_INV_EXISTS-val">MOD_MULT_INV_EXISTS</a> : thm
<a name="line218"></a>    val <a href="#MOD_MULT_LCANCEL-val">MOD_MULT_LCANCEL</a> : thm
<a name="line219"></a>    val <a href="#MOD_MULT_RCANCEL-val">MOD_MULT_RCANCEL</a> : thm
<a name="line220"></a>    val <a href="#MOD_SUC_EQN-val">MOD_SUC_EQN</a> : thm
<a name="line221"></a>    val <a href="#MONOTONE_MAX-val">MONOTONE_MAX</a> : thm
<a name="line222"></a>    val <a href="#MORE_HALF_IMP-val">MORE_HALF_IMP</a> : thm
<a name="line223"></a>    val <a href="#MULT3_EQ_0-val">MULT3_EQ_0</a> : thm
<a name="line224"></a>    val <a href="#MULT3_EQ_1-val">MULT3_EQ_1</a> : thm
<a name="line225"></a>    val <a href="#MULTIPLE_INTERVAL-val">MULTIPLE_INTERVAL</a> : thm
<a name="line226"></a>    val <a href="#MULTIPLE_SUC_LE-val">MULTIPLE_SUC_LE</a> : thm
<a name="line227"></a>    val <a href="#MULTIPLY_DIV-val">MULTIPLY_DIV</a> : thm
<a name="line228"></a>    val <a href="#MULT_EQ_LESS_TO_MORE-val">MULT_EQ_LESS_TO_MORE</a> : thm
<a name="line229"></a>    val <a href="#MULT_EVEN-val">MULT_EVEN</a> : thm
<a name="line230"></a>    val <a href="#MULT_LE_IMP_LE-val">MULT_LE_IMP_LE</a> : thm
<a name="line231"></a>    val <a href="#MULT_LT_IMP_LT-val">MULT_LT_IMP_LT</a> : thm
<a name="line232"></a>    val <a href="#MULT_ODD-val">MULT_ODD</a> : thm
<a name="line233"></a>    val <a href="#NOT_LT_ONE-val">NOT_LT_ONE</a> : thm
<a name="line234"></a>    val <a href="#NOT_PRIME_4-val">NOT_PRIME_4</a> : thm
<a name="line235"></a>    val <a href="#NOT_ZERO_GE_ONE-val">NOT_ZERO_GE_ONE</a> : thm
<a name="line236"></a>    val <a href="#ODD_1-val">ODD_1</a> : thm
<a name="line237"></a>    val <a href="#ODD_EXP-val">ODD_EXP</a> : thm
<a name="line238"></a>    val <a href="#ODD_HALF-val">ODD_HALF</a> : thm
<a name="line239"></a>    val <a href="#ODD_MOD2-val">ODD_MOD2</a> : thm
<a name="line240"></a>    val <a href="#ODD_PRIME-val">ODD_PRIME</a> : thm
<a name="line241"></a>    val <a href="#ODD_SQ-val">ODD_SQ</a> : thm
<a name="line242"></a>    val <a href="#ODD_SUC_HALF-val">ODD_SUC_HALF</a> : thm
<a name="line243"></a>    val <a href="#ONE_LT_HALF_SQ-val">ONE_LT_HALF_SQ</a> : thm
<a name="line244"></a>    val <a href="#ONE_LT_NONZERO-val">ONE_LT_NONZERO</a> : thm
<a name="line245"></a>    val <a href="#ONE_LT_POS-val">ONE_LT_POS</a> : thm
<a name="line246"></a>    val <a href="#ONE_NOT_0-val">ONE_NOT_0</a> : thm
<a name="line247"></a>    val <a href="#ONE_NOT_ZERO-val">ONE_NOT_ZERO</a> : thm
<a name="line248"></a>    val <a href="#OR_IMP_IMP-val">OR_IMP_IMP</a> : thm
<a name="line249"></a>    val <a href="#POWER_EQ_SELF-val">POWER_EQ_SELF</a> : thm
<a name="line250"></a>    val <a href="#PRE_LESS-val">PRE_LESS</a> : thm
<a name="line251"></a>    val <a href="#PRIME_EXP_FACTOR-val">PRIME_EXP_FACTOR</a> : thm
<a name="line252"></a>    val <a href="#PRIME_FACTOR_PROPER-val">PRIME_FACTOR_PROPER</a> : thm
<a name="line253"></a>    val <a href="#PROD_SET_DIVISORS-val">PROD_SET_DIVISORS</a> : thm
<a name="line254"></a>    val <a href="#PROD_SET_ELEMENT_DIVIDES-val">PROD_SET_ELEMENT_DIVIDES</a> : thm
<a name="line255"></a>    val <a href="#PROD_SET_EUCLID-val">PROD_SET_EUCLID</a> : thm
<a name="line256"></a>    val <a href="#PROD_SET_IMAGE_EQN-val">PROD_SET_IMAGE_EQN</a> : thm
<a name="line257"></a>    val <a href="#PROD_SET_IMAGE_EXP-val">PROD_SET_IMAGE_EXP</a> : thm
<a name="line258"></a>    val <a href="#PROD_SET_IMAGE_EXP_NONZERO-val">PROD_SET_IMAGE_EXP_NONZERO</a> : thm
<a name="line259"></a>    val <a href="#PROD_SET_LESS-val">PROD_SET_LESS</a> : thm
<a name="line260"></a>    val <a href="#PROD_SET_LESS_EQ-val">PROD_SET_LESS_EQ</a> : thm
<a name="line261"></a>    val <a href="#PROD_SET_LESS_SUC-val">PROD_SET_LESS_SUC</a> : thm
<a name="line262"></a>    val <a href="#PROD_SET_LE_CONSTANT-val">PROD_SET_LE_CONSTANT</a> : thm
<a name="line263"></a>    val <a href="#PROD_SET_NONZERO-val">PROD_SET_NONZERO</a> : thm
<a name="line264"></a>    val <a href="#PROD_SET_PRODUCT_BY_PARTITION-val">PROD_SET_PRODUCT_BY_PARTITION</a> : thm
<a name="line265"></a>    val <a href="#PROD_SET_PRODUCT_GE_CONSTANT-val">PROD_SET_PRODUCT_GE_CONSTANT</a> : thm
<a name="line266"></a>    val <a href="#PROD_SET_SING-val">PROD_SET_SING</a> : thm
<a name="line267"></a>    val <a href="#PUSH_IN_INTO_IF-val">PUSH_IN_INTO_IF</a> : thm
<a name="line268"></a>    val <a href="#SELF_LE_SQ-val">SELF_LE_SQ</a> : thm
<a name="line269"></a>    val <a href="#SET_EQ_BY_DIFF-val">SET_EQ_BY_DIFF</a> : thm
<a name="line270"></a>    val <a href="#SIGMA_CARD_FACTOR-val">SIGMA_CARD_FACTOR</a> : thm
<a name="line271"></a>    val <a href="#SING_SUBSET-val">SING_SUBSET</a> : thm
<a name="line272"></a>    val <a href="#SPLIT_BY_SUBSET-val">SPLIT_BY_SUBSET</a> : thm
<a name="line273"></a>    val <a href="#SPLIT_CARD-val">SPLIT_CARD</a> : thm
<a name="line274"></a>    val <a href="#SPLIT_EMPTY-val">SPLIT_EMPTY</a> : thm
<a name="line275"></a>    val <a href="#SPLIT_EQ-val">SPLIT_EQ</a> : thm
<a name="line276"></a>    val <a href="#SPLIT_EQ_DIFF-val">SPLIT_EQ_DIFF</a> : thm
<a name="line277"></a>    val <a href="#SPLIT_FINITE-val">SPLIT_FINITE</a> : thm
<a name="line278"></a>    val <a href="#SPLIT_SING-val">SPLIT_SING</a> : thm
<a name="line279"></a>    val <a href="#SPLIT_SUBSETS-val">SPLIT_SUBSETS</a> : thm
<a name="line280"></a>    val <a href="#SPLIT_SYM-val">SPLIT_SYM</a> : thm
<a name="line281"></a>    val <a href="#SPLIT_SYM_IMP-val">SPLIT_SYM_IMP</a> : thm
<a name="line282"></a>    val <a href="#SPLIT_UNION-val">SPLIT_UNION</a> : thm
<a name="line283"></a>    val <a href="#SQ_0-val">SQ_0</a> : thm
<a name="line284"></a>    val <a href="#SQ_EQ_0-val">SQ_EQ_0</a> : thm
<a name="line285"></a>    val <a href="#SQ_EQ_1-val">SQ_EQ_1</a> : thm
<a name="line286"></a>    val <a href="#SQ_EQ_SELF-val">SQ_EQ_SELF</a> : thm
<a name="line287"></a>    val <a href="#SQ_LE-val">SQ_LE</a> : thm
<a name="line288"></a>    val <a href="#SUBSET_CARD_EQ-val">SUBSET_CARD_EQ</a> : thm
<a name="line289"></a>    val <a href="#SUBSET_DIFF_CARD-val">SUBSET_DIFF_CARD</a> : thm
<a name="line290"></a>    val <a href="#SUBSET_DIFF_DIFF-val">SUBSET_DIFF_DIFF</a> : thm
<a name="line291"></a>    val <a href="#SUBSET_DIFF_EQ-val">SUBSET_DIFF_EQ</a> : thm
<a name="line292"></a>    val <a href="#SUBSET_INSERT_BOTH-val">SUBSET_INSERT_BOTH</a> : thm
<a name="line293"></a>    val <a href="#SUBSET_INTER_SUBSET-val">SUBSET_INTER_SUBSET</a> : thm
<a name="line294"></a>    val <a href="#SUBSET_SING_IFF-val">SUBSET_SING_IFF</a> : thm
<a name="line295"></a>    val <a href="#SUB_DIV_EQN-val">SUB_DIV_EQN</a> : thm
<a name="line296"></a>    val <a href="#SUB_EQ_ADD-val">SUB_EQ_ADD</a> : thm
<a name="line297"></a>    val <a href="#SUB_MOD_EQN-val">SUB_MOD_EQN</a> : thm
<a name="line298"></a>    val <a href="#SUB_SUB_SUB-val">SUB_SUB_SUB</a> : thm
<a name="line299"></a>    val <a href="#SUC_ADD_SUC-val">SUC_ADD_SUC</a> : thm
<a name="line300"></a>    val <a href="#SUC_EQ-val">SUC_EQ</a> : thm
<a name="line301"></a>    val <a href="#SUC_EXISTS-val">SUC_EXISTS</a> : thm
<a name="line302"></a>    val <a href="#SUC_MAX-val">SUC_MAX</a> : thm
<a name="line303"></a>    val <a href="#SUC_MIN-val">SUC_MIN</a> : thm
<a name="line304"></a>    val <a href="#SUC_MULT_SUC-val">SUC_MULT_SUC</a> : thm
<a name="line305"></a>    val <a href="#SUC_SQ-val">SUC_SQ</a> : thm
<a name="line306"></a>    val <a href="#SUC_X_LT_2_EXP_X-val">SUC_X_LT_2_EXP_X</a> : thm
<a name="line307"></a>    val <a href="#SUM_IMAGE_AS_SUM_SET-val">SUM_IMAGE_AS_SUM_SET</a> : thm
<a name="line308"></a>    val <a href="#SUM_IMAGE_DOUBLET-val">SUM_IMAGE_DOUBLET</a> : thm
<a name="line309"></a>    val <a href="#SUM_IMAGE_PSUBSET_LT-val">SUM_IMAGE_PSUBSET_LT</a> : thm
<a name="line310"></a>    val <a href="#SUM_IMAGE_TRIPLET-val">SUM_IMAGE_TRIPLET</a> : thm
<a name="line311"></a>    val <a href="#SUM_LE_PRODUCT-val">SUM_LE_PRODUCT</a> : thm
<a name="line312"></a>    val <a href="#SUM_SET_COUNT-val">SUM_SET_COUNT</a> : thm
<a name="line313"></a>    val <a href="#SUM_SET_IMAGE_EQN-val">SUM_SET_IMAGE_EQN</a> : thm
<a name="line314"></a>    val <a href="#SURJ_CARD_IMAGE-val">SURJ_CARD_IMAGE</a> : thm
<a name="line315"></a>    val <a href="#THREE-val">THREE</a> : thm
<a name="line316"></a>    val <a href="#TWICE_EQ_0-val">TWICE_EQ_0</a> : thm
<a name="line317"></a>    val <a href="#TWO_HALF_LE_THM-val">TWO_HALF_LE_THM</a> : thm
<a name="line318"></a>    val <a href="#TWO_HALF_TIMES_LE-val">TWO_HALF_TIMES_LE</a> : thm
<a name="line319"></a>    val <a href="#TWO_LE_PRIME-val">TWO_LE_PRIME</a> : thm
<a name="line320"></a>    val <a href="#UNION_DIFF_EQ_UNION-val">UNION_DIFF_EQ_UNION</a> : thm
<a name="line321"></a>    val <a href="#ZERO_LE_ALL-val">ZERO_LE_ALL</a> : thm
<a name="line322"></a>    val <a href="#binomial_2-val">binomial_2</a> : thm
<a name="line323"></a>    val <a href="#binomial_add-val">binomial_add</a> : thm
<a name="line324"></a>    val <a href="#binomial_means-val">binomial_means</a> : thm
<a name="line325"></a>    val <a href="#binomial_sub-val">binomial_sub</a> : thm
<a name="line326"></a>    val <a href="#binomial_sub_add-val">binomial_sub_add</a> : thm
<a name="line327"></a>    val <a href="#binomial_sub_sum-val">binomial_sub_sum</a> : thm
<a name="line328"></a>    val <a href="#card_eq_sigma_card-val">card_eq_sigma_card</a> : thm
<a name="line329"></a>    val <a href="#card_le_sigma_card-val">card_le_sigma_card</a> : thm
<a name="line330"></a>    val <a href="#card_mod_image-val">card_mod_image</a> : thm
<a name="line331"></a>    val <a href="#card_mod_image_nonzero-val">card_mod_image_nonzero</a> : thm
<a name="line332"></a>    val <a href="#coprime_all_le_imp_lt-val">coprime_all_le_imp_lt</a> : thm
<a name="line333"></a>    val <a href="#coprime_by_le_not_divides-val">coprime_by_le_not_divides</a> : thm
<a name="line334"></a>    val <a href="#coprime_condition-val">coprime_condition</a> : thm
<a name="line335"></a>    val <a href="#coprime_iff_coprime_exp-val">coprime_iff_coprime_exp</a> : thm
<a name="line336"></a>    val <a href="#coprime_linear_mod_prod-val">coprime_linear_mod_prod</a> : thm
<a name="line337"></a>    val <a href="#coprime_linear_mult-val">coprime_linear_mult</a> : thm
<a name="line338"></a>    val <a href="#coprime_linear_mult_iff-val">coprime_linear_mult_iff</a> : thm
<a name="line339"></a>    val <a href="#coprime_mod_mod_prod_eq-val">coprime_mod_mod_prod_eq</a> : thm
<a name="line340"></a>    val <a href="#coprime_mod_mod_prod_eq_iff-val">coprime_mod_mod_prod_eq_iff</a> : thm
<a name="line341"></a>    val <a href="#coprime_mod_mod_solve-val">coprime_mod_mod_solve</a> : thm
<a name="line342"></a>    val <a href="#coprime_multiple_linear_mod_prod-val">coprime_multiple_linear_mod_prod</a> : thm
<a name="line343"></a>    val <a href="#coprime_not_divides-val">coprime_not_divides</a> : thm
<a name="line344"></a>    val <a href="#coprime_power_and_power_predecessor-val">coprime_power_and_power_predecessor</a> : thm
<a name="line345"></a>    val <a href="#coprime_power_and_power_successor-val">coprime_power_and_power_successor</a> : thm
<a name="line346"></a>    val <a href="#coprime_prime_power-val">coprime_prime_power</a> : thm
<a name="line347"></a>    val <a href="#countFrom_0-val">countFrom_0</a> : thm
<a name="line348"></a>    val <a href="#countFrom_SUC-val">countFrom_SUC</a> : thm
<a name="line349"></a>    val <a href="#countFrom_first-val">countFrom_first</a> : thm
<a name="line350"></a>    val <a href="#countFrom_less-val">countFrom_less</a> : thm
<a name="line351"></a>    val <a href="#count_SUC_by_countFrom-val">count_SUC_by_countFrom</a> : thm
<a name="line352"></a>    val <a href="#count_by_countFrom-val">count_by_countFrom</a> : thm
<a name="line353"></a>    val <a href="#difference_of_squares-val">difference_of_squares</a> : thm
<a name="line354"></a>    val <a href="#difference_of_squares_alt-val">difference_of_squares_alt</a> : thm
<a name="line355"></a>    val <a href="#disjoint_bigunion_add_fun-val">disjoint_bigunion_add_fun</a> : thm
<a name="line356"></a>    val <a href="#disjoint_bigunion_card-val">disjoint_bigunion_card</a> : thm
<a name="line357"></a>    val <a href="#disjoint_bigunion_mult_fun-val">disjoint_bigunion_mult_fun</a> : thm
<a name="line358"></a>    val <a href="#disjoint_bigunion_sigma-val">disjoint_bigunion_sigma</a> : thm
<a name="line359"></a>    val <a href="#dividend_divides_divisor_multiple-val">dividend_divides_divisor_multiple</a> : thm
<a name="line360"></a>    val <a href="#divides_eq_thm-val">divides_eq_thm</a> : thm
<a name="line361"></a>    val <a href="#divides_iff_equal-val">divides_iff_equal</a> : thm
<a name="line362"></a>    val <a href="#divides_self_power-val">divides_self_power</a> : thm
<a name="line363"></a>    val <a href="#equal_partition_card-val">equal_partition_card</a> : thm
<a name="line364"></a>    val <a href="#equal_partition_factor-val">equal_partition_factor</a> : thm
<a name="line365"></a>    val <a href="#equiv_class_element-val">equiv_class_element</a> : thm
<a name="line366"></a>    val <a href="#equiv_class_not_empty-val">equiv_class_not_empty</a> : thm
<a name="line367"></a>    val <a href="#euclid_coprime-val">euclid_coprime</a> : thm
<a name="line368"></a>    val <a href="#euclid_prime-val">euclid_prime</a> : thm
<a name="line369"></a>    val <a href="#every_coprime_prod_set_coprime-val">every_coprime_prod_set_coprime</a> : thm
<a name="line370"></a>    val <a href="#factor_eq_cofactor-val">factor_eq_cofactor</a> : thm
<a name="line371"></a>    val <a href="#factor_partition_card-val">factor_partition_card</a> : thm
<a name="line372"></a>    val <a href="#feq_class_element-val">feq_class_element</a> : thm
<a name="line373"></a>    val <a href="#feq_class_fun-val">feq_class_fun</a> : thm
<a name="line374"></a>    val <a href="#feq_class_property-val">feq_class_property</a> : thm
<a name="line375"></a>    val <a href="#feq_equiv-val">feq_equiv</a> : thm
<a name="line376"></a>    val <a href="#feq_partition-val">feq_partition</a> : thm
<a name="line377"></a>    val <a href="#feq_partition_element-val">feq_partition_element</a> : thm
<a name="line378"></a>    val <a href="#feq_partition_element_exists-val">feq_partition_element_exists</a> : thm
<a name="line379"></a>    val <a href="#feq_partition_element_not_empty-val">feq_partition_element_not_empty</a> : thm
<a name="line380"></a>    val <a href="#feq_sum_over_partition-val">feq_sum_over_partition</a> : thm
<a name="line381"></a>    val <a href="#fequiv_equiv_class-val">fequiv_equiv_class</a> : thm
<a name="line382"></a>    val <a href="#fequiv_refl-val">fequiv_refl</a> : thm
<a name="line383"></a>    val <a href="#fequiv_sym-val">fequiv_sym</a> : thm
<a name="line384"></a>    val <a href="#fequiv_trans-val">fequiv_trans</a> : thm
<a name="line385"></a>    val <a href="#finite_card_by_feq_partition-val">finite_card_by_feq_partition</a> : thm
<a name="line386"></a>    val <a href="#finite_card_by_image_preimage-val">finite_card_by_image_preimage</a> : thm
<a name="line387"></a>    val <a href="#finite_card_surj_by_image_preimage-val">finite_card_surj_by_image_preimage</a> : thm
<a name="line388"></a>    val <a href="#finite_partition_by_predicate-val">finite_partition_by_predicate</a> : thm
<a name="line389"></a>    val <a href="#finite_partition_property-val">finite_partition_property</a> : thm
<a name="line390"></a>    val <a href="#fit_for_10-val">fit_for_10</a> : thm
<a name="line391"></a>    val <a href="#fit_for_100-val">fit_for_100</a> : thm
<a name="line392"></a>    val <a href="#gcd_divides_iff-val">gcd_divides_iff</a> : thm
<a name="line393"></a>    val <a href="#gcd_le-val">gcd_le</a> : thm
<a name="line394"></a>    val <a href="#gcd_linear_mod_1-val">gcd_linear_mod_1</a> : thm
<a name="line395"></a>    val <a href="#gcd_linear_mod_2-val">gcd_linear_mod_2</a> : thm
<a name="line396"></a>    val <a href="#gcd_linear_mod_prod-val">gcd_linear_mod_prod</a> : thm
<a name="line397"></a>    val <a href="#gcd_linear_mod_thm-val">gcd_linear_mod_thm</a> : thm
<a name="line398"></a>    val <a href="#gcd_linear_thm-val">gcd_linear_thm</a> : thm
<a name="line399"></a>    val <a href="#gcd_multiple_linear_mod_prod-val">gcd_multiple_linear_mod_prod</a> : thm
<a name="line400"></a>    val <a href="#gcd_multiple_linear_mod_thm-val">gcd_multiple_linear_mod_thm</a> : thm
<a name="line401"></a>    val <a href="#gcd_powers-val">gcd_powers</a> : thm
<a name="line402"></a>    val <a href="#image_mod_subset_count-val">image_mod_subset_count</a> : thm
<a name="line403"></a>    val <a href="#in_preimage-val">in_preimage</a> : thm
<a name="line404"></a>    val <a href="#in_prime-val">in_prime</a> : thm
<a name="line405"></a>    val <a href="#inj_iff_partition_element_card_1-val">inj_iff_partition_element_card_1</a> : thm
<a name="line406"></a>    val <a href="#inj_iff_partition_element_sing-val">inj_iff_partition_element_sing</a> : thm
<a name="line407"></a>    val <a href="#lcm_powers-val">lcm_powers</a> : thm
<a name="line408"></a>    val <a href="#listRangeINC_sublist-val">listRangeINC_sublist</a> : thm
<a name="line409"></a>    val <a href="#listRangeLHI_sublist-val">listRangeLHI_sublist</a> : thm
<a name="line410"></a>    val <a href="#mod_add_eq_sub-val">mod_add_eq_sub</a> : thm
<a name="line411"></a>    val <a href="#mod_add_eq_sub_eq-val">mod_add_eq_sub_eq</a> : thm
<a name="line412"></a>    val <a href="#mod_divides-val">mod_divides</a> : thm
<a name="line413"></a>    val <a href="#mod_divides_divides-val">mod_divides_divides</a> : thm
<a name="line414"></a>    val <a href="#mod_divides_divides_iff-val">mod_divides_divides_iff</a> : thm
<a name="line415"></a>    val <a href="#mod_divides_iff-val">mod_divides_iff</a> : thm
<a name="line416"></a>    val <a href="#mod_eq_divides-val">mod_eq_divides</a> : thm
<a name="line417"></a>    val <a href="#mod_eq_divides_iff-val">mod_eq_divides_iff</a> : thm
<a name="line418"></a>    val <a href="#mod_mod_prod_eq-val">mod_mod_prod_eq</a> : thm
<a name="line419"></a>    val <a href="#mod_mult_eq_mult-val">mod_mult_eq_mult</a> : thm
<a name="line420"></a>    val <a href="#natural_by_upto-val">natural_by_upto</a> : thm
<a name="line421"></a>    val <a href="#natural_thm-val">natural_thm</a> : thm
<a name="line422"></a>    val <a href="#nines_divisibility-val">nines_divisibility</a> : thm
<a name="line423"></a>    val <a href="#nines_division_alt-val">nines_division_alt</a> : thm
<a name="line424"></a>    val <a href="#nines_division_eqn-val">nines_division_eqn</a> : thm
<a name="line425"></a>    val <a href="#nines_divisor-val">nines_divisor</a> : thm
<a name="line426"></a>    val <a href="#nines_gcd_identity-val">nines_gcd_identity</a> : thm
<a name="line427"></a>    val <a href="#nines_gcd_reduction-val">nines_gcd_reduction</a> : thm
<a name="line428"></a>    val <a href="#pair_disjoint_subset-val">pair_disjoint_subset</a> : thm
<a name="line429"></a>    val <a href="#pairwise_coprime_insert-val">pairwise_coprime_insert</a> : thm
<a name="line430"></a>    val <a href="#pairwise_coprime_partition_coprime-val">pairwise_coprime_partition_coprime</a> : thm
<a name="line431"></a>    val <a href="#pairwise_coprime_prod_set_partition-val">pairwise_coprime_prod_set_partition</a> : thm
<a name="line432"></a>    val <a href="#pairwise_coprime_prod_set_subset_divides-val">pairwise_coprime_prod_set_subset_divides</a> : thm
<a name="line433"></a>    val <a href="#partition_as_image-val">partition_as_image</a> : thm
<a name="line434"></a>    val <a href="#partition_by_element-val">partition_by_element</a> : thm
<a name="line435"></a>    val <a href="#partition_by_subset-val">partition_by_subset</a> : thm
<a name="line436"></a>    val <a href="#partition_cong-val">partition_cong</a> : thm
<a name="line437"></a>    val <a href="#partition_element-val">partition_element</a> : thm
<a name="line438"></a>    val <a href="#partition_element_exists-val">partition_element_exists</a> : thm
<a name="line439"></a>    val <a href="#partition_element_not_empty-val">partition_element_not_empty</a> : thm
<a name="line440"></a>    val <a href="#partition_elements-val">partition_elements</a> : thm
<a name="line441"></a>    val <a href="#partition_on_empty-val">partition_on_empty</a> : thm
<a name="line442"></a>    val <a href="#power_divides_iff-val">power_divides_iff</a> : thm
<a name="line443"></a>    val <a href="#power_eq_prime_power-val">power_eq_prime_power</a> : thm
<a name="line444"></a>    val <a href="#power_parity-val">power_parity</a> : thm
<a name="line445"></a>    val <a href="#power_predecessor_divisibility-val">power_predecessor_divisibility</a> : thm
<a name="line446"></a>    val <a href="#power_predecessor_division_alt-val">power_predecessor_division_alt</a> : thm
<a name="line447"></a>    val <a href="#power_predecessor_division_eqn-val">power_predecessor_division_eqn</a> : thm
<a name="line448"></a>    val <a href="#power_predecessor_divisor-val">power_predecessor_divisor</a> : thm
<a name="line449"></a>    val <a href="#power_predecessor_gcd_identity-val">power_predecessor_gcd_identity</a> : thm
<a name="line450"></a>    val <a href="#power_predecessor_gcd_reduction-val">power_predecessor_gcd_reduction</a> : thm
<a name="line451"></a>    val <a href="#preimage_alt-val">preimage_alt</a> : thm
<a name="line452"></a>    val <a href="#preimage_choice_property-val">preimage_choice_property</a> : thm
<a name="line453"></a>    val <a href="#preimage_element-val">preimage_element</a> : thm
<a name="line454"></a>    val <a href="#preimage_finite-val">preimage_finite</a> : thm
<a name="line455"></a>    val <a href="#preimage_image_bij-val">preimage_image_bij</a> : thm
<a name="line456"></a>    val <a href="#preimage_image_inj-val">preimage_image_inj</a> : thm
<a name="line457"></a>    val <a href="#preimage_inj-val">preimage_inj</a> : thm
<a name="line458"></a>    val <a href="#preimage_inj_choice-val">preimage_inj_choice</a> : thm
<a name="line459"></a>    val <a href="#preimage_of_image-val">preimage_of_image</a> : thm
<a name="line460"></a>    val <a href="#preimage_property-val">preimage_property</a> : thm
<a name="line461"></a>    val <a href="#preimage_subset-val">preimage_subset</a> : thm
<a name="line462"></a>    val <a href="#prime_coprime_all_less-val">prime_coprime_all_less</a> : thm
<a name="line463"></a>    val <a href="#prime_coprime_all_lt-val">prime_coprime_all_lt</a> : thm
<a name="line464"></a>    val <a href="#prime_divides_power-val">prime_divides_power</a> : thm
<a name="line465"></a>    val <a href="#prime_divides_prime-val">prime_divides_prime</a> : thm
<a name="line466"></a>    val <a href="#prime_divides_prime_power-val">prime_divides_prime_power</a> : thm
<a name="line467"></a>    val <a href="#prime_divides_self_power-val">prime_divides_self_power</a> : thm
<a name="line468"></a>    val <a href="#prime_iff_coprime_all_lt-val">prime_iff_coprime_all_lt</a> : thm
<a name="line469"></a>    val <a href="#prime_iff_no_proper_factor-val">prime_iff_no_proper_factor</a> : thm
<a name="line470"></a>    val <a href="#prime_power_divides_iff-val">prime_power_divides_iff</a> : thm
<a name="line471"></a>    val <a href="#prime_power_divisor-val">prime_power_divisor</a> : thm
<a name="line472"></a>    val <a href="#prime_power_factor-val">prime_power_factor</a> : thm
<a name="line473"></a>    val <a href="#prime_powers_coprime-val">prime_powers_coprime</a> : thm
<a name="line474"></a>    val <a href="#prime_powers_divide-val">prime_powers_divide</a> : thm
<a name="line475"></a>    val <a href="#prime_powers_eq-val">prime_powers_eq</a> : thm
<a name="line476"></a>    val <a href="#prod_set_residue-val">prod_set_residue</a> : thm
<a name="line477"></a>    val <a href="#residue_0-val">residue_0</a> : thm
<a name="line478"></a>    val <a href="#residue_1-val">residue_1</a> : thm
<a name="line479"></a>    val <a href="#residue_card-val">residue_card</a> : thm
<a name="line480"></a>    val <a href="#residue_count-val">residue_count</a> : thm
<a name="line481"></a>    val <a href="#residue_delete-val">residue_delete</a> : thm
<a name="line482"></a>    val <a href="#residue_element-val">residue_element</a> : thm
<a name="line483"></a>    val <a href="#residue_finite-val">residue_finite</a> : thm
<a name="line484"></a>    val <a href="#residue_insert-val">residue_insert</a> : thm
<a name="line485"></a>    val <a href="#residue_no_self-val">residue_no_self</a> : thm
<a name="line486"></a>    val <a href="#residue_no_zero-val">residue_no_zero</a> : thm
<a name="line487"></a>    val <a href="#residue_nonempty-val">residue_nonempty</a> : thm
<a name="line488"></a>    val <a href="#residue_prime_neq-val">residue_prime_neq</a> : thm
<a name="line489"></a>    val <a href="#residue_suc-val">residue_suc</a> : thm
<a name="line490"></a>    val <a href="#residue_thm-val">residue_thm</a> : thm
<a name="line491"></a>    val <a href="#set_add_fun_by_partition-val">set_add_fun_by_partition</a> : thm
<a name="line492"></a>    val <a href="#set_additive_card-val">set_additive_card</a> : thm
<a name="line493"></a>    val <a href="#set_additive_sigma-val">set_additive_sigma</a> : thm
<a name="line494"></a>    val <a href="#set_card_by_partition-val">set_card_by_partition</a> : thm
<a name="line495"></a>    val <a href="#set_mult_fun_by_partition-val">set_mult_fun_by_partition</a> : thm
<a name="line496"></a>    val <a href="#set_sigma_by_partition-val">set_sigma_by_partition</a> : thm
<a name="line497"></a>    val <a href="#sigma_geometric_natural-val">sigma_geometric_natural</a> : thm
<a name="line498"></a>    val <a href="#sigma_geometric_natural_eqn-val">sigma_geometric_natural_eqn</a> : thm
<a name="line499"></a>    val <a href="#sublist_element_order-val">sublist_element_order</a> : thm
<a name="line500"></a>    val <a href="#sum_image_by_composition-val">sum_image_by_composition</a> : thm
<a name="line501"></a>    val <a href="#sum_image_by_composition_with_partial_inj-val">sum_image_by_composition_with_partial_inj</a> : thm
<a name="line502"></a>    val <a href="#sum_image_by_composition_without_inj-val">sum_image_by_composition_without_inj</a> : thm
<a name="line503"></a>    val <a href="#sum_image_by_permutation-val">sum_image_by_permutation</a> : thm
<a name="line504"></a>    val <a href="#upto_by_count-val">upto_by_count</a> : thm
<a name="line505"></a>    val <a href="#upto_by_natural-val">upto_by_natural</a> : thm
<a name="line506"></a>    val <a href="#upto_card-val">upto_card</a> : thm
<a name="line507"></a>    val <a href="#upto_delete-val">upto_delete</a> : thm
<a name="line508"></a>    val <a href="#upto_finite-val">upto_finite</a> : thm
<a name="line509"></a>    val <a href="#upto_has_last-val">upto_has_last</a> : thm
<a name="line510"></a>    val <a href="#upto_split_first-val">upto_split_first</a> : thm
<a name="line511"></a>    val <a href="#upto_split_last-val">upto_split_last</a> : thm
<a name="line512"></a>(*
   [gcdset] Parent theory of "number"
   
   [hol] Parent theory of "number"
   
   [listRange] Parent theory of "number"
   
   [logroot] Parent theory of "number"
   
   [<a name="Euler_def-val"><b>Euler_def</b></a>]  Definition
      
      ⊢ ∀n. Euler n = {i | 0 &lt; i ∧ i &lt; n ∧ coprime n i}
   
   [<a name="GEN_MULT_INV_DEF-val"><b>GEN_MULT_INV_DEF</b></a>]  Definition
      
      ⊢ ∀n x.
          1 &lt; n ∧ 0 &lt; x ∧ x &lt; n ∧ coprime n x ⇒
          0 &lt; GCD_MOD_MUL_INV n x ∧ GCD_MOD_MUL_INV n x &lt; n ∧
          coprime n (GCD_MOD_MUL_INV n x) ∧
          (GCD_MOD_MUL_INV n x * x) MOD n = 1
   
   [<a name="MOD_MULT_INV_DEF-val"><b>MOD_MULT_INV_DEF</b></a>]  Definition
      
      ⊢ ∀p x.
          prime p ∧ 0 &lt; x ∧ x &lt; p ⇒
          0 &lt; MOD_MULT_INV p x ∧ MOD_MULT_INV p x &lt; p ∧
          (MOD_MULT_INV p x * x) MOD p = 1
   
   [<a name="fequiv_def-val"><b>fequiv_def</b></a>]  Definition
      
      ⊢ ∀x y f. (x == y) f ⇔ f x = f y
   
   [<a name="preimage_def-val"><b>preimage_def</b></a>]  Definition
      
      ⊢ ∀f s y. preimage f s y = {x | x ∈ s ∧ f x = y}
   
   [<a name="residue_def-val"><b>residue_def</b></a>]  Definition
      
      ⊢ ∀n. residue n = {i | 0 &lt; i ∧ i &lt; n}
   
   [<a name="totient_def-val"><b>totient_def</b></a>]  Definition
      
      ⊢ ∀n. totient n = CARD (Euler n)
   
   [<a name="ADD_EQ_2-val"><b>ADD_EQ_2</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ∧ 0 &lt; n ∧ m + n = 2 ⇒ m = 1 ∧ n = 1
   
   [<a name="ADD_SUB_SUB-val"><b>ADD_SUB_SUB</b></a>]  Theorem
      
      ⊢ ∀a b c. c ≤ a ⇒ a + b − (a − c) = c + b
   
   [<a name="ALL_PRIME_FACTORS_MOD_EQ_1-val"><b>ALL_PRIME_FACTORS_MOD_EQ_1</b></a>]  Theorem
      
      ⊢ ∀m n.
          0 &lt; m ∧ 1 &lt; n ∧ (∀p. prime p ∧ p divides m ⇒ p MOD n = 1) ⇒
          m MOD n = 1
   
   [<a name="AND_IMP_IMP-val"><b>AND_IMP_IMP</b></a>]  Theorem
      
      ⊢ ∀b c d. b ∧ (c ⇒ d) ⇒ (b ⇒ c) ⇒ d
   
   [<a name="AND_IMP_OR_NEG-val"><b>AND_IMP_OR_NEG</b></a>]  Theorem
      
      ⊢ ∀p q. p ∧ q ⇒ p ∨ ¬q
   
   [<a name="BIGUNION_ELEMENTS_SING-val"><b>BIGUNION_ELEMENTS_SING</b></a>]  Theorem
      
      ⊢ ∀s. BIGUNION (IMAGE (λx. {x}) s) = s
   
   [<a name="BIJ_LINV_ELEMENT-val"><b>BIJ_LINV_ELEMENT</b></a>]  Theorem
      
      ⊢ ∀f s t. BIJ f s t ⇒ ∀x. x ∈ t ⇒ LINV f s x ∈ s
   
   [<a name="BIJ_LINV_THM-val"><b>BIJ_LINV_THM</b></a>]  Theorem
      
      ⊢ ∀f s t.
          BIJ f s t ⇒
          (∀x. x ∈ s ⇒ LINV f s (f x) = x) ∧ ∀x. x ∈ t ⇒ f (LINV f s x) = x
   
   [<a name="BIJ_RINV_BIJ-val"><b>BIJ_RINV_BIJ</b></a>]  Theorem
      
      ⊢ ∀f s t.
          BIJ f s t ∧ (∀y. y ∈ t ⇒ RINV f s y ∈ s) ⇒ BIJ (RINV f s) t s
   
   [<a name="BIJ_RINV_INV-val"><b>BIJ_RINV_INV</b></a>]  Theorem
      
      ⊢ ∀f s t.
          BIJ f s t ∧ (∀y. y ∈ t ⇒ RINV f s y ∈ s) ⇒
          ∀x. x ∈ s ⇒ RINV f s (f x) = x
   
   [<a name="BOOL_EQ-val"><b>BOOL_EQ</b></a>]  Theorem
      
      ⊢ ∀b1 b2 f. (b1 ⇔ b2) ⇒ f b1 = f b2
   
   [<a name="CARD_BIGUNION_PAIR_DISJOINT-val"><b>CARD_BIGUNION_PAIR_DISJOINT</b></a>]  Theorem
      
      ⊢ ∀P. FINITE P ∧ EVERY_FINITE P ∧ PAIR_DISJOINT P ⇒
            CARD (BIGUNION P) = ∑ CARD P
   
   [<a name="CARD_EQ_1-val"><b>CARD_EQ_1</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ (CARD s = 1 ⇔ SING s)
   
   [<a name="CARD_PPOW-val"><b>CARD_PPOW</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ CARD (PPOW s) = PRE (2 ** CARD s)
   
   [<a name="CARD_PPOW_EQN-val"><b>CARD_PPOW_EQN</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ CARD (PPOW s) = tops 2 (CARD s)
   
   [<a name="CARD_UNION_3_DISJOINT-val"><b>CARD_UNION_3_DISJOINT</b></a>]  Theorem
      
      ⊢ ∀a b c.
          FINITE a ∧ FINITE b ∧ FINITE c ∧ DISJOINT a b ∧ DISJOINT b c ∧
          DISJOINT a c ⇒
          CARD (a ∪ b ∪ c) = CARD a + CARD b + CARD c
   
   [<a name="CARD_UNION_3_EQN-val"><b>CARD_UNION_3_EQN</b></a>]  Theorem
      
      ⊢ ∀a b c.
          FINITE a ∧ FINITE b ∧ FINITE c ⇒
          CARD (a ∪ b ∪ c) =
          CARD a + CARD b + CARD c + CARD (a ∩ b ∩ c) − CARD (a ∩ b) −
          CARD (b ∩ c) − CARD (a ∩ c)
   
   [<a name="COUNT_0-val"><b>COUNT_0</b></a>]  Theorem
      
      ⊢ count 0 = ∅
   
   [<a name="COUNT_1-val"><b>COUNT_1</b></a>]  Theorem
      
      ⊢ count 1 = {0}
   
   [<a name="COUNT_NOT_SELF-val"><b>COUNT_NOT_SELF</b></a>]  Theorem
      
      ⊢ ∀n. n ∉ count n
   
   [<a name="COUNT_SUBSET-val"><b>COUNT_SUBSET</b></a>]  Theorem
      
      ⊢ ∀m n. m ≤ n ⇒ count m ⊆ count n
   
   [<a name="COUNT_SUC_BY_SUC-val"><b>COUNT_SUC_BY_SUC</b></a>]  Theorem
      
      ⊢ ∀n. upto n = 0 INSERT natural n
   
   [<a name="COUNT_SUC_SUBSET-val"><b>COUNT_SUC_SUBSET</b></a>]  Theorem
      
      ⊢ ∀n t. upto n ⊆ t ⇔ count n ⊆ t ∧ n ∈ t
   
   [<a name="DIFF_COUNT_SUC-val"><b>DIFF_COUNT_SUC</b></a>]  Theorem
      
      ⊢ ∀n t. t DIFF upto n = t DIFF count n DELETE n
   
   [<a name="DIFF_DELETE-val"><b>DIFF_DELETE</b></a>]  Theorem
      
      ⊢ ∀s t x. s DIFF t DELETE x = s DIFF (x INSERT t)
   
   [<a name="DIFF_DIFF_EQ_INTER-val"><b>DIFF_DIFF_EQ_INTER</b></a>]  Theorem
      
      ⊢ ∀s t. s DIFF (s DIFF t) = s ∩ t
   
   [<a name="DISJOINT_DIFF-val"><b>DISJOINT_DIFF</b></a>]  Theorem
      
      ⊢ ∀s t. DISJOINT (s DIFF t) t ∧ DISJOINT t (s DIFF t)
   
   [<a name="DISJOINT_DIFF_IFF-val"><b>DISJOINT_DIFF_IFF</b></a>]  Theorem
      
      ⊢ ∀s t. DISJOINT s t ⇔ s DIFF t = s
   
   [<a name="DIVIDES_CANCEL-val"><b>DIVIDES_CANCEL</b></a>]  Theorem
      
      ⊢ ∀k. 0 &lt; k ⇒ ∀m n. m divides n ⇔ m * k divides n * k
   
   [<a name="DIVIDES_CANCEL_COMM-val"><b>DIVIDES_CANCEL_COMM</b></a>]  Theorem
      
      ⊢ ∀m n k. m divides n ⇒ k * m divides k * n
   
   [<a name="DIVIDES_COFACTOR-val"><b>DIVIDES_COFACTOR</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; n ∧ n divides m ⇒ m DIV n divides m
   
   [<a name="DIVIDES_FACTORS-val"><b>DIVIDES_FACTORS</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; n ∧ n divides m ⇒ m = n * (m DIV n)
   
   [<a name="DIVIDES_MOD_MOD-val"><b>DIVIDES_MOD_MOD</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; n ∧ m divides n ⇒ ∀x. x MOD n MOD m = x MOD m
   
   [<a name="DIVIDES_MULTIPLE_IFF-val"><b>DIVIDES_MULTIPLE_IFF</b></a>]  Theorem
      
      ⊢ ∀m n k. k ≠ 0 ⇒ (m divides n ⇔ k * m divides k * n)
   
   [<a name="DIV_COMMON_FACTOR-val"><b>DIV_COMMON_FACTOR</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; n ∧ 0 &lt; m ⇒ ∀x. n divides x ⇒ m * x DIV (m * n) = x DIV n
   
   [<a name="DIV_DIV_MULT-val"><b>DIV_DIV_MULT</b></a>]  Theorem
      
      ⊢ ∀m n x.
          0 &lt; n ∧ 0 &lt; m ∧ 0 &lt; m DIV n ∧ n divides m ∧ m divides x ∧
          m DIV n divides x ⇒
          x DIV (m DIV n) = n * (x DIV m)
   
   [<a name="DIV_LT_MONOTONE_REVERSE-val"><b>DIV_LT_MONOTONE_REVERSE</b></a>]  Theorem
      
      ⊢ ∀x y.
          0 &lt; x ∧ 0 &lt; y ∧ x &lt; y ⇒
          ∀n. 0 &lt; n ∧ n MOD x = 0 ⇒ n DIV y &lt; n DIV x
   
   [<a name="DIV_LT_SUC-val"><b>DIV_LT_SUC</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ∧ 0 &lt; n ∧ n MOD m = 0 ⇒ n DIV SUC m &lt; n DIV m
   
   [<a name="DIV_MULT_LESS_EQ-val"><b>DIV_MULT_LESS_EQ</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ⇒ m * (n DIV m) ≤ n ∧ n &lt; m * SUC (n DIV m)
   
   [<a name="EQ_IMP2_THM-val"><b>EQ_IMP2_THM</b></a>]  Theorem
      
      ⊢ ∀A B. (A ⇔ B) ⇔ (A ⇒ B) ∧ ((A ⇒ B) ⇒ B ⇒ A)
   
   [<a name="EQ_PARITY-val"><b>EQ_PARITY</b></a>]  Theorem
      
      ⊢ ∀a b. EVEN (TWICE a + b) ⇔ EVEN b
   
   [<a name="EVEN_0-val"><b>EVEN_0</b></a>]  Theorem
      
      ⊢ EVEN 0
   
   [<a name="EVEN_2-val"><b>EVEN_2</b></a>]  Theorem
      
      ⊢ EVEN 2
   
   [<a name="EVEN_HALF-val"><b>EVEN_HALF</b></a>]  Theorem
      
      ⊢ ∀n. EVEN n ⇒ n = TWICE (HALF n)
   
   [<a name="EVEN_MOD_EVEN-val"><b>EVEN_MOD_EVEN</b></a>]  Theorem
      
      ⊢ ∀m. EVEN m ∧ m ≠ 0 ⇒ ∀n. EVEN n ⇔ EVEN (n MOD m)
   
   [<a name="EVEN_MOD_ODD-val"><b>EVEN_MOD_ODD</b></a>]  Theorem
      
      ⊢ ∀m. EVEN m ∧ m ≠ 0 ⇒ ∀n. ODD n ⇔ ODD (n MOD m)
   
   [<a name="EVEN_ODD_PRE-val"><b>EVEN_ODD_PRE</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ (EVEN n ⇔ ODD (PRE n)) ∧ (ODD n ⇔ EVEN (PRE n))
   
   [<a name="EVEN_ODD_SUC-val"><b>EVEN_ODD_SUC</b></a>]  Theorem
      
      ⊢ ∀n. (EVEN n ⇔ ODD (SUC n)) ∧ (ODD n ⇔ EVEN (SUC n))
   
   [<a name="EVEN_PARTNERS-val"><b>EVEN_PARTNERS</b></a>]  Theorem
      
      ⊢ ∀n. EVEN (n * (n + 1))
   
   [<a name="EVEN_PRIME-val"><b>EVEN_PRIME</b></a>]  Theorem
      
      ⊢ ∀n. EVEN n ∧ prime n ⇔ n = 2
   
   [<a name="EVEN_SQ-val"><b>EVEN_SQ</b></a>]  Theorem
      
      ⊢ ∀n. EVEN n² ⇔ EVEN n
   
   [<a name="EVEN_SUC_HALF-val"><b>EVEN_SUC_HALF</b></a>]  Theorem
      
      ⊢ ∀n. EVEN n ⇒ HALF (SUC n) = HALF n
   
   [<a name="EXP_2_EQ_0-val"><b>EXP_2_EQ_0</b></a>]  Theorem
      
      ⊢ ∀n. n² = 0 ⇔ n = 0
   
   [<a name="EXP_2_EVEN-val"><b>EXP_2_EVEN</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ EVEN (2 ** n)
   
   [<a name="EXP_2_HALF-val"><b>EXP_2_HALF</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ HALF (2 ** n) = 2 ** (n − 1)
   
   [<a name="EXP_2_PRE_ODD-val"><b>EXP_2_PRE_ODD</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ODD (tops 2 n)
   
   [<a name="EXP_ALT_EQN-val"><b>EXP_ALT_EQN</b></a>]  Theorem
      
      ⊢ ∀m n.
          m ** n =
          if n = 0 then 1 else (if EVEN n then 1 else m) * m² ** HALF n
   
   [<a name="EXP_BY_ADD_SUB_LE-val"><b>EXP_BY_ADD_SUB_LE</b></a>]  Theorem
      
      ⊢ ∀m n. m ≤ n ⇒ ∀p. p ** n = p ** m * p ** (n − m)
   
   [<a name="EXP_BY_ADD_SUB_LT-val"><b>EXP_BY_ADD_SUB_LT</b></a>]  Theorem
      
      ⊢ ∀m n. m &lt; n ⇒ ∀p. p ** n = p ** m * p ** (n − m)
   
   [<a name="EXP_EQN-val"><b>EXP_EQN</b></a>]  Theorem
      
      ⊢ ∀m n.
          m ** n =
          if n = 0 then 1
          else if EVEN n then SQ m ** HALF n
          else m * SQ m ** HALF n
   
   [<a name="EXP_EQN_ALT-val"><b>EXP_EQN_ALT</b></a>]  Theorem
      
      ⊢ ∀m n.
          m ** n =
          if n = 0 then 1 else (if EVEN n then 1 else m) * SQ m ** HALF n
   
   [<a name="EXP_EVEN-val"><b>EXP_EVEN</b></a>]  Theorem
      
      ⊢ ∀n. EVEN n ⇒ ∀m. m ** n = SQ m ** HALF n
   
   [<a name="EXP_EXP_BASE_LE-val"><b>EXP_EXP_BASE_LE</b></a>]  Theorem
      
      ⊢ ∀b c m n. m ≤ n ∧ 0 &lt; c ⇒ b ** c ** m ≤ b ** c ** n
   
   [<a name="EXP_EXP_LE_MONO_IMP-val"><b>EXP_EXP_LE_MONO_IMP</b></a>]  Theorem
      
      ⊢ ∀a b n. a ≤ b ⇒ a ** n ≤ b ** n
   
   [<a name="EXP_EXP_SUC-val"><b>EXP_EXP_SUC</b></a>]  Theorem
      
      ⊢ ∀x y n. x ** y ** SUC n = (x ** y) ** y ** n
   
   [<a name="EXP_LOWER_LE_HIGH-val"><b>EXP_LOWER_LE_HIGH</b></a>]  Theorem
      
      ⊢ ∀n m. n * m ** (n − 1) + m ** n ≤ (1 + m) ** n
   
   [<a name="EXP_LOWER_LE_LOW-val"><b>EXP_LOWER_LE_LOW</b></a>]  Theorem
      
      ⊢ ∀n m. 1 + n * m ≤ (1 + m) ** n
   
   [<a name="EXP_LOWER_LT_LOW-val"><b>EXP_LOWER_LT_LOW</b></a>]  Theorem
      
      ⊢ ∀n m. 0 &lt; m ∧ 1 &lt; n ⇒ 1 + n * m &lt; (1 + m) ** n
   
   [<a name="EXP_MOD_ALT-val"><b>EXP_MOD_ALT</b></a>]  Theorem
      
      ⊢ ∀b n m.
          1 &lt; m ⇒
          b ** n MOD m =
          if n = 0 then 1
          else ((if EVEN n then 1 else b) * SQ b ** HALF n MOD m) MOD m
   
   [<a name="EXP_MOD_EQN-val"><b>EXP_MOD_EQN</b></a>]  Theorem
      
      ⊢ ∀b n m.
          1 &lt; m ⇒
          b ** n MOD m =
          if n = 0 then 1
          else
            (let
               result = SQ b ** HALF n MOD m
             in
               if EVEN n then result else (b * result) MOD m)
   
   [<a name="EXP_ODD-val"><b>EXP_ODD</b></a>]  Theorem
      
      ⊢ ∀n. ODD n ⇒ ∀m. m ** n = m * SQ m ** HALF n
   
   [<a name="EXP_SUC_DIV-val"><b>EXP_SUC_DIV</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ⇒ m ** SUC n DIV m = m ** n
   
   [<a name="EXP_THM-val"><b>EXP_THM</b></a>]  Theorem
      
      ⊢ ∀m n.
          m ** n =
          if n = 0 then 1
          else if n = 1 then m
          else if EVEN n then SQ m ** HALF n
          else m * SQ m ** HALF n
   
   [<a name="Euler_0-val"><b>Euler_0</b></a>]  Theorem
      
      ⊢ Euler 0 = ∅
   
   [<a name="Euler_1-val"><b>Euler_1</b></a>]  Theorem
      
      ⊢ Euler 1 = ∅
   
   [<a name="Euler_card_bounds-val"><b>Euler_card_bounds</b></a>]  Theorem
      
      ⊢ ∀n. totient n ≤ n ∧ (1 &lt; n ⇒ 0 &lt; totient n ∧ totient n &lt; n)
   
   [<a name="Euler_card_prime-val"><b>Euler_card_prime</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇒ totient p = p − 1
   
   [<a name="Euler_card_upper_le-val"><b>Euler_card_upper_le</b></a>]  Theorem
      
      ⊢ FALLING totient
   
   [<a name="Euler_card_upper_lt-val"><b>Euler_card_upper_lt</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ totient n &lt; n
   
   [<a name="Euler_element-val"><b>Euler_element</b></a>]  Theorem
      
      ⊢ ∀n x. x ∈ Euler n ⇔ 0 &lt; x ∧ x &lt; n ∧ coprime n x
   
   [<a name="Euler_empty-val"><b>Euler_empty</b></a>]  Theorem
      
      ⊢ ∀n. Euler n = ∅ ⇔ n = 0 ∨ n = 1
   
   [<a name="Euler_finite-val"><b>Euler_finite</b></a>]  Theorem
      
      ⊢ ∀n. FINITE (Euler n)
   
   [<a name="Euler_has_1-val"><b>Euler_has_1</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ 1 ∈ Euler n
   
   [<a name="Euler_nonempty-val"><b>Euler_nonempty</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ Euler n ≠ ∅
   
   [<a name="Euler_prime-val"><b>Euler_prime</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇒ Euler p = residue p
   
   [<a name="Euler_thm-val"><b>Euler_thm</b></a>]  Theorem
      
      ⊢ ∀n. Euler n = residue n ∩ {j | coprime j n}
   
   [<a name="FACTOR_OUT_POWER-val"><b>FACTOR_OUT_POWER</b></a>]  Theorem
      
      ⊢ ∀n p.
          0 &lt; n ∧ 1 &lt; p ∧ p divides n ⇒
          ∃m. p ** m divides n ∧ ¬(p divides n DIV p ** m)
   
   [<a name="FACTOR_OUT_PRIME-val"><b>FACTOR_OUT_PRIME</b></a>]  Theorem
      
      ⊢ ∀n p.
          0 &lt; n ∧ prime p ∧ p divides n ⇒
          ∃m. 0 &lt; m ∧ p ** m divides n ∧
              ∀k. coprime (p ** k) (n DIV p ** m)
   
   [<a name="FACT_EQ_PROD-val"><b>FACT_EQ_PROD</b></a>]  Theorem
      
      ⊢ ∀n. FACT n = PROD_SET (natural n)
   
   [<a name="FACT_REDUCTION-val"><b>FACT_REDUCTION</b></a>]  Theorem
      
      ⊢ ∀n m.
          m &lt; n ⇒
          FACT n = PROD_SET (IMAGE SUC (count n DIFF count m)) * FACT m
   
   [<a name="FILTER_element_order-val"><b>FILTER_element_order</b></a>]  Theorem
      
      ⊢ ∀P ls j h.
          (let
             fs = FILTER P ls
           in
             ALL_DISTINCT ls ∧ j &lt; h ∧ h &lt; LENGTH fs ⇒
             findi (EL j fs) ls &lt; findi (EL h fs) ls)
   
   [<a name="FINITE_BIJ_COUNT_CARD-val"><b>FINITE_BIJ_COUNT_CARD</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∃f. BIJ f (count (CARD s)) s
   
   [<a name="FINITE_COUNT_IMAGE-val"><b>FINITE_COUNT_IMAGE</b></a>]  Theorem
      
      ⊢ ∀P n. FINITE {P x | x &lt; n}
   
   [<a name="FINITE_INJ_AS_SURJ-val"><b>FINITE_INJ_AS_SURJ</b></a>]  Theorem
      
      ⊢ ∀f s t.
          INJ f s t ∧ FINITE s ∧ FINITE t ∧ CARD s = CARD t ⇒ SURJ f s t
   
   [<a name="FINITE_INJ_IS_BIJ-val"><b>FINITE_INJ_IS_BIJ</b></a>]  Theorem
      
      ⊢ ∀f s t.
          FINITE s ∧ FINITE t ∧ CARD s = CARD t ∧ INJ f s t ⇒ BIJ f s t
   
   [<a name="FINITE_INJ_IS_SURJ-val"><b>FINITE_INJ_IS_SURJ</b></a>]  Theorem
      
      ⊢ ∀f s t.
          FINITE s ∧ FINITE t ∧ CARD s = CARD t ∧ INJ f s t ⇒ SURJ f s t
   
   [<a name="FINITE_PPOW-val"><b>FINITE_PPOW</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ FINITE (PPOW s)
   
   [<a name="FINITE_SURJ_IS_INJ-val"><b>FINITE_SURJ_IS_INJ</b></a>]  Theorem
      
      ⊢ ∀f s t. FINITE s ∧ CARD s = CARD t ∧ SURJ f s t ⇒ INJ f s t
   
   [<a name="FIVE-val"><b>FIVE</b></a>]  Theorem
      
      ⊢ 5 = SUC 4
   
   [<a name="FOUR-val"><b>FOUR</b></a>]  Theorem
      
      ⊢ 4 = SUC 3
   
   [<a name="FUNPOW_ADD1-val"><b>FUNPOW_ADD1</b></a>]  Theorem
      
      ⊢ ∀m n. FUNPOW SUC n m = m + n
   
   [<a name="FUNPOW_DIV-val"><b>FUNPOW_DIV</b></a>]  Theorem
      
      ⊢ ∀b m n. 0 &lt; b ⇒ FUNPOW (flip $DIV b) n m = m DIV b ** n
   
   [<a name="FUNPOW_EQ_LINV-val"><b>FUNPOW_EQ_LINV</b></a>]  Theorem
      
      ⊢ ∀f s x n.
          f PERMUTES s ∧ x ∈ s ⇒ FUNPOW (LINV f s) n (FUNPOW f n x) = x
   
   [<a name="FUNPOW_GE_MONO-val"><b>FUNPOW_GE_MONO</b></a>]  Theorem
      
      ⊢ ∀f g. (∀x. f x ≤ g x) ∧ MONO f ⇒ ∀n x. FUNPOW f n x ≤ FUNPOW g n x
   
   [<a name="FUNPOW_LE_FALLING-val"><b>FUNPOW_LE_FALLING</b></a>]  Theorem
      
      ⊢ ∀f m n. FALLING f ∧ m ≤ n ⇒ ∀x. FUNPOW f n x ≤ FUNPOW f m x
   
   [<a name="FUNPOW_LE_MONO-val"><b>FUNPOW_LE_MONO</b></a>]  Theorem
      
      ⊢ ∀f g. (∀x. f x ≤ g x) ∧ MONO g ⇒ ∀n x. FUNPOW f n x ≤ FUNPOW g n x
   
   [<a name="FUNPOW_LE_RISING-val"><b>FUNPOW_LE_RISING</b></a>]  Theorem
      
      ⊢ ∀f m n. RISING f ∧ m ≤ n ⇒ ∀x. FUNPOW f m x ≤ FUNPOW f n x
   
   [<a name="FUNPOW_LINV_EQ-val"><b>FUNPOW_LINV_EQ</b></a>]  Theorem
      
      ⊢ ∀f s x n.
          f PERMUTES s ∧ x ∈ s ⇒ FUNPOW f n (FUNPOW (LINV f s) n x) = x
   
   [<a name="FUNPOW_LINV_INV-val"><b>FUNPOW_LINV_INV</b></a>]  Theorem
      
      ⊢ ∀f s x y n.
          f PERMUTES s ∧ x ∈ s ∧ y ∈ s ⇒
          (x = FUNPOW f n y ⇔ y = FUNPOW (LINV f s) n x)
   
   [<a name="FUNPOW_LINV_SUB1-val"><b>FUNPOW_LINV_SUB1</b></a>]  Theorem
      
      ⊢ ∀f s x m n.
          f PERMUTES s ∧ x ∈ s ∧ m ≤ n ⇒
          FUNPOW (LINV f s) (n − m) x = FUNPOW (LINV f s) n (FUNPOW f m x)
   
   [<a name="FUNPOW_LINV_SUB2-val"><b>FUNPOW_LINV_SUB2</b></a>]  Theorem
      
      ⊢ ∀f s x m n.
          f PERMUTES s ∧ x ∈ s ∧ m ≤ n ⇒
          FUNPOW (LINV f s) (n − m) x = FUNPOW f m (FUNPOW (LINV f s) n x)
   
   [<a name="FUNPOW_LINV_closure-val"><b>FUNPOW_LINV_closure</b></a>]  Theorem
      
      ⊢ ∀f s x n. f PERMUTES s ∧ x ∈ s ⇒ FUNPOW (LINV f s) n x ∈ s
   
   [<a name="FUNPOW_LINV_permutes-val"><b>FUNPOW_LINV_permutes</b></a>]  Theorem
      
      ⊢ ∀f s n. f PERMUTES s ⇒ FUNPOW (LINV f s) n PERMUTES s
   
   [<a name="FUNPOW_MAX-val"><b>FUNPOW_MAX</b></a>]  Theorem
      
      ⊢ ∀m n k. 0 &lt; n ⇒ FUNPOW (λx. MAX x m) n k = MAX k m
   
   [<a name="FUNPOW_MIN-val"><b>FUNPOW_MIN</b></a>]  Theorem
      
      ⊢ ∀m n k. 0 &lt; n ⇒ FUNPOW (λx. MIN x m) n k = MIN k m
   
   [<a name="FUNPOW_MOD-val"><b>FUNPOW_MOD</b></a>]  Theorem
      
      ⊢ ∀f k e.
          0 &lt; k ∧ FUNPOW f k e = e ⇒
          ∀n. FUNPOW f n e = FUNPOW f (n MOD k) e
   
   [<a name="FUNPOW_MUL-val"><b>FUNPOW_MUL</b></a>]  Theorem
      
      ⊢ ∀b m n. FUNPOW ($* b) n m = m * b ** n
   
   [<a name="FUNPOW_MULTIPLE-val"><b>FUNPOW_MULTIPLE</b></a>]  Theorem
      
      ⊢ ∀f k e. 0 &lt; k ∧ FUNPOW f k e = e ⇒ ∀n. FUNPOW f (n * k) e = e
   
   [<a name="FUNPOW_PAIR-val"><b>FUNPOW_PAIR</b></a>]  Theorem
      
      ⊢ ∀f g n x y.
          FUNPOW (λ(x,y). (f x,g y)) n (x,y) = (FUNPOW f n x,FUNPOW g n y)
   
   [<a name="FUNPOW_SQ-val"><b>FUNPOW_SQ</b></a>]  Theorem
      
      ⊢ ∀m n. FUNPOW (λn. SQ n) n m = m ** 2 ** n
   
   [<a name="FUNPOW_SQ_MOD-val"><b>FUNPOW_SQ_MOD</b></a>]  Theorem
      
      ⊢ ∀m n k.
          0 &lt; m ∧ 0 &lt; n ⇒ FUNPOW (λn. SQ n MOD m) n k = k ** 2 ** n MOD m
   
   [<a name="FUNPOW_SUB1-val"><b>FUNPOW_SUB1</b></a>]  Theorem
      
      ⊢ ∀m n. FUNPOW PRE n m = m − n
   
   [<a name="FUNPOW_SUB_LINV1-val"><b>FUNPOW_SUB_LINV1</b></a>]  Theorem
      
      ⊢ ∀f s x m n.
          f PERMUTES s ∧ x ∈ s ∧ m ≤ n ⇒
          FUNPOW f (n − m) x = FUNPOW f n (FUNPOW (LINV f s) m x)
   
   [<a name="FUNPOW_SUB_LINV2-val"><b>FUNPOW_SUB_LINV2</b></a>]  Theorem
      
      ⊢ ∀f s x m n.
          f PERMUTES s ∧ x ∈ s ∧ m ≤ n ⇒
          FUNPOW f (n − m) x = FUNPOW (LINV f s) m (FUNPOW f n x)
   
   [<a name="FUNPOW_TRIPLE-val"><b>FUNPOW_TRIPLE</b></a>]  Theorem
      
      ⊢ ∀f g h n x y z.
          FUNPOW (λ(x,y,z). (f x,g y,h z)) n (x,y,z) =
          (FUNPOW f n x,FUNPOW g n y,FUNPOW h n z)
   
   [<a name="FUNPOW_closure-val"><b>FUNPOW_closure</b></a>]  Theorem
      
      ⊢ ∀f s x n. f PERMUTES s ∧ x ∈ s ⇒ FUNPOW f n x ∈ s
   
   [<a name="FUNPOW_permutes-val"><b>FUNPOW_permutes</b></a>]  Theorem
      
      ⊢ ∀f s n. f PERMUTES s ⇒ FUNPOW f n PERMUTES s
   
   [<a name="GCD_MOD_MULT_INV-val"><b>GCD_MOD_MULT_INV</b></a>]  Theorem
      
      ⊢ ∀n x.
          1 &lt; n ∧ 0 &lt; x ∧ x &lt; n ∧ coprime n x ⇒
          ∃y. 0 &lt; y ∧ y &lt; n ∧ coprime n y ∧ (y * x) MOD n = 1
   
   [<a name="GCD_SUB_MULTIPLE-val"><b>GCD_SUB_MULTIPLE</b></a>]  Theorem
      
      ⊢ ∀a b k. k * a ≤ b ⇒ gcd a b = gcd a (b − k * a)
   
   [<a name="GCD_SUB_MULTIPLE_COMM-val"><b>GCD_SUB_MULTIPLE_COMM</b></a>]  Theorem
      
      ⊢ ∀a b k. k * a ≤ b ⇒ gcd b a = gcd a (b − k * a)
   
   [<a name="HALF_ADD1_LE-val"><b>HALF_ADD1_LE</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ 1 + HALF n ≤ n
   
   [<a name="HALF_ADD1_LT-val"><b>HALF_ADD1_LT</b></a>]  Theorem
      
      ⊢ ∀n. 2 &lt; n ⇒ 1 + HALF n &lt; n
   
   [<a name="HALF_DIV_TWO_POWER-val"><b>HALF_DIV_TWO_POWER</b></a>]  Theorem
      
      ⊢ ∀m n. HALF n DIV 2 ** m = n DIV 2 ** SUC m
   
   [<a name="HALF_EQ_0-val"><b>HALF_EQ_0</b></a>]  Theorem
      
      ⊢ ∀n. HALF n = 0 ⇔ n = 0 ∨ n = 1
   
   [<a name="HALF_EQ_SELF-val"><b>HALF_EQ_SELF</b></a>]  Theorem
      
      ⊢ ∀n. HALF n = n ⇔ n = 0
   
   [<a name="HALF_EVEN_LE-val"><b>HALF_EVEN_LE</b></a>]  Theorem
      
      ⊢ ∀n m. TWICE n &lt; m ⇒ n ≤ HALF m
   
   [<a name="HALF_EXP_5-val"><b>HALF_EXP_5</b></a>]  Theorem
      
      ⊢ ∀n. n * HALF (SQ n)² ≤ HALF (n ** 5)
   
   [<a name="HALF_LE-val"><b>HALF_LE</b></a>]  Theorem
      
      ⊢ ∀n. HALF n ≤ n
   
   [<a name="HALF_LE_MONO-val"><b>HALF_LE_MONO</b></a>]  Theorem
      
      ⊢ ∀x y. x ≤ y ⇒ HALF x ≤ HALF y
   
   [<a name="HALF_LT-val"><b>HALF_LT</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ HALF n &lt; n
   
   [<a name="HALF_MULT-val"><b>HALF_MULT</b></a>]  Theorem
      
      ⊢ ∀m n. n * HALF m ≤ HALF (n * m)
   
   [<a name="HALF_MULT_EVEN-val"><b>HALF_MULT_EVEN</b></a>]  Theorem
      
      ⊢ ∀m n. EVEN n ⇒ HALF (m * n) = m * HALF n
   
   [<a name="HALF_ODD_LT-val"><b>HALF_ODD_LT</b></a>]  Theorem
      
      ⊢ ∀n m. TWICE n + 1 &lt; m ⇒ n &lt; HALF m
   
   [<a name="HALF_SQ_LE-val"><b>HALF_SQ_LE</b></a>]  Theorem
      
      ⊢ ∀n. (HALF n)² ≤ n² DIV 4
   
   [<a name="HALF_SUC-val"><b>HALF_SUC</b></a>]  Theorem
      
      ⊢ ∀n. HALF (SUC n) ≤ n
   
   [<a name="HALF_SUC_LE-val"><b>HALF_SUC_LE</b></a>]  Theorem
      
      ⊢ ∀n m. n &lt; HALF (SUC m) ⇒ TWICE n + 1 ≤ m
   
   [<a name="HALF_SUC_SUC-val"><b>HALF_SUC_SUC</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ HALF (SUC (SUC n)) ≤ n
   
   [<a name="HALF_TWICE-val"><b>HALF_TWICE</b></a>]  Theorem
      
      ⊢ ∀n. HALF (TWICE n) = n
   
   [<a name="IMAGE_COUNT_SUC-val"><b>IMAGE_COUNT_SUC</b></a>]  Theorem
      
      ⊢ ∀f n. IMAGE f (upto n) = f n INSERT IMAGE f (count n)
   
   [<a name="IMAGE_COUNT_SUC_BY_SUC-val"><b>IMAGE_COUNT_SUC_BY_SUC</b></a>]  Theorem
      
      ⊢ ∀f n. IMAGE f (upto n) = f 0 INSERT IMAGE (f ∘ SUC) (count n)
   
   [<a name="IMAGE_DIFF-val"><b>IMAGE_DIFF</b></a>]  Theorem
      
      ⊢ ∀s t f.
          s ⊆ t ∧ INJ f t 𝕌(:β) ⇒
          IMAGE f (t DIFF s) = IMAGE f t DIFF IMAGE f s
   
   [<a name="IMAGE_ELEMENT_CONDITION-val"><b>IMAGE_ELEMENT_CONDITION</b></a>]  Theorem
      
      ⊢ ∀f. (∀x y. f x = f y ⇒ x = y) ⇒ ∀s e. e ∈ s ⇔ f e ∈ IMAGE f s
   
   [<a name="IMAGE_K-val"><b>IMAGE_K</b></a>]  Theorem
      
      ⊢ ∀s. s ≠ ∅ ⇒ ∀e. IMAGE (K e) s = {e}
   
   [<a name="IMAGE_SUBSET_TARGET-val"><b>IMAGE_SUBSET_TARGET</b></a>]  Theorem
      
      ⊢ ∀f s t. (∀x. x ∈ s ⇒ f x ∈ t) ⇔ IMAGE f s ⊆ t
   
   [<a name="INJ_CARD_IMAGE_EQN-val"><b>INJ_CARD_IMAGE_EQN</b></a>]  Theorem
      
      ⊢ ∀f s. INJ f s 𝕌(:β) ∧ FINITE s ⇒ CARD (IMAGE f s) = CARD s
   
   [<a name="INJ_IMAGE_BIJ_ALT-val"><b>INJ_IMAGE_BIJ_ALT</b></a>]  Theorem
      
      ⊢ ∀f s. INJ f s 𝕌(:β) ⇒ BIJ f s (IMAGE f s)
   
   [<a name="INJ_UNIV-val"><b>INJ_UNIV</b></a>]  Theorem
      
      ⊢ ∀f s t. INJ f s t ⇒ INJ f s 𝕌(:β)
   
   [<a name="INSERT_DELETE_COMM-val"><b>INSERT_DELETE_COMM</b></a>]  Theorem
      
      ⊢ ∀s x y. x ≠ y ⇒ (x INSERT s) DELETE y = x INSERT s DELETE y
   
   [<a name="INSERT_DELETE_NON_ELEMENT-val"><b>INSERT_DELETE_NON_ELEMENT</b></a>]  Theorem
      
      ⊢ ∀x s. x ∉ s ⇒ (x INSERT s) DELETE x = s
   
   [<a name="INSERT_SUBSET_SUBSET-val"><b>INSERT_SUBSET_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t x. x ∉ s ∧ x INSERT s ⊆ t ⇒ s ⊆ t DELETE x
   
   [<a name="INTER_DIFF-val"><b>INTER_DIFF</b></a>]  Theorem
      
      ⊢ ∀s t. s ∩ (t DIFF s) = ∅ ∧ (t DIFF s) ∩ s = ∅
   
   [<a name="IN_PPOW-val"><b>IN_PPOW</b></a>]  Theorem
      
      ⊢ ∀s e. e ∈ PPOW s ⇒ e ⊂ s
   
   [<a name="IN_SING_OR_EMPTY-val"><b>IN_SING_OR_EMPTY</b></a>]  Theorem
      
      ⊢ ∀b x y. x ∈ (if b then {y} else ∅) ⇒ x = y
   
   [<a name="LCM_EXCHANGE-val"><b>LCM_EXCHANGE</b></a>]  Theorem
      
      ⊢ ∀a b c. a * b = c * (a − b) ⇒ lcm a b = lcm a c
   
   [<a name="LESS_HALF_IFF-val"><b>LESS_HALF_IFF</b></a>]  Theorem
      
      ⊢ ∀n k. k &lt; HALF n ⇔ k + 1 &lt; n − k
   
   [<a name="LESS_SUC-val"><b>LESS_SUC</b></a>]  Theorem
      
      ⊢ ∀n. n &lt; SUC n
   
   [<a name="LE_IMP_REVERSE_LT-val"><b>LE_IMP_REVERSE_LT</b></a>]  Theorem
      
      ⊢ ∀a b c d. 0 &lt; c ∧ 0 &lt; d ∧ a * b ≤ c * d ∧ d &lt; b ⇒ a &lt; c
   
   [<a name="LE_MONO_ADD2-val"><b>LE_MONO_ADD2</b></a>]  Theorem
      
      ⊢ ∀a b c d. a ≤ b ∧ c ≤ d ⇒ a + c ≤ b + d
   
   [<a name="LE_MONO_MULT2-val"><b>LE_MONO_MULT2</b></a>]  Theorem
      
      ⊢ ∀a b c d. a ≤ b ∧ c ≤ d ⇒ a * c ≤ b * d
   
   [<a name="LE_MULT_LCANCEL_IMP-val"><b>LE_MULT_LCANCEL_IMP</b></a>]  Theorem
      
      ⊢ ∀m n p. n ≤ p ⇒ m * n ≤ m * p
   
   [<a name="LE_ONE-val"><b>LE_ONE</b></a>]  Theorem
      
      ⊢ ∀n. n ≤ 1 ⇔ n = 0 ∨ n = 1
   
   [<a name="LE_TWICE_ALT-val"><b>LE_TWICE_ALT</b></a>]  Theorem
      
      ⊢ ∀m n. n ≤ TWICE m ⇔ n ≠ 0 ⇒ HALF (n − 1) &lt; m
   
   [<a name="LINV_SUBSET-val"><b>LINV_SUBSET</b></a>]  Theorem
      
      ⊢ ∀f s t. INJ f t 𝕌(:β) ∧ s ⊆ t ⇒ ∀x. x ∈ s ⇒ LINV f t (f x) = x
   
   [<a name="LINV_permutes-val"><b>LINV_permutes</b></a>]  Theorem
      
      ⊢ ∀f s. f PERMUTES s ⇒ LINV f s PERMUTES s
   
   [<a name="LT_MONO_ADD2-val"><b>LT_MONO_ADD2</b></a>]  Theorem
      
      ⊢ ∀a b c d. a &lt; b ∧ c &lt; d ⇒ a + c &lt; b + d
   
   [<a name="LT_MONO_MULT2-val"><b>LT_MONO_MULT2</b></a>]  Theorem
      
      ⊢ ∀a b c d. a &lt; b ∧ c &lt; d ⇒ a * c &lt; b * d
   
   [<a name="MAX_1_EXP-val"><b>MAX_1_EXP</b></a>]  Theorem
      
      ⊢ ∀n m. MAX 1 (m ** n) = MAX 1 m ** n
   
   [<a name="MAX_1_POS-val"><b>MAX_1_POS</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ MAX 1 n = n
   
   [<a name="MAX_ADD-val"><b>MAX_ADD</b></a>]  Theorem
      
      ⊢ ∀a b c. MAX a (b + c) ≤ MAX a b + MAX a c
   
   [<a name="MAX_ALT-val"><b>MAX_ALT</b></a>]  Theorem
      
      ⊢ ∀m n. MAX m n = if m ≤ n then n else m
   
   [<a name="MAX_ID-val"><b>MAX_ID</b></a>]  Theorem
      
      ⊢ ∀m n. MAX (MAX m n) n = MAX m n ∧ MAX m (MAX m n) = MAX m n
   
   [<a name="MAX_IS_MAX-val"><b>MAX_IS_MAX</b></a>]  Theorem
      
      ⊢ ∀m n. m ≤ MAX m n ∧ n ≤ MAX m n
   
   [<a name="MAX_LESS-val"><b>MAX_LESS</b></a>]  Theorem
      
      ⊢ ∀x y n. x &lt; n ∧ y &lt; n ⇒ MAX x y &lt; n
   
   [<a name="MAX_LE_PAIR-val"><b>MAX_LE_PAIR</b></a>]  Theorem
      
      ⊢ ∀a b c d. a ≤ b ∧ c ≤ d ⇒ MAX a c ≤ MAX b d
   
   [<a name="MAX_LE_SUM-val"><b>MAX_LE_SUM</b></a>]  Theorem
      
      ⊢ ∀m n. MAX m n ≤ m + n
   
   [<a name="MAX_SET_DELETE-val"><b>MAX_SET_DELETE</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ∧ s ≠ ∅ ∧ s ≠ {MIN_SET s} ⇒
            MAX_SET (s DELETE MIN_SET s) = MAX_SET s
   
   [<a name="MAX_SET_IMAGE_SUC_COUNT-val"><b>MAX_SET_IMAGE_SUC_COUNT</b></a>]  Theorem
      
      ⊢ ∀n. MAX_SET (natural n) = n
   
   [<a name="MAX_SET_IMAGE_with_DEC-val"><b>MAX_SET_IMAGE_with_DEC</b></a>]  Theorem
      
      ⊢ ∀f b c x. x − b ≤ c ⇒ f x ≤ MAX_SET {f x | x − b ≤ c}
   
   [<a name="MAX_SET_IMAGE_with_DIV-val"><b>MAX_SET_IMAGE_with_DIV</b></a>]  Theorem
      
      ⊢ ∀f b c x. 0 &lt; b ∧ x DIV b ≤ c ⇒ f x ≤ MAX_SET {f x | x DIV b ≤ c}
   
   [<a name="MAX_SET_IMAGE_with_HALF-val"><b>MAX_SET_IMAGE_with_HALF</b></a>]  Theorem
      
      ⊢ ∀f c x. HALF x ≤ c ⇒ f x ≤ MAX_SET {f x | HALF x ≤ c}
   
   [<a name="MAX_SUC-val"><b>MAX_SUC</b></a>]  Theorem
      
      ⊢ ∀m n. MAX (SUC m) (SUC n) = SUC (MAX m n)
   
   [<a name="MAX_SWAP-val"><b>MAX_SWAP</b></a>]  Theorem
      
      ⊢ ∀f. MONO f ⇒ ∀x y. f (MAX x y) = MAX (f x) (f y)
   
   [<a name="MIN_1_EXP-val"><b>MIN_1_EXP</b></a>]  Theorem
      
      ⊢ ∀n m. MIN 1 (m ** n) = MIN 1 m ** n
   
   [<a name="MIN_1_POS-val"><b>MIN_1_POS</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ MIN 1 n = 1
   
   [<a name="MIN_ADD-val"><b>MIN_ADD</b></a>]  Theorem
      
      ⊢ ∀a b c. MIN a (b + c) ≤ MIN a b + MIN a c
   
   [<a name="MIN_ALT-val"><b>MIN_ALT</b></a>]  Theorem
      
      ⊢ ∀m n. MIN m n = if m ≤ n then m else n
   
   [<a name="MIN_ID-val"><b>MIN_ID</b></a>]  Theorem
      
      ⊢ ∀m n. MIN (MIN m n) n = MIN m n ∧ MIN m (MIN m n) = MIN m n
   
   [<a name="MIN_IS_MIN-val"><b>MIN_IS_MIN</b></a>]  Theorem
      
      ⊢ ∀m n. MIN m n ≤ m ∧ MIN m n ≤ n
   
   [<a name="MIN_LE_PAIR-val"><b>MIN_LE_PAIR</b></a>]  Theorem
      
      ⊢ ∀a b c d. a ≤ b ∧ c ≤ d ⇒ MIN a c ≤ MIN b d
   
   [<a name="MIN_LE_SUM-val"><b>MIN_LE_SUM</b></a>]  Theorem
      
      ⊢ ∀m n. MIN m n ≤ m + n
   
   [<a name="MIN_SUC-val"><b>MIN_SUC</b></a>]  Theorem
      
      ⊢ ∀m n. MIN (SUC m) (SUC n) = SUC (MIN m n)
   
   [<a name="MIN_SWAP-val"><b>MIN_SWAP</b></a>]  Theorem
      
      ⊢ ∀f. MONO f ⇒ ∀x y. f (MIN x y) = MIN (f x) (f y)
   
   [<a name="MOD_MULT_INV_EXISTS-val"><b>MOD_MULT_INV_EXISTS</b></a>]  Theorem
      
      ⊢ ∀p x.
          prime p ∧ 0 &lt; x ∧ x &lt; p ⇒ ∃y. 0 &lt; y ∧ y &lt; p ∧ (y * x) MOD p = 1
   
   [<a name="MOD_MULT_LCANCEL-val"><b>MOD_MULT_LCANCEL</b></a>]  Theorem
      
      ⊢ ∀p x y z.
          prime p ∧ (x * y) MOD p = (x * z) MOD p ∧ x MOD p ≠ 0 ⇒
          y MOD p = z MOD p
   
   [<a name="MOD_MULT_RCANCEL-val"><b>MOD_MULT_RCANCEL</b></a>]  Theorem
      
      ⊢ ∀p x y z.
          prime p ∧ (y * x) MOD p = (z * x) MOD p ∧ x MOD p ≠ 0 ⇒
          y MOD p = z MOD p
   
   [<a name="MOD_SUC_EQN-val"><b>MOD_SUC_EQN</b></a>]  Theorem
      
      ⊢ ∀m n.
          0 &lt; m ⇒ SUC (n MOD m) = SUC n MOD m + (SUC n DIV m − n DIV m) * m
   
   [<a name="MONOTONE_MAX-val"><b>MONOTONE_MAX</b></a>]  Theorem
      
      ⊢ ∀f m. (∀k. k &lt; m ⇒ f k &lt; f (k + 1)) ⇒ ∀k. k &lt; m ⇒ f k &lt; f m
   
   [<a name="MORE_HALF_IMP-val"><b>MORE_HALF_IMP</b></a>]  Theorem
      
      ⊢ ∀n k. HALF n &lt; k ⇒ n − k ≤ HALF n
   
   [<a name="MULT3_EQ_0-val"><b>MULT3_EQ_0</b></a>]  Theorem
      
      ⊢ ∀x y z. x * y * z = 0 ⇔ x = 0 ∨ y = 0 ∨ z = 0
   
   [<a name="MULT3_EQ_1-val"><b>MULT3_EQ_1</b></a>]  Theorem
      
      ⊢ ∀x y z. x * y * z = 1 ⇔ x = 1 ∧ y = 1 ∧ z = 1
   
   [<a name="MULTIPLE_INTERVAL-val"><b>MULTIPLE_INTERVAL</b></a>]  Theorem
      
      ⊢ ∀n m. n divides m ⇒ ∀x. m − n &lt; x ∧ x &lt; m + n ∧ n divides x ⇒ x = m
   
   [<a name="MULTIPLE_SUC_LE-val"><b>MULTIPLE_SUC_LE</b></a>]  Theorem
      
      ⊢ ∀n k. 0 &lt; n ⇒ k * n + 1 ≤ (k + 1) * n
   
   [<a name="MULTIPLY_DIV-val"><b>MULTIPLY_DIV</b></a>]  Theorem
      
      ⊢ ∀n p q. 0 &lt; n ∧ n divides q ⇒ p * (q DIV n) = p * q DIV n
   
   [<a name="MULT_EQ_LESS_TO_MORE-val"><b>MULT_EQ_LESS_TO_MORE</b></a>]  Theorem
      
      ⊢ ∀a b c d. 0 &lt; a ∧ 0 &lt; b ∧ a &lt; c ∧ a * b = c * d ⇒ d &lt; b
   
   [<a name="MULT_EVEN-val"><b>MULT_EVEN</b></a>]  Theorem
      
      ⊢ ∀n. EVEN n ⇒ ∀m. m * n = TWICE m * HALF n
   
   [<a name="MULT_LE_IMP_LE-val"><b>MULT_LE_IMP_LE</b></a>]  Theorem
      
      ⊢ ∀m n k. 0 &lt; k ∧ k * m ≤ n ⇒ m ≤ n
   
   [<a name="MULT_LT_IMP_LT-val"><b>MULT_LT_IMP_LT</b></a>]  Theorem
      
      ⊢ ∀m n k. 0 &lt; k ∧ k * m &lt; n ⇒ m &lt; n
   
   [<a name="MULT_ODD-val"><b>MULT_ODD</b></a>]  Theorem
      
      ⊢ ∀n. ODD n ⇒ ∀m. m * n = m + TWICE m * HALF n
   
   [<a name="NOT_LT_ONE-val"><b>NOT_LT_ONE</b></a>]  Theorem
      
      ⊢ ∀n. ¬(1 &lt; n) ⇔ n = 0 ∨ n = 1
   
   [<a name="NOT_PRIME_4-val"><b>NOT_PRIME_4</b></a>]  Theorem
      
      ⊢ ¬prime 4
   
   [<a name="NOT_ZERO_GE_ONE-val"><b>NOT_ZERO_GE_ONE</b></a>]  Theorem
      
      ⊢ ∀n. n ≠ 0 ⇔ 1 ≤ n
   
   [<a name="ODD_1-val"><b>ODD_1</b></a>]  Theorem
      
      ⊢ ODD 1
   
   [<a name="ODD_EXP-val"><b>ODD_EXP</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; n ∧ ODD m ⇒ ODD (m ** n)
   
   [<a name="ODD_HALF-val"><b>ODD_HALF</b></a>]  Theorem
      
      ⊢ ∀n. ODD n ⇒ n = TWICE (HALF n) + 1
   
   [<a name="ODD_MOD2-val"><b>ODD_MOD2</b></a>]  Theorem
      
      ⊢ ∀x. ODD x ⇔ x MOD 2 = 1
   
   [<a name="ODD_PRIME-val"><b>ODD_PRIME</b></a>]  Theorem
      
      ⊢ ∀n. prime n ∧ n ≠ 2 ⇒ ODD n
   
   [<a name="ODD_SQ-val"><b>ODD_SQ</b></a>]  Theorem
      
      ⊢ ∀n. ODD n² ⇔ ODD n
   
   [<a name="ODD_SUC_HALF-val"><b>ODD_SUC_HALF</b></a>]  Theorem
      
      ⊢ ∀n. ODD n ⇒ HALF (SUC n) = SUC (HALF n)
   
   [<a name="ONE_LT_HALF_SQ-val"><b>ONE_LT_HALF_SQ</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ 1 &lt; HALF n²
   
   [<a name="ONE_LT_NONZERO-val"><b>ONE_LT_NONZERO</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ n ≠ 0
   
   [<a name="ONE_LT_POS-val"><b>ONE_LT_POS</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ 0 &lt; n
   
   [<a name="ONE_NOT_0-val"><b>ONE_NOT_0</b></a>]  Theorem
      
      ⊢ 1 ≠ 0
   
   [<a name="ONE_NOT_ZERO-val"><b>ONE_NOT_ZERO</b></a>]  Theorem
      
      ⊢ 1 ≠ 0
   
   [<a name="OR_IMP_IMP-val"><b>OR_IMP_IMP</b></a>]  Theorem
      
      ⊢ ∀p q r. (p ∨ q ⇒ r) ⇒ p ∧ ¬q ⇒ r
   
   [<a name="POWER_EQ_SELF-val"><b>POWER_EQ_SELF</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ ∀m. n ** m = n ⇔ m = 1
   
   [<a name="PRE_LESS-val"><b>PRE_LESS</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ PRE n &lt; n
   
   [<a name="PRIME_EXP_FACTOR-val"><b>PRIME_EXP_FACTOR</b></a>]  Theorem
      
      ⊢ ∀p q n. prime p ∧ q divides p ** n ⇒ q = 1 ∨ p divides q
   
   [<a name="PRIME_FACTOR_PROPER-val"><b>PRIME_FACTOR_PROPER</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ∧ ¬prime n ⇒ ∃p. prime p ∧ p &lt; n ∧ p divides n
   
   [<a name="PROD_SET_DIVISORS-val"><b>PROD_SET_DIVISORS</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀n x. x ∈ s ∧ n divides x ⇒ n divides PROD_SET s
   
   [<a name="PROD_SET_ELEMENT_DIVIDES-val"><b>PROD_SET_ELEMENT_DIVIDES</b></a>]  Theorem
      
      ⊢ ∀s x. FINITE s ∧ x ∈ s ⇒ x divides PROD_SET s
   
   [<a name="PROD_SET_EUCLID-val"><b>PROD_SET_EUCLID</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒
            ∀p. prime p ∧ p divides PROD_SET s ⇒ ∃b. b ∈ s ∧ p divides b
   
   [<a name="PROD_SET_IMAGE_EQN-val"><b>PROD_SET_IMAGE_EQN</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀f. INJ f s 𝕌(:num) ⇒ PROD_SET (IMAGE f s) = Π f s
   
   [<a name="PROD_SET_IMAGE_EXP-val"><b>PROD_SET_IMAGE_EXP</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒
            ∀m. PROD_SET (IMAGE (λj. n ** j) (count m)) =
                n ** SUM_SET (count m)
   
   [<a name="PROD_SET_IMAGE_EXP_NONZERO-val"><b>PROD_SET_IMAGE_EXP_NONZERO</b></a>]  Theorem
      
      ⊢ ∀n m.
          PROD_SET (IMAGE (λj. n ** j) (count m)) =
          PROD_SET (IMAGE (λj. n ** j) (residue m))
   
   [<a name="PROD_SET_LESS-val"><b>PROD_SET_LESS</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ∧ s ≠ ∅ ∧ 0 ∉ s ⇒
            ∀f. INJ f s 𝕌(:num) ∧ (∀x. x &lt; f x) ⇒
                PROD_SET s &lt; PROD_SET (IMAGE f s)
   
   [<a name="PROD_SET_LESS_EQ-val"><b>PROD_SET_LESS_EQ</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒
            ∀f g.
              INJ f s 𝕌(:num) ∧ INJ g s 𝕌(:num) ∧ (∀x. x ∈ s ⇒ f x ≤ g x) ⇒
              PROD_SET (IMAGE f s) ≤ PROD_SET (IMAGE g s)
   
   [<a name="PROD_SET_LESS_SUC-val"><b>PROD_SET_LESS_SUC</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ∧ s ≠ ∅ ∧ 0 ∉ s ⇒ PROD_SET s &lt; PROD_SET (IMAGE SUC s)
   
   [<a name="PROD_SET_LE_CONSTANT-val"><b>PROD_SET_LE_CONSTANT</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀n. (∀x. x ∈ s ⇒ x ≤ n) ⇒ PROD_SET s ≤ n ** CARD s
   
   [<a name="PROD_SET_NONZERO-val"><b>PROD_SET_NONZERO</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ∧ 0 ∉ s ⇒ 0 &lt; PROD_SET s
   
   [<a name="PROD_SET_PRODUCT_BY_PARTITION-val"><b>PROD_SET_PRODUCT_BY_PARTITION</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒
            ∀u v. s =|= u # v ⇒ PROD_SET s = PROD_SET u * PROD_SET v
   
   [<a name="PROD_SET_PRODUCT_GE_CONSTANT-val"><b>PROD_SET_PRODUCT_GE_CONSTANT</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒
            ∀n f g.
              INJ f s 𝕌(:num) ∧ INJ g s 𝕌(:num) ∧
              (∀x. x ∈ s ⇒ n ≤ f x * g x) ⇒
              n ** CARD s ≤ PROD_SET (IMAGE f s) * PROD_SET (IMAGE g s)
   
   [<a name="PROD_SET_SING-val"><b>PROD_SET_SING</b></a>]  Theorem
      
      ⊢ ∀x. PROD_SET {x} = x
   
   [<a name="PUSH_IN_INTO_IF-val"><b>PUSH_IN_INTO_IF</b></a>]  Theorem
      
      ⊢ ∀b x s t. x ∈ (if b then s else t) ⇔ if b then x ∈ s else x ∈ t
   
   [<a name="SELF_LE_SQ-val"><b>SELF_LE_SQ</b></a>]  Theorem
      
      ⊢ ∀n. n ≤ n²
   
   [<a name="SET_EQ_BY_DIFF-val"><b>SET_EQ_BY_DIFF</b></a>]  Theorem
      
      ⊢ ∀s t. s = t ⇔ s ⊆ t ∧ t DIFF s = ∅
   
   [<a name="SIGMA_CARD_FACTOR-val"><b>SIGMA_CARD_FACTOR</b></a>]  Theorem
      
      ⊢ ∀n s.
          FINITE s ∧ (∀e. e ∈ s ⇒ n divides CARD e) ⇒ n divides ∑ CARD s
   
   [<a name="SING_SUBSET-val"><b>SING_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s x. {x} ⊆ s ∧ SING s ⇔ s = {x}
   
   [<a name="SPLIT_BY_SUBSET-val"><b>SPLIT_BY_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s u. u ⊆ s ⇒ (let v = s DIFF u in s =|= u # v)
   
   [<a name="SPLIT_CARD-val"><b>SPLIT_CARD</b></a>]  Theorem
      
      ⊢ ∀s u v. FINITE s ∧ s =|= u # v ⇒ CARD s = CARD u + CARD v
   
   [<a name="SPLIT_EMPTY-val"><b>SPLIT_EMPTY</b></a>]  Theorem
      
      ⊢ ∀s t. s =|= ∅ # t ⇔ s = t
   
   [<a name="SPLIT_EQ-val"><b>SPLIT_EQ</b></a>]  Theorem
      
      ⊢ ∀s u v. s =|= u # v ⇔ u ⊆ s ∧ v = s DIFF u
   
   [<a name="SPLIT_EQ_DIFF-val"><b>SPLIT_EQ_DIFF</b></a>]  Theorem
      
      ⊢ ∀s u v. s =|= u # v ⇔ u = s DIFF v ∧ v = s DIFF u
   
   [<a name="SPLIT_FINITE-val"><b>SPLIT_FINITE</b></a>]  Theorem
      
      ⊢ ∀s u v. FINITE s ∧ s =|= u # v ⇒ FINITE u ∧ FINITE v
   
   [<a name="SPLIT_SING-val"><b>SPLIT_SING</b></a>]  Theorem
      
      ⊢ ∀s v x. s =|= {x} # v ⇔ x ∈ s ∧ v = s DELETE x
   
   [<a name="SPLIT_SUBSETS-val"><b>SPLIT_SUBSETS</b></a>]  Theorem
      
      ⊢ ∀s u v. s =|= u # v ⇒ u ⊆ s ∧ v ⊆ s
   
   [<a name="SPLIT_SYM-val"><b>SPLIT_SYM</b></a>]  Theorem
      
      ⊢ ∀s u v. s =|= u # v ⇔ s =|= v # u
   
   [<a name="SPLIT_SYM_IMP-val"><b>SPLIT_SYM_IMP</b></a>]  Theorem
      
      ⊢ ∀s u v. s =|= u # v ⇒ s =|= v # u
   
   [<a name="SPLIT_UNION-val"><b>SPLIT_UNION</b></a>]  Theorem
      
      ⊢ ∀s u v a b.
          s =|= u # v ∧ v =|= a # b ⇒ s =|= u ∪ a # b ∧ u ∪ a =|= u # a
   
   [<a name="SQ_0-val"><b>SQ_0</b></a>]  Theorem
      
      ⊢ 0² = 0
   
   [<a name="SQ_EQ_0-val"><b>SQ_EQ_0</b></a>]  Theorem
      
      ⊢ ∀n. SQ n = 0 ⇔ n = 0
   
   [<a name="SQ_EQ_1-val"><b>SQ_EQ_1</b></a>]  Theorem
      
      ⊢ ∀n. SQ n = 1 ⇔ n = 1
   
   [<a name="SQ_EQ_SELF-val"><b>SQ_EQ_SELF</b></a>]  Theorem
      
      ⊢ ∀n. SQ n = n ⇔ n = 0 ∨ n = 1
   
   [<a name="SQ_LE-val"><b>SQ_LE</b></a>]  Theorem
      
      ⊢ ∀m n. m ≤ n ⇒ SQ m ≤ SQ n
   
   [<a name="SUBSET_CARD_EQ-val"><b>SUBSET_CARD_EQ</b></a>]  Theorem
      
      ⊢ ∀s t. FINITE t ∧ s ⊆ t ⇒ (CARD s = CARD t ⇔ s = t)
   
   [<a name="SUBSET_DIFF_CARD-val"><b>SUBSET_DIFF_CARD</b></a>]  Theorem
      
      ⊢ ∀a b. FINITE a ∧ b ⊆ a ⇒ CARD (a DIFF b) = CARD a − CARD b
   
   [<a name="SUBSET_DIFF_DIFF-val"><b>SUBSET_DIFF_DIFF</b></a>]  Theorem
      
      ⊢ ∀s t. t ⊆ s ⇒ s DIFF (s DIFF t) = t
   
   [<a name="SUBSET_DIFF_EQ-val"><b>SUBSET_DIFF_EQ</b></a>]  Theorem
      
      ⊢ ∀s1 s2 t. s1 ⊆ t ∧ s2 ⊆ t ∧ t DIFF s1 = t DIFF s2 ⇒ s1 = s2
   
   [<a name="SUBSET_INSERT_BOTH-val"><b>SUBSET_INSERT_BOTH</b></a>]  Theorem
      
      ⊢ ∀s1 s2 x. s1 ⊆ s2 ⇒ x INSERT s1 ⊆ x INSERT s2
   
   [<a name="SUBSET_INTER_SUBSET-val"><b>SUBSET_INTER_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t u. s ⊆ u ⇒ s ∩ t ⊆ u
   
   [<a name="SUBSET_SING_IFF-val"><b>SUBSET_SING_IFF</b></a>]  Theorem
      
      ⊢ ∀s x. s ⊆ {x} ⇔ s = ∅ ∨ s = {x}
   
   [<a name="SUB_DIV_EQN-val"><b>SUB_DIV_EQN</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; n ⇒ (m − n) DIV n = if m &lt; n then 0 else m DIV n − 1
   
   [<a name="SUB_EQ_ADD-val"><b>SUB_EQ_ADD</b></a>]  Theorem
      
      ⊢ ∀p. 0 &lt; p ⇒ ∀m n. m − n = p ⇔ m = n + p
   
   [<a name="SUB_MOD_EQN-val"><b>SUB_MOD_EQN</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; n ⇒ (m − n) MOD n = if m &lt; n then 0 else m MOD n
   
   [<a name="SUB_SUB_SUB-val"><b>SUB_SUB_SUB</b></a>]  Theorem
      
      ⊢ ∀a b c. c ≤ a ⇒ a − b − (a − c) = c − b
   
   [<a name="SUC_ADD_SUC-val"><b>SUC_ADD_SUC</b></a>]  Theorem
      
      ⊢ ∀m n. SUC m + SUC n = m + n + 2
   
   [<a name="SUC_EQ-val"><b>SUC_EQ</b></a>]  Theorem
      
      ⊢ ∀m n. SUC m = SUC n ⇔ m = n
   
   [<a name="SUC_EXISTS-val"><b>SUC_EXISTS</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∃m. n = SUC m
   
   [<a name="SUC_MAX-val"><b>SUC_MAX</b></a>]  Theorem
      
      ⊢ ∀m n. SUC (MAX m n) = MAX (SUC m) (SUC n)
   
   [<a name="SUC_MIN-val"><b>SUC_MIN</b></a>]  Theorem
      
      ⊢ ∀m n. SUC (MIN m n) = MIN (SUC m) (SUC n)
   
   [<a name="SUC_MULT_SUC-val"><b>SUC_MULT_SUC</b></a>]  Theorem
      
      ⊢ ∀m n. SUC m * SUC n = m * n + m + n + 1
   
   [<a name="SUC_SQ-val"><b>SUC_SQ</b></a>]  Theorem
      
      ⊢ ∀n. (SUC n)² = SUC n² + TWICE n
   
   [<a name="SUC_X_LT_2_EXP_X-val"><b>SUC_X_LT_2_EXP_X</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ SUC n &lt; 2 ** n
   
   [<a name="SUM_IMAGE_AS_SUM_SET-val"><b>SUM_IMAGE_AS_SUM_SET</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒
            ∀f. (∀x y. f x = f y ⇒ x = y) ⇒ ∑ f s = SUM_SET (IMAGE f s)
   
   [<a name="SUM_IMAGE_DOUBLET-val"><b>SUM_IMAGE_DOUBLET</b></a>]  Theorem
      
      ⊢ ∀f x y. x ≠ y ⇒ ∑ f {x; y} = f x + f y
   
   [<a name="SUM_IMAGE_PSUBSET_LT-val"><b>SUM_IMAGE_PSUBSET_LT</b></a>]  Theorem
      
      ⊢ ∀f s t. FINITE s ∧ t ⊂ s ∧ (∀x. x ∈ s ⇒ f x ≠ 0) ⇒ ∑ f t &lt; ∑ f s
   
   [<a name="SUM_IMAGE_TRIPLET-val"><b>SUM_IMAGE_TRIPLET</b></a>]  Theorem
      
      ⊢ ∀f x y z. x ≠ y ∧ y ≠ z ∧ z ≠ x ⇒ ∑ f {x; y; z} = f x + f y + f z
   
   [<a name="SUM_LE_PRODUCT-val"><b>SUM_LE_PRODUCT</b></a>]  Theorem
      
      ⊢ ∀m n. 1 &lt; m ∧ 1 &lt; n ⇒ m + n ≤ m * n
   
   [<a name="SUM_SET_COUNT-val"><b>SUM_SET_COUNT</b></a>]  Theorem
      
      ⊢ ∀n. SUM_SET (count n) = HALF (n * (n − 1))
   
   [<a name="SUM_SET_IMAGE_EQN-val"><b>SUM_SET_IMAGE_EQN</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀f. INJ f s 𝕌(:num) ⇒ SUM_SET (IMAGE f s) = ∑ f s
   
   [<a name="SURJ_CARD_IMAGE-val"><b>SURJ_CARD_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s t. SURJ f s t ⇒ CARD (IMAGE f s) = CARD t
   
   [<a name="THREE-val"><b>THREE</b></a>]  Theorem
      
      ⊢ 3 = SUC 2
   
   [<a name="TWICE_EQ_0-val"><b>TWICE_EQ_0</b></a>]  Theorem
      
      ⊢ ∀n. TWICE n = 0 ⇔ n = 0
   
   [<a name="TWO_HALF_LE_THM-val"><b>TWO_HALF_LE_THM</b></a>]  Theorem
      
      ⊢ ∀n. TWICE (HALF n) ≤ n ∧ n ≤ SUC (TWICE (HALF n))
   
   [<a name="TWO_HALF_TIMES_LE-val"><b>TWO_HALF_TIMES_LE</b></a>]  Theorem
      
      ⊢ ∀m n. TWICE (HALF n * m) ≤ n * m
   
   [<a name="TWO_LE_PRIME-val"><b>TWO_LE_PRIME</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇒ 2 ≤ p
   
   [<a name="UNION_DIFF_EQ_UNION-val"><b>UNION_DIFF_EQ_UNION</b></a>]  Theorem
      
      ⊢ ∀s t. s ∪ (t DIFF s) = s ∪ t
   
   [<a name="ZERO_LE_ALL-val"><b>ZERO_LE_ALL</b></a>]  Theorem
      
      ⊢ ∀n. 0 ≤ n
   
   [<a name="binomial_2-val"><b>binomial_2</b></a>]  Theorem
      
      ⊢ ∀m n. (m + n)² = m² + n² + TWICE m * n
   
   [<a name="binomial_add-val"><b>binomial_add</b></a>]  Theorem
      
      ⊢ ∀a b. (a + b)² = a² + b² + TWICE a * b
   
   [<a name="binomial_means-val"><b>binomial_means</b></a>]  Theorem
      
      ⊢ ∀a b. TWICE a * b ≤ a² + b²
   
   [<a name="binomial_sub-val"><b>binomial_sub</b></a>]  Theorem
      
      ⊢ ∀a b. b ≤ a ⇒ (a − b)² = a² + b² − TWICE a * b
   
   [<a name="binomial_sub_add-val"><b>binomial_sub_add</b></a>]  Theorem
      
      ⊢ ∀a b. b ≤ a ⇒ (a − b)² + 4 * a * b = (a + b)²
   
   [<a name="binomial_sub_sum-val"><b>binomial_sub_sum</b></a>]  Theorem
      
      ⊢ ∀a b. b ≤ a ⇒ (a − b)² + TWICE a * b = a² + b²
   
   [<a name="card_eq_sigma_card-val"><b>card_eq_sigma_card</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ∧ (∀e. e ∈ s ⇒ CARD e ≠ 0) ∧ CARD s = ∑ CARD s ⇒
            ∀e. e ∈ s ⇒ CARD e = 1
   
   [<a name="card_le_sigma_card-val"><b>card_le_sigma_card</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ∧ (∀e. e ∈ s ⇒ CARD e ≠ 0) ⇒ CARD s ≤ ∑ CARD s
   
   [<a name="card_mod_image-val"><b>card_mod_image</b></a>]  Theorem
      
      ⊢ ∀s n. 0 &lt; n ⇒ CARD (IMAGE (λx. x MOD n) s) ≤ n
   
   [<a name="card_mod_image_nonzero-val"><b>card_mod_image_nonzero</b></a>]  Theorem
      
      ⊢ ∀s n.
          0 &lt; n ∧ 0 ∉ IMAGE (λx. x MOD n) s ⇒
          CARD (IMAGE (λx. x MOD n) s) &lt; n
   
   [<a name="coprime_all_le_imp_lt-val"><b>coprime_all_le_imp_lt</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ ∀m. (∀j. 0 &lt; j ∧ j ≤ m ⇒ coprime n j) ⇒ m &lt; n
   
   [<a name="coprime_by_le_not_divides-val"><b>coprime_by_le_not_divides</b></a>]  Theorem
      
      ⊢ ∀m n. 1 &lt; m ∧ (∀j. 1 &lt; j ∧ j ≤ m ⇒ ¬(j divides n)) ⇒ coprime m n
   
   [<a name="coprime_condition-val"><b>coprime_condition</b></a>]  Theorem
      
      ⊢ ∀m n.
          (∀j. 1 &lt; j ∧ j ≤ m ⇒ ¬(j divides n)) ⇔
          ∀j. 1 &lt; j ∧ j ≤ m ⇒ coprime j n
   
   [<a name="coprime_iff_coprime_exp-val"><b>coprime_iff_coprime_exp</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀a b. coprime a b ⇔ coprime a (b ** n)
   
   [<a name="coprime_linear_mod_prod-val"><b>coprime_linear_mod_prod</b></a>]  Theorem
      
      ⊢ ∀a b.
          0 &lt; a ∧ 0 &lt; b ∧ coprime a b ⇒
          ∃p q. (p * a + q * b) MOD (a * b) = 1 MOD (a * b)
   
   [<a name="coprime_linear_mult-val"><b>coprime_linear_mult</b></a>]  Theorem
      
      ⊢ ∀a b p q.
          coprime a b ∧ coprime p b ∧ coprime q a ⇒
          coprime (p * a + q * b) (a * b)
   
   [<a name="coprime_linear_mult_iff-val"><b>coprime_linear_mult_iff</b></a>]  Theorem
      
      ⊢ ∀a b p q.
          coprime a b ⇒
          (coprime p b ∧ coprime q a ⇔ coprime (p * a + q * b) (a * b))
   
   [<a name="coprime_mod_mod_prod_eq-val"><b>coprime_mod_mod_prod_eq</b></a>]  Theorem
      
      ⊢ ∀m n a b.
          0 &lt; m ∧ 0 &lt; n ∧ coprime m n ∧ a MOD m = b MOD m ∧
          a MOD n = b MOD n ⇒
          a MOD (m * n) = b MOD (m * n)
   
   [<a name="coprime_mod_mod_prod_eq_iff-val"><b>coprime_mod_mod_prod_eq_iff</b></a>]  Theorem
      
      ⊢ ∀m n.
          0 &lt; m ∧ 0 &lt; n ∧ coprime m n ⇒
          ∀a b.
            a MOD (m * n) = b MOD (m * n) ⇔
            a MOD m = b MOD m ∧ a MOD n = b MOD n
   
   [<a name="coprime_mod_mod_solve-val"><b>coprime_mod_mod_solve</b></a>]  Theorem
      
      ⊢ ∀m n a b.
          0 &lt; m ∧ 0 &lt; n ∧ coprime m n ⇒
          ∃!x. x &lt; m * n ∧ x MOD m = a MOD m ∧ x MOD n = b MOD n
   
   [<a name="coprime_multiple_linear_mod_prod-val"><b>coprime_multiple_linear_mod_prod</b></a>]  Theorem
      
      ⊢ ∀a b c.
          0 &lt; a ∧ 0 &lt; b ∧ coprime a b ⇒
          ∃p q. (p * a + q * b) MOD (a * b) = c MOD (a * b)
   
   [<a name="coprime_not_divides-val"><b>coprime_not_divides</b></a>]  Theorem
      
      ⊢ ∀m n. 1 &lt; n ∧ coprime n m ⇒ ¬(n divides m)
   
   [<a name="coprime_power_and_power_predecessor-val"><b>coprime_power_and_power_predecessor</b></a>]  Theorem
      
      ⊢ ∀b m n. 0 &lt; b ∧ 0 &lt; m ⇒ coprime (b ** n) (tops b m)
   
   [<a name="coprime_power_and_power_successor-val"><b>coprime_power_and_power_successor</b></a>]  Theorem
      
      ⊢ ∀b m n. 0 &lt; b ∧ 0 &lt; m ⇒ coprime (b ** n) (b ** m + 1)
   
   [<a name="coprime_prime_power-val"><b>coprime_prime_power</b></a>]  Theorem
      
      ⊢ ∀p n. prime p ∧ 0 &lt; n ⇒ ∀q. coprime q (p ** n) ⇔ ¬(p divides q)
   
   [<a name="countFrom_0-val"><b>countFrom_0</b></a>]  Theorem
      
      ⊢ ∀m. countFrom m 0 = ∅
   
   [<a name="countFrom_SUC-val"><b>countFrom_SUC</b></a>]  Theorem
      
      ⊢ ∀m n m n. countFrom m (SUC n) = m INSERT countFrom (m + 1) n
   
   [<a name="countFrom_first-val"><b>countFrom_first</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; n ⇒ m ∈ countFrom m n
   
   [<a name="countFrom_less-val"><b>countFrom_less</b></a>]  Theorem
      
      ⊢ ∀m n x. x &lt; m ⇒ x ∉ countFrom m n
   
   [<a name="count_SUC_by_countFrom-val"><b>count_SUC_by_countFrom</b></a>]  Theorem
      
      ⊢ ∀n. upto n = 0 INSERT countFrom 1 n
   
   [<a name="count_by_countFrom-val"><b>count_by_countFrom</b></a>]  Theorem
      
      ⊢ ∀n. count n = countFrom 0 n
   
   [<a name="difference_of_squares-val"><b>difference_of_squares</b></a>]  Theorem
      
      ⊢ ∀a b. a² − b² = (a − b) * (a + b)
   
   [<a name="difference_of_squares_alt-val"><b>difference_of_squares_alt</b></a>]  Theorem
      
      ⊢ ∀a b. SQ a − SQ b = (a − b) * (a + b)
   
   [<a name="disjoint_bigunion_add_fun-val"><b>disjoint_bigunion_add_fun</b></a>]  Theorem
      
      ⊢ ∀P. FINITE P ∧ EVERY_FINITE P ∧ PAIR_DISJOINT P ⇒
            ∀f. SET_ADDITIVE f ⇒ f (BIGUNION P) = ∑ f P
   
   [<a name="disjoint_bigunion_card-val"><b>disjoint_bigunion_card</b></a>]  Theorem
      
      ⊢ ∀P. FINITE P ∧ EVERY_FINITE P ∧ PAIR_DISJOINT P ⇒
            CARD (BIGUNION P) = ∑ CARD P
   
   [<a name="disjoint_bigunion_mult_fun-val"><b>disjoint_bigunion_mult_fun</b></a>]  Theorem
      
      ⊢ ∀P. FINITE P ∧ EVERY_FINITE P ∧ PAIR_DISJOINT P ⇒
            ∀f. SET_MULTIPLICATIVE f ⇒ f (BIGUNION P) = Π f P
   
   [<a name="disjoint_bigunion_sigma-val"><b>disjoint_bigunion_sigma</b></a>]  Theorem
      
      ⊢ ∀P. FINITE P ∧ EVERY_FINITE P ∧ PAIR_DISJOINT P ⇒
            ∀f. ∑ f (BIGUNION P) = ∑ (∑ f) P
   
   [<a name="dividend_divides_divisor_multiple-val"><b>dividend_divides_divisor_multiple</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ∧ n divides m ⇒ ∀t. m divides t * n ⇔ m DIV n divides t
   
   [<a name="divides_eq_thm-val"><b>divides_eq_thm</b></a>]  Theorem
      
      ⊢ ∀a b. a divides b ∧ 0 &lt; b ∧ b &lt; TWICE a ⇒ b = a
   
   [<a name="divides_iff_equal-val"><b>divides_iff_equal</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; n ∧ n &lt; TWICE m ⇒ (m divides n ⇔ n = m)
   
   [<a name="divides_self_power-val"><b>divides_self_power</b></a>]  Theorem
      
      ⊢ ∀n p. 0 &lt; n ∧ 1 &lt; p ⇒ p divides p ** n
   
   [<a name="equal_partition_card-val"><b>equal_partition_card</b></a>]  Theorem
      
      ⊢ ∀R s n.
          FINITE s ∧ R equiv_on s ∧ (∀e. e ∈ partition R s ⇒ CARD e = n) ⇒
          CARD s = n * CARD (partition R s)
   
   [<a name="equal_partition_factor-val"><b>equal_partition_factor</b></a>]  Theorem
      
      ⊢ ∀R s n.
          FINITE s ∧ R equiv_on s ∧ (∀e. e ∈ partition R s ⇒ CARD e = n) ⇒
          n divides CARD s
   
   [<a name="equiv_class_element-val"><b>equiv_class_element</b></a>]  Theorem
      
      ⊢ ∀R s x y. y ∈ equiv_class R s x ⇔ y ∈ s ∧ R x y
   
   [<a name="equiv_class_not_empty-val"><b>equiv_class_not_empty</b></a>]  Theorem
      
      ⊢ ∀R s x. R equiv_on s ∧ x ∈ s ⇒ equiv_class R s x ≠ ∅
   
   [<a name="euclid_coprime-val"><b>euclid_coprime</b></a>]  Theorem
      
      ⊢ ∀a b c. coprime a b ∧ b divides a * c ⇒ b divides c
   
   [<a name="euclid_prime-val"><b>euclid_prime</b></a>]  Theorem
      
      ⊢ ∀p a b. prime p ∧ p divides a * b ⇒ p divides a ∨ p divides b
   
   [<a name="every_coprime_prod_set_coprime-val"><b>every_coprime_prod_set_coprime</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒
            ∀x. x ∉ s ∧ (∀z. z ∈ s ⇒ coprime x z) ⇒ coprime x (PROD_SET s)
   
   [<a name="factor_eq_cofactor-val"><b>factor_eq_cofactor</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ∧ m divides n ⇒ (m = n DIV m ⇔ n = m²)
   
   [<a name="factor_partition_card-val"><b>factor_partition_card</b></a>]  Theorem
      
      ⊢ ∀R s n.
          FINITE s ∧ R equiv_on s ∧
          (∀e. e ∈ partition R s ⇒ n divides CARD e) ⇒
          n divides CARD s
   
   [<a name="feq_class_element-val"><b>feq_class_element</b></a>]  Theorem
      
      ⊢ ∀f s x y. x ∈ preimage f s y ⇔ x ∈ s ∧ f x = y
   
   [<a name="feq_class_fun-val"><b>feq_class_fun</b></a>]  Theorem
      
      ⊢ ∀f s. preimage f s ∘ f = (λx. equiv_class (feq f) s x)
   
   [<a name="feq_class_property-val"><b>feq_class_property</b></a>]  Theorem
      
      ⊢ ∀f s x. preimage f s (f x) = equiv_class (feq f) s x
   
   [<a name="feq_equiv-val"><b>feq_equiv</b></a>]  Theorem
      
      ⊢ ∀s f. feq f equiv_on s
   
   [<a name="feq_partition-val"><b>feq_partition</b></a>]  Theorem
      
      ⊢ ∀s f. partition (feq f) s = IMAGE (preimage f s ∘ f) s
   
   [<a name="feq_partition_element-val"><b>feq_partition_element</b></a>]  Theorem
      
      ⊢ ∀s f t.
          t ∈ partition (feq f) s ⇔
          ∃z. z ∈ s ∧ ∀x. x ∈ t ⇔ x ∈ s ∧ f x = f z
   
   [<a name="feq_partition_element_exists-val"><b>feq_partition_element_exists</b></a>]  Theorem
      
      ⊢ ∀f s x. x ∈ s ⇔ ∃e. e ∈ partition (feq f) s ∧ x ∈ e
   
   [<a name="feq_partition_element_not_empty-val"><b>feq_partition_element_not_empty</b></a>]  Theorem
      
      ⊢ ∀f s e. e ∈ partition (feq f) s ⇒ e ≠ ∅
   
   [<a name="feq_sum_over_partition-val"><b>feq_sum_over_partition</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀f g. ∑ g s = ∑ (∑ g) (partition (feq f) s)
   
   [<a name="fequiv_equiv_class-val"><b>fequiv_equiv_class</b></a>]  Theorem
      
      ⊢ ∀f. (λx y. (x == y) f) equiv_on 𝕌(:α)
   
   [<a name="fequiv_refl-val"><b>fequiv_refl</b></a>]  Theorem
      
      ⊢ ∀f x. (x == x) f
   
   [<a name="fequiv_sym-val"><b>fequiv_sym</b></a>]  Theorem
      
      ⊢ ∀f x y. (x == y) f ⇒ (y == x) f
   
   [<a name="fequiv_trans-val"><b>fequiv_trans</b></a>]  Theorem
      
      ⊢ ∀f x y z. (x == y) f ∧ (y == z) f ⇒ (x == z) f
   
   [<a name="finite_card_by_feq_partition-val"><b>finite_card_by_feq_partition</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀f. CARD s = ∑ CARD (partition (feq f) s)
   
   [<a name="finite_card_by_image_preimage-val"><b>finite_card_by_image_preimage</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀f. CARD s = ∑ CARD (IMAGE (preimage f s ∘ f) s)
   
   [<a name="finite_card_surj_by_image_preimage-val"><b>finite_card_surj_by_image_preimage</b></a>]  Theorem
      
      ⊢ ∀f s t.
          FINITE s ∧ SURJ f s t ⇒ CARD s = ∑ CARD (IMAGE (preimage f s) t)
   
   [<a name="finite_partition_by_predicate-val"><b>finite_partition_by_predicate</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒
            ∀P. (let
                   u = {x | x ∈ s ∧ P x};
                   v = {x | x ∈ s ∧ ¬P x}
                 in
                   FINITE u ∧ FINITE v ∧ s =|= u # v)
   
   [<a name="finite_partition_property-val"><b>finite_partition_property</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀u v. s =|= u # v ⇒ (u = ∅ ⇔ v = s)
   
   [<a name="fit_for_10-val"><b>fit_for_10</b></a>]  Theorem
      
      ⊢ 1 + 2 + 3 + 4 = 10
   
   [<a name="fit_for_100-val"><b>fit_for_100</b></a>]  Theorem
      
      ⊢ 1 * 2 + 3 * 4 + 5 * 6 + 7 * 8 = 100
   
   [<a name="gcd_divides_iff-val"><b>gcd_divides_iff</b></a>]  Theorem
      
      ⊢ ∀a b c. 0 &lt; a ⇒ (gcd a b divides c ⇔ ∃p q. p * a = q * b + c)
   
   [<a name="gcd_le-val"><b>gcd_le</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ∧ 0 &lt; n ⇒ gcd m n ≤ m ∧ gcd m n ≤ n
   
   [<a name="gcd_linear_mod_1-val"><b>gcd_linear_mod_1</b></a>]  Theorem
      
      ⊢ ∀a b. 0 &lt; a ⇒ ∃q. (q * b) MOD a = gcd a b MOD a
   
   [<a name="gcd_linear_mod_2-val"><b>gcd_linear_mod_2</b></a>]  Theorem
      
      ⊢ ∀a b. 0 &lt; b ⇒ ∃p. (p * a) MOD b = gcd a b MOD b
   
   [<a name="gcd_linear_mod_prod-val"><b>gcd_linear_mod_prod</b></a>]  Theorem
      
      ⊢ ∀a b.
          0 &lt; a ∧ 0 &lt; b ⇒
          ∃p q. (p * a + q * b) MOD (a * b) = gcd a b MOD (a * b)
   
   [<a name="gcd_linear_mod_thm-val"><b>gcd_linear_mod_thm</b></a>]  Theorem
      
      ⊢ ∀n a b. 0 &lt; n ∧ 0 &lt; a ⇒ ∃p q. (p * a + q * b) MOD n = gcd a b MOD n
   
   [<a name="gcd_linear_thm-val"><b>gcd_linear_thm</b></a>]  Theorem
      
      ⊢ ∀a b c. 0 &lt; a ⇒ (gcd a b divides c ⇔ ∃p q. p * a = q * b + c)
   
   [<a name="gcd_multiple_linear_mod_prod-val"><b>gcd_multiple_linear_mod_prod</b></a>]  Theorem
      
      ⊢ ∀a b c.
          0 &lt; a ∧ 0 &lt; b ∧ gcd a b divides c ⇒
          ∃p q. (p * a + q * b) MOD (a * b) = c MOD (a * b)
   
   [<a name="gcd_multiple_linear_mod_thm-val"><b>gcd_multiple_linear_mod_thm</b></a>]  Theorem
      
      ⊢ ∀n a b c.
          0 &lt; n ∧ 0 &lt; a ∧ gcd a b divides c ⇒
          ∃p q. (p * a + q * b) MOD n = c MOD n
   
   [<a name="gcd_powers-val"><b>gcd_powers</b></a>]  Theorem
      
      ⊢ ∀b m n. gcd (b ** m) (b ** n) = b ** MIN m n
   
   [<a name="image_mod_subset_count-val"><b>image_mod_subset_count</b></a>]  Theorem
      
      ⊢ ∀s n. 0 &lt; n ⇒ IMAGE (λx. x MOD n) s ⊆ count n
   
   [<a name="in_preimage-val"><b>in_preimage</b></a>]  Theorem
      
      ⊢ ∀f s x y. x ∈ preimage f s y ⇔ x ∈ s ∧ f x = y
   
   [<a name="in_prime-val"><b>in_prime</b></a>]  Theorem
      
      ⊢ ∀p. p ∈ prime ⇔ prime p
   
   [<a name="inj_iff_partition_element_card_1-val"><b>inj_iff_partition_element_card_1</b></a>]  Theorem
      
      ⊢ ∀f s.
          FINITE s ⇒
          (INJ f s (IMAGE f s) ⇔ ∀e. e ∈ partition (feq f) s ⇒ CARD e = 1)
   
   [<a name="inj_iff_partition_element_sing-val"><b>inj_iff_partition_element_sing</b></a>]  Theorem
      
      ⊢ ∀f s. INJ f s (IMAGE f s) ⇔ ∀e. e ∈ partition (feq f) s ⇒ SING e
   
   [<a name="lcm_powers-val"><b>lcm_powers</b></a>]  Theorem
      
      ⊢ ∀b m n. lcm (b ** m) (b ** n) = b ** MAX m n
   
   [<a name="listRangeINC_sublist-val"><b>listRangeINC_sublist</b></a>]  Theorem
      
      ⊢ ∀m n. m &lt; n ⇒ [m; n] ≤ [m .. n]
   
   [<a name="listRangeLHI_sublist-val"><b>listRangeLHI_sublist</b></a>]  Theorem
      
      ⊢ ∀m n. m + 1 &lt; n ⇒ [m; n − 1] ≤ [m ..&lt; n]
   
   [<a name="mod_add_eq_sub-val"><b>mod_add_eq_sub</b></a>]  Theorem
      
      ⊢ ∀n a b c d.
          b &lt; n ∧ c &lt; n ⇒
          ((a + b) MOD n = (c + d) MOD n ⇔
           (a + (n − c)) MOD n = (d + (n − b)) MOD n)
   
   [<a name="mod_add_eq_sub_eq-val"><b>mod_add_eq_sub_eq</b></a>]  Theorem
      
      ⊢ ∀n a b c d.
          0 &lt; n ⇒
          ((a + b) MOD n = (c + d) MOD n ⇔
           (a + (n − c MOD n)) MOD n = (d + (n − b MOD n)) MOD n)
   
   [<a name="mod_divides-val"><b>mod_divides</b></a>]  Theorem
      
      ⊢ ∀n a b. 0 &lt; n ∧ b divides n ∧ b divides a MOD n ⇒ b divides a
   
   [<a name="mod_divides_divides-val"><b>mod_divides_divides</b></a>]  Theorem
      
      ⊢ ∀n a b c.
          0 &lt; n ∧ a MOD n = b ∧ c divides n ∧ c divides a ⇒ c divides b
   
   [<a name="mod_divides_divides_iff-val"><b>mod_divides_divides_iff</b></a>]  Theorem
      
      ⊢ ∀n a b c.
          0 &lt; n ∧ a MOD n = b ∧ c divides n ⇒ (c divides a ⇔ c divides b)
   
   [<a name="mod_divides_iff-val"><b>mod_divides_iff</b></a>]  Theorem
      
      ⊢ ∀n a b. 0 &lt; n ∧ b divides n ⇒ (b divides a MOD n ⇔ b divides a)
   
   [<a name="mod_eq_divides-val"><b>mod_eq_divides</b></a>]  Theorem
      
      ⊢ ∀n a b c.
          0 &lt; n ∧ a MOD n = b MOD n ∧ c divides n ∧ c divides a ⇒
          c divides b
   
   [<a name="mod_eq_divides_iff-val"><b>mod_eq_divides_iff</b></a>]  Theorem
      
      ⊢ ∀n a b c.
          0 &lt; n ∧ a MOD n = b MOD n ∧ c divides n ⇒
          (c divides a ⇔ c divides b)
   
   [<a name="mod_mod_prod_eq-val"><b>mod_mod_prod_eq</b></a>]  Theorem
      
      ⊢ ∀m n a b.
          0 &lt; m ∧ 0 &lt; n ∧ a MOD (m * n) = b MOD (m * n) ⇒
          a MOD m = b MOD m ∧ a MOD n = b MOD n
   
   [<a name="mod_mult_eq_mult-val"><b>mod_mult_eq_mult</b></a>]  Theorem
      
      ⊢ ∀m n a b.
          coprime m n ∧ 0 &lt; a ∧ a &lt; TWICE n ∧ 0 &lt; b ∧ b &lt; TWICE m ∧
          (m * a) MOD (m * n) = (n * b) MOD (m * n) ⇒
          a = n ∧ b = m
   
   [<a name="natural_by_upto-val"><b>natural_by_upto</b></a>]  Theorem
      
      ⊢ ∀n. natural n = upto n DELETE 0
   
   [<a name="natural_thm-val"><b>natural_thm</b></a>]  Theorem
      
      ⊢ ∀n. natural n = set (GENLIST SUC n)
   
   [<a name="nines_divisibility-val"><b>nines_divisibility</b></a>]  Theorem
      
      ⊢ ∀n m. nines n divides nines m ⇔ n divides m
   
   [<a name="nines_division_alt-val"><b>nines_division_alt</b></a>]  Theorem
      
      ⊢ ∀m n. m ≤ n ⇒ nines n − 10 ** (n − m) * nines m = nines (n − m)
   
   [<a name="nines_division_eqn-val"><b>nines_division_eqn</b></a>]  Theorem
      
      ⊢ ∀m n. m ≤ n ⇒ nines n = 10 ** (n − m) * nines m + nines (n − m)
   
   [<a name="nines_divisor-val"><b>nines_divisor</b></a>]  Theorem
      
      ⊢ ∀n. 9 divides nines n
   
   [<a name="nines_gcd_identity-val"><b>nines_gcd_identity</b></a>]  Theorem
      
      ⊢ ∀n m. gcd (nines n) (nines m) = nines (gcd n m)
   
   [<a name="nines_gcd_reduction-val"><b>nines_gcd_reduction</b></a>]  Theorem
      
      ⊢ ∀n m.
          m ≤ n ⇒ gcd (nines n) (nines m) = gcd (nines m) (nines (n − m))
   
   [<a name="pair_disjoint_subset-val"><b>pair_disjoint_subset</b></a>]  Theorem
      
      ⊢ ∀s t. t ⊆ s ∧ PAIR_DISJOINT s ⇒ PAIR_DISJOINT t
   
   [<a name="pairwise_coprime_insert-val"><b>pairwise_coprime_insert</b></a>]  Theorem
      
      ⊢ ∀s e.
          e ∉ s ∧ PAIRWISE_COPRIME (e INSERT s) ⇒
          (∀x. x ∈ s ⇒ coprime e x) ∧ PAIRWISE_COPRIME s
   
   [<a name="pairwise_coprime_partition_coprime-val"><b>pairwise_coprime_partition_coprime</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ∧ PAIRWISE_COPRIME s ⇒
            ∀u v. s =|= u # v ⇒ coprime (PROD_SET u) (PROD_SET v)
   
   [<a name="pairwise_coprime_prod_set_partition-val"><b>pairwise_coprime_prod_set_partition</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ∧ PAIRWISE_COPRIME s ⇒
            ∀u v.
              s =|= u # v ⇒
              PROD_SET s = PROD_SET u * PROD_SET v ∧
              coprime (PROD_SET u) (PROD_SET v)
   
   [<a name="pairwise_coprime_prod_set_subset_divides-val"><b>pairwise_coprime_prod_set_subset_divides</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ∧ PAIRWISE_COPRIME s ⇒
            ∀t. t ⊆ s ⇒ PROD_SET t divides PROD_SET s
   
   [<a name="partition_as_image-val"><b>partition_as_image</b></a>]  Theorem
      
      ⊢ ∀R s. partition R s = IMAGE (λx. equiv_class R s x) s
   
   [<a name="partition_by_element-val"><b>partition_by_element</b></a>]  Theorem
      
      ⊢ ∀s x. x ∈ s ⇒ s =|= {x} # s DELETE x
   
   [<a name="partition_by_subset-val"><b>partition_by_subset</b></a>]  Theorem
      
      ⊢ ∀s u. u ⊆ s ⇒ (let v = s DIFF u in s =|= u # v)
   
   [<a name="partition_cong-val"><b>partition_cong</b></a>]  Theorem
      
      ⊢ ∀R1 R2 s1 s2. R1 = R2 ∧ s1 = s2 ⇒ partition R1 s1 = partition R2 s2
   
   [<a name="partition_element-val"><b>partition_element</b></a>]  Theorem
      
      ⊢ ∀R s t. t ∈ partition R s ⇔ ∃x. x ∈ s ∧ t = equiv_class R s x
   
   [<a name="partition_element_exists-val"><b>partition_element_exists</b></a>]  Theorem
      
      ⊢ ∀R s x. R equiv_on s ⇒ (x ∈ s ⇔ ∃e. e ∈ partition R s ∧ x ∈ e)
   
   [<a name="partition_element_not_empty-val"><b>partition_element_not_empty</b></a>]  Theorem
      
      ⊢ ∀R s e. R equiv_on s ∧ e ∈ partition R s ⇒ e ≠ ∅
   
   [<a name="partition_elements-val"><b>partition_elements</b></a>]  Theorem
      
      ⊢ ∀R s. partition R s = IMAGE (λx. equiv_class R s x) s
   
   [<a name="partition_on_empty-val"><b>partition_on_empty</b></a>]  Theorem
      
      ⊢ ∀R. partition R ∅ = ∅
   
   [<a name="power_divides_iff-val"><b>power_divides_iff</b></a>]  Theorem
      
      ⊢ ∀p. 1 &lt; p ⇒ ∀m n. p ** m divides p ** n ⇔ m ≤ n
   
   [<a name="power_eq_prime_power-val"><b>power_eq_prime_power</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇒
            ∀b n m. 0 &lt; m ∧ b ** n = p ** m ⇒ ∃k. b = p ** k ∧ k * n = m
   
   [<a name="power_parity-val"><b>power_parity</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀m. (EVEN m ⇔ EVEN (m ** n)) ∧ (ODD m ⇔ ODD (m ** n))
   
   [<a name="power_predecessor_divisibility-val"><b>power_predecessor_divisibility</b></a>]  Theorem
      
      ⊢ ∀t n m. 1 &lt; t ⇒ (tops t n divides tops t m ⇔ n divides m)
   
   [<a name="power_predecessor_division_alt-val"><b>power_predecessor_division_alt</b></a>]  Theorem
      
      ⊢ ∀t m n.
          0 &lt; t ∧ m ≤ n ⇒
          tops t n − t ** (n − m) * tops t m = tops t (n − m)
   
   [<a name="power_predecessor_division_eqn-val"><b>power_predecessor_division_eqn</b></a>]  Theorem
      
      ⊢ ∀t m n.
          0 &lt; t ∧ m ≤ n ⇒
          tops t n = t ** (n − m) * tops t m + tops t (n − m)
   
   [<a name="power_predecessor_divisor-val"><b>power_predecessor_divisor</b></a>]  Theorem
      
      ⊢ ∀t n. t − 1 divides tops t n
   
   [<a name="power_predecessor_gcd_identity-val"><b>power_predecessor_gcd_identity</b></a>]  Theorem
      
      ⊢ ∀t n m. gcd (tops t n) (tops t m) = tops t (gcd n m)
   
   [<a name="power_predecessor_gcd_reduction-val"><b>power_predecessor_gcd_reduction</b></a>]  Theorem
      
      ⊢ ∀t n m.
          m ≤ n ⇒
          gcd (tops t n) (tops t m) = gcd (tops t m) (tops t (n − m))
   
   [<a name="preimage_alt-val"><b>preimage_alt</b></a>]  Theorem
      
      ⊢ ∀f s y. preimage f s y = PREIMAGE f {y} ∩ s
   
   [<a name="preimage_choice_property-val"><b>preimage_choice_property</b></a>]  Theorem
      
      ⊢ ∀f s y.
          y ∈ IMAGE f s ⇒
          CHOICE (preimage f s y) ∈ s ∧ f (CHOICE (preimage f s y)) = y
   
   [<a name="preimage_element-val"><b>preimage_element</b></a>]  Theorem
      
      ⊢ ∀f s x y. x ∈ preimage f s y ⇔ x ∈ s ∧ f x = y
   
   [<a name="preimage_finite-val"><b>preimage_finite</b></a>]  Theorem
      
      ⊢ ∀f s y. FINITE s ⇒ FINITE (preimage f s y)
   
   [<a name="preimage_image_bij-val"><b>preimage_image_bij</b></a>]  Theorem
      
      ⊢ ∀f s. BIJ (preimage f s) (IMAGE f s) (partition (feq f) s)
   
   [<a name="preimage_image_inj-val"><b>preimage_image_inj</b></a>]  Theorem
      
      ⊢ ∀f s. INJ (preimage f s) (IMAGE f s) (POW s)
   
   [<a name="preimage_inj-val"><b>preimage_inj</b></a>]  Theorem
      
      ⊢ ∀f s. INJ f s 𝕌(:β) ⇒ ∀x. x ∈ s ⇒ preimage f s (f x) = {x}
   
   [<a name="preimage_inj_choice-val"><b>preimage_inj_choice</b></a>]  Theorem
      
      ⊢ ∀f s. INJ f s 𝕌(:β) ⇒ ∀x. x ∈ s ⇒ CHOICE (preimage f s (f x)) = x
   
   [<a name="preimage_of_image-val"><b>preimage_of_image</b></a>]  Theorem
      
      ⊢ ∀f s x. x ∈ s ⇒ x ∈ preimage f s (f x)
   
   [<a name="preimage_property-val"><b>preimage_property</b></a>]  Theorem
      
      ⊢ ∀f s y x. x ∈ preimage f s y ⇒ f x = y
   
   [<a name="preimage_subset-val"><b>preimage_subset</b></a>]  Theorem
      
      ⊢ ∀f s y. preimage f s y ⊆ s
   
   [<a name="prime_coprime_all_less-val"><b>prime_coprime_all_less</b></a>]  Theorem
      
      ⊢ ∀m n. prime n ∧ m &lt; n ⇒ ∀j. 0 &lt; j ∧ j ≤ m ⇒ coprime n j
   
   [<a name="prime_coprime_all_lt-val"><b>prime_coprime_all_lt</b></a>]  Theorem
      
      ⊢ ∀n. prime n ⇒ ∀m. 0 &lt; m ∧ m &lt; n ⇒ coprime n m
   
   [<a name="prime_divides_power-val"><b>prime_divides_power</b></a>]  Theorem
      
      ⊢ ∀p n. prime p ∧ 0 &lt; n ⇒ ∀b. p divides b ** n ⇔ p divides b
   
   [<a name="prime_divides_prime-val"><b>prime_divides_prime</b></a>]  Theorem
      
      ⊢ ∀n m. prime n ∧ prime m ⇒ (n divides m ⇔ n = m)
   
   [<a name="prime_divides_prime_power-val"><b>prime_divides_prime_power</b></a>]  Theorem
      
      ⊢ ∀m n k. prime m ∧ prime n ∧ m divides n ** k ⇒ m = n
   
   [<a name="prime_divides_self_power-val"><b>prime_divides_self_power</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇒ ∀n. 0 &lt; n ⇒ p divides p ** n
   
   [<a name="prime_iff_coprime_all_lt-val"><b>prime_iff_coprime_all_lt</b></a>]  Theorem
      
      ⊢ ∀n. prime n ⇔ 1 &lt; n ∧ ∀j. 0 &lt; j ∧ j &lt; n ⇒ coprime n j
   
   [<a name="prime_iff_no_proper_factor-val"><b>prime_iff_no_proper_factor</b></a>]  Theorem
      
      ⊢ ∀n. prime n ⇔ 1 &lt; n ∧ ∀j. 1 &lt; j ∧ j &lt; n ⇒ ¬(j divides n)
   
   [<a name="prime_power_divides_iff-val"><b>prime_power_divides_iff</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇒ ∀m n. p ** m divides p ** n ⇔ m ≤ n
   
   [<a name="prime_power_divisor-val"><b>prime_power_divisor</b></a>]  Theorem
      
      ⊢ ∀p n a. prime p ∧ a divides p ** n ⇒ ∃j. j ≤ n ∧ a = p ** j
   
   [<a name="prime_power_factor-val"><b>prime_power_factor</b></a>]  Theorem
      
      ⊢ ∀n p. 0 &lt; n ∧ prime p ⇒ ∃q m. n = p ** m * q ∧ coprime p q
   
   [<a name="prime_powers_coprime-val"><b>prime_powers_coprime</b></a>]  Theorem
      
      ⊢ ∀p q. prime p ∧ prime q ∧ p ≠ q ⇒ ∀m n. coprime (p ** m) (q ** n)
   
   [<a name="prime_powers_divide-val"><b>prime_powers_divide</b></a>]  Theorem
      
      ⊢ ∀p q.
          prime p ∧ prime q ⇒
          ∀m n. 0 &lt; m ⇒ (p ** m divides q ** n ⇔ p = q ∧ m ≤ n)
   
   [<a name="prime_powers_eq-val"><b>prime_powers_eq</b></a>]  Theorem
      
      ⊢ ∀p q.
          prime p ∧ prime q ⇒ ∀m n. 0 &lt; m ∧ p ** m = q ** n ⇒ p = q ∧ m = n
   
   [<a name="prod_set_residue-val"><b>prod_set_residue</b></a>]  Theorem
      
      ⊢ ∀n. PROD_SET (residue n) = FACT (n − 1)
   
   [<a name="residue_0-val"><b>residue_0</b></a>]  Theorem
      
      ⊢ residue 0 = ∅
   
   [<a name="residue_1-val"><b>residue_1</b></a>]  Theorem
      
      ⊢ residue 1 = ∅
   
   [<a name="residue_card-val"><b>residue_card</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ CARD (residue n) = n − 1
   
   [<a name="residue_count-val"><b>residue_count</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ count n = 0 INSERT residue n
   
   [<a name="residue_delete-val"><b>residue_delete</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ residue n DELETE n = residue n
   
   [<a name="residue_element-val"><b>residue_element</b></a>]  Theorem
      
      ⊢ ∀n j. j ∈ residue n ⇒ 0 &lt; j ∧ j &lt; n
   
   [<a name="residue_finite-val"><b>residue_finite</b></a>]  Theorem
      
      ⊢ ∀n. FINITE (residue n)
   
   [<a name="residue_insert-val"><b>residue_insert</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ residue (SUC n) = n INSERT residue n
   
   [<a name="residue_no_self-val"><b>residue_no_self</b></a>]  Theorem
      
      ⊢ ∀n. n ∉ residue n
   
   [<a name="residue_no_zero-val"><b>residue_no_zero</b></a>]  Theorem
      
      ⊢ ∀n. 0 ∉ residue n
   
   [<a name="residue_nonempty-val"><b>residue_nonempty</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ residue n ≠ ∅
   
   [<a name="residue_prime_neq-val"><b>residue_prime_neq</b></a>]  Theorem
      
      ⊢ ∀p a n.
          prime p ∧ a ∈ residue p ∧ n ≤ p ⇒
          ∀x. x ∈ residue n ⇒ (a * n) MOD p ≠ (a * x) MOD p
   
   [<a name="residue_suc-val"><b>residue_suc</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ residue (SUC n) = n INSERT residue n
   
   [<a name="residue_thm-val"><b>residue_thm</b></a>]  Theorem
      
      ⊢ ∀n. residue n = count n DIFF {0}
   
   [<a name="set_add_fun_by_partition-val"><b>set_add_fun_by_partition</b></a>]  Theorem
      
      ⊢ ∀R s.
          R equiv_on s ∧ FINITE s ⇒
          ∀f. SET_ADDITIVE f ⇒ f s = ∑ f (partition R s)
   
   [<a name="set_additive_card-val"><b>set_additive_card</b></a>]  Theorem
      
      ⊢ SET_ADDITIVE CARD
   
   [<a name="set_additive_sigma-val"><b>set_additive_sigma</b></a>]  Theorem
      
      ⊢ ∀f. SET_ADDITIVE (∑ f)
   
   [<a name="set_card_by_partition-val"><b>set_card_by_partition</b></a>]  Theorem
      
      ⊢ ∀R s. R equiv_on s ∧ FINITE s ⇒ CARD s = ∑ CARD (partition R s)
   
   [<a name="set_mult_fun_by_partition-val"><b>set_mult_fun_by_partition</b></a>]  Theorem
      
      ⊢ ∀R s.
          R equiv_on s ∧ FINITE s ⇒
          ∀f. SET_MULTIPLICATIVE f ⇒ f s = Π f (partition R s)
   
   [<a name="set_sigma_by_partition-val"><b>set_sigma_by_partition</b></a>]  Theorem
      
      ⊢ ∀R s. R equiv_on s ∧ FINITE s ⇒ ∀f. ∑ f s = ∑ (∑ f) (partition R s)
   
   [<a name="sigma_geometric_natural-val"><b>sigma_geometric_natural</b></a>]  Theorem
      
      ⊢ ∀p. 1 &lt; p ⇒
            ∀n. ∑ (λj. p ** j) (natural n) = p * tops p n DIV (p − 1)
   
   [<a name="sigma_geometric_natural_eqn-val"><b>sigma_geometric_natural_eqn</b></a>]  Theorem
      
      ⊢ ∀p. 0 &lt; p ⇒ ∀n. (p − 1) * ∑ (λj. p ** j) (natural n) = p * tops p n
   
   [<a name="sublist_element_order-val"><b>sublist_element_order</b></a>]  Theorem
      
      ⊢ ∀ls sl j h.
          sl ≤ ls ∧ ALL_DISTINCT ls ∧ j &lt; h ∧ h &lt; LENGTH sl ⇒
          findi (EL j sl) ls &lt; findi (EL h sl) ls
   
   [<a name="sum_image_by_composition-val"><b>sum_image_by_composition</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒
            ∀g. INJ g s 𝕌(:α) ⇒ ∀f. ∑ f (IMAGE g s) = ∑ (f ∘ g) s
   
   [<a name="sum_image_by_composition_with_partial_inj-val"><b>sum_image_by_composition_with_partial_inj</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒
            ∀f. f ∅ = 0 ⇒
                ∀g. (∀t. FINITE t ∧ (∀x. x ∈ t ⇒ g x ≠ ∅) ⇒
                         INJ g t 𝕌(:β -&gt; bool)) ⇒
                    ∑ f (IMAGE g s) = ∑ (f ∘ g) s
   
   [<a name="sum_image_by_composition_without_inj-val"><b>sum_image_by_composition_without_inj</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒
            ∀f g.
              (∀x y. x ∈ s ∧ y ∈ s ∧ g x = g y ⇒ x = y ∨ f (g x) = 0) ⇒
              ∑ f (IMAGE g s) = ∑ (f ∘ g) s
   
   [<a name="sum_image_by_permutation-val"><b>sum_image_by_permutation</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀g. g PERMUTES s ⇒ ∀f. ∑ (f ∘ g) s = ∑ f s
   
   [<a name="upto_by_count-val"><b>upto_by_count</b></a>]  Theorem
      
      ⊢ ∀n. upto n = n INSERT count n
   
   [<a name="upto_by_natural-val"><b>upto_by_natural</b></a>]  Theorem
      
      ⊢ ∀n. upto n = 0 INSERT natural n
   
   [<a name="upto_card-val"><b>upto_card</b></a>]  Theorem
      
      ⊢ ∀n. CARD (upto n) = SUC n
   
   [<a name="upto_delete-val"><b>upto_delete</b></a>]  Theorem
      
      ⊢ ∀n. upto n DELETE n = count n
   
   [<a name="upto_finite-val"><b>upto_finite</b></a>]  Theorem
      
      ⊢ ∀n. FINITE (upto n)
   
   [<a name="upto_has_last-val"><b>upto_has_last</b></a>]  Theorem
      
      ⊢ ∀n. n ∈ upto n
   
   [<a name="upto_split_first-val"><b>upto_split_first</b></a>]  Theorem
      
      ⊢ ∀n. upto n = {0} ∪ natural n
   
   [<a name="upto_split_last-val"><b>upto_split_last</b></a>]  Theorem
      
      ⊢ ∀n. upto n = count n ∪ {n}
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/algebra/base/.hol/objs/numberScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-2</a></em></p></body></html>
