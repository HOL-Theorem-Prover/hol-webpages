<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure bagTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure bagTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/bag/.hol/objs/bagScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature bagTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#BAG_ALL_DISTINCT-val">BAG_ALL_DISTINCT</a> : thm
<a name="line7"></a>    val <a href="#BAG_CARD-val">BAG_CARD</a> : thm
<a name="line8"></a>    val <a href="#BAG_CARD_RELn-val">BAG_CARD_RELn</a> : thm
<a name="line9"></a>    val <a href="#BAG_CHOICE_DEF-val">BAG_CHOICE_DEF</a> : thm
<a name="line10"></a>    val <a href="#BAG_DELETE-val">BAG_DELETE</a> : thm
<a name="line11"></a>    val <a href="#BAG_DIFF-val">BAG_DIFF</a> : thm
<a name="line12"></a>    val <a href="#BAG_DISJOINT-val">BAG_DISJOINT</a> : thm
<a name="line13"></a>    val <a href="#BAG_EVERY-val">BAG_EVERY</a> : thm
<a name="line14"></a>    val <a href="#BAG_FILTER_DEF-val">BAG_FILTER_DEF</a> : thm
<a name="line15"></a>    val <a href="#BAG_GEN_PROD_def-val">BAG_GEN_PROD_def</a> : thm
<a name="line16"></a>    val <a href="#BAG_GEN_SUM_def-val">BAG_GEN_SUM_def</a> : thm
<a name="line17"></a>    val <a href="#BAG_IMAGE_DEF-val">BAG_IMAGE_DEF</a> : thm
<a name="line18"></a>    val <a href="#BAG_IN-val">BAG_IN</a> : thm
<a name="line19"></a>    val <a href="#BAG_INN-val">BAG_INN</a> : thm
<a name="line20"></a>    val <a href="#BAG_INSERT-val">BAG_INSERT</a> : thm
<a name="line21"></a>    val <a href="#BAG_INTER-val">BAG_INTER</a> : thm
<a name="line22"></a>    val <a href="#BAG_MERGE-val">BAG_MERGE</a> : thm
<a name="line23"></a>    val <a href="#BAG_OF_SET-val">BAG_OF_SET</a> : thm
<a name="line24"></a>    val <a href="#BAG_REST_DEF-val">BAG_REST_DEF</a> : thm
<a name="line25"></a>    val <a href="#BAG_UNION-val">BAG_UNION</a> : thm
<a name="line26"></a>    val <a href="#BIG_BAG_UNION_def-val">BIG_BAG_UNION_def</a> : thm
<a name="line27"></a>    val <a href="#EL_BAG-val">EL_BAG</a> : thm
<a name="line28"></a>    val <a href="#EMPTY_BAG-val">EMPTY_BAG</a> : thm
<a name="line29"></a>    val <a href="#FINITE_BAG-val">FINITE_BAG</a> : thm
<a name="line30"></a>    val <a href="#PSUB_BAG-val">PSUB_BAG</a> : thm
<a name="line31"></a>    val <a href="#SET_OF_BAG-val">SET_OF_BAG</a> : thm
<a name="line32"></a>    val <a href="#SING_BAG-val">SING_BAG</a> : thm
<a name="line33"></a>    val <a href="#SUB_BAG-val">SUB_BAG</a> : thm
<a name="line34"></a>    val <a href="#bag_size_def-val">bag_size_def</a> : thm
<a name="line35"></a>    val <a href="#dominates_def-val">dominates_def</a> : thm
<a name="line36"></a>    val <a href="#mlt1_def-val">mlt1_def</a> : thm
<a name="line37"></a>  
<a name="line38"></a>  (*  Theorems  *)
<a name="line39"></a>    val <a href="#ASSOC_BAG_UNION-val">ASSOC_BAG_UNION</a> : thm
<a name="line40"></a>    val <a href="#BAG_ALL_DISTINCT_BAG_INN-val">BAG_ALL_DISTINCT_BAG_INN</a> : thm
<a name="line41"></a>    val <a href="#BAG_ALL_DISTINCT_BAG_MERGE-val">BAG_ALL_DISTINCT_BAG_MERGE</a> : thm
<a name="line42"></a>    val <a href="#BAG_ALL_DISTINCT_BAG_OF_SET-val">BAG_ALL_DISTINCT_BAG_OF_SET</a> : thm
<a name="line43"></a>    val <a href="#BAG_ALL_DISTINCT_BAG_UNION-val">BAG_ALL_DISTINCT_BAG_UNION</a> : thm
<a name="line44"></a>    val <a href="#BAG_ALL_DISTINCT_DELETE-val">BAG_ALL_DISTINCT_DELETE</a> : thm
<a name="line45"></a>    val <a href="#BAG_ALL_DISTINCT_DIFF-val">BAG_ALL_DISTINCT_DIFF</a> : thm
<a name="line46"></a>    val <a href="#BAG_ALL_DISTINCT_EXTENSION-val">BAG_ALL_DISTINCT_EXTENSION</a> : thm
<a name="line47"></a>    val <a href="#BAG_ALL_DISTINCT_SET-val">BAG_ALL_DISTINCT_SET</a> : thm
<a name="line48"></a>    val <a href="#BAG_ALL_DISTINCT_SUB_BAG-val">BAG_ALL_DISTINCT_SUB_BAG</a> : thm
<a name="line49"></a>    val <a href="#BAG_ALL_DISTINCT_THM-val">BAG_ALL_DISTINCT_THM</a> : thm
<a name="line50"></a>    val <a href="#BAG_CARD_BAG_INN-val">BAG_CARD_BAG_INN</a> : thm
<a name="line51"></a>    val <a href="#BAG_CARD_BAG_OF_SET-val">BAG_CARD_BAG_OF_SET</a> : thm
<a name="line52"></a>    val <a href="#BAG_CARD_DIFF-val">BAG_CARD_DIFF</a> : thm
<a name="line53"></a>    val <a href="#BAG_CARD_EMPTY-val">BAG_CARD_EMPTY</a> : thm
<a name="line54"></a>    val <a href="#BAG_CARD_EQ_CARD_SET_OF_BAG-val">BAG_CARD_EQ_CARD_SET_OF_BAG</a> : thm
<a name="line55"></a>    val <a href="#BAG_CARD_THM-val">BAG_CARD_THM</a> : thm
<a name="line56"></a>    val <a href="#BAG_CARD_UNION-val">BAG_CARD_UNION</a> : thm
<a name="line57"></a>    val <a href="#BAG_CHOICE_SING-val">BAG_CHOICE_SING</a> : thm
<a name="line58"></a>    val <a href="#BAG_DECOMPOSE-val">BAG_DECOMPOSE</a> : thm
<a name="line59"></a>    val <a href="#BAG_DELETE_11-val">BAG_DELETE_11</a> : thm
<a name="line60"></a>    val <a href="#BAG_DELETE_BAG_IN-val">BAG_DELETE_BAG_IN</a> : thm
<a name="line61"></a>    val <a href="#BAG_DELETE_BAG_IN_down-val">BAG_DELETE_BAG_IN_down</a> : thm
<a name="line62"></a>    val <a href="#BAG_DELETE_BAG_IN_up-val">BAG_DELETE_BAG_IN_up</a> : thm
<a name="line63"></a>    val <a href="#BAG_DELETE_EMPTY-val">BAG_DELETE_EMPTY</a> : thm
<a name="line64"></a>    val <a href="#BAG_DELETE_INSERT-val">BAG_DELETE_INSERT</a> : thm
<a name="line65"></a>    val <a href="#BAG_DELETE_PSUB_BAG-val">BAG_DELETE_PSUB_BAG</a> : thm
<a name="line66"></a>    val <a href="#BAG_DELETE_SING-val">BAG_DELETE_SING</a> : thm
<a name="line67"></a>    val <a href="#BAG_DELETE_TWICE-val">BAG_DELETE_TWICE</a> : thm
<a name="line68"></a>    val <a href="#BAG_DELETE_commutes-val">BAG_DELETE_commutes</a> : thm
<a name="line69"></a>    val <a href="#BAG_DELETE_concrete-val">BAG_DELETE_concrete</a> : thm
<a name="line70"></a>    val <a href="#BAG_DIFF_2L-val">BAG_DIFF_2L</a> : thm
<a name="line71"></a>    val <a href="#BAG_DIFF_2R-val">BAG_DIFF_2R</a> : thm
<a name="line72"></a>    val <a href="#BAG_DIFF_EMPTY-val">BAG_DIFF_EMPTY</a> : thm
<a name="line73"></a>    val <a href="#BAG_DIFF_EMPTY_simple-val">BAG_DIFF_EMPTY_simple</a> : thm
<a name="line74"></a>    val <a href="#BAG_DIFF_EQ_EMPTY-val">BAG_DIFF_EQ_EMPTY</a> : thm
<a name="line75"></a>    val <a href="#BAG_DIFF_INSERT-val">BAG_DIFF_INSERT</a> : thm
<a name="line76"></a>    val <a href="#BAG_DIFF_INSERT_SUB_BAG-val">BAG_DIFF_INSERT_SUB_BAG</a> : thm
<a name="line77"></a>    val <a href="#BAG_DIFF_INSERT_same-val">BAG_DIFF_INSERT_same</a> : thm
<a name="line78"></a>    val <a href="#BAG_DIFF_UNION_eliminate-val">BAG_DIFF_UNION_eliminate</a> : thm
<a name="line79"></a>    val <a href="#BAG_DISJOINT_BAG_IN-val">BAG_DISJOINT_BAG_IN</a> : thm
<a name="line80"></a>    val <a href="#BAG_DISJOINT_BAG_INSERT-val">BAG_DISJOINT_BAG_INSERT</a> : thm
<a name="line81"></a>    val <a href="#BAG_DISJOINT_BAG_UNION-val">BAG_DISJOINT_BAG_UNION</a> : thm
<a name="line82"></a>    val <a href="#BAG_DISJOINT_DIFF-val">BAG_DISJOINT_DIFF</a> : thm
<a name="line83"></a>    val <a href="#BAG_DISJOINT_EMPTY-val">BAG_DISJOINT_EMPTY</a> : thm
<a name="line84"></a>    val <a href="#BAG_DISJOINT_FOLDR_BAG_UNION-val">BAG_DISJOINT_FOLDR_BAG_UNION</a> : thm
<a name="line85"></a>    val <a href="#BAG_DISJOINT_SUB_BAG-val">BAG_DISJOINT_SUB_BAG</a> : thm
<a name="line86"></a>    val <a href="#BAG_DISJOINT_SYM-val">BAG_DISJOINT_SYM</a> : thm
<a name="line87"></a>    val <a href="#BAG_EVERY_MERGE-val">BAG_EVERY_MERGE</a> : thm
<a name="line88"></a>    val <a href="#BAG_EVERY_SET-val">BAG_EVERY_SET</a> : thm
<a name="line89"></a>    val <a href="#BAG_EVERY_THM-val">BAG_EVERY_THM</a> : thm
<a name="line90"></a>    val <a href="#BAG_EVERY_UNION-val">BAG_EVERY_UNION</a> : thm
<a name="line91"></a>    val <a href="#BAG_EXTENSION-val">BAG_EXTENSION</a> : thm
<a name="line92"></a>    val <a href="#BAG_FILTER_BAG_INSERT-val">BAG_FILTER_BAG_INSERT</a> : thm
<a name="line93"></a>    val <a href="#BAG_FILTER_BAG_OF_SET-val">BAG_FILTER_BAG_OF_SET</a> : thm
<a name="line94"></a>    val <a href="#BAG_FILTER_BAG_UNION-val">BAG_FILTER_BAG_UNION</a> : thm
<a name="line95"></a>    val <a href="#BAG_FILTER_EMPTY-val">BAG_FILTER_EMPTY</a> : thm
<a name="line96"></a>    val <a href="#BAG_FILTER_EQ_EMPTY-val">BAG_FILTER_EQ_EMPTY</a> : thm
<a name="line97"></a>    val <a href="#BAG_FILTER_FILTER-val">BAG_FILTER_FILTER</a> : thm
<a name="line98"></a>    val <a href="#BAG_FILTER_SPLIT-val">BAG_FILTER_SPLIT</a> : thm
<a name="line99"></a>    val <a href="#BAG_FILTER_SUB_BAG-val">BAG_FILTER_SUB_BAG</a> : thm
<a name="line100"></a>    val <a href="#BAG_GEN_PROD_ALL_ONES-val">BAG_GEN_PROD_ALL_ONES</a> : thm
<a name="line101"></a>    val <a href="#BAG_GEN_PROD_EMPTY-val">BAG_GEN_PROD_EMPTY</a> : thm
<a name="line102"></a>    val <a href="#BAG_GEN_PROD_EQ_0-val">BAG_GEN_PROD_EQ_0</a> : thm
<a name="line103"></a>    val <a href="#BAG_GEN_PROD_EQ_1-val">BAG_GEN_PROD_EQ_1</a> : thm
<a name="line104"></a>    val <a href="#BAG_GEN_PROD_POSITIVE-val">BAG_GEN_PROD_POSITIVE</a> : thm
<a name="line105"></a>    val <a href="#BAG_GEN_PROD_REC-val">BAG_GEN_PROD_REC</a> : thm
<a name="line106"></a>    val <a href="#BAG_GEN_PROD_TAILREC-val">BAG_GEN_PROD_TAILREC</a> : thm
<a name="line107"></a>    val <a href="#BAG_GEN_PROD_UNION-val">BAG_GEN_PROD_UNION</a> : thm
<a name="line108"></a>    val <a href="#BAG_GEN_PROD_UNION_LEM-val">BAG_GEN_PROD_UNION_LEM</a> : thm
<a name="line109"></a>    val <a href="#BAG_GEN_SUM_EMPTY-val">BAG_GEN_SUM_EMPTY</a> : thm
<a name="line110"></a>    val <a href="#BAG_GEN_SUM_REC-val">BAG_GEN_SUM_REC</a> : thm
<a name="line111"></a>    val <a href="#BAG_GEN_SUM_TAILREC-val">BAG_GEN_SUM_TAILREC</a> : thm
<a name="line112"></a>    val <a href="#BAG_IMAGE_BAG_OF_SET_ITSET_BAG_INSERT-val">BAG_IMAGE_BAG_OF_SET_ITSET_BAG_INSERT</a> : thm
<a name="line113"></a>    val <a href="#BAG_IMAGE_COMPOSE-val">BAG_IMAGE_COMPOSE</a> : thm
<a name="line114"></a>    val <a href="#BAG_IMAGE_CONG-val">BAG_IMAGE_CONG</a> : thm
<a name="line115"></a>    val <a href="#BAG_IMAGE_EMPTY-val">BAG_IMAGE_EMPTY</a> : thm
<a name="line116"></a>    val <a href="#BAG_IMAGE_EQ_EMPTY-val">BAG_IMAGE_EQ_EMPTY</a> : thm
<a name="line117"></a>    val <a href="#BAG_IMAGE_FINITE-val">BAG_IMAGE_FINITE</a> : thm
<a name="line118"></a>    val <a href="#BAG_IMAGE_FINITE_I-val">BAG_IMAGE_FINITE_I</a> : thm
<a name="line119"></a>    val <a href="#BAG_IMAGE_FINITE_INSERT-val">BAG_IMAGE_FINITE_INSERT</a> : thm
<a name="line120"></a>    val <a href="#BAG_IMAGE_FINITE_RESTRICTED_I-val">BAG_IMAGE_FINITE_RESTRICTED_I</a> : thm
<a name="line121"></a>    val <a href="#BAG_IMAGE_FINITE_UNION-val">BAG_IMAGE_FINITE_UNION</a> : thm
<a name="line122"></a>    val <a href="#BAG_INN_0-val">BAG_INN_0</a> : thm
<a name="line123"></a>    val <a href="#BAG_INN_BAG_DELETE-val">BAG_INN_BAG_DELETE</a> : thm
<a name="line124"></a>    val <a href="#BAG_INN_BAG_FILTER-val">BAG_INN_BAG_FILTER</a> : thm
<a name="line125"></a>    val <a href="#BAG_INN_BAG_INSERT-val">BAG_INN_BAG_INSERT</a> : thm
<a name="line126"></a>    val <a href="#BAG_INN_BAG_INSERT_STRONG-val">BAG_INN_BAG_INSERT_STRONG</a> : thm
<a name="line127"></a>    val <a href="#BAG_INN_BAG_MERGE-val">BAG_INN_BAG_MERGE</a> : thm
<a name="line128"></a>    val <a href="#BAG_INN_BAG_UNION-val">BAG_INN_BAG_UNION</a> : thm
<a name="line129"></a>    val <a href="#BAG_INN_EMPTY_BAG-val">BAG_INN_EMPTY_BAG</a> : thm
<a name="line130"></a>    val <a href="#BAG_INN_LESS-val">BAG_INN_LESS</a> : thm
<a name="line131"></a>    val <a href="#BAG_INSERT_CHOICE_REST-val">BAG_INSERT_CHOICE_REST</a> : thm
<a name="line132"></a>    val <a href="#BAG_INSERT_DIFF-val">BAG_INSERT_DIFF</a> : thm
<a name="line133"></a>    val <a href="#BAG_INSERT_EQUAL-val">BAG_INSERT_EQUAL</a> : thm
<a name="line134"></a>    val <a href="#BAG_INSERT_EQ_MERGE_DIFF-val">BAG_INSERT_EQ_MERGE_DIFF</a> : thm
<a name="line135"></a>    val <a href="#BAG_INSERT_EQ_UNION-val">BAG_INSERT_EQ_UNION</a> : thm
<a name="line136"></a>    val <a href="#BAG_INSERT_NOT_EMPTY-val">BAG_INSERT_NOT_EMPTY</a> : thm
<a name="line137"></a>    val <a href="#BAG_INSERT_ONE_ONE-val">BAG_INSERT_ONE_ONE</a> : thm
<a name="line138"></a>    val <a href="#BAG_INSERT_SUB_BAG_E-val">BAG_INSERT_SUB_BAG_E</a> : thm
<a name="line139"></a>    val <a href="#BAG_INSERT_UNION-val">BAG_INSERT_UNION</a> : thm
<a name="line140"></a>    val <a href="#BAG_INSERT_commutes-val">BAG_INSERT_commutes</a> : thm
<a name="line141"></a>    val <a href="#BAG_INTER_FINITE-val">BAG_INTER_FINITE</a> : thm
<a name="line142"></a>    val <a href="#BAG_INTER_SUB_BAG-val">BAG_INTER_SUB_BAG</a> : thm
<a name="line143"></a>    val <a href="#BAG_IN_BAG_DELETE-val">BAG_IN_BAG_DELETE</a> : thm
<a name="line144"></a>    val <a href="#BAG_IN_BAG_DIFF_ALL_DISTINCT-val">BAG_IN_BAG_DIFF_ALL_DISTINCT</a> : thm
<a name="line145"></a>    val <a href="#BAG_IN_BAG_FILTER-val">BAG_IN_BAG_FILTER</a> : thm
<a name="line146"></a>    val <a href="#BAG_IN_BAG_IMAGE_IMP-val">BAG_IN_BAG_IMAGE_IMP</a> : thm
<a name="line147"></a>    val <a href="#BAG_IN_BAG_INSERT-val">BAG_IN_BAG_INSERT</a> : thm
<a name="line148"></a>    val <a href="#BAG_IN_BAG_MERGE-val">BAG_IN_BAG_MERGE</a> : thm
<a name="line149"></a>    val <a href="#BAG_IN_BAG_OF_SET-val">BAG_IN_BAG_OF_SET</a> : thm
<a name="line150"></a>    val <a href="#BAG_IN_BAG_UNION-val">BAG_IN_BAG_UNION</a> : thm
<a name="line151"></a>    val <a href="#BAG_IN_BIG_BAG_UNION-val">BAG_IN_BIG_BAG_UNION</a> : thm
<a name="line152"></a>    val <a href="#BAG_IN_DIFF_E-val">BAG_IN_DIFF_E</a> : thm
<a name="line153"></a>    val <a href="#BAG_IN_DIFF_I-val">BAG_IN_DIFF_I</a> : thm
<a name="line154"></a>    val <a href="#BAG_IN_DIVIDES-val">BAG_IN_DIVIDES</a> : thm
<a name="line155"></a>    val <a href="#BAG_IN_FINITE_BAG_IMAGE-val">BAG_IN_FINITE_BAG_IMAGE</a> : thm
<a name="line156"></a>    val <a href="#BAG_IN_unibag-val">BAG_IN_unibag</a> : thm
<a name="line157"></a>    val <a href="#BAG_LESS_ADD-val">BAG_LESS_ADD</a> : thm
<a name="line158"></a>    val <a href="#BAG_MEMBER_NOT_EMPTY-val">BAG_MEMBER_NOT_EMPTY</a> : thm
<a name="line159"></a>    val <a href="#BAG_MERGE_BAG_INSERT-val">BAG_MERGE_BAG_INSERT</a> : thm
<a name="line160"></a>    val <a href="#BAG_MERGE_CARD-val">BAG_MERGE_CARD</a> : thm
<a name="line161"></a>    val <a href="#BAG_MERGE_ELBAG_SUB_BAG_INSERT-val">BAG_MERGE_ELBAG_SUB_BAG_INSERT</a> : thm
<a name="line162"></a>    val <a href="#BAG_MERGE_EMPTY-val">BAG_MERGE_EMPTY</a> : thm
<a name="line163"></a>    val <a href="#BAG_MERGE_EQ_EMPTY-val">BAG_MERGE_EQ_EMPTY</a> : thm
<a name="line164"></a>    val <a href="#BAG_MERGE_IDEM-val">BAG_MERGE_IDEM</a> : thm
<a name="line165"></a>    val <a href="#BAG_MERGE_SUB_BAG_UNION-val">BAG_MERGE_SUB_BAG_UNION</a> : thm
<a name="line166"></a>    val <a href="#BAG_NOT_LESS_EMPTY-val">BAG_NOT_LESS_EMPTY</a> : thm
<a name="line167"></a>    val <a href="#BAG_OF_EMPTY-val">BAG_OF_EMPTY</a> : thm
<a name="line168"></a>    val <a href="#BAG_OF_SET_BAG_DIFF_DIFF-val">BAG_OF_SET_BAG_DIFF_DIFF</a> : thm
<a name="line169"></a>    val <a href="#BAG_OF_SET_DIFF-val">BAG_OF_SET_DIFF</a> : thm
<a name="line170"></a>    val <a href="#BAG_OF_SET_DISJOINT_UNION-val">BAG_OF_SET_DISJOINT_UNION</a> : thm
<a name="line171"></a>    val <a href="#BAG_OF_SET_EQ_EMPTY_BAG-val">BAG_OF_SET_EQ_EMPTY_BAG</a> : thm
<a name="line172"></a>    val <a href="#BAG_OF_SET_EQ_INSERT-val">BAG_OF_SET_EQ_INSERT</a> : thm
<a name="line173"></a>    val <a href="#BAG_OF_SET_IMAGE_INJ-val">BAG_OF_SET_IMAGE_INJ</a> : thm
<a name="line174"></a>    val <a href="#BAG_OF_SET_INJ-val">BAG_OF_SET_INJ</a> : thm
<a name="line175"></a>    val <a href="#BAG_OF_SET_INSERT-val">BAG_OF_SET_INSERT</a> : thm
<a name="line176"></a>    val <a href="#BAG_OF_SET_INSERT_NON_ELEMENT-val">BAG_OF_SET_INSERT_NON_ELEMENT</a> : thm
<a name="line177"></a>    val <a href="#BAG_OF_SET_UNION-val">BAG_OF_SET_UNION</a> : thm
<a name="line178"></a>    val <a href="#BAG_REST_SING-val">BAG_REST_SING</a> : thm
<a name="line179"></a>    val <a href="#BAG_SIZE_EMPTY-val">BAG_SIZE_EMPTY</a> : thm
<a name="line180"></a>    val <a href="#BAG_SIZE_INSERT-val">BAG_SIZE_INSERT</a> : thm
<a name="line181"></a>    val <a href="#BAG_UNION_DIFF-val">BAG_UNION_DIFF</a> : thm
<a name="line182"></a>    val <a href="#BAG_UNION_DIFF_eliminate-val">BAG_UNION_DIFF_eliminate</a> : thm
<a name="line183"></a>    val <a href="#BAG_UNION_EMPTY-val">BAG_UNION_EMPTY</a> : thm
<a name="line184"></a>    val <a href="#BAG_UNION_EQ_LCANCEL1-val">BAG_UNION_EQ_LCANCEL1</a> : thm
<a name="line185"></a>    val <a href="#BAG_UNION_EQ_LEFT-val">BAG_UNION_EQ_LEFT</a> : thm
<a name="line186"></a>    val <a href="#BAG_UNION_EQ_RCANCEL1-val">BAG_UNION_EQ_RCANCEL1</a> : thm
<a name="line187"></a>    val <a href="#BAG_UNION_INSERT-val">BAG_UNION_INSERT</a> : thm
<a name="line188"></a>    val <a href="#BAG_UNION_LEFT_CANCEL-val">BAG_UNION_LEFT_CANCEL</a> : thm
<a name="line189"></a>    val <a href="#BAG_UNION_RIGHT_CANCEL-val">BAG_UNION_RIGHT_CANCEL</a> : thm
<a name="line190"></a>    val <a href="#BAG_cases-val">BAG_cases</a> : thm
<a name="line191"></a>    val <a href="#BCARD_0-val">BCARD_0</a> : thm
<a name="line192"></a>    val <a href="#BCARD_SUC-val">BCARD_SUC</a> : thm
<a name="line193"></a>    val <a href="#BIG_BAG_UNION_DELETE-val">BIG_BAG_UNION_DELETE</a> : thm
<a name="line194"></a>    val <a href="#BIG_BAG_UNION_EMPTY-val">BIG_BAG_UNION_EMPTY</a> : thm
<a name="line195"></a>    val <a href="#BIG_BAG_UNION_EQ_ELEMENT-val">BIG_BAG_UNION_EQ_ELEMENT</a> : thm
<a name="line196"></a>    val <a href="#BIG_BAG_UNION_EQ_EMPTY_BAG-val">BIG_BAG_UNION_EQ_EMPTY_BAG</a> : thm
<a name="line197"></a>    val <a href="#BIG_BAG_UNION_INSERT-val">BIG_BAG_UNION_INSERT</a> : thm
<a name="line198"></a>    val <a href="#BIG_BAG_UNION_ITSET_BAG_UNION-val">BIG_BAG_UNION_ITSET_BAG_UNION</a> : thm
<a name="line199"></a>    val <a href="#BIG_BAG_UNION_UNION-val">BIG_BAG_UNION_UNION</a> : thm
<a name="line200"></a>    val <a href="#COMMUTING_ITBAG_INSERT-val">COMMUTING_ITBAG_INSERT</a> : thm
<a name="line201"></a>    val <a href="#COMMUTING_ITBAG_RECURSES-val">COMMUTING_ITBAG_RECURSES</a> : thm
<a name="line202"></a>    val <a href="#COMM_BAG_UNION-val">COMM_BAG_UNION</a> : thm
<a name="line203"></a>    val <a href="#C_BAG_INSERT_ONE_ONE-val">C_BAG_INSERT_ONE_ONE</a> : thm
<a name="line204"></a>    val <a href="#EL_BAG_11-val">EL_BAG_11</a> : thm
<a name="line205"></a>    val <a href="#EL_BAG_BAG_INSERT-val">EL_BAG_BAG_INSERT</a> : thm
<a name="line206"></a>    val <a href="#EL_BAG_INSERT_squeeze-val">EL_BAG_INSERT_squeeze</a> : thm
<a name="line207"></a>    val <a href="#EL_BAG_SUB_BAG-val">EL_BAG_SUB_BAG</a> : thm
<a name="line208"></a>    val <a href="#EMPTY_BAG_alt-val">EMPTY_BAG_alt</a> : thm
<a name="line209"></a>    val <a href="#FINITE_BAG_DIFF-val">FINITE_BAG_DIFF</a> : thm
<a name="line210"></a>    val <a href="#FINITE_BAG_DIFF_dual-val">FINITE_BAG_DIFF_dual</a> : thm
<a name="line211"></a>    val <a href="#FINITE_BAG_FILTER-val">FINITE_BAG_FILTER</a> : thm
<a name="line212"></a>    val <a href="#FINITE_BAG_INDUCT-val">FINITE_BAG_INDUCT</a> : thm
<a name="line213"></a>    val <a href="#FINITE_BAG_INSERT-val">FINITE_BAG_INSERT</a> : thm
<a name="line214"></a>    val <a href="#FINITE_BAG_MERGE-val">FINITE_BAG_MERGE</a> : thm
<a name="line215"></a>    val <a href="#FINITE_BAG_OF_SET-val">FINITE_BAG_OF_SET</a> : thm
<a name="line216"></a>    val <a href="#FINITE_BAG_THM-val">FINITE_BAG_THM</a> : thm
<a name="line217"></a>    val <a href="#FINITE_BAG_UNION-val">FINITE_BAG_UNION</a> : thm
<a name="line218"></a>    val <a href="#FINITE_BIG_BAG_UNION-val">FINITE_BIG_BAG_UNION</a> : thm
<a name="line219"></a>    val <a href="#FINITE_EL_BAG-val">FINITE_EL_BAG</a> : thm
<a name="line220"></a>    val <a href="#FINITE_EMPTY_BAG-val">FINITE_EMPTY_BAG</a> : thm
<a name="line221"></a>    val <a href="#FINITE_SET_OF_BAG-val">FINITE_SET_OF_BAG</a> : thm
<a name="line222"></a>    val <a href="#FINITE_SUB_BAG-val">FINITE_SUB_BAG</a> : thm
<a name="line223"></a>    val <a href="#FINITE_SUB_BAGS-val">FINITE_SUB_BAGS</a> : thm
<a name="line224"></a>    val <a href="#IN_SET_OF_BAG-val">IN_SET_OF_BAG</a> : thm
<a name="line225"></a>    val <a href="#IN_SET_OF_BAG_NONZERO-val">IN_SET_OF_BAG_NONZERO</a> : thm
<a name="line226"></a>    val <a href="#ITBAG_EMPTY-val">ITBAG_EMPTY</a> : thm
<a name="line227"></a>    val <a href="#ITBAG_IND-val">ITBAG_IND</a> : thm
<a name="line228"></a>    val <a href="#ITBAG_INSERT-val">ITBAG_INSERT</a> : thm
<a name="line229"></a>    val <a href="#ITBAG_SING-val">ITBAG_SING</a> : thm
<a name="line230"></a>    val <a href="#ITBAG_THM-val">ITBAG_THM</a> : thm
<a name="line231"></a>    val <a href="#ITSET_BAG_INSERT_BAG_UNION_BAG_IMAGE_BAG_OF_SET-val">ITSET_BAG_INSERT_BAG_UNION_BAG_IMAGE_BAG_OF_SET</a> : thm
<a name="line232"></a>    val <a href="#MONOID_BAG_UNION_EMPTY_BAG-val">MONOID_BAG_UNION_EMPTY_BAG</a> : thm
<a name="line233"></a>    val <a href="#NOT_BAG_IN-val">NOT_BAG_IN</a> : thm
<a name="line234"></a>    val <a href="#NOT_IN_BAG_DIFF-val">NOT_IN_BAG_DIFF</a> : thm
<a name="line235"></a>    val <a href="#NOT_IN_EMPTY_BAG-val">NOT_IN_EMPTY_BAG</a> : thm
<a name="line236"></a>    val <a href="#NOT_IN_SUB_BAG_INSERT-val">NOT_IN_SUB_BAG_INSERT</a> : thm
<a name="line237"></a>    val <a href="#NOT_mlt_EMPTY-val">NOT_mlt_EMPTY</a> : thm
<a name="line238"></a>    val <a href="#PSUB_BAG_ANTISYM-val">PSUB_BAG_ANTISYM</a> : thm
<a name="line239"></a>    val <a href="#PSUB_BAG_CARD-val">PSUB_BAG_CARD</a> : thm
<a name="line240"></a>    val <a href="#PSUB_BAG_IRREFL-val">PSUB_BAG_IRREFL</a> : thm
<a name="line241"></a>    val <a href="#PSUB_BAG_NOT_EQ-val">PSUB_BAG_NOT_EQ</a> : thm
<a name="line242"></a>    val <a href="#PSUB_BAG_REST-val">PSUB_BAG_REST</a> : thm
<a name="line243"></a>    val <a href="#PSUB_BAG_SUB_BAG-val">PSUB_BAG_SUB_BAG</a> : thm
<a name="line244"></a>    val <a href="#PSUB_BAG_TRANS-val">PSUB_BAG_TRANS</a> : thm
<a name="line245"></a>    val <a href="#SET_BAG_I-val">SET_BAG_I</a> : thm
<a name="line246"></a>    val <a href="#SET_OF_BAG_DIFF_SUBSET_down-val">SET_OF_BAG_DIFF_SUBSET_down</a> : thm
<a name="line247"></a>    val <a href="#SET_OF_BAG_DIFF_SUBSET_up-val">SET_OF_BAG_DIFF_SUBSET_up</a> : thm
<a name="line248"></a>    val <a href="#SET_OF_BAG_EQ_EMPTY-val">SET_OF_BAG_EQ_EMPTY</a> : thm
<a name="line249"></a>    val <a href="#SET_OF_BAG_EQ_INSERT-val">SET_OF_BAG_EQ_INSERT</a> : thm
<a name="line250"></a>    val <a href="#SET_OF_BAG_IMAGE-val">SET_OF_BAG_IMAGE</a> : thm
<a name="line251"></a>    val <a href="#SET_OF_BAG_INSERT-val">SET_OF_BAG_INSERT</a> : thm
<a name="line252"></a>    val <a href="#SET_OF_BAG_MERGE-val">SET_OF_BAG_MERGE</a> : thm
<a name="line253"></a>    val <a href="#SET_OF_BAG_SING-val">SET_OF_BAG_SING</a> : thm
<a name="line254"></a>    val <a href="#SET_OF_BAG_SING_CARD-val">SET_OF_BAG_SING_CARD</a> : thm
<a name="line255"></a>    val <a href="#SET_OF_BAG_UNION-val">SET_OF_BAG_UNION</a> : thm
<a name="line256"></a>    val <a href="#SET_OF_EL_BAG-val">SET_OF_EL_BAG</a> : thm
<a name="line257"></a>    val <a href="#SET_OF_EMPTY-val">SET_OF_EMPTY</a> : thm
<a name="line258"></a>    val <a href="#SET_OF_SINGLETON_BAG-val">SET_OF_SINGLETON_BAG</a> : thm
<a name="line259"></a>    val <a href="#SING_BAG_THM-val">SING_BAG_THM</a> : thm
<a name="line260"></a>    val <a href="#SING_EL_BAG-val">SING_EL_BAG</a> : thm
<a name="line261"></a>    val <a href="#STRONG_FINITE_BAG_INDUCT-val">STRONG_FINITE_BAG_INDUCT</a> : thm
<a name="line262"></a>    val <a href="#SUB_BAG_ALL_DISTINCT-val">SUB_BAG_ALL_DISTINCT</a> : thm
<a name="line263"></a>    val <a href="#SUB_BAG_ANTISYM-val">SUB_BAG_ANTISYM</a> : thm
<a name="line264"></a>    val <a href="#SUB_BAG_BAG_DIFF-val">SUB_BAG_BAG_DIFF</a> : thm
<a name="line265"></a>    val <a href="#SUB_BAG_BAG_IN-val">SUB_BAG_BAG_IN</a> : thm
<a name="line266"></a>    val <a href="#SUB_BAG_CARD-val">SUB_BAG_CARD</a> : thm
<a name="line267"></a>    val <a href="#SUB_BAG_DIFF-val">SUB_BAG_DIFF</a> : thm
<a name="line268"></a>    val <a href="#SUB_BAG_DIFF_EQ-val">SUB_BAG_DIFF_EQ</a> : thm
<a name="line269"></a>    val <a href="#SUB_BAG_DIFF_simple-val">SUB_BAG_DIFF_simple</a> : thm
<a name="line270"></a>    val <a href="#SUB_BAG_EL_BAG-val">SUB_BAG_EL_BAG</a> : thm
<a name="line271"></a>    val <a href="#SUB_BAG_EMPTY-val">SUB_BAG_EMPTY</a> : thm
<a name="line272"></a>    val <a href="#SUB_BAG_EXISTS-val">SUB_BAG_EXISTS</a> : thm
<a name="line273"></a>    val <a href="#SUB_BAG_INSERT-val">SUB_BAG_INSERT</a> : thm
<a name="line274"></a>    val <a href="#SUB_BAG_INSERT_I-val">SUB_BAG_INSERT_I</a> : thm
<a name="line275"></a>    val <a href="#SUB_BAG_LEQ-val">SUB_BAG_LEQ</a> : thm
<a name="line276"></a>    val <a href="#SUB_BAG_PSUB_BAG-val">SUB_BAG_PSUB_BAG</a> : thm
<a name="line277"></a>    val <a href="#SUB_BAG_REFL-val">SUB_BAG_REFL</a> : thm
<a name="line278"></a>    val <a href="#SUB_BAG_REST-val">SUB_BAG_REST</a> : thm
<a name="line279"></a>    val <a href="#SUB_BAG_SET-val">SUB_BAG_SET</a> : thm
<a name="line280"></a>    val <a href="#SUB_BAG_SING-val">SUB_BAG_SING</a> : thm
<a name="line281"></a>    val <a href="#SUB_BAG_TRANS-val">SUB_BAG_TRANS</a> : thm
<a name="line282"></a>    val <a href="#SUB_BAG_UNION-val">SUB_BAG_UNION</a> : thm
<a name="line283"></a>    val <a href="#SUB_BAG_UNION_DIFF-val">SUB_BAG_UNION_DIFF</a> : thm
<a name="line284"></a>    val <a href="#SUB_BAG_UNION_MONO-val">SUB_BAG_UNION_MONO</a> : thm
<a name="line285"></a>    val <a href="#SUB_BAG_UNION_down-val">SUB_BAG_UNION_down</a> : thm
<a name="line286"></a>    val <a href="#SUB_BAG_UNION_eliminate-val">SUB_BAG_UNION_eliminate</a> : thm
<a name="line287"></a>    val <a href="#TC_mlt1_FINITE_BAG-val">TC_mlt1_FINITE_BAG</a> : thm
<a name="line288"></a>    val <a href="#TC_mlt1_UNION1_I-val">TC_mlt1_UNION1_I</a> : thm
<a name="line289"></a>    val <a href="#TC_mlt1_UNION2_I-val">TC_mlt1_UNION2_I</a> : thm
<a name="line290"></a>    val <a href="#WF_mlt1-val">WF_mlt1</a> : thm
<a name="line291"></a>    val <a href="#bdominates_BAG_DIFF-val">bdominates_BAG_DIFF</a> : thm
<a name="line292"></a>    val <a href="#dominates_DIFF-val">dominates_DIFF</a> : thm
<a name="line293"></a>    val <a href="#dominates_EMPTY-val">dominates_EMPTY</a> : thm
<a name="line294"></a>    val <a href="#dominates_SUBSET-val">dominates_SUBSET</a> : thm
<a name="line295"></a>    val <a href="#mlt1_INSERT_CANCEL-val">mlt1_INSERT_CANCEL</a> : thm
<a name="line296"></a>    val <a href="#mlt1_all_accessible-val">mlt1_all_accessible</a> : thm
<a name="line297"></a>    val <a href="#mltLT_SING0-val">mltLT_SING0</a> : thm
<a name="line298"></a>    val <a href="#mlt_INSERT_CANCEL-val">mlt_INSERT_CANCEL</a> : thm
<a name="line299"></a>    val <a href="#mlt_INSERT_CANCEL_I-val">mlt_INSERT_CANCEL_I</a> : thm
<a name="line300"></a>    val <a href="#mlt_NOT_REFL-val">mlt_NOT_REFL</a> : thm
<a name="line301"></a>    val <a href="#mlt_UNION_CANCEL_EQN-val">mlt_UNION_CANCEL_EQN</a> : thm
<a name="line302"></a>    val <a href="#mlt_UNION_EMPTY_EQN-val">mlt_UNION_EMPTY_EQN</a> : thm
<a name="line303"></a>    val <a href="#mlt_UNION_LCANCEL-val">mlt_UNION_LCANCEL</a> : thm
<a name="line304"></a>    val <a href="#mlt_UNION_LCANCEL_I-val">mlt_UNION_LCANCEL_I</a> : thm
<a name="line305"></a>    val <a href="#mlt_UNION_RCANCEL-val">mlt_UNION_RCANCEL</a> : thm
<a name="line306"></a>    val <a href="#mlt_UNION_RCANCEL_I-val">mlt_UNION_RCANCEL_I</a> : thm
<a name="line307"></a>    val <a href="#mlt_dominates_thm1-val">mlt_dominates_thm1</a> : thm
<a name="line308"></a>    val <a href="#mlt_dominates_thm2-val">mlt_dominates_thm2</a> : thm
<a name="line309"></a>    val <a href="#move_BAG_UNION_over_eq-val">move_BAG_UNION_over_eq</a> : thm
<a name="line310"></a>    val <a href="#unibag_ALL_DISTINCT-val">unibag_ALL_DISTINCT</a> : thm
<a name="line311"></a>    val <a href="#unibag_DECOMPOSE-val">unibag_DECOMPOSE</a> : thm
<a name="line312"></a>    val <a href="#unibag_EL_MERGE_cases-val">unibag_EL_MERGE_cases</a> : thm
<a name="line313"></a>    val <a href="#unibag_EQ_BAG_INSERT-val">unibag_EQ_BAG_INSERT</a> : thm
<a name="line314"></a>    val <a href="#unibag_FINITE-val">unibag_FINITE</a> : thm
<a name="line315"></a>    val <a href="#unibag_INSERT-val">unibag_INSERT</a> : thm
<a name="line316"></a>    val <a href="#unibag_SUB_BAG-val">unibag_SUB_BAG</a> : thm
<a name="line317"></a>    val <a href="#unibag_UNION-val">unibag_UNION</a> : thm
<a name="line318"></a>    val <a href="#unibag_thm-val">unibag_thm</a> : thm
<a name="line319"></a>(*
   [hol] Parent theory of "bag"
   
   [<a name="BAG_ALL_DISTINCT-val"><b>BAG_ALL_DISTINCT</b></a>]  Definition
      
      ⊢ ∀b. BAG_ALL_DISTINCT b ⇔ ∀e. b e ≤ 1
   
   [<a name="BAG_CARD-val"><b>BAG_CARD</b></a>]  Definition
      
      ⊢ ∀b. FINITE_BAG b ⇒ BAG_CARD_RELn b (BAG_CARD b)
   
   [<a name="BAG_CARD_RELn-val"><b>BAG_CARD_RELn</b></a>]  Definition
      
      ⊢ ∀b n.
          BAG_CARD_RELn b n ⇔
          ∀P. P {||} 0 ∧ (∀b n. P b n ⇒ ∀e. P (BAG_INSERT e b) (SUC n)) ⇒
              P b n
   
   [<a name="BAG_CHOICE_DEF-val"><b>BAG_CHOICE_DEF</b></a>]  Definition
      
      ⊢ ∀b. b ≠ {||} ⇒ BAG_CHOICE b ⋲ b
   
   [<a name="BAG_DELETE-val"><b>BAG_DELETE</b></a>]  Definition
      
      ⊢ ∀b0 e b. BAG_DELETE b0 e b ⇔ b0 = BAG_INSERT e b
   
   [<a name="BAG_DIFF-val"><b>BAG_DIFF</b></a>]  Definition
      
      ⊢ ∀b1 b2. b1 − b2 = (λx. b1 x − b2 x)
   
   [<a name="BAG_DISJOINT-val"><b>BAG_DISJOINT</b></a>]  Definition
      
      ⊢ ∀b1 b2.
          BAG_DISJOINT b1 b2 ⇔ DISJOINT (SET_OF_BAG b1) (SET_OF_BAG b2)
   
   [<a name="BAG_EVERY-val"><b>BAG_EVERY</b></a>]  Definition
      
      ⊢ ∀P b. BAG_EVERY P b ⇔ ∀e. e ⋲ b ⇒ P e
   
   [<a name="BAG_FILTER_DEF-val"><b>BAG_FILTER_DEF</b></a>]  Definition
      
      ⊢ ∀P b. BAG_FILTER P b = (λe. if P e then b e else 0)
   
   [<a name="BAG_GEN_PROD_def-val"><b>BAG_GEN_PROD_def</b></a>]  Definition
      
      ⊢ ∀bag n. BAG_GEN_PROD bag n = ITBAG $* bag n
   
   [<a name="BAG_GEN_SUM_def-val"><b>BAG_GEN_SUM_def</b></a>]  Definition
      
      ⊢ ∀bag n. BAG_GEN_SUM bag n = ITBAG $+ bag n
   
   [<a name="BAG_IMAGE_DEF-val"><b>BAG_IMAGE_DEF</b></a>]  Definition
      
      ⊢ ∀f b.
          BAG_IMAGE f b =
          (λe.
               (let
                  sb = BAG_FILTER (λe0. f e0 = e) b
                in
                  if FINITE_BAG sb then BAG_CARD sb else 1))
   
   [<a name="BAG_IN-val"><b>BAG_IN</b></a>]  Definition
      
      ⊢ ∀e b. e ⋲ b ⇔ BAG_INN e 1 b
   
   [<a name="BAG_INN-val"><b>BAG_INN</b></a>]  Definition
      
      ⊢ ∀e n b. BAG_INN e n b ⇔ b e ≥ n
   
   [<a name="BAG_INSERT-val"><b>BAG_INSERT</b></a>]  Definition
      
      ⊢ ∀e b. BAG_INSERT e b = (λx. if x = e then b e + 1 else b x)
   
   [<a name="BAG_INTER-val"><b>BAG_INTER</b></a>]  Definition
      
      ⊢ ∀b1 b2. BAG_INTER b1 b2 = (λx. if b1 x &lt; b2 x then b1 x else b2 x)
   
   [<a name="BAG_MERGE-val"><b>BAG_MERGE</b></a>]  Definition
      
      ⊢ ∀b1 b2. BAG_MERGE b1 b2 = (λx. if b1 x &lt; b2 x then b2 x else b1 x)
   
   [<a name="BAG_OF_SET-val"><b>BAG_OF_SET</b></a>]  Definition
      
      ⊢ ∀P. BAG_OF_SET P = (λx. if x ∈ P then 1 else 0)
   
   [<a name="BAG_REST_DEF-val"><b>BAG_REST_DEF</b></a>]  Definition
      
      ⊢ ∀b. BAG_REST b = b − EL_BAG (BAG_CHOICE b)
   
   [<a name="BAG_UNION-val"><b>BAG_UNION</b></a>]  Definition
      
      ⊢ ∀b c. b ⊎ c = (λx. b x + c x)
   
   [<a name="BIG_BAG_UNION_def-val"><b>BIG_BAG_UNION_def</b></a>]  Definition
      
      ⊢ ∀sob. BIG_BAG_UNION sob = (λx. ∑ (λb. b x) sob)
   
   [<a name="EL_BAG-val"><b>EL_BAG</b></a>]  Definition
      
      ⊢ ∀e. EL_BAG e = {|e|}
   
   [<a name="EMPTY_BAG-val"><b>EMPTY_BAG</b></a>]  Definition
      
      ⊢ {||} = K 0
   
   [<a name="FINITE_BAG-val"><b>FINITE_BAG</b></a>]  Definition
      
      ⊢ ∀b. FINITE_BAG b ⇔
            ∀P. P {||} ∧ (∀b. P b ⇒ ∀e. P (BAG_INSERT e b)) ⇒ P b
   
   [<a name="PSUB_BAG-val"><b>PSUB_BAG</b></a>]  Definition
      
      ⊢ ∀b1 b2. b1 &lt; b2 ⇔ b1 ≤ b2 ∧ b1 ≠ b2
   
   [<a name="SET_OF_BAG-val"><b>SET_OF_BAG</b></a>]  Definition
      
      ⊢ ∀b. SET_OF_BAG b = (λx. x ⋲ b)
   
   [<a name="SING_BAG-val"><b>SING_BAG</b></a>]  Definition
      
      ⊢ ∀b. SING_BAG b ⇔ ∃x. b = {|x|}
   
   [<a name="SUB_BAG-val"><b>SUB_BAG</b></a>]  Definition
      
      ⊢ ∀b1 b2. b1 ≤ b2 ⇔ ∀x n. BAG_INN x n b1 ⇒ BAG_INN x n b2
   
   [<a name="bag_size_def-val"><b>bag_size_def</b></a>]  Definition
      
      ⊢ ∀eltsize b.
          bag_size eltsize b = ITBAG (λe acc. 1 + eltsize e + acc) b 0
   
   [<a name="dominates_def-val"><b>dominates_def</b></a>]  Definition
      
      ⊢ ∀R s1 s2. dominates R s1 s2 ⇔ ∀x. x ∈ s1 ⇒ ∃y. y ∈ s2 ∧ R x y
   
   [<a name="mlt1_def-val"><b>mlt1_def</b></a>]  Definition
      
      ⊢ ∀r b1 b2.
          mlt1 r b1 b2 ⇔
          FINITE_BAG b1 ∧ FINITE_BAG b2 ∧
          ∃e rep res.
            b1 = rep ⊎ res ∧ b2 = res ⊎ {|e|} ∧ ∀e'. e' ⋲ rep ⇒ r e' e
   
   [<a name="ASSOC_BAG_UNION-val"><b>ASSOC_BAG_UNION</b></a>]  Theorem
      
      ⊢ ∀b1 b2 b3. b1 ⊎ (b2 ⊎ b3) = b1 ⊎ b2 ⊎ b3
   
   [<a name="BAG_ALL_DISTINCT_BAG_INN-val"><b>BAG_ALL_DISTINCT_BAG_INN</b></a>]  Theorem
      
      ⊢ ∀b n e.
          BAG_ALL_DISTINCT b ⇒ (BAG_INN e n b ⇔ n = 0 ∨ n = 1 ∧ e ⋲ b)
   
   [<a name="BAG_ALL_DISTINCT_BAG_MERGE-val"><b>BAG_ALL_DISTINCT_BAG_MERGE</b></a>]  Theorem
      
      ⊢ ∀b1 b2.
          BAG_ALL_DISTINCT (BAG_MERGE b1 b2) ⇔
          BAG_ALL_DISTINCT b1 ∧ BAG_ALL_DISTINCT b2
   
   [<a name="BAG_ALL_DISTINCT_BAG_OF_SET-val"><b>BAG_ALL_DISTINCT_BAG_OF_SET</b></a>]  Theorem
      
      ⊢ BAG_ALL_DISTINCT (BAG_OF_SET s)
   
   [<a name="BAG_ALL_DISTINCT_BAG_UNION-val"><b>BAG_ALL_DISTINCT_BAG_UNION</b></a>]  Theorem
      
      ⊢ ∀b1 b2.
          BAG_ALL_DISTINCT (b1 ⊎ b2) ⇔
          BAG_ALL_DISTINCT b1 ∧ BAG_ALL_DISTINCT b2 ∧ BAG_DISJOINT b1 b2
   
   [<a name="BAG_ALL_DISTINCT_DELETE-val"><b>BAG_ALL_DISTINCT_DELETE</b></a>]  Theorem
      
      ⊢ BAG_ALL_DISTINCT b ⇔ ∀e. e ⋲ b ⇒ ¬(e ⋲ b − {|e|})
   
   [<a name="BAG_ALL_DISTINCT_DIFF-val"><b>BAG_ALL_DISTINCT_DIFF</b></a>]  Theorem
      
      ⊢ ∀b1 b2. BAG_ALL_DISTINCT b1 ⇒ BAG_ALL_DISTINCT (b1 − b2)
   
   [<a name="BAG_ALL_DISTINCT_EXTENSION-val"><b>BAG_ALL_DISTINCT_EXTENSION</b></a>]  Theorem
      
      ⊢ ∀b1 b2.
          BAG_ALL_DISTINCT b1 ∧ BAG_ALL_DISTINCT b2 ⇒
          (b1 = b2 ⇔ ∀x. x ⋲ b1 ⇔ x ⋲ b2)
   
   [<a name="BAG_ALL_DISTINCT_SET-val"><b>BAG_ALL_DISTINCT_SET</b></a>]  Theorem
      
      ⊢ BAG_ALL_DISTINCT b ⇔ unibag b = b
   
   [<a name="BAG_ALL_DISTINCT_SUB_BAG-val"><b>BAG_ALL_DISTINCT_SUB_BAG</b></a>]  Theorem
      
      ⊢ ∀s t. s ≤ t ∧ BAG_ALL_DISTINCT t ⇒ BAG_ALL_DISTINCT s
   
   [<a name="BAG_ALL_DISTINCT_THM-val"><b>BAG_ALL_DISTINCT_THM</b></a>]  Theorem
      
      ⊢ BAG_ALL_DISTINCT {||} ∧
        ∀e b.
          BAG_ALL_DISTINCT (BAG_INSERT e b) ⇔ ¬(e ⋲ b) ∧ BAG_ALL_DISTINCT b
   
   [<a name="BAG_CARD_BAG_INN-val"><b>BAG_CARD_BAG_INN</b></a>]  Theorem
      
      ⊢ ∀b. FINITE_BAG b ⇒ ∀n e. BAG_INN e n b ⇒ n ≤ BAG_CARD b
   
   [<a name="BAG_CARD_BAG_OF_SET-val"><b>BAG_CARD_BAG_OF_SET</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ BAG_CARD (BAG_OF_SET s) = CARD s
   
   [<a name="BAG_CARD_DIFF-val"><b>BAG_CARD_DIFF</b></a>]  Theorem
      
      ⊢ ∀b. FINITE_BAG b ⇒
            ∀c. c ≤ b ⇒ BAG_CARD (b − c) = BAG_CARD b − BAG_CARD c
   
   [<a name="BAG_CARD_EMPTY-val"><b>BAG_CARD_EMPTY</b></a>]  Theorem
      
      ⊢ BAG_CARD {||} = 0
   
   [<a name="BAG_CARD_EQ_CARD_SET_OF_BAG-val"><b>BAG_CARD_EQ_CARD_SET_OF_BAG</b></a>]  Theorem
      
      ⊢ ∀b. FINITE_BAG b ⇒
            (∀e. e ⋲ b ⇒ b e = 1) ⇒
            BAG_CARD b = CARD (SET_OF_BAG b)
   
   [<a name="BAG_CARD_THM-val"><b>BAG_CARD_THM</b></a>]  Theorem
      
      ⊢ BAG_CARD {||} = 0 ∧
        ∀b. FINITE_BAG b ⇒ ∀e. BAG_CARD (BAG_INSERT e b) = BAG_CARD b + 1
   
   [<a name="BAG_CARD_UNION-val"><b>BAG_CARD_UNION</b></a>]  Theorem
      
      ⊢ ∀b1 b2.
          FINITE_BAG b1 ∧ FINITE_BAG b2 ⇒
          BAG_CARD (b1 ⊎ b2) = BAG_CARD b1 + BAG_CARD b2
   
   [<a name="BAG_CHOICE_SING-val"><b>BAG_CHOICE_SING</b></a>]  Theorem
      
      ⊢ BAG_CHOICE {|x|} = x
   
   [<a name="BAG_DECOMPOSE-val"><b>BAG_DECOMPOSE</b></a>]  Theorem
      
      ⊢ ∀e b. e ⋲ b ⇒ ∃b'. b = BAG_INSERT e b'
   
   [<a name="BAG_DELETE_11-val"><b>BAG_DELETE_11</b></a>]  Theorem
      
      ⊢ ∀b0 e1 e2 b1 b2.
          BAG_DELETE b0 e1 b1 ∧ BAG_DELETE b0 e2 b2 ⇒ (e1 = e2 ⇔ b1 = b2)
   
   [<a name="BAG_DELETE_BAG_IN-val"><b>BAG_DELETE_BAG_IN</b></a>]  Theorem
      
      ⊢ ∀b0 b e. BAG_DELETE b0 e b ⇒ e ⋲ b0
   
   [<a name="BAG_DELETE_BAG_IN_down-val"><b>BAG_DELETE_BAG_IN_down</b></a>]  Theorem
      
      ⊢ ∀b0 b e1 e2. BAG_DELETE b0 e1 b ∧ e1 ≠ e2 ∧ e2 ⋲ b0 ⇒ e2 ⋲ b
   
   [<a name="BAG_DELETE_BAG_IN_up-val"><b>BAG_DELETE_BAG_IN_up</b></a>]  Theorem
      
      ⊢ ∀b0 b e. BAG_DELETE b0 e b ⇒ ∀e'. e' ⋲ b ⇒ e' ⋲ b0
   
   [<a name="BAG_DELETE_EMPTY-val"><b>BAG_DELETE_EMPTY</b></a>]  Theorem
      
      ⊢ ∀e b. ¬BAG_DELETE {||} e b
   
   [<a name="BAG_DELETE_INSERT-val"><b>BAG_DELETE_INSERT</b></a>]  Theorem
      
      ⊢ ∀x y b1 b2.
          BAG_DELETE (BAG_INSERT x b1) y b2 ⇒
          x = y ∧ b1 = b2 ∨ (∃b3. BAG_DELETE b1 y b3) ∧ x ≠ y
   
   [<a name="BAG_DELETE_PSUB_BAG-val"><b>BAG_DELETE_PSUB_BAG</b></a>]  Theorem
      
      ⊢ ∀b0 e b. BAG_DELETE b0 e b ⇒ b &lt; b0
   
   [<a name="BAG_DELETE_SING-val"><b>BAG_DELETE_SING</b></a>]  Theorem
      
      ⊢ ∀b e. BAG_DELETE b e {||} ⇒ SING_BAG b
   
   [<a name="BAG_DELETE_TWICE-val"><b>BAG_DELETE_TWICE</b></a>]  Theorem
      
      ⊢ ∀b0 e1 e2 b1 b2.
          BAG_DELETE b0 e1 b1 ∧ BAG_DELETE b0 e2 b2 ∧ b1 ≠ b2 ⇒
          ∃b. BAG_DELETE b1 e2 b ∧ BAG_DELETE b2 e1 b
   
   [<a name="BAG_DELETE_commutes-val"><b>BAG_DELETE_commutes</b></a>]  Theorem
      
      ⊢ ∀b0 b1 b2 e1 e2.
          BAG_DELETE b0 e1 b1 ∧ BAG_DELETE b1 e2 b2 ⇒
          ∃b'. BAG_DELETE b0 e2 b' ∧ BAG_DELETE b' e1 b2
   
   [<a name="BAG_DELETE_concrete-val"><b>BAG_DELETE_concrete</b></a>]  Theorem
      
      ⊢ ∀b0 b e.
          BAG_DELETE b0 e b ⇔
          b0 e &gt; 0 ∧ b = (λx. if x = e then b0 e − 1 else b0 x)
   
   [<a name="BAG_DIFF_2L-val"><b>BAG_DIFF_2L</b></a>]  Theorem
      
      ⊢ ∀X Y Z. X − Y − Z = X − (Y ⊎ Z)
   
   [<a name="BAG_DIFF_2R-val"><b>BAG_DIFF_2R</b></a>]  Theorem
      
      ⊢ ∀A B C. C ≤ B ⇒ A − (B − C) = A ⊎ C − B
   
   [<a name="BAG_DIFF_EMPTY-val"><b>BAG_DIFF_EMPTY</b></a>]  Theorem
      
      ⊢ (∀b. b − b = {||}) ∧ (∀b. b − {||} = b) ∧ (∀b. {||} − b = {||}) ∧
        ∀b1 b2. b1 ≤ b2 ⇒ b1 − b2 = {||}
   
   [<a name="BAG_DIFF_EMPTY_simple-val"><b>BAG_DIFF_EMPTY_simple</b></a>]  Theorem
      
      ⊢ (∀b. b − b = {||}) ∧ (∀b. b − {||} = b) ∧ ∀b. {||} − b = {||}
   
   [<a name="BAG_DIFF_EQ_EMPTY-val"><b>BAG_DIFF_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ b − c = {||} ⇔ b ≤ c
   
   [<a name="BAG_DIFF_INSERT-val"><b>BAG_DIFF_INSERT</b></a>]  Theorem
      
      ⊢ ∀x b1 b2. ¬(x ⋲ b1) ⇒ BAG_INSERT x b2 − b1 = BAG_INSERT x (b2 − b1)
   
   [<a name="BAG_DIFF_INSERT_SUB_BAG-val"><b>BAG_DIFF_INSERT_SUB_BAG</b></a>]  Theorem
      
      ⊢ c ≤ b ⇒ BAG_INSERT e b − c = BAG_INSERT e (b − c)
   
   [<a name="BAG_DIFF_INSERT_same-val"><b>BAG_DIFF_INSERT_same</b></a>]  Theorem
      
      ⊢ ∀x b1 b2. BAG_INSERT x b1 − BAG_INSERT x b2 = b1 − b2
   
   [<a name="BAG_DIFF_UNION_eliminate-val"><b>BAG_DIFF_UNION_eliminate</b></a>]  Theorem
      
      ⊢ ∀b1 b2 b3.
          b1 ⊎ b2 − (b1 ⊎ b3) = b2 − b3 ∧ b1 ⊎ b2 − (b3 ⊎ b1) = b2 − b3 ∧
          b2 ⊎ b1 − (b1 ⊎ b3) = b2 − b3 ∧ b2 ⊎ b1 − (b3 ⊎ b1) = b2 − b3
   
   [<a name="BAG_DISJOINT_BAG_IN-val"><b>BAG_DISJOINT_BAG_IN</b></a>]  Theorem
      
      ⊢ ∀b1 b2. BAG_DISJOINT b1 b2 ⇔ ∀e. ¬(e ⋲ b1) ∨ ¬(e ⋲ b2)
   
   [<a name="BAG_DISJOINT_BAG_INSERT-val"><b>BAG_DISJOINT_BAG_INSERT</b></a>]  Theorem
      
      ⊢ (∀b1 b2 e1.
           BAG_DISJOINT (BAG_INSERT e1 b1) b2 ⇔
           ¬(e1 ⋲ b2) ∧ BAG_DISJOINT b1 b2) ∧
        ∀b1 b2 e2.
          BAG_DISJOINT b1 (BAG_INSERT e2 b2) ⇔
          ¬(e2 ⋲ b1) ∧ BAG_DISJOINT b1 b2
   
   [<a name="BAG_DISJOINT_BAG_UNION-val"><b>BAG_DISJOINT_BAG_UNION</b></a>]  Theorem
      
      ⊢ (BAG_DISJOINT b1 (b2 ⊎ b3) ⇔
         BAG_DISJOINT b1 b2 ∧ BAG_DISJOINT b1 b3) ∧
        (BAG_DISJOINT (b1 ⊎ b2) b3 ⇔
         BAG_DISJOINT b1 b3 ∧ BAG_DISJOINT b2 b3)
   
   [<a name="BAG_DISJOINT_DIFF-val"><b>BAG_DISJOINT_DIFF</b></a>]  Theorem
      
      ⊢ ∀B1 B2. BAG_DISJOINT (B1 − B2) (B2 − B1)
   
   [<a name="BAG_DISJOINT_EMPTY-val"><b>BAG_DISJOINT_EMPTY</b></a>]  Theorem
      
      ⊢ ∀b. BAG_DISJOINT b {||} ∧ BAG_DISJOINT {||} b
   
   [<a name="BAG_DISJOINT_FOLDR_BAG_UNION-val"><b>BAG_DISJOINT_FOLDR_BAG_UNION</b></a>]  Theorem
      
      ⊢ ∀ls b0 b1.
          BAG_DISJOINT b1 (FOLDR $⊎ b0 ls) ⇔
          EVERY (BAG_DISJOINT b1) (b0::ls)
   
   [<a name="BAG_DISJOINT_SUB_BAG-val"><b>BAG_DISJOINT_SUB_BAG</b></a>]  Theorem
      
      ⊢ ∀b1 b2 b3. b1 ≤ b2 ∧ BAG_DISJOINT b2 b3 ⇒ BAG_DISJOINT b1 b3
   
   [<a name="BAG_DISJOINT_SYM-val"><b>BAG_DISJOINT_SYM</b></a>]  Theorem
      
      ⊢ ∀b1 b2. BAG_DISJOINT b1 b2 ⇔ BAG_DISJOINT b2 b1
   
   [<a name="BAG_EVERY_MERGE-val"><b>BAG_EVERY_MERGE</b></a>]  Theorem
      
      ⊢ BAG_EVERY P (BAG_MERGE b1 b2) ⇔ BAG_EVERY P b1 ∧ BAG_EVERY P b2
   
   [<a name="BAG_EVERY_SET-val"><b>BAG_EVERY_SET</b></a>]  Theorem
      
      ⊢ BAG_EVERY P b ⇔ SET_OF_BAG b ⊆ {x | P x}
   
   [<a name="BAG_EVERY_THM-val"><b>BAG_EVERY_THM</b></a>]  Theorem
      
      ⊢ (∀P. BAG_EVERY P {||}) ∧
        ∀P e b. BAG_EVERY P (BAG_INSERT e b) ⇔ P e ∧ BAG_EVERY P b
   
   [<a name="BAG_EVERY_UNION-val"><b>BAG_EVERY_UNION</b></a>]  Theorem
      
      ⊢ BAG_EVERY P (b1 ⊎ b2) ⇔ BAG_EVERY P b1 ∧ BAG_EVERY P b2
   
   [<a name="BAG_EXTENSION-val"><b>BAG_EXTENSION</b></a>]  Theorem
      
      ⊢ ∀b1 b2. b1 = b2 ⇔ ∀n e. BAG_INN e n b1 ⇔ BAG_INN e n b2
   
   [<a name="BAG_FILTER_BAG_INSERT-val"><b>BAG_FILTER_BAG_INSERT</b></a>]  Theorem
      
      ⊢ BAG_FILTER P (BAG_INSERT e b) =
        if P e then BAG_INSERT e (BAG_FILTER P b) else BAG_FILTER P b
   
   [<a name="BAG_FILTER_BAG_OF_SET-val"><b>BAG_FILTER_BAG_OF_SET</b></a>]  Theorem
      
      ⊢ ∀P s. BAG_FILTER P (BAG_OF_SET s) = BAG_OF_SET (s ∩ {x | P x})
   
   [<a name="BAG_FILTER_BAG_UNION-val"><b>BAG_FILTER_BAG_UNION</b></a>]  Theorem
      
      ⊢ BAG_FILTER P (b1 ⊎ b2) = BAG_FILTER P b1 ⊎ BAG_FILTER P b2
   
   [<a name="BAG_FILTER_EMPTY-val"><b>BAG_FILTER_EMPTY</b></a>]  Theorem
      
      ⊢ BAG_FILTER P {||} = {||}
   
   [<a name="BAG_FILTER_EQ_EMPTY-val"><b>BAG_FILTER_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ BAG_FILTER P b = {||} ⇔ BAG_EVERY ($¬ ∘ P) b
   
   [<a name="BAG_FILTER_FILTER-val"><b>BAG_FILTER_FILTER</b></a>]  Theorem
      
      ⊢ BAG_FILTER P (BAG_FILTER Q b) = BAG_FILTER (λa. P a ∧ Q a) b
   
   [<a name="BAG_FILTER_SPLIT-val"><b>BAG_FILTER_SPLIT</b></a>]  Theorem
      
      ⊢ ∀s b. BAG_FILTER s b ⊎ BAG_FILTER (COMPL s) b = b
   
   [<a name="BAG_FILTER_SUB_BAG-val"><b>BAG_FILTER_SUB_BAG</b></a>]  Theorem
      
      ⊢ ∀P b. BAG_FILTER P b ≤ b
   
   [<a name="BAG_GEN_PROD_ALL_ONES-val"><b>BAG_GEN_PROD_ALL_ONES</b></a>]  Theorem
      
      ⊢ ∀b. FINITE_BAG b ⇒ BAG_GEN_PROD b 1 = 1 ⇒ ∀x. x ⋲ b ⇒ x = 1
   
   [<a name="BAG_GEN_PROD_EMPTY-val"><b>BAG_GEN_PROD_EMPTY</b></a>]  Theorem
      
      ⊢ ∀n. BAG_GEN_PROD {||} n = n
   
   [<a name="BAG_GEN_PROD_EQ_0-val"><b>BAG_GEN_PROD_EQ_0</b></a>]  Theorem
      
      ⊢ ∀b. FINITE_BAG b ⇒ ∀e. BAG_GEN_PROD b e = 0 ⇔ 0 ⋲ b ∨ e = 0
   
   [<a name="BAG_GEN_PROD_EQ_1-val"><b>BAG_GEN_PROD_EQ_1</b></a>]  Theorem
      
      ⊢ ∀b. FINITE_BAG b ⇒ ∀e. BAG_GEN_PROD b e = 1 ⇒ e = 1
   
   [<a name="BAG_GEN_PROD_POSITIVE-val"><b>BAG_GEN_PROD_POSITIVE</b></a>]  Theorem
      
      ⊢ ∀b. FINITE_BAG b ⇒ (∀x. x ⋲ b ⇒ 0 &lt; x) ⇒ 0 &lt; BAG_GEN_PROD b 1
   
   [<a name="BAG_GEN_PROD_REC-val"><b>BAG_GEN_PROD_REC</b></a>]  Theorem
      
      ⊢ ∀b. FINITE_BAG b ⇒
            ∀x a. BAG_GEN_PROD (BAG_INSERT x b) a = x * BAG_GEN_PROD b a
   
   [<a name="BAG_GEN_PROD_TAILREC-val"><b>BAG_GEN_PROD_TAILREC</b></a>]  Theorem
      
      ⊢ ∀b. FINITE_BAG b ⇒
            ∀x a. BAG_GEN_PROD (BAG_INSERT x b) a = BAG_GEN_PROD b (x * a)
   
   [<a name="BAG_GEN_PROD_UNION-val"><b>BAG_GEN_PROD_UNION</b></a>]  Theorem
      
      ⊢ ∀b1 b2.
          FINITE_BAG b1 ∧ FINITE_BAG b2 ⇒
          BAG_GEN_PROD (b1 ⊎ b2) 1 = BAG_GEN_PROD b1 1 * BAG_GEN_PROD b2 1
   
   [<a name="BAG_GEN_PROD_UNION_LEM-val"><b>BAG_GEN_PROD_UNION_LEM</b></a>]  Theorem
      
      ⊢ ∀b1.
          FINITE_BAG b1 ⇒
          ∀b2 a b.
            FINITE_BAG b2 ⇒
            BAG_GEN_PROD (b1 ⊎ b2) (a * b) =
            BAG_GEN_PROD b1 a * BAG_GEN_PROD b2 b
   
   [<a name="BAG_GEN_SUM_EMPTY-val"><b>BAG_GEN_SUM_EMPTY</b></a>]  Theorem
      
      ⊢ ∀n. BAG_GEN_SUM {||} n = n
   
   [<a name="BAG_GEN_SUM_REC-val"><b>BAG_GEN_SUM_REC</b></a>]  Theorem
      
      ⊢ ∀b. FINITE_BAG b ⇒
            ∀x a. BAG_GEN_SUM (BAG_INSERT x b) a = x + BAG_GEN_SUM b a
   
   [<a name="BAG_GEN_SUM_TAILREC-val"><b>BAG_GEN_SUM_TAILREC</b></a>]  Theorem
      
      ⊢ ∀b. FINITE_BAG b ⇒
            ∀x a. BAG_GEN_SUM (BAG_INSERT x b) a = BAG_GEN_SUM b (x + a)
   
   [<a name="BAG_IMAGE_BAG_OF_SET_ITSET_BAG_INSERT-val"><b>BAG_IMAGE_BAG_OF_SET_ITSET_BAG_INSERT</b></a>]  Theorem
      
      ⊢ ∀f s.
          FINITE s ⇒
          BAG_IMAGE f (BAG_OF_SET s) =
          ITSET (λx b. BAG_INSERT (f x) b) s {||}
   
   [<a name="BAG_IMAGE_COMPOSE-val"><b>BAG_IMAGE_COMPOSE</b></a>]  Theorem
      
      ⊢ ∀f g b.
          FINITE_BAG b ⇒ BAG_IMAGE (f ∘ g) b = BAG_IMAGE f (BAG_IMAGE g b)
   
   [<a name="BAG_IMAGE_CONG-val"><b>BAG_IMAGE_CONG</b></a>]  Theorem
      
      ⊢ ∀f1 b1 f2 b2.
          b1 = b2 ∧ (∀x. x ⋲ b1 ⇒ f1 x = f2 x) ⇒
          BAG_IMAGE f1 b1 = BAG_IMAGE f2 b2
   
   [<a name="BAG_IMAGE_EMPTY-val"><b>BAG_IMAGE_EMPTY</b></a>]  Theorem
      
      ⊢ ∀f. BAG_IMAGE f {||} = {||}
   
   [<a name="BAG_IMAGE_EQ_EMPTY-val"><b>BAG_IMAGE_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ FINITE_BAG b ⇒ (BAG_IMAGE f b = {||} ⇔ b = {||})
   
   [<a name="BAG_IMAGE_FINITE-val"><b>BAG_IMAGE_FINITE</b></a>]  Theorem
      
      ⊢ ∀b. FINITE_BAG b ⇒ FINITE_BAG (BAG_IMAGE f b)
   
   [<a name="BAG_IMAGE_FINITE_I-val"><b>BAG_IMAGE_FINITE_I</b></a>]  Theorem
      
      ⊢ ∀b. FINITE_BAG b ⇒ BAG_IMAGE I b = b
   
   [<a name="BAG_IMAGE_FINITE_INSERT-val"><b>BAG_IMAGE_FINITE_INSERT</b></a>]  Theorem
      
      ⊢ ∀b f e.
          FINITE_BAG b ⇒
          BAG_IMAGE f (BAG_INSERT e b) = BAG_INSERT (f e) (BAG_IMAGE f b)
   
   [<a name="BAG_IMAGE_FINITE_RESTRICTED_I-val"><b>BAG_IMAGE_FINITE_RESTRICTED_I</b></a>]  Theorem
      
      ⊢ ∀b. FINITE_BAG b ∧ BAG_EVERY (λe. f e = e) b ⇒ BAG_IMAGE f b = b
   
   [<a name="BAG_IMAGE_FINITE_UNION-val"><b>BAG_IMAGE_FINITE_UNION</b></a>]  Theorem
      
      ⊢ ∀b1 b2 f.
          FINITE_BAG b1 ∧ FINITE_BAG b2 ⇒
          BAG_IMAGE f (b1 ⊎ b2) = BAG_IMAGE f b1 ⊎ BAG_IMAGE f b2
   
   [<a name="BAG_INN_0-val"><b>BAG_INN_0</b></a>]  Theorem
      
      ⊢ ∀b e. BAG_INN e 0 b
   
   [<a name="BAG_INN_BAG_DELETE-val"><b>BAG_INN_BAG_DELETE</b></a>]  Theorem
      
      ⊢ ∀b n e. BAG_INN e n b ∧ n &gt; 0 ⇒ ∃b'. BAG_DELETE b e b'
   
   [<a name="BAG_INN_BAG_FILTER-val"><b>BAG_INN_BAG_FILTER</b></a>]  Theorem
      
      ⊢ BAG_INN e n (BAG_FILTER P b) ⇔ n = 0 ∨ P e ∧ BAG_INN e n b
   
   [<a name="BAG_INN_BAG_INSERT-val"><b>BAG_INN_BAG_INSERT</b></a>]  Theorem
      
      ⊢ ∀b e1 e2.
          BAG_INN e1 n (BAG_INSERT e2 b) ⇔
          BAG_INN e1 (n − 1) b ∧ e1 = e2 ∨ BAG_INN e1 n b
   
   [<a name="BAG_INN_BAG_INSERT_STRONG-val"><b>BAG_INN_BAG_INSERT_STRONG</b></a>]  Theorem
      
      ⊢ ∀b n e1 e2.
          BAG_INN e1 n (BAG_INSERT e2 b) ⇔
          BAG_INN e1 (n − 1) b ∧ e1 = e2 ∨ BAG_INN e1 n b ∧ e1 ≠ e2
   
   [<a name="BAG_INN_BAG_MERGE-val"><b>BAG_INN_BAG_MERGE</b></a>]  Theorem
      
      ⊢ ∀n e b1 b2.
          BAG_INN e n (BAG_MERGE b1 b2) ⇔ BAG_INN e n b1 ∨ BAG_INN e n b2
   
   [<a name="BAG_INN_BAG_UNION-val"><b>BAG_INN_BAG_UNION</b></a>]  Theorem
      
      ⊢ ∀n e b1 b2.
          BAG_INN e n (b1 ⊎ b2) ⇔
          ∃m1 m2. n = m1 + m2 ∧ BAG_INN e m1 b1 ∧ BAG_INN e m2 b2
   
   [<a name="BAG_INN_EMPTY_BAG-val"><b>BAG_INN_EMPTY_BAG</b></a>]  Theorem
      
      ⊢ ∀e n. BAG_INN e n {||} ⇔ n = 0
   
   [<a name="BAG_INN_LESS-val"><b>BAG_INN_LESS</b></a>]  Theorem
      
      ⊢ ∀b e n m. BAG_INN e n b ∧ m &lt; n ⇒ BAG_INN e m b
   
   [<a name="BAG_INSERT_CHOICE_REST-val"><b>BAG_INSERT_CHOICE_REST</b></a>]  Theorem
      
      ⊢ ∀b. b ≠ {||} ⇒ b = BAG_INSERT (BAG_CHOICE b) (BAG_REST b)
   
   [<a name="BAG_INSERT_DIFF-val"><b>BAG_INSERT_DIFF</b></a>]  Theorem
      
      ⊢ ∀x b. BAG_INSERT x b ≠ b
   
   [<a name="BAG_INSERT_EQUAL-val"><b>BAG_INSERT_EQUAL</b></a>]  Theorem
      
      ⊢ BAG_INSERT a M = BAG_INSERT b N ⇔
        M = N ∧ a = b ∨ ∃k. M = BAG_INSERT b k ∧ N = BAG_INSERT a k
   
   [<a name="BAG_INSERT_EQ_MERGE_DIFF-val"><b>BAG_INSERT_EQ_MERGE_DIFF</b></a>]  Theorem
      
      ⊢ ∀a b c e.
          BAG_INSERT e a = BAG_MERGE b c ⇒
          BAG_MERGE b c = BAG_INSERT e (BAG_MERGE (b − {|e|}) (c − {|e|}))
   
   [<a name="BAG_INSERT_EQ_UNION-val"><b>BAG_INSERT_EQ_UNION</b></a>]  Theorem
      
      ⊢ ∀e b1 b2 b. BAG_INSERT e b = b1 ⊎ b2 ⇒ e ⋲ b1 ∨ e ⋲ b2
   
   [<a name="BAG_INSERT_NOT_EMPTY-val"><b>BAG_INSERT_NOT_EMPTY</b></a>]  Theorem
      
      ⊢ ∀x b. BAG_INSERT x b ≠ {||}
   
   [<a name="BAG_INSERT_ONE_ONE-val"><b>BAG_INSERT_ONE_ONE</b></a>]  Theorem
      
      ⊢ ∀b1 b2 x. BAG_INSERT x b1 = BAG_INSERT x b2 ⇔ b1 = b2
   
   [<a name="BAG_INSERT_SUB_BAG_E-val"><b>BAG_INSERT_SUB_BAG_E</b></a>]  Theorem
      
      ⊢ BAG_INSERT e b ≤ c ⇒ e ⋲ c ∧ b ≤ c
   
   [<a name="BAG_INSERT_UNION-val"><b>BAG_INSERT_UNION</b></a>]  Theorem
      
      ⊢ ∀b e. BAG_INSERT e b = EL_BAG e ⊎ b
   
   [<a name="BAG_INSERT_commutes-val"><b>BAG_INSERT_commutes</b></a>]  Theorem
      
      ⊢ ∀b e1 e2.
          BAG_INSERT e1 (BAG_INSERT e2 b) = BAG_INSERT e2 (BAG_INSERT e1 b)
   
   [<a name="BAG_INTER_FINITE-val"><b>BAG_INTER_FINITE</b></a>]  Theorem
      
      ⊢ FINITE_BAG b1 ∨ FINITE_BAG b2 ⇒ FINITE_BAG (BAG_INTER b1 b2)
   
   [<a name="BAG_INTER_SUB_BAG-val"><b>BAG_INTER_SUB_BAG</b></a>]  Theorem
      
      ⊢ BAG_INTER b1 b2 ≤ b1 ∧ BAG_INTER b1 b2 ≤ b2
   
   [<a name="BAG_IN_BAG_DELETE-val"><b>BAG_IN_BAG_DELETE</b></a>]  Theorem
      
      ⊢ ∀b e. e ⋲ b ⇒ ∃b'. BAG_DELETE b e b'
   
   [<a name="BAG_IN_BAG_DIFF_ALL_DISTINCT-val"><b>BAG_IN_BAG_DIFF_ALL_DISTINCT</b></a>]  Theorem
      
      ⊢ ∀b1 b2 e. BAG_ALL_DISTINCT b1 ⇒ (e ⋲ b1 − b2 ⇔ e ⋲ b1 ∧ ¬(e ⋲ b2))
   
   [<a name="BAG_IN_BAG_FILTER-val"><b>BAG_IN_BAG_FILTER</b></a>]  Theorem
      
      ⊢ e ⋲ BAG_FILTER P b ⇔ P e ∧ e ⋲ b
   
   [<a name="BAG_IN_BAG_IMAGE_IMP-val"><b>BAG_IN_BAG_IMAGE_IMP</b></a>]  Theorem
      
      ⊢ ∀x f b. x ⋲ BAG_IMAGE f b ⇒ ∃y. y ⋲ b ∧ f y = x
   
   [<a name="BAG_IN_BAG_INSERT-val"><b>BAG_IN_BAG_INSERT</b></a>]  Theorem
      
      ⊢ ∀b e1 e2. e1 ⋲ BAG_INSERT e2 b ⇔ e1 = e2 ∨ e1 ⋲ b
   
   [<a name="BAG_IN_BAG_MERGE-val"><b>BAG_IN_BAG_MERGE</b></a>]  Theorem
      
      ⊢ ∀e b1 b2. e ⋲ BAG_MERGE b1 b2 ⇔ e ⋲ b1 ∨ e ⋲ b2
   
   [<a name="BAG_IN_BAG_OF_SET-val"><b>BAG_IN_BAG_OF_SET</b></a>]  Theorem
      
      ⊢ ∀P p. p ⋲ BAG_OF_SET P ⇔ p ∈ P
   
   [<a name="BAG_IN_BAG_UNION-val"><b>BAG_IN_BAG_UNION</b></a>]  Theorem
      
      ⊢ ∀b1 b2 e. e ⋲ b1 ⊎ b2 ⇔ e ⋲ b1 ∨ e ⋲ b2
   
   [<a name="BAG_IN_BIG_BAG_UNION-val"><b>BAG_IN_BIG_BAG_UNION</b></a>]  Theorem
      
      ⊢ FINITE P ⇒ (e ⋲ BIG_BAG_UNION P ⇔ ∃b. e ⋲ b ∧ b ∈ P)
   
   [<a name="BAG_IN_DIFF_E-val"><b>BAG_IN_DIFF_E</b></a>]  Theorem
      
      ⊢ e ⋲ b1 − b2 ⇒ e ⋲ b1
   
   [<a name="BAG_IN_DIFF_I-val"><b>BAG_IN_DIFF_I</b></a>]  Theorem
      
      ⊢ e ⋲ b1 ∧ ¬(e ⋲ b2) ⇒ e ⋲ b1 − b2
   
   [<a name="BAG_IN_DIVIDES-val"><b>BAG_IN_DIVIDES</b></a>]  Theorem
      
      ⊢ ∀b x a. FINITE_BAG b ∧ x ⋲ b ⇒ divides x (BAG_GEN_PROD b a)
   
   [<a name="BAG_IN_FINITE_BAG_IMAGE-val"><b>BAG_IN_FINITE_BAG_IMAGE</b></a>]  Theorem
      
      ⊢ FINITE_BAG b ⇒ (x ⋲ BAG_IMAGE f b ⇔ ∃y. f y = x ∧ y ⋲ b)
   
   [<a name="BAG_IN_unibag-val"><b>BAG_IN_unibag</b></a>]  Theorem
      
      ⊢ ∀e b. e ⋲ unibag b ⇔ e ⋲ b
   
   [<a name="BAG_LESS_ADD-val"><b>BAG_LESS_ADD</b></a>]  Theorem
      
      ⊢ mlt1 r N (M0 ⊎ {|a|}) ⇒
        (∃M. mlt1 r M M0 ∧ N = M ⊎ {|a|}) ∨
        ∃KK. (∀b. b ⋲ KK ⇒ r b a) ∧ N = M0 ⊎ KK
   
   [<a name="BAG_MEMBER_NOT_EMPTY-val"><b>BAG_MEMBER_NOT_EMPTY</b></a>]  Theorem
      
      ⊢ ∀b. (∃x. x ⋲ b) ⇔ b ≠ {||}
   
   [<a name="BAG_MERGE_BAG_INSERT-val"><b>BAG_MERGE_BAG_INSERT</b></a>]  Theorem
      
      ⊢ ∀e a b.
          (a e ≤ b e ⇒
           BAG_MERGE a (BAG_INSERT e b) = BAG_INSERT e (BAG_MERGE a b)) ∧
          (b e &lt; a e ⇒ BAG_MERGE a (BAG_INSERT e b) = BAG_MERGE a b) ∧
          (a e &lt; b e ⇒ BAG_MERGE (BAG_INSERT e a) b = BAG_MERGE a b) ∧
          (b e ≤ a e ⇒
           BAG_MERGE (BAG_INSERT e a) b = BAG_INSERT e (BAG_MERGE a b)) ∧
          (a e = b e ⇒
           BAG_MERGE (BAG_INSERT e a) (BAG_INSERT e b) =
           BAG_INSERT e (BAG_MERGE a b))
   
   [<a name="BAG_MERGE_CARD-val"><b>BAG_MERGE_CARD</b></a>]  Theorem
      
      ⊢ ∀a b.
          FINITE_BAG a ∧ FINITE_BAG b ⇒
          BAG_CARD (BAG_MERGE a b) ≤ BAG_CARD a + BAG_CARD b
   
   [<a name="BAG_MERGE_ELBAG_SUB_BAG_INSERT-val"><b>BAG_MERGE_ELBAG_SUB_BAG_INSERT</b></a>]  Theorem
      
      ⊢ ∀A b. BAG_MERGE {|A|} b ≤ BAG_INSERT A b
   
   [<a name="BAG_MERGE_EMPTY-val"><b>BAG_MERGE_EMPTY</b></a>]  Theorem
      
      ⊢ ∀b. BAG_MERGE {||} b = b ∧ BAG_MERGE b {||} = b
   
   [<a name="BAG_MERGE_EQ_EMPTY-val"><b>BAG_MERGE_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ ∀a b. BAG_MERGE a b = {||} ⇔ a = {||} ∧ b = {||}
   
   [<a name="BAG_MERGE_IDEM-val"><b>BAG_MERGE_IDEM</b></a>]  Theorem
      
      ⊢ ∀b. BAG_MERGE b b = b
   
   [<a name="BAG_MERGE_SUB_BAG_UNION-val"><b>BAG_MERGE_SUB_BAG_UNION</b></a>]  Theorem
      
      ⊢ ∀s t. BAG_MERGE s t ≤ s ⊎ t
   
   [<a name="BAG_NOT_LESS_EMPTY-val"><b>BAG_NOT_LESS_EMPTY</b></a>]  Theorem
      
      ⊢ ¬mlt1 r b {||}
   
   [<a name="BAG_OF_EMPTY-val"><b>BAG_OF_EMPTY</b></a>]  Theorem
      
      ⊢ SET_OF_BAG {||} = ∅
   
   [<a name="BAG_OF_SET_BAG_DIFF_DIFF-val"><b>BAG_OF_SET_BAG_DIFF_DIFF</b></a>]  Theorem
      
      ⊢ ∀b s. BAG_OF_SET s − b = BAG_OF_SET (s DIFF SET_OF_BAG b)
   
   [<a name="BAG_OF_SET_DIFF-val"><b>BAG_OF_SET_DIFF</b></a>]  Theorem
      
      ⊢ ∀b b'.
          BAG_OF_SET (b DIFF b') = BAG_FILTER (COMPL b') (BAG_OF_SET b)
   
   [<a name="BAG_OF_SET_DISJOINT_UNION-val"><b>BAG_OF_SET_DISJOINT_UNION</b></a>]  Theorem
      
      ⊢ ∀s1 s2.
          DISJOINT s1 s2 ⇒
          BAG_OF_SET (s1 ∪ s2) = BAG_OF_SET s1 ⊎ BAG_OF_SET s2
   
   [<a name="BAG_OF_SET_EQ_EMPTY_BAG-val"><b>BAG_OF_SET_EQ_EMPTY_BAG</b></a>]  Theorem
      
      ⊢ BAG_OF_SET s = {||} ⇔ s = ∅
   
   [<a name="BAG_OF_SET_EQ_INSERT-val"><b>BAG_OF_SET_EQ_INSERT</b></a>]  Theorem
      
      ⊢ ∀e b s. BAG_INSERT e b = BAG_OF_SET s ⇒ ∃s'. s = e INSERT s'
   
   [<a name="BAG_OF_SET_IMAGE_INJ-val"><b>BAG_OF_SET_IMAGE_INJ</b></a>]  Theorem
      
      ⊢ ∀f s.
          (∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y) ⇒
          BAG_OF_SET (IMAGE f s) = BAG_IMAGE f (BAG_OF_SET s)
   
   [<a name="BAG_OF_SET_INJ-val"><b>BAG_OF_SET_INJ</b></a>]  Theorem
      
      ⊢ ∀s1 s2. BAG_OF_SET s1 = BAG_OF_SET s2 ⇔ s1 = s2
   
   [<a name="BAG_OF_SET_INSERT-val"><b>BAG_OF_SET_INSERT</b></a>]  Theorem
      
      ⊢ ∀e s. BAG_OF_SET (e INSERT s) = BAG_MERGE {|e|} (BAG_OF_SET s)
   
   [<a name="BAG_OF_SET_INSERT_NON_ELEMENT-val"><b>BAG_OF_SET_INSERT_NON_ELEMENT</b></a>]  Theorem
      
      ⊢ ∀e s. e ∉ s ⇒ BAG_OF_SET (e INSERT s) = BAG_INSERT e (BAG_OF_SET s)
   
   [<a name="BAG_OF_SET_UNION-val"><b>BAG_OF_SET_UNION</b></a>]  Theorem
      
      ⊢ ∀b b'.
          BAG_OF_SET (b ∪ b') = BAG_MERGE (BAG_OF_SET b) (BAG_OF_SET b')
   
   [<a name="BAG_REST_SING-val"><b>BAG_REST_SING</b></a>]  Theorem
      
      ⊢ BAG_REST {|x|} = {||}
   
   [<a name="BAG_SIZE_EMPTY-val"><b>BAG_SIZE_EMPTY</b></a>]  Theorem
      
      ⊢ bag_size eltsize {||} = 0
   
   [<a name="BAG_SIZE_INSERT-val"><b>BAG_SIZE_INSERT</b></a>]  Theorem
      
      ⊢ FINITE_BAG b ⇒
        bag_size eltsize (BAG_INSERT e b) =
        1 + eltsize e + bag_size eltsize b
   
   [<a name="BAG_UNION_DIFF-val"><b>BAG_UNION_DIFF</b></a>]  Theorem
      
      ⊢ ∀X Y Z. Z ≤ Y ⇒ X ⊎ (Y − Z) = X ⊎ Y − Z ∧ Y − Z ⊎ X = X ⊎ Y − Z
   
   [<a name="BAG_UNION_DIFF_eliminate-val"><b>BAG_UNION_DIFF_eliminate</b></a>]  Theorem
      
      ⊢ b ⊎ c − c = b ∧ c ⊎ b − c = b
   
   [<a name="BAG_UNION_EMPTY-val"><b>BAG_UNION_EMPTY</b></a>]  Theorem
      
      ⊢ (∀b. b ⊎ {||} = b) ∧ (∀b. {||} ⊎ b = b) ∧
        ∀b1 b2. b1 ⊎ b2 = {||} ⇔ b1 = {||} ∧ b2 = {||}
   
   [<a name="BAG_UNION_EQ_LCANCEL1-val"><b>BAG_UNION_EQ_LCANCEL1</b></a>]  Theorem
      
      ⊢ b = b ⊎ c ⇔ c = {||}
   
   [<a name="BAG_UNION_EQ_LEFT-val"><b>BAG_UNION_EQ_LEFT</b></a>]  Theorem
      
      ⊢ ∀b c d. b ⊎ c = b ⊎ d ⇒ c = d
   
   [<a name="BAG_UNION_EQ_RCANCEL1-val"><b>BAG_UNION_EQ_RCANCEL1</b></a>]  Theorem
      
      ⊢ b = c ⊎ b ⇔ c = {||}
   
   [<a name="BAG_UNION_INSERT-val"><b>BAG_UNION_INSERT</b></a>]  Theorem
      
      ⊢ ∀e b1 b2.
          BAG_INSERT e b1 ⊎ b2 = BAG_INSERT e (b1 ⊎ b2) ∧
          b1 ⊎ BAG_INSERT e b2 = BAG_INSERT e (b1 ⊎ b2)
   
   [<a name="BAG_UNION_LEFT_CANCEL-val"><b>BAG_UNION_LEFT_CANCEL</b></a>]  Theorem
      
      ⊢ ∀b b1 b2. b ⊎ b1 = b ⊎ b2 ⇔ b1 = b2
   
   [<a name="BAG_UNION_RIGHT_CANCEL-val"><b>BAG_UNION_RIGHT_CANCEL</b></a>]  Theorem
      
      ⊢ ∀b b1 b2. b1 ⊎ b = b2 ⊎ b ⇔ b1 = b2
   
   [<a name="BAG_cases-val"><b>BAG_cases</b></a>]  Theorem
      
      ⊢ ∀b. b = {||} ∨ ∃b0 e. b = BAG_INSERT e b0
   
   [<a name="BCARD_0-val"><b>BCARD_0</b></a>]  Theorem
      
      ⊢ ∀b. FINITE_BAG b ⇒ (BAG_CARD b = 0 ⇔ b = {||})
   
   [<a name="BCARD_SUC-val"><b>BCARD_SUC</b></a>]  Theorem
      
      ⊢ ∀b. FINITE_BAG b ⇒
            ∀n. BAG_CARD b = SUC n ⇔
                ∃b0 e. b = BAG_INSERT e b0 ∧ BAG_CARD b0 = n
   
   [<a name="BIG_BAG_UNION_DELETE-val"><b>BIG_BAG_UNION_DELETE</b></a>]  Theorem
      
      ⊢ FINITE sob ⇒
        BIG_BAG_UNION (sob DELETE b) =
        if b ∈ sob then BIG_BAG_UNION sob − b else BIG_BAG_UNION sob
   
   [<a name="BIG_BAG_UNION_EMPTY-val"><b>BIG_BAG_UNION_EMPTY</b></a>]  Theorem
      
      ⊢ BIG_BAG_UNION ∅ = {||}
   
   [<a name="BIG_BAG_UNION_EQ_ELEMENT-val"><b>BIG_BAG_UNION_EQ_ELEMENT</b></a>]  Theorem
      
      ⊢ FINITE sob ∧ b ∈ sob ⇒
        (BIG_BAG_UNION sob = b ⇔ ∀b'. b' ∈ sob ⇒ b' = b ∨ b' = {||})
   
   [<a name="BIG_BAG_UNION_EQ_EMPTY_BAG-val"><b>BIG_BAG_UNION_EQ_EMPTY_BAG</b></a>]  Theorem
      
      ⊢ ∀sob.
          FINITE sob ⇒ (BIG_BAG_UNION sob = {||} ⇔ ∀b. b ∈ sob ⇒ b = {||})
   
   [<a name="BIG_BAG_UNION_INSERT-val"><b>BIG_BAG_UNION_INSERT</b></a>]  Theorem
      
      ⊢ FINITE sob ⇒
        BIG_BAG_UNION (b INSERT sob) = b ⊎ BIG_BAG_UNION (sob DELETE b)
   
   [<a name="BIG_BAG_UNION_ITSET_BAG_UNION-val"><b>BIG_BAG_UNION_ITSET_BAG_UNION</b></a>]  Theorem
      
      ⊢ ∀sob. FINITE sob ⇒ BIG_BAG_UNION sob = ITSET $⊎ sob {||}
   
   [<a name="BIG_BAG_UNION_UNION-val"><b>BIG_BAG_UNION_UNION</b></a>]  Theorem
      
      ⊢ FINITE s1 ∧ FINITE s2 ⇒
        BIG_BAG_UNION (s1 ∪ s2) =
        BIG_BAG_UNION s1 ⊎ BIG_BAG_UNION s2 − BIG_BAG_UNION (s1 ∩ s2)
   
   [<a name="COMMUTING_ITBAG_INSERT-val"><b>COMMUTING_ITBAG_INSERT</b></a>]  Theorem
      
      ⊢ ∀f b.
          (∀x y z. f x (f y z) = f y (f x z)) ∧ FINITE_BAG b ⇒
          ∀x a. ITBAG f (BAG_INSERT x b) a = ITBAG f b (f x a)
   
   [<a name="COMMUTING_ITBAG_RECURSES-val"><b>COMMUTING_ITBAG_RECURSES</b></a>]  Theorem
      
      ⊢ ∀f e b a.
          (∀x y z. f x (f y z) = f y (f x z)) ∧ FINITE_BAG b ⇒
          ITBAG f (BAG_INSERT e b) a = f e (ITBAG f b a)
   
   [<a name="COMM_BAG_UNION-val"><b>COMM_BAG_UNION</b></a>]  Theorem
      
      ⊢ ∀b1 b2. b1 ⊎ b2 = b2 ⊎ b1
   
   [<a name="C_BAG_INSERT_ONE_ONE-val"><b>C_BAG_INSERT_ONE_ONE</b></a>]  Theorem
      
      ⊢ ∀x y b. BAG_INSERT x b = BAG_INSERT y b ⇔ x = y
   
   [<a name="EL_BAG_11-val"><b>EL_BAG_11</b></a>]  Theorem
      
      ⊢ ∀x y. EL_BAG x = EL_BAG y ⇒ x = y
   
   [<a name="EL_BAG_BAG_INSERT-val"><b>EL_BAG_BAG_INSERT</b></a>]  Theorem
      
      ⊢ {|x|} = BAG_INSERT y b ⇔ x = y ∧ b = {||}
   
   [<a name="EL_BAG_INSERT_squeeze-val"><b>EL_BAG_INSERT_squeeze</b></a>]  Theorem
      
      ⊢ ∀x b y. EL_BAG x = BAG_INSERT y b ⇒ x = y ∧ b = {||}
   
   [<a name="EL_BAG_SUB_BAG-val"><b>EL_BAG_SUB_BAG</b></a>]  Theorem
      
      ⊢ {|x|} ≤ b ⇔ x ⋲ b
   
   [<a name="EMPTY_BAG_alt-val"><b>EMPTY_BAG_alt</b></a>]  Theorem
      
      ⊢ {||} = (λx. 0)
   
   [<a name="FINITE_BAG_DIFF-val"><b>FINITE_BAG_DIFF</b></a>]  Theorem
      
      ⊢ ∀b1. FINITE_BAG b1 ⇒ ∀b2. FINITE_BAG (b1 − b2)
   
   [<a name="FINITE_BAG_DIFF_dual-val"><b>FINITE_BAG_DIFF_dual</b></a>]  Theorem
      
      ⊢ ∀b1. FINITE_BAG b1 ⇒ ∀b2. FINITE_BAG (b2 − b1) ⇒ FINITE_BAG b2
   
   [<a name="FINITE_BAG_FILTER-val"><b>FINITE_BAG_FILTER</b></a>]  Theorem
      
      ⊢ ∀b. FINITE_BAG b ⇒ FINITE_BAG (BAG_FILTER P b)
   
   [<a name="FINITE_BAG_INDUCT-val"><b>FINITE_BAG_INDUCT</b></a>]  Theorem
      
      ⊢ ∀P. P {||} ∧ (∀b. P b ⇒ ∀e. P (BAG_INSERT e b)) ⇒
            ∀b. FINITE_BAG b ⇒ P b
   
   [<a name="FINITE_BAG_INSERT-val"><b>FINITE_BAG_INSERT</b></a>]  Theorem
      
      ⊢ ∀b. FINITE_BAG b ⇒ ∀e. FINITE_BAG (BAG_INSERT e b)
   
   [<a name="FINITE_BAG_MERGE-val"><b>FINITE_BAG_MERGE</b></a>]  Theorem
      
      ⊢ ∀a b. FINITE_BAG (BAG_MERGE a b) ⇔ FINITE_BAG a ∧ FINITE_BAG b
   
   [<a name="FINITE_BAG_OF_SET-val"><b>FINITE_BAG_OF_SET</b></a>]  Theorem
      
      ⊢ ∀s. FINITE_BAG (BAG_OF_SET s) ⇔ FINITE s
   
   [<a name="FINITE_BAG_THM-val"><b>FINITE_BAG_THM</b></a>]  Theorem
      
      ⊢ FINITE_BAG {||} ∧ ∀e b. FINITE_BAG (BAG_INSERT e b) ⇔ FINITE_BAG b
   
   [<a name="FINITE_BAG_UNION-val"><b>FINITE_BAG_UNION</b></a>]  Theorem
      
      ⊢ ∀b1 b2. FINITE_BAG (b1 ⊎ b2) ⇔ FINITE_BAG b1 ∧ FINITE_BAG b2
   
   [<a name="FINITE_BIG_BAG_UNION-val"><b>FINITE_BIG_BAG_UNION</b></a>]  Theorem
      
      ⊢ ∀sob.
          FINITE sob ∧ (∀b. b ∈ sob ⇒ FINITE_BAG b) ⇒
          FINITE_BAG (BIG_BAG_UNION sob)
   
   [<a name="FINITE_EL_BAG-val"><b>FINITE_EL_BAG</b></a>]  Theorem
      
      ⊢ FINITE_BAG (EL_BAG e)
   
   [<a name="FINITE_EMPTY_BAG-val"><b>FINITE_EMPTY_BAG</b></a>]  Theorem
      
      ⊢ FINITE_BAG {||}
   
   [<a name="FINITE_SET_OF_BAG-val"><b>FINITE_SET_OF_BAG</b></a>]  Theorem
      
      ⊢ ∀b. FINITE (SET_OF_BAG b) ⇔ FINITE_BAG b
   
   [<a name="FINITE_SUB_BAG-val"><b>FINITE_SUB_BAG</b></a>]  Theorem
      
      ⊢ ∀b1. FINITE_BAG b1 ⇒ ∀b2. b2 ≤ b1 ⇒ FINITE_BAG b2
   
   [<a name="FINITE_SUB_BAGS-val"><b>FINITE_SUB_BAGS</b></a>]  Theorem
      
      ⊢ ∀b. FINITE_BAG b ⇒ FINITE {s | s ≤ b}
   
   [<a name="IN_SET_OF_BAG-val"><b>IN_SET_OF_BAG</b></a>]  Theorem
      
      ⊢ ∀x b. x ∈ SET_OF_BAG b ⇔ x ⋲ b
   
   [<a name="IN_SET_OF_BAG_NONZERO-val"><b>IN_SET_OF_BAG_NONZERO</b></a>]  Theorem
      
      ⊢ ∀b x. x ∈ SET_OF_BAG b ⇔ b x ≠ 0
   
   [<a name="ITBAG_EMPTY-val"><b>ITBAG_EMPTY</b></a>]  Theorem
      
      ⊢ ∀f acc. ITBAG f {||} acc = acc
   
   [<a name="ITBAG_IND-val"><b>ITBAG_IND</b></a>]  Theorem
      
      ⊢ ∀P. (∀b acc.
               (FINITE_BAG b ∧ b ≠ {||} ⇒
                P (BAG_REST b) (f (BAG_CHOICE b) acc)) ⇒
               P b acc) ⇒
            ∀v v1. P v v1
   
   [<a name="ITBAG_INSERT-val"><b>ITBAG_INSERT</b></a>]  Theorem
      
      ⊢ ∀f acc.
          FINITE_BAG b ⇒
          ITBAG f (BAG_INSERT x b) acc =
          ITBAG f (BAG_REST (BAG_INSERT x b))
            (f (BAG_CHOICE (BAG_INSERT x b)) acc)
   
   [<a name="ITBAG_SING-val"><b>ITBAG_SING</b></a>]  Theorem
      
      ⊢ ITBAG f {|x|} a = f x a
   
   [<a name="ITBAG_THM-val"><b>ITBAG_THM</b></a>]  Theorem
      
      ⊢ ∀b f acc.
          FINITE_BAG b ⇒
          ITBAG f b acc =
          if b = {||} then acc
          else ITBAG f (BAG_REST b) (f (BAG_CHOICE b) acc)
   
   [<a name="ITSET_BAG_INSERT_BAG_UNION_BAG_IMAGE_BAG_OF_SET-val"><b>ITSET_BAG_INSERT_BAG_UNION_BAG_IMAGE_BAG_OF_SET</b></a>]  Theorem
      
      ⊢ ∀f s.
          FINITE s ⇒
          ∀a. ITSET (λx b. BAG_INSERT (f x) b) s a =
              a ⊎ BAG_IMAGE f (BAG_OF_SET s)
   
   [<a name="MONOID_BAG_UNION_EMPTY_BAG-val"><b>MONOID_BAG_UNION_EMPTY_BAG</b></a>]  Theorem
      
      ⊢ MONOID $⊎ {||}
   
   [<a name="NOT_BAG_IN-val"><b>NOT_BAG_IN</b></a>]  Theorem
      
      ⊢ ∀b x. b x = 0 ⇔ ¬(x ⋲ b)
   
   [<a name="NOT_IN_BAG_DIFF-val"><b>NOT_IN_BAG_DIFF</b></a>]  Theorem
      
      ⊢ ∀x b1 b2. ¬(x ⋲ b1) ⇒ b1 − BAG_INSERT x b2 = b1 − b2
   
   [<a name="NOT_IN_EMPTY_BAG-val"><b>NOT_IN_EMPTY_BAG</b></a>]  Theorem
      
      ⊢ ∀x. ¬(x ⋲ {||})
   
   [<a name="NOT_IN_SUB_BAG_INSERT-val"><b>NOT_IN_SUB_BAG_INSERT</b></a>]  Theorem
      
      ⊢ ∀b1 b2 e. ¬(e ⋲ b1) ⇒ (b1 ≤ BAG_INSERT e b2 ⇔ b1 ≤ b2)
   
   [<a name="NOT_mlt_EMPTY-val"><b>NOT_mlt_EMPTY</b></a>]  Theorem
      
      ⊢ ¬mlt R b {||}
   
   [<a name="PSUB_BAG_ANTISYM-val"><b>PSUB_BAG_ANTISYM</b></a>]  Theorem
      
      ⊢ ∀b1 b2. ¬(b1 &lt; b2 ∧ b2 &lt; b1)
   
   [<a name="PSUB_BAG_CARD-val"><b>PSUB_BAG_CARD</b></a>]  Theorem
      
      ⊢ ∀b1 b2. FINITE_BAG b2 ∧ b1 &lt; b2 ⇒ BAG_CARD b1 &lt; BAG_CARD b2
   
   [<a name="PSUB_BAG_IRREFL-val"><b>PSUB_BAG_IRREFL</b></a>]  Theorem
      
      ⊢ ∀b. ¬(b &lt; b)
   
   [<a name="PSUB_BAG_NOT_EQ-val"><b>PSUB_BAG_NOT_EQ</b></a>]  Theorem
      
      ⊢ ∀b1 b2. b1 &lt; b2 ⇒ b1 ≠ b2
   
   [<a name="PSUB_BAG_REST-val"><b>PSUB_BAG_REST</b></a>]  Theorem
      
      ⊢ ∀b. b ≠ {||} ⇒ BAG_REST b &lt; b
   
   [<a name="PSUB_BAG_SUB_BAG-val"><b>PSUB_BAG_SUB_BAG</b></a>]  Theorem
      
      ⊢ ∀b1 b2. b1 &lt; b2 ⇒ b1 ≤ b2
   
   [<a name="PSUB_BAG_TRANS-val"><b>PSUB_BAG_TRANS</b></a>]  Theorem
      
      ⊢ ∀b1 b2 b3. b1 &lt; b2 ∧ b2 &lt; b3 ⇒ b1 &lt; b3
   
   [<a name="SET_BAG_I-val"><b>SET_BAG_I</b></a>]  Theorem
      
      ⊢ ∀s. SET_OF_BAG (BAG_OF_SET s) = s
   
   [<a name="SET_OF_BAG_DIFF_SUBSET_down-val"><b>SET_OF_BAG_DIFF_SUBSET_down</b></a>]  Theorem
      
      ⊢ ∀b1 b2. SET_OF_BAG b1 DIFF SET_OF_BAG b2 ⊆ SET_OF_BAG (b1 − b2)
   
   [<a name="SET_OF_BAG_DIFF_SUBSET_up-val"><b>SET_OF_BAG_DIFF_SUBSET_up</b></a>]  Theorem
      
      ⊢ ∀b1 b2. SET_OF_BAG (b1 − b2) ⊆ SET_OF_BAG b1
   
   [<a name="SET_OF_BAG_EQ_EMPTY-val"><b>SET_OF_BAG_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ ∀b. (∅ = SET_OF_BAG b ⇔ b = {||}) ∧ (SET_OF_BAG b = ∅ ⇔ b = {||})
   
   [<a name="SET_OF_BAG_EQ_INSERT-val"><b>SET_OF_BAG_EQ_INSERT</b></a>]  Theorem
      
      ⊢ ∀b e s.
          e INSERT s = SET_OF_BAG b ⇔
          ∃b0 eb.
            b = eb ⊎ b0 ∧ s = SET_OF_BAG b0 ∧ (∀e'. e' ⋲ eb ⇒ e' = e) ∧
            (e ∉ s ⇒ e ⋲ eb)
   
   [<a name="SET_OF_BAG_IMAGE-val"><b>SET_OF_BAG_IMAGE</b></a>]  Theorem
      
      ⊢ SET_OF_BAG (BAG_IMAGE f b) = IMAGE f (SET_OF_BAG b)
   
   [<a name="SET_OF_BAG_INSERT-val"><b>SET_OF_BAG_INSERT</b></a>]  Theorem
      
      ⊢ ∀e b. SET_OF_BAG (BAG_INSERT e b) = e INSERT SET_OF_BAG b
   
   [<a name="SET_OF_BAG_MERGE-val"><b>SET_OF_BAG_MERGE</b></a>]  Theorem
      
      ⊢ ∀b1 b2.
          SET_OF_BAG (BAG_MERGE b1 b2) = SET_OF_BAG b1 ∪ SET_OF_BAG b2
   
   [<a name="SET_OF_BAG_SING-val"><b>SET_OF_BAG_SING</b></a>]  Theorem
      
      ⊢ ∀b e.
          SET_OF_BAG b = {e} ⇔ ∃n. 0 &lt; n ∧ b = (λx. if x = e then n else 0)
   
   [<a name="SET_OF_BAG_SING_CARD-val"><b>SET_OF_BAG_SING_CARD</b></a>]  Theorem
      
      ⊢ ∀b e. SET_OF_BAG b = {e} ⇒ BAG_CARD b = b e
   
   [<a name="SET_OF_BAG_UNION-val"><b>SET_OF_BAG_UNION</b></a>]  Theorem
      
      ⊢ ∀b1 b2. SET_OF_BAG (b1 ⊎ b2) = SET_OF_BAG b1 ∪ SET_OF_BAG b2
   
   [<a name="SET_OF_EL_BAG-val"><b>SET_OF_EL_BAG</b></a>]  Theorem
      
      ⊢ ∀e. SET_OF_BAG (EL_BAG e) = {e}
   
   [<a name="SET_OF_EMPTY-val"><b>SET_OF_EMPTY</b></a>]  Theorem
      
      ⊢ BAG_OF_SET ∅ = {||}
   
   [<a name="SET_OF_SINGLETON_BAG-val"><b>SET_OF_SINGLETON_BAG</b></a>]  Theorem
      
      ⊢ ∀e. SET_OF_BAG {|e|} = {e}
   
   [<a name="SING_BAG_THM-val"><b>SING_BAG_THM</b></a>]  Theorem
      
      ⊢ ∀e. SING_BAG {|e|}
   
   [<a name="SING_EL_BAG-val"><b>SING_EL_BAG</b></a>]  Theorem
      
      ⊢ ∀e. SING_BAG (EL_BAG e)
   
   [<a name="STRONG_FINITE_BAG_INDUCT-val"><b>STRONG_FINITE_BAG_INDUCT</b></a>]  Theorem
      
      ⊢ ∀P. P {||} ∧ (∀b. FINITE_BAG b ∧ P b ⇒ ∀e. P (BAG_INSERT e b)) ⇒
            ∀b. FINITE_BAG b ⇒ P b
   
   [<a name="SUB_BAG_ALL_DISTINCT-val"><b>SUB_BAG_ALL_DISTINCT</b></a>]  Theorem
      
      ⊢ ∀b1 b2. BAG_ALL_DISTINCT b1 ⇒ (b1 ≤ b2 ⇔ ∀x. x ⋲ b1 ⇒ x ⋲ b2)
   
   [<a name="SUB_BAG_ANTISYM-val"><b>SUB_BAG_ANTISYM</b></a>]  Theorem
      
      ⊢ ∀b1 b2. b1 ≤ b2 ∧ b2 ≤ b1 ⇒ b1 = b2
   
   [<a name="SUB_BAG_BAG_DIFF-val"><b>SUB_BAG_BAG_DIFF</b></a>]  Theorem
      
      ⊢ ∀X Y Y' Z W. X − Y ≤ Z − W ⇒ X − (Y ⊎ Y') ≤ Z − (W ⊎ Y')
   
   [<a name="SUB_BAG_BAG_IN-val"><b>SUB_BAG_BAG_IN</b></a>]  Theorem
      
      ⊢ ∀x b1 b2. BAG_INSERT x b1 ≤ b2 ⇒ x ⋲ b2
   
   [<a name="SUB_BAG_CARD-val"><b>SUB_BAG_CARD</b></a>]  Theorem
      
      ⊢ ∀b1 b2. FINITE_BAG b2 ∧ b1 ≤ b2 ⇒ BAG_CARD b1 ≤ BAG_CARD b2
   
   [<a name="SUB_BAG_DIFF-val"><b>SUB_BAG_DIFF</b></a>]  Theorem
      
      ⊢ (∀b1 b2. b1 ≤ b2 ⇒ ∀b3. b1 − b3 ≤ b2) ∧
        ∀b1 b2 b3 b4.
          b2 ≤ b1 ⇒ b4 ≤ b3 ⇒ (b1 − b2 ≤ b3 − b4 ⇔ b1 ⊎ b4 ≤ b2 ⊎ b3)
   
   [<a name="SUB_BAG_DIFF_EQ-val"><b>SUB_BAG_DIFF_EQ</b></a>]  Theorem
      
      ⊢ ∀b1 b2. b1 ≤ b2 ⇒ b2 = b1 ⊎ (b2 − b1)
   
   [<a name="SUB_BAG_DIFF_simple-val"><b>SUB_BAG_DIFF_simple</b></a>]  Theorem
      
      ⊢ b − c ≤ b
   
   [<a name="SUB_BAG_EL_BAG-val"><b>SUB_BAG_EL_BAG</b></a>]  Theorem
      
      ⊢ ∀e b. EL_BAG e ≤ b ⇔ e ⋲ b
   
   [<a name="SUB_BAG_EMPTY-val"><b>SUB_BAG_EMPTY</b></a>]  Theorem
      
      ⊢ (∀b. {||} ≤ b) ∧ ∀b. b ≤ {||} ⇔ b = {||}
   
   [<a name="SUB_BAG_EXISTS-val"><b>SUB_BAG_EXISTS</b></a>]  Theorem
      
      ⊢ ∀b1 b2. b1 ≤ b2 ⇔ ∃b. b2 = b1 ⊎ b
   
   [<a name="SUB_BAG_INSERT-val"><b>SUB_BAG_INSERT</b></a>]  Theorem
      
      ⊢ ∀e b1 b2. BAG_INSERT e b1 ≤ BAG_INSERT e b2 ⇔ b1 ≤ b2
   
   [<a name="SUB_BAG_INSERT_I-val"><b>SUB_BAG_INSERT_I</b></a>]  Theorem
      
      ⊢ ∀b c e. b ≤ c ⇒ b ≤ BAG_INSERT e c
   
   [<a name="SUB_BAG_LEQ-val"><b>SUB_BAG_LEQ</b></a>]  Theorem
      
      ⊢ b1 ≤ b2 ⇔ ∀x. b1 x ≤ b2 x
   
   [<a name="SUB_BAG_PSUB_BAG-val"><b>SUB_BAG_PSUB_BAG</b></a>]  Theorem
      
      ⊢ ∀b1 b2. (b1 ≤ b2 ⇔ b1 &lt; b2) ∨ b1 = b2
   
   [<a name="SUB_BAG_REFL-val"><b>SUB_BAG_REFL</b></a>]  Theorem
      
      ⊢ ∀b. b ≤ b
   
   [<a name="SUB_BAG_REST-val"><b>SUB_BAG_REST</b></a>]  Theorem
      
      ⊢ ∀b. BAG_REST b ≤ b
   
   [<a name="SUB_BAG_SET-val"><b>SUB_BAG_SET</b></a>]  Theorem
      
      ⊢ ∀b1 b2. b1 ≤ b2 ⇒ SET_OF_BAG b1 ⊆ SET_OF_BAG b2
   
   [<a name="SUB_BAG_SING-val"><b>SUB_BAG_SING</b></a>]  Theorem
      
      ⊢ b ≤ {|e|} ⇔ b = {||} ∨ b = {|e|}
   
   [<a name="SUB_BAG_TRANS-val"><b>SUB_BAG_TRANS</b></a>]  Theorem
      
      ⊢ ∀b1 b2 b3. b1 ≤ b2 ∧ b2 ≤ b3 ⇒ b1 ≤ b3
   
   [<a name="SUB_BAG_UNION-val"><b>SUB_BAG_UNION</b></a>]  Theorem
      
      ⊢ (∀b1 b2. b1 ≤ b2 ⇒ ∀b. b1 ≤ b2 ⊎ b) ∧
        (∀b1 b2. b1 ≤ b2 ⇒ ∀b. b1 ≤ b ⊎ b2) ∧
        (∀b1 b2 b3. b1 ≤ b2 ⊎ b3 ⇒ ∀b. b1 ≤ b2 ⊎ b ⊎ b3) ∧
        (∀b1 b2 b3. b1 ≤ b2 ⊎ b3 ⇒ ∀b. b1 ≤ b ⊎ b2 ⊎ b3) ∧
        (∀b1 b2 b3. b1 ≤ b3 ⊎ b2 ⇒ ∀b. b1 ≤ b3 ⊎ (b2 ⊎ b)) ∧
        (∀b1 b2 b3. b1 ≤ b3 ⊎ b2 ⇒ ∀b. b1 ≤ b3 ⊎ (b ⊎ b2)) ∧
        (∀b1 b2 b3 b4. b1 ≤ b3 ⇒ b2 ≤ b4 ⇒ b1 ⊎ b2 ≤ b3 ⊎ b4) ∧
        (∀b1 b2 b3 b4. b1 ≤ b4 ⇒ b2 ≤ b3 ⇒ b1 ⊎ b2 ≤ b3 ⊎ b4) ∧
        (∀b1 b2 b3 b4 b5. b1 ≤ b3 ⊎ b5 ⇒ b2 ≤ b4 ⇒ b1 ⊎ b2 ≤ b3 ⊎ b4 ⊎ b5) ∧
        (∀b1 b2 b3 b4 b5. b1 ≤ b4 ⊎ b5 ⇒ b2 ≤ b3 ⇒ b1 ⊎ b2 ≤ b3 ⊎ b4 ⊎ b5) ∧
        (∀b1 b2 b3 b4 b5. b2 ≤ b3 ⊎ b5 ⇒ b1 ≤ b4 ⇒ b1 ⊎ b2 ≤ b3 ⊎ b4 ⊎ b5) ∧
        (∀b1 b2 b3 b4 b5. b2 ≤ b4 ⊎ b5 ⇒ b1 ≤ b3 ⇒ b1 ⊎ b2 ≤ b3 ⊎ b4 ⊎ b5) ∧
        (∀b1 b2 b3 b4 b5. b1 ≤ b5 ⊎ b3 ⇒ b2 ≤ b4 ⇒ b2 ⊎ b1 ≤ b5 ⊎ (b3 ⊎ b4)) ∧
        (∀b1 b2 b3 b4 b5. b1 ≤ b5 ⊎ b4 ⇒ b2 ≤ b3 ⇒ b2 ⊎ b1 ≤ b5 ⊎ (b3 ⊎ b4)) ∧
        (∀b1 b2 b3 b4 b5. b2 ≤ b5 ⊎ b3 ⇒ b1 ≤ b4 ⇒ b2 ⊎ b1 ≤ b5 ⊎ (b3 ⊎ b4)) ∧
        (∀b1 b2 b3 b4 b5. b2 ≤ b5 ⊎ b4 ⇒ b1 ≤ b3 ⇒ b2 ⊎ b1 ≤ b5 ⊎ (b3 ⊎ b4)) ∧
        (∀b1 b2 b3 b4 b5. b1 ⊎ b2 ≤ b4 ⇒ b3 ≤ b5 ⇒ b1 ⊎ b3 ⊎ b2 ≤ b4 ⊎ b5) ∧
        (∀b1 b2 b3 b4 b5. b1 ⊎ b2 ≤ b5 ⇒ b3 ≤ b4 ⇒ b1 ⊎ b3 ⊎ b2 ≤ b4 ⊎ b5) ∧
        (∀b1 b2 b3 b4 b5. b3 ⊎ b2 ≤ b4 ⇒ b1 ≤ b5 ⇒ b1 ⊎ b3 ⊎ b2 ≤ b4 ⊎ b5) ∧
        (∀b1 b2 b3 b4 b5. b3 ⊎ b2 ≤ b5 ⇒ b1 ≤ b4 ⇒ b1 ⊎ b3 ⊎ b2 ≤ b4 ⊎ b5) ∧
        (∀b1 b2 b3 b4 b5. b2 ⊎ b1 ≤ b4 ⇒ b3 ≤ b5 ⇒ b2 ⊎ (b1 ⊎ b3) ≤ b5 ⊎ b4) ∧
        (∀b1 b2 b3 b4 b5. b2 ⊎ b1 ≤ b5 ⇒ b3 ≤ b4 ⇒ b2 ⊎ (b1 ⊎ b3) ≤ b5 ⊎ b4) ∧
        (∀b1 b2 b3 b4 b5. b2 ⊎ b3 ≤ b4 ⇒ b1 ≤ b5 ⇒ b2 ⊎ (b1 ⊎ b3) ≤ b5 ⊎ b4) ∧
        ∀b1 b2 b3 b4 b5. b2 ⊎ b3 ≤ b5 ⇒ b1 ≤ b4 ⇒ b2 ⊎ (b1 ⊎ b3) ≤ b5 ⊎ b4
   
   [<a name="SUB_BAG_UNION_DIFF-val"><b>SUB_BAG_UNION_DIFF</b></a>]  Theorem
      
      ⊢ ∀b1 b2 b3. b1 ≤ b3 ⇒ (b2 ≤ b3 − b1 ⇔ b1 ⊎ b2 ≤ b3)
   
   [<a name="SUB_BAG_UNION_MONO-val"><b>SUB_BAG_UNION_MONO</b></a>]  Theorem
      
      ⊢ (∀x y. x ≤ x ⊎ y) ∧ ∀x y. x ≤ y ⊎ x
   
   [<a name="SUB_BAG_UNION_down-val"><b>SUB_BAG_UNION_down</b></a>]  Theorem
      
      ⊢ ∀b1 b2 b3. b1 ⊎ b2 ≤ b3 ⇒ b1 ≤ b3 ∧ b2 ≤ b3
   
   [<a name="SUB_BAG_UNION_eliminate-val"><b>SUB_BAG_UNION_eliminate</b></a>]  Theorem
      
      ⊢ ∀b1 b2 b3.
          (b1 ⊎ b2 ≤ b1 ⊎ b3 ⇔ b2 ≤ b3) ∧ (b1 ⊎ b2 ≤ b3 ⊎ b1 ⇔ b2 ≤ b3) ∧
          (b2 ⊎ b1 ≤ b1 ⊎ b3 ⇔ b2 ≤ b3) ∧ (b2 ⊎ b1 ≤ b3 ⊎ b1 ⇔ b2 ≤ b3)
   
   [<a name="TC_mlt1_FINITE_BAG-val"><b>TC_mlt1_FINITE_BAG</b></a>]  Theorem
      
      ⊢ ∀b1 b2. mlt R b1 b2 ⇒ FINITE_BAG b1 ∧ FINITE_BAG b2
   
   [<a name="TC_mlt1_UNION1_I-val"><b>TC_mlt1_UNION1_I</b></a>]  Theorem
      
      ⊢ ∀b2 b1.
          FINITE_BAG b2 ∧ FINITE_BAG b1 ∧ b1 ≠ {||} ⇒ mlt R b2 (b1 ⊎ b2)
   
   [<a name="TC_mlt1_UNION2_I-val"><b>TC_mlt1_UNION2_I</b></a>]  Theorem
      
      ⊢ ∀b2 b1.
          FINITE_BAG b2 ∧ FINITE_BAG b1 ∧ b2 ≠ {||} ⇒ mlt R b1 (b1 ⊎ b2)
   
   [<a name="WF_mlt1-val"><b>WF_mlt1</b></a>]  Theorem
      
      ⊢ WF R ⇒ WF (mlt1 R)
   
   [<a name="bdominates_BAG_DIFF-val"><b>bdominates_BAG_DIFF</b></a>]  Theorem
      
      ⊢ WF R ∧ transitive R ∧ bdominates R x y ∧ FINITE_BAG i ∧ i ≤ x ∧
        i ≤ y ⇒
        bdominates R (x − i) (y − i)
   
   [<a name="dominates_DIFF-val"><b>dominates_DIFF</b></a>]  Theorem
      
      ⊢ WF R ∧ transitive R ∧ dominates R x y ∧ FINITE i ∧ i ⊆ x ∧ i ⊆ y ⇒
        dominates R (x DIFF i) (y DIFF i)
   
   [<a name="dominates_EMPTY-val"><b>dominates_EMPTY</b></a>]  Theorem
      
      ⊢ dominates R ∅ b
   
   [<a name="dominates_SUBSET-val"><b>dominates_SUBSET</b></a>]  Theorem
      
      ⊢ transitive R ∧ FINITE Y ∧ dominates R Y X ∧ X ⊆ Y ∧ X ≠ ∅ ⇒
        ∃x. x ∈ X ∧ R x x
   
   [<a name="mlt1_INSERT_CANCEL-val"><b>mlt1_INSERT_CANCEL</b></a>]  Theorem
      
      ⊢ WF R ⇒ (mlt1 R (BAG_INSERT e a) (BAG_INSERT e b) ⇔ mlt1 R a b)
   
   [<a name="mlt1_all_accessible-val"><b>mlt1_all_accessible</b></a>]  Theorem
      
      ⊢ WF R ⇒ ∀M. WFP (mlt1 R) M
   
   [<a name="mltLT_SING0-val"><b>mltLT_SING0</b></a>]  Theorem
      
      ⊢ mlt $&lt; {|0|} b ⇔ FINITE_BAG b ∧ b ≠ {|0|} ∧ b ≠ {||}
   
   [<a name="mlt_INSERT_CANCEL-val"><b>mlt_INSERT_CANCEL</b></a>]  Theorem
      
      ⊢ transitive R ∧ WF R ⇒
        (mlt R (BAG_INSERT e a) (BAG_INSERT e b) ⇔ mlt R a b)
   
   [<a name="mlt_INSERT_CANCEL_I-val"><b>mlt_INSERT_CANCEL_I</b></a>]  Theorem
      
      ⊢ ∀a b. mlt R a b ⇒ mlt R (BAG_INSERT e a) (BAG_INSERT e b)
   
   [<a name="mlt_NOT_REFL-val"><b>mlt_NOT_REFL</b></a>]  Theorem
      
      ⊢ WF R ⇒ ¬mlt R a a
   
   [<a name="mlt_UNION_CANCEL_EQN-val"><b>mlt_UNION_CANCEL_EQN</b></a>]  Theorem
      
      ⊢ WF R ⇒
        (mlt R b1 (b1 ⊎ b2) ⇔ FINITE_BAG b1 ∧ FINITE_BAG b2 ∧ b2 ≠ {||}) ∧
        (mlt R b1 (b2 ⊎ b1) ⇔ FINITE_BAG b1 ∧ FINITE_BAG b2 ∧ b2 ≠ {||})
   
   [<a name="mlt_UNION_EMPTY_EQN-val"><b>mlt_UNION_EMPTY_EQN</b></a>]  Theorem
      
      ⊢ T
   
   [<a name="mlt_UNION_LCANCEL-val"><b>mlt_UNION_LCANCEL</b></a>]  Theorem
      
      ⊢ WF R ∧ transitive R ⇒
        (mlt R (c ⊎ a) (c ⊎ b) ⇔ mlt R a b ∧ FINITE_BAG c)
   
   [<a name="mlt_UNION_LCANCEL_I-val"><b>mlt_UNION_LCANCEL_I</b></a>]  Theorem
      
      ⊢ mlt R a b ∧ FINITE_BAG c ⇒ mlt R (c ⊎ a) (c ⊎ b)
   
   [<a name="mlt_UNION_RCANCEL-val"><b>mlt_UNION_RCANCEL</b></a>]  Theorem
      
      ⊢ WF R ∧ transitive R ⇒
        (mlt R (a ⊎ c) (b ⊎ c) ⇔ mlt R a b ∧ FINITE_BAG c)
   
   [<a name="mlt_UNION_RCANCEL_I-val"><b>mlt_UNION_RCANCEL_I</b></a>]  Theorem
      
      ⊢ mlt R a b ∧ FINITE_BAG c ⇒ mlt R (a ⊎ c) (b ⊎ c)
   
   [<a name="mlt_dominates_thm1-val"><b>mlt_dominates_thm1</b></a>]  Theorem
      
      ⊢ transitive R ⇒
        ∀b1 b2.
          mlt R b1 b2 ⇔
          FINITE_BAG b1 ∧ FINITE_BAG b2 ∧
          ∃x y. x ≠ {||} ∧ x ≤ b2 ∧ b1 = b2 − x ⊎ y ∧ bdominates R y x
   
   [<a name="mlt_dominates_thm2-val"><b>mlt_dominates_thm2</b></a>]  Theorem
      
      ⊢ WF R ∧ transitive R ⇒
        ∀b1 b2.
          mlt R b1 b2 ⇔
          FINITE_BAG b1 ∧ FINITE_BAG b2 ∧
          ∃x y.
            x ≠ {||} ∧ x ≤ b2 ∧ BAG_DISJOINT x y ∧ b1 = b2 − x ⊎ y ∧
            bdominates R y x
   
   [<a name="move_BAG_UNION_over_eq-val"><b>move_BAG_UNION_over_eq</b></a>]  Theorem
      
      ⊢ ∀X Y Z. X ⊎ Y = Z ⇒ X = Z − Y
   
   [<a name="unibag_ALL_DISTINCT-val"><b>unibag_ALL_DISTINCT</b></a>]  Theorem
      
      ⊢ ∀b. BAG_ALL_DISTINCT (unibag b)
   
   [<a name="unibag_DECOMPOSE-val"><b>unibag_DECOMPOSE</b></a>]  Theorem
      
      ⊢ unibag g ≠ g ⇒ ∃A g0. g = {|A; A|} ⊎ g0
   
   [<a name="unibag_EL_MERGE_cases-val"><b>unibag_EL_MERGE_cases</b></a>]  Theorem
      
      ⊢ ∀e b.
          (e ⋲ b ⇒ BAG_MERGE {|e|} (unibag b) = unibag b) ∧
          (¬(e ⋲ b) ⇒ BAG_MERGE {|e|} (unibag b) = BAG_INSERT e (unibag b))
   
   [<a name="unibag_EQ_BAG_INSERT-val"><b>unibag_EQ_BAG_INSERT</b></a>]  Theorem
      
      ⊢ ∀e b b'. unibag b = BAG_INSERT e b' ⇒ ∃c. b' = unibag c
   
   [<a name="unibag_FINITE-val"><b>unibag_FINITE</b></a>]  Theorem
      
      ⊢ ∀b. FINITE_BAG (unibag b) ⇔ FINITE_BAG b
   
   [<a name="unibag_INSERT-val"><b>unibag_INSERT</b></a>]  Theorem
      
      ⊢ ∀a b. unibag (BAG_INSERT a b) = BAG_MERGE {|a|} (unibag b)
   
   [<a name="unibag_SUB_BAG-val"><b>unibag_SUB_BAG</b></a>]  Theorem
      
      ⊢ ∀b. unibag b ≤ b
   
   [<a name="unibag_UNION-val"><b>unibag_UNION</b></a>]  Theorem
      
      ⊢ ∀a b. unibag (a ⊎ b) = BAG_MERGE (unibag a) (unibag b)
   
   [<a name="unibag_thm-val"><b>unibag_thm</b></a>]  Theorem
      
      ⊢ (∀P. BAG_OF_SET P = (λx. if x ∈ P then 1 else 0)) ∧
        ∀b. SET_OF_BAG b = (λx. x ⋲ b)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/bag/.hol/objs/bagScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-2</a></em></p></body></html>
