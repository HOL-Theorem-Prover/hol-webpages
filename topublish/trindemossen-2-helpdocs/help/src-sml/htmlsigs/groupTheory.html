<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure groupTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure groupTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/algebra/construction/.hol/objs/groupScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature groupTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#AbelianGroup_def-val">AbelianGroup_def</a> : thm
<a name="line7"></a>    val <a href="#CosetPartition_def-val">CosetPartition_def</a> : thm
<a name="line8"></a>    val <a href="#ElGamal_decrypt_def-val">ElGamal_decrypt_def</a> : thm
<a name="line9"></a>    val <a href="#ElGamal_encrypt_def-val">ElGamal_encrypt_def</a> : thm
<a name="line10"></a>    val <a href="#Estar_def-val">Estar_def</a> : thm
<a name="line11"></a>    val <a href="#FiniteAbelianGroup_def-val">FiniteAbelianGroup_def</a> : thm
<a name="line12"></a>    val <a href="#FiniteGroup_def-val">FiniteGroup_def</a> : thm
<a name="line13"></a>    val <a href="#GFACT_def-val">GFACT_def</a> : thm
<a name="line14"></a>    val <a href="#GROUP_IMAGE_def-val">GROUP_IMAGE_def</a> : thm
<a name="line15"></a>    val <a href="#Generated_def-val">Generated_def</a> : thm
<a name="line16"></a>    val <a href="#Generated_subset_def-val">Generated_subset_def</a> : thm
<a name="line17"></a>    val <a href="#GroupAuto_def-val">GroupAuto_def</a> : thm
<a name="line18"></a>    val <a href="#GroupEndo_def-val">GroupEndo_def</a> : thm
<a name="line19"></a>    val <a href="#GroupHomo_def-val">GroupHomo_def</a> : thm
<a name="line20"></a>    val <a href="#GroupIso_def-val">GroupIso_def</a> : thm
<a name="line21"></a>    val <a href="#Group_def-val">Group_def</a> : thm
<a name="line22"></a>    val <a href="#OP_IMAGE_def-val">OP_IMAGE_def</a> : thm
<a name="line23"></a>    val <a href="#StabilizerGroup_def-val">StabilizerGroup_def</a> : thm
<a name="line24"></a>    val <a href="#Subgroup_def-val">Subgroup_def</a> : thm
<a name="line25"></a>    val <a href="#Zadd_def-val">Zadd_def</a> : thm
<a name="line26"></a>    val <a href="#Zstar_def-val">Zstar_def</a> : thm
<a name="line27"></a>    val <a href="#act_by_def-val">act_by_def</a> : thm
<a name="line28"></a>    val <a href="#action_def-val">action_def</a> : thm
<a name="line29"></a>    val <a href="#add_mod_def-val">add_mod_def</a> : thm
<a name="line30"></a>    val <a href="#all_subgroups_def-val">all_subgroups_def</a> : thm
<a name="line31"></a>    val <a href="#cogen_def-val">cogen_def</a> : thm
<a name="line32"></a>    val <a href="#conjugate_def-val">conjugate_def</a> : thm
<a name="line33"></a>    val <a href="#conjugate_subgroup_def-val">conjugate_subgroup_def</a> : thm
<a name="line34"></a>    val <a href="#coset_def-val">coset_def</a> : thm
<a name="line35"></a>    val <a href="#coset_op_def-val">coset_op_def</a> : thm
<a name="line36"></a>    val <a href="#cyclic_def-val">cyclic_def</a> : thm
<a name="line37"></a>    val <a href="#cyclic_gen_def-val">cyclic_gen_def</a> : thm
<a name="line38"></a>    val <a href="#cyclic_generators_def-val">cyclic_generators_def</a> : thm
<a name="line39"></a>    val <a href="#cyclic_index_def-val">cyclic_index_def</a> : thm
<a name="line40"></a>    val <a href="#eq_order_def-val">eq_order_def</a> : thm
<a name="line41"></a>    val <a href="#excluding_def-val">excluding_def</a> : thm
<a name="line42"></a>    val <a href="#fixed_points_def-val">fixed_points_def</a> : thm
<a name="line43"></a>    val <a href="#fn_cyclic_group_def-val">fn_cyclic_group_def</a> : thm
<a name="line44"></a>    val <a href="#group_div_def-val">group_div_def</a> : thm
<a name="line45"></a>    val <a href="#group_equiv_def-val">group_equiv_def</a> : thm
<a name="line46"></a>    val <a href="#group_fun_def-val">group_fun_def</a> : thm
<a name="line47"></a>    val <a href="#homo_image_def-val">homo_image_def</a> : thm
<a name="line48"></a>    val <a href="#inCoset_def-val">inCoset_def</a> : thm
<a name="line49"></a>    val <a href="#including_def-val">including_def</a> : thm
<a name="line50"></a>    val <a href="#kernel_def-val">kernel_def</a> : thm
<a name="line51"></a>    val <a href="#kernel_group_def-val">kernel_group_def</a> : thm
<a name="line52"></a>    val <a href="#left_coset_def-val">left_coset_def</a> : thm
<a name="line53"></a>    val <a href="#make_group_def-val">make_group_def</a> : thm
<a name="line54"></a>    val <a href="#mult_mod_def-val">mult_mod_def</a> : thm
<a name="line55"></a>    val <a href="#multi_orbits_def-val">multi_orbits_def</a> : thm
<a name="line56"></a>    val <a href="#normal_subgroup_def-val">normal_subgroup_def</a> : thm
<a name="line57"></a>    val <a href="#orbit_def-val">orbit_def</a> : thm
<a name="line58"></a>    val <a href="#orbits_def-val">orbits_def</a> : thm
<a name="line59"></a>    val <a href="#preimage_group_def-val">preimage_group_def</a> : thm
<a name="line60"></a>    val <a href="#quotient_group_def-val">quotient_group_def</a> : thm
<a name="line61"></a>    val <a href="#reach_def-val">reach_def</a> : thm
<a name="line62"></a>    val <a href="#right_coset_def-val">right_coset_def</a> : thm
<a name="line63"></a>    val <a href="#roots_of_unity_def-val">roots_of_unity_def</a> : thm
<a name="line64"></a>    val <a href="#sing_orbits_def-val">sing_orbits_def</a> : thm
<a name="line65"></a>    val <a href="#stabilizer_def-val">stabilizer_def</a> : thm
<a name="line66"></a>    val <a href="#subgroup_big_cross_def-val">subgroup_big_cross_def</a> : thm
<a name="line67"></a>    val <a href="#subgroup_big_intersect_def-val">subgroup_big_intersect_def</a> : thm
<a name="line68"></a>    val <a href="#subgroup_cross_def-val">subgroup_cross_def</a> : thm
<a name="line69"></a>    val <a href="#subgroup_def-val">subgroup_def</a> : thm
<a name="line70"></a>    val <a href="#subset_big_cross_def-val">subset_big_cross_def</a> : thm
<a name="line71"></a>    val <a href="#subset_cross_def-val">subset_cross_def</a> : thm
<a name="line72"></a>    val <a href="#subset_cross_left_right_def-val">subset_cross_left_right_def</a> : thm
<a name="line73"></a>    val <a href="#subset_group_def-val">subset_group_def</a> : thm
<a name="line74"></a>    val <a href="#symdiff_def-val">symdiff_def</a> : thm
<a name="line75"></a>    val <a href="#symdiff_set_def-val">symdiff_set_def</a> : thm
<a name="line76"></a>    val <a href="#trivial_group_def-val">trivial_group_def</a> : thm
<a name="line77"></a>  
<a name="line78"></a>  (*  Theorems  *)
<a name="line79"></a>    val <a href="#ElGamal_correctness-val">ElGamal_correctness</a> : thm
<a name="line80"></a>    val <a href="#Estar_alt-val">Estar_alt</a> : thm
<a name="line81"></a>    val <a href="#Estar_card-val">Estar_card</a> : thm
<a name="line82"></a>    val <a href="#Estar_card_alt-val">Estar_card_alt</a> : thm
<a name="line83"></a>    val <a href="#Estar_carrier-val">Estar_carrier</a> : thm
<a name="line84"></a>    val <a href="#Estar_carrier_alt-val">Estar_carrier_alt</a> : thm
<a name="line85"></a>    val <a href="#Estar_element-val">Estar_element</a> : thm
<a name="line86"></a>    val <a href="#Estar_eval-val">Estar_eval</a> : thm
<a name="line87"></a>    val <a href="#Estar_exp-val">Estar_exp</a> : thm
<a name="line88"></a>    val <a href="#Estar_finite-val">Estar_finite</a> : thm
<a name="line89"></a>    val <a href="#Estar_finite_abelian_group-val">Estar_finite_abelian_group</a> : thm
<a name="line90"></a>    val <a href="#Estar_finite_group-val">Estar_finite_group</a> : thm
<a name="line91"></a>    val <a href="#Estar_group-val">Estar_group</a> : thm
<a name="line92"></a>    val <a href="#Estar_id-val">Estar_id</a> : thm
<a name="line93"></a>    val <a href="#Estar_inv-val">Estar_inv</a> : thm
<a name="line94"></a>    val <a href="#Estar_inv_compute-val">Estar_inv_compute</a> : thm
<a name="line95"></a>    val <a href="#Estar_property-val">Estar_property</a> : thm
<a name="line96"></a>    val <a href="#Euler_Fermat_alt-val">Euler_Fermat_alt</a> : thm
<a name="line97"></a>    val <a href="#Euler_Fermat_eqn-val">Euler_Fermat_eqn</a> : thm
<a name="line98"></a>    val <a href="#Euler_Fermat_thm-val">Euler_Fermat_thm</a> : thm
<a name="line99"></a>    val <a href="#Fermat_little_eqn-val">Fermat_little_eqn</a> : thm
<a name="line100"></a>    val <a href="#Fermat_little_thm-val">Fermat_little_thm</a> : thm
<a name="line101"></a>    val <a href="#FiniteAbelianGroup_def_alt-val">FiniteAbelianGroup_def_alt</a> : thm
<a name="line102"></a>    val <a href="#GFACT_element-val">GFACT_element</a> : thm
<a name="line103"></a>    val <a href="#GFACT_identity-val">GFACT_identity</a> : thm
<a name="line104"></a>    val <a href="#GITSET_AS_ITSET-val">GITSET_AS_ITSET</a> : thm
<a name="line105"></a>    val <a href="#GPROD_SET_AS_GROUP_IMAGE-val">GPROD_SET_AS_GROUP_IMAGE</a> : thm
<a name="line106"></a>    val <a href="#GPROD_SET_IMAGE-val">GPROD_SET_IMAGE</a> : thm
<a name="line107"></a>    val <a href="#GPROD_SET_REDUCTION-val">GPROD_SET_REDUCTION</a> : thm
<a name="line108"></a>    val <a href="#GPROD_SET_REDUCTION_INSERT-val">GPROD_SET_REDUCTION_INSERT</a> : thm
<a name="line109"></a>    val <a href="#Generated_subset_exp-val">Generated_subset_exp</a> : thm
<a name="line110"></a>    val <a href="#Generated_subset_gen-val">Generated_subset_gen</a> : thm
<a name="line111"></a>    val <a href="#Generated_subset_group-val">Generated_subset_group</a> : thm
<a name="line112"></a>    val <a href="#Generated_subset_has_set-val">Generated_subset_has_set</a> : thm
<a name="line113"></a>    val <a href="#Generated_subset_property-val">Generated_subset_property</a> : thm
<a name="line114"></a>    val <a href="#Generated_subset_subgroup-val">Generated_subset_subgroup</a> : thm
<a name="line115"></a>    val <a href="#Generated_subset_subset-val">Generated_subset_subset</a> : thm
<a name="line116"></a>    val <a href="#Invertibles_inv-val">Invertibles_inv</a> : thm
<a name="line117"></a>    val <a href="#Lagrange_identity-val">Lagrange_identity</a> : thm
<a name="line118"></a>    val <a href="#Lagrange_identity_alt-val">Lagrange_identity_alt</a> : thm
<a name="line119"></a>    val <a href="#Lagrange_thm-val">Lagrange_thm</a> : thm
<a name="line120"></a>    val <a href="#OP_IMAGE_EMPTY-val">OP_IMAGE_EMPTY</a> : thm
<a name="line121"></a>    val <a href="#OP_IMAGE_SING-val">OP_IMAGE_SING</a> : thm
<a name="line122"></a>    val <a href="#OP_IMAGE_THM-val">OP_IMAGE_THM</a> : thm
<a name="line123"></a>    val <a href="#PRIME_2-val">PRIME_2</a> : thm
<a name="line124"></a>    val <a href="#PRIME_3-val">PRIME_3</a> : thm
<a name="line125"></a>    val <a href="#PRIME_5-val">PRIME_5</a> : thm
<a name="line126"></a>    val <a href="#PRIME_7-val">PRIME_7</a> : thm
<a name="line127"></a>    val <a href="#SURJ_IMAGE_PREIMAGE-val">SURJ_IMAGE_PREIMAGE</a> : thm
<a name="line128"></a>    val <a href="#Subgroup_homo_homo-val">Subgroup_homo_homo</a> : thm
<a name="line129"></a>    val <a href="#Subgroup_subgroup-val">Subgroup_subgroup</a> : thm
<a name="line130"></a>    val <a href="#Zadd_card-val">Zadd_card</a> : thm
<a name="line131"></a>    val <a href="#Zadd_carrier-val">Zadd_carrier</a> : thm
<a name="line132"></a>    val <a href="#Zadd_carrier_alt-val">Zadd_carrier_alt</a> : thm
<a name="line133"></a>    val <a href="#Zadd_element-val">Zadd_element</a> : thm
<a name="line134"></a>    val <a href="#Zadd_eval-val">Zadd_eval</a> : thm
<a name="line135"></a>    val <a href="#Zadd_exp-val">Zadd_exp</a> : thm
<a name="line136"></a>    val <a href="#Zadd_finite-val">Zadd_finite</a> : thm
<a name="line137"></a>    val <a href="#Zadd_finite_abelian_group-val">Zadd_finite_abelian_group</a> : thm
<a name="line138"></a>    val <a href="#Zadd_finite_group-val">Zadd_finite_group</a> : thm
<a name="line139"></a>    val <a href="#Zadd_group-val">Zadd_group</a> : thm
<a name="line140"></a>    val <a href="#Zadd_id-val">Zadd_id</a> : thm
<a name="line141"></a>    val <a href="#Zadd_inv-val">Zadd_inv</a> : thm
<a name="line142"></a>    val <a href="#Zadd_inv_compute-val">Zadd_inv_compute</a> : thm
<a name="line143"></a>    val <a href="#Zadd_property-val">Zadd_property</a> : thm
<a name="line144"></a>    val <a href="#Zstar_card-val">Zstar_card</a> : thm
<a name="line145"></a>    val <a href="#Zstar_carrier-val">Zstar_carrier</a> : thm
<a name="line146"></a>    val <a href="#Zstar_carrier_alt-val">Zstar_carrier_alt</a> : thm
<a name="line147"></a>    val <a href="#Zstar_element-val">Zstar_element</a> : thm
<a name="line148"></a>    val <a href="#Zstar_eval-val">Zstar_eval</a> : thm
<a name="line149"></a>    val <a href="#Zstar_exp-val">Zstar_exp</a> : thm
<a name="line150"></a>    val <a href="#Zstar_finite-val">Zstar_finite</a> : thm
<a name="line151"></a>    val <a href="#Zstar_finite_abelian_group-val">Zstar_finite_abelian_group</a> : thm
<a name="line152"></a>    val <a href="#Zstar_finite_group-val">Zstar_finite_group</a> : thm
<a name="line153"></a>    val <a href="#Zstar_group-val">Zstar_group</a> : thm
<a name="line154"></a>    val <a href="#Zstar_id-val">Zstar_id</a> : thm
<a name="line155"></a>    val <a href="#Zstar_inv-val">Zstar_inv</a> : thm
<a name="line156"></a>    val <a href="#Zstar_inv_compute-val">Zstar_inv_compute</a> : thm
<a name="line157"></a>    val <a href="#Zstar_inverse-val">Zstar_inverse</a> : thm
<a name="line158"></a>    val <a href="#Zstar_inverse_compute-val">Zstar_inverse_compute</a> : thm
<a name="line159"></a>    val <a href="#Zstar_property-val">Zstar_property</a> : thm
<a name="line160"></a>    val <a href="#abelian_group_is_abelian_monoid-val">abelian_group_is_abelian_monoid</a> : thm
<a name="line161"></a>    val <a href="#abelian_group_order_common-val">abelian_group_order_common</a> : thm
<a name="line162"></a>    val <a href="#abelian_group_order_common_coprime-val">abelian_group_order_common_coprime</a> : thm
<a name="line163"></a>    val <a href="#abelian_monoid_invertible_excluding-val">abelian_monoid_invertible_excluding</a> : thm
<a name="line164"></a>    val <a href="#abelian_subgroup_abelian-val">abelian_subgroup_abelian</a> : thm
<a name="line165"></a>    val <a href="#abelian_subgroup_cross_finite-val">abelian_subgroup_cross_finite</a> : thm
<a name="line166"></a>    val <a href="#abelian_subgroup_cross_subgroup-val">abelian_subgroup_cross_subgroup</a> : thm
<a name="line167"></a>    val <a href="#action_closure-val">action_closure</a> : thm
<a name="line168"></a>    val <a href="#action_compose-val">action_compose</a> : thm
<a name="line169"></a>    val <a href="#action_id-val">action_id</a> : thm
<a name="line170"></a>    val <a href="#action_match_condition-val">action_match_condition</a> : thm
<a name="line171"></a>    val <a href="#action_match_condition_alt-val">action_match_condition_alt</a> : thm
<a name="line172"></a>    val <a href="#action_reachable_coset-val">action_reachable_coset</a> : thm
<a name="line173"></a>    val <a href="#action_reachable_coset_alt-val">action_reachable_coset_alt</a> : thm
<a name="line174"></a>    val <a href="#action_reverse-val">action_reverse</a> : thm
<a name="line175"></a>    val <a href="#action_to_orbit_surj-val">action_to_orbit_surj</a> : thm
<a name="line176"></a>    val <a href="#action_trans-val">action_trans</a> : thm
<a name="line177"></a>    val <a href="#add_mod_abelian_group-val">add_mod_abelian_group</a> : thm
<a name="line178"></a>    val <a href="#add_mod_card-val">add_mod_card</a> : thm
<a name="line179"></a>    val <a href="#add_mod_carrier-val">add_mod_carrier</a> : thm
<a name="line180"></a>    val <a href="#add_mod_carrier_alt-val">add_mod_carrier_alt</a> : thm
<a name="line181"></a>    val <a href="#add_mod_cylic-val">add_mod_cylic</a> : thm
<a name="line182"></a>    val <a href="#add_mod_element-val">add_mod_element</a> : thm
<a name="line183"></a>    val <a href="#add_mod_eval-val">add_mod_eval</a> : thm
<a name="line184"></a>    val <a href="#add_mod_exp-val">add_mod_exp</a> : thm
<a name="line185"></a>    val <a href="#add_mod_finite-val">add_mod_finite</a> : thm
<a name="line186"></a>    val <a href="#add_mod_finite_abelian_group-val">add_mod_finite_abelian_group</a> : thm
<a name="line187"></a>    val <a href="#add_mod_finite_group-val">add_mod_finite_group</a> : thm
<a name="line188"></a>    val <a href="#add_mod_group-val">add_mod_group</a> : thm
<a name="line189"></a>    val <a href="#add_mod_id-val">add_mod_id</a> : thm
<a name="line190"></a>    val <a href="#add_mod_inv-val">add_mod_inv</a> : thm
<a name="line191"></a>    val <a href="#add_mod_inv_compute-val">add_mod_inv_compute</a> : thm
<a name="line192"></a>    val <a href="#add_mod_order_1-val">add_mod_order_1</a> : thm
<a name="line193"></a>    val <a href="#add_mod_property-val">add_mod_property</a> : thm
<a name="line194"></a>    val <a href="#all_subgroups_element-val">all_subgroups_element</a> : thm
<a name="line195"></a>    val <a href="#all_subgroups_finite-val">all_subgroups_finite</a> : thm
<a name="line196"></a>    val <a href="#all_subgroups_has_gen_id-val">all_subgroups_has_gen_id</a> : thm
<a name="line197"></a>    val <a href="#all_subgroups_subset-val">all_subgroups_subset</a> : thm
<a name="line198"></a>    val <a href="#bij_corres-val">bij_corres</a> : thm
<a name="line199"></a>    val <a href="#carrier_card_by_coset_partition-val">carrier_card_by_coset_partition</a> : thm
<a name="line200"></a>    val <a href="#carrier_card_by_subgroup_coset_partition-val">carrier_card_by_subgroup_coset_partition</a> : thm
<a name="line201"></a>    val <a href="#cogen_coset_element-val">cogen_coset_element</a> : thm
<a name="line202"></a>    val <a href="#cogen_element-val">cogen_element</a> : thm
<a name="line203"></a>    val <a href="#cogen_of_subgroup-val">cogen_of_subgroup</a> : thm
<a name="line204"></a>    val <a href="#conjugate_subgroup_group-val">conjugate_subgroup_group</a> : thm
<a name="line205"></a>    val <a href="#conjugate_subgroup_subgroup-val">conjugate_subgroup_subgroup</a> : thm
<a name="line206"></a>    val <a href="#corres_thm-val">corres_thm</a> : thm
<a name="line207"></a>    val <a href="#coset_alt-val">coset_alt</a> : thm
<a name="line208"></a>    val <a href="#coset_cogen_property-val">coset_cogen_property</a> : thm
<a name="line209"></a>    val <a href="#coset_element-val">coset_element</a> : thm
<a name="line210"></a>    val <a href="#coset_empty-val">coset_empty</a> : thm
<a name="line211"></a>    val <a href="#coset_homo_group_iso_quotient_group-val">coset_homo_group_iso_quotient_group</a> : thm
<a name="line212"></a>    val <a href="#coset_id_eq_subgroup-val">coset_id_eq_subgroup</a> : thm
<a name="line213"></a>    val <a href="#coset_partition_card-val">coset_partition_card</a> : thm
<a name="line214"></a>    val <a href="#coset_partition_element-val">coset_partition_element</a> : thm
<a name="line215"></a>    val <a href="#coset_partition_element_card-val">coset_partition_element_card</a> : thm
<a name="line216"></a>    val <a href="#coset_partition_eq_coset_image-val">coset_partition_eq_coset_image</a> : thm
<a name="line217"></a>    val <a href="#coset_property-val">coset_property</a> : thm
<a name="line218"></a>    val <a href="#count_formula-val">count_formula</a> : thm
<a name="line219"></a>    val <a href="#cyclic_element-val">cyclic_element</a> : thm
<a name="line220"></a>    val <a href="#cyclic_element_by_gen-val">cyclic_element_by_gen</a> : thm
<a name="line221"></a>    val <a href="#cyclic_element_in_generated-val">cyclic_element_in_generated</a> : thm
<a name="line222"></a>    val <a href="#cyclic_eq_order_partition-val">cyclic_eq_order_partition</a> : thm
<a name="line223"></a>    val <a href="#cyclic_eq_order_partition_alt-val">cyclic_eq_order_partition_alt</a> : thm
<a name="line224"></a>    val <a href="#cyclic_eq_order_partition_by_card-val">cyclic_eq_order_partition_by_card</a> : thm
<a name="line225"></a>    val <a href="#cyclic_finite_alt-val">cyclic_finite_alt</a> : thm
<a name="line226"></a>    val <a href="#cyclic_finite_has_order_divisor-val">cyclic_finite_has_order_divisor</a> : thm
<a name="line227"></a>    val <a href="#cyclic_gen_element-val">cyclic_gen_element</a> : thm
<a name="line228"></a>    val <a href="#cyclic_gen_order-val">cyclic_gen_order</a> : thm
<a name="line229"></a>    val <a href="#cyclic_gen_power_order-val">cyclic_gen_power_order</a> : thm
<a name="line230"></a>    val <a href="#cyclic_generated_by_gen-val">cyclic_generated_by_gen</a> : thm
<a name="line231"></a>    val <a href="#cyclic_generated_group-val">cyclic_generated_group</a> : thm
<a name="line232"></a>    val <a href="#cyclic_generators_card-val">cyclic_generators_card</a> : thm
<a name="line233"></a>    val <a href="#cyclic_generators_coprimes_bij-val">cyclic_generators_coprimes_bij</a> : thm
<a name="line234"></a>    val <a href="#cyclic_generators_element-val">cyclic_generators_element</a> : thm
<a name="line235"></a>    val <a href="#cyclic_generators_finite-val">cyclic_generators_finite</a> : thm
<a name="line236"></a>    val <a href="#cyclic_generators_gen_cofactor_eq_orders-val">cyclic_generators_gen_cofactor_eq_orders</a> : thm
<a name="line237"></a>    val <a href="#cyclic_generators_nonempty-val">cyclic_generators_nonempty</a> : thm
<a name="line238"></a>    val <a href="#cyclic_generators_subset-val">cyclic_generators_subset</a> : thm
<a name="line239"></a>    val <a href="#cyclic_group-val">cyclic_group</a> : thm
<a name="line240"></a>    val <a href="#cyclic_group_abelian-val">cyclic_group_abelian</a> : thm
<a name="line241"></a>    val <a href="#cyclic_group_comm-val">cyclic_group_comm</a> : thm
<a name="line242"></a>    val <a href="#cyclic_image_ord_is_divisors-val">cyclic_image_ord_is_divisors</a> : thm
<a name="line243"></a>    val <a href="#cyclic_index_exists-val">cyclic_index_exists</a> : thm
<a name="line244"></a>    val <a href="#cyclic_iso_gen-val">cyclic_iso_gen</a> : thm
<a name="line245"></a>    val <a href="#cyclic_orders_card-val">cyclic_orders_card</a> : thm
<a name="line246"></a>    val <a href="#cyclic_orders_nonempty-val">cyclic_orders_nonempty</a> : thm
<a name="line247"></a>    val <a href="#cyclic_orders_partition-val">cyclic_orders_partition</a> : thm
<a name="line248"></a>    val <a href="#cyclic_subgroup_condition-val">cyclic_subgroup_condition</a> : thm
<a name="line249"></a>    val <a href="#cyclic_subgroup_cyclic-val">cyclic_subgroup_cyclic</a> : thm
<a name="line250"></a>    val <a href="#cyclic_uroots_cyclic-val">cyclic_uroots_cyclic</a> : thm
<a name="line251"></a>    val <a href="#cyclic_uroots_has_primitive-val">cyclic_uroots_has_primitive</a> : thm
<a name="line252"></a>    val <a href="#element_coset_property-val">element_coset_property</a> : thm
<a name="line253"></a>    val <a href="#eq_order_equiv-val">eq_order_equiv</a> : thm
<a name="line254"></a>    val <a href="#eq_order_is_feq_order-val">eq_order_is_feq_order</a> : thm
<a name="line255"></a>    val <a href="#fermat_little-val">fermat_little</a> : thm
<a name="line256"></a>    val <a href="#fermat_little_alt-val">fermat_little_alt</a> : thm
<a name="line257"></a>    val <a href="#fermat_little_thm-val">fermat_little_thm</a> : thm
<a name="line258"></a>    val <a href="#fermat_roots-val">fermat_roots</a> : thm
<a name="line259"></a>    val <a href="#finite_abelian_Fermat-val">finite_abelian_Fermat</a> : thm
<a name="line260"></a>    val <a href="#finite_abelian_group_is_finite_abelian_monoid-val">finite_abelian_group_is_finite_abelian_monoid</a> : thm
<a name="line261"></a>    val <a href="#finite_cyclic_group_add_mod_bij-val">finite_cyclic_group_add_mod_bij</a> : thm
<a name="line262"></a>    val <a href="#finite_cyclic_group_add_mod_homo-val">finite_cyclic_group_add_mod_homo</a> : thm
<a name="line263"></a>    val <a href="#finite_cyclic_group_add_mod_iso-val">finite_cyclic_group_add_mod_iso</a> : thm
<a name="line264"></a>    val <a href="#finite_cyclic_group_bij-val">finite_cyclic_group_bij</a> : thm
<a name="line265"></a>    val <a href="#finite_cyclic_group_existence-val">finite_cyclic_group_existence</a> : thm
<a name="line266"></a>    val <a href="#finite_cyclic_group_homo-val">finite_cyclic_group_homo</a> : thm
<a name="line267"></a>    val <a href="#finite_cyclic_group_iso-val">finite_cyclic_group_iso</a> : thm
<a name="line268"></a>    val <a href="#finite_cyclic_group_uniqueness-val">finite_cyclic_group_uniqueness</a> : thm
<a name="line269"></a>    val <a href="#finite_cyclic_index_add-val">finite_cyclic_index_add</a> : thm
<a name="line270"></a>    val <a href="#finite_cyclic_index_property-val">finite_cyclic_index_property</a> : thm
<a name="line271"></a>    val <a href="#finite_cyclic_index_unique-val">finite_cyclic_index_unique</a> : thm
<a name="line272"></a>    val <a href="#finite_group_Fermat-val">finite_group_Fermat</a> : thm
<a name="line273"></a>    val <a href="#finite_group_card_pos-val">finite_group_card_pos</a> : thm
<a name="line274"></a>    val <a href="#finite_group_exp_not_distinct-val">finite_group_exp_not_distinct</a> : thm
<a name="line275"></a>    val <a href="#finite_group_exp_period_exists-val">finite_group_exp_period_exists</a> : thm
<a name="line276"></a>    val <a href="#finite_group_is_finite_monoid-val">finite_group_is_finite_monoid</a> : thm
<a name="line277"></a>    val <a href="#finite_group_is_group-val">finite_group_is_group</a> : thm
<a name="line278"></a>    val <a href="#finite_group_is_monoid-val">finite_group_is_monoid</a> : thm
<a name="line279"></a>    val <a href="#finite_group_order-val">finite_group_order</a> : thm
<a name="line280"></a>    val <a href="#finite_group_primitive_property-val">finite_group_primitive_property</a> : thm
<a name="line281"></a>    val <a href="#finite_homo_image-val">finite_homo_image</a> : thm
<a name="line282"></a>    val <a href="#finite_monoid_invertibles_is_finite_group-val">finite_monoid_invertibles_is_finite_group</a> : thm
<a name="line283"></a>    val <a href="#finite_subgroup_carrier_finite-val">finite_subgroup_carrier_finite</a> : thm
<a name="line284"></a>    val <a href="#finite_subgroup_finite_group-val">finite_subgroup_finite_group</a> : thm
<a name="line285"></a>    val <a href="#fixed_points_element-val">fixed_points_element</a> : thm
<a name="line286"></a>    val <a href="#fixed_points_element_element-val">fixed_points_element_element</a> : thm
<a name="line287"></a>    val <a href="#fixed_points_finite-val">fixed_points_finite</a> : thm
<a name="line288"></a>    val <a href="#fixed_points_orbit_iff_sing-val">fixed_points_orbit_iff_sing</a> : thm
<a name="line289"></a>    val <a href="#fixed_points_orbit_sing-val">fixed_points_orbit_sing</a> : thm
<a name="line290"></a>    val <a href="#fixed_points_subset-val">fixed_points_subset</a> : thm
<a name="line291"></a>    val <a href="#fn_cyclic_group_alt-val">fn_cyclic_group_alt</a> : thm
<a name="line292"></a>    val <a href="#fn_cyclic_group_carrier-val">fn_cyclic_group_carrier</a> : thm
<a name="line293"></a>    val <a href="#fn_cyclic_group_finite_abelian_group-val">fn_cyclic_group_finite_abelian_group</a> : thm
<a name="line294"></a>    val <a href="#fn_cyclic_group_finite_group-val">fn_cyclic_group_finite_group</a> : thm
<a name="line295"></a>    val <a href="#fn_cyclic_group_group-val">fn_cyclic_group_group</a> : thm
<a name="line296"></a>    val <a href="#fn_cyclic_group_id-val">fn_cyclic_group_id</a> : thm
<a name="line297"></a>    val <a href="#generated_Fermat-val">generated_Fermat</a> : thm
<a name="line298"></a>    val <a href="#generated_carrier-val">generated_carrier</a> : thm
<a name="line299"></a>    val <a href="#generated_carrier_as_image-val">generated_carrier_as_image</a> : thm
<a name="line300"></a>    val <a href="#generated_carrier_has_id-val">generated_carrier_has_id</a> : thm
<a name="line301"></a>    val <a href="#generated_element-val">generated_element</a> : thm
<a name="line302"></a>    val <a href="#generated_exp-val">generated_exp</a> : thm
<a name="line303"></a>    val <a href="#generated_finite_group-val">generated_finite_group</a> : thm
<a name="line304"></a>    val <a href="#generated_gen_element-val">generated_gen_element</a> : thm
<a name="line305"></a>    val <a href="#generated_group-val">generated_group</a> : thm
<a name="line306"></a>    val <a href="#generated_group_card-val">generated_group_card</a> : thm
<a name="line307"></a>    val <a href="#generated_group_finite-val">generated_group_finite</a> : thm
<a name="line308"></a>    val <a href="#generated_id_carrier-val">generated_id_carrier</a> : thm
<a name="line309"></a>    val <a href="#generated_id_subgroup-val">generated_id_subgroup</a> : thm
<a name="line310"></a>    val <a href="#generated_image_subset_all_subgroups-val">generated_image_subset_all_subgroups</a> : thm
<a name="line311"></a>    val <a href="#generated_image_subset_power_set-val">generated_image_subset_power_set</a> : thm
<a name="line312"></a>    val <a href="#generated_property-val">generated_property</a> : thm
<a name="line313"></a>    val <a href="#generated_subgroup-val">generated_subgroup</a> : thm
<a name="line314"></a>    val <a href="#generated_subset-val">generated_subset</a> : thm
<a name="line315"></a>    val <a href="#group_all_invertible-val">group_all_invertible</a> : thm
<a name="line316"></a>    val <a href="#group_alt-val">group_alt</a> : thm
<a name="line317"></a>    val <a href="#group_assoc-val">group_assoc</a> : thm
<a name="line318"></a>    val <a href="#group_auto_I-val">group_auto_I</a> : thm
<a name="line319"></a>    val <a href="#group_auto_bij-val">group_auto_bij</a> : thm
<a name="line320"></a>    val <a href="#group_auto_compose-val">group_auto_compose</a> : thm
<a name="line321"></a>    val <a href="#group_auto_element-val">group_auto_element</a> : thm
<a name="line322"></a>    val <a href="#group_auto_exp-val">group_auto_exp</a> : thm
<a name="line323"></a>    val <a href="#group_auto_id-val">group_auto_id</a> : thm
<a name="line324"></a>    val <a href="#group_auto_is_monoid_auto-val">group_auto_is_monoid_auto</a> : thm
<a name="line325"></a>    val <a href="#group_auto_linv_auto-val">group_auto_linv_auto</a> : thm
<a name="line326"></a>    val <a href="#group_auto_order-val">group_auto_order</a> : thm
<a name="line327"></a>    val <a href="#group_carrier_nonempty-val">group_carrier_nonempty</a> : thm
<a name="line328"></a>    val <a href="#group_comm_exp-val">group_comm_exp</a> : thm
<a name="line329"></a>    val <a href="#group_comm_exp_exp-val">group_comm_exp_exp</a> : thm
<a name="line330"></a>    val <a href="#group_comm_op_exp-val">group_comm_op_exp</a> : thm
<a name="line331"></a>    val <a href="#group_coset_eq_itself-val">group_coset_eq_itself</a> : thm
<a name="line332"></a>    val <a href="#group_coset_is_permutation-val">group_coset_is_permutation</a> : thm
<a name="line333"></a>    val <a href="#group_def_alt-val">group_def_alt</a> : thm
<a name="line334"></a>    val <a href="#group_def_by_inverse-val">group_def_by_inverse</a> : thm
<a name="line335"></a>    val <a href="#group_div_cancel-val">group_div_cancel</a> : thm
<a name="line336"></a>    val <a href="#group_div_element-val">group_div_element</a> : thm
<a name="line337"></a>    val <a href="#group_div_lsame-val">group_div_lsame</a> : thm
<a name="line338"></a>    val <a href="#group_div_pair-val">group_div_pair</a> : thm
<a name="line339"></a>    val <a href="#group_div_rsame-val">group_div_rsame</a> : thm
<a name="line340"></a>    val <a href="#group_excluding_exp-val">group_excluding_exp</a> : thm
<a name="line341"></a>    val <a href="#group_excluding_op-val">group_excluding_op</a> : thm
<a name="line342"></a>    val <a href="#group_excluding_property-val">group_excluding_property</a> : thm
<a name="line343"></a>    val <a href="#group_exp_0-val">group_exp_0</a> : thm
<a name="line344"></a>    val <a href="#group_exp_1-val">group_exp_1</a> : thm
<a name="line345"></a>    val <a href="#group_exp_SUC-val">group_exp_SUC</a> : thm
<a name="line346"></a>    val <a href="#group_exp_add-val">group_exp_add</a> : thm
<a name="line347"></a>    val <a href="#group_exp_comm-val">group_exp_comm</a> : thm
<a name="line348"></a>    val <a href="#group_exp_element-val">group_exp_element</a> : thm
<a name="line349"></a>    val <a href="#group_exp_eq-val">group_exp_eq</a> : thm
<a name="line350"></a>    val <a href="#group_exp_eq_condition-val">group_exp_eq_condition</a> : thm
<a name="line351"></a>    val <a href="#group_exp_equal-val">group_exp_equal</a> : thm
<a name="line352"></a>    val <a href="#group_exp_inv-val">group_exp_inv</a> : thm
<a name="line353"></a>    val <a href="#group_exp_mod-val">group_exp_mod</a> : thm
<a name="line354"></a>    val <a href="#group_exp_mod_order-val">group_exp_mod_order</a> : thm
<a name="line355"></a>    val <a href="#group_exp_mult-val">group_exp_mult</a> : thm
<a name="line356"></a>    val <a href="#group_exp_mult_comm-val">group_exp_mult_comm</a> : thm
<a name="line357"></a>    val <a href="#group_exp_suc-val">group_exp_suc</a> : thm
<a name="line358"></a>    val <a href="#group_first_isomorphism_thm-val">group_first_isomorphism_thm</a> : thm
<a name="line359"></a>    val <a href="#group_homo_I_refl-val">group_homo_I_refl</a> : thm
<a name="line360"></a>    val <a href="#group_homo_compose-val">group_homo_compose</a> : thm
<a name="line361"></a>    val <a href="#group_homo_cong-val">group_homo_cong</a> : thm
<a name="line362"></a>    val <a href="#group_homo_element-val">group_homo_element</a> : thm
<a name="line363"></a>    val <a href="#group_homo_exp-val">group_homo_exp</a> : thm
<a name="line364"></a>    val <a href="#group_homo_homo_image_group-val">group_homo_homo_image_group</a> : thm
<a name="line365"></a>    val <a href="#group_homo_id-val">group_homo_id</a> : thm
<a name="line366"></a>    val <a href="#group_homo_image_surj_property-val">group_homo_image_surj_property</a> : thm
<a name="line367"></a>    val <a href="#group_homo_inv-val">group_homo_inv</a> : thm
<a name="line368"></a>    val <a href="#group_homo_is_monoid_homo-val">group_homo_is_monoid_homo</a> : thm
<a name="line369"></a>    val <a href="#group_homo_monoid_homo-val">group_homo_monoid_homo</a> : thm
<a name="line370"></a>    val <a href="#group_homo_sym-val">group_homo_sym</a> : thm
<a name="line371"></a>    val <a href="#group_homo_sym_any-val">group_homo_sym_any</a> : thm
<a name="line372"></a>    val <a href="#group_homo_trans-val">group_homo_trans</a> : thm
<a name="line373"></a>    val <a href="#group_id-val">group_id</a> : thm
<a name="line374"></a>    val <a href="#group_id_element-val">group_id_element</a> : thm
<a name="line375"></a>    val <a href="#group_id_exp-val">group_id_exp</a> : thm
<a name="line376"></a>    val <a href="#group_id_fix-val">group_id_fix</a> : thm
<a name="line377"></a>    val <a href="#group_id_id-val">group_id_id</a> : thm
<a name="line378"></a>    val <a href="#group_id_unique-val">group_id_unique</a> : thm
<a name="line379"></a>    val <a href="#group_image_as_op_image-val">group_image_as_op_image</a> : thm
<a name="line380"></a>    val <a href="#group_image_empty-val">group_image_empty</a> : thm
<a name="line381"></a>    val <a href="#group_image_sing-val">group_image_sing</a> : thm
<a name="line382"></a>    val <a href="#group_including_excluding_abelian-val">group_including_excluding_abelian</a> : thm
<a name="line383"></a>    val <a href="#group_including_excluding_eqn-val">group_including_excluding_eqn</a> : thm
<a name="line384"></a>    val <a href="#group_including_excluding_group-val">group_including_excluding_group</a> : thm
<a name="line385"></a>    val <a href="#group_including_excluding_property-val">group_including_excluding_property</a> : thm
<a name="line386"></a>    val <a href="#group_including_property-val">group_including_property</a> : thm
<a name="line387"></a>    val <a href="#group_inj_image_abelian_group-val">group_inj_image_abelian_group</a> : thm
<a name="line388"></a>    val <a href="#group_inj_image_excluding_abelian_group-val">group_inj_image_excluding_abelian_group</a> : thm
<a name="line389"></a>    val <a href="#group_inj_image_excluding_group-val">group_inj_image_excluding_group</a> : thm
<a name="line390"></a>    val <a href="#group_inj_image_group-val">group_inj_image_group</a> : thm
<a name="line391"></a>    val <a href="#group_inj_image_group_homo-val">group_inj_image_group_homo</a> : thm
<a name="line392"></a>    val <a href="#group_inv_element-val">group_inv_element</a> : thm
<a name="line393"></a>    val <a href="#group_inv_eq-val">group_inv_eq</a> : thm
<a name="line394"></a>    val <a href="#group_inv_eq_id-val">group_inv_eq_id</a> : thm
<a name="line395"></a>    val <a href="#group_inv_eq_swap-val">group_inv_eq_swap</a> : thm
<a name="line396"></a>    val <a href="#group_inv_exp-val">group_inv_exp</a> : thm
<a name="line397"></a>    val <a href="#group_inv_id-val">group_inv_id</a> : thm
<a name="line398"></a>    val <a href="#group_inv_inv-val">group_inv_inv</a> : thm
<a name="line399"></a>    val <a href="#group_inv_op-val">group_inv_op</a> : thm
<a name="line400"></a>    val <a href="#group_inv_order-val">group_inv_order</a> : thm
<a name="line401"></a>    val <a href="#group_inv_thm-val">group_inv_thm</a> : thm
<a name="line402"></a>    val <a href="#group_is_monoid-val">group_is_monoid</a> : thm
<a name="line403"></a>    val <a href="#group_iso_I_refl-val">group_iso_I_refl</a> : thm
<a name="line404"></a>    val <a href="#group_iso_bij-val">group_iso_bij</a> : thm
<a name="line405"></a>    val <a href="#group_iso_card_eq-val">group_iso_card_eq</a> : thm
<a name="line406"></a>    val <a href="#group_iso_compose-val">group_iso_compose</a> : thm
<a name="line407"></a>    val <a href="#group_iso_element-val">group_iso_element</a> : thm
<a name="line408"></a>    val <a href="#group_iso_exp-val">group_iso_exp</a> : thm
<a name="line409"></a>    val <a href="#group_iso_group-val">group_iso_group</a> : thm
<a name="line410"></a>    val <a href="#group_iso_id-val">group_iso_id</a> : thm
<a name="line411"></a>    val <a href="#group_iso_is_monoid_iso-val">group_iso_is_monoid_iso</a> : thm
<a name="line412"></a>    val <a href="#group_iso_linv_iso-val">group_iso_linv_iso</a> : thm
<a name="line413"></a>    val <a href="#group_iso_monoid_iso-val">group_iso_monoid_iso</a> : thm
<a name="line414"></a>    val <a href="#group_iso_order-val">group_iso_order</a> : thm
<a name="line415"></a>    val <a href="#group_iso_property-val">group_iso_property</a> : thm
<a name="line416"></a>    val <a href="#group_iso_sym-val">group_iso_sym</a> : thm
<a name="line417"></a>    val <a href="#group_iso_trans-val">group_iso_trans</a> : thm
<a name="line418"></a>    val <a href="#group_lcancel-val">group_lcancel</a> : thm
<a name="line419"></a>    val <a href="#group_lid-val">group_lid</a> : thm
<a name="line420"></a>    val <a href="#group_lid_unique-val">group_lid_unique</a> : thm
<a name="line421"></a>    val <a href="#group_linv-val">group_linv</a> : thm
<a name="line422"></a>    val <a href="#group_linv_assoc-val">group_linv_assoc</a> : thm
<a name="line423"></a>    val <a href="#group_linv_unique-val">group_linv_unique</a> : thm
<a name="line424"></a>    val <a href="#group_lsolve-val">group_lsolve</a> : thm
<a name="line425"></a>    val <a href="#group_normal_equiv-val">group_normal_equiv</a> : thm
<a name="line426"></a>    val <a href="#group_normal_equiv_property-val">group_normal_equiv_property</a> : thm
<a name="line427"></a>    val <a href="#group_normal_equiv_reflexive-val">group_normal_equiv_reflexive</a> : thm
<a name="line428"></a>    val <a href="#group_normal_equiv_symmetric-val">group_normal_equiv_symmetric</a> : thm
<a name="line429"></a>    val <a href="#group_normal_equiv_transitive-val">group_normal_equiv_transitive</a> : thm
<a name="line430"></a>    val <a href="#group_op_element-val">group_op_element</a> : thm
<a name="line431"></a>    val <a href="#group_op_linv_eq_id-val">group_op_linv_eq_id</a> : thm
<a name="line432"></a>    val <a href="#group_op_linv_eqn-val">group_op_linv_eqn</a> : thm
<a name="line433"></a>    val <a href="#group_op_rinv_eq_id-val">group_op_rinv_eq_id</a> : thm
<a name="line434"></a>    val <a href="#group_op_rinv_eqn-val">group_op_rinv_eqn</a> : thm
<a name="line435"></a>    val <a href="#group_order_cofactor-val">group_order_cofactor</a> : thm
<a name="line436"></a>    val <a href="#group_order_common-val">group_order_common</a> : thm
<a name="line437"></a>    val <a href="#group_order_common_coprime-val">group_order_common_coprime</a> : thm
<a name="line438"></a>    val <a href="#group_order_condition-val">group_order_condition</a> : thm
<a name="line439"></a>    val <a href="#group_order_divides-val">group_order_divides</a> : thm
<a name="line440"></a>    val <a href="#group_order_divides_exp-val">group_order_divides_exp</a> : thm
<a name="line441"></a>    val <a href="#group_order_divides_maximal-val">group_order_divides_maximal</a> : thm
<a name="line442"></a>    val <a href="#group_order_divisor-val">group_order_divisor</a> : thm
<a name="line443"></a>    val <a href="#group_order_eq_1-val">group_order_eq_1</a> : thm
<a name="line444"></a>    val <a href="#group_order_exp_cofactor-val">group_order_exp_cofactor</a> : thm
<a name="line445"></a>    val <a href="#group_order_id-val">group_order_id</a> : thm
<a name="line446"></a>    val <a href="#group_order_inv-val">group_order_inv</a> : thm
<a name="line447"></a>    val <a href="#group_order_nonzero-val">group_order_nonzero</a> : thm
<a name="line448"></a>    val <a href="#group_order_pos-val">group_order_pos</a> : thm
<a name="line449"></a>    val <a href="#group_order_power-val">group_order_power</a> : thm
<a name="line450"></a>    val <a href="#group_order_power_coprime-val">group_order_power_coprime</a> : thm
<a name="line451"></a>    val <a href="#group_order_power_eq_0-val">group_order_power_eq_0</a> : thm
<a name="line452"></a>    val <a href="#group_order_power_eq_order-val">group_order_power_eq_order</a> : thm
<a name="line453"></a>    val <a href="#group_order_power_eqn-val">group_order_power_eqn</a> : thm
<a name="line454"></a>    val <a href="#group_order_property-val">group_order_property</a> : thm
<a name="line455"></a>    val <a href="#group_order_thm-val">group_order_thm</a> : thm
<a name="line456"></a>    val <a href="#group_order_to_generated_bij-val">group_order_to_generated_bij</a> : thm
<a name="line457"></a>    val <a href="#group_order_unique-val">group_order_unique</a> : thm
<a name="line458"></a>    val <a href="#group_orders_eq_1-val">group_orders_eq_1</a> : thm
<a name="line459"></a>    val <a href="#group_pair_reduce-val">group_pair_reduce</a> : thm
<a name="line460"></a>    val <a href="#group_rcancel-val">group_rcancel</a> : thm
<a name="line461"></a>    val <a href="#group_rid-val">group_rid</a> : thm
<a name="line462"></a>    val <a href="#group_rid_unique-val">group_rid_unique</a> : thm
<a name="line463"></a>    val <a href="#group_rinv-val">group_rinv</a> : thm
<a name="line464"></a>    val <a href="#group_rinv_assoc-val">group_rinv_assoc</a> : thm
<a name="line465"></a>    val <a href="#group_rinv_unique-val">group_rinv_unique</a> : thm
<a name="line466"></a>    val <a href="#group_rsolve-val">group_rsolve</a> : thm
<a name="line467"></a>    val <a href="#group_uroots_group-val">group_uroots_group</a> : thm
<a name="line468"></a>    val <a href="#group_uroots_has_id-val">group_uroots_has_id</a> : thm
<a name="line469"></a>    val <a href="#group_uroots_subgroup-val">group_uroots_subgroup</a> : thm
<a name="line470"></a>    val <a href="#homo_count_formula-val">homo_count_formula</a> : thm
<a name="line471"></a>    val <a href="#homo_group_abelian_group-val">homo_group_abelian_group</a> : thm
<a name="line472"></a>    val <a href="#homo_group_assoc-val">homo_group_assoc</a> : thm
<a name="line473"></a>    val <a href="#homo_group_by_inj-val">homo_group_by_inj</a> : thm
<a name="line474"></a>    val <a href="#homo_group_closure-val">homo_group_closure</a> : thm
<a name="line475"></a>    val <a href="#homo_group_comm-val">homo_group_comm</a> : thm
<a name="line476"></a>    val <a href="#homo_group_group-val">homo_group_group</a> : thm
<a name="line477"></a>    val <a href="#homo_group_id-val">homo_group_id</a> : thm
<a name="line478"></a>    val <a href="#homo_group_inv-val">homo_group_inv</a> : thm
<a name="line479"></a>    val <a href="#homo_image_group-val">homo_image_group</a> : thm
<a name="line480"></a>    val <a href="#homo_image_homo_quotient_kernel-val">homo_image_homo_quotient_kernel</a> : thm
<a name="line481"></a>    val <a href="#homo_image_iso_quotient_kernel-val">homo_image_iso_quotient_kernel</a> : thm
<a name="line482"></a>    val <a href="#homo_image_monoid-val">homo_image_monoid</a> : thm
<a name="line483"></a>    val <a href="#homo_image_subgroup-val">homo_image_subgroup</a> : thm
<a name="line484"></a>    val <a href="#homo_image_to_quotient_kernel_bij-val">homo_image_to_quotient_kernel_bij</a> : thm
<a name="line485"></a>    val <a href="#homo_restrict_same_kernel-val">homo_restrict_same_kernel</a> : thm
<a name="line486"></a>    val <a href="#image_iso_preimage_quotient-val">image_iso_preimage_quotient</a> : thm
<a name="line487"></a>    val <a href="#image_preimage_group-val">image_preimage_group</a> : thm
<a name="line488"></a>    val <a href="#image_preimage_quotient_same_card-val">image_preimage_quotient_same_card</a> : thm
<a name="line489"></a>    val <a href="#image_subgroup_subgroup-val">image_subgroup_subgroup</a> : thm
<a name="line490"></a>    val <a href="#inCoset_equiv_on_carrier-val">inCoset_equiv_on_carrier</a> : thm
<a name="line491"></a>    val <a href="#inCoset_refl-val">inCoset_refl</a> : thm
<a name="line492"></a>    val <a href="#inCoset_sym-val">inCoset_sym</a> : thm
<a name="line493"></a>    val <a href="#inCoset_trans-val">inCoset_trans</a> : thm
<a name="line494"></a>    val <a href="#in_coset-val">in_coset</a> : thm
<a name="line495"></a>    val <a href="#independent_generated_eq-val">independent_generated_eq</a> : thm
<a name="line496"></a>    val <a href="#independent_generator_2_card-val">independent_generator_2_card</a> : thm
<a name="line497"></a>    val <a href="#independent_sym-val">independent_sym</a> : thm
<a name="line498"></a>    val <a href="#iso_group_same_card-val">iso_group_same_card</a> : thm
<a name="line499"></a>    val <a href="#kernel_element-val">kernel_element</a> : thm
<a name="line500"></a>    val <a href="#kernel_group_group-val">kernel_group_group</a> : thm
<a name="line501"></a>    val <a href="#kernel_group_normal-val">kernel_group_normal</a> : thm
<a name="line502"></a>    val <a href="#kernel_group_subgroup-val">kernel_group_subgroup</a> : thm
<a name="line503"></a>    val <a href="#kernel_property-val">kernel_property</a> : thm
<a name="line504"></a>    val <a href="#kernel_quotient_group-val">kernel_quotient_group</a> : thm
<a name="line505"></a>    val <a href="#left_coset_alt-val">left_coset_alt</a> : thm
<a name="line506"></a>    val <a href="#make_group_property-val">make_group_property</a> : thm
<a name="line507"></a>    val <a href="#monoid_homo_homo_image_monoid-val">monoid_homo_homo_image_monoid</a> : thm
<a name="line508"></a>    val <a href="#monoid_inv_id-val">monoid_inv_id</a> : thm
<a name="line509"></a>    val <a href="#monoid_inv_order-val">monoid_inv_order</a> : thm
<a name="line510"></a>    val <a href="#monoid_inv_order_property-val">monoid_inv_order_property</a> : thm
<a name="line511"></a>    val <a href="#monoid_invertibles_is_group-val">monoid_invertibles_is_group</a> : thm
<a name="line512"></a>    val <a href="#mult_mod_abelian_group-val">mult_mod_abelian_group</a> : thm
<a name="line513"></a>    val <a href="#mult_mod_card-val">mult_mod_card</a> : thm
<a name="line514"></a>    val <a href="#mult_mod_carrier-val">mult_mod_carrier</a> : thm
<a name="line515"></a>    val <a href="#mult_mod_carrier_alt-val">mult_mod_carrier_alt</a> : thm
<a name="line516"></a>    val <a href="#mult_mod_element-val">mult_mod_element</a> : thm
<a name="line517"></a>    val <a href="#mult_mod_element_alt-val">mult_mod_element_alt</a> : thm
<a name="line518"></a>    val <a href="#mult_mod_eval-val">mult_mod_eval</a> : thm
<a name="line519"></a>    val <a href="#mult_mod_exp-val">mult_mod_exp</a> : thm
<a name="line520"></a>    val <a href="#mult_mod_finite-val">mult_mod_finite</a> : thm
<a name="line521"></a>    val <a href="#mult_mod_finite_abelian_group-val">mult_mod_finite_abelian_group</a> : thm
<a name="line522"></a>    val <a href="#mult_mod_finite_group-val">mult_mod_finite_group</a> : thm
<a name="line523"></a>    val <a href="#mult_mod_group-val">mult_mod_group</a> : thm
<a name="line524"></a>    val <a href="#mult_mod_id-val">mult_mod_id</a> : thm
<a name="line525"></a>    val <a href="#mult_mod_inv-val">mult_mod_inv</a> : thm
<a name="line526"></a>    val <a href="#mult_mod_inv_compute-val">mult_mod_inv_compute</a> : thm
<a name="line527"></a>    val <a href="#mult_mod_inverse-val">mult_mod_inverse</a> : thm
<a name="line528"></a>    val <a href="#mult_mod_inverse_compute-val">mult_mod_inverse_compute</a> : thm
<a name="line529"></a>    val <a href="#mult_mod_property-val">mult_mod_property</a> : thm
<a name="line530"></a>    val <a href="#multi_orbits_element-val">multi_orbits_element</a> : thm
<a name="line531"></a>    val <a href="#multi_orbits_element_finite-val">multi_orbits_element_finite</a> : thm
<a name="line532"></a>    val <a href="#multi_orbits_element_subset-val">multi_orbits_element_subset</a> : thm
<a name="line533"></a>    val <a href="#multi_orbits_finite-val">multi_orbits_finite</a> : thm
<a name="line534"></a>    val <a href="#multi_orbits_subset-val">multi_orbits_subset</a> : thm
<a name="line535"></a>    val <a href="#non_fixed_points_card-val">non_fixed_points_card</a> : thm
<a name="line536"></a>    val <a href="#non_fixed_points_orbit_not_sing-val">non_fixed_points_orbit_not_sing</a> : thm
<a name="line537"></a>    val <a href="#normal_cogen_property-val">normal_cogen_property</a> : thm
<a name="line538"></a>    val <a href="#normal_coset_op_property-val">normal_coset_op_property</a> : thm
<a name="line539"></a>    val <a href="#normal_coset_property-val">normal_coset_property</a> : thm
<a name="line540"></a>    val <a href="#normal_coset_property1-val">normal_coset_property1</a> : thm
<a name="line541"></a>    val <a href="#normal_coset_property2-val">normal_coset_property2</a> : thm
<a name="line542"></a>    val <a href="#normal_iff_preimage_normal-val">normal_iff_preimage_normal</a> : thm
<a name="line543"></a>    val <a href="#normal_preimage_normal-val">normal_preimage_normal</a> : thm
<a name="line544"></a>    val <a href="#normal_subgroup_alt-val">normal_subgroup_alt</a> : thm
<a name="line545"></a>    val <a href="#normal_subgroup_antisym-val">normal_subgroup_antisym</a> : thm
<a name="line546"></a>    val <a href="#normal_subgroup_coset_eq-val">normal_subgroup_coset_eq</a> : thm
<a name="line547"></a>    val <a href="#normal_subgroup_coset_homo-val">normal_subgroup_coset_homo</a> : thm
<a name="line548"></a>    val <a href="#normal_subgroup_groups-val">normal_subgroup_groups</a> : thm
<a name="line549"></a>    val <a href="#normal_subgroup_property-val">normal_subgroup_property</a> : thm
<a name="line550"></a>    val <a href="#normal_subgroup_refl-val">normal_subgroup_refl</a> : thm
<a name="line551"></a>    val <a href="#normal_subgroup_subgroup-val">normal_subgroup_subgroup</a> : thm
<a name="line552"></a>    val <a href="#normal_surj_normal-val">normal_surj_normal</a> : thm
<a name="line553"></a>    val <a href="#orbit_alt-val">orbit_alt</a> : thm
<a name="line554"></a>    val <a href="#orbit_card_divides_target_card-val">orbit_card_divides_target_card</a> : thm
<a name="line555"></a>    val <a href="#orbit_element-val">orbit_element</a> : thm
<a name="line556"></a>    val <a href="#orbit_element_in_target-val">orbit_element_in_target</a> : thm
<a name="line557"></a>    val <a href="#orbit_eq_equiv_class-val">orbit_eq_equiv_class</a> : thm
<a name="line558"></a>    val <a href="#orbit_eq_orbit-val">orbit_eq_orbit</a> : thm
<a name="line559"></a>    val <a href="#orbit_finite-val">orbit_finite</a> : thm
<a name="line560"></a>    val <a href="#orbit_finite_by_target-val">orbit_finite_by_target</a> : thm
<a name="line561"></a>    val <a href="#orbit_finite_inj_card_eq-val">orbit_finite_inj_card_eq</a> : thm
<a name="line562"></a>    val <a href="#orbit_has_action_element-val">orbit_has_action_element</a> : thm
<a name="line563"></a>    val <a href="#orbit_has_self-val">orbit_has_self</a> : thm
<a name="line564"></a>    val <a href="#orbit_is_orbits_element-val">orbit_is_orbits_element</a> : thm
<a name="line565"></a>    val <a href="#orbit_sing_fixed_points-val">orbit_sing_fixed_points</a> : thm
<a name="line566"></a>    val <a href="#orbit_stabilizer_cosets_bij-val">orbit_stabilizer_cosets_bij</a> : thm
<a name="line567"></a>    val <a href="#orbit_stabilizer_cosets_bij_alt-val">orbit_stabilizer_cosets_bij_alt</a> : thm
<a name="line568"></a>    val <a href="#orbit_stabilizer_map_good-val">orbit_stabilizer_map_good</a> : thm
<a name="line569"></a>    val <a href="#orbit_stabilizer_map_inj-val">orbit_stabilizer_map_inj</a> : thm
<a name="line570"></a>    val <a href="#orbit_stabilizer_thm-val">orbit_stabilizer_thm</a> : thm
<a name="line571"></a>    val <a href="#orbit_subset_target-val">orbit_subset_target</a> : thm
<a name="line572"></a>    val <a href="#orbits_alt-val">orbits_alt</a> : thm
<a name="line573"></a>    val <a href="#orbits_element-val">orbits_element</a> : thm
<a name="line574"></a>    val <a href="#orbits_element_element-val">orbits_element_element</a> : thm
<a name="line575"></a>    val <a href="#orbits_element_finite-val">orbits_element_finite</a> : thm
<a name="line576"></a>    val <a href="#orbits_element_is_orbit-val">orbits_element_is_orbit</a> : thm
<a name="line577"></a>    val <a href="#orbits_element_nonempty-val">orbits_element_nonempty</a> : thm
<a name="line578"></a>    val <a href="#orbits_element_subset-val">orbits_element_subset</a> : thm
<a name="line579"></a>    val <a href="#orbits_eq_partition-val">orbits_eq_partition</a> : thm
<a name="line580"></a>    val <a href="#orbits_equal_size_partition_equal_size-val">orbits_equal_size_partition_equal_size</a> : thm
<a name="line581"></a>    val <a href="#orbits_equal_size_property-val">orbits_equal_size_property</a> : thm
<a name="line582"></a>    val <a href="#orbits_finite-val">orbits_finite</a> : thm
<a name="line583"></a>    val <a href="#orbits_size_factor_partition_factor-val">orbits_size_factor_partition_factor</a> : thm
<a name="line584"></a>    val <a href="#orbits_size_factor_property-val">orbits_size_factor_property</a> : thm
<a name="line585"></a>    val <a href="#orders_is_feq_class_order-val">orders_is_feq_class_order</a> : thm
<a name="line586"></a>    val <a href="#preimage_cardinality-val">preimage_cardinality</a> : thm
<a name="line587"></a>    val <a href="#preimage_group_group-val">preimage_group_group</a> : thm
<a name="line588"></a>    val <a href="#preimage_group_property-val">preimage_group_property</a> : thm
<a name="line589"></a>    val <a href="#preimage_image_subset-val">preimage_image_subset</a> : thm
<a name="line590"></a>    val <a href="#preimage_subgroup_kernel-val">preimage_subgroup_kernel</a> : thm
<a name="line591"></a>    val <a href="#preimage_subgroup_subgroup-val">preimage_subgroup_subgroup</a> : thm
<a name="line592"></a>    val <a href="#prod_image_as_op_image-val">prod_image_as_op_image</a> : thm
<a name="line593"></a>    val <a href="#quotient_group_assoc-val">quotient_group_assoc</a> : thm
<a name="line594"></a>    val <a href="#quotient_group_closure-val">quotient_group_closure</a> : thm
<a name="line595"></a>    val <a href="#quotient_group_group-val">quotient_group_group</a> : thm
<a name="line596"></a>    val <a href="#quotient_group_id-val">quotient_group_id</a> : thm
<a name="line597"></a>    val <a href="#quotient_group_inv-val">quotient_group_inv</a> : thm
<a name="line598"></a>    val <a href="#reach_equiv-val">reach_equiv</a> : thm
<a name="line599"></a>    val <a href="#reach_refl-val">reach_refl</a> : thm
<a name="line600"></a>    val <a href="#reach_sym-val">reach_sym</a> : thm
<a name="line601"></a>    val <a href="#reach_trans-val">reach_trans</a> : thm
<a name="line602"></a>    val <a href="#right_coset_alt-val">right_coset_alt</a> : thm
<a name="line603"></a>    val <a href="#roots_of_unity_0-val">roots_of_unity_0</a> : thm
<a name="line604"></a>    val <a href="#roots_of_unity_element-val">roots_of_unity_element</a> : thm
<a name="line605"></a>    val <a href="#roots_of_unity_subset-val">roots_of_unity_subset</a> : thm
<a name="line606"></a>    val <a href="#sing_orbits_card_eqn-val">sing_orbits_card_eqn</a> : thm
<a name="line607"></a>    val <a href="#sing_orbits_element-val">sing_orbits_element</a> : thm
<a name="line608"></a>    val <a href="#sing_orbits_element_card-val">sing_orbits_element_card</a> : thm
<a name="line609"></a>    val <a href="#sing_orbits_element_choice-val">sing_orbits_element_choice</a> : thm
<a name="line610"></a>    val <a href="#sing_orbits_element_finite-val">sing_orbits_element_finite</a> : thm
<a name="line611"></a>    val <a href="#sing_orbits_element_subset-val">sing_orbits_element_subset</a> : thm
<a name="line612"></a>    val <a href="#sing_orbits_finite-val">sing_orbits_finite</a> : thm
<a name="line613"></a>    val <a href="#sing_orbits_subset-val">sing_orbits_subset</a> : thm
<a name="line614"></a>    val <a href="#sing_orbits_to_fixed_points_bij-val">sing_orbits_to_fixed_points_bij</a> : thm
<a name="line615"></a>    val <a href="#sing_orbits_to_fixed_points_inj-val">sing_orbits_to_fixed_points_inj</a> : thm
<a name="line616"></a>    val <a href="#sing_orbits_to_fixed_points_surj-val">sing_orbits_to_fixed_points_surj</a> : thm
<a name="line617"></a>    val <a href="#stabilizer_as_image-val">stabilizer_as_image</a> : thm
<a name="line618"></a>    val <a href="#stabilizer_conjugate-val">stabilizer_conjugate</a> : thm
<a name="line619"></a>    val <a href="#stabilizer_element-val">stabilizer_element</a> : thm
<a name="line620"></a>    val <a href="#stabilizer_group_card_divides-val">stabilizer_group_card_divides</a> : thm
<a name="line621"></a>    val <a href="#stabilizer_group_carrier-val">stabilizer_group_carrier</a> : thm
<a name="line622"></a>    val <a href="#stabilizer_group_finite_group-val">stabilizer_group_finite_group</a> : thm
<a name="line623"></a>    val <a href="#stabilizer_group_group-val">stabilizer_group_group</a> : thm
<a name="line624"></a>    val <a href="#stabilizer_group_id-val">stabilizer_group_id</a> : thm
<a name="line625"></a>    val <a href="#stabilizer_group_property-val">stabilizer_group_property</a> : thm
<a name="line626"></a>    val <a href="#stabilizer_group_subgroup-val">stabilizer_group_subgroup</a> : thm
<a name="line627"></a>    val <a href="#stabilizer_has_id-val">stabilizer_has_id</a> : thm
<a name="line628"></a>    val <a href="#stabilizer_nonempty-val">stabilizer_nonempty</a> : thm
<a name="line629"></a>    val <a href="#stabilizer_subset-val">stabilizer_subset</a> : thm
<a name="line630"></a>    val <a href="#subgroup_I_antisym-val">subgroup_I_antisym</a> : thm
<a name="line631"></a>    val <a href="#subgroup_alt-val">subgroup_alt</a> : thm
<a name="line632"></a>    val <a href="#subgroup_antisym-val">subgroup_antisym</a> : thm
<a name="line633"></a>    val <a href="#subgroup_big_cross_empty-val">subgroup_big_cross_empty</a> : thm
<a name="line634"></a>    val <a href="#subgroup_big_cross_insert-val">subgroup_big_cross_insert</a> : thm
<a name="line635"></a>    val <a href="#subgroup_big_cross_thm-val">subgroup_big_cross_thm</a> : thm
<a name="line636"></a>    val <a href="#subgroup_big_intersect_element-val">subgroup_big_intersect_element</a> : thm
<a name="line637"></a>    val <a href="#subgroup_big_intersect_group-val">subgroup_big_intersect_group</a> : thm
<a name="line638"></a>    val <a href="#subgroup_big_intersect_has_id-val">subgroup_big_intersect_has_id</a> : thm
<a name="line639"></a>    val <a href="#subgroup_big_intersect_has_inv-val">subgroup_big_intersect_has_inv</a> : thm
<a name="line640"></a>    val <a href="#subgroup_big_intersect_op_element-val">subgroup_big_intersect_op_element</a> : thm
<a name="line641"></a>    val <a href="#subgroup_big_intersect_property-val">subgroup_big_intersect_property</a> : thm
<a name="line642"></a>    val <a href="#subgroup_big_intersect_subgroup-val">subgroup_big_intersect_subgroup</a> : thm
<a name="line643"></a>    val <a href="#subgroup_big_intersect_subset-val">subgroup_big_intersect_subset</a> : thm
<a name="line644"></a>    val <a href="#subgroup_carrier_antisym-val">subgroup_carrier_antisym</a> : thm
<a name="line645"></a>    val <a href="#subgroup_carrier_nonempty-val">subgroup_carrier_nonempty</a> : thm
<a name="line646"></a>    val <a href="#subgroup_carrier_subset-val">subgroup_carrier_subset</a> : thm
<a name="line647"></a>    val <a href="#subgroup_conjugate_subgroup_bij-val">subgroup_conjugate_subgroup_bij</a> : thm
<a name="line648"></a>    val <a href="#subgroup_coset_card-val">subgroup_coset_card</a> : thm
<a name="line649"></a>    val <a href="#subgroup_coset_card_partition_element-val">subgroup_coset_card_partition_element</a> : thm
<a name="line650"></a>    val <a href="#subgroup_coset_eq-val">subgroup_coset_eq</a> : thm
<a name="line651"></a>    val <a href="#subgroup_coset_in_partition-val">subgroup_coset_in_partition</a> : thm
<a name="line652"></a>    val <a href="#subgroup_coset_nonempty-val">subgroup_coset_nonempty</a> : thm
<a name="line653"></a>    val <a href="#subgroup_coset_partition_element-val">subgroup_coset_partition_element</a> : thm
<a name="line654"></a>    val <a href="#subgroup_coset_subset-val">subgroup_coset_subset</a> : thm
<a name="line655"></a>    val <a href="#subgroup_coset_sym-val">subgroup_coset_sym</a> : thm
<a name="line656"></a>    val <a href="#subgroup_coset_trans-val">subgroup_coset_trans</a> : thm
<a name="line657"></a>    val <a href="#subgroup_cross_assoc-val">subgroup_cross_assoc</a> : thm
<a name="line658"></a>    val <a href="#subgroup_cross_card-val">subgroup_cross_card</a> : thm
<a name="line659"></a>    val <a href="#subgroup_cross_card_eqn-val">subgroup_cross_card_eqn</a> : thm
<a name="line660"></a>    val <a href="#subgroup_cross_closure_comm_assoc_fun-val">subgroup_cross_closure_comm_assoc_fun</a> : thm
<a name="line661"></a>    val <a href="#subgroup_cross_comm-val">subgroup_cross_comm</a> : thm
<a name="line662"></a>    val <a href="#subgroup_cross_finite-val">subgroup_cross_finite</a> : thm
<a name="line663"></a>    val <a href="#subgroup_cross_group-val">subgroup_cross_group</a> : thm
<a name="line664"></a>    val <a href="#subgroup_cross_property-val">subgroup_cross_property</a> : thm
<a name="line665"></a>    val <a href="#subgroup_cross_self-val">subgroup_cross_self</a> : thm
<a name="line666"></a>    val <a href="#subgroup_cross_subgroup-val">subgroup_cross_subgroup</a> : thm
<a name="line667"></a>    val <a href="#subgroup_element-val">subgroup_element</a> : thm
<a name="line668"></a>    val <a href="#subgroup_eq-val">subgroup_eq</a> : thm
<a name="line669"></a>    val <a href="#subgroup_eq_carrier-val">subgroup_eq_carrier</a> : thm
<a name="line670"></a>    val <a href="#subgroup_eqn-val">subgroup_eqn</a> : thm
<a name="line671"></a>    val <a href="#subgroup_exp-val">subgroup_exp</a> : thm
<a name="line672"></a>    val <a href="#subgroup_groups-val">subgroup_groups</a> : thm
<a name="line673"></a>    val <a href="#subgroup_has_groups-val">subgroup_has_groups</a> : thm
<a name="line674"></a>    val <a href="#subgroup_homo_homo-val">subgroup_homo_homo</a> : thm
<a name="line675"></a>    val <a href="#subgroup_homomorphism-val">subgroup_homomorphism</a> : thm
<a name="line676"></a>    val <a href="#subgroup_id-val">subgroup_id</a> : thm
<a name="line677"></a>    val <a href="#subgroup_incoset_equiv-val">subgroup_incoset_equiv</a> : thm
<a name="line678"></a>    val <a href="#subgroup_intersect_group-val">subgroup_intersect_group</a> : thm
<a name="line679"></a>    val <a href="#subgroup_intersect_has_inv-val">subgroup_intersect_has_inv</a> : thm
<a name="line680"></a>    val <a href="#subgroup_intersect_inv-val">subgroup_intersect_inv</a> : thm
<a name="line681"></a>    val <a href="#subgroup_intersect_property-val">subgroup_intersect_property</a> : thm
<a name="line682"></a>    val <a href="#subgroup_intersect_subgroup-val">subgroup_intersect_subgroup</a> : thm
<a name="line683"></a>    val <a href="#subgroup_inv-val">subgroup_inv</a> : thm
<a name="line684"></a>    val <a href="#subgroup_inv_closure-val">subgroup_inv_closure</a> : thm
<a name="line685"></a>    val <a href="#subgroup_is_group-val">subgroup_is_group</a> : thm
<a name="line686"></a>    val <a href="#subgroup_is_submonoid-val">subgroup_is_submonoid</a> : thm
<a name="line687"></a>    val <a href="#subgroup_is_submonoid0-val">subgroup_is_submonoid0</a> : thm
<a name="line688"></a>    val <a href="#subgroup_op-val">subgroup_op</a> : thm
<a name="line689"></a>    val <a href="#subgroup_order-val">subgroup_order</a> : thm
<a name="line690"></a>    val <a href="#subgroup_order_eqn-val">subgroup_order_eqn</a> : thm
<a name="line691"></a>    val <a href="#subgroup_property-val">subgroup_property</a> : thm
<a name="line692"></a>    val <a href="#subgroup_property_all-val">subgroup_property_all</a> : thm
<a name="line693"></a>    val <a href="#subgroup_refl-val">subgroup_refl</a> : thm
<a name="line694"></a>    val <a href="#subgroup_reflexive-val">subgroup_reflexive</a> : thm
<a name="line695"></a>    val <a href="#subgroup_subset-val">subgroup_subset</a> : thm
<a name="line696"></a>    val <a href="#subgroup_test_by_cross-val">subgroup_test_by_cross</a> : thm
<a name="line697"></a>    val <a href="#subgroup_thm-val">subgroup_thm</a> : thm
<a name="line698"></a>    val <a href="#subgroup_to_coset_bij-val">subgroup_to_coset_bij</a> : thm
<a name="line699"></a>    val <a href="#subgroup_trans-val">subgroup_trans</a> : thm
<a name="line700"></a>    val <a href="#subgroup_transitive-val">subgroup_transitive</a> : thm
<a name="line701"></a>    val <a href="#subset_big_cross_empty-val">subset_big_cross_empty</a> : thm
<a name="line702"></a>    val <a href="#subset_big_cross_insert-val">subset_big_cross_insert</a> : thm
<a name="line703"></a>    val <a href="#subset_big_cross_thm-val">subset_big_cross_thm</a> : thm
<a name="line704"></a>    val <a href="#subset_cross_alt-val">subset_cross_alt</a> : thm
<a name="line705"></a>    val <a href="#subset_cross_assoc-val">subset_cross_assoc</a> : thm
<a name="line706"></a>    val <a href="#subset_cross_closure_comm_assoc_fun-val">subset_cross_closure_comm_assoc_fun</a> : thm
<a name="line707"></a>    val <a href="#subset_cross_comm-val">subset_cross_comm</a> : thm
<a name="line708"></a>    val <a href="#subset_cross_element-val">subset_cross_element</a> : thm
<a name="line709"></a>    val <a href="#subset_cross_element_iff-val">subset_cross_element_iff</a> : thm
<a name="line710"></a>    val <a href="#subset_cross_element_preimage_card-val">subset_cross_element_preimage_card</a> : thm
<a name="line711"></a>    val <a href="#subset_cross_finite-val">subset_cross_finite</a> : thm
<a name="line712"></a>    val <a href="#subset_cross_inv-val">subset_cross_inv</a> : thm
<a name="line713"></a>    val <a href="#subset_cross_partition_property-val">subset_cross_partition_property</a> : thm
<a name="line714"></a>    val <a href="#subset_cross_preimage_inj-val">subset_cross_preimage_inj</a> : thm
<a name="line715"></a>    val <a href="#subset_cross_self-val">subset_cross_self</a> : thm
<a name="line716"></a>    val <a href="#subset_cross_subset-val">subset_cross_subset</a> : thm
<a name="line717"></a>    val <a href="#subset_cross_to_preimage_cross_bij-val">subset_cross_to_preimage_cross_bij</a> : thm
<a name="line718"></a>    val <a href="#subset_group_exp-val">subset_group_exp</a> : thm
<a name="line719"></a>    val <a href="#subset_group_order-val">subset_group_order</a> : thm
<a name="line720"></a>    val <a href="#subset_group_property-val">subset_group_property</a> : thm
<a name="line721"></a>    val <a href="#subset_group_subgroup-val">subset_group_subgroup</a> : thm
<a name="line722"></a>    val <a href="#subset_group_submonoid-val">subset_group_submonoid</a> : thm
<a name="line723"></a>    val <a href="#subset_preimage_image-val">subset_preimage_image</a> : thm
<a name="line724"></a>    val <a href="#sum_image_as_op_image-val">sum_image_as_op_image</a> : thm
<a name="line725"></a>    val <a href="#symdiff_set_abelian_group-val">symdiff_set_abelian_group</a> : thm
<a name="line726"></a>    val <a href="#symdiff_set_group-val">symdiff_set_group</a> : thm
<a name="line727"></a>    val <a href="#target_card_and_fixed_points_congruence-val">target_card_and_fixed_points_congruence</a> : thm
<a name="line728"></a>    val <a href="#target_card_by_fixed_points-val">target_card_by_fixed_points</a> : thm
<a name="line729"></a>    val <a href="#target_card_by_orbit_types-val">target_card_by_orbit_types</a> : thm
<a name="line730"></a>    val <a href="#target_card_by_partition-val">target_card_by_partition</a> : thm
<a name="line731"></a>    val <a href="#target_orbits_disjoint-val">target_orbits_disjoint</a> : thm
<a name="line732"></a>    val <a href="#target_orbits_union-val">target_orbits_union</a> : thm
<a name="line733"></a>    val <a href="#trivial_group-val">trivial_group</a> : thm
<a name="line734"></a>    val <a href="#trivial_group_carrier-val">trivial_group_carrier</a> : thm
<a name="line735"></a>    val <a href="#trivial_group_id-val">trivial_group_id</a> : thm
<a name="line736"></a>(*
   [monoid] Parent theory of "group"
   
   [<a name="AbelianGroup_def-val"><b>AbelianGroup_def</b></a>]  Definition
      
      ⊢ ∀g. AbelianGroup g ⇔ Group g ∧ ∀x y. x ∈ G ∧ y ∈ G ⇒ x * y = y * x
   
   [<a name="CosetPartition_def-val"><b>CosetPartition_def</b></a>]  Definition
      
      ⊢ ∀g h. CosetPartition g h = partition (inCoset g h) G
   
   [<a name="ElGamal_decrypt_def-val"><b>ElGamal_decrypt_def</b></a>]  Definition
      
      ⊢ ∀g x a b. ElGamal_decrypt g x (a,b) = |/ (a ** x) * b
   
   [<a name="ElGamal_encrypt_def-val"><b>ElGamal_encrypt_def</b></a>]  Definition
      
      ⊢ ∀g y h m k. ElGamal_encrypt g y h m k = (y ** k,h ** k * m)
   
   [<a name="Estar_def-val"><b>Estar_def</b></a>]  Definition
      
      ⊢ ∀n. Estar n =
            &lt;|carrier := Euler n; id := 1; op := (λi j. (i * j) MOD n)|&gt;
   
   [<a name="FiniteAbelianGroup_def-val"><b>FiniteAbelianGroup_def</b></a>]  Definition
      
      ⊢ ∀g. FiniteAbelianGroup g ⇔ AbelianGroup g ∧ FINITE G
   
   [<a name="FiniteGroup_def-val"><b>FiniteGroup_def</b></a>]  Definition
      
      ⊢ ∀g. FiniteGroup g ⇔ Group g ∧ FINITE G
   
   [<a name="GFACT_def-val"><b>GFACT_def</b></a>]  Definition
      
      ⊢ ∀g. GFACT g = GPROD_SET g G
   
   [<a name="GROUP_IMAGE_def-val"><b>GROUP_IMAGE_def</b></a>]  Definition
      
      ⊢ ∀g f s. GPI f s = ITSET (λe acc. f e * acc) s #e
   
   [<a name="Generated_def-val"><b>Generated_def</b></a>]  Definition
      
      ⊢ ∀g a.
          gen a = &lt;|carrier := {x | ∃k. x = a ** k}; op := $*; id := #e|&gt;
   
   [<a name="Generated_subset_def-val"><b>Generated_subset_def</b></a>]  Definition
      
      ⊢ ∀g s.
          gen_set s =
          &lt;|carrier := BIGINTER (IMAGE (λh. H) {h | h ≤ g ∧ s ⊆ H});
            op := $*; id := #e|&gt;
   
   [<a name="GroupAuto_def-val"><b>GroupAuto_def</b></a>]  Definition
      
      ⊢ ∀f g. GroupAuto f g ⇔ GroupIso f g g
   
   [<a name="GroupEndo_def-val"><b>GroupEndo_def</b></a>]  Definition
      
      ⊢ ∀f g. GroupEndo f g ⇔ GroupHomo f g g
   
   [<a name="GroupHomo_def-val"><b>GroupHomo_def</b></a>]  Definition
      
      ⊢ ∀f g h.
          GroupHomo f g h ⇔
          (∀x. x ∈ G ⇒ f x ∈ h.carrier) ∧
          ∀x y. x ∈ G ∧ y ∈ G ⇒ f (x * y) = h.op (f x) (f y)
   
   [<a name="GroupIso_def-val"><b>GroupIso_def</b></a>]  Definition
      
      ⊢ ∀f g h. GroupIso f g h ⇔ GroupHomo f g h ∧ BIJ f G h.carrier
   
   [<a name="Group_def-val"><b>Group_def</b></a>]  Definition
      
      ⊢ ∀g. Group g ⇔ Monoid g ∧ G* = G
   
   [<a name="OP_IMAGE_def-val"><b>OP_IMAGE_def</b></a>]  Definition
      
      ⊢ ∀op id f s. OP_IMAGE op id f s = ITSET (λe acc. op (f e) acc) s id
   
   [<a name="StabilizerGroup_def-val"><b>StabilizerGroup_def</b></a>]  Definition
      
      ⊢ ∀f g x.
          StabilizerGroup f g x =
          &lt;|carrier := stabilizer f g x; op := $*; id := #e|&gt;
   
   [<a name="Subgroup_def-val"><b>Subgroup_def</b></a>]  Definition
      
      ⊢ ∀h g. h ≤ g ⇔ Group h ∧ Group g ∧ H ⊆ G ∧ $o = $*
   
   [<a name="Zadd_def-val"><b>Zadd_def</b></a>]  Definition
      
      ⊢ ∀n. Z n =
            &lt;|carrier := count n; id := 0; op := (λi j. (i + j) MOD n)|&gt;
   
   [<a name="Zstar_def-val"><b>Zstar_def</b></a>]  Definition
      
      ⊢ ∀p. Z* p =
            &lt;|carrier := residue p; id := 1; op := (λi j. (i * j) MOD p)|&gt;
   
   [<a name="act_by_def-val"><b>act_by_def</b></a>]  Definition
      
      ⊢ ∀f g x y.
          (x ~~ y) f g ⇒ act_by f g x y ∈ G ∧ f (act_by f g x y) x = y
   
   [<a name="action_def-val"><b>action_def</b></a>]  Definition
      
      ⊢ ∀f g X.
          (g act X) f ⇔
          ∀x. x ∈ X ⇒
              (∀a. a ∈ G ⇒ f a x ∈ X) ∧ f #e x = x ∧
              ∀a b. a ∈ G ∧ b ∈ G ⇒ f a (f b x) = f (a * b) x
   
   [<a name="add_mod_def-val"><b>add_mod_def</b></a>]  Definition
      
      ⊢ ∀n. add_mod n =
            &lt;|carrier := {i | i &lt; n}; id := 0;
              op := (λi j. (i + j) MOD n)|&gt;
   
   [<a name="all_subgroups_def-val"><b>all_subgroups_def</b></a>]  Definition
      
      ⊢ ∀g. all_subgroups g = {h | h ≤ g}
   
   [<a name="cogen_def-val"><b>cogen_def</b></a>]  Definition
      
      ⊢ ∀g h e.
          h ≤ g ∧ e ∈ CosetPartition g h ⇒
          cogen g h e ∈ G ∧ e = cogen g h e * H
   
   [<a name="conjugate_def-val"><b>conjugate_def</b></a>]  Definition
      
      ⊢ ∀g a s. conjugate g a s = {a * z * |/ a | z ∈ s}
   
   [<a name="conjugate_subgroup_def-val"><b>conjugate_subgroup_def</b></a>]  Definition
      
      ⊢ ∀h g a.
          conjugate_subgroup h g a =
          &lt;|carrier := conjugate g a H; id := #e; op := $* |&gt;
   
   [<a name="coset_def-val"><b>coset_def</b></a>]  Definition
      
      ⊢ ∀g a X. a * X = IMAGE (λz. a * z) X
   
   [<a name="coset_op_def-val"><b>coset_op_def</b></a>]  Definition
      
      ⊢ ∀g h x y. x ∘ y = cogen g h x * cogen g h y * H
   
   [<a name="cyclic_def-val"><b>cyclic_def</b></a>]  Definition
      
      ⊢ ∀g. cyclic g ⇔ Group g ∧ ∃z. z ∈ G ∧ ∀x. x ∈ G ⇒ ∃n. x = z ** n
   
   [<a name="cyclic_gen_def-val"><b>cyclic_gen_def</b></a>]  Definition
      
      ⊢ ∀g. cyclic g ⇒
            cyclic_gen g ∈ G ∧ ∀x. x ∈ G ⇒ ∃n. x = cyclic_gen g ** n
   
   [<a name="cyclic_generators_def-val"><b>cyclic_generators_def</b></a>]  Definition
      
      ⊢ ∀g. cyclic_generators g = {z | z ∈ G ∧ ord z = CARD G}
   
   [<a name="cyclic_index_def-val"><b>cyclic_index_def</b></a>]  Definition
      
      ⊢ ∀g x.
          cyclic g ∧ x ∈ G ⇒
          x = cyclic_gen g ** cyclic_index g x ∧
          (FINITE G ⇒ cyclic_index g x &lt; CARD G)
   
   [<a name="eq_order_def-val"><b>eq_order_def</b></a>]  Definition
      
      ⊢ ∀g x y. eq_order g x y ⇔ ord x = ord y
   
   [<a name="excluding_def-val"><b>excluding_def</b></a>]  Definition
      
      ⊢ ∀g z. g excluding z = &lt;|carrier := G DIFF {z}; op := $*; id := #e|&gt;
   
   [<a name="fixed_points_def-val"><b>fixed_points_def</b></a>]  Definition
      
      ⊢ ∀f g X. fixed_points f g X = {x | x ∈ X ∧ ∀a. a ∈ G ⇒ f a x = x}
   
   [<a name="fn_cyclic_group_def-val"><b>fn_cyclic_group_def</b></a>]  Definition
      
      ⊢ ∀e f.
          fn_cyclic_group e f =
          &lt;|carrier := {x | ∃n. FUNPOW f n e = x}; id := e;
            op :=
              (λx y.
                   @z. ∀xi yi.
                     FUNPOW f xi e = x ∧ FUNPOW f yi e = y ⇒
                     FUNPOW f (xi + yi) e = z)|&gt;
   
   [<a name="group_div_def-val"><b>group_div_def</b></a>]  Definition
      
      ⊢ ∀g x y. x / y = x * |/ y
   
   [<a name="group_equiv_def-val"><b>group_equiv_def</b></a>]  Definition
      
      ⊢ ∀g h x y. x == y ⇔ x / y ∈ H
   
   [<a name="group_fun_def-val"><b>group_fun_def</b></a>]  Definition
      
      ⊢ ∀g f. gfun f ⇔ ∀x. x ∈ G ⇒ f x ∈ G
   
   [<a name="homo_image_def-val"><b>homo_image_def</b></a>]  Definition
      
      ⊢ ∀f g h.
          homo_image f g h =
          &lt;|carrier := IMAGE f G; op := h.op; id := h.id|&gt;
   
   [<a name="inCoset_def-val"><b>inCoset_def</b></a>]  Definition
      
      ⊢ ∀g h a b. inCoset g h a b ⇔ b ∈ a * H
   
   [<a name="including_def-val"><b>including_def</b></a>]  Definition
      
      ⊢ ∀g z. g including z = &lt;|carrier := G ∪ {z}; op := $*; id := #e|&gt;
   
   [<a name="kernel_def-val"><b>kernel_def</b></a>]  Definition
      
      ⊢ ∀f g h. kernel f g h = preimage f G h.id
   
   [<a name="kernel_group_def-val"><b>kernel_group_def</b></a>]  Definition
      
      ⊢ ∀f g h.
          kernel_group f g h =
          &lt;|carrier := kernel f g h; id := #e; op := $* |&gt;
   
   [<a name="left_coset_def-val"><b>left_coset_def</b></a>]  Definition
      
      ⊢ ∀g X a. left_coset g X a = a * X
   
   [<a name="make_group_def-val"><b>make_group_def</b></a>]  Definition
      
      ⊢ ∀g s. make_group g s = &lt;|carrier := s; op := $*; id := #e|&gt;
   
   [<a name="mult_mod_def-val"><b>mult_mod_def</b></a>]  Definition
      
      ⊢ ∀p. mult_mod p =
            &lt;|carrier := {i | i ≠ 0 ∧ i &lt; p}; id := 1;
              op := (λi j. (i * j) MOD p)|&gt;
   
   [<a name="multi_orbits_def-val"><b>multi_orbits_def</b></a>]  Definition
      
      ⊢ ∀f g X. multi_orbits f g X = {e | e ∈ orbits f g X ∧ ¬SING e}
   
   [<a name="normal_subgroup_def-val"><b>normal_subgroup_def</b></a>]  Definition
      
      ⊢ ∀h g. h &lt;&lt; g ⇔ h ≤ g ∧ ∀a z. a ∈ G ∧ z ∈ H ⇒ a * z / a ∈ H
   
   [<a name="orbit_def-val"><b>orbit_def</b></a>]  Definition
      
      ⊢ ∀f g x. orbit f g x = IMAGE (λa. f a x) G
   
   [<a name="orbits_def-val"><b>orbits_def</b></a>]  Definition
      
      ⊢ ∀f g X. orbits f g X = IMAGE (orbit f g) X
   
   [<a name="preimage_group_def-val"><b>preimage_group_def</b></a>]  Definition
      
      ⊢ ∀f g1 g2 h.
          preimage_group f g1 g2 h =
          &lt;|carrier := PREIMAGE f h ∩ g1.carrier; op := g1.op;
            id := g1.id|&gt;
   
   [<a name="quotient_group_def-val"><b>quotient_group_def</b></a>]  Definition
      
      ⊢ ∀g h. g / h = &lt;|carrier := CosetPartition g h; op := $o; id := H|&gt;
   
   [<a name="reach_def-val"><b>reach_def</b></a>]  Definition
      
      ⊢ ∀f g x y. (x ~~ y) f g ⇔ ∃a. a ∈ G ∧ f a x = y
   
   [<a name="right_coset_def-val"><b>right_coset_def</b></a>]  Definition
      
      ⊢ ∀g X a. X * a = IMAGE (λz. z * a) X
   
   [<a name="roots_of_unity_def-val"><b>roots_of_unity_def</b></a>]  Definition
      
      ⊢ ∀g n.
          uroots n =
          &lt;|carrier := {x | x ∈ G ∧ x ** n = #e}; op := $*; id := #e|&gt;
   
   [<a name="sing_orbits_def-val"><b>sing_orbits_def</b></a>]  Definition
      
      ⊢ ∀f g X. sing_orbits f g X = {e | e ∈ orbits f g X ∧ SING e}
   
   [<a name="stabilizer_def-val"><b>stabilizer_def</b></a>]  Definition
      
      ⊢ ∀f g x. stabilizer f g x = {a | a ∈ G ∧ f a x = x}
   
   [<a name="subgroup_big_cross_def-val"><b>subgroup_big_cross_def</b></a>]  Definition
      
      ⊢ ∀g B. sgbcross B = ITSET $o B (gen #e)
   
   [<a name="subgroup_big_intersect_def-val"><b>subgroup_big_intersect_def</b></a>]  Definition
      
      ⊢ ∀g. sgbINTER g =
            &lt;|carrier := BIGINTER (IMAGE (λh. H) {h | h ≤ g}); op := $*;
              id := #e|&gt;
   
   [<a name="subgroup_cross_def-val"><b>subgroup_cross_def</b></a>]  Definition
      
      ⊢ ∀g h1 h2. h1 ∘ h2 = make_group g (h1.carrier ∘ h2.carrier)
   
   [<a name="subgroup_def-val"><b>subgroup_def</b></a>]  Definition
      
      ⊢ ∀h g. subgroup h g ⇔ GroupHomo I h g
   
   [<a name="subset_big_cross_def-val"><b>subset_big_cross_def</b></a>]  Definition
      
      ⊢ ∀g B. ssbcross B = ITSET $o B {#e}
   
   [<a name="subset_cross_def-val"><b>subset_cross_def</b></a>]  Definition
      
      ⊢ ∀g s1 s2. s1 ∘ s2 = {x * y | x ∈ s1 ∧ y ∈ s2}
   
   [<a name="subset_cross_left_right_def-val"><b>subset_cross_left_right_def</b></a>]  Definition
      
      ⊢ ∀g s1 s2 z.
          z ∈ s1 ∘ s2 ⇒ left z ∈ s1 ∧ right z ∈ s2 ∧ z = left z * right z
   
   [<a name="subset_group_def-val"><b>subset_group_def</b></a>]  Definition
      
      ⊢ ∀g s. subset_group g s = &lt;|carrier := s; op := $*; id := #e|&gt;
   
   [<a name="symdiff_def-val"><b>symdiff_def</b></a>]  Definition
      
      ⊢ ∀s1 s2. symdiff s1 s2 = s1 ∪ s2 DIFF s1 ∩ s2
   
   [<a name="symdiff_set_def-val"><b>symdiff_set_def</b></a>]  Definition
      
      ⊢ symdiff_set = &lt;|carrier := 𝕌(:α -&gt; bool); id := ∅; op := symdiff|&gt;
   
   [<a name="trivial_group_def-val"><b>trivial_group_def</b></a>]  Definition
      
      ⊢ ∀e. trivial_group e = &lt;|carrier := {e}; id := e; op := (λx y. e)|&gt;
   
   [<a name="ElGamal_correctness-val"><b>ElGamal_correctness</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀(y::G) (h::G) (m::G) k x.
              h = y ** x ⇒
              ElGamal_decrypt g x (ElGamal_encrypt g y h m k) = m
   
   [<a name="Estar_alt-val"><b>Estar_alt</b></a>]  Theorem
      
      ⊢ ∀n. Estar n =
            &lt;|carrier := {i | 0 &lt; i ∧ i &lt; n ∧ coprime n i}; id := 1;
              op := (λi j. (i * j) MOD n)|&gt;
   
   [<a name="Estar_card-val"><b>Estar_card</b></a>]  Theorem
      
      ⊢ ∀n. CARD (Estar n).carrier = totient n
   
   [<a name="Estar_card_alt-val"><b>Estar_card_alt</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ CARD (Estar n).carrier = phi n
   
   [<a name="Estar_carrier-val"><b>Estar_carrier</b></a>]  Theorem
      
      ⊢ ∀n. (Estar n).carrier = Euler n
   
   [<a name="Estar_carrier_alt-val"><b>Estar_carrier_alt</b></a>]  Theorem
      
      ⊢ ∀n. (Estar n).carrier = {i | 0 &lt; i ∧ i &lt; n ∧ coprime n i}
   
   [<a name="Estar_element-val"><b>Estar_element</b></a>]  Theorem
      
      ⊢ ∀n x. x ∈ (Estar n).carrier ⇔ 0 &lt; x ∧ x &lt; n ∧ coprime n x
   
   [<a name="Estar_eval-val"><b>Estar_eval</b></a>]  Theorem
      
      ⊢ ∀n. (Estar n).carrier = Euler n ∧
            (∀x y. (Estar n).op x y = (x * y) MOD n) ∧ (Estar n).id = 1
   
   [<a name="Estar_exp-val"><b>Estar_exp</b></a>]  Theorem
      
      ⊢ ∀n a.
          1 &lt; n ∧ a ∈ (Estar n).carrier ⇒
          ∀k. (Estar n).exp a k = a ** k MOD n
   
   [<a name="Estar_finite-val"><b>Estar_finite</b></a>]  Theorem
      
      ⊢ ∀n. FINITE (Estar n).carrier
   
   [<a name="Estar_finite_abelian_group-val"><b>Estar_finite_abelian_group</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ FiniteAbelianGroup (Estar n)
   
   [<a name="Estar_finite_group-val"><b>Estar_finite_group</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ FiniteGroup (Estar n)
   
   [<a name="Estar_group-val"><b>Estar_group</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ Group (Estar n)
   
   [<a name="Estar_id-val"><b>Estar_id</b></a>]  Theorem
      
      ⊢ ∀n. (Estar n).id = 1
   
   [<a name="Estar_inv-val"><b>Estar_inv</b></a>]  Theorem
      
      ⊢ ∀n a.
          1 &lt; n ∧ a &lt; n ∧ coprime n a ⇒
          (Estar n).inv a = a ** (totient n − 1) MOD n
   
   [<a name="Estar_inv_compute-val"><b>Estar_inv_compute</b></a>]  Theorem
      
      ⊢ ∀n a.
          (Estar n).inv a =
          if 1 &lt; n ∧ a &lt; n ∧ coprime n a then a ** (totient n − 1) MOD n
          else FAIL ((Estar n).inv a) bad_element
   
   [<a name="Estar_property-val"><b>Estar_property</b></a>]  Theorem
      
      ⊢ ∀n. (Estar n).carrier = Euler n ∧ (Estar n).id = 1 ∧
            (∀x y. (Estar n).op x y = (x * y) MOD n) ∧
            FINITE (Estar n).carrier ∧ CARD (Estar n).carrier = totient n
   
   [<a name="Euler_Fermat_alt-val"><b>Euler_Fermat_alt</b></a>]  Theorem
      
      ⊢ ∀n a. 1 &lt; n ∧ coprime a n ⇒ a ** totient n MOD n = 1
   
   [<a name="Euler_Fermat_eqn-val"><b>Euler_Fermat_eqn</b></a>]  Theorem
      
      ⊢ ∀n a. 1 &lt; n ∧ a &lt; n ∧ coprime n a ⇒ a ** totient n MOD n = 1
   
   [<a name="Euler_Fermat_thm-val"><b>Euler_Fermat_thm</b></a>]  Theorem
      
      ⊢ ∀n a. 1 &lt; n ∧ coprime n a ⇒ a ** totient n MOD n = 1
   
   [<a name="Fermat_little_eqn-val"><b>Fermat_little_eqn</b></a>]  Theorem
      
      ⊢ ∀p a. prime p ⇒ a ** p MOD p = a MOD p
   
   [<a name="Fermat_little_thm-val"><b>Fermat_little_thm</b></a>]  Theorem
      
      ⊢ ∀p a. prime p ∧ 0 &lt; a ∧ a &lt; p ⇒ a ** (p − 1) MOD p = 1
   
   [<a name="FiniteAbelianGroup_def_alt-val"><b>FiniteAbelianGroup_def_alt</b></a>]  Theorem
      
      ⊢ ∀g. FiniteAbelianGroup g ⇔
            FiniteGroup g ∧ ∀x y. x ∈ G ∧ y ∈ G ⇒ x * y = y * x
   
   [<a name="GFACT_element-val"><b>GFACT_element</b></a>]  Theorem
      
      ⊢ ∀g. FiniteAbelianMonoid g ⇒ GFACT g ∈ G
   
   [<a name="GFACT_identity-val"><b>GFACT_identity</b></a>]  Theorem
      
      ⊢ ∀g a.
          FiniteAbelianGroup g ∧ a ∈ G ⇒ GFACT g = a ** CARD G * GFACT g
   
   [<a name="GITSET_AS_ITSET-val"><b>GITSET_AS_ITSET</b></a>]  Theorem
      
      ⊢ ∀g. (λs b. GITSET g s b) = ITSET (λe acc. e * acc)
   
   [<a name="GPROD_SET_AS_GROUP_IMAGE-val"><b>GPROD_SET_AS_GROUP_IMAGE</b></a>]  Theorem
      
      ⊢ ∀g. GPROD_SET g = GPI I
   
   [<a name="GPROD_SET_IMAGE-val"><b>GPROD_SET_IMAGE</b></a>]  Theorem
      
      ⊢ ∀g a. Group g ∧ a ∈ G ⇒ GPROD_SET g (a * G) = GPROD_SET g G
   
   [<a name="GPROD_SET_REDUCTION-val"><b>GPROD_SET_REDUCTION</b></a>]  Theorem
      
      ⊢ ∀g s.
          FiniteAbelianGroup g ∧ s ⊆ G ⇒
          ∀a::G.
            a ** CARD s * GPROD_SET g s * GPROD_SET g (a * (G DIFF s)) =
            GPROD_SET g G
   
   [<a name="GPROD_SET_REDUCTION_INSERT-val"><b>GPROD_SET_REDUCTION_INSERT</b></a>]  Theorem
      
      ⊢ ∀g s.
          FiniteAbelianGroup g ∧ s ⊆ G ⇒
          ∀a x::G.
            x ∉ s ⇒
            a * x * GPROD_SET g (a * (G DIFF (x INSERT s))) =
            GPROD_SET g (a * (G DIFF s))
   
   [<a name="Generated_subset_exp-val"><b>Generated_subset_exp</b></a>]  Theorem
      
      ⊢ ∀g s. (gen_set s).exp = $**
   
   [<a name="Generated_subset_gen-val"><b>Generated_subset_gen</b></a>]  Theorem
      
      ⊢ ∀g a. FiniteGroup g ∧ a ∈ G ⇒ gen_set (Gen a) = gen a
   
   [<a name="Generated_subset_group-val"><b>Generated_subset_group</b></a>]  Theorem
      
      ⊢ ∀g s. Group g ∧ s ⊆ G ⇒ Group (gen_set s)
   
   [<a name="Generated_subset_has_set-val"><b>Generated_subset_has_set</b></a>]  Theorem
      
      ⊢ ∀g s. s ⊆ (gen_set s).carrier
   
   [<a name="Generated_subset_property-val"><b>Generated_subset_property</b></a>]  Theorem
      
      ⊢ ∀g s.
          (gen_set s).carrier =
          BIGINTER (IMAGE (λh. H) {h | h ≤ g ∧ s ⊆ H}) ∧
          (gen_set s).op = $* ∧ (gen_set s).id = #e
   
   [<a name="Generated_subset_subgroup-val"><b>Generated_subset_subgroup</b></a>]  Theorem
      
      ⊢ ∀g s. Group g ∧ s ⊆ G ⇒ gen_set s ≤ g
   
   [<a name="Generated_subset_subset-val"><b>Generated_subset_subset</b></a>]  Theorem
      
      ⊢ ∀g s. Group g ∧ s ⊆ G ⇒ (gen_set s).carrier ⊆ G
   
   [<a name="Invertibles_inv-val"><b>Invertibles_inv</b></a>]  Theorem
      
      ⊢ ∀g x. Monoid g ∧ x ∈ G* ⇒ (Invertibles g).inv x = |/ x
   
   [<a name="Lagrange_identity-val"><b>Lagrange_identity</b></a>]  Theorem
      
      ⊢ ∀g h.
          h ≤ g ∧ FINITE G ⇒ CARD G = CARD H * CARD (CosetPartition g h)
   
   [<a name="Lagrange_identity_alt-val"><b>Lagrange_identity_alt</b></a>]  Theorem
      
      ⊢ ∀g h.
          h ≤ g ∧ FINITE G ⇒
          CARD G = CARD H * CARD (partition (left_coset g H) G)
   
   [<a name="Lagrange_thm-val"><b>Lagrange_thm</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ∧ FINITE G ⇒ CARD H divides CARD G
   
   [<a name="OP_IMAGE_EMPTY-val"><b>OP_IMAGE_EMPTY</b></a>]  Theorem
      
      ⊢ ∀op id f. OP_IMAGE op id f ∅ = id
   
   [<a name="OP_IMAGE_SING-val"><b>OP_IMAGE_SING</b></a>]  Theorem
      
      ⊢ ∀op id f x. OP_IMAGE op id f {x} = op (f x) id
   
   [<a name="OP_IMAGE_THM-val"><b>OP_IMAGE_THM</b></a>]  Theorem
      
      ⊢ ∀op id f.
          OP_IMAGE op id f ∅ = id ∧
          (FUN_COMM op f ⇒
           ∀s. FINITE s ⇒
               ∀e. OP_IMAGE op id f (e INSERT s) =
                   op (f e) (OP_IMAGE op id f (s DELETE e)))
   
   [<a name="PRIME_2-val"><b>PRIME_2</b></a>]  Theorem
      
      ⊢ prime 2
   
   [<a name="PRIME_3-val"><b>PRIME_3</b></a>]  Theorem
      
      ⊢ prime 3
   
   [<a name="PRIME_5-val"><b>PRIME_5</b></a>]  Theorem
      
      ⊢ prime 5
   
   [<a name="PRIME_7-val"><b>PRIME_7</b></a>]  Theorem
      
      ⊢ prime 7
   
   [<a name="SURJ_IMAGE_PREIMAGE-val"><b>SURJ_IMAGE_PREIMAGE</b></a>]  Theorem
      
      ⊢ ∀f a b. s ⊆ b ∧ SURJ f a b ⇒ IMAGE f (PREIMAGE f s ∩ a) = s
   
   [<a name="Subgroup_homo_homo-val"><b>Subgroup_homo_homo</b></a>]  Theorem
      
      ⊢ ∀g h k f. h ≤ g ∧ GroupHomo f g k ⇒ GroupHomo f h k
   
   [<a name="Subgroup_subgroup-val"><b>Subgroup_subgroup</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ subgroup h g
   
   [<a name="Zadd_card-val"><b>Zadd_card</b></a>]  Theorem
      
      ⊢ ∀n. CARD (Z n).carrier = n
   
   [<a name="Zadd_carrier-val"><b>Zadd_carrier</b></a>]  Theorem
      
      ⊢ ∀n. (Z n).carrier = count n
   
   [<a name="Zadd_carrier_alt-val"><b>Zadd_carrier_alt</b></a>]  Theorem
      
      ⊢ ∀n. (Z n).carrier = {i | i &lt; n}
   
   [<a name="Zadd_element-val"><b>Zadd_element</b></a>]  Theorem
      
      ⊢ ∀n x. x ∈ (Z n).carrier ⇔ x &lt; n
   
   [<a name="Zadd_eval-val"><b>Zadd_eval</b></a>]  Theorem
      
      ⊢ ∀n. (Z n).carrier = count n ∧
            (∀x y. (Z n).op x y = (x + y) MOD n) ∧ (Z n).id = 0
   
   [<a name="Zadd_exp-val"><b>Zadd_exp</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀x m. (Z n).exp x m = (x * m) MOD n
   
   [<a name="Zadd_finite-val"><b>Zadd_finite</b></a>]  Theorem
      
      ⊢ ∀n. FINITE (Z n).carrier
   
   [<a name="Zadd_finite_abelian_group-val"><b>Zadd_finite_abelian_group</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ FiniteAbelianGroup (Z n)
   
   [<a name="Zadd_finite_group-val"><b>Zadd_finite_group</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ FiniteGroup (Z n)
   
   [<a name="Zadd_group-val"><b>Zadd_group</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ Group (Z n)
   
   [<a name="Zadd_id-val"><b>Zadd_id</b></a>]  Theorem
      
      ⊢ ∀n. (Z n).id = 0
   
   [<a name="Zadd_inv-val"><b>Zadd_inv</b></a>]  Theorem
      
      ⊢ ∀n x. 0 &lt; n ∧ x &lt; n ⇒ (Z n).inv x = (n − x) MOD n
   
   [<a name="Zadd_inv_compute-val"><b>Zadd_inv_compute</b></a>]  Theorem
      
      ⊢ ∀n x.
          (Z n).inv x =
          if 0 &lt; n ∧ x &lt; n then (n − x) MOD n
          else FAIL ((Z n).inv x) bad_element
   
   [<a name="Zadd_property-val"><b>Zadd_property</b></a>]  Theorem
      
      ⊢ ∀n. (∀x. x ∈ (Z n).carrier ⇔ x &lt; n) ∧ (Z n).id = 0 ∧
            (∀x y. (Z n).op x y = (x + y) MOD n) ∧ FINITE (Z n).carrier ∧
            CARD (Z n).carrier = n
   
   [<a name="Zstar_card-val"><b>Zstar_card</b></a>]  Theorem
      
      ⊢ ∀p. 0 &lt; p ⇒ CARD (Z* p).carrier = p − 1
   
   [<a name="Zstar_carrier-val"><b>Zstar_carrier</b></a>]  Theorem
      
      ⊢ ∀p. (Z* p).carrier = residue p
   
   [<a name="Zstar_carrier_alt-val"><b>Zstar_carrier_alt</b></a>]  Theorem
      
      ⊢ ∀p. (Z* p).carrier = {i | 0 &lt; i ∧ i &lt; p}
   
   [<a name="Zstar_element-val"><b>Zstar_element</b></a>]  Theorem
      
      ⊢ ∀p x. x ∈ (Z* p).carrier ⇔ 0 &lt; x ∧ x &lt; p
   
   [<a name="Zstar_eval-val"><b>Zstar_eval</b></a>]  Theorem
      
      ⊢ ∀p. (Z* p).carrier = residue p ∧
            (∀x y. (Z* p).op x y = (x * y) MOD p) ∧ (Z* p).id = 1
   
   [<a name="Zstar_exp-val"><b>Zstar_exp</b></a>]  Theorem
      
      ⊢ ∀p a.
          prime p ∧ a ∈ (Z* p).carrier ⇒ ∀n. (Z* p).exp a n = a ** n MOD p
   
   [<a name="Zstar_finite-val"><b>Zstar_finite</b></a>]  Theorem
      
      ⊢ ∀p. FINITE (Z* p).carrier
   
   [<a name="Zstar_finite_abelian_group-val"><b>Zstar_finite_abelian_group</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇒ FiniteAbelianGroup (Z* p)
   
   [<a name="Zstar_finite_group-val"><b>Zstar_finite_group</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇒ FiniteGroup (Z* p)
   
   [<a name="Zstar_group-val"><b>Zstar_group</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇒ Group (Z* p)
   
   [<a name="Zstar_id-val"><b>Zstar_id</b></a>]  Theorem
      
      ⊢ ∀p. (Z* p).id = 1
   
   [<a name="Zstar_inv-val"><b>Zstar_inv</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇒
            ∀x. 0 &lt; x ∧ x &lt; p ⇒
                (Z* p).inv x = (Z* p).exp x (order (Z* p) x − 1)
   
   [<a name="Zstar_inv_compute-val"><b>Zstar_inv_compute</b></a>]  Theorem
      
      ⊢ ∀p x.
          (Z* p).inv x =
          if prime p ∧ 0 &lt; x ∧ x &lt; p then (Z* p).exp x (order (Z* p) x − 1)
          else FAIL ((Z* p).inv x) bad_element
   
   [<a name="Zstar_inverse-val"><b>Zstar_inverse</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇒ ∀a. 0 &lt; a ∧ a &lt; p ⇒ (Z* p).inv a = a ** (p − 2) MOD p
   
   [<a name="Zstar_inverse_compute-val"><b>Zstar_inverse_compute</b></a>]  Theorem
      
      ⊢ ∀p a.
          (Z* p).inv a =
          if prime p ∧ 0 &lt; a ∧ a &lt; p then a ** (p − 2) MOD p
          else (Z* p).inv a
   
   [<a name="Zstar_property-val"><b>Zstar_property</b></a>]  Theorem
      
      ⊢ ∀p. (Z* p).carrier = residue p ∧ (Z* p).id = 1 ∧
            (∀x y. (Z* p).op x y = (x * y) MOD p) ∧ FINITE (Z* p).carrier ∧
            (0 &lt; p ⇒ CARD (Z* p).carrier = p − 1)
   
   [<a name="abelian_group_is_abelian_monoid-val"><b>abelian_group_is_abelian_monoid</b></a>]  Theorem
      
      ⊢ ∀g. AbelianGroup g ⇒ AbelianMonoid g
   
   [<a name="abelian_group_order_common-val"><b>abelian_group_order_common</b></a>]  Theorem
      
      ⊢ ∀g. AbelianGroup g ⇒
            ∀x y.
              x ∈ G ∧ y ∈ G ⇒
              ∃z. z ∈ G ∧ ord z * gcd (ord x) (ord y) = lcm (ord x) (ord y)
   
   [<a name="abelian_group_order_common_coprime-val"><b>abelian_group_order_common_coprime</b></a>]  Theorem
      
      ⊢ ∀g. AbelianGroup g ⇒
            ∀x y.
              x ∈ G ∧ y ∈ G ∧ coprime (ord x) (ord y) ⇒
              ∃z. z ∈ G ∧ ord z = ord x * ord y
   
   [<a name="abelian_monoid_invertible_excluding-val"><b>abelian_monoid_invertible_excluding</b></a>]  Theorem
      
      ⊢ ∀g. AbelianMonoid g ⇒
            ∀z. z ∉ G* ⇒ monoid_invertibles (g excluding z) = G*
   
   [<a name="abelian_subgroup_abelian-val"><b>abelian_subgroup_abelian</b></a>]  Theorem
      
      ⊢ ∀g h. AbelianGroup g ∧ h ≤ g ⇒ AbelianGroup h
   
   [<a name="abelian_subgroup_cross_finite-val"><b>abelian_subgroup_cross_finite</b></a>]  Theorem
      
      ⊢ ∀g. AbelianGroup g ⇒
            ∀h1 h2.
              h1 ≤ g ∧ h2 ≤ g ∧ FiniteGroup h1 ∧ FiniteGroup h2 ⇒
              FiniteGroup (h1 ∘ h2)
   
   [<a name="abelian_subgroup_cross_subgroup-val"><b>abelian_subgroup_cross_subgroup</b></a>]  Theorem
      
      ⊢ ∀g. AbelianGroup g ⇒ ∀h1 h2. h1 ≤ g ∧ h2 ≤ g ⇒ h1 ∘ h2 ≤ g
   
   [<a name="action_closure-val"><b>action_closure</b></a>]  Theorem
      
      ⊢ ∀f g X. (g act X) f ⇒ ∀a x. a ∈ G ∧ x ∈ X ⇒ f a x ∈ X
   
   [<a name="action_compose-val"><b>action_compose</b></a>]  Theorem
      
      ⊢ ∀f g X.
          (g act X) f ⇒
          ∀a b x. a ∈ G ∧ b ∈ G ∧ x ∈ X ⇒ f a (f b x) = f (a * b) x
   
   [<a name="action_id-val"><b>action_id</b></a>]  Theorem
      
      ⊢ ∀f g X. (g act X) f ⇒ ∀x. x ∈ X ⇒ f #e x = x
   
   [<a name="action_match_condition-val"><b>action_match_condition</b></a>]  Theorem
      
      ⊢ ∀f g X x.
          Group g ∧ (g act X) f ∧ x ∈ X ⇒
          ∀a b.
            a ∈ G ∧ b ∈ G ⇒ (f a x = f b x ⇔ |/ a * b ∈ stabilizer f g x)
   
   [<a name="action_match_condition_alt-val"><b>action_match_condition_alt</b></a>]  Theorem
      
      ⊢ ∀f g X x.
          Group g ∧ (g act X) f ∧ x ∈ X ⇒
          ∀a b::G. f a x = f b x ⇔ |/ a * b ∈ stabilizer f g x
   
   [<a name="action_reachable_coset-val"><b>action_reachable_coset</b></a>]  Theorem
      
      ⊢ ∀f g X x y.
          Group g ∧ (g act X) f ∧ x ∈ X ∧ y ∈ orbit f g x ⇒
          act_by f g x y * stabilizer f g x = {a | a ∈ G ∧ f a x = y}
   
   [<a name="action_reachable_coset_alt-val"><b>action_reachable_coset_alt</b></a>]  Theorem
      
      ⊢ ∀f g X x y.
          Group g ∧ (g act X) f ∧ x ∈ X ∧ y ∈ orbit f g x ⇒
          ∀a. a ∈ G ∧ f a x = y ⇒
              a * stabilizer f g x = {b | b ∈ G ∧ f b x = y}
   
   [<a name="action_reverse-val"><b>action_reverse</b></a>]  Theorem
      
      ⊢ ∀f g X.
          Group g ∧ (g act X) f ⇒
          ∀a x y. a ∈ G ∧ x ∈ X ∧ y ∈ X ∧ f a x = y ⇒ f ( |/ a) y = x
   
   [<a name="action_to_orbit_surj-val"><b>action_to_orbit_surj</b></a>]  Theorem
      
      ⊢ ∀f g X x. (g act X) f ∧ x ∈ X ⇒ SURJ (λa. f a x) G (orbit f g x)
   
   [<a name="action_trans-val"><b>action_trans</b></a>]  Theorem
      
      ⊢ ∀f g X.
          (g act X) f ⇒
          ∀a b x y z.
            a ∈ G ∧ b ∈ G ∧ x ∈ X ∧ y ∈ X ∧ z ∈ X ∧ f a x = y ∧ f b y = z ⇒
            f (b * a) x = z
   
   [<a name="add_mod_abelian_group-val"><b>add_mod_abelian_group</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ AbelianGroup (add_mod n)
   
   [<a name="add_mod_card-val"><b>add_mod_card</b></a>]  Theorem
      
      ⊢ ∀n. CARD (add_mod n).carrier = n
   
   [<a name="add_mod_carrier-val"><b>add_mod_carrier</b></a>]  Theorem
      
      ⊢ ∀n. (add_mod n).carrier = {i | i &lt; n}
   
   [<a name="add_mod_carrier_alt-val"><b>add_mod_carrier_alt</b></a>]  Theorem
      
      ⊢ ∀n. (add_mod n).carrier = count n
   
   [<a name="add_mod_cylic-val"><b>add_mod_cylic</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ cyclic (add_mod n)
   
   [<a name="add_mod_element-val"><b>add_mod_element</b></a>]  Theorem
      
      ⊢ ∀n x. x ∈ (add_mod n).carrier ⇔ x &lt; n
   
   [<a name="add_mod_eval-val"><b>add_mod_eval</b></a>]  Theorem
      
      ⊢ ∀n. (add_mod n).carrier = {i | i &lt; n} ∧
            (∀x y. (add_mod n).op x y = (x + y) MOD n) ∧ (add_mod n).id = 0
   
   [<a name="add_mod_exp-val"><b>add_mod_exp</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀x m. (add_mod n).exp x m = (x * m) MOD n
   
   [<a name="add_mod_finite-val"><b>add_mod_finite</b></a>]  Theorem
      
      ⊢ ∀n. FINITE (add_mod n).carrier
   
   [<a name="add_mod_finite_abelian_group-val"><b>add_mod_finite_abelian_group</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ FiniteAbelianGroup (add_mod n)
   
   [<a name="add_mod_finite_group-val"><b>add_mod_finite_group</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ FiniteGroup (add_mod n)
   
   [<a name="add_mod_group-val"><b>add_mod_group</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ Group (add_mod n)
   
   [<a name="add_mod_id-val"><b>add_mod_id</b></a>]  Theorem
      
      ⊢ ∀n. (add_mod n).id = 0
   
   [<a name="add_mod_inv-val"><b>add_mod_inv</b></a>]  Theorem
      
      ⊢ ∀n x. 0 &lt; n ∧ x &lt; n ⇒ (add_mod n).inv x = (n − x) MOD n
   
   [<a name="add_mod_inv_compute-val"><b>add_mod_inv_compute</b></a>]  Theorem
      
      ⊢ ∀n x.
          (add_mod n).inv x =
          if 0 &lt; n ∧ x &lt; n then (n − x) MOD n
          else FAIL ((add_mod n).inv x) bad_element
   
   [<a name="add_mod_order_1-val"><b>add_mod_order_1</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ order (add_mod n) 1 = n
   
   [<a name="add_mod_property-val"><b>add_mod_property</b></a>]  Theorem
      
      ⊢ ∀n. (∀x. x ∈ (add_mod n).carrier ⇔ x &lt; n) ∧ (add_mod n).id = 0 ∧
            (∀x y. (add_mod n).op x y = (x + y) MOD n) ∧
            FINITE (add_mod n).carrier ∧ CARD (add_mod n).carrier = n
   
   [<a name="all_subgroups_element-val"><b>all_subgroups_element</b></a>]  Theorem
      
      ⊢ ∀g h. h ∈ all_subgroups g ⇔ h ≤ g
   
   [<a name="all_subgroups_finite-val"><b>all_subgroups_finite</b></a>]  Theorem
      
      ⊢ ∀g. FiniteGroup g ⇒ FINITE (all_subgroups g)
   
   [<a name="all_subgroups_has_gen_id-val"><b>all_subgroups_has_gen_id</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ gen #e ∈ all_subgroups g
   
   [<a name="all_subgroups_subset-val"><b>all_subgroups_subset</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ IMAGE (λh. H) (all_subgroups g) ⊆ POW G
   
   [<a name="bij_corres-val"><b>bij_corres</b></a>]  Theorem
      
      ⊢ ∀f g1 g2 h1 h2.
          Group g1 ∧ Group g2 ∧ h1 ≤ g1 ∧ h2 ≤ g2 ∧ GroupHomo f g1 g2 ∧
          SURJ f g1.carrier g2.carrier ∧ kernel f g1 g2 ⊆ h1.carrier ⇒
          IMAGE f (PREIMAGE f h2.carrier ∩ g1.carrier) = h2.carrier ∧
          PREIMAGE f (IMAGE f h1.carrier) ∩ g1.carrier = h1.carrier
   
   [<a name="carrier_card_by_coset_partition-val"><b>carrier_card_by_coset_partition</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ∧ FINITE G ⇒ CARD G = ∑ CARD (CosetPartition g h)
   
   [<a name="carrier_card_by_subgroup_coset_partition-val"><b>carrier_card_by_subgroup_coset_partition</b></a>]  Theorem
      
      ⊢ ∀g h.
          h ≤ g ∧ FINITE G ⇒ CARD G = ∑ CARD (partition (left_coset g H) G)
   
   [<a name="cogen_coset_element-val"><b>cogen_coset_element</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ ∀x. x ∈ G ⇒ cogen g h (x * H) ∈ G
   
   [<a name="cogen_element-val"><b>cogen_element</b></a>]  Theorem
      
      ⊢ ∀h g e. h ≤ g ∧ e ∈ CosetPartition g h ⇒ cogen g h e ∈ G
   
   [<a name="cogen_of_subgroup-val"><b>cogen_of_subgroup</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ cogen g h H * H = H
   
   [<a name="conjugate_subgroup_group-val"><b>conjugate_subgroup_group</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ ∀a. a ∈ G ⇒ Group (conjugate_subgroup h g a)
   
   [<a name="conjugate_subgroup_subgroup-val"><b>conjugate_subgroup_subgroup</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ ∀a::G. conjugate_subgroup h g a ≤ g
   
   [<a name="corres_thm-val"><b>corres_thm</b></a>]  Theorem
      
      ⊢ ∀f g1 g2 h1 h2.
          Group g1 ∧ Group g2 ∧ GroupHomo f g1 g2 ∧
          SURJ f g1.carrier g2.carrier ∧ h1 ≤ g1 ∧
          kernel f g1 g2 ⊆ h1.carrier ∧ h2 ≤ g2 ⇒
          homo_image f h1 g2 ≤ g2 ∧
          preimage_group f g1 g2 h2.carrier ≤ g1 ∧
          kernel f g1 g2 ⊆ PREIMAGE f h2.carrier ∩ g1.carrier ∧
          (h2 &lt;&lt; g2 ⇔ preimage_group f g1 g2 h2.carrier &lt;&lt; g1) ∧
          IMAGE f (PREIMAGE f h2.carrier ∩ g1.carrier) = h2.carrier ∧
          PREIMAGE f (IMAGE f h1.carrier) ∩ g1.carrier = h1.carrier ∧
          (FiniteGroup g1 ⇒
           CARD (preimage_group f g1 g2 h2.carrier).carrier =
           CARD h2.carrier * CARD (kernel f g1 g2))
   
   [<a name="coset_alt-val"><b>coset_alt</b></a>]  Theorem
      
      ⊢ ∀g a X. a * X = {a * z | z ∈ X}
   
   [<a name="coset_cogen_property-val"><b>coset_cogen_property</b></a>]  Theorem
      
      ⊢ ∀h g e. h ≤ g ∧ e ∈ CosetPartition g h ⇒ e = cogen g h e * H
   
   [<a name="coset_element-val"><b>coset_element</b></a>]  Theorem
      
      ⊢ ∀g X a. a ∈ G ⇒ ∀x. x ∈ a * X ⇔ ∃y. y ∈ X ∧ x = a * y
   
   [<a name="coset_empty-val"><b>coset_empty</b></a>]  Theorem
      
      ⊢ ∀g a. Group g ∧ a ∈ G ⇒ a * ∅ = ∅
   
   [<a name="coset_homo_group_iso_quotient_group-val"><b>coset_homo_group_iso_quotient_group</b></a>]  Theorem
      
      ⊢ ∀g h. h &lt;&lt; g ⇒ GroupIso I (homo_group g (left_coset g H)) (g / h)
   
   [<a name="coset_id_eq_subgroup-val"><b>coset_id_eq_subgroup</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ #e * H = H
   
   [<a name="coset_partition_card-val"><b>coset_partition_card</b></a>]  Theorem
      
      ⊢ ∀g h.
          h ≤ g ∧ FINITE G ⇒ CARD (CosetPartition g h) = CARD G DIV CARD H
   
   [<a name="coset_partition_element-val"><b>coset_partition_element</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ ∀e. e ∈ CosetPartition g h ⇔ ∃a. a ∈ G ∧ e = a * H
   
   [<a name="coset_partition_element_card-val"><b>coset_partition_element_card</b></a>]  Theorem
      
      ⊢ ∀g h.
          h ≤ g ∧ FINITE G ⇒ ∀e. e ∈ CosetPartition g h ⇒ CARD e = CARD H
   
   [<a name="coset_partition_eq_coset_image-val"><b>coset_partition_eq_coset_image</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ CosetPartition g h = IMAGE (left_coset g H) G
   
   [<a name="coset_property-val"><b>coset_property</b></a>]  Theorem
      
      ⊢ ∀g a. Group g ∧ a ∈ G ⇒ ∀X. X ⊆ G ⇒ a * X ⊆ G
   
   [<a name="count_formula-val"><b>count_formula</b></a>]  Theorem
      
      ⊢ ∀g h.
          FiniteGroup g ∧ h &lt;&lt; g ⇒ CARD G = CARD H * CARD (g / h).carrier
   
   [<a name="cyclic_element-val"><b>cyclic_element</b></a>]  Theorem
      
      ⊢ ∀g. cyclic g ⇒ ∀x. x ∈ G ⇒ ∃n. x = cyclic_gen g ** n
   
   [<a name="cyclic_element_by_gen-val"><b>cyclic_element_by_gen</b></a>]  Theorem
      
      ⊢ ∀g. cyclic g ∧ FINITE G ⇒
            ∀x. x ∈ G ⇒ ∃n. n &lt; CARD G ∧ x = cyclic_gen g ** n
   
   [<a name="cyclic_element_in_generated-val"><b>cyclic_element_in_generated</b></a>]  Theorem
      
      ⊢ ∀g. cyclic g ∧ FINITE G ⇒
            ∀x. x ∈ G ⇒ x ∈ Gen (cyclic_gen g ** (CARD G DIV ord x))
   
   [<a name="cyclic_eq_order_partition-val"><b>cyclic_eq_order_partition</b></a>]  Theorem
      
      ⊢ ∀g. cyclic g ∧ FINITE G ⇒
            partition (eq_order g) G = {orders g n | n | n divides CARD G}
   
   [<a name="cyclic_eq_order_partition_alt-val"><b>cyclic_eq_order_partition_alt</b></a>]  Theorem
      
      ⊢ ∀g. cyclic g ∧ FINITE G ⇒
            partition (eq_order g) G =
            {orders g n | n | n ∈ divisors (CARD G)}
   
   [<a name="cyclic_eq_order_partition_by_card-val"><b>cyclic_eq_order_partition_by_card</b></a>]  Theorem
      
      ⊢ ∀g. cyclic g ∧ FINITE G ⇒
            IMAGE CARD (partition (eq_order g) G) =
            IMAGE phi (divisors (CARD G))
   
   [<a name="cyclic_finite_alt-val"><b>cyclic_finite_alt</b></a>]  Theorem
      
      ⊢ ∀g. FiniteGroup g ⇒ (cyclic g ⇔ ∃z. z ∈ G ∧ ord z = CARD G)
   
   [<a name="cyclic_finite_has_order_divisor-val"><b>cyclic_finite_has_order_divisor</b></a>]  Theorem
      
      ⊢ ∀g. cyclic g ∧ FINITE G ⇒
            ∀n. n divides CARD G ⇒ ∃x. x ∈ G ∧ ord x = n
   
   [<a name="cyclic_gen_element-val"><b>cyclic_gen_element</b></a>]  Theorem
      
      ⊢ ∀g. cyclic g ⇒ cyclic_gen g ∈ G
   
   [<a name="cyclic_gen_order-val"><b>cyclic_gen_order</b></a>]  Theorem
      
      ⊢ ∀g. cyclic g ∧ FINITE G ⇒ ord (cyclic_gen g) = CARD G
   
   [<a name="cyclic_gen_power_order-val"><b>cyclic_gen_power_order</b></a>]  Theorem
      
      ⊢ ∀g. cyclic g ∧ FINITE G ⇒
            ∀n. 0 &lt; n ∧ CARD G MOD n = 0 ⇒
                ord (cyclic_gen g ** (CARD G DIV n)) = n
   
   [<a name="cyclic_generated_by_gen-val"><b>cyclic_generated_by_gen</b></a>]  Theorem
      
      ⊢ ∀g. cyclic g ⇒ g = gen (cyclic_gen g)
   
   [<a name="cyclic_generated_group-val"><b>cyclic_generated_group</b></a>]  Theorem
      
      ⊢ ∀g. FiniteGroup g ⇒ ∀x. x ∈ G ⇒ cyclic (gen x)
   
   [<a name="cyclic_generators_card-val"><b>cyclic_generators_card</b></a>]  Theorem
      
      ⊢ ∀g. cyclic g ∧ FINITE G ⇒ CARD (cyclic_generators g) = phi (CARD G)
   
   [<a name="cyclic_generators_coprimes_bij-val"><b>cyclic_generators_coprimes_bij</b></a>]  Theorem
      
      ⊢ ∀g. cyclic g ∧ FINITE G ⇒
            BIJ (λj. cyclic_gen g ** j) (coprimes (CARD G))
              (cyclic_generators g)
   
   [<a name="cyclic_generators_element-val"><b>cyclic_generators_element</b></a>]  Theorem
      
      ⊢ ∀g z. z ∈ cyclic_generators g ⇔ z ∈ G ∧ ord z = CARD G
   
   [<a name="cyclic_generators_finite-val"><b>cyclic_generators_finite</b></a>]  Theorem
      
      ⊢ ∀g. FINITE G ⇒ FINITE (cyclic_generators g)
   
   [<a name="cyclic_generators_gen_cofactor_eq_orders-val"><b>cyclic_generators_gen_cofactor_eq_orders</b></a>]  Theorem
      
      ⊢ ∀g. cyclic g ∧ FINITE G ⇒
            ∀n. n divides CARD G ⇒
                cyclic_generators (gen (cyclic_gen g ** (CARD G DIV n))) =
                orders g n
   
   [<a name="cyclic_generators_nonempty-val"><b>cyclic_generators_nonempty</b></a>]  Theorem
      
      ⊢ ∀g. cyclic g ∧ FINITE G ⇒ cyclic_generators g ≠ ∅
   
   [<a name="cyclic_generators_subset-val"><b>cyclic_generators_subset</b></a>]  Theorem
      
      ⊢ ∀g. cyclic_generators g ⊆ G
   
   [<a name="cyclic_group-val"><b>cyclic_group</b></a>]  Theorem
      
      ⊢ ∀g. cyclic g ⇒ Group g
   
   [<a name="cyclic_group_abelian-val"><b>cyclic_group_abelian</b></a>]  Theorem
      
      ⊢ ∀g. cyclic g ⇒ AbelianGroup g
   
   [<a name="cyclic_group_comm-val"><b>cyclic_group_comm</b></a>]  Theorem
      
      ⊢ ∀g. cyclic g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ x * y = y * x
   
   [<a name="cyclic_image_ord_is_divisors-val"><b>cyclic_image_ord_is_divisors</b></a>]  Theorem
      
      ⊢ ∀g. cyclic g ∧ FINITE G ⇒ IMAGE ord G = divisors (CARD G)
   
   [<a name="cyclic_index_exists-val"><b>cyclic_index_exists</b></a>]  Theorem
      
      ⊢ ∀g x.
          cyclic g ∧ x ∈ G ⇒
          ∃n. x = cyclic_gen g ** n ∧ (FINITE G ⇒ n &lt; CARD G)
   
   [<a name="cyclic_iso_gen-val"><b>cyclic_iso_gen</b></a>]  Theorem
      
      ⊢ ∀g h f.
          cyclic g ∧ cyclic h ∧ FINITE G ∧ GroupIso f g h ⇒
          f (cyclic_gen g) ∈ cyclic_generators h
   
   [<a name="cyclic_orders_card-val"><b>cyclic_orders_card</b></a>]  Theorem
      
      ⊢ ∀g. cyclic g ∧ FINITE G ⇒
            ∀n. CARD (orders g n) = if n divides CARD G then phi n else 0
   
   [<a name="cyclic_orders_nonempty-val"><b>cyclic_orders_nonempty</b></a>]  Theorem
      
      ⊢ ∀g. cyclic g ∧ FINITE G ⇒ ∀n. n divides CARD G ⇒ orders g n ≠ ∅
   
   [<a name="cyclic_orders_partition-val"><b>cyclic_orders_partition</b></a>]  Theorem
      
      ⊢ ∀g. cyclic g ∧ FINITE G ⇒
            partition (eq_order g) G = IMAGE (orders g) (divisors (CARD G))
   
   [<a name="cyclic_subgroup_condition-val"><b>cyclic_subgroup_condition</b></a>]  Theorem
      
      ⊢ ∀g. cyclic g ∧ FINITE G ⇒
            ∀n. (∃h. h ≤ g ∧ CARD H = n) ⇔ n divides CARD G
   
   [<a name="cyclic_subgroup_cyclic-val"><b>cyclic_subgroup_cyclic</b></a>]  Theorem
      
      ⊢ ∀g h. cyclic g ∧ h ≤ g ⇒ cyclic h
   
   [<a name="cyclic_uroots_cyclic-val"><b>cyclic_uroots_cyclic</b></a>]  Theorem
      
      ⊢ ∀g. cyclic g ⇒ ∀n. cyclic (uroots n)
   
   [<a name="cyclic_uroots_has_primitive-val"><b>cyclic_uroots_has_primitive</b></a>]  Theorem
      
      ⊢ ∀g. FINITE G ∧ cyclic g ⇒
            ∀n. ∃z.
              z ∈ (uroots n).carrier ∧ ord z = CARD (uroots n).carrier
   
   [<a name="element_coset_property-val"><b>element_coset_property</b></a>]  Theorem
      
      ⊢ ∀g X a. a ∈ G ⇒ ∀x. x ∈ X ⇒ a * x ∈ a * X
   
   [<a name="eq_order_equiv-val"><b>eq_order_equiv</b></a>]  Theorem
      
      ⊢ ∀g. eq_order g equiv_on G
   
   [<a name="eq_order_is_feq_order-val"><b>eq_order_is_feq_order</b></a>]  Theorem
      
      ⊢ ∀g. eq_order g = feq ord
   
   [<a name="fermat_little-val"><b>fermat_little</b></a>]  Theorem
      
      ⊢ ∀p a. prime p ∧ 0 &lt; a ∧ a &lt; p ⇒ a ** (p − 1) MOD p = 1
   
   [<a name="fermat_little_alt-val"><b>fermat_little_alt</b></a>]  Theorem
      
      ⊢ ∀p a. prime p ⇒ a ** (p − 1) MOD p = if a MOD p = 0 then 0 else 1
   
   [<a name="fermat_little_thm-val"><b>fermat_little_thm</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇒ ∀a. a ** p MOD p = a MOD p
   
   [<a name="fermat_roots-val"><b>fermat_roots</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇒
            ∀x y z. x ** p + y ** p = z ** p ⇒ (x + y) MOD p = z MOD p
   
   [<a name="finite_abelian_Fermat-val"><b>finite_abelian_Fermat</b></a>]  Theorem
      
      ⊢ ∀g a. FiniteAbelianGroup g ∧ a ∈ G ⇒ a ** CARD G = #e
   
   [<a name="finite_abelian_group_is_finite_abelian_monoid-val"><b>finite_abelian_group_is_finite_abelian_monoid</b></a>]  Theorem
      
      ⊢ ∀g. FiniteAbelianGroup g ⇒ FiniteAbelianMonoid g
   
   [<a name="finite_cyclic_group_add_mod_bij-val"><b>finite_cyclic_group_add_mod_bij</b></a>]  Theorem
      
      ⊢ ∀g. cyclic g ∧ FINITE G ⇒
            BIJ (λn. cyclic_gen g ** n) (add_mod (CARD G)).carrier G
   
   [<a name="finite_cyclic_group_add_mod_homo-val"><b>finite_cyclic_group_add_mod_homo</b></a>]  Theorem
      
      ⊢ ∀g. cyclic g ∧ FINITE G ⇒
            GroupHomo (λn. cyclic_gen g ** n) (add_mod (CARD G)) g
   
   [<a name="finite_cyclic_group_add_mod_iso-val"><b>finite_cyclic_group_add_mod_iso</b></a>]  Theorem
      
      ⊢ ∀g. cyclic g ∧ FINITE G ⇒
            GroupIso (λn. cyclic_gen g ** n) (add_mod (CARD G)) g
   
   [<a name="finite_cyclic_group_bij-val"><b>finite_cyclic_group_bij</b></a>]  Theorem
      
      ⊢ ∀g1 g2.
          cyclic g1 ∧ cyclic g2 ∧ FINITE g1.carrier ∧ FINITE g2.carrier ∧
          CARD g1.carrier = CARD g2.carrier ⇒
          BIJ (λx. g2.exp (cyclic_gen g2) (cyclic_index g1 x)) g1.carrier
            g2.carrier
   
   [<a name="finite_cyclic_group_existence-val"><b>finite_cyclic_group_existence</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∃g. cyclic g ∧ CARD g.carrier = n
   
   [<a name="finite_cyclic_group_homo-val"><b>finite_cyclic_group_homo</b></a>]  Theorem
      
      ⊢ ∀g1 g2.
          cyclic g1 ∧ cyclic g2 ∧ FINITE g1.carrier ∧ FINITE g2.carrier ∧
          CARD g1.carrier = CARD g2.carrier ⇒
          GroupHomo (λx. g2.exp (cyclic_gen g2) (cyclic_index g1 x)) g1 g2
   
   [<a name="finite_cyclic_group_iso-val"><b>finite_cyclic_group_iso</b></a>]  Theorem
      
      ⊢ ∀g1 g2.
          cyclic g1 ∧ cyclic g2 ∧ FINITE g1.carrier ∧ FINITE g2.carrier ∧
          CARD g1.carrier = CARD g2.carrier ⇒
          GroupIso (λx. g2.exp (cyclic_gen g2) (cyclic_index g1 x)) g1 g2
   
   [<a name="finite_cyclic_group_uniqueness-val"><b>finite_cyclic_group_uniqueness</b></a>]  Theorem
      
      ⊢ ∀g1 g2.
          cyclic g1 ∧ cyclic g2 ∧ FINITE g1.carrier ∧ FINITE g2.carrier ∧
          CARD g1.carrier = CARD g2.carrier ⇒
          ∃f. GroupIso f g1 g2
   
   [<a name="finite_cyclic_index_add-val"><b>finite_cyclic_index_add</b></a>]  Theorem
      
      ⊢ ∀g x y.
          cyclic g ∧ FINITE G ∧ x ∈ G ∧ y ∈ G ⇒
          cyclic_index g (x * y) =
          (cyclic_index g x + cyclic_index g y) MOD CARD G
   
   [<a name="finite_cyclic_index_property-val"><b>finite_cyclic_index_property</b></a>]  Theorem
      
      ⊢ ∀g. cyclic g ∧ FINITE G ⇒
            ∀n. n &lt; CARD G ⇒ cyclic_index g (cyclic_gen g ** n) = n
   
   [<a name="finite_cyclic_index_unique-val"><b>finite_cyclic_index_unique</b></a>]  Theorem
      
      ⊢ ∀g x.
          cyclic g ∧ FINITE G ∧ x ∈ G ⇒
          ∀n. n &lt; CARD G ⇒ (x = cyclic_gen g ** n ⇔ n = cyclic_index g x)
   
   [<a name="finite_group_Fermat-val"><b>finite_group_Fermat</b></a>]  Theorem
      
      ⊢ ∀g a. FiniteGroup g ∧ a ∈ G ⇒ a ** CARD G = #e
   
   [<a name="finite_group_card_pos-val"><b>finite_group_card_pos</b></a>]  Theorem
      
      ⊢ ∀g. FiniteGroup g ⇒ 0 &lt; CARD G
   
   [<a name="finite_group_exp_not_distinct-val"><b>finite_group_exp_not_distinct</b></a>]  Theorem
      
      ⊢ ∀g. FiniteGroup g ⇒ ∀x. x ∈ G ⇒ ∃h k. x ** h = x ** k ∧ h ≠ k
   
   [<a name="finite_group_exp_period_exists-val"><b>finite_group_exp_period_exists</b></a>]  Theorem
      
      ⊢ ∀g. FiniteGroup g ⇒ ∀x. x ∈ G ⇒ ∃k. 0 &lt; k ∧ x ** k = #e
   
   [<a name="finite_group_is_finite_monoid-val"><b>finite_group_is_finite_monoid</b></a>]  Theorem
      
      ⊢ ∀g. FiniteGroup g ⇒ FiniteMonoid g
   
   [<a name="finite_group_is_group-val"><b>finite_group_is_group</b></a>]  Theorem
      
      ⊢ ∀g. FiniteGroup g ⇒ Group g
   
   [<a name="finite_group_is_monoid-val"><b>finite_group_is_monoid</b></a>]  Theorem
      
      ⊢ ∀g. FiniteGroup g ⇒ Monoid g
   
   [<a name="finite_group_order-val"><b>finite_group_order</b></a>]  Theorem
      
      ⊢ ∀g. FiniteGroup g ⇒
            ∀x. x ∈ G ⇒
                ∀n. ord x = n ⇒
                    0 &lt; n ∧ x ** n = #e ∧ ∀m. 0 &lt; m ∧ m &lt; n ⇒ x ** m ≠ #e
   
   [<a name="finite_group_primitive_property-val"><b>finite_group_primitive_property</b></a>]  Theorem
      
      ⊢ ∀g. FiniteGroup g ⇒
            ∀z. z ∈ G ∧ ord z = CARD G ⇒
                ∀x. x ∈ G ⇒ ∃n. n &lt; CARD G ∧ x = z ** n
   
   [<a name="finite_homo_image-val"><b>finite_homo_image</b></a>]  Theorem
      
      ⊢ ∀f g1 g2 h.
          FiniteGroup g1 ∧ Group g2 ∧ h ≤ g2 ∧ GroupHomo f g1 g2 ⇒
          FINITE
            (homo_image f (preimage_group f g1 g2 h.carrier) g2).carrier
   
   [<a name="finite_monoid_invertibles_is_finite_group-val"><b>finite_monoid_invertibles_is_finite_group</b></a>]  Theorem
      
      ⊢ ∀g. FiniteMonoid g ⇒ FiniteGroup (Invertibles g)
   
   [<a name="finite_subgroup_carrier_finite-val"><b>finite_subgroup_carrier_finite</b></a>]  Theorem
      
      ⊢ ∀g. FiniteGroup g ⇒ ∀h. h ≤ g ⇒ FINITE H
   
   [<a name="finite_subgroup_finite_group-val"><b>finite_subgroup_finite_group</b></a>]  Theorem
      
      ⊢ ∀g. FiniteGroup g ⇒ ∀h. h ≤ g ⇒ FiniteGroup h
   
   [<a name="fixed_points_element-val"><b>fixed_points_element</b></a>]  Theorem
      
      ⊢ ∀f g X x. x ∈ fixed_points f g X ⇔ x ∈ X ∧ ∀a. a ∈ G ⇒ f a x = x
   
   [<a name="fixed_points_element_element-val"><b>fixed_points_element_element</b></a>]  Theorem
      
      ⊢ ∀f g X x. x ∈ fixed_points f g X ⇒ x ∈ X
   
   [<a name="fixed_points_finite-val"><b>fixed_points_finite</b></a>]  Theorem
      
      ⊢ ∀f g X. FINITE X ⇒ FINITE (fixed_points f g X)
   
   [<a name="fixed_points_orbit_iff_sing-val"><b>fixed_points_orbit_iff_sing</b></a>]  Theorem
      
      ⊢ ∀f g X.
          Group g ∧ (g act X) f ⇒
          ∀x. x ∈ X ⇒ (x ∈ fixed_points f g X ⇔ SING (orbit f g x))
   
   [<a name="fixed_points_orbit_sing-val"><b>fixed_points_orbit_sing</b></a>]  Theorem
      
      ⊢ ∀f g X.
          Group g ∧ (g act X) f ⇒
          ∀x. x ∈ fixed_points f g X ⇔ x ∈ X ∧ orbit f g x = {x}
   
   [<a name="fixed_points_subset-val"><b>fixed_points_subset</b></a>]  Theorem
      
      ⊢ ∀f g X. fixed_points f g X ⊆ X
   
   [<a name="fn_cyclic_group_alt-val"><b>fn_cyclic_group_alt</b></a>]  Theorem
      
      ⊢ ∀e f n.
          (∃k. k ≠ 0 ∧ FUNPOW f k e = e) ∧
          n = (LEAST k. k ≠ 0 ∧ FUNPOW f k e = e) ⇒
          (fn_cyclic_group e f).carrier = {FUNPOW f k e | k &lt; n} ∧
          (fn_cyclic_group e f).id = e ∧
          ∀i j.
            (fn_cyclic_group e f).op (FUNPOW f i e) (FUNPOW f j e) =
            FUNPOW f ((i + j) MOD n) e
   
   [<a name="fn_cyclic_group_carrier-val"><b>fn_cyclic_group_carrier</b></a>]  Theorem
      
      ⊢ ∀e f. (fn_cyclic_group e f).carrier = {x | ∃n. FUNPOW f n e = x}
   
   [<a name="fn_cyclic_group_finite_abelian_group-val"><b>fn_cyclic_group_finite_abelian_group</b></a>]  Theorem
      
      ⊢ ∀e f.
          (∃n. n ≠ 0 ∧ FUNPOW f n e = e) ⇒
          FiniteAbelianGroup (fn_cyclic_group e f)
   
   [<a name="fn_cyclic_group_finite_group-val"><b>fn_cyclic_group_finite_group</b></a>]  Theorem
      
      ⊢ ∀e f.
          (∃n. n ≠ 0 ∧ FUNPOW f n e = e) ⇒
          FiniteGroup (fn_cyclic_group e f)
   
   [<a name="fn_cyclic_group_group-val"><b>fn_cyclic_group_group</b></a>]  Theorem
      
      ⊢ ∀e f. (∃n. n ≠ 0 ∧ FUNPOW f n e = e) ⇒ Group (fn_cyclic_group e f)
   
   [<a name="fn_cyclic_group_id-val"><b>fn_cyclic_group_id</b></a>]  Theorem
      
      ⊢ ∀e f. (fn_cyclic_group e f).id = e
   
   [<a name="generated_Fermat-val"><b>generated_Fermat</b></a>]  Theorem
      
      ⊢ ∀g a.
          FiniteGroup g ∧ a ∈ G ⇒ ∀x. x ∈ Gen a ⇒ x ** CARD (Gen a) = #e
   
   [<a name="generated_carrier-val"><b>generated_carrier</b></a>]  Theorem
      
      ⊢ ∀g a. a ∈ G ⇒ Gen a = IMAGE ($** a) 𝕌(:num)
   
   [<a name="generated_carrier_as_image-val"><b>generated_carrier_as_image</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀a. a ∈ G ∧ 0 &lt; ord a ⇒
                Gen a = IMAGE (λj. a ** j) (count (ord a))
   
   [<a name="generated_carrier_has_id-val"><b>generated_carrier_has_id</b></a>]  Theorem
      
      ⊢ ∀g a. #e ∈ Gen a
   
   [<a name="generated_element-val"><b>generated_element</b></a>]  Theorem
      
      ⊢ ∀g a x. x ∈ Gen a ⇔ ∃n. x = a ** n
   
   [<a name="generated_exp-val"><b>generated_exp</b></a>]  Theorem
      
      ⊢ ∀g a z. a ∈ G ∧ z ∈ Gen a ⇒ ∀n. (gen a).exp z n = z ** n
   
   [<a name="generated_finite_group-val"><b>generated_finite_group</b></a>]  Theorem
      
      ⊢ ∀g a. FiniteGroup g ∧ a ∈ G ⇒ FiniteGroup (gen a)
   
   [<a name="generated_gen_element-val"><b>generated_gen_element</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ x ∈ Gen x
   
   [<a name="generated_group-val"><b>generated_group</b></a>]  Theorem
      
      ⊢ ∀g a. FiniteGroup g ∧ a ∈ G ⇒ Group (gen a)
   
   [<a name="generated_group_card-val"><b>generated_group_card</b></a>]  Theorem
      
      ⊢ ∀g a. Group g ∧ a ∈ G ∧ 0 &lt; ord a ⇒ CARD (Gen a) = ord a
   
   [<a name="generated_group_finite-val"><b>generated_group_finite</b></a>]  Theorem
      
      ⊢ ∀g a. FiniteGroup g ∧ a ∈ G ⇒ FINITE (Gen a)
   
   [<a name="generated_id_carrier-val"><b>generated_id_carrier</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ Gen #e = {#e}
   
   [<a name="generated_id_subgroup-val"><b>generated_id_subgroup</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ gen #e ≤ g
   
   [<a name="generated_image_subset_all_subgroups-val"><b>generated_image_subset_all_subgroups</b></a>]  Theorem
      
      ⊢ ∀g. FiniteGroup g ⇒ ∀s. s ⊆ G ⇒ IMAGE gen s ⊆ all_subgroups g
   
   [<a name="generated_image_subset_power_set-val"><b>generated_image_subset_power_set</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀s. s ⊆ G ⇒ IMAGE (λa. Gen a) s ⊆ POW G
   
   [<a name="generated_property-val"><b>generated_property</b></a>]  Theorem
      
      ⊢ ∀g a. (gen a).op = $* ∧ (gen a).id = #e
   
   [<a name="generated_subgroup-val"><b>generated_subgroup</b></a>]  Theorem
      
      ⊢ ∀g a. FiniteGroup g ∧ a ∈ G ⇒ gen a ≤ g
   
   [<a name="generated_subset-val"><b>generated_subset</b></a>]  Theorem
      
      ⊢ ∀g a. Group g ∧ a ∈ G ⇒ Gen a ⊆ G
   
   [<a name="group_all_invertible-val"><b>group_all_invertible</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ G* = G
   
   [<a name="group_alt-val"><b>group_alt</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇔
            (∀x y::G. x * y ∈ G) ∧ (∀x y z::G. x * y * z = x * (y * z)) ∧
            #e ∈ G ∧ (∀x::G. #e * x = x) ∧ ∀x::G. |/ x ∈ G ∧ |/ x * x = #e
   
   [<a name="group_assoc-val"><b>group_assoc</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀x y z. x ∈ G ∧ y ∈ G ∧ z ∈ G ⇒ x * y * z = x * (y * z)
   
   [<a name="group_auto_I-val"><b>group_auto_I</b></a>]  Theorem
      
      ⊢ ∀g. GroupAuto I g
   
   [<a name="group_auto_bij-val"><b>group_auto_bij</b></a>]  Theorem
      
      ⊢ ∀g f. GroupAuto f g ⇒ f PERMUTES G
   
   [<a name="group_auto_compose-val"><b>group_auto_compose</b></a>]  Theorem
      
      ⊢ ∀g f1 f2. GroupAuto f1 g ∧ GroupAuto f2 g ⇒ GroupAuto (f1 ∘ f2) g
   
   [<a name="group_auto_element-val"><b>group_auto_element</b></a>]  Theorem
      
      ⊢ ∀f g. GroupAuto f g ⇒ ∀x. x ∈ G ⇒ f x ∈ G
   
   [<a name="group_auto_exp-val"><b>group_auto_exp</b></a>]  Theorem
      
      ⊢ ∀g f.
          Group g ∧ GroupAuto f g ⇒ ∀x. x ∈ G ⇒ ∀n. f (x ** n) = f x ** n
   
   [<a name="group_auto_id-val"><b>group_auto_id</b></a>]  Theorem
      
      ⊢ ∀f g. Group g ∧ GroupAuto f g ⇒ f #e = #e
   
   [<a name="group_auto_is_monoid_auto-val"><b>group_auto_is_monoid_auto</b></a>]  Theorem
      
      ⊢ ∀g f. Group g ∧ GroupAuto f g ⇒ MonoidAuto f g
   
   [<a name="group_auto_linv_auto-val"><b>group_auto_linv_auto</b></a>]  Theorem
      
      ⊢ ∀g f. Group g ∧ GroupAuto f g ⇒ GroupAuto (LINV f G) g
   
   [<a name="group_auto_order-val"><b>group_auto_order</b></a>]  Theorem
      
      ⊢ ∀g f. Group g ∧ GroupAuto f g ⇒ ∀x. x ∈ G ⇒ ord (f x) = ord x
   
   [<a name="group_carrier_nonempty-val"><b>group_carrier_nonempty</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ G ≠ ∅
   
   [<a name="group_comm_exp-val"><b>group_comm_exp</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀x y.
              x ∈ G ∧ y ∈ G ⇒ x * y = y * x ⇒ ∀n. x ** n * y = y * x ** n
   
   [<a name="group_comm_exp_exp-val"><b>group_comm_exp_exp</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀x y.
              x ∈ G ∧ y ∈ G ∧ x * y = y * x ⇒
              ∀n m. x ** n * y ** m = y ** m * x ** n
   
   [<a name="group_comm_op_exp-val"><b>group_comm_op_exp</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀x y.
              x ∈ G ∧ y ∈ G ∧ x * y = y * x ⇒
              ∀n. (x * y) ** n = x ** n * y ** n
   
   [<a name="group_coset_eq_itself-val"><b>group_coset_eq_itself</b></a>]  Theorem
      
      ⊢ ∀g a. Group g ∧ a ∈ G ⇒ a * G = G
   
   [<a name="group_coset_is_permutation-val"><b>group_coset_is_permutation</b></a>]  Theorem
      
      ⊢ ∀g a. Group g ∧ a ∈ G ⇒ a * G = G
   
   [<a name="group_def_alt-val"><b>group_def_alt</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇔
            (∀x y. x ∈ G ∧ y ∈ G ⇒ x * y ∈ G) ∧
            (∀x y z. x ∈ G ∧ y ∈ G ∧ z ∈ G ⇒ x * y * z = x * (y * z)) ∧
            #e ∈ G ∧ (∀x. x ∈ G ⇒ #e * x = x) ∧
            ∀x. x ∈ G ⇒ ∃y. y ∈ G ∧ y * x = #e
   
   [<a name="group_def_by_inverse-val"><b>group_def_by_inverse</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇔ Monoid g ∧ ∀x. x ∈ G ⇒ ∃y. y ∈ G ∧ y * x = #e
   
   [<a name="group_div_cancel-val"><b>group_div_cancel</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ x / x = #e
   
   [<a name="group_div_element-val"><b>group_div_element</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ x / y ∈ G
   
   [<a name="group_div_lsame-val"><b>group_div_lsame</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀x y z.
              x ∈ G ∧ y ∈ G ∧ z ∈ G ⇒ z * x / (z * y) = z * (x / y) / z
   
   [<a name="group_div_pair-val"><b>group_div_pair</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀x1 y1 x2 y2.
              x1 ∈ G ∧ y1 ∈ G ∧ x2 ∈ G ∧ y2 ∈ G ⇒
              x1 * y1 / (x2 * y2) = x1 * (y1 / y2) / x1 * (x1 / x2)
   
   [<a name="group_div_rsame-val"><b>group_div_rsame</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀x y z. x ∈ G ∧ y ∈ G ∧ z ∈ G ⇒ x * z / (y * z) = x / y
   
   [<a name="group_excluding_exp-val"><b>group_excluding_exp</b></a>]  Theorem
      
      ⊢ ∀g z x n. (g excluding z).exp x n = x ** n
   
   [<a name="group_excluding_op-val"><b>group_excluding_op</b></a>]  Theorem
      
      ⊢ ∀g z. (g excluding z).op = $*
   
   [<a name="group_excluding_property-val"><b>group_excluding_property</b></a>]  Theorem
      
      ⊢ ∀g z.
          (g excluding z).op = $* ∧ (g excluding z).id = #e ∧
          ∀x. x ∈ (g excluding z).carrier ⇒ x ∈ G ∧ x ≠ z
   
   [<a name="group_exp_0-val"><b>group_exp_0</b></a>]  Theorem
      
      ⊢ ∀g x. x ** 0 = #e
   
   [<a name="group_exp_1-val"><b>group_exp_1</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ x ** 1 = x
   
   [<a name="group_exp_SUC-val"><b>group_exp_SUC</b></a>]  Theorem
      
      ⊢ ∀g x n. x ** SUC n = x * x ** n
   
   [<a name="group_exp_add-val"><b>group_exp_add</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ ∀n k. x ** (n + k) = x ** n * x ** k
   
   [<a name="group_exp_comm-val"><b>group_exp_comm</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ ∀n. x ** n * x = x * x ** n
   
   [<a name="group_exp_element-val"><b>group_exp_element</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ ∀n. x ** n ∈ G
   
   [<a name="group_exp_eq-val"><b>group_exp_eq</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀x. x ∈ G ⇒ ∀m n. m &lt; n ∧ x ** m = x ** n ⇒ x ** (n − m) = #e
   
   [<a name="group_exp_eq_condition-val"><b>group_exp_eq_condition</b></a>]  Theorem
      
      ⊢ ∀g x.
          Group g ∧ x ∈ G ∧ 0 &lt; ord x ⇒
          ∀n m. x ** n = x ** m ⇔ n MOD ord x = m MOD ord x
   
   [<a name="group_exp_equal-val"><b>group_exp_equal</b></a>]  Theorem
      
      ⊢ ∀g x.
          Group g ∧ x ∈ G ⇒
          ∀n m. n &lt; ord x ∧ m &lt; ord x ∧ x ** n = x ** m ⇒ n = m
   
   [<a name="group_exp_inv-val"><b>group_exp_inv</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ ∀n. |/ (x ** n) = |/ x ** n
   
   [<a name="group_exp_mod-val"><b>group_exp_mod</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀x. x ∈ G ∧ 0 &lt; ord x ⇒ ∀n. x ** n = x ** (n MOD ord x)
   
   [<a name="group_exp_mod_order-val"><b>group_exp_mod_order</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀x. x ∈ G ∧ 0 &lt; ord x ⇒ ∀n. x ** n = x ** (n MOD ord x)
   
   [<a name="group_exp_mult-val"><b>group_exp_mult</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ ∀n k. x ** (n * k) = (x ** n) ** k
   
   [<a name="group_exp_mult_comm-val"><b>group_exp_mult_comm</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ ∀m n. (x ** m) ** n = (x ** n) ** m
   
   [<a name="group_exp_suc-val"><b>group_exp_suc</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ ∀n. x ** SUC n = x ** n * x
   
   [<a name="group_first_isomorphism_thm-val"><b>group_first_isomorphism_thm</b></a>]  Theorem
      
      ⊢ ∀g h f.
          Group g ∧ Group h ∧ GroupHomo f g h ⇒
          kernel_group f g h &lt;&lt; g ∧ homo_image f g h ≤ h ∧
          GroupIso (λz. CHOICE (preimage f G z) * kernel f g h)
            (homo_image f g h) (g / kernel_group f g h) ∧
          (SURJ f G h.carrier ⇒ GroupIso I h (homo_image f g h))
   
   [<a name="group_homo_I_refl-val"><b>group_homo_I_refl</b></a>]  Theorem
      
      ⊢ ∀g. GroupHomo I g g
   
   [<a name="group_homo_compose-val"><b>group_homo_compose</b></a>]  Theorem
      
      ⊢ ∀g h k f1 f2.
          GroupHomo f1 g h ∧ GroupHomo f2 h k ⇒ GroupHomo (f2 ∘ f1) g k
   
   [<a name="group_homo_cong-val"><b>group_homo_cong</b></a>]  Theorem
      
      ⊢ ∀g h f1 f2.
          Group g ∧ Group h ∧ (∀x. x ∈ G ⇒ f1 x = f2 x) ⇒
          (GroupHomo f1 g h ⇔ GroupHomo f2 g h)
   
   [<a name="group_homo_element-val"><b>group_homo_element</b></a>]  Theorem
      
      ⊢ ∀f g h. GroupHomo f g h ⇒ ∀x. x ∈ G ⇒ f x ∈ h.carrier
   
   [<a name="group_homo_exp-val"><b>group_homo_exp</b></a>]  Theorem
      
      ⊢ ∀g h f.
          Group g ∧ Group h ∧ GroupHomo f g h ⇒
          ∀x. x ∈ G ⇒ ∀n. f (x ** n) = h.exp (f x) n
   
   [<a name="group_homo_homo_image_group-val"><b>group_homo_homo_image_group</b></a>]  Theorem
      
      ⊢ ∀g h f. Group g ∧ MonoidHomo f g h ⇒ Group (homo_image f g h)
   
   [<a name="group_homo_id-val"><b>group_homo_id</b></a>]  Theorem
      
      ⊢ ∀f g h. Group g ∧ Group h ∧ GroupHomo f g h ⇒ f #e = h.id
   
   [<a name="group_homo_image_surj_property-val"><b>group_homo_image_surj_property</b></a>]  Theorem
      
      ⊢ ∀g h f.
          Group g ∧ Group h ∧ SURJ f G h.carrier ⇒
          GroupIso I h (homo_image f g h)
   
   [<a name="group_homo_inv-val"><b>group_homo_inv</b></a>]  Theorem
      
      ⊢ ∀f g h.
          Group g ∧ Group h ∧ GroupHomo f g h ⇒
          ∀x. x ∈ G ⇒ f ( |/ x) = h.inv (f x)
   
   [<a name="group_homo_is_monoid_homo-val"><b>group_homo_is_monoid_homo</b></a>]  Theorem
      
      ⊢ ∀g h f. Group g ∧ Group h ∧ GroupHomo f g h ⇒ MonoidHomo f g h
   
   [<a name="group_homo_monoid_homo-val"><b>group_homo_monoid_homo</b></a>]  Theorem
      
      ⊢ ∀f g h. GroupHomo f g h ∧ f #e = h.id ⇔ MonoidHomo f g h
   
   [<a name="group_homo_sym-val"><b>group_homo_sym</b></a>]  Theorem
      
      ⊢ ∀g h f.
          Group g ∧ GroupHomo f g h ∧ BIJ f G h.carrier ⇒
          GroupHomo (LINV f G) h g
   
   [<a name="group_homo_sym_any-val"><b>group_homo_sym_any</b></a>]  Theorem
      
      ⊢ Group g ∧ GroupHomo f g h ∧
        (∀x. x ∈ h.carrier ⇒ i x ∈ G ∧ f (i x) = x) ∧
        (∀x. x ∈ G ⇒ i (f x) = x) ⇒
        GroupHomo i h g
   
   [<a name="group_homo_trans-val"><b>group_homo_trans</b></a>]  Theorem
      
      ⊢ ∀g h k f1 f2.
          GroupHomo f1 g h ∧ GroupHomo f2 h k ⇒ GroupHomo (f2 ∘ f1) g k
   
   [<a name="group_id-val"><b>group_id</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ #e * x = x ∧ x * #e = x
   
   [<a name="group_id_element-val"><b>group_id_element</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ #e ∈ G
   
   [<a name="group_id_exp-val"><b>group_id_exp</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀n. #e ** n = #e
   
   [<a name="group_id_fix-val"><b>group_id_fix</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ (x * x = x ⇔ x = #e)
   
   [<a name="group_id_id-val"><b>group_id_id</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ #e * #e = #e
   
   [<a name="group_id_unique-val"><b>group_id_unique</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀x y.
              x ∈ G ∧ y ∈ G ⇒ (y * x = x ⇔ y = #e) ∧ (x * y = x ⇔ y = #e)
   
   [<a name="group_image_as_op_image-val"><b>group_image_as_op_image</b></a>]  Theorem
      
      ⊢ ∀g. GPI = OP_IMAGE $* #e
   
   [<a name="group_image_empty-val"><b>group_image_empty</b></a>]  Theorem
      
      ⊢ ∀g f. GPI f ∅ = #e
   
   [<a name="group_image_sing-val"><b>group_image_sing</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ ∀f. gfun f ⇒ ∀x. x ∈ G ⇒ GPI f {x} = f x
   
   [<a name="group_including_excluding_abelian-val"><b>group_including_excluding_abelian</b></a>]  Theorem
      
      ⊢ ∀g z.
          z ∉ G ⇒
          (AbelianGroup g ⇔ AbelianGroup (g including z excluding z))
   
   [<a name="group_including_excluding_eqn-val"><b>group_including_excluding_eqn</b></a>]  Theorem
      
      ⊢ ∀g z.
          g including z excluding z =
          if z ∈ G then &lt;|carrier := G DELETE z; op := $*; id := #e|&gt;
          else g
   
   [<a name="group_including_excluding_group-val"><b>group_including_excluding_group</b></a>]  Theorem
      
      ⊢ ∀g z. z ∉ G ⇒ (Group g ⇔ Group (g including z excluding z))
   
   [<a name="group_including_excluding_property-val"><b>group_including_excluding_property</b></a>]  Theorem
      
      ⊢ ∀g z.
          (g including z excluding z).op = $* ∧
          (g including z excluding z).id = #e ∧
          (z ∉ G ⇒ (g including z excluding z).carrier = G)
   
   [<a name="group_including_property-val"><b>group_including_property</b></a>]  Theorem
      
      ⊢ ∀g z.
          (g including z).op = $* ∧ (g including z).id = #e ∧
          ∀x. x ∈ (g including z).carrier ⇒ x ∈ G ∨ x = z
   
   [<a name="group_inj_image_abelian_group-val"><b>group_inj_image_abelian_group</b></a>]  Theorem
      
      ⊢ ∀g f.
          AbelianGroup g ∧ INJ f G 𝕌(:β) ⇒
          AbelianGroup (monoid_inj_image g f)
   
   [<a name="group_inj_image_excluding_abelian_group-val"><b>group_inj_image_excluding_abelian_group</b></a>]  Theorem
      
      ⊢ ∀g f e.
          AbelianGroup (g excluding e) ∧ INJ f G 𝕌(:β) ∧ e ∈ G ⇒
          AbelianGroup (monoid_inj_image g f excluding f e)
   
   [<a name="group_inj_image_excluding_group-val"><b>group_inj_image_excluding_group</b></a>]  Theorem
      
      ⊢ ∀g f e.
          Group (g excluding e) ∧ INJ f G 𝕌(:β) ∧ e ∈ G ⇒
          Group (monoid_inj_image g f excluding f e)
   
   [<a name="group_inj_image_group-val"><b>group_inj_image_group</b></a>]  Theorem
      
      ⊢ ∀g f. Group g ∧ INJ f G 𝕌(:β) ⇒ Group (monoid_inj_image g f)
   
   [<a name="group_inj_image_group_homo-val"><b>group_inj_image_group_homo</b></a>]  Theorem
      
      ⊢ ∀g f. INJ f G 𝕌(:β) ⇒ GroupHomo f g (monoid_inj_image g f)
   
   [<a name="group_inv_element-val"><b>group_inv_element</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ |/ x ∈ G
   
   [<a name="group_inv_eq-val"><b>group_inv_eq</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ ( |/ x = |/ y ⇔ x = y)
   
   [<a name="group_inv_eq_id-val"><b>group_inv_eq_id</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ ( |/ x = #e ⇔ x = #e)
   
   [<a name="group_inv_eq_swap-val"><b>group_inv_eq_swap</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ ( |/ x = y ⇔ x = |/ y)
   
   [<a name="group_inv_exp-val"><b>group_inv_exp</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ ∀n. |/ x ** n = |/ (x ** n)
   
   [<a name="group_inv_id-val"><b>group_inv_id</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ |/ #e = #e
   
   [<a name="group_inv_inv-val"><b>group_inv_inv</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ |/ ( |/ x) = x
   
   [<a name="group_inv_op-val"><b>group_inv_op</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ |/ (x * y) = |/ y * |/ x
   
   [<a name="group_inv_order-val"><b>group_inv_order</b></a>]  Theorem
      
      ⊢ ∀g x. Group g ∧ x ∈ G ⇒ ord ( |/ x) = ord x
   
   [<a name="group_inv_thm-val"><b>group_inv_thm</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ x * |/ x = #e ∧ |/ x * x = #e
   
   [<a name="group_is_monoid-val"><b>group_is_monoid</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ Monoid g
   
   [<a name="group_iso_I_refl-val"><b>group_iso_I_refl</b></a>]  Theorem
      
      ⊢ ∀g. GroupIso I g g
   
   [<a name="group_iso_bij-val"><b>group_iso_bij</b></a>]  Theorem
      
      ⊢ ∀g h f. GroupIso f g h ⇒ BIJ f G h.carrier
   
   [<a name="group_iso_card_eq-val"><b>group_iso_card_eq</b></a>]  Theorem
      
      ⊢ ∀g h f. GroupIso f g h ∧ FINITE G ⇒ CARD G = CARD h.carrier
   
   [<a name="group_iso_compose-val"><b>group_iso_compose</b></a>]  Theorem
      
      ⊢ ∀g h k f1 f2.
          GroupIso f1 g h ∧ GroupIso f2 h k ⇒ GroupIso (f2 ∘ f1) g k
   
   [<a name="group_iso_element-val"><b>group_iso_element</b></a>]  Theorem
      
      ⊢ ∀f g h. GroupIso f g h ⇒ ∀x. x ∈ G ⇒ f x ∈ h.carrier
   
   [<a name="group_iso_exp-val"><b>group_iso_exp</b></a>]  Theorem
      
      ⊢ ∀g h f.
          Group g ∧ Group h ∧ GroupIso f g h ⇒
          ∀x. x ∈ G ⇒ ∀n. f (x ** n) = h.exp (f x) n
   
   [<a name="group_iso_group-val"><b>group_iso_group</b></a>]  Theorem
      
      ⊢ ∀g h f. Group g ∧ GroupIso f g h ∧ f #e = h.id ⇒ Group h
   
   [<a name="group_iso_id-val"><b>group_iso_id</b></a>]  Theorem
      
      ⊢ ∀f g h. Group g ∧ Group h ∧ GroupIso f g h ⇒ f #e = h.id
   
   [<a name="group_iso_is_monoid_iso-val"><b>group_iso_is_monoid_iso</b></a>]  Theorem
      
      ⊢ ∀g h f. Group g ∧ Group h ∧ GroupIso f g h ⇒ MonoidIso f g h
   
   [<a name="group_iso_linv_iso-val"><b>group_iso_linv_iso</b></a>]  Theorem
      
      ⊢ ∀g h f. Group g ∧ GroupIso f g h ⇒ GroupIso (LINV f G) h g
   
   [<a name="group_iso_monoid_iso-val"><b>group_iso_monoid_iso</b></a>]  Theorem
      
      ⊢ ∀f g h. GroupIso f g h ∧ f #e = h.id ⇔ MonoidIso f g h
   
   [<a name="group_iso_order-val"><b>group_iso_order</b></a>]  Theorem
      
      ⊢ ∀g h f.
          Group g ∧ Group h ∧ GroupIso f g h ⇒
          ∀x. x ∈ G ⇒ order h (f x) = ord x
   
   [<a name="group_iso_property-val"><b>group_iso_property</b></a>]  Theorem
      
      ⊢ ∀f g h.
          GroupIso f g h ⇔
          GroupHomo f g h ∧ ∀y. y ∈ h.carrier ⇒ ∃!x. x ∈ G ∧ f x = y
   
   [<a name="group_iso_sym-val"><b>group_iso_sym</b></a>]  Theorem
      
      ⊢ ∀g h f. Group g ∧ GroupIso f g h ⇒ GroupIso (LINV f G) h g
   
   [<a name="group_iso_trans-val"><b>group_iso_trans</b></a>]  Theorem
      
      ⊢ ∀g h k f1 f2.
          GroupIso f1 g h ∧ GroupIso f2 h k ⇒ GroupIso (f2 ∘ f1) g k
   
   [<a name="group_lcancel-val"><b>group_lcancel</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀x y z. x ∈ G ∧ y ∈ G ∧ z ∈ G ⇒ (x * y = x * z ⇔ y = z)
   
   [<a name="group_lid-val"><b>group_lid</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ #e * x = x
   
   [<a name="group_lid_unique-val"><b>group_lid_unique</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ (y * x = x ⇔ y = #e)
   
   [<a name="group_linv-val"><b>group_linv</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ |/ x * x = #e
   
   [<a name="group_linv_assoc-val"><b>group_linv_assoc</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀x y. x ∈ G ∧ y ∈ G ⇒ y = x * ( |/ x * y) ∧ y = |/ x * (x * y)
   
   [<a name="group_linv_unique-val"><b>group_linv_unique</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ (x * y = #e ⇔ x = |/ y)
   
   [<a name="group_lsolve-val"><b>group_lsolve</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀x y z. x ∈ G ∧ y ∈ G ∧ z ∈ G ⇒ (x * y = z ⇔ x = z * |/ y)
   
   [<a name="group_normal_equiv-val"><b>group_normal_equiv</b></a>]  Theorem
      
      ⊢ ∀g h. h &lt;&lt; g ⇒ $== equiv_on G
   
   [<a name="group_normal_equiv_property-val"><b>group_normal_equiv_property</b></a>]  Theorem
      
      ⊢ ∀h g. h &lt;&lt; g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ (x == y ⇔ x ∈ y * H)
   
   [<a name="group_normal_equiv_reflexive-val"><b>group_normal_equiv_reflexive</b></a>]  Theorem
      
      ⊢ ∀g h. h &lt;&lt; g ⇒ ∀z. z ∈ G ⇒ z == z
   
   [<a name="group_normal_equiv_symmetric-val"><b>group_normal_equiv_symmetric</b></a>]  Theorem
      
      ⊢ ∀g h. h &lt;&lt; g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ (x == y ⇔ y == x)
   
   [<a name="group_normal_equiv_transitive-val"><b>group_normal_equiv_transitive</b></a>]  Theorem
      
      ⊢ ∀g h.
          h &lt;&lt; g ⇒ ∀x y z. x ∈ G ∧ y ∈ G ∧ z ∈ G ⇒ x == y ∧ y == z ⇒ x == z
   
   [<a name="group_op_element-val"><b>group_op_element</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ x * y ∈ G
   
   [<a name="group_op_linv_eq_id-val"><b>group_op_linv_eq_id</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ ( |/ x * y = #e ⇔ x = y)
   
   [<a name="group_op_linv_eqn-val"><b>group_op_linv_eqn</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀x y z. x ∈ G ∧ y ∈ G ∧ z ∈ G ⇒ ( |/ x * y = z ⇔ y = x * z)
   
   [<a name="group_op_rinv_eq_id-val"><b>group_op_rinv_eq_id</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ (x * |/ y = #e ⇔ x = y)
   
   [<a name="group_op_rinv_eqn-val"><b>group_op_rinv_eqn</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀x y z. x ∈ G ∧ y ∈ G ∧ z ∈ G ⇒ (x * |/ y = z ⇔ x = z * y)
   
   [<a name="group_order_cofactor-val"><b>group_order_cofactor</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀x n.
              x ∈ G ∧ 0 &lt; ord x ∧ n divides ord x ⇒
              ord (x ** (ord x DIV n)) = n
   
   [<a name="group_order_common-val"><b>group_order_common</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀x y.
              x ∈ G ∧ y ∈ G ∧ x * y = y * x ⇒
              ∃z. z ∈ G ∧ ord z * gcd (ord x) (ord y) = lcm (ord x) (ord y)
   
   [<a name="group_order_common_coprime-val"><b>group_order_common_coprime</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀x y.
              x ∈ G ∧ y ∈ G ∧ x * y = y * x ∧ coprime (ord x) (ord y) ⇒
              ∃z. z ∈ G ∧ ord z = ord x * ord y
   
   [<a name="group_order_condition-val"><b>group_order_condition</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ ∀m. x ** m = #e ⇔ ord x divides m
   
   [<a name="group_order_divides-val"><b>group_order_divides</b></a>]  Theorem
      
      ⊢ ∀g. FiniteGroup g ⇒ ∀x. x ∈ G ⇒ ord x divides CARD G
   
   [<a name="group_order_divides_exp-val"><b>group_order_divides_exp</b></a>]  Theorem
      
      ⊢ ∀g x. Group g ∧ x ∈ G ⇒ ∀n. x ** n = #e ⇔ ord x divides n
   
   [<a name="group_order_divides_maximal-val"><b>group_order_divides_maximal</b></a>]  Theorem
      
      ⊢ ∀g. FiniteAbelianGroup g ⇒
            ∀x. x ∈ G ⇒ ord x divides maximal_order g
   
   [<a name="group_order_divisor-val"><b>group_order_divisor</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀x m.
              x ∈ G ∧ 0 &lt; ord x ∧ m divides ord x ⇒ ∃y. y ∈ G ∧ ord y = m
   
   [<a name="group_order_eq_1-val"><b>group_order_eq_1</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ (ord x = 1 ⇔ x = #e)
   
   [<a name="group_order_exp_cofactor-val"><b>group_order_exp_cofactor</b></a>]  Theorem
      
      ⊢ ∀g x n.
          Group g ∧ x ∈ G ∧ 0 &lt; ord x ∧ n divides ord x ⇒
          ord (x ** (ord x DIV n)) = n
   
   [<a name="group_order_id-val"><b>group_order_id</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ord #e = 1
   
   [<a name="group_order_inv-val"><b>group_order_inv</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x. x ∈ G ∧ 0 &lt; ord x ⇒ |/ x = x ** (ord x − 1)
   
   [<a name="group_order_nonzero-val"><b>group_order_nonzero</b></a>]  Theorem
      
      ⊢ ∀g. FiniteGroup g ⇒ ∀x. x ∈ G ⇒ ord x ≠ 0
   
   [<a name="group_order_pos-val"><b>group_order_pos</b></a>]  Theorem
      
      ⊢ ∀g. FiniteGroup g ⇒ ∀x. x ∈ G ⇒ 0 &lt; ord x
   
   [<a name="group_order_power-val"><b>group_order_power</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ ∀k. ord (x ** k) * gcd (ord x) k = ord x
   
   [<a name="group_order_power_coprime-val"><b>group_order_power_coprime</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀x. x ∈ G ⇒ ∀n. coprime n (ord x) ⇒ ord (x ** n) = ord x
   
   [<a name="group_order_power_eq_0-val"><b>group_order_power_eq_0</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ ∀k. ord (x ** k) = 0 ⇔ 0 &lt; k ∧ ord x = 0
   
   [<a name="group_order_power_eq_order-val"><b>group_order_power_eq_order</b></a>]  Theorem
      
      ⊢ ∀g x.
          Group g ∧ x ∈ G ∧ 0 &lt; ord x ⇒
          ∀k. ord (x ** k) = ord x ⇔ coprime k (ord x)
   
   [<a name="group_order_power_eqn-val"><b>group_order_power_eqn</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀x k. x ∈ G ∧ 0 &lt; k ⇒ ord (x ** k) = ord x DIV gcd k (ord x)
   
   [<a name="group_order_property-val"><b>group_order_property</b></a>]  Theorem
      
      ⊢ ∀g. FiniteGroup g ⇒ ∀x. x ∈ G ⇒ 0 &lt; ord x ∧ x ** ord x = #e
   
   [<a name="group_order_thm-val"><b>group_order_thm</b></a>]  Theorem
      
      ⊢ ∀g n.
          0 &lt; n ⇒
          ∀x. ord x = n ⇔ x ** n = #e ∧ ∀m. 0 &lt; m ∧ m &lt; n ⇒ x ** m ≠ #e
   
   [<a name="group_order_to_generated_bij-val"><b>group_order_to_generated_bij</b></a>]  Theorem
      
      ⊢ ∀g a.
          Group g ∧ a ∈ G ∧ 0 &lt; ord a ⇒
          BIJ (λn. a ** n) (count (ord a)) (Gen a)
   
   [<a name="group_order_unique-val"><b>group_order_unique</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀x. x ∈ G ⇒
                ∀m n. m &lt; ord x ∧ n &lt; ord x ∧ x ** m = x ** n ⇒ m = n
   
   [<a name="group_orders_eq_1-val"><b>group_orders_eq_1</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ orders g 1 = {#e}
   
   [<a name="group_pair_reduce-val"><b>group_pair_reduce</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀x y z. x ∈ G ∧ y ∈ G ∧ z ∈ G ⇒ x * z * |/ (y * z) = x * |/ y
   
   [<a name="group_rcancel-val"><b>group_rcancel</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀x y z. x ∈ G ∧ y ∈ G ∧ z ∈ G ⇒ (y * x = z * x ⇔ y = z)
   
   [<a name="group_rid-val"><b>group_rid</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ x * #e = x
   
   [<a name="group_rid_unique-val"><b>group_rid_unique</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ (x * y = x ⇔ y = #e)
   
   [<a name="group_rinv-val"><b>group_rinv</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ x * |/ x = #e
   
   [<a name="group_rinv_assoc-val"><b>group_rinv_assoc</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀x y. x ∈ G ∧ y ∈ G ⇒ y = y * |/ x * x ∧ y = y * x * |/ x
   
   [<a name="group_rinv_unique-val"><b>group_rinv_unique</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ (x * y = #e ⇔ y = |/ x)
   
   [<a name="group_rsolve-val"><b>group_rsolve</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀x y z. x ∈ G ∧ y ∈ G ∧ z ∈ G ⇒ (x * y = z ⇔ y = |/ x * z)
   
   [<a name="group_uroots_group-val"><b>group_uroots_group</b></a>]  Theorem
      
      ⊢ ∀g. AbelianGroup g ⇒ ∀n. Group (uroots n)
   
   [<a name="group_uroots_has_id-val"><b>group_uroots_has_id</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀n. #e ∈ (uroots n).carrier
   
   [<a name="group_uroots_subgroup-val"><b>group_uroots_subgroup</b></a>]  Theorem
      
      ⊢ ∀g. AbelianGroup g ⇒ ∀n. uroots n ≤ g
   
   [<a name="homo_count_formula-val"><b>homo_count_formula</b></a>]  Theorem
      
      ⊢ ∀f g1 g2 h.
          FiniteGroup g1 ∧ Group g2 ∧ h ≤ g2 ∧ GroupHomo f g1 g2 ⇒
          CARD (preimage_group f g1 g2 h.carrier).carrier =
          CARD
            (kernel_group f (preimage_group f g1 g2 h.carrier) g2).carrier *
          CARD
            (preimage_group f g1 g2 h.carrier /
             kernel_group f (preimage_group f g1 g2 h.carrier) g2).carrier
   
   [<a name="homo_group_abelian_group-val"><b>homo_group_abelian_group</b></a>]  Theorem
      
      ⊢ ∀g f.
          AbelianGroup g ∧ GroupHomo f g (homo_group g f) ⇒
          AbelianGroup (homo_group g f)
   
   [<a name="homo_group_assoc-val"><b>homo_group_assoc</b></a>]  Theorem
      
      ⊢ ∀g f.
          Group g ∧ GroupHomo f g (homo_group g f) ⇒
          ∀x y z. x ∈ fG ∧ y ∈ fG ∧ z ∈ fG ⇒ (x ∘ y) ∘ z = x ∘ y ∘ z
   
   [<a name="homo_group_by_inj-val"><b>homo_group_by_inj</b></a>]  Theorem
      
      ⊢ ∀g f. Group g ∧ INJ f G 𝕌(:β) ⇒ GroupHomo f g (homo_group g f)
   
   [<a name="homo_group_closure-val"><b>homo_group_closure</b></a>]  Theorem
      
      ⊢ ∀g f.
          Group g ∧ GroupHomo f g (homo_group g f) ⇒
          ∀x y. x ∈ fG ∧ y ∈ fG ⇒ x ∘ y ∈ fG
   
   [<a name="homo_group_comm-val"><b>homo_group_comm</b></a>]  Theorem
      
      ⊢ ∀g f.
          AbelianGroup g ∧ GroupHomo f g (homo_group g f) ⇒
          ∀x y. x ∈ fG ∧ y ∈ fG ⇒ x ∘ y = y ∘ x
   
   [<a name="homo_group_group-val"><b>homo_group_group</b></a>]  Theorem
      
      ⊢ ∀g f.
          Group g ∧ GroupHomo f g (homo_group g f) ⇒ Group (homo_group g f)
   
   [<a name="homo_group_id-val"><b>homo_group_id</b></a>]  Theorem
      
      ⊢ ∀g f.
          Group g ∧ GroupHomo f g (homo_group g f) ⇒
          #i ∈ fG ∧ ∀x. x ∈ fG ⇒ #i ∘ x = x ∧ x ∘ #i = x
   
   [<a name="homo_group_inv-val"><b>homo_group_inv</b></a>]  Theorem
      
      ⊢ ∀g f.
          Group g ∧ GroupHomo f g (homo_group g f) ⇒
          ∀x. x ∈ fG ⇒ ∃z. z ∈ fG ∧ z ∘ x = #i
   
   [<a name="homo_image_group-val"><b>homo_image_group</b></a>]  Theorem
      
      ⊢ ∀g h f.
          Group g ∧ Group h ∧ GroupHomo f g h ⇒ Group (homo_image f g h)
   
   [<a name="homo_image_homo_quotient_kernel-val"><b>homo_image_homo_quotient_kernel</b></a>]  Theorem
      
      ⊢ ∀g h f.
          Group g ∧ Group h ∧ GroupHomo f g h ⇒
          GroupHomo (λz. CHOICE (preimage f G z) * kernel f g h)
            (homo_image f g h) (g / kernel_group f g h)
   
   [<a name="homo_image_iso_quotient_kernel-val"><b>homo_image_iso_quotient_kernel</b></a>]  Theorem
      
      ⊢ ∀g h f.
          Group g ∧ Group h ∧ GroupHomo f g h ⇒
          GroupIso (λz. CHOICE (preimage f G z) * kernel f g h)
            (homo_image f g h) (g / kernel_group f g h)
   
   [<a name="homo_image_monoid-val"><b>homo_image_monoid</b></a>]  Theorem
      
      ⊢ ∀g h f.
          Monoid g ∧ Monoid h ∧ MonoidHomo f g h ⇒
          Monoid (homo_image f g h)
   
   [<a name="homo_image_subgroup-val"><b>homo_image_subgroup</b></a>]  Theorem
      
      ⊢ ∀g h f. Group g ∧ Group h ∧ GroupHomo f g h ⇒ homo_image f g h ≤ h
   
   [<a name="homo_image_to_quotient_kernel_bij-val"><b>homo_image_to_quotient_kernel_bij</b></a>]  Theorem
      
      ⊢ ∀g h f.
          Group g ∧ Group h ∧ GroupHomo f g h ⇒
          BIJ (λz. CHOICE (preimage f G z) * kernel f g h)
            (homo_image f g h).carrier (g / kernel_group f g h).carrier
   
   [<a name="homo_restrict_same_kernel-val"><b>homo_restrict_same_kernel</b></a>]  Theorem
      
      ⊢ ∀f g1 g2 h.
          H ⊆ g1.carrier ∧ GroupHomo f g1 g2 ∧ kernel f g1 g2 ⊆ H ⇒
          kernel f g1 g2 = kernel f h g2
   
   [<a name="image_iso_preimage_quotient-val"><b>image_iso_preimage_quotient</b></a>]  Theorem
      
      ⊢ ∀f g1 g2 h.
          Group g1 ∧ Group g2 ∧ h ≤ g2 ∧ GroupHomo f g1 g2 ⇒
          GroupIso
            (λz.
                 coset (preimage_group f g1 g2 h.carrier)
                   (CHOICE
                      (preimage f
                         (preimage_group f g1 g2 h.carrier).carrier z))
                   (kernel f (preimage_group f g1 g2 h.carrier) g2))
            (homo_image f (preimage_group f g1 g2 h.carrier) g2)
            (preimage_group f g1 g2 h.carrier /
             kernel_group f (preimage_group f g1 g2 h.carrier) g2)
   
   [<a name="image_preimage_group-val"><b>image_preimage_group</b></a>]  Theorem
      
      ⊢ ∀f g1 g2 h.
          Group g1 ∧ Group g2 ∧ h ≤ g2 ∧ GroupHomo f g1 g2 ∧
          SURJ f g1.carrier g2.carrier ⇒
          IMAGE f (PREIMAGE f h.carrier ∩ g1.carrier) = h.carrier
   
   [<a name="image_preimage_quotient_same_card-val"><b>image_preimage_quotient_same_card</b></a>]  Theorem
      
      ⊢ ∀f g1 g2 h.
          FiniteGroup g1 ∧ Group g2 ∧ h ≤ g2 ∧ GroupHomo f g1 g2 ⇒
          CARD (homo_image f (preimage_group f g1 g2 h.carrier) g2).carrier =
          CARD
            (preimage_group f g1 g2 h.carrier /
             kernel_group f (preimage_group f g1 g2 h.carrier) g2).carrier
   
   [<a name="image_subgroup_subgroup-val"><b>image_subgroup_subgroup</b></a>]  Theorem
      
      ⊢ ∀g1 g2 h f.
          Group g1 ∧ Group g2 ∧ GroupHomo f g1 g2 ∧ h ≤ g1 ⇒
          homo_image f h g2 ≤ g2
   
   [<a name="inCoset_equiv_on_carrier-val"><b>inCoset_equiv_on_carrier</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ inCoset g h equiv_on G
   
   [<a name="inCoset_refl-val"><b>inCoset_refl</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ ∀a. a ∈ G ⇒ inCoset g h a a
   
   [<a name="inCoset_sym-val"><b>inCoset_sym</b></a>]  Theorem
      
      ⊢ ∀g h.
          h ≤ g ⇒ ∀a b. a ∈ G ∧ b ∈ G ∧ inCoset g h a b ⇒ inCoset g h b a
   
   [<a name="inCoset_trans-val"><b>inCoset_trans</b></a>]  Theorem
      
      ⊢ ∀g h.
          h ≤ g ⇒
          ∀a b c.
            a ∈ G ∧ b ∈ G ∧ c ∈ G ∧ inCoset g h a b ∧ inCoset g h b c ⇒
            inCoset g h a c
   
   [<a name="in_coset-val"><b>in_coset</b></a>]  Theorem
      
      ⊢ ∀g X a. a ∈ G ⇒ ∀x. x ∈ a * X ⇔ ∃y. y ∈ X ∧ x = a * y
   
   [<a name="independent_generated_eq-val"><b>independent_generated_eq</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀a b.
              a ∈ G ∧ b ∈ G ∧ independent g a b ⇒ (gen a = gen b ⇔ a = b)
   
   [<a name="independent_generator_2_card-val"><b>independent_generator_2_card</b></a>]  Theorem
      
      ⊢ ∀g. FiniteGroup g ⇒
            ∀a b.
              a ∈ G ∧ b ∈ G ∧ independent g a b ⇒
              CARD (gen a ∘ gen b).carrier = ord a * ord b
   
   [<a name="independent_sym-val"><b>independent_sym</b></a>]  Theorem
      
      ⊢ ∀g a b. independent g a b ⇔ independent g b a
   
   [<a name="iso_group_same_card-val"><b>iso_group_same_card</b></a>]  Theorem
      
      ⊢ ∀f g h. FINITE G ∧ GroupIso f g h ⇒ CARD G = CARD h.carrier
   
   [<a name="kernel_element-val"><b>kernel_element</b></a>]  Theorem
      
      ⊢ ∀g h f x. x ∈ kernel f g h ⇔ x ∈ G ∧ f x = h.id
   
   [<a name="kernel_group_group-val"><b>kernel_group_group</b></a>]  Theorem
      
      ⊢ ∀g h f.
          Group g ∧ Group h ∧ GroupHomo f g h ⇒ Group (kernel_group f g h)
   
   [<a name="kernel_group_normal-val"><b>kernel_group_normal</b></a>]  Theorem
      
      ⊢ ∀g h f.
          Group g ∧ Group h ∧ GroupHomo f g h ⇒ kernel_group f g h &lt;&lt; g
   
   [<a name="kernel_group_subgroup-val"><b>kernel_group_subgroup</b></a>]  Theorem
      
      ⊢ ∀g h f.
          Group g ∧ Group h ∧ GroupHomo f g h ⇒ kernel_group f g h ≤ g
   
   [<a name="kernel_property-val"><b>kernel_property</b></a>]  Theorem
      
      ⊢ ∀g h f x. x ∈ kernel f g h ⇔ x ∈ G ∧ f x = h.id
   
   [<a name="kernel_quotient_group-val"><b>kernel_quotient_group</b></a>]  Theorem
      
      ⊢ ∀g h f.
          Group g ∧ Group h ∧ GroupHomo f g h ⇒
          Group (g / kernel_group f g h)
   
   [<a name="left_coset_alt-val"><b>left_coset_alt</b></a>]  Theorem
      
      ⊢ ∀g X a. left_coset g X a = {a * z | z ∈ X}
   
   [<a name="make_group_property-val"><b>make_group_property</b></a>]  Theorem
      
      ⊢ ∀g s.
          (make_group g s).carrier = s ∧ (make_group g s).op = $* ∧
          (make_group g s).id = #e
   
   [<a name="monoid_homo_homo_image_monoid-val"><b>monoid_homo_homo_image_monoid</b></a>]  Theorem
      
      ⊢ ∀g h f. Monoid g ∧ MonoidHomo f g h ⇒ Monoid (homo_image f g h)
   
   [<a name="monoid_inv_id-val"><b>monoid_inv_id</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ |/ #e = #e
   
   [<a name="monoid_inv_order-val"><b>monoid_inv_order</b></a>]  Theorem
      
      ⊢ ∀g x. Monoid g ∧ x ∈ G* ⇒ ord ( |/ x) = ord x
   
   [<a name="monoid_inv_order_property-val"><b>monoid_inv_order_property</b></a>]  Theorem
      
      ⊢ ∀g. FiniteMonoid g ⇒ ∀x. x ∈ G* ⇒ 0 &lt; ord x ∧ x ** ord x = #e
   
   [<a name="monoid_invertibles_is_group-val"><b>monoid_invertibles_is_group</b></a>]  Theorem
      
      ⊢ ∀g. Monoid g ⇒ Group (Invertibles g)
   
   [<a name="mult_mod_abelian_group-val"><b>mult_mod_abelian_group</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇒ AbelianGroup (mult_mod p)
   
   [<a name="mult_mod_card-val"><b>mult_mod_card</b></a>]  Theorem
      
      ⊢ ∀p. 0 &lt; p ⇒ CARD (mult_mod p).carrier = p − 1
   
   [<a name="mult_mod_carrier-val"><b>mult_mod_carrier</b></a>]  Theorem
      
      ⊢ ∀p. (mult_mod p).carrier = {i | i ≠ 0 ∧ i &lt; p}
   
   [<a name="mult_mod_carrier_alt-val"><b>mult_mod_carrier_alt</b></a>]  Theorem
      
      ⊢ ∀p. (mult_mod p).carrier = residue p
   
   [<a name="mult_mod_element-val"><b>mult_mod_element</b></a>]  Theorem
      
      ⊢ ∀p x. x ∈ (mult_mod p).carrier ⇔ x ≠ 0 ∧ x &lt; p
   
   [<a name="mult_mod_element_alt-val"><b>mult_mod_element_alt</b></a>]  Theorem
      
      ⊢ ∀p x. x ∈ (mult_mod p).carrier ⇔ 0 &lt; x ∧ x &lt; p
   
   [<a name="mult_mod_eval-val"><b>mult_mod_eval</b></a>]  Theorem
      
      ⊢ ∀p. (mult_mod p).carrier = {i | i ≠ 0 ∧ i &lt; p} ∧
            (∀x y. (mult_mod p).op x y = (x * y) MOD p) ∧
            (mult_mod p).id = 1
   
   [<a name="mult_mod_exp-val"><b>mult_mod_exp</b></a>]  Theorem
      
      ⊢ ∀p a.
          prime p ∧ a ∈ (mult_mod p).carrier ⇒
          ∀n. (mult_mod p).exp a n = a ** n MOD p
   
   [<a name="mult_mod_finite-val"><b>mult_mod_finite</b></a>]  Theorem
      
      ⊢ ∀p. FINITE (mult_mod p).carrier
   
   [<a name="mult_mod_finite_abelian_group-val"><b>mult_mod_finite_abelian_group</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇒ FiniteAbelianGroup (mult_mod p)
   
   [<a name="mult_mod_finite_group-val"><b>mult_mod_finite_group</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇒ FiniteGroup (mult_mod p)
   
   [<a name="mult_mod_group-val"><b>mult_mod_group</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇒ Group (mult_mod p)
   
   [<a name="mult_mod_id-val"><b>mult_mod_id</b></a>]  Theorem
      
      ⊢ ∀p. (mult_mod p).id = 1
   
   [<a name="mult_mod_inv-val"><b>mult_mod_inv</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇒
            ∀x. 0 &lt; x ∧ x &lt; p ⇒
                (mult_mod p).inv x =
                (mult_mod p).exp x (order (mult_mod p) x − 1)
   
   [<a name="mult_mod_inv_compute-val"><b>mult_mod_inv_compute</b></a>]  Theorem
      
      ⊢ ∀p x.
          (mult_mod p).inv x =
          if prime p ∧ 0 &lt; x ∧ x &lt; p then
            (mult_mod p).exp x (order (mult_mod p) x − 1)
          else FAIL ((mult_mod p).inv x) bad_element
   
   [<a name="mult_mod_inverse-val"><b>mult_mod_inverse</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇒
            ∀a. 0 &lt; a ∧ a &lt; p ⇒ (mult_mod p).inv a = a ** (p − 2) MOD p
   
   [<a name="mult_mod_inverse_compute-val"><b>mult_mod_inverse_compute</b></a>]  Theorem
      
      ⊢ ∀p a.
          (mult_mod p).inv a =
          if prime p ∧ 0 &lt; a ∧ a &lt; p then a ** (p − 2) MOD p
          else (mult_mod p).inv a
   
   [<a name="mult_mod_property-val"><b>mult_mod_property</b></a>]  Theorem
      
      ⊢ ∀p. (∀x. x ∈ (mult_mod p).carrier ⇒ x ≠ 0) ∧
            (∀x. x ∈ (mult_mod p).carrier ⇔ 0 &lt; x ∧ x &lt; p) ∧
            (mult_mod p).id = 1 ∧
            (∀x y. (mult_mod p).op x y = (x * y) MOD p) ∧
            FINITE (mult_mod p).carrier ∧
            (0 &lt; p ⇒ CARD (mult_mod p).carrier = p − 1)
   
   [<a name="multi_orbits_element-val"><b>multi_orbits_element</b></a>]  Theorem
      
      ⊢ ∀f g X e. e ∈ multi_orbits f g X ⇔ e ∈ orbits f g X ∧ ¬SING e
   
   [<a name="multi_orbits_element_finite-val"><b>multi_orbits_element_finite</b></a>]  Theorem
      
      ⊢ ∀f g X e.
          (g act X) f ∧ FINITE X ∧ e ∈ multi_orbits f g X ⇒ FINITE e
   
   [<a name="multi_orbits_element_subset-val"><b>multi_orbits_element_subset</b></a>]  Theorem
      
      ⊢ ∀f g X e. (g act X) f ∧ e ∈ multi_orbits f g X ⇒ e ⊆ X
   
   [<a name="multi_orbits_finite-val"><b>multi_orbits_finite</b></a>]  Theorem
      
      ⊢ ∀f g X. FINITE X ⇒ FINITE (multi_orbits f g X)
   
   [<a name="multi_orbits_subset-val"><b>multi_orbits_subset</b></a>]  Theorem
      
      ⊢ ∀f g X. multi_orbits f g X ⊆ orbits f g X
   
   [<a name="non_fixed_points_card-val"><b>non_fixed_points_card</b></a>]  Theorem
      
      ⊢ ∀f g X.
          FINITE X ⇒
          CARD (X DIFF fixed_points f g X) =
          CARD X − CARD (fixed_points f g X)
   
   [<a name="non_fixed_points_orbit_not_sing-val"><b>non_fixed_points_orbit_not_sing</b></a>]  Theorem
      
      ⊢ ∀f g X.
          Group g ∧ (g act X) f ⇒
          ∀x. x ∈ X DIFF fixed_points f g X ⇔ x ∈ X ∧ ¬SING (orbit f g x)
   
   [<a name="normal_cogen_property-val"><b>normal_cogen_property</b></a>]  Theorem
      
      ⊢ ∀g h. h &lt;&lt; g ⇒ ∀x. x ∈ G ⇒ x / cogen g h (x * H) ∈ H
   
   [<a name="normal_coset_op_property-val"><b>normal_coset_op_property</b></a>]  Theorem
      
      ⊢ ∀g h.
          h &lt;&lt; g ⇒
          ∀x y.
            x ∈ CosetPartition g h ∧ y ∈ CosetPartition g h ⇒
            x ∘ y =
            CHOICE (preimage (left_coset g H) G x) *
            CHOICE (preimage (left_coset g H) G y) * H
   
   [<a name="normal_coset_property-val"><b>normal_coset_property</b></a>]  Theorem
      
      ⊢ ∀g h.
          h &lt;&lt; g ⇒
          ∀a b.
            a ∈ G ∧ b ∈ G ⇒
            cogen g h (a * H) * cogen g h (b * H) * H = a * b * H
   
   [<a name="normal_coset_property1-val"><b>normal_coset_property1</b></a>]  Theorem
      
      ⊢ ∀g h.
          h &lt;&lt; g ⇒
          ∀a b. a ∈ G ∧ b ∈ G ⇒ cogen g h (a * H) * b * H = a * b * H
   
   [<a name="normal_coset_property2-val"><b>normal_coset_property2</b></a>]  Theorem
      
      ⊢ ∀g h.
          h &lt;&lt; g ⇒
          ∀a b. a ∈ G ∧ b ∈ G ⇒ a * cogen g h (b * H) * H = a * b * H
   
   [<a name="normal_iff_preimage_normal-val"><b>normal_iff_preimage_normal</b></a>]  Theorem
      
      ⊢ ∀f g1 g2 h2.
          Group g1 ∧ Group g2 ∧ h2 ≤ g2 ∧ GroupHomo f g1 g2 ∧
          SURJ f g1.carrier g2.carrier ⇒
          (h2 &lt;&lt; g2 ⇔ preimage_group f g1 g2 h2.carrier &lt;&lt; g1)
   
   [<a name="normal_preimage_normal-val"><b>normal_preimage_normal</b></a>]  Theorem
      
      ⊢ ∀f g1 g2 h2.
          Group g1 ∧ Group g2 ∧ h2 ≤ g2 ∧ GroupHomo f g1 g2 ⇒
          h2 &lt;&lt; g2 ⇒
          preimage_group f g1 g2 h2.carrier &lt;&lt; g1
   
   [<a name="normal_subgroup_alt-val"><b>normal_subgroup_alt</b></a>]  Theorem
      
      ⊢ ∀g h. h &lt;&lt; g ⇔ h ≤ g ∧ ∀a. a ∈ G ⇒ a * H = H * a
   
   [<a name="normal_subgroup_antisym-val"><b>normal_subgroup_antisym</b></a>]  Theorem
      
      ⊢ ∀g h. h &lt;&lt; g ∧ g &lt;&lt; h ⇒ h = g
   
   [<a name="normal_subgroup_coset_eq-val"><b>normal_subgroup_coset_eq</b></a>]  Theorem
      
      ⊢ ∀g h. h &lt;&lt; g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ (x * H = y * H ⇔ x / y ∈ H)
   
   [<a name="normal_subgroup_coset_homo-val"><b>normal_subgroup_coset_homo</b></a>]  Theorem
      
      ⊢ ∀g h. h &lt;&lt; g ⇒ GroupHomo (left_coset g H) g (g / h)
   
   [<a name="normal_subgroup_groups-val"><b>normal_subgroup_groups</b></a>]  Theorem
      
      ⊢ ∀g h. h &lt;&lt; g ⇒ h ≤ g ∧ Group h ∧ Group g
   
   [<a name="normal_subgroup_property-val"><b>normal_subgroup_property</b></a>]  Theorem
      
      ⊢ ∀h g. h &lt;&lt; g ⇒ ∀a z. a ∈ G ∧ z ∈ H ⇒ a * z / a ∈ H
   
   [<a name="normal_subgroup_refl-val"><b>normal_subgroup_refl</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ g &lt;&lt; g
   
   [<a name="normal_subgroup_subgroup-val"><b>normal_subgroup_subgroup</b></a>]  Theorem
      
      ⊢ ∀h g. h &lt;&lt; g ⇒ h ≤ g
   
   [<a name="normal_surj_normal-val"><b>normal_surj_normal</b></a>]  Theorem
      
      ⊢ ∀f g1 g2 h2.
          Group g1 ∧ Group g2 ∧ h2 ≤ g2 ∧ GroupHomo f g1 g2 ∧
          SURJ f g1.carrier g2.carrier ⇒
          preimage_group f g1 g2 h2.carrier &lt;&lt; g1 ⇒
          h2 &lt;&lt; g2
   
   [<a name="orbit_alt-val"><b>orbit_alt</b></a>]  Theorem
      
      ⊢ ∀f g x. orbit f g x = {f a x | a ∈ G}
   
   [<a name="orbit_card_divides_target_card-val"><b>orbit_card_divides_target_card</b></a>]  Theorem
      
      ⊢ ∀f g X x.
          FiniteGroup g ∧ (g act X) f ∧ x ∈ X ∧ FINITE X ⇒
          CARD (orbit f g x) divides CARD G
   
   [<a name="orbit_element-val"><b>orbit_element</b></a>]  Theorem
      
      ⊢ ∀f g x y. y ∈ orbit f g x ⇔ (x ~~ y) f g
   
   [<a name="orbit_element_in_target-val"><b>orbit_element_in_target</b></a>]  Theorem
      
      ⊢ ∀f g X x y. (g act X) f ∧ x ∈ X ∧ y ∈ orbit f g x ⇒ y ∈ X
   
   [<a name="orbit_eq_equiv_class-val"><b>orbit_eq_equiv_class</b></a>]  Theorem
      
      ⊢ ∀f g X x.
          (g act X) f ∧ x ∈ X ⇒ orbit f g x = equiv_class (reach f g) X x
   
   [<a name="orbit_eq_orbit-val"><b>orbit_eq_orbit</b></a>]  Theorem
      
      ⊢ ∀f g X x y.
          Group g ∧ (g act X) f ∧ x ∈ X ∧ y ∈ X ⇒
          (orbit f g x = orbit f g y ⇔ (x ~~ y) f g)
   
   [<a name="orbit_finite-val"><b>orbit_finite</b></a>]  Theorem
      
      ⊢ ∀f g x. FINITE G ⇒ FINITE (orbit f g x)
   
   [<a name="orbit_finite_by_target-val"><b>orbit_finite_by_target</b></a>]  Theorem
      
      ⊢ ∀f g X x. (g act X) f ∧ x ∈ X ∧ FINITE X ⇒ FINITE (orbit f g x)
   
   [<a name="orbit_finite_inj_card_eq-val"><b>orbit_finite_inj_card_eq</b></a>]  Theorem
      
      ⊢ ∀f g X x.
          (g act X) f ∧ x ∈ X ∧ FINITE X ∧ INJ (λa. f a x) G (orbit f g x) ⇒
          CARD (orbit f g x) = CARD G
   
   [<a name="orbit_has_action_element-val"><b>orbit_has_action_element</b></a>]  Theorem
      
      ⊢ ∀f g x a. a ∈ G ⇒ f a x ∈ orbit f g x
   
   [<a name="orbit_has_self-val"><b>orbit_has_self</b></a>]  Theorem
      
      ⊢ ∀f g X x. Group g ∧ (g act X) f ∧ x ∈ X ⇒ x ∈ orbit f g x
   
   [<a name="orbit_is_orbits_element-val"><b>orbit_is_orbits_element</b></a>]  Theorem
      
      ⊢ ∀f g X x. x ∈ X ⇒ orbit f g x ∈ orbits f g X
   
   [<a name="orbit_sing_fixed_points-val"><b>orbit_sing_fixed_points</b></a>]  Theorem
      
      ⊢ ∀f g X.
          (g act X) f ⇒
          ∀x. x ∈ X ∧ orbit f g x = {x} ⇒ x ∈ fixed_points f g X
   
   [<a name="orbit_stabilizer_cosets_bij-val"><b>orbit_stabilizer_cosets_bij</b></a>]  Theorem
      
      ⊢ ∀f g X x.
          Group g ∧ (g act X) f ∧ x ∈ X ⇒
          BIJ (λy. act_by f g x y * stabilizer f g x) (orbit f g x)
            {a * stabilizer f g x | a | a ∈ G}
   
   [<a name="orbit_stabilizer_cosets_bij_alt-val"><b>orbit_stabilizer_cosets_bij_alt</b></a>]  Theorem
      
      ⊢ ∀f g X x.
          Group g ∧ (g act X) f ∧ x ∈ X ⇒
          BIJ (λy. act_by f g x y * stabilizer f g x) (orbit f g x)
            (CosetPartition g (StabilizerGroup f g x))
   
   [<a name="orbit_stabilizer_map_good-val"><b>orbit_stabilizer_map_good</b></a>]  Theorem
      
      ⊢ ∀f g X x.
          Group g ∧ (g act X) f ∧ x ∈ X ⇒
          ∀a b.
            a ∈ G ∧ b ∈ G ∧ f a x = f b x ⇒
            a * stabilizer f g x = b * stabilizer f g x
   
   [<a name="orbit_stabilizer_map_inj-val"><b>orbit_stabilizer_map_inj</b></a>]  Theorem
      
      ⊢ ∀f g X x.
          Group g ∧ (g act X) f ∧ x ∈ X ⇒
          ∀a b.
            a ∈ G ∧ b ∈ G ∧ a * stabilizer f g x = b * stabilizer f g x ⇒
            f a x = f b x
   
   [<a name="orbit_stabilizer_thm-val"><b>orbit_stabilizer_thm</b></a>]  Theorem
      
      ⊢ ∀f g X x.
          FiniteGroup g ∧ (g act X) f ∧ x ∈ X ∧ FINITE X ⇒
          CARD G = CARD (orbit f g x) * CARD (stabilizer f g x)
   
   [<a name="orbit_subset_target-val"><b>orbit_subset_target</b></a>]  Theorem
      
      ⊢ ∀f g X x. (g act X) f ∧ x ∈ X ⇒ orbit f g x ⊆ X
   
   [<a name="orbits_alt-val"><b>orbits_alt</b></a>]  Theorem
      
      ⊢ ∀f g X. orbits f g X = {orbit f g x | x ∈ X}
   
   [<a name="orbits_element-val"><b>orbits_element</b></a>]  Theorem
      
      ⊢ ∀f g X e. e ∈ orbits f g X ⇔ ∃x. x ∈ X ∧ e = orbit f g x
   
   [<a name="orbits_element_element-val"><b>orbits_element_element</b></a>]  Theorem
      
      ⊢ ∀f g X e x. (g act X) f ∧ e ∈ orbits f g X ∧ x ∈ e ⇒ x ∈ X
   
   [<a name="orbits_element_finite-val"><b>orbits_element_finite</b></a>]  Theorem
      
      ⊢ ∀f g X. (g act X) f ∧ FINITE X ⇒ EVERY_FINITE (orbits f g X)
   
   [<a name="orbits_element_is_orbit-val"><b>orbits_element_is_orbit</b></a>]  Theorem
      
      ⊢ ∀f g X e x.
          Group g ∧ (g act X) f ∧ e ∈ orbits f g X ∧ x ∈ e ⇒
          e = orbit f g x
   
   [<a name="orbits_element_nonempty-val"><b>orbits_element_nonempty</b></a>]  Theorem
      
      ⊢ ∀f g X. Group g ∧ (g act X) f ⇒ ∀e. e ∈ orbits f g X ⇒ e ≠ ∅
   
   [<a name="orbits_element_subset-val"><b>orbits_element_subset</b></a>]  Theorem
      
      ⊢ ∀f g X e. (g act X) f ∧ e ∈ orbits f g X ⇒ e ⊆ X
   
   [<a name="orbits_eq_partition-val"><b>orbits_eq_partition</b></a>]  Theorem
      
      ⊢ ∀f g X. (g act X) f ⇒ orbits f g X = partition (reach f g) X
   
   [<a name="orbits_equal_size_partition_equal_size-val"><b>orbits_equal_size_partition_equal_size</b></a>]  Theorem
      
      ⊢ ∀f g X n.
          Group g ∧ (g act X) f ∧ FINITE X ∧
          (∀x. x ∈ X ⇒ CARD (orbit f g x) = n) ⇒
          ∀e. e ∈ orbits f g X ⇒ CARD e = n
   
   [<a name="orbits_equal_size_property-val"><b>orbits_equal_size_property</b></a>]  Theorem
      
      ⊢ ∀f g X n.
          Group g ∧ (g act X) f ∧ FINITE X ∧
          (∀x. x ∈ X ⇒ CARD (orbit f g x) = n) ⇒
          n divides CARD X
   
   [<a name="orbits_finite-val"><b>orbits_finite</b></a>]  Theorem
      
      ⊢ ∀f g X. FINITE X ⇒ FINITE (orbits f g X)
   
   [<a name="orbits_size_factor_partition_factor-val"><b>orbits_size_factor_partition_factor</b></a>]  Theorem
      
      ⊢ ∀f g X n.
          Group g ∧ (g act X) f ∧ FINITE X ∧
          (∀x. x ∈ X ⇒ n divides CARD (orbit f g x)) ⇒
          ∀e. e ∈ orbits f g X ⇒ n divides CARD e
   
   [<a name="orbits_size_factor_property-val"><b>orbits_size_factor_property</b></a>]  Theorem
      
      ⊢ ∀f g X n.
          Group g ∧ (g act X) f ∧ FINITE X ∧
          (∀x. x ∈ X ⇒ n divides CARD (orbit f g x)) ⇒
          n divides CARD X
   
   [<a name="orders_is_feq_class_order-val"><b>orders_is_feq_class_order</b></a>]  Theorem
      
      ⊢ ∀g. orders g = preimage ord G
   
   [<a name="preimage_cardinality-val"><b>preimage_cardinality</b></a>]  Theorem
      
      ⊢ ∀f g1 g2 h.
          FiniteGroup g1 ∧ Group g2 ∧ h ≤ g2 ∧ GroupHomo f g1 g2 ∧
          SURJ f g1.carrier g2.carrier ⇒
          CARD (preimage_group f g1 g2 h.carrier).carrier =
          CARD h.carrier * CARD (kernel f g1 g2)
   
   [<a name="preimage_group_group-val"><b>preimage_group_group</b></a>]  Theorem
      
      ⊢ ∀f g1 g2 h.
          Group g1 ∧ Group g2 ∧ GroupHomo f g1 g2 ∧ h ≤ g2 ⇒
          Group (preimage_group f g1 g2 h.carrier)
   
   [<a name="preimage_group_property-val"><b>preimage_group_property</b></a>]  Theorem
      
      ⊢ ∀f g1 g2 h x.
          x ∈ PREIMAGE f h ∩ g1.carrier ⇒ x ∈ g1.carrier ∧ f x ∈ h
   
   [<a name="preimage_image_subset-val"><b>preimage_image_subset</b></a>]  Theorem
      
      ⊢ ∀f g1 g2 h.
          Group g1 ∧ Group g2 ∧ h ≤ g1 ∧ GroupHomo f g1 g2 ∧
          SURJ f g1.carrier g2.carrier ∧ kernel f g1 g2 ⊆ H ⇒
          PREIMAGE f (IMAGE f H) ∩ g1.carrier ⊆ H
   
   [<a name="preimage_subgroup_kernel-val"><b>preimage_subgroup_kernel</b></a>]  Theorem
      
      ⊢ ∀f g1 g2 h2.
          Group g1 ∧ Group g2 ∧ h2 ≤ g2 ∧ GroupHomo f g1 g2 ⇒
          kernel f g1 g2 ⊆ PREIMAGE f h2.carrier ∩ g1.carrier
   
   [<a name="preimage_subgroup_subgroup-val"><b>preimage_subgroup_subgroup</b></a>]  Theorem
      
      ⊢ ∀f g1 g2 h.
          Group g1 ∧ Group g2 ∧ GroupHomo f g1 g2 ∧ h ≤ g2 ⇒
          preimage_group f g1 g2 h.carrier ≤ g1
   
   [<a name="prod_image_as_op_image-val"><b>prod_image_as_op_image</b></a>]  Theorem
      
      ⊢ Π = OP_IMAGE (λx y. x * y) 1
   
   [<a name="quotient_group_assoc-val"><b>quotient_group_assoc</b></a>]  Theorem
      
      ⊢ ∀g h.
          h &lt;&lt; g ⇒
          ∀x y z.
            x ∈ CosetPartition g h ∧ y ∈ CosetPartition g h ∧
            z ∈ CosetPartition g h ⇒
            (x ∘ y) ∘ z = x ∘ y ∘ z
   
   [<a name="quotient_group_closure-val"><b>quotient_group_closure</b></a>]  Theorem
      
      ⊢ ∀g h.
          h ≤ g ⇒
          ∀x y.
            x ∈ CosetPartition g h ∧ y ∈ CosetPartition g h ⇒
            x ∘ y ∈ CosetPartition g h
   
   [<a name="quotient_group_group-val"><b>quotient_group_group</b></a>]  Theorem
      
      ⊢ ∀g h. h &lt;&lt; g ⇒ Group (g / h)
   
   [<a name="quotient_group_id-val"><b>quotient_group_id</b></a>]  Theorem
      
      ⊢ ∀g h.
          h &lt;&lt; g ⇒
          H ∈ CosetPartition g h ∧ ∀x. x ∈ CosetPartition g h ⇒ H ∘ x = x
   
   [<a name="quotient_group_inv-val"><b>quotient_group_inv</b></a>]  Theorem
      
      ⊢ ∀g h.
          h &lt;&lt; g ⇒
          ∀x. x ∈ CosetPartition g h ⇒
              ∃y. y ∈ CosetPartition g h ∧ y ∘ x = H
   
   [<a name="reach_equiv-val"><b>reach_equiv</b></a>]  Theorem
      
      ⊢ ∀f g X. Group g ∧ (g act X) f ⇒ reach f g equiv_on X
   
   [<a name="reach_refl-val"><b>reach_refl</b></a>]  Theorem
      
      ⊢ ∀f g X x. Group g ∧ (g act X) f ∧ x ∈ X ⇒ (x ~~ x) f g
   
   [<a name="reach_sym-val"><b>reach_sym</b></a>]  Theorem
      
      ⊢ ∀f g X x y.
          Group g ∧ (g act X) f ∧ x ∈ X ∧ y ∈ X ∧ (x ~~ y) f g ⇒
          (y ~~ x) f g
   
   [<a name="reach_trans-val"><b>reach_trans</b></a>]  Theorem
      
      ⊢ ∀f g X x y z.
          Group g ∧ (g act X) f ∧ x ∈ X ∧ y ∈ X ∧ z ∈ X ∧ (x ~~ y) f g ∧
          (y ~~ z) f g ⇒
          (x ~~ z) f g
   
   [<a name="right_coset_alt-val"><b>right_coset_alt</b></a>]  Theorem
      
      ⊢ ∀g X a. X * a = {z * a | z ∈ X}
   
   [<a name="roots_of_unity_0-val"><b>roots_of_unity_0</b></a>]  Theorem
      
      ⊢ ∀g. (uroots 0).carrier = G
   
   [<a name="roots_of_unity_element-val"><b>roots_of_unity_element</b></a>]  Theorem
      
      ⊢ ∀g n x. x ∈ (uroots n).carrier ⇔ x ∈ G ∧ x ** n = #e
   
   [<a name="roots_of_unity_subset-val"><b>roots_of_unity_subset</b></a>]  Theorem
      
      ⊢ ∀g n. (uroots n).carrier ⊆ G
   
   [<a name="sing_orbits_card_eqn-val"><b>sing_orbits_card_eqn</b></a>]  Theorem
      
      ⊢ ∀f g X.
          Group g ∧ (g act X) f ∧ FINITE X ⇒
          CARD (sing_orbits f g X) = CARD (fixed_points f g X)
   
   [<a name="sing_orbits_element-val"><b>sing_orbits_element</b></a>]  Theorem
      
      ⊢ ∀f g X e. e ∈ sing_orbits f g X ⇔ e ∈ orbits f g X ∧ SING e
   
   [<a name="sing_orbits_element_card-val"><b>sing_orbits_element_card</b></a>]  Theorem
      
      ⊢ ∀f g X e. e ∈ sing_orbits f g X ⇒ CARD e = 1
   
   [<a name="sing_orbits_element_choice-val"><b>sing_orbits_element_choice</b></a>]  Theorem
      
      ⊢ ∀f g X.
          Group g ∧ (g act X) f ⇒
          ∀e. e ∈ sing_orbits f g X ⇒ CHOICE e ∈ fixed_points f g X
   
   [<a name="sing_orbits_element_finite-val"><b>sing_orbits_element_finite</b></a>]  Theorem
      
      ⊢ ∀f g X e. e ∈ sing_orbits f g X ⇒ FINITE e
   
   [<a name="sing_orbits_element_subset-val"><b>sing_orbits_element_subset</b></a>]  Theorem
      
      ⊢ ∀f g X e. (g act X) f ∧ e ∈ sing_orbits f g X ⇒ e ⊆ X
   
   [<a name="sing_orbits_finite-val"><b>sing_orbits_finite</b></a>]  Theorem
      
      ⊢ ∀f g X. FINITE X ⇒ FINITE (sing_orbits f g X)
   
   [<a name="sing_orbits_subset-val"><b>sing_orbits_subset</b></a>]  Theorem
      
      ⊢ ∀f g X. sing_orbits f g X ⊆ orbits f g X
   
   [<a name="sing_orbits_to_fixed_points_bij-val"><b>sing_orbits_to_fixed_points_bij</b></a>]  Theorem
      
      ⊢ ∀f g X.
          Group g ∧ (g act X) f ⇒
          BIJ (λe. CHOICE e) (sing_orbits f g X) (fixed_points f g X)
   
   [<a name="sing_orbits_to_fixed_points_inj-val"><b>sing_orbits_to_fixed_points_inj</b></a>]  Theorem
      
      ⊢ ∀f g X.
          Group g ∧ (g act X) f ⇒
          INJ (λe. CHOICE e) (sing_orbits f g X) (fixed_points f g X)
   
   [<a name="sing_orbits_to_fixed_points_surj-val"><b>sing_orbits_to_fixed_points_surj</b></a>]  Theorem
      
      ⊢ ∀f g X.
          Group g ∧ (g act X) f ⇒
          SURJ (λe. CHOICE e) (sing_orbits f g X) (fixed_points f g X)
   
   [<a name="stabilizer_as_image-val"><b>stabilizer_as_image</b></a>]  Theorem
      
      ⊢ ∀f g X x.
          Group g ∧ (g act X) f ∧ x ∈ X ⇒
          stabilizer f g x = IMAGE (λa. if f a x = x then a else #e) G
   
   [<a name="stabilizer_conjugate-val"><b>stabilizer_conjugate</b></a>]  Theorem
      
      ⊢ ∀f g X x a.
          Group g ∧ (g act X) f ∧ x ∈ X ∧ a ∈ G ⇒
          conjugate g a (stabilizer f g x) = stabilizer f g (f a x)
   
   [<a name="stabilizer_element-val"><b>stabilizer_element</b></a>]  Theorem
      
      ⊢ ∀f g x a. a ∈ stabilizer f g x ⇔ a ∈ G ∧ f a x = x
   
   [<a name="stabilizer_group_card_divides-val"><b>stabilizer_group_card_divides</b></a>]  Theorem
      
      ⊢ ∀f g X x.
          FiniteGroup g ∧ (g act X) f ∧ x ∈ X ⇒
          CARD (stabilizer f g x) divides CARD G
   
   [<a name="stabilizer_group_carrier-val"><b>stabilizer_group_carrier</b></a>]  Theorem
      
      ⊢ ∀f g x. (StabilizerGroup f g x).carrier = stabilizer f g x
   
   [<a name="stabilizer_group_finite_group-val"><b>stabilizer_group_finite_group</b></a>]  Theorem
      
      ⊢ ∀f g X x.
          FiniteGroup g ∧ (g act X) f ∧ x ∈ X ⇒
          FiniteGroup (StabilizerGroup f g x)
   
   [<a name="stabilizer_group_group-val"><b>stabilizer_group_group</b></a>]  Theorem
      
      ⊢ ∀f g X x.
          Group g ∧ (g act X) f ∧ x ∈ X ⇒ Group (StabilizerGroup f g x)
   
   [<a name="stabilizer_group_id-val"><b>stabilizer_group_id</b></a>]  Theorem
      
      ⊢ ∀f g x. (StabilizerGroup f g x).id = #e
   
   [<a name="stabilizer_group_property-val"><b>stabilizer_group_property</b></a>]  Theorem
      
      ⊢ ∀f g x.
          (StabilizerGroup f g x).carrier = stabilizer f g x ∧
          (StabilizerGroup f g x).op = $* ∧ (StabilizerGroup f g x).id = #e
   
   [<a name="stabilizer_group_subgroup-val"><b>stabilizer_group_subgroup</b></a>]  Theorem
      
      ⊢ ∀f g X x. Group g ∧ (g act X) f ∧ x ∈ X ⇒ StabilizerGroup f g x ≤ g
   
   [<a name="stabilizer_has_id-val"><b>stabilizer_has_id</b></a>]  Theorem
      
      ⊢ ∀f g X x. Group g ∧ (g act X) f ∧ x ∈ X ⇒ #e ∈ stabilizer f g x
   
   [<a name="stabilizer_nonempty-val"><b>stabilizer_nonempty</b></a>]  Theorem
      
      ⊢ ∀f g X x. Group g ∧ (g act X) f ∧ x ∈ X ⇒ stabilizer f g x ≠ ∅
   
   [<a name="stabilizer_subset-val"><b>stabilizer_subset</b></a>]  Theorem
      
      ⊢ ∀f g x. stabilizer f g x ⊆ G
   
   [<a name="subgroup_I_antisym-val"><b>subgroup_I_antisym</b></a>]  Theorem
      
      ⊢ ∀g h. subgroup h g ∧ subgroup g h ⇒ GroupIso I h g
   
   [<a name="subgroup_alt-val"><b>subgroup_alt</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀h. h ≤ g ⇔
                H ≠ ∅ ∧ H ⊆ G ∧ $o = $* ∧ #i = #e ∧
                ∀x y. x ∈ H ∧ y ∈ H ⇒ x * |/ y ∈ H
   
   [<a name="subgroup_antisym-val"><b>subgroup_antisym</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ∧ g ≤ h ⇒ h = g
   
   [<a name="subgroup_big_cross_empty-val"><b>subgroup_big_cross_empty</b></a>]  Theorem
      
      ⊢ ∀g. sgbcross ∅ = gen #e
   
   [<a name="subgroup_big_cross_insert-val"><b>subgroup_big_cross_insert</b></a>]  Theorem
      
      ⊢ ∀g. FiniteAbelianGroup g ⇒
            ∀B. B ⊆ all_subgroups g ⇒
                ∀h. h ∈ all_subgroups g ∧ h ∉ B ⇒
                    sgbcross (h INSERT B) = h ∘ sgbcross B
   
   [<a name="subgroup_big_cross_thm-val"><b>subgroup_big_cross_thm</b></a>]  Theorem
      
      ⊢ ∀g. FiniteAbelianGroup g ⇒
            ∀B. B ⊆ all_subgroups g ⇒
                ∀h. h ∈ all_subgroups g ⇒
                    sgbcross (h INSERT B) = h ∘ sgbcross (B DELETE h)
   
   [<a name="subgroup_big_intersect_element-val"><b>subgroup_big_intersect_element</b></a>]  Theorem
      
      ⊢ ∀g x. x ∈ (sgbINTER g).carrier ⇔ ∀h. h ≤ g ⇒ x ∈ H
   
   [<a name="subgroup_big_intersect_group-val"><b>subgroup_big_intersect_group</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ Group (sgbINTER g)
   
   [<a name="subgroup_big_intersect_has_id-val"><b>subgroup_big_intersect_has_id</b></a>]  Theorem
      
      ⊢ ∀g. (sgbINTER g).id ∈ (sgbINTER g).carrier
   
   [<a name="subgroup_big_intersect_has_inv-val"><b>subgroup_big_intersect_has_inv</b></a>]  Theorem
      
      ⊢ ∀g x. x ∈ (sgbINTER g).carrier ⇒ |/ x ∈ (sgbINTER g).carrier
   
   [<a name="subgroup_big_intersect_op_element-val"><b>subgroup_big_intersect_op_element</b></a>]  Theorem
      
      ⊢ ∀g x y.
          x ∈ (sgbINTER g).carrier ∧ y ∈ (sgbINTER g).carrier ⇒
          (sgbINTER g).op x y ∈ (sgbINTER g).carrier
   
   [<a name="subgroup_big_intersect_property-val"><b>subgroup_big_intersect_property</b></a>]  Theorem
      
      ⊢ ∀g. (sgbINTER g).carrier = BIGINTER (IMAGE (λh. H) {h | h ≤ g}) ∧
            (∀x y.
               x ∈ (sgbINTER g).carrier ∧ y ∈ (sgbINTER g).carrier ⇒
               (sgbINTER g).op x y = x * y) ∧ (sgbINTER g).id = #e
   
   [<a name="subgroup_big_intersect_subgroup-val"><b>subgroup_big_intersect_subgroup</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ sgbINTER g ≤ g
   
   [<a name="subgroup_big_intersect_subset-val"><b>subgroup_big_intersect_subset</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ (sgbINTER g).carrier ⊆ G
   
   [<a name="subgroup_carrier_antisym-val"><b>subgroup_carrier_antisym</b></a>]  Theorem
      
      ⊢ ∀g h. subgroup h g ∧ G ⊆ H ⇒ GroupIso I h g
   
   [<a name="subgroup_carrier_nonempty-val"><b>subgroup_carrier_nonempty</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ H ≠ ∅
   
   [<a name="subgroup_carrier_subset-val"><b>subgroup_carrier_subset</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ H ⊆ G
   
   [<a name="subgroup_conjugate_subgroup_bij-val"><b>subgroup_conjugate_subgroup_bij</b></a>]  Theorem
      
      ⊢ ∀g h.
          h ≤ g ⇒
          ∀a. a ∈ G ⇒
              BIJ (λz. a * z * |/ a) H (conjugate_subgroup h g a).carrier
   
   [<a name="subgroup_coset_card-val"><b>subgroup_coset_card</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ∧ FINITE H ⇒ ∀a. a ∈ G ⇒ CARD (a * H) = CARD H
   
   [<a name="subgroup_coset_card_partition_element-val"><b>subgroup_coset_card_partition_element</b></a>]  Theorem
      
      ⊢ ∀g h.
          h ≤ g ∧ FINITE G ⇒
          ∀e. e ∈ partition (left_coset g H) G ⇒ CARD e = CARD H
   
   [<a name="subgroup_coset_eq-val"><b>subgroup_coset_eq</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ (x * H = y * H ⇔ |/ y * x ∈ H)
   
   [<a name="subgroup_coset_in_partition-val"><b>subgroup_coset_in_partition</b></a>]  Theorem
      
      ⊢ ∀g h.
          h ≤ g ⇒ ∀x. x ∈ IMAGE (left_coset g H) G ⇔ x ∈ CosetPartition g h
   
   [<a name="subgroup_coset_nonempty-val"><b>subgroup_coset_nonempty</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ ∀x. x ∈ G ⇒ x ∈ x * H
   
   [<a name="subgroup_coset_partition_element-val"><b>subgroup_coset_partition_element</b></a>]  Theorem
      
      ⊢ ∀g h.
          h ≤ g ⇒
          ∀e. e ∈ partition (left_coset g H) G ⇔ ∃a. a ∈ G ∧ e = a * H
   
   [<a name="subgroup_coset_subset-val"><b>subgroup_coset_subset</b></a>]  Theorem
      
      ⊢ ∀g h a x. h ≤ g ∧ a ∈ G ∧ x ∈ a * H ⇒ x ∈ G
   
   [<a name="subgroup_coset_sym-val"><b>subgroup_coset_sym</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ ∀a b. a ∈ G ∧ b ∈ G ∧ b ∈ a * H ⇒ a ∈ b * H
   
   [<a name="subgroup_coset_trans-val"><b>subgroup_coset_trans</b></a>]  Theorem
      
      ⊢ ∀g h.
          h ≤ g ⇒
          ∀a b c. a ∈ G ∧ b ∈ G ∧ c ∈ G ∧ b ∈ a * H ∧ c ∈ b * H ⇒ c ∈ a * H
   
   [<a name="subgroup_cross_assoc-val"><b>subgroup_cross_assoc</b></a>]  Theorem
      
      ⊢ ∀g h1 h2 h3.
          h1 ≤ g ∧ h2 ≤ g ∧ h3 ≤ g ⇒ (h1 ∘ h2) ∘ h3 = h1 ∘ h2 ∘ h3
   
   [<a name="subgroup_cross_card-val"><b>subgroup_cross_card</b></a>]  Theorem
      
      ⊢ ∀g h1 h2.
          h1 ≤ g ∧ h2 ≤ g ∧ FINITE G ⇒
          (let
             s1 = h1.carrier;
             s2 = h2.carrier
           in
             CARD (h1 ∘ h2).carrier = CARD s1 * CARD s2 DIV CARD (s1 ∩ s2))
   
   [<a name="subgroup_cross_card_eqn-val"><b>subgroup_cross_card_eqn</b></a>]  Theorem
      
      ⊢ ∀g h1 h2.
          h1 ≤ g ∧ h2 ≤ g ∧ FINITE G ⇒
          (let
             s1 = h1.carrier;
             s2 = h2.carrier
           in
             CARD (h1 ∘ h2).carrier * CARD (s1 ∩ s2) = CARD s1 * CARD s2)
   
   [<a name="subgroup_cross_closure_comm_assoc_fun-val"><b>subgroup_cross_closure_comm_assoc_fun</b></a>]  Theorem
      
      ⊢ ∀g. AbelianGroup g ⇒ closure_comm_assoc_fun $o (all_subgroups g)
   
   [<a name="subgroup_cross_comm-val"><b>subgroup_cross_comm</b></a>]  Theorem
      
      ⊢ ∀g. AbelianGroup g ⇒ ∀h1 h2. h1 ≤ g ∧ h2 ≤ g ⇒ h1 ∘ h2 = h2 ∘ h1
   
   [<a name="subgroup_cross_finite-val"><b>subgroup_cross_finite</b></a>]  Theorem
      
      ⊢ ∀g h1 h2.
          h1 ≤ g ∧ h2 ≤ g ∧ h1 ∘ h2 = h2 ∘ h1 ∧ FiniteGroup h1 ∧
          FiniteGroup h2 ⇒
          FiniteGroup (h1 ∘ h2)
   
   [<a name="subgroup_cross_group-val"><b>subgroup_cross_group</b></a>]  Theorem
      
      ⊢ ∀g h1 h2. h1 ≤ g ∧ h2 ≤ g ∧ h1 ∘ h2 = h2 ∘ h1 ⇒ Group (h1 ∘ h2)
   
   [<a name="subgroup_cross_property-val"><b>subgroup_cross_property</b></a>]  Theorem
      
      ⊢ ∀g h1 h2.
          (h1 ∘ h2).carrier = h1.carrier ∘ h2.carrier ∧ (h1 ∘ h2).op = $* ∧
          (h1 ∘ h2).id = #e
   
   [<a name="subgroup_cross_self-val"><b>subgroup_cross_self</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ h ∘ h = h
   
   [<a name="subgroup_cross_subgroup-val"><b>subgroup_cross_subgroup</b></a>]  Theorem
      
      ⊢ ∀g h1 h2. h1 ≤ g ∧ h2 ≤ g ∧ h1 ∘ h2 = h2 ∘ h1 ⇒ h1 ∘ h2 ≤ g
   
   [<a name="subgroup_element-val"><b>subgroup_element</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ ∀z. z ∈ H ⇒ z ∈ G
   
   [<a name="subgroup_eq-val"><b>subgroup_eq</b></a>]  Theorem
      
      ⊢ ∀g h1 h2. h1 ≤ g ∧ h2 ≤ g ⇒ (h1 = h2 ⇔ h1.carrier = h2.carrier)
   
   [<a name="subgroup_eq_carrier-val"><b>subgroup_eq_carrier</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ∧ H = G ⇒ h = g
   
   [<a name="subgroup_eqn-val"><b>subgroup_eqn</b></a>]  Theorem
      
      ⊢ ∀g h. subgroup h g ⇔ H ⊆ G ∧ ∀x y. x ∈ H ∧ y ∈ H ⇒ x ∘ y = x * y
   
   [<a name="subgroup_exp-val"><b>subgroup_exp</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ ∀x. x ∈ H ⇒ ∀n. h.exp x n = x ** n
   
   [<a name="subgroup_groups-val"><b>subgroup_groups</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ Group h ∧ Group g
   
   [<a name="subgroup_has_groups-val"><b>subgroup_has_groups</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ Group g ∧ Group h
   
   [<a name="subgroup_homo_homo-val"><b>subgroup_homo_homo</b></a>]  Theorem
      
      ⊢ ∀g h k f. subgroup h g ∧ GroupHomo f g k ⇒ GroupHomo f h k
   
   [<a name="subgroup_homomorphism-val"><b>subgroup_homomorphism</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ Group h ∧ Group g ∧ subgroup h g
   
   [<a name="subgroup_id-val"><b>subgroup_id</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ #i = #e
   
   [<a name="subgroup_incoset_equiv-val"><b>subgroup_incoset_equiv</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ left_coset g H equiv_on G
   
   [<a name="subgroup_intersect_group-val"><b>subgroup_intersect_group</b></a>]  Theorem
      
      ⊢ ∀g h k. h ≤ g ∧ k ≤ g ⇒ Group (h mINTER k)
   
   [<a name="subgroup_intersect_has_inv-val"><b>subgroup_intersect_has_inv</b></a>]  Theorem
      
      ⊢ ∀g h k. h ≤ g ∧ k ≤ g ⇒ ∀x. x ∈ H ∩ K ⇒ |/ x ∈ H ∩ K
   
   [<a name="subgroup_intersect_inv-val"><b>subgroup_intersect_inv</b></a>]  Theorem
      
      ⊢ ∀g h k. h ≤ g ∧ k ≤ g ⇒ ∀x. x ∈ H ∩ K ⇒ (h mINTER k).inv x = |/ x
   
   [<a name="subgroup_intersect_property-val"><b>subgroup_intersect_property</b></a>]  Theorem
      
      ⊢ ∀g h k.
          h ≤ g ∧ k ≤ g ⇒
          (h mINTER k).carrier = H ∩ K ∧
          (∀x y. x ∈ H ∩ K ∧ y ∈ H ∩ K ⇒ (h mINTER k).op x y = x * y) ∧
          (h mINTER k).id = #e ∧ ∀x. x ∈ H ∩ K ⇒ (h mINTER k).inv x = |/ x
   
   [<a name="subgroup_intersect_subgroup-val"><b>subgroup_intersect_subgroup</b></a>]  Theorem
      
      ⊢ ∀g h k. h ≤ g ∧ k ≤ g ⇒ (h mINTER k) ≤ g
   
   [<a name="subgroup_inv-val"><b>subgroup_inv</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ ∀x. x ∈ H ⇒ h.inv x = |/ x
   
   [<a name="subgroup_inv_closure-val"><b>subgroup_inv_closure</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ ∀x y. x ∈ H ∧ y ∈ H ⇒ x * |/ y ∈ H
   
   [<a name="subgroup_is_group-val"><b>subgroup_is_group</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ Group h
   
   [<a name="subgroup_is_submonoid-val"><b>subgroup_is_submonoid</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ h &lt;&lt; g
   
   [<a name="subgroup_is_submonoid0-val"><b>subgroup_is_submonoid0</b></a>]  Theorem
      
      ⊢ ∀g h. Group g ∧ Group h ∧ subgroup h g ⇒ submonoid h g
   
   [<a name="subgroup_op-val"><b>subgroup_op</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ $o = $*
   
   [<a name="subgroup_order-val"><b>subgroup_order</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ ∀x. x ∈ H ⇒ order h x = ord x
   
   [<a name="subgroup_order_eqn-val"><b>subgroup_order_eqn</b></a>]  Theorem
      
      ⊢ ∀g h.
          Group g ∧ Group h ∧ subgroup h g ⇒ ∀x. x ∈ H ⇒ order h x = ord x
   
   [<a name="subgroup_property-val"><b>subgroup_property</b></a>]  Theorem
      
      ⊢ ∀g h.
          h ≤ g ⇒ Group h ∧ Group g ∧ ∀x y. x ∈ H ∧ y ∈ H ⇒ x ∘ y = x * y
   
   [<a name="subgroup_property_all-val"><b>subgroup_property_all</b></a>]  Theorem
      
      ⊢ ∀g h.
          h ≤ g ⇒
          Group g ∧ Group h ∧ H ≠ ∅ ∧ H ⊆ G ∧ $o = $* ∧ #i = #e ∧
          (∀x. x ∈ H ⇒ h.inv x = |/ x) ∧ ∀x y. x ∈ H ∧ y ∈ H ⇒ x * |/ y ∈ H
   
   [<a name="subgroup_refl-val"><b>subgroup_refl</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ g ≤ g
   
   [<a name="subgroup_reflexive-val"><b>subgroup_reflexive</b></a>]  Theorem
      
      ⊢ ∀g. subgroup g g
   
   [<a name="subgroup_subset-val"><b>subgroup_subset</b></a>]  Theorem
      
      ⊢ ∀g h. subgroup h g ⇒ H ⊆ G
   
   [<a name="subgroup_test_by_cross-val"><b>subgroup_test_by_cross</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀h. h ≤ g ⇔ H ≠ ∅ ∧ H ⊆ G ∧ h ∘ h = h ∧ IMAGE |/ H = H
   
   [<a name="subgroup_thm-val"><b>subgroup_thm</b></a>]  Theorem
      
      ⊢ ∀g h.
          h ≤ g ⇔
          Group g ∧ $o = $* ∧ #i = #e ∧ H ≠ ∅ ∧ H ⊆ G ∧
          ∀x y. x ∈ H ∧ y ∈ H ⇒ x * |/ y ∈ H
   
   [<a name="subgroup_to_coset_bij-val"><b>subgroup_to_coset_bij</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ ∀a. a ∈ G ⇒ BIJ (λx. a * x) H (a * H)
   
   [<a name="subgroup_trans-val"><b>subgroup_trans</b></a>]  Theorem
      
      ⊢ ∀g h t. h ≤ t ∧ t ≤ g ⇒ h ≤ g
   
   [<a name="subgroup_transitive-val"><b>subgroup_transitive</b></a>]  Theorem
      
      ⊢ ∀g h k. subgroup g h ∧ subgroup h k ⇒ subgroup g k
   
   [<a name="subset_big_cross_empty-val"><b>subset_big_cross_empty</b></a>]  Theorem
      
      ⊢ ∀g. ssbcross ∅ = {#e}
   
   [<a name="subset_big_cross_insert-val"><b>subset_big_cross_insert</b></a>]  Theorem
      
      ⊢ ∀g. FiniteAbelianGroup g ⇒
            ∀B. B ⊆ POW G ⇒
                ∀s. s ⊆ G ∧ s ∉ B ⇒ ssbcross (s INSERT B) = s ∘ ssbcross B
   
   [<a name="subset_big_cross_thm-val"><b>subset_big_cross_thm</b></a>]  Theorem
      
      ⊢ ∀g. FiniteAbelianGroup g ⇒
            ∀B. B ⊆ POW G ⇒
                ∀s. s ⊆ G ⇒
                    ssbcross (s INSERT B) = s ∘ ssbcross (B DELETE s)
   
   [<a name="subset_cross_alt-val"><b>subset_cross_alt</b></a>]  Theorem
      
      ⊢ ∀g s1 s2. s1 ∘ s2 = IMAGE (λ(x,y). x * y) (s1 × s2)
   
   [<a name="subset_cross_assoc-val"><b>subset_cross_assoc</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀s1 s2 s3.
              s1 ⊆ G ∧ s2 ⊆ G ∧ s3 ⊆ G ⇒ (s1 ∘ s2) ∘ s3 = s1 ∘ s2 ∘ s3
   
   [<a name="subset_cross_closure_comm_assoc_fun-val"><b>subset_cross_closure_comm_assoc_fun</b></a>]  Theorem
      
      ⊢ ∀g. AbelianGroup g ⇒ closure_comm_assoc_fun $o (POW G)
   
   [<a name="subset_cross_comm-val"><b>subset_cross_comm</b></a>]  Theorem
      
      ⊢ ∀g. AbelianGroup g ⇒ ∀s1 s2. s1 ⊆ G ∧ s2 ⊆ G ⇒ s1 ∘ s2 = s2 ∘ s1
   
   [<a name="subset_cross_element-val"><b>subset_cross_element</b></a>]  Theorem
      
      ⊢ ∀g s1 s2 x y. x ∈ s1 ∧ y ∈ s2 ⇒ x * y ∈ s1 ∘ s2
   
   [<a name="subset_cross_element_iff-val"><b>subset_cross_element_iff</b></a>]  Theorem
      
      ⊢ ∀g s1 s2 z. z ∈ s1 ∘ s2 ⇔ ∃x y. x ∈ s1 ∧ y ∈ s2 ∧ z = x * y
   
   [<a name="subset_cross_element_preimage_card-val"><b>subset_cross_element_preimage_card</b></a>]  Theorem
      
      ⊢ ∀g h1 h2.
          h1 ≤ g ∧ h2 ≤ g ∧ FINITE G ⇒
          (let
             s1 = h1.carrier;
             s2 = h2.carrier;
             f (x,y) = x * y
           in
             ∀z. z ∈ s1 ∘ s2 ⇒
                 CARD (preimage f (s1 × s2) z) = CARD (s1 ∩ s2))
   
   [<a name="subset_cross_finite-val"><b>subset_cross_finite</b></a>]  Theorem
      
      ⊢ ∀g s1 s2. FINITE s1 ∧ FINITE s2 ⇒ FINITE (s1 ∘ s2)
   
   [<a name="subset_cross_inv-val"><b>subset_cross_inv</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒
            ∀s1 s2.
              s1 ⊆ G ∧ s2 ⊆ G ⇒
              IMAGE |/ (s1 ∘ s2) = IMAGE |/ s2 ∘ IMAGE |/ s1
   
   [<a name="subset_cross_partition_property-val"><b>subset_cross_partition_property</b></a>]  Theorem
      
      ⊢ ∀g h1 h2.
          h1 ≤ g ∧ h2 ≤ g ∧ FINITE G ⇒
          (let
             s1 = h1.carrier;
             s2 = h2.carrier;
             f (x,y) = x * y
           in
             ∀t. t ∈ partition (feq f) (s1 × s2) ⇒ CARD t = CARD (s1 ∩ s2))
   
   [<a name="subset_cross_preimage_inj-val"><b>subset_cross_preimage_inj</b></a>]  Theorem
      
      ⊢ ∀g s1 s2.
          INJ (preimage (λ(x,y). x * y) (s1 × s2)) (s1 ∘ s2)
            𝕌(:α # α -&gt; bool)
   
   [<a name="subset_cross_self-val"><b>subset_cross_self</b></a>]  Theorem
      
      ⊢ ∀g h. h ≤ g ⇒ H ∘ H = H
   
   [<a name="subset_cross_subset-val"><b>subset_cross_subset</b></a>]  Theorem
      
      ⊢ ∀g. Group g ⇒ ∀s1 s2. s1 ⊆ G ∧ s2 ⊆ G ⇒ s1 ∘ s2 ⊆ G
   
   [<a name="subset_cross_to_preimage_cross_bij-val"><b>subset_cross_to_preimage_cross_bij</b></a>]  Theorem
      
      ⊢ ∀g h1 h2.
          h1 ≤ g ∧ h2 ≤ g ⇒
          (let
             s1 = h1.carrier;
             s2 = h2.carrier;
             f (x,y) = x * y
           in
             ∀z. z ∈ s1 ∘ s2 ⇒
                 BIJ (λd. (left z * d,|/ d * right z)) (s1 ∩ s2)
                   (preimage f (s1 × s2) z))
   
   [<a name="subset_group_exp-val"><b>subset_group_exp</b></a>]  Theorem
      
      ⊢ ∀g s x. x ∈ s ⇒ ∀n. (subset_group g s).exp x n = x ** n
   
   [<a name="subset_group_order-val"><b>subset_group_order</b></a>]  Theorem
      
      ⊢ ∀g s x. x ∈ s ⇒ order (subset_group g s) x = ord x
   
   [<a name="subset_group_property-val"><b>subset_group_property</b></a>]  Theorem
      
      ⊢ ∀g s.
          (subset_group g s).carrier = s ∧ (subset_group g s).op = $* ∧
          (subset_group g s).id = #e
   
   [<a name="subset_group_subgroup-val"><b>subset_group_subgroup</b></a>]  Theorem
      
      ⊢ ∀g s.
          Group g ∧ s ≠ ∅ ∧ s ⊆ G ∧ (∀x y. x ∈ s ∧ y ∈ s ⇒ x * |/ y ∈ s) ⇒
          subset_group g s ≤ g
   
   [<a name="subset_group_submonoid-val"><b>subset_group_submonoid</b></a>]  Theorem
      
      ⊢ ∀g s.
          Monoid g ∧ #e ∈ s ∧ s ⊆ G ∧ (∀x y. x ∈ s ∧ y ∈ s ⇒ x * y ∈ s) ⇒
          subset_group g s &lt;&lt; g
   
   [<a name="subset_preimage_image-val"><b>subset_preimage_image</b></a>]  Theorem
      
      ⊢ ∀f g1 g2 h.
          Group g1 ∧ Group g2 ∧ h ≤ g1 ∧ GroupHomo f g1 g2 ⇒
          H ⊆ PREIMAGE f (IMAGE f H) ∩ g1.carrier
   
   [<a name="sum_image_as_op_image-val"><b>sum_image_as_op_image</b></a>]  Theorem
      
      ⊢ ∑ = OP_IMAGE (λx y. x + y) 0
   
   [<a name="symdiff_set_abelian_group-val"><b>symdiff_set_abelian_group</b></a>]  Theorem
      
      ⊢ AbelianGroup symdiff_set
   
   [<a name="symdiff_set_group-val"><b>symdiff_set_group</b></a>]  Theorem
      
      ⊢ Group symdiff_set
   
   [<a name="target_card_and_fixed_points_congruence-val"><b>target_card_and_fixed_points_congruence</b></a>]  Theorem
      
      ⊢ ∀f g X n.
          Group g ∧ (g act X) f ∧ FINITE X ∧ 0 &lt; n ∧
          (∀e. e ∈ multi_orbits f g X ⇒ CARD e = n) ⇒
          CARD X MOD n = CARD (fixed_points f g X) MOD n
   
   [<a name="target_card_by_fixed_points-val"><b>target_card_by_fixed_points</b></a>]  Theorem
      
      ⊢ ∀f g X.
          Group g ∧ (g act X) f ∧ FINITE X ⇒
          CARD X = CARD (fixed_points f g X) + ∑ CARD (multi_orbits f g X)
   
   [<a name="target_card_by_orbit_types-val"><b>target_card_by_orbit_types</b></a>]  Theorem
      
      ⊢ ∀f g X.
          Group g ∧ (g act X) f ∧ FINITE X ⇒
          CARD X = CARD (sing_orbits f g X) + ∑ CARD (multi_orbits f g X)
   
   [<a name="target_card_by_partition-val"><b>target_card_by_partition</b></a>]  Theorem
      
      ⊢ ∀f g X.
          Group g ∧ (g act X) f ∧ FINITE X ⇒ CARD X = ∑ CARD (orbits f g X)
   
   [<a name="target_orbits_disjoint-val"><b>target_orbits_disjoint</b></a>]  Theorem
      
      ⊢ ∀f g X. DISJOINT (sing_orbits f g X) (multi_orbits f g X)
   
   [<a name="target_orbits_union-val"><b>target_orbits_union</b></a>]  Theorem
      
      ⊢ ∀f g X. orbits f g X = sing_orbits f g X ∪ multi_orbits f g X
   
   [<a name="trivial_group-val"><b>trivial_group</b></a>]  Theorem
      
      ⊢ ∀e. FiniteAbelianGroup (trivial_group e)
   
   [<a name="trivial_group_carrier-val"><b>trivial_group_carrier</b></a>]  Theorem
      
      ⊢ ∀e. (trivial_group e).carrier = {e}
   
   [<a name="trivial_group_id-val"><b>trivial_group_id</b></a>]  Theorem
      
      ⊢ ∀e. (trivial_group e).id = e
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/algebra/construction/.hol/objs/groupScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-2</a></em></p></body></html>
