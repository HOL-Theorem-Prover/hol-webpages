<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure groupTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure groupTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/algebra/construction/.hol/objs/groupScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature groupTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#AbelianGroup_def-val">AbelianGroup_def</a> : thm
<a name="line7"></a>    val <a href="#CosetPartition_def-val">CosetPartition_def</a> : thm
<a name="line8"></a>    val <a href="#ElGamal_decrypt_def-val">ElGamal_decrypt_def</a> : thm
<a name="line9"></a>    val <a href="#ElGamal_encrypt_def-val">ElGamal_encrypt_def</a> : thm
<a name="line10"></a>    val <a href="#Estar_def-val">Estar_def</a> : thm
<a name="line11"></a>    val <a href="#FiniteAbelianGroup_def-val">FiniteAbelianGroup_def</a> : thm
<a name="line12"></a>    val <a href="#FiniteGroup_def-val">FiniteGroup_def</a> : thm
<a name="line13"></a>    val <a href="#GFACT_def-val">GFACT_def</a> : thm
<a name="line14"></a>    val <a href="#GROUP_IMAGE_def-val">GROUP_IMAGE_def</a> : thm
<a name="line15"></a>    val <a href="#Generated_def-val">Generated_def</a> : thm
<a name="line16"></a>    val <a href="#Generated_subset_def-val">Generated_subset_def</a> : thm
<a name="line17"></a>    val <a href="#GroupAuto_def-val">GroupAuto_def</a> : thm
<a name="line18"></a>    val <a href="#GroupEndo_def-val">GroupEndo_def</a> : thm
<a name="line19"></a>    val <a href="#GroupHomo_def-val">GroupHomo_def</a> : thm
<a name="line20"></a>    val <a href="#GroupIso_def-val">GroupIso_def</a> : thm
<a name="line21"></a>    val <a href="#Group_def-val">Group_def</a> : thm
<a name="line22"></a>    val <a href="#OP_IMAGE_def-val">OP_IMAGE_def</a> : thm
<a name="line23"></a>    val <a href="#StabilizerGroup_def-val">StabilizerGroup_def</a> : thm
<a name="line24"></a>    val <a href="#Subgroup_def-val">Subgroup_def</a> : thm
<a name="line25"></a>    val <a href="#Zadd_def-val">Zadd_def</a> : thm
<a name="line26"></a>    val <a href="#Zstar_def-val">Zstar_def</a> : thm
<a name="line27"></a>    val <a href="#act_by_def-val">act_by_def</a> : thm
<a name="line28"></a>    val <a href="#action_def-val">action_def</a> : thm
<a name="line29"></a>    val <a href="#add_mod_def-val">add_mod_def</a> : thm
<a name="line30"></a>    val <a href="#all_subgroups_def-val">all_subgroups_def</a> : thm
<a name="line31"></a>    val <a href="#cogen_def-val">cogen_def</a> : thm
<a name="line32"></a>    val <a href="#conjugate_def-val">conjugate_def</a> : thm
<a name="line33"></a>    val <a href="#conjugate_subgroup_def-val">conjugate_subgroup_def</a> : thm
<a name="line34"></a>    val <a href="#coset_def-val">coset_def</a> : thm
<a name="line35"></a>    val <a href="#coset_op_def-val">coset_op_def</a> : thm
<a name="line36"></a>    val <a href="#cyclic_def-val">cyclic_def</a> : thm
<a name="line37"></a>    val <a href="#cyclic_gen_def-val">cyclic_gen_def</a> : thm
<a name="line38"></a>    val <a href="#cyclic_generators_def-val">cyclic_generators_def</a> : thm
<a name="line39"></a>    val <a href="#cyclic_index_def-val">cyclic_index_def</a> : thm
<a name="line40"></a>    val <a href="#eq_order_def-val">eq_order_def</a> : thm
<a name="line41"></a>    val <a href="#excluding_def-val">excluding_def</a> : thm
<a name="line42"></a>    val <a href="#fixed_points_def-val">fixed_points_def</a> : thm
<a name="line43"></a>    val <a href="#fn_cyclic_group_def-val">fn_cyclic_group_def</a> : thm
<a name="line44"></a>    val <a href="#group_div_def-val">group_div_def</a> : thm
<a name="line45"></a>    val <a href="#group_equiv_def-val">group_equiv_def</a> : thm
<a name="line46"></a>    val <a href="#group_fun_def-val">group_fun_def</a> : thm
<a name="line47"></a>    val <a href="#homo_image_def-val">homo_image_def</a> : thm
<a name="line48"></a>    val <a href="#inCoset_def-val">inCoset_def</a> : thm
<a name="line49"></a>    val <a href="#including_def-val">including_def</a> : thm
<a name="line50"></a>    val <a href="#kernel_def-val">kernel_def</a> : thm
<a name="line51"></a>    val <a href="#kernel_group_def-val">kernel_group_def</a> : thm
<a name="line52"></a>    val <a href="#left_coset_def-val">left_coset_def</a> : thm
<a name="line53"></a>    val <a href="#make_group_def-val">make_group_def</a> : thm
<a name="line54"></a>    val <a href="#mult_mod_def-val">mult_mod_def</a> : thm
<a name="line55"></a>    val <a href="#multi_orbits_def-val">multi_orbits_def</a> : thm
<a name="line56"></a>    val <a href="#normal_subgroup_def-val">normal_subgroup_def</a> : thm
<a name="line57"></a>    val <a href="#orbit_def-val">orbit_def</a> : thm
<a name="line58"></a>    val <a href="#orbits_def-val">orbits_def</a> : thm
<a name="line59"></a>    val <a href="#preimage_group_def-val">preimage_group_def</a> : thm
<a name="line60"></a>    val <a href="#quotient_group_def-val">quotient_group_def</a> : thm
<a name="line61"></a>    val <a href="#reach_def-val">reach_def</a> : thm
<a name="line62"></a>    val <a href="#right_coset_def-val">right_coset_def</a> : thm
<a name="line63"></a>    val <a href="#roots_of_unity_def-val">roots_of_unity_def</a> : thm
<a name="line64"></a>    val <a href="#sing_orbits_def-val">sing_orbits_def</a> : thm
<a name="line65"></a>    val <a href="#stabilizer_def-val">stabilizer_def</a> : thm
<a name="line66"></a>    val <a href="#subgroup_big_cross_def-val">subgroup_big_cross_def</a> : thm
<a name="line67"></a>    val <a href="#subgroup_big_intersect_def-val">subgroup_big_intersect_def</a> : thm
<a name="line68"></a>    val <a href="#subgroup_cross_def-val">subgroup_cross_def</a> : thm
<a name="line69"></a>    val <a href="#subgroup_def-val">subgroup_def</a> : thm
<a name="line70"></a>    val <a href="#subset_big_cross_def-val">subset_big_cross_def</a> : thm
<a name="line71"></a>    val <a href="#subset_cross_def-val">subset_cross_def</a> : thm
<a name="line72"></a>    val <a href="#subset_cross_left_right_def-val">subset_cross_left_right_def</a> : thm
<a name="line73"></a>    val <a href="#subset_group_def-val">subset_group_def</a> : thm
<a name="line74"></a>    val <a href="#symdiff_def-val">symdiff_def</a> : thm
<a name="line75"></a>    val <a href="#symdiff_set_def-val">symdiff_set_def</a> : thm
<a name="line76"></a>    val <a href="#trivial_group_def-val">trivial_group_def</a> : thm
<a name="line77"></a>  
<a name="line78"></a>  (*  Theorems  *)
<a name="line79"></a>    val <a href="#ElGamal_correctness-val">ElGamal_correctness</a> : thm
<a name="line80"></a>    val <a href="#Estar_alt-val">Estar_alt</a> : thm
<a name="line81"></a>    val <a href="#Estar_card-val">Estar_card</a> : thm
<a name="line82"></a>    val <a href="#Estar_card_alt-val">Estar_card_alt</a> : thm
<a name="line83"></a>    val <a href="#Estar_carrier-val">Estar_carrier</a> : thm
<a name="line84"></a>    val <a href="#Estar_carrier_alt-val">Estar_carrier_alt</a> : thm
<a name="line85"></a>    val <a href="#Estar_element-val">Estar_element</a> : thm
<a name="line86"></a>    val <a href="#Estar_eval-val">Estar_eval</a> : thm
<a name="line87"></a>    val <a href="#Estar_exp-val">Estar_exp</a> : thm
<a name="line88"></a>    val <a href="#Estar_finite-val">Estar_finite</a> : thm
<a name="line89"></a>    val <a href="#Estar_finite_abelian_group-val">Estar_finite_abelian_group</a> : thm
<a name="line90"></a>    val <a href="#Estar_finite_group-val">Estar_finite_group</a> : thm
<a name="line91"></a>    val <a href="#Estar_group-val">Estar_group</a> : thm
<a name="line92"></a>    val <a href="#Estar_id-val">Estar_id</a> : thm
<a name="line93"></a>    val <a href="#Estar_inv-val">Estar_inv</a> : thm
<a name="line94"></a>    val <a href="#Estar_inv_compute-val">Estar_inv_compute</a> : thm
<a name="line95"></a>    val <a href="#Estar_property-val">Estar_property</a> : thm
<a name="line96"></a>    val <a href="#Euler_Fermat_alt-val">Euler_Fermat_alt</a> : thm
<a name="line97"></a>    val <a href="#Euler_Fermat_eqn-val">Euler_Fermat_eqn</a> : thm
<a name="line98"></a>    val <a href="#Euler_Fermat_thm-val">Euler_Fermat_thm</a> : thm
<a name="line99"></a>    val <a href="#Fermat_little_eqn-val">Fermat_little_eqn</a> : thm
<a name="line100"></a>    val <a href="#Fermat_little_thm-val">Fermat_little_thm</a> : thm
<a name="line101"></a>    val <a href="#FiniteAbelianGroup_def_alt-val">FiniteAbelianGroup_def_alt</a> : thm
<a name="line102"></a>    val <a href="#GFACT_element-val">GFACT_element</a> : thm
<a name="line103"></a>    val <a href="#GFACT_identity-val">GFACT_identity</a> : thm
<a name="line104"></a>    val <a href="#GITSET_AS_ITSET-val">GITSET_AS_ITSET</a> : thm
<a name="line105"></a>    val <a href="#GPROD_SET_AS_GROUP_IMAGE-val">GPROD_SET_AS_GROUP_IMAGE</a> : thm
<a name="line106"></a>    val <a href="#GPROD_SET_IMAGE-val">GPROD_SET_IMAGE</a> : thm
<a name="line107"></a>    val <a href="#GPROD_SET_REDUCTION-val">GPROD_SET_REDUCTION</a> : thm
<a name="line108"></a>    val <a href="#GPROD_SET_REDUCTION_INSERT-val">GPROD_SET_REDUCTION_INSERT</a> : thm
<a name="line109"></a>    val <a href="#Generated_subset_exp-val">Generated_subset_exp</a> : thm
<a name="line110"></a>    val <a href="#Generated_subset_gen-val">Generated_subset_gen</a> : thm
<a name="line111"></a>    val <a href="#Generated_subset_group-val">Generated_subset_group</a> : thm
<a name="line112"></a>    val <a href="#Generated_subset_has_set-val">Generated_subset_has_set</a> : thm
<a name="line113"></a>    val <a href="#Generated_subset_property-val">Generated_subset_property</a> : thm
<a name="line114"></a>    val <a href="#Generated_subset_subgroup-val">Generated_subset_subgroup</a> : thm
<a name="line115"></a>    val <a href="#Generated_subset_subset-val">Generated_subset_subset</a> : thm
<a name="line116"></a>    val <a href="#Invertibles_inv-val">Invertibles_inv</a> : thm
<a name="line117"></a>    val <a href="#Lagrange_identity-val">Lagrange_identity</a> : thm
<a name="line118"></a>    val <a href="#Lagrange_identity_alt-val">Lagrange_identity_alt</a> : thm
<a name="line119"></a>    val <a href="#Lagrange_thm-val">Lagrange_thm</a> : thm
<a name="line120"></a>    val <a href="#OP_IMAGE_EMPTY-val">OP_IMAGE_EMPTY</a> : thm
<a name="line121"></a>    val <a href="#OP_IMAGE_SING-val">OP_IMAGE_SING</a> : thm
<a name="line122"></a>    val <a href="#OP_IMAGE_THM-val">OP_IMAGE_THM</a> : thm
<a name="line123"></a>    val <a href="#PRIME_2-val">PRIME_2</a> : thm
<a name="line124"></a>    val <a href="#PRIME_3-val">PRIME_3</a> : thm
<a name="line125"></a>    val <a href="#PRIME_5-val">PRIME_5</a> : thm
<a name="line126"></a>    val <a href="#PRIME_7-val">PRIME_7</a> : thm
<a name="line127"></a>    val <a href="#SURJ_IMAGE_PREIMAGE-val">SURJ_IMAGE_PREIMAGE</a> : thm
<a name="line128"></a>    val <a href="#Subgroup_homo_homo-val">Subgroup_homo_homo</a> : thm
<a name="line129"></a>    val <a href="#Subgroup_subgroup-val">Subgroup_subgroup</a> : thm
<a name="line130"></a>    val <a href="#Zadd_card-val">Zadd_card</a> : thm
<a name="line131"></a>    val <a href="#Zadd_carrier-val">Zadd_carrier</a> : thm
<a name="line132"></a>    val <a href="#Zadd_carrier_alt-val">Zadd_carrier_alt</a> : thm
<a name="line133"></a>    val <a href="#Zadd_element-val">Zadd_element</a> : thm
<a name="line134"></a>    val <a href="#Zadd_eval-val">Zadd_eval</a> : thm
<a name="line135"></a>    val <a href="#Zadd_exp-val">Zadd_exp</a> : thm
<a name="line136"></a>    val <a href="#Zadd_finite-val">Zadd_finite</a> : thm
<a name="line137"></a>    val <a href="#Zadd_finite_abelian_group-val">Zadd_finite_abelian_group</a> : thm
<a name="line138"></a>    val <a href="#Zadd_finite_group-val">Zadd_finite_group</a> : thm
<a name="line139"></a>    val <a href="#Zadd_group-val">Zadd_group</a> : thm
<a name="line140"></a>    val <a href="#Zadd_id-val">Zadd_id</a> : thm
<a name="line141"></a>    val <a href="#Zadd_inv-val">Zadd_inv</a> : thm
<a name="line142"></a>    val <a href="#Zadd_inv_compute-val">Zadd_inv_compute</a> : thm
<a name="line143"></a>    val <a href="#Zadd_property-val">Zadd_property</a> : thm
<a name="line144"></a>    val <a href="#Zstar_card-val">Zstar_card</a> : thm
<a name="line145"></a>    val <a href="#Zstar_carrier-val">Zstar_carrier</a> : thm
<a name="line146"></a>    val <a href="#Zstar_carrier_alt-val">Zstar_carrier_alt</a> : thm
<a name="line147"></a>    val <a href="#Zstar_element-val">Zstar_element</a> : thm
<a name="line148"></a>    val <a href="#Zstar_eval-val">Zstar_eval</a> : thm
<a name="line149"></a>    val <a href="#Zstar_exp-val">Zstar_exp</a> : thm
<a name="line150"></a>    val <a href="#Zstar_finite-val">Zstar_finite</a> : thm
<a name="line151"></a>    val <a href="#Zstar_finite_abelian_group-val">Zstar_finite_abelian_group</a> : thm
<a name="line152"></a>    val <a href="#Zstar_finite_group-val">Zstar_finite_group</a> : thm
<a name="line153"></a>    val <a href="#Zstar_group-val">Zstar_group</a> : thm
<a name="line154"></a>    val <a href="#Zstar_id-val">Zstar_id</a> : thm
<a name="line155"></a>    val <a href="#Zstar_inv-val">Zstar_inv</a> : thm
<a name="line156"></a>    val <a href="#Zstar_inv_compute-val">Zstar_inv_compute</a> : thm
<a name="line157"></a>    val <a href="#Zstar_inverse-val">Zstar_inverse</a> : thm
<a name="line158"></a>    val <a href="#Zstar_inverse_compute-val">Zstar_inverse_compute</a> : thm
<a name="line159"></a>    val <a href="#Zstar_property-val">Zstar_property</a> : thm
<a name="line160"></a>    val <a href="#abelian_group_is_abelian_monoid-val">abelian_group_is_abelian_monoid</a> : thm
<a name="line161"></a>    val <a href="#abelian_group_order_common-val">abelian_group_order_common</a> : thm
<a name="line162"></a>    val <a href="#abelian_group_order_common_coprime-val">abelian_group_order_common_coprime</a> : thm
<a name="line163"></a>    val <a href="#abelian_monoid_invertible_excluding-val">abelian_monoid_invertible_excluding</a> : thm
<a name="line164"></a>    val <a href="#abelian_subgroup_abelian-val">abelian_subgroup_abelian</a> : thm
<a name="line165"></a>    val <a href="#abelian_subgroup_cross_finite-val">abelian_subgroup_cross_finite</a> : thm
<a name="line166"></a>    val <a href="#abelian_subgroup_cross_subgroup-val">abelian_subgroup_cross_subgroup</a> : thm
<a name="line167"></a>    val <a href="#action_closure-val">action_closure</a> : thm
<a name="line168"></a>    val <a href="#action_compose-val">action_compose</a> : thm
<a name="line169"></a>    val <a href="#action_id-val">action_id</a> : thm
<a name="line170"></a>    val <a href="#action_match_condition-val">action_match_condition</a> : thm
<a name="line171"></a>    val <a href="#action_match_condition_alt-val">action_match_condition_alt</a> : thm
<a name="line172"></a>    val <a href="#action_reachable_coset-val">action_reachable_coset</a> : thm
<a name="line173"></a>    val <a href="#action_reachable_coset_alt-val">action_reachable_coset_alt</a> : thm
<a name="line174"></a>    val <a href="#action_reverse-val">action_reverse</a> : thm
<a name="line175"></a>    val <a href="#action_to_orbit_surj-val">action_to_orbit_surj</a> : thm
<a name="line176"></a>    val <a href="#action_trans-val">action_trans</a> : thm
<a name="line177"></a>    val <a href="#add_mod_abelian_group-val">add_mod_abelian_group</a> : thm
<a name="line178"></a>    val <a href="#add_mod_card-val">add_mod_card</a> : thm
<a name="line179"></a>    val <a href="#add_mod_carrier-val">add_mod_carrier</a> : thm
<a name="line180"></a>    val <a href="#add_mod_carrier_alt-val">add_mod_carrier_alt</a> : thm
<a name="line181"></a>    val <a href="#add_mod_cylic-val">add_mod_cylic</a> : thm
<a name="line182"></a>    val <a href="#add_mod_element-val">add_mod_element</a> : thm
<a name="line183"></a>    val <a href="#add_mod_eval-val">add_mod_eval</a> : thm
<a name="line184"></a>    val <a href="#add_mod_exp-val">add_mod_exp</a> : thm
<a name="line185"></a>    val <a href="#add_mod_finite-val">add_mod_finite</a> : thm
<a name="line186"></a>    val <a href="#add_mod_finite_abelian_group-val">add_mod_finite_abelian_group</a> : thm
<a name="line187"></a>    val <a href="#add_mod_finite_group-val">add_mod_finite_group</a> : thm
<a name="line188"></a>    val <a href="#add_mod_group-val">add_mod_group</a> : thm
<a name="line189"></a>    val <a href="#add_mod_id-val">add_mod_id</a> : thm
<a name="line190"></a>    val <a href="#add_mod_inv-val">add_mod_inv</a> : thm
<a name="line191"></a>    val <a href="#add_mod_inv_compute-val">add_mod_inv_compute</a> : thm
<a name="line192"></a>    val <a href="#add_mod_order_1-val">add_mod_order_1</a> : thm
<a name="line193"></a>    val <a href="#add_mod_property-val">add_mod_property</a> : thm
<a name="line194"></a>    val <a href="#all_subgroups_element-val">all_subgroups_element</a> : thm
<a name="line195"></a>    val <a href="#all_subgroups_finite-val">all_subgroups_finite</a> : thm
<a name="line196"></a>    val <a href="#all_subgroups_has_gen_id-val">all_subgroups_has_gen_id</a> : thm
<a name="line197"></a>    val <a href="#all_subgroups_subset-val">all_subgroups_subset</a> : thm
<a name="line198"></a>    val <a href="#bij_corres-val">bij_corres</a> : thm
<a name="line199"></a>    val <a href="#carrier_card_by_coset_partition-val">carrier_card_by_coset_partition</a> : thm
<a name="line200"></a>    val <a href="#carrier_card_by_subgroup_coset_partition-val">carrier_card_by_subgroup_coset_partition</a> : thm
<a name="line201"></a>    val <a href="#cogen_coset_element-val">cogen_coset_element</a> : thm
<a name="line202"></a>    val <a href="#cogen_element-val">cogen_element</a> : thm
<a name="line203"></a>    val <a href="#cogen_of_subgroup-val">cogen_of_subgroup</a> : thm
<a name="line204"></a>    val <a href="#conjugate_subgroup_group-val">conjugate_subgroup_group</a> : thm
<a name="line205"></a>    val <a href="#conjugate_subgroup_subgroup-val">conjugate_subgroup_subgroup</a> : thm
<a name="line206"></a>    val <a href="#corres_thm-val">corres_thm</a> : thm
<a name="line207"></a>    val <a href="#coset_alt-val">coset_alt</a> : thm
<a name="line208"></a>    val <a href="#coset_cogen_property-val">coset_cogen_property</a> : thm
<a name="line209"></a>    val <a href="#coset_element-val">coset_element</a> : thm
<a name="line210"></a>    val <a href="#coset_empty-val">coset_empty</a> : thm
<a name="line211"></a>    val <a href="#coset_homo_group_iso_quotient_group-val">coset_homo_group_iso_quotient_group</a> : thm
<a name="line212"></a>    val <a href="#coset_id_eq_subgroup-val">coset_id_eq_subgroup</a> : thm
<a name="line213"></a>    val <a href="#coset_partition_card-val">coset_partition_card</a> : thm
<a name="line214"></a>    val <a href="#coset_partition_element-val">coset_partition_element</a> : thm
<a name="line215"></a>    val <a href="#coset_partition_element_card-val">coset_partition_element_card</a> : thm
<a name="line216"></a>    val <a href="#coset_partition_eq_coset_image-val">coset_partition_eq_coset_image</a> : thm
<a name="line217"></a>    val <a href="#coset_property-val">coset_property</a> : thm
<a name="line218"></a>    val <a href="#count_formula-val">count_formula</a> : thm
<a name="line219"></a>    val <a href="#cyclic_element-val">cyclic_element</a> : thm
<a name="line220"></a>    val <a href="#cyclic_element_by_gen-val">cyclic_element_by_gen</a> : thm
<a name="line221"></a>    val <a href="#cyclic_element_in_generated-val">cyclic_element_in_generated</a> : thm
<a name="line222"></a>    val <a href="#cyclic_eq_order_partition-val">cyclic_eq_order_partition</a> : thm
<a name="line223"></a>    val <a href="#cyclic_eq_order_partition_alt-val">cyclic_eq_order_partition_alt</a> : thm
<a name="line224"></a>    val <a href="#cyclic_eq_order_partition_by_card-val">cyclic_eq_order_partition_by_card</a> : thm
<a name="line225"></a>    val <a href="#cyclic_finite_alt-val">cyclic_finite_alt</a> : thm
<a name="line226"></a>    val <a href="#cyclic_finite_has_order_divisor-val">cyclic_finite_has_order_divisor</a> : thm
<a name="line227"></a>    val <a href="#cyclic_gen_element-val">cyclic_gen_element</a> : thm
<a name="line228"></a>    val <a href="#cyclic_gen_order-val">cyclic_gen_order</a> : thm
<a name="line229"></a>    val <a href="#cyclic_gen_power_order-val">cyclic_gen_power_order</a> : thm
<a name="line230"></a>    val <a href="#cyclic_generated_by_gen-val">cyclic_generated_by_gen</a> : thm
<a name="line231"></a>    val <a href="#cyclic_generated_group-val">cyclic_generated_group</a> : thm
<a name="line232"></a>    val <a href="#cyclic_generators_card-val">cyclic_generators_card</a> : thm
<a name="line233"></a>    val <a href="#cyclic_generators_coprimes_bij-val">cyclic_generators_coprimes_bij</a> : thm
<a name="line234"></a>    val <a href="#cyclic_generators_element-val">cyclic_generators_element</a> : thm
<a name="line235"></a>    val <a href="#cyclic_generators_finite-val">cyclic_generators_finite</a> : thm
<a name="line236"></a>    val <a href="#cyclic_generators_gen_cofactor_eq_orders-val">cyclic_generators_gen_cofactor_eq_orders</a> : thm
<a name="line237"></a>    val <a href="#cyclic_generators_nonempty-val">cyclic_generators_nonempty</a> : thm
<a name="line238"></a>    val <a href="#cyclic_generators_subset-val">cyclic_generators_subset</a> : thm
<a name="line239"></a>    val <a href="#cyclic_group-val">cyclic_group</a> : thm
<a name="line240"></a>    val <a href="#cyclic_group_abelian-val">cyclic_group_abelian</a> : thm
<a name="line241"></a>    val <a href="#cyclic_group_comm-val">cyclic_group_comm</a> : thm
<a name="line242"></a>    val <a href="#cyclic_image_ord_is_divisors-val">cyclic_image_ord_is_divisors</a> : thm
<a name="line243"></a>    val <a href="#cyclic_index_exists-val">cyclic_index_exists</a> : thm
<a name="line244"></a>    val <a href="#cyclic_iso_gen-val">cyclic_iso_gen</a> : thm
<a name="line245"></a>    val <a href="#cyclic_orders_card-val">cyclic_orders_card</a> : thm
<a name="line246"></a>    val <a href="#cyclic_orders_nonempty-val">cyclic_orders_nonempty</a> : thm
<a name="line247"></a>    val <a href="#cyclic_orders_partition-val">cyclic_orders_partition</a> : thm
<a name="line248"></a>    val <a href="#cyclic_subgroup_condition-val">cyclic_subgroup_condition</a> : thm
<a name="line249"></a>    val <a href="#cyclic_subgroup_cyclic-val">cyclic_subgroup_cyclic</a> : thm
<a name="line250"></a>    val <a href="#cyclic_uroots_cyclic-val">cyclic_uroots_cyclic</a> : thm
<a name="line251"></a>    val <a href="#cyclic_uroots_has_primitive-val">cyclic_uroots_has_primitive</a> : thm
<a name="line252"></a>    val <a href="#element_coset_property-val">element_coset_property</a> : thm
<a name="line253"></a>    val <a href="#eq_order_equiv-val">eq_order_equiv</a> : thm
<a name="line254"></a>    val <a href="#eq_order_is_feq_order-val">eq_order_is_feq_order</a> : thm
<a name="line255"></a>    val <a href="#fermat_little-val">fermat_little</a> : thm
<a name="line256"></a>    val <a href="#fermat_little_alt-val">fermat_little_alt</a> : thm
<a name="line257"></a>    val <a href="#fermat_little_thm-val">fermat_little_thm</a> : thm
<a name="line258"></a>    val <a href="#fermat_roots-val">fermat_roots</a> : thm
<a name="line259"></a>    val <a href="#finite_abelian_Fermat-val">finite_abelian_Fermat</a> : thm
<a name="line260"></a>    val <a href="#finite_abelian_group_is_finite_abelian_monoid-val">finite_abelian_group_is_finite_abelian_monoid</a> : thm
<a name="line261"></a>    val <a href="#finite_cyclic_group_add_mod_bij-val">finite_cyclic_group_add_mod_bij</a> : thm
<a name="line262"></a>    val <a href="#finite_cyclic_group_add_mod_homo-val">finite_cyclic_group_add_mod_homo</a> : thm
<a name="line263"></a>    val <a href="#finite_cyclic_group_add_mod_iso-val">finite_cyclic_group_add_mod_iso</a> : thm
<a name="line264"></a>    val <a href="#finite_cyclic_group_bij-val">finite_cyclic_group_bij</a> : thm
<a name="line265"></a>    val <a href="#finite_cyclic_group_existence-val">finite_cyclic_group_existence</a> : thm
<a name="line266"></a>    val <a href="#finite_cyclic_group_homo-val">finite_cyclic_group_homo</a> : thm
<a name="line267"></a>    val <a href="#finite_cyclic_group_iso-val">finite_cyclic_group_iso</a> : thm
<a name="line268"></a>    val <a href="#finite_cyclic_group_uniqueness-val">finite_cyclic_group_uniqueness</a> : thm
<a name="line269"></a>    val <a href="#finite_cyclic_index_add-val">finite_cyclic_index_add</a> : thm
<a name="line270"></a>    val <a href="#finite_cyclic_index_property-val">finite_cyclic_index_property</a> : thm
<a name="line271"></a>    val <a href="#finite_cyclic_index_unique-val">finite_cyclic_index_unique</a> : thm
<a name="line272"></a>    val <a href="#finite_group_Fermat-val">finite_group_Fermat</a> : thm
<a name="line273"></a>    val <a href="#finite_group_card_pos-val">finite_group_card_pos</a> : thm
<a name="line274"></a>    val <a href="#finite_group_exp_not_distinct-val">finite_group_exp_not_distinct</a> : thm
<a name="line275"></a>    val <a href="#finite_group_exp_period_exists-val">finite_group_exp_period_exists</a> : thm
<a name="line276"></a>    val <a href="#finite_group_is_finite_monoid-val">finite_group_is_finite_monoid</a> : thm
<a name="line277"></a>    val <a href="#finite_group_is_group-val">finite_group_is_group</a> : thm
<a name="line278"></a>    val <a href="#finite_group_is_monoid-val">finite_group_is_monoid</a> : thm
<a name="line279"></a>    val <a href="#finite_group_order-val">finite_group_order</a> : thm
<a name="line280"></a>    val <a href="#finite_group_primitive_property-val">finite_group_primitive_property</a> : thm
<a name="line281"></a>    val <a href="#finite_homo_image-val">finite_homo_image</a> : thm
<a name="line282"></a>    val <a href="#finite_monoid_invertibles_is_finite_group-val">finite_monoid_invertibles_is_finite_group</a> : thm
<a name="line283"></a>    val <a href="#finite_subgroup_carrier_finite-val">finite_subgroup_carrier_finite</a> : thm
<a name="line284"></a>    val <a href="#finite_subgroup_finite_group-val">finite_subgroup_finite_group</a> : thm
<a name="line285"></a>    val <a href="#fixed_points_element-val">fixed_points_element</a> : thm
<a name="line286"></a>    val <a href="#fixed_points_element_element-val">fixed_points_element_element</a> : thm
<a name="line287"></a>    val <a href="#fixed_points_finite-val">fixed_points_finite</a> : thm
<a name="line288"></a>    val <a href="#fixed_points_orbit_iff_sing-val">fixed_points_orbit_iff_sing</a> : thm
<a name="line289"></a>    val <a href="#fixed_points_orbit_sing-val">fixed_points_orbit_sing</a> : thm
<a name="line290"></a>    val <a href="#fixed_points_subset-val">fixed_points_subset</a> : thm
<a name="line291"></a>    val <a href="#fn_cyclic_group_alt-val">fn_cyclic_group_alt</a> : thm
<a name="line292"></a>    val <a href="#fn_cyclic_group_carrier-val">fn_cyclic_group_carrier</a> : thm
<a name="line293"></a>    val <a href="#fn_cyclic_group_finite_abelian_group-val">fn_cyclic_group_finite_abelian_group</a> : thm
<a name="line294"></a>    val <a href="#fn_cyclic_group_finite_group-val">fn_cyclic_group_finite_group</a> : thm
<a name="line295"></a>    val <a href="#fn_cyclic_group_group-val">fn_cyclic_group_group</a> : thm
<a name="line296"></a>    val <a href="#fn_cyclic_group_id-val">fn_cyclic_group_id</a> : thm
<a name="line297"></a>    val <a href="#generated_Fermat-val">generated_Fermat</a> : thm
<a name="line298"></a>    val <a href="#generated_carrier-val">generated_carrier</a> : thm
<a name="line299"></a>    val <a href="#generated_carrier_as_image-val">generated_carrier_as_image</a> : thm
<a name="line300"></a>    val <a href="#generated_carrier_has_id-val">generated_carrier_has_id</a> : thm
<a name="line301"></a>    val <a href="#generated_element-val">generated_element</a> : thm
<a name="line302"></a>    val <a href="#generated_exp-val">generated_exp</a> : thm
<a name="line303"></a>    val <a href="#generated_finite_group-val">generated_finite_group</a> : thm
<a name="line304"></a>    val <a href="#generated_gen_element-val">generated_gen_element</a> : thm
<a name="line305"></a>    val <a href="#generated_group-val">generated_group</a> : thm
<a name="line306"></a>    val <a href="#generated_group_card-val">generated_group_card</a> : thm
<a name="line307"></a>    val <a href="#generated_group_finite-val">generated_group_finite</a> : thm
<a name="line308"></a>    val <a href="#generated_id_carrier-val">generated_id_carrier</a> : thm
<a name="line309"></a>    val <a href="#generated_id_subgroup-val">generated_id_subgroup</a> : thm
<a name="line310"></a>    val <a href="#generated_image_subset_all_subgroups-val">generated_image_subset_all_subgroups</a> : thm
<a name="line311"></a>    val <a href="#generated_image_subset_power_set-val">generated_image_subset_power_set</a> : thm
<a name="line312"></a>    val <a href="#generated_property-val">generated_property</a> : thm
<a name="line313"></a>    val <a href="#generated_subgroup-val">generated_subgroup</a> : thm
<a name="line314"></a>    val <a href="#generated_subset-val">generated_subset</a> : thm
<a name="line315"></a>    val <a href="#group_all_invertible-val">group_all_invertible</a> : thm
<a name="line316"></a>    val <a href="#group_alt-val">group_alt</a> : thm
<a name="line317"></a>    val <a href="#group_assoc-val">group_assoc</a> : thm
<a name="line318"></a>    val <a href="#group_auto_I-val">group_auto_I</a> : thm
<a name="line319"></a>    val <a href="#group_auto_bij-val">group_auto_bij</a> : thm
<a name="line320"></a>    val <a href="#group_auto_compose-val">group_auto_compose</a> : thm
<a name="line321"></a>    val <a href="#group_auto_element-val">group_auto_element</a> : thm
<a name="line322"></a>    val <a href="#group_auto_exp-val">group_auto_exp</a> : thm
<a name="line323"></a>    val <a href="#group_auto_id-val">group_auto_id</a> : thm
<a name="line324"></a>    val <a href="#group_auto_is_monoid_auto-val">group_auto_is_monoid_auto</a> : thm
<a name="line325"></a>    val <a href="#group_auto_linv_auto-val">group_auto_linv_auto</a> : thm
<a name="line326"></a>    val <a href="#group_auto_order-val">group_auto_order</a> : thm
<a name="line327"></a>    val <a href="#group_carrier_nonempty-val">group_carrier_nonempty</a> : thm
<a name="line328"></a>    val <a href="#group_comm_exp-val">group_comm_exp</a> : thm
<a name="line329"></a>    val <a href="#group_comm_exp_exp-val">group_comm_exp_exp</a> : thm
<a name="line330"></a>    val <a href="#group_comm_op_exp-val">group_comm_op_exp</a> : thm
<a name="line331"></a>    val <a href="#group_coset_eq_itself-val">group_coset_eq_itself</a> : thm
<a name="line332"></a>    val <a href="#group_coset_is_permutation-val">group_coset_is_permutation</a> : thm
<a name="line333"></a>    val <a href="#group_def_alt-val">group_def_alt</a> : thm
<a name="line334"></a>    val <a href="#group_def_by_inverse-val">group_def_by_inverse</a> : thm
<a name="line335"></a>    val <a href="#group_div_cancel-val">group_div_cancel</a> : thm
<a name="line336"></a>    val <a href="#group_div_element-val">group_div_element</a> : thm
<a name="line337"></a>    val <a href="#group_div_lsame-val">group_div_lsame</a> : thm
<a name="line338"></a>    val <a href="#group_div_pair-val">group_div_pair</a> : thm
<a name="line339"></a>    val <a href="#group_div_rsame-val">group_div_rsame</a> : thm
<a name="line340"></a>    val <a href="#group_excluding_exp-val">group_excluding_exp</a> : thm
<a name="line341"></a>    val <a href="#group_excluding_op-val">group_excluding_op</a> : thm
<a name="line342"></a>    val <a href="#group_excluding_property-val">group_excluding_property</a> : thm
<a name="line343"></a>    val <a href="#group_exp_0-val">group_exp_0</a> : thm
<a name="line344"></a>    val <a href="#group_exp_1-val">group_exp_1</a> : thm
<a name="line345"></a>    val <a href="#group_exp_SUC-val">group_exp_SUC</a> : thm
<a name="line346"></a>    val <a href="#group_exp_add-val">group_exp_add</a> : thm
<a name="line347"></a>    val <a href="#group_exp_comm-val">group_exp_comm</a> : thm
<a name="line348"></a>    val <a href="#group_exp_element-val">group_exp_element</a> : thm
<a name="line349"></a>    val <a href="#group_exp_eq-val">group_exp_eq</a> : thm
<a name="line350"></a>    val <a href="#group_exp_eq_condition-val">group_exp_eq_condition</a> : thm
<a name="line351"></a>    val <a href="#group_exp_equal-val">group_exp_equal</a> : thm
<a name="line352"></a>    val <a href="#group_exp_inv-val">group_exp_inv</a> : thm
<a name="line353"></a>    val <a href="#group_exp_mod-val">group_exp_mod</a> : thm
<a name="line354"></a>    val <a href="#group_exp_mod_order-val">group_exp_mod_order</a> : thm
<a name="line355"></a>    val <a href="#group_exp_mult-val">group_exp_mult</a> : thm
<a name="line356"></a>    val <a href="#group_exp_mult_comm-val">group_exp_mult_comm</a> : thm
<a name="line357"></a>    val <a href="#group_exp_suc-val">group_exp_suc</a> : thm
<a name="line358"></a>    val <a href="#group_first_isomorphism_thm-val">group_first_isomorphism_thm</a> : thm
<a name="line359"></a>    val <a href="#group_homo_I_refl-val">group_homo_I_refl</a> : thm
<a name="line360"></a>    val <a href="#group_homo_compose-val">group_homo_compose</a> : thm
<a name="line361"></a>    val <a href="#group_homo_cong-val">group_homo_cong</a> : thm
<a name="line362"></a>    val <a href="#group_homo_element-val">group_homo_element</a> : thm
<a name="line363"></a>    val <a href="#group_homo_exp-val">group_homo_exp</a> : thm
<a name="line364"></a>    val <a href="#group_homo_homo_image_group-val">group_homo_homo_image_group</a> : thm
<a name="line365"></a>    val <a href="#group_homo_id-val">group_homo_id</a> : thm
<a name="line366"></a>    val <a href="#group_homo_image_surj_property-val">group_homo_image_surj_property</a> : thm
<a name="line367"></a>    val <a href="#group_homo_inv-val">group_homo_inv</a> : thm
<a name="line368"></a>    val <a href="#group_homo_is_monoid_homo-val">group_homo_is_monoid_homo</a> : thm
<a name="line369"></a>    val <a href="#group_homo_monoid_homo-val">group_homo_monoid_homo</a> : thm
<a name="line370"></a>    val <a href="#group_homo_sym-val">group_homo_sym</a> : thm
<a name="line371"></a>    val <a href="#group_homo_sym_any-val">group_homo_sym_any</a> : thm
<a name="line372"></a>    val <a href="#group_homo_trans-val">group_homo_trans</a> : thm
<a name="line373"></a>    val <a href="#group_id-val">group_id</a> : thm
<a name="line374"></a>    val <a href="#group_id_element-val">group_id_element</a> : thm
<a name="line375"></a>    val <a href="#group_id_exp-val">group_id_exp</a> : thm
<a name="line376"></a>    val <a href="#group_id_fix-val">group_id_fix</a> : thm
<a name="line377"></a>    val <a href="#group_id_id-val">group_id_id</a> : thm
<a name="line378"></a>    val <a href="#group_id_unique-val">group_id_unique</a> : thm
<a name="line379"></a>    val <a href="#group_image_as_op_image-val">group_image_as_op_image</a> : thm
<a name="line380"></a>    val <a href="#group_image_empty-val">group_image_empty</a> : thm
<a name="line381"></a>    val <a href="#group_image_sing-val">group_image_sing</a> : thm
<a name="line382"></a>    val <a href="#group_including_excluding_abelian-val">group_including_excluding_abelian</a> : thm
<a name="line383"></a>    val <a href="#group_including_excluding_eqn-val">group_including_excluding_eqn</a> : thm
<a name="line384"></a>    val <a href="#group_including_excluding_group-val">group_including_excluding_group</a> : thm
<a name="line385"></a>    val <a href="#group_including_excluding_property-val">group_including_excluding_property</a> : thm
<a name="line386"></a>    val <a href="#group_including_property-val">group_including_property</a> : thm
<a name="line387"></a>    val <a href="#group_inj_image_abelian_group-val">group_inj_image_abelian_group</a> : thm
<a name="line388"></a>    val <a href="#group_inj_image_excluding_abelian_group-val">group_inj_image_excluding_abelian_group</a> : thm
<a name="line389"></a>    val <a href="#group_inj_image_excluding_group-val">group_inj_image_excluding_group</a> : thm
<a name="line390"></a>    val <a href="#group_inj_image_group-val">group_inj_image_group</a> : thm
<a name="line391"></a>    val <a href="#group_inj_image_group_homo-val">group_inj_image_group_homo</a> : thm
<a name="line392"></a>    val <a href="#group_inv_element-val">group_inv_element</a> : thm
<a name="line393"></a>    val <a href="#group_inv_eq-val">group_inv_eq</a> : thm
<a name="line394"></a>    val <a href="#group_inv_eq_id-val">group_inv_eq_id</a> : thm
<a name="line395"></a>    val <a href="#group_inv_eq_swap-val">group_inv_eq_swap</a> : thm
<a name="line396"></a>    val <a href="#group_inv_exp-val">group_inv_exp</a> : thm
<a name="line397"></a>    val <a href="#group_inv_id-val">group_inv_id</a> : thm
<a name="line398"></a>    val <a href="#group_inv_inv-val">group_inv_inv</a> : thm
<a name="line399"></a>    val <a href="#group_inv_op-val">group_inv_op</a> : thm
<a name="line400"></a>    val <a href="#group_inv_order-val">group_inv_order</a> : thm
<a name="line401"></a>    val <a href="#group_inv_thm-val">group_inv_thm</a> : thm
<a name="line402"></a>    val <a href="#group_is_monoid-val">group_is_monoid</a> : thm
<a name="line403"></a>    val <a href="#group_iso_I_refl-val">group_iso_I_refl</a> : thm
<a name="line404"></a>    val <a href="#group_iso_bij-val">group_iso_bij</a> : thm
<a name="line405"></a>    val <a href="#group_iso_card_eq-val">group_iso_card_eq</a> : thm
<a name="line406"></a>    val <a href="#group_iso_compose-val">group_iso_compose</a> : thm
<a name="line407"></a>    val <a href="#group_iso_element-val">group_iso_element</a> : thm
<a name="line408"></a>    val <a href="#group_iso_exp-val">group_iso_exp</a> : thm
<a name="line409"></a>    val <a href="#group_iso_group-val">group_iso_group</a> : thm
<a name="line410"></a>    val <a href="#group_iso_id-val">group_iso_id</a> : thm
<a name="line411"></a>    val <a href="#group_iso_is_monoid_iso-val">group_iso_is_monoid_iso</a> : thm
<a name="line412"></a>    val <a href="#group_iso_linv_iso-val">group_iso_linv_iso</a> : thm
<a name="line413"></a>    val <a href="#group_iso_monoid_iso-val">group_iso_monoid_iso</a> : thm
<a name="line414"></a>    val <a href="#group_iso_order-val">group_iso_order</a> : thm
<a name="line415"></a>    val <a href="#group_iso_property-val">group_iso_property</a> : thm
<a name="line416"></a>    val <a href="#group_iso_sym-val">group_iso_sym</a> : thm
<a name="line417"></a>    val <a href="#group_iso_trans-val">group_iso_trans</a> : thm
<a name="line418"></a>    val <a href="#group_lcancel-val">group_lcancel</a> : thm
<a name="line419"></a>    val <a href="#group_lid-val">group_lid</a> : thm
<a name="line420"></a>    val <a href="#group_lid_unique-val">group_lid_unique</a> : thm
<a name="line421"></a>    val <a href="#group_linv-val">group_linv</a> : thm
<a name="line422"></a>    val <a href="#group_linv_assoc-val">group_linv_assoc</a> : thm
<a name="line423"></a>    val <a href="#group_linv_unique-val">group_linv_unique</a> : thm
<a name="line424"></a>    val <a href="#group_lsolve-val">group_lsolve</a> : thm
<a name="line425"></a>    val <a href="#group_normal_equiv-val">group_normal_equiv</a> : thm
<a name="line426"></a>    val <a href="#group_normal_equiv_property-val">group_normal_equiv_property</a> : thm
<a name="line427"></a>    val <a href="#group_normal_equiv_reflexive-val">group_normal_equiv_reflexive</a> : thm
<a name="line428"></a>    val <a href="#group_normal_equiv_symmetric-val">group_normal_equiv_symmetric</a> : thm
<a name="line429"></a>    val <a href="#group_normal_equiv_transitive-val">group_normal_equiv_transitive</a> : thm
<a name="line430"></a>    val <a href="#group_op_element-val">group_op_element</a> : thm
<a name="line431"></a>    val <a href="#group_op_linv_eq_id-val">group_op_linv_eq_id</a> : thm
<a name="line432"></a>    val <a href="#group_op_linv_eqn-val">group_op_linv_eqn</a> : thm
<a name="line433"></a>    val <a href="#group_op_rinv_eq_id-val">group_op_rinv_eq_id</a> : thm
<a name="line434"></a>    val <a href="#group_op_rinv_eqn-val">group_op_rinv_eqn</a> : thm
<a name="line435"></a>    val <a href="#group_order_cofactor-val">group_order_cofactor</a> : thm
<a name="line436"></a>    val <a href="#group_order_common-val">group_order_common</a> : thm
<a name="line437"></a>    val <a href="#group_order_common_coprime-val">group_order_common_coprime</a> : thm
<a name="line438"></a>    val <a href="#group_order_condition-val">group_order_condition</a> : thm
<a name="line439"></a>    val <a href="#group_order_divides-val">group_order_divides</a> : thm
<a name="line440"></a>    val <a href="#group_order_divides_exp-val">group_order_divides_exp</a> : thm
<a name="line441"></a>    val <a href="#group_order_divides_maximal-val">group_order_divides_maximal</a> : thm
<a name="line442"></a>    val <a href="#group_order_divisor-val">group_order_divisor</a> : thm
<a name="line443"></a>    val <a href="#group_order_eq_1-val">group_order_eq_1</a> : thm
<a name="line444"></a>    val <a href="#group_order_exp_cofactor-val">group_order_exp_cofactor</a> : thm
<a name="line445"></a>    val <a href="#group_order_id-val">group_order_id</a> : thm
<a name="line446"></a>    val <a href="#group_order_inv-val">group_order_inv</a> : thm
<a name="line447"></a>    val <a href="#group_order_nonzero-val">group_order_nonzero</a> : thm
<a name="line448"></a>    val <a href="#group_order_pos-val">group_order_pos</a> : thm
<a name="line449"></a>    val <a href="#group_order_power-val">group_order_power</a> : thm
<a name="line450"></a>    val <a href="#group_order_power_coprime-val">group_order_power_coprime</a> : thm
<a name="line451"></a>    val <a href="#group_order_power_eq_0-val">group_order_power_eq_0</a> : thm
<a name="line452"></a>    val <a href="#group_order_power_eq_order-val">group_order_power_eq_order</a> : thm
<a name="line453"></a>    val <a href="#group_order_power_eqn-val">group_order_power_eqn</a> : thm
<a name="line454"></a>    val <a href="#group_order_property-val">group_order_property</a> : thm
<a name="line455"></a>    val <a href="#group_order_thm-val">group_order_thm</a> : thm
<a name="line456"></a>    val <a href="#group_order_to_generated_bij-val">group_order_to_generated_bij</a> : thm
<a name="line457"></a>    val <a href="#group_order_unique-val">group_order_unique</a> : thm
<a name="line458"></a>    val <a href="#group_orders_eq_1-val">group_orders_eq_1</a> : thm
<a name="line459"></a>    val <a href="#group_pair_reduce-val">group_pair_reduce</a> : thm
<a name="line460"></a>    val <a href="#group_rcancel-val">group_rcancel</a> : thm
<a name="line461"></a>    val <a href="#group_rid-val">group_rid</a> : thm
<a name="line462"></a>    val <a href="#group_rid_unique-val">group_rid_unique</a> : thm
<a name="line463"></a>    val <a href="#group_rinv-val">group_rinv</a> : thm
<a name="line464"></a>    val <a href="#group_rinv_assoc-val">group_rinv_assoc</a> : thm
<a name="line465"></a>    val <a href="#group_rinv_unique-val">group_rinv_unique</a> : thm
<a name="line466"></a>    val <a href="#group_rsolve-val">group_rsolve</a> : thm
<a name="line467"></a>    val <a href="#group_uroots_group-val">group_uroots_group</a> : thm
<a name="line468"></a>    val <a href="#group_uroots_has_id-val">group_uroots_has_id</a> : thm
<a name="line469"></a>    val <a href="#group_uroots_subgroup-val">group_uroots_subgroup</a> : thm
<a name="line470"></a>    val <a href="#homo_count_formula-val">homo_count_formula</a> : thm
<a name="line471"></a>    val <a href="#homo_group_abelian_group-val">homo_group_abelian_group</a> : thm
<a name="line472"></a>    val <a href="#homo_group_assoc-val">homo_group_assoc</a> : thm
<a name="line473"></a>    val <a href="#homo_group_by_inj-val">homo_group_by_inj</a> : thm
<a name="line474"></a>    val <a href="#homo_group_closure-val">homo_group_closure</a> : thm
<a name="line475"></a>    val <a href="#homo_group_comm-val">homo_group_comm</a> : thm
<a name="line476"></a>    val <a href="#homo_group_group-val">homo_group_group</a> : thm
<a name="line477"></a>    val <a href="#homo_group_id-val">homo_group_id</a> : thm
<a name="line478"></a>    val <a href="#homo_group_inv-val">homo_group_inv</a> : thm
<a name="line479"></a>    val <a href="#homo_image_group-val">homo_image_group</a> : thm
<a name="line480"></a>    val <a href="#homo_image_homo_quotient_kernel-val">homo_image_homo_quotient_kernel</a> : thm
<a name="line481"></a>    val <a href="#homo_image_iso_quotient_kernel-val">homo_image_iso_quotient_kernel</a> : thm
<a name="line482"></a>    val <a href="#homo_image_monoid-val">homo_image_monoid</a> : thm
<a name="line483"></a>    val <a href="#homo_image_subgroup-val">homo_image_subgroup</a> : thm
<a name="line484"></a>    val <a href="#homo_image_to_quotient_kernel_bij-val">homo_image_to_quotient_kernel_bij</a> : thm
<a name="line485"></a>    val <a href="#homo_restrict_same_kernel-val">homo_restrict_same_kernel</a> : thm
<a name="line486"></a>    val <a href="#image_iso_preimage_quotient-val">image_iso_preimage_quotient</a> : thm
<a name="line487"></a>    val <a href="#image_preimage_group-val">image_preimage_group</a> : thm
<a name="line488"></a>    val <a href="#image_preimage_quotient_same_card-val">image_preimage_quotient_same_card</a> : thm
<a name="line489"></a>    val <a href="#image_subgroup_subgroup-val">image_subgroup_subgroup</a> : thm
<a name="line490"></a>    val <a href="#inCoset_equiv_on_carrier-val">inCoset_equiv_on_carrier</a> : thm
<a name="line491"></a>    val <a href="#inCoset_refl-val">inCoset_refl</a> : thm
<a name="line492"></a>    val <a href="#inCoset_sym-val">inCoset_sym</a> : thm
<a name="line493"></a>    val <a href="#inCoset_trans-val">inCoset_trans</a> : thm
<a name="line494"></a>    val <a href="#in_coset-val">in_coset</a> : thm
<a name="line495"></a>    val <a href="#independent_generated_eq-val">independent_generated_eq</a> : thm
<a name="line496"></a>    val <a href="#independent_generator_2_card-val">independent_generator_2_card</a> : thm
<a name="line497"></a>    val <a href="#independent_sym-val">independent_sym</a> : thm
<a name="line498"></a>    val <a href="#iso_group_same_card-val">iso_group_same_card</a> : thm
<a name="line499"></a>    val <a href="#kernel_element-val">kernel_element</a> : thm
<a name="line500"></a>    val <a href="#kernel_group_group-val">kernel_group_group</a> : thm
<a name="line501"></a>    val <a href="#kernel_group_normal-val">kernel_group_normal</a> : thm
<a name="line502"></a>    val <a href="#kernel_group_subgroup-val">kernel_group_subgroup</a> : thm
<a name="line503"></a>    val <a href="#kernel_property-val">kernel_property</a> : thm
<a name="line504"></a>    val <a href="#kernel_quotient_group-val">kernel_quotient_group</a> : thm
<a name="line505"></a>    val <a href="#left_coset_alt-val">left_coset_alt</a> : thm
<a name="line506"></a>    val <a href="#make_group_property-val">make_group_property</a> : thm
<a name="line507"></a>    val <a href="#monoid_homo_homo_image_monoid-val">monoid_homo_homo_image_monoid</a> : thm
<a name="line508"></a>    val <a href="#monoid_inv_id-val">monoid_inv_id</a> : thm
<a name="line509"></a>    val <a href="#monoid_inv_order-val">monoid_inv_order</a> : thm
<a name="line510"></a>    val <a href="#monoid_inv_order_property-val">monoid_inv_order_property</a> : thm
<a name="line511"></a>    val <a href="#monoid_invertibles_is_group-val">monoid_invertibles_is_group</a> : thm
<a name="line512"></a>    val <a href="#mult_mod_abelian_group-val">mult_mod_abelian_group</a> : thm
<a name="line513"></a>    val <a href="#mult_mod_card-val">mult_mod_card</a> : thm
<a name="line514"></a>    val <a href="#mult_mod_carrier-val">mult_mod_carrier</a> : thm
<a name="line515"></a>    val <a href="#mult_mod_carrier_alt-val">mult_mod_carrier_alt</a> : thm
<a name="line516"></a>    val <a href="#mult_mod_element-val">mult_mod_element</a> : thm
<a name="line517"></a>    val <a href="#mult_mod_element_alt-val">mult_mod_element_alt</a> : thm
<a name="line518"></a>    val <a href="#mult_mod_eval-val">mult_mod_eval</a> : thm
<a name="line519"></a>    val <a href="#mult_mod_exp-val">mult_mod_exp</a> : thm
<a name="line520"></a>    val <a href="#mult_mod_finite-val">mult_mod_finite</a> : thm
<a name="line521"></a>    val <a href="#mult_mod_finite_abelian_group-val">mult_mod_finite_abelian_group</a> : thm
<a name="line522"></a>    val <a href="#mult_mod_finite_group-val">mult_mod_finite_group</a> : thm
<a name="line523"></a>    val <a href="#mult_mod_group-val">mult_mod_group</a> : thm
<a name="line524"></a>    val <a href="#mult_mod_id-val">mult_mod_id</a> : thm
<a name="line525"></a>    val <a href="#mult_mod_inv-val">mult_mod_inv</a> : thm
<a name="line526"></a>    val <a href="#mult_mod_inv_compute-val">mult_mod_inv_compute</a> : thm
<a name="line527"></a>    val <a href="#mult_mod_inverse-val">mult_mod_inverse</a> : thm
<a name="line528"></a>    val <a href="#mult_mod_inverse_compute-val">mult_mod_inverse_compute</a> : thm
<a name="line529"></a>    val <a href="#mult_mod_property-val">mult_mod_property</a> : thm
<a name="line530"></a>    val <a href="#multi_orbits_element-val">multi_orbits_element</a> : thm
<a name="line531"></a>    val <a href="#multi_orbits_element_finite-val">multi_orbits_element_finite</a> : thm
<a name="line532"></a>    val <a href="#multi_orbits_element_subset-val">multi_orbits_element_subset</a> : thm
<a name="line533"></a>    val <a href="#multi_orbits_finite-val">multi_orbits_finite</a> : thm
<a name="line534"></a>    val <a href="#multi_orbits_subset-val">multi_orbits_subset</a> : thm
<a name="line535"></a>    val <a href="#non_fixed_points_card-val">non_fixed_points_card</a> : thm
<a name="line536"></a>    val <a href="#non_fixed_points_orbit_not_sing-val">non_fixed_points_orbit_not_sing</a> : thm
<a name="line537"></a>    val <a href="#normal_cogen_property-val">normal_cogen_property</a> : thm
<a name="line538"></a>    val <a href="#normal_coset_op_property-val">normal_coset_op_property</a> : thm
<a name="line539"></a>    val <a href="#normal_coset_property-val">normal_coset_property</a> : thm
<a name="line540"></a>    val <a href="#normal_coset_property1-val">normal_coset_property1</a> : thm
<a name="line541"></a>    val <a href="#normal_coset_property2-val">normal_coset_property2</a> : thm
<a name="line542"></a>    val <a href="#normal_iff_preimage_normal-val">normal_iff_preimage_normal</a> : thm
<a name="line543"></a>    val <a href="#normal_preimage_normal-val">normal_preimage_normal</a> : thm
<a name="line544"></a>    val <a href="#normal_subgroup_alt-val">normal_subgroup_alt</a> : thm
<a name="line545"></a>    val <a href="#normal_subgroup_antisym-val">normal_subgroup_antisym</a> : thm
<a name="line546"></a>    val <a href="#normal_subgroup_coset_eq-val">normal_subgroup_coset_eq</a> : thm
<a name="line547"></a>    val <a href="#normal_subgroup_coset_homo-val">normal_subgroup_coset_homo</a> : thm
<a name="line548"></a>    val <a href="#normal_subgroup_groups-val">normal_subgroup_groups</a> : thm
<a name="line549"></a>    val <a href="#normal_subgroup_property-val">normal_subgroup_property</a> : thm
<a name="line550"></a>    val <a href="#normal_subgroup_refl-val">normal_subgroup_refl</a> : thm
<a name="line551"></a>    val <a href="#normal_subgroup_subgroup-val">normal_subgroup_subgroup</a> : thm
<a name="line552"></a>    val <a href="#normal_surj_normal-val">normal_surj_normal</a> : thm
<a name="line553"></a>    val <a href="#orbit_alt-val">orbit_alt</a> : thm
<a name="line554"></a>    val <a href="#orbit_card_divides_target_card-val">orbit_card_divides_target_card</a> : thm
<a name="line555"></a>    val <a href="#orbit_element-val">orbit_element</a> : thm
<a name="line556"></a>    val <a href="#orbit_element_in_target-val">orbit_element_in_target</a> : thm
<a name="line557"></a>    val <a href="#orbit_eq_equiv_class-val">orbit_eq_equiv_class</a> : thm
<a name="line558"></a>    val <a href="#orbit_eq_orbit-val">orbit_eq_orbit</a> : thm
<a name="line559"></a>    val <a href="#orbit_finite-val">orbit_finite</a> : thm
<a name="line560"></a>    val <a href="#orbit_finite_by_target-val">orbit_finite_by_target</a> : thm
<a name="line561"></a>    val <a href="#orbit_finite_inj_card_eq-val">orbit_finite_inj_card_eq</a> : thm
<a name="line562"></a>    val <a href="#orbit_has_action_element-val">orbit_has_action_element</a> : thm
<a name="line563"></a>    val <a href="#orbit_has_self-val">orbit_has_self</a> : thm
<a name="line564"></a>    val <a href="#orbit_is_orbits_element-val">orbit_is_orbits_element</a> : thm
<a name="line565"></a>    val <a href="#orbit_sing_fixed_points-val">orbit_sing_fixed_points</a> : thm
<a name="line566"></a>    val <a href="#orbit_stabilizer_cosets_bij-val">orbit_stabilizer_cosets_bij</a> : thm
<a name="line567"></a>    val <a href="#orbit_stabilizer_cosets_bij_alt-val">orbit_stabilizer_cosets_bij_alt</a> : thm
<a name="line568"></a>    val <a href="#orbit_stabilizer_map_good-val">orbit_stabilizer_map_good</a> : thm
<a name="line569"></a>    val <a href="#orbit_stabilizer_map_inj-val">orbit_stabilizer_map_inj</a> : thm
<a name="line570"></a>    val <a href="#orbit_stabilizer_thm-val">orbit_stabilizer_thm</a> : thm
<a name="line571"></a>    val <a href="#orbit_subset_target-val">orbit_subset_target</a> : thm
<a name="line572"></a>    val <a href="#orbits_alt-val">orbits_alt</a> : thm
<a name="line573"></a>    val <a href="#orbits_element-val">orbits_element</a> : thm
<a name="line574"></a>    val <a href="#orbits_element_element-val">orbits_element_element</a> : thm
<a name="line575"></a>    val <a href="#orbits_element_finite-val">orbits_element_finite</a> : thm
<a name="line576"></a>    val <a href="#orbits_element_is_orbit-val">orbits_element_is_orbit</a> : thm
<a name="line577"></a>    val <a href="#orbits_element_nonempty-val">orbits_element_nonempty</a> : thm
<a name="line578"></a>    val <a href="#orbits_element_subset-val">orbits_element_subset</a> : thm
<a name="line579"></a>    val <a href="#orbits_eq_partition-val">orbits_eq_partition</a> : thm
<a name="line580"></a>    val <a href="#orbits_equal_size_partition_equal_size-val">orbits_equal_size_partition_equal_size</a> : thm
<a name="line581"></a>    val <a href="#orbits_equal_size_property-val">orbits_equal_size_property</a> : thm
<a name="line582"></a>    val <a href="#orbits_finite-val">orbits_finite</a> : thm
<a name="line583"></a>    val <a href="#orbits_size_factor_partition_factor-val">orbits_size_factor_partition_factor</a> : thm
<a name="line584"></a>    val <a href="#orbits_size_factor_property-val">orbits_size_factor_property</a> : thm
<a name="line585"></a>    val <a href="#orders_is_feq_class_order-val">orders_is_feq_class_order</a> : thm
<a name="line586"></a>    val <a href="#preimage_cardinality-val">preimage_cardinality</a> : thm
<a name="line587"></a>    val <a href="#preimage_group_group-val">preimage_group_group</a> : thm
<a name="line588"></a>    val <a href="#preimage_group_property-val">preimage_group_property</a> : thm
<a name="line589"></a>    val <a href="#preimage_image_subset-val">preimage_image_subset</a> : thm
<a name="line590"></a>    val <a href="#preimage_subgroup_kernel-val">preimage_subgroup_kernel</a> : thm
<a name="line591"></a>    val <a href="#preimage_subgroup_subgroup-val">preimage_subgroup_subgroup</a> : thm
<a name="line592"></a>    val <a href="#prod_image_as_op_image-val">prod_image_as_op_image</a> : thm
<a name="line593"></a>    val <a href="#quotient_group_assoc-val">quotient_group_assoc</a> : thm
<a name="line594"></a>    val <a href="#quotient_group_closure-val">quotient_group_closure</a> : thm
<a name="line595"></a>    val <a href="#quotient_group_group-val">quotient_group_group</a> : thm
<a name="line596"></a>    val <a href="#quotient_group_id-val">quotient_group_id</a> : thm
<a name="line597"></a>    val <a href="#quotient_group_inv-val">quotient_group_inv</a> : thm
<a name="line598"></a>    val <a href="#reach_equiv-val">reach_equiv</a> : thm
<a name="line599"></a>    val <a href="#reach_refl-val">reach_refl</a> : thm
<a name="line600"></a>    val <a href="#reach_sym-val">reach_sym</a> : thm
<a name="line601"></a>    val <a href="#reach_trans-val">reach_trans</a> : thm
<a name="line602"></a>    val <a href="#right_coset_alt-val">right_coset_alt</a> : thm
<a name="line603"></a>    val <a href="#roots_of_unity_0-val">roots_of_unity_0</a> : thm
<a name="line604"></a>    val <a href="#roots_of_unity_element-val">roots_of_unity_element</a> : thm
<a name="line605"></a>    val <a href="#roots_of_unity_subset-val">roots_of_unity_subset</a> : thm
<a name="line606"></a>    val <a href="#sing_orbits_card_eqn-val">sing_orbits_card_eqn</a> : thm
<a name="line607"></a>    val <a href="#sing_orbits_element-val">sing_orbits_element</a> : thm
<a name="line608"></a>    val <a href="#sing_orbits_element_card-val">sing_orbits_element_card</a> : thm
<a name="line609"></a>    val <a href="#sing_orbits_element_choice-val">sing_orbits_element_choice</a> : thm
<a name="line610"></a>    val <a href="#sing_orbits_element_finite-val">sing_orbits_element_finite</a> : thm
<a name="line611"></a>    val <a href="#sing_orbits_element_subset-val">sing_orbits_element_subset</a> : thm
<a name="line612"></a>    val <a href="#sing_orbits_finite-val">sing_orbits_finite</a> : thm
<a name="line613"></a>    val <a href="#sing_orbits_subset-val">sing_orbits_subset</a> : thm
<a name="line614"></a>    val <a href="#sing_orbits_to_fixed_points_bij-val">sing_orbits_to_fixed_points_bij</a> : thm
<a name="line615"></a>    val <a href="#sing_orbits_to_fixed_points_inj-val">sing_orbits_to_fixed_points_inj</a> : thm
<a name="line616"></a>    val <a href="#sing_orbits_to_fixed_points_surj-val">sing_orbits_to_fixed_points_surj</a> : thm
<a name="line617"></a>    val <a href="#stabilizer_as_image-val">stabilizer_as_image</a> : thm
<a name="line618"></a>    val <a href="#stabilizer_conjugate-val">stabilizer_conjugate</a> : thm
<a name="line619"></a>    val <a href="#stabilizer_element-val">stabilizer_element</a> : thm
<a name="line620"></a>    val <a href="#stabilizer_group_card_divides-val">stabilizer_group_card_divides</a> : thm
<a name="line621"></a>    val <a href="#stabilizer_group_carrier-val">stabilizer_group_carrier</a> : thm
<a name="line622"></a>    val <a href="#stabilizer_group_finite_group-val">stabilizer_group_finite_group</a> : thm
<a name="line623"></a>    val <a href="#stabilizer_group_group-val">stabilizer_group_group</a> : thm
<a name="line624"></a>    val <a href="#stabilizer_group_id-val">stabilizer_group_id</a> : thm
<a name="line625"></a>    val <a href="#stabilizer_group_property-val">stabilizer_group_property</a> : thm
<a name="line626"></a>    val <a href="#stabilizer_group_subgroup-val">stabilizer_group_subgroup</a> : thm
<a name="line627"></a>    val <a href="#stabilizer_has_id-val">stabilizer_has_id</a> : thm
<a name="line628"></a>    val <a href="#stabilizer_nonempty-val">stabilizer_nonempty</a> : thm
<a name="line629"></a>    val <a href="#stabilizer_subset-val">stabilizer_subset</a> : thm
<a name="line630"></a>    val <a href="#subgroup_I_antisym-val">subgroup_I_antisym</a> : thm
<a name="line631"></a>    val <a href="#subgroup_alt-val">subgroup_alt</a> : thm
<a name="line632"></a>    val <a href="#subgroup_antisym-val">subgroup_antisym</a> : thm
<a name="line633"></a>    val <a href="#subgroup_big_cross_empty-val">subgroup_big_cross_empty</a> : thm
<a name="line634"></a>    val <a href="#subgroup_big_cross_insert-val">subgroup_big_cross_insert</a> : thm
<a name="line635"></a>    val <a href="#subgroup_big_cross_thm-val">subgroup_big_cross_thm</a> : thm
<a name="line636"></a>    val <a href="#subgroup_big_intersect_element-val">subgroup_big_intersect_element</a> : thm
<a name="line637"></a>    val <a href="#subgroup_big_intersect_group-val">subgroup_big_intersect_group</a> : thm
<a name="line638"></a>    val <a href="#subgroup_big_intersect_has_id-val">subgroup_big_intersect_has_id</a> : thm
<a name="line639"></a>    val <a href="#subgroup_big_intersect_has_inv-val">subgroup_big_intersect_has_inv</a> : thm
<a name="line640"></a>    val <a href="#subgroup_big_intersect_op_element-val">subgroup_big_intersect_op_element</a> : thm
<a name="line641"></a>    val <a href="#subgroup_big_intersect_property-val">subgroup_big_intersect_property</a> : thm
<a name="line642"></a>    val <a href="#subgroup_big_intersect_subgroup-val">subgroup_big_intersect_subgroup</a> : thm
<a name="line643"></a>    val <a href="#subgroup_big_intersect_subset-val">subgroup_big_intersect_subset</a> : thm
<a name="line644"></a>    val <a href="#subgroup_carrier_antisym-val">subgroup_carrier_antisym</a> : thm
<a name="line645"></a>    val <a href="#subgroup_carrier_nonempty-val">subgroup_carrier_nonempty</a> : thm
<a name="line646"></a>    val <a href="#subgroup_carrier_subset-val">subgroup_carrier_subset</a> : thm
<a name="line647"></a>    val <a href="#subgroup_conjugate_subgroup_bij-val">subgroup_conjugate_subgroup_bij</a> : thm
<a name="line648"></a>    val <a href="#subgroup_coset_card-val">subgroup_coset_card</a> : thm
<a name="line649"></a>    val <a href="#subgroup_coset_card_partition_element-val">subgroup_coset_card_partition_element</a> : thm
<a name="line650"></a>    val <a href="#subgroup_coset_eq-val">subgroup_coset_eq</a> : thm
<a name="line651"></a>    val <a href="#subgroup_coset_in_partition-val">subgroup_coset_in_partition</a> : thm
<a name="line652"></a>    val <a href="#subgroup_coset_nonempty-val">subgroup_coset_nonempty</a> : thm
<a name="line653"></a>    val <a href="#subgroup_coset_partition_element-val">subgroup_coset_partition_element</a> : thm
<a name="line654"></a>    val <a href="#subgroup_coset_subset-val">subgroup_coset_subset</a> : thm
<a name="line655"></a>    val <a href="#subgroup_coset_sym-val">subgroup_coset_sym</a> : thm
<a name="line656"></a>    val <a href="#subgroup_coset_trans-val">subgroup_coset_trans</a> : thm
<a name="line657"></a>    val <a href="#subgroup_cross_assoc-val">subgroup_cross_assoc</a> : thm
<a name="line658"></a>    val <a href="#subgroup_cross_card-val">subgroup_cross_card</a> : thm
<a name="line659"></a>    val <a href="#subgroup_cross_card_eqn-val">subgroup_cross_card_eqn</a> : thm
<a name="line660"></a>    val <a href="#subgroup_cross_closure_comm_assoc_fun-val">subgroup_cross_closure_comm_assoc_fun</a> : thm
<a name="line661"></a>    val <a href="#subgroup_cross_comm-val">subgroup_cross_comm</a> : thm
<a name="line662"></a>    val <a href="#subgroup_cross_finite-val">subgroup_cross_finite</a> : thm
<a name="line663"></a>    val <a href="#subgroup_cross_group-val">subgroup_cross_group</a> : thm
<a name="line664"></a>    val <a href="#subgroup_cross_property-val">subgroup_cross_property</a> : thm
<a name="line665"></a>    val <a href="#subgroup_cross_self-val">subgroup_cross_self</a> : thm
<a name="line666"></a>    val <a href="#subgroup_cross_subgroup-val">subgroup_cross_subgroup</a> : thm
<a name="line667"></a>    val <a href="#subgroup_element-val">subgroup_element</a> : thm
<a name="line668"></a>    val <a href="#subgroup_eq-val">subgroup_eq</a> : thm
<a name="line669"></a>    val <a href="#subgroup_eq_carrier-val">subgroup_eq_carrier</a> : thm
<a name="line670"></a>    val <a href="#subgroup_eqn-val">subgroup_eqn</a> : thm
<a name="line671"></a>    val <a href="#subgroup_exp-val">subgroup_exp</a> : thm
<a name="line672"></a>    val <a href="#subgroup_groups-val">subgroup_groups</a> : thm
<a name="line673"></a>    val <a href="#subgroup_has_groups-val">subgroup_has_groups</a> : thm
<a name="line674"></a>    val <a href="#subgroup_homo_homo-val">subgroup_homo_homo</a> : thm
<a name="line675"></a>    val <a href="#subgroup_homomorphism-val">subgroup_homomorphism</a> : thm
<a name="line676"></a>    val <a href="#subgroup_id-val">subgroup_id</a> : thm
<a name="line677"></a>    val <a href="#subgroup_incoset_equiv-val">subgroup_incoset_equiv</a> : thm
<a name="line678"></a>    val <a href="#subgroup_intersect_group-val">subgroup_intersect_group</a> : thm
<a name="line679"></a>    val <a href="#subgroup_intersect_has_inv-val">subgroup_intersect_has_inv</a> : thm
<a name="line680"></a>    val <a href="#subgroup_intersect_inv-val">subgroup_intersect_inv</a> : thm
<a name="line681"></a>    val <a href="#subgroup_intersect_property-val">subgroup_intersect_property</a> : thm
<a name="line682"></a>    val <a href="#subgroup_intersect_subgroup-val">subgroup_intersect_subgroup</a> : thm
<a name="line683"></a>    val <a href="#subgroup_inv-val">subgroup_inv</a> : thm
<a name="line684"></a>    val <a href="#subgroup_inv_closure-val">subgroup_inv_closure</a> : thm
<a name="line685"></a>    val <a href="#subgroup_is_group-val">subgroup_is_group</a> : thm
<a name="line686"></a>    val <a href="#subgroup_is_submonoid-val">subgroup_is_submonoid</a> : thm
<a name="line687"></a>    val <a href="#subgroup_is_submonoid0-val">subgroup_is_submonoid0</a> : thm
<a name="line688"></a>    val <a href="#subgroup_op-val">subgroup_op</a> : thm
<a name="line689"></a>    val <a href="#subgroup_order-val">subgroup_order</a> : thm
<a name="line690"></a>    val <a href="#subgroup_order_eqn-val">subgroup_order_eqn</a> : thm
<a name="line691"></a>    val <a href="#subgroup_property-val">subgroup_property</a> : thm
<a name="line692"></a>    val <a href="#subgroup_property_all-val">subgroup_property_all</a> : thm
<a name="line693"></a>    val <a href="#subgroup_refl-val">subgroup_refl</a> : thm
<a name="line694"></a>    val <a href="#subgroup_reflexive-val">subgroup_reflexive</a> : thm
<a name="line695"></a>    val <a href="#subgroup_subset-val">subgroup_subset</a> : thm
<a name="line696"></a>    val <a href="#subgroup_test_by_cross-val">subgroup_test_by_cross</a> : thm
<a name="line697"></a>    val <a href="#subgroup_thm-val">subgroup_thm</a> : thm
<a name="line698"></a>    val <a href="#subgroup_to_coset_bij-val">subgroup_to_coset_bij</a> : thm
<a name="line699"></a>    val <a href="#subgroup_trans-val">subgroup_trans</a> : thm
<a name="line700"></a>    val <a href="#subgroup_transitive-val">subgroup_transitive</a> : thm
<a name="line701"></a>    val <a href="#subset_big_cross_empty-val">subset_big_cross_empty</a> : thm
<a name="line702"></a>    val <a href="#subset_big_cross_insert-val">subset_big_cross_insert</a> : thm
<a name="line703"></a>    val <a href="#subset_big_cross_thm-val">subset_big_cross_thm</a> : thm
<a name="line704"></a>    val <a href="#subset_cross_alt-val">subset_cross_alt</a> : thm
<a name="line705"></a>    val <a href="#subset_cross_assoc-val">subset_cross_assoc</a> : thm
<a name="line706"></a>    val <a href="#subset_cross_closure_comm_assoc_fun-val">subset_cross_closure_comm_assoc_fun</a> : thm
<a name="line707"></a>    val <a href="#subset_cross_comm-val">subset_cross_comm</a> : thm
<a name="line708"></a>    val <a href="#subset_cross_element-val">subset_cross_element</a> : thm
<a name="line709"></a>    val <a href="#subset_cross_element_iff-val">subset_cross_element_iff</a> : thm
<a name="line710"></a>    val <a href="#subset_cross_element_preimage_card-val">subset_cross_element_preimage_card</a> : thm
<a name="line711"></a>    val <a href="#subset_cross_finite-val">subset_cross_finite</a> : thm
<a name="line712"></a>    val <a href="#subset_cross_inv-val">subset_cross_inv</a> : thm
<a name="line713"></a>    val <a href="#subset_cross_partition_property-val">subset_cross_partition_property</a> : thm
<a name="line714"></a>    val <a href="#subset_cross_preimage_inj-val">subset_cross_preimage_inj</a> : thm
<a name="line715"></a>    val <a href="#subset_cross_self-val">subset_cross_self</a> : thm
<a name="line716"></a>    val <a href="#subset_cross_subset-val">subset_cross_subset</a> : thm
<a name="line717"></a>    val <a href="#subset_cross_to_preimage_cross_bij-val">subset_cross_to_preimage_cross_bij</a> : thm
<a name="line718"></a>    val <a href="#subset_group_exp-val">subset_group_exp</a> : thm
<a name="line719"></a>    val <a href="#subset_group_order-val">subset_group_order</a> : thm
<a name="line720"></a>    val <a href="#subset_group_property-val">subset_group_property</a> : thm
<a name="line721"></a>    val <a href="#subset_group_subgroup-val">subset_group_subgroup</a> : thm
<a name="line722"></a>    val <a href="#subset_group_submonoid-val">subset_group_submonoid</a> : thm
<a name="line723"></a>    val <a href="#subset_preimage_image-val">subset_preimage_image</a> : thm
<a name="line724"></a>    val <a href="#sum_image_as_op_image-val">sum_image_as_op_image</a> : thm
<a name="line725"></a>    val <a href="#symdiff_set_abelian_group-val">symdiff_set_abelian_group</a> : thm
<a name="line726"></a>    val <a href="#symdiff_set_group-val">symdiff_set_group</a> : thm
<a name="line727"></a>    val <a href="#target_card_and_fixed_points_congruence-val">target_card_and_fixed_points_congruence</a> : thm
<a name="line728"></a>    val <a href="#target_card_by_fixed_points-val">target_card_by_fixed_points</a> : thm
<a name="line729"></a>    val <a href="#target_card_by_orbit_types-val">target_card_by_orbit_types</a> : thm
<a name="line730"></a>    val <a href="#target_card_by_partition-val">target_card_by_partition</a> : thm
<a name="line731"></a>    val <a href="#target_orbits_disjoint-val">target_orbits_disjoint</a> : thm
<a name="line732"></a>    val <a href="#target_orbits_union-val">target_orbits_union</a> : thm
<a name="line733"></a>    val <a href="#trivial_group-val">trivial_group</a> : thm
<a name="line734"></a>    val <a href="#trivial_group_carrier-val">trivial_group_carrier</a> : thm
<a name="line735"></a>    val <a href="#trivial_group_id-val">trivial_group_id</a> : thm
<a name="line736"></a>(*
   [monoid] Parent theory of "group"
   
   [<a name="AbelianGroup_def-val"><b>AbelianGroup_def</b></a>]  Definition
      
       g. AbelianGroup g  Group g  x y. x  G  y  G  x * y = y * x
   
   [<a name="CosetPartition_def-val"><b>CosetPartition_def</b></a>]  Definition
      
       g h. CosetPartition g h = partition (inCoset g h) G
   
   [<a name="ElGamal_decrypt_def-val"><b>ElGamal_decrypt_def</b></a>]  Definition
      
       g x a b. ElGamal_decrypt g x (a,b) = |/ (a ** x) * b
   
   [<a name="ElGamal_encrypt_def-val"><b>ElGamal_encrypt_def</b></a>]  Definition
      
       g y h m k. ElGamal_encrypt g y h m k = (y ** k,h ** k * m)
   
   [<a name="Estar_def-val"><b>Estar_def</b></a>]  Definition
      
       n. Estar n =
            &lt;|carrier := Euler n; id := 1; op := (i j. (i * j) MOD n)|&gt;
   
   [<a name="FiniteAbelianGroup_def-val"><b>FiniteAbelianGroup_def</b></a>]  Definition
      
       g. FiniteAbelianGroup g  AbelianGroup g  FINITE G
   
   [<a name="FiniteGroup_def-val"><b>FiniteGroup_def</b></a>]  Definition
      
       g. FiniteGroup g  Group g  FINITE G
   
   [<a name="GFACT_def-val"><b>GFACT_def</b></a>]  Definition
      
       g. GFACT g = GPROD_SET g G
   
   [<a name="GROUP_IMAGE_def-val"><b>GROUP_IMAGE_def</b></a>]  Definition
      
       g f s. GPI f s = ITSET (e acc. f e * acc) s #e
   
   [<a name="Generated_def-val"><b>Generated_def</b></a>]  Definition
      
       g a.
          gen a = &lt;|carrier := {x | k. x = a ** k}; op := $*; id := #e|&gt;
   
   [<a name="Generated_subset_def-val"><b>Generated_subset_def</b></a>]  Definition
      
       g s.
          gen_set s =
          &lt;|carrier := BIGINTER (IMAGE (h. H) {h | h  g  s  H});
            op := $*; id := #e|&gt;
   
   [<a name="GroupAuto_def-val"><b>GroupAuto_def</b></a>]  Definition
      
       f g. GroupAuto f g  GroupIso f g g
   
   [<a name="GroupEndo_def-val"><b>GroupEndo_def</b></a>]  Definition
      
       f g. GroupEndo f g  GroupHomo f g g
   
   [<a name="GroupHomo_def-val"><b>GroupHomo_def</b></a>]  Definition
      
       f g h.
          GroupHomo f g h 
          (x. x  G  f x  h.carrier) 
          x y. x  G  y  G  f (x * y) = h.op (f x) (f y)
   
   [<a name="GroupIso_def-val"><b>GroupIso_def</b></a>]  Definition
      
       f g h. GroupIso f g h  GroupHomo f g h  BIJ f G h.carrier
   
   [<a name="Group_def-val"><b>Group_def</b></a>]  Definition
      
       g. Group g  Monoid g  G* = G
   
   [<a name="OP_IMAGE_def-val"><b>OP_IMAGE_def</b></a>]  Definition
      
       op id f s. OP_IMAGE op id f s = ITSET (e acc. op (f e) acc) s id
   
   [<a name="StabilizerGroup_def-val"><b>StabilizerGroup_def</b></a>]  Definition
      
       f g x.
          StabilizerGroup f g x =
          &lt;|carrier := stabilizer f g x; op := $*; id := #e|&gt;
   
   [<a name="Subgroup_def-val"><b>Subgroup_def</b></a>]  Definition
      
       h g. h  g  Group h  Group g  H  G  $o = $*
   
   [<a name="Zadd_def-val"><b>Zadd_def</b></a>]  Definition
      
       n. Z n =
            &lt;|carrier := count n; id := 0; op := (i j. (i + j) MOD n)|&gt;
   
   [<a name="Zstar_def-val"><b>Zstar_def</b></a>]  Definition
      
       p. Z* p =
            &lt;|carrier := residue p; id := 1; op := (i j. (i * j) MOD p)|&gt;
   
   [<a name="act_by_def-val"><b>act_by_def</b></a>]  Definition
      
       f g x y.
          (x ~~ y) f g  act_by f g x y  G  f (act_by f g x y) x = y
   
   [<a name="action_def-val"><b>action_def</b></a>]  Definition
      
       f g X.
          (g act X) f 
          x. x  X 
              (a. a  G  f a x  X)  f #e x = x 
              a b. a  G  b  G  f a (f b x) = f (a * b) x
   
   [<a name="add_mod_def-val"><b>add_mod_def</b></a>]  Definition
      
       n. add_mod n =
            &lt;|carrier := {i | i &lt; n}; id := 0;
              op := (i j. (i + j) MOD n)|&gt;
   
   [<a name="all_subgroups_def-val"><b>all_subgroups_def</b></a>]  Definition
      
       g. all_subgroups g = {h | h  g}
   
   [<a name="cogen_def-val"><b>cogen_def</b></a>]  Definition
      
       g h e.
          h  g  e  CosetPartition g h 
          cogen g h e  G  e = cogen g h e * H
   
   [<a name="conjugate_def-val"><b>conjugate_def</b></a>]  Definition
      
       g a s. conjugate g a s = {a * z * |/ a | z  s}
   
   [<a name="conjugate_subgroup_def-val"><b>conjugate_subgroup_def</b></a>]  Definition
      
       h g a.
          conjugate_subgroup h g a =
          &lt;|carrier := conjugate g a H; id := #e; op := $* |&gt;
   
   [<a name="coset_def-val"><b>coset_def</b></a>]  Definition
      
       g a X. a * X = IMAGE (z. a * z) X
   
   [<a name="coset_op_def-val"><b>coset_op_def</b></a>]  Definition
      
       g h x y. x  y = cogen g h x * cogen g h y * H
   
   [<a name="cyclic_def-val"><b>cyclic_def</b></a>]  Definition
      
       g. cyclic g  Group g  z. z  G  x. x  G  n. x = z ** n
   
   [<a name="cyclic_gen_def-val"><b>cyclic_gen_def</b></a>]  Definition
      
       g. cyclic g 
            cyclic_gen g  G  x. x  G  n. x = cyclic_gen g ** n
   
   [<a name="cyclic_generators_def-val"><b>cyclic_generators_def</b></a>]  Definition
      
       g. cyclic_generators g = {z | z  G  ord z = CARD G}
   
   [<a name="cyclic_index_def-val"><b>cyclic_index_def</b></a>]  Definition
      
       g x.
          cyclic g  x  G 
          x = cyclic_gen g ** cyclic_index g x 
          (FINITE G  cyclic_index g x &lt; CARD G)
   
   [<a name="eq_order_def-val"><b>eq_order_def</b></a>]  Definition
      
       g x y. eq_order g x y  ord x = ord y
   
   [<a name="excluding_def-val"><b>excluding_def</b></a>]  Definition
      
       g z. g excluding z = &lt;|carrier := G DIFF {z}; op := $*; id := #e|&gt;
   
   [<a name="fixed_points_def-val"><b>fixed_points_def</b></a>]  Definition
      
       f g X. fixed_points f g X = {x | x  X  a. a  G  f a x = x}
   
   [<a name="fn_cyclic_group_def-val"><b>fn_cyclic_group_def</b></a>]  Definition
      
       e f.
          fn_cyclic_group e f =
          &lt;|carrier := {x | n. FUNPOW f n e = x}; id := e;
            op :=
              (x y.
                   @z. xi yi.
                     FUNPOW f xi e = x  FUNPOW f yi e = y 
                     FUNPOW f (xi + yi) e = z)|&gt;
   
   [<a name="group_div_def-val"><b>group_div_def</b></a>]  Definition
      
       g x y. x / y = x * |/ y
   
   [<a name="group_equiv_def-val"><b>group_equiv_def</b></a>]  Definition
      
       g h x y. x == y  x / y  H
   
   [<a name="group_fun_def-val"><b>group_fun_def</b></a>]  Definition
      
       g f. gfun f  x. x  G  f x  G
   
   [<a name="homo_image_def-val"><b>homo_image_def</b></a>]  Definition
      
       f g h.
          homo_image f g h =
          &lt;|carrier := IMAGE f G; op := h.op; id := h.id|&gt;
   
   [<a name="inCoset_def-val"><b>inCoset_def</b></a>]  Definition
      
       g h a b. inCoset g h a b  b  a * H
   
   [<a name="including_def-val"><b>including_def</b></a>]  Definition
      
       g z. g including z = &lt;|carrier := G  {z}; op := $*; id := #e|&gt;
   
   [<a name="kernel_def-val"><b>kernel_def</b></a>]  Definition
      
       f g h. kernel f g h = preimage f G h.id
   
   [<a name="kernel_group_def-val"><b>kernel_group_def</b></a>]  Definition
      
       f g h.
          kernel_group f g h =
          &lt;|carrier := kernel f g h; id := #e; op := $* |&gt;
   
   [<a name="left_coset_def-val"><b>left_coset_def</b></a>]  Definition
      
       g X a. left_coset g X a = a * X
   
   [<a name="make_group_def-val"><b>make_group_def</b></a>]  Definition
      
       g s. make_group g s = &lt;|carrier := s; op := $*; id := #e|&gt;
   
   [<a name="mult_mod_def-val"><b>mult_mod_def</b></a>]  Definition
      
       p. mult_mod p =
            &lt;|carrier := {i | i  0  i &lt; p}; id := 1;
              op := (i j. (i * j) MOD p)|&gt;
   
   [<a name="multi_orbits_def-val"><b>multi_orbits_def</b></a>]  Definition
      
       f g X. multi_orbits f g X = {e | e  orbits f g X  SING e}
   
   [<a name="normal_subgroup_def-val"><b>normal_subgroup_def</b></a>]  Definition
      
       h g. h &lt;&lt; g  h  g  a z. a  G  z  H  a * z / a  H
   
   [<a name="orbit_def-val"><b>orbit_def</b></a>]  Definition
      
       f g x. orbit f g x = IMAGE (a. f a x) G
   
   [<a name="orbits_def-val"><b>orbits_def</b></a>]  Definition
      
       f g X. orbits f g X = IMAGE (orbit f g) X
   
   [<a name="preimage_group_def-val"><b>preimage_group_def</b></a>]  Definition
      
       f g1 g2 h.
          preimage_group f g1 g2 h =
          &lt;|carrier := PREIMAGE f h  g1.carrier; op := g1.op;
            id := g1.id|&gt;
   
   [<a name="quotient_group_def-val"><b>quotient_group_def</b></a>]  Definition
      
       g h. g / h = &lt;|carrier := CosetPartition g h; op := $o; id := H|&gt;
   
   [<a name="reach_def-val"><b>reach_def</b></a>]  Definition
      
       f g x y. (x ~~ y) f g  a. a  G  f a x = y
   
   [<a name="right_coset_def-val"><b>right_coset_def</b></a>]  Definition
      
       g X a. X * a = IMAGE (z. z * a) X
   
   [<a name="roots_of_unity_def-val"><b>roots_of_unity_def</b></a>]  Definition
      
       g n.
          uroots n =
          &lt;|carrier := {x | x  G  x ** n = #e}; op := $*; id := #e|&gt;
   
   [<a name="sing_orbits_def-val"><b>sing_orbits_def</b></a>]  Definition
      
       f g X. sing_orbits f g X = {e | e  orbits f g X  SING e}
   
   [<a name="stabilizer_def-val"><b>stabilizer_def</b></a>]  Definition
      
       f g x. stabilizer f g x = {a | a  G  f a x = x}
   
   [<a name="subgroup_big_cross_def-val"><b>subgroup_big_cross_def</b></a>]  Definition
      
       g B. sgbcross B = ITSET $o B (gen #e)
   
   [<a name="subgroup_big_intersect_def-val"><b>subgroup_big_intersect_def</b></a>]  Definition
      
       g. sgbINTER g =
            &lt;|carrier := BIGINTER (IMAGE (h. H) {h | h  g}); op := $*;
              id := #e|&gt;
   
   [<a name="subgroup_cross_def-val"><b>subgroup_cross_def</b></a>]  Definition
      
       g h1 h2. h1  h2 = make_group g (h1.carrier  h2.carrier)
   
   [<a name="subgroup_def-val"><b>subgroup_def</b></a>]  Definition
      
       h g. subgroup h g  GroupHomo I h g
   
   [<a name="subset_big_cross_def-val"><b>subset_big_cross_def</b></a>]  Definition
      
       g B. ssbcross B = ITSET $o B {#e}
   
   [<a name="subset_cross_def-val"><b>subset_cross_def</b></a>]  Definition
      
       g s1 s2. s1  s2 = {x * y | x  s1  y  s2}
   
   [<a name="subset_cross_left_right_def-val"><b>subset_cross_left_right_def</b></a>]  Definition
      
       g s1 s2 z.
          z  s1  s2  left z  s1  right z  s2  z = left z * right z
   
   [<a name="subset_group_def-val"><b>subset_group_def</b></a>]  Definition
      
       g s. subset_group g s = &lt;|carrier := s; op := $*; id := #e|&gt;
   
   [<a name="symdiff_def-val"><b>symdiff_def</b></a>]  Definition
      
       s1 s2. symdiff s1 s2 = s1  s2 DIFF s1  s2
   
   [<a name="symdiff_set_def-val"><b>symdiff_set_def</b></a>]  Definition
      
       symdiff_set = &lt;|carrier := (: -&gt; bool); id := ; op := symdiff|&gt;
   
   [<a name="trivial_group_def-val"><b>trivial_group_def</b></a>]  Definition
      
       e. trivial_group e = &lt;|carrier := {e}; id := e; op := (x y. e)|&gt;
   
   [<a name="ElGamal_correctness-val"><b>ElGamal_correctness</b></a>]  Theorem
      
       g. Group g 
            (y::G) (h::G) (m::G) k x.
              h = y ** x 
              ElGamal_decrypt g x (ElGamal_encrypt g y h m k) = m
   
   [<a name="Estar_alt-val"><b>Estar_alt</b></a>]  Theorem
      
       n. Estar n =
            &lt;|carrier := {i | 0 &lt; i  i &lt; n  coprime n i}; id := 1;
              op := (i j. (i * j) MOD n)|&gt;
   
   [<a name="Estar_card-val"><b>Estar_card</b></a>]  Theorem
      
       n. CARD (Estar n).carrier = totient n
   
   [<a name="Estar_card_alt-val"><b>Estar_card_alt</b></a>]  Theorem
      
       n. 1 &lt; n  CARD (Estar n).carrier = phi n
   
   [<a name="Estar_carrier-val"><b>Estar_carrier</b></a>]  Theorem
      
       n. (Estar n).carrier = Euler n
   
   [<a name="Estar_carrier_alt-val"><b>Estar_carrier_alt</b></a>]  Theorem
      
       n. (Estar n).carrier = {i | 0 &lt; i  i &lt; n  coprime n i}
   
   [<a name="Estar_element-val"><b>Estar_element</b></a>]  Theorem
      
       n x. x  (Estar n).carrier  0 &lt; x  x &lt; n  coprime n x
   
   [<a name="Estar_eval-val"><b>Estar_eval</b></a>]  Theorem
      
       n. (Estar n).carrier = Euler n 
            (x y. (Estar n).op x y = (x * y) MOD n)  (Estar n).id = 1
   
   [<a name="Estar_exp-val"><b>Estar_exp</b></a>]  Theorem
      
       n a.
          1 &lt; n  a  (Estar n).carrier 
          k. (Estar n).exp a k = a ** k MOD n
   
   [<a name="Estar_finite-val"><b>Estar_finite</b></a>]  Theorem
      
       n. FINITE (Estar n).carrier
   
   [<a name="Estar_finite_abelian_group-val"><b>Estar_finite_abelian_group</b></a>]  Theorem
      
       n. 1 &lt; n  FiniteAbelianGroup (Estar n)
   
   [<a name="Estar_finite_group-val"><b>Estar_finite_group</b></a>]  Theorem
      
       n. 1 &lt; n  FiniteGroup (Estar n)
   
   [<a name="Estar_group-val"><b>Estar_group</b></a>]  Theorem
      
       n. 1 &lt; n  Group (Estar n)
   
   [<a name="Estar_id-val"><b>Estar_id</b></a>]  Theorem
      
       n. (Estar n).id = 1
   
   [<a name="Estar_inv-val"><b>Estar_inv</b></a>]  Theorem
      
       n a.
          1 &lt; n  a &lt; n  coprime n a 
          (Estar n).inv a = a ** (totient n  1) MOD n
   
   [<a name="Estar_inv_compute-val"><b>Estar_inv_compute</b></a>]  Theorem
      
       n a.
          (Estar n).inv a =
          if 1 &lt; n  a &lt; n  coprime n a then a ** (totient n  1) MOD n
          else FAIL ((Estar n).inv a) bad_element
   
   [<a name="Estar_property-val"><b>Estar_property</b></a>]  Theorem
      
       n. (Estar n).carrier = Euler n  (Estar n).id = 1 
            (x y. (Estar n).op x y = (x * y) MOD n) 
            FINITE (Estar n).carrier  CARD (Estar n).carrier = totient n
   
   [<a name="Euler_Fermat_alt-val"><b>Euler_Fermat_alt</b></a>]  Theorem
      
       n a. 1 &lt; n  coprime a n  a ** totient n MOD n = 1
   
   [<a name="Euler_Fermat_eqn-val"><b>Euler_Fermat_eqn</b></a>]  Theorem
      
       n a. 1 &lt; n  a &lt; n  coprime n a  a ** totient n MOD n = 1
   
   [<a name="Euler_Fermat_thm-val"><b>Euler_Fermat_thm</b></a>]  Theorem
      
       n a. 1 &lt; n  coprime n a  a ** totient n MOD n = 1
   
   [<a name="Fermat_little_eqn-val"><b>Fermat_little_eqn</b></a>]  Theorem
      
       p a. prime p  a ** p MOD p = a MOD p
   
   [<a name="Fermat_little_thm-val"><b>Fermat_little_thm</b></a>]  Theorem
      
       p a. prime p  0 &lt; a  a &lt; p  a ** (p  1) MOD p = 1
   
   [<a name="FiniteAbelianGroup_def_alt-val"><b>FiniteAbelianGroup_def_alt</b></a>]  Theorem
      
       g. FiniteAbelianGroup g 
            FiniteGroup g  x y. x  G  y  G  x * y = y * x
   
   [<a name="GFACT_element-val"><b>GFACT_element</b></a>]  Theorem
      
       g. FiniteAbelianMonoid g  GFACT g  G
   
   [<a name="GFACT_identity-val"><b>GFACT_identity</b></a>]  Theorem
      
       g a.
          FiniteAbelianGroup g  a  G  GFACT g = a ** CARD G * GFACT g
   
   [<a name="GITSET_AS_ITSET-val"><b>GITSET_AS_ITSET</b></a>]  Theorem
      
       g. (s b. GITSET g s b) = ITSET (e acc. e * acc)
   
   [<a name="GPROD_SET_AS_GROUP_IMAGE-val"><b>GPROD_SET_AS_GROUP_IMAGE</b></a>]  Theorem
      
       g. GPROD_SET g = GPI I
   
   [<a name="GPROD_SET_IMAGE-val"><b>GPROD_SET_IMAGE</b></a>]  Theorem
      
       g a. Group g  a  G  GPROD_SET g (a * G) = GPROD_SET g G
   
   [<a name="GPROD_SET_REDUCTION-val"><b>GPROD_SET_REDUCTION</b></a>]  Theorem
      
       g s.
          FiniteAbelianGroup g  s  G 
          a::G.
            a ** CARD s * GPROD_SET g s * GPROD_SET g (a * (G DIFF s)) =
            GPROD_SET g G
   
   [<a name="GPROD_SET_REDUCTION_INSERT-val"><b>GPROD_SET_REDUCTION_INSERT</b></a>]  Theorem
      
       g s.
          FiniteAbelianGroup g  s  G 
          a x::G.
            x  s 
            a * x * GPROD_SET g (a * (G DIFF (x INSERT s))) =
            GPROD_SET g (a * (G DIFF s))
   
   [<a name="Generated_subset_exp-val"><b>Generated_subset_exp</b></a>]  Theorem
      
       g s. (gen_set s).exp = $**
   
   [<a name="Generated_subset_gen-val"><b>Generated_subset_gen</b></a>]  Theorem
      
       g a. FiniteGroup g  a  G  gen_set (Gen a) = gen a
   
   [<a name="Generated_subset_group-val"><b>Generated_subset_group</b></a>]  Theorem
      
       g s. Group g  s  G  Group (gen_set s)
   
   [<a name="Generated_subset_has_set-val"><b>Generated_subset_has_set</b></a>]  Theorem
      
       g s. s  (gen_set s).carrier
   
   [<a name="Generated_subset_property-val"><b>Generated_subset_property</b></a>]  Theorem
      
       g s.
          (gen_set s).carrier =
          BIGINTER (IMAGE (h. H) {h | h  g  s  H}) 
          (gen_set s).op = $*  (gen_set s).id = #e
   
   [<a name="Generated_subset_subgroup-val"><b>Generated_subset_subgroup</b></a>]  Theorem
      
       g s. Group g  s  G  gen_set s  g
   
   [<a name="Generated_subset_subset-val"><b>Generated_subset_subset</b></a>]  Theorem
      
       g s. Group g  s  G  (gen_set s).carrier  G
   
   [<a name="Invertibles_inv-val"><b>Invertibles_inv</b></a>]  Theorem
      
       g x. Monoid g  x  G*  (Invertibles g).inv x = |/ x
   
   [<a name="Lagrange_identity-val"><b>Lagrange_identity</b></a>]  Theorem
      
       g h.
          h  g  FINITE G  CARD G = CARD H * CARD (CosetPartition g h)
   
   [<a name="Lagrange_identity_alt-val"><b>Lagrange_identity_alt</b></a>]  Theorem
      
       g h.
          h  g  FINITE G 
          CARD G = CARD H * CARD (partition (left_coset g H) G)
   
   [<a name="Lagrange_thm-val"><b>Lagrange_thm</b></a>]  Theorem
      
       g h. h  g  FINITE G  CARD H divides CARD G
   
   [<a name="OP_IMAGE_EMPTY-val"><b>OP_IMAGE_EMPTY</b></a>]  Theorem
      
       op id f. OP_IMAGE op id f  = id
   
   [<a name="OP_IMAGE_SING-val"><b>OP_IMAGE_SING</b></a>]  Theorem
      
       op id f x. OP_IMAGE op id f {x} = op (f x) id
   
   [<a name="OP_IMAGE_THM-val"><b>OP_IMAGE_THM</b></a>]  Theorem
      
       op id f.
          OP_IMAGE op id f  = id 
          (FUN_COMM op f 
           s. FINITE s 
               e. OP_IMAGE op id f (e INSERT s) =
                   op (f e) (OP_IMAGE op id f (s DELETE e)))
   
   [<a name="PRIME_2-val"><b>PRIME_2</b></a>]  Theorem
      
       prime 2
   
   [<a name="PRIME_3-val"><b>PRIME_3</b></a>]  Theorem
      
       prime 3
   
   [<a name="PRIME_5-val"><b>PRIME_5</b></a>]  Theorem
      
       prime 5
   
   [<a name="PRIME_7-val"><b>PRIME_7</b></a>]  Theorem
      
       prime 7
   
   [<a name="SURJ_IMAGE_PREIMAGE-val"><b>SURJ_IMAGE_PREIMAGE</b></a>]  Theorem
      
       f a b. s  b  SURJ f a b  IMAGE f (PREIMAGE f s  a) = s
   
   [<a name="Subgroup_homo_homo-val"><b>Subgroup_homo_homo</b></a>]  Theorem
      
       g h k f. h  g  GroupHomo f g k  GroupHomo f h k
   
   [<a name="Subgroup_subgroup-val"><b>Subgroup_subgroup</b></a>]  Theorem
      
       g h. h  g  subgroup h g
   
   [<a name="Zadd_card-val"><b>Zadd_card</b></a>]  Theorem
      
       n. CARD (Z n).carrier = n
   
   [<a name="Zadd_carrier-val"><b>Zadd_carrier</b></a>]  Theorem
      
       n. (Z n).carrier = count n
   
   [<a name="Zadd_carrier_alt-val"><b>Zadd_carrier_alt</b></a>]  Theorem
      
       n. (Z n).carrier = {i | i &lt; n}
   
   [<a name="Zadd_element-val"><b>Zadd_element</b></a>]  Theorem
      
       n x. x  (Z n).carrier  x &lt; n
   
   [<a name="Zadd_eval-val"><b>Zadd_eval</b></a>]  Theorem
      
       n. (Z n).carrier = count n 
            (x y. (Z n).op x y = (x + y) MOD n)  (Z n).id = 0
   
   [<a name="Zadd_exp-val"><b>Zadd_exp</b></a>]  Theorem
      
       n. 0 &lt; n  x m. (Z n).exp x m = (x * m) MOD n
   
   [<a name="Zadd_finite-val"><b>Zadd_finite</b></a>]  Theorem
      
       n. FINITE (Z n).carrier
   
   [<a name="Zadd_finite_abelian_group-val"><b>Zadd_finite_abelian_group</b></a>]  Theorem
      
       n. 0 &lt; n  FiniteAbelianGroup (Z n)
   
   [<a name="Zadd_finite_group-val"><b>Zadd_finite_group</b></a>]  Theorem
      
       n. 0 &lt; n  FiniteGroup (Z n)
   
   [<a name="Zadd_group-val"><b>Zadd_group</b></a>]  Theorem
      
       n. 0 &lt; n  Group (Z n)
   
   [<a name="Zadd_id-val"><b>Zadd_id</b></a>]  Theorem
      
       n. (Z n).id = 0
   
   [<a name="Zadd_inv-val"><b>Zadd_inv</b></a>]  Theorem
      
       n x. 0 &lt; n  x &lt; n  (Z n).inv x = (n  x) MOD n
   
   [<a name="Zadd_inv_compute-val"><b>Zadd_inv_compute</b></a>]  Theorem
      
       n x.
          (Z n).inv x =
          if 0 &lt; n  x &lt; n then (n  x) MOD n
          else FAIL ((Z n).inv x) bad_element
   
   [<a name="Zadd_property-val"><b>Zadd_property</b></a>]  Theorem
      
       n. (x. x  (Z n).carrier  x &lt; n)  (Z n).id = 0 
            (x y. (Z n).op x y = (x + y) MOD n)  FINITE (Z n).carrier 
            CARD (Z n).carrier = n
   
   [<a name="Zstar_card-val"><b>Zstar_card</b></a>]  Theorem
      
       p. 0 &lt; p  CARD (Z* p).carrier = p  1
   
   [<a name="Zstar_carrier-val"><b>Zstar_carrier</b></a>]  Theorem
      
       p. (Z* p).carrier = residue p
   
   [<a name="Zstar_carrier_alt-val"><b>Zstar_carrier_alt</b></a>]  Theorem
      
       p. (Z* p).carrier = {i | 0 &lt; i  i &lt; p}
   
   [<a name="Zstar_element-val"><b>Zstar_element</b></a>]  Theorem
      
       p x. x  (Z* p).carrier  0 &lt; x  x &lt; p
   
   [<a name="Zstar_eval-val"><b>Zstar_eval</b></a>]  Theorem
      
       p. (Z* p).carrier = residue p 
            (x y. (Z* p).op x y = (x * y) MOD p)  (Z* p).id = 1
   
   [<a name="Zstar_exp-val"><b>Zstar_exp</b></a>]  Theorem
      
       p a.
          prime p  a  (Z* p).carrier  n. (Z* p).exp a n = a ** n MOD p
   
   [<a name="Zstar_finite-val"><b>Zstar_finite</b></a>]  Theorem
      
       p. FINITE (Z* p).carrier
   
   [<a name="Zstar_finite_abelian_group-val"><b>Zstar_finite_abelian_group</b></a>]  Theorem
      
       p. prime p  FiniteAbelianGroup (Z* p)
   
   [<a name="Zstar_finite_group-val"><b>Zstar_finite_group</b></a>]  Theorem
      
       p. prime p  FiniteGroup (Z* p)
   
   [<a name="Zstar_group-val"><b>Zstar_group</b></a>]  Theorem
      
       p. prime p  Group (Z* p)
   
   [<a name="Zstar_id-val"><b>Zstar_id</b></a>]  Theorem
      
       p. (Z* p).id = 1
   
   [<a name="Zstar_inv-val"><b>Zstar_inv</b></a>]  Theorem
      
       p. prime p 
            x. 0 &lt; x  x &lt; p 
                (Z* p).inv x = (Z* p).exp x (order (Z* p) x  1)
   
   [<a name="Zstar_inv_compute-val"><b>Zstar_inv_compute</b></a>]  Theorem
      
       p x.
          (Z* p).inv x =
          if prime p  0 &lt; x  x &lt; p then (Z* p).exp x (order (Z* p) x  1)
          else FAIL ((Z* p).inv x) bad_element
   
   [<a name="Zstar_inverse-val"><b>Zstar_inverse</b></a>]  Theorem
      
       p. prime p  a. 0 &lt; a  a &lt; p  (Z* p).inv a = a ** (p  2) MOD p
   
   [<a name="Zstar_inverse_compute-val"><b>Zstar_inverse_compute</b></a>]  Theorem
      
       p a.
          (Z* p).inv a =
          if prime p  0 &lt; a  a &lt; p then a ** (p  2) MOD p
          else (Z* p).inv a
   
   [<a name="Zstar_property-val"><b>Zstar_property</b></a>]  Theorem
      
       p. (Z* p).carrier = residue p  (Z* p).id = 1 
            (x y. (Z* p).op x y = (x * y) MOD p)  FINITE (Z* p).carrier 
            (0 &lt; p  CARD (Z* p).carrier = p  1)
   
   [<a name="abelian_group_is_abelian_monoid-val"><b>abelian_group_is_abelian_monoid</b></a>]  Theorem
      
       g. AbelianGroup g  AbelianMonoid g
   
   [<a name="abelian_group_order_common-val"><b>abelian_group_order_common</b></a>]  Theorem
      
       g. AbelianGroup g 
            x y.
              x  G  y  G 
              z. z  G  ord z * gcd (ord x) (ord y) = lcm (ord x) (ord y)
   
   [<a name="abelian_group_order_common_coprime-val"><b>abelian_group_order_common_coprime</b></a>]  Theorem
      
       g. AbelianGroup g 
            x y.
              x  G  y  G  coprime (ord x) (ord y) 
              z. z  G  ord z = ord x * ord y
   
   [<a name="abelian_monoid_invertible_excluding-val"><b>abelian_monoid_invertible_excluding</b></a>]  Theorem
      
       g. AbelianMonoid g 
            z. z  G*  monoid_invertibles (g excluding z) = G*
   
   [<a name="abelian_subgroup_abelian-val"><b>abelian_subgroup_abelian</b></a>]  Theorem
      
       g h. AbelianGroup g  h  g  AbelianGroup h
   
   [<a name="abelian_subgroup_cross_finite-val"><b>abelian_subgroup_cross_finite</b></a>]  Theorem
      
       g. AbelianGroup g 
            h1 h2.
              h1  g  h2  g  FiniteGroup h1  FiniteGroup h2 
              FiniteGroup (h1  h2)
   
   [<a name="abelian_subgroup_cross_subgroup-val"><b>abelian_subgroup_cross_subgroup</b></a>]  Theorem
      
       g. AbelianGroup g  h1 h2. h1  g  h2  g  h1  h2  g
   
   [<a name="action_closure-val"><b>action_closure</b></a>]  Theorem
      
       f g X. (g act X) f  a x. a  G  x  X  f a x  X
   
   [<a name="action_compose-val"><b>action_compose</b></a>]  Theorem
      
       f g X.
          (g act X) f 
          a b x. a  G  b  G  x  X  f a (f b x) = f (a * b) x
   
   [<a name="action_id-val"><b>action_id</b></a>]  Theorem
      
       f g X. (g act X) f  x. x  X  f #e x = x
   
   [<a name="action_match_condition-val"><b>action_match_condition</b></a>]  Theorem
      
       f g X x.
          Group g  (g act X) f  x  X 
          a b.
            a  G  b  G  (f a x = f b x  |/ a * b  stabilizer f g x)
   
   [<a name="action_match_condition_alt-val"><b>action_match_condition_alt</b></a>]  Theorem
      
       f g X x.
          Group g  (g act X) f  x  X 
          a b::G. f a x = f b x  |/ a * b  stabilizer f g x
   
   [<a name="action_reachable_coset-val"><b>action_reachable_coset</b></a>]  Theorem
      
       f g X x y.
          Group g  (g act X) f  x  X  y  orbit f g x 
          act_by f g x y * stabilizer f g x = {a | a  G  f a x = y}
   
   [<a name="action_reachable_coset_alt-val"><b>action_reachable_coset_alt</b></a>]  Theorem
      
       f g X x y.
          Group g  (g act X) f  x  X  y  orbit f g x 
          a. a  G  f a x = y 
              a * stabilizer f g x = {b | b  G  f b x = y}
   
   [<a name="action_reverse-val"><b>action_reverse</b></a>]  Theorem
      
       f g X.
          Group g  (g act X) f 
          a x y. a  G  x  X  y  X  f a x = y  f ( |/ a) y = x
   
   [<a name="action_to_orbit_surj-val"><b>action_to_orbit_surj</b></a>]  Theorem
      
       f g X x. (g act X) f  x  X  SURJ (a. f a x) G (orbit f g x)
   
   [<a name="action_trans-val"><b>action_trans</b></a>]  Theorem
      
       f g X.
          (g act X) f 
          a b x y z.
            a  G  b  G  x  X  y  X  z  X  f a x = y  f b y = z 
            f (b * a) x = z
   
   [<a name="add_mod_abelian_group-val"><b>add_mod_abelian_group</b></a>]  Theorem
      
       n. 0 &lt; n  AbelianGroup (add_mod n)
   
   [<a name="add_mod_card-val"><b>add_mod_card</b></a>]  Theorem
      
       n. CARD (add_mod n).carrier = n
   
   [<a name="add_mod_carrier-val"><b>add_mod_carrier</b></a>]  Theorem
      
       n. (add_mod n).carrier = {i | i &lt; n}
   
   [<a name="add_mod_carrier_alt-val"><b>add_mod_carrier_alt</b></a>]  Theorem
      
       n. (add_mod n).carrier = count n
   
   [<a name="add_mod_cylic-val"><b>add_mod_cylic</b></a>]  Theorem
      
       n. 0 &lt; n  cyclic (add_mod n)
   
   [<a name="add_mod_element-val"><b>add_mod_element</b></a>]  Theorem
      
       n x. x  (add_mod n).carrier  x &lt; n
   
   [<a name="add_mod_eval-val"><b>add_mod_eval</b></a>]  Theorem
      
       n. (add_mod n).carrier = {i | i &lt; n} 
            (x y. (add_mod n).op x y = (x + y) MOD n)  (add_mod n).id = 0
   
   [<a name="add_mod_exp-val"><b>add_mod_exp</b></a>]  Theorem
      
       n. 0 &lt; n  x m. (add_mod n).exp x m = (x * m) MOD n
   
   [<a name="add_mod_finite-val"><b>add_mod_finite</b></a>]  Theorem
      
       n. FINITE (add_mod n).carrier
   
   [<a name="add_mod_finite_abelian_group-val"><b>add_mod_finite_abelian_group</b></a>]  Theorem
      
       n. 0 &lt; n  FiniteAbelianGroup (add_mod n)
   
   [<a name="add_mod_finite_group-val"><b>add_mod_finite_group</b></a>]  Theorem
      
       n. 0 &lt; n  FiniteGroup (add_mod n)
   
   [<a name="add_mod_group-val"><b>add_mod_group</b></a>]  Theorem
      
       n. 0 &lt; n  Group (add_mod n)
   
   [<a name="add_mod_id-val"><b>add_mod_id</b></a>]  Theorem
      
       n. (add_mod n).id = 0
   
   [<a name="add_mod_inv-val"><b>add_mod_inv</b></a>]  Theorem
      
       n x. 0 &lt; n  x &lt; n  (add_mod n).inv x = (n  x) MOD n
   
   [<a name="add_mod_inv_compute-val"><b>add_mod_inv_compute</b></a>]  Theorem
      
       n x.
          (add_mod n).inv x =
          if 0 &lt; n  x &lt; n then (n  x) MOD n
          else FAIL ((add_mod n).inv x) bad_element
   
   [<a name="add_mod_order_1-val"><b>add_mod_order_1</b></a>]  Theorem
      
       n. 1 &lt; n  order (add_mod n) 1 = n
   
   [<a name="add_mod_property-val"><b>add_mod_property</b></a>]  Theorem
      
       n. (x. x  (add_mod n).carrier  x &lt; n)  (add_mod n).id = 0 
            (x y. (add_mod n).op x y = (x + y) MOD n) 
            FINITE (add_mod n).carrier  CARD (add_mod n).carrier = n
   
   [<a name="all_subgroups_element-val"><b>all_subgroups_element</b></a>]  Theorem
      
       g h. h  all_subgroups g  h  g
   
   [<a name="all_subgroups_finite-val"><b>all_subgroups_finite</b></a>]  Theorem
      
       g. FiniteGroup g  FINITE (all_subgroups g)
   
   [<a name="all_subgroups_has_gen_id-val"><b>all_subgroups_has_gen_id</b></a>]  Theorem
      
       g. Group g  gen #e  all_subgroups g
   
   [<a name="all_subgroups_subset-val"><b>all_subgroups_subset</b></a>]  Theorem
      
       g. Group g  IMAGE (h. H) (all_subgroups g)  POW G
   
   [<a name="bij_corres-val"><b>bij_corres</b></a>]  Theorem
      
       f g1 g2 h1 h2.
          Group g1  Group g2  h1  g1  h2  g2  GroupHomo f g1 g2 
          SURJ f g1.carrier g2.carrier  kernel f g1 g2  h1.carrier 
          IMAGE f (PREIMAGE f h2.carrier  g1.carrier) = h2.carrier 
          PREIMAGE f (IMAGE f h1.carrier)  g1.carrier = h1.carrier
   
   [<a name="carrier_card_by_coset_partition-val"><b>carrier_card_by_coset_partition</b></a>]  Theorem
      
       g h. h  g  FINITE G  CARD G =  CARD (CosetPartition g h)
   
   [<a name="carrier_card_by_subgroup_coset_partition-val"><b>carrier_card_by_subgroup_coset_partition</b></a>]  Theorem
      
       g h.
          h  g  FINITE G  CARD G =  CARD (partition (left_coset g H) G)
   
   [<a name="cogen_coset_element-val"><b>cogen_coset_element</b></a>]  Theorem
      
       g h. h  g  x. x  G  cogen g h (x * H)  G
   
   [<a name="cogen_element-val"><b>cogen_element</b></a>]  Theorem
      
       h g e. h  g  e  CosetPartition g h  cogen g h e  G
   
   [<a name="cogen_of_subgroup-val"><b>cogen_of_subgroup</b></a>]  Theorem
      
       g h. h  g  cogen g h H * H = H
   
   [<a name="conjugate_subgroup_group-val"><b>conjugate_subgroup_group</b></a>]  Theorem
      
       g h. h  g  a. a  G  Group (conjugate_subgroup h g a)
   
   [<a name="conjugate_subgroup_subgroup-val"><b>conjugate_subgroup_subgroup</b></a>]  Theorem
      
       g h. h  g  a::G. conjugate_subgroup h g a  g
   
   [<a name="corres_thm-val"><b>corres_thm</b></a>]  Theorem
      
       f g1 g2 h1 h2.
          Group g1  Group g2  GroupHomo f g1 g2 
          SURJ f g1.carrier g2.carrier  h1  g1 
          kernel f g1 g2  h1.carrier  h2  g2 
          homo_image f h1 g2  g2 
          preimage_group f g1 g2 h2.carrier  g1 
          kernel f g1 g2  PREIMAGE f h2.carrier  g1.carrier 
          (h2 &lt;&lt; g2  preimage_group f g1 g2 h2.carrier &lt;&lt; g1) 
          IMAGE f (PREIMAGE f h2.carrier  g1.carrier) = h2.carrier 
          PREIMAGE f (IMAGE f h1.carrier)  g1.carrier = h1.carrier 
          (FiniteGroup g1 
           CARD (preimage_group f g1 g2 h2.carrier).carrier =
           CARD h2.carrier * CARD (kernel f g1 g2))
   
   [<a name="coset_alt-val"><b>coset_alt</b></a>]  Theorem
      
       g a X. a * X = {a * z | z  X}
   
   [<a name="coset_cogen_property-val"><b>coset_cogen_property</b></a>]  Theorem
      
       h g e. h  g  e  CosetPartition g h  e = cogen g h e * H
   
   [<a name="coset_element-val"><b>coset_element</b></a>]  Theorem
      
       g X a. a  G  x. x  a * X  y. y  X  x = a * y
   
   [<a name="coset_empty-val"><b>coset_empty</b></a>]  Theorem
      
       g a. Group g  a  G  a *  = 
   
   [<a name="coset_homo_group_iso_quotient_group-val"><b>coset_homo_group_iso_quotient_group</b></a>]  Theorem
      
       g h. h &lt;&lt; g  GroupIso I (homo_group g (left_coset g H)) (g / h)
   
   [<a name="coset_id_eq_subgroup-val"><b>coset_id_eq_subgroup</b></a>]  Theorem
      
       g h. h  g  #e * H = H
   
   [<a name="coset_partition_card-val"><b>coset_partition_card</b></a>]  Theorem
      
       g h.
          h  g  FINITE G  CARD (CosetPartition g h) = CARD G DIV CARD H
   
   [<a name="coset_partition_element-val"><b>coset_partition_element</b></a>]  Theorem
      
       g h. h  g  e. e  CosetPartition g h  a. a  G  e = a * H
   
   [<a name="coset_partition_element_card-val"><b>coset_partition_element_card</b></a>]  Theorem
      
       g h.
          h  g  FINITE G  e. e  CosetPartition g h  CARD e = CARD H
   
   [<a name="coset_partition_eq_coset_image-val"><b>coset_partition_eq_coset_image</b></a>]  Theorem
      
       g h. h  g  CosetPartition g h = IMAGE (left_coset g H) G
   
   [<a name="coset_property-val"><b>coset_property</b></a>]  Theorem
      
       g a. Group g  a  G  X. X  G  a * X  G
   
   [<a name="count_formula-val"><b>count_formula</b></a>]  Theorem
      
       g h.
          FiniteGroup g  h &lt;&lt; g  CARD G = CARD H * CARD (g / h).carrier
   
   [<a name="cyclic_element-val"><b>cyclic_element</b></a>]  Theorem
      
       g. cyclic g  x. x  G  n. x = cyclic_gen g ** n
   
   [<a name="cyclic_element_by_gen-val"><b>cyclic_element_by_gen</b></a>]  Theorem
      
       g. cyclic g  FINITE G 
            x. x  G  n. n &lt; CARD G  x = cyclic_gen g ** n
   
   [<a name="cyclic_element_in_generated-val"><b>cyclic_element_in_generated</b></a>]  Theorem
      
       g. cyclic g  FINITE G 
            x. x  G  x  Gen (cyclic_gen g ** (CARD G DIV ord x))
   
   [<a name="cyclic_eq_order_partition-val"><b>cyclic_eq_order_partition</b></a>]  Theorem
      
       g. cyclic g  FINITE G 
            partition (eq_order g) G = {orders g n | n | n divides CARD G}
   
   [<a name="cyclic_eq_order_partition_alt-val"><b>cyclic_eq_order_partition_alt</b></a>]  Theorem
      
       g. cyclic g  FINITE G 
            partition (eq_order g) G =
            {orders g n | n | n  divisors (CARD G)}
   
   [<a name="cyclic_eq_order_partition_by_card-val"><b>cyclic_eq_order_partition_by_card</b></a>]  Theorem
      
       g. cyclic g  FINITE G 
            IMAGE CARD (partition (eq_order g) G) =
            IMAGE phi (divisors (CARD G))
   
   [<a name="cyclic_finite_alt-val"><b>cyclic_finite_alt</b></a>]  Theorem
      
       g. FiniteGroup g  (cyclic g  z. z  G  ord z = CARD G)
   
   [<a name="cyclic_finite_has_order_divisor-val"><b>cyclic_finite_has_order_divisor</b></a>]  Theorem
      
       g. cyclic g  FINITE G 
            n. n divides CARD G  x. x  G  ord x = n
   
   [<a name="cyclic_gen_element-val"><b>cyclic_gen_element</b></a>]  Theorem
      
       g. cyclic g  cyclic_gen g  G
   
   [<a name="cyclic_gen_order-val"><b>cyclic_gen_order</b></a>]  Theorem
      
       g. cyclic g  FINITE G  ord (cyclic_gen g) = CARD G
   
   [<a name="cyclic_gen_power_order-val"><b>cyclic_gen_power_order</b></a>]  Theorem
      
       g. cyclic g  FINITE G 
            n. 0 &lt; n  CARD G MOD n = 0 
                ord (cyclic_gen g ** (CARD G DIV n)) = n
   
   [<a name="cyclic_generated_by_gen-val"><b>cyclic_generated_by_gen</b></a>]  Theorem
      
       g. cyclic g  g = gen (cyclic_gen g)
   
   [<a name="cyclic_generated_group-val"><b>cyclic_generated_group</b></a>]  Theorem
      
       g. FiniteGroup g  x. x  G  cyclic (gen x)
   
   [<a name="cyclic_generators_card-val"><b>cyclic_generators_card</b></a>]  Theorem
      
       g. cyclic g  FINITE G  CARD (cyclic_generators g) = phi (CARD G)
   
   [<a name="cyclic_generators_coprimes_bij-val"><b>cyclic_generators_coprimes_bij</b></a>]  Theorem
      
       g. cyclic g  FINITE G 
            BIJ (j. cyclic_gen g ** j) (coprimes (CARD G))
              (cyclic_generators g)
   
   [<a name="cyclic_generators_element-val"><b>cyclic_generators_element</b></a>]  Theorem
      
       g z. z  cyclic_generators g  z  G  ord z = CARD G
   
   [<a name="cyclic_generators_finite-val"><b>cyclic_generators_finite</b></a>]  Theorem
      
       g. FINITE G  FINITE (cyclic_generators g)
   
   [<a name="cyclic_generators_gen_cofactor_eq_orders-val"><b>cyclic_generators_gen_cofactor_eq_orders</b></a>]  Theorem
      
       g. cyclic g  FINITE G 
            n. n divides CARD G 
                cyclic_generators (gen (cyclic_gen g ** (CARD G DIV n))) =
                orders g n
   
   [<a name="cyclic_generators_nonempty-val"><b>cyclic_generators_nonempty</b></a>]  Theorem
      
       g. cyclic g  FINITE G  cyclic_generators g  
   
   [<a name="cyclic_generators_subset-val"><b>cyclic_generators_subset</b></a>]  Theorem
      
       g. cyclic_generators g  G
   
   [<a name="cyclic_group-val"><b>cyclic_group</b></a>]  Theorem
      
       g. cyclic g  Group g
   
   [<a name="cyclic_group_abelian-val"><b>cyclic_group_abelian</b></a>]  Theorem
      
       g. cyclic g  AbelianGroup g
   
   [<a name="cyclic_group_comm-val"><b>cyclic_group_comm</b></a>]  Theorem
      
       g. cyclic g  x y. x  G  y  G  x * y = y * x
   
   [<a name="cyclic_image_ord_is_divisors-val"><b>cyclic_image_ord_is_divisors</b></a>]  Theorem
      
       g. cyclic g  FINITE G  IMAGE ord G = divisors (CARD G)
   
   [<a name="cyclic_index_exists-val"><b>cyclic_index_exists</b></a>]  Theorem
      
       g x.
          cyclic g  x  G 
          n. x = cyclic_gen g ** n  (FINITE G  n &lt; CARD G)
   
   [<a name="cyclic_iso_gen-val"><b>cyclic_iso_gen</b></a>]  Theorem
      
       g h f.
          cyclic g  cyclic h  FINITE G  GroupIso f g h 
          f (cyclic_gen g)  cyclic_generators h
   
   [<a name="cyclic_orders_card-val"><b>cyclic_orders_card</b></a>]  Theorem
      
       g. cyclic g  FINITE G 
            n. CARD (orders g n) = if n divides CARD G then phi n else 0
   
   [<a name="cyclic_orders_nonempty-val"><b>cyclic_orders_nonempty</b></a>]  Theorem
      
       g. cyclic g  FINITE G  n. n divides CARD G  orders g n  
   
   [<a name="cyclic_orders_partition-val"><b>cyclic_orders_partition</b></a>]  Theorem
      
       g. cyclic g  FINITE G 
            partition (eq_order g) G = IMAGE (orders g) (divisors (CARD G))
   
   [<a name="cyclic_subgroup_condition-val"><b>cyclic_subgroup_condition</b></a>]  Theorem
      
       g. cyclic g  FINITE G 
            n. (h. h  g  CARD H = n)  n divides CARD G
   
   [<a name="cyclic_subgroup_cyclic-val"><b>cyclic_subgroup_cyclic</b></a>]  Theorem
      
       g h. cyclic g  h  g  cyclic h
   
   [<a name="cyclic_uroots_cyclic-val"><b>cyclic_uroots_cyclic</b></a>]  Theorem
      
       g. cyclic g  n. cyclic (uroots n)
   
   [<a name="cyclic_uroots_has_primitive-val"><b>cyclic_uroots_has_primitive</b></a>]  Theorem
      
       g. FINITE G  cyclic g 
            n. z.
              z  (uroots n).carrier  ord z = CARD (uroots n).carrier
   
   [<a name="element_coset_property-val"><b>element_coset_property</b></a>]  Theorem
      
       g X a. a  G  x. x  X  a * x  a * X
   
   [<a name="eq_order_equiv-val"><b>eq_order_equiv</b></a>]  Theorem
      
       g. eq_order g equiv_on G
   
   [<a name="eq_order_is_feq_order-val"><b>eq_order_is_feq_order</b></a>]  Theorem
      
       g. eq_order g = feq ord
   
   [<a name="fermat_little-val"><b>fermat_little</b></a>]  Theorem
      
       p a. prime p  0 &lt; a  a &lt; p  a ** (p  1) MOD p = 1
   
   [<a name="fermat_little_alt-val"><b>fermat_little_alt</b></a>]  Theorem
      
       p a. prime p  a ** (p  1) MOD p = if a MOD p = 0 then 0 else 1
   
   [<a name="fermat_little_thm-val"><b>fermat_little_thm</b></a>]  Theorem
      
       p. prime p  a. a ** p MOD p = a MOD p
   
   [<a name="fermat_roots-val"><b>fermat_roots</b></a>]  Theorem
      
       p. prime p 
            x y z. x ** p + y ** p = z ** p  (x + y) MOD p = z MOD p
   
   [<a name="finite_abelian_Fermat-val"><b>finite_abelian_Fermat</b></a>]  Theorem
      
       g a. FiniteAbelianGroup g  a  G  a ** CARD G = #e
   
   [<a name="finite_abelian_group_is_finite_abelian_monoid-val"><b>finite_abelian_group_is_finite_abelian_monoid</b></a>]  Theorem
      
       g. FiniteAbelianGroup g  FiniteAbelianMonoid g
   
   [<a name="finite_cyclic_group_add_mod_bij-val"><b>finite_cyclic_group_add_mod_bij</b></a>]  Theorem
      
       g. cyclic g  FINITE G 
            BIJ (n. cyclic_gen g ** n) (add_mod (CARD G)).carrier G
   
   [<a name="finite_cyclic_group_add_mod_homo-val"><b>finite_cyclic_group_add_mod_homo</b></a>]  Theorem
      
       g. cyclic g  FINITE G 
            GroupHomo (n. cyclic_gen g ** n) (add_mod (CARD G)) g
   
   [<a name="finite_cyclic_group_add_mod_iso-val"><b>finite_cyclic_group_add_mod_iso</b></a>]  Theorem
      
       g. cyclic g  FINITE G 
            GroupIso (n. cyclic_gen g ** n) (add_mod (CARD G)) g
   
   [<a name="finite_cyclic_group_bij-val"><b>finite_cyclic_group_bij</b></a>]  Theorem
      
       g1 g2.
          cyclic g1  cyclic g2  FINITE g1.carrier  FINITE g2.carrier 
          CARD g1.carrier = CARD g2.carrier 
          BIJ (x. g2.exp (cyclic_gen g2) (cyclic_index g1 x)) g1.carrier
            g2.carrier
   
   [<a name="finite_cyclic_group_existence-val"><b>finite_cyclic_group_existence</b></a>]  Theorem
      
       n. 0 &lt; n  g. cyclic g  CARD g.carrier = n
   
   [<a name="finite_cyclic_group_homo-val"><b>finite_cyclic_group_homo</b></a>]  Theorem
      
       g1 g2.
          cyclic g1  cyclic g2  FINITE g1.carrier  FINITE g2.carrier 
          CARD g1.carrier = CARD g2.carrier 
          GroupHomo (x. g2.exp (cyclic_gen g2) (cyclic_index g1 x)) g1 g2
   
   [<a name="finite_cyclic_group_iso-val"><b>finite_cyclic_group_iso</b></a>]  Theorem
      
       g1 g2.
          cyclic g1  cyclic g2  FINITE g1.carrier  FINITE g2.carrier 
          CARD g1.carrier = CARD g2.carrier 
          GroupIso (x. g2.exp (cyclic_gen g2) (cyclic_index g1 x)) g1 g2
   
   [<a name="finite_cyclic_group_uniqueness-val"><b>finite_cyclic_group_uniqueness</b></a>]  Theorem
      
       g1 g2.
          cyclic g1  cyclic g2  FINITE g1.carrier  FINITE g2.carrier 
          CARD g1.carrier = CARD g2.carrier 
          f. GroupIso f g1 g2
   
   [<a name="finite_cyclic_index_add-val"><b>finite_cyclic_index_add</b></a>]  Theorem
      
       g x y.
          cyclic g  FINITE G  x  G  y  G 
          cyclic_index g (x * y) =
          (cyclic_index g x + cyclic_index g y) MOD CARD G
   
   [<a name="finite_cyclic_index_property-val"><b>finite_cyclic_index_property</b></a>]  Theorem
      
       g. cyclic g  FINITE G 
            n. n &lt; CARD G  cyclic_index g (cyclic_gen g ** n) = n
   
   [<a name="finite_cyclic_index_unique-val"><b>finite_cyclic_index_unique</b></a>]  Theorem
      
       g x.
          cyclic g  FINITE G  x  G 
          n. n &lt; CARD G  (x = cyclic_gen g ** n  n = cyclic_index g x)
   
   [<a name="finite_group_Fermat-val"><b>finite_group_Fermat</b></a>]  Theorem
      
       g a. FiniteGroup g  a  G  a ** CARD G = #e
   
   [<a name="finite_group_card_pos-val"><b>finite_group_card_pos</b></a>]  Theorem
      
       g. FiniteGroup g  0 &lt; CARD G
   
   [<a name="finite_group_exp_not_distinct-val"><b>finite_group_exp_not_distinct</b></a>]  Theorem
      
       g. FiniteGroup g  x. x  G  h k. x ** h = x ** k  h  k
   
   [<a name="finite_group_exp_period_exists-val"><b>finite_group_exp_period_exists</b></a>]  Theorem
      
       g. FiniteGroup g  x. x  G  k. 0 &lt; k  x ** k = #e
   
   [<a name="finite_group_is_finite_monoid-val"><b>finite_group_is_finite_monoid</b></a>]  Theorem
      
       g. FiniteGroup g  FiniteMonoid g
   
   [<a name="finite_group_is_group-val"><b>finite_group_is_group</b></a>]  Theorem
      
       g. FiniteGroup g  Group g
   
   [<a name="finite_group_is_monoid-val"><b>finite_group_is_monoid</b></a>]  Theorem
      
       g. FiniteGroup g  Monoid g
   
   [<a name="finite_group_order-val"><b>finite_group_order</b></a>]  Theorem
      
       g. FiniteGroup g 
            x. x  G 
                n. ord x = n 
                    0 &lt; n  x ** n = #e  m. 0 &lt; m  m &lt; n  x ** m  #e
   
   [<a name="finite_group_primitive_property-val"><b>finite_group_primitive_property</b></a>]  Theorem
      
       g. FiniteGroup g 
            z. z  G  ord z = CARD G 
                x. x  G  n. n &lt; CARD G  x = z ** n
   
   [<a name="finite_homo_image-val"><b>finite_homo_image</b></a>]  Theorem
      
       f g1 g2 h.
          FiniteGroup g1  Group g2  h  g2  GroupHomo f g1 g2 
          FINITE
            (homo_image f (preimage_group f g1 g2 h.carrier) g2).carrier
   
   [<a name="finite_monoid_invertibles_is_finite_group-val"><b>finite_monoid_invertibles_is_finite_group</b></a>]  Theorem
      
       g. FiniteMonoid g  FiniteGroup (Invertibles g)
   
   [<a name="finite_subgroup_carrier_finite-val"><b>finite_subgroup_carrier_finite</b></a>]  Theorem
      
       g. FiniteGroup g  h. h  g  FINITE H
   
   [<a name="finite_subgroup_finite_group-val"><b>finite_subgroup_finite_group</b></a>]  Theorem
      
       g. FiniteGroup g  h. h  g  FiniteGroup h
   
   [<a name="fixed_points_element-val"><b>fixed_points_element</b></a>]  Theorem
      
       f g X x. x  fixed_points f g X  x  X  a. a  G  f a x = x
   
   [<a name="fixed_points_element_element-val"><b>fixed_points_element_element</b></a>]  Theorem
      
       f g X x. x  fixed_points f g X  x  X
   
   [<a name="fixed_points_finite-val"><b>fixed_points_finite</b></a>]  Theorem
      
       f g X. FINITE X  FINITE (fixed_points f g X)
   
   [<a name="fixed_points_orbit_iff_sing-val"><b>fixed_points_orbit_iff_sing</b></a>]  Theorem
      
       f g X.
          Group g  (g act X) f 
          x. x  X  (x  fixed_points f g X  SING (orbit f g x))
   
   [<a name="fixed_points_orbit_sing-val"><b>fixed_points_orbit_sing</b></a>]  Theorem
      
       f g X.
          Group g  (g act X) f 
          x. x  fixed_points f g X  x  X  orbit f g x = {x}
   
   [<a name="fixed_points_subset-val"><b>fixed_points_subset</b></a>]  Theorem
      
       f g X. fixed_points f g X  X
   
   [<a name="fn_cyclic_group_alt-val"><b>fn_cyclic_group_alt</b></a>]  Theorem
      
       e f n.
          (k. k  0  FUNPOW f k e = e) 
          n = (LEAST k. k  0  FUNPOW f k e = e) 
          (fn_cyclic_group e f).carrier = {FUNPOW f k e | k &lt; n} 
          (fn_cyclic_group e f).id = e 
          i j.
            (fn_cyclic_group e f).op (FUNPOW f i e) (FUNPOW f j e) =
            FUNPOW f ((i + j) MOD n) e
   
   [<a name="fn_cyclic_group_carrier-val"><b>fn_cyclic_group_carrier</b></a>]  Theorem
      
       e f. (fn_cyclic_group e f).carrier = {x | n. FUNPOW f n e = x}
   
   [<a name="fn_cyclic_group_finite_abelian_group-val"><b>fn_cyclic_group_finite_abelian_group</b></a>]  Theorem
      
       e f.
          (n. n  0  FUNPOW f n e = e) 
          FiniteAbelianGroup (fn_cyclic_group e f)
   
   [<a name="fn_cyclic_group_finite_group-val"><b>fn_cyclic_group_finite_group</b></a>]  Theorem
      
       e f.
          (n. n  0  FUNPOW f n e = e) 
          FiniteGroup (fn_cyclic_group e f)
   
   [<a name="fn_cyclic_group_group-val"><b>fn_cyclic_group_group</b></a>]  Theorem
      
       e f. (n. n  0  FUNPOW f n e = e)  Group (fn_cyclic_group e f)
   
   [<a name="fn_cyclic_group_id-val"><b>fn_cyclic_group_id</b></a>]  Theorem
      
       e f. (fn_cyclic_group e f).id = e
   
   [<a name="generated_Fermat-val"><b>generated_Fermat</b></a>]  Theorem
      
       g a.
          FiniteGroup g  a  G  x. x  Gen a  x ** CARD (Gen a) = #e
   
   [<a name="generated_carrier-val"><b>generated_carrier</b></a>]  Theorem
      
       g a. a  G  Gen a = IMAGE ($** a) (:num)
   
   [<a name="generated_carrier_as_image-val"><b>generated_carrier_as_image</b></a>]  Theorem
      
       g. Group g 
            a. a  G  0 &lt; ord a 
                Gen a = IMAGE (j. a ** j) (count (ord a))
   
   [<a name="generated_carrier_has_id-val"><b>generated_carrier_has_id</b></a>]  Theorem
      
       g a. #e  Gen a
   
   [<a name="generated_element-val"><b>generated_element</b></a>]  Theorem
      
       g a x. x  Gen a  n. x = a ** n
   
   [<a name="generated_exp-val"><b>generated_exp</b></a>]  Theorem
      
       g a z. a  G  z  Gen a  n. (gen a).exp z n = z ** n
   
   [<a name="generated_finite_group-val"><b>generated_finite_group</b></a>]  Theorem
      
       g a. FiniteGroup g  a  G  FiniteGroup (gen a)
   
   [<a name="generated_gen_element-val"><b>generated_gen_element</b></a>]  Theorem
      
       g. Group g  x. x  G  x  Gen x
   
   [<a name="generated_group-val"><b>generated_group</b></a>]  Theorem
      
       g a. FiniteGroup g  a  G  Group (gen a)
   
   [<a name="generated_group_card-val"><b>generated_group_card</b></a>]  Theorem
      
       g a. Group g  a  G  0 &lt; ord a  CARD (Gen a) = ord a
   
   [<a name="generated_group_finite-val"><b>generated_group_finite</b></a>]  Theorem
      
       g a. FiniteGroup g  a  G  FINITE (Gen a)
   
   [<a name="generated_id_carrier-val"><b>generated_id_carrier</b></a>]  Theorem
      
       g. Group g  Gen #e = {#e}
   
   [<a name="generated_id_subgroup-val"><b>generated_id_subgroup</b></a>]  Theorem
      
       g. Group g  gen #e  g
   
   [<a name="generated_image_subset_all_subgroups-val"><b>generated_image_subset_all_subgroups</b></a>]  Theorem
      
       g. FiniteGroup g  s. s  G  IMAGE gen s  all_subgroups g
   
   [<a name="generated_image_subset_power_set-val"><b>generated_image_subset_power_set</b></a>]  Theorem
      
       g. Group g  s. s  G  IMAGE (a. Gen a) s  POW G
   
   [<a name="generated_property-val"><b>generated_property</b></a>]  Theorem
      
       g a. (gen a).op = $*  (gen a).id = #e
   
   [<a name="generated_subgroup-val"><b>generated_subgroup</b></a>]  Theorem
      
       g a. FiniteGroup g  a  G  gen a  g
   
   [<a name="generated_subset-val"><b>generated_subset</b></a>]  Theorem
      
       g a. Group g  a  G  Gen a  G
   
   [<a name="group_all_invertible-val"><b>group_all_invertible</b></a>]  Theorem
      
       g. Group g  G* = G
   
   [<a name="group_alt-val"><b>group_alt</b></a>]  Theorem
      
       g. Group g 
            (x y::G. x * y  G)  (x y z::G. x * y * z = x * (y * z)) 
            #e  G  (x::G. #e * x = x)  x::G. |/ x  G  |/ x * x = #e
   
   [<a name="group_assoc-val"><b>group_assoc</b></a>]  Theorem
      
       g. Group g 
            x y z. x  G  y  G  z  G  x * y * z = x * (y * z)
   
   [<a name="group_auto_I-val"><b>group_auto_I</b></a>]  Theorem
      
       g. GroupAuto I g
   
   [<a name="group_auto_bij-val"><b>group_auto_bij</b></a>]  Theorem
      
       g f. GroupAuto f g  f PERMUTES G
   
   [<a name="group_auto_compose-val"><b>group_auto_compose</b></a>]  Theorem
      
       g f1 f2. GroupAuto f1 g  GroupAuto f2 g  GroupAuto (f1  f2) g
   
   [<a name="group_auto_element-val"><b>group_auto_element</b></a>]  Theorem
      
       f g. GroupAuto f g  x. x  G  f x  G
   
   [<a name="group_auto_exp-val"><b>group_auto_exp</b></a>]  Theorem
      
       g f.
          Group g  GroupAuto f g  x. x  G  n. f (x ** n) = f x ** n
   
   [<a name="group_auto_id-val"><b>group_auto_id</b></a>]  Theorem
      
       f g. Group g  GroupAuto f g  f #e = #e
   
   [<a name="group_auto_is_monoid_auto-val"><b>group_auto_is_monoid_auto</b></a>]  Theorem
      
       g f. Group g  GroupAuto f g  MonoidAuto f g
   
   [<a name="group_auto_linv_auto-val"><b>group_auto_linv_auto</b></a>]  Theorem
      
       g f. Group g  GroupAuto f g  GroupAuto (LINV f G) g
   
   [<a name="group_auto_order-val"><b>group_auto_order</b></a>]  Theorem
      
       g f. Group g  GroupAuto f g  x. x  G  ord (f x) = ord x
   
   [<a name="group_carrier_nonempty-val"><b>group_carrier_nonempty</b></a>]  Theorem
      
       g. Group g  G  
   
   [<a name="group_comm_exp-val"><b>group_comm_exp</b></a>]  Theorem
      
       g. Group g 
            x y.
              x  G  y  G  x * y = y * x  n. x ** n * y = y * x ** n
   
   [<a name="group_comm_exp_exp-val"><b>group_comm_exp_exp</b></a>]  Theorem
      
       g. Group g 
            x y.
              x  G  y  G  x * y = y * x 
              n m. x ** n * y ** m = y ** m * x ** n
   
   [<a name="group_comm_op_exp-val"><b>group_comm_op_exp</b></a>]  Theorem
      
       g. Group g 
            x y.
              x  G  y  G  x * y = y * x 
              n. (x * y) ** n = x ** n * y ** n
   
   [<a name="group_coset_eq_itself-val"><b>group_coset_eq_itself</b></a>]  Theorem
      
       g a. Group g  a  G  a * G = G
   
   [<a name="group_coset_is_permutation-val"><b>group_coset_is_permutation</b></a>]  Theorem
      
       g a. Group g  a  G  a * G = G
   
   [<a name="group_def_alt-val"><b>group_def_alt</b></a>]  Theorem
      
       g. Group g 
            (x y. x  G  y  G  x * y  G) 
            (x y z. x  G  y  G  z  G  x * y * z = x * (y * z)) 
            #e  G  (x. x  G  #e * x = x) 
            x. x  G  y. y  G  y * x = #e
   
   [<a name="group_def_by_inverse-val"><b>group_def_by_inverse</b></a>]  Theorem
      
       g. Group g  Monoid g  x. x  G  y. y  G  y * x = #e
   
   [<a name="group_div_cancel-val"><b>group_div_cancel</b></a>]  Theorem
      
       g. Group g  x. x  G  x / x = #e
   
   [<a name="group_div_element-val"><b>group_div_element</b></a>]  Theorem
      
       g. Group g  x y. x  G  y  G  x / y  G
   
   [<a name="group_div_lsame-val"><b>group_div_lsame</b></a>]  Theorem
      
       g. Group g 
            x y z.
              x  G  y  G  z  G  z * x / (z * y) = z * (x / y) / z
   
   [<a name="group_div_pair-val"><b>group_div_pair</b></a>]  Theorem
      
       g. Group g 
            x1 y1 x2 y2.
              x1  G  y1  G  x2  G  y2  G 
              x1 * y1 / (x2 * y2) = x1 * (y1 / y2) / x1 * (x1 / x2)
   
   [<a name="group_div_rsame-val"><b>group_div_rsame</b></a>]  Theorem
      
       g. Group g 
            x y z. x  G  y  G  z  G  x * z / (y * z) = x / y
   
   [<a name="group_excluding_exp-val"><b>group_excluding_exp</b></a>]  Theorem
      
       g z x n. (g excluding z).exp x n = x ** n
   
   [<a name="group_excluding_op-val"><b>group_excluding_op</b></a>]  Theorem
      
       g z. (g excluding z).op = $*
   
   [<a name="group_excluding_property-val"><b>group_excluding_property</b></a>]  Theorem
      
       g z.
          (g excluding z).op = $*  (g excluding z).id = #e 
          x. x  (g excluding z).carrier  x  G  x  z
   
   [<a name="group_exp_0-val"><b>group_exp_0</b></a>]  Theorem
      
       g x. x ** 0 = #e
   
   [<a name="group_exp_1-val"><b>group_exp_1</b></a>]  Theorem
      
       g. Group g  x. x  G  x ** 1 = x
   
   [<a name="group_exp_SUC-val"><b>group_exp_SUC</b></a>]  Theorem
      
       g x n. x ** SUC n = x * x ** n
   
   [<a name="group_exp_add-val"><b>group_exp_add</b></a>]  Theorem
      
       g. Group g  x. x  G  n k. x ** (n + k) = x ** n * x ** k
   
   [<a name="group_exp_comm-val"><b>group_exp_comm</b></a>]  Theorem
      
       g. Group g  x. x  G  n. x ** n * x = x * x ** n
   
   [<a name="group_exp_element-val"><b>group_exp_element</b></a>]  Theorem
      
       g. Group g  x. x  G  n. x ** n  G
   
   [<a name="group_exp_eq-val"><b>group_exp_eq</b></a>]  Theorem
      
       g. Group g 
            x. x  G  m n. m &lt; n  x ** m = x ** n  x ** (n  m) = #e
   
   [<a name="group_exp_eq_condition-val"><b>group_exp_eq_condition</b></a>]  Theorem
      
       g x.
          Group g  x  G  0 &lt; ord x 
          n m. x ** n = x ** m  n MOD ord x = m MOD ord x
   
   [<a name="group_exp_equal-val"><b>group_exp_equal</b></a>]  Theorem
      
       g x.
          Group g  x  G 
          n m. n &lt; ord x  m &lt; ord x  x ** n = x ** m  n = m
   
   [<a name="group_exp_inv-val"><b>group_exp_inv</b></a>]  Theorem
      
       g. Group g  x. x  G  n. |/ (x ** n) = |/ x ** n
   
   [<a name="group_exp_mod-val"><b>group_exp_mod</b></a>]  Theorem
      
       g. Group g 
            x. x  G  0 &lt; ord x  n. x ** n = x ** (n MOD ord x)
   
   [<a name="group_exp_mod_order-val"><b>group_exp_mod_order</b></a>]  Theorem
      
       g. Group g 
            x. x  G  0 &lt; ord x  n. x ** n = x ** (n MOD ord x)
   
   [<a name="group_exp_mult-val"><b>group_exp_mult</b></a>]  Theorem
      
       g. Group g  x. x  G  n k. x ** (n * k) = (x ** n) ** k
   
   [<a name="group_exp_mult_comm-val"><b>group_exp_mult_comm</b></a>]  Theorem
      
       g. Group g  x. x  G  m n. (x ** m) ** n = (x ** n) ** m
   
   [<a name="group_exp_suc-val"><b>group_exp_suc</b></a>]  Theorem
      
       g. Group g  x. x  G  n. x ** SUC n = x ** n * x
   
   [<a name="group_first_isomorphism_thm-val"><b>group_first_isomorphism_thm</b></a>]  Theorem
      
       g h f.
          Group g  Group h  GroupHomo f g h 
          kernel_group f g h &lt;&lt; g  homo_image f g h  h 
          GroupIso (z. CHOICE (preimage f G z) * kernel f g h)
            (homo_image f g h) (g / kernel_group f g h) 
          (SURJ f G h.carrier  GroupIso I h (homo_image f g h))
   
   [<a name="group_homo_I_refl-val"><b>group_homo_I_refl</b></a>]  Theorem
      
       g. GroupHomo I g g
   
   [<a name="group_homo_compose-val"><b>group_homo_compose</b></a>]  Theorem
      
       g h k f1 f2.
          GroupHomo f1 g h  GroupHomo f2 h k  GroupHomo (f2  f1) g k
   
   [<a name="group_homo_cong-val"><b>group_homo_cong</b></a>]  Theorem
      
       g h f1 f2.
          Group g  Group h  (x. x  G  f1 x = f2 x) 
          (GroupHomo f1 g h  GroupHomo f2 g h)
   
   [<a name="group_homo_element-val"><b>group_homo_element</b></a>]  Theorem
      
       f g h. GroupHomo f g h  x. x  G  f x  h.carrier
   
   [<a name="group_homo_exp-val"><b>group_homo_exp</b></a>]  Theorem
      
       g h f.
          Group g  Group h  GroupHomo f g h 
          x. x  G  n. f (x ** n) = h.exp (f x) n
   
   [<a name="group_homo_homo_image_group-val"><b>group_homo_homo_image_group</b></a>]  Theorem
      
       g h f. Group g  MonoidHomo f g h  Group (homo_image f g h)
   
   [<a name="group_homo_id-val"><b>group_homo_id</b></a>]  Theorem
      
       f g h. Group g  Group h  GroupHomo f g h  f #e = h.id
   
   [<a name="group_homo_image_surj_property-val"><b>group_homo_image_surj_property</b></a>]  Theorem
      
       g h f.
          Group g  Group h  SURJ f G h.carrier 
          GroupIso I h (homo_image f g h)
   
   [<a name="group_homo_inv-val"><b>group_homo_inv</b></a>]  Theorem
      
       f g h.
          Group g  Group h  GroupHomo f g h 
          x. x  G  f ( |/ x) = h.inv (f x)
   
   [<a name="group_homo_is_monoid_homo-val"><b>group_homo_is_monoid_homo</b></a>]  Theorem
      
       g h f. Group g  Group h  GroupHomo f g h  MonoidHomo f g h
   
   [<a name="group_homo_monoid_homo-val"><b>group_homo_monoid_homo</b></a>]  Theorem
      
       f g h. GroupHomo f g h  f #e = h.id  MonoidHomo f g h
   
   [<a name="group_homo_sym-val"><b>group_homo_sym</b></a>]  Theorem
      
       g h f.
          Group g  GroupHomo f g h  BIJ f G h.carrier 
          GroupHomo (LINV f G) h g
   
   [<a name="group_homo_sym_any-val"><b>group_homo_sym_any</b></a>]  Theorem
      
       Group g  GroupHomo f g h 
        (x. x  h.carrier  i x  G  f (i x) = x) 
        (x. x  G  i (f x) = x) 
        GroupHomo i h g
   
   [<a name="group_homo_trans-val"><b>group_homo_trans</b></a>]  Theorem
      
       g h k f1 f2.
          GroupHomo f1 g h  GroupHomo f2 h k  GroupHomo (f2  f1) g k
   
   [<a name="group_id-val"><b>group_id</b></a>]  Theorem
      
       g. Group g  x. x  G  #e * x = x  x * #e = x
   
   [<a name="group_id_element-val"><b>group_id_element</b></a>]  Theorem
      
       g. Group g  #e  G
   
   [<a name="group_id_exp-val"><b>group_id_exp</b></a>]  Theorem
      
       g. Group g  n. #e ** n = #e
   
   [<a name="group_id_fix-val"><b>group_id_fix</b></a>]  Theorem
      
       g. Group g  x. x  G  (x * x = x  x = #e)
   
   [<a name="group_id_id-val"><b>group_id_id</b></a>]  Theorem
      
       g. Group g  #e * #e = #e
   
   [<a name="group_id_unique-val"><b>group_id_unique</b></a>]  Theorem
      
       g. Group g 
            x y.
              x  G  y  G  (y * x = x  y = #e)  (x * y = x  y = #e)
   
   [<a name="group_image_as_op_image-val"><b>group_image_as_op_image</b></a>]  Theorem
      
       g. GPI = OP_IMAGE $* #e
   
   [<a name="group_image_empty-val"><b>group_image_empty</b></a>]  Theorem
      
       g f. GPI f  = #e
   
   [<a name="group_image_sing-val"><b>group_image_sing</b></a>]  Theorem
      
       g. Monoid g  f. gfun f  x. x  G  GPI f {x} = f x
   
   [<a name="group_including_excluding_abelian-val"><b>group_including_excluding_abelian</b></a>]  Theorem
      
       g z.
          z  G 
          (AbelianGroup g  AbelianGroup (g including z excluding z))
   
   [<a name="group_including_excluding_eqn-val"><b>group_including_excluding_eqn</b></a>]  Theorem
      
       g z.
          g including z excluding z =
          if z  G then &lt;|carrier := G DELETE z; op := $*; id := #e|&gt;
          else g
   
   [<a name="group_including_excluding_group-val"><b>group_including_excluding_group</b></a>]  Theorem
      
       g z. z  G  (Group g  Group (g including z excluding z))
   
   [<a name="group_including_excluding_property-val"><b>group_including_excluding_property</b></a>]  Theorem
      
       g z.
          (g including z excluding z).op = $* 
          (g including z excluding z).id = #e 
          (z  G  (g including z excluding z).carrier = G)
   
   [<a name="group_including_property-val"><b>group_including_property</b></a>]  Theorem
      
       g z.
          (g including z).op = $*  (g including z).id = #e 
          x. x  (g including z).carrier  x  G  x = z
   
   [<a name="group_inj_image_abelian_group-val"><b>group_inj_image_abelian_group</b></a>]  Theorem
      
       g f.
          AbelianGroup g  INJ f G (:) 
          AbelianGroup (monoid_inj_image g f)
   
   [<a name="group_inj_image_excluding_abelian_group-val"><b>group_inj_image_excluding_abelian_group</b></a>]  Theorem
      
       g f e.
          AbelianGroup (g excluding e)  INJ f G (:)  e  G 
          AbelianGroup (monoid_inj_image g f excluding f e)
   
   [<a name="group_inj_image_excluding_group-val"><b>group_inj_image_excluding_group</b></a>]  Theorem
      
       g f e.
          Group (g excluding e)  INJ f G (:)  e  G 
          Group (monoid_inj_image g f excluding f e)
   
   [<a name="group_inj_image_group-val"><b>group_inj_image_group</b></a>]  Theorem
      
       g f. Group g  INJ f G (:)  Group (monoid_inj_image g f)
   
   [<a name="group_inj_image_group_homo-val"><b>group_inj_image_group_homo</b></a>]  Theorem
      
       g f. INJ f G (:)  GroupHomo f g (monoid_inj_image g f)
   
   [<a name="group_inv_element-val"><b>group_inv_element</b></a>]  Theorem
      
       g. Group g  x. x  G  |/ x  G
   
   [<a name="group_inv_eq-val"><b>group_inv_eq</b></a>]  Theorem
      
       g. Group g  x y. x  G  y  G  ( |/ x = |/ y  x = y)
   
   [<a name="group_inv_eq_id-val"><b>group_inv_eq_id</b></a>]  Theorem
      
       g. Group g  x. x  G  ( |/ x = #e  x = #e)
   
   [<a name="group_inv_eq_swap-val"><b>group_inv_eq_swap</b></a>]  Theorem
      
       g. Group g  x y. x  G  y  G  ( |/ x = y  x = |/ y)
   
   [<a name="group_inv_exp-val"><b>group_inv_exp</b></a>]  Theorem
      
       g. Group g  x. x  G  n. |/ x ** n = |/ (x ** n)
   
   [<a name="group_inv_id-val"><b>group_inv_id</b></a>]  Theorem
      
       g. Group g  |/ #e = #e
   
   [<a name="group_inv_inv-val"><b>group_inv_inv</b></a>]  Theorem
      
       g. Group g  x. x  G  |/ ( |/ x) = x
   
   [<a name="group_inv_op-val"><b>group_inv_op</b></a>]  Theorem
      
       g. Group g  x y. x  G  y  G  |/ (x * y) = |/ y * |/ x
   
   [<a name="group_inv_order-val"><b>group_inv_order</b></a>]  Theorem
      
       g x. Group g  x  G  ord ( |/ x) = ord x
   
   [<a name="group_inv_thm-val"><b>group_inv_thm</b></a>]  Theorem
      
       g. Group g  x. x  G  x * |/ x = #e  |/ x * x = #e
   
   [<a name="group_is_monoid-val"><b>group_is_monoid</b></a>]  Theorem
      
       g. Group g  Monoid g
   
   [<a name="group_iso_I_refl-val"><b>group_iso_I_refl</b></a>]  Theorem
      
       g. GroupIso I g g
   
   [<a name="group_iso_bij-val"><b>group_iso_bij</b></a>]  Theorem
      
       g h f. GroupIso f g h  BIJ f G h.carrier
   
   [<a name="group_iso_card_eq-val"><b>group_iso_card_eq</b></a>]  Theorem
      
       g h f. GroupIso f g h  FINITE G  CARD G = CARD h.carrier
   
   [<a name="group_iso_compose-val"><b>group_iso_compose</b></a>]  Theorem
      
       g h k f1 f2.
          GroupIso f1 g h  GroupIso f2 h k  GroupIso (f2  f1) g k
   
   [<a name="group_iso_element-val"><b>group_iso_element</b></a>]  Theorem
      
       f g h. GroupIso f g h  x. x  G  f x  h.carrier
   
   [<a name="group_iso_exp-val"><b>group_iso_exp</b></a>]  Theorem
      
       g h f.
          Group g  Group h  GroupIso f g h 
          x. x  G  n. f (x ** n) = h.exp (f x) n
   
   [<a name="group_iso_group-val"><b>group_iso_group</b></a>]  Theorem
      
       g h f. Group g  GroupIso f g h  f #e = h.id  Group h
   
   [<a name="group_iso_id-val"><b>group_iso_id</b></a>]  Theorem
      
       f g h. Group g  Group h  GroupIso f g h  f #e = h.id
   
   [<a name="group_iso_is_monoid_iso-val"><b>group_iso_is_monoid_iso</b></a>]  Theorem
      
       g h f. Group g  Group h  GroupIso f g h  MonoidIso f g h
   
   [<a name="group_iso_linv_iso-val"><b>group_iso_linv_iso</b></a>]  Theorem
      
       g h f. Group g  GroupIso f g h  GroupIso (LINV f G) h g
   
   [<a name="group_iso_monoid_iso-val"><b>group_iso_monoid_iso</b></a>]  Theorem
      
       f g h. GroupIso f g h  f #e = h.id  MonoidIso f g h
   
   [<a name="group_iso_order-val"><b>group_iso_order</b></a>]  Theorem
      
       g h f.
          Group g  Group h  GroupIso f g h 
          x. x  G  order h (f x) = ord x
   
   [<a name="group_iso_property-val"><b>group_iso_property</b></a>]  Theorem
      
       f g h.
          GroupIso f g h 
          GroupHomo f g h  y. y  h.carrier  !x. x  G  f x = y
   
   [<a name="group_iso_sym-val"><b>group_iso_sym</b></a>]  Theorem
      
       g h f. Group g  GroupIso f g h  GroupIso (LINV f G) h g
   
   [<a name="group_iso_trans-val"><b>group_iso_trans</b></a>]  Theorem
      
       g h k f1 f2.
          GroupIso f1 g h  GroupIso f2 h k  GroupIso (f2  f1) g k
   
   [<a name="group_lcancel-val"><b>group_lcancel</b></a>]  Theorem
      
       g. Group g 
            x y z. x  G  y  G  z  G  (x * y = x * z  y = z)
   
   [<a name="group_lid-val"><b>group_lid</b></a>]  Theorem
      
       g. Group g  x. x  G  #e * x = x
   
   [<a name="group_lid_unique-val"><b>group_lid_unique</b></a>]  Theorem
      
       g. Group g  x y. x  G  y  G  (y * x = x  y = #e)
   
   [<a name="group_linv-val"><b>group_linv</b></a>]  Theorem
      
       g. Group g  x. x  G  |/ x * x = #e
   
   [<a name="group_linv_assoc-val"><b>group_linv_assoc</b></a>]  Theorem
      
       g. Group g 
            x y. x  G  y  G  y = x * ( |/ x * y)  y = |/ x * (x * y)
   
   [<a name="group_linv_unique-val"><b>group_linv_unique</b></a>]  Theorem
      
       g. Group g  x y. x  G  y  G  (x * y = #e  x = |/ y)
   
   [<a name="group_lsolve-val"><b>group_lsolve</b></a>]  Theorem
      
       g. Group g 
            x y z. x  G  y  G  z  G  (x * y = z  x = z * |/ y)
   
   [<a name="group_normal_equiv-val"><b>group_normal_equiv</b></a>]  Theorem
      
       g h. h &lt;&lt; g  $== equiv_on G
   
   [<a name="group_normal_equiv_property-val"><b>group_normal_equiv_property</b></a>]  Theorem
      
       h g. h &lt;&lt; g  x y. x  G  y  G  (x == y  x  y * H)
   
   [<a name="group_normal_equiv_reflexive-val"><b>group_normal_equiv_reflexive</b></a>]  Theorem
      
       g h. h &lt;&lt; g  z. z  G  z == z
   
   [<a name="group_normal_equiv_symmetric-val"><b>group_normal_equiv_symmetric</b></a>]  Theorem
      
       g h. h &lt;&lt; g  x y. x  G  y  G  (x == y  y == x)
   
   [<a name="group_normal_equiv_transitive-val"><b>group_normal_equiv_transitive</b></a>]  Theorem
      
       g h.
          h &lt;&lt; g  x y z. x  G  y  G  z  G  x == y  y == z  x == z
   
   [<a name="group_op_element-val"><b>group_op_element</b></a>]  Theorem
      
       g. Group g  x y. x  G  y  G  x * y  G
   
   [<a name="group_op_linv_eq_id-val"><b>group_op_linv_eq_id</b></a>]  Theorem
      
       g. Group g  x y. x  G  y  G  ( |/ x * y = #e  x = y)
   
   [<a name="group_op_linv_eqn-val"><b>group_op_linv_eqn</b></a>]  Theorem
      
       g. Group g 
            x y z. x  G  y  G  z  G  ( |/ x * y = z  y = x * z)
   
   [<a name="group_op_rinv_eq_id-val"><b>group_op_rinv_eq_id</b></a>]  Theorem
      
       g. Group g  x y. x  G  y  G  (x * |/ y = #e  x = y)
   
   [<a name="group_op_rinv_eqn-val"><b>group_op_rinv_eqn</b></a>]  Theorem
      
       g. Group g 
            x y z. x  G  y  G  z  G  (x * |/ y = z  x = z * y)
   
   [<a name="group_order_cofactor-val"><b>group_order_cofactor</b></a>]  Theorem
      
       g. Group g 
            x n.
              x  G  0 &lt; ord x  n divides ord x 
              ord (x ** (ord x DIV n)) = n
   
   [<a name="group_order_common-val"><b>group_order_common</b></a>]  Theorem
      
       g. Group g 
            x y.
              x  G  y  G  x * y = y * x 
              z. z  G  ord z * gcd (ord x) (ord y) = lcm (ord x) (ord y)
   
   [<a name="group_order_common_coprime-val"><b>group_order_common_coprime</b></a>]  Theorem
      
       g. Group g 
            x y.
              x  G  y  G  x * y = y * x  coprime (ord x) (ord y) 
              z. z  G  ord z = ord x * ord y
   
   [<a name="group_order_condition-val"><b>group_order_condition</b></a>]  Theorem
      
       g. Group g  x. x  G  m. x ** m = #e  ord x divides m
   
   [<a name="group_order_divides-val"><b>group_order_divides</b></a>]  Theorem
      
       g. FiniteGroup g  x. x  G  ord x divides CARD G
   
   [<a name="group_order_divides_exp-val"><b>group_order_divides_exp</b></a>]  Theorem
      
       g x. Group g  x  G  n. x ** n = #e  ord x divides n
   
   [<a name="group_order_divides_maximal-val"><b>group_order_divides_maximal</b></a>]  Theorem
      
       g. FiniteAbelianGroup g 
            x. x  G  ord x divides maximal_order g
   
   [<a name="group_order_divisor-val"><b>group_order_divisor</b></a>]  Theorem
      
       g. Group g 
            x m.
              x  G  0 &lt; ord x  m divides ord x  y. y  G  ord y = m
   
   [<a name="group_order_eq_1-val"><b>group_order_eq_1</b></a>]  Theorem
      
       g. Group g  x. x  G  (ord x = 1  x = #e)
   
   [<a name="group_order_exp_cofactor-val"><b>group_order_exp_cofactor</b></a>]  Theorem
      
       g x n.
          Group g  x  G  0 &lt; ord x  n divides ord x 
          ord (x ** (ord x DIV n)) = n
   
   [<a name="group_order_id-val"><b>group_order_id</b></a>]  Theorem
      
       g. Group g  ord #e = 1
   
   [<a name="group_order_inv-val"><b>group_order_inv</b></a>]  Theorem
      
       g. Group g  x. x  G  0 &lt; ord x  |/ x = x ** (ord x  1)
   
   [<a name="group_order_nonzero-val"><b>group_order_nonzero</b></a>]  Theorem
      
       g. FiniteGroup g  x. x  G  ord x  0
   
   [<a name="group_order_pos-val"><b>group_order_pos</b></a>]  Theorem
      
       g. FiniteGroup g  x. x  G  0 &lt; ord x
   
   [<a name="group_order_power-val"><b>group_order_power</b></a>]  Theorem
      
       g. Group g  x. x  G  k. ord (x ** k) * gcd (ord x) k = ord x
   
   [<a name="group_order_power_coprime-val"><b>group_order_power_coprime</b></a>]  Theorem
      
       g. Group g 
            x. x  G  n. coprime n (ord x)  ord (x ** n) = ord x
   
   [<a name="group_order_power_eq_0-val"><b>group_order_power_eq_0</b></a>]  Theorem
      
       g. Group g  x. x  G  k. ord (x ** k) = 0  0 &lt; k  ord x = 0
   
   [<a name="group_order_power_eq_order-val"><b>group_order_power_eq_order</b></a>]  Theorem
      
       g x.
          Group g  x  G  0 &lt; ord x 
          k. ord (x ** k) = ord x  coprime k (ord x)
   
   [<a name="group_order_power_eqn-val"><b>group_order_power_eqn</b></a>]  Theorem
      
       g. Group g 
            x k. x  G  0 &lt; k  ord (x ** k) = ord x DIV gcd k (ord x)
   
   [<a name="group_order_property-val"><b>group_order_property</b></a>]  Theorem
      
       g. FiniteGroup g  x. x  G  0 &lt; ord x  x ** ord x = #e
   
   [<a name="group_order_thm-val"><b>group_order_thm</b></a>]  Theorem
      
       g n.
          0 &lt; n 
          x. ord x = n  x ** n = #e  m. 0 &lt; m  m &lt; n  x ** m  #e
   
   [<a name="group_order_to_generated_bij-val"><b>group_order_to_generated_bij</b></a>]  Theorem
      
       g a.
          Group g  a  G  0 &lt; ord a 
          BIJ (n. a ** n) (count (ord a)) (Gen a)
   
   [<a name="group_order_unique-val"><b>group_order_unique</b></a>]  Theorem
      
       g. Group g 
            x. x  G 
                m n. m &lt; ord x  n &lt; ord x  x ** m = x ** n  m = n
   
   [<a name="group_orders_eq_1-val"><b>group_orders_eq_1</b></a>]  Theorem
      
       g. Group g  orders g 1 = {#e}
   
   [<a name="group_pair_reduce-val"><b>group_pair_reduce</b></a>]  Theorem
      
       g. Group g 
            x y z. x  G  y  G  z  G  x * z * |/ (y * z) = x * |/ y
   
   [<a name="group_rcancel-val"><b>group_rcancel</b></a>]  Theorem
      
       g. Group g 
            x y z. x  G  y  G  z  G  (y * x = z * x  y = z)
   
   [<a name="group_rid-val"><b>group_rid</b></a>]  Theorem
      
       g. Group g  x. x  G  x * #e = x
   
   [<a name="group_rid_unique-val"><b>group_rid_unique</b></a>]  Theorem
      
       g. Group g  x y. x  G  y  G  (x * y = x  y = #e)
   
   [<a name="group_rinv-val"><b>group_rinv</b></a>]  Theorem
      
       g. Group g  x. x  G  x * |/ x = #e
   
   [<a name="group_rinv_assoc-val"><b>group_rinv_assoc</b></a>]  Theorem
      
       g. Group g 
            x y. x  G  y  G  y = y * |/ x * x  y = y * x * |/ x
   
   [<a name="group_rinv_unique-val"><b>group_rinv_unique</b></a>]  Theorem
      
       g. Group g  x y. x  G  y  G  (x * y = #e  y = |/ x)
   
   [<a name="group_rsolve-val"><b>group_rsolve</b></a>]  Theorem
      
       g. Group g 
            x y z. x  G  y  G  z  G  (x * y = z  y = |/ x * z)
   
   [<a name="group_uroots_group-val"><b>group_uroots_group</b></a>]  Theorem
      
       g. AbelianGroup g  n. Group (uroots n)
   
   [<a name="group_uroots_has_id-val"><b>group_uroots_has_id</b></a>]  Theorem
      
       g. Group g  n. #e  (uroots n).carrier
   
   [<a name="group_uroots_subgroup-val"><b>group_uroots_subgroup</b></a>]  Theorem
      
       g. AbelianGroup g  n. uroots n  g
   
   [<a name="homo_count_formula-val"><b>homo_count_formula</b></a>]  Theorem
      
       f g1 g2 h.
          FiniteGroup g1  Group g2  h  g2  GroupHomo f g1 g2 
          CARD (preimage_group f g1 g2 h.carrier).carrier =
          CARD
            (kernel_group f (preimage_group f g1 g2 h.carrier) g2).carrier *
          CARD
            (preimage_group f g1 g2 h.carrier /
             kernel_group f (preimage_group f g1 g2 h.carrier) g2).carrier
   
   [<a name="homo_group_abelian_group-val"><b>homo_group_abelian_group</b></a>]  Theorem
      
       g f.
          AbelianGroup g  GroupHomo f g (homo_group g f) 
          AbelianGroup (homo_group g f)
   
   [<a name="homo_group_assoc-val"><b>homo_group_assoc</b></a>]  Theorem
      
       g f.
          Group g  GroupHomo f g (homo_group g f) 
          x y z. x  fG  y  fG  z  fG  (x  y)  z = x  y  z
   
   [<a name="homo_group_by_inj-val"><b>homo_group_by_inj</b></a>]  Theorem
      
       g f. Group g  INJ f G (:)  GroupHomo f g (homo_group g f)
   
   [<a name="homo_group_closure-val"><b>homo_group_closure</b></a>]  Theorem
      
       g f.
          Group g  GroupHomo f g (homo_group g f) 
          x y. x  fG  y  fG  x  y  fG
   
   [<a name="homo_group_comm-val"><b>homo_group_comm</b></a>]  Theorem
      
       g f.
          AbelianGroup g  GroupHomo f g (homo_group g f) 
          x y. x  fG  y  fG  x  y = y  x
   
   [<a name="homo_group_group-val"><b>homo_group_group</b></a>]  Theorem
      
       g f.
          Group g  GroupHomo f g (homo_group g f)  Group (homo_group g f)
   
   [<a name="homo_group_id-val"><b>homo_group_id</b></a>]  Theorem
      
       g f.
          Group g  GroupHomo f g (homo_group g f) 
          #i  fG  x. x  fG  #i  x = x  x  #i = x
   
   [<a name="homo_group_inv-val"><b>homo_group_inv</b></a>]  Theorem
      
       g f.
          Group g  GroupHomo f g (homo_group g f) 
          x. x  fG  z. z  fG  z  x = #i
   
   [<a name="homo_image_group-val"><b>homo_image_group</b></a>]  Theorem
      
       g h f.
          Group g  Group h  GroupHomo f g h  Group (homo_image f g h)
   
   [<a name="homo_image_homo_quotient_kernel-val"><b>homo_image_homo_quotient_kernel</b></a>]  Theorem
      
       g h f.
          Group g  Group h  GroupHomo f g h 
          GroupHomo (z. CHOICE (preimage f G z) * kernel f g h)
            (homo_image f g h) (g / kernel_group f g h)
   
   [<a name="homo_image_iso_quotient_kernel-val"><b>homo_image_iso_quotient_kernel</b></a>]  Theorem
      
       g h f.
          Group g  Group h  GroupHomo f g h 
          GroupIso (z. CHOICE (preimage f G z) * kernel f g h)
            (homo_image f g h) (g / kernel_group f g h)
   
   [<a name="homo_image_monoid-val"><b>homo_image_monoid</b></a>]  Theorem
      
       g h f.
          Monoid g  Monoid h  MonoidHomo f g h 
          Monoid (homo_image f g h)
   
   [<a name="homo_image_subgroup-val"><b>homo_image_subgroup</b></a>]  Theorem
      
       g h f. Group g  Group h  GroupHomo f g h  homo_image f g h  h
   
   [<a name="homo_image_to_quotient_kernel_bij-val"><b>homo_image_to_quotient_kernel_bij</b></a>]  Theorem
      
       g h f.
          Group g  Group h  GroupHomo f g h 
          BIJ (z. CHOICE (preimage f G z) * kernel f g h)
            (homo_image f g h).carrier (g / kernel_group f g h).carrier
   
   [<a name="homo_restrict_same_kernel-val"><b>homo_restrict_same_kernel</b></a>]  Theorem
      
       f g1 g2 h.
          H  g1.carrier  GroupHomo f g1 g2  kernel f g1 g2  H 
          kernel f g1 g2 = kernel f h g2
   
   [<a name="image_iso_preimage_quotient-val"><b>image_iso_preimage_quotient</b></a>]  Theorem
      
       f g1 g2 h.
          Group g1  Group g2  h  g2  GroupHomo f g1 g2 
          GroupIso
            (z.
                 coset (preimage_group f g1 g2 h.carrier)
                   (CHOICE
                      (preimage f
                         (preimage_group f g1 g2 h.carrier).carrier z))
                   (kernel f (preimage_group f g1 g2 h.carrier) g2))
            (homo_image f (preimage_group f g1 g2 h.carrier) g2)
            (preimage_group f g1 g2 h.carrier /
             kernel_group f (preimage_group f g1 g2 h.carrier) g2)
   
   [<a name="image_preimage_group-val"><b>image_preimage_group</b></a>]  Theorem
      
       f g1 g2 h.
          Group g1  Group g2  h  g2  GroupHomo f g1 g2 
          SURJ f g1.carrier g2.carrier 
          IMAGE f (PREIMAGE f h.carrier  g1.carrier) = h.carrier
   
   [<a name="image_preimage_quotient_same_card-val"><b>image_preimage_quotient_same_card</b></a>]  Theorem
      
       f g1 g2 h.
          FiniteGroup g1  Group g2  h  g2  GroupHomo f g1 g2 
          CARD (homo_image f (preimage_group f g1 g2 h.carrier) g2).carrier =
          CARD
            (preimage_group f g1 g2 h.carrier /
             kernel_group f (preimage_group f g1 g2 h.carrier) g2).carrier
   
   [<a name="image_subgroup_subgroup-val"><b>image_subgroup_subgroup</b></a>]  Theorem
      
       g1 g2 h f.
          Group g1  Group g2  GroupHomo f g1 g2  h  g1 
          homo_image f h g2  g2
   
   [<a name="inCoset_equiv_on_carrier-val"><b>inCoset_equiv_on_carrier</b></a>]  Theorem
      
       g h. h  g  inCoset g h equiv_on G
   
   [<a name="inCoset_refl-val"><b>inCoset_refl</b></a>]  Theorem
      
       g h. h  g  a. a  G  inCoset g h a a
   
   [<a name="inCoset_sym-val"><b>inCoset_sym</b></a>]  Theorem
      
       g h.
          h  g  a b. a  G  b  G  inCoset g h a b  inCoset g h b a
   
   [<a name="inCoset_trans-val"><b>inCoset_trans</b></a>]  Theorem
      
       g h.
          h  g 
          a b c.
            a  G  b  G  c  G  inCoset g h a b  inCoset g h b c 
            inCoset g h a c
   
   [<a name="in_coset-val"><b>in_coset</b></a>]  Theorem
      
       g X a. a  G  x. x  a * X  y. y  X  x = a * y
   
   [<a name="independent_generated_eq-val"><b>independent_generated_eq</b></a>]  Theorem
      
       g. Group g 
            a b.
              a  G  b  G  independent g a b  (gen a = gen b  a = b)
   
   [<a name="independent_generator_2_card-val"><b>independent_generator_2_card</b></a>]  Theorem
      
       g. FiniteGroup g 
            a b.
              a  G  b  G  independent g a b 
              CARD (gen a  gen b).carrier = ord a * ord b
   
   [<a name="independent_sym-val"><b>independent_sym</b></a>]  Theorem
      
       g a b. independent g a b  independent g b a
   
   [<a name="iso_group_same_card-val"><b>iso_group_same_card</b></a>]  Theorem
      
       f g h. FINITE G  GroupIso f g h  CARD G = CARD h.carrier
   
   [<a name="kernel_element-val"><b>kernel_element</b></a>]  Theorem
      
       g h f x. x  kernel f g h  x  G  f x = h.id
   
   [<a name="kernel_group_group-val"><b>kernel_group_group</b></a>]  Theorem
      
       g h f.
          Group g  Group h  GroupHomo f g h  Group (kernel_group f g h)
   
   [<a name="kernel_group_normal-val"><b>kernel_group_normal</b></a>]  Theorem
      
       g h f.
          Group g  Group h  GroupHomo f g h  kernel_group f g h &lt;&lt; g
   
   [<a name="kernel_group_subgroup-val"><b>kernel_group_subgroup</b></a>]  Theorem
      
       g h f.
          Group g  Group h  GroupHomo f g h  kernel_group f g h  g
   
   [<a name="kernel_property-val"><b>kernel_property</b></a>]  Theorem
      
       g h f x. x  kernel f g h  x  G  f x = h.id
   
   [<a name="kernel_quotient_group-val"><b>kernel_quotient_group</b></a>]  Theorem
      
       g h f.
          Group g  Group h  GroupHomo f g h 
          Group (g / kernel_group f g h)
   
   [<a name="left_coset_alt-val"><b>left_coset_alt</b></a>]  Theorem
      
       g X a. left_coset g X a = {a * z | z  X}
   
   [<a name="make_group_property-val"><b>make_group_property</b></a>]  Theorem
      
       g s.
          (make_group g s).carrier = s  (make_group g s).op = $* 
          (make_group g s).id = #e
   
   [<a name="monoid_homo_homo_image_monoid-val"><b>monoid_homo_homo_image_monoid</b></a>]  Theorem
      
       g h f. Monoid g  MonoidHomo f g h  Monoid (homo_image f g h)
   
   [<a name="monoid_inv_id-val"><b>monoid_inv_id</b></a>]  Theorem
      
       g. Monoid g  |/ #e = #e
   
   [<a name="monoid_inv_order-val"><b>monoid_inv_order</b></a>]  Theorem
      
       g x. Monoid g  x  G*  ord ( |/ x) = ord x
   
   [<a name="monoid_inv_order_property-val"><b>monoid_inv_order_property</b></a>]  Theorem
      
       g. FiniteMonoid g  x. x  G*  0 &lt; ord x  x ** ord x = #e
   
   [<a name="monoid_invertibles_is_group-val"><b>monoid_invertibles_is_group</b></a>]  Theorem
      
       g. Monoid g  Group (Invertibles g)
   
   [<a name="mult_mod_abelian_group-val"><b>mult_mod_abelian_group</b></a>]  Theorem
      
       p. prime p  AbelianGroup (mult_mod p)
   
   [<a name="mult_mod_card-val"><b>mult_mod_card</b></a>]  Theorem
      
       p. 0 &lt; p  CARD (mult_mod p).carrier = p  1
   
   [<a name="mult_mod_carrier-val"><b>mult_mod_carrier</b></a>]  Theorem
      
       p. (mult_mod p).carrier = {i | i  0  i &lt; p}
   
   [<a name="mult_mod_carrier_alt-val"><b>mult_mod_carrier_alt</b></a>]  Theorem
      
       p. (mult_mod p).carrier = residue p
   
   [<a name="mult_mod_element-val"><b>mult_mod_element</b></a>]  Theorem
      
       p x. x  (mult_mod p).carrier  x  0  x &lt; p
   
   [<a name="mult_mod_element_alt-val"><b>mult_mod_element_alt</b></a>]  Theorem
      
       p x. x  (mult_mod p).carrier  0 &lt; x  x &lt; p
   
   [<a name="mult_mod_eval-val"><b>mult_mod_eval</b></a>]  Theorem
      
       p. (mult_mod p).carrier = {i | i  0  i &lt; p} 
            (x y. (mult_mod p).op x y = (x * y) MOD p) 
            (mult_mod p).id = 1
   
   [<a name="mult_mod_exp-val"><b>mult_mod_exp</b></a>]  Theorem
      
       p a.
          prime p  a  (mult_mod p).carrier 
          n. (mult_mod p).exp a n = a ** n MOD p
   
   [<a name="mult_mod_finite-val"><b>mult_mod_finite</b></a>]  Theorem
      
       p. FINITE (mult_mod p).carrier
   
   [<a name="mult_mod_finite_abelian_group-val"><b>mult_mod_finite_abelian_group</b></a>]  Theorem
      
       p. prime p  FiniteAbelianGroup (mult_mod p)
   
   [<a name="mult_mod_finite_group-val"><b>mult_mod_finite_group</b></a>]  Theorem
      
       p. prime p  FiniteGroup (mult_mod p)
   
   [<a name="mult_mod_group-val"><b>mult_mod_group</b></a>]  Theorem
      
       p. prime p  Group (mult_mod p)
   
   [<a name="mult_mod_id-val"><b>mult_mod_id</b></a>]  Theorem
      
       p. (mult_mod p).id = 1
   
   [<a name="mult_mod_inv-val"><b>mult_mod_inv</b></a>]  Theorem
      
       p. prime p 
            x. 0 &lt; x  x &lt; p 
                (mult_mod p).inv x =
                (mult_mod p).exp x (order (mult_mod p) x  1)
   
   [<a name="mult_mod_inv_compute-val"><b>mult_mod_inv_compute</b></a>]  Theorem
      
       p x.
          (mult_mod p).inv x =
          if prime p  0 &lt; x  x &lt; p then
            (mult_mod p).exp x (order (mult_mod p) x  1)
          else FAIL ((mult_mod p).inv x) bad_element
   
   [<a name="mult_mod_inverse-val"><b>mult_mod_inverse</b></a>]  Theorem
      
       p. prime p 
            a. 0 &lt; a  a &lt; p  (mult_mod p).inv a = a ** (p  2) MOD p
   
   [<a name="mult_mod_inverse_compute-val"><b>mult_mod_inverse_compute</b></a>]  Theorem
      
       p a.
          (mult_mod p).inv a =
          if prime p  0 &lt; a  a &lt; p then a ** (p  2) MOD p
          else (mult_mod p).inv a
   
   [<a name="mult_mod_property-val"><b>mult_mod_property</b></a>]  Theorem
      
       p. (x. x  (mult_mod p).carrier  x  0) 
            (x. x  (mult_mod p).carrier  0 &lt; x  x &lt; p) 
            (mult_mod p).id = 1 
            (x y. (mult_mod p).op x y = (x * y) MOD p) 
            FINITE (mult_mod p).carrier 
            (0 &lt; p  CARD (mult_mod p).carrier = p  1)
   
   [<a name="multi_orbits_element-val"><b>multi_orbits_element</b></a>]  Theorem
      
       f g X e. e  multi_orbits f g X  e  orbits f g X  SING e
   
   [<a name="multi_orbits_element_finite-val"><b>multi_orbits_element_finite</b></a>]  Theorem
      
       f g X e.
          (g act X) f  FINITE X  e  multi_orbits f g X  FINITE e
   
   [<a name="multi_orbits_element_subset-val"><b>multi_orbits_element_subset</b></a>]  Theorem
      
       f g X e. (g act X) f  e  multi_orbits f g X  e  X
   
   [<a name="multi_orbits_finite-val"><b>multi_orbits_finite</b></a>]  Theorem
      
       f g X. FINITE X  FINITE (multi_orbits f g X)
   
   [<a name="multi_orbits_subset-val"><b>multi_orbits_subset</b></a>]  Theorem
      
       f g X. multi_orbits f g X  orbits f g X
   
   [<a name="non_fixed_points_card-val"><b>non_fixed_points_card</b></a>]  Theorem
      
       f g X.
          FINITE X 
          CARD (X DIFF fixed_points f g X) =
          CARD X  CARD (fixed_points f g X)
   
   [<a name="non_fixed_points_orbit_not_sing-val"><b>non_fixed_points_orbit_not_sing</b></a>]  Theorem
      
       f g X.
          Group g  (g act X) f 
          x. x  X DIFF fixed_points f g X  x  X  SING (orbit f g x)
   
   [<a name="normal_cogen_property-val"><b>normal_cogen_property</b></a>]  Theorem
      
       g h. h &lt;&lt; g  x. x  G  x / cogen g h (x * H)  H
   
   [<a name="normal_coset_op_property-val"><b>normal_coset_op_property</b></a>]  Theorem
      
       g h.
          h &lt;&lt; g 
          x y.
            x  CosetPartition g h  y  CosetPartition g h 
            x  y =
            CHOICE (preimage (left_coset g H) G x) *
            CHOICE (preimage (left_coset g H) G y) * H
   
   [<a name="normal_coset_property-val"><b>normal_coset_property</b></a>]  Theorem
      
       g h.
          h &lt;&lt; g 
          a b.
            a  G  b  G 
            cogen g h (a * H) * cogen g h (b * H) * H = a * b * H
   
   [<a name="normal_coset_property1-val"><b>normal_coset_property1</b></a>]  Theorem
      
       g h.
          h &lt;&lt; g 
          a b. a  G  b  G  cogen g h (a * H) * b * H = a * b * H
   
   [<a name="normal_coset_property2-val"><b>normal_coset_property2</b></a>]  Theorem
      
       g h.
          h &lt;&lt; g 
          a b. a  G  b  G  a * cogen g h (b * H) * H = a * b * H
   
   [<a name="normal_iff_preimage_normal-val"><b>normal_iff_preimage_normal</b></a>]  Theorem
      
       f g1 g2 h2.
          Group g1  Group g2  h2  g2  GroupHomo f g1 g2 
          SURJ f g1.carrier g2.carrier 
          (h2 &lt;&lt; g2  preimage_group f g1 g2 h2.carrier &lt;&lt; g1)
   
   [<a name="normal_preimage_normal-val"><b>normal_preimage_normal</b></a>]  Theorem
      
       f g1 g2 h2.
          Group g1  Group g2  h2  g2  GroupHomo f g1 g2 
          h2 &lt;&lt; g2 
          preimage_group f g1 g2 h2.carrier &lt;&lt; g1
   
   [<a name="normal_subgroup_alt-val"><b>normal_subgroup_alt</b></a>]  Theorem
      
       g h. h &lt;&lt; g  h  g  a. a  G  a * H = H * a
   
   [<a name="normal_subgroup_antisym-val"><b>normal_subgroup_antisym</b></a>]  Theorem
      
       g h. h &lt;&lt; g  g &lt;&lt; h  h = g
   
   [<a name="normal_subgroup_coset_eq-val"><b>normal_subgroup_coset_eq</b></a>]  Theorem
      
       g h. h &lt;&lt; g  x y. x  G  y  G  (x * H = y * H  x / y  H)
   
   [<a name="normal_subgroup_coset_homo-val"><b>normal_subgroup_coset_homo</b></a>]  Theorem
      
       g h. h &lt;&lt; g  GroupHomo (left_coset g H) g (g / h)
   
   [<a name="normal_subgroup_groups-val"><b>normal_subgroup_groups</b></a>]  Theorem
      
       g h. h &lt;&lt; g  h  g  Group h  Group g
   
   [<a name="normal_subgroup_property-val"><b>normal_subgroup_property</b></a>]  Theorem
      
       h g. h &lt;&lt; g  a z. a  G  z  H  a * z / a  H
   
   [<a name="normal_subgroup_refl-val"><b>normal_subgroup_refl</b></a>]  Theorem
      
       g. Group g  g &lt;&lt; g
   
   [<a name="normal_subgroup_subgroup-val"><b>normal_subgroup_subgroup</b></a>]  Theorem
      
       h g. h &lt;&lt; g  h  g
   
   [<a name="normal_surj_normal-val"><b>normal_surj_normal</b></a>]  Theorem
      
       f g1 g2 h2.
          Group g1  Group g2  h2  g2  GroupHomo f g1 g2 
          SURJ f g1.carrier g2.carrier 
          preimage_group f g1 g2 h2.carrier &lt;&lt; g1 
          h2 &lt;&lt; g2
   
   [<a name="orbit_alt-val"><b>orbit_alt</b></a>]  Theorem
      
       f g x. orbit f g x = {f a x | a  G}
   
   [<a name="orbit_card_divides_target_card-val"><b>orbit_card_divides_target_card</b></a>]  Theorem
      
       f g X x.
          FiniteGroup g  (g act X) f  x  X  FINITE X 
          CARD (orbit f g x) divides CARD G
   
   [<a name="orbit_element-val"><b>orbit_element</b></a>]  Theorem
      
       f g x y. y  orbit f g x  (x ~~ y) f g
   
   [<a name="orbit_element_in_target-val"><b>orbit_element_in_target</b></a>]  Theorem
      
       f g X x y. (g act X) f  x  X  y  orbit f g x  y  X
   
   [<a name="orbit_eq_equiv_class-val"><b>orbit_eq_equiv_class</b></a>]  Theorem
      
       f g X x.
          (g act X) f  x  X  orbit f g x = equiv_class (reach f g) X x
   
   [<a name="orbit_eq_orbit-val"><b>orbit_eq_orbit</b></a>]  Theorem
      
       f g X x y.
          Group g  (g act X) f  x  X  y  X 
          (orbit f g x = orbit f g y  (x ~~ y) f g)
   
   [<a name="orbit_finite-val"><b>orbit_finite</b></a>]  Theorem
      
       f g x. FINITE G  FINITE (orbit f g x)
   
   [<a name="orbit_finite_by_target-val"><b>orbit_finite_by_target</b></a>]  Theorem
      
       f g X x. (g act X) f  x  X  FINITE X  FINITE (orbit f g x)
   
   [<a name="orbit_finite_inj_card_eq-val"><b>orbit_finite_inj_card_eq</b></a>]  Theorem
      
       f g X x.
          (g act X) f  x  X  FINITE X  INJ (a. f a x) G (orbit f g x) 
          CARD (orbit f g x) = CARD G
   
   [<a name="orbit_has_action_element-val"><b>orbit_has_action_element</b></a>]  Theorem
      
       f g x a. a  G  f a x  orbit f g x
   
   [<a name="orbit_has_self-val"><b>orbit_has_self</b></a>]  Theorem
      
       f g X x. Group g  (g act X) f  x  X  x  orbit f g x
   
   [<a name="orbit_is_orbits_element-val"><b>orbit_is_orbits_element</b></a>]  Theorem
      
       f g X x. x  X  orbit f g x  orbits f g X
   
   [<a name="orbit_sing_fixed_points-val"><b>orbit_sing_fixed_points</b></a>]  Theorem
      
       f g X.
          (g act X) f 
          x. x  X  orbit f g x = {x}  x  fixed_points f g X
   
   [<a name="orbit_stabilizer_cosets_bij-val"><b>orbit_stabilizer_cosets_bij</b></a>]  Theorem
      
       f g X x.
          Group g  (g act X) f  x  X 
          BIJ (y. act_by f g x y * stabilizer f g x) (orbit f g x)
            {a * stabilizer f g x | a | a  G}
   
   [<a name="orbit_stabilizer_cosets_bij_alt-val"><b>orbit_stabilizer_cosets_bij_alt</b></a>]  Theorem
      
       f g X x.
          Group g  (g act X) f  x  X 
          BIJ (y. act_by f g x y * stabilizer f g x) (orbit f g x)
            (CosetPartition g (StabilizerGroup f g x))
   
   [<a name="orbit_stabilizer_map_good-val"><b>orbit_stabilizer_map_good</b></a>]  Theorem
      
       f g X x.
          Group g  (g act X) f  x  X 
          a b.
            a  G  b  G  f a x = f b x 
            a * stabilizer f g x = b * stabilizer f g x
   
   [<a name="orbit_stabilizer_map_inj-val"><b>orbit_stabilizer_map_inj</b></a>]  Theorem
      
       f g X x.
          Group g  (g act X) f  x  X 
          a b.
            a  G  b  G  a * stabilizer f g x = b * stabilizer f g x 
            f a x = f b x
   
   [<a name="orbit_stabilizer_thm-val"><b>orbit_stabilizer_thm</b></a>]  Theorem
      
       f g X x.
          FiniteGroup g  (g act X) f  x  X  FINITE X 
          CARD G = CARD (orbit f g x) * CARD (stabilizer f g x)
   
   [<a name="orbit_subset_target-val"><b>orbit_subset_target</b></a>]  Theorem
      
       f g X x. (g act X) f  x  X  orbit f g x  X
   
   [<a name="orbits_alt-val"><b>orbits_alt</b></a>]  Theorem
      
       f g X. orbits f g X = {orbit f g x | x  X}
   
   [<a name="orbits_element-val"><b>orbits_element</b></a>]  Theorem
      
       f g X e. e  orbits f g X  x. x  X  e = orbit f g x
   
   [<a name="orbits_element_element-val"><b>orbits_element_element</b></a>]  Theorem
      
       f g X e x. (g act X) f  e  orbits f g X  x  e  x  X
   
   [<a name="orbits_element_finite-val"><b>orbits_element_finite</b></a>]  Theorem
      
       f g X. (g act X) f  FINITE X  EVERY_FINITE (orbits f g X)
   
   [<a name="orbits_element_is_orbit-val"><b>orbits_element_is_orbit</b></a>]  Theorem
      
       f g X e x.
          Group g  (g act X) f  e  orbits f g X  x  e 
          e = orbit f g x
   
   [<a name="orbits_element_nonempty-val"><b>orbits_element_nonempty</b></a>]  Theorem
      
       f g X. Group g  (g act X) f  e. e  orbits f g X  e  
   
   [<a name="orbits_element_subset-val"><b>orbits_element_subset</b></a>]  Theorem
      
       f g X e. (g act X) f  e  orbits f g X  e  X
   
   [<a name="orbits_eq_partition-val"><b>orbits_eq_partition</b></a>]  Theorem
      
       f g X. (g act X) f  orbits f g X = partition (reach f g) X
   
   [<a name="orbits_equal_size_partition_equal_size-val"><b>orbits_equal_size_partition_equal_size</b></a>]  Theorem
      
       f g X n.
          Group g  (g act X) f  FINITE X 
          (x. x  X  CARD (orbit f g x) = n) 
          e. e  orbits f g X  CARD e = n
   
   [<a name="orbits_equal_size_property-val"><b>orbits_equal_size_property</b></a>]  Theorem
      
       f g X n.
          Group g  (g act X) f  FINITE X 
          (x. x  X  CARD (orbit f g x) = n) 
          n divides CARD X
   
   [<a name="orbits_finite-val"><b>orbits_finite</b></a>]  Theorem
      
       f g X. FINITE X  FINITE (orbits f g X)
   
   [<a name="orbits_size_factor_partition_factor-val"><b>orbits_size_factor_partition_factor</b></a>]  Theorem
      
       f g X n.
          Group g  (g act X) f  FINITE X 
          (x. x  X  n divides CARD (orbit f g x)) 
          e. e  orbits f g X  n divides CARD e
   
   [<a name="orbits_size_factor_property-val"><b>orbits_size_factor_property</b></a>]  Theorem
      
       f g X n.
          Group g  (g act X) f  FINITE X 
          (x. x  X  n divides CARD (orbit f g x)) 
          n divides CARD X
   
   [<a name="orders_is_feq_class_order-val"><b>orders_is_feq_class_order</b></a>]  Theorem
      
       g. orders g = preimage ord G
   
   [<a name="preimage_cardinality-val"><b>preimage_cardinality</b></a>]  Theorem
      
       f g1 g2 h.
          FiniteGroup g1  Group g2  h  g2  GroupHomo f g1 g2 
          SURJ f g1.carrier g2.carrier 
          CARD (preimage_group f g1 g2 h.carrier).carrier =
          CARD h.carrier * CARD (kernel f g1 g2)
   
   [<a name="preimage_group_group-val"><b>preimage_group_group</b></a>]  Theorem
      
       f g1 g2 h.
          Group g1  Group g2  GroupHomo f g1 g2  h  g2 
          Group (preimage_group f g1 g2 h.carrier)
   
   [<a name="preimage_group_property-val"><b>preimage_group_property</b></a>]  Theorem
      
       f g1 g2 h x.
          x  PREIMAGE f h  g1.carrier  x  g1.carrier  f x  h
   
   [<a name="preimage_image_subset-val"><b>preimage_image_subset</b></a>]  Theorem
      
       f g1 g2 h.
          Group g1  Group g2  h  g1  GroupHomo f g1 g2 
          SURJ f g1.carrier g2.carrier  kernel f g1 g2  H 
          PREIMAGE f (IMAGE f H)  g1.carrier  H
   
   [<a name="preimage_subgroup_kernel-val"><b>preimage_subgroup_kernel</b></a>]  Theorem
      
       f g1 g2 h2.
          Group g1  Group g2  h2  g2  GroupHomo f g1 g2 
          kernel f g1 g2  PREIMAGE f h2.carrier  g1.carrier
   
   [<a name="preimage_subgroup_subgroup-val"><b>preimage_subgroup_subgroup</b></a>]  Theorem
      
       f g1 g2 h.
          Group g1  Group g2  GroupHomo f g1 g2  h  g2 
          preimage_group f g1 g2 h.carrier  g1
   
   [<a name="prod_image_as_op_image-val"><b>prod_image_as_op_image</b></a>]  Theorem
      
        = OP_IMAGE (x y. x * y) 1
   
   [<a name="quotient_group_assoc-val"><b>quotient_group_assoc</b></a>]  Theorem
      
       g h.
          h &lt;&lt; g 
          x y z.
            x  CosetPartition g h  y  CosetPartition g h 
            z  CosetPartition g h 
            (x  y)  z = x  y  z
   
   [<a name="quotient_group_closure-val"><b>quotient_group_closure</b></a>]  Theorem
      
       g h.
          h  g 
          x y.
            x  CosetPartition g h  y  CosetPartition g h 
            x  y  CosetPartition g h
   
   [<a name="quotient_group_group-val"><b>quotient_group_group</b></a>]  Theorem
      
       g h. h &lt;&lt; g  Group (g / h)
   
   [<a name="quotient_group_id-val"><b>quotient_group_id</b></a>]  Theorem
      
       g h.
          h &lt;&lt; g 
          H  CosetPartition g h  x. x  CosetPartition g h  H  x = x
   
   [<a name="quotient_group_inv-val"><b>quotient_group_inv</b></a>]  Theorem
      
       g h.
          h &lt;&lt; g 
          x. x  CosetPartition g h 
              y. y  CosetPartition g h  y  x = H
   
   [<a name="reach_equiv-val"><b>reach_equiv</b></a>]  Theorem
      
       f g X. Group g  (g act X) f  reach f g equiv_on X
   
   [<a name="reach_refl-val"><b>reach_refl</b></a>]  Theorem
      
       f g X x. Group g  (g act X) f  x  X  (x ~~ x) f g
   
   [<a name="reach_sym-val"><b>reach_sym</b></a>]  Theorem
      
       f g X x y.
          Group g  (g act X) f  x  X  y  X  (x ~~ y) f g 
          (y ~~ x) f g
   
   [<a name="reach_trans-val"><b>reach_trans</b></a>]  Theorem
      
       f g X x y z.
          Group g  (g act X) f  x  X  y  X  z  X  (x ~~ y) f g 
          (y ~~ z) f g 
          (x ~~ z) f g
   
   [<a name="right_coset_alt-val"><b>right_coset_alt</b></a>]  Theorem
      
       g X a. X * a = {z * a | z  X}
   
   [<a name="roots_of_unity_0-val"><b>roots_of_unity_0</b></a>]  Theorem
      
       g. (uroots 0).carrier = G
   
   [<a name="roots_of_unity_element-val"><b>roots_of_unity_element</b></a>]  Theorem
      
       g n x. x  (uroots n).carrier  x  G  x ** n = #e
   
   [<a name="roots_of_unity_subset-val"><b>roots_of_unity_subset</b></a>]  Theorem
      
       g n. (uroots n).carrier  G
   
   [<a name="sing_orbits_card_eqn-val"><b>sing_orbits_card_eqn</b></a>]  Theorem
      
       f g X.
          Group g  (g act X) f  FINITE X 
          CARD (sing_orbits f g X) = CARD (fixed_points f g X)
   
   [<a name="sing_orbits_element-val"><b>sing_orbits_element</b></a>]  Theorem
      
       f g X e. e  sing_orbits f g X  e  orbits f g X  SING e
   
   [<a name="sing_orbits_element_card-val"><b>sing_orbits_element_card</b></a>]  Theorem
      
       f g X e. e  sing_orbits f g X  CARD e = 1
   
   [<a name="sing_orbits_element_choice-val"><b>sing_orbits_element_choice</b></a>]  Theorem
      
       f g X.
          Group g  (g act X) f 
          e. e  sing_orbits f g X  CHOICE e  fixed_points f g X
   
   [<a name="sing_orbits_element_finite-val"><b>sing_orbits_element_finite</b></a>]  Theorem
      
       f g X e. e  sing_orbits f g X  FINITE e
   
   [<a name="sing_orbits_element_subset-val"><b>sing_orbits_element_subset</b></a>]  Theorem
      
       f g X e. (g act X) f  e  sing_orbits f g X  e  X
   
   [<a name="sing_orbits_finite-val"><b>sing_orbits_finite</b></a>]  Theorem
      
       f g X. FINITE X  FINITE (sing_orbits f g X)
   
   [<a name="sing_orbits_subset-val"><b>sing_orbits_subset</b></a>]  Theorem
      
       f g X. sing_orbits f g X  orbits f g X
   
   [<a name="sing_orbits_to_fixed_points_bij-val"><b>sing_orbits_to_fixed_points_bij</b></a>]  Theorem
      
       f g X.
          Group g  (g act X) f 
          BIJ (e. CHOICE e) (sing_orbits f g X) (fixed_points f g X)
   
   [<a name="sing_orbits_to_fixed_points_inj-val"><b>sing_orbits_to_fixed_points_inj</b></a>]  Theorem
      
       f g X.
          Group g  (g act X) f 
          INJ (e. CHOICE e) (sing_orbits f g X) (fixed_points f g X)
   
   [<a name="sing_orbits_to_fixed_points_surj-val"><b>sing_orbits_to_fixed_points_surj</b></a>]  Theorem
      
       f g X.
          Group g  (g act X) f 
          SURJ (e. CHOICE e) (sing_orbits f g X) (fixed_points f g X)
   
   [<a name="stabilizer_as_image-val"><b>stabilizer_as_image</b></a>]  Theorem
      
       f g X x.
          Group g  (g act X) f  x  X 
          stabilizer f g x = IMAGE (a. if f a x = x then a else #e) G
   
   [<a name="stabilizer_conjugate-val"><b>stabilizer_conjugate</b></a>]  Theorem
      
       f g X x a.
          Group g  (g act X) f  x  X  a  G 
          conjugate g a (stabilizer f g x) = stabilizer f g (f a x)
   
   [<a name="stabilizer_element-val"><b>stabilizer_element</b></a>]  Theorem
      
       f g x a. a  stabilizer f g x  a  G  f a x = x
   
   [<a name="stabilizer_group_card_divides-val"><b>stabilizer_group_card_divides</b></a>]  Theorem
      
       f g X x.
          FiniteGroup g  (g act X) f  x  X 
          CARD (stabilizer f g x) divides CARD G
   
   [<a name="stabilizer_group_carrier-val"><b>stabilizer_group_carrier</b></a>]  Theorem
      
       f g x. (StabilizerGroup f g x).carrier = stabilizer f g x
   
   [<a name="stabilizer_group_finite_group-val"><b>stabilizer_group_finite_group</b></a>]  Theorem
      
       f g X x.
          FiniteGroup g  (g act X) f  x  X 
          FiniteGroup (StabilizerGroup f g x)
   
   [<a name="stabilizer_group_group-val"><b>stabilizer_group_group</b></a>]  Theorem
      
       f g X x.
          Group g  (g act X) f  x  X  Group (StabilizerGroup f g x)
   
   [<a name="stabilizer_group_id-val"><b>stabilizer_group_id</b></a>]  Theorem
      
       f g x. (StabilizerGroup f g x).id = #e
   
   [<a name="stabilizer_group_property-val"><b>stabilizer_group_property</b></a>]  Theorem
      
       f g x.
          (StabilizerGroup f g x).carrier = stabilizer f g x 
          (StabilizerGroup f g x).op = $*  (StabilizerGroup f g x).id = #e
   
   [<a name="stabilizer_group_subgroup-val"><b>stabilizer_group_subgroup</b></a>]  Theorem
      
       f g X x. Group g  (g act X) f  x  X  StabilizerGroup f g x  g
   
   [<a name="stabilizer_has_id-val"><b>stabilizer_has_id</b></a>]  Theorem
      
       f g X x. Group g  (g act X) f  x  X  #e  stabilizer f g x
   
   [<a name="stabilizer_nonempty-val"><b>stabilizer_nonempty</b></a>]  Theorem
      
       f g X x. Group g  (g act X) f  x  X  stabilizer f g x  
   
   [<a name="stabilizer_subset-val"><b>stabilizer_subset</b></a>]  Theorem
      
       f g x. stabilizer f g x  G
   
   [<a name="subgroup_I_antisym-val"><b>subgroup_I_antisym</b></a>]  Theorem
      
       g h. subgroup h g  subgroup g h  GroupIso I h g
   
   [<a name="subgroup_alt-val"><b>subgroup_alt</b></a>]  Theorem
      
       g. Group g 
            h. h  g 
                H    H  G  $o = $*  #i = #e 
                x y. x  H  y  H  x * |/ y  H
   
   [<a name="subgroup_antisym-val"><b>subgroup_antisym</b></a>]  Theorem
      
       g h. h  g  g  h  h = g
   
   [<a name="subgroup_big_cross_empty-val"><b>subgroup_big_cross_empty</b></a>]  Theorem
      
       g. sgbcross  = gen #e
   
   [<a name="subgroup_big_cross_insert-val"><b>subgroup_big_cross_insert</b></a>]  Theorem
      
       g. FiniteAbelianGroup g 
            B. B  all_subgroups g 
                h. h  all_subgroups g  h  B 
                    sgbcross (h INSERT B) = h  sgbcross B
   
   [<a name="subgroup_big_cross_thm-val"><b>subgroup_big_cross_thm</b></a>]  Theorem
      
       g. FiniteAbelianGroup g 
            B. B  all_subgroups g 
                h. h  all_subgroups g 
                    sgbcross (h INSERT B) = h  sgbcross (B DELETE h)
   
   [<a name="subgroup_big_intersect_element-val"><b>subgroup_big_intersect_element</b></a>]  Theorem
      
       g x. x  (sgbINTER g).carrier  h. h  g  x  H
   
   [<a name="subgroup_big_intersect_group-val"><b>subgroup_big_intersect_group</b></a>]  Theorem
      
       g. Group g  Group (sgbINTER g)
   
   [<a name="subgroup_big_intersect_has_id-val"><b>subgroup_big_intersect_has_id</b></a>]  Theorem
      
       g. (sgbINTER g).id  (sgbINTER g).carrier
   
   [<a name="subgroup_big_intersect_has_inv-val"><b>subgroup_big_intersect_has_inv</b></a>]  Theorem
      
       g x. x  (sgbINTER g).carrier  |/ x  (sgbINTER g).carrier
   
   [<a name="subgroup_big_intersect_op_element-val"><b>subgroup_big_intersect_op_element</b></a>]  Theorem
      
       g x y.
          x  (sgbINTER g).carrier  y  (sgbINTER g).carrier 
          (sgbINTER g).op x y  (sgbINTER g).carrier
   
   [<a name="subgroup_big_intersect_property-val"><b>subgroup_big_intersect_property</b></a>]  Theorem
      
       g. (sgbINTER g).carrier = BIGINTER (IMAGE (h. H) {h | h  g}) 
            (x y.
               x  (sgbINTER g).carrier  y  (sgbINTER g).carrier 
               (sgbINTER g).op x y = x * y)  (sgbINTER g).id = #e
   
   [<a name="subgroup_big_intersect_subgroup-val"><b>subgroup_big_intersect_subgroup</b></a>]  Theorem
      
       g. Group g  sgbINTER g  g
   
   [<a name="subgroup_big_intersect_subset-val"><b>subgroup_big_intersect_subset</b></a>]  Theorem
      
       g. Group g  (sgbINTER g).carrier  G
   
   [<a name="subgroup_carrier_antisym-val"><b>subgroup_carrier_antisym</b></a>]  Theorem
      
       g h. subgroup h g  G  H  GroupIso I h g
   
   [<a name="subgroup_carrier_nonempty-val"><b>subgroup_carrier_nonempty</b></a>]  Theorem
      
       g h. h  g  H  
   
   [<a name="subgroup_carrier_subset-val"><b>subgroup_carrier_subset</b></a>]  Theorem
      
       g h. h  g  H  G
   
   [<a name="subgroup_conjugate_subgroup_bij-val"><b>subgroup_conjugate_subgroup_bij</b></a>]  Theorem
      
       g h.
          h  g 
          a. a  G 
              BIJ (z. a * z * |/ a) H (conjugate_subgroup h g a).carrier
   
   [<a name="subgroup_coset_card-val"><b>subgroup_coset_card</b></a>]  Theorem
      
       g h. h  g  FINITE H  a. a  G  CARD (a * H) = CARD H
   
   [<a name="subgroup_coset_card_partition_element-val"><b>subgroup_coset_card_partition_element</b></a>]  Theorem
      
       g h.
          h  g  FINITE G 
          e. e  partition (left_coset g H) G  CARD e = CARD H
   
   [<a name="subgroup_coset_eq-val"><b>subgroup_coset_eq</b></a>]  Theorem
      
       g h. h  g  x y. x  G  y  G  (x * H = y * H  |/ y * x  H)
   
   [<a name="subgroup_coset_in_partition-val"><b>subgroup_coset_in_partition</b></a>]  Theorem
      
       g h.
          h  g  x. x  IMAGE (left_coset g H) G  x  CosetPartition g h
   
   [<a name="subgroup_coset_nonempty-val"><b>subgroup_coset_nonempty</b></a>]  Theorem
      
       g h. h  g  x. x  G  x  x * H
   
   [<a name="subgroup_coset_partition_element-val"><b>subgroup_coset_partition_element</b></a>]  Theorem
      
       g h.
          h  g 
          e. e  partition (left_coset g H) G  a. a  G  e = a * H
   
   [<a name="subgroup_coset_subset-val"><b>subgroup_coset_subset</b></a>]  Theorem
      
       g h a x. h  g  a  G  x  a * H  x  G
   
   [<a name="subgroup_coset_sym-val"><b>subgroup_coset_sym</b></a>]  Theorem
      
       g h. h  g  a b. a  G  b  G  b  a * H  a  b * H
   
   [<a name="subgroup_coset_trans-val"><b>subgroup_coset_trans</b></a>]  Theorem
      
       g h.
          h  g 
          a b c. a  G  b  G  c  G  b  a * H  c  b * H  c  a * H
   
   [<a name="subgroup_cross_assoc-val"><b>subgroup_cross_assoc</b></a>]  Theorem
      
       g h1 h2 h3.
          h1  g  h2  g  h3  g  (h1  h2)  h3 = h1  h2  h3
   
   [<a name="subgroup_cross_card-val"><b>subgroup_cross_card</b></a>]  Theorem
      
       g h1 h2.
          h1  g  h2  g  FINITE G 
          (let
             s1 = h1.carrier;
             s2 = h2.carrier
           in
             CARD (h1  h2).carrier = CARD s1 * CARD s2 DIV CARD (s1  s2))
   
   [<a name="subgroup_cross_card_eqn-val"><b>subgroup_cross_card_eqn</b></a>]  Theorem
      
       g h1 h2.
          h1  g  h2  g  FINITE G 
          (let
             s1 = h1.carrier;
             s2 = h2.carrier
           in
             CARD (h1  h2).carrier * CARD (s1  s2) = CARD s1 * CARD s2)
   
   [<a name="subgroup_cross_closure_comm_assoc_fun-val"><b>subgroup_cross_closure_comm_assoc_fun</b></a>]  Theorem
      
       g. AbelianGroup g  closure_comm_assoc_fun $o (all_subgroups g)
   
   [<a name="subgroup_cross_comm-val"><b>subgroup_cross_comm</b></a>]  Theorem
      
       g. AbelianGroup g  h1 h2. h1  g  h2  g  h1  h2 = h2  h1
   
   [<a name="subgroup_cross_finite-val"><b>subgroup_cross_finite</b></a>]  Theorem
      
       g h1 h2.
          h1  g  h2  g  h1  h2 = h2  h1  FiniteGroup h1 
          FiniteGroup h2 
          FiniteGroup (h1  h2)
   
   [<a name="subgroup_cross_group-val"><b>subgroup_cross_group</b></a>]  Theorem
      
       g h1 h2. h1  g  h2  g  h1  h2 = h2  h1  Group (h1  h2)
   
   [<a name="subgroup_cross_property-val"><b>subgroup_cross_property</b></a>]  Theorem
      
       g h1 h2.
          (h1  h2).carrier = h1.carrier  h2.carrier  (h1  h2).op = $* 
          (h1  h2).id = #e
   
   [<a name="subgroup_cross_self-val"><b>subgroup_cross_self</b></a>]  Theorem
      
       g h. h  g  h  h = h
   
   [<a name="subgroup_cross_subgroup-val"><b>subgroup_cross_subgroup</b></a>]  Theorem
      
       g h1 h2. h1  g  h2  g  h1  h2 = h2  h1  h1  h2  g
   
   [<a name="subgroup_element-val"><b>subgroup_element</b></a>]  Theorem
      
       g h. h  g  z. z  H  z  G
   
   [<a name="subgroup_eq-val"><b>subgroup_eq</b></a>]  Theorem
      
       g h1 h2. h1  g  h2  g  (h1 = h2  h1.carrier = h2.carrier)
   
   [<a name="subgroup_eq_carrier-val"><b>subgroup_eq_carrier</b></a>]  Theorem
      
       g h. h  g  H = G  h = g
   
   [<a name="subgroup_eqn-val"><b>subgroup_eqn</b></a>]  Theorem
      
       g h. subgroup h g  H  G  x y. x  H  y  H  x  y = x * y
   
   [<a name="subgroup_exp-val"><b>subgroup_exp</b></a>]  Theorem
      
       g h. h  g  x. x  H  n. h.exp x n = x ** n
   
   [<a name="subgroup_groups-val"><b>subgroup_groups</b></a>]  Theorem
      
       g h. h  g  Group h  Group g
   
   [<a name="subgroup_has_groups-val"><b>subgroup_has_groups</b></a>]  Theorem
      
       g h. h  g  Group g  Group h
   
   [<a name="subgroup_homo_homo-val"><b>subgroup_homo_homo</b></a>]  Theorem
      
       g h k f. subgroup h g  GroupHomo f g k  GroupHomo f h k
   
   [<a name="subgroup_homomorphism-val"><b>subgroup_homomorphism</b></a>]  Theorem
      
       g h. h  g  Group h  Group g  subgroup h g
   
   [<a name="subgroup_id-val"><b>subgroup_id</b></a>]  Theorem
      
       g h. h  g  #i = #e
   
   [<a name="subgroup_incoset_equiv-val"><b>subgroup_incoset_equiv</b></a>]  Theorem
      
       g h. h  g  left_coset g H equiv_on G
   
   [<a name="subgroup_intersect_group-val"><b>subgroup_intersect_group</b></a>]  Theorem
      
       g h k. h  g  k  g  Group (h mINTER k)
   
   [<a name="subgroup_intersect_has_inv-val"><b>subgroup_intersect_has_inv</b></a>]  Theorem
      
       g h k. h  g  k  g  x. x  H  K  |/ x  H  K
   
   [<a name="subgroup_intersect_inv-val"><b>subgroup_intersect_inv</b></a>]  Theorem
      
       g h k. h  g  k  g  x. x  H  K  (h mINTER k).inv x = |/ x
   
   [<a name="subgroup_intersect_property-val"><b>subgroup_intersect_property</b></a>]  Theorem
      
       g h k.
          h  g  k  g 
          (h mINTER k).carrier = H  K 
          (x y. x  H  K  y  H  K  (h mINTER k).op x y = x * y) 
          (h mINTER k).id = #e  x. x  H  K  (h mINTER k).inv x = |/ x
   
   [<a name="subgroup_intersect_subgroup-val"><b>subgroup_intersect_subgroup</b></a>]  Theorem
      
       g h k. h  g  k  g  (h mINTER k)  g
   
   [<a name="subgroup_inv-val"><b>subgroup_inv</b></a>]  Theorem
      
       g h. h  g  x. x  H  h.inv x = |/ x
   
   [<a name="subgroup_inv_closure-val"><b>subgroup_inv_closure</b></a>]  Theorem
      
       g h. h  g  x y. x  H  y  H  x * |/ y  H
   
   [<a name="subgroup_is_group-val"><b>subgroup_is_group</b></a>]  Theorem
      
       g h. h  g  Group h
   
   [<a name="subgroup_is_submonoid-val"><b>subgroup_is_submonoid</b></a>]  Theorem
      
       g h. h  g  h &lt;&lt; g
   
   [<a name="subgroup_is_submonoid0-val"><b>subgroup_is_submonoid0</b></a>]  Theorem
      
       g h. Group g  Group h  subgroup h g  submonoid h g
   
   [<a name="subgroup_op-val"><b>subgroup_op</b></a>]  Theorem
      
       g h. h  g  $o = $*
   
   [<a name="subgroup_order-val"><b>subgroup_order</b></a>]  Theorem
      
       g h. h  g  x. x  H  order h x = ord x
   
   [<a name="subgroup_order_eqn-val"><b>subgroup_order_eqn</b></a>]  Theorem
      
       g h.
          Group g  Group h  subgroup h g  x. x  H  order h x = ord x
   
   [<a name="subgroup_property-val"><b>subgroup_property</b></a>]  Theorem
      
       g h.
          h  g  Group h  Group g  x y. x  H  y  H  x  y = x * y
   
   [<a name="subgroup_property_all-val"><b>subgroup_property_all</b></a>]  Theorem
      
       g h.
          h  g 
          Group g  Group h  H    H  G  $o = $*  #i = #e 
          (x. x  H  h.inv x = |/ x)  x y. x  H  y  H  x * |/ y  H
   
   [<a name="subgroup_refl-val"><b>subgroup_refl</b></a>]  Theorem
      
       g. Group g  g  g
   
   [<a name="subgroup_reflexive-val"><b>subgroup_reflexive</b></a>]  Theorem
      
       g. subgroup g g
   
   [<a name="subgroup_subset-val"><b>subgroup_subset</b></a>]  Theorem
      
       g h. subgroup h g  H  G
   
   [<a name="subgroup_test_by_cross-val"><b>subgroup_test_by_cross</b></a>]  Theorem
      
       g. Group g 
            h. h  g  H    H  G  h  h = h  IMAGE |/ H = H
   
   [<a name="subgroup_thm-val"><b>subgroup_thm</b></a>]  Theorem
      
       g h.
          h  g 
          Group g  $o = $*  #i = #e  H    H  G 
          x y. x  H  y  H  x * |/ y  H
   
   [<a name="subgroup_to_coset_bij-val"><b>subgroup_to_coset_bij</b></a>]  Theorem
      
       g h. h  g  a. a  G  BIJ (x. a * x) H (a * H)
   
   [<a name="subgroup_trans-val"><b>subgroup_trans</b></a>]  Theorem
      
       g h t. h  t  t  g  h  g
   
   [<a name="subgroup_transitive-val"><b>subgroup_transitive</b></a>]  Theorem
      
       g h k. subgroup g h  subgroup h k  subgroup g k
   
   [<a name="subset_big_cross_empty-val"><b>subset_big_cross_empty</b></a>]  Theorem
      
       g. ssbcross  = {#e}
   
   [<a name="subset_big_cross_insert-val"><b>subset_big_cross_insert</b></a>]  Theorem
      
       g. FiniteAbelianGroup g 
            B. B  POW G 
                s. s  G  s  B  ssbcross (s INSERT B) = s  ssbcross B
   
   [<a name="subset_big_cross_thm-val"><b>subset_big_cross_thm</b></a>]  Theorem
      
       g. FiniteAbelianGroup g 
            B. B  POW G 
                s. s  G 
                    ssbcross (s INSERT B) = s  ssbcross (B DELETE s)
   
   [<a name="subset_cross_alt-val"><b>subset_cross_alt</b></a>]  Theorem
      
       g s1 s2. s1  s2 = IMAGE ((x,y). x * y) (s1  s2)
   
   [<a name="subset_cross_assoc-val"><b>subset_cross_assoc</b></a>]  Theorem
      
       g. Group g 
            s1 s2 s3.
              s1  G  s2  G  s3  G  (s1  s2)  s3 = s1  s2  s3
   
   [<a name="subset_cross_closure_comm_assoc_fun-val"><b>subset_cross_closure_comm_assoc_fun</b></a>]  Theorem
      
       g. AbelianGroup g  closure_comm_assoc_fun $o (POW G)
   
   [<a name="subset_cross_comm-val"><b>subset_cross_comm</b></a>]  Theorem
      
       g. AbelianGroup g  s1 s2. s1  G  s2  G  s1  s2 = s2  s1
   
   [<a name="subset_cross_element-val"><b>subset_cross_element</b></a>]  Theorem
      
       g s1 s2 x y. x  s1  y  s2  x * y  s1  s2
   
   [<a name="subset_cross_element_iff-val"><b>subset_cross_element_iff</b></a>]  Theorem
      
       g s1 s2 z. z  s1  s2  x y. x  s1  y  s2  z = x * y
   
   [<a name="subset_cross_element_preimage_card-val"><b>subset_cross_element_preimage_card</b></a>]  Theorem
      
       g h1 h2.
          h1  g  h2  g  FINITE G 
          (let
             s1 = h1.carrier;
             s2 = h2.carrier;
             f (x,y) = x * y
           in
             z. z  s1  s2 
                 CARD (preimage f (s1  s2) z) = CARD (s1  s2))
   
   [<a name="subset_cross_finite-val"><b>subset_cross_finite</b></a>]  Theorem
      
       g s1 s2. FINITE s1  FINITE s2  FINITE (s1  s2)
   
   [<a name="subset_cross_inv-val"><b>subset_cross_inv</b></a>]  Theorem
      
       g. Group g 
            s1 s2.
              s1  G  s2  G 
              IMAGE |/ (s1  s2) = IMAGE |/ s2  IMAGE |/ s1
   
   [<a name="subset_cross_partition_property-val"><b>subset_cross_partition_property</b></a>]  Theorem
      
       g h1 h2.
          h1  g  h2  g  FINITE G 
          (let
             s1 = h1.carrier;
             s2 = h2.carrier;
             f (x,y) = x * y
           in
             t. t  partition (feq f) (s1  s2)  CARD t = CARD (s1  s2))
   
   [<a name="subset_cross_preimage_inj-val"><b>subset_cross_preimage_inj</b></a>]  Theorem
      
       g s1 s2.
          INJ (preimage ((x,y). x * y) (s1  s2)) (s1  s2)
            (: #  -&gt; bool)
   
   [<a name="subset_cross_self-val"><b>subset_cross_self</b></a>]  Theorem
      
       g h. h  g  H  H = H
   
   [<a name="subset_cross_subset-val"><b>subset_cross_subset</b></a>]  Theorem
      
       g. Group g  s1 s2. s1  G  s2  G  s1  s2  G
   
   [<a name="subset_cross_to_preimage_cross_bij-val"><b>subset_cross_to_preimage_cross_bij</b></a>]  Theorem
      
       g h1 h2.
          h1  g  h2  g 
          (let
             s1 = h1.carrier;
             s2 = h2.carrier;
             f (x,y) = x * y
           in
             z. z  s1  s2 
                 BIJ (d. (left z * d,|/ d * right z)) (s1  s2)
                   (preimage f (s1  s2) z))
   
   [<a name="subset_group_exp-val"><b>subset_group_exp</b></a>]  Theorem
      
       g s x. x  s  n. (subset_group g s).exp x n = x ** n
   
   [<a name="subset_group_order-val"><b>subset_group_order</b></a>]  Theorem
      
       g s x. x  s  order (subset_group g s) x = ord x
   
   [<a name="subset_group_property-val"><b>subset_group_property</b></a>]  Theorem
      
       g s.
          (subset_group g s).carrier = s  (subset_group g s).op = $* 
          (subset_group g s).id = #e
   
   [<a name="subset_group_subgroup-val"><b>subset_group_subgroup</b></a>]  Theorem
      
       g s.
          Group g  s    s  G  (x y. x  s  y  s  x * |/ y  s) 
          subset_group g s  g
   
   [<a name="subset_group_submonoid-val"><b>subset_group_submonoid</b></a>]  Theorem
      
       g s.
          Monoid g  #e  s  s  G  (x y. x  s  y  s  x * y  s) 
          subset_group g s &lt;&lt; g
   
   [<a name="subset_preimage_image-val"><b>subset_preimage_image</b></a>]  Theorem
      
       f g1 g2 h.
          Group g1  Group g2  h  g1  GroupHomo f g1 g2 
          H  PREIMAGE f (IMAGE f H)  g1.carrier
   
   [<a name="sum_image_as_op_image-val"><b>sum_image_as_op_image</b></a>]  Theorem
      
        = OP_IMAGE (x y. x + y) 0
   
   [<a name="symdiff_set_abelian_group-val"><b>symdiff_set_abelian_group</b></a>]  Theorem
      
       AbelianGroup symdiff_set
   
   [<a name="symdiff_set_group-val"><b>symdiff_set_group</b></a>]  Theorem
      
       Group symdiff_set
   
   [<a name="target_card_and_fixed_points_congruence-val"><b>target_card_and_fixed_points_congruence</b></a>]  Theorem
      
       f g X n.
          Group g  (g act X) f  FINITE X  0 &lt; n 
          (e. e  multi_orbits f g X  CARD e = n) 
          CARD X MOD n = CARD (fixed_points f g X) MOD n
   
   [<a name="target_card_by_fixed_points-val"><b>target_card_by_fixed_points</b></a>]  Theorem
      
       f g X.
          Group g  (g act X) f  FINITE X 
          CARD X = CARD (fixed_points f g X) +  CARD (multi_orbits f g X)
   
   [<a name="target_card_by_orbit_types-val"><b>target_card_by_orbit_types</b></a>]  Theorem
      
       f g X.
          Group g  (g act X) f  FINITE X 
          CARD X = CARD (sing_orbits f g X) +  CARD (multi_orbits f g X)
   
   [<a name="target_card_by_partition-val"><b>target_card_by_partition</b></a>]  Theorem
      
       f g X.
          Group g  (g act X) f  FINITE X  CARD X =  CARD (orbits f g X)
   
   [<a name="target_orbits_disjoint-val"><b>target_orbits_disjoint</b></a>]  Theorem
      
       f g X. DISJOINT (sing_orbits f g X) (multi_orbits f g X)
   
   [<a name="target_orbits_union-val"><b>target_orbits_union</b></a>]  Theorem
      
       f g X. orbits f g X = sing_orbits f g X  multi_orbits f g X
   
   [<a name="trivial_group-val"><b>trivial_group</b></a>]  Theorem
      
       e. FiniteAbelianGroup (trivial_group e)
   
   [<a name="trivial_group_carrier-val"><b>trivial_group_carrier</b></a>]  Theorem
      
       e. (trivial_group e).carrier = {e}
   
   [<a name="trivial_group_id-val"><b>trivial_group_id</b></a>]  Theorem
      
       e. (trivial_group e).id = e
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/algebra/construction/.hol/objs/groupScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-2</a></em></p></body></html>
