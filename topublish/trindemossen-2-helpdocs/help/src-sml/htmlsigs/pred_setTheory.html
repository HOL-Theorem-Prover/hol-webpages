<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure pred_setTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure pred_setTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/pred_set/src/pred_setScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature pred_setTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#BIGINTER-val">BIGINTER</a> : thm
<a name="line7"></a>    val <a href="#BIGUNION-val">BIGUNION</a> : thm
<a name="line8"></a>    val <a href="#BIJ_DEF-val">BIJ_DEF</a> : thm
<a name="line9"></a>    val <a href="#CARD_DEF-val">CARD_DEF</a> : thm
<a name="line10"></a>    val <a href="#CHOICE_DEF-val">CHOICE_DEF</a> : thm
<a name="line11"></a>    val <a href="#COMPL_DEF-val">COMPL_DEF</a> : thm
<a name="line12"></a>    val <a href="#CROSS_DEF-val">CROSS_DEF</a> : thm
<a name="line13"></a>    val <a href="#DELETE_DEF-val">DELETE_DEF</a> : thm
<a name="line14"></a>    val <a href="#DFUNSET-val">DFUNSET</a> : thm
<a name="line15"></a>    val <a href="#DIFF_DEF-val">DIFF_DEF</a> : thm
<a name="line16"></a>    val <a href="#DISJOINT_DEF-val">DISJOINT_DEF</a> : thm
<a name="line17"></a>    val <a href="#EMPTY_DEF-val">EMPTY_DEF</a> : thm
<a name="line18"></a>    val <a href="#FINITE_DEF-val">FINITE_DEF</a> : thm
<a name="line19"></a>    val <a href="#FUNSET-val">FUNSET</a> : thm
<a name="line20"></a>    val <a href="#GSPECIFICATION-val">GSPECIFICATION</a> : thm
<a name="line21"></a>    val <a href="#HAS_SIZE-val">HAS_SIZE</a> : thm
<a name="line22"></a>    val <a href="#IMAGE_DEF-val">IMAGE_DEF</a> : thm
<a name="line23"></a>    val <a href="#INJ_DEF-val">INJ_DEF</a> : thm
<a name="line24"></a>    val <a href="#INSERT_DEF-val">INSERT_DEF</a> : thm
<a name="line25"></a>    val <a href="#INTER_DEF-val">INTER_DEF</a> : thm
<a name="line26"></a>    val <a href="#LINV_LO-val">LINV_LO</a> : thm
<a name="line27"></a>    val <a href="#LINV_OPT_def-val">LINV_OPT_def</a> : thm
<a name="line28"></a>    val <a href="#MAX_SET_DEF-val">MAX_SET_DEF</a> : thm
<a name="line29"></a>    val <a href="#MIN_SET_DEF-val">MIN_SET_DEF</a> : thm
<a name="line30"></a>    val <a href="#POW_DEF-val">POW_DEF</a> : thm
<a name="line31"></a>    val <a href="#PREIMAGE_def-val">PREIMAGE_def</a> : thm
<a name="line32"></a>    val <a href="#PROD_IMAGE_DEF-val">PROD_IMAGE_DEF</a> : thm
<a name="line33"></a>    val <a href="#PROD_SET_DEF-val">PROD_SET_DEF</a> : thm
<a name="line34"></a>    val <a href="#PSUBSET_DEF-val">PSUBSET_DEF</a> : thm
<a name="line35"></a>    val <a href="#REL_RESTRICT_DEF-val">REL_RESTRICT_DEF</a> : thm
<a name="line36"></a>    val <a href="#REST_DEF-val">REST_DEF</a> : thm
<a name="line37"></a>    val <a href="#RINV_LO-val">RINV_LO</a> : thm
<a name="line38"></a>    val <a href="#SING_DEF-val">SING_DEF</a> : thm
<a name="line39"></a>    val <a href="#SUBSET_DEF-val">SUBSET_DEF</a> : thm
<a name="line40"></a>    val <a href="#SUM_IMAGE_DEF-val">SUM_IMAGE_DEF</a> : thm
<a name="line41"></a>    val <a href="#SUM_SET_DEF-val">SUM_SET_DEF</a> : thm
<a name="line42"></a>    val <a href="#SURJ_DEF-val">SURJ_DEF</a> : thm
<a name="line43"></a>    val <a href="#UNION_DEF-val">UNION_DEF</a> : thm
<a name="line44"></a>    val <a href="#UNIV_DEF-val">UNIV_DEF</a> : thm
<a name="line45"></a>    val <a href="#chooser_def-val">chooser_def</a> : thm
<a name="line46"></a>    val <a href="#closure_comm_assoc_fun_def-val">closure_comm_assoc_fun_def</a> : thm
<a name="line47"></a>    val <a href="#count_def-val">count_def</a> : thm
<a name="line48"></a>    val <a href="#countable_def-val">countable_def</a> : thm
<a name="line49"></a>    val <a href="#disjUNION_def-val">disjUNION_def</a> : thm
<a name="line50"></a>    val <a href="#disjoint-val">disjoint</a> : thm
<a name="line51"></a>    val <a href="#enumerate_def-val">enumerate_def</a> : thm
<a name="line52"></a>    val <a href="#equiv_on_def-val">equiv_on_def</a> : thm
<a name="line53"></a>    val <a href="#is_measure_maximal_def-val">is_measure_maximal_def</a> : thm
<a name="line54"></a>    val <a href="#num_to_pair_def-val">num_to_pair_def</a> : thm
<a name="line55"></a>    val <a href="#pair_to_num_def-val">pair_to_num_def</a> : thm
<a name="line56"></a>    val <a href="#pairwise_def-val">pairwise_def</a> : thm
<a name="line57"></a>    val <a href="#part_def-val">part_def</a> : thm
<a name="line58"></a>    val <a href="#partition_def-val">partition_def</a> : thm
<a name="line59"></a>    val <a href="#partitions_def-val">partitions_def</a> : thm
<a name="line60"></a>    val <a href="#refines_def-val">refines_def</a> : thm
<a name="line61"></a>    val <a href="#schroeder_close_def-val">schroeder_close_def</a> : thm
<a name="line62"></a>  
<a name="line63"></a>  (*  Theorems  *)
<a name="line64"></a>    val <a href="#ABSORPTION-val">ABSORPTION</a> : thm
<a name="line65"></a>    val <a href="#ABSORPTION_RWT-val">ABSORPTION_RWT</a> : thm
<a name="line66"></a>    val <a href="#ABS_DIFF_SUM_IMAGE-val">ABS_DIFF_SUM_IMAGE</a> : thm
<a name="line67"></a>    val <a href="#BIGINTER_2-val">BIGINTER_2</a> : thm
<a name="line68"></a>    val <a href="#BIGINTER_EMPTY-val">BIGINTER_EMPTY</a> : thm
<a name="line69"></a>    val <a href="#BIGINTER_GSPEC-val">BIGINTER_GSPEC</a> : thm
<a name="line70"></a>    val <a href="#BIGINTER_IMAGE-val">BIGINTER_IMAGE</a> : thm
<a name="line71"></a>    val <a href="#BIGINTER_INSERT-val">BIGINTER_INSERT</a> : thm
<a name="line72"></a>    val <a href="#BIGINTER_INTER-val">BIGINTER_INTER</a> : thm
<a name="line73"></a>    val <a href="#BIGINTER_SING-val">BIGINTER_SING</a> : thm
<a name="line74"></a>    val <a href="#BIGINTER_SUBSET-val">BIGINTER_SUBSET</a> : thm
<a name="line75"></a>    val <a href="#BIGINTER_UNION-val">BIGINTER_UNION</a> : thm
<a name="line76"></a>    val <a href="#BIGINTER_applied-val">BIGINTER_applied</a> : thm
<a name="line77"></a>    val <a href="#BIGUNION_CROSS-val">BIGUNION_CROSS</a> : thm
<a name="line78"></a>    val <a href="#BIGUNION_EMPTY-val">BIGUNION_EMPTY</a> : thm
<a name="line79"></a>    val <a href="#BIGUNION_EQ_EMPTY-val">BIGUNION_EQ_EMPTY</a> : thm
<a name="line80"></a>    val <a href="#BIGUNION_GSPEC-val">BIGUNION_GSPEC</a> : thm
<a name="line81"></a>    val <a href="#BIGUNION_IMAGE-val">BIGUNION_IMAGE</a> : thm
<a name="line82"></a>    val <a href="#BIGUNION_IMAGE_SUBSET-val">BIGUNION_IMAGE_SUBSET</a> : thm
<a name="line83"></a>    val <a href="#BIGUNION_IMAGE_UNIV-val">BIGUNION_IMAGE_UNIV</a> : thm
<a name="line84"></a>    val <a href="#BIGUNION_INSERT-val">BIGUNION_INSERT</a> : thm
<a name="line85"></a>    val <a href="#BIGUNION_PAIR-val">BIGUNION_PAIR</a> : thm
<a name="line86"></a>    val <a href="#BIGUNION_SING-val">BIGUNION_SING</a> : thm
<a name="line87"></a>    val <a href="#BIGUNION_SUBSET-val">BIGUNION_SUBSET</a> : thm
<a name="line88"></a>    val <a href="#BIGUNION_UNION-val">BIGUNION_UNION</a> : thm
<a name="line89"></a>    val <a href="#BIGUNION_applied-val">BIGUNION_applied</a> : thm
<a name="line90"></a>    val <a href="#BIGUNION_partition-val">BIGUNION_partition</a> : thm
<a name="line91"></a>    val <a href="#BIJ_ALT-val">BIJ_ALT</a> : thm
<a name="line92"></a>    val <a href="#BIJ_COMPOSE-val">BIJ_COMPOSE</a> : thm
<a name="line93"></a>    val <a href="#BIJ_CONG-val">BIJ_CONG</a> : thm
<a name="line94"></a>    val <a href="#BIJ_DELETE-val">BIJ_DELETE</a> : thm
<a name="line95"></a>    val <a href="#BIJ_ELEMENT-val">BIJ_ELEMENT</a> : thm
<a name="line96"></a>    val <a href="#BIJ_EMPTY-val">BIJ_EMPTY</a> : thm
<a name="line97"></a>    val <a href="#BIJ_FINITE-val">BIJ_FINITE</a> : thm
<a name="line98"></a>    val <a href="#BIJ_FINITE_IFF-val">BIJ_FINITE_IFF</a> : thm
<a name="line99"></a>    val <a href="#BIJ_FINITE_SUBSET-val">BIJ_FINITE_SUBSET</a> : thm
<a name="line100"></a>    val <a href="#BIJ_ID-val">BIJ_ID</a> : thm
<a name="line101"></a>    val <a href="#BIJ_IFF_INV-val">BIJ_IFF_INV</a> : thm
<a name="line102"></a>    val <a href="#BIJ_IMAGE-val">BIJ_IMAGE</a> : thm
<a name="line103"></a>    val <a href="#BIJ_IMAGE_partitions-val">BIJ_IMAGE_partitions</a> : thm
<a name="line104"></a>    val <a href="#BIJ_IMP_11-val">BIJ_IMP_11</a> : thm
<a name="line105"></a>    val <a href="#BIJ_INJ_SURJ-val">BIJ_INJ_SURJ</a> : thm
<a name="line106"></a>    val <a href="#BIJ_INSERT-val">BIJ_INSERT</a> : thm
<a name="line107"></a>    val <a href="#BIJ_INSERT_IMP-val">BIJ_INSERT_IMP</a> : thm
<a name="line108"></a>    val <a href="#BIJ_INV-val">BIJ_INV</a> : thm
<a name="line109"></a>    val <a href="#BIJ_IS_INJ-val">BIJ_IS_INJ</a> : thm
<a name="line110"></a>    val <a href="#BIJ_IS_SURJ-val">BIJ_IS_SURJ</a> : thm
<a name="line111"></a>    val <a href="#BIJ_I_SAME-val">BIJ_I_SAME</a> : thm
<a name="line112"></a>    val <a href="#BIJ_LINV_BIJ-val">BIJ_LINV_BIJ</a> : thm
<a name="line113"></a>    val <a href="#BIJ_LINV_INV-val">BIJ_LINV_INV</a> : thm
<a name="line114"></a>    val <a href="#BIJ_NUM_COUNTABLE-val">BIJ_NUM_COUNTABLE</a> : thm
<a name="line115"></a>    val <a href="#BIJ_NUM_TO_PAIR-val">BIJ_NUM_TO_PAIR</a> : thm
<a name="line116"></a>    val <a href="#BIJ_PAIR_TO_NUM-val">BIJ_PAIR_TO_NUM</a> : thm
<a name="line117"></a>    val <a href="#BIJ_SWAP-val">BIJ_SWAP</a> : thm
<a name="line118"></a>    val <a href="#BIJ_SYM-val">BIJ_SYM</a> : thm
<a name="line119"></a>    val <a href="#BIJ_SYM_IMP-val">BIJ_SYM_IMP</a> : thm
<a name="line120"></a>    val <a href="#BIJ_THM-val">BIJ_THM</a> : thm
<a name="line121"></a>    val <a href="#BIJ_TRANS-val">BIJ_TRANS</a> : thm
<a name="line122"></a>    val <a href="#BIJ_support-val">BIJ_support</a> : thm
<a name="line123"></a>    val <a href="#CARD_AS_SIGMA-val">CARD_AS_SIGMA</a> : thm
<a name="line124"></a>    val <a href="#CARD_BIGUNION_SAME_SIZED_SETS-val">CARD_BIGUNION_SAME_SIZED_SETS</a> : thm
<a name="line125"></a>    val <a href="#CARD_CLAUSES-val">CARD_CLAUSES</a> : thm
<a name="line126"></a>    val <a href="#CARD_COUNT-val">CARD_COUNT</a> : thm
<a name="line127"></a>    val <a href="#CARD_CROSS-val">CARD_CROSS</a> : thm
<a name="line128"></a>    val <a href="#CARD_DELETE-val">CARD_DELETE</a> : thm
<a name="line129"></a>    val <a href="#CARD_DIFF-val">CARD_DIFF</a> : thm
<a name="line130"></a>    val <a href="#CARD_DIFF_EQN-val">CARD_DIFF_EQN</a> : thm
<a name="line131"></a>    val <a href="#CARD_EMPTY-val">CARD_EMPTY</a> : thm
<a name="line132"></a>    val <a href="#CARD_EQ_0-val">CARD_EQ_0</a> : thm
<a name="line133"></a>    val <a href="#CARD_EQ_SIGMA-val">CARD_EQ_SIGMA</a> : thm
<a name="line134"></a>    val <a href="#CARD_IMAGE-val">CARD_IMAGE</a> : thm
<a name="line135"></a>    val <a href="#CARD_IMAGE_INJ-val">CARD_IMAGE_INJ</a> : thm
<a name="line136"></a>    val <a href="#CARD_IMAGE_LE-val">CARD_IMAGE_LE</a> : thm
<a name="line137"></a>    val <a href="#CARD_IMAGE_SUC-val">CARD_IMAGE_SUC</a> : thm
<a name="line138"></a>    val <a href="#CARD_INJ_IMAGE-val">CARD_INJ_IMAGE</a> : thm
<a name="line139"></a>    val <a href="#CARD_INSERT-val">CARD_INSERT</a> : thm
<a name="line140"></a>    val <a href="#CARD_INTER_LESS_EQ-val">CARD_INTER_LESS_EQ</a> : thm
<a name="line141"></a>    val <a href="#CARD_LE_MAX_SET-val">CARD_LE_MAX_SET</a> : thm
<a name="line142"></a>    val <a href="#CARD_POW-val">CARD_POW</a> : thm
<a name="line143"></a>    val <a href="#CARD_PRODUCT-val">CARD_PRODUCT</a> : thm
<a name="line144"></a>    val <a href="#CARD_PSUBSET-val">CARD_PSUBSET</a> : thm
<a name="line145"></a>    val <a href="#CARD_REST-val">CARD_REST</a> : thm
<a name="line146"></a>    val <a href="#CARD_SING-val">CARD_SING</a> : thm
<a name="line147"></a>    val <a href="#CARD_SING_CROSS-val">CARD_SING_CROSS</a> : thm
<a name="line148"></a>    val <a href="#CARD_SUBSET-val">CARD_SUBSET</a> : thm
<a name="line149"></a>    val <a href="#CARD_UNION-val">CARD_UNION</a> : thm
<a name="line150"></a>    val <a href="#CARD_UNION_DISJOINT-val">CARD_UNION_DISJOINT</a> : thm
<a name="line151"></a>    val <a href="#CARD_UNION_EQN-val">CARD_UNION_EQN</a> : thm
<a name="line152"></a>    val <a href="#CARD_UNION_LE-val">CARD_UNION_LE</a> : thm
<a name="line153"></a>    val <a href="#CARD_disjUNION-val">CARD_disjUNION</a> : thm
<a name="line154"></a>    val <a href="#CHOICE_INSERT_REST-val">CHOICE_INSERT_REST</a> : thm
<a name="line155"></a>    val <a href="#CHOICE_INTRO-val">CHOICE_INTRO</a> : thm
<a name="line156"></a>    val <a href="#CHOICE_NOT_IN_REST-val">CHOICE_NOT_IN_REST</a> : thm
<a name="line157"></a>    val <a href="#CHOICE_SING-val">CHOICE_SING</a> : thm
<a name="line158"></a>    val <a href="#COMMUTING_ITSET_INSERT-val">COMMUTING_ITSET_INSERT</a> : thm
<a name="line159"></a>    val <a href="#COMMUTING_ITSET_RECURSES-val">COMMUTING_ITSET_RECURSES</a> : thm
<a name="line160"></a>    val <a href="#COMPL_CLAUSES-val">COMPL_CLAUSES</a> : thm
<a name="line161"></a>    val <a href="#COMPL_COMPL-val">COMPL_COMPL</a> : thm
<a name="line162"></a>    val <a href="#COMPL_EMPTY-val">COMPL_EMPTY</a> : thm
<a name="line163"></a>    val <a href="#COMPL_INTER-val">COMPL_INTER</a> : thm
<a name="line164"></a>    val <a href="#COMPL_SPLITS-val">COMPL_SPLITS</a> : thm
<a name="line165"></a>    val <a href="#COMPL_UNION-val">COMPL_UNION</a> : thm
<a name="line166"></a>    val <a href="#COMPL_applied-val">COMPL_applied</a> : thm
<a name="line167"></a>    val <a href="#COMPONENT-val">COMPONENT</a> : thm
<a name="line168"></a>    val <a href="#COUNTABLE_ALT-val">COUNTABLE_ALT</a> : thm
<a name="line169"></a>    val <a href="#COUNTABLE_ALT_BIJ-val">COUNTABLE_ALT_BIJ</a> : thm
<a name="line170"></a>    val <a href="#COUNTABLE_COUNT-val">COUNTABLE_COUNT</a> : thm
<a name="line171"></a>    val <a href="#COUNTABLE_ENUM-val">COUNTABLE_ENUM</a> : thm
<a name="line172"></a>    val <a href="#COUNTABLE_IMAGE_NUM-val">COUNTABLE_IMAGE_NUM</a> : thm
<a name="line173"></a>    val <a href="#COUNTABLE_NUM-val">COUNTABLE_NUM</a> : thm
<a name="line174"></a>    val <a href="#COUNTABLE_SUBSET-val">COUNTABLE_SUBSET</a> : thm
<a name="line175"></a>    val <a href="#COUNT_11-val">COUNT_11</a> : thm
<a name="line176"></a>    val <a href="#COUNT_DELETE-val">COUNT_DELETE</a> : thm
<a name="line177"></a>    val <a href="#COUNT_EQ_EMPTY-val">COUNT_EQ_EMPTY</a> : thm
<a name="line178"></a>    val <a href="#COUNT_MONO-val">COUNT_MONO</a> : thm
<a name="line179"></a>    val <a href="#COUNT_NOT_EMPTY-val">COUNT_NOT_EMPTY</a> : thm
<a name="line180"></a>    val <a href="#COUNT_ONE-val">COUNT_ONE</a> : thm
<a name="line181"></a>    val <a href="#COUNT_SUC-val">COUNT_SUC</a> : thm
<a name="line182"></a>    val <a href="#COUNT_ZERO-val">COUNT_ZERO</a> : thm
<a name="line183"></a>    val <a href="#COUNT_applied-val">COUNT_applied</a> : thm
<a name="line184"></a>    val <a href="#CROSS_BIGUNION-val">CROSS_BIGUNION</a> : thm
<a name="line185"></a>    val <a href="#CROSS_EMPTY-val">CROSS_EMPTY</a> : thm
<a name="line186"></a>    val <a href="#CROSS_EMPTY_EQN-val">CROSS_EMPTY_EQN</a> : thm
<a name="line187"></a>    val <a href="#CROSS_EQNS-val">CROSS_EQNS</a> : thm
<a name="line188"></a>    val <a href="#CROSS_INSERT_LEFT-val">CROSS_INSERT_LEFT</a> : thm
<a name="line189"></a>    val <a href="#CROSS_INSERT_RIGHT-val">CROSS_INSERT_RIGHT</a> : thm
<a name="line190"></a>    val <a href="#CROSS_SINGS-val">CROSS_SINGS</a> : thm
<a name="line191"></a>    val <a href="#CROSS_SUBSET-val">CROSS_SUBSET</a> : thm
<a name="line192"></a>    val <a href="#CROSS_UNIV-val">CROSS_UNIV</a> : thm
<a name="line193"></a>    val <a href="#CROSS_applied-val">CROSS_applied</a> : thm
<a name="line194"></a>    val <a href="#DECOMPOSITION-val">DECOMPOSITION</a> : thm
<a name="line195"></a>    val <a href="#DELETE_COMM-val">DELETE_COMM</a> : thm
<a name="line196"></a>    val <a href="#DELETE_DELETE-val">DELETE_DELETE</a> : thm
<a name="line197"></a>    val <a href="#DELETE_EQ_SING-val">DELETE_EQ_SING</a> : thm
<a name="line198"></a>    val <a href="#DELETE_INSERT-val">DELETE_INSERT</a> : thm
<a name="line199"></a>    val <a href="#DELETE_INTER-val">DELETE_INTER</a> : thm
<a name="line200"></a>    val <a href="#DELETE_NON_ELEMENT-val">DELETE_NON_ELEMENT</a> : thm
<a name="line201"></a>    val <a href="#DELETE_NON_ELEMENT_RWT-val">DELETE_NON_ELEMENT_RWT</a> : thm
<a name="line202"></a>    val <a href="#DELETE_SUBSET-val">DELETE_SUBSET</a> : thm
<a name="line203"></a>    val <a href="#DELETE_SUBSET_INSERT-val">DELETE_SUBSET_INSERT</a> : thm
<a name="line204"></a>    val <a href="#DELETE_applied-val">DELETE_applied</a> : thm
<a name="line205"></a>    val <a href="#DFUNSET_applied-val">DFUNSET_applied</a> : thm
<a name="line206"></a>    val <a href="#DIFF_BIGINTER-val">DIFF_BIGINTER</a> : thm
<a name="line207"></a>    val <a href="#DIFF_BIGINTER1-val">DIFF_BIGINTER1</a> : thm
<a name="line208"></a>    val <a href="#DIFF_COMM-val">DIFF_COMM</a> : thm
<a name="line209"></a>    val <a href="#DIFF_DIFF-val">DIFF_DIFF</a> : thm
<a name="line210"></a>    val <a href="#DIFF_DIFF_SUBSET-val">DIFF_DIFF_SUBSET</a> : thm
<a name="line211"></a>    val <a href="#DIFF_EMPTY-val">DIFF_EMPTY</a> : thm
<a name="line212"></a>    val <a href="#DIFF_EQ_EMPTY-val">DIFF_EQ_EMPTY</a> : thm
<a name="line213"></a>    val <a href="#DIFF_INSERT-val">DIFF_INSERT</a> : thm
<a name="line214"></a>    val <a href="#DIFF_INTER-val">DIFF_INTER</a> : thm
<a name="line215"></a>    val <a href="#DIFF_INTER2-val">DIFF_INTER2</a> : thm
<a name="line216"></a>    val <a href="#DIFF_INTER_COMPL-val">DIFF_INTER_COMPL</a> : thm
<a name="line217"></a>    val <a href="#DIFF_INTER_SUBSET-val">DIFF_INTER_SUBSET</a> : thm
<a name="line218"></a>    val <a href="#DIFF_SAME_UNION-val">DIFF_SAME_UNION</a> : thm
<a name="line219"></a>    val <a href="#DIFF_SUBSET-val">DIFF_SUBSET</a> : thm
<a name="line220"></a>    val <a href="#DIFF_UNION-val">DIFF_UNION</a> : thm
<a name="line221"></a>    val <a href="#DIFF_UNIV-val">DIFF_UNIV</a> : thm
<a name="line222"></a>    val <a href="#DIFF_applied-val">DIFF_applied</a> : thm
<a name="line223"></a>    val <a href="#DISJOINT_ALT-val">DISJOINT_ALT</a> : thm
<a name="line224"></a>    val <a href="#DISJOINT_ALT'-val">DISJOINT_ALT'</a> : thm
<a name="line225"></a>    val <a href="#DISJOINT_BIGINTER-val">DISJOINT_BIGINTER</a> : thm
<a name="line226"></a>    val <a href="#DISJOINT_BIGUNION-val">DISJOINT_BIGUNION</a> : thm
<a name="line227"></a>    val <a href="#DISJOINT_COUNT-val">DISJOINT_COUNT</a> : thm
<a name="line228"></a>    val <a href="#DISJOINT_DELETE_SYM-val">DISJOINT_DELETE_SYM</a> : thm
<a name="line229"></a>    val <a href="#DISJOINT_DIFF-val">DISJOINT_DIFF</a> : thm
<a name="line230"></a>    val <a href="#DISJOINT_DIFFS-val">DISJOINT_DIFFS</a> : thm
<a name="line231"></a>    val <a href="#DISJOINT_EMPTY-val">DISJOINT_EMPTY</a> : thm
<a name="line232"></a>    val <a href="#DISJOINT_EMPTY_REFL-val">DISJOINT_EMPTY_REFL</a> : thm
<a name="line233"></a>    val <a href="#DISJOINT_EMPTY_REFL_RWT-val">DISJOINT_EMPTY_REFL_RWT</a> : thm
<a name="line234"></a>    val <a href="#DISJOINT_IMAGE-val">DISJOINT_IMAGE</a> : thm
<a name="line235"></a>    val <a href="#DISJOINT_INSERT-val">DISJOINT_INSERT</a> : thm
<a name="line236"></a>    val <a href="#DISJOINT_INSERT'-val">DISJOINT_INSERT'</a> : thm
<a name="line237"></a>    val <a href="#DISJOINT_SING_EMPTY-val">DISJOINT_SING_EMPTY</a> : thm
<a name="line238"></a>    val <a href="#DISJOINT_SUBSET-val">DISJOINT_SUBSET</a> : thm
<a name="line239"></a>    val <a href="#DISJOINT_SUBSET'-val">DISJOINT_SUBSET'</a> : thm
<a name="line240"></a>    val <a href="#DISJOINT_SYM-val">DISJOINT_SYM</a> : thm
<a name="line241"></a>    val <a href="#DISJOINT_UNION-val">DISJOINT_UNION</a> : thm
<a name="line242"></a>    val <a href="#DISJOINT_UNION'-val">DISJOINT_UNION'</a> : thm
<a name="line243"></a>    val <a href="#DISJOINT_UNION_BOTH-val">DISJOINT_UNION_BOTH</a> : thm
<a name="line244"></a>    val <a href="#ELT_IN_DELETE-val">ELT_IN_DELETE</a> : thm
<a name="line245"></a>    val <a href="#EMPTY_DELETE-val">EMPTY_DELETE</a> : thm
<a name="line246"></a>    val <a href="#EMPTY_DIFF-val">EMPTY_DIFF</a> : thm
<a name="line247"></a>    val <a href="#EMPTY_FUNSET-val">EMPTY_FUNSET</a> : thm
<a name="line248"></a>    val <a href="#EMPTY_IN_POW-val">EMPTY_IN_POW</a> : thm
<a name="line249"></a>    val <a href="#EMPTY_NOT_IN_partition-val">EMPTY_NOT_IN_partition</a> : thm
<a name="line250"></a>    val <a href="#EMPTY_NOT_UNIV-val">EMPTY_NOT_UNIV</a> : thm
<a name="line251"></a>    val <a href="#EMPTY_SUBSET-val">EMPTY_SUBSET</a> : thm
<a name="line252"></a>    val <a href="#EMPTY_UNION-val">EMPTY_UNION</a> : thm
<a name="line253"></a>    val <a href="#EMPTY_applied-val">EMPTY_applied</a> : thm
<a name="line254"></a>    val <a href="#ENUMERATE-val">ENUMERATE</a> : thm
<a name="line255"></a>    val <a href="#EQUAL_SING-val">EQUAL_SING</a> : thm
<a name="line256"></a>    val <a href="#EQ_SUBSET_SUBSET-val">EQ_SUBSET_SUBSET</a> : thm
<a name="line257"></a>    val <a href="#EQ_UNIV-val">EQ_UNIV</a> : thm
<a name="line258"></a>    val <a href="#EXISTS_IN_IMAGE-val">EXISTS_IN_IMAGE</a> : thm
<a name="line259"></a>    val <a href="#EXISTS_IN_INSERT-val">EXISTS_IN_INSERT</a> : thm
<a name="line260"></a>    val <a href="#EXPLICIT_ENUMERATE_MONO-val">EXPLICIT_ENUMERATE_MONO</a> : thm
<a name="line261"></a>    val <a href="#EXPLICIT_ENUMERATE_NOT_EMPTY-val">EXPLICIT_ENUMERATE_NOT_EMPTY</a> : thm
<a name="line262"></a>    val <a href="#EXTENSION-val">EXTENSION</a> : thm
<a name="line263"></a>    val <a href="#EXTENSIONAL-val">EXTENSIONAL</a> : thm
<a name="line264"></a>    val <a href="#EXTENSIONAL_EMPTY-val">EXTENSIONAL_EMPTY</a> : thm
<a name="line265"></a>    val <a href="#EXTENSIONAL_EQ-val">EXTENSIONAL_EQ</a> : thm
<a name="line266"></a>    val <a href="#EXTENSIONAL_UNIV-val">EXTENSIONAL_UNIV</a> : thm
<a name="line267"></a>    val <a href="#FINITELY_INJECTIVE_IMAGE_FINITE-val">FINITELY_INJECTIVE_IMAGE_FINITE</a> : thm
<a name="line268"></a>    val <a href="#FINITE_BIGINTER-val">FINITE_BIGINTER</a> : thm
<a name="line269"></a>    val <a href="#FINITE_BIGUNION-val">FINITE_BIGUNION</a> : thm
<a name="line270"></a>    val <a href="#FINITE_BIGUNION_EQ-val">FINITE_BIGUNION_EQ</a> : thm
<a name="line271"></a>    val <a href="#FINITE_BIJ-val">FINITE_BIJ</a> : thm
<a name="line272"></a>    val <a href="#FINITE_BIJ_CARD-val">FINITE_BIJ_CARD</a> : thm
<a name="line273"></a>    val <a href="#FINITE_BIJ_CARD_EQ-val">FINITE_BIJ_CARD_EQ</a> : thm
<a name="line274"></a>    val <a href="#FINITE_BIJ_COUNT-val">FINITE_BIJ_COUNT</a> : thm
<a name="line275"></a>    val <a href="#FINITE_BIJ_COUNT_EQ-val">FINITE_BIJ_COUNT_EQ</a> : thm
<a name="line276"></a>    val <a href="#FINITE_CARD_IMAGE-val">FINITE_CARD_IMAGE</a> : thm
<a name="line277"></a>    val <a href="#FINITE_COMPLETE_INDUCTION-val">FINITE_COMPLETE_INDUCTION</a> : thm
<a name="line278"></a>    val <a href="#FINITE_COUNT-val">FINITE_COUNT</a> : thm
<a name="line279"></a>    val <a href="#FINITE_CROSS-val">FINITE_CROSS</a> : thm
<a name="line280"></a>    val <a href="#FINITE_CROSS_EQ-val">FINITE_CROSS_EQ</a> : thm
<a name="line281"></a>    val <a href="#FINITE_DELETE-val">FINITE_DELETE</a> : thm
<a name="line282"></a>    val <a href="#FINITE_DIFF-val">FINITE_DIFF</a> : thm
<a name="line283"></a>    val <a href="#FINITE_DIFF_down-val">FINITE_DIFF_down</a> : thm
<a name="line284"></a>    val <a href="#FINITE_EMPTY-val">FINITE_EMPTY</a> : thm
<a name="line285"></a>    val <a href="#FINITE_HAS_SIZE-val">FINITE_HAS_SIZE</a> : thm
<a name="line286"></a>    val <a href="#FINITE_IMAGE_INJ'-val">FINITE_IMAGE_INJ'</a> : thm
<a name="line287"></a>    val <a href="#FINITE_IMAGE_INJ_EQ-val">FINITE_IMAGE_INJ_EQ</a> : thm
<a name="line288"></a>    val <a href="#FINITE_INDUCT-val">FINITE_INDUCT</a> : thm
<a name="line289"></a>    val <a href="#FINITE_INDUCT_STRONG-val">FINITE_INDUCT_STRONG</a> : thm
<a name="line290"></a>    val <a href="#FINITE_INJ-val">FINITE_INJ</a> : thm
<a name="line291"></a>    val <a href="#FINITE_INSERT-val">FINITE_INSERT</a> : thm
<a name="line292"></a>    val <a href="#FINITE_INTER-val">FINITE_INTER</a> : thm
<a name="line293"></a>    val <a href="#FINITE_ISO_NUM-val">FINITE_ISO_NUM</a> : thm
<a name="line294"></a>    val <a href="#FINITE_LEAST_MEASURE_INDUCTION-val">FINITE_LEAST_MEASURE_INDUCTION</a> : thm
<a name="line295"></a>    val <a href="#FINITE_POW-val">FINITE_POW</a> : thm
<a name="line296"></a>    val <a href="#FINITE_POW_EQN-val">FINITE_POW_EQN</a> : thm
<a name="line297"></a>    val <a href="#FINITE_PREIMAGE-val">FINITE_PREIMAGE</a> : thm
<a name="line298"></a>    val <a href="#FINITE_PRODUCT-val">FINITE_PRODUCT</a> : thm
<a name="line299"></a>    val <a href="#FINITE_PRODUCT_DEPENDENT-val">FINITE_PRODUCT_DEPENDENT</a> : thm
<a name="line300"></a>    val <a href="#FINITE_PSUBSET_INFINITE-val">FINITE_PSUBSET_INFINITE</a> : thm
<a name="line301"></a>    val <a href="#FINITE_PSUBSET_UNIV-val">FINITE_PSUBSET_UNIV</a> : thm
<a name="line302"></a>    val <a href="#FINITE_REST-val">FINITE_REST</a> : thm
<a name="line303"></a>    val <a href="#FINITE_REST_EQ-val">FINITE_REST_EQ</a> : thm
<a name="line304"></a>    val <a href="#FINITE_RULES-val">FINITE_RULES</a> : thm
<a name="line305"></a>    val <a href="#FINITE_SING-val">FINITE_SING</a> : thm
<a name="line306"></a>    val <a href="#FINITE_SURJ-val">FINITE_SURJ</a> : thm
<a name="line307"></a>    val <a href="#FINITE_SURJ_BIJ-val">FINITE_SURJ_BIJ</a> : thm
<a name="line308"></a>    val <a href="#FINITE_StrongOrder_WF-val">FINITE_StrongOrder_WF</a> : thm
<a name="line309"></a>    val <a href="#FINITE_UNION-val">FINITE_UNION</a> : thm
<a name="line310"></a>    val <a href="#FINITE_WEAK_ENUMERATE-val">FINITE_WEAK_ENUMERATE</a> : thm
<a name="line311"></a>    val <a href="#FINITE_WF_noloops-val">FINITE_WF_noloops</a> : thm
<a name="line312"></a>    val <a href="#FINITE_is_measure_maximal-val">FINITE_is_measure_maximal</a> : thm
<a name="line313"></a>    val <a href="#FINITE_partition-val">FINITE_partition</a> : thm
<a name="line314"></a>    val <a href="#FINITE_partitions-val">FINITE_partitions</a> : thm
<a name="line315"></a>    val <a href="#FORALL_IN_BIGUNION-val">FORALL_IN_BIGUNION</a> : thm
<a name="line316"></a>    val <a href="#FORALL_IN_IMAGE-val">FORALL_IN_IMAGE</a> : thm
<a name="line317"></a>    val <a href="#FORALL_IN_INSERT-val">FORALL_IN_INSERT</a> : thm
<a name="line318"></a>    val <a href="#FORALL_IN_UNION-val">FORALL_IN_UNION</a> : thm
<a name="line319"></a>    val <a href="#FUNPOW_INJ-val">FUNPOW_INJ</a> : thm
<a name="line320"></a>    val <a href="#FUNPOW_eq_elim-val">FUNPOW_eq_elim</a> : thm
<a name="line321"></a>    val <a href="#FUNPOW_min_cancel-val">FUNPOW_min_cancel</a> : thm
<a name="line322"></a>    val <a href="#FUNSET_DFUNSET-val">FUNSET_DFUNSET</a> : thm
<a name="line323"></a>    val <a href="#FUNSET_EMPTY-val">FUNSET_EMPTY</a> : thm
<a name="line324"></a>    val <a href="#FUNSET_INTER-val">FUNSET_INTER</a> : thm
<a name="line325"></a>    val <a href="#FUNSET_THM-val">FUNSET_THM</a> : thm
<a name="line326"></a>    val <a href="#FUNSET_applied-val">FUNSET_applied</a> : thm
<a name="line327"></a>    val <a href="#GSPECIFICATION_applied-val">GSPECIFICATION_applied</a> : thm
<a name="line328"></a>    val <a href="#GSPEC_AND-val">GSPEC_AND</a> : thm
<a name="line329"></a>    val <a href="#GSPEC_EQ-val">GSPEC_EQ</a> : thm
<a name="line330"></a>    val <a href="#GSPEC_EQ2-val">GSPEC_EQ2</a> : thm
<a name="line331"></a>    val <a href="#GSPEC_ETA-val">GSPEC_ETA</a> : thm
<a name="line332"></a>    val <a href="#GSPEC_F-val">GSPEC_F</a> : thm
<a name="line333"></a>    val <a href="#GSPEC_F_COND-val">GSPEC_F_COND</a> : thm
<a name="line334"></a>    val <a href="#GSPEC_ID-val">GSPEC_ID</a> : thm
<a name="line335"></a>    val <a href="#GSPEC_IMAGE-val">GSPEC_IMAGE</a> : thm
<a name="line336"></a>    val <a href="#GSPEC_OR-val">GSPEC_OR</a> : thm
<a name="line337"></a>    val <a href="#GSPEC_PAIR_ETA-val">GSPEC_PAIR_ETA</a> : thm
<a name="line338"></a>    val <a href="#GSPEC_T-val">GSPEC_T</a> : thm
<a name="line339"></a>    val <a href="#HAS_SIZE_0-val">HAS_SIZE_0</a> : thm
<a name="line340"></a>    val <a href="#HAS_SIZE_CARD-val">HAS_SIZE_CARD</a> : thm
<a name="line341"></a>    val <a href="#HAS_SIZE_IMAGE_INJ-val">HAS_SIZE_IMAGE_INJ</a> : thm
<a name="line342"></a>    val <a href="#HAS_SIZE_INDEX-val">HAS_SIZE_INDEX</a> : thm
<a name="line343"></a>    val <a href="#HAS_SIZE_PRODUCT-val">HAS_SIZE_PRODUCT</a> : thm
<a name="line344"></a>    val <a href="#HAS_SIZE_PRODUCT_DEPENDENT-val">HAS_SIZE_PRODUCT_DEPENDENT</a> : thm
<a name="line345"></a>    val <a href="#HAS_SIZE_SUC-val">HAS_SIZE_SUC</a> : thm
<a name="line346"></a>    val <a href="#HAS_SIZE_UNION-val">HAS_SIZE_UNION</a> : thm
<a name="line347"></a>    val <a href="#IMAGE_11-val">IMAGE_11</a> : thm
<a name="line348"></a>    val <a href="#IMAGE_11_INFINITE-val">IMAGE_11_INFINITE</a> : thm
<a name="line349"></a>    val <a href="#IMAGE_BIGUNION-val">IMAGE_BIGUNION</a> : thm
<a name="line350"></a>    val <a href="#IMAGE_CLAUSES-val">IMAGE_CLAUSES</a> : thm
<a name="line351"></a>    val <a href="#IMAGE_COMPOSE-val">IMAGE_COMPOSE</a> : thm
<a name="line352"></a>    val <a href="#IMAGE_CONG-val">IMAGE_CONG</a> : thm
<a name="line353"></a>    val <a href="#IMAGE_CONST-val">IMAGE_CONST</a> : thm
<a name="line354"></a>    val <a href="#IMAGE_DELETE-val">IMAGE_DELETE</a> : thm
<a name="line355"></a>    val <a href="#IMAGE_EMPTY-val">IMAGE_EMPTY</a> : thm
<a name="line356"></a>    val <a href="#IMAGE_EQ_EMPTY-val">IMAGE_EQ_EMPTY</a> : thm
<a name="line357"></a>    val <a href="#IMAGE_EQ_SING-val">IMAGE_EQ_SING</a> : thm
<a name="line358"></a>    val <a href="#IMAGE_FINITE-val">IMAGE_FINITE</a> : thm
<a name="line359"></a>    val <a href="#IMAGE_FST_CROSS-val">IMAGE_FST_CROSS</a> : thm
<a name="line360"></a>    val <a href="#IMAGE_I-val">IMAGE_I</a> : thm
<a name="line361"></a>    val <a href="#IMAGE_ID-val">IMAGE_ID</a> : thm
<a name="line362"></a>    val <a href="#IMAGE_II-val">IMAGE_II</a> : thm
<a name="line363"></a>    val <a href="#IMAGE_IMAGE-val">IMAGE_IMAGE</a> : thm
<a name="line364"></a>    val <a href="#IMAGE_IMAGE_partition-val">IMAGE_IMAGE_partition</a> : thm
<a name="line365"></a>    val <a href="#IMAGE_IN-val">IMAGE_IN</a> : thm
<a name="line366"></a>    val <a href="#IMAGE_INSERT-val">IMAGE_INSERT</a> : thm
<a name="line367"></a>    val <a href="#IMAGE_INTER-val">IMAGE_INTER</a> : thm
<a name="line368"></a>    val <a href="#IMAGE_PREIMAGE-val">IMAGE_PREIMAGE</a> : thm
<a name="line369"></a>    val <a href="#IMAGE_RESTRICTION-val">IMAGE_RESTRICTION</a> : thm
<a name="line370"></a>    val <a href="#IMAGE_SING-val">IMAGE_SING</a> : thm
<a name="line371"></a>    val <a href="#IMAGE_SND_CROSS-val">IMAGE_SND_CROSS</a> : thm
<a name="line372"></a>    val <a href="#IMAGE_SUBSET-val">IMAGE_SUBSET</a> : thm
<a name="line373"></a>    val <a href="#IMAGE_SUBSET_gen-val">IMAGE_SUBSET_gen</a> : thm
<a name="line374"></a>    val <a href="#IMAGE_SURJ-val">IMAGE_SURJ</a> : thm
<a name="line375"></a>    val <a href="#IMAGE_UNION-val">IMAGE_UNION</a> : thm
<a name="line376"></a>    val <a href="#IMAGE_applied-val">IMAGE_applied</a> : thm
<a name="line377"></a>    val <a href="#IMAGE_o-val">IMAGE_o</a> : thm
<a name="line378"></a>    val <a href="#INFINITE_DIFF_FINITE-val">INFINITE_DIFF_FINITE</a> : thm
<a name="line379"></a>    val <a href="#INFINITE_DIFF_FINITE'-val">INFINITE_DIFF_FINITE'</a> : thm
<a name="line380"></a>    val <a href="#INFINITE_EXPLICIT_ENUMERATE-val">INFINITE_EXPLICIT_ENUMERATE</a> : thm
<a name="line381"></a>    val <a href="#INFINITE_INHAB-val">INFINITE_INHAB</a> : thm
<a name="line382"></a>    val <a href="#INFINITE_INJ-val">INFINITE_INJ</a> : thm
<a name="line383"></a>    val <a href="#INFINITE_INJ_NOT_SURJ-val">INFINITE_INJ_NOT_SURJ</a> : thm
<a name="line384"></a>    val <a href="#INFINITE_NUM_UNIV-val">INFINITE_NUM_UNIV</a> : thm
<a name="line385"></a>    val <a href="#INFINITE_PAIR_UNIV-val">INFINITE_PAIR_UNIV</a> : thm
<a name="line386"></a>    val <a href="#INFINITE_SUBSET-val">INFINITE_SUBSET</a> : thm
<a name="line387"></a>    val <a href="#INFINITE_UNIV-val">INFINITE_UNIV</a> : thm
<a name="line388"></a>    val <a href="#INJECTIVE_IMAGE_FINITE-val">INJECTIVE_IMAGE_FINITE</a> : thm
<a name="line389"></a>    val <a href="#INJ_BIJ_SUBSET-val">INJ_BIJ_SUBSET</a> : thm
<a name="line390"></a>    val <a href="#INJ_CARD-val">INJ_CARD</a> : thm
<a name="line391"></a>    val <a href="#INJ_CARD_IMAGE-val">INJ_CARD_IMAGE</a> : thm
<a name="line392"></a>    val <a href="#INJ_CARD_IMAGE_EQ-val">INJ_CARD_IMAGE_EQ</a> : thm
<a name="line393"></a>    val <a href="#INJ_COMPOSE-val">INJ_COMPOSE</a> : thm
<a name="line394"></a>    val <a href="#INJ_CONG-val">INJ_CONG</a> : thm
<a name="line395"></a>    val <a href="#INJ_DELETE-val">INJ_DELETE</a> : thm
<a name="line396"></a>    val <a href="#INJ_ELEMENT-val">INJ_ELEMENT</a> : thm
<a name="line397"></a>    val <a href="#INJ_EMPTY-val">INJ_EMPTY</a> : thm
<a name="line398"></a>    val <a href="#INJ_EQ_11-val">INJ_EQ_11</a> : thm
<a name="line399"></a>    val <a href="#INJ_EXTEND-val">INJ_EXTEND</a> : thm
<a name="line400"></a>    val <a href="#INJ_I-val">INJ_I</a> : thm
<a name="line401"></a>    val <a href="#INJ_ID-val">INJ_ID</a> : thm
<a name="line402"></a>    val <a href="#INJ_IFF-val">INJ_IFF</a> : thm
<a name="line403"></a>    val <a href="#INJ_IMAGE-val">INJ_IMAGE</a> : thm
<a name="line404"></a>    val <a href="#INJ_IMAGE_BIJ-val">INJ_IMAGE_BIJ</a> : thm
<a name="line405"></a>    val <a href="#INJ_IMAGE_DISJOINT-val">INJ_IMAGE_DISJOINT</a> : thm
<a name="line406"></a>    val <a href="#INJ_IMAGE_EQ-val">INJ_IMAGE_EQ</a> : thm
<a name="line407"></a>    val <a href="#INJ_IMAGE_INTER-val">INJ_IMAGE_INTER</a> : thm
<a name="line408"></a>    val <a href="#INJ_IMAGE_SUBSET-val">INJ_IMAGE_SUBSET</a> : thm
<a name="line409"></a>    val <a href="#INJ_IMAGE_equiv_class-val">INJ_IMAGE_equiv_class</a> : thm
<a name="line410"></a>    val <a href="#INJ_IMP_11-val">INJ_IMP_11</a> : thm
<a name="line411"></a>    val <a href="#INJ_INL-val">INJ_INL</a> : thm
<a name="line412"></a>    val <a href="#INJ_INR-val">INJ_INR</a> : thm
<a name="line413"></a>    val <a href="#INJ_INSERT-val">INJ_INSERT</a> : thm
<a name="line414"></a>    val <a href="#INJ_I_IMAGE-val">INJ_I_IMAGE</a> : thm
<a name="line415"></a>    val <a href="#INJ_LINV_OPT-val">INJ_LINV_OPT</a> : thm
<a name="line416"></a>    val <a href="#INJ_LINV_OPT_IMAGE-val">INJ_LINV_OPT_IMAGE</a> : thm
<a name="line417"></a>    val <a href="#INJ_SUBSET-val">INJ_SUBSET</a> : thm
<a name="line418"></a>    val <a href="#INJ_SUBSET_UNIV-val">INJ_SUBSET_UNIV</a> : thm
<a name="line419"></a>    val <a href="#INSERT_COMM-val">INSERT_COMM</a> : thm
<a name="line420"></a>    val <a href="#INSERT_DELETE-val">INSERT_DELETE</a> : thm
<a name="line421"></a>    val <a href="#INSERT_DIFF-val">INSERT_DIFF</a> : thm
<a name="line422"></a>    val <a href="#INSERT_EQ_SING-val">INSERT_EQ_SING</a> : thm
<a name="line423"></a>    val <a href="#INSERT_INSERT-val">INSERT_INSERT</a> : thm
<a name="line424"></a>    val <a href="#INSERT_INTER-val">INSERT_INTER</a> : thm
<a name="line425"></a>    val <a href="#INSERT_SING_UNION-val">INSERT_SING_UNION</a> : thm
<a name="line426"></a>    val <a href="#INSERT_SUBSET-val">INSERT_SUBSET</a> : thm
<a name="line427"></a>    val <a href="#INSERT_UNION-val">INSERT_UNION</a> : thm
<a name="line428"></a>    val <a href="#INSERT_UNION_EQ-val">INSERT_UNION_EQ</a> : thm
<a name="line429"></a>    val <a href="#INSERT_UNIV-val">INSERT_UNIV</a> : thm
<a name="line430"></a>    val <a href="#INSERT_applied-val">INSERT_applied</a> : thm
<a name="line431"></a>    val <a href="#INTER_ASSOC-val">INTER_ASSOC</a> : thm
<a name="line432"></a>    val <a href="#INTER_BIGUNION-val">INTER_BIGUNION</a> : thm
<a name="line433"></a>    val <a href="#INTER_COMM-val">INTER_COMM</a> : thm
<a name="line434"></a>    val <a href="#INTER_CROSS-val">INTER_CROSS</a> : thm
<a name="line435"></a>    val <a href="#INTER_EMPTY-val">INTER_EMPTY</a> : thm
<a name="line436"></a>    val <a href="#INTER_FINITE-val">INTER_FINITE</a> : thm
<a name="line437"></a>    val <a href="#INTER_IDEMPOT-val">INTER_IDEMPOT</a> : thm
<a name="line438"></a>    val <a href="#INTER_OVER_UNION-val">INTER_OVER_UNION</a> : thm
<a name="line439"></a>    val <a href="#INTER_SING-val">INTER_SING</a> : thm
<a name="line440"></a>    val <a href="#INTER_SUBSET-val">INTER_SUBSET</a> : thm
<a name="line441"></a>    val <a href="#INTER_SUBSET_EQN-val">INTER_SUBSET_EQN</a> : thm
<a name="line442"></a>    val <a href="#INTER_UNION-val">INTER_UNION</a> : thm
<a name="line443"></a>    val <a href="#INTER_UNION_COMPL-val">INTER_UNION_COMPL</a> : thm
<a name="line444"></a>    val <a href="#INTER_UNIV-val">INTER_UNIV</a> : thm
<a name="line445"></a>    val <a href="#INTER_applied-val">INTER_applied</a> : thm
<a name="line446"></a>    val <a href="#IN_ABS-val">IN_ABS</a> : thm
<a name="line447"></a>    val <a href="#IN_APP-val">IN_APP</a> : thm
<a name="line448"></a>    val <a href="#IN_BIGINTER-val">IN_BIGINTER</a> : thm
<a name="line449"></a>    val <a href="#IN_BIGINTER_IMAGE-val">IN_BIGINTER_IMAGE</a> : thm
<a name="line450"></a>    val <a href="#IN_BIGUNION-val">IN_BIGUNION</a> : thm
<a name="line451"></a>    val <a href="#IN_BIGUNION_IMAGE-val">IN_BIGUNION_IMAGE</a> : thm
<a name="line452"></a>    val <a href="#IN_COMPL-val">IN_COMPL</a> : thm
<a name="line453"></a>    val <a href="#IN_COUNT-val">IN_COUNT</a> : thm
<a name="line454"></a>    val <a href="#IN_CROSS-val">IN_CROSS</a> : thm
<a name="line455"></a>    val <a href="#IN_DELETE-val">IN_DELETE</a> : thm
<a name="line456"></a>    val <a href="#IN_DELETE_EQ-val">IN_DELETE_EQ</a> : thm
<a name="line457"></a>    val <a href="#IN_DFUNSET-val">IN_DFUNSET</a> : thm
<a name="line458"></a>    val <a href="#IN_DIFF-val">IN_DIFF</a> : thm
<a name="line459"></a>    val <a href="#IN_DISJOINT-val">IN_DISJOINT</a> : thm
<a name="line460"></a>    val <a href="#IN_EQ_UNIV_IMP-val">IN_EQ_UNIV_IMP</a> : thm
<a name="line461"></a>    val <a href="#IN_FUNSET-val">IN_FUNSET</a> : thm
<a name="line462"></a>    val <a href="#IN_GSPEC-val">IN_GSPEC</a> : thm
<a name="line463"></a>    val <a href="#IN_GSPEC_IFF-val">IN_GSPEC_IFF</a> : thm
<a name="line464"></a>    val <a href="#IN_IMAGE-val">IN_IMAGE</a> : thm
<a name="line465"></a>    val <a href="#IN_INFINITE_NOT_FINITE-val">IN_INFINITE_NOT_FINITE</a> : thm
<a name="line466"></a>    val <a href="#IN_INSERT-val">IN_INSERT</a> : thm
<a name="line467"></a>    val <a href="#IN_INSERT_EXPAND-val">IN_INSERT_EXPAND</a> : thm
<a name="line468"></a>    val <a href="#IN_INTER-val">IN_INTER</a> : thm
<a name="line469"></a>    val <a href="#IN_POW-val">IN_POW</a> : thm
<a name="line470"></a>    val <a href="#IN_PREIMAGE-val">IN_PREIMAGE</a> : thm
<a name="line471"></a>    val <a href="#IN_REST-val">IN_REST</a> : thm
<a name="line472"></a>    val <a href="#IN_SING-val">IN_SING</a> : thm
<a name="line473"></a>    val <a href="#IN_UNION-val">IN_UNION</a> : thm
<a name="line474"></a>    val <a href="#IN_UNIV-val">IN_UNIV</a> : thm
<a name="line475"></a>    val <a href="#IN_disjUNION-val">IN_disjUNION</a> : thm
<a name="line476"></a>    val <a href="#ITSET_CONG-val">ITSET_CONG</a> : thm
<a name="line477"></a>    val <a href="#ITSET_EMPTY-val">ITSET_EMPTY</a> : thm
<a name="line478"></a>    val <a href="#ITSET_IND-val">ITSET_IND</a> : thm
<a name="line479"></a>    val <a href="#ITSET_INSERT-val">ITSET_INSERT</a> : thm
<a name="line480"></a>    val <a href="#ITSET_PROPERTY-val">ITSET_PROPERTY</a> : thm
<a name="line481"></a>    val <a href="#ITSET_REDUCTION-val">ITSET_REDUCTION</a> : thm
<a name="line482"></a>    val <a href="#ITSET_SING-val">ITSET_SING</a> : thm
<a name="line483"></a>    val <a href="#ITSET_THM-val">ITSET_THM</a> : thm
<a name="line484"></a>    val <a href="#ITSET_def-val">ITSET_def</a> : thm
<a name="line485"></a>    val <a href="#K_SUBSET-val">K_SUBSET</a> : thm
<a name="line486"></a>    val <a href="#KoenigsLemma-val">KoenigsLemma</a> : thm
<a name="line487"></a>    val <a href="#KoenigsLemma_WF-val">KoenigsLemma_WF</a> : thm
<a name="line488"></a>    val <a href="#LESS_CARD_DIFF-val">LESS_CARD_DIFF</a> : thm
<a name="line489"></a>    val <a href="#LINV_DEF-val">LINV_DEF</a> : thm
<a name="line490"></a>    val <a href="#LINV_OPT_THM-val">LINV_OPT_THM</a> : thm
<a name="line491"></a>    val <a href="#MAX_SET_ELIM-val">MAX_SET_ELIM</a> : thm
<a name="line492"></a>    val <a href="#MAX_SET_EMPTY-val">MAX_SET_EMPTY</a> : thm
<a name="line493"></a>    val <a href="#MAX_SET_EQ_0-val">MAX_SET_EQ_0</a> : thm
<a name="line494"></a>    val <a href="#MAX_SET_INTER-val">MAX_SET_INTER</a> : thm
<a name="line495"></a>    val <a href="#MAX_SET_IN_SET-val">MAX_SET_IN_SET</a> : thm
<a name="line496"></a>    val <a href="#MAX_SET_LESS-val">MAX_SET_LESS</a> : thm
<a name="line497"></a>    val <a href="#MAX_SET_PROPERTY-val">MAX_SET_PROPERTY</a> : thm
<a name="line498"></a>    val <a href="#MAX_SET_REWRITES-val">MAX_SET_REWRITES</a> : thm
<a name="line499"></a>    val <a href="#MAX_SET_SING-val">MAX_SET_SING</a> : thm
<a name="line500"></a>    val <a href="#MAX_SET_TEST-val">MAX_SET_TEST</a> : thm
<a name="line501"></a>    val <a href="#MAX_SET_TEST_IFF-val">MAX_SET_TEST_IFF</a> : thm
<a name="line502"></a>    val <a href="#MAX_SET_THM-val">MAX_SET_THM</a> : thm
<a name="line503"></a>    val <a href="#MAX_SET_UNION-val">MAX_SET_UNION</a> : thm
<a name="line504"></a>    val <a href="#MEMBER_NOT_EMPTY-val">MEMBER_NOT_EMPTY</a> : thm
<a name="line505"></a>    val <a href="#MIN_SET_ELIM-val">MIN_SET_ELIM</a> : thm
<a name="line506"></a>    val <a href="#MIN_SET_EQ_0-val">MIN_SET_EQ_0</a> : thm
<a name="line507"></a>    val <a href="#MIN_SET_IN_SET-val">MIN_SET_IN_SET</a> : thm
<a name="line508"></a>    val <a href="#MIN_SET_LEM-val">MIN_SET_LEM</a> : thm
<a name="line509"></a>    val <a href="#MIN_SET_LEQ_MAX_SET-val">MIN_SET_LEQ_MAX_SET</a> : thm
<a name="line510"></a>    val <a href="#MIN_SET_PROPERTY-val">MIN_SET_PROPERTY</a> : thm
<a name="line511"></a>    val <a href="#MIN_SET_SING-val">MIN_SET_SING</a> : thm
<a name="line512"></a>    val <a href="#MIN_SET_TEST-val">MIN_SET_TEST</a> : thm
<a name="line513"></a>    val <a href="#MIN_SET_TEST_IFF-val">MIN_SET_TEST_IFF</a> : thm
<a name="line514"></a>    val <a href="#MIN_SET_THM-val">MIN_SET_THM</a> : thm
<a name="line515"></a>    val <a href="#MIN_SET_THM'-val">MIN_SET_THM'</a> : thm
<a name="line516"></a>    val <a href="#MIN_SET_UNION-val">MIN_SET_UNION</a> : thm
<a name="line517"></a>    val <a href="#NOT_EMPTY_INSERT-val">NOT_EMPTY_INSERT</a> : thm
<a name="line518"></a>    val <a href="#NOT_EMPTY_SING-val">NOT_EMPTY_SING</a> : thm
<a name="line519"></a>    val <a href="#NOT_EQUAL_SETS-val">NOT_EQUAL_SETS</a> : thm
<a name="line520"></a>    val <a href="#NOT_INSERT_EMPTY-val">NOT_INSERT_EMPTY</a> : thm
<a name="line521"></a>    val <a href="#NOT_IN_EMPTY-val">NOT_IN_EMPTY</a> : thm
<a name="line522"></a>    val <a href="#NOT_IN_FINITE-val">NOT_IN_FINITE</a> : thm
<a name="line523"></a>    val <a href="#NOT_PSUBSET_EMPTY-val">NOT_PSUBSET_EMPTY</a> : thm
<a name="line524"></a>    val <a href="#NOT_SING_EMPTY-val">NOT_SING_EMPTY</a> : thm
<a name="line525"></a>    val <a href="#NOT_UNIV_PSUBSET-val">NOT_UNIV_PSUBSET</a> : thm
<a name="line526"></a>    val <a href="#NUM_2D_BIJ-val">NUM_2D_BIJ</a> : thm
<a name="line527"></a>    val <a href="#NUM_2D_BIJ_BIG_SQUARE-val">NUM_2D_BIJ_BIG_SQUARE</a> : thm
<a name="line528"></a>    val <a href="#NUM_2D_BIJ_INV-val">NUM_2D_BIJ_INV</a> : thm
<a name="line529"></a>    val <a href="#NUM_2D_BIJ_NZ-val">NUM_2D_BIJ_NZ</a> : thm
<a name="line530"></a>    val <a href="#NUM_2D_BIJ_NZ_ALT-val">NUM_2D_BIJ_NZ_ALT</a> : thm
<a name="line531"></a>    val <a href="#NUM_2D_BIJ_NZ_ALT2-val">NUM_2D_BIJ_NZ_ALT2</a> : thm
<a name="line532"></a>    val <a href="#NUM_2D_BIJ_NZ_ALT2_INV-val">NUM_2D_BIJ_NZ_ALT2_INV</a> : thm
<a name="line533"></a>    val <a href="#NUM_2D_BIJ_NZ_ALT_INV-val">NUM_2D_BIJ_NZ_ALT_INV</a> : thm
<a name="line534"></a>    val <a href="#NUM_2D_BIJ_NZ_INV-val">NUM_2D_BIJ_NZ_INV</a> : thm
<a name="line535"></a>    val <a href="#NUM_2D_BIJ_SMALL_SQUARE-val">NUM_2D_BIJ_SMALL_SQUARE</a> : thm
<a name="line536"></a>    val <a href="#NUM_SET_WOP-val">NUM_SET_WOP</a> : thm
<a name="line537"></a>    val <a href="#ONE_ELEMENT_SING-val">ONE_ELEMENT_SING</a> : thm
<a name="line538"></a>    val <a href="#PAIR_IN_GSPEC_1-val">PAIR_IN_GSPEC_1</a> : thm
<a name="line539"></a>    val <a href="#PAIR_IN_GSPEC_2-val">PAIR_IN_GSPEC_2</a> : thm
<a name="line540"></a>    val <a href="#PAIR_IN_GSPEC_IFF-val">PAIR_IN_GSPEC_IFF</a> : thm
<a name="line541"></a>    val <a href="#PAIR_IN_GSPEC_same-val">PAIR_IN_GSPEC_same</a> : thm
<a name="line542"></a>    val <a href="#PHP-val">PHP</a> : thm
<a name="line543"></a>    val <a href="#PI_CONSTANT-val">PI_CONSTANT</a> : thm
<a name="line544"></a>    val <a href="#POW_EMPTY-val">POW_EMPTY</a> : thm
<a name="line545"></a>    val <a href="#POW_EQNS-val">POW_EQNS</a> : thm
<a name="line546"></a>    val <a href="#POW_INSERT-val">POW_INSERT</a> : thm
<a name="line547"></a>    val <a href="#POW_applied-val">POW_applied</a> : thm
<a name="line548"></a>    val <a href="#PREIMAGE_ALT-val">PREIMAGE_ALT</a> : thm
<a name="line549"></a>    val <a href="#PREIMAGE_BIGUNION-val">PREIMAGE_BIGUNION</a> : thm
<a name="line550"></a>    val <a href="#PREIMAGE_COMP-val">PREIMAGE_COMP</a> : thm
<a name="line551"></a>    val <a href="#PREIMAGE_COMPL-val">PREIMAGE_COMPL</a> : thm
<a name="line552"></a>    val <a href="#PREIMAGE_COMPL_INTER-val">PREIMAGE_COMPL_INTER</a> : thm
<a name="line553"></a>    val <a href="#PREIMAGE_CROSS-val">PREIMAGE_CROSS</a> : thm
<a name="line554"></a>    val <a href="#PREIMAGE_DIFF-val">PREIMAGE_DIFF</a> : thm
<a name="line555"></a>    val <a href="#PREIMAGE_DISJOINT-val">PREIMAGE_DISJOINT</a> : thm
<a name="line556"></a>    val <a href="#PREIMAGE_EMPTY-val">PREIMAGE_EMPTY</a> : thm
<a name="line557"></a>    val <a href="#PREIMAGE_I-val">PREIMAGE_I</a> : thm
<a name="line558"></a>    val <a href="#PREIMAGE_IMAGE-val">PREIMAGE_IMAGE</a> : thm
<a name="line559"></a>    val <a href="#PREIMAGE_INTER-val">PREIMAGE_INTER</a> : thm
<a name="line560"></a>    val <a href="#PREIMAGE_K-val">PREIMAGE_K</a> : thm
<a name="line561"></a>    val <a href="#PREIMAGE_SUBSET-val">PREIMAGE_SUBSET</a> : thm
<a name="line562"></a>    val <a href="#PREIMAGE_UNION-val">PREIMAGE_UNION</a> : thm
<a name="line563"></a>    val <a href="#PREIMAGE_UNIV-val">PREIMAGE_UNIV</a> : thm
<a name="line564"></a>    val <a href="#PREIMAGE_applied-val">PREIMAGE_applied</a> : thm
<a name="line565"></a>    val <a href="#PREIMAGE_o-val">PREIMAGE_o</a> : thm
<a name="line566"></a>    val <a href="#PROD_IMAGE_CONG-val">PROD_IMAGE_CONG</a> : thm
<a name="line567"></a>    val <a href="#PROD_IMAGE_CONSTANT-val">PROD_IMAGE_CONSTANT</a> : thm
<a name="line568"></a>    val <a href="#PROD_IMAGE_DELETE-val">PROD_IMAGE_DELETE</a> : thm
<a name="line569"></a>    val <a href="#PROD_IMAGE_EMPTY-val">PROD_IMAGE_EMPTY</a> : thm
<a name="line570"></a>    val <a href="#PROD_IMAGE_EQ_0-val">PROD_IMAGE_EQ_0</a> : thm
<a name="line571"></a>    val <a href="#PROD_IMAGE_EQ_1-val">PROD_IMAGE_EQ_1</a> : thm
<a name="line572"></a>    val <a href="#PROD_IMAGE_INSERT-val">PROD_IMAGE_INSERT</a> : thm
<a name="line573"></a>    val <a href="#PROD_IMAGE_THM-val">PROD_IMAGE_THM</a> : thm
<a name="line574"></a>    val <a href="#PROD_SET_EMPTY-val">PROD_SET_EMPTY</a> : thm
<a name="line575"></a>    val <a href="#PROD_SET_IMAGE_REDUCTION-val">PROD_SET_IMAGE_REDUCTION</a> : thm
<a name="line576"></a>    val <a href="#PROD_SET_INSERT-val">PROD_SET_INSERT</a> : thm
<a name="line577"></a>    val <a href="#PROD_SET_THM-val">PROD_SET_THM</a> : thm
<a name="line578"></a>    val <a href="#PSUBSET_EQN-val">PSUBSET_EQN</a> : thm
<a name="line579"></a>    val <a href="#PSUBSET_FINITE-val">PSUBSET_FINITE</a> : thm
<a name="line580"></a>    val <a href="#PSUBSET_INSERT_SUBSET-val">PSUBSET_INSERT_SUBSET</a> : thm
<a name="line581"></a>    val <a href="#PSUBSET_IRREFL-val">PSUBSET_IRREFL</a> : thm
<a name="line582"></a>    val <a href="#PSUBSET_MEMBER-val">PSUBSET_MEMBER</a> : thm
<a name="line583"></a>    val <a href="#PSUBSET_SING-val">PSUBSET_SING</a> : thm
<a name="line584"></a>    val <a href="#PSUBSET_SUBSET_TRANS-val">PSUBSET_SUBSET_TRANS</a> : thm
<a name="line585"></a>    val <a href="#PSUBSET_TRANS-val">PSUBSET_TRANS</a> : thm
<a name="line586"></a>    val <a href="#PSUBSET_UNIV-val">PSUBSET_UNIV</a> : thm
<a name="line587"></a>    val <a href="#RC_PSUBSET-val">RC_PSUBSET</a> : thm
<a name="line588"></a>    val <a href="#RC_SUBSET_THM-val">RC_SUBSET_THM</a> : thm
<a name="line589"></a>    val <a href="#REL_RESTRICT_EMPTY-val">REL_RESTRICT_EMPTY</a> : thm
<a name="line590"></a>    val <a href="#REL_RESTRICT_SUBSET-val">REL_RESTRICT_SUBSET</a> : thm
<a name="line591"></a>    val <a href="#RESTRICTION_COMPOSE-val">RESTRICTION_COMPOSE</a> : thm
<a name="line592"></a>    val <a href="#RESTRICTION_COMPOSE_LEFT-val">RESTRICTION_COMPOSE_LEFT</a> : thm
<a name="line593"></a>    val <a href="#RESTRICTION_COMPOSE_RIGHT-val">RESTRICTION_COMPOSE_RIGHT</a> : thm
<a name="line594"></a>    val <a href="#RESTRICTION_EXTENSION-val">RESTRICTION_EXTENSION</a> : thm
<a name="line595"></a>    val <a href="#RESTRICTION_FIXPOINT-val">RESTRICTION_FIXPOINT</a> : thm
<a name="line596"></a>    val <a href="#RESTRICTION_IDEMP-val">RESTRICTION_IDEMP</a> : thm
<a name="line597"></a>    val <a href="#RESTRICTION_IN_EXTENSIONAL-val">RESTRICTION_IN_EXTENSIONAL</a> : thm
<a name="line598"></a>    val <a href="#RESTRICTION_RESTRICTION-val">RESTRICTION_RESTRICTION</a> : thm
<a name="line599"></a>    val <a href="#RESTRICTION_UNIQUE-val">RESTRICTION_UNIQUE</a> : thm
<a name="line600"></a>    val <a href="#RESTRICTION_UNIQUE_ALT-val">RESTRICTION_UNIQUE_ALT</a> : thm
<a name="line601"></a>    val <a href="#REST_PSUBSET-val">REST_PSUBSET</a> : thm
<a name="line602"></a>    val <a href="#REST_SING-val">REST_SING</a> : thm
<a name="line603"></a>    val <a href="#REST_SUBSET-val">REST_SUBSET</a> : thm
<a name="line604"></a>    val <a href="#REST_applied-val">REST_applied</a> : thm
<a name="line605"></a>    val <a href="#RINV_DEF-val">RINV_DEF</a> : thm
<a name="line606"></a>    val <a href="#RTC_PSUBSET-val">RTC_PSUBSET</a> : thm
<a name="line607"></a>    val <a href="#RTC_SUBSET_THM-val">RTC_SUBSET_THM</a> : thm
<a name="line608"></a>    val <a href="#SCHROEDER_BERNSTEIN-val">SCHROEDER_BERNSTEIN</a> : thm
<a name="line609"></a>    val <a href="#SCHROEDER_BERNSTEIN_AUTO-val">SCHROEDER_BERNSTEIN_AUTO</a> : thm
<a name="line610"></a>    val <a href="#SCHROEDER_CLOSE-val">SCHROEDER_CLOSE</a> : thm
<a name="line611"></a>    val <a href="#SCHROEDER_CLOSED-val">SCHROEDER_CLOSED</a> : thm
<a name="line612"></a>    val <a href="#SCHROEDER_CLOSE_SET-val">SCHROEDER_CLOSE_SET</a> : thm
<a name="line613"></a>    val <a href="#SCHROEDER_CLOSE_SUBSET-val">SCHROEDER_CLOSE_SUBSET</a> : thm
<a name="line614"></a>    val <a href="#SET_CASES-val">SET_CASES</a> : thm
<a name="line615"></a>    val <a href="#SET_EQ_SUBSET-val">SET_EQ_SUBSET</a> : thm
<a name="line616"></a>    val <a href="#SET_MINIMUM-val">SET_MINIMUM</a> : thm
<a name="line617"></a>    val <a href="#SIGMA_CARD_CONSTANT-val">SIGMA_CARD_CONSTANT</a> : thm
<a name="line618"></a>    val <a href="#SIGMA_CARD_SAME_SIZE_SETS-val">SIGMA_CARD_SAME_SIZE_SETS</a> : thm
<a name="line619"></a>    val <a href="#SIGMA_CONG-val">SIGMA_CONG</a> : thm
<a name="line620"></a>    val <a href="#SIGMA_CONSTANT-val">SIGMA_CONSTANT</a> : thm
<a name="line621"></a>    val <a href="#SIGMA_LE_SIGMA-val">SIGMA_LE_SIGMA</a> : thm
<a name="line622"></a>    val <a href="#SIMPLE_FINITE_INDUCT-val">SIMPLE_FINITE_INDUCT</a> : thm
<a name="line623"></a>    val <a href="#SING-val">SING</a> : thm
<a name="line624"></a>    val <a href="#SING_CARD_1-val">SING_CARD_1</a> : thm
<a name="line625"></a>    val <a href="#SING_DELETE-val">SING_DELETE</a> : thm
<a name="line626"></a>    val <a href="#SING_ELEMENT-val">SING_ELEMENT</a> : thm
<a name="line627"></a>    val <a href="#SING_EMPTY-val">SING_EMPTY</a> : thm
<a name="line628"></a>    val <a href="#SING_FINITE-val">SING_FINITE</a> : thm
<a name="line629"></a>    val <a href="#SING_IFF_CARD1-val">SING_IFF_CARD1</a> : thm
<a name="line630"></a>    val <a href="#SING_IFF_EMPTY_REST-val">SING_IFF_EMPTY_REST</a> : thm
<a name="line631"></a>    val <a href="#SING_INSERT-val">SING_INSERT</a> : thm
<a name="line632"></a>    val <a href="#SING_INTER-val">SING_INTER</a> : thm
<a name="line633"></a>    val <a href="#SING_ONE_ELEMENT-val">SING_ONE_ELEMENT</a> : thm
<a name="line634"></a>    val <a href="#SING_TEST-val">SING_TEST</a> : thm
<a name="line635"></a>    val <a href="#SING_UNION-val">SING_UNION</a> : thm
<a name="line636"></a>    val <a href="#SING_applied-val">SING_applied</a> : thm
<a name="line637"></a>    val <a href="#SING_partitions-val">SING_partitions</a> : thm
<a name="line638"></a>    val <a href="#SPECIFICATION-val">SPECIFICATION</a> : thm
<a name="line639"></a>    val <a href="#SUBSET_ADD-val">SUBSET_ADD</a> : thm
<a name="line640"></a>    val <a href="#SUBSET_ANTISYM-val">SUBSET_ANTISYM</a> : thm
<a name="line641"></a>    val <a href="#SUBSET_ANTISYM_EQ-val">SUBSET_ANTISYM_EQ</a> : thm
<a name="line642"></a>    val <a href="#SUBSET_BIGINTER-val">SUBSET_BIGINTER</a> : thm
<a name="line643"></a>    val <a href="#SUBSET_BIGUNION-val">SUBSET_BIGUNION</a> : thm
<a name="line644"></a>    val <a href="#SUBSET_BIGUNION_I-val">SUBSET_BIGUNION_I</a> : thm
<a name="line645"></a>    val <a href="#SUBSET_BIGUNION_SUBSET_I-val">SUBSET_BIGUNION_SUBSET_I</a> : thm
<a name="line646"></a>    val <a href="#SUBSET_COMMUTING_ITSET_INSERT-val">SUBSET_COMMUTING_ITSET_INSERT</a> : thm
<a name="line647"></a>    val <a href="#SUBSET_COMMUTING_ITSET_RECURSES-val">SUBSET_COMMUTING_ITSET_RECURSES</a> : thm
<a name="line648"></a>    val <a href="#SUBSET_COMMUTING_ITSET_REDUCTION-val">SUBSET_COMMUTING_ITSET_REDUCTION</a> : thm
<a name="line649"></a>    val <a href="#SUBSET_CROSS-val">SUBSET_CROSS</a> : thm
<a name="line650"></a>    val <a href="#SUBSET_DELETE-val">SUBSET_DELETE</a> : thm
<a name="line651"></a>    val <a href="#SUBSET_DELETE_BOTH-val">SUBSET_DELETE_BOTH</a> : thm
<a name="line652"></a>    val <a href="#SUBSET_DIFF-val">SUBSET_DIFF</a> : thm
<a name="line653"></a>    val <a href="#SUBSET_DIFF_EMPTY-val">SUBSET_DIFF_EMPTY</a> : thm
<a name="line654"></a>    val <a href="#SUBSET_DISJOINT-val">SUBSET_DISJOINT</a> : thm
<a name="line655"></a>    val <a href="#SUBSET_EMPTY-val">SUBSET_EMPTY</a> : thm
<a name="line656"></a>    val <a href="#SUBSET_EQ_CARD-val">SUBSET_EQ_CARD</a> : thm
<a name="line657"></a>    val <a href="#SUBSET_FINITE-val">SUBSET_FINITE</a> : thm
<a name="line658"></a>    val <a href="#SUBSET_FINITE_I-val">SUBSET_FINITE_I</a> : thm
<a name="line659"></a>    val <a href="#SUBSET_IMAGE-val">SUBSET_IMAGE</a> : thm
<a name="line660"></a>    val <a href="#SUBSET_INSERT-val">SUBSET_INSERT</a> : thm
<a name="line661"></a>    val <a href="#SUBSET_INSERT_DELETE-val">SUBSET_INSERT_DELETE</a> : thm
<a name="line662"></a>    val <a href="#SUBSET_INSERT_RIGHT-val">SUBSET_INSERT_RIGHT</a> : thm
<a name="line663"></a>    val <a href="#SUBSET_INTER-val">SUBSET_INTER</a> : thm
<a name="line664"></a>    val <a href="#SUBSET_INTER1-val">SUBSET_INTER1</a> : thm
<a name="line665"></a>    val <a href="#SUBSET_INTER2-val">SUBSET_INTER2</a> : thm
<a name="line666"></a>    val <a href="#SUBSET_INTER_ABSORPTION-val">SUBSET_INTER_ABSORPTION</a> : thm
<a name="line667"></a>    val <a href="#SUBSET_K-val">SUBSET_K</a> : thm
<a name="line668"></a>    val <a href="#SUBSET_MAX_SET-val">SUBSET_MAX_SET</a> : thm
<a name="line669"></a>    val <a href="#SUBSET_MIN_SET-val">SUBSET_MIN_SET</a> : thm
<a name="line670"></a>    val <a href="#SUBSET_OF_INSERT-val">SUBSET_OF_INSERT</a> : thm
<a name="line671"></a>    val <a href="#SUBSET_POW-val">SUBSET_POW</a> : thm
<a name="line672"></a>    val <a href="#SUBSET_PSUBSET_TRANS-val">SUBSET_PSUBSET_TRANS</a> : thm
<a name="line673"></a>    val <a href="#SUBSET_REFL-val">SUBSET_REFL</a> : thm
<a name="line674"></a>    val <a href="#SUBSET_SING-val">SUBSET_SING</a> : thm
<a name="line675"></a>    val <a href="#SUBSET_THM-val">SUBSET_THM</a> : thm
<a name="line676"></a>    val <a href="#SUBSET_TRANS-val">SUBSET_TRANS</a> : thm
<a name="line677"></a>    val <a href="#SUBSET_UNION-val">SUBSET_UNION</a> : thm
<a name="line678"></a>    val <a href="#SUBSET_UNION_ABSORPTION-val">SUBSET_UNION_ABSORPTION</a> : thm
<a name="line679"></a>    val <a href="#SUBSET_UNIV-val">SUBSET_UNIV</a> : thm
<a name="line680"></a>    val <a href="#SUBSET_applied-val">SUBSET_applied</a> : thm
<a name="line681"></a>    val <a href="#SUBSET_count_MAX_SET-val">SUBSET_count_MAX_SET</a> : thm
<a name="line682"></a>    val <a href="#SUBSET_reflexive-val">SUBSET_reflexive</a> : thm
<a name="line683"></a>    val <a href="#SUBSET_transitive-val">SUBSET_transitive</a> : thm
<a name="line684"></a>    val <a href="#SUM_IMAGE_ADD-val">SUM_IMAGE_ADD</a> : thm
<a name="line685"></a>    val <a href="#SUM_IMAGE_CONG-val">SUM_IMAGE_CONG</a> : thm
<a name="line686"></a>    val <a href="#SUM_IMAGE_CONSTANT-val">SUM_IMAGE_CONSTANT</a> : thm
<a name="line687"></a>    val <a href="#SUM_IMAGE_DELETE-val">SUM_IMAGE_DELETE</a> : thm
<a name="line688"></a>    val <a href="#SUM_IMAGE_DISJOINT-val">SUM_IMAGE_DISJOINT</a> : thm
<a name="line689"></a>    val <a href="#SUM_IMAGE_EMPTY-val">SUM_IMAGE_EMPTY</a> : thm
<a name="line690"></a>    val <a href="#SUM_IMAGE_INJ_o-val">SUM_IMAGE_INJ_o</a> : thm
<a name="line691"></a>    val <a href="#SUM_IMAGE_INSERT-val">SUM_IMAGE_INSERT</a> : thm
<a name="line692"></a>    val <a href="#SUM_IMAGE_IN_LE-val">SUM_IMAGE_IN_LE</a> : thm
<a name="line693"></a>    val <a href="#SUM_IMAGE_MONO_LESS-val">SUM_IMAGE_MONO_LESS</a> : thm
<a name="line694"></a>    val <a href="#SUM_IMAGE_MONO_LESS_EQ-val">SUM_IMAGE_MONO_LESS_EQ</a> : thm
<a name="line695"></a>    val <a href="#SUM_IMAGE_MONO_LT-val">SUM_IMAGE_MONO_LT</a> : thm
<a name="line696"></a>    val <a href="#SUM_IMAGE_PERMUTES-val">SUM_IMAGE_PERMUTES</a> : thm
<a name="line697"></a>    val <a href="#SUM_IMAGE_SING-val">SUM_IMAGE_SING</a> : thm
<a name="line698"></a>    val <a href="#SUM_IMAGE_SUBSET_LE-val">SUM_IMAGE_SUBSET_LE</a> : thm
<a name="line699"></a>    val <a href="#SUM_IMAGE_THM-val">SUM_IMAGE_THM</a> : thm
<a name="line700"></a>    val <a href="#SUM_IMAGE_UNION-val">SUM_IMAGE_UNION</a> : thm
<a name="line701"></a>    val <a href="#SUM_IMAGE_UNION_EQN-val">SUM_IMAGE_UNION_EQN</a> : thm
<a name="line702"></a>    val <a href="#SUM_IMAGE_ZERO-val">SUM_IMAGE_ZERO</a> : thm
<a name="line703"></a>    val <a href="#SUM_IMAGE_lower_bound-val">SUM_IMAGE_lower_bound</a> : thm
<a name="line704"></a>    val <a href="#SUM_IMAGE_upper_bound-val">SUM_IMAGE_upper_bound</a> : thm
<a name="line705"></a>    val <a href="#SUM_SAME_IMAGE-val">SUM_SAME_IMAGE</a> : thm
<a name="line706"></a>    val <a href="#SUM_SET_DELETE-val">SUM_SET_DELETE</a> : thm
<a name="line707"></a>    val <a href="#SUM_SET_EMPTY-val">SUM_SET_EMPTY</a> : thm
<a name="line708"></a>    val <a href="#SUM_SET_INSERT-val">SUM_SET_INSERT</a> : thm
<a name="line709"></a>    val <a href="#SUM_SET_IN_LE-val">SUM_SET_IN_LE</a> : thm
<a name="line710"></a>    val <a href="#SUM_SET_SING-val">SUM_SET_SING</a> : thm
<a name="line711"></a>    val <a href="#SUM_SET_SUBSET_LE-val">SUM_SET_SUBSET_LE</a> : thm
<a name="line712"></a>    val <a href="#SUM_SET_THM-val">SUM_SET_THM</a> : thm
<a name="line713"></a>    val <a href="#SUM_SET_UNION-val">SUM_SET_UNION</a> : thm
<a name="line714"></a>    val <a href="#SUM_SET_count-val">SUM_SET_count</a> : thm
<a name="line715"></a>    val <a href="#SUM_SET_count_2-val">SUM_SET_count_2</a> : thm
<a name="line716"></a>    val <a href="#SUM_UNIV-val">SUM_UNIV</a> : thm
<a name="line717"></a>    val <a href="#SURJECTIVE_IFF_INJECTIVE-val">SURJECTIVE_IFF_INJECTIVE</a> : thm
<a name="line718"></a>    val <a href="#SURJECTIVE_IFF_INJECTIVE_GEN-val">SURJECTIVE_IFF_INJECTIVE_GEN</a> : thm
<a name="line719"></a>    val <a href="#SURJ_CARD-val">SURJ_CARD</a> : thm
<a name="line720"></a>    val <a href="#SURJ_COMPOSE-val">SURJ_COMPOSE</a> : thm
<a name="line721"></a>    val <a href="#SURJ_CONG-val">SURJ_CONG</a> : thm
<a name="line722"></a>    val <a href="#SURJ_ELEMENT-val">SURJ_ELEMENT</a> : thm
<a name="line723"></a>    val <a href="#SURJ_EMPTY-val">SURJ_EMPTY</a> : thm
<a name="line724"></a>    val <a href="#SURJ_ID-val">SURJ_ID</a> : thm
<a name="line725"></a>    val <a href="#SURJ_IMAGE-val">SURJ_IMAGE</a> : thm
<a name="line726"></a>    val <a href="#SURJ_IMP_INJ-val">SURJ_IMP_INJ</a> : thm
<a name="line727"></a>    val <a href="#SURJ_INJ_INV-val">SURJ_INJ_INV</a> : thm
<a name="line728"></a>    val <a href="#TC_PSUBSET-val">TC_PSUBSET</a> : thm
<a name="line729"></a>    val <a href="#TC_SUBSET_THM-val">TC_SUBSET_THM</a> : thm
<a name="line730"></a>    val <a href="#UNION_ASSOC-val">UNION_ASSOC</a> : thm
<a name="line731"></a>    val <a href="#UNION_COMM-val">UNION_COMM</a> : thm
<a name="line732"></a>    val <a href="#UNION_DELETE-val">UNION_DELETE</a> : thm
<a name="line733"></a>    val <a href="#UNION_DIFF-val">UNION_DIFF</a> : thm
<a name="line734"></a>    val <a href="#UNION_DIFF_2-val">UNION_DIFF_2</a> : thm
<a name="line735"></a>    val <a href="#UNION_DIFF_EQ-val">UNION_DIFF_EQ</a> : thm
<a name="line736"></a>    val <a href="#UNION_EMPTY-val">UNION_EMPTY</a> : thm
<a name="line737"></a>    val <a href="#UNION_IDEMPOT-val">UNION_IDEMPOT</a> : thm
<a name="line738"></a>    val <a href="#UNION_OVER_INTER-val">UNION_OVER_INTER</a> : thm
<a name="line739"></a>    val <a href="#UNION_SUBSET-val">UNION_SUBSET</a> : thm
<a name="line740"></a>    val <a href="#UNION_UNIV-val">UNION_UNIV</a> : thm
<a name="line741"></a>    val <a href="#UNION_applied-val">UNION_applied</a> : thm
<a name="line742"></a>    val <a href="#UNIQUE_MEMBER_SING-val">UNIQUE_MEMBER_SING</a> : thm
<a name="line743"></a>    val <a href="#UNIV_BOOL-val">UNIV_BOOL</a> : thm
<a name="line744"></a>    val <a href="#UNIV_FUNSET_UNIV-val">UNIV_FUNSET_UNIV</a> : thm
<a name="line745"></a>    val <a href="#UNIV_FUN_TO_BOOL-val">UNIV_FUN_TO_BOOL</a> : thm
<a name="line746"></a>    val <a href="#UNIV_NOT_EMPTY-val">UNIV_NOT_EMPTY</a> : thm
<a name="line747"></a>    val <a href="#UNIV_SUBSET-val">UNIV_SUBSET</a> : thm
<a name="line748"></a>    val <a href="#UNIV_applied-val">UNIV_applied</a> : thm
<a name="line749"></a>    val <a href="#X_LE_MAX_SET-val">X_LE_MAX_SET</a> : thm
<a name="line750"></a>    val <a href="#bigunion_countable-val">bigunion_countable</a> : thm
<a name="line751"></a>    val <a href="#chooser_compute-val">chooser_compute</a> : thm
<a name="line752"></a>    val <a href="#compl_insert-val">compl_insert</a> : thm
<a name="line753"></a>    val <a href="#count_EQN-val">count_EQN</a> : thm
<a name="line754"></a>    val <a href="#count_add-val">count_add</a> : thm
<a name="line755"></a>    val <a href="#count_add1-val">count_add1</a> : thm
<a name="line756"></a>    val <a href="#countable_EMPTY-val">countable_EMPTY</a> : thm
<a name="line757"></a>    val <a href="#countable_INSERT-val">countable_INSERT</a> : thm
<a name="line758"></a>    val <a href="#countable_Uprod-val">countable_Uprod</a> : thm
<a name="line759"></a>    val <a href="#countable_Usum-val">countable_Usum</a> : thm
<a name="line760"></a>    val <a href="#countable_image_nats-val">countable_image_nats</a> : thm
<a name="line761"></a>    val <a href="#countable_surj-val">countable_surj</a> : thm
<a name="line762"></a>    val <a href="#cross_countable-val">cross_countable</a> : thm
<a name="line763"></a>    val <a href="#cross_countable_IFF-val">cross_countable_IFF</a> : thm
<a name="line764"></a>    val <a href="#disjUNION_EQ_EMPTY-val">disjUNION_EQ_EMPTY</a> : thm
<a name="line765"></a>    val <a href="#disjUNION_UNIV-val">disjUNION_UNIV</a> : thm
<a name="line766"></a>    val <a href="#disjointD-val">disjointD</a> : thm
<a name="line767"></a>    val <a href="#disjointI-val">disjointI</a> : thm
<a name="line768"></a>    val <a href="#disjoint_def-val">disjoint_def</a> : thm
<a name="line769"></a>    val <a href="#disjoint_empty-val">disjoint_empty</a> : thm
<a name="line770"></a>    val <a href="#disjoint_image-val">disjoint_image</a> : thm
<a name="line771"></a>    val <a href="#disjoint_insert-val">disjoint_insert</a> : thm
<a name="line772"></a>    val <a href="#disjoint_insert_imp-val">disjoint_insert_imp</a> : thm
<a name="line773"></a>    val <a href="#disjoint_insert_notin-val">disjoint_insert_notin</a> : thm
<a name="line774"></a>    val <a href="#disjoint_restrict-val">disjoint_restrict</a> : thm
<a name="line775"></a>    val <a href="#disjoint_same-val">disjoint_same</a> : thm
<a name="line776"></a>    val <a href="#disjoint_sing-val">disjoint_sing</a> : thm
<a name="line777"></a>    val <a href="#disjoint_two-val">disjoint_two</a> : thm
<a name="line778"></a>    val <a href="#disjoint_union-val">disjoint_union</a> : thm
<a name="line779"></a>    val <a href="#empty_partitions-val">empty_partitions</a> : thm
<a name="line780"></a>    val <a href="#empty_refines-val">empty_refines</a> : thm
<a name="line781"></a>    val <a href="#equiv_class_eq-val">equiv_class_eq</a> : thm
<a name="line782"></a>    val <a href="#equiv_on_subset-val">equiv_on_subset</a> : thm
<a name="line783"></a>    val <a href="#equivalence_same_part-val">equivalence_same_part</a> : thm
<a name="line784"></a>    val <a href="#finite_countable-val">finite_countable</a> : thm
<a name="line785"></a>    val <a href="#image_countable-val">image_countable</a> : thm
<a name="line786"></a>    val <a href="#in_max_set-val">in_max_set</a> : thm
<a name="line787"></a>    val <a href="#in_part-val">in_part</a> : thm
<a name="line788"></a>    val <a href="#infinite_num_inj-val">infinite_num_inj</a> : thm
<a name="line789"></a>    val <a href="#infinite_pow_uncountable-val">infinite_pow_uncountable</a> : thm
<a name="line790"></a>    val <a href="#infinite_rest-val">infinite_rest</a> : thm
<a name="line791"></a>    val <a href="#inj_countable-val">inj_countable</a> : thm
<a name="line792"></a>    val <a href="#inj_image_countable_IFF-val">inj_image_countable_IFF</a> : thm
<a name="line793"></a>    val <a href="#inj_surj-val">inj_surj</a> : thm
<a name="line794"></a>    val <a href="#inter_countable-val">inter_countable</a> : thm
<a name="line795"></a>    val <a href="#inv_image_equiv_on-val">inv_image_equiv_on</a> : thm
<a name="line796"></a>    val <a href="#is_measure_maximal_INSERT-val">is_measure_maximal_INSERT</a> : thm
<a name="line797"></a>    val <a href="#is_measure_maximal_SING-val">is_measure_maximal_SING</a> : thm
<a name="line798"></a>    val <a href="#num_FINITE-val">num_FINITE</a> : thm
<a name="line799"></a>    val <a href="#num_FINITE_AVOID-val">num_FINITE_AVOID</a> : thm
<a name="line800"></a>    val <a href="#num_INFINITE-val">num_INFINITE</a> : thm
<a name="line801"></a>    val <a href="#num_countable-val">num_countable</a> : thm
<a name="line802"></a>    val <a href="#pair_to_num_formula-val">pair_to_num_formula</a> : thm
<a name="line803"></a>    val <a href="#pair_to_num_inv-val">pair_to_num_inv</a> : thm
<a name="line804"></a>    val <a href="#pair_to_num_inv'-val">pair_to_num_inv'</a> : thm
<a name="line805"></a>    val <a href="#pairwise_EMPTY-val">pairwise_EMPTY</a> : thm
<a name="line806"></a>    val <a href="#pairwise_SUBSET-val">pairwise_SUBSET</a> : thm
<a name="line807"></a>    val <a href="#pairwise_UNION-val">pairwise_UNION</a> : thm
<a name="line808"></a>    val <a href="#part_SING-val">part_SING</a> : thm
<a name="line809"></a>    val <a href="#part_in_partition-val">part_in_partition</a> : thm
<a name="line810"></a>    val <a href="#part_partition-val">part_partition</a> : thm
<a name="line811"></a>    val <a href="#part_unique-val">part_unique</a> : thm
<a name="line812"></a>    val <a href="#partition_CARD-val">partition_CARD</a> : thm
<a name="line813"></a>    val <a href="#partition_SUBSET-val">partition_SUBSET</a> : thm
<a name="line814"></a>    val <a href="#partition_elements_disjoint-val">partition_elements_disjoint</a> : thm
<a name="line815"></a>    val <a href="#partition_elements_interrelate-val">partition_elements_interrelate</a> : thm
<a name="line816"></a>    val <a href="#partition_rel_eq-val">partition_rel_eq</a> : thm
<a name="line817"></a>    val <a href="#partitions_DISJOINT-val">partitions_DISJOINT</a> : thm
<a name="line818"></a>    val <a href="#partitions_FINITE-val">partitions_FINITE</a> : thm
<a name="line819"></a>    val <a href="#partitions_INSERT-val">partitions_INSERT</a> : thm
<a name="line820"></a>    val <a href="#partitions_PAIR_DISJOINT-val">partitions_PAIR_DISJOINT</a> : thm
<a name="line821"></a>    val <a href="#partitions_SING-val">partitions_SING</a> : thm
<a name="line822"></a>    val <a href="#partitions_covers-val">partitions_covers</a> : thm
<a name="line823"></a>    val <a href="#partitions_empty-val">partitions_empty</a> : thm
<a name="line824"></a>    val <a href="#partitions_inj-val">partitions_inj</a> : thm
<a name="line825"></a>    val <a href="#partitions_thm-val">partitions_thm</a> : thm
<a name="line826"></a>    val <a href="#pow_no_surj-val">pow_no_surj</a> : thm
<a name="line827"></a>    val <a href="#prime_PROD_IMAGE-val">prime_PROD_IMAGE</a> : thm
<a name="line828"></a>    val <a href="#refines_antisym-val">refines_antisym</a> : thm
<a name="line829"></a>    val <a href="#refines_grows_parts-val">refines_grows_parts</a> : thm
<a name="line830"></a>    val <a href="#refines_refl-val">refines_refl</a> : thm
<a name="line831"></a>    val <a href="#refines_transitive-val">refines_transitive</a> : thm
<a name="line832"></a>    val <a href="#subset_countable-val">subset_countable</a> : thm
<a name="line833"></a>    val <a href="#transitive_PSUBSET-val">transitive_PSUBSET</a> : thm
<a name="line834"></a>    val <a href="#union_countable-val">union_countable</a> : thm
<a name="line835"></a>    val <a href="#union_countable_IFF-val">union_countable_IFF</a> : thm
<a name="line836"></a>(*
   [divides] Parent theory of "pred_set"
   
   [numpair] Parent theory of "pred_set"
   
   [<a name="BIGINTER-val"><b>BIGINTER</b></a>]  Definition
      
      ⊢ ∀P. BIGINTER P = {x | ∀s. s ∈ P ⇒ x ∈ s}
   
   [<a name="BIGUNION-val"><b>BIGUNION</b></a>]  Definition
      
      ⊢ ∀P. BIGUNION P = {x | ∃s. s ∈ P ∧ x ∈ s}
   
   [<a name="BIJ_DEF-val"><b>BIJ_DEF</b></a>]  Definition
      
      ⊢ ∀f s t. BIJ f s t ⇔ INJ f s t ∧ SURJ f s t
   
   [<a name="CARD_DEF-val"><b>CARD_DEF</b></a>]  Definition
      
      ⊢ CARD ∅ = 0 ∧
        ∀s. FINITE s ⇒
            ∀x. CARD (x INSERT s) = if x ∈ s then CARD s else SUC (CARD s)
   
   [<a name="CHOICE_DEF-val"><b>CHOICE_DEF</b></a>]  Definition
      
      ⊢ ∀s. s ≠ ∅ ⇒ CHOICE s ∈ s
   
   [<a name="COMPL_DEF-val"><b>COMPL_DEF</b></a>]  Definition
      
      ⊢ ∀P. COMPL P = 𝕌(:α) DIFF P
   
   [<a name="CROSS_DEF-val"><b>CROSS_DEF</b></a>]  Definition
      
      ⊢ ∀P Q. P × Q = {p | FST p ∈ P ∧ SND p ∈ Q}
   
   [<a name="DELETE_DEF-val"><b>DELETE_DEF</b></a>]  Definition
      
      ⊢ ∀s x. s DELETE x = s DIFF {x}
   
   [<a name="DFUNSET-val"><b>DFUNSET</b></a>]  Definition
      
      ⊢ ∀P Q. DFUNSET P Q = (λf. ∀x. x ∈ P ⇒ f x ∈ Q x)
   
   [<a name="DIFF_DEF-val"><b>DIFF_DEF</b></a>]  Definition
      
      ⊢ ∀s t. s DIFF t = {x | x ∈ s ∧ x ∉ t}
   
   [<a name="DISJOINT_DEF-val"><b>DISJOINT_DEF</b></a>]  Definition
      
      ⊢ ∀s t. DISJOINT s t ⇔ s ∩ t = ∅
   
   [<a name="EMPTY_DEF-val"><b>EMPTY_DEF</b></a>]  Definition
      
      ⊢ ∅ = (λx. F)
   
   [<a name="FINITE_DEF-val"><b>FINITE_DEF</b></a>]  Definition
      
      ⊢ ∀s. FINITE s ⇔ ∀P. P ∅ ∧ (∀s. P s ⇒ ∀e. P (e INSERT s)) ⇒ P s
   
   [<a name="FUNSET-val"><b>FUNSET</b></a>]  Definition
      
      ⊢ ∀P Q. FUNSET P Q = (λf. ∀x. x ∈ P ⇒ f x ∈ Q)
   
   [<a name="GSPECIFICATION-val"><b>GSPECIFICATION</b></a>]  Definition
      
      ⊢ ∀f v. v ∈ GSPEC f ⇔ ∃x. (v,T) = f x
   
   [<a name="HAS_SIZE-val"><b>HAS_SIZE</b></a>]  Definition
      
      ⊢ ∀s n. s HAS_SIZE n ⇔ FINITE s ∧ CARD s = n
   
   [<a name="IMAGE_DEF-val"><b>IMAGE_DEF</b></a>]  Definition
      
      ⊢ ∀f s. IMAGE f s = {f x | x ∈ s}
   
   [<a name="INJ_DEF-val"><b>INJ_DEF</b></a>]  Definition
      
      ⊢ ∀f s t.
          INJ f s t ⇔
          (∀x. x ∈ s ⇒ f x ∈ t) ∧ ∀x y. x ∈ s ∧ y ∈ s ⇒ f x = f y ⇒ x = y
   
   [<a name="INSERT_DEF-val"><b>INSERT_DEF</b></a>]  Definition
      
      ⊢ ∀x s. x INSERT s = {y | y = x ∨ y ∈ s}
   
   [<a name="INTER_DEF-val"><b>INTER_DEF</b></a>]  Definition
      
      ⊢ ∀s t. s ∩ t = {x | x ∈ s ∧ x ∈ t}
   
   [<a name="LINV_LO-val"><b>LINV_LO</b></a>]  Definition
      
      ⊢ ∀f s y. LINV f s y = THE (LINV_OPT f s y)
   
   [<a name="LINV_OPT_def-val"><b>LINV_OPT_def</b></a>]  Definition
      
      ⊢ ∀f s y.
          LINV_OPT f s y =
          if y ∈ IMAGE f s then SOME (@x. x ∈ s ∧ f x = y) else NONE
   
   [<a name="MAX_SET_DEF-val"><b>MAX_SET_DEF</b></a>]  Definition
      
      ⊢ ∀s. FINITE s ⇒
            (s ≠ ∅ ⇒ MAX_SET s ∈ s ∧ ∀y. y ∈ s ⇒ y ≤ MAX_SET s) ∧
            (s = ∅ ⇒ MAX_SET s = 0)
   
   [<a name="MIN_SET_DEF-val"><b>MIN_SET_DEF</b></a>]  Definition
      
      ⊢ MIN_SET = $LEAST
   
   [<a name="POW_DEF-val"><b>POW_DEF</b></a>]  Definition
      
      ⊢ ∀set. POW set = {s | s ⊆ set}
   
   [<a name="PREIMAGE_def-val"><b>PREIMAGE_def</b></a>]  Definition
      
      ⊢ ∀f s. PREIMAGE f s = {x | f x ∈ s}
   
   [<a name="PROD_IMAGE_DEF-val"><b>PROD_IMAGE_DEF</b></a>]  Definition
      
      ⊢ ∀f s. Π f s = ITSET (λe acc. f e * acc) s 1
   
   [<a name="PROD_SET_DEF-val"><b>PROD_SET_DEF</b></a>]  Definition
      
      ⊢ PROD_SET = Π I
   
   [<a name="PSUBSET_DEF-val"><b>PSUBSET_DEF</b></a>]  Definition
      
      ⊢ ∀s t. s ⊂ t ⇔ s ⊆ t ∧ s ≠ t
   
   [<a name="REL_RESTRICT_DEF-val"><b>REL_RESTRICT_DEF</b></a>]  Definition
      
      ⊢ ∀R s x y. REL_RESTRICT R s x y ⇔ x ∈ s ∧ y ∈ s ∧ R x y
   
   [<a name="REST_DEF-val"><b>REST_DEF</b></a>]  Definition
      
      ⊢ ∀s. REST s = s DELETE CHOICE s
   
   [<a name="RINV_LO-val"><b>RINV_LO</b></a>]  Definition
      
      ⊢ ∀f s y. RINV f s y = THE (LINV_OPT f s y)
   
   [<a name="SING_DEF-val"><b>SING_DEF</b></a>]  Definition
      
      ⊢ ∀s. SING s ⇔ ∃x. s = {x}
   
   [<a name="SUBSET_DEF-val"><b>SUBSET_DEF</b></a>]  Definition
      
      ⊢ ∀s t. s ⊆ t ⇔ ∀x. x ∈ s ⇒ x ∈ t
   
   [<a name="SUM_IMAGE_DEF-val"><b>SUM_IMAGE_DEF</b></a>]  Definition
      
      ⊢ ∀f s. ∑ f s = ITSET (λe acc. f e + acc) s 0
   
   [<a name="SUM_SET_DEF-val"><b>SUM_SET_DEF</b></a>]  Definition
      
      ⊢ SUM_SET = ∑ I
   
   [<a name="SURJ_DEF-val"><b>SURJ_DEF</b></a>]  Definition
      
      ⊢ ∀f s t.
          SURJ f s t ⇔
          (∀x. x ∈ s ⇒ f x ∈ t) ∧ ∀x. x ∈ t ⇒ ∃y. y ∈ s ∧ f y = x
   
   [<a name="UNION_DEF-val"><b>UNION_DEF</b></a>]  Definition
      
      ⊢ ∀s t. s ∪ t = {x | x ∈ s ∨ x ∈ t}
   
   [<a name="UNIV_DEF-val"><b>UNIV_DEF</b></a>]  Definition
      
      ⊢ 𝕌(:α) = (λx. T)
   
   [<a name="chooser_def-val"><b>chooser_def</b></a>]  Definition
      
      ⊢ (∀s. chooser s 0 = CHOICE s) ∧
        ∀s n. chooser s (SUC n) = chooser (REST s) n
   
   [<a name="closure_comm_assoc_fun_def-val"><b>closure_comm_assoc_fun_def</b></a>]  Definition
      
      ⊢ ∀f s.
          closure_comm_assoc_fun f s ⇔
          (∀x y. x ∈ s ∧ y ∈ s ⇒ f x y ∈ s) ∧
          ∀x y z. x ∈ s ∧ y ∈ s ∧ z ∈ s ⇒ f x (f y z) = f y (f x z)
   
   [<a name="count_def-val"><b>count_def</b></a>]  Definition
      
      ⊢ ∀n. count n = {m | m &lt; n}
   
   [<a name="countable_def-val"><b>countable_def</b></a>]  Definition
      
      ⊢ ∀s. countable s ⇔ ∃f. INJ f s 𝕌(:num)
   
   [<a name="disjUNION_def-val"><b>disjUNION_def</b></a>]  Definition
      
      ⊢ ∀A B. A ⊔ B = {INL a | a ∈ A} ∪ {INR b | b ∈ B}
   
   [<a name="disjoint-val"><b>disjoint</b></a>]  Definition
      
      ⊢ disjoint = pairwise (RC DISJOINT)
   
   [<a name="enumerate_def-val"><b>enumerate_def</b></a>]  Definition
      
      ⊢ ∀s. enumerate s = @f. BIJ f 𝕌(:num) s
   
   [<a name="equiv_on_def-val"><b>equiv_on_def</b></a>]  Definition
      
      ⊢ ∀R s.
          R equiv_on s ⇔
          (∀x. x ∈ s ⇒ R x x) ∧ (∀x y. x ∈ s ∧ y ∈ s ⇒ (R x y ⇔ R y x)) ∧
          ∀x y z. x ∈ s ∧ y ∈ s ∧ z ∈ s ∧ R x y ∧ R y z ⇒ R x z
   
   [<a name="is_measure_maximal_def-val"><b>is_measure_maximal_def</b></a>]  Definition
      
      ⊢ ∀m s x. is_measure_maximal m s x ⇔ x ∈ s ∧ ∀y. y ∈ s ⇒ m y ≤ m x
   
   [<a name="num_to_pair_def-val"><b>num_to_pair_def</b></a>]  Definition
      
      ⊢ ∀n. num_to_pair n = (nfst n,nsnd n)
   
   [<a name="pair_to_num_def-val"><b>pair_to_num_def</b></a>]  Definition
      
      ⊢ ∀m n. pair_to_num (m,n) = m ⊗ n
   
   [<a name="pairwise_def-val"><b>pairwise_def</b></a>]  Definition
      
      ⊢ ∀P s. pairwise P s ⇔ ∀e1 e2. e1 ∈ s ∧ e2 ∈ s ⇒ P e1 e2
   
   [<a name="part_def-val"><b>part_def</b></a>]  Definition
      
      ⊢ ∀v x. part v x = @s. x ∈ s ∧ s ∈ v
   
   [<a name="partition_def-val"><b>partition_def</b></a>]  Definition
      
      ⊢ ∀R s. partition R s = {t | ∃x. x ∈ s ∧ t = equiv_class R s x}
   
   [<a name="partitions_def-val"><b>partitions_def</b></a>]  Definition
      
      ⊢ ∀X Y. X partitions Y ⇔ ∃R. R equiv_on Y ∧ X = partition R Y
   
   [<a name="refines_def-val"><b>refines_def</b></a>]  Definition
      
      ⊢ ∀v1 v2. v1 refines v2 ⇔ ∀s1. s1 ∈ v1 ⇒ ∃s2. s2 ∈ v2 ∧ s1 ⊆ s2
   
   [<a name="schroeder_close_def-val"><b>schroeder_close_def</b></a>]  Definition
      
      ⊢ ∀f s x. schroeder_close f s x ⇔ ∃n. x ∈ FUNPOW (IMAGE f) n s
   
   [<a name="ABSORPTION-val"><b>ABSORPTION</b></a>]  Theorem
      
      ⊢ ∀x s. x ∈ s ⇔ x INSERT s = s
   
   [<a name="ABSORPTION_RWT-val"><b>ABSORPTION_RWT</b></a>]  Theorem
      
      ⊢ ∀x s. x ∈ s ⇒ x INSERT s = s
   
   [<a name="ABS_DIFF_SUM_IMAGE-val"><b>ABS_DIFF_SUM_IMAGE</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒
            ABS_DIFF (∑ f s) (∑ g s) ≤ ∑ (λx. ABS_DIFF (f x) (g x)) s
   
   [<a name="BIGINTER_2-val"><b>BIGINTER_2</b></a>]  Theorem
      
      ⊢ ∀P Q. BIGINTER {P; Q} = P ∩ Q
   
   [<a name="BIGINTER_EMPTY-val"><b>BIGINTER_EMPTY</b></a>]  Theorem
      
      ⊢ BIGINTER ∅ = 𝕌(:α)
   
   [<a name="BIGINTER_GSPEC-val"><b>BIGINTER_GSPEC</b></a>]  Theorem
      
      ⊢ (∀P f. BIGINTER {f x | P x} = {a | ∀x. P x ⇒ a ∈ f x}) ∧
        (∀P f. BIGINTER {f x y | P x y} = {a | ∀x y. P x y ⇒ a ∈ f x y}) ∧
        ∀P f.
          BIGINTER {f x y z | P x y z} =
          {a | ∀x y z. P x y z ⇒ a ∈ f x y z}
   
   [<a name="BIGINTER_IMAGE-val"><b>BIGINTER_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s. BIGINTER (IMAGE f s) = {y | ∀x. x ∈ s ⇒ y ∈ f x}
   
   [<a name="BIGINTER_INSERT-val"><b>BIGINTER_INSERT</b></a>]  Theorem
      
      ⊢ ∀P B. BIGINTER (P INSERT B) = P ∩ BIGINTER B
   
   [<a name="BIGINTER_INTER-val"><b>BIGINTER_INTER</b></a>]  Theorem
      
      ⊢ ∀P Q. BIGINTER {P; Q} = P ∩ Q
   
   [<a name="BIGINTER_SING-val"><b>BIGINTER_SING</b></a>]  Theorem
      
      ⊢ ∀P. BIGINTER {P} = P
   
   [<a name="BIGINTER_SUBSET-val"><b>BIGINTER_SUBSET</b></a>]  Theorem
      
      ⊢ ∀sp s t. t ∈ s ∧ t ⊆ sp ⇒ BIGINTER s ⊆ sp
   
   [<a name="BIGINTER_UNION-val"><b>BIGINTER_UNION</b></a>]  Theorem
      
      ⊢ ∀s1 s2. BIGINTER (s1 ∪ s2) = BIGINTER s1 ∩ BIGINTER s2
   
   [<a name="BIGINTER_applied-val"><b>BIGINTER_applied</b></a>]  Theorem
      
      ⊢ BIGINTER B x ⇔ ∀P. P ∈ B ⇒ x ∈ P
   
   [<a name="BIGUNION_CROSS-val"><b>BIGUNION_CROSS</b></a>]  Theorem
      
      ⊢ ∀f s t. BIGUNION (IMAGE f s) × t = BIGUNION (IMAGE (λn. f n × t) s)
   
   [<a name="BIGUNION_EMPTY-val"><b>BIGUNION_EMPTY</b></a>]  Theorem
      
      ⊢ BIGUNION ∅ = ∅
   
   [<a name="BIGUNION_EQ_EMPTY-val"><b>BIGUNION_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ ∀P. (BIGUNION P = ∅ ⇔ P = ∅ ∨ P = {∅}) ∧
            (∅ = BIGUNION P ⇔ P = ∅ ∨ P = {∅})
   
   [<a name="BIGUNION_GSPEC-val"><b>BIGUNION_GSPEC</b></a>]  Theorem
      
      ⊢ (∀P f. BIGUNION {f x | P x} = {a | ∃x. P x ∧ a ∈ f x}) ∧
        (∀P f. BIGUNION {f x y | P x y} = {a | ∃x y. P x y ∧ a ∈ f x y}) ∧
        ∀P f.
          BIGUNION {f x y z | P x y z} =
          {a | ∃x y z. P x y z ∧ a ∈ f x y z}
   
   [<a name="BIGUNION_IMAGE-val"><b>BIGUNION_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s. BIGUNION (IMAGE f s) = {y | ∃x. x ∈ s ∧ y ∈ f x}
   
   [<a name="BIGUNION_IMAGE_SUBSET-val"><b>BIGUNION_IMAGE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀f s t. BIGUNION (IMAGE f s) ⊆ t ⇔ ∀x. x ∈ s ⇒ f x ⊆ t
   
   [<a name="BIGUNION_IMAGE_UNIV-val"><b>BIGUNION_IMAGE_UNIV</b></a>]  Theorem
      
      ⊢ ∀f N.
          (∀n. N ≤ n ⇒ f n = ∅) ⇒
          BIGUNION (IMAGE f 𝕌(:num)) = BIGUNION (IMAGE f (count N))
   
   [<a name="BIGUNION_INSERT-val"><b>BIGUNION_INSERT</b></a>]  Theorem
      
      ⊢ ∀s P. BIGUNION (s INSERT P) = s ∪ BIGUNION P
   
   [<a name="BIGUNION_PAIR-val"><b>BIGUNION_PAIR</b></a>]  Theorem
      
      ⊢ ∀s t. BIGUNION {s; t} = s ∪ t
   
   [<a name="BIGUNION_SING-val"><b>BIGUNION_SING</b></a>]  Theorem
      
      ⊢ ∀x. BIGUNION {x} = x
   
   [<a name="BIGUNION_SUBSET-val"><b>BIGUNION_SUBSET</b></a>]  Theorem
      
      ⊢ ∀X P. BIGUNION P ⊆ X ⇔ ∀Y. Y ∈ P ⇒ Y ⊆ X
   
   [<a name="BIGUNION_UNION-val"><b>BIGUNION_UNION</b></a>]  Theorem
      
      ⊢ ∀s1 s2. BIGUNION (s1 ∪ s2) = BIGUNION s1 ∪ BIGUNION s2
   
   [<a name="BIGUNION_applied-val"><b>BIGUNION_applied</b></a>]  Theorem
      
      ⊢ ∀x sos. BIGUNION sos x ⇔ ∃s. x ∈ s ∧ s ∈ sos
   
   [<a name="BIGUNION_partition-val"><b>BIGUNION_partition</b></a>]  Theorem
      
      ⊢ R equiv_on s ⇒ BIGUNION (partition R s) = s
   
   [<a name="BIJ_ALT-val"><b>BIJ_ALT</b></a>]  Theorem
      
      ⊢ ∀f s t.
          BIJ f s t ⇔ f ∈ FUNSET s t ∧ ∀y. y ∈ t ⇒ ∃!x. x ∈ s ∧ y = f x
   
   [<a name="BIJ_COMPOSE-val"><b>BIJ_COMPOSE</b></a>]  Theorem
      
      ⊢ ∀f g s t u. BIJ f s t ∧ BIJ g t u ⇒ BIJ (g ∘ f) s u
   
   [<a name="BIJ_CONG-val"><b>BIJ_CONG</b></a>]  Theorem
      
      ⊢ ∀f g s t. (∀x. x ∈ s ⇒ f x = g x) ⇒ (BIJ f s t ⇔ BIJ g s t)
   
   [<a name="BIJ_DELETE-val"><b>BIJ_DELETE</b></a>]  Theorem
      
      ⊢ ∀s t f. BIJ f s t ⇒ ∀e. e ∈ s ⇒ BIJ f (s DELETE e) (t DELETE f e)
   
   [<a name="BIJ_ELEMENT-val"><b>BIJ_ELEMENT</b></a>]  Theorem
      
      ⊢ ∀f s t x. BIJ f s t ∧ x ∈ s ⇒ f x ∈ t
   
   [<a name="BIJ_EMPTY-val"><b>BIJ_EMPTY</b></a>]  Theorem
      
      ⊢ ∀f. (∀s. BIJ f ∅ s ⇔ s = ∅) ∧ ∀s. BIJ f s ∅ ⇔ s = ∅
   
   [<a name="BIJ_FINITE-val"><b>BIJ_FINITE</b></a>]  Theorem
      
      ⊢ ∀f s t. BIJ f s t ∧ FINITE s ⇒ FINITE t
   
   [<a name="BIJ_FINITE_IFF-val"><b>BIJ_FINITE_IFF</b></a>]  Theorem
      
      ⊢ ∀f s t. BIJ f s t ⇒ (FINITE s ⇔ FINITE t)
   
   [<a name="BIJ_FINITE_SUBSET-val"><b>BIJ_FINITE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀f s t.
          BIJ f 𝕌(:num) s ∧ FINITE t ∧ t ⊆ s ⇒ ∃N. ∀n. N ≤ n ⇒ f n ∉ t
   
   [<a name="BIJ_ID-val"><b>BIJ_ID</b></a>]  Theorem
      
      ⊢ ∀s. (λx. x) PERMUTES s
   
   [<a name="BIJ_IFF_INV-val"><b>BIJ_IFF_INV</b></a>]  Theorem
      
      ⊢ ∀f s t.
          BIJ f s t ⇔
          (∀x. x ∈ s ⇒ f x ∈ t) ∧
          ∃g. (∀x. x ∈ t ⇒ g x ∈ s) ∧ (∀x. x ∈ s ⇒ g (f x) = x) ∧
              ∀x. x ∈ t ⇒ f (g x) = x
   
   [<a name="BIJ_IMAGE-val"><b>BIJ_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s t. BIJ f s t ⇒ t = IMAGE f s
   
   [<a name="BIJ_IMAGE_partitions-val"><b>BIJ_IMAGE_partitions</b></a>]  Theorem
      
      ⊢ ∀f x y v.
          BIJ f x y ∧ v partitions x ⇒ IMAGE (IMAGE f) v partitions y
   
   [<a name="BIJ_IMP_11-val"><b>BIJ_IMP_11</b></a>]  Theorem
      
      ⊢ BIJ f 𝕌(:α) 𝕌(:β) ⇒ ∀x y. f x = f y ⇔ x = y
   
   [<a name="BIJ_INJ_SURJ-val"><b>BIJ_INJ_SURJ</b></a>]  Theorem
      
      ⊢ ∀s t. (∃f. INJ f s t) ∧ (∃g. SURJ g s t) ⇒ ∃h. BIJ h s t
   
   [<a name="BIJ_INSERT-val"><b>BIJ_INSERT</b></a>]  Theorem
      
      ⊢ ∀f e s t.
          BIJ f (e INSERT s) t ⇔
          e ∉ s ∧ f e ∈ t ∧ BIJ f s (t DELETE f e) ∨ e ∈ s ∧ BIJ f s t
   
   [<a name="BIJ_INSERT_IMP-val"><b>BIJ_INSERT_IMP</b></a>]  Theorem
      
      ⊢ ∀f e s t.
          e ∉ s ∧ BIJ f (e INSERT s) t ⇒
          ∃u. f e INSERT u = t ∧ f e ∉ u ∧ BIJ f s u
   
   [<a name="BIJ_INV-val"><b>BIJ_INV</b></a>]  Theorem
      
      ⊢ ∀f s t.
          BIJ f s t ⇒
          ∃g. BIJ g t s ∧ (∀x. x ∈ s ⇒ (g ∘ f) x = x) ∧
              ∀x. x ∈ t ⇒ (f ∘ g) x = x
   
   [<a name="BIJ_IS_INJ-val"><b>BIJ_IS_INJ</b></a>]  Theorem
      
      ⊢ ∀f s t. BIJ f s t ⇒ ∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y
   
   [<a name="BIJ_IS_SURJ-val"><b>BIJ_IS_SURJ</b></a>]  Theorem
      
      ⊢ ∀f s t. BIJ f s t ⇒ ∀x. x ∈ t ⇒ ∃y. y ∈ s ∧ f y = x
   
   [<a name="BIJ_I_SAME-val"><b>BIJ_I_SAME</b></a>]  Theorem
      
      ⊢ ∀s. I PERMUTES s
   
   [<a name="BIJ_LINV_BIJ-val"><b>BIJ_LINV_BIJ</b></a>]  Theorem
      
      ⊢ ∀f s t. BIJ f s t ⇒ BIJ (LINV f s) t s
   
   [<a name="BIJ_LINV_INV-val"><b>BIJ_LINV_INV</b></a>]  Theorem
      
      ⊢ ∀f s t. BIJ f s t ⇒ ∀x. x ∈ t ⇒ f (LINV f s x) = x
   
   [<a name="BIJ_NUM_COUNTABLE-val"><b>BIJ_NUM_COUNTABLE</b></a>]  Theorem
      
      ⊢ ∀s. (∃f. BIJ f 𝕌(:num) s) ⇒ countable s
   
   [<a name="BIJ_NUM_TO_PAIR-val"><b>BIJ_NUM_TO_PAIR</b></a>]  Theorem
      
      ⊢ BIJ num_to_pair 𝕌(:num) (𝕌(:num) × 𝕌(:num))
   
   [<a name="BIJ_PAIR_TO_NUM-val"><b>BIJ_PAIR_TO_NUM</b></a>]  Theorem
      
      ⊢ BIJ pair_to_num (𝕌(:num) × 𝕌(:num)) 𝕌(:num)
   
   [<a name="BIJ_SWAP-val"><b>BIJ_SWAP</b></a>]  Theorem
      
      ⊢ BIJ SWAP (𝕌(:α) × 𝕌(:β)) (𝕌(:β) × 𝕌(:α))
   
   [<a name="BIJ_SYM-val"><b>BIJ_SYM</b></a>]  Theorem
      
      ⊢ ∀s t. (∃f. BIJ f s t) ⇔ ∃g. BIJ g t s
   
   [<a name="BIJ_SYM_IMP-val"><b>BIJ_SYM_IMP</b></a>]  Theorem
      
      ⊢ ∀s t. (∃f. BIJ f s t) ⇒ ∃g. BIJ g t s
   
   [<a name="BIJ_THM-val"><b>BIJ_THM</b></a>]  Theorem
      
      ⊢ ∀f s t.
          BIJ f s t ⇔
          (∀x. x ∈ s ⇒ f x ∈ t) ∧ ∀y. y ∈ t ⇒ ∃!x. x ∈ s ∧ f x = y
   
   [<a name="BIJ_TRANS-val"><b>BIJ_TRANS</b></a>]  Theorem
      
      ⊢ ∀s t u. (∃f. BIJ f s t) ∧ (∃g. BIJ g t u) ⇒ ∃h. BIJ h s u
   
   [<a name="BIJ_support-val"><b>BIJ_support</b></a>]  Theorem
      
      ⊢ ∀f s' s.
          f PERMUTES s' ∧ s' ⊆ s ∧ (∀x. x ∉ s' ⇒ f x = x) ⇒ f PERMUTES s
   
   [<a name="CARD_AS_SIGMA-val"><b>CARD_AS_SIGMA</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ CARD s = ∑ (λx. 1) s
   
   [<a name="CARD_BIGUNION_SAME_SIZED_SETS-val"><b>CARD_BIGUNION_SAME_SIZED_SETS</b></a>]  Theorem
      
      ⊢ ∀n s.
          FINITE s ∧ (∀e. e ∈ s ⇒ FINITE e ∧ CARD e = n) ∧
          (∀e1 e2. e1 ∈ s ∧ e2 ∈ s ∧ e1 ≠ e2 ⇒ DISJOINT e1 e2) ⇒
          CARD (BIGUNION s) = CARD s * n
   
   [<a name="CARD_CLAUSES-val"><b>CARD_CLAUSES</b></a>]  Theorem
      
      ⊢ CARD ∅ = 0 ∧
        ∀s. FINITE s ⇒
            ∀x. CARD (x INSERT s) = if x ∈ s then CARD s else SUC (CARD s)
   
   [<a name="CARD_COUNT-val"><b>CARD_COUNT</b></a>]  Theorem
      
      ⊢ ∀n. CARD (count n) = n
   
   [<a name="CARD_CROSS-val"><b>CARD_CROSS</b></a>]  Theorem
      
      ⊢ ∀P Q. FINITE P ∧ FINITE Q ⇒ CARD (P × Q) = CARD P * CARD Q
   
   [<a name="CARD_DELETE-val"><b>CARD_DELETE</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒
            ∀x. CARD (s DELETE x) = if x ∈ s then CARD s − 1 else CARD s
   
   [<a name="CARD_DIFF-val"><b>CARD_DIFF</b></a>]  Theorem
      
      ⊢ ∀t. FINITE t ⇒
            ∀s. FINITE s ⇒ CARD (s DIFF t) = CARD s − CARD (s ∩ t)
   
   [<a name="CARD_DIFF_EQN-val"><b>CARD_DIFF_EQN</b></a>]  Theorem
      
      ⊢ ∀t s. FINITE s ⇒ CARD (s DIFF t) = CARD s − CARD (s ∩ t)
   
   [<a name="CARD_EMPTY-val"><b>CARD_EMPTY</b></a>]  Theorem
      
      ⊢ CARD ∅ = 0
   
   [<a name="CARD_EQ_0-val"><b>CARD_EQ_0</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ (CARD s = 0 ⇔ s = ∅)
   
   [<a name="CARD_EQ_SIGMA-val"><b>CARD_EQ_SIGMA</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ CARD s = ∑ (K 1) s
   
   [<a name="CARD_IMAGE-val"><b>CARD_IMAGE</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ CARD (IMAGE f s) ≤ CARD s
   
   [<a name="CARD_IMAGE_INJ-val"><b>CARD_IMAGE_INJ</b></a>]  Theorem
      
      ⊢ ∀f s.
          (∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y) ∧ FINITE s ⇒
          CARD (IMAGE f s) = CARD s
   
   [<a name="CARD_IMAGE_LE-val"><b>CARD_IMAGE_LE</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ⇒ CARD (IMAGE f s) ≤ CARD s
   
   [<a name="CARD_IMAGE_SUC-val"><b>CARD_IMAGE_SUC</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ CARD (IMAGE SUC s) = CARD s
   
   [<a name="CARD_INJ_IMAGE-val"><b>CARD_INJ_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s.
          (∀x y. f x = f y ⇔ x = y) ∧ FINITE s ⇒ CARD (IMAGE f s) = CARD s
   
   [<a name="CARD_INSERT-val"><b>CARD_INSERT</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒
            ∀x. CARD (x INSERT s) = if x ∈ s then CARD s else SUC (CARD s)
   
   [<a name="CARD_INTER_LESS_EQ-val"><b>CARD_INTER_LESS_EQ</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀t. CARD (s ∩ t) ≤ CARD s
   
   [<a name="CARD_LE_MAX_SET-val"><b>CARD_LE_MAX_SET</b></a>]  Theorem
      
      ⊢ FINITE s ⇒ CARD s ≤ MAX_SET s + 1
   
   [<a name="CARD_POW-val"><b>CARD_POW</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ CARD (POW s) = 2 ** CARD s
   
   [<a name="CARD_PRODUCT-val"><b>CARD_PRODUCT</b></a>]  Theorem
      
      ⊢ ∀s t.
          FINITE s ∧ FINITE t ⇒
          CARD {(x,y) | x ∈ s ∧ y ∈ t} = CARD s * CARD t
   
   [<a name="CARD_PSUBSET-val"><b>CARD_PSUBSET</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀t. t ⊂ s ⇒ CARD t &lt; CARD s
   
   [<a name="CARD_REST-val"><b>CARD_REST</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ∧ s ≠ ∅ ⇒ CARD (REST s) = CARD s − 1
   
   [<a name="CARD_SING-val"><b>CARD_SING</b></a>]  Theorem
      
      ⊢ ∀x. CARD {x} = 1
   
   [<a name="CARD_SING_CROSS-val"><b>CARD_SING_CROSS</b></a>]  Theorem
      
      ⊢ ∀x P. FINITE P ⇒ CARD ({x} × P) = CARD P
   
   [<a name="CARD_SUBSET-val"><b>CARD_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀t. t ⊆ s ⇒ CARD t ≤ CARD s
   
   [<a name="CARD_UNION-val"><b>CARD_UNION</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒
            ∀t. FINITE t ⇒ CARD (s ∪ t) + CARD (s ∩ t) = CARD s + CARD t
   
   [<a name="CARD_UNION_DISJOINT-val"><b>CARD_UNION_DISJOINT</b></a>]  Theorem
      
      ⊢ ∀s t.
          FINITE s ∧ FINITE t ∧ DISJOINT s t ⇒
          CARD (s ∪ t) = CARD s + CARD t
   
   [<a name="CARD_UNION_EQN-val"><b>CARD_UNION_EQN</b></a>]  Theorem
      
      ⊢ ∀s t.
          FINITE s ∧ FINITE t ⇒
          CARD (s ∪ t) = CARD s + CARD t − CARD (s ∩ t)
   
   [<a name="CARD_UNION_LE-val"><b>CARD_UNION_LE</b></a>]  Theorem
      
      ⊢ FINITE s ∧ FINITE t ⇒ CARD (s ∪ t) ≤ CARD s + CARD t
   
   [<a name="CARD_disjUNION-val"><b>CARD_disjUNION</b></a>]  Theorem
      
      ⊢ FINITE s ∧ FINITE t ⇒ CARD (s ⊔ t) = CARD s + CARD t
   
   [<a name="CHOICE_INSERT_REST-val"><b>CHOICE_INSERT_REST</b></a>]  Theorem
      
      ⊢ ∀s. s ≠ ∅ ⇒ CHOICE s INSERT REST s = s
   
   [<a name="CHOICE_INTRO-val"><b>CHOICE_INTRO</b></a>]  Theorem
      
      ⊢ (∃x. x ∈ s) ∧ (∀x. x ∈ s ⇒ P x) ⇒ P (CHOICE s)
   
   [<a name="CHOICE_NOT_IN_REST-val"><b>CHOICE_NOT_IN_REST</b></a>]  Theorem
      
      ⊢ ∀s. CHOICE s ∉ REST s
   
   [<a name="CHOICE_SING-val"><b>CHOICE_SING</b></a>]  Theorem
      
      ⊢ ∀x. CHOICE {x} = x
   
   [<a name="COMMUTING_ITSET_INSERT-val"><b>COMMUTING_ITSET_INSERT</b></a>]  Theorem
      
      ⊢ ∀f s.
          (∀x y z. f x (f y z) = f y (f x z)) ∧ FINITE s ⇒
          ∀x b. ITSET f (x INSERT s) b = ITSET f (s DELETE x) (f x b)
   
   [<a name="COMMUTING_ITSET_RECURSES-val"><b>COMMUTING_ITSET_RECURSES</b></a>]  Theorem
      
      ⊢ ∀f e s b.
          (∀x y z. f x (f y z) = f y (f x z)) ∧ FINITE s ⇒
          ITSET f (e INSERT s) b = f e (ITSET f (s DELETE e) b)
   
   [<a name="COMPL_CLAUSES-val"><b>COMPL_CLAUSES</b></a>]  Theorem
      
      ⊢ ∀s. COMPL s ∩ s = ∅ ∧ COMPL s ∪ s = 𝕌(:α)
   
   [<a name="COMPL_COMPL-val"><b>COMPL_COMPL</b></a>]  Theorem
      
      ⊢ ∀s. COMPL (COMPL s) = s
   
   [<a name="COMPL_EMPTY-val"><b>COMPL_EMPTY</b></a>]  Theorem
      
      ⊢ COMPL ∅ = 𝕌(:α)
   
   [<a name="COMPL_INTER-val"><b>COMPL_INTER</b></a>]  Theorem
      
      ⊢ x ∩ COMPL x = ∅ ∧ COMPL x ∩ x = ∅
   
   [<a name="COMPL_SPLITS-val"><b>COMPL_SPLITS</b></a>]  Theorem
      
      ⊢ ∀p q. p ∩ q ∪ COMPL p ∩ q = q
   
   [<a name="COMPL_UNION-val"><b>COMPL_UNION</b></a>]  Theorem
      
      ⊢ COMPL (s ∪ t) = COMPL s ∩ COMPL t
   
   [<a name="COMPL_applied-val"><b>COMPL_applied</b></a>]  Theorem
      
      ⊢ ∀x s. COMPL s x ⇔ x ∉ s
   
   [<a name="COMPONENT-val"><b>COMPONENT</b></a>]  Theorem
      
      ⊢ ∀x s. x ∈ x INSERT s
   
   [<a name="COUNTABLE_ALT-val"><b>COUNTABLE_ALT</b></a>]  Theorem
      
      ⊢ ∀s. countable s ⇔ ∃f. ∀x. x ∈ s ⇒ ∃n. f n = x
   
   [<a name="COUNTABLE_ALT_BIJ-val"><b>COUNTABLE_ALT_BIJ</b></a>]  Theorem
      
      ⊢ ∀s. countable s ⇔ FINITE s ∨ BIJ (enumerate s) 𝕌(:num) s
   
   [<a name="COUNTABLE_COUNT-val"><b>COUNTABLE_COUNT</b></a>]  Theorem
      
      ⊢ ∀n. countable (count n)
   
   [<a name="COUNTABLE_ENUM-val"><b>COUNTABLE_ENUM</b></a>]  Theorem
      
      ⊢ ∀c. countable c ⇔ c = ∅ ∨ ∃f. c = IMAGE f 𝕌(:num)
   
   [<a name="COUNTABLE_IMAGE_NUM-val"><b>COUNTABLE_IMAGE_NUM</b></a>]  Theorem
      
      ⊢ ∀f s. countable (IMAGE f s)
   
   [<a name="COUNTABLE_NUM-val"><b>COUNTABLE_NUM</b></a>]  Theorem
      
      ⊢ ∀s. countable s
   
   [<a name="COUNTABLE_SUBSET-val"><b>COUNTABLE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t. s ⊆ t ∧ countable t ⇒ countable s
   
   [<a name="COUNT_11-val"><b>COUNT_11</b></a>]  Theorem
      
      ⊢ ∀n1 n2. count n1 = count n2 ⇔ n1 = n2
   
   [<a name="COUNT_DELETE-val"><b>COUNT_DELETE</b></a>]  Theorem
      
      ⊢ ∀n. count n DELETE n = count n
   
   [<a name="COUNT_EQ_EMPTY-val"><b>COUNT_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ count n = ∅ ⇔ n = 0
   
   [<a name="COUNT_MONO-val"><b>COUNT_MONO</b></a>]  Theorem
      
      ⊢ ∀m n. m ≤ n ⇒ count m ⊆ count n
   
   [<a name="COUNT_NOT_EMPTY-val"><b>COUNT_NOT_EMPTY</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇔ count n ≠ ∅
   
   [<a name="COUNT_ONE-val"><b>COUNT_ONE</b></a>]  Theorem
      
      ⊢ count 1 = {0}
   
   [<a name="COUNT_SUC-val"><b>COUNT_SUC</b></a>]  Theorem
      
      ⊢ ∀n. count (SUC n) = n INSERT count n
   
   [<a name="COUNT_ZERO-val"><b>COUNT_ZERO</b></a>]  Theorem
      
      ⊢ count 0 = ∅
   
   [<a name="COUNT_applied-val"><b>COUNT_applied</b></a>]  Theorem
      
      ⊢ ∀m n. count n m ⇔ m &lt; n
   
   [<a name="CROSS_BIGUNION-val"><b>CROSS_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀f s t. s × BIGUNION (IMAGE f t) = BIGUNION (IMAGE (λn. s × f n) t)
   
   [<a name="CROSS_EMPTY-val"><b>CROSS_EMPTY</b></a>]  Theorem
      
      ⊢ ∀P. P × ∅ = ∅ ∧ ∅ × P = ∅
   
   [<a name="CROSS_EMPTY_EQN-val"><b>CROSS_EMPTY_EQN</b></a>]  Theorem
      
      ⊢ s × t = ∅ ⇔ s = ∅ ∨ t = ∅
   
   [<a name="CROSS_EQNS-val"><b>CROSS_EQNS</b></a>]  Theorem
      
      ⊢ ∀s1 s2.
          ∅ × s2 = ∅ ∧ (a INSERT s1) × s2 = IMAGE (λy. (a,y)) s2 ∪ s1 × s2
   
   [<a name="CROSS_INSERT_LEFT-val"><b>CROSS_INSERT_LEFT</b></a>]  Theorem
      
      ⊢ ∀P Q x. (x INSERT P) × Q = {x} × Q ∪ P × Q
   
   [<a name="CROSS_INSERT_RIGHT-val"><b>CROSS_INSERT_RIGHT</b></a>]  Theorem
      
      ⊢ ∀P Q x. P × (x INSERT Q) = P × {x} ∪ P × Q
   
   [<a name="CROSS_SINGS-val"><b>CROSS_SINGS</b></a>]  Theorem
      
      ⊢ ∀x y. {x} × {y} = {(x,y)}
   
   [<a name="CROSS_SUBSET-val"><b>CROSS_SUBSET</b></a>]  Theorem
      
      ⊢ ∀P Q P0 Q0. P0 × Q0 ⊆ P × Q ⇔ P0 = ∅ ∨ Q0 = ∅ ∨ P0 ⊆ P ∧ Q0 ⊆ Q
   
   [<a name="CROSS_UNIV-val"><b>CROSS_UNIV</b></a>]  Theorem
      
      ⊢ 𝕌(:α # β) = 𝕌(:α) × 𝕌(:β)
   
   [<a name="CROSS_applied-val"><b>CROSS_applied</b></a>]  Theorem
      
      ⊢ ∀P Q x. (P × Q) x ⇔ FST x ∈ P ∧ SND x ∈ Q
   
   [<a name="DECOMPOSITION-val"><b>DECOMPOSITION</b></a>]  Theorem
      
      ⊢ ∀s x. x ∈ s ⇔ ∃t. s = x INSERT t ∧ x ∉ t
   
   [<a name="DELETE_COMM-val"><b>DELETE_COMM</b></a>]  Theorem
      
      ⊢ ∀x y s. s DELETE x DELETE y = s DELETE y DELETE x
   
   [<a name="DELETE_DELETE-val"><b>DELETE_DELETE</b></a>]  Theorem
      
      ⊢ ∀x s. s DELETE x DELETE x = s DELETE x
   
   [<a name="DELETE_EQ_SING-val"><b>DELETE_EQ_SING</b></a>]  Theorem
      
      ⊢ ∀s x. x ∈ s ⇒ (s DELETE x = ∅ ⇔ s = {x})
   
   [<a name="DELETE_INSERT-val"><b>DELETE_INSERT</b></a>]  Theorem
      
      ⊢ ∀x y s.
          (x INSERT s) DELETE y =
          if x = y then s DELETE y else x INSERT s DELETE y
   
   [<a name="DELETE_INTER-val"><b>DELETE_INTER</b></a>]  Theorem
      
      ⊢ ∀s t x. (s DELETE x) ∩ t = s ∩ t DELETE x
   
   [<a name="DELETE_NON_ELEMENT-val"><b>DELETE_NON_ELEMENT</b></a>]  Theorem
      
      ⊢ ∀x s. x ∉ s ⇔ s DELETE x = s
   
   [<a name="DELETE_NON_ELEMENT_RWT-val"><b>DELETE_NON_ELEMENT_RWT</b></a>]  Theorem
      
      ⊢ ∀s x. x ∉ s ⇒ s DELETE x = s
   
   [<a name="DELETE_SUBSET-val"><b>DELETE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀x s. s DELETE x ⊆ s
   
   [<a name="DELETE_SUBSET_INSERT-val"><b>DELETE_SUBSET_INSERT</b></a>]  Theorem
      
      ⊢ ∀s e s2. s DELETE e ⊆ s2 ⇔ s ⊆ e INSERT s2
   
   [<a name="DELETE_applied-val"><b>DELETE_applied</b></a>]  Theorem
      
      ⊢ ∀s x y. (s DELETE y) x ⇔ x ∈ s ∧ x ≠ y
   
   [<a name="DFUNSET_applied-val"><b>DFUNSET_applied</b></a>]  Theorem
      
      ⊢ ∀f P Q. DFUNSET P Q f ⇔ ∀x. x ∈ P ⇒ f x ∈ Q x
   
   [<a name="DIFF_BIGINTER-val"><b>DIFF_BIGINTER</b></a>]  Theorem
      
      ⊢ ∀sp s.
          (∀t. t ∈ s ⇒ t ⊆ sp) ∧ s ≠ ∅ ⇒
          BIGINTER s = sp DIFF BIGUNION (IMAGE (λu. sp DIFF u) s)
   
   [<a name="DIFF_BIGINTER1-val"><b>DIFF_BIGINTER1</b></a>]  Theorem
      
      ⊢ ∀sp s. sp DIFF BIGINTER s = BIGUNION (IMAGE (λu. sp DIFF u) s)
   
   [<a name="DIFF_COMM-val"><b>DIFF_COMM</b></a>]  Theorem
      
      ⊢ ∀x y z. x DIFF y DIFF z = x DIFF z DIFF y
   
   [<a name="DIFF_DIFF-val"><b>DIFF_DIFF</b></a>]  Theorem
      
      ⊢ ∀s t. s DIFF t DIFF t = s DIFF t
   
   [<a name="DIFF_DIFF_SUBSET-val"><b>DIFF_DIFF_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t. t ⊆ s ⇒ s DIFF (s DIFF t) = t
   
   [<a name="DIFF_EMPTY-val"><b>DIFF_EMPTY</b></a>]  Theorem
      
      ⊢ ∀s. s DIFF ∅ = s
   
   [<a name="DIFF_EQ_EMPTY-val"><b>DIFF_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ ∀s. s DIFF s = ∅
   
   [<a name="DIFF_INSERT-val"><b>DIFF_INSERT</b></a>]  Theorem
      
      ⊢ ∀s t x. s DIFF (x INSERT t) = s DELETE x DIFF t
   
   [<a name="DIFF_INTER-val"><b>DIFF_INTER</b></a>]  Theorem
      
      ⊢ ∀s t g. (s DIFF t) ∩ g = s ∩ g DIFF t
   
   [<a name="DIFF_INTER2-val"><b>DIFF_INTER2</b></a>]  Theorem
      
      ⊢ ∀s t. s DIFF t ∩ s = s DIFF t
   
   [<a name="DIFF_INTER_COMPL-val"><b>DIFF_INTER_COMPL</b></a>]  Theorem
      
      ⊢ ∀s t. s DIFF t = s ∩ COMPL t
   
   [<a name="DIFF_INTER_SUBSET-val"><b>DIFF_INTER_SUBSET</b></a>]  Theorem
      
      ⊢ ∀r s t. r ⊆ s ⇒ r DIFF s ∩ t = r DIFF t
   
   [<a name="DIFF_SAME_UNION-val"><b>DIFF_SAME_UNION</b></a>]  Theorem
      
      ⊢ ∀x y. x ∪ y DIFF x = y DIFF x ∧ x ∪ y DIFF y = x DIFF y
   
   [<a name="DIFF_SUBSET-val"><b>DIFF_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t. s DIFF t ⊆ s
   
   [<a name="DIFF_UNION-val"><b>DIFF_UNION</b></a>]  Theorem
      
      ⊢ ∀x y z. x DIFF (y ∪ z) = x DIFF y DIFF z
   
   [<a name="DIFF_UNIV-val"><b>DIFF_UNIV</b></a>]  Theorem
      
      ⊢ ∀s. s DIFF 𝕌(:α) = ∅
   
   [<a name="DIFF_applied-val"><b>DIFF_applied</b></a>]  Theorem
      
      ⊢ ∀s t x. (s DIFF t) x ⇔ x ∈ s ∧ x ∉ t
   
   [<a name="DISJOINT_ALT-val"><b>DISJOINT_ALT</b></a>]  Theorem
      
      ⊢ ∀s t. DISJOINT s t ⇔ ∀x. x ∈ s ⇒ x ∉ t
   
   [<a name="DISJOINT_ALT'-val"><b>DISJOINT_ALT'</b></a>]  Theorem
      
      ⊢ ∀s t. DISJOINT s t ⇔ ∀x. x ∈ t ⇒ x ∉ s
   
   [<a name="DISJOINT_BIGINTER-val"><b>DISJOINT_BIGINTER</b></a>]  Theorem
      
      ⊢ ∀X Y P.
          Y ∈ P ∧ DISJOINT Y X ⇒
          DISJOINT X (BIGINTER P) ∧ DISJOINT (BIGINTER P) X
   
   [<a name="DISJOINT_BIGUNION-val"><b>DISJOINT_BIGUNION</b></a>]  Theorem
      
      ⊢ (∀s t. DISJOINT (BIGUNION s) t ⇔ ∀s'. s' ∈ s ⇒ DISJOINT s' t) ∧
        ∀s t. DISJOINT t (BIGUNION s) ⇔ ∀s'. s' ∈ s ⇒ DISJOINT t s'
   
   [<a name="DISJOINT_COUNT-val"><b>DISJOINT_COUNT</b></a>]  Theorem
      
      ⊢ ∀f. (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ⇒
            ∀n. DISJOINT (f n) (BIGUNION (IMAGE f (count n)))
   
   [<a name="DISJOINT_DELETE_SYM-val"><b>DISJOINT_DELETE_SYM</b></a>]  Theorem
      
      ⊢ ∀s t x. DISJOINT (s DELETE x) t ⇔ DISJOINT (t DELETE x) s
   
   [<a name="DISJOINT_DIFF-val"><b>DISJOINT_DIFF</b></a>]  Theorem
      
      ⊢ ∀s t. DISJOINT t (s DIFF t) ∧ DISJOINT (s DIFF t) t
   
   [<a name="DISJOINT_DIFFS-val"><b>DISJOINT_DIFFS</b></a>]  Theorem
      
      ⊢ ∀f g m n.
          (∀n. f n ⊆ f (SUC n)) ∧ (∀n. g n = f (SUC n) DIFF f n) ∧ m ≠ n ⇒
          DISJOINT (g m) (g n)
   
   [<a name="DISJOINT_EMPTY-val"><b>DISJOINT_EMPTY</b></a>]  Theorem
      
      ⊢ ∀s. DISJOINT ∅ s ∧ DISJOINT s ∅
   
   [<a name="DISJOINT_EMPTY_REFL-val"><b>DISJOINT_EMPTY_REFL</b></a>]  Theorem
      
      ⊢ ∀s. s = ∅ ⇔ DISJOINT s s
   
   [<a name="DISJOINT_EMPTY_REFL_RWT-val"><b>DISJOINT_EMPTY_REFL_RWT</b></a>]  Theorem
      
      ⊢ ∀s. DISJOINT s s ⇔ s = ∅
   
   [<a name="DISJOINT_IMAGE-val"><b>DISJOINT_IMAGE</b></a>]  Theorem
      
      ⊢ (∀x y. f x = f y ⇔ x = y) ⇒
        (DISJOINT (IMAGE f s1) (IMAGE f s2) ⇔ DISJOINT s1 s2)
   
   [<a name="DISJOINT_INSERT-val"><b>DISJOINT_INSERT</b></a>]  Theorem
      
      ⊢ ∀x s t. DISJOINT (x INSERT s) t ⇔ DISJOINT s t ∧ x ∉ t
   
   [<a name="DISJOINT_INSERT'-val"><b>DISJOINT_INSERT'</b></a>]  Theorem
      
      ⊢ ∀x s t. DISJOINT t (x INSERT s) ⇔ DISJOINT t s ∧ x ∉ t
   
   [<a name="DISJOINT_SING_EMPTY-val"><b>DISJOINT_SING_EMPTY</b></a>]  Theorem
      
      ⊢ ∀x. DISJOINT {x} ∅
   
   [<a name="DISJOINT_SUBSET-val"><b>DISJOINT_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t u. DISJOINT s t ∧ u ⊆ t ⇒ DISJOINT s u
   
   [<a name="DISJOINT_SUBSET'-val"><b>DISJOINT_SUBSET'</b></a>]  Theorem
      
      ⊢ ∀s t u. DISJOINT s t ∧ u ⊆ s ⇒ DISJOINT u t
   
   [<a name="DISJOINT_SYM-val"><b>DISJOINT_SYM</b></a>]  Theorem
      
      ⊢ ∀s t. DISJOINT s t ⇔ DISJOINT t s
   
   [<a name="DISJOINT_UNION-val"><b>DISJOINT_UNION</b></a>]  Theorem
      
      ⊢ ∀s t u. DISJOINT (s ∪ t) u ⇔ DISJOINT s u ∧ DISJOINT t u
   
   [<a name="DISJOINT_UNION'-val"><b>DISJOINT_UNION'</b></a>]  Theorem
      
      ⊢ ∀s t u. DISJOINT u (s ∪ t) ⇔ DISJOINT u s ∧ DISJOINT u t
   
   [<a name="DISJOINT_UNION_BOTH-val"><b>DISJOINT_UNION_BOTH</b></a>]  Theorem
      
      ⊢ ∀s t u.
          (DISJOINT (s ∪ t) u ⇔ DISJOINT s u ∧ DISJOINT t u) ∧
          (DISJOINT u (s ∪ t) ⇔ DISJOINT s u ∧ DISJOINT t u)
   
   [<a name="ELT_IN_DELETE-val"><b>ELT_IN_DELETE</b></a>]  Theorem
      
      ⊢ ∀x s. x ∉ s DELETE x
   
   [<a name="EMPTY_DELETE-val"><b>EMPTY_DELETE</b></a>]  Theorem
      
      ⊢ ∀x. ∅ DELETE x = ∅
   
   [<a name="EMPTY_DIFF-val"><b>EMPTY_DIFF</b></a>]  Theorem
      
      ⊢ ∀s. ∅ DIFF s = ∅
   
   [<a name="EMPTY_FUNSET-val"><b>EMPTY_FUNSET</b></a>]  Theorem
      
      ⊢ ∀s. FUNSET ∅ s = 𝕌(:α -&gt; β)
   
   [<a name="EMPTY_IN_POW-val"><b>EMPTY_IN_POW</b></a>]  Theorem
      
      ⊢ ∀s. ∅ ∈ POW s
   
   [<a name="EMPTY_NOT_IN_partition-val"><b>EMPTY_NOT_IN_partition</b></a>]  Theorem
      
      ⊢ R equiv_on s ⇒ ∅ ∉ partition R s
   
   [<a name="EMPTY_NOT_UNIV-val"><b>EMPTY_NOT_UNIV</b></a>]  Theorem
      
      ⊢ ∅ ≠ 𝕌(:α)
   
   [<a name="EMPTY_SUBSET-val"><b>EMPTY_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s. ∅ ⊆ s
   
   [<a name="EMPTY_UNION-val"><b>EMPTY_UNION</b></a>]  Theorem
      
      ⊢ ∀s t. s ∪ t = ∅ ⇔ s = ∅ ∧ t = ∅
   
   [<a name="EMPTY_applied-val"><b>EMPTY_applied</b></a>]  Theorem
      
      ⊢ ∅ x ⇔ F
   
   [<a name="ENUMERATE-val"><b>ENUMERATE</b></a>]  Theorem
      
      ⊢ ∀s. (∃f. BIJ f 𝕌(:num) s) ⇔ BIJ (enumerate s) 𝕌(:num) s
   
   [<a name="EQUAL_SING-val"><b>EQUAL_SING</b></a>]  Theorem
      
      ⊢ ∀x y. {x} = {y} ⇔ x = y
   
   [<a name="EQ_SUBSET_SUBSET-val"><b>EQ_SUBSET_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t. s = t ⇒ s ⊆ t ∧ t ⊆ s
   
   [<a name="EQ_UNIV-val"><b>EQ_UNIV</b></a>]  Theorem
      
      ⊢ (∀x. x ∈ s) ⇔ s = 𝕌(:α)
   
   [<a name="EXISTS_IN_IMAGE-val"><b>EXISTS_IN_IMAGE</b></a>]  Theorem
      
      ⊢ ∀P f s. (∃y. y ∈ IMAGE f s ∧ P y) ⇔ ∃x. x ∈ s ∧ P (f x)
   
   [<a name="EXISTS_IN_INSERT-val"><b>EXISTS_IN_INSERT</b></a>]  Theorem
      
      ⊢ ∀P a s. (∃x. x ∈ a INSERT s ∧ P x) ⇔ P a ∨ ∃x. x ∈ s ∧ P x
   
   [<a name="EXPLICIT_ENUMERATE_MONO-val"><b>EXPLICIT_ENUMERATE_MONO</b></a>]  Theorem
      
      ⊢ ∀n s. FUNPOW REST n s ⊆ s
   
   [<a name="EXPLICIT_ENUMERATE_NOT_EMPTY-val"><b>EXPLICIT_ENUMERATE_NOT_EMPTY</b></a>]  Theorem
      
      ⊢ ∀n s. INFINITE s ⇒ FUNPOW REST n s ≠ ∅
   
   [<a name="EXTENSION-val"><b>EXTENSION</b></a>]  Theorem
      
      ⊢ ∀s t. s = t ⇔ ∀x. x ∈ s ⇔ x ∈ t
   
   [<a name="EXTENSIONAL-val"><b>EXTENSIONAL</b></a>]  Theorem
      
      ⊢ ∀s. EXTENSIONAL s = {f | ∀x. x ∉ s ⇒ f x = ARB}
   
   [<a name="EXTENSIONAL_EMPTY-val"><b>EXTENSIONAL_EMPTY</b></a>]  Theorem
      
      ⊢ EXTENSIONAL ∅ = {(λx. ARB)}
   
   [<a name="EXTENSIONAL_EQ-val"><b>EXTENSIONAL_EQ</b></a>]  Theorem
      
      ⊢ ∀s f g.
          f ∈ EXTENSIONAL s ∧ g ∈ EXTENSIONAL s ∧ (∀x. x ∈ s ⇒ f x = g x) ⇒
          f = g
   
   [<a name="EXTENSIONAL_UNIV-val"><b>EXTENSIONAL_UNIV</b></a>]  Theorem
      
      ⊢ ∀f. EXTENSIONAL 𝕌(:α) f
   
   [<a name="FINITELY_INJECTIVE_IMAGE_FINITE-val"><b>FINITELY_INJECTIVE_IMAGE_FINITE</b></a>]  Theorem
      
      ⊢ ∀f. (∀x. FINITE {y | x = f y}) ⇒ ∀s. FINITE (IMAGE f s) ⇔ FINITE s
   
   [<a name="FINITE_BIGINTER-val"><b>FINITE_BIGINTER</b></a>]  Theorem
      
      ⊢ (∃s. s ∈ P ∧ FINITE s) ⇒ FINITE (BIGINTER P)
   
   [<a name="FINITE_BIGUNION-val"><b>FINITE_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀P. FINITE P ∧ (∀s. s ∈ P ⇒ FINITE s) ⇒ FINITE (BIGUNION P)
   
   [<a name="FINITE_BIGUNION_EQ-val"><b>FINITE_BIGUNION_EQ</b></a>]  Theorem
      
      ⊢ ∀P. FINITE (BIGUNION P) ⇔ FINITE P ∧ ∀s. s ∈ P ⇒ FINITE s
   
   [<a name="FINITE_BIJ-val"><b>FINITE_BIJ</b></a>]  Theorem
      
      ⊢ ∀f s t. FINITE s ∧ BIJ f s t ⇒ FINITE t ∧ CARD s = CARD t
   
   [<a name="FINITE_BIJ_CARD-val"><b>FINITE_BIJ_CARD</b></a>]  Theorem
      
      ⊢ ∀f s t. FINITE s ∧ BIJ f s t ⇒ CARD s = CARD t
   
   [<a name="FINITE_BIJ_CARD_EQ-val"><b>FINITE_BIJ_CARD_EQ</b></a>]  Theorem
      
      ⊢ ∀S. FINITE S ⇒ ∀t f. BIJ f S t ∧ FINITE t ⇒ CARD S = CARD t
   
   [<a name="FINITE_BIJ_COUNT-val"><b>FINITE_BIJ_COUNT</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∃f b. BIJ f (count b) s
   
   [<a name="FINITE_BIJ_COUNT_EQ-val"><b>FINITE_BIJ_COUNT_EQ</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇔ ∃c n. BIJ c (count n) s
   
   [<a name="FINITE_CARD_IMAGE-val"><b>FINITE_CARD_IMAGE</b></a>]  Theorem
      
      ⊢ ∀s f.
          (∀x y. f x = f y ⇔ x = y) ∧ FINITE s ⇒ CARD (IMAGE f s) = CARD s
   
   [<a name="FINITE_COMPLETE_INDUCTION-val"><b>FINITE_COMPLETE_INDUCTION</b></a>]  Theorem
      
      ⊢ ∀P. (∀x. (∀y. y ⊂ x ⇒ P y) ⇒ FINITE x ⇒ P x) ⇒ ∀x. FINITE x ⇒ P x
   
   [<a name="FINITE_COUNT-val"><b>FINITE_COUNT</b></a>]  Theorem
      
      ⊢ ∀n. FINITE (count n)
   
   [<a name="FINITE_CROSS-val"><b>FINITE_CROSS</b></a>]  Theorem
      
      ⊢ ∀P Q. FINITE P ∧ FINITE Q ⇒ FINITE (P × Q)
   
   [<a name="FINITE_CROSS_EQ-val"><b>FINITE_CROSS_EQ</b></a>]  Theorem
      
      ⊢ ∀P Q. FINITE (P × Q) ⇔ P = ∅ ∨ Q = ∅ ∨ FINITE P ∧ FINITE Q
   
   [<a name="FINITE_DELETE-val"><b>FINITE_DELETE</b></a>]  Theorem
      
      ⊢ ∀x s. FINITE (s DELETE x) ⇔ FINITE s
   
   [<a name="FINITE_DIFF-val"><b>FINITE_DIFF</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀t. FINITE (s DIFF t)
   
   [<a name="FINITE_DIFF_down-val"><b>FINITE_DIFF_down</b></a>]  Theorem
      
      ⊢ ∀P Q. FINITE (P DIFF Q) ∧ FINITE Q ⇒ FINITE P
   
   [<a name="FINITE_EMPTY-val"><b>FINITE_EMPTY</b></a>]  Theorem
      
      ⊢ FINITE ∅
   
   [<a name="FINITE_HAS_SIZE-val"><b>FINITE_HAS_SIZE</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇔ s HAS_SIZE CARD s
   
   [<a name="FINITE_IMAGE_INJ'-val"><b>FINITE_IMAGE_INJ'</b></a>]  Theorem
      
      ⊢ (∀x y. x ∈ s ∧ y ∈ s ⇒ (f x = f y ⇔ x = y)) ⇒
        (FINITE (IMAGE f s) ⇔ FINITE s)
   
   [<a name="FINITE_IMAGE_INJ_EQ-val"><b>FINITE_IMAGE_INJ_EQ</b></a>]  Theorem
      
      ⊢ ∀f s.
          (∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y) ⇒
          (FINITE (IMAGE f s) ⇔ FINITE s)
   
   [<a name="FINITE_INDUCT-val"><b>FINITE_INDUCT</b></a>]  Theorem
      
      ⊢ ∀P. P ∅ ∧ (∀s. FINITE s ∧ P s ⇒ ∀e. e ∉ s ⇒ P (e INSERT s)) ⇒
            ∀s. FINITE s ⇒ P s
   
   [<a name="FINITE_INDUCT_STRONG-val"><b>FINITE_INDUCT_STRONG</b></a>]  Theorem
      
      ⊢ ∀P. P ∅ ∧ (∀x s. P s ∧ x ∉ s ∧ FINITE s ⇒ P (x INSERT s)) ⇒
            ∀s. FINITE s ⇒ P s
   
   [<a name="FINITE_INJ-val"><b>FINITE_INJ</b></a>]  Theorem
      
      ⊢ ∀f s t. INJ f s t ∧ FINITE t ⇒ FINITE s
   
   [<a name="FINITE_INSERT-val"><b>FINITE_INSERT</b></a>]  Theorem
      
      ⊢ ∀x s. FINITE (x INSERT s) ⇔ FINITE s
   
   [<a name="FINITE_INTER-val"><b>FINITE_INTER</b></a>]  Theorem
      
      ⊢ ∀s1 s2. FINITE s1 ∨ FINITE s2 ⇒ FINITE (s1 ∩ s2)
   
   [<a name="FINITE_ISO_NUM-val"><b>FINITE_ISO_NUM</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒
            ∃f. (∀n m. n &lt; CARD s ∧ m &lt; CARD s ⇒ f n = f m ⇒ n = m) ∧
                s = {f n | n &lt; CARD s}
   
   [<a name="FINITE_LEAST_MEASURE_INDUCTION-val"><b>FINITE_LEAST_MEASURE_INDUCTION</b></a>]  Theorem
      
      ⊢ ∀f P.
          P ∅ ∧
          (∀a s. a ∉ s ∧ (∀b. b ∈ s ⇒ f a ≤ f b) ∧ P s ⇒ P (a INSERT s)) ⇒
          ∀s. FINITE s ⇒ P s
   
   [<a name="FINITE_POW-val"><b>FINITE_POW</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ FINITE (POW s)
   
   [<a name="FINITE_POW_EQN-val"><b>FINITE_POW_EQN</b></a>]  Theorem
      
      ⊢ FINITE (POW s) ⇔ FINITE s
   
   [<a name="FINITE_PREIMAGE-val"><b>FINITE_PREIMAGE</b></a>]  Theorem
      
      ⊢ (∀x y. f x = f y ⇔ x = y) ∧ FINITE s ⇒ FINITE (PREIMAGE f s)
   
   [<a name="FINITE_PRODUCT-val"><b>FINITE_PRODUCT</b></a>]  Theorem
      
      ⊢ ∀s t. FINITE s ∧ FINITE t ⇒ FINITE {(x,y) | x ∈ s ∧ y ∈ t}
   
   [<a name="FINITE_PRODUCT_DEPENDENT-val"><b>FINITE_PRODUCT_DEPENDENT</b></a>]  Theorem
      
      ⊢ ∀f s t.
          FINITE s ∧ (∀x. x ∈ s ⇒ FINITE (t x)) ⇒
          FINITE {f x y | x ∈ s ∧ y ∈ t x}
   
   [<a name="FINITE_PSUBSET_INFINITE-val"><b>FINITE_PSUBSET_INFINITE</b></a>]  Theorem
      
      ⊢ ∀s. INFINITE s ⇔ ∀t. FINITE t ⇒ t ⊆ s ⇒ t ⊂ s
   
   [<a name="FINITE_PSUBSET_UNIV-val"><b>FINITE_PSUBSET_UNIV</b></a>]  Theorem
      
      ⊢ INFINITE 𝕌(:α) ⇔ ∀s. FINITE s ⇒ s ⊂ 𝕌(:α)
   
   [<a name="FINITE_REST-val"><b>FINITE_REST</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ FINITE (REST s)
   
   [<a name="FINITE_REST_EQ-val"><b>FINITE_REST_EQ</b></a>]  Theorem
      
      ⊢ ∀s. FINITE (REST s) ⇔ FINITE s
   
   [<a name="FINITE_RULES-val"><b>FINITE_RULES</b></a>]  Theorem
      
      ⊢ FINITE ∅ ∧ ∀s. FINITE s ⇒ ∀x. FINITE (x INSERT s)
   
   [<a name="FINITE_SING-val"><b>FINITE_SING</b></a>]  Theorem
      
      ⊢ ∀x. FINITE {x}
   
   [<a name="FINITE_SURJ-val"><b>FINITE_SURJ</b></a>]  Theorem
      
      ⊢ FINITE s ∧ SURJ f s t ⇒ FINITE t
   
   [<a name="FINITE_SURJ_BIJ-val"><b>FINITE_SURJ_BIJ</b></a>]  Theorem
      
      ⊢ FINITE s ∧ SURJ f s t ∧ CARD t = CARD s ⇒ BIJ f s t
   
   [<a name="FINITE_StrongOrder_WF-val"><b>FINITE_StrongOrder_WF</b></a>]  Theorem
      
      ⊢ ∀R s.
          FINITE s ∧ StrongOrder (REL_RESTRICT R s) ⇒ WF (REL_RESTRICT R s)
   
   [<a name="FINITE_UNION-val"><b>FINITE_UNION</b></a>]  Theorem
      
      ⊢ ∀s t. FINITE (s ∪ t) ⇔ FINITE s ∧ FINITE t
   
   [<a name="FINITE_WEAK_ENUMERATE-val"><b>FINITE_WEAK_ENUMERATE</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇔ ∃f b. ∀e. e ∈ s ⇔ ∃n. n &lt; b ∧ e = f n
   
   [<a name="FINITE_WF_noloops-val"><b>FINITE_WF_noloops</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒
            (WF (REL_RESTRICT R s) ⇔ irreflexive (REL_RESTRICT R s)⁺)
   
   [<a name="FINITE_is_measure_maximal-val"><b>FINITE_is_measure_maximal</b></a>]  Theorem
      
      ⊢ ∀m s. FINITE s ∧ s ≠ ∅ ⇒ ∃x. is_measure_maximal m s x
   
   [<a name="FINITE_partition-val"><b>FINITE_partition</b></a>]  Theorem
      
      ⊢ ∀R s.
          FINITE s ⇒
          FINITE (partition R s) ∧ ∀t. t ∈ partition R s ⇒ FINITE t
   
   [<a name="FINITE_partitions-val"><b>FINITE_partitions</b></a>]  Theorem
      
      ⊢ ∀x. FINITE x ⇒ FINITE {v | v partitions x}
   
   [<a name="FORALL_IN_BIGUNION-val"><b>FORALL_IN_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀P s. (∀x. x ∈ BIGUNION s ⇒ P x) ⇔ ∀t x. t ∈ s ∧ x ∈ t ⇒ P x
   
   [<a name="FORALL_IN_IMAGE-val"><b>FORALL_IN_IMAGE</b></a>]  Theorem
      
      ⊢ ∀P f s. (∀y. y ∈ IMAGE f s ⇒ P y) ⇔ ∀x. x ∈ s ⇒ P (f x)
   
   [<a name="FORALL_IN_INSERT-val"><b>FORALL_IN_INSERT</b></a>]  Theorem
      
      ⊢ ∀P a s. (∀x. x ∈ a INSERT s ⇒ P x) ⇔ P a ∧ ∀x. x ∈ s ⇒ P x
   
   [<a name="FORALL_IN_UNION-val"><b>FORALL_IN_UNION</b></a>]  Theorem
      
      ⊢ ∀P s t. (∀x. x ∈ s ∪ t ⇒ P x) ⇔ (∀x. x ∈ s ⇒ P x) ∧ ∀x. x ∈ t ⇒ P x
   
   [<a name="FUNPOW_INJ-val"><b>FUNPOW_INJ</b></a>]  Theorem
      
      ⊢ INJ f 𝕌(:α) 𝕌(:α) ⇒ INJ (FUNPOW f n) 𝕌(:α) 𝕌(:α)
   
   [<a name="FUNPOW_eq_elim-val"><b>FUNPOW_eq_elim</b></a>]  Theorem
      
      ⊢ INJ f 𝕌(:α) 𝕌(:α) ⇒ (FUNPOW f n t = FUNPOW f n t' ⇔ t = t')
   
   [<a name="FUNPOW_min_cancel-val"><b>FUNPOW_min_cancel</b></a>]  Theorem
      
      ⊢ n ≤ n' ∧ INJ f 𝕌(:α) 𝕌(:α) ⇒
        (FUNPOW f n X = FUNPOW f n' X' ⇔ X = FUNPOW f (n' − n) X')
   
   [<a name="FUNSET_DFUNSET-val"><b>FUNSET_DFUNSET</b></a>]  Theorem
      
      ⊢ ∀x y. FUNSET x y = DFUNSET x (K y)
   
   [<a name="FUNSET_EMPTY-val"><b>FUNSET_EMPTY</b></a>]  Theorem
      
      ⊢ ∀s f. f ∈ FUNSET s ∅ ⇔ s = ∅
   
   [<a name="FUNSET_INTER-val"><b>FUNSET_INTER</b></a>]  Theorem
      
      ⊢ ∀a b c. FUNSET a (b ∩ c) = FUNSET a b ∩ FUNSET a c
   
   [<a name="FUNSET_THM-val"><b>FUNSET_THM</b></a>]  Theorem
      
      ⊢ ∀s t f x. f ∈ FUNSET s t ∧ x ∈ s ⇒ f x ∈ t
   
   [<a name="FUNSET_applied-val"><b>FUNSET_applied</b></a>]  Theorem
      
      ⊢ ∀f P Q. FUNSET P Q f ⇔ ∀x. x ∈ P ⇒ f x ∈ Q
   
   [<a name="GSPECIFICATION_applied-val"><b>GSPECIFICATION_applied</b></a>]  Theorem
      
      ⊢ ∀f v. GSPEC f v ⇔ ∃x. (v,T) = f x
   
   [<a name="GSPEC_AND-val"><b>GSPEC_AND</b></a>]  Theorem
      
      ⊢ ∀P Q. {x | P x ∧ Q x} = {x | P x} ∩ {x | Q x}
   
   [<a name="GSPEC_EQ-val"><b>GSPEC_EQ</b></a>]  Theorem
      
      ⊢ {x | x = y} = {y}
   
   [<a name="GSPEC_EQ2-val"><b>GSPEC_EQ2</b></a>]  Theorem
      
      ⊢ {x | y = x} = {y}
   
   [<a name="GSPEC_ETA-val"><b>GSPEC_ETA</b></a>]  Theorem
      
      ⊢ {x | P x} = P
   
   [<a name="GSPEC_F-val"><b>GSPEC_F</b></a>]  Theorem
      
      ⊢ {x | F} = ∅
   
   [<a name="GSPEC_F_COND-val"><b>GSPEC_F_COND</b></a>]  Theorem
      
      ⊢ ∀f. (∀x. ¬SND (f x)) ⇒ GSPEC f = ∅
   
   [<a name="GSPEC_ID-val"><b>GSPEC_ID</b></a>]  Theorem
      
      ⊢ {x | x ∈ y} = y
   
   [<a name="GSPEC_IMAGE-val"><b>GSPEC_IMAGE</b></a>]  Theorem
      
      ⊢ GSPEC f = IMAGE (FST ∘ f) (SND ∘ f)
   
   [<a name="GSPEC_OR-val"><b>GSPEC_OR</b></a>]  Theorem
      
      ⊢ ∀P Q. {x | P x ∨ Q x} = {x | P x} ∪ {x | Q x}
   
   [<a name="GSPEC_PAIR_ETA-val"><b>GSPEC_PAIR_ETA</b></a>]  Theorem
      
      ⊢ {(x,y) | P x y} = UNCURRY P
   
   [<a name="GSPEC_T-val"><b>GSPEC_T</b></a>]  Theorem
      
      ⊢ {x | T} = 𝕌(:α)
   
   [<a name="HAS_SIZE_0-val"><b>HAS_SIZE_0</b></a>]  Theorem
      
      ⊢ ∀s. s HAS_SIZE 0 ⇔ s = ∅
   
   [<a name="HAS_SIZE_CARD-val"><b>HAS_SIZE_CARD</b></a>]  Theorem
      
      ⊢ ∀s n. s HAS_SIZE n ⇒ CARD s = n
   
   [<a name="HAS_SIZE_IMAGE_INJ-val"><b>HAS_SIZE_IMAGE_INJ</b></a>]  Theorem
      
      ⊢ ∀f s n.
          (∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y) ∧ s HAS_SIZE n ⇒
          IMAGE f s HAS_SIZE n
   
   [<a name="HAS_SIZE_INDEX-val"><b>HAS_SIZE_INDEX</b></a>]  Theorem
      
      ⊢ ∀s n.
          s HAS_SIZE n ⇒
          ∃f. (∀m. m &lt; n ⇒ f m ∈ s) ∧ ∀x. x ∈ s ⇒ ∃!m. m &lt; n ∧ f m = x
   
   [<a name="HAS_SIZE_PRODUCT-val"><b>HAS_SIZE_PRODUCT</b></a>]  Theorem
      
      ⊢ ∀s m t n.
          s HAS_SIZE m ∧ t HAS_SIZE n ⇒
          {(x,y) | x ∈ s ∧ y ∈ t} HAS_SIZE m * n
   
   [<a name="HAS_SIZE_PRODUCT_DEPENDENT-val"><b>HAS_SIZE_PRODUCT_DEPENDENT</b></a>]  Theorem
      
      ⊢ ∀s m t n.
          s HAS_SIZE m ∧ (∀x. x ∈ s ⇒ t x HAS_SIZE n) ⇒
          {(x,y) | x ∈ s ∧ y ∈ t x} HAS_SIZE m * n
   
   [<a name="HAS_SIZE_SUC-val"><b>HAS_SIZE_SUC</b></a>]  Theorem
      
      ⊢ ∀s n. s HAS_SIZE SUC n ⇔ s ≠ ∅ ∧ ∀a. a ∈ s ⇒ s DELETE a HAS_SIZE n
   
   [<a name="HAS_SIZE_UNION-val"><b>HAS_SIZE_UNION</b></a>]  Theorem
      
      ⊢ ∀s t m n.
          s HAS_SIZE m ∧ t HAS_SIZE n ∧ DISJOINT s t ⇒ s ∪ t HAS_SIZE m + n
   
   [<a name="IMAGE_11-val"><b>IMAGE_11</b></a>]  Theorem
      
      ⊢ (∀x y. f x = f y ⇔ x = y) ⇒ (IMAGE f s1 = IMAGE f s2 ⇔ s1 = s2)
   
   [<a name="IMAGE_11_INFINITE-val"><b>IMAGE_11_INFINITE</b></a>]  Theorem
      
      ⊢ ∀f. (∀x y. f x = f y ⇒ x = y) ⇒
            ∀s. INFINITE s ⇒ INFINITE (IMAGE f s)
   
   [<a name="IMAGE_BIGUNION-val"><b>IMAGE_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀f M. IMAGE f (BIGUNION M) = BIGUNION (IMAGE (IMAGE f) M)
   
   [<a name="IMAGE_CLAUSES-val"><b>IMAGE_CLAUSES</b></a>]  Theorem
      
      ⊢ (∀f. IMAGE f ∅ = ∅) ∧
        ∀f x s. IMAGE f (x INSERT s) = f x INSERT IMAGE f s
   
   [<a name="IMAGE_COMPOSE-val"><b>IMAGE_COMPOSE</b></a>]  Theorem
      
      ⊢ ∀f g s. IMAGE (f ∘ g) s = IMAGE f (IMAGE g s)
   
   [<a name="IMAGE_CONG-val"><b>IMAGE_CONG</b></a>]  Theorem
      
      ⊢ ∀f s f' s'.
          s = s' ∧ (∀x. x ∈ s' ⇒ f x = f' x) ⇒ IMAGE f s = IMAGE f' s'
   
   [<a name="IMAGE_CONST-val"><b>IMAGE_CONST</b></a>]  Theorem
      
      ⊢ ∀s c. IMAGE (λx. c) s = if s = ∅ then ∅ else {c}
   
   [<a name="IMAGE_DELETE-val"><b>IMAGE_DELETE</b></a>]  Theorem
      
      ⊢ ∀f x s. x ∉ s ⇒ IMAGE f (s DELETE x) = IMAGE f s
   
   [<a name="IMAGE_EMPTY-val"><b>IMAGE_EMPTY</b></a>]  Theorem
      
      ⊢ ∀f. IMAGE f ∅ = ∅
   
   [<a name="IMAGE_EQ_EMPTY-val"><b>IMAGE_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ ∀s f. (IMAGE f s = ∅ ⇔ s = ∅) ∧ (∅ = IMAGE f s ⇔ s = ∅)
   
   [<a name="IMAGE_EQ_SING-val"><b>IMAGE_EQ_SING</b></a>]  Theorem
      
      ⊢ IMAGE f s = {z} ⇔ s ≠ ∅ ∧ ∀x. x ∈ s ⇒ f x = z
   
   [<a name="IMAGE_FINITE-val"><b>IMAGE_FINITE</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀f. FINITE (IMAGE f s)
   
   [<a name="IMAGE_FST_CROSS-val"><b>IMAGE_FST_CROSS</b></a>]  Theorem
      
      ⊢ ∀s t. t ≠ ∅ ⇒ IMAGE FST (s × t) = s
   
   [<a name="IMAGE_I-val"><b>IMAGE_I</b></a>]  Theorem
      
      ⊢ IMAGE I s = s
   
   [<a name="IMAGE_ID-val"><b>IMAGE_ID</b></a>]  Theorem
      
      ⊢ ∀s. IMAGE (λx. x) s = s
   
   [<a name="IMAGE_II-val"><b>IMAGE_II</b></a>]  Theorem
      
      ⊢ IMAGE I = I
   
   [<a name="IMAGE_IMAGE-val"><b>IMAGE_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f g s. IMAGE f (IMAGE g s) = IMAGE (f ∘ g) s
   
   [<a name="IMAGE_IMAGE_partition-val"><b>IMAGE_IMAGE_partition</b></a>]  Theorem
      
      ⊢ ∀R f s t.
          INJ f s t ⇒
          IMAGE (IMAGE f) (partition R s) =
          partition (inv_image R (LINV f s)) (IMAGE f s)
   
   [<a name="IMAGE_IN-val"><b>IMAGE_IN</b></a>]  Theorem
      
      ⊢ ∀x s. x ∈ s ⇒ ∀f. f x ∈ IMAGE f s
   
   [<a name="IMAGE_INSERT-val"><b>IMAGE_INSERT</b></a>]  Theorem
      
      ⊢ ∀f x s. IMAGE f (x INSERT s) = f x INSERT IMAGE f s
   
   [<a name="IMAGE_INTER-val"><b>IMAGE_INTER</b></a>]  Theorem
      
      ⊢ ∀f s t. IMAGE f (s ∩ t) ⊆ IMAGE f s ∩ IMAGE f t
   
   [<a name="IMAGE_PREIMAGE-val"><b>IMAGE_PREIMAGE</b></a>]  Theorem
      
      ⊢ ∀f s. IMAGE f (PREIMAGE f s) ⊆ s
   
   [<a name="IMAGE_RESTRICTION-val"><b>IMAGE_RESTRICTION</b></a>]  Theorem
      
      ⊢ ∀f s t. s ⊆ t ⇒ IMAGE (RESTRICTION t f) s = IMAGE f s
   
   [<a name="IMAGE_SING-val"><b>IMAGE_SING</b></a>]  Theorem
      
      ⊢ ∀f x. IMAGE f {x} = {f x}
   
   [<a name="IMAGE_SND_CROSS-val"><b>IMAGE_SND_CROSS</b></a>]  Theorem
      
      ⊢ ∀s t. s ≠ ∅ ⇒ IMAGE SND (s × t) = t
   
   [<a name="IMAGE_SUBSET-val"><b>IMAGE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t. s ⊆ t ⇒ ∀f. IMAGE f s ⊆ IMAGE f t
   
   [<a name="IMAGE_SUBSET_gen-val"><b>IMAGE_SUBSET_gen</b></a>]  Theorem
      
      ⊢ ∀f s u t. s ⊆ u ∧ IMAGE f u ⊆ t ⇒ IMAGE f s ⊆ t
   
   [<a name="IMAGE_SURJ-val"><b>IMAGE_SURJ</b></a>]  Theorem
      
      ⊢ ∀f s t. SURJ f s t ⇔ IMAGE f s = t
   
   [<a name="IMAGE_UNION-val"><b>IMAGE_UNION</b></a>]  Theorem
      
      ⊢ ∀f s t. IMAGE f (s ∪ t) = IMAGE f s ∪ IMAGE f t
   
   [<a name="IMAGE_applied-val"><b>IMAGE_applied</b></a>]  Theorem
      
      ⊢ ∀y s f. IMAGE f s y ⇔ ∃x. y = f x ∧ x ∈ s
   
   [<a name="IMAGE_o-val"><b>IMAGE_o</b></a>]  Theorem
      
      ⊢ ∀f g s. IMAGE (f ∘ g) s = IMAGE f (IMAGE g s)
   
   [<a name="INFINITE_DIFF_FINITE-val"><b>INFINITE_DIFF_FINITE</b></a>]  Theorem
      
      ⊢ ∀s t. INFINITE s ∧ FINITE t ⇒ s DIFF t ≠ ∅
   
   [<a name="INFINITE_DIFF_FINITE'-val"><b>INFINITE_DIFF_FINITE'</b></a>]  Theorem
      
      ⊢ ∀s t. INFINITE s ∧ FINITE t ⇒ INFINITE (s DIFF t)
   
   [<a name="INFINITE_EXPLICIT_ENUMERATE-val"><b>INFINITE_EXPLICIT_ENUMERATE</b></a>]  Theorem
      
      ⊢ ∀s. INFINITE s ⇒ INJ (λn. CHOICE (FUNPOW REST n s)) 𝕌(:num) s
   
   [<a name="INFINITE_INHAB-val"><b>INFINITE_INHAB</b></a>]  Theorem
      
      ⊢ ∀P. INFINITE P ⇒ ∃x. x ∈ P
   
   [<a name="INFINITE_INJ-val"><b>INFINITE_INJ</b></a>]  Theorem
      
      ⊢ ∀f s t. INJ f s t ∧ INFINITE s ⇒ INFINITE t
   
   [<a name="INFINITE_INJ_NOT_SURJ-val"><b>INFINITE_INJ_NOT_SURJ</b></a>]  Theorem
      
      ⊢ ∀s. INFINITE s ⇔ ∃f. INJ f s s ∧ ¬SURJ f s s
   
   [<a name="INFINITE_NUM_UNIV-val"><b>INFINITE_NUM_UNIV</b></a>]  Theorem
      
      ⊢ INFINITE 𝕌(:num)
   
   [<a name="INFINITE_PAIR_UNIV-val"><b>INFINITE_PAIR_UNIV</b></a>]  Theorem
      
      ⊢ FINITE 𝕌(:α # β) ⇔ FINITE 𝕌(:α) ∧ FINITE 𝕌(:β)
   
   [<a name="INFINITE_SUBSET-val"><b>INFINITE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s. INFINITE s ⇒ ∀t. s ⊆ t ⇒ INFINITE t
   
   [<a name="INFINITE_UNIV-val"><b>INFINITE_UNIV</b></a>]  Theorem
      
      ⊢ INFINITE 𝕌(:α) ⇔ ∃f. (∀x y. f x = f y ⇒ x = y) ∧ ∃y. ∀x. f x ≠ y
   
   [<a name="INJECTIVE_IMAGE_FINITE-val"><b>INJECTIVE_IMAGE_FINITE</b></a>]  Theorem
      
      ⊢ ∀f. (∀x y. f x = f y ⇔ x = y) ⇒ ∀s. FINITE (IMAGE f s) ⇔ FINITE s
   
   [<a name="INJ_BIJ_SUBSET-val"><b>INJ_BIJ_SUBSET</b></a>]  Theorem
      
      ⊢ s0 ⊆ s ∧ INJ f s t ⇒ BIJ f s0 (IMAGE f s0)
   
   [<a name="INJ_CARD-val"><b>INJ_CARD</b></a>]  Theorem
      
      ⊢ ∀f s t. INJ f s t ∧ FINITE t ⇒ CARD s ≤ CARD t
   
   [<a name="INJ_CARD_IMAGE-val"><b>INJ_CARD_IMAGE</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ INJ f s t ⇒ CARD (IMAGE f s) = CARD s
   
   [<a name="INJ_CARD_IMAGE_EQ-val"><b>INJ_CARD_IMAGE_EQ</b></a>]  Theorem
      
      ⊢ INJ f s t ⇒ FINITE s ⇒ CARD (IMAGE f s) = CARD s
   
   [<a name="INJ_COMPOSE-val"><b>INJ_COMPOSE</b></a>]  Theorem
      
      ⊢ ∀f g s t u. INJ f s t ∧ INJ g t u ⇒ INJ (g ∘ f) s u
   
   [<a name="INJ_CONG-val"><b>INJ_CONG</b></a>]  Theorem
      
      ⊢ ∀f g s t. (∀x. x ∈ s ⇒ f x = g x) ⇒ (INJ f s t ⇔ INJ g s t)
   
   [<a name="INJ_DELETE-val"><b>INJ_DELETE</b></a>]  Theorem
      
      ⊢ ∀f s t. INJ f s t ⇒ ∀e. e ∈ s ⇒ INJ f (s DELETE e) (t DELETE f e)
   
   [<a name="INJ_ELEMENT-val"><b>INJ_ELEMENT</b></a>]  Theorem
      
      ⊢ ∀f s t x. INJ f s t ∧ x ∈ s ⇒ f x ∈ t
   
   [<a name="INJ_EMPTY-val"><b>INJ_EMPTY</b></a>]  Theorem
      
      ⊢ ∀f. (∀s. INJ f ∅ s) ∧ ∀s. INJ f s ∅ ⇔ s = ∅
   
   [<a name="INJ_EQ_11-val"><b>INJ_EQ_11</b></a>]  Theorem
      
      ⊢ ∀f s x y. INJ f s s ∧ x ∈ s ∧ y ∈ s ⇒ (f x = f y ⇔ x = y)
   
   [<a name="INJ_EXTEND-val"><b>INJ_EXTEND</b></a>]  Theorem
      
      ⊢ ∀b s t x y.
          INJ b s t ∧ x ∉ s ∧ y ∉ t ⇒
          INJ b⦇x ↦ y⦈ (x INSERT s) (y INSERT t)
   
   [<a name="INJ_I-val"><b>INJ_I</b></a>]  Theorem
      
      ⊢ ∀s. INJ I s 𝕌(:α)
   
   [<a name="INJ_ID-val"><b>INJ_ID</b></a>]  Theorem
      
      ⊢ ∀s. INJ (λx. x) s s
   
   [<a name="INJ_IFF-val"><b>INJ_IFF</b></a>]  Theorem
      
      ⊢ INJ f s t ⇔
        (∀x. x ∈ s ⇒ f x ∈ t) ∧ ∀x y. x ∈ s ∧ y ∈ s ⇒ (f x = f y ⇔ x = y)
   
   [<a name="INJ_IMAGE-val"><b>INJ_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s t. INJ f s t ⇒ INJ f s (IMAGE f s)
   
   [<a name="INJ_IMAGE_BIJ-val"><b>INJ_IMAGE_BIJ</b></a>]  Theorem
      
      ⊢ ∀s f. (∃t. INJ f s t) ⇒ BIJ f s (IMAGE f s)
   
   [<a name="INJ_IMAGE_DISJOINT-val"><b>INJ_IMAGE_DISJOINT</b></a>]  Theorem
      
      ⊢ ∀P f.
          INJ f P 𝕌(:β) ⇒
          ∀s t.
            s ⊆ P ∧ t ⊆ P ⇒
            (DISJOINT s t ⇔ DISJOINT (IMAGE f s) (IMAGE f t))
   
   [<a name="INJ_IMAGE_EQ-val"><b>INJ_IMAGE_EQ</b></a>]  Theorem
      
      ⊢ ∀P f.
          INJ f P 𝕌(:β) ⇒
          ∀s t. s ⊆ P ∧ t ⊆ P ⇒ (IMAGE f s = IMAGE f t ⇔ s = t)
   
   [<a name="INJ_IMAGE_INTER-val"><b>INJ_IMAGE_INTER</b></a>]  Theorem
      
      ⊢ ∀P f.
          INJ f P 𝕌(:β) ⇒
          ∀s t. s ⊆ P ∧ t ⊆ P ⇒ IMAGE f (s ∩ t) = IMAGE f s ∩ IMAGE f t
   
   [<a name="INJ_IMAGE_SUBSET-val"><b>INJ_IMAGE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀f s t. INJ f s t ⇒ IMAGE f s ⊆ t
   
   [<a name="INJ_IMAGE_equiv_class-val"><b>INJ_IMAGE_equiv_class</b></a>]  Theorem
      
      ⊢ ∀f s t x.
          INJ f s t ∧ x ∈ s ⇒
          IMAGE f (equiv_class R s x) =
          equiv_class (inv_image R (LINV f s)) (IMAGE f s) (f x)
   
   [<a name="INJ_IMP_11-val"><b>INJ_IMP_11</b></a>]  Theorem
      
      ⊢ ∀f. INJ f 𝕌(:α) 𝕌(:β) ⇒ ∀x y. f x = f y ⇔ x = y
   
   [<a name="INJ_INL-val"><b>INJ_INL</b></a>]  Theorem
      
      ⊢ (∀x. x ∈ s ⇒ INL x ∈ t) ⇒ INJ INL s t
   
   [<a name="INJ_INR-val"><b>INJ_INR</b></a>]  Theorem
      
      ⊢ (∀x. x ∈ s ⇒ INR x ∈ t) ⇒ INJ INR s t
   
   [<a name="INJ_INSERT-val"><b>INJ_INSERT</b></a>]  Theorem
      
      ⊢ ∀f x s t.
          INJ f (x INSERT s) t ⇔
          INJ f s t ∧ f x ∈ t ∧ ∀y. y ∈ s ∧ f x = f y ⇒ x = y
   
   [<a name="INJ_I_IMAGE-val"><b>INJ_I_IMAGE</b></a>]  Theorem
      
      ⊢ ∀s f. INJ I (IMAGE f s) 𝕌(:β)
   
   [<a name="INJ_LINV_OPT-val"><b>INJ_LINV_OPT</b></a>]  Theorem
      
      ⊢ INJ f s t ⇒ ∀x y. LINV_OPT f s y = SOME x ⇔ y = f x ∧ x ∈ s ∧ y ∈ t
   
   [<a name="INJ_LINV_OPT_IMAGE-val"><b>INJ_LINV_OPT_IMAGE</b></a>]  Theorem
      
      ⊢ INJ (LINV_OPT f s) (IMAGE f s) (IMAGE SOME s)
   
   [<a name="INJ_SUBSET-val"><b>INJ_SUBSET</b></a>]  Theorem
      
      ⊢ ∀f s t s0 t0. INJ f s t ∧ s0 ⊆ s ∧ t ⊆ t0 ⇒ INJ f s0 t0
   
   [<a name="INJ_SUBSET_UNIV-val"><b>INJ_SUBSET_UNIV</b></a>]  Theorem
      
      ⊢ ∀f s. INJ f 𝕌(:α) 𝕌(:β) ⇒ INJ f s 𝕌(:β)
   
   [<a name="INSERT_COMM-val"><b>INSERT_COMM</b></a>]  Theorem
      
      ⊢ ∀x y s. x INSERT y INSERT s = y INSERT x INSERT s
   
   [<a name="INSERT_DELETE-val"><b>INSERT_DELETE</b></a>]  Theorem
      
      ⊢ ∀x s. x ∈ s ⇒ x INSERT s DELETE x = s
   
   [<a name="INSERT_DIFF-val"><b>INSERT_DIFF</b></a>]  Theorem
      
      ⊢ ∀s t x.
          (x INSERT s) DIFF t =
          if x ∈ t then s DIFF t else x INSERT s DIFF t
   
   [<a name="INSERT_EQ_SING-val"><b>INSERT_EQ_SING</b></a>]  Theorem
      
      ⊢ ∀s x y. x INSERT s = {y} ⇔ x = y ∧ s ⊆ {y}
   
   [<a name="INSERT_INSERT-val"><b>INSERT_INSERT</b></a>]  Theorem
      
      ⊢ ∀x s. x INSERT x INSERT s = x INSERT s
   
   [<a name="INSERT_INTER-val"><b>INSERT_INTER</b></a>]  Theorem
      
      ⊢ ∀x s t. (x INSERT s) ∩ t = if x ∈ t then x INSERT s ∩ t else s ∩ t
   
   [<a name="INSERT_SING_UNION-val"><b>INSERT_SING_UNION</b></a>]  Theorem
      
      ⊢ ∀s x. x INSERT s = {x} ∪ s
   
   [<a name="INSERT_SUBSET-val"><b>INSERT_SUBSET</b></a>]  Theorem
      
      ⊢ ∀x s t. x INSERT s ⊆ t ⇔ x ∈ t ∧ s ⊆ t
   
   [<a name="INSERT_UNION-val"><b>INSERT_UNION</b></a>]  Theorem
      
      ⊢ ∀x s t. (x INSERT s) ∪ t = if x ∈ t then s ∪ t else x INSERT s ∪ t
   
   [<a name="INSERT_UNION_EQ-val"><b>INSERT_UNION_EQ</b></a>]  Theorem
      
      ⊢ ∀x s t. (x INSERT s) ∪ t = x INSERT s ∪ t
   
   [<a name="INSERT_UNIV-val"><b>INSERT_UNIV</b></a>]  Theorem
      
      ⊢ ∀x. x INSERT 𝕌(:α) = 𝕌(:α)
   
   [<a name="INSERT_applied-val"><b>INSERT_applied</b></a>]  Theorem
      
      ⊢ ∀x y s. (y INSERT s) x ⇔ x = y ∨ x ∈ s
   
   [<a name="INTER_ASSOC-val"><b>INTER_ASSOC</b></a>]  Theorem
      
      ⊢ ∀s t u. s ∩ (t ∩ u) = s ∩ t ∩ u
   
   [<a name="INTER_BIGUNION-val"><b>INTER_BIGUNION</b></a>]  Theorem
      
      ⊢ (∀s t. BIGUNION s ∩ t = BIGUNION {x ∩ t | x ∈ s}) ∧
        ∀s t. t ∩ BIGUNION s = BIGUNION {t ∩ x | x ∈ s}
   
   [<a name="INTER_COMM-val"><b>INTER_COMM</b></a>]  Theorem
      
      ⊢ ∀s t. s ∩ t = t ∩ s
   
   [<a name="INTER_CROSS-val"><b>INTER_CROSS</b></a>]  Theorem
      
      ⊢ ∀A B C D. A × B ∩ C × D = (A ∩ C) × (B ∩ D)
   
   [<a name="INTER_EMPTY-val"><b>INTER_EMPTY</b></a>]  Theorem
      
      ⊢ (∀s. ∅ ∩ s = ∅) ∧ ∀s. s ∩ ∅ = ∅
   
   [<a name="INTER_FINITE-val"><b>INTER_FINITE</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀t. FINITE (s ∩ t)
   
   [<a name="INTER_IDEMPOT-val"><b>INTER_IDEMPOT</b></a>]  Theorem
      
      ⊢ ∀s. s ∩ s = s
   
   [<a name="INTER_OVER_UNION-val"><b>INTER_OVER_UNION</b></a>]  Theorem
      
      ⊢ ∀s t u. s ∪ t ∩ u = (s ∪ t) ∩ (s ∪ u)
   
   [<a name="INTER_SING-val"><b>INTER_SING</b></a>]  Theorem
      
      ⊢ ∀s x. x ∈ s ⇒ s ∩ {x} = {x}
   
   [<a name="INTER_SUBSET-val"><b>INTER_SUBSET</b></a>]  Theorem
      
      ⊢ (∀s t. s ∩ t ⊆ s) ∧ ∀s t. t ∩ s ⊆ s
   
   [<a name="INTER_SUBSET_EQN-val"><b>INTER_SUBSET_EQN</b></a>]  Theorem
      
      ⊢ (A ∩ B = A ⇔ A ⊆ B) ∧ (A ∩ B = B ⇔ B ⊆ A)
   
   [<a name="INTER_UNION-val"><b>INTER_UNION</b></a>]  Theorem
      
      ⊢ (A ∪ B) ∩ A = A ∧ (B ∪ A) ∩ A = A ∧ A ∩ (A ∪ B) = A ∧
        A ∩ (B ∪ A) = A
   
   [<a name="INTER_UNION_COMPL-val"><b>INTER_UNION_COMPL</b></a>]  Theorem
      
      ⊢ ∀s t. s ∩ t = COMPL (COMPL s ∪ COMPL t)
   
   [<a name="INTER_UNIV-val"><b>INTER_UNIV</b></a>]  Theorem
      
      ⊢ (∀s. 𝕌(:α) ∩ s = s) ∧ ∀s. s ∩ 𝕌(:α) = s
   
   [<a name="INTER_applied-val"><b>INTER_applied</b></a>]  Theorem
      
      ⊢ ∀s t x. (s ∩ t) x ⇔ x ∈ s ∧ x ∈ t
   
   [<a name="IN_ABS-val"><b>IN_ABS</b></a>]  Theorem
      
      ⊢ ∀x P. x ∈ (λx. P x) ⇔ P x
   
   [<a name="IN_APP-val"><b>IN_APP</b></a>]  Theorem
      
      ⊢ ∀x P. x ∈ P ⇔ P x
   
   [<a name="IN_BIGINTER-val"><b>IN_BIGINTER</b></a>]  Theorem
      
      ⊢ x ∈ BIGINTER B ⇔ ∀P. P ∈ B ⇒ x ∈ P
   
   [<a name="IN_BIGINTER_IMAGE-val"><b>IN_BIGINTER_IMAGE</b></a>]  Theorem
      
      ⊢ ∀x f s. x ∈ BIGINTER (IMAGE f s) ⇔ ∀y. y ∈ s ⇒ x ∈ f y
   
   [<a name="IN_BIGUNION-val"><b>IN_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀x sos. x ∈ BIGUNION sos ⇔ ∃s. x ∈ s ∧ s ∈ sos
   
   [<a name="IN_BIGUNION_IMAGE-val"><b>IN_BIGUNION_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s y. y ∈ BIGUNION (IMAGE f s) ⇔ ∃x. x ∈ s ∧ y ∈ f x
   
   [<a name="IN_COMPL-val"><b>IN_COMPL</b></a>]  Theorem
      
      ⊢ ∀x s. x ∈ COMPL s ⇔ x ∉ s
   
   [<a name="IN_COUNT-val"><b>IN_COUNT</b></a>]  Theorem
      
      ⊢ ∀m n. m ∈ count n ⇔ m &lt; n
   
   [<a name="IN_CROSS-val"><b>IN_CROSS</b></a>]  Theorem
      
      ⊢ ∀P Q x. x ∈ P × Q ⇔ FST x ∈ P ∧ SND x ∈ Q
   
   [<a name="IN_DELETE-val"><b>IN_DELETE</b></a>]  Theorem
      
      ⊢ ∀s x y. x ∈ s DELETE y ⇔ x ∈ s ∧ x ≠ y
   
   [<a name="IN_DELETE_EQ-val"><b>IN_DELETE_EQ</b></a>]  Theorem
      
      ⊢ ∀s x x'. (x ∈ s ⇔ x' ∈ s) ⇔ (x ∈ s DELETE x' ⇔ x' ∈ s DELETE x)
   
   [<a name="IN_DFUNSET-val"><b>IN_DFUNSET</b></a>]  Theorem
      
      ⊢ ∀f P Q. f ∈ DFUNSET P Q ⇔ ∀x. x ∈ P ⇒ f x ∈ Q x
   
   [<a name="IN_DIFF-val"><b>IN_DIFF</b></a>]  Theorem
      
      ⊢ ∀s t x. x ∈ s DIFF t ⇔ x ∈ s ∧ x ∉ t
   
   [<a name="IN_DISJOINT-val"><b>IN_DISJOINT</b></a>]  Theorem
      
      ⊢ ∀s t. DISJOINT s t ⇔ ¬∃x. x ∈ s ∧ x ∈ t
   
   [<a name="IN_EQ_UNIV_IMP-val"><b>IN_EQ_UNIV_IMP</b></a>]  Theorem
      
      ⊢ ∀s. s = 𝕌(:α) ⇒ ∀v. v ∈ s
   
   [<a name="IN_FUNSET-val"><b>IN_FUNSET</b></a>]  Theorem
      
      ⊢ ∀f P Q. f ∈ FUNSET P Q ⇔ ∀x. x ∈ P ⇒ f x ∈ Q
   
   [<a name="IN_GSPEC-val"><b>IN_GSPEC</b></a>]  Theorem
      
      ⊢ ∀y x P. P y ∧ x = f y ⇒ x ∈ {f x | P x}
   
   [<a name="IN_GSPEC_IFF-val"><b>IN_GSPEC_IFF</b></a>]  Theorem
      
      ⊢ y ∈ {x | P x} ⇔ P y
   
   [<a name="IN_IMAGE-val"><b>IN_IMAGE</b></a>]  Theorem
      
      ⊢ ∀y s f. y ∈ IMAGE f s ⇔ ∃x. y = f x ∧ x ∈ s
   
   [<a name="IN_INFINITE_NOT_FINITE-val"><b>IN_INFINITE_NOT_FINITE</b></a>]  Theorem
      
      ⊢ ∀s t. INFINITE s ∧ FINITE t ⇒ ∃x. x ∈ s ∧ x ∉ t
   
   [<a name="IN_INSERT-val"><b>IN_INSERT</b></a>]  Theorem
      
      ⊢ ∀x y s. x ∈ y INSERT s ⇔ x = y ∨ x ∈ s
   
   [<a name="IN_INSERT_EXPAND-val"><b>IN_INSERT_EXPAND</b></a>]  Theorem
      
      ⊢ ∀x y P. x ∈ y INSERT P ⇔ x = y ∨ x ≠ y ∧ x ∈ P
   
   [<a name="IN_INTER-val"><b>IN_INTER</b></a>]  Theorem
      
      ⊢ ∀s t x. x ∈ s ∩ t ⇔ x ∈ s ∧ x ∈ t
   
   [<a name="IN_POW-val"><b>IN_POW</b></a>]  Theorem
      
      ⊢ ∀set e. e ∈ POW set ⇔ e ⊆ set
   
   [<a name="IN_PREIMAGE-val"><b>IN_PREIMAGE</b></a>]  Theorem
      
      ⊢ ∀f s x. x ∈ PREIMAGE f s ⇔ f x ∈ s
   
   [<a name="IN_REST-val"><b>IN_REST</b></a>]  Theorem
      
      ⊢ ∀x s. x ∈ REST s ⇔ x ∈ s ∧ x ≠ CHOICE s
   
   [<a name="IN_SING-val"><b>IN_SING</b></a>]  Theorem
      
      ⊢ ∀x y. x ∈ {y} ⇔ x = y
   
   [<a name="IN_UNION-val"><b>IN_UNION</b></a>]  Theorem
      
      ⊢ ∀s t x. x ∈ s ∪ t ⇔ x ∈ s ∨ x ∈ t
   
   [<a name="IN_UNIV-val"><b>IN_UNIV</b></a>]  Theorem
      
      ⊢ ∀x. x ∈ 𝕌(:α)
   
   [<a name="IN_disjUNION-val"><b>IN_disjUNION</b></a>]  Theorem
      
      ⊢ (INL a ∈ A ⊔ B ⇔ a ∈ A) ∧ (INR b ∈ A ⊔ B ⇔ b ∈ B)
   
   [<a name="ITSET_CONG-val"><b>ITSET_CONG</b></a>]  Theorem
      
      ⊢ ∀f g. f = g ⇒ ITSET f = ITSET g
   
   [<a name="ITSET_EMPTY-val"><b>ITSET_EMPTY</b></a>]  Theorem
      
      ⊢ ∀f b. ITSET f ∅ b = b
   
   [<a name="ITSET_IND-val"><b>ITSET_IND</b></a>]  Theorem
      
      ⊢ ∀P. (∀s b. (FINITE s ∧ s ≠ ∅ ⇒ P (REST s) (f (CHOICE s) b)) ⇒ P s b) ⇒
            ∀v v1. P v v1
   
   [<a name="ITSET_INSERT-val"><b>ITSET_INSERT</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒
            ∀f x b.
              ITSET f (x INSERT s) b =
              ITSET f (REST (x INSERT s)) (f (CHOICE (x INSERT s)) b)
   
   [<a name="ITSET_PROPERTY-val"><b>ITSET_PROPERTY</b></a>]  Theorem
      
      ⊢ ∀s f b.
          FINITE s ∧ s ≠ ∅ ⇒
          ITSET f s b = ITSET f (REST s) (f (CHOICE s) b)
   
   [<a name="ITSET_REDUCTION-val"><b>ITSET_REDUCTION</b></a>]  Theorem
      
      ⊢ ∀f. (∀x y z. f x (f y z) = f y (f x z)) ⇒
            ∀s x b.
              FINITE s ∧ x ∉ s ⇒ ITSET f (x INSERT s) b = f x (ITSET f s b)
   
   [<a name="ITSET_SING-val"><b>ITSET_SING</b></a>]  Theorem
      
      ⊢ ∀f x a. ITSET f {x} a = f x a
   
   [<a name="ITSET_THM-val"><b>ITSET_THM</b></a>]  Theorem
      
      ⊢ ∀s f b.
          FINITE s ⇒
          ITSET f s b =
          if s = ∅ then b else ITSET f (REST s) (f (CHOICE s) b)
   
   [<a name="ITSET_def-val"><b>ITSET_def</b></a>]  Theorem
      
      ⊢ ∀s f b.
          ITSET f s b =
          if FINITE s then
            if s = ∅ then b else ITSET f (REST s) (f (CHOICE s) b)
          else ARB
   
   [<a name="K_SUBSET-val"><b>K_SUBSET</b></a>]  Theorem
      
      ⊢ ∀x y. K x ⊆ y ⇔ ¬x ∨ 𝕌(:α) ⊆ y
   
   [<a name="KoenigsLemma-val"><b>KoenigsLemma</b></a>]  Theorem
      
      ⊢ ∀R. (∀x. FINITE {y | R x y}) ⇒
            ∀x. INFINITE {y | R꙳ x y} ⇒
                ∃f. f 0 = x ∧ ∀n. R (f n) (f (SUC n))
   
   [<a name="KoenigsLemma_WF-val"><b>KoenigsLemma_WF</b></a>]  Theorem
      
      ⊢ ∀R. (∀x. FINITE {y | R x y}) ∧ WF Rᵀ ⇒ ∀x. FINITE {y | R꙳ x y}
   
   [<a name="LESS_CARD_DIFF-val"><b>LESS_CARD_DIFF</b></a>]  Theorem
      
      ⊢ ∀t. FINITE t ⇒ ∀s. FINITE s ⇒ CARD t &lt; CARD s ⇒ 0 &lt; CARD (s DIFF t)
   
   [<a name="LINV_DEF-val"><b>LINV_DEF</b></a>]  Theorem
      
      ⊢ ∀f s t. INJ f s t ⇒ ∀x. x ∈ s ⇒ LINV f s (f x) = x
   
   [<a name="LINV_OPT_THM-val"><b>LINV_OPT_THM</b></a>]  Theorem
      
      ⊢ LINV_OPT f s y = SOME x ⇒ x ∈ s ∧ f x = y
   
   [<a name="MAX_SET_ELIM-val"><b>MAX_SET_ELIM</b></a>]  Theorem
      
      ⊢ ∀P Q.
          FINITE P ∧ (P = ∅ ⇒ Q 0) ∧
          (∀x. (∀y. y ∈ P ⇒ y ≤ x) ∧ x ∈ P ⇒ Q x) ⇒
          Q (MAX_SET P)
   
   [<a name="MAX_SET_EMPTY-val"><b>MAX_SET_EMPTY</b></a>]  Theorem
      
      ⊢ MAX_SET ∅ = 0
   
   [<a name="MAX_SET_EQ_0-val"><b>MAX_SET_EQ_0</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ (MAX_SET s = 0 ⇔ s = ∅ ∨ s = {0})
   
   [<a name="MAX_SET_INTER-val"><b>MAX_SET_INTER</b></a>]  Theorem
      
      ⊢ ∀A B.
          FINITE A ∧ FINITE B ⇒
          MAX_SET (A ∩ B) ≤ MIN (MAX_SET A) (MAX_SET B)
   
   [<a name="MAX_SET_IN_SET-val"><b>MAX_SET_IN_SET</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ∧ s ≠ ∅ ⇒ MAX_SET s ∈ s
   
   [<a name="MAX_SET_LESS-val"><b>MAX_SET_LESS</b></a>]  Theorem
      
      ⊢ ∀s n. FINITE s ∧ MAX_SET s &lt; n ⇒ ∀x. x ∈ s ⇒ x &lt; n
   
   [<a name="MAX_SET_PROPERTY-val"><b>MAX_SET_PROPERTY</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀x. x ∈ s ⇒ x ≤ MAX_SET s
   
   [<a name="MAX_SET_REWRITES-val"><b>MAX_SET_REWRITES</b></a>]  Theorem
      
      ⊢ MAX_SET ∅ = 0 ∧ MAX_SET {e} = e
   
   [<a name="MAX_SET_SING-val"><b>MAX_SET_SING</b></a>]  Theorem
      
      ⊢ ∀e. MAX_SET {e} = e
   
   [<a name="MAX_SET_TEST-val"><b>MAX_SET_TEST</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ∧ s ≠ ∅ ⇒
            ∀x. x ∈ s ∧ (∀y. y ∈ s ⇒ y ≤ x) ⇒ x = MAX_SET s
   
   [<a name="MAX_SET_TEST_IFF-val"><b>MAX_SET_TEST_IFF</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ∧ s ≠ ∅ ⇒
            ∀x. x ∈ s ⇒ (MAX_SET s = x ⇔ ∀y. y ∈ s ⇒ y ≤ x)
   
   [<a name="MAX_SET_THM-val"><b>MAX_SET_THM</b></a>]  Theorem
      
      ⊢ MAX_SET ∅ = 0 ∧
        ∀e s. FINITE s ⇒ MAX_SET (e INSERT s) = MAX e (MAX_SET s)
   
   [<a name="MAX_SET_UNION-val"><b>MAX_SET_UNION</b></a>]  Theorem
      
      ⊢ ∀A B.
          FINITE A ∧ FINITE B ⇒
          MAX_SET (A ∪ B) = MAX (MAX_SET A) (MAX_SET B)
   
   [<a name="MEMBER_NOT_EMPTY-val"><b>MEMBER_NOT_EMPTY</b></a>]  Theorem
      
      ⊢ ∀s. (∃x. x ∈ s) ⇔ s ≠ ∅
   
   [<a name="MIN_SET_ELIM-val"><b>MIN_SET_ELIM</b></a>]  Theorem
      
      ⊢ ∀P Q.
          P ≠ ∅ ∧ (∀x. (∀y. y ∈ P ⇒ x ≤ y) ∧ x ∈ P ⇒ Q x) ⇒ Q (MIN_SET P)
   
   [<a name="MIN_SET_EQ_0-val"><b>MIN_SET_EQ_0</b></a>]  Theorem
      
      ⊢ ∀s. s ≠ ∅ ⇒ (MIN_SET s = 0 ⇔ 0 ∈ s)
   
   [<a name="MIN_SET_IN_SET-val"><b>MIN_SET_IN_SET</b></a>]  Theorem
      
      ⊢ ∀s. s ≠ ∅ ⇒ MIN_SET s ∈ s
   
   [<a name="MIN_SET_LEM-val"><b>MIN_SET_LEM</b></a>]  Theorem
      
      ⊢ ∀s. s ≠ ∅ ⇒ MIN_SET s ∈ s ∧ ∀x. x ∈ s ⇒ MIN_SET s ≤ x
   
   [<a name="MIN_SET_LEQ_MAX_SET-val"><b>MIN_SET_LEQ_MAX_SET</b></a>]  Theorem
      
      ⊢ ∀s. s ≠ ∅ ∧ FINITE s ⇒ MIN_SET s ≤ MAX_SET s
   
   [<a name="MIN_SET_PROPERTY-val"><b>MIN_SET_PROPERTY</b></a>]  Theorem
      
      ⊢ ∀s. s ≠ ∅ ⇒ ∀x. x ∈ s ⇒ MIN_SET s ≤ x
   
   [<a name="MIN_SET_SING-val"><b>MIN_SET_SING</b></a>]  Theorem
      
      ⊢ ∀e. MIN_SET {e} = e
   
   [<a name="MIN_SET_TEST-val"><b>MIN_SET_TEST</b></a>]  Theorem
      
      ⊢ ∀s. s ≠ ∅ ⇒ ∀x. x ∈ s ∧ (∀y. y ∈ s ⇒ x ≤ y) ⇒ x = MIN_SET s
   
   [<a name="MIN_SET_TEST_IFF-val"><b>MIN_SET_TEST_IFF</b></a>]  Theorem
      
      ⊢ ∀s. s ≠ ∅ ⇒ ∀x. x ∈ s ⇒ (MIN_SET s = x ⇔ ∀y. y ∈ s ⇒ x ≤ y)
   
   [<a name="MIN_SET_THM-val"><b>MIN_SET_THM</b></a>]  Theorem
      
      ⊢ (∀e. MIN_SET {e} = e) ∧
        ∀s e1 e2.
          MIN_SET (e1 INSERT e2 INSERT s) = MIN e1 (MIN_SET (e2 INSERT s))
   
   [<a name="MIN_SET_THM'-val"><b>MIN_SET_THM'</b></a>]  Theorem
      
      ⊢ (∀e. MIN_SET {e} = e) ∧
        ∀e s. s ≠ ∅ ⇒ MIN_SET (e INSERT s) = MIN e (MIN_SET s)
   
   [<a name="MIN_SET_UNION-val"><b>MIN_SET_UNION</b></a>]  Theorem
      
      ⊢ ∀A B.
          FINITE A ∧ FINITE B ∧ A ≠ ∅ ∧ B ≠ ∅ ⇒
          MIN_SET (A ∪ B) = MIN (MIN_SET A) (MIN_SET B)
   
   [<a name="NOT_EMPTY_INSERT-val"><b>NOT_EMPTY_INSERT</b></a>]  Theorem
      
      ⊢ ∀x s. ∅ ≠ x INSERT s
   
   [<a name="NOT_EMPTY_SING-val"><b>NOT_EMPTY_SING</b></a>]  Theorem
      
      ⊢ ∀x. ∅ ≠ {x}
   
   [<a name="NOT_EQUAL_SETS-val"><b>NOT_EQUAL_SETS</b></a>]  Theorem
      
      ⊢ ∀s t. s ≠ t ⇔ ∃x. x ∈ t ⇔ x ∉ s
   
   [<a name="NOT_INSERT_EMPTY-val"><b>NOT_INSERT_EMPTY</b></a>]  Theorem
      
      ⊢ ∀x s. x INSERT s ≠ ∅
   
   [<a name="NOT_IN_EMPTY-val"><b>NOT_IN_EMPTY</b></a>]  Theorem
      
      ⊢ ∀x. x ∉ ∅
   
   [<a name="NOT_IN_FINITE-val"><b>NOT_IN_FINITE</b></a>]  Theorem
      
      ⊢ INFINITE 𝕌(:α) ⇔ ∀s. FINITE s ⇒ ∃x. x ∉ s
   
   [<a name="NOT_PSUBSET_EMPTY-val"><b>NOT_PSUBSET_EMPTY</b></a>]  Theorem
      
      ⊢ ∀s. ¬(s ⊂ ∅)
   
   [<a name="NOT_SING_EMPTY-val"><b>NOT_SING_EMPTY</b></a>]  Theorem
      
      ⊢ ∀x. {x} ≠ ∅
   
   [<a name="NOT_UNIV_PSUBSET-val"><b>NOT_UNIV_PSUBSET</b></a>]  Theorem
      
      ⊢ ∀s. ¬(𝕌(:α) ⊂ s)
   
   [<a name="NUM_2D_BIJ-val"><b>NUM_2D_BIJ</b></a>]  Theorem
      
      ⊢ ∃f. BIJ f (𝕌(:num) × 𝕌(:num)) 𝕌(:num)
   
   [<a name="NUM_2D_BIJ_BIG_SQUARE-val"><b>NUM_2D_BIJ_BIG_SQUARE</b></a>]  Theorem
      
      ⊢ ∀f N.
          BIJ f 𝕌(:num) (𝕌(:num) × 𝕌(:num)) ⇒
          ∃k. IMAGE f (count N) ⊆ count k × count k
   
   [<a name="NUM_2D_BIJ_INV-val"><b>NUM_2D_BIJ_INV</b></a>]  Theorem
      
      ⊢ ∃f. BIJ f 𝕌(:num) (𝕌(:num) × 𝕌(:num))
   
   [<a name="NUM_2D_BIJ_NZ-val"><b>NUM_2D_BIJ_NZ</b></a>]  Theorem
      
      ⊢ ∃f. BIJ f (𝕌(:num) × (𝕌(:num) DIFF {0})) 𝕌(:num)
   
   [<a name="NUM_2D_BIJ_NZ_ALT-val"><b>NUM_2D_BIJ_NZ_ALT</b></a>]  Theorem
      
      ⊢ ∃f. BIJ f (𝕌(:num) × 𝕌(:num)) (𝕌(:num) DIFF {0})
   
   [<a name="NUM_2D_BIJ_NZ_ALT2-val"><b>NUM_2D_BIJ_NZ_ALT2</b></a>]  Theorem
      
      ⊢ ∃f. BIJ f ((𝕌(:num) DIFF {0}) × (𝕌(:num) DIFF {0})) 𝕌(:num)
   
   [<a name="NUM_2D_BIJ_NZ_ALT2_INV-val"><b>NUM_2D_BIJ_NZ_ALT2_INV</b></a>]  Theorem
      
      ⊢ ∃f. BIJ f 𝕌(:num) ((𝕌(:num) DIFF {0}) × (𝕌(:num) DIFF {0}))
   
   [<a name="NUM_2D_BIJ_NZ_ALT_INV-val"><b>NUM_2D_BIJ_NZ_ALT_INV</b></a>]  Theorem
      
      ⊢ ∃f. BIJ f (𝕌(:num) DIFF {0}) (𝕌(:num) × 𝕌(:num))
   
   [<a name="NUM_2D_BIJ_NZ_INV-val"><b>NUM_2D_BIJ_NZ_INV</b></a>]  Theorem
      
      ⊢ ∃f. BIJ f 𝕌(:num) (𝕌(:num) × (𝕌(:num) DIFF {0}))
   
   [<a name="NUM_2D_BIJ_SMALL_SQUARE-val"><b>NUM_2D_BIJ_SMALL_SQUARE</b></a>]  Theorem
      
      ⊢ ∀f k.
          BIJ f 𝕌(:num) (𝕌(:num) × 𝕌(:num)) ⇒
          ∃N. count k × count k ⊆ IMAGE f (count N)
   
   [<a name="NUM_SET_WOP-val"><b>NUM_SET_WOP</b></a>]  Theorem
      
      ⊢ ∀s. (∃n. n ∈ s) ⇔ ∃n. n ∈ s ∧ ∀m. m ∈ s ⇒ n ≤ m
   
   [<a name="ONE_ELEMENT_SING-val"><b>ONE_ELEMENT_SING</b></a>]  Theorem
      
      ⊢ ∀s a. s ≠ ∅ ∧ (∀k. k ∈ s ⇒ k = a) ⇒ s = {a}
   
   [<a name="PAIR_IN_GSPEC_1-val"><b>PAIR_IN_GSPEC_1</b></a>]  Theorem
      
      ⊢ (a,b) ∈ {(y,x) | P y} ⇔ P a ∧ b = x
   
   [<a name="PAIR_IN_GSPEC_2-val"><b>PAIR_IN_GSPEC_2</b></a>]  Theorem
      
      ⊢ (a,b) ∈ {(x,y) | P y} ⇔ P b ∧ a = x
   
   [<a name="PAIR_IN_GSPEC_IFF-val"><b>PAIR_IN_GSPEC_IFF</b></a>]  Theorem
      
      ⊢ (x,y) ∈ {(x,y) | P x y} ⇔ P x y
   
   [<a name="PAIR_IN_GSPEC_same-val"><b>PAIR_IN_GSPEC_same</b></a>]  Theorem
      
      ⊢ (a,b) ∈ {(x,x) | P x} ⇔ P a ∧ a = b
   
   [<a name="PHP-val"><b>PHP</b></a>]  Theorem
      
      ⊢ ∀f s t. FINITE t ∧ CARD t &lt; CARD s ⇒ ¬INJ f s t
   
   [<a name="PI_CONSTANT-val"><b>PI_CONSTANT</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀f k. (∀x. x ∈ s ⇒ f x = k) ⇒ Π f s = k ** CARD s
   
   [<a name="POW_EMPTY-val"><b>POW_EMPTY</b></a>]  Theorem
      
      ⊢ ∀s. POW s ≠ ∅
   
   [<a name="POW_EQNS-val"><b>POW_EQNS</b></a>]  Theorem
      
      ⊢ POW ∅ = {∅} ∧
        ∀e s.
          POW (e INSERT s) = (let ps = POW s in IMAGE ($INSERT e) ps ∪ ps)
   
   [<a name="POW_INSERT-val"><b>POW_INSERT</b></a>]  Theorem
      
      ⊢ ∀e s. POW (e INSERT s) = IMAGE ($INSERT e) (POW s) ∪ POW s
   
   [<a name="POW_applied-val"><b>POW_applied</b></a>]  Theorem
      
      ⊢ ∀set e. POW set e ⇔ e ⊆ set
   
   [<a name="PREIMAGE_ALT-val"><b>PREIMAGE_ALT</b></a>]  Theorem
      
      ⊢ ∀f s. PREIMAGE f s = s ∘ f
   
   [<a name="PREIMAGE_BIGUNION-val"><b>PREIMAGE_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀f s. PREIMAGE f (BIGUNION s) = BIGUNION (IMAGE (PREIMAGE f) s)
   
   [<a name="PREIMAGE_COMP-val"><b>PREIMAGE_COMP</b></a>]  Theorem
      
      ⊢ ∀f g s. PREIMAGE f (PREIMAGE g s) = PREIMAGE (g ∘ f) s
   
   [<a name="PREIMAGE_COMPL-val"><b>PREIMAGE_COMPL</b></a>]  Theorem
      
      ⊢ ∀f s. PREIMAGE f (COMPL s) = COMPL (PREIMAGE f s)
   
   [<a name="PREIMAGE_COMPL_INTER-val"><b>PREIMAGE_COMPL_INTER</b></a>]  Theorem
      
      ⊢ ∀f t sp. PREIMAGE f (COMPL t) ∩ sp = sp DIFF PREIMAGE f t
   
   [<a name="PREIMAGE_CROSS-val"><b>PREIMAGE_CROSS</b></a>]  Theorem
      
      ⊢ ∀f a b.
          PREIMAGE f (a × b) = PREIMAGE (FST ∘ f) a ∩ PREIMAGE (SND ∘ f) b
   
   [<a name="PREIMAGE_DIFF-val"><b>PREIMAGE_DIFF</b></a>]  Theorem
      
      ⊢ ∀f s t. PREIMAGE f (s DIFF t) = PREIMAGE f s DIFF PREIMAGE f t
   
   [<a name="PREIMAGE_DISJOINT-val"><b>PREIMAGE_DISJOINT</b></a>]  Theorem
      
      ⊢ ∀f s t. DISJOINT s t ⇒ DISJOINT (PREIMAGE f s) (PREIMAGE f t)
   
   [<a name="PREIMAGE_EMPTY-val"><b>PREIMAGE_EMPTY</b></a>]  Theorem
      
      ⊢ ∀f. PREIMAGE f ∅ = ∅
   
   [<a name="PREIMAGE_I-val"><b>PREIMAGE_I</b></a>]  Theorem
      
      ⊢ PREIMAGE I = I ∧ PREIMAGE (λx. x) = (λx. x)
   
   [<a name="PREIMAGE_IMAGE-val"><b>PREIMAGE_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s. s ⊆ PREIMAGE f (IMAGE f s)
   
   [<a name="PREIMAGE_INTER-val"><b>PREIMAGE_INTER</b></a>]  Theorem
      
      ⊢ ∀f s t. PREIMAGE f (s ∩ t) = PREIMAGE f s ∩ PREIMAGE f t
   
   [<a name="PREIMAGE_K-val"><b>PREIMAGE_K</b></a>]  Theorem
      
      ⊢ ∀x s. PREIMAGE (K x) s = if x ∈ s then 𝕌(:β) else ∅
   
   [<a name="PREIMAGE_SUBSET-val"><b>PREIMAGE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀f s t. s ⊆ t ⇒ PREIMAGE f s ⊆ PREIMAGE f t
   
   [<a name="PREIMAGE_UNION-val"><b>PREIMAGE_UNION</b></a>]  Theorem
      
      ⊢ ∀f s t. PREIMAGE f (s ∪ t) = PREIMAGE f s ∪ PREIMAGE f t
   
   [<a name="PREIMAGE_UNIV-val"><b>PREIMAGE_UNIV</b></a>]  Theorem
      
      ⊢ ∀f. PREIMAGE f 𝕌(:β) = 𝕌(:α)
   
   [<a name="PREIMAGE_applied-val"><b>PREIMAGE_applied</b></a>]  Theorem
      
      ⊢ ∀f s x. PREIMAGE f s x ⇔ f x ∈ s
   
   [<a name="PREIMAGE_o-val"><b>PREIMAGE_o</b></a>]  Theorem
      
      ⊢ ∀f g s. PREIMAGE (f ∘ g) s = PREIMAGE g (s ∘ f)
   
   [<a name="PROD_IMAGE_CONG-val"><b>PROD_IMAGE_CONG</b></a>]  Theorem
      
      ⊢ ∀s f1 f2. (∀x. x ∈ s ⇒ f1 x = f2 x) ⇒ Π f1 s = Π f2 s
   
   [<a name="PROD_IMAGE_CONSTANT-val"><b>PROD_IMAGE_CONSTANT</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀c. Π (K c) s = c ** CARD s
   
   [<a name="PROD_IMAGE_DELETE-val"><b>PROD_IMAGE_DELETE</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒
            ∀f e.
              0 &lt; f e ⇒
              Π f (s DELETE e) = if e ∈ s then Π f s DIV f e else Π f s
   
   [<a name="PROD_IMAGE_EMPTY-val"><b>PROD_IMAGE_EMPTY</b></a>]  Theorem
      
      ⊢ ∀f. Π f ∅ = 1
   
   [<a name="PROD_IMAGE_EQ_0-val"><b>PROD_IMAGE_EQ_0</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ (Π f s = 0 ⇔ ∃x. x ∈ s ∧ f x = 0)
   
   [<a name="PROD_IMAGE_EQ_1-val"><b>PROD_IMAGE_EQ_1</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ (Π f s = 1 ⇔ IMAGE f s ⊆ {1})
   
   [<a name="PROD_IMAGE_INSERT-val"><b>PROD_IMAGE_INSERT</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀f e. e ∉ s ⇒ Π f (e INSERT s) = f e * Π f s
   
   [<a name="PROD_IMAGE_THM-val"><b>PROD_IMAGE_THM</b></a>]  Theorem
      
      ⊢ ∀f. Π f ∅ = 1 ∧
            ∀e s. FINITE s ⇒ Π f (e INSERT s) = f e * Π f (s DELETE e)
   
   [<a name="PROD_SET_EMPTY-val"><b>PROD_SET_EMPTY</b></a>]  Theorem
      
      ⊢ PROD_SET ∅ = 1
   
   [<a name="PROD_SET_IMAGE_REDUCTION-val"><b>PROD_SET_IMAGE_REDUCTION</b></a>]  Theorem
      
      ⊢ ∀f s x.
          FINITE (IMAGE f s) ∧ f x ∉ IMAGE f s ⇒
          PROD_SET (IMAGE f (x INSERT s)) = f x * PROD_SET (IMAGE f s)
   
   [<a name="PROD_SET_INSERT-val"><b>PROD_SET_INSERT</b></a>]  Theorem
      
      ⊢ ∀x s. FINITE s ∧ x ∉ s ⇒ PROD_SET (x INSERT s) = x * PROD_SET s
   
   [<a name="PROD_SET_THM-val"><b>PROD_SET_THM</b></a>]  Theorem
      
      ⊢ PROD_SET ∅ = 1 ∧
        ∀x s. FINITE s ⇒ PROD_SET (x INSERT s) = x * PROD_SET (s DELETE x)
   
   [<a name="PSUBSET_EQN-val"><b>PSUBSET_EQN</b></a>]  Theorem
      
      ⊢ ∀s1 s2. s1 ⊂ s2 ⇔ s1 ⊆ s2 ∧ ¬(s2 ⊆ s1)
   
   [<a name="PSUBSET_FINITE-val"><b>PSUBSET_FINITE</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀t. t ⊂ s ⇒ FINITE t
   
   [<a name="PSUBSET_INSERT_SUBSET-val"><b>PSUBSET_INSERT_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t. s ⊂ t ⇔ ∃x. x ∉ s ∧ x INSERT s ⊆ t
   
   [<a name="PSUBSET_IRREFL-val"><b>PSUBSET_IRREFL</b></a>]  Theorem
      
      ⊢ ∀s. ¬(s ⊂ s)
   
   [<a name="PSUBSET_MEMBER-val"><b>PSUBSET_MEMBER</b></a>]  Theorem
      
      ⊢ ∀s t. s ⊂ t ⇔ s ⊆ t ∧ ∃y. y ∈ t ∧ y ∉ s
   
   [<a name="PSUBSET_SING-val"><b>PSUBSET_SING</b></a>]  Theorem
      
      ⊢ ∀s x. x ⊂ {s} ⇔ x = ∅
   
   [<a name="PSUBSET_SUBSET_TRANS-val"><b>PSUBSET_SUBSET_TRANS</b></a>]  Theorem
      
      ⊢ ∀s t u. s ⊂ t ∧ t ⊆ u ⇒ s ⊂ u
   
   [<a name="PSUBSET_TRANS-val"><b>PSUBSET_TRANS</b></a>]  Theorem
      
      ⊢ ∀s t u. s ⊂ t ∧ t ⊂ u ⇒ s ⊂ u
   
   [<a name="PSUBSET_UNIV-val"><b>PSUBSET_UNIV</b></a>]  Theorem
      
      ⊢ ∀s. s ⊂ 𝕌(:α) ⇔ ∃x. x ∉ s
   
   [<a name="RC_PSUBSET-val"><b>RC_PSUBSET</b></a>]  Theorem
      
      ⊢ RC $PSUBSET = $SUBSET
   
   [<a name="RC_SUBSET_THM-val"><b>RC_SUBSET_THM</b></a>]  Theorem
      
      ⊢ RC $SUBSET = $SUBSET
   
   [<a name="REL_RESTRICT_EMPTY-val"><b>REL_RESTRICT_EMPTY</b></a>]  Theorem
      
      ⊢ REL_RESTRICT R ∅ = ∅ᵣ
   
   [<a name="REL_RESTRICT_SUBSET-val"><b>REL_RESTRICT_SUBSET</b></a>]  Theorem
      
      ⊢ s1 ⊆ s2 ⇒ REL_RESTRICT R s1 ⊆ᵣ REL_RESTRICT R s2
   
   [<a name="RESTRICTION_COMPOSE-val"><b>RESTRICTION_COMPOSE</b></a>]  Theorem
      
      ⊢ ∀f g s t.
          IMAGE f s ⊆ t ⇒
          RESTRICTION s (RESTRICTION t g ∘ RESTRICTION s f) =
          RESTRICTION s (g ∘ f)
   
   [<a name="RESTRICTION_COMPOSE_LEFT-val"><b>RESTRICTION_COMPOSE_LEFT</b></a>]  Theorem
      
      ⊢ ∀f g s t.
          IMAGE f s ⊆ t ⇒
          RESTRICTION s (RESTRICTION t g ∘ f) = RESTRICTION s (g ∘ f)
   
   [<a name="RESTRICTION_COMPOSE_RIGHT-val"><b>RESTRICTION_COMPOSE_RIGHT</b></a>]  Theorem
      
      ⊢ ∀f g s. RESTRICTION s (g ∘ RESTRICTION s f) = RESTRICTION s (g ∘ f)
   
   [<a name="RESTRICTION_EXTENSION-val"><b>RESTRICTION_EXTENSION</b></a>]  Theorem
      
      ⊢ ∀s f g. RESTRICTION s f = RESTRICTION s g ⇔ ∀x. x ∈ s ⇒ f x = g x
   
   [<a name="RESTRICTION_FIXPOINT-val"><b>RESTRICTION_FIXPOINT</b></a>]  Theorem
      
      ⊢ ∀s f. RESTRICTION s f = f ⇔ f ∈ EXTENSIONAL s
   
   [<a name="RESTRICTION_IDEMP-val"><b>RESTRICTION_IDEMP</b></a>]  Theorem
      
      ⊢ ∀s f. RESTRICTION s (RESTRICTION s f) = RESTRICTION s f
   
   [<a name="RESTRICTION_IN_EXTENSIONAL-val"><b>RESTRICTION_IN_EXTENSIONAL</b></a>]  Theorem
      
      ⊢ ∀s f. RESTRICTION s f ∈ EXTENSIONAL s
   
   [<a name="RESTRICTION_RESTRICTION-val"><b>RESTRICTION_RESTRICTION</b></a>]  Theorem
      
      ⊢ ∀s t f. s ⊆ t ⇒ RESTRICTION s (RESTRICTION t f) = RESTRICTION s f
   
   [<a name="RESTRICTION_UNIQUE-val"><b>RESTRICTION_UNIQUE</b></a>]  Theorem
      
      ⊢ ∀s f g.
          RESTRICTION s f = g ⇔ EXTENSIONAL s g ∧ ∀x. x ∈ s ⇒ f x = g x
   
   [<a name="RESTRICTION_UNIQUE_ALT-val"><b>RESTRICTION_UNIQUE_ALT</b></a>]  Theorem
      
      ⊢ ∀s f g.
          f = RESTRICTION s g ⇔ EXTENSIONAL s f ∧ ∀x. x ∈ s ⇒ f x = g x
   
   [<a name="REST_PSUBSET-val"><b>REST_PSUBSET</b></a>]  Theorem
      
      ⊢ ∀s. s ≠ ∅ ⇒ REST s ⊂ s
   
   [<a name="REST_SING-val"><b>REST_SING</b></a>]  Theorem
      
      ⊢ ∀x. REST {x} = ∅
   
   [<a name="REST_SUBSET-val"><b>REST_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s. REST s ⊆ s
   
   [<a name="REST_applied-val"><b>REST_applied</b></a>]  Theorem
      
      ⊢ ∀x s. REST s x ⇔ x ∈ s ∧ x ≠ CHOICE s
   
   [<a name="RINV_DEF-val"><b>RINV_DEF</b></a>]  Theorem
      
      ⊢ ∀f s t. SURJ f s t ⇒ ∀x. x ∈ t ⇒ f (RINV f s x) = x
   
   [<a name="RTC_PSUBSET-val"><b>RTC_PSUBSET</b></a>]  Theorem
      
      ⊢ $PSUBSET꙳ = $SUBSET
   
   [<a name="RTC_SUBSET_THM-val"><b>RTC_SUBSET_THM</b></a>]  Theorem
      
      ⊢ $SUBSET꙳ = $SUBSET
   
   [<a name="SCHROEDER_BERNSTEIN-val"><b>SCHROEDER_BERNSTEIN</b></a>]  Theorem
      
      ⊢ ∀s t. (∃f. INJ f s t) ∧ (∃g. INJ g t s) ⇒ ∃h. BIJ h s t
   
   [<a name="SCHROEDER_BERNSTEIN_AUTO-val"><b>SCHROEDER_BERNSTEIN_AUTO</b></a>]  Theorem
      
      ⊢ ∀s t. t ⊆ s ∧ (∃f. INJ f s t) ⇒ ∃g. BIJ g s t
   
   [<a name="SCHROEDER_CLOSE-val"><b>SCHROEDER_CLOSE</b></a>]  Theorem
      
      ⊢ ∀f s. x ∈ schroeder_close f s ⇔ ∃n. x ∈ FUNPOW (IMAGE f) n s
   
   [<a name="SCHROEDER_CLOSED-val"><b>SCHROEDER_CLOSED</b></a>]  Theorem
      
      ⊢ ∀f s. IMAGE f (schroeder_close f s) ⊆ schroeder_close f s
   
   [<a name="SCHROEDER_CLOSE_SET-val"><b>SCHROEDER_CLOSE_SET</b></a>]  Theorem
      
      ⊢ ∀f s t. f ∈ FUNSET s s ∧ t ⊆ s ⇒ schroeder_close f t ⊆ s
   
   [<a name="SCHROEDER_CLOSE_SUBSET-val"><b>SCHROEDER_CLOSE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀f s. s ⊆ schroeder_close f s
   
   [<a name="SET_CASES-val"><b>SET_CASES</b></a>]  Theorem
      
      ⊢ ∀s. s = ∅ ∨ ∃x t. s = x INSERT t ∧ x ∉ t
   
   [<a name="SET_EQ_SUBSET-val"><b>SET_EQ_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t. s = t ⇔ s ⊆ t ∧ t ⊆ s
   
   [<a name="SET_MINIMUM-val"><b>SET_MINIMUM</b></a>]  Theorem
      
      ⊢ ∀s M. (∃x. x ∈ s) ⇔ ∃x. x ∈ s ∧ ∀y. y ∈ s ⇒ M x ≤ M y
   
   [<a name="SIGMA_CARD_CONSTANT-val"><b>SIGMA_CARD_CONSTANT</b></a>]  Theorem
      
      ⊢ ∀n s. FINITE s ∧ (∀e. e ∈ s ⇒ CARD e = n) ⇒ ∑ CARD s = n * CARD s
   
   [<a name="SIGMA_CARD_SAME_SIZE_SETS-val"><b>SIGMA_CARD_SAME_SIZE_SETS</b></a>]  Theorem
      
      ⊢ ∀n s. FINITE s ∧ (∀e. e ∈ s ⇒ CARD e = n) ⇒ ∑ CARD s = n * CARD s
   
   [<a name="SIGMA_CONG-val"><b>SIGMA_CONG</b></a>]  Theorem
      
      ⊢ ∀s f1 f2. (∀x. x ∈ s ⇒ f1 x = f2 x) ⇒ ∑ f1 s = ∑ f2 s
   
   [<a name="SIGMA_CONSTANT-val"><b>SIGMA_CONSTANT</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀f k. (∀x. x ∈ s ⇒ f x = k) ⇒ ∑ f s = k * CARD s
   
   [<a name="SIGMA_LE_SIGMA-val"><b>SIGMA_LE_SIGMA</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀f g. (∀x. x ∈ s ⇒ f x ≤ g x) ⇒ ∑ f s ≤ ∑ g s
   
   [<a name="SIMPLE_FINITE_INDUCT-val"><b>SIMPLE_FINITE_INDUCT</b></a>]  Theorem
      
      ⊢ ∀P. P ∅ ∧ (∀s. P s ⇒ ∀e. P (e INSERT s)) ⇒ ∀s. FINITE s ⇒ P s
   
   [<a name="SING-val"><b>SING</b></a>]  Theorem
      
      ⊢ ∀x. SING {x}
   
   [<a name="SING_CARD_1-val"><b>SING_CARD_1</b></a>]  Theorem
      
      ⊢ ∀s. SING s ⇒ CARD s = 1
   
   [<a name="SING_DELETE-val"><b>SING_DELETE</b></a>]  Theorem
      
      ⊢ ∀x. {x} DELETE x = ∅
   
   [<a name="SING_ELEMENT-val"><b>SING_ELEMENT</b></a>]  Theorem
      
      ⊢ ∀s. SING s ⇒ ∀x y. x ∈ s ∧ y ∈ s ⇒ x = y
   
   [<a name="SING_EMPTY-val"><b>SING_EMPTY</b></a>]  Theorem
      
      ⊢ SING ∅ ⇔ F
   
   [<a name="SING_FINITE-val"><b>SING_FINITE</b></a>]  Theorem
      
      ⊢ ∀s. SING s ⇒ FINITE s
   
   [<a name="SING_IFF_CARD1-val"><b>SING_IFF_CARD1</b></a>]  Theorem
      
      ⊢ ∀s. SING s ⇔ CARD s = 1 ∧ FINITE s
   
   [<a name="SING_IFF_EMPTY_REST-val"><b>SING_IFF_EMPTY_REST</b></a>]  Theorem
      
      ⊢ ∀s. SING s ⇔ s ≠ ∅ ∧ REST s = ∅
   
   [<a name="SING_INSERT-val"><b>SING_INSERT</b></a>]  Theorem
      
      ⊢ SING (x INSERT s) ⇔ s = ∅ ∨ s = {x}
   
   [<a name="SING_INTER-val"><b>SING_INTER</b></a>]  Theorem
      
      ⊢ ∀s x. {x} ∩ s = if x ∈ s then {x} else ∅
   
   [<a name="SING_ONE_ELEMENT-val"><b>SING_ONE_ELEMENT</b></a>]  Theorem
      
      ⊢ ∀s. s ≠ ∅ ⇒ (SING s ⇔ ∀x y. x ∈ s ∧ y ∈ s ⇒ x = y)
   
   [<a name="SING_TEST-val"><b>SING_TEST</b></a>]  Theorem
      
      ⊢ ∀s. SING s ⇔ s ≠ ∅ ∧ ∀x y. x ∈ s ∧ y ∈ s ⇒ x = y
   
   [<a name="SING_UNION-val"><b>SING_UNION</b></a>]  Theorem
      
      ⊢ SING (s ∪ t) ⇔
        SING s ∧ t = ∅ ∨ SING t ∧ s = ∅ ∨ SING s ∧ SING t ∧ s = t
   
   [<a name="SING_applied-val"><b>SING_applied</b></a>]  Theorem
      
      ⊢ ∀x y. {y} x ⇔ x = y
   
   [<a name="SING_partitions-val"><b>SING_partitions</b></a>]  Theorem
      
      ⊢ ∀x w. {x} partitions w ⇔ x = w ∧ w ≠ ∅
   
   [<a name="SPECIFICATION-val"><b>SPECIFICATION</b></a>]  Theorem
      
      ⊢ ∀P x. x ∈ P ⇔ P x
   
   [<a name="SUBSET_ADD-val"><b>SUBSET_ADD</b></a>]  Theorem
      
      ⊢ ∀f n d. (∀n. f n ⊆ f (SUC n)) ⇒ f n ⊆ f (n + d)
   
   [<a name="SUBSET_ANTISYM-val"><b>SUBSET_ANTISYM</b></a>]  Theorem
      
      ⊢ ∀s t. s ⊆ t ∧ t ⊆ s ⇒ s = t
   
   [<a name="SUBSET_ANTISYM_EQ-val"><b>SUBSET_ANTISYM_EQ</b></a>]  Theorem
      
      ⊢ ∀s t. s ⊆ t ∧ t ⊆ s ⇔ s = t
   
   [<a name="SUBSET_BIGINTER-val"><b>SUBSET_BIGINTER</b></a>]  Theorem
      
      ⊢ ∀X P. X ⊆ BIGINTER P ⇔ ∀Y. Y ∈ P ⇒ X ⊆ Y
   
   [<a name="SUBSET_BIGUNION-val"><b>SUBSET_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀f g. f ⊆ g ⇒ BIGUNION f ⊆ BIGUNION g
   
   [<a name="SUBSET_BIGUNION_I-val"><b>SUBSET_BIGUNION_I</b></a>]  Theorem
      
      ⊢ ∀x P. x ∈ P ⇒ x ⊆ BIGUNION P
   
   [<a name="SUBSET_BIGUNION_SUBSET_I-val"><b>SUBSET_BIGUNION_SUBSET_I</b></a>]  Theorem
      
      ⊢ B ⊆ A ∧ A ∈ As ⇒ B ⊆ BIGUNION As
   
   [<a name="SUBSET_COMMUTING_ITSET_INSERT-val"><b>SUBSET_COMMUTING_ITSET_INSERT</b></a>]  Theorem
      
      ⊢ ∀f s t.
          FINITE s ∧ s ⊆ t ∧ closure_comm_assoc_fun f t ⇒
          ∀x b::t. ITSET f (x INSERT s) b = ITSET f (s DELETE x) (f x b)
   
   [<a name="SUBSET_COMMUTING_ITSET_RECURSES-val"><b>SUBSET_COMMUTING_ITSET_RECURSES</b></a>]  Theorem
      
      ⊢ ∀f s t.
          FINITE s ∧ s ⊆ t ∧ closure_comm_assoc_fun f t ⇒
          ∀x b::t. ITSET f (x INSERT s) b = f x (ITSET f (s DELETE x) b)
   
   [<a name="SUBSET_COMMUTING_ITSET_REDUCTION-val"><b>SUBSET_COMMUTING_ITSET_REDUCTION</b></a>]  Theorem
      
      ⊢ ∀f s t.
          FINITE s ∧ s ⊆ t ∧ closure_comm_assoc_fun f t ⇒
          ∀x b::t. ITSET f s (f x b) = f x (ITSET f s b)
   
   [<a name="SUBSET_CROSS-val"><b>SUBSET_CROSS</b></a>]  Theorem
      
      ⊢ ∀a b c d. a ⊆ b ∧ c ⊆ d ⇒ a × c ⊆ b × d
   
   [<a name="SUBSET_DELETE-val"><b>SUBSET_DELETE</b></a>]  Theorem
      
      ⊢ ∀x s t. s ⊆ t DELETE x ⇔ x ∉ s ∧ s ⊆ t
   
   [<a name="SUBSET_DELETE_BOTH-val"><b>SUBSET_DELETE_BOTH</b></a>]  Theorem
      
      ⊢ ∀s1 s2 x. s1 ⊆ s2 ⇒ s1 DELETE x ⊆ s2 DELETE x
   
   [<a name="SUBSET_DIFF-val"><b>SUBSET_DIFF</b></a>]  Theorem
      
      ⊢ ∀s1 s2 s3. s1 ⊆ s2 DIFF s3 ⇔ s1 ⊆ s2 ∧ DISJOINT s1 s3
   
   [<a name="SUBSET_DIFF_EMPTY-val"><b>SUBSET_DIFF_EMPTY</b></a>]  Theorem
      
      ⊢ ∀s t. s DIFF t = ∅ ⇔ s ⊆ t
   
   [<a name="SUBSET_DISJOINT-val"><b>SUBSET_DISJOINT</b></a>]  Theorem
      
      ⊢ ∀s t u v. DISJOINT s t ∧ u ⊆ s ∧ v ⊆ t ⇒ DISJOINT u v
   
   [<a name="SUBSET_EMPTY-val"><b>SUBSET_EMPTY</b></a>]  Theorem
      
      ⊢ ∀s. s ⊆ ∅ ⇔ s = ∅
   
   [<a name="SUBSET_EQ_CARD-val"><b>SUBSET_EQ_CARD</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀t. FINITE t ∧ CARD s = CARD t ∧ s ⊆ t ⇒ s = t
   
   [<a name="SUBSET_FINITE-val"><b>SUBSET_FINITE</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀t. t ⊆ s ⇒ FINITE t
   
   [<a name="SUBSET_FINITE_I-val"><b>SUBSET_FINITE_I</b></a>]  Theorem
      
      ⊢ ∀s t. FINITE s ∧ t ⊆ s ⇒ FINITE t
   
   [<a name="SUBSET_IMAGE-val"><b>SUBSET_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s t. s ⊆ IMAGE f t ⇔ ∃u. u ⊆ t ∧ s = IMAGE f u
   
   [<a name="SUBSET_INSERT-val"><b>SUBSET_INSERT</b></a>]  Theorem
      
      ⊢ ∀x s. x ∉ s ⇒ ∀t. s ⊆ x INSERT t ⇔ s ⊆ t
   
   [<a name="SUBSET_INSERT_DELETE-val"><b>SUBSET_INSERT_DELETE</b></a>]  Theorem
      
      ⊢ ∀x s t. s ⊆ x INSERT t ⇔ s DELETE x ⊆ t
   
   [<a name="SUBSET_INSERT_RIGHT-val"><b>SUBSET_INSERT_RIGHT</b></a>]  Theorem
      
      ⊢ ∀e s1 s2. s1 ⊆ s2 ⇒ s1 ⊆ e INSERT s2
   
   [<a name="SUBSET_INTER-val"><b>SUBSET_INTER</b></a>]  Theorem
      
      ⊢ ∀s t u. s ⊆ t ∩ u ⇔ s ⊆ t ∧ s ⊆ u
   
   [<a name="SUBSET_INTER1-val"><b>SUBSET_INTER1</b></a>]  Theorem
      
      ⊢ ∀s t. s ⊆ t ⇒ s ∩ t = s
   
   [<a name="SUBSET_INTER2-val"><b>SUBSET_INTER2</b></a>]  Theorem
      
      ⊢ ∀s t. s ⊆ t ⇒ t ∩ s = s
   
   [<a name="SUBSET_INTER_ABSORPTION-val"><b>SUBSET_INTER_ABSORPTION</b></a>]  Theorem
      
      ⊢ ∀s t. s ⊆ t ⇔ s ∩ t = s
   
   [<a name="SUBSET_K-val"><b>SUBSET_K</b></a>]  Theorem
      
      ⊢ ∀x y. x ⊆ K y ⇔ x ⊆ ∅ ∨ y
   
   [<a name="SUBSET_MAX_SET-val"><b>SUBSET_MAX_SET</b></a>]  Theorem
      
      ⊢ ∀I J. FINITE I ∧ FINITE J ∧ I ⊆ J ⇒ MAX_SET I ≤ MAX_SET J
   
   [<a name="SUBSET_MIN_SET-val"><b>SUBSET_MIN_SET</b></a>]  Theorem
      
      ⊢ ∀I J. I ≠ ∅ ∧ J ≠ ∅ ∧ I ⊆ J ⇒ MIN_SET J ≤ MIN_SET I
   
   [<a name="SUBSET_OF_INSERT-val"><b>SUBSET_OF_INSERT</b></a>]  Theorem
      
      ⊢ ∀x s. s ⊆ x INSERT s
   
   [<a name="SUBSET_POW-val"><b>SUBSET_POW</b></a>]  Theorem
      
      ⊢ ∀s1 s2. s1 ⊆ s2 ⇒ POW s1 ⊆ POW s2
   
   [<a name="SUBSET_PSUBSET_TRANS-val"><b>SUBSET_PSUBSET_TRANS</b></a>]  Theorem
      
      ⊢ ∀s t u. s ⊆ t ∧ t ⊂ u ⇒ s ⊂ u
   
   [<a name="SUBSET_REFL-val"><b>SUBSET_REFL</b></a>]  Theorem
      
      ⊢ ∀s. s ⊆ s
   
   [<a name="SUBSET_SING-val"><b>SUBSET_SING</b></a>]  Theorem
      
      ⊢ x ⊆ {a} ⇔ x = ∅ ∨ x = {a}
   
   [<a name="SUBSET_THM-val"><b>SUBSET_THM</b></a>]  Theorem
      
      ⊢ ∀P Q. P ⊆ Q ⇒ ∀x. x ∈ P ⇒ x ∈ Q
   
   [<a name="SUBSET_TRANS-val"><b>SUBSET_TRANS</b></a>]  Theorem
      
      ⊢ ∀s t u. s ⊆ t ∧ t ⊆ u ⇒ s ⊆ u
   
   [<a name="SUBSET_UNION-val"><b>SUBSET_UNION</b></a>]  Theorem
      
      ⊢ (∀s t. s ⊆ s ∪ t) ∧ ∀s t. s ⊆ t ∪ s
   
   [<a name="SUBSET_UNION_ABSORPTION-val"><b>SUBSET_UNION_ABSORPTION</b></a>]  Theorem
      
      ⊢ ∀s t. s ⊆ t ⇔ s ∪ t = t
   
   [<a name="SUBSET_UNIV-val"><b>SUBSET_UNIV</b></a>]  Theorem
      
      ⊢ ∀s. s ⊆ 𝕌(:α)
   
   [<a name="SUBSET_applied-val"><b>SUBSET_applied</b></a>]  Theorem
      
      ⊢ ∀s t. s ⊆ t ⇔ ∀x. s x ⇒ t x
   
   [<a name="SUBSET_count_MAX_SET-val"><b>SUBSET_count_MAX_SET</b></a>]  Theorem
      
      ⊢ FINITE s ⇒ s ⊆ count (MAX_SET s + 1)
   
   [<a name="SUBSET_reflexive-val"><b>SUBSET_reflexive</b></a>]  Theorem
      
      ⊢ reflexive $SUBSET
   
   [<a name="SUBSET_transitive-val"><b>SUBSET_transitive</b></a>]  Theorem
      
      ⊢ transitive $SUBSET
   
   [<a name="SUM_IMAGE_ADD-val"><b>SUM_IMAGE_ADD</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∑ (λx. f x + g x) s = ∑ f s + ∑ g s
   
   [<a name="SUM_IMAGE_CONG-val"><b>SUM_IMAGE_CONG</b></a>]  Theorem
      
      ⊢ s1 = s2 ∧ (∀x. x ∈ s2 ⇒ f1 x = f2 x) ⇒ ∑ f1 s1 = ∑ f2 s2
   
   [<a name="SUM_IMAGE_CONSTANT-val"><b>SUM_IMAGE_CONSTANT</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀c. ∑ (K c) s = c * CARD s
   
   [<a name="SUM_IMAGE_DELETE-val"><b>SUM_IMAGE_DELETE</b></a>]  Theorem
      
      ⊢ ∀f s.
          FINITE s ⇒
          ∀e. ∑ f (s DELETE e) = if e ∈ s then ∑ f s − f e else ∑ f s
   
   [<a name="SUM_IMAGE_DISJOINT-val"><b>SUM_IMAGE_DISJOINT</b></a>]  Theorem
      
      ⊢ ∀s t.
          FINITE s ∧ FINITE t ∧ DISJOINT s t ⇒
          ∀f. ∑ f (s ∪ t) = ∑ f s + ∑ f t
   
   [<a name="SUM_IMAGE_EMPTY-val"><b>SUM_IMAGE_EMPTY</b></a>]  Theorem
      
      ⊢ ∀f. ∑ f ∅ = 0
   
   [<a name="SUM_IMAGE_INJ_o-val"><b>SUM_IMAGE_INJ_o</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒
            ∀g. INJ g s 𝕌(:α) ⇒ ∀f. ∑ f (IMAGE g s) = ∑ (f ∘ g) s
   
   [<a name="SUM_IMAGE_INSERT-val"><b>SUM_IMAGE_INSERT</b></a>]  Theorem
      
      ⊢ ∀f s. FINITE s ⇒ ∀e. e ∉ s ⇒ ∑ f (e INSERT s) = f e + ∑ f s
   
   [<a name="SUM_IMAGE_IN_LE-val"><b>SUM_IMAGE_IN_LE</b></a>]  Theorem
      
      ⊢ ∀f s e. FINITE s ∧ e ∈ s ⇒ f e ≤ ∑ f s
   
   [<a name="SUM_IMAGE_MONO_LESS-val"><b>SUM_IMAGE_MONO_LESS</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒
            (∃x. x ∈ s ∧ f x &lt; g x) ∧ (∀x. x ∈ s ⇒ f x ≤ g x) ⇒
            ∑ f s &lt; ∑ g s
   
   [<a name="SUM_IMAGE_MONO_LESS_EQ-val"><b>SUM_IMAGE_MONO_LESS_EQ</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ (∀x. x ∈ s ⇒ f x ≤ g x) ⇒ ∑ f s ≤ ∑ g s
   
   [<a name="SUM_IMAGE_MONO_LT-val"><b>SUM_IMAGE_MONO_LT</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ∧ s ≠ ∅ ⇒
            ∀f g. (∀x. x ∈ s ⇒ f x &lt; g x) ⇒ ∑ f s &lt; ∑ g s
   
   [<a name="SUM_IMAGE_PERMUTES-val"><b>SUM_IMAGE_PERMUTES</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀g. g PERMUTES s ⇒ ∀f. ∑ (f ∘ g) s = ∑ f s
   
   [<a name="SUM_IMAGE_SING-val"><b>SUM_IMAGE_SING</b></a>]  Theorem
      
      ⊢ ∀f e. ∑ f {e} = f e
   
   [<a name="SUM_IMAGE_SUBSET_LE-val"><b>SUM_IMAGE_SUBSET_LE</b></a>]  Theorem
      
      ⊢ ∀f s t. FINITE s ∧ t ⊆ s ⇒ ∑ f t ≤ ∑ f s
   
   [<a name="SUM_IMAGE_THM-val"><b>SUM_IMAGE_THM</b></a>]  Theorem
      
      ⊢ ∀f. ∑ f ∅ = 0 ∧
            ∀e s. FINITE s ⇒ ∑ f (e INSERT s) = f e + ∑ f (s DELETE e)
   
   [<a name="SUM_IMAGE_UNION-val"><b>SUM_IMAGE_UNION</b></a>]  Theorem
      
      ⊢ ∀f s t.
          FINITE s ∧ FINITE t ⇒ ∑ f (s ∪ t) = ∑ f s + ∑ f t − ∑ f (s ∩ t)
   
   [<a name="SUM_IMAGE_UNION_EQN-val"><b>SUM_IMAGE_UNION_EQN</b></a>]  Theorem
      
      ⊢ ∀s t.
          FINITE s ∧ FINITE t ⇒
          ∀f. ∑ f (s ∪ t) + ∑ f (s ∩ t) = ∑ f s + ∑ f t
   
   [<a name="SUM_IMAGE_ZERO-val"><b>SUM_IMAGE_ZERO</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ (∑ f s = 0 ⇔ ∀x. x ∈ s ⇒ f x = 0)
   
   [<a name="SUM_IMAGE_lower_bound-val"><b>SUM_IMAGE_lower_bound</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀n. (∀x. x ∈ s ⇒ n ≤ f x) ⇒ CARD s * n ≤ ∑ f s
   
   [<a name="SUM_IMAGE_upper_bound-val"><b>SUM_IMAGE_upper_bound</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀n. (∀x. x ∈ s ⇒ f x ≤ n) ⇒ ∑ f s ≤ CARD s * n
   
   [<a name="SUM_SAME_IMAGE-val"><b>SUM_SAME_IMAGE</b></a>]  Theorem
      
      ⊢ ∀P. FINITE P ⇒
            ∀f p. p ∈ P ∧ (∀q. q ∈ P ⇒ f p = f q) ⇒ ∑ f P = CARD P * f p
   
   [<a name="SUM_SET_DELETE-val"><b>SUM_SET_DELETE</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒
            ∀e. SUM_SET (s DELETE e) =
                if e ∈ s then SUM_SET s − e else SUM_SET s
   
   [<a name="SUM_SET_EMPTY-val"><b>SUM_SET_EMPTY</b></a>]  Theorem
      
      ⊢ SUM_SET ∅ = 0
   
   [<a name="SUM_SET_INSERT-val"><b>SUM_SET_INSERT</b></a>]  Theorem
      
      ⊢ ∀s x. FINITE s ∧ x ∉ s ⇒ SUM_SET (x INSERT s) = x + SUM_SET s
   
   [<a name="SUM_SET_IN_LE-val"><b>SUM_SET_IN_LE</b></a>]  Theorem
      
      ⊢ ∀x s. FINITE s ∧ x ∈ s ⇒ x ≤ SUM_SET s
   
   [<a name="SUM_SET_SING-val"><b>SUM_SET_SING</b></a>]  Theorem
      
      ⊢ ∀n. SUM_SET {n} = n
   
   [<a name="SUM_SET_SUBSET_LE-val"><b>SUM_SET_SUBSET_LE</b></a>]  Theorem
      
      ⊢ ∀s t. FINITE t ∧ s ⊆ t ⇒ SUM_SET s ≤ SUM_SET t
   
   [<a name="SUM_SET_THM-val"><b>SUM_SET_THM</b></a>]  Theorem
      
      ⊢ SUM_SET ∅ = 0 ∧
        ∀x s. FINITE s ⇒ SUM_SET (x INSERT s) = x + SUM_SET (s DELETE x)
   
   [<a name="SUM_SET_UNION-val"><b>SUM_SET_UNION</b></a>]  Theorem
      
      ⊢ ∀s t.
          FINITE s ∧ FINITE t ⇒
          SUM_SET (s ∪ t) = SUM_SET s + SUM_SET t − SUM_SET (s ∩ t)
   
   [<a name="SUM_SET_count-val"><b>SUM_SET_count</b></a>]  Theorem
      
      ⊢ SUM_SET (count n) = n * (n − 1) DIV 2
   
   [<a name="SUM_SET_count_2-val"><b>SUM_SET_count_2</b></a>]  Theorem
      
      ⊢ ∀n. 2 * SUM_SET (count n) = n * (n − 1)
   
   [<a name="SUM_UNIV-val"><b>SUM_UNIV</b></a>]  Theorem
      
      ⊢ 𝕌(:α + β) = IMAGE INL 𝕌(:α) ∪ IMAGE INR 𝕌(:β)
   
   [<a name="SURJECTIVE_IFF_INJECTIVE-val"><b>SURJECTIVE_IFF_INJECTIVE</b></a>]  Theorem
      
      ⊢ ∀s f.
          FINITE s ∧ IMAGE f s ⊆ s ⇒
          ((∀y. y ∈ s ⇒ ∃x. x ∈ s ∧ f x = y) ⇔
           ∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y)
   
   [<a name="SURJECTIVE_IFF_INJECTIVE_GEN-val"><b>SURJECTIVE_IFF_INJECTIVE_GEN</b></a>]  Theorem
      
      ⊢ ∀s t f.
          FINITE s ∧ FINITE t ∧ CARD s = CARD t ∧ IMAGE f s ⊆ t ⇒
          ((∀y. y ∈ t ⇒ ∃x. x ∈ s ∧ f x = y) ⇔
           ∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y)
   
   [<a name="SURJ_CARD-val"><b>SURJ_CARD</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀t. SURJ f s t ⇒ FINITE t ∧ CARD t ≤ CARD s
   
   [<a name="SURJ_COMPOSE-val"><b>SURJ_COMPOSE</b></a>]  Theorem
      
      ⊢ ∀f g s t u. SURJ f s t ∧ SURJ g t u ⇒ SURJ (g ∘ f) s u
   
   [<a name="SURJ_CONG-val"><b>SURJ_CONG</b></a>]  Theorem
      
      ⊢ ∀f g s t. (∀x. x ∈ s ⇒ f x = g x) ⇒ (SURJ f s t ⇔ SURJ g s t)
   
   [<a name="SURJ_ELEMENT-val"><b>SURJ_ELEMENT</b></a>]  Theorem
      
      ⊢ ∀f s t x. SURJ f s t ∧ x ∈ s ⇒ f x ∈ t
   
   [<a name="SURJ_EMPTY-val"><b>SURJ_EMPTY</b></a>]  Theorem
      
      ⊢ ∀f. (∀s. SURJ f ∅ s ⇔ s = ∅) ∧ ∀s. SURJ f s ∅ ⇔ s = ∅
   
   [<a name="SURJ_ID-val"><b>SURJ_ID</b></a>]  Theorem
      
      ⊢ ∀s. SURJ (λx. x) s s
   
   [<a name="SURJ_IMAGE-val"><b>SURJ_IMAGE</b></a>]  Theorem
      
      ⊢ SURJ f s (IMAGE f s)
   
   [<a name="SURJ_IMP_INJ-val"><b>SURJ_IMP_INJ</b></a>]  Theorem
      
      ⊢ ∀s t. (∃f. SURJ f s t) ⇒ ∃g. INJ g t s
   
   [<a name="SURJ_INJ_INV-val"><b>SURJ_INJ_INV</b></a>]  Theorem
      
      ⊢ SURJ f s t ⇒ ∃g. INJ g t s ∧ ∀y. y ∈ t ⇒ f (g y) = y
   
   [<a name="TC_PSUBSET-val"><b>TC_PSUBSET</b></a>]  Theorem
      
      ⊢ $PSUBSET⁺ = $PSUBSET
   
   [<a name="TC_SUBSET_THM-val"><b>TC_SUBSET_THM</b></a>]  Theorem
      
      ⊢ $SUBSET⁺ = $SUBSET
   
   [<a name="UNION_ASSOC-val"><b>UNION_ASSOC</b></a>]  Theorem
      
      ⊢ ∀s t u. s ∪ (t ∪ u) = s ∪ t ∪ u
   
   [<a name="UNION_COMM-val"><b>UNION_COMM</b></a>]  Theorem
      
      ⊢ ∀s t. s ∪ t = t ∪ s
   
   [<a name="UNION_DELETE-val"><b>UNION_DELETE</b></a>]  Theorem
      
      ⊢ ∀A B x. A ∪ B DELETE x = A DELETE x ∪ (B DELETE x)
   
   [<a name="UNION_DIFF-val"><b>UNION_DIFF</b></a>]  Theorem
      
      ⊢ s ⊆ t ⇒ s ∪ (t DIFF s) = t ∧ t DIFF s ∪ s = t
   
   [<a name="UNION_DIFF_2-val"><b>UNION_DIFF_2</b></a>]  Theorem
      
      ⊢ ∀s t. s ∪ (s DIFF t) = s
   
   [<a name="UNION_DIFF_EQ-val"><b>UNION_DIFF_EQ</b></a>]  Theorem
      
      ⊢ (∀s t. s ∪ (t DIFF s) = s ∪ t) ∧ ∀s t. t DIFF s ∪ s = t ∪ s
   
   [<a name="UNION_EMPTY-val"><b>UNION_EMPTY</b></a>]  Theorem
      
      ⊢ (∀s. ∅ ∪ s = s) ∧ ∀s. s ∪ ∅ = s
   
   [<a name="UNION_IDEMPOT-val"><b>UNION_IDEMPOT</b></a>]  Theorem
      
      ⊢ ∀s. s ∪ s = s
   
   [<a name="UNION_OVER_INTER-val"><b>UNION_OVER_INTER</b></a>]  Theorem
      
      ⊢ ∀s t u. s ∩ (t ∪ u) = s ∩ t ∪ s ∩ u
   
   [<a name="UNION_SUBSET-val"><b>UNION_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t u. s ∪ t ⊆ u ⇔ s ⊆ u ∧ t ⊆ u
   
   [<a name="UNION_UNIV-val"><b>UNION_UNIV</b></a>]  Theorem
      
      ⊢ (∀s. 𝕌(:α) ∪ s = 𝕌(:α)) ∧ ∀s. s ∪ 𝕌(:α) = 𝕌(:α)
   
   [<a name="UNION_applied-val"><b>UNION_applied</b></a>]  Theorem
      
      ⊢ ∀s t x. (s ∪ t) x ⇔ x ∈ s ∨ x ∈ t
   
   [<a name="UNIQUE_MEMBER_SING-val"><b>UNIQUE_MEMBER_SING</b></a>]  Theorem
      
      ⊢ ∀x s. x ∈ s ∧ (∀y. y ∈ s ⇒ x = y) ⇔ s = {x}
   
   [<a name="UNIV_BOOL-val"><b>UNIV_BOOL</b></a>]  Theorem
      
      ⊢ 𝕌(:bool) = {T; F}
   
   [<a name="UNIV_FUNSET_UNIV-val"><b>UNIV_FUNSET_UNIV</b></a>]  Theorem
      
      ⊢ FUNSET 𝕌(:α) 𝕌(:β) = 𝕌(:α -&gt; β)
   
   [<a name="UNIV_FUN_TO_BOOL-val"><b>UNIV_FUN_TO_BOOL</b></a>]  Theorem
      
      ⊢ 𝕌(:α -&gt; bool) = POW 𝕌(:α)
   
   [<a name="UNIV_NOT_EMPTY-val"><b>UNIV_NOT_EMPTY</b></a>]  Theorem
      
      ⊢ 𝕌(:α) ≠ ∅
   
   [<a name="UNIV_SUBSET-val"><b>UNIV_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s. 𝕌(:α) ⊆ s ⇔ s = 𝕌(:α)
   
   [<a name="UNIV_applied-val"><b>UNIV_applied</b></a>]  Theorem
      
      ⊢ ∀x. 𝕌(:α) x
   
   [<a name="X_LE_MAX_SET-val"><b>X_LE_MAX_SET</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀x. x ∈ s ⇒ x ≤ MAX_SET s
   
   [<a name="bigunion_countable-val"><b>bigunion_countable</b></a>]  Theorem
      
      ⊢ ∀s. countable s ∧ (∀x. x ∈ s ⇒ countable x) ⇒
            countable (BIGUNION s)
   
   [<a name="chooser_compute-val"><b>chooser_compute</b></a>]  Theorem
      
      ⊢ (∀s. chooser s 0 = CHOICE s) ∧
        (∀s n.
           chooser s &lt;..num comp'n..&gt; =
           chooser (REST s) (&lt;..num comp'n..&gt; − 1)) ∧
        ∀s n.
          chooser s &lt;..num comp'n..&gt; = chooser (REST s) &lt;..num comp'n..&gt;
   
   [<a name="compl_insert-val"><b>compl_insert</b></a>]  Theorem
      
      ⊢ ∀s x. COMPL (x INSERT s) = COMPL s DELETE x
   
   [<a name="count_EQN-val"><b>count_EQN</b></a>]  Theorem
      
      ⊢ ∀n. count n =
            if n = 0 then ∅ else (let p = PRE n in p INSERT count p)
   
   [<a name="count_add-val"><b>count_add</b></a>]  Theorem
      
      ⊢ ∀n m. count (n + m) = count n ∪ IMAGE ($+ n) (count m)
   
   [<a name="count_add1-val"><b>count_add1</b></a>]  Theorem
      
      ⊢ ∀n. count (n + 1) = n INSERT count n
   
   [<a name="countable_EMPTY-val"><b>countable_EMPTY</b></a>]  Theorem
      
      ⊢ countable ∅
   
   [<a name="countable_INSERT-val"><b>countable_INSERT</b></a>]  Theorem
      
      ⊢ countable (x INSERT s) ⇔ countable s
   
   [<a name="countable_Uprod-val"><b>countable_Uprod</b></a>]  Theorem
      
      ⊢ countable 𝕌(:α # β) ⇔ countable 𝕌(:α) ∧ countable 𝕌(:β)
   
   [<a name="countable_Usum-val"><b>countable_Usum</b></a>]  Theorem
      
      ⊢ countable 𝕌(:α + β) ⇔ countable 𝕌(:α) ∧ countable 𝕌(:β)
   
   [<a name="countable_image_nats-val"><b>countable_image_nats</b></a>]  Theorem
      
      ⊢ countable (IMAGE f 𝕌(:num))
   
   [<a name="countable_surj-val"><b>countable_surj</b></a>]  Theorem
      
      ⊢ ∀s. countable s ⇔ s = ∅ ∨ ∃f. SURJ f 𝕌(:num) s
   
   [<a name="cross_countable-val"><b>cross_countable</b></a>]  Theorem
      
      ⊢ ∀s t. countable s ∧ countable t ⇒ countable (s × t)
   
   [<a name="cross_countable_IFF-val"><b>cross_countable_IFF</b></a>]  Theorem
      
      ⊢ countable (s × t) ⇔ s = ∅ ∨ t = ∅ ∨ countable s ∧ countable t
   
   [<a name="disjUNION_EQ_EMPTY-val"><b>disjUNION_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ x ⊔ y = ∅ ⇔ x = ∅ ∧ y = ∅
   
   [<a name="disjUNION_UNIV-val"><b>disjUNION_UNIV</b></a>]  Theorem
      
      ⊢ 𝕌(:α + β) = 𝕌(:α) ⊔ 𝕌(:β)
   
   [<a name="disjointD-val"><b>disjointD</b></a>]  Theorem
      
      ⊢ ∀A a b. disjoint A ⇒ a ∈ A ⇒ b ∈ A ⇒ a ≠ b ⇒ DISJOINT a b
   
   [<a name="disjointI-val"><b>disjointI</b></a>]  Theorem
      
      ⊢ ∀A. (∀a b. a ∈ A ⇒ b ∈ A ⇒ a ≠ b ⇒ DISJOINT a b) ⇒ disjoint A
   
   [<a name="disjoint_def-val"><b>disjoint_def</b></a>]  Theorem
      
      ⊢ ∀A. disjoint A ⇔ ∀a b. a ∈ A ∧ b ∈ A ∧ a ≠ b ⇒ DISJOINT a b
   
   [<a name="disjoint_empty-val"><b>disjoint_empty</b></a>]  Theorem
      
      ⊢ disjoint ∅
   
   [<a name="disjoint_image-val"><b>disjoint_image</b></a>]  Theorem
      
      ⊢ ∀f. (∀i j. i ≠ j ⇒ DISJOINT (f i) (f j)) ⇒ disjoint (IMAGE f 𝕌(:α))
   
   [<a name="disjoint_insert-val"><b>disjoint_insert</b></a>]  Theorem
      
      ⊢ ∀e c.
          disjoint c ∧ (∀x. x ∈ c ⇒ DISJOINT x e) ⇒ disjoint (e INSERT c)
   
   [<a name="disjoint_insert_imp-val"><b>disjoint_insert_imp</b></a>]  Theorem
      
      ⊢ ∀e c. disjoint (e INSERT c) ⇒ disjoint c
   
   [<a name="disjoint_insert_notin-val"><b>disjoint_insert_notin</b></a>]  Theorem
      
      ⊢ ∀e c. disjoint (e INSERT c) ∧ e ∉ c ⇒ ∀s. s ∈ c ⇒ DISJOINT e s
   
   [<a name="disjoint_restrict-val"><b>disjoint_restrict</b></a>]  Theorem
      
      ⊢ ∀e c. disjoint c ⇒ disjoint (IMAGE ($INTER e) c)
   
   [<a name="disjoint_same-val"><b>disjoint_same</b></a>]  Theorem
      
      ⊢ ∀s t. s = t ⇒ disjoint {s; t}
   
   [<a name="disjoint_sing-val"><b>disjoint_sing</b></a>]  Theorem
      
      ⊢ ∀a. disjoint {a}
   
   [<a name="disjoint_two-val"><b>disjoint_two</b></a>]  Theorem
      
      ⊢ ∀s t. s ≠ t ∧ DISJOINT s t ⇒ disjoint {s; t}
   
   [<a name="disjoint_union-val"><b>disjoint_union</b></a>]  Theorem
      
      ⊢ ∀A B.
          disjoint A ∧ disjoint B ∧ BIGUNION A ∩ BIGUNION B = ∅ ⇒
          disjoint (A ∪ B)
   
   [<a name="empty_partitions-val"><b>empty_partitions</b></a>]  Theorem
      
      ⊢ ∀s. ∅ partitions s ⇔ s = ∅
   
   [<a name="empty_refines-val"><b>empty_refines</b></a>]  Theorem
      
      ⊢ ∀v. ∅ refines v
   
   [<a name="equiv_class_eq-val"><b>equiv_class_eq</b></a>]  Theorem
      
      ⊢ ∀R s x y.
          R equiv_on s ∧ x ∈ s ∧ y ∈ s ⇒
          (equiv_class R s x = equiv_class R s y ⇔ R x y)
   
   [<a name="equiv_on_subset-val"><b>equiv_on_subset</b></a>]  Theorem
      
      ⊢ ∀R s t. R equiv_on s ∧ t ⊆ s ⇒ R equiv_on t
   
   [<a name="equivalence_same_part-val"><b>equivalence_same_part</b></a>]  Theorem
      
      ⊢ equivalence (λx y. part v x = part v y)
   
   [<a name="finite_countable-val"><b>finite_countable</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ countable s
   
   [<a name="image_countable-val"><b>image_countable</b></a>]  Theorem
      
      ⊢ ∀f s. countable s ⇒ countable (IMAGE f s)
   
   [<a name="in_max_set-val"><b>in_max_set</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∀x. x ∈ s ⇒ x ≤ MAX_SET s
   
   [<a name="in_part-val"><b>in_part</b></a>]  Theorem
      
      ⊢ ∀w v x. v partitions w ∧ x ∈ w ⇒ x ∈ part v x
   
   [<a name="infinite_num_inj-val"><b>infinite_num_inj</b></a>]  Theorem
      
      ⊢ ∀s. INFINITE s ⇔ ∃f. INJ f 𝕌(:num) s
   
   [<a name="infinite_pow_uncountable-val"><b>infinite_pow_uncountable</b></a>]  Theorem
      
      ⊢ ∀s. INFINITE s ⇒ ¬countable (POW s)
   
   [<a name="infinite_rest-val"><b>infinite_rest</b></a>]  Theorem
      
      ⊢ ∀s. INFINITE s ⇒ INFINITE (REST s)
   
   [<a name="inj_countable-val"><b>inj_countable</b></a>]  Theorem
      
      ⊢ ∀f s t. countable t ∧ INJ f s t ⇒ countable s
   
   [<a name="inj_image_countable_IFF-val"><b>inj_image_countable_IFF</b></a>]  Theorem
      
      ⊢ INJ f s (IMAGE f s) ⇒ (countable (IMAGE f s) ⇔ countable s)
   
   [<a name="inj_surj-val"><b>inj_surj</b></a>]  Theorem
      
      ⊢ ∀f s t. INJ f s t ⇒ s = ∅ ∨ ∃f'. SURJ f' t s
   
   [<a name="inter_countable-val"><b>inter_countable</b></a>]  Theorem
      
      ⊢ ∀s t. countable s ∨ countable t ⇒ countable (s ∩ t)
   
   [<a name="inv_image_equiv_on-val"><b>inv_image_equiv_on</b></a>]  Theorem
      
      ⊢ ∀R Y f. R equiv_on Y ⇒ inv_image R f equiv_on {x | f x ∈ Y}
   
   [<a name="is_measure_maximal_INSERT-val"><b>is_measure_maximal_INSERT</b></a>]  Theorem
      
      ⊢ ∀x s m e y.
          x ∈ s ∧ m e &lt; m x ⇒
          (is_measure_maximal m (e INSERT s) y ⇔ is_measure_maximal m s y)
   
   [<a name="is_measure_maximal_SING-val"><b>is_measure_maximal_SING</b></a>]  Theorem
      
      ⊢ is_measure_maximal m {x} y ⇔ y = x
   
   [<a name="num_FINITE-val"><b>num_FINITE</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇔ ∃a. ∀x. x ∈ s ⇒ x ≤ a
   
   [<a name="num_FINITE_AVOID-val"><b>num_FINITE_AVOID</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ ∃a. a ∉ s
   
   [<a name="num_INFINITE-val"><b>num_INFINITE</b></a>]  Theorem
      
      ⊢ INFINITE 𝕌(:num)
   
   [<a name="num_countable-val"><b>num_countable</b></a>]  Theorem
      
      ⊢ countable 𝕌(:num)
   
   [<a name="pair_to_num_formula-val"><b>pair_to_num_formula</b></a>]  Theorem
      
      ⊢ ∀x y. pair_to_num (x,y) = (x + y + 1) * (x + y) DIV 2 + y
   
   [<a name="pair_to_num_inv-val"><b>pair_to_num_inv</b></a>]  Theorem
      
      ⊢ (∀x. pair_to_num (num_to_pair x) = x) ∧
        ∀x y. num_to_pair (pair_to_num (x,y)) = (x,y)
   
   [<a name="pair_to_num_inv'-val"><b>pair_to_num_inv'</b></a>]  Theorem
      
      ⊢ (∀x. pair_to_num (num_to_pair x) = x) ∧
        ∀x. num_to_pair (pair_to_num x) = x
   
   [<a name="pairwise_EMPTY-val"><b>pairwise_EMPTY</b></a>]  Theorem
      
      ⊢ ∀r. pairwise r ∅
   
   [<a name="pairwise_SUBSET-val"><b>pairwise_SUBSET</b></a>]  Theorem
      
      ⊢ ∀R s t. pairwise R t ∧ s ⊆ t ⇒ pairwise R s
   
   [<a name="pairwise_UNION-val"><b>pairwise_UNION</b></a>]  Theorem
      
      ⊢ pairwise R (s1 ∪ s2) ⇔
        pairwise R s1 ∧ pairwise R s2 ∧
        ∀x y. x ∈ s1 ∧ y ∈ s2 ⇒ R x y ∧ R y x
   
   [<a name="part_SING-val"><b>part_SING</b></a>]  Theorem
      
      ⊢ ∀x w. x ∈ w ⇒ part {w} x = w
   
   [<a name="part_in_partition-val"><b>part_in_partition</b></a>]  Theorem
      
      ⊢ ∀w v x. v partitions w ∧ x ∈ w ⇒ part v x ∈ v
   
   [<a name="part_partition-val"><b>part_partition</b></a>]  Theorem
      
      ⊢ ∀R w y.
          y ∈ w ∧ R equiv_on w ⇒
          part (partition R w) y = {x | x ∈ w ∧ R x y}
   
   [<a name="part_unique-val"><b>part_unique</b></a>]  Theorem
      
      ⊢ ∀w v x s. v partitions w ∧ x ∈ w ∧ x ∈ s ∧ s ∈ v ⇒ s = part v x
   
   [<a name="partition_CARD-val"><b>partition_CARD</b></a>]  Theorem
      
      ⊢ ∀R s. R equiv_on s ∧ FINITE s ⇒ CARD s = ∑ CARD (partition R s)
   
   [<a name="partition_SUBSET-val"><b>partition_SUBSET</b></a>]  Theorem
      
      ⊢ ∀R s t. t ∈ partition R s ⇒ t ⊆ s
   
   [<a name="partition_elements_disjoint-val"><b>partition_elements_disjoint</b></a>]  Theorem
      
      ⊢ R equiv_on s ⇒
        ∀t1 t2.
          t1 ∈ partition R s ∧ t2 ∈ partition R s ∧ t1 ≠ t2 ⇒
          DISJOINT t1 t2
   
   [<a name="partition_elements_interrelate-val"><b>partition_elements_interrelate</b></a>]  Theorem
      
      ⊢ R equiv_on s ⇒ ∀t. t ∈ partition R s ⇒ ∀x y. x ∈ t ∧ y ∈ t ⇒ R x y
   
   [<a name="partition_rel_eq-val"><b>partition_rel_eq</b></a>]  Theorem
      
      ⊢ ∀R1 R2 Y.
          R1 equiv_on Y ∧ R2 equiv_on Y ∧ partition R1 Y = partition R2 Y ⇒
          ∀x y. x ∈ Y ∧ y ∈ Y ⇒ (R1 x y ⇔ R2 x y)
   
   [<a name="partitions_DISJOINT-val"><b>partitions_DISJOINT</b></a>]  Theorem
      
      ⊢ ∀v w s1 s2.
          v partitions w ∧ s1 ∈ v ∧ s2 ∈ v ∧ s1 ≠ s2 ⇒ DISJOINT s1 s2
   
   [<a name="partitions_FINITE-val"><b>partitions_FINITE</b></a>]  Theorem
      
      ⊢ ∀X Y. X partitions Y ∧ FINITE Y ⇒ FINITE X ∧ ∀s. s ∈ X ⇒ FINITE s
   
   [<a name="partitions_INSERT-val"><b>partitions_INSERT</b></a>]  Theorem
      
      ⊢ ∀x w v.
          x ∉ w ⇒
          (v partitions x INSERT w ⇔
           ∃u s.
             u partitions w ∧ v = (x INSERT s) INSERT u DELETE s ∧
             (s ≠ ∅ ⇒ s ∈ u))
   
   [<a name="partitions_PAIR_DISJOINT-val"><b>partitions_PAIR_DISJOINT</b></a>]  Theorem
      
      ⊢ ∀x y.
          x partitions y ⇔
          ∅ ∉ x ∧ (∀s t. s ∈ x ∧ t ∈ x ∧ s ≠ t ⇒ DISJOINT s t) ∧
          BIGUNION x = y
   
   [<a name="partitions_SING-val"><b>partitions_SING</b></a>]  Theorem
      
      ⊢ ∀v x. SING x ⇒ (v partitions x ⇔ v = {{CHOICE x}})
   
   [<a name="partitions_covers-val"><b>partitions_covers</b></a>]  Theorem
      
      ⊢ ∀x y. x partitions y ⇒ BIGUNION x = y
   
   [<a name="partitions_empty-val"><b>partitions_empty</b></a>]  Theorem
      
      ⊢ ∀v. v partitions ∅ ⇔ v = ∅
   
   [<a name="partitions_inj-val"><b>partitions_inj</b></a>]  Theorem
      
      ⊢ ∀x w1 w2. x partitions w1 ∧ x partitions w2 ⇒ w1 = w2
   
   [<a name="partitions_thm-val"><b>partitions_thm</b></a>]  Theorem
      
      ⊢ ∀X Y.
          X partitions Y ⇔
          (∀x. x ∈ X ⇒ x ≠ ∅ ∧ x ⊆ Y) ∧ ∀y. y ∈ Y ⇒ ∃!x. x ∈ X ∧ y ∈ x
   
   [<a name="pow_no_surj-val"><b>pow_no_surj</b></a>]  Theorem
      
      ⊢ ∀s. ¬∃f. SURJ f s (POW s)
   
   [<a name="prime_PROD_IMAGE-val"><b>prime_PROD_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s.
          FINITE s ⇒
          (prime (Π f s) ⇔
           ∃p. IMAGE f s ⊆ {1; p} ∧ prime p ∧ ∃!x. x ∈ s ∧ f x = p)
   
   [<a name="refines_antisym-val"><b>refines_antisym</b></a>]  Theorem
      
      ⊢ ∀w v1 v2.
          v1 partitions w ∧ v2 partitions w ∧ v1 refines v2 ∧ v2 refines v1 ⇒
          v1 = v2
   
   [<a name="refines_grows_parts-val"><b>refines_grows_parts</b></a>]  Theorem
      
      ⊢ ∀w v1 v2.
          v1 partitions w ∧ v2 partitions w ⇒
          (v1 refines v2 ⇔
           ∀x y.
             x ∈ w ∧ y ∈ w ∧ part v1 x = part v1 y ⇒ part v2 x = part v2 y)
   
   [<a name="refines_refl-val"><b>refines_refl</b></a>]  Theorem
      
      ⊢ ∀v. v refines v
   
   [<a name="refines_transitive-val"><b>refines_transitive</b></a>]  Theorem
      
      ⊢ ∀v1 v2 v3. v1 refines v2 ∧ v2 refines v3 ⇒ v1 refines v3
   
   [<a name="subset_countable-val"><b>subset_countable</b></a>]  Theorem
      
      ⊢ ∀s t. countable s ∧ t ⊆ s ⇒ countable t
   
   [<a name="transitive_PSUBSET-val"><b>transitive_PSUBSET</b></a>]  Theorem
      
      ⊢ transitive $PSUBSET
   
   [<a name="union_countable-val"><b>union_countable</b></a>]  Theorem
      
      ⊢ ∀s t. countable s ∧ countable t ⇒ countable (s ∪ t)
   
   [<a name="union_countable_IFF-val"><b>union_countable_IFF</b></a>]  Theorem
      
      ⊢ countable (s ∪ t) ⇔ countable s ∧ countable t
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/pred_set/src/pred_setScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-2</a></em></p></body></html>
