<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure sigma_algebraTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure sigma_algebraTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/probability/.hol/objs/sigma_algebraScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature sigma_algebraTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#algebra_def-val">algebra_def</a> : thm
<a name="line7"></a>    val <a href="#binary_def-val">binary_def</a> : thm
<a name="line8"></a>    val <a href="#disjoint_family_on-val">disjoint_family_on</a> : thm
<a name="line9"></a>    val <a href="#disjointed-val">disjointed</a> : thm
<a name="line10"></a>    val <a href="#dynkin_def-val">dynkin_def</a> : thm
<a name="line11"></a>    val <a href="#dynkin_system_def-val">dynkin_system_def</a> : thm
<a name="line12"></a>    val <a href="#measurable_def-val">measurable_def</a> : thm
<a name="line13"></a>    val <a href="#prod_sets_def-val">prod_sets_def</a> : thm
<a name="line14"></a>    val <a href="#prod_sigma_def-val">prod_sigma_def</a> : thm
<a name="line15"></a>    val <a href="#restrict_algebra_def-val">restrict_algebra_def</a> : thm
<a name="line16"></a>    val <a href="#ring_def-val">ring_def</a> : thm
<a name="line17"></a>    val <a href="#semiring_def-val">semiring_def</a> : thm
<a name="line18"></a>    val <a href="#set_liminf_def-val">set_liminf_def</a> : thm
<a name="line19"></a>    val <a href="#set_limsup_def-val">set_limsup_def</a> : thm
<a name="line20"></a>    val <a href="#sigma_algebra_alt-val">sigma_algebra_alt</a> : thm
<a name="line21"></a>    val <a href="#sigma_algebra_def-val">sigma_algebra_def</a> : thm
<a name="line22"></a>    val <a href="#sigma_def-val">sigma_def</a> : thm
<a name="line23"></a>    val <a href="#sigma_function_def-val">sigma_function_def</a> : thm
<a name="line24"></a>    val <a href="#sigma_functions_def-val">sigma_functions_def</a> : thm
<a name="line25"></a>    val <a href="#smallest_ring_def-val">smallest_ring_def</a> : thm
<a name="line26"></a>    val <a href="#space_def-val">space_def</a> : thm
<a name="line27"></a>    val <a href="#subset_class_def-val">subset_class_def</a> : thm
<a name="line28"></a>    val <a href="#subsets_def-val">subsets_def</a> : thm
<a name="line29"></a>  
<a name="line30"></a>  (*  Theorems  *)
<a name="line31"></a>    val <a href="#ALGEBRA_ALT_INTER-val">ALGEBRA_ALT_INTER</a> : thm
<a name="line32"></a>    val <a href="#ALGEBRA_COMPL-val">ALGEBRA_COMPL</a> : thm
<a name="line33"></a>    val <a href="#ALGEBRA_COMPL_SETS-val">ALGEBRA_COMPL_SETS</a> : thm
<a name="line34"></a>    val <a href="#ALGEBRA_DIFF-val">ALGEBRA_DIFF</a> : thm
<a name="line35"></a>    val <a href="#ALGEBRA_EMPTY-val">ALGEBRA_EMPTY</a> : thm
<a name="line36"></a>    val <a href="#ALGEBRA_FINITE_INTER-val">ALGEBRA_FINITE_INTER</a> : thm
<a name="line37"></a>    val <a href="#ALGEBRA_FINITE_INTER'-val">ALGEBRA_FINITE_INTER'</a> : thm
<a name="line38"></a>    val <a href="#ALGEBRA_FINITE_UNION-val">ALGEBRA_FINITE_UNION</a> : thm
<a name="line39"></a>    val <a href="#ALGEBRA_IMP_RING-val">ALGEBRA_IMP_RING</a> : thm
<a name="line40"></a>    val <a href="#ALGEBRA_IMP_SEMIRING-val">ALGEBRA_IMP_SEMIRING</a> : thm
<a name="line41"></a>    val <a href="#ALGEBRA_INTER-val">ALGEBRA_INTER</a> : thm
<a name="line42"></a>    val <a href="#ALGEBRA_INTER_SPACE-val">ALGEBRA_INTER_SPACE</a> : thm
<a name="line43"></a>    val <a href="#ALGEBRA_RESTRICT-val">ALGEBRA_RESTRICT</a> : thm
<a name="line44"></a>    val <a href="#ALGEBRA_RESTRICT'-val">ALGEBRA_RESTRICT'</a> : thm
<a name="line45"></a>    val <a href="#ALGEBRA_SETS_COLLECT_CONST-val">ALGEBRA_SETS_COLLECT_CONST</a> : thm
<a name="line46"></a>    val <a href="#ALGEBRA_SETS_COLLECT_IMP-val">ALGEBRA_SETS_COLLECT_IMP</a> : thm
<a name="line47"></a>    val <a href="#ALGEBRA_SETS_COLLECT_NEG-val">ALGEBRA_SETS_COLLECT_NEG</a> : thm
<a name="line48"></a>    val <a href="#ALGEBRA_SINGLE_SET-val">ALGEBRA_SINGLE_SET</a> : thm
<a name="line49"></a>    val <a href="#ALGEBRA_SPACE-val">ALGEBRA_SPACE</a> : thm
<a name="line50"></a>    val <a href="#ALGEBRA_UNION-val">ALGEBRA_UNION</a> : thm
<a name="line51"></a>    val <a href="#BIGINTER_OVER_INTER_L-val">BIGINTER_OVER_INTER_L</a> : thm
<a name="line52"></a>    val <a href="#BIGINTER_OVER_INTER_R-val">BIGINTER_OVER_INTER_R</a> : thm
<a name="line53"></a>    val <a href="#BIGINTER_PAIR-val">BIGINTER_PAIR</a> : thm
<a name="line54"></a>    val <a href="#BIGUNION_IMAGE_BIGUNION_IMAGE_UNIV-val">BIGUNION_IMAGE_BIGUNION_IMAGE_UNIV</a> : thm
<a name="line55"></a>    val <a href="#BIGUNION_IMAGE_COUNT_IMP_UNIV-val">BIGUNION_IMAGE_COUNT_IMP_UNIV</a> : thm
<a name="line56"></a>    val <a href="#BIGUNION_IMAGE_UNIV_CROSS_UNIV-val">BIGUNION_IMAGE_UNIV_CROSS_UNIV</a> : thm
<a name="line57"></a>    val <a href="#BIGUNION_OVER_DIFF-val">BIGUNION_OVER_DIFF</a> : thm
<a name="line58"></a>    val <a href="#BIGUNION_OVER_INTER_L-val">BIGUNION_OVER_INTER_L</a> : thm
<a name="line59"></a>    val <a href="#BIGUNION_OVER_INTER_R-val">BIGUNION_OVER_INTER_R</a> : thm
<a name="line60"></a>    val <a href="#BIGUNION_disjointed-val">BIGUNION_disjointed</a> : thm
<a name="line61"></a>    val <a href="#BINARY_RANGE-val">BINARY_RANGE</a> : thm
<a name="line62"></a>    val <a href="#COMPL_BIGINTER-val">COMPL_BIGINTER</a> : thm
<a name="line63"></a>    val <a href="#COMPL_BIGINTER_IMAGE-val">COMPL_BIGINTER_IMAGE</a> : thm
<a name="line64"></a>    val <a href="#COMPL_BIGUNION-val">COMPL_BIGUNION</a> : thm
<a name="line65"></a>    val <a href="#COMPL_BIGUNION_IMAGE-val">COMPL_BIGUNION_IMAGE</a> : thm
<a name="line66"></a>    val <a href="#DIFF_INTER_PAIR-val">DIFF_INTER_PAIR</a> : thm
<a name="line67"></a>    val <a href="#DINTER_IMP_FINITE_INTER-val">DINTER_IMP_FINITE_INTER</a> : thm
<a name="line68"></a>    val <a href="#DISJOINT_CROSS_L-val">DISJOINT_CROSS_L</a> : thm
<a name="line69"></a>    val <a href="#DISJOINT_CROSS_R-val">DISJOINT_CROSS_R</a> : thm
<a name="line70"></a>    val <a href="#DISJOINT_RESTRICT_L-val">DISJOINT_RESTRICT_L</a> : thm
<a name="line71"></a>    val <a href="#DISJOINT_RESTRICT_R-val">DISJOINT_RESTRICT_R</a> : thm
<a name="line72"></a>    val <a href="#DUNION_IMP_FINITE_UNION-val">DUNION_IMP_FINITE_UNION</a> : thm
<a name="line73"></a>    val <a href="#DYNKIN-val">DYNKIN</a> : thm
<a name="line74"></a>    val <a href="#DYNKIN_LEMMA-val">DYNKIN_LEMMA</a> : thm
<a name="line75"></a>    val <a href="#DYNKIN_MONOTONE-val">DYNKIN_MONOTONE</a> : thm
<a name="line76"></a>    val <a href="#DYNKIN_SMALLEST-val">DYNKIN_SMALLEST</a> : thm
<a name="line77"></a>    val <a href="#DYNKIN_STABLE-val">DYNKIN_STABLE</a> : thm
<a name="line78"></a>    val <a href="#DYNKIN_STABLE_LEMMA-val">DYNKIN_STABLE_LEMMA</a> : thm
<a name="line79"></a>    val <a href="#DYNKIN_SUBSET-val">DYNKIN_SUBSET</a> : thm
<a name="line80"></a>    val <a href="#DYNKIN_SUBSET_SIGMA-val">DYNKIN_SUBSET_SIGMA</a> : thm
<a name="line81"></a>    val <a href="#DYNKIN_SUBSET_SUBSETS-val">DYNKIN_SUBSET_SUBSETS</a> : thm
<a name="line82"></a>    val <a href="#DYNKIN_SYSTEM_ALT-val">DYNKIN_SYSTEM_ALT</a> : thm
<a name="line83"></a>    val <a href="#DYNKIN_SYSTEM_ALT_MONO-val">DYNKIN_SYSTEM_ALT_MONO</a> : thm
<a name="line84"></a>    val <a href="#DYNKIN_SYSTEM_COMPL-val">DYNKIN_SYSTEM_COMPL</a> : thm
<a name="line85"></a>    val <a href="#DYNKIN_SYSTEM_COUNTABLY_DUNION-val">DYNKIN_SYSTEM_COUNTABLY_DUNION</a> : thm
<a name="line86"></a>    val <a href="#DYNKIN_SYSTEM_DUNION-val">DYNKIN_SYSTEM_DUNION</a> : thm
<a name="line87"></a>    val <a href="#DYNKIN_SYSTEM_EMPTY-val">DYNKIN_SYSTEM_EMPTY</a> : thm
<a name="line88"></a>    val <a href="#DYNKIN_SYSTEM_INCREASING-val">DYNKIN_SYSTEM_INCREASING</a> : thm
<a name="line89"></a>    val <a href="#DYNKIN_SYSTEM_SPACE-val">DYNKIN_SYSTEM_SPACE</a> : thm
<a name="line90"></a>    val <a href="#DYNKIN_THM-val">DYNKIN_THM</a> : thm
<a name="line91"></a>    val <a href="#FINITE_TWO-val">FINITE_TWO</a> : thm
<a name="line92"></a>    val <a href="#GBIGUNION_IMAGE-val">GBIGUNION_IMAGE</a> : thm
<a name="line93"></a>    val <a href="#GEN_COMPL_BIGINTER-val">GEN_COMPL_BIGINTER</a> : thm
<a name="line94"></a>    val <a href="#GEN_COMPL_BIGINTER_IMAGE-val">GEN_COMPL_BIGINTER_IMAGE</a> : thm
<a name="line95"></a>    val <a href="#GEN_COMPL_BIGUNION-val">GEN_COMPL_BIGUNION</a> : thm
<a name="line96"></a>    val <a href="#GEN_COMPL_BIGUNION_IMAGE-val">GEN_COMPL_BIGUNION_IMAGE</a> : thm
<a name="line97"></a>    val <a href="#GEN_COMPL_FINITE_INTER-val">GEN_COMPL_FINITE_INTER</a> : thm
<a name="line98"></a>    val <a href="#GEN_COMPL_FINITE_UNION-val">GEN_COMPL_FINITE_UNION</a> : thm
<a name="line99"></a>    val <a href="#GEN_COMPL_INTER-val">GEN_COMPL_INTER</a> : thm
<a name="line100"></a>    val <a href="#GEN_COMPL_UNION-val">GEN_COMPL_UNION</a> : thm
<a name="line101"></a>    val <a href="#GEN_DIFF_INTER-val">GEN_DIFF_INTER</a> : thm
<a name="line102"></a>    val <a href="#IMAGE_SIGMA-val">IMAGE_SIGMA</a> : thm
<a name="line103"></a>    val <a href="#IMAGE_SIGMA_ALGEBRA-val">IMAGE_SIGMA_ALGEBRA</a> : thm
<a name="line104"></a>    val <a href="#INCREASING_TO_DISJOINT_SETS-val">INCREASING_TO_DISJOINT_SETS</a> : thm
<a name="line105"></a>    val <a href="#INCREASING_TO_DISJOINT_SETS'-val">INCREASING_TO_DISJOINT_SETS'</a> : thm
<a name="line106"></a>    val <a href="#INTER_BINARY-val">INTER_BINARY</a> : thm
<a name="line107"></a>    val <a href="#INTER_SPACE_EQ1-val">INTER_SPACE_EQ1</a> : thm
<a name="line108"></a>    val <a href="#INTER_SPACE_REDUCE-val">INTER_SPACE_REDUCE</a> : thm
<a name="line109"></a>    val <a href="#IN_DYNKIN-val">IN_DYNKIN</a> : thm
<a name="line110"></a>    val <a href="#IN_LIMINF-val">IN_LIMINF</a> : thm
<a name="line111"></a>    val <a href="#IN_LIMSUP-val">IN_LIMSUP</a> : thm
<a name="line112"></a>    val <a href="#IN_MEASURABLE-val">IN_MEASURABLE</a> : thm
<a name="line113"></a>    val <a href="#IN_MEASURABLE_COMP-val">IN_MEASURABLE_COMP</a> : thm
<a name="line114"></a>    val <a href="#IN_MEASURABLE_CONG-val">IN_MEASURABLE_CONG</a> : thm
<a name="line115"></a>    val <a href="#IN_MEASURABLE_EQ-val">IN_MEASURABLE_EQ</a> : thm
<a name="line116"></a>    val <a href="#IN_MEASURABLE_PROD_SIGMA-val">IN_MEASURABLE_PROD_SIGMA</a> : thm
<a name="line117"></a>    val <a href="#IN_PROD_SETS-val">IN_PROD_SETS</a> : thm
<a name="line118"></a>    val <a href="#IN_SIGMA-val">IN_SIGMA</a> : thm
<a name="line119"></a>    val <a href="#IN_SPACE_PROD_SIGMA-val">IN_SPACE_PROD_SIGMA</a> : thm
<a name="line120"></a>    val <a href="#LIMSUP_COMPL-val">LIMSUP_COMPL</a> : thm
<a name="line121"></a>    val <a href="#LIMSUP_DIFF-val">LIMSUP_DIFF</a> : thm
<a name="line122"></a>    val <a href="#LIMSUP_MONO_STRONG-val">LIMSUP_MONO_STRONG</a> : thm
<a name="line123"></a>    val <a href="#LIMSUP_MONO_STRONGER-val">LIMSUP_MONO_STRONGER</a> : thm
<a name="line124"></a>    val <a href="#LIMSUP_MONO_WEAK-val">LIMSUP_MONO_WEAK</a> : thm
<a name="line125"></a>    val <a href="#MEASUBABLE_BIGUNION_LEMMA-val">MEASUBABLE_BIGUNION_LEMMA</a> : thm
<a name="line126"></a>    val <a href="#MEASURABLE_BIGUNION_PROPERTY-val">MEASURABLE_BIGUNION_PROPERTY</a> : thm
<a name="line127"></a>    val <a href="#MEASURABLE_COMP-val">MEASURABLE_COMP</a> : thm
<a name="line128"></a>    val <a href="#MEASURABLE_COMP_STRONG-val">MEASURABLE_COMP_STRONG</a> : thm
<a name="line129"></a>    val <a href="#MEASURABLE_COMP_STRONGER-val">MEASURABLE_COMP_STRONGER</a> : thm
<a name="line130"></a>    val <a href="#MEASURABLE_DIFF_PROPERTY-val">MEASURABLE_DIFF_PROPERTY</a> : thm
<a name="line131"></a>    val <a href="#MEASURABLE_FST-val">MEASURABLE_FST</a> : thm
<a name="line132"></a>    val <a href="#MEASURABLE_I-val">MEASURABLE_I</a> : thm
<a name="line133"></a>    val <a href="#MEASURABLE_LEMMA-val">MEASURABLE_LEMMA</a> : thm
<a name="line134"></a>    val <a href="#MEASURABLE_LIFT-val">MEASURABLE_LIFT</a> : thm
<a name="line135"></a>    val <a href="#MEASURABLE_PAIR-val">MEASURABLE_PAIR</a> : thm
<a name="line136"></a>    val <a href="#MEASURABLE_PROD_SIGMA-val">MEASURABLE_PROD_SIGMA</a> : thm
<a name="line137"></a>    val <a href="#MEASURABLE_PROD_SIGMA'-val">MEASURABLE_PROD_SIGMA'</a> : thm
<a name="line138"></a>    val <a href="#MEASURABLE_SIGMA-val">MEASURABLE_SIGMA</a> : thm
<a name="line139"></a>    val <a href="#MEASURABLE_SIGMA_PREIMAGES-val">MEASURABLE_SIGMA_PREIMAGES</a> : thm
<a name="line140"></a>    val <a href="#MEASURABLE_SND-val">MEASURABLE_SND</a> : thm
<a name="line141"></a>    val <a href="#MEASURABLE_SUBSET-val">MEASURABLE_SUBSET</a> : thm
<a name="line142"></a>    val <a href="#MEASURABLE_UP_LIFT-val">MEASURABLE_UP_LIFT</a> : thm
<a name="line143"></a>    val <a href="#MEASURABLE_UP_SIGMA-val">MEASURABLE_UP_SIGMA</a> : thm
<a name="line144"></a>    val <a href="#MEASURABLE_UP_SUBSET-val">MEASURABLE_UP_SUBSET</a> : thm
<a name="line145"></a>    val <a href="#POW_ALGEBRA-val">POW_ALGEBRA</a> : thm
<a name="line146"></a>    val <a href="#POW_SIGMA_ALGEBRA-val">POW_SIGMA_ALGEBRA</a> : thm
<a name="line147"></a>    val <a href="#PREIMAGE_SIGMA-val">PREIMAGE_SIGMA</a> : thm
<a name="line148"></a>    val <a href="#PREIMAGE_SIGMA_ALGEBRA-val">PREIMAGE_SIGMA_ALGEBRA</a> : thm
<a name="line149"></a>    val <a href="#RING_BIGUNION-val">RING_BIGUNION</a> : thm
<a name="line150"></a>    val <a href="#RING_DIFF-val">RING_DIFF</a> : thm
<a name="line151"></a>    val <a href="#RING_DIFF_ALT-val">RING_DIFF_ALT</a> : thm
<a name="line152"></a>    val <a href="#RING_EMPTY-val">RING_EMPTY</a> : thm
<a name="line153"></a>    val <a href="#RING_FINITE_BIGUNION1-val">RING_FINITE_BIGUNION1</a> : thm
<a name="line154"></a>    val <a href="#RING_FINITE_BIGUNION2-val">RING_FINITE_BIGUNION2</a> : thm
<a name="line155"></a>    val <a href="#RING_FINITE_INTER-val">RING_FINITE_INTER</a> : thm
<a name="line156"></a>    val <a href="#RING_FINITE_INTER'-val">RING_FINITE_INTER'</a> : thm
<a name="line157"></a>    val <a href="#RING_FINITE_UNION-val">RING_FINITE_UNION</a> : thm
<a name="line158"></a>    val <a href="#RING_FINITE_UNION_ALT-val">RING_FINITE_UNION_ALT</a> : thm
<a name="line159"></a>    val <a href="#RING_IMP_SEMIRING-val">RING_IMP_SEMIRING</a> : thm
<a name="line160"></a>    val <a href="#RING_INSERT-val">RING_INSERT</a> : thm
<a name="line161"></a>    val <a href="#RING_INTER-val">RING_INTER</a> : thm
<a name="line162"></a>    val <a href="#RING_SETS_COLLECT_FINITE-val">RING_SETS_COLLECT_FINITE</a> : thm
<a name="line163"></a>    val <a href="#RING_SPACE_IMP_ALGEBRA-val">RING_SPACE_IMP_ALGEBRA</a> : thm
<a name="line164"></a>    val <a href="#RING_UNION-val">RING_UNION</a> : thm
<a name="line165"></a>    val <a href="#SEMIRING_DIFF-val">SEMIRING_DIFF</a> : thm
<a name="line166"></a>    val <a href="#SEMIRING_DIFF_ALT-val">SEMIRING_DIFF_ALT</a> : thm
<a name="line167"></a>    val <a href="#SEMIRING_EMPTY-val">SEMIRING_EMPTY</a> : thm
<a name="line168"></a>    val <a href="#SEMIRING_FINITE_INTER-val">SEMIRING_FINITE_INTER</a> : thm
<a name="line169"></a>    val <a href="#SEMIRING_FINITE_INTER'-val">SEMIRING_FINITE_INTER'</a> : thm
<a name="line170"></a>    val <a href="#SEMIRING_INTER-val">SEMIRING_INTER</a> : thm
<a name="line171"></a>    val <a href="#SEMIRING_PROD_SETS-val">SEMIRING_PROD_SETS</a> : thm
<a name="line172"></a>    val <a href="#SEMIRING_PROD_SETS'-val">SEMIRING_PROD_SETS'</a> : thm
<a name="line173"></a>    val <a href="#SEMIRING_SETS_COLLECT-val">SEMIRING_SETS_COLLECT</a> : thm
<a name="line174"></a>    val <a href="#SETS_TO_DISJOINT_SETS-val">SETS_TO_DISJOINT_SETS</a> : thm
<a name="line175"></a>    val <a href="#SETS_TO_DISJOINT_SETS'-val">SETS_TO_DISJOINT_SETS'</a> : thm
<a name="line176"></a>    val <a href="#SETS_TO_INCREASING_SETS-val">SETS_TO_INCREASING_SETS</a> : thm
<a name="line177"></a>    val <a href="#SETS_TO_INCREASING_SETS'-val">SETS_TO_INCREASING_SETS'</a> : thm
<a name="line178"></a>    val <a href="#SIGMA_ALGEBRA-val">SIGMA_ALGEBRA</a> : thm
<a name="line179"></a>    val <a href="#SIGMA_ALGEBRA_ALGEBRA-val">SIGMA_ALGEBRA_ALGEBRA</a> : thm
<a name="line180"></a>    val <a href="#SIGMA_ALGEBRA_ALT-val">SIGMA_ALGEBRA_ALT</a> : thm
<a name="line181"></a>    val <a href="#SIGMA_ALGEBRA_ALT_DISJOINT-val">SIGMA_ALGEBRA_ALT_DISJOINT</a> : thm
<a name="line182"></a>    val <a href="#SIGMA_ALGEBRA_ALT_MONO-val">SIGMA_ALGEBRA_ALT_MONO</a> : thm
<a name="line183"></a>    val <a href="#SIGMA_ALGEBRA_ALT_SPACE-val">SIGMA_ALGEBRA_ALT_SPACE</a> : thm
<a name="line184"></a>    val <a href="#SIGMA_ALGEBRA_COMPL-val">SIGMA_ALGEBRA_COMPL</a> : thm
<a name="line185"></a>    val <a href="#SIGMA_ALGEBRA_COUNTABLE_INT-val">SIGMA_ALGEBRA_COUNTABLE_INT</a> : thm
<a name="line186"></a>    val <a href="#SIGMA_ALGEBRA_COUNTABLE_INT'-val">SIGMA_ALGEBRA_COUNTABLE_INT'</a> : thm
<a name="line187"></a>    val <a href="#SIGMA_ALGEBRA_COUNTABLE_UN-val">SIGMA_ALGEBRA_COUNTABLE_UN</a> : thm
<a name="line188"></a>    val <a href="#SIGMA_ALGEBRA_COUNTABLE_UN'-val">SIGMA_ALGEBRA_COUNTABLE_UN'</a> : thm
<a name="line189"></a>    val <a href="#SIGMA_ALGEBRA_COUNTABLE_UNION-val">SIGMA_ALGEBRA_COUNTABLE_UNION</a> : thm
<a name="line190"></a>    val <a href="#SIGMA_ALGEBRA_DIFF-val">SIGMA_ALGEBRA_DIFF</a> : thm
<a name="line191"></a>    val <a href="#SIGMA_ALGEBRA_EMPTY-val">SIGMA_ALGEBRA_EMPTY</a> : thm
<a name="line192"></a>    val <a href="#SIGMA_ALGEBRA_ENUM-val">SIGMA_ALGEBRA_ENUM</a> : thm
<a name="line193"></a>    val <a href="#SIGMA_ALGEBRA_FINITE_INTER-val">SIGMA_ALGEBRA_FINITE_INTER</a> : thm
<a name="line194"></a>    val <a href="#SIGMA_ALGEBRA_FINITE_INTER'-val">SIGMA_ALGEBRA_FINITE_INTER'</a> : thm
<a name="line195"></a>    val <a href="#SIGMA_ALGEBRA_FINITE_UNION-val">SIGMA_ALGEBRA_FINITE_UNION</a> : thm
<a name="line196"></a>    val <a href="#SIGMA_ALGEBRA_FN-val">SIGMA_ALGEBRA_FN</a> : thm
<a name="line197"></a>    val <a href="#SIGMA_ALGEBRA_FN_BIGINTER-val">SIGMA_ALGEBRA_FN_BIGINTER</a> : thm
<a name="line198"></a>    val <a href="#SIGMA_ALGEBRA_FN_DISJOINT-val">SIGMA_ALGEBRA_FN_DISJOINT</a> : thm
<a name="line199"></a>    val <a href="#SIGMA_ALGEBRA_IMP_DYNKIN_SYSTEM-val">SIGMA_ALGEBRA_IMP_DYNKIN_SYSTEM</a> : thm
<a name="line200"></a>    val <a href="#SIGMA_ALGEBRA_INTER-val">SIGMA_ALGEBRA_INTER</a> : thm
<a name="line201"></a>    val <a href="#SIGMA_ALGEBRA_PROD_SIGMA-val">SIGMA_ALGEBRA_PROD_SIGMA</a> : thm
<a name="line202"></a>    val <a href="#SIGMA_ALGEBRA_PROD_SIGMA'-val">SIGMA_ALGEBRA_PROD_SIGMA'</a> : thm
<a name="line203"></a>    val <a href="#SIGMA_ALGEBRA_PROD_SIGMA_WEAK-val">SIGMA_ALGEBRA_PROD_SIGMA_WEAK</a> : thm
<a name="line204"></a>    val <a href="#SIGMA_ALGEBRA_RESTRICT-val">SIGMA_ALGEBRA_RESTRICT</a> : thm
<a name="line205"></a>    val <a href="#SIGMA_ALGEBRA_RESTRICT'-val">SIGMA_ALGEBRA_RESTRICT'</a> : thm
<a name="line206"></a>    val <a href="#SIGMA_ALGEBRA_RESTRICT_SUBSET-val">SIGMA_ALGEBRA_RESTRICT_SUBSET</a> : thm
<a name="line207"></a>    val <a href="#SIGMA_ALGEBRA_SIGMA-val">SIGMA_ALGEBRA_SIGMA</a> : thm
<a name="line208"></a>    val <a href="#SIGMA_ALGEBRA_SIGMA_UNIV-val">SIGMA_ALGEBRA_SIGMA_UNIV</a> : thm
<a name="line209"></a>    val <a href="#SIGMA_ALGEBRA_SPACE-val">SIGMA_ALGEBRA_SPACE</a> : thm
<a name="line210"></a>    val <a href="#SIGMA_ALGEBRA_SUBSET_SPACE-val">SIGMA_ALGEBRA_SUBSET_SPACE</a> : thm
<a name="line211"></a>    val <a href="#SIGMA_ALGEBRA_UNION-val">SIGMA_ALGEBRA_UNION</a> : thm
<a name="line212"></a>    val <a href="#SIGMA_CONG-val">SIGMA_CONG</a> : thm
<a name="line213"></a>    val <a href="#SIGMA_MEASURABLE-val">SIGMA_MEASURABLE</a> : thm
<a name="line214"></a>    val <a href="#SIGMA_MONOTONE-val">SIGMA_MONOTONE</a> : thm
<a name="line215"></a>    val <a href="#SIGMA_POW-val">SIGMA_POW</a> : thm
<a name="line216"></a>    val <a href="#SIGMA_PROPERTY-val">SIGMA_PROPERTY</a> : thm
<a name="line217"></a>    val <a href="#SIGMA_PROPERTY_ALT-val">SIGMA_PROPERTY_ALT</a> : thm
<a name="line218"></a>    val <a href="#SIGMA_PROPERTY_DISJOINT-val">SIGMA_PROPERTY_DISJOINT</a> : thm
<a name="line219"></a>    val <a href="#SIGMA_PROPERTY_DISJOINT_LEMMA-val">SIGMA_PROPERTY_DISJOINT_LEMMA</a> : thm
<a name="line220"></a>    val <a href="#SIGMA_PROPERTY_DISJOINT_LEMMA1-val">SIGMA_PROPERTY_DISJOINT_LEMMA1</a> : thm
<a name="line221"></a>    val <a href="#SIGMA_PROPERTY_DISJOINT_LEMMA2-val">SIGMA_PROPERTY_DISJOINT_LEMMA2</a> : thm
<a name="line222"></a>    val <a href="#SIGMA_PROPERTY_DISJOINT_WEAK-val">SIGMA_PROPERTY_DISJOINT_WEAK</a> : thm
<a name="line223"></a>    val <a href="#SIGMA_PROPERTY_DISJOINT_WEAK_ALT-val">SIGMA_PROPERTY_DISJOINT_WEAK_ALT</a> : thm
<a name="line224"></a>    val <a href="#SIGMA_PROPERTY_DYNKIN-val">SIGMA_PROPERTY_DYNKIN</a> : thm
<a name="line225"></a>    val <a href="#SIGMA_REDUCE-val">SIGMA_REDUCE</a> : thm
<a name="line226"></a>    val <a href="#SIGMA_RESTRICT-val">SIGMA_RESTRICT</a> : thm
<a name="line227"></a>    val <a href="#SIGMA_SIMULTANEOUSLY_MEASURABLE-val">SIGMA_SIMULTANEOUSLY_MEASURABLE</a> : thm
<a name="line228"></a>    val <a href="#SIGMA_SMALLEST-val">SIGMA_SMALLEST</a> : thm
<a name="line229"></a>    val <a href="#SIGMA_STABLE-val">SIGMA_STABLE</a> : thm
<a name="line230"></a>    val <a href="#SIGMA_STABLE_LEMMA-val">SIGMA_STABLE_LEMMA</a> : thm
<a name="line231"></a>    val <a href="#SIGMA_SUBSET-val">SIGMA_SUBSET</a> : thm
<a name="line232"></a>    val <a href="#SIGMA_SUBSET_SUBSETS-val">SIGMA_SUBSET_SUBSETS</a> : thm
<a name="line233"></a>    val <a href="#SMALLEST_RING-val">SMALLEST_RING</a> : thm
<a name="line234"></a>    val <a href="#SMALLEST_RING_OF_SEMIRING-val">SMALLEST_RING_OF_SEMIRING</a> : thm
<a name="line235"></a>    val <a href="#SMALLEST_RING_SUBSET_SUBSETS-val">SMALLEST_RING_SUBSET_SUBSETS</a> : thm
<a name="line236"></a>    val <a href="#SPACE-val">SPACE</a> : thm
<a name="line237"></a>    val <a href="#SPACE_DYNKIN-val">SPACE_DYNKIN</a> : thm
<a name="line238"></a>    val <a href="#SPACE_PROD_SIGMA-val">SPACE_PROD_SIGMA</a> : thm
<a name="line239"></a>    val <a href="#SPACE_SIGMA-val">SPACE_SIGMA</a> : thm
<a name="line240"></a>    val <a href="#SPACE_SMALLEST_RING-val">SPACE_SMALLEST_RING</a> : thm
<a name="line241"></a>    val <a href="#SUBSET_DIFF_DISJOINT-val">SUBSET_DIFF_DISJOINT</a> : thm
<a name="line242"></a>    val <a href="#SUBSET_DIFF_SUBSET-val">SUBSET_DIFF_SUBSET</a> : thm
<a name="line243"></a>    val <a href="#SUBSET_INTER_SUBSET_L-val">SUBSET_INTER_SUBSET_L</a> : thm
<a name="line244"></a>    val <a href="#SUBSET_INTER_SUBSET_R-val">SUBSET_INTER_SUBSET_R</a> : thm
<a name="line245"></a>    val <a href="#SUBSET_MONO_DIFF-val">SUBSET_MONO_DIFF</a> : thm
<a name="line246"></a>    val <a href="#SUBSET_RESTRICT_DIFF-val">SUBSET_RESTRICT_DIFF</a> : thm
<a name="line247"></a>    val <a href="#SUBSET_RESTRICT_L-val">SUBSET_RESTRICT_L</a> : thm
<a name="line248"></a>    val <a href="#SUBSET_RESTRICT_R-val">SUBSET_RESTRICT_R</a> : thm
<a name="line249"></a>    val <a href="#SUBSET_TWO-val">SUBSET_TWO</a> : thm
<a name="line250"></a>    val <a href="#TRACE_SIGMA_ALGEBRA-val">TRACE_SIGMA_ALGEBRA</a> : thm
<a name="line251"></a>    val <a href="#UNION_BINARY-val">UNION_BINARY</a> : thm
<a name="line252"></a>    val <a href="#UNION_TO_3_DISJOINT_UNIONS-val">UNION_TO_3_DISJOINT_UNIONS</a> : thm
<a name="line253"></a>    val <a href="#UNIV_SIGMA_ALGEBRA-val">UNIV_SIGMA_ALGEBRA</a> : thm
<a name="line254"></a>    val <a href="#algebra_alt-val">algebra_alt</a> : thm
<a name="line255"></a>    val <a href="#algebra_alt_inter-val">algebra_alt_inter</a> : thm
<a name="line256"></a>    val <a href="#algebra_alt_union-val">algebra_alt_union</a> : thm
<a name="line257"></a>    val <a href="#algebra_finite_space_imp_sigma_algebra-val">algebra_finite_space_imp_sigma_algebra</a> : thm
<a name="line258"></a>    val <a href="#algebra_finite_subsets_imp_sigma_algebra-val">algebra_finite_subsets_imp_sigma_algebra</a> : thm
<a name="line259"></a>    val <a href="#count1_def-val">count1_def</a> : thm
<a name="line260"></a>    val <a href="#count1_numseg-val">count1_numseg</a> : thm
<a name="line261"></a>    val <a href="#disjoint_family_def-val">disjoint_family_def</a> : thm
<a name="line262"></a>    val <a href="#disjoint_family_disjoint-val">disjoint_family_disjoint</a> : thm
<a name="line263"></a>    val <a href="#disjoint_family_on_def-val">disjoint_family_on_def</a> : thm
<a name="line264"></a>    val <a href="#disjoint_family_on_iff_disjoint-val">disjoint_family_on_iff_disjoint</a> : thm
<a name="line265"></a>    val <a href="#disjoint_family_on_imp_disjoint-val">disjoint_family_on_imp_disjoint</a> : thm
<a name="line266"></a>    val <a href="#disjointed_subset-val">disjointed_subset</a> : thm
<a name="line267"></a>    val <a href="#finite_decomposition-val">finite_decomposition</a> : thm
<a name="line268"></a>    val <a href="#finite_decomposition_simple-val">finite_decomposition_simple</a> : thm
<a name="line269"></a>    val <a href="#finite_disjoint_decomposition-val">finite_disjoint_decomposition</a> : thm
<a name="line270"></a>    val <a href="#finite_disjoint_decomposition'-val">finite_disjoint_decomposition'</a> : thm
<a name="line271"></a>    val <a href="#finite_enumeration_of_sets_has_max_non_empty-val">finite_enumeration_of_sets_has_max_non_empty</a> : thm
<a name="line272"></a>    val <a href="#infinitely_often_lemma-val">infinitely_often_lemma</a> : thm
<a name="line273"></a>    val <a href="#infinity_bound_lemma-val">infinity_bound_lemma</a> : thm
<a name="line274"></a>    val <a href="#prod_sigma_alt_sigma_functions-val">prod_sigma_alt_sigma_functions</a> : thm
<a name="line275"></a>    val <a href="#prod_sigma_alt_sigma_functions'-val">prod_sigma_alt_sigma_functions'</a> : thm
<a name="line276"></a>    val <a href="#restrict_algebra_SUBSET-val">restrict_algebra_SUBSET</a> : thm
<a name="line277"></a>    val <a href="#restrict_algebra_reduce-val">restrict_algebra_reduce</a> : thm
<a name="line278"></a>    val <a href="#restrict_algebra_reduce'-val">restrict_algebra_reduce'</a> : thm
<a name="line279"></a>    val <a href="#ring_alt-val">ring_alt</a> : thm
<a name="line280"></a>    val <a href="#ring_alt_pow-val">ring_alt_pow</a> : thm
<a name="line281"></a>    val <a href="#ring_alt_pow_imp-val">ring_alt_pow_imp</a> : thm
<a name="line282"></a>    val <a href="#ring_and_semiring-val">ring_and_semiring</a> : thm
<a name="line283"></a>    val <a href="#ring_disjointed_sets-val">ring_disjointed_sets</a> : thm
<a name="line284"></a>    val <a href="#semiring_alt-val">semiring_alt</a> : thm
<a name="line285"></a>    val <a href="#set_limsup_alt-val">set_limsup_alt</a> : thm
<a name="line286"></a>    val <a href="#sigma_algebra_alt_eq-val">sigma_algebra_alt_eq</a> : thm
<a name="line287"></a>    val <a href="#sigma_algebra_alt_pow-val">sigma_algebra_alt_pow</a> : thm
<a name="line288"></a>    val <a href="#sigma_algebra_eq_alt-val">sigma_algebra_eq_alt</a> : thm
<a name="line289"></a>    val <a href="#sigma_algebra_iff2-val">sigma_algebra_iff2</a> : thm
<a name="line290"></a>    val <a href="#sigma_algebra_restrict_algebra-val">sigma_algebra_restrict_algebra</a> : thm
<a name="line291"></a>    val <a href="#sigma_algebra_sigma_function-val">sigma_algebra_sigma_function</a> : thm
<a name="line292"></a>    val <a href="#sigma_algebra_sigma_functions-val">sigma_algebra_sigma_functions</a> : thm
<a name="line293"></a>    val <a href="#sigma_algebra_sigma_sets-val">sigma_algebra_sigma_sets</a> : thm
<a name="line294"></a>    val <a href="#sigma_function_alt_sigma_functions-val">sigma_function_alt_sigma_functions</a> : thm
<a name="line295"></a>    val <a href="#sigma_function_subset-val">sigma_function_subset</a> : thm
<a name="line296"></a>    val <a href="#sigma_functions_1-val">sigma_functions_1</a> : thm
<a name="line297"></a>    val <a href="#sigma_functions_subset-val">sigma_functions_subset</a> : thm
<a name="line298"></a>    val <a href="#sigma_sets_BIGINTER-val">sigma_sets_BIGINTER</a> : thm
<a name="line299"></a>    val <a href="#sigma_sets_BIGINTER2-val">sigma_sets_BIGINTER2</a> : thm
<a name="line300"></a>    val <a href="#sigma_sets_BIGUNION-val">sigma_sets_BIGUNION</a> : thm
<a name="line301"></a>    val <a href="#sigma_sets_basic-val">sigma_sets_basic</a> : thm
<a name="line302"></a>    val <a href="#sigma_sets_cases-val">sigma_sets_cases</a> : thm
<a name="line303"></a>    val <a href="#sigma_sets_compl-val">sigma_sets_compl</a> : thm
<a name="line304"></a>    val <a href="#sigma_sets_empty-val">sigma_sets_empty</a> : thm
<a name="line305"></a>    val <a href="#sigma_sets_eq-val">sigma_sets_eq</a> : thm
<a name="line306"></a>    val <a href="#sigma_sets_fixpoint-val">sigma_sets_fixpoint</a> : thm
<a name="line307"></a>    val <a href="#sigma_sets_ind-val">sigma_sets_ind</a> : thm
<a name="line308"></a>    val <a href="#sigma_sets_into_sp-val">sigma_sets_into_sp</a> : thm
<a name="line309"></a>    val <a href="#sigma_sets_least_sigma_algebra-val">sigma_sets_least_sigma_algebra</a> : thm
<a name="line310"></a>    val <a href="#sigma_sets_rules-val">sigma_sets_rules</a> : thm
<a name="line311"></a>    val <a href="#sigma_sets_sigma-val">sigma_sets_sigma</a> : thm
<a name="line312"></a>    val <a href="#sigma_sets_strongind-val">sigma_sets_strongind</a> : thm
<a name="line313"></a>    val <a href="#sigma_sets_subset-val">sigma_sets_subset</a> : thm
<a name="line314"></a>    val <a href="#sigma_sets_superset_generator-val">sigma_sets_superset_generator</a> : thm
<a name="line315"></a>    val <a href="#sigma_sets_top-val">sigma_sets_top</a> : thm
<a name="line316"></a>    val <a href="#sigma_sets_union-val">sigma_sets_union</a> : thm
<a name="line317"></a>    val <a href="#space_sigma_function-val">space_sigma_function</a> : thm
<a name="line318"></a>    val <a href="#space_sigma_functions-val">space_sigma_functions</a> : thm
<a name="line319"></a>    val <a href="#subset_class_POW-val">subset_class_POW</a> : thm
<a name="line320"></a>    val <a href="#tail_countable-val">tail_countable</a> : thm
<a name="line321"></a>    val <a href="#tail_not_empty-val">tail_not_empty</a> : thm
<a name="line322"></a>    val <a href="#trivial_algebra_of_space-val">trivial_algebra_of_space</a> : thm
<a name="line323"></a>    val <a href="#trivial_algebra_of_two_points-val">trivial_algebra_of_two_points</a> : thm
<a name="line324"></a>    val <a href="#trivial_algebra_of_two_sets-val">trivial_algebra_of_two_sets</a> : thm
<a name="line325"></a>(*
   [nets] Parent theory of "sigma_algebra"
   
   [<a name="algebra_def-val"><b>algebra_def</b></a>]  Definition
      
      ⊢ ∀a. algebra a ⇔
            subset_class (space a) (subsets a) ∧ ∅ ∈ subsets a ∧
            (∀s. s ∈ subsets a ⇒ space a DIFF s ∈ subsets a) ∧
            ∀s t. s ∈ subsets a ∧ t ∈ subsets a ⇒ s ∪ t ∈ subsets a
   
   [<a name="binary_def-val"><b>binary_def</b></a>]  Definition
      
      ⊢ ∀a b. binary a b = (λx. if x = 0 then a else b)
   
   [<a name="disjoint_family_on-val"><b>disjoint_family_on</b></a>]  Definition
      
      ⊢ ∀a s.
          disjoint_family_on a s ⇔
          ∀m n. m ∈ s ∧ n ∈ s ∧ m ≠ n ⇒ a m ∩ a n = ∅
   
   [<a name="disjointed-val"><b>disjointed</b></a>]  Definition
      
      ⊢ ∀A n.
          disjointed A n =
          A n DIFF BIGUNION {A i | i ∈ {x | 0 ≤ x ∧ x &lt; n}}
   
   [<a name="dynkin_def-val"><b>dynkin_def</b></a>]  Definition
      
      ⊢ ∀sp sts.
          dynkin sp sts =
          (sp,BIGINTER {d | sts ⊆ d ∧ dynkin_system (sp,d)})
   
   [<a name="dynkin_system_def-val"><b>dynkin_system_def</b></a>]  Definition
      
      ⊢ ∀d. dynkin_system d ⇔
            subset_class (space d) (subsets d) ∧ space d ∈ subsets d ∧
            (∀s. s ∈ subsets d ⇒ space d DIFF s ∈ subsets d) ∧
            ∀f. f ∈ (𝕌(:num) → subsets d) ∧
                (∀i j. i ≠ j ⇒ DISJOINT (f i) (f j)) ⇒
                BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets d
   
   [<a name="measurable_def-val"><b>measurable_def</b></a>]  Definition
      
      ⊢ ∀a b.
          measurable a b =
          {f |
           f ∈ (space a → space b) ∧
           ∀s. s ∈ subsets b ⇒ PREIMAGE f s ∩ space a ∈ subsets a}
   
   [<a name="prod_sets_def-val"><b>prod_sets_def</b></a>]  Definition
      
      ⊢ ∀a b. prod_sets a b = {s × t | s ∈ a ∧ t ∈ b}
   
   [<a name="prod_sigma_def-val"><b>prod_sigma_def</b></a>]  Definition
      
      ⊢ ∀a b.
          a × b =
          sigma (space a × space b) (prod_sets (subsets a) (subsets b))
   
   [<a name="restrict_algebra_def-val"><b>restrict_algebra_def</b></a>]  Definition
      
      ⊢ ∀A sp.
          restrict_algebra A sp =
          (sp ∩ space A,IMAGE (λa. a ∩ sp) (subsets A))
   
   [<a name="ring_def-val"><b>ring_def</b></a>]  Definition
      
      ⊢ ∀r. ring r ⇔
            subset_class (space r) (subsets r) ∧ ∅ ∈ subsets r ∧
            (∀s t. s ∈ subsets r ∧ t ∈ subsets r ⇒ s ∪ t ∈ subsets r) ∧
            ∀s t. s ∈ subsets r ∧ t ∈ subsets r ⇒ s DIFF t ∈ subsets r
   
   [<a name="semiring_def-val"><b>semiring_def</b></a>]  Definition
      
      ⊢ ∀r. semiring r ⇔
            subset_class (space r) (subsets r) ∧ ∅ ∈ subsets r ∧
            (∀s t. s ∈ subsets r ∧ t ∈ subsets r ⇒ s ∩ t ∈ subsets r) ∧
            ∀s t.
              s ∈ subsets r ∧ t ∈ subsets r ⇒
              ∃c. c ⊆ subsets r ∧ FINITE c ∧ disjoint c ∧
                  s DIFF t = BIGUNION c
   
   [<a name="set_liminf_def-val"><b>set_liminf_def</b></a>]  Definition
      
      ⊢ ∀E. liminf E =
            BIGUNION (IMAGE (λm. BIGINTER {E n | m ≤ n}) 𝕌(:num))
   
   [<a name="set_limsup_def-val"><b>set_limsup_def</b></a>]  Definition
      
      ⊢ ∀E. limsup E =
            BIGINTER (IMAGE (λm. BIGUNION {E n | m ≤ n}) 𝕌(:num))
   
   [<a name="sigma_algebra_alt-val"><b>sigma_algebra_alt</b></a>]  Definition
      
      ⊢ ∀sp sts.
          sigma_algebra_alt sp sts ⇔
          algebra (sp,sts) ∧
          ∀A. IMAGE A 𝕌(:num) ⊆ sts ⇒ BIGUNION {A i | i ∈ 𝕌(:num)} ∈ sts
   
   [<a name="sigma_algebra_def-val"><b>sigma_algebra_def</b></a>]  Definition
      
      ⊢ ∀a. sigma_algebra a ⇔
            algebra a ∧
            ∀c. countable c ∧ c ⊆ subsets a ⇒ BIGUNION c ∈ subsets a
   
   [<a name="sigma_def-val"><b>sigma_def</b></a>]  Definition
      
      ⊢ ∀sp sts.
          sigma sp sts = (sp,BIGINTER {s | sts ⊆ s ∧ sigma_algebra (sp,s)})
   
   [<a name="sigma_function_def-val"><b>sigma_function_def</b></a>]  Definition
      
      ⊢ ∀sp A f.
          sigma sp A f = (sp,IMAGE (λs. PREIMAGE f s ∩ sp) (subsets A))
   
   [<a name="sigma_functions_def-val"><b>sigma_functions_def</b></a>]  Definition
      
      ⊢ ∀sp A f J.
          sigma sp A f J =
          sigma sp
            (BIGUNION
               (IMAGE
                  (λi. IMAGE (λs. PREIMAGE (f i) s ∩ sp) (subsets (A i))) J))
   
   [<a name="smallest_ring_def-val"><b>smallest_ring_def</b></a>]  Definition
      
      ⊢ ∀sp sts.
          smallest_ring sp sts = (sp,BIGINTER {s | sts ⊆ s ∧ ring (sp,s)})
   
   [<a name="space_def-val"><b>space_def</b></a>]  Definition
      
      ⊢ ∀x y. space (x,y) = x
   
   [<a name="subset_class_def-val"><b>subset_class_def</b></a>]  Definition
      
      ⊢ ∀sp sts. subset_class sp sts ⇔ ∀x. x ∈ sts ⇒ x ⊆ sp
   
   [<a name="subsets_def-val"><b>subsets_def</b></a>]  Definition
      
      ⊢ ∀x y. subsets (x,y) = y
   
   [<a name="ALGEBRA_ALT_INTER-val"><b>ALGEBRA_ALT_INTER</b></a>]  Theorem
      
      ⊢ ∀a. algebra a ⇔
            subset_class (space a) (subsets a) ∧ ∅ ∈ subsets a ∧
            (∀s. s ∈ subsets a ⇒ space a DIFF s ∈ subsets a) ∧
            ∀s t. s ∈ subsets a ∧ t ∈ subsets a ⇒ s ∩ t ∈ subsets a
   
   [<a name="ALGEBRA_COMPL-val"><b>ALGEBRA_COMPL</b></a>]  Theorem
      
      ⊢ ∀a s. algebra a ∧ s ∈ subsets a ⇒ space a DIFF s ∈ subsets a
   
   [<a name="ALGEBRA_COMPL_SETS-val"><b>ALGEBRA_COMPL_SETS</b></a>]  Theorem
      
      ⊢ ∀sp sts a. algebra (sp,sts) ∧ a ∈ sts ⇒ sp DIFF a ∈ sts
   
   [<a name="ALGEBRA_DIFF-val"><b>ALGEBRA_DIFF</b></a>]  Theorem
      
      ⊢ ∀a s t.
          algebra a ∧ s ∈ subsets a ∧ t ∈ subsets a ⇒ s DIFF t ∈ subsets a
   
   [<a name="ALGEBRA_EMPTY-val"><b>ALGEBRA_EMPTY</b></a>]  Theorem
      
      ⊢ ∀a. algebra a ⇒ ∅ ∈ subsets a
   
   [<a name="ALGEBRA_FINITE_INTER-val"><b>ALGEBRA_FINITE_INTER</b></a>]  Theorem
      
      ⊢ ∀a f n.
          algebra a ∧ 0 &lt; n ∧ (∀i. i &lt; n ⇒ f i ∈ subsets a) ⇒
          BIGINTER (IMAGE f (count n)) ∈ subsets a
   
   [<a name="ALGEBRA_FINITE_INTER'-val"><b>ALGEBRA_FINITE_INTER'</b></a>]  Theorem
      
      ⊢ ∀a c.
          algebra a ∧ FINITE c ∧ c ⊆ subsets a ∧ c ≠ ∅ ⇒
          BIGINTER c ∈ subsets a
   
   [<a name="ALGEBRA_FINITE_UNION-val"><b>ALGEBRA_FINITE_UNION</b></a>]  Theorem
      
      ⊢ ∀a c. algebra a ∧ FINITE c ∧ c ⊆ subsets a ⇒ BIGUNION c ∈ subsets a
   
   [<a name="ALGEBRA_IMP_RING-val"><b>ALGEBRA_IMP_RING</b></a>]  Theorem
      
      ⊢ ∀a. algebra a ⇒ ring a
   
   [<a name="ALGEBRA_IMP_SEMIRING-val"><b>ALGEBRA_IMP_SEMIRING</b></a>]  Theorem
      
      ⊢ ∀a. algebra a ⇒ semiring a
   
   [<a name="ALGEBRA_INTER-val"><b>ALGEBRA_INTER</b></a>]  Theorem
      
      ⊢ ∀a s t.
          algebra a ∧ s ∈ subsets a ∧ t ∈ subsets a ⇒ s ∩ t ∈ subsets a
   
   [<a name="ALGEBRA_INTER_SPACE-val"><b>ALGEBRA_INTER_SPACE</b></a>]  Theorem
      
      ⊢ ∀a s. algebra a ∧ s ∈ subsets a ⇒ space a ∩ s = s ∧ s ∩ space a = s
   
   [<a name="ALGEBRA_RESTRICT-val"><b>ALGEBRA_RESTRICT</b></a>]  Theorem
      
      ⊢ ∀sp sts a.
          algebra (sp,sts) ∧ a ∈ sts ⇒ algebra (a,IMAGE (λs. s ∩ a) sts)
   
   [<a name="ALGEBRA_RESTRICT'-val"><b>ALGEBRA_RESTRICT'</b></a>]  Theorem
      
      ⊢ ∀sp sts a.
          algebra (sp,sts) ∧ a ⊆ sp ⇒ algebra (a,IMAGE (λs. s ∩ a) sts)
   
   [<a name="ALGEBRA_SETS_COLLECT_CONST-val"><b>ALGEBRA_SETS_COLLECT_CONST</b></a>]  Theorem
      
      ⊢ ∀sp sts P. algebra (sp,sts) ⇒ {x | x ∈ sp ∧ P} ∈ sts
   
   [<a name="ALGEBRA_SETS_COLLECT_IMP-val"><b>ALGEBRA_SETS_COLLECT_IMP</b></a>]  Theorem
      
      ⊢ ∀sp sts P Q.
          algebra (sp,sts) ∧ {x | x ∈ sp ∧ P x} ∈ sts ⇒
          {x | x ∈ sp ∧ Q x} ∈ sts ⇒
          {x | x ∈ sp ∧ (Q x ⇒ P x)} ∈ sts
   
   [<a name="ALGEBRA_SETS_COLLECT_NEG-val"><b>ALGEBRA_SETS_COLLECT_NEG</b></a>]  Theorem
      
      ⊢ ∀sp sts P.
          algebra (sp,sts) ∧ {x | x ∈ sp ∧ P x} ∈ sts ⇒
          {x | x ∈ sp ∧ ¬P x} ∈ sts
   
   [<a name="ALGEBRA_SINGLE_SET-val"><b>ALGEBRA_SINGLE_SET</b></a>]  Theorem
      
      ⊢ ∀X S. X ⊆ S ⇒ algebra (S,{∅; X; S DIFF X; S})
   
   [<a name="ALGEBRA_SPACE-val"><b>ALGEBRA_SPACE</b></a>]  Theorem
      
      ⊢ ∀a. algebra a ⇒ space a ∈ subsets a
   
   [<a name="ALGEBRA_UNION-val"><b>ALGEBRA_UNION</b></a>]  Theorem
      
      ⊢ ∀a s t.
          algebra a ∧ s ∈ subsets a ∧ t ∈ subsets a ⇒ s ∪ t ∈ subsets a
   
   [<a name="BIGINTER_OVER_INTER_L-val"><b>BIGINTER_OVER_INTER_L</b></a>]  Theorem
      
      ⊢ ∀f s d.
          s ≠ ∅ ⇒
          BIGINTER (IMAGE f s) ∩ d = BIGINTER (IMAGE (λi. f i ∩ d) s)
   
   [<a name="BIGINTER_OVER_INTER_R-val"><b>BIGINTER_OVER_INTER_R</b></a>]  Theorem
      
      ⊢ ∀f s d.
          s ≠ ∅ ⇒
          d ∩ BIGINTER (IMAGE f s) = BIGINTER (IMAGE (λi. d ∩ f i) s)
   
   [<a name="BIGINTER_PAIR-val"><b>BIGINTER_PAIR</b></a>]  Theorem
      
      ⊢ ∀s t. BIGINTER {s; t} = s ∩ t
   
   [<a name="BIGUNION_IMAGE_BIGUNION_IMAGE_UNIV-val"><b>BIGUNION_IMAGE_BIGUNION_IMAGE_UNIV</b></a>]  Theorem
      
      ⊢ ∀f. BIGUNION (IMAGE (λn. BIGUNION (IMAGE (f n) 𝕌(:num))) 𝕌(:num)) =
            BIGUNION (IMAGE (UNCURRY f) 𝕌(:num # num))
   
   [<a name="BIGUNION_IMAGE_COUNT_IMP_UNIV-val"><b>BIGUNION_IMAGE_COUNT_IMP_UNIV</b></a>]  Theorem
      
      ⊢ ∀f g.
          (∀n. BIGUNION (IMAGE g (count n)) = BIGUNION (IMAGE f (count n))) ⇒
          BIGUNION (IMAGE f 𝕌(:num)) = BIGUNION (IMAGE g 𝕌(:num))
   
   [<a name="BIGUNION_IMAGE_UNIV_CROSS_UNIV-val"><b>BIGUNION_IMAGE_UNIV_CROSS_UNIV</b></a>]  Theorem
      
      ⊢ ∀f h.
          BIJ h 𝕌(:num) (𝕌(:num) × 𝕌(:num)) ⇒
          BIGUNION (IMAGE (UNCURRY f) 𝕌(:num # num)) =
          BIGUNION (IMAGE (UNCURRY f ∘ h) 𝕌(:num))
   
   [<a name="BIGUNION_OVER_DIFF-val"><b>BIGUNION_OVER_DIFF</b></a>]  Theorem
      
      ⊢ ∀f s d.
          BIGUNION (IMAGE f s) DIFF d = BIGUNION (IMAGE (λi. f i DIFF d) s)
   
   [<a name="BIGUNION_OVER_INTER_L-val"><b>BIGUNION_OVER_INTER_L</b></a>]  Theorem
      
      ⊢ ∀f s d. BIGUNION (IMAGE f s) ∩ d = BIGUNION (IMAGE (λi. f i ∩ d) s)
   
   [<a name="BIGUNION_OVER_INTER_R-val"><b>BIGUNION_OVER_INTER_R</b></a>]  Theorem
      
      ⊢ ∀f s d. d ∩ BIGUNION (IMAGE f s) = BIGUNION (IMAGE (λi. d ∩ f i) s)
   
   [<a name="BIGUNION_disjointed-val"><b>BIGUNION_disjointed</b></a>]  Theorem
      
      ⊢ ∀A. BIGUNION {disjointed A i | i ∈ 𝕌(:num)} =
            BIGUNION {A i | i ∈ 𝕌(:num)}
   
   [<a name="BINARY_RANGE-val"><b>BINARY_RANGE</b></a>]  Theorem
      
      ⊢ ∀a b. IMAGE (binary a b) 𝕌(:num) = {a; b}
   
   [<a name="COMPL_BIGINTER-val"><b>COMPL_BIGINTER</b></a>]  Theorem
      
      ⊢ ∀c. COMPL (BIGINTER c) = BIGUNION (IMAGE COMPL c)
   
   [<a name="COMPL_BIGINTER_IMAGE-val"><b>COMPL_BIGINTER_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f. COMPL (BIGINTER (IMAGE f 𝕌(:num))) =
            BIGUNION (IMAGE (COMPL ∘ f) 𝕌(:num))
   
   [<a name="COMPL_BIGUNION-val"><b>COMPL_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀c. c ≠ ∅ ⇒ COMPL (BIGUNION c) = BIGINTER (IMAGE COMPL c)
   
   [<a name="COMPL_BIGUNION_IMAGE-val"><b>COMPL_BIGUNION_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f. COMPL (BIGUNION (IMAGE f 𝕌(:num))) =
            BIGINTER (IMAGE (COMPL ∘ f) 𝕌(:num))
   
   [<a name="DIFF_INTER_PAIR-val"><b>DIFF_INTER_PAIR</b></a>]  Theorem
      
      ⊢ ∀sp x y. sp DIFF x ∩ y = sp DIFF x ∪ (sp DIFF y)
   
   [<a name="DINTER_IMP_FINITE_INTER-val"><b>DINTER_IMP_FINITE_INTER</b></a>]  Theorem
      
      ⊢ ∀sts f.
          (∀s t. s ∈ sts ∧ t ∈ sts ⇒ s ∩ t ∈ sts) ∧ f ∈ (𝕌(:num) → sts) ⇒
          ∀n. 0 &lt; n ⇒ BIGINTER (IMAGE f (count n)) ∈ sts
   
   [<a name="DISJOINT_CROSS_L-val"><b>DISJOINT_CROSS_L</b></a>]  Theorem
      
      ⊢ ∀s t c. DISJOINT s t ⇒ DISJOINT (s × c) (t × c)
   
   [<a name="DISJOINT_CROSS_R-val"><b>DISJOINT_CROSS_R</b></a>]  Theorem
      
      ⊢ ∀s t c. DISJOINT s t ⇒ DISJOINT (c × s) (c × t)
   
   [<a name="DISJOINT_RESTRICT_L-val"><b>DISJOINT_RESTRICT_L</b></a>]  Theorem
      
      ⊢ ∀s t c. DISJOINT s t ⇒ DISJOINT (s ∩ c) (t ∩ c)
   
   [<a name="DISJOINT_RESTRICT_R-val"><b>DISJOINT_RESTRICT_R</b></a>]  Theorem
      
      ⊢ ∀s t c. DISJOINT s t ⇒ DISJOINT (c ∩ s) (c ∩ t)
   
   [<a name="DUNION_IMP_FINITE_UNION-val"><b>DUNION_IMP_FINITE_UNION</b></a>]  Theorem
      
      ⊢ ∀sts f.
          (∀s t. s ∈ sts ∧ t ∈ sts ⇒ s ∪ t ∈ sts) ⇒
          ∀n. 0 &lt; n ∧ (∀i. i &lt; n ⇒ f i ∈ sts) ⇒
              BIGUNION (IMAGE f (count n)) ∈ sts
   
   [<a name="DYNKIN-val"><b>DYNKIN</b></a>]  Theorem
      
      ⊢ ∀sp sts.
          subset_class sp sts ⇒
          sts ⊆ subsets (dynkin sp sts) ∧ dynkin_system (dynkin sp sts) ∧
          subset_class sp (subsets (dynkin sp sts))
   
   [<a name="DYNKIN_LEMMA-val"><b>DYNKIN_LEMMA</b></a>]  Theorem
      
      ⊢ ∀d. dynkin_system d ∧
            (∀s t. s ∈ subsets d ∧ t ∈ subsets d ⇒ s ∩ t ∈ subsets d) ⇔
            sigma_algebra d
   
   [<a name="DYNKIN_MONOTONE-val"><b>DYNKIN_MONOTONE</b></a>]  Theorem
      
      ⊢ ∀sp a b. a ⊆ b ⇒ subsets (dynkin sp a) ⊆ subsets (dynkin sp b)
   
   [<a name="DYNKIN_SMALLEST-val"><b>DYNKIN_SMALLEST</b></a>]  Theorem
      
      ⊢ ∀sp sts D.
          sts ⊆ D ∧ D ⊆ subsets (dynkin sp sts) ∧ dynkin_system (sp,D) ⇒
          D = subsets (dynkin sp sts)
   
   [<a name="DYNKIN_STABLE-val"><b>DYNKIN_STABLE</b></a>]  Theorem
      
      ⊢ ∀d. dynkin_system d ⇒ dynkin (space d) (subsets d) = d
   
   [<a name="DYNKIN_STABLE_LEMMA-val"><b>DYNKIN_STABLE_LEMMA</b></a>]  Theorem
      
      ⊢ ∀sp sts. dynkin_system (sp,sts) ⇒ dynkin sp sts = (sp,sts)
   
   [<a name="DYNKIN_SUBSET-val"><b>DYNKIN_SUBSET</b></a>]  Theorem
      
      ⊢ ∀a b.
          dynkin_system b ∧ a ⊆ subsets b ⇒
          subsets (dynkin (space b) a) ⊆ subsets b
   
   [<a name="DYNKIN_SUBSET_SIGMA-val"><b>DYNKIN_SUBSET_SIGMA</b></a>]  Theorem
      
      ⊢ ∀sp sts.
          subset_class sp sts ⇒
          subsets (dynkin sp sts) ⊆ subsets (sigma sp sts)
   
   [<a name="DYNKIN_SUBSET_SUBSETS-val"><b>DYNKIN_SUBSET_SUBSETS</b></a>]  Theorem
      
      ⊢ ∀sp a. a ⊆ subsets (dynkin sp a)
   
   [<a name="DYNKIN_SYSTEM_ALT-val"><b>DYNKIN_SYSTEM_ALT</b></a>]  Theorem
      
      ⊢ ∀d. dynkin_system d ⇔
            subset_class (space d) (subsets d) ∧ space d ∈ subsets d ∧
            (∀s. s ∈ subsets d ⇒ space d DIFF s ∈ subsets d) ∧
            (∀f. f ∈ (𝕌(:num) → subsets d) ∧ f 0 = ∅ ∧
                 (∀n. f n ⊆ f (SUC n)) ⇒
                 BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets d) ∧
            ∀f. f ∈ (𝕌(:num) → subsets d) ∧
                (∀i j. i ≠ j ⇒ DISJOINT (f i) (f j)) ⇒
                BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets d
   
   [<a name="DYNKIN_SYSTEM_ALT_MONO-val"><b>DYNKIN_SYSTEM_ALT_MONO</b></a>]  Theorem
      
      ⊢ ∀d. dynkin_system d ⇔
            subset_class (space d) (subsets d) ∧ space d ∈ subsets d ∧
            (∀s t.
               s ∈ subsets d ∧ t ∈ subsets d ∧ s ⊆ t ⇒ t DIFF s ∈ subsets d) ∧
            ∀f. f ∈ (𝕌(:num) → subsets d) ∧ f 0 = ∅ ∧ (∀n. f n ⊆ f (SUC n)) ⇒
                BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets d
   
   [<a name="DYNKIN_SYSTEM_COMPL-val"><b>DYNKIN_SYSTEM_COMPL</b></a>]  Theorem
      
      ⊢ ∀d s. dynkin_system d ∧ s ∈ subsets d ⇒ space d DIFF s ∈ subsets d
   
   [<a name="DYNKIN_SYSTEM_COUNTABLY_DUNION-val"><b>DYNKIN_SYSTEM_COUNTABLY_DUNION</b></a>]  Theorem
      
      ⊢ ∀d f.
          dynkin_system d ∧ f ∈ (𝕌(:num) → subsets d) ∧
          (∀i j. i ≠ j ⇒ DISJOINT (f i) (f j)) ⇒
          BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets d
   
   [<a name="DYNKIN_SYSTEM_DUNION-val"><b>DYNKIN_SYSTEM_DUNION</b></a>]  Theorem
      
      ⊢ ∀d s t.
          dynkin_system d ∧ s ∈ subsets d ∧ t ∈ subsets d ∧ DISJOINT s t ⇒
          s ∪ t ∈ subsets d
   
   [<a name="DYNKIN_SYSTEM_EMPTY-val"><b>DYNKIN_SYSTEM_EMPTY</b></a>]  Theorem
      
      ⊢ ∀d. dynkin_system d ⇒ ∅ ∈ subsets d
   
   [<a name="DYNKIN_SYSTEM_INCREASING-val"><b>DYNKIN_SYSTEM_INCREASING</b></a>]  Theorem
      
      ⊢ ∀p f.
          dynkin_system p ∧ f ∈ (𝕌(:num) → subsets p) ∧ f 0 = ∅ ∧
          (∀n. f n ⊆ f (SUC n)) ⇒
          BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets p
   
   [<a name="DYNKIN_SYSTEM_SPACE-val"><b>DYNKIN_SYSTEM_SPACE</b></a>]  Theorem
      
      ⊢ ∀d. dynkin_system d ⇒ space d ∈ subsets d
   
   [<a name="DYNKIN_THM-val"><b>DYNKIN_THM</b></a>]  Theorem
      
      ⊢ ∀sp sts.
          subset_class sp sts ∧ (∀s t. s ∈ sts ∧ t ∈ sts ⇒ s ∩ t ∈ sts) ⇒
          dynkin sp sts = sigma sp sts
   
   [<a name="FINITE_TWO-val"><b>FINITE_TWO</b></a>]  Theorem
      
      ⊢ ∀s t. FINITE {s; t}
   
   [<a name="GBIGUNION_IMAGE-val"><b>GBIGUNION_IMAGE</b></a>]  Theorem
      
      ⊢ ∀s p n. {s | ∃n. p s n} = BIGUNION (IMAGE (λn. {s | p s n}) 𝕌(:γ))
   
   [<a name="GEN_COMPL_BIGINTER-val"><b>GEN_COMPL_BIGINTER</b></a>]  Theorem
      
      ⊢ ∀sp c.
          (∀x. x ∈ c ⇒ x ⊆ sp) ⇒
          sp DIFF BIGINTER c = BIGUNION (IMAGE (λx. sp DIFF x) c)
   
   [<a name="GEN_COMPL_BIGINTER_IMAGE-val"><b>GEN_COMPL_BIGINTER_IMAGE</b></a>]  Theorem
      
      ⊢ ∀sp f.
          (∀n. f n ⊆ sp) ⇒
          sp DIFF BIGINTER (IMAGE f 𝕌(:num)) =
          BIGUNION (IMAGE (λn. sp DIFF f n) 𝕌(:num))
   
   [<a name="GEN_COMPL_BIGUNION-val"><b>GEN_COMPL_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀sp c.
          c ≠ ∅ ∧ (∀x. x ∈ c ⇒ x ⊆ sp) ⇒
          sp DIFF BIGUNION c = BIGINTER (IMAGE (λx. sp DIFF x) c)
   
   [<a name="GEN_COMPL_BIGUNION_IMAGE-val"><b>GEN_COMPL_BIGUNION_IMAGE</b></a>]  Theorem
      
      ⊢ ∀sp f.
          (∀n. f n ⊆ sp) ⇒
          sp DIFF BIGUNION (IMAGE f 𝕌(:num)) =
          BIGINTER (IMAGE (λn. sp DIFF f n) 𝕌(:num))
   
   [<a name="GEN_COMPL_FINITE_INTER-val"><b>GEN_COMPL_FINITE_INTER</b></a>]  Theorem
      
      ⊢ ∀sp f n.
          0 &lt; n ⇒
          sp DIFF BIGINTER (IMAGE f (count n)) =
          BIGUNION (IMAGE (λi. sp DIFF f i) (count n))
   
   [<a name="GEN_COMPL_FINITE_UNION-val"><b>GEN_COMPL_FINITE_UNION</b></a>]  Theorem
      
      ⊢ ∀sp f n.
          0 &lt; n ⇒
          sp DIFF BIGUNION (IMAGE f (count n)) =
          BIGINTER (IMAGE (λi. sp DIFF f i) (count n))
   
   [<a name="GEN_COMPL_INTER-val"><b>GEN_COMPL_INTER</b></a>]  Theorem
      
      ⊢ ∀sp s t. s ⊆ sp ∧ t ⊆ sp ⇒ sp DIFF s ∩ t = sp DIFF s ∪ (sp DIFF t)
   
   [<a name="GEN_COMPL_UNION-val"><b>GEN_COMPL_UNION</b></a>]  Theorem
      
      ⊢ ∀sp s t.
          s ⊆ sp ∧ t ⊆ sp ⇒ sp DIFF (s ∪ t) = (sp DIFF s) ∩ (sp DIFF t)
   
   [<a name="GEN_DIFF_INTER-val"><b>GEN_DIFF_INTER</b></a>]  Theorem
      
      ⊢ ∀sp s t. s ⊆ sp ∧ t ⊆ sp ⇒ s DIFF t = s ∩ (sp DIFF t)
   
   [<a name="IMAGE_SIGMA-val"><b>IMAGE_SIGMA</b></a>]  Theorem
      
      ⊢ ∀sp sts f.
          subset_class sp sts ∧ BIJ f sp (IMAGE f sp) ⇒
          IMAGE (IMAGE f) (subsets (sigma sp sts)) =
          subsets (sigma (IMAGE f sp) (IMAGE (IMAGE f) sts))
   
   [<a name="IMAGE_SIGMA_ALGEBRA-val"><b>IMAGE_SIGMA_ALGEBRA</b></a>]  Theorem
      
      ⊢ ∀sp sts f.
          sigma_algebra (sp,sts) ∧ BIJ f sp (IMAGE f sp) ⇒
          sigma_algebra (IMAGE f sp,IMAGE (IMAGE f) sts)
   
   [<a name="INCREASING_TO_DISJOINT_SETS-val"><b>INCREASING_TO_DISJOINT_SETS</b></a>]  Theorem
      
      ⊢ ∀f. (∀n. f n ⊆ f (SUC n)) ⇒
            ∃g. g 0 = f 0 ∧ (∀n. 0 &lt; n ⇒ g n = f n DIFF f (PRE n)) ∧
                (∀i j. i ≠ j ⇒ DISJOINT (g i) (g j)) ∧
                BIGUNION (IMAGE f 𝕌(:num)) = BIGUNION (IMAGE g 𝕌(:num))
   
   [<a name="INCREASING_TO_DISJOINT_SETS'-val"><b>INCREASING_TO_DISJOINT_SETS'</b></a>]  Theorem
      
      ⊢ ∀f. f 0 = ∅ ∧ (∀n. f n ⊆ f (SUC n)) ⇒
            ∃g. (∀n. g n = f (SUC n) DIFF f n) ∧
                (∀i j. i ≠ j ⇒ DISJOINT (g i) (g j)) ∧
                BIGUNION (IMAGE f 𝕌(:num)) = BIGUNION (IMAGE g 𝕌(:num))
   
   [<a name="INTER_BINARY-val"><b>INTER_BINARY</b></a>]  Theorem
      
      ⊢ ∀a b. a ∩ b = BIGINTER {binary a b i | i ∈ 𝕌(:num)}
   
   [<a name="INTER_SPACE_EQ1-val"><b>INTER_SPACE_EQ1</b></a>]  Theorem
      
      ⊢ ∀sp sts. subset_class sp sts ⇒ ∀x. x ∈ sts ⇒ sp ∩ x = x
   
   [<a name="INTER_SPACE_REDUCE-val"><b>INTER_SPACE_REDUCE</b></a>]  Theorem
      
      ⊢ ∀sp sts. subset_class sp sts ⇒ ∀x. x ∈ sts ⇒ x ∩ sp = x
   
   [<a name="IN_DYNKIN-val"><b>IN_DYNKIN</b></a>]  Theorem
      
      ⊢ ∀sp a x. x ∈ a ⇒ x ∈ subsets (dynkin sp a)
   
   [<a name="IN_LIMINF-val"><b>IN_LIMINF</b></a>]  Theorem
      
      ⊢ ∀A x. x ∈ liminf A ⇔ ∃m. ∀n. m ≤ n ⇒ x ∈ A n
   
   [<a name="IN_LIMSUP-val"><b>IN_LIMSUP</b></a>]  Theorem
      
      ⊢ ∀A x. x ∈ limsup A ⇔ ∃N. INFINITE N ∧ ∀n. n ∈ N ⇒ x ∈ A n
   
   [<a name="IN_MEASURABLE-val"><b>IN_MEASURABLE</b></a>]  Theorem
      
      ⊢ ∀a b f.
          f ∈ measurable a b ⇔
          f ∈ (space a → space b) ∧
          ∀s. s ∈ subsets b ⇒ PREIMAGE f s ∩ space a ∈ subsets a
   
   [<a name="IN_MEASURABLE_COMP-val"><b>IN_MEASURABLE_COMP</b></a>]  Theorem
      
      ⊢ ∀f g h a b c.
          f ∈ measurable a b ∧ g ∈ measurable b c ∧
          (∀x. x ∈ space a ⇒ h x = g (f x)) ⇒
          h ∈ measurable a c
   
   [<a name="IN_MEASURABLE_CONG-val"><b>IN_MEASURABLE_CONG</b></a>]  Theorem
      
      ⊢ ∀a b c d f g.
          a = c ∧ b = d ∧ (∀x. x ∈ space c ⇒ f x = g x) ⇒
          (f ∈ measurable a b ⇔ g ∈ measurable c d)
   
   [<a name="IN_MEASURABLE_EQ-val"><b>IN_MEASURABLE_EQ</b></a>]  Theorem
      
      ⊢ ∀a b f g.
          f ∈ measurable a b ∧ (∀x. x ∈ space a ⇒ g x = f x) ⇒
          g ∈ measurable a b
   
   [<a name="IN_MEASURABLE_PROD_SIGMA-val"><b>IN_MEASURABLE_PROD_SIGMA</b></a>]  Theorem
      
      ⊢ ∀a bx by fx fy f.
          sigma_algebra a ∧ subset_class (space bx) (subsets bx) ∧
          subset_class (space by) (subsets by) ∧ fx ∈ measurable a bx ∧
          fy ∈ measurable a by ∧ (∀z. z ∈ space a ⇒ f z = (fx z,fy z)) ⇒
          f ∈ measurable a (bx × by)
   
   [<a name="IN_PROD_SETS-val"><b>IN_PROD_SETS</b></a>]  Theorem
      
      ⊢ ∀s a b. s ∈ prod_sets a b ⇔ ∃t u. s = t × u ∧ t ∈ a ∧ u ∈ b
   
   [<a name="IN_SIGMA-val"><b>IN_SIGMA</b></a>]  Theorem
      
      ⊢ ∀sp a x. x ∈ a ⇒ x ∈ subsets (sigma sp a)
   
   [<a name="IN_SPACE_PROD_SIGMA-val"><b>IN_SPACE_PROD_SIGMA</b></a>]  Theorem
      
      ⊢ ∀a b z. z ∈ space (a × b) ⇔ FST z ∈ space a ∧ SND z ∈ space b
   
   [<a name="LIMSUP_COMPL-val"><b>LIMSUP_COMPL</b></a>]  Theorem
      
      ⊢ ∀E. COMPL (liminf E) = limsup (COMPL ∘ E)
   
   [<a name="LIMSUP_DIFF-val"><b>LIMSUP_DIFF</b></a>]  Theorem
      
      ⊢ ∀sp E. (∀n. E n ⊆ sp) ⇒ sp DIFF liminf E = limsup (λn. sp DIFF E n)
   
   [<a name="LIMSUP_MONO_STRONG-val"><b>LIMSUP_MONO_STRONG</b></a>]  Theorem
      
      ⊢ ∀A B. (∀y n. y ∈ A n ⇒ ∃m. n ≤ m ∧ y ∈ B m) ⇒ limsup A ⊆ limsup B
   
   [<a name="LIMSUP_MONO_STRONGER-val"><b>LIMSUP_MONO_STRONGER</b></a>]  Theorem
      
      ⊢ ∀A B.
          (∃d. ∀y n. y ∈ A n ⇒ ∃m. n − d ≤ m ∧ y ∈ B m) ⇒
          limsup A ⊆ limsup B
   
   [<a name="LIMSUP_MONO_WEAK-val"><b>LIMSUP_MONO_WEAK</b></a>]  Theorem
      
      ⊢ ∀A B. (∀n. A n ⊆ B n) ⇒ limsup A ⊆ limsup B
   
   [<a name="MEASUBABLE_BIGUNION_LEMMA-val"><b>MEASUBABLE_BIGUNION_LEMMA</b></a>]  Theorem
      
      ⊢ ∀a b f.
          sigma_algebra a ∧ sigma_algebra b ∧ f ∈ (space a → space b) ∧
          (∀s. s ∈ subsets b ⇒ PREIMAGE f s ∈ subsets a) ⇒
          ∀c. countable c ∧ c ⊆ IMAGE (PREIMAGE f) (subsets b) ⇒
              BIGUNION c ∈ IMAGE (PREIMAGE f) (subsets b)
   
   [<a name="MEASURABLE_BIGUNION_PROPERTY-val"><b>MEASURABLE_BIGUNION_PROPERTY</b></a>]  Theorem
      
      ⊢ ∀a b f.
          sigma_algebra a ∧ sigma_algebra b ∧ f ∈ (space a → space b) ∧
          (∀s. s ∈ subsets b ⇒ PREIMAGE f s ∈ subsets a) ⇒
          ∀c. c ⊆ subsets b ⇒
              PREIMAGE f (BIGUNION c) = BIGUNION (IMAGE (PREIMAGE f) c)
   
   [<a name="MEASURABLE_COMP-val"><b>MEASURABLE_COMP</b></a>]  Theorem
      
      ⊢ ∀f g a b c.
          f ∈ measurable a b ∧ g ∈ measurable b c ⇒ g ∘ f ∈ measurable a c
   
   [<a name="MEASURABLE_COMP_STRONG-val"><b>MEASURABLE_COMP_STRONG</b></a>]  Theorem
      
      ⊢ ∀f g a b c.
          f ∈ measurable a b ∧ sigma_algebra c ∧ g ∈ (space b → space c) ∧
          (∀x. x ∈ subsets c ⇒ PREIMAGE g x ∩ IMAGE f (space a) ∈ subsets b) ⇒
          g ∘ f ∈ measurable a c
   
   [<a name="MEASURABLE_COMP_STRONGER-val"><b>MEASURABLE_COMP_STRONGER</b></a>]  Theorem
      
      ⊢ ∀f g a b c t.
          f ∈ measurable a b ∧ sigma_algebra c ∧ g ∈ (space b → space c) ∧
          IMAGE f (space a) ⊆ t ∧
          (∀s. s ∈ subsets c ⇒ PREIMAGE g s ∩ t ∈ subsets b) ⇒
          g ∘ f ∈ measurable a c
   
   [<a name="MEASURABLE_DIFF_PROPERTY-val"><b>MEASURABLE_DIFF_PROPERTY</b></a>]  Theorem
      
      ⊢ ∀a b f.
          sigma_algebra a ∧ sigma_algebra b ∧ f ∈ (space a → space b) ∧
          (∀s. s ∈ subsets b ⇒ PREIMAGE f s ∈ subsets a) ⇒
          ∀s. s ∈ subsets b ⇒
              PREIMAGE f (space b DIFF s) = space a DIFF PREIMAGE f s
   
   [<a name="MEASURABLE_FST-val"><b>MEASURABLE_FST</b></a>]  Theorem
      
      ⊢ ∀a b.
          sigma_algebra a ∧ sigma_algebra b ⇒ FST ∈ measurable (a × b) a
   
   [<a name="MEASURABLE_I-val"><b>MEASURABLE_I</b></a>]  Theorem
      
      ⊢ ∀a. sigma_algebra a ⇒ I ∈ measurable a a
   
   [<a name="MEASURABLE_LEMMA-val"><b>MEASURABLE_LEMMA</b></a>]  Theorem
      
      ⊢ ∀f a b sp sts.
          sigma_algebra a ∧ subset_class sp sts ∧ f ∈ (space a → sp) ∧
          b = sigma sp sts ⇒
          ((∀s. s ∈ subsets b ⇒ PREIMAGE f s ∩ space a ∈ subsets a) ⇔
           ∀s. s ∈ sts ⇒ PREIMAGE f s ∩ space a ∈ subsets a)
   
   [<a name="MEASURABLE_LIFT-val"><b>MEASURABLE_LIFT</b></a>]  Theorem
      
      ⊢ ∀f a b.
          sigma_algebra a ∧ subset_class (space b) (subsets b) ∧
          f ∈ measurable a b ⇒
          f ∈ measurable a (sigma (space b) (subsets b))
   
   [<a name="MEASURABLE_PAIR-val"><b>MEASURABLE_PAIR</b></a>]  Theorem
      
      ⊢ ∀a b1 b2 X Y.
          sigma_algebra a ∧ sigma_algebra b1 ∧ sigma_algebra b2 ∧
          X ∈ measurable a b1 ∧ Y ∈ measurable a b2 ⇒
          (λx. (X x,Y x)) ∈ measurable a (b1 × b2)
   
   [<a name="MEASURABLE_PROD_SIGMA-val"><b>MEASURABLE_PROD_SIGMA</b></a>]  Theorem
      
      ⊢ ∀a a1 a2 f.
          sigma_algebra a ∧ subset_class (space a1) (subsets a1) ∧
          subset_class (space a2) (subsets a2) ∧
          FST ∘ f ∈ measurable a a1 ∧ SND ∘ f ∈ measurable a a2 ⇒
          f ∈
          measurable a
            (sigma (space a1 × space a2)
               (prod_sets (subsets a1) (subsets a2)))
   
   [<a name="MEASURABLE_PROD_SIGMA'-val"><b>MEASURABLE_PROD_SIGMA'</b></a>]  Theorem
      
      ⊢ ∀a a1 a2 f.
          sigma_algebra a ∧ subset_class (space a1) (subsets a1) ∧
          subset_class (space a2) (subsets a2) ∧
          FST ∘ f ∈ measurable a a1 ∧ SND ∘ f ∈ measurable a a2 ⇒
          f ∈ measurable a (a1 × a2)
   
   [<a name="MEASURABLE_SIGMA-val"><b>MEASURABLE_SIGMA</b></a>]  Theorem
      
      ⊢ ∀f a b sp.
          sigma_algebra a ∧ subset_class sp b ∧ f ∈ (space a → sp) ∧
          (∀s. s ∈ b ⇒ PREIMAGE f s ∩ space a ∈ subsets a) ⇒
          f ∈ measurable a (sigma sp b)
   
   [<a name="MEASURABLE_SIGMA_PREIMAGES-val"><b>MEASURABLE_SIGMA_PREIMAGES</b></a>]  Theorem
      
      ⊢ ∀a b f.
          sigma_algebra a ∧ sigma_algebra b ∧ f ∈ (space a → space b) ∧
          (∀s. s ∈ subsets b ⇒ PREIMAGE f s ∈ subsets a) ⇒
          sigma_algebra (space a,IMAGE (PREIMAGE f) (subsets b))
   
   [<a name="MEASURABLE_SND-val"><b>MEASURABLE_SND</b></a>]  Theorem
      
      ⊢ ∀a b.
          sigma_algebra a ∧ sigma_algebra b ⇒ SND ∈ measurable (a × b) b
   
   [<a name="MEASURABLE_SUBSET-val"><b>MEASURABLE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀a b.
          sigma_algebra a ∧ subset_class (space b) (subsets b) ⇒
          measurable a b ⊆ measurable a (sigma (space b) (subsets b))
   
   [<a name="MEASURABLE_UP_LIFT-val"><b>MEASURABLE_UP_LIFT</b></a>]  Theorem
      
      ⊢ ∀sp a b c f.
          f ∈ measurable (sp,a) c ∧ sigma_algebra (sp,b) ∧ a ⊆ b ⇒
          f ∈ measurable (sp,b) c
   
   [<a name="MEASURABLE_UP_SIGMA-val"><b>MEASURABLE_UP_SIGMA</b></a>]  Theorem
      
      ⊢ ∀a b.
          subset_class (space a) (subsets a) ∧ sigma_algebra b ⇒
          measurable a b ⊆ measurable (sigma (space a) (subsets a)) b
   
   [<a name="MEASURABLE_UP_SUBSET-val"><b>MEASURABLE_UP_SUBSET</b></a>]  Theorem
      
      ⊢ ∀sp a b c.
          a ⊆ b ∧ sigma_algebra (sp,b) ⇒
          measurable (sp,a) c ⊆ measurable (sp,b) c
   
   [<a name="POW_ALGEBRA-val"><b>POW_ALGEBRA</b></a>]  Theorem
      
      ⊢ ∀sp. algebra (sp,POW sp)
   
   [<a name="POW_SIGMA_ALGEBRA-val"><b>POW_SIGMA_ALGEBRA</b></a>]  Theorem
      
      ⊢ ∀sp. sigma_algebra (sp,POW sp)
   
   [<a name="PREIMAGE_SIGMA-val"><b>PREIMAGE_SIGMA</b></a>]  Theorem
      
      ⊢ ∀Z sp sts f.
          subset_class sp sts ∧ f ∈ (Z → sp) ⇒
          IMAGE (λs. PREIMAGE f s ∩ Z) (subsets (sigma sp sts)) =
          subsets (sigma Z (IMAGE (λs. PREIMAGE f s ∩ Z) sts))
   
   [<a name="PREIMAGE_SIGMA_ALGEBRA-val"><b>PREIMAGE_SIGMA_ALGEBRA</b></a>]  Theorem
      
      ⊢ ∀sp A f.
          sigma_algebra A ∧ f ∈ (sp → space A) ⇒
          sigma_algebra (sp,IMAGE (λs. PREIMAGE f s ∩ sp) (subsets A))
   
   [<a name="RING_BIGUNION-val"><b>RING_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀sp sts A n.
          ring (sp,sts) ∧ IMAGE A 𝕌(:num) ⊆ sts ⇒
          BIGUNION {A i | i &lt; n} ∈ sts
   
   [<a name="RING_DIFF-val"><b>RING_DIFF</b></a>]  Theorem
      
      ⊢ ∀r s t.
          ring r ∧ s ∈ subsets r ∧ t ∈ subsets r ⇒ s DIFF t ∈ subsets r
   
   [<a name="RING_DIFF_ALT-val"><b>RING_DIFF_ALT</b></a>]  Theorem
      
      ⊢ ∀a b sp sts. ring (sp,sts) ∧ a ∈ sts ∧ b ∈ sts ⇒ a DIFF b ∈ sts
   
   [<a name="RING_EMPTY-val"><b>RING_EMPTY</b></a>]  Theorem
      
      ⊢ ∀r. ring r ⇒ ∅ ∈ subsets r
   
   [<a name="RING_FINITE_BIGUNION1-val"><b>RING_FINITE_BIGUNION1</b></a>]  Theorem
      
      ⊢ ∀X sp sts. ring (sp,sts) ∧ FINITE X ⇒ X ⊆ sts ⇒ BIGUNION X ∈ sts
   
   [<a name="RING_FINITE_BIGUNION2-val"><b>RING_FINITE_BIGUNION2</b></a>]  Theorem
      
      ⊢ ∀A N sp sts.
          ring (sp,sts) ∧ FINITE N ∧ (∀i. i ∈ N ⇒ A i ∈ sts) ⇒
          BIGUNION {A i | i ∈ N} ∈ sts
   
   [<a name="RING_FINITE_INTER-val"><b>RING_FINITE_INTER</b></a>]  Theorem
      
      ⊢ ∀r f n.
          ring r ∧ 0 &lt; n ∧ (∀i. i &lt; n ⇒ f i ∈ subsets r) ⇒
          BIGINTER (IMAGE f (count n)) ∈ subsets r
   
   [<a name="RING_FINITE_INTER'-val"><b>RING_FINITE_INTER'</b></a>]  Theorem
      
      ⊢ ∀r c.
          ring r ∧ FINITE c ∧ c ⊆ subsets r ∧ c ≠ ∅ ⇒
          BIGINTER c ∈ subsets r
   
   [<a name="RING_FINITE_UNION-val"><b>RING_FINITE_UNION</b></a>]  Theorem
      
      ⊢ ∀r c. ring r ∧ c ⊆ subsets r ∧ FINITE c ⇒ BIGUNION c ∈ subsets r
   
   [<a name="RING_FINITE_UNION_ALT-val"><b>RING_FINITE_UNION_ALT</b></a>]  Theorem
      
      ⊢ ∀r f n.
          ring r ∧ (∀i. i &lt; n ⇒ f i ∈ subsets r) ⇒
          BIGUNION (IMAGE f (count n)) ∈ subsets r
   
   [<a name="RING_IMP_SEMIRING-val"><b>RING_IMP_SEMIRING</b></a>]  Theorem
      
      ⊢ ∀r. ring r ⇒ semiring r
   
   [<a name="RING_INSERT-val"><b>RING_INSERT</b></a>]  Theorem
      
      ⊢ ∀x A sp sts. ring (sp,sts) ∧ {x} ∈ sts ∧ A ∈ sts ⇒ x INSERT A ∈ sts
   
   [<a name="RING_INTER-val"><b>RING_INTER</b></a>]  Theorem
      
      ⊢ ∀r s t. ring r ∧ s ∈ subsets r ∧ t ∈ subsets r ⇒ s ∩ t ∈ subsets r
   
   [<a name="RING_SETS_COLLECT_FINITE-val"><b>RING_SETS_COLLECT_FINITE</b></a>]  Theorem
      
      ⊢ ∀sp sts s P.
          ring (sp,sts) ∧ (∀i. i ∈ s ⇒ equiv_class P sp i ∈ sts) ∧ FINITE s ⇒
          {x | x ∈ sp ∧ ∃i. i ∈ s ∧ P i x} ∈ sts
   
   [<a name="RING_SPACE_IMP_ALGEBRA-val"><b>RING_SPACE_IMP_ALGEBRA</b></a>]  Theorem
      
      ⊢ ∀r. ring r ∧ space r ∈ subsets r ⇒ algebra r
   
   [<a name="RING_UNION-val"><b>RING_UNION</b></a>]  Theorem
      
      ⊢ ∀r s t. ring r ∧ s ∈ subsets r ∧ t ∈ subsets r ⇒ s ∪ t ∈ subsets r
   
   [<a name="SEMIRING_DIFF-val"><b>SEMIRING_DIFF</b></a>]  Theorem
      
      ⊢ ∀r s t.
          semiring r ∧ s ∈ subsets r ∧ t ∈ subsets r ⇒
          ∃c. c ⊆ subsets r ∧ FINITE c ∧ disjoint c ∧ s DIFF t = BIGUNION c
   
   [<a name="SEMIRING_DIFF_ALT-val"><b>SEMIRING_DIFF_ALT</b></a>]  Theorem
      
      ⊢ ∀r s t.
          semiring r ∧ s ∈ subsets r ∧ t ∈ subsets r ⇒
          ∃f n.
            (∀i. i &lt; n ⇒ f i ∈ subsets r) ∧
            (∀i j. i &lt; n ∧ j &lt; n ∧ i ≠ j ⇒ DISJOINT (f i) (f j)) ∧
            s DIFF t = BIGUNION (IMAGE f (count n))
   
   [<a name="SEMIRING_EMPTY-val"><b>SEMIRING_EMPTY</b></a>]  Theorem
      
      ⊢ ∀r. semiring r ⇒ ∅ ∈ subsets r
   
   [<a name="SEMIRING_FINITE_INTER-val"><b>SEMIRING_FINITE_INTER</b></a>]  Theorem
      
      ⊢ ∀r f n.
          semiring r ∧ 0 &lt; n ∧ (∀i. i &lt; n ⇒ f i ∈ subsets r) ⇒
          BIGINTER (IMAGE f (count n)) ∈ subsets r
   
   [<a name="SEMIRING_FINITE_INTER'-val"><b>SEMIRING_FINITE_INTER'</b></a>]  Theorem
      
      ⊢ ∀r c.
          semiring r ∧ FINITE c ∧ c ⊆ subsets r ∧ c ≠ ∅ ⇒
          BIGINTER c ∈ subsets r
   
   [<a name="SEMIRING_INTER-val"><b>SEMIRING_INTER</b></a>]  Theorem
      
      ⊢ ∀r s t.
          semiring r ∧ s ∈ subsets r ∧ t ∈ subsets r ⇒ s ∩ t ∈ subsets r
   
   [<a name="SEMIRING_PROD_SETS-val"><b>SEMIRING_PROD_SETS</b></a>]  Theorem
      
      ⊢ ∀a b.
          semiring a ∧ semiring b ⇒
          semiring (space a × space b,prod_sets (subsets a) (subsets b))
   
   [<a name="SEMIRING_PROD_SETS'-val"><b>SEMIRING_PROD_SETS'</b></a>]  Theorem
      
      ⊢ ∀a b.
          sigma_algebra a ∧ sigma_algebra b ⇒
          semiring (space a × space b,prod_sets (subsets a) (subsets b))
   
   [<a name="SEMIRING_SETS_COLLECT-val"><b>SEMIRING_SETS_COLLECT</b></a>]  Theorem
      
      ⊢ ∀sp sts P Q.
          semiring (sp,sts) ∧ {x | x ∈ sp ∧ P x} ∈ sts ∧
          {x | x ∈ sp ∧ Q x} ∈ sts ⇒
          {x | x ∈ sp ∧ P x ∧ Q x} ∈ sts
   
   [<a name="SETS_TO_DISJOINT_SETS-val"><b>SETS_TO_DISJOINT_SETS</b></a>]  Theorem
      
      ⊢ ∀sp sts f.
          (∀s. s ∈ sts ⇒ s ⊆ sp) ∧ (∀n. f n ∈ sts) ⇒
          ∃g. g 0 = f 0 ∧
              (∀n. 0 &lt; n ⇒
                   g n = f n ∩ BIGINTER (IMAGE (λi. sp DIFF f i) (count n))) ∧
              (∀i j. i ≠ j ⇒ DISJOINT (g i) (g j)) ∧
              BIGUNION (IMAGE f 𝕌(:num)) = BIGUNION (IMAGE g 𝕌(:num))
   
   [<a name="SETS_TO_DISJOINT_SETS'-val"><b>SETS_TO_DISJOINT_SETS'</b></a>]  Theorem
      
      ⊢ ∀f. ∃g.
          g 0 = f 0 ∧
          (∀n. 0 &lt; n ⇒ g n = f n ∩ BIGINTER (IMAGE (COMPL ∘ f) (count n))) ∧
          (∀i j. i ≠ j ⇒ DISJOINT (g i) (g j)) ∧
          BIGUNION (IMAGE f 𝕌(:num)) = BIGUNION (IMAGE g 𝕌(:num))
   
   [<a name="SETS_TO_INCREASING_SETS-val"><b>SETS_TO_INCREASING_SETS</b></a>]  Theorem
      
      ⊢ ∀f. ∃g.
          g 0 = f 0 ∧ (∀n. g n = BIGUNION (IMAGE f (count1 n))) ∧
          (∀n. g n ⊆ g (SUC n)) ∧
          BIGUNION (IMAGE f 𝕌(:num)) = BIGUNION (IMAGE g 𝕌(:num))
   
   [<a name="SETS_TO_INCREASING_SETS'-val"><b>SETS_TO_INCREASING_SETS'</b></a>]  Theorem
      
      ⊢ ∀f. ∃g.
          g 0 = ∅ ∧ (∀n. g n = BIGUNION (IMAGE f (count n))) ∧
          (∀n. g n ⊆ g (SUC n)) ∧
          BIGUNION (IMAGE f 𝕌(:num)) = BIGUNION (IMAGE g 𝕌(:num))
   
   [<a name="SIGMA_ALGEBRA-val"><b>SIGMA_ALGEBRA</b></a>]  Theorem
      
      ⊢ ∀p. sigma_algebra p ⇔
            subset_class (space p) (subsets p) ∧ ∅ ∈ subsets p ∧
            (∀s. s ∈ subsets p ⇒ space p DIFF s ∈ subsets p) ∧
            ∀c. countable c ∧ c ⊆ subsets p ⇒ BIGUNION c ∈ subsets p
   
   [<a name="SIGMA_ALGEBRA_ALGEBRA-val"><b>SIGMA_ALGEBRA_ALGEBRA</b></a>]  Theorem
      
      ⊢ ∀a. sigma_algebra a ⇒ algebra a
   
   [<a name="SIGMA_ALGEBRA_ALT-val"><b>SIGMA_ALGEBRA_ALT</b></a>]  Theorem
      
      ⊢ ∀a. sigma_algebra a ⇔
            algebra a ∧
            ∀f. f ∈ (𝕌(:num) → subsets a) ⇒
                BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_ALT_DISJOINT-val"><b>SIGMA_ALGEBRA_ALT_DISJOINT</b></a>]  Theorem
      
      ⊢ ∀a. sigma_algebra a ⇔
            algebra a ∧
            ∀f. f ∈ (𝕌(:num) → subsets a) ∧
                (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ⇒
                BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_ALT_MONO-val"><b>SIGMA_ALGEBRA_ALT_MONO</b></a>]  Theorem
      
      ⊢ ∀a. sigma_algebra a ⇔
            algebra a ∧
            ∀f. f ∈ (𝕌(:num) → subsets a) ∧ f 0 = ∅ ∧ (∀n. f n ⊆ f (SUC n)) ⇒
                BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_ALT_SPACE-val"><b>SIGMA_ALGEBRA_ALT_SPACE</b></a>]  Theorem
      
      ⊢ ∀a. sigma_algebra a ⇔
            subset_class (space a) (subsets a) ∧ space a ∈ subsets a ∧
            (∀s. s ∈ subsets a ⇒ space a DIFF s ∈ subsets a) ∧
            ∀f. f ∈ (𝕌(:num) → subsets a) ⇒
                BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_COMPL-val"><b>SIGMA_ALGEBRA_COMPL</b></a>]  Theorem
      
      ⊢ ∀a s. sigma_algebra a ∧ s ∈ subsets a ⇒ space a DIFF s ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_COUNTABLE_INT-val"><b>SIGMA_ALGEBRA_COUNTABLE_INT</b></a>]  Theorem
      
      ⊢ ∀sp sts A X.
          sigma_algebra (sp,sts) ∧ IMAGE A X ⊆ sts ∧ X ≠ ∅ ⇒
          BIGINTER {A x | x ∈ X} ∈ sts
   
   [<a name="SIGMA_ALGEBRA_COUNTABLE_INT'-val"><b>SIGMA_ALGEBRA_COUNTABLE_INT'</b></a>]  Theorem
      
      ⊢ ∀sp sts A X.
          sigma_algebra (sp,sts) ∧ countable X ∧ X ≠ ∅ ∧ IMAGE A X ⊆ sts ⇒
          BIGINTER {A x | x ∈ X} ∈ sts
   
   [<a name="SIGMA_ALGEBRA_COUNTABLE_UN-val"><b>SIGMA_ALGEBRA_COUNTABLE_UN</b></a>]  Theorem
      
      ⊢ ∀sp sts A X.
          sigma_algebra (sp,sts) ∧ IMAGE A X ⊆ sts ⇒
          BIGUNION {A x | x ∈ X} ∈ sts
   
   [<a name="SIGMA_ALGEBRA_COUNTABLE_UN'-val"><b>SIGMA_ALGEBRA_COUNTABLE_UN'</b></a>]  Theorem
      
      ⊢ ∀sp sts A X.
          sigma_algebra (sp,sts) ∧ IMAGE A X ⊆ sts ∧ countable X ⇒
          BIGUNION {A x | x ∈ X} ∈ sts
   
   [<a name="SIGMA_ALGEBRA_COUNTABLE_UNION-val"><b>SIGMA_ALGEBRA_COUNTABLE_UNION</b></a>]  Theorem
      
      ⊢ ∀a c.
          sigma_algebra a ∧ countable c ∧ c ⊆ subsets a ⇒
          BIGUNION c ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_DIFF-val"><b>SIGMA_ALGEBRA_DIFF</b></a>]  Theorem
      
      ⊢ ∀a s t.
          sigma_algebra a ∧ s ∈ subsets a ∧ t ∈ subsets a ⇒
          s DIFF t ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_EMPTY-val"><b>SIGMA_ALGEBRA_EMPTY</b></a>]  Theorem
      
      ⊢ ∀a. sigma_algebra a ⇒ ∅ ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_ENUM-val"><b>SIGMA_ALGEBRA_ENUM</b></a>]  Theorem
      
      ⊢ ∀a f.
          sigma_algebra a ∧ f ∈ (𝕌(:num) → subsets a) ⇒
          BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_FINITE_INTER-val"><b>SIGMA_ALGEBRA_FINITE_INTER</b></a>]  Theorem
      
      ⊢ ∀a f n.
          sigma_algebra a ∧ 0 &lt; n ∧ (∀i. i &lt; n ⇒ f i ∈ subsets a) ⇒
          BIGINTER (IMAGE f (count n)) ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_FINITE_INTER'-val"><b>SIGMA_ALGEBRA_FINITE_INTER'</b></a>]  Theorem
      
      ⊢ ∀a c.
          sigma_algebra a ∧ FINITE c ∧ c ⊆ subsets a ∧ c ≠ ∅ ⇒
          BIGINTER c ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_FINITE_UNION-val"><b>SIGMA_ALGEBRA_FINITE_UNION</b></a>]  Theorem
      
      ⊢ ∀a c.
          sigma_algebra a ∧ FINITE c ∧ c ⊆ subsets a ⇒
          BIGUNION c ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_FN-val"><b>SIGMA_ALGEBRA_FN</b></a>]  Theorem
      
      ⊢ ∀a. sigma_algebra a ⇔
            subset_class (space a) (subsets a) ∧ ∅ ∈ subsets a ∧
            (∀s. s ∈ subsets a ⇒ space a DIFF s ∈ subsets a) ∧
            ∀f. f ∈ (𝕌(:num) → subsets a) ⇒
                BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_FN_BIGINTER-val"><b>SIGMA_ALGEBRA_FN_BIGINTER</b></a>]  Theorem
      
      ⊢ ∀a. sigma_algebra a ⇒
            subset_class (space a) (subsets a) ∧ ∅ ∈ subsets a ∧
            (∀s. s ∈ subsets a ⇒ space a DIFF s ∈ subsets a) ∧
            ∀f. f ∈ (𝕌(:num) → subsets a) ⇒
                BIGINTER (IMAGE f 𝕌(:num)) ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_FN_DISJOINT-val"><b>SIGMA_ALGEBRA_FN_DISJOINT</b></a>]  Theorem
      
      ⊢ ∀a. sigma_algebra a ⇔
            subset_class (space a) (subsets a) ∧ ∅ ∈ subsets a ∧
            (∀s. s ∈ subsets a ⇒ space a DIFF s ∈ subsets a) ∧
            (∀s t. s ∈ subsets a ∧ t ∈ subsets a ⇒ s ∪ t ∈ subsets a) ∧
            ∀f. f ∈ (𝕌(:num) → subsets a) ∧
                (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ⇒
                BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_IMP_DYNKIN_SYSTEM-val"><b>SIGMA_ALGEBRA_IMP_DYNKIN_SYSTEM</b></a>]  Theorem
      
      ⊢ ∀a. sigma_algebra a ⇒ dynkin_system a
   
   [<a name="SIGMA_ALGEBRA_INTER-val"><b>SIGMA_ALGEBRA_INTER</b></a>]  Theorem
      
      ⊢ ∀a s t.
          sigma_algebra a ∧ s ∈ subsets a ∧ t ∈ subsets a ⇒
          s ∩ t ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_PROD_SIGMA-val"><b>SIGMA_ALGEBRA_PROD_SIGMA</b></a>]  Theorem
      
      ⊢ ∀a b.
          subset_class (space a) (subsets a) ∧
          subset_class (space b) (subsets b) ⇒
          sigma_algebra (a × b)
   
   [<a name="SIGMA_ALGEBRA_PROD_SIGMA'-val"><b>SIGMA_ALGEBRA_PROD_SIGMA'</b></a>]  Theorem
      
      ⊢ ∀X Y A B.
          subset_class X A ∧ subset_class Y B ⇒
          sigma_algebra ((X,A) × (Y,B))
   
   [<a name="SIGMA_ALGEBRA_PROD_SIGMA_WEAK-val"><b>SIGMA_ALGEBRA_PROD_SIGMA_WEAK</b></a>]  Theorem
      
      ⊢ ∀a b. sigma_algebra a ∧ sigma_algebra b ⇒ sigma_algebra (a × b)
   
   [<a name="SIGMA_ALGEBRA_RESTRICT-val"><b>SIGMA_ALGEBRA_RESTRICT</b></a>]  Theorem
      
      ⊢ ∀sp sts a.
          sigma_algebra (sp,sts) ∧ a ∈ sts ⇒
          sigma_algebra (a,IMAGE (λs. s ∩ a) sts)
   
   [<a name="SIGMA_ALGEBRA_RESTRICT'-val"><b>SIGMA_ALGEBRA_RESTRICT'</b></a>]  Theorem
      
      ⊢ ∀sp sts a.
          sigma_algebra (sp,sts) ∧ a ⊆ sp ⇒
          sigma_algebra (a,IMAGE (λs. s ∩ a) sts)
   
   [<a name="SIGMA_ALGEBRA_RESTRICT_SUBSET-val"><b>SIGMA_ALGEBRA_RESTRICT_SUBSET</b></a>]  Theorem
      
      ⊢ ∀sp sts a.
          sigma_algebra (sp,sts) ∧ a ∈ sts ⇒ IMAGE (λs. s ∩ a) sts ⊆ sts
   
   [<a name="SIGMA_ALGEBRA_SIGMA-val"><b>SIGMA_ALGEBRA_SIGMA</b></a>]  Theorem
      
      ⊢ ∀sp sts. subset_class sp sts ⇒ sigma_algebra (sigma sp sts)
   
   [<a name="SIGMA_ALGEBRA_SIGMA_UNIV-val"><b>SIGMA_ALGEBRA_SIGMA_UNIV</b></a>]  Theorem
      
      ⊢ ∀sts. sigma_algebra (sigma 𝕌(:α) sts)
   
   [<a name="SIGMA_ALGEBRA_SPACE-val"><b>SIGMA_ALGEBRA_SPACE</b></a>]  Theorem
      
      ⊢ ∀a. sigma_algebra a ⇒ space a ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_SUBSET_SPACE-val"><b>SIGMA_ALGEBRA_SUBSET_SPACE</b></a>]  Theorem
      
      ⊢ ∀a s. sigma_algebra a ∧ s ∈ subsets a ⇒ s ⊆ space a
   
   [<a name="SIGMA_ALGEBRA_UNION-val"><b>SIGMA_ALGEBRA_UNION</b></a>]  Theorem
      
      ⊢ ∀a s t.
          sigma_algebra a ∧ s ∈ subsets a ∧ t ∈ subsets a ⇒
          s ∪ t ∈ subsets a
   
   [<a name="SIGMA_CONG-val"><b>SIGMA_CONG</b></a>]  Theorem
      
      ⊢ ∀sp a b.
          subsets (sigma sp a) = subsets (sigma sp b) ⇒
          sigma sp a = sigma sp b
   
   [<a name="SIGMA_MEASURABLE-val"><b>SIGMA_MEASURABLE</b></a>]  Theorem
      
      ⊢ ∀sp A f.
          sigma_algebra A ∧ f ∈ (sp → space A) ⇒
          f ∈ measurable (sigma sp A f) A
   
   [<a name="SIGMA_MONOTONE-val"><b>SIGMA_MONOTONE</b></a>]  Theorem
      
      ⊢ ∀sp a b. a ⊆ b ⇒ subsets (sigma sp a) ⊆ subsets (sigma sp b)
   
   [<a name="SIGMA_POW-val"><b>SIGMA_POW</b></a>]  Theorem
      
      ⊢ ∀s. sigma s (POW s) = (s,POW s)
   
   [<a name="SIGMA_PROPERTY-val"><b>SIGMA_PROPERTY</b></a>]  Theorem
      
      ⊢ ∀sp p a.
          subset_class sp p ∧ ∅ ∈ p ∧ a ⊆ p ∧
          (∀s. s ∈ p ∩ subsets (sigma sp a) ⇒ sp DIFF s ∈ p) ∧
          (∀c. countable c ∧ c ⊆ p ∩ subsets (sigma sp a) ⇒ BIGUNION c ∈ p) ⇒
          subsets (sigma sp a) ⊆ p
   
   [<a name="SIGMA_PROPERTY_ALT-val"><b>SIGMA_PROPERTY_ALT</b></a>]  Theorem
      
      ⊢ ∀sp p a.
          subset_class sp p ∧ ∅ ∈ p ∧ a ⊆ p ∧
          (∀s. s ∈ p ∩ subsets (sigma sp a) ⇒ sp DIFF s ∈ p) ∧
          (∀f. f ∈ (𝕌(:num) → p ∩ subsets (sigma sp a)) ⇒
               BIGUNION (IMAGE f 𝕌(:num)) ∈ p) ⇒
          subsets (sigma sp a) ⊆ p
   
   [<a name="SIGMA_PROPERTY_DISJOINT-val"><b>SIGMA_PROPERTY_DISJOINT</b></a>]  Theorem
      
      ⊢ ∀sp p a.
          algebra (sp,a) ∧ a ⊆ p ∧
          (∀s. s ∈ p ∩ subsets (sigma sp a) ⇒ sp DIFF s ∈ p) ∧
          (∀f. f ∈ (𝕌(:num) → p ∩ subsets (sigma sp a)) ∧ f 0 = ∅ ∧
               (∀n. f n ⊆ f (SUC n)) ⇒
               BIGUNION (IMAGE f 𝕌(:num)) ∈ p) ∧
          (∀f. f ∈ (𝕌(:num) → p ∩ subsets (sigma sp a)) ∧
               (∀i j. i ≠ j ⇒ DISJOINT (f i) (f j)) ⇒
               BIGUNION (IMAGE f 𝕌(:num)) ∈ p) ⇒
          subsets (sigma sp a) ⊆ p
   
   [<a name="SIGMA_PROPERTY_DISJOINT_LEMMA-val"><b>SIGMA_PROPERTY_DISJOINT_LEMMA</b></a>]  Theorem
      
      ⊢ ∀sp a d.
          algebra (sp,a) ∧ a ⊆ d ∧ dynkin_system (sp,d) ⇒
          subsets (sigma sp a) ⊆ d
   
   [<a name="SIGMA_PROPERTY_DISJOINT_LEMMA1-val"><b>SIGMA_PROPERTY_DISJOINT_LEMMA1</b></a>]  Theorem
      
      ⊢ ∀sp sts.
          algebra (sp,sts) ⇒
          ∀s t.
            s ∈ sts ∧ t ∈ subsets (dynkin sp sts) ⇒
            s ∩ t ∈ subsets (dynkin sp sts)
   
   [<a name="SIGMA_PROPERTY_DISJOINT_LEMMA2-val"><b>SIGMA_PROPERTY_DISJOINT_LEMMA2</b></a>]  Theorem
      
      ⊢ ∀sp sts.
          algebra (sp,sts) ⇒
          ∀s t.
            s ∈ subsets (dynkin sp sts) ∧ t ∈ subsets (dynkin sp sts) ⇒
            s ∩ t ∈ subsets (dynkin sp sts)
   
   [<a name="SIGMA_PROPERTY_DISJOINT_WEAK-val"><b>SIGMA_PROPERTY_DISJOINT_WEAK</b></a>]  Theorem
      
      ⊢ ∀sp p a.
          subset_class sp p ∧ ∅ ∈ p ∧ a ⊆ p ∧
          (∀s. s ∈ p ∩ subsets (sigma sp a) ⇒ sp DIFF s ∈ p) ∧
          (∀s t. s ∈ p ∧ t ∈ p ⇒ s ∪ t ∈ p) ∧
          (∀f. f ∈ (𝕌(:num) → p ∩ subsets (sigma sp a)) ∧
               (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ⇒
               BIGUNION (IMAGE f 𝕌(:num)) ∈ p) ⇒
          subsets (sigma sp a) ⊆ p
   
   [<a name="SIGMA_PROPERTY_DISJOINT_WEAK_ALT-val"><b>SIGMA_PROPERTY_DISJOINT_WEAK_ALT</b></a>]  Theorem
      
      ⊢ ∀sp p a.
          algebra (sp,a) ∧ a ⊆ p ∧ subset_class sp p ∧
          (∀s. s ∈ p ⇒ sp DIFF s ∈ p) ∧
          (∀f. f ∈ (𝕌(:num) → p) ∧ f 0 = ∅ ∧ (∀n. f n ⊆ f (SUC n)) ⇒
               BIGUNION (IMAGE f 𝕌(:num)) ∈ p) ∧
          (∀f. f ∈ (𝕌(:num) → p) ∧ (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ⇒
               BIGUNION (IMAGE f 𝕌(:num)) ∈ p) ⇒
          subsets (sigma sp a) ⊆ p
   
   [<a name="SIGMA_PROPERTY_DYNKIN-val"><b>SIGMA_PROPERTY_DYNKIN</b></a>]  Theorem
      
      ⊢ ∀sp sts d.
          subset_class sp sts ∧ (∀s t. s ∈ sts ∧ t ∈ sts ⇒ s ∩ t ∈ sts) ∧
          sts ⊆ d ∧ dynkin_system (sp,d) ⇒
          subsets (sigma sp sts) ⊆ d
   
   [<a name="SIGMA_REDUCE-val"><b>SIGMA_REDUCE</b></a>]  Theorem
      
      ⊢ ∀sp a. (sp,subsets (sigma sp a)) = sigma sp a
   
   [<a name="SIGMA_RESTRICT-val"><b>SIGMA_RESTRICT</b></a>]  Theorem
      
      ⊢ ∀sp sts B.
          subset_class sp sts ∧ B ⊆ sp ⇒
          sigma_algebra (B,IMAGE (λs. s ∩ B) (subsets (sigma sp sts))) ∧
          subsets (sigma B (IMAGE (λs. s ∩ B) sts)) =
          IMAGE (λs. s ∩ B) (subsets (sigma sp sts))
   
   [<a name="SIGMA_SIMULTANEOUSLY_MEASURABLE-val"><b>SIGMA_SIMULTANEOUSLY_MEASURABLE</b></a>]  Theorem
      
      ⊢ ∀sp A f J.
          (∀i. i ∈ J ⇒ sigma_algebra (A i)) ∧
          (∀i. i ∈ J ⇒ f i ∈ (sp → space (A i))) ⇒
          ∀i. i ∈ J ⇒ f i ∈ measurable (sigma sp A f J) (A i)
   
   [<a name="SIGMA_SMALLEST-val"><b>SIGMA_SMALLEST</b></a>]  Theorem
      
      ⊢ ∀sp sts A.
          sts ⊆ A ∧ A ⊆ subsets (sigma sp sts) ∧ sigma_algebra (sp,A) ⇒
          A = subsets (sigma sp sts)
   
   [<a name="SIGMA_STABLE-val"><b>SIGMA_STABLE</b></a>]  Theorem
      
      ⊢ ∀a. sigma_algebra a ⇒ sigma (space a) (subsets a) = a
   
   [<a name="SIGMA_STABLE_LEMMA-val"><b>SIGMA_STABLE_LEMMA</b></a>]  Theorem
      
      ⊢ ∀sp sts. sigma_algebra (sp,sts) ⇒ sigma sp sts = (sp,sts)
   
   [<a name="SIGMA_SUBSET-val"><b>SIGMA_SUBSET</b></a>]  Theorem
      
      ⊢ ∀a b.
          sigma_algebra b ∧ a ⊆ subsets b ⇒
          subsets (sigma (space b) a) ⊆ subsets b
   
   [<a name="SIGMA_SUBSET_SUBSETS-val"><b>SIGMA_SUBSET_SUBSETS</b></a>]  Theorem
      
      ⊢ ∀sp a. a ⊆ subsets (sigma sp a)
   
   [<a name="SMALLEST_RING-val"><b>SMALLEST_RING</b></a>]  Theorem
      
      ⊢ ∀sp sts. subset_class sp sts ⇒ ring (smallest_ring sp sts)
   
   [<a name="SMALLEST_RING_OF_SEMIRING-val"><b>SMALLEST_RING_OF_SEMIRING</b></a>]  Theorem
      
      ⊢ ∀sp sts.
          semiring (sp,sts) ⇒
          subsets (smallest_ring sp sts) =
          {BIGUNION c | c ⊆ sts ∧ FINITE c ∧ disjoint c}
   
   [<a name="SMALLEST_RING_SUBSET_SUBSETS-val"><b>SMALLEST_RING_SUBSET_SUBSETS</b></a>]  Theorem
      
      ⊢ ∀sp a. a ⊆ subsets (smallest_ring sp a)
   
   [<a name="SPACE-val"><b>SPACE</b></a>]  Theorem
      
      ⊢ ∀a. (space a,subsets a) = a
   
   [<a name="SPACE_DYNKIN-val"><b>SPACE_DYNKIN</b></a>]  Theorem
      
      ⊢ ∀sp sts. space (dynkin sp sts) = sp
   
   [<a name="SPACE_PROD_SIGMA-val"><b>SPACE_PROD_SIGMA</b></a>]  Theorem
      
      ⊢ ∀a b. space (a × b) = space a × space b
   
   [<a name="SPACE_SIGMA-val"><b>SPACE_SIGMA</b></a>]  Theorem
      
      ⊢ ∀sp a. space (sigma sp a) = sp
   
   [<a name="SPACE_SMALLEST_RING-val"><b>SPACE_SMALLEST_RING</b></a>]  Theorem
      
      ⊢ ∀sp sts. space (smallest_ring sp sts) = sp
   
   [<a name="SUBSET_DIFF_DISJOINT-val"><b>SUBSET_DIFF_DISJOINT</b></a>]  Theorem
      
      ⊢ ∀s1 s2 s3. s1 ⊆ s2 DIFF s3 ⇒ DISJOINT s1 s3
   
   [<a name="SUBSET_DIFF_SUBSET-val"><b>SUBSET_DIFF_SUBSET</b></a>]  Theorem
      
      ⊢ ∀r s t. s ⊆ t ⇒ s DIFF r ⊆ t
   
   [<a name="SUBSET_INTER_SUBSET_L-val"><b>SUBSET_INTER_SUBSET_L</b></a>]  Theorem
      
      ⊢ ∀r s t. s ⊆ t ⇒ s ∩ r ⊆ t
   
   [<a name="SUBSET_INTER_SUBSET_R-val"><b>SUBSET_INTER_SUBSET_R</b></a>]  Theorem
      
      ⊢ ∀r s t. s ⊆ t ⇒ r ∩ s ⊆ t
   
   [<a name="SUBSET_MONO_DIFF-val"><b>SUBSET_MONO_DIFF</b></a>]  Theorem
      
      ⊢ ∀r s t. s ⊆ t ⇒ s DIFF r ⊆ t DIFF r
   
   [<a name="SUBSET_RESTRICT_DIFF-val"><b>SUBSET_RESTRICT_DIFF</b></a>]  Theorem
      
      ⊢ ∀r s t. s ⊆ t ⇒ r DIFF t ⊆ r DIFF s
   
   [<a name="SUBSET_RESTRICT_L-val"><b>SUBSET_RESTRICT_L</b></a>]  Theorem
      
      ⊢ ∀r s t. s ⊆ t ⇒ s ∩ r ⊆ t ∩ r
   
   [<a name="SUBSET_RESTRICT_R-val"><b>SUBSET_RESTRICT_R</b></a>]  Theorem
      
      ⊢ ∀r s t. s ⊆ t ⇒ r ∩ s ⊆ r ∩ t
   
   [<a name="SUBSET_TWO-val"><b>SUBSET_TWO</b></a>]  Theorem
      
      ⊢ ∀N s t. N ⊆ {s; t} ∧ N ≠ ∅ ⇒ N = {s} ∨ N = {t} ∨ N = {s; t}
   
   [<a name="TRACE_SIGMA_ALGEBRA-val"><b>TRACE_SIGMA_ALGEBRA</b></a>]  Theorem
      
      ⊢ ∀a E.
          sigma_algebra a ∧ E ⊆ space a ⇒
          sigma_algebra (E,{A ∩ E | A ∈ subsets a})
   
   [<a name="UNION_BINARY-val"><b>UNION_BINARY</b></a>]  Theorem
      
      ⊢ ∀a b. a ∪ b = BIGUNION {binary a b i | i ∈ 𝕌(:num)}
   
   [<a name="UNION_TO_3_DISJOINT_UNIONS-val"><b>UNION_TO_3_DISJOINT_UNIONS</b></a>]  Theorem
      
      ⊢ ∀s t.
          s ∪ t = s DIFF t ∪ s ∩ t ∪ (t DIFF s) ∧
          disjoint {s DIFF t; s ∩ t; t DIFF s}
   
   [<a name="UNIV_SIGMA_ALGEBRA-val"><b>UNIV_SIGMA_ALGEBRA</b></a>]  Theorem
      
      ⊢ sigma_algebra (𝕌(:α),𝕌(:α -&gt; bool))
   
   [<a name="algebra_alt-val"><b>algebra_alt</b></a>]  Theorem
      
      ⊢ ∀sp sts. algebra (sp,sts) ⇔ ring (sp,sts) ∧ sp ∈ sts
   
   [<a name="algebra_alt_inter-val"><b>algebra_alt_inter</b></a>]  Theorem
      
      ⊢ ∀sp sts.
          algebra (sp,sts) ⇔
          sts ⊆ POW sp ∧ ∅ ∈ sts ∧ (∀a. a ∈ sts ⇒ sp DIFF a ∈ sts) ∧
          ∀a b. a ∈ sts ∧ b ∈ sts ⇒ a ∩ b ∈ sts
   
   [<a name="algebra_alt_union-val"><b>algebra_alt_union</b></a>]  Theorem
      
      ⊢ ∀sp sts.
          algebra (sp,sts) ⇔
          sts ⊆ POW sp ∧ ∅ ∈ sts ∧ (∀a. a ∈ sts ⇒ sp DIFF a ∈ sts) ∧
          ∀a b. a ∈ sts ∧ b ∈ sts ⇒ a ∪ b ∈ sts
   
   [<a name="algebra_finite_space_imp_sigma_algebra-val"><b>algebra_finite_space_imp_sigma_algebra</b></a>]  Theorem
      
      ⊢ ∀a. algebra a ∧ FINITE (space a) ⇒ sigma_algebra a
   
   [<a name="algebra_finite_subsets_imp_sigma_algebra-val"><b>algebra_finite_subsets_imp_sigma_algebra</b></a>]  Theorem
      
      ⊢ ∀a. algebra a ∧ FINITE (subsets a) ⇒ sigma_algebra a
   
   [<a name="count1_def-val"><b>count1_def</b></a>]  Theorem
      
      ⊢ ∀n. count1 n = {m | m ≤ n}
   
   [<a name="count1_numseg-val"><b>count1_numseg</b></a>]  Theorem
      
      ⊢ ∀n. count1 n = {0 .. n}
   
   [<a name="disjoint_family_def-val"><b>disjoint_family_def</b></a>]  Theorem
      
      ⊢ ∀A. disjoint_family A ⇔ ∀i j. i ≠ j ⇒ DISJOINT (A i) (A j)
   
   [<a name="disjoint_family_disjoint-val"><b>disjoint_family_disjoint</b></a>]  Theorem
      
      ⊢ ∀A. disjoint_family (disjointed A)
   
   [<a name="disjoint_family_on_def-val"><b>disjoint_family_on_def</b></a>]  Theorem
      
      ⊢ ∀A J.
          disjoint_family_on A J ⇔
          ∀i j. i ∈ J ∧ j ∈ J ∧ i ≠ j ⇒ DISJOINT (A i) (A j)
   
   [<a name="disjoint_family_on_iff_disjoint-val"><b>disjoint_family_on_iff_disjoint</b></a>]  Theorem
      
      ⊢ ∀a s.
          INJ a s (IMAGE a s) ⇒
          (disjoint_family_on a s ⇔ disjoint (IMAGE a s))
   
   [<a name="disjoint_family_on_imp_disjoint-val"><b>disjoint_family_on_imp_disjoint</b></a>]  Theorem
      
      ⊢ ∀a s. disjoint_family_on a s ⇒ disjoint (IMAGE a s)
   
   [<a name="disjointed_subset-val"><b>disjointed_subset</b></a>]  Theorem
      
      ⊢ ∀A n. disjointed A n ⊆ A n
   
   [<a name="finite_decomposition-val"><b>finite_decomposition</b></a>]  Theorem
      
      ⊢ ∀c. FINITE c ⇒
            ∃f n.
              (∀x. x &lt; n ⇒ f x ∈ c) ∧ c = IMAGE f (count n) ∧
              ∀i j. i &lt; n ∧ j &lt; n ∧ i ≠ j ⇒ f i ≠ f j
   
   [<a name="finite_decomposition_simple-val"><b>finite_decomposition_simple</b></a>]  Theorem
      
      ⊢ ∀c. FINITE c ⇒ ∃f n. (∀x. x &lt; n ⇒ f x ∈ c) ∧ c = IMAGE f (count n)
   
   [<a name="finite_disjoint_decomposition-val"><b>finite_disjoint_decomposition</b></a>]  Theorem
      
      ⊢ ∀c. FINITE c ∧ disjoint c ⇒
            ∃f n.
              (∀i. i &lt; n ⇒ f i ∈ c) ∧ c = IMAGE f (count n) ∧
              (∀i j. i &lt; n ∧ j &lt; n ∧ i ≠ j ⇒ f i ≠ f j) ∧
              ∀i j. i &lt; n ∧ j &lt; n ∧ i ≠ j ⇒ DISJOINT (f i) (f j)
   
   [<a name="finite_disjoint_decomposition'-val"><b>finite_disjoint_decomposition'</b></a>]  Theorem
      
      ⊢ ∀c. FINITE c ∧ disjoint c ⇒
            ∃f n.
              (∀i. i &lt; n ⇒ f i ∈ c) ∧ (∀i. n ≤ i ⇒ f i = ∅) ∧
              c = IMAGE f (count n) ∧
              BIGUNION c = BIGUNION (IMAGE f 𝕌(:num)) ∧
              (∀i j. i &lt; n ∧ j &lt; n ∧ i ≠ j ⇒ f i ≠ f j) ∧
              ∀i j. i &lt; n ∧ j &lt; n ∧ i ≠ j ⇒ DISJOINT (f i) (f j)
   
   [<a name="finite_enumeration_of_sets_has_max_non_empty-val"><b>finite_enumeration_of_sets_has_max_non_empty</b></a>]  Theorem
      
      ⊢ ∀f s.
          FINITE s ∧ (∀x. f x ∈ s) ∧ (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ⇒
          ∃N. ∀n. n ≥ N ⇒ f n = ∅
   
   [<a name="infinitely_often_lemma-val"><b>infinitely_often_lemma</b></a>]  Theorem
      
      ⊢ ∀P. ¬(∃N. INFINITE N ∧ ∀n. n ∈ N ⇒ P n) ⇔ ∃m. ∀n. m ≤ n ⇒ ¬P n
   
   [<a name="infinity_bound_lemma-val"><b>infinity_bound_lemma</b></a>]  Theorem
      
      ⊢ ∀N m. INFINITE N ⇒ ∃n. m ≤ n ∧ n ∈ N
   
   [<a name="prod_sigma_alt_sigma_functions-val"><b>prod_sigma_alt_sigma_functions</b></a>]  Theorem
      
      ⊢ ∀A B.
          sigma_algebra A ∧ sigma_algebra B ⇒
          A × B =
          sigma (space A × space B) (binary A B) (binary FST SND) {0; 1}
   
   [<a name="prod_sigma_alt_sigma_functions'-val"><b>prod_sigma_alt_sigma_functions'</b></a>]  Theorem
      
      ⊢ ∀A B.
          algebra A ∧ algebra B ⇒
          A × B =
          sigma (space A × space B) (binary A B) (binary FST SND) {0; 1}
   
   [<a name="restrict_algebra_SUBSET-val"><b>restrict_algebra_SUBSET</b></a>]  Theorem
      
      ⊢ ∀A sp.
          sigma_algebra A ∧ sp ∈ subsets A ⇒
          subsets (restrict_algebra A sp) ⊆ subsets A
   
   [<a name="restrict_algebra_reduce-val"><b>restrict_algebra_reduce</b></a>]  Theorem
      
      ⊢ ∀A. subset_class (space A) (subsets A) ⇒
            restrict_algebra A (space A) = A
   
   [<a name="restrict_algebra_reduce'-val"><b>restrict_algebra_reduce'</b></a>]  Theorem
      
      ⊢ ∀A. sigma_algebra A ⇒ restrict_algebra A (space A) = A
   
   [<a name="ring_alt-val"><b>ring_alt</b></a>]  Theorem
      
      ⊢ ∀sp sts.
          ring (sp,sts) ⇔
          subset_class sp sts ∧ ∅ ∈ sts ∧
          (∀s t. s ∈ sts ∧ t ∈ sts ⇒ s ∪ t ∈ sts) ∧
          ∀s t. s ∈ sts ∧ t ∈ sts ⇒ s DIFF t ∈ sts
   
   [<a name="ring_alt_pow-val"><b>ring_alt_pow</b></a>]  Theorem
      
      ⊢ ∀sp sts.
          ring (sp,sts) ⇔
          sts ⊆ POW sp ∧ ∅ ∈ sts ∧
          (∀s t. s ∈ sts ∧ t ∈ sts ⇒ s ∪ t ∈ sts) ∧
          ∀s t. s ∈ sts ∧ t ∈ sts ⇒ s DIFF t ∈ sts
   
   [<a name="ring_alt_pow_imp-val"><b>ring_alt_pow_imp</b></a>]  Theorem
      
      ⊢ ∀sp sts.
          sts ⊆ POW sp ∧ ∅ ∈ sts ∧
          (∀a b. a ∈ sts ∧ b ∈ sts ⇒ a ∪ b ∈ sts) ∧
          (∀a b. a ∈ sts ∧ b ∈ sts ⇒ a DIFF b ∈ sts) ⇒
          ring (sp,sts)
   
   [<a name="ring_and_semiring-val"><b>ring_and_semiring</b></a>]  Theorem
      
      ⊢ ∀r. ring r ⇔
            semiring r ∧
            ∀s t. s ∈ subsets r ∧ t ∈ subsets r ⇒ s ∪ t ∈ subsets r
   
   [<a name="ring_disjointed_sets-val"><b>ring_disjointed_sets</b></a>]  Theorem
      
      ⊢ ∀sp sts A.
          ring (sp,sts) ∧ IMAGE A 𝕌(:num) ⊆ sts ⇒
          IMAGE (λn. disjointed A n) 𝕌(:num) ⊆ sts
   
   [<a name="semiring_alt-val"><b>semiring_alt</b></a>]  Theorem
      
      ⊢ ∀sp sts.
          semiring (sp,sts) ⇔
          subset_class sp sts ∧ ∅ ∈ sts ∧
          (∀s t. s ∈ sts ∧ t ∈ sts ⇒ s ∩ t ∈ sts) ∧
          ∀s t.
            s ∈ sts ∧ t ∈ sts ⇒
            ∃c. c ⊆ sts ∧ FINITE c ∧ disjoint c ∧ s DIFF t = BIGUNION c
   
   [<a name="set_limsup_alt-val"><b>set_limsup_alt</b></a>]  Theorem
      
      ⊢ ∀E. limsup E =
            BIGINTER (IMAGE (λn. BIGUNION (IMAGE E (from n))) 𝕌(:num))
   
   [<a name="sigma_algebra_alt_eq-val"><b>sigma_algebra_alt_eq</b></a>]  Theorem
      
      ⊢ ∀sp sts.
          sigma_algebra (sp,sts) ⇔
          algebra (sp,sts) ∧
          ∀A. IMAGE A 𝕌(:num) ⊆ sts ⇒ BIGUNION {A i | i ∈ 𝕌(:num)} ∈ sts
   
   [<a name="sigma_algebra_alt_pow-val"><b>sigma_algebra_alt_pow</b></a>]  Theorem
      
      ⊢ ∀sp sts.
          sigma_algebra (sp,sts) ⇔
          sts ⊆ POW sp ∧ ∅ ∈ sts ∧ (∀s. s ∈ sts ⇒ sp DIFF s ∈ sts) ∧
          ∀A. IMAGE A 𝕌(:num) ⊆ sts ⇒ BIGUNION {A i | i ∈ 𝕌(:num)} ∈ sts
   
   [<a name="sigma_algebra_eq_alt-val"><b>sigma_algebra_eq_alt</b></a>]  Theorem
      
      ⊢ ∀sp sts. sigma_algebra (sp,sts) ⇔ sigma_algebra_alt sp sts
   
   [<a name="sigma_algebra_iff2-val"><b>sigma_algebra_iff2</b></a>]  Theorem
      
      ⊢ ∀sp sts.
          sigma_algebra (sp,sts) ⇔
          sts ⊆ POW sp ∧ ∅ ∈ sts ∧ (∀s. s ∈ sts ⇒ sp DIFF s ∈ sts) ∧
          ∀A. IMAGE A 𝕌(:num) ⊆ sts ⇒ BIGUNION {A i | i ∈ 𝕌(:num)} ∈ sts
   
   [<a name="sigma_algebra_restrict_algebra-val"><b>sigma_algebra_restrict_algebra</b></a>]  Theorem
      
      ⊢ ∀A sp.
          sigma_algebra A ∧ sp ∈ subsets A ⇒
          sigma_algebra (restrict_algebra A sp)
   
   [<a name="sigma_algebra_sigma_function-val"><b>sigma_algebra_sigma_function</b></a>]  Theorem
      
      ⊢ ∀sp A f.
          sigma_algebra A ∧ f ∈ (sp → space A) ⇒
          sigma_algebra (sigma sp A f)
   
   [<a name="sigma_algebra_sigma_functions-val"><b>sigma_algebra_sigma_functions</b></a>]  Theorem
      
      ⊢ ∀sp A f J.
          (∀i. f i ∈ (sp → space (A i))) ⇒ sigma_algebra (sigma sp A f J)
   
   [<a name="sigma_algebra_sigma_sets-val"><b>sigma_algebra_sigma_sets</b></a>]  Theorem
      
      ⊢ ∀sp st. st ⊆ POW sp ⇒ sigma_algebra (sp,sigma_sets sp st)
   
   [<a name="sigma_function_alt_sigma_functions-val"><b>sigma_function_alt_sigma_functions</b></a>]  Theorem
      
      ⊢ ∀sp A X.
          sigma_algebra A ∧ X ∈ (sp → space A) ⇒
          sigma sp A X = sigma sp (λn. A) (λn x. X x) (count 1)
   
   [<a name="sigma_function_subset-val"><b>sigma_function_subset</b></a>]  Theorem
      
      ⊢ ∀A B f.
          sigma_algebra A ∧ f ∈ measurable A B ⇒
          subsets (sigma (space A) B f) ⊆ subsets A
   
   [<a name="sigma_functions_1-val"><b>sigma_functions_1</b></a>]  Theorem
      
      ⊢ ∀sp A f.
          sigma_algebra A ∧ f 0 ∈ (sp → space A) ⇒
          sigma sp (λn. A) f (count 1) = sigma sp A (f 0)
   
   [<a name="sigma_functions_subset-val"><b>sigma_functions_subset</b></a>]  Theorem
      
      ⊢ ∀A B f J.
          sigma_algebra A ∧ (∀i. i ∈ J ⇒ sigma_algebra (B i)) ∧
          (∀i. i ∈ J ⇒ f i ∈ measurable A (B i)) ⇒
          subsets (sigma (space A) B f J) ⊆ subsets A
   
   [<a name="sigma_sets_BIGINTER-val"><b>sigma_sets_BIGINTER</b></a>]  Theorem
      
      ⊢ ∀sp st A.
          st ⊆ POW sp ⇒
          (∀i. A i ∈ sigma_sets sp st) ⇒
          BIGINTER {A i | i ∈ 𝕌(:num)} ∈ sigma_sets sp st
   
   [<a name="sigma_sets_BIGINTER2-val"><b>sigma_sets_BIGINTER2</b></a>]  Theorem
      
      ⊢ ∀sp st A N.
          st ⊆ POW sp ∧ (∀i. i ∈ N ⇒ A i ∈ sigma_sets sp st) ∧ N ≠ ∅ ⇒
          BIGINTER {A i | i ∈ N} ∈ sigma_sets sp st
   
   [<a name="sigma_sets_BIGUNION-val"><b>sigma_sets_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀sp st A.
          (∀i. A i ∈ sigma_sets sp st) ⇒
          BIGUNION {A i | i ∈ 𝕌(:num)} ∈ sigma_sets sp st
   
   [<a name="sigma_sets_basic-val"><b>sigma_sets_basic</b></a>]  Theorem
      
      ⊢ ∀sp st a. a ∈ st ⇒ a ∈ sigma_sets sp st
   
   [<a name="sigma_sets_cases-val"><b>sigma_sets_cases</b></a>]  Theorem
      
      ⊢ ∀sp st a0.
          sigma_sets sp st a0 ⇔
          a0 = ∅ ∨ st a0 ∨ (∃a. a0 = sp DIFF a ∧ sigma_sets sp st a) ∨
          ∃A. a0 = BIGUNION {A i | i ∈ 𝕌(:num)} ∧
              ∀i. sigma_sets sp st (A i)
   
   [<a name="sigma_sets_compl-val"><b>sigma_sets_compl</b></a>]  Theorem
      
      ⊢ ∀sp st a. a ∈ sigma_sets sp st ⇒ sp DIFF a ∈ sigma_sets sp st
   
   [<a name="sigma_sets_empty-val"><b>sigma_sets_empty</b></a>]  Theorem
      
      ⊢ ∀sp st. ∅ ∈ sigma_sets sp st
   
   [<a name="sigma_sets_eq-val"><b>sigma_sets_eq</b></a>]  Theorem
      
      ⊢ ∀sp sts. sigma_algebra (sp,sts) ⇒ sigma_sets sp sts = sts
   
   [<a name="sigma_sets_fixpoint-val"><b>sigma_sets_fixpoint</b></a>]  Theorem
      
      ⊢ ∀sp sts. sigma_algebra (sp,sts) ⇒ sigma_sets sp sts = sts
   
   [<a name="sigma_sets_ind-val"><b>sigma_sets_ind</b></a>]  Theorem
      
      ⊢ ∀sp st sigma_sets'.
          sigma_sets' ∅ ∧ (∀a. st a ⇒ sigma_sets' a) ∧
          (∀a. sigma_sets' a ⇒ sigma_sets' (sp DIFF a)) ∧
          (∀A. (∀i. sigma_sets' (A i)) ⇒
               sigma_sets' (BIGUNION {A i | i ∈ 𝕌(:num)})) ⇒
          ∀a0. sigma_sets sp st a0 ⇒ sigma_sets' a0
   
   [<a name="sigma_sets_into_sp-val"><b>sigma_sets_into_sp</b></a>]  Theorem
      
      ⊢ ∀sp st. st ⊆ POW sp ⇒ ∀x. x ∈ sigma_sets sp st ⇒ x ⊆ sp
   
   [<a name="sigma_sets_least_sigma_algebra-val"><b>sigma_sets_least_sigma_algebra</b></a>]  Theorem
      
      ⊢ ∀sp A.
          A ⊆ POW sp ⇒
          sigma_sets sp A = BIGINTER {B | A ⊆ B ∧ sigma_algebra (sp,B)}
   
   [<a name="sigma_sets_rules-val"><b>sigma_sets_rules</b></a>]  Theorem
      
      ⊢ ∀sp st.
          sigma_sets sp st ∅ ∧ (∀a. st a ⇒ sigma_sets sp st a) ∧
          (∀a. sigma_sets sp st a ⇒ sigma_sets sp st (sp DIFF a)) ∧
          ∀A. (∀i. sigma_sets sp st (A i)) ⇒
              sigma_sets sp st (BIGUNION {A i | i ∈ 𝕌(:num)})
   
   [<a name="sigma_sets_sigma-val"><b>sigma_sets_sigma</b></a>]  Theorem
      
      ⊢ ∀sp A. A ⊆ POW sp ⇒ sigma_sets sp A = subsets (sigma sp A)
   
   [<a name="sigma_sets_strongind-val"><b>sigma_sets_strongind</b></a>]  Theorem
      
      ⊢ ∀sp st sigma_sets'.
          sigma_sets' ∅ ∧ (∀a. st a ⇒ sigma_sets' a) ∧
          (∀a. sigma_sets sp st a ∧ sigma_sets' a ⇒ sigma_sets' (sp DIFF a)) ∧
          (∀A. (∀i. sigma_sets sp st (A i) ∧ sigma_sets' (A i)) ⇒
               sigma_sets' (BIGUNION {A i | i ∈ 𝕌(:num)})) ⇒
          ∀a0. sigma_sets sp st a0 ⇒ sigma_sets' a0
   
   [<a name="sigma_sets_subset-val"><b>sigma_sets_subset</b></a>]  Theorem
      
      ⊢ ∀sp sts st.
          sigma_algebra (sp,sts) ∧ st ⊆ sts ⇒ sigma_sets sp st ⊆ sts
   
   [<a name="sigma_sets_superset_generator-val"><b>sigma_sets_superset_generator</b></a>]  Theorem
      
      ⊢ ∀X A. A ⊆ sigma_sets X A
   
   [<a name="sigma_sets_top-val"><b>sigma_sets_top</b></a>]  Theorem
      
      ⊢ ∀sp A. sp ∈ sigma_sets sp A
   
   [<a name="sigma_sets_union-val"><b>sigma_sets_union</b></a>]  Theorem
      
      ⊢ ∀sp st a b.
          a ∈ sigma_sets sp st ∧ b ∈ sigma_sets sp st ⇒
          a ∪ b ∈ sigma_sets sp st
   
   [<a name="space_sigma_function-val"><b>space_sigma_function</b></a>]  Theorem
      
      ⊢ ∀sp A f. space (sigma sp A f) = sp
   
   [<a name="space_sigma_functions-val"><b>space_sigma_functions</b></a>]  Theorem
      
      ⊢ ∀sp A f J. space (sigma sp A f J) = sp
   
   [<a name="subset_class_POW-val"><b>subset_class_POW</b></a>]  Theorem
      
      ⊢ ∀sp. subset_class sp (POW sp)
   
   [<a name="tail_countable-val"><b>tail_countable</b></a>]  Theorem
      
      ⊢ ∀A m. countable {A n | m ≤ n}
   
   [<a name="tail_not_empty-val"><b>tail_not_empty</b></a>]  Theorem
      
      ⊢ ∀A m. {A n | m ≤ n} ≠ ∅
   
   [<a name="trivial_algebra_of_space-val"><b>trivial_algebra_of_space</b></a>]  Theorem
      
      ⊢ ∀sp. algebra (sp,{∅; sp})
   
   [<a name="trivial_algebra_of_two_points-val"><b>trivial_algebra_of_two_points</b></a>]  Theorem
      
      ⊢ ∀h t. algebra ({h; t},{∅; {h}; {t}; {h; t}})
   
   [<a name="trivial_algebra_of_two_sets-val"><b>trivial_algebra_of_two_sets</b></a>]  Theorem
      
      ⊢ ∀sp s. s ⊆ sp ⇒ algebra (sp,{∅; s; sp DIFF s; sp})
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/probability/.hol/objs/sigma_algebraScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-2</a></em></p></body></html>
