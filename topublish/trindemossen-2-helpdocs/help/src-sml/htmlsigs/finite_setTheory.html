<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure finite_setTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure finite_setTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/pred_set/src/more_theories/.hol/objs/finite_setScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature finite_setTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#FSET_def-val">FSET_def</a> : thm
<a name="line7"></a>    val <a href="#fBIGUNION_def-val">fBIGUNION_def</a> : thm
<a name="line8"></a>    val <a href="#fCARD_def-val">fCARD_def</a> : thm
<a name="line9"></a>    val <a href="#fDELETE_def-val">fDELETE_def</a> : thm
<a name="line10"></a>    val <a href="#fDIFF_def-val">fDIFF_def</a> : thm
<a name="line11"></a>    val <a href="#fEMPTY_def-val">fEMPTY_def</a> : thm
<a name="line12"></a>    val <a href="#fIMAGE_def-val">fIMAGE_def</a> : thm
<a name="line13"></a>    val <a href="#fINSERT_def-val">fINSERT_def</a> : thm
<a name="line14"></a>    val <a href="#fINTER_def-val">fINTER_def</a> : thm
<a name="line15"></a>    val <a href="#fIN_def-val">fIN_def</a> : thm
<a name="line16"></a>    val <a href="#fITSET_def-val">fITSET_def</a> : thm
<a name="line17"></a>    val <a href="#fMAX_SET_def-val">fMAX_SET_def</a> : thm
<a name="line18"></a>    val <a href="#fSUM_IMAGE_def-val">fSUM_IMAGE_def</a> : thm
<a name="line19"></a>    val <a href="#fUNION_def-val">fUNION_def</a> : thm
<a name="line20"></a>    val <a href="#fromSet_def-val">fromSet_def</a> : thm
<a name="line21"></a>    val <a href="#fsequiv_def-val">fsequiv_def</a> : thm
<a name="line22"></a>    val <a href="#fset_ABS_def-val">fset_ABS_def</a> : thm
<a name="line23"></a>    val <a href="#fset_REL_def-val">fset_REL_def</a> : thm
<a name="line24"></a>    val <a href="#fset_REP_def-val">fset_REP_def</a> : thm
<a name="line25"></a>    val <a href="#fset_TY_DEF-val">fset_TY_DEF</a> : thm
<a name="line26"></a>    val <a href="#fset_bijections-val">fset_bijections</a> : thm
<a name="line27"></a>    val <a href="#rel_set_def-val">rel_set_def</a> : thm
<a name="line28"></a>    val <a href="#sfSETREL_def-val">sfSETREL_def</a> : thm
<a name="line29"></a>    val <a href="#toSet_def-val">toSet_def</a> : thm
<a name="line30"></a>  
<a name="line31"></a>  (*  Theorems  *)
<a name="line32"></a>    val <a href="#ABS_CLASS_onto-val">ABS_CLASS_onto</a> : thm
<a name="line33"></a>    val <a href="#BIGUNION_relates-val">BIGUNION_relates</a> : thm
<a name="line34"></a>    val <a href="#CARD_toSet-val">CARD_toSet</a> : thm
<a name="line35"></a>    val <a href="#DECOMPOSITION-val">DECOMPOSITION</a> : thm
<a name="line36"></a>    val <a href="#DELETE_EMPTY-val">DELETE_EMPTY</a> : thm
<a name="line37"></a>    val <a href="#EXTENSION-val">EXTENSION</a> : thm
<a name="line38"></a>    val <a href="#FINITE_toSet-val">FINITE_toSet</a> : thm
<a name="line39"></a>    val <a href="#FLAT_relates-val">FLAT_relates</a> : thm
<a name="line40"></a>    val <a href="#FSETEQ-val">FSETEQ</a> : thm
<a name="line41"></a>    val <a href="#FSET_AB_eqn-val">FSET_AB_eqn</a> : thm
<a name="line42"></a>    val <a href="#FSET_right_unique-val">FSET_right_unique</a> : thm
<a name="line43"></a>    val <a href="#FSET_surj-val">FSET_surj</a> : thm
<a name="line44"></a>    val <a href="#FUN_REL_O-val">FUN_REL_O</a> : thm
<a name="line45"></a>    val <a href="#FUN_REL_RSUBSET-val">FUN_REL_RSUBSET</a> : thm
<a name="line46"></a>    val <a href="#INSERT_DELETE-val">INSERT_DELETE</a> : thm
<a name="line47"></a>    val <a href="#IN_BIGUNION-val">IN_BIGUNION</a> : thm
<a name="line48"></a>    val <a href="#IN_DELETE-val">IN_DELETE</a> : thm
<a name="line49"></a>    val <a href="#IN_DIFF-val">IN_DIFF</a> : thm
<a name="line50"></a>    val <a href="#IN_IMAGE-val">IN_IMAGE</a> : thm
<a name="line51"></a>    val <a href="#IN_INSERT-val">IN_INSERT</a> : thm
<a name="line52"></a>    val <a href="#IN_INTER-val">IN_INTER</a> : thm
<a name="line53"></a>    val <a href="#IN_UNION-val">IN_UNION</a> : thm
<a name="line54"></a>    val <a href="#IN_fromSet-val">IN_fromSet</a> : thm
<a name="line55"></a>    val <a href="#IN_toSet_fINSERT-val">IN_toSet_fINSERT</a> : thm
<a name="line56"></a>    val <a href="#LIST_REL_FSET0-val">LIST_REL_FSET0</a> : thm
<a name="line57"></a>    val <a href="#LIST_REL_FSET0_Abs-val">LIST_REL_FSET0_Abs</a> : thm
<a name="line58"></a>    val <a href="#LIST_TO_SET_rel_set-val">LIST_TO_SET_rel_set</a> : thm
<a name="line59"></a>    val <a href="#LIST_TO_SET_transfer-val">LIST_TO_SET_transfer</a> : thm
<a name="line60"></a>    val <a href="#MAP_relates-val">MAP_relates</a> : thm
<a name="line61"></a>    val <a href="#MEM_FSET0-val">MEM_FSET0</a> : thm
<a name="line62"></a>    val <a href="#MEM_fset_REP-val">MEM_fset_REP</a> : thm
<a name="line63"></a>    val <a href="#MEM_transfers-val">MEM_transfers</a> : thm
<a name="line64"></a>    val <a href="#NOT_EMPTY_INSERT-val">NOT_EMPTY_INSERT</a> : thm
<a name="line65"></a>    val <a href="#NOT_IN_EMPTY-val">NOT_IN_EMPTY</a> : thm
<a name="line66"></a>    val <a href="#Qt_composes-val">Qt_composes</a> : thm
<a name="line67"></a>    val <a href="#RDOM_FSET0-val">RDOM_FSET0</a> : thm
<a name="line68"></a>    val <a href="#RDOM_FSET0set-val">RDOM_FSET0set</a> : thm
<a name="line69"></a>    val <a href="#REP_ABS_equiv-val">REP_ABS_equiv</a> : thm
<a name="line70"></a>    val <a href="#REP_CLASS_11-val">REP_CLASS_11</a> : thm
<a name="line71"></a>    val <a href="#REP_CLASS_NONEMPTY-val">REP_CLASS_NONEMPTY</a> : thm
<a name="line72"></a>    val <a href="#RSUBSET_I-val">RSUBSET_I</a> : thm
<a name="line73"></a>    val <a href="#RSUBSET_REFL-val">RSUBSET_REFL</a> : thm
<a name="line74"></a>    val <a href="#RSUBSET_rel_set-val">RSUBSET_rel_set</a> : thm
<a name="line75"></a>    val <a href="#bijection2-val">bijection2</a> : thm
<a name="line76"></a>    val <a href="#equalityp_relset-val">equalityp_relset</a> : thm
<a name="line77"></a>    val <a href="#fABSORPTION-val">fABSORPTION</a> : thm
<a name="line78"></a>    val <a href="#fBIGUNION_fset_ABS_FOLDL-val">fBIGUNION_fset_ABS_FOLDL</a> : thm
<a name="line79"></a>    val <a href="#fBIGUNION_relates-val">fBIGUNION_relates</a> : thm
<a name="line80"></a>    val <a href="#fCARD_EQ0-val">fCARD_EQ0</a> : thm
<a name="line81"></a>    val <a href="#fCARD_THM-val">fCARD_THM</a> : thm
<a name="line82"></a>    val <a href="#fCARD_relates-val">fCARD_relates</a> : thm
<a name="line83"></a>    val <a href="#fDELETE_INSERT-val">fDELETE_INSERT</a> : thm
<a name="line84"></a>    val <a href="#fDELETE_UNION-val">fDELETE_UNION</a> : thm
<a name="line85"></a>    val <a href="#fDELETE_nonelement-val">fDELETE_nonelement</a> : thm
<a name="line86"></a>    val <a href="#fDELETE_relates-val">fDELETE_relates</a> : thm
<a name="line87"></a>    val <a href="#fDIFF_relates-val">fDIFF_relates</a> : thm
<a name="line88"></a>    val <a href="#fEMPTY_relates-val">fEMPTY_relates</a> : thm
<a name="line89"></a>    val <a href="#fIMAGE_11-val">fIMAGE_11</a> : thm
<a name="line90"></a>    val <a href="#fIMAGE_COMPOSE-val">fIMAGE_COMPOSE</a> : thm
<a name="line91"></a>    val <a href="#fIMAGE_ID-val">fIMAGE_ID</a> : thm
<a name="line92"></a>    val <a href="#fIMAGE_fUNION-val">fIMAGE_fUNION</a> : thm
<a name="line93"></a>    val <a href="#fIMAGE_relates-val">fIMAGE_relates</a> : thm
<a name="line94"></a>    val <a href="#fIMAGE_thm-val">fIMAGE_thm</a> : thm
<a name="line95"></a>    val <a href="#fINSERT_commutes-val">fINSERT_commutes</a> : thm
<a name="line96"></a>    val <a href="#fINSERT_duplicates-val">fINSERT_duplicates</a> : thm
<a name="line97"></a>    val <a href="#fINSERT_relates-val">fINSERT_relates</a> : thm
<a name="line98"></a>    val <a href="#fINSERT_sfSETREL-val">fINSERT_sfSETREL</a> : thm
<a name="line99"></a>    val <a href="#fINTER_COMM-val">fINTER_COMM</a> : thm
<a name="line100"></a>    val <a href="#fINTER_EMPTY-val">fINTER_EMPTY</a> : thm
<a name="line101"></a>    val <a href="#fINTER_IDEMPOT-val">fINTER_IDEMPOT</a> : thm
<a name="line102"></a>    val <a href="#fINTER_INSERT-val">fINTER_INSERT</a> : thm
<a name="line103"></a>    val <a href="#fINTER_relates-val">fINTER_relates</a> : thm
<a name="line104"></a>    val <a href="#fIN_IN-val">fIN_IN</a> : thm
<a name="line105"></a>    val <a href="#fIN_fMAX_SET-val">fIN_fMAX_SET</a> : thm
<a name="line106"></a>    val <a href="#fIN_fset_ABS-val">fIN_fset_ABS</a> : thm
<a name="line107"></a>    val <a href="#fIN_relates-val">fIN_relates</a> : thm
<a name="line108"></a>    val <a href="#fIN_sfSETREL-val">fIN_sfSETREL</a> : thm
<a name="line109"></a>    val <a href="#fITSET_EMPTY-val">fITSET_EMPTY</a> : thm
<a name="line110"></a>    val <a href="#fITSET_INSERT-val">fITSET_INSERT</a> : thm
<a name="line111"></a>    val <a href="#fITSET_INSERT_tail-val">fITSET_INSERT_tail</a> : thm
<a name="line112"></a>    val <a href="#fITSETr_cases-val">fITSETr_cases</a> : thm
<a name="line113"></a>    val <a href="#fITSETr_functional-val">fITSETr_functional</a> : thm
<a name="line114"></a>    val <a href="#fITSETr_ind-val">fITSETr_ind</a> : thm
<a name="line115"></a>    val <a href="#fITSETr_rules-val">fITSETr_rules</a> : thm
<a name="line116"></a>    val <a href="#fITSETr_strongind-val">fITSETr_strongind</a> : thm
<a name="line117"></a>    val <a href="#fITSETr_total-val">fITSETr_total</a> : thm
<a name="line118"></a>    val <a href="#fMAX_SET_SUBSET-val">fMAX_SET_SUBSET</a> : thm
<a name="line119"></a>    val <a href="#fMAX_SET_THM-val">fMAX_SET_THM</a> : thm
<a name="line120"></a>    val <a href="#fMAX_SET_fIN-val">fMAX_SET_fIN</a> : thm
<a name="line121"></a>    val <a href="#fSUM_IMAGE_SUBSET-val">fSUM_IMAGE_SUBSET</a> : thm
<a name="line122"></a>    val <a href="#fSUM_IMAGE_THM-val">fSUM_IMAGE_THM</a> : thm
<a name="line123"></a>    val <a href="#fSUM_IMAGE_UNION-val">fSUM_IMAGE_UNION</a> : thm
<a name="line124"></a>    val <a href="#fUNION_ASSOC-val">fUNION_ASSOC</a> : thm
<a name="line125"></a>    val <a href="#fUNION_COMM-val">fUNION_COMM</a> : thm
<a name="line126"></a>    val <a href="#fUNION_EMPTY-val">fUNION_EMPTY</a> : thm
<a name="line127"></a>    val <a href="#fUNION_EQ_EMPTY-val">fUNION_EQ_EMPTY</a> : thm
<a name="line128"></a>    val <a href="#fUNION_IDEMPOT-val">fUNION_IDEMPOT</a> : thm
<a name="line129"></a>    val <a href="#fUNION_INSERT-val">fUNION_INSERT</a> : thm
<a name="line130"></a>    val <a href="#fUNION_relates-val">fUNION_relates</a> : thm
<a name="line131"></a>    val <a href="#fUNION_sfSETREL-val">fUNION_sfSETREL</a> : thm
<a name="line132"></a>    val <a href="#fromSet_EMPTY-val">fromSet_EMPTY</a> : thm
<a name="line133"></a>    val <a href="#fromSet_INSERT-val">fromSet_INSERT</a> : thm
<a name="line134"></a>    val <a href="#fromSet_set-val">fromSet_set</a> : thm
<a name="line135"></a>    val <a href="#fromSet_toSet-val">fromSet_toSet</a> : thm
<a name="line136"></a>    val <a href="#fsequiv_equiv-val">fsequiv_equiv</a> : thm
<a name="line137"></a>    val <a href="#fsequiv_refl-val">fsequiv_refl</a> : thm
<a name="line138"></a>    val <a href="#fset0Q-val">fset0Q</a> : thm
<a name="line139"></a>    val <a href="#fset_ABS_11-val">fset_ABS_11</a> : thm
<a name="line140"></a>    val <a href="#fset_ABS_MAP-val">fset_ABS_MAP</a> : thm
<a name="line141"></a>    val <a href="#fset_ABS_REP-val">fset_ABS_REP</a> : thm
<a name="line142"></a>    val <a href="#fset_ABS_REP_CLASS-val">fset_ABS_REP_CLASS</a> : thm
<a name="line143"></a>    val <a href="#fset_ABS_onto-val">fset_ABS_onto</a> : thm
<a name="line144"></a>    val <a href="#fset_QUOTIENT-val">fset_QUOTIENT</a> : thm
<a name="line145"></a>    val <a href="#fset_REP_11-val">fset_REP_11</a> : thm
<a name="line146"></a>    val <a href="#fset_REP_fEMPTY-val">fset_REP_fEMPTY</a> : thm
<a name="line147"></a>    val <a href="#fset_cases-val">fset_cases</a> : thm
<a name="line148"></a>    val <a href="#fset_induction-val">fset_induction</a> : thm
<a name="line149"></a>    val <a href="#left_unique_rel_set-val">left_unique_rel_set</a> : thm
<a name="line150"></a>    val <a href="#rel_setEQ-val">rel_setEQ</a> : thm
<a name="line151"></a>    val <a href="#rel_set_RSUBSET-val">rel_set_RSUBSET</a> : thm
<a name="line152"></a>    val <a href="#rel_set_empty-val">rel_set_empty</a> : thm
<a name="line153"></a>    val <a href="#right_unique_FSET0-val">right_unique_FSET0</a> : thm
<a name="line154"></a>    val <a href="#right_unique_rel_set-val">right_unique_rel_set</a> : thm
<a name="line155"></a>    val <a href="#set_BIGUNION-val">set_BIGUNION</a> : thm
<a name="line156"></a>    val <a href="#set_IMAGE-val">set_IMAGE</a> : thm
<a name="line157"></a>    val <a href="#surj_FSET0-val">surj_FSET0</a> : thm
<a name="line158"></a>    val <a href="#surjfns-val">surjfns</a> : thm
<a name="line159"></a>    val <a href="#toSet_11-val">toSet_11</a> : thm
<a name="line160"></a>    val <a href="#toSet_Qt-val">toSet_Qt</a> : thm
<a name="line161"></a>    val <a href="#toSet_fEMPTY-val">toSet_fEMPTY</a> : thm
<a name="line162"></a>    val <a href="#toSet_fIMAGE-val">toSet_fIMAGE</a> : thm
<a name="line163"></a>    val <a href="#toSet_fINSERT-val">toSet_fINSERT</a> : thm
<a name="line164"></a>    val <a href="#toSet_fUNION-val">toSet_fUNION</a> : thm
<a name="line165"></a>    val <a href="#toSet_fromSet-val">toSet_fromSet</a> : thm
<a name="line166"></a>    val <a href="#toSet_fset_ABS-val">toSet_fset_ABS</a> : thm
<a name="line167"></a>    val <a href="#toSet_rel_set_relates-val">toSet_rel_set_relates</a> : thm
<a name="line168"></a>    val <a href="#toSet_relates-val">toSet_relates</a> : thm
<a name="line169"></a>    val <a href="#total_FSET-val">total_FSET</a> : thm
<a name="line170"></a>(*
   [lifting] Parent theory of "finite_set"
   
   [<a name="FSET_def-val"><b>FSET_def</b></a>]  Definition
      
      ⊢ ∀AB al bfs.
          FSET AB al bfs ⇔ ∃bl. LIST_REL AB al bl ∧ bfs = fset_ABS bl
   
   [<a name="fBIGUNION_def-val"><b>fBIGUNION_def</b></a>]  Definition
      
      ⊢ fBIGUNION = (MAP fset_REP ∘ fset_REP ---&gt; fset_ABS) FLAT
   
   [<a name="fCARD_def-val"><b>fCARD_def</b></a>]  Definition
      
      ⊢ fCARD = (fset_REP ---&gt; I) (LENGTH ∘ nub)
   
   [<a name="fDELETE_def-val"><b>fDELETE_def</b></a>]  Definition
      
      ⊢ fDELETE = (I ---&gt; fset_REP ---&gt; fset_ABS) (λe. FILTER ($¬ ∘ $= e))
   
   [<a name="fDIFF_def-val"><b>fDIFF_def</b></a>]  Definition
      
      ⊢ fDIFF =
        (fset_REP ---&gt; fset_REP ---&gt; fset_ABS)
          (λl1 l2. FILTER (λx. ¬MEM x l2) l1)
   
   [<a name="fEMPTY_def-val"><b>fEMPTY_def</b></a>]  Definition
      
      ⊢ fEMPTY = fset_ABS []
   
   [<a name="fIMAGE_def-val"><b>fIMAGE_def</b></a>]  Definition
      
      ⊢ fIMAGE = ((I ---&gt; I) ---&gt; fset_REP ---&gt; fset_ABS) MAP
   
   [<a name="fINSERT_def-val"><b>fINSERT_def</b></a>]  Definition
      
      ⊢ fINSERT = (I ---&gt; fset_REP ---&gt; fset_ABS) CONS
   
   [<a name="fINTER_def-val"><b>fINTER_def</b></a>]  Definition
      
      ⊢ fINTER =
        (fset_REP ---&gt; fset_REP ---&gt; fset_ABS) (FILTER ∘ flip $IN ∘ set)
   
   [<a name="fIN_def-val"><b>fIN_def</b></a>]  Definition
      
      ⊢ fIN = (I ---&gt; fset_REP ---&gt; I) (λx l. MEM x l)
   
   [<a name="fITSET_def-val"><b>fITSET_def</b></a>]  Definition
      
      ⊢ ∀f s a0. fITSET f s a0 = @a. fITSETr f s a0 a
   
   [<a name="fMAX_SET_def-val"><b>fMAX_SET_def</b></a>]  Definition
      
      ⊢ ∀s. fMAX_SET s = fITSET MAX s 0
   
   [<a name="fSUM_IMAGE_def-val"><b>fSUM_IMAGE_def</b></a>]  Definition
      
      ⊢ ∀f s. fSUM_IMAGE f s = fITSET (λe a. f e + a) s 0
   
   [<a name="fUNION_def-val"><b>fUNION_def</b></a>]  Definition
      
      ⊢ fUNION = (fset_REP ---&gt; fset_REP ---&gt; fset_ABS) $++
   
   [<a name="fromSet_def-val"><b>fromSet_def</b></a>]  Definition
      
      ⊢ ∀s. fromSet s = ITSET fINSERT s fEMPTY
   
   [<a name="fsequiv_def-val"><b>fsequiv_def</b></a>]  Definition
      
      ⊢ ∀l1 l2. fsequiv l1 l2 ⇔ set l1 = set l2
   
   [<a name="fset_ABS_def-val"><b>fset_ABS_def</b></a>]  Definition
      
      ⊢ ∀r. fset_ABS r = fset_ABS_CLASS (fsequiv r)
   
   [<a name="fset_REL_def-val"><b>fset_REL_def</b></a>]  Definition
      
      ⊢ ∀AB fs1 fs2.
          fset_REL AB fs1 fs2 ⇔ ∀a b. AB a b ⇒ (fIN a fs1 ⇔ fIN b fs2)
   
   [<a name="fset_REP_def-val"><b>fset_REP_def</b></a>]  Definition
      
      ⊢ ∀a. fset_REP a = $@ (fset_REP_CLASS a)
   
   [<a name="fset_TY_DEF-val"><b>fset_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep. TYPE_DEFINITION (λc. ∃r. fsequiv r r ∧ c = fsequiv r) rep
   
   [<a name="fset_bijections-val"><b>fset_bijections</b></a>]  Definition
      
      ⊢ (∀a. fset_ABS_CLASS (fset_REP_CLASS a) = a) ∧
        ∀r. (λc. ∃r. fsequiv r r ∧ c = fsequiv r) r ⇔
            fset_REP_CLASS (fset_ABS_CLASS r) = r
   
   [<a name="rel_set_def-val"><b>rel_set_def</b></a>]  Definition
      
      ⊢ ∀AB A B.
          rel_set AB A B ⇔
          (∀a. a ∈ A ⇒ ∃b. b ∈ B ∧ AB a b) ∧ ∀b. b ∈ B ⇒ ∃a. a ∈ A ∧ AB a b
   
   [<a name="sfSETREL_def-val"><b>sfSETREL_def</b></a>]  Definition
      
      ⊢ ∀AB s fs.
          sfSETREL AB s fs ⇔
          (∀a. a ∈ s ⇒ ∃b. fIN b fs ∧ AB a b) ∧
          ∀b. fIN b fs ⇒ ∃a. a ∈ s ∧ AB a b
   
   [<a name="toSet_def-val"><b>toSet_def</b></a>]  Definition
      
      ⊢ ∀fs. toSet fs = {x | fIN x fs}
   
   [<a name="ABS_CLASS_onto-val"><b>ABS_CLASS_onto</b></a>]  Theorem
      
      ⊢ ∀fs. ∃r. fs = fset_ABS_CLASS (fsequiv r)
   
   [<a name="BIGUNION_relates-val"><b>BIGUNION_relates</b></a>]  Theorem
      
      ⊢ FUN_REL (rel_set (rel_set AB)) (rel_set AB) BIGUNION BIGUNION
   
   [<a name="CARD_toSet-val"><b>CARD_toSet</b></a>]  Theorem
      
      ⊢ CARD (toSet s) = fCARD s
   
   [<a name="DECOMPOSITION-val"><b>DECOMPOSITION</b></a>]  Theorem
      
      ⊢ fIN e s ⇔ ∃s0. s = fINSERT e s0 ∧ ¬fIN e s0
   
   [<a name="DELETE_EMPTY-val"><b>DELETE_EMPTY</b></a>]  Theorem
      
      ⊢ ∀e. fDELETE e fEMPTY = fEMPTY
   
   [<a name="EXTENSION-val"><b>EXTENSION</b></a>]  Theorem
      
      ⊢ ∀s1 s2. s1 = s2 ⇔ ∀e. fIN e s1 ⇔ fIN e s2
   
   [<a name="FINITE_toSet-val"><b>FINITE_toSet</b></a>]  Theorem
      
      ⊢ ∀s. FINITE (toSet s)
   
   [<a name="FLAT_relates-val"><b>FLAT_relates</b></a>]  Theorem
      
      ⊢ FUN_REL (LIST_REL (LIST_REL AB)) (LIST_REL AB) FLAT FLAT
   
   [<a name="FSETEQ-val"><b>FSETEQ</b></a>]  Theorem
      
      ⊢ FUN_REL FSET0 (FUN_REL FSET0 $&lt;=&gt;) fsequiv $=
   
   [<a name="FSET_AB_eqn-val"><b>FSET_AB_eqn</b></a>]  Theorem
      
      ⊢ FSET AB = FSET0 ∘ᵣ LIST_REL AB
   
   [<a name="FSET_right_unique-val"><b>FSET_right_unique</b></a>]  Theorem
      
      ⊢ right_unique AB ⇒ right_unique (FSET AB)
   
   [<a name="FSET_surj-val"><b>FSET_surj</b></a>]  Theorem
      
      ⊢ surj AB ⇒ surj (FSET AB)
   
   [<a name="FUN_REL_O-val"><b>FUN_REL_O</b></a>]  Theorem
      
      ⊢ FUN_REL D1 R1 ∘ᵣ FUN_REL D2 R2 ⊆ᵣ FUN_REL (D1 ∘ᵣ D2) (R1 ∘ᵣ R2)
   
   [<a name="FUN_REL_RSUBSET-val"><b>FUN_REL_RSUBSET</b></a>]  Theorem
      
      ⊢ D2 ⊆ᵣ D1 ∧ R1 ⊆ᵣ R2 ⇒ FUN_REL D1 R1 ⊆ᵣ FUN_REL D2 R2
   
   [<a name="INSERT_DELETE-val"><b>INSERT_DELETE</b></a>]  Theorem
      
      ⊢ ∀e s. fINSERT e (fDELETE e s) = fINSERT e s
   
   [<a name="IN_BIGUNION-val"><b>IN_BIGUNION</b></a>]  Theorem
      
      ⊢ fIN e (fBIGUNION fss) ⇔ ∃fs. fIN fs fss ∧ fIN e fs
   
   [<a name="IN_DELETE-val"><b>IN_DELETE</b></a>]  Theorem
      
      ⊢ ∀a b s. fIN a (fDELETE b s) ⇔ a ≠ b ∧ fIN a s
   
   [<a name="IN_DIFF-val"><b>IN_DIFF</b></a>]  Theorem
      
      ⊢ ∀e s1 s2. fIN e (fDIFF s1 s2) ⇔ fIN e s1 ∧ ¬fIN e s2
   
   [<a name="IN_IMAGE-val"><b>IN_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f x s. fIN x (fIMAGE f s) ⇔ ∃y. fIN y s ∧ x = f y
   
   [<a name="IN_INSERT-val"><b>IN_INSERT</b></a>]  Theorem
      
      ⊢ ∀e1 e2 s. fIN e1 (fINSERT e2 s) ⇔ e1 = e2 ∨ fIN e1 s
   
   [<a name="IN_INTER-val"><b>IN_INTER</b></a>]  Theorem
      
      ⊢ ∀e s1 s2. fIN e (fINTER s1 s2) ⇔ fIN e s1 ∧ fIN e s2
   
   [<a name="IN_UNION-val"><b>IN_UNION</b></a>]  Theorem
      
      ⊢ ∀e s1 s2. fIN e (fUNION s1 s2) ⇔ fIN e s1 ∨ fIN e s2
   
   [<a name="IN_fromSet-val"><b>IN_fromSet</b></a>]  Theorem
      
      ⊢ FINITE s ⇒ (fIN e (fromSet s) ⇔ e ∈ s)
   
   [<a name="IN_toSet_fINSERT-val"><b>IN_toSet_fINSERT</b></a>]  Theorem
      
      ⊢ x ∈ toSet (fINSERT a s) ⇔ x = a ∨ x ∈ toSet s
   
   [<a name="LIST_REL_FSET0-val"><b>LIST_REL_FSET0</b></a>]  Theorem
      
      ⊢ Qt (LIST_REL fsequiv) (MAP fset_ABS) (MAP fset_REP)
          (LIST_REL FSET0)
   
   [<a name="LIST_REL_FSET0_Abs-val"><b>LIST_REL_FSET0_Abs</b></a>]  Theorem
      
      ⊢ LIST_REL FSET0 ll lfs ⇒ lfs = MAP fset_ABS ll
   
   [<a name="LIST_TO_SET_rel_set-val"><b>LIST_TO_SET_rel_set</b></a>]  Theorem
      
      ⊢ FUN_REL (LIST_REL AB) (rel_set AB) set set
   
   [<a name="LIST_TO_SET_transfer-val"><b>LIST_TO_SET_transfer</b></a>]  Theorem
      
      ⊢ FUN_REL (LIST_REL AB) (rel_set AB) set set
   
   [<a name="MAP_relates-val"><b>MAP_relates</b></a>]  Theorem
      
      ⊢ FUN_REL (FUN_REL AB CD) (FUN_REL (LIST_REL AB) (LIST_REL CD)) MAP
          MAP
   
   [<a name="MEM_FSET0-val"><b>MEM_FSET0</b></a>]  Theorem
      
      ⊢ FSET0 l fs ⇒ ∀a. MEM a l ⇔ fIN a fs
   
   [<a name="MEM_fset_REP-val"><b>MEM_fset_REP</b></a>]  Theorem
      
      ⊢ MEM x (fset_REP fs) ⇔ fIN x fs
   
   [<a name="MEM_transfers-val"><b>MEM_transfers</b></a>]  Theorem
      
      ⊢ bi_unique AB ⇒
        FUN_REL AB (FUN_REL (LIST_REL AB) $&lt;=&gt;) (λx l. MEM x l)
          (λx l. MEM x l)
   
   [<a name="NOT_EMPTY_INSERT-val"><b>NOT_EMPTY_INSERT</b></a>]  Theorem
      
      ⊢ ∀h t. fEMPTY ≠ fINSERT h t
   
   [<a name="NOT_IN_EMPTY-val"><b>NOT_IN_EMPTY</b></a>]  Theorem
      
      ⊢ ∀e. ¬fIN e fEMPTY
   
   [<a name="Qt_composes-val"><b>Qt_composes</b></a>]  Theorem
      
      ⊢ Qt R1 Abs1 Rep1 Tf1 ∧ Qt R2 Abs2 Rep2 Tf2 ⇒
        Qt (Tf1ᵀ ∘ᵣ R2 ∘ᵣ Tf1) (Abs2 ∘ Abs1) (Rep1 ∘ Rep2) (Tf2 ∘ᵣ Tf1)
   
   [<a name="RDOM_FSET0-val"><b>RDOM_FSET0</b></a>]  Theorem
      
      ⊢ RDOM (FSET AB) = (λal. ∀x. MEM x al ⇒ RDOM AB x)
   
   [<a name="RDOM_FSET0set-val"><b>RDOM_FSET0set</b></a>]  Theorem
      
      ⊢ RDOM (FUN_REL FSET0 $&lt;=&gt;) =
        (λlP. ∀l1 l2. lP l1 ∧ fsequiv l1 l2 ⇒ lP l2)
   
   [<a name="REP_ABS_equiv-val"><b>REP_ABS_equiv</b></a>]  Theorem
      
      ⊢ fset_REP_CLASS (fset_ABS_CLASS (fsequiv r)) = fsequiv r
   
   [<a name="REP_CLASS_11-val"><b>REP_CLASS_11</b></a>]  Theorem
      
      ⊢ fset_REP_CLASS fs1 = fset_REP_CLASS fs2 ⇔ fs1 = fs2
   
   [<a name="REP_CLASS_NONEMPTY-val"><b>REP_CLASS_NONEMPTY</b></a>]  Theorem
      
      ⊢ ∀fs. ∃x. fset_REP_CLASS fs x
   
   [<a name="RSUBSET_I-val"><b>RSUBSET_I</b></a>]  Theorem
      
      ⊢ R1 ⊆ᵣ R2 ⇒ R1 x y ⇒ R2 x y
   
   [<a name="RSUBSET_REFL-val"><b>RSUBSET_REFL</b></a>]  Theorem
      
      ⊢ R ⊆ᵣ R
   
   [<a name="RSUBSET_rel_set-val"><b>RSUBSET_rel_set</b></a>]  Theorem
      
      ⊢ bitotal AB ⇒ FUN_REL AB $&lt;=&gt; ⊆ᵣ rel_set AB
   
   [<a name="bijection2-val"><b>bijection2</b></a>]  Theorem
      
      ⊢ ∀r. fset_REP_CLASS (fset_ABS_CLASS (fsequiv r)) = fsequiv r
   
   [<a name="equalityp_relset-val"><b>equalityp_relset</b></a>]  Theorem
      
      ⊢ equalityp AB ⇒ equalityp (rel_set AB)
   
   [<a name="fABSORPTION-val"><b>fABSORPTION</b></a>]  Theorem
      
      ⊢ ∀a A. fIN a A ⇔ fINSERT a A = A
   
   [<a name="fBIGUNION_fset_ABS_FOLDL-val"><b>fBIGUNION_fset_ABS_FOLDL</b></a>]  Theorem
      
      ⊢ fBIGUNION (fset_ABS l) = FOLDL fUNION fEMPTY l
   
   [<a name="fBIGUNION_relates-val"><b>fBIGUNION_relates</b></a>]  Theorem
      
      ⊢ FUN_REL (FSET (FSET AB)) (FSET AB) FLAT fBIGUNION
   
   [<a name="fCARD_EQ0-val"><b>fCARD_EQ0</b></a>]  Theorem
      
      ⊢ ∀s. fCARD s = 0 ⇔ s = fEMPTY
   
   [<a name="fCARD_THM-val"><b>fCARD_THM</b></a>]  Theorem
      
      ⊢ fCARD fEMPTY = 0 ∧
        ∀e s. fCARD (fINSERT e s) = 1 + fCARD (fDELETE e s)
   
   [<a name="fCARD_relates-val"><b>fCARD_relates</b></a>]  Theorem
      
      ⊢ FUN_REL FSET0 $= (LENGTH ∘ nub) fCARD
   
   [<a name="fDELETE_INSERT-val"><b>fDELETE_INSERT</b></a>]  Theorem
      
      ⊢ fDELETE a (fINSERT a A) = fDELETE a A
   
   [<a name="fDELETE_UNION-val"><b>fDELETE_UNION</b></a>]  Theorem
      
      ⊢ fDELETE e (fUNION A B) = fUNION (fDELETE e A) (fDELETE e B)
   
   [<a name="fDELETE_nonelement-val"><b>fDELETE_nonelement</b></a>]  Theorem
      
      ⊢ ∀e s. ¬fIN e s ⇒ fDELETE e s = s
   
   [<a name="fDELETE_relates-val"><b>fDELETE_relates</b></a>]  Theorem
      
      ⊢ FUN_REL $= (FUN_REL FSET0 FSET0) (λe. FILTER ($¬ ∘ $= e)) fDELETE
   
   [<a name="fDIFF_relates-val"><b>fDIFF_relates</b></a>]  Theorem
      
      ⊢ FUN_REL FSET0 (FUN_REL FSET0 FSET0)
          (λl1 l2. FILTER (λx. ¬MEM x l2) l1) fDIFF
   
   [<a name="fEMPTY_relates-val"><b>fEMPTY_relates</b></a>]  Theorem
      
      ⊢ FSET0 [] fEMPTY
   
   [<a name="fIMAGE_11-val"><b>fIMAGE_11</b></a>]  Theorem
      
      ⊢ (∀x y. f x = f y ⇔ x = y) ⇒ (fIMAGE f x = fIMAGE f y ⇔ x = y)
   
   [<a name="fIMAGE_COMPOSE-val"><b>fIMAGE_COMPOSE</b></a>]  Theorem
      
      ⊢ fIMAGE (f ∘ g) s = fIMAGE f (fIMAGE g s)
   
   [<a name="fIMAGE_ID-val"><b>fIMAGE_ID</b></a>]  Theorem
      
      ⊢ fIMAGE (λx. x) s = s ∧ fIMAGE I s = s
   
   [<a name="fIMAGE_fUNION-val"><b>fIMAGE_fUNION</b></a>]  Theorem
      
      ⊢ fIMAGE f (fUNION s1 s2) = fUNION (fIMAGE f s1) (fIMAGE f s2)
   
   [<a name="fIMAGE_relates-val"><b>fIMAGE_relates</b></a>]  Theorem
      
      ⊢ FUN_REL (FUN_REL AB CD) (FUN_REL (FSET AB) (FSET CD)) MAP fIMAGE
   
   [<a name="fIMAGE_thm-val"><b>fIMAGE_thm</b></a>]  Theorem
      
      ⊢ (∀f. fIMAGE f fEMPTY = fEMPTY) ∧
        ∀f e s. fIMAGE f (fINSERT e s) = fINSERT (f e) (fIMAGE f s)
   
   [<a name="fINSERT_commutes-val"><b>fINSERT_commutes</b></a>]  Theorem
      
      ⊢ ∀e1 e2 s. fINSERT e1 (fINSERT e2 s) = fINSERT e2 (fINSERT e1 s)
   
   [<a name="fINSERT_duplicates-val"><b>fINSERT_duplicates</b></a>]  Theorem
      
      ⊢ ∀e s. fINSERT e (fINSERT e s) = fINSERT e s
   
   [<a name="fINSERT_relates-val"><b>fINSERT_relates</b></a>]  Theorem
      
      ⊢ FUN_REL $= (FUN_REL FSET0 FSET0) CONS fINSERT
   
   [<a name="fINSERT_sfSETREL-val"><b>fINSERT_sfSETREL</b></a>]  Theorem
      
      ⊢ FUN_REL AB (FUN_REL (sfSETREL AB) (sfSETREL AB)) $INSERT fINSERT
   
   [<a name="fINTER_COMM-val"><b>fINTER_COMM</b></a>]  Theorem
      
      ⊢ fINTER a b = fINTER b a
   
   [<a name="fINTER_EMPTY-val"><b>fINTER_EMPTY</b></a>]  Theorem
      
      ⊢ ∀x. fINTER x fEMPTY = fEMPTY ∧ fINTER fEMPTY x = fEMPTY
   
   [<a name="fINTER_IDEMPOT-val"><b>fINTER_IDEMPOT</b></a>]  Theorem
      
      ⊢ ∀x. fINTER x x = x
   
   [<a name="fINTER_INSERT-val"><b>fINTER_INSERT</b></a>]  Theorem
      
      ⊢ fINTER (fINSERT a A) B =
        (if fIN a B then fINSERT a (fINTER A B) else fINTER A B) ∧
        fINTER A (fINSERT b B) =
        if fIN b A then fINSERT b (fINTER A B) else fINTER A B
   
   [<a name="fINTER_relates-val"><b>fINTER_relates</b></a>]  Theorem
      
      ⊢ FUN_REL FSET0 (FUN_REL FSET0 FSET0) (FILTER ∘ flip $IN ∘ set)
          fINTER
   
   [<a name="fIN_IN-val"><b>fIN_IN</b></a>]  Theorem
      
      ⊢ ∀e fs. fIN e fs ⇔ e ∈ toSet fs
   
   [<a name="fIN_fMAX_SET-val"><b>fIN_fMAX_SET</b></a>]  Theorem
      
      ⊢ ∀A e. fIN e A ⇒ e ≤ fMAX_SET A
   
   [<a name="fIN_fset_ABS-val"><b>fIN_fset_ABS</b></a>]  Theorem
      
      ⊢ fIN x (fset_ABS l) ⇔ MEM x l
   
   [<a name="fIN_relates-val"><b>fIN_relates</b></a>]  Theorem
      
      ⊢ bi_unique AB ⇒
        FUN_REL AB (FUN_REL (FSET AB) $&lt;=&gt;) (λx l. MEM x l) fIN
   
   [<a name="fIN_sfSETREL-val"><b>fIN_sfSETREL</b></a>]  Theorem
      
      ⊢ bi_unique AB ⇒ FUN_REL AB (FUN_REL (sfSETREL AB) $&lt;=&gt;) $IN fIN
   
   [<a name="fITSET_EMPTY-val"><b>fITSET_EMPTY</b></a>]  Theorem
      
      ⊢ fITSET f fEMPTY a = a
   
   [<a name="fITSET_INSERT-val"><b>fITSET_INSERT</b></a>]  Theorem
      
      ⊢ (∀x y a. f x (f y a) = f y (f x a)) ⇒
        ∀e s a. fITSET f (fINSERT e s) a = f e (fITSET f (fDELETE e s) a)
   
   [<a name="fITSET_INSERT_tail-val"><b>fITSET_INSERT_tail</b></a>]  Theorem
      
      ⊢ (∀x y a. f x (f y a) = f y (f x a)) ⇒
        ∀e s a. fITSET f (fINSERT e s) a = fITSET f (fDELETE e s) (f e a)
   
   [<a name="fITSETr_cases-val"><b>fITSETr_cases</b></a>]  Theorem
      
      ⊢ ∀f a0 a1 a2.
          fITSETr f a0 a1 a2 ⇔
          a0 = fEMPTY ∧ a2 = a1 ∨
          ∃e s A1.
            a0 = fINSERT e s ∧ a2 = f e A1 ∧ fITSETr f s a1 A1 ∧ ¬fIN e s
   
   [<a name="fITSETr_functional-val"><b>fITSETr_functional</b></a>]  Theorem
      
      ⊢ (∀x y a. f x (f y a) = f y (f x a)) ⇒
        ∀s a0 a1 a2. fITSETr f s a0 a1 ∧ fITSETr f s a0 a2 ⇒ a1 = a2
   
   [<a name="fITSETr_ind-val"><b>fITSETr_ind</b></a>]  Theorem
      
      ⊢ ∀f fITSETr'.
          (∀A. fITSETr' fEMPTY A A) ∧
          (∀e s A0 A1.
             fITSETr' s A0 A1 ∧ ¬fIN e s ⇒
             fITSETr' (fINSERT e s) A0 (f e A1)) ⇒
          ∀a0 a1 a2. fITSETr f a0 a1 a2 ⇒ fITSETr' a0 a1 a2
   
   [<a name="fITSETr_rules-val"><b>fITSETr_rules</b></a>]  Theorem
      
      ⊢ ∀f. (∀A. fITSETr f fEMPTY A A) ∧
            ∀e s A0 A1.
              fITSETr f s A0 A1 ∧ ¬fIN e s ⇒
              fITSETr f (fINSERT e s) A0 (f e A1)
   
   [<a name="fITSETr_strongind-val"><b>fITSETr_strongind</b></a>]  Theorem
      
      ⊢ ∀f fITSETr'.
          (∀A. fITSETr' fEMPTY A A) ∧
          (∀e s A0 A1.
             fITSETr f s A0 A1 ∧ fITSETr' s A0 A1 ∧ ¬fIN e s ⇒
             fITSETr' (fINSERT e s) A0 (f e A1)) ⇒
          ∀a0 a1 a2. fITSETr f a0 a1 a2 ⇒ fITSETr' a0 a1 a2
   
   [<a name="fITSETr_total-val"><b>fITSETr_total</b></a>]  Theorem
      
      ⊢ ∀s f a0. ∃a. fITSETr f s a0 a
   
   [<a name="fMAX_SET_SUBSET-val"><b>fMAX_SET_SUBSET</b></a>]  Theorem
      
      ⊢ ∀A B. (∀e. fIN e A ⇒ fIN e B) ⇒ fMAX_SET A ≤ fMAX_SET B
   
   [<a name="fMAX_SET_THM-val"><b>fMAX_SET_THM</b></a>]  Theorem
      
      ⊢ fMAX_SET fEMPTY = 0 ∧ fMAX_SET (fINSERT e A) = MAX e (fMAX_SET A)
   
   [<a name="fMAX_SET_fIN-val"><b>fMAX_SET_fIN</b></a>]  Theorem
      
      ⊢ A ≠ fEMPTY ⇒ fIN (fMAX_SET A) A
   
   [<a name="fSUM_IMAGE_SUBSET-val"><b>fSUM_IMAGE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀A B. (∀a. fIN a A ⇒ fIN a B) ⇒ fSUM_IMAGE f A ≤ fSUM_IMAGE f B
   
   [<a name="fSUM_IMAGE_THM-val"><b>fSUM_IMAGE_THM</b></a>]  Theorem
      
      ⊢ fSUM_IMAGE f fEMPTY = 0 ∧
        fSUM_IMAGE f (fINSERT e A) = f e + fSUM_IMAGE f (fDELETE e A)
   
   [<a name="fSUM_IMAGE_UNION-val"><b>fSUM_IMAGE_UNION</b></a>]  Theorem
      
      ⊢ ∀A B.
          fSUM_IMAGE f (fUNION A B) =
          fSUM_IMAGE f A + fSUM_IMAGE f B − fSUM_IMAGE f (fINTER A B)
   
   [<a name="fUNION_ASSOC-val"><b>fUNION_ASSOC</b></a>]  Theorem
      
      ⊢ ∀s1 s2 s3. fUNION s1 (fUNION s2 s3) = fUNION (fUNION s1 s2) s3
   
   [<a name="fUNION_COMM-val"><b>fUNION_COMM</b></a>]  Theorem
      
      ⊢ ∀s1 s2. fUNION s1 s2 = fUNION s2 s1
   
   [<a name="fUNION_EMPTY-val"><b>fUNION_EMPTY</b></a>]  Theorem
      
      ⊢ ∀s. fUNION fEMPTY s = s ∧ fUNION s fEMPTY = s
   
   [<a name="fUNION_EQ_EMPTY-val"><b>fUNION_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ ∀s1 s2. fUNION s1 s2 = fEMPTY ⇔ s1 = fEMPTY ∧ s2 = fEMPTY
   
   [<a name="fUNION_IDEMPOT-val"><b>fUNION_IDEMPOT</b></a>]  Theorem
      
      ⊢ ∀s. fUNION s s = s
   
   [<a name="fUNION_INSERT-val"><b>fUNION_INSERT</b></a>]  Theorem
      
      ⊢ fUNION (fINSERT a A) B = fINSERT a (fUNION A B)
   
   [<a name="fUNION_relates-val"><b>fUNION_relates</b></a>]  Theorem
      
      ⊢ FUN_REL FSET0 (FUN_REL FSET0 FSET0) $++ fUNION
   
   [<a name="fUNION_sfSETREL-val"><b>fUNION_sfSETREL</b></a>]  Theorem
      
      ⊢ FUN_REL (sfSETREL AB) (FUN_REL (sfSETREL AB) (sfSETREL AB)) $UNION
          fUNION
   
   [<a name="fromSet_EMPTY-val"><b>fromSet_EMPTY</b></a>]  Theorem
      
      ⊢ fromSet ∅ = fEMPTY
   
   [<a name="fromSet_INSERT-val"><b>fromSet_INSERT</b></a>]  Theorem
      
      ⊢ FINITE s ⇒ fromSet (e INSERT s) = fINSERT e (fromSet s)
   
   [<a name="fromSet_set-val"><b>fromSet_set</b></a>]  Theorem
      
      ⊢ ∀l. fromSet (set l) = fset_ABS l
   
   [<a name="fromSet_toSet-val"><b>fromSet_toSet</b></a>]  Theorem
      
      ⊢ fromSet (toSet s) = s
   
   [<a name="fsequiv_equiv-val"><b>fsequiv_equiv</b></a>]  Theorem
      
      ⊢ EQUIV fsequiv
   
   [<a name="fsequiv_refl-val"><b>fsequiv_refl</b></a>]  Theorem
      
      ⊢ fsequiv l l
   
   [<a name="fset0Q-val"><b>fset0Q</b></a>]  Theorem
      
      ⊢ Qt fsequiv fset_ABS fset_REP FSET0
   
   [<a name="fset_ABS_11-val"><b>fset_ABS_11</b></a>]  Theorem
      
      ⊢ fset_ABS l1 = fset_ABS l2 ⇔ fsequiv l1 l2
   
   [<a name="fset_ABS_MAP-val"><b>fset_ABS_MAP</b></a>]  Theorem
      
      ⊢ fset_ABS (MAP f l) = fIMAGE f (fset_ABS l)
   
   [<a name="fset_ABS_REP-val"><b>fset_ABS_REP</b></a>]  Theorem
      
      ⊢ fset_ABS (fset_REP s) = s
   
   [<a name="fset_ABS_REP_CLASS-val"><b>fset_ABS_REP_CLASS</b></a>]  Theorem
      
      ⊢ (∀a. fset_ABS_CLASS (fset_REP_CLASS a) = a) ∧
        ∀c. (∃r. fsequiv r r ∧ c = fsequiv r) ⇔
            fset_REP_CLASS (fset_ABS_CLASS c) = c
   
   [<a name="fset_ABS_onto-val"><b>fset_ABS_onto</b></a>]  Theorem
      
      ⊢ ∀fs. ∃l. fset_ABS l = fs
   
   [<a name="fset_QUOTIENT-val"><b>fset_QUOTIENT</b></a>]  Theorem
      
      ⊢ QUOTIENT fsequiv fset_ABS fset_REP
   
   [<a name="fset_REP_11-val"><b>fset_REP_11</b></a>]  Theorem
      
      ⊢ fset_REP fs1 = fset_REP fs2 ⇔ fs1 = fs2
   
   [<a name="fset_REP_fEMPTY-val"><b>fset_REP_fEMPTY</b></a>]  Theorem
      
      ⊢ fset_REP fEMPTY = []
   
   [<a name="fset_cases-val"><b>fset_cases</b></a>]  Theorem
      
      ⊢ ∀s. s = fEMPTY ∨ ∃e s0. s = fINSERT e s0 ∧ ¬fIN e s0
   
   [<a name="fset_induction-val"><b>fset_induction</b></a>]  Theorem
      
      ⊢ ∀P. P fEMPTY ∧ (∀e s. P s ∧ ¬fIN e s ⇒ P (fINSERT e s)) ⇒ ∀s. P s
   
   [<a name="left_unique_rel_set-val"><b>left_unique_rel_set</b></a>]  Theorem
      
      ⊢ left_unique AB ⇒ left_unique (rel_set AB)
   
   [<a name="rel_setEQ-val"><b>rel_setEQ</b></a>]  Theorem
      
      ⊢ rel_set $= = $=
   
   [<a name="rel_set_RSUBSET-val"><b>rel_set_RSUBSET</b></a>]  Theorem
      
      ⊢ bi_unique AB ⇒ rel_set AB ⊆ᵣ FUN_REL AB $&lt;=&gt;
   
   [<a name="rel_set_empty-val"><b>rel_set_empty</b></a>]  Theorem
      
      ⊢ rel_set AB ∅ ∅
   
   [<a name="right_unique_FSET0-val"><b>right_unique_FSET0</b></a>]  Theorem
      
      ⊢ right_unique FSET0
   
   [<a name="right_unique_rel_set-val"><b>right_unique_rel_set</b></a>]  Theorem
      
      ⊢ right_unique AB ⇒ right_unique (rel_set AB)
   
   [<a name="set_BIGUNION-val"><b>set_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀fss. toSet (fBIGUNION fss) = BIGUNION (toSet (fIMAGE toSet fss))
   
   [<a name="set_IMAGE-val"><b>set_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f fs. toSet (fIMAGE f fs) = IMAGE f (toSet fs)
   
   [<a name="surj_FSET0-val"><b>surj_FSET0</b></a>]  Theorem
      
      ⊢ surj FSET0
   
   [<a name="surjfns-val"><b>surjfns</b></a>]  Theorem
      
      ⊢ surj AB ∧ right_unique AB ∧ surj CD ⇒ surj (FUN_REL AB CD)
   
   [<a name="toSet_11-val"><b>toSet_11</b></a>]  Theorem
      
      ⊢ ∀fs1 fs2. toSet fs1 = toSet fs2 ⇔ fs1 = fs2
   
   [<a name="toSet_Qt-val"><b>toSet_Qt</b></a>]  Theorem
      
      ⊢ Qt (λx y. FINITE x ∧ x = y) fromSet toSet (λs fs. s = toSet fs)
   
   [<a name="toSet_fEMPTY-val"><b>toSet_fEMPTY</b></a>]  Theorem
      
      ⊢ toSet fEMPTY = ∅
   
   [<a name="toSet_fIMAGE-val"><b>toSet_fIMAGE</b></a>]  Theorem
      
      ⊢ toSet (fIMAGE f s) = IMAGE f (toSet s)
   
   [<a name="toSet_fINSERT-val"><b>toSet_fINSERT</b></a>]  Theorem
      
      ⊢ toSet (fINSERT x s) = x INSERT toSet s
   
   [<a name="toSet_fUNION-val"><b>toSet_fUNION</b></a>]  Theorem
      
      ⊢ toSet (fUNION s1 s2) = toSet s1 ∪ toSet s2
   
   [<a name="toSet_fromSet-val"><b>toSet_fromSet</b></a>]  Theorem
      
      ⊢ FINITE s ⇒ toSet (fromSet s) = s
   
   [<a name="toSet_fset_ABS-val"><b>toSet_fset_ABS</b></a>]  Theorem
      
      ⊢ ∀l. toSet (fset_ABS l) = set l
   
   [<a name="toSet_rel_set_relates-val"><b>toSet_rel_set_relates</b></a>]  Theorem
      
      ⊢ FUN_REL (FSET AB) (rel_set AB) set toSet
   
   [<a name="toSet_relates-val"><b>toSet_relates</b></a>]  Theorem
      
      ⊢ bi_unique AB ⇒ FUN_REL (FSET AB) (FUN_REL AB $&lt;=&gt;) set toSet
   
   [<a name="total_FSET-val"><b>total_FSET</b></a>]  Theorem
      
      ⊢ total AB ⇒ total (FSET AB)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/pred_set/src/more_theories/.hol/objs/finite_setScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-2</a></em></p></body></html>
