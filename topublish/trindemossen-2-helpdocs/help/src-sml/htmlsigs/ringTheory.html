<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure ringTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure ringTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/algebra/construction/.hol/objs/ringScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature ringTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#EuclideanRing_def-val">EuclideanRing_def</a> : thm
<a name="line7"></a>    val <a href="#FiniteIntegralDomain_def-val">FiniteIntegralDomain_def</a> : thm
<a name="line8"></a>    val <a href="#FiniteRing_def-val">FiniteRing_def</a> : thm
<a name="line9"></a>    val <a href="#IntegralDomain_def-val">IntegralDomain_def</a> : thm
<a name="line10"></a>    val <a href="#PrincipalIdealRing_def-val">PrincipalIdealRing_def</a> : thm
<a name="line11"></a>    val <a href="#RingAuto_def-val">RingAuto_def</a> : thm
<a name="line12"></a>    val <a href="#RingEndo_def-val">RingEndo_def</a> : thm
<a name="line13"></a>    val <a href="#RingHomo_def-val">RingHomo_def</a> : thm
<a name="line14"></a>    val <a href="#RingIso_def-val">RingIso_def</a> : thm
<a name="line15"></a>    val <a href="#Ring_def-val">Ring_def</a> : thm
<a name="line16"></a>    val <a href="#ZN_def-val">ZN_def</a> : thm
<a name="line17"></a>    val <a href="#ZP_def-val">ZP_def</a> : thm
<a name="line18"></a>    val <a href="#Z_add_def-val">Z_add_def</a> : thm
<a name="line19"></a>    val <a href="#Z_def-val">Z_def</a> : thm
<a name="line20"></a>    val <a href="#Z_ideal_def-val">Z_ideal_def</a> : thm
<a name="line21"></a>    val <a href="#Z_mult_def-val">Z_mult_def</a> : thm
<a name="line22"></a>    val <a href="#Z_multiple_def-val">Z_multiple_def</a> : thm
<a name="line23"></a>    val <a href="#char_def-val">char_def</a> : thm
<a name="line24"></a>    val <a href="#compute_ordz_def-val">compute_ordz_def</a> : thm
<a name="line25"></a>    val <a href="#homo_ideal_def-val">homo_ideal_def</a> : thm
<a name="line26"></a>    val <a href="#homo_ring_def-val">homo_ring_def</a> : thm
<a name="line27"></a>    val <a href="#ideal_congruence_def-val">ideal_congruence_def</a> : thm
<a name="line28"></a>    val <a href="#ideal_coset_add_def-val">ideal_coset_add_def</a> : thm
<a name="line29"></a>    val <a href="#ideal_coset_mult_def-val">ideal_coset_mult_def</a> : thm
<a name="line30"></a>    val <a href="#ideal_def-val">ideal_def</a> : thm
<a name="line31"></a>    val <a href="#ideal_gen_def-val">ideal_gen_def</a> : thm
<a name="line32"></a>    val <a href="#ideal_maximal_def-val">ideal_maximal_def</a> : thm
<a name="line33"></a>    val <a href="#ideal_sum_def-val">ideal_sum_def</a> : thm
<a name="line34"></a>    val <a href="#irreducible_def-val">irreducible_def</a> : thm
<a name="line35"></a>    val <a href="#kernel_ideal_def-val">kernel_ideal_def</a> : thm
<a name="line36"></a>    val <a href="#monoid_of_ring_nonzero_mult_def-val">monoid_of_ring_nonzero_mult_def</a> : thm
<a name="line37"></a>    val <a href="#principal_ideal_def-val">principal_ideal_def</a> : thm
<a name="line38"></a>    val <a href="#quotient_ring_add_def-val">quotient_ring_add_def</a> : thm
<a name="line39"></a>    val <a href="#quotient_ring_def-val">quotient_ring_def</a> : thm
<a name="line40"></a>    val <a href="#quotient_ring_mult_def-val">quotient_ring_mult_def</a> : thm
<a name="line41"></a>    val <a href="#recordtype_ring_seldef_carrier_def-val">recordtype_ring_seldef_carrier_def</a> : thm
<a name="line42"></a>    val <a href="#recordtype_ring_seldef_carrier_fupd_def-val">recordtype_ring_seldef_carrier_fupd_def</a> : thm
<a name="line43"></a>    val <a href="#recordtype_ring_seldef_prod_def-val">recordtype_ring_seldef_prod_def</a> : thm
<a name="line44"></a>    val <a href="#recordtype_ring_seldef_prod_fupd_def-val">recordtype_ring_seldef_prod_fupd_def</a> : thm
<a name="line45"></a>    val <a href="#recordtype_ring_seldef_sum_def-val">recordtype_ring_seldef_sum_def</a> : thm
<a name="line46"></a>    val <a href="#recordtype_ring_seldef_sum_fupd_def-val">recordtype_ring_seldef_sum_fupd_def</a> : thm
<a name="line47"></a>    val <a href="#ring_TY_DEF-val">ring_TY_DEF</a> : thm
<a name="line48"></a>    val <a href="#ring_associates_def-val">ring_associates_def</a> : thm
<a name="line49"></a>    val <a href="#ring_case_def-val">ring_case_def</a> : thm
<a name="line50"></a>    val <a href="#ring_divides_def-val">ring_divides_def</a> : thm
<a name="line51"></a>    val <a href="#ring_fun_def-val">ring_fun_def</a> : thm
<a name="line52"></a>    val <a href="#ring_gcd_def-val">ring_gcd_def</a> : thm
<a name="line53"></a>    val <a href="#ring_homo_image_def-val">ring_homo_image_def</a> : thm
<a name="line54"></a>    val <a href="#ring_inj_image_def-val">ring_inj_image_def</a> : thm
<a name="line55"></a>    val <a href="#ring_list_def-val">ring_list_def</a> : thm
<a name="line56"></a>    val <a href="#ring_nonzero_def-val">ring_nonzero_def</a> : thm
<a name="line57"></a>    val <a href="#ring_ordering_def-val">ring_ordering_def</a> : thm
<a name="line58"></a>    val <a href="#ring_prime_def-val">ring_prime_def</a> : thm
<a name="line59"></a>    val <a href="#ring_size_def-val">ring_size_def</a> : thm
<a name="line60"></a>    val <a href="#ring_sub_def-val">ring_sub_def</a> : thm
<a name="line61"></a>    val <a href="#ring_sum_def-val">ring_sum_def</a> : thm
<a name="line62"></a>    val <a href="#subring_def-val">subring_def</a> : thm
<a name="line63"></a>    val <a href="#symdiff_set_inter_def-val">symdiff_set_inter_def</a> : thm
<a name="line64"></a>    val <a href="#trivial_integal_domain_def-val">trivial_integal_domain_def</a> : thm
<a name="line65"></a>    val <a href="#trivial_ring_def-val">trivial_ring_def</a> : thm
<a name="line66"></a>    val <a href="#unit_eq_def-val">unit_eq_def</a> : thm
<a name="line67"></a>  
<a name="line68"></a>  (*  Theorems  *)
<a name="line69"></a>    val <a href="#EXISTS_ring-val">EXISTS_ring</a> : thm
<a name="line70"></a>    val <a href="#FORALL_ring-val">FORALL_ring</a> : thm
<a name="line71"></a>    val <a href="#LIST_REL_ring_associates_product-val">LIST_REL_ring_associates_product</a> : thm
<a name="line72"></a>    val <a href="#WHILE_RULE_PRE_POST-val">WHILE_RULE_PRE_POST</a> : thm
<a name="line73"></a>    val <a href="#ZN_1_exp-val">ZN_1_exp</a> : thm
<a name="line74"></a>    val <a href="#ZN_card-val">ZN_card</a> : thm
<a name="line75"></a>    val <a href="#ZN_char-val">ZN_char</a> : thm
<a name="line76"></a>    val <a href="#ZN_coprime_euler_element-val">ZN_coprime_euler_element</a> : thm
<a name="line77"></a>    val <a href="#ZN_coprime_exp_mod-val">ZN_coprime_exp_mod</a> : thm
<a name="line78"></a>    val <a href="#ZN_coprime_invertible-val">ZN_coprime_invertible</a> : thm
<a name="line79"></a>    val <a href="#ZN_coprime_order-val">ZN_coprime_order</a> : thm
<a name="line80"></a>    val <a href="#ZN_coprime_order_alt-val">ZN_coprime_order_alt</a> : thm
<a name="line81"></a>    val <a href="#ZN_coprime_order_divides_phi-val">ZN_coprime_order_divides_phi</a> : thm
<a name="line82"></a>    val <a href="#ZN_coprime_order_divides_totient-val">ZN_coprime_order_divides_totient</a> : thm
<a name="line83"></a>    val <a href="#ZN_coprime_order_gt_1-val">ZN_coprime_order_gt_1</a> : thm
<a name="line84"></a>    val <a href="#ZN_coprime_order_lt-val">ZN_coprime_order_lt</a> : thm
<a name="line85"></a>    val <a href="#ZN_eval-val">ZN_eval</a> : thm
<a name="line86"></a>    val <a href="#ZN_exp-val">ZN_exp</a> : thm
<a name="line87"></a>    val <a href="#ZN_finite-val">ZN_finite</a> : thm
<a name="line88"></a>    val <a href="#ZN_finite_ring-val">ZN_finite_ring</a> : thm
<a name="line89"></a>    val <a href="#ZN_ids-val">ZN_ids</a> : thm
<a name="line90"></a>    val <a href="#ZN_ids_alt-val">ZN_ids_alt</a> : thm
<a name="line91"></a>    val <a href="#ZN_invertibles-val">ZN_invertibles</a> : thm
<a name="line92"></a>    val <a href="#ZN_invertibles_finite_group-val">ZN_invertibles_finite_group</a> : thm
<a name="line93"></a>    val <a href="#ZN_invertibles_group-val">ZN_invertibles_group</a> : thm
<a name="line94"></a>    val <a href="#ZN_invertibles_order-val">ZN_invertibles_order</a> : thm
<a name="line95"></a>    val <a href="#ZN_mult_inv_coprime-val">ZN_mult_inv_coprime</a> : thm
<a name="line96"></a>    val <a href="#ZN_mult_inv_coprime_iff-val">ZN_mult_inv_coprime_iff</a> : thm
<a name="line97"></a>    val <a href="#ZN_not_coprime-val">ZN_not_coprime</a> : thm
<a name="line98"></a>    val <a href="#ZN_num-val">ZN_num</a> : thm
<a name="line99"></a>    val <a href="#ZN_num_0-val">ZN_num_0</a> : thm
<a name="line100"></a>    val <a href="#ZN_num_1-val">ZN_num_1</a> : thm
<a name="line101"></a>    val <a href="#ZN_num_mod-val">ZN_num_mod</a> : thm
<a name="line102"></a>    val <a href="#ZN_order_0-val">ZN_order_0</a> : thm
<a name="line103"></a>    val <a href="#ZN_order_1-val">ZN_order_1</a> : thm
<a name="line104"></a>    val <a href="#ZN_order_divides_exp-val">ZN_order_divides_exp</a> : thm
<a name="line105"></a>    val <a href="#ZN_order_divides_phi-val">ZN_order_divides_phi</a> : thm
<a name="line106"></a>    val <a href="#ZN_order_divides_tops_index-val">ZN_order_divides_tops_index</a> : thm
<a name="line107"></a>    val <a href="#ZN_order_divisibility-val">ZN_order_divisibility</a> : thm
<a name="line108"></a>    val <a href="#ZN_order_eq_0-val">ZN_order_eq_0</a> : thm
<a name="line109"></a>    val <a href="#ZN_order_eq_0_iff-val">ZN_order_eq_0_iff</a> : thm
<a name="line110"></a>    val <a href="#ZN_order_eq_0_test-val">ZN_order_eq_0_test</a> : thm
<a name="line111"></a>    val <a href="#ZN_order_eq_1-val">ZN_order_eq_1</a> : thm
<a name="line112"></a>    val <a href="#ZN_order_eq_1_alt-val">ZN_order_eq_1_alt</a> : thm
<a name="line113"></a>    val <a href="#ZN_order_eq_1_by_prime_factors-val">ZN_order_eq_1_by_prime_factors</a> : thm
<a name="line114"></a>    val <a href="#ZN_order_gt_1_property-val">ZN_order_gt_1_property</a> : thm
<a name="line115"></a>    val <a href="#ZN_order_le-val">ZN_order_le</a> : thm
<a name="line116"></a>    val <a href="#ZN_order_le_tops_index-val">ZN_order_le_tops_index</a> : thm
<a name="line117"></a>    val <a href="#ZN_order_lt-val">ZN_order_lt</a> : thm
<a name="line118"></a>    val <a href="#ZN_order_minimal-val">ZN_order_minimal</a> : thm
<a name="line119"></a>    val <a href="#ZN_order_mod-val">ZN_order_mod</a> : thm
<a name="line120"></a>    val <a href="#ZN_order_mod_1-val">ZN_order_mod_1</a> : thm
<a name="line121"></a>    val <a href="#ZN_order_nonzero-val">ZN_order_nonzero</a> : thm
<a name="line122"></a>    val <a href="#ZN_order_nonzero_iff-val">ZN_order_nonzero_iff</a> : thm
<a name="line123"></a>    val <a href="#ZN_order_property-val">ZN_order_property</a> : thm
<a name="line124"></a>    val <a href="#ZN_order_property_alt-val">ZN_order_property_alt</a> : thm
<a name="line125"></a>    val <a href="#ZN_order_test_1-val">ZN_order_test_1</a> : thm
<a name="line126"></a>    val <a href="#ZN_order_test_2-val">ZN_order_test_2</a> : thm
<a name="line127"></a>    val <a href="#ZN_order_test_3-val">ZN_order_test_3</a> : thm
<a name="line128"></a>    val <a href="#ZN_order_test_4-val">ZN_order_test_4</a> : thm
<a name="line129"></a>    val <a href="#ZN_order_test_propery-val">ZN_order_test_propery</a> : thm
<a name="line130"></a>    val <a href="#ZN_order_upper-val">ZN_order_upper</a> : thm
<a name="line131"></a>    val <a href="#ZN_order_with_coprime_1-val">ZN_order_with_coprime_1</a> : thm
<a name="line132"></a>    val <a href="#ZN_order_with_coprime_2-val">ZN_order_with_coprime_2</a> : thm
<a name="line133"></a>    val <a href="#ZN_property-val">ZN_property</a> : thm
<a name="line134"></a>    val <a href="#ZN_ring-val">ZN_ring</a> : thm
<a name="line135"></a>    val <a href="#ZN_to_ZN_element-val">ZN_to_ZN_element</a> : thm
<a name="line136"></a>    val <a href="#ZN_to_ZN_prod_monoid_homo-val">ZN_to_ZN_prod_monoid_homo</a> : thm
<a name="line137"></a>    val <a href="#ZN_to_ZN_ring_homo-val">ZN_to_ZN_ring_homo</a> : thm
<a name="line138"></a>    val <a href="#ZN_to_ZN_sum_group_homo-val">ZN_to_ZN_sum_group_homo</a> : thm
<a name="line139"></a>    val <a href="#ZP_finite-val">ZP_finite</a> : thm
<a name="line140"></a>    val <a href="#ZP_finite_integral_domain-val">ZP_finite_integral_domain</a> : thm
<a name="line141"></a>    val <a href="#ZP_integral_domain-val">ZP_integral_domain</a> : thm
<a name="line142"></a>    val <a href="#Z_add_abelian_group-val">Z_add_abelian_group</a> : thm
<a name="line143"></a>    val <a href="#Z_add_group-val">Z_add_group</a> : thm
<a name="line144"></a>    val <a href="#Z_add_inv-val">Z_add_inv</a> : thm
<a name="line145"></a>    val <a href="#Z_euclid_ring-val">Z_euclid_ring</a> : thm
<a name="line146"></a>    val <a href="#Z_ideal_map_bij-val">Z_ideal_map_bij</a> : thm
<a name="line147"></a>    val <a href="#Z_ideal_map_element-val">Z_ideal_map_element</a> : thm
<a name="line148"></a>    val <a href="#Z_ideal_map_group_homo-val">Z_ideal_map_group_homo</a> : thm
<a name="line149"></a>    val <a href="#Z_ideal_map_monoid_homo-val">Z_ideal_map_monoid_homo</a> : thm
<a name="line150"></a>    val <a href="#Z_ideal_sum_group-val">Z_ideal_sum_group</a> : thm
<a name="line151"></a>    val <a href="#Z_ideal_sum_normal-val">Z_ideal_sum_normal</a> : thm
<a name="line152"></a>    val <a href="#Z_ideal_sum_subgroup-val">Z_ideal_sum_subgroup</a> : thm
<a name="line153"></a>    val <a href="#Z_ideal_thm-val">Z_ideal_thm</a> : thm
<a name="line154"></a>    val <a href="#Z_mult_abelian_monoid-val">Z_mult_abelian_monoid</a> : thm
<a name="line155"></a>    val <a href="#Z_mult_monoid-val">Z_mult_monoid</a> : thm
<a name="line156"></a>    val <a href="#Z_multiple_less_neg_eq-val">Z_multiple_less_neg_eq</a> : thm
<a name="line157"></a>    val <a href="#Z_principal_ideal_ring-val">Z_principal_ideal_ring</a> : thm
<a name="line158"></a>    val <a href="#Z_quotient_iso_ZN-val">Z_quotient_iso_ZN</a> : thm
<a name="line159"></a>    val <a href="#Z_ring-val">Z_ring</a> : thm
<a name="line160"></a>    val <a href="#Z_sum_cogen-val">Z_sum_cogen</a> : thm
<a name="line161"></a>    val <a href="#Z_sum_coset_eq-val">Z_sum_coset_eq</a> : thm
<a name="line162"></a>    val <a href="#char_eq_0-val">char_eq_0</a> : thm
<a name="line163"></a>    val <a href="#char_minimal-val">char_minimal</a> : thm
<a name="line164"></a>    val <a href="#char_property-val">char_property</a> : thm
<a name="line165"></a>    val <a href="#compute_ordz_0-val">compute_ordz_0</a> : thm
<a name="line166"></a>    val <a href="#compute_ordz_1-val">compute_ordz_1</a> : thm
<a name="line167"></a>    val <a href="#compute_ordz_eqn-val">compute_ordz_eqn</a> : thm
<a name="line168"></a>    val <a href="#compute_ordz_hoare-val">compute_ordz_hoare</a> : thm
<a name="line169"></a>    val <a href="#datatype_ring-val">datatype_ring</a> : thm
<a name="line170"></a>    val <a href="#euclid_ring_map-val">euclid_ring_map</a> : thm
<a name="line171"></a>    val <a href="#euclid_ring_principal_ideal_ring-val">euclid_ring_principal_ideal_ring</a> : thm
<a name="line172"></a>    val <a href="#euclid_ring_property-val">euclid_ring_property</a> : thm
<a name="line173"></a>    val <a href="#euclid_ring_ring-val">euclid_ring_ring</a> : thm
<a name="line174"></a>    val <a href="#finite_integral_domain_nonzero_group-val">finite_integral_domain_nonzero_group</a> : thm
<a name="line175"></a>    val <a href="#finite_integral_domain_nonzero_invertible-val">finite_integral_domain_nonzero_invertible</a> : thm
<a name="line176"></a>    val <a href="#finite_integral_domain_nonzero_invertible_alt-val">finite_integral_domain_nonzero_invertible_alt</a> : thm
<a name="line177"></a>    val <a href="#finite_integral_domain_period_exists-val">finite_integral_domain_period_exists</a> : thm
<a name="line178"></a>    val <a href="#finite_ring_add_finite_abelian_group-val">finite_ring_add_finite_abelian_group</a> : thm
<a name="line179"></a>    val <a href="#finite_ring_add_finite_group-val">finite_ring_add_finite_group</a> : thm
<a name="line180"></a>    val <a href="#finite_ring_card_eq_1-val">finite_ring_card_eq_1</a> : thm
<a name="line181"></a>    val <a href="#finite_ring_card_pos-val">finite_ring_card_pos</a> : thm
<a name="line182"></a>    val <a href="#finite_ring_card_prime-val">finite_ring_card_prime</a> : thm
<a name="line183"></a>    val <a href="#finite_ring_char-val">finite_ring_char</a> : thm
<a name="line184"></a>    val <a href="#finite_ring_char_alt-val">finite_ring_char_alt</a> : thm
<a name="line185"></a>    val <a href="#finite_ring_char_divides-val">finite_ring_char_divides</a> : thm
<a name="line186"></a>    val <a href="#finite_ring_char_pos-val">finite_ring_char_pos</a> : thm
<a name="line187"></a>    val <a href="#finite_ring_is_ring-val">finite_ring_is_ring</a> : thm
<a name="line188"></a>    val <a href="#finite_ring_mult_finite_abelian_monoid-val">finite_ring_mult_finite_abelian_monoid</a> : thm
<a name="line189"></a>    val <a href="#finite_ring_mult_finite_monoid-val">finite_ring_mult_finite_monoid</a> : thm
<a name="line190"></a>    val <a href="#homo_ring_by_inj-val">homo_ring_by_inj</a> : thm
<a name="line191"></a>    val <a href="#homo_ring_property-val">homo_ring_property</a> : thm
<a name="line192"></a>    val <a href="#homo_ring_ring-val">homo_ring_ring</a> : thm
<a name="line193"></a>    val <a href="#homo_ring_subring-val">homo_ring_subring</a> : thm
<a name="line194"></a>    val <a href="#ideal_antisym-val">ideal_antisym</a> : thm
<a name="line195"></a>    val <a href="#ideal_carrier_sing-val">ideal_carrier_sing</a> : thm
<a name="line196"></a>    val <a href="#ideal_carriers-val">ideal_carriers</a> : thm
<a name="line197"></a>    val <a href="#ideal_cogen_property-val">ideal_cogen_property</a> : thm
<a name="line198"></a>    val <a href="#ideal_congruence_elements-val">ideal_congruence_elements</a> : thm
<a name="line199"></a>    val <a href="#ideal_congruence_equiv-val">ideal_congruence_equiv</a> : thm
<a name="line200"></a>    val <a href="#ideal_congruence_iff_inCoset-val">ideal_congruence_iff_inCoset</a> : thm
<a name="line201"></a>    val <a href="#ideal_congruence_mult-val">ideal_congruence_mult</a> : thm
<a name="line202"></a>    val <a href="#ideal_congruence_refl-val">ideal_congruence_refl</a> : thm
<a name="line203"></a>    val <a href="#ideal_congruence_sym-val">ideal_congruence_sym</a> : thm
<a name="line204"></a>    val <a href="#ideal_congruence_trans-val">ideal_congruence_trans</a> : thm
<a name="line205"></a>    val <a href="#ideal_coset_add-val">ideal_coset_add</a> : thm
<a name="line206"></a>    val <a href="#ideal_coset_element-val">ideal_coset_element</a> : thm
<a name="line207"></a>    val <a href="#ideal_coset_eq-val">ideal_coset_eq</a> : thm
<a name="line208"></a>    val <a href="#ideal_coset_eq_carrier-val">ideal_coset_eq_carrier</a> : thm
<a name="line209"></a>    val <a href="#ideal_coset_eq_congruence-val">ideal_coset_eq_congruence</a> : thm
<a name="line210"></a>    val <a href="#ideal_coset_has_gen_diff-val">ideal_coset_has_gen_diff</a> : thm
<a name="line211"></a>    val <a href="#ideal_coset_mult-val">ideal_coset_mult</a> : thm
<a name="line212"></a>    val <a href="#ideal_coset_neg-val">ideal_coset_neg</a> : thm
<a name="line213"></a>    val <a href="#ideal_coset_of_element-val">ideal_coset_of_element</a> : thm
<a name="line214"></a>    val <a href="#ideal_coset_property-val">ideal_coset_property</a> : thm
<a name="line215"></a>    val <a href="#ideal_coset_zero-val">ideal_coset_zero</a> : thm
<a name="line216"></a>    val <a href="#ideal_element-val">ideal_element</a> : thm
<a name="line217"></a>    val <a href="#ideal_element_property-val">ideal_element_property</a> : thm
<a name="line218"></a>    val <a href="#ideal_eq_ideal-val">ideal_eq_ideal</a> : thm
<a name="line219"></a>    val <a href="#ideal_gen_exists-val">ideal_gen_exists</a> : thm
<a name="line220"></a>    val <a href="#ideal_gen_minimal-val">ideal_gen_minimal</a> : thm
<a name="line221"></a>    val <a href="#ideal_has_diff-val">ideal_has_diff</a> : thm
<a name="line222"></a>    val <a href="#ideal_has_multiple-val">ideal_has_multiple</a> : thm
<a name="line223"></a>    val <a href="#ideal_has_neg-val">ideal_has_neg</a> : thm
<a name="line224"></a>    val <a href="#ideal_has_one-val">ideal_has_one</a> : thm
<a name="line225"></a>    val <a href="#ideal_has_principal_ideal-val">ideal_has_principal_ideal</a> : thm
<a name="line226"></a>    val <a href="#ideal_has_product-val">ideal_has_product</a> : thm
<a name="line227"></a>    val <a href="#ideal_has_subgroup-val">ideal_has_subgroup</a> : thm
<a name="line228"></a>    val <a href="#ideal_has_sum-val">ideal_has_sum</a> : thm
<a name="line229"></a>    val <a href="#ideal_has_zero-val">ideal_has_zero</a> : thm
<a name="line230"></a>    val <a href="#ideal_in_quotient_ring-val">ideal_in_quotient_ring</a> : thm
<a name="line231"></a>    val <a href="#ideal_ops-val">ideal_ops</a> : thm
<a name="line232"></a>    val <a href="#ideal_product_property-val">ideal_product_property</a> : thm
<a name="line233"></a>    val <a href="#ideal_property-val">ideal_property</a> : thm
<a name="line234"></a>    val <a href="#ideal_refl-val">ideal_refl</a> : thm
<a name="line235"></a>    val <a href="#ideal_sub_ideal-val">ideal_sub_ideal</a> : thm
<a name="line236"></a>    val <a href="#ideal_sub_itself-val">ideal_sub_itself</a> : thm
<a name="line237"></a>    val <a href="#ideal_subgroup_ideal_sum-val">ideal_subgroup_ideal_sum</a> : thm
<a name="line238"></a>    val <a href="#ideal_sum_comm-val">ideal_sum_comm</a> : thm
<a name="line239"></a>    val <a href="#ideal_sum_element-val">ideal_sum_element</a> : thm
<a name="line240"></a>    val <a href="#ideal_sum_group-val">ideal_sum_group</a> : thm
<a name="line241"></a>    val <a href="#ideal_sum_has_ideal-val">ideal_sum_has_ideal</a> : thm
<a name="line242"></a>    val <a href="#ideal_sum_has_ideal_comm-val">ideal_sum_has_ideal_comm</a> : thm
<a name="line243"></a>    val <a href="#ideal_sum_ideal-val">ideal_sum_ideal</a> : thm
<a name="line244"></a>    val <a href="#ideal_sum_sub_ideal-val">ideal_sum_sub_ideal</a> : thm
<a name="line245"></a>    val <a href="#ideal_sum_subgroup-val">ideal_sum_subgroup</a> : thm
<a name="line246"></a>    val <a href="#ideal_with_one-val">ideal_with_one</a> : thm
<a name="line247"></a>    val <a href="#ideal_with_unit-val">ideal_with_unit</a> : thm
<a name="line248"></a>    val <a href="#ideal_zero-val">ideal_zero</a> : thm
<a name="line249"></a>    val <a href="#integral_domain_char-val">integral_domain_char</a> : thm
<a name="line250"></a>    val <a href="#integral_domain_divides_prime-val">integral_domain_divides_prime</a> : thm
<a name="line251"></a>    val <a href="#integral_domain_exp_eq-val">integral_domain_exp_eq</a> : thm
<a name="line252"></a>    val <a href="#integral_domain_exp_eq_zero-val">integral_domain_exp_eq_zero</a> : thm
<a name="line253"></a>    val <a href="#integral_domain_exp_nonzero-val">integral_domain_exp_nonzero</a> : thm
<a name="line254"></a>    val <a href="#integral_domain_is_ring-val">integral_domain_is_ring</a> : thm
<a name="line255"></a>    val <a href="#integral_domain_mult_eq_zero-val">integral_domain_mult_eq_zero</a> : thm
<a name="line256"></a>    val <a href="#integral_domain_mult_lcancel-val">integral_domain_mult_lcancel</a> : thm
<a name="line257"></a>    val <a href="#integral_domain_mult_nonzero-val">integral_domain_mult_nonzero</a> : thm
<a name="line258"></a>    val <a href="#integral_domain_mult_rcancel-val">integral_domain_mult_rcancel</a> : thm
<a name="line259"></a>    val <a href="#integral_domain_nonzero_monoid-val">integral_domain_nonzero_monoid</a> : thm
<a name="line260"></a>    val <a href="#integral_domain_nonzero_mult_carrier-val">integral_domain_nonzero_mult_carrier</a> : thm
<a name="line261"></a>    val <a href="#integral_domain_nonzero_mult_is_monoid-val">integral_domain_nonzero_mult_is_monoid</a> : thm
<a name="line262"></a>    val <a href="#integral_domain_nonzero_mult_property-val">integral_domain_nonzero_mult_property</a> : thm
<a name="line263"></a>    val <a href="#integral_domain_nonzero_order-val">integral_domain_nonzero_order</a> : thm
<a name="line264"></a>    val <a href="#integral_domain_one_ne_zero-val">integral_domain_one_ne_zero</a> : thm
<a name="line265"></a>    val <a href="#integral_domain_one_nonzero-val">integral_domain_one_nonzero</a> : thm
<a name="line266"></a>    val <a href="#integral_domain_order_eq_0-val">integral_domain_order_eq_0</a> : thm
<a name="line267"></a>    val <a href="#integral_domain_order_nonzero-val">integral_domain_order_nonzero</a> : thm
<a name="line268"></a>    val <a href="#integral_domain_order_zero-val">integral_domain_order_zero</a> : thm
<a name="line269"></a>    val <a href="#integral_domain_prime_factors_unique-val">integral_domain_prime_factors_unique</a> : thm
<a name="line270"></a>    val <a href="#integral_domain_ring_iso-val">integral_domain_ring_iso</a> : thm
<a name="line271"></a>    val <a href="#integral_domain_zero_not_unit-val">integral_domain_zero_not_unit</a> : thm
<a name="line272"></a>    val <a href="#integral_domain_zero_product-val">integral_domain_zero_product</a> : thm
<a name="line273"></a>    val <a href="#irreducible_associates-val">irreducible_associates</a> : thm
<a name="line274"></a>    val <a href="#irreducible_element-val">irreducible_element</a> : thm
<a name="line275"></a>    val <a href="#irreducible_factors-val">irreducible_factors</a> : thm
<a name="line276"></a>    val <a href="#kernel_ideal_element-val">kernel_ideal_element</a> : thm
<a name="line277"></a>    val <a href="#kernel_ideal_gen_add_map-val">kernel_ideal_gen_add_map</a> : thm
<a name="line278"></a>    val <a href="#kernel_ideal_gen_id_map-val">kernel_ideal_gen_id_map</a> : thm
<a name="line279"></a>    val <a href="#kernel_ideal_gen_mult_map-val">kernel_ideal_gen_mult_map</a> : thm
<a name="line280"></a>    val <a href="#kernel_ideal_quotient_bij-val">kernel_ideal_quotient_bij</a> : thm
<a name="line281"></a>    val <a href="#kernel_ideal_quotient_element_eq-val">kernel_ideal_quotient_element_eq</a> : thm
<a name="line282"></a>    val <a href="#kernel_ideal_quotient_homo-val">kernel_ideal_quotient_homo</a> : thm
<a name="line283"></a>    val <a href="#kernel_ideal_quotient_inj-val">kernel_ideal_quotient_inj</a> : thm
<a name="line284"></a>    val <a href="#kernel_ideal_quotient_iso-val">kernel_ideal_quotient_iso</a> : thm
<a name="line285"></a>    val <a href="#kernel_ideal_quotient_surj-val">kernel_ideal_quotient_surj</a> : thm
<a name="line286"></a>    val <a href="#kernel_ideal_sum_eqn-val">kernel_ideal_sum_eqn</a> : thm
<a name="line287"></a>    val <a href="#ordz_eval-val">ordz_eval</a> : thm
<a name="line288"></a>    val <a href="#prime_is_irreducible-val">prime_is_irreducible</a> : thm
<a name="line289"></a>    val <a href="#principal_ideal_element-val">principal_ideal_element</a> : thm
<a name="line290"></a>    val <a href="#principal_ideal_element_divides-val">principal_ideal_element_divides</a> : thm
<a name="line291"></a>    val <a href="#principal_ideal_eq_principal_ideal-val">principal_ideal_eq_principal_ideal</a> : thm
<a name="line292"></a>    val <a href="#principal_ideal_equal_principal_ideal-val">principal_ideal_equal_principal_ideal</a> : thm
<a name="line293"></a>    val <a href="#principal_ideal_group-val">principal_ideal_group</a> : thm
<a name="line294"></a>    val <a href="#principal_ideal_has_element-val">principal_ideal_has_element</a> : thm
<a name="line295"></a>    val <a href="#principal_ideal_has_principal_ideal-val">principal_ideal_has_principal_ideal</a> : thm
<a name="line296"></a>    val <a href="#principal_ideal_ideal-val">principal_ideal_ideal</a> : thm
<a name="line297"></a>    val <a href="#principal_ideal_property-val">principal_ideal_property</a> : thm
<a name="line298"></a>    val <a href="#principal_ideal_ring_atom_is_prime-val">principal_ideal_ring_atom_is_prime</a> : thm
<a name="line299"></a>    val <a href="#principal_ideal_ring_ideal_maximal-val">principal_ideal_ring_ideal_maximal</a> : thm
<a name="line300"></a>    val <a href="#principal_ideal_ring_irreducible_is_prime-val">principal_ideal_ring_irreducible_is_prime</a> : thm
<a name="line301"></a>    val <a href="#principal_ideal_sub_implies_divides-val">principal_ideal_sub_implies_divides</a> : thm
<a name="line302"></a>    val <a href="#principal_ideal_subgroup-val">principal_ideal_subgroup</a> : thm
<a name="line303"></a>    val <a href="#principal_ideal_subgroup_normal-val">principal_ideal_subgroup_normal</a> : thm
<a name="line304"></a>    val <a href="#principal_ideal_sum_eq_ideal-val">principal_ideal_sum_eq_ideal</a> : thm
<a name="line305"></a>    val <a href="#principal_ideal_sum_equal_ideal-val">principal_ideal_sum_equal_ideal</a> : thm
<a name="line306"></a>    val <a href="#quotient_ring_add_abelian_group-val">quotient_ring_add_abelian_group</a> : thm
<a name="line307"></a>    val <a href="#quotient_ring_add_assoc-val">quotient_ring_add_assoc</a> : thm
<a name="line308"></a>    val <a href="#quotient_ring_add_comm-val">quotient_ring_add_comm</a> : thm
<a name="line309"></a>    val <a href="#quotient_ring_add_element-val">quotient_ring_add_element</a> : thm
<a name="line310"></a>    val <a href="#quotient_ring_add_group-val">quotient_ring_add_group</a> : thm
<a name="line311"></a>    val <a href="#quotient_ring_add_id-val">quotient_ring_add_id</a> : thm
<a name="line312"></a>    val <a href="#quotient_ring_add_inv-val">quotient_ring_add_inv</a> : thm
<a name="line313"></a>    val <a href="#quotient_ring_by_principal_ideal-val">quotient_ring_by_principal_ideal</a> : thm
<a name="line314"></a>    val <a href="#quotient_ring_element-val">quotient_ring_element</a> : thm
<a name="line315"></a>    val <a href="#quotient_ring_has_ideal-val">quotient_ring_has_ideal</a> : thm
<a name="line316"></a>    val <a href="#quotient_ring_homo-val">quotient_ring_homo</a> : thm
<a name="line317"></a>    val <a href="#quotient_ring_homo_kernel-val">quotient_ring_homo_kernel</a> : thm
<a name="line318"></a>    val <a href="#quotient_ring_homo_kernel_ideal-val">quotient_ring_homo_kernel_ideal</a> : thm
<a name="line319"></a>    val <a href="#quotient_ring_homo_surj-val">quotient_ring_homo_surj</a> : thm
<a name="line320"></a>    val <a href="#quotient_ring_mult_abelian_monoid-val">quotient_ring_mult_abelian_monoid</a> : thm
<a name="line321"></a>    val <a href="#quotient_ring_mult_assoc-val">quotient_ring_mult_assoc</a> : thm
<a name="line322"></a>    val <a href="#quotient_ring_mult_comm-val">quotient_ring_mult_comm</a> : thm
<a name="line323"></a>    val <a href="#quotient_ring_mult_element-val">quotient_ring_mult_element</a> : thm
<a name="line324"></a>    val <a href="#quotient_ring_mult_id-val">quotient_ring_mult_id</a> : thm
<a name="line325"></a>    val <a href="#quotient_ring_mult_ladd-val">quotient_ring_mult_ladd</a> : thm
<a name="line326"></a>    val <a href="#quotient_ring_mult_monoid-val">quotient_ring_mult_monoid</a> : thm
<a name="line327"></a>    val <a href="#quotient_ring_property-val">quotient_ring_property</a> : thm
<a name="line328"></a>    val <a href="#quotient_ring_ring-val">quotient_ring_ring</a> : thm
<a name="line329"></a>    val <a href="#quotient_ring_ring_sing-val">quotient_ring_ring_sing</a> : thm
<a name="line330"></a>    val <a href="#ring_11-val">ring_11</a> : thm
<a name="line331"></a>    val <a href="#ring_Axiom-val">ring_Axiom</a> : thm
<a name="line332"></a>    val <a href="#ring_accessors-val">ring_accessors</a> : thm
<a name="line333"></a>    val <a href="#ring_accfupds-val">ring_accfupds</a> : thm
<a name="line334"></a>    val <a href="#ring_add_abelian_group-val">ring_add_abelian_group</a> : thm
<a name="line335"></a>    val <a href="#ring_add_assoc-val">ring_add_assoc</a> : thm
<a name="line336"></a>    val <a href="#ring_add_assoc_comm-val">ring_add_assoc_comm</a> : thm
<a name="line337"></a>    val <a href="#ring_add_char_2-val">ring_add_char_2</a> : thm
<a name="line338"></a>    val <a href="#ring_add_comm-val">ring_add_comm</a> : thm
<a name="line339"></a>    val <a href="#ring_add_element-val">ring_add_element</a> : thm
<a name="line340"></a>    val <a href="#ring_add_eq_zero-val">ring_add_eq_zero</a> : thm
<a name="line341"></a>    val <a href="#ring_add_exp_eqn-val">ring_add_exp_eqn</a> : thm
<a name="line342"></a>    val <a href="#ring_add_group-val">ring_add_group</a> : thm
<a name="line343"></a>    val <a href="#ring_add_group_rwt-val">ring_add_group_rwt</a> : thm
<a name="line344"></a>    val <a href="#ring_add_lcancel-val">ring_add_lcancel</a> : thm
<a name="line345"></a>    val <a href="#ring_add_lneg-val">ring_add_lneg</a> : thm
<a name="line346"></a>    val <a href="#ring_add_lneg_assoc-val">ring_add_lneg_assoc</a> : thm
<a name="line347"></a>    val <a href="#ring_add_lzero-val">ring_add_lzero</a> : thm
<a name="line348"></a>    val <a href="#ring_add_pair_sub-val">ring_add_pair_sub</a> : thm
<a name="line349"></a>    val <a href="#ring_add_rcancel-val">ring_add_rcancel</a> : thm
<a name="line350"></a>    val <a href="#ring_add_rneg-val">ring_add_rneg</a> : thm
<a name="line351"></a>    val <a href="#ring_add_rneg_assoc-val">ring_add_rneg_assoc</a> : thm
<a name="line352"></a>    val <a href="#ring_add_rzero-val">ring_add_rzero</a> : thm
<a name="line353"></a>    val <a href="#ring_add_sub-val">ring_add_sub</a> : thm
<a name="line354"></a>    val <a href="#ring_add_sub_assoc-val">ring_add_sub_assoc</a> : thm
<a name="line355"></a>    val <a href="#ring_add_sub_comm-val">ring_add_sub_comm</a> : thm
<a name="line356"></a>    val <a href="#ring_add_sub_identity-val">ring_add_sub_identity</a> : thm
<a name="line357"></a>    val <a href="#ring_add_zero_zero-val">ring_add_zero_zero</a> : thm
<a name="line358"></a>    val <a href="#ring_associates_divides-val">ring_associates_divides</a> : thm
<a name="line359"></a>    val <a href="#ring_associates_mult-val">ring_associates_mult</a> : thm
<a name="line360"></a>    val <a href="#ring_associates_refl-val">ring_associates_refl</a> : thm
<a name="line361"></a>    val <a href="#ring_associates_sym-val">ring_associates_sym</a> : thm
<a name="line362"></a>    val <a href="#ring_associates_trans-val">ring_associates_trans</a> : thm
<a name="line363"></a>    val <a href="#ring_auto_I-val">ring_auto_I</a> : thm
<a name="line364"></a>    val <a href="#ring_auto_bij-val">ring_auto_bij</a> : thm
<a name="line365"></a>    val <a href="#ring_auto_cong-val">ring_auto_cong</a> : thm
<a name="line366"></a>    val <a href="#ring_auto_element-val">ring_auto_element</a> : thm
<a name="line367"></a>    val <a href="#ring_auto_ids-val">ring_auto_ids</a> : thm
<a name="line368"></a>    val <a href="#ring_auto_linv_auto-val">ring_auto_linv_auto</a> : thm
<a name="line369"></a>    val <a href="#ring_auto_one-val">ring_auto_one</a> : thm
<a name="line370"></a>    val <a href="#ring_auto_zero-val">ring_auto_zero</a> : thm
<a name="line371"></a>    val <a href="#ring_binomial_2-val">ring_binomial_2</a> : thm
<a name="line372"></a>    val <a href="#ring_binomial_3-val">ring_binomial_3</a> : thm
<a name="line373"></a>    val <a href="#ring_binomial_4-val">ring_binomial_4</a> : thm
<a name="line374"></a>    val <a href="#ring_binomial_genlist_index_shift-val">ring_binomial_genlist_index_shift</a> : thm
<a name="line375"></a>    val <a href="#ring_binomial_index_shift-val">ring_binomial_index_shift</a> : thm
<a name="line376"></a>    val <a href="#ring_binomial_term_merge_x-val">ring_binomial_term_merge_x</a> : thm
<a name="line377"></a>    val <a href="#ring_binomial_term_merge_y-val">ring_binomial_term_merge_y</a> : thm
<a name="line378"></a>    val <a href="#ring_binomial_thm-val">ring_binomial_thm</a> : thm
<a name="line379"></a>    val <a href="#ring_carrier_nonempty-val">ring_carrier_nonempty</a> : thm
<a name="line380"></a>    val <a href="#ring_carriers-val">ring_carriers</a> : thm
<a name="line381"></a>    val <a href="#ring_case_cong-val">ring_case_cong</a> : thm
<a name="line382"></a>    val <a href="#ring_case_eq-val">ring_case_eq</a> : thm
<a name="line383"></a>    val <a href="#ring_char_0-val">ring_char_0</a> : thm
<a name="line384"></a>    val <a href="#ring_char_1-val">ring_char_1</a> : thm
<a name="line385"></a>    val <a href="#ring_char_2_double-val">ring_char_2_double</a> : thm
<a name="line386"></a>    val <a href="#ring_char_2_neg_one-val">ring_char_2_neg_one</a> : thm
<a name="line387"></a>    val <a href="#ring_char_2_property-val">ring_char_2_property</a> : thm
<a name="line388"></a>    val <a href="#ring_char_alt-val">ring_char_alt</a> : thm
<a name="line389"></a>    val <a href="#ring_char_divides-val">ring_char_divides</a> : thm
<a name="line390"></a>    val <a href="#ring_char_eq_1-val">ring_char_eq_1</a> : thm
<a name="line391"></a>    val <a href="#ring_char_prime-val">ring_char_prime</a> : thm
<a name="line392"></a>    val <a href="#ring_char_prime_endo-val">ring_char_prime_endo</a> : thm
<a name="line393"></a>    val <a href="#ring_component_equality-val">ring_component_equality</a> : thm
<a name="line394"></a>    val <a href="#ring_divides_associates-val">ring_divides_associates</a> : thm
<a name="line395"></a>    val <a href="#ring_divides_by_one-val">ring_divides_by_one</a> : thm
<a name="line396"></a>    val <a href="#ring_divides_by_unit-val">ring_divides_by_unit</a> : thm
<a name="line397"></a>    val <a href="#ring_divides_iso-val">ring_divides_iso</a> : thm
<a name="line398"></a>    val <a href="#ring_divides_le-val">ring_divides_le</a> : thm
<a name="line399"></a>    val <a href="#ring_divides_refl-val">ring_divides_refl</a> : thm
<a name="line400"></a>    val <a href="#ring_divides_trans-val">ring_divides_trans</a> : thm
<a name="line401"></a>    val <a href="#ring_divides_zero-val">ring_divides_zero</a> : thm
<a name="line402"></a>    val <a href="#ring_eq_unit_eq-val">ring_eq_unit_eq</a> : thm
<a name="line403"></a>    val <a href="#ring_exp_0-val">ring_exp_0</a> : thm
<a name="line404"></a>    val <a href="#ring_exp_1-val">ring_exp_1</a> : thm
<a name="line405"></a>    val <a href="#ring_exp_SUC-val">ring_exp_SUC</a> : thm
<a name="line406"></a>    val <a href="#ring_exp_add-val">ring_exp_add</a> : thm
<a name="line407"></a>    val <a href="#ring_exp_add_assoc-val">ring_exp_add_assoc</a> : thm
<a name="line408"></a>    val <a href="#ring_exp_comm-val">ring_exp_comm</a> : thm
<a name="line409"></a>    val <a href="#ring_exp_element-val">ring_exp_element</a> : thm
<a name="line410"></a>    val <a href="#ring_exp_mod_order-val">ring_exp_mod_order</a> : thm
<a name="line411"></a>    val <a href="#ring_exp_mult-val">ring_exp_mult</a> : thm
<a name="line412"></a>    val <a href="#ring_exp_mult_comm-val">ring_exp_mult_comm</a> : thm
<a name="line413"></a>    val <a href="#ring_exp_neg-val">ring_exp_neg</a> : thm
<a name="line414"></a>    val <a href="#ring_exp_small-val">ring_exp_small</a> : thm
<a name="line415"></a>    val <a href="#ring_exp_suc-val">ring_exp_suc</a> : thm
<a name="line416"></a>    val <a href="#ring_factor_multiple-val">ring_factor_multiple</a> : thm
<a name="line417"></a>    val <a href="#ring_fermat_all-val">ring_fermat_all</a> : thm
<a name="line418"></a>    val <a href="#ring_fermat_thm-val">ring_fermat_thm</a> : thm
<a name="line419"></a>    val <a href="#ring_first_isomorphism_thm-val">ring_first_isomorphism_thm</a> : thm
<a name="line420"></a>    val <a href="#ring_fn_updates-val">ring_fn_updates</a> : thm
<a name="line421"></a>    val <a href="#ring_freshman_all-val">ring_freshman_all</a> : thm
<a name="line422"></a>    val <a href="#ring_freshman_all_sub-val">ring_freshman_all_sub</a> : thm
<a name="line423"></a>    val <a href="#ring_freshman_thm-val">ring_freshman_thm</a> : thm
<a name="line424"></a>    val <a href="#ring_freshman_thm_sub-val">ring_freshman_thm_sub</a> : thm
<a name="line425"></a>    val <a href="#ring_fun_add-val">ring_fun_add</a> : thm
<a name="line426"></a>    val <a href="#ring_fun_from_ring_fun-val">ring_fun_from_ring_fun</a> : thm
<a name="line427"></a>    val <a href="#ring_fun_from_ring_fun_exp-val">ring_fun_from_ring_fun_exp</a> : thm
<a name="line428"></a>    val <a href="#ring_fun_genlist-val">ring_fun_genlist</a> : thm
<a name="line429"></a>    val <a href="#ring_fun_map-val">ring_fun_map</a> : thm
<a name="line430"></a>    val <a href="#ring_fupdcanon-val">ring_fupdcanon</a> : thm
<a name="line431"></a>    val <a href="#ring_fupdcanon_comp-val">ring_fupdcanon_comp</a> : thm
<a name="line432"></a>    val <a href="#ring_fupdfupds-val">ring_fupdfupds</a> : thm
<a name="line433"></a>    val <a href="#ring_fupdfupds_comp-val">ring_fupdfupds_comp</a> : thm
<a name="line434"></a>    val <a href="#ring_gcd_divides-val">ring_gcd_divides</a> : thm
<a name="line435"></a>    val <a href="#ring_gcd_element-val">ring_gcd_element</a> : thm
<a name="line436"></a>    val <a href="#ring_gcd_is_gcd-val">ring_gcd_is_gcd</a> : thm
<a name="line437"></a>    val <a href="#ring_gcd_linear-val">ring_gcd_linear</a> : thm
<a name="line438"></a>    val <a href="#ring_gcd_property-val">ring_gcd_property</a> : thm
<a name="line439"></a>    val <a href="#ring_gcd_sym-val">ring_gcd_sym</a> : thm
<a name="line440"></a>    val <a href="#ring_gcd_zero-val">ring_gcd_zero</a> : thm
<a name="line441"></a>    val <a href="#ring_homo_I_refl-val">ring_homo_I_refl</a> : thm
<a name="line442"></a>    val <a href="#ring_homo_add-val">ring_homo_add</a> : thm
<a name="line443"></a>    val <a href="#ring_homo_char_divides-val">ring_homo_char_divides</a> : thm
<a name="line444"></a>    val <a href="#ring_homo_compose-val">ring_homo_compose</a> : thm
<a name="line445"></a>    val <a href="#ring_homo_cong-val">ring_homo_cong</a> : thm
<a name="line446"></a>    val <a href="#ring_homo_element-val">ring_homo_element</a> : thm
<a name="line447"></a>    val <a href="#ring_homo_eq_zero-val">ring_homo_eq_zero</a> : thm
<a name="line448"></a>    val <a href="#ring_homo_exp-val">ring_homo_exp</a> : thm
<a name="line449"></a>    val <a href="#ring_homo_ideal_group-val">ring_homo_ideal_group</a> : thm
<a name="line450"></a>    val <a href="#ring_homo_ideal_ideal-val">ring_homo_ideal_ideal</a> : thm
<a name="line451"></a>    val <a href="#ring_homo_ideal_subgroup-val">ring_homo_ideal_subgroup</a> : thm
<a name="line452"></a>    val <a href="#ring_homo_ids-val">ring_homo_ids</a> : thm
<a name="line453"></a>    val <a href="#ring_homo_image_bij-val">ring_homo_image_bij</a> : thm
<a name="line454"></a>    val <a href="#ring_homo_image_carrier-val">ring_homo_image_carrier</a> : thm
<a name="line455"></a>    val <a href="#ring_homo_image_homo-val">ring_homo_image_homo</a> : thm
<a name="line456"></a>    val <a href="#ring_homo_image_is_subring-val">ring_homo_image_is_subring</a> : thm
<a name="line457"></a>    val <a href="#ring_homo_image_iso-val">ring_homo_image_iso</a> : thm
<a name="line458"></a>    val <a href="#ring_homo_image_ring-val">ring_homo_image_ring</a> : thm
<a name="line459"></a>    val <a href="#ring_homo_image_subring-val">ring_homo_image_subring</a> : thm
<a name="line460"></a>    val <a href="#ring_homo_image_subring_subring-val">ring_homo_image_subring_subring</a> : thm
<a name="line461"></a>    val <a href="#ring_homo_image_surj_property-val">ring_homo_image_surj_property</a> : thm
<a name="line462"></a>    val <a href="#ring_homo_inv-val">ring_homo_inv</a> : thm
<a name="line463"></a>    val <a href="#ring_homo_kernel_ideal-val">ring_homo_kernel_ideal</a> : thm
<a name="line464"></a>    val <a href="#ring_homo_linv_homo-val">ring_homo_linv_homo</a> : thm
<a name="line465"></a>    val <a href="#ring_homo_mult-val">ring_homo_mult</a> : thm
<a name="line466"></a>    val <a href="#ring_homo_neg-val">ring_homo_neg</a> : thm
<a name="line467"></a>    val <a href="#ring_homo_num-val">ring_homo_num</a> : thm
<a name="line468"></a>    val <a href="#ring_homo_num_nonzero-val">ring_homo_num_nonzero</a> : thm
<a name="line469"></a>    val <a href="#ring_homo_one-val">ring_homo_one</a> : thm
<a name="line470"></a>    val <a href="#ring_homo_one_eq_zero-val">ring_homo_one_eq_zero</a> : thm
<a name="line471"></a>    val <a href="#ring_homo_property-val">ring_homo_property</a> : thm
<a name="line472"></a>    val <a href="#ring_homo_ring_homo_subring-val">ring_homo_ring_homo_subring</a> : thm
<a name="line473"></a>    val <a href="#ring_homo_sub-val">ring_homo_sub</a> : thm
<a name="line474"></a>    val <a href="#ring_homo_subring_homo-val">ring_homo_subring_homo</a> : thm
<a name="line475"></a>    val <a href="#ring_homo_sum_num_property-val">ring_homo_sum_num_property</a> : thm
<a name="line476"></a>    val <a href="#ring_homo_sym-val">ring_homo_sym</a> : thm
<a name="line477"></a>    val <a href="#ring_homo_sym_any-val">ring_homo_sym_any</a> : thm
<a name="line478"></a>    val <a href="#ring_homo_trans-val">ring_homo_trans</a> : thm
<a name="line479"></a>    val <a href="#ring_homo_unit-val">ring_homo_unit</a> : thm
<a name="line480"></a>    val <a href="#ring_homo_unit_inv-val">ring_homo_unit_inv</a> : thm
<a name="line481"></a>    val <a href="#ring_homo_unit_inv_element-val">ring_homo_unit_inv_element</a> : thm
<a name="line482"></a>    val <a href="#ring_homo_unit_inv_nonzero-val">ring_homo_unit_inv_nonzero</a> : thm
<a name="line483"></a>    val <a href="#ring_homo_unit_nonzero-val">ring_homo_unit_nonzero</a> : thm
<a name="line484"></a>    val <a href="#ring_homo_zero-val">ring_homo_zero</a> : thm
<a name="line485"></a>    val <a href="#ring_induction-val">ring_induction</a> : thm
<a name="line486"></a>    val <a href="#ring_inj_image_alt-val">ring_inj_image_alt</a> : thm
<a name="line487"></a>    val <a href="#ring_inj_image_carrier-val">ring_inj_image_carrier</a> : thm
<a name="line488"></a>    val <a href="#ring_inj_image_prod_abelian_monoid-val">ring_inj_image_prod_abelian_monoid</a> : thm
<a name="line489"></a>    val <a href="#ring_inj_image_prod_monoid-val">ring_inj_image_prod_monoid</a> : thm
<a name="line490"></a>    val <a href="#ring_inj_image_prod_monoid_homo-val">ring_inj_image_prod_monoid_homo</a> : thm
<a name="line491"></a>    val <a href="#ring_inj_image_ring-val">ring_inj_image_ring</a> : thm
<a name="line492"></a>    val <a href="#ring_inj_image_ring_homo-val">ring_inj_image_ring_homo</a> : thm
<a name="line493"></a>    val <a href="#ring_inj_image_sum_abelian_group-val">ring_inj_image_sum_abelian_group</a> : thm
<a name="line494"></a>    val <a href="#ring_inj_image_sum_group-val">ring_inj_image_sum_group</a> : thm
<a name="line495"></a>    val <a href="#ring_inj_image_sum_group_homo-val">ring_inj_image_sum_group_homo</a> : thm
<a name="line496"></a>    val <a href="#ring_inj_image_sum_monoid-val">ring_inj_image_sum_monoid</a> : thm
<a name="line497"></a>    val <a href="#ring_inv_one-val">ring_inv_one</a> : thm
<a name="line498"></a>    val <a href="#ring_irreducible_gcd-val">ring_irreducible_gcd</a> : thm
<a name="line499"></a>    val <a href="#ring_iso_I_refl-val">ring_iso_I_refl</a> : thm
<a name="line500"></a>    val <a href="#ring_iso_add-val">ring_iso_add</a> : thm
<a name="line501"></a>    val <a href="#ring_iso_bij-val">ring_iso_bij</a> : thm
<a name="line502"></a>    val <a href="#ring_iso_card_eq-val">ring_iso_card_eq</a> : thm
<a name="line503"></a>    val <a href="#ring_iso_char_eq-val">ring_iso_char_eq</a> : thm
<a name="line504"></a>    val <a href="#ring_iso_compose-val">ring_iso_compose</a> : thm
<a name="line505"></a>    val <a href="#ring_iso_cong-val">ring_iso_cong</a> : thm
<a name="line506"></a>    val <a href="#ring_iso_element-val">ring_iso_element</a> : thm
<a name="line507"></a>    val <a href="#ring_iso_element_unique-val">ring_iso_element_unique</a> : thm
<a name="line508"></a>    val <a href="#ring_iso_eq_one-val">ring_iso_eq_one</a> : thm
<a name="line509"></a>    val <a href="#ring_iso_eq_zero-val">ring_iso_eq_zero</a> : thm
<a name="line510"></a>    val <a href="#ring_iso_exp-val">ring_iso_exp</a> : thm
<a name="line511"></a>    val <a href="#ring_iso_ids-val">ring_iso_ids</a> : thm
<a name="line512"></a>    val <a href="#ring_iso_inv-val">ring_iso_inv</a> : thm
<a name="line513"></a>    val <a href="#ring_iso_inverse-val">ring_iso_inverse</a> : thm
<a name="line514"></a>    val <a href="#ring_iso_inverse_element-val">ring_iso_inverse_element</a> : thm
<a name="line515"></a>    val <a href="#ring_iso_linv_iso-val">ring_iso_linv_iso</a> : thm
<a name="line516"></a>    val <a href="#ring_iso_mult-val">ring_iso_mult</a> : thm
<a name="line517"></a>    val <a href="#ring_iso_neg-val">ring_iso_neg</a> : thm
<a name="line518"></a>    val <a href="#ring_iso_nonzero-val">ring_iso_nonzero</a> : thm
<a name="line519"></a>    val <a href="#ring_iso_num-val">ring_iso_num</a> : thm
<a name="line520"></a>    val <a href="#ring_iso_one-val">ring_iso_one</a> : thm
<a name="line521"></a>    val <a href="#ring_iso_property-val">ring_iso_property</a> : thm
<a name="line522"></a>    val <a href="#ring_iso_ring_homo_subring-val">ring_iso_ring_homo_subring</a> : thm
<a name="line523"></a>    val <a href="#ring_iso_sub-val">ring_iso_sub</a> : thm
<a name="line524"></a>    val <a href="#ring_iso_subring_iso-val">ring_iso_subring_iso</a> : thm
<a name="line525"></a>    val <a href="#ring_iso_sym-val">ring_iso_sym</a> : thm
<a name="line526"></a>    val <a href="#ring_iso_sym_any-val">ring_iso_sym_any</a> : thm
<a name="line527"></a>    val <a href="#ring_iso_trans-val">ring_iso_trans</a> : thm
<a name="line528"></a>    val <a href="#ring_iso_unit-val">ring_iso_unit</a> : thm
<a name="line529"></a>    val <a href="#ring_iso_zero-val">ring_iso_zero</a> : thm
<a name="line530"></a>    val <a href="#ring_list_SNOC-val">ring_list_SNOC</a> : thm
<a name="line531"></a>    val <a href="#ring_list_cons-val">ring_list_cons</a> : thm
<a name="line532"></a>    val <a href="#ring_list_from_genlist-val">ring_list_from_genlist</a> : thm
<a name="line533"></a>    val <a href="#ring_list_from_genlist_ring_fun-val">ring_list_from_genlist_ring_fun</a> : thm
<a name="line534"></a>    val <a href="#ring_list_front_last-val">ring_list_front_last</a> : thm
<a name="line535"></a>    val <a href="#ring_list_gen_from_ring_fun-val">ring_list_gen_from_ring_fun</a> : thm
<a name="line536"></a>    val <a href="#ring_list_nil-val">ring_list_nil</a> : thm
<a name="line537"></a>    val <a href="#ring_literal_11-val">ring_literal_11</a> : thm
<a name="line538"></a>    val <a href="#ring_literal_nchotomy-val">ring_literal_nchotomy</a> : thm
<a name="line539"></a>    val <a href="#ring_mult_abelian_monoid-val">ring_mult_abelian_monoid</a> : thm
<a name="line540"></a>    val <a href="#ring_mult_add-val">ring_mult_add</a> : thm
<a name="line541"></a>    val <a href="#ring_mult_add_neg-val">ring_mult_add_neg</a> : thm
<a name="line542"></a>    val <a href="#ring_mult_add_neg_assoc-val">ring_mult_add_neg_assoc</a> : thm
<a name="line543"></a>    val <a href="#ring_mult_add_neg_mult-val">ring_mult_add_neg_mult</a> : thm
<a name="line544"></a>    val <a href="#ring_mult_add_neg_mult_assoc-val">ring_mult_add_neg_mult_assoc</a> : thm
<a name="line545"></a>    val <a href="#ring_mult_assoc-val">ring_mult_assoc</a> : thm
<a name="line546"></a>    val <a href="#ring_mult_assoc_comm-val">ring_mult_assoc_comm</a> : thm
<a name="line547"></a>    val <a href="#ring_mult_comm-val">ring_mult_comm</a> : thm
<a name="line548"></a>    val <a href="#ring_mult_divides-val">ring_mult_divides</a> : thm
<a name="line549"></a>    val <a href="#ring_mult_element-val">ring_mult_element</a> : thm
<a name="line550"></a>    val <a href="#ring_mult_exp-val">ring_mult_exp</a> : thm
<a name="line551"></a>    val <a href="#ring_mult_ladd-val">ring_mult_ladd</a> : thm
<a name="line552"></a>    val <a href="#ring_mult_lneg-val">ring_mult_lneg</a> : thm
<a name="line553"></a>    val <a href="#ring_mult_lone-val">ring_mult_lone</a> : thm
<a name="line554"></a>    val <a href="#ring_mult_lsub-val">ring_mult_lsub</a> : thm
<a name="line555"></a>    val <a href="#ring_mult_lzero-val">ring_mult_lzero</a> : thm
<a name="line556"></a>    val <a href="#ring_mult_monoid-val">ring_mult_monoid</a> : thm
<a name="line557"></a>    val <a href="#ring_mult_monoid_rwt-val">ring_mult_monoid_rwt</a> : thm
<a name="line558"></a>    val <a href="#ring_mult_neg_neg-val">ring_mult_neg_neg</a> : thm
<a name="line559"></a>    val <a href="#ring_mult_one_one-val">ring_mult_one_one</a> : thm
<a name="line560"></a>    val <a href="#ring_mult_pair_diff-val">ring_mult_pair_diff</a> : thm
<a name="line561"></a>    val <a href="#ring_mult_pair_sub-val">ring_mult_pair_sub</a> : thm
<a name="line562"></a>    val <a href="#ring_mult_radd-val">ring_mult_radd</a> : thm
<a name="line563"></a>    val <a href="#ring_mult_rneg-val">ring_mult_rneg</a> : thm
<a name="line564"></a>    val <a href="#ring_mult_rone-val">ring_mult_rone</a> : thm
<a name="line565"></a>    val <a href="#ring_mult_rsub-val">ring_mult_rsub</a> : thm
<a name="line566"></a>    val <a href="#ring_mult_rzero-val">ring_mult_rzero</a> : thm
<a name="line567"></a>    val <a href="#ring_mult_zero_zero-val">ring_mult_zero_zero</a> : thm
<a name="line568"></a>    val <a href="#ring_nchotomy-val">ring_nchotomy</a> : thm
<a name="line569"></a>    val <a href="#ring_neg_add-val">ring_neg_add</a> : thm
<a name="line570"></a>    val <a href="#ring_neg_add_comm-val">ring_neg_add_comm</a> : thm
<a name="line571"></a>    val <a href="#ring_neg_add_neg-val">ring_neg_add_neg</a> : thm
<a name="line572"></a>    val <a href="#ring_neg_add_neg_assoc-val">ring_neg_add_neg_assoc</a> : thm
<a name="line573"></a>    val <a href="#ring_neg_add_neg_mult-val">ring_neg_add_neg_mult</a> : thm
<a name="line574"></a>    val <a href="#ring_neg_add_neg_mult_assoc-val">ring_neg_add_neg_mult_assoc</a> : thm
<a name="line575"></a>    val <a href="#ring_neg_char_2-val">ring_neg_char_2</a> : thm
<a name="line576"></a>    val <a href="#ring_neg_element-val">ring_neg_element</a> : thm
<a name="line577"></a>    val <a href="#ring_neg_eq-val">ring_neg_eq</a> : thm
<a name="line578"></a>    val <a href="#ring_neg_eq_swap-val">ring_neg_eq_swap</a> : thm
<a name="line579"></a>    val <a href="#ring_neg_eq_zero-val">ring_neg_eq_zero</a> : thm
<a name="line580"></a>    val <a href="#ring_neg_exp-val">ring_neg_exp</a> : thm
<a name="line581"></a>    val <a href="#ring_neg_mult-val">ring_neg_mult</a> : thm
<a name="line582"></a>    val <a href="#ring_neg_mult_add_neg_mult-val">ring_neg_mult_add_neg_mult</a> : thm
<a name="line583"></a>    val <a href="#ring_neg_mult_add_neg_mult_assoc-val">ring_neg_mult_add_neg_mult_assoc</a> : thm
<a name="line584"></a>    val <a href="#ring_neg_neg-val">ring_neg_neg</a> : thm
<a name="line585"></a>    val <a href="#ring_neg_nonzero-val">ring_neg_nonzero</a> : thm
<a name="line586"></a>    val <a href="#ring_neg_one_eq_one-val">ring_neg_one_eq_one</a> : thm
<a name="line587"></a>    val <a href="#ring_neg_square-val">ring_neg_square</a> : thm
<a name="line588"></a>    val <a href="#ring_neg_sub-val">ring_neg_sub</a> : thm
<a name="line589"></a>    val <a href="#ring_neg_zero-val">ring_neg_zero</a> : thm
<a name="line590"></a>    val <a href="#ring_nonzero_element-val">ring_nonzero_element</a> : thm
<a name="line591"></a>    val <a href="#ring_nonzero_eq-val">ring_nonzero_eq</a> : thm
<a name="line592"></a>    val <a href="#ring_nonzero_mult_carrier-val">ring_nonzero_mult_carrier</a> : thm
<a name="line593"></a>    val <a href="#ring_num_0-val">ring_num_0</a> : thm
<a name="line594"></a>    val <a href="#ring_num_1-val">ring_num_1</a> : thm
<a name="line595"></a>    val <a href="#ring_num_2-val">ring_num_2</a> : thm
<a name="line596"></a>    val <a href="#ring_num_SUC-val">ring_num_SUC</a> : thm
<a name="line597"></a>    val <a href="#ring_num_add-val">ring_num_add</a> : thm
<a name="line598"></a>    val <a href="#ring_num_add_assoc-val">ring_num_add_assoc</a> : thm
<a name="line599"></a>    val <a href="#ring_num_add_mult-val">ring_num_add_mult</a> : thm
<a name="line600"></a>    val <a href="#ring_num_add_mult_assoc-val">ring_num_add_mult_assoc</a> : thm
<a name="line601"></a>    val <a href="#ring_num_all_zero-val">ring_num_all_zero</a> : thm
<a name="line602"></a>    val <a href="#ring_num_char_coprime_nonzero-val">ring_num_char_coprime_nonzero</a> : thm
<a name="line603"></a>    val <a href="#ring_num_element-val">ring_num_element</a> : thm
<a name="line604"></a>    val <a href="#ring_num_eq-val">ring_num_eq</a> : thm
<a name="line605"></a>    val <a href="#ring_num_exp-val">ring_num_exp</a> : thm
<a name="line606"></a>    val <a href="#ring_num_mod-val">ring_num_mod</a> : thm
<a name="line607"></a>    val <a href="#ring_num_mult-val">ring_num_mult</a> : thm
<a name="line608"></a>    val <a href="#ring_num_mult_assoc-val">ring_num_mult_assoc</a> : thm
<a name="line609"></a>    val <a href="#ring_num_mult_element-val">ring_num_mult_element</a> : thm
<a name="line610"></a>    val <a href="#ring_num_mult_exp-val">ring_num_mult_exp</a> : thm
<a name="line611"></a>    val <a href="#ring_num_mult_neg-val">ring_num_mult_neg</a> : thm
<a name="line612"></a>    val <a href="#ring_num_mult_radd-val">ring_num_mult_radd</a> : thm
<a name="line613"></a>    val <a href="#ring_num_mult_small-val">ring_num_mult_small</a> : thm
<a name="line614"></a>    val <a href="#ring_num_mult_suc-val">ring_num_mult_suc</a> : thm
<a name="line615"></a>    val <a href="#ring_num_negative-val">ring_num_negative</a> : thm
<a name="line616"></a>    val <a href="#ring_num_one-val">ring_num_one</a> : thm
<a name="line617"></a>    val <a href="#ring_num_sub-val">ring_num_sub</a> : thm
<a name="line618"></a>    val <a href="#ring_num_suc-val">ring_num_suc</a> : thm
<a name="line619"></a>    val <a href="#ring_one_element-val">ring_one_element</a> : thm
<a name="line620"></a>    val <a href="#ring_one_eq_zero-val">ring_one_eq_zero</a> : thm
<a name="line621"></a>    val <a href="#ring_one_exp-val">ring_one_exp</a> : thm
<a name="line622"></a>    val <a href="#ring_one_unique-val">ring_one_unique</a> : thm
<a name="line623"></a>    val <a href="#ring_prime_divides_product-val">ring_prime_divides_product</a> : thm
<a name="line624"></a>    val <a href="#ring_prime_iso-val">ring_prime_iso</a> : thm
<a name="line625"></a>    val <a href="#ring_product_factors_divide-val">ring_product_factors_divide</a> : thm
<a name="line626"></a>    val <a href="#ring_single_add_mult-val">ring_single_add_mult</a> : thm
<a name="line627"></a>    val <a href="#ring_single_add_mult_assoc-val">ring_single_add_mult_assoc</a> : thm
<a name="line628"></a>    val <a href="#ring_single_add_neg_mult-val">ring_single_add_neg_mult</a> : thm
<a name="line629"></a>    val <a href="#ring_single_add_neg_mult_assoc-val">ring_single_add_neg_mult_assoc</a> : thm
<a name="line630"></a>    val <a href="#ring_single_add_single-val">ring_single_add_single</a> : thm
<a name="line631"></a>    val <a href="#ring_single_add_single_assoc-val">ring_single_add_single_assoc</a> : thm
<a name="line632"></a>    val <a href="#ring_single_mult_exp-val">ring_single_mult_exp</a> : thm
<a name="line633"></a>    val <a href="#ring_single_mult_exp_assoc-val">ring_single_mult_exp_assoc</a> : thm
<a name="line634"></a>    val <a href="#ring_single_mult_single-val">ring_single_mult_single</a> : thm
<a name="line635"></a>    val <a href="#ring_single_mult_single_assoc-val">ring_single_mult_single_assoc</a> : thm
<a name="line636"></a>    val <a href="#ring_sub_add-val">ring_sub_add</a> : thm
<a name="line637"></a>    val <a href="#ring_sub_element-val">ring_sub_element</a> : thm
<a name="line638"></a>    val <a href="#ring_sub_eq-val">ring_sub_eq</a> : thm
<a name="line639"></a>    val <a href="#ring_sub_eq_add-val">ring_sub_eq_add</a> : thm
<a name="line640"></a>    val <a href="#ring_sub_eq_zero-val">ring_sub_eq_zero</a> : thm
<a name="line641"></a>    val <a href="#ring_sub_lcancel-val">ring_sub_lcancel</a> : thm
<a name="line642"></a>    val <a href="#ring_sub_pair_reduce-val">ring_sub_pair_reduce</a> : thm
<a name="line643"></a>    val <a href="#ring_sub_rcancel-val">ring_sub_rcancel</a> : thm
<a name="line644"></a>    val <a href="#ring_sub_zero-val">ring_sub_zero</a> : thm
<a name="line645"></a>    val <a href="#ring_sum_SNOC-val">ring_sum_SNOC</a> : thm
<a name="line646"></a>    val <a href="#ring_sum_append-val">ring_sum_append</a> : thm
<a name="line647"></a>    val <a href="#ring_sum_cons-val">ring_sum_cons</a> : thm
<a name="line648"></a>    val <a href="#ring_sum_decompose_first-val">ring_sum_decompose_first</a> : thm
<a name="line649"></a>    val <a href="#ring_sum_decompose_first_last-val">ring_sum_decompose_first_last</a> : thm
<a name="line650"></a>    val <a href="#ring_sum_decompose_last-val">ring_sum_decompose_last</a> : thm
<a name="line651"></a>    val <a href="#ring_sum_element-val">ring_sum_element</a> : thm
<a name="line652"></a>    val <a href="#ring_sum_freshman_all-val">ring_sum_freshman_all</a> : thm
<a name="line653"></a>    val <a href="#ring_sum_freshman_thm-val">ring_sum_freshman_thm</a> : thm
<a name="line654"></a>    val <a href="#ring_sum_fun_zero-val">ring_sum_fun_zero</a> : thm
<a name="line655"></a>    val <a href="#ring_sum_genlist_add-val">ring_sum_genlist_add</a> : thm
<a name="line656"></a>    val <a href="#ring_sum_genlist_append-val">ring_sum_genlist_append</a> : thm
<a name="line657"></a>    val <a href="#ring_sum_genlist_const-val">ring_sum_genlist_const</a> : thm
<a name="line658"></a>    val <a href="#ring_sum_genlist_sum-val">ring_sum_genlist_sum</a> : thm
<a name="line659"></a>    val <a href="#ring_sum_mult-val">ring_sum_mult</a> : thm
<a name="line660"></a>    val <a href="#ring_sum_mult_ladd-val">ring_sum_mult_ladd</a> : thm
<a name="line661"></a>    val <a href="#ring_sum_nil-val">ring_sum_nil</a> : thm
<a name="line662"></a>    val <a href="#ring_sum_sing-val">ring_sum_sing</a> : thm
<a name="line663"></a>    val <a href="#ring_sum_zero-val">ring_sum_zero</a> : thm
<a name="line664"></a>    val <a href="#ring_unit_element-val">ring_unit_element</a> : thm
<a name="line665"></a>    val <a href="#ring_unit_has_inv-val">ring_unit_has_inv</a> : thm
<a name="line666"></a>    val <a href="#ring_unit_inv_element-val">ring_unit_inv_element</a> : thm
<a name="line667"></a>    val <a href="#ring_unit_inv_inv-val">ring_unit_inv_inv</a> : thm
<a name="line668"></a>    val <a href="#ring_unit_inv_nonzero-val">ring_unit_inv_nonzero</a> : thm
<a name="line669"></a>    val <a href="#ring_unit_linv-val">ring_unit_linv</a> : thm
<a name="line670"></a>    val <a href="#ring_unit_linv_inv-val">ring_unit_linv_inv</a> : thm
<a name="line671"></a>    val <a href="#ring_unit_linv_unique-val">ring_unit_linv_unique</a> : thm
<a name="line672"></a>    val <a href="#ring_unit_mult_eq_unit-val">ring_unit_mult_eq_unit</a> : thm
<a name="line673"></a>    val <a href="#ring_unit_mult_unit-val">ring_unit_mult_unit</a> : thm
<a name="line674"></a>    val <a href="#ring_unit_mult_zero-val">ring_unit_mult_zero</a> : thm
<a name="line675"></a>    val <a href="#ring_unit_neg-val">ring_unit_neg</a> : thm
<a name="line676"></a>    val <a href="#ring_unit_nonzero-val">ring_unit_nonzero</a> : thm
<a name="line677"></a>    val <a href="#ring_unit_one-val">ring_unit_one</a> : thm
<a name="line678"></a>    val <a href="#ring_unit_property-val">ring_unit_property</a> : thm
<a name="line679"></a>    val <a href="#ring_unit_rinv-val">ring_unit_rinv</a> : thm
<a name="line680"></a>    val <a href="#ring_unit_rinv_inv-val">ring_unit_rinv_inv</a> : thm
<a name="line681"></a>    val <a href="#ring_unit_rinv_unique-val">ring_unit_rinv_unique</a> : thm
<a name="line682"></a>    val <a href="#ring_unit_zero-val">ring_unit_zero</a> : thm
<a name="line683"></a>    val <a href="#ring_units_abelain_group-val">ring_units_abelain_group</a> : thm
<a name="line684"></a>    val <a href="#ring_units_element-val">ring_units_element</a> : thm
<a name="line685"></a>    val <a href="#ring_units_group-val">ring_units_group</a> : thm
<a name="line686"></a>    val <a href="#ring_units_has_one-val">ring_units_has_one</a> : thm
<a name="line687"></a>    val <a href="#ring_units_has_zero-val">ring_units_has_zero</a> : thm
<a name="line688"></a>    val <a href="#ring_units_property-val">ring_units_property</a> : thm
<a name="line689"></a>    val <a href="#ring_updates_eq_literal-val">ring_updates_eq_literal</a> : thm
<a name="line690"></a>    val <a href="#ring_zero_divides-val">ring_zero_divides</a> : thm
<a name="line691"></a>    val <a href="#ring_zero_element-val">ring_zero_element</a> : thm
<a name="line692"></a>    val <a href="#ring_zero_exp-val">ring_zero_exp</a> : thm
<a name="line693"></a>    val <a href="#ring_zero_fix-val">ring_zero_fix</a> : thm
<a name="line694"></a>    val <a href="#ring_zero_sub-val">ring_zero_sub</a> : thm
<a name="line695"></a>    val <a href="#ring_zero_unique-val">ring_zero_unique</a> : thm
<a name="line696"></a>    val <a href="#subring_I_antisym-val">subring_I_antisym</a> : thm
<a name="line697"></a>    val <a href="#subring_add-val">subring_add</a> : thm
<a name="line698"></a>    val <a href="#subring_by_subgroup_submonoid-val">subring_by_subgroup_submonoid</a> : thm
<a name="line699"></a>    val <a href="#subring_carrier_antisym-val">subring_carrier_antisym</a> : thm
<a name="line700"></a>    val <a href="#subring_carrier_finite-val">subring_carrier_finite</a> : thm
<a name="line701"></a>    val <a href="#subring_carrier_subset-val">subring_carrier_subset</a> : thm
<a name="line702"></a>    val <a href="#subring_char-val">subring_char</a> : thm
<a name="line703"></a>    val <a href="#subring_char_divides-val">subring_char_divides</a> : thm
<a name="line704"></a>    val <a href="#subring_element-val">subring_element</a> : thm
<a name="line705"></a>    val <a href="#subring_element_alt-val">subring_element_alt</a> : thm
<a name="line706"></a>    val <a href="#subring_exp-val">subring_exp</a> : thm
<a name="line707"></a>    val <a href="#subring_finite_ring-val">subring_finite_ring</a> : thm
<a name="line708"></a>    val <a href="#subring_homo_homo-val">subring_homo_homo</a> : thm
<a name="line709"></a>    val <a href="#subring_ids-val">subring_ids</a> : thm
<a name="line710"></a>    val <a href="#subring_mult-val">subring_mult</a> : thm
<a name="line711"></a>    val <a href="#subring_neg-val">subring_neg</a> : thm
<a name="line712"></a>    val <a href="#subring_num-val">subring_num</a> : thm
<a name="line713"></a>    val <a href="#subring_one-val">subring_one</a> : thm
<a name="line714"></a>    val <a href="#subring_prod_submonoid-val">subring_prod_submonoid</a> : thm
<a name="line715"></a>    val <a href="#subring_property-val">subring_property</a> : thm
<a name="line716"></a>    val <a href="#subring_refl-val">subring_refl</a> : thm
<a name="line717"></a>    val <a href="#subring_ring_iso_compose-val">subring_ring_iso_compose</a> : thm
<a name="line718"></a>    val <a href="#subring_ring_iso_ring_homo_subring-val">subring_ring_iso_ring_homo_subring</a> : thm
<a name="line719"></a>    val <a href="#subring_sub-val">subring_sub</a> : thm
<a name="line720"></a>    val <a href="#subring_sum_subgroup-val">subring_sum_subgroup</a> : thm
<a name="line721"></a>    val <a href="#subring_trans-val">subring_trans</a> : thm
<a name="line722"></a>    val <a href="#subring_unit-val">subring_unit</a> : thm
<a name="line723"></a>    val <a href="#subring_unit_inv-val">subring_unit_inv</a> : thm
<a name="line724"></a>    val <a href="#subring_unit_inv_element-val">subring_unit_inv_element</a> : thm
<a name="line725"></a>    val <a href="#subring_unit_inv_nonzero-val">subring_unit_inv_nonzero</a> : thm
<a name="line726"></a>    val <a href="#subring_unit_nonzero-val">subring_unit_nonzero</a> : thm
<a name="line727"></a>    val <a href="#subring_zero-val">subring_zero</a> : thm
<a name="line728"></a>    val <a href="#symdiff_eval-val">symdiff_eval</a> : thm
<a name="line729"></a>    val <a href="#symdiff_set_inter_char-val">symdiff_set_inter_char</a> : thm
<a name="line730"></a>    val <a href="#symdiff_set_inter_ring-val">symdiff_set_inter_ring</a> : thm
<a name="line731"></a>    val <a href="#symdiff_univ_univ_eq_empty-val">symdiff_univ_univ_eq_empty</a> : thm
<a name="line732"></a>    val <a href="#trivial_char-val">trivial_char</a> : thm
<a name="line733"></a>    val <a href="#trivial_integral_domain-val">trivial_integral_domain</a> : thm
<a name="line734"></a>    val <a href="#trivial_ring-val">trivial_ring</a> : thm
<a name="line735"></a>    val <a href="#trivial_ring_thm-val">trivial_ring_thm</a> : thm
<a name="line736"></a>    val <a href="#unit_eq_refl-val">unit_eq_refl</a> : thm
<a name="line737"></a>    val <a href="#unit_eq_sym-val">unit_eq_sym</a> : thm
<a name="line738"></a>    val <a href="#unit_eq_trans-val">unit_eq_trans</a> : thm
<a name="line739"></a>    val <a href="#zero_ideal_ideal-val">zero_ideal_ideal</a> : thm
<a name="line740"></a>    val <a href="#zero_ideal_sing-val">zero_ideal_sing</a> : thm
<a name="line741"></a>(*
   [Omega] Parent theory of "ring"
   
   [container] Parent theory of "ring"
   
   [group] Parent theory of "ring"
   
   [<a name="EuclideanRing_def-val"><b>EuclideanRing_def</b></a>]  Definition
      
       r f.
          EuclideanRing r f 
          Ring r  (x. f x = 0  x = #0) 
          x y.
            x  R  y  R  y  #0 
            q t. q  R  t  R  x = q * y + t  f t &lt; f y
   
   [<a name="FiniteIntegralDomain_def-val"><b>FiniteIntegralDomain_def</b></a>]  Definition
      
       r. FiniteIntegralDomain r  IntegralDomain r  FINITE R
   
   [<a name="FiniteRing_def-val"><b>FiniteRing_def</b></a>]  Definition
      
       r. FiniteRing r  Ring r  FINITE R
   
   [<a name="IntegralDomain_def-val"><b>IntegralDomain_def</b></a>]  Definition
      
       r. IntegralDomain r 
            Ring r  #1  #0 
            x y. x  R  y  R  (x * y = #0  x = #0  y = #0)
   
   [<a name="PrincipalIdealRing_def-val"><b>PrincipalIdealRing_def</b></a>]  Definition
      
       r. PrincipalIdealRing r 
            Ring r  i. i &lt;&lt; r  p. p  R  &lt;p&gt; = i
   
   [<a name="RingAuto_def-val"><b>RingAuto_def</b></a>]  Definition
      
       f r. RingAuto f r  RingIso f r r
   
   [<a name="RingEndo_def-val"><b>RingEndo_def</b></a>]  Definition
      
       f r. RingEndo f r  RingHomo f r r
   
   [<a name="RingHomo_def-val"><b>RingHomo_def</b></a>]  Definition
      
       f r s.
          RingHomo f r s 
          (x. x  R  f x  s.carrier)  GroupHomo f r.sum s.sum 
          MonoidHomo f r.prod s.prod
   
   [<a name="RingIso_def-val"><b>RingIso_def</b></a>]  Definition
      
       f r s. RingIso f r s  RingHomo f r s  BIJ f R s.carrier
   
   [<a name="Ring_def-val"><b>Ring_def</b></a>]  Definition
      
       r. Ring r 
            AbelianGroup r.sum  AbelianMonoid r.prod  r.sum.carrier = R 
            r.prod.carrier = R 
            x y z. x  R  y  R  z  R  x * (y + z) = x * y + x * z
   
   [<a name="ZN_def-val"><b>ZN_def</b></a>]  Definition
      
       n. ZN n =
            &lt;|carrier := count n; sum := add_mod n; prod := times_mod n|&gt;
   
   [<a name="ZP_def-val"><b>ZP_def</b></a>]  Definition
      
       p. ZP p =
            &lt;|carrier := count p; sum := add_mod p; prod := times_mod p|&gt;
   
   [<a name="Z_add_def-val"><b>Z_add_def</b></a>]  Definition
      
       Z_add = &lt;|carrier := (:int); op := (x y. x + y); id := 0|&gt;
   
   [<a name="Z_def-val"><b>Z_def</b></a>]  Definition
      
       Z = &lt;|carrier := (:int); sum := Z_add; prod := Z_mult|&gt;
   
   [<a name="Z_ideal_def-val"><b>Z_ideal_def</b></a>]  Definition
      
       n. Z* n =
            &lt;|carrier := Z_multiple n;
              sum :=
                &lt;|carrier := Z_multiple n; op := Z.sum.op; id := Z.sum.id|&gt;;
              prod :=
                &lt;|carrier := Z_multiple n; op := Z.prod.op;
                  id := Z.prod.id|&gt; |&gt;
   
   [<a name="Z_mult_def-val"><b>Z_mult_def</b></a>]  Definition
      
       Z_mult = &lt;|carrier := (:int); op := (x y. x * y); id := 1|&gt;
   
   [<a name="Z_multiple_def-val"><b>Z_multiple_def</b></a>]  Definition
      
       n. Z_multiple n = {&n * z | z  (:int)}
   
   [<a name="char_def-val"><b>char_def</b></a>]  Definition
      
       r. char r = order r.sum #1
   
   [<a name="compute_ordz_def-val"><b>compute_ordz_def</b></a>]  Definition
      
       m n.
          compute_ordz m n =
          if m = 0 then ordz 0 n
          else if m = 1 then 1
          else if coprime m n then WHILE (i. n ** i MOD m  1) SUC 1
          else 0
   
   [<a name="homo_ideal_def-val"><b>homo_ideal_def</b></a>]  Definition
      
       f r s i.
          homo_ideal f r s i =
          &lt;|carrier := IMAGE f I;
            sum := &lt;|carrier := IMAGE f I; op := s.sum.op; id := f #0|&gt;;
            prod := &lt;|carrier := IMAGE f I; op := s.prod.op; id := f #1|&gt; |&gt;
   
   [<a name="homo_ring_def-val"><b>homo_ring_def</b></a>]  Definition
      
       r f.
          homo_ring r f =
          &lt;|carrier := IMAGE f R; sum := homo_group r.sum f;
            prod := homo_group r.prod f|&gt;
   
   [<a name="ideal_congruence_def-val"><b>ideal_congruence_def</b></a>]  Definition
      
       r i x y. x === y  x  y  I
   
   [<a name="ideal_coset_add_def-val"><b>ideal_coset_add_def</b></a>]  Definition
      
       r i x y. x + y = (gen x + gen y)  I
   
   [<a name="ideal_coset_mult_def-val"><b>ideal_coset_mult_def</b></a>]  Definition
      
       r i x y. x * y = (gen x * gen y)  I
   
   [<a name="ideal_def-val"><b>ideal_def</b></a>]  Definition
      
       i r.
          i &lt;&lt; r 
          i.sum  r.sum  i.sum.carrier = I  i.prod.carrier = I 
          i.prod.op = $*  i.prod.id = #1 
          x y. x  I  y  R  x * y  I  y * x  I
   
   [<a name="ideal_gen_def-val"><b>ideal_gen_def</b></a>]  Definition
      
       r i f.
          Ring r  i &lt;&lt; r  i  &lt;#0&gt;  (x. f x = 0  x = #0) 
          ideal_gen r i f  I  ideal_gen r i f  #0 
          z. z  I  z  #0  f (ideal_gen r i f)  f z
   
   [<a name="ideal_maximal_def-val"><b>ideal_maximal_def</b></a>]  Definition
      
       r i. maxi i  i &lt;&lt; r  j. i &lt;&lt; j  j &lt;&lt; r  i = j  j = r
   
   [<a name="ideal_sum_def-val"><b>ideal_sum_def</b></a>]  Definition
      
       r i j.
          i + j =
          &lt;|carrier := {x + y | x  I  y  J};
            sum :=
              &lt;|carrier := {x + y | x  I  y  J}; op := $+; id := #0|&gt;;
            prod :=
              &lt;|carrier := {x + y | x  I  y  J}; op := $*; id := #1|&gt; |&gt;
   
   [<a name="irreducible_def-val"><b>irreducible_def</b></a>]  Definition
      
       r z.
          atom z 
          z  R+  z  R* 
          x y. x  R  y  R  z = x * y  unit x  unit y
   
   [<a name="kernel_ideal_def-val"><b>kernel_ideal_def</b></a>]  Definition
      
       f r s.
          kernel_ideal f r s =
          &lt;|carrier := kernel f r.sum s.sum;
            sum := &lt;|carrier := kernel f r.sum s.sum; op := $+; id := #0|&gt;;
            prod := &lt;|carrier := kernel f r.sum s.sum; op := $*; id := #1|&gt; |&gt;
   
   [<a name="monoid_of_ring_nonzero_mult_def-val"><b>monoid_of_ring_nonzero_mult_def</b></a>]  Definition
      
       r. monoid_of_ring_nonzero_mult r =
            &lt;|carrier := R+; op := $*; id := #1|&gt;
   
   [<a name="principal_ideal_def-val"><b>principal_ideal_def</b></a>]  Definition
      
       r p.
          &lt;p&gt; =
          &lt;|carrier := p * R;
            sum := &lt;|carrier := p * R; op := $+; id := #0|&gt;;
            prod := &lt;|carrier := p * R; op := $*; id := #1|&gt; |&gt;
   
   [<a name="quotient_ring_add_def-val"><b>quotient_ring_add_def</b></a>]  Definition
      
       r i.
          quotient_ring_add r i = &lt;|carrier := R/I; id := I; op := $+ |&gt;
   
   [<a name="quotient_ring_def-val"><b>quotient_ring_def</b></a>]  Definition
      
       r i.
          r / i =
          &lt;|carrier := R/I; sum := quotient_ring_add r i;
            prod := quotient_ring_mult r i|&gt;
   
   [<a name="quotient_ring_mult_def-val"><b>quotient_ring_mult_def</b></a>]  Definition
      
       r i.
          quotient_ring_mult r i =
          &lt;|carrier := R/I; id := #1  I; op := $* |&gt;
   
   [<a name="recordtype_ring_seldef_carrier_def-val"><b>recordtype_ring_seldef_carrier_def</b></a>]  Definition
      
       f m m0. (ring f m m0).carrier = f
   
   [<a name="recordtype_ring_seldef_carrier_fupd_def-val"><b>recordtype_ring_seldef_carrier_fupd_def</b></a>]  Definition
      
       f0 f m m0.
          ring f m m0 with carrier updated_by f0 = ring (f0 f) m m0
   
   [<a name="recordtype_ring_seldef_prod_def-val"><b>recordtype_ring_seldef_prod_def</b></a>]  Definition
      
       f m m0. (ring f m m0).prod = m0
   
   [<a name="recordtype_ring_seldef_prod_fupd_def-val"><b>recordtype_ring_seldef_prod_fupd_def</b></a>]  Definition
      
       f0 f m m0. ring f m m0 with prod updated_by f0 = ring f m (f0 m0)
   
   [<a name="recordtype_ring_seldef_sum_def-val"><b>recordtype_ring_seldef_sum_def</b></a>]  Definition
      
       f m m0. (ring f m m0).sum = m
   
   [<a name="recordtype_ring_seldef_sum_fupd_def-val"><b>recordtype_ring_seldef_sum_fupd_def</b></a>]  Definition
      
       f0 f m m0. ring f m m0 with sum updated_by f0 = ring f (f0 m) m0
   
   [<a name="ring_TY_DEF-val"><b>ring_TY_DEF</b></a>]  Definition
      
       rep.
          TYPE_DEFINITION
            (a0'.
                  $var$('ring').
                   (a0'.
                      (a0 a1 a2.
                         a0' =
                         (a0 a1 a2.
                              ind_type$CONSTR 0 (a0,a1,a2)
                                (n. ind_type$BOTTOM)) a0 a1 a2) 
                      $var$('ring') a0') 
                   $var$('ring') a0') rep
   
   [<a name="ring_associates_def-val"><b>ring_associates_def</b></a>]  Definition
      
       r p q. rassoc p q  s. unit s  p = s * q
   
   [<a name="ring_case_def-val"><b>ring_case_def</b></a>]  Definition
      
       a0 a1 a2 f. ring_CASE (ring a0 a1 a2) f = f a0 a1 a2
   
   [<a name="ring_divides_def-val"><b>ring_divides_def</b></a>]  Definition
      
       r q p. q rdivides p  s. s  R  p = s * q
   
   [<a name="ring_fun_def-val"><b>ring_fun_def</b></a>]  Definition
      
       r f. rfun f  x. f x  R
   
   [<a name="ring_gcd_def-val"><b>ring_gcd_def</b></a>]  Definition
      
       r f p q.
          rgcd p q =
          if p = #0 then q
          else if q = #0 then p
          else
            (let
               s =
                 {a * p + b * q |
                  (a,b) |
                  a  R  b  R  0 &lt; f (a * p + b * q)}
             in
               CHOICE (preimage f s (MIN_SET (IMAGE f s))))
   
   [<a name="ring_homo_image_def-val"><b>ring_homo_image_def</b></a>]  Definition
      
       f r r_.
          ring_homo_image f r r_ =
          &lt;|carrier := IMAGE f R; sum := homo_image f r.sum r_.sum;
            prod := homo_image f r.prod r_.prod|&gt;
   
   [<a name="ring_inj_image_def-val"><b>ring_inj_image_def</b></a>]  Definition
      
       r f.
          ring_inj_image r f =
          &lt;|carrier := IMAGE f R;
            sum :=
              &lt;|carrier := IMAGE f R;
                op := (x y. f (LINV f R x + LINV f R y)); id := f #0|&gt;;
            prod :=
              &lt;|carrier := IMAGE f R;
                op := (x y. f (LINV f R x * LINV f R y)); id := f #1|&gt; |&gt;
   
   [<a name="ring_list_def-val"><b>ring_list_def</b></a>]  Definition
      
       (r. rlist []  T)  r h t. rlist (h::t)  h  R  rlist t
   
   [<a name="ring_nonzero_def-val"><b>ring_nonzero_def</b></a>]  Definition
      
       r. R+ = R DIFF {#0}
   
   [<a name="ring_ordering_def-val"><b>ring_ordering_def</b></a>]  Definition
      
       r f.
          ring_ordering r f 
          a b. a  R  b  R  b  #0  f a  f (a * b)
   
   [<a name="ring_prime_def-val"><b>ring_prime_def</b></a>]  Definition
      
       r p.
          rprime p 
          a b.
            a  R  b  R  p rdivides a * b  p rdivides a  p rdivides b
   
   [<a name="ring_size_def-val"><b>ring_size_def</b></a>]  Definition
      
       f a0 a1 a2.
          ring_size f (ring a0 a1 a2) =
          1 + (monoid_size f a1 + monoid_size f a2)
   
   [<a name="ring_sub_def-val"><b>ring_sub_def</b></a>]  Definition
      
       r x y. x  y = x + -y
   
   [<a name="ring_sum_def-val"><b>ring_sum_def</b></a>]  Definition
      
       (r. rsum [] = #0)  r h t. rsum (h::t) = h + rsum t
   
   [<a name="subring_def-val"><b>subring_def</b></a>]  Definition
      
       s r. subring s r  RingHomo I s r
   
   [<a name="symdiff_set_inter_def-val"><b>symdiff_set_inter_def</b></a>]  Definition
      
       symdiff_set_inter =
        &lt;|carrier := (: -&gt; bool); sum := symdiff_set; prod := set_inter|&gt;
   
   [<a name="trivial_integal_domain_def-val"><b>trivial_integal_domain_def</b></a>]  Definition
      
       e0 e1.
          trivial_integal_domain e0 e1 =
          &lt;|carrier := {e0; e1};
            sum :=
              &lt;|carrier := {e0; e1}; id := e0;
                op :=
                  (x y. if x = e0 then y else if y = e0 then x else e0)|&gt;;
            prod :=
              &lt;|carrier := {e0; e1}; id := e1;
                op :=
                  (x y. if x = e0 then e0 else if y = e0 then e0 else e1)|&gt; |&gt;
   
   [<a name="trivial_ring_def-val"><b>trivial_ring_def</b></a>]  Definition
      
       z. trivial_ring z =
            &lt;|carrier := {z};
              sum := &lt;|carrier := {z}; id := z; op := (x y. z)|&gt;;
              prod := &lt;|carrier := {z}; id := z; op := (x y. z)|&gt; |&gt;
   
   [<a name="unit_eq_def-val"><b>unit_eq_def</b></a>]  Definition
      
       r x y. x =~ y  u. unit u  x = u * y
   
   [<a name="EXISTS_ring-val"><b>EXISTS_ring</b></a>]  Theorem
      
       P. (r. P r)  f m0 m. P &lt;|carrier := f; sum := m0; prod := m|&gt;
   
   [<a name="FORALL_ring-val"><b>FORALL_ring</b></a>]  Theorem
      
       P. (r. P r)  f m0 m. P &lt;|carrier := f; sum := m0; prod := m|&gt;
   
   [<a name="LIST_REL_ring_associates_product-val"><b>LIST_REL_ring_associates_product</b></a>]  Theorem
      
       Ring r 
        l1 l2.
          LIST_REL rassoc l1 l2  set l2  R 
          rassoc (GBAG r.prod (LIST_TO_BAG l1))
            (GBAG r.prod (LIST_TO_BAG l2))
   
   [<a name="WHILE_RULE_PRE_POST-val"><b>WHILE_RULE_PRE_POST</b></a>]  Theorem
      
       (x. Invariant x  Guard x  f (Cmd x) &lt; f x) 
        (x. Precond x  Invariant x) 
        (x. Invariant x  Guard x  Postcond x) 
        HOARE_SPEC (x. Invariant x  Guard x) Cmd Invariant 
        HOARE_SPEC Precond (WHILE Guard Cmd) Postcond
   
   [<a name="ZN_1_exp-val"><b>ZN_1_exp</b></a>]  Theorem
      
       n k. (ZN 1).prod.exp n k = 0
   
   [<a name="ZN_card-val"><b>ZN_card</b></a>]  Theorem
      
       n. CARD (ZN n).carrier = n
   
   [<a name="ZN_char-val"><b>ZN_char</b></a>]  Theorem
      
       n. 0 &lt; n  char (ZN n) = n
   
   [<a name="ZN_coprime_euler_element-val"><b>ZN_coprime_euler_element</b></a>]  Theorem
      
       m n. 1 &lt; m  coprime m n  n MOD m  Euler m
   
   [<a name="ZN_coprime_exp_mod-val"><b>ZN_coprime_exp_mod</b></a>]  Theorem
      
       m n.
          0 &lt; m  coprime m n 
          k. n ** k MOD m = n ** (k MOD ordz m n) MOD m
   
   [<a name="ZN_coprime_invertible-val"><b>ZN_coprime_invertible</b></a>]  Theorem
      
       m n. 1 &lt; m  coprime m n  Unit (ZN m) (n MOD m)
   
   [<a name="ZN_coprime_order-val"><b>ZN_coprime_order</b></a>]  Theorem
      
       m n.
          0 &lt; m  coprime m n 
          0 &lt; ordz m n  n ** ordz m n MOD m = 1 MOD m
   
   [<a name="ZN_coprime_order_alt-val"><b>ZN_coprime_order_alt</b></a>]  Theorem
      
       m n. 1 &lt; m  coprime m n  0 &lt; ordz m n  n ** ordz m n MOD m = 1
   
   [<a name="ZN_coprime_order_divides_phi-val"><b>ZN_coprime_order_divides_phi</b></a>]  Theorem
      
       m n. 0 &lt; m  coprime m n  ordz m n divides phi m
   
   [<a name="ZN_coprime_order_divides_totient-val"><b>ZN_coprime_order_divides_totient</b></a>]  Theorem
      
       m n. 0 &lt; m  coprime m n  ordz m n divides totient m
   
   [<a name="ZN_coprime_order_gt_1-val"><b>ZN_coprime_order_gt_1</b></a>]  Theorem
      
       m n. 1 &lt; m  1 &lt; n MOD m  coprime m n  1 &lt; ordz m n
   
   [<a name="ZN_coprime_order_lt-val"><b>ZN_coprime_order_lt</b></a>]  Theorem
      
       m n. 1 &lt; m  coprime m n  ordz m n &lt; m
   
   [<a name="ZN_eval-val"><b>ZN_eval</b></a>]  Theorem
      
       n. (ZN n).carrier = count n  (ZN n).sum = add_mod n 
            (ZN n).prod = times_mod n
   
   [<a name="ZN_exp-val"><b>ZN_exp</b></a>]  Theorem
      
       n. 0 &lt; n  x k. (ZN n).prod.exp x k = x ** k MOD n
   
   [<a name="ZN_finite-val"><b>ZN_finite</b></a>]  Theorem
      
       n. FINITE (ZN n).carrier
   
   [<a name="ZN_finite_ring-val"><b>ZN_finite_ring</b></a>]  Theorem
      
       n. 0 &lt; n  FiniteRing (ZN n)
   
   [<a name="ZN_ids-val"><b>ZN_ids</b></a>]  Theorem
      
       n. 0 &lt; n  (ZN n).sum.id = 0  (ZN n).prod.id = 1 MOD n
   
   [<a name="ZN_ids_alt-val"><b>ZN_ids_alt</b></a>]  Theorem
      
       n. 1 &lt; n  (ZN n).sum.id = 0  (ZN n).prod.id = 1
   
   [<a name="ZN_invertibles-val"><b>ZN_invertibles</b></a>]  Theorem
      
       n. 1 &lt; n  Invertibles (ZN n).prod = Estar n
   
   [<a name="ZN_invertibles_finite_group-val"><b>ZN_invertibles_finite_group</b></a>]  Theorem
      
       n. 0 &lt; n  FiniteGroup (Invertibles (ZN n).prod)
   
   [<a name="ZN_invertibles_group-val"><b>ZN_invertibles_group</b></a>]  Theorem
      
       n. 0 &lt; n  Group (Invertibles (ZN n).prod)
   
   [<a name="ZN_invertibles_order-val"><b>ZN_invertibles_order</b></a>]  Theorem
      
       m n. 0 &lt; m  order (Invertibles (ZN m).prod) (n MOD m) = ordz m n
   
   [<a name="ZN_mult_inv_coprime-val"><b>ZN_mult_inv_coprime</b></a>]  Theorem
      
       n. 0 &lt; n  x y. (x * y) MOD n = 1  coprime x n
   
   [<a name="ZN_mult_inv_coprime_iff-val"><b>ZN_mult_inv_coprime_iff</b></a>]  Theorem
      
       n. 1 &lt; n  x. coprime x n  y. (x * y) MOD n = 1
   
   [<a name="ZN_not_coprime-val"><b>ZN_not_coprime</b></a>]  Theorem
      
       m n. 0 &lt; m  gcd m n  1  k. 0 &lt; k  n ** k MOD m  1
   
   [<a name="ZN_num-val"><b>ZN_num</b></a>]  Theorem
      
       n. 0 &lt; n  k. (ZN n).sum.exp 1 k = k MOD n
   
   [<a name="ZN_num_0-val"><b>ZN_num_0</b></a>]  Theorem
      
       n c. 0 &lt; n  (ZN n).sum.exp 0 c = 0
   
   [<a name="ZN_num_1-val"><b>ZN_num_1</b></a>]  Theorem
      
       n. (ZN n).sum.exp (ZN n).prod.id 1 = 1 MOD n
   
   [<a name="ZN_num_mod-val"><b>ZN_num_mod</b></a>]  Theorem
      
       n c. 0 &lt; n  (ZN n).sum.exp (ZN n).prod.id c = c MOD n
   
   [<a name="ZN_order_0-val"><b>ZN_order_0</b></a>]  Theorem
      
       n. 0 &lt; n  ordz n 0 = if n = 1 then 1 else 0
   
   [<a name="ZN_order_1-val"><b>ZN_order_1</b></a>]  Theorem
      
       n. 0 &lt; n  ordz n 1 = 1
   
   [<a name="ZN_order_divides_exp-val"><b>ZN_order_divides_exp</b></a>]  Theorem
      
       m n k. 1 &lt; m  0 &lt; k  (n ** k MOD m = 1  ordz m n divides k)
   
   [<a name="ZN_order_divides_phi-val"><b>ZN_order_divides_phi</b></a>]  Theorem
      
       m n. 0 &lt; m  0 &lt; ordz m n  ordz m n divides phi m
   
   [<a name="ZN_order_divides_tops_index-val"><b>ZN_order_divides_tops_index</b></a>]  Theorem
      
       n j k.
          1 &lt; n  0 &lt; j  1 &lt; k  (k divides tops n j  ordz k n divides j)
   
   [<a name="ZN_order_divisibility-val"><b>ZN_order_divisibility</b></a>]  Theorem
      
       m n. 0 &lt; m  m divides tops n (ordz m n)
   
   [<a name="ZN_order_eq_0-val"><b>ZN_order_eq_0</b></a>]  Theorem
      
       m n. 0 &lt; m  (ordz m n = 0  gcd m n  1)
   
   [<a name="ZN_order_eq_0_iff-val"><b>ZN_order_eq_0_iff</b></a>]  Theorem
      
       m n. 1 &lt; m  (ordz m n = 0  k. 0 &lt; k  n ** k MOD m  1)
   
   [<a name="ZN_order_eq_0_test-val"><b>ZN_order_eq_0_test</b></a>]  Theorem
      
       m n. 1 &lt; m  (ordz m n = 0  j. 0 &lt; j  j &lt; m  n ** j MOD m  1)
   
   [<a name="ZN_order_eq_1-val"><b>ZN_order_eq_1</b></a>]  Theorem
      
       m n. 0 &lt; m  (ordz m n = 1  n MOD m = 1 MOD m)
   
   [<a name="ZN_order_eq_1_alt-val"><b>ZN_order_eq_1_alt</b></a>]  Theorem
      
       m n. 1 &lt; m  (ordz m n = 1  n MOD m = 1)
   
   [<a name="ZN_order_eq_1_by_prime_factors-val"><b>ZN_order_eq_1_by_prime_factors</b></a>]  Theorem
      
       m n.
          0 &lt; m  coprime m n  (p. prime p  p divides n  ordz m p = 1) 
          ordz m n = 1
   
   [<a name="ZN_order_gt_1_property-val"><b>ZN_order_gt_1_property</b></a>]  Theorem
      
       m n.
          0 &lt; m  1 &lt; ordz m n  p. prime p  p divides n  1 &lt; ordz m p
   
   [<a name="ZN_order_le-val"><b>ZN_order_le</b></a>]  Theorem
      
       m n. 0 &lt; m  ordz m n  m
   
   [<a name="ZN_order_le_tops_index-val"><b>ZN_order_le_tops_index</b></a>]  Theorem
      
       n j k. 1 &lt; n  0 &lt; j  1 &lt; k  k divides tops n j  ordz k n  j
   
   [<a name="ZN_order_lt-val"><b>ZN_order_lt</b></a>]  Theorem
      
       k n m. 0 &lt; k  k &lt; m  ordz k n &lt; m
   
   [<a name="ZN_order_minimal-val"><b>ZN_order_minimal</b></a>]  Theorem
      
       m n k. 0 &lt; m  0 &lt; k  k &lt; ordz m n  n ** k MOD m  1
   
   [<a name="ZN_order_mod-val"><b>ZN_order_mod</b></a>]  Theorem
      
       m n. 0 &lt; m  ordz m (n MOD m) = ordz m n
   
   [<a name="ZN_order_mod_1-val"><b>ZN_order_mod_1</b></a>]  Theorem
      
       n. ordz 1 n = 1
   
   [<a name="ZN_order_nonzero-val"><b>ZN_order_nonzero</b></a>]  Theorem
      
       m n. 0 &lt; m  (ordz m n  0  coprime m n)
   
   [<a name="ZN_order_nonzero_iff-val"><b>ZN_order_nonzero_iff</b></a>]  Theorem
      
       m n. 1 &lt; m  (ordz m n  0  k. 0 &lt; k  n ** k MOD m = 1)
   
   [<a name="ZN_order_property-val"><b>ZN_order_property</b></a>]  Theorem
      
       m n. 0 &lt; m  n ** ordz m n MOD m = 1 MOD m
   
   [<a name="ZN_order_property_alt-val"><b>ZN_order_property_alt</b></a>]  Theorem
      
       m n. 1 &lt; m  n ** ordz m n MOD m = 1
   
   [<a name="ZN_order_test_1-val"><b>ZN_order_test_1</b></a>]  Theorem
      
       m n k.
          1 &lt; m  0 &lt; k 
          (ordz m n = k 
           n ** k MOD m = 1  j. 0 &lt; j  j &lt; k  n ** j MOD m  1)
   
   [<a name="ZN_order_test_2-val"><b>ZN_order_test_2</b></a>]  Theorem
      
       m n k.
          1 &lt; m  0 &lt; k 
          (ordz m n = k 
           n ** k MOD m = 1 
           j. 0 &lt; j  j &lt; k  j divides phi m  n ** j MOD m  1)
   
   [<a name="ZN_order_test_3-val"><b>ZN_order_test_3</b></a>]  Theorem
      
       m n k.
          1 &lt; m  0 &lt; k 
          (ordz m n = k 
           k divides phi m  n ** k MOD m = 1 
           j. 0 &lt; j  j &lt; k  j divides phi m  n ** j MOD m  1)
   
   [<a name="ZN_order_test_4-val"><b>ZN_order_test_4</b></a>]  Theorem
      
       m n k.
          1 &lt; m 
          (ordz m n = k 
           n ** k MOD m = 1 
           j. 0 &lt; j  j &lt; (if k = 0 then m else k)  n ** j MOD m  1)
   
   [<a name="ZN_order_test_propery-val"><b>ZN_order_test_propery</b></a>]  Theorem
      
       m n k.
          1 &lt; m  0 &lt; k  n ** k MOD m = 1 
          (j. 0 &lt; j  j &lt; k  j divides phi m  n ** j MOD m  1) 
          j. 0 &lt; j  j &lt; k  (j divides phi m) 
              ordz m n = k  n ** j MOD m  1
   
   [<a name="ZN_order_upper-val"><b>ZN_order_upper</b></a>]  Theorem
      
       m n. 0 &lt; m  ordz m n  phi m
   
   [<a name="ZN_order_with_coprime_1-val"><b>ZN_order_with_coprime_1</b></a>]  Theorem
      
       m n. 1 &lt; n  coprime m n  1 &lt; ordz m n  1 &lt; m
   
   [<a name="ZN_order_with_coprime_2-val"><b>ZN_order_with_coprime_2</b></a>]  Theorem
      
       m n k.
          1 &lt; m  m divides n  1 &lt; ordz k m  coprime k n  1 &lt; n  1 &lt; k
   
   [<a name="ZN_property-val"><b>ZN_property</b></a>]  Theorem
      
       n. (x. x  (ZN n).carrier  x &lt; n)  (ZN n).sum.id = 0 
            (ZN n).prod.id = (if n = 1 then 0 else 1) 
            (x y. (ZN n).sum.op x y = (x + y) MOD n) 
            (x y. (ZN n).prod.op x y = (x * y) MOD n) 
            FINITE (ZN n).carrier  CARD (ZN n).carrier = n
   
   [<a name="ZN_ring-val"><b>ZN_ring</b></a>]  Theorem
      
       n. 0 &lt; n  Ring (ZN n)
   
   [<a name="ZN_to_ZN_element-val"><b>ZN_to_ZN_element</b></a>]  Theorem
      
       n m x. 0 &lt; m  x  (ZN n).carrier  x MOD m  (ZN m).carrier
   
   [<a name="ZN_to_ZN_prod_monoid_homo-val"><b>ZN_to_ZN_prod_monoid_homo</b></a>]  Theorem
      
       n m.
          0 &lt; n  m divides n 
          MonoidHomo (x. x MOD m) (ZN n).prod (ZN m).prod
   
   [<a name="ZN_to_ZN_ring_homo-val"><b>ZN_to_ZN_ring_homo</b></a>]  Theorem
      
       n m. 0 &lt; n  m divides n  RingHomo (x. x MOD m) (ZN n) (ZN m)
   
   [<a name="ZN_to_ZN_sum_group_homo-val"><b>ZN_to_ZN_sum_group_homo</b></a>]  Theorem
      
       n m.
          0 &lt; n  m divides n 
          GroupHomo (x. x MOD m) (ZN n).sum (ZN m).sum
   
   [<a name="ZP_finite-val"><b>ZP_finite</b></a>]  Theorem
      
       p. FINITE (ZP p).carrier
   
   [<a name="ZP_finite_integral_domain-val"><b>ZP_finite_integral_domain</b></a>]  Theorem
      
       p. prime p  FiniteIntegralDomain (ZP p)
   
   [<a name="ZP_integral_domain-val"><b>ZP_integral_domain</b></a>]  Theorem
      
       p. prime p  IntegralDomain (ZP p)
   
   [<a name="Z_add_abelian_group-val"><b>Z_add_abelian_group</b></a>]  Theorem
      
       AbelianGroup Z_add
   
   [<a name="Z_add_group-val"><b>Z_add_group</b></a>]  Theorem
      
       Group Z_add
   
   [<a name="Z_add_inv-val"><b>Z_add_inv</b></a>]  Theorem
      
       z. z  Z_add.carrier  Z_add.inv z = -z
   
   [<a name="Z_euclid_ring-val"><b>Z_euclid_ring</b></a>]  Theorem
      
       EuclideanRing Z Num
   
   [<a name="Z_ideal_map_bij-val"><b>Z_ideal_map_bij</b></a>]  Theorem
      
       n. 0 &lt; n 
            BIJ (j. coset Z.sum (&j) (Z* n).sum.carrier) (ZN n).carrier
              (Z / Z* n).carrier
   
   [<a name="Z_ideal_map_element-val"><b>Z_ideal_map_element</b></a>]  Theorem
      
       n j.
          0 &lt; n  j  (ZN n).carrier 
          coset Z.sum (&j) (Z* n).sum.carrier  (Z / Z* n).carrier
   
   [<a name="Z_ideal_map_group_homo-val"><b>Z_ideal_map_group_homo</b></a>]  Theorem
      
       n. 0 &lt; n 
            GroupHomo (j. coset Z.sum (&j) (Z* n).sum.carrier) (ZN n).sum
              (Z / Z* n).sum
   
   [<a name="Z_ideal_map_monoid_homo-val"><b>Z_ideal_map_monoid_homo</b></a>]  Theorem
      
       n. 0 &lt; n 
            MonoidHomo (j. coset Z.sum (&j) (Z* n).sum.carrier)
              (ZN n).prod (Z / Z* n).prod
   
   [<a name="Z_ideal_sum_group-val"><b>Z_ideal_sum_group</b></a>]  Theorem
      
       n. Group (Z* n).sum
   
   [<a name="Z_ideal_sum_normal-val"><b>Z_ideal_sum_normal</b></a>]  Theorem
      
       n. (Z* n).sum &lt;&lt; Z.sum
   
   [<a name="Z_ideal_sum_subgroup-val"><b>Z_ideal_sum_subgroup</b></a>]  Theorem
      
       n. (Z* n).sum  Z.sum
   
   [<a name="Z_ideal_thm-val"><b>Z_ideal_thm</b></a>]  Theorem
      
       n. Z* n &lt;&lt; Z
   
   [<a name="Z_mult_abelian_monoid-val"><b>Z_mult_abelian_monoid</b></a>]  Theorem
      
       AbelianMonoid Z_mult
   
   [<a name="Z_mult_monoid-val"><b>Z_mult_monoid</b></a>]  Theorem
      
       Monoid Z_mult
   
   [<a name="Z_multiple_less_neg_eq-val"><b>Z_multiple_less_neg_eq</b></a>]  Theorem
      
       n x y. 0 &lt; n  x &lt; n  y &lt; n  -&x + &y  Z_multiple n  x = y
   
   [<a name="Z_principal_ideal_ring-val"><b>Z_principal_ideal_ring</b></a>]  Theorem
      
       PrincipalIdealRing Z
   
   [<a name="Z_quotient_iso_ZN-val"><b>Z_quotient_iso_ZN</b></a>]  Theorem
      
       n. 0 &lt; n 
            RingIso (j. coset Z.sum (&j) (Z* n).sum.carrier) (ZN n)
              (Z / Z* n)
   
   [<a name="Z_ring-val"><b>Z_ring</b></a>]  Theorem
      
       Ring Z
   
   [<a name="Z_sum_cogen-val"><b>Z_sum_cogen</b></a>]  Theorem
      
       n. 0 &lt; n 
            x. x  Z.sum.carrier 
                y. cogen Z.sum (Z* n).sum
                      (coset Z.sum x (Z* n).sum.carrier) = x + &n * y
   
   [<a name="Z_sum_coset_eq-val"><b>Z_sum_coset_eq</b></a>]  Theorem
      
       n. 0 &lt; n 
            p. coset Z.sum p (Z* n).sum.carrier =
                coset Z.sum (p % &n) (Z* n).sum.carrier
   
   [<a name="char_eq_0-val"><b>char_eq_0</b></a>]  Theorem
      
       r. char r = 0  n. 0 &lt; n  ##n  #0
   
   [<a name="char_minimal-val"><b>char_minimal</b></a>]  Theorem
      
       r. 0 &lt; char r  n. 0 &lt; n  n &lt; char r  ##n  #0
   
   [<a name="char_property-val"><b>char_property</b></a>]  Theorem
      
       r. ##(char r) = #0
   
   [<a name="compute_ordz_0-val"><b>compute_ordz_0</b></a>]  Theorem
      
       n. compute_ordz 0 n = ordz 0 n
   
   [<a name="compute_ordz_1-val"><b>compute_ordz_1</b></a>]  Theorem
      
       n. compute_ordz 1 n = 1
   
   [<a name="compute_ordz_eqn-val"><b>compute_ordz_eqn</b></a>]  Theorem
      
       m n. compute_ordz m n = ordz m n
   
   [<a name="compute_ordz_hoare-val"><b>compute_ordz_hoare</b></a>]  Theorem
      
       m n.
          1 &lt; m  coprime m n 
          HOARE_SPEC (i. 0 &lt; i  i  ordz m n)
            (WHILE (i. n ** i MOD m  1) SUC) (i. i = ordz m n)
   
   [<a name="datatype_ring-val"><b>datatype_ring</b></a>]  Theorem
      
       DATATYPE (record ring carrier sum prod)
   
   [<a name="euclid_ring_map-val"><b>euclid_ring_map</b></a>]  Theorem
      
       r f. EuclideanRing r f  x. f x = 0  x = #0
   
   [<a name="euclid_ring_principal_ideal_ring-val"><b>euclid_ring_principal_ideal_ring</b></a>]  Theorem
      
       r f. EuclideanRing r f  PrincipalIdealRing r
   
   [<a name="euclid_ring_property-val"><b>euclid_ring_property</b></a>]  Theorem
      
       r f.
          EuclideanRing r f 
          x y.
            x  R  y  R  y  #0 
            q t. q  R  t  R  x = q * y + t  f t &lt; f y
   
   [<a name="euclid_ring_ring-val"><b>euclid_ring_ring</b></a>]  Theorem
      
       r f. EuclideanRing r f  Ring r
   
   [<a name="finite_integral_domain_nonzero_group-val"><b>finite_integral_domain_nonzero_group</b></a>]  Theorem
      
       r. FiniteIntegralDomain r  Group f*
   
   [<a name="finite_integral_domain_nonzero_invertible-val"><b>finite_integral_domain_nonzero_invertible</b></a>]  Theorem
      
       r. FiniteIntegralDomain r  monoid_invertibles r.prod = R+
   
   [<a name="finite_integral_domain_nonzero_invertible_alt-val"><b>finite_integral_domain_nonzero_invertible_alt</b></a>]  Theorem
      
       r. FiniteIntegralDomain r  monoid_invertibles f* = F*
   
   [<a name="finite_integral_domain_period_exists-val"><b>finite_integral_domain_period_exists</b></a>]  Theorem
      
       r. FiniteIntegralDomain r  x. x  R+  k. 0 &lt; k  x ** k = #1
   
   [<a name="finite_ring_add_finite_abelian_group-val"><b>finite_ring_add_finite_abelian_group</b></a>]  Theorem
      
       r. FiniteRing r  FiniteAbelianGroup r.sum  r.sum.carrier = R
   
   [<a name="finite_ring_add_finite_group-val"><b>finite_ring_add_finite_group</b></a>]  Theorem
      
       r. FiniteRing r  FiniteGroup r.sum  r.sum.carrier = R
   
   [<a name="finite_ring_card_eq_1-val"><b>finite_ring_card_eq_1</b></a>]  Theorem
      
       r. FiniteRing r  (CARD R = 1  #1 = #0)
   
   [<a name="finite_ring_card_pos-val"><b>finite_ring_card_pos</b></a>]  Theorem
      
       r. FiniteRing r  0 &lt; CARD R
   
   [<a name="finite_ring_card_prime-val"><b>finite_ring_card_prime</b></a>]  Theorem
      
       r. FiniteRing r  prime (CARD R)  char r = CARD R
   
   [<a name="finite_ring_char-val"><b>finite_ring_char</b></a>]  Theorem
      
       r. FiniteRing r  0 &lt; char r  char r = order r.sum #1
   
   [<a name="finite_ring_char_alt-val"><b>finite_ring_char_alt</b></a>]  Theorem
      
       r. FiniteRing r 
            n. char r = n 
                0 &lt; n  ##n = #0  m. 0 &lt; m  m &lt; n  ##m  #0
   
   [<a name="finite_ring_char_divides-val"><b>finite_ring_char_divides</b></a>]  Theorem
      
       r. FiniteRing r  char r divides CARD R
   
   [<a name="finite_ring_char_pos-val"><b>finite_ring_char_pos</b></a>]  Theorem
      
       r. FiniteRing r  0 &lt; char r
   
   [<a name="finite_ring_is_ring-val"><b>finite_ring_is_ring</b></a>]  Theorem
      
       r. FiniteRing r  Ring r
   
   [<a name="finite_ring_mult_finite_abelian_monoid-val"><b>finite_ring_mult_finite_abelian_monoid</b></a>]  Theorem
      
       r. FiniteRing r  FiniteAbelianMonoid r.prod
   
   [<a name="finite_ring_mult_finite_monoid-val"><b>finite_ring_mult_finite_monoid</b></a>]  Theorem
      
       r. FiniteRing r  FiniteMonoid r.prod
   
   [<a name="homo_ring_by_inj-val"><b>homo_ring_by_inj</b></a>]  Theorem
      
       r f. Ring r  INJ f R (:)  RingHomo f r (homo_ring r f)
   
   [<a name="homo_ring_property-val"><b>homo_ring_property</b></a>]  Theorem
      
       r f.
          fR = IMAGE f R  (homo_ring r f).sum = homo_group r.sum f 
          (homo_ring r f).prod = homo_group r.prod f
   
   [<a name="homo_ring_ring-val"><b>homo_ring_ring</b></a>]  Theorem
      
       r f. Ring r  RingHomo f r (homo_ring r f)  Ring (homo_ring r f)
   
   [<a name="homo_ring_subring-val"><b>homo_ring_subring</b></a>]  Theorem
      
       r s f. (r ~r~ s) f  subring (homo_ring r f) s
   
   [<a name="ideal_antisym-val"><b>ideal_antisym</b></a>]  Theorem
      
       r i. i &lt;&lt; r  r &lt;&lt; i  i = r
   
   [<a name="ideal_carrier_sing-val"><b>ideal_carrier_sing</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  (SING I  i = &lt;#0&gt;)
   
   [<a name="ideal_carriers-val"><b>ideal_carriers</b></a>]  Theorem
      
       r i. i &lt;&lt; r  i.sum.carrier = I  i.prod.carrier = I
   
   [<a name="ideal_cogen_property-val"><b>ideal_cogen_property</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  x. x  R/I  gen x  R  gen x  I = x
   
   [<a name="ideal_congruence_elements-val"><b>ideal_congruence_elements</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  x y. x  I  y  R  (y  I  x === y)
   
   [<a name="ideal_congruence_equiv-val"><b>ideal_congruence_equiv</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  $=== equiv_on R
   
   [<a name="ideal_congruence_iff_inCoset-val"><b>ideal_congruence_iff_inCoset</b></a>]  Theorem
      
       r i.
          Ring r  i &lt;&lt; r 
          x y. x  I  y  I  (x === y  inCoset r.sum i.sum x y)
   
   [<a name="ideal_congruence_mult-val"><b>ideal_congruence_mult</b></a>]  Theorem
      
       r i.
          Ring r  i &lt;&lt; r 
          x y z. x  R  y  R  z  R  x === y  z * x === z * y
   
   [<a name="ideal_congruence_refl-val"><b>ideal_congruence_refl</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  x. x  R  x === x
   
   [<a name="ideal_congruence_sym-val"><b>ideal_congruence_sym</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  x y. x  R  y  R  (x === y  y === x)
   
   [<a name="ideal_congruence_trans-val"><b>ideal_congruence_trans</b></a>]  Theorem
      
       r i.
          Ring r  i &lt;&lt; r 
          x y z. x  R  y  R  z  R  x === y  y === z  x === z
   
   [<a name="ideal_coset_add-val"><b>ideal_coset_add</b></a>]  Theorem
      
       r i.
          Ring r  i &lt;&lt; r 
          x y. x  R  y  R  x  I + y  I = (x + y)  I
   
   [<a name="ideal_coset_element-val"><b>ideal_coset_element</b></a>]  Theorem
      
       r i x.
          Ring r  i &lt;&lt; r  x  R  z. z  x  I  y. y  I  z = x + y
   
   [<a name="ideal_coset_eq-val"><b>ideal_coset_eq</b></a>]  Theorem
      
       r i.
          Ring r  i &lt;&lt; r 
          x y. x  R  y  R  (x  I = y  I  x  y  I)
   
   [<a name="ideal_coset_eq_carrier-val"><b>ideal_coset_eq_carrier</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  x. x  R  x  I = I  x  I
   
   [<a name="ideal_coset_eq_congruence-val"><b>ideal_coset_eq_congruence</b></a>]  Theorem
      
       r i.
          Ring r  i &lt;&lt; r  x y. x  R  y  R  (x  I = y  I  x === y)
   
   [<a name="ideal_coset_has_gen_diff-val"><b>ideal_coset_has_gen_diff</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  x. x  R  gen (x  I)  x  I
   
   [<a name="ideal_coset_mult-val"><b>ideal_coset_mult</b></a>]  Theorem
      
       r i.
          Ring r  i &lt;&lt; r 
          x y. x  R  y  R  x  I * y  I = (x * y)  I
   
   [<a name="ideal_coset_neg-val"><b>ideal_coset_neg</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  x. x  R  x  I + -x  I = I
   
   [<a name="ideal_coset_of_element-val"><b>ideal_coset_of_element</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  x. x  I  x  I = I
   
   [<a name="ideal_coset_property-val"><b>ideal_coset_property</b></a>]  Theorem
      
       r i.
          Ring r  i &lt;&lt; r 
          x. x  R  x  I  R/I  gen (x  I)  I = x  I
   
   [<a name="ideal_coset_zero-val"><b>ideal_coset_zero</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  #0  I = I
   
   [<a name="ideal_element-val"><b>ideal_element</b></a>]  Theorem
      
       r i. i &lt;&lt; r  x. x  I  x  r.sum.carrier
   
   [<a name="ideal_element_property-val"><b>ideal_element_property</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  x. x  I  x  R
   
   [<a name="ideal_eq_ideal-val"><b>ideal_eq_ideal</b></a>]  Theorem
      
       r i j. Ring r  i &lt;&lt; r  j &lt;&lt; r  (i = j  I = J)
   
   [<a name="ideal_gen_exists-val"><b>ideal_gen_exists</b></a>]  Theorem
      
       r i.
          Ring r  i &lt;&lt; r  i  &lt;#0&gt; 
          f. (x. f x = 0  x = #0) 
              p. p  I  p  #0  z. z  I  z  #0  f p  f z
   
   [<a name="ideal_gen_minimal-val"><b>ideal_gen_minimal</b></a>]  Theorem
      
       r i.
          Ring r  i &lt;&lt; r  i  &lt;#0&gt; 
          f. (x. f x = 0  x = #0) 
              z. z  I  (f z &lt; f (ideal_gen r i f)  z = #0)
   
   [<a name="ideal_has_diff-val"><b>ideal_has_diff</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  x y. x  I  y  I  x  y  I
   
   [<a name="ideal_has_multiple-val"><b>ideal_has_multiple</b></a>]  Theorem
      
       r i. i &lt;&lt; r  x y. x  I  y  R  x * y  I
   
   [<a name="ideal_has_neg-val"><b>ideal_has_neg</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  x. x  I  -x  I
   
   [<a name="ideal_has_one-val"><b>ideal_has_one</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  #1  I  I = R
   
   [<a name="ideal_has_principal_ideal-val"><b>ideal_has_principal_ideal</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  p. p  R  (p  I  &lt;p&gt; &lt;&lt; i)
   
   [<a name="ideal_has_product-val"><b>ideal_has_product</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  x y. x  I  y  I  x * y  I
   
   [<a name="ideal_has_subgroup-val"><b>ideal_has_subgroup</b></a>]  Theorem
      
       r i. i &lt;&lt; r  i.sum  r.sum
   
   [<a name="ideal_has_sum-val"><b>ideal_has_sum</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  x y. x  I  y  I  x + y  I
   
   [<a name="ideal_has_zero-val"><b>ideal_has_zero</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  #0  I
   
   [<a name="ideal_in_quotient_ring-val"><b>ideal_in_quotient_ring</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  I  R/I
   
   [<a name="ideal_ops-val"><b>ideal_ops</b></a>]  Theorem
      
       r i. i &lt;&lt; r  i.sum.op = $+  i.prod.op = $*
   
   [<a name="ideal_product_property-val"><b>ideal_product_property</b></a>]  Theorem
      
       r i. i &lt;&lt; r  x y. x  I  y  R  x * y  I  y * x  I
   
   [<a name="ideal_property-val"><b>ideal_property</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  x y. x  I  y  I  x + y  I  x * y  I
   
   [<a name="ideal_refl-val"><b>ideal_refl</b></a>]  Theorem
      
       r. Ring r  r &lt;&lt; r
   
   [<a name="ideal_sub_ideal-val"><b>ideal_sub_ideal</b></a>]  Theorem
      
       r i j. Ring r  i &lt;&lt; r  j &lt;&lt; r  (i &lt;&lt; j  I  J)
   
   [<a name="ideal_sub_itself-val"><b>ideal_sub_itself</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  i &lt;&lt; i
   
   [<a name="ideal_subgroup_ideal_sum-val"><b>ideal_subgroup_ideal_sum</b></a>]  Theorem
      
       r i j. Ring r  i &lt;&lt; r  j &lt;&lt; r  i.sum  (i + j).sum
   
   [<a name="ideal_sum_comm-val"><b>ideal_sum_comm</b></a>]  Theorem
      
       r i j. Ring r  i &lt;&lt; r  j &lt;&lt; r  i + j = j + i
   
   [<a name="ideal_sum_element-val"><b>ideal_sum_element</b></a>]  Theorem
      
       i j x. x  (i + j).carrier  y z. y  I  z  J  x = y + z
   
   [<a name="ideal_sum_group-val"><b>ideal_sum_group</b></a>]  Theorem
      
       r i j. Ring r  i &lt;&lt; r  j &lt;&lt; r  Group (i + j).sum
   
   [<a name="ideal_sum_has_ideal-val"><b>ideal_sum_has_ideal</b></a>]  Theorem
      
       r i j. Ring r  i &lt;&lt; r  j &lt;&lt; r  i &lt;&lt; (i + j)
   
   [<a name="ideal_sum_has_ideal_comm-val"><b>ideal_sum_has_ideal_comm</b></a>]  Theorem
      
       r i j. Ring r  i &lt;&lt; r  j &lt;&lt; r  j &lt;&lt; (i + j)
   
   [<a name="ideal_sum_ideal-val"><b>ideal_sum_ideal</b></a>]  Theorem
      
       r i j. Ring r  i &lt;&lt; r  j &lt;&lt; r  (i + j) &lt;&lt; r
   
   [<a name="ideal_sum_sub_ideal-val"><b>ideal_sum_sub_ideal</b></a>]  Theorem
      
       r i j. Ring r  i &lt;&lt; r  j &lt;&lt; r  ((i + j) &lt;&lt; j  i &lt;&lt; j)
   
   [<a name="ideal_sum_subgroup-val"><b>ideal_sum_subgroup</b></a>]  Theorem
      
       r i j. Ring r  i &lt;&lt; r  j &lt;&lt; r  (i + j).sum  r.sum
   
   [<a name="ideal_with_one-val"><b>ideal_with_one</b></a>]  Theorem
      
       r. Ring r  i. i &lt;&lt; r  #1  I  i = r
   
   [<a name="ideal_with_unit-val"><b>ideal_with_unit</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  x. x  I  unit x  i = r
   
   [<a name="ideal_zero-val"><b>ideal_zero</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  i.sum.id = #0
   
   [<a name="integral_domain_char-val"><b>integral_domain_char</b></a>]  Theorem
      
       r. IntegralDomain r  char r = 0  prime (char r)
   
   [<a name="integral_domain_divides_prime-val"><b>integral_domain_divides_prime</b></a>]  Theorem
      
       r p x.
          IntegralDomain r  x  R  p  R  p  #0  rprime p  p  R* 
          x  R*  x rdivides p 
          rassoc x p
   
   [<a name="integral_domain_exp_eq-val"><b>integral_domain_exp_eq</b></a>]  Theorem
      
       r. IntegralDomain r 
            x. x  R+  m n. m &lt; n  x ** m = x ** n  x ** (n  m) = #1
   
   [<a name="integral_domain_exp_eq_zero-val"><b>integral_domain_exp_eq_zero</b></a>]  Theorem
      
       r. IntegralDomain r  x. x  R  n. x ** n = #0  n  0  x = #0
   
   [<a name="integral_domain_exp_nonzero-val"><b>integral_domain_exp_nonzero</b></a>]  Theorem
      
       r. IntegralDomain r  x. x  R+  n. x ** n  R+
   
   [<a name="integral_domain_is_ring-val"><b>integral_domain_is_ring</b></a>]  Theorem
      
       r. IntegralDomain r  Ring r
   
   [<a name="integral_domain_mult_eq_zero-val"><b>integral_domain_mult_eq_zero</b></a>]  Theorem
      
       r. IntegralDomain r 
            x y. x  R  y  R  (x * y = #0  x = #0  y = #0)
   
   [<a name="integral_domain_mult_lcancel-val"><b>integral_domain_mult_lcancel</b></a>]  Theorem
      
       r. IntegralDomain r 
            x y z.
              x  R  y  R  z  R  (x * y = x * z  x = #0  y = z)
   
   [<a name="integral_domain_mult_nonzero-val"><b>integral_domain_mult_nonzero</b></a>]  Theorem
      
       r. IntegralDomain r  x y. x  R+  y  R+  x * y  R+
   
   [<a name="integral_domain_mult_rcancel-val"><b>integral_domain_mult_rcancel</b></a>]  Theorem
      
       r. IntegralDomain r 
            x y z.
              x  R  y  R  z  R  (y * x = z * x  x = #0  y = z)
   
   [<a name="integral_domain_nonzero_monoid-val"><b>integral_domain_nonzero_monoid</b></a>]  Theorem
      
       r. IntegralDomain r  Monoid f*
   
   [<a name="integral_domain_nonzero_mult_carrier-val"><b>integral_domain_nonzero_mult_carrier</b></a>]  Theorem
      
       r. IntegralDomain r  F* = R+
   
   [<a name="integral_domain_nonzero_mult_is_monoid-val"><b>integral_domain_nonzero_mult_is_monoid</b></a>]  Theorem
      
       r. IntegralDomain r  Monoid (monoid_of_ring_nonzero_mult r)
   
   [<a name="integral_domain_nonzero_mult_property-val"><b>integral_domain_nonzero_mult_property</b></a>]  Theorem
      
       r. IntegralDomain r 
            F* = R+  f*.id = #1  f*.op = $*  f*.exp = $**
   
   [<a name="integral_domain_nonzero_order-val"><b>integral_domain_nonzero_order</b></a>]  Theorem
      
       r. IntegralDomain r  x. order r.prod x = order f* x
   
   [<a name="integral_domain_one_ne_zero-val"><b>integral_domain_one_ne_zero</b></a>]  Theorem
      
       r. IntegralDomain r  #1  #0
   
   [<a name="integral_domain_one_nonzero-val"><b>integral_domain_one_nonzero</b></a>]  Theorem
      
       r. IntegralDomain r  #1  R+
   
   [<a name="integral_domain_order_eq_0-val"><b>integral_domain_order_eq_0</b></a>]  Theorem
      
       r. FiniteIntegralDomain r  x. x  R  (order f* x = 0  x = #0)
   
   [<a name="integral_domain_order_nonzero-val"><b>integral_domain_order_nonzero</b></a>]  Theorem
      
       r. FiniteIntegralDomain r  x. x  R+  order f* x  0
   
   [<a name="integral_domain_order_zero-val"><b>integral_domain_order_zero</b></a>]  Theorem
      
       r. IntegralDomain r  order f* #0 = 0
   
   [<a name="integral_domain_prime_factors_unique-val"><b>integral_domain_prime_factors_unique</b></a>]  Theorem
      
       IntegralDomain r 
        l1 l2.
          (m. MEM m l1  m  R  rprime m  m  #0  m  R* ) 
          (m. MEM m l2  m  R  rprime m  m  #0  m  R* ) 
          rassoc (GBAG r.prod (LIST_TO_BAG l1))
            (GBAG r.prod (LIST_TO_BAG l2)) 
          l3. PERM l2 l3  LIST_REL rassoc l1 l3
   
   [<a name="integral_domain_ring_iso-val"><b>integral_domain_ring_iso</b></a>]  Theorem
      
       IntegralDomain r  Ring s  RingIso f r s  IntegralDomain s
   
   [<a name="integral_domain_zero_not_unit-val"><b>integral_domain_zero_not_unit</b></a>]  Theorem
      
       r. IntegralDomain r  #0  R*
   
   [<a name="integral_domain_zero_product-val"><b>integral_domain_zero_product</b></a>]  Theorem
      
       r. IntegralDomain r 
            x y. x  R  y  R  (x * y = #0  x = #0  y = #0)
   
   [<a name="irreducible_associates-val"><b>irreducible_associates</b></a>]  Theorem
      
       r. Ring r  #1  #0 
            p s. p  R  unit s  (atom p  atom (s * p))
   
   [<a name="irreducible_element-val"><b>irreducible_element</b></a>]  Theorem
      
       r p. atom p  p  R
   
   [<a name="irreducible_factors-val"><b>irreducible_factors</b></a>]  Theorem
      
       r z.
          atom z 
          z  R+  z  R*  p. p  R  p rdivides z  rassoc z p  unit p
   
   [<a name="kernel_ideal_element-val"><b>kernel_ideal_element</b></a>]  Theorem
      
       r r_ f x.
          x  (kernel_ideal f r r_).carrier  x  r.sum.carrier  f x = #0_
   
   [<a name="kernel_ideal_gen_add_map-val"><b>kernel_ideal_gen_add_map</b></a>]  Theorem
      
       r r_ f.
          (r ~r~ r_) f 
          (let
             i = kernel_ideal f r r_
           in
             x y.
               x  R/I  y  R/I 
               f (gen ((gen x + gen y)  I)) = f (gen x) +_ f (gen y))
   
   [<a name="kernel_ideal_gen_id_map-val"><b>kernel_ideal_gen_id_map</b></a>]  Theorem
      
       r r_ f.
          (r ~r~ r_) f 
          (let i = kernel_ideal f r r_ in f (gen (#1  I)) = #1_)
   
   [<a name="kernel_ideal_gen_mult_map-val"><b>kernel_ideal_gen_mult_map</b></a>]  Theorem
      
       r r_ f.
          (r ~r~ r_) f 
          (let
             i = kernel_ideal f r r_
           in
             x y.
               x  R/I  y  R/I 
               f (gen ((gen x * gen y)  I)) = f (gen x) *_ f (gen y))
   
   [<a name="kernel_ideal_quotient_bij-val"><b>kernel_ideal_quotient_bij</b></a>]  Theorem
      
       r r_ f.
          (r ~r~ r_) f 
          (let i = kernel_ideal f r r_ in BIJ (f  gen) R/I (IMAGE f R))
   
   [<a name="kernel_ideal_quotient_element_eq-val"><b>kernel_ideal_quotient_element_eq</b></a>]  Theorem
      
       r r_ f.
          (r ~r~ r_) f 
          (let
             i = kernel_ideal f r r_
           in
             x y. x  R/I  y  R/I  (gen x  gen y  I  x = y))
   
   [<a name="kernel_ideal_quotient_homo-val"><b>kernel_ideal_quotient_homo</b></a>]  Theorem
      
       r s f.
          (r ~r~ s) f 
          (let
             i = kernel_ideal f r s
           in
             RingHomo (f  gen) (r / i) (ring_homo_image f r s))
   
   [<a name="kernel_ideal_quotient_inj-val"><b>kernel_ideal_quotient_inj</b></a>]  Theorem
      
       r r_ f.
          (r ~r~ r_) f 
          (let i = kernel_ideal f r r_ in INJ (f  gen) R/I (IMAGE f R))
   
   [<a name="kernel_ideal_quotient_iso-val"><b>kernel_ideal_quotient_iso</b></a>]  Theorem
      
       r s f.
          (r ~r~ s) f 
          (let
             i = kernel_ideal f r s
           in
             RingIso (f  gen) (r / i) (ring_homo_image f r s))
   
   [<a name="kernel_ideal_quotient_surj-val"><b>kernel_ideal_quotient_surj</b></a>]  Theorem
      
       r r_ f.
          (r ~r~ r_) f 
          (let i = kernel_ideal f r r_ in SURJ (f  gen) R/I (IMAGE f R))
   
   [<a name="kernel_ideal_sum_eqn-val"><b>kernel_ideal_sum_eqn</b></a>]  Theorem
      
       r s f. (kernel_ideal f r s).sum = kernel_group f r.sum s.sum
   
   [<a name="ordz_eval-val"><b>ordz_eval</b></a>]  Theorem
      
       m n. order (times_mod m) n = compute_ordz m n
   
   [<a name="prime_is_irreducible-val"><b>prime_is_irreducible</b></a>]  Theorem
      
       r p.
          IntegralDomain r  p  R  rprime p  p  #0  p  R*  atom p
   
   [<a name="principal_ideal_element-val"><b>principal_ideal_element</b></a>]  Theorem
      
       p x. x  &lt;p&gt;.carrier  z. z  R  x = p * z
   
   [<a name="principal_ideal_element_divides-val"><b>principal_ideal_element_divides</b></a>]  Theorem
      
       r. Ring r  p. p  R  x. x  &lt;p&gt;.carrier  p rdivides x
   
   [<a name="principal_ideal_eq_principal_ideal-val"><b>principal_ideal_eq_principal_ideal</b></a>]  Theorem
      
       r. Ring r  p q u. p  R  q  R  unit u  p = q * u  &lt;p&gt; = &lt;q&gt;
   
   [<a name="principal_ideal_equal_principal_ideal-val"><b>principal_ideal_equal_principal_ideal</b></a>]  Theorem
      
       r. IntegralDomain r 
            p q. p  R  q  R  (&lt;p&gt; = &lt;q&gt;  u. unit u  p = q * u)
   
   [<a name="principal_ideal_group-val"><b>principal_ideal_group</b></a>]  Theorem
      
       r. Ring r  p. p  R  Group &lt;p&gt;.sum
   
   [<a name="principal_ideal_has_element-val"><b>principal_ideal_has_element</b></a>]  Theorem
      
       r. Ring r  p. p  R  p  &lt;p&gt;.carrier
   
   [<a name="principal_ideal_has_principal_ideal-val"><b>principal_ideal_has_principal_ideal</b></a>]  Theorem
      
       r. Ring r  p q. p  R  q  &lt;p&gt;.carrier  &lt;q&gt; &lt;&lt; &lt;p&gt;
   
   [<a name="principal_ideal_ideal-val"><b>principal_ideal_ideal</b></a>]  Theorem
      
       r. Ring r  p. p  R  &lt;p&gt; &lt;&lt; r
   
   [<a name="principal_ideal_property-val"><b>principal_ideal_property</b></a>]  Theorem
      
       r p.
          &lt;p&gt;.carrier = p * R  &lt;p&gt;.sum.carrier = p * R 
          &lt;p&gt;.prod.carrier = p * R  &lt;p&gt;.sum.op = $+  &lt;p&gt;.prod.op = $* 
          &lt;p&gt;.sum.id = #0  &lt;p&gt;.prod.id = #1
   
   [<a name="principal_ideal_ring_atom_is_prime-val"><b>principal_ideal_ring_atom_is_prime</b></a>]  Theorem
      
       r. PrincipalIdealRing r  p. atom p  rprime p
   
   [<a name="principal_ideal_ring_ideal_maximal-val"><b>principal_ideal_ring_ideal_maximal</b></a>]  Theorem
      
       r. PrincipalIdealRing r  p. atom p  maxi &lt;p&gt;
   
   [<a name="principal_ideal_ring_irreducible_is_prime-val"><b>principal_ideal_ring_irreducible_is_prime</b></a>]  Theorem
      
       r. PrincipalIdealRing r  p. atom p  rprime p
   
   [<a name="principal_ideal_sub_implies_divides-val"><b>principal_ideal_sub_implies_divides</b></a>]  Theorem
      
       r. Ring r  p q. p  R  q  R  (q rdivides p  &lt;p&gt; &lt;&lt; &lt;q&gt;)
   
   [<a name="principal_ideal_subgroup-val"><b>principal_ideal_subgroup</b></a>]  Theorem
      
       r. Ring r  p. p  R  &lt;p&gt;.sum  r.sum
   
   [<a name="principal_ideal_subgroup_normal-val"><b>principal_ideal_subgroup_normal</b></a>]  Theorem
      
       r. Ring r  p. p  R  &lt;p&gt;.sum &lt;&lt; r.sum
   
   [<a name="principal_ideal_sum_eq_ideal-val"><b>principal_ideal_sum_eq_ideal</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  p. p  I  &lt;p&gt; + i = i
   
   [<a name="principal_ideal_sum_equal_ideal-val"><b>principal_ideal_sum_equal_ideal</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  p. p  I  p  R  &lt;p&gt; + i = i
   
   [<a name="quotient_ring_add_abelian_group-val"><b>quotient_ring_add_abelian_group</b></a>]  Theorem
      
       r. Ring r  i &lt;&lt; r  AbelianGroup (quotient_ring_add r i)
   
   [<a name="quotient_ring_add_assoc-val"><b>quotient_ring_add_assoc</b></a>]  Theorem
      
       r i.
          Ring r  i &lt;&lt; r 
          x y z. x  R/I  y  R/I  z  R/I  x + y + z = x + (y + z)
   
   [<a name="quotient_ring_add_comm-val"><b>quotient_ring_add_comm</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  x y. x  R/I  y  R/I  x + y = y + x
   
   [<a name="quotient_ring_add_element-val"><b>quotient_ring_add_element</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  x y. x  R/I  y  R/I  x + y  R/I
   
   [<a name="quotient_ring_add_group-val"><b>quotient_ring_add_group</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  Group (quotient_ring_add r i)
   
   [<a name="quotient_ring_add_id-val"><b>quotient_ring_add_id</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  x. x  R/I  I + x = x
   
   [<a name="quotient_ring_add_inv-val"><b>quotient_ring_add_inv</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  x. x  R/I  y. y  R/I  y + x = I
   
   [<a name="quotient_ring_by_principal_ideal-val"><b>quotient_ring_by_principal_ideal</b></a>]  Theorem
      
       r. Ring r  p. p  R  Ring (r / &lt;p&gt;)
   
   [<a name="quotient_ring_element-val"><b>quotient_ring_element</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  z. z  R/I  x. x  R  z = x  I
   
   [<a name="quotient_ring_has_ideal-val"><b>quotient_ring_has_ideal</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  I  R/I
   
   [<a name="quotient_ring_homo-val"><b>quotient_ring_homo</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  RingHomo (x. x  I) r (r / i)
   
   [<a name="quotient_ring_homo_kernel-val"><b>quotient_ring_homo_kernel</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  kernel (x. x  I) r.sum (r / i).sum = I
   
   [<a name="quotient_ring_homo_kernel_ideal-val"><b>quotient_ring_homo_kernel_ideal</b></a>]  Theorem
      
       r i.
          Ring r  i &lt;&lt; r 
          RingHomo (x. x  I) r (r / i) 
          kernel_ideal (x. x  I) r (r / i) = i
   
   [<a name="quotient_ring_homo_surj-val"><b>quotient_ring_homo_surj</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  SURJ (x. x  I) R R/I
   
   [<a name="quotient_ring_mult_abelian_monoid-val"><b>quotient_ring_mult_abelian_monoid</b></a>]  Theorem
      
       r. Ring r  i &lt;&lt; r  AbelianMonoid (quotient_ring_mult r i)
   
   [<a name="quotient_ring_mult_assoc-val"><b>quotient_ring_mult_assoc</b></a>]  Theorem
      
       r i.
          Ring r  i &lt;&lt; r 
          x y z. x  R/I  y  R/I  z  R/I  x * y * z = x * (y * z)
   
   [<a name="quotient_ring_mult_comm-val"><b>quotient_ring_mult_comm</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  x y. x  R/I  y  R/I  x * y = y * x
   
   [<a name="quotient_ring_mult_element-val"><b>quotient_ring_mult_element</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  x y. x  R/I  y  R/I  x * y  R/I
   
   [<a name="quotient_ring_mult_id-val"><b>quotient_ring_mult_id</b></a>]  Theorem
      
       r i.
          Ring r  i &lt;&lt; r  x. x  R/I  #1  I * x = x  x * #1  I = x
   
   [<a name="quotient_ring_mult_ladd-val"><b>quotient_ring_mult_ladd</b></a>]  Theorem
      
       r i.
          Ring r  i &lt;&lt; r 
          x y z. x  R/I  y  R/I  z  R/I  x * (y + z) = x * y + x * z
   
   [<a name="quotient_ring_mult_monoid-val"><b>quotient_ring_mult_monoid</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  Monoid (quotient_ring_mult r i)
   
   [<a name="quotient_ring_property-val"><b>quotient_ring_property</b></a>]  Theorem
      
       r i.
          (r / i).carrier = R/I  (r / i).sum = quotient_ring_add r i 
          (r / i).prod = quotient_ring_mult r i
   
   [<a name="quotient_ring_ring-val"><b>quotient_ring_ring</b></a>]  Theorem
      
       r i. Ring r  i &lt;&lt; r  Ring (r / i)
   
   [<a name="quotient_ring_ring_sing-val"><b>quotient_ring_ring_sing</b></a>]  Theorem
      
       r. Ring r  (r / r).carrier = {R}
   
   [<a name="ring_11-val"><b>ring_11</b></a>]  Theorem
      
       a0 a1 a2 a0' a1' a2'.
          ring a0 a1 a2 = ring a0' a1' a2'  a0 = a0'  a1 = a1'  a2 = a2'
   
   [<a name="ring_Axiom-val"><b>ring_Axiom</b></a>]  Theorem
      
       f. fn. a0 a1 a2. fn (ring a0 a1 a2) = f a0 a1 a2
   
   [<a name="ring_accessors-val"><b>ring_accessors</b></a>]  Theorem
      
       (f m m0. (ring f m m0).carrier = f) 
        (f m m0. (ring f m m0).sum = m)  f m m0. (ring f m m0).prod = m0
   
   [<a name="ring_accfupds-val"><b>ring_accfupds</b></a>]  Theorem
      
       (r f. (r with sum updated_by f).carrier = R) 
        (r f. (r with prod updated_by f).carrier = R) 
        (r f. (r with carrier updated_by f).sum = r.sum) 
        (r f. (r with prod updated_by f).sum = r.sum) 
        (r f. (r with carrier updated_by f).prod = r.prod) 
        (r f. (r with sum updated_by f).prod = r.prod) 
        (r f. (r with carrier updated_by f).carrier = f R) 
        (r f. (r with sum updated_by f).sum = f r.sum) 
        r f. (r with prod updated_by f).prod = f r.prod
   
   [<a name="ring_add_abelian_group-val"><b>ring_add_abelian_group</b></a>]  Theorem
      
       r. Ring r  AbelianGroup r.sum
   
   [<a name="ring_add_assoc-val"><b>ring_add_assoc</b></a>]  Theorem
      
       r. Ring r 
            x y z. x  R  y  R  z  R  x + y + z = x + (y + z)
   
   [<a name="ring_add_assoc_comm-val"><b>ring_add_assoc_comm</b></a>]  Theorem
      
       r. Ring r 
            x y z. x  R  y  R  z  R  x + (y + z) = y + (x + z)
   
   [<a name="ring_add_char_2-val"><b>ring_add_char_2</b></a>]  Theorem
      
       r. Ring r  char r = 2  x y. x  R  y  R  x + y = x  y
   
   [<a name="ring_add_comm-val"><b>ring_add_comm</b></a>]  Theorem
      
       r. Ring r  x y. x  R  y  R  x + y = y + x
   
   [<a name="ring_add_element-val"><b>ring_add_element</b></a>]  Theorem
      
       r. Ring r  x y. x  R  y  R  x + y  R
   
   [<a name="ring_add_eq_zero-val"><b>ring_add_eq_zero</b></a>]  Theorem
      
       r. Ring r  x y. x  R  y  R  (x + y = #0  y = -x)
   
   [<a name="ring_add_exp_eqn-val"><b>ring_add_exp_eqn</b></a>]  Theorem
      
       r. Ring r  x. x  R  n. r.sum.exp x n = x * ##n
   
   [<a name="ring_add_group-val"><b>ring_add_group</b></a>]  Theorem
      
       r. Ring r 
            Group r.sum  r.sum.carrier = R 
            x y. x  R  y  R  x + y = y + x
   
   [<a name="ring_add_group_rwt-val"><b>ring_add_group_rwt</b></a>]  Theorem
      
       r. Ring r  Group r.sum  r.sum.carrier = R
   
   [<a name="ring_add_lcancel-val"><b>ring_add_lcancel</b></a>]  Theorem
      
       r. Ring r 
            x y z. x  R  y  R  z  R  (x + y = x + z  y = z)
   
   [<a name="ring_add_lneg-val"><b>ring_add_lneg</b></a>]  Theorem
      
       r. Ring r  x. x  R  -x + x = #0
   
   [<a name="ring_add_lneg_assoc-val"><b>ring_add_lneg_assoc</b></a>]  Theorem
      
       r. Ring r 
            x y. x  R  y  R  y = x + (-x + y)  y = -x + (x + y)
   
   [<a name="ring_add_lzero-val"><b>ring_add_lzero</b></a>]  Theorem
      
       r. Ring r  x. x  R  #0 + x = x
   
   [<a name="ring_add_pair_sub-val"><b>ring_add_pair_sub</b></a>]  Theorem
      
       r. Ring r 
            x y p q.
              x  R  y  R  p  R  q  R 
              x + y  (p + q) = x  p + (y  q)
   
   [<a name="ring_add_rcancel-val"><b>ring_add_rcancel</b></a>]  Theorem
      
       r. Ring r 
            x y z. x  R  y  R  z  R  (y + x = z + x  y = z)
   
   [<a name="ring_add_rneg-val"><b>ring_add_rneg</b></a>]  Theorem
      
       r. Ring r  x. x  R  x + -x = #0
   
   [<a name="ring_add_rneg_assoc-val"><b>ring_add_rneg_assoc</b></a>]  Theorem
      
       r. Ring r  x y. x  R  y  R  y = y + -x + x  y = y + x + -x
   
   [<a name="ring_add_rzero-val"><b>ring_add_rzero</b></a>]  Theorem
      
       r. Ring r  x. x  R  x + #0 = x
   
   [<a name="ring_add_sub-val"><b>ring_add_sub</b></a>]  Theorem
      
       r. Ring r  x y. x  R  y  R  x + y  y = x
   
   [<a name="ring_add_sub_assoc-val"><b>ring_add_sub_assoc</b></a>]  Theorem
      
       r. Ring r 
            x y z. x  R  y  R  z  R  x + y  z = x + (y  z)
   
   [<a name="ring_add_sub_comm-val"><b>ring_add_sub_comm</b></a>]  Theorem
      
       r. Ring r  x y. x  R  y  R  y + x  y = x
   
   [<a name="ring_add_sub_identity-val"><b>ring_add_sub_identity</b></a>]  Theorem
      
       r. Ring r 
            x y z t.
              x  R  y  R  z  R  t  R 
              (x + y = z + t  x  z = t  y)
   
   [<a name="ring_add_zero_zero-val"><b>ring_add_zero_zero</b></a>]  Theorem
      
       r. Ring r  #0 + #0 = #0
   
   [<a name="ring_associates_divides-val"><b>ring_associates_divides</b></a>]  Theorem
      
       r p q x. Ring r  rassoc p q  q  R  p rdivides x  q rdivides x
   
   [<a name="ring_associates_mult-val"><b>ring_associates_mult</b></a>]  Theorem
      
       r p q x.
          Ring r  p  R  q  R  x  R  rassoc p q 
          rassoc (x * p) (x * q)
   
   [<a name="ring_associates_refl-val"><b>ring_associates_refl</b></a>]  Theorem
      
       r x. Ring r  x  R  rassoc x x
   
   [<a name="ring_associates_sym-val"><b>ring_associates_sym</b></a>]  Theorem
      
       r p q. Ring r  q  R  rassoc p q  rassoc q p
   
   [<a name="ring_associates_trans-val"><b>ring_associates_trans</b></a>]  Theorem
      
       r x y z. Ring r  z  R  rassoc x y  rassoc y z  rassoc x z
   
   [<a name="ring_auto_I-val"><b>ring_auto_I</b></a>]  Theorem
      
       r. RingAuto I r
   
   [<a name="ring_auto_bij-val"><b>ring_auto_bij</b></a>]  Theorem
      
       r f. Ring r  RingAuto f r  f PERMUTES R
   
   [<a name="ring_auto_cong-val"><b>ring_auto_cong</b></a>]  Theorem
      
       r f1 f2.
          Ring r  (x. x  R  f1 x = f2 x) 
          (RingAuto f1 r  RingAuto f2 r)
   
   [<a name="ring_auto_element-val"><b>ring_auto_element</b></a>]  Theorem
      
       r f. RingAuto f r  x. x  R  f x  R
   
   [<a name="ring_auto_ids-val"><b>ring_auto_ids</b></a>]  Theorem
      
       r f. Ring r  RingAuto f r  f #0 = #0  f #1 = #1
   
   [<a name="ring_auto_linv_auto-val"><b>ring_auto_linv_auto</b></a>]  Theorem
      
       r f. Ring r  RingAuto f r  RingAuto (LINV f R) r
   
   [<a name="ring_auto_one-val"><b>ring_auto_one</b></a>]  Theorem
      
       r f. Ring r  RingAuto f r  f #1 = #1
   
   [<a name="ring_auto_zero-val"><b>ring_auto_zero</b></a>]  Theorem
      
       r f. Ring r  RingAuto f r  f #0 = #0
   
   [<a name="ring_binomial_2-val"><b>ring_binomial_2</b></a>]  Theorem
      
       r. Ring r 
            x y.
              x  R  y  R 
              (x + y) ** 2 = x ** 2 + ##2 * (x * y) + y ** 2
   
   [<a name="ring_binomial_3-val"><b>ring_binomial_3</b></a>]  Theorem
      
       r. Ring r 
            x y.
              x  R  y  R 
              (x + y) ** 3 =
              x ** 3 + ##3 * (x ** 2 * y) + ##3 * (x * y ** 2) + y ** 3
   
   [<a name="ring_binomial_4-val"><b>ring_binomial_4</b></a>]  Theorem
      
       r. Ring r 
            x y.
              x  R  y  R 
              (x + y) ** 4 =
              x ** 4 + ##4 * (x ** 3 * y) + ##6 * (x ** 2 * y ** 2) +
              ##4 * (x * y ** 3) + y ** 4
   
   [<a name="ring_binomial_genlist_index_shift-val"><b>ring_binomial_genlist_index_shift</b></a>]  Theorem
      
       r. Ring r 
            x y.
              x  R  y  R 
              n. GENLIST
                    ((k. ##(binomial n k) * x ** SUC (n  k) * y ** k) 
                     SUC) n =
                  GENLIST
                    (k. ##(binomial n (SUC k)) * x ** (n  k) * y ** SUC k)
                    n
   
   [<a name="ring_binomial_index_shift-val"><b>ring_binomial_index_shift</b></a>]  Theorem
      
       r. Ring r 
            x y.
              x  R  y  R 
              n. (k. ##(binomial (SUC n) k) * x ** (SUC n  k) * y ** k) 
                  SUC =
                  (k.
                       ##(binomial (SUC n) (SUC k)) * x ** (n  k) *
                       y ** SUC k)
   
   [<a name="ring_binomial_term_merge_x-val"><b>ring_binomial_term_merge_x</b></a>]  Theorem
      
       r. Ring r 
            x y.
              x  R  y  R 
              n. (k. x * k) 
                  (k. ##(binomial n k) * x ** (n  k) * y ** k) =
                  (k. ##(binomial n k) * x ** SUC (n  k) * y ** k)
   
   [<a name="ring_binomial_term_merge_y-val"><b>ring_binomial_term_merge_y</b></a>]  Theorem
      
       r. Ring r 
            x y.
              x  R  y  R 
              n. (k. y * k) 
                  (k. ##(binomial n k) * x ** (n  k) * y ** k) =
                  (k. ##(binomial n k) * x ** (n  k) * y ** SUC k)
   
   [<a name="ring_binomial_thm-val"><b>ring_binomial_thm</b></a>]  Theorem
      
       r. Ring r 
            x y.
              x  R  y  R 
              n. (x + y) ** n =
                  rsum
                    (GENLIST (k. ##(binomial n k) * x ** (n  k) * y ** k)
                       (SUC n))
   
   [<a name="ring_carrier_nonempty-val"><b>ring_carrier_nonempty</b></a>]  Theorem
      
       r. Ring r  R  
   
   [<a name="ring_carriers-val"><b>ring_carriers</b></a>]  Theorem
      
       r. Ring r  r.sum.carrier = R  r.prod.carrier = R
   
   [<a name="ring_case_cong-val"><b>ring_case_cong</b></a>]  Theorem
      
       M M' f.
          M = M' 
          (a0 a1 a2. M' = ring a0 a1 a2  f a0 a1 a2 = f' a0 a1 a2) 
          ring_CASE M f = ring_CASE M' f'
   
   [<a name="ring_case_eq-val"><b>ring_case_eq</b></a>]  Theorem
      
       ring_CASE x f = v  f' m m0. x = ring f' m m0  f f' m m0 = v
   
   [<a name="ring_char_0-val"><b>ring_char_0</b></a>]  Theorem
      
       r. Ring r  char r = 0  INFINITE R
   
   [<a name="ring_char_1-val"><b>ring_char_1</b></a>]  Theorem
      
       r. Ring r  char r = 1  R = {#0}
   
   [<a name="ring_char_2_double-val"><b>ring_char_2_double</b></a>]  Theorem
      
       r. Ring r  char r = 2  x. x  R  x + x = #0
   
   [<a name="ring_char_2_neg_one-val"><b>ring_char_2_neg_one</b></a>]  Theorem
      
       r. Ring r  char r = 2  -#1 = #1
   
   [<a name="ring_char_2_property-val"><b>ring_char_2_property</b></a>]  Theorem
      
       r. Ring r  char r = 2  #1 + #1 = #0
   
   [<a name="ring_char_alt-val"><b>ring_char_alt</b></a>]  Theorem
      
       r. Ring r 
            n. 0 &lt; n 
                (char r = n  ##n = #0  m. 0 &lt; m  m &lt; n  ##m  #0)
   
   [<a name="ring_char_divides-val"><b>ring_char_divides</b></a>]  Theorem
      
       r. Ring r  n. ##n = #0  char r divides n
   
   [<a name="ring_char_eq_1-val"><b>ring_char_eq_1</b></a>]  Theorem
      
       r. Ring r  (char r = 1  #1 = #0)
   
   [<a name="ring_char_prime-val"><b>ring_char_prime</b></a>]  Theorem
      
       r. Ring r 
            (prime (char r) 
             1 &lt; char r 
             k. 0 &lt; k  k &lt; char r  ##(binomial (char r) k) = #0)
   
   [<a name="ring_char_prime_endo-val"><b>ring_char_prime_endo</b></a>]  Theorem
      
       r. Ring r  prime (char r)  RingEndo (x. x ** char r) r
   
   [<a name="ring_component_equality-val"><b>ring_component_equality</b></a>]  Theorem
      
       r1 r2.
          r1 = r2 
          r1.carrier = r2.carrier  r1.sum = r2.sum  r1.prod = r2.prod
   
   [<a name="ring_divides_associates-val"><b>ring_divides_associates</b></a>]  Theorem
      
       r x y p.
          Ring r  rassoc x y  p  R  y  R  p rdivides x  p rdivides y
   
   [<a name="ring_divides_by_one-val"><b>ring_divides_by_one</b></a>]  Theorem
      
       r. Ring r  p. p  R  #1 rdivides p
   
   [<a name="ring_divides_by_unit-val"><b>ring_divides_by_unit</b></a>]  Theorem
      
       r. Ring r  p t. p  R  unit t  t rdivides p
   
   [<a name="ring_divides_iso-val"><b>ring_divides_iso</b></a>]  Theorem
      
       r r_ f.
          (r =r= r_) f 
          p q. p  R  p rdivides q  ring_divides r_ (f p) (f q)
   
   [<a name="ring_divides_le-val"><b>ring_divides_le</b></a>]  Theorem
      
       r f.
          EuclideanRing r f  ring_ordering r f 
          p q. p  R  q  R  p  #0  q rdivides p  f q  f p
   
   [<a name="ring_divides_refl-val"><b>ring_divides_refl</b></a>]  Theorem
      
       r. Ring r  p. p  R  p rdivides p
   
   [<a name="ring_divides_trans-val"><b>ring_divides_trans</b></a>]  Theorem
      
       r. Ring r 
            p q t.
              p  R  q  R  t  R  p rdivides q  q rdivides t 
              p rdivides t
   
   [<a name="ring_divides_zero-val"><b>ring_divides_zero</b></a>]  Theorem
      
       r. Ring r  p. p  R  p rdivides #0
   
   [<a name="ring_eq_unit_eq-val"><b>ring_eq_unit_eq</b></a>]  Theorem
      
       r. Ring r  x y. x  R  y  R  x = y  x =~ y
   
   [<a name="ring_exp_0-val"><b>ring_exp_0</b></a>]  Theorem
      
       x. x ** 0 = #1
   
   [<a name="ring_exp_1-val"><b>ring_exp_1</b></a>]  Theorem
      
       r. Ring r  x. x  R  x ** 1 = x
   
   [<a name="ring_exp_SUC-val"><b>ring_exp_SUC</b></a>]  Theorem
      
       x n. x ** SUC n = x * x ** n
   
   [<a name="ring_exp_add-val"><b>ring_exp_add</b></a>]  Theorem
      
       r. Ring r  x. x  R  n k. x ** (n + k) = x ** n * x ** k
   
   [<a name="ring_exp_add_assoc-val"><b>ring_exp_add_assoc</b></a>]  Theorem
      
       r. Ring r 
            x y.
              x  R  y  R 
              n k. x ** n * (x ** k * y) = x ** (n + k) * y
   
   [<a name="ring_exp_comm-val"><b>ring_exp_comm</b></a>]  Theorem
      
       r. Ring r  x. x  R  n. x ** n * x = x * x ** n
   
   [<a name="ring_exp_element-val"><b>ring_exp_element</b></a>]  Theorem
      
       r. Ring r  x. x  R  n. x ** n  R
   
   [<a name="ring_exp_mod_order-val"><b>ring_exp_mod_order</b></a>]  Theorem
      
       r. Ring r 
            x. x  R  0 &lt; order r.prod x 
                n. x ** n = x ** (n MOD order r.prod x)
   
   [<a name="ring_exp_mult-val"><b>ring_exp_mult</b></a>]  Theorem
      
       r. Ring r  x. x  R  n k. x ** (n * k) = (x ** n) ** k
   
   [<a name="ring_exp_mult_comm-val"><b>ring_exp_mult_comm</b></a>]  Theorem
      
       r. Ring r  x. x  R  m n. (x ** m) ** n = (x ** n) ** m
   
   [<a name="ring_exp_neg-val"><b>ring_exp_neg</b></a>]  Theorem
      
       r. Ring r 
            x. x  R  n. -x ** n = if EVEN n then x ** n else -(x ** n)
   
   [<a name="ring_exp_small-val"><b>ring_exp_small</b></a>]  Theorem
      
       r. Ring r 
            x. x  R 
                x ** 0 = #1  x ** 1 = x  x ** 2 = x * x 
                x ** 3 = x * x ** 2  x ** 4 = x * x ** 3 
                x ** 5 = x * x ** 4  x ** 6 = x * x ** 5 
                x ** 7 = x * x ** 6  x ** 8 = x * x ** 7 
                x ** 9 = x * x ** 8
   
   [<a name="ring_exp_suc-val"><b>ring_exp_suc</b></a>]  Theorem
      
       r. Ring r  x. x  R  n. x ** SUC n = x ** n * x
   
   [<a name="ring_factor_multiple-val"><b>ring_factor_multiple</b></a>]  Theorem
      
       r. Ring r 
            p q.
              p  R  q  R  (k. k  R  p = k * q) 
              z. z  R  (s. s  R  z = s * p)  t. t  R  z = t * q
   
   [<a name="ring_fermat_all-val"><b>ring_fermat_all</b></a>]  Theorem
      
       r. Ring r  prime (char r)  n k. ##n ** char r ** k = ##n
   
   [<a name="ring_fermat_thm-val"><b>ring_fermat_thm</b></a>]  Theorem
      
       r. Ring r  prime (char r)  n. ##n ** char r = ##n
   
   [<a name="ring_first_isomorphism_thm-val"><b>ring_first_isomorphism_thm</b></a>]  Theorem
      
       r r_ f.
          (r ~r~ r_) f 
          (let
             i = kernel_ideal f r r_
           in
             i &lt;&lt; r  ring_homo_image f r r_  r_ 
             RingIso (f  gen) (r / i) (ring_homo_image f r r_))
   
   [<a name="ring_fn_updates-val"><b>ring_fn_updates</b></a>]  Theorem
      
       (f0 f m m0.
           ring f m m0 with carrier updated_by f0 = ring (f0 f) m m0) 
        (f0 f m m0. ring f m m0 with sum updated_by f0 = ring f (f0 m) m0) 
        f0 f m m0. ring f m m0 with prod updated_by f0 = ring f m (f0 m0)
   
   [<a name="ring_freshman_all-val"><b>ring_freshman_all</b></a>]  Theorem
      
       r. Ring r  prime (char r) 
            x y.
              x  R  y  R 
              n. (x + y) ** char r ** n =
                  x ** char r ** n + y ** char r ** n
   
   [<a name="ring_freshman_all_sub-val"><b>ring_freshman_all_sub</b></a>]  Theorem
      
       r. Ring r  prime (char r) 
            x y.
              x  R  y  R 
              n. (x  y) ** char r ** n =
                  x ** char r ** n  y ** char r ** n
   
   [<a name="ring_freshman_thm-val"><b>ring_freshman_thm</b></a>]  Theorem
      
       r. Ring r  prime (char r) 
            x y.
              x  R  y  R  (x + y) ** char r = x ** char r + y ** char r
   
   [<a name="ring_freshman_thm_sub-val"><b>ring_freshman_thm_sub</b></a>]  Theorem
      
       r. Ring r  prime (char r) 
            x y.
              x  R  y  R  (x  y) ** char r = x ** char r  y ** char r
   
   [<a name="ring_fun_add-val"><b>ring_fun_add</b></a>]  Theorem
      
       r. Ring r  a b. rfun a  rfun b  rfun (k. a k + b k)
   
   [<a name="ring_fun_from_ring_fun-val"><b>ring_fun_from_ring_fun</b></a>]  Theorem
      
       r. Ring r  f. rfun f  x. x  R  rfun (j. f j * x ** j)
   
   [<a name="ring_fun_from_ring_fun_exp-val"><b>ring_fun_from_ring_fun_exp</b></a>]  Theorem
      
       r. Ring r 
            f. rfun f  x. x  R  n. rfun (j. (f j * x ** j) ** n)
   
   [<a name="ring_fun_genlist-val"><b>ring_fun_genlist</b></a>]  Theorem
      
       f. rfun f  n. rlist (GENLIST f n)
   
   [<a name="ring_fun_map-val"><b>ring_fun_map</b></a>]  Theorem
      
       f l. rfun f  rlist (MAP f l)
   
   [<a name="ring_fupdcanon-val"><b>ring_fupdcanon</b></a>]  Theorem
      
       (r g f.
           r with &lt;|sum updated_by f; carrier updated_by g|&gt; =
           r with &lt;|carrier updated_by g; sum updated_by f|&gt;) 
        (r g f.
           r with &lt;|prod updated_by f; carrier updated_by g|&gt; =
           r with &lt;|carrier updated_by g; prod updated_by f|&gt;) 
        r g f.
          r with &lt;|prod updated_by f; sum updated_by g|&gt; =
          r with &lt;|sum updated_by g; prod updated_by f|&gt;
   
   [<a name="ring_fupdcanon_comp-val"><b>ring_fupdcanon_comp</b></a>]  Theorem
      
       ((g f. sum_fupd f  carrier_fupd g = carrier_fupd g  sum_fupd f) 
         h g f.
           sum_fupd f  carrier_fupd g  h =
           carrier_fupd g  sum_fupd f  h) 
        ((g f. prod_fupd f  carrier_fupd g = carrier_fupd g  prod_fupd f) 
         h g f.
           prod_fupd f  carrier_fupd g  h =
           carrier_fupd g  prod_fupd f  h) 
        (g f. prod_fupd f  sum_fupd g = sum_fupd g  prod_fupd f) 
        h g f. prod_fupd f  sum_fupd g  h = sum_fupd g  prod_fupd f  h
   
   [<a name="ring_fupdfupds-val"><b>ring_fupdfupds</b></a>]  Theorem
      
       (r g f.
           r with &lt;|carrier updated_by f; carrier updated_by g|&gt; =
           r with carrier updated_by f  g) 
        (r g f.
           r with &lt;|sum updated_by f; sum updated_by g|&gt; =
           r with sum updated_by f  g) 
        r g f.
          r with &lt;|prod updated_by f; prod updated_by g|&gt; =
          r with prod updated_by f  g
   
   [<a name="ring_fupdfupds_comp-val"><b>ring_fupdfupds_comp</b></a>]  Theorem
      
       ((g f. carrier_fupd f  carrier_fupd g = carrier_fupd (f  g)) 
         h g f.
           carrier_fupd f  carrier_fupd g  h = carrier_fupd (f  g)  h) 
        ((g f. sum_fupd f  sum_fupd g = sum_fupd (f  g)) 
         h g f. sum_fupd f  sum_fupd g  h = sum_fupd (f  g)  h) 
        (g f. prod_fupd f  prod_fupd g = prod_fupd (f  g)) 
        h g f. prod_fupd f  prod_fupd g  h = prod_fupd (f  g)  h
   
   [<a name="ring_gcd_divides-val"><b>ring_gcd_divides</b></a>]  Theorem
      
       r f.
          EuclideanRing r f 
          p q. p  R  q  R  rgcd p q rdivides p  rgcd p q rdivides q
   
   [<a name="ring_gcd_element-val"><b>ring_gcd_element</b></a>]  Theorem
      
       r f. EuclideanRing r f  p q. p  R  q  R  rgcd p q  R
   
   [<a name="ring_gcd_is_gcd-val"><b>ring_gcd_is_gcd</b></a>]  Theorem
      
       r f.
          EuclideanRing r f 
          p q.
            p  R  q  R 
            rgcd p q rdivides p  rgcd p q rdivides q 
            d. d  R  d rdivides p  d rdivides q  d rdivides rgcd p q
   
   [<a name="ring_gcd_linear-val"><b>ring_gcd_linear</b></a>]  Theorem
      
       r f.
          EuclideanRing r f 
          p q.
            p  R  q  R  a b. a  R  b  R  rgcd p q = a * p + b * q
   
   [<a name="ring_gcd_property-val"><b>ring_gcd_property</b></a>]  Theorem
      
       r f.
          EuclideanRing r f 
          p q.
            p  R  q  R 
            d. d  R  d rdivides p  d rdivides q  d rdivides rgcd p q
   
   [<a name="ring_gcd_sym-val"><b>ring_gcd_sym</b></a>]  Theorem
      
       r f. EuclideanRing r f  p q. p  R  q  R  rgcd p q = rgcd q p
   
   [<a name="ring_gcd_zero-val"><b>ring_gcd_zero</b></a>]  Theorem
      
       r f p. rgcd p #0 = p  rgcd #0 p = p
   
   [<a name="ring_homo_I_refl-val"><b>ring_homo_I_refl</b></a>]  Theorem
      
       r. RingHomo I r r
   
   [<a name="ring_homo_add-val"><b>ring_homo_add</b></a>]  Theorem
      
       r r_ f.
          (r ~r~ r_) f  x y. x  R  y  R  f (x + y) = f x +_ f y
   
   [<a name="ring_homo_char_divides-val"><b>ring_homo_char_divides</b></a>]  Theorem
      
       r r_ f. (r ~r~ r_) f  char r_ divides char r
   
   [<a name="ring_homo_compose-val"><b>ring_homo_compose</b></a>]  Theorem
      
       r s t f1 f2.
          RingHomo f1 r s  RingHomo f2 s t  RingHomo (f2  f1) r t
   
   [<a name="ring_homo_cong-val"><b>ring_homo_cong</b></a>]  Theorem
      
       r r_ f1 f2.
          Ring r  Ring r_  (x. x  R  f1 x = f2 x) 
          (RingHomo f1 r r_  RingHomo f2 r r_)
   
   [<a name="ring_homo_element-val"><b>ring_homo_element</b></a>]  Theorem
      
       r r_ f. RingHomo f r r_  x. x  R  f x  R_
   
   [<a name="ring_homo_eq_zero-val"><b>ring_homo_eq_zero</b></a>]  Theorem
      
       r r_ f.
          (r ~r~ r_) f  INJ f R R_  x. x  R  (f x = #0_  x = #0)
   
   [<a name="ring_homo_exp-val"><b>ring_homo_exp</b></a>]  Theorem
      
       r r_ f. (r ~r~ r_) f  x. x  R  n. f (x ** n) = f x **_ n
   
   [<a name="ring_homo_ideal_group-val"><b>ring_homo_ideal_group</b></a>]  Theorem
      
       r s f. (r ~r~ s) f  i. i &lt;&lt; r  Group (homo_ideal f r s i).sum
   
   [<a name="ring_homo_ideal_ideal-val"><b>ring_homo_ideal_ideal</b></a>]  Theorem
      
       r s f.
          Ring r  Ring s  RingHomo f r s  SURJ f R s.carrier 
          i. i &lt;&lt; r  homo_ideal f r s i &lt;&lt; s
   
   [<a name="ring_homo_ideal_subgroup-val"><b>ring_homo_ideal_subgroup</b></a>]  Theorem
      
       r s f. (r ~r~ s) f  i. i &lt;&lt; r  (homo_ideal f r s i).sum  s.sum
   
   [<a name="ring_homo_ids-val"><b>ring_homo_ids</b></a>]  Theorem
      
       r r_ f. (r ~r~ r_) f  f #0 = #0_  f #1 = #1_
   
   [<a name="ring_homo_image_bij-val"><b>ring_homo_image_bij</b></a>]  Theorem
      
       r r_ f.
          (r ~r~ r_) f  INJ f R R_ 
          BIJ f R (ring_homo_image f r r_).carrier
   
   [<a name="ring_homo_image_carrier-val"><b>ring_homo_image_carrier</b></a>]  Theorem
      
       r r_ f. (ring_homo_image f r r_).carrier = IMAGE f R
   
   [<a name="ring_homo_image_homo-val"><b>ring_homo_image_homo</b></a>]  Theorem
      
       r r_ f. (r ~r~ r_) f  RingHomo f r (ring_homo_image f r r_)
   
   [<a name="ring_homo_image_is_subring-val"><b>ring_homo_image_is_subring</b></a>]  Theorem
      
       r r_ f. (r ~r~ r_) f  subring (ring_homo_image f r r_) r_
   
   [<a name="ring_homo_image_iso-val"><b>ring_homo_image_iso</b></a>]  Theorem
      
       r r_ f.
          (r ~r~ r_) f  INJ f R R_  RingIso f r (ring_homo_image f r r_)
   
   [<a name="ring_homo_image_ring-val"><b>ring_homo_image_ring</b></a>]  Theorem
      
       r r_ f. (r ~r~ r_) f  Ring (ring_homo_image f r r_)
   
   [<a name="ring_homo_image_subring-val"><b>ring_homo_image_subring</b></a>]  Theorem
      
       r r_ f. (r ~r~ r_) f  ring_homo_image f r r_  r_
   
   [<a name="ring_homo_image_subring_subring-val"><b>ring_homo_image_subring_subring</b></a>]  Theorem
      
       r r_ f.
          (r ~r~ r_) f 
          s. Ring s  subring s r  subring (ring_homo_image f s r_) r_
   
   [<a name="ring_homo_image_surj_property-val"><b>ring_homo_image_surj_property</b></a>]  Theorem
      
       r r_ f.
          Ring r  Ring r_  SURJ f R R_ 
          RingIso I r_ (ring_homo_image f r r_)
   
   [<a name="ring_homo_inv-val"><b>ring_homo_inv</b></a>]  Theorem
      
       r r_ f. (r ~r~ r_) f  x. unit x  f ( |/ x) = |/_ (f x)
   
   [<a name="ring_homo_kernel_ideal-val"><b>ring_homo_kernel_ideal</b></a>]  Theorem
      
       f r s. (r ~r~ s) f  kernel_ideal f r s &lt;&lt; r
   
   [<a name="ring_homo_linv_homo-val"><b>ring_homo_linv_homo</b></a>]  Theorem
      
       r r_ f. (r ~r~ r_) f  BIJ f R R_  RingHomo (LINV f R) r_ r
   
   [<a name="ring_homo_mult-val"><b>ring_homo_mult</b></a>]  Theorem
      
       r r_ f.
          (r ~r~ r_) f  x y. x  R  y  R  f (x * y) = f x *_ f y
   
   [<a name="ring_homo_neg-val"><b>ring_homo_neg</b></a>]  Theorem
      
       r r_ f. (r ~r~ r_) f  x. x  R  f (-x) = $-_ (f x)
   
   [<a name="ring_homo_num-val"><b>ring_homo_num</b></a>]  Theorem
      
       r r_ f. (r ~r~ r_) f  n. f (##n) = ##_ #1_ n
   
   [<a name="ring_homo_num_nonzero-val"><b>ring_homo_num_nonzero</b></a>]  Theorem
      
       r r_ f.
          (r ~r~ r_) f  c. 0 &lt; c  c &lt; char r_  ##c  #0  f (##c)  #0_
   
   [<a name="ring_homo_one-val"><b>ring_homo_one</b></a>]  Theorem
      
       r r_ f. (r ~r~ r_) f  f #1 = #1_
   
   [<a name="ring_homo_one_eq_zero-val"><b>ring_homo_one_eq_zero</b></a>]  Theorem
      
       r r_ f. (r ~r~ r_) f  #1 = #0  #1_ = #0_
   
   [<a name="ring_homo_property-val"><b>ring_homo_property</b></a>]  Theorem
      
       r r_ f.
          Ring r  RingHomo f r r_ 
          x y.
            x  R  y  R  f (x + y) = f x +_ f y  f (x * y) = f x *_ f y
   
   [<a name="ring_homo_ring_homo_subring-val"><b>ring_homo_ring_homo_subring</b></a>]  Theorem
      
       r r_ f. (r ~r~ r_) f  subring (ring_homo_image f r r_) r_
   
   [<a name="ring_homo_sub-val"><b>ring_homo_sub</b></a>]  Theorem
      
       r r_ f.
          (r ~r~ r_) f  x y. x  R  y  R  f (x  y) = f x -_ f y
   
   [<a name="ring_homo_subring_homo-val"><b>ring_homo_subring_homo</b></a>]  Theorem
      
       r s r_ f. (r ~r~ r_) f  s  r  (s ~r~ ring_homo_image f s r_) f
   
   [<a name="ring_homo_sum_num_property-val"><b>ring_homo_sum_num_property</b></a>]  Theorem
      
       r r_ f.
          (r ~r~ r_) f 
          c. 0 &lt; c  c &lt; char r_  ##c  #0  ##_ #1_ c  #0_
   
   [<a name="ring_homo_sym-val"><b>ring_homo_sym</b></a>]  Theorem
      
       r r_ f. (r ~r~ r_) f  BIJ f R R_  RingHomo (LINV f R) r_ r
   
   [<a name="ring_homo_sym_any-val"><b>ring_homo_sym_any</b></a>]  Theorem
      
       Ring r  Ring s  RingHomo f r s 
        (x. x  s.carrier  i x  R  f (i x) = x) 
        (x. x  R  i (f x) = x) 
        RingHomo i s r
   
   [<a name="ring_homo_trans-val"><b>ring_homo_trans</b></a>]  Theorem
      
       r s t f1 f2.
          RingHomo f1 r s  RingHomo f2 s t  RingHomo (f2  f1) r t
   
   [<a name="ring_homo_unit-val"><b>ring_homo_unit</b></a>]  Theorem
      
       r r_ f. (r ~r~ r_) f  x. unit x  unit_ (f x)
   
   [<a name="ring_homo_unit_inv-val"><b>ring_homo_unit_inv</b></a>]  Theorem
      
       r r_ f. (r ~r~ r_) f  x. unit x  |/_ (f x) = f ( |/ x)
   
   [<a name="ring_homo_unit_inv_element-val"><b>ring_homo_unit_inv_element</b></a>]  Theorem
      
       r r_ f. (r ~r~ r_) f  x. unit x  |/_ (f x)  R_
   
   [<a name="ring_homo_unit_inv_nonzero-val"><b>ring_homo_unit_inv_nonzero</b></a>]  Theorem
      
       r r_ f. (r ~r~ r_) f  #1_  #0_  x. unit x  |/_ (f x)  #0_
   
   [<a name="ring_homo_unit_nonzero-val"><b>ring_homo_unit_nonzero</b></a>]  Theorem
      
       r r_ f. (r ~r~ r_) f  #1_  #0_  x. unit x  f x  #0_
   
   [<a name="ring_homo_zero-val"><b>ring_homo_zero</b></a>]  Theorem
      
       r r_ f. (r ~r~ r_) f  f #0 = #0_
   
   [<a name="ring_induction-val"><b>ring_induction</b></a>]  Theorem
      
       P. (f m m0. P (ring f m m0))  r. P r
   
   [<a name="ring_inj_image_alt-val"><b>ring_inj_image_alt</b></a>]  Theorem
      
       r f.
          Ring r 
          ring_inj_image r f =
          &lt;|carrier := IMAGE f R; sum := monoid_inj_image r.sum f;
            prod := monoid_inj_image r.prod f|&gt;
   
   [<a name="ring_inj_image_carrier-val"><b>ring_inj_image_carrier</b></a>]  Theorem
      
       r f. (ring_inj_image r f).carrier = IMAGE f R
   
   [<a name="ring_inj_image_prod_abelian_monoid-val"><b>ring_inj_image_prod_abelian_monoid</b></a>]  Theorem
      
       r f.
          Ring r  INJ f R (:)  AbelianMonoid (ring_inj_image r f).prod
   
   [<a name="ring_inj_image_prod_monoid-val"><b>ring_inj_image_prod_monoid</b></a>]  Theorem
      
       r f. Ring r  INJ f R (:)  Monoid (ring_inj_image r f).prod
   
   [<a name="ring_inj_image_prod_monoid_homo-val"><b>ring_inj_image_prod_monoid_homo</b></a>]  Theorem
      
       r f.
          Ring r  INJ f R (:) 
          MonoidHomo f r.prod (ring_inj_image r f).prod
   
   [<a name="ring_inj_image_ring-val"><b>ring_inj_image_ring</b></a>]  Theorem
      
       r f. Ring r  INJ f R (:)  Ring (ring_inj_image r f)
   
   [<a name="ring_inj_image_ring_homo-val"><b>ring_inj_image_ring_homo</b></a>]  Theorem
      
       r f. Ring r  INJ f R (:)  RingHomo f r (ring_inj_image r f)
   
   [<a name="ring_inj_image_sum_abelian_group-val"><b>ring_inj_image_sum_abelian_group</b></a>]  Theorem
      
       r f.
          Ring r  INJ f R (:)  AbelianGroup (ring_inj_image r f).sum
   
   [<a name="ring_inj_image_sum_group-val"><b>ring_inj_image_sum_group</b></a>]  Theorem
      
       r f. Ring r  INJ f R (:)  Group (ring_inj_image r f).sum
   
   [<a name="ring_inj_image_sum_group_homo-val"><b>ring_inj_image_sum_group_homo</b></a>]  Theorem
      
       r f.
          Ring r  INJ f R (:) 
          GroupHomo f r.sum (ring_inj_image r f).sum
   
   [<a name="ring_inj_image_sum_monoid-val"><b>ring_inj_image_sum_monoid</b></a>]  Theorem
      
       r f. Ring r  INJ f R (:)  Monoid (ring_inj_image r f).sum
   
   [<a name="ring_inv_one-val"><b>ring_inv_one</b></a>]  Theorem
      
       r. Ring r  |/ #1 = #1
   
   [<a name="ring_irreducible_gcd-val"><b>ring_irreducible_gcd</b></a>]  Theorem
      
       r f.
          EuclideanRing r f 
          p. p  R  atom p  q. q  R  unit (rgcd p q)  p rdivides q
   
   [<a name="ring_iso_I_refl-val"><b>ring_iso_I_refl</b></a>]  Theorem
      
       r. RingIso I r r
   
   [<a name="ring_iso_add-val"><b>ring_iso_add</b></a>]  Theorem
      
       r r_ f.
          (r =r= r_) f  x y. x  R  y  R  f (x + y) = f x +_ f y
   
   [<a name="ring_iso_bij-val"><b>ring_iso_bij</b></a>]  Theorem
      
       r r_ f. (r =r= r_) f  BIJ f R R_
   
   [<a name="ring_iso_card_eq-val"><b>ring_iso_card_eq</b></a>]  Theorem
      
       r r_ f. RingIso f r r_  FINITE R  CARD R = CARD R_
   
   [<a name="ring_iso_char_eq-val"><b>ring_iso_char_eq</b></a>]  Theorem
      
       r r_ f. (r =r= r_) f  char r_ = char r
   
   [<a name="ring_iso_compose-val"><b>ring_iso_compose</b></a>]  Theorem
      
       r s t f1 f2.
          RingIso f1 r s  RingIso f2 s t  RingIso (f2  f1) r t
   
   [<a name="ring_iso_cong-val"><b>ring_iso_cong</b></a>]  Theorem
      
       r r_ f1 f2.
          Ring r  Ring r_  (x. x  R  f1 x = f2 x) 
          (RingIso f1 r r_  RingIso f2 r r_)
   
   [<a name="ring_iso_element-val"><b>ring_iso_element</b></a>]  Theorem
      
       r r_ f. RingIso f r r_  x. x  R  f x  R_
   
   [<a name="ring_iso_element_unique-val"><b>ring_iso_element_unique</b></a>]  Theorem
      
       r r_ f. (r =r= r_) f  x y. x  R  y  R  (f x = f y  x = y)
   
   [<a name="ring_iso_eq_one-val"><b>ring_iso_eq_one</b></a>]  Theorem
      
       r r_ f. (r =r= r_) f  x. x  R  (f x = #1_  x = #1)
   
   [<a name="ring_iso_eq_zero-val"><b>ring_iso_eq_zero</b></a>]  Theorem
      
       r r_ f. (r =r= r_) f  x. x  R  (f x = #0_  x = #0)
   
   [<a name="ring_iso_exp-val"><b>ring_iso_exp</b></a>]  Theorem
      
       r r_ f. (r =r= r_) f  x. x  R  n. f (x ** n) = f x **_ n
   
   [<a name="ring_iso_ids-val"><b>ring_iso_ids</b></a>]  Theorem
      
       r r_ f. (r =r= r_) f  f #0 = #0_  f #1 = #1_
   
   [<a name="ring_iso_inv-val"><b>ring_iso_inv</b></a>]  Theorem
      
       r r_ f. (r =r= r_) f  x. unit x  f ( |/ x) = |/_ (f x)
   
   [<a name="ring_iso_inverse-val"><b>ring_iso_inverse</b></a>]  Theorem
      
       r r_ f. (r =r= r_) f  y. y  R_  x. x  R  y = f x
   
   [<a name="ring_iso_inverse_element-val"><b>ring_iso_inverse_element</b></a>]  Theorem
      
       r r_ f.
          (r =r= r_) f  y. y  R_  LINV f R y  R  y = f (LINV f R y)
   
   [<a name="ring_iso_linv_iso-val"><b>ring_iso_linv_iso</b></a>]  Theorem
      
       r r_ f. (r =r= r_) f  RingIso (LINV f R) r_ r
   
   [<a name="ring_iso_mult-val"><b>ring_iso_mult</b></a>]  Theorem
      
       r r_ f.
          (r =r= r_) f  x y. x  R  y  R  f (x * y) = f x *_ f y
   
   [<a name="ring_iso_neg-val"><b>ring_iso_neg</b></a>]  Theorem
      
       r r_ f. (r =r= r_) f  x. x  R  f (-x) = $-_ (f x)
   
   [<a name="ring_iso_nonzero-val"><b>ring_iso_nonzero</b></a>]  Theorem
      
       r r_ f. (r =r= r_) f  x. x  R+  f x  R+_
   
   [<a name="ring_iso_num-val"><b>ring_iso_num</b></a>]  Theorem
      
       r r_ f. (r =r= r_) f  n. f (##n) = ##_ #1_ n
   
   [<a name="ring_iso_one-val"><b>ring_iso_one</b></a>]  Theorem
      
       r r_ f. (r =r= r_) f  f #1 = #1_
   
   [<a name="ring_iso_property-val"><b>ring_iso_property</b></a>]  Theorem
      
       r r_ f.
          Ring r  RingIso f r r_ 
          x y.
            x  R  y  R  f (x + y) = f x +_ f y  f (x * y) = f x *_ f y
   
   [<a name="ring_iso_ring_homo_subring-val"><b>ring_iso_ring_homo_subring</b></a>]  Theorem
      
       r r_ f. (r =r= r_) f  subring (ring_homo_image f r r_) r_
   
   [<a name="ring_iso_sub-val"><b>ring_iso_sub</b></a>]  Theorem
      
       r r_ f.
          (r =r= r_) f  x y. x  R  y  R  f (x  y) = f x -_ f y
   
   [<a name="ring_iso_subring_iso-val"><b>ring_iso_subring_iso</b></a>]  Theorem
      
       r s r_ f. (r =r= r_) f  s  r  (s =r= ring_homo_image f s r_) f
   
   [<a name="ring_iso_sym-val"><b>ring_iso_sym</b></a>]  Theorem
      
       r r_ f. (r =r= r_) f  RingIso (LINV f R) r_ r
   
   [<a name="ring_iso_sym_any-val"><b>ring_iso_sym_any</b></a>]  Theorem
      
       Ring r  Ring s  RingIso f r s 
        (x. x  s.carrier  i x  R  f (i x) = x) 
        (x. x  R  i (f x) = x) 
        RingIso i s r
   
   [<a name="ring_iso_trans-val"><b>ring_iso_trans</b></a>]  Theorem
      
       r s t f1 f2.
          RingIso f1 r s  RingIso f2 s t  RingIso (f2  f1) r t
   
   [<a name="ring_iso_unit-val"><b>ring_iso_unit</b></a>]  Theorem
      
       r r_ f. (r =r= r_) f  x. unit x  unit_ (f x)
   
   [<a name="ring_iso_zero-val"><b>ring_iso_zero</b></a>]  Theorem
      
       r r_ f. (r =r= r_) f  f #0 = #0_
   
   [<a name="ring_list_SNOC-val"><b>ring_list_SNOC</b></a>]  Theorem
      
       x s. rlist (SNOC x s)  x  R  rlist s
   
   [<a name="ring_list_cons-val"><b>ring_list_cons</b></a>]  Theorem
      
       r h t. rlist (h::t)  h  R  rlist t
   
   [<a name="ring_list_from_genlist-val"><b>ring_list_from_genlist</b></a>]  Theorem
      
       r f. rfun f  n. rlist (GENLIST f n)
   
   [<a name="ring_list_from_genlist_ring_fun-val"><b>ring_list_from_genlist_ring_fun</b></a>]  Theorem
      
       r f. rfun f  n g. rlist (GENLIST (f  g) n)
   
   [<a name="ring_list_front_last-val"><b>ring_list_front_last</b></a>]  Theorem
      
       s. rlist (FRONT s)  LAST s  R  rlist s
   
   [<a name="ring_list_gen_from_ring_fun-val"><b>ring_list_gen_from_ring_fun</b></a>]  Theorem
      
       r. Ring r 
            f. rfun f 
                x. x  R  n. rlist (GENLIST (j. f j * x ** j) n)
   
   [<a name="ring_list_nil-val"><b>ring_list_nil</b></a>]  Theorem
      
       r. rlist []  T
   
   [<a name="ring_literal_11-val"><b>ring_literal_11</b></a>]  Theorem
      
       f1 m01 m1 f2 m02 m2.
          &lt;|carrier := f1; sum := m01; prod := m1|&gt; =
          &lt;|carrier := f2; sum := m02; prod := m2|&gt; 
          f1 = f2  m01 = m02  m1 = m2
   
   [<a name="ring_literal_nchotomy-val"><b>ring_literal_nchotomy</b></a>]  Theorem
      
       r. f m0 m. r = &lt;|carrier := f; sum := m0; prod := m|&gt;
   
   [<a name="ring_mult_abelian_monoid-val"><b>ring_mult_abelian_monoid</b></a>]  Theorem
      
       r. Ring r  AbelianMonoid r.prod
   
   [<a name="ring_mult_add-val"><b>ring_mult_add</b></a>]  Theorem
      
       r. Ring r 
            z y x.
              x  R  y  R  z  R 
              x * (y + z) = x * y + x * z  (y + z) * x = y * x + z * x
   
   [<a name="ring_mult_add_neg-val"><b>ring_mult_add_neg</b></a>]  Theorem
      
       r. Ring r 
            x. x  R 
                n. ##n * x + -x = if n = 0 then -x else ##(n  1) * x
   
   [<a name="ring_mult_add_neg_assoc-val"><b>ring_mult_add_neg_assoc</b></a>]  Theorem
      
       r. Ring r 
            x y.
              x  R  y  R 
              n. ##n * x + (-x + y) =
                  if n = 0 then -x + y else ##(n  1) * x + y
   
   [<a name="ring_mult_add_neg_mult-val"><b>ring_mult_add_neg_mult</b></a>]  Theorem
      
       r. Ring r 
            x. x  R 
                m n.
                  ##m * x + -(##n * x) =
                  if m &lt; n then -(##(n  m) * x) else ##(m  n) * x
   
   [<a name="ring_mult_add_neg_mult_assoc-val"><b>ring_mult_add_neg_mult_assoc</b></a>]  Theorem
      
       r. Ring r 
            x y.
              x  R  y  R 
              m n.
                ##m * x + (-(##n * x) + y) =
                if m &lt; n then -(##(n  m) * x) + y else ##(m  n) * x + y
   
   [<a name="ring_mult_assoc-val"><b>ring_mult_assoc</b></a>]  Theorem
      
       r. Ring r 
            x y z. x  R  y  R  z  R  x * y * z = x * (y * z)
   
   [<a name="ring_mult_assoc_comm-val"><b>ring_mult_assoc_comm</b></a>]  Theorem
      
       r. Ring r 
            x y z. x  R  y  R  z  R  x * (y * z) = y * (x * z)
   
   [<a name="ring_mult_comm-val"><b>ring_mult_comm</b></a>]  Theorem
      
       r. Ring r  x y. x  R  y  R  x * y = y * x
   
   [<a name="ring_mult_divides-val"><b>ring_mult_divides</b></a>]  Theorem
      
       r p q x.
          Ring r  p * q rdivides x  p  R  q  R 
          p rdivides x  q rdivides x
   
   [<a name="ring_mult_element-val"><b>ring_mult_element</b></a>]  Theorem
      
       r. Ring r  x y. x  R  y  R  x * y  R
   
   [<a name="ring_mult_exp-val"><b>ring_mult_exp</b></a>]  Theorem
      
       r. Ring r 
            x y. x  R  y  R  n. (x * y) ** n = x ** n * y ** n
   
   [<a name="ring_mult_ladd-val"><b>ring_mult_ladd</b></a>]  Theorem
      
       r. Ring r 
            x y z. x  R  y  R  z  R  (y + z) * x = y * x + z * x
   
   [<a name="ring_mult_lneg-val"><b>ring_mult_lneg</b></a>]  Theorem
      
       r. Ring r  x y. x  R  y  R  -x * y = -(x * y)
   
   [<a name="ring_mult_lone-val"><b>ring_mult_lone</b></a>]  Theorem
      
       r. Ring r  x. x  R  #1 * x = x
   
   [<a name="ring_mult_lsub-val"><b>ring_mult_lsub</b></a>]  Theorem
      
       r. Ring r 
            x y z. x  R  y  R  z  R  x * z  y * z = (x  y) * z
   
   [<a name="ring_mult_lzero-val"><b>ring_mult_lzero</b></a>]  Theorem
      
       r. Ring r  x. x  R  #0 * x = #0
   
   [<a name="ring_mult_monoid-val"><b>ring_mult_monoid</b></a>]  Theorem
      
       r. Ring r 
            Monoid r.prod  r.prod.carrier = R 
            x y. x  R  y  R  x * y = y * x
   
   [<a name="ring_mult_monoid_rwt-val"><b>ring_mult_monoid_rwt</b></a>]  Theorem
      
       r. Ring r  Monoid r.prod  r.prod.carrier = R
   
   [<a name="ring_mult_neg_neg-val"><b>ring_mult_neg_neg</b></a>]  Theorem
      
       r. Ring r  x y. x  R  y  R  -x * -y = x * y
   
   [<a name="ring_mult_one_one-val"><b>ring_mult_one_one</b></a>]  Theorem
      
       r. Ring r  #1 * #1 = #1
   
   [<a name="ring_mult_pair_diff-val"><b>ring_mult_pair_diff</b></a>]  Theorem
      
       r. Ring r 
            x y p q.
              x  R  y  R  p  R  q  R 
              x * y  p * q = (x  p) * y + p * (y  q)
   
   [<a name="ring_mult_pair_sub-val"><b>ring_mult_pair_sub</b></a>]  Theorem
      
       r. Ring r 
            x y p q.
              x  R  y  R  p  R  q  R 
              x * y  p * q = (x  p) * (y  q) + (x  p) * q + p * (y  q)
   
   [<a name="ring_mult_radd-val"><b>ring_mult_radd</b></a>]  Theorem
      
       r. Ring r 
            x y z. x  R  y  R  z  R  x * (y + z) = x * y + x * z
   
   [<a name="ring_mult_rneg-val"><b>ring_mult_rneg</b></a>]  Theorem
      
       r. Ring r  x y. x  R  y  R  x * -y = -(x * y)
   
   [<a name="ring_mult_rone-val"><b>ring_mult_rone</b></a>]  Theorem
      
       r. Ring r  x. x  R  x * #1 = x
   
   [<a name="ring_mult_rsub-val"><b>ring_mult_rsub</b></a>]  Theorem
      
       r. Ring r 
            x y z. x  R  y  R  z  R  x * y  x * z = x * (y  z)
   
   [<a name="ring_mult_rzero-val"><b>ring_mult_rzero</b></a>]  Theorem
      
       r. Ring r  x. x  R  x * #0 = #0
   
   [<a name="ring_mult_zero_zero-val"><b>ring_mult_zero_zero</b></a>]  Theorem
      
       r. Ring r  #0 * #0 = #0
   
   [<a name="ring_nchotomy-val"><b>ring_nchotomy</b></a>]  Theorem
      
       rr. f m m0. rr = ring f m m0
   
   [<a name="ring_neg_add-val"><b>ring_neg_add</b></a>]  Theorem
      
       r. Ring r  x y. x  R  y  R  -(x + y) = -x + -y
   
   [<a name="ring_neg_add_comm-val"><b>ring_neg_add_comm</b></a>]  Theorem
      
       r. Ring r  x y. x  R  y  R  -(x + y) = -y + -x
   
   [<a name="ring_neg_add_neg-val"><b>ring_neg_add_neg</b></a>]  Theorem
      
       r. Ring r  x. x  R  -x + -x = -(##2 * x)
   
   [<a name="ring_neg_add_neg_assoc-val"><b>ring_neg_add_neg_assoc</b></a>]  Theorem
      
       r. Ring r  x y. x  R  y  R  -x + (-x + y) = -(##2 * x) + y
   
   [<a name="ring_neg_add_neg_mult-val"><b>ring_neg_add_neg_mult</b></a>]  Theorem
      
       r. Ring r  x. x  R  n. -x + -(##n * x) = -(##(n + 1) * x)
   
   [<a name="ring_neg_add_neg_mult_assoc-val"><b>ring_neg_add_neg_mult_assoc</b></a>]  Theorem
      
       r. Ring r 
            x y.
              x  R  y  R 
              n. -x + (-(##n * x) + y) = -(##(n + 1) * x) + y
   
   [<a name="ring_neg_char_2-val"><b>ring_neg_char_2</b></a>]  Theorem
      
       r. Ring r  char r = 2  x. x  R  -x = x
   
   [<a name="ring_neg_element-val"><b>ring_neg_element</b></a>]  Theorem
      
       r. Ring r  x. x  R  -x  R
   
   [<a name="ring_neg_eq-val"><b>ring_neg_eq</b></a>]  Theorem
      
       r. Ring r  x y. x  R  y  R  (-x = -y  x = y)
   
   [<a name="ring_neg_eq_swap-val"><b>ring_neg_eq_swap</b></a>]  Theorem
      
       r. Ring r  x y. x  R  y  R  (-x = y  x = -y)
   
   [<a name="ring_neg_eq_zero-val"><b>ring_neg_eq_zero</b></a>]  Theorem
      
       r. Ring r  x. x  R  (-x = #0  x = #0)
   
   [<a name="ring_neg_exp-val"><b>ring_neg_exp</b></a>]  Theorem
      
       r. Ring r 
            x. x  R  n. -x ** n = if EVEN n then x ** n else -(x ** n)
   
   [<a name="ring_neg_mult-val"><b>ring_neg_mult</b></a>]  Theorem
      
       r. Ring r 
            x y. x  R  y  R  -(x * y) = -x * y  -(x * y) = x * -y
   
   [<a name="ring_neg_mult_add_neg_mult-val"><b>ring_neg_mult_add_neg_mult</b></a>]  Theorem
      
       r. Ring r 
            x. x  R  m n. -(##m * x) + -(##n * x) = -(##(m + n) * x)
   
   [<a name="ring_neg_mult_add_neg_mult_assoc-val"><b>ring_neg_mult_add_neg_mult_assoc</b></a>]  Theorem
      
       r. Ring r 
            x y.
              x  R  y  R 
              m n. -(##m * x) + (-(##n * x) + y) = -(##(m + n) * x) + y
   
   [<a name="ring_neg_neg-val"><b>ring_neg_neg</b></a>]  Theorem
      
       r. Ring r  x. x  R  --x = x
   
   [<a name="ring_neg_nonzero-val"><b>ring_neg_nonzero</b></a>]  Theorem
      
       r. Ring r  x. x  R+  -x  R+
   
   [<a name="ring_neg_one_eq_one-val"><b>ring_neg_one_eq_one</b></a>]  Theorem
      
       r. Ring r  #1  #0  (-#1 = #1  char r = 2)
   
   [<a name="ring_neg_square-val"><b>ring_neg_square</b></a>]  Theorem
      
       r. Ring r  x. x  R  -x ** 2 = x ** 2
   
   [<a name="ring_neg_sub-val"><b>ring_neg_sub</b></a>]  Theorem
      
       r. Ring r  x y. x  R  y  R  -(x  y) = y  x
   
   [<a name="ring_neg_zero-val"><b>ring_neg_zero</b></a>]  Theorem
      
       r. Ring r  -#0 = #0
   
   [<a name="ring_nonzero_element-val"><b>ring_nonzero_element</b></a>]  Theorem
      
       r x. x  R+  x  R
   
   [<a name="ring_nonzero_eq-val"><b>ring_nonzero_eq</b></a>]  Theorem
      
       r x. x  R+  x  R  x  #0
   
   [<a name="ring_nonzero_mult_carrier-val"><b>ring_nonzero_mult_carrier</b></a>]  Theorem
      
       r. Ring r  F* = R+
   
   [<a name="ring_num_0-val"><b>ring_num_0</b></a>]  Theorem
      
       r. ##0 = #0
   
   [<a name="ring_num_1-val"><b>ring_num_1</b></a>]  Theorem
      
       r. Ring r  ##1 = #1
   
   [<a name="ring_num_2-val"><b>ring_num_2</b></a>]  Theorem
      
       r. Ring r  ##2 = #1 + #1
   
   [<a name="ring_num_SUC-val"><b>ring_num_SUC</b></a>]  Theorem
      
       r. Ring r  n. ##(SUC n) = #1 + ##n
   
   [<a name="ring_num_add-val"><b>ring_num_add</b></a>]  Theorem
      
       r. Ring r  n k. ##(n + k) = ##n + ##k
   
   [<a name="ring_num_add_assoc-val"><b>ring_num_add_assoc</b></a>]  Theorem
      
       r. Ring r  x. x  R  m n. ##m + (##n + x) = ##(m + n) + x
   
   [<a name="ring_num_add_mult-val"><b>ring_num_add_mult</b></a>]  Theorem
      
       r. Ring r  x. x  R  m n. ##(m + n) * x = ##m * x + ##n * x
   
   [<a name="ring_num_add_mult_assoc-val"><b>ring_num_add_mult_assoc</b></a>]  Theorem
      
       r. Ring r 
            x y.
              x  R  y  R 
              m n. ##(m + n) * x + y = ##m * x + (##n * x + y)
   
   [<a name="ring_num_all_zero-val"><b>ring_num_all_zero</b></a>]  Theorem
      
       r. Ring r  #1 = #0  c. ##c = #0
   
   [<a name="ring_num_char_coprime_nonzero-val"><b>ring_num_char_coprime_nonzero</b></a>]  Theorem
      
       r. Ring r  #1  #0  c. coprime c (char r)  ##c  #0
   
   [<a name="ring_num_element-val"><b>ring_num_element</b></a>]  Theorem
      
       r. Ring r  n. ##n  R
   
   [<a name="ring_num_eq-val"><b>ring_num_eq</b></a>]  Theorem
      
       r. Ring r  n m. n &lt; char r  m &lt; char r  (##n = ##m  n = m)
   
   [<a name="ring_num_exp-val"><b>ring_num_exp</b></a>]  Theorem
      
       r. Ring r  m n. ##m ** n = ##(m ** n)
   
   [<a name="ring_num_mod-val"><b>ring_num_mod</b></a>]  Theorem
      
       r. Ring r  0 &lt; char r  n. ##n = ##(n MOD char r)
   
   [<a name="ring_num_mult-val"><b>ring_num_mult</b></a>]  Theorem
      
       r. Ring r  m n. ##m * ##n = ##(m * n)
   
   [<a name="ring_num_mult_assoc-val"><b>ring_num_mult_assoc</b></a>]  Theorem
      
       r. Ring r  m n x. x  R  ##m * (##n * x) = ##(m * n) * x
   
   [<a name="ring_num_mult_element-val"><b>ring_num_mult_element</b></a>]  Theorem
      
       r. Ring r  x. x  R  n. ##n * x  R
   
   [<a name="ring_num_mult_exp-val"><b>ring_num_mult_exp</b></a>]  Theorem
      
       r. Ring r  k m n. ##k * ##m ** n = ##(k * m ** n)
   
   [<a name="ring_num_mult_neg-val"><b>ring_num_mult_neg</b></a>]  Theorem
      
       r. Ring r  x. x  R  n. -(##n * x) = ##n * -x
   
   [<a name="ring_num_mult_radd-val"><b>ring_num_mult_radd</b></a>]  Theorem
      
       r. Ring r 
            x y. x  R  y  R  n. ##n * (x + y) = ##n * x + ##n * y
   
   [<a name="ring_num_mult_small-val"><b>ring_num_mult_small</b></a>]  Theorem
      
       r. Ring r 
            x. x  R 
                #0 * x = #0  #1 * x = x  ##2 * x = x + x 
                ##3 * x = ##2 * x + x
   
   [<a name="ring_num_mult_suc-val"><b>ring_num_mult_suc</b></a>]  Theorem
      
       r. Ring r  x. x  R  n. ##(SUC n) * x = ##n * x + x
   
   [<a name="ring_num_negative-val"><b>ring_num_negative</b></a>]  Theorem
      
       r. Ring r  0 &lt; char r  z. y x. y = ##x  y + ##z = #0
   
   [<a name="ring_num_one-val"><b>ring_num_one</b></a>]  Theorem
      
       r. ##1 = #1 + #0
   
   [<a name="ring_num_sub-val"><b>ring_num_sub</b></a>]  Theorem
      
       r. Ring r  n m. m &lt; n  ##(n  m) = ##n  ##m
   
   [<a name="ring_num_suc-val"><b>ring_num_suc</b></a>]  Theorem
      
       r. Ring r  n. ##(SUC n) = ##n + #1
   
   [<a name="ring_one_element-val"><b>ring_one_element</b></a>]  Theorem
      
       r. Ring r  #1  R
   
   [<a name="ring_one_eq_zero-val"><b>ring_one_eq_zero</b></a>]  Theorem
      
       r. Ring r  (#1 = #0  R = {#0})
   
   [<a name="ring_one_exp-val"><b>ring_one_exp</b></a>]  Theorem
      
       r. Ring r  n. #1 ** n = #1
   
   [<a name="ring_one_unique-val"><b>ring_one_unique</b></a>]  Theorem
      
       r. Ring r 
            y. y  R  ((x. x  R  y * x = x  x * y = x)  y = #1)
   
   [<a name="ring_prime_divides_product-val"><b>ring_prime_divides_product</b></a>]  Theorem
      
       r. Ring r 
            p. p  R 
                (rprime p  p  R* 
                 b. FINITE_BAG b  SET_OF_BAG b  R 
                     p rdivides GBAG r.prod b 
                     x. x  b  p rdivides x)
   
   [<a name="ring_prime_iso-val"><b>ring_prime_iso</b></a>]  Theorem
      
       r r_ f. (r =r= r_) f  p. p  R  rprime p  ring_prime r_ (f p)
   
   [<a name="ring_product_factors_divide-val"><b>ring_product_factors_divide</b></a>]  Theorem
      
       r. Ring r 
            b. FINITE_BAG b 
                SET_OF_BAG b  R  GBAG r.prod b rdivides x 
                y. y  b  y rdivides x
   
   [<a name="ring_single_add_mult-val"><b>ring_single_add_mult</b></a>]  Theorem
      
       r. Ring r  x. x  R  n. x + ##n * x = ##(n + 1) * x
   
   [<a name="ring_single_add_mult_assoc-val"><b>ring_single_add_mult_assoc</b></a>]  Theorem
      
       r. Ring r 
            x y. x  R  y  R  n. x + (##n * x + y) = ##(n + 1) * x + y
   
   [<a name="ring_single_add_neg_mult-val"><b>ring_single_add_neg_mult</b></a>]  Theorem
      
       r. Ring r 
            x. x  R 
                n. x + -(##n * x) = if n = 0 then x else -(##(n  1) * x)
   
   [<a name="ring_single_add_neg_mult_assoc-val"><b>ring_single_add_neg_mult_assoc</b></a>]  Theorem
      
       r. Ring r 
            x y.
              x  R  y  R 
              n. x + (-(##n * x) + y) =
                  if n = 0 then x + y else -(##(n  1) * x) + y
   
   [<a name="ring_single_add_single-val"><b>ring_single_add_single</b></a>]  Theorem
      
       r. Ring r  x. x  R  x + x = ##2 * x
   
   [<a name="ring_single_add_single_assoc-val"><b>ring_single_add_single_assoc</b></a>]  Theorem
      
       r. Ring r  x y. x  R  y  R  x + (x + y) = ##2 * x + y
   
   [<a name="ring_single_mult_exp-val"><b>ring_single_mult_exp</b></a>]  Theorem
      
       r. Ring r  x. x  R  n. x * x ** n = x ** (n + 1)
   
   [<a name="ring_single_mult_exp_assoc-val"><b>ring_single_mult_exp_assoc</b></a>]  Theorem
      
       r. Ring r 
            x y. x  R  y  R  n. x * (x ** n * y) = x ** (n + 1) * y
   
   [<a name="ring_single_mult_single-val"><b>ring_single_mult_single</b></a>]  Theorem
      
       r. Ring r  x. x  R  x * x = x ** 2
   
   [<a name="ring_single_mult_single_assoc-val"><b>ring_single_mult_single_assoc</b></a>]  Theorem
      
       r. Ring r  x y. x  R  y  R  x * (x * y) = x ** 2 * y
   
   [<a name="ring_sub_add-val"><b>ring_sub_add</b></a>]  Theorem
      
       r. Ring r  x y. x  R  y  R  x  y + y = x
   
   [<a name="ring_sub_element-val"><b>ring_sub_element</b></a>]  Theorem
      
       r. Ring r  x y. x  R  y  R  x  y  R
   
   [<a name="ring_sub_eq-val"><b>ring_sub_eq</b></a>]  Theorem
      
       r. Ring r  x y. x  R  x  x = #0
   
   [<a name="ring_sub_eq_add-val"><b>ring_sub_eq_add</b></a>]  Theorem
      
       r. Ring r 
            x y z. x  R  y  R  z  R  (x  y = z  x = y + z)
   
   [<a name="ring_sub_eq_zero-val"><b>ring_sub_eq_zero</b></a>]  Theorem
      
       r. Ring r  x y. x  R  y  R  (x  y = #0  x = y)
   
   [<a name="ring_sub_lcancel-val"><b>ring_sub_lcancel</b></a>]  Theorem
      
       r. Ring r 
            x y z. x  R  y  R  z  R  (x  y = x  z  y = z)
   
   [<a name="ring_sub_pair_reduce-val"><b>ring_sub_pair_reduce</b></a>]  Theorem
      
       r. Ring r 
            x y z. x  R  y  R  z  R  x + z  (y + z) = x  y
   
   [<a name="ring_sub_rcancel-val"><b>ring_sub_rcancel</b></a>]  Theorem
      
       r. Ring r 
            x y z. x  R  y  R  z  R  (y  x = z  x  y = z)
   
   [<a name="ring_sub_zero-val"><b>ring_sub_zero</b></a>]  Theorem
      
       r. Ring r  x. x  R  x  #0 = x
   
   [<a name="ring_sum_SNOC-val"><b>ring_sum_SNOC</b></a>]  Theorem
      
       r. Ring r  k s. k  R  rlist s  rsum (SNOC k s) = rsum s + k
   
   [<a name="ring_sum_append-val"><b>ring_sum_append</b></a>]  Theorem
      
       r. Ring r 
            s t. rlist s  rlist t  rsum (s  t) = rsum s + rsum t
   
   [<a name="ring_sum_cons-val"><b>ring_sum_cons</b></a>]  Theorem
      
       r h t. rsum (h::t) = h + rsum t
   
   [<a name="ring_sum_decompose_first-val"><b>ring_sum_decompose_first</b></a>]  Theorem
      
       r f n. rsum (GENLIST f (SUC n)) = f 0 + rsum (GENLIST (f  SUC) n)
   
   [<a name="ring_sum_decompose_first_last-val"><b>ring_sum_decompose_first_last</b></a>]  Theorem
      
       r. Ring r 
            f n.
              rfun f  0 &lt; n 
              rsum (GENLIST f (SUC n)) =
              f 0 + rsum (GENLIST (f  SUC) (PRE n)) + f n
   
   [<a name="ring_sum_decompose_last-val"><b>ring_sum_decompose_last</b></a>]  Theorem
      
       r. Ring r 
            f n.
              rfun f  rsum (GENLIST f (SUC n)) = rsum (GENLIST f n) + f n
   
   [<a name="ring_sum_element-val"><b>ring_sum_element</b></a>]  Theorem
      
       r. Ring r  s. rlist s  rsum s  R
   
   [<a name="ring_sum_freshman_all-val"><b>ring_sum_freshman_all</b></a>]  Theorem
      
       r. Ring r  prime (char r) 
            f. rfun f 
                x. x  R 
                    n k.
                      rsum (GENLIST (j. f j * x ** j) n) ** char r ** k =
                      rsum (GENLIST (j. (f j * x ** j) ** char r ** k) n)
   
   [<a name="ring_sum_freshman_thm-val"><b>ring_sum_freshman_thm</b></a>]  Theorem
      
       r. Ring r  prime (char r) 
            f. rfun f 
                x. x  R 
                    n. rsum (GENLIST (j. f j * x ** j) n) ** char r =
                        rsum (GENLIST (j. (f j * x ** j) ** char r) n)
   
   [<a name="ring_sum_fun_zero-val"><b>ring_sum_fun_zero</b></a>]  Theorem
      
       r. Ring r 
            f. rfun f 
                n. (k. 0 &lt; k  k &lt; n  f k = #0) 
                    rsum (MAP f (GENLIST SUC (PRE n))) = #0
   
   [<a name="ring_sum_genlist_add-val"><b>ring_sum_genlist_add</b></a>]  Theorem
      
       r. Ring r 
            a b.
              rfun a  rfun b 
              n. rsum (GENLIST a n) + rsum (GENLIST b n) =
                  rsum (GENLIST (k. a k + b k) n)
   
   [<a name="ring_sum_genlist_append-val"><b>ring_sum_genlist_append</b></a>]  Theorem
      
       r. Ring r 
            a b.
              rfun a  rfun b 
              n. rsum (GENLIST a n  GENLIST b n) =
                  rsum (GENLIST (k. a k + b k) n)
   
   [<a name="ring_sum_genlist_const-val"><b>ring_sum_genlist_const</b></a>]  Theorem
      
       r. Ring r  x. x  R  n. rsum (GENLIST (K x) n) = ##n * x
   
   [<a name="ring_sum_genlist_sum-val"><b>ring_sum_genlist_sum</b></a>]  Theorem
      
       r. Ring r 
            f. rfun f 
                n m.
                  rsum (GENLIST f (n + m)) =
                  rsum (GENLIST f m) + rsum (GENLIST (k. f (k + m)) n)
   
   [<a name="ring_sum_mult-val"><b>ring_sum_mult</b></a>]  Theorem
      
       r. Ring r 
            k s. k  R  rlist s  k * rsum s = rsum (MAP (x. k * x) s)
   
   [<a name="ring_sum_mult_ladd-val"><b>ring_sum_mult_ladd</b></a>]  Theorem
      
       r. Ring r 
            m n s.
              m  R  n  R  rlist s 
              (m + n) * rsum s =
              rsum (MAP (x. m * x) s) + rsum (MAP (x. n * x) s)
   
   [<a name="ring_sum_nil-val"><b>ring_sum_nil</b></a>]  Theorem
      
       r. rsum [] = #0
   
   [<a name="ring_sum_sing-val"><b>ring_sum_sing</b></a>]  Theorem
      
       r. Ring r  x. x  R  rsum [x] = x
   
   [<a name="ring_sum_zero-val"><b>ring_sum_zero</b></a>]  Theorem
      
       r. Ring r  n. r.sum.exp #0 n = #0
   
   [<a name="ring_unit_element-val"><b>ring_unit_element</b></a>]  Theorem
      
       r. Ring r  x. unit x  x  R
   
   [<a name="ring_unit_has_inv-val"><b>ring_unit_has_inv</b></a>]  Theorem
      
       r. Ring r  x. unit x  unit ( |/ x)
   
   [<a name="ring_unit_inv_element-val"><b>ring_unit_inv_element</b></a>]  Theorem
      
       r. Ring r  x. unit x  |/ x  R
   
   [<a name="ring_unit_inv_inv-val"><b>ring_unit_inv_inv</b></a>]  Theorem
      
       r. Ring r  u. unit u  u = |/ ( |/ u)
   
   [<a name="ring_unit_inv_nonzero-val"><b>ring_unit_inv_nonzero</b></a>]  Theorem
      
       r. Ring r  #1  #0  x. unit x  |/ x  #0
   
   [<a name="ring_unit_linv-val"><b>ring_unit_linv</b></a>]  Theorem
      
       r. Ring r  x. unit x  |/ x * x = #1
   
   [<a name="ring_unit_linv_inv-val"><b>ring_unit_linv_inv</b></a>]  Theorem
      
       r. Ring r  u v. unit u  v  R  |/ u * v = #1  u = v
   
   [<a name="ring_unit_linv_unique-val"><b>ring_unit_linv_unique</b></a>]  Theorem
      
       r. Ring r  u v. u  R  unit v  u * v = #1  u = |/ v
   
   [<a name="ring_unit_mult_eq_unit-val"><b>ring_unit_mult_eq_unit</b></a>]  Theorem
      
       r. Ring r  x y. x  R  y  R  (unit (x * y)  unit x  unit y)
   
   [<a name="ring_unit_mult_unit-val"><b>ring_unit_mult_unit</b></a>]  Theorem
      
       r. Ring r  u v. unit u  unit v  unit (u * v)
   
   [<a name="ring_unit_mult_zero-val"><b>ring_unit_mult_zero</b></a>]  Theorem
      
       r. Ring r  x y. unit x  y  R  (x * y = #0  y = #0)
   
   [<a name="ring_unit_neg-val"><b>ring_unit_neg</b></a>]  Theorem
      
       r. Ring r  x. unit x  unit (-x)
   
   [<a name="ring_unit_nonzero-val"><b>ring_unit_nonzero</b></a>]  Theorem
      
       r. Ring r  #1  #0  x. unit x  x  #0
   
   [<a name="ring_unit_one-val"><b>ring_unit_one</b></a>]  Theorem
      
       r. Ring r  unit #1
   
   [<a name="ring_unit_property-val"><b>ring_unit_property</b></a>]  Theorem
      
       r. Ring r  u. unit u  u  R  v. v  R  u * v = #1
   
   [<a name="ring_unit_rinv-val"><b>ring_unit_rinv</b></a>]  Theorem
      
       r. Ring r  x. unit x  x * |/ x = #1
   
   [<a name="ring_unit_rinv_inv-val"><b>ring_unit_rinv_inv</b></a>]  Theorem
      
       r. Ring r  u v. u  R  unit v  u * |/ v = #1  u = v
   
   [<a name="ring_unit_rinv_unique-val"><b>ring_unit_rinv_unique</b></a>]  Theorem
      
       r. Ring r  u v. unit u  v  R  u * v = #1  v = |/ u
   
   [<a name="ring_unit_zero-val"><b>ring_unit_zero</b></a>]  Theorem
      
       r. Ring r  (unit #0  #1 = #0)
   
   [<a name="ring_units_abelain_group-val"><b>ring_units_abelain_group</b></a>]  Theorem
      
       r. Ring r  AbelianGroup r*
   
   [<a name="ring_units_element-val"><b>ring_units_element</b></a>]  Theorem
      
       r. Ring r  x. unit x  x  R
   
   [<a name="ring_units_group-val"><b>ring_units_group</b></a>]  Theorem
      
       r. Ring r  Group r*
   
   [<a name="ring_units_has_one-val"><b>ring_units_has_one</b></a>]  Theorem
      
       r. Ring r  unit #1
   
   [<a name="ring_units_has_zero-val"><b>ring_units_has_zero</b></a>]  Theorem
      
       r. Ring r  (unit #0  #1 = #0)
   
   [<a name="ring_units_property-val"><b>ring_units_property</b></a>]  Theorem
      
       r. Ring r  r*.op = $*  r*.id = #1
   
   [<a name="ring_updates_eq_literal-val"><b>ring_updates_eq_literal</b></a>]  Theorem
      
       r f m0 m.
          r with &lt;|carrier := f; sum := m0; prod := m|&gt; =
          &lt;|carrier := f; sum := m0; prod := m|&gt;
   
   [<a name="ring_zero_divides-val"><b>ring_zero_divides</b></a>]  Theorem
      
       r. Ring r  x. x  R  (#0 rdivides x  x = #0)
   
   [<a name="ring_zero_element-val"><b>ring_zero_element</b></a>]  Theorem
      
       r. Ring r  #0  R
   
   [<a name="ring_zero_exp-val"><b>ring_zero_exp</b></a>]  Theorem
      
       r. Ring r  n. #0 ** n = if n = 0 then #1 else #0
   
   [<a name="ring_zero_fix-val"><b>ring_zero_fix</b></a>]  Theorem
      
       r. Ring r  x. x  R  (x + x = x  x = #0)
   
   [<a name="ring_zero_sub-val"><b>ring_zero_sub</b></a>]  Theorem
      
       r. Ring r  x. x  R  #0  x = -x
   
   [<a name="ring_zero_unique-val"><b>ring_zero_unique</b></a>]  Theorem
      
       r. Ring r 
            x y.
              x  R  y  R  (y + x = x  y = #0)  (x + y = x  y = #0)
   
   [<a name="subring_I_antisym-val"><b>subring_I_antisym</b></a>]  Theorem
      
       r s. subring s r  subring r s  RingIso I s r
   
   [<a name="subring_add-val"><b>subring_add</b></a>]  Theorem
      
       r s. s  r  x y. x  B  y  B  s.sum.op x y = x + y
   
   [<a name="subring_by_subgroup_submonoid-val"><b>subring_by_subgroup_submonoid</b></a>]  Theorem
      
       r s.
          s  r 
          Ring r  Ring s  subgroup s.sum r.sum  submonoid s.prod r.prod
   
   [<a name="subring_carrier_antisym-val"><b>subring_carrier_antisym</b></a>]  Theorem
      
       r s. subring s r  R  B  RingIso I s r
   
   [<a name="subring_carrier_finite-val"><b>subring_carrier_finite</b></a>]  Theorem
      
       r s. FiniteRing r  subring s r  FINITE B
   
   [<a name="subring_carrier_subset-val"><b>subring_carrier_subset</b></a>]  Theorem
      
       r s. subring s r  B  R
   
   [<a name="subring_char-val"><b>subring_char</b></a>]  Theorem
      
       r s. s  r  char s = char r
   
   [<a name="subring_char_divides-val"><b>subring_char_divides</b></a>]  Theorem
      
       r s. s  r  char r divides char s
   
   [<a name="subring_element-val"><b>subring_element</b></a>]  Theorem
      
       r s. subring s r  x. x  B  x  R
   
   [<a name="subring_element_alt-val"><b>subring_element_alt</b></a>]  Theorem
      
       r s. s  r  x. x  B  x  R
   
   [<a name="subring_exp-val"><b>subring_exp</b></a>]  Theorem
      
       r s. s  r  x. x  B  n. s.prod.exp x n = x ** n
   
   [<a name="subring_finite_ring-val"><b>subring_finite_ring</b></a>]  Theorem
      
       r s. FiniteRing r  s  r  FiniteRing s
   
   [<a name="subring_homo_homo-val"><b>subring_homo_homo</b></a>]  Theorem
      
       r s r_ f. subring s r  RingHomo f r r_  RingHomo f s r_
   
   [<a name="subring_ids-val"><b>subring_ids</b></a>]  Theorem
      
       r s. s  r  s.sum.id = #0  s.prod.id = #1
   
   [<a name="subring_mult-val"><b>subring_mult</b></a>]  Theorem
      
       r s. s  r  x y. x  B  y  B  s.prod.op x y = x * y
   
   [<a name="subring_neg-val"><b>subring_neg</b></a>]  Theorem
      
       r s. s  r  x. x  B  s.sum.inv x = -x
   
   [<a name="subring_num-val"><b>subring_num</b></a>]  Theorem
      
       r s. s  r  n. s.sum.exp s.prod.id n = ##n
   
   [<a name="subring_one-val"><b>subring_one</b></a>]  Theorem
      
       r s. s  r  s.prod.id = #1
   
   [<a name="subring_prod_submonoid-val"><b>subring_prod_submonoid</b></a>]  Theorem
      
       r s. subring s r  submonoid s.prod r.prod
   
   [<a name="subring_property-val"><b>subring_property</b></a>]  Theorem
      
       r s.
          Ring s  subring s r 
          x y.
            x  B  y  B  s.sum.op x y = x + y  s.prod.op x y = x * y
   
   [<a name="subring_refl-val"><b>subring_refl</b></a>]  Theorem
      
       r. subring r r
   
   [<a name="subring_ring_iso_compose-val"><b>subring_ring_iso_compose</b></a>]  Theorem
      
       r s r_ f. subring s r  RingIso f r r_  RingHomo f s r_
   
   [<a name="subring_ring_iso_ring_homo_subring-val"><b>subring_ring_iso_ring_homo_subring</b></a>]  Theorem
      
       r s r_ f. s  r  (r =r= r_) f  ring_homo_image f s r_  r_
   
   [<a name="subring_sub-val"><b>subring_sub</b></a>]  Theorem
      
       r s. s  r  x y. x  B  y  B  ring_sub s x y = x  y
   
   [<a name="subring_sum_subgroup-val"><b>subring_sum_subgroup</b></a>]  Theorem
      
       r s. subring s r  subgroup s.sum r.sum
   
   [<a name="subring_trans-val"><b>subring_trans</b></a>]  Theorem
      
       r s t. subring r s  subring s t  subring r t
   
   [<a name="subring_unit-val"><b>subring_unit</b></a>]  Theorem
      
       r s. s  r  x. Unit s x  unit x
   
   [<a name="subring_unit_inv-val"><b>subring_unit_inv</b></a>]  Theorem
      
       r s. s  r  x. Unit s x  Inv s x = |/ x
   
   [<a name="subring_unit_inv_element-val"><b>subring_unit_inv_element</b></a>]  Theorem
      
       r s. s  r  x. Unit s x  Inv s x  B
   
   [<a name="subring_unit_inv_nonzero-val"><b>subring_unit_inv_nonzero</b></a>]  Theorem
      
       r s. s  r  #1  #0  x. Unit s x  Inv s x  #0
   
   [<a name="subring_unit_nonzero-val"><b>subring_unit_nonzero</b></a>]  Theorem
      
       r s. s  r  #1  #0  x. Unit s x  x  #0
   
   [<a name="subring_zero-val"><b>subring_zero</b></a>]  Theorem
      
       r s. s  r  s.sum.id = #0
   
   [<a name="symdiff_eval-val"><b>symdiff_eval</b></a>]  Theorem
      
       symdiff_set.carrier = (: -&gt; bool) 
        (x y. symdiff_set.op x y = x  y DIFF x  y)  symdiff_set.id = 
   
   [<a name="symdiff_set_inter_char-val"><b>symdiff_set_inter_char</b></a>]  Theorem
      
       char symdiff_set_inter = 2
   
   [<a name="symdiff_set_inter_ring-val"><b>symdiff_set_inter_ring</b></a>]  Theorem
      
       Ring symdiff_set_inter
   
   [<a name="symdiff_univ_univ_eq_empty-val"><b>symdiff_univ_univ_eq_empty</b></a>]  Theorem
      
       symdiff (:) (:) = 
   
   [<a name="trivial_char-val"><b>trivial_char</b></a>]  Theorem
      
       z. char (trivial_ring z) = 1
   
   [<a name="trivial_integral_domain-val"><b>trivial_integral_domain</b></a>]  Theorem
      
       e0 e1.
          e0  e1  FiniteIntegralDomain (trivial_integal_domain e0 e1)
   
   [<a name="trivial_ring-val"><b>trivial_ring</b></a>]  Theorem
      
       z. FiniteRing (trivial_ring z)
   
   [<a name="trivial_ring_thm-val"><b>trivial_ring_thm</b></a>]  Theorem
      
       z. Ring (trivial_ring z)
   
   [<a name="unit_eq_refl-val"><b>unit_eq_refl</b></a>]  Theorem
      
       r. Ring r  x. x  R  x =~ x
   
   [<a name="unit_eq_sym-val"><b>unit_eq_sym</b></a>]  Theorem
      
       r. Ring r  x y. x  R  y  R  x =~ y  y =~ x
   
   [<a name="unit_eq_trans-val"><b>unit_eq_trans</b></a>]  Theorem
      
       r. Ring r 
            x y z. x  R  y  R  z  R  x =~ y  y =~ z  x =~ z
   
   [<a name="zero_ideal_ideal-val"><b>zero_ideal_ideal</b></a>]  Theorem
      
       r. Ring r  &lt;#0&gt; &lt;&lt; r
   
   [<a name="zero_ideal_sing-val"><b>zero_ideal_sing</b></a>]  Theorem
      
       r. Ring r  &lt;#0&gt;.carrier = {#0}
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/algebra/construction/.hol/objs/ringScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-2</a></em></p></body></html>
