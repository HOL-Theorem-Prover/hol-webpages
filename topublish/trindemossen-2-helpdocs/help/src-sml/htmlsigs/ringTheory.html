<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure ringTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure ringTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/algebra/construction/.hol/objs/ringScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature ringTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#EuclideanRing_def-val">EuclideanRing_def</a> : thm
<a name="line7"></a>    val <a href="#FiniteIntegralDomain_def-val">FiniteIntegralDomain_def</a> : thm
<a name="line8"></a>    val <a href="#FiniteRing_def-val">FiniteRing_def</a> : thm
<a name="line9"></a>    val <a href="#IntegralDomain_def-val">IntegralDomain_def</a> : thm
<a name="line10"></a>    val <a href="#PrincipalIdealRing_def-val">PrincipalIdealRing_def</a> : thm
<a name="line11"></a>    val <a href="#RingAuto_def-val">RingAuto_def</a> : thm
<a name="line12"></a>    val <a href="#RingEndo_def-val">RingEndo_def</a> : thm
<a name="line13"></a>    val <a href="#RingHomo_def-val">RingHomo_def</a> : thm
<a name="line14"></a>    val <a href="#RingIso_def-val">RingIso_def</a> : thm
<a name="line15"></a>    val <a href="#Ring_def-val">Ring_def</a> : thm
<a name="line16"></a>    val <a href="#ZN_def-val">ZN_def</a> : thm
<a name="line17"></a>    val <a href="#ZP_def-val">ZP_def</a> : thm
<a name="line18"></a>    val <a href="#Z_add_def-val">Z_add_def</a> : thm
<a name="line19"></a>    val <a href="#Z_def-val">Z_def</a> : thm
<a name="line20"></a>    val <a href="#Z_ideal_def-val">Z_ideal_def</a> : thm
<a name="line21"></a>    val <a href="#Z_mult_def-val">Z_mult_def</a> : thm
<a name="line22"></a>    val <a href="#Z_multiple_def-val">Z_multiple_def</a> : thm
<a name="line23"></a>    val <a href="#char_def-val">char_def</a> : thm
<a name="line24"></a>    val <a href="#compute_ordz_def-val">compute_ordz_def</a> : thm
<a name="line25"></a>    val <a href="#homo_ideal_def-val">homo_ideal_def</a> : thm
<a name="line26"></a>    val <a href="#homo_ring_def-val">homo_ring_def</a> : thm
<a name="line27"></a>    val <a href="#ideal_congruence_def-val">ideal_congruence_def</a> : thm
<a name="line28"></a>    val <a href="#ideal_coset_add_def-val">ideal_coset_add_def</a> : thm
<a name="line29"></a>    val <a href="#ideal_coset_mult_def-val">ideal_coset_mult_def</a> : thm
<a name="line30"></a>    val <a href="#ideal_def-val">ideal_def</a> : thm
<a name="line31"></a>    val <a href="#ideal_gen_def-val">ideal_gen_def</a> : thm
<a name="line32"></a>    val <a href="#ideal_maximal_def-val">ideal_maximal_def</a> : thm
<a name="line33"></a>    val <a href="#ideal_sum_def-val">ideal_sum_def</a> : thm
<a name="line34"></a>    val <a href="#irreducible_def-val">irreducible_def</a> : thm
<a name="line35"></a>    val <a href="#kernel_ideal_def-val">kernel_ideal_def</a> : thm
<a name="line36"></a>    val <a href="#monoid_of_ring_nonzero_mult_def-val">monoid_of_ring_nonzero_mult_def</a> : thm
<a name="line37"></a>    val <a href="#principal_ideal_def-val">principal_ideal_def</a> : thm
<a name="line38"></a>    val <a href="#quotient_ring_add_def-val">quotient_ring_add_def</a> : thm
<a name="line39"></a>    val <a href="#quotient_ring_def-val">quotient_ring_def</a> : thm
<a name="line40"></a>    val <a href="#quotient_ring_mult_def-val">quotient_ring_mult_def</a> : thm
<a name="line41"></a>    val <a href="#recordtype_ring_seldef_carrier_def-val">recordtype_ring_seldef_carrier_def</a> : thm
<a name="line42"></a>    val <a href="#recordtype_ring_seldef_carrier_fupd_def-val">recordtype_ring_seldef_carrier_fupd_def</a> : thm
<a name="line43"></a>    val <a href="#recordtype_ring_seldef_prod_def-val">recordtype_ring_seldef_prod_def</a> : thm
<a name="line44"></a>    val <a href="#recordtype_ring_seldef_prod_fupd_def-val">recordtype_ring_seldef_prod_fupd_def</a> : thm
<a name="line45"></a>    val <a href="#recordtype_ring_seldef_sum_def-val">recordtype_ring_seldef_sum_def</a> : thm
<a name="line46"></a>    val <a href="#recordtype_ring_seldef_sum_fupd_def-val">recordtype_ring_seldef_sum_fupd_def</a> : thm
<a name="line47"></a>    val <a href="#ring_TY_DEF-val">ring_TY_DEF</a> : thm
<a name="line48"></a>    val <a href="#ring_associates_def-val">ring_associates_def</a> : thm
<a name="line49"></a>    val <a href="#ring_case_def-val">ring_case_def</a> : thm
<a name="line50"></a>    val <a href="#ring_divides_def-val">ring_divides_def</a> : thm
<a name="line51"></a>    val <a href="#ring_fun_def-val">ring_fun_def</a> : thm
<a name="line52"></a>    val <a href="#ring_gcd_def-val">ring_gcd_def</a> : thm
<a name="line53"></a>    val <a href="#ring_homo_image_def-val">ring_homo_image_def</a> : thm
<a name="line54"></a>    val <a href="#ring_inj_image_def-val">ring_inj_image_def</a> : thm
<a name="line55"></a>    val <a href="#ring_list_def-val">ring_list_def</a> : thm
<a name="line56"></a>    val <a href="#ring_nonzero_def-val">ring_nonzero_def</a> : thm
<a name="line57"></a>    val <a href="#ring_ordering_def-val">ring_ordering_def</a> : thm
<a name="line58"></a>    val <a href="#ring_prime_def-val">ring_prime_def</a> : thm
<a name="line59"></a>    val <a href="#ring_size_def-val">ring_size_def</a> : thm
<a name="line60"></a>    val <a href="#ring_sub_def-val">ring_sub_def</a> : thm
<a name="line61"></a>    val <a href="#ring_sum_def-val">ring_sum_def</a> : thm
<a name="line62"></a>    val <a href="#subring_def-val">subring_def</a> : thm
<a name="line63"></a>    val <a href="#symdiff_set_inter_def-val">symdiff_set_inter_def</a> : thm
<a name="line64"></a>    val <a href="#trivial_integal_domain_def-val">trivial_integal_domain_def</a> : thm
<a name="line65"></a>    val <a href="#trivial_ring_def-val">trivial_ring_def</a> : thm
<a name="line66"></a>    val <a href="#unit_eq_def-val">unit_eq_def</a> : thm
<a name="line67"></a>  
<a name="line68"></a>  (*  Theorems  *)
<a name="line69"></a>    val <a href="#EXISTS_ring-val">EXISTS_ring</a> : thm
<a name="line70"></a>    val <a href="#FORALL_ring-val">FORALL_ring</a> : thm
<a name="line71"></a>    val <a href="#LIST_REL_ring_associates_product-val">LIST_REL_ring_associates_product</a> : thm
<a name="line72"></a>    val <a href="#WHILE_RULE_PRE_POST-val">WHILE_RULE_PRE_POST</a> : thm
<a name="line73"></a>    val <a href="#ZN_1_exp-val">ZN_1_exp</a> : thm
<a name="line74"></a>    val <a href="#ZN_card-val">ZN_card</a> : thm
<a name="line75"></a>    val <a href="#ZN_char-val">ZN_char</a> : thm
<a name="line76"></a>    val <a href="#ZN_coprime_euler_element-val">ZN_coprime_euler_element</a> : thm
<a name="line77"></a>    val <a href="#ZN_coprime_exp_mod-val">ZN_coprime_exp_mod</a> : thm
<a name="line78"></a>    val <a href="#ZN_coprime_invertible-val">ZN_coprime_invertible</a> : thm
<a name="line79"></a>    val <a href="#ZN_coprime_order-val">ZN_coprime_order</a> : thm
<a name="line80"></a>    val <a href="#ZN_coprime_order_alt-val">ZN_coprime_order_alt</a> : thm
<a name="line81"></a>    val <a href="#ZN_coprime_order_divides_phi-val">ZN_coprime_order_divides_phi</a> : thm
<a name="line82"></a>    val <a href="#ZN_coprime_order_divides_totient-val">ZN_coprime_order_divides_totient</a> : thm
<a name="line83"></a>    val <a href="#ZN_coprime_order_gt_1-val">ZN_coprime_order_gt_1</a> : thm
<a name="line84"></a>    val <a href="#ZN_coprime_order_lt-val">ZN_coprime_order_lt</a> : thm
<a name="line85"></a>    val <a href="#ZN_eval-val">ZN_eval</a> : thm
<a name="line86"></a>    val <a href="#ZN_exp-val">ZN_exp</a> : thm
<a name="line87"></a>    val <a href="#ZN_finite-val">ZN_finite</a> : thm
<a name="line88"></a>    val <a href="#ZN_finite_ring-val">ZN_finite_ring</a> : thm
<a name="line89"></a>    val <a href="#ZN_ids-val">ZN_ids</a> : thm
<a name="line90"></a>    val <a href="#ZN_ids_alt-val">ZN_ids_alt</a> : thm
<a name="line91"></a>    val <a href="#ZN_invertibles-val">ZN_invertibles</a> : thm
<a name="line92"></a>    val <a href="#ZN_invertibles_finite_group-val">ZN_invertibles_finite_group</a> : thm
<a name="line93"></a>    val <a href="#ZN_invertibles_group-val">ZN_invertibles_group</a> : thm
<a name="line94"></a>    val <a href="#ZN_invertibles_order-val">ZN_invertibles_order</a> : thm
<a name="line95"></a>    val <a href="#ZN_mult_inv_coprime-val">ZN_mult_inv_coprime</a> : thm
<a name="line96"></a>    val <a href="#ZN_mult_inv_coprime_iff-val">ZN_mult_inv_coprime_iff</a> : thm
<a name="line97"></a>    val <a href="#ZN_not_coprime-val">ZN_not_coprime</a> : thm
<a name="line98"></a>    val <a href="#ZN_num-val">ZN_num</a> : thm
<a name="line99"></a>    val <a href="#ZN_num_0-val">ZN_num_0</a> : thm
<a name="line100"></a>    val <a href="#ZN_num_1-val">ZN_num_1</a> : thm
<a name="line101"></a>    val <a href="#ZN_num_mod-val">ZN_num_mod</a> : thm
<a name="line102"></a>    val <a href="#ZN_order_0-val">ZN_order_0</a> : thm
<a name="line103"></a>    val <a href="#ZN_order_1-val">ZN_order_1</a> : thm
<a name="line104"></a>    val <a href="#ZN_order_divides_exp-val">ZN_order_divides_exp</a> : thm
<a name="line105"></a>    val <a href="#ZN_order_divides_phi-val">ZN_order_divides_phi</a> : thm
<a name="line106"></a>    val <a href="#ZN_order_divides_tops_index-val">ZN_order_divides_tops_index</a> : thm
<a name="line107"></a>    val <a href="#ZN_order_divisibility-val">ZN_order_divisibility</a> : thm
<a name="line108"></a>    val <a href="#ZN_order_eq_0-val">ZN_order_eq_0</a> : thm
<a name="line109"></a>    val <a href="#ZN_order_eq_0_iff-val">ZN_order_eq_0_iff</a> : thm
<a name="line110"></a>    val <a href="#ZN_order_eq_0_test-val">ZN_order_eq_0_test</a> : thm
<a name="line111"></a>    val <a href="#ZN_order_eq_1-val">ZN_order_eq_1</a> : thm
<a name="line112"></a>    val <a href="#ZN_order_eq_1_alt-val">ZN_order_eq_1_alt</a> : thm
<a name="line113"></a>    val <a href="#ZN_order_eq_1_by_prime_factors-val">ZN_order_eq_1_by_prime_factors</a> : thm
<a name="line114"></a>    val <a href="#ZN_order_gt_1_property-val">ZN_order_gt_1_property</a> : thm
<a name="line115"></a>    val <a href="#ZN_order_le-val">ZN_order_le</a> : thm
<a name="line116"></a>    val <a href="#ZN_order_le_tops_index-val">ZN_order_le_tops_index</a> : thm
<a name="line117"></a>    val <a href="#ZN_order_lt-val">ZN_order_lt</a> : thm
<a name="line118"></a>    val <a href="#ZN_order_minimal-val">ZN_order_minimal</a> : thm
<a name="line119"></a>    val <a href="#ZN_order_mod-val">ZN_order_mod</a> : thm
<a name="line120"></a>    val <a href="#ZN_order_mod_1-val">ZN_order_mod_1</a> : thm
<a name="line121"></a>    val <a href="#ZN_order_nonzero-val">ZN_order_nonzero</a> : thm
<a name="line122"></a>    val <a href="#ZN_order_nonzero_iff-val">ZN_order_nonzero_iff</a> : thm
<a name="line123"></a>    val <a href="#ZN_order_property-val">ZN_order_property</a> : thm
<a name="line124"></a>    val <a href="#ZN_order_property_alt-val">ZN_order_property_alt</a> : thm
<a name="line125"></a>    val <a href="#ZN_order_test_1-val">ZN_order_test_1</a> : thm
<a name="line126"></a>    val <a href="#ZN_order_test_2-val">ZN_order_test_2</a> : thm
<a name="line127"></a>    val <a href="#ZN_order_test_3-val">ZN_order_test_3</a> : thm
<a name="line128"></a>    val <a href="#ZN_order_test_4-val">ZN_order_test_4</a> : thm
<a name="line129"></a>    val <a href="#ZN_order_test_propery-val">ZN_order_test_propery</a> : thm
<a name="line130"></a>    val <a href="#ZN_order_upper-val">ZN_order_upper</a> : thm
<a name="line131"></a>    val <a href="#ZN_order_with_coprime_1-val">ZN_order_with_coprime_1</a> : thm
<a name="line132"></a>    val <a href="#ZN_order_with_coprime_2-val">ZN_order_with_coprime_2</a> : thm
<a name="line133"></a>    val <a href="#ZN_property-val">ZN_property</a> : thm
<a name="line134"></a>    val <a href="#ZN_ring-val">ZN_ring</a> : thm
<a name="line135"></a>    val <a href="#ZN_to_ZN_element-val">ZN_to_ZN_element</a> : thm
<a name="line136"></a>    val <a href="#ZN_to_ZN_prod_monoid_homo-val">ZN_to_ZN_prod_monoid_homo</a> : thm
<a name="line137"></a>    val <a href="#ZN_to_ZN_ring_homo-val">ZN_to_ZN_ring_homo</a> : thm
<a name="line138"></a>    val <a href="#ZN_to_ZN_sum_group_homo-val">ZN_to_ZN_sum_group_homo</a> : thm
<a name="line139"></a>    val <a href="#ZP_finite-val">ZP_finite</a> : thm
<a name="line140"></a>    val <a href="#ZP_finite_integral_domain-val">ZP_finite_integral_domain</a> : thm
<a name="line141"></a>    val <a href="#ZP_integral_domain-val">ZP_integral_domain</a> : thm
<a name="line142"></a>    val <a href="#Z_add_abelian_group-val">Z_add_abelian_group</a> : thm
<a name="line143"></a>    val <a href="#Z_add_group-val">Z_add_group</a> : thm
<a name="line144"></a>    val <a href="#Z_add_inv-val">Z_add_inv</a> : thm
<a name="line145"></a>    val <a href="#Z_euclid_ring-val">Z_euclid_ring</a> : thm
<a name="line146"></a>    val <a href="#Z_ideal_map_bij-val">Z_ideal_map_bij</a> : thm
<a name="line147"></a>    val <a href="#Z_ideal_map_element-val">Z_ideal_map_element</a> : thm
<a name="line148"></a>    val <a href="#Z_ideal_map_group_homo-val">Z_ideal_map_group_homo</a> : thm
<a name="line149"></a>    val <a href="#Z_ideal_map_monoid_homo-val">Z_ideal_map_monoid_homo</a> : thm
<a name="line150"></a>    val <a href="#Z_ideal_sum_group-val">Z_ideal_sum_group</a> : thm
<a name="line151"></a>    val <a href="#Z_ideal_sum_normal-val">Z_ideal_sum_normal</a> : thm
<a name="line152"></a>    val <a href="#Z_ideal_sum_subgroup-val">Z_ideal_sum_subgroup</a> : thm
<a name="line153"></a>    val <a href="#Z_ideal_thm-val">Z_ideal_thm</a> : thm
<a name="line154"></a>    val <a href="#Z_mult_abelian_monoid-val">Z_mult_abelian_monoid</a> : thm
<a name="line155"></a>    val <a href="#Z_mult_monoid-val">Z_mult_monoid</a> : thm
<a name="line156"></a>    val <a href="#Z_multiple_less_neg_eq-val">Z_multiple_less_neg_eq</a> : thm
<a name="line157"></a>    val <a href="#Z_principal_ideal_ring-val">Z_principal_ideal_ring</a> : thm
<a name="line158"></a>    val <a href="#Z_quotient_iso_ZN-val">Z_quotient_iso_ZN</a> : thm
<a name="line159"></a>    val <a href="#Z_ring-val">Z_ring</a> : thm
<a name="line160"></a>    val <a href="#Z_sum_cogen-val">Z_sum_cogen</a> : thm
<a name="line161"></a>    val <a href="#Z_sum_coset_eq-val">Z_sum_coset_eq</a> : thm
<a name="line162"></a>    val <a href="#char_eq_0-val">char_eq_0</a> : thm
<a name="line163"></a>    val <a href="#char_minimal-val">char_minimal</a> : thm
<a name="line164"></a>    val <a href="#char_property-val">char_property</a> : thm
<a name="line165"></a>    val <a href="#compute_ordz_0-val">compute_ordz_0</a> : thm
<a name="line166"></a>    val <a href="#compute_ordz_1-val">compute_ordz_1</a> : thm
<a name="line167"></a>    val <a href="#compute_ordz_eqn-val">compute_ordz_eqn</a> : thm
<a name="line168"></a>    val <a href="#compute_ordz_hoare-val">compute_ordz_hoare</a> : thm
<a name="line169"></a>    val <a href="#datatype_ring-val">datatype_ring</a> : thm
<a name="line170"></a>    val <a href="#euclid_ring_map-val">euclid_ring_map</a> : thm
<a name="line171"></a>    val <a href="#euclid_ring_principal_ideal_ring-val">euclid_ring_principal_ideal_ring</a> : thm
<a name="line172"></a>    val <a href="#euclid_ring_property-val">euclid_ring_property</a> : thm
<a name="line173"></a>    val <a href="#euclid_ring_ring-val">euclid_ring_ring</a> : thm
<a name="line174"></a>    val <a href="#finite_integral_domain_nonzero_group-val">finite_integral_domain_nonzero_group</a> : thm
<a name="line175"></a>    val <a href="#finite_integral_domain_nonzero_invertible-val">finite_integral_domain_nonzero_invertible</a> : thm
<a name="line176"></a>    val <a href="#finite_integral_domain_nonzero_invertible_alt-val">finite_integral_domain_nonzero_invertible_alt</a> : thm
<a name="line177"></a>    val <a href="#finite_integral_domain_period_exists-val">finite_integral_domain_period_exists</a> : thm
<a name="line178"></a>    val <a href="#finite_ring_add_finite_abelian_group-val">finite_ring_add_finite_abelian_group</a> : thm
<a name="line179"></a>    val <a href="#finite_ring_add_finite_group-val">finite_ring_add_finite_group</a> : thm
<a name="line180"></a>    val <a href="#finite_ring_card_eq_1-val">finite_ring_card_eq_1</a> : thm
<a name="line181"></a>    val <a href="#finite_ring_card_pos-val">finite_ring_card_pos</a> : thm
<a name="line182"></a>    val <a href="#finite_ring_card_prime-val">finite_ring_card_prime</a> : thm
<a name="line183"></a>    val <a href="#finite_ring_char-val">finite_ring_char</a> : thm
<a name="line184"></a>    val <a href="#finite_ring_char_alt-val">finite_ring_char_alt</a> : thm
<a name="line185"></a>    val <a href="#finite_ring_char_divides-val">finite_ring_char_divides</a> : thm
<a name="line186"></a>    val <a href="#finite_ring_char_pos-val">finite_ring_char_pos</a> : thm
<a name="line187"></a>    val <a href="#finite_ring_is_ring-val">finite_ring_is_ring</a> : thm
<a name="line188"></a>    val <a href="#finite_ring_mult_finite_abelian_monoid-val">finite_ring_mult_finite_abelian_monoid</a> : thm
<a name="line189"></a>    val <a href="#finite_ring_mult_finite_monoid-val">finite_ring_mult_finite_monoid</a> : thm
<a name="line190"></a>    val <a href="#homo_ring_by_inj-val">homo_ring_by_inj</a> : thm
<a name="line191"></a>    val <a href="#homo_ring_property-val">homo_ring_property</a> : thm
<a name="line192"></a>    val <a href="#homo_ring_ring-val">homo_ring_ring</a> : thm
<a name="line193"></a>    val <a href="#homo_ring_subring-val">homo_ring_subring</a> : thm
<a name="line194"></a>    val <a href="#ideal_antisym-val">ideal_antisym</a> : thm
<a name="line195"></a>    val <a href="#ideal_carrier_sing-val">ideal_carrier_sing</a> : thm
<a name="line196"></a>    val <a href="#ideal_carriers-val">ideal_carriers</a> : thm
<a name="line197"></a>    val <a href="#ideal_cogen_property-val">ideal_cogen_property</a> : thm
<a name="line198"></a>    val <a href="#ideal_congruence_elements-val">ideal_congruence_elements</a> : thm
<a name="line199"></a>    val <a href="#ideal_congruence_equiv-val">ideal_congruence_equiv</a> : thm
<a name="line200"></a>    val <a href="#ideal_congruence_iff_inCoset-val">ideal_congruence_iff_inCoset</a> : thm
<a name="line201"></a>    val <a href="#ideal_congruence_mult-val">ideal_congruence_mult</a> : thm
<a name="line202"></a>    val <a href="#ideal_congruence_refl-val">ideal_congruence_refl</a> : thm
<a name="line203"></a>    val <a href="#ideal_congruence_sym-val">ideal_congruence_sym</a> : thm
<a name="line204"></a>    val <a href="#ideal_congruence_trans-val">ideal_congruence_trans</a> : thm
<a name="line205"></a>    val <a href="#ideal_coset_add-val">ideal_coset_add</a> : thm
<a name="line206"></a>    val <a href="#ideal_coset_element-val">ideal_coset_element</a> : thm
<a name="line207"></a>    val <a href="#ideal_coset_eq-val">ideal_coset_eq</a> : thm
<a name="line208"></a>    val <a href="#ideal_coset_eq_carrier-val">ideal_coset_eq_carrier</a> : thm
<a name="line209"></a>    val <a href="#ideal_coset_eq_congruence-val">ideal_coset_eq_congruence</a> : thm
<a name="line210"></a>    val <a href="#ideal_coset_has_gen_diff-val">ideal_coset_has_gen_diff</a> : thm
<a name="line211"></a>    val <a href="#ideal_coset_mult-val">ideal_coset_mult</a> : thm
<a name="line212"></a>    val <a href="#ideal_coset_neg-val">ideal_coset_neg</a> : thm
<a name="line213"></a>    val <a href="#ideal_coset_of_element-val">ideal_coset_of_element</a> : thm
<a name="line214"></a>    val <a href="#ideal_coset_property-val">ideal_coset_property</a> : thm
<a name="line215"></a>    val <a href="#ideal_coset_zero-val">ideal_coset_zero</a> : thm
<a name="line216"></a>    val <a href="#ideal_element-val">ideal_element</a> : thm
<a name="line217"></a>    val <a href="#ideal_element_property-val">ideal_element_property</a> : thm
<a name="line218"></a>    val <a href="#ideal_eq_ideal-val">ideal_eq_ideal</a> : thm
<a name="line219"></a>    val <a href="#ideal_gen_exists-val">ideal_gen_exists</a> : thm
<a name="line220"></a>    val <a href="#ideal_gen_minimal-val">ideal_gen_minimal</a> : thm
<a name="line221"></a>    val <a href="#ideal_has_diff-val">ideal_has_diff</a> : thm
<a name="line222"></a>    val <a href="#ideal_has_multiple-val">ideal_has_multiple</a> : thm
<a name="line223"></a>    val <a href="#ideal_has_neg-val">ideal_has_neg</a> : thm
<a name="line224"></a>    val <a href="#ideal_has_one-val">ideal_has_one</a> : thm
<a name="line225"></a>    val <a href="#ideal_has_principal_ideal-val">ideal_has_principal_ideal</a> : thm
<a name="line226"></a>    val <a href="#ideal_has_product-val">ideal_has_product</a> : thm
<a name="line227"></a>    val <a href="#ideal_has_subgroup-val">ideal_has_subgroup</a> : thm
<a name="line228"></a>    val <a href="#ideal_has_sum-val">ideal_has_sum</a> : thm
<a name="line229"></a>    val <a href="#ideal_has_zero-val">ideal_has_zero</a> : thm
<a name="line230"></a>    val <a href="#ideal_in_quotient_ring-val">ideal_in_quotient_ring</a> : thm
<a name="line231"></a>    val <a href="#ideal_ops-val">ideal_ops</a> : thm
<a name="line232"></a>    val <a href="#ideal_product_property-val">ideal_product_property</a> : thm
<a name="line233"></a>    val <a href="#ideal_property-val">ideal_property</a> : thm
<a name="line234"></a>    val <a href="#ideal_refl-val">ideal_refl</a> : thm
<a name="line235"></a>    val <a href="#ideal_sub_ideal-val">ideal_sub_ideal</a> : thm
<a name="line236"></a>    val <a href="#ideal_sub_itself-val">ideal_sub_itself</a> : thm
<a name="line237"></a>    val <a href="#ideal_subgroup_ideal_sum-val">ideal_subgroup_ideal_sum</a> : thm
<a name="line238"></a>    val <a href="#ideal_sum_comm-val">ideal_sum_comm</a> : thm
<a name="line239"></a>    val <a href="#ideal_sum_element-val">ideal_sum_element</a> : thm
<a name="line240"></a>    val <a href="#ideal_sum_group-val">ideal_sum_group</a> : thm
<a name="line241"></a>    val <a href="#ideal_sum_has_ideal-val">ideal_sum_has_ideal</a> : thm
<a name="line242"></a>    val <a href="#ideal_sum_has_ideal_comm-val">ideal_sum_has_ideal_comm</a> : thm
<a name="line243"></a>    val <a href="#ideal_sum_ideal-val">ideal_sum_ideal</a> : thm
<a name="line244"></a>    val <a href="#ideal_sum_sub_ideal-val">ideal_sum_sub_ideal</a> : thm
<a name="line245"></a>    val <a href="#ideal_sum_subgroup-val">ideal_sum_subgroup</a> : thm
<a name="line246"></a>    val <a href="#ideal_with_one-val">ideal_with_one</a> : thm
<a name="line247"></a>    val <a href="#ideal_with_unit-val">ideal_with_unit</a> : thm
<a name="line248"></a>    val <a href="#ideal_zero-val">ideal_zero</a> : thm
<a name="line249"></a>    val <a href="#integral_domain_char-val">integral_domain_char</a> : thm
<a name="line250"></a>    val <a href="#integral_domain_divides_prime-val">integral_domain_divides_prime</a> : thm
<a name="line251"></a>    val <a href="#integral_domain_exp_eq-val">integral_domain_exp_eq</a> : thm
<a name="line252"></a>    val <a href="#integral_domain_exp_eq_zero-val">integral_domain_exp_eq_zero</a> : thm
<a name="line253"></a>    val <a href="#integral_domain_exp_nonzero-val">integral_domain_exp_nonzero</a> : thm
<a name="line254"></a>    val <a href="#integral_domain_is_ring-val">integral_domain_is_ring</a> : thm
<a name="line255"></a>    val <a href="#integral_domain_mult_eq_zero-val">integral_domain_mult_eq_zero</a> : thm
<a name="line256"></a>    val <a href="#integral_domain_mult_lcancel-val">integral_domain_mult_lcancel</a> : thm
<a name="line257"></a>    val <a href="#integral_domain_mult_nonzero-val">integral_domain_mult_nonzero</a> : thm
<a name="line258"></a>    val <a href="#integral_domain_mult_rcancel-val">integral_domain_mult_rcancel</a> : thm
<a name="line259"></a>    val <a href="#integral_domain_nonzero_monoid-val">integral_domain_nonzero_monoid</a> : thm
<a name="line260"></a>    val <a href="#integral_domain_nonzero_mult_carrier-val">integral_domain_nonzero_mult_carrier</a> : thm
<a name="line261"></a>    val <a href="#integral_domain_nonzero_mult_is_monoid-val">integral_domain_nonzero_mult_is_monoid</a> : thm
<a name="line262"></a>    val <a href="#integral_domain_nonzero_mult_property-val">integral_domain_nonzero_mult_property</a> : thm
<a name="line263"></a>    val <a href="#integral_domain_nonzero_order-val">integral_domain_nonzero_order</a> : thm
<a name="line264"></a>    val <a href="#integral_domain_one_ne_zero-val">integral_domain_one_ne_zero</a> : thm
<a name="line265"></a>    val <a href="#integral_domain_one_nonzero-val">integral_domain_one_nonzero</a> : thm
<a name="line266"></a>    val <a href="#integral_domain_order_eq_0-val">integral_domain_order_eq_0</a> : thm
<a name="line267"></a>    val <a href="#integral_domain_order_nonzero-val">integral_domain_order_nonzero</a> : thm
<a name="line268"></a>    val <a href="#integral_domain_order_zero-val">integral_domain_order_zero</a> : thm
<a name="line269"></a>    val <a href="#integral_domain_prime_factors_unique-val">integral_domain_prime_factors_unique</a> : thm
<a name="line270"></a>    val <a href="#integral_domain_ring_iso-val">integral_domain_ring_iso</a> : thm
<a name="line271"></a>    val <a href="#integral_domain_zero_not_unit-val">integral_domain_zero_not_unit</a> : thm
<a name="line272"></a>    val <a href="#integral_domain_zero_product-val">integral_domain_zero_product</a> : thm
<a name="line273"></a>    val <a href="#irreducible_associates-val">irreducible_associates</a> : thm
<a name="line274"></a>    val <a href="#irreducible_element-val">irreducible_element</a> : thm
<a name="line275"></a>    val <a href="#irreducible_factors-val">irreducible_factors</a> : thm
<a name="line276"></a>    val <a href="#kernel_ideal_element-val">kernel_ideal_element</a> : thm
<a name="line277"></a>    val <a href="#kernel_ideal_gen_add_map-val">kernel_ideal_gen_add_map</a> : thm
<a name="line278"></a>    val <a href="#kernel_ideal_gen_id_map-val">kernel_ideal_gen_id_map</a> : thm
<a name="line279"></a>    val <a href="#kernel_ideal_gen_mult_map-val">kernel_ideal_gen_mult_map</a> : thm
<a name="line280"></a>    val <a href="#kernel_ideal_quotient_bij-val">kernel_ideal_quotient_bij</a> : thm
<a name="line281"></a>    val <a href="#kernel_ideal_quotient_element_eq-val">kernel_ideal_quotient_element_eq</a> : thm
<a name="line282"></a>    val <a href="#kernel_ideal_quotient_homo-val">kernel_ideal_quotient_homo</a> : thm
<a name="line283"></a>    val <a href="#kernel_ideal_quotient_inj-val">kernel_ideal_quotient_inj</a> : thm
<a name="line284"></a>    val <a href="#kernel_ideal_quotient_iso-val">kernel_ideal_quotient_iso</a> : thm
<a name="line285"></a>    val <a href="#kernel_ideal_quotient_surj-val">kernel_ideal_quotient_surj</a> : thm
<a name="line286"></a>    val <a href="#kernel_ideal_sum_eqn-val">kernel_ideal_sum_eqn</a> : thm
<a name="line287"></a>    val <a href="#ordz_eval-val">ordz_eval</a> : thm
<a name="line288"></a>    val <a href="#prime_is_irreducible-val">prime_is_irreducible</a> : thm
<a name="line289"></a>    val <a href="#principal_ideal_element-val">principal_ideal_element</a> : thm
<a name="line290"></a>    val <a href="#principal_ideal_element_divides-val">principal_ideal_element_divides</a> : thm
<a name="line291"></a>    val <a href="#principal_ideal_eq_principal_ideal-val">principal_ideal_eq_principal_ideal</a> : thm
<a name="line292"></a>    val <a href="#principal_ideal_equal_principal_ideal-val">principal_ideal_equal_principal_ideal</a> : thm
<a name="line293"></a>    val <a href="#principal_ideal_group-val">principal_ideal_group</a> : thm
<a name="line294"></a>    val <a href="#principal_ideal_has_element-val">principal_ideal_has_element</a> : thm
<a name="line295"></a>    val <a href="#principal_ideal_has_principal_ideal-val">principal_ideal_has_principal_ideal</a> : thm
<a name="line296"></a>    val <a href="#principal_ideal_ideal-val">principal_ideal_ideal</a> : thm
<a name="line297"></a>    val <a href="#principal_ideal_property-val">principal_ideal_property</a> : thm
<a name="line298"></a>    val <a href="#principal_ideal_ring_atom_is_prime-val">principal_ideal_ring_atom_is_prime</a> : thm
<a name="line299"></a>    val <a href="#principal_ideal_ring_ideal_maximal-val">principal_ideal_ring_ideal_maximal</a> : thm
<a name="line300"></a>    val <a href="#principal_ideal_ring_irreducible_is_prime-val">principal_ideal_ring_irreducible_is_prime</a> : thm
<a name="line301"></a>    val <a href="#principal_ideal_sub_implies_divides-val">principal_ideal_sub_implies_divides</a> : thm
<a name="line302"></a>    val <a href="#principal_ideal_subgroup-val">principal_ideal_subgroup</a> : thm
<a name="line303"></a>    val <a href="#principal_ideal_subgroup_normal-val">principal_ideal_subgroup_normal</a> : thm
<a name="line304"></a>    val <a href="#principal_ideal_sum_eq_ideal-val">principal_ideal_sum_eq_ideal</a> : thm
<a name="line305"></a>    val <a href="#principal_ideal_sum_equal_ideal-val">principal_ideal_sum_equal_ideal</a> : thm
<a name="line306"></a>    val <a href="#quotient_ring_add_abelian_group-val">quotient_ring_add_abelian_group</a> : thm
<a name="line307"></a>    val <a href="#quotient_ring_add_assoc-val">quotient_ring_add_assoc</a> : thm
<a name="line308"></a>    val <a href="#quotient_ring_add_comm-val">quotient_ring_add_comm</a> : thm
<a name="line309"></a>    val <a href="#quotient_ring_add_element-val">quotient_ring_add_element</a> : thm
<a name="line310"></a>    val <a href="#quotient_ring_add_group-val">quotient_ring_add_group</a> : thm
<a name="line311"></a>    val <a href="#quotient_ring_add_id-val">quotient_ring_add_id</a> : thm
<a name="line312"></a>    val <a href="#quotient_ring_add_inv-val">quotient_ring_add_inv</a> : thm
<a name="line313"></a>    val <a href="#quotient_ring_by_principal_ideal-val">quotient_ring_by_principal_ideal</a> : thm
<a name="line314"></a>    val <a href="#quotient_ring_element-val">quotient_ring_element</a> : thm
<a name="line315"></a>    val <a href="#quotient_ring_has_ideal-val">quotient_ring_has_ideal</a> : thm
<a name="line316"></a>    val <a href="#quotient_ring_homo-val">quotient_ring_homo</a> : thm
<a name="line317"></a>    val <a href="#quotient_ring_homo_kernel-val">quotient_ring_homo_kernel</a> : thm
<a name="line318"></a>    val <a href="#quotient_ring_homo_kernel_ideal-val">quotient_ring_homo_kernel_ideal</a> : thm
<a name="line319"></a>    val <a href="#quotient_ring_homo_surj-val">quotient_ring_homo_surj</a> : thm
<a name="line320"></a>    val <a href="#quotient_ring_mult_abelian_monoid-val">quotient_ring_mult_abelian_monoid</a> : thm
<a name="line321"></a>    val <a href="#quotient_ring_mult_assoc-val">quotient_ring_mult_assoc</a> : thm
<a name="line322"></a>    val <a href="#quotient_ring_mult_comm-val">quotient_ring_mult_comm</a> : thm
<a name="line323"></a>    val <a href="#quotient_ring_mult_element-val">quotient_ring_mult_element</a> : thm
<a name="line324"></a>    val <a href="#quotient_ring_mult_id-val">quotient_ring_mult_id</a> : thm
<a name="line325"></a>    val <a href="#quotient_ring_mult_ladd-val">quotient_ring_mult_ladd</a> : thm
<a name="line326"></a>    val <a href="#quotient_ring_mult_monoid-val">quotient_ring_mult_monoid</a> : thm
<a name="line327"></a>    val <a href="#quotient_ring_property-val">quotient_ring_property</a> : thm
<a name="line328"></a>    val <a href="#quotient_ring_ring-val">quotient_ring_ring</a> : thm
<a name="line329"></a>    val <a href="#quotient_ring_ring_sing-val">quotient_ring_ring_sing</a> : thm
<a name="line330"></a>    val <a href="#ring_11-val">ring_11</a> : thm
<a name="line331"></a>    val <a href="#ring_Axiom-val">ring_Axiom</a> : thm
<a name="line332"></a>    val <a href="#ring_accessors-val">ring_accessors</a> : thm
<a name="line333"></a>    val <a href="#ring_accfupds-val">ring_accfupds</a> : thm
<a name="line334"></a>    val <a href="#ring_add_abelian_group-val">ring_add_abelian_group</a> : thm
<a name="line335"></a>    val <a href="#ring_add_assoc-val">ring_add_assoc</a> : thm
<a name="line336"></a>    val <a href="#ring_add_assoc_comm-val">ring_add_assoc_comm</a> : thm
<a name="line337"></a>    val <a href="#ring_add_char_2-val">ring_add_char_2</a> : thm
<a name="line338"></a>    val <a href="#ring_add_comm-val">ring_add_comm</a> : thm
<a name="line339"></a>    val <a href="#ring_add_element-val">ring_add_element</a> : thm
<a name="line340"></a>    val <a href="#ring_add_eq_zero-val">ring_add_eq_zero</a> : thm
<a name="line341"></a>    val <a href="#ring_add_exp_eqn-val">ring_add_exp_eqn</a> : thm
<a name="line342"></a>    val <a href="#ring_add_group-val">ring_add_group</a> : thm
<a name="line343"></a>    val <a href="#ring_add_group_rwt-val">ring_add_group_rwt</a> : thm
<a name="line344"></a>    val <a href="#ring_add_lcancel-val">ring_add_lcancel</a> : thm
<a name="line345"></a>    val <a href="#ring_add_lneg-val">ring_add_lneg</a> : thm
<a name="line346"></a>    val <a href="#ring_add_lneg_assoc-val">ring_add_lneg_assoc</a> : thm
<a name="line347"></a>    val <a href="#ring_add_lzero-val">ring_add_lzero</a> : thm
<a name="line348"></a>    val <a href="#ring_add_pair_sub-val">ring_add_pair_sub</a> : thm
<a name="line349"></a>    val <a href="#ring_add_rcancel-val">ring_add_rcancel</a> : thm
<a name="line350"></a>    val <a href="#ring_add_rneg-val">ring_add_rneg</a> : thm
<a name="line351"></a>    val <a href="#ring_add_rneg_assoc-val">ring_add_rneg_assoc</a> : thm
<a name="line352"></a>    val <a href="#ring_add_rzero-val">ring_add_rzero</a> : thm
<a name="line353"></a>    val <a href="#ring_add_sub-val">ring_add_sub</a> : thm
<a name="line354"></a>    val <a href="#ring_add_sub_assoc-val">ring_add_sub_assoc</a> : thm
<a name="line355"></a>    val <a href="#ring_add_sub_comm-val">ring_add_sub_comm</a> : thm
<a name="line356"></a>    val <a href="#ring_add_sub_identity-val">ring_add_sub_identity</a> : thm
<a name="line357"></a>    val <a href="#ring_add_zero_zero-val">ring_add_zero_zero</a> : thm
<a name="line358"></a>    val <a href="#ring_associates_divides-val">ring_associates_divides</a> : thm
<a name="line359"></a>    val <a href="#ring_associates_mult-val">ring_associates_mult</a> : thm
<a name="line360"></a>    val <a href="#ring_associates_refl-val">ring_associates_refl</a> : thm
<a name="line361"></a>    val <a href="#ring_associates_sym-val">ring_associates_sym</a> : thm
<a name="line362"></a>    val <a href="#ring_associates_trans-val">ring_associates_trans</a> : thm
<a name="line363"></a>    val <a href="#ring_auto_I-val">ring_auto_I</a> : thm
<a name="line364"></a>    val <a href="#ring_auto_bij-val">ring_auto_bij</a> : thm
<a name="line365"></a>    val <a href="#ring_auto_cong-val">ring_auto_cong</a> : thm
<a name="line366"></a>    val <a href="#ring_auto_element-val">ring_auto_element</a> : thm
<a name="line367"></a>    val <a href="#ring_auto_ids-val">ring_auto_ids</a> : thm
<a name="line368"></a>    val <a href="#ring_auto_linv_auto-val">ring_auto_linv_auto</a> : thm
<a name="line369"></a>    val <a href="#ring_auto_one-val">ring_auto_one</a> : thm
<a name="line370"></a>    val <a href="#ring_auto_zero-val">ring_auto_zero</a> : thm
<a name="line371"></a>    val <a href="#ring_binomial_2-val">ring_binomial_2</a> : thm
<a name="line372"></a>    val <a href="#ring_binomial_3-val">ring_binomial_3</a> : thm
<a name="line373"></a>    val <a href="#ring_binomial_4-val">ring_binomial_4</a> : thm
<a name="line374"></a>    val <a href="#ring_binomial_genlist_index_shift-val">ring_binomial_genlist_index_shift</a> : thm
<a name="line375"></a>    val <a href="#ring_binomial_index_shift-val">ring_binomial_index_shift</a> : thm
<a name="line376"></a>    val <a href="#ring_binomial_term_merge_x-val">ring_binomial_term_merge_x</a> : thm
<a name="line377"></a>    val <a href="#ring_binomial_term_merge_y-val">ring_binomial_term_merge_y</a> : thm
<a name="line378"></a>    val <a href="#ring_binomial_thm-val">ring_binomial_thm</a> : thm
<a name="line379"></a>    val <a href="#ring_carrier_nonempty-val">ring_carrier_nonempty</a> : thm
<a name="line380"></a>    val <a href="#ring_carriers-val">ring_carriers</a> : thm
<a name="line381"></a>    val <a href="#ring_case_cong-val">ring_case_cong</a> : thm
<a name="line382"></a>    val <a href="#ring_case_eq-val">ring_case_eq</a> : thm
<a name="line383"></a>    val <a href="#ring_char_0-val">ring_char_0</a> : thm
<a name="line384"></a>    val <a href="#ring_char_1-val">ring_char_1</a> : thm
<a name="line385"></a>    val <a href="#ring_char_2_double-val">ring_char_2_double</a> : thm
<a name="line386"></a>    val <a href="#ring_char_2_neg_one-val">ring_char_2_neg_one</a> : thm
<a name="line387"></a>    val <a href="#ring_char_2_property-val">ring_char_2_property</a> : thm
<a name="line388"></a>    val <a href="#ring_char_alt-val">ring_char_alt</a> : thm
<a name="line389"></a>    val <a href="#ring_char_divides-val">ring_char_divides</a> : thm
<a name="line390"></a>    val <a href="#ring_char_eq_1-val">ring_char_eq_1</a> : thm
<a name="line391"></a>    val <a href="#ring_char_prime-val">ring_char_prime</a> : thm
<a name="line392"></a>    val <a href="#ring_char_prime_endo-val">ring_char_prime_endo</a> : thm
<a name="line393"></a>    val <a href="#ring_component_equality-val">ring_component_equality</a> : thm
<a name="line394"></a>    val <a href="#ring_divides_associates-val">ring_divides_associates</a> : thm
<a name="line395"></a>    val <a href="#ring_divides_by_one-val">ring_divides_by_one</a> : thm
<a name="line396"></a>    val <a href="#ring_divides_by_unit-val">ring_divides_by_unit</a> : thm
<a name="line397"></a>    val <a href="#ring_divides_iso-val">ring_divides_iso</a> : thm
<a name="line398"></a>    val <a href="#ring_divides_le-val">ring_divides_le</a> : thm
<a name="line399"></a>    val <a href="#ring_divides_refl-val">ring_divides_refl</a> : thm
<a name="line400"></a>    val <a href="#ring_divides_trans-val">ring_divides_trans</a> : thm
<a name="line401"></a>    val <a href="#ring_divides_zero-val">ring_divides_zero</a> : thm
<a name="line402"></a>    val <a href="#ring_eq_unit_eq-val">ring_eq_unit_eq</a> : thm
<a name="line403"></a>    val <a href="#ring_exp_0-val">ring_exp_0</a> : thm
<a name="line404"></a>    val <a href="#ring_exp_1-val">ring_exp_1</a> : thm
<a name="line405"></a>    val <a href="#ring_exp_SUC-val">ring_exp_SUC</a> : thm
<a name="line406"></a>    val <a href="#ring_exp_add-val">ring_exp_add</a> : thm
<a name="line407"></a>    val <a href="#ring_exp_add_assoc-val">ring_exp_add_assoc</a> : thm
<a name="line408"></a>    val <a href="#ring_exp_comm-val">ring_exp_comm</a> : thm
<a name="line409"></a>    val <a href="#ring_exp_element-val">ring_exp_element</a> : thm
<a name="line410"></a>    val <a href="#ring_exp_mod_order-val">ring_exp_mod_order</a> : thm
<a name="line411"></a>    val <a href="#ring_exp_mult-val">ring_exp_mult</a> : thm
<a name="line412"></a>    val <a href="#ring_exp_mult_comm-val">ring_exp_mult_comm</a> : thm
<a name="line413"></a>    val <a href="#ring_exp_neg-val">ring_exp_neg</a> : thm
<a name="line414"></a>    val <a href="#ring_exp_small-val">ring_exp_small</a> : thm
<a name="line415"></a>    val <a href="#ring_exp_suc-val">ring_exp_suc</a> : thm
<a name="line416"></a>    val <a href="#ring_factor_multiple-val">ring_factor_multiple</a> : thm
<a name="line417"></a>    val <a href="#ring_fermat_all-val">ring_fermat_all</a> : thm
<a name="line418"></a>    val <a href="#ring_fermat_thm-val">ring_fermat_thm</a> : thm
<a name="line419"></a>    val <a href="#ring_first_isomorphism_thm-val">ring_first_isomorphism_thm</a> : thm
<a name="line420"></a>    val <a href="#ring_fn_updates-val">ring_fn_updates</a> : thm
<a name="line421"></a>    val <a href="#ring_freshman_all-val">ring_freshman_all</a> : thm
<a name="line422"></a>    val <a href="#ring_freshman_all_sub-val">ring_freshman_all_sub</a> : thm
<a name="line423"></a>    val <a href="#ring_freshman_thm-val">ring_freshman_thm</a> : thm
<a name="line424"></a>    val <a href="#ring_freshman_thm_sub-val">ring_freshman_thm_sub</a> : thm
<a name="line425"></a>    val <a href="#ring_fun_add-val">ring_fun_add</a> : thm
<a name="line426"></a>    val <a href="#ring_fun_from_ring_fun-val">ring_fun_from_ring_fun</a> : thm
<a name="line427"></a>    val <a href="#ring_fun_from_ring_fun_exp-val">ring_fun_from_ring_fun_exp</a> : thm
<a name="line428"></a>    val <a href="#ring_fun_genlist-val">ring_fun_genlist</a> : thm
<a name="line429"></a>    val <a href="#ring_fun_map-val">ring_fun_map</a> : thm
<a name="line430"></a>    val <a href="#ring_fupdcanon-val">ring_fupdcanon</a> : thm
<a name="line431"></a>    val <a href="#ring_fupdcanon_comp-val">ring_fupdcanon_comp</a> : thm
<a name="line432"></a>    val <a href="#ring_fupdfupds-val">ring_fupdfupds</a> : thm
<a name="line433"></a>    val <a href="#ring_fupdfupds_comp-val">ring_fupdfupds_comp</a> : thm
<a name="line434"></a>    val <a href="#ring_gcd_divides-val">ring_gcd_divides</a> : thm
<a name="line435"></a>    val <a href="#ring_gcd_element-val">ring_gcd_element</a> : thm
<a name="line436"></a>    val <a href="#ring_gcd_is_gcd-val">ring_gcd_is_gcd</a> : thm
<a name="line437"></a>    val <a href="#ring_gcd_linear-val">ring_gcd_linear</a> : thm
<a name="line438"></a>    val <a href="#ring_gcd_property-val">ring_gcd_property</a> : thm
<a name="line439"></a>    val <a href="#ring_gcd_sym-val">ring_gcd_sym</a> : thm
<a name="line440"></a>    val <a href="#ring_gcd_zero-val">ring_gcd_zero</a> : thm
<a name="line441"></a>    val <a href="#ring_homo_I_refl-val">ring_homo_I_refl</a> : thm
<a name="line442"></a>    val <a href="#ring_homo_add-val">ring_homo_add</a> : thm
<a name="line443"></a>    val <a href="#ring_homo_char_divides-val">ring_homo_char_divides</a> : thm
<a name="line444"></a>    val <a href="#ring_homo_compose-val">ring_homo_compose</a> : thm
<a name="line445"></a>    val <a href="#ring_homo_cong-val">ring_homo_cong</a> : thm
<a name="line446"></a>    val <a href="#ring_homo_element-val">ring_homo_element</a> : thm
<a name="line447"></a>    val <a href="#ring_homo_eq_zero-val">ring_homo_eq_zero</a> : thm
<a name="line448"></a>    val <a href="#ring_homo_exp-val">ring_homo_exp</a> : thm
<a name="line449"></a>    val <a href="#ring_homo_ideal_group-val">ring_homo_ideal_group</a> : thm
<a name="line450"></a>    val <a href="#ring_homo_ideal_ideal-val">ring_homo_ideal_ideal</a> : thm
<a name="line451"></a>    val <a href="#ring_homo_ideal_subgroup-val">ring_homo_ideal_subgroup</a> : thm
<a name="line452"></a>    val <a href="#ring_homo_ids-val">ring_homo_ids</a> : thm
<a name="line453"></a>    val <a href="#ring_homo_image_bij-val">ring_homo_image_bij</a> : thm
<a name="line454"></a>    val <a href="#ring_homo_image_carrier-val">ring_homo_image_carrier</a> : thm
<a name="line455"></a>    val <a href="#ring_homo_image_homo-val">ring_homo_image_homo</a> : thm
<a name="line456"></a>    val <a href="#ring_homo_image_is_subring-val">ring_homo_image_is_subring</a> : thm
<a name="line457"></a>    val <a href="#ring_homo_image_iso-val">ring_homo_image_iso</a> : thm
<a name="line458"></a>    val <a href="#ring_homo_image_ring-val">ring_homo_image_ring</a> : thm
<a name="line459"></a>    val <a href="#ring_homo_image_subring-val">ring_homo_image_subring</a> : thm
<a name="line460"></a>    val <a href="#ring_homo_image_subring_subring-val">ring_homo_image_subring_subring</a> : thm
<a name="line461"></a>    val <a href="#ring_homo_image_surj_property-val">ring_homo_image_surj_property</a> : thm
<a name="line462"></a>    val <a href="#ring_homo_inv-val">ring_homo_inv</a> : thm
<a name="line463"></a>    val <a href="#ring_homo_kernel_ideal-val">ring_homo_kernel_ideal</a> : thm
<a name="line464"></a>    val <a href="#ring_homo_linv_homo-val">ring_homo_linv_homo</a> : thm
<a name="line465"></a>    val <a href="#ring_homo_mult-val">ring_homo_mult</a> : thm
<a name="line466"></a>    val <a href="#ring_homo_neg-val">ring_homo_neg</a> : thm
<a name="line467"></a>    val <a href="#ring_homo_num-val">ring_homo_num</a> : thm
<a name="line468"></a>    val <a href="#ring_homo_num_nonzero-val">ring_homo_num_nonzero</a> : thm
<a name="line469"></a>    val <a href="#ring_homo_one-val">ring_homo_one</a> : thm
<a name="line470"></a>    val <a href="#ring_homo_one_eq_zero-val">ring_homo_one_eq_zero</a> : thm
<a name="line471"></a>    val <a href="#ring_homo_property-val">ring_homo_property</a> : thm
<a name="line472"></a>    val <a href="#ring_homo_ring_homo_subring-val">ring_homo_ring_homo_subring</a> : thm
<a name="line473"></a>    val <a href="#ring_homo_sub-val">ring_homo_sub</a> : thm
<a name="line474"></a>    val <a href="#ring_homo_subring_homo-val">ring_homo_subring_homo</a> : thm
<a name="line475"></a>    val <a href="#ring_homo_sum_num_property-val">ring_homo_sum_num_property</a> : thm
<a name="line476"></a>    val <a href="#ring_homo_sym-val">ring_homo_sym</a> : thm
<a name="line477"></a>    val <a href="#ring_homo_sym_any-val">ring_homo_sym_any</a> : thm
<a name="line478"></a>    val <a href="#ring_homo_trans-val">ring_homo_trans</a> : thm
<a name="line479"></a>    val <a href="#ring_homo_unit-val">ring_homo_unit</a> : thm
<a name="line480"></a>    val <a href="#ring_homo_unit_inv-val">ring_homo_unit_inv</a> : thm
<a name="line481"></a>    val <a href="#ring_homo_unit_inv_element-val">ring_homo_unit_inv_element</a> : thm
<a name="line482"></a>    val <a href="#ring_homo_unit_inv_nonzero-val">ring_homo_unit_inv_nonzero</a> : thm
<a name="line483"></a>    val <a href="#ring_homo_unit_nonzero-val">ring_homo_unit_nonzero</a> : thm
<a name="line484"></a>    val <a href="#ring_homo_zero-val">ring_homo_zero</a> : thm
<a name="line485"></a>    val <a href="#ring_induction-val">ring_induction</a> : thm
<a name="line486"></a>    val <a href="#ring_inj_image_alt-val">ring_inj_image_alt</a> : thm
<a name="line487"></a>    val <a href="#ring_inj_image_carrier-val">ring_inj_image_carrier</a> : thm
<a name="line488"></a>    val <a href="#ring_inj_image_prod_abelian_monoid-val">ring_inj_image_prod_abelian_monoid</a> : thm
<a name="line489"></a>    val <a href="#ring_inj_image_prod_monoid-val">ring_inj_image_prod_monoid</a> : thm
<a name="line490"></a>    val <a href="#ring_inj_image_prod_monoid_homo-val">ring_inj_image_prod_monoid_homo</a> : thm
<a name="line491"></a>    val <a href="#ring_inj_image_ring-val">ring_inj_image_ring</a> : thm
<a name="line492"></a>    val <a href="#ring_inj_image_ring_homo-val">ring_inj_image_ring_homo</a> : thm
<a name="line493"></a>    val <a href="#ring_inj_image_sum_abelian_group-val">ring_inj_image_sum_abelian_group</a> : thm
<a name="line494"></a>    val <a href="#ring_inj_image_sum_group-val">ring_inj_image_sum_group</a> : thm
<a name="line495"></a>    val <a href="#ring_inj_image_sum_group_homo-val">ring_inj_image_sum_group_homo</a> : thm
<a name="line496"></a>    val <a href="#ring_inj_image_sum_monoid-val">ring_inj_image_sum_monoid</a> : thm
<a name="line497"></a>    val <a href="#ring_inv_one-val">ring_inv_one</a> : thm
<a name="line498"></a>    val <a href="#ring_irreducible_gcd-val">ring_irreducible_gcd</a> : thm
<a name="line499"></a>    val <a href="#ring_iso_I_refl-val">ring_iso_I_refl</a> : thm
<a name="line500"></a>    val <a href="#ring_iso_add-val">ring_iso_add</a> : thm
<a name="line501"></a>    val <a href="#ring_iso_bij-val">ring_iso_bij</a> : thm
<a name="line502"></a>    val <a href="#ring_iso_card_eq-val">ring_iso_card_eq</a> : thm
<a name="line503"></a>    val <a href="#ring_iso_char_eq-val">ring_iso_char_eq</a> : thm
<a name="line504"></a>    val <a href="#ring_iso_compose-val">ring_iso_compose</a> : thm
<a name="line505"></a>    val <a href="#ring_iso_cong-val">ring_iso_cong</a> : thm
<a name="line506"></a>    val <a href="#ring_iso_element-val">ring_iso_element</a> : thm
<a name="line507"></a>    val <a href="#ring_iso_element_unique-val">ring_iso_element_unique</a> : thm
<a name="line508"></a>    val <a href="#ring_iso_eq_one-val">ring_iso_eq_one</a> : thm
<a name="line509"></a>    val <a href="#ring_iso_eq_zero-val">ring_iso_eq_zero</a> : thm
<a name="line510"></a>    val <a href="#ring_iso_exp-val">ring_iso_exp</a> : thm
<a name="line511"></a>    val <a href="#ring_iso_ids-val">ring_iso_ids</a> : thm
<a name="line512"></a>    val <a href="#ring_iso_inv-val">ring_iso_inv</a> : thm
<a name="line513"></a>    val <a href="#ring_iso_inverse-val">ring_iso_inverse</a> : thm
<a name="line514"></a>    val <a href="#ring_iso_inverse_element-val">ring_iso_inverse_element</a> : thm
<a name="line515"></a>    val <a href="#ring_iso_linv_iso-val">ring_iso_linv_iso</a> : thm
<a name="line516"></a>    val <a href="#ring_iso_mult-val">ring_iso_mult</a> : thm
<a name="line517"></a>    val <a href="#ring_iso_neg-val">ring_iso_neg</a> : thm
<a name="line518"></a>    val <a href="#ring_iso_nonzero-val">ring_iso_nonzero</a> : thm
<a name="line519"></a>    val <a href="#ring_iso_num-val">ring_iso_num</a> : thm
<a name="line520"></a>    val <a href="#ring_iso_one-val">ring_iso_one</a> : thm
<a name="line521"></a>    val <a href="#ring_iso_property-val">ring_iso_property</a> : thm
<a name="line522"></a>    val <a href="#ring_iso_ring_homo_subring-val">ring_iso_ring_homo_subring</a> : thm
<a name="line523"></a>    val <a href="#ring_iso_sub-val">ring_iso_sub</a> : thm
<a name="line524"></a>    val <a href="#ring_iso_subring_iso-val">ring_iso_subring_iso</a> : thm
<a name="line525"></a>    val <a href="#ring_iso_sym-val">ring_iso_sym</a> : thm
<a name="line526"></a>    val <a href="#ring_iso_sym_any-val">ring_iso_sym_any</a> : thm
<a name="line527"></a>    val <a href="#ring_iso_trans-val">ring_iso_trans</a> : thm
<a name="line528"></a>    val <a href="#ring_iso_unit-val">ring_iso_unit</a> : thm
<a name="line529"></a>    val <a href="#ring_iso_zero-val">ring_iso_zero</a> : thm
<a name="line530"></a>    val <a href="#ring_list_SNOC-val">ring_list_SNOC</a> : thm
<a name="line531"></a>    val <a href="#ring_list_cons-val">ring_list_cons</a> : thm
<a name="line532"></a>    val <a href="#ring_list_from_genlist-val">ring_list_from_genlist</a> : thm
<a name="line533"></a>    val <a href="#ring_list_from_genlist_ring_fun-val">ring_list_from_genlist_ring_fun</a> : thm
<a name="line534"></a>    val <a href="#ring_list_front_last-val">ring_list_front_last</a> : thm
<a name="line535"></a>    val <a href="#ring_list_gen_from_ring_fun-val">ring_list_gen_from_ring_fun</a> : thm
<a name="line536"></a>    val <a href="#ring_list_nil-val">ring_list_nil</a> : thm
<a name="line537"></a>    val <a href="#ring_literal_11-val">ring_literal_11</a> : thm
<a name="line538"></a>    val <a href="#ring_literal_nchotomy-val">ring_literal_nchotomy</a> : thm
<a name="line539"></a>    val <a href="#ring_mult_abelian_monoid-val">ring_mult_abelian_monoid</a> : thm
<a name="line540"></a>    val <a href="#ring_mult_add-val">ring_mult_add</a> : thm
<a name="line541"></a>    val <a href="#ring_mult_add_neg-val">ring_mult_add_neg</a> : thm
<a name="line542"></a>    val <a href="#ring_mult_add_neg_assoc-val">ring_mult_add_neg_assoc</a> : thm
<a name="line543"></a>    val <a href="#ring_mult_add_neg_mult-val">ring_mult_add_neg_mult</a> : thm
<a name="line544"></a>    val <a href="#ring_mult_add_neg_mult_assoc-val">ring_mult_add_neg_mult_assoc</a> : thm
<a name="line545"></a>    val <a href="#ring_mult_assoc-val">ring_mult_assoc</a> : thm
<a name="line546"></a>    val <a href="#ring_mult_assoc_comm-val">ring_mult_assoc_comm</a> : thm
<a name="line547"></a>    val <a href="#ring_mult_comm-val">ring_mult_comm</a> : thm
<a name="line548"></a>    val <a href="#ring_mult_divides-val">ring_mult_divides</a> : thm
<a name="line549"></a>    val <a href="#ring_mult_element-val">ring_mult_element</a> : thm
<a name="line550"></a>    val <a href="#ring_mult_exp-val">ring_mult_exp</a> : thm
<a name="line551"></a>    val <a href="#ring_mult_ladd-val">ring_mult_ladd</a> : thm
<a name="line552"></a>    val <a href="#ring_mult_lneg-val">ring_mult_lneg</a> : thm
<a name="line553"></a>    val <a href="#ring_mult_lone-val">ring_mult_lone</a> : thm
<a name="line554"></a>    val <a href="#ring_mult_lsub-val">ring_mult_lsub</a> : thm
<a name="line555"></a>    val <a href="#ring_mult_lzero-val">ring_mult_lzero</a> : thm
<a name="line556"></a>    val <a href="#ring_mult_monoid-val">ring_mult_monoid</a> : thm
<a name="line557"></a>    val <a href="#ring_mult_monoid_rwt-val">ring_mult_monoid_rwt</a> : thm
<a name="line558"></a>    val <a href="#ring_mult_neg_neg-val">ring_mult_neg_neg</a> : thm
<a name="line559"></a>    val <a href="#ring_mult_one_one-val">ring_mult_one_one</a> : thm
<a name="line560"></a>    val <a href="#ring_mult_pair_diff-val">ring_mult_pair_diff</a> : thm
<a name="line561"></a>    val <a href="#ring_mult_pair_sub-val">ring_mult_pair_sub</a> : thm
<a name="line562"></a>    val <a href="#ring_mult_radd-val">ring_mult_radd</a> : thm
<a name="line563"></a>    val <a href="#ring_mult_rneg-val">ring_mult_rneg</a> : thm
<a name="line564"></a>    val <a href="#ring_mult_rone-val">ring_mult_rone</a> : thm
<a name="line565"></a>    val <a href="#ring_mult_rsub-val">ring_mult_rsub</a> : thm
<a name="line566"></a>    val <a href="#ring_mult_rzero-val">ring_mult_rzero</a> : thm
<a name="line567"></a>    val <a href="#ring_mult_zero_zero-val">ring_mult_zero_zero</a> : thm
<a name="line568"></a>    val <a href="#ring_nchotomy-val">ring_nchotomy</a> : thm
<a name="line569"></a>    val <a href="#ring_neg_add-val">ring_neg_add</a> : thm
<a name="line570"></a>    val <a href="#ring_neg_add_comm-val">ring_neg_add_comm</a> : thm
<a name="line571"></a>    val <a href="#ring_neg_add_neg-val">ring_neg_add_neg</a> : thm
<a name="line572"></a>    val <a href="#ring_neg_add_neg_assoc-val">ring_neg_add_neg_assoc</a> : thm
<a name="line573"></a>    val <a href="#ring_neg_add_neg_mult-val">ring_neg_add_neg_mult</a> : thm
<a name="line574"></a>    val <a href="#ring_neg_add_neg_mult_assoc-val">ring_neg_add_neg_mult_assoc</a> : thm
<a name="line575"></a>    val <a href="#ring_neg_char_2-val">ring_neg_char_2</a> : thm
<a name="line576"></a>    val <a href="#ring_neg_element-val">ring_neg_element</a> : thm
<a name="line577"></a>    val <a href="#ring_neg_eq-val">ring_neg_eq</a> : thm
<a name="line578"></a>    val <a href="#ring_neg_eq_swap-val">ring_neg_eq_swap</a> : thm
<a name="line579"></a>    val <a href="#ring_neg_eq_zero-val">ring_neg_eq_zero</a> : thm
<a name="line580"></a>    val <a href="#ring_neg_exp-val">ring_neg_exp</a> : thm
<a name="line581"></a>    val <a href="#ring_neg_mult-val">ring_neg_mult</a> : thm
<a name="line582"></a>    val <a href="#ring_neg_mult_add_neg_mult-val">ring_neg_mult_add_neg_mult</a> : thm
<a name="line583"></a>    val <a href="#ring_neg_mult_add_neg_mult_assoc-val">ring_neg_mult_add_neg_mult_assoc</a> : thm
<a name="line584"></a>    val <a href="#ring_neg_neg-val">ring_neg_neg</a> : thm
<a name="line585"></a>    val <a href="#ring_neg_nonzero-val">ring_neg_nonzero</a> : thm
<a name="line586"></a>    val <a href="#ring_neg_one_eq_one-val">ring_neg_one_eq_one</a> : thm
<a name="line587"></a>    val <a href="#ring_neg_square-val">ring_neg_square</a> : thm
<a name="line588"></a>    val <a href="#ring_neg_sub-val">ring_neg_sub</a> : thm
<a name="line589"></a>    val <a href="#ring_neg_zero-val">ring_neg_zero</a> : thm
<a name="line590"></a>    val <a href="#ring_nonzero_element-val">ring_nonzero_element</a> : thm
<a name="line591"></a>    val <a href="#ring_nonzero_eq-val">ring_nonzero_eq</a> : thm
<a name="line592"></a>    val <a href="#ring_nonzero_mult_carrier-val">ring_nonzero_mult_carrier</a> : thm
<a name="line593"></a>    val <a href="#ring_num_0-val">ring_num_0</a> : thm
<a name="line594"></a>    val <a href="#ring_num_1-val">ring_num_1</a> : thm
<a name="line595"></a>    val <a href="#ring_num_2-val">ring_num_2</a> : thm
<a name="line596"></a>    val <a href="#ring_num_SUC-val">ring_num_SUC</a> : thm
<a name="line597"></a>    val <a href="#ring_num_add-val">ring_num_add</a> : thm
<a name="line598"></a>    val <a href="#ring_num_add_assoc-val">ring_num_add_assoc</a> : thm
<a name="line599"></a>    val <a href="#ring_num_add_mult-val">ring_num_add_mult</a> : thm
<a name="line600"></a>    val <a href="#ring_num_add_mult_assoc-val">ring_num_add_mult_assoc</a> : thm
<a name="line601"></a>    val <a href="#ring_num_all_zero-val">ring_num_all_zero</a> : thm
<a name="line602"></a>    val <a href="#ring_num_char_coprime_nonzero-val">ring_num_char_coprime_nonzero</a> : thm
<a name="line603"></a>    val <a href="#ring_num_element-val">ring_num_element</a> : thm
<a name="line604"></a>    val <a href="#ring_num_eq-val">ring_num_eq</a> : thm
<a name="line605"></a>    val <a href="#ring_num_exp-val">ring_num_exp</a> : thm
<a name="line606"></a>    val <a href="#ring_num_mod-val">ring_num_mod</a> : thm
<a name="line607"></a>    val <a href="#ring_num_mult-val">ring_num_mult</a> : thm
<a name="line608"></a>    val <a href="#ring_num_mult_assoc-val">ring_num_mult_assoc</a> : thm
<a name="line609"></a>    val <a href="#ring_num_mult_element-val">ring_num_mult_element</a> : thm
<a name="line610"></a>    val <a href="#ring_num_mult_exp-val">ring_num_mult_exp</a> : thm
<a name="line611"></a>    val <a href="#ring_num_mult_neg-val">ring_num_mult_neg</a> : thm
<a name="line612"></a>    val <a href="#ring_num_mult_radd-val">ring_num_mult_radd</a> : thm
<a name="line613"></a>    val <a href="#ring_num_mult_small-val">ring_num_mult_small</a> : thm
<a name="line614"></a>    val <a href="#ring_num_mult_suc-val">ring_num_mult_suc</a> : thm
<a name="line615"></a>    val <a href="#ring_num_negative-val">ring_num_negative</a> : thm
<a name="line616"></a>    val <a href="#ring_num_one-val">ring_num_one</a> : thm
<a name="line617"></a>    val <a href="#ring_num_sub-val">ring_num_sub</a> : thm
<a name="line618"></a>    val <a href="#ring_num_suc-val">ring_num_suc</a> : thm
<a name="line619"></a>    val <a href="#ring_one_element-val">ring_one_element</a> : thm
<a name="line620"></a>    val <a href="#ring_one_eq_zero-val">ring_one_eq_zero</a> : thm
<a name="line621"></a>    val <a href="#ring_one_exp-val">ring_one_exp</a> : thm
<a name="line622"></a>    val <a href="#ring_one_unique-val">ring_one_unique</a> : thm
<a name="line623"></a>    val <a href="#ring_prime_divides_product-val">ring_prime_divides_product</a> : thm
<a name="line624"></a>    val <a href="#ring_prime_iso-val">ring_prime_iso</a> : thm
<a name="line625"></a>    val <a href="#ring_product_factors_divide-val">ring_product_factors_divide</a> : thm
<a name="line626"></a>    val <a href="#ring_single_add_mult-val">ring_single_add_mult</a> : thm
<a name="line627"></a>    val <a href="#ring_single_add_mult_assoc-val">ring_single_add_mult_assoc</a> : thm
<a name="line628"></a>    val <a href="#ring_single_add_neg_mult-val">ring_single_add_neg_mult</a> : thm
<a name="line629"></a>    val <a href="#ring_single_add_neg_mult_assoc-val">ring_single_add_neg_mult_assoc</a> : thm
<a name="line630"></a>    val <a href="#ring_single_add_single-val">ring_single_add_single</a> : thm
<a name="line631"></a>    val <a href="#ring_single_add_single_assoc-val">ring_single_add_single_assoc</a> : thm
<a name="line632"></a>    val <a href="#ring_single_mult_exp-val">ring_single_mult_exp</a> : thm
<a name="line633"></a>    val <a href="#ring_single_mult_exp_assoc-val">ring_single_mult_exp_assoc</a> : thm
<a name="line634"></a>    val <a href="#ring_single_mult_single-val">ring_single_mult_single</a> : thm
<a name="line635"></a>    val <a href="#ring_single_mult_single_assoc-val">ring_single_mult_single_assoc</a> : thm
<a name="line636"></a>    val <a href="#ring_sub_add-val">ring_sub_add</a> : thm
<a name="line637"></a>    val <a href="#ring_sub_element-val">ring_sub_element</a> : thm
<a name="line638"></a>    val <a href="#ring_sub_eq-val">ring_sub_eq</a> : thm
<a name="line639"></a>    val <a href="#ring_sub_eq_add-val">ring_sub_eq_add</a> : thm
<a name="line640"></a>    val <a href="#ring_sub_eq_zero-val">ring_sub_eq_zero</a> : thm
<a name="line641"></a>    val <a href="#ring_sub_lcancel-val">ring_sub_lcancel</a> : thm
<a name="line642"></a>    val <a href="#ring_sub_pair_reduce-val">ring_sub_pair_reduce</a> : thm
<a name="line643"></a>    val <a href="#ring_sub_rcancel-val">ring_sub_rcancel</a> : thm
<a name="line644"></a>    val <a href="#ring_sub_zero-val">ring_sub_zero</a> : thm
<a name="line645"></a>    val <a href="#ring_sum_SNOC-val">ring_sum_SNOC</a> : thm
<a name="line646"></a>    val <a href="#ring_sum_append-val">ring_sum_append</a> : thm
<a name="line647"></a>    val <a href="#ring_sum_cons-val">ring_sum_cons</a> : thm
<a name="line648"></a>    val <a href="#ring_sum_decompose_first-val">ring_sum_decompose_first</a> : thm
<a name="line649"></a>    val <a href="#ring_sum_decompose_first_last-val">ring_sum_decompose_first_last</a> : thm
<a name="line650"></a>    val <a href="#ring_sum_decompose_last-val">ring_sum_decompose_last</a> : thm
<a name="line651"></a>    val <a href="#ring_sum_element-val">ring_sum_element</a> : thm
<a name="line652"></a>    val <a href="#ring_sum_freshman_all-val">ring_sum_freshman_all</a> : thm
<a name="line653"></a>    val <a href="#ring_sum_freshman_thm-val">ring_sum_freshman_thm</a> : thm
<a name="line654"></a>    val <a href="#ring_sum_fun_zero-val">ring_sum_fun_zero</a> : thm
<a name="line655"></a>    val <a href="#ring_sum_genlist_add-val">ring_sum_genlist_add</a> : thm
<a name="line656"></a>    val <a href="#ring_sum_genlist_append-val">ring_sum_genlist_append</a> : thm
<a name="line657"></a>    val <a href="#ring_sum_genlist_const-val">ring_sum_genlist_const</a> : thm
<a name="line658"></a>    val <a href="#ring_sum_genlist_sum-val">ring_sum_genlist_sum</a> : thm
<a name="line659"></a>    val <a href="#ring_sum_mult-val">ring_sum_mult</a> : thm
<a name="line660"></a>    val <a href="#ring_sum_mult_ladd-val">ring_sum_mult_ladd</a> : thm
<a name="line661"></a>    val <a href="#ring_sum_nil-val">ring_sum_nil</a> : thm
<a name="line662"></a>    val <a href="#ring_sum_sing-val">ring_sum_sing</a> : thm
<a name="line663"></a>    val <a href="#ring_sum_zero-val">ring_sum_zero</a> : thm
<a name="line664"></a>    val <a href="#ring_unit_element-val">ring_unit_element</a> : thm
<a name="line665"></a>    val <a href="#ring_unit_has_inv-val">ring_unit_has_inv</a> : thm
<a name="line666"></a>    val <a href="#ring_unit_inv_element-val">ring_unit_inv_element</a> : thm
<a name="line667"></a>    val <a href="#ring_unit_inv_inv-val">ring_unit_inv_inv</a> : thm
<a name="line668"></a>    val <a href="#ring_unit_inv_nonzero-val">ring_unit_inv_nonzero</a> : thm
<a name="line669"></a>    val <a href="#ring_unit_linv-val">ring_unit_linv</a> : thm
<a name="line670"></a>    val <a href="#ring_unit_linv_inv-val">ring_unit_linv_inv</a> : thm
<a name="line671"></a>    val <a href="#ring_unit_linv_unique-val">ring_unit_linv_unique</a> : thm
<a name="line672"></a>    val <a href="#ring_unit_mult_eq_unit-val">ring_unit_mult_eq_unit</a> : thm
<a name="line673"></a>    val <a href="#ring_unit_mult_unit-val">ring_unit_mult_unit</a> : thm
<a name="line674"></a>    val <a href="#ring_unit_mult_zero-val">ring_unit_mult_zero</a> : thm
<a name="line675"></a>    val <a href="#ring_unit_neg-val">ring_unit_neg</a> : thm
<a name="line676"></a>    val <a href="#ring_unit_nonzero-val">ring_unit_nonzero</a> : thm
<a name="line677"></a>    val <a href="#ring_unit_one-val">ring_unit_one</a> : thm
<a name="line678"></a>    val <a href="#ring_unit_property-val">ring_unit_property</a> : thm
<a name="line679"></a>    val <a href="#ring_unit_rinv-val">ring_unit_rinv</a> : thm
<a name="line680"></a>    val <a href="#ring_unit_rinv_inv-val">ring_unit_rinv_inv</a> : thm
<a name="line681"></a>    val <a href="#ring_unit_rinv_unique-val">ring_unit_rinv_unique</a> : thm
<a name="line682"></a>    val <a href="#ring_unit_zero-val">ring_unit_zero</a> : thm
<a name="line683"></a>    val <a href="#ring_units_abelain_group-val">ring_units_abelain_group</a> : thm
<a name="line684"></a>    val <a href="#ring_units_element-val">ring_units_element</a> : thm
<a name="line685"></a>    val <a href="#ring_units_group-val">ring_units_group</a> : thm
<a name="line686"></a>    val <a href="#ring_units_has_one-val">ring_units_has_one</a> : thm
<a name="line687"></a>    val <a href="#ring_units_has_zero-val">ring_units_has_zero</a> : thm
<a name="line688"></a>    val <a href="#ring_units_property-val">ring_units_property</a> : thm
<a name="line689"></a>    val <a href="#ring_updates_eq_literal-val">ring_updates_eq_literal</a> : thm
<a name="line690"></a>    val <a href="#ring_zero_divides-val">ring_zero_divides</a> : thm
<a name="line691"></a>    val <a href="#ring_zero_element-val">ring_zero_element</a> : thm
<a name="line692"></a>    val <a href="#ring_zero_exp-val">ring_zero_exp</a> : thm
<a name="line693"></a>    val <a href="#ring_zero_fix-val">ring_zero_fix</a> : thm
<a name="line694"></a>    val <a href="#ring_zero_sub-val">ring_zero_sub</a> : thm
<a name="line695"></a>    val <a href="#ring_zero_unique-val">ring_zero_unique</a> : thm
<a name="line696"></a>    val <a href="#subring_I_antisym-val">subring_I_antisym</a> : thm
<a name="line697"></a>    val <a href="#subring_add-val">subring_add</a> : thm
<a name="line698"></a>    val <a href="#subring_by_subgroup_submonoid-val">subring_by_subgroup_submonoid</a> : thm
<a name="line699"></a>    val <a href="#subring_carrier_antisym-val">subring_carrier_antisym</a> : thm
<a name="line700"></a>    val <a href="#subring_carrier_finite-val">subring_carrier_finite</a> : thm
<a name="line701"></a>    val <a href="#subring_carrier_subset-val">subring_carrier_subset</a> : thm
<a name="line702"></a>    val <a href="#subring_char-val">subring_char</a> : thm
<a name="line703"></a>    val <a href="#subring_char_divides-val">subring_char_divides</a> : thm
<a name="line704"></a>    val <a href="#subring_element-val">subring_element</a> : thm
<a name="line705"></a>    val <a href="#subring_element_alt-val">subring_element_alt</a> : thm
<a name="line706"></a>    val <a href="#subring_exp-val">subring_exp</a> : thm
<a name="line707"></a>    val <a href="#subring_finite_ring-val">subring_finite_ring</a> : thm
<a name="line708"></a>    val <a href="#subring_homo_homo-val">subring_homo_homo</a> : thm
<a name="line709"></a>    val <a href="#subring_ids-val">subring_ids</a> : thm
<a name="line710"></a>    val <a href="#subring_mult-val">subring_mult</a> : thm
<a name="line711"></a>    val <a href="#subring_neg-val">subring_neg</a> : thm
<a name="line712"></a>    val <a href="#subring_num-val">subring_num</a> : thm
<a name="line713"></a>    val <a href="#subring_one-val">subring_one</a> : thm
<a name="line714"></a>    val <a href="#subring_prod_submonoid-val">subring_prod_submonoid</a> : thm
<a name="line715"></a>    val <a href="#subring_property-val">subring_property</a> : thm
<a name="line716"></a>    val <a href="#subring_refl-val">subring_refl</a> : thm
<a name="line717"></a>    val <a href="#subring_ring_iso_compose-val">subring_ring_iso_compose</a> : thm
<a name="line718"></a>    val <a href="#subring_ring_iso_ring_homo_subring-val">subring_ring_iso_ring_homo_subring</a> : thm
<a name="line719"></a>    val <a href="#subring_sub-val">subring_sub</a> : thm
<a name="line720"></a>    val <a href="#subring_sum_subgroup-val">subring_sum_subgroup</a> : thm
<a name="line721"></a>    val <a href="#subring_trans-val">subring_trans</a> : thm
<a name="line722"></a>    val <a href="#subring_unit-val">subring_unit</a> : thm
<a name="line723"></a>    val <a href="#subring_unit_inv-val">subring_unit_inv</a> : thm
<a name="line724"></a>    val <a href="#subring_unit_inv_element-val">subring_unit_inv_element</a> : thm
<a name="line725"></a>    val <a href="#subring_unit_inv_nonzero-val">subring_unit_inv_nonzero</a> : thm
<a name="line726"></a>    val <a href="#subring_unit_nonzero-val">subring_unit_nonzero</a> : thm
<a name="line727"></a>    val <a href="#subring_zero-val">subring_zero</a> : thm
<a name="line728"></a>    val <a href="#symdiff_eval-val">symdiff_eval</a> : thm
<a name="line729"></a>    val <a href="#symdiff_set_inter_char-val">symdiff_set_inter_char</a> : thm
<a name="line730"></a>    val <a href="#symdiff_set_inter_ring-val">symdiff_set_inter_ring</a> : thm
<a name="line731"></a>    val <a href="#symdiff_univ_univ_eq_empty-val">symdiff_univ_univ_eq_empty</a> : thm
<a name="line732"></a>    val <a href="#trivial_char-val">trivial_char</a> : thm
<a name="line733"></a>    val <a href="#trivial_integral_domain-val">trivial_integral_domain</a> : thm
<a name="line734"></a>    val <a href="#trivial_ring-val">trivial_ring</a> : thm
<a name="line735"></a>    val <a href="#trivial_ring_thm-val">trivial_ring_thm</a> : thm
<a name="line736"></a>    val <a href="#unit_eq_refl-val">unit_eq_refl</a> : thm
<a name="line737"></a>    val <a href="#unit_eq_sym-val">unit_eq_sym</a> : thm
<a name="line738"></a>    val <a href="#unit_eq_trans-val">unit_eq_trans</a> : thm
<a name="line739"></a>    val <a href="#zero_ideal_ideal-val">zero_ideal_ideal</a> : thm
<a name="line740"></a>    val <a href="#zero_ideal_sing-val">zero_ideal_sing</a> : thm
<a name="line741"></a>(*
   [Omega] Parent theory of "ring"
   
   [container] Parent theory of "ring"
   
   [group] Parent theory of "ring"
   
   [<a name="EuclideanRing_def-val"><b>EuclideanRing_def</b></a>]  Definition
      
      ⊢ ∀r f.
          EuclideanRing r f ⇔
          Ring r ∧ (∀x. f x = 0 ⇔ x = #0) ∧
          ∀x y.
            x ∈ R ∧ y ∈ R ∧ y ≠ #0 ⇒
            ∃q t. q ∈ R ∧ t ∈ R ∧ x = q * y + t ∧ f t &lt; f y
   
   [<a name="FiniteIntegralDomain_def-val"><b>FiniteIntegralDomain_def</b></a>]  Definition
      
      ⊢ ∀r. FiniteIntegralDomain r ⇔ IntegralDomain r ∧ FINITE R
   
   [<a name="FiniteRing_def-val"><b>FiniteRing_def</b></a>]  Definition
      
      ⊢ ∀r. FiniteRing r ⇔ Ring r ∧ FINITE R
   
   [<a name="IntegralDomain_def-val"><b>IntegralDomain_def</b></a>]  Definition
      
      ⊢ ∀r. IntegralDomain r ⇔
            Ring r ∧ #1 ≠ #0 ∧
            ∀x y. x ∈ R ∧ y ∈ R ⇒ (x * y = #0 ⇔ x = #0 ∨ y = #0)
   
   [<a name="PrincipalIdealRing_def-val"><b>PrincipalIdealRing_def</b></a>]  Definition
      
      ⊢ ∀r. PrincipalIdealRing r ⇔
            Ring r ∧ ∀i. i &lt;&lt; r ⇒ ∃p. p ∈ R ∧ &lt;p&gt; = i
   
   [<a name="RingAuto_def-val"><b>RingAuto_def</b></a>]  Definition
      
      ⊢ ∀f r. RingAuto f r ⇔ RingIso f r r
   
   [<a name="RingEndo_def-val"><b>RingEndo_def</b></a>]  Definition
      
      ⊢ ∀f r. RingEndo f r ⇔ RingHomo f r r
   
   [<a name="RingHomo_def-val"><b>RingHomo_def</b></a>]  Definition
      
      ⊢ ∀f r s.
          RingHomo f r s ⇔
          (∀x. x ∈ R ⇒ f x ∈ s.carrier) ∧ GroupHomo f r.sum s.sum ∧
          MonoidHomo f r.prod s.prod
   
   [<a name="RingIso_def-val"><b>RingIso_def</b></a>]  Definition
      
      ⊢ ∀f r s. RingIso f r s ⇔ RingHomo f r s ∧ BIJ f R s.carrier
   
   [<a name="Ring_def-val"><b>Ring_def</b></a>]  Definition
      
      ⊢ ∀r. Ring r ⇔
            AbelianGroup r.sum ∧ AbelianMonoid r.prod ∧ r.sum.carrier = R ∧
            r.prod.carrier = R ∧
            ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ x * (y + z) = x * y + x * z
   
   [<a name="ZN_def-val"><b>ZN_def</b></a>]  Definition
      
      ⊢ ∀n. ZN n =
            &lt;|carrier := count n; sum := add_mod n; prod := times_mod n|&gt;
   
   [<a name="ZP_def-val"><b>ZP_def</b></a>]  Definition
      
      ⊢ ∀p. ZP p =
            &lt;|carrier := count p; sum := add_mod p; prod := times_mod p|&gt;
   
   [<a name="Z_add_def-val"><b>Z_add_def</b></a>]  Definition
      
      ⊢ Z_add = &lt;|carrier := 𝕌(:int); op := (λx y. x + y); id := 0|&gt;
   
   [<a name="Z_def-val"><b>Z_def</b></a>]  Definition
      
      ⊢ Z = &lt;|carrier := 𝕌(:int); sum := Z_add; prod := Z_mult|&gt;
   
   [<a name="Z_ideal_def-val"><b>Z_ideal_def</b></a>]  Definition
      
      ⊢ ∀n. Z* n =
            &lt;|carrier := Z_multiple n;
              sum :=
                &lt;|carrier := Z_multiple n; op := Z.sum.op; id := Z.sum.id|&gt;;
              prod :=
                &lt;|carrier := Z_multiple n; op := Z.prod.op;
                  id := Z.prod.id|&gt; |&gt;
   
   [<a name="Z_mult_def-val"><b>Z_mult_def</b></a>]  Definition
      
      ⊢ Z_mult = &lt;|carrier := 𝕌(:int); op := (λx y. x * y); id := 1|&gt;
   
   [<a name="Z_multiple_def-val"><b>Z_multiple_def</b></a>]  Definition
      
      ⊢ ∀n. Z_multiple n = {&n * z | z ∈ 𝕌(:int)}
   
   [<a name="char_def-val"><b>char_def</b></a>]  Definition
      
      ⊢ ∀r. char r = order r.sum #1
   
   [<a name="compute_ordz_def-val"><b>compute_ordz_def</b></a>]  Definition
      
      ⊢ ∀m n.
          compute_ordz m n =
          if m = 0 then ordz 0 n
          else if m = 1 then 1
          else if coprime m n then WHILE (λi. n ** i MOD m ≠ 1) SUC 1
          else 0
   
   [<a name="homo_ideal_def-val"><b>homo_ideal_def</b></a>]  Definition
      
      ⊢ ∀f r s i.
          homo_ideal f r s i =
          &lt;|carrier := IMAGE f I;
            sum := &lt;|carrier := IMAGE f I; op := s.sum.op; id := f #0|&gt;;
            prod := &lt;|carrier := IMAGE f I; op := s.prod.op; id := f #1|&gt; |&gt;
   
   [<a name="homo_ring_def-val"><b>homo_ring_def</b></a>]  Definition
      
      ⊢ ∀r f.
          homo_ring r f =
          &lt;|carrier := IMAGE f R; sum := homo_group r.sum f;
            prod := homo_group r.prod f|&gt;
   
   [<a name="ideal_congruence_def-val"><b>ideal_congruence_def</b></a>]  Definition
      
      ⊢ ∀r i x y. x === y ⇔ x − y ∈ I
   
   [<a name="ideal_coset_add_def-val"><b>ideal_coset_add_def</b></a>]  Definition
      
      ⊢ ∀r i x y. x + y = (gen x + gen y) ∘ I
   
   [<a name="ideal_coset_mult_def-val"><b>ideal_coset_mult_def</b></a>]  Definition
      
      ⊢ ∀r i x y. x * y = (gen x * gen y) ∘ I
   
   [<a name="ideal_def-val"><b>ideal_def</b></a>]  Definition
      
      ⊢ ∀i r.
          i &lt;&lt; r ⇔
          i.sum ≤ r.sum ∧ i.sum.carrier = I ∧ i.prod.carrier = I ∧
          i.prod.op = $* ∧ i.prod.id = #1 ∧
          ∀x y. x ∈ I ∧ y ∈ R ⇒ x * y ∈ I ∧ y * x ∈ I
   
   [<a name="ideal_gen_def-val"><b>ideal_gen_def</b></a>]  Definition
      
      ⊢ ∀r i f.
          Ring r ∧ i &lt;&lt; r ∧ i ≠ &lt;#0&gt; ∧ (∀x. f x = 0 ⇔ x = #0) ⇒
          ideal_gen r i f ∈ I ∧ ideal_gen r i f ≠ #0 ∧
          ∀z. z ∈ I ∧ z ≠ #0 ⇒ f (ideal_gen r i f) ≤ f z
   
   [<a name="ideal_maximal_def-val"><b>ideal_maximal_def</b></a>]  Definition
      
      ⊢ ∀r i. maxi i ⇔ i &lt;&lt; r ∧ ∀j. i &lt;&lt; j ∧ j &lt;&lt; r ⇒ i = j ∨ j = r
   
   [<a name="ideal_sum_def-val"><b>ideal_sum_def</b></a>]  Definition
      
      ⊢ ∀r i j.
          i + j =
          &lt;|carrier := {x + y | x ∈ I ∧ y ∈ J};
            sum :=
              &lt;|carrier := {x + y | x ∈ I ∧ y ∈ J}; op := $+; id := #0|&gt;;
            prod :=
              &lt;|carrier := {x + y | x ∈ I ∧ y ∈ J}; op := $*; id := #1|&gt; |&gt;
   
   [<a name="irreducible_def-val"><b>irreducible_def</b></a>]  Definition
      
      ⊢ ∀r z.
          atom z ⇔
          z ∈ R+ ∧ z ∉ R* ∧
          ∀x y. x ∈ R ∧ y ∈ R ∧ z = x * y ⇒ unit x ∨ unit y
   
   [<a name="kernel_ideal_def-val"><b>kernel_ideal_def</b></a>]  Definition
      
      ⊢ ∀f r s.
          kernel_ideal f r s =
          &lt;|carrier := kernel f r.sum s.sum;
            sum := &lt;|carrier := kernel f r.sum s.sum; op := $+; id := #0|&gt;;
            prod := &lt;|carrier := kernel f r.sum s.sum; op := $*; id := #1|&gt; |&gt;
   
   [<a name="monoid_of_ring_nonzero_mult_def-val"><b>monoid_of_ring_nonzero_mult_def</b></a>]  Definition
      
      ⊢ ∀r. monoid_of_ring_nonzero_mult r =
            &lt;|carrier := R+; op := $*; id := #1|&gt;
   
   [<a name="principal_ideal_def-val"><b>principal_ideal_def</b></a>]  Definition
      
      ⊢ ∀r p.
          &lt;p&gt; =
          &lt;|carrier := p * R;
            sum := &lt;|carrier := p * R; op := $+; id := #0|&gt;;
            prod := &lt;|carrier := p * R; op := $*; id := #1|&gt; |&gt;
   
   [<a name="quotient_ring_add_def-val"><b>quotient_ring_add_def</b></a>]  Definition
      
      ⊢ ∀r i.
          quotient_ring_add r i = &lt;|carrier := R/I; id := I; op := $+ |&gt;
   
   [<a name="quotient_ring_def-val"><b>quotient_ring_def</b></a>]  Definition
      
      ⊢ ∀r i.
          r / i =
          &lt;|carrier := R/I; sum := quotient_ring_add r i;
            prod := quotient_ring_mult r i|&gt;
   
   [<a name="quotient_ring_mult_def-val"><b>quotient_ring_mult_def</b></a>]  Definition
      
      ⊢ ∀r i.
          quotient_ring_mult r i =
          &lt;|carrier := R/I; id := #1 ∘ I; op := $* |&gt;
   
   [<a name="recordtype_ring_seldef_carrier_def-val"><b>recordtype_ring_seldef_carrier_def</b></a>]  Definition
      
      ⊢ ∀f m m0. (ring f m m0).carrier = f
   
   [<a name="recordtype_ring_seldef_carrier_fupd_def-val"><b>recordtype_ring_seldef_carrier_fupd_def</b></a>]  Definition
      
      ⊢ ∀f0 f m m0.
          ring f m m0 with carrier updated_by f0 = ring (f0 f) m m0
   
   [<a name="recordtype_ring_seldef_prod_def-val"><b>recordtype_ring_seldef_prod_def</b></a>]  Definition
      
      ⊢ ∀f m m0. (ring f m m0).prod = m0
   
   [<a name="recordtype_ring_seldef_prod_fupd_def-val"><b>recordtype_ring_seldef_prod_fupd_def</b></a>]  Definition
      
      ⊢ ∀f0 f m m0. ring f m m0 with prod updated_by f0 = ring f m (f0 m0)
   
   [<a name="recordtype_ring_seldef_sum_def-val"><b>recordtype_ring_seldef_sum_def</b></a>]  Definition
      
      ⊢ ∀f m m0. (ring f m m0).sum = m
   
   [<a name="recordtype_ring_seldef_sum_fupd_def-val"><b>recordtype_ring_seldef_sum_fupd_def</b></a>]  Definition
      
      ⊢ ∀f0 f m m0. ring f m m0 with sum updated_by f0 = ring f (f0 m) m0
   
   [<a name="ring_TY_DEF-val"><b>ring_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep.
          TYPE_DEFINITION
            (λa0'.
                 ∀ $var$('ring').
                   (∀a0'.
                      (∃a0 a1 a2.
                         a0' =
                         (λa0 a1 a2.
                              ind_type$CONSTR 0 (a0,a1,a2)
                                (λn. ind_type$BOTTOM)) a0 a1 a2) ⇒
                      $var$('ring') a0') ⇒
                   $var$('ring') a0') rep
   
   [<a name="ring_associates_def-val"><b>ring_associates_def</b></a>]  Definition
      
      ⊢ ∀r p q. rassoc p q ⇔ ∃s. unit s ∧ p = s * q
   
   [<a name="ring_case_def-val"><b>ring_case_def</b></a>]  Definition
      
      ⊢ ∀a0 a1 a2 f. ring_CASE (ring a0 a1 a2) f = f a0 a1 a2
   
   [<a name="ring_divides_def-val"><b>ring_divides_def</b></a>]  Definition
      
      ⊢ ∀r q p. q rdivides p ⇔ ∃s. s ∈ R ∧ p = s * q
   
   [<a name="ring_fun_def-val"><b>ring_fun_def</b></a>]  Definition
      
      ⊢ ∀r f. rfun f ⇔ ∀x. f x ∈ R
   
   [<a name="ring_gcd_def-val"><b>ring_gcd_def</b></a>]  Definition
      
      ⊢ ∀r f p q.
          rgcd p q =
          if p = #0 then q
          else if q = #0 then p
          else
            (let
               s =
                 {a * p + b * q |
                  (a,b) |
                  a ∈ R ∧ b ∈ R ∧ 0 &lt; f (a * p + b * q)}
             in
               CHOICE (preimage f s (MIN_SET (IMAGE f s))))
   
   [<a name="ring_homo_image_def-val"><b>ring_homo_image_def</b></a>]  Definition
      
      ⊢ ∀f r r_.
          ring_homo_image f r r_ =
          &lt;|carrier := IMAGE f R; sum := homo_image f r.sum r_.sum;
            prod := homo_image f r.prod r_.prod|&gt;
   
   [<a name="ring_inj_image_def-val"><b>ring_inj_image_def</b></a>]  Definition
      
      ⊢ ∀r f.
          ring_inj_image r f =
          &lt;|carrier := IMAGE f R;
            sum :=
              &lt;|carrier := IMAGE f R;
                op := (λx y. f (LINV f R x + LINV f R y)); id := f #0|&gt;;
            prod :=
              &lt;|carrier := IMAGE f R;
                op := (λx y. f (LINV f R x * LINV f R y)); id := f #1|&gt; |&gt;
   
   [<a name="ring_list_def-val"><b>ring_list_def</b></a>]  Definition
      
      ⊢ (∀r. rlist [] ⇔ T) ∧ ∀r h t. rlist (h::t) ⇔ h ∈ R ∧ rlist t
   
   [<a name="ring_nonzero_def-val"><b>ring_nonzero_def</b></a>]  Definition
      
      ⊢ ∀r. R+ = R DIFF {#0}
   
   [<a name="ring_ordering_def-val"><b>ring_ordering_def</b></a>]  Definition
      
      ⊢ ∀r f.
          ring_ordering r f ⇔
          ∀a b. a ∈ R ∧ b ∈ R ∧ b ≠ #0 ⇒ f a ≤ f (a * b)
   
   [<a name="ring_prime_def-val"><b>ring_prime_def</b></a>]  Definition
      
      ⊢ ∀r p.
          rprime p ⇔
          ∀a b.
            a ∈ R ∧ b ∈ R ∧ p rdivides a * b ⇒ p rdivides a ∨ p rdivides b
   
   [<a name="ring_size_def-val"><b>ring_size_def</b></a>]  Definition
      
      ⊢ ∀f a0 a1 a2.
          ring_size f (ring a0 a1 a2) =
          1 + (monoid_size f a1 + monoid_size f a2)
   
   [<a name="ring_sub_def-val"><b>ring_sub_def</b></a>]  Definition
      
      ⊢ ∀r x y. x − y = x + -y
   
   [<a name="ring_sum_def-val"><b>ring_sum_def</b></a>]  Definition
      
      ⊢ (∀r. rsum [] = #0) ∧ ∀r h t. rsum (h::t) = h + rsum t
   
   [<a name="subring_def-val"><b>subring_def</b></a>]  Definition
      
      ⊢ ∀s r. subring s r ⇔ RingHomo I s r
   
   [<a name="symdiff_set_inter_def-val"><b>symdiff_set_inter_def</b></a>]  Definition
      
      ⊢ symdiff_set_inter =
        &lt;|carrier := 𝕌(:α -&gt; bool); sum := symdiff_set; prod := set_inter|&gt;
   
   [<a name="trivial_integal_domain_def-val"><b>trivial_integal_domain_def</b></a>]  Definition
      
      ⊢ ∀e0 e1.
          trivial_integal_domain e0 e1 =
          &lt;|carrier := {e0; e1};
            sum :=
              &lt;|carrier := {e0; e1}; id := e0;
                op :=
                  (λx y. if x = e0 then y else if y = e0 then x else e0)|&gt;;
            prod :=
              &lt;|carrier := {e0; e1}; id := e1;
                op :=
                  (λx y. if x = e0 then e0 else if y = e0 then e0 else e1)|&gt; |&gt;
   
   [<a name="trivial_ring_def-val"><b>trivial_ring_def</b></a>]  Definition
      
      ⊢ ∀z. trivial_ring z =
            &lt;|carrier := {z};
              sum := &lt;|carrier := {z}; id := z; op := (λx y. z)|&gt;;
              prod := &lt;|carrier := {z}; id := z; op := (λx y. z)|&gt; |&gt;
   
   [<a name="unit_eq_def-val"><b>unit_eq_def</b></a>]  Definition
      
      ⊢ ∀r x y. x =~ y ⇔ ∃u. unit u ∧ x = u * y
   
   [<a name="EXISTS_ring-val"><b>EXISTS_ring</b></a>]  Theorem
      
      ⊢ ∀P. (∃r. P r) ⇔ ∃f m0 m. P &lt;|carrier := f; sum := m0; prod := m|&gt;
   
   [<a name="FORALL_ring-val"><b>FORALL_ring</b></a>]  Theorem
      
      ⊢ ∀P. (∀r. P r) ⇔ ∀f m0 m. P &lt;|carrier := f; sum := m0; prod := m|&gt;
   
   [<a name="LIST_REL_ring_associates_product-val"><b>LIST_REL_ring_associates_product</b></a>]  Theorem
      
      ⊢ Ring r ⇒
        ∀l1 l2.
          LIST_REL rassoc l1 l2 ∧ set l2 ⊆ R ⇒
          rassoc (GBAG r.prod (LIST_TO_BAG l1))
            (GBAG r.prod (LIST_TO_BAG l2))
   
   [<a name="WHILE_RULE_PRE_POST-val"><b>WHILE_RULE_PRE_POST</b></a>]  Theorem
      
      ⊢ (∀x. Invariant x ∧ Guard x ⇒ f (Cmd x) &lt; f x) ∧
        (∀x. Precond x ⇒ Invariant x) ∧
        (∀x. Invariant x ∧ ¬Guard x ⇒ Postcond x) ∧
        HOARE_SPEC (λx. Invariant x ∧ Guard x) Cmd Invariant ⇒
        HOARE_SPEC Precond (WHILE Guard Cmd) Postcond
   
   [<a name="ZN_1_exp-val"><b>ZN_1_exp</b></a>]  Theorem
      
      ⊢ ∀n k. (ZN 1).prod.exp n k = 0
   
   [<a name="ZN_card-val"><b>ZN_card</b></a>]  Theorem
      
      ⊢ ∀n. CARD (ZN n).carrier = n
   
   [<a name="ZN_char-val"><b>ZN_char</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ char (ZN n) = n
   
   [<a name="ZN_coprime_euler_element-val"><b>ZN_coprime_euler_element</b></a>]  Theorem
      
      ⊢ ∀m n. 1 &lt; m ∧ coprime m n ⇒ n MOD m ∈ Euler m
   
   [<a name="ZN_coprime_exp_mod-val"><b>ZN_coprime_exp_mod</b></a>]  Theorem
      
      ⊢ ∀m n.
          0 &lt; m ∧ coprime m n ⇒
          ∀k. n ** k MOD m = n ** (k MOD ordz m n) MOD m
   
   [<a name="ZN_coprime_invertible-val"><b>ZN_coprime_invertible</b></a>]  Theorem
      
      ⊢ ∀m n. 1 &lt; m ∧ coprime m n ⇒ Unit (ZN m) (n MOD m)
   
   [<a name="ZN_coprime_order-val"><b>ZN_coprime_order</b></a>]  Theorem
      
      ⊢ ∀m n.
          0 &lt; m ∧ coprime m n ⇒
          0 &lt; ordz m n ∧ n ** ordz m n MOD m = 1 MOD m
   
   [<a name="ZN_coprime_order_alt-val"><b>ZN_coprime_order_alt</b></a>]  Theorem
      
      ⊢ ∀m n. 1 &lt; m ∧ coprime m n ⇒ 0 &lt; ordz m n ∧ n ** ordz m n MOD m = 1
   
   [<a name="ZN_coprime_order_divides_phi-val"><b>ZN_coprime_order_divides_phi</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ∧ coprime m n ⇒ ordz m n divides phi m
   
   [<a name="ZN_coprime_order_divides_totient-val"><b>ZN_coprime_order_divides_totient</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ∧ coprime m n ⇒ ordz m n divides totient m
   
   [<a name="ZN_coprime_order_gt_1-val"><b>ZN_coprime_order_gt_1</b></a>]  Theorem
      
      ⊢ ∀m n. 1 &lt; m ∧ 1 &lt; n MOD m ∧ coprime m n ⇒ 1 &lt; ordz m n
   
   [<a name="ZN_coprime_order_lt-val"><b>ZN_coprime_order_lt</b></a>]  Theorem
      
      ⊢ ∀m n. 1 &lt; m ∧ coprime m n ⇒ ordz m n &lt; m
   
   [<a name="ZN_eval-val"><b>ZN_eval</b></a>]  Theorem
      
      ⊢ ∀n. (ZN n).carrier = count n ∧ (ZN n).sum = add_mod n ∧
            (ZN n).prod = times_mod n
   
   [<a name="ZN_exp-val"><b>ZN_exp</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀x k. (ZN n).prod.exp x k = x ** k MOD n
   
   [<a name="ZN_finite-val"><b>ZN_finite</b></a>]  Theorem
      
      ⊢ ∀n. FINITE (ZN n).carrier
   
   [<a name="ZN_finite_ring-val"><b>ZN_finite_ring</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ FiniteRing (ZN n)
   
   [<a name="ZN_ids-val"><b>ZN_ids</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ (ZN n).sum.id = 0 ∧ (ZN n).prod.id = 1 MOD n
   
   [<a name="ZN_ids_alt-val"><b>ZN_ids_alt</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ (ZN n).sum.id = 0 ∧ (ZN n).prod.id = 1
   
   [<a name="ZN_invertibles-val"><b>ZN_invertibles</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ Invertibles (ZN n).prod = Estar n
   
   [<a name="ZN_invertibles_finite_group-val"><b>ZN_invertibles_finite_group</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ FiniteGroup (Invertibles (ZN n).prod)
   
   [<a name="ZN_invertibles_group-val"><b>ZN_invertibles_group</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ Group (Invertibles (ZN n).prod)
   
   [<a name="ZN_invertibles_order-val"><b>ZN_invertibles_order</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ⇒ order (Invertibles (ZN m).prod) (n MOD m) = ordz m n
   
   [<a name="ZN_mult_inv_coprime-val"><b>ZN_mult_inv_coprime</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀x y. (x * y) MOD n = 1 ⇒ coprime x n
   
   [<a name="ZN_mult_inv_coprime_iff-val"><b>ZN_mult_inv_coprime_iff</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ ∀x. coprime x n ⇔ ∃y. (x * y) MOD n = 1
   
   [<a name="ZN_not_coprime-val"><b>ZN_not_coprime</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ∧ gcd m n ≠ 1 ⇒ ∀k. 0 &lt; k ⇒ n ** k MOD m ≠ 1
   
   [<a name="ZN_num-val"><b>ZN_num</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀k. (ZN n).sum.exp 1 k = k MOD n
   
   [<a name="ZN_num_0-val"><b>ZN_num_0</b></a>]  Theorem
      
      ⊢ ∀n c. 0 &lt; n ⇒ (ZN n).sum.exp 0 c = 0
   
   [<a name="ZN_num_1-val"><b>ZN_num_1</b></a>]  Theorem
      
      ⊢ ∀n. (ZN n).sum.exp (ZN n).prod.id 1 = 1 MOD n
   
   [<a name="ZN_num_mod-val"><b>ZN_num_mod</b></a>]  Theorem
      
      ⊢ ∀n c. 0 &lt; n ⇒ (ZN n).sum.exp (ZN n).prod.id c = c MOD n
   
   [<a name="ZN_order_0-val"><b>ZN_order_0</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ordz n 0 = if n = 1 then 1 else 0
   
   [<a name="ZN_order_1-val"><b>ZN_order_1</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ordz n 1 = 1
   
   [<a name="ZN_order_divides_exp-val"><b>ZN_order_divides_exp</b></a>]  Theorem
      
      ⊢ ∀m n k. 1 &lt; m ∧ 0 &lt; k ⇒ (n ** k MOD m = 1 ⇔ ordz m n divides k)
   
   [<a name="ZN_order_divides_phi-val"><b>ZN_order_divides_phi</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ∧ 0 &lt; ordz m n ⇒ ordz m n divides phi m
   
   [<a name="ZN_order_divides_tops_index-val"><b>ZN_order_divides_tops_index</b></a>]  Theorem
      
      ⊢ ∀n j k.
          1 &lt; n ∧ 0 &lt; j ∧ 1 &lt; k ⇒ (k divides tops n j ⇔ ordz k n divides j)
   
   [<a name="ZN_order_divisibility-val"><b>ZN_order_divisibility</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ⇒ m divides tops n (ordz m n)
   
   [<a name="ZN_order_eq_0-val"><b>ZN_order_eq_0</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ⇒ (ordz m n = 0 ⇔ gcd m n ≠ 1)
   
   [<a name="ZN_order_eq_0_iff-val"><b>ZN_order_eq_0_iff</b></a>]  Theorem
      
      ⊢ ∀m n. 1 &lt; m ⇒ (ordz m n = 0 ⇔ ∀k. 0 &lt; k ⇒ n ** k MOD m ≠ 1)
   
   [<a name="ZN_order_eq_0_test-val"><b>ZN_order_eq_0_test</b></a>]  Theorem
      
      ⊢ ∀m n. 1 &lt; m ⇒ (ordz m n = 0 ⇔ ∀j. 0 &lt; j ∧ j &lt; m ⇒ n ** j MOD m ≠ 1)
   
   [<a name="ZN_order_eq_1-val"><b>ZN_order_eq_1</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ⇒ (ordz m n = 1 ⇔ n MOD m = 1 MOD m)
   
   [<a name="ZN_order_eq_1_alt-val"><b>ZN_order_eq_1_alt</b></a>]  Theorem
      
      ⊢ ∀m n. 1 &lt; m ⇒ (ordz m n = 1 ⇔ n MOD m = 1)
   
   [<a name="ZN_order_eq_1_by_prime_factors-val"><b>ZN_order_eq_1_by_prime_factors</b></a>]  Theorem
      
      ⊢ ∀m n.
          0 &lt; m ∧ coprime m n ∧ (∀p. prime p ∧ p divides n ⇒ ordz m p = 1) ⇒
          ordz m n = 1
   
   [<a name="ZN_order_gt_1_property-val"><b>ZN_order_gt_1_property</b></a>]  Theorem
      
      ⊢ ∀m n.
          0 &lt; m ∧ 1 &lt; ordz m n ⇒ ∃p. prime p ∧ p divides n ∧ 1 &lt; ordz m p
   
   [<a name="ZN_order_le-val"><b>ZN_order_le</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ⇒ ordz m n ≤ m
   
   [<a name="ZN_order_le_tops_index-val"><b>ZN_order_le_tops_index</b></a>]  Theorem
      
      ⊢ ∀n j k. 1 &lt; n ∧ 0 &lt; j ∧ 1 &lt; k ∧ k divides tops n j ⇒ ordz k n ≤ j
   
   [<a name="ZN_order_lt-val"><b>ZN_order_lt</b></a>]  Theorem
      
      ⊢ ∀k n m. 0 &lt; k ∧ k &lt; m ⇒ ordz k n &lt; m
   
   [<a name="ZN_order_minimal-val"><b>ZN_order_minimal</b></a>]  Theorem
      
      ⊢ ∀m n k. 0 &lt; m ∧ 0 &lt; k ∧ k &lt; ordz m n ⇒ n ** k MOD m ≠ 1
   
   [<a name="ZN_order_mod-val"><b>ZN_order_mod</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ⇒ ordz m (n MOD m) = ordz m n
   
   [<a name="ZN_order_mod_1-val"><b>ZN_order_mod_1</b></a>]  Theorem
      
      ⊢ ∀n. ordz 1 n = 1
   
   [<a name="ZN_order_nonzero-val"><b>ZN_order_nonzero</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ⇒ (ordz m n ≠ 0 ⇔ coprime m n)
   
   [<a name="ZN_order_nonzero_iff-val"><b>ZN_order_nonzero_iff</b></a>]  Theorem
      
      ⊢ ∀m n. 1 &lt; m ⇒ (ordz m n ≠ 0 ⇔ ∃k. 0 &lt; k ∧ n ** k MOD m = 1)
   
   [<a name="ZN_order_property-val"><b>ZN_order_property</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ⇒ n ** ordz m n MOD m = 1 MOD m
   
   [<a name="ZN_order_property_alt-val"><b>ZN_order_property_alt</b></a>]  Theorem
      
      ⊢ ∀m n. 1 &lt; m ⇒ n ** ordz m n MOD m = 1
   
   [<a name="ZN_order_test_1-val"><b>ZN_order_test_1</b></a>]  Theorem
      
      ⊢ ∀m n k.
          1 &lt; m ∧ 0 &lt; k ⇒
          (ordz m n = k ⇔
           n ** k MOD m = 1 ∧ ∀j. 0 &lt; j ∧ j &lt; k ⇒ n ** j MOD m ≠ 1)
   
   [<a name="ZN_order_test_2-val"><b>ZN_order_test_2</b></a>]  Theorem
      
      ⊢ ∀m n k.
          1 &lt; m ∧ 0 &lt; k ⇒
          (ordz m n = k ⇔
           n ** k MOD m = 1 ∧
           ∀j. 0 &lt; j ∧ j &lt; k ∧ j divides phi m ⇒ n ** j MOD m ≠ 1)
   
   [<a name="ZN_order_test_3-val"><b>ZN_order_test_3</b></a>]  Theorem
      
      ⊢ ∀m n k.
          1 &lt; m ∧ 0 &lt; k ⇒
          (ordz m n = k ⇔
           k divides phi m ∧ n ** k MOD m = 1 ∧
           ∀j. 0 &lt; j ∧ j &lt; k ∧ j divides phi m ⇒ n ** j MOD m ≠ 1)
   
   [<a name="ZN_order_test_4-val"><b>ZN_order_test_4</b></a>]  Theorem
      
      ⊢ ∀m n k.
          1 &lt; m ⇒
          (ordz m n = k ⇔
           n ** k MOD m = 1 ∧
           ∀j. 0 &lt; j ∧ j &lt; (if k = 0 then m else k) ⇒ n ** j MOD m ≠ 1)
   
   [<a name="ZN_order_test_propery-val"><b>ZN_order_test_propery</b></a>]  Theorem
      
      ⊢ ∀m n k.
          1 &lt; m ∧ 0 &lt; k ∧ n ** k MOD m = 1 ∧
          (∀j. 0 &lt; j ∧ j &lt; k ∧ j divides phi m ⇒ n ** j MOD m ≠ 1) ⇒
          ∀j. 0 &lt; j ∧ j &lt; k ∧ ¬(j divides phi m) ⇒
              ordz m n = k ∨ n ** j MOD m ≠ 1
   
   [<a name="ZN_order_upper-val"><b>ZN_order_upper</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ⇒ ordz m n ≤ phi m
   
   [<a name="ZN_order_with_coprime_1-val"><b>ZN_order_with_coprime_1</b></a>]  Theorem
      
      ⊢ ∀m n. 1 &lt; n ∧ coprime m n ∧ 1 &lt; ordz m n ⇒ 1 &lt; m
   
   [<a name="ZN_order_with_coprime_2-val"><b>ZN_order_with_coprime_2</b></a>]  Theorem
      
      ⊢ ∀m n k.
          1 &lt; m ∧ m divides n ∧ 1 &lt; ordz k m ∧ coprime k n ⇒ 1 &lt; n ∧ 1 &lt; k
   
   [<a name="ZN_property-val"><b>ZN_property</b></a>]  Theorem
      
      ⊢ ∀n. (∀x. x ∈ (ZN n).carrier ⇔ x &lt; n) ∧ (ZN n).sum.id = 0 ∧
            (ZN n).prod.id = (if n = 1 then 0 else 1) ∧
            (∀x y. (ZN n).sum.op x y = (x + y) MOD n) ∧
            (∀x y. (ZN n).prod.op x y = (x * y) MOD n) ∧
            FINITE (ZN n).carrier ∧ CARD (ZN n).carrier = n
   
   [<a name="ZN_ring-val"><b>ZN_ring</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ Ring (ZN n)
   
   [<a name="ZN_to_ZN_element-val"><b>ZN_to_ZN_element</b></a>]  Theorem
      
      ⊢ ∀n m x. 0 &lt; m ∧ x ∈ (ZN n).carrier ⇒ x MOD m ∈ (ZN m).carrier
   
   [<a name="ZN_to_ZN_prod_monoid_homo-val"><b>ZN_to_ZN_prod_monoid_homo</b></a>]  Theorem
      
      ⊢ ∀n m.
          0 &lt; n ∧ m divides n ⇒
          MonoidHomo (λx. x MOD m) (ZN n).prod (ZN m).prod
   
   [<a name="ZN_to_ZN_ring_homo-val"><b>ZN_to_ZN_ring_homo</b></a>]  Theorem
      
      ⊢ ∀n m. 0 &lt; n ∧ m divides n ⇒ RingHomo (λx. x MOD m) (ZN n) (ZN m)
   
   [<a name="ZN_to_ZN_sum_group_homo-val"><b>ZN_to_ZN_sum_group_homo</b></a>]  Theorem
      
      ⊢ ∀n m.
          0 &lt; n ∧ m divides n ⇒
          GroupHomo (λx. x MOD m) (ZN n).sum (ZN m).sum
   
   [<a name="ZP_finite-val"><b>ZP_finite</b></a>]  Theorem
      
      ⊢ ∀p. FINITE (ZP p).carrier
   
   [<a name="ZP_finite_integral_domain-val"><b>ZP_finite_integral_domain</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇒ FiniteIntegralDomain (ZP p)
   
   [<a name="ZP_integral_domain-val"><b>ZP_integral_domain</b></a>]  Theorem
      
      ⊢ ∀p. prime p ⇒ IntegralDomain (ZP p)
   
   [<a name="Z_add_abelian_group-val"><b>Z_add_abelian_group</b></a>]  Theorem
      
      ⊢ AbelianGroup Z_add
   
   [<a name="Z_add_group-val"><b>Z_add_group</b></a>]  Theorem
      
      ⊢ Group Z_add
   
   [<a name="Z_add_inv-val"><b>Z_add_inv</b></a>]  Theorem
      
      ⊢ ∀z. z ∈ Z_add.carrier ⇒ Z_add.inv z = -z
   
   [<a name="Z_euclid_ring-val"><b>Z_euclid_ring</b></a>]  Theorem
      
      ⊢ EuclideanRing Z Num
   
   [<a name="Z_ideal_map_bij-val"><b>Z_ideal_map_bij</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒
            BIJ (λj. coset Z.sum (&j) (Z* n).sum.carrier) (ZN n).carrier
              (Z / Z* n).carrier
   
   [<a name="Z_ideal_map_element-val"><b>Z_ideal_map_element</b></a>]  Theorem
      
      ⊢ ∀n j.
          0 &lt; n ∧ j ∈ (ZN n).carrier ⇒
          coset Z.sum (&j) (Z* n).sum.carrier ∈ (Z / Z* n).carrier
   
   [<a name="Z_ideal_map_group_homo-val"><b>Z_ideal_map_group_homo</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒
            GroupHomo (λj. coset Z.sum (&j) (Z* n).sum.carrier) (ZN n).sum
              (Z / Z* n).sum
   
   [<a name="Z_ideal_map_monoid_homo-val"><b>Z_ideal_map_monoid_homo</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒
            MonoidHomo (λj. coset Z.sum (&j) (Z* n).sum.carrier)
              (ZN n).prod (Z / Z* n).prod
   
   [<a name="Z_ideal_sum_group-val"><b>Z_ideal_sum_group</b></a>]  Theorem
      
      ⊢ ∀n. Group (Z* n).sum
   
   [<a name="Z_ideal_sum_normal-val"><b>Z_ideal_sum_normal</b></a>]  Theorem
      
      ⊢ ∀n. (Z* n).sum &lt;&lt; Z.sum
   
   [<a name="Z_ideal_sum_subgroup-val"><b>Z_ideal_sum_subgroup</b></a>]  Theorem
      
      ⊢ ∀n. (Z* n).sum ≤ Z.sum
   
   [<a name="Z_ideal_thm-val"><b>Z_ideal_thm</b></a>]  Theorem
      
      ⊢ ∀n. Z* n &lt;&lt; Z
   
   [<a name="Z_mult_abelian_monoid-val"><b>Z_mult_abelian_monoid</b></a>]  Theorem
      
      ⊢ AbelianMonoid Z_mult
   
   [<a name="Z_mult_monoid-val"><b>Z_mult_monoid</b></a>]  Theorem
      
      ⊢ Monoid Z_mult
   
   [<a name="Z_multiple_less_neg_eq-val"><b>Z_multiple_less_neg_eq</b></a>]  Theorem
      
      ⊢ ∀n x y. 0 &lt; n ∧ x &lt; n ∧ y &lt; n ∧ -&x + &y ∈ Z_multiple n ⇒ x = y
   
   [<a name="Z_principal_ideal_ring-val"><b>Z_principal_ideal_ring</b></a>]  Theorem
      
      ⊢ PrincipalIdealRing Z
   
   [<a name="Z_quotient_iso_ZN-val"><b>Z_quotient_iso_ZN</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒
            RingIso (λj. coset Z.sum (&j) (Z* n).sum.carrier) (ZN n)
              (Z / Z* n)
   
   [<a name="Z_ring-val"><b>Z_ring</b></a>]  Theorem
      
      ⊢ Ring Z
   
   [<a name="Z_sum_cogen-val"><b>Z_sum_cogen</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒
            ∀x. x ∈ Z.sum.carrier ⇒
                ∃y. cogen Z.sum (Z* n).sum
                      (coset Z.sum x (Z* n).sum.carrier) = x + &n * y
   
   [<a name="Z_sum_coset_eq-val"><b>Z_sum_coset_eq</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒
            ∀p. coset Z.sum p (Z* n).sum.carrier =
                coset Z.sum (p % &n) (Z* n).sum.carrier
   
   [<a name="char_eq_0-val"><b>char_eq_0</b></a>]  Theorem
      
      ⊢ ∀r. char r = 0 ⇔ ∀n. 0 &lt; n ⇒ ##n ≠ #0
   
   [<a name="char_minimal-val"><b>char_minimal</b></a>]  Theorem
      
      ⊢ ∀r. 0 &lt; char r ⇒ ∀n. 0 &lt; n ∧ n &lt; char r ⇒ ##n ≠ #0
   
   [<a name="char_property-val"><b>char_property</b></a>]  Theorem
      
      ⊢ ∀r. ##(char r) = #0
   
   [<a name="compute_ordz_0-val"><b>compute_ordz_0</b></a>]  Theorem
      
      ⊢ ∀n. compute_ordz 0 n = ordz 0 n
   
   [<a name="compute_ordz_1-val"><b>compute_ordz_1</b></a>]  Theorem
      
      ⊢ ∀n. compute_ordz 1 n = 1
   
   [<a name="compute_ordz_eqn-val"><b>compute_ordz_eqn</b></a>]  Theorem
      
      ⊢ ∀m n. compute_ordz m n = ordz m n
   
   [<a name="compute_ordz_hoare-val"><b>compute_ordz_hoare</b></a>]  Theorem
      
      ⊢ ∀m n.
          1 &lt; m ∧ coprime m n ⇒
          HOARE_SPEC (λi. 0 &lt; i ∧ i ≤ ordz m n)
            (WHILE (λi. n ** i MOD m ≠ 1) SUC) (λi. i = ordz m n)
   
   [<a name="datatype_ring-val"><b>datatype_ring</b></a>]  Theorem
      
      ⊢ DATATYPE (record ring carrier sum prod)
   
   [<a name="euclid_ring_map-val"><b>euclid_ring_map</b></a>]  Theorem
      
      ⊢ ∀r f. EuclideanRing r f ⇒ ∀x. f x = 0 ⇔ x = #0
   
   [<a name="euclid_ring_principal_ideal_ring-val"><b>euclid_ring_principal_ideal_ring</b></a>]  Theorem
      
      ⊢ ∀r f. EuclideanRing r f ⇒ PrincipalIdealRing r
   
   [<a name="euclid_ring_property-val"><b>euclid_ring_property</b></a>]  Theorem
      
      ⊢ ∀r f.
          EuclideanRing r f ⇒
          ∀x y.
            x ∈ R ∧ y ∈ R ∧ y ≠ #0 ⇒
            ∃q t. q ∈ R ∧ t ∈ R ∧ x = q * y + t ∧ f t &lt; f y
   
   [<a name="euclid_ring_ring-val"><b>euclid_ring_ring</b></a>]  Theorem
      
      ⊢ ∀r f. EuclideanRing r f ⇒ Ring r
   
   [<a name="finite_integral_domain_nonzero_group-val"><b>finite_integral_domain_nonzero_group</b></a>]  Theorem
      
      ⊢ ∀r. FiniteIntegralDomain r ⇒ Group f*
   
   [<a name="finite_integral_domain_nonzero_invertible-val"><b>finite_integral_domain_nonzero_invertible</b></a>]  Theorem
      
      ⊢ ∀r. FiniteIntegralDomain r ⇒ monoid_invertibles r.prod = R+
   
   [<a name="finite_integral_domain_nonzero_invertible_alt-val"><b>finite_integral_domain_nonzero_invertible_alt</b></a>]  Theorem
      
      ⊢ ∀r. FiniteIntegralDomain r ⇒ monoid_invertibles f* = F*
   
   [<a name="finite_integral_domain_period_exists-val"><b>finite_integral_domain_period_exists</b></a>]  Theorem
      
      ⊢ ∀r. FiniteIntegralDomain r ⇒ ∀x. x ∈ R+ ⇒ ∃k. 0 &lt; k ∧ x ** k = #1
   
   [<a name="finite_ring_add_finite_abelian_group-val"><b>finite_ring_add_finite_abelian_group</b></a>]  Theorem
      
      ⊢ ∀r. FiniteRing r ⇒ FiniteAbelianGroup r.sum ∧ r.sum.carrier = R
   
   [<a name="finite_ring_add_finite_group-val"><b>finite_ring_add_finite_group</b></a>]  Theorem
      
      ⊢ ∀r. FiniteRing r ⇒ FiniteGroup r.sum ∧ r.sum.carrier = R
   
   [<a name="finite_ring_card_eq_1-val"><b>finite_ring_card_eq_1</b></a>]  Theorem
      
      ⊢ ∀r. FiniteRing r ⇒ (CARD R = 1 ⇔ #1 = #0)
   
   [<a name="finite_ring_card_pos-val"><b>finite_ring_card_pos</b></a>]  Theorem
      
      ⊢ ∀r. FiniteRing r ⇒ 0 &lt; CARD R
   
   [<a name="finite_ring_card_prime-val"><b>finite_ring_card_prime</b></a>]  Theorem
      
      ⊢ ∀r. FiniteRing r ∧ prime (CARD R) ⇒ char r = CARD R
   
   [<a name="finite_ring_char-val"><b>finite_ring_char</b></a>]  Theorem
      
      ⊢ ∀r. FiniteRing r ⇒ 0 &lt; char r ∧ char r = order r.sum #1
   
   [<a name="finite_ring_char_alt-val"><b>finite_ring_char_alt</b></a>]  Theorem
      
      ⊢ ∀r. FiniteRing r ⇒
            ∀n. char r = n ⇔
                0 &lt; n ∧ ##n = #0 ∧ ∀m. 0 &lt; m ∧ m &lt; n ⇒ ##m ≠ #0
   
   [<a name="finite_ring_char_divides-val"><b>finite_ring_char_divides</b></a>]  Theorem
      
      ⊢ ∀r. FiniteRing r ⇒ char r divides CARD R
   
   [<a name="finite_ring_char_pos-val"><b>finite_ring_char_pos</b></a>]  Theorem
      
      ⊢ ∀r. FiniteRing r ⇒ 0 &lt; char r
   
   [<a name="finite_ring_is_ring-val"><b>finite_ring_is_ring</b></a>]  Theorem
      
      ⊢ ∀r. FiniteRing r ⇒ Ring r
   
   [<a name="finite_ring_mult_finite_abelian_monoid-val"><b>finite_ring_mult_finite_abelian_monoid</b></a>]  Theorem
      
      ⊢ ∀r. FiniteRing r ⇒ FiniteAbelianMonoid r.prod
   
   [<a name="finite_ring_mult_finite_monoid-val"><b>finite_ring_mult_finite_monoid</b></a>]  Theorem
      
      ⊢ ∀r. FiniteRing r ⇒ FiniteMonoid r.prod
   
   [<a name="homo_ring_by_inj-val"><b>homo_ring_by_inj</b></a>]  Theorem
      
      ⊢ ∀r f. Ring r ∧ INJ f R 𝕌(:β) ⇒ RingHomo f r (homo_ring r f)
   
   [<a name="homo_ring_property-val"><b>homo_ring_property</b></a>]  Theorem
      
      ⊢ ∀r f.
          fR = IMAGE f R ∧ (homo_ring r f).sum = homo_group r.sum f ∧
          (homo_ring r f).prod = homo_group r.prod f
   
   [<a name="homo_ring_ring-val"><b>homo_ring_ring</b></a>]  Theorem
      
      ⊢ ∀r f. Ring r ∧ RingHomo f r (homo_ring r f) ⇒ Ring (homo_ring r f)
   
   [<a name="homo_ring_subring-val"><b>homo_ring_subring</b></a>]  Theorem
      
      ⊢ ∀r s f. (r ~r~ s) f ⇒ subring (homo_ring r f) s
   
   [<a name="ideal_antisym-val"><b>ideal_antisym</b></a>]  Theorem
      
      ⊢ ∀r i. i &lt;&lt; r ∧ r &lt;&lt; i ⇒ i = r
   
   [<a name="ideal_carrier_sing-val"><b>ideal_carrier_sing</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ (SING I ⇔ i = &lt;#0&gt;)
   
   [<a name="ideal_carriers-val"><b>ideal_carriers</b></a>]  Theorem
      
      ⊢ ∀r i. i &lt;&lt; r ⇒ i.sum.carrier = I ∧ i.prod.carrier = I
   
   [<a name="ideal_cogen_property-val"><b>ideal_cogen_property</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ ∀x. x ∈ R/I ⇒ gen x ∈ R ∧ gen x ∘ I = x
   
   [<a name="ideal_congruence_elements-val"><b>ideal_congruence_elements</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ ∀x y. x ∈ I ∧ y ∈ R ⇒ (y ∈ I ⇔ x === y)
   
   [<a name="ideal_congruence_equiv-val"><b>ideal_congruence_equiv</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ $=== equiv_on R
   
   [<a name="ideal_congruence_iff_inCoset-val"><b>ideal_congruence_iff_inCoset</b></a>]  Theorem
      
      ⊢ ∀r i.
          Ring r ∧ i &lt;&lt; r ⇒
          ∀x y. x ∈ I ∧ y ∈ I ⇒ (x === y ⇔ inCoset r.sum i.sum x y)
   
   [<a name="ideal_congruence_mult-val"><b>ideal_congruence_mult</b></a>]  Theorem
      
      ⊢ ∀r i.
          Ring r ∧ i &lt;&lt; r ⇒
          ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ x === y ⇒ z * x === z * y
   
   [<a name="ideal_congruence_refl-val"><b>ideal_congruence_refl</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ ∀x. x ∈ R ⇒ x === x
   
   [<a name="ideal_congruence_sym-val"><b>ideal_congruence_sym</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ (x === y ⇔ y === x)
   
   [<a name="ideal_congruence_trans-val"><b>ideal_congruence_trans</b></a>]  Theorem
      
      ⊢ ∀r i.
          Ring r ∧ i &lt;&lt; r ⇒
          ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ x === y ∧ y === z ⇒ x === z
   
   [<a name="ideal_coset_add-val"><b>ideal_coset_add</b></a>]  Theorem
      
      ⊢ ∀r i.
          Ring r ∧ i &lt;&lt; r ⇒
          ∀x y. x ∈ R ∧ y ∈ R ⇒ x ∘ I + y ∘ I = (x + y) ∘ I
   
   [<a name="ideal_coset_element-val"><b>ideal_coset_element</b></a>]  Theorem
      
      ⊢ ∀r i x.
          Ring r ∧ i &lt;&lt; r ∧ x ∈ R ⇒ ∀z. z ∈ x ∘ I ⇔ ∃y. y ∈ I ∧ z = x + y
   
   [<a name="ideal_coset_eq-val"><b>ideal_coset_eq</b></a>]  Theorem
      
      ⊢ ∀r i.
          Ring r ∧ i &lt;&lt; r ⇒
          ∀x y. x ∈ R ∧ y ∈ R ⇒ (x ∘ I = y ∘ I ⇔ x − y ∈ I)
   
   [<a name="ideal_coset_eq_carrier-val"><b>ideal_coset_eq_carrier</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ ∀x. x ∈ R ∧ x ∘ I = I ⇔ x ∈ I
   
   [<a name="ideal_coset_eq_congruence-val"><b>ideal_coset_eq_congruence</b></a>]  Theorem
      
      ⊢ ∀r i.
          Ring r ∧ i &lt;&lt; r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ (x ∘ I = y ∘ I ⇔ x === y)
   
   [<a name="ideal_coset_has_gen_diff-val"><b>ideal_coset_has_gen_diff</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ ∀x. x ∈ R ⇒ gen (x ∘ I) − x ∈ I
   
   [<a name="ideal_coset_mult-val"><b>ideal_coset_mult</b></a>]  Theorem
      
      ⊢ ∀r i.
          Ring r ∧ i &lt;&lt; r ⇒
          ∀x y. x ∈ R ∧ y ∈ R ⇒ x ∘ I * y ∘ I = (x * y) ∘ I
   
   [<a name="ideal_coset_neg-val"><b>ideal_coset_neg</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ ∀x. x ∈ R ⇒ x ∘ I + -x ∘ I = I
   
   [<a name="ideal_coset_of_element-val"><b>ideal_coset_of_element</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ ∀x. x ∈ I ⇒ x ∘ I = I
   
   [<a name="ideal_coset_property-val"><b>ideal_coset_property</b></a>]  Theorem
      
      ⊢ ∀r i.
          Ring r ∧ i &lt;&lt; r ⇒
          ∀x. x ∈ R ⇒ x ∘ I ∈ R/I ∧ gen (x ∘ I) ∘ I = x ∘ I
   
   [<a name="ideal_coset_zero-val"><b>ideal_coset_zero</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ #0 ∘ I = I
   
   [<a name="ideal_element-val"><b>ideal_element</b></a>]  Theorem
      
      ⊢ ∀r i. i &lt;&lt; r ⇒ ∀x. x ∈ I ⇒ x ∈ r.sum.carrier
   
   [<a name="ideal_element_property-val"><b>ideal_element_property</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ ∀x. x ∈ I ⇒ x ∈ R
   
   [<a name="ideal_eq_ideal-val"><b>ideal_eq_ideal</b></a>]  Theorem
      
      ⊢ ∀r i j. Ring r ∧ i &lt;&lt; r ∧ j &lt;&lt; r ⇒ (i = j ⇔ I = J)
   
   [<a name="ideal_gen_exists-val"><b>ideal_gen_exists</b></a>]  Theorem
      
      ⊢ ∀r i.
          Ring r ∧ i &lt;&lt; r ∧ i ≠ &lt;#0&gt; ⇒
          ∀f. (∀x. f x = 0 ⇔ x = #0) ⇒
              ∃p. p ∈ I ∧ p ≠ #0 ∧ ∀z. z ∈ I ∧ z ≠ #0 ⇒ f p ≤ f z
   
   [<a name="ideal_gen_minimal-val"><b>ideal_gen_minimal</b></a>]  Theorem
      
      ⊢ ∀r i.
          Ring r ∧ i &lt;&lt; r ∧ i ≠ &lt;#0&gt; ⇒
          ∀f. (∀x. f x = 0 ⇔ x = #0) ⇒
              ∀z. z ∈ I ⇒ (f z &lt; f (ideal_gen r i f) ⇔ z = #0)
   
   [<a name="ideal_has_diff-val"><b>ideal_has_diff</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ ∀x y. x ∈ I ∧ y ∈ I ⇒ x − y ∈ I
   
   [<a name="ideal_has_multiple-val"><b>ideal_has_multiple</b></a>]  Theorem
      
      ⊢ ∀r i. i &lt;&lt; r ⇒ ∀x y. x ∈ I ∧ y ∈ R ⇒ x * y ∈ I
   
   [<a name="ideal_has_neg-val"><b>ideal_has_neg</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ ∀x. x ∈ I ⇒ -x ∈ I
   
   [<a name="ideal_has_one-val"><b>ideal_has_one</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ∧ #1 ∈ I ⇒ I = R
   
   [<a name="ideal_has_principal_ideal-val"><b>ideal_has_principal_ideal</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ ∀p. p ∈ R ⇒ (p ∈ I ⇔ &lt;p&gt; &lt;&lt; i)
   
   [<a name="ideal_has_product-val"><b>ideal_has_product</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ ∀x y. x ∈ I ∧ y ∈ I ⇒ x * y ∈ I
   
   [<a name="ideal_has_subgroup-val"><b>ideal_has_subgroup</b></a>]  Theorem
      
      ⊢ ∀r i. i &lt;&lt; r ⇒ i.sum ≤ r.sum
   
   [<a name="ideal_has_sum-val"><b>ideal_has_sum</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ ∀x y. x ∈ I ∧ y ∈ I ⇒ x + y ∈ I
   
   [<a name="ideal_has_zero-val"><b>ideal_has_zero</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ #0 ∈ I
   
   [<a name="ideal_in_quotient_ring-val"><b>ideal_in_quotient_ring</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ I ∈ R/I
   
   [<a name="ideal_ops-val"><b>ideal_ops</b></a>]  Theorem
      
      ⊢ ∀r i. i &lt;&lt; r ⇒ i.sum.op = $+ ∧ i.prod.op = $*
   
   [<a name="ideal_product_property-val"><b>ideal_product_property</b></a>]  Theorem
      
      ⊢ ∀r i. i &lt;&lt; r ⇒ ∀x y. x ∈ I ∧ y ∈ R ⇒ x * y ∈ I ∧ y * x ∈ I
   
   [<a name="ideal_property-val"><b>ideal_property</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ ∀x y. x ∈ I ∧ y ∈ I ⇒ x + y ∈ I ∧ x * y ∈ I
   
   [<a name="ideal_refl-val"><b>ideal_refl</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ r &lt;&lt; r
   
   [<a name="ideal_sub_ideal-val"><b>ideal_sub_ideal</b></a>]  Theorem
      
      ⊢ ∀r i j. Ring r ∧ i &lt;&lt; r ∧ j &lt;&lt; r ⇒ (i &lt;&lt; j ⇔ I ⊆ J)
   
   [<a name="ideal_sub_itself-val"><b>ideal_sub_itself</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ i &lt;&lt; i
   
   [<a name="ideal_subgroup_ideal_sum-val"><b>ideal_subgroup_ideal_sum</b></a>]  Theorem
      
      ⊢ ∀r i j. Ring r ∧ i &lt;&lt; r ∧ j &lt;&lt; r ⇒ i.sum ≤ (i + j).sum
   
   [<a name="ideal_sum_comm-val"><b>ideal_sum_comm</b></a>]  Theorem
      
      ⊢ ∀r i j. Ring r ∧ i &lt;&lt; r ∧ j &lt;&lt; r ⇒ i + j = j + i
   
   [<a name="ideal_sum_element-val"><b>ideal_sum_element</b></a>]  Theorem
      
      ⊢ ∀i j x. x ∈ (i + j).carrier ⇔ ∃y z. y ∈ I ∧ z ∈ J ∧ x = y + z
   
   [<a name="ideal_sum_group-val"><b>ideal_sum_group</b></a>]  Theorem
      
      ⊢ ∀r i j. Ring r ∧ i &lt;&lt; r ∧ j &lt;&lt; r ⇒ Group (i + j).sum
   
   [<a name="ideal_sum_has_ideal-val"><b>ideal_sum_has_ideal</b></a>]  Theorem
      
      ⊢ ∀r i j. Ring r ∧ i &lt;&lt; r ∧ j &lt;&lt; r ⇒ i &lt;&lt; (i + j)
   
   [<a name="ideal_sum_has_ideal_comm-val"><b>ideal_sum_has_ideal_comm</b></a>]  Theorem
      
      ⊢ ∀r i j. Ring r ∧ i &lt;&lt; r ∧ j &lt;&lt; r ⇒ j &lt;&lt; (i + j)
   
   [<a name="ideal_sum_ideal-val"><b>ideal_sum_ideal</b></a>]  Theorem
      
      ⊢ ∀r i j. Ring r ∧ i &lt;&lt; r ∧ j &lt;&lt; r ⇒ (i + j) &lt;&lt; r
   
   [<a name="ideal_sum_sub_ideal-val"><b>ideal_sum_sub_ideal</b></a>]  Theorem
      
      ⊢ ∀r i j. Ring r ∧ i &lt;&lt; r ∧ j &lt;&lt; r ⇒ ((i + j) &lt;&lt; j ⇔ i &lt;&lt; j)
   
   [<a name="ideal_sum_subgroup-val"><b>ideal_sum_subgroup</b></a>]  Theorem
      
      ⊢ ∀r i j. Ring r ∧ i &lt;&lt; r ∧ j &lt;&lt; r ⇒ (i + j).sum ≤ r.sum
   
   [<a name="ideal_with_one-val"><b>ideal_with_one</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀i. i &lt;&lt; r ∧ #1 ∈ I ⇔ i = r
   
   [<a name="ideal_with_unit-val"><b>ideal_with_unit</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ ∀x. x ∈ I ∧ unit x ⇒ i = r
   
   [<a name="ideal_zero-val"><b>ideal_zero</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ i.sum.id = #0
   
   [<a name="integral_domain_char-val"><b>integral_domain_char</b></a>]  Theorem
      
      ⊢ ∀r. IntegralDomain r ⇒ char r = 0 ∨ prime (char r)
   
   [<a name="integral_domain_divides_prime-val"><b>integral_domain_divides_prime</b></a>]  Theorem
      
      ⊢ ∀r p x.
          IntegralDomain r ∧ x ∈ R ∧ p ∈ R ∧ p ≠ #0 ∧ rprime p ∧ p ∉ R* ∧
          x ∉ R* ∧ x rdivides p ⇒
          rassoc x p
   
   [<a name="integral_domain_exp_eq-val"><b>integral_domain_exp_eq</b></a>]  Theorem
      
      ⊢ ∀r. IntegralDomain r ⇒
            ∀x. x ∈ R+ ⇒ ∀m n. m &lt; n ∧ x ** m = x ** n ⇒ x ** (n − m) = #1
   
   [<a name="integral_domain_exp_eq_zero-val"><b>integral_domain_exp_eq_zero</b></a>]  Theorem
      
      ⊢ ∀r. IntegralDomain r ⇒ ∀x. x ∈ R ⇒ ∀n. x ** n = #0 ⇔ n ≠ 0 ∧ x = #0
   
   [<a name="integral_domain_exp_nonzero-val"><b>integral_domain_exp_nonzero</b></a>]  Theorem
      
      ⊢ ∀r. IntegralDomain r ⇒ ∀x. x ∈ R+ ⇒ ∀n. x ** n ∈ R+
   
   [<a name="integral_domain_is_ring-val"><b>integral_domain_is_ring</b></a>]  Theorem
      
      ⊢ ∀r. IntegralDomain r ⇒ Ring r
   
   [<a name="integral_domain_mult_eq_zero-val"><b>integral_domain_mult_eq_zero</b></a>]  Theorem
      
      ⊢ ∀r. IntegralDomain r ⇒
            ∀x y. x ∈ R ∧ y ∈ R ⇒ (x * y = #0 ⇔ x = #0 ∨ y = #0)
   
   [<a name="integral_domain_mult_lcancel-val"><b>integral_domain_mult_lcancel</b></a>]  Theorem
      
      ⊢ ∀r. IntegralDomain r ⇒
            ∀x y z.
              x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ (x * y = x * z ⇔ x = #0 ∨ y = z)
   
   [<a name="integral_domain_mult_nonzero-val"><b>integral_domain_mult_nonzero</b></a>]  Theorem
      
      ⊢ ∀r. IntegralDomain r ⇒ ∀x y. x ∈ R+ ∧ y ∈ R+ ⇒ x * y ∈ R+
   
   [<a name="integral_domain_mult_rcancel-val"><b>integral_domain_mult_rcancel</b></a>]  Theorem
      
      ⊢ ∀r. IntegralDomain r ⇒
            ∀x y z.
              x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ (y * x = z * x ⇔ x = #0 ∨ y = z)
   
   [<a name="integral_domain_nonzero_monoid-val"><b>integral_domain_nonzero_monoid</b></a>]  Theorem
      
      ⊢ ∀r. IntegralDomain r ⇒ Monoid f*
   
   [<a name="integral_domain_nonzero_mult_carrier-val"><b>integral_domain_nonzero_mult_carrier</b></a>]  Theorem
      
      ⊢ ∀r. IntegralDomain r ⇒ F* = R+
   
   [<a name="integral_domain_nonzero_mult_is_monoid-val"><b>integral_domain_nonzero_mult_is_monoid</b></a>]  Theorem
      
      ⊢ ∀r. IntegralDomain r ⇒ Monoid (monoid_of_ring_nonzero_mult r)
   
   [<a name="integral_domain_nonzero_mult_property-val"><b>integral_domain_nonzero_mult_property</b></a>]  Theorem
      
      ⊢ ∀r. IntegralDomain r ⇒
            F* = R+ ∧ f*.id = #1 ∧ f*.op = $* ∧ f*.exp = $**
   
   [<a name="integral_domain_nonzero_order-val"><b>integral_domain_nonzero_order</b></a>]  Theorem
      
      ⊢ ∀r. IntegralDomain r ⇒ ∀x. order r.prod x = order f* x
   
   [<a name="integral_domain_one_ne_zero-val"><b>integral_domain_one_ne_zero</b></a>]  Theorem
      
      ⊢ ∀r. IntegralDomain r ⇒ #1 ≠ #0
   
   [<a name="integral_domain_one_nonzero-val"><b>integral_domain_one_nonzero</b></a>]  Theorem
      
      ⊢ ∀r. IntegralDomain r ⇒ #1 ∈ R+
   
   [<a name="integral_domain_order_eq_0-val"><b>integral_domain_order_eq_0</b></a>]  Theorem
      
      ⊢ ∀r. FiniteIntegralDomain r ⇒ ∀x. x ∈ R ⇒ (order f* x = 0 ⇔ x = #0)
   
   [<a name="integral_domain_order_nonzero-val"><b>integral_domain_order_nonzero</b></a>]  Theorem
      
      ⊢ ∀r. FiniteIntegralDomain r ⇒ ∀x. x ∈ R+ ⇒ order f* x ≠ 0
   
   [<a name="integral_domain_order_zero-val"><b>integral_domain_order_zero</b></a>]  Theorem
      
      ⊢ ∀r. IntegralDomain r ⇒ order f* #0 = 0
   
   [<a name="integral_domain_prime_factors_unique-val"><b>integral_domain_prime_factors_unique</b></a>]  Theorem
      
      ⊢ IntegralDomain r ⇒
        ∀l1 l2.
          (∀m. MEM m l1 ⇒ m ∈ R ∧ rprime m ∧ m ≠ #0 ∧ m ∉ R* ) ∧
          (∀m. MEM m l2 ⇒ m ∈ R ∧ rprime m ∧ m ≠ #0 ∧ m ∉ R* ) ∧
          rassoc (GBAG r.prod (LIST_TO_BAG l1))
            (GBAG r.prod (LIST_TO_BAG l2)) ⇒
          ∃l3. PERM l2 l3 ∧ LIST_REL rassoc l1 l3
   
   [<a name="integral_domain_ring_iso-val"><b>integral_domain_ring_iso</b></a>]  Theorem
      
      ⊢ IntegralDomain r ∧ Ring s ∧ RingIso f r s ⇒ IntegralDomain s
   
   [<a name="integral_domain_zero_not_unit-val"><b>integral_domain_zero_not_unit</b></a>]  Theorem
      
      ⊢ ∀r. IntegralDomain r ⇒ #0 ∉ R*
   
   [<a name="integral_domain_zero_product-val"><b>integral_domain_zero_product</b></a>]  Theorem
      
      ⊢ ∀r. IntegralDomain r ⇒
            ∀x y. x ∈ R ∧ y ∈ R ⇒ (x * y = #0 ⇔ x = #0 ∨ y = #0)
   
   [<a name="irreducible_associates-val"><b>irreducible_associates</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ∧ #1 ≠ #0 ⇒
            ∀p s. p ∈ R ∧ unit s ⇒ (atom p ⇔ atom (s * p))
   
   [<a name="irreducible_element-val"><b>irreducible_element</b></a>]  Theorem
      
      ⊢ ∀r p. atom p ⇒ p ∈ R
   
   [<a name="irreducible_factors-val"><b>irreducible_factors</b></a>]  Theorem
      
      ⊢ ∀r z.
          atom z ⇒
          z ∈ R+ ∧ z ∉ R* ∧ ∀p. p ∈ R ∧ p rdivides z ⇒ rassoc z p ∨ unit p
   
   [<a name="kernel_ideal_element-val"><b>kernel_ideal_element</b></a>]  Theorem
      
      ⊢ ∀r r_ f x.
          x ∈ (kernel_ideal f r r_).carrier ⇔ x ∈ r.sum.carrier ∧ f x = #0_
   
   [<a name="kernel_ideal_gen_add_map-val"><b>kernel_ideal_gen_add_map</b></a>]  Theorem
      
      ⊢ ∀r r_ f.
          (r ~r~ r_) f ⇒
          (let
             i = kernel_ideal f r r_
           in
             ∀x y.
               x ∈ R/I ∧ y ∈ R/I ⇒
               f (gen ((gen x + gen y) ∘ I)) = f (gen x) +_ f (gen y))
   
   [<a name="kernel_ideal_gen_id_map-val"><b>kernel_ideal_gen_id_map</b></a>]  Theorem
      
      ⊢ ∀r r_ f.
          (r ~r~ r_) f ⇒
          (let i = kernel_ideal f r r_ in f (gen (#1 ∘ I)) = #1_)
   
   [<a name="kernel_ideal_gen_mult_map-val"><b>kernel_ideal_gen_mult_map</b></a>]  Theorem
      
      ⊢ ∀r r_ f.
          (r ~r~ r_) f ⇒
          (let
             i = kernel_ideal f r r_
           in
             ∀x y.
               x ∈ R/I ∧ y ∈ R/I ⇒
               f (gen ((gen x * gen y) ∘ I)) = f (gen x) *_ f (gen y))
   
   [<a name="kernel_ideal_quotient_bij-val"><b>kernel_ideal_quotient_bij</b></a>]  Theorem
      
      ⊢ ∀r r_ f.
          (r ~r~ r_) f ⇒
          (let i = kernel_ideal f r r_ in BIJ (f ∘ gen) R/I (IMAGE f R))
   
   [<a name="kernel_ideal_quotient_element_eq-val"><b>kernel_ideal_quotient_element_eq</b></a>]  Theorem
      
      ⊢ ∀r r_ f.
          (r ~r~ r_) f ⇒
          (let
             i = kernel_ideal f r r_
           in
             ∀x y. x ∈ R/I ∧ y ∈ R/I ⇒ (gen x − gen y ∈ I ⇔ x = y))
   
   [<a name="kernel_ideal_quotient_homo-val"><b>kernel_ideal_quotient_homo</b></a>]  Theorem
      
      ⊢ ∀r s f.
          (r ~r~ s) f ⇒
          (let
             i = kernel_ideal f r s
           in
             RingHomo (f ∘ gen) (r / i) (ring_homo_image f r s))
   
   [<a name="kernel_ideal_quotient_inj-val"><b>kernel_ideal_quotient_inj</b></a>]  Theorem
      
      ⊢ ∀r r_ f.
          (r ~r~ r_) f ⇒
          (let i = kernel_ideal f r r_ in INJ (f ∘ gen) R/I (IMAGE f R))
   
   [<a name="kernel_ideal_quotient_iso-val"><b>kernel_ideal_quotient_iso</b></a>]  Theorem
      
      ⊢ ∀r s f.
          (r ~r~ s) f ⇒
          (let
             i = kernel_ideal f r s
           in
             RingIso (f ∘ gen) (r / i) (ring_homo_image f r s))
   
   [<a name="kernel_ideal_quotient_surj-val"><b>kernel_ideal_quotient_surj</b></a>]  Theorem
      
      ⊢ ∀r r_ f.
          (r ~r~ r_) f ⇒
          (let i = kernel_ideal f r r_ in SURJ (f ∘ gen) R/I (IMAGE f R))
   
   [<a name="kernel_ideal_sum_eqn-val"><b>kernel_ideal_sum_eqn</b></a>]  Theorem
      
      ⊢ ∀r s f. (kernel_ideal f r s).sum = kernel_group f r.sum s.sum
   
   [<a name="ordz_eval-val"><b>ordz_eval</b></a>]  Theorem
      
      ⊢ ∀m n. order (times_mod m) n = compute_ordz m n
   
   [<a name="prime_is_irreducible-val"><b>prime_is_irreducible</b></a>]  Theorem
      
      ⊢ ∀r p.
          IntegralDomain r ∧ p ∈ R ∧ rprime p ∧ p ≠ #0 ∧ p ∉ R* ⇒ atom p
   
   [<a name="principal_ideal_element-val"><b>principal_ideal_element</b></a>]  Theorem
      
      ⊢ ∀p x. x ∈ &lt;p&gt;.carrier ⇔ ∃z. z ∈ R ∧ x = p * z
   
   [<a name="principal_ideal_element_divides-val"><b>principal_ideal_element_divides</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀p. p ∈ R ⇒ ∀x. x ∈ &lt;p&gt;.carrier ⇔ p rdivides x
   
   [<a name="principal_ideal_eq_principal_ideal-val"><b>principal_ideal_eq_principal_ideal</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀p q u. p ∈ R ∧ q ∈ R ∧ unit u ∧ p = q * u ⇒ &lt;p&gt; = &lt;q&gt;
   
   [<a name="principal_ideal_equal_principal_ideal-val"><b>principal_ideal_equal_principal_ideal</b></a>]  Theorem
      
      ⊢ ∀r. IntegralDomain r ⇒
            ∀p q. p ∈ R ∧ q ∈ R ⇒ (&lt;p&gt; = &lt;q&gt; ⇔ ∃u. unit u ∧ p = q * u)
   
   [<a name="principal_ideal_group-val"><b>principal_ideal_group</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀p. p ∈ R ⇒ Group &lt;p&gt;.sum
   
   [<a name="principal_ideal_has_element-val"><b>principal_ideal_has_element</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀p. p ∈ R ⇒ p ∈ &lt;p&gt;.carrier
   
   [<a name="principal_ideal_has_principal_ideal-val"><b>principal_ideal_has_principal_ideal</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀p q. p ∈ R ∧ q ∈ &lt;p&gt;.carrier ⇒ &lt;q&gt; &lt;&lt; &lt;p&gt;
   
   [<a name="principal_ideal_ideal-val"><b>principal_ideal_ideal</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀p. p ∈ R ⇒ &lt;p&gt; &lt;&lt; r
   
   [<a name="principal_ideal_property-val"><b>principal_ideal_property</b></a>]  Theorem
      
      ⊢ ∀r p.
          &lt;p&gt;.carrier = p * R ∧ &lt;p&gt;.sum.carrier = p * R ∧
          &lt;p&gt;.prod.carrier = p * R ∧ &lt;p&gt;.sum.op = $+ ∧ &lt;p&gt;.prod.op = $* ∧
          &lt;p&gt;.sum.id = #0 ∧ &lt;p&gt;.prod.id = #1
   
   [<a name="principal_ideal_ring_atom_is_prime-val"><b>principal_ideal_ring_atom_is_prime</b></a>]  Theorem
      
      ⊢ ∀r. PrincipalIdealRing r ⇒ ∀p. atom p ⇒ rprime p
   
   [<a name="principal_ideal_ring_ideal_maximal-val"><b>principal_ideal_ring_ideal_maximal</b></a>]  Theorem
      
      ⊢ ∀r. PrincipalIdealRing r ⇒ ∀p. atom p ⇒ maxi &lt;p&gt;
   
   [<a name="principal_ideal_ring_irreducible_is_prime-val"><b>principal_ideal_ring_irreducible_is_prime</b></a>]  Theorem
      
      ⊢ ∀r. PrincipalIdealRing r ⇒ ∀p. atom p ⇒ rprime p
   
   [<a name="principal_ideal_sub_implies_divides-val"><b>principal_ideal_sub_implies_divides</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀p q. p ∈ R ∧ q ∈ R ⇒ (q rdivides p ⇔ &lt;p&gt; &lt;&lt; &lt;q&gt;)
   
   [<a name="principal_ideal_subgroup-val"><b>principal_ideal_subgroup</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀p. p ∈ R ⇒ &lt;p&gt;.sum ≤ r.sum
   
   [<a name="principal_ideal_subgroup_normal-val"><b>principal_ideal_subgroup_normal</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀p. p ∈ R ⇒ &lt;p&gt;.sum &lt;&lt; r.sum
   
   [<a name="principal_ideal_sum_eq_ideal-val"><b>principal_ideal_sum_eq_ideal</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ ∀p. p ∈ I ⇒ &lt;p&gt; + i = i
   
   [<a name="principal_ideal_sum_equal_ideal-val"><b>principal_ideal_sum_equal_ideal</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ ∀p. p ∈ I ⇔ p ∈ R ∧ &lt;p&gt; + i = i
   
   [<a name="quotient_ring_add_abelian_group-val"><b>quotient_ring_add_abelian_group</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ∧ i &lt;&lt; r ⇒ AbelianGroup (quotient_ring_add r i)
   
   [<a name="quotient_ring_add_assoc-val"><b>quotient_ring_add_assoc</b></a>]  Theorem
      
      ⊢ ∀r i.
          Ring r ∧ i &lt;&lt; r ⇒
          ∀x y z. x ∈ R/I ∧ y ∈ R/I ∧ z ∈ R/I ⇒ x + y + z = x + (y + z)
   
   [<a name="quotient_ring_add_comm-val"><b>quotient_ring_add_comm</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ ∀x y. x ∈ R/I ∧ y ∈ R/I ⇒ x + y = y + x
   
   [<a name="quotient_ring_add_element-val"><b>quotient_ring_add_element</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ ∀x y. x ∈ R/I ∧ y ∈ R/I ⇒ x + y ∈ R/I
   
   [<a name="quotient_ring_add_group-val"><b>quotient_ring_add_group</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ Group (quotient_ring_add r i)
   
   [<a name="quotient_ring_add_id-val"><b>quotient_ring_add_id</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ ∀x. x ∈ R/I ⇒ I + x = x
   
   [<a name="quotient_ring_add_inv-val"><b>quotient_ring_add_inv</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ ∀x. x ∈ R/I ⇒ ∃y. y ∈ R/I ∧ y + x = I
   
   [<a name="quotient_ring_by_principal_ideal-val"><b>quotient_ring_by_principal_ideal</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀p. p ∈ R ⇒ Ring (r / &lt;p&gt;)
   
   [<a name="quotient_ring_element-val"><b>quotient_ring_element</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ ∀z. z ∈ R/I ⇔ ∃x. x ∈ R ∧ z = x ∘ I
   
   [<a name="quotient_ring_has_ideal-val"><b>quotient_ring_has_ideal</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ I ∈ R/I
   
   [<a name="quotient_ring_homo-val"><b>quotient_ring_homo</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ RingHomo (λx. x ∘ I) r (r / i)
   
   [<a name="quotient_ring_homo_kernel-val"><b>quotient_ring_homo_kernel</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ kernel (λx. x ∘ I) r.sum (r / i).sum = I
   
   [<a name="quotient_ring_homo_kernel_ideal-val"><b>quotient_ring_homo_kernel_ideal</b></a>]  Theorem
      
      ⊢ ∀r i.
          Ring r ∧ i &lt;&lt; r ⇒
          RingHomo (λx. x ∘ I) r (r / i) ∧
          kernel_ideal (λx. x ∘ I) r (r / i) = i
   
   [<a name="quotient_ring_homo_surj-val"><b>quotient_ring_homo_surj</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ SURJ (λx. x ∘ I) R R/I
   
   [<a name="quotient_ring_mult_abelian_monoid-val"><b>quotient_ring_mult_abelian_monoid</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ∧ i &lt;&lt; r ⇒ AbelianMonoid (quotient_ring_mult r i)
   
   [<a name="quotient_ring_mult_assoc-val"><b>quotient_ring_mult_assoc</b></a>]  Theorem
      
      ⊢ ∀r i.
          Ring r ∧ i &lt;&lt; r ⇒
          ∀x y z. x ∈ R/I ∧ y ∈ R/I ∧ z ∈ R/I ⇒ x * y * z = x * (y * z)
   
   [<a name="quotient_ring_mult_comm-val"><b>quotient_ring_mult_comm</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ ∀x y. x ∈ R/I ∧ y ∈ R/I ⇒ x * y = y * x
   
   [<a name="quotient_ring_mult_element-val"><b>quotient_ring_mult_element</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ ∀x y. x ∈ R/I ∧ y ∈ R/I ⇒ x * y ∈ R/I
   
   [<a name="quotient_ring_mult_id-val"><b>quotient_ring_mult_id</b></a>]  Theorem
      
      ⊢ ∀r i.
          Ring r ∧ i &lt;&lt; r ⇒ ∀x. x ∈ R/I ⇒ #1 ∘ I * x = x ∧ x * #1 ∘ I = x
   
   [<a name="quotient_ring_mult_ladd-val"><b>quotient_ring_mult_ladd</b></a>]  Theorem
      
      ⊢ ∀r i.
          Ring r ∧ i &lt;&lt; r ⇒
          ∀x y z. x ∈ R/I ∧ y ∈ R/I ∧ z ∈ R/I ⇒ x * (y + z) = x * y + x * z
   
   [<a name="quotient_ring_mult_monoid-val"><b>quotient_ring_mult_monoid</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ Monoid (quotient_ring_mult r i)
   
   [<a name="quotient_ring_property-val"><b>quotient_ring_property</b></a>]  Theorem
      
      ⊢ ∀r i.
          (r / i).carrier = R/I ∧ (r / i).sum = quotient_ring_add r i ∧
          (r / i).prod = quotient_ring_mult r i
   
   [<a name="quotient_ring_ring-val"><b>quotient_ring_ring</b></a>]  Theorem
      
      ⊢ ∀r i. Ring r ∧ i &lt;&lt; r ⇒ Ring (r / i)
   
   [<a name="quotient_ring_ring_sing-val"><b>quotient_ring_ring_sing</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ (r / r).carrier = {R}
   
   [<a name="ring_11-val"><b>ring_11</b></a>]  Theorem
      
      ⊢ ∀a0 a1 a2 a0' a1' a2'.
          ring a0 a1 a2 = ring a0' a1' a2' ⇔ a0 = a0' ∧ a1 = a1' ∧ a2 = a2'
   
   [<a name="ring_Axiom-val"><b>ring_Axiom</b></a>]  Theorem
      
      ⊢ ∀f. ∃fn. ∀a0 a1 a2. fn (ring a0 a1 a2) = f a0 a1 a2
   
   [<a name="ring_accessors-val"><b>ring_accessors</b></a>]  Theorem
      
      ⊢ (∀f m m0. (ring f m m0).carrier = f) ∧
        (∀f m m0. (ring f m m0).sum = m) ∧ ∀f m m0. (ring f m m0).prod = m0
   
   [<a name="ring_accfupds-val"><b>ring_accfupds</b></a>]  Theorem
      
      ⊢ (∀r f. (r with sum updated_by f).carrier = R) ∧
        (∀r f. (r with prod updated_by f).carrier = R) ∧
        (∀r f. (r with carrier updated_by f).sum = r.sum) ∧
        (∀r f. (r with prod updated_by f).sum = r.sum) ∧
        (∀r f. (r with carrier updated_by f).prod = r.prod) ∧
        (∀r f. (r with sum updated_by f).prod = r.prod) ∧
        (∀r f. (r with carrier updated_by f).carrier = f R) ∧
        (∀r f. (r with sum updated_by f).sum = f r.sum) ∧
        ∀r f. (r with prod updated_by f).prod = f r.prod
   
   [<a name="ring_add_abelian_group-val"><b>ring_add_abelian_group</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ AbelianGroup r.sum
   
   [<a name="ring_add_assoc-val"><b>ring_add_assoc</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ x + y + z = x + (y + z)
   
   [<a name="ring_add_assoc_comm-val"><b>ring_add_assoc_comm</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ x + (y + z) = y + (x + z)
   
   [<a name="ring_add_char_2-val"><b>ring_add_char_2</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ∧ char r = 2 ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ x + y = x − y
   
   [<a name="ring_add_comm-val"><b>ring_add_comm</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ x + y = y + x
   
   [<a name="ring_add_element-val"><b>ring_add_element</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ x + y ∈ R
   
   [<a name="ring_add_eq_zero-val"><b>ring_add_eq_zero</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ (x + y = #0 ⇔ y = -x)
   
   [<a name="ring_add_exp_eqn-val"><b>ring_add_exp_eqn</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀n. r.sum.exp x n = x * ##n
   
   [<a name="ring_add_group-val"><b>ring_add_group</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            Group r.sum ∧ r.sum.carrier = R ∧
            ∀x y. x ∈ R ∧ y ∈ R ⇒ x + y = y + x
   
   [<a name="ring_add_group_rwt-val"><b>ring_add_group_rwt</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ Group r.sum ∧ r.sum.carrier = R
   
   [<a name="ring_add_lcancel-val"><b>ring_add_lcancel</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ (x + y = x + z ⇔ y = z)
   
   [<a name="ring_add_lneg-val"><b>ring_add_lneg</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ -x + x = #0
   
   [<a name="ring_add_lneg_assoc-val"><b>ring_add_lneg_assoc</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y. x ∈ R ∧ y ∈ R ⇒ y = x + (-x + y) ∧ y = -x + (x + y)
   
   [<a name="ring_add_lzero-val"><b>ring_add_lzero</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ #0 + x = x
   
   [<a name="ring_add_pair_sub-val"><b>ring_add_pair_sub</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y p q.
              x ∈ R ∧ y ∈ R ∧ p ∈ R ∧ q ∈ R ⇒
              x + y − (p + q) = x − p + (y − q)
   
   [<a name="ring_add_rcancel-val"><b>ring_add_rcancel</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ (y + x = z + x ⇔ y = z)
   
   [<a name="ring_add_rneg-val"><b>ring_add_rneg</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ x + -x = #0
   
   [<a name="ring_add_rneg_assoc-val"><b>ring_add_rneg_assoc</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ y = y + -x + x ∧ y = y + x + -x
   
   [<a name="ring_add_rzero-val"><b>ring_add_rzero</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ x + #0 = x
   
   [<a name="ring_add_sub-val"><b>ring_add_sub</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ x + y − y = x
   
   [<a name="ring_add_sub_assoc-val"><b>ring_add_sub_assoc</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ x + y − z = x + (y − z)
   
   [<a name="ring_add_sub_comm-val"><b>ring_add_sub_comm</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ y + x − y = x
   
   [<a name="ring_add_sub_identity-val"><b>ring_add_sub_identity</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y z t.
              x ∈ R ∧ y ∈ R ∧ z ∈ R ∧ t ∈ R ⇒
              (x + y = z + t ⇔ x − z = t − y)
   
   [<a name="ring_add_zero_zero-val"><b>ring_add_zero_zero</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ #0 + #0 = #0
   
   [<a name="ring_associates_divides-val"><b>ring_associates_divides</b></a>]  Theorem
      
      ⊢ ∀r p q x. Ring r ∧ rassoc p q ∧ q ∈ R ∧ p rdivides x ⇒ q rdivides x
   
   [<a name="ring_associates_mult-val"><b>ring_associates_mult</b></a>]  Theorem
      
      ⊢ ∀r p q x.
          Ring r ∧ p ∈ R ∧ q ∈ R ∧ x ∈ R ∧ rassoc p q ⇒
          rassoc (x * p) (x * q)
   
   [<a name="ring_associates_refl-val"><b>ring_associates_refl</b></a>]  Theorem
      
      ⊢ ∀r x. Ring r ∧ x ∈ R ⇒ rassoc x x
   
   [<a name="ring_associates_sym-val"><b>ring_associates_sym</b></a>]  Theorem
      
      ⊢ ∀r p q. Ring r ∧ q ∈ R ∧ rassoc p q ⇒ rassoc q p
   
   [<a name="ring_associates_trans-val"><b>ring_associates_trans</b></a>]  Theorem
      
      ⊢ ∀r x y z. Ring r ∧ z ∈ R ∧ rassoc x y ∧ rassoc y z ⇒ rassoc x z
   
   [<a name="ring_auto_I-val"><b>ring_auto_I</b></a>]  Theorem
      
      ⊢ ∀r. RingAuto I r
   
   [<a name="ring_auto_bij-val"><b>ring_auto_bij</b></a>]  Theorem
      
      ⊢ ∀r f. Ring r ∧ RingAuto f r ⇒ f PERMUTES R
   
   [<a name="ring_auto_cong-val"><b>ring_auto_cong</b></a>]  Theorem
      
      ⊢ ∀r f1 f2.
          Ring r ∧ (∀x. x ∈ R ⇒ f1 x = f2 x) ⇒
          (RingAuto f1 r ⇔ RingAuto f2 r)
   
   [<a name="ring_auto_element-val"><b>ring_auto_element</b></a>]  Theorem
      
      ⊢ ∀r f. RingAuto f r ⇒ ∀x. x ∈ R ⇒ f x ∈ R
   
   [<a name="ring_auto_ids-val"><b>ring_auto_ids</b></a>]  Theorem
      
      ⊢ ∀r f. Ring r ∧ RingAuto f r ⇒ f #0 = #0 ∧ f #1 = #1
   
   [<a name="ring_auto_linv_auto-val"><b>ring_auto_linv_auto</b></a>]  Theorem
      
      ⊢ ∀r f. Ring r ∧ RingAuto f r ⇒ RingAuto (LINV f R) r
   
   [<a name="ring_auto_one-val"><b>ring_auto_one</b></a>]  Theorem
      
      ⊢ ∀r f. Ring r ∧ RingAuto f r ⇒ f #1 = #1
   
   [<a name="ring_auto_zero-val"><b>ring_auto_zero</b></a>]  Theorem
      
      ⊢ ∀r f. Ring r ∧ RingAuto f r ⇒ f #0 = #0
   
   [<a name="ring_binomial_2-val"><b>ring_binomial_2</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y.
              x ∈ R ∧ y ∈ R ⇒
              (x + y) ** 2 = x ** 2 + ##2 * (x * y) + y ** 2
   
   [<a name="ring_binomial_3-val"><b>ring_binomial_3</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y.
              x ∈ R ∧ y ∈ R ⇒
              (x + y) ** 3 =
              x ** 3 + ##3 * (x ** 2 * y) + ##3 * (x * y ** 2) + y ** 3
   
   [<a name="ring_binomial_4-val"><b>ring_binomial_4</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y.
              x ∈ R ∧ y ∈ R ⇒
              (x + y) ** 4 =
              x ** 4 + ##4 * (x ** 3 * y) + ##6 * (x ** 2 * y ** 2) +
              ##4 * (x * y ** 3) + y ** 4
   
   [<a name="ring_binomial_genlist_index_shift-val"><b>ring_binomial_genlist_index_shift</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y.
              x ∈ R ∧ y ∈ R ⇒
              ∀n. GENLIST
                    ((λk. ##(binomial n k) * x ** SUC (n − k) * y ** k) ∘
                     SUC) n =
                  GENLIST
                    (λk. ##(binomial n (SUC k)) * x ** (n − k) * y ** SUC k)
                    n
   
   [<a name="ring_binomial_index_shift-val"><b>ring_binomial_index_shift</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y.
              x ∈ R ∧ y ∈ R ⇒
              ∀n. (λk. ##(binomial (SUC n) k) * x ** (SUC n − k) * y ** k) ∘
                  SUC =
                  (λk.
                       ##(binomial (SUC n) (SUC k)) * x ** (n − k) *
                       y ** SUC k)
   
   [<a name="ring_binomial_term_merge_x-val"><b>ring_binomial_term_merge_x</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y.
              x ∈ R ∧ y ∈ R ⇒
              ∀n. (λk. x * k) ∘
                  (λk. ##(binomial n k) * x ** (n − k) * y ** k) =
                  (λk. ##(binomial n k) * x ** SUC (n − k) * y ** k)
   
   [<a name="ring_binomial_term_merge_y-val"><b>ring_binomial_term_merge_y</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y.
              x ∈ R ∧ y ∈ R ⇒
              ∀n. (λk. y * k) ∘
                  (λk. ##(binomial n k) * x ** (n − k) * y ** k) =
                  (λk. ##(binomial n k) * x ** (n − k) * y ** SUC k)
   
   [<a name="ring_binomial_thm-val"><b>ring_binomial_thm</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y.
              x ∈ R ∧ y ∈ R ⇒
              ∀n. (x + y) ** n =
                  rsum
                    (GENLIST (λk. ##(binomial n k) * x ** (n − k) * y ** k)
                       (SUC n))
   
   [<a name="ring_carrier_nonempty-val"><b>ring_carrier_nonempty</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ R ≠ ∅
   
   [<a name="ring_carriers-val"><b>ring_carriers</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ r.sum.carrier = R ∧ r.prod.carrier = R
   
   [<a name="ring_case_cong-val"><b>ring_case_cong</b></a>]  Theorem
      
      ⊢ ∀M M' f.
          M = M' ∧
          (∀a0 a1 a2. M' = ring a0 a1 a2 ⇒ f a0 a1 a2 = f' a0 a1 a2) ⇒
          ring_CASE M f = ring_CASE M' f'
   
   [<a name="ring_case_eq-val"><b>ring_case_eq</b></a>]  Theorem
      
      ⊢ ring_CASE x f = v ⇔ ∃f' m m0. x = ring f' m m0 ∧ f f' m m0 = v
   
   [<a name="ring_char_0-val"><b>ring_char_0</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ∧ char r = 0 ⇒ INFINITE R
   
   [<a name="ring_char_1-val"><b>ring_char_1</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ∧ char r = 1 ⇒ R = {#0}
   
   [<a name="ring_char_2_double-val"><b>ring_char_2_double</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ∧ char r = 2 ⇒ ∀x. x ∈ R ⇒ x + x = #0
   
   [<a name="ring_char_2_neg_one-val"><b>ring_char_2_neg_one</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ∧ char r = 2 ⇒ -#1 = #1
   
   [<a name="ring_char_2_property-val"><b>ring_char_2_property</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ∧ char r = 2 ⇒ #1 + #1 = #0
   
   [<a name="ring_char_alt-val"><b>ring_char_alt</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀n. 0 &lt; n ⇒
                (char r = n ⇔ ##n = #0 ∧ ∀m. 0 &lt; m ∧ m &lt; n ⇒ ##m ≠ #0)
   
   [<a name="ring_char_divides-val"><b>ring_char_divides</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀n. ##n = #0 ⇔ char r divides n
   
   [<a name="ring_char_eq_1-val"><b>ring_char_eq_1</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ (char r = 1 ⇔ #1 = #0)
   
   [<a name="ring_char_prime-val"><b>ring_char_prime</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            (prime (char r) ⇔
             1 &lt; char r ∧
             ∀k. 0 &lt; k ∧ k &lt; char r ⇒ ##(binomial (char r) k) = #0)
   
   [<a name="ring_char_prime_endo-val"><b>ring_char_prime_endo</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ∧ prime (char r) ⇒ RingEndo (λx. x ** char r) r
   
   [<a name="ring_component_equality-val"><b>ring_component_equality</b></a>]  Theorem
      
      ⊢ ∀r1 r2.
          r1 = r2 ⇔
          r1.carrier = r2.carrier ∧ r1.sum = r2.sum ∧ r1.prod = r2.prod
   
   [<a name="ring_divides_associates-val"><b>ring_divides_associates</b></a>]  Theorem
      
      ⊢ ∀r x y p.
          Ring r ∧ rassoc x y ∧ p ∈ R ∧ y ∈ R ∧ p rdivides x ⇒ p rdivides y
   
   [<a name="ring_divides_by_one-val"><b>ring_divides_by_one</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀p. p ∈ R ⇒ #1 rdivides p
   
   [<a name="ring_divides_by_unit-val"><b>ring_divides_by_unit</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀p t. p ∈ R ∧ unit t ⇒ t rdivides p
   
   [<a name="ring_divides_iso-val"><b>ring_divides_iso</b></a>]  Theorem
      
      ⊢ ∀r r_ f.
          (r =r= r_) f ⇒
          ∀p q. p ∈ R ∧ p rdivides q ⇒ ring_divides r_ (f p) (f q)
   
   [<a name="ring_divides_le-val"><b>ring_divides_le</b></a>]  Theorem
      
      ⊢ ∀r f.
          EuclideanRing r f ∧ ring_ordering r f ⇒
          ∀p q. p ∈ R ∧ q ∈ R ∧ p ≠ #0 ∧ q rdivides p ⇒ f q ≤ f p
   
   [<a name="ring_divides_refl-val"><b>ring_divides_refl</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀p. p ∈ R ⇒ p rdivides p
   
   [<a name="ring_divides_trans-val"><b>ring_divides_trans</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀p q t.
              p ∈ R ∧ q ∈ R ∧ t ∈ R ∧ p rdivides q ∧ q rdivides t ⇒
              p rdivides t
   
   [<a name="ring_divides_zero-val"><b>ring_divides_zero</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀p. p ∈ R ⇒ p rdivides #0
   
   [<a name="ring_eq_unit_eq-val"><b>ring_eq_unit_eq</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ∧ x = y ⇒ x =~ y
   
   [<a name="ring_exp_0-val"><b>ring_exp_0</b></a>]  Theorem
      
      ⊢ ∀x. x ** 0 = #1
   
   [<a name="ring_exp_1-val"><b>ring_exp_1</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ x ** 1 = x
   
   [<a name="ring_exp_SUC-val"><b>ring_exp_SUC</b></a>]  Theorem
      
      ⊢ ∀x n. x ** SUC n = x * x ** n
   
   [<a name="ring_exp_add-val"><b>ring_exp_add</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀n k. x ** (n + k) = x ** n * x ** k
   
   [<a name="ring_exp_add_assoc-val"><b>ring_exp_add_assoc</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y.
              x ∈ R ∧ y ∈ R ⇒
              ∀n k. x ** n * (x ** k * y) = x ** (n + k) * y
   
   [<a name="ring_exp_comm-val"><b>ring_exp_comm</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀n. x ** n * x = x * x ** n
   
   [<a name="ring_exp_element-val"><b>ring_exp_element</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀n. x ** n ∈ R
   
   [<a name="ring_exp_mod_order-val"><b>ring_exp_mod_order</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x. x ∈ R ∧ 0 &lt; order r.prod x ⇒
                ∀n. x ** n = x ** (n MOD order r.prod x)
   
   [<a name="ring_exp_mult-val"><b>ring_exp_mult</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀n k. x ** (n * k) = (x ** n) ** k
   
   [<a name="ring_exp_mult_comm-val"><b>ring_exp_mult_comm</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀m n. (x ** m) ** n = (x ** n) ** m
   
   [<a name="ring_exp_neg-val"><b>ring_exp_neg</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x. x ∈ R ⇒ ∀n. -x ** n = if EVEN n then x ** n else -(x ** n)
   
   [<a name="ring_exp_small-val"><b>ring_exp_small</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x. x ∈ R ⇒
                x ** 0 = #1 ∧ x ** 1 = x ∧ x ** 2 = x * x ∧
                x ** 3 = x * x ** 2 ∧ x ** 4 = x * x ** 3 ∧
                x ** 5 = x * x ** 4 ∧ x ** 6 = x * x ** 5 ∧
                x ** 7 = x * x ** 6 ∧ x ** 8 = x * x ** 7 ∧
                x ** 9 = x * x ** 8
   
   [<a name="ring_exp_suc-val"><b>ring_exp_suc</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀n. x ** SUC n = x ** n * x
   
   [<a name="ring_factor_multiple-val"><b>ring_factor_multiple</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀p q.
              p ∈ R ∧ q ∈ R ∧ (∃k. k ∈ R ∧ p = k * q) ⇒
              ∀z. z ∈ R ∧ (∃s. s ∈ R ∧ z = s * p) ⇒ ∃t. t ∈ R ∧ z = t * q
   
   [<a name="ring_fermat_all-val"><b>ring_fermat_all</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ∧ prime (char r) ⇒ ∀n k. ##n ** char r ** k = ##n
   
   [<a name="ring_fermat_thm-val"><b>ring_fermat_thm</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ∧ prime (char r) ⇒ ∀n. ##n ** char r = ##n
   
   [<a name="ring_first_isomorphism_thm-val"><b>ring_first_isomorphism_thm</b></a>]  Theorem
      
      ⊢ ∀r r_ f.
          (r ~r~ r_) f ⇒
          (let
             i = kernel_ideal f r r_
           in
             i &lt;&lt; r ∧ ring_homo_image f r r_ ≤ r_ ∧
             RingIso (f ∘ gen) (r / i) (ring_homo_image f r r_))
   
   [<a name="ring_fn_updates-val"><b>ring_fn_updates</b></a>]  Theorem
      
      ⊢ (∀f0 f m m0.
           ring f m m0 with carrier updated_by f0 = ring (f0 f) m m0) ∧
        (∀f0 f m m0. ring f m m0 with sum updated_by f0 = ring f (f0 m) m0) ∧
        ∀f0 f m m0. ring f m m0 with prod updated_by f0 = ring f m (f0 m0)
   
   [<a name="ring_freshman_all-val"><b>ring_freshman_all</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ∧ prime (char r) ⇒
            ∀x y.
              x ∈ R ∧ y ∈ R ⇒
              ∀n. (x + y) ** char r ** n =
                  x ** char r ** n + y ** char r ** n
   
   [<a name="ring_freshman_all_sub-val"><b>ring_freshman_all_sub</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ∧ prime (char r) ⇒
            ∀x y.
              x ∈ R ∧ y ∈ R ⇒
              ∀n. (x − y) ** char r ** n =
                  x ** char r ** n − y ** char r ** n
   
   [<a name="ring_freshman_thm-val"><b>ring_freshman_thm</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ∧ prime (char r) ⇒
            ∀x y.
              x ∈ R ∧ y ∈ R ⇒ (x + y) ** char r = x ** char r + y ** char r
   
   [<a name="ring_freshman_thm_sub-val"><b>ring_freshman_thm_sub</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ∧ prime (char r) ⇒
            ∀x y.
              x ∈ R ∧ y ∈ R ⇒ (x − y) ** char r = x ** char r − y ** char r
   
   [<a name="ring_fun_add-val"><b>ring_fun_add</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀a b. rfun a ∧ rfun b ⇒ rfun (λk. a k + b k)
   
   [<a name="ring_fun_from_ring_fun-val"><b>ring_fun_from_ring_fun</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀f. rfun f ⇒ ∀x. x ∈ R ⇒ rfun (λj. f j * x ** j)
   
   [<a name="ring_fun_from_ring_fun_exp-val"><b>ring_fun_from_ring_fun_exp</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀f. rfun f ⇒ ∀x. x ∈ R ⇒ ∀n. rfun (λj. (f j * x ** j) ** n)
   
   [<a name="ring_fun_genlist-val"><b>ring_fun_genlist</b></a>]  Theorem
      
      ⊢ ∀f. rfun f ⇒ ∀n. rlist (GENLIST f n)
   
   [<a name="ring_fun_map-val"><b>ring_fun_map</b></a>]  Theorem
      
      ⊢ ∀f l. rfun f ⇒ rlist (MAP f l)
   
   [<a name="ring_fupdcanon-val"><b>ring_fupdcanon</b></a>]  Theorem
      
      ⊢ (∀r g f.
           r with &lt;|sum updated_by f; carrier updated_by g|&gt; =
           r with &lt;|carrier updated_by g; sum updated_by f|&gt;) ∧
        (∀r g f.
           r with &lt;|prod updated_by f; carrier updated_by g|&gt; =
           r with &lt;|carrier updated_by g; prod updated_by f|&gt;) ∧
        ∀r g f.
          r with &lt;|prod updated_by f; sum updated_by g|&gt; =
          r with &lt;|sum updated_by g; prod updated_by f|&gt;
   
   [<a name="ring_fupdcanon_comp-val"><b>ring_fupdcanon_comp</b></a>]  Theorem
      
      ⊢ ((∀g f. sum_fupd f ∘ carrier_fupd g = carrier_fupd g ∘ sum_fupd f) ∧
         ∀h g f.
           sum_fupd f ∘ carrier_fupd g ∘ h =
           carrier_fupd g ∘ sum_fupd f ∘ h) ∧
        ((∀g f. prod_fupd f ∘ carrier_fupd g = carrier_fupd g ∘ prod_fupd f) ∧
         ∀h g f.
           prod_fupd f ∘ carrier_fupd g ∘ h =
           carrier_fupd g ∘ prod_fupd f ∘ h) ∧
        (∀g f. prod_fupd f ∘ sum_fupd g = sum_fupd g ∘ prod_fupd f) ∧
        ∀h g f. prod_fupd f ∘ sum_fupd g ∘ h = sum_fupd g ∘ prod_fupd f ∘ h
   
   [<a name="ring_fupdfupds-val"><b>ring_fupdfupds</b></a>]  Theorem
      
      ⊢ (∀r g f.
           r with &lt;|carrier updated_by f; carrier updated_by g|&gt; =
           r with carrier updated_by f ∘ g) ∧
        (∀r g f.
           r with &lt;|sum updated_by f; sum updated_by g|&gt; =
           r with sum updated_by f ∘ g) ∧
        ∀r g f.
          r with &lt;|prod updated_by f; prod updated_by g|&gt; =
          r with prod updated_by f ∘ g
   
   [<a name="ring_fupdfupds_comp-val"><b>ring_fupdfupds_comp</b></a>]  Theorem
      
      ⊢ ((∀g f. carrier_fupd f ∘ carrier_fupd g = carrier_fupd (f ∘ g)) ∧
         ∀h g f.
           carrier_fupd f ∘ carrier_fupd g ∘ h = carrier_fupd (f ∘ g) ∘ h) ∧
        ((∀g f. sum_fupd f ∘ sum_fupd g = sum_fupd (f ∘ g)) ∧
         ∀h g f. sum_fupd f ∘ sum_fupd g ∘ h = sum_fupd (f ∘ g) ∘ h) ∧
        (∀g f. prod_fupd f ∘ prod_fupd g = prod_fupd (f ∘ g)) ∧
        ∀h g f. prod_fupd f ∘ prod_fupd g ∘ h = prod_fupd (f ∘ g) ∘ h
   
   [<a name="ring_gcd_divides-val"><b>ring_gcd_divides</b></a>]  Theorem
      
      ⊢ ∀r f.
          EuclideanRing r f ⇒
          ∀p q. p ∈ R ∧ q ∈ R ⇒ rgcd p q rdivides p ∧ rgcd p q rdivides q
   
   [<a name="ring_gcd_element-val"><b>ring_gcd_element</b></a>]  Theorem
      
      ⊢ ∀r f. EuclideanRing r f ⇒ ∀p q. p ∈ R ∧ q ∈ R ⇒ rgcd p q ∈ R
   
   [<a name="ring_gcd_is_gcd-val"><b>ring_gcd_is_gcd</b></a>]  Theorem
      
      ⊢ ∀r f.
          EuclideanRing r f ⇒
          ∀p q.
            p ∈ R ∧ q ∈ R ⇒
            rgcd p q rdivides p ∧ rgcd p q rdivides q ∧
            ∀d. d ∈ R ∧ d rdivides p ∧ d rdivides q ⇒ d rdivides rgcd p q
   
   [<a name="ring_gcd_linear-val"><b>ring_gcd_linear</b></a>]  Theorem
      
      ⊢ ∀r f.
          EuclideanRing r f ⇒
          ∀p q.
            p ∈ R ∧ q ∈ R ⇒ ∃a b. a ∈ R ∧ b ∈ R ∧ rgcd p q = a * p + b * q
   
   [<a name="ring_gcd_property-val"><b>ring_gcd_property</b></a>]  Theorem
      
      ⊢ ∀r f.
          EuclideanRing r f ⇒
          ∀p q.
            p ∈ R ∧ q ∈ R ⇒
            ∀d. d ∈ R ∧ d rdivides p ∧ d rdivides q ⇒ d rdivides rgcd p q
   
   [<a name="ring_gcd_sym-val"><b>ring_gcd_sym</b></a>]  Theorem
      
      ⊢ ∀r f. EuclideanRing r f ⇒ ∀p q. p ∈ R ∧ q ∈ R ⇒ rgcd p q = rgcd q p
   
   [<a name="ring_gcd_zero-val"><b>ring_gcd_zero</b></a>]  Theorem
      
      ⊢ ∀r f p. rgcd p #0 = p ∧ rgcd #0 p = p
   
   [<a name="ring_homo_I_refl-val"><b>ring_homo_I_refl</b></a>]  Theorem
      
      ⊢ ∀r. RingHomo I r r
   
   [<a name="ring_homo_add-val"><b>ring_homo_add</b></a>]  Theorem
      
      ⊢ ∀r r_ f.
          (r ~r~ r_) f ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ f (x + y) = f x +_ f y
   
   [<a name="ring_homo_char_divides-val"><b>ring_homo_char_divides</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r ~r~ r_) f ⇒ char r_ divides char r
   
   [<a name="ring_homo_compose-val"><b>ring_homo_compose</b></a>]  Theorem
      
      ⊢ ∀r s t f1 f2.
          RingHomo f1 r s ∧ RingHomo f2 s t ⇒ RingHomo (f2 ∘ f1) r t
   
   [<a name="ring_homo_cong-val"><b>ring_homo_cong</b></a>]  Theorem
      
      ⊢ ∀r r_ f1 f2.
          Ring r ∧ Ring r_ ∧ (∀x. x ∈ R ⇒ f1 x = f2 x) ⇒
          (RingHomo f1 r r_ ⇔ RingHomo f2 r r_)
   
   [<a name="ring_homo_element-val"><b>ring_homo_element</b></a>]  Theorem
      
      ⊢ ∀r r_ f. RingHomo f r r_ ⇒ ∀x. x ∈ R ⇒ f x ∈ R_
   
   [<a name="ring_homo_eq_zero-val"><b>ring_homo_eq_zero</b></a>]  Theorem
      
      ⊢ ∀r r_ f.
          (r ~r~ r_) f ∧ INJ f R R_ ⇒ ∀x. x ∈ R ⇒ (f x = #0_ ⇔ x = #0)
   
   [<a name="ring_homo_exp-val"><b>ring_homo_exp</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r ~r~ r_) f ⇒ ∀x. x ∈ R ⇒ ∀n. f (x ** n) = f x **_ n
   
   [<a name="ring_homo_ideal_group-val"><b>ring_homo_ideal_group</b></a>]  Theorem
      
      ⊢ ∀r s f. (r ~r~ s) f ⇒ ∀i. i &lt;&lt; r ⇒ Group (homo_ideal f r s i).sum
   
   [<a name="ring_homo_ideal_ideal-val"><b>ring_homo_ideal_ideal</b></a>]  Theorem
      
      ⊢ ∀r s f.
          Ring r ∧ Ring s ∧ RingHomo f r s ∧ SURJ f R s.carrier ⇒
          ∀i. i &lt;&lt; r ⇒ homo_ideal f r s i &lt;&lt; s
   
   [<a name="ring_homo_ideal_subgroup-val"><b>ring_homo_ideal_subgroup</b></a>]  Theorem
      
      ⊢ ∀r s f. (r ~r~ s) f ⇒ ∀i. i &lt;&lt; r ⇒ (homo_ideal f r s i).sum ≤ s.sum
   
   [<a name="ring_homo_ids-val"><b>ring_homo_ids</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r ~r~ r_) f ⇒ f #0 = #0_ ∧ f #1 = #1_
   
   [<a name="ring_homo_image_bij-val"><b>ring_homo_image_bij</b></a>]  Theorem
      
      ⊢ ∀r r_ f.
          (r ~r~ r_) f ∧ INJ f R R_ ⇒
          BIJ f R (ring_homo_image f r r_).carrier
   
   [<a name="ring_homo_image_carrier-val"><b>ring_homo_image_carrier</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (ring_homo_image f r r_).carrier = IMAGE f R
   
   [<a name="ring_homo_image_homo-val"><b>ring_homo_image_homo</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r ~r~ r_) f ⇒ RingHomo f r (ring_homo_image f r r_)
   
   [<a name="ring_homo_image_is_subring-val"><b>ring_homo_image_is_subring</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r ~r~ r_) f ⇒ subring (ring_homo_image f r r_) r_
   
   [<a name="ring_homo_image_iso-val"><b>ring_homo_image_iso</b></a>]  Theorem
      
      ⊢ ∀r r_ f.
          (r ~r~ r_) f ∧ INJ f R R_ ⇒ RingIso f r (ring_homo_image f r r_)
   
   [<a name="ring_homo_image_ring-val"><b>ring_homo_image_ring</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r ~r~ r_) f ⇒ Ring (ring_homo_image f r r_)
   
   [<a name="ring_homo_image_subring-val"><b>ring_homo_image_subring</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r ~r~ r_) f ⇒ ring_homo_image f r r_ ≤ r_
   
   [<a name="ring_homo_image_subring_subring-val"><b>ring_homo_image_subring_subring</b></a>]  Theorem
      
      ⊢ ∀r r_ f.
          (r ~r~ r_) f ⇒
          ∀s. Ring s ∧ subring s r ⇒ subring (ring_homo_image f s r_) r_
   
   [<a name="ring_homo_image_surj_property-val"><b>ring_homo_image_surj_property</b></a>]  Theorem
      
      ⊢ ∀r r_ f.
          Ring r ∧ Ring r_ ∧ SURJ f R R_ ⇒
          RingIso I r_ (ring_homo_image f r r_)
   
   [<a name="ring_homo_inv-val"><b>ring_homo_inv</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r ~r~ r_) f ⇒ ∀x. unit x ⇒ f ( |/ x) = |/_ (f x)
   
   [<a name="ring_homo_kernel_ideal-val"><b>ring_homo_kernel_ideal</b></a>]  Theorem
      
      ⊢ ∀f r s. (r ~r~ s) f ⇒ kernel_ideal f r s &lt;&lt; r
   
   [<a name="ring_homo_linv_homo-val"><b>ring_homo_linv_homo</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r ~r~ r_) f ∧ BIJ f R R_ ⇒ RingHomo (LINV f R) r_ r
   
   [<a name="ring_homo_mult-val"><b>ring_homo_mult</b></a>]  Theorem
      
      ⊢ ∀r r_ f.
          (r ~r~ r_) f ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ f (x * y) = f x *_ f y
   
   [<a name="ring_homo_neg-val"><b>ring_homo_neg</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r ~r~ r_) f ⇒ ∀x. x ∈ R ⇒ f (-x) = $-_ (f x)
   
   [<a name="ring_homo_num-val"><b>ring_homo_num</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r ~r~ r_) f ⇒ ∀n. f (##n) = ##_ #1_ n
   
   [<a name="ring_homo_num_nonzero-val"><b>ring_homo_num_nonzero</b></a>]  Theorem
      
      ⊢ ∀r r_ f.
          (r ~r~ r_) f ⇒ ∀c. 0 &lt; c ∧ c &lt; char r_ ⇒ ##c ≠ #0 ∧ f (##c) ≠ #0_
   
   [<a name="ring_homo_one-val"><b>ring_homo_one</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r ~r~ r_) f ⇒ f #1 = #1_
   
   [<a name="ring_homo_one_eq_zero-val"><b>ring_homo_one_eq_zero</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r ~r~ r_) f ∧ #1 = #0 ⇒ #1_ = #0_
   
   [<a name="ring_homo_property-val"><b>ring_homo_property</b></a>]  Theorem
      
      ⊢ ∀r r_ f.
          Ring r ∧ RingHomo f r r_ ⇒
          ∀x y.
            x ∈ R ∧ y ∈ R ⇒ f (x + y) = f x +_ f y ∧ f (x * y) = f x *_ f y
   
   [<a name="ring_homo_ring_homo_subring-val"><b>ring_homo_ring_homo_subring</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r ~r~ r_) f ⇒ subring (ring_homo_image f r r_) r_
   
   [<a name="ring_homo_sub-val"><b>ring_homo_sub</b></a>]  Theorem
      
      ⊢ ∀r r_ f.
          (r ~r~ r_) f ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ f (x − y) = f x -_ f y
   
   [<a name="ring_homo_subring_homo-val"><b>ring_homo_subring_homo</b></a>]  Theorem
      
      ⊢ ∀r s r_ f. (r ~r~ r_) f ∧ s ≤ r ⇒ (s ~r~ ring_homo_image f s r_) f
   
   [<a name="ring_homo_sum_num_property-val"><b>ring_homo_sum_num_property</b></a>]  Theorem
      
      ⊢ ∀r r_ f.
          (r ~r~ r_) f ⇒
          ∀c. 0 &lt; c ∧ c &lt; char r_ ⇒ ##c ≠ #0 ∧ ##_ #1_ c ≠ #0_
   
   [<a name="ring_homo_sym-val"><b>ring_homo_sym</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r ~r~ r_) f ∧ BIJ f R R_ ⇒ RingHomo (LINV f R) r_ r
   
   [<a name="ring_homo_sym_any-val"><b>ring_homo_sym_any</b></a>]  Theorem
      
      ⊢ Ring r ∧ Ring s ∧ RingHomo f r s ∧
        (∀x. x ∈ s.carrier ⇒ i x ∈ R ∧ f (i x) = x) ∧
        (∀x. x ∈ R ⇒ i (f x) = x) ⇒
        RingHomo i s r
   
   [<a name="ring_homo_trans-val"><b>ring_homo_trans</b></a>]  Theorem
      
      ⊢ ∀r s t f1 f2.
          RingHomo f1 r s ∧ RingHomo f2 s t ⇒ RingHomo (f2 ∘ f1) r t
   
   [<a name="ring_homo_unit-val"><b>ring_homo_unit</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r ~r~ r_) f ⇒ ∀x. unit x ⇒ unit_ (f x)
   
   [<a name="ring_homo_unit_inv-val"><b>ring_homo_unit_inv</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r ~r~ r_) f ⇒ ∀x. unit x ⇒ |/_ (f x) = f ( |/ x)
   
   [<a name="ring_homo_unit_inv_element-val"><b>ring_homo_unit_inv_element</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r ~r~ r_) f ⇒ ∀x. unit x ⇒ |/_ (f x) ∈ R_
   
   [<a name="ring_homo_unit_inv_nonzero-val"><b>ring_homo_unit_inv_nonzero</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r ~r~ r_) f ∧ #1_ ≠ #0_ ⇒ ∀x. unit x ⇒ |/_ (f x) ≠ #0_
   
   [<a name="ring_homo_unit_nonzero-val"><b>ring_homo_unit_nonzero</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r ~r~ r_) f ∧ #1_ ≠ #0_ ⇒ ∀x. unit x ⇒ f x ≠ #0_
   
   [<a name="ring_homo_zero-val"><b>ring_homo_zero</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r ~r~ r_) f ⇒ f #0 = #0_
   
   [<a name="ring_induction-val"><b>ring_induction</b></a>]  Theorem
      
      ⊢ ∀P. (∀f m m0. P (ring f m m0)) ⇒ ∀r. P r
   
   [<a name="ring_inj_image_alt-val"><b>ring_inj_image_alt</b></a>]  Theorem
      
      ⊢ ∀r f.
          Ring r ⇒
          ring_inj_image r f =
          &lt;|carrier := IMAGE f R; sum := monoid_inj_image r.sum f;
            prod := monoid_inj_image r.prod f|&gt;
   
   [<a name="ring_inj_image_carrier-val"><b>ring_inj_image_carrier</b></a>]  Theorem
      
      ⊢ ∀r f. (ring_inj_image r f).carrier = IMAGE f R
   
   [<a name="ring_inj_image_prod_abelian_monoid-val"><b>ring_inj_image_prod_abelian_monoid</b></a>]  Theorem
      
      ⊢ ∀r f.
          Ring r ∧ INJ f R 𝕌(:β) ⇒ AbelianMonoid (ring_inj_image r f).prod
   
   [<a name="ring_inj_image_prod_monoid-val"><b>ring_inj_image_prod_monoid</b></a>]  Theorem
      
      ⊢ ∀r f. Ring r ∧ INJ f R 𝕌(:β) ⇒ Monoid (ring_inj_image r f).prod
   
   [<a name="ring_inj_image_prod_monoid_homo-val"><b>ring_inj_image_prod_monoid_homo</b></a>]  Theorem
      
      ⊢ ∀r f.
          Ring r ∧ INJ f R 𝕌(:β) ⇒
          MonoidHomo f r.prod (ring_inj_image r f).prod
   
   [<a name="ring_inj_image_ring-val"><b>ring_inj_image_ring</b></a>]  Theorem
      
      ⊢ ∀r f. Ring r ∧ INJ f R 𝕌(:β) ⇒ Ring (ring_inj_image r f)
   
   [<a name="ring_inj_image_ring_homo-val"><b>ring_inj_image_ring_homo</b></a>]  Theorem
      
      ⊢ ∀r f. Ring r ∧ INJ f R 𝕌(:β) ⇒ RingHomo f r (ring_inj_image r f)
   
   [<a name="ring_inj_image_sum_abelian_group-val"><b>ring_inj_image_sum_abelian_group</b></a>]  Theorem
      
      ⊢ ∀r f.
          Ring r ∧ INJ f R 𝕌(:β) ⇒ AbelianGroup (ring_inj_image r f).sum
   
   [<a name="ring_inj_image_sum_group-val"><b>ring_inj_image_sum_group</b></a>]  Theorem
      
      ⊢ ∀r f. Ring r ∧ INJ f R 𝕌(:β) ⇒ Group (ring_inj_image r f).sum
   
   [<a name="ring_inj_image_sum_group_homo-val"><b>ring_inj_image_sum_group_homo</b></a>]  Theorem
      
      ⊢ ∀r f.
          Ring r ∧ INJ f R 𝕌(:β) ⇒
          GroupHomo f r.sum (ring_inj_image r f).sum
   
   [<a name="ring_inj_image_sum_monoid-val"><b>ring_inj_image_sum_monoid</b></a>]  Theorem
      
      ⊢ ∀r f. Ring r ∧ INJ f R 𝕌(:β) ⇒ Monoid (ring_inj_image r f).sum
   
   [<a name="ring_inv_one-val"><b>ring_inv_one</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ |/ #1 = #1
   
   [<a name="ring_irreducible_gcd-val"><b>ring_irreducible_gcd</b></a>]  Theorem
      
      ⊢ ∀r f.
          EuclideanRing r f ⇒
          ∀p. p ∈ R ∧ atom p ⇒ ∀q. q ∈ R ⇒ unit (rgcd p q) ∨ p rdivides q
   
   [<a name="ring_iso_I_refl-val"><b>ring_iso_I_refl</b></a>]  Theorem
      
      ⊢ ∀r. RingIso I r r
   
   [<a name="ring_iso_add-val"><b>ring_iso_add</b></a>]  Theorem
      
      ⊢ ∀r r_ f.
          (r =r= r_) f ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ f (x + y) = f x +_ f y
   
   [<a name="ring_iso_bij-val"><b>ring_iso_bij</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r =r= r_) f ⇒ BIJ f R R_
   
   [<a name="ring_iso_card_eq-val"><b>ring_iso_card_eq</b></a>]  Theorem
      
      ⊢ ∀r r_ f. RingIso f r r_ ∧ FINITE R ⇒ CARD R = CARD R_
   
   [<a name="ring_iso_char_eq-val"><b>ring_iso_char_eq</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r =r= r_) f ⇒ char r_ = char r
   
   [<a name="ring_iso_compose-val"><b>ring_iso_compose</b></a>]  Theorem
      
      ⊢ ∀r s t f1 f2.
          RingIso f1 r s ∧ RingIso f2 s t ⇒ RingIso (f2 ∘ f1) r t
   
   [<a name="ring_iso_cong-val"><b>ring_iso_cong</b></a>]  Theorem
      
      ⊢ ∀r r_ f1 f2.
          Ring r ∧ Ring r_ ∧ (∀x. x ∈ R ⇒ f1 x = f2 x) ⇒
          (RingIso f1 r r_ ⇔ RingIso f2 r r_)
   
   [<a name="ring_iso_element-val"><b>ring_iso_element</b></a>]  Theorem
      
      ⊢ ∀r r_ f. RingIso f r r_ ⇒ ∀x. x ∈ R ⇒ f x ∈ R_
   
   [<a name="ring_iso_element_unique-val"><b>ring_iso_element_unique</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r =r= r_) f ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ (f x = f y ⇔ x = y)
   
   [<a name="ring_iso_eq_one-val"><b>ring_iso_eq_one</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r =r= r_) f ⇒ ∀x. x ∈ R ⇒ (f x = #1_ ⇔ x = #1)
   
   [<a name="ring_iso_eq_zero-val"><b>ring_iso_eq_zero</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r =r= r_) f ⇒ ∀x. x ∈ R ⇒ (f x = #0_ ⇔ x = #0)
   
   [<a name="ring_iso_exp-val"><b>ring_iso_exp</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r =r= r_) f ⇒ ∀x. x ∈ R ⇒ ∀n. f (x ** n) = f x **_ n
   
   [<a name="ring_iso_ids-val"><b>ring_iso_ids</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r =r= r_) f ⇒ f #0 = #0_ ∧ f #1 = #1_
   
   [<a name="ring_iso_inv-val"><b>ring_iso_inv</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r =r= r_) f ⇒ ∀x. unit x ⇒ f ( |/ x) = |/_ (f x)
   
   [<a name="ring_iso_inverse-val"><b>ring_iso_inverse</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r =r= r_) f ⇒ ∀y. y ∈ R_ ⇒ ∃x. x ∈ R ∧ y = f x
   
   [<a name="ring_iso_inverse_element-val"><b>ring_iso_inverse_element</b></a>]  Theorem
      
      ⊢ ∀r r_ f.
          (r =r= r_) f ⇒ ∀y. y ∈ R_ ⇒ LINV f R y ∈ R ∧ y = f (LINV f R y)
   
   [<a name="ring_iso_linv_iso-val"><b>ring_iso_linv_iso</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r =r= r_) f ⇒ RingIso (LINV f R) r_ r
   
   [<a name="ring_iso_mult-val"><b>ring_iso_mult</b></a>]  Theorem
      
      ⊢ ∀r r_ f.
          (r =r= r_) f ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ f (x * y) = f x *_ f y
   
   [<a name="ring_iso_neg-val"><b>ring_iso_neg</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r =r= r_) f ⇒ ∀x. x ∈ R ⇒ f (-x) = $-_ (f x)
   
   [<a name="ring_iso_nonzero-val"><b>ring_iso_nonzero</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r =r= r_) f ⇒ ∀x. x ∈ R+ ⇒ f x ∈ R+_
   
   [<a name="ring_iso_num-val"><b>ring_iso_num</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r =r= r_) f ⇒ ∀n. f (##n) = ##_ #1_ n
   
   [<a name="ring_iso_one-val"><b>ring_iso_one</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r =r= r_) f ⇒ f #1 = #1_
   
   [<a name="ring_iso_property-val"><b>ring_iso_property</b></a>]  Theorem
      
      ⊢ ∀r r_ f.
          Ring r ∧ RingIso f r r_ ⇒
          ∀x y.
            x ∈ R ∧ y ∈ R ⇒ f (x + y) = f x +_ f y ∧ f (x * y) = f x *_ f y
   
   [<a name="ring_iso_ring_homo_subring-val"><b>ring_iso_ring_homo_subring</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r =r= r_) f ⇒ subring (ring_homo_image f r r_) r_
   
   [<a name="ring_iso_sub-val"><b>ring_iso_sub</b></a>]  Theorem
      
      ⊢ ∀r r_ f.
          (r =r= r_) f ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ f (x − y) = f x -_ f y
   
   [<a name="ring_iso_subring_iso-val"><b>ring_iso_subring_iso</b></a>]  Theorem
      
      ⊢ ∀r s r_ f. (r =r= r_) f ∧ s ≤ r ⇒ (s =r= ring_homo_image f s r_) f
   
   [<a name="ring_iso_sym-val"><b>ring_iso_sym</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r =r= r_) f ⇒ RingIso (LINV f R) r_ r
   
   [<a name="ring_iso_sym_any-val"><b>ring_iso_sym_any</b></a>]  Theorem
      
      ⊢ Ring r ∧ Ring s ∧ RingIso f r s ∧
        (∀x. x ∈ s.carrier ⇒ i x ∈ R ∧ f (i x) = x) ∧
        (∀x. x ∈ R ⇒ i (f x) = x) ⇒
        RingIso i s r
   
   [<a name="ring_iso_trans-val"><b>ring_iso_trans</b></a>]  Theorem
      
      ⊢ ∀r s t f1 f2.
          RingIso f1 r s ∧ RingIso f2 s t ⇒ RingIso (f2 ∘ f1) r t
   
   [<a name="ring_iso_unit-val"><b>ring_iso_unit</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r =r= r_) f ⇒ ∀x. unit x ⇒ unit_ (f x)
   
   [<a name="ring_iso_zero-val"><b>ring_iso_zero</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r =r= r_) f ⇒ f #0 = #0_
   
   [<a name="ring_list_SNOC-val"><b>ring_list_SNOC</b></a>]  Theorem
      
      ⊢ ∀x s. rlist (SNOC x s) ⇔ x ∈ R ∧ rlist s
   
   [<a name="ring_list_cons-val"><b>ring_list_cons</b></a>]  Theorem
      
      ⊢ ∀r h t. rlist (h::t) ⇔ h ∈ R ∧ rlist t
   
   [<a name="ring_list_from_genlist-val"><b>ring_list_from_genlist</b></a>]  Theorem
      
      ⊢ ∀r f. rfun f ⇒ ∀n. rlist (GENLIST f n)
   
   [<a name="ring_list_from_genlist_ring_fun-val"><b>ring_list_from_genlist_ring_fun</b></a>]  Theorem
      
      ⊢ ∀r f. rfun f ⇒ ∀n g. rlist (GENLIST (f ∘ g) n)
   
   [<a name="ring_list_front_last-val"><b>ring_list_front_last</b></a>]  Theorem
      
      ⊢ ∀s. rlist (FRONT s) ∧ LAST s ∈ R ⇒ rlist s
   
   [<a name="ring_list_gen_from_ring_fun-val"><b>ring_list_gen_from_ring_fun</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀f. rfun f ⇒
                ∀x. x ∈ R ⇒ ∀n. rlist (GENLIST (λj. f j * x ** j) n)
   
   [<a name="ring_list_nil-val"><b>ring_list_nil</b></a>]  Theorem
      
      ⊢ ∀r. rlist [] ⇔ T
   
   [<a name="ring_literal_11-val"><b>ring_literal_11</b></a>]  Theorem
      
      ⊢ ∀f1 m01 m1 f2 m02 m2.
          &lt;|carrier := f1; sum := m01; prod := m1|&gt; =
          &lt;|carrier := f2; sum := m02; prod := m2|&gt; ⇔
          f1 = f2 ∧ m01 = m02 ∧ m1 = m2
   
   [<a name="ring_literal_nchotomy-val"><b>ring_literal_nchotomy</b></a>]  Theorem
      
      ⊢ ∀r. ∃f m0 m. r = &lt;|carrier := f; sum := m0; prod := m|&gt;
   
   [<a name="ring_mult_abelian_monoid-val"><b>ring_mult_abelian_monoid</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ AbelianMonoid r.prod
   
   [<a name="ring_mult_add-val"><b>ring_mult_add</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀z y x.
              x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒
              x * (y + z) = x * y + x * z ∧ (y + z) * x = y * x + z * x
   
   [<a name="ring_mult_add_neg-val"><b>ring_mult_add_neg</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x. x ∈ R ⇒
                ∀n. ##n * x + -x = if n = 0 then -x else ##(n − 1) * x
   
   [<a name="ring_mult_add_neg_assoc-val"><b>ring_mult_add_neg_assoc</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y.
              x ∈ R ∧ y ∈ R ⇒
              ∀n. ##n * x + (-x + y) =
                  if n = 0 then -x + y else ##(n − 1) * x + y
   
   [<a name="ring_mult_add_neg_mult-val"><b>ring_mult_add_neg_mult</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x. x ∈ R ⇒
                ∀m n.
                  ##m * x + -(##n * x) =
                  if m &lt; n then -(##(n − m) * x) else ##(m − n) * x
   
   [<a name="ring_mult_add_neg_mult_assoc-val"><b>ring_mult_add_neg_mult_assoc</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y.
              x ∈ R ∧ y ∈ R ⇒
              ∀m n.
                ##m * x + (-(##n * x) + y) =
                if m &lt; n then -(##(n − m) * x) + y else ##(m − n) * x + y
   
   [<a name="ring_mult_assoc-val"><b>ring_mult_assoc</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ x * y * z = x * (y * z)
   
   [<a name="ring_mult_assoc_comm-val"><b>ring_mult_assoc_comm</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ x * (y * z) = y * (x * z)
   
   [<a name="ring_mult_comm-val"><b>ring_mult_comm</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ x * y = y * x
   
   [<a name="ring_mult_divides-val"><b>ring_mult_divides</b></a>]  Theorem
      
      ⊢ ∀r p q x.
          Ring r ∧ p * q rdivides x ∧ p ∈ R ∧ q ∈ R ⇒
          p rdivides x ∧ q rdivides x
   
   [<a name="ring_mult_element-val"><b>ring_mult_element</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ x * y ∈ R
   
   [<a name="ring_mult_exp-val"><b>ring_mult_exp</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y. x ∈ R ∧ y ∈ R ⇒ ∀n. (x * y) ** n = x ** n * y ** n
   
   [<a name="ring_mult_ladd-val"><b>ring_mult_ladd</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ (y + z) * x = y * x + z * x
   
   [<a name="ring_mult_lneg-val"><b>ring_mult_lneg</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ -x * y = -(x * y)
   
   [<a name="ring_mult_lone-val"><b>ring_mult_lone</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ #1 * x = x
   
   [<a name="ring_mult_lsub-val"><b>ring_mult_lsub</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ x * z − y * z = (x − y) * z
   
   [<a name="ring_mult_lzero-val"><b>ring_mult_lzero</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ #0 * x = #0
   
   [<a name="ring_mult_monoid-val"><b>ring_mult_monoid</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            Monoid r.prod ∧ r.prod.carrier = R ∧
            ∀x y. x ∈ R ∧ y ∈ R ⇒ x * y = y * x
   
   [<a name="ring_mult_monoid_rwt-val"><b>ring_mult_monoid_rwt</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ Monoid r.prod ∧ r.prod.carrier = R
   
   [<a name="ring_mult_neg_neg-val"><b>ring_mult_neg_neg</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ -x * -y = x * y
   
   [<a name="ring_mult_one_one-val"><b>ring_mult_one_one</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ #1 * #1 = #1
   
   [<a name="ring_mult_pair_diff-val"><b>ring_mult_pair_diff</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y p q.
              x ∈ R ∧ y ∈ R ∧ p ∈ R ∧ q ∈ R ⇒
              x * y − p * q = (x − p) * y + p * (y − q)
   
   [<a name="ring_mult_pair_sub-val"><b>ring_mult_pair_sub</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y p q.
              x ∈ R ∧ y ∈ R ∧ p ∈ R ∧ q ∈ R ⇒
              x * y − p * q = (x − p) * (y − q) + (x − p) * q + p * (y − q)
   
   [<a name="ring_mult_radd-val"><b>ring_mult_radd</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ x * (y + z) = x * y + x * z
   
   [<a name="ring_mult_rneg-val"><b>ring_mult_rneg</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ x * -y = -(x * y)
   
   [<a name="ring_mult_rone-val"><b>ring_mult_rone</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ x * #1 = x
   
   [<a name="ring_mult_rsub-val"><b>ring_mult_rsub</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ x * y − x * z = x * (y − z)
   
   [<a name="ring_mult_rzero-val"><b>ring_mult_rzero</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ x * #0 = #0
   
   [<a name="ring_mult_zero_zero-val"><b>ring_mult_zero_zero</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ #0 * #0 = #0
   
   [<a name="ring_nchotomy-val"><b>ring_nchotomy</b></a>]  Theorem
      
      ⊢ ∀rr. ∃f m m0. rr = ring f m m0
   
   [<a name="ring_neg_add-val"><b>ring_neg_add</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ -(x + y) = -x + -y
   
   [<a name="ring_neg_add_comm-val"><b>ring_neg_add_comm</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ -(x + y) = -y + -x
   
   [<a name="ring_neg_add_neg-val"><b>ring_neg_add_neg</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ -x + -x = -(##2 * x)
   
   [<a name="ring_neg_add_neg_assoc-val"><b>ring_neg_add_neg_assoc</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ -x + (-x + y) = -(##2 * x) + y
   
   [<a name="ring_neg_add_neg_mult-val"><b>ring_neg_add_neg_mult</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀n. -x + -(##n * x) = -(##(n + 1) * x)
   
   [<a name="ring_neg_add_neg_mult_assoc-val"><b>ring_neg_add_neg_mult_assoc</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y.
              x ∈ R ∧ y ∈ R ⇒
              ∀n. -x + (-(##n * x) + y) = -(##(n + 1) * x) + y
   
   [<a name="ring_neg_char_2-val"><b>ring_neg_char_2</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ∧ char r = 2 ⇒ ∀x. x ∈ R ⇒ -x = x
   
   [<a name="ring_neg_element-val"><b>ring_neg_element</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ -x ∈ R
   
   [<a name="ring_neg_eq-val"><b>ring_neg_eq</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ (-x = -y ⇔ x = y)
   
   [<a name="ring_neg_eq_swap-val"><b>ring_neg_eq_swap</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ (-x = y ⇔ x = -y)
   
   [<a name="ring_neg_eq_zero-val"><b>ring_neg_eq_zero</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ (-x = #0 ⇔ x = #0)
   
   [<a name="ring_neg_exp-val"><b>ring_neg_exp</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x. x ∈ R ⇒ ∀n. -x ** n = if EVEN n then x ** n else -(x ** n)
   
   [<a name="ring_neg_mult-val"><b>ring_neg_mult</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y. x ∈ R ∧ y ∈ R ⇒ -(x * y) = -x * y ∧ -(x * y) = x * -y
   
   [<a name="ring_neg_mult_add_neg_mult-val"><b>ring_neg_mult_add_neg_mult</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x. x ∈ R ⇒ ∀m n. -(##m * x) + -(##n * x) = -(##(m + n) * x)
   
   [<a name="ring_neg_mult_add_neg_mult_assoc-val"><b>ring_neg_mult_add_neg_mult_assoc</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y.
              x ∈ R ∧ y ∈ R ⇒
              ∀m n. -(##m * x) + (-(##n * x) + y) = -(##(m + n) * x) + y
   
   [<a name="ring_neg_neg-val"><b>ring_neg_neg</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ --x = x
   
   [<a name="ring_neg_nonzero-val"><b>ring_neg_nonzero</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R+ ⇒ -x ∈ R+
   
   [<a name="ring_neg_one_eq_one-val"><b>ring_neg_one_eq_one</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ∧ #1 ≠ #0 ⇒ (-#1 = #1 ⇔ char r = 2)
   
   [<a name="ring_neg_square-val"><b>ring_neg_square</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ -x ** 2 = x ** 2
   
   [<a name="ring_neg_sub-val"><b>ring_neg_sub</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ -(x − y) = y − x
   
   [<a name="ring_neg_zero-val"><b>ring_neg_zero</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ -#0 = #0
   
   [<a name="ring_nonzero_element-val"><b>ring_nonzero_element</b></a>]  Theorem
      
      ⊢ ∀r x. x ∈ R+ ⇒ x ∈ R
   
   [<a name="ring_nonzero_eq-val"><b>ring_nonzero_eq</b></a>]  Theorem
      
      ⊢ ∀r x. x ∈ R+ ⇔ x ∈ R ∧ x ≠ #0
   
   [<a name="ring_nonzero_mult_carrier-val"><b>ring_nonzero_mult_carrier</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ F* = R+
   
   [<a name="ring_num_0-val"><b>ring_num_0</b></a>]  Theorem
      
      ⊢ ∀r. ##0 = #0
   
   [<a name="ring_num_1-val"><b>ring_num_1</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ##1 = #1
   
   [<a name="ring_num_2-val"><b>ring_num_2</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ##2 = #1 + #1
   
   [<a name="ring_num_SUC-val"><b>ring_num_SUC</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀n. ##(SUC n) = #1 + ##n
   
   [<a name="ring_num_add-val"><b>ring_num_add</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀n k. ##(n + k) = ##n + ##k
   
   [<a name="ring_num_add_assoc-val"><b>ring_num_add_assoc</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀m n. ##m + (##n + x) = ##(m + n) + x
   
   [<a name="ring_num_add_mult-val"><b>ring_num_add_mult</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀m n. ##(m + n) * x = ##m * x + ##n * x
   
   [<a name="ring_num_add_mult_assoc-val"><b>ring_num_add_mult_assoc</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y.
              x ∈ R ∧ y ∈ R ⇒
              ∀m n. ##(m + n) * x + y = ##m * x + (##n * x + y)
   
   [<a name="ring_num_all_zero-val"><b>ring_num_all_zero</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ #1 = #0 ⇒ ∀c. ##c = #0
   
   [<a name="ring_num_char_coprime_nonzero-val"><b>ring_num_char_coprime_nonzero</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ∧ #1 ≠ #0 ⇒ ∀c. coprime c (char r) ⇒ ##c ≠ #0
   
   [<a name="ring_num_element-val"><b>ring_num_element</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀n. ##n ∈ R
   
   [<a name="ring_num_eq-val"><b>ring_num_eq</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀n m. n &lt; char r ∧ m &lt; char r ⇒ (##n = ##m ⇔ n = m)
   
   [<a name="ring_num_exp-val"><b>ring_num_exp</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀m n. ##m ** n = ##(m ** n)
   
   [<a name="ring_num_mod-val"><b>ring_num_mod</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ∧ 0 &lt; char r ⇒ ∀n. ##n = ##(n MOD char r)
   
   [<a name="ring_num_mult-val"><b>ring_num_mult</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀m n. ##m * ##n = ##(m * n)
   
   [<a name="ring_num_mult_assoc-val"><b>ring_num_mult_assoc</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀m n x. x ∈ R ⇒ ##m * (##n * x) = ##(m * n) * x
   
   [<a name="ring_num_mult_element-val"><b>ring_num_mult_element</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀n. ##n * x ∈ R
   
   [<a name="ring_num_mult_exp-val"><b>ring_num_mult_exp</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀k m n. ##k * ##m ** n = ##(k * m ** n)
   
   [<a name="ring_num_mult_neg-val"><b>ring_num_mult_neg</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀n. -(##n * x) = ##n * -x
   
   [<a name="ring_num_mult_radd-val"><b>ring_num_mult_radd</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y. x ∈ R ∧ y ∈ R ⇒ ∀n. ##n * (x + y) = ##n * x + ##n * y
   
   [<a name="ring_num_mult_small-val"><b>ring_num_mult_small</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x. x ∈ R ⇒
                #0 * x = #0 ∧ #1 * x = x ∧ ##2 * x = x + x ∧
                ##3 * x = ##2 * x + x
   
   [<a name="ring_num_mult_suc-val"><b>ring_num_mult_suc</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀n. ##(SUC n) * x = ##n * x + x
   
   [<a name="ring_num_negative-val"><b>ring_num_negative</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ∧ 0 &lt; char r ⇒ ∀z. ∃y x. y = ##x ∧ y + ##z = #0
   
   [<a name="ring_num_one-val"><b>ring_num_one</b></a>]  Theorem
      
      ⊢ ∀r. ##1 = #1 + #0
   
   [<a name="ring_num_sub-val"><b>ring_num_sub</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀n m. m &lt; n ⇒ ##(n − m) = ##n − ##m
   
   [<a name="ring_num_suc-val"><b>ring_num_suc</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀n. ##(SUC n) = ##n + #1
   
   [<a name="ring_one_element-val"><b>ring_one_element</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ #1 ∈ R
   
   [<a name="ring_one_eq_zero-val"><b>ring_one_eq_zero</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ (#1 = #0 ⇔ R = {#0})
   
   [<a name="ring_one_exp-val"><b>ring_one_exp</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀n. #1 ** n = #1
   
   [<a name="ring_one_unique-val"><b>ring_one_unique</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀y. y ∈ R ⇒ ((∀x. x ∈ R ⇒ y * x = x ∨ x * y = x) ⇔ y = #1)
   
   [<a name="ring_prime_divides_product-val"><b>ring_prime_divides_product</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀p. p ∈ R ⇒
                (rprime p ∧ p ∉ R* ⇔
                 ∀b. FINITE_BAG b ∧ SET_OF_BAG b ⊆ R ∧
                     p rdivides GBAG r.prod b ⇒
                     ∃x. x ⋲ b ∧ p rdivides x)
   
   [<a name="ring_prime_iso-val"><b>ring_prime_iso</b></a>]  Theorem
      
      ⊢ ∀r r_ f. (r =r= r_) f ⇒ ∀p. p ∈ R ∧ rprime p ⇒ ring_prime r_ (f p)
   
   [<a name="ring_product_factors_divide-val"><b>ring_product_factors_divide</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀b. FINITE_BAG b ⇒
                SET_OF_BAG b ⊆ R ∧ GBAG r.prod b rdivides x ⇒
                ∀y. y ⋲ b ⇒ y rdivides x
   
   [<a name="ring_single_add_mult-val"><b>ring_single_add_mult</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀n. x + ##n * x = ##(n + 1) * x
   
   [<a name="ring_single_add_mult_assoc-val"><b>ring_single_add_mult_assoc</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y. x ∈ R ∧ y ∈ R ⇒ ∀n. x + (##n * x + y) = ##(n + 1) * x + y
   
   [<a name="ring_single_add_neg_mult-val"><b>ring_single_add_neg_mult</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x. x ∈ R ⇒
                ∀n. x + -(##n * x) = if n = 0 then x else -(##(n − 1) * x)
   
   [<a name="ring_single_add_neg_mult_assoc-val"><b>ring_single_add_neg_mult_assoc</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y.
              x ∈ R ∧ y ∈ R ⇒
              ∀n. x + (-(##n * x) + y) =
                  if n = 0 then x + y else -(##(n − 1) * x) + y
   
   [<a name="ring_single_add_single-val"><b>ring_single_add_single</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ x + x = ##2 * x
   
   [<a name="ring_single_add_single_assoc-val"><b>ring_single_add_single_assoc</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ x + (x + y) = ##2 * x + y
   
   [<a name="ring_single_mult_exp-val"><b>ring_single_mult_exp</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀n. x * x ** n = x ** (n + 1)
   
   [<a name="ring_single_mult_exp_assoc-val"><b>ring_single_mult_exp_assoc</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y. x ∈ R ∧ y ∈ R ⇒ ∀n. x * (x ** n * y) = x ** (n + 1) * y
   
   [<a name="ring_single_mult_single-val"><b>ring_single_mult_single</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ x * x = x ** 2
   
   [<a name="ring_single_mult_single_assoc-val"><b>ring_single_mult_single_assoc</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ x * (x * y) = x ** 2 * y
   
   [<a name="ring_sub_add-val"><b>ring_sub_add</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ x − y + y = x
   
   [<a name="ring_sub_element-val"><b>ring_sub_element</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ x − y ∈ R
   
   [<a name="ring_sub_eq-val"><b>ring_sub_eq</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ⇒ x − x = #0
   
   [<a name="ring_sub_eq_add-val"><b>ring_sub_eq_add</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ (x − y = z ⇔ x = y + z)
   
   [<a name="ring_sub_eq_zero-val"><b>ring_sub_eq_zero</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ (x − y = #0 ⇔ x = y)
   
   [<a name="ring_sub_lcancel-val"><b>ring_sub_lcancel</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ (x − y = x − z ⇔ y = z)
   
   [<a name="ring_sub_pair_reduce-val"><b>ring_sub_pair_reduce</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ x + z − (y + z) = x − y
   
   [<a name="ring_sub_rcancel-val"><b>ring_sub_rcancel</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ (y − x = z − x ⇔ y = z)
   
   [<a name="ring_sub_zero-val"><b>ring_sub_zero</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ x − #0 = x
   
   [<a name="ring_sum_SNOC-val"><b>ring_sum_SNOC</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀k s. k ∈ R ∧ rlist s ⇒ rsum (SNOC k s) = rsum s + k
   
   [<a name="ring_sum_append-val"><b>ring_sum_append</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀s t. rlist s ∧ rlist t ⇒ rsum (s ⧺ t) = rsum s + rsum t
   
   [<a name="ring_sum_cons-val"><b>ring_sum_cons</b></a>]  Theorem
      
      ⊢ ∀r h t. rsum (h::t) = h + rsum t
   
   [<a name="ring_sum_decompose_first-val"><b>ring_sum_decompose_first</b></a>]  Theorem
      
      ⊢ ∀r f n. rsum (GENLIST f (SUC n)) = f 0 + rsum (GENLIST (f ∘ SUC) n)
   
   [<a name="ring_sum_decompose_first_last-val"><b>ring_sum_decompose_first_last</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀f n.
              rfun f ∧ 0 &lt; n ⇒
              rsum (GENLIST f (SUC n)) =
              f 0 + rsum (GENLIST (f ∘ SUC) (PRE n)) + f n
   
   [<a name="ring_sum_decompose_last-val"><b>ring_sum_decompose_last</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀f n.
              rfun f ⇒ rsum (GENLIST f (SUC n)) = rsum (GENLIST f n) + f n
   
   [<a name="ring_sum_element-val"><b>ring_sum_element</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀s. rlist s ⇒ rsum s ∈ R
   
   [<a name="ring_sum_freshman_all-val"><b>ring_sum_freshman_all</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ∧ prime (char r) ⇒
            ∀f. rfun f ⇒
                ∀x. x ∈ R ⇒
                    ∀n k.
                      rsum (GENLIST (λj. f j * x ** j) n) ** char r ** k =
                      rsum (GENLIST (λj. (f j * x ** j) ** char r ** k) n)
   
   [<a name="ring_sum_freshman_thm-val"><b>ring_sum_freshman_thm</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ∧ prime (char r) ⇒
            ∀f. rfun f ⇒
                ∀x. x ∈ R ⇒
                    ∀n. rsum (GENLIST (λj. f j * x ** j) n) ** char r =
                        rsum (GENLIST (λj. (f j * x ** j) ** char r) n)
   
   [<a name="ring_sum_fun_zero-val"><b>ring_sum_fun_zero</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀f. rfun f ⇒
                ∀n. (∀k. 0 &lt; k ∧ k &lt; n ⇒ f k = #0) ⇒
                    rsum (MAP f (GENLIST SUC (PRE n))) = #0
   
   [<a name="ring_sum_genlist_add-val"><b>ring_sum_genlist_add</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀a b.
              rfun a ∧ rfun b ⇒
              ∀n. rsum (GENLIST a n) + rsum (GENLIST b n) =
                  rsum (GENLIST (λk. a k + b k) n)
   
   [<a name="ring_sum_genlist_append-val"><b>ring_sum_genlist_append</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀a b.
              rfun a ∧ rfun b ⇒
              ∀n. rsum (GENLIST a n ⧺ GENLIST b n) =
                  rsum (GENLIST (λk. a k + b k) n)
   
   [<a name="ring_sum_genlist_const-val"><b>ring_sum_genlist_const</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀n. rsum (GENLIST (K x) n) = ##n * x
   
   [<a name="ring_sum_genlist_sum-val"><b>ring_sum_genlist_sum</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀f. rfun f ⇒
                ∀n m.
                  rsum (GENLIST f (n + m)) =
                  rsum (GENLIST f m) + rsum (GENLIST (λk. f (k + m)) n)
   
   [<a name="ring_sum_mult-val"><b>ring_sum_mult</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀k s. k ∈ R ∧ rlist s ⇒ k * rsum s = rsum (MAP (λx. k * x) s)
   
   [<a name="ring_sum_mult_ladd-val"><b>ring_sum_mult_ladd</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀m n s.
              m ∈ R ∧ n ∈ R ∧ rlist s ⇒
              (m + n) * rsum s =
              rsum (MAP (λx. m * x) s) + rsum (MAP (λx. n * x) s)
   
   [<a name="ring_sum_nil-val"><b>ring_sum_nil</b></a>]  Theorem
      
      ⊢ ∀r. rsum [] = #0
   
   [<a name="ring_sum_sing-val"><b>ring_sum_sing</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ rsum [x] = x
   
   [<a name="ring_sum_zero-val"><b>ring_sum_zero</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀n. r.sum.exp #0 n = #0
   
   [<a name="ring_unit_element-val"><b>ring_unit_element</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. unit x ⇒ x ∈ R
   
   [<a name="ring_unit_has_inv-val"><b>ring_unit_has_inv</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. unit x ⇒ unit ( |/ x)
   
   [<a name="ring_unit_inv_element-val"><b>ring_unit_inv_element</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. unit x ⇒ |/ x ∈ R
   
   [<a name="ring_unit_inv_inv-val"><b>ring_unit_inv_inv</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀u. unit u ⇒ u = |/ ( |/ u)
   
   [<a name="ring_unit_inv_nonzero-val"><b>ring_unit_inv_nonzero</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ∧ #1 ≠ #0 ⇒ ∀x. unit x ⇒ |/ x ≠ #0
   
   [<a name="ring_unit_linv-val"><b>ring_unit_linv</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. unit x ⇒ |/ x * x = #1
   
   [<a name="ring_unit_linv_inv-val"><b>ring_unit_linv_inv</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀u v. unit u ∧ v ∈ R ∧ |/ u * v = #1 ⇒ u = v
   
   [<a name="ring_unit_linv_unique-val"><b>ring_unit_linv_unique</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀u v. u ∈ R ∧ unit v ∧ u * v = #1 ⇒ u = |/ v
   
   [<a name="ring_unit_mult_eq_unit-val"><b>ring_unit_mult_eq_unit</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ (unit (x * y) ⇔ unit x ∧ unit y)
   
   [<a name="ring_unit_mult_unit-val"><b>ring_unit_mult_unit</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀u v. unit u ∧ unit v ⇒ unit (u * v)
   
   [<a name="ring_unit_mult_zero-val"><b>ring_unit_mult_zero</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x y. unit x ∧ y ∈ R ⇒ (x * y = #0 ⇔ y = #0)
   
   [<a name="ring_unit_neg-val"><b>ring_unit_neg</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. unit x ⇒ unit (-x)
   
   [<a name="ring_unit_nonzero-val"><b>ring_unit_nonzero</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ∧ #1 ≠ #0 ⇒ ∀x. unit x ⇒ x ≠ #0
   
   [<a name="ring_unit_one-val"><b>ring_unit_one</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ unit #1
   
   [<a name="ring_unit_property-val"><b>ring_unit_property</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀u. unit u ⇔ u ∈ R ∧ ∃v. v ∈ R ∧ u * v = #1
   
   [<a name="ring_unit_rinv-val"><b>ring_unit_rinv</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. unit x ⇒ x * |/ x = #1
   
   [<a name="ring_unit_rinv_inv-val"><b>ring_unit_rinv_inv</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀u v. u ∈ R ∧ unit v ∧ u * |/ v = #1 ⇒ u = v
   
   [<a name="ring_unit_rinv_unique-val"><b>ring_unit_rinv_unique</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀u v. unit u ∧ v ∈ R ∧ u * v = #1 ⇒ v = |/ u
   
   [<a name="ring_unit_zero-val"><b>ring_unit_zero</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ (unit #0 ⇔ #1 = #0)
   
   [<a name="ring_units_abelain_group-val"><b>ring_units_abelain_group</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ AbelianGroup r*
   
   [<a name="ring_units_element-val"><b>ring_units_element</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. unit x ⇒ x ∈ R
   
   [<a name="ring_units_group-val"><b>ring_units_group</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ Group r*
   
   [<a name="ring_units_has_one-val"><b>ring_units_has_one</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ unit #1
   
   [<a name="ring_units_has_zero-val"><b>ring_units_has_zero</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ (unit #0 ⇔ #1 = #0)
   
   [<a name="ring_units_property-val"><b>ring_units_property</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ r*.op = $* ∧ r*.id = #1
   
   [<a name="ring_updates_eq_literal-val"><b>ring_updates_eq_literal</b></a>]  Theorem
      
      ⊢ ∀r f m0 m.
          r with &lt;|carrier := f; sum := m0; prod := m|&gt; =
          &lt;|carrier := f; sum := m0; prod := m|&gt;
   
   [<a name="ring_zero_divides-val"><b>ring_zero_divides</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ (#0 rdivides x ⇔ x = #0)
   
   [<a name="ring_zero_element-val"><b>ring_zero_element</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ #0 ∈ R
   
   [<a name="ring_zero_exp-val"><b>ring_zero_exp</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀n. #0 ** n = if n = 0 then #1 else #0
   
   [<a name="ring_zero_fix-val"><b>ring_zero_fix</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ (x + x = x ⇔ x = #0)
   
   [<a name="ring_zero_sub-val"><b>ring_zero_sub</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ #0 − x = -x
   
   [<a name="ring_zero_unique-val"><b>ring_zero_unique</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y.
              x ∈ R ∧ y ∈ R ⇒ (y + x = x ⇔ y = #0) ∧ (x + y = x ⇔ y = #0)
   
   [<a name="subring_I_antisym-val"><b>subring_I_antisym</b></a>]  Theorem
      
      ⊢ ∀r s. subring s r ∧ subring r s ⇒ RingIso I s r
   
   [<a name="subring_add-val"><b>subring_add</b></a>]  Theorem
      
      ⊢ ∀r s. s ≤ r ⇒ ∀x y. x ∈ B ∧ y ∈ B ⇒ s.sum.op x y = x + y
   
   [<a name="subring_by_subgroup_submonoid-val"><b>subring_by_subgroup_submonoid</b></a>]  Theorem
      
      ⊢ ∀r s.
          s ≤ r ⇔
          Ring r ∧ Ring s ∧ subgroup s.sum r.sum ∧ submonoid s.prod r.prod
   
   [<a name="subring_carrier_antisym-val"><b>subring_carrier_antisym</b></a>]  Theorem
      
      ⊢ ∀r s. subring s r ∧ R ⊆ B ⇒ RingIso I s r
   
   [<a name="subring_carrier_finite-val"><b>subring_carrier_finite</b></a>]  Theorem
      
      ⊢ ∀r s. FiniteRing r ∧ subring s r ⇒ FINITE B
   
   [<a name="subring_carrier_subset-val"><b>subring_carrier_subset</b></a>]  Theorem
      
      ⊢ ∀r s. subring s r ⇒ B ⊆ R
   
   [<a name="subring_char-val"><b>subring_char</b></a>]  Theorem
      
      ⊢ ∀r s. s ≤ r ⇒ char s = char r
   
   [<a name="subring_char_divides-val"><b>subring_char_divides</b></a>]  Theorem
      
      ⊢ ∀r s. s ≤ r ⇒ char r divides char s
   
   [<a name="subring_element-val"><b>subring_element</b></a>]  Theorem
      
      ⊢ ∀r s. subring s r ⇒ ∀x. x ∈ B ⇒ x ∈ R
   
   [<a name="subring_element_alt-val"><b>subring_element_alt</b></a>]  Theorem
      
      ⊢ ∀r s. s ≤ r ⇒ ∀x. x ∈ B ⇒ x ∈ R
   
   [<a name="subring_exp-val"><b>subring_exp</b></a>]  Theorem
      
      ⊢ ∀r s. s ≤ r ⇒ ∀x. x ∈ B ⇒ ∀n. s.prod.exp x n = x ** n
   
   [<a name="subring_finite_ring-val"><b>subring_finite_ring</b></a>]  Theorem
      
      ⊢ ∀r s. FiniteRing r ∧ s ≤ r ⇒ FiniteRing s
   
   [<a name="subring_homo_homo-val"><b>subring_homo_homo</b></a>]  Theorem
      
      ⊢ ∀r s r_ f. subring s r ∧ RingHomo f r r_ ⇒ RingHomo f s r_
   
   [<a name="subring_ids-val"><b>subring_ids</b></a>]  Theorem
      
      ⊢ ∀r s. s ≤ r ⇒ s.sum.id = #0 ∧ s.prod.id = #1
   
   [<a name="subring_mult-val"><b>subring_mult</b></a>]  Theorem
      
      ⊢ ∀r s. s ≤ r ⇒ ∀x y. x ∈ B ∧ y ∈ B ⇒ s.prod.op x y = x * y
   
   [<a name="subring_neg-val"><b>subring_neg</b></a>]  Theorem
      
      ⊢ ∀r s. s ≤ r ⇒ ∀x. x ∈ B ⇒ s.sum.inv x = -x
   
   [<a name="subring_num-val"><b>subring_num</b></a>]  Theorem
      
      ⊢ ∀r s. s ≤ r ⇒ ∀n. s.sum.exp s.prod.id n = ##n
   
   [<a name="subring_one-val"><b>subring_one</b></a>]  Theorem
      
      ⊢ ∀r s. s ≤ r ⇒ s.prod.id = #1
   
   [<a name="subring_prod_submonoid-val"><b>subring_prod_submonoid</b></a>]  Theorem
      
      ⊢ ∀r s. subring s r ⇒ submonoid s.prod r.prod
   
   [<a name="subring_property-val"><b>subring_property</b></a>]  Theorem
      
      ⊢ ∀r s.
          Ring s ∧ subring s r ⇒
          ∀x y.
            x ∈ B ∧ y ∈ B ⇒ s.sum.op x y = x + y ∧ s.prod.op x y = x * y
   
   [<a name="subring_refl-val"><b>subring_refl</b></a>]  Theorem
      
      ⊢ ∀r. subring r r
   
   [<a name="subring_ring_iso_compose-val"><b>subring_ring_iso_compose</b></a>]  Theorem
      
      ⊢ ∀r s r_ f. subring s r ∧ RingIso f r r_ ⇒ RingHomo f s r_
   
   [<a name="subring_ring_iso_ring_homo_subring-val"><b>subring_ring_iso_ring_homo_subring</b></a>]  Theorem
      
      ⊢ ∀r s r_ f. s ≤ r ∧ (r =r= r_) f ⇒ ring_homo_image f s r_ ≤ r_
   
   [<a name="subring_sub-val"><b>subring_sub</b></a>]  Theorem
      
      ⊢ ∀r s. s ≤ r ⇒ ∀x y. x ∈ B ∧ y ∈ B ⇒ ring_sub s x y = x − y
   
   [<a name="subring_sum_subgroup-val"><b>subring_sum_subgroup</b></a>]  Theorem
      
      ⊢ ∀r s. subring s r ⇒ subgroup s.sum r.sum
   
   [<a name="subring_trans-val"><b>subring_trans</b></a>]  Theorem
      
      ⊢ ∀r s t. subring r s ∧ subring s t ⇒ subring r t
   
   [<a name="subring_unit-val"><b>subring_unit</b></a>]  Theorem
      
      ⊢ ∀r s. s ≤ r ⇒ ∀x. Unit s x ⇒ unit x
   
   [<a name="subring_unit_inv-val"><b>subring_unit_inv</b></a>]  Theorem
      
      ⊢ ∀r s. s ≤ r ⇒ ∀x. Unit s x ⇒ Inv s x = |/ x
   
   [<a name="subring_unit_inv_element-val"><b>subring_unit_inv_element</b></a>]  Theorem
      
      ⊢ ∀r s. s ≤ r ⇒ ∀x. Unit s x ⇒ Inv s x ∈ B
   
   [<a name="subring_unit_inv_nonzero-val"><b>subring_unit_inv_nonzero</b></a>]  Theorem
      
      ⊢ ∀r s. s ≤ r ∧ #1 ≠ #0 ⇒ ∀x. Unit s x ⇒ Inv s x ≠ #0
   
   [<a name="subring_unit_nonzero-val"><b>subring_unit_nonzero</b></a>]  Theorem
      
      ⊢ ∀r s. s ≤ r ∧ #1 ≠ #0 ⇒ ∀x. Unit s x ⇒ x ≠ #0
   
   [<a name="subring_zero-val"><b>subring_zero</b></a>]  Theorem
      
      ⊢ ∀r s. s ≤ r ⇒ s.sum.id = #0
   
   [<a name="symdiff_eval-val"><b>symdiff_eval</b></a>]  Theorem
      
      ⊢ symdiff_set.carrier = 𝕌(:α -&gt; bool) ∧
        (∀x y. symdiff_set.op x y = x ∪ y DIFF x ∩ y) ∧ symdiff_set.id = ∅
   
   [<a name="symdiff_set_inter_char-val"><b>symdiff_set_inter_char</b></a>]  Theorem
      
      ⊢ char symdiff_set_inter = 2
   
   [<a name="symdiff_set_inter_ring-val"><b>symdiff_set_inter_ring</b></a>]  Theorem
      
      ⊢ Ring symdiff_set_inter
   
   [<a name="symdiff_univ_univ_eq_empty-val"><b>symdiff_univ_univ_eq_empty</b></a>]  Theorem
      
      ⊢ symdiff 𝕌(:α) 𝕌(:α) = ∅
   
   [<a name="trivial_char-val"><b>trivial_char</b></a>]  Theorem
      
      ⊢ ∀z. char (trivial_ring z) = 1
   
   [<a name="trivial_integral_domain-val"><b>trivial_integral_domain</b></a>]  Theorem
      
      ⊢ ∀e0 e1.
          e0 ≠ e1 ⇒ FiniteIntegralDomain (trivial_integal_domain e0 e1)
   
   [<a name="trivial_ring-val"><b>trivial_ring</b></a>]  Theorem
      
      ⊢ ∀z. FiniteRing (trivial_ring z)
   
   [<a name="trivial_ring_thm-val"><b>trivial_ring_thm</b></a>]  Theorem
      
      ⊢ ∀z. Ring (trivial_ring z)
   
   [<a name="unit_eq_refl-val"><b>unit_eq_refl</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ x =~ x
   
   [<a name="unit_eq_sym-val"><b>unit_eq_sym</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ∧ x =~ y ⇒ y =~ x
   
   [<a name="unit_eq_trans-val"><b>unit_eq_trans</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒
            ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ∧ x =~ y ∧ y =~ z ⇒ x =~ z
   
   [<a name="zero_ideal_ideal-val"><b>zero_ideal_ideal</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ &lt;#0&gt; &lt;&lt; r
   
   [<a name="zero_ideal_sing-val"><b>zero_ideal_sing</b></a>]  Theorem
      
      ⊢ ∀r. Ring r ⇒ &lt;#0&gt;.carrier = {#0}
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/algebra/construction/.hol/objs/ringScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-2</a></em></p></body></html>
