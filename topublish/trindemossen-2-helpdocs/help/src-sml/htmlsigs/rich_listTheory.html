<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure rich_listTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure rich_listTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/list/src/rich_listScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature rich_listTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#AND_EL_DEF-val">AND_EL_DEF</a> : thm
<a name="line7"></a>    val <a href="#BUTLASTN_def-val">BUTLASTN_def</a> : thm
<a name="line8"></a>    val <a href="#COUNT_LIST_AUX_def-val">COUNT_LIST_AUX_def</a> : thm
<a name="line9"></a>    val <a href="#COUNT_LIST_def-val">COUNT_LIST_def</a> : thm
<a name="line10"></a>    val <a href="#DELETE_ELEMENT-val">DELETE_ELEMENT</a> : thm
<a name="line11"></a>    val <a href="#ELL-val">ELL</a> : thm
<a name="line12"></a>    val <a href="#IS_SUBLIST-val">IS_SUBLIST</a> : thm
<a name="line13"></a>    val <a href="#IS_SUFFIX-val">IS_SUFFIX</a> : thm
<a name="line14"></a>    val <a href="#LASTN_def-val">LASTN_def</a> : thm
<a name="line15"></a>    val <a href="#LIST_ELEM_COUNT_DEF-val">LIST_ELEM_COUNT_DEF</a> : thm
<a name="line16"></a>    val <a href="#MAX_LIST_def-val">MAX_LIST_def</a> : thm
<a name="line17"></a>    val <a href="#MIN_LIST_def-val">MIN_LIST_def</a> : thm
<a name="line18"></a>    val <a href="#OR_EL_DEF-val">OR_EL_DEF</a> : thm
<a name="line19"></a>    val <a href="#PREFIX_DEF-val">PREFIX_DEF</a> : thm
<a name="line20"></a>    val <a href="#REPLICATE-val">REPLICATE</a> : thm
<a name="line21"></a>    val <a href="#SCANL-val">SCANL</a> : thm
<a name="line22"></a>    val <a href="#SCANR-val">SCANR</a> : thm
<a name="line23"></a>    val <a href="#SEG-val">SEG</a> : thm
<a name="line24"></a>    val <a href="#SPLITL_def-val">SPLITL_def</a> : thm
<a name="line25"></a>    val <a href="#SPLITP-val">SPLITP</a> : thm
<a name="line26"></a>    val <a href="#SPLITP_AUX_def-val">SPLITP_AUX_def</a> : thm
<a name="line27"></a>    val <a href="#SPLITR_def-val">SPLITR_def</a> : thm
<a name="line28"></a>    val <a href="#SUFFIX_DEF-val">SUFFIX_DEF</a> : thm
<a name="line29"></a>    val <a href="#TL_T_def-val">TL_T_def</a> : thm
<a name="line30"></a>    val <a href="#UNZIP_FST_DEF-val">UNZIP_FST_DEF</a> : thm
<a name="line31"></a>    val <a href="#UNZIP_SND_DEF-val">UNZIP_SND_DEF</a> : thm
<a name="line32"></a>    val <a href="#chunks_tr_def-val">chunks_tr_def</a> : thm
<a name="line33"></a>    val <a href="#common_prefixes_def-val">common_prefixes_def</a> : thm
<a name="line34"></a>    val <a href="#longest_prefix_def-val">longest_prefix_def</a> : thm
<a name="line35"></a>  
<a name="line36"></a>  (*  Theorems  *)
<a name="line37"></a>    val <a href="#ALL_DISTINCT_APPEND_3-val">ALL_DISTINCT_APPEND_3</a> : thm
<a name="line38"></a>    val <a href="#ALL_DISTINCT_EL_APPEND-val">ALL_DISTINCT_EL_APPEND</a> : thm
<a name="line39"></a>    val <a href="#ALL_DISTINCT_FRONT-val">ALL_DISTINCT_FRONT</a> : thm
<a name="line40"></a>    val <a href="#ALL_DISTINCT_LAST_EL_IFF-val">ALL_DISTINCT_LAST_EL_IFF</a> : thm
<a name="line41"></a>    val <a href="#ALL_DISTINCT_MEM_ZIP_MAP-val">ALL_DISTINCT_MEM_ZIP_MAP</a> : thm
<a name="line42"></a>    val <a href="#ALL_DISTINCT_SNOC-val">ALL_DISTINCT_SNOC</a> : thm
<a name="line43"></a>    val <a href="#ALL_DISTINCT_SWAP-val">ALL_DISTINCT_SWAP</a> : thm
<a name="line44"></a>    val <a href="#ALL_DISTINCT_TAKE-val">ALL_DISTINCT_TAKE</a> : thm
<a name="line45"></a>    val <a href="#ALL_DISTINCT_TAKE_DROP-val">ALL_DISTINCT_TAKE_DROP</a> : thm
<a name="line46"></a>    val <a href="#ALL_EL-val">ALL_EL</a> : thm
<a name="line47"></a>    val <a href="#ALL_EL_APPEND-val">ALL_EL_APPEND</a> : thm
<a name="line48"></a>    val <a href="#ALL_EL_BUTFIRSTN-val">ALL_EL_BUTFIRSTN</a> : thm
<a name="line49"></a>    val <a href="#ALL_EL_BUTLASTN-val">ALL_EL_BUTLASTN</a> : thm
<a name="line50"></a>    val <a href="#ALL_EL_CONJ-val">ALL_EL_CONJ</a> : thm
<a name="line51"></a>    val <a href="#ALL_EL_FIRSTN-val">ALL_EL_FIRSTN</a> : thm
<a name="line52"></a>    val <a href="#ALL_EL_FOLDL-val">ALL_EL_FOLDL</a> : thm
<a name="line53"></a>    val <a href="#ALL_EL_FOLDL_MAP-val">ALL_EL_FOLDL_MAP</a> : thm
<a name="line54"></a>    val <a href="#ALL_EL_FOLDR-val">ALL_EL_FOLDR</a> : thm
<a name="line55"></a>    val <a href="#ALL_EL_FOLDR_MAP-val">ALL_EL_FOLDR_MAP</a> : thm
<a name="line56"></a>    val <a href="#ALL_EL_LASTN-val">ALL_EL_LASTN</a> : thm
<a name="line57"></a>    val <a href="#ALL_EL_MAP-val">ALL_EL_MAP</a> : thm
<a name="line58"></a>    val <a href="#ALL_EL_REPLICATE-val">ALL_EL_REPLICATE</a> : thm
<a name="line59"></a>    val <a href="#ALL_EL_REVERSE-val">ALL_EL_REVERSE</a> : thm
<a name="line60"></a>    val <a href="#ALL_EL_SEG-val">ALL_EL_SEG</a> : thm
<a name="line61"></a>    val <a href="#ALL_EL_SNOC-val">ALL_EL_SNOC</a> : thm
<a name="line62"></a>    val <a href="#AND_EL_FOLDL-val">AND_EL_FOLDL</a> : thm
<a name="line63"></a>    val <a href="#AND_EL_FOLDR-val">AND_EL_FOLDR</a> : thm
<a name="line64"></a>    val <a href="#APPEND-val">APPEND</a> : thm
<a name="line65"></a>    val <a href="#APPEND_11_LENGTH-val">APPEND_11_LENGTH</a> : thm
<a name="line66"></a>    val <a href="#APPEND_ASSOC-val">APPEND_ASSOC</a> : thm
<a name="line67"></a>    val <a href="#APPEND_ASSOC_CONS-val">APPEND_ASSOC_CONS</a> : thm
<a name="line68"></a>    val <a href="#APPEND_BUTLASTN_BUTFIRSTN-val">APPEND_BUTLASTN_BUTFIRSTN</a> : thm
<a name="line69"></a>    val <a href="#APPEND_BUTLASTN_DROP-val">APPEND_BUTLASTN_DROP</a> : thm
<a name="line70"></a>    val <a href="#APPEND_BUTLASTN_LASTN-val">APPEND_BUTLASTN_LASTN</a> : thm
<a name="line71"></a>    val <a href="#APPEND_BUTLAST_LAST-val">APPEND_BUTLAST_LAST</a> : thm
<a name="line72"></a>    val <a href="#APPEND_EQ_APPEND_EQ-val">APPEND_EQ_APPEND_EQ</a> : thm
<a name="line73"></a>    val <a href="#APPEND_FIRSTN_BUTFIRSTN-val">APPEND_FIRSTN_BUTFIRSTN</a> : thm
<a name="line74"></a>    val <a href="#APPEND_FIRSTN_LASTN-val">APPEND_FIRSTN_LASTN</a> : thm
<a name="line75"></a>    val <a href="#APPEND_FOLDL-val">APPEND_FOLDL</a> : thm
<a name="line76"></a>    val <a href="#APPEND_FOLDR-val">APPEND_FOLDR</a> : thm
<a name="line77"></a>    val <a href="#APPEND_LENGTH_EQ-val">APPEND_LENGTH_EQ</a> : thm
<a name="line78"></a>    val <a href="#APPEND_NIL-val">APPEND_NIL</a> : thm
<a name="line79"></a>    val <a href="#APPEND_SNOC-val">APPEND_SNOC</a> : thm
<a name="line80"></a>    val <a href="#APPEND_SNOC1-val">APPEND_SNOC1</a> : thm
<a name="line81"></a>    val <a href="#APPEND_TAKE_LASTN-val">APPEND_TAKE_LASTN</a> : thm
<a name="line82"></a>    val <a href="#ASSOC_APPEND-val">ASSOC_APPEND</a> : thm
<a name="line83"></a>    val <a href="#ASSOC_FOLDL_FLAT-val">ASSOC_FOLDL_FLAT</a> : thm
<a name="line84"></a>    val <a href="#ASSOC_FOLDR_FLAT-val">ASSOC_FOLDR_FLAT</a> : thm
<a name="line85"></a>    val <a href="#BUTFIRSTN-val">BUTFIRSTN</a> : thm
<a name="line86"></a>    val <a href="#BUTFIRSTN_APPEND1-val">BUTFIRSTN_APPEND1</a> : thm
<a name="line87"></a>    val <a href="#BUTFIRSTN_APPEND2-val">BUTFIRSTN_APPEND2</a> : thm
<a name="line88"></a>    val <a href="#BUTFIRSTN_BUTFIRSTN-val">BUTFIRSTN_BUTFIRSTN</a> : thm
<a name="line89"></a>    val <a href="#BUTFIRSTN_CONS_EL-val">BUTFIRSTN_CONS_EL</a> : thm
<a name="line90"></a>    val <a href="#BUTFIRSTN_LASTN-val">BUTFIRSTN_LASTN</a> : thm
<a name="line91"></a>    val <a href="#BUTFIRSTN_LENGTH_APPEND-val">BUTFIRSTN_LENGTH_APPEND</a> : thm
<a name="line92"></a>    val <a href="#BUTFIRSTN_LENGTH_NIL-val">BUTFIRSTN_LENGTH_NIL</a> : thm
<a name="line93"></a>    val <a href="#BUTFIRSTN_REVERSE-val">BUTFIRSTN_REVERSE</a> : thm
<a name="line94"></a>    val <a href="#BUTFIRSTN_SEG-val">BUTFIRSTN_SEG</a> : thm
<a name="line95"></a>    val <a href="#BUTFIRSTN_SNOC-val">BUTFIRSTN_SNOC</a> : thm
<a name="line96"></a>    val <a href="#BUTLAST-val">BUTLAST</a> : thm
<a name="line97"></a>    val <a href="#BUTLASTN-val">BUTLASTN</a> : thm
<a name="line98"></a>    val <a href="#BUTLASTN_1-val">BUTLASTN_1</a> : thm
<a name="line99"></a>    val <a href="#BUTLASTN_APPEND1-val">BUTLASTN_APPEND1</a> : thm
<a name="line100"></a>    val <a href="#BUTLASTN_APPEND2-val">BUTLASTN_APPEND2</a> : thm
<a name="line101"></a>    val <a href="#BUTLASTN_BUTLAST-val">BUTLASTN_BUTLAST</a> : thm
<a name="line102"></a>    val <a href="#BUTLASTN_BUTLASTN-val">BUTLASTN_BUTLASTN</a> : thm
<a name="line103"></a>    val <a href="#BUTLASTN_CONS-val">BUTLASTN_CONS</a> : thm
<a name="line104"></a>    val <a href="#BUTLASTN_FIRSTN-val">BUTLASTN_FIRSTN</a> : thm
<a name="line105"></a>    val <a href="#BUTLASTN_FRONT-val">BUTLASTN_FRONT</a> : thm
<a name="line106"></a>    val <a href="#BUTLASTN_LASTN-val">BUTLASTN_LASTN</a> : thm
<a name="line107"></a>    val <a href="#BUTLASTN_LASTN_NIL-val">BUTLASTN_LASTN_NIL</a> : thm
<a name="line108"></a>    val <a href="#BUTLASTN_LENGTH_APPEND-val">BUTLASTN_LENGTH_APPEND</a> : thm
<a name="line109"></a>    val <a href="#BUTLASTN_LENGTH_CONS-val">BUTLASTN_LENGTH_CONS</a> : thm
<a name="line110"></a>    val <a href="#BUTLASTN_LENGTH_NIL-val">BUTLASTN_LENGTH_NIL</a> : thm
<a name="line111"></a>    val <a href="#BUTLASTN_MAP-val">BUTLASTN_MAP</a> : thm
<a name="line112"></a>    val <a href="#BUTLASTN_REVERSE-val">BUTLASTN_REVERSE</a> : thm
<a name="line113"></a>    val <a href="#BUTLASTN_SEG-val">BUTLASTN_SEG</a> : thm
<a name="line114"></a>    val <a href="#BUTLASTN_SUC_BUTLAST-val">BUTLASTN_SUC_BUTLAST</a> : thm
<a name="line115"></a>    val <a href="#BUTLASTN_SUC_FRONT-val">BUTLASTN_SUC_FRONT</a> : thm
<a name="line116"></a>    val <a href="#BUTLASTN_TAKE-val">BUTLASTN_TAKE</a> : thm
<a name="line117"></a>    val <a href="#BUTLASTN_TAKE_UNCOND-val">BUTLASTN_TAKE_UNCOND</a> : thm
<a name="line118"></a>    val <a href="#BUTLASTN_compute-val">BUTLASTN_compute</a> : thm
<a name="line119"></a>    val <a href="#BUTLAST_CONS-val">BUTLAST_CONS</a> : thm
<a name="line120"></a>    val <a href="#COMM_ASSOC_FOLDL_REVERSE-val">COMM_ASSOC_FOLDL_REVERSE</a> : thm
<a name="line121"></a>    val <a href="#COMM_ASSOC_FOLDR_REVERSE-val">COMM_ASSOC_FOLDR_REVERSE</a> : thm
<a name="line122"></a>    val <a href="#COMM_MONOID_FOLDL-val">COMM_MONOID_FOLDL</a> : thm
<a name="line123"></a>    val <a href="#COMM_MONOID_FOLDR-val">COMM_MONOID_FOLDR</a> : thm
<a name="line124"></a>    val <a href="#CONS-val">CONS</a> : thm
<a name="line125"></a>    val <a href="#CONS_11-val">CONS_11</a> : thm
<a name="line126"></a>    val <a href="#CONS_APPEND-val">CONS_APPEND</a> : thm
<a name="line127"></a>    val <a href="#COUNT_LIST_ADD-val">COUNT_LIST_ADD</a> : thm
<a name="line128"></a>    val <a href="#COUNT_LIST_AUX_compute-val">COUNT_LIST_AUX_compute</a> : thm
<a name="line129"></a>    val <a href="#COUNT_LIST_COUNT-val">COUNT_LIST_COUNT</a> : thm
<a name="line130"></a>    val <a href="#COUNT_LIST_GENLIST-val">COUNT_LIST_GENLIST</a> : thm
<a name="line131"></a>    val <a href="#COUNT_LIST_SNOC-val">COUNT_LIST_SNOC</a> : thm
<a name="line132"></a>    val <a href="#COUNT_LIST_compute-val">COUNT_LIST_compute</a> : thm
<a name="line133"></a>    val <a href="#DELETE_ELEMENT_APPEND-val">DELETE_ELEMENT_APPEND</a> : thm
<a name="line134"></a>    val <a href="#DELETE_ELEMENT_FILTER-val">DELETE_ELEMENT_FILTER</a> : thm
<a name="line135"></a>    val <a href="#DISTINCT_LIST_TO_SET_EQ_SING-val">DISTINCT_LIST_TO_SET_EQ_SING</a> : thm
<a name="line136"></a>    val <a href="#DROP-val">DROP</a> : thm
<a name="line137"></a>    val <a href="#DROP_1-val">DROP_1</a> : thm
<a name="line138"></a>    val <a href="#DROP_1_APPEND-val">DROP_1_APPEND</a> : thm
<a name="line139"></a>    val <a href="#DROP_APPEND-val">DROP_APPEND</a> : thm
<a name="line140"></a>    val <a href="#DROP_APPEND1-val">DROP_APPEND1</a> : thm
<a name="line141"></a>    val <a href="#DROP_APPEND2-val">DROP_APPEND2</a> : thm
<a name="line142"></a>    val <a href="#DROP_BY_DROP_SUC-val">DROP_BY_DROP_SUC</a> : thm
<a name="line143"></a>    val <a href="#DROP_CONS_EL-val">DROP_CONS_EL</a> : thm
<a name="line144"></a>    val <a href="#DROP_DROP-val">DROP_DROP</a> : thm
<a name="line145"></a>    val <a href="#DROP_DROP_T-val">DROP_DROP_T</a> : thm
<a name="line146"></a>    val <a href="#DROP_EL_CONS-val">DROP_EL_CONS</a> : thm
<a name="line147"></a>    val <a href="#DROP_FUNPOW_TL-val">DROP_FUNPOW_TL</a> : thm
<a name="line148"></a>    val <a href="#DROP_HEAD_ELEMENT-val">DROP_HEAD_ELEMENT</a> : thm
<a name="line149"></a>    val <a href="#DROP_LASTN-val">DROP_LASTN</a> : thm
<a name="line150"></a>    val <a href="#DROP_LENGTH_APPEND-val">DROP_LENGTH_APPEND</a> : thm
<a name="line151"></a>    val <a href="#DROP_LENGTH_NIL-val">DROP_LENGTH_NIL</a> : thm
<a name="line152"></a>    val <a href="#DROP_LENGTH_NIL_rwt-val">DROP_LENGTH_NIL_rwt</a> : thm
<a name="line153"></a>    val <a href="#DROP_PREn_LAST_CONS-val">DROP_PREn_LAST_CONS</a> : thm
<a name="line154"></a>    val <a href="#DROP_REPLICATE-val">DROP_REPLICATE</a> : thm
<a name="line155"></a>    val <a href="#DROP_REVERSE-val">DROP_REVERSE</a> : thm
<a name="line156"></a>    val <a href="#DROP_SEG-val">DROP_SEG</a> : thm
<a name="line157"></a>    val <a href="#DROP_SNOC-val">DROP_SNOC</a> : thm
<a name="line158"></a>    val <a href="#DROP_SUC-val">DROP_SUC</a> : thm
<a name="line159"></a>    val <a href="#DROP_TAKE_EQ_NIL-val">DROP_TAKE_EQ_NIL</a> : thm
<a name="line160"></a>    val <a href="#EL-val">EL</a> : thm
<a name="line161"></a>    val <a href="#ELL_0_SNOC-val">ELL_0_SNOC</a> : thm
<a name="line162"></a>    val <a href="#ELL_APPEND1-val">ELL_APPEND1</a> : thm
<a name="line163"></a>    val <a href="#ELL_APPEND2-val">ELL_APPEND2</a> : thm
<a name="line164"></a>    val <a href="#ELL_CONS-val">ELL_CONS</a> : thm
<a name="line165"></a>    val <a href="#ELL_EL-val">ELL_EL</a> : thm
<a name="line166"></a>    val <a href="#ELL_IS_EL-val">ELL_IS_EL</a> : thm
<a name="line167"></a>    val <a href="#ELL_LAST-val">ELL_LAST</a> : thm
<a name="line168"></a>    val <a href="#ELL_LENGTH_APPEND-val">ELL_LENGTH_APPEND</a> : thm
<a name="line169"></a>    val <a href="#ELL_LENGTH_CONS-val">ELL_LENGTH_CONS</a> : thm
<a name="line170"></a>    val <a href="#ELL_LENGTH_SNOC-val">ELL_LENGTH_SNOC</a> : thm
<a name="line171"></a>    val <a href="#ELL_MAP-val">ELL_MAP</a> : thm
<a name="line172"></a>    val <a href="#ELL_MEM-val">ELL_MEM</a> : thm
<a name="line173"></a>    val <a href="#ELL_PRE_LENGTH-val">ELL_PRE_LENGTH</a> : thm
<a name="line174"></a>    val <a href="#ELL_REVERSE-val">ELL_REVERSE</a> : thm
<a name="line175"></a>    val <a href="#ELL_REVERSE_EL-val">ELL_REVERSE_EL</a> : thm
<a name="line176"></a>    val <a href="#ELL_SEG-val">ELL_SEG</a> : thm
<a name="line177"></a>    val <a href="#ELL_SNOC-val">ELL_SNOC</a> : thm
<a name="line178"></a>    val <a href="#ELL_SUC_SNOC-val">ELL_SUC_SNOC</a> : thm
<a name="line179"></a>    val <a href="#ELL_compute-val">ELL_compute</a> : thm
<a name="line180"></a>    val <a href="#EL_APPEND-val">EL_APPEND</a> : thm
<a name="line181"></a>    val <a href="#EL_APPEND1-val">EL_APPEND1</a> : thm
<a name="line182"></a>    val <a href="#EL_APPEND2-val">EL_APPEND2</a> : thm
<a name="line183"></a>    val <a href="#EL_BUTFIRSTN-val">EL_BUTFIRSTN</a> : thm
<a name="line184"></a>    val <a href="#EL_CONS-val">EL_CONS</a> : thm
<a name="line185"></a>    val <a href="#EL_COUNT_LIST-val">EL_COUNT_LIST</a> : thm
<a name="line186"></a>    val <a href="#EL_DROP-val">EL_DROP</a> : thm
<a name="line187"></a>    val <a href="#EL_ELL-val">EL_ELL</a> : thm
<a name="line188"></a>    val <a href="#EL_FIRSTN-val">EL_FIRSTN</a> : thm
<a name="line189"></a>    val <a href="#EL_FRONT-val">EL_FRONT</a> : thm
<a name="line190"></a>    val <a href="#EL_GENLIST-val">EL_GENLIST</a> : thm
<a name="line191"></a>    val <a href="#EL_IS_EL-val">EL_IS_EL</a> : thm
<a name="line192"></a>    val <a href="#EL_LENGTH_APPEND-val">EL_LENGTH_APPEND</a> : thm
<a name="line193"></a>    val <a href="#EL_LENGTH_APPEND_0-val">EL_LENGTH_APPEND_0</a> : thm
<a name="line194"></a>    val <a href="#EL_LENGTH_APPEND_1-val">EL_LENGTH_APPEND_1</a> : thm
<a name="line195"></a>    val <a href="#EL_LENGTH_APPEND_rwt-val">EL_LENGTH_APPEND_rwt</a> : thm
<a name="line196"></a>    val <a href="#EL_LENGTH_SNOC-val">EL_LENGTH_SNOC</a> : thm
<a name="line197"></a>    val <a href="#EL_MAP-val">EL_MAP</a> : thm
<a name="line198"></a>    val <a href="#EL_MEM-val">EL_MEM</a> : thm
<a name="line199"></a>    val <a href="#EL_PRE_LENGTH-val">EL_PRE_LENGTH</a> : thm
<a name="line200"></a>    val <a href="#EL_REPLICATE-val">EL_REPLICATE</a> : thm
<a name="line201"></a>    val <a href="#EL_REVERSE-val">EL_REVERSE</a> : thm
<a name="line202"></a>    val <a href="#EL_REVERSE_ELL-val">EL_REVERSE_ELL</a> : thm
<a name="line203"></a>    val <a href="#EL_SEG-val">EL_SEG</a> : thm
<a name="line204"></a>    val <a href="#EL_SNOC-val">EL_SNOC</a> : thm
<a name="line205"></a>    val <a href="#EL_SPLIT-val">EL_SPLIT</a> : thm
<a name="line206"></a>    val <a href="#EL_SPLIT_2-val">EL_SPLIT_2</a> : thm
<a name="line207"></a>    val <a href="#EL_TAIL-val">EL_TAIL</a> : thm
<a name="line208"></a>    val <a href="#EL_TAKE-val">EL_TAKE</a> : thm
<a name="line209"></a>    val <a href="#EL_chunks-val">EL_chunks</a> : thm
<a name="line210"></a>    val <a href="#EQ_LIST-val">EQ_LIST</a> : thm
<a name="line211"></a>    val <a href="#EVERY2_APPEND-val">EVERY2_APPEND</a> : thm
<a name="line212"></a>    val <a href="#EVERY2_APPEND_suff-val">EVERY2_APPEND_suff</a> : thm
<a name="line213"></a>    val <a href="#EVERY2_DROP-val">EVERY2_DROP</a> : thm
<a name="line214"></a>    val <a href="#EVERY2_REVERSE1-val">EVERY2_REVERSE1</a> : thm
<a name="line215"></a>    val <a href="#EVERY2_TAKE-val">EVERY2_TAKE</a> : thm
<a name="line216"></a>    val <a href="#EVERY_BUTLASTN-val">EVERY_BUTLASTN</a> : thm
<a name="line217"></a>    val <a href="#EVERY_DELETE_ELEMENT-val">EVERY_DELETE_ELEMENT</a> : thm
<a name="line218"></a>    val <a href="#EVERY_DROP-val">EVERY_DROP</a> : thm
<a name="line219"></a>    val <a href="#EVERY_FOLDL-val">EVERY_FOLDL</a> : thm
<a name="line220"></a>    val <a href="#EVERY_FOLDL_MAP-val">EVERY_FOLDL_MAP</a> : thm
<a name="line221"></a>    val <a href="#EVERY_FOLDR-val">EVERY_FOLDR</a> : thm
<a name="line222"></a>    val <a href="#EVERY_FOLDR_MAP-val">EVERY_FOLDR_MAP</a> : thm
<a name="line223"></a>    val <a href="#EVERY_GENLIST-val">EVERY_GENLIST</a> : thm
<a name="line224"></a>    val <a href="#EVERY_LASTN-val">EVERY_LASTN</a> : thm
<a name="line225"></a>    val <a href="#EVERY_REPLICATE-val">EVERY_REPLICATE</a> : thm
<a name="line226"></a>    val <a href="#EVERY_REVERSE-val">EVERY_REVERSE</a> : thm
<a name="line227"></a>    val <a href="#EVERY_SEG-val">EVERY_SEG</a> : thm
<a name="line228"></a>    val <a href="#EVERY_TAKE-val">EVERY_TAKE</a> : thm
<a name="line229"></a>    val <a href="#EXISTS_BUTLASTN-val">EXISTS_BUTLASTN</a> : thm
<a name="line230"></a>    val <a href="#EXISTS_DISJ-val">EXISTS_DISJ</a> : thm
<a name="line231"></a>    val <a href="#EXISTS_DROP-val">EXISTS_DROP</a> : thm
<a name="line232"></a>    val <a href="#EXISTS_FOLDL-val">EXISTS_FOLDL</a> : thm
<a name="line233"></a>    val <a href="#EXISTS_FOLDL_MAP-val">EXISTS_FOLDL_MAP</a> : thm
<a name="line234"></a>    val <a href="#EXISTS_FOLDR-val">EXISTS_FOLDR</a> : thm
<a name="line235"></a>    val <a href="#EXISTS_FOLDR_MAP-val">EXISTS_FOLDR_MAP</a> : thm
<a name="line236"></a>    val <a href="#EXISTS_GENLIST-val">EXISTS_GENLIST</a> : thm
<a name="line237"></a>    val <a href="#EXISTS_LASTN-val">EXISTS_LASTN</a> : thm
<a name="line238"></a>    val <a href="#EXISTS_REVERSE-val">EXISTS_REVERSE</a> : thm
<a name="line239"></a>    val <a href="#EXISTS_SEG-val">EXISTS_SEG</a> : thm
<a name="line240"></a>    val <a href="#EXISTS_TAKE-val">EXISTS_TAKE</a> : thm
<a name="line241"></a>    val <a href="#FCOMM_FOLDL_APPEND-val">FCOMM_FOLDL_APPEND</a> : thm
<a name="line242"></a>    val <a href="#FCOMM_FOLDL_FLAT-val">FCOMM_FOLDL_FLAT</a> : thm
<a name="line243"></a>    val <a href="#FCOMM_FOLDR_APPEND-val">FCOMM_FOLDR_APPEND</a> : thm
<a name="line244"></a>    val <a href="#FCOMM_FOLDR_FLAT-val">FCOMM_FOLDR_FLAT</a> : thm
<a name="line245"></a>    val <a href="#FILTER-val">FILTER</a> : thm
<a name="line246"></a>    val <a href="#FILTER_APPEND-val">FILTER_APPEND</a> : thm
<a name="line247"></a>    val <a href="#FILTER_COMM-val">FILTER_COMM</a> : thm
<a name="line248"></a>    val <a href="#FILTER_EL_IFF-val">FILTER_EL_IFF</a> : thm
<a name="line249"></a>    val <a href="#FILTER_EL_IMP-val">FILTER_EL_IMP</a> : thm
<a name="line250"></a>    val <a href="#FILTER_EL_NEXT-val">FILTER_EL_NEXT</a> : thm
<a name="line251"></a>    val <a href="#FILTER_EL_NEXT_IFF-val">FILTER_EL_NEXT_IFF</a> : thm
<a name="line252"></a>    val <a href="#FILTER_EQ-val">FILTER_EQ</a> : thm
<a name="line253"></a>    val <a href="#FILTER_FILTER-val">FILTER_FILTER</a> : thm
<a name="line254"></a>    val <a href="#FILTER_FLAT-val">FILTER_FLAT</a> : thm
<a name="line255"></a>    val <a href="#FILTER_FOLDL-val">FILTER_FOLDL</a> : thm
<a name="line256"></a>    val <a href="#FILTER_FOLDR-val">FILTER_FOLDR</a> : thm
<a name="line257"></a>    val <a href="#FILTER_HD-val">FILTER_HD</a> : thm
<a name="line258"></a>    val <a href="#FILTER_HD_IFF-val">FILTER_HD_IFF</a> : thm
<a name="line259"></a>    val <a href="#FILTER_IDEM-val">FILTER_IDEM</a> : thm
<a name="line260"></a>    val <a href="#FILTER_LAST-val">FILTER_LAST</a> : thm
<a name="line261"></a>    val <a href="#FILTER_LAST_IFF-val">FILTER_LAST_IFF</a> : thm
<a name="line262"></a>    val <a href="#FILTER_MAP-val">FILTER_MAP</a> : thm
<a name="line263"></a>    val <a href="#FILTER_MONO_DEC-val">FILTER_MONO_DEC</a> : thm
<a name="line264"></a>    val <a href="#FILTER_MONO_INC-val">FILTER_MONO_INC</a> : thm
<a name="line265"></a>    val <a href="#FILTER_REVERSE-val">FILTER_REVERSE</a> : thm
<a name="line266"></a>    val <a href="#FILTER_SNOC-val">FILTER_SNOC</a> : thm
<a name="line267"></a>    val <a href="#FILTER_sublist-val">FILTER_sublist</a> : thm
<a name="line268"></a>    val <a href="#FINITE_common_prefixes-val">FINITE_common_prefixes</a> : thm
<a name="line269"></a>    val <a href="#FINITE_prefix-val">FINITE_prefix</a> : thm
<a name="line270"></a>    val <a href="#FIRSTN-val">FIRSTN</a> : thm
<a name="line271"></a>    val <a href="#FIRSTN_APPEND1-val">FIRSTN_APPEND1</a> : thm
<a name="line272"></a>    val <a href="#FIRSTN_APPEND2-val">FIRSTN_APPEND2</a> : thm
<a name="line273"></a>    val <a href="#FIRSTN_BUTLASTN-val">FIRSTN_BUTLASTN</a> : thm
<a name="line274"></a>    val <a href="#FIRSTN_FIRSTN-val">FIRSTN_FIRSTN</a> : thm
<a name="line275"></a>    val <a href="#FIRSTN_LENGTH_APPEND-val">FIRSTN_LENGTH_APPEND</a> : thm
<a name="line276"></a>    val <a href="#FIRSTN_LENGTH_ID-val">FIRSTN_LENGTH_ID</a> : thm
<a name="line277"></a>    val <a href="#FIRSTN_REVERSE-val">FIRSTN_REVERSE</a> : thm
<a name="line278"></a>    val <a href="#FIRSTN_SEG-val">FIRSTN_SEG</a> : thm
<a name="line279"></a>    val <a href="#FIRSTN_SNOC-val">FIRSTN_SNOC</a> : thm
<a name="line280"></a>    val <a href="#FLAT-val">FLAT</a> : thm
<a name="line281"></a>    val <a href="#FLAT_APPEND-val">FLAT_APPEND</a> : thm
<a name="line282"></a>    val <a href="#FLAT_FLAT-val">FLAT_FLAT</a> : thm
<a name="line283"></a>    val <a href="#FLAT_FOLDL-val">FLAT_FOLDL</a> : thm
<a name="line284"></a>    val <a href="#FLAT_FOLDR-val">FLAT_FOLDR</a> : thm
<a name="line285"></a>    val <a href="#FLAT_REVERSE-val">FLAT_REVERSE</a> : thm
<a name="line286"></a>    val <a href="#FLAT_SNOC-val">FLAT_SNOC</a> : thm
<a name="line287"></a>    val <a href="#FLAT_chunks-val">FLAT_chunks</a> : thm
<a name="line288"></a>    val <a href="#FOLDL-val">FOLDL</a> : thm
<a name="line289"></a>    val <a href="#FOLDL_APPEND-val">FOLDL_APPEND</a> : thm
<a name="line290"></a>    val <a href="#FOLDL_CONG_invariant-val">FOLDL_CONG_invariant</a> : thm
<a name="line291"></a>    val <a href="#FOLDL_FILTER-val">FOLDL_FILTER</a> : thm
<a name="line292"></a>    val <a href="#FOLDL_FOLDR_REVERSE-val">FOLDL_FOLDR_REVERSE</a> : thm
<a name="line293"></a>    val <a href="#FOLDL_MAP-val">FOLDL_MAP</a> : thm
<a name="line294"></a>    val <a href="#FOLDL_MAP2-val">FOLDL_MAP2</a> : thm
<a name="line295"></a>    val <a href="#FOLDL_REVERSE-val">FOLDL_REVERSE</a> : thm
<a name="line296"></a>    val <a href="#FOLDL_SINGLE-val">FOLDL_SINGLE</a> : thm
<a name="line297"></a>    val <a href="#FOLDL_SNOC-val">FOLDL_SNOC</a> : thm
<a name="line298"></a>    val <a href="#FOLDL_SNOC_NIL-val">FOLDL_SNOC_NIL</a> : thm
<a name="line299"></a>    val <a href="#FOLDR-val">FOLDR</a> : thm
<a name="line300"></a>    val <a href="#FOLDR_APPEND-val">FOLDR_APPEND</a> : thm
<a name="line301"></a>    val <a href="#FOLDR_CONS_NIL-val">FOLDR_CONS_NIL</a> : thm
<a name="line302"></a>    val <a href="#FOLDR_FILTER-val">FOLDR_FILTER</a> : thm
<a name="line303"></a>    val <a href="#FOLDR_FILTER_REVERSE-val">FOLDR_FILTER_REVERSE</a> : thm
<a name="line304"></a>    val <a href="#FOLDR_FOLDL-val">FOLDR_FOLDL</a> : thm
<a name="line305"></a>    val <a href="#FOLDR_FOLDL_REVERSE-val">FOLDR_FOLDL_REVERSE</a> : thm
<a name="line306"></a>    val <a href="#FOLDR_MAP-val">FOLDR_MAP</a> : thm
<a name="line307"></a>    val <a href="#FOLDR_MAP_REVERSE-val">FOLDR_MAP_REVERSE</a> : thm
<a name="line308"></a>    val <a href="#FOLDR_REVERSE-val">FOLDR_REVERSE</a> : thm
<a name="line309"></a>    val <a href="#FOLDR_SINGLE-val">FOLDR_SINGLE</a> : thm
<a name="line310"></a>    val <a href="#FOLDR_SNOC-val">FOLDR_SNOC</a> : thm
<a name="line311"></a>    val <a href="#FRONT_APPEND-val">FRONT_APPEND</a> : thm
<a name="line312"></a>    val <a href="#FRONT_APPEND_NOT_NIL-val">FRONT_APPEND_NOT_NIL</a> : thm
<a name="line313"></a>    val <a href="#FRONT_BY_TAKE-val">FRONT_BY_TAKE</a> : thm
<a name="line314"></a>    val <a href="#FRONT_EL-val">FRONT_EL</a> : thm
<a name="line315"></a>    val <a href="#FRONT_EQ_NIL-val">FRONT_EQ_NIL</a> : thm
<a name="line316"></a>    val <a href="#FRONT_LENGTH-val">FRONT_LENGTH</a> : thm
<a name="line317"></a>    val <a href="#FRONT_NON_NIL-val">FRONT_NON_NIL</a> : thm
<a name="line318"></a>    val <a href="#FRONT_SING-val">FRONT_SING</a> : thm
<a name="line319"></a>    val <a href="#GENLIST-val">GENLIST</a> : thm
<a name="line320"></a>    val <a href="#GENLIST_APPEND-val">GENLIST_APPEND</a> : thm
<a name="line321"></a>    val <a href="#GENLIST_CONS-val">GENLIST_CONS</a> : thm
<a name="line322"></a>    val <a href="#GENLIST_FUN_EQ-val">GENLIST_FUN_EQ</a> : thm
<a name="line323"></a>    val <a href="#GENLIST_K_ADD-val">GENLIST_K_ADD</a> : thm
<a name="line324"></a>    val <a href="#GENLIST_K_APPEND-val">GENLIST_K_APPEND</a> : thm
<a name="line325"></a>    val <a href="#GENLIST_K_APPEND_K-val">GENLIST_K_APPEND_K</a> : thm
<a name="line326"></a>    val <a href="#GENLIST_K_CONS-val">GENLIST_K_CONS</a> : thm
<a name="line327"></a>    val <a href="#GENLIST_K_LESS-val">GENLIST_K_LESS</a> : thm
<a name="line328"></a>    val <a href="#GENLIST_K_MEM-val">GENLIST_K_MEM</a> : thm
<a name="line329"></a>    val <a href="#GENLIST_K_RANGE-val">GENLIST_K_RANGE</a> : thm
<a name="line330"></a>    val <a href="#GENLIST_K_SET-val">GENLIST_K_SET</a> : thm
<a name="line331"></a>    val <a href="#HD-val">HD</a> : thm
<a name="line332"></a>    val <a href="#HD_APPEND-val">HD_APPEND</a> : thm
<a name="line333"></a>    val <a href="#HD_APPEND_NOT_NIL-val">HD_APPEND_NOT_NIL</a> : thm
<a name="line334"></a>    val <a href="#HD_GENLIST-val">HD_GENLIST</a> : thm
<a name="line335"></a>    val <a href="#HEAD_MEM-val">HEAD_MEM</a> : thm
<a name="line336"></a>    val <a href="#IS_EL-val">IS_EL</a> : thm
<a name="line337"></a>    val <a href="#IS_EL_APPEND-val">IS_EL_APPEND</a> : thm
<a name="line338"></a>    val <a href="#IS_EL_BUTFIRSTN-val">IS_EL_BUTFIRSTN</a> : thm
<a name="line339"></a>    val <a href="#IS_EL_BUTLASTN-val">IS_EL_BUTLASTN</a> : thm
<a name="line340"></a>    val <a href="#IS_EL_DEF-val">IS_EL_DEF</a> : thm
<a name="line341"></a>    val <a href="#IS_EL_FILTER-val">IS_EL_FILTER</a> : thm
<a name="line342"></a>    val <a href="#IS_EL_FIRSTN-val">IS_EL_FIRSTN</a> : thm
<a name="line343"></a>    val <a href="#IS_EL_FOLDL-val">IS_EL_FOLDL</a> : thm
<a name="line344"></a>    val <a href="#IS_EL_FOLDL_MAP-val">IS_EL_FOLDL_MAP</a> : thm
<a name="line345"></a>    val <a href="#IS_EL_FOLDR-val">IS_EL_FOLDR</a> : thm
<a name="line346"></a>    val <a href="#IS_EL_FOLDR_MAP-val">IS_EL_FOLDR_MAP</a> : thm
<a name="line347"></a>    val <a href="#IS_EL_LASTN-val">IS_EL_LASTN</a> : thm
<a name="line348"></a>    val <a href="#IS_EL_REPLICATE-val">IS_EL_REPLICATE</a> : thm
<a name="line349"></a>    val <a href="#IS_EL_REVERSE-val">IS_EL_REVERSE</a> : thm
<a name="line350"></a>    val <a href="#IS_EL_SEG-val">IS_EL_SEG</a> : thm
<a name="line351"></a>    val <a href="#IS_EL_SNOC-val">IS_EL_SNOC</a> : thm
<a name="line352"></a>    val <a href="#IS_EL_SOME_EL-val">IS_EL_SOME_EL</a> : thm
<a name="line353"></a>    val <a href="#IS_PREFIX-val">IS_PREFIX</a> : thm
<a name="line354"></a>    val <a href="#IS_PREFIX_ALL_DISTINCT-val">IS_PREFIX_ALL_DISTINCT</a> : thm
<a name="line355"></a>    val <a href="#IS_PREFIX_ANTISYM-val">IS_PREFIX_ANTISYM</a> : thm
<a name="line356"></a>    val <a href="#IS_PREFIX_APPEND-val">IS_PREFIX_APPEND</a> : thm
<a name="line357"></a>    val <a href="#IS_PREFIX_APPEND1-val">IS_PREFIX_APPEND1</a> : thm
<a name="line358"></a>    val <a href="#IS_PREFIX_APPEND2-val">IS_PREFIX_APPEND2</a> : thm
<a name="line359"></a>    val <a href="#IS_PREFIX_APPEND3-val">IS_PREFIX_APPEND3</a> : thm
<a name="line360"></a>    val <a href="#IS_PREFIX_APPENDS-val">IS_PREFIX_APPENDS</a> : thm
<a name="line361"></a>    val <a href="#IS_PREFIX_BUTLAST-val">IS_PREFIX_BUTLAST</a> : thm
<a name="line362"></a>    val <a href="#IS_PREFIX_BUTLAST'-val">IS_PREFIX_BUTLAST'</a> : thm
<a name="line363"></a>    val <a href="#IS_PREFIX_EQ_REWRITE-val">IS_PREFIX_EQ_REWRITE</a> : thm
<a name="line364"></a>    val <a href="#IS_PREFIX_EQ_TAKE-val">IS_PREFIX_EQ_TAKE</a> : thm
<a name="line365"></a>    val <a href="#IS_PREFIX_EQ_TAKE'-val">IS_PREFIX_EQ_TAKE'</a> : thm
<a name="line366"></a>    val <a href="#IS_PREFIX_FRONT_CASES-val">IS_PREFIX_FRONT_CASES</a> : thm
<a name="line367"></a>    val <a href="#IS_PREFIX_FRONT_MONO-val">IS_PREFIX_FRONT_MONO</a> : thm
<a name="line368"></a>    val <a href="#IS_PREFIX_GENLIST-val">IS_PREFIX_GENLIST</a> : thm
<a name="line369"></a>    val <a href="#IS_PREFIX_IMP_TAKE-val">IS_PREFIX_IMP_TAKE</a> : thm
<a name="line370"></a>    val <a href="#IS_PREFIX_IS_SUBLIST-val">IS_PREFIX_IS_SUBLIST</a> : thm
<a name="line371"></a>    val <a href="#IS_PREFIX_LENGTH-val">IS_PREFIX_LENGTH</a> : thm
<a name="line372"></a>    val <a href="#IS_PREFIX_LENGTH_ANTI-val">IS_PREFIX_LENGTH_ANTI</a> : thm
<a name="line373"></a>    val <a href="#IS_PREFIX_NIL-val">IS_PREFIX_NIL</a> : thm
<a name="line374"></a>    val <a href="#IS_PREFIX_PREFIX-val">IS_PREFIX_PREFIX</a> : thm
<a name="line375"></a>    val <a href="#IS_PREFIX_REFL-val">IS_PREFIX_REFL</a> : thm
<a name="line376"></a>    val <a href="#IS_PREFIX_REVERSE-val">IS_PREFIX_REVERSE</a> : thm
<a name="line377"></a>    val <a href="#IS_PREFIX_SNOC-val">IS_PREFIX_SNOC</a> : thm
<a name="line378"></a>    val <a href="#IS_PREFIX_TRANS-val">IS_PREFIX_TRANS</a> : thm
<a name="line379"></a>    val <a href="#IS_SUBLIST_APPEND-val">IS_SUBLIST_APPEND</a> : thm
<a name="line380"></a>    val <a href="#IS_SUBLIST_REVERSE-val">IS_SUBLIST_REVERSE</a> : thm
<a name="line381"></a>    val <a href="#IS_SUFFIX_ALL_DISTINCT-val">IS_SUFFIX_ALL_DISTINCT</a> : thm
<a name="line382"></a>    val <a href="#IS_SUFFIX_APPEND-val">IS_SUFFIX_APPEND</a> : thm
<a name="line383"></a>    val <a href="#IS_SUFFIX_APPEND1-val">IS_SUFFIX_APPEND1</a> : thm
<a name="line384"></a>    val <a href="#IS_SUFFIX_CONS-val">IS_SUFFIX_CONS</a> : thm
<a name="line385"></a>    val <a href="#IS_SUFFIX_CONS2_E-val">IS_SUFFIX_CONS2_E</a> : thm
<a name="line386"></a>    val <a href="#IS_SUFFIX_EQ_DROP-val">IS_SUFFIX_EQ_DROP</a> : thm
<a name="line387"></a>    val <a href="#IS_SUFFIX_EQ_DROP'-val">IS_SUFFIX_EQ_DROP'</a> : thm
<a name="line388"></a>    val <a href="#IS_SUFFIX_IMP_DROP-val">IS_SUFFIX_IMP_DROP</a> : thm
<a name="line389"></a>    val <a href="#IS_SUFFIX_IMP_LASTN-val">IS_SUFFIX_IMP_LASTN</a> : thm
<a name="line390"></a>    val <a href="#IS_SUFFIX_IS_SUBLIST-val">IS_SUFFIX_IS_SUBLIST</a> : thm
<a name="line391"></a>    val <a href="#IS_SUFFIX_REFL-val">IS_SUFFIX_REFL</a> : thm
<a name="line392"></a>    val <a href="#IS_SUFFIX_REVERSE-val">IS_SUFFIX_REVERSE</a> : thm
<a name="line393"></a>    val <a href="#IS_SUFFIX_TRANS-val">IS_SUFFIX_TRANS</a> : thm
<a name="line394"></a>    val <a href="#IS_SUFFIX_compute-val">IS_SUFFIX_compute</a> : thm
<a name="line395"></a>    val <a href="#IS_SUFFIX_dropWhile-val">IS_SUFFIX_dropWhile</a> : thm
<a name="line396"></a>    val <a href="#ITSET_TO_FOLDR-val">ITSET_TO_FOLDR</a> : thm
<a name="line397"></a>    val <a href="#LAST-val">LAST</a> : thm
<a name="line398"></a>    val <a href="#LASTN-val">LASTN</a> : thm
<a name="line399"></a>    val <a href="#LASTN_1-val">LASTN_1</a> : thm
<a name="line400"></a>    val <a href="#LASTN_APPEND1-val">LASTN_APPEND1</a> : thm
<a name="line401"></a>    val <a href="#LASTN_APPEND2-val">LASTN_APPEND2</a> : thm
<a name="line402"></a>    val <a href="#LASTN_BUTFIRSTN-val">LASTN_BUTFIRSTN</a> : thm
<a name="line403"></a>    val <a href="#LASTN_BUTLASTN-val">LASTN_BUTLASTN</a> : thm
<a name="line404"></a>    val <a href="#LASTN_CONS-val">LASTN_CONS</a> : thm
<a name="line405"></a>    val <a href="#LASTN_DROP-val">LASTN_DROP</a> : thm
<a name="line406"></a>    val <a href="#LASTN_DROP_UNCOND-val">LASTN_DROP_UNCOND</a> : thm
<a name="line407"></a>    val <a href="#LASTN_LASTN-val">LASTN_LASTN</a> : thm
<a name="line408"></a>    val <a href="#LASTN_LENGTH_APPEND-val">LASTN_LENGTH_APPEND</a> : thm
<a name="line409"></a>    val <a href="#LASTN_LENGTH_ID-val">LASTN_LENGTH_ID</a> : thm
<a name="line410"></a>    val <a href="#LASTN_MAP-val">LASTN_MAP</a> : thm
<a name="line411"></a>    val <a href="#LASTN_REVERSE-val">LASTN_REVERSE</a> : thm
<a name="line412"></a>    val <a href="#LASTN_SEG-val">LASTN_SEG</a> : thm
<a name="line413"></a>    val <a href="#LASTN_compute-val">LASTN_compute</a> : thm
<a name="line414"></a>    val <a href="#LAST_APPEND-val">LAST_APPEND</a> : thm
<a name="line415"></a>    val <a href="#LAST_APPEND_NOT_NIL-val">LAST_APPEND_NOT_NIL</a> : thm
<a name="line416"></a>    val <a href="#LAST_CONS-val">LAST_CONS</a> : thm
<a name="line417"></a>    val <a href="#LAST_EL_CONS-val">LAST_EL_CONS</a> : thm
<a name="line418"></a>    val <a href="#LAST_EQ_HD-val">LAST_EQ_HD</a> : thm
<a name="line419"></a>    val <a href="#LAST_LASTN_LAST-val">LAST_LASTN_LAST</a> : thm
<a name="line420"></a>    val <a href="#LAST_MEM-val">LAST_MEM</a> : thm
<a name="line421"></a>    val <a href="#LENGTH-val">LENGTH</a> : thm
<a name="line422"></a>    val <a href="#LENGTH_APPEND-val">LENGTH_APPEND</a> : thm
<a name="line423"></a>    val <a href="#LENGTH_BUTFIRSTN-val">LENGTH_BUTFIRSTN</a> : thm
<a name="line424"></a>    val <a href="#LENGTH_BUTLAST-val">LENGTH_BUTLAST</a> : thm
<a name="line425"></a>    val <a href="#LENGTH_BUTLASTN-val">LENGTH_BUTLASTN</a> : thm
<a name="line426"></a>    val <a href="#LENGTH_CONS-val">LENGTH_CONS</a> : thm
<a name="line427"></a>    val <a href="#LENGTH_COUNT_LIST-val">LENGTH_COUNT_LIST</a> : thm
<a name="line428"></a>    val <a href="#LENGTH_DELETE_ELEMENT_LE-val">LENGTH_DELETE_ELEMENT_LE</a> : thm
<a name="line429"></a>    val <a href="#LENGTH_DELETE_ELEMENT_LEQ-val">LENGTH_DELETE_ELEMENT_LEQ</a> : thm
<a name="line430"></a>    val <a href="#LENGTH_EQ_NIL-val">LENGTH_EQ_NIL</a> : thm
<a name="line431"></a>    val <a href="#LENGTH_FILTER_LEQ-val">LENGTH_FILTER_LEQ</a> : thm
<a name="line432"></a>    val <a href="#LENGTH_FILTER_LESS-val">LENGTH_FILTER_LESS</a> : thm
<a name="line433"></a>    val <a href="#LENGTH_FIRSTN-val">LENGTH_FIRSTN</a> : thm
<a name="line434"></a>    val <a href="#LENGTH_FLAT-val">LENGTH_FLAT</a> : thm
<a name="line435"></a>    val <a href="#LENGTH_FLAT_REPLICATE-val">LENGTH_FLAT_REPLICATE</a> : thm
<a name="line436"></a>    val <a href="#LENGTH_FOLDL-val">LENGTH_FOLDL</a> : thm
<a name="line437"></a>    val <a href="#LENGTH_FOLDR-val">LENGTH_FOLDR</a> : thm
<a name="line438"></a>    val <a href="#LENGTH_FRONT-val">LENGTH_FRONT</a> : thm
<a name="line439"></a>    val <a href="#LENGTH_GENLIST-val">LENGTH_GENLIST</a> : thm
<a name="line440"></a>    val <a href="#LENGTH_LASTN-val">LENGTH_LASTN</a> : thm
<a name="line441"></a>    val <a href="#LENGTH_MAP-val">LENGTH_MAP</a> : thm
<a name="line442"></a>    val <a href="#LENGTH_NIL-val">LENGTH_NIL</a> : thm
<a name="line443"></a>    val <a href="#LENGTH_NOT_NULL-val">LENGTH_NOT_NULL</a> : thm
<a name="line444"></a>    val <a href="#LENGTH_REPLICATE-val">LENGTH_REPLICATE</a> : thm
<a name="line445"></a>    val <a href="#LENGTH_REVERSE-val">LENGTH_REVERSE</a> : thm
<a name="line446"></a>    val <a href="#LENGTH_SCANL-val">LENGTH_SCANL</a> : thm
<a name="line447"></a>    val <a href="#LENGTH_SCANR-val">LENGTH_SCANR</a> : thm
<a name="line448"></a>    val <a href="#LENGTH_SEG-val">LENGTH_SEG</a> : thm
<a name="line449"></a>    val <a href="#LENGTH_SING-val">LENGTH_SING</a> : thm
<a name="line450"></a>    val <a href="#LENGTH_SNOC-val">LENGTH_SNOC</a> : thm
<a name="line451"></a>    val <a href="#LENGTH_TAKE_LE-val">LENGTH_TAKE_LE</a> : thm
<a name="line452"></a>    val <a href="#LENGTH_TL_LT-val">LENGTH_TL_LT</a> : thm
<a name="line453"></a>    val <a href="#LENGTH_UNZIP_FST-val">LENGTH_UNZIP_FST</a> : thm
<a name="line454"></a>    val <a href="#LENGTH_UNZIP_SND-val">LENGTH_UNZIP_SND</a> : thm
<a name="line455"></a>    val <a href="#LENGTH_ZIP-val">LENGTH_ZIP</a> : thm
<a name="line456"></a>    val <a href="#LENGTH_chunks-val">LENGTH_chunks</a> : thm
<a name="line457"></a>    val <a href="#LENGTH_dropWhile_id-val">LENGTH_dropWhile_id</a> : thm
<a name="line458"></a>    val <a href="#LIST_ELEM_COUNT_CARD_EL-val">LIST_ELEM_COUNT_CARD_EL</a> : thm
<a name="line459"></a>    val <a href="#LIST_ELEM_COUNT_MEM-val">LIST_ELEM_COUNT_MEM</a> : thm
<a name="line460"></a>    val <a href="#LIST_ELEM_COUNT_THM-val">LIST_ELEM_COUNT_THM</a> : thm
<a name="line461"></a>    val <a href="#LIST_EQ_HEAD_TAIL-val">LIST_EQ_HEAD_TAIL</a> : thm
<a name="line462"></a>    val <a href="#LIST_HEAD_TAIL-val">LIST_HEAD_TAIL</a> : thm
<a name="line463"></a>    val <a href="#LIST_NOT_EQ-val">LIST_NOT_EQ</a> : thm
<a name="line464"></a>    val <a href="#LIST_REL_APPEND_SING-val">LIST_REL_APPEND_SING</a> : thm
<a name="line465"></a>    val <a href="#LIST_REL_GENLIST-val">LIST_REL_GENLIST</a> : thm
<a name="line466"></a>    val <a href="#LIST_REL_REPLICATE_same-val">LIST_REL_REPLICATE_same</a> : thm
<a name="line467"></a>    val <a href="#LIST_REL_REVERSE_EQ-val">LIST_REL_REVERSE_EQ</a> : thm
<a name="line468"></a>    val <a href="#LIST_SING_EQ-val">LIST_SING_EQ</a> : thm
<a name="line469"></a>    val <a href="#LIST_TO_SET_EQ_SING-val">LIST_TO_SET_EQ_SING</a> : thm
<a name="line470"></a>    val <a href="#LIST_TO_SET_PREFIX-val">LIST_TO_SET_PREFIX</a> : thm
<a name="line471"></a>    val <a href="#LIST_TO_SET_SING_IFF-val">LIST_TO_SET_SING_IFF</a> : thm
<a name="line472"></a>    val <a href="#LIST_TO_SET_SUFFIX-val">LIST_TO_SET_SUFFIX</a> : thm
<a name="line473"></a>    val <a href="#LUPDATE_APPEND1-val">LUPDATE_APPEND1</a> : thm
<a name="line474"></a>    val <a href="#LUPDATE_APPEND2-val">LUPDATE_APPEND2</a> : thm
<a name="line475"></a>    val <a href="#MAP-val">MAP</a> : thm
<a name="line476"></a>    val <a href="#MAP2-val">MAP2</a> : thm
<a name="line477"></a>    val <a href="#MAP2_MAP_MAP-val">MAP2_MAP_MAP</a> : thm
<a name="line478"></a>    val <a href="#MAP2_ZIP-val">MAP2_ZIP</a> : thm
<a name="line479"></a>    val <a href="#MAP_APPEND-val">MAP_APPEND</a> : thm
<a name="line480"></a>    val <a href="#MAP_COUNT_LIST-val">MAP_COUNT_LIST</a> : thm
<a name="line481"></a>    val <a href="#MAP_EQ_f-val">MAP_EQ_f</a> : thm
<a name="line482"></a>    val <a href="#MAP_FILTER-val">MAP_FILTER</a> : thm
<a name="line483"></a>    val <a href="#MAP_FLAT-val">MAP_FLAT</a> : thm
<a name="line484"></a>    val <a href="#MAP_FOLDL-val">MAP_FOLDL</a> : thm
<a name="line485"></a>    val <a href="#MAP_FOLDR-val">MAP_FOLDR</a> : thm
<a name="line486"></a>    val <a href="#MAP_FST_funs-val">MAP_FST_funs</a> : thm
<a name="line487"></a>    val <a href="#MAP_GENLIST-val">MAP_GENLIST</a> : thm
<a name="line488"></a>    val <a href="#MAP_HD-val">MAP_HD</a> : thm
<a name="line489"></a>    val <a href="#MAP_MAP_o-val">MAP_MAP_o</a> : thm
<a name="line490"></a>    val <a href="#MAP_REVERSE-val">MAP_REVERSE</a> : thm
<a name="line491"></a>    val <a href="#MAP_SING-val">MAP_SING</a> : thm
<a name="line492"></a>    val <a href="#MAP_SND_FILTER_NEQ-val">MAP_SND_FILTER_NEQ</a> : thm
<a name="line493"></a>    val <a href="#MAP_SNOC-val">MAP_SNOC</a> : thm
<a name="line494"></a>    val <a href="#MAP_SUBLIST-val">MAP_SUBLIST</a> : thm
<a name="line495"></a>    val <a href="#MAP_o-val">MAP_o</a> : thm
<a name="line496"></a>    val <a href="#MAX_LIST_CONS-val">MAX_LIST_CONS</a> : thm
<a name="line497"></a>    val <a href="#MAX_LIST_EQ_0-val">MAX_LIST_EQ_0</a> : thm
<a name="line498"></a>    val <a href="#MAX_LIST_LE-val">MAX_LIST_LE</a> : thm
<a name="line499"></a>    val <a href="#MAX_LIST_MAP_LE-val">MAX_LIST_MAP_LE</a> : thm
<a name="line500"></a>    val <a href="#MAX_LIST_MEM-val">MAX_LIST_MEM</a> : thm
<a name="line501"></a>    val <a href="#MAX_LIST_MONO_DEC-val">MAX_LIST_MONO_DEC</a> : thm
<a name="line502"></a>    val <a href="#MAX_LIST_MONO_INC-val">MAX_LIST_MONO_INC</a> : thm
<a name="line503"></a>    val <a href="#MAX_LIST_NIL-val">MAX_LIST_NIL</a> : thm
<a name="line504"></a>    val <a href="#MAX_LIST_PROPERTY-val">MAX_LIST_PROPERTY</a> : thm
<a name="line505"></a>    val <a href="#MAX_LIST_SING-val">MAX_LIST_SING</a> : thm
<a name="line506"></a>    val <a href="#MAX_LIST_TEST-val">MAX_LIST_TEST</a> : thm
<a name="line507"></a>    val <a href="#MEM_APPEND_3-val">MEM_APPEND_3</a> : thm
<a name="line508"></a>    val <a href="#MEM_BUTLASTN-val">MEM_BUTLASTN</a> : thm
<a name="line509"></a>    val <a href="#MEM_COUNT_LIST-val">MEM_COUNT_LIST</a> : thm
<a name="line510"></a>    val <a href="#MEM_DROP_IMP-val">MEM_DROP_IMP</a> : thm
<a name="line511"></a>    val <a href="#MEM_EXISTS-val">MEM_EXISTS</a> : thm
<a name="line512"></a>    val <a href="#MEM_FOLDL-val">MEM_FOLDL</a> : thm
<a name="line513"></a>    val <a href="#MEM_FOLDL_MAP-val">MEM_FOLDL_MAP</a> : thm
<a name="line514"></a>    val <a href="#MEM_FOLDR-val">MEM_FOLDR</a> : thm
<a name="line515"></a>    val <a href="#MEM_FOLDR_MAP-val">MEM_FOLDR_MAP</a> : thm
<a name="line516"></a>    val <a href="#MEM_FRONT-val">MEM_FRONT</a> : thm
<a name="line517"></a>    val <a href="#MEM_FRONT_NOT_LAST-val">MEM_FRONT_NOT_LAST</a> : thm
<a name="line518"></a>    val <a href="#MEM_FRONT_NOT_NIL-val">MEM_FRONT_NOT_NIL</a> : thm
<a name="line519"></a>    val <a href="#MEM_LAST-val">MEM_LAST</a> : thm
<a name="line520"></a>    val <a href="#MEM_LASTN-val">MEM_LASTN</a> : thm
<a name="line521"></a>    val <a href="#MEM_LAST_FRONT-val">MEM_LAST_FRONT</a> : thm
<a name="line522"></a>    val <a href="#MEM_LAST_NOT_NIL-val">MEM_LAST_NOT_NIL</a> : thm
<a name="line523"></a>    val <a href="#MEM_REPLICATE-val">MEM_REPLICATE</a> : thm
<a name="line524"></a>    val <a href="#MEM_SEG-val">MEM_SEG</a> : thm
<a name="line525"></a>    val <a href="#MEM_SING_APPEND-val">MEM_SING_APPEND</a> : thm
<a name="line526"></a>    val <a href="#MEM_SPLIT_APPEND_distinct-val">MEM_SPLIT_APPEND_distinct</a> : thm
<a name="line527"></a>    val <a href="#MEM_SPLIT_TAKE_DROP_distinct-val">MEM_SPLIT_TAKE_DROP_distinct</a> : thm
<a name="line528"></a>    val <a href="#MEM_SPLIT_TAKE_DROP_first-val">MEM_SPLIT_TAKE_DROP_first</a> : thm
<a name="line529"></a>    val <a href="#MEM_SPLIT_TAKE_DROP_last-val">MEM_SPLIT_TAKE_DROP_last</a> : thm
<a name="line530"></a>    val <a href="#MEM_TAKE-val">MEM_TAKE</a> : thm
<a name="line531"></a>    val <a href="#MIN_LIST_CONS-val">MIN_LIST_CONS</a> : thm
<a name="line532"></a>    val <a href="#MIN_LIST_LE-val">MIN_LIST_LE</a> : thm
<a name="line533"></a>    val <a href="#MIN_LIST_LE_MAX_LIST-val">MIN_LIST_LE_MAX_LIST</a> : thm
<a name="line534"></a>    val <a href="#MIN_LIST_MAP_LE-val">MIN_LIST_MAP_LE</a> : thm
<a name="line535"></a>    val <a href="#MIN_LIST_MEM-val">MIN_LIST_MEM</a> : thm
<a name="line536"></a>    val <a href="#MIN_LIST_MONO_DEC-val">MIN_LIST_MONO_DEC</a> : thm
<a name="line537"></a>    val <a href="#MIN_LIST_MONO_INC-val">MIN_LIST_MONO_INC</a> : thm
<a name="line538"></a>    val <a href="#MIN_LIST_PROPERTY-val">MIN_LIST_PROPERTY</a> : thm
<a name="line539"></a>    val <a href="#MIN_LIST_SING-val">MIN_LIST_SING</a> : thm
<a name="line540"></a>    val <a href="#MIN_LIST_TEST-val">MIN_LIST_TEST</a> : thm
<a name="line541"></a>    val <a href="#MONOID_APPEND_NIL-val">MONOID_APPEND_NIL</a> : thm
<a name="line542"></a>    val <a href="#MONOLIST_EQ-val">MONOLIST_EQ</a> : thm
<a name="line543"></a>    val <a href="#MONOLIST_SET_SING-val">MONOLIST_SET_SING</a> : thm
<a name="line544"></a>    val <a href="#MONO_DEC_CONS-val">MONO_DEC_CONS</a> : thm
<a name="line545"></a>    val <a href="#MONO_DEC_HD-val">MONO_DEC_HD</a> : thm
<a name="line546"></a>    val <a href="#MONO_DEC_NIL-val">MONO_DEC_NIL</a> : thm
<a name="line547"></a>    val <a href="#MONO_INC_CONS-val">MONO_INC_CONS</a> : thm
<a name="line548"></a>    val <a href="#MONO_INC_HD-val">MONO_INC_HD</a> : thm
<a name="line549"></a>    val <a href="#MONO_INC_NIL-val">MONO_INC_NIL</a> : thm
<a name="line550"></a>    val <a href="#NIL_IN_common_prefixes-val">NIL_IN_common_prefixes</a> : thm
<a name="line551"></a>    val <a href="#NIL_NO_MEM-val">NIL_NO_MEM</a> : thm
<a name="line552"></a>    val <a href="#NON_MONO_TAIL_PROPERTY-val">NON_MONO_TAIL_PROPERTY</a> : thm
<a name="line553"></a>    val <a href="#NOT_ALL_EL_SOME_EL-val">NOT_ALL_EL_SOME_EL</a> : thm
<a name="line554"></a>    val <a href="#NOT_CONS_NIL-val">NOT_CONS_NIL</a> : thm
<a name="line555"></a>    val <a href="#NOT_EQ_LIST-val">NOT_EQ_LIST</a> : thm
<a name="line556"></a>    val <a href="#NOT_IN_DELETE_ELEMENT-val">NOT_IN_DELETE_ELEMENT</a> : thm
<a name="line557"></a>    val <a href="#NOT_NIL_CONS-val">NOT_NIL_CONS</a> : thm
<a name="line558"></a>    val <a href="#NOT_NIL_SNOC-val">NOT_NIL_SNOC</a> : thm
<a name="line559"></a>    val <a href="#NOT_NULL_SNOC-val">NOT_NULL_SNOC</a> : thm
<a name="line560"></a>    val <a href="#NOT_SNOC_NIL-val">NOT_SNOC_NIL</a> : thm
<a name="line561"></a>    val <a href="#NOT_SOME_EL_ALL_EL-val">NOT_SOME_EL_ALL_EL</a> : thm
<a name="line562"></a>    val <a href="#NULL-val">NULL</a> : thm
<a name="line563"></a>    val <a href="#NULL_DEF-val">NULL_DEF</a> : thm
<a name="line564"></a>    val <a href="#NULL_EQ_NIL-val">NULL_EQ_NIL</a> : thm
<a name="line565"></a>    val <a href="#NULL_FOLDL-val">NULL_FOLDL</a> : thm
<a name="line566"></a>    val <a href="#NULL_FOLDR-val">NULL_FOLDR</a> : thm
<a name="line567"></a>    val <a href="#OR_EL_FOLDL-val">OR_EL_FOLDL</a> : thm
<a name="line568"></a>    val <a href="#OR_EL_FOLDR-val">OR_EL_FOLDR</a> : thm
<a name="line569"></a>    val <a href="#PREFIX-val">PREFIX</a> : thm
<a name="line570"></a>    val <a href="#PREFIX_FOLDR-val">PREFIX_FOLDR</a> : thm
<a name="line571"></a>    val <a href="#REPLICATE_APPEND-val">REPLICATE_APPEND</a> : thm
<a name="line572"></a>    val <a href="#REPLICATE_EQ_CONS-val">REPLICATE_EQ_CONS</a> : thm
<a name="line573"></a>    val <a href="#REPLICATE_GENLIST-val">REPLICATE_GENLIST</a> : thm
<a name="line574"></a>    val <a href="#REPLICATE_NIL-val">REPLICATE_NIL</a> : thm
<a name="line575"></a>    val <a href="#REPLICATE_compute-val">REPLICATE_compute</a> : thm
<a name="line576"></a>    val <a href="#REVERSE_APPEND-val">REVERSE_APPEND</a> : thm
<a name="line577"></a>    val <a href="#REVERSE_DROP-val">REVERSE_DROP</a> : thm
<a name="line578"></a>    val <a href="#REVERSE_EQ_NIL-val">REVERSE_EQ_NIL</a> : thm
<a name="line579"></a>    val <a href="#REVERSE_FLAT-val">REVERSE_FLAT</a> : thm
<a name="line580"></a>    val <a href="#REVERSE_FOLDL-val">REVERSE_FOLDL</a> : thm
<a name="line581"></a>    val <a href="#REVERSE_FOLDR-val">REVERSE_FOLDR</a> : thm
<a name="line582"></a>    val <a href="#REVERSE_HD-val">REVERSE_HD</a> : thm
<a name="line583"></a>    val <a href="#REVERSE_REPLICATE-val">REVERSE_REPLICATE</a> : thm
<a name="line584"></a>    val <a href="#REVERSE_REVERSE-val">REVERSE_REVERSE</a> : thm
<a name="line585"></a>    val <a href="#REVERSE_SING-val">REVERSE_SING</a> : thm
<a name="line586"></a>    val <a href="#REVERSE_SNOC-val">REVERSE_SNOC</a> : thm
<a name="line587"></a>    val <a href="#REVERSE_TL-val">REVERSE_TL</a> : thm
<a name="line588"></a>    val <a href="#REVERSE_ZIP-val">REVERSE_ZIP</a> : thm
<a name="line589"></a>    val <a href="#SEG1-val">SEG1</a> : thm
<a name="line590"></a>    val <a href="#SEG_0_SNOC-val">SEG_0_SNOC</a> : thm
<a name="line591"></a>    val <a href="#SEG_APPEND-val">SEG_APPEND</a> : thm
<a name="line592"></a>    val <a href="#SEG_APPEND1-val">SEG_APPEND1</a> : thm
<a name="line593"></a>    val <a href="#SEG_APPEND2-val">SEG_APPEND2</a> : thm
<a name="line594"></a>    val <a href="#SEG_CONS-val">SEG_CONS</a> : thm
<a name="line595"></a>    val <a href="#SEG_LASTN_BUTLASTN-val">SEG_LASTN_BUTLASTN</a> : thm
<a name="line596"></a>    val <a href="#SEG_LENGTH_ID-val">SEG_LENGTH_ID</a> : thm
<a name="line597"></a>    val <a href="#SEG_LENGTH_SNOC-val">SEG_LENGTH_SNOC</a> : thm
<a name="line598"></a>    val <a href="#SEG_REVERSE-val">SEG_REVERSE</a> : thm
<a name="line599"></a>    val <a href="#SEG_SEG-val">SEG_SEG</a> : thm
<a name="line600"></a>    val <a href="#SEG_SNOC-val">SEG_SNOC</a> : thm
<a name="line601"></a>    val <a href="#SEG_SUC_CONS-val">SEG_SUC_CONS</a> : thm
<a name="line602"></a>    val <a href="#SEG_SUC_EL-val">SEG_SUC_EL</a> : thm
<a name="line603"></a>    val <a href="#SEG_TAKE_DROP-val">SEG_TAKE_DROP</a> : thm
<a name="line604"></a>    val <a href="#SEG_compute-val">SEG_compute</a> : thm
<a name="line605"></a>    val <a href="#SING_LIST_TO_SET-val">SING_LIST_TO_SET</a> : thm
<a name="line606"></a>    val <a href="#SNOC-val">SNOC</a> : thm
<a name="line607"></a>    val <a href="#SNOC_11-val">SNOC_11</a> : thm
<a name="line608"></a>    val <a href="#SNOC_ACYCLIC-val">SNOC_ACYCLIC</a> : thm
<a name="line609"></a>    val <a href="#SNOC_APPEND-val">SNOC_APPEND</a> : thm
<a name="line610"></a>    val <a href="#SNOC_Axiom-val">SNOC_Axiom</a> : thm
<a name="line611"></a>    val <a href="#SNOC_CASES-val">SNOC_CASES</a> : thm
<a name="line612"></a>    val <a href="#SNOC_EL_FIRSTN-val">SNOC_EL_FIRSTN</a> : thm
<a name="line613"></a>    val <a href="#SNOC_EL_TAKE-val">SNOC_EL_TAKE</a> : thm
<a name="line614"></a>    val <a href="#SNOC_EQ_LENGTH_EQ-val">SNOC_EQ_LENGTH_EQ</a> : thm
<a name="line615"></a>    val <a href="#SNOC_FOLDR-val">SNOC_FOLDR</a> : thm
<a name="line616"></a>    val <a href="#SNOC_INDUCT-val">SNOC_INDUCT</a> : thm
<a name="line617"></a>    val <a href="#SNOC_LASTN-val">SNOC_LASTN</a> : thm
<a name="line618"></a>    val <a href="#SNOC_LAST_FRONT'-val">SNOC_LAST_FRONT'</a> : thm
<a name="line619"></a>    val <a href="#SNOC_REPLICATE-val">SNOC_REPLICATE</a> : thm
<a name="line620"></a>    val <a href="#SNOC_REVERSE_CONS-val">SNOC_REVERSE_CONS</a> : thm
<a name="line621"></a>    val <a href="#SOME_EL-val">SOME_EL</a> : thm
<a name="line622"></a>    val <a href="#SOME_EL_APPEND-val">SOME_EL_APPEND</a> : thm
<a name="line623"></a>    val <a href="#SOME_EL_BUTFIRSTN-val">SOME_EL_BUTFIRSTN</a> : thm
<a name="line624"></a>    val <a href="#SOME_EL_BUTLASTN-val">SOME_EL_BUTLASTN</a> : thm
<a name="line625"></a>    val <a href="#SOME_EL_DISJ-val">SOME_EL_DISJ</a> : thm
<a name="line626"></a>    val <a href="#SOME_EL_FIRSTN-val">SOME_EL_FIRSTN</a> : thm
<a name="line627"></a>    val <a href="#SOME_EL_FOLDL-val">SOME_EL_FOLDL</a> : thm
<a name="line628"></a>    val <a href="#SOME_EL_FOLDL_MAP-val">SOME_EL_FOLDL_MAP</a> : thm
<a name="line629"></a>    val <a href="#SOME_EL_FOLDR-val">SOME_EL_FOLDR</a> : thm
<a name="line630"></a>    val <a href="#SOME_EL_FOLDR_MAP-val">SOME_EL_FOLDR_MAP</a> : thm
<a name="line631"></a>    val <a href="#SOME_EL_LASTN-val">SOME_EL_LASTN</a> : thm
<a name="line632"></a>    val <a href="#SOME_EL_MAP-val">SOME_EL_MAP</a> : thm
<a name="line633"></a>    val <a href="#SOME_EL_REVERSE-val">SOME_EL_REVERSE</a> : thm
<a name="line634"></a>    val <a href="#SOME_EL_SEG-val">SOME_EL_SEG</a> : thm
<a name="line635"></a>    val <a href="#SOME_EL_SNOC-val">SOME_EL_SNOC</a> : thm
<a name="line636"></a>    val <a href="#SPLITP_APPEND-val">SPLITP_APPEND</a> : thm
<a name="line637"></a>    val <a href="#SPLITP_EVERY-val">SPLITP_EVERY</a> : thm
<a name="line638"></a>    val <a href="#SPLITP_IMP-val">SPLITP_IMP</a> : thm
<a name="line639"></a>    val <a href="#SPLITP_JOIN-val">SPLITP_JOIN</a> : thm
<a name="line640"></a>    val <a href="#SPLITP_LENGTH-val">SPLITP_LENGTH</a> : thm
<a name="line641"></a>    val <a href="#SPLITP_NIL_FST_IMP-val">SPLITP_NIL_FST_IMP</a> : thm
<a name="line642"></a>    val <a href="#SPLITP_NIL_SND_EVERY-val">SPLITP_NIL_SND_EVERY</a> : thm
<a name="line643"></a>    val <a href="#SPLITP_compute-val">SPLITP_compute</a> : thm
<a name="line644"></a>    val <a href="#SPLITP_splitAtPki-val">SPLITP_splitAtPki</a> : thm
<a name="line645"></a>    val <a href="#SUM-val">SUM</a> : thm
<a name="line646"></a>    val <a href="#SUM_APPEND-val">SUM_APPEND</a> : thm
<a name="line647"></a>    val <a href="#SUM_FLAT-val">SUM_FLAT</a> : thm
<a name="line648"></a>    val <a href="#SUM_FOLDL-val">SUM_FOLDL</a> : thm
<a name="line649"></a>    val <a href="#SUM_FOLDR-val">SUM_FOLDR</a> : thm
<a name="line650"></a>    val <a href="#SUM_IMAGE_count_MULT-val">SUM_IMAGE_count_MULT</a> : thm
<a name="line651"></a>    val <a href="#SUM_IMAGE_count_SUM_GENLIST-val">SUM_IMAGE_count_SUM_GENLIST</a> : thm
<a name="line652"></a>    val <a href="#SUM_REPLICATE-val">SUM_REPLICATE</a> : thm
<a name="line653"></a>    val <a href="#SUM_REVERSE-val">SUM_REVERSE</a> : thm
<a name="line654"></a>    val <a href="#SUM_SNOC-val">SUM_SNOC</a> : thm
<a name="line655"></a>    val <a href="#SUM_SUBLIST-val">SUM_SUBLIST</a> : thm
<a name="line656"></a>    val <a href="#TAIL_BY_DROP-val">TAIL_BY_DROP</a> : thm
<a name="line657"></a>    val <a href="#TAKE-val">TAKE</a> : thm
<a name="line658"></a>    val <a href="#TAKE_1_APPEND-val">TAKE_1_APPEND</a> : thm
<a name="line659"></a>    val <a href="#TAKE_APPEND-val">TAKE_APPEND</a> : thm
<a name="line660"></a>    val <a href="#TAKE_APPEND1-val">TAKE_APPEND1</a> : thm
<a name="line661"></a>    val <a href="#TAKE_APPEND2-val">TAKE_APPEND2</a> : thm
<a name="line662"></a>    val <a href="#TAKE_BUTLASTN-val">TAKE_BUTLASTN</a> : thm
<a name="line663"></a>    val <a href="#TAKE_DROP_SUC-val">TAKE_DROP_SUC</a> : thm
<a name="line664"></a>    val <a href="#TAKE_DROP_SWAP-val">TAKE_DROP_SWAP</a> : thm
<a name="line665"></a>    val <a href="#TAKE_EL_SNOC-val">TAKE_EL_SNOC</a> : thm
<a name="line666"></a>    val <a href="#TAKE_FRONT-val">TAKE_FRONT</a> : thm
<a name="line667"></a>    val <a href="#TAKE_LENGTH_APPEND-val">TAKE_LENGTH_APPEND</a> : thm
<a name="line668"></a>    val <a href="#TAKE_LENGTH_APPEND2-val">TAKE_LENGTH_APPEND2</a> : thm
<a name="line669"></a>    val <a href="#TAKE_PRE_LENGTH-val">TAKE_PRE_LENGTH</a> : thm
<a name="line670"></a>    val <a href="#TAKE_REVERSE-val">TAKE_REVERSE</a> : thm
<a name="line671"></a>    val <a href="#TAKE_SEG-val">TAKE_SEG</a> : thm
<a name="line672"></a>    val <a href="#TAKE_SEG_DROP-val">TAKE_SEG_DROP</a> : thm
<a name="line673"></a>    val <a href="#TAKE_SNOC-val">TAKE_SNOC</a> : thm
<a name="line674"></a>    val <a href="#TAKE_SUC-val">TAKE_SUC</a> : thm
<a name="line675"></a>    val <a href="#TAKE_SUC_BY_TAKE-val">TAKE_SUC_BY_TAKE</a> : thm
<a name="line676"></a>    val <a href="#TAKE_TAKE-val">TAKE_TAKE</a> : thm
<a name="line677"></a>    val <a href="#TAKE_TAKE_T-val">TAKE_TAKE_T</a> : thm
<a name="line678"></a>    val <a href="#TL-val">TL</a> : thm
<a name="line679"></a>    val <a href="#TL_DROP-val">TL_DROP</a> : thm
<a name="line680"></a>    val <a href="#TL_GENLIST-val">TL_GENLIST</a> : thm
<a name="line681"></a>    val <a href="#TL_SNOC-val">TL_SNOC</a> : thm
<a name="line682"></a>    val <a href="#UNIQUE_LIST_ELEM_COUNT-val">UNIQUE_LIST_ELEM_COUNT</a> : thm
<a name="line683"></a>    val <a href="#UNZIP-val">UNZIP</a> : thm
<a name="line684"></a>    val <a href="#UNZIP_SNOC-val">UNZIP_SNOC</a> : thm
<a name="line685"></a>    val <a href="#UNZIP_ZIP-val">UNZIP_ZIP</a> : thm
<a name="line686"></a>    val <a href="#ZIP-val">ZIP</a> : thm
<a name="line687"></a>    val <a href="#ZIP_APPEND-val">ZIP_APPEND</a> : thm
<a name="line688"></a>    val <a href="#ZIP_COUNT_LIST-val">ZIP_COUNT_LIST</a> : thm
<a name="line689"></a>    val <a href="#ZIP_FIRSTN-val">ZIP_FIRSTN</a> : thm
<a name="line690"></a>    val <a href="#ZIP_FIRSTN_LEQ-val">ZIP_FIRSTN_LEQ</a> : thm
<a name="line691"></a>    val <a href="#ZIP_GENLIST-val">ZIP_GENLIST</a> : thm
<a name="line692"></a>    val <a href="#ZIP_MAP_MAP-val">ZIP_MAP_MAP</a> : thm
<a name="line693"></a>    val <a href="#ZIP_SNOC-val">ZIP_SNOC</a> : thm
<a name="line694"></a>    val <a href="#ZIP_TAKE-val">ZIP_TAKE</a> : thm
<a name="line695"></a>    val <a href="#ZIP_TAKE_LEQ-val">ZIP_TAKE_LEQ</a> : thm
<a name="line696"></a>    val <a href="#ZIP_UNZIP-val">ZIP_UNZIP</a> : thm
<a name="line697"></a>    val <a href="#all_distinct_count_list-val">all_distinct_count_list</a> : thm
<a name="line698"></a>    val <a href="#all_distinct_list_el_inj-val">all_distinct_list_el_inj</a> : thm
<a name="line699"></a>    val <a href="#chunks_0-val">chunks_0</a> : thm
<a name="line700"></a>    val <a href="#chunks_MAP-val">chunks_MAP</a> : thm
<a name="line701"></a>    val <a href="#chunks_NIL-val">chunks_NIL</a> : thm
<a name="line702"></a>    val <a href="#chunks_TAKE-val">chunks_TAKE</a> : thm
<a name="line703"></a>    val <a href="#chunks_ZIP-val">chunks_ZIP</a> : thm
<a name="line704"></a>    val <a href="#chunks_append_divides-val">chunks_append_divides</a> : thm
<a name="line705"></a>    val <a href="#chunks_def-val">chunks_def</a> : thm
<a name="line706"></a>    val <a href="#chunks_ind-val">chunks_ind</a> : thm
<a name="line707"></a>    val <a href="#chunks_length-val">chunks_length</a> : thm
<a name="line708"></a>    val <a href="#chunks_not_nil-val">chunks_not_nil</a> : thm
<a name="line709"></a>    val <a href="#chunks_tr_aux_def-val">chunks_tr_aux_def</a> : thm
<a name="line710"></a>    val <a href="#chunks_tr_aux_ind-val">chunks_tr_aux_ind</a> : thm
<a name="line711"></a>    val <a href="#chunks_tr_aux_thm-val">chunks_tr_aux_thm</a> : thm
<a name="line712"></a>    val <a href="#chunks_tr_thm-val">chunks_tr_thm</a> : thm
<a name="line713"></a>    val <a href="#common_prefixes_BIGINTER-val">common_prefixes_BIGINTER</a> : thm
<a name="line714"></a>    val <a href="#common_prefixes_NIL-val">common_prefixes_NIL</a> : thm
<a name="line715"></a>    val <a href="#common_prefixes_NONEMPTY-val">common_prefixes_NONEMPTY</a> : thm
<a name="line716"></a>    val <a href="#common_prefixes_PAIR-val">common_prefixes_PAIR</a> : thm
<a name="line717"></a>    val <a href="#count_list_sub1-val">count_list_sub1</a> : thm
<a name="line718"></a>    val <a href="#divides_EVERY_LENGTH_chunks-val">divides_EVERY_LENGTH_chunks</a> : thm
<a name="line719"></a>    val <a href="#el_map_count-val">el_map_count</a> : thm
<a name="line720"></a>    val <a href="#every_count_list-val">every_count_list</a> : thm
<a name="line721"></a>    val <a href="#is_prefix_el-val">is_prefix_el</a> : thm
<a name="line722"></a>    val <a href="#list_rel_butlastn-val">list_rel_butlastn</a> : thm
<a name="line723"></a>    val <a href="#list_rel_lastn-val">list_rel_lastn</a> : thm
<a name="line724"></a>    val <a href="#list_to_set_eq_el_image-val">list_to_set_eq_el_image</a> : thm
<a name="line725"></a>    val <a href="#longest_prefix_EMPTY-val">longest_prefix_EMPTY</a> : thm
<a name="line726"></a>    val <a href="#longest_prefix_NIL-val">longest_prefix_NIL</a> : thm
<a name="line727"></a>    val <a href="#longest_prefix_PAIR-val">longest_prefix_PAIR</a> : thm
<a name="line728"></a>    val <a href="#longest_prefix_SING-val">longest_prefix_SING</a> : thm
<a name="line729"></a>    val <a href="#longest_prefix_UNIQUE-val">longest_prefix_UNIQUE</a> : thm
<a name="line730"></a>    val <a href="#map_replicate-val">map_replicate</a> : thm
<a name="line731"></a>    val <a href="#nub_GENLIST-val">nub_GENLIST</a> : thm
<a name="line732"></a>    val <a href="#prefixes_is_prefix_total-val">prefixes_is_prefix_total</a> : thm
<a name="line733"></a>    val <a href="#set_list_eq_count-val">set_list_eq_count</a> : thm
<a name="line734"></a>    val <a href="#sublist_ALL_DISTINCT-val">sublist_ALL_DISTINCT</a> : thm
<a name="line735"></a>    val <a href="#sublist_MONO_DEC-val">sublist_MONO_DEC</a> : thm
<a name="line736"></a>    val <a href="#sublist_MONO_INC-val">sublist_MONO_INC</a> : thm
<a name="line737"></a>    val <a href="#sublist_antisym-val">sublist_antisym</a> : thm
<a name="line738"></a>    val <a href="#sublist_append_extend-val">sublist_append_extend</a> : thm
<a name="line739"></a>    val <a href="#sublist_append_if-val">sublist_append_if</a> : thm
<a name="line740"></a>    val <a href="#sublist_append_iff-val">sublist_append_iff</a> : thm
<a name="line741"></a>    val <a href="#sublist_append_include-val">sublist_append_include</a> : thm
<a name="line742"></a>    val <a href="#sublist_append_only_if-val">sublist_append_only_if</a> : thm
<a name="line743"></a>    val <a href="#sublist_append_pair-val">sublist_append_pair</a> : thm
<a name="line744"></a>    val <a href="#sublist_append_prefix-val">sublist_append_prefix</a> : thm
<a name="line745"></a>    val <a href="#sublist_append_remove-val">sublist_append_remove</a> : thm
<a name="line746"></a>    val <a href="#sublist_append_suffix-val">sublist_append_suffix</a> : thm
<a name="line747"></a>    val <a href="#sublist_cons-val">sublist_cons</a> : thm
<a name="line748"></a>    val <a href="#sublist_cons_eq-val">sublist_cons_eq</a> : thm
<a name="line749"></a>    val <a href="#sublist_cons_include-val">sublist_cons_include</a> : thm
<a name="line750"></a>    val <a href="#sublist_cons_remove-val">sublist_cons_remove</a> : thm
<a name="line751"></a>    val <a href="#sublist_def-val">sublist_def</a> : thm
<a name="line752"></a>    val <a href="#sublist_drop-val">sublist_drop</a> : thm
<a name="line753"></a>    val <a href="#sublist_every-val">sublist_every</a> : thm
<a name="line754"></a>    val <a href="#sublist_front-val">sublist_front</a> : thm
<a name="line755"></a>    val <a href="#sublist_head_sing-val">sublist_head_sing</a> : thm
<a name="line756"></a>    val <a href="#sublist_ind-val">sublist_ind</a> : thm
<a name="line757"></a>    val <a href="#sublist_induct-val">sublist_induct</a> : thm
<a name="line758"></a>    val <a href="#sublist_last_sing-val">sublist_last_sing</a> : thm
<a name="line759"></a>    val <a href="#sublist_length-val">sublist_length</a> : thm
<a name="line760"></a>    val <a href="#sublist_mem-val">sublist_mem</a> : thm
<a name="line761"></a>    val <a href="#sublist_member_sing-val">sublist_member_sing</a> : thm
<a name="line762"></a>    val <a href="#sublist_nil-val">sublist_nil</a> : thm
<a name="line763"></a>    val <a href="#sublist_of_nil-val">sublist_of_nil</a> : thm
<a name="line764"></a>    val <a href="#sublist_order-val">sublist_order</a> : thm
<a name="line765"></a>    val <a href="#sublist_prefix-val">sublist_prefix</a> : thm
<a name="line766"></a>    val <a href="#sublist_prefix_nil-val">sublist_prefix_nil</a> : thm
<a name="line767"></a>    val <a href="#sublist_refl-val">sublist_refl</a> : thm
<a name="line768"></a>    val <a href="#sublist_snoc-val">sublist_snoc</a> : thm
<a name="line769"></a>    val <a href="#sublist_subset-val">sublist_subset</a> : thm
<a name="line770"></a>    val <a href="#sublist_suffix-val">sublist_suffix</a> : thm
<a name="line771"></a>    val <a href="#sublist_tail-val">sublist_tail</a> : thm
<a name="line772"></a>    val <a href="#sublist_take-val">sublist_take</a> : thm
<a name="line773"></a>    val <a href="#sublist_trans-val">sublist_trans</a> : thm
<a name="line774"></a>    val <a href="#sum_of_sums-val">sum_of_sums</a> : thm
<a name="line775"></a>    val <a href="#take_drop_partition-val">take_drop_partition</a> : thm
<a name="line776"></a>    val <a href="#two_common_prefixes-val">two_common_prefixes</a> : thm
<a name="line777"></a>(*
   [list] Parent theory of "rich_list"
   
   [<a name="AND_EL_DEF-val"><b>AND_EL_DEF</b></a>]  Definition
      
       AND_EL = EVERY I
   
   [<a name="BUTLASTN_def-val"><b>BUTLASTN_def</b></a>]  Definition
      
       n xs. BUTLASTN n xs = REVERSE (DROP n (REVERSE xs))
   
   [<a name="COUNT_LIST_AUX_def-val"><b>COUNT_LIST_AUX_def</b></a>]  Definition
      
       (l. COUNT_LIST_AUX 0 l = l) 
        n l. COUNT_LIST_AUX (SUC n) l = COUNT_LIST_AUX n (n::l)
   
   [<a name="COUNT_LIST_def-val"><b>COUNT_LIST_def</b></a>]  Definition
      
       COUNT_LIST 0 = [] 
        n. COUNT_LIST (SUC n) = 0::MAP SUC (COUNT_LIST n)
   
   [<a name="DELETE_ELEMENT-val"><b>DELETE_ELEMENT</b></a>]  Definition
      
       (e. DELETE_ELEMENT e [] = []) 
        e x l.
          DELETE_ELEMENT e (x::l) =
          if e = x then DELETE_ELEMENT e l else x::DELETE_ELEMENT e l
   
   [<a name="ELL-val"><b>ELL</b></a>]  Definition
      
       (l. ELL 0 l = LAST l)  n l. ELL (SUC n) l = ELL n (FRONT l)
   
   [<a name="IS_SUBLIST-val"><b>IS_SUBLIST</b></a>]  Definition
      
       (l. IS_SUBLIST l []  T)  (x l. IS_SUBLIST [] (x::l)  F) 
        x1 l1 x2 l2.
          IS_SUBLIST (x1::l1) (x2::l2) 
          x1 = x2  l2  l1  IS_SUBLIST l1 (x2::l2)
   
   [<a name="IS_SUFFIX-val"><b>IS_SUFFIX</b></a>]  Definition
      
       (l. IS_SUFFIX l []  T)  (x l. IS_SUFFIX [] (SNOC x l)  F) 
        x1 l1 x2 l2.
          IS_SUFFIX (SNOC x1 l1) (SNOC x2 l2)  x1 = x2  IS_SUFFIX l1 l2
   
   [<a name="LASTN_def-val"><b>LASTN_def</b></a>]  Definition
      
       n xs. LASTN n xs = REVERSE (TAKE n (REVERSE xs))
   
   [<a name="LIST_ELEM_COUNT_DEF-val"><b>LIST_ELEM_COUNT_DEF</b></a>]  Definition
      
       e l. LIST_ELEM_COUNT e l = LENGTH (FILTER (x. x = e) l)
   
   [<a name="MAX_LIST_def-val"><b>MAX_LIST_def</b></a>]  Definition
      
       MAX_LIST [] = 0  h t. MAX_LIST (h::t) = MAX h (MAX_LIST t)
   
   [<a name="MIN_LIST_def-val"><b>MIN_LIST_def</b></a>]  Definition
      
       h t. MIN_LIST (h::t) = if t = [] then h else MIN h (MIN_LIST t)
   
   [<a name="OR_EL_DEF-val"><b>OR_EL_DEF</b></a>]  Definition
      
       OR_EL = EXISTS I
   
   [<a name="PREFIX_DEF-val"><b>PREFIX_DEF</b></a>]  Definition
      
       P l. PREFIX P l = FST (SPLITP ($  P) l)
   
   [<a name="REPLICATE-val"><b>REPLICATE</b></a>]  Definition
      
       (x. REPLICATE 0 x = []) 
        n x. REPLICATE (SUC n) x = x::REPLICATE n x
   
   [<a name="SCANL-val"><b>SCANL</b></a>]  Definition
      
       (f e. SCANL f e [] = [e]) 
        f e x l. SCANL f e (x::l) = e::SCANL f (f e x) l
   
   [<a name="SCANR-val"><b>SCANR</b></a>]  Definition
      
       (f e. SCANR f e [] = [e]) 
        f e x l. SCANR f e (x::l) = f x (HD (SCANR f e l))::SCANR f e l
   
   [<a name="SEG-val"><b>SEG</b></a>]  Definition
      
       (k l. SEG 0 k l = []) 
        (m x l. SEG (SUC m) 0 (x::l) = x::SEG m 0 l) 
        m k x l. SEG (SUC m) (SUC k) (x::l) = SEG (SUC m) k l
   
   [<a name="SPLITL_def-val"><b>SPLITL_def</b></a>]  Definition
      
       P. SPLITL P = SPLITP ($  P)
   
   [<a name="SPLITP-val"><b>SPLITP</b></a>]  Definition
      
       (P. SPLITP P [] = ([],[])) 
        P x l.
          SPLITP P (x::l) =
          if P x then ([],x::l) else (x::FST (SPLITP P l),SND (SPLITP P l))
   
   [<a name="SPLITP_AUX_def-val"><b>SPLITP_AUX_def</b></a>]  Definition
      
       (acc P. SPLITP_AUX acc P [] = (acc,[])) 
        acc P h t.
          SPLITP_AUX acc P (h::t) =
          if P h then (acc,h::t) else SPLITP_AUX (acc  [h]) P t
   
   [<a name="SPLITR_def-val"><b>SPLITR_def</b></a>]  Definition
      
       P l.
          SPLITR P l =
          (let
             (a,b) = SPLITP ($  P) (REVERSE l)
           in
             (REVERSE b,REVERSE a))
   
   [<a name="SUFFIX_DEF-val"><b>SUFFIX_DEF</b></a>]  Definition
      
       P l.
          SUFFIX P l = FOLDL (l' x. if P x then SNOC x l' else []) [] l
   
   [<a name="TL_T_def-val"><b>TL_T_def</b></a>]  Definition
      
       TL_T [] = []  h t. TL_T (h::t) = t
   
   [<a name="UNZIP_FST_DEF-val"><b>UNZIP_FST_DEF</b></a>]  Definition
      
       l. UNZIP_FST l = FST (UNZIP l)
   
   [<a name="UNZIP_SND_DEF-val"><b>UNZIP_SND_DEF</b></a>]  Definition
      
       l. UNZIP_SND l = SND (UNZIP l)
   
   [<a name="chunks_tr_def-val"><b>chunks_tr_def</b></a>]  Definition
      
       n ls.
          chunks_tr n ls =
          if n = 0 then [ls] else chunks_tr_aux (n  1) ls []
   
   [<a name="common_prefixes_def-val"><b>common_prefixes_def</b></a>]  Definition
      
       s. common_prefixes s = {p | m. m  s  p  m}
   
   [<a name="longest_prefix_def-val"><b>longest_prefix_def</b></a>]  Definition
      
       s. longest_prefix s =
            if s =  then []
            else @x. is_measure_maximal LENGTH (common_prefixes s) x
   
   [<a name="ALL_DISTINCT_APPEND_3-val"><b>ALL_DISTINCT_APPEND_3</b></a>]  Theorem
      
       l1 x l2.
          ALL_DISTINCT (l1  [x]  l2)  ALL_DISTINCT (x::(l1  l2))
   
   [<a name="ALL_DISTINCT_EL_APPEND-val"><b>ALL_DISTINCT_EL_APPEND</b></a>]  Theorem
      
       ls l1 l2 j.
          ALL_DISTINCT ls  j &lt; LENGTH ls  ls = l1  [EL j ls]  l2 
          j = LENGTH l1
   
   [<a name="ALL_DISTINCT_FRONT-val"><b>ALL_DISTINCT_FRONT</b></a>]  Theorem
      
       l. l  []  ALL_DISTINCT l  ALL_DISTINCT (FRONT l)
   
   [<a name="ALL_DISTINCT_LAST_EL_IFF-val"><b>ALL_DISTINCT_LAST_EL_IFF</b></a>]  Theorem
      
       ls j.
          ALL_DISTINCT ls  ls  []  j &lt; LENGTH ls 
          (EL j ls = LAST ls  j + 1 = LENGTH ls)
   
   [<a name="ALL_DISTINCT_MEM_ZIP_MAP-val"><b>ALL_DISTINCT_MEM_ZIP_MAP</b></a>]  Theorem
      
       f x ls.
          ALL_DISTINCT ls 
          (MEM x (ZIP (ls,MAP f ls))  MEM (FST x) ls  SND x = f (FST x))
   
   [<a name="ALL_DISTINCT_SNOC-val"><b>ALL_DISTINCT_SNOC</b></a>]  Theorem
      
       x l. ALL_DISTINCT (SNOC x l)  MEM x l  ALL_DISTINCT l
   
   [<a name="ALL_DISTINCT_SWAP-val"><b>ALL_DISTINCT_SWAP</b></a>]  Theorem
      
       ls x y. ALL_DISTINCT (x::y::ls)  ALL_DISTINCT (y::x::ls)
   
   [<a name="ALL_DISTINCT_TAKE-val"><b>ALL_DISTINCT_TAKE</b></a>]  Theorem
      
       ls n. ALL_DISTINCT ls  ALL_DISTINCT (TAKE n ls)
   
   [<a name="ALL_DISTINCT_TAKE_DROP-val"><b>ALL_DISTINCT_TAKE_DROP</b></a>]  Theorem
      
       ls.
          ALL_DISTINCT ls  k e. MEM e (TAKE k ls)  MEM e (DROP k ls)  F
   
   [<a name="ALL_EL-val"><b>ALL_EL</b></a>]  Theorem
      
       (P. EVERY P []  T)  P h t. EVERY P (h::t)  P h  EVERY P t
   
   [<a name="ALL_EL_APPEND-val"><b>ALL_EL_APPEND</b></a>]  Theorem
      
       P l1 l2. EVERY P (l1  l2)  EVERY P l1  EVERY P l2
   
   [<a name="ALL_EL_BUTFIRSTN-val"><b>ALL_EL_BUTFIRSTN</b></a>]  Theorem
      
       P l m. EVERY P l  EVERY P (DROP m l)
   
   [<a name="ALL_EL_BUTLASTN-val"><b>ALL_EL_BUTLASTN</b></a>]  Theorem
      
       P l m. EVERY P l  EVERY P (BUTLASTN m l)
   
   [<a name="ALL_EL_CONJ-val"><b>ALL_EL_CONJ</b></a>]  Theorem
      
       P Q l. EVERY (x. P x  Q x) l  EVERY P l  EVERY Q l
   
   [<a name="ALL_EL_FIRSTN-val"><b>ALL_EL_FIRSTN</b></a>]  Theorem
      
       P l m. EVERY P l  EVERY P (TAKE m l)
   
   [<a name="ALL_EL_FOLDL-val"><b>ALL_EL_FOLDL</b></a>]  Theorem
      
       P l. EVERY P l  FOLDL (l' x. l'  P x) T l
   
   [<a name="ALL_EL_FOLDL_MAP-val"><b>ALL_EL_FOLDL_MAP</b></a>]  Theorem
      
       P l. EVERY P l  FOLDL $/\ T (MAP P l)
   
   [<a name="ALL_EL_FOLDR-val"><b>ALL_EL_FOLDR</b></a>]  Theorem
      
       P l. EVERY P l  FOLDR (x l'. P x  l') T l
   
   [<a name="ALL_EL_FOLDR_MAP-val"><b>ALL_EL_FOLDR_MAP</b></a>]  Theorem
      
       P l. EVERY P l  FOLDR $/\ T (MAP P l)
   
   [<a name="ALL_EL_LASTN-val"><b>ALL_EL_LASTN</b></a>]  Theorem
      
       P l m. EVERY P l  EVERY P (LASTN m l)
   
   [<a name="ALL_EL_MAP-val"><b>ALL_EL_MAP</b></a>]  Theorem
      
       P f l. EVERY P (MAP f l)  EVERY (P  f) l
   
   [<a name="ALL_EL_REPLICATE-val"><b>ALL_EL_REPLICATE</b></a>]  Theorem
      
       f n x. EVERY f (REPLICATE n x)  n = 0  f x
   
   [<a name="ALL_EL_REVERSE-val"><b>ALL_EL_REVERSE</b></a>]  Theorem
      
       P l. EVERY P (REVERSE l)  EVERY P l
   
   [<a name="ALL_EL_SEG-val"><b>ALL_EL_SEG</b></a>]  Theorem
      
       P l. EVERY P l  m k. m + k  LENGTH l  EVERY P (SEG m k l)
   
   [<a name="ALL_EL_SNOC-val"><b>ALL_EL_SNOC</b></a>]  Theorem
      
       P x l. EVERY P (SNOC x l)  EVERY P l  P x
   
   [<a name="AND_EL_FOLDL-val"><b>AND_EL_FOLDL</b></a>]  Theorem
      
       l. AND_EL l  FOLDL $/\ T l
   
   [<a name="AND_EL_FOLDR-val"><b>AND_EL_FOLDR</b></a>]  Theorem
      
       l. AND_EL l  FOLDR $/\ T l
   
   [<a name="APPEND-val"><b>APPEND</b></a>]  Theorem
      
       (l. []  l = l)  l1 l2 h. h::l1  l2 = h::(l1  l2)
   
   [<a name="APPEND_11_LENGTH-val"><b>APPEND_11_LENGTH</b></a>]  Theorem
      
       (l1 l2 l1' l2'.
           LENGTH l1 = LENGTH l1' 
           (l1  l2 = l1'  l2'  l1 = l1'  l2 = l2')) 
        l1 l2 l1' l2'.
          LENGTH l2 = LENGTH l2' 
          (l1  l2 = l1'  l2'  l1 = l1'  l2 = l2')
   
   [<a name="APPEND_ASSOC-val"><b>APPEND_ASSOC</b></a>]  Theorem
      
       l1 l2 l3. l1  (l2  l3) = l1  l2  l3
   
   [<a name="APPEND_ASSOC_CONS-val"><b>APPEND_ASSOC_CONS</b></a>]  Theorem
      
       l1 h l2 l3. l1  h::l2  l3 = l1  h::(l2  l3)
   
   [<a name="APPEND_BUTLASTN_BUTFIRSTN-val"><b>APPEND_BUTLASTN_BUTFIRSTN</b></a>]  Theorem
      
       m n l. m + n = LENGTH l  BUTLASTN m l  DROP n l = l
   
   [<a name="APPEND_BUTLASTN_DROP-val"><b>APPEND_BUTLASTN_DROP</b></a>]  Theorem
      
       m n l. m + n = LENGTH l  BUTLASTN m l  DROP n l = l
   
   [<a name="APPEND_BUTLASTN_LASTN-val"><b>APPEND_BUTLASTN_LASTN</b></a>]  Theorem
      
       n l. n  LENGTH l  BUTLASTN n l  LASTN n l = l
   
   [<a name="APPEND_BUTLAST_LAST-val"><b>APPEND_BUTLAST_LAST</b></a>]  Theorem
      
       l. l  []  FRONT l  [LAST l] = l
   
   [<a name="APPEND_EQ_APPEND_EQ-val"><b>APPEND_EQ_APPEND_EQ</b></a>]  Theorem
      
       l1 l2 m1 m2.
          l1  l2 = m1  m2  LENGTH l1 = LENGTH m1  l1 = m1  l2 = m2
   
   [<a name="APPEND_FIRSTN_BUTFIRSTN-val"><b>APPEND_FIRSTN_BUTFIRSTN</b></a>]  Theorem
      
       n l. TAKE n l  DROP n l = l
   
   [<a name="APPEND_FIRSTN_LASTN-val"><b>APPEND_FIRSTN_LASTN</b></a>]  Theorem
      
       m n l. m + n = LENGTH l  TAKE n l  LASTN m l = l
   
   [<a name="APPEND_FOLDL-val"><b>APPEND_FOLDL</b></a>]  Theorem
      
       l1 l2. l1  l2 = FOLDL (l' x. SNOC x l') l1 l2
   
   [<a name="APPEND_FOLDR-val"><b>APPEND_FOLDR</b></a>]  Theorem
      
       l1 l2. l1  l2 = FOLDR CONS l2 l1
   
   [<a name="APPEND_LENGTH_EQ-val"><b>APPEND_LENGTH_EQ</b></a>]  Theorem
      
       l1 l1'.
          LENGTH l1 = LENGTH l1' 
          l2 l2'.
            LENGTH l2 = LENGTH l2' 
            (l1  l2 = l1'  l2'  l1 = l1'  l2 = l2')
   
   [<a name="APPEND_NIL-val"><b>APPEND_NIL</b></a>]  Theorem
      
       (l. l  [] = l)  l. []  l = l
   
   [<a name="APPEND_SNOC-val"><b>APPEND_SNOC</b></a>]  Theorem
      
       l1 x l2. l1  SNOC x l2 = SNOC x (l1  l2)
   
   [<a name="APPEND_SNOC1-val"><b>APPEND_SNOC1</b></a>]  Theorem
      
       l1 x l2. SNOC x l1  l2 = l1  x::l2
   
   [<a name="APPEND_TAKE_LASTN-val"><b>APPEND_TAKE_LASTN</b></a>]  Theorem
      
       m n l. m + n = LENGTH l  TAKE n l  LASTN m l = l
   
   [<a name="ASSOC_APPEND-val"><b>ASSOC_APPEND</b></a>]  Theorem
      
       ASSOC $++
   
   [<a name="ASSOC_FOLDL_FLAT-val"><b>ASSOC_FOLDL_FLAT</b></a>]  Theorem
      
       f. ASSOC f 
            e. RIGHT_ID f e 
                l. FOLDL f e (FLAT l) = FOLDL f e (MAP (FOLDL f e) l)
   
   [<a name="ASSOC_FOLDR_FLAT-val"><b>ASSOC_FOLDR_FLAT</b></a>]  Theorem
      
       f. ASSOC f 
            e. LEFT_ID f e 
                l. FOLDR f e (FLAT l) = FOLDR f e (MAP (FOLDR f e) l)
   
   [<a name="BUTFIRSTN-val"><b>BUTFIRSTN</b></a>]  Theorem
      
       (l. DROP 0 l = l)  n x l. DROP (SUC n) (x::l) = DROP n l
   
   [<a name="BUTFIRSTN_APPEND1-val"><b>BUTFIRSTN_APPEND1</b></a>]  Theorem
      
       n l1. n  LENGTH l1  l2. DROP n (l1  l2) = DROP n l1  l2
   
   [<a name="BUTFIRSTN_APPEND2-val"><b>BUTFIRSTN_APPEND2</b></a>]  Theorem
      
       l1 n.
          LENGTH l1  n  l2. DROP n (l1  l2) = DROP (n  LENGTH l1) l2
   
   [<a name="BUTFIRSTN_BUTFIRSTN-val"><b>BUTFIRSTN_BUTFIRSTN</b></a>]  Theorem
      
       n m l. n + m  LENGTH l  DROP n (DROP m l) = DROP (n + m) l
   
   [<a name="BUTFIRSTN_CONS_EL-val"><b>BUTFIRSTN_CONS_EL</b></a>]  Theorem
      
       n l. n &lt; LENGTH l  DROP n l = EL n l::DROP (SUC n) l
   
   [<a name="BUTFIRSTN_LASTN-val"><b>BUTFIRSTN_LASTN</b></a>]  Theorem
      
       n l. n  LENGTH l  DROP n l = LASTN (LENGTH l  n) l
   
   [<a name="BUTFIRSTN_LENGTH_APPEND-val"><b>BUTFIRSTN_LENGTH_APPEND</b></a>]  Theorem
      
       l1 l2. DROP (LENGTH l1) (l1  l2) = l2
   
   [<a name="BUTFIRSTN_LENGTH_NIL-val"><b>BUTFIRSTN_LENGTH_NIL</b></a>]  Theorem
      
       l. DROP (LENGTH l) l = []
   
   [<a name="BUTFIRSTN_REVERSE-val"><b>BUTFIRSTN_REVERSE</b></a>]  Theorem
      
       n l. n  LENGTH l  DROP n (REVERSE l) = REVERSE (BUTLASTN n l)
   
   [<a name="BUTFIRSTN_SEG-val"><b>BUTFIRSTN_SEG</b></a>]  Theorem
      
       n l. n  LENGTH l  DROP n l = SEG (LENGTH l  n) n l
   
   [<a name="BUTFIRSTN_SNOC-val"><b>BUTFIRSTN_SNOC</b></a>]  Theorem
      
       n l. n  LENGTH l  x. DROP n (SNOC x l) = SNOC x (DROP n l)
   
   [<a name="BUTLAST-val"><b>BUTLAST</b></a>]  Theorem
      
       x l. FRONT (SNOC x l) = l
   
   [<a name="BUTLASTN-val"><b>BUTLASTN</b></a>]  Theorem
      
       (l. BUTLASTN 0 l = l) 
        n x l. BUTLASTN (SUC n) (SNOC x l) = BUTLASTN n l
   
   [<a name="BUTLASTN_1-val"><b>BUTLASTN_1</b></a>]  Theorem
      
       l. l  []  BUTLASTN 1 l = FRONT l
   
   [<a name="BUTLASTN_APPEND1-val"><b>BUTLASTN_APPEND1</b></a>]  Theorem
      
       l2 n.
          LENGTH l2  n 
          l1. BUTLASTN n (l1  l2) = BUTLASTN (n  LENGTH l2) l1
   
   [<a name="BUTLASTN_APPEND2-val"><b>BUTLASTN_APPEND2</b></a>]  Theorem
      
       n l1 l2. n  LENGTH l2  BUTLASTN n (l1  l2) = l1  BUTLASTN n l2
   
   [<a name="BUTLASTN_BUTLAST-val"><b>BUTLASTN_BUTLAST</b></a>]  Theorem
      
       n l. n &lt; LENGTH l  BUTLASTN n (FRONT l) = FRONT (BUTLASTN n l)
   
   [<a name="BUTLASTN_BUTLASTN-val"><b>BUTLASTN_BUTLASTN</b></a>]  Theorem
      
       m n l.
          n + m  LENGTH l  BUTLASTN n (BUTLASTN m l) = BUTLASTN (n + m) l
   
   [<a name="BUTLASTN_CONS-val"><b>BUTLASTN_CONS</b></a>]  Theorem
      
       n l. n  LENGTH l  x. BUTLASTN n (x::l) = x::BUTLASTN n l
   
   [<a name="BUTLASTN_FIRSTN-val"><b>BUTLASTN_FIRSTN</b></a>]  Theorem
      
       n l. n  LENGTH l  BUTLASTN n l = TAKE (LENGTH l  n) l
   
   [<a name="BUTLASTN_FRONT-val"><b>BUTLASTN_FRONT</b></a>]  Theorem
      
       n l. n &lt; LENGTH l  BUTLASTN n (FRONT l) = FRONT (BUTLASTN n l)
   
   [<a name="BUTLASTN_LASTN-val"><b>BUTLASTN_LASTN</b></a>]  Theorem
      
       m n l.
          m  n  n  LENGTH l 
          BUTLASTN m (LASTN n l) = LASTN (n  m) (BUTLASTN m l)
   
   [<a name="BUTLASTN_LASTN_NIL-val"><b>BUTLASTN_LASTN_NIL</b></a>]  Theorem
      
       n l. n  LENGTH l  BUTLASTN n (LASTN n l) = []
   
   [<a name="BUTLASTN_LENGTH_APPEND-val"><b>BUTLASTN_LENGTH_APPEND</b></a>]  Theorem
      
       l2 l1. BUTLASTN (LENGTH l2) (l1  l2) = l1
   
   [<a name="BUTLASTN_LENGTH_CONS-val"><b>BUTLASTN_LENGTH_CONS</b></a>]  Theorem
      
       l x. BUTLASTN (LENGTH l) (x::l) = [x]
   
   [<a name="BUTLASTN_LENGTH_NIL-val"><b>BUTLASTN_LENGTH_NIL</b></a>]  Theorem
      
       l. BUTLASTN (LENGTH l) l = []
   
   [<a name="BUTLASTN_MAP-val"><b>BUTLASTN_MAP</b></a>]  Theorem
      
       n l.
          n  LENGTH l  f. BUTLASTN n (MAP f l) = MAP f (BUTLASTN n l)
   
   [<a name="BUTLASTN_REVERSE-val"><b>BUTLASTN_REVERSE</b></a>]  Theorem
      
       n l. n  LENGTH l  BUTLASTN n (REVERSE l) = REVERSE (DROP n l)
   
   [<a name="BUTLASTN_SEG-val"><b>BUTLASTN_SEG</b></a>]  Theorem
      
       n l. n  LENGTH l  BUTLASTN n l = SEG (LENGTH l  n) 0 l
   
   [<a name="BUTLASTN_SUC_BUTLAST-val"><b>BUTLASTN_SUC_BUTLAST</b></a>]  Theorem
      
       n l. n &lt; LENGTH l  BUTLASTN (SUC n) l = BUTLASTN n (FRONT l)
   
   [<a name="BUTLASTN_SUC_FRONT-val"><b>BUTLASTN_SUC_FRONT</b></a>]  Theorem
      
       n l. n &lt; LENGTH l  BUTLASTN (SUC n) l = BUTLASTN n (FRONT l)
   
   [<a name="BUTLASTN_TAKE-val"><b>BUTLASTN_TAKE</b></a>]  Theorem
      
       n l. n  LENGTH l  BUTLASTN n l = TAKE (LENGTH l  n) l
   
   [<a name="BUTLASTN_TAKE_UNCOND-val"><b>BUTLASTN_TAKE_UNCOND</b></a>]  Theorem
      
       n l. BUTLASTN n l = TAKE (LENGTH l  n) l
   
   [<a name="BUTLASTN_compute-val"><b>BUTLASTN_compute</b></a>]  Theorem
      
       n l.
          BUTLASTN n l =
          (let
             m = LENGTH l
           in
             if n  m then TAKE (m  n) l
             else FAIL BUTLASTN $var$(longer than list) n l)
   
   [<a name="BUTLAST_CONS-val"><b>BUTLAST_CONS</b></a>]  Theorem
      
       (x. FRONT [x] = [])  x y z. FRONT (x::y::z) = x::FRONT (y::z)
   
   [<a name="COMM_ASSOC_FOLDL_REVERSE-val"><b>COMM_ASSOC_FOLDL_REVERSE</b></a>]  Theorem
      
       f. COMM f  ASSOC f  e l. FOLDL f e (REVERSE l) = FOLDL f e l
   
   [<a name="COMM_ASSOC_FOLDR_REVERSE-val"><b>COMM_ASSOC_FOLDR_REVERSE</b></a>]  Theorem
      
       f. COMM f  ASSOC f  e l. FOLDR f e (REVERSE l) = FOLDR f e l
   
   [<a name="COMM_MONOID_FOLDL-val"><b>COMM_MONOID_FOLDL</b></a>]  Theorem
      
       f. COMM f 
            e'. MONOID f e'  e l. FOLDL f e l = f e (FOLDL f e' l)
   
   [<a name="COMM_MONOID_FOLDR-val"><b>COMM_MONOID_FOLDR</b></a>]  Theorem
      
       f. COMM f 
            e'. MONOID f e'  e l. FOLDR f e l = f e (FOLDR f e' l)
   
   [<a name="CONS-val"><b>CONS</b></a>]  Theorem
      
       l. NULL l  HD l::TL l = l
   
   [<a name="CONS_11-val"><b>CONS_11</b></a>]  Theorem
      
       a0 a1 a0' a1'. a0::a1 = a0'::a1'  a0 = a0'  a1 = a1'
   
   [<a name="CONS_APPEND-val"><b>CONS_APPEND</b></a>]  Theorem
      
       x l. x::l = [x]  l
   
   [<a name="COUNT_LIST_ADD-val"><b>COUNT_LIST_ADD</b></a>]  Theorem
      
       n m.
          COUNT_LIST (n + m) =
          COUNT_LIST n  MAP (n'. n' + n) (COUNT_LIST m)
   
   [<a name="COUNT_LIST_AUX_compute-val"><b>COUNT_LIST_AUX_compute</b></a>]  Theorem
      
       (l. COUNT_LIST_AUX 0 l = l) 
        (n l.
           COUNT_LIST_AUX &lt;..num comp'n..&gt; l =
           COUNT_LIST_AUX (&lt;..num comp'n..&gt;  1) (&lt;..num comp'n..&gt;  1::l)) 
        n l.
          COUNT_LIST_AUX &lt;..num comp'n..&gt; l =
          COUNT_LIST_AUX &lt;..num comp'n..&gt; (&lt;..num comp'n..&gt; ::l)
   
   [<a name="COUNT_LIST_COUNT-val"><b>COUNT_LIST_COUNT</b></a>]  Theorem
      
       n. set (COUNT_LIST n) = count n
   
   [<a name="COUNT_LIST_GENLIST-val"><b>COUNT_LIST_GENLIST</b></a>]  Theorem
      
       n. COUNT_LIST n = GENLIST I n
   
   [<a name="COUNT_LIST_SNOC-val"><b>COUNT_LIST_SNOC</b></a>]  Theorem
      
       COUNT_LIST 0 = []  n. COUNT_LIST (SUC n) = SNOC n (COUNT_LIST n)
   
   [<a name="COUNT_LIST_compute-val"><b>COUNT_LIST_compute</b></a>]  Theorem
      
       n. COUNT_LIST n = COUNT_LIST_AUX n []
   
   [<a name="DELETE_ELEMENT_APPEND-val"><b>DELETE_ELEMENT_APPEND</b></a>]  Theorem
      
       a L L'.
          DELETE_ELEMENT a (L  L') =
          DELETE_ELEMENT a L  DELETE_ELEMENT a L'
   
   [<a name="DELETE_ELEMENT_FILTER-val"><b>DELETE_ELEMENT_FILTER</b></a>]  Theorem
      
       e L. DELETE_ELEMENT e L = FILTER (y. e  y) L
   
   [<a name="DISTINCT_LIST_TO_SET_EQ_SING-val"><b>DISTINCT_LIST_TO_SET_EQ_SING</b></a>]  Theorem
      
       l x. ALL_DISTINCT l  set l = {x}  l = [x]
   
   [<a name="DROP-val"><b>DROP</b></a>]  Theorem
      
       (l. DROP 0 l = l)  n x l. DROP (SUC n) (x::l) = DROP n l
   
   [<a name="DROP_1-val"><b>DROP_1</b></a>]  Theorem
      
       h t. DROP 1 (h::t) = t
   
   [<a name="DROP_1_APPEND-val"><b>DROP_1_APPEND</b></a>]  Theorem
      
       x y. x  []  DROP 1 (x  y) = DROP 1 x  y
   
   [<a name="DROP_APPEND-val"><b>DROP_APPEND</b></a>]  Theorem
      
       n l1 l2. DROP n (l1  l2) = DROP n l1  DROP (n  LENGTH l1) l2
   
   [<a name="DROP_APPEND1-val"><b>DROP_APPEND1</b></a>]  Theorem
      
       n l1. n  LENGTH l1  l2. DROP n (l1  l2) = DROP n l1  l2
   
   [<a name="DROP_APPEND2-val"><b>DROP_APPEND2</b></a>]  Theorem
      
       l1 n.
          LENGTH l1  n  l2. DROP n (l1  l2) = DROP (n  LENGTH l1) l2
   
   [<a name="DROP_BY_DROP_SUC-val"><b>DROP_BY_DROP_SUC</b></a>]  Theorem
      
       k x. k &lt; LENGTH x  DROP k x = EL k x::DROP (SUC k) x
   
   [<a name="DROP_CONS_EL-val"><b>DROP_CONS_EL</b></a>]  Theorem
      
       n l. n &lt; LENGTH l  DROP n l = EL n l::DROP (SUC n) l
   
   [<a name="DROP_DROP-val"><b>DROP_DROP</b></a>]  Theorem
      
       n m l. n + m  LENGTH l  DROP n (DROP m l) = DROP (n + m) l
   
   [<a name="DROP_DROP_T-val"><b>DROP_DROP_T</b></a>]  Theorem
      
       n m l. DROP n (DROP m l) = DROP (n + m) l
   
   [<a name="DROP_EL_CONS-val"><b>DROP_EL_CONS</b></a>]  Theorem
      
       ls n. n &lt; LENGTH ls  DROP n ls = EL n ls::DROP (n + 1) ls
   
   [<a name="DROP_FUNPOW_TL-val"><b>DROP_FUNPOW_TL</b></a>]  Theorem
      
       n l. DROP n l = FUNPOW TL_T n l
   
   [<a name="DROP_HEAD_ELEMENT-val"><b>DROP_HEAD_ELEMENT</b></a>]  Theorem
      
       ls n. n &lt; LENGTH ls  u. DROP n ls = [EL n ls]  u
   
   [<a name="DROP_LASTN-val"><b>DROP_LASTN</b></a>]  Theorem
      
       n l. n  LENGTH l  DROP n l = LASTN (LENGTH l  n) l
   
   [<a name="DROP_LENGTH_APPEND-val"><b>DROP_LENGTH_APPEND</b></a>]  Theorem
      
       l1 l2. DROP (LENGTH l1) (l1  l2) = l2
   
   [<a name="DROP_LENGTH_NIL-val"><b>DROP_LENGTH_NIL</b></a>]  Theorem
      
       l. DROP (LENGTH l) l = []
   
   [<a name="DROP_LENGTH_NIL_rwt-val"><b>DROP_LENGTH_NIL_rwt</b></a>]  Theorem
      
       l m. m = LENGTH l  DROP m l = []
   
   [<a name="DROP_PREn_LAST_CONS-val"><b>DROP_PREn_LAST_CONS</b></a>]  Theorem
      
       l n.
          0 &lt; n  n  LENGTH l  DROP (n  1) l = LAST (TAKE n l)::DROP n l
   
   [<a name="DROP_REPLICATE-val"><b>DROP_REPLICATE</b></a>]  Theorem
      
       DROP n (REPLICATE m a) = REPLICATE (m  n) a
   
   [<a name="DROP_REVERSE-val"><b>DROP_REVERSE</b></a>]  Theorem
      
       n l. n  LENGTH l  DROP n (REVERSE l) = REVERSE (BUTLASTN n l)
   
   [<a name="DROP_SEG-val"><b>DROP_SEG</b></a>]  Theorem
      
       n l. n  LENGTH l  DROP n l = SEG (LENGTH l  n) n l
   
   [<a name="DROP_SNOC-val"><b>DROP_SNOC</b></a>]  Theorem
      
       n l. n  LENGTH l  x. DROP n (SNOC x l) = SNOC x (DROP n l)
   
   [<a name="DROP_SUC-val"><b>DROP_SUC</b></a>]  Theorem
      
       n x. DROP (SUC n) x = DROP 1 (DROP n x)
   
   [<a name="DROP_TAKE_EQ_NIL-val"><b>DROP_TAKE_EQ_NIL</b></a>]  Theorem
      
       ls n. DROP n (TAKE n ls) = []
   
   [<a name="EL-val"><b>EL</b></a>]  Theorem
      
       (l. EL 0 l = HD l)  l n. EL (SUC n) l = EL n (TL l)
   
   [<a name="ELL_0_SNOC-val"><b>ELL_0_SNOC</b></a>]  Theorem
      
       l x. ELL 0 (SNOC x l) = x
   
   [<a name="ELL_APPEND1-val"><b>ELL_APPEND1</b></a>]  Theorem
      
       l2 n.
          LENGTH l2  n  l1. ELL n (l1  l2) = ELL (n  LENGTH l2) l1
   
   [<a name="ELL_APPEND2-val"><b>ELL_APPEND2</b></a>]  Theorem
      
       n l2. n &lt; LENGTH l2  l1. ELL n (l1  l2) = ELL n l2
   
   [<a name="ELL_CONS-val"><b>ELL_CONS</b></a>]  Theorem
      
       n l. n &lt; LENGTH l  x. ELL n (x::l) = ELL n l
   
   [<a name="ELL_EL-val"><b>ELL_EL</b></a>]  Theorem
      
       n l. n &lt; LENGTH l  ELL n l = EL (PRE (LENGTH l  n)) l
   
   [<a name="ELL_IS_EL-val"><b>ELL_IS_EL</b></a>]  Theorem
      
       n l. n &lt; LENGTH l  MEM (ELL n l) l
   
   [<a name="ELL_LAST-val"><b>ELL_LAST</b></a>]  Theorem
      
       l. NULL l  ELL 0 l = LAST l
   
   [<a name="ELL_LENGTH_APPEND-val"><b>ELL_LENGTH_APPEND</b></a>]  Theorem
      
       l1 l2. NULL l1  ELL (LENGTH l2) (l1  l2) = LAST l1
   
   [<a name="ELL_LENGTH_CONS-val"><b>ELL_LENGTH_CONS</b></a>]  Theorem
      
       l x. ELL (LENGTH l) (x::l) = x
   
   [<a name="ELL_LENGTH_SNOC-val"><b>ELL_LENGTH_SNOC</b></a>]  Theorem
      
       l x. ELL (LENGTH l) (SNOC x l) = if NULL l then x else HD l
   
   [<a name="ELL_MAP-val"><b>ELL_MAP</b></a>]  Theorem
      
       n l f. n &lt; LENGTH l  ELL n (MAP f l) = f (ELL n l)
   
   [<a name="ELL_MEM-val"><b>ELL_MEM</b></a>]  Theorem
      
       n l. n &lt; LENGTH l  MEM (ELL n l) l
   
   [<a name="ELL_PRE_LENGTH-val"><b>ELL_PRE_LENGTH</b></a>]  Theorem
      
       l. l  []  ELL (PRE (LENGTH l)) l = HD l
   
   [<a name="ELL_REVERSE-val"><b>ELL_REVERSE</b></a>]  Theorem
      
       n l. n &lt; LENGTH l  ELL n (REVERSE l) = ELL (PRE (LENGTH l  n)) l
   
   [<a name="ELL_REVERSE_EL-val"><b>ELL_REVERSE_EL</b></a>]  Theorem
      
       n l. n &lt; LENGTH l  ELL n (REVERSE l) = EL n l
   
   [<a name="ELL_SEG-val"><b>ELL_SEG</b></a>]  Theorem
      
       n l. n &lt; LENGTH l  ELL n l = HD (SEG 1 (PRE (LENGTH l  n)) l)
   
   [<a name="ELL_SNOC-val"><b>ELL_SNOC</b></a>]  Theorem
      
       n. 0 &lt; n  x l. ELL n (SNOC x l) = ELL (PRE n) l
   
   [<a name="ELL_SUC_SNOC-val"><b>ELL_SUC_SNOC</b></a>]  Theorem
      
       n x l. ELL (SUC n) (SNOC x l) = ELL n l
   
   [<a name="ELL_compute-val"><b>ELL_compute</b></a>]  Theorem
      
       (l. ELL 0 l = LAST l) 
        (n l.
           ELL &lt;..num comp'n..&gt; l = ELL (&lt;..num comp'n..&gt;  1) (FRONT l)) 
        n l. ELL &lt;..num comp'n..&gt; l = ELL &lt;..num comp'n..&gt; (FRONT l)
   
   [<a name="EL_APPEND-val"><b>EL_APPEND</b></a>]  Theorem
      
       n l1 l2.
          EL n (l1  l2) =
          if n &lt; LENGTH l1 then EL n l1 else EL (n  LENGTH l1) l2
   
   [<a name="EL_APPEND1-val"><b>EL_APPEND1</b></a>]  Theorem
      
       n l1 l2. n &lt; LENGTH l1  EL n (l1  l2) = EL n l1
   
   [<a name="EL_APPEND2-val"><b>EL_APPEND2</b></a>]  Theorem
      
       l1 n. LENGTH l1  n  l2. EL n (l1  l2) = EL (n  LENGTH l1) l2
   
   [<a name="EL_BUTFIRSTN-val"><b>EL_BUTFIRSTN</b></a>]  Theorem
      
       m n l. m + n &lt; LENGTH l  EL m (DROP n l) = EL (m + n) l
   
   [<a name="EL_CONS-val"><b>EL_CONS</b></a>]  Theorem
      
       n. 0 &lt; n  x l. EL n (x::l) = EL (PRE n) l
   
   [<a name="EL_COUNT_LIST-val"><b>EL_COUNT_LIST</b></a>]  Theorem
      
       m n. m &lt; n  EL m (COUNT_LIST n) = m
   
   [<a name="EL_DROP-val"><b>EL_DROP</b></a>]  Theorem
      
       m n l. m + n &lt; LENGTH l  EL m (DROP n l) = EL (m + n) l
   
   [<a name="EL_ELL-val"><b>EL_ELL</b></a>]  Theorem
      
       n l. n &lt; LENGTH l  EL n l = ELL (PRE (LENGTH l  n)) l
   
   [<a name="EL_FIRSTN-val"><b>EL_FIRSTN</b></a>]  Theorem
      
       n x l. x &lt; n  EL x (TAKE n l) = EL x l
   
   [<a name="EL_FRONT-val"><b>EL_FRONT</b></a>]  Theorem
      
       l n. n &lt; LENGTH (FRONT l)  NULL l  EL n (FRONT l) = EL n l
   
   [<a name="EL_GENLIST-val"><b>EL_GENLIST</b></a>]  Theorem
      
       f n x. x &lt; n  EL x (GENLIST f n) = f x
   
   [<a name="EL_IS_EL-val"><b>EL_IS_EL</b></a>]  Theorem
      
       n l. n &lt; LENGTH l  MEM (EL n l) l
   
   [<a name="EL_LENGTH_APPEND-val"><b>EL_LENGTH_APPEND</b></a>]  Theorem
      
       l2 l1. NULL l2  EL (LENGTH l1) (l1  l2) = HD l2
   
   [<a name="EL_LENGTH_APPEND_0-val"><b>EL_LENGTH_APPEND_0</b></a>]  Theorem
      
       ls h t. EL (LENGTH ls) (ls  h::t) = h
   
   [<a name="EL_LENGTH_APPEND_1-val"><b>EL_LENGTH_APPEND_1</b></a>]  Theorem
      
       ls h k t. EL (LENGTH ls + 1) (ls  h::k::t) = k
   
   [<a name="EL_LENGTH_APPEND_rwt-val"><b>EL_LENGTH_APPEND_rwt</b></a>]  Theorem
      
       NULL l2  n = LENGTH l1  EL n (l1  l2) = HD l2
   
   [<a name="EL_LENGTH_SNOC-val"><b>EL_LENGTH_SNOC</b></a>]  Theorem
      
       l x. EL (LENGTH l) (SNOC x l) = x
   
   [<a name="EL_MAP-val"><b>EL_MAP</b></a>]  Theorem
      
       n l. n &lt; LENGTH l  f. EL n (MAP f l) = f (EL n l)
   
   [<a name="EL_MEM-val"><b>EL_MEM</b></a>]  Theorem
      
       n l. n &lt; LENGTH l  MEM (EL n l) l
   
   [<a name="EL_PRE_LENGTH-val"><b>EL_PRE_LENGTH</b></a>]  Theorem
      
       l. l  []  EL (PRE (LENGTH l)) l = LAST l
   
   [<a name="EL_REPLICATE-val"><b>EL_REPLICATE</b></a>]  Theorem
      
       n1 n2 x. n1 &lt; n2  EL n1 (REPLICATE n2 x) = x
   
   [<a name="EL_REVERSE-val"><b>EL_REVERSE</b></a>]  Theorem
      
       n l. n &lt; LENGTH l  EL n (REVERSE l) = EL (PRE (LENGTH l  n)) l
   
   [<a name="EL_REVERSE_ELL-val"><b>EL_REVERSE_ELL</b></a>]  Theorem
      
       n l. n &lt; LENGTH l  EL n (REVERSE l) = ELL n l
   
   [<a name="EL_SEG-val"><b>EL_SEG</b></a>]  Theorem
      
       n l. n &lt; LENGTH l  EL n l = HD (SEG 1 n l)
   
   [<a name="EL_SNOC-val"><b>EL_SNOC</b></a>]  Theorem
      
       n l. n &lt; LENGTH l  x. EL n (SNOC x l) = EL n l
   
   [<a name="EL_SPLIT-val"><b>EL_SPLIT</b></a>]  Theorem
      
       ls j. j &lt; LENGTH ls  l1 l2. ls = l1  EL j ls::l2
   
   [<a name="EL_SPLIT_2-val"><b>EL_SPLIT_2</b></a>]  Theorem
      
       ls j k.
          j &lt; k  k &lt; LENGTH ls 
          l1 l2 l3. ls = l1  EL j ls::l2  EL k ls::l3
   
   [<a name="EL_TAIL-val"><b>EL_TAIL</b></a>]  Theorem
      
       h t n. 0  n  EL (n  1) t = EL n (h::t)
   
   [<a name="EL_TAKE-val"><b>EL_TAKE</b></a>]  Theorem
      
       n x l. x &lt; n  EL x (TAKE n l) = EL x l
   
   [<a name="EL_chunks-val"><b>EL_chunks</b></a>]  Theorem
      
       k ls n.
          n &lt; LENGTH (chunks k ls)  0 &lt; k  NULL ls 
          EL n (chunks k ls) = TAKE k (DROP (n * k) ls)
   
   [<a name="EQ_LIST-val"><b>EQ_LIST</b></a>]  Theorem
      
       h1 h2. h1 = h2  l1 l2. l1 = l2  h1::l1 = h2::l2
   
   [<a name="EVERY2_APPEND-val"><b>EVERY2_APPEND</b></a>]  Theorem
      
       LIST_REL R l1 l2  LIST_REL R l3 l4 
        LIST_REL R (l1  l3) (l2  l4)  LENGTH l1 = LENGTH l2 
        LENGTH l3 = LENGTH l4
   
   [<a name="EVERY2_APPEND_suff-val"><b>EVERY2_APPEND_suff</b></a>]  Theorem
      
       LIST_REL R l1 l2  LIST_REL R l3 l4 
        LIST_REL R (l1  l3) (l2  l4)
   
   [<a name="EVERY2_DROP-val"><b>EVERY2_DROP</b></a>]  Theorem
      
       R l1 l2 n. LIST_REL R l1 l2  LIST_REL R (DROP n l1) (DROP n l2)
   
   [<a name="EVERY2_REVERSE1-val"><b>EVERY2_REVERSE1</b></a>]  Theorem
      
       l1 l2. LIST_REL R l1 (REVERSE l2)  LIST_REL R (REVERSE l1) l2
   
   [<a name="EVERY2_TAKE-val"><b>EVERY2_TAKE</b></a>]  Theorem
      
       P xs ys n. LIST_REL P xs ys  LIST_REL P (TAKE n xs) (TAKE n ys)
   
   [<a name="EVERY_BUTLASTN-val"><b>EVERY_BUTLASTN</b></a>]  Theorem
      
       P l m. EVERY P l  EVERY P (BUTLASTN m l)
   
   [<a name="EVERY_DELETE_ELEMENT-val"><b>EVERY_DELETE_ELEMENT</b></a>]  Theorem
      
       e L P. P e  EVERY P (DELETE_ELEMENT e L)  EVERY P L
   
   [<a name="EVERY_DROP-val"><b>EVERY_DROP</b></a>]  Theorem
      
       P l m. EVERY P l  EVERY P (DROP m l)
   
   [<a name="EVERY_FOLDL-val"><b>EVERY_FOLDL</b></a>]  Theorem
      
       P l. EVERY P l  FOLDL (l' x. l'  P x) T l
   
   [<a name="EVERY_FOLDL_MAP-val"><b>EVERY_FOLDL_MAP</b></a>]  Theorem
      
       P l. EVERY P l  FOLDL $/\ T (MAP P l)
   
   [<a name="EVERY_FOLDR-val"><b>EVERY_FOLDR</b></a>]  Theorem
      
       P l. EVERY P l  FOLDR (x l'. P x  l') T l
   
   [<a name="EVERY_FOLDR_MAP-val"><b>EVERY_FOLDR_MAP</b></a>]  Theorem
      
       P l. EVERY P l  FOLDR $/\ T (MAP P l)
   
   [<a name="EVERY_GENLIST-val"><b>EVERY_GENLIST</b></a>]  Theorem
      
       n. EVERY P (GENLIST f n)  i. i &lt; n  P (f i)
   
   [<a name="EVERY_LASTN-val"><b>EVERY_LASTN</b></a>]  Theorem
      
       P l m. EVERY P l  EVERY P (LASTN m l)
   
   [<a name="EVERY_REPLICATE-val"><b>EVERY_REPLICATE</b></a>]  Theorem
      
       f n x. EVERY f (REPLICATE n x)  n = 0  f x
   
   [<a name="EVERY_REVERSE-val"><b>EVERY_REVERSE</b></a>]  Theorem
      
       P l. EVERY P (REVERSE l)  EVERY P l
   
   [<a name="EVERY_SEG-val"><b>EVERY_SEG</b></a>]  Theorem
      
       P l. EVERY P l  m k. m + k  LENGTH l  EVERY P (SEG m k l)
   
   [<a name="EVERY_TAKE-val"><b>EVERY_TAKE</b></a>]  Theorem
      
       P l m. EVERY P l  EVERY P (TAKE m l)
   
   [<a name="EXISTS_BUTLASTN-val"><b>EXISTS_BUTLASTN</b></a>]  Theorem
      
       l m P. EXISTS P (BUTLASTN m l)  EXISTS P l
   
   [<a name="EXISTS_DISJ-val"><b>EXISTS_DISJ</b></a>]  Theorem
      
       P Q l. (EXISTS (x. P x  Q x) l  EXISTS P l)  EXISTS Q l
   
   [<a name="EXISTS_DROP-val"><b>EXISTS_DROP</b></a>]  Theorem
      
       l m P. EXISTS P (DROP m l)  EXISTS P l
   
   [<a name="EXISTS_FOLDL-val"><b>EXISTS_FOLDL</b></a>]  Theorem
      
       P l. EXISTS P l  FOLDL (l' x. l'  P x) F l
   
   [<a name="EXISTS_FOLDL_MAP-val"><b>EXISTS_FOLDL_MAP</b></a>]  Theorem
      
       P l. EXISTS P l  FOLDL $\/ F (MAP P l)
   
   [<a name="EXISTS_FOLDR-val"><b>EXISTS_FOLDR</b></a>]  Theorem
      
       P l. EXISTS P l  FOLDR (x l'. P x  l') F l
   
   [<a name="EXISTS_FOLDR_MAP-val"><b>EXISTS_FOLDR_MAP</b></a>]  Theorem
      
       P l. EXISTS P l  FOLDR $\/ F (MAP P l)
   
   [<a name="EXISTS_GENLIST-val"><b>EXISTS_GENLIST</b></a>]  Theorem
      
       n. EXISTS P (GENLIST f n)  i. i &lt; n  P (f i)
   
   [<a name="EXISTS_LASTN-val"><b>EXISTS_LASTN</b></a>]  Theorem
      
       l m P. EXISTS P (LASTN m l)  EXISTS P l
   
   [<a name="EXISTS_REVERSE-val"><b>EXISTS_REVERSE</b></a>]  Theorem
      
       P l. EXISTS P (REVERSE l)  EXISTS P l
   
   [<a name="EXISTS_SEG-val"><b>EXISTS_SEG</b></a>]  Theorem
      
       m k l. m + k  LENGTH l  P. EXISTS P (SEG m k l)  EXISTS P l
   
   [<a name="EXISTS_TAKE-val"><b>EXISTS_TAKE</b></a>]  Theorem
      
       l m P. EXISTS P (TAKE m l)  EXISTS P l
   
   [<a name="FCOMM_FOLDL_APPEND-val"><b>FCOMM_FOLDL_APPEND</b></a>]  Theorem
      
       f g.
          FCOMM f g 
          e. RIGHT_ID g e 
              l1 l2. FOLDL f e (l1  l2) = g (FOLDL f e l1) (FOLDL f e l2)
   
   [<a name="FCOMM_FOLDL_FLAT-val"><b>FCOMM_FOLDL_FLAT</b></a>]  Theorem
      
       f g.
          FCOMM f g 
          e. RIGHT_ID g e 
              l. FOLDL f e (FLAT l) = FOLDL g e (MAP (FOLDL f e) l)
   
   [<a name="FCOMM_FOLDR_APPEND-val"><b>FCOMM_FOLDR_APPEND</b></a>]  Theorem
      
       g f.
          FCOMM g f 
          e. LEFT_ID g e 
              l1 l2. FOLDR f e (l1  l2) = g (FOLDR f e l1) (FOLDR f e l2)
   
   [<a name="FCOMM_FOLDR_FLAT-val"><b>FCOMM_FOLDR_FLAT</b></a>]  Theorem
      
       g f.
          FCOMM g f 
          e. LEFT_ID g e 
              l. FOLDR f e (FLAT l) = FOLDR g e (MAP (FOLDR f e) l)
   
   [<a name="FILTER-val"><b>FILTER</b></a>]  Theorem
      
       (P. FILTER P [] = []) 
        P h t. FILTER P (h::t) = if P h then h::FILTER P t else FILTER P t
   
   [<a name="FILTER_APPEND-val"><b>FILTER_APPEND</b></a>]  Theorem
      
       P L M. FILTER P (L  M) = FILTER P L  FILTER P M
   
   [<a name="FILTER_COMM-val"><b>FILTER_COMM</b></a>]  Theorem
      
       f1 f2 l. FILTER f1 (FILTER f2 l) = FILTER f2 (FILTER f1 l)
   
   [<a name="FILTER_EL_IFF-val"><b>FILTER_EL_IFF</b></a>]  Theorem
      
       P ls l1 l2 x j.
          (let
             fs = FILTER P ls
           in
             ALL_DISTINCT ls  ls = l1  x::l2  j &lt; LENGTH fs 
             (x = EL j fs  P x  j = LENGTH (FILTER P l1)))
   
   [<a name="FILTER_EL_IMP-val"><b>FILTER_EL_IMP</b></a>]  Theorem
      
       P ls l1 l2 x.
          (let
             fs = FILTER P ls
           in
             ls = l1  x::l2  P x  x = EL (LENGTH (FILTER P l1)) fs)
   
   [<a name="FILTER_EL_NEXT-val"><b>FILTER_EL_NEXT</b></a>]  Theorem
      
       P ls l1 l2 l3 x y.
          (let
             fs = FILTER P ls;
             j = LENGTH (FILTER P l1)
           in
             ls = l1  x::l2  y::l3  P x  P y  FILTER P l2 = [] 
             x = EL j fs  y = EL (j + 1) fs)
   
   [<a name="FILTER_EL_NEXT_IFF-val"><b>FILTER_EL_NEXT_IFF</b></a>]  Theorem
      
       P ls l1 l2 l3 x y.
          (let
             fs = FILTER P ls;
             j = LENGTH (FILTER P l1)
           in
             ALL_DISTINCT ls  ls = l1  x::l2  y::l3  P x  P y 
             (x = EL j fs  y = EL (j + 1) fs  FILTER P l2 = []))
   
   [<a name="FILTER_EQ-val"><b>FILTER_EQ</b></a>]  Theorem
      
       P1 P2 l. FILTER P1 l = FILTER P2 l  x. MEM x l  (P1 x  P2 x)
   
   [<a name="FILTER_FILTER-val"><b>FILTER_FILTER</b></a>]  Theorem
      
       P Q l. FILTER P (FILTER Q l) = FILTER (x. P x  Q x) l
   
   [<a name="FILTER_FLAT-val"><b>FILTER_FLAT</b></a>]  Theorem
      
       P l. FILTER P (FLAT l) = FLAT (MAP (FILTER P) l)
   
   [<a name="FILTER_FOLDL-val"><b>FILTER_FOLDL</b></a>]  Theorem
      
       P l.
          FILTER P l = FOLDL (l' x. if P x then SNOC x l' else l') [] l
   
   [<a name="FILTER_FOLDR-val"><b>FILTER_FOLDR</b></a>]  Theorem
      
       P l. FILTER P l = FOLDR (x l'. if P x then x::l' else l') [] l
   
   [<a name="FILTER_HD-val"><b>FILTER_HD</b></a>]  Theorem
      
       P ls l1 l2 x.
          ls = l1  x::l2  P x  FILTER P l1 = []  x = HD (FILTER P ls)
   
   [<a name="FILTER_HD_IFF-val"><b>FILTER_HD_IFF</b></a>]  Theorem
      
       P ls l1 l2 x.
          ALL_DISTINCT ls  ls = l1  x::l2  P x 
          (x = HD (FILTER P ls)  FILTER P l1 = [])
   
   [<a name="FILTER_IDEM-val"><b>FILTER_IDEM</b></a>]  Theorem
      
       f l. FILTER f (FILTER f l) = FILTER f l
   
   [<a name="FILTER_LAST-val"><b>FILTER_LAST</b></a>]  Theorem
      
       P ls l1 l2 x.
          ls = l1  x::l2  P x  FILTER P l2 = []  x = LAST (FILTER P ls)
   
   [<a name="FILTER_LAST_IFF-val"><b>FILTER_LAST_IFF</b></a>]  Theorem
      
       P ls l1 l2 x.
          ALL_DISTINCT ls  ls = l1  x::l2  P x 
          (x = LAST (FILTER P ls)  FILTER P l2 = [])
   
   [<a name="FILTER_MAP-val"><b>FILTER_MAP</b></a>]  Theorem
      
       f1 f2 l. FILTER f1 (MAP f2 l) = MAP f2 (FILTER (f1  f2) l)
   
   [<a name="FILTER_MONO_DEC-val"><b>FILTER_MONO_DEC</b></a>]  Theorem
      
       P ls. MONO_DEC ls  MONO_DEC (FILTER P ls)
   
   [<a name="FILTER_MONO_INC-val"><b>FILTER_MONO_INC</b></a>]  Theorem
      
       P ls. MONO_INC ls  MONO_INC (FILTER P ls)
   
   [<a name="FILTER_REVERSE-val"><b>FILTER_REVERSE</b></a>]  Theorem
      
       l P. FILTER P (REVERSE l) = REVERSE (FILTER P l)
   
   [<a name="FILTER_SNOC-val"><b>FILTER_SNOC</b></a>]  Theorem
      
       P x l.
          FILTER P (SNOC x l) =
          if P x then SNOC x (FILTER P l) else FILTER P l
   
   [<a name="FILTER_sublist-val"><b>FILTER_sublist</b></a>]  Theorem
      
       P ls. FILTER P ls  ls
   
   [<a name="FINITE_common_prefixes-val"><b>FINITE_common_prefixes</b></a>]  Theorem
      
       s    FINITE (common_prefixes s)
   
   [<a name="FINITE_prefix-val"><b>FINITE_prefix</b></a>]  Theorem
      
       FINITE {a | a  b}
   
   [<a name="FIRSTN-val"><b>FIRSTN</b></a>]  Theorem
      
       (l. TAKE 0 l = [])  n x l. TAKE (SUC n) (x::l) = x::TAKE n l
   
   [<a name="FIRSTN_APPEND1-val"><b>FIRSTN_APPEND1</b></a>]  Theorem
      
       n l1. n  LENGTH l1  l2. TAKE n (l1  l2) = TAKE n l1
   
   [<a name="FIRSTN_APPEND2-val"><b>FIRSTN_APPEND2</b></a>]  Theorem
      
       l1 n.
          LENGTH l1  n 
          l2. TAKE n (l1  l2) = l1  TAKE (n  LENGTH l1) l2
   
   [<a name="FIRSTN_BUTLASTN-val"><b>FIRSTN_BUTLASTN</b></a>]  Theorem
      
       n l. n  LENGTH l  TAKE n l = BUTLASTN (LENGTH l  n) l
   
   [<a name="FIRSTN_FIRSTN-val"><b>FIRSTN_FIRSTN</b></a>]  Theorem
      
       m l. m  LENGTH l  n. n  m  TAKE n (TAKE m l) = TAKE n l
   
   [<a name="FIRSTN_LENGTH_APPEND-val"><b>FIRSTN_LENGTH_APPEND</b></a>]  Theorem
      
       l1 l2. TAKE (LENGTH l1) (l1  l2) = l1
   
   [<a name="FIRSTN_LENGTH_ID-val"><b>FIRSTN_LENGTH_ID</b></a>]  Theorem
      
       l. TAKE (LENGTH l) l = l
   
   [<a name="FIRSTN_REVERSE-val"><b>FIRSTN_REVERSE</b></a>]  Theorem
      
       n l. n  LENGTH l  TAKE n (REVERSE l) = REVERSE (LASTN n l)
   
   [<a name="FIRSTN_SEG-val"><b>FIRSTN_SEG</b></a>]  Theorem
      
       n l. n  LENGTH l  TAKE n l = SEG n 0 l
   
   [<a name="FIRSTN_SNOC-val"><b>FIRSTN_SNOC</b></a>]  Theorem
      
       n l. n  LENGTH l  x. TAKE n (SNOC x l) = TAKE n l
   
   [<a name="FLAT-val"><b>FLAT</b></a>]  Theorem
      
       FLAT [] = []  h t. FLAT (h::t) = h  FLAT t
   
   [<a name="FLAT_APPEND-val"><b>FLAT_APPEND</b></a>]  Theorem
      
       l1 l2. FLAT (l1  l2) = FLAT l1  FLAT l2
   
   [<a name="FLAT_FLAT-val"><b>FLAT_FLAT</b></a>]  Theorem
      
       l. FLAT (FLAT l) = FLAT (MAP FLAT l)
   
   [<a name="FLAT_FOLDL-val"><b>FLAT_FOLDL</b></a>]  Theorem
      
       l. FLAT l = FOLDL $++ [] l
   
   [<a name="FLAT_FOLDR-val"><b>FLAT_FOLDR</b></a>]  Theorem
      
       l. FLAT l = FOLDR $++ [] l
   
   [<a name="FLAT_REVERSE-val"><b>FLAT_REVERSE</b></a>]  Theorem
      
       l. FLAT (REVERSE l) = REVERSE (FLAT (MAP REVERSE l))
   
   [<a name="FLAT_SNOC-val"><b>FLAT_SNOC</b></a>]  Theorem
      
       x l. FLAT (SNOC x l) = FLAT l  x
   
   [<a name="FLAT_chunks-val"><b>FLAT_chunks</b></a>]  Theorem
      
       FLAT (chunks n ls) = ls
   
   [<a name="FOLDL-val"><b>FOLDL</b></a>]  Theorem
      
       (f e. FOLDL f e [] = e) 
        f e x l. FOLDL f e (x::l) = FOLDL f (f e x) l
   
   [<a name="FOLDL_APPEND-val"><b>FOLDL_APPEND</b></a>]  Theorem
      
       f e l1 l2. FOLDL f e (l1  l2) = FOLDL f (FOLDL f e l1) l2
   
   [<a name="FOLDL_CONG_invariant-val"><b>FOLDL_CONG_invariant</b></a>]  Theorem
      
       P f1 f2 l e.
          P e  (x a. MEM x l  P a  f1 a x = f2 a x  P (f2 a x)) 
          FOLDL f1 e l = FOLDL f2 e l  P (FOLDL f2 e l)
   
   [<a name="FOLDL_FILTER-val"><b>FOLDL_FILTER</b></a>]  Theorem
      
       f e P l.
          FOLDL f e (FILTER P l) =
          FOLDL (x y. if P y then f x y else x) e l
   
   [<a name="FOLDL_FOLDR_REVERSE-val"><b>FOLDL_FOLDR_REVERSE</b></a>]  Theorem
      
       f e l. FOLDL f e l = FOLDR (x y. f y x) e (REVERSE l)
   
   [<a name="FOLDL_MAP-val"><b>FOLDL_MAP</b></a>]  Theorem
      
       f e g l. FOLDL f e (MAP g l) = FOLDL (x y. f x (g y)) e l
   
   [<a name="FOLDL_MAP2-val"><b>FOLDL_MAP2</b></a>]  Theorem
      
       f e g l. FOLDL f e (MAP g l) = FOLDL (x y. f x (g y)) e l
   
   [<a name="FOLDL_REVERSE-val"><b>FOLDL_REVERSE</b></a>]  Theorem
      
       f e l. FOLDL f e (REVERSE l) = FOLDR (x y. f y x) e l
   
   [<a name="FOLDL_SINGLE-val"><b>FOLDL_SINGLE</b></a>]  Theorem
      
       f e x. FOLDL f e [x] = f e x
   
   [<a name="FOLDL_SNOC-val"><b>FOLDL_SNOC</b></a>]  Theorem
      
       f e x l. FOLDL f e (SNOC x l) = f (FOLDL f e l) x
   
   [<a name="FOLDL_SNOC_NIL-val"><b>FOLDL_SNOC_NIL</b></a>]  Theorem
      
       l. FOLDL (xs x. SNOC x xs) [] l = l
   
   [<a name="FOLDR-val"><b>FOLDR</b></a>]  Theorem
      
       (f e. FOLDR f e [] = e) 
        f e x l. FOLDR f e (x::l) = f x (FOLDR f e l)
   
   [<a name="FOLDR_APPEND-val"><b>FOLDR_APPEND</b></a>]  Theorem
      
       f e l1 l2. FOLDR f e (l1  l2) = FOLDR f (FOLDR f e l2) l1
   
   [<a name="FOLDR_CONS_NIL-val"><b>FOLDR_CONS_NIL</b></a>]  Theorem
      
       l. FOLDR CONS [] l = l
   
   [<a name="FOLDR_FILTER-val"><b>FOLDR_FILTER</b></a>]  Theorem
      
       f e P l.
          FOLDR f e (FILTER P l) =
          FOLDR (x y. if P x then f x y else y) e l
   
   [<a name="FOLDR_FILTER_REVERSE-val"><b>FOLDR_FILTER_REVERSE</b></a>]  Theorem
      
       f. (a b c. f a (f b c) = f b (f a c)) 
            e P l.
              FOLDR f e (FILTER P (REVERSE l)) = FOLDR f e (FILTER P l)
   
   [<a name="FOLDR_FOLDL-val"><b>FOLDR_FOLDL</b></a>]  Theorem
      
       f e. MONOID f e  l. FOLDR f e l = FOLDL f e l
   
   [<a name="FOLDR_FOLDL_REVERSE-val"><b>FOLDR_FOLDL_REVERSE</b></a>]  Theorem
      
       f e l. FOLDR f e l = FOLDL (x y. f y x) e (REVERSE l)
   
   [<a name="FOLDR_MAP-val"><b>FOLDR_MAP</b></a>]  Theorem
      
       f e g l. FOLDR f e (MAP g l) = FOLDR (x y. f (g x) y) e l
   
   [<a name="FOLDR_MAP_REVERSE-val"><b>FOLDR_MAP_REVERSE</b></a>]  Theorem
      
       f. (a b c. f a (f b c) = f b (f a c)) 
            e g l. FOLDR f e (MAP g (REVERSE l)) = FOLDR f e (MAP g l)
   
   [<a name="FOLDR_REVERSE-val"><b>FOLDR_REVERSE</b></a>]  Theorem
      
       f e l. FOLDR f e (REVERSE l) = FOLDL (x y. f y x) e l
   
   [<a name="FOLDR_SINGLE-val"><b>FOLDR_SINGLE</b></a>]  Theorem
      
       f e x. FOLDR f e [x] = f x e
   
   [<a name="FOLDR_SNOC-val"><b>FOLDR_SNOC</b></a>]  Theorem
      
       f e x l. FOLDR f e (SNOC x l) = FOLDR f (f x e) l
   
   [<a name="FRONT_APPEND-val"><b>FRONT_APPEND</b></a>]  Theorem
      
       l1 l2 e. FRONT (l1  e::l2) = l1  FRONT (e::l2)
   
   [<a name="FRONT_APPEND_NOT_NIL-val"><b>FRONT_APPEND_NOT_NIL</b></a>]  Theorem
      
       l1 l2. l2  []  FRONT (l1  l2) = l1  FRONT l2
   
   [<a name="FRONT_BY_TAKE-val"><b>FRONT_BY_TAKE</b></a>]  Theorem
      
       ls. ls  []  FRONT ls = TAKE (LENGTH ls  1) ls
   
   [<a name="FRONT_EL-val"><b>FRONT_EL</b></a>]  Theorem
      
       l n. l  []  n &lt; LENGTH (FRONT l)  EL n (FRONT l) = EL n l
   
   [<a name="FRONT_EQ_NIL-val"><b>FRONT_EQ_NIL</b></a>]  Theorem
      
       l. LENGTH l = 1  FRONT l = []
   
   [<a name="FRONT_LENGTH-val"><b>FRONT_LENGTH</b></a>]  Theorem
      
       l. l  []  LENGTH (FRONT l) = PRE (LENGTH l)
   
   [<a name="FRONT_NON_NIL-val"><b>FRONT_NON_NIL</b></a>]  Theorem
      
       l. 1 &lt; LENGTH l  FRONT l  []
   
   [<a name="FRONT_SING-val"><b>FRONT_SING</b></a>]  Theorem
      
       x. FRONT [x] = []
   
   [<a name="GENLIST-val"><b>GENLIST</b></a>]  Theorem
      
       (f. GENLIST f 0 = []) 
        f n. GENLIST f (SUC n) = SNOC (f n) (GENLIST f n)
   
   [<a name="GENLIST_APPEND-val"><b>GENLIST_APPEND</b></a>]  Theorem
      
       f a b. GENLIST f (a + b) = GENLIST f b  GENLIST (t. f (t + b)) a
   
   [<a name="GENLIST_CONS-val"><b>GENLIST_CONS</b></a>]  Theorem
      
       GENLIST f (SUC n) = f 0::GENLIST (f  SUC) n
   
   [<a name="GENLIST_FUN_EQ-val"><b>GENLIST_FUN_EQ</b></a>]  Theorem
      
       n f g. GENLIST f n = GENLIST g n  x. x &lt; n  f x = g x
   
   [<a name="GENLIST_K_ADD-val"><b>GENLIST_K_ADD</b></a>]  Theorem
      
       e n m. GENLIST (K e) (n + m) = GENLIST (K e) m  GENLIST (K e) n
   
   [<a name="GENLIST_K_APPEND-val"><b>GENLIST_K_APPEND</b></a>]  Theorem
      
       a b c. GENLIST (K c) a  GENLIST (K c) b = GENLIST (K c) (a + b)
   
   [<a name="GENLIST_K_APPEND_K-val"><b>GENLIST_K_APPEND_K</b></a>]  Theorem
      
       c n. GENLIST (K c) n  [c] = [c]  GENLIST (K c) n
   
   [<a name="GENLIST_K_CONS-val"><b>GENLIST_K_CONS</b></a>]  Theorem
      
       e n. GENLIST (K e) (SUC n) = e::GENLIST (K e) n
   
   [<a name="GENLIST_K_LESS-val"><b>GENLIST_K_LESS</b></a>]  Theorem
      
       f e n. (k. k &lt; n  f k = e)  GENLIST f n = GENLIST (K e) n
   
   [<a name="GENLIST_K_MEM-val"><b>GENLIST_K_MEM</b></a>]  Theorem
      
       x c n. 0 &lt; n  (MEM x (GENLIST (K c) n)  x = c)
   
   [<a name="GENLIST_K_RANGE-val"><b>GENLIST_K_RANGE</b></a>]  Theorem
      
       f e n.
          (k. 0 &lt; k  k  n  f k = e) 
          GENLIST (f  SUC) n = GENLIST (K e) n
   
   [<a name="GENLIST_K_SET-val"><b>GENLIST_K_SET</b></a>]  Theorem
      
       c n. 0 &lt; n  set (GENLIST (K c) n) = {c}
   
   [<a name="HD-val"><b>HD</b></a>]  Theorem
      
       h t. HD (h::t) = h
   
   [<a name="HD_APPEND-val"><b>HD_APPEND</b></a>]  Theorem
      
       h t ls. HD (h::t  ls) = h
   
   [<a name="HD_APPEND_NOT_NIL-val"><b>HD_APPEND_NOT_NIL</b></a>]  Theorem
      
       l1 l2. l1  []  HD (l1  l2) = HD l1
   
   [<a name="HD_GENLIST-val"><b>HD_GENLIST</b></a>]  Theorem
      
       HD (GENLIST f (SUC n)) = f 0
   
   [<a name="HEAD_MEM-val"><b>HEAD_MEM</b></a>]  Theorem
      
       ls. ls  []  MEM (HD ls) ls
   
   [<a name="IS_EL-val"><b>IS_EL</b></a>]  Theorem
      
       (x. MEM x []  F)  x h t. MEM x (h::t)  x = h  MEM x t
   
   [<a name="IS_EL_APPEND-val"><b>IS_EL_APPEND</b></a>]  Theorem
      
       e l1 l2. MEM e (l1  l2)  MEM e l1  MEM e l2
   
   [<a name="IS_EL_BUTFIRSTN-val"><b>IS_EL_BUTFIRSTN</b></a>]  Theorem
      
       l m x. MEM x (DROP m l)  MEM x l
   
   [<a name="IS_EL_BUTLASTN-val"><b>IS_EL_BUTLASTN</b></a>]  Theorem
      
       l m x. MEM x (BUTLASTN m l)  MEM x l
   
   [<a name="IS_EL_DEF-val"><b>IS_EL_DEF</b></a>]  Theorem
      
       x l. MEM x l  EXISTS ($= x) l
   
   [<a name="IS_EL_FILTER-val"><b>IS_EL_FILTER</b></a>]  Theorem
      
       P L x. MEM x (FILTER P L)  P x  MEM x L
   
   [<a name="IS_EL_FIRSTN-val"><b>IS_EL_FIRSTN</b></a>]  Theorem
      
       l m x. MEM x (TAKE m l)  MEM x l
   
   [<a name="IS_EL_FOLDL-val"><b>IS_EL_FOLDL</b></a>]  Theorem
      
       y l. MEM y l  FOLDL (l' x. l'  y = x) F l
   
   [<a name="IS_EL_FOLDL_MAP-val"><b>IS_EL_FOLDL_MAP</b></a>]  Theorem
      
       x l. MEM x l  FOLDL $\/ F (MAP ($= x) l)
   
   [<a name="IS_EL_FOLDR-val"><b>IS_EL_FOLDR</b></a>]  Theorem
      
       y l. MEM y l  FOLDR (x l'. y = x  l') F l
   
   [<a name="IS_EL_FOLDR_MAP-val"><b>IS_EL_FOLDR_MAP</b></a>]  Theorem
      
       x l. MEM x l  FOLDR $\/ F (MAP ($= x) l)
   
   [<a name="IS_EL_LASTN-val"><b>IS_EL_LASTN</b></a>]  Theorem
      
       m l x. MEM x (LASTN m l)  MEM x l
   
   [<a name="IS_EL_REPLICATE-val"><b>IS_EL_REPLICATE</b></a>]  Theorem
      
       n x y. MEM y (REPLICATE n x)  x = y  0 &lt; n
   
   [<a name="IS_EL_REVERSE-val"><b>IS_EL_REVERSE</b></a>]  Theorem
      
       l x. MEM x (REVERSE l)  MEM x l
   
   [<a name="IS_EL_SEG-val"><b>IS_EL_SEG</b></a>]  Theorem
      
       n m l. n + m  LENGTH l  x. MEM x (SEG n m l)  MEM x l
   
   [<a name="IS_EL_SNOC-val"><b>IS_EL_SNOC</b></a>]  Theorem
      
       y x l. MEM y (SNOC x l)  y = x  MEM y l
   
   [<a name="IS_EL_SOME_EL-val"><b>IS_EL_SOME_EL</b></a>]  Theorem
      
       x l. MEM x l  EXISTS ($= x) l
   
   [<a name="IS_PREFIX-val"><b>IS_PREFIX</b></a>]  Theorem
      
       (l. []  l  T)  (x l. x::l  []  F) 
        x1 l1 x2 l2. x2::l2  x1::l1  x1 = x2  l2  l1
   
   [<a name="IS_PREFIX_ALL_DISTINCT-val"><b>IS_PREFIX_ALL_DISTINCT</b></a>]  Theorem
      
       l l1. l1  l  ALL_DISTINCT l  ALL_DISTINCT l1
   
   [<a name="IS_PREFIX_ANTISYM-val"><b>IS_PREFIX_ANTISYM</b></a>]  Theorem
      
       x y. x  y  y  x  x = y
   
   [<a name="IS_PREFIX_APPEND-val"><b>IS_PREFIX_APPEND</b></a>]  Theorem
      
       l1 l2. l2  l1  l. l1 = l2  l
   
   [<a name="IS_PREFIX_APPEND1-val"><b>IS_PREFIX_APPEND1</b></a>]  Theorem
      
       a b c. a  b  c  a  c
   
   [<a name="IS_PREFIX_APPEND2-val"><b>IS_PREFIX_APPEND2</b></a>]  Theorem
      
       a b c. a  b  c  a  b  b  a
   
   [<a name="IS_PREFIX_APPEND3-val"><b>IS_PREFIX_APPEND3</b></a>]  Theorem
      
       c a. a  a  c
   
   [<a name="IS_PREFIX_APPENDS-val"><b>IS_PREFIX_APPENDS</b></a>]  Theorem
      
       a b c. a  b  a  c  b  c
   
   [<a name="IS_PREFIX_BUTLAST-val"><b>IS_PREFIX_BUTLAST</b></a>]  Theorem
      
       x y. FRONT (x::y)  x::y
   
   [<a name="IS_PREFIX_BUTLAST'-val"><b>IS_PREFIX_BUTLAST'</b></a>]  Theorem
      
       l. l  []  FRONT l  l
   
   [<a name="IS_PREFIX_EQ_REWRITE-val"><b>IS_PREFIX_EQ_REWRITE</b></a>]  Theorem
      
       l1 l2 l. l1  l  l2  l  (l1 = l2  LENGTH l1 = LENGTH l2)
   
   [<a name="IS_PREFIX_EQ_TAKE-val"><b>IS_PREFIX_EQ_TAKE</b></a>]  Theorem
      
       l l1. l1  l  n. n  LENGTH l  l1 = TAKE n l
   
   [<a name="IS_PREFIX_EQ_TAKE'-val"><b>IS_PREFIX_EQ_TAKE'</b></a>]  Theorem
      
       l l1. l1  l  n. l1 = TAKE n l
   
   [<a name="IS_PREFIX_FRONT_CASES-val"><b>IS_PREFIX_FRONT_CASES</b></a>]  Theorem
      
       l l1. l  []  (l1  l  l = l1  l1  FRONT l)
   
   [<a name="IS_PREFIX_FRONT_MONO-val"><b>IS_PREFIX_FRONT_MONO</b></a>]  Theorem
      
       l1 l2. l1  []  l2  []  l1  l2  FRONT l1  FRONT l2
   
   [<a name="IS_PREFIX_GENLIST-val"><b>IS_PREFIX_GENLIST</b></a>]  Theorem
      
       f m n. GENLIST f m  GENLIST f n  m  n
   
   [<a name="IS_PREFIX_IMP_TAKE-val"><b>IS_PREFIX_IMP_TAKE</b></a>]  Theorem
      
       l l1. l1  l  l1 = TAKE (LENGTH l1) l
   
   [<a name="IS_PREFIX_IS_SUBLIST-val"><b>IS_PREFIX_IS_SUBLIST</b></a>]  Theorem
      
       l1 l2. l2  l1  IS_SUBLIST l1 l2
   
   [<a name="IS_PREFIX_LENGTH-val"><b>IS_PREFIX_LENGTH</b></a>]  Theorem
      
       x y. x  y  LENGTH x  LENGTH y
   
   [<a name="IS_PREFIX_LENGTH_ANTI-val"><b>IS_PREFIX_LENGTH_ANTI</b></a>]  Theorem
      
       x y. x  y  LENGTH x = LENGTH y  x = y
   
   [<a name="IS_PREFIX_NIL-val"><b>IS_PREFIX_NIL</b></a>]  Theorem
      
       x. []  x  (x  []  x = [])
   
   [<a name="IS_PREFIX_PREFIX-val"><b>IS_PREFIX_PREFIX</b></a>]  Theorem
      
       P l. PREFIX P l  l
   
   [<a name="IS_PREFIX_REFL-val"><b>IS_PREFIX_REFL</b></a>]  Theorem
      
       x. x  x
   
   [<a name="IS_PREFIX_REVERSE-val"><b>IS_PREFIX_REVERSE</b></a>]  Theorem
      
       l1 l2. REVERSE l2  REVERSE l1  IS_SUFFIX l1 l2
   
   [<a name="IS_PREFIX_SNOC-val"><b>IS_PREFIX_SNOC</b></a>]  Theorem
      
       l  SNOC x l
   
   [<a name="IS_PREFIX_TRANS-val"><b>IS_PREFIX_TRANS</b></a>]  Theorem
      
       x y z. y  x  z  y  z  x
   
   [<a name="IS_SUBLIST_APPEND-val"><b>IS_SUBLIST_APPEND</b></a>]  Theorem
      
       l1 l2. IS_SUBLIST l1 l2  l l'. l1 = l  (l2  l')
   
   [<a name="IS_SUBLIST_REVERSE-val"><b>IS_SUBLIST_REVERSE</b></a>]  Theorem
      
       l1 l2. IS_SUBLIST (REVERSE l1) (REVERSE l2)  IS_SUBLIST l1 l2
   
   [<a name="IS_SUFFIX_ALL_DISTINCT-val"><b>IS_SUFFIX_ALL_DISTINCT</b></a>]  Theorem
      
       l l1. IS_SUFFIX l l1  ALL_DISTINCT l  ALL_DISTINCT l1
   
   [<a name="IS_SUFFIX_APPEND-val"><b>IS_SUFFIX_APPEND</b></a>]  Theorem
      
       l1 l2. IS_SUFFIX l1 l2  l. l1 = l  l2
   
   [<a name="IS_SUFFIX_APPEND1-val"><b>IS_SUFFIX_APPEND1</b></a>]  Theorem
      
       l1 l2 l. IS_SUFFIX l2 l  IS_SUFFIX (l1  l2) l
   
   [<a name="IS_SUFFIX_CONS-val"><b>IS_SUFFIX_CONS</b></a>]  Theorem
      
       l1 l2 a. IS_SUFFIX l1 l2  IS_SUFFIX (a::l1) l2
   
   [<a name="IS_SUFFIX_CONS2_E-val"><b>IS_SUFFIX_CONS2_E</b></a>]  Theorem
      
       s h t. IS_SUFFIX s (h::t)  IS_SUFFIX s t
   
   [<a name="IS_SUFFIX_EQ_DROP-val"><b>IS_SUFFIX_EQ_DROP</b></a>]  Theorem
      
       l l1. IS_SUFFIX l l1  n. n  LENGTH l  l1 = DROP n l
   
   [<a name="IS_SUFFIX_EQ_DROP'-val"><b>IS_SUFFIX_EQ_DROP'</b></a>]  Theorem
      
       l l1. IS_SUFFIX l l1  n. l1 = DROP n l
   
   [<a name="IS_SUFFIX_IMP_DROP-val"><b>IS_SUFFIX_IMP_DROP</b></a>]  Theorem
      
       l l1. IS_SUFFIX l l1  l1 = DROP (LENGTH l  LENGTH l1) l
   
   [<a name="IS_SUFFIX_IMP_LASTN-val"><b>IS_SUFFIX_IMP_LASTN</b></a>]  Theorem
      
       l l1. IS_SUFFIX l l1  l1 = LASTN (LENGTH l1) l
   
   [<a name="IS_SUFFIX_IS_SUBLIST-val"><b>IS_SUFFIX_IS_SUBLIST</b></a>]  Theorem
      
       l1 l2. IS_SUFFIX l1 l2  IS_SUBLIST l1 l2
   
   [<a name="IS_SUFFIX_REFL-val"><b>IS_SUFFIX_REFL</b></a>]  Theorem
      
       l. IS_SUFFIX l l
   
   [<a name="IS_SUFFIX_REVERSE-val"><b>IS_SUFFIX_REVERSE</b></a>]  Theorem
      
       l2 l1. IS_SUFFIX (REVERSE l1) (REVERSE l2)  l2  l1
   
   [<a name="IS_SUFFIX_TRANS-val"><b>IS_SUFFIX_TRANS</b></a>]  Theorem
      
       l1 l2 l3. IS_SUFFIX l1 l2  IS_SUFFIX l2 l3  IS_SUFFIX l1 l3
   
   [<a name="IS_SUFFIX_compute-val"><b>IS_SUFFIX_compute</b></a>]  Theorem
      
       l1 l2. IS_SUFFIX l1 l2  REVERSE l2  REVERSE l1
   
   [<a name="IS_SUFFIX_dropWhile-val"><b>IS_SUFFIX_dropWhile</b></a>]  Theorem
      
       IS_SUFFIX ls (dropWhile P ls)
   
   [<a name="ITSET_TO_FOLDR-val"><b>ITSET_TO_FOLDR</b></a>]  Theorem
      
       f s b.
          FINITE s  ITSET f s b = FOLDR f b (REVERSE (SET_TO_LIST s))
   
   [<a name="LAST-val"><b>LAST</b></a>]  Theorem
      
       x l. LAST (SNOC x l) = x
   
   [<a name="LASTN-val"><b>LASTN</b></a>]  Theorem
      
       (l. LASTN 0 l = []) 
        n x l. LASTN (SUC n) (SNOC x l) = SNOC x (LASTN n l)
   
   [<a name="LASTN_1-val"><b>LASTN_1</b></a>]  Theorem
      
       l. l  []  LASTN 1 l = [LAST l]
   
   [<a name="LASTN_APPEND1-val"><b>LASTN_APPEND1</b></a>]  Theorem
      
       l2 n.
          LENGTH l2  n 
          l1. LASTN n (l1  l2) = LASTN (n  LENGTH l2) l1  l2
   
   [<a name="LASTN_APPEND2-val"><b>LASTN_APPEND2</b></a>]  Theorem
      
       n l2. n  LENGTH l2  l1. LASTN n (l1  l2) = LASTN n l2
   
   [<a name="LASTN_BUTFIRSTN-val"><b>LASTN_BUTFIRSTN</b></a>]  Theorem
      
       n l. n  LENGTH l  LASTN n l = DROP (LENGTH l  n) l
   
   [<a name="LASTN_BUTLASTN-val"><b>LASTN_BUTLASTN</b></a>]  Theorem
      
       n m l.
          n + m  LENGTH l 
          LASTN n (BUTLASTN m l) = BUTLASTN m (LASTN (n + m) l)
   
   [<a name="LASTN_CONS-val"><b>LASTN_CONS</b></a>]  Theorem
      
       n l. n  LENGTH l  x. LASTN n (x::l) = LASTN n l
   
   [<a name="LASTN_DROP-val"><b>LASTN_DROP</b></a>]  Theorem
      
       n l. n  LENGTH l  LASTN n l = DROP (LENGTH l  n) l
   
   [<a name="LASTN_DROP_UNCOND-val"><b>LASTN_DROP_UNCOND</b></a>]  Theorem
      
       n l. LASTN n l = DROP (LENGTH l  n) l
   
   [<a name="LASTN_LASTN-val"><b>LASTN_LASTN</b></a>]  Theorem
      
       l n m. m  LENGTH l  n  m  LASTN n (LASTN m l) = LASTN n l
   
   [<a name="LASTN_LENGTH_APPEND-val"><b>LASTN_LENGTH_APPEND</b></a>]  Theorem
      
       l2 l1. LASTN (LENGTH l2) (l1  l2) = l2
   
   [<a name="LASTN_LENGTH_ID-val"><b>LASTN_LENGTH_ID</b></a>]  Theorem
      
       l. LASTN (LENGTH l) l = l
   
   [<a name="LASTN_MAP-val"><b>LASTN_MAP</b></a>]  Theorem
      
       n l. n  LENGTH l  f. LASTN n (MAP f l) = MAP f (LASTN n l)
   
   [<a name="LASTN_REVERSE-val"><b>LASTN_REVERSE</b></a>]  Theorem
      
       n l. n  LENGTH l  LASTN n (REVERSE l) = REVERSE (TAKE n l)
   
   [<a name="LASTN_SEG-val"><b>LASTN_SEG</b></a>]  Theorem
      
       n l. n  LENGTH l  LASTN n l = SEG n (LENGTH l  n) l
   
   [<a name="LASTN_compute-val"><b>LASTN_compute</b></a>]  Theorem
      
       n l.
          LASTN n l =
          (let
             m = LENGTH l
           in
             if n  m then DROP (m  n) l
             else FAIL LASTN $var$(longer than list) n l)
   
   [<a name="LAST_APPEND-val"><b>LAST_APPEND</b></a>]  Theorem
      
       h l1 l2. LAST (l1  h::l2) = LAST (h::l2)
   
   [<a name="LAST_APPEND_NOT_NIL-val"><b>LAST_APPEND_NOT_NIL</b></a>]  Theorem
      
       l1 l2. l2  []  LAST (l1  l2) = LAST l2
   
   [<a name="LAST_CONS-val"><b>LAST_CONS</b></a>]  Theorem
      
       (x. LAST [x] = x)  x y z. LAST (x::y::z) = LAST (y::z)
   
   [<a name="LAST_EL_CONS-val"><b>LAST_EL_CONS</b></a>]  Theorem
      
       h t. t  []  LAST t = EL (LENGTH t) (h::t)
   
   [<a name="LAST_EQ_HD-val"><b>LAST_EQ_HD</b></a>]  Theorem
      
       h t. MEM h t  LAST (h::t) = h  t = []
   
   [<a name="LAST_LASTN_LAST-val"><b>LAST_LASTN_LAST</b></a>]  Theorem
      
       n l. n  LENGTH l  0 &lt; n  LAST (LASTN n l) = LAST l
   
   [<a name="LAST_MEM-val"><b>LAST_MEM</b></a>]  Theorem
      
       ls. ls  []  MEM (LAST ls) ls
   
   [<a name="LENGTH-val"><b>LENGTH</b></a>]  Theorem
      
       LENGTH [] = 0  h t. LENGTH (h::t) = SUC (LENGTH t)
   
   [<a name="LENGTH_APPEND-val"><b>LENGTH_APPEND</b></a>]  Theorem
      
       l1 l2. LENGTH (l1  l2) = LENGTH l1 + LENGTH l2
   
   [<a name="LENGTH_BUTFIRSTN-val"><b>LENGTH_BUTFIRSTN</b></a>]  Theorem
      
       n l. LENGTH (DROP n l) = LENGTH l  n
   
   [<a name="LENGTH_BUTLAST-val"><b>LENGTH_BUTLAST</b></a>]  Theorem
      
       l. l  []  LENGTH (FRONT l) = PRE (LENGTH l)
   
   [<a name="LENGTH_BUTLASTN-val"><b>LENGTH_BUTLASTN</b></a>]  Theorem
      
       n l. n  LENGTH l  LENGTH (BUTLASTN n l) = LENGTH l  n
   
   [<a name="LENGTH_CONS-val"><b>LENGTH_CONS</b></a>]  Theorem
      
       l n. LENGTH l = SUC n  h l'. LENGTH l' = n  l = h::l'
   
   [<a name="LENGTH_COUNT_LIST-val"><b>LENGTH_COUNT_LIST</b></a>]  Theorem
      
       n. LENGTH (COUNT_LIST n) = n
   
   [<a name="LENGTH_DELETE_ELEMENT_LE-val"><b>LENGTH_DELETE_ELEMENT_LE</b></a>]  Theorem
      
       e L. MEM e L  LENGTH (DELETE_ELEMENT e L) &lt; LENGTH L
   
   [<a name="LENGTH_DELETE_ELEMENT_LEQ-val"><b>LENGTH_DELETE_ELEMENT_LEQ</b></a>]  Theorem
      
       e L. LENGTH (DELETE_ELEMENT e L)  LENGTH L
   
   [<a name="LENGTH_EQ_NIL-val"><b>LENGTH_EQ_NIL</b></a>]  Theorem
      
       P. (l. LENGTH l = 0  P l)  P []
   
   [<a name="LENGTH_FILTER_LEQ-val"><b>LENGTH_FILTER_LEQ</b></a>]  Theorem
      
       P l. LENGTH (FILTER P l)  LENGTH l
   
   [<a name="LENGTH_FILTER_LESS-val"><b>LENGTH_FILTER_LESS</b></a>]  Theorem
      
       P ls. EXISTS ($  P) ls  LENGTH (FILTER P ls) &lt; LENGTH ls
   
   [<a name="LENGTH_FIRSTN-val"><b>LENGTH_FIRSTN</b></a>]  Theorem
      
       n l. n  LENGTH l  LENGTH (TAKE n l) = n
   
   [<a name="LENGTH_FLAT-val"><b>LENGTH_FLAT</b></a>]  Theorem
      
       l. LENGTH (FLAT l) = SUM (MAP LENGTH l)
   
   [<a name="LENGTH_FLAT_REPLICATE-val"><b>LENGTH_FLAT_REPLICATE</b></a>]  Theorem
      
       n. LENGTH (FLAT (REPLICATE n ls)) = n * LENGTH ls
   
   [<a name="LENGTH_FOLDL-val"><b>LENGTH_FOLDL</b></a>]  Theorem
      
       l. LENGTH l = FOLDL (l' x. SUC l') 0 l
   
   [<a name="LENGTH_FOLDR-val"><b>LENGTH_FOLDR</b></a>]  Theorem
      
       l. LENGTH l = FOLDR (x l'. SUC l') 0 l
   
   [<a name="LENGTH_FRONT-val"><b>LENGTH_FRONT</b></a>]  Theorem
      
       l. l  []  LENGTH (FRONT l) = PRE (LENGTH l)
   
   [<a name="LENGTH_GENLIST-val"><b>LENGTH_GENLIST</b></a>]  Theorem
      
       f n. LENGTH (GENLIST f n) = n
   
   [<a name="LENGTH_LASTN-val"><b>LENGTH_LASTN</b></a>]  Theorem
      
       n l. n  LENGTH l  LENGTH (LASTN n l) = n
   
   [<a name="LENGTH_MAP-val"><b>LENGTH_MAP</b></a>]  Theorem
      
       l f. LENGTH (MAP f l) = LENGTH l
   
   [<a name="LENGTH_NIL-val"><b>LENGTH_NIL</b></a>]  Theorem
      
       l. LENGTH l = 0  l = []
   
   [<a name="LENGTH_NOT_NULL-val"><b>LENGTH_NOT_NULL</b></a>]  Theorem
      
       l. 0 &lt; LENGTH l  NULL l
   
   [<a name="LENGTH_REPLICATE-val"><b>LENGTH_REPLICATE</b></a>]  Theorem
      
       n x. LENGTH (REPLICATE n x) = n
   
   [<a name="LENGTH_REVERSE-val"><b>LENGTH_REVERSE</b></a>]  Theorem
      
       l. LENGTH (REVERSE l) = LENGTH l
   
   [<a name="LENGTH_SCANL-val"><b>LENGTH_SCANL</b></a>]  Theorem
      
       f e l. LENGTH (SCANL f e l) = SUC (LENGTH l)
   
   [<a name="LENGTH_SCANR-val"><b>LENGTH_SCANR</b></a>]  Theorem
      
       f e l. LENGTH (SCANR f e l) = SUC (LENGTH l)
   
   [<a name="LENGTH_SEG-val"><b>LENGTH_SEG</b></a>]  Theorem
      
       n k l. n + k  LENGTH l  LENGTH (SEG n k l) = n
   
   [<a name="LENGTH_SING-val"><b>LENGTH_SING</b></a>]  Theorem
      
       x. LENGTH [x] = 1
   
   [<a name="LENGTH_SNOC-val"><b>LENGTH_SNOC</b></a>]  Theorem
      
       x l. LENGTH (SNOC x l) = SUC (LENGTH l)
   
   [<a name="LENGTH_TAKE_LE-val"><b>LENGTH_TAKE_LE</b></a>]  Theorem
      
       n l. LENGTH (TAKE n l)  LENGTH l
   
   [<a name="LENGTH_TL_LT-val"><b>LENGTH_TL_LT</b></a>]  Theorem
      
       ls. ls  []  LENGTH (TL ls) &lt; LENGTH ls
   
   [<a name="LENGTH_UNZIP_FST-val"><b>LENGTH_UNZIP_FST</b></a>]  Theorem
      
       l. LENGTH (UNZIP_FST l) = LENGTH l
   
   [<a name="LENGTH_UNZIP_SND-val"><b>LENGTH_UNZIP_SND</b></a>]  Theorem
      
       l. LENGTH (UNZIP_SND l) = LENGTH l
   
   [<a name="LENGTH_ZIP-val"><b>LENGTH_ZIP</b></a>]  Theorem
      
       l1 l2.
          LENGTH l1 = LENGTH l2 
          LENGTH (ZIP (l1,l2)) = LENGTH l1 
          LENGTH (ZIP (l1,l2)) = LENGTH l2
   
   [<a name="LENGTH_chunks-val"><b>LENGTH_chunks</b></a>]  Theorem
      
       n ls.
          0 &lt; n  NULL ls 
          LENGTH (chunks n ls) =
          LENGTH ls DIV n + bool_to_bit (divides n (LENGTH ls))
   
   [<a name="LENGTH_dropWhile_id-val"><b>LENGTH_dropWhile_id</b></a>]  Theorem
      
       LENGTH (dropWhile P ls) = LENGTH ls  dropWhile P ls = ls
   
   [<a name="LIST_ELEM_COUNT_CARD_EL-val"><b>LIST_ELEM_COUNT_CARD_EL</b></a>]  Theorem
      
       ls. LIST_ELEM_COUNT x ls = CARD {n | n &lt; LENGTH ls  EL n ls = x}
   
   [<a name="LIST_ELEM_COUNT_MEM-val"><b>LIST_ELEM_COUNT_MEM</b></a>]  Theorem
      
       e l. LIST_ELEM_COUNT e l &gt; 0  MEM e l
   
   [<a name="LIST_ELEM_COUNT_THM-val"><b>LIST_ELEM_COUNT_THM</b></a>]  Theorem
      
       (e. LIST_ELEM_COUNT e [] = 0) 
        (e l1 l2.
           LIST_ELEM_COUNT e (l1  l2) =
           LIST_ELEM_COUNT e l1 + LIST_ELEM_COUNT e l2) 
        (e h l.
           h = e  LIST_ELEM_COUNT e (h::l) = SUC (LIST_ELEM_COUNT e l)) 
        e h l. h  e  LIST_ELEM_COUNT e (h::l) = LIST_ELEM_COUNT e l
   
   [<a name="LIST_EQ_HEAD_TAIL-val"><b>LIST_EQ_HEAD_TAIL</b></a>]  Theorem
      
       p q. p  []  q  []  (p = q  HD p = HD q  TL p = TL q)
   
   [<a name="LIST_HEAD_TAIL-val"><b>LIST_HEAD_TAIL</b></a>]  Theorem
      
       ls. 0 &lt; LENGTH ls  ls = HD ls::TL ls
   
   [<a name="LIST_NOT_EQ-val"><b>LIST_NOT_EQ</b></a>]  Theorem
      
       l1 l2. l1  l2  h1 h2. h1::l1  h2::l2
   
   [<a name="LIST_REL_APPEND_SING-val"><b>LIST_REL_APPEND_SING</b></a>]  Theorem
      
       LIST_REL R (l1  [x1]) (l2  [x2])  LIST_REL R l1 l2  R x1 x2
   
   [<a name="LIST_REL_GENLIST-val"><b>LIST_REL_GENLIST</b></a>]  Theorem
      
       LIST_REL P (GENLIST f l) (GENLIST g l)  i. i &lt; l  P (f i) (g i)
   
   [<a name="LIST_REL_REPLICATE_same-val"><b>LIST_REL_REPLICATE_same</b></a>]  Theorem
      
       LIST_REL P (REPLICATE n x) (REPLICATE n y)  0 &lt; n  P x y
   
   [<a name="LIST_REL_REVERSE_EQ-val"><b>LIST_REL_REVERSE_EQ</b></a>]  Theorem
      
       LIST_REL R (REVERSE l1) (REVERSE l2)  LIST_REL R l1 l2
   
   [<a name="LIST_SING_EQ-val"><b>LIST_SING_EQ</b></a>]  Theorem
      
       x y. [x] = [y]  x = y
   
   [<a name="LIST_TO_SET_EQ_SING-val"><b>LIST_TO_SET_EQ_SING</b></a>]  Theorem
      
       x ls. set ls = {x}  ls  []  EVERY ($= x) ls
   
   [<a name="LIST_TO_SET_PREFIX-val"><b>LIST_TO_SET_PREFIX</b></a>]  Theorem
      
       l l1. l1  l  set l1  set l
   
   [<a name="LIST_TO_SET_SING_IFF-val"><b>LIST_TO_SET_SING_IFF</b></a>]  Theorem
      
       ls. ls  []  (SING (set ls)  c. ls = GENLIST (K c) (LENGTH ls))
   
   [<a name="LIST_TO_SET_SUFFIX-val"><b>LIST_TO_SET_SUFFIX</b></a>]  Theorem
      
       l l1. IS_SUFFIX l l1  set l1  set l
   
   [<a name="LUPDATE_APPEND1-val"><b>LUPDATE_APPEND1</b></a>]  Theorem
      
       l1 l2 n x.
          n &lt; LENGTH l1  LUPDATE x n (l1  l2) = LUPDATE x n l1  l2
   
   [<a name="LUPDATE_APPEND2-val"><b>LUPDATE_APPEND2</b></a>]  Theorem
      
       l1 l2 n x.
          LENGTH l1  n 
          LUPDATE x n (l1  l2) = l1  LUPDATE x (n  LENGTH l1) l2
   
   [<a name="MAP-val"><b>MAP</b></a>]  Theorem
      
       (f. MAP f [] = [])  f h t. MAP f (h::t) = f h::MAP f t
   
   [<a name="MAP2-val"><b>MAP2</b></a>]  Theorem
      
       (f. MAP2 f [] [] = []) 
        f h1 t1 h2 t2. MAP2 f (h1::t1) (h2::t2) = f h1 h2::MAP2 f t1 t2
   
   [<a name="MAP2_MAP_MAP-val"><b>MAP2_MAP_MAP</b></a>]  Theorem
      
       ls f g1 g2.
          MAP2 f (MAP g1 ls) (MAP g2 ls) = MAP (x. f (g1 x) (g2 x)) ls
   
   [<a name="MAP2_ZIP-val"><b>MAP2_ZIP</b></a>]  Theorem
      
       l1 l2.
          LENGTH l1 = LENGTH l2 
          f. MAP2 f l1 l2 = MAP (UNCURRY f) (ZIP (l1,l2))
   
   [<a name="MAP_APPEND-val"><b>MAP_APPEND</b></a>]  Theorem
      
       f l1 l2. MAP f (l1  l2) = MAP f l1  MAP f l2
   
   [<a name="MAP_COUNT_LIST-val"><b>MAP_COUNT_LIST</b></a>]  Theorem
      
       MAP f (COUNT_LIST n) = GENLIST f n
   
   [<a name="MAP_EQ_f-val"><b>MAP_EQ_f</b></a>]  Theorem
      
       f1 f2 l. MAP f1 l = MAP f2 l  e. MEM e l  f1 e = f2 e
   
   [<a name="MAP_FILTER-val"><b>MAP_FILTER</b></a>]  Theorem
      
       f P l.
          (x. P (f x)  P x)  MAP f (FILTER P l) = FILTER P (MAP f l)
   
   [<a name="MAP_FLAT-val"><b>MAP_FLAT</b></a>]  Theorem
      
       f l. MAP f (FLAT l) = FLAT (MAP (MAP f) l)
   
   [<a name="MAP_FOLDL-val"><b>MAP_FOLDL</b></a>]  Theorem
      
       f l. MAP f l = FOLDL (l' x. SNOC (f x) l') [] l
   
   [<a name="MAP_FOLDR-val"><b>MAP_FOLDR</b></a>]  Theorem
      
       f l. MAP f l = FOLDR (x l'. f x::l') [] l
   
   [<a name="MAP_FST_funs-val"><b>MAP_FST_funs</b></a>]  Theorem
      
       MAP ((x,y,z). x) funs = MAP FST funs
   
   [<a name="MAP_GENLIST-val"><b>MAP_GENLIST</b></a>]  Theorem
      
       f g n. MAP f (GENLIST g n) = GENLIST (f  g) n
   
   [<a name="MAP_HD-val"><b>MAP_HD</b></a>]  Theorem
      
       ls f. ls  []  HD (MAP f ls) = f (HD ls)
   
   [<a name="MAP_MAP_o-val"><b>MAP_MAP_o</b></a>]  Theorem
      
       f g l. MAP f (MAP g l) = MAP (f  g) l
   
   [<a name="MAP_REVERSE-val"><b>MAP_REVERSE</b></a>]  Theorem
      
       f l. MAP f (REVERSE l) = REVERSE (MAP f l)
   
   [<a name="MAP_SING-val"><b>MAP_SING</b></a>]  Theorem
      
       f x. MAP f [x] = [f x]
   
   [<a name="MAP_SND_FILTER_NEQ-val"><b>MAP_SND_FILTER_NEQ</b></a>]  Theorem
      
       MAP SND (FILTER ((x,y). y  z) ls) =
        FILTER (y. z  y) (MAP SND ls)
   
   [<a name="MAP_SNOC-val"><b>MAP_SNOC</b></a>]  Theorem
      
       f x l. MAP f (SNOC x l) = SNOC (f x) (MAP f l)
   
   [<a name="MAP_SUBLIST-val"><b>MAP_SUBLIST</b></a>]  Theorem
      
       f p q. p  q  MAP f p  MAP f q
   
   [<a name="MAP_o-val"><b>MAP_o</b></a>]  Theorem
      
       f g. MAP (f  g) = MAP f  MAP g
   
   [<a name="MAX_LIST_CONS-val"><b>MAX_LIST_CONS</b></a>]  Theorem
      
       h t. MAX_LIST (h::t) = MAX h (MAX_LIST t)
   
   [<a name="MAX_LIST_EQ_0-val"><b>MAX_LIST_EQ_0</b></a>]  Theorem
      
       l. MAX_LIST l = 0  EVERY (x. x = 0) l
   
   [<a name="MAX_LIST_LE-val"><b>MAX_LIST_LE</b></a>]  Theorem
      
       h t. MAX_LIST t  MAX_LIST (h::t)
   
   [<a name="MAX_LIST_MAP_LE-val"><b>MAX_LIST_MAP_LE</b></a>]  Theorem
      
       f g.
          (x. f x  g x)  ls. MAX_LIST (MAP f ls)  MAX_LIST (MAP g ls)
   
   [<a name="MAX_LIST_MEM-val"><b>MAX_LIST_MEM</b></a>]  Theorem
      
       l. l  []  MEM (MAX_LIST l) l
   
   [<a name="MAX_LIST_MONO_DEC-val"><b>MAX_LIST_MONO_DEC</b></a>]  Theorem
      
       ls. ls  []  MONO_DEC ls  MAX_LIST ls = HD ls
   
   [<a name="MAX_LIST_MONO_INC-val"><b>MAX_LIST_MONO_INC</b></a>]  Theorem
      
       ls. ls  []  MONO_INC ls  MAX_LIST ls = LAST ls
   
   [<a name="MAX_LIST_NIL-val"><b>MAX_LIST_NIL</b></a>]  Theorem
      
       MAX_LIST [] = 0
   
   [<a name="MAX_LIST_PROPERTY-val"><b>MAX_LIST_PROPERTY</b></a>]  Theorem
      
       l x. MEM x l  x  MAX_LIST l
   
   [<a name="MAX_LIST_SING-val"><b>MAX_LIST_SING</b></a>]  Theorem
      
       x. MAX_LIST [x] = x
   
   [<a name="MAX_LIST_TEST-val"><b>MAX_LIST_TEST</b></a>]  Theorem
      
       l. l  []  x. MEM x l  (y. MEM y l  y  x)  x = MAX_LIST l
   
   [<a name="MEM_APPEND_3-val"><b>MEM_APPEND_3</b></a>]  Theorem
      
       l1 x l2 h. MEM h (l1  [x]  l2)  MEM h (x::(l1  l2))
   
   [<a name="MEM_BUTLASTN-val"><b>MEM_BUTLASTN</b></a>]  Theorem
      
       l m x. MEM x (BUTLASTN m l)  MEM x l
   
   [<a name="MEM_COUNT_LIST-val"><b>MEM_COUNT_LIST</b></a>]  Theorem
      
       m n. MEM m (COUNT_LIST n)  m &lt; n
   
   [<a name="MEM_DROP_IMP-val"><b>MEM_DROP_IMP</b></a>]  Theorem
      
       l m x. MEM x (DROP m l)  MEM x l
   
   [<a name="MEM_EXISTS-val"><b>MEM_EXISTS</b></a>]  Theorem
      
       x l. MEM x l  EXISTS ($= x) l
   
   [<a name="MEM_FOLDL-val"><b>MEM_FOLDL</b></a>]  Theorem
      
       y l. MEM y l  FOLDL (l' x. l'  y = x) F l
   
   [<a name="MEM_FOLDL_MAP-val"><b>MEM_FOLDL_MAP</b></a>]  Theorem
      
       x l. MEM x l  FOLDL $\/ F (MAP ($= x) l)
   
   [<a name="MEM_FOLDR-val"><b>MEM_FOLDR</b></a>]  Theorem
      
       y l. MEM y l  FOLDR (x l'. y = x  l') F l
   
   [<a name="MEM_FOLDR_MAP-val"><b>MEM_FOLDR_MAP</b></a>]  Theorem
      
       x l. MEM x l  FOLDR $\/ F (MAP ($= x) l)
   
   [<a name="MEM_FRONT-val"><b>MEM_FRONT</b></a>]  Theorem
      
       l e y. MEM y (FRONT (e::l))  MEM y (e::l)
   
   [<a name="MEM_FRONT_NOT_LAST-val"><b>MEM_FRONT_NOT_LAST</b></a>]  Theorem
      
       ls. ls  []  ALL_DISTINCT ls  MEM (LAST ls) (FRONT ls)
   
   [<a name="MEM_FRONT_NOT_NIL-val"><b>MEM_FRONT_NOT_NIL</b></a>]  Theorem
      
       l y. l  []  MEM y (FRONT l)  MEM y l
   
   [<a name="MEM_LAST-val"><b>MEM_LAST</b></a>]  Theorem
      
       e l. MEM (LAST (e::l)) (e::l)
   
   [<a name="MEM_LASTN-val"><b>MEM_LASTN</b></a>]  Theorem
      
       m l x. MEM x (LASTN m l)  MEM x l
   
   [<a name="MEM_LAST_FRONT-val"><b>MEM_LAST_FRONT</b></a>]  Theorem
      
       e l h. MEM e l  e  LAST (h::l)  MEM e (FRONT (h::l))
   
   [<a name="MEM_LAST_NOT_NIL-val"><b>MEM_LAST_NOT_NIL</b></a>]  Theorem
      
       e l. l  []  MEM (LAST l) l
   
   [<a name="MEM_REPLICATE-val"><b>MEM_REPLICATE</b></a>]  Theorem
      
       n x y. MEM y (REPLICATE n x)  x = y  0 &lt; n
   
   [<a name="MEM_SEG-val"><b>MEM_SEG</b></a>]  Theorem
      
       n m l. n + m  LENGTH l  x. MEM x (SEG n m l)  MEM x l
   
   [<a name="MEM_SING_APPEND-val"><b>MEM_SING_APPEND</b></a>]  Theorem
      
       (a c. d  a  [b]  c)  MEM b d
   
   [<a name="MEM_SPLIT_APPEND_distinct-val"><b>MEM_SPLIT_APPEND_distinct</b></a>]  Theorem
      
       l. ALL_DISTINCT l 
            x. MEM x l  p1 p2. l = p1  [x]  p2  MEM x p1  MEM x p2
   
   [<a name="MEM_SPLIT_TAKE_DROP_distinct-val"><b>MEM_SPLIT_TAKE_DROP_distinct</b></a>]  Theorem
      
       ls.
          ALL_DISTINCT ls 
          x. MEM x ls 
              k. k &lt; LENGTH ls  x = EL k ls 
                  ls = TAKE k ls  x::DROP (k + 1) ls 
                  MEM x (TAKE k ls)  MEM x (DROP (k + 1) ls)
   
   [<a name="MEM_SPLIT_TAKE_DROP_first-val"><b>MEM_SPLIT_TAKE_DROP_first</b></a>]  Theorem
      
       ls x.
          MEM x ls 
          k. k &lt; LENGTH ls  x = EL k ls 
              ls = TAKE k ls  x::DROP (k + 1) ls  MEM x (TAKE k ls)
   
   [<a name="MEM_SPLIT_TAKE_DROP_last-val"><b>MEM_SPLIT_TAKE_DROP_last</b></a>]  Theorem
      
       ls x.
          MEM x ls 
          k. k &lt; LENGTH ls  x = EL k ls 
              ls = TAKE k ls  x::DROP (k + 1) ls 
              MEM x (DROP (k + 1) ls)
   
   [<a name="MEM_TAKE-val"><b>MEM_TAKE</b></a>]  Theorem
      
       l m x. MEM x (TAKE m l)  MEM x l
   
   [<a name="MIN_LIST_CONS-val"><b>MIN_LIST_CONS</b></a>]  Theorem
      
       h t. t  []  MIN_LIST (h::t) = MIN h (MIN_LIST t)
   
   [<a name="MIN_LIST_LE-val"><b>MIN_LIST_LE</b></a>]  Theorem
      
       h t. t  []  MIN_LIST (h::t)  MIN_LIST t
   
   [<a name="MIN_LIST_LE_MAX_LIST-val"><b>MIN_LIST_LE_MAX_LIST</b></a>]  Theorem
      
       l. l  []  MIN_LIST l  MAX_LIST l
   
   [<a name="MIN_LIST_MAP_LE-val"><b>MIN_LIST_MAP_LE</b></a>]  Theorem
      
       f g.
          (x. f x  g x)  ls. MIN_LIST (MAP f ls)  MIN_LIST (MAP g ls)
   
   [<a name="MIN_LIST_MEM-val"><b>MIN_LIST_MEM</b></a>]  Theorem
      
       l. l  []  MEM (MIN_LIST l) l
   
   [<a name="MIN_LIST_MONO_DEC-val"><b>MIN_LIST_MONO_DEC</b></a>]  Theorem
      
       ls. ls  []  MONO_DEC ls  MIN_LIST ls = LAST ls
   
   [<a name="MIN_LIST_MONO_INC-val"><b>MIN_LIST_MONO_INC</b></a>]  Theorem
      
       ls. ls  []  MONO_INC ls  MIN_LIST ls = HD ls
   
   [<a name="MIN_LIST_PROPERTY-val"><b>MIN_LIST_PROPERTY</b></a>]  Theorem
      
       l. l  []  x. MEM x l  MIN_LIST l  x
   
   [<a name="MIN_LIST_SING-val"><b>MIN_LIST_SING</b></a>]  Theorem
      
       x. MIN_LIST [x] = x
   
   [<a name="MIN_LIST_TEST-val"><b>MIN_LIST_TEST</b></a>]  Theorem
      
       l. l  []  x. MEM x l  (y. MEM y l  x  y)  x = MIN_LIST l
   
   [<a name="MONOID_APPEND_NIL-val"><b>MONOID_APPEND_NIL</b></a>]  Theorem
      
       MONOID $++ []
   
   [<a name="MONOLIST_EQ-val"><b>MONOLIST_EQ</b></a>]  Theorem
      
       l1 l2.
          SING (set l1)  SING (set l2) 
          (l1 = l2  LENGTH l1 = LENGTH l2  set l1 = set l2)
   
   [<a name="MONOLIST_SET_SING-val"><b>MONOLIST_SET_SING</b></a>]  Theorem
      
       c ls. ls  []  EVERY ($= c) ls  SING (set ls)
   
   [<a name="MONO_DEC_CONS-val"><b>MONO_DEC_CONS</b></a>]  Theorem
      
       h t. MONO_DEC (h::t)  MONO_DEC t
   
   [<a name="MONO_DEC_HD-val"><b>MONO_DEC_HD</b></a>]  Theorem
      
       h t x. MONO_DEC (h::t)  MEM x t  x  h
   
   [<a name="MONO_DEC_NIL-val"><b>MONO_DEC_NIL</b></a>]  Theorem
      
       MONO_DEC []
   
   [<a name="MONO_INC_CONS-val"><b>MONO_INC_CONS</b></a>]  Theorem
      
       h t. MONO_INC (h::t)  MONO_INC t
   
   [<a name="MONO_INC_HD-val"><b>MONO_INC_HD</b></a>]  Theorem
      
       h t x. MONO_INC (h::t)  MEM x t  h  x
   
   [<a name="MONO_INC_NIL-val"><b>MONO_INC_NIL</b></a>]  Theorem
      
       MONO_INC []
   
   [<a name="NIL_IN_common_prefixes-val"><b>NIL_IN_common_prefixes</b></a>]  Theorem
      
       []  common_prefixes s
   
   [<a name="NIL_NO_MEM-val"><b>NIL_NO_MEM</b></a>]  Theorem
      
       ls. ls = []  x. MEM x ls
   
   [<a name="NON_MONO_TAIL_PROPERTY-val"><b>NON_MONO_TAIL_PROPERTY</b></a>]  Theorem
      
       l. SING (set (h::t))  h'. MEM h' t  h'  h
   
   [<a name="NOT_ALL_EL_SOME_EL-val"><b>NOT_ALL_EL_SOME_EL</b></a>]  Theorem
      
       P l. EVERY P l  EXISTS ($  P) l
   
   [<a name="NOT_CONS_NIL-val"><b>NOT_CONS_NIL</b></a>]  Theorem
      
       a1 a0. a0::a1  []
   
   [<a name="NOT_EQ_LIST-val"><b>NOT_EQ_LIST</b></a>]  Theorem
      
       h1 h2. h1  h2  l1 l2. h1::l1  h2::l2
   
   [<a name="NOT_IN_DELETE_ELEMENT-val"><b>NOT_IN_DELETE_ELEMENT</b></a>]  Theorem
      
       e L. MEM e (DELETE_ELEMENT e L)
   
   [<a name="NOT_NIL_CONS-val"><b>NOT_NIL_CONS</b></a>]  Theorem
      
       a1 a0. []  a0::a1
   
   [<a name="NOT_NIL_SNOC-val"><b>NOT_NIL_SNOC</b></a>]  Theorem
      
       x l. []  SNOC x l
   
   [<a name="NOT_NULL_SNOC-val"><b>NOT_NULL_SNOC</b></a>]  Theorem
      
       x l. NULL (SNOC x l)
   
   [<a name="NOT_SNOC_NIL-val"><b>NOT_SNOC_NIL</b></a>]  Theorem
      
       x l. SNOC x l  []
   
   [<a name="NOT_SOME_EL_ALL_EL-val"><b>NOT_SOME_EL_ALL_EL</b></a>]  Theorem
      
       P l. EXISTS P l  EVERY ($  P) l
   
   [<a name="NULL-val"><b>NULL</b></a>]  Theorem
      
       NULL []  h t. NULL (h::t)
   
   [<a name="NULL_DEF-val"><b>NULL_DEF</b></a>]  Theorem
      
       (NULL []  T)  h t. NULL (h::t)  F
   
   [<a name="NULL_EQ_NIL-val"><b>NULL_EQ_NIL</b></a>]  Theorem
      
       l. NULL l  l = []
   
   [<a name="NULL_FOLDL-val"><b>NULL_FOLDL</b></a>]  Theorem
      
       l. NULL l  FOLDL (x l'. F) T l
   
   [<a name="NULL_FOLDR-val"><b>NULL_FOLDR</b></a>]  Theorem
      
       l. NULL l  FOLDR (x l'. F) T l
   
   [<a name="OR_EL_FOLDL-val"><b>OR_EL_FOLDL</b></a>]  Theorem
      
       l. OR_EL l  FOLDL $\/ F l
   
   [<a name="OR_EL_FOLDR-val"><b>OR_EL_FOLDR</b></a>]  Theorem
      
       l. OR_EL l  FOLDR $\/ F l
   
   [<a name="PREFIX-val"><b>PREFIX</b></a>]  Theorem
      
       (P. PREFIX P [] = []) 
        P x l. PREFIX P (x::l) = if P x then x::PREFIX P l else []
   
   [<a name="PREFIX_FOLDR-val"><b>PREFIX_FOLDR</b></a>]  Theorem
      
       P l. PREFIX P l = FOLDR (x l'. if P x then x::l' else []) [] l
   
   [<a name="REPLICATE_APPEND-val"><b>REPLICATE_APPEND</b></a>]  Theorem
      
       REPLICATE n a  REPLICATE m a = REPLICATE (n + m) a
   
   [<a name="REPLICATE_EQ_CONS-val"><b>REPLICATE_EQ_CONS</b></a>]  Theorem
      
       REPLICATE n x = y::r  y = x  m. n = SUC m  r = REPLICATE m x
   
   [<a name="REPLICATE_GENLIST-val"><b>REPLICATE_GENLIST</b></a>]  Theorem
      
       n x. REPLICATE n x = GENLIST (K x) n
   
   [<a name="REPLICATE_NIL-val"><b>REPLICATE_NIL</b></a>]  Theorem
      
       REPLICATE x y = []  x = 0
   
   [<a name="REPLICATE_compute-val"><b>REPLICATE_compute</b></a>]  Theorem
      
       (x. REPLICATE 0 x = []) 
        (n x.
           REPLICATE &lt;..num comp'n..&gt; x =
           x::REPLICATE (&lt;..num comp'n..&gt;  1) x) 
        n x.
          REPLICATE &lt;..num comp'n..&gt; x = x::REPLICATE &lt;..num comp'n..&gt; x
   
   [<a name="REVERSE_APPEND-val"><b>REVERSE_APPEND</b></a>]  Theorem
      
       l1 l2. REVERSE (l1  l2) = REVERSE l2  REVERSE l1
   
   [<a name="REVERSE_DROP-val"><b>REVERSE_DROP</b></a>]  Theorem
      
       ls n.
          n  LENGTH ls 
          REVERSE (DROP n ls) = REVERSE (LASTN (LENGTH ls  n) ls)
   
   [<a name="REVERSE_EQ_NIL-val"><b>REVERSE_EQ_NIL</b></a>]  Theorem
      
       REVERSE l = []  l = []
   
   [<a name="REVERSE_FLAT-val"><b>REVERSE_FLAT</b></a>]  Theorem
      
       l. REVERSE (FLAT l) = FLAT (REVERSE (MAP REVERSE l))
   
   [<a name="REVERSE_FOLDL-val"><b>REVERSE_FOLDL</b></a>]  Theorem
      
       l. REVERSE l = FOLDL (l' x. x::l') [] l
   
   [<a name="REVERSE_FOLDR-val"><b>REVERSE_FOLDR</b></a>]  Theorem
      
       l. REVERSE l = FOLDR SNOC [] l
   
   [<a name="REVERSE_HD-val"><b>REVERSE_HD</b></a>]  Theorem
      
       ls. ls  []  HD (REVERSE ls) = LAST ls
   
   [<a name="REVERSE_REPLICATE-val"><b>REVERSE_REPLICATE</b></a>]  Theorem
      
       n x. REVERSE (REPLICATE n x) = REPLICATE n x
   
   [<a name="REVERSE_REVERSE-val"><b>REVERSE_REVERSE</b></a>]  Theorem
      
       l. REVERSE (REVERSE l) = l
   
   [<a name="REVERSE_SING-val"><b>REVERSE_SING</b></a>]  Theorem
      
       x. REVERSE [x] = [x]
   
   [<a name="REVERSE_SNOC-val"><b>REVERSE_SNOC</b></a>]  Theorem
      
       x l. REVERSE (SNOC x l) = x::REVERSE l
   
   [<a name="REVERSE_TL-val"><b>REVERSE_TL</b></a>]  Theorem
      
       ls. ls  []  TL (REVERSE ls) = REVERSE (FRONT ls)
   
   [<a name="REVERSE_ZIP-val"><b>REVERSE_ZIP</b></a>]  Theorem
      
       l1 l2.
          LENGTH l1 = LENGTH l2 
          REVERSE (ZIP (l1,l2)) = ZIP (REVERSE l1,REVERSE l2)
   
   [<a name="SEG1-val"><b>SEG1</b></a>]  Theorem
      
       n l. n &lt; LENGTH l  SEG 1 n l = [EL n l]
   
   [<a name="SEG_0_SNOC-val"><b>SEG_0_SNOC</b></a>]  Theorem
      
       m l x. m  LENGTH l  SEG m 0 (SNOC x l) = SEG m 0 l
   
   [<a name="SEG_APPEND-val"><b>SEG_APPEND</b></a>]  Theorem
      
       m l1 n l2.
          m &lt; LENGTH l1  LENGTH l1  n + m  n + m  LENGTH l1 + LENGTH l2 
          SEG n m (l1  l2) =
          SEG (LENGTH l1  m) m l1  SEG (n + m  LENGTH l1) 0 l2
   
   [<a name="SEG_APPEND1-val"><b>SEG_APPEND1</b></a>]  Theorem
      
       n m l1. n + m  LENGTH l1  l2. SEG n m (l1  l2) = SEG n m l1
   
   [<a name="SEG_APPEND2-val"><b>SEG_APPEND2</b></a>]  Theorem
      
       l1 m n l2.
          LENGTH l1  m  n  LENGTH l2 
          SEG n m (l1  l2) = SEG n (m  LENGTH l1) l2
   
   [<a name="SEG_CONS-val"><b>SEG_CONS</b></a>]  Theorem
      
       j n h t.
          0 &lt; j  n + j  LENGTH t + 1  SEG n j (h::t) = SEG n (j  1) t
   
   [<a name="SEG_LASTN_BUTLASTN-val"><b>SEG_LASTN_BUTLASTN</b></a>]  Theorem
      
       n m l.
          n + m  LENGTH l 
          SEG n m l = LASTN n (BUTLASTN (LENGTH l  (n + m)) l)
   
   [<a name="SEG_LENGTH_ID-val"><b>SEG_LENGTH_ID</b></a>]  Theorem
      
       l. SEG (LENGTH l) 0 l = l
   
   [<a name="SEG_LENGTH_SNOC-val"><b>SEG_LENGTH_SNOC</b></a>]  Theorem
      
       l x. SEG 1 (LENGTH l) (SNOC x l) = [x]
   
   [<a name="SEG_REVERSE-val"><b>SEG_REVERSE</b></a>]  Theorem
      
       n m l.
          n + m  LENGTH l 
          SEG n m (REVERSE l) = REVERSE (SEG n (LENGTH l  (n + m)) l)
   
   [<a name="SEG_SEG-val"><b>SEG_SEG</b></a>]  Theorem
      
       n1 m1 n2 m2 l.
          n1 + m1  LENGTH l  n2 + m2  n1 
          SEG n2 m2 (SEG n1 m1 l) = SEG n2 (m1 + m2) l
   
   [<a name="SEG_SNOC-val"><b>SEG_SNOC</b></a>]  Theorem
      
       n m l. n + m  LENGTH l  x. SEG n m (SNOC x l) = SEG n m l
   
   [<a name="SEG_SUC_CONS-val"><b>SEG_SUC_CONS</b></a>]  Theorem
      
       m n l x. SEG m (SUC n) (x::l) = SEG m n l
   
   [<a name="SEG_SUC_EL-val"><b>SEG_SUC_EL</b></a>]  Theorem
      
       n i l.
          i + n &lt; LENGTH l  SEG (SUC n) i l = EL i l::SEG n (i + 1) l
   
   [<a name="SEG_TAKE_DROP-val"><b>SEG_TAKE_DROP</b></a>]  Theorem
      
       n m l. n + m  LENGTH l  SEG n m l = TAKE n (DROP m l)
   
   [<a name="SEG_compute-val"><b>SEG_compute</b></a>]  Theorem
      
       (k l. SEG 0 k l = []) 
        (m x l.
           SEG &lt;..num comp'n..&gt; 0 (x::l) =
           x::SEG (&lt;..num comp'n..&gt;  1) 0 l) 
        (m x l.
           SEG &lt;..num comp'n..&gt; 0 (x::l) = x::SEG &lt;..num comp'n..&gt; 0 l) 
        (m k x l.
           SEG &lt;..num comp'n..&gt; &lt;..num comp'n..&gt; (x::l) =
           SEG &lt;..num comp'n..&gt; (&lt;..num comp'n..&gt;  1) l) 
        (m k x l.
           SEG &lt;..num comp'n..&gt; &lt;..num comp'n..&gt; (x::l) =
           SEG &lt;..num comp'n..&gt; (&lt;..num comp'n..&gt;  1) l) 
        (m k x l.
           SEG &lt;..num comp'n..&gt; &lt;..num comp'n..&gt; (x::l) =
           SEG &lt;..num comp'n..&gt; &lt;..num comp'n..&gt; l) 
        m k x l.
          SEG &lt;..num comp'n..&gt; &lt;..num comp'n..&gt; (x::l) =
          SEG &lt;..num comp'n..&gt; &lt;..num comp'n..&gt; l
   
   [<a name="SING_LIST_TO_SET-val"><b>SING_LIST_TO_SET</b></a>]  Theorem
      
       l. LENGTH l = 1  SING (set l)
   
   [<a name="SNOC-val"><b>SNOC</b></a>]  Theorem
      
       (x. SNOC x [] = [x])  x x' l. SNOC x (x'::l) = x'::SNOC x l
   
   [<a name="SNOC_11-val"><b>SNOC_11</b></a>]  Theorem
      
       x y a b. SNOC x y = SNOC a b  x = a  y = b
   
   [<a name="SNOC_ACYCLIC-val"><b>SNOC_ACYCLIC</b></a>]  Theorem
      
       l  SNOC x l  SNOC x l  l
   
   [<a name="SNOC_APPEND-val"><b>SNOC_APPEND</b></a>]  Theorem
      
       x l. SNOC x l = l  [x]
   
   [<a name="SNOC_Axiom-val"><b>SNOC_Axiom</b></a>]  Theorem
      
       e f. fn. fn [] = e  x l. fn (SNOC x l) = f x l (fn l)
   
   [<a name="SNOC_CASES-val"><b>SNOC_CASES</b></a>]  Theorem
      
       ll. ll = []  x l. ll = SNOC x l
   
   [<a name="SNOC_EL_FIRSTN-val"><b>SNOC_EL_FIRSTN</b></a>]  Theorem
      
       n l. n &lt; LENGTH l  SNOC (EL n l) (TAKE n l) = TAKE (SUC n) l
   
   [<a name="SNOC_EL_TAKE-val"><b>SNOC_EL_TAKE</b></a>]  Theorem
      
       n l. n &lt; LENGTH l  SNOC (EL n l) (TAKE n l) = TAKE (SUC n) l
   
   [<a name="SNOC_EQ_LENGTH_EQ-val"><b>SNOC_EQ_LENGTH_EQ</b></a>]  Theorem
      
       x1 l1 x2 l2. SNOC x1 l1 = SNOC x2 l2  LENGTH l1 = LENGTH l2
   
   [<a name="SNOC_FOLDR-val"><b>SNOC_FOLDR</b></a>]  Theorem
      
       x l. SNOC x l = FOLDR CONS [x] l
   
   [<a name="SNOC_INDUCT-val"><b>SNOC_INDUCT</b></a>]  Theorem
      
       P. P []  (l. P l  x. P (SNOC x l))  l. P l
   
   [<a name="SNOC_LASTN-val"><b>SNOC_LASTN</b></a>]  Theorem
      
       l x n. LASTN (SUC n) (SNOC x l) = SNOC x (LASTN n l)
   
   [<a name="SNOC_LAST_FRONT'-val"><b>SNOC_LAST_FRONT'</b></a>]  Theorem
      
       l. l  []  l = SNOC (LAST l) (FRONT l)
   
   [<a name="SNOC_REPLICATE-val"><b>SNOC_REPLICATE</b></a>]  Theorem
      
       n x. SNOC x (REPLICATE n x) = REPLICATE (SUC n) x
   
   [<a name="SNOC_REVERSE_CONS-val"><b>SNOC_REVERSE_CONS</b></a>]  Theorem
      
       x l. SNOC x l = REVERSE (x::REVERSE l)
   
   [<a name="SOME_EL-val"><b>SOME_EL</b></a>]  Theorem
      
       (P. EXISTS P []  F)  P h t. EXISTS P (h::t)  P h  EXISTS P t
   
   [<a name="SOME_EL_APPEND-val"><b>SOME_EL_APPEND</b></a>]  Theorem
      
       P l1 l2. EXISTS P (l1  l2)  EXISTS P l1  EXISTS P l2
   
   [<a name="SOME_EL_BUTFIRSTN-val"><b>SOME_EL_BUTFIRSTN</b></a>]  Theorem
      
       l m P. EXISTS P (DROP m l)  EXISTS P l
   
   [<a name="SOME_EL_BUTLASTN-val"><b>SOME_EL_BUTLASTN</b></a>]  Theorem
      
       l m P. EXISTS P (BUTLASTN m l)  EXISTS P l
   
   [<a name="SOME_EL_DISJ-val"><b>SOME_EL_DISJ</b></a>]  Theorem
      
       P Q l. (EXISTS (x. P x  Q x) l  EXISTS P l)  EXISTS Q l
   
   [<a name="SOME_EL_FIRSTN-val"><b>SOME_EL_FIRSTN</b></a>]  Theorem
      
       l m P. EXISTS P (TAKE m l)  EXISTS P l
   
   [<a name="SOME_EL_FOLDL-val"><b>SOME_EL_FOLDL</b></a>]  Theorem
      
       P l. EXISTS P l  FOLDL (l' x. l'  P x) F l
   
   [<a name="SOME_EL_FOLDL_MAP-val"><b>SOME_EL_FOLDL_MAP</b></a>]  Theorem
      
       P l. EXISTS P l  FOLDL $\/ F (MAP P l)
   
   [<a name="SOME_EL_FOLDR-val"><b>SOME_EL_FOLDR</b></a>]  Theorem
      
       P l. EXISTS P l  FOLDR (x l'. P x  l') F l
   
   [<a name="SOME_EL_FOLDR_MAP-val"><b>SOME_EL_FOLDR_MAP</b></a>]  Theorem
      
       P l. EXISTS P l  FOLDR $\/ F (MAP P l)
   
   [<a name="SOME_EL_LASTN-val"><b>SOME_EL_LASTN</b></a>]  Theorem
      
       l m P. EXISTS P (LASTN m l)  EXISTS P l
   
   [<a name="SOME_EL_MAP-val"><b>SOME_EL_MAP</b></a>]  Theorem
      
       P f l. EXISTS P (MAP f l)  EXISTS (x. P (f x)) l
   
   [<a name="SOME_EL_REVERSE-val"><b>SOME_EL_REVERSE</b></a>]  Theorem
      
       P l. EXISTS P (REVERSE l)  EXISTS P l
   
   [<a name="SOME_EL_SEG-val"><b>SOME_EL_SEG</b></a>]  Theorem
      
       m k l. m + k  LENGTH l  P. EXISTS P (SEG m k l)  EXISTS P l
   
   [<a name="SOME_EL_SNOC-val"><b>SOME_EL_SNOC</b></a>]  Theorem
      
       P x l. EXISTS P (SNOC x l)  P x  EXISTS P l
   
   [<a name="SPLITP_APPEND-val"><b>SPLITP_APPEND</b></a>]  Theorem
      
       l1 l2.
          SPLITP P (l1  l2) =
          if EXISTS P l1 then (FST (SPLITP P l1),SND (SPLITP P l1)  l2)
          else (l1  FST (SPLITP P l2),SND (SPLITP P l2))
   
   [<a name="SPLITP_EVERY-val"><b>SPLITP_EVERY</b></a>]  Theorem
      
       P l. EVERY (x. P x) l  SPLITP P l = (l,[])
   
   [<a name="SPLITP_IMP-val"><b>SPLITP_IMP</b></a>]  Theorem
      
       P ls l r.
          SPLITP P ls = (l,r)  EVERY ($  P) l  (NULL r  P (HD r))
   
   [<a name="SPLITP_JOIN-val"><b>SPLITP_JOIN</b></a>]  Theorem
      
       ls l r. SPLITP P ls = (l,r)  ls = l  r
   
   [<a name="SPLITP_LENGTH-val"><b>SPLITP_LENGTH</b></a>]  Theorem
      
       l. LENGTH (FST (SPLITP P l)) + LENGTH (SND (SPLITP P l)) =
            LENGTH l
   
   [<a name="SPLITP_NIL_FST_IMP-val"><b>SPLITP_NIL_FST_IMP</b></a>]  Theorem
      
       ls r. SPLITP P ls = ([],r)  r = ls
   
   [<a name="SPLITP_NIL_SND_EVERY-val"><b>SPLITP_NIL_SND_EVERY</b></a>]  Theorem
      
       ls r. SPLITP P ls = (r,[])  r = ls  EVERY ($  P) ls
   
   [<a name="SPLITP_compute-val"><b>SPLITP_compute</b></a>]  Theorem
      
       SPLITP = SPLITP_AUX []
   
   [<a name="SPLITP_splitAtPki-val"><b>SPLITP_splitAtPki</b></a>]  Theorem
      
       SPLITP P = splitAtPki (K P) $,
   
   [<a name="SUM-val"><b>SUM</b></a>]  Theorem
      
       SUM [] = 0  h t. SUM (h::t) = h + SUM t
   
   [<a name="SUM_APPEND-val"><b>SUM_APPEND</b></a>]  Theorem
      
       l1 l2. SUM (l1  l2) = SUM l1 + SUM l2
   
   [<a name="SUM_FLAT-val"><b>SUM_FLAT</b></a>]  Theorem
      
       l. SUM (FLAT l) = SUM (MAP SUM l)
   
   [<a name="SUM_FOLDL-val"><b>SUM_FOLDL</b></a>]  Theorem
      
       l. SUM l = FOLDL $+ 0 l
   
   [<a name="SUM_FOLDR-val"><b>SUM_FOLDR</b></a>]  Theorem
      
       l. SUM l = FOLDR $+ 0 l
   
   [<a name="SUM_IMAGE_count_MULT-val"><b>SUM_IMAGE_count_MULT</b></a>]  Theorem
      
       (m. m &lt; n  g m =  (x. f (x + k * m)) (count k)) 
         f (count (k * n)) =  g (count n)
   
   [<a name="SUM_IMAGE_count_SUM_GENLIST-val"><b>SUM_IMAGE_count_SUM_GENLIST</b></a>]  Theorem
      
        f (count n) = SUM (GENLIST f n)
   
   [<a name="SUM_REPLICATE-val"><b>SUM_REPLICATE</b></a>]  Theorem
      
       n k. SUM (REPLICATE n k) = n * k
   
   [<a name="SUM_REVERSE-val"><b>SUM_REVERSE</b></a>]  Theorem
      
       l. SUM (REVERSE l) = SUM l
   
   [<a name="SUM_SNOC-val"><b>SUM_SNOC</b></a>]  Theorem
      
       x l. SUM (SNOC x l) = SUM l + x
   
   [<a name="SUM_SUBLIST-val"><b>SUM_SUBLIST</b></a>]  Theorem
      
       p q. p  q  SUM p  SUM q
   
   [<a name="TAIL_BY_DROP-val"><b>TAIL_BY_DROP</b></a>]  Theorem
      
       ls. ls  []  TL ls = DROP 1 ls
   
   [<a name="TAKE-val"><b>TAKE</b></a>]  Theorem
      
       (l. TAKE 0 l = [])  n x l. TAKE (SUC n) (x::l) = x::TAKE n l
   
   [<a name="TAKE_1_APPEND-val"><b>TAKE_1_APPEND</b></a>]  Theorem
      
       x y. x  []  TAKE 1 (x  y) = TAKE 1 x
   
   [<a name="TAKE_APPEND-val"><b>TAKE_APPEND</b></a>]  Theorem
      
       n l1 l2. TAKE n (l1  l2) = TAKE n l1  TAKE (n  LENGTH l1) l2
   
   [<a name="TAKE_APPEND1-val"><b>TAKE_APPEND1</b></a>]  Theorem
      
       n l1. n  LENGTH l1  l2. TAKE n (l1  l2) = TAKE n l1
   
   [<a name="TAKE_APPEND2-val"><b>TAKE_APPEND2</b></a>]  Theorem
      
       l1 n.
          LENGTH l1  n 
          l2. TAKE n (l1  l2) = l1  TAKE (n  LENGTH l1) l2
   
   [<a name="TAKE_BUTLASTN-val"><b>TAKE_BUTLASTN</b></a>]  Theorem
      
       n l. n  LENGTH l  TAKE n l = BUTLASTN (LENGTH l  n) l
   
   [<a name="TAKE_DROP_SUC-val"><b>TAKE_DROP_SUC</b></a>]  Theorem
      
       n l. n &lt; LENGTH l  TAKE n l  [EL n l]  DROP (SUC n) l = l
   
   [<a name="TAKE_DROP_SWAP-val"><b>TAKE_DROP_SWAP</b></a>]  Theorem
      
       ls m n. TAKE m (DROP n ls) = DROP n (TAKE (n + m) ls)
   
   [<a name="TAKE_EL_SNOC-val"><b>TAKE_EL_SNOC</b></a>]  Theorem
      
       ls n. n &lt; LENGTH ls  TAKE (n + 1) ls = SNOC (EL n ls) (TAKE n ls)
   
   [<a name="TAKE_FRONT-val"><b>TAKE_FRONT</b></a>]  Theorem
      
       l n. l  []  n &lt; LENGTH l  TAKE n (FRONT l) = TAKE n l
   
   [<a name="TAKE_LENGTH_APPEND-val"><b>TAKE_LENGTH_APPEND</b></a>]  Theorem
      
       l1 l2. TAKE (LENGTH l1) (l1  l2) = l1
   
   [<a name="TAKE_LENGTH_APPEND2-val"><b>TAKE_LENGTH_APPEND2</b></a>]  Theorem
      
       l1 l2 x k.
          TAKE (LENGTH l1) (LUPDATE x (LENGTH l1 + k) (l1  l2)) = l1
   
   [<a name="TAKE_PRE_LENGTH-val"><b>TAKE_PRE_LENGTH</b></a>]  Theorem
      
       ls. ls  []  TAKE (PRE (LENGTH ls)) ls = FRONT ls
   
   [<a name="TAKE_REVERSE-val"><b>TAKE_REVERSE</b></a>]  Theorem
      
       n l. n  LENGTH l  TAKE n (REVERSE l) = REVERSE (LASTN n l)
   
   [<a name="TAKE_SEG-val"><b>TAKE_SEG</b></a>]  Theorem
      
       n l. n  LENGTH l  TAKE n l = SEG n 0 l
   
   [<a name="TAKE_SEG_DROP-val"><b>TAKE_SEG_DROP</b></a>]  Theorem
      
       n i l.
          i + n  LENGTH l  TAKE i l  SEG n i l  DROP (i + n) l = l
   
   [<a name="TAKE_SNOC-val"><b>TAKE_SNOC</b></a>]  Theorem
      
       n l. n  LENGTH l  x. TAKE n (SNOC x l) = TAKE n l
   
   [<a name="TAKE_SUC-val"><b>TAKE_SUC</b></a>]  Theorem
      
       n x. TAKE (SUC n) x = TAKE n x  TAKE 1 (DROP n x)
   
   [<a name="TAKE_SUC_BY_TAKE-val"><b>TAKE_SUC_BY_TAKE</b></a>]  Theorem
      
       k x. k &lt; LENGTH x  TAKE (SUC k) x = SNOC (EL k x) (TAKE k x)
   
   [<a name="TAKE_TAKE-val"><b>TAKE_TAKE</b></a>]  Theorem
      
       m l. m  LENGTH l  n. n  m  TAKE n (TAKE m l) = TAKE n l
   
   [<a name="TAKE_TAKE_T-val"><b>TAKE_TAKE_T</b></a>]  Theorem
      
       m l n. n  m  TAKE n (TAKE m l) = TAKE n l
   
   [<a name="TL-val"><b>TL</b></a>]  Theorem
      
       h t. TL (h::t) = t
   
   [<a name="TL_DROP-val"><b>TL_DROP</b></a>]  Theorem
      
       ls n. n &lt; LENGTH ls  TL (DROP n ls) = DROP n (TL ls)
   
   [<a name="TL_GENLIST-val"><b>TL_GENLIST</b></a>]  Theorem
      
       f n. TL (GENLIST f (SUC n)) = GENLIST (f  SUC) n
   
   [<a name="TL_SNOC-val"><b>TL_SNOC</b></a>]  Theorem
      
       x l. TL (SNOC x l) = if NULL l then [] else SNOC x (TL l)
   
   [<a name="UNIQUE_LIST_ELEM_COUNT-val"><b>UNIQUE_LIST_ELEM_COUNT</b></a>]  Theorem
      
       e L. UNIQUE e L  LIST_ELEM_COUNT e L = 1
   
   [<a name="UNZIP-val"><b>UNZIP</b></a>]  Theorem
      
       UNZIP [] = ([],[]) 
        x l. UNZIP (x::l) = (FST x::FST (UNZIP l),SND x::SND (UNZIP l))
   
   [<a name="UNZIP_SNOC-val"><b>UNZIP_SNOC</b></a>]  Theorem
      
       x l.
          UNZIP (SNOC x l) =
          (SNOC (FST x) (FST (UNZIP l)),SNOC (SND x) (SND (UNZIP l)))
   
   [<a name="UNZIP_ZIP-val"><b>UNZIP_ZIP</b></a>]  Theorem
      
       l1 l2. LENGTH l1 = LENGTH l2  UNZIP (ZIP (l1,l2)) = (l1,l2)
   
   [<a name="ZIP-val"><b>ZIP</b></a>]  Theorem
      
       ZIP ([],[]) = [] 
        x1 l1 x2 l2. ZIP (x1::l1,x2::l2) = (x1,x2)::ZIP (l1,l2)
   
   [<a name="ZIP_APPEND-val"><b>ZIP_APPEND</b></a>]  Theorem
      
       a b c d.
          LENGTH a = LENGTH b  LENGTH c = LENGTH d 
          ZIP (a,b)  ZIP (c,d) = ZIP (a  c,b  d)
   
   [<a name="ZIP_COUNT_LIST-val"><b>ZIP_COUNT_LIST</b></a>]  Theorem
      
       n = LENGTH l1 
        ZIP (l1,COUNT_LIST n) = GENLIST (n. (EL n l1,n)) (LENGTH l1)
   
   [<a name="ZIP_FIRSTN-val"><b>ZIP_FIRSTN</b></a>]  Theorem
      
       n a b.
          n  LENGTH a  LENGTH a = LENGTH b 
          ZIP (TAKE n a,TAKE n b) = TAKE n (ZIP (a,b))
   
   [<a name="ZIP_FIRSTN_LEQ-val"><b>ZIP_FIRSTN_LEQ</b></a>]  Theorem
      
       n a b.
          n  LENGTH a  LENGTH a  LENGTH b 
          ZIP (TAKE n a,TAKE n b) = TAKE n (ZIP (a,TAKE (LENGTH a) b))
   
   [<a name="ZIP_GENLIST-val"><b>ZIP_GENLIST</b></a>]  Theorem
      
       l f n.
          LENGTH l = n  ZIP (l,GENLIST f n) = GENLIST (x. (EL x l,f x)) n
   
   [<a name="ZIP_MAP_MAP-val"><b>ZIP_MAP_MAP</b></a>]  Theorem
      
       ls f g. ZIP (MAP f ls,MAP g ls) = MAP (x. (f x,g x)) ls
   
   [<a name="ZIP_SNOC-val"><b>ZIP_SNOC</b></a>]  Theorem
      
       l1 l2.
          LENGTH l1 = LENGTH l2 
          x1 x2. ZIP (SNOC x1 l1,SNOC x2 l2) = SNOC (x1,x2) (ZIP (l1,l2))
   
   [<a name="ZIP_TAKE-val"><b>ZIP_TAKE</b></a>]  Theorem
      
       n a b.
          n  LENGTH a  LENGTH a = LENGTH b 
          ZIP (TAKE n a,TAKE n b) = TAKE n (ZIP (a,b))
   
   [<a name="ZIP_TAKE_LEQ-val"><b>ZIP_TAKE_LEQ</b></a>]  Theorem
      
       n a b.
          n  LENGTH a  LENGTH a  LENGTH b 
          ZIP (TAKE n a,TAKE n b) = TAKE n (ZIP (a,TAKE (LENGTH a) b))
   
   [<a name="ZIP_UNZIP-val"><b>ZIP_UNZIP</b></a>]  Theorem
      
       l. ZIP (UNZIP l) = l
   
   [<a name="all_distinct_count_list-val"><b>all_distinct_count_list</b></a>]  Theorem
      
       n. ALL_DISTINCT (COUNT_LIST n)
   
   [<a name="all_distinct_list_el_inj-val"><b>all_distinct_list_el_inj</b></a>]  Theorem
      
       ls. ALL_DISTINCT ls  INJ (j. EL j ls) (count (LENGTH ls)) (:)
   
   [<a name="chunks_0-val"><b>chunks_0</b></a>]  Theorem
      
       chunks 0 ls = [ls]
   
   [<a name="chunks_MAP-val"><b>chunks_MAP</b></a>]  Theorem
      
       n ls. chunks n (MAP f ls) = MAP (MAP f) (chunks n ls)
   
   [<a name="chunks_NIL-val"><b>chunks_NIL</b></a>]  Theorem
      
       chunks n [] = [[]]
   
   [<a name="chunks_TAKE-val"><b>chunks_TAKE</b></a>]  Theorem
      
       n ls m.
          divides n m  0 &lt; m 
          chunks n (TAKE m ls) = TAKE (m DIV n) (chunks n ls)
   
   [<a name="chunks_ZIP-val"><b>chunks_ZIP</b></a>]  Theorem
      
       n ls l2.
          LENGTH ls = LENGTH l2 
          chunks n (ZIP (ls,l2)) = MAP ZIP (ZIP (chunks n ls,chunks n l2))
   
   [<a name="chunks_append_divides-val"><b>chunks_append_divides</b></a>]  Theorem
      
       n l1 l2.
          0 &lt; n  divides n (LENGTH l1)  NULL l1  NULL l2 
          chunks n (l1  l2) = chunks n l1  chunks n l2
   
   [<a name="chunks_def-val"><b>chunks_def</b></a>]  Theorem
      
       n ls.
          chunks n ls =
          if LENGTH ls  n  n = 0 then [ls]
          else TAKE n ls::chunks n (DROP n ls)
   
   [<a name="chunks_ind-val"><b>chunks_ind</b></a>]  Theorem
      
       P. (n ls. ((LENGTH ls  n  n = 0)  P n (DROP n ls))  P n ls) 
            v v1. P v v1
   
   [<a name="chunks_length-val"><b>chunks_length</b></a>]  Theorem
      
       chunks (LENGTH ls) ls = [ls]
   
   [<a name="chunks_not_nil-val"><b>chunks_not_nil</b></a>]  Theorem
      
       n ls. chunks n ls  []
   
   [<a name="chunks_tr_aux_def-val"><b>chunks_tr_aux_def</b></a>]  Theorem
      
       n ls acc.
          chunks_tr_aux n ls acc =
          if LENGTH ls  SUC n then REVERSE (ls::acc)
          else chunks_tr_aux n (DROP (SUC n) ls) (TAKE (SUC n) ls::acc)
   
   [<a name="chunks_tr_aux_ind-val"><b>chunks_tr_aux_ind</b></a>]  Theorem
      
       P. (n ls acc.
               ((LENGTH ls  SUC n) 
                P n (DROP (SUC n) ls) (TAKE (SUC n) ls::acc)) 
               P n ls acc) 
            v v1 v2. P v v1 v2
   
   [<a name="chunks_tr_aux_thm-val"><b>chunks_tr_aux_thm</b></a>]  Theorem
      
       n ls acc. chunks_tr_aux n ls acc = REVERSE acc  chunks (SUC n) ls
   
   [<a name="chunks_tr_thm-val"><b>chunks_tr_thm</b></a>]  Theorem
      
       chunks_tr = chunks
   
   [<a name="common_prefixes_BIGINTER-val"><b>common_prefixes_BIGINTER</b></a>]  Theorem
      
       common_prefixes s = BIGINTER (IMAGE (l. {p | p  l}) s)
   
   [<a name="common_prefixes_NIL-val"><b>common_prefixes_NIL</b></a>]  Theorem
      
       []  s  common_prefixes s = {[]}
   
   [<a name="common_prefixes_NONEMPTY-val"><b>common_prefixes_NONEMPTY</b></a>]  Theorem
      
       common_prefixes s  
   
   [<a name="common_prefixes_PAIR-val"><b>common_prefixes_PAIR</b></a>]  Theorem
      
       common_prefixes {[]; x} = {[]}  common_prefixes {x; []} = {[]} 
        common_prefixes {a::xs; b::ys} =
        [] INSERT
        if a = b then IMAGE (CONS a) (common_prefixes {xs; ys}) else 
   
   [<a name="count_list_sub1-val"><b>count_list_sub1</b></a>]  Theorem
      
       n. n  0  COUNT_LIST n = 0::MAP SUC (COUNT_LIST (n  1))
   
   [<a name="divides_EVERY_LENGTH_chunks-val"><b>divides_EVERY_LENGTH_chunks</b></a>]  Theorem
      
       n ls.
          ls  []  divides n (LENGTH ls) 
          EVERY ($= n  LENGTH) (chunks n ls)
   
   [<a name="el_map_count-val"><b>el_map_count</b></a>]  Theorem
      
       n f m. n &lt; m  EL n (MAP f (COUNT_LIST m)) = f n
   
   [<a name="every_count_list-val"><b>every_count_list</b></a>]  Theorem
      
       P n. EVERY P (COUNT_LIST n)  m. m &lt; n  P m
   
   [<a name="is_prefix_el-val"><b>is_prefix_el</b></a>]  Theorem
      
       n l1 l2.
          l1  l2  n &lt; LENGTH l1  n &lt; LENGTH l2  EL n l1 = EL n l2
   
   [<a name="list_rel_butlastn-val"><b>list_rel_butlastn</b></a>]  Theorem
      
       f l1 l2 n.
          n  LENGTH l1  LIST_REL f l1 l2 
          LIST_REL f (BUTLASTN n l1) (BUTLASTN n l2)
   
   [<a name="list_rel_lastn-val"><b>list_rel_lastn</b></a>]  Theorem
      
       f l1 l2 n.
          n  LENGTH l1  LIST_REL f l1 l2 
          LIST_REL f (LASTN n l1) (LASTN n l2)
   
   [<a name="list_to_set_eq_el_image-val"><b>list_to_set_eq_el_image</b></a>]  Theorem
      
       ls. set ls = IMAGE (j. EL j ls) (count (LENGTH ls))
   
   [<a name="longest_prefix_EMPTY-val"><b>longest_prefix_EMPTY</b></a>]  Theorem
      
       longest_prefix  = []
   
   [<a name="longest_prefix_NIL-val"><b>longest_prefix_NIL</b></a>]  Theorem
      
       []  s  longest_prefix s = []
   
   [<a name="longest_prefix_PAIR-val"><b>longest_prefix_PAIR</b></a>]  Theorem
      
       longest_prefix {[]; ys} = []  longest_prefix {xs; []} = [] 
        longest_prefix {x::xs; y::ys} =
        if x = y then x::longest_prefix {xs; ys} else []
   
   [<a name="longest_prefix_SING-val"><b>longest_prefix_SING</b></a>]  Theorem
      
       longest_prefix {s} = s
   
   [<a name="longest_prefix_UNIQUE-val"><b>longest_prefix_UNIQUE</b></a>]  Theorem
      
       s    is_measure_maximal LENGTH (common_prefixes s) x 
        is_measure_maximal LENGTH (common_prefixes s) y 
        x = y
   
   [<a name="map_replicate-val"><b>map_replicate</b></a>]  Theorem
      
       f n x. MAP f (REPLICATE n x) = REPLICATE n (f x)
   
   [<a name="nub_GENLIST-val"><b>nub_GENLIST</b></a>]  Theorem
      
       nub (GENLIST f n) =
        MAP f (FILTER (i. j. i &lt; j  j &lt; n  f i  f j) (COUNT_LIST n))
   
   [<a name="prefixes_is_prefix_total-val"><b>prefixes_is_prefix_total</b></a>]  Theorem
      
       l l1 l2. l1  l  l2  l  l1  l2  l2  l1
   
   [<a name="set_list_eq_count-val"><b>set_list_eq_count</b></a>]  Theorem
      
       ls n. set ls = count n  j. j &lt; LENGTH ls  EL j ls &lt; n
   
   [<a name="sublist_ALL_DISTINCT-val"><b>sublist_ALL_DISTINCT</b></a>]  Theorem
      
       p q. p  q  ALL_DISTINCT q  ALL_DISTINCT p
   
   [<a name="sublist_MONO_DEC-val"><b>sublist_MONO_DEC</b></a>]  Theorem
      
       ls sl. sl  ls  MONO_DEC ls  MONO_DEC sl
   
   [<a name="sublist_MONO_INC-val"><b>sublist_MONO_INC</b></a>]  Theorem
      
       ls sl. sl  ls  MONO_INC ls  MONO_INC sl
   
   [<a name="sublist_antisym-val"><b>sublist_antisym</b></a>]  Theorem
      
       p q. p  q  q  p  p = q
   
   [<a name="sublist_append_extend-val"><b>sublist_append_extend</b></a>]  Theorem
      
       h t q. h::t  q  x y. q = x  h::y  t  y
   
   [<a name="sublist_append_if-val"><b>sublist_append_if</b></a>]  Theorem
      
       p q h. p  q  p  [h]  q  [h]
   
   [<a name="sublist_append_iff-val"><b>sublist_append_iff</b></a>]  Theorem
      
       p q h. p  q  p  [h]  q  [h]
   
   [<a name="sublist_append_include-val"><b>sublist_append_include</b></a>]  Theorem
      
       p q x. p  q  p  x  q
   
   [<a name="sublist_append_only_if-val"><b>sublist_append_only_if</b></a>]  Theorem
      
       p q h. p  [h]  q  [h]  p  q
   
   [<a name="sublist_append_pair-val"><b>sublist_append_pair</b></a>]  Theorem
      
       a b c d. a  b  c  d  a  c  b  d
   
   [<a name="sublist_append_prefix-val"><b>sublist_append_prefix</b></a>]  Theorem
      
       p q. p  q  p
   
   [<a name="sublist_append_remove-val"><b>sublist_append_remove</b></a>]  Theorem
      
       p q x. x  p  q  p  q
   
   [<a name="sublist_append_suffix-val"><b>sublist_append_suffix</b></a>]  Theorem
      
       p q. p  p  q
   
   [<a name="sublist_cons-val"><b>sublist_cons</b></a>]  Theorem
      
       h p q. p  q  h::p  h::q
   
   [<a name="sublist_cons_eq-val"><b>sublist_cons_eq</b></a>]  Theorem
      
       h. (p q. h::p  q  p  q)  p q. p  q  p  h::q
   
   [<a name="sublist_cons_include-val"><b>sublist_cons_include</b></a>]  Theorem
      
       h p q. p  q  p  h::q
   
   [<a name="sublist_cons_remove-val"><b>sublist_cons_remove</b></a>]  Theorem
      
       h p q. h::p  q  p  q
   
   [<a name="sublist_def-val"><b>sublist_def</b></a>]  Theorem
      
       (x. []  x  T)  (t1 h1. h1::t1  []  F) 
        t2 t1 h2 h1.
          h1::t1  h2::t2  h1 = h2  t1  t2  h1  h2  h1::t1  t2
   
   [<a name="sublist_drop-val"><b>sublist_drop</b></a>]  Theorem
      
       ls n. DROP n ls  ls
   
   [<a name="sublist_every-val"><b>sublist_every</b></a>]  Theorem
      
       l ls. l  ls  P. EVERY P ls  EVERY P l
   
   [<a name="sublist_front-val"><b>sublist_front</b></a>]  Theorem
      
       ls. ls  []  FRONT ls  ls
   
   [<a name="sublist_head_sing-val"><b>sublist_head_sing</b></a>]  Theorem
      
       ls. ls  []  [HD ls]  ls
   
   [<a name="sublist_ind-val"><b>sublist_ind</b></a>]  Theorem
      
       P. (x. P [] x)  (h1 t1. P (h1::t1) []) 
            (h1 t1 h2 t2. P t1 t2  P (h1::t1) t2  P (h1::t1) (h2::t2)) 
            v v1. P v v1
   
   [<a name="sublist_induct-val"><b>sublist_induct</b></a>]  Theorem
      
       P. (y. P [] y)  (h x y. P x y  x  y  P (h::x) (h::y)) 
            (h x y. P x y  x  y  P x (h::y)) 
            x y. x  y  P x y
   
   [<a name="sublist_last_sing-val"><b>sublist_last_sing</b></a>]  Theorem
      
       ls. ls  []  [LAST ls]  ls
   
   [<a name="sublist_length-val"><b>sublist_length</b></a>]  Theorem
      
       p q. p  q  LENGTH p  LENGTH q
   
   [<a name="sublist_mem-val"><b>sublist_mem</b></a>]  Theorem
      
       p q x. p  q  MEM x p  MEM x q
   
   [<a name="sublist_member_sing-val"><b>sublist_member_sing</b></a>]  Theorem
      
       ls x. MEM x ls  [x]  ls
   
   [<a name="sublist_nil-val"><b>sublist_nil</b></a>]  Theorem
      
       p. []  p
   
   [<a name="sublist_of_nil-val"><b>sublist_of_nil</b></a>]  Theorem
      
       p. p  []  p = []
   
   [<a name="sublist_order-val"><b>sublist_order</b></a>]  Theorem
      
       ls sl x.
          sl  ls  MEM x sl 
          l1 l2 l3 l4.
            ls = l1  [x]  l2  sl = l3  [x]  l4  l3  l1  l4  l2
   
   [<a name="sublist_prefix-val"><b>sublist_prefix</b></a>]  Theorem
      
       x p q. p  q  x  p  x  q
   
   [<a name="sublist_prefix_nil-val"><b>sublist_prefix_nil</b></a>]  Theorem
      
       p q. p  q  q  p = []
   
   [<a name="sublist_refl-val"><b>sublist_refl</b></a>]  Theorem
      
       p. p  p
   
   [<a name="sublist_snoc-val"><b>sublist_snoc</b></a>]  Theorem
      
       h p q. p  q  SNOC h p  SNOC h q
   
   [<a name="sublist_subset-val"><b>sublist_subset</b></a>]  Theorem
      
       ls sl. sl  ls  set sl  set ls
   
   [<a name="sublist_suffix-val"><b>sublist_suffix</b></a>]  Theorem
      
       x p q. p  q  p  x  q  x
   
   [<a name="sublist_tail-val"><b>sublist_tail</b></a>]  Theorem
      
       ls. ls  []  TL ls  ls
   
   [<a name="sublist_take-val"><b>sublist_take</b></a>]  Theorem
      
       ls n. TAKE n ls  ls
   
   [<a name="sublist_trans-val"><b>sublist_trans</b></a>]  Theorem
      
       p q r. p  q  q  r  p  r
   
   [<a name="sum_of_sums-val"><b>sum_of_sums</b></a>]  Theorem
      
        (m.  (f m) (count a)) (count b) =
         (m. f (m DIV a) (m MOD a)) (count (a * b))
   
   [<a name="take_drop_partition-val"><b>take_drop_partition</b></a>]  Theorem
      
       n m l. m  n  TAKE m l  TAKE (n  m) (DROP m l) = TAKE n l
   
   [<a name="two_common_prefixes-val"><b>two_common_prefixes</b></a>]  Theorem
      
       s    p1  common_prefixes s  p2  common_prefixes s 
        p1  p2  p2  p1
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/list/src/rich_listScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-2</a></em></p></body></html>
