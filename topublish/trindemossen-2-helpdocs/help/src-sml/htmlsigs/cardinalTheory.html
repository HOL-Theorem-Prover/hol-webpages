<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure cardinalTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure cardinalTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/pred_set/src/more_theories/.hol/objs/cardinalScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature cardinalTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#BIGPROD_def-val">BIGPROD_def</a> : thm
<a name="line7"></a>    val <a href="#BIGPRODi_def-val">BIGPRODi_def</a> : thm
<a name="line8"></a>    val <a href="#bijns_def-val">bijns_def</a> : thm
<a name="line9"></a>    val <a href="#cardeq_def-val">cardeq_def</a> : thm
<a name="line10"></a>    val <a href="#cardgeq_def-val">cardgeq_def</a> : thm
<a name="line11"></a>    val <a href="#cardgt_def-val">cardgt_def</a> : thm
<a name="line12"></a>    val <a href="#cardleq_def-val">cardleq_def</a> : thm
<a name="line13"></a>    val <a href="#fnOfSet_def-val">fnOfSet_def</a> : thm
<a name="line14"></a>    val <a href="#list_def-val">list_def</a> : thm
<a name="line15"></a>    val <a href="#set_exp_def-val">set_exp_def</a> : thm
<a name="line16"></a>  
<a name="line17"></a>  (*  Theorems  *)
<a name="line18"></a>    val <a href="#BIGPROD_CONS-val">BIGPROD_CONS</a> : thm
<a name="line19"></a>    val <a href="#BIGPROD_EQ_EMPTY-val">BIGPROD_EQ_EMPTY</a> : thm
<a name="line20"></a>    val <a href="#BIGPROD_ONE-val">BIGPROD_ONE</a> : thm
<a name="line21"></a>    val <a href="#BIGPROD_SING-val">BIGPROD_SING</a> : thm
<a name="line22"></a>    val <a href="#BIGPROD_pair-val">BIGPROD_pair</a> : thm
<a name="line23"></a>    val <a href="#BIGPROD_thm-val">BIGPROD_thm</a> : thm
<a name="line24"></a>    val <a href="#BIGPRODi_11-val">BIGPRODi_11</a> : thm
<a name="line25"></a>    val <a href="#BIGPRODi_EQ_EMPTY-val">BIGPRODi_EQ_EMPTY</a> : thm
<a name="line26"></a>    val <a href="#BIGPRODi_KNONE-val">BIGPRODi_KNONE</a> : thm
<a name="line27"></a>    val <a href="#BIGPRODi_SING_CEQ-val">BIGPRODi_SING_CEQ</a> : thm
<a name="line28"></a>    val <a href="#BIGPRODi_SING_EQ-val">BIGPRODi_SING_EQ</a> : thm
<a name="line29"></a>    val <a href="#BIGPRODi_pair-val">BIGPRODi_pair</a> : thm
<a name="line30"></a>    val <a href="#BIJECTIVE_INJECTIVE_SURJECTIVE-val">BIJECTIVE_INJECTIVE_SURJECTIVE</a> : thm
<a name="line31"></a>    val <a href="#BIJECTIVE_INVERSES-val">BIJECTIVE_INVERSES</a> : thm
<a name="line32"></a>    val <a href="#BIJ_functions_agree-val">BIJ_functions_agree</a> : thm
<a name="line33"></a>    val <a href="#CANTOR-val">CANTOR</a> : thm
<a name="line34"></a>    val <a href="#CANTOR_THM-val">CANTOR_THM</a> : thm
<a name="line35"></a>    val <a href="#CANTOR_THM_UNIV-val">CANTOR_THM_UNIV</a> : thm
<a name="line36"></a>    val <a href="#CARD1_SING-val">CARD1_SING</a> : thm
<a name="line37"></a>    val <a href="#CARDEQ_0-val">CARDEQ_0</a> : thm
<a name="line38"></a>    val <a href="#CARDEQ_CARD-val">CARDEQ_CARD</a> : thm
<a name="line39"></a>    val <a href="#CARDEQ_CARDLEQ-val">CARDEQ_CARDLEQ</a> : thm
<a name="line40"></a>    val <a href="#CARDEQ_CARD_EQN-val">CARDEQ_CARD_EQN</a> : thm
<a name="line41"></a>    val <a href="#CARDEQ_CROSS-val">CARDEQ_CROSS</a> : thm
<a name="line42"></a>    val <a href="#CARDEQ_CROSS_1-val">CARDEQ_CROSS_1</a> : thm
<a name="line43"></a>    val <a href="#CARDEQ_CROSS_SYM-val">CARDEQ_CROSS_SYM</a> : thm
<a name="line44"></a>    val <a href="#CARDEQ_DISJOINT_UNION-val">CARDEQ_DISJOINT_UNION</a> : thm
<a name="line45"></a>    val <a href="#CARDEQ_FINITE-val">CARDEQ_FINITE</a> : thm
<a name="line46"></a>    val <a href="#CARDEQ_INSERT_RWT-val">CARDEQ_INSERT_RWT</a> : thm
<a name="line47"></a>    val <a href="#CARDEQ_SUBSET_CARDLEQ-val">CARDEQ_SUBSET_CARDLEQ</a> : thm
<a name="line48"></a>    val <a href="#CARDLEQ_CARD-val">CARDLEQ_CARD</a> : thm
<a name="line49"></a>    val <a href="#CARDLEQ_CROSS_CONG-val">CARDLEQ_CROSS_CONG</a> : thm
<a name="line50"></a>    val <a href="#CARDLEQ_FINITE-val">CARDLEQ_FINITE</a> : thm
<a name="line51"></a>    val <a href="#CARD_12-val">CARD_12</a> : thm
<a name="line52"></a>    val <a href="#CARD_ADD2_ABSORB_LE-val">CARD_ADD2_ABSORB_LE</a> : thm
<a name="line53"></a>    val <a href="#CARD_ADD2_ABSORB_LT-val">CARD_ADD2_ABSORB_LT</a> : thm
<a name="line54"></a>    val <a href="#CARD_ADD_ABSORB-val">CARD_ADD_ABSORB</a> : thm
<a name="line55"></a>    val <a href="#CARD_ADD_ABSORB_LE-val">CARD_ADD_ABSORB_LE</a> : thm
<a name="line56"></a>    val <a href="#CARD_ADD_ASSOC-val">CARD_ADD_ASSOC</a> : thm
<a name="line57"></a>    val <a href="#CARD_ADD_C-val">CARD_ADD_C</a> : thm
<a name="line58"></a>    val <a href="#CARD_ADD_CONG-val">CARD_ADD_CONG</a> : thm
<a name="line59"></a>    val <a href="#CARD_ADD_FINITE-val">CARD_ADD_FINITE</a> : thm
<a name="line60"></a>    val <a href="#CARD_ADD_FINITE_EQ-val">CARD_ADD_FINITE_EQ</a> : thm
<a name="line61"></a>    val <a href="#CARD_ADD_LE_MUL_INFINITE-val">CARD_ADD_LE_MUL_INFINITE</a> : thm
<a name="line62"></a>    val <a href="#CARD_ADD_SYM-val">CARD_ADD_SYM</a> : thm
<a name="line63"></a>    val <a href="#CARD_BIGUNION-val">CARD_BIGUNION</a> : thm
<a name="line64"></a>    val <a href="#CARD_BIGUNION_LE-val">CARD_BIGUNION_LE</a> : thm
<a name="line65"></a>    val <a href="#CARD_BOOL-val">CARD_BOOL</a> : thm
<a name="line66"></a>    val <a href="#CARD_CARDEQ_I-val">CARD_CARDEQ_I</a> : thm
<a name="line67"></a>    val <a href="#CARD_COUNTABLE_CONG-val">CARD_COUNTABLE_CONG</a> : thm
<a name="line68"></a>    val <a href="#CARD_DISJOINT_UNION-val">CARD_DISJOINT_UNION</a> : thm
<a name="line69"></a>    val <a href="#CARD_EQ_BIJECTION-val">CARD_EQ_BIJECTION</a> : thm
<a name="line70"></a>    val <a href="#CARD_EQ_BIJECTIONS-val">CARD_EQ_BIJECTIONS</a> : thm
<a name="line71"></a>    val <a href="#CARD_EQ_CARD-val">CARD_EQ_CARD</a> : thm
<a name="line72"></a>    val <a href="#CARD_EQ_CARD_IMP-val">CARD_EQ_CARD_IMP</a> : thm
<a name="line73"></a>    val <a href="#CARD_EQ_CONG-val">CARD_EQ_CONG</a> : thm
<a name="line74"></a>    val <a href="#CARD_EQ_COUNTABLE-val">CARD_EQ_COUNTABLE</a> : thm
<a name="line75"></a>    val <a href="#CARD_EQ_EMPTY-val">CARD_EQ_EMPTY</a> : thm
<a name="line76"></a>    val <a href="#CARD_EQ_FINITE-val">CARD_EQ_FINITE</a> : thm
<a name="line77"></a>    val <a href="#CARD_EQ_IMAGE-val">CARD_EQ_IMAGE</a> : thm
<a name="line78"></a>    val <a href="#CARD_EQ_IMP_LE-val">CARD_EQ_IMP_LE</a> : thm
<a name="line79"></a>    val <a href="#CARD_EQ_REFL-val">CARD_EQ_REFL</a> : thm
<a name="line80"></a>    val <a href="#CARD_EQ_SYM-val">CARD_EQ_SYM</a> : thm
<a name="line81"></a>    val <a href="#CARD_EQ_TRANS-val">CARD_EQ_TRANS</a> : thm
<a name="line82"></a>    val <a href="#CARD_EXP_ABSORB-val">CARD_EXP_ABSORB</a> : thm
<a name="line83"></a>    val <a href="#CARD_EXP_CANTOR-val">CARD_EXP_CANTOR</a> : thm
<a name="line84"></a>    val <a href="#CARD_EXP_CONG-val">CARD_EXP_CONG</a> : thm
<a name="line85"></a>    val <a href="#CARD_EXP_MUL-val">CARD_EXP_MUL</a> : thm
<a name="line86"></a>    val <a href="#CARD_EXP_POWERSET-val">CARD_EXP_POWERSET</a> : thm
<a name="line87"></a>    val <a href="#CARD_EXP_SING-val">CARD_EXP_SING</a> : thm
<a name="line88"></a>    val <a href="#CARD_EXP_UNIV-val">CARD_EXP_UNIV</a> : thm
<a name="line89"></a>    val <a href="#CARD_FINITE_CONG-val">CARD_FINITE_CONG</a> : thm
<a name="line90"></a>    val <a href="#CARD_HAS_SIZE_CONG-val">CARD_HAS_SIZE_CONG</a> : thm
<a name="line91"></a>    val <a href="#CARD_INFINITE_CONG-val">CARD_INFINITE_CONG</a> : thm
<a name="line92"></a>    val <a href="#CARD_LDISTRIB-val">CARD_LDISTRIB</a> : thm
<a name="line93"></a>    val <a href="#CARD_LET_TOTAL-val">CARD_LET_TOTAL</a> : thm
<a name="line94"></a>    val <a href="#CARD_LET_TRANS-val">CARD_LET_TRANS</a> : thm
<a name="line95"></a>    val <a href="#CARD_LE_ADD-val">CARD_LE_ADD</a> : thm
<a name="line96"></a>    val <a href="#CARD_LE_ADDL-val">CARD_LE_ADDL</a> : thm
<a name="line97"></a>    val <a href="#CARD_LE_ADDR-val">CARD_LE_ADDR</a> : thm
<a name="line98"></a>    val <a href="#CARD_LE_ANTISYM-val">CARD_LE_ANTISYM</a> : thm
<a name="line99"></a>    val <a href="#CARD_LE_CARD-val">CARD_LE_CARD</a> : thm
<a name="line100"></a>    val <a href="#CARD_LE_CARD_IMP-val">CARD_LE_CARD_IMP</a> : thm
<a name="line101"></a>    val <a href="#CARD_LE_CONG-val">CARD_LE_CONG</a> : thm
<a name="line102"></a>    val <a href="#CARD_LE_COUNTABLE-val">CARD_LE_COUNTABLE</a> : thm
<a name="line103"></a>    val <a href="#CARD_LE_EMPTY-val">CARD_LE_EMPTY</a> : thm
<a name="line104"></a>    val <a href="#CARD_LE_EQ_SUBSET-val">CARD_LE_EQ_SUBSET</a> : thm
<a name="line105"></a>    val <a href="#CARD_LE_EXP-val">CARD_LE_EXP</a> : thm
<a name="line106"></a>    val <a href="#CARD_LE_EXP_LEFT-val">CARD_LE_EXP_LEFT</a> : thm
<a name="line107"></a>    val <a href="#CARD_LE_FINITE-val">CARD_LE_FINITE</a> : thm
<a name="line108"></a>    val <a href="#CARD_LE_IMAGE-val">CARD_LE_IMAGE</a> : thm
<a name="line109"></a>    val <a href="#CARD_LE_IMAGE_GEN-val">CARD_LE_IMAGE_GEN</a> : thm
<a name="line110"></a>    val <a href="#CARD_LE_INFINITE-val">CARD_LE_INFINITE</a> : thm
<a name="line111"></a>    val <a href="#CARD_LE_INJ-val">CARD_LE_INJ</a> : thm
<a name="line112"></a>    val <a href="#CARD_LE_LT-val">CARD_LE_LT</a> : thm
<a name="line113"></a>    val <a href="#CARD_LE_MUL-val">CARD_LE_MUL</a> : thm
<a name="line114"></a>    val <a href="#CARD_LE_REFL-val">CARD_LE_REFL</a> : thm
<a name="line115"></a>    val <a href="#CARD_LE_RELATIONAL-val">CARD_LE_RELATIONAL</a> : thm
<a name="line116"></a>    val <a href="#CARD_LE_SQUARE-val">CARD_LE_SQUARE</a> : thm
<a name="line117"></a>    val <a href="#CARD_LE_SUBSET-val">CARD_LE_SUBSET</a> : thm
<a name="line118"></a>    val <a href="#CARD_LE_TOTAL-val">CARD_LE_TOTAL</a> : thm
<a name="line119"></a>    val <a href="#CARD_LE_TRANS-val">CARD_LE_TRANS</a> : thm
<a name="line120"></a>    val <a href="#CARD_LE_UNIV-val">CARD_LE_UNIV</a> : thm
<a name="line121"></a>    val <a href="#CARD_LTE_TOTAL-val">CARD_LTE_TOTAL</a> : thm
<a name="line122"></a>    val <a href="#CARD_LTE_TRANS-val">CARD_LTE_TRANS</a> : thm
<a name="line123"></a>    val <a href="#CARD_LT_ADD-val">CARD_LT_ADD</a> : thm
<a name="line124"></a>    val <a href="#CARD_LT_CARD-val">CARD_LT_CARD</a> : thm
<a name="line125"></a>    val <a href="#CARD_LT_CONG-val">CARD_LT_CONG</a> : thm
<a name="line126"></a>    val <a href="#CARD_LT_FINITE_INFINITE-val">CARD_LT_FINITE_INFINITE</a> : thm
<a name="line127"></a>    val <a href="#CARD_LT_IMP_LE-val">CARD_LT_IMP_LE</a> : thm
<a name="line128"></a>    val <a href="#CARD_LT_LE-val">CARD_LT_LE</a> : thm
<a name="line129"></a>    val <a href="#CARD_LT_REFL-val">CARD_LT_REFL</a> : thm
<a name="line130"></a>    val <a href="#CARD_LT_TOTAL-val">CARD_LT_TOTAL</a> : thm
<a name="line131"></a>    val <a href="#CARD_LT_TRANS-val">CARD_LT_TRANS</a> : thm
<a name="line132"></a>    val <a href="#CARD_MUL2_ABSORB_LE-val">CARD_MUL2_ABSORB_LE</a> : thm
<a name="line133"></a>    val <a href="#CARD_MUL_ABSORB-val">CARD_MUL_ABSORB</a> : thm
<a name="line134"></a>    val <a href="#CARD_MUL_ABSORB_LE-val">CARD_MUL_ABSORB_LE</a> : thm
<a name="line135"></a>    val <a href="#CARD_MUL_ASSOC-val">CARD_MUL_ASSOC</a> : thm
<a name="line136"></a>    val <a href="#CARD_MUL_CONG-val">CARD_MUL_CONG</a> : thm
<a name="line137"></a>    val <a href="#CARD_MUL_FINITE-val">CARD_MUL_FINITE</a> : thm
<a name="line138"></a>    val <a href="#CARD_MUL_FINITE_EQ-val">CARD_MUL_FINITE_EQ</a> : thm
<a name="line139"></a>    val <a href="#CARD_MUL_LT_INFINITE-val">CARD_MUL_LT_INFINITE</a> : thm
<a name="line140"></a>    val <a href="#CARD_MUL_LT_LEMMA-val">CARD_MUL_LT_LEMMA</a> : thm
<a name="line141"></a>    val <a href="#CARD_MUL_SYM-val">CARD_MUL_SYM</a> : thm
<a name="line142"></a>    val <a href="#CARD_NOT_LE-val">CARD_NOT_LE</a> : thm
<a name="line143"></a>    val <a href="#CARD_NOT_LT-val">CARD_NOT_LT</a> : thm
<a name="line144"></a>    val <a href="#CARD_RDISTRIB-val">CARD_RDISTRIB</a> : thm
<a name="line145"></a>    val <a href="#CARD_SQUARE_INFINITE-val">CARD_SQUARE_INFINITE</a> : thm
<a name="line146"></a>    val <a href="#CARD_SQUARE_NUM-val">CARD_SQUARE_NUM</a> : thm
<a name="line147"></a>    val <a href="#CARD_SUBSET_EQ-val">CARD_SUBSET_EQ</a> : thm
<a name="line148"></a>    val <a href="#CONJ_ACI-val">CONJ_ACI</a> : thm
<a name="line149"></a>    val <a href="#CONJ_EQ_IMP-val">CONJ_EQ_IMP</a> : thm
<a name="line150"></a>    val <a href="#COUNTABLE-val">COUNTABLE</a> : thm
<a name="line151"></a>    val <a href="#COUNTABLE_ALT_cardleq-val">COUNTABLE_ALT_cardleq</a> : thm
<a name="line152"></a>    val <a href="#COUNTABLE_AS_IMAGE-val">COUNTABLE_AS_IMAGE</a> : thm
<a name="line153"></a>    val <a href="#COUNTABLE_AS_IMAGE_SUBSET-val">COUNTABLE_AS_IMAGE_SUBSET</a> : thm
<a name="line154"></a>    val <a href="#COUNTABLE_AS_IMAGE_SUBSET_EQ-val">COUNTABLE_AS_IMAGE_SUBSET_EQ</a> : thm
<a name="line155"></a>    val <a href="#COUNTABLE_AS_INJECTIVE_IMAGE-val">COUNTABLE_AS_INJECTIVE_IMAGE</a> : thm
<a name="line156"></a>    val <a href="#COUNTABLE_BIGUNION-val">COUNTABLE_BIGUNION</a> : thm
<a name="line157"></a>    val <a href="#COUNTABLE_CASES-val">COUNTABLE_CASES</a> : thm
<a name="line158"></a>    val <a href="#COUNTABLE_CROSS-val">COUNTABLE_CROSS</a> : thm
<a name="line159"></a>    val <a href="#COUNTABLE_DELETE-val">COUNTABLE_DELETE</a> : thm
<a name="line160"></a>    val <a href="#COUNTABLE_DIFF_FINITE-val">COUNTABLE_DIFF_FINITE</a> : thm
<a name="line161"></a>    val <a href="#COUNTABLE_EMPTY-val">COUNTABLE_EMPTY</a> : thm
<a name="line162"></a>    val <a href="#COUNTABLE_IMAGE-val">COUNTABLE_IMAGE</a> : thm
<a name="line163"></a>    val <a href="#COUNTABLE_IMAGE_INJ-val">COUNTABLE_IMAGE_INJ</a> : thm
<a name="line164"></a>    val <a href="#COUNTABLE_IMAGE_INJ_EQ-val">COUNTABLE_IMAGE_INJ_EQ</a> : thm
<a name="line165"></a>    val <a href="#COUNTABLE_IMAGE_INJ_GENERAL-val">COUNTABLE_IMAGE_INJ_GENERAL</a> : thm
<a name="line166"></a>    val <a href="#COUNTABLE_INSERT-val">COUNTABLE_INSERT</a> : thm
<a name="line167"></a>    val <a href="#COUNTABLE_INTER-val">COUNTABLE_INTER</a> : thm
<a name="line168"></a>    val <a href="#COUNTABLE_LIST_UNIV-val">COUNTABLE_LIST_UNIV</a> : thm
<a name="line169"></a>    val <a href="#COUNTABLE_LIST_UNIV'-val">COUNTABLE_LIST_UNIV'</a> : thm
<a name="line170"></a>    val <a href="#COUNTABLE_PRODUCT_DEPENDENT-val">COUNTABLE_PRODUCT_DEPENDENT</a> : thm
<a name="line171"></a>    val <a href="#COUNTABLE_RESTRICT-val">COUNTABLE_RESTRICT</a> : thm
<a name="line172"></a>    val <a href="#COUNTABLE_SING-val">COUNTABLE_SING</a> : thm
<a name="line173"></a>    val <a href="#COUNTABLE_UNION-val">COUNTABLE_UNION</a> : thm
<a name="line174"></a>    val <a href="#COUNTABLE_UNION_IMP-val">COUNTABLE_UNION_IMP</a> : thm
<a name="line175"></a>    val <a href="#EMPTY_CARDLEQ-val">EMPTY_CARDLEQ</a> : thm
<a name="line176"></a>    val <a href="#EMPTY_set_exp-val">EMPTY_set_exp</a> : thm
<a name="line177"></a>    val <a href="#EMPTY_set_exp_CARD-val">EMPTY_set_exp_CARD</a> : thm
<a name="line178"></a>    val <a href="#EQ_C-val">EQ_C</a> : thm
<a name="line179"></a>    val <a href="#EQ_C_BIJECTIONS-val">EQ_C_BIJECTIONS</a> : thm
<a name="line180"></a>    val <a href="#EXISTS_IN_GSPEC-val">EXISTS_IN_GSPEC</a> : thm
<a name="line181"></a>    val <a href="#FINITE_012-val">FINITE_012</a> : thm
<a name="line182"></a>    val <a href="#FINITE_BOOL-val">FINITE_BOOL</a> : thm
<a name="line183"></a>    val <a href="#FINITE_CARD_LT-val">FINITE_CARD_LT</a> : thm
<a name="line184"></a>    val <a href="#FINITE_CLE_INFINITE-val">FINITE_CLE_INFINITE</a> : thm
<a name="line185"></a>    val <a href="#FINITE_EXPONENT_SETEXP_COUNTABLE-val">FINITE_EXPONENT_SETEXP_COUNTABLE</a> : thm
<a name="line186"></a>    val <a href="#FINITE_EXPONENT_SETEXP_UNCOUNTABLE-val">FINITE_EXPONENT_SETEXP_UNCOUNTABLE</a> : thm
<a name="line187"></a>    val <a href="#FINITE_IMAGE_INJ-val">FINITE_IMAGE_INJ</a> : thm
<a name="line188"></a>    val <a href="#FINITE_IMAGE_INJ_GENERAL-val">FINITE_IMAGE_INJ_GENERAL</a> : thm
<a name="line189"></a>    val <a href="#FINITE_IMP_COUNTABLE-val">FINITE_IMP_COUNTABLE</a> : thm
<a name="line190"></a>    val <a href="#FINITE_setexp-val">FINITE_setexp</a> : thm
<a name="line191"></a>    val <a href="#FORALL_COUNTABLE_AS_IMAGE-val">FORALL_COUNTABLE_AS_IMAGE</a> : thm
<a name="line192"></a>    val <a href="#FORALL_IN_GSPEC-val">FORALL_IN_GSPEC</a> : thm
<a name="line193"></a>    val <a href="#GE-val">GE</a> : thm
<a name="line194"></a>    val <a href="#GE_C-val">GE_C</a> : thm
<a name="line195"></a>    val <a href="#HAS_SIZE_BOOL-val">HAS_SIZE_BOOL</a> : thm
<a name="line196"></a>    val <a href="#HAS_SIZE_CLAUSES-val">HAS_SIZE_CLAUSES</a> : thm
<a name="line197"></a>    val <a href="#IMAGE_cardleq-val">IMAGE_cardleq</a> : thm
<a name="line198"></a>    val <a href="#IMAGE_cardleq_rwt-val">IMAGE_cardleq_rwt</a> : thm
<a name="line199"></a>    val <a href="#IMP_CONJ_ALT-val">IMP_CONJ_ALT</a> : thm
<a name="line200"></a>    val <a href="#INFINITE_A_list_BIJ_A-val">INFINITE_A_list_BIJ_A</a> : thm
<a name="line201"></a>    val <a href="#INFINITE_DIFF_FINITE-val">INFINITE_DIFF_FINITE</a> : thm
<a name="line202"></a>    val <a href="#INFINITE_IMAGE_INJ-val">INFINITE_IMAGE_INJ</a> : thm
<a name="line203"></a>    val <a href="#INFINITE_NONEMPTY-val">INFINITE_NONEMPTY</a> : thm
<a name="line204"></a>    val <a href="#INFINITE_UNIV_INF-val">INFINITE_UNIV_INF</a> : thm
<a name="line205"></a>    val <a href="#INFINITE_Unum-val">INFINITE_Unum</a> : thm
<a name="line206"></a>    val <a href="#INFINITE_cardleq_INSERT-val">INFINITE_cardleq_INSERT</a> : thm
<a name="line207"></a>    val <a href="#INJECTIVE_ALT-val">INJECTIVE_ALT</a> : thm
<a name="line208"></a>    val <a href="#INJECTIVE_IMAGE-val">INJECTIVE_IMAGE</a> : thm
<a name="line209"></a>    val <a href="#INJECTIVE_LEFT_INVERSE-val">INJECTIVE_LEFT_INVERSE</a> : thm
<a name="line210"></a>    val <a href="#INJECTIVE_ON_ALT-val">INJECTIVE_ON_ALT</a> : thm
<a name="line211"></a>    val <a href="#INJECTIVE_ON_IMAGE-val">INJECTIVE_ON_IMAGE</a> : thm
<a name="line212"></a>    val <a href="#INJECTIVE_ON_LEFT_INVERSE-val">INJECTIVE_ON_LEFT_INVERSE</a> : thm
<a name="line213"></a>    val <a href="#INTER_ACI-val">INTER_ACI</a> : thm
<a name="line214"></a>    val <a href="#IN_CARD_ADD-val">IN_CARD_ADD</a> : thm
<a name="line215"></a>    val <a href="#IN_CARD_MUL-val">IN_CARD_MUL</a> : thm
<a name="line216"></a>    val <a href="#IN_ELIM_PAIR_THM-val">IN_ELIM_PAIR_THM</a> : thm
<a name="line217"></a>    val <a href="#LEFT_IMP_EXISTS_THM-val">LEFT_IMP_EXISTS_THM</a> : thm
<a name="line218"></a>    val <a href="#LEFT_IMP_FORALL_THM-val">LEFT_IMP_FORALL_THM</a> : thm
<a name="line219"></a>    val <a href="#LE_1-val">LE_1</a> : thm
<a name="line220"></a>    val <a href="#LE_C-val">LE_C</a> : thm
<a name="line221"></a>    val <a href="#LE_SUC_LT-val">LE_SUC_LT</a> : thm
<a name="line222"></a>    val <a href="#LT_NZ-val">LT_NZ</a> : thm
<a name="line223"></a>    val <a href="#MUL_C_UNIV-val">MUL_C_UNIV</a> : thm
<a name="line224"></a>    val <a href="#NUM_COUNTABLE-val">NUM_COUNTABLE</a> : thm
<a name="line225"></a>    val <a href="#OR_EXISTS_THM-val">OR_EXISTS_THM</a> : thm
<a name="line226"></a>    val <a href="#POW_EQ_X_EXP_X-val">POW_EQ_X_EXP_X</a> : thm
<a name="line227"></a>    val <a href="#POW_TWO_set_exp-val">POW_TWO_set_exp</a> : thm
<a name="line228"></a>    val <a href="#RIGHT_IMP_EXISTS_THM-val">RIGHT_IMP_EXISTS_THM</a> : thm
<a name="line229"></a>    val <a href="#RIGHT_IMP_FORALL_THM-val">RIGHT_IMP_FORALL_THM</a> : thm
<a name="line230"></a>    val <a href="#SET_SQUARED_CARDEQ_SET-val">SET_SQUARED_CARDEQ_SET</a> : thm
<a name="line231"></a>    val <a href="#SET_SUM_CARDEQ_SET-val">SET_SUM_CARDEQ_SET</a> : thm
<a name="line232"></a>    val <a href="#SING_SUBSET-val">SING_SUBSET</a> : thm
<a name="line233"></a>    val <a href="#SING_set_exp-val">SING_set_exp</a> : thm
<a name="line234"></a>    val <a href="#SING_set_exp_CARD-val">SING_set_exp_CARD</a> : thm
<a name="line235"></a>    val <a href="#SUBSET_CARDLEQ-val">SUBSET_CARDLEQ</a> : thm
<a name="line236"></a>    val <a href="#SURJECTIVE_IMAGE-val">SURJECTIVE_IMAGE</a> : thm
<a name="line237"></a>    val <a href="#SURJECTIVE_IMAGE_THM-val">SURJECTIVE_IMAGE_THM</a> : thm
<a name="line238"></a>    val <a href="#SURJECTIVE_ON_IMAGE-val">SURJECTIVE_ON_IMAGE</a> : thm
<a name="line239"></a>    val <a href="#SURJECTIVE_ON_RIGHT_INVERSE-val">SURJECTIVE_ON_RIGHT_INVERSE</a> : thm
<a name="line240"></a>    val <a href="#SURJECTIVE_RIGHT_INVERSE-val">SURJECTIVE_RIGHT_INVERSE</a> : thm
<a name="line241"></a>    val <a href="#UNION_ACI-val">UNION_ACI</a> : thm
<a name="line242"></a>    val <a href="#UNION_LE_ADD_C-val">UNION_LE_ADD_C</a> : thm
<a name="line243"></a>    val <a href="#UNIV_fun_exp-val">UNIV_fun_exp</a> : thm
<a name="line244"></a>    val <a href="#UNIV_list-val">UNIV_list</a> : thm
<a name="line245"></a>    val <a href="#bijections_cardeq-val">bijections_cardeq</a> : thm
<a name="line246"></a>    val <a href="#bijns_alt_permutes-val">bijns_alt_permutes</a> : thm
<a name="line247"></a>    val <a href="#cardeq_INSERT-val">cardeq_INSERT</a> : thm
<a name="line248"></a>    val <a href="#cardeq_REFL-val">cardeq_REFL</a> : thm
<a name="line249"></a>    val <a href="#cardeq_SYM-val">cardeq_SYM</a> : thm
<a name="line250"></a>    val <a href="#cardeq_TRANS-val">cardeq_TRANS</a> : thm
<a name="line251"></a>    val <a href="#cardeq_addUnum-val">cardeq_addUnum</a> : thm
<a name="line252"></a>    val <a href="#cardeq_bijns_cong-val">cardeq_bijns_cong</a> : thm
<a name="line253"></a>    val <a href="#cardleq_ANTISYM-val">cardleq_ANTISYM</a> : thm
<a name="line254"></a>    val <a href="#cardleq_REFL-val">cardleq_REFL</a> : thm
<a name="line255"></a>    val <a href="#cardleq_SURJ-val">cardleq_SURJ</a> : thm
<a name="line256"></a>    val <a href="#cardleq_TRANS-val">cardleq_TRANS</a> : thm
<a name="line257"></a>    val <a href="#cardleq_copy_wellorders-val">cardleq_copy_wellorders</a> : thm
<a name="line258"></a>    val <a href="#cardleq_dichotomy-val">cardleq_dichotomy</a> : thm
<a name="line259"></a>    val <a href="#cardleq_empty-val">cardleq_empty</a> : thm
<a name="line260"></a>    val <a href="#cardleq_lt_trans-val">cardleq_lt_trans</a> : thm
<a name="line261"></a>    val <a href="#cardleq_lteq-val">cardleq_lteq</a> : thm
<a name="line262"></a>    val <a href="#cardleq_setexp-val">cardleq_setexp</a> : thm
<a name="line263"></a>    val <a href="#cardlt_REFL-val">cardlt_REFL</a> : thm
<a name="line264"></a>    val <a href="#cardlt_TRANS-val">cardlt_TRANS</a> : thm
<a name="line265"></a>    val <a href="#cardlt_cardle-val">cardlt_cardle</a> : thm
<a name="line266"></a>    val <a href="#cardlt_lenoteq-val">cardlt_lenoteq</a> : thm
<a name="line267"></a>    val <a href="#cardlt_leq_trans-val">cardlt_leq_trans</a> : thm
<a name="line268"></a>    val <a href="#count_cardle-val">count_cardle</a> : thm
<a name="line269"></a>    val <a href="#countable_cardeq-val">countable_cardeq</a> : thm
<a name="line270"></a>    val <a href="#countable_setexp-val">countable_setexp</a> : thm
<a name="line271"></a>    val <a href="#countable_thm-val">countable_thm</a> : thm
<a name="line272"></a>    val <a href="#disjoint_countable_decomposition-val">disjoint_countable_decomposition</a> : thm
<a name="line273"></a>    val <a href="#disjoint_countable_decomposition2-val">disjoint_countable_decomposition2</a> : thm
<a name="line274"></a>    val <a href="#eq_c-val">eq_c</a> : thm
<a name="line275"></a>    val <a href="#exp_INSERT_cardeq-val">exp_INSERT_cardeq</a> : thm
<a name="line276"></a>    val <a href="#exp_c-val">exp_c</a> : thm
<a name="line277"></a>    val <a href="#exp_count_cardeq-val">exp_count_cardeq</a> : thm
<a name="line278"></a>    val <a href="#finite_subsets_bijection-val">finite_subsets_bijection</a> : thm
<a name="line279"></a>    val <a href="#fnOfSet_SING-val">fnOfSet_SING</a> : thm
<a name="line280"></a>    val <a href="#ge_c-val">ge_c</a> : thm
<a name="line281"></a>    val <a href="#gt_c-val">gt_c</a> : thm
<a name="line282"></a>    val <a href="#le_c-val">le_c</a> : thm
<a name="line283"></a>    val <a href="#list_BIGUNION_EXP-val">list_BIGUNION_EXP</a> : thm
<a name="line284"></a>    val <a href="#list_EMPTY-val">list_EMPTY</a> : thm
<a name="line285"></a>    val <a href="#list_SING-val">list_SING</a> : thm
<a name="line286"></a>    val <a href="#lt_c-val">lt_c</a> : thm
<a name="line287"></a>    val <a href="#mul_c-val">mul_c</a> : thm
<a name="line288"></a>    val <a href="#set_binomial2-val">set_binomial2</a> : thm
<a name="line289"></a>    val <a href="#set_exp_card_cong-val">set_exp_card_cong</a> : thm
<a name="line290"></a>    val <a href="#set_exp_cardle_cong-val">set_exp_cardle_cong</a> : thm
<a name="line291"></a>    val <a href="#set_exp_count-val">set_exp_count</a> : thm
<a name="line292"></a>    val <a href="#set_exp_product-val">set_exp_product</a> : thm
<a name="line293"></a>    val <a href="#setexp_eq_EMPTY-val">setexp_eq_EMPTY</a> : thm
<a name="line294"></a>    val <a href="#tupNONE_IN_BIGPRODi-val">tupNONE_IN_BIGPRODi</a> : thm
<a name="line295"></a>    val <a href="#wellorder_destWO-val">wellorder_destWO</a> : thm
<a name="line296"></a>(*
   [permutes] Parent theory of "cardinal"
   
   [wellorder] Parent theory of "cardinal"
   
   [<a name="BIGPROD_def-val"><b>BIGPROD_def</b></a>]  Definition
      
      ⊢ ∀A. BIGPROD A = BIGPRODi (λa. if a ∈ A then SOME a else NONE)
   
   [<a name="BIGPRODi_def-val"><b>BIGPRODi_def</b></a>]  Definition
      
      ⊢ ∀A. BIGPRODi A =
            {tup |
             (∀i. A i = NONE ⇒ tup i = NONE) ∧
             ∀i s. A i = SOME s ⇒ ∃a. tup i = SOME a ∧ a ∈ s}
   
   [<a name="bijns_def-val"><b>bijns_def</b></a>]  Definition
      
      ⊢ ∀A. bijns A = {f | f PERMUTES A ∧ ∀a. a ∉ A ⇒ f a = a}
   
   [<a name="cardeq_def-val"><b>cardeq_def</b></a>]  Definition
      
      ⊢ ∀s1 s2. s1 ≈ s2 ⇔ ∃f. BIJ f s1 s2
   
   [<a name="cardgeq_def-val"><b>cardgeq_def</b></a>]  Definition
      
      ⊢ ∀s t. s ≽ t ⇔ t ≼ s
   
   [<a name="cardgt_def-val"><b>cardgt_def</b></a>]  Definition
      
      ⊢ ∀s t. s ≻ t ⇔ t ≺ s
   
   [<a name="cardleq_def-val"><b>cardleq_def</b></a>]  Definition
      
      ⊢ ∀s1 s2. s1 ≼ s2 ⇔ ∃f. INJ f s1 s2
   
   [<a name="fnOfSet_def-val"><b>fnOfSet_def</b></a>]  Definition
      
      ⊢ ∀s k.
          fnOfSet s k =
          if ∃!v. (k,v) ∈ s then SOME (@v. (k,v) ∈ s) else NONE
   
   [<a name="list_def-val"><b>list_def</b></a>]  Definition
      
      ⊢ ∀A. list A = {l | ∀e. MEM e l ⇒ e ∈ A}
   
   [<a name="set_exp_def-val"><b>set_exp_def</b></a>]  Definition
      
      ⊢ ∀A B.
          A ** B =
          {f | (∀b. b ∈ B ⇒ ∃a. a ∈ A ∧ f b = a) ∧ ∀b. b ∉ B ⇒ f b = ARB}
   
   [<a name="BIGPROD_CONS-val"><b>BIGPROD_CONS</b></a>]  Theorem
      
      ⊢ A × BIGPROD As ≈ BIGPROD (IMAGE INL A INSERT IMAGE (IMAGE INR) As)
   
   [<a name="BIGPROD_EQ_EMPTY-val"><b>BIGPROD_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ BIGPROD As = ∅ ⇔ ∅ ∈ As
   
   [<a name="BIGPROD_ONE-val"><b>BIGPROD_ONE</b></a>]  Theorem
      
      ⊢ BIGPROD ∅ ≈ 𝟙
   
   [<a name="BIGPROD_SING-val"><b>BIGPROD_SING</b></a>]  Theorem
      
      ⊢ BIGPROD {A} ≈ A
   
   [<a name="BIGPROD_pair-val"><b>BIGPROD_pair</b></a>]  Theorem
      
      ⊢ A1 ≠ A2 ⇒ BIGPROD {A1; A2} ≈ A1 × A2
   
   [<a name="BIGPROD_thm-val"><b>BIGPROD_thm</b></a>]  Theorem
      
      ⊢ BIGPROD A =
        {tup |
         (∀s. s ∈ A ⇒ ∃a. tup s = SOME a ∧ a ∈ s) ∧
         ∀s. s ∉ A ⇒ tup s = NONE}
   
   [<a name="BIGPRODi_11-val"><b>BIGPRODi_11</b></a>]  Theorem
      
      ⊢ (∀i. Af i ≠ SOME ∅) ∧ (∀i. Bf i ≠ SOME ∅) ⇒
        (BIGPRODi Af = BIGPRODi Bf ⇔ Af = Bf)
   
   [<a name="BIGPRODi_EQ_EMPTY-val"><b>BIGPRODi_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ BIGPRODi Af = ∅ ⇔ ∃i. Af i = SOME ∅
   
   [<a name="BIGPRODi_KNONE-val"><b>BIGPRODi_KNONE</b></a>]  Theorem
      
      ⊢ BIGPRODi (K NONE) = {K NONE}
   
   [<a name="BIGPRODi_SING_CEQ-val"><b>BIGPRODi_SING_CEQ</b></a>]  Theorem
      
      ⊢ BIGPRODi (fnOfSet {(i,s)}) ≈ s
   
   [<a name="BIGPRODi_SING_EQ-val"><b>BIGPRODi_SING_EQ</b></a>]  Theorem
      
      ⊢ BIGPRODi (fnOfSet {(i,s)}) = {(K NONE)⦇i ↦ SOME a⦈ | a ∈ s}
   
   [<a name="BIGPRODi_pair-val"><b>BIGPRODi_pair</b></a>]  Theorem
      
      ⊢ i ≠ j ⇒ BIGPRODi (K NONE)⦇i ↦ SOME A1; j ↦ SOME A2⦈ ≈ A1 × A2
   
   [<a name="BIJECTIVE_INJECTIVE_SURJECTIVE-val"><b>BIJECTIVE_INJECTIVE_SURJECTIVE</b></a>]  Theorem
      
      ⊢ ∀f s t.
          (∀x. x ∈ s ⇒ f x ∈ t) ∧ (∀y. y ∈ t ⇒ ∃!x. x ∈ s ∧ f x = y) ⇔
          (∀x. x ∈ s ⇒ f x ∈ t) ∧
          (∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y) ∧
          ∀y. y ∈ t ⇒ ∃x. x ∈ s ∧ f x = y
   
   [<a name="BIJECTIVE_INVERSES-val"><b>BIJECTIVE_INVERSES</b></a>]  Theorem
      
      ⊢ ∀f s t.
          (∀x. x ∈ s ⇒ f x ∈ t) ∧ (∀y. y ∈ t ⇒ ∃!x. x ∈ s ∧ f x = y) ⇔
          (∀x. x ∈ s ⇒ f x ∈ t) ∧
          ∃g. (∀y. y ∈ t ⇒ g y ∈ s) ∧ (∀y. y ∈ t ⇒ f (g y) = y) ∧
              ∀x. x ∈ s ⇒ g (f x) = x
   
   [<a name="BIJ_functions_agree-val"><b>BIJ_functions_agree</b></a>]  Theorem
      
      ⊢ ∀f g s t. BIJ f s t ∧ (∀x. x ∈ s ⇒ f x = g x) ⇒ BIJ g s t
   
   [<a name="CANTOR-val"><b>CANTOR</b></a>]  Theorem
      
      ⊢ A ≺ POW A
   
   [<a name="CANTOR_THM-val"><b>CANTOR_THM</b></a>]  Theorem
      
      ⊢ ∀s. s ≺ {t | t ⊆ s}
   
   [<a name="CANTOR_THM_UNIV-val"><b>CANTOR_THM_UNIV</b></a>]  Theorem
      
      ⊢ 𝕌(:α) ≺ 𝕌(:α -&gt; bool)
   
   [<a name="CARD1_SING-val"><b>CARD1_SING</b></a>]  Theorem
      
      ⊢ A ≈ 𝟙 ⇔ ∃a. A = {a}
   
   [<a name="CARDEQ_0-val"><b>CARDEQ_0</b></a>]  Theorem
      
      ⊢ (x ≈ ∅ ⇔ x = ∅) ∧ (∅ ≈ x ⇔ x = ∅)
   
   [<a name="CARDEQ_CARD-val"><b>CARDEQ_CARD</b></a>]  Theorem
      
      ⊢ s1 ≈ s2 ∧ FINITE s1 ⇒ CARD s1 = CARD s2
   
   [<a name="CARDEQ_CARDLEQ-val"><b>CARDEQ_CARDLEQ</b></a>]  Theorem
      
      ⊢ s1 ≈ s2 ∧ t1 ≈ t2 ⇒ (s1 ≼ t1 ⇔ s2 ≼ t2)
   
   [<a name="CARDEQ_CARD_EQN-val"><b>CARDEQ_CARD_EQN</b></a>]  Theorem
      
      ⊢ FINITE s1 ∧ FINITE s2 ⇒ (s1 ≈ s2 ⇔ CARD s1 = CARD s2)
   
   [<a name="CARDEQ_CROSS-val"><b>CARDEQ_CROSS</b></a>]  Theorem
      
      ⊢ s1 ≈ s2 ∧ t1 ≈ t2 ⇒ s1 × t1 ≈ s2 × t2
   
   [<a name="CARDEQ_CROSS_1-val"><b>CARDEQ_CROSS_1</b></a>]  Theorem
      
      ⊢ {x} × A ≈ A ∧ A × {x} ≈ A
   
   [<a name="CARDEQ_CROSS_SYM-val"><b>CARDEQ_CROSS_SYM</b></a>]  Theorem
      
      ⊢ s × t ≈ t × s
   
   [<a name="CARDEQ_DISJOINT_UNION-val"><b>CARDEQ_DISJOINT_UNION</b></a>]  Theorem
      
      ⊢ ∀s t. s ∩ t = ∅ ⇒ s ∪ t ≈ s ⊔ t
   
   [<a name="CARDEQ_FINITE-val"><b>CARDEQ_FINITE</b></a>]  Theorem
      
      ⊢ s1 ≈ s2 ⇒ (FINITE s1 ⇔ FINITE s2)
   
   [<a name="CARDEQ_INSERT_RWT-val"><b>CARDEQ_INSERT_RWT</b></a>]  Theorem
      
      ⊢ ∀s. INFINITE s ⇒ x INSERT s ≈ s
   
   [<a name="CARDEQ_SUBSET_CARDLEQ-val"><b>CARDEQ_SUBSET_CARDLEQ</b></a>]  Theorem
      
      ⊢ s ≈ t ⇒ s ≼ t
   
   [<a name="CARDLEQ_CARD-val"><b>CARDLEQ_CARD</b></a>]  Theorem
      
      ⊢ FINITE s1 ∧ FINITE s2 ⇒ (s1 ≼ s2 ⇔ CARD s1 ≤ CARD s2)
   
   [<a name="CARDLEQ_CROSS_CONG-val"><b>CARDLEQ_CROSS_CONG</b></a>]  Theorem
      
      ⊢ ∀x1 x2 y1 y2. x1 ≼ x2 ∧ y1 ≼ y2 ⇒ x1 × y1 ≼ x2 × y2
   
   [<a name="CARDLEQ_FINITE-val"><b>CARDLEQ_FINITE</b></a>]  Theorem
      
      ⊢ ∀s1 s2. FINITE s2 ∧ s1 ≼ s2 ⇒ FINITE s1
   
   [<a name="CARD_12-val"><b>CARD_12</b></a>]  Theorem
      
      ⊢ 𝟙 ≺ 𝟚 ∧ 𝟙 ≉ 𝟚 ∧ 𝟚 ≉ 𝟙 ∧ 𝟙 ≼ 𝟚
   
   [<a name="CARD_ADD2_ABSORB_LE-val"><b>CARD_ADD2_ABSORB_LE</b></a>]  Theorem
      
      ⊢ ∀s t u. INFINITE u ∧ s ≼ u ∧ t ≼ u ⇒ s ⊔ t ≼ u
   
   [<a name="CARD_ADD2_ABSORB_LT-val"><b>CARD_ADD2_ABSORB_LT</b></a>]  Theorem
      
      ⊢ ∀s t u. INFINITE u ∧ s ≺ u ∧ t ≺ u ⇒ s ⊔ t ≺ u
   
   [<a name="CARD_ADD_ABSORB-val"><b>CARD_ADD_ABSORB</b></a>]  Theorem
      
      ⊢ ∀s t. INFINITE t ∧ s ≼ t ⇒ s ⊔ t ≈ t
   
   [<a name="CARD_ADD_ABSORB_LE-val"><b>CARD_ADD_ABSORB_LE</b></a>]  Theorem
      
      ⊢ ∀s t. INFINITE t ∧ s ≼ t ⇒ s ⊔ t ≼ t
   
   [<a name="CARD_ADD_ASSOC-val"><b>CARD_ADD_ASSOC</b></a>]  Theorem
      
      ⊢ ∀s t u. s ⊔ (t ⊔ u) ≈ s ⊔ t ⊔ u
   
   [<a name="CARD_ADD_C-val"><b>CARD_ADD_C</b></a>]  Theorem
      
      ⊢ FINITE s ∧ FINITE t ⇒ CARD (s ⊔ t) = CARD s + CARD t
   
   [<a name="CARD_ADD_CONG-val"><b>CARD_ADD_CONG</b></a>]  Theorem
      
      ⊢ ∀s s' t t'. s ≈ s' ∧ t ≈ t' ⇒ s ⊔ t ≈ s' ⊔ t'
   
   [<a name="CARD_ADD_FINITE-val"><b>CARD_ADD_FINITE</b></a>]  Theorem
      
      ⊢ ∀s t. FINITE s ∧ FINITE t ⇒ FINITE (s ⊔ t)
   
   [<a name="CARD_ADD_FINITE_EQ-val"><b>CARD_ADD_FINITE_EQ</b></a>]  Theorem
      
      ⊢ ∀s t. FINITE (s ⊔ t) ⇔ FINITE s ∧ FINITE t
   
   [<a name="CARD_ADD_LE_MUL_INFINITE-val"><b>CARD_ADD_LE_MUL_INFINITE</b></a>]  Theorem
      
      ⊢ ∀s. INFINITE s ⇒ s ⊔ s ≼ s × s
   
   [<a name="CARD_ADD_SYM-val"><b>CARD_ADD_SYM</b></a>]  Theorem
      
      ⊢ ∀s t. s ⊔ t ≈ t ⊔ s
   
   [<a name="CARD_BIGUNION-val"><b>CARD_BIGUNION</b></a>]  Theorem
      
      ⊢ INFINITE k ∧ s1 ≼ k ∧ (∀e. e ∈ s1 ⇒ e ≼ k) ⇒ BIGUNION s1 ≼ k
   
   [<a name="CARD_BIGUNION_LE-val"><b>CARD_BIGUNION_LE</b></a>]  Theorem
      
      ⊢ ∀s t m n.
          s HAS_SIZE m ∧ (∀x. x ∈ s ⇒ FINITE (t x) ∧ CARD (t x) ≤ n) ⇒
          CARD (BIGUNION {t x | x ∈ s}) ≤ m * n
   
   [<a name="CARD_BOOL-val"><b>CARD_BOOL</b></a>]  Theorem
      
      ⊢ CARD 𝕌(:bool) = 2
   
   [<a name="CARD_CARDEQ_I-val"><b>CARD_CARDEQ_I</b></a>]  Theorem
      
      ⊢ FINITE s1 ∧ FINITE s2 ∧ CARD s1 = CARD s2 ⇒ s1 ≈ s2
   
   [<a name="CARD_COUNTABLE_CONG-val"><b>CARD_COUNTABLE_CONG</b></a>]  Theorem
      
      ⊢ ∀s t. s ≈ t ⇒ (countable s ⇔ countable t)
   
   [<a name="CARD_DISJOINT_UNION-val"><b>CARD_DISJOINT_UNION</b></a>]  Theorem
      
      ⊢ ∀s t.
          FINITE s ∧ FINITE t ∧ s ∩ t = ∅ ⇒ CARD (s ∪ t) = CARD s + CARD t
   
   [<a name="CARD_EQ_BIJECTION-val"><b>CARD_EQ_BIJECTION</b></a>]  Theorem
      
      ⊢ ∀s t.
          FINITE s ∧ FINITE t ∧ CARD s = CARD t ⇒
          ∃f. (∀x. x ∈ s ⇒ f x ∈ t) ∧ (∀y. y ∈ t ⇒ ∃x. x ∈ s ∧ f x = y) ∧
              ∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y
   
   [<a name="CARD_EQ_BIJECTIONS-val"><b>CARD_EQ_BIJECTIONS</b></a>]  Theorem
      
      ⊢ ∀s t.
          FINITE s ∧ FINITE t ∧ CARD s = CARD t ⇒
          ∃f g.
            (∀x. x ∈ s ⇒ f x ∈ t ∧ g (f x) = x) ∧
            ∀y. y ∈ t ⇒ g y ∈ s ∧ f (g y) = y
   
   [<a name="CARD_EQ_CARD-val"><b>CARD_EQ_CARD</b></a>]  Theorem
      
      ⊢ ∀s t. FINITE s ∧ FINITE t ⇒ (s ≈ t ⇔ CARD s = CARD t)
   
   [<a name="CARD_EQ_CARD_IMP-val"><b>CARD_EQ_CARD_IMP</b></a>]  Theorem
      
      ⊢ ∀s t. FINITE t ∧ s ≈ t ⇒ CARD s = CARD t
   
   [<a name="CARD_EQ_CONG-val"><b>CARD_EQ_CONG</b></a>]  Theorem
      
      ⊢ ∀s s' t t'. s ≈ s' ∧ t ≈ t' ⇒ (s ≈ t ⇔ s' ≈ t')
   
   [<a name="CARD_EQ_COUNTABLE-val"><b>CARD_EQ_COUNTABLE</b></a>]  Theorem
      
      ⊢ ∀s t. countable t ∧ s ≈ t ⇒ countable s
   
   [<a name="CARD_EQ_EMPTY-val"><b>CARD_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ ∀s. s ≈ ∅ ⇔ s = ∅
   
   [<a name="CARD_EQ_FINITE-val"><b>CARD_EQ_FINITE</b></a>]  Theorem
      
      ⊢ ∀s t. FINITE t ∧ s ≈ t ⇒ FINITE s
   
   [<a name="CARD_EQ_IMAGE-val"><b>CARD_EQ_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s. (∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y) ⇒ IMAGE f s ≈ s
   
   [<a name="CARD_EQ_IMP_LE-val"><b>CARD_EQ_IMP_LE</b></a>]  Theorem
      
      ⊢ ∀s t. s ≈ t ⇒ s ≼ t
   
   [<a name="CARD_EQ_REFL-val"><b>CARD_EQ_REFL</b></a>]  Theorem
      
      ⊢ ∀s. s ≈ s
   
   [<a name="CARD_EQ_SYM-val"><b>CARD_EQ_SYM</b></a>]  Theorem
      
      ⊢ ∀s t. s ≈ t ⇔ t ≈ s
   
   [<a name="CARD_EQ_TRANS-val"><b>CARD_EQ_TRANS</b></a>]  Theorem
      
      ⊢ ∀s t u. s ≈ t ∧ t ≈ u ⇒ s ≈ u
   
   [<a name="CARD_EXP_ABSORB-val"><b>CARD_EXP_ABSORB</b></a>]  Theorem
      
      ⊢ ∀s t.
          INFINITE t ∧ 𝕌(:bool) ≼ s ∧ s ≼ 𝕌(:bool) ** t ⇒
          s ** t ≈ 𝕌(:bool) ** t
   
   [<a name="CARD_EXP_CANTOR-val"><b>CARD_EXP_CANTOR</b></a>]  Theorem
      
      ⊢ ∀s. s ≺ 𝕌(:bool) ** s
   
   [<a name="CARD_EXP_CONG-val"><b>CARD_EXP_CONG</b></a>]  Theorem
      
      ⊢ ∀s s' t t'. s ≈ s' ∧ t ≈ t' ⇒ s ** t ≈ s' ** t'
   
   [<a name="CARD_EXP_MUL-val"><b>CARD_EXP_MUL</b></a>]  Theorem
      
      ⊢ ∀s t u. s ** (t × u) ≈ (s ** t) ** u
   
   [<a name="CARD_EXP_POWERSET-val"><b>CARD_EXP_POWERSET</b></a>]  Theorem
      
      ⊢ ∀s. 𝕌(:bool) ** s ≈ {t | t ⊆ s}
   
   [<a name="CARD_EXP_SING-val"><b>CARD_EXP_SING</b></a>]  Theorem
      
      ⊢ ∀s b. s ** {b} ≈ s
   
   [<a name="CARD_EXP_UNIV-val"><b>CARD_EXP_UNIV</b></a>]  Theorem
      
      ⊢ 𝕌(:β) ** 𝕌(:α) = 𝕌(:α -&gt; β)
   
   [<a name="CARD_FINITE_CONG-val"><b>CARD_FINITE_CONG</b></a>]  Theorem
      
      ⊢ ∀s t. s ≈ t ⇒ (FINITE s ⇔ FINITE t)
   
   [<a name="CARD_HAS_SIZE_CONG-val"><b>CARD_HAS_SIZE_CONG</b></a>]  Theorem
      
      ⊢ ∀s t n. s HAS_SIZE n ∧ s ≈ t ⇒ t HAS_SIZE n
   
   [<a name="CARD_INFINITE_CONG-val"><b>CARD_INFINITE_CONG</b></a>]  Theorem
      
      ⊢ ∀s t. s ≈ t ⇒ (INFINITE s ⇔ INFINITE t)
   
   [<a name="CARD_LDISTRIB-val"><b>CARD_LDISTRIB</b></a>]  Theorem
      
      ⊢ ∀s t u. s × (t ⊔ u) ≈ s × t ⊔ s × u
   
   [<a name="CARD_LET_TOTAL-val"><b>CARD_LET_TOTAL</b></a>]  Theorem
      
      ⊢ ∀s t. s ≼ t ∨ t ≺ s
   
   [<a name="CARD_LET_TRANS-val"><b>CARD_LET_TRANS</b></a>]  Theorem
      
      ⊢ ∀s t u. s ≼ t ∧ t ≺ u ⇒ s ≺ u
   
   [<a name="CARD_LE_ADD-val"><b>CARD_LE_ADD</b></a>]  Theorem
      
      ⊢ ∀s s' t t'. s ≼ s' ∧ t ≼ t' ⇒ s ⊔ t ≼ s' ⊔ t'
   
   [<a name="CARD_LE_ADDL-val"><b>CARD_LE_ADDL</b></a>]  Theorem
      
      ⊢ ∀s t. t ≼ s ⊔ t
   
   [<a name="CARD_LE_ADDR-val"><b>CARD_LE_ADDR</b></a>]  Theorem
      
      ⊢ ∀s t. s ≼ s ⊔ t
   
   [<a name="CARD_LE_ANTISYM-val"><b>CARD_LE_ANTISYM</b></a>]  Theorem
      
      ⊢ ∀s t. s ≼ t ∧ t ≼ s ⇔ s ≈ t
   
   [<a name="CARD_LE_CARD-val"><b>CARD_LE_CARD</b></a>]  Theorem
      
      ⊢ ∀s t. FINITE s ∧ FINITE t ⇒ (s ≼ t ⇔ CARD s ≤ CARD t)
   
   [<a name="CARD_LE_CARD_IMP-val"><b>CARD_LE_CARD_IMP</b></a>]  Theorem
      
      ⊢ ∀s t. FINITE t ∧ s ≼ t ⇒ CARD s ≤ CARD t
   
   [<a name="CARD_LE_CONG-val"><b>CARD_LE_CONG</b></a>]  Theorem
      
      ⊢ s1 ≈ s2 ∧ t1 ≈ t2 ⇒ (s1 ≼ t1 ⇔ s2 ≼ t2)
   
   [<a name="CARD_LE_COUNTABLE-val"><b>CARD_LE_COUNTABLE</b></a>]  Theorem
      
      ⊢ ∀s t. countable t ∧ s ≼ t ⇒ countable s
   
   [<a name="CARD_LE_EMPTY-val"><b>CARD_LE_EMPTY</b></a>]  Theorem
      
      ⊢ ∀s. s ≼ ∅ ⇔ s = ∅
   
   [<a name="CARD_LE_EQ_SUBSET-val"><b>CARD_LE_EQ_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t. s ≼ t ⇔ ∃u. u ⊆ t ∧ s ≈ u
   
   [<a name="CARD_LE_EXP-val"><b>CARD_LE_EXP</b></a>]  Theorem
      
      ⊢ 𝟚 ≼ B ⇒ A ≼ B ** A
   
   [<a name="CARD_LE_EXP_LEFT-val"><b>CARD_LE_EXP_LEFT</b></a>]  Theorem
      
      ⊢ ∀s s' t. s ≼ s' ⇒ s ** t ≼ s' ** t
   
   [<a name="CARD_LE_FINITE-val"><b>CARD_LE_FINITE</b></a>]  Theorem
      
      ⊢ ∀s t. FINITE t ∧ s ≼ t ⇒ FINITE s
   
   [<a name="CARD_LE_IMAGE-val"><b>CARD_LE_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s. IMAGE f s ≼ s
   
   [<a name="CARD_LE_IMAGE_GEN-val"><b>CARD_LE_IMAGE_GEN</b></a>]  Theorem
      
      ⊢ ∀f s t. t ⊆ IMAGE f s ⇒ t ≼ s
   
   [<a name="CARD_LE_INFINITE-val"><b>CARD_LE_INFINITE</b></a>]  Theorem
      
      ⊢ ∀s t. INFINITE s ∧ s ≼ t ⇒ INFINITE t
   
   [<a name="CARD_LE_INJ-val"><b>CARD_LE_INJ</b></a>]  Theorem
      
      ⊢ ∀s t.
          FINITE s ∧ FINITE t ∧ CARD s ≤ CARD t ⇒
          ∃f. IMAGE f s ⊆ t ∧ ∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y
   
   [<a name="CARD_LE_LT-val"><b>CARD_LE_LT</b></a>]  Theorem
      
      ⊢ ∀s1 s2. s1 ≼ s2 ⇔ s1 ≺ s2 ∨ s1 ≈ s2
   
   [<a name="CARD_LE_MUL-val"><b>CARD_LE_MUL</b></a>]  Theorem
      
      ⊢ ∀x1 x2 y1 y2. x1 ≼ x2 ∧ y1 ≼ y2 ⇒ x1 × y1 ≼ x2 × y2
   
   [<a name="CARD_LE_REFL-val"><b>CARD_LE_REFL</b></a>]  Theorem
      
      ⊢ ∀s. s ≼ s
   
   [<a name="CARD_LE_RELATIONAL-val"><b>CARD_LE_RELATIONAL</b></a>]  Theorem
      
      ⊢ ∀R s.
          (∀x y y'. x ∈ s ∧ R x y ∧ R x y' ⇒ y = y') ⇒
          {y | ∃x. x ∈ s ∧ R x y} ≼ s
   
   [<a name="CARD_LE_SQUARE-val"><b>CARD_LE_SQUARE</b></a>]  Theorem
      
      ⊢ ∀s. s ≼ s × s
   
   [<a name="CARD_LE_SUBSET-val"><b>CARD_LE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s t. s ⊆ t ⇒ s ≼ t
   
   [<a name="CARD_LE_TOTAL-val"><b>CARD_LE_TOTAL</b></a>]  Theorem
      
      ⊢ ∀s t. s ≼ t ∨ t ≼ s
   
   [<a name="CARD_LE_TRANS-val"><b>CARD_LE_TRANS</b></a>]  Theorem
      
      ⊢ ∀s t u. s ≼ t ∧ t ≼ u ⇒ s ≼ u
   
   [<a name="CARD_LE_UNIV-val"><b>CARD_LE_UNIV</b></a>]  Theorem
      
      ⊢ ∀s. s ≼ 𝕌(:α)
   
   [<a name="CARD_LTE_TOTAL-val"><b>CARD_LTE_TOTAL</b></a>]  Theorem
      
      ⊢ ∀s t. s ≺ t ∨ t ≼ s
   
   [<a name="CARD_LTE_TRANS-val"><b>CARD_LTE_TRANS</b></a>]  Theorem
      
      ⊢ ∀s t u. s ≺ t ∧ t ≼ u ⇒ s ≺ u
   
   [<a name="CARD_LT_ADD-val"><b>CARD_LT_ADD</b></a>]  Theorem
      
      ⊢ ∀s s' t t'. s ≺ s' ∧ t ≺ t' ⇒ s ⊔ t ≺ s' ⊔ t'
   
   [<a name="CARD_LT_CARD-val"><b>CARD_LT_CARD</b></a>]  Theorem
      
      ⊢ FINITE s1 ∧ FINITE s2 ⇒ (s1 ≺ s2 ⇔ CARD s1 &lt; CARD s2)
   
   [<a name="CARD_LT_CONG-val"><b>CARD_LT_CONG</b></a>]  Theorem
      
      ⊢ ∀s s' t t'. s ≈ s' ∧ t ≈ t' ⇒ (s ≺ t ⇔ s' ≺ t')
   
   [<a name="CARD_LT_FINITE_INFINITE-val"><b>CARD_LT_FINITE_INFINITE</b></a>]  Theorem
      
      ⊢ ∀s t. FINITE s ∧ INFINITE t ⇒ s ≺ t
   
   [<a name="CARD_LT_IMP_LE-val"><b>CARD_LT_IMP_LE</b></a>]  Theorem
      
      ⊢ ∀s t. s ≺ t ⇒ s ≼ t
   
   [<a name="CARD_LT_LE-val"><b>CARD_LT_LE</b></a>]  Theorem
      
      ⊢ ∀s t. s ≺ t ⇔ s ≼ t ∧ s ≉ t
   
   [<a name="CARD_LT_REFL-val"><b>CARD_LT_REFL</b></a>]  Theorem
      
      ⊢ ∀s. ¬(s ≺ s)
   
   [<a name="CARD_LT_TOTAL-val"><b>CARD_LT_TOTAL</b></a>]  Theorem
      
      ⊢ ∀s t. s ≈ t ∨ s ≺ t ∨ t ≺ s
   
   [<a name="CARD_LT_TRANS-val"><b>CARD_LT_TRANS</b></a>]  Theorem
      
      ⊢ ∀s t u. s ≺ t ∧ t ≺ u ⇒ s ≺ u
   
   [<a name="CARD_MUL2_ABSORB_LE-val"><b>CARD_MUL2_ABSORB_LE</b></a>]  Theorem
      
      ⊢ ∀s t u. INFINITE u ∧ s ≼ u ∧ t ≼ u ⇒ s × t ≼ u
   
   [<a name="CARD_MUL_ABSORB-val"><b>CARD_MUL_ABSORB</b></a>]  Theorem
      
      ⊢ ∀s t. INFINITE t ∧ s ≠ ∅ ∧ s ≼ t ⇒ s × t ≈ t
   
   [<a name="CARD_MUL_ABSORB_LE-val"><b>CARD_MUL_ABSORB_LE</b></a>]  Theorem
      
      ⊢ ∀s t. INFINITE t ∧ s ≼ t ⇒ s × t ≼ t
   
   [<a name="CARD_MUL_ASSOC-val"><b>CARD_MUL_ASSOC</b></a>]  Theorem
      
      ⊢ ∀s t u. s × t × u ≈ (s × t) × u
   
   [<a name="CARD_MUL_CONG-val"><b>CARD_MUL_CONG</b></a>]  Theorem
      
      ⊢ s1 ≈ s2 ∧ t1 ≈ t2 ⇒ s1 × t1 ≈ s2 × t2
   
   [<a name="CARD_MUL_FINITE-val"><b>CARD_MUL_FINITE</b></a>]  Theorem
      
      ⊢ ∀s t. FINITE s ∧ FINITE t ⇒ FINITE (s × t)
   
   [<a name="CARD_MUL_FINITE_EQ-val"><b>CARD_MUL_FINITE_EQ</b></a>]  Theorem
      
      ⊢ ∀s t. FINITE (s × t) ⇔ s = ∅ ∨ t = ∅ ∨ FINITE s ∧ FINITE t
   
   [<a name="CARD_MUL_LT_INFINITE-val"><b>CARD_MUL_LT_INFINITE</b></a>]  Theorem
      
      ⊢ ∀s t. s ≺ t ∧ t ≺ u ∧ INFINITE u ⇒ s × t ≺ u
   
   [<a name="CARD_MUL_LT_LEMMA-val"><b>CARD_MUL_LT_LEMMA</b></a>]  Theorem
      
      ⊢ ∀s t. s ≼ t ∧ t ≺ u ∧ INFINITE u ⇒ s × t ≺ u
   
   [<a name="CARD_MUL_SYM-val"><b>CARD_MUL_SYM</b></a>]  Theorem
      
      ⊢ s × t ≈ t × s
   
   [<a name="CARD_NOT_LE-val"><b>CARD_NOT_LE</b></a>]  Theorem
      
      ⊢ ∀s t. t ≺ s ⇔ t ≺ s
   
   [<a name="CARD_NOT_LT-val"><b>CARD_NOT_LT</b></a>]  Theorem
      
      ⊢ ∀s t. ¬(s ≺ t) ⇔ t ≼ s
   
   [<a name="CARD_RDISTRIB-val"><b>CARD_RDISTRIB</b></a>]  Theorem
      
      ⊢ ∀s t u. (s ⊔ t) × u ≈ s × u ⊔ t × u
   
   [<a name="CARD_SQUARE_INFINITE-val"><b>CARD_SQUARE_INFINITE</b></a>]  Theorem
      
      ⊢ ∀s. INFINITE s ⇒ s × s ≈ s
   
   [<a name="CARD_SQUARE_NUM-val"><b>CARD_SQUARE_NUM</b></a>]  Theorem
      
      ⊢ 𝕌(:num) × 𝕌(:num) ≈ 𝕌(:num)
   
   [<a name="CARD_SUBSET_EQ-val"><b>CARD_SUBSET_EQ</b></a>]  Theorem
      
      ⊢ ∀a b. FINITE b ∧ a ⊆ b ∧ CARD a = CARD b ⇒ a = b
   
   [<a name="CONJ_ACI-val"><b>CONJ_ACI</b></a>]  Theorem
      
      ⊢ ∀p q.
          (p ∧ q ⇔ q ∧ p) ∧ ((p ∧ q) ∧ r ⇔ p ∧ q ∧ r) ∧
          (p ∧ q ∧ r ⇔ q ∧ p ∧ r) ∧ (p ∧ p ⇔ p) ∧ (p ∧ p ∧ q ⇔ p ∧ q)
   
   [<a name="CONJ_EQ_IMP-val"><b>CONJ_EQ_IMP</b></a>]  Theorem
      
      ⊢ ∀p q r. p ∧ q ⇒ r ⇔ p ⇒ q ⇒ r
   
   [<a name="COUNTABLE-val"><b>COUNTABLE</b></a>]  Theorem
      
      ⊢ ∀t. countable t ⇔ 𝕌(:num) ≽ t
   
   [<a name="COUNTABLE_ALT_cardleq-val"><b>COUNTABLE_ALT_cardleq</b></a>]  Theorem
      
      ⊢ ∀s. countable s ⇔ s ≼ 𝕌(:num)
   
   [<a name="COUNTABLE_AS_IMAGE-val"><b>COUNTABLE_AS_IMAGE</b></a>]  Theorem
      
      ⊢ ∀s. countable s ∧ s ≠ ∅ ⇒ ∃f. s = IMAGE f 𝕌(:num)
   
   [<a name="COUNTABLE_AS_IMAGE_SUBSET-val"><b>COUNTABLE_AS_IMAGE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s. countable s ⇒ ∃f. s ⊆ IMAGE f 𝕌(:num)
   
   [<a name="COUNTABLE_AS_IMAGE_SUBSET_EQ-val"><b>COUNTABLE_AS_IMAGE_SUBSET_EQ</b></a>]  Theorem
      
      ⊢ ∀s. countable s ⇔ ∃f. s ⊆ IMAGE f 𝕌(:num)
   
   [<a name="COUNTABLE_AS_INJECTIVE_IMAGE-val"><b>COUNTABLE_AS_INJECTIVE_IMAGE</b></a>]  Theorem
      
      ⊢ ∀s. countable s ∧ INFINITE s ⇒
            ∃f. s = IMAGE f 𝕌(:num) ∧ ∀m n. f m = f n ⇒ m = n
   
   [<a name="COUNTABLE_BIGUNION-val"><b>COUNTABLE_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀s. countable s ∧ (∀x. x ∈ s ⇒ countable x) ⇒
            countable (BIGUNION s)
   
   [<a name="COUNTABLE_CASES-val"><b>COUNTABLE_CASES</b></a>]  Theorem
      
      ⊢ ∀s. countable s ⇔ FINITE s ∨ s ≈ 𝕌(:num)
   
   [<a name="COUNTABLE_CROSS-val"><b>COUNTABLE_CROSS</b></a>]  Theorem
      
      ⊢ ∀s t. countable s ∧ countable t ⇒ countable (s × t)
   
   [<a name="COUNTABLE_DELETE-val"><b>COUNTABLE_DELETE</b></a>]  Theorem
      
      ⊢ ∀x s. countable (s DELETE x) ⇔ countable s
   
   [<a name="COUNTABLE_DIFF_FINITE-val"><b>COUNTABLE_DIFF_FINITE</b></a>]  Theorem
      
      ⊢ ∀s t. FINITE s ⇒ (countable (t DIFF s) ⇔ countable t)
   
   [<a name="COUNTABLE_EMPTY-val"><b>COUNTABLE_EMPTY</b></a>]  Theorem
      
      ⊢ countable ∅
   
   [<a name="COUNTABLE_IMAGE-val"><b>COUNTABLE_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f s. countable s ⇒ countable (IMAGE f s)
   
   [<a name="COUNTABLE_IMAGE_INJ-val"><b>COUNTABLE_IMAGE_INJ</b></a>]  Theorem
      
      ⊢ ∀f A.
          (∀x y. f x = f y ⇒ x = y) ∧ countable A ⇒ countable {x | f x ∈ A}
   
   [<a name="COUNTABLE_IMAGE_INJ_EQ-val"><b>COUNTABLE_IMAGE_INJ_EQ</b></a>]  Theorem
      
      ⊢ ∀f s.
          (∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y) ⇒
          (countable (IMAGE f s) ⇔ countable s)
   
   [<a name="COUNTABLE_IMAGE_INJ_GENERAL-val"><b>COUNTABLE_IMAGE_INJ_GENERAL</b></a>]  Theorem
      
      ⊢ ∀f A s.
          (∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y) ∧ countable A ⇒
          countable {x | x ∈ s ∧ f x ∈ A}
   
   [<a name="COUNTABLE_INSERT-val"><b>COUNTABLE_INSERT</b></a>]  Theorem
      
      ⊢ ∀x s. countable (x INSERT s) ⇔ countable s
   
   [<a name="COUNTABLE_INTER-val"><b>COUNTABLE_INTER</b></a>]  Theorem
      
      ⊢ ∀s t. countable s ∨ countable t ⇒ countable (s ∩ t)
   
   [<a name="COUNTABLE_LIST_UNIV-val"><b>COUNTABLE_LIST_UNIV</b></a>]  Theorem
      
      ⊢ countable 𝕌(:α) ⇒ countable 𝕌(:α list)
   
   [<a name="COUNTABLE_LIST_UNIV'-val"><b>COUNTABLE_LIST_UNIV'</b></a>]  Theorem
      
      ⊢ FINITE 𝕌(:α) ⇒ countable 𝕌(:α list)
   
   [<a name="COUNTABLE_PRODUCT_DEPENDENT-val"><b>COUNTABLE_PRODUCT_DEPENDENT</b></a>]  Theorem
      
      ⊢ ∀f s t.
          countable s ∧ (∀x. x ∈ s ⇒ countable (t x)) ⇒
          countable {f x y | x ∈ s ∧ y ∈ t x}
   
   [<a name="COUNTABLE_RESTRICT-val"><b>COUNTABLE_RESTRICT</b></a>]  Theorem
      
      ⊢ ∀s P. countable s ⇒ countable {x | x ∈ s ∧ P x}
   
   [<a name="COUNTABLE_SING-val"><b>COUNTABLE_SING</b></a>]  Theorem
      
      ⊢ ∀x. countable {x}
   
   [<a name="COUNTABLE_UNION-val"><b>COUNTABLE_UNION</b></a>]  Theorem
      
      ⊢ ∀s t. countable (s ∪ t) ⇔ countable s ∧ countable t
   
   [<a name="COUNTABLE_UNION_IMP-val"><b>COUNTABLE_UNION_IMP</b></a>]  Theorem
      
      ⊢ ∀s t. countable s ∧ countable t ⇒ countable (s ∪ t)
   
   [<a name="EMPTY_CARDLEQ-val"><b>EMPTY_CARDLEQ</b></a>]  Theorem
      
      ⊢ ∅ ≼ t
   
   [<a name="EMPTY_set_exp-val"><b>EMPTY_set_exp</b></a>]  Theorem
      
      ⊢ A ** ∅ = {K ARB} ∧ (B ≠ ∅ ⇒ ∅ ** B = ∅)
   
   [<a name="EMPTY_set_exp_CARD-val"><b>EMPTY_set_exp_CARD</b></a>]  Theorem
      
      ⊢ A ** ∅ ≈ count 1
   
   [<a name="EQ_C-val"><b>EQ_C</b></a>]  Theorem
      
      ⊢ ∀s t.
          s ≈ t ⇔
          ∃R. (∀x y. R (x,y) ⇒ x ∈ s ∧ y ∈ t) ∧
              (∀x. x ∈ s ⇒ ∃!y. y ∈ t ∧ R (x,y)) ∧
              ∀y. y ∈ t ⇒ ∃!x. x ∈ s ∧ R (x,y)
   
   [<a name="EQ_C_BIJECTIONS-val"><b>EQ_C_BIJECTIONS</b></a>]  Theorem
      
      ⊢ ∀s t.
          s ≈ t ⇔
          ∃f g.
            (∀x. x ∈ s ⇒ f x ∈ t ∧ g (f x) = x) ∧
            ∀y. y ∈ t ⇒ g y ∈ s ∧ f (g y) = y
   
   [<a name="EXISTS_IN_GSPEC-val"><b>EXISTS_IN_GSPEC</b></a>]  Theorem
      
      ⊢ (∀P f. (∃z. z ∈ {f x | P x} ∧ Q z) ⇔ ∃x. P x ∧ Q (f x)) ∧
        (∀P f. (∃z. z ∈ {f x y | P x y} ∧ Q z) ⇔ ∃x y. P x y ∧ Q (f x y)) ∧
        ∀P f.
          (∃z. z ∈ {f w x y | P w x y} ∧ Q z) ⇔
          ∃w x y. P w x y ∧ Q (f w x y)
   
   [<a name="FINITE_012-val"><b>FINITE_012</b></a>]  Theorem
      
      ⊢ FINITE A ⇒ A = ∅ ∨ A ≈ 𝟙 ∨ 2 ≤ CARD A
   
   [<a name="FINITE_BOOL-val"><b>FINITE_BOOL</b></a>]  Theorem
      
      ⊢ FINITE 𝕌(:bool)
   
   [<a name="FINITE_CARD_LT-val"><b>FINITE_CARD_LT</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇔ s ≺ 𝕌(:num)
   
   [<a name="FINITE_CLE_INFINITE-val"><b>FINITE_CLE_INFINITE</b></a>]  Theorem
      
      ⊢ FINITE s ∧ INFINITE t ⇒ s ≼ t
   
   [<a name="FINITE_EXPONENT_SETEXP_COUNTABLE-val"><b>FINITE_EXPONENT_SETEXP_COUNTABLE</b></a>]  Theorem
      
      ⊢ FINITE B ⇒ (countable (A ** B) ⇔ B = ∅ ∨ countable A)
   
   [<a name="FINITE_EXPONENT_SETEXP_UNCOUNTABLE-val"><b>FINITE_EXPONENT_SETEXP_UNCOUNTABLE</b></a>]  Theorem
      
      ⊢ FINITE B ∧ B ≠ ∅ ∧ ¬countable A ⇒ ¬countable (A ** B)
   
   [<a name="FINITE_IMAGE_INJ-val"><b>FINITE_IMAGE_INJ</b></a>]  Theorem
      
      ⊢ ∀f A. (∀x y. f x = f y ⇒ x = y) ∧ FINITE A ⇒ FINITE {x | f x ∈ A}
   
   [<a name="FINITE_IMAGE_INJ_GENERAL-val"><b>FINITE_IMAGE_INJ_GENERAL</b></a>]  Theorem
      
      ⊢ ∀f A s.
          (∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y) ∧ FINITE A ⇒
          FINITE {x | x ∈ s ∧ f x ∈ A}
   
   [<a name="FINITE_IMP_COUNTABLE-val"><b>FINITE_IMP_COUNTABLE</b></a>]  Theorem
      
      ⊢ ∀s. FINITE s ⇒ countable s
   
   [<a name="FINITE_setexp-val"><b>FINITE_setexp</b></a>]  Theorem
      
      ⊢ FINITE (A ** B) ⇔ B = ∅ ∨ A ≼ 𝟙 ∨ FINITE A ∧ FINITE B
   
   [<a name="FORALL_COUNTABLE_AS_IMAGE-val"><b>FORALL_COUNTABLE_AS_IMAGE</b></a>]  Theorem
      
      ⊢ (∀d. countable d ⇒ P d) ⇔ P ∅ ∧ ∀f. P (IMAGE f 𝕌(:num))
   
   [<a name="FORALL_IN_GSPEC-val"><b>FORALL_IN_GSPEC</b></a>]  Theorem
      
      ⊢ (∀P f. (∀z. z ∈ {f x | P x} ⇒ Q z) ⇔ ∀x. P x ⇒ Q (f x)) ∧
        (∀P f. (∀z. z ∈ {f x y | P x y} ⇒ Q z) ⇔ ∀x y. P x y ⇒ Q (f x y)) ∧
        ∀P f.
          (∀z. z ∈ {f w x y | P w x y} ⇒ Q z) ⇔
          ∀w x y. P w x y ⇒ Q (f w x y)
   
   [<a name="GE-val"><b>GE</b></a>]  Theorem
      
      ⊢ ∀n m. m ≥ n ⇔ n ≤ m
   
   [<a name="GE_C-val"><b>GE_C</b></a>]  Theorem
      
      ⊢ ∀s t. s ≽ t ⇔ ∃f. ∀y. y ∈ t ⇒ ∃x. x ∈ s ∧ y = f x
   
   [<a name="HAS_SIZE_BOOL-val"><b>HAS_SIZE_BOOL</b></a>]  Theorem
      
      ⊢ 𝕌(:bool) HAS_SIZE 2
   
   [<a name="HAS_SIZE_CLAUSES-val"><b>HAS_SIZE_CLAUSES</b></a>]  Theorem
      
      ⊢ ∀s. (s HAS_SIZE 0 ⇔ s = ∅) ∧
            (s HAS_SIZE SUC n ⇔ ∃a t. t HAS_SIZE n ∧ a ∉ t ∧ s = a INSERT t)
   
   [<a name="IMAGE_cardleq-val"><b>IMAGE_cardleq</b></a>]  Theorem
      
      ⊢ ∀f s. IMAGE f s ≼ s
   
   [<a name="IMAGE_cardleq_rwt-val"><b>IMAGE_cardleq_rwt</b></a>]  Theorem
      
      ⊢ ∀s t. s ≼ t ⇒ IMAGE f s ≼ t
   
   [<a name="IMP_CONJ_ALT-val"><b>IMP_CONJ_ALT</b></a>]  Theorem
      
      ⊢ ∀p q r. p ∧ q ⇒ r ⇔ q ⇒ p ⇒ r
   
   [<a name="INFINITE_A_list_BIJ_A-val"><b>INFINITE_A_list_BIJ_A</b></a>]  Theorem
      
      ⊢ INFINITE A ⇒ list A ≈ A
   
   [<a name="INFINITE_DIFF_FINITE-val"><b>INFINITE_DIFF_FINITE</b></a>]  Theorem
      
      ⊢ ∀s t. INFINITE s ∧ FINITE t ⇒ INFINITE (s DIFF t)
   
   [<a name="INFINITE_IMAGE_INJ-val"><b>INFINITE_IMAGE_INJ</b></a>]  Theorem
      
      ⊢ ∀f. (∀x y. f x = f y ⇒ x = y) ⇒
            ∀s. INFINITE s ⇒ INFINITE (IMAGE f s)
   
   [<a name="INFINITE_NONEMPTY-val"><b>INFINITE_NONEMPTY</b></a>]  Theorem
      
      ⊢ ∀s. INFINITE s ⇒ s ≠ ∅
   
   [<a name="INFINITE_UNIV_INF-val"><b>INFINITE_UNIV_INF</b></a>]  Theorem
      
      ⊢ INFINITE 𝕌(:num + α)
   
   [<a name="INFINITE_Unum-val"><b>INFINITE_Unum</b></a>]  Theorem
      
      ⊢ INFINITE A ⇔ 𝕌(:num) ≼ A
   
   [<a name="INFINITE_cardleq_INSERT-val"><b>INFINITE_cardleq_INSERT</b></a>]  Theorem
      
      ⊢ INFINITE A ⇒ (x INSERT s ≼ A ⇔ s ≼ A)
   
   [<a name="INJECTIVE_ALT-val"><b>INJECTIVE_ALT</b></a>]  Theorem
      
      ⊢ ∀f. (∀x y. f x = f y ⇒ x = y) ⇔ ∀x y. f x = f y ⇔ x = y
   
   [<a name="INJECTIVE_IMAGE-val"><b>INJECTIVE_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f. (∀s t. IMAGE f s = IMAGE f t ⇒ s = t) ⇔ ∀x y. f x = f y ⇒ x = y
   
   [<a name="INJECTIVE_LEFT_INVERSE-val"><b>INJECTIVE_LEFT_INVERSE</b></a>]  Theorem
      
      ⊢ (∀x y. f x = f y ⇒ x = y) ⇔ ∃g. ∀x. g (f x) = x
   
   [<a name="INJECTIVE_ON_ALT-val"><b>INJECTIVE_ON_ALT</b></a>]  Theorem
      
      ⊢ ∀P f.
          (∀x y. P x ∧ P y ∧ f x = f y ⇒ x = y) ⇔
          ∀x y. P x ∧ P y ⇒ (f x = f y ⇔ x = y)
   
   [<a name="INJECTIVE_ON_IMAGE-val"><b>INJECTIVE_ON_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f u.
          (∀s t. s ⊆ u ∧ t ⊆ u ∧ IMAGE f s = IMAGE f t ⇒ s = t) ⇔
          ∀x y. x ∈ u ∧ y ∈ u ∧ f x = f y ⇒ x = y
   
   [<a name="INJECTIVE_ON_LEFT_INVERSE-val"><b>INJECTIVE_ON_LEFT_INVERSE</b></a>]  Theorem
      
      ⊢ ∀f s.
          (∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y) ⇔
          ∃g. ∀x. x ∈ s ⇒ g (f x) = x
   
   [<a name="INTER_ACI-val"><b>INTER_ACI</b></a>]  Theorem
      
      ⊢ ∀p q.
          p ∩ q = q ∩ p ∧ p ∩ q ∩ r = p ∩ q ∩ r ∧ p ∩ q ∩ r = q ∩ p ∩ r ∧
          p ∩ p = p ∧ p ∩ p ∩ q = p ∩ q
   
   [<a name="IN_CARD_ADD-val"><b>IN_CARD_ADD</b></a>]  Theorem
      
      ⊢ (INL a ∈ A ⊔ B ⇔ a ∈ A) ∧ (INR b ∈ A ⊔ B ⇔ b ∈ B)
   
   [<a name="IN_CARD_MUL-val"><b>IN_CARD_MUL</b></a>]  Theorem
      
      ⊢ ∀s t x y. (x,y) ∈ s × t ⇔ x ∈ s ∧ y ∈ t
   
   [<a name="IN_ELIM_PAIR_THM-val"><b>IN_ELIM_PAIR_THM</b></a>]  Theorem
      
      ⊢ ∀P a b. (a,b) ∈ {(x,y) | P x y} ⇔ P a b
   
   [<a name="LEFT_IMP_EXISTS_THM-val"><b>LEFT_IMP_EXISTS_THM</b></a>]  Theorem
      
      ⊢ ∀P Q. (∃x. P x) ⇒ Q ⇔ ∀x. P x ⇒ Q
   
   [<a name="LEFT_IMP_FORALL_THM-val"><b>LEFT_IMP_FORALL_THM</b></a>]  Theorem
      
      ⊢ ∀P Q. (∀x. P x) ⇒ Q ⇔ ∃x. P x ⇒ Q
   
   [<a name="LE_1-val"><b>LE_1</b></a>]  Theorem
      
      ⊢ (∀n. n ≠ 0 ⇒ 0 &lt; n) ∧ (∀n. n ≠ 0 ⇒ 1 ≤ n) ∧ (∀n. 0 &lt; n ⇒ n ≠ 0) ∧
        (∀n. 0 &lt; n ⇒ 1 ≤ n) ∧ (∀n. 1 ≤ n ⇒ 0 &lt; n) ∧ ∀n. 1 ≤ n ⇒ n ≠ 0
   
   [<a name="LE_C-val"><b>LE_C</b></a>]  Theorem
      
      ⊢ ∀s t. s ≼ t ⇔ ∃g. ∀x. x ∈ s ⇒ ∃y. y ∈ t ∧ g y = x
   
   [<a name="LE_SUC_LT-val"><b>LE_SUC_LT</b></a>]  Theorem
      
      ⊢ ∀m n. SUC m ≤ n ⇔ m &lt; n
   
   [<a name="LT_NZ-val"><b>LT_NZ</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇔ n ≠ 0
   
   [<a name="MUL_C_UNIV-val"><b>MUL_C_UNIV</b></a>]  Theorem
      
      ⊢ 𝕌(:α) × 𝕌(:β) = 𝕌(:α # β)
   
   [<a name="NUM_COUNTABLE-val"><b>NUM_COUNTABLE</b></a>]  Theorem
      
      ⊢ countable 𝕌(:num)
   
   [<a name="OR_EXISTS_THM-val"><b>OR_EXISTS_THM</b></a>]  Theorem
      
      ⊢ ∀P Q. (∃x. P x) ∨ (∃x. Q x) ⇔ ∃x. P x ∨ Q x
   
   [<a name="POW_EQ_X_EXP_X-val"><b>POW_EQ_X_EXP_X</b></a>]  Theorem
      
      ⊢ INFINITE A ⇒ POW A ≈ A ** A
   
   [<a name="POW_TWO_set_exp-val"><b>POW_TWO_set_exp</b></a>]  Theorem
      
      ⊢ POW A ≈ count 2 ** A
   
   [<a name="RIGHT_IMP_EXISTS_THM-val"><b>RIGHT_IMP_EXISTS_THM</b></a>]  Theorem
      
      ⊢ ∀P Q. P ⇒ (∃x. Q x) ⇔ ∃x. P ⇒ Q x
   
   [<a name="RIGHT_IMP_FORALL_THM-val"><b>RIGHT_IMP_FORALL_THM</b></a>]  Theorem
      
      ⊢ ∀P Q. P ⇒ (∀x. Q x) ⇔ ∀x. P ⇒ Q x
   
   [<a name="SET_SQUARED_CARDEQ_SET-val"><b>SET_SQUARED_CARDEQ_SET</b></a>]  Theorem
      
      ⊢ ∀s. INFINITE s ⇒ s × s ≈ s
   
   [<a name="SET_SUM_CARDEQ_SET-val"><b>SET_SUM_CARDEQ_SET</b></a>]  Theorem
      
      ⊢ INFINITE s ⇒
        s ≈ 𝟚 × s ∧ ∀A B. DISJOINT A B ∧ A ≈ s ∧ B ≈ s ⇒ A ∪ B ≈ s
   
   [<a name="SING_SUBSET-val"><b>SING_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s x. {x} ⊆ s ⇔ x ∈ s
   
   [<a name="SING_set_exp-val"><b>SING_set_exp</b></a>]  Theorem
      
      ⊢ {x} ** B = {(λb. if b ∈ B then x else ARB)} ∧
        A ** {x} = {(λb. if b = x then a else ARB) | a ∈ A}
   
   [<a name="SING_set_exp_CARD-val"><b>SING_set_exp_CARD</b></a>]  Theorem
      
      ⊢ {x} ** B ≈ count 1 ∧ A ** {x} ≈ A
   
   [<a name="SUBSET_CARDLEQ-val"><b>SUBSET_CARDLEQ</b></a>]  Theorem
      
      ⊢ ∀x y. x ⊆ y ⇒ x ≼ y
   
   [<a name="SURJECTIVE_IMAGE-val"><b>SURJECTIVE_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f. (∀t. ∃s. IMAGE f s = t) ⇔ ∀y. ∃x. f x = y
   
   [<a name="SURJECTIVE_IMAGE_THM-val"><b>SURJECTIVE_IMAGE_THM</b></a>]  Theorem
      
      ⊢ ∀f. (∀y. ∃x. f x = y) ⇔ ∀P. IMAGE f {x | P (f x)} = {x | P x}
   
   [<a name="SURJECTIVE_ON_IMAGE-val"><b>SURJECTIVE_ON_IMAGE</b></a>]  Theorem
      
      ⊢ ∀f u v.
          (∀t. t ⊆ v ⇒ ∃s. s ⊆ u ∧ IMAGE f s = t) ⇔
          ∀y. y ∈ v ⇒ ∃x. x ∈ u ∧ f x = y
   
   [<a name="SURJECTIVE_ON_RIGHT_INVERSE-val"><b>SURJECTIVE_ON_RIGHT_INVERSE</b></a>]  Theorem
      
      ⊢ ∀f t.
          (∀y. y ∈ t ⇒ ∃x. x ∈ s ∧ f x = y) ⇔
          ∃g. ∀y. y ∈ t ⇒ g y ∈ s ∧ f (g y) = y
   
   [<a name="SURJECTIVE_RIGHT_INVERSE-val"><b>SURJECTIVE_RIGHT_INVERSE</b></a>]  Theorem
      
      ⊢ (∀y. ∃x. f x = y) ⇔ ∃g. ∀y. f (g y) = y
   
   [<a name="UNION_ACI-val"><b>UNION_ACI</b></a>]  Theorem
      
      ⊢ ∀p q.
          p ∪ q = q ∪ p ∧ p ∪ q ∪ r = p ∪ q ∪ r ∧ p ∪ q ∪ r = q ∪ p ∪ r ∧
          p ∪ p = p ∧ p ∪ p ∪ q = p ∪ q
   
   [<a name="UNION_LE_ADD_C-val"><b>UNION_LE_ADD_C</b></a>]  Theorem
      
      ⊢ ∀s t. s ∪ t ≼ s ⊔ t
   
   [<a name="UNIV_fun_exp-val"><b>UNIV_fun_exp</b></a>]  Theorem
      
      ⊢ 𝕌(:α -&gt; β) = 𝕌(:β) ** 𝕌(:α)
   
   [<a name="UNIV_list-val"><b>UNIV_list</b></a>]  Theorem
      
      ⊢ 𝕌(:α list) = list 𝕌(:α)
   
   [<a name="bijections_cardeq-val"><b>bijections_cardeq</b></a>]  Theorem
      
      ⊢ INFINITE s ⇒ bijns s ≈ POW s
   
   [<a name="bijns_alt_permutes-val"><b>bijns_alt_permutes</b></a>]  Theorem
      
      ⊢ ∀f s. f ∈ bijns s ⇔ f permutes s
   
   [<a name="cardeq_INSERT-val"><b>cardeq_INSERT</b></a>]  Theorem
      
      ⊢ x INSERT s ≈ s ⇔ x ∈ s ∨ INFINITE s
   
   [<a name="cardeq_REFL-val"><b>cardeq_REFL</b></a>]  Theorem
      
      ⊢ ∀s. s ≈ s
   
   [<a name="cardeq_SYM-val"><b>cardeq_SYM</b></a>]  Theorem
      
      ⊢ ∀s t. s ≈ t ⇔ t ≈ s
   
   [<a name="cardeq_TRANS-val"><b>cardeq_TRANS</b></a>]  Theorem
      
      ⊢ ∀s t u. s ≈ t ∧ t ≈ u ⇒ s ≈ u
   
   [<a name="cardeq_addUnum-val"><b>cardeq_addUnum</b></a>]  Theorem
      
      ⊢ INFINITE 𝕌(:α) ⇒ 𝕌(:num + α) ≈ 𝕌(:α)
   
   [<a name="cardeq_bijns_cong-val"><b>cardeq_bijns_cong</b></a>]  Theorem
      
      ⊢ A ≈ B ⇒ bijns A ≈ bijns B
   
   [<a name="cardleq_ANTISYM-val"><b>cardleq_ANTISYM</b></a>]  Theorem
      
      ⊢ ∀s t. s ≼ t ∧ t ≼ s ⇒ s ≈ t
   
   [<a name="cardleq_REFL-val"><b>cardleq_REFL</b></a>]  Theorem
      
      ⊢ ∀s. s ≼ s
   
   [<a name="cardleq_SURJ-val"><b>cardleq_SURJ</b></a>]  Theorem
      
      ⊢ A ≼ B ⇔ (∃f. SURJ f B A) ∨ A = ∅
   
   [<a name="cardleq_TRANS-val"><b>cardleq_TRANS</b></a>]  Theorem
      
      ⊢ ∀s t u. s ≼ t ∧ t ≼ u ⇒ s ≼ u
   
   [<a name="cardleq_copy_wellorders-val"><b>cardleq_copy_wellorders</b></a>]  Theorem
      
      ⊢ 𝕌(:α) ≼ 𝕌(:β) ⇒ ∀w1. ∃w2. orderiso w1 w2
   
   [<a name="cardleq_dichotomy-val"><b>cardleq_dichotomy</b></a>]  Theorem
      
      ⊢ ∀s t. s ≼ t ∨ t ≼ s
   
   [<a name="cardleq_empty-val"><b>cardleq_empty</b></a>]  Theorem
      
      ⊢ ∀x. x ≼ ∅ ⇔ x = ∅
   
   [<a name="cardleq_lt_trans-val"><b>cardleq_lt_trans</b></a>]  Theorem
      
      ⊢ ∀r s t. r ≼ s ∧ s ≺ t ⇒ r ≺ t
   
   [<a name="cardleq_lteq-val"><b>cardleq_lteq</b></a>]  Theorem
      
      ⊢ ∀s1 s2. s1 ≼ s2 ⇔ s1 ≺ s2 ∨ s1 ≈ s2
   
   [<a name="cardleq_setexp-val"><b>cardleq_setexp</b></a>]  Theorem
      
      ⊢ x ≼ x ** e ⇔ x = ∅ ∨ x ≈ 𝟙 ∨ e ≠ ∅
   
   [<a name="cardlt_REFL-val"><b>cardlt_REFL</b></a>]  Theorem
      
      ⊢ ∀s. ¬(s ≺ s)
   
   [<a name="cardlt_TRANS-val"><b>cardlt_TRANS</b></a>]  Theorem
      
      ⊢ ∀s t u. s ≺ t ∧ t ≺ u ⇒ s ≺ u
   
   [<a name="cardlt_cardle-val"><b>cardlt_cardle</b></a>]  Theorem
      
      ⊢ A ≺ B ⇒ A ≼ B
   
   [<a name="cardlt_lenoteq-val"><b>cardlt_lenoteq</b></a>]  Theorem
      
      ⊢ ∀s t. s ≺ t ⇔ s ≼ t ∧ s ≉ t
   
   [<a name="cardlt_leq_trans-val"><b>cardlt_leq_trans</b></a>]  Theorem
      
      ⊢ ∀r s t. r ≺ s ∧ s ≼ t ⇒ r ≺ t
   
   [<a name="count_cardle-val"><b>count_cardle</b></a>]  Theorem
      
      ⊢ count n ≼ A ⇔ FINITE A ⇒ n ≤ CARD A
   
   [<a name="countable_cardeq-val"><b>countable_cardeq</b></a>]  Theorem
      
      ⊢ ∀s t. s ≈ t ⇒ (countable s ⇔ countable t)
   
   [<a name="countable_setexp-val"><b>countable_setexp</b></a>]  Theorem
      
      ⊢ countable (A ** B) ⇔ B = ∅ ∨ FINITE B ∧ countable A ∨ A ≈ 𝟙 ∨ A = ∅
   
   [<a name="countable_thm-val"><b>countable_thm</b></a>]  Theorem
      
      ⊢ ∀s. countable s ⇔ s ≼ 𝕌(:num)
   
   [<a name="disjoint_countable_decomposition-val"><b>disjoint_countable_decomposition</b></a>]  Theorem
      
      ⊢ ∀s. INFINITE s ⇒
            ∃A. BIGUNION A = s ∧ (∀a. a ∈ A ⇒ INFINITE a ∧ countable a) ∧
                ∀a1 a2. a1 ∈ A ∧ a2 ∈ A ∧ a1 ≠ a2 ⇒ DISJOINT a1 a2
   
   [<a name="disjoint_countable_decomposition2-val"><b>disjoint_countable_decomposition2</b></a>]  Theorem
      
      ⊢ ∀s. INFINITE s ⇒
            ∃A. BIGUNION A = s ∧ (∀a. a ∈ A ⇒ INFINITE a ∧ countable a) ∧
                pairwise (RC DISJOINT) A
   
   [<a name="eq_c-val"><b>eq_c</b></a>]  Theorem
      
      ⊢ ∀s t.
          s ≈ t ⇔
          ∃f. (∀x. x ∈ s ⇒ f x ∈ t) ∧ ∀y. y ∈ t ⇒ ∃!x. x ∈ s ∧ f x = y
   
   [<a name="exp_INSERT_cardeq-val"><b>exp_INSERT_cardeq</b></a>]  Theorem
      
      ⊢ e ∉ s ⇒ A ** (e INSERT s) ≈ A × A ** s
   
   [<a name="exp_c-val"><b>exp_c</b></a>]  Theorem
      
      ⊢ ∀s t. s ** t = {f | (∀x. x ∈ t ⇒ f x ∈ s) ∧ ∀x. x ∉ t ⇒ f x = ARB}
   
   [<a name="exp_count_cardeq-val"><b>exp_count_cardeq</b></a>]  Theorem
      
      ⊢ INFINITE A ∧ 0 &lt; n ⇒ A ** count n ≈ A
   
   [<a name="finite_subsets_bijection-val"><b>finite_subsets_bijection</b></a>]  Theorem
      
      ⊢ INFINITE A ⇒ A ≈ {s | FINITE s ∧ s ⊆ A}
   
   [<a name="fnOfSet_SING-val"><b>fnOfSet_SING</b></a>]  Theorem
      
      ⊢ fnOfSet {(k,v)} = (K NONE)⦇k ↦ SOME v⦈
   
   [<a name="ge_c-val"><b>ge_c</b></a>]  Theorem
      
      ⊢ ∀s t. s ≽ t ⇔ t ≼ s
   
   [<a name="gt_c-val"><b>gt_c</b></a>]  Theorem
      
      ⊢ ∀s t. s ≻ t ⇔ t ≺ s
   
   [<a name="le_c-val"><b>le_c</b></a>]  Theorem
      
      ⊢ ∀s t.
          s ≼ t ⇔
          ∃f. (∀x. x ∈ s ⇒ f x ∈ t) ∧
              ∀x y. x ∈ s ∧ y ∈ s ∧ f x = f y ⇒ x = y
   
   [<a name="list_BIGUNION_EXP-val"><b>list_BIGUNION_EXP</b></a>]  Theorem
      
      ⊢ list A ≈ BIGUNION (IMAGE (λn. {n} × A ** count n) 𝕌(:num))
   
   [<a name="list_EMPTY-val"><b>list_EMPTY</b></a>]  Theorem
      
      ⊢ list ∅ = {[]}
   
   [<a name="list_SING-val"><b>list_SING</b></a>]  Theorem
      
      ⊢ list {e} ≈ 𝕌(:num)
   
   [<a name="lt_c-val"><b>lt_c</b></a>]  Theorem
      
      ⊢ ∀s t. s ≺ t ⇔ s ≼ t ∧ s ≺ t
   
   [<a name="mul_c-val"><b>mul_c</b></a>]  Theorem
      
      ⊢ ∀s t. s × t = {(x,y) | x ∈ s ∧ y ∈ t}
   
   [<a name="set_binomial2-val"><b>set_binomial2</b></a>]  Theorem
      
      ⊢ (A ∪ B) × (A ∪ B) = A × A ∪ A × B ∪ B × A ∪ B × B
   
   [<a name="set_exp_card_cong-val"><b>set_exp_card_cong</b></a>]  Theorem
      
      ⊢ a1 ≈ a2 ⇒ b1 ≈ b2 ⇒ a1 ** b1 ≈ a2 ** b2
   
   [<a name="set_exp_cardle_cong-val"><b>set_exp_cardle_cong</b></a>]  Theorem
      
      ⊢ (b = ∅ ⇒ d = ∅) ⇒ a ≼ b ∧ c ≼ d ⇒ a ** c ≼ b ** d
   
   [<a name="set_exp_count-val"><b>set_exp_count</b></a>]  Theorem
      
      ⊢ A ** count n ≈ {l | LENGTH l = n ∧ ∀e. MEM e l ⇒ e ∈ A}
   
   [<a name="set_exp_product-val"><b>set_exp_product</b></a>]  Theorem
      
      ⊢ (A ** B1) ** B2 ≈ A ** (B1 × B2)
   
   [<a name="setexp_eq_EMPTY-val"><b>setexp_eq_EMPTY</b></a>]  Theorem
      
      ⊢ A ** B = ∅ ⇔ A = ∅ ∧ B ≠ ∅
   
   [<a name="tupNONE_IN_BIGPRODi-val"><b>tupNONE_IN_BIGPRODi</b></a>]  Theorem
      
      ⊢ tup ∈ BIGPRODi Af ⇒ (tup i = NONE ⇔ Af i = NONE)
   
   [<a name="wellorder_destWO-val"><b>wellorder_destWO</b></a>]  Theorem
      
      ⊢ wellorder (destWO r)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/pred_set/src/more_theories/.hol/objs/cardinalScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-2</a></em></p></body></html>
