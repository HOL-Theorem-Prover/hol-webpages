<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure itreeTauTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure itreeTauTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/coalgebras/.hol/objs/itreeTauScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature itreeTauTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#itree_TY_DEF-val">itree_TY_DEF</a> : thm
<a name="line7"></a>    val <a href="#itree_bind_def-val">itree_bind_def</a> : thm
<a name="line8"></a>    val <a href="#itree_el_case_def-val">itree_el_case_def</a> : thm
<a name="line9"></a>    val <a href="#itree_el_size_def-val">itree_el_size_def</a> : thm
<a name="line10"></a>    val <a href="#itree_iter_def-val">itree_iter_def</a> : thm
<a name="line11"></a>    val <a href="#itree_loop_def-val">itree_loop_def</a> : thm
<a name="line12"></a>    val <a href="#itree_next_case_def-val">itree_next_case_def</a> : thm
<a name="line13"></a>    val <a href="#itree_next_size_def-val">itree_next_size_def</a> : thm
<a name="line14"></a>    val <a href="#untau_def-val">untau_def</a> : thm
<a name="line15"></a>    val <a href="#upto_taus_func_def-val">upto_taus_func_def</a> : thm
<a name="line16"></a>    val <a href="#wbisim_functional_def-val">wbisim_functional_def</a> : thm
<a name="line17"></a>  
<a name="line18"></a>  (*  Theorems  *)
<a name="line19"></a>    val <a href="#FUNPOW_Tau_Ret_eq-val">FUNPOW_Tau_Ret_eq</a> : thm
<a name="line20"></a>    val <a href="#FUNPOW_Tau_Vis_eq-val">FUNPOW_Tau_Vis_eq</a> : thm
<a name="line21"></a>    val <a href="#FUNPOW_Tau_bind-val">FUNPOW_Tau_bind</a> : thm
<a name="line22"></a>    val <a href="#FUNPOW_Tau_imp_wbisim-val">FUNPOW_Tau_imp_wbisim</a> : thm
<a name="line23"></a>    val <a href="#FUNPOW_Tau_neq-val">FUNPOW_Tau_neq</a> : thm
<a name="line24"></a>    val <a href="#FUNPOW_Tau_neq2-val">FUNPOW_Tau_neq2</a> : thm
<a name="line25"></a>    val <a href="#FUNPOW_Tau_wbisim-val">FUNPOW_Tau_wbisim</a> : thm
<a name="line26"></a>    val <a href="#FUNPOW_Tau_wbisim_intro-val">FUNPOW_Tau_wbisim_intro</a> : thm
<a name="line27"></a>    val <a href="#Ret_11-val">Ret_11</a> : thm
<a name="line28"></a>    val <a href="#Tau_11-val">Tau_11</a> : thm
<a name="line29"></a>    val <a href="#Tau_INJ-val">Tau_INJ</a> : thm
<a name="line30"></a>    val <a href="#Vis_11-val">Vis_11</a> : thm
<a name="line31"></a>    val <a href="#after_taus_cases-val">after_taus_cases</a> : thm
<a name="line32"></a>    val <a href="#after_taus_ind-val">after_taus_ind</a> : thm
<a name="line33"></a>    val <a href="#after_taus_rel-val">after_taus_rel</a> : thm
<a name="line34"></a>    val <a href="#after_taus_rules-val">after_taus_rules</a> : thm
<a name="line35"></a>    val <a href="#after_taus_strongind-val">after_taus_strongind</a> : thm
<a name="line36"></a>    val <a href="#after_taus_tauL-val">after_taus_tauL</a> : thm
<a name="line37"></a>    val <a href="#after_taus_tauR-val">after_taus_tauR</a> : thm
<a name="line38"></a>    val <a href="#datatype_itree-val">datatype_itree</a> : thm
<a name="line39"></a>    val <a href="#datatype_itree_el-val">datatype_itree_el</a> : thm
<a name="line40"></a>    val <a href="#datatype_itree_next-val">datatype_itree_next</a> : thm
<a name="line41"></a>    val <a href="#itree_11-val">itree_11</a> : thm
<a name="line42"></a>    val <a href="#itree_CASE-val">itree_CASE</a> : thm
<a name="line43"></a>    val <a href="#itree_CASE_cong-val">itree_CASE_cong</a> : thm
<a name="line44"></a>    val <a href="#itree_CASE_elim-val">itree_CASE_elim</a> : thm
<a name="line45"></a>    val <a href="#itree_CASE_eq-val">itree_CASE_eq</a> : thm
<a name="line46"></a>    val <a href="#itree_bind_assoc-val">itree_bind_assoc</a> : thm
<a name="line47"></a>    val <a href="#itree_bind_resp_k_wbisim-val">itree_bind_resp_k_wbisim</a> : thm
<a name="line48"></a>    val <a href="#itree_bind_resp_t_wbisim-val">itree_bind_resp_t_wbisim</a> : thm
<a name="line49"></a>    val <a href="#itree_bind_resp_wbisim-val">itree_bind_resp_wbisim</a> : thm
<a name="line50"></a>    val <a href="#itree_bind_ret_inv-val">itree_bind_ret_inv</a> : thm
<a name="line51"></a>    val <a href="#itree_bind_right_identity-val">itree_bind_right_identity</a> : thm
<a name="line52"></a>    val <a href="#itree_bind_strip_tau_wbisim-val">itree_bind_strip_tau_wbisim</a> : thm
<a name="line53"></a>    val <a href="#itree_bind_thm-val">itree_bind_thm</a> : thm
<a name="line54"></a>    val <a href="#itree_bind_vis_strip_tau-val">itree_bind_vis_strip_tau</a> : thm
<a name="line55"></a>    val <a href="#itree_bisimulation-val">itree_bisimulation</a> : thm
<a name="line56"></a>    val <a href="#itree_cases-val">itree_cases</a> : thm
<a name="line57"></a>    val <a href="#itree_coind_upto_taus-val">itree_coind_upto_taus</a> : thm
<a name="line58"></a>    val <a href="#itree_distinct-val">itree_distinct</a> : thm
<a name="line59"></a>    val <a href="#itree_el_11-val">itree_el_11</a> : thm
<a name="line60"></a>    val <a href="#itree_el_Axiom-val">itree_el_Axiom</a> : thm
<a name="line61"></a>    val <a href="#itree_el_case_cong-val">itree_el_case_cong</a> : thm
<a name="line62"></a>    val <a href="#itree_el_case_eq-val">itree_el_case_eq</a> : thm
<a name="line63"></a>    val <a href="#itree_el_def-val">itree_el_def</a> : thm
<a name="line64"></a>    val <a href="#itree_el_distinct-val">itree_el_distinct</a> : thm
<a name="line65"></a>    val <a href="#itree_el_eqv-val">itree_el_eqv</a> : thm
<a name="line66"></a>    val <a href="#itree_el_ind-val">itree_el_ind</a> : thm
<a name="line67"></a>    val <a href="#itree_el_induction-val">itree_el_induction</a> : thm
<a name="line68"></a>    val <a href="#itree_el_nchotomy-val">itree_el_nchotomy</a> : thm
<a name="line69"></a>    val <a href="#itree_el_thm-val">itree_el_thm</a> : thm
<a name="line70"></a>    val <a href="#itree_iter_resp_wbisim-val">itree_iter_resp_wbisim</a> : thm
<a name="line71"></a>    val <a href="#itree_iter_thm-val">itree_iter_thm</a> : thm
<a name="line72"></a>    val <a href="#itree_next_11-val">itree_next_11</a> : thm
<a name="line73"></a>    val <a href="#itree_next_Axiom-val">itree_next_Axiom</a> : thm
<a name="line74"></a>    val <a href="#itree_next_case_cong-val">itree_next_case_cong</a> : thm
<a name="line75"></a>    val <a href="#itree_next_case_eq-val">itree_next_case_eq</a> : thm
<a name="line76"></a>    val <a href="#itree_next_distinct-val">itree_next_distinct</a> : thm
<a name="line77"></a>    val <a href="#itree_next_induction-val">itree_next_induction</a> : thm
<a name="line78"></a>    val <a href="#itree_next_nchotomy-val">itree_next_nchotomy</a> : thm
<a name="line79"></a>    val <a href="#itree_strong_bisimulation-val">itree_strong_bisimulation</a> : thm
<a name="line80"></a>    val <a href="#itree_unfold-val">itree_unfold</a> : thm
<a name="line81"></a>    val <a href="#itree_wbisim_Ret_FUNPOW-val">itree_wbisim_Ret_FUNPOW</a> : thm
<a name="line82"></a>    val <a href="#itree_wbisim_Vis_FUNPOW-val">itree_wbisim_Vis_FUNPOW</a> : thm
<a name="line83"></a>    val <a href="#itree_wbisim_cases-val">itree_wbisim_cases</a> : thm
<a name="line84"></a>    val <a href="#itree_wbisim_coind-val">itree_wbisim_coind</a> : thm
<a name="line85"></a>    val <a href="#itree_wbisim_coind_upto-val">itree_wbisim_coind_upto</a> : thm
<a name="line86"></a>    val <a href="#itree_wbisim_coind_upto'-val">itree_wbisim_coind_upto'</a> : thm
<a name="line87"></a>    val <a href="#itree_wbisim_refl-val">itree_wbisim_refl</a> : thm
<a name="line88"></a>    val <a href="#itree_wbisim_rules-val">itree_wbisim_rules</a> : thm
<a name="line89"></a>    val <a href="#itree_wbisim_strip_tau-val">itree_wbisim_strip_tau</a> : thm
<a name="line90"></a>    val <a href="#itree_wbisim_strip_tau_Ret-val">itree_wbisim_strip_tau_Ret</a> : thm
<a name="line91"></a>    val <a href="#itree_wbisim_strip_tau_Vis-val">itree_wbisim_strip_tau_Vis</a> : thm
<a name="line92"></a>    val <a href="#itree_wbisim_strip_tau_sym-val">itree_wbisim_strip_tau_sym</a> : thm
<a name="line93"></a>    val <a href="#itree_wbisim_strong_coind-val">itree_wbisim_strong_coind</a> : thm
<a name="line94"></a>    val <a href="#itree_wbisim_sym-val">itree_wbisim_sym</a> : thm
<a name="line95"></a>    val <a href="#itree_wbisim_tau-val">itree_wbisim_tau</a> : thm
<a name="line96"></a>    val <a href="#itree_wbisim_tau_eq-val">itree_wbisim_tau_eq</a> : thm
<a name="line97"></a>    val <a href="#itree_wbisim_tau_eqn-val">itree_wbisim_tau_eqn</a> : thm
<a name="line98"></a>    val <a href="#itree_wbisim_trans-val">itree_wbisim_trans</a> : thm
<a name="line99"></a>    val <a href="#itree_wbisim_vis-val">itree_wbisim_vis</a> : thm
<a name="line100"></a>    val <a href="#spin-val">spin</a> : thm
<a name="line101"></a>    val <a href="#spin_FUNPOW_Tau-val">spin_FUNPOW_Tau</a> : thm
<a name="line102"></a>    val <a href="#spin_bind-val">spin_bind</a> : thm
<a name="line103"></a>    val <a href="#spin_strip_tau-val">spin_strip_tau</a> : thm
<a name="line104"></a>    val <a href="#strip_tau_FUNPOW-val">strip_tau_FUNPOW</a> : thm
<a name="line105"></a>    val <a href="#strip_tau_FUNPOW_cancel-val">strip_tau_FUNPOW_cancel</a> : thm
<a name="line106"></a>    val <a href="#strip_tau_cases-val">strip_tau_cases</a> : thm
<a name="line107"></a>    val <a href="#strip_tau_ind-val">strip_tau_ind</a> : thm
<a name="line108"></a>    val <a href="#strip_tau_inj-val">strip_tau_inj</a> : thm
<a name="line109"></a>    val <a href="#strip_tau_rules-val">strip_tau_rules</a> : thm
<a name="line110"></a>    val <a href="#strip_tau_simps-val">strip_tau_simps</a> : thm
<a name="line111"></a>    val <a href="#strip_tau_simps2-val">strip_tau_simps2</a> : thm
<a name="line112"></a>    val <a href="#strip_tau_simps3-val">strip_tau_simps3</a> : thm
<a name="line113"></a>    val <a href="#strip_tau_spin-val">strip_tau_spin</a> : thm
<a name="line114"></a>    val <a href="#strip_tau_strongind-val">strip_tau_strongind</a> : thm
<a name="line115"></a>    val <a href="#strip_tau_vis_wbisim-val">strip_tau_vis_wbisim</a> : thm
<a name="line116"></a>    val <a href="#untau_IMP_wbisim-val">untau_IMP_wbisim</a> : thm
<a name="line117"></a>    val <a href="#untau_spin-val">untau_spin</a> : thm
<a name="line118"></a>    val <a href="#upto_taus_compatible-val">upto_taus_compatible</a> : thm
<a name="line119"></a>    val <a href="#wbisim_FUNPOW_Tau-val">wbisim_FUNPOW_Tau</a> : thm
<a name="line120"></a>    val <a href="#wbisim_IMP_untau-val">wbisim_IMP_untau</a> : thm
<a name="line121"></a>    val <a href="#wbisim_functional_cancel-val">wbisim_functional_cancel</a> : thm
<a name="line122"></a>    val <a href="#wbisim_functional_gfp-val">wbisim_functional_gfp</a> : thm
<a name="line123"></a>    val <a href="#wbisim_functional_mono-val">wbisim_functional_mono</a> : thm
<a name="line124"></a>    val <a href="#wbisim_spin_eq-val">wbisim_spin_eq</a> : thm
<a name="line125"></a>(*
   [alist] Parent theory of "itreeTau"
   
   [companion] Parent theory of "itreeTau"
   
   [itree] Parent theory of "itreeTau"
   
   [llist] Parent theory of "itreeTau"
   
   [<a name="itree_TY_DEF-val"><b>itree_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep. TYPE_DEFINITION itree_rep_ok rep
   
   [<a name="itree_bind_def-val"><b>itree_bind_def</b></a>]  Definition
      
      ⊢ ∀t k.
          itree_bind t k =
          itree_unfold
            (λx.
                 case x of
                   INL (Ret r) =&gt;
                     (case k r of
                        Ret s =&gt; Ret' s
                      | Tau t =&gt; Tau' (INR t)
                      | Vis e g =&gt; Vis' e (INR ∘ g))
                 | INL (Tau t) =&gt; Tau' (INL t)
                 | INL (Vis e g) =&gt; Vis' e (INL ∘ g)
                 | INR (Ret r') =&gt; Ret' r'
                 | INR (Tau t') =&gt; Tau' (INR t')
                 | INR (Vis e' g') =&gt; Vis' e' (INR ∘ g')) (INL t)
   
   [<a name="itree_el_case_def-val"><b>itree_el_case_def</b></a>]  Definition
      
      ⊢ (∀a f f1 v. itree_el_CASE (Event a) f f1 v = f a) ∧
        (∀a f f1 v. itree_el_CASE (Return a) f f1 v = f1 a) ∧
        ∀f f1 v. itree_el_CASE Silence f f1 v = v
   
   [<a name="itree_el_size_def-val"><b>itree_el_size_def</b></a>]  Definition
      
      ⊢ (∀f f1 a. itree_el_size f f1 (Event a) = 1 + f a) ∧
        (∀f f1 a. itree_el_size f f1 (Return a) = 1 + f1 a) ∧
        ∀f f1. itree_el_size f f1 Silence = 0
   
   [<a name="itree_iter_def-val"><b>itree_iter_def</b></a>]  Definition
      
      ⊢ ∀body seed.
          itree_iter body seed =
          itree_unfold
            (λx.
                 case x of
                   Ret (INL seed') =&gt; Tau' (body seed')
                 | Ret (INR v) =&gt; Ret' v
                 | Tau u =&gt; Tau' u
                 | Vis e g =&gt; Vis' e g) (body seed)
   
   [<a name="itree_loop_def-val"><b>itree_loop_def</b></a>]  Definition
      
      ⊢ ∀body seed.
          itree_loop body seed =
          itree_iter
            (λx.
                 itree_bind (body x)
                   (λcb.
                        case cb of
                          INL c =&gt; Ret (INL (INL c))
                        | INR b =&gt; Ret (INR b))) (INR seed)
   
   [<a name="itree_next_case_def-val"><b>itree_next_case_def</b></a>]  Definition
      
      ⊢ (∀a f f1 f2. itree_next_CASE (Ret' a) f f1 f2 = f a) ∧
        (∀a f f1 f2. itree_next_CASE (Tau' a) f f1 f2 = f1 a) ∧
        ∀a0 a1 f f1 f2. itree_next_CASE (Vis' a0 a1) f f1 f2 = f2 a0 a1
   
   [<a name="itree_next_size_def-val"><b>itree_next_size_def</b></a>]  Definition
      
      ⊢ (∀f f1 f2 f3 a. itree_next_size f f1 f2 f3 (Ret' a) = 1 + f2 a) ∧
        (∀f f1 f2 f3 a. itree_next_size f f1 f2 f3 (Tau' a) = 1 + f3 a) ∧
        ∀f f1 f2 f3 a0 a1.
          itree_next_size f f1 f2 f3 (Vis' a0 a1) = 1 + f1 a0
   
   [<a name="untau_def-val"><b>untau_def</b></a>]  Definition
      
      ⊢ untau =
        itree_unfold
          (λt.
               case some t'. strip_tau t t' of
                 NONE =&gt; Div'
               | SOME (Ret v) =&gt; Ret' v
               | SOME (Tau t') =&gt; Div'
               | SOME (Vis e k) =&gt; Vis' e k)
   
   [<a name="upto_taus_func_def-val"><b>upto_taus_func_def</b></a>]  Definition
      
      ⊢ ∀R. upto_taus_func R = R ∪ rel_to_reln (after_taus (reln_to_rel R))
   
   [<a name="wbisim_functional_def-val"><b>wbisim_functional_def</b></a>]  Definition
      
      ⊢ ∀R. wbisim_functional R =
            {(t,t') | ∃r. strip_tau t (Ret r) ∧ strip_tau t' (Ret r)} ∪
            {(t,t') |
             ∃e k k'.
               strip_tau t (Vis e k) ∧ strip_tau t' (Vis e k') ∧
               ∀r. (k r,k' r) ∈ R} ∪ {(Tau t,Tau t') | (t,t') ∈ R}
   
   [<a name="FUNPOW_Tau_Ret_eq-val"><b>FUNPOW_Tau_Ret_eq</b></a>]  Theorem
      
      ⊢ FUNPOW Tau n (Ret x) = FUNPOW Tau m (Ret y) ⇒ n = m ∧ x = y
   
   [<a name="FUNPOW_Tau_Vis_eq-val"><b>FUNPOW_Tau_Vis_eq</b></a>]  Theorem
      
      ⊢ FUNPOW Tau n (Vis a g) = FUNPOW Tau m (Vis e k) ⇒
        n = m ∧ a = e ∧ g = k
   
   [<a name="FUNPOW_Tau_bind-val"><b>FUNPOW_Tau_bind</b></a>]  Theorem
      
      ⊢ itree_bind (FUNPOW Tau n t) g = FUNPOW Tau n (itree_bind t g)
   
   [<a name="FUNPOW_Tau_imp_wbisim-val"><b>FUNPOW_Tau_imp_wbisim</b></a>]  Theorem
      
      ⊢ t = FUNPOW Tau n t' ⇒ itree_wbisim t t'
   
   [<a name="FUNPOW_Tau_neq-val"><b>FUNPOW_Tau_neq</b></a>]  Theorem
      
      ⊢ Ret x ≠ FUNPOW Tau n (Vis a g) ∧ Vis a g ≠ FUNPOW Tau n (Ret x)
   
   [<a name="FUNPOW_Tau_neq2-val"><b>FUNPOW_Tau_neq2</b></a>]  Theorem
      
      ⊢ FUNPOW Tau n' (Ret x) ≠ FUNPOW Tau n (Vis a g)
   
   [<a name="FUNPOW_Tau_wbisim-val"><b>FUNPOW_Tau_wbisim</b></a>]  Theorem
      
      ⊢ itree_wbisim (FUNPOW Tau n x) x
   
   [<a name="FUNPOW_Tau_wbisim_intro-val"><b>FUNPOW_Tau_wbisim_intro</b></a>]  Theorem
      
      ⊢ itree_wbisim x y ⇒ itree_wbisim (FUNPOW Tau n x) (FUNPOW Tau n' y)
   
   [<a name="Ret_11-val"><b>Ret_11</b></a>]  Theorem
      
      ⊢ ∀x y. Ret x = Ret y ⇔ x = y
   
   [<a name="Tau_11-val"><b>Tau_11</b></a>]  Theorem
      
      ⊢ ∀x y. Tau x = Tau y ⇔ x = y
   
   [<a name="Tau_INJ-val"><b>Tau_INJ</b></a>]  Theorem
      
      ⊢ INJ Tau 𝕌(:(α, β, γ) itree) 𝕌(:(α, β, γ) itree)
   
   [<a name="Vis_11-val"><b>Vis_11</b></a>]  Theorem
      
      ⊢ ∀x f y g. Vis x f = Vis y g ⇔ x = y ∧ f = g
   
   [<a name="after_taus_cases-val"><b>after_taus_cases</b></a>]  Theorem
      
      ⊢ ∀R a0 a1.
          after_taus R a0 a1 ⇔
          R a0 a1 ∨ (∃x. a0 = Tau x ∧ after_taus R x a1) ∨
          ∃y. a1 = Tau y ∧ after_taus R a0 y
   
   [<a name="after_taus_ind-val"><b>after_taus_ind</b></a>]  Theorem
      
      ⊢ ∀R after_taus'.
          (∀x y. R x y ⇒ after_taus' x y) ∧
          (∀x y. after_taus' x y ⇒ after_taus' (Tau x) y) ∧
          (∀x y. after_taus' x y ⇒ after_taus' x (Tau y)) ⇒
          ∀a0 a1. after_taus R a0 a1 ⇒ after_taus' a0 a1
   
   [<a name="after_taus_rel-val"><b>after_taus_rel</b></a>]  Theorem
      
      ⊢ ∀R x y. R x y ⇒ after_taus R x y
   
   [<a name="after_taus_rules-val"><b>after_taus_rules</b></a>]  Theorem
      
      ⊢ ∀R. (∀x y. R x y ⇒ after_taus R x y) ∧
            (∀x y. after_taus R x y ⇒ after_taus R (Tau x) y) ∧
            ∀x y. after_taus R x y ⇒ after_taus R x (Tau y)
   
   [<a name="after_taus_strongind-val"><b>after_taus_strongind</b></a>]  Theorem
      
      ⊢ ∀R after_taus'.
          (∀x y. R x y ⇒ after_taus' x y) ∧
          (∀x y. after_taus R x y ∧ after_taus' x y ⇒ after_taus' (Tau x) y) ∧
          (∀x y. after_taus R x y ∧ after_taus' x y ⇒ after_taus' x (Tau y)) ⇒
          ∀a0 a1. after_taus R a0 a1 ⇒ after_taus' a0 a1
   
   [<a name="after_taus_tauL-val"><b>after_taus_tauL</b></a>]  Theorem
      
      ⊢ ∀R x y. after_taus R x y ⇒ after_taus R (Tau x) y
   
   [<a name="after_taus_tauR-val"><b>after_taus_tauR</b></a>]  Theorem
      
      ⊢ ∀R x y. after_taus R x y ⇒ after_taus R x (Tau y)
   
   [<a name="datatype_itree-val"><b>datatype_itree</b></a>]  Theorem
      
      ⊢ DATATYPE (itree Ret Tau Vis)
   
   [<a name="datatype_itree_el-val"><b>datatype_itree_el</b></a>]  Theorem
      
      ⊢ DATATYPE (itree_el Event Return Silence)
   
   [<a name="datatype_itree_next-val"><b>datatype_itree_next</b></a>]  Theorem
      
      ⊢ DATATYPE (itree_next Ret' Tau' Vis')
   
   [<a name="itree_11-val"><b>itree_11</b></a>]  Theorem
      
      ⊢ (∀x y. Ret x = Ret y ⇔ x = y) ∧ (∀x y. Tau x = Tau y ⇔ x = y) ∧
        ∀x f y g. Vis x f = Vis y g ⇔ x = y ∧ f = g
   
   [<a name="itree_CASE-val"><b>itree_CASE</b></a>]  Theorem
      
      ⊢ itree_CASE (Ret r) ret tau vis = ret r ∧
        itree_CASE (Tau t) ret tau vis = tau t ∧
        itree_CASE (Vis a g) ret tau vis = vis a g
   
   [<a name="itree_CASE_cong-val"><b>itree_CASE_cong</b></a>]  Theorem
      
      ⊢ ∀M M' ret tau vis ret' tau' vis'.
          M = M' ∧ (∀x. M' = Ret x ⇒ ret x = ret' x) ∧
          (∀t. M' = Tau t ⇒ tau t = tau' t) ∧
          (∀a g. M' = Vis a g ⇒ vis a g = vis' a g) ⇒
          itree_CASE M ret tau vis = itree_CASE M' ret' tau' vis'
   
   [<a name="itree_CASE_elim-val"><b>itree_CASE_elim</b></a>]  Theorem
      
      ⊢ ∀f. f (itree_CASE t ret tau vis) ⇔
            (∃r. t = Ret r ∧ f (ret r)) ∨ (∃u. t = Tau u ∧ f (tau u)) ∨
            ∃a g. t = Vis a g ∧ f (vis a g)
   
   [<a name="itree_CASE_eq-val"><b>itree_CASE_eq</b></a>]  Theorem
      
      ⊢ itree_CASE t ret tau vis = v ⇔
        (∃r. t = Ret r ∧ ret r = v) ∨ (∃u. t = Tau u ∧ tau u = v) ∨
        ∃a g. t = Vis a g ∧ vis a g = v
   
   [<a name="itree_bind_assoc-val"><b>itree_bind_assoc</b></a>]  Theorem
      
      ⊢ itree_bind (itree_bind t k) k' =
        itree_bind t (λx. itree_bind (k x) k')
   
   [<a name="itree_bind_resp_k_wbisim-val"><b>itree_bind_resp_k_wbisim</b></a>]  Theorem
      
      ⊢ ∀t k1 k2.
          (∀r. itree_wbisim (k1 r) (k2 r)) ⇒
          itree_wbisim (itree_bind t k1) (itree_bind t k2)
   
   [<a name="itree_bind_resp_t_wbisim-val"><b>itree_bind_resp_t_wbisim</b></a>]  Theorem
      
      ⊢ ∀a b k.
          itree_wbisim a b ⇒ itree_wbisim (itree_bind a k) (itree_bind b k)
   
   [<a name="itree_bind_resp_wbisim-val"><b>itree_bind_resp_wbisim</b></a>]  Theorem
      
      ⊢ ∀a b k1 k2.
          itree_wbisim a b ∧ (∀r. itree_wbisim (k1 r) (k2 r)) ⇒
          itree_wbisim (itree_bind a k1) (itree_bind b k2)
   
   [<a name="itree_bind_ret_inv-val"><b>itree_bind_ret_inv</b></a>]  Theorem
      
      ⊢ itree_bind t k = Ret r ⇒ ∃r'. t = Ret r' ∧ k r' = Ret r
   
   [<a name="itree_bind_right_identity-val"><b>itree_bind_right_identity</b></a>]  Theorem
      
      ⊢ itree_bind t Ret = t
   
   [<a name="itree_bind_strip_tau_wbisim-val"><b>itree_bind_strip_tau_wbisim</b></a>]  Theorem
      
      ⊢ ∀u u' k.
          strip_tau u u' ⇒ itree_wbisim (itree_bind u k) (itree_bind u' k)
   
   [<a name="itree_bind_thm-val"><b>itree_bind_thm</b></a>]  Theorem
      
      ⊢ itree_bind (Ret r) k = k r ∧
        itree_bind (Tau t) k = Tau (itree_bind t k) ∧
        itree_bind (Vis e k') k = Vis e (λx. itree_bind (k' x) k)
   
   [<a name="itree_bind_vis_strip_tau-val"><b>itree_bind_vis_strip_tau</b></a>]  Theorem
      
      ⊢ ∀u k k' e.
          strip_tau u (Vis e k') ⇒
          strip_tau (itree_bind u k) (Vis e (λx. itree_bind (k' x) k))
   
   [<a name="itree_bisimulation-val"><b>itree_bisimulation</b></a>]  Theorem
      
      ⊢ ∀t1 t2.
          t1 = t2 ⇔
          ∃R. R t1 t2 ∧ (∀x t. R (Ret x) t ⇒ t = Ret x) ∧
              (∀u t. R (Tau u) t ⇒ ∃v. t = Tau v ∧ R u v) ∧
              ∀a f t. R (Vis a f) t ⇒ ∃g. t = Vis a g ∧ ∀s. R (f s) (g s)
   
   [<a name="itree_cases-val"><b>itree_cases</b></a>]  Theorem
      
      ⊢ ∀t. (∃x. t = Ret x) ∨ (∃u. t = Tau u) ∨ ∃a g. t = Vis a g
   
   [<a name="itree_coind_upto_taus-val"><b>itree_coind_upto_taus</b></a>]  Theorem
      
      ⊢ ∀R. rel_to_reln R ⊆
            rel_to_reln itree_wbisim ∪
            wbisim_functional
              (upto_taus_func (rel_to_reln R) ∪ rel_to_reln itree_wbisim) ⇒
            rel_to_reln R ⊆ rel_to_reln itree_wbisim
   
   [<a name="itree_distinct-val"><b>itree_distinct</b></a>]  Theorem
      
      ⊢ Ret x ≠ Tau t ∧ Ret x ≠ Vis e g ∧ Tau t ≠ Vis e g
   
   [<a name="itree_el_11-val"><b>itree_el_11</b></a>]  Theorem
      
      ⊢ (∀a a'. Event a = Event a' ⇔ a = a') ∧
        ∀a a'. Return a = Return a' ⇔ a = a'
   
   [<a name="itree_el_Axiom-val"><b>itree_el_Axiom</b></a>]  Theorem
      
      ⊢ ∀f0 f1 f2. ∃fn.
          (∀a. fn (Event a) = f0 a) ∧ (∀a. fn (Return a) = f1 a) ∧
          fn Silence = f2
   
   [<a name="itree_el_case_cong-val"><b>itree_el_case_cong</b></a>]  Theorem
      
      ⊢ ∀M M' f f1 v.
          M = M' ∧ (∀a. M' = Event a ⇒ f a = f' a) ∧
          (∀a. M' = Return a ⇒ f1 a = f1' a) ∧ (M' = Silence ⇒ v = v') ⇒
          itree_el_CASE M f f1 v = itree_el_CASE M' f' f1' v'
   
   [<a name="itree_el_case_eq-val"><b>itree_el_case_eq</b></a>]  Theorem
      
      ⊢ itree_el_CASE x f f1 v = v' ⇔
        (∃e. x = Event e ∧ f e = v') ∨ (∃r. x = Return r ∧ f1 r = v') ∨
        x = Silence ∧ v = v'
   
   [<a name="itree_el_def-val"><b>itree_el_def</b></a>]  Theorem
      
      ⊢ (∀t. itree_el t [] =
             case t of
               Ret r =&gt; Return r
             | Tau t =&gt; Silence
             | Vis e g =&gt; Event e) ∧
        (∀t ns.
           itree_el t (NONE::ns) =
           case t of
             Ret r =&gt; Silence
           | Tau t' =&gt; itree_el t' ns
           | Vis e g =&gt; Silence) ∧
        ∀t ns a.
          itree_el t (SOME a::ns) =
          case t of
            Ret r =&gt; Silence
          | Tau t =&gt; Silence
          | Vis e g =&gt; itree_el (g a) ns
   
   [<a name="itree_el_distinct-val"><b>itree_el_distinct</b></a>]  Theorem
      
      ⊢ (∀a' a. Event a ≠ Return a') ∧ (∀a. Event a ≠ Silence) ∧
        ∀a. Return a ≠ Silence
   
   [<a name="itree_el_eqv-val"><b>itree_el_eqv</b></a>]  Theorem
      
      ⊢ ∀t1 t2. t1 = t2 ⇔ ∀path. itree_el t1 path = itree_el t2 path
   
   [<a name="itree_el_ind-val"><b>itree_el_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀t. P t []) ∧ (∀t ns. (∀t'. P t' ns) ⇒ P t (NONE::ns)) ∧
            (∀t a ns. (∀g. P (g a) ns) ⇒ P t (SOME a::ns)) ⇒
            ∀v v1. P v v1
   
   [<a name="itree_el_induction-val"><b>itree_el_induction</b></a>]  Theorem
      
      ⊢ ∀P. (∀e. P (Event e)) ∧ (∀r. P (Return r)) ∧ P Silence ⇒ ∀i. P i
   
   [<a name="itree_el_nchotomy-val"><b>itree_el_nchotomy</b></a>]  Theorem
      
      ⊢ ∀ii. (∃e. ii = Event e) ∨ (∃r. ii = Return r) ∨ ii = Silence
   
   [<a name="itree_el_thm-val"><b>itree_el_thm</b></a>]  Theorem
      
      ⊢ itree_el (Ret r) [] = Return r ∧ itree_el (Tau t) [] = Silence ∧
        itree_el (Vis e g) [] = Event e ∧
        itree_el (Ret r) (NONE::ns) = Silence ∧
        itree_el (Tau t) (NONE::ns) = itree_el t ns ∧
        itree_el (Vis e g) (NONE::ns) = Silence ∧
        itree_el (Ret r) (SOME a::ns) = Silence ∧
        itree_el (Tau t) (SOME a::ns) = Silence ∧
        itree_el (Vis e g) (SOME a::ns) = itree_el (g a) ns
   
   [<a name="itree_iter_resp_wbisim-val"><b>itree_iter_resp_wbisim</b></a>]  Theorem
      
      ⊢ ∀t k1 k2.
          (∀r. itree_wbisim (k1 r) (k2 r)) ⇒
          itree_wbisim (itree_iter k1 t) (itree_iter k2 t)
   
   [<a name="itree_iter_thm-val"><b>itree_iter_thm</b></a>]  Theorem
      
      ⊢ itree_iter body seed =
        itree_bind (body seed)
          (λx. case x of INL a =&gt; Tau (itree_iter body a) | INR b =&gt; Ret b)
   
   [<a name="itree_next_11-val"><b>itree_next_11</b></a>]  Theorem
      
      ⊢ (∀a a'. Ret' a = Ret' a' ⇔ a = a') ∧
        (∀a a'. Tau' a = Tau' a' ⇔ a = a') ∧
        ∀a0 a1 a0' a1'. Vis' a0 a1 = Vis' a0' a1' ⇔ a0 = a0' ∧ a1 = a1'
   
   [<a name="itree_next_Axiom-val"><b>itree_next_Axiom</b></a>]  Theorem
      
      ⊢ ∀f0 f1 f2. ∃fn.
          (∀a. fn (Ret' a) = f0 a) ∧ (∀a. fn (Tau' a) = f1 a) ∧
          ∀a0 a1. fn (Vis' a0 a1) = f2 a0 a1
   
   [<a name="itree_next_case_cong-val"><b>itree_next_case_cong</b></a>]  Theorem
      
      ⊢ ∀M M' f f1 f2.
          M = M' ∧ (∀a. M' = Ret' a ⇒ f a = f' a) ∧
          (∀a. M' = Tau' a ⇒ f1 a = f1' a) ∧
          (∀a0 a1. M' = Vis' a0 a1 ⇒ f2 a0 a1 = f2' a0 a1) ⇒
          itree_next_CASE M f f1 f2 = itree_next_CASE M' f' f1' f2'
   
   [<a name="itree_next_case_eq-val"><b>itree_next_case_eq</b></a>]  Theorem
      
      ⊢ itree_next_CASE x f f1 f2 = v ⇔
        (∃r. x = Ret' r ∧ f r = v) ∨ (∃s. x = Tau' s ∧ f1 s = v) ∨
        ∃e f'. x = Vis' e f' ∧ f2 e f' = v
   
   [<a name="itree_next_distinct-val"><b>itree_next_distinct</b></a>]  Theorem
      
      ⊢ (∀a' a. Ret' a ≠ Tau' a') ∧ (∀a1 a0 a. Ret' a ≠ Vis' a0 a1) ∧
        ∀a1 a0 a. Tau' a ≠ Vis' a0 a1
   
   [<a name="itree_next_induction-val"><b>itree_next_induction</b></a>]  Theorem
      
      ⊢ ∀P. (∀r. P (Ret' r)) ∧ (∀s. P (Tau' s)) ∧ (∀e f. P (Vis' e f)) ⇒
            ∀i. P i
   
   [<a name="itree_next_nchotomy-val"><b>itree_next_nchotomy</b></a>]  Theorem
      
      ⊢ ∀ii. (∃r. ii = Ret' r) ∨ (∃s. ii = Tau' s) ∨ ∃e f. ii = Vis' e f
   
   [<a name="itree_strong_bisimulation-val"><b>itree_strong_bisimulation</b></a>]  Theorem
      
      ⊢ ∀t1 t2.
          t1 = t2 ⇔
          ∃R. R t1 t2 ∧ (∀x t. R (Ret x) t ⇒ t = Ret x) ∧
              (∀u t. R (Tau u) t ⇒ ∃v. t = Tau v ∧ (R u v ∨ u = v)) ∧
              ∀a f t.
                R (Vis a f) t ⇒
                ∃g. t = Vis a g ∧ ∀s. R (f s) (g s) ∨ f s = g s
   
   [<a name="itree_unfold-val"><b>itree_unfold</b></a>]  Theorem
      
      ⊢ itree_unfold f seed =
        case f seed of
          Ret' r =&gt; Ret r
        | Tau' s =&gt; Tau (itree_unfold f s)
        | Vis' e g =&gt; Vis e (itree_unfold f ∘ g)
   
   [<a name="itree_wbisim_Ret_FUNPOW-val"><b>itree_wbisim_Ret_FUNPOW</b></a>]  Theorem
      
      ⊢ itree_wbisim t (Ret x) ⇒ ∃n. t = FUNPOW Tau n (Ret x)
   
   [<a name="itree_wbisim_Vis_FUNPOW-val"><b>itree_wbisim_Vis_FUNPOW</b></a>]  Theorem
      
      ⊢ itree_wbisim t (Vis a g) ⇒
        ∃n k. t = FUNPOW Tau n (Vis a k) ∧ ∀r. itree_wbisim (k r) (g r)
   
   [<a name="itree_wbisim_cases-val"><b>itree_wbisim_cases</b></a>]  Theorem
      
      ⊢ ∀a0 a1.
          itree_wbisim a0 a1 ⇔
          (∃t t'. a0 = Tau t ∧ a1 = Tau t' ∧ itree_wbisim t t') ∨
          (∃e k k'.
             strip_tau a0 (Vis e k) ∧ strip_tau a1 (Vis e k') ∧
             ∀r. itree_wbisim (k r) (k' r)) ∨
          ∃r. strip_tau a0 (Ret r) ∧ strip_tau a1 (Ret r)
   
   [<a name="itree_wbisim_coind-val"><b>itree_wbisim_coind</b></a>]  Theorem
      
      ⊢ ∀itree_wbisim'.
          (∀a0 a1.
             itree_wbisim' a0 a1 ⇒
             (∃t t'. a0 = Tau t ∧ a1 = Tau t' ∧ itree_wbisim' t t') ∨
             (∃e k k'.
                strip_tau a0 (Vis e k) ∧ strip_tau a1 (Vis e k') ∧
                ∀r. itree_wbisim' (k r) (k' r)) ∨
             ∃r. strip_tau a0 (Ret r) ∧ strip_tau a1 (Ret r)) ⇒
          ∀a0 a1. itree_wbisim' a0 a1 ⇒ itree_wbisim a0 a1
   
   [<a name="itree_wbisim_coind_upto-val"><b>itree_wbisim_coind_upto</b></a>]  Theorem
      
      ⊢ ∀R. (∀t t'.
               R t t' ⇒
               (∃t2 t3.
                  t = Tau t2 ∧ t' = Tau t3 ∧ (R t2 t3 ∨ itree_wbisim t2 t3)) ∨
               (∃e k k'.
                  strip_tau t (Vis e k) ∧ strip_tau t' (Vis e k') ∧
                  ∀r. R (k r) (k' r) ∨ itree_wbisim (k r) (k' r)) ∨
               (∃r. strip_tau t (Ret r) ∧ strip_tau t' (Ret r)) ∨
               itree_wbisim t t') ⇒
            ∀t t'. R t t' ⇒ itree_wbisim t t'
   
   [<a name="itree_wbisim_coind_upto'-val"><b>itree_wbisim_coind_upto'</b></a>]  Theorem
      
      ⊢ ∀R. rel_to_reln R ⊆
            rel_to_reln itree_wbisim ∪
            wbisim_functional
              (set_companion wbisim_functional (rel_to_reln R)) ⇒
            rel_to_reln R ⊆ rel_to_reln itree_wbisim
   
   [<a name="itree_wbisim_refl-val"><b>itree_wbisim_refl</b></a>]  Theorem
      
      ⊢ itree_wbisim t t
   
   [<a name="itree_wbisim_rules-val"><b>itree_wbisim_rules</b></a>]  Theorem
      
      ⊢ (∀t t'. itree_wbisim t t' ⇒ itree_wbisim (Tau t) (Tau t')) ∧
        (∀e k k' t t'.
           strip_tau t (Vis e k) ∧ strip_tau t' (Vis e k') ∧
           (∀r. itree_wbisim (k r) (k' r)) ⇒
           itree_wbisim t t') ∧
        ∀r t t'.
          strip_tau t (Ret r) ∧ strip_tau t' (Ret r) ⇒ itree_wbisim t t'
   
   [<a name="itree_wbisim_strip_tau-val"><b>itree_wbisim_strip_tau</b></a>]  Theorem
      
      ⊢ ∀t t' t''.
          itree_wbisim t t' ∧ strip_tau t t'' ⇒ itree_wbisim t'' t'
   
   [<a name="itree_wbisim_strip_tau_Ret-val"><b>itree_wbisim_strip_tau_Ret</b></a>]  Theorem
      
      ⊢ ∀t t' v.
          itree_wbisim t t' ∧ strip_tau t (Ret v) ⇒ strip_tau t' (Ret v)
   
   [<a name="itree_wbisim_strip_tau_Vis-val"><b>itree_wbisim_strip_tau_Vis</b></a>]  Theorem
      
      ⊢ ∀t t' e k.
          itree_wbisim t t' ∧ strip_tau t (Vis e k) ⇒
          ∃k'. strip_tau t' (Vis e k') ∧ ∀r. itree_wbisim (k r) (k' r)
   
   [<a name="itree_wbisim_strip_tau_sym-val"><b>itree_wbisim_strip_tau_sym</b></a>]  Theorem
      
      ⊢ ∀t t' t''.
          itree_wbisim t t' ∧ strip_tau t' t'' ⇒ itree_wbisim t t''
   
   [<a name="itree_wbisim_strong_coind-val"><b>itree_wbisim_strong_coind</b></a>]  Theorem
      
      ⊢ ∀R. (∀t t'.
               R t t' ⇒
               (∃t2 t3.
                  t = Tau t2 ∧ t' = Tau t3 ∧ (R t2 t3 ∨ itree_wbisim t2 t3)) ∨
               (∃e k k'.
                  strip_tau t (Vis e k) ∧ strip_tau t' (Vis e k') ∧
                  ∀r. R (k r) (k' r) ∨ itree_wbisim (k r) (k' r)) ∨
               ∃r. strip_tau t (Ret r) ∧ strip_tau t' (Ret r)) ⇒
            ∀t t'. R t t' ⇒ itree_wbisim t t'
   
   [<a name="itree_wbisim_sym-val"><b>itree_wbisim_sym</b></a>]  Theorem
      
      ⊢ ∀t t'. itree_wbisim t t' ⇒ itree_wbisim t' t
   
   [<a name="itree_wbisim_tau-val"><b>itree_wbisim_tau</b></a>]  Theorem
      
      ⊢ ∀t t'. itree_wbisim (Tau t) t' ⇒ itree_wbisim t t'
   
   [<a name="itree_wbisim_tau_eq-val"><b>itree_wbisim_tau_eq</b></a>]  Theorem
      
      ⊢ itree_wbisim (Tau t) t
   
   [<a name="itree_wbisim_tau_eqn-val"><b>itree_wbisim_tau_eqn</b></a>]  Theorem
      
      ⊢ (itree_wbisim (Tau t1) t2 ⇔ itree_wbisim t1 t2) ∧
        (itree_wbisim t1 (Tau t2) ⇔ itree_wbisim t1 t2)
   
   [<a name="itree_wbisim_trans-val"><b>itree_wbisim_trans</b></a>]  Theorem
      
      ⊢ ∀t t' t''.
          itree_wbisim t t' ∧ itree_wbisim t' t'' ⇒ itree_wbisim t t''
   
   [<a name="itree_wbisim_vis-val"><b>itree_wbisim_vis</b></a>]  Theorem
      
      ⊢ ∀e k1 k2.
          (∀r. itree_wbisim (k1 r) (k2 r)) ⇒
          itree_wbisim (Vis e k1) (Vis e k2)
   
   [<a name="spin-val"><b>spin</b></a>]  Theorem
      
      ⊢ spin = Tau spin
   
   [<a name="spin_FUNPOW_Tau-val"><b>spin_FUNPOW_Tau</b></a>]  Theorem
      
      ⊢ ∀n. spin = FUNPOW Tau n spin
   
   [<a name="spin_bind-val"><b>spin_bind</b></a>]  Theorem
      
      ⊢ itree_bind spin k = spin
   
   [<a name="spin_strip_tau-val"><b>spin_strip_tau</b></a>]  Theorem
      
      ⊢ ∀t. strip_tau spin t ⇒ F
   
   [<a name="strip_tau_FUNPOW-val"><b>strip_tau_FUNPOW</b></a>]  Theorem
      
      ⊢ ∀t1 t2. strip_tau t1 t2 ⇒ ∃n. t1 = FUNPOW Tau n t2
   
   [<a name="strip_tau_FUNPOW_cancel-val"><b>strip_tau_FUNPOW_cancel</b></a>]  Theorem
      
      ⊢ (∀u. t ≠ Tau u) ⇒ strip_tau (FUNPOW Tau n t) t
   
   [<a name="strip_tau_cases-val"><b>strip_tau_cases</b></a>]  Theorem
      
      ⊢ ∀a0 a1.
          strip_tau a0 a1 ⇔
          (∃t. a0 = Tau t ∧ strip_tau t a1) ∨
          (∃e k. a0 = Vis e k ∧ a1 = Vis e k) ∨ ∃v. a0 = Ret v ∧ a1 = Ret v
   
   [<a name="strip_tau_ind-val"><b>strip_tau_ind</b></a>]  Theorem
      
      ⊢ ∀strip_tau'.
          (∀t t'. strip_tau' t t' ⇒ strip_tau' (Tau t) t') ∧
          (∀e k. strip_tau' (Vis e k) (Vis e k)) ∧
          (∀v. strip_tau' (Ret v) (Ret v)) ⇒
          ∀a0 a1. strip_tau a0 a1 ⇒ strip_tau' a0 a1
   
   [<a name="strip_tau_inj-val"><b>strip_tau_inj</b></a>]  Theorem
      
      ⊢ ∀t t' t''. strip_tau t t' ∧ strip_tau t t'' ⇒ t' = t''
   
   [<a name="strip_tau_rules-val"><b>strip_tau_rules</b></a>]  Theorem
      
      ⊢ (∀t t'. strip_tau t t' ⇒ strip_tau (Tau t) t') ∧
        (∀e k. strip_tau (Vis e k) (Vis e k)) ∧
        ∀v. strip_tau (Ret v) (Ret v)
   
   [<a name="strip_tau_simps-val"><b>strip_tau_simps</b></a>]  Theorem
      
      ⊢ (strip_tau t' (Tau t) ⇔ F) ∧ (strip_tau (Ret v) (Vis e k) ⇔ F) ∧
        (strip_tau (Vis e k) (Ret v) ⇔ F) ∧
        (strip_tau (Tau t) t' ⇔ strip_tau t t')
   
   [<a name="strip_tau_simps2-val"><b>strip_tau_simps2</b></a>]  Theorem
      
      ⊢ strip_tau (Ret v) (Ret v') ⇔ v = v'
   
   [<a name="strip_tau_simps3-val"><b>strip_tau_simps3</b></a>]  Theorem
      
      ⊢ strip_tau (Vis e k) (Vis e' k') ⇔ e = e' ∧ k = k'
   
   [<a name="strip_tau_spin-val"><b>strip_tau_spin</b></a>]  Theorem
      
      ⊢ (∀t'. ¬strip_tau t t') ⇒ t = spin
   
   [<a name="strip_tau_strongind-val"><b>strip_tau_strongind</b></a>]  Theorem
      
      ⊢ ∀strip_tau'.
          (∀t t'. strip_tau t t' ∧ strip_tau' t t' ⇒ strip_tau' (Tau t) t') ∧
          (∀e k. strip_tau' (Vis e k) (Vis e k)) ∧
          (∀v. strip_tau' (Ret v) (Ret v)) ⇒
          ∀a0 a1. strip_tau a0 a1 ⇒ strip_tau' a0 a1
   
   [<a name="strip_tau_vis_wbisim-val"><b>strip_tau_vis_wbisim</b></a>]  Theorem
      
      ⊢ ∀e k k'.
          strip_tau t (Vis e k) ∧ strip_tau t' (Vis e k') ∧
          (∀r. itree_wbisim (k r) (k' r)) ⇒
          itree_wbisim t t'
   
   [<a name="untau_IMP_wbisim-val"><b>untau_IMP_wbisim</b></a>]  Theorem
      
      ⊢ ∀t t'. untau t = untau t' ⇒ itree_wbisim t t'
   
   [<a name="untau_spin-val"><b>untau_spin</b></a>]  Theorem
      
      ⊢ untau spin = Div
   
   [<a name="upto_taus_compatible-val"><b>upto_taus_compatible</b></a>]  Theorem
      
      ⊢ set_compatible wbisim_functional upto_taus_func
   
   [<a name="wbisim_FUNPOW_Tau-val"><b>wbisim_FUNPOW_Tau</b></a>]  Theorem
      
      ⊢ (itree_wbisim t (FUNPOW Tau n ht) ⇔ itree_wbisim t ht) ∧
        (itree_wbisim (FUNPOW Tau n ht) t ⇔ itree_wbisim ht t)
   
   [<a name="wbisim_IMP_untau-val"><b>wbisim_IMP_untau</b></a>]  Theorem
      
      ⊢ ∀t t'. itree_wbisim t t' ⇒ untau t = untau t'
   
   [<a name="wbisim_functional_cancel-val"><b>wbisim_functional_cancel</b></a>]  Theorem
      
      ⊢ X ⊆ Y ⇒ wbisim_functional X ⊆ wbisim_functional Y
   
   [<a name="wbisim_functional_gfp-val"><b>wbisim_functional_gfp</b></a>]  Theorem
      
      ⊢ gfp wbisim_functional = rel_to_reln itree_wbisim
   
   [<a name="wbisim_functional_mono-val"><b>wbisim_functional_mono</b></a>]  Theorem
      
      ⊢ monotone wbisim_functional
   
   [<a name="wbisim_spin_eq-val"><b>wbisim_spin_eq</b></a>]  Theorem
      
      ⊢ itree_wbisim t spin ⇔ t = spin
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/coalgebras/.hol/objs/itreeTauScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-2</a></em></p></body></html>
