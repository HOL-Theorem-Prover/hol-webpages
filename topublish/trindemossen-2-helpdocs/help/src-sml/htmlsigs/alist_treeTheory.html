<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure alist_treeTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure alist_treeTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/finite_maps/.hol/objs/alist_treeScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature alist_treeTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#count_append_def-val">count_append_def</a> : thm
<a name="line7"></a>    val <a href="#is_insert_def-val">is_insert_def</a> : thm
<a name="line8"></a>    val <a href="#is_lookup_def-val">is_lookup_def</a> : thm
<a name="line9"></a>    val <a href="#option_choice_f_def-val">option_choice_f_def</a> : thm
<a name="line10"></a>    val <a href="#sorted_alist_repr_def-val">sorted_alist_repr_def</a> : thm
<a name="line11"></a>  
<a name="line12"></a>  (*  Theorems  *)
<a name="line13"></a>    val <a href="#DISJ_EQ_IMP-val">DISJ_EQ_IMP</a> : thm
<a name="line14"></a>    val <a href="#HD_APPEND-val">HD_APPEND</a> : thm
<a name="line15"></a>    val <a href="#HD_MAP-val">HD_MAP</a> : thm
<a name="line16"></a>    val <a href="#HD_MEM-val">HD_MEM</a> : thm
<a name="line17"></a>    val <a href="#LAST_APPEND-val">LAST_APPEND</a> : thm
<a name="line18"></a>    val <a href="#alist_repr_choice_trans_left-val">alist_repr_choice_trans_left</a> : thm
<a name="line19"></a>    val <a href="#alist_repr_refl-val">alist_repr_refl</a> : thm
<a name="line20"></a>    val <a href="#alookup_append_option_choice_f-val">alookup_append_option_choice_f</a> : thm
<a name="line21"></a>    val <a href="#alookup_empty_option_choice_f-val">alookup_empty_option_choice_f</a> : thm
<a name="line22"></a>    val <a href="#alookup_to_option_choice-val">alookup_to_option_choice</a> : thm
<a name="line23"></a>    val <a href="#balance_l-val">balance_l</a> : thm
<a name="line24"></a>    val <a href="#balance_r-val">balance_r</a> : thm
<a name="line25"></a>    val <a href="#count_append_HD_LAST-val">count_append_HD_LAST</a> : thm
<a name="line26"></a>    val <a href="#empty_is_ALOOKUP-val">empty_is_ALOOKUP</a> : thm
<a name="line27"></a>    val <a href="#insert_fl_R-val">insert_fl_R</a> : thm
<a name="line28"></a>    val <a href="#insert_fl_R_append-val">insert_fl_R_append</a> : thm
<a name="line29"></a>    val <a href="#is_insert_centre-val">is_insert_centre</a> : thm
<a name="line30"></a>    val <a href="#is_insert_centre_rule-val">is_insert_centre_rule</a> : thm
<a name="line31"></a>    val <a href="#is_insert_far_left-val">is_insert_far_left</a> : thm
<a name="line32"></a>    val <a href="#is_insert_far_right-val">is_insert_far_right</a> : thm
<a name="line33"></a>    val <a href="#is_insert_l-val">is_insert_l</a> : thm
<a name="line34"></a>    val <a href="#is_insert_overwrite-val">is_insert_overwrite</a> : thm
<a name="line35"></a>    val <a href="#is_insert_r-val">is_insert_r</a> : thm
<a name="line36"></a>    val <a href="#is_insert_to_empty-val">is_insert_to_empty</a> : thm
<a name="line37"></a>    val <a href="#is_lookup_centre-val">is_lookup_centre</a> : thm
<a name="line38"></a>    val <a href="#is_lookup_empty-val">is_lookup_empty</a> : thm
<a name="line39"></a>    val <a href="#is_lookup_far_left-val">is_lookup_far_left</a> : thm
<a name="line40"></a>    val <a href="#is_lookup_far_right-val">is_lookup_far_right</a> : thm
<a name="line41"></a>    val <a href="#is_lookup_hit-val">is_lookup_hit</a> : thm
<a name="line42"></a>    val <a href="#is_lookup_l-val">is_lookup_l</a> : thm
<a name="line43"></a>    val <a href="#is_lookup_r-val">is_lookup_r</a> : thm
<a name="line44"></a>    val <a href="#lookup_repr-val">lookup_repr</a> : thm
<a name="line45"></a>    val <a href="#option_choice_f_assoc-val">option_choice_f_assoc</a> : thm
<a name="line46"></a>    val <a href="#repr_insert-val">repr_insert</a> : thm
<a name="line47"></a>    val <a href="#set_count-val">set_count</a> : thm
<a name="line48"></a>    val <a href="#sorted_fst_insert_centre-val">sorted_fst_insert_centre</a> : thm
<a name="line49"></a>(*
   [alist] Parent theory of "alist_tree"
   
   [<a name="count_append_def-val"><b>count_append_def</b></a>]  Definition
      
      ⊢ ∀n xs ys. count_append n xs ys = xs ⧺ ys
   
   [<a name="is_insert_def-val"><b>is_insert_def</b></a>]  Definition
      
      ⊢ ∀frame_l frame_r R k x al al'.
          is_insert frame_l frame_r R k x al al' ⇔
          irreflexive R ∧ transitive R ⇒
          SORTED R (MAP FST al) ⇒
          ALOOKUP al' = ALOOKUP ((k,x)::al) ∧
          (frame_l ⇒ al ≠ [] ∧ FST (HD al') = FST (HD al)) ∧
          (frame_r ⇒ al ≠ [] ∧ FST (LAST al') = FST (LAST al)) ∧
          SORTED R (MAP FST al')
   
   [<a name="is_lookup_def-val"><b>is_lookup_def</b></a>]  Definition
      
      ⊢ ∀fl fr R al x r.
          is_lookup fl fr R al x r ⇔
          ∀xs ys.
            fl ∨ xs = [] ⇒
            fr ∨ ys = [] ⇒
            irreflexive R ∧ transitive R ⇒
            SORTED R (MAP FST (xs ⧺ al ⧺ ys)) ⇒
            ALOOKUP (xs ⧺ al ⧺ ys) x = r
   
   [<a name="option_choice_f_def-val"><b>option_choice_f_def</b></a>]  Definition
      
      ⊢ ∀f g. option_choice_f f g = (λx. OPTION_CHOICE (f x) (g x))
   
   [<a name="sorted_alist_repr_def-val"><b>sorted_alist_repr_def</b></a>]  Definition
      
      ⊢ ∀R al f.
          sorted_alist_repr R al f ⇔
          SORTED R (MAP FST al) ∧ irreflexive R ∧ transitive R ∧
          f = ALOOKUP al
   
   [<a name="DISJ_EQ_IMP-val"><b>DISJ_EQ_IMP</b></a>]  Theorem
      
      ⊢ P ∨ Q ⇔ ¬P ⇒ Q
   
   [<a name="HD_APPEND-val"><b>HD_APPEND</b></a>]  Theorem
      
      ⊢ HD (xs ⧺ ys) = if xs = [] then HD ys else HD xs
   
   [<a name="HD_MAP-val"><b>HD_MAP</b></a>]  Theorem
      
      ⊢ xs ≠ [] ⇒ HD (MAP f xs) = f (HD xs)
   
   [<a name="HD_MEM-val"><b>HD_MEM</b></a>]  Theorem
      
      ⊢ xs ≠ [] ⇒ MEM (HD xs) xs
   
   [<a name="LAST_APPEND-val"><b>LAST_APPEND</b></a>]  Theorem
      
      ⊢ LAST (xs ⧺ ys) = if ys = [] then LAST xs else LAST ys
   
   [<a name="alist_repr_choice_trans_left-val"><b>alist_repr_choice_trans_left</b></a>]  Theorem
      
      ⊢ sorted_alist_repr R al f ∧
        sorted_alist_repr R al' (option_choice_f (ALOOKUP al) g) ⇒
        sorted_alist_repr R al' (option_choice_f f g)
   
   [<a name="alist_repr_refl-val"><b>alist_repr_refl</b></a>]  Theorem
      
      ⊢ ∀al.
          irreflexive R ∧ transitive R ⇒
          SORTED R (MAP FST al) ⇒
          sorted_alist_repr R al (ALOOKUP al)
   
   [<a name="alookup_append_option_choice_f-val"><b>alookup_append_option_choice_f</b></a>]  Theorem
      
      ⊢ ALOOKUP (xs ⧺ ys) = option_choice_f (ALOOKUP xs) (ALOOKUP ys)
   
   [<a name="alookup_empty_option_choice_f-val"><b>alookup_empty_option_choice_f</b></a>]  Theorem
      
      ⊢ option_choice_f (ALOOKUP []) f = f ∧
        option_choice_f f (ALOOKUP []) = f
   
   [<a name="alookup_to_option_choice-val"><b>alookup_to_option_choice</b></a>]  Theorem
      
      ⊢ ALOOKUP (x::y::zs) =
        option_choice_f (ALOOKUP [x]) (ALOOKUP (y::zs)) ∧
        option_choice_f (ALOOKUP []) g = g
   
   [<a name="balance_l-val"><b>balance_l</b></a>]  Theorem
      
      ⊢ count_append i xs (count_append j ys zs) =
        count_append ARB (count_append ARB xs ys) zs
   
   [<a name="balance_r-val"><b>balance_r</b></a>]  Theorem
      
      ⊢ count_append i (count_append j xs ys) zs =
        count_append ARB xs (count_append ARB ys zs)
   
   [<a name="count_append_HD_LAST-val"><b>count_append_HD_LAST</b></a>]  Theorem
      
      ⊢ HD (count_append i (count_append j xs ys) zs) =
        HD (count_append 0 xs (count_append 0 ys zs)) ∧
        HD (count_append i (x::xs) ys) = x ∧
        HD (count_append i [] ys) = HD ys ∧
        LAST (count_append i xs (count_append j ys zs)) =
        LAST (count_append 0 (count_append 0 xs ys) zs) ∧
        LAST (count_append i xs (y::ys)) = LAST (y::ys) ∧
        LAST (count_append i xs []) = LAST xs ∧ HD (x::xs) = x ∧
        LAST (x::y::zs) = LAST (y::zs) ∧ LAST [x] = x ∧
        (count_append i (count_append j xs ys) zs = [] ⇔
         count_append 0 xs (count_append 0 ys zs) = []) ∧
        (count_append i [] ys = [] ⇔ ys = []) ∧
        (count_append i (x::xs) ys = [] ⇔ F) ∧ (x::xs = [] ⇔ F)
   
   [<a name="empty_is_ALOOKUP-val"><b>empty_is_ALOOKUP</b></a>]  Theorem
      
      ⊢ (λx. NONE) = ALOOKUP []
   
   [<a name="insert_fl_R-val"><b>insert_fl_R</b></a>]  Theorem
      
      ⊢ is_insert fl fr R k x al al' ⇒
        fl ⇒
        SORTED R (MAP FST al) ⇒
        irreflexive R ∧ transitive R ⇒
        k = FST (HD al) ∨ R (HD (MAP FST al)) k
   
   [<a name="insert_fl_R_append-val"><b>insert_fl_R_append</b></a>]  Theorem
      
      ⊢ is_insert T fr R k x r r' ⇒
        SORTED R (MAP FST (l ⧺ r)) ⇒
        irreflexive R ∧ transitive R ⇒
        ¬MEM k (MAP FST l)
   
   [<a name="is_insert_centre-val"><b>is_insert_centre</b></a>]  Theorem
      
      ⊢ ∀R n k x.
          l ≠ [] ⇒
          R (FST (LAST l)) k ⇒
          r ≠ [] ⇒
          R k (FST (HD r)) ⇒
          is_insert T T R k x (count_append n l r)
            (count_append ARB l (count_append ARB [(k,x)] r))
   
   [<a name="is_insert_centre_rule-val"><b>is_insert_centre_rule</b></a>]  Theorem
      
      ⊢ (fl ⇒ l ≠ []) ⇒
        (l ≠ [] ⇒ R (FST (LAST l)) k) ⇒
        (fr ⇒ r ≠ []) ⇒
        (r ≠ [] ⇒ R k (FST (HD r))) ⇒
        is_insert fl fr R k x (count_append n l r)
          (count_append ARB l (count_append ARB [(k,x)] r))
   
   [<a name="is_insert_far_left-val"><b>is_insert_far_left</b></a>]  Theorem
      
      ⊢ ∀R k x xs.
          xs ≠ [] ⇒
          R k (FST (HD xs)) ⇒
          is_insert F T R k x xs (count_append ARB [(k,x)] xs)
   
   [<a name="is_insert_far_right-val"><b>is_insert_far_right</b></a>]  Theorem
      
      ⊢ ∀R k x xs.
          xs ≠ [] ⇒
          R (FST (LAST xs)) k ⇒
          is_insert T F R k x xs (count_append ARB xs [(k,x)])
   
   [<a name="is_insert_l-val"><b>is_insert_l</b></a>]  Theorem
      
      ⊢ ∀n. is_insert fl T R k x l l' ⇒
            is_insert fl T R k x (count_append n l r)
              (count_append ARB l' r)
   
   [<a name="is_insert_overwrite-val"><b>is_insert_overwrite</b></a>]  Theorem
      
      ⊢ ∀R k x v. FST v = k ⇒ is_insert T T R k x [v] [(k,x)]
   
   [<a name="is_insert_r-val"><b>is_insert_r</b></a>]  Theorem
      
      ⊢ ∀n. is_insert T fr R k x r r' ⇒
            is_insert T fr R k x (count_append n l r)
              (count_append ARB l r')
   
   [<a name="is_insert_to_empty-val"><b>is_insert_to_empty</b></a>]  Theorem
      
      ⊢ ∀R k x. is_insert F F R k x [] [(k,x)]
   
   [<a name="is_lookup_centre-val"><b>is_lookup_centre</b></a>]  Theorem
      
      ⊢ ∀R n l r k.
          l ≠ [] ⇒
          R (FST (LAST l)) k ⇒
          r ≠ [] ⇒
          R k (FST (HD r)) ⇒
          is_lookup T T R (count_append n l r) k NONE
   
   [<a name="is_lookup_empty-val"><b>is_lookup_empty</b></a>]  Theorem
      
      ⊢ ∀R k al. al = [] ⇒ is_lookup F F R al k NONE
   
   [<a name="is_lookup_far_left-val"><b>is_lookup_far_left</b></a>]  Theorem
      
      ⊢ ∀R k k' v. R k k' ⇒ is_lookup F T R [(k',v)] k NONE
   
   [<a name="is_lookup_far_right-val"><b>is_lookup_far_right</b></a>]  Theorem
      
      ⊢ ∀R k k' v. R k' k ⇒ is_lookup T F R [(k',v)] k NONE
   
   [<a name="is_lookup_hit-val"><b>is_lookup_hit</b></a>]  Theorem
      
      ⊢ ∀R k k' v. k' = k ⇒ is_lookup T T R [(k',v)] k (SOME v)
   
   [<a name="is_lookup_l-val"><b>is_lookup_l</b></a>]  Theorem
      
      ⊢ ∀n. is_lookup fl T R l x res ⇒
            is_lookup fl T R (count_append n l r) x res
   
   [<a name="is_lookup_r-val"><b>is_lookup_r</b></a>]  Theorem
      
      ⊢ ∀n. is_lookup T fr R r x res ⇒
            is_lookup T fr R (count_append n l r) x res
   
   [<a name="lookup_repr-val"><b>lookup_repr</b></a>]  Theorem
      
      ⊢ sorted_alist_repr R al f ∧ is_lookup fl fr R al x r ⇒ f x = r
   
   [<a name="option_choice_f_assoc-val"><b>option_choice_f_assoc</b></a>]  Theorem
      
      ⊢ option_choice_f (option_choice_f f g) h =
        option_choice_f f (option_choice_f g h)
   
   [<a name="repr_insert-val"><b>repr_insert</b></a>]  Theorem
      
      ⊢ sorted_alist_repr R al f ∧ is_insert fl fr R k x al al' ⇒
        sorted_alist_repr R al' (option_choice_f (ALOOKUP [(k,x)]) f)
   
   [<a name="set_count-val"><b>set_count</b></a>]  Theorem
      
      ⊢ ∀j. count_append i xs ys = count_append j xs ys
   
   [<a name="sorted_fst_insert_centre-val"><b>sorted_fst_insert_centre</b></a>]  Theorem
      
      ⊢ ∀k. SORTED R (MAP FST l ⧺ MAP FST r) ⇒
            (l ≠ [] ⇒ R (FST (LAST l)) k) ⇒
            (r ≠ [] ⇒ R k (FST (HD r))) ⇒
            SORTED R (MAP FST l ⧺ k::MAP FST r)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/finite_maps/.hol/objs/alist_treeScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-2</a></em></p></body></html>
