<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure logrootTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure logrootTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/num/extra_theories/logrootScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature logrootTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#LOG-val">LOG</a> : thm
<a name="line7"></a>    val <a href="#ROOT-val">ROOT</a> : thm
<a name="line8"></a>    val <a href="#SQRTd_def-val">SQRTd_def</a> : thm
<a name="line9"></a>    val <a href="#iSQRT0_def-val">iSQRT0_def</a> : thm
<a name="line10"></a>    val <a href="#iSQRT1_def-val">iSQRT1_def</a> : thm
<a name="line11"></a>    val <a href="#iSQRT2_def-val">iSQRT2_def</a> : thm
<a name="line12"></a>    val <a href="#iSQRT3_def-val">iSQRT3_def</a> : thm
<a name="line13"></a>  
<a name="line14"></a>  (*  Theorems  *)
<a name="line15"></a>    val <a href="#EXP_EQ_SELF-val">EXP_EQ_SELF</a> : thm
<a name="line16"></a>    val <a href="#EXP_LCANCEL-val">EXP_LCANCEL</a> : thm
<a name="line17"></a>    val <a href="#EXP_LE-val">EXP_LE</a> : thm
<a name="line18"></a>    val <a href="#EXP_LE_ISO-val">EXP_LE_ISO</a> : thm
<a name="line19"></a>    val <a href="#EXP_LE_LOG_SIMP-val">EXP_LE_LOG_SIMP</a> : thm
<a name="line20"></a>    val <a href="#EXP_LT-val">EXP_LT</a> : thm
<a name="line21"></a>    val <a href="#EXP_LT_ISO-val">EXP_LT_ISO</a> : thm
<a name="line22"></a>    val <a href="#EXP_LT_LOG_SIMP-val">EXP_LT_LOG_SIMP</a> : thm
<a name="line23"></a>    val <a href="#EXP_MUL-val">EXP_MUL</a> : thm
<a name="line24"></a>    val <a href="#EXP_RCANCEL-val">EXP_RCANCEL</a> : thm
<a name="line25"></a>    val <a href="#EXP_TO_LOG-val">EXP_TO_LOG</a> : thm
<a name="line26"></a>    val <a href="#LE_EXP_ISO-val">LE_EXP_ISO</a> : thm
<a name="line27"></a>    val <a href="#LE_EXP_LOG_SIMP-val">LE_EXP_LOG_SIMP</a> : thm
<a name="line28"></a>    val <a href="#LOG2_1-val">LOG2_1</a> : thm
<a name="line29"></a>    val <a href="#LOG2_2-val">LOG2_2</a> : thm
<a name="line30"></a>    val <a href="#LOG2_2_EXP-val">LOG2_2_EXP</a> : thm
<a name="line31"></a>    val <a href="#LOG2_EQ_0-val">LOG2_EQ_0</a> : thm
<a name="line32"></a>    val <a href="#LOG2_EQ_1-val">LOG2_EQ_1</a> : thm
<a name="line33"></a>    val <a href="#LOG2_EQ_SELF-val">LOG2_EQ_SELF</a> : thm
<a name="line34"></a>    val <a href="#LOG2_EXACT_EXP-val">LOG2_EXACT_EXP</a> : thm
<a name="line35"></a>    val <a href="#LOG2_LE-val">LOG2_LE</a> : thm
<a name="line36"></a>    val <a href="#LOG2_LE_MONO-val">LOG2_LE_MONO</a> : thm
<a name="line37"></a>    val <a href="#LOG2_LT-val">LOG2_LT</a> : thm
<a name="line38"></a>    val <a href="#LOG2_LT_SELF-val">LOG2_LT_SELF</a> : thm
<a name="line39"></a>    val <a href="#LOG2_MULT_EXP-val">LOG2_MULT_EXP</a> : thm
<a name="line40"></a>    val <a href="#LOG2_NEQ_SELF-val">LOG2_NEQ_SELF</a> : thm
<a name="line41"></a>    val <a href="#LOG2_POS-val">LOG2_POS</a> : thm
<a name="line42"></a>    val <a href="#LOG2_PROPERTY-val">LOG2_PROPERTY</a> : thm
<a name="line43"></a>    val <a href="#LOG2_SUC_SQ-val">LOG2_SUC_SQ</a> : thm
<a name="line44"></a>    val <a href="#LOG2_SUC_TWICE_SQ-val">LOG2_SUC_TWICE_SQ</a> : thm
<a name="line45"></a>    val <a href="#LOG2_THM-val">LOG2_THM</a> : thm
<a name="line46"></a>    val <a href="#LOG2_TWICE-val">LOG2_TWICE</a> : thm
<a name="line47"></a>    val <a href="#LOG2_TWICE_LT-val">LOG2_TWICE_LT</a> : thm
<a name="line48"></a>    val <a href="#LOG2_TWICE_SQ-val">LOG2_TWICE_SQ</a> : thm
<a name="line49"></a>    val <a href="#LOG2_UNIQUE-val">LOG2_UNIQUE</a> : thm
<a name="line50"></a>    val <a href="#LOG_1-val">LOG_1</a> : thm
<a name="line51"></a>    val <a href="#LOG_ADD-val">LOG_ADD</a> : thm
<a name="line52"></a>    val <a href="#LOG_ADD1-val">LOG_ADD1</a> : thm
<a name="line53"></a>    val <a href="#LOG_BASE-val">LOG_BASE</a> : thm
<a name="line54"></a>    val <a href="#LOG_DIV-val">LOG_DIV</a> : thm
<a name="line55"></a>    val <a href="#LOG_EQ_0-val">LOG_EQ_0</a> : thm
<a name="line56"></a>    val <a href="#LOG_EVAL-val">LOG_EVAL</a> : thm
<a name="line57"></a>    val <a href="#LOG_EXACT_EXP-val">LOG_EXACT_EXP</a> : thm
<a name="line58"></a>    val <a href="#LOG_EXP-val">LOG_EXP</a> : thm
<a name="line59"></a>    val <a href="#LOG_LE_MONO-val">LOG_LE_MONO</a> : thm
<a name="line60"></a>    val <a href="#LOG_LE_REVERSE-val">LOG_LE_REVERSE</a> : thm
<a name="line61"></a>    val <a href="#LOG_MOD-val">LOG_MOD</a> : thm
<a name="line62"></a>    val <a href="#LOG_MULT-val">LOG_MULT</a> : thm
<a name="line63"></a>    val <a href="#LOG_NUMERAL-val">LOG_NUMERAL</a> : thm
<a name="line64"></a>    val <a href="#LOG_POW-val">LOG_POW</a> : thm
<a name="line65"></a>    val <a href="#LOG_POWER-val">LOG_POWER</a> : thm
<a name="line66"></a>    val <a href="#LOG_ROOT-val">LOG_ROOT</a> : thm
<a name="line67"></a>    val <a href="#LOG_RWT-val">LOG_RWT</a> : thm
<a name="line68"></a>    val <a href="#LOG_TEST-val">LOG_TEST</a> : thm
<a name="line69"></a>    val <a href="#LOG_THM-val">LOG_THM</a> : thm
<a name="line70"></a>    val <a href="#LOG_UNIQUE-val">LOG_UNIQUE</a> : thm
<a name="line71"></a>    val <a href="#LOG_add_digit-val">LOG_add_digit</a> : thm
<a name="line72"></a>    val <a href="#LOG_exists-val">LOG_exists</a> : thm
<a name="line73"></a>    val <a href="#LT_EXP_ISO-val">LT_EXP_ISO</a> : thm
<a name="line74"></a>    val <a href="#LT_EXP_LOG-val">LT_EXP_LOG</a> : thm
<a name="line75"></a>    val <a href="#LT_EXP_LOG_SIMP-val">LT_EXP_LOG_SIMP</a> : thm
<a name="line76"></a>    val <a href="#LT_SQRT_IMP-val">LT_SQRT_IMP</a> : thm
<a name="line77"></a>    val <a href="#ONE_LE_EXP-val">ONE_LE_EXP</a> : thm
<a name="line78"></a>    val <a href="#ROOT_1-val">ROOT_1</a> : thm
<a name="line79"></a>    val <a href="#ROOT_COMPUTE-val">ROOT_COMPUTE</a> : thm
<a name="line80"></a>    val <a href="#ROOT_DIV-val">ROOT_DIV</a> : thm
<a name="line81"></a>    val <a href="#ROOT_EQ_0-val">ROOT_EQ_0</a> : thm
<a name="line82"></a>    val <a href="#ROOT_EQ_1-val">ROOT_EQ_1</a> : thm
<a name="line83"></a>    val <a href="#ROOT_EQ_SELF-val">ROOT_EQ_SELF</a> : thm
<a name="line84"></a>    val <a href="#ROOT_EVAL-val">ROOT_EVAL</a> : thm
<a name="line85"></a>    val <a href="#ROOT_EXP-val">ROOT_EXP</a> : thm
<a name="line86"></a>    val <a href="#ROOT_FROM_POWER-val">ROOT_FROM_POWER</a> : thm
<a name="line87"></a>    val <a href="#ROOT_GE_SELF-val">ROOT_GE_SELF</a> : thm
<a name="line88"></a>    val <a href="#ROOT_LE_MONO-val">ROOT_LE_MONO</a> : thm
<a name="line89"></a>    val <a href="#ROOT_LE_REVERSE-val">ROOT_LE_REVERSE</a> : thm
<a name="line90"></a>    val <a href="#ROOT_LE_SELF-val">ROOT_LE_SELF</a> : thm
<a name="line91"></a>    val <a href="#ROOT_OF_0-val">ROOT_OF_0</a> : thm
<a name="line92"></a>    val <a href="#ROOT_OF_1-val">ROOT_OF_1</a> : thm
<a name="line93"></a>    val <a href="#ROOT_POWER-val">ROOT_POWER</a> : thm
<a name="line94"></a>    val <a href="#ROOT_SUC-val">ROOT_SUC</a> : thm
<a name="line95"></a>    val <a href="#ROOT_THM-val">ROOT_THM</a> : thm
<a name="line96"></a>    val <a href="#ROOT_UNIQUE-val">ROOT_UNIQUE</a> : thm
<a name="line97"></a>    val <a href="#ROOT_exists-val">ROOT_exists</a> : thm
<a name="line98"></a>    val <a href="#SQRT_0-val">SQRT_0</a> : thm
<a name="line99"></a>    val <a href="#SQRT_1-val">SQRT_1</a> : thm
<a name="line100"></a>    val <a href="#SQRT_EQ_0-val">SQRT_EQ_0</a> : thm
<a name="line101"></a>    val <a href="#SQRT_EQ_1-val">SQRT_EQ_1</a> : thm
<a name="line102"></a>    val <a href="#SQRT_EQ_SELF-val">SQRT_EQ_SELF</a> : thm
<a name="line103"></a>    val <a href="#SQRT_EXP_2-val">SQRT_EXP_2</a> : thm
<a name="line104"></a>    val <a href="#SQRT_GE_SELF-val">SQRT_GE_SELF</a> : thm
<a name="line105"></a>    val <a href="#SQRT_LE-val">SQRT_LE</a> : thm
<a name="line106"></a>    val <a href="#SQRT_LT-val">SQRT_LT</a> : thm
<a name="line107"></a>    val <a href="#SQRT_LT_IMP-val">SQRT_LT_IMP</a> : thm
<a name="line108"></a>    val <a href="#SQRT_LT_SQRT-val">SQRT_LT_SQRT</a> : thm
<a name="line109"></a>    val <a href="#SQRT_OF_SQ-val">SQRT_OF_SQ</a> : thm
<a name="line110"></a>    val <a href="#SQRT_PROPERTY-val">SQRT_PROPERTY</a> : thm
<a name="line111"></a>    val <a href="#SQRT_THM-val">SQRT_THM</a> : thm
<a name="line112"></a>    val <a href="#SQRT_UNIQUE-val">SQRT_UNIQUE</a> : thm
<a name="line113"></a>    val <a href="#TWO_EXP_LOG2_LE-val">TWO_EXP_LOG2_LE</a> : thm
<a name="line114"></a>    val <a href="#numeral_root2-val">numeral_root2</a> : thm
<a name="line115"></a>    val <a href="#numeral_sqrt-val">numeral_sqrt</a> : thm
<a name="line116"></a>(*
   [basicSize] Parent theory of "logroot"
   
   [cv] Parent theory of "logroot"
   
   [reduce] Parent theory of "logroot"
   
   [while] Parent theory of "logroot"
   
   [<a name="LOG-val"><b>LOG</b></a>]  Definition
      
      ⊢ ∀a n. 1 &lt; a ∧ 0 &lt; n ⇒ a ** LOG a n ≤ n ∧ n &lt; a ** SUC (LOG a n)
   
   [<a name="ROOT-val"><b>ROOT</b></a>]  Definition
      
      ⊢ ∀r n. 0 &lt; r ⇒ ROOT r n ** r ≤ n ∧ n &lt; SUC (ROOT r n) ** r
   
   [<a name="SQRTd_def-val"><b>SQRTd_def</b></a>]  Definition
      
      ⊢ ∀n. SQRTd n = (SQRT n,n − SQRT n * SQRT n)
   
   [<a name="iSQRT0_def-val"><b>iSQRT0_def</b></a>]  Definition
      
      ⊢ ∀n. iSQRT0 n =
            (let
               p = SQRTd n;
               d = SND p − FST p
             in
               if d = 0 then (2 * FST p,4 * SND p)
               else (SUC (2 * FST p),4 * d − 1))
   
   [<a name="iSQRT1_def-val"><b>iSQRT1_def</b></a>]  Definition
      
      ⊢ ∀n. iSQRT1 n =
            (let
               p = SQRTd n;
               d = SUC (SND p) − FST p
             in
               if d = 0 then (2 * FST p,SUC (4 * SND p))
               else (SUC (2 * FST p),4 * (d − 1)))
   
   [<a name="iSQRT2_def-val"><b>iSQRT2_def</b></a>]  Definition
      
      ⊢ ∀n. iSQRT2 n =
            (let
               p = SQRTd n;
               d = 2 * FST p;
               c = SUC (2 * SND p);
               e = c − d
             in
               if e = 0 then (d,2 * c) else (SUC d,2 * e − 1))
   
   [<a name="iSQRT3_def-val"><b>iSQRT3_def</b></a>]  Definition
      
      ⊢ ∀n. iSQRT3 n =
            (let
               p = SQRTd n;
               d = 2 * FST p;
               c = SUC (2 * SND p);
               e = SUC c − d
             in
               if e = 0 then (d,SUC (2 * c)) else (SUC d,2 * (e − 1)))
   
   [<a name="EXP_EQ_SELF-val"><b>EXP_EQ_SELF</b></a>]  Theorem
      
      ⊢ ∀n m. 0 &lt; m ⇒ (n ** m = n ⇔ m = 1 ∨ n = 0 ∨ n = 1)
   
   [<a name="EXP_LCANCEL-val"><b>EXP_LCANCEL</b></a>]  Theorem
      
      ⊢ ∀a b c n m.
          0 &lt; a ∧ n &lt; m ∧ a ** n * b = a ** m * c ⇒
          ∃d. 0 &lt; d ∧ b = a ** d * c
   
   [<a name="EXP_LE-val"><b>EXP_LE</b></a>]  Theorem
      
      ⊢ ∀n b. 0 &lt; n ⇒ b ≤ b ** n
   
   [<a name="EXP_LE_ISO-val"><b>EXP_LE_ISO</b></a>]  Theorem
      
      ⊢ ∀a b r. 0 &lt; r ⇒ (a ≤ b ⇔ a ** r ≤ b ** r)
   
   [<a name="EXP_LE_LOG_SIMP-val"><b>EXP_LE_LOG_SIMP</b></a>]  Theorem
      
      ⊢ (&lt;..num comp'n..&gt; ** e ≤ &lt;..num comp'n..&gt; ⇔
         &lt;..num comp'n..&gt; &lt; 2 ∨ e ≤ LOG &lt;..num comp'n..&gt; &lt;..num comp'n..&gt; ) ∧
        (&lt;..num comp'n..&gt; ** e ≤ &lt;..num comp'n..&gt; ⇔
         &lt;..num comp'n..&gt; &lt; 2 ∨ e ≤ LOG &lt;..num comp'n..&gt; &lt;..num comp'n..&gt; )
   
   [<a name="EXP_LT-val"><b>EXP_LT</b></a>]  Theorem
      
      ⊢ ∀n b. 1 &lt; b ∧ 1 &lt; n ⇒ b &lt; b ** n
   
   [<a name="EXP_LT_ISO-val"><b>EXP_LT_ISO</b></a>]  Theorem
      
      ⊢ ∀a b r. 0 &lt; r ⇒ (a &lt; b ⇔ a ** r &lt; b ** r)
   
   [<a name="EXP_LT_LOG_SIMP-val"><b>EXP_LT_LOG_SIMP</b></a>]  Theorem
      
      ⊢ (&lt;..num comp'n..&gt; ** e &lt; &lt;..num comp'n..&gt; ⇔
         &lt;..num comp'n..&gt; &lt; 2 ∨
         e ≤ LOG &lt;..num comp'n..&gt; (&lt;..num comp'n..&gt; − 1)) ∧
        (&lt;..num comp'n..&gt; ** e &lt; &lt;..num comp'n..&gt; ⇔
         &lt;..num comp'n..&gt; &lt; 2 ∨
         e ≤ LOG &lt;..num comp'n..&gt; (&lt;..num comp'n..&gt; − 1)) ∧
        (&lt;..num comp'n..&gt; ** e &lt; &lt;..num comp'n..&gt; ⇔
         &lt;..num comp'n..&gt; &lt; 2 ∨
         e ≤ LOG &lt;..num comp'n..&gt; (&lt;..num comp'n..&gt; − 1))
   
   [<a name="EXP_MUL-val"><b>EXP_MUL</b></a>]  Theorem
      
      ⊢ ∀a b c. (a ** b) ** c = a ** (b * c)
   
   [<a name="EXP_RCANCEL-val"><b>EXP_RCANCEL</b></a>]  Theorem
      
      ⊢ ∀a b c n m.
          0 &lt; a ∧ n &lt; m ∧ b * a ** n = c * a ** m ⇒
          ∃d. 0 &lt; d ∧ b = c * a ** d
   
   [<a name="EXP_TO_LOG-val"><b>EXP_TO_LOG</b></a>]  Theorem
      
      ⊢ ∀a b n. 1 &lt; a ∧ 0 &lt; b ∧ b ≤ a ** n ⇒ LOG a b ≤ n
   
   [<a name="LE_EXP_ISO-val"><b>LE_EXP_ISO</b></a>]  Theorem
      
      ⊢ ∀e a b. 1 &lt; e ⇒ (a ≤ b ⇔ e ** a ≤ e ** b)
   
   [<a name="LE_EXP_LOG_SIMP-val"><b>LE_EXP_LOG_SIMP</b></a>]  Theorem
      
      ⊢ (&lt;..num comp'n..&gt; ≤ &lt;..num comp'n..&gt; ** e ⇔
         2 ≤ &lt;..num comp'n..&gt; ∧
         LOG &lt;..num comp'n..&gt; (&lt;..num comp'n..&gt; − 1) &lt; e) ∧
        (&lt;..num comp'n..&gt; ≤ &lt;..num comp'n..&gt; ** e ⇔
         2 ≤ &lt;..num comp'n..&gt; ∧
         LOG &lt;..num comp'n..&gt; (&lt;..num comp'n..&gt; − 1) &lt; e) ∧
        (&lt;..num comp'n..&gt; ≤ &lt;..num comp'n..&gt; ** e ⇔
         2 ≤ &lt;..num comp'n..&gt; ∧
         LOG &lt;..num comp'n..&gt; (&lt;..num comp'n..&gt; − 1) &lt; e)
   
   [<a name="LOG2_1-val"><b>LOG2_1</b></a>]  Theorem
      
      ⊢ LOG2 1 = 0
   
   [<a name="LOG2_2-val"><b>LOG2_2</b></a>]  Theorem
      
      ⊢ LOG2 2 = 1
   
   [<a name="LOG2_2_EXP-val"><b>LOG2_2_EXP</b></a>]  Theorem
      
      ⊢ ∀n. LOG2 (2 ** n) = n
   
   [<a name="LOG2_EQ_0-val"><b>LOG2_EQ_0</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ (LOG2 n = 0 ⇔ n = 1)
   
   [<a name="LOG2_EQ_1-val"><b>LOG2_EQ_1</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ (LOG2 n = 1 ⇔ n = 2 ∨ n = 3)
   
   [<a name="LOG2_EQ_SELF-val"><b>LOG2_EQ_SELF</b></a>]  Theorem
      
      ⊢ ∀n. LOG2 n = n ⇒ n = 0
   
   [<a name="LOG2_EXACT_EXP-val"><b>LOG2_EXACT_EXP</b></a>]  Theorem
      
      ⊢ ∀n. 2 ** LOG2 n = n ⇔ ∃k. n = 2 ** k
   
   [<a name="LOG2_LE-val"><b>LOG2_LE</b></a>]  Theorem
      
      ⊢ ∀n m. 0 &lt; n ∧ n ≤ m ⇒ LOG2 n ≤ LOG2 m
   
   [<a name="LOG2_LE_MONO-val"><b>LOG2_LE_MONO</b></a>]  Theorem
      
      ⊢ ∀n m. 0 &lt; n ⇒ n ≤ m ⇒ LOG2 n ≤ LOG2 m
   
   [<a name="LOG2_LT-val"><b>LOG2_LT</b></a>]  Theorem
      
      ⊢ ∀n m. 0 &lt; n ∧ n &lt; m ⇒ LOG2 n ≤ LOG2 m
   
   [<a name="LOG2_LT_SELF-val"><b>LOG2_LT_SELF</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ LOG2 n &lt; n
   
   [<a name="LOG2_MULT_EXP-val"><b>LOG2_MULT_EXP</b></a>]  Theorem
      
      ⊢ ∀n m. 0 &lt; n ⇒ LOG2 (n * 2 ** m) = LOG2 n + m
   
   [<a name="LOG2_NEQ_SELF-val"><b>LOG2_NEQ_SELF</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ LOG2 n ≠ n
   
   [<a name="LOG2_POS-val"><b>LOG2_POS</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ 0 &lt; LOG2 n
   
   [<a name="LOG2_PROPERTY-val"><b>LOG2_PROPERTY</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ 2 ** LOG2 n ≤ n ∧ n &lt; 2 ** SUC (LOG2 n)
   
   [<a name="LOG2_SUC_SQ-val"><b>LOG2_SUC_SQ</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ 1 &lt; (SUC (LOG2 n))²
   
   [<a name="LOG2_SUC_TWICE_SQ-val"><b>LOG2_SUC_TWICE_SQ</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ 4 ≤ (2 * SUC (LOG2 n))²
   
   [<a name="LOG2_THM-val"><b>LOG2_THM</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀p. LOG2 n = p ⇔ 2 ** p ≤ n ∧ n &lt; 2 ** SUC p
   
   [<a name="LOG2_TWICE-val"><b>LOG2_TWICE</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ LOG2 (2 * n) = 1 + LOG2 n
   
   [<a name="LOG2_TWICE_LT-val"><b>LOG2_TWICE_LT</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ 1 &lt; 2 * LOG2 n
   
   [<a name="LOG2_TWICE_SQ-val"><b>LOG2_TWICE_SQ</b></a>]  Theorem
      
      ⊢ ∀n. 1 &lt; n ⇒ 4 ≤ (2 * LOG2 n)²
   
   [<a name="LOG2_UNIQUE-val"><b>LOG2_UNIQUE</b></a>]  Theorem
      
      ⊢ ∀n m. 2 ** m ≤ n ∧ n &lt; 2 ** SUC m ⇒ LOG2 n = m
   
   [<a name="LOG_1-val"><b>LOG_1</b></a>]  Theorem
      
      ⊢ ∀a. 1 &lt; a ⇒ LOG a 1 = 0
   
   [<a name="LOG_ADD-val"><b>LOG_ADD</b></a>]  Theorem
      
      ⊢ ∀a b c. 1 &lt; a ∧ b &lt; a ** c ⇒ LOG a (b + a ** c) = c
   
   [<a name="LOG_ADD1-val"><b>LOG_ADD1</b></a>]  Theorem
      
      ⊢ ∀n a b.
          0 &lt; n ∧ 1 &lt; a ∧ 0 &lt; b ⇒
          LOG a (a ** SUC n * b) = SUC (LOG a (a ** n * b))
   
   [<a name="LOG_BASE-val"><b>LOG_BASE</b></a>]  Theorem
      
      ⊢ ∀a. 1 &lt; a ⇒ LOG a a = 1
   
   [<a name="LOG_DIV-val"><b>LOG_DIV</b></a>]  Theorem
      
      ⊢ ∀a x. 1 &lt; a ∧ a ≤ x ⇒ LOG a x = 1 + LOG a (x DIV a)
   
   [<a name="LOG_EQ_0-val"><b>LOG_EQ_0</b></a>]  Theorem
      
      ⊢ ∀a b. 1 &lt; a ∧ 0 &lt; b ⇒ (LOG a b = 0 ⇔ b &lt; a)
   
   [<a name="LOG_EVAL-val"><b>LOG_EVAL</b></a>]  Theorem
      
      ⊢ ∀m n.
          LOG m n =
          if m ≤ 1 ∨ n = 0 then LOG m n
          else if n &lt; m then 0
          else SUC (LOG m (n DIV m))
   
   [<a name="LOG_EXACT_EXP-val"><b>LOG_EXACT_EXP</b></a>]  Theorem
      
      ⊢ ∀a. 1 &lt; a ⇒ ∀n. LOG a (a ** n) = n
   
   [<a name="LOG_EXP-val"><b>LOG_EXP</b></a>]  Theorem
      
      ⊢ ∀n a b. 1 &lt; a ∧ 0 &lt; b ⇒ LOG a (a ** n * b) = n + LOG a b
   
   [<a name="LOG_LE_MONO-val"><b>LOG_LE_MONO</b></a>]  Theorem
      
      ⊢ ∀a x y. 1 &lt; a ∧ 0 &lt; x ⇒ x ≤ y ⇒ LOG a x ≤ LOG a y
   
   [<a name="LOG_LE_REVERSE-val"><b>LOG_LE_REVERSE</b></a>]  Theorem
      
      ⊢ ∀a b n. 1 &lt; a ∧ 0 &lt; n ∧ a ≤ b ⇒ LOG b n ≤ LOG a n
   
   [<a name="LOG_MOD-val"><b>LOG_MOD</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ n = 2 ** LOG2 n + n MOD 2 ** LOG2 n
   
   [<a name="LOG_MULT-val"><b>LOG_MULT</b></a>]  Theorem
      
      ⊢ ∀b x. 1 &lt; b ∧ 0 &lt; x ⇒ LOG b (b * x) = SUC (LOG b x)
   
   [<a name="LOG_NUMERAL-val"><b>LOG_NUMERAL</b></a>]  Theorem
      
      ⊢ LOG &lt;..num comp'n..&gt; &lt;..num comp'n..&gt; =
        (if &lt;..num comp'n..&gt; &lt; &lt;..num comp'n..&gt; then 0
         else
           LOG &lt;..num comp'n..&gt; (&lt;..num comp'n..&gt; DIV &lt;..num comp'n..&gt; ) +
           1) ∧
        LOG &lt;..num comp'n..&gt; &lt;..num comp'n..&gt; =
        (if &lt;..num comp'n..&gt; &lt; &lt;..num comp'n..&gt; then 0
         else
           LOG &lt;..num comp'n..&gt; (&lt;..num comp'n..&gt; DIV &lt;..num comp'n..&gt; ) +
           1) ∧
        LOG &lt;..num comp'n..&gt; &lt;..num comp'n..&gt; =
        (if &lt;..num comp'n..&gt; &lt; &lt;..num comp'n..&gt; then 0
         else
           LOG &lt;..num comp'n..&gt; (&lt;..num comp'n..&gt; DIV &lt;..num comp'n..&gt; ) +
           1) ∧
        LOG &lt;..num comp'n..&gt; &lt;..num comp'n..&gt; =
        (if &lt;..num comp'n..&gt; &lt; &lt;..num comp'n..&gt; then 0
         else
           LOG &lt;..num comp'n..&gt; (&lt;..num comp'n..&gt; DIV &lt;..num comp'n..&gt; ) +
           1) ∧
        LOG &lt;..num comp'n..&gt; &lt;..num comp'n..&gt; =
        (if &lt;..num comp'n..&gt; &lt; &lt;..num comp'n..&gt; then 0
         else
           LOG &lt;..num comp'n..&gt; (&lt;..num comp'n..&gt; DIV &lt;..num comp'n..&gt; ) +
           1) ∧
        LOG &lt;..num comp'n..&gt; &lt;..num comp'n..&gt; =
        if &lt;..num comp'n..&gt; &lt; &lt;..num comp'n..&gt; then 0
        else
          LOG &lt;..num comp'n..&gt; (&lt;..num comp'n..&gt; DIV &lt;..num comp'n..&gt; ) + 1
   
   [<a name="LOG_POW-val"><b>LOG_POW</b></a>]  Theorem
      
      ⊢ ∀b n. 1 &lt; b ⇒ LOG b (b ** n) = n
   
   [<a name="LOG_POWER-val"><b>LOG_POWER</b></a>]  Theorem
      
      ⊢ ∀b x n.
          1 &lt; b ∧ 0 &lt; x ∧ 0 &lt; n ⇒
          n * LOG b x ≤ LOG b (x ** n) ∧ LOG b (x ** n) &lt; n * SUC (LOG b x)
   
   [<a name="LOG_ROOT-val"><b>LOG_ROOT</b></a>]  Theorem
      
      ⊢ ∀a x r. 1 &lt; a ∧ 0 &lt; x ∧ 0 &lt; r ⇒ LOG a (ROOT r x) = LOG a x DIV r
   
   [<a name="LOG_RWT-val"><b>LOG_RWT</b></a>]  Theorem
      
      ⊢ ∀m n.
          1 &lt; m ∧ 0 &lt; n ⇒
          LOG m n = if n &lt; m then 0 else SUC (LOG m (n DIV m))
   
   [<a name="LOG_TEST-val"><b>LOG_TEST</b></a>]  Theorem
      
      ⊢ ∀a n.
          1 &lt; a ∧ 0 &lt; n ⇒
          ∀p. LOG a n = p ⇔ SUC n ≤ a ** SUC p ∧ a ** SUC p ≤ a * n
   
   [<a name="LOG_THM-val"><b>LOG_THM</b></a>]  Theorem
      
      ⊢ ∀a n. 1 &lt; a ∧ 0 &lt; n ⇒ ∀p. LOG a n = p ⇔ a ** p ≤ n ∧ n &lt; a ** SUC p
   
   [<a name="LOG_UNIQUE-val"><b>LOG_UNIQUE</b></a>]  Theorem
      
      ⊢ ∀a n p. a ** p ≤ n ∧ n &lt; a ** SUC p ⇒ LOG a n = p
   
   [<a name="LOG_add_digit-val"><b>LOG_add_digit</b></a>]  Theorem
      
      ⊢ ∀b x y. 1 &lt; b ∧ 0 &lt; y ∧ x &lt; b ⇒ LOG b (b * y + x) = SUC (LOG b y)
   
   [<a name="LOG_exists-val"><b>LOG_exists</b></a>]  Theorem
      
      ⊢ ∃f. ∀a n. 1 &lt; a ∧ 0 &lt; n ⇒ a ** f a n ≤ n ∧ n &lt; a ** SUC (f a n)
   
   [<a name="LT_EXP_ISO-val"><b>LT_EXP_ISO</b></a>]  Theorem
      
      ⊢ ∀e a b. 1 &lt; e ⇒ (a &lt; b ⇔ e ** a &lt; e ** b)
   
   [<a name="LT_EXP_LOG-val"><b>LT_EXP_LOG</b></a>]  Theorem
      
      ⊢ x &lt; b ** e ⇔
        b = 0 ∧ e = 0 ∧ x = 0 ∨ b = 1 ∧ x = 0 ∨
        2 ≤ b ∧ (LOG b x &lt; e ∨ x = 0)
   
   [<a name="LT_EXP_LOG_SIMP-val"><b>LT_EXP_LOG_SIMP</b></a>]  Theorem
      
      ⊢ (&lt;..num comp'n..&gt; &lt; &lt;..num comp'n..&gt; ** e ⇔
         2 ≤ &lt;..num comp'n..&gt; ∧ LOG &lt;..num comp'n..&gt; &lt;..num comp'n..&gt; &lt; e) ∧
        (&lt;..num comp'n..&gt; &lt; &lt;..num comp'n..&gt; ** e ⇔
         2 ≤ &lt;..num comp'n..&gt; ∧ LOG &lt;..num comp'n..&gt; &lt;..num comp'n..&gt; &lt; e)
   
   [<a name="LT_SQRT_IMP-val"><b>LT_SQRT_IMP</b></a>]  Theorem
      
      ⊢ ∀n m. n &lt; SQRT m ⇒ n² &lt; m
   
   [<a name="ONE_LE_EXP-val"><b>ONE_LE_EXP</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ⇒ 1 ≤ m ** n
   
   [<a name="ROOT_1-val"><b>ROOT_1</b></a>]  Theorem
      
      ⊢ ∀n. ROOT 1 n = n
   
   [<a name="ROOT_COMPUTE-val"><b>ROOT_COMPUTE</b></a>]  Theorem
      
      ⊢ ∀r n.
          0 &lt; r ⇒
          ROOT r 0 = 0 ∧
          ROOT r n =
          (let
             x = 2 * ROOT r (n DIV 2 ** r)
           in
             if n &lt; SUC x ** r then x else SUC x)
   
   [<a name="ROOT_DIV-val"><b>ROOT_DIV</b></a>]  Theorem
      
      ⊢ ∀r x y. 0 &lt; r ∧ 0 &lt; y ⇒ ROOT r x DIV y = ROOT r (x DIV y ** r)
   
   [<a name="ROOT_EQ_0-val"><b>ROOT_EQ_0</b></a>]  Theorem
      
      ⊢ ∀m. 0 &lt; m ⇒ ∀n. ROOT m n = 0 ⇔ n = 0
   
   [<a name="ROOT_EQ_1-val"><b>ROOT_EQ_1</b></a>]  Theorem
      
      ⊢ ∀m. 0 &lt; m ⇒ ∀n. ROOT m n = 1 ⇔ 0 &lt; n ∧ n &lt; 2 ** m
   
   [<a name="ROOT_EQ_SELF-val"><b>ROOT_EQ_SELF</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ⇒ (ROOT m n = n ⇔ m = 1 ∨ n = 0 ∨ n = 1)
   
   [<a name="ROOT_EVAL-val"><b>ROOT_EVAL</b></a>]  Theorem
      
      ⊢ ∀r n.
          ROOT r n =
          if r = 0 then ROOT 0 n
          else if n = 0 then 0
          else
            (let
               m = 2 * ROOT r (n DIV 2 ** r)
             in
               m + if SUC m ** r ≤ n then 1 else 0)
   
   [<a name="ROOT_EXP-val"><b>ROOT_EXP</b></a>]  Theorem
      
      ⊢ ∀n r. 0 &lt; r ⇒ ROOT r (n ** r) = n
   
   [<a name="ROOT_FROM_POWER-val"><b>ROOT_FROM_POWER</b></a>]  Theorem
      
      ⊢ ∀m n b. 0 &lt; m ∧ b ** m = n ⇒ b = ROOT m n
   
   [<a name="ROOT_GE_SELF-val"><b>ROOT_GE_SELF</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ⇒ (n ≤ ROOT m n ⇔ m = 1 ∨ n = 0 ∨ n = 1)
   
   [<a name="ROOT_LE_MONO-val"><b>ROOT_LE_MONO</b></a>]  Theorem
      
      ⊢ ∀r x y. 0 &lt; r ⇒ x ≤ y ⇒ ROOT r x ≤ ROOT r y
   
   [<a name="ROOT_LE_REVERSE-val"><b>ROOT_LE_REVERSE</b></a>]  Theorem
      
      ⊢ ∀a b n. 0 &lt; a ∧ a ≤ b ⇒ ROOT b n ≤ ROOT a n
   
   [<a name="ROOT_LE_SELF-val"><b>ROOT_LE_SELF</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ⇒ ROOT m n ≤ n
   
   [<a name="ROOT_OF_0-val"><b>ROOT_OF_0</b></a>]  Theorem
      
      ⊢ ∀m. 0 &lt; m ⇒ ROOT m 0 = 0
   
   [<a name="ROOT_OF_1-val"><b>ROOT_OF_1</b></a>]  Theorem
      
      ⊢ ∀m. 0 &lt; m ⇒ ROOT m 1 = 1
   
   [<a name="ROOT_POWER-val"><b>ROOT_POWER</b></a>]  Theorem
      
      ⊢ ∀a n. 1 &lt; a ∧ 0 &lt; n ⇒ ROOT n (a ** n) = a
   
   [<a name="ROOT_SUC-val"><b>ROOT_SUC</b></a>]  Theorem
      
      ⊢ ∀r n.
          0 &lt; r ⇒
          ROOT r (SUC n) =
          ROOT r n + if SUC n = SUC (ROOT r n) ** r then 1 else 0
   
   [<a name="ROOT_THM-val"><b>ROOT_THM</b></a>]  Theorem
      
      ⊢ ∀r. 0 &lt; r ⇒ ∀n p. ROOT r n = p ⇔ p ** r ≤ n ∧ n &lt; SUC p ** r
   
   [<a name="ROOT_UNIQUE-val"><b>ROOT_UNIQUE</b></a>]  Theorem
      
      ⊢ ∀r n p. p ** r ≤ n ∧ n &lt; SUC p ** r ⇒ ROOT r n = p
   
   [<a name="ROOT_exists-val"><b>ROOT_exists</b></a>]  Theorem
      
      ⊢ ∀r n. 0 &lt; r ⇒ ∃rt. rt ** r ≤ n ∧ n &lt; SUC rt ** r
   
   [<a name="SQRT_0-val"><b>SQRT_0</b></a>]  Theorem
      
      ⊢ SQRT 0 = 0
   
   [<a name="SQRT_1-val"><b>SQRT_1</b></a>]  Theorem
      
      ⊢ SQRT 1 = 1
   
   [<a name="SQRT_EQ_0-val"><b>SQRT_EQ_0</b></a>]  Theorem
      
      ⊢ ∀n. SQRT n = 0 ⇔ n = 0
   
   [<a name="SQRT_EQ_1-val"><b>SQRT_EQ_1</b></a>]  Theorem
      
      ⊢ ∀n. SQRT n = 1 ⇔ n = 1 ∨ n = 2 ∨ n = 3
   
   [<a name="SQRT_EQ_SELF-val"><b>SQRT_EQ_SELF</b></a>]  Theorem
      
      ⊢ ∀n. SQRT n = n ⇔ n = 0 ∨ n = 1
   
   [<a name="SQRT_EXP_2-val"><b>SQRT_EXP_2</b></a>]  Theorem
      
      ⊢ ∀n. SQRT n² = n
   
   [<a name="SQRT_GE_SELF-val"><b>SQRT_GE_SELF</b></a>]  Theorem
      
      ⊢ ∀n. n ≤ SQRT n ⇔ n = 0 ∨ n = 1
   
   [<a name="SQRT_LE-val"><b>SQRT_LE</b></a>]  Theorem
      
      ⊢ ∀n m. n ≤ m ⇒ SQRT n ≤ SQRT m
   
   [<a name="SQRT_LT-val"><b>SQRT_LT</b></a>]  Theorem
      
      ⊢ ∀n m. n &lt; m ⇒ SQRT n ≤ SQRT m
   
   [<a name="SQRT_LT_IMP-val"><b>SQRT_LT_IMP</b></a>]  Theorem
      
      ⊢ ∀n m. SQRT n &lt; m ⇒ n &lt; m²
   
   [<a name="SQRT_LT_SQRT-val"><b>SQRT_LT_SQRT</b></a>]  Theorem
      
      ⊢ ∀n m. SQRT n &lt; SQRT m ⇒ n &lt; m
   
   [<a name="SQRT_OF_SQ-val"><b>SQRT_OF_SQ</b></a>]  Theorem
      
      ⊢ ∀n. SQRT n² = n
   
   [<a name="SQRT_PROPERTY-val"><b>SQRT_PROPERTY</b></a>]  Theorem
      
      ⊢ ∀n. (SQRT n)² ≤ n ∧ n &lt; (SUC (SQRT n))²
   
   [<a name="SQRT_THM-val"><b>SQRT_THM</b></a>]  Theorem
      
      ⊢ ∀n p. SQRT n = p ⇔ p² ≤ n ∧ n &lt; (SUC p)²
   
   [<a name="SQRT_UNIQUE-val"><b>SQRT_UNIQUE</b></a>]  Theorem
      
      ⊢ ∀n p. p² ≤ n ∧ n &lt; (SUC p)² ⇒ SQRT n = p
   
   [<a name="TWO_EXP_LOG2_LE-val"><b>TWO_EXP_LOG2_LE</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ 2 ** LOG2 n ≤ n
   
   [<a name="numeral_root2-val"><b>numeral_root2</b></a>]  Theorem
      
      ⊢ SQRT &lt;..num comp'n..&gt; = FST (SQRTd n)
   
   [<a name="numeral_sqrt-val"><b>numeral_sqrt</b></a>]  Theorem
      
      ⊢ SQRTd ZERO = (0,0) ∧ SQRTd &lt;..num comp'n..&gt; = (1,0) ∧
        SQRTd &lt;..num comp'n..&gt; = (1,1) ∧
        SQRTd &lt;..num comp'n..&gt; = iSQRT3 n ∧
        SQRTd &lt;..num comp'n..&gt; = iSQRT0 (SUC n) ∧
        SQRTd &lt;..num comp'n..&gt; = iSQRT1 (SUC n) ∧
        SQRTd &lt;..num comp'n..&gt; = iSQRT2 (SUC n) ∧
        SQRTd (SUC &lt;..num comp'n..&gt; ) = iSQRT0 (SUC n) ∧
        SQRTd (SUC &lt;..num comp'n..&gt; ) = iSQRT1 (SUC n) ∧
        SQRTd (SUC &lt;..num comp'n..&gt; ) = iSQRT2 (SUC n) ∧
        SQRTd (SUC &lt;..num comp'n..&gt; ) = iSQRT3 (SUC n)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/num/extra_theories/logrootScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-2</a></em></p></body></html>
