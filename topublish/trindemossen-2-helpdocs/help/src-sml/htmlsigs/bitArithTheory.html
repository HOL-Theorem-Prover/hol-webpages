<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure bitArithTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure bitArithTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/real/.hol/objs/bitArithScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature bitArithTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#add_def-val">add_def</a> : thm
<a name="line7"></a>    val <a href="#bleval_def_primitive-val">bleval_def_primitive</a> : thm
<a name="line8"></a>    val <a href="#fromBL_def-val">fromBL_def</a> : thm
<a name="line9"></a>    val <a href="#lte_def-val">lte_def</a> : thm
<a name="line10"></a>    val <a href="#sub_def-val">sub_def</a> : thm
<a name="line11"></a>    val <a href="#tobl_def-val">tobl_def</a> : thm
<a name="line12"></a>  
<a name="line13"></a>  (*  Theorems  *)
<a name="line14"></a>    val <a href="#DIV_POW2-val">DIV_POW2</a> : thm
<a name="line15"></a>    val <a href="#EVERYF_bleval0-val">EVERYF_bleval0</a> : thm
<a name="line16"></a>    val <a href="#EVERYF_suffix_bleval-val">EVERYF_suffix_bleval</a> : thm
<a name="line17"></a>    val <a href="#LASTbl_nonzero-val">LASTbl_nonzero</a> : thm
<a name="line18"></a>    val <a href="#add_aux_def-val">add_aux_def</a> : thm
<a name="line19"></a>    val <a href="#add_aux_ind-val">add_aux_ind</a> : thm
<a name="line20"></a>    val <a href="#add_aux_thm-val">add_aux_thm</a> : thm
<a name="line21"></a>    val <a href="#add_thm-val">add_thm</a> : thm
<a name="line22"></a>    val <a href="#bleval_APPEND-val">bleval_APPEND</a> : thm
<a name="line23"></a>    val <a href="#bleval_def-val">bleval_def</a> : thm
<a name="line24"></a>    val <a href="#bleval_ind-val">bleval_ind</a> : thm
<a name="line25"></a>    val <a href="#bleval_less-val">bleval_less</a> : thm
<a name="line26"></a>    val <a href="#bleval_less_large-val">bleval_less_large</a> : thm
<a name="line27"></a>    val <a href="#divpow2_compute-val">divpow2_compute</a> : thm
<a name="line28"></a>    val <a href="#divpow2_def-val">divpow2_def</a> : thm
<a name="line29"></a>    val <a href="#divpow2_ind-val">divpow2_ind</a> : thm
<a name="line30"></a>    val <a href="#divpow2_thm-val">divpow2_thm</a> : thm
<a name="line31"></a>    val <a href="#fromBL_correct-val">fromBL_correct</a> : thm
<a name="line32"></a>    val <a href="#frombl_correct-val">frombl_correct</a> : thm
<a name="line33"></a>    val <a href="#frombl_def-val">frombl_def</a> : thm
<a name="line34"></a>    val <a href="#frombl_ind-val">frombl_ind</a> : thm
<a name="line35"></a>    
<a name="line36"></a>    val <a href="#karatsuba_bit-val">karatsuba_bit</a> : thm
<a name="line37"></a>    val <a href="#karatsuba_num-val">karatsuba_num</a> : thm
<a name="line38"></a>    val <a href="#lte_aux_def-val">lte_aux_def</a> : thm
<a name="line39"></a>    val <a href="#lte_aux_ind-val">lte_aux_ind</a> : thm
<a name="line40"></a>    val <a href="#lte_aux_thm-val">lte_aux_thm</a> : thm
<a name="line41"></a>    val <a href="#lte_thm-val">lte_thm</a> : thm
<a name="line42"></a>    
<a name="line43"></a>    val <a href="#modpow2_compute-val">modpow2_compute</a> : thm
<a name="line44"></a>    val <a href="#modpow2_def-val">modpow2_def</a> : thm
<a name="line45"></a>    val <a href="#modpow2_ind-val">modpow2_ind</a> : thm
<a name="line46"></a>    val <a href="#modpow2_thm-val">modpow2_thm</a> : thm
<a name="line47"></a>    val <a href="#mul_def-val">mul_def</a> : thm
<a name="line48"></a>    
<a name="line49"></a>    val <a href="#mul_ind-val">mul_ind</a> : thm
<a name="line50"></a>    val <a href="#mul_thm-val">mul_thm</a> : thm
<a name="line51"></a>    val <a href="#mulpow2_compute-val">mulpow2_compute</a> : thm
<a name="line52"></a>    val <a href="#mulpow2_def-val">mulpow2_def</a> : thm
<a name="line53"></a>    val <a href="#mulpow2_ind-val">mulpow2_ind</a> : thm
<a name="line54"></a>    val <a href="#mulpow2_thm-val">mulpow2_thm</a> : thm
<a name="line55"></a>    val <a href="#sub_aux_def-val">sub_aux_def</a> : thm
<a name="line56"></a>    val <a href="#sub_aux_ind-val">sub_aux_ind</a> : thm
<a name="line57"></a>    val <a href="#sub_aux_thm-val">sub_aux_thm</a> : thm
<a name="line58"></a>    val <a href="#sub_thm-val">sub_thm</a> : thm
<a name="line59"></a>    val <a href="#tobl0-val">tobl0</a> : thm
<a name="line60"></a>    val <a href="#tobl_NUMERAL-val">tobl_NUMERAL</a> : thm
<a name="line61"></a>    val <a href="#tobl_correct-val">tobl_correct</a> : thm
<a name="line62"></a>    val <a href="#zeroPad_def-val">zeroPad_def</a> : thm
<a name="line63"></a>    val <a href="#zeroPad_ind-val">zeroPad_ind</a> : thm
<a name="line64"></a>    val <a href="#zeroPad_thm-val">zeroPad_thm</a> : thm
<a name="line65"></a>(*
   [real] Parent theory of "bitArith"
   
   [<a name="add_def-val"><b>add_def</b></a>]  Definition
      
      ⊢ ∀bs1 bs2. add bs1 bs2 = add_aux bs1 bs2 F
   
   [<a name="bleval_def_primitive-val"><b>bleval_def_primitive</b></a>]  Definition
      
      ⊢ bleval =
        WFREC
          (@R. WF R ∧ (∀rest. R rest (T::rest)) ∧ ∀rest. R rest (F::rest))
          (λbleval a.
               case a of
                 [] =&gt; I 0
               | T::rest =&gt; I (2 * bleval rest + 1)
               | F::rest =&gt; I (2 * bleval rest))
   
   [<a name="fromBL_def-val"><b>fromBL_def</b></a>]  Definition
      
      ⊢ ∀bs.
          fromBL bs =
          if bs = [] then 0
          else
            (let
               bs1 = REV bs []
             in
               if HD bs1 then NUMERAL (frombl F bs)
               else
                 (let
                    bs2 = dropWhile ($&lt;=&gt; F) bs1;
                    bs3 = REV bs2 []
                  in
                    if bs3 = [] then 0 else NUMERAL (frombl F bs3)))
   
   [<a name="lte_def-val"><b>lte_def</b></a>]  Definition
      
      ⊢ ∀bs1 bs2.
          lte bs1 bs2 ⇔
          (let
             (bs1pad,bs2pad) = zeroPad bs1 bs2
           in
             lte_aux (REV bs1pad []) (REV bs2pad []))
   
   [<a name="sub_def-val"><b>sub_def</b></a>]  Definition
      
      ⊢ ∀bs1 bs2.
          sub bs1 bs2 = if lte bs2 bs1 then sub_aux bs1 bs2 F else []
   
   [<a name="tobl_def-val"><b>tobl_def</b></a>]  Definition
      
      ⊢ (∀b. tobl ZERO b = if b then [] else [T]) ∧
        (∀n x. tobl (BIT1 n) x = x::tobl n x) ∧
        ∀n x. tobl (BIT2 n) x = ¬x::tobl n F
   
   [<a name="DIV_POW2-val"><b>DIV_POW2</b></a>]  Theorem
      
      ⊢ ∀x y. 0 &lt; y ⇒ 2 * x DIV (2 * y) = x DIV y
   
   [<a name="EVERYF_bleval0-val"><b>EVERYF_bleval0</b></a>]  Theorem
      
      ⊢ bleval bs = 0 ⇔ EVERY ($&lt;=&gt; F) bs
   
   [<a name="EVERYF_suffix_bleval-val"><b>EVERYF_suffix_bleval</b></a>]  Theorem
      
      ⊢ EVERY ($&lt;=&gt; F) s ⇒ bleval (p ⧺ s) = bleval p
   
   [<a name="LASTbl_nonzero-val"><b>LASTbl_nonzero</b></a>]  Theorem
      
      ⊢ LAST (x::xs) ⇒ 0 &lt; bleval (x::xs)
   
   [<a name="add_aux_def-val"><b>add_aux_def</b></a>]  Theorem
      
      ⊢ (∀bs. add_aux [] bs F = bs) ∧ add_aux [] [] T = [T] ∧
        (∀bs. add_aux [] (F::bs) T = T::bs) ∧
        (∀bs. add_aux [] (T::bs) T = F::add_aux [] bs T) ∧
        (∀v5 v4. add_aux (v4::v5) [] F = v4::v5) ∧
        (∀bs. add_aux (F::bs) [] T = T::bs) ∧
        (∀bs. add_aux (T::bs) [] T = F::add_aux [] bs T) ∧
        (∀bs2 bs1. add_aux (F::bs1) (F::bs2) T = T::add_aux bs1 bs2 F) ∧
        (∀bs2 bs1. add_aux (F::bs1) (F::bs2) F = F::add_aux bs1 bs2 F) ∧
        (∀bs2 bs1. add_aux (T::bs1) (F::bs2) F = T::add_aux bs1 bs2 F) ∧
        (∀bs2 bs1. add_aux (T::bs1) (F::bs2) T = F::add_aux bs1 bs2 T) ∧
        (∀bs2 bs1. add_aux (F::bs1) (T::bs2) T = F::add_aux bs1 bs2 T) ∧
        (∀bs2 bs1. add_aux (F::bs1) (T::bs2) F = T::add_aux bs1 bs2 F) ∧
        (∀bs2 bs1. add_aux (T::bs1) (T::bs2) T = T::add_aux bs1 bs2 T) ∧
        ∀bs2 bs1. add_aux (T::bs1) (T::bs2) F = F::add_aux bs1 bs2 T
   
   [<a name="add_aux_ind-val"><b>add_aux_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀bs. P [] bs F) ∧ P [] [] T ∧ (∀bs. P [] (F::bs) T) ∧
            (∀bs. P [] bs T ⇒ P [] (T::bs) T) ∧ (∀v4 v5. P (v4::v5) [] F) ∧
            (∀bs. P (F::bs) [] T) ∧ (∀bs. P [] bs T ⇒ P (T::bs) [] T) ∧
            (∀bs1 bs2. P bs1 bs2 F ⇒ P (F::bs1) (F::bs2) T) ∧
            (∀bs1 bs2. P bs1 bs2 F ⇒ P (F::bs1) (F::bs2) F) ∧
            (∀bs1 bs2. P bs1 bs2 F ⇒ P (T::bs1) (F::bs2) F) ∧
            (∀bs1 bs2. P bs1 bs2 T ⇒ P (T::bs1) (F::bs2) T) ∧
            (∀bs1 bs2. P bs1 bs2 T ⇒ P (F::bs1) (T::bs2) T) ∧
            (∀bs1 bs2. P bs1 bs2 F ⇒ P (F::bs1) (T::bs2) F) ∧
            (∀bs1 bs2. P bs1 bs2 T ⇒ P (T::bs1) (T::bs2) T) ∧
            (∀bs1 bs2. P bs1 bs2 T ⇒ P (T::bs1) (T::bs2) F) ⇒
            ∀v v1 v2. P v v1 v2
   
   [<a name="add_aux_thm-val"><b>add_aux_thm</b></a>]  Theorem
      
      ⊢ ∀m n b.
          bleval (add_aux m n b) = bleval m + bleval n + if b then 1 else 0
   
   [<a name="add_thm-val"><b>add_thm</b></a>]  Theorem
      
      ⊢ bleval (add m n) = bleval m + bleval n
   
   [<a name="bleval_APPEND-val"><b>bleval_APPEND</b></a>]  Theorem
      
      ⊢ bleval (xs ⧺ ys) = bleval ys * 2 ** LENGTH xs + bleval xs
   
   [<a name="bleval_def-val"><b>bleval_def</b></a>]  Theorem
      
      ⊢ bleval [] = 0 ∧ (∀rest. bleval (T::rest) = 2 * bleval rest + 1) ∧
        ∀rest. bleval (F::rest) = 2 * bleval rest
   
   [<a name="bleval_ind-val"><b>bleval_ind</b></a>]  Theorem
      
      ⊢ ∀P. P [] ∧ (∀rest. P rest ⇒ P (T::rest)) ∧
            (∀rest. P rest ⇒ P (F::rest)) ⇒
            ∀v. P v
   
   [<a name="bleval_less-val"><b>bleval_less</b></a>]  Theorem
      
      ⊢ ∀bs. bleval bs &lt; 2 ** LENGTH bs
   
   [<a name="bleval_less_large-val"><b>bleval_less_large</b></a>]  Theorem
      
      ⊢ LENGTH bs ≤ k ⇒ bleval bs &lt; 2 ** k
   
   [<a name="divpow2_compute-val"><b>divpow2_compute</b></a>]  Theorem
      
      ⊢ (∀k. divpow2 [] k = []) ∧ (∀v3 v2. divpow2 (v2::v3) 0 = v2::v3) ∧
        (∀k bs b.
           divpow2 (b::bs) (NUMERAL (BIT1 k)) =
           divpow2 bs (NUMERAL (BIT1 k) − 1)) ∧
        ∀k bs b.
          divpow2 (b::bs) (NUMERAL (BIT2 k)) =
          divpow2 bs (NUMERAL (BIT1 k))
   
   [<a name="divpow2_def-val"><b>divpow2_def</b></a>]  Theorem
      
      ⊢ (∀k. divpow2 [] k = []) ∧ (∀v3 v2. divpow2 (v2::v3) 0 = v2::v3) ∧
        ∀k bs b. divpow2 (b::bs) (SUC k) = divpow2 bs k
   
   [<a name="divpow2_ind-val"><b>divpow2_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀k. P [] k) ∧ (∀v2 v3. P (v2::v3) 0) ∧
            (∀b bs k. P bs k ⇒ P (b::bs) (SUC k)) ⇒
            ∀v v1. P v v1
   
   [<a name="divpow2_thm-val"><b>divpow2_thm</b></a>]  Theorem
      
      ⊢ ∀x k. bleval (divpow2 x k) = bleval x DIV 2 ** k
   
   [<a name="fromBL_correct-val"><b>fromBL_correct</b></a>]  Theorem
      
      ⊢ fromBL bs = bleval bs
   
   [<a name="frombl_correct-val"><b>frombl_correct</b></a>]  Theorem
      
      ⊢ bl ≠ [] ∧ LAST bl ⇒
        frombl F bl = bleval bl ∧ frombl T bl = bleval bl − 1
   
   [<a name="frombl_def-val"><b>frombl_def</b></a>]  Theorem
      
      ⊢ (∀addedp. frombl addedp [] = 0) ∧ frombl T [T] = ZERO ∧
        frombl F [T] = BIT1 ZERO ∧
        (∀rest. frombl T (F::rest) = BIT1 (frombl T rest)) ∧
        (∀rest. frombl F (F::rest) = BIT2 (frombl T rest)) ∧
        (∀v5 v4. frombl T (T::v4::v5) = BIT2 (frombl T (v4::v5))) ∧
        ∀v7 v6. frombl F (T::v6::v7) = BIT1 (frombl F (v6::v7))
   
   [<a name="frombl_ind-val"><b>frombl_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀addedp. P addedp []) ∧ P T [T] ∧ P F [T] ∧
            (∀rest. P T rest ⇒ P T (F::rest)) ∧
            (∀rest. P T rest ⇒ P F (F::rest)) ∧
            (∀v4 v5. P T (v4::v5) ⇒ P T (T::v4::v5)) ∧
            (∀v6 v7. P F (v6::v7) ⇒ P F (T::v6::v7)) ⇒
            ∀v v1. P v v1
   
   [<a name="karatsuba_bit-val"><b>karatsuba_bit</b></a>]  Theorem
      
      ⊢ ∀x y.
          bleval (mul x y) =
          bleval
            (let
               d =
                 fromBL
                   (divpow2
                      (add (divpow2 (tobl (LENGTH x) F) 1)
                         (divpow2 (tobl (LENGTH y) F) 1)) 1) + 1;
               x1 = divpow2 x d;
               x0 = modpow2 x d;
               y1 = divpow2 y d;
               y0 = modpow2 y d;
               z0 = mul x0 y0;
               z2 = mul x1 y1;
               z1a = add x1 x0;
               z1b = add y1 y0;
               z1Mul = mul z1a z1b;
               z1 = sub (sub z1Mul z2) z0
             in
               add (mulpow2 (add (mulpow2 z2 d) z1) d) z0)
   
   [<a name="karatsuba_num-val"><b>karatsuba_num</b></a>]  Theorem
      
      ⊢ ∀d x y.
          0 &lt; d ⇒
          x * y =
          (let
             x1 = x DIV d;
             x0 = x MOD d;
             y1 = y DIV d;
             y0 = y MOD d;
             z0 = x0 * y0;
             z2 = x1 * y1;
             z1a = x1 + x0;
             z1b = y1 + y0;
             z1 = z1a * z1b;
             z1 = z1 − z2 − z0
           in
             (z2 * d + z1) * d + z0)
   
   [<a name="lte_aux_def-val"><b>lte_aux_def</b></a>]  Theorem
      
      ⊢ (lte_aux [] [] ⇔ T) ∧ (∀bs2 bs1. lte_aux (F::bs1) (T::bs2) ⇔ T) ∧
        (∀bs2 bs1. lte_aux (T::bs1) (F::bs2) ⇔ F) ∧
        (∀bs2 bs1. lte_aux (T::bs1) (T::bs2) ⇔ lte_aux bs1 bs2) ∧
        (∀bs2 bs1. lte_aux (F::bs1) (F::bs2) ⇔ lte_aux bs1 bs2) ∧
        (∀v8 v7. lte_aux [] (v7::v8) ⇔ F) ∧ ∀v4 v3. lte_aux (v3::v4) [] ⇔ F
   
   [<a name="lte_aux_ind-val"><b>lte_aux_ind</b></a>]  Theorem
      
      ⊢ ∀P. P [] [] ∧ (∀bs1 bs2. P (F::bs1) (T::bs2)) ∧
            (∀bs1 bs2. P (T::bs1) (F::bs2)) ∧
            (∀bs1 bs2. P bs1 bs2 ⇒ P (T::bs1) (T::bs2)) ∧
            (∀bs1 bs2. P bs1 bs2 ⇒ P (F::bs1) (F::bs2)) ∧
            (∀v7 v8. P [] (v7::v8)) ∧ (∀v3 v4. P (v3::v4) []) ⇒
            ∀v v1. P v v1
   
   [<a name="lte_aux_thm-val"><b>lte_aux_thm</b></a>]  Theorem
      
      ⊢ ∀bs1 bs2.
          LENGTH bs1 = LENGTH bs2 ⇒
          (lte_aux bs1 bs2 ⇔ bleval (REVERSE bs1) ≤ bleval (REVERSE bs2))
   
   [<a name="lte_thm-val"><b>lte_thm</b></a>]  Theorem
      
      ⊢ ∀bs1 bs2. lte bs1 bs2 ⇔ bleval bs1 ≤ bleval bs2
   
   [<a name="modpow2_compute-val"><b>modpow2_compute</b></a>]  Theorem
      
      ⊢ (∀k. modpow2 [] k = []) ∧ (∀v3 v2. modpow2 (v2::v3) 0 = []) ∧
        (∀k bs b.
           modpow2 (b::bs) (NUMERAL (BIT1 k)) =
           b::modpow2 bs (NUMERAL (BIT1 k) − 1)) ∧
        ∀k bs b.
          modpow2 (b::bs) (NUMERAL (BIT2 k)) =
          b::modpow2 bs (NUMERAL (BIT1 k))
   
   [<a name="modpow2_def-val"><b>modpow2_def</b></a>]  Theorem
      
      ⊢ (∀k. modpow2 [] k = []) ∧ (∀v3 v2. modpow2 (v2::v3) 0 = []) ∧
        ∀k bs b. modpow2 (b::bs) (SUC k) = b::modpow2 bs k
   
   [<a name="modpow2_ind-val"><b>modpow2_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀k. P [] k) ∧ (∀v2 v3. P (v2::v3) 0) ∧
            (∀b bs k. P bs k ⇒ P (b::bs) (SUC k)) ⇒
            ∀v v1. P v v1
   
   [<a name="modpow2_thm-val"><b>modpow2_thm</b></a>]  Theorem
      
      ⊢ ∀x k. bleval (modpow2 x k) = bleval x MOD 2 ** k
   
   [<a name="mul_def-val"><b>mul_def</b></a>]  Theorem
      
      ⊢ (∀v0. mul [] v0 = []) ∧
        (∀bs2 bs. mul (T::bs) bs2 = add bs2 (mul bs (F::bs2))) ∧
        ∀bs2 bs. mul (F::bs) bs2 = mul bs (F::bs2)
   
   [<a name="mul_ind-val"><b>mul_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀v0. P [] v0) ∧ (∀bs bs2. P bs (F::bs2) ⇒ P (T::bs) bs2) ∧
            (∀bs bs2. P bs (F::bs2) ⇒ P (F::bs) bs2) ⇒
            ∀v v1. P v v1
   
   [<a name="mul_thm-val"><b>mul_thm</b></a>]  Theorem
      
      ⊢ ∀x y. bleval (mul x y) = bleval x * bleval y
   
   [<a name="mulpow2_compute-val"><b>mulpow2_compute</b></a>]  Theorem
      
      ⊢ (∀v0. mulpow2 [] v0 = []) ∧ (∀v3 v2. mulpow2 (v2::v3) 0 = v2::v3) ∧
        (∀v5 v4 k.
           mulpow2 (v4::v5) (NUMERAL (BIT1 k)) =
           F::mulpow2 (v4::v5) (NUMERAL (BIT1 k) − 1)) ∧
        ∀v5 v4 k.
          mulpow2 (v4::v5) (NUMERAL (BIT2 k)) =
          F::mulpow2 (v4::v5) (NUMERAL (BIT1 k))
   
   [<a name="mulpow2_def-val"><b>mulpow2_def</b></a>]  Theorem
      
      ⊢ (∀v0. mulpow2 [] v0 = []) ∧ (∀v3 v2. mulpow2 (v2::v3) 0 = v2::v3) ∧
        ∀v5 v4 k. mulpow2 (v4::v5) (SUC k) = F::mulpow2 (v4::v5) k
   
   [<a name="mulpow2_ind-val"><b>mulpow2_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀v0. P [] v0) ∧ (∀v2 v3. P (v2::v3) 0) ∧
            (∀v4 v5 k. P (v4::v5) k ⇒ P (v4::v5) (SUC k)) ⇒
            ∀v v1. P v v1
   
   [<a name="mulpow2_thm-val"><b>mulpow2_thm</b></a>]  Theorem
      
      ⊢ ∀bs k. bleval (mulpow2 bs k) = bleval bs * 2 ** k
   
   [<a name="sub_aux_def-val"><b>sub_aux_def</b></a>]  Theorem
      
      ⊢ (∀v1 v0. sub_aux [] v0 v1 = []) ∧
        (∀bs1. sub_aux (F::bs1) [] T = T::sub_aux bs1 [] T) ∧
        (∀bs1. sub_aux (T::bs1) [] T = F::bs1) ∧
        (∀bs1. sub_aux (F::bs1) [] F = F::bs1) ∧
        (∀bs1. sub_aux (T::bs1) [] F = T::bs1) ∧
        (∀bs2 bs1. sub_aux (F::bs1) (F::bs2) T = T::sub_aux bs1 bs2 T) ∧
        (∀bs2 bs1. sub_aux (F::bs1) (F::bs2) F = F::sub_aux bs1 bs2 F) ∧
        (∀bs2 bs1. sub_aux (F::bs1) (T::bs2) T = F::sub_aux bs1 bs2 T) ∧
        (∀bs2 bs1. sub_aux (F::bs1) (T::bs2) F = T::sub_aux bs1 bs2 T) ∧
        (∀bs2 bs1. sub_aux (T::bs1) (F::bs2) T = F::sub_aux bs1 bs2 F) ∧
        (∀bs2 bs1. sub_aux (T::bs1) (F::bs2) F = T::sub_aux bs1 bs2 F) ∧
        (∀bs2 bs1. sub_aux (T::bs1) (T::bs2) T = T::sub_aux bs1 bs2 T) ∧
        ∀bs2 bs1. sub_aux (T::bs1) (T::bs2) F = F::sub_aux bs1 bs2 F
   
   [<a name="sub_aux_ind-val"><b>sub_aux_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀v0 v1. P [] v0 v1) ∧ (∀bs1. P bs1 [] T ⇒ P (F::bs1) [] T) ∧
            (∀bs1. P (T::bs1) [] T) ∧ (∀bs1. P (F::bs1) [] F) ∧
            (∀bs1. P (T::bs1) [] F) ∧
            (∀bs1 bs2. P bs1 bs2 T ⇒ P (F::bs1) (F::bs2) T) ∧
            (∀bs1 bs2. P bs1 bs2 F ⇒ P (F::bs1) (F::bs2) F) ∧
            (∀bs1 bs2. P bs1 bs2 T ⇒ P (F::bs1) (T::bs2) T) ∧
            (∀bs1 bs2. P bs1 bs2 T ⇒ P (F::bs1) (T::bs2) F) ∧
            (∀bs1 bs2. P bs1 bs2 F ⇒ P (T::bs1) (F::bs2) T) ∧
            (∀bs1 bs2. P bs1 bs2 F ⇒ P (T::bs1) (F::bs2) F) ∧
            (∀bs1 bs2. P bs1 bs2 T ⇒ P (T::bs1) (T::bs2) T) ∧
            (∀bs1 bs2. P bs1 bs2 F ⇒ P (T::bs1) (T::bs2) F) ⇒
            ∀v v1 v2. P v v1 v2
   
   [<a name="sub_aux_thm-val"><b>sub_aux_thm</b></a>]  Theorem
      
      ⊢ ∀bs1 bs2 b.
          bleval bs2 + (if b then 1 else 0) ≤ bleval bs1 ⇒
          bleval (sub_aux bs1 bs2 b) =
          bleval bs1 − (bleval bs2 + if b then 1 else 0)
   
   [<a name="sub_thm-val"><b>sub_thm</b></a>]  Theorem
      
      ⊢ ∀m n. bleval (sub m n) = bleval m − bleval n
   
   [<a name="tobl0-val"><b>tobl0</b></a>]  Theorem
      
      ⊢ tobl 0 b = tobl ZERO b
   
   [<a name="tobl_NUMERAL-val"><b>tobl_NUMERAL</b></a>]  Theorem
      
      ⊢ tobl (NUMERAL x) = tobl x
   
   [<a name="tobl_correct-val"><b>tobl_correct</b></a>]  Theorem
      
      ⊢ bleval (tobl n T) = n ∧ bleval (tobl n F) = n + 1
   
   [<a name="zeroPad_def-val"><b>zeroPad_def</b></a>]  Theorem
      
      ⊢ zeroPad [] [] = ([],[]) ∧
        (∀bs1 b.
           zeroPad (b::bs1) [] =
           (let (bs1pad,bs2pad) = zeroPad bs1 [] in (b::bs1pad,F::bs2pad))) ∧
        (∀bs2 b.
           zeroPad [] (b::bs2) =
           (let (bs1pad,bs2pad) = zeroPad [] bs2 in (F::bs1pad,b::bs2pad))) ∧
        ∀bs2 bs1 b2 b1.
          zeroPad (b1::bs1) (b2::bs2) =
          (let
             (bs1pad,bs2pad) = zeroPad bs1 bs2
           in
             (b1::bs1pad,b2::bs2pad))
   
   [<a name="zeroPad_ind-val"><b>zeroPad_ind</b></a>]  Theorem
      
      ⊢ ∀P. P [] [] ∧ (∀b bs1. P bs1 [] ⇒ P (b::bs1) []) ∧
            (∀b bs2. P [] bs2 ⇒ P [] (b::bs2)) ∧
            (∀b1 bs1 b2 bs2. P bs1 bs2 ⇒ P (b1::bs1) (b2::bs2)) ⇒
            ∀v v1. P v v1
   
   [<a name="zeroPad_thm-val"><b>zeroPad_thm</b></a>]  Theorem
      
      ⊢ ∀bs1 bs2 bs1pad bs2pad.
          zeroPad bs1 bs2 = (bs1pad,bs2pad) ⇒
          bleval bs1 = bleval bs1pad ∧ bleval bs2 = bleval bs2pad ∧
          LENGTH bs1pad = LENGTH bs2pad
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/real/.hol/objs/bitArithScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-2</a></em></p></body></html>
