<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure ordinalTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure ordinalTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/pred_set/src/more_theories/.hol/objs/ordinalScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature ordinalTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#allOrds_def-val">allOrds_def</a> : thm
<a name="line7"></a>    val <a href="#cardSUC_def-val">cardSUC_def</a> : thm
<a name="line8"></a>    val <a href="#csuc_def-val">csuc_def</a> : thm
<a name="line9"></a>    val <a href="#dclose_def-val">dclose_def</a> : thm
<a name="line10"></a>    val <a href="#downward_closed_def-val">downward_closed_def</a> : thm
<a name="line11"></a>    val <a href="#epsilon0_def-val">epsilon0_def</a> : thm
<a name="line12"></a>    val <a href="#fromNat_def-val">fromNat_def</a> : thm
<a name="line13"></a>    val <a href="#ival_def-val">ival_def</a> : thm
<a name="line14"></a>    val <a href="#oleast_def-val">oleast_def</a> : thm
<a name="line15"></a>    val <a href="#omax_def-val">omax_def</a> : thm
<a name="line16"></a>    val <a href="#omega1_def-val">omega1_def</a> : thm
<a name="line17"></a>    val <a href="#omega_def-val">omega_def</a> : thm
<a name="line18"></a>    val <a href="#ordADD_def-val">ordADD_def</a> : thm
<a name="line19"></a>    val <a href="#ordDIV-val">ordDIV</a> : thm
<a name="line20"></a>    val <a href="#ordDIVMOD-val">ordDIVMOD</a> : thm
<a name="line21"></a>    val <a href="#ordEXP_def-val">ordEXP_def</a> : thm
<a name="line22"></a>    val <a href="#ordMOD-val">ordMOD</a> : thm
<a name="line23"></a>    val <a href="#ordMULT_def-val">ordMULT_def</a> : thm
<a name="line24"></a>    val <a href="#ordSUC_def-val">ordSUC_def</a> : thm
<a name="line25"></a>    val <a href="#ordinal_ABS_def-val">ordinal_ABS_def</a> : thm
<a name="line26"></a>    val <a href="#ordinal_REP_def-val">ordinal_REP_def</a> : thm
<a name="line27"></a>    val <a href="#ordinal_TY_DEF-val">ordinal_TY_DEF</a> : thm
<a name="line28"></a>    val <a href="#ordinal_bijections-val">ordinal_bijections</a> : thm
<a name="line29"></a>    val <a href="#ordlt_def-val">ordlt_def</a> : thm
<a name="line30"></a>    val <a href="#ordlt_top_def-val">ordlt_top_def</a> : thm
<a name="line31"></a>    val <a href="#polyform_def-val">polyform_def</a> : thm
<a name="line32"></a>    val <a href="#preds_def-val">preds_def</a> : thm
<a name="line33"></a>    val <a href="#sup_def-val">sup_def</a> : thm
<a name="line34"></a>  
<a name="line35"></a>  (*  Theorems  *)
<a name="line36"></a>    val <a href="#ADD1R-val">ADD1R</a> : thm
<a name="line37"></a>    val <a href="#CARD_FINITE_preds-val">CARD_FINITE_preds</a> : thm
<a name="line38"></a>    val <a href="#CNF_nat-val">CNF_nat</a> : thm
<a name="line39"></a>    val <a href="#CNF_thm-val">CNF_thm</a> : thm
<a name="line40"></a>    val <a href="#FINITE_cardSUC-val">FINITE_cardSUC</a> : thm
<a name="line41"></a>    val <a href="#FINITE_omax_IS_SOME-val">FINITE_omax_IS_SOME</a> : thm
<a name="line42"></a>    val <a href="#FINITE_preds-val">FINITE_preds</a> : thm
<a name="line43"></a>    val <a href="#IFF_ZERO_lt-val">IFF_ZERO_lt</a> : thm
<a name="line44"></a>    val <a href="#IMAGE_EQ_SING-val">IMAGE_EQ_SING</a> : thm
<a name="line45"></a>    val <a href="#INFINITE_eqpreds-val">INFINITE_eqpreds</a> : thm
<a name="line46"></a>    val <a href="#IN_preds-val">IN_preds</a> : thm
<a name="line47"></a>    val <a href="#ORD_ONE-val">ORD_ONE</a> : thm
<a name="line48"></a>    val <a href="#Unum_cardle_ucinf-val">Unum_cardle_ucinf</a> : thm
<a name="line49"></a>    val <a href="#Unum_cardlt_ucinf-val">Unum_cardlt_ucinf</a> : thm
<a name="line50"></a>    val <a href="#Unum_cle_Uinf-val">Unum_cle_Uinf</a> : thm
<a name="line51"></a>    val <a href="#WIN_allOrds-val">WIN_allOrds</a> : thm
<a name="line52"></a>    val <a href="#ZERO_LT_csuc-val">ZERO_LT_csuc</a> : thm
<a name="line53"></a>    val <a href="#ZERO_lt_ordEXP-val">ZERO_lt_ordEXP</a> : thm
<a name="line54"></a>    val <a href="#ZERO_lt_ordEXP_I-val">ZERO_lt_ordEXP_I</a> : thm
<a name="line55"></a>    val <a href="#addL_fixpoint_iff-val">addL_fixpoint_iff</a> : thm
<a name="line56"></a>    val <a href="#add_nat_islimit-val">add_nat_islimit</a> : thm
<a name="line57"></a>    val <a href="#add_omega_islimit-val">add_omega_islimit</a> : thm
<a name="line58"></a>    val <a href="#bumpUNIV_cardlt-val">bumpUNIV_cardlt</a> : thm
<a name="line59"></a>    val <a href="#cardSUC_EQ0-val">cardSUC_EQ0</a> : thm
<a name="line60"></a>    val <a href="#cardeq_ordinals_exist-val">cardeq_ordinals_exist</a> : thm
<a name="line61"></a>    val <a href="#cardinality_bump_exists-val">cardinality_bump_exists</a> : thm
<a name="line62"></a>    val <a href="#cardle_preds_EQ_cardeq_preds-val">cardle_preds_EQ_cardeq_preds</a> : thm
<a name="line63"></a>    val <a href="#cardleq_preds_csuc-val">cardleq_preds_csuc</a> : thm
<a name="line64"></a>    val <a href="#cardlt_eqpreds-val">cardlt_eqpreds</a> : thm
<a name="line65"></a>    val <a href="#cardlt_lepreds-val">cardlt_lepreds</a> : thm
<a name="line66"></a>    val <a href="#cardlt_preds-val">cardlt_preds</a> : thm
<a name="line67"></a>    val <a href="#closed_sing-val">closed_sing</a> : thm
<a name="line68"></a>    val <a href="#cord_countable_preds-val">cord_countable_preds</a> : thm
<a name="line69"></a>    val <a href="#countableOrds_dclosed-val">countableOrds_dclosed</a> : thm
<a name="line70"></a>    val <a href="#countableOrds_uncountable-val">countableOrds_uncountable</a> : thm
<a name="line71"></a>    val <a href="#csuc_EQ_N-val">csuc_EQ_N</a> : thm
<a name="line72"></a>    val <a href="#csuc_is_nonzero_limit-val">csuc_is_nonzero_limit</a> : thm
<a name="line73"></a>    val <a href="#csuc_nat-val">csuc_nat</a> : thm
<a name="line74"></a>    val <a href="#csuc_omega-val">csuc_omega</a> : thm
<a name="line75"></a>    val <a href="#csup_lesup-val">csup_lesup</a> : thm
<a name="line76"></a>    val <a href="#csup_suple-val">csup_suple</a> : thm
<a name="line77"></a>    val <a href="#csup_thm-val">csup_thm</a> : thm
<a name="line78"></a>    val <a href="#cx_lt_x-val">cx_lt_x</a> : thm
<a name="line79"></a>    val <a href="#dclose_BIGUNION-val">dclose_BIGUNION</a> : thm
<a name="line80"></a>    val <a href="#dclose_cardleq_univinf-val">dclose_cardleq_univinf</a> : thm
<a name="line81"></a>    val <a href="#elsOf_allOrds-val">elsOf_allOrds</a> : thm
<a name="line82"></a>    val <a href="#epsilon0_fixpoint-val">epsilon0_fixpoint</a> : thm
<a name="line83"></a>    val <a href="#epsilon0_least_fixpoint-val">epsilon0_least_fixpoint</a> : thm
<a name="line84"></a>    val <a href="#eval_poly_def-val">eval_poly_def</a> : thm
<a name="line85"></a>    val <a href="#eval_poly_ind-val">eval_poly_ind</a> : thm
<a name="line86"></a>    val <a href="#expbound_add-val">expbound_add</a> : thm
<a name="line87"></a>    val <a href="#fixpoints_exist-val">fixpoints_exist</a> : thm
<a name="line88"></a>    val <a href="#fromNat_11-val">fromNat_11</a> : thm
<a name="line89"></a>    val <a href="#fromNat_SUC-val">fromNat_SUC</a> : thm
<a name="line90"></a>    val <a href="#fromNat_compute-val">fromNat_compute</a> : thm
<a name="line91"></a>    val <a href="#fromNat_eq_omega-val">fromNat_eq_omega</a> : thm
<a name="line92"></a>    val <a href="#fromNat_lt_epsilon0-val">fromNat_lt_epsilon0</a> : thm
<a name="line93"></a>    val <a href="#fromNat_lt_omega-val">fromNat_lt_omega</a> : thm
<a name="line94"></a>    val <a href="#fromNat_ordlt-val">fromNat_ordlt</a> : thm
<a name="line95"></a>    val <a href="#generic_continuity-val">generic_continuity</a> : thm
<a name="line96"></a>    val <a href="#is_polyform_CONS_E-val">is_polyform_CONS_E</a> : thm
<a name="line97"></a>    val <a href="#is_polyform_ELthm-val">is_polyform_ELthm</a> : thm
<a name="line98"></a>    val <a href="#is_polyform_def-val">is_polyform_def</a> : thm
<a name="line99"></a>    val <a href="#is_polyform_head_dominates_tail-val">is_polyform_head_dominates_tail</a> : thm
<a name="line100"></a>    val <a href="#is_polyform_ind-val">is_polyform_ind</a> : thm
<a name="line101"></a>    val <a href="#islimit_0-val">islimit_0</a> : thm
<a name="line102"></a>    val <a href="#islimit_SUC-val">islimit_SUC</a> : thm
<a name="line103"></a>    val <a href="#islimit_SUC_lt-val">islimit_SUC_lt</a> : thm
<a name="line104"></a>    val <a href="#islimit_fromNat-val">islimit_fromNat</a> : thm
<a name="line105"></a>    val <a href="#islimit_mul_R-val">islimit_mul_R</a> : thm
<a name="line106"></a>    val <a href="#le_cardSUC-val">le_cardSUC</a> : thm
<a name="line107"></a>    val <a href="#leqLEFT_CANCEL-val">leqLEFT_CANCEL</a> : thm
<a name="line108"></a>    val <a href="#limpt_islimit-val">limpt_islimit</a> : thm
<a name="line109"></a>    val <a href="#lt_cardSUC-val">lt_cardSUC</a> : thm
<a name="line110"></a>    val <a href="#lt_csuc-val">lt_csuc</a> : thm
<a name="line111"></a>    val <a href="#lt_omega-val">lt_omega</a> : thm
<a name="line112"></a>    val <a href="#lt_suppreds-val">lt_suppreds</a> : thm
<a name="line113"></a>    val <a href="#mul_omega_islimit-val">mul_omega_islimit</a> : thm
<a name="line114"></a>    val <a href="#no_maximal_ordinal-val">no_maximal_ordinal</a> : thm
<a name="line115"></a>    val <a href="#oleast_intro-val">oleast_intro</a> : thm
<a name="line116"></a>    val <a href="#olog_correct-val">olog_correct</a> : thm
<a name="line117"></a>    val <a href="#omax_EMPTY-val">omax_EMPTY</a> : thm
<a name="line118"></a>    val <a href="#omax_INSERT-val">omax_INSERT</a> : thm
<a name="line119"></a>    val <a href="#omax_NONE-val">omax_NONE</a> : thm
<a name="line120"></a>    val <a href="#omax_SOME-val">omax_SOME</a> : thm
<a name="line121"></a>    val <a href="#omax_preds_SUC-val">omax_preds_SUC</a> : thm
<a name="line122"></a>    val <a href="#omax_preds_omega-val">omax_preds_omega</a> : thm
<a name="line123"></a>    val <a href="#omax_sup-val">omax_sup</a> : thm
<a name="line124"></a>    val <a href="#omega1_not_countable-val">omega1_not_countable</a> : thm
<a name="line125"></a>    val <a href="#omega_LEQ_INFINITE_preds-val">omega_LEQ_INFINITE_preds</a> : thm
<a name="line126"></a>    val <a href="#omega_MUL_fromNat-val">omega_MUL_fromNat</a> : thm
<a name="line127"></a>    val <a href="#omega_exp_islimit-val">omega_exp_islimit</a> : thm
<a name="line128"></a>    val <a href="#omega_islimit-val">omega_islimit</a> : thm
<a name="line129"></a>    val <a href="#omega_lt_epsilon0-val">omega_lt_epsilon0</a> : thm
<a name="line130"></a>    val <a href="#open_in_ordlt-val">open_in_ordlt</a> : thm
<a name="line131"></a>    val <a href="#open_sing_nonlimit-val">open_sing_nonlimit</a> : thm
<a name="line132"></a>    val <a href="#ordADD_0L-val">ordADD_0L</a> : thm
<a name="line133"></a>    val <a href="#ordADD_ASSOC-val">ordADD_ASSOC</a> : thm
<a name="line134"></a>    val <a href="#ordADD_CANCEL1-val">ordADD_CANCEL1</a> : thm
<a name="line135"></a>    val <a href="#ordADD_EQ_0-val">ordADD_EQ_0</a> : thm
<a name="line136"></a>    val <a href="#ordADD_MONO-val">ordADD_MONO</a> : thm
<a name="line137"></a>    val <a href="#ordADD_RIGHT_CANCEL-val">ordADD_RIGHT_CANCEL</a> : thm
<a name="line138"></a>    val <a href="#ordADD_continuous-val">ordADD_continuous</a> : thm
<a name="line139"></a>    val <a href="#ordADD_fromNat-val">ordADD_fromNat</a> : thm
<a name="line140"></a>    val <a href="#ordADD_fromNat_omega-val">ordADD_fromNat_omega</a> : thm
<a name="line141"></a>    val <a href="#ordADD_le_MONO_L-val">ordADD_le_MONO_L</a> : thm
<a name="line142"></a>    val <a href="#ordADD_under_epsilon0-val">ordADD_under_epsilon0</a> : thm
<a name="line143"></a>    val <a href="#ordADD_weak_MONO-val">ordADD_weak_MONO</a> : thm
<a name="line144"></a>    val <a href="#ordDIVISION-val">ordDIVISION</a> : thm
<a name="line145"></a>    val <a href="#ordDIV_UNIQUE-val">ordDIV_UNIQUE</a> : thm
<a name="line146"></a>    val <a href="#ordEXP_1L-val">ordEXP_1L</a> : thm
<a name="line147"></a>    val <a href="#ordEXP_1R-val">ordEXP_1R</a> : thm
<a name="line148"></a>    val <a href="#ordEXP_2R-val">ordEXP_2R</a> : thm
<a name="line149"></a>    val <a href="#ordEXP_ADD-val">ordEXP_ADD</a> : thm
<a name="line150"></a>    val <a href="#ordEXP_EQ_0-val">ordEXP_EQ_0</a> : thm
<a name="line151"></a>    val <a href="#ordEXP_MUL-val">ordEXP_MUL</a> : thm
<a name="line152"></a>    val <a href="#ordEXP_ZERO_limit-val">ordEXP_ZERO_limit</a> : thm
<a name="line153"></a>    val <a href="#ordEXP_ZERO_nonlimit-val">ordEXP_ZERO_nonlimit</a> : thm
<a name="line154"></a>    val <a href="#ordEXP_continuous-val">ordEXP_continuous</a> : thm
<a name="line155"></a>    val <a href="#ordEXP_fromNat-val">ordEXP_fromNat</a> : thm
<a name="line156"></a>    val <a href="#ordEXP_le_MONO_L-val">ordEXP_le_MONO_L</a> : thm
<a name="line157"></a>    val <a href="#ordEXP_le_MONO_R-val">ordEXP_le_MONO_R</a> : thm
<a name="line158"></a>    val <a href="#ordEXP_lt_IFF-val">ordEXP_lt_IFF</a> : thm
<a name="line159"></a>    val <a href="#ordEXP_lt_MONO_R-val">ordEXP_lt_MONO_R</a> : thm
<a name="line160"></a>    val <a href="#ordEXP_under_epsilon0-val">ordEXP_under_epsilon0</a> : thm
<a name="line161"></a>    val <a href="#ordLOG_correct-val">ordLOG_correct</a> : thm
<a name="line162"></a>    val <a href="#ordMOD_UNIQUE-val">ordMOD_UNIQUE</a> : thm
<a name="line163"></a>    val <a href="#ordMULT_0L-val">ordMULT_0L</a> : thm
<a name="line164"></a>    val <a href="#ordMULT_0R-val">ordMULT_0R</a> : thm
<a name="line165"></a>    val <a href="#ordMULT_1L-val">ordMULT_1L</a> : thm
<a name="line166"></a>    val <a href="#ordMULT_1R-val">ordMULT_1R</a> : thm
<a name="line167"></a>    val <a href="#ordMULT_2R-val">ordMULT_2R</a> : thm
<a name="line168"></a>    val <a href="#ordMULT_ASSOC-val">ordMULT_ASSOC</a> : thm
<a name="line169"></a>    val <a href="#ordMULT_CANCEL_R-val">ordMULT_CANCEL_R</a> : thm
<a name="line170"></a>    val <a href="#ordMULT_EQ_0-val">ordMULT_EQ_0</a> : thm
<a name="line171"></a>    val <a href="#ordMULT_LDISTRIB-val">ordMULT_LDISTRIB</a> : thm
<a name="line172"></a>    val <a href="#ordMULT_continuous-val">ordMULT_continuous</a> : thm
<a name="line173"></a>    val <a href="#ordMULT_fromNat-val">ordMULT_fromNat</a> : thm
<a name="line174"></a>    val <a href="#ordMULT_le_MONO_L-val">ordMULT_le_MONO_L</a> : thm
<a name="line175"></a>    val <a href="#ordMULT_le_MONO_R-val">ordMULT_le_MONO_R</a> : thm
<a name="line176"></a>    val <a href="#ordMULT_lt_MONO_R-val">ordMULT_lt_MONO_R</a> : thm
<a name="line177"></a>    val <a href="#ordMULT_lt_MONO_R_EQN-val">ordMULT_lt_MONO_R_EQN</a> : thm
<a name="line178"></a>    val <a href="#ordMUL_under_epsilon0-val">ordMUL_under_epsilon0</a> : thm
<a name="line179"></a>    val <a href="#ordSUC_11-val">ordSUC_11</a> : thm
<a name="line180"></a>    val <a href="#ordSUC_MONO-val">ordSUC_MONO</a> : thm
<a name="line181"></a>    val <a href="#ordSUC_NUMERAL-val">ordSUC_NUMERAL</a> : thm
<a name="line182"></a>    val <a href="#ordSUC_ZERO-val">ordSUC_ZERO</a> : thm
<a name="line183"></a>    val <a href="#ordZERO_ltSUC-val">ordZERO_ltSUC</a> : thm
<a name="line184"></a>    val <a href="#ord_CASES-val">ord_CASES</a> : thm
<a name="line185"></a>    val <a href="#ord_RECURSION-val">ord_RECURSION</a> : thm
<a name="line186"></a>    val <a href="#ord_induction-val">ord_induction</a> : thm
<a name="line187"></a>    val <a href="#order_topology_exists-val">order_topology_exists</a> : thm
<a name="line188"></a>    val <a href="#orderiso_cardeq_elsOf-val">orderiso_cardeq_elsOf</a> : thm
<a name="line189"></a>    val <a href="#orderiso_wobound2-val">orderiso_wobound2</a> : thm
<a name="line190"></a>    val <a href="#orderlt_iso_REFL-val">orderlt_iso_REFL</a> : thm
<a name="line191"></a>    val <a href="#ordinal_ABS_REP_CLASS-val">ordinal_ABS_REP_CLASS</a> : thm
<a name="line192"></a>    val <a href="#ordinal_IVT-val">ordinal_IVT</a> : thm
<a name="line193"></a>    val <a href="#ordinal_QUOTIENT-val">ordinal_QUOTIENT</a> : thm
<a name="line194"></a>    val <a href="#ordle_ANTISYM-val">ordle_ANTISYM</a> : thm
<a name="line195"></a>    val <a href="#ordle_CANCEL_ADDR-val">ordle_CANCEL_ADDR</a> : thm
<a name="line196"></a>    val <a href="#ordle_EXISTS_ADD-val">ordle_EXISTS_ADD</a> : thm
<a name="line197"></a>    val <a href="#ordle_TRANS-val">ordle_TRANS</a> : thm
<a name="line198"></a>    val <a href="#ordle_lteq-val">ordle_lteq</a> : thm
<a name="line199"></a>    val <a href="#ordleq0-val">ordleq0</a> : thm
<a name="line200"></a>    val <a href="#ordlet_TRANS-val">ordlet_TRANS</a> : thm
<a name="line201"></a>    val <a href="#ordlt_CANCEL-val">ordlt_CANCEL</a> : thm
<a name="line202"></a>    val <a href="#ordlt_CANCEL_ADDL-val">ordlt_CANCEL_ADDL</a> : thm
<a name="line203"></a>    val <a href="#ordlt_CANCEL_ADDR-val">ordlt_CANCEL_ADDR</a> : thm
<a name="line204"></a>    val <a href="#ordlt_DISCRETE1-val">ordlt_DISCRETE1</a> : thm
<a name="line205"></a>    val <a href="#ordlt_EXISTS_ADD-val">ordlt_EXISTS_ADD</a> : thm
<a name="line206"></a>    val <a href="#ordlt_REFL-val">ordlt_REFL</a> : thm
<a name="line207"></a>    val <a href="#ordlt_SUC-val">ordlt_SUC</a> : thm
<a name="line208"></a>    val <a href="#ordlt_SUC_DISCRETE-val">ordlt_SUC_DISCRETE</a> : thm
<a name="line209"></a>    val <a href="#ordlt_TRANS-val">ordlt_TRANS</a> : thm
<a name="line210"></a>    val <a href="#ordlt_WF-val">ordlt_WF</a> : thm
<a name="line211"></a>    val <a href="#ordlt_ZERO-val">ordlt_ZERO</a> : thm
<a name="line212"></a>    val <a href="#ordlt_fromNat-val">ordlt_fromNat</a> : thm
<a name="line213"></a>    val <a href="#ordlt_mkOrdinal-val">ordlt_mkOrdinal</a> : thm
<a name="line214"></a>    val <a href="#ordlt_preds_mono-val">ordlt_preds_mono</a> : thm
<a name="line215"></a>    val <a href="#ordlt_trichotomy-val">ordlt_trichotomy</a> : thm
<a name="line216"></a>    val <a href="#ordlte_TRANS-val">ordlte_TRANS</a> : thm
<a name="line217"></a>    val <a href="#polyform_0-val">polyform_0</a> : thm
<a name="line218"></a>    val <a href="#polyform_EQ_NIL-val">polyform_EQ_NIL</a> : thm
<a name="line219"></a>    val <a href="#polyform_UNIQUE-val">polyform_UNIQUE</a> : thm
<a name="line220"></a>    val <a href="#polyform_eval_poly-val">polyform_eval_poly</a> : thm
<a name="line221"></a>    val <a href="#polyform_exists-val">polyform_exists</a> : thm
<a name="line222"></a>    val <a href="#predimage_sup_thm-val">predimage_sup_thm</a> : thm
<a name="line223"></a>    val <a href="#predimage_suplt_ELIM-val">predimage_suplt_ELIM</a> : thm
<a name="line224"></a>    val <a href="#preds_0-val">preds_0</a> : thm
<a name="line225"></a>    val <a href="#preds_11-val">preds_11</a> : thm
<a name="line226"></a>    val <a href="#preds_EQ_EMPTY-val">preds_EQ_EMPTY</a> : thm
<a name="line227"></a>    val <a href="#preds_bij-val">preds_bij</a> : thm
<a name="line228"></a>    val <a href="#preds_downward_closed-val">preds_downward_closed</a> : thm
<a name="line229"></a>    val <a href="#preds_inj_univ-val">preds_inj_univ</a> : thm
<a name="line230"></a>    val <a href="#preds_lesup-val">preds_lesup</a> : thm
<a name="line231"></a>    val <a href="#preds_lt_PSUBSET-val">preds_lt_PSUBSET</a> : thm
<a name="line232"></a>    val <a href="#preds_nat-val">preds_nat</a> : thm
<a name="line233"></a>    val <a href="#preds_omax_SOME_SUC-val">preds_omax_SOME_SUC</a> : thm
<a name="line234"></a>    val <a href="#preds_omega_UNIV-val">preds_omega_UNIV</a> : thm
<a name="line235"></a>    val <a href="#preds_omega_lt_preds_omega1-val">preds_omega_lt_preds_omega1</a> : thm
<a name="line236"></a>    val <a href="#preds_ordSUC-val">preds_ordSUC</a> : thm
<a name="line237"></a>    val <a href="#preds_sup-val">preds_sup</a> : thm
<a name="line238"></a>    val <a href="#preds_sup_thm-val">preds_sup_thm</a> : thm
<a name="line239"></a>    val <a href="#preds_suple-val">preds_suple</a> : thm
<a name="line240"></a>    val <a href="#preds_surj-val">preds_surj</a> : thm
<a name="line241"></a>    val <a href="#preds_wobound-val">preds_wobound</a> : thm
<a name="line242"></a>    val <a href="#rays_open-val">rays_open</a> : thm
<a name="line243"></a>    val <a href="#simple_ord_induction-val">simple_ord_induction</a> : thm
<a name="line244"></a>    val <a href="#strict_continuity_preserves_islimit-val">strict_continuity_preserves_islimit</a> : thm
<a name="line245"></a>    val <a href="#sup_EMPTY-val">sup_EMPTY</a> : thm
<a name="line246"></a>    val <a href="#sup_EQ_0-val">sup_EQ_0</a> : thm
<a name="line247"></a>    val <a href="#sup_SING-val">sup_SING</a> : thm
<a name="line248"></a>    val <a href="#sup_eq_SUC-val">sup_eq_SUC</a> : thm
<a name="line249"></a>    val <a href="#sup_eq_max-val">sup_eq_max</a> : thm
<a name="line250"></a>    val <a href="#sup_eq_sup-val">sup_eq_sup</a> : thm
<a name="line251"></a>    val <a href="#sup_lt_implies-val">sup_lt_implies</a> : thm
<a name="line252"></a>    val <a href="#sup_preds_SUC-val">sup_preds_SUC</a> : thm
<a name="line253"></a>    val <a href="#sup_preds_omax_NONE-val">sup_preds_omax_NONE</a> : thm
<a name="line254"></a>    val <a href="#sup_thm-val">sup_thm</a> : thm
<a name="line255"></a>    val <a href="#suple_thm-val">suple_thm</a> : thm
<a name="line256"></a>    val <a href="#suppred_suplt_ELIM-val">suppred_suplt_ELIM</a> : thm
<a name="line257"></a>    val <a href="#topspace_ordlt_top-val">topspace_ordlt_top</a> : thm
<a name="line258"></a>    val <a href="#transfer_ordinals-val">transfer_ordinals</a> : thm
<a name="line259"></a>    val <a href="#ubsup_thm-val">ubsup_thm</a> : thm
<a name="line260"></a>    val <a href="#ucinf_uncountable-val">ucinf_uncountable</a> : thm
<a name="line261"></a>    val <a href="#ucord_sup_exists_lemma-val">ucord_sup_exists_lemma</a> : thm
<a name="line262"></a>    val <a href="#unitinf_univnum-val">unitinf_univnum</a> : thm
<a name="line263"></a>    val <a href="#univ_cord_uncountable-val">univ_cord_uncountable</a> : thm
<a name="line264"></a>    val <a href="#univ_ord_greater_cardinal-val">univ_ord_greater_cardinal</a> : thm
<a name="line265"></a>    val <a href="#wellorder_allOrds-val">wellorder_allOrds</a> : thm
<a name="line266"></a>    val <a href="#wellorder_ordinal_isomorphism-val">wellorder_ordinal_isomorphism</a> : thm
<a name="line267"></a>    val <a href="#x_le_ordEXP_x-val">x_le_ordEXP_x</a> : thm
<a name="line268"></a>    val <a href="#x_lt_omega1_countable-val">x_lt_omega1_countable</a> : thm
<a name="line269"></a>(*
   [topology] Parent theory of "ordinal"
   
   [<a name="allOrds_def-val"><b>allOrds_def</b></a>]  Definition
      
      ⊢ allOrds = mkWO {(x,y) | x = y ∨ x &lt; y}
   
   [<a name="cardSUC_def-val"><b>cardSUC_def</b></a>]  Definition
      
      ⊢ ∀s. cardSUC s = preds (csuc (oleast a. preds a ≈ s))
   
   [<a name="csuc_def-val"><b>csuc_def</b></a>]  Definition
      
      ⊢ ∀a. csuc a = oleast b. preds a ≺ preds b
   
   [<a name="dclose_def-val"><b>dclose_def</b></a>]  Definition
      
      ⊢ ∀s. dclose s = {x | ∃y. y ∈ s ∧ x &lt; y}
   
   [<a name="downward_closed_def-val"><b>downward_closed_def</b></a>]  Definition
      
      ⊢ ∀s. downward_closed s ⇔ ∀a b. a ∈ s ∧ b &lt; a ⇒ b ∈ s
   
   [<a name="epsilon0_def-val"><b>epsilon0_def</b></a>]  Definition
      
      ⊢ ε₀ = oleast x. ω ** x = x
   
   [<a name="fromNat_def-val"><b>fromNat_def</b></a>]  Definition
      
      ⊢ 0 = (oleast a. T) ∧ ∀n. &SUC n = (&n)⁺
   
   [<a name="ival_def-val"><b>ival_def</b></a>]  Definition
      
      ⊢ ∀a b. ival a b = {e | a &lt; e ∧ e &lt; b}
   
   [<a name="oleast_def-val"><b>oleast_def</b></a>]  Definition
      
      ⊢ ∀P. $oleast P = @x. P x ∧ ∀y. y &lt; x ⇒ ¬P y
   
   [<a name="omax_def-val"><b>omax_def</b></a>]  Definition
      
      ⊢ ∀s. omax s = some a. maximal_elements s {(x,y) | x ≤ y} = {a}
   
   [<a name="omega1_def-val"><b>omega1_def</b></a>]  Definition
      
      ⊢ ω₁ = sup {a | countableOrd a}
   
   [<a name="omega_def-val"><b>omega_def</b></a>]  Definition
      
      ⊢ ω = sup {(&i) | T}
   
   [<a name="ordADD_def-val"><b>ordADD_def</b></a>]  Definition
      
      ⊢ ∀b. b + 0 = b ∧ (∀a. b + a⁺ = (b + a)⁺) ∧
            ∀a. 0 &lt; a ∧ islimit a ⇒ b + a = sup (IMAGE ($+ b) (preds a))
   
   [<a name="ordDIV-val"><b>ordDIV</b></a>]  Definition
      
      ⊢ ∀a b. a / b = FST (ordDIVMOD a b)
   
   [<a name="ordDIVMOD-val"><b>ordDIVMOD</b></a>]  Definition
      
      ⊢ ∀a b.
          0 &lt; b ⇒
          a = b * FST (ordDIVMOD a b) + SND (ordDIVMOD a b) ∧
          SND (ordDIVMOD a b) &lt; b
   
   [<a name="ordEXP_def-val"><b>ordEXP_def</b></a>]  Definition
      
      ⊢ (∀a. a ** 0 = 1) ∧ (∀a a'. a ** a'⁺ = a ** a' * a) ∧
        ∀a a'.
          0 &lt; a' ∧ islimit a' ⇒ a ** a' = sup (IMAGE ($** a) (preds a'))
   
   [<a name="ordMOD-val"><b>ordMOD</b></a>]  Definition
      
      ⊢ ∀a b. a % b = SND (ordDIVMOD a b)
   
   [<a name="ordMULT_def-val"><b>ordMULT_def</b></a>]  Definition
      
      ⊢ ∀b. b * 0 = 0 ∧ (∀a. b * a⁺ = b * a + b) ∧
            ∀a. 0 &lt; a ∧ islimit a ⇒ b * a = sup (IMAGE ($* b) (preds a))
   
   [<a name="ordSUC_def-val"><b>ordSUC_def</b></a>]  Definition
      
      ⊢ ∀a. a⁺ = oleast b. a &lt; b
   
   [<a name="ordinal_ABS_def-val"><b>ordinal_ABS_def</b></a>]  Definition
      
      ⊢ ∀r. mkOrdinal r = ordinal_ABS_CLASS (orderiso r)
   
   [<a name="ordinal_REP_def-val"><b>ordinal_REP_def</b></a>]  Definition
      
      ⊢ ∀a. ordinal_REP a = $@ (ordinal_REP_CLASS a)
   
   [<a name="ordinal_TY_DEF-val"><b>ordinal_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep. TYPE_DEFINITION (λc. ∃r. orderiso r r ∧ c = orderiso r) rep
   
   [<a name="ordinal_bijections-val"><b>ordinal_bijections</b></a>]  Definition
      
      ⊢ (∀a. ordinal_ABS_CLASS (ordinal_REP_CLASS a) = a) ∧
        ∀r. (λc. ∃r. orderiso r r ∧ c = orderiso r) r ⇔
            ordinal_REP_CLASS (ordinal_ABS_CLASS r) = r
   
   [<a name="ordlt_def-val"><b>ordlt_def</b></a>]  Definition
      
      ⊢ ∀T1 T2. T1 &lt; T2 ⇔ orderlt (ordinal_REP T1) (ordinal_REP T2)
   
   [<a name="ordlt_top_def-val"><b>ordlt_top_def</b></a>]  Definition
      
      ⊢ ordlt_top =
        topology
          {s |
           (∀e. e ∈ s ⇒
                (∃a b. e ∈ ival a b ∧ ival a b ⊆ s) ∨
                ∃b. e &lt; b ∧ ∀d. d &lt; b ⇒ d ∈ s)}
   
   [<a name="polyform_def-val"><b>polyform_def</b></a>]  Definition
      
      ⊢ ∀a b.
          1 &lt; a ⇒
          is_polyform a (polyform a b) ∧ b = eval_poly a (polyform a b)
   
   [<a name="preds_def-val"><b>preds_def</b></a>]  Definition
      
      ⊢ ∀w. preds w = {w0 | w0 &lt; w}
   
   [<a name="sup_def-val"><b>sup_def</b></a>]  Definition
      
      ⊢ ∀ordset. sup ordset = oleast a. a ∉ BIGUNION (IMAGE preds ordset)
   
   [<a name="ADD1R-val"><b>ADD1R</b></a>]  Theorem
      
      ⊢ a + 1 = a⁺
   
   [<a name="CARD_FINITE_preds-val"><b>CARD_FINITE_preds</b></a>]  Theorem
      
      ⊢ CARD (preds (&n)) = CARD (preds (&n))
   
   [<a name="CNF_nat-val"><b>CNF_nat</b></a>]  Theorem
      
      ⊢ CNF (&n) = if n = 0 then [] else [(&n,0)]
   
   [<a name="CNF_thm-val"><b>CNF_thm</b></a>]  Theorem
      
      ⊢ ∀b. is_polyform ω (CNF b) ∧ b = eval_poly ω (CNF b)
   
   [<a name="FINITE_cardSUC-val"><b>FINITE_cardSUC</b></a>]  Theorem
      
      ⊢ FINITE (cardSUC A) ⇔ FINITE A
   
   [<a name="FINITE_omax_IS_SOME-val"><b>FINITE_omax_IS_SOME</b></a>]  Theorem
      
      ⊢ s ≠ ∅ ∧ FINITE s ⇒ ∃a. omax s = SOME a
   
   [<a name="FINITE_preds-val"><b>FINITE_preds</b></a>]  Theorem
      
      ⊢ FINITE (preds a) ⇔ ∃n. a = &n
   
   [<a name="IFF_ZERO_lt-val"><b>IFF_ZERO_lt</b></a>]  Theorem
      
      ⊢ (x ≠ 0 ⇔ 0 &lt; x) ∧ (1 ≤ x ⇔ 0 &lt; x)
   
   [<a name="IMAGE_EQ_SING-val"><b>IMAGE_EQ_SING</b></a>]  Theorem
      
      ⊢ IMAGE f s = {x} ⇔ (∃y. y ∈ s) ∧ ∀y. y ∈ s ⇒ f y = x
   
   [<a name="INFINITE_eqpreds-val"><b>INFINITE_eqpreds</b></a>]  Theorem
      
      ⊢ ω ≤ x ⇒ INFINITE {y | preds y ≈ preds x}
   
   [<a name="IN_preds-val"><b>IN_preds</b></a>]  Theorem
      
      ⊢ x ∈ preds w ⇔ x &lt; w
   
   [<a name="ORD_ONE-val"><b>ORD_ONE</b></a>]  Theorem
      
      ⊢ 0⁺ = 1
   
   [<a name="Unum_cardle_ucinf-val"><b>Unum_cardle_ucinf</b></a>]  Theorem
      
      ⊢ 𝕌(:num) ≼ 𝕌(:num + (α + num -&gt; bool))
   
   [<a name="Unum_cardlt_ucinf-val"><b>Unum_cardlt_ucinf</b></a>]  Theorem
      
      ⊢ 𝕌(:num) ≺ 𝕌(:num + (α + num -&gt; bool))
   
   [<a name="Unum_cle_Uinf-val"><b>Unum_cle_Uinf</b></a>]  Theorem
      
      ⊢ 𝕌(:num) ≼ 𝕌(:num + α)
   
   [<a name="WIN_allOrds-val"><b>WIN_allOrds</b></a>]  Theorem
      
      ⊢ (x,y) WIN allOrds ⇔ x &lt; y
   
   [<a name="ZERO_LT_csuc-val"><b>ZERO_LT_csuc</b></a>]  Theorem
      
      ⊢ 0o &lt; csuc a ∧ csuc a ≠ 0o
   
   [<a name="ZERO_lt_ordEXP-val"><b>ZERO_lt_ordEXP</b></a>]  Theorem
      
      ⊢ 0 &lt; a ** x ⇔ 0 &lt; a ∨ islimit x
   
   [<a name="ZERO_lt_ordEXP_I-val"><b>ZERO_lt_ordEXP_I</b></a>]  Theorem
      
      ⊢ ∀a x. 0 &lt; a ⇒ 0 &lt; a ** x
   
   [<a name="addL_fixpoint_iff-val"><b>addL_fixpoint_iff</b></a>]  Theorem
      
      ⊢ a + b = b ⇔ a * ω ≤ b
   
   [<a name="add_nat_islimit-val"><b>add_nat_islimit</b></a>]  Theorem
      
      ⊢ 0 &lt; n ⇒ (islimit (a + &n) ⇔ F)
   
   [<a name="add_omega_islimit-val"><b>add_omega_islimit</b></a>]  Theorem
      
      ⊢ islimit (a + ω)
   
   [<a name="bumpUNIV_cardlt-val"><b>bumpUNIV_cardlt</b></a>]  Theorem
      
      ⊢ 𝕌(:num + α) ≺ 𝕌(:num + (α + num -&gt; bool))
   
   [<a name="cardSUC_EQ0-val"><b>cardSUC_EQ0</b></a>]  Theorem
      
      ⊢ cardSUC A ≠ ∅
   
   [<a name="cardeq_ordinals_exist-val"><b>cardeq_ordinals_exist</b></a>]  Theorem
      
      ⊢ s ≼ 𝕌(:num + α) ⇒ ∃a. preds a ≈ s
   
   [<a name="cardinality_bump_exists-val"><b>cardinality_bump_exists</b></a>]  Theorem
      
      ⊢ ∀x. ∃y. preds x ≺ preds y
   
   [<a name="cardle_preds_EQ_cardeq_preds-val"><b>cardle_preds_EQ_cardeq_preds</b></a>]  Theorem
      
      ⊢ ω ≤ x ⇒ {y | preds y ≼ preds x} ≈ {y | preds y ≈ preds x}
   
   [<a name="cardleq_preds_csuc-val"><b>cardleq_preds_csuc</b></a>]  Theorem
      
      ⊢ preds a ≼ preds b ⇒ preds (csuc a) ≼ preds (csuc b)
   
   [<a name="cardlt_eqpreds-val"><b>cardlt_eqpreds</b></a>]  Theorem
      
      ⊢ ω ≤ x ⇒ preds x ≺ {y | preds y ≈ preds x}
   
   [<a name="cardlt_lepreds-val"><b>cardlt_lepreds</b></a>]  Theorem
      
      ⊢ preds x ≺ {y | preds y ≼ preds x}
   
   [<a name="cardlt_preds-val"><b>cardlt_preds</b></a>]  Theorem
      
      ⊢ preds x ≺ preds y ⇒ x &lt; y
   
   [<a name="closed_sing-val"><b>closed_sing</b></a>]  Theorem
      
      ⊢ closed_in ordlt_top {x}
   
   [<a name="cord_countable_preds-val"><b>cord_countable_preds</b></a>]  Theorem
      
      ⊢ countableOrd ord
   
   [<a name="countableOrds_dclosed-val"><b>countableOrds_dclosed</b></a>]  Theorem
      
      ⊢ a &lt; b ∧ countableOrd b ⇒ countableOrd a
   
   [<a name="countableOrds_uncountable-val"><b>countableOrds_uncountable</b></a>]  Theorem
      
      ⊢ ¬countable {a | countableOrd a}
   
   [<a name="csuc_EQ_N-val"><b>csuc_EQ_N</b></a>]  Theorem
      
      ⊢ csuc a = &n ⇔ ∃m. n = SUC m ∧ a = &m
   
   [<a name="csuc_is_nonzero_limit-val"><b>csuc_is_nonzero_limit</b></a>]  Theorem
      
      ⊢ ω ≤ a ⇒ islimit (csuc a) ∧ 0o &lt; csuc a
   
   [<a name="csuc_nat-val"><b>csuc_nat</b></a>]  Theorem
      
      ⊢ csuc (&n) = (&n)⁺
   
   [<a name="csuc_omega-val"><b>csuc_omega</b></a>]  Theorem
      
      ⊢ csuc ω = ω₁
   
   [<a name="csup_lesup-val"><b>csup_lesup</b></a>]  Theorem
      
      ⊢ countable s ⇒ ∀d. d ∈ s ⇒ d ≤ sup s
   
   [<a name="csup_suple-val"><b>csup_suple</b></a>]  Theorem
      
      ⊢ countable s ⇒ (sup s ≤ b ⇔ ∀d. d ∈ s ⇒ d ≤ b)
   
   [<a name="csup_thm-val"><b>csup_thm</b></a>]  Theorem
      
      ⊢ countable s ⇒ ∀b. b &lt; sup s ⇔ ∃d. d ∈ s ∧ b &lt; d
   
   [<a name="cx_lt_x-val"><b>cx_lt_x</b></a>]  Theorem
      
      ⊢ x * c &lt; x ⇔ 0 &lt; x ∧ c = 0
   
   [<a name="dclose_BIGUNION-val"><b>dclose_BIGUNION</b></a>]  Theorem
      
      ⊢ dclose s = BIGUNION (IMAGE preds s)
   
   [<a name="dclose_cardleq_univinf-val"><b>dclose_cardleq_univinf</b></a>]  Theorem
      
      ⊢ s ≼ 𝕌(:num + α) ⇒ dclose s ≼ 𝕌(:num + α)
   
   [<a name="elsOf_allOrds-val"><b>elsOf_allOrds</b></a>]  Theorem
      
      ⊢ elsOf allOrds = 𝕌(:α ordinal)
   
   [<a name="epsilon0_fixpoint-val"><b>epsilon0_fixpoint</b></a>]  Theorem
      
      ⊢ ω ** ε₀ = ε₀
   
   [<a name="epsilon0_least_fixpoint-val"><b>epsilon0_least_fixpoint</b></a>]  Theorem
      
      ⊢ ∀a. a &lt; ε₀ ⇒ a &lt; ω ** a ∧ ω ** a &lt; ε₀
   
   [<a name="eval_poly_def-val"><b>eval_poly_def</b></a>]  Theorem
      
      ⊢ (∀a. eval_poly a [] = 0) ∧
        ∀t e c a. eval_poly a ((c,e)::t) = a ** e * c + eval_poly a t
   
   [<a name="eval_poly_ind-val"><b>eval_poly_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀a. P a []) ∧ (∀a c e t. P a t ⇒ P a ((c,e)::t)) ⇒
            ∀v v1. P v v1
   
   [<a name="expbound_add-val"><b>expbound_add</b></a>]  Theorem
      
      ⊢ ∀a x y. x &lt; ω ** a ∧ y &lt; ω ** a ⇒ x + y &lt; ω ** a
   
   [<a name="fixpoints_exist-val"><b>fixpoints_exist</b></a>]  Theorem
      
      ⊢ (∀s. s ≠ ∅ ∧ s ≼ 𝕌(:num + α) ⇒ f (sup s) = sup (IMAGE f s)) ∧
        (∀x. x ≤ f x) ⇒
        ∀a. ∃b. a ≤ b ∧ f b = b
   
   [<a name="fromNat_11-val"><b>fromNat_11</b></a>]  Theorem
      
      ⊢ ∀x y. &x = &y ⇔ x = y
   
   [<a name="fromNat_SUC-val"><b>fromNat_SUC</b></a>]  Theorem
      
      ⊢ ∀n. &SUC n = (&n)⁺
   
   [<a name="fromNat_compute-val"><b>fromNat_compute</b></a>]  Theorem
      
      ⊢ 0 = (oleast a. T) ∧
        (∀n. &NUMERAL (BIT1 n) = (&(NUMERAL (BIT1 n) − 1))⁺) ∧
        ∀n. &NUMERAL (BIT2 n) = (&NUMERAL (BIT1 n))⁺
   
   [<a name="fromNat_eq_omega-val"><b>fromNat_eq_omega</b></a>]  Theorem
      
      ⊢ ∀n. &n ≠ ω
   
   [<a name="fromNat_lt_epsilon0-val"><b>fromNat_lt_epsilon0</b></a>]  Theorem
      
      ⊢ &n &lt; ε₀
   
   [<a name="fromNat_lt_omega-val"><b>fromNat_lt_omega</b></a>]  Theorem
      
      ⊢ ∀n. &n &lt; ω
   
   [<a name="fromNat_ordlt-val"><b>fromNat_ordlt</b></a>]  Theorem
      
      ⊢ &n &lt; &m ⇔ n &lt; m
   
   [<a name="generic_continuity-val"><b>generic_continuity</b></a>]  Theorem
      
      ⊢ (∀a. 0 &lt; a ∧ islimit a ⇒ f a = sup (IMAGE f (preds a))) ∧
        (∀x y. x ≤ y ⇒ f x ≤ f y) ⇒
        ∀s. s ≼ 𝕌(:num + α) ∧ s ≠ ∅ ⇒ f (sup s) = sup (IMAGE f s)
   
   [<a name="is_polyform_CONS_E-val"><b>is_polyform_CONS_E</b></a>]  Theorem
      
      ⊢ is_polyform a ((c,e)::t) ⇒ 0 &lt; c ∧ c &lt; a ∧ is_polyform a t
   
   [<a name="is_polyform_ELthm-val"><b>is_polyform_ELthm</b></a>]  Theorem
      
      ⊢ is_polyform a ces ⇔
        (∀i j. i &lt; j ∧ j &lt; LENGTH ces ⇒ SND (EL j ces) &lt; SND (EL i ces)) ∧
        ∀c e. MEM (c,e) ces ⇒ 0 &lt; c ∧ c &lt; a
   
   [<a name="is_polyform_def-val"><b>is_polyform_def</b></a>]  Theorem
      
      ⊢ (∀a. is_polyform a [] ⇔ T) ∧
        (∀e c a. is_polyform a [(c,e)] ⇔ 0 &lt; c ∧ c &lt; a) ∧
        ∀t e2 e1 c2 c1 a.
          is_polyform a ((c1,e1)::(c2,e2)::t) ⇔
          0 &lt; c1 ∧ c1 &lt; a ∧ e2 &lt; e1 ∧ is_polyform a ((c2,e2)::t)
   
   [<a name="is_polyform_head_dominates_tail-val"><b>is_polyform_head_dominates_tail</b></a>]  Theorem
      
      ⊢ 1 &lt; a ∧ is_polyform a ((c,e)::t) ⇒ eval_poly a t &lt; a ** e
   
   [<a name="is_polyform_ind-val"><b>is_polyform_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀a. P a []) ∧ (∀a c e. P a [(c,e)]) ∧
            (∀a c1 e1 c2 e2 t. P a ((c2,e2)::t) ⇒ P a ((c1,e1)::(c2,e2)::t)) ⇒
            ∀v v1. P v v1
   
   [<a name="islimit_0-val"><b>islimit_0</b></a>]  Theorem
      
      ⊢ islimit 0
   
   [<a name="islimit_SUC-val"><b>islimit_SUC</b></a>]  Theorem
      
      ⊢ islimit x⁺ ⇔ F
   
   [<a name="islimit_SUC_lt-val"><b>islimit_SUC_lt</b></a>]  Theorem
      
      ⊢ islimit b ∧ a &lt; b ⇒ a⁺ &lt; b
   
   [<a name="islimit_fromNat-val"><b>islimit_fromNat</b></a>]  Theorem
      
      ⊢ islimit (&x) ⇔ x = 0
   
   [<a name="islimit_mul_R-val"><b>islimit_mul_R</b></a>]  Theorem
      
      ⊢ ∀a. islimit a ⇒ islimit (b * a)
   
   [<a name="le_cardSUC-val"><b>le_cardSUC</b></a>]  Theorem
      
      ⊢ A ≼ cardSUC A
   
   [<a name="leqLEFT_CANCEL-val"><b>leqLEFT_CANCEL</b></a>]  Theorem
      
      ⊢ ∀x a. x ≤ a + x
   
   [<a name="limpt_islimit-val"><b>limpt_islimit</b></a>]  Theorem
      
      ⊢ limpt ordlt_top a (preds a) ⇔ islimit a ∧ a ≠ 0
   
   [<a name="lt_cardSUC-val"><b>lt_cardSUC</b></a>]  Theorem
      
      ⊢ A ≺ cardSUC A
   
   [<a name="lt_csuc-val"><b>lt_csuc</b></a>]  Theorem
      
      ⊢ x &lt; csuc y ⇔ preds x ≼ preds y
   
   [<a name="lt_omega-val"><b>lt_omega</b></a>]  Theorem
      
      ⊢ ∀a. a &lt; ω ⇔ ∃m. a = &m
   
   [<a name="lt_suppreds-val"><b>lt_suppreds</b></a>]  Theorem
      
      ⊢ ∀b. b &lt; sup (preds a) ⇔ ∃d. d &lt; a ∧ b &lt; d
   
   [<a name="mul_omega_islimit-val"><b>mul_omega_islimit</b></a>]  Theorem
      
      ⊢ islimit (ω * a)
   
   [<a name="no_maximal_ordinal-val"><b>no_maximal_ordinal</b></a>]  Theorem
      
      ⊢ ∀a. ∃b. a &lt; b
   
   [<a name="oleast_intro-val"><b>oleast_intro</b></a>]  Theorem
      
      ⊢ ∀Q P.
          (∃a. P a) ∧ (∀a. (∀b. b &lt; a ⇒ ¬P b) ∧ P a ⇒ Q a) ⇒ Q ($oleast P)
   
   [<a name="olog_correct-val"><b>olog_correct</b></a>]  Theorem
      
      ⊢ 0 &lt; x ⇒ ω ** olog x ≤ x ∧ ∀a. olog x &lt; a ⇒ x &lt; ω ** a
   
   [<a name="omax_EMPTY-val"><b>omax_EMPTY</b></a>]  Theorem
      
      ⊢ omax ∅ = NONE
   
   [<a name="omax_INSERT-val"><b>omax_INSERT</b></a>]  Theorem
      
      ⊢ omax (x INSERT y) = if ∀e. e ∈ y ⇒ e ≤ x then SOME x else omax y
   
   [<a name="omax_NONE-val"><b>omax_NONE</b></a>]  Theorem
      
      ⊢ omax s = NONE ⇔ ∀a. a ∈ s ⇒ ∃b. b ∈ s ∧ a &lt; b
   
   [<a name="omax_SOME-val"><b>omax_SOME</b></a>]  Theorem
      
      ⊢ omax s = SOME a ⇔ a ∈ s ∧ ∀b. b ∈ s ⇒ b ≤ a
   
   [<a name="omax_preds_SUC-val"><b>omax_preds_SUC</b></a>]  Theorem
      
      ⊢ omax (preds a⁺) = SOME a
   
   [<a name="omax_preds_omega-val"><b>omax_preds_omega</b></a>]  Theorem
      
      ⊢ islimit ω
   
   [<a name="omax_sup-val"><b>omax_sup</b></a>]  Theorem
      
      ⊢ omax s = SOME a ⇒ sup s = a
   
   [<a name="omega1_not_countable-val"><b>omega1_not_countable</b></a>]  Theorem
      
      ⊢ ¬countableOrd ω₁
   
   [<a name="omega_LEQ_INFINITE_preds-val"><b>omega_LEQ_INFINITE_preds</b></a>]  Theorem
      
      ⊢ INFINITE (preds a) ⇒ ω ≤ a
   
   [<a name="omega_MUL_fromNat-val"><b>omega_MUL_fromNat</b></a>]  Theorem
      
      ⊢ 0 &lt; n ⇒ &n * ω = ω
   
   [<a name="omega_exp_islimit-val"><b>omega_exp_islimit</b></a>]  Theorem
      
      ⊢ 0 &lt; a ⇒ islimit (ω ** a)
   
   [<a name="omega_islimit-val"><b>omega_islimit</b></a>]  Theorem
      
      ⊢ islimit ω
   
   [<a name="omega_lt_epsilon0-val"><b>omega_lt_epsilon0</b></a>]  Theorem
      
      ⊢ ω &lt; ε₀
   
   [<a name="open_in_ordlt-val"><b>open_in_ordlt</b></a>]  Theorem
      
      ⊢ open_in ordlt_top s ⇔
        ∀e. e ∈ s ⇒
            (∃a b. e ∈ ival a b ∧ ival a b ⊆ s) ∨
            ∃b. e &lt; b ∧ ∀d. d &lt; b ⇒ d ∈ s
   
   [<a name="open_sing_nonlimit-val"><b>open_sing_nonlimit</b></a>]  Theorem
      
      ⊢ open_in ordlt_top {x} ⇔ omax (preds x) ≠ NONE ∨ x = 0
   
   [<a name="ordADD_0L-val"><b>ordADD_0L</b></a>]  Theorem
      
      ⊢ ∀a. 0 + a = a
   
   [<a name="ordADD_ASSOC-val"><b>ordADD_ASSOC</b></a>]  Theorem
      
      ⊢ ∀a b c. a + (b + c) = a + b + c
   
   [<a name="ordADD_CANCEL1-val"><b>ordADD_CANCEL1</b></a>]  Theorem
      
      ⊢ (∀c a. a = a + c ⇔ c = 0) ∧ ∀c a. a + c = a ⇔ c = 0
   
   [<a name="ordADD_EQ_0-val"><b>ordADD_EQ_0</b></a>]  Theorem
      
      ⊢ ∀y x. x + y = 0 ⇔ x = 0 ∧ y = 0
   
   [<a name="ordADD_MONO-val"><b>ordADD_MONO</b></a>]  Theorem
      
      ⊢ ∀b a c. a &lt; b ⇒ c + a &lt; c + b
   
   [<a name="ordADD_RIGHT_CANCEL-val"><b>ordADD_RIGHT_CANCEL</b></a>]  Theorem
      
      ⊢ ∀b a c. a + b = a + c ⇔ b = c
   
   [<a name="ordADD_continuous-val"><b>ordADD_continuous</b></a>]  Theorem
      
      ⊢ ∀s. s ≼ 𝕌(:num + α) ∧ s ≠ ∅ ⇒ a + sup s = sup (IMAGE ($+ a) s)
   
   [<a name="ordADD_fromNat-val"><b>ordADD_fromNat</b></a>]  Theorem
      
      ⊢ &n + &m = &(n + m)
   
   [<a name="ordADD_fromNat_omega-val"><b>ordADD_fromNat_omega</b></a>]  Theorem
      
      ⊢ &n + ω = ω
   
   [<a name="ordADD_le_MONO_L-val"><b>ordADD_le_MONO_L</b></a>]  Theorem
      
      ⊢ x ≤ y ⇒ x + z ≤ y + z
   
   [<a name="ordADD_under_epsilon0-val"><b>ordADD_under_epsilon0</b></a>]  Theorem
      
      ⊢ x &lt; ε₀ ∧ y &lt; ε₀ ⇒ x + y &lt; ε₀
   
   [<a name="ordADD_weak_MONO-val"><b>ordADD_weak_MONO</b></a>]  Theorem
      
      ⊢ ∀c a b. a &lt; b ⇒ a + c ≤ b + c
   
   [<a name="ordDIVISION-val"><b>ordDIVISION</b></a>]  Theorem
      
      ⊢ ∀a b. 0 &lt; b ⇒ a = b * (a / b) + a % b ∧ a % b &lt; b
   
   [<a name="ordDIV_UNIQUE-val"><b>ordDIV_UNIQUE</b></a>]  Theorem
      
      ⊢ ∀a b q r. 0 &lt; b ∧ a = b * q + r ∧ r &lt; b ⇒ a / b = q
   
   [<a name="ordEXP_1L-val"><b>ordEXP_1L</b></a>]  Theorem
      
      ⊢ ∀a. 1 ** a = 1
   
   [<a name="ordEXP_1R-val"><b>ordEXP_1R</b></a>]  Theorem
      
      ⊢ a ** 1 = a
   
   [<a name="ordEXP_2R-val"><b>ordEXP_2R</b></a>]  Theorem
      
      ⊢ a ** 2 = a * a
   
   [<a name="ordEXP_ADD-val"><b>ordEXP_ADD</b></a>]  Theorem
      
      ⊢ 0 &lt; x ⇒ x ** (y + z) = x ** y * x ** z
   
   [<a name="ordEXP_EQ_0-val"><b>ordEXP_EQ_0</b></a>]  Theorem
      
      ⊢ ∀y x. x ** y = 0 ⇔ x = 0 ∧ omax (preds y) ≠ NONE
   
   [<a name="ordEXP_MUL-val"><b>ordEXP_MUL</b></a>]  Theorem
      
      ⊢ 0 &lt; x ⇒ x ** (y * z) = (x ** y) ** z
   
   [<a name="ordEXP_ZERO_limit-val"><b>ordEXP_ZERO_limit</b></a>]  Theorem
      
      ⊢ ∀x. islimit x ⇒ 0 ** x = 1
   
   [<a name="ordEXP_ZERO_nonlimit-val"><b>ordEXP_ZERO_nonlimit</b></a>]  Theorem
      
      ⊢ omax (preds x) ≠ NONE ⇒ 0 ** x = 0
   
   [<a name="ordEXP_continuous-val"><b>ordEXP_continuous</b></a>]  Theorem
      
      ⊢ ∀a s.
          0 &lt; a ∧ s ≼ 𝕌(:num + α) ∧ s ≠ ∅ ⇒
          a ** sup s = sup (IMAGE ($** a) s)
   
   [<a name="ordEXP_fromNat-val"><b>ordEXP_fromNat</b></a>]  Theorem
      
      ⊢ &x ** &n = &(x ** n)
   
   [<a name="ordEXP_le_MONO_L-val"><b>ordEXP_le_MONO_L</b></a>]  Theorem
      
      ⊢ ∀x a b. a ≤ b ⇒ a ** x ≤ b ** x
   
   [<a name="ordEXP_le_MONO_R-val"><b>ordEXP_le_MONO_R</b></a>]  Theorem
      
      ⊢ ∀x y a. 0 &lt; a ∧ x ≤ y ⇒ a ** x ≤ a ** y
   
   [<a name="ordEXP_lt_IFF-val"><b>ordEXP_lt_IFF</b></a>]  Theorem
      
      ⊢ ∀x y a. 1 &lt; a ⇒ (a ** x &lt; a ** y ⇔ x &lt; y)
   
   [<a name="ordEXP_lt_MONO_R-val"><b>ordEXP_lt_MONO_R</b></a>]  Theorem
      
      ⊢ ∀y x a. 1 &lt; a ∧ x &lt; y ⇒ a ** x &lt; a ** y
   
   [<a name="ordEXP_under_epsilon0-val"><b>ordEXP_under_epsilon0</b></a>]  Theorem
      
      ⊢ a &lt; ε₀ ∧ b &lt; ε₀ ⇒ a ** b &lt; ε₀
   
   [<a name="ordLOG_correct-val"><b>ordLOG_correct</b></a>]  Theorem
      
      ⊢ 1 &lt; b ∧ 0 &lt; x ⇒
        b ** ordLOG b x ≤ x ∧ ∀a. ordLOG b x &lt; a ⇒ x &lt; b ** a
   
   [<a name="ordMOD_UNIQUE-val"><b>ordMOD_UNIQUE</b></a>]  Theorem
      
      ⊢ ∀a b q r. 0 &lt; b ∧ a = b * q + r ∧ r &lt; b ⇒ a % b = r
   
   [<a name="ordMULT_0L-val"><b>ordMULT_0L</b></a>]  Theorem
      
      ⊢ ∀a. 0 * a = 0
   
   [<a name="ordMULT_0R-val"><b>ordMULT_0R</b></a>]  Theorem
      
      ⊢ ∀a. a * 0 = 0
   
   [<a name="ordMULT_1L-val"><b>ordMULT_1L</b></a>]  Theorem
      
      ⊢ ∀a. 1 * a = a
   
   [<a name="ordMULT_1R-val"><b>ordMULT_1R</b></a>]  Theorem
      
      ⊢ ∀a. a * 1 = a
   
   [<a name="ordMULT_2R-val"><b>ordMULT_2R</b></a>]  Theorem
      
      ⊢ a * 2 = a + a
   
   [<a name="ordMULT_ASSOC-val"><b>ordMULT_ASSOC</b></a>]  Theorem
      
      ⊢ ∀a b c. a * (b * c) = a * b * c
   
   [<a name="ordMULT_CANCEL_R-val"><b>ordMULT_CANCEL_R</b></a>]  Theorem
      
      ⊢ z * x = z * y ⇔ z = 0 ∨ x = y
   
   [<a name="ordMULT_EQ_0-val"><b>ordMULT_EQ_0</b></a>]  Theorem
      
      ⊢ ∀x y. x * y = 0 ⇔ x = 0 ∨ y = 0
   
   [<a name="ordMULT_LDISTRIB-val"><b>ordMULT_LDISTRIB</b></a>]  Theorem
      
      ⊢ ∀a b c. c * (a + b) = c * a + c * b
   
   [<a name="ordMULT_continuous-val"><b>ordMULT_continuous</b></a>]  Theorem
      
      ⊢ ∀s. s ≼ 𝕌(:num + α) ⇒ a * sup s = sup (IMAGE ($* a) s)
   
   [<a name="ordMULT_fromNat-val"><b>ordMULT_fromNat</b></a>]  Theorem
      
      ⊢ &n * &m = &(n * m)
   
   [<a name="ordMULT_le_MONO_L-val"><b>ordMULT_le_MONO_L</b></a>]  Theorem
      
      ⊢ ∀a b c. a ≤ b ⇒ a * c ≤ b * c
   
   [<a name="ordMULT_le_MONO_R-val"><b>ordMULT_le_MONO_R</b></a>]  Theorem
      
      ⊢ ∀a b c. a ≤ b ⇒ c * a ≤ c * b
   
   [<a name="ordMULT_lt_MONO_R-val"><b>ordMULT_lt_MONO_R</b></a>]  Theorem
      
      ⊢ ∀a b c. a &lt; b ∧ 0 &lt; c ⇒ c * a &lt; c * b
   
   [<a name="ordMULT_lt_MONO_R_EQN-val"><b>ordMULT_lt_MONO_R_EQN</b></a>]  Theorem
      
      ⊢ c * a &lt; c * b ⇔ a &lt; b ∧ 0 &lt; c
   
   [<a name="ordMUL_under_epsilon0-val"><b>ordMUL_under_epsilon0</b></a>]  Theorem
      
      ⊢ x &lt; ε₀ ∧ y &lt; ε₀ ⇒ x * y &lt; ε₀
   
   [<a name="ordSUC_11-val"><b>ordSUC_11</b></a>]  Theorem
      
      ⊢ a⁺ = b⁺ ⇔ a = b
   
   [<a name="ordSUC_MONO-val"><b>ordSUC_MONO</b></a>]  Theorem
      
      ⊢ a⁺ &lt; b⁺ ⇔ a &lt; b
   
   [<a name="ordSUC_NUMERAL-val"><b>ordSUC_NUMERAL</b></a>]  Theorem
      
      ⊢ (&NUMERAL n)⁺ = &(NUMERAL n + 1)
   
   [<a name="ordSUC_ZERO-val"><b>ordSUC_ZERO</b></a>]  Theorem
      
      ⊢ a⁺ ≠ 0
   
   [<a name="ordZERO_ltSUC-val"><b>ordZERO_ltSUC</b></a>]  Theorem
      
      ⊢ 0 &lt; x⁺
   
   [<a name="ord_CASES-val"><b>ord_CASES</b></a>]  Theorem
      
      ⊢ ∀a. a = 0 ∨ (∃a0. a = a0⁺) ∨ 0 &lt; a ∧ islimit a
   
   [<a name="ord_RECURSION-val"><b>ord_RECURSION</b></a>]  Theorem
      
      ⊢ ∀z sf lf. ∃h.
          h 0 = z ∧ (∀a. h a⁺ = sf a (h a)) ∧
          ∀a. 0 &lt; a ∧ islimit a ⇒ h a = lf a (IMAGE h (preds a))
   
   [<a name="ord_induction-val"><b>ord_induction</b></a>]  Theorem
      
      ⊢ (∀min. (∀b. b &lt; min ⇒ P b) ⇒ P min) ⇒ ∀a. P a
   
   [<a name="order_topology_exists-val"><b>order_topology_exists</b></a>]  Theorem
      
      ⊢ istopology
          {s |
           (∀e. e ∈ s ⇒
                (∃a b. e ∈ ival a b ∧ ival a b ⊆ s) ∨
                ∃b. e &lt; b ∧ ∀d. d &lt; b ⇒ d ∈ s)}
   
   [<a name="orderiso_cardeq_elsOf-val"><b>orderiso_cardeq_elsOf</b></a>]  Theorem
      
      ⊢ orderiso w1 w2 ⇒ elsOf w1 ≈ elsOf w2
   
   [<a name="orderiso_wobound2-val"><b>orderiso_wobound2</b></a>]  Theorem
      
      ⊢ orderiso (wobound x w) (wobound y w) ⇒ (x,y) ∉ strict (destWO w)
   
   [<a name="orderlt_iso_REFL-val"><b>orderlt_iso_REFL</b></a>]  Theorem
      
      ⊢ orderiso w1 w2 ⇒ ¬orderlt w1 w2
   
   [<a name="ordinal_ABS_REP_CLASS-val"><b>ordinal_ABS_REP_CLASS</b></a>]  Theorem
      
      ⊢ (∀a. ordinal_ABS_CLASS (ordinal_REP_CLASS a) = a) ∧
        ∀c. (∃r. orderiso r r ∧ c = orderiso r) ⇔
            ordinal_REP_CLASS (ordinal_ABS_CLASS c) = c
   
   [<a name="ordinal_IVT-val"><b>ordinal_IVT</b></a>]  Theorem
      
      ⊢ (∀a. 0 &lt; a ∧ islimit a ⇒ f a = sup (IMAGE f (preds a))) ∧
        (∀x y. x ≤ y ⇒ f x ≤ f y) ∧ a1 &lt; a2 ∧ f a1 ≤ c ∧ c &lt; f a2 ⇒
        ∃b. a1 ≤ b ∧ b &lt; a2 ∧ f b ≤ c ∧ c &lt; f b⁺
   
   [<a name="ordinal_QUOTIENT-val"><b>ordinal_QUOTIENT</b></a>]  Theorem
      
      ⊢ QUOTIENT orderiso mkOrdinal ordinal_REP
   
   [<a name="ordle_ANTISYM-val"><b>ordle_ANTISYM</b></a>]  Theorem
      
      ⊢ a ≤ b ∧ b ≤ a ⇒ a = b
   
   [<a name="ordle_CANCEL_ADDR-val"><b>ordle_CANCEL_ADDR</b></a>]  Theorem
      
      ⊢ x ≤ x + a
   
   [<a name="ordle_EXISTS_ADD-val"><b>ordle_EXISTS_ADD</b></a>]  Theorem
      
      ⊢ ∀a b. a ≤ b ⇔ ∃c. b = a + c
   
   [<a name="ordle_TRANS-val"><b>ordle_TRANS</b></a>]  Theorem
      
      ⊢ ∀x y z. x ≤ y ∧ y ≤ z ⇒ x ≤ z
   
   [<a name="ordle_lteq-val"><b>ordle_lteq</b></a>]  Theorem
      
      ⊢ a ≤ b ⇔ a &lt; b ∨ a = b
   
   [<a name="ordleq0-val"><b>ordleq0</b></a>]  Theorem
      
      ⊢ x ≤ 0 ⇔ x = 0
   
   [<a name="ordlet_TRANS-val"><b>ordlet_TRANS</b></a>]  Theorem
      
      ⊢ ∀x y z. x ≤ y ∧ y &lt; z ⇒ x &lt; z
   
   [<a name="ordlt_CANCEL-val"><b>ordlt_CANCEL</b></a>]  Theorem
      
      ⊢ ∀b a c. c + a &lt; c + b ⇔ a &lt; b
   
   [<a name="ordlt_CANCEL_ADDL-val"><b>ordlt_CANCEL_ADDL</b></a>]  Theorem
      
      ⊢ a + b &lt; a ⇔ F
   
   [<a name="ordlt_CANCEL_ADDR-val"><b>ordlt_CANCEL_ADDR</b></a>]  Theorem
      
      ⊢ ∀b a. a &lt; a + b ⇔ 0 &lt; b
   
   [<a name="ordlt_DISCRETE1-val"><b>ordlt_DISCRETE1</b></a>]  Theorem
      
      ⊢ ¬(a &lt; b ∧ b &lt; a⁺)
   
   [<a name="ordlt_EXISTS_ADD-val"><b>ordlt_EXISTS_ADD</b></a>]  Theorem
      
      ⊢ ∀a b. a &lt; b ⇔ ∃c. c ≠ 0 ∧ b = a + c
   
   [<a name="ordlt_REFL-val"><b>ordlt_REFL</b></a>]  Theorem
      
      ⊢ ∀w. w ≤ w
   
   [<a name="ordlt_SUC-val"><b>ordlt_SUC</b></a>]  Theorem
      
      ⊢ a &lt; a⁺
   
   [<a name="ordlt_SUC_DISCRETE-val"><b>ordlt_SUC_DISCRETE</b></a>]  Theorem
      
      ⊢ a &lt; b⁺ ⇔ a &lt; b ∨ a = b
   
   [<a name="ordlt_TRANS-val"><b>ordlt_TRANS</b></a>]  Theorem
      
      ⊢ ∀w1 w2 w3. w1 &lt; w2 ∧ w2 &lt; w3 ⇒ w1 &lt; w3
   
   [<a name="ordlt_WF-val"><b>ordlt_WF</b></a>]  Theorem
      
      ⊢ WF $&lt;
   
   [<a name="ordlt_ZERO-val"><b>ordlt_ZERO</b></a>]  Theorem
      
      ⊢ 0 ≤ a
   
   [<a name="ordlt_fromNat-val"><b>ordlt_fromNat</b></a>]  Theorem
      
      ⊢ ∀n x. x &lt; &n ⇔ ∃m. x = &m ∧ m &lt; n
   
   [<a name="ordlt_mkOrdinal-val"><b>ordlt_mkOrdinal</b></a>]  Theorem
      
      ⊢ o1 &lt; o2 ⇔
        ∀w1 w2. mkOrdinal w1 = o1 ∧ mkOrdinal w2 = o2 ⇒ orderlt w1 w2
   
   [<a name="ordlt_preds_mono-val"><b>ordlt_preds_mono</b></a>]  Theorem
      
      ⊢ a &lt; b ⇒ preds a ≼ preds b
   
   [<a name="ordlt_trichotomy-val"><b>ordlt_trichotomy</b></a>]  Theorem
      
      ⊢ ∀w2 w1. w1 &lt; w2 ∨ w1 = w2 ∨ w2 &lt; w1
   
   [<a name="ordlte_TRANS-val"><b>ordlte_TRANS</b></a>]  Theorem
      
      ⊢ ∀x y z. x &lt; y ∧ y ≤ z ⇒ x &lt; z
   
   [<a name="polyform_0-val"><b>polyform_0</b></a>]  Theorem
      
      ⊢ 1 &lt; a ⇒ polyform a 0 = []
   
   [<a name="polyform_EQ_NIL-val"><b>polyform_EQ_NIL</b></a>]  Theorem
      
      ⊢ 1 &lt; a ⇒ (polyform a x = [] ⇔ x = 0)
   
   [<a name="polyform_UNIQUE-val"><b>polyform_UNIQUE</b></a>]  Theorem
      
      ⊢ ∀a b ces.
          1 &lt; a ∧ is_polyform a ces ∧ b = eval_poly a ces ⇒
          polyform a b = ces
   
   [<a name="polyform_eval_poly-val"><b>polyform_eval_poly</b></a>]  Theorem
      
      ⊢ 1 &lt; a ∧ is_polyform a b ⇒ polyform a (eval_poly a b) = b
   
   [<a name="polyform_exists-val"><b>polyform_exists</b></a>]  Theorem
      
      ⊢ ∀a b. 1 &lt; a ⇒ ∃ces. is_polyform a ces ∧ b = eval_poly a ces
   
   [<a name="predimage_sup_thm-val"><b>predimage_sup_thm</b></a>]  Theorem
      
      ⊢ ∀b. b &lt; sup (IMAGE f (preds a)) ⇔ ∃d. d &lt; a ∧ b &lt; f d
   
   [<a name="predimage_suplt_ELIM-val"><b>predimage_suplt_ELIM</b></a>]  Theorem
      
      ⊢ sup (IMAGE f (preds a)) &lt; b ⇒ ∀d. d &lt; a ⇒ f d ≤ b
   
   [<a name="preds_0-val"><b>preds_0</b></a>]  Theorem
      
      ⊢ preds 0 = ∅
   
   [<a name="preds_11-val"><b>preds_11</b></a>]  Theorem
      
      ⊢ preds w1 = preds w2 ⇔ w1 = w2
   
   [<a name="preds_EQ_EMPTY-val"><b>preds_EQ_EMPTY</b></a>]  Theorem
      
      ⊢ preds x = ∅ ⇔ x = 0
   
   [<a name="preds_bij-val"><b>preds_bij</b></a>]  Theorem
      
      ⊢ BIJ preds 𝕌(:α ordinal) (downward_closed DELETE 𝕌(:α ordinal))
   
   [<a name="preds_downward_closed-val"><b>preds_downward_closed</b></a>]  Theorem
      
      ⊢ downward_closed (preds w)
   
   [<a name="preds_inj_univ-val"><b>preds_inj_univ</b></a>]  Theorem
      
      ⊢ preds ord ≼ 𝕌(:num + α)
   
   [<a name="preds_lesup-val"><b>preds_lesup</b></a>]  Theorem
      
      ⊢ downward_closed s ∧ s ≠ 𝕌(:α ordinal) ⇒ ∀d. d ∈ s ⇒ d ≤ sup s
   
   [<a name="preds_lt_PSUBSET-val"><b>preds_lt_PSUBSET</b></a>]  Theorem
      
      ⊢ w1 &lt; w2 ⇔ preds w1 ⊂ preds w2
   
   [<a name="preds_nat-val"><b>preds_nat</b></a>]  Theorem
      
      ⊢ preds (&n) = IMAGE $& (count n)
   
   [<a name="preds_omax_SOME_SUC-val"><b>preds_omax_SOME_SUC</b></a>]  Theorem
      
      ⊢ omax (preds a) = SOME b ⇔ a = b⁺
   
   [<a name="preds_omega_UNIV-val"><b>preds_omega_UNIV</b></a>]  Theorem
      
      ⊢ preds ω ≈ 𝕌(:num)
   
   [<a name="preds_omega_lt_preds_omega1-val"><b>preds_omega_lt_preds_omega1</b></a>]  Theorem
      
      ⊢ preds ω ≺ preds ω₁
   
   [<a name="preds_ordSUC-val"><b>preds_ordSUC</b></a>]  Theorem
      
      ⊢ preds a⁺ = a INSERT preds a
   
   [<a name="preds_sup-val"><b>preds_sup</b></a>]  Theorem
      
      ⊢ s ≼ 𝕌(:num + α) ⇒ preds (sup s) = dclose s
   
   [<a name="preds_sup_thm-val"><b>preds_sup_thm</b></a>]  Theorem
      
      ⊢ downward_closed s ∧ s ≠ 𝕌(:α ordinal) ⇒
        ∀b. b &lt; sup s ⇔ ∃d. d ∈ s ∧ b &lt; d
   
   [<a name="preds_suple-val"><b>preds_suple</b></a>]  Theorem
      
      ⊢ downward_closed s ∧ s ≠ 𝕌(:α ordinal) ⇒
        (sup s ≤ b ⇔ ∀d. d ∈ s ⇒ d ≤ b)
   
   [<a name="preds_surj-val"><b>preds_surj</b></a>]  Theorem
      
      ⊢ ∀x. downward_closed x ∧ x ≠ 𝕌(:α ordinal) ⇒ ∃y. preds y = x
   
   [<a name="preds_wobound-val"><b>preds_wobound</b></a>]  Theorem
      
      ⊢ preds ord = elsOf (wobound ord allOrds)
   
   [<a name="rays_open-val"><b>rays_open</b></a>]  Theorem
      
      ⊢ open_in ordlt_top {x | x &lt; a} ∧ open_in ordlt_top {x | a &lt; x}
   
   [<a name="simple_ord_induction-val"><b>simple_ord_induction</b></a>]  Theorem
      
      ⊢ ∀P. P 0 ∧ (∀a. P a ⇒ P a⁺) ∧
            (∀a. islimit a ∧ 0 &lt; a ∧ (∀b. b &lt; a ⇒ P b) ⇒ P a) ⇒
            ∀a. P a
   
   [<a name="strict_continuity_preserves_islimit-val"><b>strict_continuity_preserves_islimit</b></a>]  Theorem
      
      ⊢ (∀s. s ≼ 𝕌(:num + α) ∧ s ≠ ∅ ⇒ f (sup s) = sup (IMAGE f s)) ∧
        (∀x y. x &lt; y ⇒ f x &lt; f y) ∧ islimit a ∧ a ≠ 0 ⇒
        islimit (f a)
   
   [<a name="sup_EMPTY-val"><b>sup_EMPTY</b></a>]  Theorem
      
      ⊢ sup ∅ = 0
   
   [<a name="sup_EQ_0-val"><b>sup_EQ_0</b></a>]  Theorem
      
      ⊢ s ≼ 𝕌(:num + α) ⇒ (sup s = 0 ⇔ s = ∅ ∨ s = {0})
   
   [<a name="sup_SING-val"><b>sup_SING</b></a>]  Theorem
      
      ⊢ sup {a} = a
   
   [<a name="sup_eq_SUC-val"><b>sup_eq_SUC</b></a>]  Theorem
      
      ⊢ s ≼ 𝕌(:num + α) ∧ sup s = a⁺ ⇒ a⁺ ∈ s
   
   [<a name="sup_eq_max-val"><b>sup_eq_max</b></a>]  Theorem
      
      ⊢ (∀b. b ∈ s ⇒ b ≤ a) ∧ a ∈ s ⇒ sup s = a
   
   [<a name="sup_eq_sup-val"><b>sup_eq_sup</b></a>]  Theorem
      
      ⊢ s1 ≼ 𝕌(:num + α) ∧ s2 ≼ 𝕌(:num + α) ∧
        (∀a. a ∈ s1 ⇒ ∃b. b ∈ s2 ∧ a ≤ b) ∧
        (∀b. b ∈ s2 ⇒ ∃a. a ∈ s1 ∧ b ≤ a) ⇒
        sup s1 = sup s2
   
   [<a name="sup_lt_implies-val"><b>sup_lt_implies</b></a>]  Theorem
      
      ⊢ s ≼ 𝕌(:num + α) ∧ sup s &lt; a ∧ b ∈ s ⇒ b &lt; a
   
   [<a name="sup_preds_SUC-val"><b>sup_preds_SUC</b></a>]  Theorem
      
      ⊢ sup (preds a⁺) = a
   
   [<a name="sup_preds_omax_NONE-val"><b>sup_preds_omax_NONE</b></a>]  Theorem
      
      ⊢ islimit a ⇔ sup (preds a) = a
   
   [<a name="sup_thm-val"><b>sup_thm</b></a>]  Theorem
      
      ⊢ s ≼ 𝕌(:num + α) ⇒ ∀a. a &lt; sup s ⇔ ∃b. b ∈ s ∧ a &lt; b
   
   [<a name="suple_thm-val"><b>suple_thm</b></a>]  Theorem
      
      ⊢ ∀b s. s ≼ 𝕌(:num + α) ∧ b ∈ s ⇒ b ≤ sup s
   
   [<a name="suppred_suplt_ELIM-val"><b>suppred_suplt_ELIM</b></a>]  Theorem
      
      ⊢ sup (preds a) &lt; b ⇒ ∀d. d &lt; a ⇒ d ≤ b
   
   [<a name="topspace_ordlt_top-val"><b>topspace_ordlt_top</b></a>]  Theorem
      
      ⊢ topspace ordlt_top = 𝕌(:α ordinal)
   
   [<a name="transfer_ordinals-val"><b>transfer_ordinals</b></a>]  Theorem
      
      ⊢ ∀a. preds a ≼ 𝕌(:num + β) ⇒
            ∃b. orderiso (wobound a allOrds) (wobound b allOrds) ∧
                preds a ≈ preds b
   
   [<a name="ubsup_thm-val"><b>ubsup_thm</b></a>]  Theorem
      
      ⊢ (∀a. a ∈ s ⇒ a &lt; b) ⇒ ∀c. c &lt; sup s ⇔ ∃d. d ∈ s ∧ c &lt; d
   
   [<a name="ucinf_uncountable-val"><b>ucinf_uncountable</b></a>]  Theorem
      
      ⊢ ¬countable 𝕌(:num + (α + num -&gt; bool))
   
   [<a name="ucord_sup_exists_lemma-val"><b>ucord_sup_exists_lemma</b></a>]  Theorem
      
      ⊢ {a | countableOrd a} ≼ 𝕌(:num + (α + num -&gt; bool))
   
   [<a name="unitinf_univnum-val"><b>unitinf_univnum</b></a>]  Theorem
      
      ⊢ 𝕌(:num + unit) ≈ 𝕌(:num)
   
   [<a name="univ_cord_uncountable-val"><b>univ_cord_uncountable</b></a>]  Theorem
      
      ⊢ ¬countable 𝕌(:unit ordinal)
   
   [<a name="univ_ord_greater_cardinal-val"><b>univ_ord_greater_cardinal</b></a>]  Theorem
      
      ⊢ 𝕌(:num + α) ≺ 𝕌(:α ordinal)
   
   [<a name="wellorder_allOrds-val"><b>wellorder_allOrds</b></a>]  Theorem
      
      ⊢ wellorder {(x,y) | x = y ∨ x &lt; y}
   
   [<a name="wellorder_ordinal_isomorphism-val"><b>wellorder_ordinal_isomorphism</b></a>]  Theorem
      
      ⊢ ∀w. orderiso w (wobound (mkOrdinal w) allOrds)
   
   [<a name="x_le_ordEXP_x-val"><b>x_le_ordEXP_x</b></a>]  Theorem
      
      ⊢ ∀a x. 1 &lt; a ⇒ x ≤ a ** x
   
   [<a name="x_lt_omega1_countable-val"><b>x_lt_omega1_countable</b></a>]  Theorem
      
      ⊢ x &lt; ω₁ ⇔ countableOrd x
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/pred_set/src/more_theories/.hol/objs/ordinalScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-2</a></em></p></body></html>
