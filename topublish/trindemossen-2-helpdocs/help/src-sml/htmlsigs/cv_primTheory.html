<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure cv_primTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure cv_primTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/num/theories/cv_compute/automation/.hol/objs/cv_primScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature cv_primTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#cv_abs_def-val">cv_abs_def</a> : thm
<a name="line7"></a>    val <a href="#cv_int_add_def-val">cv_int_add_def</a> : thm
<a name="line8"></a>    val <a href="#cv_int_div_def-val">cv_int_div_def</a> : thm
<a name="line9"></a>    val <a href="#cv_int_lt_def-val">cv_int_lt_def</a> : thm
<a name="line10"></a>    val <a href="#cv_int_mod_def-val">cv_int_mod_def</a> : thm
<a name="line11"></a>    val <a href="#cv_int_mul_def-val">cv_int_mul_def</a> : thm
<a name="line12"></a>    val <a href="#cv_int_neg_def-val">cv_int_neg_def</a> : thm
<a name="line13"></a>    val <a href="#cv_max_def-val">cv_max_def</a> : thm
<a name="line14"></a>    val <a href="#cv_min_def-val">cv_min_def</a> : thm
<a name="line15"></a>    val <a href="#cv_rat_add_def-val">cv_rat_add_def</a> : thm
<a name="line16"></a>    val <a href="#cv_rat_lt_def-val">cv_rat_lt_def</a> : thm
<a name="line17"></a>    val <a href="#cv_rat_mul_def-val">cv_rat_mul_def</a> : thm
<a name="line18"></a>    val <a href="#cv_rat_neg_def-val">cv_rat_neg_def</a> : thm
<a name="line19"></a>    val <a href="#cv_rat_norm_def-val">cv_rat_norm_def</a> : thm
<a name="line20"></a>    val <a href="#cv_rat_reciprocal_def-val">cv_rat_reciprocal_def</a> : thm
<a name="line21"></a>    val <a href="#cv_total_int_div_def-val">cv_total_int_div_def</a> : thm
<a name="line22"></a>    val <a href="#cv_total_int_mod_def-val">cv_total_int_mod_def</a> : thm
<a name="line23"></a>    val <a href="#cv_word_and_def-val">cv_word_and_def</a> : thm
<a name="line24"></a>    val <a href="#cv_word_lt_def-val">cv_word_lt_def</a> : thm
<a name="line25"></a>    val <a href="#cv_word_or_def-val">cv_word_or_def</a> : thm
<a name="line26"></a>    val <a href="#cv_word_sub_def-val">cv_word_sub_def</a> : thm
<a name="line27"></a>    val <a href="#cv_word_xor_def-val">cv_word_xor_def</a> : thm
<a name="line28"></a>    val <a href="#total_int_div_def-val">total_int_div_def</a> : thm
<a name="line29"></a>    val <a href="#total_int_mod_def-val">total_int_mod_def</a> : thm
<a name="line30"></a>  
<a name="line31"></a>  (*  Theorems  *)
<a name="line32"></a>    val <a href="#BITWISE-val">BITWISE</a> : thm
<a name="line33"></a>    val <a href="#BITWISE_ADD-val">BITWISE_ADD</a> : thm
<a name="line34"></a>    val <a href="#cv_Num-val">cv_Num</a> : thm
<a name="line35"></a>    val <a href="#cv_chr_thm-val">cv_chr_thm</a> : thm
<a name="line36"></a>    val <a href="#cv_gcd_def-val">cv_gcd_def</a> : thm
<a name="line37"></a>    val <a href="#cv_gcd_ind-val">cv_gcd_ind</a> : thm
<a name="line38"></a>    val <a href="#cv_gcd_thm-val">cv_gcd_thm</a> : thm
<a name="line39"></a>    val <a href="#cv_inline_imp-val">cv_inline_imp</a> : thm
<a name="line40"></a>    val <a href="#cv_inline_v2n-val">cv_inline_v2n</a> : thm
<a name="line41"></a>    val <a href="#cv_inline_v2w-val">cv_inline_v2w</a> : thm
<a name="line42"></a>    val <a href="#cv_inline_w2i-val">cv_inline_w2i</a> : thm
<a name="line43"></a>    val <a href="#cv_inline_w2v-val">cv_inline_w2v</a> : thm
<a name="line44"></a>    val <a href="#cv_inline_word_log2-val">cv_inline_word_log2</a> : thm
<a name="line45"></a>    val <a href="#cv_inline_word_ror-val">cv_inline_word_ror</a> : thm
<a name="line46"></a>    val <a href="#cv_inline_word_sw2sw-val">cv_inline_word_sw2sw</a> : thm
<a name="line47"></a>    val <a href="#cv_int_add-val">cv_int_add</a> : thm
<a name="line48"></a>    val <a href="#cv_int_div-val">cv_int_div</a> : thm
<a name="line49"></a>    val <a href="#cv_int_ge-val">cv_int_ge</a> : thm
<a name="line50"></a>    val <a href="#cv_int_gt-val">cv_int_gt</a> : thm
<a name="line51"></a>    val <a href="#cv_int_le-val">cv_int_le</a> : thm
<a name="line52"></a>    val <a href="#cv_int_lt-val">cv_int_lt</a> : thm
<a name="line53"></a>    val <a href="#cv_int_mod-val">cv_int_mod</a> : thm
<a name="line54"></a>    val <a href="#cv_int_mul-val">cv_int_mul</a> : thm
<a name="line55"></a>    val <a href="#cv_int_of_num-val">cv_int_of_num</a> : thm
<a name="line56"></a>    val <a href="#cv_int_sub-val">cv_int_sub</a> : thm
<a name="line57"></a>    val <a href="#cv_log2_def-val">cv_log2_def</a> : thm
<a name="line58"></a>    val <a href="#cv_log2_ind-val">cv_log2_ind</a> : thm
<a name="line59"></a>    val <a href="#cv_max_thm-val">cv_max_thm</a> : thm
<a name="line60"></a>    val <a href="#cv_min_thm-val">cv_min_thm</a> : thm
<a name="line61"></a>    val <a href="#cv_neg_int-val">cv_neg_int</a> : thm
<a name="line62"></a>    val <a href="#cv_ord_thm-val">cv_ord_thm</a> : thm
<a name="line63"></a>    val <a href="#cv_rat_add-val">cv_rat_add</a> : thm
<a name="line64"></a>    val <a href="#cv_rat_div-val">cv_rat_div</a> : thm
<a name="line65"></a>    val <a href="#cv_rat_ge-val">cv_rat_ge</a> : thm
<a name="line66"></a>    val <a href="#cv_rat_gt-val">cv_rat_gt</a> : thm
<a name="line67"></a>    val <a href="#cv_rat_le-val">cv_rat_le</a> : thm
<a name="line68"></a>    val <a href="#cv_rat_lt-val">cv_rat_lt</a> : thm
<a name="line69"></a>    val <a href="#cv_rat_mul-val">cv_rat_mul</a> : thm
<a name="line70"></a>    val <a href="#cv_rat_neg-val">cv_rat_neg</a> : thm
<a name="line71"></a>    val <a href="#cv_rat_norm_div_gcd-val">cv_rat_norm_div_gcd</a> : thm
<a name="line72"></a>    val <a href="#cv_rat_of_int-val">cv_rat_of_int</a> : thm
<a name="line73"></a>    val <a href="#cv_rat_reciprocal-val">cv_rat_reciprocal</a> : thm
<a name="line74"></a>    val <a href="#cv_rat_sub-val">cv_rat_sub</a> : thm
<a name="line75"></a>    val <a href="#cv_rep_F-val">cv_rep_F</a> : thm
<a name="line76"></a>    val <a href="#cv_rep_LOG2-val">cv_rep_LOG2</a> : thm
<a name="line77"></a>    val <a href="#cv_rep_T-val">cv_rep_T</a> : thm
<a name="line78"></a>    val <a href="#cv_rep_add-val">cv_rep_add</a> : thm
<a name="line79"></a>    val <a href="#cv_rep_and-val">cv_rep_and</a> : thm
<a name="line80"></a>    val <a href="#cv_rep_arb-val">cv_rep_arb</a> : thm
<a name="line81"></a>    val <a href="#cv_rep_dimindex-val">cv_rep_dimindex</a> : thm
<a name="line82"></a>    val <a href="#cv_rep_div-val">cv_rep_div</a> : thm
<a name="line83"></a>    val <a href="#cv_rep_eq-val">cv_rep_eq</a> : thm
<a name="line84"></a>    val <a href="#cv_rep_even-val">cv_rep_even</a> : thm
<a name="line85"></a>    val <a href="#cv_rep_exp-val">cv_rep_exp</a> : thm
<a name="line86"></a>    val <a href="#cv_rep_ge-val">cv_rep_ge</a> : thm
<a name="line87"></a>    val <a href="#cv_rep_gt-val">cv_rep_gt</a> : thm
<a name="line88"></a>    val <a href="#cv_rep_if-val">cv_rep_if</a> : thm
<a name="line89"></a>    val <a href="#cv_rep_le-val">cv_rep_le</a> : thm
<a name="line90"></a>    val <a href="#cv_rep_let-val">cv_rep_let</a> : thm
<a name="line91"></a>    val <a href="#cv_rep_lt-val">cv_rep_lt</a> : thm
<a name="line92"></a>    val <a href="#cv_rep_mod-val">cv_rep_mod</a> : thm
<a name="line93"></a>    val <a href="#cv_rep_mul-val">cv_rep_mul</a> : thm
<a name="line94"></a>    val <a href="#cv_rep_not-val">cv_rep_not</a> : thm
<a name="line95"></a>    val <a href="#cv_rep_num_case-val">cv_rep_num_case</a> : thm
<a name="line96"></a>    val <a href="#cv_rep_odd-val">cv_rep_odd</a> : thm
<a name="line97"></a>    val <a href="#cv_rep_or-val">cv_rep_or</a> : thm
<a name="line98"></a>    val <a href="#cv_rep_sub-val">cv_rep_sub</a> : thm
<a name="line99"></a>    val <a href="#cv_rep_sub1-val">cv_rep_sub1</a> : thm
<a name="line100"></a>    val <a href="#cv_rep_suc-val">cv_rep_suc</a> : thm
<a name="line101"></a>    val <a href="#cv_rep_word_add-val">cv_rep_word_add</a> : thm
<a name="line102"></a>    val <a href="#cv_rep_word_and-val">cv_rep_word_and</a> : thm
<a name="line103"></a>    val <a href="#cv_rep_word_div-val">cv_rep_word_div</a> : thm
<a name="line104"></a>    val <a href="#cv_rep_word_lsl-val">cv_rep_word_lsl</a> : thm
<a name="line105"></a>    val <a href="#cv_rep_word_lsr-val">cv_rep_word_lsr</a> : thm
<a name="line106"></a>    val <a href="#cv_rep_word_mod-val">cv_rep_word_mod</a> : thm
<a name="line107"></a>    val <a href="#cv_rep_word_msb-val">cv_rep_word_msb</a> : thm
<a name="line108"></a>    val <a href="#cv_rep_word_mul-val">cv_rep_word_mul</a> : thm
<a name="line109"></a>    val <a href="#cv_rep_word_n2w-val">cv_rep_word_n2w</a> : thm
<a name="line110"></a>    val <a href="#cv_rep_word_neg-val">cv_rep_word_neg</a> : thm
<a name="line111"></a>    val <a href="#cv_rep_word_not-val">cv_rep_word_not</a> : thm
<a name="line112"></a>    val <a href="#cv_rep_word_or-val">cv_rep_word_or</a> : thm
<a name="line113"></a>    val <a href="#cv_rep_word_sub-val">cv_rep_word_sub</a> : thm
<a name="line114"></a>    val <a href="#cv_rep_word_uint_max-val">cv_rep_word_uint_max</a> : thm
<a name="line115"></a>    val <a href="#cv_rep_word_w2n-val">cv_rep_word_w2n</a> : thm
<a name="line116"></a>    val <a href="#cv_rep_word_w2w-val">cv_rep_word_w2w</a> : thm
<a name="line117"></a>    val <a href="#cv_rep_word_xor-val">cv_rep_word_xor</a> : thm
<a name="line118"></a>    val <a href="#cv_total_int_div-val">cv_total_int_div</a> : thm
<a name="line119"></a>    val <a href="#cv_total_int_mod-val">cv_total_int_mod</a> : thm
<a name="line120"></a>    val <a href="#cv_word_and_loop_def-val">cv_word_and_loop_def</a> : thm
<a name="line121"></a>    val <a href="#cv_word_and_loop_ind-val">cv_word_and_loop_ind</a> : thm
<a name="line122"></a>    val <a href="#cv_word_and_loop_thm-val">cv_word_and_loop_thm</a> : thm
<a name="line123"></a>    val <a href="#cv_word_bit_thm-val">cv_word_bit_thm</a> : thm
<a name="line124"></a>    val <a href="#cv_word_bits_thm-val">cv_word_bits_thm</a> : thm
<a name="line125"></a>    val <a href="#cv_word_concat_thm-val">cv_word_concat_thm</a> : thm
<a name="line126"></a>    val <a href="#cv_word_extract-val">cv_word_extract</a> : thm
<a name="line127"></a>    val <a href="#cv_word_ge_thm-val">cv_word_ge_thm</a> : thm
<a name="line128"></a>    val <a href="#cv_word_gt_thm-val">cv_word_gt_thm</a> : thm
<a name="line129"></a>    val <a href="#cv_word_hi_thm-val">cv_word_hi_thm</a> : thm
<a name="line130"></a>    val <a href="#cv_word_hs_thm-val">cv_word_hs_thm</a> : thm
<a name="line131"></a>    val <a href="#cv_word_join_thm-val">cv_word_join_thm</a> : thm
<a name="line132"></a>    val <a href="#cv_word_le_thm-val">cv_word_le_thm</a> : thm
<a name="line133"></a>    val <a href="#cv_word_lo_thm-val">cv_word_lo_thm</a> : thm
<a name="line134"></a>    val <a href="#cv_word_ls_thm-val">cv_word_ls_thm</a> : thm
<a name="line135"></a>    val <a href="#cv_word_lt_thm-val">cv_word_lt_thm</a> : thm
<a name="line136"></a>    val <a href="#cv_word_or_loop_def-val">cv_word_or_loop_def</a> : thm
<a name="line137"></a>    val <a href="#cv_word_or_loop_ind-val">cv_word_or_loop_ind</a> : thm
<a name="line138"></a>    val <a href="#cv_word_or_loop_thm-val">cv_word_or_loop_thm</a> : thm
<a name="line139"></a>    val <a href="#cv_word_slice_thm-val">cv_word_slice_thm</a> : thm
<a name="line140"></a>    val <a href="#cv_word_xor_loop_def-val">cv_word_xor_loop_def</a> : thm
<a name="line141"></a>    val <a href="#cv_word_xor_loop_ind-val">cv_word_xor_loop_ind</a> : thm
<a name="line142"></a>    val <a href="#cv_word_xor_loop_thm-val">cv_word_xor_loop_thm</a> : thm
<a name="line143"></a>    val <a href="#v2n_custom_def-val">v2n_custom_def</a> : thm
<a name="line144"></a>    val <a href="#v2n_custom_ind-val">v2n_custom_ind</a> : thm
<a name="line145"></a>    val <a href="#v2n_custom_thm-val">v2n_custom_thm</a> : thm
<a name="line146"></a>    val <a href="#word_asr_add-val">word_asr_add</a> : thm
<a name="line147"></a>(*
   [bitstring] Parent theory of "cv_prim"
   
   [cv_rep] Parent theory of "cv_prim"
   
   [integer_word] Parent theory of "cv_prim"
   
   [<a name="cv_abs_def-val"><b>cv_abs_def</b></a>]  Definition
      
      ⊢ ∀i. cv_abs i = cv_if (cv_ispair i) (cv_fst i) i
   
   [<a name="cv_int_add_def-val"><b>cv_int_add_def</b></a>]  Definition
      
      ⊢ ∀i j.
          cv_int_add i j =
          cv_if (cv_ispair i)
            (cv_if (cv_ispair j)
               (Pair (cv_add (cv_fst i) (cv_fst j)) (Num 0))
               (cv_if (cv_int_lt j (cv_fst i))
                  (Pair (cv_sub (cv_fst i) j) (Num 0))
                  (cv_sub j (cv_fst i))))
            (cv_if (cv_ispair j)
               (cv_if (cv_int_lt i (cv_fst j))
                  (Pair (cv_sub (cv_fst j) i) (Num 0))
                  (cv_sub i (cv_fst j))) (cv_add i j))
   
   [<a name="cv_int_div_def-val"><b>cv_int_div_def</b></a>]  Definition
      
      ⊢ ∀i j.
          cv_int_div i j =
          cv_if (cv_ispair j)
            (cv_if (cv_ispair i) (cv_div (cv_fst i) (cv_fst j))
               (cv_int_add (Pair (cv_div i (cv_fst j)) (Num 0))
                  (cv_if (cv_mod i (cv_fst j)) (Pair (Num 1) (Num 0))
                     (Num 0))))
            (cv_if (cv_ispair i)
               (cv_int_add (Pair (cv_div (cv_fst i) j) (Num 0))
                  (cv_if (cv_mod (cv_fst i) j) (Pair (Num 1) (Num 0))
                     (Num 0))) (cv_div i j))
   
   [<a name="cv_int_lt_def-val"><b>cv_int_lt_def</b></a>]  Definition
      
      ⊢ ∀i j.
          cv_int_lt i j =
          cv_if (cv_ispair i)
            (cv_if (cv_ispair j) (cv_lt (cv_abs j) (cv_abs i)) (Num 1))
            (cv_if (cv_ispair j) (Num 0) (cv_lt i j))
   
   [<a name="cv_int_mod_def-val"><b>cv_int_mod_def</b></a>]  Definition
      
      ⊢ ∀i j.
          cv_int_mod i j =
          cv_int_add i (cv_int_neg (cv_int_mul (cv_int_div i j) j))
   
   [<a name="cv_int_mul_def-val"><b>cv_int_mul_def</b></a>]  Definition
      
      ⊢ ∀i j.
          cv_int_mul i j =
          cv_if (cv_eq i (Num 0)) (Num 0)
            (cv_if (cv_eq j (Num 0)) (Num 0)
               (cv_if (cv_ispair i)
                  (cv_if (cv_ispair j) (cv_mul (cv_fst i) (cv_fst j))
                     (Pair (cv_mul (cv_fst i) j) (Num 0)))
                  (cv_if (cv_ispair j) (Pair (cv_mul i (cv_fst j)) (Num 0))
                     (cv_mul i j))))
   
   [<a name="cv_int_neg_def-val"><b>cv_int_neg_def</b></a>]  Definition
      
      ⊢ ∀x. cv_int_neg x =
            cv_if (cv_eq x (Num 0)) x
              (cv_if (cv_ispair x) (cv_fst x) (Pair x (Num 0)))
   
   [<a name="cv_max_def-val"><b>cv_max_def</b></a>]  Definition
      
      ⊢ ∀x y. cv_max x y = cv_if (cv_lt x y) y x
   
   [<a name="cv_min_def-val"><b>cv_min_def</b></a>]  Definition
      
      ⊢ ∀x y. cv_min x y = cv_if (cv_lt x y) x y
   
   [<a name="cv_rat_add_def-val"><b>cv_rat_add_def</b></a>]  Definition
      
      ⊢ ∀r1 r2.
          cv_rat_add r1 r2 =
          cv_rat_norm
            (Pair
               (cv_int_add (cv_int_mul (cv_fst r1) (cv_snd r2))
                  (cv_int_mul (cv_fst r2) (cv_snd r1)))
               (cv_mul (cv_snd r1) (cv_snd r2)))
   
   [<a name="cv_rat_lt_def-val"><b>cv_rat_lt_def</b></a>]  Definition
      
      ⊢ ∀r1 r2.
          cv_rat_lt r1 r2 =
          cv_int_lt (cv_int_mul (cv_fst r1) (cv_snd r2))
            (cv_int_mul (cv_fst r2) (cv_snd r1))
   
   [<a name="cv_rat_mul_def-val"><b>cv_rat_mul_def</b></a>]  Definition
      
      ⊢ ∀r1 r2.
          cv_rat_mul r1 r2 =
          cv_rat_norm
            (Pair (cv_int_mul (cv_fst r1) (cv_fst r2))
               (cv_mul (cv_snd r1) (cv_snd r2)))
   
   [<a name="cv_rat_neg_def-val"><b>cv_rat_neg_def</b></a>]  Definition
      
      ⊢ ∀r. cv_rat_neg r = Pair (cv_int_neg (cv_fst r)) (cv_snd r)
   
   [<a name="cv_rat_norm_def-val"><b>cv_rat_norm_def</b></a>]  Definition
      
      ⊢ ∀r. cv_rat_norm r =
            (let
               d = cv_gcd (cv_abs (cv_fst r)) (cv_snd r)
             in
               cv_if (cv_lt d (Num 2)) r
                 (Pair (cv_total_int_div (cv_fst r) d)
                    (cv_div (cv_snd r) d)))
   
   [<a name="cv_rat_reciprocal_def-val"><b>cv_rat_reciprocal_def</b></a>]  Definition
      
      ⊢ ∀r. cv_rat_reciprocal r =
            cv_if (cv_int_lt (cv_fst r) (Num 0))
              (Pair (Pair (cv_snd r) (Num 0)) (cv_fst (cv_fst r)))
              (Pair (cv_snd r) (cv_fst r))
   
   [<a name="cv_total_int_div_def-val"><b>cv_total_int_div_def</b></a>]  Definition
      
      ⊢ ∀i j.
          cv_total_int_div i j =
          cv_if (cv_eq j (Num 0)) (Num 0) (cv_int_div i j)
   
   [<a name="cv_total_int_mod_def-val"><b>cv_total_int_mod_def</b></a>]  Definition
      
      ⊢ ∀i j.
          cv_total_int_mod i j = cv_if (cv_eq j (Num 0)) i (cv_int_mod i j)
   
   [<a name="cv_word_and_def-val"><b>cv_word_and_def</b></a>]  Definition
      
      ⊢ ∀x y.
          cv_word_and x y =
          cv_if (cv_lt x y) (cv_word_and_loop x y) (cv_word_and_loop y x)
   
   [<a name="cv_word_lt_def-val"><b>cv_word_lt_def</b></a>]  Definition
      
      ⊢ ∀w1 w2 msb1 msb2.
          cv_word_lt w1 w2 msb1 msb2 =
          cv_if (cv_eq msb1 msb2) (cv_lt w1 w2)
            (cv_if msb1 (Num 1) (cv_sub (Num 1) msb2))
   
   [<a name="cv_word_or_def-val"><b>cv_word_or_def</b></a>]  Definition
      
      ⊢ ∀x y.
          cv_word_or x y =
          cv_if (cv_lt x y) (cv_word_or_loop x y) (cv_word_or_loop y x)
   
   [<a name="cv_word_sub_def-val"><b>cv_word_sub_def</b></a>]  Definition
      
      ⊢ ∀x y d.
          cv_word_sub x y d =
          cv_if (cv_lt x y) (cv_sub (cv_add x d) y) (cv_sub x y)
   
   [<a name="cv_word_xor_def-val"><b>cv_word_xor_def</b></a>]  Definition
      
      ⊢ ∀x y.
          cv_word_xor x y =
          cv_if (cv_lt x y) (cv_word_xor_loop x y) (cv_word_xor_loop y x)
   
   [<a name="total_int_div_def-val"><b>total_int_div_def</b></a>]  Definition
      
      ⊢ ∀i j. total_int_div i j = if j = 0 then 0 else i / j
   
   [<a name="total_int_mod_def-val"><b>total_int_mod_def</b></a>]  Definition
      
      ⊢ ∀i j. total_int_mod i j = if j = 0 then i else i % j
   
   [<a name="BITWISE-val"><b>BITWISE</b></a>]  Theorem
      
      ⊢ BITWISE 0 b m n = 0 ∧
        BITWISE (SUC k) b m n =
        (if b (ODD m) (ODD n) then 1 else 0) +
        2 * BITWISE k b (m DIV 2) (n DIV 2)
   
   [<a name="BITWISE_ADD-val"><b>BITWISE_ADD</b></a>]  Theorem
      
      ⊢ ∀l k m n b.
          BITWISE (l + k) b m n =
          BITWISE l b m n +
          BITWISE k b (m DIV 2 ** l) (n DIV 2 ** l) * 2 ** l
   
   [<a name="cv_Num-val"><b>cv_Num</b></a>]  Theorem
      
      ⊢ Num (Num i) = cv_abs (from_int i)
   
   [<a name="cv_chr_thm-val"><b>cv_chr_thm</b></a>]  Theorem
      
      ⊢ n &lt; 256 ⇒ from_char (CHR n) = Num n
   
   [<a name="cv_gcd_def-val"><b>cv_gcd_def</b></a>]  Theorem
      
      ⊢ ∀b a. cv_gcd a b = cv_if a (cv_gcd (cv_mod b a) a) b
   
   [<a name="cv_gcd_ind-val"><b>cv_gcd_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀a b. (c2b a ⇒ P (cv_mod b a) a) ⇒ P a b) ⇒ ∀v v1. P v v1
   
   [<a name="cv_gcd_thm-val"><b>cv_gcd_thm</b></a>]  Theorem
      
      ⊢ Num (gcd a b) = cv_gcd (Num a) (Num b)
   
   [<a name="cv_inline_imp-val"><b>cv_inline_imp</b></a>]  Theorem
      
      ⊢ b2c (a ⇒ b) = cv_if (b2c a) (b2c b) (Num 1)
   
   [<a name="cv_inline_v2n-val"><b>cv_inline_v2n</b></a>]  Theorem
      
      ⊢ v2n = v2n_custom 0
   
   [<a name="cv_inline_v2w-val"><b>cv_inline_v2w</b></a>]  Theorem
      
      ⊢ ∀v. v2w v = n2w (v2n_custom 0 v)
   
   [<a name="cv_inline_w2i-val"><b>cv_inline_w2i</b></a>]  Theorem
      
      ⊢ w2i w = (let v = w in if word_msb v then -&w2n (-v) else &w2n v)
   
   [<a name="cv_inline_w2v-val"><b>cv_inline_w2v</b></a>]  Theorem
      
      ⊢ w2v w =
        (let d = dimindex (:α) in GENLIST (λi. word_bit (d − 1 − i) w) d)
   
   [<a name="cv_inline_word_log2-val"><b>cv_inline_word_log2</b></a>]  Theorem
      
      ⊢ ∀w. word_log2 w = n2w (LOG2 (w2n w))
   
   [<a name="cv_inline_word_ror-val"><b>cv_inline_word_ror</b></a>]  Theorem
      
      ⊢ ∀r a.
          a ⇄ r =
          (let
             a = a;
             d = dimindex (:α);
             r = r MOD d
           in
             a ≪ (d − r) ‖ a ⋙ r)
   
   [<a name="cv_inline_word_sw2sw-val"><b>cv_inline_word_sw2sw</b></a>]  Theorem
      
      ⊢ sw2sw w =
        (let
           v = w
         in
           (if word_msb v then -1w ≪ dimindex (:α) else 0w) + w2w v)
   
   [<a name="cv_int_add-val"><b>cv_int_add</b></a>]  Theorem
      
      ⊢ from_int (i + j) = cv_int_add (from_int i) (from_int j)
   
   [<a name="cv_int_div-val"><b>cv_int_div</b></a>]  Theorem
      
      ⊢ j ≠ 0 ⇒ from_int (i / j) = cv_int_div (from_int i) (from_int j)
   
   [<a name="cv_int_ge-val"><b>cv_int_ge</b></a>]  Theorem
      
      ⊢ b2c (i ≥ j) =
        cv_if (cv_int_lt (from_int i) (from_int j)) (Num 0) (Num 1)
   
   [<a name="cv_int_gt-val"><b>cv_int_gt</b></a>]  Theorem
      
      ⊢ b2c (i &gt; j) = cv_int_lt (from_int j) (from_int i)
   
   [<a name="cv_int_le-val"><b>cv_int_le</b></a>]  Theorem
      
      ⊢ b2c (i ≤ j) =
        cv_if (cv_int_lt (from_int j) (from_int i)) (Num 0) (Num 1)
   
   [<a name="cv_int_lt-val"><b>cv_int_lt</b></a>]  Theorem
      
      ⊢ b2c (i &lt; j) = cv_int_lt (from_int i) (from_int j)
   
   [<a name="cv_int_mod-val"><b>cv_int_mod</b></a>]  Theorem
      
      ⊢ j ≠ 0 ⇒ from_int (i % j) = cv_int_mod (from_int i) (from_int j)
   
   [<a name="cv_int_mul-val"><b>cv_int_mul</b></a>]  Theorem
      
      ⊢ from_int (i * j) = cv_int_mul (from_int i) (from_int j)
   
   [<a name="cv_int_of_num-val"><b>cv_int_of_num</b></a>]  Theorem
      
      ⊢ from_int (&n) = Num n
   
   [<a name="cv_int_sub-val"><b>cv_int_sub</b></a>]  Theorem
      
      ⊢ from_int (i − j) =
        cv_int_add (from_int i) (cv_int_neg (from_int j))
   
   [<a name="cv_log2_def-val"><b>cv_log2_def</b></a>]  Theorem
      
      ⊢ ∀n acc.
          cv_log2 acc n =
          cv_if (cv_lt (Num 1) n)
            (cv_log2 (cv_add acc (Num 1)) (cv_div n (Num 2))) acc
   
   [<a name="cv_log2_ind-val"><b>cv_log2_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀acc n.
               (c2b (cv_lt (Num 1) n) ⇒
                P (cv_add acc (Num 1)) (cv_div n (Num 2))) ⇒
               P acc n) ⇒
            ∀v v1. P v v1
   
   [<a name="cv_max_thm-val"><b>cv_max_thm</b></a>]  Theorem
      
      ⊢ Num (MAX m n) = cv_max (Num m) (Num n)
   
   [<a name="cv_min_thm-val"><b>cv_min_thm</b></a>]  Theorem
      
      ⊢ Num (MIN m n) = cv_min (Num m) (Num n)
   
   [<a name="cv_neg_int-val"><b>cv_neg_int</b></a>]  Theorem
      
      ⊢ from_int (-x) = cv_int_neg (from_int x)
   
   [<a name="cv_ord_thm-val"><b>cv_ord_thm</b></a>]  Theorem
      
      ⊢ Num (ORD c) = from_char c
   
   [<a name="cv_rat_add-val"><b>cv_rat_add</b></a>]  Theorem
      
      ⊢ from_rat (r1 + r2) = cv_rat_add (from_rat r1) (from_rat r2)
   
   [<a name="cv_rat_div-val"><b>cv_rat_div</b></a>]  Theorem
      
      ⊢ r2 ≠ 0 ⇒
        from_rat (r1 / r2) =
        cv_rat_mul (from_rat r1) (cv_rat_reciprocal (from_rat r2))
   
   [<a name="cv_rat_ge-val"><b>cv_rat_ge</b></a>]  Theorem
      
      ⊢ b2c (r1 ≥ r2) =
        cv_if (cv_rat_lt (from_rat r1) (from_rat r2)) (Num 0) (Num 1)
   
   [<a name="cv_rat_gt-val"><b>cv_rat_gt</b></a>]  Theorem
      
      ⊢ b2c (r1 &gt; r2) = cv_rat_lt (from_rat r2) (from_rat r1)
   
   [<a name="cv_rat_le-val"><b>cv_rat_le</b></a>]  Theorem
      
      ⊢ b2c (r1 ≤ r2) =
        cv_if (cv_rat_lt (from_rat r2) (from_rat r1)) (Num 0) (Num 1)
   
   [<a name="cv_rat_lt-val"><b>cv_rat_lt</b></a>]  Theorem
      
      ⊢ b2c (r1 &lt; r2) = cv_rat_lt (from_rat r1) (from_rat r2)
   
   [<a name="cv_rat_mul-val"><b>cv_rat_mul</b></a>]  Theorem
      
      ⊢ from_rat (r1 * r2) = cv_rat_mul (from_rat r1) (from_rat r2)
   
   [<a name="cv_rat_neg-val"><b>cv_rat_neg</b></a>]  Theorem
      
      ⊢ from_rat (-r) = cv_rat_neg (from_rat r)
   
   [<a name="cv_rat_norm_div_gcd-val"><b>cv_rat_norm_div_gcd</b></a>]  Theorem
      
      ⊢ (λ(x,y). Pair (from_int x) (Num y)) (div_gcd a b) =
        cv_rat_norm (Pair (from_int a) (Num b))
   
   [<a name="cv_rat_of_int-val"><b>cv_rat_of_int</b></a>]  Theorem
      
      ⊢ from_rat (rat_of_int i) = Pair (from_int i) (Num 1)
   
   [<a name="cv_rat_reciprocal-val"><b>cv_rat_reciprocal</b></a>]  Theorem
      
      ⊢ r ≠ 0 ⇒ from_rat (rat_minv r) = cv_rat_reciprocal (from_rat r)
   
   [<a name="cv_rat_sub-val"><b>cv_rat_sub</b></a>]  Theorem
      
      ⊢ from_rat (r1 − r2) =
        cv_rat_add (from_rat r1) (cv_rat_neg (from_rat r2))
   
   [<a name="cv_rep_F-val"><b>cv_rep_F</b></a>]  Theorem
      
      ⊢ b2c F = Num 0
   
   [<a name="cv_rep_LOG2-val"><b>cv_rep_LOG2</b></a>]  Theorem
      
      ⊢ n ≠ 0 ⇒ Num (LOG2 n) = cv_log2 (Num 0) (Num n)
   
   [<a name="cv_rep_T-val"><b>cv_rep_T</b></a>]  Theorem
      
      ⊢ b2c T = Num 1
   
   [<a name="cv_rep_add-val"><b>cv_rep_add</b></a>]  Theorem
      
      ⊢ Num (n + m) = cv_add (Num n) (Num m)
   
   [<a name="cv_rep_and-val"><b>cv_rep_and</b></a>]  Theorem
      
      ⊢ b2c (b1 ∧ b2) = cv_if (b2c b1) (b2c b2) (Num 0)
   
   [<a name="cv_rep_arb-val"><b>cv_rep_arb</b></a>]  Theorem
      
      ⊢ F ⇒ f ARB = Num 0
   
   [<a name="cv_rep_dimindex-val"><b>cv_rep_dimindex</b></a>]  Theorem
      
      ⊢ Num (dimindex (:α)) = Num (dimindex (:α))
   
   [<a name="cv_rep_div-val"><b>cv_rep_div</b></a>]  Theorem
      
      ⊢ Num (n DIV m) = cv_div (Num n) (Num m)
   
   [<a name="cv_rep_eq-val"><b>cv_rep_eq</b></a>]  Theorem
      
      ⊢ cv_rep p1 c1 f x ∧ cv_rep p2 c2 f y ∧ from_to f t ⇒
        cv_rep (p1 ∧ p2) (cv_eq c1 c2) b2c (x = y)
   
   [<a name="cv_rep_even-val"><b>cv_rep_even</b></a>]  Theorem
      
      ⊢ b2c (EVEN n) = cv_sub (Num 1) (cv_mod (Num n) (Num 2))
   
   [<a name="cv_rep_exp-val"><b>cv_rep_exp</b></a>]  Theorem
      
      ⊢ Num (n ** m) = cv_exp (Num n) (Num m)
   
   [<a name="cv_rep_ge-val"><b>cv_rep_ge</b></a>]  Theorem
      
      ⊢ b2c (n ≥ m) = cv_sub (Num 1) (cv_lt (Num n) (Num m))
   
   [<a name="cv_rep_gt-val"><b>cv_rep_gt</b></a>]  Theorem
      
      ⊢ b2c (n &gt; m) = cv_lt (Num m) (Num n)
   
   [<a name="cv_rep_if-val"><b>cv_rep_if</b></a>]  Theorem
      
      ⊢ cv_rep p1 c1 b2c b ∧ cv_rep p2 c2 f t ∧ cv_rep p3 c3 f e ⇒
        cv_rep (p1 ∧ (b ⇒ p2) ∧ (¬b ⇒ p3)) (cv_if c1 c2 c3) f
          (if b then t else e)
   
   [<a name="cv_rep_le-val"><b>cv_rep_le</b></a>]  Theorem
      
      ⊢ b2c (n ≤ m) = cv_sub (Num 1) (cv_lt (Num m) (Num n))
   
   [<a name="cv_rep_let-val"><b>cv_rep_let</b></a>]  Theorem
      
      ⊢ cv_rep p1 c1 a x ∧ (∀v. cv_rep (p2 v) (c2 (a v)) b (y v)) ⇒
        cv_rep (p1 ∧ ∀v. v = x ⇒ p2 v) (LET c2 c1) b (LET y x)
   
   [<a name="cv_rep_lt-val"><b>cv_rep_lt</b></a>]  Theorem
      
      ⊢ b2c (n &lt; m) = cv_lt (Num n) (Num m)
   
   [<a name="cv_rep_mod-val"><b>cv_rep_mod</b></a>]  Theorem
      
      ⊢ Num (n MOD m) = cv_mod (Num n) (Num m)
   
   [<a name="cv_rep_mul-val"><b>cv_rep_mul</b></a>]  Theorem
      
      ⊢ Num (n * m) = cv_mul (Num n) (Num m)
   
   [<a name="cv_rep_not-val"><b>cv_rep_not</b></a>]  Theorem
      
      ⊢ b2c (¬b1) = cv_sub (Num 1) (b2c b1)
   
   [<a name="cv_rep_num_case-val"><b>cv_rep_num_case</b></a>]  Theorem
      
      ⊢ cv_rep p1 c1 Num x ∧ cv_rep p2 c2 a y ∧
        (∀v. cv_rep (p3 v) (c3 (Num v)) a (z v)) ⇒
        cv_rep (p1 ∧ (x = 0 ⇒ p2) ∧ ∀n. x = SUC n ⇒ p3 n)
          (cv_if (cv_lt (Num 0) c1) (let y = cv_sub c1 (Num 1) in c3 y) c2)
          a (num_CASE x y z)
   
   [<a name="cv_rep_odd-val"><b>cv_rep_odd</b></a>]  Theorem
      
      ⊢ b2c (ODD n) = cv_mod (Num n) (Num 2)
   
   [<a name="cv_rep_or-val"><b>cv_rep_or</b></a>]  Theorem
      
      ⊢ b2c (b1 ∨ b2) = cv_if (b2c b1) (Num 1) (b2c b2)
   
   [<a name="cv_rep_sub-val"><b>cv_rep_sub</b></a>]  Theorem
      
      ⊢ Num (n − m) = cv_sub (Num n) (Num m)
   
   [<a name="cv_rep_sub1-val"><b>cv_rep_sub1</b></a>]  Theorem
      
      ⊢ Num (PRE n) = cv_sub (Num n) (Num 1)
   
   [<a name="cv_rep_suc-val"><b>cv_rep_suc</b></a>]  Theorem
      
      ⊢ Num (SUC n) = cv_add (Num n) (Num 1)
   
   [<a name="cv_rep_word_add-val"><b>cv_rep_word_add</b></a>]  Theorem
      
      ⊢ from_word (w1 + w2) =
        cv_mod (cv_add (from_word w1) (from_word w2)) (Num (dimword (:α)))
   
   [<a name="cv_rep_word_and-val"><b>cv_rep_word_and</b></a>]  Theorem
      
      ⊢ from_word (w1 && w2) = cv_word_and (from_word w1) (from_word w2)
   
   [<a name="cv_rep_word_div-val"><b>cv_rep_word_div</b></a>]  Theorem
      
      ⊢ from_word (w1 // w2) = cv_div (from_word w1) (from_word w2)
   
   [<a name="cv_rep_word_lsl-val"><b>cv_rep_word_lsl</b></a>]  Theorem
      
      ⊢ from_word (w ≪ n) =
        cv_mod (cv_mul (from_word w) (cv_exp (Num 2) (Num n)))
          (Num (2 ** dimindex (:α)))
   
   [<a name="cv_rep_word_lsr-val"><b>cv_rep_word_lsr</b></a>]  Theorem
      
      ⊢ from_word (w ⋙ n) =
        (let
           k = Num n
         in
           cv_if (cv_lt k (Num (dimindex (:α))))
             (cv_div (from_word w) (cv_exp (Num 2) k)) (Num 0))
   
   [<a name="cv_rep_word_mod-val"><b>cv_rep_word_mod</b></a>]  Theorem
      
      ⊢ from_word (word_mod w1 w2) = cv_mod (from_word w1) (from_word w2)
   
   [<a name="cv_rep_word_msb-val"><b>cv_rep_word_msb</b></a>]  Theorem
      
      ⊢ b2c (word_msb w) =
        cv_div (from_word w) (Num (2 ** (dimindex (:α) − 1)))
   
   [<a name="cv_rep_word_mul-val"><b>cv_rep_word_mul</b></a>]  Theorem
      
      ⊢ from_word (w1 * w2) =
        cv_mod (cv_mul (from_word w1) (from_word w2)) (Num (dimword (:α)))
   
   [<a name="cv_rep_word_n2w-val"><b>cv_rep_word_n2w</b></a>]  Theorem
      
      ⊢ from_word (n2w n) = cv_mod (Num n) (Num (2 ** dimindex (:α)))
   
   [<a name="cv_rep_word_neg-val"><b>cv_rep_word_neg</b></a>]  Theorem
      
      ⊢ from_word (-w1) =
        cv_word_sub (Num 0) (from_word w1) (Num (dimword (:α)))
   
   [<a name="cv_rep_word_not-val"><b>cv_rep_word_not</b></a>]  Theorem
      
      ⊢ from_word (¬w) =
        cv_word_xor (from_word w) (Num (2 ** dimindex (:α) − 1))
   
   [<a name="cv_rep_word_or-val"><b>cv_rep_word_or</b></a>]  Theorem
      
      ⊢ from_word (w1 ‖ w2) = cv_word_or (from_word w1) (from_word w2)
   
   [<a name="cv_rep_word_sub-val"><b>cv_rep_word_sub</b></a>]  Theorem
      
      ⊢ from_word (w1 − w2) =
        cv_word_sub (from_word w1) (from_word w2) (Num (dimword (:α)))
   
   [<a name="cv_rep_word_uint_max-val"><b>cv_rep_word_uint_max</b></a>]  Theorem
      
      ⊢ from_word UINT_MAXw = Num (2 ** dimindex (:α) − 1)
   
   [<a name="cv_rep_word_w2n-val"><b>cv_rep_word_w2n</b></a>]  Theorem
      
      ⊢ Num (w2n w) = from_word w
   
   [<a name="cv_rep_word_w2w-val"><b>cv_rep_word_w2w</b></a>]  Theorem
      
      ⊢ from_word (w2w w) =
        if dimindex (:α) ≤ dimindex (:β) then from_word w
        else cv_mod (from_word w) (Num (2 ** dimindex (:β)))
   
   [<a name="cv_rep_word_xor-val"><b>cv_rep_word_xor</b></a>]  Theorem
      
      ⊢ from_word (w1 ⊕ w2) = cv_word_xor (from_word w1) (from_word w2)
   
   [<a name="cv_total_int_div-val"><b>cv_total_int_div</b></a>]  Theorem
      
      ⊢ from_int (total_int_div i j) =
        cv_total_int_div (from_int i) (from_int j)
   
   [<a name="cv_total_int_mod-val"><b>cv_total_int_mod</b></a>]  Theorem
      
      ⊢ from_int (total_int_mod i j) =
        cv_total_int_mod (from_int i) (from_int j)
   
   [<a name="cv_word_and_loop_def-val"><b>cv_word_and_loop_def</b></a>]  Theorem
      
      ⊢ ∀y x.
          cv_word_and_loop x y =
          cv_if (cv_lt (Num 0) x)
            (cv_add
               (cv_mul (Num 2)
                  (cv_word_and_loop (cv_div x (Num 2)) (cv_div y (Num 2))))
               (cv_div (cv_add (cv_mod x (Num 2)) (cv_mod y (Num 2)))
                  (Num 2))) (Num 0)
   
   [<a name="cv_word_and_loop_ind-val"><b>cv_word_and_loop_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀x y.
               (c2b (cv_lt (Num 0) x) ⇒
                P (cv_div x (Num 2)) (cv_div y (Num 2))) ⇒
               P x y) ⇒
            ∀v v1. P v v1
   
   [<a name="cv_word_and_loop_thm-val"><b>cv_word_and_loop_thm</b></a>]  Theorem
      
      ⊢ ∀m n.
          m ≤ n ∧ n &lt; dimword (:α) ⇒
          cv_word_and_loop (Num m) (Num n) = Num (w2n (n2w m && n2w n))
   
   [<a name="cv_word_bit_thm-val"><b>cv_word_bit_thm</b></a>]  Theorem
      
      ⊢ b2c (word_bit b w) =
        cv_mod (cv_div (from_word w) (cv_exp (Num 2) (Num b))) (Num 2)
   
   [<a name="cv_word_bits_thm-val"><b>cv_word_bits_thm</b></a>]  Theorem
      
      ⊢ from_word ((h -- l) w) =
        cv_div
          (cv_mod (from_word w)
             (cv_exp (Num 2)
                (cv_min (cv_add (Num h) (Num 1)) (Num (dimindex (:α))))))
          (cv_exp (Num 2) (Num l))
   
   [<a name="cv_word_concat_thm-val"><b>cv_word_concat_thm</b></a>]  Theorem
      
      ⊢ FINITE 𝕌(:α) ∧ FINITE 𝕌(:β) ⇒
        from_word (w1 @@ w2) =
        if dimindex (:α) + dimindex (:β) ≤ dimindex (:γ) then
          cv_add
            (cv_mul (from_word w1) (cv_exp (Num 2) (Num (dimindex (:β)))))
            (from_word w2)
        else
          cv_mod
            (cv_add
               (cv_mul (from_word w1)
                  (cv_exp (Num 2) (Num (dimindex (:β))))) (from_word w2))
            (Num (2 ** dimindex (:γ)))
   
   [<a name="cv_word_extract-val"><b>cv_word_extract</b></a>]  Theorem
      
      ⊢ from_word ((h &gt;&lt; l) w) =
        if dimindex (:α) ≤ dimindex (:β) then
          cv_div
            (cv_mod (from_word w)
               (cv_exp (Num 2)
                  (cv_min (cv_add (Num h) (Num 1)) (Num (dimindex (:α))))))
            (cv_exp (Num 2) (Num l))
        else
          cv_mod
            (cv_div
               (cv_mod (from_word w)
                  (cv_exp (Num 2)
                     (cv_min (cv_add (Num h) (Num 1)) (Num (dimindex (:α))))))
               (cv_exp (Num 2) (Num l))) (Num (2 ** dimindex (:β)))
   
   [<a name="cv_word_ge_thm-val"><b>cv_word_ge_thm</b></a>]  Theorem
      
      ⊢ b2c (w1 ≥ w2) =
        cv_sub (Num 1)
          (cv_word_lt (from_word w1) (from_word w2)
             (cv_div (from_word w1) (Num (2 ** (dimindex (:α) − 1))))
             (cv_div (from_word w2) (Num (2 ** (dimindex (:α) − 1)))))
   
   [<a name="cv_word_gt_thm-val"><b>cv_word_gt_thm</b></a>]  Theorem
      
      ⊢ b2c (w2 &gt; w1) =
        cv_word_lt (from_word w1) (from_word w2)
          (cv_div (from_word w1) (Num (2 ** (dimindex (:α) − 1))))
          (cv_div (from_word w2) (Num (2 ** (dimindex (:α) − 1))))
   
   [<a name="cv_word_hi_thm-val"><b>cv_word_hi_thm</b></a>]  Theorem
      
      ⊢ b2c (w2 &gt;₊ w1) = cv_lt (from_word w1) (from_word w2)
   
   [<a name="cv_word_hs_thm-val"><b>cv_word_hs_thm</b></a>]  Theorem
      
      ⊢ b2c (w1 ≥₊ w2) =
        cv_sub (Num 1) (cv_lt (from_word w1) (from_word w2))
   
   [<a name="cv_word_join_thm-val"><b>cv_word_join_thm</b></a>]  Theorem
      
      ⊢ FINITE 𝕌(:α) ∧ FINITE 𝕌(:β) ⇒
        from_word (word_join w1 w2) =
        cv_add
          (cv_mul (from_word w1) (cv_exp (Num 2) (Num (dimindex (:β)))))
          (from_word w2)
   
   [<a name="cv_word_le_thm-val"><b>cv_word_le_thm</b></a>]  Theorem
      
      ⊢ b2c (w2 ≤ w1) =
        cv_sub (Num 1)
          (cv_word_lt (from_word w1) (from_word w2)
             (cv_div (from_word w1) (Num (2 ** (dimindex (:α) − 1))))
             (cv_div (from_word w2) (Num (2 ** (dimindex (:α) − 1)))))
   
   [<a name="cv_word_lo_thm-val"><b>cv_word_lo_thm</b></a>]  Theorem
      
      ⊢ b2c (w1 &lt;₊ w2) = cv_lt (from_word w1) (from_word w2)
   
   [<a name="cv_word_ls_thm-val"><b>cv_word_ls_thm</b></a>]  Theorem
      
      ⊢ b2c (w1 ≤₊ w2) =
        cv_sub (Num 1) (cv_lt (from_word w2) (from_word w1))
   
   [<a name="cv_word_lt_thm-val"><b>cv_word_lt_thm</b></a>]  Theorem
      
      ⊢ b2c (w1 &lt; w2) =
        cv_word_lt (from_word w1) (from_word w2)
          (cv_div (from_word w1) (Num (2 ** (dimindex (:α) − 1))))
          (cv_div (from_word w2) (Num (2 ** (dimindex (:α) − 1))))
   
   [<a name="cv_word_or_loop_def-val"><b>cv_word_or_loop_def</b></a>]  Theorem
      
      ⊢ ∀y x.
          cv_word_or_loop x y =
          cv_if (cv_lt (Num 0) x)
            (cv_add
               (cv_mul (Num 2)
                  (cv_word_or_loop (cv_div x (Num 2)) (cv_div y (Num 2))))
               (cv_max (cv_mod x (Num 2)) (cv_mod y (Num 2)))) y
   
   [<a name="cv_word_or_loop_ind-val"><b>cv_word_or_loop_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀x y.
               (c2b (cv_lt (Num 0) x) ⇒
                P (cv_div x (Num 2)) (cv_div y (Num 2))) ⇒
               P x y) ⇒
            ∀v v1. P v v1
   
   [<a name="cv_word_or_loop_thm-val"><b>cv_word_or_loop_thm</b></a>]  Theorem
      
      ⊢ ∀m n.
          m ≤ n ∧ n &lt; dimword (:α) ⇒
          cv_word_or_loop (Num m) (Num n) = Num (w2n (n2w m ‖ n2w n))
   
   [<a name="cv_word_slice_thm-val"><b>cv_word_slice_thm</b></a>]  Theorem
      
      ⊢ from_word ((h '' l) w) =
        cv_mod
          (cv_mul
             (cv_div
                (cv_mod (from_word w)
                   (cv_exp (Num 2)
                      (cv_min (cv_add (Num h) (Num 1))
                         (Num (dimindex (:α)))))) (cv_exp (Num 2) (Num l)))
             (cv_exp (Num 2) (Num l))) (Num (dimword (:α)))
   
   [<a name="cv_word_xor_loop_def-val"><b>cv_word_xor_loop_def</b></a>]  Theorem
      
      ⊢ ∀y x.
          cv_word_xor_loop x y =
          cv_if (cv_lt (Num 0) x)
            (cv_add
               (cv_mul (Num 2)
                  (cv_word_xor_loop (cv_div x (Num 2)) (cv_div y (Num 2))))
               (cv_mod (cv_add (cv_mod x (Num 2)) (cv_mod y (Num 2)))
                  (Num 2))) y
   
   [<a name="cv_word_xor_loop_ind-val"><b>cv_word_xor_loop_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀x y.
               (c2b (cv_lt (Num 0) x) ⇒
                P (cv_div x (Num 2)) (cv_div y (Num 2))) ⇒
               P x y) ⇒
            ∀v v1. P v v1
   
   [<a name="cv_word_xor_loop_thm-val"><b>cv_word_xor_loop_thm</b></a>]  Theorem
      
      ⊢ ∀m n.
          m ≤ n ∧ n &lt; dimword (:α) ⇒
          cv_word_xor_loop (Num m) (Num n) = Num (w2n (n2w m ⊕ n2w n))
   
   [<a name="v2n_custom_def-val"><b>v2n_custom_def</b></a>]  Theorem
      
      ⊢ (∀acc. v2n_custom acc [] = acc) ∧
        (∀rest acc.
           v2n_custom acc (T::rest) = v2n_custom (2 * acc + 1) rest) ∧
        ∀rest acc. v2n_custom acc (F::rest) = v2n_custom (2 * acc) rest
   
   [<a name="v2n_custom_ind-val"><b>v2n_custom_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀acc. P acc []) ∧
            (∀acc rest. P (2 * acc + 1) rest ⇒ P acc (T::rest)) ∧
            (∀acc rest. P (2 * acc) rest ⇒ P acc (F::rest)) ⇒
            ∀v v1. P v v1
   
   [<a name="v2n_custom_thm-val"><b>v2n_custom_thm</b></a>]  Theorem
      
      ⊢ v2n_custom 0 = v2n
   
   [<a name="word_asr_add-val"><b>word_asr_add</b></a>]  Theorem
      
      ⊢ w ≫ n =
        (let
           x = w
         in
           if word_msb x then
             (dimindex (:α) − 1 '' dimindex (:α) − n) UINT_MAXw + x ⋙ n
           else x ⋙ n)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/num/theories/cv_compute/automation/.hol/objs/cv_primScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Trindemossen-2</a></em></p></body></html>
