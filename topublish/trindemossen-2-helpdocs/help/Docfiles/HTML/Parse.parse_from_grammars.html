<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Parse.parse_from_grammars</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<h2 id="parse_from_grammars"><code>parse_from_grammars</code></h2>
<pre class="hol4"><code>Parse.parse_from_grammars :
  (type_grammar.grammar * term_grammar.grammar) -&gt;
  ((hol_type frag list -&gt; hol_type) * (term frag list -&gt; term))</code></pre>
<hr />
<p>Returns parsing functions based on the supplied grammars.</p>
<p>When given a pair consisting of a type and a term grammar, this
function returns parsing functions that use those grammars to turn
strings (strictly, quotations) into types and terms respectively.</p>
<h3 id="failure">Failure</h3>
<p>Canâ€™t fail immediately. However, when the precedence matrix for the
term parser is built on first application of the term parser, this may
generate precedence conflict errors depending on the rules in the
grammar.</p>
<h3 id="example">Example</h3>
<p>First the user loads <code>arithmeticTheory</code> to augment the
built-in grammar with the ability to lex numerals and deal with symbols
such as <code>+</code> and <code>-</code>:</p>
<pre class="hol4"><code>   - load &quot;arithmeticTheory&quot;;
   &gt; val it = () : unit
   - val t = Term`2 + 3`;
   &gt; val t = `2 + 3` : term</code></pre>
<p>Then the <code>parse_from_grammars</code> function is used to make
the values <code>Type</code> and <code>Term</code> use the grammar
present in the simpler theory of booleans. Using this function fails to
parse numerals or even the <code>+</code> infix:</p>
<pre class="hol4"><code>   - val (Type,Term) = parse_from_grammars boolTheory.bool_grammars;
   &gt; val Type = fn : hol_type frag list -&gt; hol_type
     val Term = fn : term frag list -&gt; term
   - Term`2 + 3`;
   &lt;&lt;HOL message: No numerals currently allowed.&gt;&gt;
   ! Uncaught exception:
   ! HOL_ERR &lt;poly&gt;
   - Term`x + y`;
   &lt;&lt;HOL message: inventing new type variable names: &#39;a, &#39;b.&gt;&gt;
   &gt; val it = `x $+ y` : term</code></pre>
<p>But, as the last example above also demonstrates, the installed
pretty-printer is still dependent on the global grammar, and the global
value of <code>Term</code> can still be accessed through the
<code>Parse</code> structure:</p>
<pre class="hol4"><code>   - t;
   &gt; val it = `2 + 3` : term

   - Parse.Term`2 + 3`;
   &gt; val it = `2 + 3` : term</code></pre>
<p>This function is used to ensure that library code has access to a
term parser that is a known quantity. In particular, it is not good form
to have library code that depends on the default parsers
<code>Term</code> and <code>Type</code>. When the library is loaded,
which may happen at any stage, these global values may be such that the
parsing causes quite unexpected results or failures.</p>
<h3 id="see-also">See also</h3>
<p><a href="Parse.add_rule.html"><code>Parse.add_rule</code></a>, <a
href="Parse.print_from_grammars.html"><code>Parse.print_from_grammars</code></a>,
<a href="Parse.Term.html"><code>Parse.Term</code></a></p>
</body>
</html>
