<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>bossLib.SIMP_CONV</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<h2 id="simp_conv"><code>SIMP_CONV</code></h2>
<pre class="hol4"><code>bossLib.SIMP_CONV : simpset -&gt; thm list -&gt; conv</code></pre>
<hr />
<p>Applies a simpset and a list of rewrite rules to simplify a term.</p>
<p><code>SIMP_CONV</code> is the fundamental engine of the HOL
simplification library. It repeatedly applies the transformations
included in the provided simpset (which is augmented with the given
rewrite rules) to a term, ultimately yielding a theorem equating the
original term to another.</p>
<p>Values of the <code>simpset</code> type embody a suite of different
transformations that might be applicable to given terms. These
“transformational components” are rewrites, conversions, AC-rules,
congruences, decision procedures and a filter, which is used to modify
the way in which rewrite rules are added to the simpset. The exact types
for these components, known as simpset fragments, and the way they can
be combined to create simpsets is given in the reference entry for
<code>SSFRAG</code>.</p>
<p>Rewrite rules are used similarly to the way in they are used in the
rewriting system (<code>REWRITE_TAC</code> et al.). These are equational
theorems oriented to rewrite from left-hand-side to right-hand-side.
Further, <code>SIMP_CONV</code> handles obvious problems. If a rewrite
rule is of the general form <code>[...] |- x = f x</code>, then it will
be discarded, and a message is printed to this effect. On the other
hand, if the right-hand-side is a permutation of the pattern on the
left, as in <code>|- x + y = y + x</code> and
<code>|- x INSERT (y INSERT s) = y INSERT (x INSERT s)</code>, then such
rules will only be applied if the term to which they are being applied
is strictly reduced according to some term ordering.</p>
<p>Rewriting is done using a form of higher-order matching, and also
uses conditional rewriting. This latter means that theorems of the form
<code>|- P ==&gt; (x = y)</code> can be used as rewrites. If a term
matching <code>x</code> is found, the simplifier will attempt to satisfy
the side-condition <code>P</code>. If it is able to do so, then the
rewriting will be performed. In the process of attempting to rewrite
<code>P</code> to true, further side conditions may be generated. The
simplifier limits the size of the stack of side conditions to be solved
(the reference variable <code>Cond_rewr.stack_limit</code> holds this
limit), so this will not introduce an infinite loop.</p>
<p>Rewrite rules can always be added “on the fly” as all of the
simplification functions take a <code>thm list</code> argument where
these rules can be specified. If a set of rewrite rules is frequently
used, then these should probably be made into a <code>ssfrag</code>
value with the <code>rewrites</code> function and then added to an
existing simpset with <code>++</code>.</p>
<p>The conversions which are part of simpsets are useful for situations
where simple rewriting is not enough to transform certain terms. For
example, the <code>BETA_CONV</code> conversion is not expressible as a
standard first order rewrite, but is part of the <code>bool_ss</code>
simpset and the application of this simpset will thus simplify all
occurrences of <code>(\x. e1) e2</code>.</p>
<p>In fact, conversions in simpsets are not typically applied
indiscriminately to all sub-terms. (If a conversion is applied to an
inappropriate sub-term and fails, this failure is caught by the
simplifier and ignored.) Instead, conversions in simpsets are
accompanied by a term-pattern which specifies the sort of situations in
which they should be applied. This facility is used in the definition of
<code>bool_ss</code> to include <code>ETA_CONV</code>, but stop it from
transforming <code>!x. P x</code> into <code>$! P</code>.</p>
<p>AC-rules allow simpsets to be constructed that automatically
normalise terms involving associative and commutative operators, again
according to some arbitrary term ordering metric.</p>
<p>Congruence rules allow <code>SIMP_CONV</code> to assume additional
context as a term is rewritten. In a term such as
<code>P ==&gt; Q /\ f x</code> the truth of term P may be assumed as an
additional piece of context in the rewriting of <code>Q /\ f x</code>.
The congruence theorem that states this is valid is
(<code>IMP_CONG</code>):</p>
<pre class="hol4"><code>   |- (P = P&#39;) ==&gt; (P&#39; ==&gt; (Q = Q&#39;)) ==&gt; ((P ==&gt; Q) = (P&#39; ==&gt; Q&#39;))</code></pre>
<p>Other congruence theorems can be part of simpsets. The system
provides <code>IMP_CONG</code> above and <code>COND_CONG</code> as part
of the <code>CONG_ss</code> <code>ssfrag</code> value. (These
<code>simpset</code> fragments can be incorporated into simpsets with
the <code>++</code> function.) Other congruence theorems are already
proved for operators such as conjunction and disjunction, but use of
these in standard simpsets is not recommended as the computation of all
the additional contexts for a simple chain of conjuncts or disjuncts can
be very computationally intensive.</p>
<p>Decision procedures in simpsets are similar to conversions. They are
arbitrary pieces of code that are applied to sub-terms at low priority.
They are given access to the wider context through a list of relevant
theorems. The <code>arith_ss</code> simpset includes an arithmetic
decision procedure implemented in this way.</p>
<h3 id="failure">Failure</h3>
<p><code>SIMP_CONV</code> never fails, but may diverge.</p>
<h3 id="example">Example</h3>
<pre class="hol4"><code>- SIMP_CONV arith_ss [] ``(\x. x + 3) 4``;
&gt; val it = |- (\x. x + 3) 4 = 7 : thm</code></pre>
<p><code>SIMP_CONV</code> is a powerful way of manipulating terms. Other
functions in the simplification library provide the same facilities when
in the contexts of goals and tactics (<code>SIMP_TAC</code>,
<code>ASM_SIMP_TAC</code> etc.), and theorems (<code>SIMP_RULE</code>),
but <code>SIMP_CONV</code> provides the underlying functionality, and is
useful in its own right, just as conversions are generally.</p>
<h3 id="see-also">See also</h3>
<p><a href="bossLib..KAL.html"><code>bossLib.++</code></a>, <a
href="bossLib.ASM_SIMP_TAC.html"><code>bossLib.ASM_SIMP_TAC</code></a>,
<a
href="bossLib.FULL_SIMP_TAC.html"><code>bossLib.FULL_SIMP_TAC</code></a>,
<a href="simpLib.mk_simpset.html"><code>simpLib.mk_simpset</code></a>,
<a href="bossLib.rewrites.html"><code>bossLib.rewrites</code></a>, <a
href="bossLib.SIMP_RULE.html"><code>bossLib.SIMP_RULE</code></a>, <a
href="bossLib.SIMP_TAC.html"><code>bossLib.SIMP_TAC</code></a>, <a
href="simpLib.SSFRAG.html"><code>simpLib.SSFRAG</code></a>, <a
href="bossLib.EVAL.html"><code>bossLib.EVAL</code></a></p>
</body>
</html>
