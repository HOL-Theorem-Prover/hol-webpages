<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Thm.mk_oracle_thm</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<h2 id="mk_oracle_thm"><code>mk_oracle_thm</code></h2>
<pre class="hol4"><code>Thm.mk_oracle_thm : string -&gt; term list * term -&gt; thm</code></pre>
<hr />
<p>Construct a theorem without proof, and tag it.</p>
<p>In principle, nearly every theorem of interest can be proved in HOL
by using only the axioms and primitive rules of inference. The use of ML
to orchestrate larger inference steps from the primitives, along with
support in HOL for goal-directed proof, considerably eases the task of
formal proof. Nearly every theorem of interest can therefore be produced
as the end product of a chain of primitive inference steps, and HOL
implementations strive to keep this purity.</p>
<p>However, it is occasionally useful to interface HOL with trusted
external tools that also produce, in some sense, theorems that would be
derivable in HOL. It is clearly a burden to require that HOL proofs
accompany such theorems so that they can be (re-)derived in HOL. In
order to support greater interoperation of proof tools, therefore, HOL
provides the notion of a ‘tagged’ theorem.</p>
<p>A tagged theorem is manufactured by invoking
<code>mk_oracle_thm tag (A,w)</code>, where <code>A</code> is a list of
HOL terms of type <code>bool</code>, and <code>w</code> is also a HOL
term of boolean type. No proof is done; the sequent is merely injected
into the type of theorems, and the <code>tag</code> value is attached to
it. The result is the theorem <code>A |- w</code>.</p>
<p>The <code>tag</code> value stays with the theorem, and it propagates
in a hereditary fashion to any theorem derived from the tagged theorem.
Thus, if one examines a theorem with <code>Thm.tag</code> and finds that
it has no tag, then the theorem has been derived purely by proof steps
in the HOL logic. Otherwise, shortcuts have been taken, and the external
tools, also known as ‘oracles’, used to make the shortcuts are signified
by the tags.</p>
<h3 id="failure">Failure</h3>
<p>If some element of <code>A</code> does not have type
<code>bool</code>, or <code>w</code> does not have type
<code>bool</code>, or the tag string doesn’t represent a valid tag
(which occurs if it is the string <code>"DISK_THM"</code>, or if it is a
string containing unprintable characters).</p>
<h3 id="example">Example</h3>
<p>In the following, we construct a tag and then make a rogue rule of
inference.</p>
<pre class="hol4"><code>   - val tag = &quot;SimonSays&quot;;
   &gt; val tag = &quot;SimonSays&quot; : string

   - val SimonThm = mk_oracle_thm tag;
   &gt; val SimonThm = fn : term list * term -&gt; thm

   - val th = SimonThm ([], Term `!x. x`);
   &gt; val th = |- !x. x : thm

   - val th1 = SPEC F th;
   &gt; val th1 = |- F : thm

   - (show_tags := true; th1);
   &gt; val it = [oracles: SimonSays] [axioms: ] [] |- F : thm</code></pre>
<p>Tags accumulate in a manner similar to logical hypotheses.</p>
<pre class="hol4"><code>   - CONJ th1 th1;
   &gt; val it = [oracles: SimonSays] [axioms: ] [] |- F /\ F : thm

   - val SerenaThm = mk_oracle_thm &quot;Serena&quot;;
   &gt; val SerenaThm = fn : term list * term -&gt; thm

   - CONJ th1 (SerenaThm ([],T));
   &gt; val it = [oracles: Serena, SimonSays] [axioms: ] [] |- F /\ T : thm</code></pre>
<h3 id="comments">Comments</h3>
<p>It is impossible to detach a tag from a theorem.</p>
<h3 id="see-also">See also</h3>
<p><a href="Thm.add_tag.html"><code>Thm.add_tag</code></a>, <a
href="Thm.mk_thm.html"><code>Thm.mk_thm</code></a>, <a
href="Tag.read.html"><code>Tag.read</code></a>, <a
href="Thm.tag.html"><code>Thm.tag</code></a></p>
</body>
</html>
