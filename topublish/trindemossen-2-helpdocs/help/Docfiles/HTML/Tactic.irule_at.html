<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Tactic.irule_at</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<h2 id="irule_at"><code>irule_at</code></h2>
<pre class="hol4"><code>Tactic.irule_at : match_position -&gt; thm -&gt; tactic</code></pre>
<hr />
<p>Applies an implicational theorem backwards in a particular position
in the goal</p>
<p>A call to <code>irule_at pos th</code>, with <code>th</code> an
“implicational” theorem of general form <code>∀xs... P ⇒ Q</code>, will
attempt to find an instance of term <code>Q</code> at position
<code>pos</code> within the current goal, and replace it with an
appropriately instantiated version of <code>P</code>. (It is possible
for <code>P</code> to be empty, in which case the term is effectively
replaced by truth.) The possible positions encoded by <code>pos</code>
are all “positive”, meaning that this process is sound (it may
nonetheless turn a provable goal into an unprovable one).</p>
<p>The possible positions encoded by parameter <code>pos</code> view the
goal as if it is of form <code>?ys. c1 ∧ ... ∧ cn</code>, where the
existential prefix <code>ys</code> may be empty, and where there may
only be one conjunct. If <code>pos</code> encodes the choice of conjunct
<code>cj</code>, then <code>irule_at pos</code> will instantiate type
variables and term variables from <code>xs</code> in <code>th</code>,
and variables from <code>ys</code> in the goal so as to make
<code>cj</code> unify with <code>Q</code>. The conjunct <code>cj</code>
will then be replaced with the correspondingly instantiated
<code>P</code>, which may itself be multiple conjunctions. While the
goal may lose variables from <code>ys</code> because they have been
instantiated, it may also acquire new variables from <code>xs</code>;
these will be added to the goal’s existential prefix.</p>
<p>The new goal will be assembled to put new conjuncts first, followed
by conjuncts from the original goal in their original order (these
conjuncts may still be different if existential variables from
<code>ys</code> have been instantiated). If two conjuncts become the
same because of variable instantiation, only one will be present in the
resulting goal. There is some effort made to keep variables from the
existential prefix with the same names, but some renaming may occur, and
the new goal’s existential variables will be ordered arbitrarily. If the
new goal has no conjuncts, then the tactic has proved the original.</p>
<p>There are four possible forms for the <code>pos</code> parameter. If
it is of form <code>Pos f</code>, <code>f</code> will be a function of
type <code>term list -&gt; term</code>, and this function will be passed
the list of conjuncts. The returned term should be one of those
conjuncts. Typical values for this function are <code>hd</code>,
<code>last</code> and <code>el i</code>, for positive integers
<code>i</code>. If the <code>pos</code> parameter is of form
<code>Pat q</code>, the quotation <code>q</code> will be parsed in the
context of the goal (honouring the goal’s free variables), generating a
set of possible terms (multiple terms are possible because of
ambiguities caused by overloading) that are then viewed as patterns
against which the conjuncts of the goal are matched. The first conjunct
that matches the earliest pattern in the sequence of possible parses,
and which unifies with <code>th</code>’s conclusion, is used.</p>
<p>The pattern form <code>Concl</code> is used to indicate that the
entire goal (including its existential prefix) should be viewed as the
desired target for <code>th</code>. This results in a call to
<code>irule th</code> being made.</p>
<p>Finally, the pattern form <code>Any</code> is used to have the tactic
search for any conjunct that matches the conclusion (as with a pattern
of <code>‘_:bool’</code>), and if no conjunct unifies with
<code>th</code>’s conclusion, to then try to call <code>irule th</code>,
as is done with the <code>Concl</code> pattern form.</p>
<h3 id="failure">Failure</h3>
<p>Fails if the position parameter fails to specify a term, or if that
term does not unify with the implicational theorem’s conclusion. A
position may fail to specify a term in mulitple ways depending on the
form of the position. A position of form <code>Pos f</code> will fail if
the function <code>f</code> fails when applied to the goal’s conjuncts.
(Note that there is no failure if <code>f</code> returns a term that is
not actually a conjunct; if this term unifies, this will simply result
in new conjuncts appearing in the goal without any old conjuncts being
removed.)</p>
<p>A position of form <code>Pat q</code> can fail if no conjunct of the
goal matches any of the terms parsed to by <code>q</code>. The other
position forms always return at least one term to be considered. Failure
after this point will only follow if none of these terms unifies with
the implicational theorem’s conclusion.</p>
<h3 id="example">Example</h3>
<p>Solving a goal outright:</p>
<pre class="hol4"><code>    ?- ∃x. x ≤ 3
   ============== irule_at (Pos hd) (DECIDE “y ≤ y”)</code></pre>
<p>Refining a goal under an existential prefix (the theorem
<code>RTC_SUBSET</code> states that
<code>∀x y. R x y ⇒ RTC R x y</code>):</p>
<pre class="hol4"><code>    ?- ∃x y z. P x ∧ RTC R x (f y) ∧ Q y z
   ======================================== irule_at Any RTC_SUBSET
    ?- ∃z y0 x. R x (f y0) ∧ P x ∧ Q y0 z</code></pre>
<p>Instantiating existential variables (with <code>LESS_MONO</code>
stating that <code>m &lt; n ⇒ SUC m &lt; SUC n</code>):</p>
<pre class="hol4"><code>    ?- ∃x y z. P x ∧ SUC x &lt; y ∧ Q y z
   ====================================== irule_at Any LESS_MONO
    ?- ∃z n m. m &lt; n ∧ P m ∧ Q (SUC n) z</code></pre>
<h3 id="comments">Comments</h3>
<p>The underlying operation is resolution, where one resolvent is always
the conclusion of <code>th</code>, and the other is the conjunct from
the goal selected by the position parameter. The goal is viewed as a
literal clause by negating it (via the action of
<code>goal_assum</code>).</p>
<h3 id="see-also">See also</h3>
<p><a href="Tactic.irule.html"><code>Tactic.irule</code></a>, <a
href="Tactic.MATCH_MP_TAC.html"><code>Tactic.MATCH_MP_TAC</code></a></p>
</body>
</html>
