<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>proofManagerLib.expandf</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<h2 id="expandf"><code>expandf</code></h2>
<pre class="hol4"><code>proofManagerLib.expandf : (tactic -&gt; unit)</code></pre>
<hr />
<p>Applies a tactic to the current goal, stacking the resulting
subgoals.</p>
<p>The function <code>expandf</code> is a faster version of
<code>expand</code>. It does not use a validated version of the tactic.
That is, no check is made that the justification of the tactic does
prove the goal from the subgoals it generates. If an invalid tactic is
used, the theorem ultimately proved may not match the goal originally
set. Alternatively, failure may occur when the justifications are
applied in which case the theorem would not be proved. For a description
of the subgoal package, see under <code>set_goal</code>.</p>
<h3 id="failure">Failure</h3>
<p>Calling <code>expandf tac</code> fails if the tactic <code>tac</code>
fails for the top goal. It will diverge if the tactic diverges for the
goal. It will fail if there are no unproven goals. This could be because
no goal has been set using <code>set_goal</code> or because the last
goal set has been completely proved. If an invalid tactic, whose
justification actually fails, has been used earlier in the proof,
<code>expandf tac</code> may succeed in applying <code>tac</code> and
apparently prove the current goal. It may then fail as it applies the
justifications of the tactics applied earlier.</p>
<h3 id="example">Example</h3>
<pre class="hol4"><code>   - g `HD[1;2;3] = 1`;

   `HD[1;2;3] = 1`

   () : void

   - expandf (REWRITE_TAC[HD;TL]);;
   OK..
   goal proved
   |- HD[1;2;3] = 1

   Previous subproof:
   goal proved
   () : void</code></pre>
<p>The following example shows how the use of an invalid tactic can
yield a theorem which does not correspond to the goal set.</p>
<pre class="hol4"><code>   - set_goal([], Term `1=2`);
   `1 = 2`

   () : void

   - expandf (REWRITE_TAC[ASSUME (Term`1=2`)]);
   OK..
   goal proved
   . |- 1 = 2

   Previous subproof:
   goal proved
   () : void</code></pre>
<p>The proof assumed something which was not on the assumption list.
This assumption appears in the assumption list of the theorem proved,
even though it was not in the goal. An attempt to perform the proof
using <code>expand</code> fails. The validated version of the tactic
detects that the justification produces a theorem which does not
correspond to the goal set. It therefore fails.</p>
<p>Saving CPU time when doing goal-directed proofs, since the extra
validation is not done. Redoing proofs quickly that are already known to
work.</p>
<h3 id="comments">Comments</h3>
<p>The CPU time saved may cause misery later. If an invalid tactic is
used, this will only be discovered when the proof has apparently been
finished and the justifications are applied.</p>
<h3 id="see-also">See also</h3>
<p><a
href="proofManagerLib.set_goal.html"><code>proofManagerLib.set_goal</code></a>,
<a
href="proofManagerLib.restart.html"><code>proofManagerLib.restart</code></a>,
<a
href="proofManagerLib.backup.html"><code>proofManagerLib.backup</code></a>,
<a
href="proofManagerLib.redo.html"><code>proofManagerLib.redo</code></a>,
<a
href="proofManagerLib.restore.html"><code>proofManagerLib.restore</code></a>,
<a
href="proofManagerLib.save.html"><code>proofManagerLib.save</code></a>,
<a
href="proofManagerLib.set_backup.html"><code>proofManagerLib.set_backup</code></a>,
<a
href="proofManagerLib.expand.html"><code>proofManagerLib.expand</code></a>,
<a
href="proofManagerLib.expandf.html"><code>proofManagerLib.expandf</code></a>,
<a href="proofManagerLib.p.html"><code>proofManagerLib.p</code></a>, <a
href="proofManagerLib.top_thm.html"><code>proofManagerLib.top_thm</code></a>,
<a
href="proofManagerLib.top_goal.html"><code>proofManagerLib.top_goal</code></a></p>
</body>
</html>
