<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Drule.MATCH_MP</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<h2 id="match_mp"><code>MATCH_MP</code></h2>
<pre class="hol4"><code>Drule.MATCH_MP : thm -&gt; thm -&gt; thm</code></pre>
<hr />
<p>Modus Ponens inference rule with automatic matching.</p>
<p>When applied to theorems <code>A1 |- !x1...xn. t1 ==&gt; t2</code>
and <code>A2 |- t1'</code>, the inference rule <code>MATCH_MP</code>
matches <code>t1</code> to <code>t1'</code> by instantiating free or
universally quantified variables in the first theorem (only), and
returns a theorem <code>A1 u A2 |- !xa..xk. t2'</code>, where
<code>t2'</code> is a correspondingly instantiated version of
<code>t2</code>. Polymorphic types are also instantiated if
necessary.</p>
<p>Variables free in the consequent but not the antecedent of the first
argument theorem will be replaced by variants if this is necessary to
maintain the full generality of the theorem, and any which were
universally quantified over in the first argument theorem will be
universally quantified over in the result, and in the same order.</p>
<pre class="hol4"><code>    A1 |- !x1..xn. t1 ==&gt; t2   A2 |- t1&#39;
   --------------------------------------  MATCH_MP
          A1 u A2 |- !xa..xk. t2&#39;</code></pre>
<p>As with <code>MP</code> and the underlying syntactic function
<code>dest_imp</code>, negated terms (of the form <code>~p</code>) are
treated as if they were implications from the argument of the negation
to falsity.</p>
<h3 id="failure">Failure</h3>
<p>Fails unless the first theorem is a (possibly repeatedly universally
quantified) implication (in the sense of <code>dest_imp</code>) whose
antecedent can be instantiated to match the conclusion of the second
theorem, without instantiating any variables which are free in
<code>A1</code>, the first theoremâ€™s assumption list.</p>
<h3 id="example">Example</h3>
<p>In this example, automatic renaming occurs to maintain the most
general form of the theorem, and the variant corresponding to
<code>z</code> is universally quantified over, since it was universally
quantified over in the first argument theorem.</p>
<pre class="hol4"><code>   - val ith = (GENL [Term `x:num`, Term `z:num`]
                  o DISCH_ALL
                  o AP_TERM (Term `$+ (w + z)`))
               (ASSUME (Term `x:num = y`));
   &gt; val ith = |- !x z. (x = y) ==&gt; (w + z + x = w + z + y) : thm

   - val th = ASSUME (Term `w:num = z`);
   &gt; val th = [w = z] |- w = z : thm

   - MATCH_MP ith th;
   &gt; val it =  [w = z] |- !z&#39;. w&#39; + z&#39; + w = w&#39; + z&#39; + z : thm</code></pre>
<h3 id="see-also">See also</h3>
<p><a
href="boolSyntax.dest_imp.html"><code>boolSyntax.dest_imp</code></a>, <a
href="Thm.EQ_MP.html"><code>Thm.EQ_MP</code></a>, <a
href="Tactic.MATCH_MP_TAC.html"><code>Tactic.MATCH_MP_TAC</code></a>, <a
href="Thm.MP.html"><code>Thm.MP</code></a>, <a
href="Tactic.MP_TAC.html"><code>Tactic.MP_TAC</code></a>, <a
href="ConseqConv.CONSEQ_REWRITE_CONV.html"><code>ConseqConv.CONSEQ_REWRITE_CONV</code></a></p>
</body>
</html>
