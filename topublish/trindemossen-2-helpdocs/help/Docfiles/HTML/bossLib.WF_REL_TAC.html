<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>bossLib.WF_REL_TAC</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<h2 id="wf_rel_tac"><code>WF_REL_TAC</code></h2>
<pre class="hol4"><code>bossLib.WF_REL_TAC : term quotation -&gt; tactic</code></pre>
<hr />
<p>Start termination proof.</p>
<p><code>WF_REL_TAC</code> builds a tactic that starts a termination
proof. An invocation <code>WF_REL_TAC q</code>, where <code>q</code>
should parse into a term that denotes a well-founded relation, builds a
tactic <code>tac</code> that is intended to be applied to a goal arising
from an application of <code>tgoal</code> or <code>tprove</code>. Such a
goal has the form</p>
<pre class="hol4"><code>   ?R. WF R /\ ...</code></pre>
<p>The tactic <code>tac</code> will instantiate <code>R</code> with the
relation denoted by <code>q</code> and will attempt various
simplifications of the goal. For example, it will try to automatically
prove the well-foundedness of the relation denoted by <code>q</code>,
and will also attempt to simplify the goal using some basic facts about
well-founded relations. Often this can result in a much simpler
goal.</p>
<h3 id="failure">Failure</h3>
<p><code>WF_REL_TAC q</code> fails if <code>q</code> does not parse into
a term whose type is an instance of
<code>'a -&gt; 'a -&gt; bool</code>.</p>
<h3 id="example">Example</h3>
<p>Suppose that a version of Quicksort had been defined as follows:</p>
<pre class="hol4"><code>   val qsort_defn =
        Hol_defn &quot;qsort&quot;
           `(qsort ___ [] = []) /\
            (qsort ord (x::rst) =
                APPEND (qsort ord (FILTER ($~ o ord x) rst))
                  (x :: qsort ord (FILTER (ord x) rst)))`;</code></pre>
<p>Then one can start a termination proof as follows: set up a goalstack
with <code>tgoal</code> and then apply <code>WF_REL_TAC</code> with a
quotation denoting a suitable well-founded relation.</p>
<pre class="hol4"><code>   - tgoal qsort_defn;
   &gt; val it =
       Proof manager status: 1 proof.
       1. Incomplete:
          Initial goal:
           ?R. WF R /\
            (!rst x ord. R (ord,FILTER ($~ o ord x) rst) (ord,x::rst)) /\
             !rst x ord. R (ord,FILTER (ord x) rst) (ord,x::rst)

   - e (WF_REL_TAC `measure (LENGTH o SND)`);

   OK..
   2 subgoals:
   &gt; val it =
      !rst x ord. LENGTH (FILTER (ord x) rst) &lt; LENGTH (x::rst)

      !rst x ord. LENGTH (FILTER (\x&#39;. ~ord x x&#39;) rst) &lt; LENGTH (x::rst)</code></pre>
<p>Execution of <code>WF_REL_TAC</code> has automatically proved the
well-foundedness of</p>
<pre class="hol4"><code>   measure (LENGTH o SND)</code></pre>
<p>and the remainder of the goal has been simplified into a pair of easy
goals.</p>
<h3 id="comments">Comments</h3>
<p>There are two problems to deal with when trying to prove termination.
First, one has to understand, intuitively and then mathematically, why
the function under consideration terminates. Second, one must be able to
phrase this in HOL. In the following, we shall give a few examples of
how this is done.</p>
<p>There are a number of basic and advanced means of specifying
well-founded relations. The most common starting point for dealing with
termination problems for recursive functions is to find some function,
known as a ‘measure’ under which the arguments of a function call are
larger than the arguments to any recursive calls that result.</p>
<p>For a very simple starter example, consider the following definition
of a function that computes the greatest common divisor of two
numbers:</p>
<pre class="hol4"><code>   - val gcd_defn = Hol_defn &quot;gcd&quot;
        `(gcd (0,n) = n) /\
         (gcd (m,n) = gcd (n MOD m, m))`;

   - Defn.tgoal gcd_defn;

   &gt; val it =
       Proof manager status: 1 proof.
       1. Incomplete:
            Initial goal:
            ?R. WF R /\ !v2 n. R (n MOD SUC v2,SUC v2) (SUC v2,n)</code></pre>
<p>The recursion happens in the first argument, and the recursive call
in that position is a smaller number. The way to phrase the termination
of <code>gcd</code> in HOL is to use a ‘measure’ function to map from
the domain of <code>gcd</code>—a pair of numbers—to a number. The
definition of <code>measure</code> is equivalent to</p>
<pre class="hol4"><code>   measure f x y = (f x &lt; f y).</code></pre>
<p>(The actual definition of <code>measure</code> in
<code>prim_recTheory</code> is more primitive.) Now we must pick out the
argument position to measure and invoke <code>WF_REL_TAC</code>:</p>
<pre class="hol4"><code>   - e (WF_REL_TAC `measure FST`);
   OK..

   1 subgoal:
   &gt; val it =
    !v2 n. n MOD SUC v2 &lt; SUC v2</code></pre>
<p>This goal is easy to prove with a few simple arithmetic facts:</p>
<pre class="hol4"><code>   - e (PROVE_TAC [arithmeticTheory.DIVISION, prim_recTheory.LESS_0]);
   OK..

   Goal proved. ...</code></pre>
<p>Sometimes one needs a measure function that is itself recursive. For
example, consider a type of binary trees and a function that
‘unbalances’ trees. The algorithm works by rotating the tree until it
gets a <code>Leaf</code> in the left branch, then it recurses into the
right branch. At the end of execution the tree has been linearized.</p>
<pre class="hol4"><code>   - Hol_datatype
      `btree = Leaf
             | Brh of btree =&gt; btree`;

   - val Unbal_defn =
      Hol_defn &quot;Unbal&quot;
      `(Unbal Leaf = Leaf)
   /\  (Unbal (Brh Leaf bt) = Brh Leaf (Unbal bt))
   /\  (Unbal (Brh (Brh bt1 bt2) bt) = Unbal (Brh bt1 (Brh bt2 bt)))`;

   - Defn.tgoal Unbal_defn;

   &gt; val it =
       Proof manager status: 1 proof.
       1. Incomplete:
          Initial goal:
           ?R. WF R /\
               (!bt. R bt (Brh Leaf bt)) /\
               !bt bt2 bt1. R (Brh bt1 (Brh bt2 bt)) (Brh (Brh bt1 bt2) bt)</code></pre>
<p>Since the size of the tree is unchanged in the last clause in the
definition of <code>Unbal</code>, a simple size measure will not work.
Instead, we can assign weights to nodes in the tree such that the
recursive calls of <code>Unbal</code> decrease the total weight in every
case. One such assignment is</p>
<pre class="hol4"><code>   Weight (Leaf) = 0
   Weight (Brh x y) = (2 * Weight x) + (Weight y) + 1</code></pre>
<p>It is easiest to use <code>Define</code> to define
<code>Weight</code>, but if one is worried about “polluting” the
signature, one can also use <code>prove_rec_fn_exists</code> from the
<code>Prim_rec</code> structure:</p>
<pre class="hol4"><code>   val Weight =
     Prim_rec.prove_rec_fn_exists (TypeBase.axiom_of (&quot;&quot;, &quot;btree&quot;))
      (Term`(Weight (Leaf) = 0) /\
            (Weight (Brh x y) = (2 * Weight x) + (Weight y) + 1)`);

   &gt; val Weight =
      |- ?Weight.
            (Weight Leaf = 0) /\
            !x y. Weight (Brh x y) = 2 * Weight x + Weight y + 1 : thm

   - e (STRIP_ASSUME_TAC Weight);
   OK..

   1 subgoal:
   &gt; val it =
       ?R.
         WF R /\ (!bt. R bt (Brh Leaf bt)) /\
         !bt bt2 bt1. R (Brh bt1 (Brh bt2 bt)) (Brh (Brh bt1 bt2) bt)
       ------------------------------------
         0.  Weight Leaf = 0
         1.  !x y. Weight (Brh x y) = 2 * Weight x + Weight y + 1</code></pre>
<p>Now we can invoke <code>WF_REL_TAC</code>:</p>
<pre class="hol4"><code>   e (WF_REL_TAC `measure Weight`);
   OK..

   2 subgoals:
   &gt; val it =
    !bt bt2 bt1.
      Weight (Brh bt1 (Brh bt2 bt)) &lt; Weight (Brh (Brh bt1 bt2) bt)
    ------------------------------------
      0.  Weight Leaf = 0
      1.  !x y. Weight (Brh x y) = 2 * Weight x + Weight y + 1

    !bt. Weight bt &lt; Weight (Brh Leaf bt)
    ------------------------------------
      0.  Weight Leaf = 0
      1.  !x y. Weight (Brh x y) = 2 * Weight x + Weight y + 1</code></pre>
<p>Both of these subgoals are quite easy to prove.</p>
<p>The technique of ‘weighting’ nodes in a tree in order to prove
termination also goes by the name of ‘polynomial interpretation’. It
must be admitted that finding the correct weighting for a termination
proof is more an art than a science. Typically, one makes a guess and
then tries the termination proof to see if it works.</p>
<p>Occasionally, there’s a combination of factors that complicate the
termination argument. For example, the following specification describes
a naive pattern matching algorithm on strings (represented as lists
here). The function takes four arguments: the first is the remainder of
the pattern being matched. The second is the remainder of the string
being searched. The third argument holds the original pattern to be
matched. The fourth argument is the string being searched. If the
pattern (first argument) becomes exhausted, then a match has been found
and the function returns <code>T</code>. Otherwise, if the string being
searched becomes exhausted, the function returns <code>F</code>.</p>
<pre class="hol4"><code>   val match0_defn =
     Hol_defn &quot;match0&quot;
          `(match0 [] __ __ __ = T)
      /\   (match0 __ [] __ __ = F)
      /\   (match0 (p::pp) (s::ss) p0 rs =
             if p=s then match0 pp ss p0 rs else
             if NULL rs then F
                else match0 p0 (TL rs) p0 (TL rs))`;

   - val match = Define `match pat str = match0 pat str pat str`;</code></pre>
<p>The remaining case is when there’s more searching to do; the function
checks if the head of the pattern is the same as the head of the string
being searched. If yes, then we recursively search, using the tail of
the pattern and the tail of the string being searched. If no, that means
that we have failed to match the pattern, so we should move one
character ahead in the string being searched and try again. If the
string being searched is empty, however, then we return <code>F</code>.
The second and third arguments both represent the string being searched.
The second argument is a kind of ‘local’ version of the string being
searched; we recurse into it as long as there are matches with the
pattern. However, if the search eventually fails, then the fourth
argument, which ‘remembers’ where the search started from, is used to
restart the search.</p>
<p>So much for the behaviour of the function. Why does it terminate?
There are two recursive calls. The first call reduces the size of the
first and second arguments, and leaves the other arguments unchanged.
The second call can increase the size of the first and second arguments,
but reduces the size of the fourth.</p>
<p>This is a classic situation in which to use a lexicographic ordering:
some arguments to the function are reduced in some recursive calls, and
some others are reduced in other recursive calls. Recall that
<code>LEX</code> is an infix operator, defined in
<code>pairTheory</code> as follows:</p>
<pre class="hol4"><code>   LEX R1 R2 = \(x,y) (p,q). R1 x p \/ ((x=p) /\ R2 y q)</code></pre>
<p>In the second recursive call, the length of <code>rs</code> is
reduced, and in the first it stays the same. This motivates having the
length of the fourth argument be the first component of the
lexicographic combination, and the length of the second argument as the
second component.</p>
<p>What we need now is to formalize this. We want to map from the
four-tuple of arguments into a lexicographic combination of relations.
This is enabled by <code>inv_image</code> from
<code>relationTheory</code>:</p>
<pre class="hol4"><code>   inv_image R f = \x y. R (f x) (f y)</code></pre>
<p>The actual relation maps from the four-tuple of arguments into a pair
of numbers <code>(m,n)</code>, where <code>m</code> is the length of the
fourth argument, and <code>n</code> is the length of the second
argument. These lengths are then compared lexicographically with respect
to less-than (<code>&lt;</code>).</p>
<pre class="hol4"><code>   - Defn.tgoal match0_defn;

   - e (WF_REL_TAC `inv_image ($&lt; LEX $&lt;)
                     (\(w,x,y,z). (LENGTH z, LENGTH x))`);

   OK..
   2 subgoals:
   &gt; val it =
    !rs ss s p.
      (p=s) ==&gt; LENGTH rs &lt; LENGTH rs \/ LENGTH ss &lt; LENGTH (s::ss)


    !ss rs s p.
      ~(p = s) /\ ~NULL rs ==&gt;
      LENGTH (TL rs) &lt; LENGTH rs \/
      (LENGTH (TL rs) = LENGTH rs) /\ LENGTH (TL rs) &lt; LENGTH (s::ss)</code></pre>
<p>The first subgoal needs a case-split on <code>rs</code> before it is
proved by rewriting, and the seconds is also easy to prove by
rewriting.</p>
<p>As a final example, one occasionally needs to recurse over
non-concrete data, such as finite sets or multisets. We can define a
‘fold’ function (of questionable utility) for finite sets as
follows:</p>
<pre class="hol4"><code>   load &quot;pred_setTheory&quot;; open pred_setTheory;

   val FOLD_SET_defn =
     Defn.Hol_defn &quot;FOLD_SET&quot;
     `FOLD_SET (s:&#39;a-&gt;bool) (b:&#39;b) =
        if FINITE s then
           if s={} then b
           else FOLD_SET (REST s) (f (CHOICE s) b)
        else ARB`;</code></pre>
<p>Typically, such functions terminate because the cardinality of the
set (or multiset) is reduced in the recursive call, and this is another
application of <code>measure</code>:</p>
<pre class="hol4"><code>   val (FOLD_SET_0, FOLD_SET_IND) =
    Defn.tprove (FOLD_SET_defn,
      WF_REL_TAC `measure (CARD o FST)`
       THEN PROVE_TAC [CARD_PSUBSET, REST_PSUBSET]);</code></pre>
<p>The desired recursion equation</p>
<pre class="hol4"><code>   |- FINITE s ==&gt; (FOLD_SET f s b =
                      if s = {} then b
                      else FOLD_SET f (REST s) (f (CHOICE s) b))</code></pre>
<p>is easy to obtain from <code>FOLD_SET_0</code>.</p>
<h3 id="see-also">See also</h3>
<p><a href="Defn.tgoal.html"><code>Defn.tgoal</code></a>, <a
href="Defn.tprove.html"><code>Defn.tprove</code></a>, <a
href="bossLib.Hol_defn.html"><code>bossLib.Hol_defn</code></a></p>
</body>
</html>
