<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>proofManagerLib.set_goal</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<h2 id="set_goal"><code>set_goal</code></h2>
<pre class="hol4"><code>proofManagerLib.set_goal : term list * term -&gt; unit</code></pre>
<hr />
<p>Initializes the subgoal package with a new goal.</p>
<p>The function <code>set_goal</code> initializes the subgoal management
package. A proof state of the package consists of either a goal stack
and a justification stack if a proof is in progress, or a theorem if a
proof has just been completed. <code>set_goal</code> sets a new proof
state consisting of an empty justification stack and a goal stack with
the given goal as its sole goal. The goal is printed.</p>
<h3 id="failure">Failure</h3>
<p>Fails unless all terms in the goal are of type <code>bool</code>.</p>
<h3 id="example">Example</h3>
<pre class="hol4"><code>- set_goal([], Term `(HD[1;2;3] = 1) /\ (TL[1;2;3] = [2;3])`);
&gt; val it =
    Proof manager status: 1 proof.
    1. Incomplete:
         Initial goal:
         (HD [1; 2; 3] = 1) /\ (TL [1; 2; 3] = [2; 3])

     : proofs</code></pre>
<p>Starting an interactive proof session with the subgoal package.</p>
<p>The subgoal package implements a simple framework for interactive
goal-directed proof. When conducting a proof that involves many subgoals
and tactics, the user must keep track of all the justifications and
compose them in the correct order. While this is feasible even in large
proofs, it is tedious. The subgoal package provides a way of building
and traversing the tree of subgoals top-down, stacking the
justifications and applying them properly.</p>
<p>The package maintains a proof state consisting of either a goal stack
of outstanding goals and a justification stack, or a theorem. Tactics
are used to expand the current goal (the one on the top of the goal
stack) into subgoals and justifications. These are pushed onto the goal
stack and justification stack, respectively, to form a new proof state.
Several preceding proof states are saved and can be returned to if a
mistake is made in the proof. The goal stack is divided into levels, a
new level being created each time a tactic is successfully applied to
give new subgoals. Alternatively a list-tactic can process the entire
list of goals of the current level to change that level (rather than
creating a new level). The subgoals of the current level may be
considered in any order. Levels of the goal stack may be collapsed so
that subgoals of a previous level appear as part of of the current
level.</p>
<p>If a tactic solves the current goal (returns an empty subgoal list),
then its justification is used to prove a corresponding theorem. This
theorem is then incorporated into the justification of the parent goal.
If the subgoal was the last subgoal of the level, the level is removed
and the parent goal is proved using its (new) justification. This
process is repeated until a level with unproven subgoals is reached. The
next goal on the goal stack then becomes the current goal. If all the
subgoals are proved, the resulting proof state consists of the theorem
proved by the justifications. This theorem may be accessed and
saved.</p>
<h3 id="see-also">See also</h3>
<p><a
href="proofManagerLib.set_goal.html"><code>proofManagerLib.set_goal</code></a>,
<a
href="proofManagerLib.restart.html"><code>proofManagerLib.restart</code></a>,
<a
href="proofManagerLib.backup.html"><code>proofManagerLib.backup</code></a>,
<a
href="proofManagerLib.redo.html"><code>proofManagerLib.redo</code></a>,
<a
href="proofManagerLib.restore.html"><code>proofManagerLib.restore</code></a>,
<a
href="proofManagerLib.save.html"><code>proofManagerLib.save</code></a>,
<a
href="proofManagerLib.set_backup.html"><code>proofManagerLib.set_backup</code></a>,
<a
href="proofManagerLib.expand.html"><code>proofManagerLib.expand</code></a>,
<a
href="proofManagerLib.expandf.html"><code>proofManagerLib.expandf</code></a>,
<a
href="proofManagerLib.expand_list.html"><code>proofManagerLib.expand_list</code></a>,
<a
href="proofManagerLib.flatn.html"><code>proofManagerLib.flatn</code></a>,
<a href="proofManagerLib.p.html"><code>proofManagerLib.p</code></a>, <a
href="proofManagerLib.top_thm.html"><code>proofManagerLib.top_thm</code></a>,
<a
href="proofManagerLib.top_goal.html"><code>proofManagerLib.top_goal</code></a></p>
</body>
</html>
