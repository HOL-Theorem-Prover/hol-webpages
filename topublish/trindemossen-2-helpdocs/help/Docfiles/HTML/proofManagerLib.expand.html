<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>proofManagerLib.expand</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<h2 id="expand"><code>expand</code></h2>
<pre class="hol4"><code>proofManagerLib.expand : tactic -&gt; proof</code></pre>
<hr />
<p>Applies a tactic to the current goal, stacking the resulting
subgoals.</p>
<p>The function <code>expand</code> is part of the subgoal package. It
may be abbreviated by the function <code>e</code>. It applies a tactic
to the current goal to give a new proof state. The previous state is
stored on the backup list. If the tactic produces subgoals, the new
proof state is formed from the old one by removing the current goal from
the goal stack and adding a new level consisting of its subgoals. The
corresponding justification is placed on the justification stack. The
new subgoals are printed. If more than one subgoal is produced, they are
printed from the bottom of the stack so that the new current goal is
printed last.</p>
<p>If a tactic solves the current goal (returns an empty subgoal list),
then its justification is used to prove a corresponding theorem. This
theorem is incorporated into the justification of the parent goal and
printed. If the subgoal was the last subgoal of the level, the level is
removed and the parent goal is proved using its (new) justification.
This process is repeated until a level with unproven subgoals is
reached. The next goal on the goal stack then becomes the current goal.
This goal is printed. If all the subgoals are proved, the resulting
proof state consists of the theorem proved by the justifications.</p>
<p>The tactic applied is a validating version of the tactic given. It
ensures that the justification of the tactic does provide a proof of the
goal from the subgoals generated by the tactic. It will cause failure if
this is not so. The tactical <code>VALID</code> performs this
validation.</p>
<p>For a description of the subgoal package, see
<code>set_goal</code>.</p>
<h3 id="failure">Failure</h3>
<p><code>expand tac</code> fails if the tactic <code>tac</code> fails
for the top goal. It will diverge if the tactic diverges for the goal.
It will fail if there are no unproven goals. This could be because no
goal has been set using <code>set_goal</code> or because the last goal
set has been completely proved. It will also fail in cases when the
tactic is invalid.</p>
<h3 id="example">Example</h3>
<pre class="hol4"><code>- expand CONJ_TAC;
- expand CONJ_TAC;
OK..
NO_PROOFS! Uncaught exception:
! NO_PROOFS

- g `(HD[1;2;3] = 1) /\ (TL[1;2;3] = [2;3])`;
&gt; val it =
    Proof manager status: 1 proof.
    1. Incomplete:
         Initial goal:
         (HD [1; 2; 3] = 1) /\ (TL [1; 2; 3] = [2; 3])

     : proofs

- expand CONJ_TAC;
OK..
2 subgoals:
&gt; val it =
    TL [1; 2; 3] = [2; 3]


    HD [1; 2; 3] = 1

     : proof

- expand (REWRITE_TAC[listTheory.HD]);
OK..

Goal proved.
|- HD [1; 2; 3] = 1

Remaining subgoals:
&gt; val it =
    TL [1; 2; 3] = [2; 3]

     : proof

- expand (REWRITE_TAC[listTheory.TL]);
OK..

Goal proved.
|- TL [1; 2; 3] = [2; 3]
&gt; val it =
    Initial goal proved.
    |- (HD [1; 2; 3] = 1) /\ (TL [1; 2; 3] = [2; 3]) : proof</code></pre>
<p>In the following example an invalid tactic is used. It is invalid
because it assumes something that is not on the assumption list of the
goal. The justification adds this assumption to the assumption list so
the justification would not prove the goal that was set.</p>
<pre class="hol4"><code>- g `1=2`;
&gt; val it =
    Proof manager status: 2 proofs.
    2. Completed: |- (HD [1; 2; 3] = 1) /\ (TL [1; 2; 3] = [2; 3])
    1. Incomplete:
         Initial goal:
         1 = 2

     : proofs
- expand (REWRITE_TAC[ASSUME (Term `1=2`)]);
OK..

Exception raised at Tactical.VALID:
Invalid tactic
! Uncaught exception:
! HOL_ERR</code></pre>
<p>Note that an invalid tactic may “succeed”. Thus, where
<code>tac1</code> is invalid, and <code>tac2</code> is valid (and both
succeed), <code>FIRST [tac1, tac2]</code> is invalid. For example, where
theorem <code>uth</code> is <code>[p] |- q</code> and <code>uth'</code>
is <code>[p'] |- q</code></p>
<pre class="hol4"><code>1 subgoal:
val it =

q
------------------------------------
  p
:
   proof

&gt; e (FIRST (map ACCEPT_TAC [uth&#39;, uth])) ;
OK..

Exception raised at Tactical.VALID:
Invalid tactic [...]

&gt; e (FIRST (map (VALID o ACCEPT_TAC) [uth&#39;, uth])) ;
OK..

Goal proved.
 [p] |- q</code></pre>
<p>Doing a step in an interactive goal-directed proof.</p>
<h3 id="see-also">See also</h3>
<p><a
href="proofManagerLib.set_goal.html"><code>proofManagerLib.set_goal</code></a>,
<a
href="proofManagerLib.restart.html"><code>proofManagerLib.restart</code></a>,
<a
href="proofManagerLib.backup.html"><code>proofManagerLib.backup</code></a>,
<a
href="proofManagerLib.redo.html"><code>proofManagerLib.redo</code></a>,
<a
href="proofManagerLib.restore.html"><code>proofManagerLib.restore</code></a>,
<a
href="proofManagerLib.save.html"><code>proofManagerLib.save</code></a>,
<a
href="proofManagerLib.set_backup.html"><code>proofManagerLib.set_backup</code></a>,
<a
href="proofManagerLib.expand.html"><code>proofManagerLib.expand</code></a>,
<a
href="proofManagerLib.expandf.html"><code>proofManagerLib.expandf</code></a>,
<a
href="proofManagerLib.flatn.html"><code>proofManagerLib.flatn</code></a>,
<a href="proofManagerLib.p.html"><code>proofManagerLib.p</code></a>, <a
href="proofManagerLib.top_thm.html"><code>proofManagerLib.top_thm</code></a>,
<a
href="proofManagerLib.top_goal.html"><code>proofManagerLib.top_goal</code></a>,
<a href="Tactical.VALID.html"><code>Tactical.VALID</code></a>, <a
href="Tactical.VALIDATE.html"><code>Tactical.VALIDATE</code></a></p>
</body>
</html>
