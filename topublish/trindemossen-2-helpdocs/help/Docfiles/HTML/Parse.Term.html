<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Parse.Term</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<h2 id="term"><code>Term</code></h2>
<pre class="hol4"><code>Parse.Term : term quotation -&gt; term</code></pre>
<hr />
<p>Parses a quotation into a term value.</p>
<p>The parsing process for terms divides into four distinct phases.</p>
<p>The first phase converts the quotation argument into abstract syntax,
a relatively simple parse tree datatype, with the following datatype
definition (from <code>Absyn</code>):</p>
<pre class="hol4"><code>   datatype vstruct
       = VAQ    of term
       | VIDENT of string
       | VPAIR  of vstruct * vstruct
       | VTYPED of vstruct * pretype
   datatype absyn
       = AQ    of term
       | IDENT of string
       | APP   of absyn * absyn
       | LAM   of vstruct * absyn
       | TYPED of absyn * pretype</code></pre>
<p>This phase of parsing is concerned with the treatment of the rawest
concrete syntax. It has no notion of whether or not a term corresponds
to a constant or a variable, so all <code>preterm</code> leaves are
ultimately either <code>IDENT</code>s or <code>AQ</code>s
(anti-quotations).</p>
<p>This first phase converts infixes, mixfixes and all the other
categories of syntactic rule from the global grammar into simple
structures built up using <code>APP</code>. For example,
<code>`x op y`</code> (where <code>op</code> is an infix) will turn
into</p>
<pre class="hol4"><code>   APP(APP(IDENT &quot;op&quot;, IDENT &quot;x&quot;), IDENT &quot;y&quot;)</code></pre>
<p>and <code>`tok1 x tok2 y`</code> (where <code>tok1 _ tok2</code> has
been declared as a <code>Prefix</code> form for the term <code>f</code>)
will turn into</p>
<pre class="hol4"><code>   APP(APP(IDENT &quot;f&quot;, IDENT &quot;x&quot;), IDENT &quot;y&quot;)</code></pre>
<p>The special syntaxes for “let” and record expressions are also
handled at this stage. For more details on how this is done see the
reference entry for <code>Absyn</code>, which function can be used in
isolation to see what is done at this phase.</p>
<p>The second phase of parsing consists of the resolution of names,
identifying what were just <code>VAR</code>s as constants or genuine
variables (whether free or bound). This phase also annotates all leaves
of the data structure (given in the entry for <code>Preterm</code>) with
type information.</p>
<p>The third phase of parsing works over the <code>Preterm</code>
datatype and does type-checking, though ignoring overloaded values. The
datatype being operated over uses reference variables to allow for
efficiency, and the type-checking is done “in place”. If type-checking
is successful, the resulting value has consistent type annotations.</p>
<p>The final phase of parsing resolves overloaded constants. The
type-checking done to this point may completely determine which choice
of overloaded constant is appropriate, but if not, the choice may still
be completely determined by the interaction of the possible types for
the overloaded possibilities.</p>
<p>Finally, depending on the value of the global flags
<code>guessing_tyvars</code> and <code>guessing_overloads</code>, the
parser will make choices about how to resolve any remaining
ambiguities.</p>
<p>The parsing process is entirely driven by the global grammar. This
value can be inspected with the <code>term_grammar</code> function.</p>
<h3 id="failure">Failure</h3>
<p>All over place, and for all sorts of reasons.</p>
<p>Turns strings into terms.</p>
<h3 id="see-also">See also</h3>
<p><a href="Parse.Absyn.html"><code>Parse.Absyn</code></a>, <a
href="Parse.overload_on.html"><code>Parse.overload_on</code></a>, <a
href="Parse.term_grammar.html"><code>Parse.term_grammar</code></a></p>
</body>
</html>
