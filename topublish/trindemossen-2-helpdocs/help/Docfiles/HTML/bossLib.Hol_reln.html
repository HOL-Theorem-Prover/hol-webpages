<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>bossLib.Hol_reln</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<h2 id="hol_reln"><code>Hol_reln</code></h2>
<pre class="hol4"><code>bossLib.Hol_reln : term quotation -&gt; (thm * thm * thm)</code></pre>
<hr />
<p>Defines inductive relations.</p>
<p>The <code>Hol_reln</code> function is used to define inductively
characterised relations. It takes a term quotation as input and attempts
to define the relations there specified. The input term quotation must
parse to a term that conforms to the following grammar:</p>
<pre class="hol4"><code>   &lt;input-format&gt; ::= &lt;clause&gt; /\ &lt;input-format&gt; | &lt;clause&gt;
   &lt;clause&gt;       ::= (!x1 .. xn. &lt;hypothesis&gt; ==&gt; &lt;conclusion&gt;)
                   |  (!x1 .. xn. &lt;conclusion&gt;)
   &lt;conclusion&gt;   ::= &lt;con&gt; sv1 sv2 ....
   &lt;hypothesis&gt;   ::= any term
   &lt;con&gt;          ::= a new relation constant</code></pre>
<p>The <code>sv1</code> terms that appear after a constant name are
so-called “schematic variables”. The same variables must always follow
the same constant name throughout the definition. These variables and
the names of the constants-to-be must not be quantified over in each
<code>&lt;clause&gt;</code>. Otherwise, a <code>&lt;clause&gt;</code>
must not include any free variables. (The universal quantifiers at the
head of the clause can be used to bind free variables, but it is also
permissible to use existential quantification in the hypotheses. If a
clause has no free variables, it is permissible to have no universal
quantification.)</p>
<p>The <code>Hol_reln</code> function may be used to define multiple
relations. These may or may not be mutually recursive. The clauses for
each relation need not be contiguous.</p>
<p>The function returns three theorems. Each is also saved in the
current theory segment. The first is a conjunction of implications that
will be the same as the input term quotation. This theorem is saved
under the name <code>&lt;stem&gt;_rules</code>, where
<code>&lt;stem&gt;</code> is the name of the first relation defined by
the function. The second is the induction principle for the relations,
saved under the name <code>&lt;stem&gt;_ind</code>. The third is the
cases theorem for the relations, saved under the name
<code>&lt;stem&gt;_cases</code>. The cases theorem is of the form</p>
<pre class="hol4"><code>   (!a0 .. an.  R1 a0 .. an = &lt;R1&#39;s first rule possibility&gt; \/
                              &lt;R1&#39;s second rule possibility&gt; \/ ...)
                   /\
   (!a0 .. am.  R2 a0 .. am = &lt;R2&#39;s first rule possibility&gt; \/
                              &lt;R2&#39;s second rule possibility&gt; \/ ...)
                   /\
   ...</code></pre>
<h3 id="failure">Failure</h3>
<p>The <code>Hol_reln</code> function will fail if the provided
quotation does not parse to a term of the specified form. It will also
fail if a clause’s only free variables do not follow a relation name, or
if a relation name is followed by differing schematic variables. If the
definition principle can not prove that the characterisation is
inductive (as would happen if a hypothesis included a negated occurence
of one of the relation names), then the same theorems are returned, but
with extra assumptions stating the required inductive property.</p>
<p>If the name of the new constants are such that they will produce
invalid SML identifiers when bound in a theory file, using
<code>export_theory</code> will fail, and suggest the use of
<code>set_MLname</code> to fix the problem.</p>
<h3 id="example">Example</h3>
<p>Defining <code>ODD</code> and <code>EVEN</code>:</p>
<pre class="hol4"><code>   - Hol_reln`EVEN 0 /\
              (!n. ODD n ==&gt; EVEN (n + 1)) /\
              (!n. EVEN n ==&gt; ODD (n + 1))`;
   &gt; val it =
       (|- EVEN 0 /\ (!n. ODD n ==&gt; EVEN (n + 1)) /\
           !n. EVEN n ==&gt; ODD (n + 1),

        |- !EVEN&#39; ODD&#39;.
             EVEN&#39; 0 /\ (!n. ODD&#39; n ==&gt; EVEN&#39; (n + 1)) /\
             (!n. EVEN&#39; n ==&gt; ODD&#39; (n + 1)) ==&gt;
             (!a0. EVEN a0 ==&gt; EVEN&#39; a0) /\ !a1. ODD a1 ==&gt; ODD&#39; a1,

        |- (!a0. EVEN a0 = (a0 = 0) \/
                           ?n. (a0 = n + 1) /\ ODD n) /\
           !a1. ODD a1 = ?n. (a1 = n + 1) /\ EVEN n)

      : thm * thm * thm</code></pre>
<p>Defining reflexive and transitive closure, using a schematic
variable. This is appropriate because it is <code>RTC R</code> that has
the inductive characterisation, not <code>RTC</code> itself.</p>
<pre class="hol4"><code>   - Hol_reln `(!x. RTC R x x) /\
               (!x z. (?y. R x y /\ RTC R y z) ==&gt; RTC R x z)`;
   &lt;&lt;HOL message: inventing new type variable names: &#39;a&gt;&gt;
   &gt; val it =
       (|- !R. (!x. RTC R x x) /\
               !x z. (?y. R x y /\ RTC R y z) ==&gt; RTC R x z,

        |- !R RTC&#39;.
             (!x. RTC&#39; x x) /\
             (!x z. (?y. R x y /\ RTC&#39; y z) ==&gt; RTC&#39; x z) ==&gt;
             !a0 a1. RTC R a0 a1 ==&gt; RTC&#39; a0 a1,

        |- !R a0 a1. RTC R a0 a1 =
                       (a1 = a0) \/ ?y. R a0 y /\ RTC R y a1)

     : thm * thm * thm</code></pre>
<h3 id="comments">Comments</h3>
<p>Being a definition principle, the <code>Hol_reln</code> function
takes a quotation rather than a term. The structure
<code>IndDefRules</code> provides functions for applying the results of
an invocation of <code>Hol_reln</code>.</p>
<h3 id="see-also">See also</h3>
<p><a href="bossLib.Define.html"><code>bossLib.Define</code></a>, <a
href="bossLib.Hol_datatype.html"><code>bossLib.Hol_datatype</code></a>,
<a href="IndDefRules.html"><code>IndDefRules</code></a></p>
</body>
</html>
