<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Cond_rewrite.COND_REWR_CONV</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<h2 id="cond_rewr_conv"><code>COND_REWR_CONV</code></h2>
<pre class="hol4"><code>Cond_rewrite.COND_REWR_CONV : ((term -&gt; term -&gt;
 ((term # term) list # (type # type) list) list) -&gt; thm -&gt; conv)</code></pre>
<hr />
<p>A lower level conversion implementing simple conditional
rewriting.</p>
<p><code>COND_REWR_CONV</code> is one of the basic building blocks for
the implementation of the simple conditional rewriting conversions in
the HOL system. In particular, the conditional term replacement or
rewriting done by all the conditional rewriting conversions in this
library is ultimately done by applications of
<code>COND_REWR_CONV</code>. The description given here for
<code>COND_REWR_CONV</code> may therefore be taken as a specification of
the atomic action of replacing equals by equals in a term under certain
conditions that are used in all these higher level conditional rewriting
conversions.</p>
<p>The first argument to <code>COND_REWR_CONV</code> is expected to be a
function which returns a list of matches. Each of these matches is in
the form of the value returned by the built-in function
<code>match</code>. It is used to search the input term for instances
which may be rewritten.</p>
<p>The second argument to <code>COND_REWR_CONV</code> is expected to be
an implicative theorem in the following form:</p>
<pre class="hol4"><code>   A |- !x1 ... xn. P1 ==&gt; ... Pm ==&gt; (Q[x1,...,xn] = R[x1,...,xn])</code></pre>
<p>where <code>x1</code>, â€¦, <code>xn</code> are all the variables that
occur free in the left hand side of the conclusion of the theorem but do
not occur free in the assumptions.</p>
<p>The last argument to <code>COND_REWR_CONV</code> is the term to be
rewritten.</p>
<p>If <code>fn</code> is a function and <code>th</code> is an
implicative theorem of the kind shown above, then
<code>COND_REWR_CONV fn th</code> will be a conversion. When applying to
a term <code>tm</code>, it will return a theorem</p>
<pre class="hol4"><code>   P1&#39;, ..., Pm&#39; |- tm = tm[R&#39;/Q&#39;]</code></pre>
<p>if evaluating <code>fn Q[x1,...,xn] tm</code> returns a non-empty
list of matches. The assumptions of the resulting theorem are instances
of the antecedents of the input theorem <code>th</code>. The right hand
side of the equation is obtained by rewriting the input term
<code>tm</code> with instances of the conclusion of the input
theorem.</p>
<h3 id="failure">Failure</h3>
<p><code>COND_REWR_CONV fn th</code> fails if <code>th</code> is not an
implication of the form described above. If <code>th</code> is such an
equation, but the function <code>fn</code> returns a null list of
matches, or the function <code>fn</code> returns a non-empty list of
matches, but the term or type instantiation fails.</p>
<h3 id="example">Example</h3>
<p>The following example illustrates a straightforward use of
<code>COND_REWR_CONV</code>. We use the built-in theorem
<code>LESS_MOD</code> as the input theorem, and the function
<code>search_top_down</code> as the search function.</p>
<pre class="hol4"><code>   #LESS_MOD;;
   Theorem LESS_MOD autoloading from theory `arithmetic` ...
   LESS_MOD = |- !n k. k &lt; n ==&gt; (k MOD n = k)

   |- !n k. k &lt; n ==&gt; (k MOD n = k)

   #search_top_down;;
   - : (term -&gt; term -&gt; ((term # term) list # (type # type) list) list)

   #COND_REWR_CONV search_top_down LESS_MOD &quot;2 MOD 3&quot;;;
   2 &lt; 3 |- 2 MOD 3 = 2</code></pre>
<h3 id="see-also">See also</h3>
<p><a
href="Cond_rewrite.COND_REWR_TAC.html"><code>Cond_rewrite.COND_REWR_TAC</code></a>,
<a
href="Cond_rewrite.COND_REWRITE1_TAC.html"><code>Cond_rewrite.COND_REWRITE1_TAC</code></a>,
<a
href="Cond_rewrite.COND_REWRITE1_CONV.html"><code>Cond_rewrite.COND_REWRITE1_CONV</code></a>,
<a
href="Cond_rewrite.COND_REWR_CANON.html"><code>Cond_rewrite.COND_REWR_CANON</code></a>,
<a
href="Cond_rewrite.search_top_down.html"><code>Cond_rewrite.search_top_down</code></a></p>
</body>
</html>
