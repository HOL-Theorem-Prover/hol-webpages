<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: nets</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "nets"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "metricTheory.html"><span class="strong">metric</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Type <th> Arity<tr><td> <span class="strong">net</span> <td> 1
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">at</span>
    <td>
    :real -> real net
    <tr><td> <span class="strong">at_infinity</span> <td> :real net
    <tr><td> <span class="strong">at_neginfinity</span> <td> :real net
    <tr><td> <span class="strong">at_posinfinity</span> <td> :real net
    <tr><td>
    <span class="strong">bounded</span>
    <td>
    :α metric # (β -> β -> bool) -> (β -> α) -> bool
    <tr><td> <span class="strong">dorder</span> <td> :(α -> α -> bool) -> bool
    <tr><td>
    <span class="strong">eventually</span>
    <td>
    :(α -> bool) -> α net -> bool
    <tr><td>
    <span class="strong">in_direction</span>
    <td>
    :real -> real -> real net
    <tr><td> <span class="strong">isnet</span> <td> :(α -> β -> bool) -> bool
    <tr><td>
    <span class="strong">limit</span>
    <td>
    :β topology -> (α -> β) -> β -> α net -> bool
    <tr><td>
    <span class="strong">mk_net</span>
    <td>
    :(α -> α -> bool) -> α net
    <tr><td> <span class="strong">netlimit</span> <td> :α net -> α
    <tr><td> <span class="strong">netord</span> <td> :α net -> α -> α -> bool
    <tr><td> <span class="strong">sequentially</span> <td> :num net
    <tr><td>
    <span class="strong">tends</span>
    <td>
    :(β -> α) -> α -> α topology # (β -> β -> bool) -> bool
    <tr><td>
    <span class="strong">tendsto</span>
    <td>
    :α metric # α -> α -> α -> bool
    <tr><td> <span class="strong">trivial_limit</span> <td> :α net -> bool
    <tr><td>
    <span class="strong">within</span>
    <td>
    :α net -> (α -> bool) -> α net
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">at_def</span>
<DD>
<pre>
⊢ ∀z. at z = mk_net (tendsto (mr1,z))
</pre>

<DT><span class="strong">at_infinity</span>
<DD>
<pre>
⊢ at_infinity = mk_net (λx y. abs x ≥ abs y)
</pre>

<DT><span class="strong">at_neginfinity</span>
<DD>
<pre>
⊢ at_neginfinity = mk_net (λx y. x ≤ y)
</pre>

<DT><span class="strong">at_posinfinity</span>
<DD>
<pre>
⊢ at_posinfinity = mk_net (λx y. x ≥ y)
</pre>

<DT><span class="strong">bounded</span>
<DD>
<pre>
⊢ ∀m g f. bounded (m,g) f ⇔ ∃k x N. g N N ∧ ∀n. g n N ⇒ dist m (f n,x) < k
</pre>

<DT><span class="strong">dorder</span>
<DD>
<pre>
⊢ ∀g. dorder g ⇔ ∀x y. g x x ∧ g y y ⇒ ∃z. g z z ∧ ∀w. g w z ⇒ g w x ∧ g w y
</pre>

<DT><span class="strong">eventually</span>
<DD>
<pre>
⊢ ∀p net.
    eventually p net ⇔
    trivial_limit net ∨ ∃y. (∃x. netord net x y) ∧ ∀x. netord net x y ⇒ p x
</pre>

<DT><span class="strong">in_direction</span>
<DD>
<pre>
⊢ ∀a v. (a in_direction v) = (at a within {b | ∃c. 0 ≤ c ∧ b − a = c * v})
</pre>

<DT><span class="strong">isnet</span>
<DD>
<pre>
⊢ ∀g. isnet g ⇔ ∀x y. (∀z. g z x ⇒ g z y) ∨ ∀z. g z y ⇒ g z x
</pre>

<DT><span class="strong">limit</span>
<DD>
<pre>
⊢ ∀top f l net.
    limit top f l net ⇔
    l ∈ topspace top ∧
    ∀u. open_in top u ∧ l ∈ u ⇒ eventually (λx. f x ∈ u) net
</pre>

<DT><span class="strong">net_TY_DEF</span>
<DD>
<pre>
⊢ ∃rep. TYPE_DEFINITION isnet rep
</pre>

<DT><span class="strong">netlimit</span>
<DD>
<pre>
⊢ ∀net. netlimit net = @a. ∀x. ¬netord net x a
</pre>

<DT><span class="strong">sequentially</span>
<DD>
<pre>
⊢ sequentially = mk_net (λm n. m ≥ n)
</pre>

<DT><span class="strong">tends</span>
<DD>
<pre>
⊢ ∀s l top g.
    (s tends l) (top,g) ⇔
    ∀N. neigh top (N,l) ⇒ ∃n. g n n ∧ ∀m. g m n ⇒ N (s m)
</pre>

<DT><span class="strong">tendsto</span>
<DD>
<pre>
⊢ ∀m x y z. tendsto (m,x) y z ⇔ 0 < dist m (x,y) ∧ dist m (x,y) ≤ dist m (x,z)
</pre>

<DT><span class="strong">trivial_limit</span>
<DD>
<pre>
⊢ ∀net.
    trivial_limit net ⇔
    (∀a b. a = b) ∨ ∃a b. a ≠ b ∧ ∀x. ¬netord net x a ∧ ¬netord net x b
</pre>

<DT><span class="strong">within</span>
<DD>
<pre>
⊢ ∀net s. (net within s) = mk_net (λx y. netord net x y ∧ x ∈ s)
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">ALWAYS_EVENTUALLY</span>
<DD>
<pre>
⊢ ∀net p. (∀x. p x) ⇒ eventually p net
</pre>

<DT><span class="strong">AT</span>
<DD>
<pre>
⊢ ∀a x y. netord (at a) x y ⇔ 0 < dist (x,a) ∧ dist (x,a) ≤ dist (y,a)
</pre>

<DT><span class="strong">AT_INFINITY</span>
<DD>
<pre>
⊢ ∀x y. netord at_infinity x y ⇔ abs x ≥ abs y
</pre>

<DT><span class="strong">AT_NEGINFINITY</span>
<DD>
<pre>
⊢ ∀x y. netord at_neginfinity x y ⇔ x ≤ y
</pre>

<DT><span class="strong">AT_POSINFINITY</span>
<DD>
<pre>
⊢ ∀x y. netord at_posinfinity x y ⇔ x ≥ y
</pre>

<DT><span class="strong">DORDER_LEMMA</span>
<DD>
<pre>
⊢ ∀g. dorder g ⇒
      ∀P Q.
        (∃n. g n n ∧ ∀m. g m n ⇒ P m) ∧ (∃n. g n n ∧ ∀m. g m n ⇒ Q m) ⇒
        ∃n. g n n ∧ ∀m. g m n ⇒ P m ∧ Q m
</pre>

<DT><span class="strong">DORDER_NET</span>
<DD>
<pre>
⊢ ∀n. dorder (netord n)
</pre>

<DT><span class="strong">DORDER_NGE</span>
<DD>
<pre>
⊢ dorder $>=
</pre>

<DT><span class="strong">DORDER_TENDSTO</span>
<DD>
<pre>
⊢ ∀m x. dorder (tendsto (m,x))
</pre>

<DT><span class="strong">EVENTUALLY_AND</span>
<DD>
<pre>
⊢ ∀net p q.
    eventually (λx. p x ∧ q x) net ⇔ eventually p net ∧ eventually q net
</pre>

<DT><span class="strong">EVENTUALLY_AT_INFINITY</span>
<DD>
<pre>
⊢ ∀p. eventually p at_infinity ⇔ ∃b. ∀x. abs x ≥ b ⇒ p x
</pre>

<DT><span class="strong">EVENTUALLY_AT_INFINITY_POS</span>
<DD>
<pre>
⊢ ∀p. eventually p at_infinity ⇔ ∃b. 0 < b ∧ ∀x. abs x ≥ b ⇒ p x
</pre>

<DT><span class="strong">EVENTUALLY_AT_NEGINFINITY</span>
<DD>
<pre>
⊢ ∀p. eventually p at_neginfinity ⇔ ∃b. ∀x. x ≤ b ⇒ p x
</pre>

<DT><span class="strong">EVENTUALLY_AT_POSINFINITY</span>
<DD>
<pre>
⊢ ∀p. eventually p at_posinfinity ⇔ ∃b. ∀x. x ≥ b ⇒ p x
</pre>

<DT><span class="strong">EVENTUALLY_FALSE</span>
<DD>
<pre>
⊢ ∀net. eventually (λx. F) net ⇔ trivial_limit net
</pre>

<DT><span class="strong">EVENTUALLY_FORALL</span>
<DD>
<pre>
⊢ ∀net p s.
    FINITE s ∧ s ≠ ∅ ⇒
    (eventually (λx. ∀a. a ∈ s ⇒ p a x) net ⇔ ∀a. a ∈ s ⇒ eventually (p a) net)
</pre>

<DT><span class="strong">EVENTUALLY_HAPPENS</span>
<DD>
<pre>
⊢ ∀net p. eventually p net ⇒ trivial_limit net ∨ ∃x. p x
</pre>

<DT><span class="strong">EVENTUALLY_MONO</span>
<DD>
<pre>
⊢ ∀net p q. (∀x. p x ⇒ q x) ∧ eventually p net ⇒ eventually q net
</pre>

<DT><span class="strong">EVENTUALLY_MP</span>
<DD>
<pre>
⊢ ∀net p q.
    eventually (λx. p x ⇒ q x) net ∧ eventually p net ⇒ eventually q net
</pre>

<DT><span class="strong">EVENTUALLY_SEQUENTIALLY</span>
<DD>
<pre>
⊢ ∀p. eventually p sequentially ⇔ ∃N. ∀n. N ≤ n ⇒ p n
</pre>

<DT><span class="strong">EVENTUALLY_TRUE</span>
<DD>
<pre>
⊢ ∀net. eventually (λx. T) net ⇔ T
</pre>

<DT><span class="strong">FORALL_EVENTUALLY</span>
<DD>
<pre>
⊢ ∀net p s.
    FINITE s ∧ s ≠ ∅ ⇒
    ((∀a. a ∈ s ⇒ eventually (p a) net) ⇔
     eventually (λx. ∀a. a ∈ s ⇒ p a x) net)
</pre>

<DT><span class="strong">IN_DIRECTION</span>
<DD>
<pre>
⊢ ∀a v x y.
    netord (a in_direction v) x y ⇔
    0 < dist (x,a) ∧ dist (x,a) ≤ dist (y,a) ∧ ∃c. 0 ≤ c ∧ x − a = c * v
</pre>

<DT><span class="strong">LIM_TENDS</span>
<DD>
<pre>
⊢ ∀m1 m2 f x0 y0.
    limpt (mtop m1) x0 𝕌(:α) ⇒
    ((f tends y0) (mtop m2,tendsto (m1,x0)) ⇔
     ∀e. 0 < e ⇒
         ∃d. 0 < d ∧
             ∀x. 0 < dist m1 (x,x0) ∧ dist m1 (x,x0) ≤ d ⇒
                 dist m2 (f x,y0) < e)
</pre>

<DT><span class="strong">LIM_TENDS2</span>
<DD>
<pre>
⊢ ∀m1 m2 f x0 y0.
    limpt (mtop m1) x0 𝕌(:α) ⇒
    ((f tends y0) (mtop m2,tendsto (m1,x0)) ⇔
     ∀e. 0 < e ⇒
         ∃d. 0 < d ∧
             ∀x. 0 < dist m1 (x,x0) ∧ dist m1 (x,x0) < d ⇒
                 dist m2 (f x,y0) < e)
</pre>

<DT><span class="strong">MR1_BOUNDED</span>
<DD>
<pre>
⊢ ∀g f. bounded (mr1,g) f ⇔ ∃k N. g N N ∧ ∀n. g n N ⇒ abs (f n) < k
</pre>

<DT><span class="strong">MTOP_TENDS</span>
<DD>
<pre>
⊢ ∀d g x x0.
    (x tends x0) (mtop d,g) ⇔
    ∀e. 0 < e ⇒ ∃n. g n n ∧ ∀m. g m n ⇒ dist d (x m,x0) < e
</pre>

<DT><span class="strong">MTOP_TENDS_UNIQ</span>
<DD>
<pre>
⊢ ∀g d. dorder g ⇒ (x tends x0) (mtop d,g) ∧ (x tends x1) (mtop d,g) ⇒ x0 = x1
</pre>

<DT><span class="strong">NET</span>
<DD>
<pre>
⊢ ∀n x y. (∀z. netord n z x ⇒ netord n z y) ∨ ∀z. netord n z y ⇒ netord n z x
</pre>

<DT><span class="strong">NETLIMIT_WITHIN</span>
<DD>
<pre>
⊢ ∀a s. ¬trivial_limit (at a within s) ⇒ netlimit (at a within s) = a
</pre>

<DT><span class="strong">NET_ABS</span>
<DD>
<pre>
⊢ ∀g x x0.
    (x tends x0) (mtop mr1,g) ⇒ ((λn. abs (x n)) tends abs x0) (mtop mr1,g)
</pre>

<DT><span class="strong">NET_ADD</span>
<DD>
<pre>
⊢ ∀g. dorder g ⇒
      ∀x x0 y y0.
        (x tends x0) (mtop mr1,g) ∧ (y tends y0) (mtop mr1,g) ⇒
        ((λn. x n + y n) tends (x0 + y0)) (mtop mr1,g)
</pre>

<DT><span class="strong">NET_CONV_BOUNDED</span>
<DD>
<pre>
⊢ ∀g x x0. (x tends x0) (mtop mr1,g) ⇒ bounded (mr1,g) x
</pre>

<DT><span class="strong">NET_CONV_IBOUNDED</span>
<DD>
<pre>
⊢ ∀g x x0. (x tends x0) (mtop mr1,g) ∧ x0 ≠ 0 ⇒ bounded (mr1,g) (λn. (x n)⁻¹)
</pre>

<DT><span class="strong">NET_CONV_NZ</span>
<DD>
<pre>
⊢ ∀g x x0.
    (x tends x0) (mtop mr1,g) ∧ x0 ≠ 0 ⇒ ∃N. g N N ∧ ∀n. g n N ⇒ x n ≠ 0
</pre>

<DT><span class="strong">NET_DILEMMA</span>
<DD>
<pre>
⊢ ∀net.
    (∃a. (∃x. netord net x a) ∧ ∀x. netord net x a ⇒ P x) ∧
    (∃b. (∃x. netord net x b) ∧ ∀x. netord net x b ⇒ Q x) ⇒
    ∃c. (∃x. netord net x c) ∧ ∀x. netord net x c ⇒ P x ∧ Q x
</pre>

<DT><span class="strong">NET_DIV</span>
<DD>
<pre>
⊢ ∀g. dorder g ⇒
      ∀x x0 y y0.
        (x tends x0) (mtop mr1,g) ∧ (y tends y0) (mtop mr1,g) ∧ y0 ≠ 0 ⇒
        ((λn. x n / y n) tends (x0 / y0)) (mtop mr1,g)
</pre>

<DT><span class="strong">NET_INV</span>
<DD>
<pre>
⊢ ∀g. dorder g ⇒
      ∀x x0.
        (x tends x0) (mtop mr1,g) ∧ x0 ≠ 0 ⇒
        ((λn. (x n)⁻¹) tends x0⁻¹) (mtop mr1,g)
</pre>

<DT><span class="strong">NET_LE</span>
<DD>
<pre>
⊢ ∀g. dorder g ⇒
      ∀x x0 y y0.
        (x tends x0) (mtop mr1,g) ∧ (y tends y0) (mtop mr1,g) ∧
        (∃N. g N N ∧ ∀n. g n N ⇒ x n ≤ y n) ⇒
        x0 ≤ y0
</pre>

<DT><span class="strong">NET_MUL</span>
<DD>
<pre>
⊢ ∀g. dorder g ⇒
      ∀x y x0 y0.
        (x tends x0) (mtop mr1,g) ∧ (y tends y0) (mtop mr1,g) ⇒
        ((λn. x n * y n) tends (x0 * y0)) (mtop mr1,g)
</pre>

<DT><span class="strong">NET_NEG</span>
<DD>
<pre>
⊢ ∀g. dorder g ⇒
      ∀x x0. (x tends x0) (mtop mr1,g) ⇔ ((λn. -x n) tends -x0) (mtop mr1,g)
</pre>

<DT><span class="strong">NET_NULL</span>
<DD>
<pre>
⊢ ∀g x x0. (x tends x0) (mtop mr1,g) ⇔ ((λn. x n − x0) tends 0) (mtop mr1,g)
</pre>

<DT><span class="strong">NET_NULL_ADD</span>
<DD>
<pre>
⊢ ∀g. dorder g ⇒
      ∀x y.
        (x tends 0) (mtop mr1,g) ∧ (y tends 0) (mtop mr1,g) ⇒
        ((λn. x n + y n) tends 0) (mtop mr1,g)
</pre>

<DT><span class="strong">NET_NULL_CMUL</span>
<DD>
<pre>
⊢ ∀g k x. (x tends 0) (mtop mr1,g) ⇒ ((λn. k * x n) tends 0) (mtop mr1,g)
</pre>

<DT><span class="strong">NET_NULL_MUL</span>
<DD>
<pre>
⊢ ∀g. dorder g ⇒
      ∀x y.
        bounded (mr1,g) x ∧ (y tends 0) (mtop mr1,g) ⇒
        ((λn. x n * y n) tends 0) (mtop mr1,g)
</pre>

<DT><span class="strong">NET_SUB</span>
<DD>
<pre>
⊢ ∀g. dorder g ⇒
      ∀x x0 y y0.
        (x tends x0) (mtop mr1,g) ∧ (y tends y0) (mtop mr1,g) ⇒
        ((λn. x n − y n) tends (x0 − y0)) (mtop mr1,g)
</pre>

<DT><span class="strong">NONTRIVIAL_LIMIT_WITHIN</span>
<DD>
<pre>
⊢ ∀net s. trivial_limit net ⇒ trivial_limit (net within s)
</pre>

<DT><span class="strong">NOT_EVENTUALLY</span>
<DD>
<pre>
⊢ ∀net p. (∀x. ¬p x) ∧ ¬trivial_limit net ⇒ ¬eventually p net
</pre>

<DT><span class="strong">OLDNET</span>
<DD>
<pre>
⊢ ∀n x y.
    netord n x x ∧ netord n y y ⇒
    ∃z. netord n z z ∧ ∀w. netord n w z ⇒ netord n w x ∧ netord n w y
</pre>

<DT><span class="strong">REAL_CHOOSE_SIZE</span>
<DD>
<pre>
⊢ ∀c. 0 ≤ c ⇒ ∃x. abs x = c
</pre>

<DT><span class="strong">SEQUENTIALLY</span>
<DD>
<pre>
⊢ ∀m n. netord sequentially m n ⇔ m ≥ n
</pre>

<DT><span class="strong">SEQ_TENDS</span>
<DD>
<pre>
⊢ ∀d x x0.
    (x tends x0) (mtop d,$>=) ⇔
    ∀e. 0 < e ⇒ ∃N. ∀n. n ≥ N ⇒ dist d (x n,x0) < e
</pre>

<DT><span class="strong">TRIVIAL_LIMIT_AT_INFINITY</span>
<DD>
<pre>
⊢ ¬trivial_limit at_infinity
</pre>

<DT><span class="strong">TRIVIAL_LIMIT_AT_NEGINFINITY</span>
<DD>
<pre>
⊢ ¬trivial_limit at_neginfinity
</pre>

<DT><span class="strong">TRIVIAL_LIMIT_AT_POSINFINITY</span>
<DD>
<pre>
⊢ ¬trivial_limit at_posinfinity
</pre>

<DT><span class="strong">TRIVIAL_LIMIT_SEQUENTIALLY</span>
<DD>
<pre>
⊢ ¬trivial_limit sequentially
</pre>

<DT><span class="strong">WITHIN</span>
<DD>
<pre>
⊢ ∀n s x y. netord (n within s) x y ⇔ netord n x y ∧ x ∈ s
</pre>

<DT><span class="strong">WITHIN_UNIV</span>
<DD>
<pre>
⊢ ∀x. (at x within 𝕌(:real)) = at x
</pre>

<DT><span class="strong">WITHIN_WITHIN</span>
<DD>
<pre>
⊢ ∀net s t. ((net within s) within t) = (net within s ∩ t)
</pre>

<DT><span class="strong">at</span>
<DD>
<pre>
⊢ ∀a. at a = mk_net (λx y. 0 < dist (x,a) ∧ dist (x,a) ≤ dist (y,a))
</pre>

<DT><span class="strong">limit_alt_tends</span>
<DD>
<pre>
⊢ ∀top f l net.
    ¬trivial_limit net ∧ l ∈ topspace top ∧
    (∀x y. netord net x y ⇒ netord net y y) ⇒
    (limit top f l net ⇔ (f tends l) (top,netord net))
</pre>

<DT><span class="strong">net_tybij</span>
<DD>
<pre>
⊢ (∀a. mk_net (netord a) = a) ∧
  ∀r. (∀x y. (∀z. r z x ⇒ r z y) ∨ ∀z. r z y ⇒ r z x) ⇔ netord (mk_net r) = r
</pre>

<DT><span class="strong">tends_imp_limit</span>
<DD>
<pre>
⊢ ∀top f l net.
    ¬trivial_limit net ∧ l ∈ topspace top ⇒
    (f tends l) (top,netord net) ⇒
    limit top f l net
</pre>

<DT><span class="strong">tendsto_mr1</span>
<DD>
<pre>
⊢ ∀m a. tendsto (mr1,a) = netord (at a)
</pre>

<DT><span class="strong">trivial_limit_def</span>
<DD>
<pre>
⊢ ∀net. trivial_limit net ⇔ eventually (λx. F) net
</pre>

</DL>



<hr>
</body>
</html>
