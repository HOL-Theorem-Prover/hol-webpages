<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: ltree</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "ltree"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "alistTheory.html"><span class="strong">alist</span></a>&nbsp;&nbsp;
    <a href = "llistTheory.html"><span class="strong">llist</span></a>&nbsp;&nbsp;
    <a href = "iterateTheory.html"><span class="strong">iterate</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Type <th> Arity<tr><td> <span class="strong">ltree</span> <td> 1
    <tr><td> <span class="strong">rose_tree</span> <td> 1
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">Branch</span>
    <td>
    :α -> α ltree llist -> α ltree
    <tr><td>
    <span class="strong">Branch_rep</span>
    <td>
    :α -> (num list -> α # num option) llist -> num list -> α # num option
    <tr><td>
    <span class="strong">Rose</span>
    <td>
    :α -> α rose_tree list -> α rose_tree
    <tr><td>
    <span class="strong">dest_Branch_rep</span>
    <td>
    :(num list -> α # num option) -> α # (num list -> α # num option) llist
    <tr><td>
    <span class="strong">finite_branching</span>
    <td>
    :α ltree -> bool
    <tr><td>
    <span class="strong">from_rose</span>
    <td>
    :α rose_tree -> α ltree
    <tr><td>
    <span class="strong">gen_ltree</span>
    <td>
    :(num list -> α # num option) -> α ltree
    <tr><td>
    <span class="strong">ltree_CASE</span>
    <td>
    :β ltree -> (β -> β ltree llist -> α) -> α
    <tr><td>
    <span class="strong">ltree_abs</span>
    <td>
    :(num list -> α # num option) -> α ltree
    <tr><td>
    <span class="strong">ltree_branching</span>
    <td>
    :α ltree -> num list -> num option
    <tr><td>
    <span class="strong">ltree_children</span>
    <td>
    :α ltree -> α ltree llist
    <tr><td>
    <span class="strong">ltree_delete</span>
    <td>
    :(α -> α) -> α ltree -> num list -> α ltree
    <tr><td>
    <span class="strong">ltree_el</span>
    <td>
    :α ltree -> num list -> (α # num option) option
    <tr><td>
    <span class="strong">ltree_every</span>
    <td>
    :(α -> α ltree llist -> bool) -> α ltree -> bool
    <tr><td> <span class="strong">ltree_finite</span> <td> :α ltree -> bool
    <tr><td>
    <span class="strong">ltree_insert</span>
    <td>
    :(α -> α) -> α ltree -> num list -> α ltree -> α ltree
    <tr><td>
    <span class="strong">ltree_lookup</span>
    <td>
    :α ltree -> num list -> α ltree option
    <tr><td>
    <span class="strong">ltree_map</span>
    <td>
    :(α -> β) -> α ltree -> β ltree
    <tr><td> <span class="strong">ltree_node</span> <td> :α ltree -> α
    <tr><td>
    <span class="strong">ltree_paths</span>
    <td>
    :α ltree -> num list -> bool
    <tr><td>
    <span class="strong">ltree_rel</span>
    <td>
    :(α -> β -> bool) -> α ltree -> β ltree -> bool
    <tr><td>
    <span class="strong">ltree_rep</span>
    <td>
    :α ltree -> num list -> α # num option
    <tr><td>
    <span class="strong">ltree_rep_ok</span>
    <td>
    :(num list -> α # num option) -> bool
    <tr><td> <span class="strong">ltree_set</span> <td> :α ltree -> α -> bool
    <tr><td>
    <span class="strong">ltree_unfold</span>
    <td>
    :(β -> α # β llist) -> β -> α ltree
    <tr><td>
    <span class="strong">make_ltree_rep</span>
    <td>
    :(num list -> α # num option) -> num list -> α # num option
    <tr><td>
    <span class="strong">make_unfold</span>
    <td>
    :(β -> α # β llist) -> β -> num list -> α # num option
    <tr><td>
    <span class="strong">parent_inclusive</span>
    <td>
    :(num list -> bool) -> bool
    <tr><td>
    <span class="strong">path_index</span>
    <td>
    :(num list -> bool) -> num -> num list
    <tr><td>
    <span class="strong">path_ok</span>
    <td>
    :num list -> (num list -> α # num option) -> bool
    <tr><td>
    <span class="strong">rose_children</span>
    <td>
    :α rose_tree -> α rose_tree list
    <tr><td> <span class="strong">rose_node</span> <td> :α rose_tree -> α
    <tr><td>
    <span class="strong">rose_reduce</span>
    <td>
    :(α -> β list -> β) -> α rose_tree -> β
    <tr><td>
    <span class="strong">rose_tree1_size</span>
    <td>
    :(α -> num) -> α rose_tree list -> num
    <tr><td>
    <span class="strong">rose_tree_CASE</span>
    <td>
    :α rose_tree -> (α -> α rose_tree list -> β) -> β
    <tr><td>
    <span class="strong">rose_tree_size</span>
    <td>
    :(α -> num) -> α rose_tree -> num
    <tr><td>
    <span class="strong">sibling_inclusive</span>
    <td>
    :(num list -> bool) -> bool
    <tr><td>
    <span class="strong">subtrees</span>
    <td>
    :α ltree -> α ltree -> bool
    <tr><td> <span class="strong">to_rose</span> <td> :α ltree -> α rose_tree
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">@templtree_every_def</span>
<DD>
<pre>
⊢ ltree_every =
  (λP a0.
       ∃ltree_every'.
         ltree_every' a0 ∧
         ∀a0.
           ltree_every' a0 ⇒
           ∃a ts. a0 = Branch a ts ∧ P a ts ∧ every ltree_every' ts)
</pre>

<DT><span class="strong">@templtree_finite_def</span>
<DD>
<pre>
⊢ ltree_finite =
  (λa0.
       ∀ltree_finite'.
         (∀a0.
            (∃a ts. a0 = Branch a (fromList ts) ∧ EVERY ltree_finite' ts) ⇒
            ltree_finite' a0) ⇒
         ltree_finite' a0)
</pre>

<DT><span class="strong">finite_branching_def</span>
<DD>
<pre>
⊢ finite_branching = ltree_every (λa ts. LFINITE ts)
</pre>

<DT><span class="strong">ltree_TY_DEF</span>
<DD>
<pre>
⊢ ∃rep. TYPE_DEFINITION ltree_rep_ok rep
</pre>

<DT><span class="strong">ltree_branching_def</span>
<DD>
<pre>
⊢ ∀t p. ltree_branching t p = SND (THE (ltree_el t p))
</pre>

<DT><span class="strong">ltree_children_def_primitive</span>
<DD>
<pre>
⊢ ltree_children =
  WFREC (@R. WF R) (λltree_children a'. case a' of Branch a ts => I ts)
</pre>

<DT><span class="strong">ltree_delete_def</span>
<DD>
<pre>
⊢ ∀f t p.
    ltree_delete f t p =
    gen_ltree
      (λns.
           (let
              (d,len) = THE (ltree_el t ns);
              m = THE len
            in
              if ns = p ∧ len ≠ NONE ∧ 0 < m then (f d,SOME (m − 1))
              else (d,len)))
</pre>

<DT><span class="strong">ltree_insert_def</span>
<DD>
<pre>
⊢ ∀f t p t0.
    ltree_insert f t p t0 =
    gen_ltree
      (λns.
           if ltree_el t ns ≠ NONE then
             (let
                (d,len) = THE (ltree_el t ns);
                m = THE len
              in
                if ns = p ∧ len ≠ NONE then (f d,SOME (m + 1)) else (d,len))
           else THE (ltree_el t0 (DROP (LENGTH p + 1) ns)))
</pre>

<DT><span class="strong">ltree_map_def</span>
<DD>
<pre>
⊢ ∀f. ltree_map f = ltree_unfold (λt. case t of Branch a ts => (f a,ts))
</pre>

<DT><span class="strong">ltree_node_def_primitive</span>
<DD>
<pre>
⊢ ltree_node =
  WFREC (@R. WF R) (λltree_node a'. case a' of Branch a ts => I a)
</pre>

<DT><span class="strong">ltree_paths_def</span>
<DD>
<pre>
⊢ ∀t. ltree_paths t = {p | ltree_lookup t p ≠ NONE}
</pre>

<DT><span class="strong">ltree_rel_def</span>
<DD>
<pre>
⊢ ∀R x y.
    ltree_rel R x y ⇔
    ∀path.
      OPTREL (λx y. R (FST x) (FST y) ∧ SND x = SND y) (ltree_el x path)
        (ltree_el y path)
</pre>

<DT><span class="strong">ltree_set_def</span>
<DD>
<pre>
⊢ ∀t. ltree_set t = {a | ∃ts. Branch a ts ∈ subtrees t}
</pre>

<DT><span class="strong">parent_inclusive_def</span>
<DD>
<pre>
⊢ ∀s. parent_inclusive s ⇔ ∀p q. p ∈ s ∧ q ≼ p ⇒ q ∈ s
</pre>

<DT><span class="strong">path_index_def</span>
<DD>
<pre>
⊢ ∀s. FINITE s ⇒
      s = IMAGE (path_index s) (count (CARD s)) ∧
      ∀j k.
        j < CARD s ∧ k < CARD s ∧ j < k ⇒
        ¬ltree_path_lt (path_index s k) (path_index s j)
</pre>

<DT><span class="strong">rose_children_def</span>
<DD>
<pre>
⊢ ∀a ts. rose_children (Rose a ts) = ts
</pre>

<DT><span class="strong">rose_node_def</span>
<DD>
<pre>
⊢ ∀a ts. rose_node (Rose a ts) = a
</pre>

<DT><span class="strong">rose_tree_TY_DEF</span>
<DD>
<pre>
⊢ ∃rep.
    TYPE_DEFINITION
      (λa0'.
           ∀ $var$('rose_tree') $var$('@temp@ind_typeltree0list').
             (∀a0'.
                (∃a0 a1.
                   a0' =
                   (λa0 a1.
                        ind_type$CONSTR 0 a0
                          (ind_type$FCONS a1 (λn. ind_type$BOTTOM))) a0 a1 ∧
                   $var$('@temp@ind_typeltree0list') a1) ⇒
                $var$('rose_tree') a0') ∧
             (∀a1'.
                a1' = ind_type$CONSTR (SUC 0) ARB (λn. ind_type$BOTTOM) ∨
                (∃a0 a1.
                   a1' =
                   (λa0 a1.
                        ind_type$CONSTR (SUC (SUC 0)) ARB
                          (ind_type$FCONS a0
                             (ind_type$FCONS a1 (λn. ind_type$BOTTOM)))) a0 a1 ∧
                   $var$('rose_tree') a0 ∧
                   $var$('@temp@ind_typeltree0list') a1) ⇒
                $var$('@temp@ind_typeltree0list') a1') ⇒
             $var$('rose_tree') a0') rep
</pre>

<DT><span class="strong">rose_tree_case_def</span>
<DD>
<pre>
⊢ ∀a0 a1 f. rose_tree_CASE (Rose a0 a1) f = f a0 a1
</pre>

<DT><span class="strong">rose_tree_size_def</span>
<DD>
<pre>
⊢ (∀f a0 a1. rose_tree_size f (Rose a0 a1) = 1 + (f a0 + rose_tree1_size f a1)) ∧
  (∀f. rose_tree1_size f [] = 0) ∧
  ∀f a0 a1.
    rose_tree1_size f (a0::a1) =
    1 + (rose_tree_size f a0 + rose_tree1_size f a1)
</pre>

<DT><span class="strong">sibling_inclusive_def</span>
<DD>
<pre>
⊢ ∀s. sibling_inclusive s ⇔
      ∀p q.
        p ∈ s ∧ p ≠ [] ∧ q ≠ [] ∧ FRONT q = FRONT p ∧ LAST q < LAST p ⇒ q ∈ s
</pre>

<DT><span class="strong">subtrees_def</span>
<DD>
<pre>
⊢ ∀t. subtrees t = {u | ∃path. ltree_lookup t path = SOME u}
</pre>

<DT><span class="strong">to_rose_def</span>
<DD>
<pre>
⊢ ∀t. ltree_finite t ⇒ from_rose (to_rose t) = t
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">Branch_11</span>
<DD>
<pre>
⊢ ∀a1 a2 ts1 ts2. Branch a1 ts1 = Branch a2 ts2 ⇔ a1 = a2 ∧ ts1 = ts2
</pre>

<DT><span class="strong">IN_ltree_paths</span>
<DD>
<pre>
⊢ ∀p t. p ∈ ltree_paths t ⇔ ltree_lookup t p ≠ NONE
</pre>

<DT><span class="strong">NIL_IN_ltree_paths</span>
<DD>
<pre>
⊢ [] ∈ ltree_paths t
</pre>

<DT><span class="strong">datatype_ltree</span>
<DD>
<pre>
⊢ DATATYPE (ltree Branch)
</pre>

<DT><span class="strong">datatype_rose_tree</span>
<DD>
<pre>
⊢ DATATYPE (rose_tree Rose)
</pre>

<DT><span class="strong">finite_branching_cases</span>
<DD>
<pre>
⊢ ∀t. finite_branching t ⇔
      ∃a ts. t = Branch a (fromList ts) ∧ EVERY finite_branching ts
</pre>

<DT><span class="strong">finite_branching_cases'</span>
<DD>
<pre>
⊢ ∀t. finite_branching t ⇔
      ∃a ts. t = Branch a ts ∧ LFINITE ts ∧ every finite_branching ts
</pre>

<DT><span class="strong">finite_branching_coind</span>
<DD>
<pre>
⊢ ∀P. (∀t. P t ⇒ ∃a ts. t = Branch a (fromList ts) ∧ EVERY P ts) ⇒
      ∀t. P t ⇒ finite_branching t
</pre>

<DT><span class="strong">finite_branching_coind'</span>
<DD>
<pre>
⊢ ∀P. (∀t. P t ⇒ ∃a ts. t = Branch a ts ∧ LFINITE ts ∧ every P ts) ⇒
      ∀t. P t ⇒ finite_branching t
</pre>

<DT><span class="strong">finite_branching_ltree_el_cases</span>
<DD>
<pre>
⊢ ∀p t.
    finite_branching t ∧ p ∈ ltree_paths t ⇒
    ∃d m. ltree_el t p = SOME (d,SOME m)
</pre>

<DT><span class="strong">finite_branching_rewrite</span>
<DD>
<pre>
⊢ finite_branching (Branch a ts) ⇔ LFINITE ts ∧ every finite_branching ts
</pre>

<DT><span class="strong">finite_branching_rules</span>
<DD>
<pre>
⊢ ∀a ts. EVERY finite_branching ts ⇒ finite_branching (Branch a (fromList ts))
</pre>

<DT><span class="strong">finite_branching_rules'</span>
<DD>
<pre>
⊢ ∀a ts.
    LFINITE ts ∧ every finite_branching ts ⇒ finite_branching (Branch a ts)
</pre>

<DT><span class="strong">from_rose</span>
<DD>
<pre>
⊢ ∀t. from_rose t =
      Branch (rose_node t) (fromList (MAP from_rose (rose_children t)))
</pre>

<DT><span class="strong">from_rose_11</span>
<DD>
<pre>
⊢ ∀r1 r2. from_rose r1 = from_rose r2 ⇔ r1 = r2
</pre>

<DT><span class="strong">from_rose_def</span>
<DD>
<pre>
⊢ ∀ts a. from_rose (Rose a ts) = Branch a (fromList (MAP from_rose ts))
</pre>

<DT><span class="strong">from_rose_ind</span>
<DD>
<pre>
⊢ ∀P. (∀a ts. (∀a'. MEM a' ts ⇒ P a') ⇒ P (Rose a ts)) ⇒ ∀v. P v
</pre>

<DT><span class="strong">gen_ltree</span>
<DD>
<pre>
⊢ gen_ltree f =
  (let
     (a,len) = f []
   in
     Branch a (LGENLIST (λn. gen_ltree (λpath. f (n::path))) len))
</pre>

<DT><span class="strong">gen_ltree_LNIL</span>
<DD>
<pre>
⊢ gen_ltree f = Branch a [||] ⇔ f [] = (a,SOME 0)
</pre>

<DT><span class="strong">gen_ltree_unchanged</span>
<DD>
<pre>
⊢ ∀t. gen_ltree (λp. THE (ltree_el t p)) = t
</pre>

<DT><span class="strong">gen_ltree_unchanged_extra</span>
<DD>
<pre>
⊢ ∀t f.
    gen_ltree (λp. if ltree_el t p ≠ NONE then THE (ltree_el t p) else f p) =
    t
</pre>

<DT><span class="strong">ltree_CASE</span>
<DD>
<pre>
⊢ ltree_CASE (Branch a ts) f = f a ts
</pre>

<DT><span class="strong">ltree_CASE_cong</span>
<DD>
<pre>
⊢ ∀M M' f f'.
    M = M' ∧ (∀a ts. M' = Branch a ts ⇒ f a ts = f' a ts) ⇒
    ltree_CASE M f = ltree_CASE M' f'
</pre>

<DT><span class="strong">ltree_CASE_elim</span>
<DD>
<pre>
⊢ ∀f'. f' (ltree_CASE t f) ⇔ ∃a ts. t = Branch a ts ∧ f' (f a ts)
</pre>

<DT><span class="strong">ltree_CASE_eq</span>
<DD>
<pre>
⊢ ltree_CASE t f = v ⇔ ∃a ts. t = Branch a ts ∧ f a ts = v
</pre>

<DT><span class="strong">ltree_bisimulation</span>
<DD>
<pre>
⊢ ∀t1 t2.
    t1 = t2 ⇔
    ∃R. R t1 t2 ∧
        ∀a ts a' ts'.
          R (Branch a ts) (Branch a' ts') ⇒ a = a' ∧ llist_rel R ts ts'
</pre>

<DT><span class="strong">ltree_branching_CONS</span>
<DD>
<pre>
⊢ ∀h p a ts.
    h::p ∈ ltree_paths (Branch a ts) ⇒
    ltree_branching (Branch a ts) (h::p) = ltree_branching (THE (LNTH h ts)) p
</pre>

<DT><span class="strong">ltree_branching_NIL</span>
<DD>
<pre>
⊢ ∀a ts. ltree_branching (Branch a ts) [] = LLENGTH ts
</pre>

<DT><span class="strong">ltree_branching_alt_ltree_lookup</span>
<DD>
<pre>
⊢ ∀p t.
    p ∈ ltree_paths t ⇒
    ltree_branching t p = LLENGTH (ltree_children (THE (ltree_lookup t p)))
</pre>

<DT><span class="strong">ltree_branching_ltree_paths</span>
<DD>
<pre>
⊢ ∀p t m.
    p ∈ ltree_paths t ∧ ltree_branching t p = SOME m ⇒
    ∀h. h < m ⇔ SNOC h p ∈ ltree_paths t
</pre>

<DT><span class="strong">ltree_cases</span>
<DD>
<pre>
⊢ ∀t. ∃a ts. t = Branch a ts
</pre>

<DT><span class="strong">ltree_children_def</span>
<DD>
<pre>
⊢ ltree_children (Branch a ts) = ts
</pre>

<DT><span class="strong">ltree_children_ind</span>
<DD>
<pre>
⊢ ∀P. (∀a ts. P (Branch a ts)) ⇒ ∀v. P v
</pre>

<DT><span class="strong">ltree_delete_CONS</span>
<DD>
<pre>
⊢ ∀f a ts h p t.
    LNTH h ts = SOME t ∧ ltree_el t p ≠ NONE ⇒
    ltree_delete f (Branch a ts) (h::p) =
    Branch a
      (LGENLIST
         (λi.
              if i = h then ltree_delete f (THE (LNTH h ts)) p
              else THE (LNTH i ts)) (LLENGTH ts))
</pre>

<DT><span class="strong">ltree_delete_NIL</span>
<DD>
<pre>
⊢ ∀f a ts.
    ltree_delete f (Branch a ts) [] =
    if LFINITE ts ∧ 0 < THE (LLENGTH ts) then
      Branch (f a)
        (LGENLIST (λi. THE (LNTH i ts)) (SOME (THE (LLENGTH ts) − 1)))
    else Branch a ts
</pre>

<DT><span class="strong">ltree_delete_path_stable</span>
<DD>
<pre>
⊢ ∀f p t. p ∈ ltree_paths t ⇒ p ∈ ltree_paths (ltree_delete f t p)
</pre>

<DT><span class="strong">ltree_delete_paths</span>
<DD>
<pre>
⊢ ∀f p t n.
    p ∈ ltree_paths t ∧ ltree_branching t p = SOME (SUC n) ⇒
    ltree_paths (ltree_delete f t p) =
    ltree_paths t DIFF
    IMAGE (λq. SNOC n p ++ q) (ltree_paths (THE (ltree_lookup t (SNOC n p))))
</pre>

<DT><span class="strong">ltree_el</span>
<DD>
<pre>
⊢ ltree_el t [] = SOME (ltree_node t,LLENGTH (ltree_children t)) ∧
  ltree_el t (n::ns) =
  case LNTH n (ltree_children t) of NONE => NONE | SOME a => ltree_el a ns
</pre>

<DT><span class="strong">ltree_el_alt_ltree_lookup</span>
<DD>
<pre>
⊢ ∀p t.
    p ∈ ltree_paths t ⇒
    ltree_el t p =
    do
      t' <- ltree_lookup t p;
      SOME (ltree_node t',LLENGTH (ltree_children t'))
    od
</pre>

<DT><span class="strong">ltree_el_def</span>
<DD>
<pre>
⊢ ltree_el (Branch a ts) [] = SOME (a,LLENGTH ts) ∧
  ltree_el (Branch a ts) (n::ns) =
  case LNTH n ts of NONE => NONE | SOME t => ltree_el t ns
</pre>

<DT><span class="strong">ltree_el_eqv</span>
<DD>
<pre>
⊢ ∀t1 t2. t1 = t2 ⇔ ∀path. ltree_el t1 path = ltree_el t2 path
</pre>

<DT><span class="strong">ltree_el_ltree_delete</span>
<DD>
<pre>
⊢ ∀f p t.
    ltree_el t p = SOME (a,SOME (SUC n)) ⇒
    ltree_el (ltree_delete f t p) p = SOME (f a,SOME n)
</pre>

<DT><span class="strong">ltree_el_ltree_delete'</span>
<DD>
<pre>
⊢ ∀p t.
    ltree_el t p = SOME (a,SOME (SUC n)) ⇒
    ltree_el (ltree_delete' t p) p = SOME (a,SOME n)
</pre>

<DT><span class="strong">ltree_el_ltree_insert</span>
<DD>
<pre>
⊢ ∀f p t t0.
    ltree_el t p = SOME (a,SOME n) ⇒
    ltree_el (ltree_insert f t p t0) p = SOME (f a,SOME (SUC n))
</pre>

<DT><span class="strong">ltree_el_ltree_insert'</span>
<DD>
<pre>
⊢ ∀p t t0.
    ltree_el t p = SOME (a,SOME n) ⇒
    ltree_el (ltree_insert' t p t0) p = SOME (a,SOME (SUC n))
</pre>

<DT><span class="strong">ltree_el_valid</span>
<DD>
<pre>
⊢ ∀p t. p ∈ ltree_paths t ⇔ ltree_el t p ≠ NONE
</pre>

<DT><span class="strong">ltree_el_valid_inclusive</span>
<DD>
<pre>
⊢ ∀p t. p ∈ ltree_paths t ⇔ ∀p'. p' ≼ p ⇒ ltree_el t p' ≠ NONE
</pre>

<DT><span class="strong">ltree_every_cases</span>
<DD>
<pre>
⊢ ∀P a0.
    ltree_every P a0 ⇔
    ∃a ts. a0 = Branch a ts ∧ P a ts ∧ every (ltree_every P) ts
</pre>

<DT><span class="strong">ltree_every_coind</span>
<DD>
<pre>
⊢ ∀P ltree_every'.
    (∀a0.
       ltree_every' a0 ⇒
       ∃a ts. a0 = Branch a ts ∧ P a ts ∧ every ltree_every' ts) ⇒
    ∀a0. ltree_every' a0 ⇒ ltree_every P a0
</pre>

<DT><span class="strong">ltree_every_rewrite</span>
<DD>
<pre>
⊢ ltree_every P (Branch a ts) ⇔ P a ts ∧ every (ltree_every P) ts
</pre>

<DT><span class="strong">ltree_every_rules</span>
<DD>
<pre>
⊢ ∀P a ts. P a ts ∧ every (ltree_every P) ts ⇒ ltree_every P (Branch a ts)
</pre>

<DT><span class="strong">ltree_finite</span>
<DD>
<pre>
⊢ ltree_finite (Branch a ts) ⇔ LFINITE ts ∧ ∀t. t ∈ LSET ts ⇒ ltree_finite t
</pre>

<DT><span class="strong">ltree_finite_alt_ltree_paths</span>
<DD>
<pre>
⊢ ∀t. ltree_finite t ⇔ FINITE (ltree_paths t)
</pre>

<DT><span class="strong">ltree_finite_by_unfolding</span>
<DD>
<pre>
⊢ ∀P f.
    (∃m. ∀seed.
       P seed ⇒
       (let
          (a,seeds) = f seed
        in
          LFINITE seeds ∧ every (λe. P e ∧ m e < m seed) seeds)) ⇒
    ∀seed. P seed ⇒ ltree_finite (ltree_unfold f seed)
</pre>

<DT><span class="strong">ltree_finite_by_unfolding'</span>
<DD>
<pre>
⊢ ∀f. (∃m. ∀seed.
         (let
            (a,seeds) = f seed
          in
            LFINITE seeds ∧ every (λe. m e < m seed) seeds)) ⇒
      ∀seed. ltree_finite (ltree_unfold f seed)
</pre>

<DT><span class="strong">ltree_finite_cases</span>
<DD>
<pre>
⊢ ∀a0.
    ltree_finite a0 ⇔
    ∃a ts. a0 = Branch a (fromList ts) ∧ EVERY ltree_finite ts
</pre>

<DT><span class="strong">ltree_finite_from_rose</span>
<DD>
<pre>
⊢ ltree_finite t ⇔ ∃r. from_rose r = t
</pre>

<DT><span class="strong">ltree_finite_imp_finite_branching</span>
<DD>
<pre>
⊢ ∀t. ltree_finite t ⇒ finite_branching t
</pre>

<DT><span class="strong">ltree_finite_imp_finite_ltree_paths</span>
<DD>
<pre>
⊢ ∀t. ltree_finite t ⇒ FINITE (ltree_paths t)
</pre>

<DT><span class="strong">ltree_finite_ind</span>
<DD>
<pre>
⊢ ∀P. (∀a ts. EVERY P ts ⇒ P (Branch a (fromList ts))) ⇒
      ∀t. ltree_finite t ⇒ P t
</pre>

<DT><span class="strong">ltree_finite_ltree_insert</span>
<DD>
<pre>
⊢ ∀f p t t0.
    ltree_finite t ∧ p ∈ ltree_paths t ∧ ltree_finite t0 ⇒
    ltree_finite (ltree_insert f t p t0)
</pre>

<DT><span class="strong">ltree_finite_rules</span>
<DD>
<pre>
⊢ ∀a ts. EVERY ltree_finite ts ⇒ ltree_finite (Branch a (fromList ts))
</pre>

<DT><span class="strong">ltree_finite_strongind</span>
<DD>
<pre>
⊢ ∀P. (∀a ts.
         EVERY (λa0. ltree_finite a0 ∧ P a0) ts ⇒ P (Branch a (fromList ts))) ⇒
      ∀t. ltree_finite t ⇒ P t
</pre>

<DT><span class="strong">ltree_insert_CONS</span>
<DD>
<pre>
⊢ ∀f a ts h p t t0.
    LNTH h ts = SOME t ∧ ltree_el t p ≠ NONE ⇒
    ltree_insert f (Branch a ts) (h::p) t0 =
    Branch a
      (LGENLIST
         (λi.
              if i = h then ltree_insert f (THE (LNTH h ts)) p t0
              else THE (LNTH i ts)) (LLENGTH ts))
</pre>

<DT><span class="strong">ltree_insert_NIL</span>
<DD>
<pre>
⊢ ∀f a ts t0.
    ltree_insert f (Branch a ts) [] t0 =
    if LFINITE ts then
      Branch (f a)
        (LGENLIST (λi. if i < THE (LLENGTH ts) then THE (LNTH i ts) else t0)
           (SOME (THE (LLENGTH ts) + 1)))
    else Branch a ts
</pre>

<DT><span class="strong">ltree_insert_delete</span>
<DD>
<pre>
⊢ ∀n p t t0 f g d len.
    ltree_branching t p = SOME (SUC n) ∧ ltree_lookup t (SNOC n p) = SOME t0 ∧
    ltree_el t p = SOME (d,len) ∧ f (g d) = d ⇒
    ltree_insert f (ltree_delete g t p) p t0 = t
</pre>

<DT><span class="strong">ltree_insert_delete'</span>
<DD>
<pre>
⊢ ∀n p t t0.
    ltree_branching t p = SOME (SUC n) ∧ ltree_lookup t (SNOC n p) = SOME t0 ⇒
    ltree_insert' (ltree_delete' t p) p t0 = t
</pre>

<DT><span class="strong">ltree_insert_path_stable</span>
<DD>
<pre>
⊢ ∀f p t t0. p ∈ ltree_paths t ⇒ p ∈ ltree_paths (ltree_insert f t p t0)
</pre>

<DT><span class="strong">ltree_insert_paths</span>
<DD>
<pre>
⊢ ∀f p t n t0.
    p ∈ ltree_paths t ∧ ltree_branching t p = SOME n ⇒
    ltree_paths (ltree_insert f t p t0) =
    ltree_paths t ∪ IMAGE (λq. SNOC n p ++ q) (ltree_paths t0)
</pre>

<DT><span class="strong">ltree_lookup</span>
<DD>
<pre>
⊢ ltree_lookup t [] = SOME t ∧
  ltree_lookup t (n::ns) =
  case LNTH n (ltree_children t) of NONE => NONE | SOME a => ltree_lookup a ns
</pre>

<DT><span class="strong">ltree_lookup_SNOC</span>
<DD>
<pre>
⊢ ∀t x xs.
    ltree_lookup t xs ≠ NONE ⇒
    ltree_lookup t (SNOC x xs) = ltree_lookup (THE (ltree_lookup t xs)) [x]
</pre>

<DT><span class="strong">ltree_lookup_append</span>
<DD>
<pre>
⊢ ∀l1 l2 t.
    ltree_lookup t l1 ≠ NONE ⇒
    ltree_lookup t (l1 ++ l2) = ltree_lookup (THE (ltree_lookup t l1)) l2
</pre>

<DT><span class="strong">ltree_lookup_def</span>
<DD>
<pre>
⊢ ltree_lookup t [] = SOME t ∧
  ltree_lookup (Branch a ts) (n::ns) =
  case LNTH n ts of NONE => NONE | SOME t => ltree_lookup t ns
</pre>

<DT><span class="strong">ltree_lookup_valid</span>
<DD>
<pre>
⊢ ∀p t. p ∈ ltree_paths t ⇔ ltree_lookup t p ≠ NONE
</pre>

<DT><span class="strong">ltree_lookup_valid_inclusive</span>
<DD>
<pre>
⊢ ∀p t. p ∈ ltree_paths t ⇔ ∀p'. p' ≼ p ⇒ ltree_lookup t p' ≠ NONE
</pre>

<DT><span class="strong">ltree_map</span>
<DD>
<pre>
⊢ ltree_map f (Branch a xs) = Branch (f a) (LMAP (ltree_map f) xs)
</pre>

<DT><span class="strong">ltree_map_id</span>
<DD>
<pre>
⊢ ltree_map I t = t
</pre>

<DT><span class="strong">ltree_map_map</span>
<DD>
<pre>
⊢ ltree_map f (ltree_map g t) = ltree_map (f ∘ g) t
</pre>

<DT><span class="strong">ltree_node_children_reduce</span>
<DD>
<pre>
⊢ Branch (ltree_node t) (ltree_children t) = t
</pre>

<DT><span class="strong">ltree_node_def</span>
<DD>
<pre>
⊢ ltree_node (Branch a ts) = a
</pre>

<DT><span class="strong">ltree_node_ind</span>
<DD>
<pre>
⊢ ∀P. (∀a ts. P (Branch a ts)) ⇒ ∀v. P v
</pre>

<DT><span class="strong">ltree_path_le_total</span>
<DD>
<pre>
⊢ total ltree_path_le
</pre>

<DT><span class="strong">ltree_path_lt</span>
<DD>
<pre>
⊢ (¬ltree_path_lt [] [] ∧ ¬ltree_path_lt (h1::t1) []) ∧
  ltree_path_lt [] (h2::t2) ∧
  (ltree_path_lt (h1::t1) (h2::t2) ⇔
   LENGTH t1 < LENGTH t2 ∨
   LENGTH t1 = LENGTH t2 ∧ (h1 < h2 ∨ h1 = h2 ∧ ltree_path_lt t1 t2))
</pre>

<DT><span class="strong">ltree_path_lt_antisymmetric</span>
<DD>
<pre>
⊢ antisymmetric ltree_path_lt
</pre>

<DT><span class="strong">ltree_path_lt_irreflexive</span>
<DD>
<pre>
⊢ irreflexive ltree_path_lt
</pre>

<DT><span class="strong">ltree_path_lt_sibling</span>
<DD>
<pre>
⊢ ∀p q.
    p ≠ [] ∧ q ≠ [] ∧ FRONT p = FRONT q ∧ LAST p < LAST q ⇒ ltree_path_lt p q
</pre>

<DT><span class="strong">ltree_path_lt_sibling'</span>
<DD>
<pre>
⊢ ∀x y xs. x < y ⇒ ltree_path_lt (SNOC x xs) (SNOC y xs)
</pre>

<DT><span class="strong">ltree_path_lt_transitive</span>
<DD>
<pre>
⊢ transitive ltree_path_lt
</pre>

<DT><span class="strong">ltree_paths_alt_ltree_el</span>
<DD>
<pre>
⊢ ∀t. ltree_paths t = {p | ltree_el t p ≠ NONE}
</pre>

<DT><span class="strong">ltree_paths_inclusive</span>
<DD>
<pre>
⊢ ∀l1 l2 t. l1 ≼ l2 ∧ l2 ∈ ltree_paths t ⇒ l1 ∈ ltree_paths t
</pre>

<DT><span class="strong">ltree_paths_map_cong</span>
<DD>
<pre>
⊢ ∀f t. ltree_paths (ltree_map f t) = ltree_paths t
</pre>

<DT><span class="strong">ltree_rel</span>
<DD>
<pre>
⊢ ltree_rel R (Branch a ts) (Branch b us) ⇔
  R a b ∧ llist_rel (ltree_rel R) ts us
</pre>

<DT><span class="strong">ltree_rel_O</span>
<DD>
<pre>
⊢ ltree_rel R1 ∘ᵣ ltree_rel R2 ⊆ᵣ ltree_rel (R1 ∘ᵣ R2)
</pre>

<DT><span class="strong">ltree_rel_eq</span>
<DD>
<pre>
⊢ ltree_rel $= x y ⇔ x = y
</pre>

<DT><span class="strong">ltree_set</span>
<DD>
<pre>
⊢ ltree_set (Branch a ts) = a INSERT BIGUNION (IMAGE ltree_set (LSET ts))
</pre>

<DT><span class="strong">ltree_set_map</span>
<DD>
<pre>
⊢ ltree_set (ltree_map f t) = IMAGE f (ltree_set t)
</pre>

<DT><span class="strong">ltree_unfold</span>
<DD>
<pre>
⊢ ltree_unfold f seed =
  (let (a,seeds) = f seed in Branch a (LMAP (ltree_unfold f) seeds))
</pre>

<DT><span class="strong">parent_inclusive_ltree_paths</span>
<DD>
<pre>
⊢ ∀t. parent_inclusive (ltree_paths t)
</pre>

<DT><span class="strong">parent_inclusive_union</span>
<DD>
<pre>
⊢ ∀s1 s2.
    parent_inclusive s1 ∧ parent_inclusive s2 ⇒ parent_inclusive (s1 ∪ s2)
</pre>

<DT><span class="strong">path_index_in_paths</span>
<DD>
<pre>
⊢ ∀s i. FINITE s ∧ i < CARD s ⇒ path_index s i ∈ s
</pre>

<DT><span class="strong">path_index_thm</span>
<DD>
<pre>
⊢ ∀s n.
    s HAS_SIZE n ⇒
    BIJ (path_index s) (count n) s ∧
    ∀j k.
      j < n ∧ k < n ⇒
      (ltree_path_lt (path_index s j) (path_index s k) ⇔ j < k)
</pre>

<DT><span class="strong">rose_children_to_rose</span>
<DD>
<pre>
⊢ ∀t. ltree_finite t ⇒
      rose_children (to_rose t) =
      MAP to_rose (THE (toList (ltree_children t)))
</pre>

<DT><span class="strong">rose_children_to_rose'</span>
<DD>
<pre>
⊢ ∀t. ltree_finite t ⇒
      rose_children (to_rose t) =
      THE (toList (LMAP to_rose (ltree_children t)))
</pre>

<DT><span class="strong">rose_node_to_rose</span>
<DD>
<pre>
⊢ ∀t. ltree_finite t ⇒ rose_node (to_rose t) = ltree_node t
</pre>

<DT><span class="strong">rose_reduce</span>
<DD>
<pre>
⊢ ∀f t.
    rose_reduce f t = f (rose_node t) (MAP (rose_reduce f) (rose_children t))
</pre>

<DT><span class="strong">rose_reduce_def</span>
<DD>
<pre>
⊢ ∀f a ts. rose_reduce f (Rose a ts) = f a (MAP (rose_reduce f) ts)
</pre>

<DT><span class="strong">rose_reduce_ind</span>
<DD>
<pre>
⊢ ∀P. (∀f a ts. (∀a'. MEM a' ts ⇒ P f a') ⇒ P f (Rose a ts)) ⇒ ∀v v1. P v v1
</pre>

<DT><span class="strong">rose_tree_11</span>
<DD>
<pre>
⊢ ∀a0 a1 a0' a1'. Rose a0 a1 = Rose a0' a1' ⇔ a0 = a0' ∧ a1 = a1'
</pre>

<DT><span class="strong">rose_tree_Axiom</span>
<DD>
<pre>
⊢ ∀f0 f1 f2. ∃fn0 fn1.
    (∀a0 a1. fn0 (Rose a0 a1) = f0 a0 a1 (fn1 a1)) ∧ fn1 [] = f1 ∧
    ∀a0 a1. fn1 (a0::a1) = f2 a0 a1 (fn0 a0) (fn1 a1)
</pre>

<DT><span class="strong">rose_tree_case_cong</span>
<DD>
<pre>
⊢ ∀M M' f.
    M = M' ∧ (∀a0 a1. M' = Rose a0 a1 ⇒ f a0 a1 = f' a0 a1) ⇒
    rose_tree_CASE M f = rose_tree_CASE M' f'
</pre>

<DT><span class="strong">rose_tree_case_eq</span>
<DD>
<pre>
⊢ rose_tree_CASE x f = v ⇔ ∃a l. x = Rose a l ∧ f a l = v
</pre>

<DT><span class="strong">rose_tree_induction</span>
<DD>
<pre>
⊢ ∀P. (∀a ts. (∀a'. MEM a' ts ⇒ P a') ⇒ P (Rose a ts)) ⇒ ∀v. P v
</pre>

<DT><span class="strong">rose_tree_nchotomy</span>
<DD>
<pre>
⊢ ∀rr. ∃a l. rr = Rose a l
</pre>

<DT><span class="strong">sibling_inclusive_ltree_paths</span>
<DD>
<pre>
⊢ ∀t. sibling_inclusive (ltree_paths t)
</pre>

<DT><span class="strong">sibling_inclusive_union</span>
<DD>
<pre>
⊢ ∀s1 s2.
    sibling_inclusive s1 ∧ sibling_inclusive s2 ⇒ sibling_inclusive (s1 ∪ s2)
</pre>

<DT><span class="strong">subtrees</span>
<DD>
<pre>
⊢ subtrees (Branch a ts) =
  Branch a ts INSERT BIGUNION (IMAGE subtrees (LSET ts))
</pre>

<DT><span class="strong">to_rose_thm</span>
<DD>
<pre>
⊢ ∀r. to_rose (from_rose r) = r
</pre>

</DL>



<hr>
</body>
</html>
