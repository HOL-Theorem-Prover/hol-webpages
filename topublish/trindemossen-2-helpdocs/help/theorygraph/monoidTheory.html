<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: monoid</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "monoid"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "bagTheory.html"><span class="strong">bag</span></a>&nbsp;&nbsp;
    <a href = "primeTheory.html"><span class="strong">prime</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Type <th> Arity<tr><td>
    <span class="strong">monoid</span>
    <td>
    1
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">AbelianMonoid</span>
    <td>
    :Î± monoid -> bool
    <tr><td>
    <span class="strong">FiniteAbelianMonoid</span>
    <td>
    :Î± monoid -> bool
    <tr><td> <span class="strong">FiniteMonoid</span> <td> :Î± monoid -> bool
    <tr><td>
    <span class="strong">GPROD_SET</span>
    <td>
    :Î± monoid -> (Î± -> bool) -> Î±
    <tr><td>
    <span class="strong">Invertibles</span>
    <td>
    :Î± monoid -> Î± monoid
    <tr><td> <span class="strong">Monoid</span> <td> :Î± monoid -> bool
    <tr><td>
    <span class="strong">MonoidAuto</span>
    <td>
    :(Î± -> Î±) -> Î± monoid -> bool
    <tr><td>
    <span class="strong">MonoidEndo</span>
    <td>
    :(Î± -> Î±) -> Î± monoid -> bool
    <tr><td>
    <span class="strong">MonoidHomo</span>
    <td>
    :(Î± -> Î²) -> Î± monoid -> Î² monoid -> bool
    <tr><td>
    <span class="strong">MonoidIso</span>
    <td>
    :(Î± -> Î²) -> Î± monoid -> Î² monoid -> bool
    <tr><td>
    <span class="strong">Submonoid</span>
    <td>
    :Î± monoid -> Î± monoid -> bool
    <tr><td>
    <span class="strong">WeakHomo</span>
    <td>
    :(Î± -> Î²) -> Î± monoid -> Î² monoid -> bool
    <tr><td>
    <span class="strong">WeakIso</span>
    <td>
    :(Î± -> Î²) -> Î± monoid -> Î² monoid -> bool
    <tr><td> <span class="strong">addition_monoid</span> <td> :num monoid
    <tr><td> <span class="strong">extend</span> <td> :Î± monoid -> Î± monoid
    <tr><td>
    <span class="strong">homo_monoid</span>
    <td>
    :Î± monoid -> (Î± -> Î²) -> Î² monoid
    <tr><td>
    <span class="strong">image_op</span>
    <td>
    :Î± monoid -> (Î± -> Î²) -> Î² -> Î² -> Î²
    <tr><td> <span class="strong">lists</span> <td> :Î± list monoid
    <tr><td>
    <span class="strong">monoid_CASE</span>
    <td>
    :Î± monoid -> ((Î± -> bool) -> (Î± -> Î± -> Î±) -> Î± -> Î²) -> Î²
    <tr><td>
    <span class="strong">monoid_exp</span>
    <td>
    :Î± monoid -> Î± -> num -> Î±
    <tr><td>
    <span class="strong">monoid_inj_image</span>
    <td>
    :Î± monoid -> (Î± -> Î²) -> Î² monoid
    <tr><td>
    <span class="strong">monoid_intersect</span>
    <td>
    :Î± monoid -> Î± monoid -> Î± monoid
    <tr><td> <span class="strong">monoid_inv</span> <td> :Î± monoid -> Î± -> Î±
    <tr><td>
    <span class="strong">monoid_invertibles</span>
    <td>
    :Î± monoid -> Î± -> bool
    <tr><td>
    <span class="strong">monoid_size</span>
    <td>
    :(Î± -> num) -> Î± monoid -> num
    <tr><td>
    <span class="strong">multiplication_monoid</span>
    <td>
    :num monoid
    <tr><td> <span class="strong">order</span> <td> :Î± monoid -> Î± -> num
    <tr><td>
    <span class="strong">orders</span>
    <td>
    :Î± monoid -> num -> Î± -> bool
    <tr><td>
    <span class="strong">period</span>
    <td>
    :Î± monoid -> Î± -> num -> bool
    <tr><td> <span class="strong">plus_mod</span> <td> :num -> num monoid
    <tr><td> <span class="strong">power_monoid</span> <td> :num -> num monoid
    <tr><td>
    <span class="strong">recordtype.monoid</span>
    <td>
    :(Î± -> bool) -> (Î± -> Î± -> Î±) -> Î± -> Î± monoid
    <tr><td>
    <span class="strong">recordtype.monoid.seldef.carrier</span>
    <td>
    :Î± monoid -> Î± -> bool
    <tr><td>
    <span class="strong">recordtype.monoid.seldef.carrier_fupd</span>
    <td>
    :((Î± -> bool) -> Î± -> bool) -> Î± monoid -> Î± monoid
    <tr><td>
    <span class="strong">recordtype.monoid.seldef.id</span>
    <td>
    :Î± monoid -> Î±
    <tr><td>
    <span class="strong">recordtype.monoid.seldef.id_fupd</span>
    <td>
    :(Î± -> Î±) -> Î± monoid -> Î± monoid
    <tr><td>
    <span class="strong">recordtype.monoid.seldef.op</span>
    <td>
    :Î± monoid -> Î± -> Î± -> Î±
    <tr><td>
    <span class="strong">recordtype.monoid.seldef.op_fupd</span>
    <td>
    :((Î± -> Î± -> Î±) -> Î± -> Î± -> Î±) -> Î± monoid -> Î± monoid
    <tr><td> <span class="strong">set_inter</span> <td> :(Î± -> bool) monoid
    <tr><td> <span class="strong">set_union</span> <td> :(Î± -> bool) monoid
    <tr><td>
    <span class="strong">submonoid</span>
    <td>
    :Î± monoid -> Î± monoid -> bool
    <tr><td>
    <span class="strong">submonoid_big_intersect</span>
    <td>
    :Î± monoid -> Î± monoid
    <tr><td> <span class="strong">times_mod</span> <td> :num -> num monoid
    <tr><td> <span class="strong">trivial_monoid</span> <td> :Î± -> Î± monoid
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">AbelianMonoid_def</span>
<DD>
<pre>
âŠ¢ âˆ€g. AbelianMonoid g â‡” Monoid g âˆ§ âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ x * y = y * x
</pre>

<DT><span class="strong">FiniteAbelianMonoid_def</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteAbelianMonoid g â‡” AbelianMonoid g âˆ§ FINITE G
</pre>

<DT><span class="strong">FiniteMonoid_def</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteMonoid g â‡” Monoid g âˆ§ FINITE G
</pre>

<DT><span class="strong">GPROD_SET_def</span>
<DD>
<pre>
âŠ¢ âˆ€g s. GPROD_SET g s = GITSET g s #e
</pre>

<DT><span class="strong">Invertibles_def</span>
<DD>
<pre>
âŠ¢ âˆ€g. Invertibles g = <|carrier := G*; op := $*; id := #e|>
</pre>

<DT><span class="strong">MonoidAuto_def</span>
<DD>
<pre>
âŠ¢ âˆ€f g. MonoidAuto f g â‡” MonoidIso f g g
</pre>

<DT><span class="strong">MonoidEndo_def</span>
<DD>
<pre>
âŠ¢ âˆ€f g. MonoidEndo f g â‡” MonoidHomo f g g
</pre>

<DT><span class="strong">MonoidHomo_def</span>
<DD>
<pre>
âŠ¢ âˆ€f g h.
    MonoidHomo f g h â‡”
    (âˆ€x. x âˆˆ G â‡’ f x âˆˆ h.carrier) âˆ§
    (âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ f (x * y) = h.op (f x) (f y)) âˆ§ f #e = h.id
</pre>

<DT><span class="strong">MonoidIso_def</span>
<DD>
<pre>
âŠ¢ âˆ€f g h. MonoidIso f g h â‡” MonoidHomo f g h âˆ§ BIJ f G h.carrier
</pre>

<DT><span class="strong">Monoid_def</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡”
      (âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ x * y âˆˆ G) âˆ§
      (âˆ€x y z. x âˆˆ G âˆ§ y âˆˆ G âˆ§ z âˆˆ G â‡’ x * y * z = x * (y * z)) âˆ§ #e âˆˆ G âˆ§
      âˆ€x. x âˆˆ G â‡’ #e * x = x âˆ§ x * #e = x
</pre>

<DT><span class="strong">Submonoid_def</span>
<DD>
<pre>
âŠ¢ âˆ€h g. h << g â‡” Monoid h âˆ§ Monoid g âˆ§ H âŠ† G âˆ§ h.op = $* âˆ§ h.id = #e
</pre>

<DT><span class="strong">WeakHomo_def</span>
<DD>
<pre>
âŠ¢ âˆ€f g h.
    WeakHomo f g h â‡”
    (âˆ€x. x âˆˆ G â‡’ f x âˆˆ h.carrier) âˆ§
    âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ f (x * y) = h.op (f x) (f y)
</pre>

<DT><span class="strong">WeakIso_def</span>
<DD>
<pre>
âŠ¢ âˆ€f g h. WeakIso f g h â‡” WeakHomo f g h âˆ§ BIJ f G h.carrier
</pre>

<DT><span class="strong">addition_monoid_def</span>
<DD>
<pre>
âŠ¢ addition_monoid = <|carrier := ğ•Œ(:num); op := $+; id := 0|>
</pre>

<DT><span class="strong">extend_def</span>
<DD>
<pre>
âŠ¢ âˆ€m. extend m =
      <|carrier := ğ•Œ(:Î±); id := m.id;
        op :=
          (Î»x y.
               if x âˆˆ m.carrier then if y âˆˆ m.carrier then m.op x y else y
               else x)|>
</pre>

<DT><span class="strong">homo_monoid_def</span>
<DD>
<pre>
âŠ¢ âˆ€g f.
    homo_group g f = <|carrier := IMAGE f G; op := image_op g f; id := f #e|>
</pre>

<DT><span class="strong">image_op_def</span>
<DD>
<pre>
âŠ¢ âˆ€g f x y.
    image_op g f x y = f (CHOICE (preimage f G x) * CHOICE (preimage f G y))
</pre>

<DT><span class="strong">lists_def</span>
<DD>
<pre>
âŠ¢ lists = <|carrier := ğ•Œ(:Î± list); id := []; op := $++ |>
</pre>

<DT><span class="strong">monoid_TY_DEF</span>
<DD>
<pre>
âŠ¢ âˆƒrep.
    TYPE_DEFINITION
      (Î»a0'.
           âˆ€ $var$('monoid').
             (âˆ€a0'.
                (âˆƒa0 a1 a2.
                   a0' =
                   (Î»a0 a1 a2.
                        ind_type$CONSTR 0 (a0,a1,a2) (Î»n. ind_type$BOTTOM)) a0
                     a1 a2) â‡’
                $var$('monoid') a0') â‡’
             $var$('monoid') a0') rep
</pre>

<DT><span class="strong">monoid_case_def</span>
<DD>
<pre>
âŠ¢ âˆ€a0 a1 a2 f. monoid_CASE (monoid a0 a1 a2) f = f a0 a1 a2
</pre>

<DT><span class="strong">monoid_exp_def</span>
<DD>
<pre>
âŠ¢ âˆ€g x n. x ** n = FUNPOW ($* x) n #e
</pre>

<DT><span class="strong">monoid_inj_image_def</span>
<DD>
<pre>
âŠ¢ âˆ€g f.
    monoid_inj_image g f =
    <|carrier := IMAGE f G; op := (let t = LINV f G in Î»x y. f (t x * t y));
      id := f #e|>
</pre>

<DT><span class="strong">monoid_intersect_def</span>
<DD>
<pre>
âŠ¢ âˆ€g h. (g mINTER h) = <|carrier := G âˆ© H; op := $*; id := #e|>
</pre>

<DT><span class="strong">monoid_inv_def</span>
<DD>
<pre>
âŠ¢ âˆ€g x. Monoid g âˆ§ x âˆˆ G* â‡’ |/ x âˆˆ G âˆ§ x * |/ x = #e âˆ§ |/ x * x = #e
</pre>

<DT><span class="strong">monoid_invertibles_def</span>
<DD>
<pre>
âŠ¢ âˆ€g. G* = {x | x âˆˆ G âˆ§ âˆƒy. y âˆˆ G âˆ§ x * y = #e âˆ§ y * x = #e}
</pre>

<DT><span class="strong">monoid_size_def</span>
<DD>
<pre>
âŠ¢ âˆ€f a0 a1 a2. monoid_size f (monoid a0 a1 a2) = 1 + f a2
</pre>

<DT><span class="strong">multiplication_monoid_def</span>
<DD>
<pre>
âŠ¢ multiplication_monoid = <|carrier := ğ•Œ(:num); op := $*; id := 1|>
</pre>

<DT><span class="strong">order_def</span>
<DD>
<pre>
âŠ¢ âˆ€g x. ord x = case OLEAST k. period g x k of NONE => 0 | SOME k => k
</pre>

<DT><span class="strong">orders_def</span>
<DD>
<pre>
âŠ¢ âˆ€g n. orders g n = {x | x âˆˆ G âˆ§ ord x = n}
</pre>

<DT><span class="strong">period_def</span>
<DD>
<pre>
âŠ¢ âˆ€g x k. period g x k â‡” 0 < k âˆ§ x ** k = #e
</pre>

<DT><span class="strong">plus_mod_def</span>
<DD>
<pre>
âŠ¢ âˆ€n. plus_mod n =
      <|carrier := count n; id := 0; op := (Î»i j. (i + j) MOD n)|>
</pre>

<DT><span class="strong">power_monoid_def</span>
<DD>
<pre>
âŠ¢ âˆ€b. power_monoid b =
      <|carrier := {b ** j | j âˆˆ ğ•Œ(:num)}; op := $*; id := 1|>
</pre>

<DT><span class="strong">recordtype_monoid_seldef_carrier_def</span>
<DD>
<pre>
âŠ¢ âˆ€f f0 a. (monoid f f0 a).carrier = f
</pre>

<DT><span class="strong">recordtype_monoid_seldef_carrier_fupd_def</span>
<DD>
<pre>
âŠ¢ âˆ€f1 f f0 a. monoid f f0 a with carrier updated_by f1 = monoid (f1 f) f0 a
</pre>

<DT><span class="strong">recordtype_monoid_seldef_id_def</span>
<DD>
<pre>
âŠ¢ âˆ€f f0 a. (monoid f f0 a).id = a
</pre>

<DT><span class="strong">recordtype_monoid_seldef_id_fupd_def</span>
<DD>
<pre>
âŠ¢ âˆ€f1 f f0 a. monoid f f0 a with id updated_by f1 = monoid f f0 (f1 a)
</pre>

<DT><span class="strong">recordtype_monoid_seldef_op_def</span>
<DD>
<pre>
âŠ¢ âˆ€f f0 a. (monoid f f0 a).op = f0
</pre>

<DT><span class="strong">recordtype_monoid_seldef_op_fupd_def</span>
<DD>
<pre>
âŠ¢ âˆ€f1 f f0 a. monoid f f0 a with op updated_by f1 = monoid f (f1 f0) a
</pre>

<DT><span class="strong">set_inter_def</span>
<DD>
<pre>
âŠ¢ set_inter = <|carrier := ğ•Œ(:Î± -> bool); id := ğ•Œ(:Î±); op := $INTER|>
</pre>

<DT><span class="strong">set_union_def</span>
<DD>
<pre>
âŠ¢ set_union = <|carrier := ğ•Œ(:Î± -> bool); id := âˆ…; op := $UNION|>
</pre>

<DT><span class="strong">submonoid_big_intersect_def</span>
<DD>
<pre>
âŠ¢ âˆ€g. smbINTER g =
      <|carrier := BIGINTER (IMAGE (Î»h. H) {h | h << g}); op := $*; id := #e|>
</pre>

<DT><span class="strong">submonoid_def</span>
<DD>
<pre>
âŠ¢ âˆ€h g. submonoid h g â‡” MonoidHomo I h g
</pre>

<DT><span class="strong">times_mod_def</span>
<DD>
<pre>
âŠ¢ âˆ€n. times_mod n =
      <|carrier := count n; id := if n = 1 then 0 else 1;
        op := (Î»i j. (i * j) MOD n)|>
</pre>

<DT><span class="strong">trivial_monoid_def</span>
<DD>
<pre>
âŠ¢ âˆ€e. trivial_monoid e = <|carrier := {e}; id := e; op := (Î»x y. e)|>
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">COMMUTING_GITBAG_INSERT</span>
<DD>
<pre>
âŠ¢ âˆ€g b.
    AbelianMonoid g âˆ§ FINITE_BAG b âˆ§ SET_OF_BAG b âŠ† G â‡’
    âˆ€x a::G. GITBAG g (BAG_INSERT x b) a = GITBAG g b (x * a)
</pre>

<DT><span class="strong">COMMUTING_GITSET_INSERT</span>
<DD>
<pre>
âŠ¢ âˆ€g s.
    AbelianMonoid g âˆ§ FINITE s âˆ§ s âŠ† G â‡’
    âˆ€b x::G. GITSET g (x INSERT s) b = GITSET g (s DELETE x) (x * b)
</pre>

<DT><span class="strong">COMMUTING_GITSET_RECURSES</span>
<DD>
<pre>
âŠ¢ âˆ€g s.
    AbelianMonoid g âˆ§ FINITE s âˆ§ s âŠ† G â‡’
    âˆ€b x::G. GITSET g (x INSERT s) b = x * GITSET g (s DELETE x) b
</pre>

<DT><span class="strong">COMMUTING_GITSET_REDUCTION</span>
<DD>
<pre>
âŠ¢ âˆ€g s.
    AbelianMonoid g âˆ§ FINITE s âˆ§ s âŠ† G â‡’
    âˆ€b x::G. GITSET g s (x * b) = x * GITSET g s b
</pre>

<DT><span class="strong">EXISTS_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€P. (âˆƒm. P m) â‡” âˆƒf0 f a. P <|carrier := f0; op := f; id := a|>
</pre>

<DT><span class="strong">FORALL_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€P. (âˆ€m. P m) â‡” âˆ€f0 f a. P <|carrier := f0; op := f; id := a|>
</pre>

<DT><span class="strong">FiniteAbelianMonoid_def_alt</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteAbelianMonoid g â‡”
      FiniteMonoid g âˆ§ âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ x * y = y * x
</pre>

<DT><span class="strong">GBAG_IMAGE_FILTER</span>
<DD>
<pre>
âŠ¢ AbelianMonoid g â‡’
  âˆ€b. FINITE_BAG b â‡’
      IMAGE f (SET_OF_BAG b âˆ© P) âŠ† G â‡’
      GBAG g (BAG_IMAGE f (BAG_FILTER P b)) =
      GBAG g (BAG_IMAGE (Î»x. if P x then f x else #e) b)
</pre>

<DT><span class="strong">GBAG_IMAGE_PARTITION</span>
<DD>
<pre>
âŠ¢ AbelianMonoid g âˆ§ FINITE s â‡’
  âˆ€b. FINITE_BAG b â‡’
      IMAGE f (SET_OF_BAG b) âŠ† G âˆ§ (âˆ€x. x â‹² b â‡’ âˆƒP. P âˆˆ s âˆ§ P x) âˆ§
      (âˆ€x P1 P2. x â‹² b âˆ§ P1 âˆˆ s âˆ§ P2 âˆˆ s âˆ§ P1 x âˆ§ P2 x â‡’ P1 = P2) â‡’
      GBAG g
        (BAG_IMAGE (Î»P. GBAG g (BAG_IMAGE f (BAG_FILTER P b))) (BAG_OF_SET s)) =
      GBAG g (BAG_IMAGE f b)
</pre>

<DT><span class="strong">GBAG_INSERT</span>
<DD>
<pre>
âŠ¢ AbelianMonoid g âˆ§ FINITE_BAG b âˆ§ SET_OF_BAG b âŠ† G âˆ§ x âˆˆ G â‡’
  GBAG g (BAG_INSERT x b) = x * GBAG g b
</pre>

<DT><span class="strong">GBAG_PARTITION</span>
<DD>
<pre>
âŠ¢ AbelianMonoid g âˆ§ FINITE s âˆ§ FINITE_BAG b âˆ§ SET_OF_BAG b âŠ† G âˆ§
  (âˆ€x. x â‹² b â‡’ âˆƒP. P âˆˆ s âˆ§ P x) âˆ§
  (âˆ€x P1 P2. x â‹² b âˆ§ P1 âˆˆ s âˆ§ P2 âˆˆ s âˆ§ P1 x âˆ§ P2 x â‡’ P1 = P2) â‡’
  GBAG g (BAG_IMAGE (Î»P. GBAG g (BAG_FILTER P b)) (BAG_OF_SET s)) = GBAG g b
</pre>

<DT><span class="strong">GBAG_UNION</span>
<DD>
<pre>
âŠ¢ AbelianMonoid g âˆ§ FINITE_BAG b1 âˆ§ FINITE_BAG b2 âˆ§ SET_OF_BAG b1 âŠ† G âˆ§
  SET_OF_BAG b2 âŠ† G â‡’
  GBAG g (b1 âŠ b2) = GBAG g b1 * GBAG g b2
</pre>

<DT><span class="strong">GBAG_in_carrier</span>
<DD>
<pre>
âŠ¢ âˆ€g b. AbelianMonoid g âˆ§ FINITE_BAG b âˆ§ SET_OF_BAG b âŠ† G â‡’ GBAG g b âˆˆ G
</pre>

<DT><span class="strong">GITBAG_BAG_IMAGE_op</span>
<DD>
<pre>
âŠ¢ âˆ€g. AbelianMonoid g â‡’
      âˆ€b. FINITE_BAG b â‡’
          âˆ€p q a.
            IMAGE p (SET_OF_BAG b) âŠ† G âˆ§ IMAGE q (SET_OF_BAG b) âŠ† G âˆ§ a âˆˆ G â‡’
            GITBAG g (BAG_IMAGE (Î»x. p x * q x) b) a =
            GITBAG g (BAG_IMAGE p b) a * GBAG g (BAG_IMAGE q b)
</pre>

<DT><span class="strong">GITBAG_CONG</span>
<DD>
<pre>
âŠ¢ âˆ€g. AbelianMonoid g â‡’
      âˆ€b. FINITE_BAG b â‡’
          âˆ€b' a a'.
            FINITE_BAG b' âˆ§ a âˆˆ G âˆ§ SET_OF_BAG b âŠ† G âˆ§ SET_OF_BAG b' âŠ† G âˆ§
            (âˆ€x. x â‹² b âŠ b' âˆ§ x â‰  #e â‡’ b x = b' x) â‡’
            GITBAG g b a = GITBAG g b' a
</pre>

<DT><span class="strong">GITBAG_EMPTY</span>
<DD>
<pre>
âŠ¢ âˆ€g a. GITBAG g {||} a = a
</pre>

<DT><span class="strong">GITBAG_GBAG</span>
<DD>
<pre>
âŠ¢ âˆ€g. AbelianMonoid g â‡’
      âˆ€b. FINITE_BAG b â‡’
          âˆ€a. a âˆˆ G âˆ§ SET_OF_BAG b âŠ† G â‡’ GITBAG g b a = a * GBAG g b
</pre>

<DT><span class="strong">GITBAG_INSERT</span>
<DD>
<pre>
âŠ¢ âˆ€b. FINITE_BAG b â‡’
      âˆ€g x a.
        GITBAG g (BAG_INSERT x b) a =
        GITBAG g (BAG_REST (BAG_INSERT x b)) (BAG_CHOICE (BAG_INSERT x b) * a)
</pre>

<DT><span class="strong">GITBAG_INSERT_THM</span>
<DD>
<pre>
âŠ¢ âˆ€g b x a.
    (AbelianMonoid g âˆ§ FINITE_BAG b âˆ§ SET_OF_BAG b âŠ† G) âˆ§ x âˆˆ G âˆ§ a âˆˆ G â‡’
    GITBAG g (BAG_INSERT x b) a = GITBAG g b (x * a)
</pre>

<DT><span class="strong">GITBAG_THM</span>
<DD>
<pre>
âŠ¢ âˆ€g b acc.
    FINITE_BAG b â‡’
    GITBAG g b acc =
    if b = {||} then acc else GITBAG g (BAG_REST b) (BAG_CHOICE b * acc)
</pre>

<DT><span class="strong">GITBAG_UNION</span>
<DD>
<pre>
âŠ¢ âˆ€g. AbelianMonoid g â‡’
      âˆ€b1.
        FINITE_BAG b1 â‡’
        âˆ€b2.
          FINITE_BAG b2 âˆ§ SET_OF_BAG b1 âŠ† G âˆ§ SET_OF_BAG b2 âŠ† G â‡’
          âˆ€a. a âˆˆ G â‡’ GITBAG g (b1 âŠ b2) a = GITBAG g b2 (GITBAG g b1 a)
</pre>

<DT><span class="strong">GITBAG_in_carrier</span>
<DD>
<pre>
âŠ¢ âˆ€g. AbelianMonoid g â‡’
      âˆ€b. FINITE_BAG b â‡’ âˆ€a. SET_OF_BAG b âŠ† G âˆ§ a âˆˆ G â‡’ GITBAG g b a âˆˆ G
</pre>

<DT><span class="strong">GITBAG_same_op</span>
<DD>
<pre>
âŠ¢ g1.op = g2.op â‡’ âˆ€b. FINITE_BAG b â‡’ âˆ€a. GITBAG g1 b a = GITBAG g2 b a
</pre>

<DT><span class="strong">GITSET_EMPTY</span>
<DD>
<pre>
âŠ¢ âˆ€g b. GITSET g âˆ… b = b
</pre>

<DT><span class="strong">GITSET_INSERT</span>
<DD>
<pre>
âŠ¢ âˆ€s. FINITE s â‡’
      âˆ€x g b.
        GITSET g (x INSERT s) b =
        GITSET g (REST (x INSERT s)) (CHOICE (x INSERT s) * b)
</pre>

<DT><span class="strong">GITSET_PROPERTY</span>
<DD>
<pre>
âŠ¢ âˆ€g s. FINITE s âˆ§ s â‰  âˆ… â‡’ âˆ€b. GITSET g s b = GITSET g (REST s) (CHOICE s * b)
</pre>

<DT><span class="strong">GITSET_THM</span>
<DD>
<pre>
âŠ¢ âˆ€s g b.
    FINITE s â‡’
    GITSET g s b = if s = âˆ… then b else GITSET g (REST s) (CHOICE s * b)
</pre>

<DT><span class="strong">GPROD_SET_EMPTY</span>
<DD>
<pre>
âŠ¢ âˆ€g s. GPROD_SET g âˆ… = #e
</pre>

<DT><span class="strong">GPROD_SET_PROPERTY</span>
<DD>
<pre>
âŠ¢ âˆ€g s. AbelianMonoid g âˆ§ FINITE s âˆ§ s âŠ† G â‡’ GPROD_SET g s âˆˆ G
</pre>

<DT><span class="strong">GPROD_SET_SING</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€x. x âˆˆ G â‡’ GPROD_SET g {x} = x
</pre>

<DT><span class="strong">GPROD_SET_THM</span>
<DD>
<pre>
âŠ¢ âˆ€g s.
    GPROD_SET g âˆ… = #e âˆ§
    (AbelianMonoid g âˆ§ FINITE s âˆ§ s âŠ† G â‡’
     âˆ€x::G. GPROD_SET g (x INSERT s) = x * GPROD_SET g (s DELETE x))
</pre>

<DT><span class="strong">IMP_GBAG_EQ_EXP</span>
<DD>
<pre>
âŠ¢ AbelianMonoid g âˆ§ x âˆˆ G âˆ§ SET_OF_BAG b âŠ† {x} â‡’ GBAG g b = x ** b x
</pre>

<DT><span class="strong">IMP_GBAG_EQ_ID</span>
<DD>
<pre>
âŠ¢ AbelianMonoid g â‡’ âˆ€b. BAG_EVERY ($= #e) b â‡’ GBAG g b = #e
</pre>

<DT><span class="strong">Invertibles_carrier</span>
<DD>
<pre>
âŠ¢ âˆ€g. (Invertibles g).carrier = G*
</pre>

<DT><span class="strong">Invertibles_order</span>
<DD>
<pre>
âŠ¢ âˆ€g x. order (Invertibles g) x = ord x
</pre>

<DT><span class="strong">Invertibles_property</span>
<DD>
<pre>
âŠ¢ âˆ€g. (Invertibles g).carrier = G* âˆ§ (Invertibles g).op = $* âˆ§
      (Invertibles g).id = #e âˆ§ (Invertibles g).exp = $**
</pre>

<DT><span class="strong">Invertibles_subset</span>
<DD>
<pre>
âŠ¢ âˆ€g. (Invertibles g).carrier âŠ† G
</pre>

<DT><span class="strong">MonoidHomo_GBAG</span>
<DD>
<pre>
âŠ¢ AbelianMonoid g âˆ§ AbelianMonoid h âˆ§ MonoidHomo f g h âˆ§ FINITE_BAG b âˆ§
  SET_OF_BAG b âŠ† G â‡’
  f (GBAG g b) = GBAG h (BAG_IMAGE f b)
</pre>

<DT><span class="strong">SUBSET_COMMUTING_ITBAG_INSERT</span>
<DD>
<pre>
âŠ¢ âˆ€f b t.
    SET_OF_BAG b âŠ† t âˆ§ closure_comm_assoc_fun f t âˆ§ FINITE_BAG b â‡’
    âˆ€x a::t. ITBAG f (BAG_INSERT x b) a = ITBAG f b (f x a)
</pre>

<DT><span class="strong">abelian_monoid_op_closure_comm_assoc_fun</span>
<DD>
<pre>
âŠ¢ âˆ€g. AbelianMonoid g â‡’ closure_comm_assoc_fun $* G
</pre>

<DT><span class="strong">abelian_monoid_order_common</span>
<DD>
<pre>
âŠ¢ âˆ€g. AbelianMonoid g â‡’
      âˆ€x y.
        x âˆˆ G âˆ§ y âˆˆ G â‡’
        âˆƒz. z âˆˆ G âˆ§ ord z * gcd (ord x) (ord y) = lcm (ord x) (ord y)
</pre>

<DT><span class="strong">abelian_monoid_order_common_coprime</span>
<DD>
<pre>
âŠ¢ âˆ€g. AbelianMonoid g â‡’
      âˆ€x y.
        x âˆˆ G âˆ§ y âˆˆ G âˆ§ coprime (ord x) (ord y) â‡’
        âˆƒz. z âˆˆ G âˆ§ ord z = ord x * ord y
</pre>

<DT><span class="strong">abelian_monoid_order_lcm</span>
<DD>
<pre>
âŠ¢ âˆ€g. AbelianMonoid g â‡’
      âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ âˆƒz. z âˆˆ G âˆ§ ord z = lcm (ord x) (ord y)
</pre>

<DT><span class="strong">addition_monoid_abelian_monoid</span>
<DD>
<pre>
âŠ¢ AbelianMonoid addition_monoid
</pre>

<DT><span class="strong">addition_monoid_monoid</span>
<DD>
<pre>
âŠ¢ Monoid addition_monoid
</pre>

<DT><span class="strong">addition_monoid_property</span>
<DD>
<pre>
âŠ¢ addition_monoid.carrier = ğ•Œ(:num) âˆ§ addition_monoid.op = $+ âˆ§
  addition_monoid.id = 0
</pre>

<DT><span class="strong">datatype_monoid</span>
<DD>
<pre>
âŠ¢ DATATYPE (record monoid carrier op id)
</pre>

<DT><span class="strong">extend_carrier</span>
<DD>
<pre>
âŠ¢ (extend m).carrier = ğ•Œ(:Î±)
</pre>

<DT><span class="strong">extend_id</span>
<DD>
<pre>
âŠ¢ (extend m).id = m.id
</pre>

<DT><span class="strong">extend_is_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€m. Monoid m â‡’ Monoid (extend m)
</pre>

<DT><span class="strong">extend_op</span>
<DD>
<pre>
âŠ¢ x âˆˆ m.carrier âˆ§ y âˆˆ m.carrier â‡’ (extend m).op x y = m.op x y
</pre>

<DT><span class="strong">finite_monoid_exp_not_distinct</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteMonoid g â‡’ âˆ€x. x âˆˆ G â‡’ âˆƒh k. x ** h = x ** k âˆ§ h â‰  k
</pre>

<DT><span class="strong">homo_monoid_I</span>
<DD>
<pre>
âŠ¢ âˆ€g. MonoidIso I (homo_group g I) g
</pre>

<DT><span class="strong">homo_monoid_abelian_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€g f.
    AbelianMonoid g âˆ§ MonoidHomo f g (homo_group g f) â‡’
    AbelianMonoid (homo_group g f)
</pre>

<DT><span class="strong">homo_monoid_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€g f.
    Monoid g âˆ§ MonoidHomo f g (homo_group g f) â‡’
    âˆ€x y z. x âˆˆ fG âˆ§ y âˆˆ fG âˆ§ z âˆˆ fG â‡’ (x âˆ˜ y) âˆ˜ z = x âˆ˜ y âˆ˜ z
</pre>

<DT><span class="strong">homo_monoid_by_inj</span>
<DD>
<pre>
âŠ¢ âˆ€g f. Monoid g âˆ§ INJ f G ğ•Œ(:Î²) â‡’ MonoidHomo f g (homo_group g f)
</pre>

<DT><span class="strong">homo_monoid_closure</span>
<DD>
<pre>
âŠ¢ âˆ€g f.
    Monoid g âˆ§ MonoidHomo f g (homo_group g f) â‡’
    âˆ€x y. x âˆˆ fG âˆ§ y âˆˆ fG â‡’ x âˆ˜ y âˆˆ fG
</pre>

<DT><span class="strong">homo_monoid_comm</span>
<DD>
<pre>
âŠ¢ âˆ€g f.
    AbelianMonoid g âˆ§ MonoidHomo f g (homo_group g f) â‡’
    âˆ€x y. x âˆˆ fG âˆ§ y âˆˆ fG â‡’ x âˆ˜ y = y âˆ˜ x
</pre>

<DT><span class="strong">homo_monoid_element</span>
<DD>
<pre>
âŠ¢ âˆ€g f x. x âˆˆ G â‡’ f x âˆˆ fG
</pre>

<DT><span class="strong">homo_monoid_id</span>
<DD>
<pre>
âŠ¢ âˆ€g f. f #e = #i
</pre>

<DT><span class="strong">homo_monoid_id_property</span>
<DD>
<pre>
âŠ¢ âˆ€g f.
    Monoid g âˆ§ MonoidHomo f g (homo_group g f) â‡’
    #i âˆˆ fG âˆ§ âˆ€x. x âˆˆ fG â‡’ #i âˆ˜ x = x âˆ§ x âˆ˜ #i = x
</pre>

<DT><span class="strong">homo_monoid_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€g f. Monoid g âˆ§ MonoidHomo f g (homo_group g f) â‡’ Monoid (homo_group g f)
</pre>

<DT><span class="strong">homo_monoid_op_inj</span>
<DD>
<pre>
âŠ¢ âˆ€g f. INJ f G ğ•Œ(:Î²) â‡’ âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ f (x * y) = f x âˆ˜ f y
</pre>

<DT><span class="strong">homo_monoid_property</span>
<DD>
<pre>
âŠ¢ âˆ€g f.
    fG = IMAGE f G âˆ§
    (âˆ€x y.
       x âˆˆ fG âˆ§ y âˆˆ fG â‡’
       x âˆ˜ y = f (CHOICE (preimage f G x) * CHOICE (preimage f G y))) âˆ§
    #i = f #e
</pre>

<DT><span class="strong">image_op_inj</span>
<DD>
<pre>
âŠ¢ âˆ€g f.
    INJ f G ğ•Œ(:Î²) â‡’ âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ image_op g f (f x) (f y) = f (x * y)
</pre>

<DT><span class="strong">lists_monoid</span>
<DD>
<pre>
âŠ¢ Monoid lists
</pre>

<DT><span class="strong">maximal_order_alt</span>
<DD>
<pre>
âŠ¢ âˆ€g. maximal_order g = MAX_SET {ord z | z | z âˆˆ G}
</pre>

<DT><span class="strong">monoid_11</span>
<DD>
<pre>
âŠ¢ âˆ€a0 a1 a2 a0' a1' a2'.
    monoid a0 a1 a2 = monoid a0' a1' a2' â‡” a0 = a0' âˆ§ a1 = a1' âˆ§ a2 = a2'
</pre>

<DT><span class="strong">monoid_Axiom</span>
<DD>
<pre>
âŠ¢ âˆ€f. âˆƒfn. âˆ€a0 a1 a2. fn (monoid a0 a1 a2) = f a0 a1 a2
</pre>

<DT><span class="strong">monoid_accessors</span>
<DD>
<pre>
âŠ¢ (âˆ€f f0 a. (monoid f f0 a).carrier = f) âˆ§
  (âˆ€f f0 a. (monoid f f0 a).op = f0) âˆ§ âˆ€f f0 a. (monoid f f0 a).id = a
</pre>

<DT><span class="strong">monoid_accfupds</span>
<DD>
<pre>
âŠ¢ (âˆ€m f. (m with op updated_by f).carrier = m.carrier) âˆ§
  (âˆ€m f. (m with id updated_by f).carrier = m.carrier) âˆ§
  (âˆ€m f. (m with carrier updated_by f).op = m.op) âˆ§
  (âˆ€m f. (m with id updated_by f).op = m.op) âˆ§
  (âˆ€m f. (m with carrier updated_by f).id = m.id) âˆ§
  (âˆ€m f. (m with op updated_by f).id = m.id) âˆ§
  (âˆ€m f. (m with carrier updated_by f).carrier = f m.carrier) âˆ§
  (âˆ€m f. (m with op updated_by f).op = f m.op) âˆ§
  âˆ€m f. (m with id updated_by f).id = f m.id
</pre>

<DT><span class="strong">monoid_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€x y z. x âˆˆ G âˆ§ y âˆˆ G âˆ§ z âˆˆ G â‡’ x * y * z = x * (y * z)
</pre>

<DT><span class="strong">monoid_auto_I</span>
<DD>
<pre>
âŠ¢ âˆ€g. MonoidAuto I g
</pre>

<DT><span class="strong">monoid_auto_bij</span>
<DD>
<pre>
âŠ¢ âˆ€g f. MonoidAuto f g â‡’ f PERMUTES G
</pre>

<DT><span class="strong">monoid_auto_compose</span>
<DD>
<pre>
âŠ¢ âˆ€g f1 f2. MonoidAuto f1 g âˆ§ MonoidAuto f2 g â‡’ MonoidAuto (f1 âˆ˜ f2) g
</pre>

<DT><span class="strong">monoid_auto_element</span>
<DD>
<pre>
âŠ¢ âˆ€f g. MonoidAuto f g â‡’ âˆ€x. x âˆˆ G â‡’ f x âˆˆ G
</pre>

<DT><span class="strong">monoid_auto_exp</span>
<DD>
<pre>
âŠ¢ âˆ€f g. Monoid g âˆ§ MonoidAuto f g â‡’ âˆ€x. x âˆˆ G â‡’ âˆ€n. f (x ** n) = f x ** n
</pre>

<DT><span class="strong">monoid_auto_id</span>
<DD>
<pre>
âŠ¢ âˆ€f g. MonoidAuto f g â‡’ f #e = #e
</pre>

<DT><span class="strong">monoid_auto_linv_auto</span>
<DD>
<pre>
âŠ¢ âˆ€g f. Monoid g âˆ§ MonoidAuto f g â‡’ MonoidAuto (LINV f G) g
</pre>

<DT><span class="strong">monoid_auto_order</span>
<DD>
<pre>
âŠ¢ âˆ€g f. Monoid g âˆ§ MonoidAuto f g â‡’ âˆ€x. x âˆˆ G â‡’ ord (f x) = ord x
</pre>

<DT><span class="strong">monoid_carrier_nonempty</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ G â‰  âˆ…
</pre>

<DT><span class="strong">monoid_case_cong</span>
<DD>
<pre>
âŠ¢ âˆ€M M' f.
    M = M' âˆ§ (âˆ€a0 a1 a2. M' = monoid a0 a1 a2 â‡’ f a0 a1 a2 = f' a0 a1 a2) â‡’
    monoid_CASE M f = monoid_CASE M' f'
</pre>

<DT><span class="strong">monoid_case_eq</span>
<DD>
<pre>
âŠ¢ monoid_CASE x f = v â‡” âˆƒf' f0 a. x = monoid f' f0 a âˆ§ f f' f0 a = v
</pre>

<DT><span class="strong">monoid_comm_exp</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’
      âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ x * y = y * x â‡’ âˆ€n. x ** n * y = y * x ** n
</pre>

<DT><span class="strong">monoid_comm_exp_exp</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’
      âˆ€x y.
        x âˆˆ G âˆ§ y âˆˆ G âˆ§ x * y = y * x â‡’
        âˆ€n m. x ** n * y ** m = y ** m * x ** n
</pre>

<DT><span class="strong">monoid_comm_op_exp</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’
      âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G âˆ§ x * y = y * x â‡’ âˆ€n. (x * y) ** n = x ** n * y ** n
</pre>

<DT><span class="strong">monoid_component_equality</span>
<DD>
<pre>
âŠ¢ âˆ€m1 m2. m1 = m2 â‡” m1.carrier = m2.carrier âˆ§ m1.op = m2.op âˆ§ m1.id = m2.id
</pre>

<DT><span class="strong">monoid_exp_0</span>
<DD>
<pre>
âŠ¢ âˆ€g x. x ** 0 = #e
</pre>

<DT><span class="strong">monoid_exp_1</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€x. x âˆˆ G â‡’ x ** 1 = x
</pre>

<DT><span class="strong">monoid_exp_SUC</span>
<DD>
<pre>
âŠ¢ âˆ€g x n. x ** SUC n = x * x ** n
</pre>

<DT><span class="strong">monoid_exp_add</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€x. x âˆˆ G â‡’ âˆ€n k. x ** (n + k) = x ** n * x ** k
</pre>

<DT><span class="strong">monoid_exp_comm</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€x. x âˆˆ G â‡’ âˆ€n. x ** n * x = x * x ** n
</pre>

<DT><span class="strong">monoid_exp_element</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€x. x âˆˆ G â‡’ âˆ€n. x ** n âˆˆ G
</pre>

<DT><span class="strong">monoid_exp_mod_order</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€x. x âˆˆ G âˆ§ 0 < ord x â‡’ âˆ€n. x ** n = x ** (n MOD ord x)
</pre>

<DT><span class="strong">monoid_exp_mult</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€x. x âˆˆ G â‡’ âˆ€n k. x ** (n * k) = (x ** n) ** k
</pre>

<DT><span class="strong">monoid_exp_mult_comm</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€x. x âˆˆ G â‡’ âˆ€m n. (x ** m) ** n = (x ** n) ** m
</pre>

<DT><span class="strong">monoid_exp_suc</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€x. x âˆˆ G â‡’ âˆ€n. x ** SUC n = x ** n * x
</pre>

<DT><span class="strong">monoid_fn_updates</span>
<DD>
<pre>
âŠ¢ (âˆ€f1 f f0 a. monoid f f0 a with carrier updated_by f1 = monoid (f1 f) f0 a) âˆ§
  (âˆ€f1 f f0 a. monoid f f0 a with op updated_by f1 = monoid f (f1 f0) a) âˆ§
  âˆ€f1 f f0 a. monoid f f0 a with id updated_by f1 = monoid f f0 (f1 a)
</pre>

<DT><span class="strong">monoid_fupdcanon</span>
<DD>
<pre>
âŠ¢ (âˆ€m g f.
     m with <|op updated_by f; carrier updated_by g|> =
     m with <|carrier updated_by g; op updated_by f|>) âˆ§
  (âˆ€m g f.
     m with <|id updated_by f; carrier updated_by g|> =
     m with <|carrier updated_by g; id updated_by f|>) âˆ§
  âˆ€m g f.
    m with <|id updated_by f; op updated_by g|> =
    m with <|op updated_by g; id updated_by f|>
</pre>

<DT><span class="strong">monoid_fupdcanon_comp</span>
<DD>
<pre>
âŠ¢ ((âˆ€g f. op_fupd f âˆ˜ carrier_fupd g = carrier_fupd g âˆ˜ op_fupd f) âˆ§
   âˆ€h g f. op_fupd f âˆ˜ carrier_fupd g âˆ˜ h = carrier_fupd g âˆ˜ op_fupd f âˆ˜ h) âˆ§
  ((âˆ€g f. id_fupd f âˆ˜ carrier_fupd g = carrier_fupd g âˆ˜ id_fupd f) âˆ§
   âˆ€h g f. id_fupd f âˆ˜ carrier_fupd g âˆ˜ h = carrier_fupd g âˆ˜ id_fupd f âˆ˜ h) âˆ§
  (âˆ€g f. id_fupd f âˆ˜ op_fupd g = op_fupd g âˆ˜ id_fupd f) âˆ§
  âˆ€h g f. id_fupd f âˆ˜ op_fupd g âˆ˜ h = op_fupd g âˆ˜ id_fupd f âˆ˜ h
</pre>

<DT><span class="strong">monoid_fupdfupds</span>
<DD>
<pre>
âŠ¢ (âˆ€m g f.
     m with <|carrier updated_by f; carrier updated_by g|> =
     m with carrier updated_by f âˆ˜ g) âˆ§
  (âˆ€m g f.
     m with <|op updated_by f; op updated_by g|> = m with op updated_by f âˆ˜ g) âˆ§
  âˆ€m g f.
    m with <|id updated_by f; id updated_by g|> = m with id updated_by f âˆ˜ g
</pre>

<DT><span class="strong">monoid_fupdfupds_comp</span>
<DD>
<pre>
âŠ¢ ((âˆ€g f. carrier_fupd f âˆ˜ carrier_fupd g = carrier_fupd (f âˆ˜ g)) âˆ§
   âˆ€h g f. carrier_fupd f âˆ˜ carrier_fupd g âˆ˜ h = carrier_fupd (f âˆ˜ g) âˆ˜ h) âˆ§
  ((âˆ€g f. op_fupd f âˆ˜ op_fupd g = op_fupd (f âˆ˜ g)) âˆ§
   âˆ€h g f. op_fupd f âˆ˜ op_fupd g âˆ˜ h = op_fupd (f âˆ˜ g) âˆ˜ h) âˆ§
  (âˆ€g f. id_fupd f âˆ˜ id_fupd g = id_fupd (f âˆ˜ g)) âˆ§
  âˆ€h g f. id_fupd f âˆ˜ id_fupd g âˆ˜ h = id_fupd (f âˆ˜ g) âˆ˜ h
</pre>

<DT><span class="strong">monoid_homo_I_refl</span>
<DD>
<pre>
âŠ¢ âˆ€g. MonoidHomo I g g
</pre>

<DT><span class="strong">monoid_homo_compose</span>
<DD>
<pre>
âŠ¢ âˆ€g h k f1 f2.
    MonoidHomo f1 g h âˆ§ MonoidHomo f2 h k â‡’ MonoidHomo (f2 âˆ˜ f1) g k
</pre>

<DT><span class="strong">monoid_homo_cong</span>
<DD>
<pre>
âŠ¢ âˆ€g h f1 f2.
    Monoid g âˆ§ Monoid h âˆ§ (âˆ€x. x âˆˆ G â‡’ f1 x = f2 x) â‡’
    (MonoidHomo f1 g h â‡” MonoidHomo f2 g h)
</pre>

<DT><span class="strong">monoid_homo_element</span>
<DD>
<pre>
âŠ¢ âˆ€f g h. MonoidHomo f g h â‡’ âˆ€x. x âˆˆ G â‡’ f x âˆˆ h.carrier
</pre>

<DT><span class="strong">monoid_homo_exp</span>
<DD>
<pre>
âŠ¢ âˆ€g h f.
    Monoid g âˆ§ MonoidHomo f g h â‡’ âˆ€x. x âˆˆ G â‡’ âˆ€n. f (x ** n) = h.exp (f x) n
</pre>

<DT><span class="strong">monoid_homo_id</span>
<DD>
<pre>
âŠ¢ âˆ€f g h. MonoidHomo f g h â‡’ f #e = h.id
</pre>

<DT><span class="strong">monoid_homo_sym</span>
<DD>
<pre>
âŠ¢ âˆ€g h f.
    Monoid g âˆ§ MonoidHomo f g h âˆ§ BIJ f G h.carrier â‡’
    MonoidHomo (LINV f G) h g
</pre>

<DT><span class="strong">monoid_homo_sym_any</span>
<DD>
<pre>
âŠ¢ Monoid g âˆ§ MonoidHomo f g h âˆ§ (âˆ€x. x âˆˆ h.carrier â‡’ i x âˆˆ G âˆ§ f (i x) = x) âˆ§
  (âˆ€x. x âˆˆ G â‡’ i (f x) = x) â‡’
  MonoidHomo i h g
</pre>

<DT><span class="strong">monoid_homo_trans</span>
<DD>
<pre>
âŠ¢ âˆ€g h k f1 f2.
    MonoidHomo f1 g h âˆ§ MonoidHomo f2 h k â‡’ MonoidHomo (f2 âˆ˜ f1) g k
</pre>

<DT><span class="strong">monoid_id</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€x. x âˆˆ G â‡’ #e * x = x âˆ§ x * #e = x
</pre>

<DT><span class="strong">monoid_id_element</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ #e âˆˆ G
</pre>

<DT><span class="strong">monoid_id_exp</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€n. #e ** n = #e
</pre>

<DT><span class="strong">monoid_id_id</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ #e * #e = #e
</pre>

<DT><span class="strong">monoid_id_invertible</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ #e âˆˆ G*
</pre>

<DT><span class="strong">monoid_id_unique</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€e. e âˆˆ G â‡’ ((âˆ€x. x âˆˆ G â‡’ x * e = x âˆ§ e * x = x) â‡” e = #e)
</pre>

<DT><span class="strong">monoid_induction</span>
<DD>
<pre>
âŠ¢ âˆ€P. (âˆ€f f0 a. P (monoid f f0 a)) â‡’ âˆ€m. P m
</pre>

<DT><span class="strong">monoid_inj_image_abelian_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€g f. AbelianMonoid g âˆ§ INJ f G ğ•Œ(:Î²) â‡’ AbelianMonoid (monoid_inj_image g f)
</pre>

<DT><span class="strong">monoid_inj_image_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€g f. Monoid g âˆ§ INJ f G ğ•Œ(:Î²) â‡’ Monoid (monoid_inj_image g f)
</pre>

<DT><span class="strong">monoid_inj_image_monoid_homo</span>
<DD>
<pre>
âŠ¢ âˆ€g f. INJ f G ğ•Œ(:Î²) â‡’ MonoidHomo f g (monoid_inj_image g f)
</pre>

<DT><span class="strong">monoid_intersect_element</span>
<DD>
<pre>
âŠ¢ âˆ€g h x. x âˆˆ (g mINTER h).carrier â‡’ x âˆˆ G âˆ§ x âˆˆ H
</pre>

<DT><span class="strong">monoid_intersect_id</span>
<DD>
<pre>
âŠ¢ âˆ€g h. (g mINTER h).id = #e
</pre>

<DT><span class="strong">monoid_intersect_property</span>
<DD>
<pre>
âŠ¢ âˆ€g h.
    (g mINTER h).carrier = G âˆ© H âˆ§ (g mINTER h).op = $* âˆ§ (g mINTER h).id = #e
</pre>

<DT><span class="strong">monoid_inv_def_alt</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€x. x âˆˆ G* â‡” x âˆˆ G âˆ§ |/ x âˆˆ G âˆ§ x * |/ x = #e âˆ§ |/ x * x = #e
</pre>

<DT><span class="strong">monoid_inv_element</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€x. x âˆˆ G* â‡’ x âˆˆ G
</pre>

<DT><span class="strong">monoid_inv_from_invertibles</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€x. x âˆˆ G* â‡’ âˆƒy. y âˆˆ G âˆ§ x * y = #e âˆ§ y * x = #e
</pre>

<DT><span class="strong">monoid_inv_invertible</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€x. x âˆˆ G* â‡’ |/ x âˆˆ G*
</pre>

<DT><span class="strong">monoid_inv_op_invertible</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€x y. x âˆˆ G* âˆ§ y âˆˆ G* â‡’ x * y âˆˆ G*
</pre>

<DT><span class="strong">monoid_invertibles_element</span>
<DD>
<pre>
âŠ¢ âˆ€g x. x âˆˆ G* â‡” x âˆˆ G âˆ§ âˆƒy. y âˆˆ G âˆ§ x * y = #e âˆ§ y * x = #e
</pre>

<DT><span class="strong">monoid_invertibles_is_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ Monoid (Invertibles g)
</pre>

<DT><span class="strong">monoid_iso_I_refl</span>
<DD>
<pre>
âŠ¢ âˆ€g. MonoidIso I g g
</pre>

<DT><span class="strong">monoid_iso_bij</span>
<DD>
<pre>
âŠ¢ âˆ€g h f. MonoidIso f g h â‡’ BIJ f G h.carrier
</pre>

<DT><span class="strong">monoid_iso_card_eq</span>
<DD>
<pre>
âŠ¢ âˆ€g h f. MonoidIso f g h âˆ§ FINITE G â‡’ CARD G = CARD h.carrier
</pre>

<DT><span class="strong">monoid_iso_compose</span>
<DD>
<pre>
âŠ¢ âˆ€g h k f1 f2. MonoidIso f1 g h âˆ§ MonoidIso f2 h k â‡’ MonoidIso (f2 âˆ˜ f1) g k
</pre>

<DT><span class="strong">monoid_iso_element</span>
<DD>
<pre>
âŠ¢ âˆ€f g h. MonoidIso f g h â‡’ âˆ€x. x âˆˆ G â‡’ f x âˆˆ h.carrier
</pre>

<DT><span class="strong">monoid_iso_eq_id</span>
<DD>
<pre>
âŠ¢ âˆ€g h f.
    Monoid g âˆ§ Monoid h âˆ§ MonoidIso f g h â‡’ âˆ€x. x âˆˆ G â‡’ (f x = h.id â‡” x = #e)
</pre>

<DT><span class="strong">monoid_iso_exp</span>
<DD>
<pre>
âŠ¢ âˆ€g h f.
    Monoid g âˆ§ MonoidIso f g h â‡’ âˆ€x. x âˆˆ G â‡’ âˆ€n. f (x ** n) = h.exp (f x) n
</pre>

<DT><span class="strong">monoid_iso_id</span>
<DD>
<pre>
âŠ¢ âˆ€f g h. MonoidIso f g h â‡’ f #e = h.id
</pre>

<DT><span class="strong">monoid_iso_linv_iso</span>
<DD>
<pre>
âŠ¢ âˆ€g h f. Monoid g âˆ§ MonoidIso f g h â‡’ MonoidIso (LINV f G) h g
</pre>

<DT><span class="strong">monoid_iso_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€g h f. Monoid g âˆ§ MonoidIso f g h â‡’ Monoid h
</pre>

<DT><span class="strong">monoid_iso_order</span>
<DD>
<pre>
âŠ¢ âˆ€g h f.
    Monoid g âˆ§ Monoid h âˆ§ MonoidIso f g h â‡’ âˆ€x. x âˆˆ G â‡’ order h (f x) = ord x
</pre>

<DT><span class="strong">monoid_iso_property</span>
<DD>
<pre>
âŠ¢ âˆ€f g h.
    MonoidIso f g h â‡”
    MonoidHomo f g h âˆ§ âˆ€y. y âˆˆ h.carrier â‡’ âˆƒ!x. x âˆˆ G âˆ§ f x = y
</pre>

<DT><span class="strong">monoid_iso_sym</span>
<DD>
<pre>
âŠ¢ âˆ€g h f. Monoid g âˆ§ MonoidIso f g h â‡’ MonoidIso (LINV f G) h g
</pre>

<DT><span class="strong">monoid_iso_trans</span>
<DD>
<pre>
âŠ¢ âˆ€g h k f1 f2. MonoidIso f1 g h âˆ§ MonoidIso f2 h k â‡’ MonoidIso (f2 âˆ˜ f1) g k
</pre>

<DT><span class="strong">monoid_lid</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€x. x âˆˆ G â‡’ #e * x = x
</pre>

<DT><span class="strong">monoid_lid_unique</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€e. e âˆˆ G â‡’ (âˆ€x. x âˆˆ G â‡’ e * x = x) â‡’ e = #e
</pre>

<DT><span class="strong">monoid_literal_11</span>
<DD>
<pre>
âŠ¢ âˆ€f01 f1 a1 f02 f2 a2.
    <|carrier := f01; op := f1; id := a1|> =
    <|carrier := f02; op := f2; id := a2|> â‡” f01 = f02 âˆ§ f1 = f2 âˆ§ a1 = a2
</pre>

<DT><span class="strong">monoid_literal_nchotomy</span>
<DD>
<pre>
âŠ¢ âˆ€m. âˆƒf0 f a. m = <|carrier := f0; op := f; id := a|>
</pre>

<DT><span class="strong">monoid_nchotomy</span>
<DD>
<pre>
âŠ¢ âˆ€mm. âˆƒf f0 a. mm = monoid f f0 a
</pre>

<DT><span class="strong">monoid_op_element</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ x * y âˆˆ G
</pre>

<DT><span class="strong">monoid_order_cofactor</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’
      âˆ€x n. x âˆˆ G âˆ§ 0 < ord x âˆ§ n divides ord x â‡’ ord (x ** (ord x DIV n)) = n
</pre>

<DT><span class="strong">monoid_order_common</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’
      âˆ€x y.
        x âˆˆ G âˆ§ y âˆˆ G âˆ§ x * y = y * x â‡’
        âˆƒz. z âˆˆ G âˆ§ ord z * gcd (ord x) (ord y) = lcm (ord x) (ord y)
</pre>

<DT><span class="strong">monoid_order_common_coprime</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’
      âˆ€x y.
        x âˆˆ G âˆ§ y âˆˆ G âˆ§ x * y = y * x âˆ§ coprime (ord x) (ord y) â‡’
        âˆƒz. z âˆˆ G âˆ§ ord z = ord x * ord y
</pre>

<DT><span class="strong">monoid_order_condition</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€x. x âˆˆ G â‡’ âˆ€m. x ** m = #e â‡” ord x divides m
</pre>

<DT><span class="strong">monoid_order_divides_exp</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€x n. x âˆˆ G â‡’ (x ** n = #e â‡” ord x divides n)
</pre>

<DT><span class="strong">monoid_order_divides_maximal</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteAbelianMonoid g â‡’
      âˆ€x. x âˆˆ G âˆ§ 0 < ord x â‡’ ord x divides maximal_order g
</pre>

<DT><span class="strong">monoid_order_divisor</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’
      âˆ€x m. x âˆˆ G âˆ§ 0 < ord x âˆ§ m divides ord x â‡’ âˆƒy. y âˆˆ G âˆ§ ord y = m
</pre>

<DT><span class="strong">monoid_order_eq_1</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€x. x âˆˆ G â‡’ (ord x = 1 â‡” x = #e)
</pre>

<DT><span class="strong">monoid_order_id</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ ord #e = 1
</pre>

<DT><span class="strong">monoid_order_nonzero</span>
<DD>
<pre>
âŠ¢ âˆ€g x. Monoid g âˆ§ x âˆˆ G âˆ§ 0 < ord x â‡’ x âˆˆ G*
</pre>

<DT><span class="strong">monoid_order_power</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€x. x âˆˆ G â‡’ âˆ€k. ord (x ** k) * gcd (ord x) k = ord x
</pre>

<DT><span class="strong">monoid_order_power_coprime</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€x. x âˆˆ G â‡’ âˆ€n. coprime n (ord x) â‡’ ord (x ** n) = ord x
</pre>

<DT><span class="strong">monoid_order_power_eq_0</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€x. x âˆˆ G â‡’ âˆ€k. ord (x ** k) = 0 â‡” 0 < k âˆ§ ord x = 0
</pre>

<DT><span class="strong">monoid_order_power_eqn</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€x k. x âˆˆ G âˆ§ 0 < k â‡’ ord (x ** k) = ord x DIV gcd k (ord x)
</pre>

<DT><span class="strong">monoid_rid</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€x. x âˆˆ G â‡’ x * #e = x
</pre>

<DT><span class="strong">monoid_rid_unique</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€e. e âˆˆ G â‡’ (âˆ€x. x âˆˆ G â‡’ x * e = x) â‡’ e = #e
</pre>

<DT><span class="strong">monoid_updates_eq_literal</span>
<DD>
<pre>
âŠ¢ âˆ€m f0 f a.
    m with <|carrier := f0; op := f; id := a|> =
    <|carrier := f0; op := f; id := a|>
</pre>

<DT><span class="strong">monoid_weak_iso_id</span>
<DD>
<pre>
âŠ¢ âˆ€f g h. Monoid g âˆ§ Monoid h âˆ§ WeakIso f g h â‡’ f #e = h.id
</pre>

<DT><span class="strong">multiplication_monoid_abelian_monoid</span>
<DD>
<pre>
âŠ¢ AbelianMonoid multiplication_monoid
</pre>

<DT><span class="strong">multiplication_monoid_monoid</span>
<DD>
<pre>
âŠ¢ Monoid multiplication_monoid
</pre>

<DT><span class="strong">multiplication_monoid_property</span>
<DD>
<pre>
âŠ¢ multiplication_monoid.carrier = ğ•Œ(:num) âˆ§ multiplication_monoid.op = $* âˆ§
  multiplication_monoid.id = 1
</pre>

<DT><span class="strong">order_alt</span>
<DD>
<pre>
âŠ¢ âˆ€g x. ord x = case OLEAST k. 0 < k âˆ§ x ** k = #e of NONE => 0 | SOME k => k
</pre>

<DT><span class="strong">order_eq_0</span>
<DD>
<pre>
âŠ¢ âˆ€g x. ord x = 0 â‡” âˆ€n. 0 < n â‡’ x ** n â‰  #e
</pre>

<DT><span class="strong">order_minimal</span>
<DD>
<pre>
âŠ¢ âˆ€g x n. 0 < n âˆ§ n < ord x â‡’ x ** n â‰  #e
</pre>

<DT><span class="strong">order_period</span>
<DD>
<pre>
âŠ¢ âˆ€g x. 0 < ord x â‡’ period g x (ord x)
</pre>

<DT><span class="strong">order_property</span>
<DD>
<pre>
âŠ¢ âˆ€g x. x ** ord x = #e
</pre>

<DT><span class="strong">order_thm</span>
<DD>
<pre>
âŠ¢ âˆ€g x n. 0 < n â‡’ (ord x = n â‡” x ** n = #e âˆ§ âˆ€m. 0 < m âˆ§ m < n â‡’ x ** m â‰  #e)
</pre>

<DT><span class="strong">orders_element</span>
<DD>
<pre>
âŠ¢ âˆ€g x n. x âˆˆ orders g n â‡” x âˆˆ G âˆ§ ord x = n
</pre>

<DT><span class="strong">orders_eq_1</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ orders g 1 = {#e}
</pre>

<DT><span class="strong">orders_finite</span>
<DD>
<pre>
âŠ¢ âˆ€g. FINITE G â‡’ âˆ€n. FINITE (orders g n)
</pre>

<DT><span class="strong">orders_subset</span>
<DD>
<pre>
âŠ¢ âˆ€g n. orders g n âŠ† G
</pre>

<DT><span class="strong">plus_mod_abelian_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ AbelianMonoid (plus_mod n)
</pre>

<DT><span class="strong">plus_mod_exp</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ âˆ€x k. (plus_mod n).exp x k = (k * x) MOD n
</pre>

<DT><span class="strong">plus_mod_finite</span>
<DD>
<pre>
âŠ¢ âˆ€n. FINITE (plus_mod n).carrier
</pre>

<DT><span class="strong">plus_mod_finite_abelian_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ FiniteAbelianMonoid (plus_mod n)
</pre>

<DT><span class="strong">plus_mod_finite_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ FiniteMonoid (plus_mod n)
</pre>

<DT><span class="strong">plus_mod_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ Monoid (plus_mod n)
</pre>

<DT><span class="strong">plus_mod_property</span>
<DD>
<pre>
âŠ¢ âˆ€n. (plus_mod n).carrier = count n âˆ§
      (plus_mod n).op = (Î»i j. (i + j) MOD n) âˆ§ (plus_mod n).id = 0 âˆ§
      (âˆ€x. x âˆˆ (plus_mod n).carrier â‡’ x < n) âˆ§ FINITE (plus_mod n).carrier âˆ§
      CARD (plus_mod n).carrier = n
</pre>

<DT><span class="strong">power_monoid_abelian_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€b. AbelianMonoid (power_monoid b)
</pre>

<DT><span class="strong">power_monoid_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€b. Monoid (power_monoid b)
</pre>

<DT><span class="strong">power_monoid_property</span>
<DD>
<pre>
âŠ¢ âˆ€b. (power_monoid b).carrier = {b ** j | j âˆˆ ğ•Œ(:num)} âˆ§
      (power_monoid b).op = $* âˆ§ (power_monoid b).id = 1
</pre>

<DT><span class="strong">power_to_addition_homo</span>
<DD>
<pre>
âŠ¢ âˆ€b. 1 < b â‡’ MonoidHomo (LOG b) (power_monoid b) addition_monoid
</pre>

<DT><span class="strong">power_to_addition_iso</span>
<DD>
<pre>
âŠ¢ âˆ€b. 1 < b â‡’ MonoidIso (LOG b) (power_monoid b) addition_monoid
</pre>

<DT><span class="strong">set_inter_abelian_monoid</span>
<DD>
<pre>
âŠ¢ AbelianMonoid set_inter
</pre>

<DT><span class="strong">set_inter_monoid</span>
<DD>
<pre>
âŠ¢ Monoid set_inter
</pre>

<DT><span class="strong">set_union_abelian_monoid</span>
<DD>
<pre>
âŠ¢ AbelianMonoid set_union
</pre>

<DT><span class="strong">set_union_monoid</span>
<DD>
<pre>
âŠ¢ Monoid set_union
</pre>

<DT><span class="strong">submonoid_I_antisym</span>
<DD>
<pre>
âŠ¢ âˆ€g h. submonoid h g âˆ§ submonoid g h â‡’ MonoidIso I h g
</pre>

<DT><span class="strong">submonoid_alt</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’
      âˆ€h. h << g â‡”
          H âŠ† G âˆ§ (âˆ€x y. x âˆˆ H âˆ§ y âˆˆ H â‡’ h.op x y âˆˆ H) âˆ§ h.id âˆˆ H âˆ§
          h.op = $* âˆ§ h.id = #e
</pre>

<DT><span class="strong">submonoid_antisymmetric</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h << g âˆ§ g << h â‡’ h = g
</pre>

<DT><span class="strong">submonoid_big_intersect_element</span>
<DD>
<pre>
âŠ¢ âˆ€g x. x âˆˆ (smbINTER g).carrier â‡” âˆ€h. h << g â‡’ x âˆˆ H
</pre>

<DT><span class="strong">submonoid_big_intersect_has_id</span>
<DD>
<pre>
âŠ¢ âˆ€g. (smbINTER g).id âˆˆ (smbINTER g).carrier
</pre>

<DT><span class="strong">submonoid_big_intersect_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ Monoid (smbINTER g)
</pre>

<DT><span class="strong">submonoid_big_intersect_op_element</span>
<DD>
<pre>
âŠ¢ âˆ€g x y.
    x âˆˆ (smbINTER g).carrier âˆ§ y âˆˆ (smbINTER g).carrier â‡’
    (smbINTER g).op x y âˆˆ (smbINTER g).carrier
</pre>

<DT><span class="strong">submonoid_big_intersect_property</span>
<DD>
<pre>
âŠ¢ âˆ€g. (smbINTER g).carrier = BIGINTER (IMAGE (Î»h. H) {h | h << g}) âˆ§
      (âˆ€x y.
         x âˆˆ (smbINTER g).carrier âˆ§ y âˆˆ (smbINTER g).carrier â‡’
         (smbINTER g).op x y = x * y) âˆ§ (smbINTER g).id = #e
</pre>

<DT><span class="strong">submonoid_big_intersect_submonoid</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ smbINTER g << g
</pre>

<DT><span class="strong">submonoid_big_intersect_subset</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ (smbINTER g).carrier âŠ† G
</pre>

<DT><span class="strong">submonoid_carrier_antisym</span>
<DD>
<pre>
âŠ¢ âˆ€g h. submonoid h g âˆ§ G âŠ† H â‡’ MonoidIso I h g
</pre>

<DT><span class="strong">submonoid_carrier_subset</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h << g â‡’ H âŠ† G
</pre>

<DT><span class="strong">submonoid_element</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h << g â‡’ âˆ€x. x âˆˆ H â‡’ x âˆˆ G
</pre>

<DT><span class="strong">submonoid_eqn</span>
<DD>
<pre>
âŠ¢ âˆ€g h.
    submonoid h g â‡”
    H âŠ† G âˆ§ (âˆ€x y. x âˆˆ H âˆ§ y âˆˆ H â‡’ h.op x y = x * y) âˆ§ h.id = #e
</pre>

<DT><span class="strong">submonoid_exp</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h << g â‡’ âˆ€x. x âˆˆ H â‡’ âˆ€n. h.exp x n = x ** n
</pre>

<DT><span class="strong">submonoid_homo_homo</span>
<DD>
<pre>
âŠ¢ âˆ€g h k f. submonoid h g âˆ§ MonoidHomo f g k â‡’ MonoidHomo f h k
</pre>

<DT><span class="strong">submonoid_homomorphism</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h << g â‡’ Monoid h âˆ§ Monoid g âˆ§ submonoid h g
</pre>

<DT><span class="strong">submonoid_id</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h << g â‡’ h.id = #e
</pre>

<DT><span class="strong">submonoid_intersect_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€g h k. h << g âˆ§ k << g â‡’ Monoid (h mINTER k)
</pre>

<DT><span class="strong">submonoid_intersect_property</span>
<DD>
<pre>
âŠ¢ âˆ€g h k.
    h << g âˆ§ k << g â‡’
    (h mINTER k).carrier = H âˆ© k.carrier âˆ§
    (âˆ€x y. x âˆˆ H âˆ© k.carrier âˆ§ y âˆˆ H âˆ© k.carrier â‡’ (h mINTER k).op x y = x * y) âˆ§
    (h mINTER k).id = #e
</pre>

<DT><span class="strong">submonoid_intersect_submonoid</span>
<DD>
<pre>
âŠ¢ âˆ€g h k. h << g âˆ§ k << g â‡’ (h mINTER k) << g
</pre>

<DT><span class="strong">submonoid_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h << g â‡’ Monoid h
</pre>

<DT><span class="strong">submonoid_op</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h << g â‡’ h.op = $*
</pre>

<DT><span class="strong">submonoid_order</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h << g â‡’ âˆ€x. x âˆˆ H â‡’ order h x = ord x
</pre>

<DT><span class="strong">submonoid_order_eqn</span>
<DD>
<pre>
âŠ¢ âˆ€g h. Monoid g âˆ§ Monoid h âˆ§ submonoid h g â‡’ âˆ€x. x âˆˆ H â‡’ order h x = ord x
</pre>

<DT><span class="strong">submonoid_property</span>
<DD>
<pre>
âŠ¢ âˆ€g h.
    h << g â‡’
    Monoid h âˆ§ Monoid g âˆ§ H âŠ† G âˆ§ (âˆ€x y. x âˆˆ H âˆ§ y âˆˆ H â‡’ h.op x y = x * y) âˆ§
    h.id = #e
</pre>

<DT><span class="strong">submonoid_refl</span>
<DD>
<pre>
âŠ¢ âˆ€g. submonoid g g
</pre>

<DT><span class="strong">submonoid_reflexive</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ g << g
</pre>

<DT><span class="strong">submonoid_subset</span>
<DD>
<pre>
âŠ¢ âˆ€g h. submonoid h g â‡’ H âŠ† G
</pre>

<DT><span class="strong">submonoid_trans</span>
<DD>
<pre>
âŠ¢ âˆ€g h k. submonoid g h âˆ§ submonoid h k â‡’ submonoid g k
</pre>

<DT><span class="strong">submonoid_transitive</span>
<DD>
<pre>
âŠ¢ âˆ€g h k. k << h âˆ§ h << g â‡’ k << g
</pre>

<DT><span class="strong">times_mod_abelian_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ AbelianMonoid (times_mod n)
</pre>

<DT><span class="strong">times_mod_eval</span>
<DD>
<pre>
âŠ¢ âˆ€n. (times_mod n).carrier = count n âˆ§
      (âˆ€x y. (times_mod n).op x y = (x * y) MOD n) âˆ§
      (times_mod n).id = if n = 1 then 0 else 1
</pre>

<DT><span class="strong">times_mod_exp</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ âˆ€x k. (times_mod n).exp x k = (x MOD n) ** k MOD n
</pre>

<DT><span class="strong">times_mod_finite</span>
<DD>
<pre>
âŠ¢ âˆ€n. FINITE (times_mod n).carrier
</pre>

<DT><span class="strong">times_mod_finite_abelian_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ FiniteAbelianMonoid (times_mod n)
</pre>

<DT><span class="strong">times_mod_finite_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ FiniteMonoid (times_mod n)
</pre>

<DT><span class="strong">times_mod_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ Monoid (times_mod n)
</pre>

<DT><span class="strong">times_mod_property</span>
<DD>
<pre>
âŠ¢ âˆ€n. (times_mod n).carrier = count n âˆ§
      (times_mod n).op = (Î»i j. (i * j) MOD n) âˆ§
      (times_mod n).id = (if n = 1 then 0 else 1) âˆ§
      (âˆ€x. x âˆˆ (times_mod n).carrier â‡’ x < n) âˆ§ FINITE (times_mod n).carrier âˆ§
      CARD (times_mod n).carrier = n
</pre>

<DT><span class="strong">trivial_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€e. FiniteAbelianMonoid (trivial_monoid e)
</pre>

</DL>



<hr>
</body>
</html>
