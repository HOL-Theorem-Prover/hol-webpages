<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: monoid</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "monoid"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "bagTheory.html"><span class="strong">bag</span></a>&nbsp;&nbsp;
    <a href = "primeTheory.html"><span class="strong">prime</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Type <th> Arity<tr><td>
    <span class="strong">monoid</span>
    <td>
    1
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">AbelianMonoid</span>
    <td>
    :α monoid -> bool
    <tr><td>
    <span class="strong">FiniteAbelianMonoid</span>
    <td>
    :α monoid -> bool
    <tr><td> <span class="strong">FiniteMonoid</span> <td> :α monoid -> bool
    <tr><td>
    <span class="strong">GPROD_SET</span>
    <td>
    :α monoid -> (α -> bool) -> α
    <tr><td>
    <span class="strong">Invertibles</span>
    <td>
    :α monoid -> α monoid
    <tr><td> <span class="strong">Monoid</span> <td> :α monoid -> bool
    <tr><td>
    <span class="strong">MonoidAuto</span>
    <td>
    :(α -> α) -> α monoid -> bool
    <tr><td>
    <span class="strong">MonoidEndo</span>
    <td>
    :(α -> α) -> α monoid -> bool
    <tr><td>
    <span class="strong">MonoidHomo</span>
    <td>
    :(α -> β) -> α monoid -> β monoid -> bool
    <tr><td>
    <span class="strong">MonoidIso</span>
    <td>
    :(α -> β) -> α monoid -> β monoid -> bool
    <tr><td>
    <span class="strong">Submonoid</span>
    <td>
    :α monoid -> α monoid -> bool
    <tr><td>
    <span class="strong">WeakHomo</span>
    <td>
    :(α -> β) -> α monoid -> β monoid -> bool
    <tr><td>
    <span class="strong">WeakIso</span>
    <td>
    :(α -> β) -> α monoid -> β monoid -> bool
    <tr><td> <span class="strong">addition_monoid</span> <td> :num monoid
    <tr><td> <span class="strong">extend</span> <td> :α monoid -> α monoid
    <tr><td>
    <span class="strong">homo_monoid</span>
    <td>
    :α monoid -> (α -> β) -> β monoid
    <tr><td>
    <span class="strong">image_op</span>
    <td>
    :α monoid -> (α -> β) -> β -> β -> β
    <tr><td> <span class="strong">lists</span> <td> :α list monoid
    <tr><td>
    <span class="strong">monoid_CASE</span>
    <td>
    :α monoid -> ((α -> bool) -> (α -> α -> α) -> α -> β) -> β
    <tr><td>
    <span class="strong">monoid_exp</span>
    <td>
    :α monoid -> α -> num -> α
    <tr><td>
    <span class="strong">monoid_inj_image</span>
    <td>
    :α monoid -> (α -> β) -> β monoid
    <tr><td>
    <span class="strong">monoid_intersect</span>
    <td>
    :α monoid -> α monoid -> α monoid
    <tr><td> <span class="strong">monoid_inv</span> <td> :α monoid -> α -> α
    <tr><td>
    <span class="strong">monoid_invertibles</span>
    <td>
    :α monoid -> α -> bool
    <tr><td>
    <span class="strong">monoid_size</span>
    <td>
    :(α -> num) -> α monoid -> num
    <tr><td>
    <span class="strong">multiplication_monoid</span>
    <td>
    :num monoid
    <tr><td> <span class="strong">order</span> <td> :α monoid -> α -> num
    <tr><td>
    <span class="strong">orders</span>
    <td>
    :α monoid -> num -> α -> bool
    <tr><td>
    <span class="strong">period</span>
    <td>
    :α monoid -> α -> num -> bool
    <tr><td> <span class="strong">plus_mod</span> <td> :num -> num monoid
    <tr><td> <span class="strong">power_monoid</span> <td> :num -> num monoid
    <tr><td>
    <span class="strong">recordtype.monoid</span>
    <td>
    :(α -> bool) -> (α -> α -> α) -> α -> α monoid
    <tr><td>
    <span class="strong">recordtype.monoid.seldef.carrier</span>
    <td>
    :α monoid -> α -> bool
    <tr><td>
    <span class="strong">recordtype.monoid.seldef.carrier_fupd</span>
    <td>
    :((α -> bool) -> α -> bool) -> α monoid -> α monoid
    <tr><td>
    <span class="strong">recordtype.monoid.seldef.id</span>
    <td>
    :α monoid -> α
    <tr><td>
    <span class="strong">recordtype.monoid.seldef.id_fupd</span>
    <td>
    :(α -> α) -> α monoid -> α monoid
    <tr><td>
    <span class="strong">recordtype.monoid.seldef.op</span>
    <td>
    :α monoid -> α -> α -> α
    <tr><td>
    <span class="strong">recordtype.monoid.seldef.op_fupd</span>
    <td>
    :((α -> α -> α) -> α -> α -> α) -> α monoid -> α monoid
    <tr><td> <span class="strong">set_inter</span> <td> :(α -> bool) monoid
    <tr><td> <span class="strong">set_union</span> <td> :(α -> bool) monoid
    <tr><td>
    <span class="strong">submonoid</span>
    <td>
    :α monoid -> α monoid -> bool
    <tr><td>
    <span class="strong">submonoid_big_intersect</span>
    <td>
    :α monoid -> α monoid
    <tr><td> <span class="strong">times_mod</span> <td> :num -> num monoid
    <tr><td> <span class="strong">trivial_monoid</span> <td> :α -> α monoid
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">AbelianMonoid_def</span>
<DD>
<pre>
⊢ ∀g. AbelianMonoid g ⇔ Monoid g ∧ ∀x y. x ∈ G ∧ y ∈ G ⇒ x * y = y * x
</pre>

<DT><span class="strong">FiniteAbelianMonoid_def</span>
<DD>
<pre>
⊢ ∀g. FiniteAbelianMonoid g ⇔ AbelianMonoid g ∧ FINITE G
</pre>

<DT><span class="strong">FiniteMonoid_def</span>
<DD>
<pre>
⊢ ∀g. FiniteMonoid g ⇔ Monoid g ∧ FINITE G
</pre>

<DT><span class="strong">GPROD_SET_def</span>
<DD>
<pre>
⊢ ∀g s. GPROD_SET g s = GITSET g s #e
</pre>

<DT><span class="strong">Invertibles_def</span>
<DD>
<pre>
⊢ ∀g. Invertibles g = <|carrier := G*; op := $*; id := #e|>
</pre>

<DT><span class="strong">MonoidAuto_def</span>
<DD>
<pre>
⊢ ∀f g. MonoidAuto f g ⇔ MonoidIso f g g
</pre>

<DT><span class="strong">MonoidEndo_def</span>
<DD>
<pre>
⊢ ∀f g. MonoidEndo f g ⇔ MonoidHomo f g g
</pre>

<DT><span class="strong">MonoidHomo_def</span>
<DD>
<pre>
⊢ ∀f g h.
    MonoidHomo f g h ⇔
    (∀x. x ∈ G ⇒ f x ∈ h.carrier) ∧
    (∀x y. x ∈ G ∧ y ∈ G ⇒ f (x * y) = h.op (f x) (f y)) ∧ f #e = h.id
</pre>

<DT><span class="strong">MonoidIso_def</span>
<DD>
<pre>
⊢ ∀f g h. MonoidIso f g h ⇔ MonoidHomo f g h ∧ BIJ f G h.carrier
</pre>

<DT><span class="strong">Monoid_def</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇔
      (∀x y. x ∈ G ∧ y ∈ G ⇒ x * y ∈ G) ∧
      (∀x y z. x ∈ G ∧ y ∈ G ∧ z ∈ G ⇒ x * y * z = x * (y * z)) ∧ #e ∈ G ∧
      ∀x. x ∈ G ⇒ #e * x = x ∧ x * #e = x
</pre>

<DT><span class="strong">Submonoid_def</span>
<DD>
<pre>
⊢ ∀h g. h << g ⇔ Monoid h ∧ Monoid g ∧ H ⊆ G ∧ h.op = $* ∧ h.id = #e
</pre>

<DT><span class="strong">WeakHomo_def</span>
<DD>
<pre>
⊢ ∀f g h.
    WeakHomo f g h ⇔
    (∀x. x ∈ G ⇒ f x ∈ h.carrier) ∧
    ∀x y. x ∈ G ∧ y ∈ G ⇒ f (x * y) = h.op (f x) (f y)
</pre>

<DT><span class="strong">WeakIso_def</span>
<DD>
<pre>
⊢ ∀f g h. WeakIso f g h ⇔ WeakHomo f g h ∧ BIJ f G h.carrier
</pre>

<DT><span class="strong">addition_monoid_def</span>
<DD>
<pre>
⊢ addition_monoid = <|carrier := 𝕌(:num); op := $+; id := 0|>
</pre>

<DT><span class="strong">extend_def</span>
<DD>
<pre>
⊢ ∀m. extend m =
      <|carrier := 𝕌(:α); id := m.id;
        op :=
          (λx y.
               if x ∈ m.carrier then if y ∈ m.carrier then m.op x y else y
               else x)|>
</pre>

<DT><span class="strong">homo_monoid_def</span>
<DD>
<pre>
⊢ ∀g f.
    homo_group g f = <|carrier := IMAGE f G; op := image_op g f; id := f #e|>
</pre>

<DT><span class="strong">image_op_def</span>
<DD>
<pre>
⊢ ∀g f x y.
    image_op g f x y = f (CHOICE (preimage f G x) * CHOICE (preimage f G y))
</pre>

<DT><span class="strong">lists_def</span>
<DD>
<pre>
⊢ lists = <|carrier := 𝕌(:α list); id := []; op := $++ |>
</pre>

<DT><span class="strong">monoid_TY_DEF</span>
<DD>
<pre>
⊢ ∃rep.
    TYPE_DEFINITION
      (λa0'.
           ∀ $var$('monoid').
             (∀a0'.
                (∃a0 a1 a2.
                   a0' =
                   (λa0 a1 a2.
                        ind_type$CONSTR 0 (a0,a1,a2) (λn. ind_type$BOTTOM)) a0
                     a1 a2) ⇒
                $var$('monoid') a0') ⇒
             $var$('monoid') a0') rep
</pre>

<DT><span class="strong">monoid_case_def</span>
<DD>
<pre>
⊢ ∀a0 a1 a2 f. monoid_CASE (monoid a0 a1 a2) f = f a0 a1 a2
</pre>

<DT><span class="strong">monoid_exp_def</span>
<DD>
<pre>
⊢ ∀g x n. x ** n = FUNPOW ($* x) n #e
</pre>

<DT><span class="strong">monoid_inj_image_def</span>
<DD>
<pre>
⊢ ∀g f.
    monoid_inj_image g f =
    <|carrier := IMAGE f G; op := (let t = LINV f G in λx y. f (t x * t y));
      id := f #e|>
</pre>

<DT><span class="strong">monoid_intersect_def</span>
<DD>
<pre>
⊢ ∀g h. (g mINTER h) = <|carrier := G ∩ H; op := $*; id := #e|>
</pre>

<DT><span class="strong">monoid_inv_def</span>
<DD>
<pre>
⊢ ∀g x. Monoid g ∧ x ∈ G* ⇒ |/ x ∈ G ∧ x * |/ x = #e ∧ |/ x * x = #e
</pre>

<DT><span class="strong">monoid_invertibles_def</span>
<DD>
<pre>
⊢ ∀g. G* = {x | x ∈ G ∧ ∃y. y ∈ G ∧ x * y = #e ∧ y * x = #e}
</pre>

<DT><span class="strong">monoid_size_def</span>
<DD>
<pre>
⊢ ∀f a0 a1 a2. monoid_size f (monoid a0 a1 a2) = 1 + f a2
</pre>

<DT><span class="strong">multiplication_monoid_def</span>
<DD>
<pre>
⊢ multiplication_monoid = <|carrier := 𝕌(:num); op := $*; id := 1|>
</pre>

<DT><span class="strong">order_def</span>
<DD>
<pre>
⊢ ∀g x. ord x = case OLEAST k. period g x k of NONE => 0 | SOME k => k
</pre>

<DT><span class="strong">orders_def</span>
<DD>
<pre>
⊢ ∀g n. orders g n = {x | x ∈ G ∧ ord x = n}
</pre>

<DT><span class="strong">period_def</span>
<DD>
<pre>
⊢ ∀g x k. period g x k ⇔ 0 < k ∧ x ** k = #e
</pre>

<DT><span class="strong">plus_mod_def</span>
<DD>
<pre>
⊢ ∀n. plus_mod n =
      <|carrier := count n; id := 0; op := (λi j. (i + j) MOD n)|>
</pre>

<DT><span class="strong">power_monoid_def</span>
<DD>
<pre>
⊢ ∀b. power_monoid b =
      <|carrier := {b ** j | j ∈ 𝕌(:num)}; op := $*; id := 1|>
</pre>

<DT><span class="strong">recordtype_monoid_seldef_carrier_def</span>
<DD>
<pre>
⊢ ∀f f0 a. (monoid f f0 a).carrier = f
</pre>

<DT><span class="strong">recordtype_monoid_seldef_carrier_fupd_def</span>
<DD>
<pre>
⊢ ∀f1 f f0 a. monoid f f0 a with carrier updated_by f1 = monoid (f1 f) f0 a
</pre>

<DT><span class="strong">recordtype_monoid_seldef_id_def</span>
<DD>
<pre>
⊢ ∀f f0 a. (monoid f f0 a).id = a
</pre>

<DT><span class="strong">recordtype_monoid_seldef_id_fupd_def</span>
<DD>
<pre>
⊢ ∀f1 f f0 a. monoid f f0 a with id updated_by f1 = monoid f f0 (f1 a)
</pre>

<DT><span class="strong">recordtype_monoid_seldef_op_def</span>
<DD>
<pre>
⊢ ∀f f0 a. (monoid f f0 a).op = f0
</pre>

<DT><span class="strong">recordtype_monoid_seldef_op_fupd_def</span>
<DD>
<pre>
⊢ ∀f1 f f0 a. monoid f f0 a with op updated_by f1 = monoid f (f1 f0) a
</pre>

<DT><span class="strong">set_inter_def</span>
<DD>
<pre>
⊢ set_inter = <|carrier := 𝕌(:α -> bool); id := 𝕌(:α); op := $INTER|>
</pre>

<DT><span class="strong">set_union_def</span>
<DD>
<pre>
⊢ set_union = <|carrier := 𝕌(:α -> bool); id := ∅; op := $UNION|>
</pre>

<DT><span class="strong">submonoid_big_intersect_def</span>
<DD>
<pre>
⊢ ∀g. smbINTER g =
      <|carrier := BIGINTER (IMAGE (λh. H) {h | h << g}); op := $*; id := #e|>
</pre>

<DT><span class="strong">submonoid_def</span>
<DD>
<pre>
⊢ ∀h g. submonoid h g ⇔ MonoidHomo I h g
</pre>

<DT><span class="strong">times_mod_def</span>
<DD>
<pre>
⊢ ∀n. times_mod n =
      <|carrier := count n; id := if n = 1 then 0 else 1;
        op := (λi j. (i * j) MOD n)|>
</pre>

<DT><span class="strong">trivial_monoid_def</span>
<DD>
<pre>
⊢ ∀e. trivial_monoid e = <|carrier := {e}; id := e; op := (λx y. e)|>
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">COMMUTING_GITBAG_INSERT</span>
<DD>
<pre>
⊢ ∀g b.
    AbelianMonoid g ∧ FINITE_BAG b ∧ SET_OF_BAG b ⊆ G ⇒
    ∀x a::G. GITBAG g (BAG_INSERT x b) a = GITBAG g b (x * a)
</pre>

<DT><span class="strong">COMMUTING_GITSET_INSERT</span>
<DD>
<pre>
⊢ ∀g s.
    AbelianMonoid g ∧ FINITE s ∧ s ⊆ G ⇒
    ∀b x::G. GITSET g (x INSERT s) b = GITSET g (s DELETE x) (x * b)
</pre>

<DT><span class="strong">COMMUTING_GITSET_RECURSES</span>
<DD>
<pre>
⊢ ∀g s.
    AbelianMonoid g ∧ FINITE s ∧ s ⊆ G ⇒
    ∀b x::G. GITSET g (x INSERT s) b = x * GITSET g (s DELETE x) b
</pre>

<DT><span class="strong">COMMUTING_GITSET_REDUCTION</span>
<DD>
<pre>
⊢ ∀g s.
    AbelianMonoid g ∧ FINITE s ∧ s ⊆ G ⇒
    ∀b x::G. GITSET g s (x * b) = x * GITSET g s b
</pre>

<DT><span class="strong">EXISTS_monoid</span>
<DD>
<pre>
⊢ ∀P. (∃m. P m) ⇔ ∃f0 f a. P <|carrier := f0; op := f; id := a|>
</pre>

<DT><span class="strong">FORALL_monoid</span>
<DD>
<pre>
⊢ ∀P. (∀m. P m) ⇔ ∀f0 f a. P <|carrier := f0; op := f; id := a|>
</pre>

<DT><span class="strong">FiniteAbelianMonoid_def_alt</span>
<DD>
<pre>
⊢ ∀g. FiniteAbelianMonoid g ⇔
      FiniteMonoid g ∧ ∀x y. x ∈ G ∧ y ∈ G ⇒ x * y = y * x
</pre>

<DT><span class="strong">GBAG_IMAGE_FILTER</span>
<DD>
<pre>
⊢ AbelianMonoid g ⇒
  ∀b. FINITE_BAG b ⇒
      IMAGE f (SET_OF_BAG b ∩ P) ⊆ G ⇒
      GBAG g (BAG_IMAGE f (BAG_FILTER P b)) =
      GBAG g (BAG_IMAGE (λx. if P x then f x else #e) b)
</pre>

<DT><span class="strong">GBAG_IMAGE_PARTITION</span>
<DD>
<pre>
⊢ AbelianMonoid g ∧ FINITE s ⇒
  ∀b. FINITE_BAG b ⇒
      IMAGE f (SET_OF_BAG b) ⊆ G ∧ (∀x. x ⋲ b ⇒ ∃P. P ∈ s ∧ P x) ∧
      (∀x P1 P2. x ⋲ b ∧ P1 ∈ s ∧ P2 ∈ s ∧ P1 x ∧ P2 x ⇒ P1 = P2) ⇒
      GBAG g
        (BAG_IMAGE (λP. GBAG g (BAG_IMAGE f (BAG_FILTER P b))) (BAG_OF_SET s)) =
      GBAG g (BAG_IMAGE f b)
</pre>

<DT><span class="strong">GBAG_INSERT</span>
<DD>
<pre>
⊢ AbelianMonoid g ∧ FINITE_BAG b ∧ SET_OF_BAG b ⊆ G ∧ x ∈ G ⇒
  GBAG g (BAG_INSERT x b) = x * GBAG g b
</pre>

<DT><span class="strong">GBAG_PARTITION</span>
<DD>
<pre>
⊢ AbelianMonoid g ∧ FINITE s ∧ FINITE_BAG b ∧ SET_OF_BAG b ⊆ G ∧
  (∀x. x ⋲ b ⇒ ∃P. P ∈ s ∧ P x) ∧
  (∀x P1 P2. x ⋲ b ∧ P1 ∈ s ∧ P2 ∈ s ∧ P1 x ∧ P2 x ⇒ P1 = P2) ⇒
  GBAG g (BAG_IMAGE (λP. GBAG g (BAG_FILTER P b)) (BAG_OF_SET s)) = GBAG g b
</pre>

<DT><span class="strong">GBAG_UNION</span>
<DD>
<pre>
⊢ AbelianMonoid g ∧ FINITE_BAG b1 ∧ FINITE_BAG b2 ∧ SET_OF_BAG b1 ⊆ G ∧
  SET_OF_BAG b2 ⊆ G ⇒
  GBAG g (b1 ⊎ b2) = GBAG g b1 * GBAG g b2
</pre>

<DT><span class="strong">GBAG_in_carrier</span>
<DD>
<pre>
⊢ ∀g b. AbelianMonoid g ∧ FINITE_BAG b ∧ SET_OF_BAG b ⊆ G ⇒ GBAG g b ∈ G
</pre>

<DT><span class="strong">GITBAG_BAG_IMAGE_op</span>
<DD>
<pre>
⊢ ∀g. AbelianMonoid g ⇒
      ∀b. FINITE_BAG b ⇒
          ∀p q a.
            IMAGE p (SET_OF_BAG b) ⊆ G ∧ IMAGE q (SET_OF_BAG b) ⊆ G ∧ a ∈ G ⇒
            GITBAG g (BAG_IMAGE (λx. p x * q x) b) a =
            GITBAG g (BAG_IMAGE p b) a * GBAG g (BAG_IMAGE q b)
</pre>

<DT><span class="strong">GITBAG_CONG</span>
<DD>
<pre>
⊢ ∀g. AbelianMonoid g ⇒
      ∀b. FINITE_BAG b ⇒
          ∀b' a a'.
            FINITE_BAG b' ∧ a ∈ G ∧ SET_OF_BAG b ⊆ G ∧ SET_OF_BAG b' ⊆ G ∧
            (∀x. x ⋲ b ⊎ b' ∧ x ≠ #e ⇒ b x = b' x) ⇒
            GITBAG g b a = GITBAG g b' a
</pre>

<DT><span class="strong">GITBAG_EMPTY</span>
<DD>
<pre>
⊢ ∀g a. GITBAG g {||} a = a
</pre>

<DT><span class="strong">GITBAG_GBAG</span>
<DD>
<pre>
⊢ ∀g. AbelianMonoid g ⇒
      ∀b. FINITE_BAG b ⇒
          ∀a. a ∈ G ∧ SET_OF_BAG b ⊆ G ⇒ GITBAG g b a = a * GBAG g b
</pre>

<DT><span class="strong">GITBAG_INSERT</span>
<DD>
<pre>
⊢ ∀b. FINITE_BAG b ⇒
      ∀g x a.
        GITBAG g (BAG_INSERT x b) a =
        GITBAG g (BAG_REST (BAG_INSERT x b)) (BAG_CHOICE (BAG_INSERT x b) * a)
</pre>

<DT><span class="strong">GITBAG_INSERT_THM</span>
<DD>
<pre>
⊢ ∀g b x a.
    (AbelianMonoid g ∧ FINITE_BAG b ∧ SET_OF_BAG b ⊆ G) ∧ x ∈ G ∧ a ∈ G ⇒
    GITBAG g (BAG_INSERT x b) a = GITBAG g b (x * a)
</pre>

<DT><span class="strong">GITBAG_THM</span>
<DD>
<pre>
⊢ ∀g b acc.
    FINITE_BAG b ⇒
    GITBAG g b acc =
    if b = {||} then acc else GITBAG g (BAG_REST b) (BAG_CHOICE b * acc)
</pre>

<DT><span class="strong">GITBAG_UNION</span>
<DD>
<pre>
⊢ ∀g. AbelianMonoid g ⇒
      ∀b1.
        FINITE_BAG b1 ⇒
        ∀b2.
          FINITE_BAG b2 ∧ SET_OF_BAG b1 ⊆ G ∧ SET_OF_BAG b2 ⊆ G ⇒
          ∀a. a ∈ G ⇒ GITBAG g (b1 ⊎ b2) a = GITBAG g b2 (GITBAG g b1 a)
</pre>

<DT><span class="strong">GITBAG_in_carrier</span>
<DD>
<pre>
⊢ ∀g. AbelianMonoid g ⇒
      ∀b. FINITE_BAG b ⇒ ∀a. SET_OF_BAG b ⊆ G ∧ a ∈ G ⇒ GITBAG g b a ∈ G
</pre>

<DT><span class="strong">GITBAG_same_op</span>
<DD>
<pre>
⊢ g1.op = g2.op ⇒ ∀b. FINITE_BAG b ⇒ ∀a. GITBAG g1 b a = GITBAG g2 b a
</pre>

<DT><span class="strong">GITSET_EMPTY</span>
<DD>
<pre>
⊢ ∀g b. GITSET g ∅ b = b
</pre>

<DT><span class="strong">GITSET_INSERT</span>
<DD>
<pre>
⊢ ∀s. FINITE s ⇒
      ∀x g b.
        GITSET g (x INSERT s) b =
        GITSET g (REST (x INSERT s)) (CHOICE (x INSERT s) * b)
</pre>

<DT><span class="strong">GITSET_PROPERTY</span>
<DD>
<pre>
⊢ ∀g s. FINITE s ∧ s ≠ ∅ ⇒ ∀b. GITSET g s b = GITSET g (REST s) (CHOICE s * b)
</pre>

<DT><span class="strong">GITSET_THM</span>
<DD>
<pre>
⊢ ∀s g b.
    FINITE s ⇒
    GITSET g s b = if s = ∅ then b else GITSET g (REST s) (CHOICE s * b)
</pre>

<DT><span class="strong">GPROD_SET_EMPTY</span>
<DD>
<pre>
⊢ ∀g s. GPROD_SET g ∅ = #e
</pre>

<DT><span class="strong">GPROD_SET_PROPERTY</span>
<DD>
<pre>
⊢ ∀g s. AbelianMonoid g ∧ FINITE s ∧ s ⊆ G ⇒ GPROD_SET g s ∈ G
</pre>

<DT><span class="strong">GPROD_SET_SING</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ GPROD_SET g {x} = x
</pre>

<DT><span class="strong">GPROD_SET_THM</span>
<DD>
<pre>
⊢ ∀g s.
    GPROD_SET g ∅ = #e ∧
    (AbelianMonoid g ∧ FINITE s ∧ s ⊆ G ⇒
     ∀x::G. GPROD_SET g (x INSERT s) = x * GPROD_SET g (s DELETE x))
</pre>

<DT><span class="strong">IMP_GBAG_EQ_EXP</span>
<DD>
<pre>
⊢ AbelianMonoid g ∧ x ∈ G ∧ SET_OF_BAG b ⊆ {x} ⇒ GBAG g b = x ** b x
</pre>

<DT><span class="strong">IMP_GBAG_EQ_ID</span>
<DD>
<pre>
⊢ AbelianMonoid g ⇒ ∀b. BAG_EVERY ($= #e) b ⇒ GBAG g b = #e
</pre>

<DT><span class="strong">Invertibles_carrier</span>
<DD>
<pre>
⊢ ∀g. (Invertibles g).carrier = G*
</pre>

<DT><span class="strong">Invertibles_order</span>
<DD>
<pre>
⊢ ∀g x. order (Invertibles g) x = ord x
</pre>

<DT><span class="strong">Invertibles_property</span>
<DD>
<pre>
⊢ ∀g. (Invertibles g).carrier = G* ∧ (Invertibles g).op = $* ∧
      (Invertibles g).id = #e ∧ (Invertibles g).exp = $**
</pre>

<DT><span class="strong">Invertibles_subset</span>
<DD>
<pre>
⊢ ∀g. (Invertibles g).carrier ⊆ G
</pre>

<DT><span class="strong">MonoidHomo_GBAG</span>
<DD>
<pre>
⊢ AbelianMonoid g ∧ AbelianMonoid h ∧ MonoidHomo f g h ∧ FINITE_BAG b ∧
  SET_OF_BAG b ⊆ G ⇒
  f (GBAG g b) = GBAG h (BAG_IMAGE f b)
</pre>

<DT><span class="strong">SUBSET_COMMUTING_ITBAG_INSERT</span>
<DD>
<pre>
⊢ ∀f b t.
    SET_OF_BAG b ⊆ t ∧ closure_comm_assoc_fun f t ∧ FINITE_BAG b ⇒
    ∀x a::t. ITBAG f (BAG_INSERT x b) a = ITBAG f b (f x a)
</pre>

<DT><span class="strong">abelian_monoid_op_closure_comm_assoc_fun</span>
<DD>
<pre>
⊢ ∀g. AbelianMonoid g ⇒ closure_comm_assoc_fun $* G
</pre>

<DT><span class="strong">abelian_monoid_order_common</span>
<DD>
<pre>
⊢ ∀g. AbelianMonoid g ⇒
      ∀x y.
        x ∈ G ∧ y ∈ G ⇒
        ∃z. z ∈ G ∧ ord z * gcd (ord x) (ord y) = lcm (ord x) (ord y)
</pre>

<DT><span class="strong">abelian_monoid_order_common_coprime</span>
<DD>
<pre>
⊢ ∀g. AbelianMonoid g ⇒
      ∀x y.
        x ∈ G ∧ y ∈ G ∧ coprime (ord x) (ord y) ⇒
        ∃z. z ∈ G ∧ ord z = ord x * ord y
</pre>

<DT><span class="strong">abelian_monoid_order_lcm</span>
<DD>
<pre>
⊢ ∀g. AbelianMonoid g ⇒
      ∀x y. x ∈ G ∧ y ∈ G ⇒ ∃z. z ∈ G ∧ ord z = lcm (ord x) (ord y)
</pre>

<DT><span class="strong">addition_monoid_abelian_monoid</span>
<DD>
<pre>
⊢ AbelianMonoid addition_monoid
</pre>

<DT><span class="strong">addition_monoid_monoid</span>
<DD>
<pre>
⊢ Monoid addition_monoid
</pre>

<DT><span class="strong">addition_monoid_property</span>
<DD>
<pre>
⊢ addition_monoid.carrier = 𝕌(:num) ∧ addition_monoid.op = $+ ∧
  addition_monoid.id = 0
</pre>

<DT><span class="strong">datatype_monoid</span>
<DD>
<pre>
⊢ DATATYPE (record monoid carrier op id)
</pre>

<DT><span class="strong">extend_carrier</span>
<DD>
<pre>
⊢ (extend m).carrier = 𝕌(:α)
</pre>

<DT><span class="strong">extend_id</span>
<DD>
<pre>
⊢ (extend m).id = m.id
</pre>

<DT><span class="strong">extend_is_monoid</span>
<DD>
<pre>
⊢ ∀m. Monoid m ⇒ Monoid (extend m)
</pre>

<DT><span class="strong">extend_op</span>
<DD>
<pre>
⊢ x ∈ m.carrier ∧ y ∈ m.carrier ⇒ (extend m).op x y = m.op x y
</pre>

<DT><span class="strong">finite_monoid_exp_not_distinct</span>
<DD>
<pre>
⊢ ∀g. FiniteMonoid g ⇒ ∀x. x ∈ G ⇒ ∃h k. x ** h = x ** k ∧ h ≠ k
</pre>

<DT><span class="strong">homo_monoid_I</span>
<DD>
<pre>
⊢ ∀g. MonoidIso I (homo_group g I) g
</pre>

<DT><span class="strong">homo_monoid_abelian_monoid</span>
<DD>
<pre>
⊢ ∀g f.
    AbelianMonoid g ∧ MonoidHomo f g (homo_group g f) ⇒
    AbelianMonoid (homo_group g f)
</pre>

<DT><span class="strong">homo_monoid_assoc</span>
<DD>
<pre>
⊢ ∀g f.
    Monoid g ∧ MonoidHomo f g (homo_group g f) ⇒
    ∀x y z. x ∈ fG ∧ y ∈ fG ∧ z ∈ fG ⇒ (x ∘ y) ∘ z = x ∘ y ∘ z
</pre>

<DT><span class="strong">homo_monoid_by_inj</span>
<DD>
<pre>
⊢ ∀g f. Monoid g ∧ INJ f G 𝕌(:β) ⇒ MonoidHomo f g (homo_group g f)
</pre>

<DT><span class="strong">homo_monoid_closure</span>
<DD>
<pre>
⊢ ∀g f.
    Monoid g ∧ MonoidHomo f g (homo_group g f) ⇒
    ∀x y. x ∈ fG ∧ y ∈ fG ⇒ x ∘ y ∈ fG
</pre>

<DT><span class="strong">homo_monoid_comm</span>
<DD>
<pre>
⊢ ∀g f.
    AbelianMonoid g ∧ MonoidHomo f g (homo_group g f) ⇒
    ∀x y. x ∈ fG ∧ y ∈ fG ⇒ x ∘ y = y ∘ x
</pre>

<DT><span class="strong">homo_monoid_element</span>
<DD>
<pre>
⊢ ∀g f x. x ∈ G ⇒ f x ∈ fG
</pre>

<DT><span class="strong">homo_monoid_id</span>
<DD>
<pre>
⊢ ∀g f. f #e = #i
</pre>

<DT><span class="strong">homo_monoid_id_property</span>
<DD>
<pre>
⊢ ∀g f.
    Monoid g ∧ MonoidHomo f g (homo_group g f) ⇒
    #i ∈ fG ∧ ∀x. x ∈ fG ⇒ #i ∘ x = x ∧ x ∘ #i = x
</pre>

<DT><span class="strong">homo_monoid_monoid</span>
<DD>
<pre>
⊢ ∀g f. Monoid g ∧ MonoidHomo f g (homo_group g f) ⇒ Monoid (homo_group g f)
</pre>

<DT><span class="strong">homo_monoid_op_inj</span>
<DD>
<pre>
⊢ ∀g f. INJ f G 𝕌(:β) ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ f (x * y) = f x ∘ f y
</pre>

<DT><span class="strong">homo_monoid_property</span>
<DD>
<pre>
⊢ ∀g f.
    fG = IMAGE f G ∧
    (∀x y.
       x ∈ fG ∧ y ∈ fG ⇒
       x ∘ y = f (CHOICE (preimage f G x) * CHOICE (preimage f G y))) ∧
    #i = f #e
</pre>

<DT><span class="strong">image_op_inj</span>
<DD>
<pre>
⊢ ∀g f.
    INJ f G 𝕌(:β) ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ image_op g f (f x) (f y) = f (x * y)
</pre>

<DT><span class="strong">lists_monoid</span>
<DD>
<pre>
⊢ Monoid lists
</pre>

<DT><span class="strong">maximal_order_alt</span>
<DD>
<pre>
⊢ ∀g. maximal_order g = MAX_SET {ord z | z | z ∈ G}
</pre>

<DT><span class="strong">monoid_11</span>
<DD>
<pre>
⊢ ∀a0 a1 a2 a0' a1' a2'.
    monoid a0 a1 a2 = monoid a0' a1' a2' ⇔ a0 = a0' ∧ a1 = a1' ∧ a2 = a2'
</pre>

<DT><span class="strong">monoid_Axiom</span>
<DD>
<pre>
⊢ ∀f. ∃fn. ∀a0 a1 a2. fn (monoid a0 a1 a2) = f a0 a1 a2
</pre>

<DT><span class="strong">monoid_accessors</span>
<DD>
<pre>
⊢ (∀f f0 a. (monoid f f0 a).carrier = f) ∧
  (∀f f0 a. (monoid f f0 a).op = f0) ∧ ∀f f0 a. (monoid f f0 a).id = a
</pre>

<DT><span class="strong">monoid_accfupds</span>
<DD>
<pre>
⊢ (∀m f. (m with op updated_by f).carrier = m.carrier) ∧
  (∀m f. (m with id updated_by f).carrier = m.carrier) ∧
  (∀m f. (m with carrier updated_by f).op = m.op) ∧
  (∀m f. (m with id updated_by f).op = m.op) ∧
  (∀m f. (m with carrier updated_by f).id = m.id) ∧
  (∀m f. (m with op updated_by f).id = m.id) ∧
  (∀m f. (m with carrier updated_by f).carrier = f m.carrier) ∧
  (∀m f. (m with op updated_by f).op = f m.op) ∧
  ∀m f. (m with id updated_by f).id = f m.id
</pre>

<DT><span class="strong">monoid_assoc</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀x y z. x ∈ G ∧ y ∈ G ∧ z ∈ G ⇒ x * y * z = x * (y * z)
</pre>

<DT><span class="strong">monoid_auto_I</span>
<DD>
<pre>
⊢ ∀g. MonoidAuto I g
</pre>

<DT><span class="strong">monoid_auto_bij</span>
<DD>
<pre>
⊢ ∀g f. MonoidAuto f g ⇒ f PERMUTES G
</pre>

<DT><span class="strong">monoid_auto_compose</span>
<DD>
<pre>
⊢ ∀g f1 f2. MonoidAuto f1 g ∧ MonoidAuto f2 g ⇒ MonoidAuto (f1 ∘ f2) g
</pre>

<DT><span class="strong">monoid_auto_element</span>
<DD>
<pre>
⊢ ∀f g. MonoidAuto f g ⇒ ∀x. x ∈ G ⇒ f x ∈ G
</pre>

<DT><span class="strong">monoid_auto_exp</span>
<DD>
<pre>
⊢ ∀f g. Monoid g ∧ MonoidAuto f g ⇒ ∀x. x ∈ G ⇒ ∀n. f (x ** n) = f x ** n
</pre>

<DT><span class="strong">monoid_auto_id</span>
<DD>
<pre>
⊢ ∀f g. MonoidAuto f g ⇒ f #e = #e
</pre>

<DT><span class="strong">monoid_auto_linv_auto</span>
<DD>
<pre>
⊢ ∀g f. Monoid g ∧ MonoidAuto f g ⇒ MonoidAuto (LINV f G) g
</pre>

<DT><span class="strong">monoid_auto_order</span>
<DD>
<pre>
⊢ ∀g f. Monoid g ∧ MonoidAuto f g ⇒ ∀x. x ∈ G ⇒ ord (f x) = ord x
</pre>

<DT><span class="strong">monoid_carrier_nonempty</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ G ≠ ∅
</pre>

<DT><span class="strong">monoid_case_cong</span>
<DD>
<pre>
⊢ ∀M M' f.
    M = M' ∧ (∀a0 a1 a2. M' = monoid a0 a1 a2 ⇒ f a0 a1 a2 = f' a0 a1 a2) ⇒
    monoid_CASE M f = monoid_CASE M' f'
</pre>

<DT><span class="strong">monoid_case_eq</span>
<DD>
<pre>
⊢ monoid_CASE x f = v ⇔ ∃f' f0 a. x = monoid f' f0 a ∧ f f' f0 a = v
</pre>

<DT><span class="strong">monoid_comm_exp</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒
      ∀x y. x ∈ G ∧ y ∈ G ⇒ x * y = y * x ⇒ ∀n. x ** n * y = y * x ** n
</pre>

<DT><span class="strong">monoid_comm_exp_exp</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒
      ∀x y.
        x ∈ G ∧ y ∈ G ∧ x * y = y * x ⇒
        ∀n m. x ** n * y ** m = y ** m * x ** n
</pre>

<DT><span class="strong">monoid_comm_op_exp</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒
      ∀x y. x ∈ G ∧ y ∈ G ∧ x * y = y * x ⇒ ∀n. (x * y) ** n = x ** n * y ** n
</pre>

<DT><span class="strong">monoid_component_equality</span>
<DD>
<pre>
⊢ ∀m1 m2. m1 = m2 ⇔ m1.carrier = m2.carrier ∧ m1.op = m2.op ∧ m1.id = m2.id
</pre>

<DT><span class="strong">monoid_exp_0</span>
<DD>
<pre>
⊢ ∀g x. x ** 0 = #e
</pre>

<DT><span class="strong">monoid_exp_1</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ x ** 1 = x
</pre>

<DT><span class="strong">monoid_exp_SUC</span>
<DD>
<pre>
⊢ ∀g x n. x ** SUC n = x * x ** n
</pre>

<DT><span class="strong">monoid_exp_add</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ ∀n k. x ** (n + k) = x ** n * x ** k
</pre>

<DT><span class="strong">monoid_exp_comm</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ ∀n. x ** n * x = x * x ** n
</pre>

<DT><span class="strong">monoid_exp_element</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ ∀n. x ** n ∈ G
</pre>

<DT><span class="strong">monoid_exp_mod_order</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ∧ 0 < ord x ⇒ ∀n. x ** n = x ** (n MOD ord x)
</pre>

<DT><span class="strong">monoid_exp_mult</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ ∀n k. x ** (n * k) = (x ** n) ** k
</pre>

<DT><span class="strong">monoid_exp_mult_comm</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ ∀m n. (x ** m) ** n = (x ** n) ** m
</pre>

<DT><span class="strong">monoid_exp_suc</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ ∀n. x ** SUC n = x ** n * x
</pre>

<DT><span class="strong">monoid_fn_updates</span>
<DD>
<pre>
⊢ (∀f1 f f0 a. monoid f f0 a with carrier updated_by f1 = monoid (f1 f) f0 a) ∧
  (∀f1 f f0 a. monoid f f0 a with op updated_by f1 = monoid f (f1 f0) a) ∧
  ∀f1 f f0 a. monoid f f0 a with id updated_by f1 = monoid f f0 (f1 a)
</pre>

<DT><span class="strong">monoid_fupdcanon</span>
<DD>
<pre>
⊢ (∀m g f.
     m with <|op updated_by f; carrier updated_by g|> =
     m with <|carrier updated_by g; op updated_by f|>) ∧
  (∀m g f.
     m with <|id updated_by f; carrier updated_by g|> =
     m with <|carrier updated_by g; id updated_by f|>) ∧
  ∀m g f.
    m with <|id updated_by f; op updated_by g|> =
    m with <|op updated_by g; id updated_by f|>
</pre>

<DT><span class="strong">monoid_fupdcanon_comp</span>
<DD>
<pre>
⊢ ((∀g f. op_fupd f ∘ carrier_fupd g = carrier_fupd g ∘ op_fupd f) ∧
   ∀h g f. op_fupd f ∘ carrier_fupd g ∘ h = carrier_fupd g ∘ op_fupd f ∘ h) ∧
  ((∀g f. id_fupd f ∘ carrier_fupd g = carrier_fupd g ∘ id_fupd f) ∧
   ∀h g f. id_fupd f ∘ carrier_fupd g ∘ h = carrier_fupd g ∘ id_fupd f ∘ h) ∧
  (∀g f. id_fupd f ∘ op_fupd g = op_fupd g ∘ id_fupd f) ∧
  ∀h g f. id_fupd f ∘ op_fupd g ∘ h = op_fupd g ∘ id_fupd f ∘ h
</pre>

<DT><span class="strong">monoid_fupdfupds</span>
<DD>
<pre>
⊢ (∀m g f.
     m with <|carrier updated_by f; carrier updated_by g|> =
     m with carrier updated_by f ∘ g) ∧
  (∀m g f.
     m with <|op updated_by f; op updated_by g|> = m with op updated_by f ∘ g) ∧
  ∀m g f.
    m with <|id updated_by f; id updated_by g|> = m with id updated_by f ∘ g
</pre>

<DT><span class="strong">monoid_fupdfupds_comp</span>
<DD>
<pre>
⊢ ((∀g f. carrier_fupd f ∘ carrier_fupd g = carrier_fupd (f ∘ g)) ∧
   ∀h g f. carrier_fupd f ∘ carrier_fupd g ∘ h = carrier_fupd (f ∘ g) ∘ h) ∧
  ((∀g f. op_fupd f ∘ op_fupd g = op_fupd (f ∘ g)) ∧
   ∀h g f. op_fupd f ∘ op_fupd g ∘ h = op_fupd (f ∘ g) ∘ h) ∧
  (∀g f. id_fupd f ∘ id_fupd g = id_fupd (f ∘ g)) ∧
  ∀h g f. id_fupd f ∘ id_fupd g ∘ h = id_fupd (f ∘ g) ∘ h
</pre>

<DT><span class="strong">monoid_homo_I_refl</span>
<DD>
<pre>
⊢ ∀g. MonoidHomo I g g
</pre>

<DT><span class="strong">monoid_homo_compose</span>
<DD>
<pre>
⊢ ∀g h k f1 f2.
    MonoidHomo f1 g h ∧ MonoidHomo f2 h k ⇒ MonoidHomo (f2 ∘ f1) g k
</pre>

<DT><span class="strong">monoid_homo_cong</span>
<DD>
<pre>
⊢ ∀g h f1 f2.
    Monoid g ∧ Monoid h ∧ (∀x. x ∈ G ⇒ f1 x = f2 x) ⇒
    (MonoidHomo f1 g h ⇔ MonoidHomo f2 g h)
</pre>

<DT><span class="strong">monoid_homo_element</span>
<DD>
<pre>
⊢ ∀f g h. MonoidHomo f g h ⇒ ∀x. x ∈ G ⇒ f x ∈ h.carrier
</pre>

<DT><span class="strong">monoid_homo_exp</span>
<DD>
<pre>
⊢ ∀g h f.
    Monoid g ∧ MonoidHomo f g h ⇒ ∀x. x ∈ G ⇒ ∀n. f (x ** n) = h.exp (f x) n
</pre>

<DT><span class="strong">monoid_homo_id</span>
<DD>
<pre>
⊢ ∀f g h. MonoidHomo f g h ⇒ f #e = h.id
</pre>

<DT><span class="strong">monoid_homo_sym</span>
<DD>
<pre>
⊢ ∀g h f.
    Monoid g ∧ MonoidHomo f g h ∧ BIJ f G h.carrier ⇒
    MonoidHomo (LINV f G) h g
</pre>

<DT><span class="strong">monoid_homo_sym_any</span>
<DD>
<pre>
⊢ Monoid g ∧ MonoidHomo f g h ∧ (∀x. x ∈ h.carrier ⇒ i x ∈ G ∧ f (i x) = x) ∧
  (∀x. x ∈ G ⇒ i (f x) = x) ⇒
  MonoidHomo i h g
</pre>

<DT><span class="strong">monoid_homo_trans</span>
<DD>
<pre>
⊢ ∀g h k f1 f2.
    MonoidHomo f1 g h ∧ MonoidHomo f2 h k ⇒ MonoidHomo (f2 ∘ f1) g k
</pre>

<DT><span class="strong">monoid_id</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ #e * x = x ∧ x * #e = x
</pre>

<DT><span class="strong">monoid_id_element</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ #e ∈ G
</pre>

<DT><span class="strong">monoid_id_exp</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀n. #e ** n = #e
</pre>

<DT><span class="strong">monoid_id_id</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ #e * #e = #e
</pre>

<DT><span class="strong">monoid_id_invertible</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ #e ∈ G*
</pre>

<DT><span class="strong">monoid_id_unique</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀e. e ∈ G ⇒ ((∀x. x ∈ G ⇒ x * e = x ∧ e * x = x) ⇔ e = #e)
</pre>

<DT><span class="strong">monoid_induction</span>
<DD>
<pre>
⊢ ∀P. (∀f f0 a. P (monoid f f0 a)) ⇒ ∀m. P m
</pre>

<DT><span class="strong">monoid_inj_image_abelian_monoid</span>
<DD>
<pre>
⊢ ∀g f. AbelianMonoid g ∧ INJ f G 𝕌(:β) ⇒ AbelianMonoid (monoid_inj_image g f)
</pre>

<DT><span class="strong">monoid_inj_image_monoid</span>
<DD>
<pre>
⊢ ∀g f. Monoid g ∧ INJ f G 𝕌(:β) ⇒ Monoid (monoid_inj_image g f)
</pre>

<DT><span class="strong">monoid_inj_image_monoid_homo</span>
<DD>
<pre>
⊢ ∀g f. INJ f G 𝕌(:β) ⇒ MonoidHomo f g (monoid_inj_image g f)
</pre>

<DT><span class="strong">monoid_intersect_element</span>
<DD>
<pre>
⊢ ∀g h x. x ∈ (g mINTER h).carrier ⇒ x ∈ G ∧ x ∈ H
</pre>

<DT><span class="strong">monoid_intersect_id</span>
<DD>
<pre>
⊢ ∀g h. (g mINTER h).id = #e
</pre>

<DT><span class="strong">monoid_intersect_property</span>
<DD>
<pre>
⊢ ∀g h.
    (g mINTER h).carrier = G ∩ H ∧ (g mINTER h).op = $* ∧ (g mINTER h).id = #e
</pre>

<DT><span class="strong">monoid_inv_def_alt</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G* ⇔ x ∈ G ∧ |/ x ∈ G ∧ x * |/ x = #e ∧ |/ x * x = #e
</pre>

<DT><span class="strong">monoid_inv_element</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G* ⇒ x ∈ G
</pre>

<DT><span class="strong">monoid_inv_from_invertibles</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G* ⇒ ∃y. y ∈ G ∧ x * y = #e ∧ y * x = #e
</pre>

<DT><span class="strong">monoid_inv_invertible</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G* ⇒ |/ x ∈ G*
</pre>

<DT><span class="strong">monoid_inv_op_invertible</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀x y. x ∈ G* ∧ y ∈ G* ⇒ x * y ∈ G*
</pre>

<DT><span class="strong">monoid_invertibles_element</span>
<DD>
<pre>
⊢ ∀g x. x ∈ G* ⇔ x ∈ G ∧ ∃y. y ∈ G ∧ x * y = #e ∧ y * x = #e
</pre>

<DT><span class="strong">monoid_invertibles_is_monoid</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ Monoid (Invertibles g)
</pre>

<DT><span class="strong">monoid_iso_I_refl</span>
<DD>
<pre>
⊢ ∀g. MonoidIso I g g
</pre>

<DT><span class="strong">monoid_iso_bij</span>
<DD>
<pre>
⊢ ∀g h f. MonoidIso f g h ⇒ BIJ f G h.carrier
</pre>

<DT><span class="strong">monoid_iso_card_eq</span>
<DD>
<pre>
⊢ ∀g h f. MonoidIso f g h ∧ FINITE G ⇒ CARD G = CARD h.carrier
</pre>

<DT><span class="strong">monoid_iso_compose</span>
<DD>
<pre>
⊢ ∀g h k f1 f2. MonoidIso f1 g h ∧ MonoidIso f2 h k ⇒ MonoidIso (f2 ∘ f1) g k
</pre>

<DT><span class="strong">monoid_iso_element</span>
<DD>
<pre>
⊢ ∀f g h. MonoidIso f g h ⇒ ∀x. x ∈ G ⇒ f x ∈ h.carrier
</pre>

<DT><span class="strong">monoid_iso_eq_id</span>
<DD>
<pre>
⊢ ∀g h f.
    Monoid g ∧ Monoid h ∧ MonoidIso f g h ⇒ ∀x. x ∈ G ⇒ (f x = h.id ⇔ x = #e)
</pre>

<DT><span class="strong">monoid_iso_exp</span>
<DD>
<pre>
⊢ ∀g h f.
    Monoid g ∧ MonoidIso f g h ⇒ ∀x. x ∈ G ⇒ ∀n. f (x ** n) = h.exp (f x) n
</pre>

<DT><span class="strong">monoid_iso_id</span>
<DD>
<pre>
⊢ ∀f g h. MonoidIso f g h ⇒ f #e = h.id
</pre>

<DT><span class="strong">monoid_iso_linv_iso</span>
<DD>
<pre>
⊢ ∀g h f. Monoid g ∧ MonoidIso f g h ⇒ MonoidIso (LINV f G) h g
</pre>

<DT><span class="strong">monoid_iso_monoid</span>
<DD>
<pre>
⊢ ∀g h f. Monoid g ∧ MonoidIso f g h ⇒ Monoid h
</pre>

<DT><span class="strong">monoid_iso_order</span>
<DD>
<pre>
⊢ ∀g h f.
    Monoid g ∧ Monoid h ∧ MonoidIso f g h ⇒ ∀x. x ∈ G ⇒ order h (f x) = ord x
</pre>

<DT><span class="strong">monoid_iso_property</span>
<DD>
<pre>
⊢ ∀f g h.
    MonoidIso f g h ⇔
    MonoidHomo f g h ∧ ∀y. y ∈ h.carrier ⇒ ∃!x. x ∈ G ∧ f x = y
</pre>

<DT><span class="strong">monoid_iso_sym</span>
<DD>
<pre>
⊢ ∀g h f. Monoid g ∧ MonoidIso f g h ⇒ MonoidIso (LINV f G) h g
</pre>

<DT><span class="strong">monoid_iso_trans</span>
<DD>
<pre>
⊢ ∀g h k f1 f2. MonoidIso f1 g h ∧ MonoidIso f2 h k ⇒ MonoidIso (f2 ∘ f1) g k
</pre>

<DT><span class="strong">monoid_lid</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ #e * x = x
</pre>

<DT><span class="strong">monoid_lid_unique</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀e. e ∈ G ⇒ (∀x. x ∈ G ⇒ e * x = x) ⇒ e = #e
</pre>

<DT><span class="strong">monoid_literal_11</span>
<DD>
<pre>
⊢ ∀f01 f1 a1 f02 f2 a2.
    <|carrier := f01; op := f1; id := a1|> =
    <|carrier := f02; op := f2; id := a2|> ⇔ f01 = f02 ∧ f1 = f2 ∧ a1 = a2
</pre>

<DT><span class="strong">monoid_literal_nchotomy</span>
<DD>
<pre>
⊢ ∀m. ∃f0 f a. m = <|carrier := f0; op := f; id := a|>
</pre>

<DT><span class="strong">monoid_nchotomy</span>
<DD>
<pre>
⊢ ∀mm. ∃f f0 a. mm = monoid f f0 a
</pre>

<DT><span class="strong">monoid_op_element</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ x * y ∈ G
</pre>

<DT><span class="strong">monoid_order_cofactor</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒
      ∀x n. x ∈ G ∧ 0 < ord x ∧ n divides ord x ⇒ ord (x ** (ord x DIV n)) = n
</pre>

<DT><span class="strong">monoid_order_common</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒
      ∀x y.
        x ∈ G ∧ y ∈ G ∧ x * y = y * x ⇒
        ∃z. z ∈ G ∧ ord z * gcd (ord x) (ord y) = lcm (ord x) (ord y)
</pre>

<DT><span class="strong">monoid_order_common_coprime</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒
      ∀x y.
        x ∈ G ∧ y ∈ G ∧ x * y = y * x ∧ coprime (ord x) (ord y) ⇒
        ∃z. z ∈ G ∧ ord z = ord x * ord y
</pre>

<DT><span class="strong">monoid_order_condition</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ ∀m. x ** m = #e ⇔ ord x divides m
</pre>

<DT><span class="strong">monoid_order_divides_exp</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀x n. x ∈ G ⇒ (x ** n = #e ⇔ ord x divides n)
</pre>

<DT><span class="strong">monoid_order_divides_maximal</span>
<DD>
<pre>
⊢ ∀g. FiniteAbelianMonoid g ⇒
      ∀x. x ∈ G ∧ 0 < ord x ⇒ ord x divides maximal_order g
</pre>

<DT><span class="strong">monoid_order_divisor</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒
      ∀x m. x ∈ G ∧ 0 < ord x ∧ m divides ord x ⇒ ∃y. y ∈ G ∧ ord y = m
</pre>

<DT><span class="strong">monoid_order_eq_1</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ (ord x = 1 ⇔ x = #e)
</pre>

<DT><span class="strong">monoid_order_id</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ord #e = 1
</pre>

<DT><span class="strong">monoid_order_nonzero</span>
<DD>
<pre>
⊢ ∀g x. Monoid g ∧ x ∈ G ∧ 0 < ord x ⇒ x ∈ G*
</pre>

<DT><span class="strong">monoid_order_power</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ ∀k. ord (x ** k) * gcd (ord x) k = ord x
</pre>

<DT><span class="strong">monoid_order_power_coprime</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ ∀n. coprime n (ord x) ⇒ ord (x ** n) = ord x
</pre>

<DT><span class="strong">monoid_order_power_eq_0</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ ∀k. ord (x ** k) = 0 ⇔ 0 < k ∧ ord x = 0
</pre>

<DT><span class="strong">monoid_order_power_eqn</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀x k. x ∈ G ∧ 0 < k ⇒ ord (x ** k) = ord x DIV gcd k (ord x)
</pre>

<DT><span class="strong">monoid_rid</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀x. x ∈ G ⇒ x * #e = x
</pre>

<DT><span class="strong">monoid_rid_unique</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀e. e ∈ G ⇒ (∀x. x ∈ G ⇒ x * e = x) ⇒ e = #e
</pre>

<DT><span class="strong">monoid_updates_eq_literal</span>
<DD>
<pre>
⊢ ∀m f0 f a.
    m with <|carrier := f0; op := f; id := a|> =
    <|carrier := f0; op := f; id := a|>
</pre>

<DT><span class="strong">monoid_weak_iso_id</span>
<DD>
<pre>
⊢ ∀f g h. Monoid g ∧ Monoid h ∧ WeakIso f g h ⇒ f #e = h.id
</pre>

<DT><span class="strong">multiplication_monoid_abelian_monoid</span>
<DD>
<pre>
⊢ AbelianMonoid multiplication_monoid
</pre>

<DT><span class="strong">multiplication_monoid_monoid</span>
<DD>
<pre>
⊢ Monoid multiplication_monoid
</pre>

<DT><span class="strong">multiplication_monoid_property</span>
<DD>
<pre>
⊢ multiplication_monoid.carrier = 𝕌(:num) ∧ multiplication_monoid.op = $* ∧
  multiplication_monoid.id = 1
</pre>

<DT><span class="strong">order_alt</span>
<DD>
<pre>
⊢ ∀g x. ord x = case OLEAST k. 0 < k ∧ x ** k = #e of NONE => 0 | SOME k => k
</pre>

<DT><span class="strong">order_eq_0</span>
<DD>
<pre>
⊢ ∀g x. ord x = 0 ⇔ ∀n. 0 < n ⇒ x ** n ≠ #e
</pre>

<DT><span class="strong">order_minimal</span>
<DD>
<pre>
⊢ ∀g x n. 0 < n ∧ n < ord x ⇒ x ** n ≠ #e
</pre>

<DT><span class="strong">order_period</span>
<DD>
<pre>
⊢ ∀g x. 0 < ord x ⇒ period g x (ord x)
</pre>

<DT><span class="strong">order_property</span>
<DD>
<pre>
⊢ ∀g x. x ** ord x = #e
</pre>

<DT><span class="strong">order_thm</span>
<DD>
<pre>
⊢ ∀g x n. 0 < n ⇒ (ord x = n ⇔ x ** n = #e ∧ ∀m. 0 < m ∧ m < n ⇒ x ** m ≠ #e)
</pre>

<DT><span class="strong">orders_element</span>
<DD>
<pre>
⊢ ∀g x n. x ∈ orders g n ⇔ x ∈ G ∧ ord x = n
</pre>

<DT><span class="strong">orders_eq_1</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ orders g 1 = {#e}
</pre>

<DT><span class="strong">orders_finite</span>
<DD>
<pre>
⊢ ∀g. FINITE G ⇒ ∀n. FINITE (orders g n)
</pre>

<DT><span class="strong">orders_subset</span>
<DD>
<pre>
⊢ ∀g n. orders g n ⊆ G
</pre>

<DT><span class="strong">plus_mod_abelian_monoid</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ AbelianMonoid (plus_mod n)
</pre>

<DT><span class="strong">plus_mod_exp</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ ∀x k. (plus_mod n).exp x k = (k * x) MOD n
</pre>

<DT><span class="strong">plus_mod_finite</span>
<DD>
<pre>
⊢ ∀n. FINITE (plus_mod n).carrier
</pre>

<DT><span class="strong">plus_mod_finite_abelian_monoid</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ FiniteAbelianMonoid (plus_mod n)
</pre>

<DT><span class="strong">plus_mod_finite_monoid</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ FiniteMonoid (plus_mod n)
</pre>

<DT><span class="strong">plus_mod_monoid</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ Monoid (plus_mod n)
</pre>

<DT><span class="strong">plus_mod_property</span>
<DD>
<pre>
⊢ ∀n. (plus_mod n).carrier = count n ∧
      (plus_mod n).op = (λi j. (i + j) MOD n) ∧ (plus_mod n).id = 0 ∧
      (∀x. x ∈ (plus_mod n).carrier ⇒ x < n) ∧ FINITE (plus_mod n).carrier ∧
      CARD (plus_mod n).carrier = n
</pre>

<DT><span class="strong">power_monoid_abelian_monoid</span>
<DD>
<pre>
⊢ ∀b. AbelianMonoid (power_monoid b)
</pre>

<DT><span class="strong">power_monoid_monoid</span>
<DD>
<pre>
⊢ ∀b. Monoid (power_monoid b)
</pre>

<DT><span class="strong">power_monoid_property</span>
<DD>
<pre>
⊢ ∀b. (power_monoid b).carrier = {b ** j | j ∈ 𝕌(:num)} ∧
      (power_monoid b).op = $* ∧ (power_monoid b).id = 1
</pre>

<DT><span class="strong">power_to_addition_homo</span>
<DD>
<pre>
⊢ ∀b. 1 < b ⇒ MonoidHomo (LOG b) (power_monoid b) addition_monoid
</pre>

<DT><span class="strong">power_to_addition_iso</span>
<DD>
<pre>
⊢ ∀b. 1 < b ⇒ MonoidIso (LOG b) (power_monoid b) addition_monoid
</pre>

<DT><span class="strong">set_inter_abelian_monoid</span>
<DD>
<pre>
⊢ AbelianMonoid set_inter
</pre>

<DT><span class="strong">set_inter_monoid</span>
<DD>
<pre>
⊢ Monoid set_inter
</pre>

<DT><span class="strong">set_union_abelian_monoid</span>
<DD>
<pre>
⊢ AbelianMonoid set_union
</pre>

<DT><span class="strong">set_union_monoid</span>
<DD>
<pre>
⊢ Monoid set_union
</pre>

<DT><span class="strong">submonoid_I_antisym</span>
<DD>
<pre>
⊢ ∀g h. submonoid h g ∧ submonoid g h ⇒ MonoidIso I h g
</pre>

<DT><span class="strong">submonoid_alt</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒
      ∀h. h << g ⇔
          H ⊆ G ∧ (∀x y. x ∈ H ∧ y ∈ H ⇒ h.op x y ∈ H) ∧ h.id ∈ H ∧
          h.op = $* ∧ h.id = #e
</pre>

<DT><span class="strong">submonoid_antisymmetric</span>
<DD>
<pre>
⊢ ∀g h. h << g ∧ g << h ⇒ h = g
</pre>

<DT><span class="strong">submonoid_big_intersect_element</span>
<DD>
<pre>
⊢ ∀g x. x ∈ (smbINTER g).carrier ⇔ ∀h. h << g ⇒ x ∈ H
</pre>

<DT><span class="strong">submonoid_big_intersect_has_id</span>
<DD>
<pre>
⊢ ∀g. (smbINTER g).id ∈ (smbINTER g).carrier
</pre>

<DT><span class="strong">submonoid_big_intersect_monoid</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ Monoid (smbINTER g)
</pre>

<DT><span class="strong">submonoid_big_intersect_op_element</span>
<DD>
<pre>
⊢ ∀g x y.
    x ∈ (smbINTER g).carrier ∧ y ∈ (smbINTER g).carrier ⇒
    (smbINTER g).op x y ∈ (smbINTER g).carrier
</pre>

<DT><span class="strong">submonoid_big_intersect_property</span>
<DD>
<pre>
⊢ ∀g. (smbINTER g).carrier = BIGINTER (IMAGE (λh. H) {h | h << g}) ∧
      (∀x y.
         x ∈ (smbINTER g).carrier ∧ y ∈ (smbINTER g).carrier ⇒
         (smbINTER g).op x y = x * y) ∧ (smbINTER g).id = #e
</pre>

<DT><span class="strong">submonoid_big_intersect_submonoid</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ smbINTER g << g
</pre>

<DT><span class="strong">submonoid_big_intersect_subset</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ (smbINTER g).carrier ⊆ G
</pre>

<DT><span class="strong">submonoid_carrier_antisym</span>
<DD>
<pre>
⊢ ∀g h. submonoid h g ∧ G ⊆ H ⇒ MonoidIso I h g
</pre>

<DT><span class="strong">submonoid_carrier_subset</span>
<DD>
<pre>
⊢ ∀g h. h << g ⇒ H ⊆ G
</pre>

<DT><span class="strong">submonoid_element</span>
<DD>
<pre>
⊢ ∀g h. h << g ⇒ ∀x. x ∈ H ⇒ x ∈ G
</pre>

<DT><span class="strong">submonoid_eqn</span>
<DD>
<pre>
⊢ ∀g h.
    submonoid h g ⇔
    H ⊆ G ∧ (∀x y. x ∈ H ∧ y ∈ H ⇒ h.op x y = x * y) ∧ h.id = #e
</pre>

<DT><span class="strong">submonoid_exp</span>
<DD>
<pre>
⊢ ∀g h. h << g ⇒ ∀x. x ∈ H ⇒ ∀n. h.exp x n = x ** n
</pre>

<DT><span class="strong">submonoid_homo_homo</span>
<DD>
<pre>
⊢ ∀g h k f. submonoid h g ∧ MonoidHomo f g k ⇒ MonoidHomo f h k
</pre>

<DT><span class="strong">submonoid_homomorphism</span>
<DD>
<pre>
⊢ ∀g h. h << g ⇒ Monoid h ∧ Monoid g ∧ submonoid h g
</pre>

<DT><span class="strong">submonoid_id</span>
<DD>
<pre>
⊢ ∀g h. h << g ⇒ h.id = #e
</pre>

<DT><span class="strong">submonoid_intersect_monoid</span>
<DD>
<pre>
⊢ ∀g h k. h << g ∧ k << g ⇒ Monoid (h mINTER k)
</pre>

<DT><span class="strong">submonoid_intersect_property</span>
<DD>
<pre>
⊢ ∀g h k.
    h << g ∧ k << g ⇒
    (h mINTER k).carrier = H ∩ k.carrier ∧
    (∀x y. x ∈ H ∩ k.carrier ∧ y ∈ H ∩ k.carrier ⇒ (h mINTER k).op x y = x * y) ∧
    (h mINTER k).id = #e
</pre>

<DT><span class="strong">submonoid_intersect_submonoid</span>
<DD>
<pre>
⊢ ∀g h k. h << g ∧ k << g ⇒ (h mINTER k) << g
</pre>

<DT><span class="strong">submonoid_monoid</span>
<DD>
<pre>
⊢ ∀g h. h << g ⇒ Monoid h
</pre>

<DT><span class="strong">submonoid_op</span>
<DD>
<pre>
⊢ ∀g h. h << g ⇒ h.op = $*
</pre>

<DT><span class="strong">submonoid_order</span>
<DD>
<pre>
⊢ ∀g h. h << g ⇒ ∀x. x ∈ H ⇒ order h x = ord x
</pre>

<DT><span class="strong">submonoid_order_eqn</span>
<DD>
<pre>
⊢ ∀g h. Monoid g ∧ Monoid h ∧ submonoid h g ⇒ ∀x. x ∈ H ⇒ order h x = ord x
</pre>

<DT><span class="strong">submonoid_property</span>
<DD>
<pre>
⊢ ∀g h.
    h << g ⇒
    Monoid h ∧ Monoid g ∧ H ⊆ G ∧ (∀x y. x ∈ H ∧ y ∈ H ⇒ h.op x y = x * y) ∧
    h.id = #e
</pre>

<DT><span class="strong">submonoid_refl</span>
<DD>
<pre>
⊢ ∀g. submonoid g g
</pre>

<DT><span class="strong">submonoid_reflexive</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ g << g
</pre>

<DT><span class="strong">submonoid_subset</span>
<DD>
<pre>
⊢ ∀g h. submonoid h g ⇒ H ⊆ G
</pre>

<DT><span class="strong">submonoid_trans</span>
<DD>
<pre>
⊢ ∀g h k. submonoid g h ∧ submonoid h k ⇒ submonoid g k
</pre>

<DT><span class="strong">submonoid_transitive</span>
<DD>
<pre>
⊢ ∀g h k. k << h ∧ h << g ⇒ k << g
</pre>

<DT><span class="strong">times_mod_abelian_monoid</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ AbelianMonoid (times_mod n)
</pre>

<DT><span class="strong">times_mod_eval</span>
<DD>
<pre>
⊢ ∀n. (times_mod n).carrier = count n ∧
      (∀x y. (times_mod n).op x y = (x * y) MOD n) ∧
      (times_mod n).id = if n = 1 then 0 else 1
</pre>

<DT><span class="strong">times_mod_exp</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ ∀x k. (times_mod n).exp x k = (x MOD n) ** k MOD n
</pre>

<DT><span class="strong">times_mod_finite</span>
<DD>
<pre>
⊢ ∀n. FINITE (times_mod n).carrier
</pre>

<DT><span class="strong">times_mod_finite_abelian_monoid</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ FiniteAbelianMonoid (times_mod n)
</pre>

<DT><span class="strong">times_mod_finite_monoid</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ FiniteMonoid (times_mod n)
</pre>

<DT><span class="strong">times_mod_monoid</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ Monoid (times_mod n)
</pre>

<DT><span class="strong">times_mod_property</span>
<DD>
<pre>
⊢ ∀n. (times_mod n).carrier = count n ∧
      (times_mod n).op = (λi j. (i * j) MOD n) ∧
      (times_mod n).id = (if n = 1 then 0 else 1) ∧
      (∀x. x ∈ (times_mod n).carrier ⇒ x < n) ∧ FINITE (times_mod n).carrier ∧
      CARD (times_mod n).carrier = n
</pre>

<DT><span class="strong">trivial_monoid</span>
<DD>
<pre>
⊢ ∀e. FiniteAbelianMonoid (trivial_monoid e)
</pre>

</DL>



<hr>
</body>
</html>
