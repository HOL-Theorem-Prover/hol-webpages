<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: combinatorics</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "combinatorics"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "numberTheory.html"><span class="strong">number</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Type <th> Arity<tr><td>
    <span class="strong">triple</span>
    <td>
    0
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">DILATE</span>
    <td>
    :Œ± -> num -> num -> Œ± list -> Œ± list
    <tr><td>
    <span class="strong">MAP3</span>
    <td>
    :(Œ≤ -> Œ≥ -> Œ¥ -> Œ±) -> Œ≤ list -> Œ≥ list -> Œ¥ list -> Œ± list
    <tr><td>
    <span class="strong">MDILATE</span>
    <td>
    :Œ± -> num -> Œ± list -> Œ± list
    <tr><td> <span class="strong">PROD</span> <td> :num list -> num
    <tr><td> <span class="strong">PROD_ACC</span> <td> :num list -> num -> num
    <tr><td> <span class="strong">arrange</span> <td> :num -> num -> num
    <tr><td> <span class="strong">binomial</span> <td> :num -> num -> num
    <tr><td> <span class="strong">choose</span> <td> :num -> num -> num
    <tr><td>
    <span class="strong">interleave</span>
    <td>
    :Œ± -> Œ± list -> Œ± list -> bool
    <tr><td> <span class="strong">lcm_upto</span> <td> :num -> num
    <tr><td> <span class="strong">leibniz</span> <td> :num -> num -> num
    <tr><td>
    <span class="strong">leibniz_zigzag</span>
    <td>
    :num list -> num list -> bool
    <tr><td>
    <span class="strong">list_count</span>
    <td>
    :num -> num -> num list -> bool
    <tr><td> <span class="strong">list_lcm</span> <td> :num list -> num
    <tr><td>
    <span class="strong">monocoloured</span>
    <td>
    :num -> num -> num list -> bool
    <tr><td>
    <span class="strong">multicoloured</span>
    <td>
    :num -> num -> num list -> bool
    <tr><td>
    <span class="strong">necklace</span>
    <td>
    :num -> num -> num list -> bool
    <tr><td> <span class="strong">perm</span> <td> :num -> num
    <tr><td>
    <span class="strong">perm_count</span>
    <td>
    :num -> num list -> bool
    <tr><td>
    <span class="strong">perm_set</span>
    <td>
    :(Œ± -> bool) -> Œ± list -> bool
    <tr><td>
    <span class="strong">recordtype.triple</span>
    <td>
    :num -> num -> num -> triple
    <tr><td>
    <span class="strong">recordtype.triple.seldef.a</span>
    <td>
    :triple -> num
    <tr><td>
    <span class="strong">recordtype.triple.seldef.a_fupd</span>
    <td>
    :(num -> num) -> triple -> triple
    <tr><td>
    <span class="strong">recordtype.triple.seldef.b</span>
    <td>
    :triple -> num
    <tr><td>
    <span class="strong">recordtype.triple.seldef.b_fupd</span>
    <td>
    :(num -> num) -> triple -> triple
    <tr><td>
    <span class="strong">recordtype.triple.seldef.c</span>
    <td>
    :triple -> num
    <tr><td>
    <span class="strong">recordtype.triple.seldef.c_fupd</span>
    <td>
    :(num -> num) -> triple -> triple
    <tr><td> <span class="strong">rotate</span> <td> :num -> Œ± list -> Œ± list
    <tr><td> <span class="strong">set_lcm</span> <td> :(num -> bool) -> num
    <tr><td>
    <span class="strong">sub_count</span>
    <td>
    :num -> num -> (num -> bool) -> bool
    <tr><td>
    <span class="strong">sub_sets</span>
    <td>
    :(Œ± -> bool) -> num -> (Œ± -> bool) -> bool
    <tr><td>
    <span class="strong">triple_CASE</span>
    <td>
    :triple -> (num -> num -> num -> Œ±) -> Œ±
    <tr><td> <span class="strong">triple_size</span> <td> :triple -> num
    <tr><td> <span class="strong">triplet</span> <td> :num -> num -> triple
    <tr><td> <span class="strong">turn</span> <td> :Œ± list -> Œ± list
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">MDILATE_def</span>
<DD>
<pre>
‚ä¢ (‚àÄe n. MDILATE e n [] = []) ‚àß
  ‚àÄe n h t.
    MDILATE e n (h::t) =
    if t = [] then [h] else h::GENLIST (K e) (PRE n) ++ MDILATE e n t
</pre>

<DT><span class="strong">PROD</span>
<DD>
<pre>
‚ä¢ PROD [] = 1 ‚àß ‚àÄh t. PROD (h::t) = h * PROD t
</pre>

<DT><span class="strong">PROD_ACC_DEF</span>
<DD>
<pre>
‚ä¢ (‚àÄacc. PROD_ACC [] acc = acc) ‚àß
  ‚àÄh t acc. PROD_ACC (h::t) acc = PROD_ACC t (h * acc)
</pre>

<DT><span class="strong">arrange_def</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. n arrange k = CARD (list_count n k)
</pre>

<DT><span class="strong">choose_def</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. n choose k = CARD (sub_count n k)
</pre>

<DT><span class="strong">interleave_def</span>
<DD>
<pre>
‚ä¢ ‚àÄx ls.
    x interleave ls = IMAGE (Œªk. TAKE k ls ++ x::DROP k ls) (upto (LENGTH ls))
</pre>

<DT><span class="strong">lcm_upto_def</span>
<DD>
<pre>
‚ä¢ lcm_upto 0 = 1 ‚àß ‚àÄn. lcm_upto (SUC n) = lcm (SUC n) (lcm_upto n)
</pre>

<DT><span class="strong">leibniz_def</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. leibniz n k = (n + 1) * binomial n k
</pre>

<DT><span class="strong">leibniz_zigzag_def</span>
<DD>
<pre>
‚ä¢ ‚àÄp1 p2.
    p1 zigzag p2 ‚áî
    ‚àÉn k x y.
      p1 = x ++ [(triplet n k).b; (triplet n k).a] ++ y ‚àß
      p2 = x ++ [(triplet n k).b; (triplet n k).c] ++ y
</pre>

<DT><span class="strong">list_count_def</span>
<DD>
<pre>
‚ä¢ ‚àÄn k.
    list_count n k =
    {ls | ALL_DISTINCT ls ‚àß LIST_TO_SET ls ‚äÜ count n ‚àß LENGTH ls = k}
</pre>

<DT><span class="strong">list_lcm_def</span>
<DD>
<pre>
‚ä¢ list_lcm [] = 1 ‚àß ‚àÄh t. list_lcm (h::t) = lcm h (list_lcm t)
</pre>

<DT><span class="strong">monocoloured_def</span>
<DD>
<pre>
‚ä¢ ‚àÄn a.
    monocoloured n a =
    {ls | ls ‚àà necklace n a ‚àß (ls ‚â† [] ‚áí SING (LIST_TO_SET ls))}
</pre>

<DT><span class="strong">multicoloured_def</span>
<DD>
<pre>
‚ä¢ ‚àÄn a. multicoloured n a = necklace n a DIFF monocoloured n a
</pre>

<DT><span class="strong">necklace_def</span>
<DD>
<pre>
‚ä¢ ‚àÄn a. necklace n a = {ls | LENGTH ls = n ‚àß LIST_TO_SET ls ‚äÜ count a}
</pre>

<DT><span class="strong">perm_count_def</span>
<DD>
<pre>
‚ä¢ ‚àÄn. perm_count n = {ls | ALL_DISTINCT ls ‚àß LIST_TO_SET ls = count n}
</pre>

<DT><span class="strong">perm_def</span>
<DD>
<pre>
‚ä¢ ‚àÄn. perm n = CARD (perm_count n)
</pre>

<DT><span class="strong">perm_set_def</span>
<DD>
<pre>
‚ä¢ ‚àÄs. perm_set s = {ls | ALL_DISTINCT ls ‚àß LIST_TO_SET ls = s}
</pre>

<DT><span class="strong">recordtype_triple_seldef_a_def</span>
<DD>
<pre>
‚ä¢ ‚àÄn n0 n1. (triple n n0 n1).a = n
</pre>

<DT><span class="strong">recordtype_triple_seldef_a_fupd_def</span>
<DD>
<pre>
‚ä¢ ‚àÄf n n0 n1. triple n n0 n1 with a updated_by f = triple (f n) n0 n1
</pre>

<DT><span class="strong">recordtype_triple_seldef_b_def</span>
<DD>
<pre>
‚ä¢ ‚àÄn n0 n1. (triple n n0 n1).b = n0
</pre>

<DT><span class="strong">recordtype_triple_seldef_b_fupd_def</span>
<DD>
<pre>
‚ä¢ ‚àÄf n n0 n1. triple n n0 n1 with b updated_by f = triple n (f n0) n1
</pre>

<DT><span class="strong">recordtype_triple_seldef_c_def</span>
<DD>
<pre>
‚ä¢ ‚àÄn n0 n1. (triple n n0 n1).c = n1
</pre>

<DT><span class="strong">recordtype_triple_seldef_c_fupd_def</span>
<DD>
<pre>
‚ä¢ ‚àÄf n n0 n1. triple n n0 n1 with c updated_by f = triple n n0 (f n1)
</pre>

<DT><span class="strong">rotate_def</span>
<DD>
<pre>
‚ä¢ ‚àÄn l. rotate n l = DROP n l ++ TAKE n l
</pre>

<DT><span class="strong">set_lcm_def</span>
<DD>
<pre>
‚ä¢ ‚àÄs. set_lcm s = list_lcm (SET_TO_LIST s)
</pre>

<DT><span class="strong">sub_count_def</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. sub_count n k = {s | s ‚äÜ count n ‚àß CARD s = k}
</pre>

<DT><span class="strong">sub_sets_def</span>
<DD>
<pre>
‚ä¢ ‚àÄP k. sub_sets P k = {s | s ‚äÜ P ‚àß CARD s = k}
</pre>

<DT><span class="strong">triple_TY_DEF</span>
<DD>
<pre>
‚ä¢ ‚àÉrep.
    TYPE_DEFINITION
      (Œªa0'.
           ‚àÄ $var$('triple').
             (‚àÄa0'.
                (‚àÉa0 a1 a2.
                   a0' =
                   (Œªa0 a1 a2.
                        ind_type$CONSTR 0 (a0,a1,a2) (Œªn. ind_type$BOTTOM)) a0
                     a1 a2) ‚áí
                $var$('triple') a0') ‚áí
             $var$('triple') a0') rep
</pre>

<DT><span class="strong">triple_case_def</span>
<DD>
<pre>
‚ä¢ ‚àÄa0 a1 a2 f. triple_CASE (triple a0 a1 a2) f = f a0 a1 a2
</pre>

<DT><span class="strong">triple_size_def</span>
<DD>
<pre>
‚ä¢ ‚àÄa0 a1 a2. triple_size (triple a0 a1 a2) = 1 + (a0 + (a1 + a2))
</pre>

<DT><span class="strong">triplet_def</span>
<DD>
<pre>
‚ä¢ ‚àÄn k.
    triplet n k =
    <|a := leibniz n k; b := leibniz (n + 1) k; c := leibniz (n + 1) (k + 1)|>
</pre>

<DT><span class="strong">turn_def</span>
<DD>
<pre>
‚ä¢ ‚àÄl. turn l = if l = [] then [] else LAST l::FRONT l
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">CARD_LIST_TO_SET_EQ</span>
<DD>
<pre>
‚ä¢ ‚àÄl. CARD (LIST_TO_SET l) = LENGTH (nub l)
</pre>

<DT><span class="strong">DILATE_0_0</span>
<DD>
<pre>
‚ä¢ ‚àÄl e. DILATE e 0 0 l = l
</pre>

<DT><span class="strong">DILATE_0_CONS</span>
<DD>
<pre>
‚ä¢ ‚àÄn h t e.
    DILATE e 0 n (h::t) =
    if t = [] then [h] else h::(GENLIST (K e) n ++ DILATE e 0 n t)
</pre>

<DT><span class="strong">DILATE_0_EL</span>
<DD>
<pre>
‚ä¢ ‚àÄl e n k.
    k < LENGTH (DILATE e 0 n l) ‚áí
    EL k (DILATE e 0 n l) = if k MOD SUC n = 0 then EL (k DIV SUC n) l else e
</pre>

<DT><span class="strong">DILATE_0_EQ_NIL</span>
<DD>
<pre>
‚ä¢ ‚àÄl e n. DILATE e 0 n l = [] ‚áî l = []
</pre>

<DT><span class="strong">DILATE_0_LAST</span>
<DD>
<pre>
‚ä¢ ‚àÄl e n. LAST (DILATE e 0 n l) = LAST l
</pre>

<DT><span class="strong">DILATE_0_LENGTH</span>
<DD>
<pre>
‚ä¢ ‚àÄl e n.
    LENGTH (DILATE e 0 n l) =
    if l = [] then 0 else SUC (SUC n * PRE (LENGTH l))
</pre>

<DT><span class="strong">DILATE_0_LENGTH_LOWER</span>
<DD>
<pre>
‚ä¢ ‚àÄl e n. LENGTH l ‚â§ LENGTH (DILATE e 0 n l)
</pre>

<DT><span class="strong">DILATE_0_LENGTH_UPPER</span>
<DD>
<pre>
‚ä¢ ‚àÄl e n. LENGTH (DILATE e 0 n l) ‚â§ SUC (SUC n * PRE (LENGTH l))
</pre>

<DT><span class="strong">DILATE_0_SUC</span>
<DD>
<pre>
‚ä¢ ‚àÄl e n. DILATE e 0 (SUC n) l = DILATE e n 1 (DILATE e 0 n l)
</pre>

<DT><span class="strong">DILATE_CONS</span>
<DD>
<pre>
‚ä¢ ‚àÄn m h t e.
    DILATE e n m (h::t) =
    if t = [] then [h]
    else h::(TAKE n t ++ GENLIST (K e) m ++ DILATE e n m (DROP n t))
</pre>

<DT><span class="strong">DILATE_NIL</span>
<DD>
<pre>
‚ä¢ ‚àÄn m e. DILATE e n m [] = []
</pre>

<DT><span class="strong">DILATE_SING</span>
<DD>
<pre>
‚ä¢ ‚àÄn m h e. DILATE e n m [h] = [h]
</pre>

<DT><span class="strong">DILATE_def</span>
<DD>
<pre>
‚ä¢ (‚àÄn m e. DILATE e n m [] = []) ‚àß (‚àÄn m h e. DILATE e n m [h] = [h]) ‚àß
  ‚àÄv9 v8 n m h e.
    DILATE e n m (h::v8::v9) =
    h::(TAKE n (v8::v9) ++ GENLIST (K e) m ++ DILATE e n m (DROP n (v8::v9)))
</pre>

<DT><span class="strong">DILATE_ind</span>
<DD>
<pre>
‚ä¢ ‚àÄP. (‚àÄe n m. P e n m []) ‚àß (‚àÄe n m h. P e n m [h]) ‚àß
      (‚àÄe n m h v8 v9. P e n m (DROP n (v8::v9)) ‚áí P e n m (h::v8::v9)) ‚áí
      ‚àÄv v1 v2 v3. P v v1 v2 v3
</pre>

<DT><span class="strong">EL_ALL_PROPERTY</span>
<DD>
<pre>
‚ä¢ ‚àÄh1 t1 h2 t2 P.
    LENGTH (h1::t1) = LENGTH (h2::t2) ‚àß
    (‚àÄk. k < LENGTH (h1::t1) ‚áí P (EL k (h1::t1)) (EL k (h2::t2))) ‚áí
    P h1 h2 ‚àß ‚àÄk. k < LENGTH t1 ‚áí P (EL k t1) (EL k t2)
</pre>

<DT><span class="strong">EL_MAP3</span>
<DD>
<pre>
‚ä¢ ‚àÄlx ly lz n.
    n < MIN (MIN (LENGTH lx) (LENGTH ly)) (LENGTH lz) ‚áí
    ‚àÄf. EL n (MAP3 f lx ly lz) = f (EL n lx) (EL n ly) (EL n lz)
</pre>

<DT><span class="strong">EVERY_ELEMENT_PROPERTY</span>
<DD>
<pre>
‚ä¢ ‚àÄp R. EVERY (Œªc. c ‚àà R) p ‚áí ‚àÄk. k < LENGTH p ‚áí EL k p ‚àà R
</pre>

<DT><span class="strong">EVERY_LT_IMP_EVERY_LE</span>
<DD>
<pre>
‚ä¢ ‚àÄls n. EVERY (Œªj. j < n) ls ‚áí EVERY (Œªj. j ‚â§ n) ls
</pre>

<DT><span class="strong">EVERY_MONOTONIC_MAP</span>
<DD>
<pre>
‚ä¢ ‚àÄl f P Q. (‚àÄx. P x ‚áí (Q ‚àò f) x) ‚àß EVERY P l ‚áí EVERY Q (MAP f l)
</pre>

<DT><span class="strong">EXISTS_triple</span>
<DD>
<pre>
‚ä¢ ‚àÄP. (‚àÉt. P t) ‚áî ‚àÉn1 n0 n. P <|a := n1; b := n0; c := n|>
</pre>

<DT><span class="strong">FILTER_EL_NEXT_IDX</span>
<DD>
<pre>
‚ä¢ ‚àÄP ls l1 l2 l3 x y.
    (let
       fs = FILTER P ls
     in
       ALL_DISTINCT ls ‚àß ls = l1 ++ x::l2 ++ y::l3 ‚àß P x ‚àß P y ‚áí
       (findi y fs = 1 + findi x fs ‚áî FILTER P l2 = []))
</pre>

<DT><span class="strong">FINITE_SURJ_IFF</span>
<DD>
<pre>
‚ä¢ ‚àÄf s t.
    FINITE t ‚áí (SURJ f s t ‚áî CARD (IMAGE f s) = CARD t ‚àß ‚àÄx. x ‚àà s ‚áí f x ‚àà t)
</pre>

<DT><span class="strong">FORALL_triple</span>
<DD>
<pre>
‚ä¢ ‚àÄP. (‚àÄt. P t) ‚áî ‚àÄn1 n0 n. P <|a := n1; b := n0; c := n|>
</pre>

<DT><span class="strong">FUNPOW_cons_eq_map_0</span>
<DD>
<pre>
‚ä¢ ‚àÄf u n.
    FUNPOW (Œªls. f (HD ls)::ls) n [u] = MAP (Œªj. FUNPOW f j u) (n downto 0)
</pre>

<DT><span class="strong">FUNPOW_cons_eq_map_1</span>
<DD>
<pre>
‚ä¢ ‚àÄf u n.
    0 < n ‚áí
    FUNPOW (Œªls. f (HD ls)::ls) (n ‚àí 1) [f u] =
    MAP (Œªj. FUNPOW f j u) (n downto 1)
</pre>

<DT><span class="strong">FUNPOW_cons_head</span>
<DD>
<pre>
‚ä¢ ‚àÄf n ls. HD (FUNPOW (Œªls. f (HD ls)::ls) n ls) = FUNPOW f n (HD ls)
</pre>

<DT><span class="strong">FUNSET_ALT</span>
<DD>
<pre>
‚ä¢ ‚àÄP Q. (P ‚Üí Q) = {f | ‚àÄx. x ‚àà P ‚áí f x ‚àà Q}
</pre>

<DT><span class="strong">GENLIST_MONO_DEC</span>
<DD>
<pre>
‚ä¢ ‚àÄf n. RMONO f ‚áí MONO_DEC (GENLIST f n)
</pre>

<DT><span class="strong">GENLIST_MONO_INC</span>
<DD>
<pre>
‚ä¢ ‚àÄf n. MONO f ‚áí MONO_INC (GENLIST f n)
</pre>

<DT><span class="strong">GENLIST_binomial_index_shift</span>
<DD>
<pre>
‚ä¢ ‚àÄn x y.
    GENLIST ((Œªk. binomial n k * x ** SUC (n ‚àí k) * y ** k) ‚àò SUC) n =
    GENLIST (Œªk. binomial n (SUC k) * x ** (n ‚àí k) * y ** SUC k) n
</pre>

<DT><span class="strong">INJ_IFF_BIJ_IMAGE</span>
<DD>
<pre>
‚ä¢ ‚àÄf s t. (‚àÄx. x ‚àà s ‚áí f x ‚àà t) ‚áí (INJ f s t ‚áî BIJ f s (IMAGE f s))
</pre>

<DT><span class="strong">INJ_IMAGE_BIJ_IFF</span>
<DD>
<pre>
‚ä¢ ‚àÄf s t. INJ f s t ‚áî BIJ f s (IMAGE f s) ‚àß ‚àÄx. x ‚àà s ‚áí f x ‚àà t
</pre>

<DT><span class="strong">INJ_IMAGE_IFF</span>
<DD>
<pre>
‚ä¢ ‚àÄf s t. INJ f s t ‚áî INJ f s (IMAGE f s) ‚àß ‚àÄx. x ‚àà s ‚áí f x ‚àà t
</pre>

<DT><span class="strong">LENGTH_MAP3</span>
<DD>
<pre>
‚ä¢ ‚àÄlx ly lz f.
    LENGTH (MAP3 f lx ly lz) = MIN (MIN (LENGTH lx) (LENGTH ly)) (LENGTH lz)
</pre>

<DT><span class="strong">LIST_TO_SET_REDUCTION</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2 h.
    ¬¨MEM h l1 ‚àß LIST_TO_SET (h::l1) = LIST_TO_SET l2 ‚áí
    ‚àÉp1 p2.
      ¬¨MEM h p1 ‚àß ¬¨MEM h p2 ‚àß nub l2 = p1 ++ [h] ++ p2 ‚àß
      LIST_TO_SET l1 = LIST_TO_SET (p1 ++ p2)
</pre>

<DT><span class="strong">LUPDATE_APPEND_0</span>
<DD>
<pre>
‚ä¢ ‚àÄls a h t. LUPDATE a (LENGTH ls) (ls ++ h::t) = ls ++ a::t
</pre>

<DT><span class="strong">LUPDATE_APPEND_0_1</span>
<DD>
<pre>
‚ä¢ ‚àÄls a b h k t.
    LUPDATE b (LENGTH ls + 1) (LUPDATE a (LENGTH ls) (ls ++ h::k::t)) =
    ls ++ a::b::t
</pre>

<DT><span class="strong">LUPDATE_APPEND_1</span>
<DD>
<pre>
‚ä¢ ‚àÄls b h k t. LUPDATE b (LENGTH ls + 1) (ls ++ h::k::t) = ls ++ h::b::t
</pre>

<DT><span class="strong">LUPDATE_DIFF_SPOT</span>
<DD>
<pre>
‚ä¢ ‚àÄls m n p q.
    m ‚â† n ‚áí LUPDATE q n (LUPDATE p m ls) = LUPDATE p m (LUPDATE q n ls)
</pre>

<DT><span class="strong">LUPDATE_EL</span>
<DD>
<pre>
‚ä¢ ‚àÄe n l p. p < LENGTH l ‚áí EL p (LUPDATE e n l) = if p = n then e else EL p l
</pre>

<DT><span class="strong">LUPDATE_LEN</span>
<DD>
<pre>
‚ä¢ ‚àÄe n l. LENGTH (LUPDATE e n l) = LENGTH l
</pre>

<DT><span class="strong">LUPDATE_SAME_SPOT</span>
<DD>
<pre>
‚ä¢ ‚àÄls n p q. LUPDATE q n (LUPDATE p n ls) = LUPDATE q n ls
</pre>

<DT><span class="strong">MAP2_LE</span>
<DD>
<pre>
‚ä¢ ‚àÄf g.
    (‚àÄx y. f x y ‚â§ g x y) ‚áí
    ‚àÄlx ly n. EL n (MAP2 f lx ly) ‚â§ EL n (MAP2 g lx ly)
</pre>

<DT><span class="strong">MAP3</span>
<DD>
<pre>
‚ä¢ (‚àÄf. MAP3 f [] [] [] = []) ‚àß
  ‚àÄf h1 t1 h2 t2 h3 t3.
    MAP3 f (h1::t1) (h2::t2) (h3::t3) = f h1 h2 h3::MAP3 f t1 t2 t3
</pre>

<DT><span class="strong">MAP3_DEF</span>
<DD>
<pre>
‚ä¢ (‚àÄt3 t2 t1 h3 h2 h1 f.
     MAP3 f (h1::t1) (h2::t2) (h3::t3) = f h1 h2 h3::MAP3 f t1 t2 t3) ‚àß
  (‚àÄz y f. MAP3 f [] y z = []) ‚àß (‚àÄz v5 v4 f. MAP3 f (v4::v5) [] z = []) ‚àß
  ‚àÄv5 v4 v13 v12 f. MAP3 f (v4::v5) (v12::v13) [] = []
</pre>

<DT><span class="strong">MAP3_IND</span>
<DD>
<pre>
‚ä¢ ‚àÄP. (‚àÄf h1 t1 h2 t2 h3 t3. P f t1 t2 t3 ‚áí P f (h1::t1) (h2::t2) (h3::t3)) ‚àß
      (‚àÄf y z. P f [] y z) ‚àß (‚àÄf v4 v5 z. P f (v4::v5) [] z) ‚àß
      (‚àÄf v4 v5 v12 v13. P f (v4::v5) (v12::v13) []) ‚áí
      ‚àÄv v1 v2 v3. P v v1 v2 v3
</pre>

<DT><span class="strong">MAP3_LE</span>
<DD>
<pre>
‚ä¢ ‚àÄf g.
    (‚àÄx y z. f x y z ‚â§ g x y z) ‚áí
    ‚àÄlx ly lz n. EL n (MAP3 f lx ly lz) ‚â§ EL n (MAP3 g lx ly lz)
</pre>

<DT><span class="strong">MAP_LE</span>
<DD>
<pre>
‚ä¢ ‚àÄf g. (‚àÄx. f x ‚â§ g x) ‚áí ‚àÄls n. EL n (MAP f ls) ‚â§ EL n (MAP g ls)
</pre>

<DT><span class="strong">MAX_LIST_MONO_MAP</span>
<DD>
<pre>
‚ä¢ ‚àÄf. MONO f ‚áí ‚àÄls. ls ‚â† [] ‚áí MAX_LIST (MAP f ls) = f (MAX_LIST ls)
</pre>

<DT><span class="strong">MDILATE_0</span>
<DD>
<pre>
‚ä¢ ‚àÄl e. MDILATE e 0 l = l
</pre>

<DT><span class="strong">MDILATE_1</span>
<DD>
<pre>
‚ä¢ ‚àÄl e. MDILATE e 1 l = l
</pre>

<DT><span class="strong">MDILATE_CONS</span>
<DD>
<pre>
‚ä¢ ‚àÄe n h t.
    MDILATE e n (h::t) =
    if t = [] then [h] else h::GENLIST (K e) (PRE n) ++ MDILATE e n t
</pre>

<DT><span class="strong">MDILATE_EL</span>
<DD>
<pre>
‚ä¢ ‚àÄl e n k.
    k < LENGTH (MDILATE e n l) ‚áí
    EL k (MDILATE e n l) =
    if n = 0 then EL k l else if k MOD n = 0 then EL (k DIV n) l else e
</pre>

<DT><span class="strong">MDILATE_EQ_NIL</span>
<DD>
<pre>
‚ä¢ ‚àÄl e n. MDILATE e n l = [] ‚áî l = []
</pre>

<DT><span class="strong">MDILATE_LAST</span>
<DD>
<pre>
‚ä¢ ‚àÄl e n. LAST (MDILATE e n l) = LAST l
</pre>

<DT><span class="strong">MDILATE_LENGTH</span>
<DD>
<pre>
‚ä¢ ‚àÄl e n.
    LENGTH (MDILATE e n l) =
    if n = 0 then LENGTH l else if l = [] then 0 else SUC (n * PRE (LENGTH l))
</pre>

<DT><span class="strong">MDILATE_LENGTH_LOWER</span>
<DD>
<pre>
‚ä¢ ‚àÄl e n. LENGTH l ‚â§ LENGTH (MDILATE e n l)
</pre>

<DT><span class="strong">MDILATE_LENGTH_UPPER</span>
<DD>
<pre>
‚ä¢ ‚àÄl e n. 0 < n ‚áí LENGTH (MDILATE e n l) ‚â§ SUC (n * PRE (LENGTH l))
</pre>

<DT><span class="strong">MDILATE_NIL</span>
<DD>
<pre>
‚ä¢ ‚àÄe n. MDILATE e n [] = []
</pre>

<DT><span class="strong">MDILATE_SING</span>
<DD>
<pre>
‚ä¢ ‚àÄe n x. MDILATE e n [x] = [x]
</pre>

<DT><span class="strong">MEM_MAP2</span>
<DD>
<pre>
‚ä¢ ‚àÄf x l1 l2.
    MEM x (MAP2 f l1 l2) ‚áí ‚àÉy1 y2. x = f y1 y2 ‚àß MEM y1 l1 ‚àß MEM y2 l2
</pre>

<DT><span class="strong">MEM_MAP2_LOWER</span>
<DD>
<pre>
‚ä¢ ‚àÄf. MONO2 f ‚áí
      ‚àÄlx ly e. MEM e (MAP2 f lx ly) ‚áí f (MIN_LIST lx) (MIN_LIST ly) ‚â§ e
</pre>

<DT><span class="strong">MEM_MAP2_UPPER</span>
<DD>
<pre>
‚ä¢ ‚àÄf. MONO2 f ‚áí
      ‚àÄlx ly e. MEM e (MAP2 f lx ly) ‚áí e ‚â§ f (MAX_LIST lx) (MAX_LIST ly)
</pre>

<DT><span class="strong">MEM_MAP3</span>
<DD>
<pre>
‚ä¢ ‚àÄf x l1 l2 l3.
    MEM x (MAP3 f l1 l2 l3) ‚áí
    ‚àÉy1 y2 y3. x = f y1 y2 y3 ‚àß MEM y1 l1 ‚àß MEM y2 l2 ‚àß MEM y3 l3
</pre>

<DT><span class="strong">MEM_MAP3_LOWER</span>
<DD>
<pre>
‚ä¢ ‚àÄf. MONO3 f ‚áí
      ‚àÄlx ly lz e.
        MEM e (MAP3 f lx ly lz) ‚áí
        f (MIN_LIST lx) (MIN_LIST ly) (MIN_LIST lz) ‚â§ e
</pre>

<DT><span class="strong">MEM_MAP3_UPPER</span>
<DD>
<pre>
‚ä¢ ‚àÄf. MONO3 f ‚áí
      ‚àÄlx ly lz e.
        MEM e (MAP3 f lx ly lz) ‚áí
        e ‚â§ f (MAX_LIST lx) (MAX_LIST ly) (MAX_LIST lz)
</pre>

<DT><span class="strong">MEM_MAP_LOWER</span>
<DD>
<pre>
‚ä¢ ‚àÄf. MONO f ‚áí ‚àÄls e. MEM e (MAP f ls) ‚áí f (MIN_LIST ls) ‚â§ e
</pre>

<DT><span class="strong">MEM_MAP_UPPER</span>
<DD>
<pre>
‚ä¢ ‚àÄf. MONO f ‚áí ‚àÄls e. MEM e (MAP f ls) ‚áí e ‚â§ f (MAX_LIST ls)
</pre>

<DT><span class="strong">MIN_LIST_MONO_MAP</span>
<DD>
<pre>
‚ä¢ ‚àÄf. MONO f ‚áí ‚àÄls. ls ‚â† [] ‚áí MIN_LIST (MAP f ls) = f (MIN_LIST ls)
</pre>

<DT><span class="strong">MONO_LIST_TO_SET</span>
<DD>
<pre>
‚ä¢ ‚àÄx. LIST_TO_SET [x] = {x}
</pre>

<DT><span class="strong">PAD_LEFT_0</span>
<DD>
<pre>
‚ä¢ ‚àÄl c. PAD_LEFT c 0 l = l
</pre>

<DT><span class="strong">PAD_LEFT_BY_LEFT</span>
<DD>
<pre>
‚ä¢ ‚àÄls c n. PAD_LEFT c n ls = PAD_LEFT c (n ‚àí LENGTH ls) [] ++ ls
</pre>

<DT><span class="strong">PAD_LEFT_BY_RIGHT</span>
<DD>
<pre>
‚ä¢ ‚àÄls c n. PAD_LEFT c n ls = PAD_RIGHT c (n ‚àí LENGTH ls) [] ++ ls
</pre>

<DT><span class="strong">PAD_LEFT_CONS</span>
<DD>
<pre>
‚ä¢ ‚àÄl n. LENGTH l ‚â§ n ‚áí ‚àÄc. PAD_LEFT c (SUC n) l = c::PAD_LEFT c n l
</pre>

<DT><span class="strong">PAD_LEFT_EQ_NIL</span>
<DD>
<pre>
‚ä¢ ‚àÄl c n. PAD_LEFT c n l = [] ‚áî l = [] ‚àß n = 0
</pre>

<DT><span class="strong">PAD_LEFT_ID</span>
<DD>
<pre>
‚ä¢ ‚àÄl c n. n ‚â§ LENGTH l ‚áí PAD_LEFT c n l = l
</pre>

<DT><span class="strong">PAD_LEFT_LAST</span>
<DD>
<pre>
‚ä¢ ‚àÄl c n. l ‚â† [] ‚áí LAST (PAD_LEFT c n l) = LAST l
</pre>

<DT><span class="strong">PAD_LEFT_LENGTH</span>
<DD>
<pre>
‚ä¢ ‚àÄn c s. LENGTH (PAD_LEFT c n s) = MAX n (LENGTH s)
</pre>

<DT><span class="strong">PAD_LEFT_NIL</span>
<DD>
<pre>
‚ä¢ ‚àÄn c. PAD_LEFT c n [] = GENLIST (K c) n
</pre>

<DT><span class="strong">PAD_LEFT_NIL_EQ</span>
<DD>
<pre>
‚ä¢ ‚àÄn c. 0 < n ‚áí PAD_LEFT c n [] = PAD_LEFT c n [c]
</pre>

<DT><span class="strong">PAD_RIGHT_0</span>
<DD>
<pre>
‚ä¢ ‚àÄl c. PAD_RIGHT c 0 l = l
</pre>

<DT><span class="strong">PAD_RIGHT_BY_LEFT</span>
<DD>
<pre>
‚ä¢ ‚àÄls c n. PAD_RIGHT c n ls = ls ++ PAD_LEFT c (n ‚àí LENGTH ls) []
</pre>

<DT><span class="strong">PAD_RIGHT_BY_RIGHT</span>
<DD>
<pre>
‚ä¢ ‚àÄls c n. PAD_RIGHT c n ls = ls ++ PAD_RIGHT c (n ‚àí LENGTH ls) []
</pre>

<DT><span class="strong">PAD_RIGHT_CONS</span>
<DD>
<pre>
‚ä¢ ‚àÄh t c n. h::PAD_RIGHT c n t = PAD_RIGHT c (SUC n) (h::t)
</pre>

<DT><span class="strong">PAD_RIGHT_EQ_NIL</span>
<DD>
<pre>
‚ä¢ ‚àÄl c n. PAD_RIGHT c n l = [] ‚áî l = [] ‚àß n = 0
</pre>

<DT><span class="strong">PAD_RIGHT_ID</span>
<DD>
<pre>
‚ä¢ ‚àÄl c n. n ‚â§ LENGTH l ‚áí PAD_RIGHT c n l = l
</pre>

<DT><span class="strong">PAD_RIGHT_LENGTH</span>
<DD>
<pre>
‚ä¢ ‚àÄn c s. LENGTH (PAD_RIGHT c n s) = MAX n (LENGTH s)
</pre>

<DT><span class="strong">PAD_RIGHT_NIL</span>
<DD>
<pre>
‚ä¢ ‚àÄn c. PAD_RIGHT c n [] = GENLIST (K c) n
</pre>

<DT><span class="strong">PAD_RIGHT_NIL_EQ</span>
<DD>
<pre>
‚ä¢ ‚àÄn c. 0 < n ‚áí PAD_RIGHT c n [] = PAD_RIGHT c n [c]
</pre>

<DT><span class="strong">PAD_RIGHT_SNOC</span>
<DD>
<pre>
‚ä¢ ‚àÄl n. LENGTH l ‚â§ n ‚áí ‚àÄc. PAD_RIGHT c (SUC n) l = SNOC c (PAD_RIGHT c n l)
</pre>

<DT><span class="strong">POSITIVE_THM</span>
<DD>
<pre>
‚ä¢ ‚àÄls. EVERY_POSITIVE ls ‚áî POSITIVE ls
</pre>

<DT><span class="strong">PROD_ACC_PROD_LEM</span>
<DD>
<pre>
‚ä¢ ‚àÄL n. PROD_ACC L n = PROD L * n
</pre>

<DT><span class="strong">PROD_ACC_SUM_LEM</span>
<DD>
<pre>
‚ä¢ ‚àÄL n. PROD_ACC L n = PROD L * n
</pre>

<DT><span class="strong">PROD_APPEND</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2. PROD (l1 ++ l2) = PROD l1 * PROD l2
</pre>

<DT><span class="strong">PROD_CONS</span>
<DD>
<pre>
‚ä¢ ‚àÄh t. PROD (h::t) = h * PROD t
</pre>

<DT><span class="strong">PROD_CONSTANT</span>
<DD>
<pre>
‚ä¢ ‚àÄn x. PROD (GENLIST (Œªj. x) n) = x ** n
</pre>

<DT><span class="strong">PROD_EQ_0</span>
<DD>
<pre>
‚ä¢ ‚àÄl. PROD l = 0 ‚áî MEM 0 l
</pre>

<DT><span class="strong">PROD_GENLIST_K</span>
<DD>
<pre>
‚ä¢ ‚àÄm n. PROD (GENLIST (K m) n) = m ** n
</pre>

<DT><span class="strong">PROD_IMAGE_eq_PROD_MAP_SET_TO_LIST</span>
<DD>
<pre>
‚ä¢ ‚àÄs. FINITE s ‚áí ‚àÄf. ‚àè f s = PROD (MAP f (SET_TO_LIST s))
</pre>

<DT><span class="strong">PROD_MAP_FOLDL</span>
<DD>
<pre>
‚ä¢ ‚àÄls f. PROD (MAP f ls) = FOLDL (Œªa e. a * f e) 1 ls
</pre>

<DT><span class="strong">PROD_NIL</span>
<DD>
<pre>
‚ä¢ PROD [] = 1
</pre>

<DT><span class="strong">PROD_POS</span>
<DD>
<pre>
‚ä¢ ‚àÄl. EVERY_POSITIVE l ‚áí 0 < PROD l
</pre>

<DT><span class="strong">PROD_POS_ALT</span>
<DD>
<pre>
‚ä¢ ‚àÄl. POSITIVE l ‚áí 0 < PROD l
</pre>

<DT><span class="strong">PROD_PROD_ACC</span>
<DD>
<pre>
‚ä¢ ‚àÄL. PROD L = PROD_ACC L 1
</pre>

<DT><span class="strong">PROD_SING</span>
<DD>
<pre>
‚ä¢ ‚àÄn. PROD [n] = n
</pre>

<DT><span class="strong">PROD_SNOC</span>
<DD>
<pre>
‚ä¢ ‚àÄx l. PROD (SNOC x l) = PROD l * x
</pre>

<DT><span class="strong">PROD_SQUARING_LIST</span>
<DD>
<pre>
‚ä¢ ‚àÄm n. PROD (GENLIST (Œªj. n ** 2 ** j) m) = n ** tops 2 m
</pre>

<DT><span class="strong">PROD_eq_1</span>
<DD>
<pre>
‚ä¢ ‚àÄls. PROD ls = 1 ‚áî ‚àÄx. MEM x ls ‚áí x = 1
</pre>

<DT><span class="strong">PROD_eval</span>
<DD>
<pre>
‚ä¢ ‚àÄls. PROD ls = if ls = [] then 1 else HD ls * PROD (TL ls)
</pre>

<DT><span class="strong">SUM_ADD_GENLIST</span>
<DD>
<pre>
‚ä¢ ‚àÄa b n.
    SUM (GENLIST a n) + SUM (GENLIST b n) = SUM (GENLIST (Œªk. a k + b k) n)
</pre>

<DT><span class="strong">SUM_CONS</span>
<DD>
<pre>
‚ä¢ ‚àÄh t. SUM (h::t) = h + SUM t
</pre>

<DT><span class="strong">SUM_CONSTANT</span>
<DD>
<pre>
‚ä¢ ‚àÄn x. SUM (GENLIST (Œªj. x) n) = n * x
</pre>

<DT><span class="strong">SUM_DECOMPOSE_FIRST</span>
<DD>
<pre>
‚ä¢ ‚àÄf n. SUM (GENLIST f (SUC n)) = f 0 + SUM (GENLIST (f ‚àò SUC) n)
</pre>

<DT><span class="strong">SUM_DECOMPOSE_FIRST_LAST</span>
<DD>
<pre>
‚ä¢ ‚àÄf n.
    0 < n ‚áí
    SUM (GENLIST f (SUC n)) = f 0 + SUM (GENLIST (f ‚àò SUC) (PRE n)) + f n
</pre>

<DT><span class="strong">SUM_DECOMPOSE_LAST</span>
<DD>
<pre>
‚ä¢ ‚àÄf n. SUM (GENLIST f (SUC n)) = SUM (GENLIST f n) + f n
</pre>

<DT><span class="strong">SUM_DOUBLING_LIST</span>
<DD>
<pre>
‚ä¢ ‚àÄm n. SUM (GENLIST (Œªj. n * 2 ** j) m) = n * tops 2 m
</pre>

<DT><span class="strong">SUM_EQ_0</span>
<DD>
<pre>
‚ä¢ ‚àÄl. SUM l = 0 ‚áî EVERY (Œªx. x = 0) l
</pre>

<DT><span class="strong">SUM_GENLIST</span>
<DD>
<pre>
‚ä¢ ‚àÄf n. SUM (GENLIST f n) = ‚àë f (count n)
</pre>

<DT><span class="strong">SUM_GENLIST_APPEND</span>
<DD>
<pre>
‚ä¢ ‚àÄa b n. SUM (GENLIST a n ++ GENLIST b n) = SUM (GENLIST (Œªk. a k + b k) n)
</pre>

<DT><span class="strong">SUM_GENLIST_K</span>
<DD>
<pre>
‚ä¢ ‚àÄm n. SUM (GENLIST (K m) n) = m * n
</pre>

<DT><span class="strong">SUM_GENLIST_MOD</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 < n ‚áí
      ‚àÄf. SUM (GENLIST ((Œªk. f k) ‚àò SUC) (PRE n)) MOD n =
          SUM (GENLIST ((Œªk. f k MOD n) ‚àò SUC) (PRE n)) MOD n
</pre>

<DT><span class="strong">SUM_GENLIST_REVERSE</span>
<DD>
<pre>
‚ä¢ ‚àÄf n. SUM (GENLIST (Œªj. f (n ‚àí j)) n) = SUM (MAP f [1 .. n])
</pre>

<DT><span class="strong">SUM_IMAGE_count</span>
<DD>
<pre>
‚ä¢ ‚àÄf n. ‚àë f (count n) = SUM (MAP f [0 ..< n])
</pre>

<DT><span class="strong">SUM_IMAGE_upto</span>
<DD>
<pre>
‚ä¢ ‚àÄf n. ‚àë f (upto n) = SUM (MAP f [0 .. n])
</pre>

<DT><span class="strong">SUM_LE</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2.
    LENGTH l1 = LENGTH l2 ‚àß (‚àÄk. k < LENGTH l1 ‚áí EL k l1 ‚â§ EL k l2) ‚áí
    SUM l1 ‚â§ SUM l2
</pre>

<DT><span class="strong">SUM_LEFT_ADD_DISTRIB</span>
<DD>
<pre>
‚ä¢ ‚àÄs m n. SUM s * (m + n) = SUM (MAP ($* m) s) + SUM (MAP ($* n) s)
</pre>

<DT><span class="strong">SUM_LE_EL</span>
<DD>
<pre>
‚ä¢ ‚àÄl n. n < LENGTH l ‚áí EL n l ‚â§ SUM l
</pre>

<DT><span class="strong">SUM_LE_MEM</span>
<DD>
<pre>
‚ä¢ ‚àÄl x. MEM x l ‚áí x ‚â§ SUM l
</pre>

<DT><span class="strong">SUM_LE_SUM_EL</span>
<DD>
<pre>
‚ä¢ ‚àÄl m n. m < n ‚àß n < LENGTH l ‚áí EL m l + EL n l ‚â§ SUM l
</pre>

<DT><span class="strong">SUM_LOWER</span>
<DD>
<pre>
‚ä¢ ‚àÄls. MIN_LIST ls * LENGTH ls ‚â§ SUM ls
</pre>

<DT><span class="strong">SUM_MAP2_K</span>
<DD>
<pre>
‚ä¢ ‚àÄlx ly c. SUM (MAP2 (Œªx y. c) lx ly) = c * LENGTH (MAP2 (Œªx y. c) lx ly)
</pre>

<DT><span class="strong">SUM_MAP2_UPPER</span>
<DD>
<pre>
‚ä¢ ‚àÄf. MONO2 f ‚áí
      ‚àÄlx ly.
        SUM (MAP2 f lx ly) ‚â§
        f (MAX_LIST lx) (MAX_LIST ly) * LENGTH (MAP2 f lx ly)
</pre>

<DT><span class="strong">SUM_MAP3_K</span>
<DD>
<pre>
‚ä¢ ‚àÄlx ly lz c.
    SUM (MAP3 (Œªx y z. c) lx ly lz) = c * LENGTH (MAP3 (Œªx y z. c) lx ly lz)
</pre>

<DT><span class="strong">SUM_MAP3_UPPER</span>
<DD>
<pre>
‚ä¢ ‚àÄf. MONO3 f ‚áí
      ‚àÄlx ly lz.
        SUM (MAP3 f lx ly lz) ‚â§
        f (MAX_LIST lx) (MAX_LIST ly) (MAX_LIST lz) * LENGTH (MAP3 f lx ly lz)
</pre>

<DT><span class="strong">SUM_MAP_K</span>
<DD>
<pre>
‚ä¢ ‚àÄls c. SUM (MAP (K c) ls) = c * LENGTH ls
</pre>

<DT><span class="strong">SUM_MAP_K_LE</span>
<DD>
<pre>
‚ä¢ ‚àÄls a b. a ‚â§ b ‚áí SUM (MAP (K a) ls) ‚â§ SUM (MAP (K b) ls)
</pre>

<DT><span class="strong">SUM_MAP_LE</span>
<DD>
<pre>
‚ä¢ ‚àÄf g ls. EVERY (Œªx. f x ‚â§ g x) ls ‚áí SUM (MAP f ls) ‚â§ SUM (MAP g ls)
</pre>

<DT><span class="strong">SUM_MAP_LT</span>
<DD>
<pre>
‚ä¢ ‚àÄf g ls.
    EVERY (Œªx. f x < g x) ls ‚àß ls ‚â† [] ‚áí SUM (MAP f ls) < SUM (MAP g ls)
</pre>

<DT><span class="strong">SUM_MAP_UPPER</span>
<DD>
<pre>
‚ä¢ ‚àÄf. MONO f ‚áí ‚àÄls. SUM (MAP f ls) ‚â§ f (MAX_LIST ls) * LENGTH ls
</pre>

<DT><span class="strong">SUM_MOD</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 < n ‚áí ‚àÄl. SUM l MOD n = SUM (MAP (Œªx. x MOD n) l) MOD n
</pre>

<DT><span class="strong">SUM_MONO_MAP</span>
<DD>
<pre>
‚ä¢ ‚àÄf1 f2. (‚àÄx. f1 x ‚â§ f2 x) ‚áí ‚àÄls. SUM (MAP f1 ls) ‚â§ SUM (MAP f2 ls)
</pre>

<DT><span class="strong">SUM_MONO_MAP2</span>
<DD>
<pre>
‚ä¢ ‚àÄf1 f2.
    (‚àÄx y. f1 x y ‚â§ f2 x y) ‚áí
    ‚àÄlx ly. SUM (MAP2 f1 lx ly) ‚â§ SUM (MAP2 f2 lx ly)
</pre>

<DT><span class="strong">SUM_MONO_MAP3</span>
<DD>
<pre>
‚ä¢ ‚àÄf1 f2.
    (‚àÄx y z. f1 x y z ‚â§ f2 x y z) ‚áí
    ‚àÄlx ly lz. SUM (MAP3 f1 lx ly lz) ‚â§ SUM (MAP3 f2 lx ly lz)
</pre>

<DT><span class="strong">SUM_MULT</span>
<DD>
<pre>
‚ä¢ ‚àÄs k. k * SUM s = SUM (MAP ($* k) s)
</pre>

<DT><span class="strong">SUM_NIL</span>
<DD>
<pre>
‚ä¢ SUM [] = 0
</pre>

<DT><span class="strong">SUM_RIGHT_ADD_DISTRIB</span>
<DD>
<pre>
‚ä¢ ‚àÄs m n. (m + n) * SUM s = SUM (MAP ($* m) s) + SUM (MAP ($* n) s)
</pre>

<DT><span class="strong">SUM_SING</span>
<DD>
<pre>
‚ä¢ ‚àÄn. SUM [n] = n
</pre>

<DT><span class="strong">SUM_UPPER</span>
<DD>
<pre>
‚ä¢ ‚àÄls. SUM ls ‚â§ MAX_LIST ls * LENGTH ls
</pre>

<DT><span class="strong">SURJ_CARD_IMAGE_EQ</span>
<DD>
<pre>
‚ä¢ ‚àÄf s t.
    FINITE t ‚àß (‚àÄx. x ‚àà s ‚áí f x ‚àà t) ‚áí
    (SURJ f s t ‚áî CARD (IMAGE f s) = CARD t)
</pre>

<DT><span class="strong">arithmetic_sum_eqn</span>
<DD>
<pre>
‚ä¢ ‚àÄn. SUM [1 ..< n] = n * (n ‚àí 1) DIV 2
</pre>

<DT><span class="strong">arithmetic_sum_eqn_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn. SUM [1 .. n] = n * (n + 1) DIV 2
</pre>

<DT><span class="strong">arrange_0_n</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 < n ‚áí 0 arrange n = 0
</pre>

<DT><span class="strong">arrange_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. n arrange k = (n choose k) * FACT k
</pre>

<DT><span class="strong">arrange_eq_0</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. n arrange k = 0 ‚áî n < k
</pre>

<DT><span class="strong">arrange_eqn</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. n arrange k = (n choose k) * perm k
</pre>

<DT><span class="strong">arrange_formula</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. n arrange k = binomial n k * FACT k
</pre>

<DT><span class="strong">arrange_formula2</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. k ‚â§ n ‚áí n arrange k = FACT n DIV FACT (n ‚àí k)
</pre>

<DT><span class="strong">arrange_n_0</span>
<DD>
<pre>
‚ä¢ ‚àÄn. n arrange 0 = 1
</pre>

<DT><span class="strong">arrange_n_n</span>
<DD>
<pre>
‚ä¢ ‚àÄn. n arrange n = perm n
</pre>

<DT><span class="strong">arrange_n_n_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn. n arrange n = FACT n
</pre>

<DT><span class="strong">beta_0_n</span>
<DD>
<pre>
‚ä¢ ‚àÄn. n * binomial 0 n = 0
</pre>

<DT><span class="strong">beta_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. 0 < n ‚àß 0 < k ‚áí k * binomial n k = leibniz (n ‚àí 1) (k ‚àí 1)
</pre>

<DT><span class="strong">beta_divides_beta_factor</span>
<DD>
<pre>
‚ä¢ ‚àÄm n k.
    k ‚â§ m ‚àß m ‚â§ n ‚áí k * binomial n k divides k * binomial m k * binomial n m
</pre>

<DT><span class="strong">beta_eq_0</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. k * binomial n k = 0 ‚áî k = 0 ‚à® n < k
</pre>

<DT><span class="strong">beta_eqn</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. (k + 1) * binomial (n + 1) (k + 1) = leibniz n k
</pre>

<DT><span class="strong">beta_horizontal_0</span>
<DD>
<pre>
‚ä¢ GENLIST ((Œªk. k * binomial 0 k) ‚àò SUC) 0 = []
</pre>

<DT><span class="strong">beta_horizontal_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 < n ‚áí
      GENLIST ((Œªk. k * binomial n k) ‚àò SUC) n = leibniz_horizontal (n ‚àí 1)
</pre>

<DT><span class="strong">beta_horizontal_element</span>
<DD>
<pre>
‚ä¢ ‚àÄn k.
    k < n ‚áí
    EL k (GENLIST ((Œªk. k * binomial n k) ‚àò SUC) n) =
    (k + 1) * binomial n (k + 1)
</pre>

<DT><span class="strong">beta_horizontal_eqn</span>
<DD>
<pre>
‚ä¢ ‚àÄn. GENLIST ((Œªk. k * binomial (n + 1) k) ‚àò SUC) (n + 1) =
      leibniz_horizontal n
</pre>

<DT><span class="strong">beta_horizontal_len</span>
<DD>
<pre>
‚ä¢ ‚àÄn. LENGTH (GENLIST ((Œªk. k * binomial n k) ‚àò SUC) n) = n
</pre>

<DT><span class="strong">beta_horizontal_mem</span>
<DD>
<pre>
‚ä¢ ‚àÄn k.
    0 < k ‚àß k ‚â§ n ‚áí
    MEM (k * binomial n k) (GENLIST ((Œªk. k * binomial n k) ‚àò SUC) n)
</pre>

<DT><span class="strong">beta_horizontal_mem_iff</span>
<DD>
<pre>
‚ä¢ ‚àÄn k.
    MEM (k * binomial n k) (GENLIST ((Œªk. k * binomial n k) ‚àò SUC) n) ‚áî
    0 < k ‚àß k ‚â§ n
</pre>

<DT><span class="strong">beta_horizontal_member</span>
<DD>
<pre>
‚ä¢ ‚àÄn x.
    MEM x (GENLIST ((Œªk. k * binomial n k) ‚àò SUC) n) ‚áî
    ‚àÉk. 0 < k ‚àß k ‚â§ n ‚àß x = k * binomial n k
</pre>

<DT><span class="strong">beta_less_0</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. n < k ‚áí k * binomial n k = 0
</pre>

<DT><span class="strong">beta_n_0</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 * binomial n 0 = 0
</pre>

<DT><span class="strong">beta_pos</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. 0 < k ‚àß k ‚â§ n ‚áí 0 < k * binomial n k
</pre>

<DT><span class="strong">beta_sym</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. k ‚â§ n ‚áí k * binomial n k = (n ‚àí k + 1) * binomial n (n ‚àí k + 1)
</pre>

<DT><span class="strong">big_lcm_corner_transform</span>
<DD>
<pre>
‚ä¢ ‚àÄn. big_lcm (leibniz_col (n + 1)) = big_lcm (leibniz_row n (n + 1))
</pre>

<DT><span class="strong">big_lcm_count_lower_bound</span>
<DD>
<pre>
‚ä¢ ‚àÄf n.
    (‚àÄx. x ‚àà count (n + 1) ‚áí 0 < f x) ‚áí
    SUM (GENLIST f (n + 1)) ‚â§ (n + 1) * big_lcm (IMAGE f (count (n + 1)))
</pre>

<DT><span class="strong">big_lcm_eq_list_lcm</span>
<DD>
<pre>
‚ä¢ ‚àÄl. big_lcm (LIST_TO_SET l) = list_lcm l
</pre>

<DT><span class="strong">big_lcm_ge_max</span>
<DD>
<pre>
‚ä¢ ‚àÄs. FINITE s ‚àß (‚àÄx. x ‚àà s ‚áí 0 < x) ‚áí MAX_SET s ‚â§ big_lcm s
</pre>

<DT><span class="strong">big_lcm_lower_bound</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 2 ** n ‚â§ big_lcm (natural (n + 1))
</pre>

<DT><span class="strong">big_lcm_natural_eqn</span>
<DD>
<pre>
‚ä¢ ‚àÄn. big_lcm (natural (n + 1)) =
      (n + 1) * big_lcm (IMAGE (binomial n) (count (n + 1)))
</pre>

<DT><span class="strong">big_lcm_non_decreasing</span>
<DD>
<pre>
‚ä¢ ‚àÄn. big_lcm (natural n) ‚â§ big_lcm (natural (n + 1))
</pre>

<DT><span class="strong">big_lcm_row_transform</span>
<DD>
<pre>
‚ä¢ ‚àÄn h.
    lcm (leibniz (n + 1) 0) (big_lcm (leibniz_row n h)) =
    big_lcm (leibniz_row (n + 1) (h + 1))
</pre>

<DT><span class="strong">big_lcm_seg_transform</span>
<DD>
<pre>
‚ä¢ ‚àÄn k h.
    lcm (leibniz (n + 1) k) (big_lcm (leibniz_seg n k h)) =
    big_lcm (leibniz_seg (n + 1) k (h + 1))
</pre>

<DT><span class="strong">bij_eq_card</span>
<DD>
<pre>
‚ä¢ ‚àÄs t. s =b= t ‚àß (FINITE s ‚à® FINITE t) ‚áí CARD s = CARD t
</pre>

<DT><span class="strong">bij_eq_card_eq</span>
<DD>
<pre>
‚ä¢ ‚àÄs t. FINITE s ‚àß FINITE t ‚áí (s =b= t ‚áî CARD s = CARD t)
</pre>

<DT><span class="strong">bij_eq_count</span>
<DD>
<pre>
‚ä¢ ‚àÄs. FINITE s ‚áí s =b= count (CARD s)
</pre>

<DT><span class="strong">bij_eq_empty</span>
<DD>
<pre>
‚ä¢ ‚àÄs t. s =b= t ‚áí (s = ‚àÖ ‚áî t = ‚àÖ)
</pre>

<DT><span class="strong">bij_eq_equiv_on</span>
<DD>
<pre>
‚ä¢ ‚àÄP. (Œªs t. s =b= t) equiv_on P
</pre>

<DT><span class="strong">bij_eq_finite</span>
<DD>
<pre>
‚ä¢ ‚àÄs t. s =b= t ‚áí (FINITE s ‚áî FINITE t)
</pre>

<DT><span class="strong">bij_eq_refl</span>
<DD>
<pre>
‚ä¢ ‚àÄs. s =b= s
</pre>

<DT><span class="strong">bij_eq_sym</span>
<DD>
<pre>
‚ä¢ ‚àÄs t. s =b= t ‚áî t =b= s
</pre>

<DT><span class="strong">bij_eq_trans</span>
<DD>
<pre>
‚ä¢ ‚àÄs t u. s =b= t ‚àß t =b= u ‚áí s =b= u
</pre>

<DT><span class="strong">bij_iff_preimage_card_eq_1</span>
<DD>
<pre>
‚ä¢ ‚àÄf s t.
    FINITE s ‚àß (‚àÄx. x ‚àà s ‚áí f x ‚àà t) ‚áí
    (BIJ f s t ‚áî ‚àÄy. y ‚àà t ‚áí CARD (preimage f s y) = 1)
</pre>

<DT><span class="strong">bij_preimage_sing</span>
<DD>
<pre>
‚ä¢ ‚àÄf s t.
    BIJ f s t ‚áî (‚àÄx. x ‚àà s ‚áí f x ‚àà t) ‚àß ‚àÄy. y ‚àà t ‚áí SING (preimage f s y)
</pre>

<DT><span class="strong">binomial_0_n</span>
<DD>
<pre>
‚ä¢ ‚àÄn. binomial 0 n = if n = 0 then 1 else 0
</pre>

<DT><span class="strong">binomial_1_n</span>
<DD>
<pre>
‚ä¢ ‚àÄn. binomial 1 n = if 1 < n then 0 else 1
</pre>

<DT><span class="strong">binomial_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn k.
    binomial n 0 = 1 ‚àß binomial 0 (k + 1) = 0 ‚àß
    binomial (n + 1) (k + 1) = binomial n k + binomial n (k + 1)
</pre>

<DT><span class="strong">binomial_compute</span>
<DD>
<pre>
‚ä¢ binomial 0 0 = 1 ‚àß (‚àÄn. binomial <..num comp'n..> 0 = 1) ‚àß
  (‚àÄn. binomial <..num comp'n..> 0 = 1) ‚àß
  (‚àÄk. binomial 0 <..num comp'n..> = 0) ‚àß
  (‚àÄk. binomial 0 <..num comp'n..> = 0) ‚àß
  (‚àÄn k.
     binomial <..num comp'n..> <..num comp'n..> =
     binomial (<..num comp'n..> ‚àí 1) (<..num comp'n..> ‚àí 1) +
     binomial (<..num comp'n..> ‚àí 1) <..num comp'n..> ) ‚àß
  (‚àÄn k.
     binomial <..num comp'n..> <..num comp'n..> =
     binomial <..num comp'n..> (<..num comp'n..> ‚àí 1) +
     binomial <..num comp'n..> <..num comp'n..> ) ‚àß
  (‚àÄn k.
     binomial <..num comp'n..> <..num comp'n..> =
     binomial (<..num comp'n..> ‚àí 1) <..num comp'n..> +
     binomial (<..num comp'n..> ‚àí 1) <..num comp'n..> ) ‚àß
  ‚àÄn k.
    binomial <..num comp'n..> <..num comp'n..> =
    binomial <..num comp'n..> <..num comp'n..> +
    binomial <..num comp'n..> <..num comp'n..>
</pre>

<DT><span class="strong">binomial_def</span>
<DD>
<pre>
‚ä¢ binomial 0 0 = 1 ‚àß (‚àÄn. binomial (SUC n) 0 = 1) ‚àß
  (‚àÄk. binomial 0 (SUC k) = 0) ‚àß
  ‚àÄn k. binomial (SUC n) (SUC k) = binomial n k + binomial n (SUC k)
</pre>

<DT><span class="strong">binomial_eq_0</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. binomial n k = 0 ‚áî n < k
</pre>

<DT><span class="strong">binomial_fact</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. k ‚â§ n ‚áí binomial n k = FACT n DIV (FACT k * FACT (n ‚àí k))
</pre>

<DT><span class="strong">binomial_formula</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. binomial (n + k) k * (FACT n * FACT k) = FACT (n + k)
</pre>

<DT><span class="strong">binomial_formula2</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. k ‚â§ n ‚áí FACT n = binomial n k * (FACT (n ‚àí k) * FACT k)
</pre>

<DT><span class="strong">binomial_formula3</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. k ‚â§ n ‚áí binomial n k = FACT n DIV (FACT k * FACT (n ‚àí k))
</pre>

<DT><span class="strong">binomial_horizontal_0</span>
<DD>
<pre>
‚ä¢ binomial_horizontal 0 = [1]
</pre>

<DT><span class="strong">binomial_horizontal_element</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. k ‚â§ n ‚áí EL k (binomial_horizontal n) = binomial n k
</pre>

<DT><span class="strong">binomial_horizontal_len</span>
<DD>
<pre>
‚ä¢ ‚àÄn. LENGTH (binomial_horizontal n) = n + 1
</pre>

<DT><span class="strong">binomial_horizontal_max</span>
<DD>
<pre>
‚ä¢ ‚àÄn. MAX_LIST (binomial_horizontal n) = binomial n (n DIV 2)
</pre>

<DT><span class="strong">binomial_horizontal_mem</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. k < n + 1 ‚áí MEM (binomial n k) (binomial_horizontal n)
</pre>

<DT><span class="strong">binomial_horizontal_mem_iff</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. MEM (binomial n k) (binomial_horizontal n) ‚áî k ‚â§ n
</pre>

<DT><span class="strong">binomial_horizontal_member</span>
<DD>
<pre>
‚ä¢ ‚àÄn x. MEM x (binomial_horizontal n) ‚áî ‚àÉk. k ‚â§ n ‚àß x = binomial n k
</pre>

<DT><span class="strong">binomial_horizontal_pos</span>
<DD>
<pre>
‚ä¢ ‚àÄn. EVERY_POSITIVE (binomial_horizontal n)
</pre>

<DT><span class="strong">binomial_horizontal_pos_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn x. MEM x (binomial_horizontal n) ‚áí 0 < x
</pre>

<DT><span class="strong">binomial_horizontal_sum</span>
<DD>
<pre>
‚ä¢ ‚àÄn. SUM (binomial_horizontal n) = 2 ** n
</pre>

<DT><span class="strong">binomial_iff</span>
<DD>
<pre>
‚ä¢ ‚àÄf. f = binomial ‚áî
      ‚àÄn k.
        f n 0 = 1 ‚àß f 0 (k + 1) = 0 ‚àß f (n + 1) (k + 1) = f n k + f n (k + 1)
</pre>

<DT><span class="strong">binomial_ind</span>
<DD>
<pre>
‚ä¢ ‚àÄP. P 0 0 ‚àß (‚àÄn. P (SUC n) 0) ‚àß (‚àÄk. P 0 (SUC k)) ‚àß
      (‚àÄn k. P n k ‚àß P n (SUC k) ‚áí P (SUC n) (SUC k)) ‚áí
      ‚àÄv v1. P v v1
</pre>

<DT><span class="strong">binomial_index_shift</span>
<DD>
<pre>
‚ä¢ ‚àÄn x y.
    (Œªk. binomial (SUC n) k * x ** (SUC n ‚àí k) * y ** k) ‚àò SUC =
    (Œªk. binomial (SUC n) (SUC k) * x ** (n ‚àí k) * y ** SUC k)
</pre>

<DT><span class="strong">binomial_is_integer</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. k ‚â§ n ‚áí FACT k * FACT (n ‚àí k) divides FACT n
</pre>

<DT><span class="strong">binomial_less_0</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. n < k ‚áí binomial n k = 0
</pre>

<DT><span class="strong">binomial_max</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. binomial n k ‚â§ binomial n (n DIV 2)
</pre>

<DT><span class="strong">binomial_middle_by_stirling</span>
<DD>
<pre>
‚ä¢ Stirling ‚áí
  ‚àÄn. 0 < n ‚àß EVEN n ‚áí
      binomial n (n DIV 2) = 2 ** (n + 1) DIV SQRT (2 * pi * n)
</pre>

<DT><span class="strong">binomial_middle_upper_bound</span>
<DD>
<pre>
‚ä¢ ‚àÄn. binomial n (n DIV 2) ‚â§ 4 ** (n DIV 2)
</pre>

<DT><span class="strong">binomial_mod_zero</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 < n ‚áí
      ‚àÄk. binomial n k MOD n = 0 ‚áî
          ‚àÄx y. (binomial n k * x ** (n ‚àí k) * y ** k) MOD n = 0
</pre>

<DT><span class="strong">binomial_mod_zero_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 < n ‚áí
      ((‚àÄk. 0 < k ‚àß k < n ‚áí binomial n k MOD n = 0) ‚áî
       ‚àÄx y.
         SUM
           (GENLIST ((Œªk. (binomial n k * x ** (n ‚àí k) * y ** k) MOD n) ‚àò SUC)
              (PRE n)) = 0)
</pre>

<DT><span class="strong">binomial_monotone</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. k < n DIV 2 ‚áí binomial n k < binomial n (k + 1)
</pre>

<DT><span class="strong">binomial_n_0</span>
<DD>
<pre>
‚ä¢ ‚àÄn. binomial n 0 = 1
</pre>

<DT><span class="strong">binomial_n_1</span>
<DD>
<pre>
‚ä¢ ‚àÄn. binomial n 1 = n
</pre>

<DT><span class="strong">binomial_n_k</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. k ‚â§ n ‚áí binomial n k = FACT n DIV FACT k DIV FACT (n ‚àí k)
</pre>

<DT><span class="strong">binomial_n_n</span>
<DD>
<pre>
‚ä¢ ‚àÄn. binomial n n = 1
</pre>

<DT><span class="strong">binomial_pos</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. k ‚â§ n ‚áí 0 < binomial n k
</pre>

<DT><span class="strong">binomial_product_identity</span>
<DD>
<pre>
‚ä¢ ‚àÄm n k.
    k ‚â§ m ‚àß m ‚â§ n ‚áí
    binomial m k * binomial n m = binomial n k * binomial (n ‚àí k) (m ‚àí k)
</pre>

<DT><span class="strong">binomial_range_shift</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 < n ‚áí
      ((‚àÄk. 0 < k ‚àß k < n ‚áí binomial n k MOD n = 0) ‚áî
       ‚àÄh. h < PRE n ‚áí binomial n (SUC h) MOD n = 0)
</pre>

<DT><span class="strong">binomial_range_shift_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 < n ‚áí
      ((‚àÄk. 0 < k ‚àß k < n ‚áí
            ‚àÄx y. (binomial n k * x ** (n ‚àí k) * y ** k) MOD n = 0) ‚áî
       ‚àÄh. h < PRE n ‚áí
           ‚àÄx y.
             (binomial n (SUC h) * x ** (n ‚àí SUC h) * y ** SUC h) MOD n = 0)
</pre>

<DT><span class="strong">binomial_recurrence</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. binomial (SUC n) (SUC k) = binomial n k + binomial n (SUC k)
</pre>

<DT><span class="strong">binomial_right</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 < n ‚áí ‚àÄk. binomial n (k + 1) = (n ‚àí k) * binomial n k DIV (k + 1)
</pre>

<DT><span class="strong">binomial_right_eqn</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 < n ‚áí ‚àÄk. (k + 1) * binomial n (k + 1) = (n ‚àí k) * binomial n k
</pre>

<DT><span class="strong">binomial_row_max</span>
<DD>
<pre>
‚ä¢ ‚àÄn. MAX_SET (IMAGE (binomial n) (count (n + 1))) = binomial n (n DIV 2)
</pre>

<DT><span class="strong">binomial_sum</span>
<DD>
<pre>
‚ä¢ ‚àÄn. SUM (GENLIST (binomial n) (SUC n)) = 2 ** n
</pre>

<DT><span class="strong">binomial_sum_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn. SUM (binomial_horizontal n) = 2 ** n
</pre>

<DT><span class="strong">binomial_sym</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. k ‚â§ n ‚áí binomial n k = binomial n (n ‚àí k)
</pre>

<DT><span class="strong">binomial_term_merge_x</span>
<DD>
<pre>
‚ä¢ ‚àÄn x y.
    (Œªk. x * k) ‚àò (Œªk. binomial n k * x ** (n ‚àí k) * y ** k) =
    (Œªk. binomial n k * x ** SUC (n ‚àí k) * y ** k)
</pre>

<DT><span class="strong">binomial_term_merge_y</span>
<DD>
<pre>
‚ä¢ ‚àÄn x y.
    (Œªk. y * k) ‚àò (Œªk. binomial n k * x ** (n ‚àí k) * y ** k) =
    (Œªk. binomial n k * x ** (n ‚àí k) * y ** SUC k)
</pre>

<DT><span class="strong">binomial_thm</span>
<DD>
<pre>
‚ä¢ ‚àÄn x y.
    (x + y) ** n =
    SUM (GENLIST (Œªk. binomial n k * x ** (n ‚àí k) * y ** k) (SUC n))
</pre>

<DT><span class="strong">binomial_thm_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn x y.
    (x + y) ** n =
    SUM (GENLIST (Œªk. binomial n k * x ** (n ‚àí k) * y ** k) (n + 1))
</pre>

<DT><span class="strong">binomial_thm_prime</span>
<DD>
<pre>
‚ä¢ ‚àÄp. prime p ‚áí ‚àÄx y. (x + y) ** p MOD p = (x ** p + y ** p) MOD p
</pre>

<DT><span class="strong">binomial_up</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 < n ‚áí ‚àÄk. binomial (n ‚àí 1) k = (n ‚àí k) * binomial n k DIV n
</pre>

<DT><span class="strong">binomial_up_eqn</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 < n ‚áí ‚àÄk. n * binomial (n ‚àí 1) k = (n ‚àí k) * binomial n k
</pre>

<DT><span class="strong">choose_0_n</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 choose n = if n = 0 then 1 else 0
</pre>

<DT><span class="strong">choose_1_n</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 1 choose n = if 1 < n then 0 else 1
</pre>

<DT><span class="strong">choose_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn k.
    n choose 0 = 1 ‚àß 0 choose (k + 1) = 0 ‚àß
    (n + 1) choose (k + 1) = n choose k + n choose (k + 1)
</pre>

<DT><span class="strong">choose_eq_0</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. n choose k = 0 ‚áî n < k
</pre>

<DT><span class="strong">choose_eqn</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. n choose k = binomial n k
</pre>

<DT><span class="strong">choose_n_0</span>
<DD>
<pre>
‚ä¢ ‚àÄn. n choose 0 = 1
</pre>

<DT><span class="strong">choose_n_1</span>
<DD>
<pre>
‚ä¢ ‚àÄn. n choose 1 = n
</pre>

<DT><span class="strong">choose_n_n</span>
<DD>
<pre>
‚ä¢ ‚àÄn. n choose n = 1
</pre>

<DT><span class="strong">choose_recurrence</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. (n + 1) choose (k + 1) = n choose k + n choose (k + 1)
</pre>

<DT><span class="strong">choose_sum_over_all</span>
<DD>
<pre>
‚ä¢ ‚àÄn. SUM (MAP ($choose n) [0 .. n]) = 2 ** n
</pre>

<DT><span class="strong">choose_sum_over_count</span>
<DD>
<pre>
‚ä¢ ‚àÄn. ‚àë ($choose n) (upto n) = 2 ** n
</pre>

<DT><span class="strong">count_power_partition</span>
<DD>
<pre>
‚ä¢ ‚àÄn. partition (Œªs t. s =b= t) (POW (count n)) = IMAGE (sub_count n) (upto n)
</pre>

<DT><span class="strong">datatype_triple</span>
<DD>
<pre>
‚ä¢ DATATYPE (record triple a b c)
</pre>

<DT><span class="strong">divides_binomials_imp_prime</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 1 < n ‚àß (‚àÄk. 0 < k ‚àß k < n ‚áí n divides binomial n k) ‚áí prime n
</pre>

<DT><span class="strong">feq_set_equiv</span>
<DD>
<pre>
‚ä¢ ‚àÄs. feq LIST_TO_SET equiv_on s
</pre>

<DT><span class="strong">finite_surj_inj_iff</span>
<DD>
<pre>
‚ä¢ ‚àÄf s t.
    FINITE s ‚àß SURJ f s t ‚áí
    (INJ f s t ‚áî ‚àÄe. e ‚àà IMAGE (preimage f s) t ‚áí CARD e = 1)
</pre>

<DT><span class="strong">gcd_prime_product_property</span>
<DD>
<pre>
‚ä¢ ‚àÄp m n. prime p ‚àß m divides n ‚àß ¬¨(p * m divides n) ‚áí gcd (p * m) n = m
</pre>

<DT><span class="strong">geometric_sum_eqn</span>
<DD>
<pre>
‚ä¢ ‚àÄt n. 1 < t ‚áí SUM (MAP (Œªj. t ** j) [0 ..< n]) = tops t n DIV (t ‚àí 1)
</pre>

<DT><span class="strong">geometric_sum_eqn_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄt n. 1 < t ‚áí SUM (MAP (Œªj. t ** j) [0 .. n]) = tops t (n + 1) DIV (t ‚àí 1)
</pre>

<DT><span class="strong">head_turn</span>
<DD>
<pre>
‚ä¢ ‚àÄls. ls ‚â† [] ‚áí HD (turn ls) = LAST ls
</pre>

<DT><span class="strong">head_turn_exp</span>
<DD>
<pre>
‚ä¢ ‚àÄls n.
    n < LENGTH ls ‚áí
    HD (turn_exp ls n) = EL (if n = 0 then 0 else (LENGTH ls ‚àí n)) ls
</pre>

<DT><span class="strong">inj_iff_preimage_card_le_1</span>
<DD>
<pre>
‚ä¢ ‚àÄf s t.
    FINITE s ‚àß (‚àÄx. x ‚àà s ‚áí f x ‚àà t) ‚áí
    (INJ f s t ‚áî ‚àÄy. y ‚àà t ‚áí CARD (preimage f s y) ‚â§ 1)
</pre>

<DT><span class="strong">inj_preimage_empty_or_sing</span>
<DD>
<pre>
‚ä¢ ‚àÄf s t.
    INJ f s t ‚áî
    (‚àÄx. x ‚àà s ‚áí f x ‚àà t) ‚àß
    ‚àÄy. y ‚àà t ‚áí preimage f s y = ‚àÖ ‚à® SING (preimage f s y)
</pre>

<DT><span class="strong">interleave_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄls x. x interleave ls = {TAKE k ls ++ x::DROP k ls | k | k ‚â§ LENGTH ls}
</pre>

<DT><span class="strong">interleave_card</span>
<DD>
<pre>
‚ä¢ ‚àÄls x. ¬¨MEM x ls ‚áí CARD (x interleave ls) = 1 + LENGTH ls
</pre>

<DT><span class="strong">interleave_count_inj</span>
<DD>
<pre>
‚ä¢ ‚àÄls x.
    ¬¨MEM x ls ‚áí
    INJ (Œªk. TAKE k ls ++ x::DROP k ls) (upto (LENGTH ls)) ùïå(:Œ± list)
</pre>

<DT><span class="strong">interleave_disjoint</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2 x. ¬¨MEM x l1 ‚àß l1 ‚â† l2 ‚áí DISJOINT (x interleave l1) (x interleave l2)
</pre>

<DT><span class="strong">interleave_distinct</span>
<DD>
<pre>
‚ä¢ ‚àÄls x y. ALL_DISTINCT (x::ls) ‚àß y ‚àà x interleave ls ‚áí ALL_DISTINCT y
</pre>

<DT><span class="strong">interleave_distinct_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄls x y. ALL_DISTINCT ls ‚àß ¬¨MEM x ls ‚àß y ‚àà x interleave ls ‚áí ALL_DISTINCT y
</pre>

<DT><span class="strong">interleave_element</span>
<DD>
<pre>
‚ä¢ ‚àÄls x y.
    y ‚àà x interleave ls ‚áî ‚àÉk. k ‚â§ LENGTH ls ‚àß y = TAKE k ls ++ x::DROP k ls
</pre>

<DT><span class="strong">interleave_eq</span>
<DD>
<pre>
‚ä¢ ‚àÄn x y. ¬¨MEM n x ‚àß ¬¨MEM n y ‚áí (n interleave x = n interleave y ‚áî x = y)
</pre>

<DT><span class="strong">interleave_finite</span>
<DD>
<pre>
‚ä¢ ‚àÄls x. FINITE (x interleave ls)
</pre>

<DT><span class="strong">interleave_has_cons</span>
<DD>
<pre>
‚ä¢ ‚àÄls x. x::ls ‚àà x interleave ls
</pre>

<DT><span class="strong">interleave_length</span>
<DD>
<pre>
‚ä¢ ‚àÄls x y. y ‚àà x interleave ls ‚áí LENGTH y = 1 + LENGTH ls
</pre>

<DT><span class="strong">interleave_nil</span>
<DD>
<pre>
‚ä¢ ‚àÄx. x interleave [] = {[x]}
</pre>

<DT><span class="strong">interleave_not_empty</span>
<DD>
<pre>
‚ä¢ ‚àÄls x. x interleave ls ‚â† ‚àÖ
</pre>

<DT><span class="strong">interleave_revert</span>
<DD>
<pre>
‚ä¢ ‚àÄls h.
    ALL_DISTINCT ls ‚àß MEM h ls ‚áí
    ‚àÉt. ALL_DISTINCT t ‚àß ls ‚àà h interleave t ‚àß
        LIST_TO_SET t = LIST_TO_SET ls DELETE h
</pre>

<DT><span class="strong">interleave_revert_count</span>
<DD>
<pre>
‚ä¢ ‚àÄls n.
    ALL_DISTINCT ls ‚àß LIST_TO_SET ls = upto n ‚áí
    ‚àÉt. ALL_DISTINCT t ‚àß ls ‚àà n interleave t ‚àß LIST_TO_SET t = count n
</pre>

<DT><span class="strong">interleave_set</span>
<DD>
<pre>
‚ä¢ ‚àÄls x y. y ‚àà x interleave ls ‚áí LIST_TO_SET y = LIST_TO_SET (x::ls)
</pre>

<DT><span class="strong">interleave_set_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄls x y. y ‚àà x interleave ls ‚áí LIST_TO_SET y = x INSERT LIST_TO_SET ls
</pre>

<DT><span class="strong">lcm_lower_bound</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 2 ** n ‚â§ lcm_run (n + 1)
</pre>

<DT><span class="strong">lcm_lower_bound_by_big_lcm</span>
<DD>
<pre>
‚ä¢ ‚àÄn. (n + 1) * binomial n (n DIV 2) ‚â§ big_lcm (natural (n + 1))
</pre>

<DT><span class="strong">lcm_lower_bound_by_big_lcm_stirling</span>
<DD>
<pre>
‚ä¢ Stirling ‚àß (‚àÄn c. n DIV SQRT (c * (n ‚àí 1)) = SQRT (n DIV c)) ‚áí
  ‚àÄn. ODD n ‚áí SQRT (n DIV (2 * pi)) * 2 ** n ‚â§ big_lcm (natural n)
</pre>

<DT><span class="strong">lcm_lower_bound_by_list_lcm</span>
<DD>
<pre>
‚ä¢ ‚àÄn. (n + 1) * binomial n (n DIV 2) ‚â§ lcm_run (n + 1)
</pre>

<DT><span class="strong">lcm_lower_bound_by_list_lcm_stirling</span>
<DD>
<pre>
‚ä¢ Stirling ‚àß (‚àÄn c. n DIV SQRT (c * (n ‚àí 1)) = SQRT (n DIV c)) ‚áí
  ‚àÄn. ODD n ‚áí SQRT (n DIV (2 * pi)) * 2 ** n ‚â§ lcm_run n
</pre>

<DT><span class="strong">lcm_prime_product_property</span>
<DD>
<pre>
‚ä¢ ‚àÄp m n. prime p ‚àß m divides n ‚àß ¬¨(p * m divides n) ‚áí lcm (p * m) n = p * n
</pre>

<DT><span class="strong">lcm_run_0</span>
<DD>
<pre>
‚ä¢ lcm_run 0 = 1
</pre>

<DT><span class="strong">lcm_run_1</span>
<DD>
<pre>
‚ä¢ lcm_run 1 = 1
</pre>

<DT><span class="strong">lcm_run_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn. lcm_run n = lcm_run (n ‚àí 1 + 1)
</pre>

<DT><span class="strong">lcm_run_beta_divisor</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. 0 < k ‚àß k ‚â§ n ‚áí k * binomial n k divides lcm_run n
</pre>

<DT><span class="strong">lcm_run_bound_recurrence</span>
<DD>
<pre>
‚ä¢ ‚àÄm n. n ‚â§ 2 * m ‚àß m ‚â§ n ‚áí lcm_run n ‚â§ lcm_run m * binomial n m
</pre>

<DT><span class="strong">lcm_run_by_FOLDL</span>
<DD>
<pre>
‚ä¢ ‚àÄn. lcm_run n = FOLDL lcm 1 [1 .. n]
</pre>

<DT><span class="strong">lcm_run_by_FOLDR</span>
<DD>
<pre>
‚ä¢ ‚àÄn. lcm_run n = FOLDR lcm 1 [1 .. n]
</pre>

<DT><span class="strong">lcm_run_by_beta_horizontal</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 < n ‚áí lcm_run n = list_lcm (GENLIST ((Œªk. k * binomial n k) ‚àò SUC) n)
</pre>

<DT><span class="strong">lcm_run_divides_property</span>
<DD>
<pre>
‚ä¢ ‚àÄm n. n ‚â§ 2 * m ‚àß m ‚â§ n ‚áí lcm_run n divides lcm_run m * binomial n m
</pre>

<DT><span class="strong">lcm_run_divides_property_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄm n. n ‚â§ 2 * m ‚àß m ‚â§ n ‚áí lcm_run n divides binomial n m * lcm_run m
</pre>

<DT><span class="strong">lcm_run_divisors</span>
<DD>
<pre>
‚ä¢ ‚àÄn. n + 1 divides lcm_run (n + 1) ‚àß lcm_run n divides lcm_run (n + 1)
</pre>

<DT><span class="strong">lcm_run_even_lower</span>
<DD>
<pre>
‚ä¢ ‚àÄn. EVEN n ‚áí (n ‚àí 2) DIV 2 * (2 ** n DIV 2 DIV 2) ‚â§ lcm_run n
</pre>

<DT><span class="strong">lcm_run_even_lower_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn. EVEN n ‚àß 8 ‚â§ n ‚áí 2 ** n ‚â§ lcm_run n
</pre>

<DT><span class="strong">lcm_run_leibniz_divisor</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. k ‚â§ n ‚áí leibniz n k divides lcm_run (n + 1)
</pre>

<DT><span class="strong">lcm_run_lower</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 2 ** n ‚â§ lcm_run (n + 1)
</pre>

<DT><span class="strong">lcm_run_lower_better</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 7 ‚â§ n ‚áí 2 ** n ‚â§ lcm_run n
</pre>

<DT><span class="strong">lcm_run_lower_better_iff</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 2 ** n ‚â§ lcm_run n ‚áî n = 0 ‚à® n = 5 ‚à® 7 ‚â§ n
</pre>

<DT><span class="strong">lcm_run_lower_even</span>
<DD>
<pre>
‚ä¢ ‚àÄn. n * 4 ** n ‚â§ lcm_run (2 * (n + 1))
</pre>

<DT><span class="strong">lcm_run_lower_even_iff</span>
<DD>
<pre>
‚ä¢ ‚àÄn. EVEN n ‚áí (2 ** n ‚â§ lcm_run n ‚áî n = 0 ‚à® 8 ‚â§ n)
</pre>

<DT><span class="strong">lcm_run_lower_good</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 2 ** (n ‚àí 1) ‚â§ lcm_run n
</pre>

<DT><span class="strong">lcm_run_lower_odd</span>
<DD>
<pre>
‚ä¢ ‚àÄn. n * 4 ** n ‚â§ lcm_run (2 * n + 1)
</pre>

<DT><span class="strong">lcm_run_lower_odd_iff</span>
<DD>
<pre>
‚ä¢ ‚àÄn. ODD n ‚áí (2 ** n ‚â§ lcm_run n ‚áî 5 ‚â§ n)
</pre>

<DT><span class="strong">lcm_run_lower_simple</span>
<DD>
<pre>
‚ä¢ ‚àÄn. (n + 1) DIV 2 ‚â§ lcm_run n
</pre>

<DT><span class="strong">lcm_run_monotone</span>
<DD>
<pre>
‚ä¢ ‚àÄn. lcm_run n ‚â§ lcm_run (n + 1)
</pre>

<DT><span class="strong">lcm_run_odd_factor</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 < n ‚áí n * leibniz (2 * n) n divides lcm_run (2 * n + 1)
</pre>

<DT><span class="strong">lcm_run_odd_lower</span>
<DD>
<pre>
‚ä¢ ‚àÄn. ODD n ‚áí n DIV 2 * (2 ** n DIV 2) ‚â§ lcm_run n
</pre>

<DT><span class="strong">lcm_run_odd_lower_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn. ODD n ‚àß 5 ‚â§ n ‚áí 2 ** n ‚â§ lcm_run n
</pre>

<DT><span class="strong">lcm_run_pos</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 < lcm_run n
</pre>

<DT><span class="strong">lcm_run_small</span>
<DD>
<pre>
‚ä¢ lcm_run 2 = 2 ‚àß lcm_run 3 = 6 ‚àß lcm_run 4 = 12 ‚àß lcm_run 5 = 60 ‚àß
  lcm_run 6 = 60 ‚àß lcm_run 7 = 420 ‚àß lcm_run 8 = 840 ‚àß lcm_run 9 = 2520
</pre>

<DT><span class="strong">lcm_run_suc</span>
<DD>
<pre>
‚ä¢ ‚àÄn. lcm_run (n + 1) = lcm (n + 1) (lcm_run n)
</pre>

<DT><span class="strong">lcm_run_upper_bound</span>
<DD>
<pre>
‚ä¢ ‚àÄn. lcm_run n ‚â§ 4 ** n
</pre>

<DT><span class="strong">lcm_upto_0</span>
<DD>
<pre>
‚ä¢ lcm_upto 0 = 1
</pre>

<DT><span class="strong">lcm_upto_1</span>
<DD>
<pre>
‚ä¢ lcm_upto 1 = 1
</pre>

<DT><span class="strong">lcm_upto_SUC</span>
<DD>
<pre>
‚ä¢ ‚àÄn. lcm_upto (SUC n) = lcm (SUC n) (lcm_upto n)
</pre>

<DT><span class="strong">lcm_upto_alt</span>
<DD>
<pre>
‚ä¢ lcm_upto 0 = 1 ‚àß ‚àÄn. lcm_upto (n + 1) = lcm (n + 1) (lcm_upto n)
</pre>

<DT><span class="strong">lcm_upto_compute</span>
<DD>
<pre>
‚ä¢ lcm_upto 0 = 1 ‚àß
  (‚àÄn. lcm_upto <..num comp'n..> =
       lcm <..num comp'n..> (lcm_upto (<..num comp'n..> ‚àí 1))) ‚àß
  ‚àÄn. lcm_upto <..num comp'n..> =
      lcm <..num comp'n..> (lcm_upto <..num comp'n..> )
</pre>

<DT><span class="strong">lcm_upto_divisors</span>
<DD>
<pre>
‚ä¢ ‚àÄn. n + 1 divides lcm_upto (n + 1) ‚àß lcm_upto n divides lcm_upto (n + 1)
</pre>

<DT><span class="strong">lcm_upto_eq_list_lcm</span>
<DD>
<pre>
‚ä¢ ‚àÄn. lcm_upto n = lcm_run n
</pre>

<DT><span class="strong">lcm_upto_leibniz_divisor</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. k ‚â§ n ‚áí leibniz n k divides lcm_upto (n + 1)
</pre>

<DT><span class="strong">lcm_upto_lower</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 2 ** n ‚â§ lcm_upto (n + 1)
</pre>

<DT><span class="strong">lcm_upto_lower_better</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 7 ‚â§ n ‚áí 2 ** n ‚â§ lcm_upto n
</pre>

<DT><span class="strong">lcm_upto_lower_even</span>
<DD>
<pre>
‚ä¢ ‚àÄn. n * 4 ** n ‚â§ lcm_upto (2 * (n + 1))
</pre>

<DT><span class="strong">lcm_upto_lower_odd</span>
<DD>
<pre>
‚ä¢ ‚àÄn. n * 4 ** n ‚â§ lcm_upto (2 * n + 1)
</pre>

<DT><span class="strong">lcm_upto_monotone</span>
<DD>
<pre>
‚ä¢ ‚àÄn. lcm_upto n ‚â§ lcm_upto (n + 1)
</pre>

<DT><span class="strong">lcm_upto_pos</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 < lcm_upto (n + 1)
</pre>

<DT><span class="strong">lcm_upto_small</span>
<DD>
<pre>
‚ä¢ lcm_upto 2 = 2 ‚àß lcm_upto 3 = 6 ‚àß lcm_upto 4 = 12 ‚àß lcm_upto 5 = 60 ‚àß
  lcm_upto 6 = 60 ‚àß lcm_upto 7 = 420 ‚àß lcm_upto 8 = 840 ‚àß lcm_upto 9 = 2520 ‚àß
  lcm_upto 10 = 2520
</pre>

<DT><span class="strong">leibniz_0_n</span>
<DD>
<pre>
‚ä¢ ‚àÄn. leibniz 0 n = if n = 0 then 1 else 0
</pre>

<DT><span class="strong">leibniz_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn. leibniz n = (Œªj. (n + 1) * j) ‚àò binomial n
</pre>

<DT><span class="strong">leibniz_binomial_identity</span>
<DD>
<pre>
‚ä¢ ‚àÄm n k.
    k ‚â§ m ‚àß m ‚â§ n ‚áí
    leibniz n k * binomial (n ‚àí k) (m ‚àí k) =
    leibniz m k * binomial (n + 1) (m + 1)
</pre>

<DT><span class="strong">leibniz_col_arm_0</span>
<DD>
<pre>
‚ä¢ ‚àÄa b. leibniz_col_arm a b 0 = []
</pre>

<DT><span class="strong">leibniz_col_arm_1</span>
<DD>
<pre>
‚ä¢ ‚àÄa b. leibniz_col_arm a b 1 = [leibniz a b]
</pre>

<DT><span class="strong">leibniz_col_arm_cons</span>
<DD>
<pre>
‚ä¢ ‚àÄa b n.
    leibniz_col_arm (a + 1) b (n + 1) =
    leibniz (a + 1) b::leibniz_col_arm a b n
</pre>

<DT><span class="strong">leibniz_col_arm_el</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. k < n ‚áí ‚àÄa b. EL k (leibniz_col_arm a b n) = leibniz (a ‚àí k) b
</pre>

<DT><span class="strong">leibniz_col_arm_len</span>
<DD>
<pre>
‚ä¢ ‚àÄa b n. LENGTH (leibniz_col_arm a b n) = n
</pre>

<DT><span class="strong">leibniz_col_arm_n_0</span>
<DD>
<pre>
‚ä¢ ‚àÄn. leibniz_col_arm n 0 (n + 1) = leibniz_up n
</pre>

<DT><span class="strong">leibniz_col_arm_wriggle_row_arm</span>
<DD>
<pre>
‚ä¢ ‚àÄa b n.
    b ‚â§ a ‚àß n ‚â§ a + 1 ‚àí b ‚áí
    leibniz_col_arm a b n wriggle leibniz_seg_arm a b n
</pre>

<DT><span class="strong">leibniz_col_def</span>
<DD>
<pre>
‚ä¢ ‚àÄh. leibniz_col h = {leibniz j 0 | j ‚àà count h}
</pre>

<DT><span class="strong">leibniz_col_eq_natural</span>
<DD>
<pre>
‚ä¢ ‚àÄn. leibniz_col n = natural n
</pre>

<DT><span class="strong">leibniz_def_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. leibniz n k = (Œªj. (n + 1) * j) (binomial n k)
</pre>

<DT><span class="strong">leibniz_divides_leibniz_factor</span>
<DD>
<pre>
‚ä¢ ‚àÄm n k.
    k ‚â§ m ‚àß m ‚â§ n ‚áí leibniz n k divides leibniz m k * binomial (n + 1) (m + 1)
</pre>

<DT><span class="strong">leibniz_eq_0</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. leibniz n k = 0 ‚áî n < k
</pre>

<DT><span class="strong">leibniz_eqn</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. leibniz n k = (n + 1 ‚àí k) * binomial (n + 1) k
</pre>

<DT><span class="strong">leibniz_formula</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. k ‚â§ n ‚áí leibniz n k = (n + 1) * FACT n DIV (FACT k * FACT (n ‚àí k))
</pre>

<DT><span class="strong">leibniz_horizontal_0</span>
<DD>
<pre>
‚ä¢ leibniz_horizontal 0 = [1]
</pre>

<DT><span class="strong">leibniz_horizontal_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn. leibniz_horizontal n = MAP (Œªj. (n + 1) * j) (binomial_horizontal n)
</pre>

<DT><span class="strong">leibniz_horizontal_average</span>
<DD>
<pre>
‚ä¢ ‚àÄn. SUM (leibniz_horizontal n) DIV LENGTH (leibniz_horizontal n) =
      SUM (binomial_horizontal n)
</pre>

<DT><span class="strong">leibniz_horizontal_average_eqn</span>
<DD>
<pre>
‚ä¢ ‚àÄn. SUM (leibniz_horizontal n) DIV LENGTH (leibniz_horizontal n) = 2 ** n
</pre>

<DT><span class="strong">leibniz_horizontal_divisor</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. k ‚â§ n ‚áí leibniz n k divides list_lcm (leibniz_horizontal n)
</pre>

<DT><span class="strong">leibniz_horizontal_el</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. k ‚â§ n ‚áí EL k (leibniz_horizontal n) = leibniz n k
</pre>

<DT><span class="strong">leibniz_horizontal_element</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. k ‚â§ n ‚áí EL k (leibniz_horizontal n) = leibniz n k
</pre>

<DT><span class="strong">leibniz_horizontal_head</span>
<DD>
<pre>
‚ä¢ ‚àÄn. TAKE 1 (leibniz_horizontal (n + 1)) = [n + 2]
</pre>

<DT><span class="strong">leibniz_horizontal_lcm_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn. list_lcm (leibniz_horizontal n) =
      (n + 1) * list_lcm (binomial_horizontal n)
</pre>

<DT><span class="strong">leibniz_horizontal_lcm_lower</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 2 ** n ‚â§ list_lcm (leibniz_horizontal n)
</pre>

<DT><span class="strong">leibniz_horizontal_len</span>
<DD>
<pre>
‚ä¢ ‚àÄn. LENGTH (leibniz_horizontal n) = n + 1
</pre>

<DT><span class="strong">leibniz_horizontal_mem</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. k ‚â§ n ‚áí MEM (leibniz n k) (leibniz_horizontal n)
</pre>

<DT><span class="strong">leibniz_horizontal_mem_iff</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. MEM (leibniz n k) (leibniz_horizontal n) ‚áî k ‚â§ n
</pre>

<DT><span class="strong">leibniz_horizontal_member</span>
<DD>
<pre>
‚ä¢ ‚àÄn x. MEM x (leibniz_horizontal n) ‚áî ‚àÉk. k ‚â§ n ‚àß x = leibniz n k
</pre>

<DT><span class="strong">leibniz_horizontal_member_divides</span>
<DD>
<pre>
‚ä¢ ‚àÄm n x.
    n ‚â§ 2 * m + 1 ‚àß m ‚â§ n ‚àß MEM x (leibniz_horizontal n) ‚áí
    x divides list_lcm (leibniz_horizontal m) * binomial (n + 1) (m + 1)
</pre>

<DT><span class="strong">leibniz_horizontal_pos</span>
<DD>
<pre>
‚ä¢ ‚àÄn. EVERY_POSITIVE (leibniz_horizontal n)
</pre>

<DT><span class="strong">leibniz_horizontal_pos_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn x. MEM x (leibniz_horizontal n) ‚áí 0 < x
</pre>

<DT><span class="strong">leibniz_horizontal_sum</span>
<DD>
<pre>
‚ä¢ ‚àÄn. SUM (leibniz_horizontal n) = (n + 1) * SUM (binomial_horizontal n)
</pre>

<DT><span class="strong">leibniz_horizontal_sum_eqn</span>
<DD>
<pre>
‚ä¢ ‚àÄn. SUM (leibniz_horizontal n) = (n + 1) * 2 ** n
</pre>

<DT><span class="strong">leibniz_horizontal_wriggle</span>
<DD>
<pre>
‚ä¢ ‚àÄn. [leibniz (n + 1) 0] ++ leibniz_horizontal n wriggle
      leibniz_horizontal (n + 1)
</pre>

<DT><span class="strong">leibniz_horizontal_wriggle_step</span>
<DD>
<pre>
‚ä¢ ‚àÄn k.
    k ‚â§ n + 1 ‚áí
    TAKE (k + 1) (leibniz_horizontal (n + 1)) ++ DROP k (leibniz_horizontal n) wriggle
    leibniz_horizontal (n + 1)
</pre>

<DT><span class="strong">leibniz_horizontal_zigzag</span>
<DD>
<pre>
‚ä¢ ‚àÄn k.
    k ‚â§ n ‚áí
    TAKE (k + 1) (leibniz_horizontal (n + 1)) ++ DROP k (leibniz_horizontal n) zigzag
    TAKE (k + 2) (leibniz_horizontal (n + 1)) ++
    DROP (k + 1) (leibniz_horizontal n)
</pre>

<DT><span class="strong">leibniz_lcm_exchange</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 < n ‚áí
      ‚àÄk. lcm (leibniz n k) (leibniz (n ‚àí 1) k) =
          lcm (leibniz n k) (leibniz n (k + 1))
</pre>

<DT><span class="strong">leibniz_lcm_invariance</span>
<DD>
<pre>
‚ä¢ ‚àÄa b n.
    b ‚â§ a ‚àß n ‚â§ a + 1 ‚àí b ‚áí
    list_lcm (leibniz_col_arm a b n) = list_lcm (leibniz_seg_arm a b n)
</pre>

<DT><span class="strong">leibniz_lcm_property</span>
<DD>
<pre>
‚ä¢ ‚àÄn. lcm_run (n + 1) = list_lcm (leibniz_horizontal n)
</pre>

<DT><span class="strong">leibniz_less_0</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. n < k ‚áí leibniz n k = 0
</pre>

<DT><span class="strong">leibniz_middle_lower</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 4 ** n ‚â§ leibniz (2 * n) n
</pre>

<DT><span class="strong">leibniz_monotone</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. k < n DIV 2 ‚áí leibniz n k < leibniz n (k + 1)
</pre>

<DT><span class="strong">leibniz_n_0</span>
<DD>
<pre>
‚ä¢ ‚àÄn. leibniz n 0 = n + 1
</pre>

<DT><span class="strong">leibniz_n_k</span>
<DD>
<pre>
‚ä¢ ‚àÄn k.
    0 < k ‚àß k ‚â§ n ‚áí
    leibniz n k =
    leibniz n (k ‚àí 1) * leibniz (n ‚àí 1) (k ‚àí 1) DIV
    (leibniz n (k ‚àí 1) ‚àí leibniz (n ‚àí 1) (k ‚àí 1))
</pre>

<DT><span class="strong">leibniz_n_n</span>
<DD>
<pre>
‚ä¢ ‚àÄn. leibniz n n = n + 1
</pre>

<DT><span class="strong">leibniz_pos</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. k ‚â§ n ‚áí 0 < leibniz n k
</pre>

<DT><span class="strong">leibniz_property</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 < n ‚áí
      ‚àÄk. leibniz n k * leibniz (n ‚àí 1) k =
          leibniz n (k + 1) * (leibniz n k ‚àí leibniz (n ‚àí 1) k)
</pre>

<DT><span class="strong">leibniz_recurrence</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 < n ‚áí
      ‚àÄk. k < n ‚áí
          leibniz n (k + 1) =
          leibniz n k * leibniz (n ‚àí 1) k DIV
          (leibniz n k ‚àí leibniz (n ‚àí 1) k)
</pre>

<DT><span class="strong">leibniz_right</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 < n ‚áí ‚àÄk. leibniz n (k + 1) = (n ‚àí k) * leibniz n k DIV (k + 1)
</pre>

<DT><span class="strong">leibniz_right_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. leibniz n (k + 1) = (n ‚àí k) * binomial (n + 1) (k + 1)
</pre>

<DT><span class="strong">leibniz_right_entry</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. (k + 1) * (triplet n k).c = (n + 1 ‚àí k) * (triplet n k).b
</pre>

<DT><span class="strong">leibniz_right_eqn</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 < n ‚áí ‚àÄk. (k + 1) * leibniz n (k + 1) = (n ‚àí k) * leibniz n k
</pre>

<DT><span class="strong">leibniz_row_def</span>
<DD>
<pre>
‚ä¢ ‚àÄn h. leibniz_row n h = {leibniz n j | j ‚àà count h}
</pre>

<DT><span class="strong">leibniz_seg_arm_0</span>
<DD>
<pre>
‚ä¢ ‚àÄa b. leibniz_seg_arm a b 0 = []
</pre>

<DT><span class="strong">leibniz_seg_arm_1</span>
<DD>
<pre>
‚ä¢ ‚àÄa b. leibniz_seg_arm a b 1 = [leibniz a b]
</pre>

<DT><span class="strong">leibniz_seg_arm_el</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. k < n ‚áí ‚àÄa b. EL k (leibniz_seg_arm a b n) = leibniz a (b + k)
</pre>

<DT><span class="strong">leibniz_seg_arm_head</span>
<DD>
<pre>
‚ä¢ ‚àÄa b n. TAKE 1 (leibniz_seg_arm a b (n + 1)) = [leibniz a b]
</pre>

<DT><span class="strong">leibniz_seg_arm_len</span>
<DD>
<pre>
‚ä¢ ‚àÄa b n. LENGTH (leibniz_seg_arm a b n) = n
</pre>

<DT><span class="strong">leibniz_seg_arm_n_0</span>
<DD>
<pre>
‚ä¢ ‚àÄn. leibniz_seg_arm n 0 (n + 1) = leibniz_horizontal n
</pre>

<DT><span class="strong">leibniz_seg_arm_wriggle_row_arm</span>
<DD>
<pre>
‚ä¢ ‚àÄa b n.
    [leibniz (a + 1) b] ++ leibniz_seg_arm a b n wriggle
    leibniz_seg_arm (a + 1) b (n + 1)
</pre>

<DT><span class="strong">leibniz_seg_arm_wriggle_step</span>
<DD>
<pre>
‚ä¢ ‚àÄn k.
    k < n + 1 ‚áí
    ‚àÄa b.
      TAKE (k + 1) (leibniz_seg_arm (a + 1) b (n + 1)) ++
      DROP k (leibniz_seg_arm a b n) wriggle leibniz_seg_arm (a + 1) b (n + 1)
</pre>

<DT><span class="strong">leibniz_seg_arm_zigzag_step</span>
<DD>
<pre>
‚ä¢ ‚àÄn k.
    k < n ‚áí
    ‚àÄa b.
      TAKE (k + 1) (leibniz_seg_arm (a + 1) b (n + 1)) ++
      DROP k (leibniz_seg_arm a b n) zigzag
      TAKE (k + 2) (leibniz_seg_arm (a + 1) b (n + 1)) ++
      DROP (k + 1) (leibniz_seg_arm a b n)
</pre>

<DT><span class="strong">leibniz_seg_def</span>
<DD>
<pre>
‚ä¢ ‚àÄn k h. leibniz_seg n k h = {leibniz n (k + j) | j ‚àà count h}
</pre>

<DT><span class="strong">leibniz_sym</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. k ‚â§ n ‚áí leibniz n k = leibniz n (n ‚àí k)
</pre>

<DT><span class="strong">leibniz_triplet_0</span>
<DD>
<pre>
‚ä¢ leibniz_up 1 zigzag leibniz_horizontal 1
</pre>

<DT><span class="strong">leibniz_triplet_lcm</span>
<DD>
<pre>
‚ä¢ ‚àÄn k.
    lcm (triplet n k).b (triplet n k).a = lcm (triplet n k).b (triplet n k).c
</pre>

<DT><span class="strong">leibniz_triplet_member</span>
<DD>
<pre>
‚ä¢ ‚àÄn k.
    (triplet n k).a = leibniz n k ‚àß (triplet n k).b = leibniz (n + 1) k ‚àß
    (triplet n k).c = leibniz (n + 1) (k + 1)
</pre>

<DT><span class="strong">leibniz_triplet_property</span>
<DD>
<pre>
‚ä¢ ‚àÄn' k.
    (triplet n k).a * (triplet n k).b =
    (triplet n k).c * ((triplet n k).b ‚àí (triplet n k).a)
</pre>

<DT><span class="strong">leibniz_up</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 < n ‚áí ‚àÄk. leibniz (n ‚àí 1) k = (n ‚àí k) * leibniz n k DIV (n + 1)
</pre>

<DT><span class="strong">leibniz_up_0</span>
<DD>
<pre>
‚ä¢ leibniz_up 0 = [1]
</pre>

<DT><span class="strong">leibniz_up_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 < n ‚áí ‚àÄk. leibniz (n ‚àí 1) k = (n ‚àí k) * binomial n k
</pre>

<DT><span class="strong">leibniz_up_cons</span>
<DD>
<pre>
‚ä¢ ‚àÄn. leibniz_up (n + 1) = n + 2::leibniz_up n
</pre>

<DT><span class="strong">leibniz_up_entry</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. (n + 2) * (triplet n k).a = (n + 1 ‚àí k) * (triplet n k).b
</pre>

<DT><span class="strong">leibniz_up_eqn</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 < n ‚áí ‚àÄk. (n + 1) * leibniz (n ‚àí 1) k = (n ‚àí k) * leibniz n k
</pre>

<DT><span class="strong">leibniz_up_lcm_eq_horizontal_lcm</span>
<DD>
<pre>
‚ä¢ ‚àÄn. list_lcm (leibniz_up n) = list_lcm (leibniz_horizontal n)
</pre>

<DT><span class="strong">leibniz_up_len</span>
<DD>
<pre>
‚ä¢ ‚àÄn. LENGTH (leibniz_up n) = n + 1
</pre>

<DT><span class="strong">leibniz_up_mem</span>
<DD>
<pre>
‚ä¢ ‚àÄn x. 0 < x ‚àß x ‚â§ n + 1 ‚áî MEM x (leibniz_up n)
</pre>

<DT><span class="strong">leibniz_up_pos</span>
<DD>
<pre>
‚ä¢ ‚àÄn. EVERY_POSITIVE (leibniz_up n)
</pre>

<DT><span class="strong">leibniz_up_wriggle_horizontal</span>
<DD>
<pre>
‚ä¢ ‚àÄn. leibniz_up n wriggle leibniz_horizontal n
</pre>

<DT><span class="strong">leibniz_up_wriggle_horizontal_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn. leibniz_up n wriggle leibniz_horizontal n
</pre>

<DT><span class="strong">leibniz_vertical_0</span>
<DD>
<pre>
‚ä¢ leibniz_vertical 0 = [1]
</pre>

<DT><span class="strong">leibniz_vertical_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn. leibniz_vertical n = GENLIST (Œªi. 1 + i) (n + 1)
</pre>

<DT><span class="strong">leibniz_vertical_divisor</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. k ‚â§ n ‚áí leibniz n k divides lcm_run (n + 1)
</pre>

<DT><span class="strong">leibniz_vertical_lcm_lower</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 2 ** n ‚â§ lcm_run (n + 1)
</pre>

<DT><span class="strong">leibniz_vertical_len</span>
<DD>
<pre>
‚ä¢ ‚àÄn. LENGTH (leibniz_vertical n) = n + 1
</pre>

<DT><span class="strong">leibniz_vertical_mem</span>
<DD>
<pre>
‚ä¢ ‚àÄn x. 0 < x ‚àß x ‚â§ n + 1 ‚áî MEM x (leibniz_vertical n)
</pre>

<DT><span class="strong">leibniz_vertical_not_nil</span>
<DD>
<pre>
‚ä¢ ‚àÄn. leibniz_vertical n ‚â† []
</pre>

<DT><span class="strong">leibniz_vertical_pos</span>
<DD>
<pre>
‚ä¢ ‚àÄn. EVERY_POSITIVE (leibniz_vertical n)
</pre>

<DT><span class="strong">leibniz_vertical_pos_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn x. MEM x (leibniz_vertical n) ‚áí 0 < x
</pre>

<DT><span class="strong">leibniz_vertical_snoc</span>
<DD>
<pre>
‚ä¢ ‚àÄn. leibniz_vertical (n + 1) = SNOC (n + 2) (leibniz_vertical n)
</pre>

<DT><span class="strong">leibniz_wriggle_refl</span>
<DD>
<pre>
‚ä¢ ‚àÄp1. p1 wriggle p1
</pre>

<DT><span class="strong">leibniz_wriggle_tail</span>
<DD>
<pre>
‚ä¢ ‚àÄp1 p2. p1 wriggle p2 ‚áí ‚àÄx. [x] ++ p1 wriggle [x] ++ p2
</pre>

<DT><span class="strong">leibniz_wriggle_trans</span>
<DD>
<pre>
‚ä¢ ‚àÄp1 p2 p3. p1 wriggle p2 ‚àß p2 wriggle p3 ‚áí p1 wriggle p3
</pre>

<DT><span class="strong">leibniz_zigzag_tail</span>
<DD>
<pre>
‚ä¢ ‚àÄp1 p2. p1 zigzag p2 ‚áí ‚àÄx. [x] ++ p1 zigzag [x] ++ p2
</pre>

<DT><span class="strong">leibniz_zigzag_wriggle</span>
<DD>
<pre>
‚ä¢ ‚àÄp1 p2. p1 zigzag p2 ‚áí p1 wriggle p2
</pre>

<DT><span class="strong">listRangeINC_MONO_INC</span>
<DD>
<pre>
‚ä¢ ‚àÄm n m' n'. m' ‚â§ n' ‚àß n' < LENGTH [m .. n] ‚áí EL m' [m .. n] ‚â§ EL n' [m .. n]
</pre>

<DT><span class="strong">listRangeINC_PROD</span>
<DD>
<pre>
‚ä¢ ‚àÄm n. 0 < m ‚àß m ‚â§ n ‚áí PROD [m .. n] = PROD [1 .. n] DIV PROD [1 .. m ‚àí 1]
</pre>

<DT><span class="strong">listRangeINC_PROD_pos</span>
<DD>
<pre>
‚ä¢ ‚àÄm n. 0 < m ‚áí 0 < PROD [m .. n]
</pre>

<DT><span class="strong">listRangeLHI_MONO_INC</span>
<DD>
<pre>
‚ä¢ ‚àÄm n m' n'.
    m' ‚â§ n' ‚àß n' < LENGTH [m ..< n] ‚áí EL m' [m ..< n] ‚â§ EL n' [m ..< n]
</pre>

<DT><span class="strong">listRangeLHI_PROD</span>
<DD>
<pre>
‚ä¢ ‚àÄm n. 0 < m ‚àß m ‚â§ n ‚áí PROD [m ..< n] = PROD [1 ..< n] DIV PROD [1 ..< m]
</pre>

<DT><span class="strong">listRangeLHI_PROD_pos</span>
<DD>
<pre>
‚ä¢ ‚àÄm n. 0 < m ‚áí 0 < PROD [m ..< n]
</pre>

<DT><span class="strong">list_count_0_n</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 < n ‚áí list_count 0 n = ‚àÖ
</pre>

<DT><span class="strong">list_count_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn k.
    list_count n k =
    {ls |
     ALL_DISTINCT ls ‚àß LIST_TO_SET ls ‚äÜ count n ‚àß CARD (LIST_TO_SET ls) = k}
</pre>

<DT><span class="strong">list_count_by_image</span>
<DD>
<pre>
‚ä¢ ‚àÄn k.
    0 < k ‚áí
    list_count n k =
    IMAGE (Œªls. if ALL_DISTINCT ls then ls else []) (necklace k n) DELETE []
</pre>

<DT><span class="strong">list_count_element</span>
<DD>
<pre>
‚ä¢ ‚àÄls n k.
    ls ‚àà list_count n k ‚áî
    ALL_DISTINCT ls ‚àß LIST_TO_SET ls ‚äÜ count n ‚àß LENGTH ls = k
</pre>

<DT><span class="strong">list_count_element_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄls n k.
    ls ‚àà list_count n k ‚áî
    ALL_DISTINCT ls ‚àß LIST_TO_SET ls ‚äÜ count n ‚àß CARD (LIST_TO_SET ls) = k
</pre>

<DT><span class="strong">list_count_element_perm_set_not_empty</span>
<DD>
<pre>
‚ä¢ ‚àÄls n k. ls ‚àà list_count n k ‚áí perm_set (LIST_TO_SET ls) ‚â† ‚àÖ
</pre>

<DT><span class="strong">list_count_element_set_card</span>
<DD>
<pre>
‚ä¢ ‚àÄls n k. ls ‚àà list_count n k ‚áí CARD (LIST_TO_SET ls) = k
</pre>

<DT><span class="strong">list_count_eq_empty</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. list_count n k = ‚àÖ ‚áî n < k
</pre>

<DT><span class="strong">list_count_eqn</span>
<DD>
<pre>
‚ä¢ ‚àÄn k.
    list_count n k =
    if k = 0 then {[]}
    else
      IMAGE (Œªls. if ALL_DISTINCT ls then ls else []) (necklace k n) DELETE []
</pre>

<DT><span class="strong">list_count_finite</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. FINITE (list_count n k)
</pre>

<DT><span class="strong">list_count_n_0</span>
<DD>
<pre>
‚ä¢ ‚àÄn. list_count n 0 = {[]}
</pre>

<DT><span class="strong">list_count_n_n</span>
<DD>
<pre>
‚ä¢ ‚àÄn. list_count n n = perm_count n
</pre>

<DT><span class="strong">list_count_set_eq_class</span>
<DD>
<pre>
‚ä¢ ‚àÄls n k.
    ls ‚àà list_count n k ‚áí
    equiv_class (feq LIST_TO_SET) (list_count n k) ls =
    perm_set (LIST_TO_SET ls)
</pre>

<DT><span class="strong">list_count_set_eq_class_card</span>
<DD>
<pre>
‚ä¢ ‚àÄls n k.
    ls ‚àà list_count n k ‚áí
    CARD (equiv_class (feq LIST_TO_SET) (list_count n k) ls) = perm k
</pre>

<DT><span class="strong">list_count_set_map_bij</span>
<DD>
<pre>
‚ä¢ ‚àÄn k.
    BIJ (LIST_TO_SET ‚àò CHOICE) (partition (feq LIST_TO_SET) (list_count n k))
      (sub_count n k)
</pre>

<DT><span class="strong">list_count_set_map_element</span>
<DD>
<pre>
‚ä¢ ‚àÄs n k.
    s ‚àà partition (feq LIST_TO_SET) (list_count n k) ‚áí
    (LIST_TO_SET ‚àò CHOICE) s ‚àà sub_count n k
</pre>

<DT><span class="strong">list_count_set_map_inj</span>
<DD>
<pre>
‚ä¢ ‚àÄn k.
    INJ (LIST_TO_SET ‚àò CHOICE) (partition (feq LIST_TO_SET) (list_count n k))
      (sub_count n k)
</pre>

<DT><span class="strong">list_count_set_map_surj</span>
<DD>
<pre>
‚ä¢ ‚àÄn k.
    SURJ (LIST_TO_SET ‚àò CHOICE) (partition (feq LIST_TO_SET) (list_count n k))
      (sub_count n k)
</pre>

<DT><span class="strong">list_count_set_partititon_element_card</span>
<DD>
<pre>
‚ä¢ ‚àÄn k e. e ‚àà partition (feq LIST_TO_SET) (list_count n k) ‚áí CARD e = perm k
</pre>

<DT><span class="strong">list_count_subset</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. list_count n k ‚äÜ necklace k n
</pre>

<DT><span class="strong">list_lcm_absorption</span>
<DD>
<pre>
‚ä¢ ‚àÄx l. MEM x l ‚áí list_lcm (x::l) = list_lcm l
</pre>

<DT><span class="strong">list_lcm_append</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2. list_lcm (l1 ++ l2) = lcm (list_lcm l1) (list_lcm l2)
</pre>

<DT><span class="strong">list_lcm_append_3</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2 l3.
    list_lcm (l1 ++ l2 ++ l3) =
    list_lcm [list_lcm l1; list_lcm l2; list_lcm l3]
</pre>

<DT><span class="strong">list_lcm_by_FOLDL</span>
<DD>
<pre>
‚ä¢ ‚àÄls. list_lcm ls = FOLDL lcm 1 ls
</pre>

<DT><span class="strong">list_lcm_by_FOLDR</span>
<DD>
<pre>
‚ä¢ ‚àÄls. list_lcm ls = FOLDR lcm 1 ls
</pre>

<DT><span class="strong">list_lcm_cons</span>
<DD>
<pre>
‚ä¢ ‚àÄh t. list_lcm (h::t) = lcm h (list_lcm t)
</pre>

<DT><span class="strong">list_lcm_divisor_lcm_pair</span>
<DD>
<pre>
‚ä¢ ‚àÄl x y. MEM x l ‚àß MEM y l ‚áí lcm x y divides list_lcm l
</pre>

<DT><span class="strong">list_lcm_eq_if_set_eq</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2. LIST_TO_SET l1 = LIST_TO_SET l2 ‚áí list_lcm l1 = list_lcm l2
</pre>

<DT><span class="strong">list_lcm_ge_max</span>
<DD>
<pre>
‚ä¢ ‚àÄl. POSITIVE l ‚áí MAX_LIST l ‚â§ list_lcm l
</pre>

<DT><span class="strong">list_lcm_is_common_multiple</span>
<DD>
<pre>
‚ä¢ ‚àÄx l. MEM x l ‚áí x divides list_lcm l
</pre>

<DT><span class="strong">list_lcm_is_least_common_multiple</span>
<DD>
<pre>
‚ä¢ ‚àÄl m. (‚àÄx. MEM x l ‚áí x divides m) ‚áí list_lcm l divides m
</pre>

<DT><span class="strong">list_lcm_lower_bound</span>
<DD>
<pre>
‚ä¢ ‚àÄl. EVERY_POSITIVE l ‚áí SUM l ‚â§ LENGTH l * list_lcm l
</pre>

<DT><span class="strong">list_lcm_lower_bound_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄl. POSITIVE l ‚áí SUM l ‚â§ LENGTH l * list_lcm l
</pre>

<DT><span class="strong">list_lcm_lower_by_lcm_pair</span>
<DD>
<pre>
‚ä¢ ‚àÄl x y. POSITIVE l ‚àß MEM x l ‚àß MEM y l ‚áí lcm x y ‚â§ list_lcm l
</pre>

<DT><span class="strong">list_lcm_map_times</span>
<DD>
<pre>
‚ä¢ ‚àÄn l. list_lcm (MAP (Œªk. n * k) l) = if l = [] then 1 else n * list_lcm l
</pre>

<DT><span class="strong">list_lcm_nil</span>
<DD>
<pre>
‚ä¢ list_lcm [] = 1
</pre>

<DT><span class="strong">list_lcm_nonempty_lower</span>
<DD>
<pre>
‚ä¢ ‚àÄl. l ‚â† [] ‚àß EVERY_POSITIVE l ‚áí SUM l DIV LENGTH l ‚â§ list_lcm l
</pre>

<DT><span class="strong">list_lcm_nonempty_lower_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄl. l ‚â† [] ‚àß POSITIVE l ‚áí SUM l DIV LENGTH l ‚â§ list_lcm l
</pre>

<DT><span class="strong">list_lcm_nub</span>
<DD>
<pre>
‚ä¢ ‚àÄl. list_lcm (nub l) = list_lcm l
</pre>

<DT><span class="strong">list_lcm_nub_eq_if_set_eq</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2.
    LIST_TO_SET l1 = LIST_TO_SET l2 ‚áí list_lcm (nub l1) = list_lcm (nub l2)
</pre>

<DT><span class="strong">list_lcm_pos</span>
<DD>
<pre>
‚ä¢ ‚àÄl. EVERY_POSITIVE l ‚áí 0 < list_lcm l
</pre>

<DT><span class="strong">list_lcm_pos_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄl. POSITIVE l ‚áí 0 < list_lcm l
</pre>

<DT><span class="strong">list_lcm_prime_factor</span>
<DD>
<pre>
‚ä¢ ‚àÄp l. prime p ‚àß p divides list_lcm l ‚áí p divides PROD_SET (LIST_TO_SET l)
</pre>

<DT><span class="strong">list_lcm_prime_factor_member</span>
<DD>
<pre>
‚ä¢ ‚àÄp l. prime p ‚àß p divides list_lcm l ‚áí ‚àÉx. MEM x l ‚àß p divides x
</pre>

<DT><span class="strong">list_lcm_reverse</span>
<DD>
<pre>
‚ä¢ ‚àÄl. list_lcm (REVERSE l) = list_lcm l
</pre>

<DT><span class="strong">list_lcm_sing</span>
<DD>
<pre>
‚ä¢ ‚àÄx. list_lcm [x] = x
</pre>

<DT><span class="strong">list_lcm_snoc</span>
<DD>
<pre>
‚ä¢ ‚àÄx l. list_lcm (SNOC x l) = lcm x (list_lcm l)
</pre>

<DT><span class="strong">list_lcm_suc</span>
<DD>
<pre>
‚ä¢ ‚àÄn. lcm_run (n + 1) = lcm (n + 1) (lcm_run n)
</pre>

<DT><span class="strong">list_lcm_upper_by_common_multiple</span>
<DD>
<pre>
‚ä¢ ‚àÄl m. 0 < m ‚àß (‚àÄx. MEM x l ‚áí x divides m) ‚áí list_lcm l ‚â§ m
</pre>

<DT><span class="strong">list_lcm_wriggle</span>
<DD>
<pre>
‚ä¢ ‚àÄp1 p2. p1 wriggle p2 ‚áí list_lcm p1 = list_lcm p2
</pre>

<DT><span class="strong">list_lcm_zigzag</span>
<DD>
<pre>
‚ä¢ ‚àÄp1 p2. p1 zigzag p2 ‚áí list_lcm p1 = list_lcm p2
</pre>

<DT><span class="strong">list_length_eq_sum</span>
<DD>
<pre>
‚ä¢ ‚àÄls. EVERY_POSITIVE ls ‚àß LENGTH ls = SUM ls ‚áí EVERY (Œªx. x = 1) ls
</pre>

<DT><span class="strong">list_length_le_sum</span>
<DD>
<pre>
‚ä¢ ‚àÄls. EVERY_POSITIVE ls ‚áí LENGTH ls ‚â§ SUM ls
</pre>

<DT><span class="strong">list_product_prime_factor</span>
<DD>
<pre>
‚ä¢ ‚àÄp l.
    prime p ‚àß p divides PROD_SET (LIST_TO_SET l) ‚áí ‚àÉx. MEM x l ‚àß p divides x
</pre>

<DT><span class="strong">monocoloured_0</span>
<DD>
<pre>
‚ä¢ ‚àÄa. monocoloured 0 a = {[]}
</pre>

<DT><span class="strong">monocoloured_0_card</span>
<DD>
<pre>
‚ä¢ ‚àÄa. CARD (monocoloured 0 a) = 1
</pre>

<DT><span class="strong">monocoloured_1</span>
<DD>
<pre>
‚ä¢ ‚àÄa. monocoloured 1 a = necklace 1 a
</pre>

<DT><span class="strong">monocoloured_card</span>
<DD>
<pre>
‚ä¢ ‚àÄn a. 0 < n ‚áí CARD (monocoloured n a) = a
</pre>

<DT><span class="strong">monocoloured_card_eqn</span>
<DD>
<pre>
‚ä¢ ‚àÄn a. CARD (monocoloured n a) = if n = 0 then 1 else a
</pre>

<DT><span class="strong">monocoloured_element</span>
<DD>
<pre>
‚ä¢ ‚àÄn a ls.
    ls ‚àà monocoloured n a ‚áî
    ls ‚àà necklace n a ‚àß (ls ‚â† [] ‚áí SING (LIST_TO_SET ls))
</pre>

<DT><span class="strong">monocoloured_empty</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 < n ‚áí monocoloured n 0 = ‚àÖ
</pre>

<DT><span class="strong">monocoloured_eqn</span>
<DD>
<pre>
‚ä¢ ‚àÄn a.
    monocoloured n a =
    if n = 0 then {[]} else IMAGE (Œªc. GENLIST (K c) n) (count a)
</pre>

<DT><span class="strong">monocoloured_finite</span>
<DD>
<pre>
‚ä¢ ‚àÄn a. FINITE (monocoloured n a)
</pre>

<DT><span class="strong">monocoloured_mono</span>
<DD>
<pre>
‚ä¢ ‚àÄn. monocoloured n 1 = necklace n 1
</pre>

<DT><span class="strong">monocoloured_necklace</span>
<DD>
<pre>
‚ä¢ ‚àÄn a ls. ls ‚àà monocoloured n a ‚áí ls ‚àà necklace n a
</pre>

<DT><span class="strong">monocoloured_subset</span>
<DD>
<pre>
‚ä¢ ‚àÄn a. monocoloured n a ‚äÜ necklace n a
</pre>

<DT><span class="strong">monocoloured_suc</span>
<DD>
<pre>
‚ä¢ ‚àÄn a.
    0 < n ‚áí monocoloured (SUC n) a = IMAGE (Œªls. HD ls::ls) (monocoloured n a)
</pre>

<DT><span class="strong">multi_mono_disjoint</span>
<DD>
<pre>
‚ä¢ ‚àÄn a. DISJOINT (multicoloured n a) (monocoloured n a)
</pre>

<DT><span class="strong">multi_mono_exhaust</span>
<DD>
<pre>
‚ä¢ ‚àÄn a. necklace n a = multicoloured n a ‚à™ monocoloured n a
</pre>

<DT><span class="strong">multicoloured_0</span>
<DD>
<pre>
‚ä¢ ‚àÄa. multicoloured 0 a = ‚àÖ
</pre>

<DT><span class="strong">multicoloured_1</span>
<DD>
<pre>
‚ä¢ ‚àÄa. multicoloured 1 a = ‚àÖ
</pre>

<DT><span class="strong">multicoloured_card</span>
<DD>
<pre>
‚ä¢ ‚àÄn a. 0 < n ‚áí CARD (multicoloured n a) = a ** n ‚àí a
</pre>

<DT><span class="strong">multicoloured_card_eqn</span>
<DD>
<pre>
‚ä¢ ‚àÄn a. CARD (multicoloured n a) = if n = 0 then 0 else a ** n ‚àí a
</pre>

<DT><span class="strong">multicoloured_element</span>
<DD>
<pre>
‚ä¢ ‚àÄn a ls.
    ls ‚àà multicoloured n a ‚áî
    ls ‚àà necklace n a ‚àß ls ‚â† [] ‚àß ¬¨SING (LIST_TO_SET ls)
</pre>

<DT><span class="strong">multicoloured_empty</span>
<DD>
<pre>
‚ä¢ ‚àÄn. multicoloured n 0 = ‚àÖ ‚àß multicoloured n 1 = ‚àÖ
</pre>

<DT><span class="strong">multicoloured_finite</span>
<DD>
<pre>
‚ä¢ ‚àÄn a. FINITE (multicoloured n a)
</pre>

<DT><span class="strong">multicoloured_n_0</span>
<DD>
<pre>
‚ä¢ ‚àÄn. multicoloured n 0 = ‚àÖ
</pre>

<DT><span class="strong">multicoloured_n_1</span>
<DD>
<pre>
‚ä¢ ‚àÄn. multicoloured n 1 = ‚àÖ
</pre>

<DT><span class="strong">multicoloured_necklace</span>
<DD>
<pre>
‚ä¢ ‚àÄn a ls. ls ‚àà multicoloured n a ‚áí ls ‚àà necklace n a
</pre>

<DT><span class="strong">multicoloured_nonempty</span>
<DD>
<pre>
‚ä¢ ‚àÄn a. 1 < n ‚àß 1 < a ‚áí multicoloured n a ‚â† ‚àÖ
</pre>

<DT><span class="strong">multicoloured_not_monocoloured</span>
<DD>
<pre>
‚ä¢ ‚àÄn a ls. ls ‚àà multicoloured n a ‚áí ls ‚àâ monocoloured n a
</pre>

<DT><span class="strong">multicoloured_not_monocoloured_iff</span>
<DD>
<pre>
‚ä¢ ‚àÄn a ls.
    ls ‚àà necklace n a ‚áí (ls ‚àà multicoloured n a ‚áî ls ‚àâ monocoloured n a)
</pre>

<DT><span class="strong">multicoloured_or_monocoloured</span>
<DD>
<pre>
‚ä¢ ‚àÄn a ls. ls ‚àà necklace n a ‚áí ls ‚àà multicoloured n a ‚à® ls ‚àà monocoloured n a
</pre>

<DT><span class="strong">multicoloured_subset</span>
<DD>
<pre>
‚ä¢ ‚àÄn a. multicoloured n a ‚äÜ necklace n a
</pre>

<DT><span class="strong">necklace_0</span>
<DD>
<pre>
‚ä¢ ‚àÄa. necklace 0 a = {[]}
</pre>

<DT><span class="strong">necklace_1</span>
<DD>
<pre>
‚ä¢ ‚àÄa. necklace 1 a = {[e] | e ‚àà count a}
</pre>

<DT><span class="strong">necklace_1_monocoloured</span>
<DD>
<pre>
‚ä¢ ‚àÄa. necklace 1 a = monocoloured 1 a
</pre>

<DT><span class="strong">necklace_card</span>
<DD>
<pre>
‚ä¢ ‚àÄn a. CARD (necklace n a) = a ** n
</pre>

<DT><span class="strong">necklace_colors</span>
<DD>
<pre>
‚ä¢ ‚àÄn a ls. ls ‚àà necklace n a ‚áí LIST_TO_SET ls ‚äÜ count a
</pre>

<DT><span class="strong">necklace_element</span>
<DD>
<pre>
‚ä¢ ‚àÄn a ls. ls ‚àà necklace n a ‚áî LENGTH ls = n ‚àß LIST_TO_SET ls ‚äÜ count a
</pre>

<DT><span class="strong">necklace_empty</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 0 < n ‚áí necklace n 0 = ‚àÖ
</pre>

<DT><span class="strong">necklace_eqn</span>
<DD>
<pre>
‚ä¢ ‚àÄn a.
    necklace n a =
    if n = 0 then {[]}
    else IMAGE (Œª(c,ls). c::ls) (count a √ó necklace (n ‚àí 1) a)
</pre>

<DT><span class="strong">necklace_finite</span>
<DD>
<pre>
‚ä¢ ‚àÄn a. FINITE (necklace n a)
</pre>

<DT><span class="strong">necklace_length</span>
<DD>
<pre>
‚ä¢ ‚àÄn a ls. ls ‚àà necklace n a ‚áí LENGTH ls = n
</pre>

<DT><span class="strong">necklace_not_nil</span>
<DD>
<pre>
‚ä¢ ‚àÄn a ls. 0 < n ‚àß ls ‚àà necklace n a ‚áí ls ‚â† []
</pre>

<DT><span class="strong">necklace_property</span>
<DD>
<pre>
‚ä¢ ‚àÄn a ls. ls ‚àà necklace n a ‚áí LENGTH ls = n ‚àß LIST_TO_SET ls ‚äÜ count a
</pre>

<DT><span class="strong">necklace_suc</span>
<DD>
<pre>
‚ä¢ ‚àÄn a. necklace (SUC n) a = IMAGE (Œª(c,ls). c::ls) (count a √ó necklace n a)
</pre>

<DT><span class="strong">nub_all_distinct</span>
<DD>
<pre>
‚ä¢ ‚àÄl. ALL_DISTINCT (nub l)
</pre>

<DT><span class="strong">nub_cons</span>
<DD>
<pre>
‚ä¢ ‚àÄx l. nub (x::l) = if MEM x l then nub l else x::nub l
</pre>

<DT><span class="strong">nub_nil</span>
<DD>
<pre>
‚ä¢ nub [] = []
</pre>

<DT><span class="strong">nub_sing</span>
<DD>
<pre>
‚ä¢ ‚àÄx. nub [x] = [x]
</pre>

<DT><span class="strong">over_bij</span>
<DD>
<pre>
‚ä¢ ‚àÄf s t. BIJ f s t ‚áí ‚àÄx. x ‚àà s ‚áí f x ‚àà t
</pre>

<DT><span class="strong">over_inj</span>
<DD>
<pre>
‚ä¢ ‚àÄf s t. INJ f s t ‚áí ‚àÄx. x ‚àà s ‚áí f x ‚àà t
</pre>

<DT><span class="strong">over_surj</span>
<DD>
<pre>
‚ä¢ ‚àÄf s t. SURJ f s t ‚áí ‚àÄx. x ‚àà s ‚áí f x ‚àà t
</pre>

<DT><span class="strong">pairwise_coprime_prod_set_divides</span>
<DD>
<pre>
‚ä¢ ‚àÄs m.
    FINITE s ‚àß PAIRWISE_COPRIME s ‚àß (‚àÄx. x ‚àà s ‚áí x divides m) ‚áí
    PROD_SET s divides m
</pre>

<DT><span class="strong">pairwise_coprime_prod_set_eq_set_lcm</span>
<DD>
<pre>
‚ä¢ ‚àÄs. FINITE s ‚àß PAIRWISE_COPRIME s ‚áí set_lcm s = PROD_SET s
</pre>

<DT><span class="strong">perm_0</span>
<DD>
<pre>
‚ä¢ perm 0 = 1
</pre>

<DT><span class="strong">perm_1</span>
<DD>
<pre>
‚ä¢ perm 1 = 1
</pre>

<DT><span class="strong">perm_alt</span>
<DD>
<pre>
‚ä¢ perm 0 = 1 ‚àß ‚àÄn. perm (n + 1) = (n + 1) * perm n
</pre>

<DT><span class="strong">perm_count_0</span>
<DD>
<pre>
‚ä¢ perm_count 0 = {[]}
</pre>

<DT><span class="strong">perm_count_1</span>
<DD>
<pre>
‚ä¢ perm_count 1 = {[0]}
</pre>

<DT><span class="strong">perm_count_element</span>
<DD>
<pre>
‚ä¢ ‚àÄls n. ls ‚àà perm_count n ‚áî ALL_DISTINCT ls ‚àß LIST_TO_SET ls = count n
</pre>

<DT><span class="strong">perm_count_element_length</span>
<DD>
<pre>
‚ä¢ ‚àÄls n. ls ‚àà perm_count n ‚áí LENGTH ls = n
</pre>

<DT><span class="strong">perm_count_element_no_self</span>
<DD>
<pre>
‚ä¢ ‚àÄls n. ls ‚àà perm_count n ‚áí ¬¨MEM n ls
</pre>

<DT><span class="strong">perm_count_eqn</span>
<DD>
<pre>
‚ä¢ ‚àÄn. perm_count n =
      if n = 0 then {[]}
      else BIGUNION (IMAGE ($interleave (n ‚àí 1)) (perm_count (n ‚àí 1)))
</pre>

<DT><span class="strong">perm_count_finite</span>
<DD>
<pre>
‚ä¢ ‚àÄn. FINITE (perm_count n)
</pre>

<DT><span class="strong">perm_count_interleave_card</span>
<DD>
<pre>
‚ä¢ ‚àÄn e. e ‚àà IMAGE ($interleave n) (perm_count n) ‚áí CARD e = n + 1
</pre>

<DT><span class="strong">perm_count_interleave_disjoint</span>
<DD>
<pre>
‚ä¢ ‚àÄn e s t.
    s ‚àà IMAGE ($interleave n) (perm_count n) ‚àß
    t ‚àà IMAGE ($interleave n) (perm_count n) ‚àß s ‚â† t ‚áí
    DISJOINT s t
</pre>

<DT><span class="strong">perm_count_interleave_finite</span>
<DD>
<pre>
‚ä¢ ‚àÄn e. e ‚àà IMAGE ($interleave n) (perm_count n) ‚áí FINITE e
</pre>

<DT><span class="strong">perm_count_interleave_inj</span>
<DD>
<pre>
‚ä¢ ‚àÄn. INJ ($interleave n) (perm_count n) ùïå(:num list -> bool)
</pre>

<DT><span class="strong">perm_count_subset</span>
<DD>
<pre>
‚ä¢ ‚àÄn. perm_count n ‚äÜ necklace n n
</pre>

<DT><span class="strong">perm_count_suc</span>
<DD>
<pre>
‚ä¢ ‚àÄn. perm_count (SUC n) = BIGUNION (IMAGE ($interleave n) (perm_count n))
</pre>

<DT><span class="strong">perm_count_suc_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn. perm_count (n + 1) = BIGUNION (IMAGE ($interleave n) (perm_count n))
</pre>

<DT><span class="strong">perm_eq_fact</span>
<DD>
<pre>
‚ä¢ ‚àÄn. perm n = FACT n
</pre>

<DT><span class="strong">perm_set_bij_eq_perm_count</span>
<DD>
<pre>
‚ä¢ ‚àÄs. FINITE s ‚áí perm_set s =b= perm_count (CARD s)
</pre>

<DT><span class="strong">perm_set_card</span>
<DD>
<pre>
‚ä¢ ‚àÄs. FINITE s ‚áí CARD (perm_set s) = perm (CARD s)
</pre>

<DT><span class="strong">perm_set_card_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄs. FINITE s ‚áí CARD (perm_set s) = FACT (CARD s)
</pre>

<DT><span class="strong">perm_set_element</span>
<DD>
<pre>
‚ä¢ ‚àÄls s. ls ‚àà perm_set s ‚áî ALL_DISTINCT ls ‚àß LIST_TO_SET ls = s
</pre>

<DT><span class="strong">perm_set_empty</span>
<DD>
<pre>
‚ä¢ perm_set ‚àÖ = {[]}
</pre>

<DT><span class="strong">perm_set_eq_empty_sing</span>
<DD>
<pre>
‚ä¢ ‚àÄs. perm_set s = {[]} ‚áî s = ‚àÖ
</pre>

<DT><span class="strong">perm_set_finite</span>
<DD>
<pre>
‚ä¢ ‚àÄs. FINITE s ‚áí FINITE (perm_set s)
</pre>

<DT><span class="strong">perm_set_has_self_list</span>
<DD>
<pre>
‚ä¢ ‚àÄs. FINITE s ‚áí SET_TO_LIST s ‚àà perm_set s
</pre>

<DT><span class="strong">perm_set_list_not_empty</span>
<DD>
<pre>
‚ä¢ ‚àÄls. perm_set (LIST_TO_SET ls) ‚â† ‚àÖ
</pre>

<DT><span class="strong">perm_set_map_bij</span>
<DD>
<pre>
‚ä¢ ‚àÄf s n. BIJ f s (count n) ‚áí BIJ (MAP f) (perm_set s) (perm_count n)
</pre>

<DT><span class="strong">perm_set_map_element</span>
<DD>
<pre>
‚ä¢ ‚àÄls f s n. ls ‚àà perm_set s ‚àß BIJ f s (count n) ‚áí MAP f ls ‚àà perm_count n
</pre>

<DT><span class="strong">perm_set_map_inj</span>
<DD>
<pre>
‚ä¢ ‚àÄf s n. BIJ f s (count n) ‚áí INJ (MAP f) (perm_set s) (perm_count n)
</pre>

<DT><span class="strong">perm_set_map_surj</span>
<DD>
<pre>
‚ä¢ ‚àÄf s n. BIJ f s (count n) ‚áí SURJ (MAP f) (perm_set s) (perm_count n)
</pre>

<DT><span class="strong">perm_set_not_empty</span>
<DD>
<pre>
‚ä¢ ‚àÄs. FINITE s ‚áí perm_set s ‚â† ‚àÖ
</pre>

<DT><span class="strong">perm_set_perm_count</span>
<DD>
<pre>
‚ä¢ ‚àÄn. perm_set (count n) = perm_count n
</pre>

<DT><span class="strong">perm_set_sing</span>
<DD>
<pre>
‚ä¢ ‚àÄx. perm_set {x} = {[x]}
</pre>

<DT><span class="strong">perm_suc</span>
<DD>
<pre>
‚ä¢ ‚àÄn. perm (SUC n) = SUC n * perm n
</pre>

<DT><span class="strong">perm_suc_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn. perm (n + 1) = (n + 1) * perm n
</pre>

<DT><span class="strong">power_predecessor_eqn</span>
<DD>
<pre>
‚ä¢ ‚àÄt n. tops t n = (t ‚àí 1) * SUM (MAP (Œªj. t ** j) [0 ..< n])
</pre>

<DT><span class="strong">prime_divides_binomials</span>
<DD>
<pre>
‚ä¢ ‚àÄn. prime n ‚áí 1 < n ‚àß ‚àÄk. 0 < k ‚àß k < n ‚áí n divides binomial n k
</pre>

<DT><span class="strong">prime_divides_binomials_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. prime n ‚àß 0 < k ‚àß k < n ‚áí n divides binomial n k
</pre>

<DT><span class="strong">prime_divisor_property</span>
<DD>
<pre>
‚ä¢ ‚àÄn p.
    1 < n ‚àß p < n ‚àß prime p ‚àß p divides n ‚áí
    ¬¨(p divides FACT (n ‚àí 1) DIV FACT (n ‚àí p))
</pre>

<DT><span class="strong">prime_iff_divides_binomials</span>
<DD>
<pre>
‚ä¢ ‚àÄn. prime n ‚áî 1 < n ‚àß ‚àÄk. 0 < k ‚àß k < n ‚áí n divides binomial n k
</pre>

<DT><span class="strong">prime_iff_divides_binomials_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn. prime n ‚áî 1 < n ‚àß ‚àÄk. 0 < k ‚àß k < n ‚áí binomial n k MOD n = 0
</pre>

<DT><span class="strong">prod_1_to_n_eq_fact_n</span>
<DD>
<pre>
‚ä¢ ‚àÄn. PROD [1 .. n] = FACT n
</pre>

<DT><span class="strong">rotate_0</span>
<DD>
<pre>
‚ä¢ ‚àÄl. rotate 0 l = l
</pre>

<DT><span class="strong">rotate_add</span>
<DD>
<pre>
‚ä¢ ‚àÄn m l. n + m ‚â§ LENGTH l ‚áí rotate n (rotate m l) = rotate (n + m) l
</pre>

<DT><span class="strong">rotate_full</span>
<DD>
<pre>
‚ä¢ ‚àÄl. rotate (LENGTH l) l = l
</pre>

<DT><span class="strong">rotate_lcancel</span>
<DD>
<pre>
‚ä¢ ‚àÄk l. k < LENGTH l ‚áí rotate (LENGTH l ‚àí k) (rotate k l) = l
</pre>

<DT><span class="strong">rotate_nil</span>
<DD>
<pre>
‚ä¢ ‚àÄn. rotate n [] = []
</pre>

<DT><span class="strong">rotate_rcancel</span>
<DD>
<pre>
‚ä¢ ‚àÄk l. k < LENGTH l ‚áí rotate k (rotate (LENGTH l ‚àí k) l) = l
</pre>

<DT><span class="strong">rotate_same_length</span>
<DD>
<pre>
‚ä¢ ‚àÄl n. LENGTH (rotate n l) = LENGTH l
</pre>

<DT><span class="strong">rotate_same_set</span>
<DD>
<pre>
‚ä¢ ‚àÄl n. LIST_TO_SET (rotate n l) = LIST_TO_SET l
</pre>

<DT><span class="strong">rotate_shift_element</span>
<DD>
<pre>
‚ä¢ ‚àÄl n. n < LENGTH l ‚áí rotate n l = EL n l::(DROP (SUC n) l ++ TAKE n l)
</pre>

<DT><span class="strong">rotate_suc</span>
<DD>
<pre>
‚ä¢ ‚àÄl n. n < LENGTH l ‚áí rotate (SUC n) l = rotate 1 (rotate n l)
</pre>

<DT><span class="strong">set_lcm_empty</span>
<DD>
<pre>
‚ä¢ set_lcm ‚àÖ = 1
</pre>

<DT><span class="strong">set_lcm_eq_big_lcm</span>
<DD>
<pre>
‚ä¢ ‚àÄs. FINITE s ‚áí big_lcm s = set_lcm s
</pre>

<DT><span class="strong">set_lcm_eq_list_lcm</span>
<DD>
<pre>
‚ä¢ ‚àÄl. set_lcm (LIST_TO_SET l) = list_lcm l
</pre>

<DT><span class="strong">set_lcm_insert</span>
<DD>
<pre>
‚ä¢ ‚àÄs. FINITE s ‚áí ‚àÄx. set_lcm (x INSERT s) = lcm x (set_lcm s)
</pre>

<DT><span class="strong">set_lcm_is_common_multiple</span>
<DD>
<pre>
‚ä¢ ‚àÄx s. FINITE s ‚àß x ‚àà s ‚áí x divides set_lcm s
</pre>

<DT><span class="strong">set_lcm_is_least_common_multiple</span>
<DD>
<pre>
‚ä¢ ‚àÄs m. FINITE s ‚àß (‚àÄx. x ‚àà s ‚áí x divides m) ‚áí set_lcm s divides m
</pre>

<DT><span class="strong">set_lcm_nonempty</span>
<DD>
<pre>
‚ä¢ ‚àÄs. FINITE s ‚àß s ‚â† ‚àÖ ‚áí set_lcm s = lcm (CHOICE s) (set_lcm (REST s))
</pre>

<DT><span class="strong">set_lcm_sing</span>
<DD>
<pre>
‚ä¢ ‚àÄx. set_lcm {x} = x
</pre>

<DT><span class="strong">sub_count_0_n</span>
<DD>
<pre>
‚ä¢ ‚àÄn. sub_count 0 n = if n = 0 then {‚àÖ} else ‚àÖ
</pre>

<DT><span class="strong">sub_count_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄn k.
    sub_count n 0 = {‚àÖ} ‚àß sub_count 0 (k + 1) = ‚àÖ ‚àß
    sub_count (n + 1) (k + 1) =
    IMAGE (Œªs. n INSERT s) (sub_count n k) ‚à™ sub_count n (k + 1)
</pre>

<DT><span class="strong">sub_count_count_inj</span>
<DD>
<pre>
‚ä¢ ‚àÄn m. INJ (sub_count n) (upto n) ùïå(:(num -> bool) -> bool)
</pre>

<DT><span class="strong">sub_count_disjoint</span>
<DD>
<pre>
‚ä¢ ‚àÄn k.
    DISJOINT (IMAGE (Œªs. n INSERT s) (sub_count n k)) (sub_count n (k + 1))
</pre>

<DT><span class="strong">sub_count_element</span>
<DD>
<pre>
‚ä¢ ‚àÄn k s. s ‚àà sub_count n k ‚áî s ‚äÜ count n ‚àß CARD s = k
</pre>

<DT><span class="strong">sub_count_element_finite</span>
<DD>
<pre>
‚ä¢ ‚àÄn k s. s ‚àà sub_count n k ‚áí FINITE s
</pre>

<DT><span class="strong">sub_count_element_no_self</span>
<DD>
<pre>
‚ä¢ ‚àÄn k s. s ‚àà sub_count n k ‚áí n ‚àâ s
</pre>

<DT><span class="strong">sub_count_eq_empty</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. sub_count n k = ‚àÖ ‚áî n < k
</pre>

<DT><span class="strong">sub_count_eqn</span>
<DD>
<pre>
‚ä¢ ‚àÄn k.
    sub_count n k =
    if k = 0 then {‚àÖ}
    else if n = 0 then ‚àÖ
    else
      IMAGE (Œªs. n ‚àí 1 INSERT s) (sub_count (n ‚àí 1) (k ‚àí 1)) ‚à™
      sub_count (n ‚àí 1) k
</pre>

<DT><span class="strong">sub_count_equiv_class</span>
<DD>
<pre>
‚ä¢ ‚àÄn s.
    s ‚äÜ count n ‚áí
    sub_count n (CARD s) = equiv_class (Œªs t. s =b= t) (POW (count n)) s
</pre>

<DT><span class="strong">sub_count_finite</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. FINITE (sub_count n k)
</pre>

<DT><span class="strong">sub_count_insert</span>
<DD>
<pre>
‚ä¢ ‚àÄn k s. s ‚àà sub_count n k ‚áí n INSERT s ‚àà sub_count (n + 1) (k + 1)
</pre>

<DT><span class="strong">sub_count_insert_card</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. CARD (IMAGE (Œªs. n INSERT s) (sub_count n k)) = n choose k
</pre>

<DT><span class="strong">sub_count_n_0</span>
<DD>
<pre>
‚ä¢ ‚àÄn. sub_count n 0 = {‚àÖ}
</pre>

<DT><span class="strong">sub_count_n_1</span>
<DD>
<pre>
‚ä¢ ‚àÄn. sub_count n 1 = {{j} | j < n}
</pre>

<DT><span class="strong">sub_count_n_n</span>
<DD>
<pre>
‚ä¢ ‚àÄn. sub_count n n = {count n}
</pre>

<DT><span class="strong">sub_count_subset</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. sub_count n k ‚äÜ POW (count n)
</pre>

<DT><span class="strong">sub_count_union</span>
<DD>
<pre>
‚ä¢ ‚àÄn k.
    sub_count (n + 1) (k + 1) =
    IMAGE (Œªs. n INSERT s) (sub_count n k) ‚à™ sub_count n (k + 1)
</pre>

<DT><span class="strong">sub_sets_element</span>
<DD>
<pre>
‚ä¢ ‚àÄP k s. s ‚àà sub_sets P k ‚áî s ‚äÜ P ‚àß CARD s = k
</pre>

<DT><span class="strong">sub_sets_equiv_class</span>
<DD>
<pre>
‚ä¢ ‚àÄs t.
    FINITE t ‚àß s ‚äÜ t ‚áí
    sub_sets t (CARD s) = equiv_class (Œªs t. s =b= t) (POW t) s
</pre>

<DT><span class="strong">sub_sets_sub_count</span>
<DD>
<pre>
‚ä¢ ‚àÄn k. sub_sets (count n) k = sub_count n k
</pre>

<DT><span class="strong">sum_1_to_n_double</span>
<DD>
<pre>
‚ä¢ ‚àÄn. 2 * SUM [1 .. n] = n * (n + 1)
</pre>

<DT><span class="strong">sum_1_to_n_eq_tri_n</span>
<DD>
<pre>
‚ä¢ ‚àÄn. SUM [1 .. n] = tri n
</pre>

<DT><span class="strong">sum_1_to_n_eqn</span>
<DD>
<pre>
‚ä¢ ‚àÄn. SUM [1 .. n] = n * (n + 1) DIV 2
</pre>

<DT><span class="strong">surj_iff_preimage_card_not_0</span>
<DD>
<pre>
‚ä¢ ‚àÄf s t.
    FINITE s ‚àß (‚àÄx. x ‚àà s ‚áí f x ‚àà t) ‚áí
    (SURJ f s t ‚áî ‚àÄy. y ‚àà t ‚áí CARD (preimage f s y) ‚â† 0)
</pre>

<DT><span class="strong">surj_preimage_not_empty</span>
<DD>
<pre>
‚ä¢ ‚àÄf s t. SURJ f s t ‚áî (‚àÄx. x ‚àà s ‚áí f x ‚àà t) ‚àß ‚àÄy. y ‚àà t ‚áí preimage f s y ‚â† ‚àÖ
</pre>

<DT><span class="strong">tail_turn</span>
<DD>
<pre>
‚ä¢ ‚àÄls. ls ‚â† [] ‚áí TL (turn ls) = FRONT ls
</pre>

<DT><span class="strong">triple_11</span>
<DD>
<pre>
‚ä¢ ‚àÄa0 a1 a2 a0' a1' a2'.
    triple a0 a1 a2 = triple a0' a1' a2' ‚áî a0 = a0' ‚àß a1 = a1' ‚àß a2 = a2'
</pre>

<DT><span class="strong">triple_Axiom</span>
<DD>
<pre>
‚ä¢ ‚àÄf. ‚àÉfn. ‚àÄa0 a1 a2. fn (triple a0 a1 a2) = f a0 a1 a2
</pre>

<DT><span class="strong">triple_accessors</span>
<DD>
<pre>
‚ä¢ (‚àÄn n0 n1. (triple n n0 n1).a = n) ‚àß (‚àÄn n0 n1. (triple n n0 n1).b = n0) ‚àß
  ‚àÄn n0 n1. (triple n n0 n1).c = n1
</pre>

<DT><span class="strong">triple_accfupds</span>
<DD>
<pre>
‚ä¢ (‚àÄt f. (t with b updated_by f).a = t.a) ‚àß
  (‚àÄt f. (t with c updated_by f).a = t.a) ‚àß
  (‚àÄt f. (t with a updated_by f).b = t.b) ‚àß
  (‚àÄt f. (t with c updated_by f).b = t.b) ‚àß
  (‚àÄt f. (t with a updated_by f).c = t.c) ‚àß
  (‚àÄt f. (t with b updated_by f).c = t.c) ‚àß
  (‚àÄt f. (t with a updated_by f).a = f t.a) ‚àß
  (‚àÄt f. (t with b updated_by f).b = f t.b) ‚àß
  ‚àÄt f. (t with c updated_by f).c = f t.c
</pre>

<DT><span class="strong">triple_case_cong</span>
<DD>
<pre>
‚ä¢ ‚àÄM M' f.
    M = M' ‚àß (‚àÄa0 a1 a2. M' = triple a0 a1 a2 ‚áí f a0 a1 a2 = f' a0 a1 a2) ‚áí
    triple_CASE M f = triple_CASE M' f'
</pre>

<DT><span class="strong">triple_case_eq</span>
<DD>
<pre>
‚ä¢ triple_CASE x f = v ‚áî ‚àÉn n0 n1. x = triple n n0 n1 ‚àß f n n0 n1 = v
</pre>

<DT><span class="strong">triple_component_equality</span>
<DD>
<pre>
‚ä¢ ‚àÄt1 t2. t1 = t2 ‚áî t1.a = t2.a ‚àß t1.b = t2.b ‚àß t1.c = t2.c
</pre>

<DT><span class="strong">triple_fn_updates</span>
<DD>
<pre>
‚ä¢ (‚àÄf n n0 n1. triple n n0 n1 with a updated_by f = triple (f n) n0 n1) ‚àß
  (‚àÄf n n0 n1. triple n n0 n1 with b updated_by f = triple n (f n0) n1) ‚àß
  ‚àÄf n n0 n1. triple n n0 n1 with c updated_by f = triple n n0 (f n1)
</pre>

<DT><span class="strong">triple_fupdcanon</span>
<DD>
<pre>
‚ä¢ (‚àÄt g f.
     t with <|b updated_by f; a updated_by g|> =
     t with <|a updated_by g; b updated_by f|>) ‚àß
  (‚àÄt g f.
     t with <|c updated_by f; a updated_by g|> =
     t with <|a updated_by g; c updated_by f|>) ‚àß
  ‚àÄt g f.
    t with <|c updated_by f; b updated_by g|> =
    t with <|b updated_by g; c updated_by f|>
</pre>

<DT><span class="strong">triple_fupdcanon_comp</span>
<DD>
<pre>
‚ä¢ ((‚àÄg f. b_fupd f ‚àò a_fupd g = a_fupd g ‚àò b_fupd f) ‚àß
   ‚àÄh g f. b_fupd f ‚àò a_fupd g ‚àò h = a_fupd g ‚àò b_fupd f ‚àò h) ‚àß
  ((‚àÄg f. c_fupd f ‚àò a_fupd g = a_fupd g ‚àò c_fupd f) ‚àß
   ‚àÄh g f. c_fupd f ‚àò a_fupd g ‚àò h = a_fupd g ‚àò c_fupd f ‚àò h) ‚àß
  (‚àÄg f. c_fupd f ‚àò b_fupd g = b_fupd g ‚àò c_fupd f) ‚àß
  ‚àÄh g f. c_fupd f ‚àò b_fupd g ‚àò h = b_fupd g ‚àò c_fupd f ‚àò h
</pre>

<DT><span class="strong">triple_fupdfupds</span>
<DD>
<pre>
‚ä¢ (‚àÄt g f.
     t with <|a updated_by f; a updated_by g|> = t with a updated_by f ‚àò g) ‚àß
  (‚àÄt g f.
     t with <|b updated_by f; b updated_by g|> = t with b updated_by f ‚àò g) ‚àß
  ‚àÄt g f.
    t with <|c updated_by f; c updated_by g|> = t with c updated_by f ‚àò g
</pre>

<DT><span class="strong">triple_fupdfupds_comp</span>
<DD>
<pre>
‚ä¢ ((‚àÄg f. a_fupd f ‚àò a_fupd g = a_fupd (f ‚àò g)) ‚àß
   ‚àÄh g f. a_fupd f ‚àò a_fupd g ‚àò h = a_fupd (f ‚àò g) ‚àò h) ‚àß
  ((‚àÄg f. b_fupd f ‚àò b_fupd g = b_fupd (f ‚àò g)) ‚àß
   ‚àÄh g f. b_fupd f ‚àò b_fupd g ‚àò h = b_fupd (f ‚àò g) ‚àò h) ‚àß
  (‚àÄg f. c_fupd f ‚àò c_fupd g = c_fupd (f ‚àò g)) ‚àß
  ‚àÄh g f. c_fupd f ‚àò c_fupd g ‚àò h = c_fupd (f ‚àò g) ‚àò h
</pre>

<DT><span class="strong">triple_induction</span>
<DD>
<pre>
‚ä¢ ‚àÄP. (‚àÄn n0 n1. P (triple n n0 n1)) ‚áí ‚àÄt. P t
</pre>

<DT><span class="strong">triple_literal_11</span>
<DD>
<pre>
‚ä¢ ‚àÄn11 n01 n1 n12 n02 n2.
    <|a := n11; b := n01; c := n1|> = <|a := n12; b := n02; c := n2|> ‚áî
    n11 = n12 ‚àß n01 = n02 ‚àß n1 = n2
</pre>

<DT><span class="strong">triple_literal_nchotomy</span>
<DD>
<pre>
‚ä¢ ‚àÄt. ‚àÉn1 n0 n. t = <|a := n1; b := n0; c := n|>
</pre>

<DT><span class="strong">triple_nchotomy</span>
<DD>
<pre>
‚ä¢ ‚àÄtt. ‚àÉn n0 n1. tt = triple n n0 n1
</pre>

<DT><span class="strong">triple_updates_eq_literal</span>
<DD>
<pre>
‚ä¢ ‚àÄt n1 n0 n.
    t with <|a := n1; b := n0; c := n|> = <|a := n1; b := n0; c := n|>
</pre>

<DT><span class="strong">turn_eq_nil</span>
<DD>
<pre>
‚ä¢ ‚àÄp. turn p = [] ‚áî p = []
</pre>

<DT><span class="strong">turn_exp_0</span>
<DD>
<pre>
‚ä¢ ‚àÄl. turn_exp l 0 = l
</pre>

<DT><span class="strong">turn_exp_1</span>
<DD>
<pre>
‚ä¢ ‚àÄl. turn_exp l 1 = turn l
</pre>

<DT><span class="strong">turn_exp_2</span>
<DD>
<pre>
‚ä¢ ‚àÄl. turn_exp l 2 = turn (turn l)
</pre>

<DT><span class="strong">turn_exp_SUC</span>
<DD>
<pre>
‚ä¢ ‚àÄl n. turn_exp l (SUC n) = turn_exp (turn l) n
</pre>

<DT><span class="strong">turn_exp_length</span>
<DD>
<pre>
‚ä¢ ‚àÄl n. LENGTH (turn_exp l n) = LENGTH l
</pre>

<DT><span class="strong">turn_exp_suc</span>
<DD>
<pre>
‚ä¢ ‚àÄl n. turn_exp l (SUC n) = turn (turn_exp l n)
</pre>

<DT><span class="strong">turn_length</span>
<DD>
<pre>
‚ä¢ ‚àÄl. LENGTH (turn l) = LENGTH l
</pre>

<DT><span class="strong">turn_nil</span>
<DD>
<pre>
‚ä¢ turn [] = []
</pre>

<DT><span class="strong">turn_not_nil</span>
<DD>
<pre>
‚ä¢ ‚àÄl. l ‚â† [] ‚áí turn l = LAST l::FRONT l
</pre>

<DT><span class="strong">turn_snoc</span>
<DD>
<pre>
‚ä¢ ‚àÄls x. turn (SNOC x ls) = x::ls
</pre>

</DL>



<hr>
</body>
</html>
