<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: combinatorics</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "combinatorics"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "numberTheory.html"><span class="strong">number</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Type <th> Arity<tr><td>
    <span class="strong">triple</span>
    <td>
    0
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">DILATE</span>
    <td>
    :α -> num -> num -> α list -> α list
    <tr><td>
    <span class="strong">MAP3</span>
    <td>
    :(β -> γ -> δ -> α) -> β list -> γ list -> δ list -> α list
    <tr><td>
    <span class="strong">MDILATE</span>
    <td>
    :α -> num -> α list -> α list
    <tr><td> <span class="strong">PROD</span> <td> :num list -> num
    <tr><td> <span class="strong">PROD_ACC</span> <td> :num list -> num -> num
    <tr><td> <span class="strong">arrange</span> <td> :num -> num -> num
    <tr><td> <span class="strong">binomial</span> <td> :num -> num -> num
    <tr><td> <span class="strong">choose</span> <td> :num -> num -> num
    <tr><td>
    <span class="strong">interleave</span>
    <td>
    :α -> α list -> α list -> bool
    <tr><td> <span class="strong">lcm_upto</span> <td> :num -> num
    <tr><td> <span class="strong">leibniz</span> <td> :num -> num -> num
    <tr><td>
    <span class="strong">leibniz_zigzag</span>
    <td>
    :num list -> num list -> bool
    <tr><td>
    <span class="strong">list_count</span>
    <td>
    :num -> num -> num list -> bool
    <tr><td> <span class="strong">list_lcm</span> <td> :num list -> num
    <tr><td>
    <span class="strong">monocoloured</span>
    <td>
    :num -> num -> num list -> bool
    <tr><td>
    <span class="strong">multicoloured</span>
    <td>
    :num -> num -> num list -> bool
    <tr><td>
    <span class="strong">necklace</span>
    <td>
    :num -> num -> num list -> bool
    <tr><td> <span class="strong">perm</span> <td> :num -> num
    <tr><td>
    <span class="strong">perm_count</span>
    <td>
    :num -> num list -> bool
    <tr><td>
    <span class="strong">perm_set</span>
    <td>
    :(α -> bool) -> α list -> bool
    <tr><td>
    <span class="strong">recordtype.triple</span>
    <td>
    :num -> num -> num -> triple
    <tr><td>
    <span class="strong">recordtype.triple.seldef.a</span>
    <td>
    :triple -> num
    <tr><td>
    <span class="strong">recordtype.triple.seldef.a_fupd</span>
    <td>
    :(num -> num) -> triple -> triple
    <tr><td>
    <span class="strong">recordtype.triple.seldef.b</span>
    <td>
    :triple -> num
    <tr><td>
    <span class="strong">recordtype.triple.seldef.b_fupd</span>
    <td>
    :(num -> num) -> triple -> triple
    <tr><td>
    <span class="strong">recordtype.triple.seldef.c</span>
    <td>
    :triple -> num
    <tr><td>
    <span class="strong">recordtype.triple.seldef.c_fupd</span>
    <td>
    :(num -> num) -> triple -> triple
    <tr><td> <span class="strong">rotate</span> <td> :num -> α list -> α list
    <tr><td> <span class="strong">set_lcm</span> <td> :(num -> bool) -> num
    <tr><td>
    <span class="strong">sub_count</span>
    <td>
    :num -> num -> (num -> bool) -> bool
    <tr><td>
    <span class="strong">sub_sets</span>
    <td>
    :(α -> bool) -> num -> (α -> bool) -> bool
    <tr><td>
    <span class="strong">triple_CASE</span>
    <td>
    :triple -> (num -> num -> num -> α) -> α
    <tr><td> <span class="strong">triple_size</span> <td> :triple -> num
    <tr><td> <span class="strong">triplet</span> <td> :num -> num -> triple
    <tr><td> <span class="strong">turn</span> <td> :α list -> α list
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">MDILATE_def</span>
<DD>
<pre>
⊢ (∀e n. MDILATE e n [] = []) ∧
  ∀e n h t.
    MDILATE e n (h::t) =
    if t = [] then [h] else h::GENLIST (K e) (PRE n) ++ MDILATE e n t
</pre>

<DT><span class="strong">PROD</span>
<DD>
<pre>
⊢ PROD [] = 1 ∧ ∀h t. PROD (h::t) = h * PROD t
</pre>

<DT><span class="strong">PROD_ACC_DEF</span>
<DD>
<pre>
⊢ (∀acc. PROD_ACC [] acc = acc) ∧
  ∀h t acc. PROD_ACC (h::t) acc = PROD_ACC t (h * acc)
</pre>

<DT><span class="strong">arrange_def</span>
<DD>
<pre>
⊢ ∀n k. n arrange k = CARD (list_count n k)
</pre>

<DT><span class="strong">choose_def</span>
<DD>
<pre>
⊢ ∀n k. n choose k = CARD (sub_count n k)
</pre>

<DT><span class="strong">interleave_def</span>
<DD>
<pre>
⊢ ∀x ls.
    x interleave ls = IMAGE (λk. TAKE k ls ++ x::DROP k ls) (upto (LENGTH ls))
</pre>

<DT><span class="strong">lcm_upto_def</span>
<DD>
<pre>
⊢ lcm_upto 0 = 1 ∧ ∀n. lcm_upto (SUC n) = lcm (SUC n) (lcm_upto n)
</pre>

<DT><span class="strong">leibniz_def</span>
<DD>
<pre>
⊢ ∀n k. leibniz n k = (n + 1) * binomial n k
</pre>

<DT><span class="strong">leibniz_zigzag_def</span>
<DD>
<pre>
⊢ ∀p1 p2.
    p1 zigzag p2 ⇔
    ∃n k x y.
      p1 = x ++ [(triplet n k).b; (triplet n k).a] ++ y ∧
      p2 = x ++ [(triplet n k).b; (triplet n k).c] ++ y
</pre>

<DT><span class="strong">list_count_def</span>
<DD>
<pre>
⊢ ∀n k.
    list_count n k =
    {ls | ALL_DISTINCT ls ∧ LIST_TO_SET ls ⊆ count n ∧ LENGTH ls = k}
</pre>

<DT><span class="strong">list_lcm_def</span>
<DD>
<pre>
⊢ list_lcm [] = 1 ∧ ∀h t. list_lcm (h::t) = lcm h (list_lcm t)
</pre>

<DT><span class="strong">monocoloured_def</span>
<DD>
<pre>
⊢ ∀n a.
    monocoloured n a =
    {ls | ls ∈ necklace n a ∧ (ls ≠ [] ⇒ SING (LIST_TO_SET ls))}
</pre>

<DT><span class="strong">multicoloured_def</span>
<DD>
<pre>
⊢ ∀n a. multicoloured n a = necklace n a DIFF monocoloured n a
</pre>

<DT><span class="strong">necklace_def</span>
<DD>
<pre>
⊢ ∀n a. necklace n a = {ls | LENGTH ls = n ∧ LIST_TO_SET ls ⊆ count a}
</pre>

<DT><span class="strong">perm_count_def</span>
<DD>
<pre>
⊢ ∀n. perm_count n = {ls | ALL_DISTINCT ls ∧ LIST_TO_SET ls = count n}
</pre>

<DT><span class="strong">perm_def</span>
<DD>
<pre>
⊢ ∀n. perm n = CARD (perm_count n)
</pre>

<DT><span class="strong">perm_set_def</span>
<DD>
<pre>
⊢ ∀s. perm_set s = {ls | ALL_DISTINCT ls ∧ LIST_TO_SET ls = s}
</pre>

<DT><span class="strong">recordtype_triple_seldef_a_def</span>
<DD>
<pre>
⊢ ∀n n0 n1. (triple n n0 n1).a = n
</pre>

<DT><span class="strong">recordtype_triple_seldef_a_fupd_def</span>
<DD>
<pre>
⊢ ∀f n n0 n1. triple n n0 n1 with a updated_by f = triple (f n) n0 n1
</pre>

<DT><span class="strong">recordtype_triple_seldef_b_def</span>
<DD>
<pre>
⊢ ∀n n0 n1. (triple n n0 n1).b = n0
</pre>

<DT><span class="strong">recordtype_triple_seldef_b_fupd_def</span>
<DD>
<pre>
⊢ ∀f n n0 n1. triple n n0 n1 with b updated_by f = triple n (f n0) n1
</pre>

<DT><span class="strong">recordtype_triple_seldef_c_def</span>
<DD>
<pre>
⊢ ∀n n0 n1. (triple n n0 n1).c = n1
</pre>

<DT><span class="strong">recordtype_triple_seldef_c_fupd_def</span>
<DD>
<pre>
⊢ ∀f n n0 n1. triple n n0 n1 with c updated_by f = triple n n0 (f n1)
</pre>

<DT><span class="strong">rotate_def</span>
<DD>
<pre>
⊢ ∀n l. rotate n l = DROP n l ++ TAKE n l
</pre>

<DT><span class="strong">set_lcm_def</span>
<DD>
<pre>
⊢ ∀s. set_lcm s = list_lcm (SET_TO_LIST s)
</pre>

<DT><span class="strong">sub_count_def</span>
<DD>
<pre>
⊢ ∀n k. sub_count n k = {s | s ⊆ count n ∧ CARD s = k}
</pre>

<DT><span class="strong">sub_sets_def</span>
<DD>
<pre>
⊢ ∀P k. sub_sets P k = {s | s ⊆ P ∧ CARD s = k}
</pre>

<DT><span class="strong">triple_TY_DEF</span>
<DD>
<pre>
⊢ ∃rep.
    TYPE_DEFINITION
      (λa0'.
           ∀ $var$('triple').
             (∀a0'.
                (∃a0 a1 a2.
                   a0' =
                   (λa0 a1 a2.
                        ind_type$CONSTR 0 (a0,a1,a2) (λn. ind_type$BOTTOM)) a0
                     a1 a2) ⇒
                $var$('triple') a0') ⇒
             $var$('triple') a0') rep
</pre>

<DT><span class="strong">triple_case_def</span>
<DD>
<pre>
⊢ ∀a0 a1 a2 f. triple_CASE (triple a0 a1 a2) f = f a0 a1 a2
</pre>

<DT><span class="strong">triple_size_def</span>
<DD>
<pre>
⊢ ∀a0 a1 a2. triple_size (triple a0 a1 a2) = 1 + (a0 + (a1 + a2))
</pre>

<DT><span class="strong">triplet_def</span>
<DD>
<pre>
⊢ ∀n k.
    triplet n k =
    <|a := leibniz n k; b := leibniz (n + 1) k; c := leibniz (n + 1) (k + 1)|>
</pre>

<DT><span class="strong">turn_def</span>
<DD>
<pre>
⊢ ∀l. turn l = if l = [] then [] else LAST l::FRONT l
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">CARD_LIST_TO_SET_EQ</span>
<DD>
<pre>
⊢ ∀l. CARD (LIST_TO_SET l) = LENGTH (nub l)
</pre>

<DT><span class="strong">DILATE_0_0</span>
<DD>
<pre>
⊢ ∀l e. DILATE e 0 0 l = l
</pre>

<DT><span class="strong">DILATE_0_CONS</span>
<DD>
<pre>
⊢ ∀n h t e.
    DILATE e 0 n (h::t) =
    if t = [] then [h] else h::(GENLIST (K e) n ++ DILATE e 0 n t)
</pre>

<DT><span class="strong">DILATE_0_EL</span>
<DD>
<pre>
⊢ ∀l e n k.
    k < LENGTH (DILATE e 0 n l) ⇒
    EL k (DILATE e 0 n l) = if k MOD SUC n = 0 then EL (k DIV SUC n) l else e
</pre>

<DT><span class="strong">DILATE_0_EQ_NIL</span>
<DD>
<pre>
⊢ ∀l e n. DILATE e 0 n l = [] ⇔ l = []
</pre>

<DT><span class="strong">DILATE_0_LAST</span>
<DD>
<pre>
⊢ ∀l e n. LAST (DILATE e 0 n l) = LAST l
</pre>

<DT><span class="strong">DILATE_0_LENGTH</span>
<DD>
<pre>
⊢ ∀l e n.
    LENGTH (DILATE e 0 n l) =
    if l = [] then 0 else SUC (SUC n * PRE (LENGTH l))
</pre>

<DT><span class="strong">DILATE_0_LENGTH_LOWER</span>
<DD>
<pre>
⊢ ∀l e n. LENGTH l ≤ LENGTH (DILATE e 0 n l)
</pre>

<DT><span class="strong">DILATE_0_LENGTH_UPPER</span>
<DD>
<pre>
⊢ ∀l e n. LENGTH (DILATE e 0 n l) ≤ SUC (SUC n * PRE (LENGTH l))
</pre>

<DT><span class="strong">DILATE_0_SUC</span>
<DD>
<pre>
⊢ ∀l e n. DILATE e 0 (SUC n) l = DILATE e n 1 (DILATE e 0 n l)
</pre>

<DT><span class="strong">DILATE_CONS</span>
<DD>
<pre>
⊢ ∀n m h t e.
    DILATE e n m (h::t) =
    if t = [] then [h]
    else h::(TAKE n t ++ GENLIST (K e) m ++ DILATE e n m (DROP n t))
</pre>

<DT><span class="strong">DILATE_NIL</span>
<DD>
<pre>
⊢ ∀n m e. DILATE e n m [] = []
</pre>

<DT><span class="strong">DILATE_SING</span>
<DD>
<pre>
⊢ ∀n m h e. DILATE e n m [h] = [h]
</pre>

<DT><span class="strong">DILATE_def</span>
<DD>
<pre>
⊢ (∀n m e. DILATE e n m [] = []) ∧ (∀n m h e. DILATE e n m [h] = [h]) ∧
  ∀v9 v8 n m h e.
    DILATE e n m (h::v8::v9) =
    h::(TAKE n (v8::v9) ++ GENLIST (K e) m ++ DILATE e n m (DROP n (v8::v9)))
</pre>

<DT><span class="strong">DILATE_ind</span>
<DD>
<pre>
⊢ ∀P. (∀e n m. P e n m []) ∧ (∀e n m h. P e n m [h]) ∧
      (∀e n m h v8 v9. P e n m (DROP n (v8::v9)) ⇒ P e n m (h::v8::v9)) ⇒
      ∀v v1 v2 v3. P v v1 v2 v3
</pre>

<DT><span class="strong">EL_ALL_PROPERTY</span>
<DD>
<pre>
⊢ ∀h1 t1 h2 t2 P.
    LENGTH (h1::t1) = LENGTH (h2::t2) ∧
    (∀k. k < LENGTH (h1::t1) ⇒ P (EL k (h1::t1)) (EL k (h2::t2))) ⇒
    P h1 h2 ∧ ∀k. k < LENGTH t1 ⇒ P (EL k t1) (EL k t2)
</pre>

<DT><span class="strong">EL_MAP3</span>
<DD>
<pre>
⊢ ∀lx ly lz n.
    n < MIN (MIN (LENGTH lx) (LENGTH ly)) (LENGTH lz) ⇒
    ∀f. EL n (MAP3 f lx ly lz) = f (EL n lx) (EL n ly) (EL n lz)
</pre>

<DT><span class="strong">EVERY_ELEMENT_PROPERTY</span>
<DD>
<pre>
⊢ ∀p R. EVERY (λc. c ∈ R) p ⇒ ∀k. k < LENGTH p ⇒ EL k p ∈ R
</pre>

<DT><span class="strong">EVERY_LT_IMP_EVERY_LE</span>
<DD>
<pre>
⊢ ∀ls n. EVERY (λj. j < n) ls ⇒ EVERY (λj. j ≤ n) ls
</pre>

<DT><span class="strong">EVERY_MONOTONIC_MAP</span>
<DD>
<pre>
⊢ ∀l f P Q. (∀x. P x ⇒ (Q ∘ f) x) ∧ EVERY P l ⇒ EVERY Q (MAP f l)
</pre>

<DT><span class="strong">EXISTS_triple</span>
<DD>
<pre>
⊢ ∀P. (∃t. P t) ⇔ ∃n1 n0 n. P <|a := n1; b := n0; c := n|>
</pre>

<DT><span class="strong">FILTER_EL_NEXT_IDX</span>
<DD>
<pre>
⊢ ∀P ls l1 l2 l3 x y.
    (let
       fs = FILTER P ls
     in
       ALL_DISTINCT ls ∧ ls = l1 ++ x::l2 ++ y::l3 ∧ P x ∧ P y ⇒
       (findi y fs = 1 + findi x fs ⇔ FILTER P l2 = []))
</pre>

<DT><span class="strong">FINITE_SURJ_IFF</span>
<DD>
<pre>
⊢ ∀f s t.
    FINITE t ⇒ (SURJ f s t ⇔ CARD (IMAGE f s) = CARD t ∧ ∀x. x ∈ s ⇒ f x ∈ t)
</pre>

<DT><span class="strong">FORALL_triple</span>
<DD>
<pre>
⊢ ∀P. (∀t. P t) ⇔ ∀n1 n0 n. P <|a := n1; b := n0; c := n|>
</pre>

<DT><span class="strong">FUNPOW_cons_eq_map_0</span>
<DD>
<pre>
⊢ ∀f u n.
    FUNPOW (λls. f (HD ls)::ls) n [u] = MAP (λj. FUNPOW f j u) (n downto 0)
</pre>

<DT><span class="strong">FUNPOW_cons_eq_map_1</span>
<DD>
<pre>
⊢ ∀f u n.
    0 < n ⇒
    FUNPOW (λls. f (HD ls)::ls) (n − 1) [f u] =
    MAP (λj. FUNPOW f j u) (n downto 1)
</pre>

<DT><span class="strong">FUNPOW_cons_head</span>
<DD>
<pre>
⊢ ∀f n ls. HD (FUNPOW (λls. f (HD ls)::ls) n ls) = FUNPOW f n (HD ls)
</pre>

<DT><span class="strong">FUNSET_ALT</span>
<DD>
<pre>
⊢ ∀P Q. (P → Q) = {f | ∀x. x ∈ P ⇒ f x ∈ Q}
</pre>

<DT><span class="strong">GENLIST_MONO_DEC</span>
<DD>
<pre>
⊢ ∀f n. RMONO f ⇒ MONO_DEC (GENLIST f n)
</pre>

<DT><span class="strong">GENLIST_MONO_INC</span>
<DD>
<pre>
⊢ ∀f n. MONO f ⇒ MONO_INC (GENLIST f n)
</pre>

<DT><span class="strong">GENLIST_binomial_index_shift</span>
<DD>
<pre>
⊢ ∀n x y.
    GENLIST ((λk. binomial n k * x ** SUC (n − k) * y ** k) ∘ SUC) n =
    GENLIST (λk. binomial n (SUC k) * x ** (n − k) * y ** SUC k) n
</pre>

<DT><span class="strong">INJ_IFF_BIJ_IMAGE</span>
<DD>
<pre>
⊢ ∀f s t. (∀x. x ∈ s ⇒ f x ∈ t) ⇒ (INJ f s t ⇔ BIJ f s (IMAGE f s))
</pre>

<DT><span class="strong">INJ_IMAGE_BIJ_IFF</span>
<DD>
<pre>
⊢ ∀f s t. INJ f s t ⇔ BIJ f s (IMAGE f s) ∧ ∀x. x ∈ s ⇒ f x ∈ t
</pre>

<DT><span class="strong">INJ_IMAGE_IFF</span>
<DD>
<pre>
⊢ ∀f s t. INJ f s t ⇔ INJ f s (IMAGE f s) ∧ ∀x. x ∈ s ⇒ f x ∈ t
</pre>

<DT><span class="strong">LENGTH_MAP3</span>
<DD>
<pre>
⊢ ∀lx ly lz f.
    LENGTH (MAP3 f lx ly lz) = MIN (MIN (LENGTH lx) (LENGTH ly)) (LENGTH lz)
</pre>

<DT><span class="strong">LIST_TO_SET_REDUCTION</span>
<DD>
<pre>
⊢ ∀l1 l2 h.
    ¬MEM h l1 ∧ LIST_TO_SET (h::l1) = LIST_TO_SET l2 ⇒
    ∃p1 p2.
      ¬MEM h p1 ∧ ¬MEM h p2 ∧ nub l2 = p1 ++ [h] ++ p2 ∧
      LIST_TO_SET l1 = LIST_TO_SET (p1 ++ p2)
</pre>

<DT><span class="strong">LUPDATE_APPEND_0</span>
<DD>
<pre>
⊢ ∀ls a h t. LUPDATE a (LENGTH ls) (ls ++ h::t) = ls ++ a::t
</pre>

<DT><span class="strong">LUPDATE_APPEND_0_1</span>
<DD>
<pre>
⊢ ∀ls a b h k t.
    LUPDATE b (LENGTH ls + 1) (LUPDATE a (LENGTH ls) (ls ++ h::k::t)) =
    ls ++ a::b::t
</pre>

<DT><span class="strong">LUPDATE_APPEND_1</span>
<DD>
<pre>
⊢ ∀ls b h k t. LUPDATE b (LENGTH ls + 1) (ls ++ h::k::t) = ls ++ h::b::t
</pre>

<DT><span class="strong">LUPDATE_DIFF_SPOT</span>
<DD>
<pre>
⊢ ∀ls m n p q.
    m ≠ n ⇒ LUPDATE q n (LUPDATE p m ls) = LUPDATE p m (LUPDATE q n ls)
</pre>

<DT><span class="strong">LUPDATE_EL</span>
<DD>
<pre>
⊢ ∀e n l p. p < LENGTH l ⇒ EL p (LUPDATE e n l) = if p = n then e else EL p l
</pre>

<DT><span class="strong">LUPDATE_LEN</span>
<DD>
<pre>
⊢ ∀e n l. LENGTH (LUPDATE e n l) = LENGTH l
</pre>

<DT><span class="strong">LUPDATE_SAME_SPOT</span>
<DD>
<pre>
⊢ ∀ls n p q. LUPDATE q n (LUPDATE p n ls) = LUPDATE q n ls
</pre>

<DT><span class="strong">MAP2_LE</span>
<DD>
<pre>
⊢ ∀f g.
    (∀x y. f x y ≤ g x y) ⇒
    ∀lx ly n. EL n (MAP2 f lx ly) ≤ EL n (MAP2 g lx ly)
</pre>

<DT><span class="strong">MAP3</span>
<DD>
<pre>
⊢ (∀f. MAP3 f [] [] [] = []) ∧
  ∀f h1 t1 h2 t2 h3 t3.
    MAP3 f (h1::t1) (h2::t2) (h3::t3) = f h1 h2 h3::MAP3 f t1 t2 t3
</pre>

<DT><span class="strong">MAP3_DEF</span>
<DD>
<pre>
⊢ (∀t3 t2 t1 h3 h2 h1 f.
     MAP3 f (h1::t1) (h2::t2) (h3::t3) = f h1 h2 h3::MAP3 f t1 t2 t3) ∧
  (∀z y f. MAP3 f [] y z = []) ∧ (∀z v5 v4 f. MAP3 f (v4::v5) [] z = []) ∧
  ∀v5 v4 v13 v12 f. MAP3 f (v4::v5) (v12::v13) [] = []
</pre>

<DT><span class="strong">MAP3_IND</span>
<DD>
<pre>
⊢ ∀P. (∀f h1 t1 h2 t2 h3 t3. P f t1 t2 t3 ⇒ P f (h1::t1) (h2::t2) (h3::t3)) ∧
      (∀f y z. P f [] y z) ∧ (∀f v4 v5 z. P f (v4::v5) [] z) ∧
      (∀f v4 v5 v12 v13. P f (v4::v5) (v12::v13) []) ⇒
      ∀v v1 v2 v3. P v v1 v2 v3
</pre>

<DT><span class="strong">MAP3_LE</span>
<DD>
<pre>
⊢ ∀f g.
    (∀x y z. f x y z ≤ g x y z) ⇒
    ∀lx ly lz n. EL n (MAP3 f lx ly lz) ≤ EL n (MAP3 g lx ly lz)
</pre>

<DT><span class="strong">MAP_LE</span>
<DD>
<pre>
⊢ ∀f g. (∀x. f x ≤ g x) ⇒ ∀ls n. EL n (MAP f ls) ≤ EL n (MAP g ls)
</pre>

<DT><span class="strong">MAX_LIST_MONO_MAP</span>
<DD>
<pre>
⊢ ∀f. MONO f ⇒ ∀ls. ls ≠ [] ⇒ MAX_LIST (MAP f ls) = f (MAX_LIST ls)
</pre>

<DT><span class="strong">MDILATE_0</span>
<DD>
<pre>
⊢ ∀l e. MDILATE e 0 l = l
</pre>

<DT><span class="strong">MDILATE_1</span>
<DD>
<pre>
⊢ ∀l e. MDILATE e 1 l = l
</pre>

<DT><span class="strong">MDILATE_CONS</span>
<DD>
<pre>
⊢ ∀e n h t.
    MDILATE e n (h::t) =
    if t = [] then [h] else h::GENLIST (K e) (PRE n) ++ MDILATE e n t
</pre>

<DT><span class="strong">MDILATE_EL</span>
<DD>
<pre>
⊢ ∀l e n k.
    k < LENGTH (MDILATE e n l) ⇒
    EL k (MDILATE e n l) =
    if n = 0 then EL k l else if k MOD n = 0 then EL (k DIV n) l else e
</pre>

<DT><span class="strong">MDILATE_EQ_NIL</span>
<DD>
<pre>
⊢ ∀l e n. MDILATE e n l = [] ⇔ l = []
</pre>

<DT><span class="strong">MDILATE_LAST</span>
<DD>
<pre>
⊢ ∀l e n. LAST (MDILATE e n l) = LAST l
</pre>

<DT><span class="strong">MDILATE_LENGTH</span>
<DD>
<pre>
⊢ ∀l e n.
    LENGTH (MDILATE e n l) =
    if n = 0 then LENGTH l else if l = [] then 0 else SUC (n * PRE (LENGTH l))
</pre>

<DT><span class="strong">MDILATE_LENGTH_LOWER</span>
<DD>
<pre>
⊢ ∀l e n. LENGTH l ≤ LENGTH (MDILATE e n l)
</pre>

<DT><span class="strong">MDILATE_LENGTH_UPPER</span>
<DD>
<pre>
⊢ ∀l e n. 0 < n ⇒ LENGTH (MDILATE e n l) ≤ SUC (n * PRE (LENGTH l))
</pre>

<DT><span class="strong">MDILATE_NIL</span>
<DD>
<pre>
⊢ ∀e n. MDILATE e n [] = []
</pre>

<DT><span class="strong">MDILATE_SING</span>
<DD>
<pre>
⊢ ∀e n x. MDILATE e n [x] = [x]
</pre>

<DT><span class="strong">MEM_MAP2</span>
<DD>
<pre>
⊢ ∀f x l1 l2.
    MEM x (MAP2 f l1 l2) ⇒ ∃y1 y2. x = f y1 y2 ∧ MEM y1 l1 ∧ MEM y2 l2
</pre>

<DT><span class="strong">MEM_MAP2_LOWER</span>
<DD>
<pre>
⊢ ∀f. MONO2 f ⇒
      ∀lx ly e. MEM e (MAP2 f lx ly) ⇒ f (MIN_LIST lx) (MIN_LIST ly) ≤ e
</pre>

<DT><span class="strong">MEM_MAP2_UPPER</span>
<DD>
<pre>
⊢ ∀f. MONO2 f ⇒
      ∀lx ly e. MEM e (MAP2 f lx ly) ⇒ e ≤ f (MAX_LIST lx) (MAX_LIST ly)
</pre>

<DT><span class="strong">MEM_MAP3</span>
<DD>
<pre>
⊢ ∀f x l1 l2 l3.
    MEM x (MAP3 f l1 l2 l3) ⇒
    ∃y1 y2 y3. x = f y1 y2 y3 ∧ MEM y1 l1 ∧ MEM y2 l2 ∧ MEM y3 l3
</pre>

<DT><span class="strong">MEM_MAP3_LOWER</span>
<DD>
<pre>
⊢ ∀f. MONO3 f ⇒
      ∀lx ly lz e.
        MEM e (MAP3 f lx ly lz) ⇒
        f (MIN_LIST lx) (MIN_LIST ly) (MIN_LIST lz) ≤ e
</pre>

<DT><span class="strong">MEM_MAP3_UPPER</span>
<DD>
<pre>
⊢ ∀f. MONO3 f ⇒
      ∀lx ly lz e.
        MEM e (MAP3 f lx ly lz) ⇒
        e ≤ f (MAX_LIST lx) (MAX_LIST ly) (MAX_LIST lz)
</pre>

<DT><span class="strong">MEM_MAP_LOWER</span>
<DD>
<pre>
⊢ ∀f. MONO f ⇒ ∀ls e. MEM e (MAP f ls) ⇒ f (MIN_LIST ls) ≤ e
</pre>

<DT><span class="strong">MEM_MAP_UPPER</span>
<DD>
<pre>
⊢ ∀f. MONO f ⇒ ∀ls e. MEM e (MAP f ls) ⇒ e ≤ f (MAX_LIST ls)
</pre>

<DT><span class="strong">MIN_LIST_MONO_MAP</span>
<DD>
<pre>
⊢ ∀f. MONO f ⇒ ∀ls. ls ≠ [] ⇒ MIN_LIST (MAP f ls) = f (MIN_LIST ls)
</pre>

<DT><span class="strong">MONO_LIST_TO_SET</span>
<DD>
<pre>
⊢ ∀x. LIST_TO_SET [x] = {x}
</pre>

<DT><span class="strong">PAD_LEFT_0</span>
<DD>
<pre>
⊢ ∀l c. PAD_LEFT c 0 l = l
</pre>

<DT><span class="strong">PAD_LEFT_BY_LEFT</span>
<DD>
<pre>
⊢ ∀ls c n. PAD_LEFT c n ls = PAD_LEFT c (n − LENGTH ls) [] ++ ls
</pre>

<DT><span class="strong">PAD_LEFT_BY_RIGHT</span>
<DD>
<pre>
⊢ ∀ls c n. PAD_LEFT c n ls = PAD_RIGHT c (n − LENGTH ls) [] ++ ls
</pre>

<DT><span class="strong">PAD_LEFT_CONS</span>
<DD>
<pre>
⊢ ∀l n. LENGTH l ≤ n ⇒ ∀c. PAD_LEFT c (SUC n) l = c::PAD_LEFT c n l
</pre>

<DT><span class="strong">PAD_LEFT_EQ_NIL</span>
<DD>
<pre>
⊢ ∀l c n. PAD_LEFT c n l = [] ⇔ l = [] ∧ n = 0
</pre>

<DT><span class="strong">PAD_LEFT_ID</span>
<DD>
<pre>
⊢ ∀l c n. n ≤ LENGTH l ⇒ PAD_LEFT c n l = l
</pre>

<DT><span class="strong">PAD_LEFT_LAST</span>
<DD>
<pre>
⊢ ∀l c n. l ≠ [] ⇒ LAST (PAD_LEFT c n l) = LAST l
</pre>

<DT><span class="strong">PAD_LEFT_LENGTH</span>
<DD>
<pre>
⊢ ∀n c s. LENGTH (PAD_LEFT c n s) = MAX n (LENGTH s)
</pre>

<DT><span class="strong">PAD_LEFT_NIL</span>
<DD>
<pre>
⊢ ∀n c. PAD_LEFT c n [] = GENLIST (K c) n
</pre>

<DT><span class="strong">PAD_LEFT_NIL_EQ</span>
<DD>
<pre>
⊢ ∀n c. 0 < n ⇒ PAD_LEFT c n [] = PAD_LEFT c n [c]
</pre>

<DT><span class="strong">PAD_RIGHT_0</span>
<DD>
<pre>
⊢ ∀l c. PAD_RIGHT c 0 l = l
</pre>

<DT><span class="strong">PAD_RIGHT_BY_LEFT</span>
<DD>
<pre>
⊢ ∀ls c n. PAD_RIGHT c n ls = ls ++ PAD_LEFT c (n − LENGTH ls) []
</pre>

<DT><span class="strong">PAD_RIGHT_BY_RIGHT</span>
<DD>
<pre>
⊢ ∀ls c n. PAD_RIGHT c n ls = ls ++ PAD_RIGHT c (n − LENGTH ls) []
</pre>

<DT><span class="strong">PAD_RIGHT_CONS</span>
<DD>
<pre>
⊢ ∀h t c n. h::PAD_RIGHT c n t = PAD_RIGHT c (SUC n) (h::t)
</pre>

<DT><span class="strong">PAD_RIGHT_EQ_NIL</span>
<DD>
<pre>
⊢ ∀l c n. PAD_RIGHT c n l = [] ⇔ l = [] ∧ n = 0
</pre>

<DT><span class="strong">PAD_RIGHT_ID</span>
<DD>
<pre>
⊢ ∀l c n. n ≤ LENGTH l ⇒ PAD_RIGHT c n l = l
</pre>

<DT><span class="strong">PAD_RIGHT_LENGTH</span>
<DD>
<pre>
⊢ ∀n c s. LENGTH (PAD_RIGHT c n s) = MAX n (LENGTH s)
</pre>

<DT><span class="strong">PAD_RIGHT_NIL</span>
<DD>
<pre>
⊢ ∀n c. PAD_RIGHT c n [] = GENLIST (K c) n
</pre>

<DT><span class="strong">PAD_RIGHT_NIL_EQ</span>
<DD>
<pre>
⊢ ∀n c. 0 < n ⇒ PAD_RIGHT c n [] = PAD_RIGHT c n [c]
</pre>

<DT><span class="strong">PAD_RIGHT_SNOC</span>
<DD>
<pre>
⊢ ∀l n. LENGTH l ≤ n ⇒ ∀c. PAD_RIGHT c (SUC n) l = SNOC c (PAD_RIGHT c n l)
</pre>

<DT><span class="strong">POSITIVE_THM</span>
<DD>
<pre>
⊢ ∀ls. EVERY_POSITIVE ls ⇔ POSITIVE ls
</pre>

<DT><span class="strong">PROD_ACC_PROD_LEM</span>
<DD>
<pre>
⊢ ∀L n. PROD_ACC L n = PROD L * n
</pre>

<DT><span class="strong">PROD_ACC_SUM_LEM</span>
<DD>
<pre>
⊢ ∀L n. PROD_ACC L n = PROD L * n
</pre>

<DT><span class="strong">PROD_APPEND</span>
<DD>
<pre>
⊢ ∀l1 l2. PROD (l1 ++ l2) = PROD l1 * PROD l2
</pre>

<DT><span class="strong">PROD_CONS</span>
<DD>
<pre>
⊢ ∀h t. PROD (h::t) = h * PROD t
</pre>

<DT><span class="strong">PROD_CONSTANT</span>
<DD>
<pre>
⊢ ∀n x. PROD (GENLIST (λj. x) n) = x ** n
</pre>

<DT><span class="strong">PROD_EQ_0</span>
<DD>
<pre>
⊢ ∀l. PROD l = 0 ⇔ MEM 0 l
</pre>

<DT><span class="strong">PROD_GENLIST_K</span>
<DD>
<pre>
⊢ ∀m n. PROD (GENLIST (K m) n) = m ** n
</pre>

<DT><span class="strong">PROD_IMAGE_eq_PROD_MAP_SET_TO_LIST</span>
<DD>
<pre>
⊢ ∀s. FINITE s ⇒ ∀f. ∏ f s = PROD (MAP f (SET_TO_LIST s))
</pre>

<DT><span class="strong">PROD_MAP_FOLDL</span>
<DD>
<pre>
⊢ ∀ls f. PROD (MAP f ls) = FOLDL (λa e. a * f e) 1 ls
</pre>

<DT><span class="strong">PROD_NIL</span>
<DD>
<pre>
⊢ PROD [] = 1
</pre>

<DT><span class="strong">PROD_POS</span>
<DD>
<pre>
⊢ ∀l. EVERY_POSITIVE l ⇒ 0 < PROD l
</pre>

<DT><span class="strong">PROD_POS_ALT</span>
<DD>
<pre>
⊢ ∀l. POSITIVE l ⇒ 0 < PROD l
</pre>

<DT><span class="strong">PROD_PROD_ACC</span>
<DD>
<pre>
⊢ ∀L. PROD L = PROD_ACC L 1
</pre>

<DT><span class="strong">PROD_SING</span>
<DD>
<pre>
⊢ ∀n. PROD [n] = n
</pre>

<DT><span class="strong">PROD_SNOC</span>
<DD>
<pre>
⊢ ∀x l. PROD (SNOC x l) = PROD l * x
</pre>

<DT><span class="strong">PROD_SQUARING_LIST</span>
<DD>
<pre>
⊢ ∀m n. PROD (GENLIST (λj. n ** 2 ** j) m) = n ** tops 2 m
</pre>

<DT><span class="strong">PROD_eq_1</span>
<DD>
<pre>
⊢ ∀ls. PROD ls = 1 ⇔ ∀x. MEM x ls ⇒ x = 1
</pre>

<DT><span class="strong">PROD_eval</span>
<DD>
<pre>
⊢ ∀ls. PROD ls = if ls = [] then 1 else HD ls * PROD (TL ls)
</pre>

<DT><span class="strong">SUM_ADD_GENLIST</span>
<DD>
<pre>
⊢ ∀a b n.
    SUM (GENLIST a n) + SUM (GENLIST b n) = SUM (GENLIST (λk. a k + b k) n)
</pre>

<DT><span class="strong">SUM_CONS</span>
<DD>
<pre>
⊢ ∀h t. SUM (h::t) = h + SUM t
</pre>

<DT><span class="strong">SUM_CONSTANT</span>
<DD>
<pre>
⊢ ∀n x. SUM (GENLIST (λj. x) n) = n * x
</pre>

<DT><span class="strong">SUM_DECOMPOSE_FIRST</span>
<DD>
<pre>
⊢ ∀f n. SUM (GENLIST f (SUC n)) = f 0 + SUM (GENLIST (f ∘ SUC) n)
</pre>

<DT><span class="strong">SUM_DECOMPOSE_FIRST_LAST</span>
<DD>
<pre>
⊢ ∀f n.
    0 < n ⇒
    SUM (GENLIST f (SUC n)) = f 0 + SUM (GENLIST (f ∘ SUC) (PRE n)) + f n
</pre>

<DT><span class="strong">SUM_DECOMPOSE_LAST</span>
<DD>
<pre>
⊢ ∀f n. SUM (GENLIST f (SUC n)) = SUM (GENLIST f n) + f n
</pre>

<DT><span class="strong">SUM_DOUBLING_LIST</span>
<DD>
<pre>
⊢ ∀m n. SUM (GENLIST (λj. n * 2 ** j) m) = n * tops 2 m
</pre>

<DT><span class="strong">SUM_EQ_0</span>
<DD>
<pre>
⊢ ∀l. SUM l = 0 ⇔ EVERY (λx. x = 0) l
</pre>

<DT><span class="strong">SUM_GENLIST</span>
<DD>
<pre>
⊢ ∀f n. SUM (GENLIST f n) = ∑ f (count n)
</pre>

<DT><span class="strong">SUM_GENLIST_APPEND</span>
<DD>
<pre>
⊢ ∀a b n. SUM (GENLIST a n ++ GENLIST b n) = SUM (GENLIST (λk. a k + b k) n)
</pre>

<DT><span class="strong">SUM_GENLIST_K</span>
<DD>
<pre>
⊢ ∀m n. SUM (GENLIST (K m) n) = m * n
</pre>

<DT><span class="strong">SUM_GENLIST_MOD</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒
      ∀f. SUM (GENLIST ((λk. f k) ∘ SUC) (PRE n)) MOD n =
          SUM (GENLIST ((λk. f k MOD n) ∘ SUC) (PRE n)) MOD n
</pre>

<DT><span class="strong">SUM_GENLIST_REVERSE</span>
<DD>
<pre>
⊢ ∀f n. SUM (GENLIST (λj. f (n − j)) n) = SUM (MAP f [1 .. n])
</pre>

<DT><span class="strong">SUM_IMAGE_count</span>
<DD>
<pre>
⊢ ∀f n. ∑ f (count n) = SUM (MAP f [0 ..< n])
</pre>

<DT><span class="strong">SUM_IMAGE_upto</span>
<DD>
<pre>
⊢ ∀f n. ∑ f (upto n) = SUM (MAP f [0 .. n])
</pre>

<DT><span class="strong">SUM_LE</span>
<DD>
<pre>
⊢ ∀l1 l2.
    LENGTH l1 = LENGTH l2 ∧ (∀k. k < LENGTH l1 ⇒ EL k l1 ≤ EL k l2) ⇒
    SUM l1 ≤ SUM l2
</pre>

<DT><span class="strong">SUM_LEFT_ADD_DISTRIB</span>
<DD>
<pre>
⊢ ∀s m n. SUM s * (m + n) = SUM (MAP ($* m) s) + SUM (MAP ($* n) s)
</pre>

<DT><span class="strong">SUM_LE_EL</span>
<DD>
<pre>
⊢ ∀l n. n < LENGTH l ⇒ EL n l ≤ SUM l
</pre>

<DT><span class="strong">SUM_LE_MEM</span>
<DD>
<pre>
⊢ ∀l x. MEM x l ⇒ x ≤ SUM l
</pre>

<DT><span class="strong">SUM_LE_SUM_EL</span>
<DD>
<pre>
⊢ ∀l m n. m < n ∧ n < LENGTH l ⇒ EL m l + EL n l ≤ SUM l
</pre>

<DT><span class="strong">SUM_LOWER</span>
<DD>
<pre>
⊢ ∀ls. MIN_LIST ls * LENGTH ls ≤ SUM ls
</pre>

<DT><span class="strong">SUM_MAP2_K</span>
<DD>
<pre>
⊢ ∀lx ly c. SUM (MAP2 (λx y. c) lx ly) = c * LENGTH (MAP2 (λx y. c) lx ly)
</pre>

<DT><span class="strong">SUM_MAP2_UPPER</span>
<DD>
<pre>
⊢ ∀f. MONO2 f ⇒
      ∀lx ly.
        SUM (MAP2 f lx ly) ≤
        f (MAX_LIST lx) (MAX_LIST ly) * LENGTH (MAP2 f lx ly)
</pre>

<DT><span class="strong">SUM_MAP3_K</span>
<DD>
<pre>
⊢ ∀lx ly lz c.
    SUM (MAP3 (λx y z. c) lx ly lz) = c * LENGTH (MAP3 (λx y z. c) lx ly lz)
</pre>

<DT><span class="strong">SUM_MAP3_UPPER</span>
<DD>
<pre>
⊢ ∀f. MONO3 f ⇒
      ∀lx ly lz.
        SUM (MAP3 f lx ly lz) ≤
        f (MAX_LIST lx) (MAX_LIST ly) (MAX_LIST lz) * LENGTH (MAP3 f lx ly lz)
</pre>

<DT><span class="strong">SUM_MAP_K</span>
<DD>
<pre>
⊢ ∀ls c. SUM (MAP (K c) ls) = c * LENGTH ls
</pre>

<DT><span class="strong">SUM_MAP_K_LE</span>
<DD>
<pre>
⊢ ∀ls a b. a ≤ b ⇒ SUM (MAP (K a) ls) ≤ SUM (MAP (K b) ls)
</pre>

<DT><span class="strong">SUM_MAP_LE</span>
<DD>
<pre>
⊢ ∀f g ls. EVERY (λx. f x ≤ g x) ls ⇒ SUM (MAP f ls) ≤ SUM (MAP g ls)
</pre>

<DT><span class="strong">SUM_MAP_LT</span>
<DD>
<pre>
⊢ ∀f g ls.
    EVERY (λx. f x < g x) ls ∧ ls ≠ [] ⇒ SUM (MAP f ls) < SUM (MAP g ls)
</pre>

<DT><span class="strong">SUM_MAP_UPPER</span>
<DD>
<pre>
⊢ ∀f. MONO f ⇒ ∀ls. SUM (MAP f ls) ≤ f (MAX_LIST ls) * LENGTH ls
</pre>

<DT><span class="strong">SUM_MOD</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ ∀l. SUM l MOD n = SUM (MAP (λx. x MOD n) l) MOD n
</pre>

<DT><span class="strong">SUM_MONO_MAP</span>
<DD>
<pre>
⊢ ∀f1 f2. (∀x. f1 x ≤ f2 x) ⇒ ∀ls. SUM (MAP f1 ls) ≤ SUM (MAP f2 ls)
</pre>

<DT><span class="strong">SUM_MONO_MAP2</span>
<DD>
<pre>
⊢ ∀f1 f2.
    (∀x y. f1 x y ≤ f2 x y) ⇒
    ∀lx ly. SUM (MAP2 f1 lx ly) ≤ SUM (MAP2 f2 lx ly)
</pre>

<DT><span class="strong">SUM_MONO_MAP3</span>
<DD>
<pre>
⊢ ∀f1 f2.
    (∀x y z. f1 x y z ≤ f2 x y z) ⇒
    ∀lx ly lz. SUM (MAP3 f1 lx ly lz) ≤ SUM (MAP3 f2 lx ly lz)
</pre>

<DT><span class="strong">SUM_MULT</span>
<DD>
<pre>
⊢ ∀s k. k * SUM s = SUM (MAP ($* k) s)
</pre>

<DT><span class="strong">SUM_NIL</span>
<DD>
<pre>
⊢ SUM [] = 0
</pre>

<DT><span class="strong">SUM_RIGHT_ADD_DISTRIB</span>
<DD>
<pre>
⊢ ∀s m n. (m + n) * SUM s = SUM (MAP ($* m) s) + SUM (MAP ($* n) s)
</pre>

<DT><span class="strong">SUM_SING</span>
<DD>
<pre>
⊢ ∀n. SUM [n] = n
</pre>

<DT><span class="strong">SUM_UPPER</span>
<DD>
<pre>
⊢ ∀ls. SUM ls ≤ MAX_LIST ls * LENGTH ls
</pre>

<DT><span class="strong">SURJ_CARD_IMAGE_EQ</span>
<DD>
<pre>
⊢ ∀f s t.
    FINITE t ∧ (∀x. x ∈ s ⇒ f x ∈ t) ⇒
    (SURJ f s t ⇔ CARD (IMAGE f s) = CARD t)
</pre>

<DT><span class="strong">arithmetic_sum_eqn</span>
<DD>
<pre>
⊢ ∀n. SUM [1 ..< n] = n * (n − 1) DIV 2
</pre>

<DT><span class="strong">arithmetic_sum_eqn_alt</span>
<DD>
<pre>
⊢ ∀n. SUM [1 .. n] = n * (n + 1) DIV 2
</pre>

<DT><span class="strong">arrange_0_n</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ 0 arrange n = 0
</pre>

<DT><span class="strong">arrange_alt</span>
<DD>
<pre>
⊢ ∀n k. n arrange k = (n choose k) * FACT k
</pre>

<DT><span class="strong">arrange_eq_0</span>
<DD>
<pre>
⊢ ∀n k. n arrange k = 0 ⇔ n < k
</pre>

<DT><span class="strong">arrange_eqn</span>
<DD>
<pre>
⊢ ∀n k. n arrange k = (n choose k) * perm k
</pre>

<DT><span class="strong">arrange_formula</span>
<DD>
<pre>
⊢ ∀n k. n arrange k = binomial n k * FACT k
</pre>

<DT><span class="strong">arrange_formula2</span>
<DD>
<pre>
⊢ ∀n k. k ≤ n ⇒ n arrange k = FACT n DIV FACT (n − k)
</pre>

<DT><span class="strong">arrange_n_0</span>
<DD>
<pre>
⊢ ∀n. n arrange 0 = 1
</pre>

<DT><span class="strong">arrange_n_n</span>
<DD>
<pre>
⊢ ∀n. n arrange n = perm n
</pre>

<DT><span class="strong">arrange_n_n_alt</span>
<DD>
<pre>
⊢ ∀n. n arrange n = FACT n
</pre>

<DT><span class="strong">beta_0_n</span>
<DD>
<pre>
⊢ ∀n. n * binomial 0 n = 0
</pre>

<DT><span class="strong">beta_alt</span>
<DD>
<pre>
⊢ ∀n k. 0 < n ∧ 0 < k ⇒ k * binomial n k = leibniz (n − 1) (k − 1)
</pre>

<DT><span class="strong">beta_divides_beta_factor</span>
<DD>
<pre>
⊢ ∀m n k.
    k ≤ m ∧ m ≤ n ⇒ k * binomial n k divides k * binomial m k * binomial n m
</pre>

<DT><span class="strong">beta_eq_0</span>
<DD>
<pre>
⊢ ∀n k. k * binomial n k = 0 ⇔ k = 0 ∨ n < k
</pre>

<DT><span class="strong">beta_eqn</span>
<DD>
<pre>
⊢ ∀n k. (k + 1) * binomial (n + 1) (k + 1) = leibniz n k
</pre>

<DT><span class="strong">beta_horizontal_0</span>
<DD>
<pre>
⊢ GENLIST ((λk. k * binomial 0 k) ∘ SUC) 0 = []
</pre>

<DT><span class="strong">beta_horizontal_alt</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒
      GENLIST ((λk. k * binomial n k) ∘ SUC) n = leibniz_horizontal (n − 1)
</pre>

<DT><span class="strong">beta_horizontal_element</span>
<DD>
<pre>
⊢ ∀n k.
    k < n ⇒
    EL k (GENLIST ((λk. k * binomial n k) ∘ SUC) n) =
    (k + 1) * binomial n (k + 1)
</pre>

<DT><span class="strong">beta_horizontal_eqn</span>
<DD>
<pre>
⊢ ∀n. GENLIST ((λk. k * binomial (n + 1) k) ∘ SUC) (n + 1) =
      leibniz_horizontal n
</pre>

<DT><span class="strong">beta_horizontal_len</span>
<DD>
<pre>
⊢ ∀n. LENGTH (GENLIST ((λk. k * binomial n k) ∘ SUC) n) = n
</pre>

<DT><span class="strong">beta_horizontal_mem</span>
<DD>
<pre>
⊢ ∀n k.
    0 < k ∧ k ≤ n ⇒
    MEM (k * binomial n k) (GENLIST ((λk. k * binomial n k) ∘ SUC) n)
</pre>

<DT><span class="strong">beta_horizontal_mem_iff</span>
<DD>
<pre>
⊢ ∀n k.
    MEM (k * binomial n k) (GENLIST ((λk. k * binomial n k) ∘ SUC) n) ⇔
    0 < k ∧ k ≤ n
</pre>

<DT><span class="strong">beta_horizontal_member</span>
<DD>
<pre>
⊢ ∀n x.
    MEM x (GENLIST ((λk. k * binomial n k) ∘ SUC) n) ⇔
    ∃k. 0 < k ∧ k ≤ n ∧ x = k * binomial n k
</pre>

<DT><span class="strong">beta_less_0</span>
<DD>
<pre>
⊢ ∀n k. n < k ⇒ k * binomial n k = 0
</pre>

<DT><span class="strong">beta_n_0</span>
<DD>
<pre>
⊢ ∀n. 0 * binomial n 0 = 0
</pre>

<DT><span class="strong">beta_pos</span>
<DD>
<pre>
⊢ ∀n k. 0 < k ∧ k ≤ n ⇒ 0 < k * binomial n k
</pre>

<DT><span class="strong">beta_sym</span>
<DD>
<pre>
⊢ ∀n k. k ≤ n ⇒ k * binomial n k = (n − k + 1) * binomial n (n − k + 1)
</pre>

<DT><span class="strong">big_lcm_corner_transform</span>
<DD>
<pre>
⊢ ∀n. big_lcm (leibniz_col (n + 1)) = big_lcm (leibniz_row n (n + 1))
</pre>

<DT><span class="strong">big_lcm_count_lower_bound</span>
<DD>
<pre>
⊢ ∀f n.
    (∀x. x ∈ count (n + 1) ⇒ 0 < f x) ⇒
    SUM (GENLIST f (n + 1)) ≤ (n + 1) * big_lcm (IMAGE f (count (n + 1)))
</pre>

<DT><span class="strong">big_lcm_eq_list_lcm</span>
<DD>
<pre>
⊢ ∀l. big_lcm (LIST_TO_SET l) = list_lcm l
</pre>

<DT><span class="strong">big_lcm_ge_max</span>
<DD>
<pre>
⊢ ∀s. FINITE s ∧ (∀x. x ∈ s ⇒ 0 < x) ⇒ MAX_SET s ≤ big_lcm s
</pre>

<DT><span class="strong">big_lcm_lower_bound</span>
<DD>
<pre>
⊢ ∀n. 2 ** n ≤ big_lcm (natural (n + 1))
</pre>

<DT><span class="strong">big_lcm_natural_eqn</span>
<DD>
<pre>
⊢ ∀n. big_lcm (natural (n + 1)) =
      (n + 1) * big_lcm (IMAGE (binomial n) (count (n + 1)))
</pre>

<DT><span class="strong">big_lcm_non_decreasing</span>
<DD>
<pre>
⊢ ∀n. big_lcm (natural n) ≤ big_lcm (natural (n + 1))
</pre>

<DT><span class="strong">big_lcm_row_transform</span>
<DD>
<pre>
⊢ ∀n h.
    lcm (leibniz (n + 1) 0) (big_lcm (leibniz_row n h)) =
    big_lcm (leibniz_row (n + 1) (h + 1))
</pre>

<DT><span class="strong">big_lcm_seg_transform</span>
<DD>
<pre>
⊢ ∀n k h.
    lcm (leibniz (n + 1) k) (big_lcm (leibniz_seg n k h)) =
    big_lcm (leibniz_seg (n + 1) k (h + 1))
</pre>

<DT><span class="strong">bij_eq_card</span>
<DD>
<pre>
⊢ ∀s t. s =b= t ∧ (FINITE s ∨ FINITE t) ⇒ CARD s = CARD t
</pre>

<DT><span class="strong">bij_eq_card_eq</span>
<DD>
<pre>
⊢ ∀s t. FINITE s ∧ FINITE t ⇒ (s =b= t ⇔ CARD s = CARD t)
</pre>

<DT><span class="strong">bij_eq_count</span>
<DD>
<pre>
⊢ ∀s. FINITE s ⇒ s =b= count (CARD s)
</pre>

<DT><span class="strong">bij_eq_empty</span>
<DD>
<pre>
⊢ ∀s t. s =b= t ⇒ (s = ∅ ⇔ t = ∅)
</pre>

<DT><span class="strong">bij_eq_equiv_on</span>
<DD>
<pre>
⊢ ∀P. (λs t. s =b= t) equiv_on P
</pre>

<DT><span class="strong">bij_eq_finite</span>
<DD>
<pre>
⊢ ∀s t. s =b= t ⇒ (FINITE s ⇔ FINITE t)
</pre>

<DT><span class="strong">bij_eq_refl</span>
<DD>
<pre>
⊢ ∀s. s =b= s
</pre>

<DT><span class="strong">bij_eq_sym</span>
<DD>
<pre>
⊢ ∀s t. s =b= t ⇔ t =b= s
</pre>

<DT><span class="strong">bij_eq_trans</span>
<DD>
<pre>
⊢ ∀s t u. s =b= t ∧ t =b= u ⇒ s =b= u
</pre>

<DT><span class="strong">bij_iff_preimage_card_eq_1</span>
<DD>
<pre>
⊢ ∀f s t.
    FINITE s ∧ (∀x. x ∈ s ⇒ f x ∈ t) ⇒
    (BIJ f s t ⇔ ∀y. y ∈ t ⇒ CARD (preimage f s y) = 1)
</pre>

<DT><span class="strong">bij_preimage_sing</span>
<DD>
<pre>
⊢ ∀f s t.
    BIJ f s t ⇔ (∀x. x ∈ s ⇒ f x ∈ t) ∧ ∀y. y ∈ t ⇒ SING (preimage f s y)
</pre>

<DT><span class="strong">binomial_0_n</span>
<DD>
<pre>
⊢ ∀n. binomial 0 n = if n = 0 then 1 else 0
</pre>

<DT><span class="strong">binomial_1_n</span>
<DD>
<pre>
⊢ ∀n. binomial 1 n = if 1 < n then 0 else 1
</pre>

<DT><span class="strong">binomial_alt</span>
<DD>
<pre>
⊢ ∀n k.
    binomial n 0 = 1 ∧ binomial 0 (k + 1) = 0 ∧
    binomial (n + 1) (k + 1) = binomial n k + binomial n (k + 1)
</pre>

<DT><span class="strong">binomial_compute</span>
<DD>
<pre>
⊢ binomial 0 0 = 1 ∧ (∀n. binomial <..num comp'n..> 0 = 1) ∧
  (∀n. binomial <..num comp'n..> 0 = 1) ∧
  (∀k. binomial 0 <..num comp'n..> = 0) ∧
  (∀k. binomial 0 <..num comp'n..> = 0) ∧
  (∀n k.
     binomial <..num comp'n..> <..num comp'n..> =
     binomial (<..num comp'n..> − 1) (<..num comp'n..> − 1) +
     binomial (<..num comp'n..> − 1) <..num comp'n..> ) ∧
  (∀n k.
     binomial <..num comp'n..> <..num comp'n..> =
     binomial <..num comp'n..> (<..num comp'n..> − 1) +
     binomial <..num comp'n..> <..num comp'n..> ) ∧
  (∀n k.
     binomial <..num comp'n..> <..num comp'n..> =
     binomial (<..num comp'n..> − 1) <..num comp'n..> +
     binomial (<..num comp'n..> − 1) <..num comp'n..> ) ∧
  ∀n k.
    binomial <..num comp'n..> <..num comp'n..> =
    binomial <..num comp'n..> <..num comp'n..> +
    binomial <..num comp'n..> <..num comp'n..>
</pre>

<DT><span class="strong">binomial_def</span>
<DD>
<pre>
⊢ binomial 0 0 = 1 ∧ (∀n. binomial (SUC n) 0 = 1) ∧
  (∀k. binomial 0 (SUC k) = 0) ∧
  ∀n k. binomial (SUC n) (SUC k) = binomial n k + binomial n (SUC k)
</pre>

<DT><span class="strong">binomial_eq_0</span>
<DD>
<pre>
⊢ ∀n k. binomial n k = 0 ⇔ n < k
</pre>

<DT><span class="strong">binomial_fact</span>
<DD>
<pre>
⊢ ∀n k. k ≤ n ⇒ binomial n k = FACT n DIV (FACT k * FACT (n − k))
</pre>

<DT><span class="strong">binomial_formula</span>
<DD>
<pre>
⊢ ∀n k. binomial (n + k) k * (FACT n * FACT k) = FACT (n + k)
</pre>

<DT><span class="strong">binomial_formula2</span>
<DD>
<pre>
⊢ ∀n k. k ≤ n ⇒ FACT n = binomial n k * (FACT (n − k) * FACT k)
</pre>

<DT><span class="strong">binomial_formula3</span>
<DD>
<pre>
⊢ ∀n k. k ≤ n ⇒ binomial n k = FACT n DIV (FACT k * FACT (n − k))
</pre>

<DT><span class="strong">binomial_horizontal_0</span>
<DD>
<pre>
⊢ binomial_horizontal 0 = [1]
</pre>

<DT><span class="strong">binomial_horizontal_element</span>
<DD>
<pre>
⊢ ∀n k. k ≤ n ⇒ EL k (binomial_horizontal n) = binomial n k
</pre>

<DT><span class="strong">binomial_horizontal_len</span>
<DD>
<pre>
⊢ ∀n. LENGTH (binomial_horizontal n) = n + 1
</pre>

<DT><span class="strong">binomial_horizontal_max</span>
<DD>
<pre>
⊢ ∀n. MAX_LIST (binomial_horizontal n) = binomial n (n DIV 2)
</pre>

<DT><span class="strong">binomial_horizontal_mem</span>
<DD>
<pre>
⊢ ∀n k. k < n + 1 ⇒ MEM (binomial n k) (binomial_horizontal n)
</pre>

<DT><span class="strong">binomial_horizontal_mem_iff</span>
<DD>
<pre>
⊢ ∀n k. MEM (binomial n k) (binomial_horizontal n) ⇔ k ≤ n
</pre>

<DT><span class="strong">binomial_horizontal_member</span>
<DD>
<pre>
⊢ ∀n x. MEM x (binomial_horizontal n) ⇔ ∃k. k ≤ n ∧ x = binomial n k
</pre>

<DT><span class="strong">binomial_horizontal_pos</span>
<DD>
<pre>
⊢ ∀n. EVERY_POSITIVE (binomial_horizontal n)
</pre>

<DT><span class="strong">binomial_horizontal_pos_alt</span>
<DD>
<pre>
⊢ ∀n x. MEM x (binomial_horizontal n) ⇒ 0 < x
</pre>

<DT><span class="strong">binomial_horizontal_sum</span>
<DD>
<pre>
⊢ ∀n. SUM (binomial_horizontal n) = 2 ** n
</pre>

<DT><span class="strong">binomial_iff</span>
<DD>
<pre>
⊢ ∀f. f = binomial ⇔
      ∀n k.
        f n 0 = 1 ∧ f 0 (k + 1) = 0 ∧ f (n + 1) (k + 1) = f n k + f n (k + 1)
</pre>

<DT><span class="strong">binomial_ind</span>
<DD>
<pre>
⊢ ∀P. P 0 0 ∧ (∀n. P (SUC n) 0) ∧ (∀k. P 0 (SUC k)) ∧
      (∀n k. P n k ∧ P n (SUC k) ⇒ P (SUC n) (SUC k)) ⇒
      ∀v v1. P v v1
</pre>

<DT><span class="strong">binomial_index_shift</span>
<DD>
<pre>
⊢ ∀n x y.
    (λk. binomial (SUC n) k * x ** (SUC n − k) * y ** k) ∘ SUC =
    (λk. binomial (SUC n) (SUC k) * x ** (n − k) * y ** SUC k)
</pre>

<DT><span class="strong">binomial_is_integer</span>
<DD>
<pre>
⊢ ∀n k. k ≤ n ⇒ FACT k * FACT (n − k) divides FACT n
</pre>

<DT><span class="strong">binomial_less_0</span>
<DD>
<pre>
⊢ ∀n k. n < k ⇒ binomial n k = 0
</pre>

<DT><span class="strong">binomial_max</span>
<DD>
<pre>
⊢ ∀n k. binomial n k ≤ binomial n (n DIV 2)
</pre>

<DT><span class="strong">binomial_middle_by_stirling</span>
<DD>
<pre>
⊢ Stirling ⇒
  ∀n. 0 < n ∧ EVEN n ⇒
      binomial n (n DIV 2) = 2 ** (n + 1) DIV SQRT (2 * pi * n)
</pre>

<DT><span class="strong">binomial_middle_upper_bound</span>
<DD>
<pre>
⊢ ∀n. binomial n (n DIV 2) ≤ 4 ** (n DIV 2)
</pre>

<DT><span class="strong">binomial_mod_zero</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒
      ∀k. binomial n k MOD n = 0 ⇔
          ∀x y. (binomial n k * x ** (n − k) * y ** k) MOD n = 0
</pre>

<DT><span class="strong">binomial_mod_zero_alt</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒
      ((∀k. 0 < k ∧ k < n ⇒ binomial n k MOD n = 0) ⇔
       ∀x y.
         SUM
           (GENLIST ((λk. (binomial n k * x ** (n − k) * y ** k) MOD n) ∘ SUC)
              (PRE n)) = 0)
</pre>

<DT><span class="strong">binomial_monotone</span>
<DD>
<pre>
⊢ ∀n k. k < n DIV 2 ⇒ binomial n k < binomial n (k + 1)
</pre>

<DT><span class="strong">binomial_n_0</span>
<DD>
<pre>
⊢ ∀n. binomial n 0 = 1
</pre>

<DT><span class="strong">binomial_n_1</span>
<DD>
<pre>
⊢ ∀n. binomial n 1 = n
</pre>

<DT><span class="strong">binomial_n_k</span>
<DD>
<pre>
⊢ ∀n k. k ≤ n ⇒ binomial n k = FACT n DIV FACT k DIV FACT (n − k)
</pre>

<DT><span class="strong">binomial_n_n</span>
<DD>
<pre>
⊢ ∀n. binomial n n = 1
</pre>

<DT><span class="strong">binomial_pos</span>
<DD>
<pre>
⊢ ∀n k. k ≤ n ⇒ 0 < binomial n k
</pre>

<DT><span class="strong">binomial_product_identity</span>
<DD>
<pre>
⊢ ∀m n k.
    k ≤ m ∧ m ≤ n ⇒
    binomial m k * binomial n m = binomial n k * binomial (n − k) (m − k)
</pre>

<DT><span class="strong">binomial_range_shift</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒
      ((∀k. 0 < k ∧ k < n ⇒ binomial n k MOD n = 0) ⇔
       ∀h. h < PRE n ⇒ binomial n (SUC h) MOD n = 0)
</pre>

<DT><span class="strong">binomial_range_shift_alt</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒
      ((∀k. 0 < k ∧ k < n ⇒
            ∀x y. (binomial n k * x ** (n − k) * y ** k) MOD n = 0) ⇔
       ∀h. h < PRE n ⇒
           ∀x y.
             (binomial n (SUC h) * x ** (n − SUC h) * y ** SUC h) MOD n = 0)
</pre>

<DT><span class="strong">binomial_recurrence</span>
<DD>
<pre>
⊢ ∀n k. binomial (SUC n) (SUC k) = binomial n k + binomial n (SUC k)
</pre>

<DT><span class="strong">binomial_right</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ ∀k. binomial n (k + 1) = (n − k) * binomial n k DIV (k + 1)
</pre>

<DT><span class="strong">binomial_right_eqn</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ ∀k. (k + 1) * binomial n (k + 1) = (n − k) * binomial n k
</pre>

<DT><span class="strong">binomial_row_max</span>
<DD>
<pre>
⊢ ∀n. MAX_SET (IMAGE (binomial n) (count (n + 1))) = binomial n (n DIV 2)
</pre>

<DT><span class="strong">binomial_sum</span>
<DD>
<pre>
⊢ ∀n. SUM (GENLIST (binomial n) (SUC n)) = 2 ** n
</pre>

<DT><span class="strong">binomial_sum_alt</span>
<DD>
<pre>
⊢ ∀n. SUM (binomial_horizontal n) = 2 ** n
</pre>

<DT><span class="strong">binomial_sym</span>
<DD>
<pre>
⊢ ∀n k. k ≤ n ⇒ binomial n k = binomial n (n − k)
</pre>

<DT><span class="strong">binomial_term_merge_x</span>
<DD>
<pre>
⊢ ∀n x y.
    (λk. x * k) ∘ (λk. binomial n k * x ** (n − k) * y ** k) =
    (λk. binomial n k * x ** SUC (n − k) * y ** k)
</pre>

<DT><span class="strong">binomial_term_merge_y</span>
<DD>
<pre>
⊢ ∀n x y.
    (λk. y * k) ∘ (λk. binomial n k * x ** (n − k) * y ** k) =
    (λk. binomial n k * x ** (n − k) * y ** SUC k)
</pre>

<DT><span class="strong">binomial_thm</span>
<DD>
<pre>
⊢ ∀n x y.
    (x + y) ** n =
    SUM (GENLIST (λk. binomial n k * x ** (n − k) * y ** k) (SUC n))
</pre>

<DT><span class="strong">binomial_thm_alt</span>
<DD>
<pre>
⊢ ∀n x y.
    (x + y) ** n =
    SUM (GENLIST (λk. binomial n k * x ** (n − k) * y ** k) (n + 1))
</pre>

<DT><span class="strong">binomial_thm_prime</span>
<DD>
<pre>
⊢ ∀p. prime p ⇒ ∀x y. (x + y) ** p MOD p = (x ** p + y ** p) MOD p
</pre>

<DT><span class="strong">binomial_up</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ ∀k. binomial (n − 1) k = (n − k) * binomial n k DIV n
</pre>

<DT><span class="strong">binomial_up_eqn</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ ∀k. n * binomial (n − 1) k = (n − k) * binomial n k
</pre>

<DT><span class="strong">choose_0_n</span>
<DD>
<pre>
⊢ ∀n. 0 choose n = if n = 0 then 1 else 0
</pre>

<DT><span class="strong">choose_1_n</span>
<DD>
<pre>
⊢ ∀n. 1 choose n = if 1 < n then 0 else 1
</pre>

<DT><span class="strong">choose_alt</span>
<DD>
<pre>
⊢ ∀n k.
    n choose 0 = 1 ∧ 0 choose (k + 1) = 0 ∧
    (n + 1) choose (k + 1) = n choose k + n choose (k + 1)
</pre>

<DT><span class="strong">choose_eq_0</span>
<DD>
<pre>
⊢ ∀n k. n choose k = 0 ⇔ n < k
</pre>

<DT><span class="strong">choose_eqn</span>
<DD>
<pre>
⊢ ∀n k. n choose k = binomial n k
</pre>

<DT><span class="strong">choose_n_0</span>
<DD>
<pre>
⊢ ∀n. n choose 0 = 1
</pre>

<DT><span class="strong">choose_n_1</span>
<DD>
<pre>
⊢ ∀n. n choose 1 = n
</pre>

<DT><span class="strong">choose_n_n</span>
<DD>
<pre>
⊢ ∀n. n choose n = 1
</pre>

<DT><span class="strong">choose_recurrence</span>
<DD>
<pre>
⊢ ∀n k. (n + 1) choose (k + 1) = n choose k + n choose (k + 1)
</pre>

<DT><span class="strong">choose_sum_over_all</span>
<DD>
<pre>
⊢ ∀n. SUM (MAP ($choose n) [0 .. n]) = 2 ** n
</pre>

<DT><span class="strong">choose_sum_over_count</span>
<DD>
<pre>
⊢ ∀n. ∑ ($choose n) (upto n) = 2 ** n
</pre>

<DT><span class="strong">count_power_partition</span>
<DD>
<pre>
⊢ ∀n. partition (λs t. s =b= t) (POW (count n)) = IMAGE (sub_count n) (upto n)
</pre>

<DT><span class="strong">datatype_triple</span>
<DD>
<pre>
⊢ DATATYPE (record triple a b c)
</pre>

<DT><span class="strong">divides_binomials_imp_prime</span>
<DD>
<pre>
⊢ ∀n. 1 < n ∧ (∀k. 0 < k ∧ k < n ⇒ n divides binomial n k) ⇒ prime n
</pre>

<DT><span class="strong">feq_set_equiv</span>
<DD>
<pre>
⊢ ∀s. feq LIST_TO_SET equiv_on s
</pre>

<DT><span class="strong">finite_surj_inj_iff</span>
<DD>
<pre>
⊢ ∀f s t.
    FINITE s ∧ SURJ f s t ⇒
    (INJ f s t ⇔ ∀e. e ∈ IMAGE (preimage f s) t ⇒ CARD e = 1)
</pre>

<DT><span class="strong">gcd_prime_product_property</span>
<DD>
<pre>
⊢ ∀p m n. prime p ∧ m divides n ∧ ¬(p * m divides n) ⇒ gcd (p * m) n = m
</pre>

<DT><span class="strong">geometric_sum_eqn</span>
<DD>
<pre>
⊢ ∀t n. 1 < t ⇒ SUM (MAP (λj. t ** j) [0 ..< n]) = tops t n DIV (t − 1)
</pre>

<DT><span class="strong">geometric_sum_eqn_alt</span>
<DD>
<pre>
⊢ ∀t n. 1 < t ⇒ SUM (MAP (λj. t ** j) [0 .. n]) = tops t (n + 1) DIV (t − 1)
</pre>

<DT><span class="strong">head_turn</span>
<DD>
<pre>
⊢ ∀ls. ls ≠ [] ⇒ HD (turn ls) = LAST ls
</pre>

<DT><span class="strong">head_turn_exp</span>
<DD>
<pre>
⊢ ∀ls n.
    n < LENGTH ls ⇒
    HD (turn_exp ls n) = EL (if n = 0 then 0 else (LENGTH ls − n)) ls
</pre>

<DT><span class="strong">inj_iff_preimage_card_le_1</span>
<DD>
<pre>
⊢ ∀f s t.
    FINITE s ∧ (∀x. x ∈ s ⇒ f x ∈ t) ⇒
    (INJ f s t ⇔ ∀y. y ∈ t ⇒ CARD (preimage f s y) ≤ 1)
</pre>

<DT><span class="strong">inj_preimage_empty_or_sing</span>
<DD>
<pre>
⊢ ∀f s t.
    INJ f s t ⇔
    (∀x. x ∈ s ⇒ f x ∈ t) ∧
    ∀y. y ∈ t ⇒ preimage f s y = ∅ ∨ SING (preimage f s y)
</pre>

<DT><span class="strong">interleave_alt</span>
<DD>
<pre>
⊢ ∀ls x. x interleave ls = {TAKE k ls ++ x::DROP k ls | k | k ≤ LENGTH ls}
</pre>

<DT><span class="strong">interleave_card</span>
<DD>
<pre>
⊢ ∀ls x. ¬MEM x ls ⇒ CARD (x interleave ls) = 1 + LENGTH ls
</pre>

<DT><span class="strong">interleave_count_inj</span>
<DD>
<pre>
⊢ ∀ls x.
    ¬MEM x ls ⇒
    INJ (λk. TAKE k ls ++ x::DROP k ls) (upto (LENGTH ls)) 𝕌(:α list)
</pre>

<DT><span class="strong">interleave_disjoint</span>
<DD>
<pre>
⊢ ∀l1 l2 x. ¬MEM x l1 ∧ l1 ≠ l2 ⇒ DISJOINT (x interleave l1) (x interleave l2)
</pre>

<DT><span class="strong">interleave_distinct</span>
<DD>
<pre>
⊢ ∀ls x y. ALL_DISTINCT (x::ls) ∧ y ∈ x interleave ls ⇒ ALL_DISTINCT y
</pre>

<DT><span class="strong">interleave_distinct_alt</span>
<DD>
<pre>
⊢ ∀ls x y. ALL_DISTINCT ls ∧ ¬MEM x ls ∧ y ∈ x interleave ls ⇒ ALL_DISTINCT y
</pre>

<DT><span class="strong">interleave_element</span>
<DD>
<pre>
⊢ ∀ls x y.
    y ∈ x interleave ls ⇔ ∃k. k ≤ LENGTH ls ∧ y = TAKE k ls ++ x::DROP k ls
</pre>

<DT><span class="strong">interleave_eq</span>
<DD>
<pre>
⊢ ∀n x y. ¬MEM n x ∧ ¬MEM n y ⇒ (n interleave x = n interleave y ⇔ x = y)
</pre>

<DT><span class="strong">interleave_finite</span>
<DD>
<pre>
⊢ ∀ls x. FINITE (x interleave ls)
</pre>

<DT><span class="strong">interleave_has_cons</span>
<DD>
<pre>
⊢ ∀ls x. x::ls ∈ x interleave ls
</pre>

<DT><span class="strong">interleave_length</span>
<DD>
<pre>
⊢ ∀ls x y. y ∈ x interleave ls ⇒ LENGTH y = 1 + LENGTH ls
</pre>

<DT><span class="strong">interleave_nil</span>
<DD>
<pre>
⊢ ∀x. x interleave [] = {[x]}
</pre>

<DT><span class="strong">interleave_not_empty</span>
<DD>
<pre>
⊢ ∀ls x. x interleave ls ≠ ∅
</pre>

<DT><span class="strong">interleave_revert</span>
<DD>
<pre>
⊢ ∀ls h.
    ALL_DISTINCT ls ∧ MEM h ls ⇒
    ∃t. ALL_DISTINCT t ∧ ls ∈ h interleave t ∧
        LIST_TO_SET t = LIST_TO_SET ls DELETE h
</pre>

<DT><span class="strong">interleave_revert_count</span>
<DD>
<pre>
⊢ ∀ls n.
    ALL_DISTINCT ls ∧ LIST_TO_SET ls = upto n ⇒
    ∃t. ALL_DISTINCT t ∧ ls ∈ n interleave t ∧ LIST_TO_SET t = count n
</pre>

<DT><span class="strong">interleave_set</span>
<DD>
<pre>
⊢ ∀ls x y. y ∈ x interleave ls ⇒ LIST_TO_SET y = LIST_TO_SET (x::ls)
</pre>

<DT><span class="strong">interleave_set_alt</span>
<DD>
<pre>
⊢ ∀ls x y. y ∈ x interleave ls ⇒ LIST_TO_SET y = x INSERT LIST_TO_SET ls
</pre>

<DT><span class="strong">lcm_lower_bound</span>
<DD>
<pre>
⊢ ∀n. 2 ** n ≤ lcm_run (n + 1)
</pre>

<DT><span class="strong">lcm_lower_bound_by_big_lcm</span>
<DD>
<pre>
⊢ ∀n. (n + 1) * binomial n (n DIV 2) ≤ big_lcm (natural (n + 1))
</pre>

<DT><span class="strong">lcm_lower_bound_by_big_lcm_stirling</span>
<DD>
<pre>
⊢ Stirling ∧ (∀n c. n DIV SQRT (c * (n − 1)) = SQRT (n DIV c)) ⇒
  ∀n. ODD n ⇒ SQRT (n DIV (2 * pi)) * 2 ** n ≤ big_lcm (natural n)
</pre>

<DT><span class="strong">lcm_lower_bound_by_list_lcm</span>
<DD>
<pre>
⊢ ∀n. (n + 1) * binomial n (n DIV 2) ≤ lcm_run (n + 1)
</pre>

<DT><span class="strong">lcm_lower_bound_by_list_lcm_stirling</span>
<DD>
<pre>
⊢ Stirling ∧ (∀n c. n DIV SQRT (c * (n − 1)) = SQRT (n DIV c)) ⇒
  ∀n. ODD n ⇒ SQRT (n DIV (2 * pi)) * 2 ** n ≤ lcm_run n
</pre>

<DT><span class="strong">lcm_prime_product_property</span>
<DD>
<pre>
⊢ ∀p m n. prime p ∧ m divides n ∧ ¬(p * m divides n) ⇒ lcm (p * m) n = p * n
</pre>

<DT><span class="strong">lcm_run_0</span>
<DD>
<pre>
⊢ lcm_run 0 = 1
</pre>

<DT><span class="strong">lcm_run_1</span>
<DD>
<pre>
⊢ lcm_run 1 = 1
</pre>

<DT><span class="strong">lcm_run_alt</span>
<DD>
<pre>
⊢ ∀n. lcm_run n = lcm_run (n − 1 + 1)
</pre>

<DT><span class="strong">lcm_run_beta_divisor</span>
<DD>
<pre>
⊢ ∀n k. 0 < k ∧ k ≤ n ⇒ k * binomial n k divides lcm_run n
</pre>

<DT><span class="strong">lcm_run_bound_recurrence</span>
<DD>
<pre>
⊢ ∀m n. n ≤ 2 * m ∧ m ≤ n ⇒ lcm_run n ≤ lcm_run m * binomial n m
</pre>

<DT><span class="strong">lcm_run_by_FOLDL</span>
<DD>
<pre>
⊢ ∀n. lcm_run n = FOLDL lcm 1 [1 .. n]
</pre>

<DT><span class="strong">lcm_run_by_FOLDR</span>
<DD>
<pre>
⊢ ∀n. lcm_run n = FOLDR lcm 1 [1 .. n]
</pre>

<DT><span class="strong">lcm_run_by_beta_horizontal</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ lcm_run n = list_lcm (GENLIST ((λk. k * binomial n k) ∘ SUC) n)
</pre>

<DT><span class="strong">lcm_run_divides_property</span>
<DD>
<pre>
⊢ ∀m n. n ≤ 2 * m ∧ m ≤ n ⇒ lcm_run n divides lcm_run m * binomial n m
</pre>

<DT><span class="strong">lcm_run_divides_property_alt</span>
<DD>
<pre>
⊢ ∀m n. n ≤ 2 * m ∧ m ≤ n ⇒ lcm_run n divides binomial n m * lcm_run m
</pre>

<DT><span class="strong">lcm_run_divisors</span>
<DD>
<pre>
⊢ ∀n. n + 1 divides lcm_run (n + 1) ∧ lcm_run n divides lcm_run (n + 1)
</pre>

<DT><span class="strong">lcm_run_even_lower</span>
<DD>
<pre>
⊢ ∀n. EVEN n ⇒ (n − 2) DIV 2 * (2 ** n DIV 2 DIV 2) ≤ lcm_run n
</pre>

<DT><span class="strong">lcm_run_even_lower_alt</span>
<DD>
<pre>
⊢ ∀n. EVEN n ∧ 8 ≤ n ⇒ 2 ** n ≤ lcm_run n
</pre>

<DT><span class="strong">lcm_run_leibniz_divisor</span>
<DD>
<pre>
⊢ ∀n k. k ≤ n ⇒ leibniz n k divides lcm_run (n + 1)
</pre>

<DT><span class="strong">lcm_run_lower</span>
<DD>
<pre>
⊢ ∀n. 2 ** n ≤ lcm_run (n + 1)
</pre>

<DT><span class="strong">lcm_run_lower_better</span>
<DD>
<pre>
⊢ ∀n. 7 ≤ n ⇒ 2 ** n ≤ lcm_run n
</pre>

<DT><span class="strong">lcm_run_lower_better_iff</span>
<DD>
<pre>
⊢ ∀n. 2 ** n ≤ lcm_run n ⇔ n = 0 ∨ n = 5 ∨ 7 ≤ n
</pre>

<DT><span class="strong">lcm_run_lower_even</span>
<DD>
<pre>
⊢ ∀n. n * 4 ** n ≤ lcm_run (2 * (n + 1))
</pre>

<DT><span class="strong">lcm_run_lower_even_iff</span>
<DD>
<pre>
⊢ ∀n. EVEN n ⇒ (2 ** n ≤ lcm_run n ⇔ n = 0 ∨ 8 ≤ n)
</pre>

<DT><span class="strong">lcm_run_lower_good</span>
<DD>
<pre>
⊢ ∀n. 2 ** (n − 1) ≤ lcm_run n
</pre>

<DT><span class="strong">lcm_run_lower_odd</span>
<DD>
<pre>
⊢ ∀n. n * 4 ** n ≤ lcm_run (2 * n + 1)
</pre>

<DT><span class="strong">lcm_run_lower_odd_iff</span>
<DD>
<pre>
⊢ ∀n. ODD n ⇒ (2 ** n ≤ lcm_run n ⇔ 5 ≤ n)
</pre>

<DT><span class="strong">lcm_run_lower_simple</span>
<DD>
<pre>
⊢ ∀n. (n + 1) DIV 2 ≤ lcm_run n
</pre>

<DT><span class="strong">lcm_run_monotone</span>
<DD>
<pre>
⊢ ∀n. lcm_run n ≤ lcm_run (n + 1)
</pre>

<DT><span class="strong">lcm_run_odd_factor</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ n * leibniz (2 * n) n divides lcm_run (2 * n + 1)
</pre>

<DT><span class="strong">lcm_run_odd_lower</span>
<DD>
<pre>
⊢ ∀n. ODD n ⇒ n DIV 2 * (2 ** n DIV 2) ≤ lcm_run n
</pre>

<DT><span class="strong">lcm_run_odd_lower_alt</span>
<DD>
<pre>
⊢ ∀n. ODD n ∧ 5 ≤ n ⇒ 2 ** n ≤ lcm_run n
</pre>

<DT><span class="strong">lcm_run_pos</span>
<DD>
<pre>
⊢ ∀n. 0 < lcm_run n
</pre>

<DT><span class="strong">lcm_run_small</span>
<DD>
<pre>
⊢ lcm_run 2 = 2 ∧ lcm_run 3 = 6 ∧ lcm_run 4 = 12 ∧ lcm_run 5 = 60 ∧
  lcm_run 6 = 60 ∧ lcm_run 7 = 420 ∧ lcm_run 8 = 840 ∧ lcm_run 9 = 2520
</pre>

<DT><span class="strong">lcm_run_suc</span>
<DD>
<pre>
⊢ ∀n. lcm_run (n + 1) = lcm (n + 1) (lcm_run n)
</pre>

<DT><span class="strong">lcm_run_upper_bound</span>
<DD>
<pre>
⊢ ∀n. lcm_run n ≤ 4 ** n
</pre>

<DT><span class="strong">lcm_upto_0</span>
<DD>
<pre>
⊢ lcm_upto 0 = 1
</pre>

<DT><span class="strong">lcm_upto_1</span>
<DD>
<pre>
⊢ lcm_upto 1 = 1
</pre>

<DT><span class="strong">lcm_upto_SUC</span>
<DD>
<pre>
⊢ ∀n. lcm_upto (SUC n) = lcm (SUC n) (lcm_upto n)
</pre>

<DT><span class="strong">lcm_upto_alt</span>
<DD>
<pre>
⊢ lcm_upto 0 = 1 ∧ ∀n. lcm_upto (n + 1) = lcm (n + 1) (lcm_upto n)
</pre>

<DT><span class="strong">lcm_upto_compute</span>
<DD>
<pre>
⊢ lcm_upto 0 = 1 ∧
  (∀n. lcm_upto <..num comp'n..> =
       lcm <..num comp'n..> (lcm_upto (<..num comp'n..> − 1))) ∧
  ∀n. lcm_upto <..num comp'n..> =
      lcm <..num comp'n..> (lcm_upto <..num comp'n..> )
</pre>

<DT><span class="strong">lcm_upto_divisors</span>
<DD>
<pre>
⊢ ∀n. n + 1 divides lcm_upto (n + 1) ∧ lcm_upto n divides lcm_upto (n + 1)
</pre>

<DT><span class="strong">lcm_upto_eq_list_lcm</span>
<DD>
<pre>
⊢ ∀n. lcm_upto n = lcm_run n
</pre>

<DT><span class="strong">lcm_upto_leibniz_divisor</span>
<DD>
<pre>
⊢ ∀n k. k ≤ n ⇒ leibniz n k divides lcm_upto (n + 1)
</pre>

<DT><span class="strong">lcm_upto_lower</span>
<DD>
<pre>
⊢ ∀n. 2 ** n ≤ lcm_upto (n + 1)
</pre>

<DT><span class="strong">lcm_upto_lower_better</span>
<DD>
<pre>
⊢ ∀n. 7 ≤ n ⇒ 2 ** n ≤ lcm_upto n
</pre>

<DT><span class="strong">lcm_upto_lower_even</span>
<DD>
<pre>
⊢ ∀n. n * 4 ** n ≤ lcm_upto (2 * (n + 1))
</pre>

<DT><span class="strong">lcm_upto_lower_odd</span>
<DD>
<pre>
⊢ ∀n. n * 4 ** n ≤ lcm_upto (2 * n + 1)
</pre>

<DT><span class="strong">lcm_upto_monotone</span>
<DD>
<pre>
⊢ ∀n. lcm_upto n ≤ lcm_upto (n + 1)
</pre>

<DT><span class="strong">lcm_upto_pos</span>
<DD>
<pre>
⊢ ∀n. 0 < lcm_upto (n + 1)
</pre>

<DT><span class="strong">lcm_upto_small</span>
<DD>
<pre>
⊢ lcm_upto 2 = 2 ∧ lcm_upto 3 = 6 ∧ lcm_upto 4 = 12 ∧ lcm_upto 5 = 60 ∧
  lcm_upto 6 = 60 ∧ lcm_upto 7 = 420 ∧ lcm_upto 8 = 840 ∧ lcm_upto 9 = 2520 ∧
  lcm_upto 10 = 2520
</pre>

<DT><span class="strong">leibniz_0_n</span>
<DD>
<pre>
⊢ ∀n. leibniz 0 n = if n = 0 then 1 else 0
</pre>

<DT><span class="strong">leibniz_alt</span>
<DD>
<pre>
⊢ ∀n. leibniz n = (λj. (n + 1) * j) ∘ binomial n
</pre>

<DT><span class="strong">leibniz_binomial_identity</span>
<DD>
<pre>
⊢ ∀m n k.
    k ≤ m ∧ m ≤ n ⇒
    leibniz n k * binomial (n − k) (m − k) =
    leibniz m k * binomial (n + 1) (m + 1)
</pre>

<DT><span class="strong">leibniz_col_arm_0</span>
<DD>
<pre>
⊢ ∀a b. leibniz_col_arm a b 0 = []
</pre>

<DT><span class="strong">leibniz_col_arm_1</span>
<DD>
<pre>
⊢ ∀a b. leibniz_col_arm a b 1 = [leibniz a b]
</pre>

<DT><span class="strong">leibniz_col_arm_cons</span>
<DD>
<pre>
⊢ ∀a b n.
    leibniz_col_arm (a + 1) b (n + 1) =
    leibniz (a + 1) b::leibniz_col_arm a b n
</pre>

<DT><span class="strong">leibniz_col_arm_el</span>
<DD>
<pre>
⊢ ∀n k. k < n ⇒ ∀a b. EL k (leibniz_col_arm a b n) = leibniz (a − k) b
</pre>

<DT><span class="strong">leibniz_col_arm_len</span>
<DD>
<pre>
⊢ ∀a b n. LENGTH (leibniz_col_arm a b n) = n
</pre>

<DT><span class="strong">leibniz_col_arm_n_0</span>
<DD>
<pre>
⊢ ∀n. leibniz_col_arm n 0 (n + 1) = leibniz_up n
</pre>

<DT><span class="strong">leibniz_col_arm_wriggle_row_arm</span>
<DD>
<pre>
⊢ ∀a b n.
    b ≤ a ∧ n ≤ a + 1 − b ⇒
    leibniz_col_arm a b n wriggle leibniz_seg_arm a b n
</pre>

<DT><span class="strong">leibniz_col_def</span>
<DD>
<pre>
⊢ ∀h. leibniz_col h = {leibniz j 0 | j ∈ count h}
</pre>

<DT><span class="strong">leibniz_col_eq_natural</span>
<DD>
<pre>
⊢ ∀n. leibniz_col n = natural n
</pre>

<DT><span class="strong">leibniz_def_alt</span>
<DD>
<pre>
⊢ ∀n k. leibniz n k = (λj. (n + 1) * j) (binomial n k)
</pre>

<DT><span class="strong">leibniz_divides_leibniz_factor</span>
<DD>
<pre>
⊢ ∀m n k.
    k ≤ m ∧ m ≤ n ⇒ leibniz n k divides leibniz m k * binomial (n + 1) (m + 1)
</pre>

<DT><span class="strong">leibniz_eq_0</span>
<DD>
<pre>
⊢ ∀n k. leibniz n k = 0 ⇔ n < k
</pre>

<DT><span class="strong">leibniz_eqn</span>
<DD>
<pre>
⊢ ∀n k. leibniz n k = (n + 1 − k) * binomial (n + 1) k
</pre>

<DT><span class="strong">leibniz_formula</span>
<DD>
<pre>
⊢ ∀n k. k ≤ n ⇒ leibniz n k = (n + 1) * FACT n DIV (FACT k * FACT (n − k))
</pre>

<DT><span class="strong">leibniz_horizontal_0</span>
<DD>
<pre>
⊢ leibniz_horizontal 0 = [1]
</pre>

<DT><span class="strong">leibniz_horizontal_alt</span>
<DD>
<pre>
⊢ ∀n. leibniz_horizontal n = MAP (λj. (n + 1) * j) (binomial_horizontal n)
</pre>

<DT><span class="strong">leibniz_horizontal_average</span>
<DD>
<pre>
⊢ ∀n. SUM (leibniz_horizontal n) DIV LENGTH (leibniz_horizontal n) =
      SUM (binomial_horizontal n)
</pre>

<DT><span class="strong">leibniz_horizontal_average_eqn</span>
<DD>
<pre>
⊢ ∀n. SUM (leibniz_horizontal n) DIV LENGTH (leibniz_horizontal n) = 2 ** n
</pre>

<DT><span class="strong">leibniz_horizontal_divisor</span>
<DD>
<pre>
⊢ ∀n k. k ≤ n ⇒ leibniz n k divides list_lcm (leibniz_horizontal n)
</pre>

<DT><span class="strong">leibniz_horizontal_el</span>
<DD>
<pre>
⊢ ∀n k. k ≤ n ⇒ EL k (leibniz_horizontal n) = leibniz n k
</pre>

<DT><span class="strong">leibniz_horizontal_element</span>
<DD>
<pre>
⊢ ∀n k. k ≤ n ⇒ EL k (leibniz_horizontal n) = leibniz n k
</pre>

<DT><span class="strong">leibniz_horizontal_head</span>
<DD>
<pre>
⊢ ∀n. TAKE 1 (leibniz_horizontal (n + 1)) = [n + 2]
</pre>

<DT><span class="strong">leibniz_horizontal_lcm_alt</span>
<DD>
<pre>
⊢ ∀n. list_lcm (leibniz_horizontal n) =
      (n + 1) * list_lcm (binomial_horizontal n)
</pre>

<DT><span class="strong">leibniz_horizontal_lcm_lower</span>
<DD>
<pre>
⊢ ∀n. 2 ** n ≤ list_lcm (leibniz_horizontal n)
</pre>

<DT><span class="strong">leibniz_horizontal_len</span>
<DD>
<pre>
⊢ ∀n. LENGTH (leibniz_horizontal n) = n + 1
</pre>

<DT><span class="strong">leibniz_horizontal_mem</span>
<DD>
<pre>
⊢ ∀n k. k ≤ n ⇒ MEM (leibniz n k) (leibniz_horizontal n)
</pre>

<DT><span class="strong">leibniz_horizontal_mem_iff</span>
<DD>
<pre>
⊢ ∀n k. MEM (leibniz n k) (leibniz_horizontal n) ⇔ k ≤ n
</pre>

<DT><span class="strong">leibniz_horizontal_member</span>
<DD>
<pre>
⊢ ∀n x. MEM x (leibniz_horizontal n) ⇔ ∃k. k ≤ n ∧ x = leibniz n k
</pre>

<DT><span class="strong">leibniz_horizontal_member_divides</span>
<DD>
<pre>
⊢ ∀m n x.
    n ≤ 2 * m + 1 ∧ m ≤ n ∧ MEM x (leibniz_horizontal n) ⇒
    x divides list_lcm (leibniz_horizontal m) * binomial (n + 1) (m + 1)
</pre>

<DT><span class="strong">leibniz_horizontal_pos</span>
<DD>
<pre>
⊢ ∀n. EVERY_POSITIVE (leibniz_horizontal n)
</pre>

<DT><span class="strong">leibniz_horizontal_pos_alt</span>
<DD>
<pre>
⊢ ∀n x. MEM x (leibniz_horizontal n) ⇒ 0 < x
</pre>

<DT><span class="strong">leibniz_horizontal_sum</span>
<DD>
<pre>
⊢ ∀n. SUM (leibniz_horizontal n) = (n + 1) * SUM (binomial_horizontal n)
</pre>

<DT><span class="strong">leibniz_horizontal_sum_eqn</span>
<DD>
<pre>
⊢ ∀n. SUM (leibniz_horizontal n) = (n + 1) * 2 ** n
</pre>

<DT><span class="strong">leibniz_horizontal_wriggle</span>
<DD>
<pre>
⊢ ∀n. [leibniz (n + 1) 0] ++ leibniz_horizontal n wriggle
      leibniz_horizontal (n + 1)
</pre>

<DT><span class="strong">leibniz_horizontal_wriggle_step</span>
<DD>
<pre>
⊢ ∀n k.
    k ≤ n + 1 ⇒
    TAKE (k + 1) (leibniz_horizontal (n + 1)) ++ DROP k (leibniz_horizontal n) wriggle
    leibniz_horizontal (n + 1)
</pre>

<DT><span class="strong">leibniz_horizontal_zigzag</span>
<DD>
<pre>
⊢ ∀n k.
    k ≤ n ⇒
    TAKE (k + 1) (leibniz_horizontal (n + 1)) ++ DROP k (leibniz_horizontal n) zigzag
    TAKE (k + 2) (leibniz_horizontal (n + 1)) ++
    DROP (k + 1) (leibniz_horizontal n)
</pre>

<DT><span class="strong">leibniz_lcm_exchange</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒
      ∀k. lcm (leibniz n k) (leibniz (n − 1) k) =
          lcm (leibniz n k) (leibniz n (k + 1))
</pre>

<DT><span class="strong">leibniz_lcm_invariance</span>
<DD>
<pre>
⊢ ∀a b n.
    b ≤ a ∧ n ≤ a + 1 − b ⇒
    list_lcm (leibniz_col_arm a b n) = list_lcm (leibniz_seg_arm a b n)
</pre>

<DT><span class="strong">leibniz_lcm_property</span>
<DD>
<pre>
⊢ ∀n. lcm_run (n + 1) = list_lcm (leibniz_horizontal n)
</pre>

<DT><span class="strong">leibniz_less_0</span>
<DD>
<pre>
⊢ ∀n k. n < k ⇒ leibniz n k = 0
</pre>

<DT><span class="strong">leibniz_middle_lower</span>
<DD>
<pre>
⊢ ∀n. 4 ** n ≤ leibniz (2 * n) n
</pre>

<DT><span class="strong">leibniz_monotone</span>
<DD>
<pre>
⊢ ∀n k. k < n DIV 2 ⇒ leibniz n k < leibniz n (k + 1)
</pre>

<DT><span class="strong">leibniz_n_0</span>
<DD>
<pre>
⊢ ∀n. leibniz n 0 = n + 1
</pre>

<DT><span class="strong">leibniz_n_k</span>
<DD>
<pre>
⊢ ∀n k.
    0 < k ∧ k ≤ n ⇒
    leibniz n k =
    leibniz n (k − 1) * leibniz (n − 1) (k − 1) DIV
    (leibniz n (k − 1) − leibniz (n − 1) (k − 1))
</pre>

<DT><span class="strong">leibniz_n_n</span>
<DD>
<pre>
⊢ ∀n. leibniz n n = n + 1
</pre>

<DT><span class="strong">leibniz_pos</span>
<DD>
<pre>
⊢ ∀n k. k ≤ n ⇒ 0 < leibniz n k
</pre>

<DT><span class="strong">leibniz_property</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒
      ∀k. leibniz n k * leibniz (n − 1) k =
          leibniz n (k + 1) * (leibniz n k − leibniz (n − 1) k)
</pre>

<DT><span class="strong">leibniz_recurrence</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒
      ∀k. k < n ⇒
          leibniz n (k + 1) =
          leibniz n k * leibniz (n − 1) k DIV
          (leibniz n k − leibniz (n − 1) k)
</pre>

<DT><span class="strong">leibniz_right</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ ∀k. leibniz n (k + 1) = (n − k) * leibniz n k DIV (k + 1)
</pre>

<DT><span class="strong">leibniz_right_alt</span>
<DD>
<pre>
⊢ ∀n k. leibniz n (k + 1) = (n − k) * binomial (n + 1) (k + 1)
</pre>

<DT><span class="strong">leibniz_right_entry</span>
<DD>
<pre>
⊢ ∀n k. (k + 1) * (triplet n k).c = (n + 1 − k) * (triplet n k).b
</pre>

<DT><span class="strong">leibniz_right_eqn</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ ∀k. (k + 1) * leibniz n (k + 1) = (n − k) * leibniz n k
</pre>

<DT><span class="strong">leibniz_row_def</span>
<DD>
<pre>
⊢ ∀n h. leibniz_row n h = {leibniz n j | j ∈ count h}
</pre>

<DT><span class="strong">leibniz_seg_arm_0</span>
<DD>
<pre>
⊢ ∀a b. leibniz_seg_arm a b 0 = []
</pre>

<DT><span class="strong">leibniz_seg_arm_1</span>
<DD>
<pre>
⊢ ∀a b. leibniz_seg_arm a b 1 = [leibniz a b]
</pre>

<DT><span class="strong">leibniz_seg_arm_el</span>
<DD>
<pre>
⊢ ∀n k. k < n ⇒ ∀a b. EL k (leibniz_seg_arm a b n) = leibniz a (b + k)
</pre>

<DT><span class="strong">leibniz_seg_arm_head</span>
<DD>
<pre>
⊢ ∀a b n. TAKE 1 (leibniz_seg_arm a b (n + 1)) = [leibniz a b]
</pre>

<DT><span class="strong">leibniz_seg_arm_len</span>
<DD>
<pre>
⊢ ∀a b n. LENGTH (leibniz_seg_arm a b n) = n
</pre>

<DT><span class="strong">leibniz_seg_arm_n_0</span>
<DD>
<pre>
⊢ ∀n. leibniz_seg_arm n 0 (n + 1) = leibniz_horizontal n
</pre>

<DT><span class="strong">leibniz_seg_arm_wriggle_row_arm</span>
<DD>
<pre>
⊢ ∀a b n.
    [leibniz (a + 1) b] ++ leibniz_seg_arm a b n wriggle
    leibniz_seg_arm (a + 1) b (n + 1)
</pre>

<DT><span class="strong">leibniz_seg_arm_wriggle_step</span>
<DD>
<pre>
⊢ ∀n k.
    k < n + 1 ⇒
    ∀a b.
      TAKE (k + 1) (leibniz_seg_arm (a + 1) b (n + 1)) ++
      DROP k (leibniz_seg_arm a b n) wriggle leibniz_seg_arm (a + 1) b (n + 1)
</pre>

<DT><span class="strong">leibniz_seg_arm_zigzag_step</span>
<DD>
<pre>
⊢ ∀n k.
    k < n ⇒
    ∀a b.
      TAKE (k + 1) (leibniz_seg_arm (a + 1) b (n + 1)) ++
      DROP k (leibniz_seg_arm a b n) zigzag
      TAKE (k + 2) (leibniz_seg_arm (a + 1) b (n + 1)) ++
      DROP (k + 1) (leibniz_seg_arm a b n)
</pre>

<DT><span class="strong">leibniz_seg_def</span>
<DD>
<pre>
⊢ ∀n k h. leibniz_seg n k h = {leibniz n (k + j) | j ∈ count h}
</pre>

<DT><span class="strong">leibniz_sym</span>
<DD>
<pre>
⊢ ∀n k. k ≤ n ⇒ leibniz n k = leibniz n (n − k)
</pre>

<DT><span class="strong">leibniz_triplet_0</span>
<DD>
<pre>
⊢ leibniz_up 1 zigzag leibniz_horizontal 1
</pre>

<DT><span class="strong">leibniz_triplet_lcm</span>
<DD>
<pre>
⊢ ∀n k.
    lcm (triplet n k).b (triplet n k).a = lcm (triplet n k).b (triplet n k).c
</pre>

<DT><span class="strong">leibniz_triplet_member</span>
<DD>
<pre>
⊢ ∀n k.
    (triplet n k).a = leibniz n k ∧ (triplet n k).b = leibniz (n + 1) k ∧
    (triplet n k).c = leibniz (n + 1) (k + 1)
</pre>

<DT><span class="strong">leibniz_triplet_property</span>
<DD>
<pre>
⊢ ∀n' k.
    (triplet n k).a * (triplet n k).b =
    (triplet n k).c * ((triplet n k).b − (triplet n k).a)
</pre>

<DT><span class="strong">leibniz_up</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ ∀k. leibniz (n − 1) k = (n − k) * leibniz n k DIV (n + 1)
</pre>

<DT><span class="strong">leibniz_up_0</span>
<DD>
<pre>
⊢ leibniz_up 0 = [1]
</pre>

<DT><span class="strong">leibniz_up_alt</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ ∀k. leibniz (n − 1) k = (n − k) * binomial n k
</pre>

<DT><span class="strong">leibniz_up_cons</span>
<DD>
<pre>
⊢ ∀n. leibniz_up (n + 1) = n + 2::leibniz_up n
</pre>

<DT><span class="strong">leibniz_up_entry</span>
<DD>
<pre>
⊢ ∀n k. (n + 2) * (triplet n k).a = (n + 1 − k) * (triplet n k).b
</pre>

<DT><span class="strong">leibniz_up_eqn</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ ∀k. (n + 1) * leibniz (n − 1) k = (n − k) * leibniz n k
</pre>

<DT><span class="strong">leibniz_up_lcm_eq_horizontal_lcm</span>
<DD>
<pre>
⊢ ∀n. list_lcm (leibniz_up n) = list_lcm (leibniz_horizontal n)
</pre>

<DT><span class="strong">leibniz_up_len</span>
<DD>
<pre>
⊢ ∀n. LENGTH (leibniz_up n) = n + 1
</pre>

<DT><span class="strong">leibniz_up_mem</span>
<DD>
<pre>
⊢ ∀n x. 0 < x ∧ x ≤ n + 1 ⇔ MEM x (leibniz_up n)
</pre>

<DT><span class="strong">leibniz_up_pos</span>
<DD>
<pre>
⊢ ∀n. EVERY_POSITIVE (leibniz_up n)
</pre>

<DT><span class="strong">leibniz_up_wriggle_horizontal</span>
<DD>
<pre>
⊢ ∀n. leibniz_up n wriggle leibniz_horizontal n
</pre>

<DT><span class="strong">leibniz_up_wriggle_horizontal_alt</span>
<DD>
<pre>
⊢ ∀n. leibniz_up n wriggle leibniz_horizontal n
</pre>

<DT><span class="strong">leibniz_vertical_0</span>
<DD>
<pre>
⊢ leibniz_vertical 0 = [1]
</pre>

<DT><span class="strong">leibniz_vertical_alt</span>
<DD>
<pre>
⊢ ∀n. leibniz_vertical n = GENLIST (λi. 1 + i) (n + 1)
</pre>

<DT><span class="strong">leibniz_vertical_divisor</span>
<DD>
<pre>
⊢ ∀n k. k ≤ n ⇒ leibniz n k divides lcm_run (n + 1)
</pre>

<DT><span class="strong">leibniz_vertical_lcm_lower</span>
<DD>
<pre>
⊢ ∀n. 2 ** n ≤ lcm_run (n + 1)
</pre>

<DT><span class="strong">leibniz_vertical_len</span>
<DD>
<pre>
⊢ ∀n. LENGTH (leibniz_vertical n) = n + 1
</pre>

<DT><span class="strong">leibniz_vertical_mem</span>
<DD>
<pre>
⊢ ∀n x. 0 < x ∧ x ≤ n + 1 ⇔ MEM x (leibniz_vertical n)
</pre>

<DT><span class="strong">leibniz_vertical_not_nil</span>
<DD>
<pre>
⊢ ∀n. leibniz_vertical n ≠ []
</pre>

<DT><span class="strong">leibniz_vertical_pos</span>
<DD>
<pre>
⊢ ∀n. EVERY_POSITIVE (leibniz_vertical n)
</pre>

<DT><span class="strong">leibniz_vertical_pos_alt</span>
<DD>
<pre>
⊢ ∀n x. MEM x (leibniz_vertical n) ⇒ 0 < x
</pre>

<DT><span class="strong">leibniz_vertical_snoc</span>
<DD>
<pre>
⊢ ∀n. leibniz_vertical (n + 1) = SNOC (n + 2) (leibniz_vertical n)
</pre>

<DT><span class="strong">leibniz_wriggle_refl</span>
<DD>
<pre>
⊢ ∀p1. p1 wriggle p1
</pre>

<DT><span class="strong">leibniz_wriggle_tail</span>
<DD>
<pre>
⊢ ∀p1 p2. p1 wriggle p2 ⇒ ∀x. [x] ++ p1 wriggle [x] ++ p2
</pre>

<DT><span class="strong">leibniz_wriggle_trans</span>
<DD>
<pre>
⊢ ∀p1 p2 p3. p1 wriggle p2 ∧ p2 wriggle p3 ⇒ p1 wriggle p3
</pre>

<DT><span class="strong">leibniz_zigzag_tail</span>
<DD>
<pre>
⊢ ∀p1 p2. p1 zigzag p2 ⇒ ∀x. [x] ++ p1 zigzag [x] ++ p2
</pre>

<DT><span class="strong">leibniz_zigzag_wriggle</span>
<DD>
<pre>
⊢ ∀p1 p2. p1 zigzag p2 ⇒ p1 wriggle p2
</pre>

<DT><span class="strong">listRangeINC_MONO_INC</span>
<DD>
<pre>
⊢ ∀m n m' n'. m' ≤ n' ∧ n' < LENGTH [m .. n] ⇒ EL m' [m .. n] ≤ EL n' [m .. n]
</pre>

<DT><span class="strong">listRangeINC_PROD</span>
<DD>
<pre>
⊢ ∀m n. 0 < m ∧ m ≤ n ⇒ PROD [m .. n] = PROD [1 .. n] DIV PROD [1 .. m − 1]
</pre>

<DT><span class="strong">listRangeINC_PROD_pos</span>
<DD>
<pre>
⊢ ∀m n. 0 < m ⇒ 0 < PROD [m .. n]
</pre>

<DT><span class="strong">listRangeLHI_MONO_INC</span>
<DD>
<pre>
⊢ ∀m n m' n'.
    m' ≤ n' ∧ n' < LENGTH [m ..< n] ⇒ EL m' [m ..< n] ≤ EL n' [m ..< n]
</pre>

<DT><span class="strong">listRangeLHI_PROD</span>
<DD>
<pre>
⊢ ∀m n. 0 < m ∧ m ≤ n ⇒ PROD [m ..< n] = PROD [1 ..< n] DIV PROD [1 ..< m]
</pre>

<DT><span class="strong">listRangeLHI_PROD_pos</span>
<DD>
<pre>
⊢ ∀m n. 0 < m ⇒ 0 < PROD [m ..< n]
</pre>

<DT><span class="strong">list_count_0_n</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ list_count 0 n = ∅
</pre>

<DT><span class="strong">list_count_alt</span>
<DD>
<pre>
⊢ ∀n k.
    list_count n k =
    {ls |
     ALL_DISTINCT ls ∧ LIST_TO_SET ls ⊆ count n ∧ CARD (LIST_TO_SET ls) = k}
</pre>

<DT><span class="strong">list_count_by_image</span>
<DD>
<pre>
⊢ ∀n k.
    0 < k ⇒
    list_count n k =
    IMAGE (λls. if ALL_DISTINCT ls then ls else []) (necklace k n) DELETE []
</pre>

<DT><span class="strong">list_count_element</span>
<DD>
<pre>
⊢ ∀ls n k.
    ls ∈ list_count n k ⇔
    ALL_DISTINCT ls ∧ LIST_TO_SET ls ⊆ count n ∧ LENGTH ls = k
</pre>

<DT><span class="strong">list_count_element_alt</span>
<DD>
<pre>
⊢ ∀ls n k.
    ls ∈ list_count n k ⇔
    ALL_DISTINCT ls ∧ LIST_TO_SET ls ⊆ count n ∧ CARD (LIST_TO_SET ls) = k
</pre>

<DT><span class="strong">list_count_element_perm_set_not_empty</span>
<DD>
<pre>
⊢ ∀ls n k. ls ∈ list_count n k ⇒ perm_set (LIST_TO_SET ls) ≠ ∅
</pre>

<DT><span class="strong">list_count_element_set_card</span>
<DD>
<pre>
⊢ ∀ls n k. ls ∈ list_count n k ⇒ CARD (LIST_TO_SET ls) = k
</pre>

<DT><span class="strong">list_count_eq_empty</span>
<DD>
<pre>
⊢ ∀n k. list_count n k = ∅ ⇔ n < k
</pre>

<DT><span class="strong">list_count_eqn</span>
<DD>
<pre>
⊢ ∀n k.
    list_count n k =
    if k = 0 then {[]}
    else
      IMAGE (λls. if ALL_DISTINCT ls then ls else []) (necklace k n) DELETE []
</pre>

<DT><span class="strong">list_count_finite</span>
<DD>
<pre>
⊢ ∀n k. FINITE (list_count n k)
</pre>

<DT><span class="strong">list_count_n_0</span>
<DD>
<pre>
⊢ ∀n. list_count n 0 = {[]}
</pre>

<DT><span class="strong">list_count_n_n</span>
<DD>
<pre>
⊢ ∀n. list_count n n = perm_count n
</pre>

<DT><span class="strong">list_count_set_eq_class</span>
<DD>
<pre>
⊢ ∀ls n k.
    ls ∈ list_count n k ⇒
    equiv_class (feq LIST_TO_SET) (list_count n k) ls =
    perm_set (LIST_TO_SET ls)
</pre>

<DT><span class="strong">list_count_set_eq_class_card</span>
<DD>
<pre>
⊢ ∀ls n k.
    ls ∈ list_count n k ⇒
    CARD (equiv_class (feq LIST_TO_SET) (list_count n k) ls) = perm k
</pre>

<DT><span class="strong">list_count_set_map_bij</span>
<DD>
<pre>
⊢ ∀n k.
    BIJ (LIST_TO_SET ∘ CHOICE) (partition (feq LIST_TO_SET) (list_count n k))
      (sub_count n k)
</pre>

<DT><span class="strong">list_count_set_map_element</span>
<DD>
<pre>
⊢ ∀s n k.
    s ∈ partition (feq LIST_TO_SET) (list_count n k) ⇒
    (LIST_TO_SET ∘ CHOICE) s ∈ sub_count n k
</pre>

<DT><span class="strong">list_count_set_map_inj</span>
<DD>
<pre>
⊢ ∀n k.
    INJ (LIST_TO_SET ∘ CHOICE) (partition (feq LIST_TO_SET) (list_count n k))
      (sub_count n k)
</pre>

<DT><span class="strong">list_count_set_map_surj</span>
<DD>
<pre>
⊢ ∀n k.
    SURJ (LIST_TO_SET ∘ CHOICE) (partition (feq LIST_TO_SET) (list_count n k))
      (sub_count n k)
</pre>

<DT><span class="strong">list_count_set_partititon_element_card</span>
<DD>
<pre>
⊢ ∀n k e. e ∈ partition (feq LIST_TO_SET) (list_count n k) ⇒ CARD e = perm k
</pre>

<DT><span class="strong">list_count_subset</span>
<DD>
<pre>
⊢ ∀n k. list_count n k ⊆ necklace k n
</pre>

<DT><span class="strong">list_lcm_absorption</span>
<DD>
<pre>
⊢ ∀x l. MEM x l ⇒ list_lcm (x::l) = list_lcm l
</pre>

<DT><span class="strong">list_lcm_append</span>
<DD>
<pre>
⊢ ∀l1 l2. list_lcm (l1 ++ l2) = lcm (list_lcm l1) (list_lcm l2)
</pre>

<DT><span class="strong">list_lcm_append_3</span>
<DD>
<pre>
⊢ ∀l1 l2 l3.
    list_lcm (l1 ++ l2 ++ l3) =
    list_lcm [list_lcm l1; list_lcm l2; list_lcm l3]
</pre>

<DT><span class="strong">list_lcm_by_FOLDL</span>
<DD>
<pre>
⊢ ∀ls. list_lcm ls = FOLDL lcm 1 ls
</pre>

<DT><span class="strong">list_lcm_by_FOLDR</span>
<DD>
<pre>
⊢ ∀ls. list_lcm ls = FOLDR lcm 1 ls
</pre>

<DT><span class="strong">list_lcm_cons</span>
<DD>
<pre>
⊢ ∀h t. list_lcm (h::t) = lcm h (list_lcm t)
</pre>

<DT><span class="strong">list_lcm_divisor_lcm_pair</span>
<DD>
<pre>
⊢ ∀l x y. MEM x l ∧ MEM y l ⇒ lcm x y divides list_lcm l
</pre>

<DT><span class="strong">list_lcm_eq_if_set_eq</span>
<DD>
<pre>
⊢ ∀l1 l2. LIST_TO_SET l1 = LIST_TO_SET l2 ⇒ list_lcm l1 = list_lcm l2
</pre>

<DT><span class="strong">list_lcm_ge_max</span>
<DD>
<pre>
⊢ ∀l. POSITIVE l ⇒ MAX_LIST l ≤ list_lcm l
</pre>

<DT><span class="strong">list_lcm_is_common_multiple</span>
<DD>
<pre>
⊢ ∀x l. MEM x l ⇒ x divides list_lcm l
</pre>

<DT><span class="strong">list_lcm_is_least_common_multiple</span>
<DD>
<pre>
⊢ ∀l m. (∀x. MEM x l ⇒ x divides m) ⇒ list_lcm l divides m
</pre>

<DT><span class="strong">list_lcm_lower_bound</span>
<DD>
<pre>
⊢ ∀l. EVERY_POSITIVE l ⇒ SUM l ≤ LENGTH l * list_lcm l
</pre>

<DT><span class="strong">list_lcm_lower_bound_alt</span>
<DD>
<pre>
⊢ ∀l. POSITIVE l ⇒ SUM l ≤ LENGTH l * list_lcm l
</pre>

<DT><span class="strong">list_lcm_lower_by_lcm_pair</span>
<DD>
<pre>
⊢ ∀l x y. POSITIVE l ∧ MEM x l ∧ MEM y l ⇒ lcm x y ≤ list_lcm l
</pre>

<DT><span class="strong">list_lcm_map_times</span>
<DD>
<pre>
⊢ ∀n l. list_lcm (MAP (λk. n * k) l) = if l = [] then 1 else n * list_lcm l
</pre>

<DT><span class="strong">list_lcm_nil</span>
<DD>
<pre>
⊢ list_lcm [] = 1
</pre>

<DT><span class="strong">list_lcm_nonempty_lower</span>
<DD>
<pre>
⊢ ∀l. l ≠ [] ∧ EVERY_POSITIVE l ⇒ SUM l DIV LENGTH l ≤ list_lcm l
</pre>

<DT><span class="strong">list_lcm_nonempty_lower_alt</span>
<DD>
<pre>
⊢ ∀l. l ≠ [] ∧ POSITIVE l ⇒ SUM l DIV LENGTH l ≤ list_lcm l
</pre>

<DT><span class="strong">list_lcm_nub</span>
<DD>
<pre>
⊢ ∀l. list_lcm (nub l) = list_lcm l
</pre>

<DT><span class="strong">list_lcm_nub_eq_if_set_eq</span>
<DD>
<pre>
⊢ ∀l1 l2.
    LIST_TO_SET l1 = LIST_TO_SET l2 ⇒ list_lcm (nub l1) = list_lcm (nub l2)
</pre>

<DT><span class="strong">list_lcm_pos</span>
<DD>
<pre>
⊢ ∀l. EVERY_POSITIVE l ⇒ 0 < list_lcm l
</pre>

<DT><span class="strong">list_lcm_pos_alt</span>
<DD>
<pre>
⊢ ∀l. POSITIVE l ⇒ 0 < list_lcm l
</pre>

<DT><span class="strong">list_lcm_prime_factor</span>
<DD>
<pre>
⊢ ∀p l. prime p ∧ p divides list_lcm l ⇒ p divides PROD_SET (LIST_TO_SET l)
</pre>

<DT><span class="strong">list_lcm_prime_factor_member</span>
<DD>
<pre>
⊢ ∀p l. prime p ∧ p divides list_lcm l ⇒ ∃x. MEM x l ∧ p divides x
</pre>

<DT><span class="strong">list_lcm_reverse</span>
<DD>
<pre>
⊢ ∀l. list_lcm (REVERSE l) = list_lcm l
</pre>

<DT><span class="strong">list_lcm_sing</span>
<DD>
<pre>
⊢ ∀x. list_lcm [x] = x
</pre>

<DT><span class="strong">list_lcm_snoc</span>
<DD>
<pre>
⊢ ∀x l. list_lcm (SNOC x l) = lcm x (list_lcm l)
</pre>

<DT><span class="strong">list_lcm_suc</span>
<DD>
<pre>
⊢ ∀n. lcm_run (n + 1) = lcm (n + 1) (lcm_run n)
</pre>

<DT><span class="strong">list_lcm_upper_by_common_multiple</span>
<DD>
<pre>
⊢ ∀l m. 0 < m ∧ (∀x. MEM x l ⇒ x divides m) ⇒ list_lcm l ≤ m
</pre>

<DT><span class="strong">list_lcm_wriggle</span>
<DD>
<pre>
⊢ ∀p1 p2. p1 wriggle p2 ⇒ list_lcm p1 = list_lcm p2
</pre>

<DT><span class="strong">list_lcm_zigzag</span>
<DD>
<pre>
⊢ ∀p1 p2. p1 zigzag p2 ⇒ list_lcm p1 = list_lcm p2
</pre>

<DT><span class="strong">list_length_eq_sum</span>
<DD>
<pre>
⊢ ∀ls. EVERY_POSITIVE ls ∧ LENGTH ls = SUM ls ⇒ EVERY (λx. x = 1) ls
</pre>

<DT><span class="strong">list_length_le_sum</span>
<DD>
<pre>
⊢ ∀ls. EVERY_POSITIVE ls ⇒ LENGTH ls ≤ SUM ls
</pre>

<DT><span class="strong">list_product_prime_factor</span>
<DD>
<pre>
⊢ ∀p l.
    prime p ∧ p divides PROD_SET (LIST_TO_SET l) ⇒ ∃x. MEM x l ∧ p divides x
</pre>

<DT><span class="strong">monocoloured_0</span>
<DD>
<pre>
⊢ ∀a. monocoloured 0 a = {[]}
</pre>

<DT><span class="strong">monocoloured_0_card</span>
<DD>
<pre>
⊢ ∀a. CARD (monocoloured 0 a) = 1
</pre>

<DT><span class="strong">monocoloured_1</span>
<DD>
<pre>
⊢ ∀a. monocoloured 1 a = necklace 1 a
</pre>

<DT><span class="strong">monocoloured_card</span>
<DD>
<pre>
⊢ ∀n a. 0 < n ⇒ CARD (monocoloured n a) = a
</pre>

<DT><span class="strong">monocoloured_card_eqn</span>
<DD>
<pre>
⊢ ∀n a. CARD (monocoloured n a) = if n = 0 then 1 else a
</pre>

<DT><span class="strong">monocoloured_element</span>
<DD>
<pre>
⊢ ∀n a ls.
    ls ∈ monocoloured n a ⇔
    ls ∈ necklace n a ∧ (ls ≠ [] ⇒ SING (LIST_TO_SET ls))
</pre>

<DT><span class="strong">monocoloured_empty</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ monocoloured n 0 = ∅
</pre>

<DT><span class="strong">monocoloured_eqn</span>
<DD>
<pre>
⊢ ∀n a.
    monocoloured n a =
    if n = 0 then {[]} else IMAGE (λc. GENLIST (K c) n) (count a)
</pre>

<DT><span class="strong">monocoloured_finite</span>
<DD>
<pre>
⊢ ∀n a. FINITE (monocoloured n a)
</pre>

<DT><span class="strong">monocoloured_mono</span>
<DD>
<pre>
⊢ ∀n. monocoloured n 1 = necklace n 1
</pre>

<DT><span class="strong">monocoloured_necklace</span>
<DD>
<pre>
⊢ ∀n a ls. ls ∈ monocoloured n a ⇒ ls ∈ necklace n a
</pre>

<DT><span class="strong">monocoloured_subset</span>
<DD>
<pre>
⊢ ∀n a. monocoloured n a ⊆ necklace n a
</pre>

<DT><span class="strong">monocoloured_suc</span>
<DD>
<pre>
⊢ ∀n a.
    0 < n ⇒ monocoloured (SUC n) a = IMAGE (λls. HD ls::ls) (monocoloured n a)
</pre>

<DT><span class="strong">multi_mono_disjoint</span>
<DD>
<pre>
⊢ ∀n a. DISJOINT (multicoloured n a) (monocoloured n a)
</pre>

<DT><span class="strong">multi_mono_exhaust</span>
<DD>
<pre>
⊢ ∀n a. necklace n a = multicoloured n a ∪ monocoloured n a
</pre>

<DT><span class="strong">multicoloured_0</span>
<DD>
<pre>
⊢ ∀a. multicoloured 0 a = ∅
</pre>

<DT><span class="strong">multicoloured_1</span>
<DD>
<pre>
⊢ ∀a. multicoloured 1 a = ∅
</pre>

<DT><span class="strong">multicoloured_card</span>
<DD>
<pre>
⊢ ∀n a. 0 < n ⇒ CARD (multicoloured n a) = a ** n − a
</pre>

<DT><span class="strong">multicoloured_card_eqn</span>
<DD>
<pre>
⊢ ∀n a. CARD (multicoloured n a) = if n = 0 then 0 else a ** n − a
</pre>

<DT><span class="strong">multicoloured_element</span>
<DD>
<pre>
⊢ ∀n a ls.
    ls ∈ multicoloured n a ⇔
    ls ∈ necklace n a ∧ ls ≠ [] ∧ ¬SING (LIST_TO_SET ls)
</pre>

<DT><span class="strong">multicoloured_empty</span>
<DD>
<pre>
⊢ ∀n. multicoloured n 0 = ∅ ∧ multicoloured n 1 = ∅
</pre>

<DT><span class="strong">multicoloured_finite</span>
<DD>
<pre>
⊢ ∀n a. FINITE (multicoloured n a)
</pre>

<DT><span class="strong">multicoloured_n_0</span>
<DD>
<pre>
⊢ ∀n. multicoloured n 0 = ∅
</pre>

<DT><span class="strong">multicoloured_n_1</span>
<DD>
<pre>
⊢ ∀n. multicoloured n 1 = ∅
</pre>

<DT><span class="strong">multicoloured_necklace</span>
<DD>
<pre>
⊢ ∀n a ls. ls ∈ multicoloured n a ⇒ ls ∈ necklace n a
</pre>

<DT><span class="strong">multicoloured_nonempty</span>
<DD>
<pre>
⊢ ∀n a. 1 < n ∧ 1 < a ⇒ multicoloured n a ≠ ∅
</pre>

<DT><span class="strong">multicoloured_not_monocoloured</span>
<DD>
<pre>
⊢ ∀n a ls. ls ∈ multicoloured n a ⇒ ls ∉ monocoloured n a
</pre>

<DT><span class="strong">multicoloured_not_monocoloured_iff</span>
<DD>
<pre>
⊢ ∀n a ls.
    ls ∈ necklace n a ⇒ (ls ∈ multicoloured n a ⇔ ls ∉ monocoloured n a)
</pre>

<DT><span class="strong">multicoloured_or_monocoloured</span>
<DD>
<pre>
⊢ ∀n a ls. ls ∈ necklace n a ⇒ ls ∈ multicoloured n a ∨ ls ∈ monocoloured n a
</pre>

<DT><span class="strong">multicoloured_subset</span>
<DD>
<pre>
⊢ ∀n a. multicoloured n a ⊆ necklace n a
</pre>

<DT><span class="strong">necklace_0</span>
<DD>
<pre>
⊢ ∀a. necklace 0 a = {[]}
</pre>

<DT><span class="strong">necklace_1</span>
<DD>
<pre>
⊢ ∀a. necklace 1 a = {[e] | e ∈ count a}
</pre>

<DT><span class="strong">necklace_1_monocoloured</span>
<DD>
<pre>
⊢ ∀a. necklace 1 a = monocoloured 1 a
</pre>

<DT><span class="strong">necklace_card</span>
<DD>
<pre>
⊢ ∀n a. CARD (necklace n a) = a ** n
</pre>

<DT><span class="strong">necklace_colors</span>
<DD>
<pre>
⊢ ∀n a ls. ls ∈ necklace n a ⇒ LIST_TO_SET ls ⊆ count a
</pre>

<DT><span class="strong">necklace_element</span>
<DD>
<pre>
⊢ ∀n a ls. ls ∈ necklace n a ⇔ LENGTH ls = n ∧ LIST_TO_SET ls ⊆ count a
</pre>

<DT><span class="strong">necklace_empty</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ necklace n 0 = ∅
</pre>

<DT><span class="strong">necklace_eqn</span>
<DD>
<pre>
⊢ ∀n a.
    necklace n a =
    if n = 0 then {[]}
    else IMAGE (λ(c,ls). c::ls) (count a × necklace (n − 1) a)
</pre>

<DT><span class="strong">necklace_finite</span>
<DD>
<pre>
⊢ ∀n a. FINITE (necklace n a)
</pre>

<DT><span class="strong">necklace_length</span>
<DD>
<pre>
⊢ ∀n a ls. ls ∈ necklace n a ⇒ LENGTH ls = n
</pre>

<DT><span class="strong">necklace_not_nil</span>
<DD>
<pre>
⊢ ∀n a ls. 0 < n ∧ ls ∈ necklace n a ⇒ ls ≠ []
</pre>

<DT><span class="strong">necklace_property</span>
<DD>
<pre>
⊢ ∀n a ls. ls ∈ necklace n a ⇒ LENGTH ls = n ∧ LIST_TO_SET ls ⊆ count a
</pre>

<DT><span class="strong">necklace_suc</span>
<DD>
<pre>
⊢ ∀n a. necklace (SUC n) a = IMAGE (λ(c,ls). c::ls) (count a × necklace n a)
</pre>

<DT><span class="strong">nub_all_distinct</span>
<DD>
<pre>
⊢ ∀l. ALL_DISTINCT (nub l)
</pre>

<DT><span class="strong">nub_cons</span>
<DD>
<pre>
⊢ ∀x l. nub (x::l) = if MEM x l then nub l else x::nub l
</pre>

<DT><span class="strong">nub_nil</span>
<DD>
<pre>
⊢ nub [] = []
</pre>

<DT><span class="strong">nub_sing</span>
<DD>
<pre>
⊢ ∀x. nub [x] = [x]
</pre>

<DT><span class="strong">over_bij</span>
<DD>
<pre>
⊢ ∀f s t. BIJ f s t ⇒ ∀x. x ∈ s ⇒ f x ∈ t
</pre>

<DT><span class="strong">over_inj</span>
<DD>
<pre>
⊢ ∀f s t. INJ f s t ⇒ ∀x. x ∈ s ⇒ f x ∈ t
</pre>

<DT><span class="strong">over_surj</span>
<DD>
<pre>
⊢ ∀f s t. SURJ f s t ⇒ ∀x. x ∈ s ⇒ f x ∈ t
</pre>

<DT><span class="strong">pairwise_coprime_prod_set_divides</span>
<DD>
<pre>
⊢ ∀s m.
    FINITE s ∧ PAIRWISE_COPRIME s ∧ (∀x. x ∈ s ⇒ x divides m) ⇒
    PROD_SET s divides m
</pre>

<DT><span class="strong">pairwise_coprime_prod_set_eq_set_lcm</span>
<DD>
<pre>
⊢ ∀s. FINITE s ∧ PAIRWISE_COPRIME s ⇒ set_lcm s = PROD_SET s
</pre>

<DT><span class="strong">perm_0</span>
<DD>
<pre>
⊢ perm 0 = 1
</pre>

<DT><span class="strong">perm_1</span>
<DD>
<pre>
⊢ perm 1 = 1
</pre>

<DT><span class="strong">perm_alt</span>
<DD>
<pre>
⊢ perm 0 = 1 ∧ ∀n. perm (n + 1) = (n + 1) * perm n
</pre>

<DT><span class="strong">perm_count_0</span>
<DD>
<pre>
⊢ perm_count 0 = {[]}
</pre>

<DT><span class="strong">perm_count_1</span>
<DD>
<pre>
⊢ perm_count 1 = {[0]}
</pre>

<DT><span class="strong">perm_count_element</span>
<DD>
<pre>
⊢ ∀ls n. ls ∈ perm_count n ⇔ ALL_DISTINCT ls ∧ LIST_TO_SET ls = count n
</pre>

<DT><span class="strong">perm_count_element_length</span>
<DD>
<pre>
⊢ ∀ls n. ls ∈ perm_count n ⇒ LENGTH ls = n
</pre>

<DT><span class="strong">perm_count_element_no_self</span>
<DD>
<pre>
⊢ ∀ls n. ls ∈ perm_count n ⇒ ¬MEM n ls
</pre>

<DT><span class="strong">perm_count_eqn</span>
<DD>
<pre>
⊢ ∀n. perm_count n =
      if n = 0 then {[]}
      else BIGUNION (IMAGE ($interleave (n − 1)) (perm_count (n − 1)))
</pre>

<DT><span class="strong">perm_count_finite</span>
<DD>
<pre>
⊢ ∀n. FINITE (perm_count n)
</pre>

<DT><span class="strong">perm_count_interleave_card</span>
<DD>
<pre>
⊢ ∀n e. e ∈ IMAGE ($interleave n) (perm_count n) ⇒ CARD e = n + 1
</pre>

<DT><span class="strong">perm_count_interleave_disjoint</span>
<DD>
<pre>
⊢ ∀n e s t.
    s ∈ IMAGE ($interleave n) (perm_count n) ∧
    t ∈ IMAGE ($interleave n) (perm_count n) ∧ s ≠ t ⇒
    DISJOINT s t
</pre>

<DT><span class="strong">perm_count_interleave_finite</span>
<DD>
<pre>
⊢ ∀n e. e ∈ IMAGE ($interleave n) (perm_count n) ⇒ FINITE e
</pre>

<DT><span class="strong">perm_count_interleave_inj</span>
<DD>
<pre>
⊢ ∀n. INJ ($interleave n) (perm_count n) 𝕌(:num list -> bool)
</pre>

<DT><span class="strong">perm_count_subset</span>
<DD>
<pre>
⊢ ∀n. perm_count n ⊆ necklace n n
</pre>

<DT><span class="strong">perm_count_suc</span>
<DD>
<pre>
⊢ ∀n. perm_count (SUC n) = BIGUNION (IMAGE ($interleave n) (perm_count n))
</pre>

<DT><span class="strong">perm_count_suc_alt</span>
<DD>
<pre>
⊢ ∀n. perm_count (n + 1) = BIGUNION (IMAGE ($interleave n) (perm_count n))
</pre>

<DT><span class="strong">perm_eq_fact</span>
<DD>
<pre>
⊢ ∀n. perm n = FACT n
</pre>

<DT><span class="strong">perm_set_bij_eq_perm_count</span>
<DD>
<pre>
⊢ ∀s. FINITE s ⇒ perm_set s =b= perm_count (CARD s)
</pre>

<DT><span class="strong">perm_set_card</span>
<DD>
<pre>
⊢ ∀s. FINITE s ⇒ CARD (perm_set s) = perm (CARD s)
</pre>

<DT><span class="strong">perm_set_card_alt</span>
<DD>
<pre>
⊢ ∀s. FINITE s ⇒ CARD (perm_set s) = FACT (CARD s)
</pre>

<DT><span class="strong">perm_set_element</span>
<DD>
<pre>
⊢ ∀ls s. ls ∈ perm_set s ⇔ ALL_DISTINCT ls ∧ LIST_TO_SET ls = s
</pre>

<DT><span class="strong">perm_set_empty</span>
<DD>
<pre>
⊢ perm_set ∅ = {[]}
</pre>

<DT><span class="strong">perm_set_eq_empty_sing</span>
<DD>
<pre>
⊢ ∀s. perm_set s = {[]} ⇔ s = ∅
</pre>

<DT><span class="strong">perm_set_finite</span>
<DD>
<pre>
⊢ ∀s. FINITE s ⇒ FINITE (perm_set s)
</pre>

<DT><span class="strong">perm_set_has_self_list</span>
<DD>
<pre>
⊢ ∀s. FINITE s ⇒ SET_TO_LIST s ∈ perm_set s
</pre>

<DT><span class="strong">perm_set_list_not_empty</span>
<DD>
<pre>
⊢ ∀ls. perm_set (LIST_TO_SET ls) ≠ ∅
</pre>

<DT><span class="strong">perm_set_map_bij</span>
<DD>
<pre>
⊢ ∀f s n. BIJ f s (count n) ⇒ BIJ (MAP f) (perm_set s) (perm_count n)
</pre>

<DT><span class="strong">perm_set_map_element</span>
<DD>
<pre>
⊢ ∀ls f s n. ls ∈ perm_set s ∧ BIJ f s (count n) ⇒ MAP f ls ∈ perm_count n
</pre>

<DT><span class="strong">perm_set_map_inj</span>
<DD>
<pre>
⊢ ∀f s n. BIJ f s (count n) ⇒ INJ (MAP f) (perm_set s) (perm_count n)
</pre>

<DT><span class="strong">perm_set_map_surj</span>
<DD>
<pre>
⊢ ∀f s n. BIJ f s (count n) ⇒ SURJ (MAP f) (perm_set s) (perm_count n)
</pre>

<DT><span class="strong">perm_set_not_empty</span>
<DD>
<pre>
⊢ ∀s. FINITE s ⇒ perm_set s ≠ ∅
</pre>

<DT><span class="strong">perm_set_perm_count</span>
<DD>
<pre>
⊢ ∀n. perm_set (count n) = perm_count n
</pre>

<DT><span class="strong">perm_set_sing</span>
<DD>
<pre>
⊢ ∀x. perm_set {x} = {[x]}
</pre>

<DT><span class="strong">perm_suc</span>
<DD>
<pre>
⊢ ∀n. perm (SUC n) = SUC n * perm n
</pre>

<DT><span class="strong">perm_suc_alt</span>
<DD>
<pre>
⊢ ∀n. perm (n + 1) = (n + 1) * perm n
</pre>

<DT><span class="strong">power_predecessor_eqn</span>
<DD>
<pre>
⊢ ∀t n. tops t n = (t − 1) * SUM (MAP (λj. t ** j) [0 ..< n])
</pre>

<DT><span class="strong">prime_divides_binomials</span>
<DD>
<pre>
⊢ ∀n. prime n ⇒ 1 < n ∧ ∀k. 0 < k ∧ k < n ⇒ n divides binomial n k
</pre>

<DT><span class="strong">prime_divides_binomials_alt</span>
<DD>
<pre>
⊢ ∀n k. prime n ∧ 0 < k ∧ k < n ⇒ n divides binomial n k
</pre>

<DT><span class="strong">prime_divisor_property</span>
<DD>
<pre>
⊢ ∀n p.
    1 < n ∧ p < n ∧ prime p ∧ p divides n ⇒
    ¬(p divides FACT (n − 1) DIV FACT (n − p))
</pre>

<DT><span class="strong">prime_iff_divides_binomials</span>
<DD>
<pre>
⊢ ∀n. prime n ⇔ 1 < n ∧ ∀k. 0 < k ∧ k < n ⇒ n divides binomial n k
</pre>

<DT><span class="strong">prime_iff_divides_binomials_alt</span>
<DD>
<pre>
⊢ ∀n. prime n ⇔ 1 < n ∧ ∀k. 0 < k ∧ k < n ⇒ binomial n k MOD n = 0
</pre>

<DT><span class="strong">prod_1_to_n_eq_fact_n</span>
<DD>
<pre>
⊢ ∀n. PROD [1 .. n] = FACT n
</pre>

<DT><span class="strong">rotate_0</span>
<DD>
<pre>
⊢ ∀l. rotate 0 l = l
</pre>

<DT><span class="strong">rotate_add</span>
<DD>
<pre>
⊢ ∀n m l. n + m ≤ LENGTH l ⇒ rotate n (rotate m l) = rotate (n + m) l
</pre>

<DT><span class="strong">rotate_full</span>
<DD>
<pre>
⊢ ∀l. rotate (LENGTH l) l = l
</pre>

<DT><span class="strong">rotate_lcancel</span>
<DD>
<pre>
⊢ ∀k l. k < LENGTH l ⇒ rotate (LENGTH l − k) (rotate k l) = l
</pre>

<DT><span class="strong">rotate_nil</span>
<DD>
<pre>
⊢ ∀n. rotate n [] = []
</pre>

<DT><span class="strong">rotate_rcancel</span>
<DD>
<pre>
⊢ ∀k l. k < LENGTH l ⇒ rotate k (rotate (LENGTH l − k) l) = l
</pre>

<DT><span class="strong">rotate_same_length</span>
<DD>
<pre>
⊢ ∀l n. LENGTH (rotate n l) = LENGTH l
</pre>

<DT><span class="strong">rotate_same_set</span>
<DD>
<pre>
⊢ ∀l n. LIST_TO_SET (rotate n l) = LIST_TO_SET l
</pre>

<DT><span class="strong">rotate_shift_element</span>
<DD>
<pre>
⊢ ∀l n. n < LENGTH l ⇒ rotate n l = EL n l::(DROP (SUC n) l ++ TAKE n l)
</pre>

<DT><span class="strong">rotate_suc</span>
<DD>
<pre>
⊢ ∀l n. n < LENGTH l ⇒ rotate (SUC n) l = rotate 1 (rotate n l)
</pre>

<DT><span class="strong">set_lcm_empty</span>
<DD>
<pre>
⊢ set_lcm ∅ = 1
</pre>

<DT><span class="strong">set_lcm_eq_big_lcm</span>
<DD>
<pre>
⊢ ∀s. FINITE s ⇒ big_lcm s = set_lcm s
</pre>

<DT><span class="strong">set_lcm_eq_list_lcm</span>
<DD>
<pre>
⊢ ∀l. set_lcm (LIST_TO_SET l) = list_lcm l
</pre>

<DT><span class="strong">set_lcm_insert</span>
<DD>
<pre>
⊢ ∀s. FINITE s ⇒ ∀x. set_lcm (x INSERT s) = lcm x (set_lcm s)
</pre>

<DT><span class="strong">set_lcm_is_common_multiple</span>
<DD>
<pre>
⊢ ∀x s. FINITE s ∧ x ∈ s ⇒ x divides set_lcm s
</pre>

<DT><span class="strong">set_lcm_is_least_common_multiple</span>
<DD>
<pre>
⊢ ∀s m. FINITE s ∧ (∀x. x ∈ s ⇒ x divides m) ⇒ set_lcm s divides m
</pre>

<DT><span class="strong">set_lcm_nonempty</span>
<DD>
<pre>
⊢ ∀s. FINITE s ∧ s ≠ ∅ ⇒ set_lcm s = lcm (CHOICE s) (set_lcm (REST s))
</pre>

<DT><span class="strong">set_lcm_sing</span>
<DD>
<pre>
⊢ ∀x. set_lcm {x} = x
</pre>

<DT><span class="strong">sub_count_0_n</span>
<DD>
<pre>
⊢ ∀n. sub_count 0 n = if n = 0 then {∅} else ∅
</pre>

<DT><span class="strong">sub_count_alt</span>
<DD>
<pre>
⊢ ∀n k.
    sub_count n 0 = {∅} ∧ sub_count 0 (k + 1) = ∅ ∧
    sub_count (n + 1) (k + 1) =
    IMAGE (λs. n INSERT s) (sub_count n k) ∪ sub_count n (k + 1)
</pre>

<DT><span class="strong">sub_count_count_inj</span>
<DD>
<pre>
⊢ ∀n m. INJ (sub_count n) (upto n) 𝕌(:(num -> bool) -> bool)
</pre>

<DT><span class="strong">sub_count_disjoint</span>
<DD>
<pre>
⊢ ∀n k.
    DISJOINT (IMAGE (λs. n INSERT s) (sub_count n k)) (sub_count n (k + 1))
</pre>

<DT><span class="strong">sub_count_element</span>
<DD>
<pre>
⊢ ∀n k s. s ∈ sub_count n k ⇔ s ⊆ count n ∧ CARD s = k
</pre>

<DT><span class="strong">sub_count_element_finite</span>
<DD>
<pre>
⊢ ∀n k s. s ∈ sub_count n k ⇒ FINITE s
</pre>

<DT><span class="strong">sub_count_element_no_self</span>
<DD>
<pre>
⊢ ∀n k s. s ∈ sub_count n k ⇒ n ∉ s
</pre>

<DT><span class="strong">sub_count_eq_empty</span>
<DD>
<pre>
⊢ ∀n k. sub_count n k = ∅ ⇔ n < k
</pre>

<DT><span class="strong">sub_count_eqn</span>
<DD>
<pre>
⊢ ∀n k.
    sub_count n k =
    if k = 0 then {∅}
    else if n = 0 then ∅
    else
      IMAGE (λs. n − 1 INSERT s) (sub_count (n − 1) (k − 1)) ∪
      sub_count (n − 1) k
</pre>

<DT><span class="strong">sub_count_equiv_class</span>
<DD>
<pre>
⊢ ∀n s.
    s ⊆ count n ⇒
    sub_count n (CARD s) = equiv_class (λs t. s =b= t) (POW (count n)) s
</pre>

<DT><span class="strong">sub_count_finite</span>
<DD>
<pre>
⊢ ∀n k. FINITE (sub_count n k)
</pre>

<DT><span class="strong">sub_count_insert</span>
<DD>
<pre>
⊢ ∀n k s. s ∈ sub_count n k ⇒ n INSERT s ∈ sub_count (n + 1) (k + 1)
</pre>

<DT><span class="strong">sub_count_insert_card</span>
<DD>
<pre>
⊢ ∀n k. CARD (IMAGE (λs. n INSERT s) (sub_count n k)) = n choose k
</pre>

<DT><span class="strong">sub_count_n_0</span>
<DD>
<pre>
⊢ ∀n. sub_count n 0 = {∅}
</pre>

<DT><span class="strong">sub_count_n_1</span>
<DD>
<pre>
⊢ ∀n. sub_count n 1 = {{j} | j < n}
</pre>

<DT><span class="strong">sub_count_n_n</span>
<DD>
<pre>
⊢ ∀n. sub_count n n = {count n}
</pre>

<DT><span class="strong">sub_count_subset</span>
<DD>
<pre>
⊢ ∀n k. sub_count n k ⊆ POW (count n)
</pre>

<DT><span class="strong">sub_count_union</span>
<DD>
<pre>
⊢ ∀n k.
    sub_count (n + 1) (k + 1) =
    IMAGE (λs. n INSERT s) (sub_count n k) ∪ sub_count n (k + 1)
</pre>

<DT><span class="strong">sub_sets_element</span>
<DD>
<pre>
⊢ ∀P k s. s ∈ sub_sets P k ⇔ s ⊆ P ∧ CARD s = k
</pre>

<DT><span class="strong">sub_sets_equiv_class</span>
<DD>
<pre>
⊢ ∀s t.
    FINITE t ∧ s ⊆ t ⇒
    sub_sets t (CARD s) = equiv_class (λs t. s =b= t) (POW t) s
</pre>

<DT><span class="strong">sub_sets_sub_count</span>
<DD>
<pre>
⊢ ∀n k. sub_sets (count n) k = sub_count n k
</pre>

<DT><span class="strong">sum_1_to_n_double</span>
<DD>
<pre>
⊢ ∀n. 2 * SUM [1 .. n] = n * (n + 1)
</pre>

<DT><span class="strong">sum_1_to_n_eq_tri_n</span>
<DD>
<pre>
⊢ ∀n. SUM [1 .. n] = tri n
</pre>

<DT><span class="strong">sum_1_to_n_eqn</span>
<DD>
<pre>
⊢ ∀n. SUM [1 .. n] = n * (n + 1) DIV 2
</pre>

<DT><span class="strong">surj_iff_preimage_card_not_0</span>
<DD>
<pre>
⊢ ∀f s t.
    FINITE s ∧ (∀x. x ∈ s ⇒ f x ∈ t) ⇒
    (SURJ f s t ⇔ ∀y. y ∈ t ⇒ CARD (preimage f s y) ≠ 0)
</pre>

<DT><span class="strong">surj_preimage_not_empty</span>
<DD>
<pre>
⊢ ∀f s t. SURJ f s t ⇔ (∀x. x ∈ s ⇒ f x ∈ t) ∧ ∀y. y ∈ t ⇒ preimage f s y ≠ ∅
</pre>

<DT><span class="strong">tail_turn</span>
<DD>
<pre>
⊢ ∀ls. ls ≠ [] ⇒ TL (turn ls) = FRONT ls
</pre>

<DT><span class="strong">triple_11</span>
<DD>
<pre>
⊢ ∀a0 a1 a2 a0' a1' a2'.
    triple a0 a1 a2 = triple a0' a1' a2' ⇔ a0 = a0' ∧ a1 = a1' ∧ a2 = a2'
</pre>

<DT><span class="strong">triple_Axiom</span>
<DD>
<pre>
⊢ ∀f. ∃fn. ∀a0 a1 a2. fn (triple a0 a1 a2) = f a0 a1 a2
</pre>

<DT><span class="strong">triple_accessors</span>
<DD>
<pre>
⊢ (∀n n0 n1. (triple n n0 n1).a = n) ∧ (∀n n0 n1. (triple n n0 n1).b = n0) ∧
  ∀n n0 n1. (triple n n0 n1).c = n1
</pre>

<DT><span class="strong">triple_accfupds</span>
<DD>
<pre>
⊢ (∀t f. (t with b updated_by f).a = t.a) ∧
  (∀t f. (t with c updated_by f).a = t.a) ∧
  (∀t f. (t with a updated_by f).b = t.b) ∧
  (∀t f. (t with c updated_by f).b = t.b) ∧
  (∀t f. (t with a updated_by f).c = t.c) ∧
  (∀t f. (t with b updated_by f).c = t.c) ∧
  (∀t f. (t with a updated_by f).a = f t.a) ∧
  (∀t f. (t with b updated_by f).b = f t.b) ∧
  ∀t f. (t with c updated_by f).c = f t.c
</pre>

<DT><span class="strong">triple_case_cong</span>
<DD>
<pre>
⊢ ∀M M' f.
    M = M' ∧ (∀a0 a1 a2. M' = triple a0 a1 a2 ⇒ f a0 a1 a2 = f' a0 a1 a2) ⇒
    triple_CASE M f = triple_CASE M' f'
</pre>

<DT><span class="strong">triple_case_eq</span>
<DD>
<pre>
⊢ triple_CASE x f = v ⇔ ∃n n0 n1. x = triple n n0 n1 ∧ f n n0 n1 = v
</pre>

<DT><span class="strong">triple_component_equality</span>
<DD>
<pre>
⊢ ∀t1 t2. t1 = t2 ⇔ t1.a = t2.a ∧ t1.b = t2.b ∧ t1.c = t2.c
</pre>

<DT><span class="strong">triple_fn_updates</span>
<DD>
<pre>
⊢ (∀f n n0 n1. triple n n0 n1 with a updated_by f = triple (f n) n0 n1) ∧
  (∀f n n0 n1. triple n n0 n1 with b updated_by f = triple n (f n0) n1) ∧
  ∀f n n0 n1. triple n n0 n1 with c updated_by f = triple n n0 (f n1)
</pre>

<DT><span class="strong">triple_fupdcanon</span>
<DD>
<pre>
⊢ (∀t g f.
     t with <|b updated_by f; a updated_by g|> =
     t with <|a updated_by g; b updated_by f|>) ∧
  (∀t g f.
     t with <|c updated_by f; a updated_by g|> =
     t with <|a updated_by g; c updated_by f|>) ∧
  ∀t g f.
    t with <|c updated_by f; b updated_by g|> =
    t with <|b updated_by g; c updated_by f|>
</pre>

<DT><span class="strong">triple_fupdcanon_comp</span>
<DD>
<pre>
⊢ ((∀g f. b_fupd f ∘ a_fupd g = a_fupd g ∘ b_fupd f) ∧
   ∀h g f. b_fupd f ∘ a_fupd g ∘ h = a_fupd g ∘ b_fupd f ∘ h) ∧
  ((∀g f. c_fupd f ∘ a_fupd g = a_fupd g ∘ c_fupd f) ∧
   ∀h g f. c_fupd f ∘ a_fupd g ∘ h = a_fupd g ∘ c_fupd f ∘ h) ∧
  (∀g f. c_fupd f ∘ b_fupd g = b_fupd g ∘ c_fupd f) ∧
  ∀h g f. c_fupd f ∘ b_fupd g ∘ h = b_fupd g ∘ c_fupd f ∘ h
</pre>

<DT><span class="strong">triple_fupdfupds</span>
<DD>
<pre>
⊢ (∀t g f.
     t with <|a updated_by f; a updated_by g|> = t with a updated_by f ∘ g) ∧
  (∀t g f.
     t with <|b updated_by f; b updated_by g|> = t with b updated_by f ∘ g) ∧
  ∀t g f.
    t with <|c updated_by f; c updated_by g|> = t with c updated_by f ∘ g
</pre>

<DT><span class="strong">triple_fupdfupds_comp</span>
<DD>
<pre>
⊢ ((∀g f. a_fupd f ∘ a_fupd g = a_fupd (f ∘ g)) ∧
   ∀h g f. a_fupd f ∘ a_fupd g ∘ h = a_fupd (f ∘ g) ∘ h) ∧
  ((∀g f. b_fupd f ∘ b_fupd g = b_fupd (f ∘ g)) ∧
   ∀h g f. b_fupd f ∘ b_fupd g ∘ h = b_fupd (f ∘ g) ∘ h) ∧
  (∀g f. c_fupd f ∘ c_fupd g = c_fupd (f ∘ g)) ∧
  ∀h g f. c_fupd f ∘ c_fupd g ∘ h = c_fupd (f ∘ g) ∘ h
</pre>

<DT><span class="strong">triple_induction</span>
<DD>
<pre>
⊢ ∀P. (∀n n0 n1. P (triple n n0 n1)) ⇒ ∀t. P t
</pre>

<DT><span class="strong">triple_literal_11</span>
<DD>
<pre>
⊢ ∀n11 n01 n1 n12 n02 n2.
    <|a := n11; b := n01; c := n1|> = <|a := n12; b := n02; c := n2|> ⇔
    n11 = n12 ∧ n01 = n02 ∧ n1 = n2
</pre>

<DT><span class="strong">triple_literal_nchotomy</span>
<DD>
<pre>
⊢ ∀t. ∃n1 n0 n. t = <|a := n1; b := n0; c := n|>
</pre>

<DT><span class="strong">triple_nchotomy</span>
<DD>
<pre>
⊢ ∀tt. ∃n n0 n1. tt = triple n n0 n1
</pre>

<DT><span class="strong">triple_updates_eq_literal</span>
<DD>
<pre>
⊢ ∀t n1 n0 n.
    t with <|a := n1; b := n0; c := n|> = <|a := n1; b := n0; c := n|>
</pre>

<DT><span class="strong">turn_eq_nil</span>
<DD>
<pre>
⊢ ∀p. turn p = [] ⇔ p = []
</pre>

<DT><span class="strong">turn_exp_0</span>
<DD>
<pre>
⊢ ∀l. turn_exp l 0 = l
</pre>

<DT><span class="strong">turn_exp_1</span>
<DD>
<pre>
⊢ ∀l. turn_exp l 1 = turn l
</pre>

<DT><span class="strong">turn_exp_2</span>
<DD>
<pre>
⊢ ∀l. turn_exp l 2 = turn (turn l)
</pre>

<DT><span class="strong">turn_exp_SUC</span>
<DD>
<pre>
⊢ ∀l n. turn_exp l (SUC n) = turn_exp (turn l) n
</pre>

<DT><span class="strong">turn_exp_length</span>
<DD>
<pre>
⊢ ∀l n. LENGTH (turn_exp l n) = LENGTH l
</pre>

<DT><span class="strong">turn_exp_suc</span>
<DD>
<pre>
⊢ ∀l n. turn_exp l (SUC n) = turn (turn_exp l n)
</pre>

<DT><span class="strong">turn_length</span>
<DD>
<pre>
⊢ ∀l. LENGTH (turn l) = LENGTH l
</pre>

<DT><span class="strong">turn_nil</span>
<DD>
<pre>
⊢ turn [] = []
</pre>

<DT><span class="strong">turn_not_nil</span>
<DD>
<pre>
⊢ ∀l. l ≠ [] ⇒ turn l = LAST l::FRONT l
</pre>

<DT><span class="strong">turn_snoc</span>
<DD>
<pre>
⊢ ∀ls x. turn (SNOC x ls) = x::ls
</pre>

</DL>



<hr>
</body>
</html>
