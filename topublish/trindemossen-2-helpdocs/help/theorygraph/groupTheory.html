<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: group</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "group"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "monoidTheory.html"><span class="strong">monoid</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">AbelianGroup</span>
    <td>
    :Î± monoid -> bool
    <tr><td>
    <span class="strong">CosetPartition</span>
    <td>
    :Î± monoid -> Î± monoid -> (Î± -> bool) -> bool
    <tr><td>
    <span class="strong">ElGamal_decrypt</span>
    <td>
    :Î± monoid -> num -> Î± # Î± -> Î±
    <tr><td>
    <span class="strong">ElGamal_encrypt</span>
    <td>
    :Î± monoid -> Î± -> Î± -> Î± -> num -> Î± # Î±
    <tr><td> <span class="strong">Estar</span> <td> :num -> num monoid
    <tr><td>
    <span class="strong">FiniteAbelianGroup</span>
    <td>
    :Î± monoid -> bool
    <tr><td> <span class="strong">FiniteGroup</span> <td> :Î± monoid -> bool
    <tr><td> <span class="strong">GFACT</span> <td> :Î± monoid -> Î±
    <tr><td>
    <span class="strong">GROUP_IMAGE</span>
    <td>
    :Î± monoid -> (Î² -> Î±) -> (Î² -> bool) -> Î±
    <tr><td>
    <span class="strong">Generated</span>
    <td>
    :Î± monoid -> Î± -> Î± monoid
    <tr><td>
    <span class="strong">Generated_subset</span>
    <td>
    :Î± monoid -> (Î± -> bool) -> Î± monoid
    <tr><td> <span class="strong">Group</span> <td> :Î± monoid -> bool
    <tr><td>
    <span class="strong">GroupAuto</span>
    <td>
    :(Î± -> Î±) -> Î± monoid -> bool
    <tr><td>
    <span class="strong">GroupEndo</span>
    <td>
    :(Î± -> Î±) -> Î± monoid -> bool
    <tr><td>
    <span class="strong">GroupHomo</span>
    <td>
    :(Î± -> Î²) -> Î± monoid -> Î² monoid -> bool
    <tr><td>
    <span class="strong">GroupIso</span>
    <td>
    :(Î± -> Î²) -> Î± monoid -> Î² monoid -> bool
    <tr><td>
    <span class="strong">OP_IMAGE</span>
    <td>
    :(Î± -> Î± -> Î±) -> Î± -> (Î² -> Î±) -> (Î² -> bool) -> Î±
    <tr><td>
    <span class="strong">StabilizerGroup</span>
    <td>
    :(Î± -> Î² -> Î²) -> Î± monoid -> Î² -> Î± monoid
    <tr><td>
    <span class="strong">Subgroup</span>
    <td>
    :Î± monoid -> Î± monoid -> bool
    <tr><td> <span class="strong">Zadd</span> <td> :num -> num monoid
    <tr><td> <span class="strong">Zstar</span> <td> :num -> num monoid
    <tr><td>
    <span class="strong">act_by</span>
    <td>
    :(Î± -> Î² -> Î²) -> Î± monoid -> Î² -> Î² -> Î±
    <tr><td>
    <span class="strong">action</span>
    <td>
    :(Î± -> Î² -> Î²) -> Î± monoid -> (Î² -> bool) -> bool
    <tr><td> <span class="strong">add_mod</span> <td> :num -> num monoid
    <tr><td>
    <span class="strong">all_subgroups</span>
    <td>
    :Î± monoid -> Î± monoid -> bool
    <tr><td>
    <span class="strong">cogen</span>
    <td>
    :Î± monoid -> Î± monoid -> (Î± -> bool) -> Î±
    <tr><td>
    <span class="strong">conjugate</span>
    <td>
    :Î± monoid -> Î± -> (Î± -> bool) -> Î± -> bool
    <tr><td>
    <span class="strong">conjugate_subgroup</span>
    <td>
    :Î± monoid -> Î± monoid -> Î± -> Î± monoid
    <tr><td>
    <span class="strong">coset</span>
    <td>
    :Î± monoid -> Î± -> (Î± -> bool) -> Î± -> bool
    <tr><td>
    <span class="strong">coset_op</span>
    <td>
    :Î± monoid -> Î± monoid -> (Î± -> bool) -> (Î± -> bool) -> Î± -> bool
    <tr><td> <span class="strong">cyclic</span> <td> :Î± monoid -> bool
    <tr><td> <span class="strong">cyclic_gen</span> <td> :Î± monoid -> Î±
    <tr><td>
    <span class="strong">cyclic_generators</span>
    <td>
    :Î± monoid -> Î± -> bool
    <tr><td>
    <span class="strong">cyclic_index</span>
    <td>
    :Î± monoid -> Î± -> num
    <tr><td>
    <span class="strong">eq_order</span>
    <td>
    :Î± monoid -> Î± -> Î± -> bool
    <tr><td>
    <span class="strong">excluding</span>
    <td>
    :Î± monoid -> Î± -> Î± monoid
    <tr><td>
    <span class="strong">fixed_points</span>
    <td>
    :(Î± -> Î² -> Î²) -> Î± monoid -> (Î² -> bool) -> Î² -> bool
    <tr><td>
    <span class="strong">fn_cyclic_group</span>
    <td>
    :Î± -> (Î± -> Î±) -> Î± monoid
    <tr><td>
    <span class="strong">group_div</span>
    <td>
    :Î± monoid -> Î± -> Î± -> Î±
    <tr><td>
    <span class="strong">group_equiv</span>
    <td>
    :Î± monoid -> Î± monoid -> Î± -> Î± -> bool
    <tr><td>
    <span class="strong">group_fun</span>
    <td>
    :Î± monoid -> (Î± -> Î±) -> bool
    <tr><td>
    <span class="strong">homo_image</span>
    <td>
    :(Î± -> Î²) -> Î± monoid -> Î² monoid -> Î² monoid
    <tr><td>
    <span class="strong">inCoset</span>
    <td>
    :Î± monoid -> Î± monoid -> Î± -> Î± -> bool
    <tr><td>
    <span class="strong">including</span>
    <td>
    :Î± monoid -> Î± -> Î± monoid
    <tr><td>
    <span class="strong">kernel</span>
    <td>
    :(Î± -> Î²) -> Î± monoid -> Î² monoid -> Î± -> bool
    <tr><td>
    <span class="strong">kernel_group</span>
    <td>
    :(Î± -> Î²) -> Î± monoid -> Î² monoid -> Î± monoid
    <tr><td>
    <span class="strong">left_coset</span>
    <td>
    :Î± monoid -> (Î± -> bool) -> Î± -> Î± -> bool
    <tr><td>
    <span class="strong">make_group</span>
    <td>
    :Î± monoid -> (Î± -> bool) -> Î± monoid
    <tr><td> <span class="strong">mult_mod</span> <td> :num -> num monoid
    <tr><td>
    <span class="strong">multi_orbits</span>
    <td>
    :(Î± -> Î² -> Î²) -> Î± monoid -> (Î² -> bool) -> (Î² -> bool) -> bool
    <tr><td>
    <span class="strong">normal_subgroup</span>
    <td>
    :Î± monoid -> Î± monoid -> bool
    <tr><td>
    <span class="strong">orbit</span>
    <td>
    :(Î± -> Î² -> Î²) -> Î± monoid -> Î² -> Î² -> bool
    <tr><td>
    <span class="strong">orbits</span>
    <td>
    :(Î± -> Î² -> Î²) -> Î± monoid -> (Î² -> bool) -> (Î² -> bool) -> bool
    <tr><td>
    <span class="strong">preimage_group</span>
    <td>
    :(Î± -> Î²) -> Î± monoid -> Î² monoid -> (Î² -> bool) -> Î± monoid
    <tr><td>
    <span class="strong">quotient_group</span>
    <td>
    :Î± monoid -> Î± monoid -> (Î± -> bool) monoid
    <tr><td>
    <span class="strong">reach</span>
    <td>
    :(Î± -> Î² -> Î²) -> Î± monoid -> Î² -> Î² -> bool
    <tr><td>
    <span class="strong">right_coset</span>
    <td>
    :Î± monoid -> (Î± -> bool) -> Î± -> Î± -> bool
    <tr><td>
    <span class="strong">roots_of_unity</span>
    <td>
    :Î± monoid -> num -> Î± monoid
    <tr><td>
    <span class="strong">sing_orbits</span>
    <td>
    :(Î± -> Î² -> Î²) -> Î± monoid -> (Î² -> bool) -> (Î² -> bool) -> bool
    <tr><td>
    <span class="strong">stabilizer</span>
    <td>
    :(Î± -> Î² -> Î²) -> Î± monoid -> Î² -> Î± -> bool
    <tr><td>
    <span class="strong">subgroup</span>
    <td>
    :Î± monoid -> Î± monoid -> bool
    <tr><td>
    <span class="strong">subgroup_big_cross</span>
    <td>
    :Î± monoid -> (Î± monoid -> bool) -> Î± monoid
    <tr><td>
    <span class="strong">subgroup_big_intersect</span>
    <td>
    :Î± monoid -> Î± monoid
    <tr><td>
    <span class="strong">subgroup_cross</span>
    <td>
    :Î± monoid -> Î± monoid -> Î± monoid -> Î± monoid
    <tr><td>
    <span class="strong">subset_big_cross</span>
    <td>
    :Î± monoid -> ((Î± -> bool) -> bool) -> Î± -> bool
    <tr><td>
    <span class="strong">subset_cross</span>
    <td>
    :Î± monoid -> (Î± -> bool) -> (Î± -> bool) -> Î± -> bool
    <tr><td>
    <span class="strong">subset_cross_left</span>
    <td>
    :Î± monoid -> (Î± -> bool) -> (Î± -> bool) -> Î± -> Î±
    <tr><td>
    <span class="strong">subset_cross_right</span>
    <td>
    :Î± monoid -> (Î± -> bool) -> (Î± -> bool) -> Î± -> Î±
    <tr><td>
    <span class="strong">subset_group</span>
    <td>
    :Î± monoid -> (Î± -> bool) -> Î± monoid
    <tr><td>
    <span class="strong">symdiff</span>
    <td>
    :(Î± -> bool) -> (Î± -> bool) -> Î± -> bool
    <tr><td> <span class="strong">symdiff_set</span> <td> :(Î± -> bool) monoid
    <tr><td> <span class="strong">trivial_group</span> <td> :Î± -> Î± monoid
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">AbelianGroup_def</span>
<DD>
<pre>
âŠ¢ âˆ€g. AbelianGroup g â‡” Group g âˆ§ âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ x * y = y * x
</pre>

<DT><span class="strong">CosetPartition_def</span>
<DD>
<pre>
âŠ¢ âˆ€g h. CosetPartition g h = partition (inCoset g h) G
</pre>

<DT><span class="strong">ElGamal_decrypt_def</span>
<DD>
<pre>
âŠ¢ âˆ€g x a b. ElGamal_decrypt g x (a,b) = |/ (a ** x) * b
</pre>

<DT><span class="strong">ElGamal_encrypt_def</span>
<DD>
<pre>
âŠ¢ âˆ€g y h m k. ElGamal_encrypt g y h m k = (y ** k,h ** k * m)
</pre>

<DT><span class="strong">Estar_def</span>
<DD>
<pre>
âŠ¢ âˆ€n. Estar n = <|carrier := Euler n; id := 1; op := (Î»i j. (i * j) MOD n)|>
</pre>

<DT><span class="strong">FiniteAbelianGroup_def</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteAbelianGroup g â‡” AbelianGroup g âˆ§ FINITE G
</pre>

<DT><span class="strong">FiniteGroup_def</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteGroup g â‡” Group g âˆ§ FINITE G
</pre>

<DT><span class="strong">GFACT_def</span>
<DD>
<pre>
âŠ¢ âˆ€g. GFACT g = GPROD_SET g G
</pre>

<DT><span class="strong">GROUP_IMAGE_def</span>
<DD>
<pre>
âŠ¢ âˆ€g f s. GROUP_IMAGE g f s = ITSET (Î»e acc. f e * acc) s #e
</pre>

<DT><span class="strong">Generated_def</span>
<DD>
<pre>
âŠ¢ âˆ€g a. gen a = <|carrier := {x | âˆƒk. x = a ** k}; op := $*; id := #e|>
</pre>

<DT><span class="strong">Generated_subset_def</span>
<DD>
<pre>
âŠ¢ âˆ€g s.
    gen_set s =
    <|carrier := BIGINTER (IMAGE (Î»h. H) {h | h â‰¤ g âˆ§ s âŠ† H}); op := $*;
      id := #e|>
</pre>

<DT><span class="strong">GroupAuto_def</span>
<DD>
<pre>
âŠ¢ âˆ€f g. GroupAuto f g â‡” GroupIso f g g
</pre>

<DT><span class="strong">GroupEndo_def</span>
<DD>
<pre>
âŠ¢ âˆ€f g. GroupEndo f g â‡” GroupHomo f g g
</pre>

<DT><span class="strong">GroupHomo_def</span>
<DD>
<pre>
âŠ¢ âˆ€f g h.
    GroupHomo f g h â‡”
    (âˆ€x. x âˆˆ G â‡’ f x âˆˆ h.carrier) âˆ§
    âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ f (x * y) = h.op (f x) (f y)
</pre>

<DT><span class="strong">GroupIso_def</span>
<DD>
<pre>
âŠ¢ âˆ€f g h. GroupIso f g h â‡” GroupHomo f g h âˆ§ BIJ f G h.carrier
</pre>

<DT><span class="strong">Group_def</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡” Monoid g âˆ§ G* = G
</pre>

<DT><span class="strong">OP_IMAGE_def</span>
<DD>
<pre>
âŠ¢ âˆ€op id f s. OP_IMAGE op id f s = ITSET (Î»e acc. op (f e) acc) s id
</pre>

<DT><span class="strong">StabilizerGroup_def</span>
<DD>
<pre>
âŠ¢ âˆ€f g x.
    StabilizerGroup f g x =
    <|carrier := stabilizer f g x; op := $*; id := #e|>
</pre>

<DT><span class="strong">Subgroup_def</span>
<DD>
<pre>
âŠ¢ âˆ€h g. h â‰¤ g â‡” Group h âˆ§ Group g âˆ§ H âŠ† G âˆ§ h.op = $*
</pre>

<DT><span class="strong">Zadd_def</span>
<DD>
<pre>
âŠ¢ âˆ€n. Zadd n = <|carrier := count n; id := 0; op := (Î»i j. (i + j) MOD n)|>
</pre>

<DT><span class="strong">Zstar_def</span>
<DD>
<pre>
âŠ¢ âˆ€p. Zstar p = <|carrier := residue p; id := 1; op := (Î»i j. (i * j) MOD p)|>
</pre>

<DT><span class="strong">act_by_def</span>
<DD>
<pre>
âŠ¢ âˆ€f g x y. reach f g x y â‡’ act_by f g x y âˆˆ G âˆ§ f (act_by f g x y) x = y
</pre>

<DT><span class="strong">action_def</span>
<DD>
<pre>
âŠ¢ âˆ€f g X.
    (g act X) f â‡”
    âˆ€x. x âˆˆ X â‡’
        (âˆ€a. a âˆˆ G â‡’ f a x âˆˆ X) âˆ§ f #e x = x âˆ§
        âˆ€a b. a âˆˆ G âˆ§ b âˆˆ G â‡’ f a (f b x) = f (a * b) x
</pre>

<DT><span class="strong">add_mod_def</span>
<DD>
<pre>
âŠ¢ âˆ€n. add_mod n =
      <|carrier := {i | i < n}; id := 0; op := (Î»i j. (i + j) MOD n)|>
</pre>

<DT><span class="strong">all_subgroups_def</span>
<DD>
<pre>
âŠ¢ âˆ€g. all_subgroups g = {h | h â‰¤ g}
</pre>

<DT><span class="strong">cogen_def</span>
<DD>
<pre>
âŠ¢ âˆ€g h e.
    h â‰¤ g âˆ§ e âˆˆ CosetPartition g h â‡’ cogen g h e âˆˆ G âˆ§ e = cogen g h e * H
</pre>

<DT><span class="strong">conjugate_def</span>
<DD>
<pre>
âŠ¢ âˆ€g a s. conjugate g a s = {a * z * |/ a | z âˆˆ s}
</pre>

<DT><span class="strong">conjugate_subgroup_def</span>
<DD>
<pre>
âŠ¢ âˆ€h g a.
    conjugate_subgroup h g a =
    <|carrier := conjugate g a H; id := #e; op := $* |>
</pre>

<DT><span class="strong">coset_def</span>
<DD>
<pre>
âŠ¢ âˆ€g a X. a * X = IMAGE (Î»z. a * z) X
</pre>

<DT><span class="strong">coset_op_def</span>
<DD>
<pre>
âŠ¢ âˆ€g h x y. x âˆ˜ y = cogen g h x * cogen g h y * H
</pre>

<DT><span class="strong">cyclic_def</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g â‡” Group g âˆ§ âˆƒz. z âˆˆ G âˆ§ âˆ€x. x âˆˆ G â‡’ âˆƒn. x = z ** n
</pre>

<DT><span class="strong">cyclic_gen_def</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g â‡’ cyclic_gen g âˆˆ G âˆ§ âˆ€x. x âˆˆ G â‡’ âˆƒn. x = cyclic_gen g ** n
</pre>

<DT><span class="strong">cyclic_generators_def</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic_generators g = {z | z âˆˆ G âˆ§ ord z = CARD G}
</pre>

<DT><span class="strong">cyclic_index_def</span>
<DD>
<pre>
âŠ¢ âˆ€g x.
    cyclic g âˆ§ x âˆˆ G â‡’
    x = cyclic_gen g ** cyclic_index g x âˆ§
    (FINITE G â‡’ cyclic_index g x < CARD G)
</pre>

<DT><span class="strong">eq_order_def</span>
<DD>
<pre>
âŠ¢ âˆ€g x y. eq_order g x y â‡” ord x = ord y
</pre>

<DT><span class="strong">excluding_def</span>
<DD>
<pre>
âŠ¢ âˆ€g z. g excluding z = <|carrier := G DIFF {z}; op := $*; id := #e|>
</pre>

<DT><span class="strong">fixed_points_def</span>
<DD>
<pre>
âŠ¢ âˆ€f g X. fixed_points f g X = {x | x âˆˆ X âˆ§ âˆ€a. a âˆˆ G â‡’ f a x = x}
</pre>

<DT><span class="strong">fn_cyclic_group_def</span>
<DD>
<pre>
âŠ¢ âˆ€e f.
    fn_cyclic_group e f =
    <|carrier := {x | âˆƒn. FUNPOW f n e = x}; id := e;
      op :=
        (Î»x y.
             @z. âˆ€xi yi.
               FUNPOW f xi e = x âˆ§ FUNPOW f yi e = y â‡’
               FUNPOW f (xi + yi) e = z)|>
</pre>

<DT><span class="strong">group_div_def</span>
<DD>
<pre>
âŠ¢ âˆ€g x y. x / y = x * |/ y
</pre>

<DT><span class="strong">group_equiv_def</span>
<DD>
<pre>
âŠ¢ âˆ€g h x y. x == y â‡” x / y âˆˆ H
</pre>

<DT><span class="strong">group_fun_def</span>
<DD>
<pre>
âŠ¢ âˆ€g f. group_fun g f â‡” âˆ€x. x âˆˆ G â‡’ f x âˆˆ G
</pre>

<DT><span class="strong">homo_image_def</span>
<DD>
<pre>
âŠ¢ âˆ€f g h. homo_image f g h = <|carrier := IMAGE f G; op := h.op; id := h.id|>
</pre>

<DT><span class="strong">inCoset_def</span>
<DD>
<pre>
âŠ¢ âˆ€g h a b. inCoset g h a b â‡” b âˆˆ a * H
</pre>

<DT><span class="strong">including_def</span>
<DD>
<pre>
âŠ¢ âˆ€g z. g including z = <|carrier := G âˆª {z}; op := $*; id := #e|>
</pre>

<DT><span class="strong">kernel_def</span>
<DD>
<pre>
âŠ¢ âˆ€f g h. kernel f g h = preimage f G h.id
</pre>

<DT><span class="strong">kernel_group_def</span>
<DD>
<pre>
âŠ¢ âˆ€f g h.
    kernel_group f g h = <|carrier := kernel f g h; id := #e; op := $* |>
</pre>

<DT><span class="strong">left_coset_def</span>
<DD>
<pre>
âŠ¢ âˆ€g X a. left_coset g X a = a * X
</pre>

<DT><span class="strong">make_group_def</span>
<DD>
<pre>
âŠ¢ âˆ€g s. make_group g s = <|carrier := s; op := $*; id := #e|>
</pre>

<DT><span class="strong">mult_mod_def</span>
<DD>
<pre>
âŠ¢ âˆ€p. mult_mod p =
      <|carrier := {i | i â‰  0 âˆ§ i < p}; id := 1; op := (Î»i j. (i * j) MOD p)|>
</pre>

<DT><span class="strong">multi_orbits_def</span>
<DD>
<pre>
âŠ¢ âˆ€f g X. multi_orbits f g X = {e | e âˆˆ orbits f g X âˆ§ Â¬SING e}
</pre>

<DT><span class="strong">normal_subgroup_def</span>
<DD>
<pre>
âŠ¢ âˆ€h g. h << g â‡” h â‰¤ g âˆ§ âˆ€a z. a âˆˆ G âˆ§ z âˆˆ H â‡’ a * z / a âˆˆ H
</pre>

<DT><span class="strong">orbit_def</span>
<DD>
<pre>
âŠ¢ âˆ€f g x. orbit f g x = IMAGE (Î»a. f a x) G
</pre>

<DT><span class="strong">orbits_def</span>
<DD>
<pre>
âŠ¢ âˆ€f g X. orbits f g X = IMAGE (orbit f g) X
</pre>

<DT><span class="strong">preimage_group_def</span>
<DD>
<pre>
âŠ¢ âˆ€f g1 g2 h.
    preimage_group f g1 g2 h =
    <|carrier := PREIMAGE f h âˆ© g1.carrier; op := g1.op; id := g1.id|>
</pre>

<DT><span class="strong">quotient_group_def</span>
<DD>
<pre>
âŠ¢ âˆ€g h. g / h = <|carrier := CosetPartition g h; op := $o; id := H|>
</pre>

<DT><span class="strong">reach_def</span>
<DD>
<pre>
âŠ¢ âˆ€f g x y. reach f g x y â‡” âˆƒa. a âˆˆ G âˆ§ f a x = y
</pre>

<DT><span class="strong">right_coset_def</span>
<DD>
<pre>
âŠ¢ âˆ€g X a. X * a = IMAGE (Î»z. z * a) X
</pre>

<DT><span class="strong">roots_of_unity_def</span>
<DD>
<pre>
âŠ¢ âˆ€g n.
    uroots n = <|carrier := {x | x âˆˆ G âˆ§ x ** n = #e}; op := $*; id := #e|>
</pre>

<DT><span class="strong">sing_orbits_def</span>
<DD>
<pre>
âŠ¢ âˆ€f g X. sing_orbits f g X = {e | e âˆˆ orbits f g X âˆ§ SING e}
</pre>

<DT><span class="strong">stabilizer_def</span>
<DD>
<pre>
âŠ¢ âˆ€f g x. stabilizer f g x = {a | a âˆˆ G âˆ§ f a x = x}
</pre>

<DT><span class="strong">subgroup_big_cross_def</span>
<DD>
<pre>
âŠ¢ âˆ€g B. sgbcross B = ITSET $o B (gen #e)
</pre>

<DT><span class="strong">subgroup_big_intersect_def</span>
<DD>
<pre>
âŠ¢ âˆ€g. sgbINTER g =
      <|carrier := BIGINTER (IMAGE (Î»h. H) {h | h â‰¤ g}); op := $*; id := #e|>
</pre>

<DT><span class="strong">subgroup_cross_def</span>
<DD>
<pre>
âŠ¢ âˆ€g h1 h2. h1 âˆ˜ h2 = make_group g (h1.carrier âˆ˜ h2.carrier)
</pre>

<DT><span class="strong">subgroup_def</span>
<DD>
<pre>
âŠ¢ âˆ€h g. subgroup h g â‡” GroupHomo I h g
</pre>

<DT><span class="strong">subset_big_cross_def</span>
<DD>
<pre>
âŠ¢ âˆ€g B. ssbcross B = ITSET $o B {#e}
</pre>

<DT><span class="strong">subset_cross_def</span>
<DD>
<pre>
âŠ¢ âˆ€g s1 s2. s1 âˆ˜ s2 = {x * y | x âˆˆ s1 âˆ§ y âˆˆ s2}
</pre>

<DT><span class="strong">subset_cross_left_right_def</span>
<DD>
<pre>
âŠ¢ âˆ€g s1 s2 z. z âˆˆ s1 âˆ˜ s2 â‡’ left z âˆˆ s1 âˆ§ right z âˆˆ s2 âˆ§ z = left z * right z
</pre>

<DT><span class="strong">subset_group_def</span>
<DD>
<pre>
âŠ¢ âˆ€g s. subset_group g s = <|carrier := s; op := $*; id := #e|>
</pre>

<DT><span class="strong">symdiff_def</span>
<DD>
<pre>
âŠ¢ âˆ€s1 s2. symdiff s1 s2 = s1 âˆª s2 DIFF s1 âˆ© s2
</pre>

<DT><span class="strong">symdiff_set_def</span>
<DD>
<pre>
âŠ¢ symdiff_set = <|carrier := ð•Œ(:Î± -> bool); id := âˆ…; op := symdiff|>
</pre>

<DT><span class="strong">trivial_group_def</span>
<DD>
<pre>
âŠ¢ âˆ€e. trivial_group e = <|carrier := {e}; id := e; op := (Î»x y. e)|>
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">ElGamal_correctness</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’
      âˆ€(y::G) (h::G) (m::G) k x.
        h = y ** x â‡’ ElGamal_decrypt g x (ElGamal_encrypt g y h m k) = m
</pre>

<DT><span class="strong">Estar_alt</span>
<DD>
<pre>
âŠ¢ âˆ€n. Estar n =
      <|carrier := {i | 0 < i âˆ§ i < n âˆ§ coprime n i}; id := 1;
        op := (Î»i j. (i * j) MOD n)|>
</pre>

<DT><span class="strong">Estar_card</span>
<DD>
<pre>
âŠ¢ âˆ€n. CARD (Estar n).carrier = totient n
</pre>

<DT><span class="strong">Estar_card_alt</span>
<DD>
<pre>
âŠ¢ âˆ€n. 1 < n â‡’ CARD (Estar n).carrier = phi n
</pre>

<DT><span class="strong">Estar_carrier</span>
<DD>
<pre>
âŠ¢ âˆ€n. (Estar n).carrier = Euler n
</pre>

<DT><span class="strong">Estar_carrier_alt</span>
<DD>
<pre>
âŠ¢ âˆ€n. (Estar n).carrier = {i | 0 < i âˆ§ i < n âˆ§ coprime n i}
</pre>

<DT><span class="strong">Estar_element</span>
<DD>
<pre>
âŠ¢ âˆ€n x. x âˆˆ (Estar n).carrier â‡” 0 < x âˆ§ x < n âˆ§ coprime n x
</pre>

<DT><span class="strong">Estar_eval</span>
<DD>
<pre>
âŠ¢ âˆ€n. (Estar n).carrier = Euler n âˆ§ (âˆ€x y. (Estar n).op x y = (x * y) MOD n) âˆ§
      (Estar n).id = 1
</pre>

<DT><span class="strong">Estar_exp</span>
<DD>
<pre>
âŠ¢ âˆ€n a. 1 < n âˆ§ a âˆˆ (Estar n).carrier â‡’ âˆ€k. (Estar n).exp a k = a ** k MOD n
</pre>

<DT><span class="strong">Estar_finite</span>
<DD>
<pre>
âŠ¢ âˆ€n. FINITE (Estar n).carrier
</pre>

<DT><span class="strong">Estar_finite_abelian_group</span>
<DD>
<pre>
âŠ¢ âˆ€n. 1 < n â‡’ FiniteAbelianGroup (Estar n)
</pre>

<DT><span class="strong">Estar_finite_group</span>
<DD>
<pre>
âŠ¢ âˆ€n. 1 < n â‡’ FiniteGroup (Estar n)
</pre>

<DT><span class="strong">Estar_group</span>
<DD>
<pre>
âŠ¢ âˆ€n. 1 < n â‡’ Group (Estar n)
</pre>

<DT><span class="strong">Estar_id</span>
<DD>
<pre>
âŠ¢ âˆ€n. (Estar n).id = 1
</pre>

<DT><span class="strong">Estar_inv</span>
<DD>
<pre>
âŠ¢ âˆ€n a.
    1 < n âˆ§ a < n âˆ§ coprime n a â‡’ (Estar n).inv a = a ** (totient n âˆ’ 1) MOD n
</pre>

<DT><span class="strong">Estar_inv_compute</span>
<DD>
<pre>
âŠ¢ âˆ€n a.
    (Estar n).inv a =
    if 1 < n âˆ§ a < n âˆ§ coprime n a then a ** (totient n âˆ’ 1) MOD n
    else FAIL ((Estar n).inv a) bad_element
</pre>

<DT><span class="strong">Estar_property</span>
<DD>
<pre>
âŠ¢ âˆ€n. (Estar n).carrier = Euler n âˆ§ (Estar n).id = 1 âˆ§
      (âˆ€x y. (Estar n).op x y = (x * y) MOD n) âˆ§ FINITE (Estar n).carrier âˆ§
      CARD (Estar n).carrier = totient n
</pre>

<DT><span class="strong">Euler_Fermat_alt</span>
<DD>
<pre>
âŠ¢ âˆ€n a. 1 < n âˆ§ coprime a n â‡’ a ** totient n MOD n = 1
</pre>

<DT><span class="strong">Euler_Fermat_eqn</span>
<DD>
<pre>
âŠ¢ âˆ€n a. 1 < n âˆ§ a < n âˆ§ coprime n a â‡’ a ** totient n MOD n = 1
</pre>

<DT><span class="strong">Euler_Fermat_thm</span>
<DD>
<pre>
âŠ¢ âˆ€n a. 1 < n âˆ§ coprime n a â‡’ a ** totient n MOD n = 1
</pre>

<DT><span class="strong">Fermat_little_eqn</span>
<DD>
<pre>
âŠ¢ âˆ€p a. prime p â‡’ a ** p MOD p = a MOD p
</pre>

<DT><span class="strong">Fermat_little_thm</span>
<DD>
<pre>
âŠ¢ âˆ€p a. prime p âˆ§ 0 < a âˆ§ a < p â‡’ a ** (p âˆ’ 1) MOD p = 1
</pre>

<DT><span class="strong">FiniteAbelianGroup_def_alt</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteAbelianGroup g â‡”
      FiniteGroup g âˆ§ âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ x * y = y * x
</pre>

<DT><span class="strong">GFACT_element</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteAbelianMonoid g â‡’ GFACT g âˆˆ G
</pre>

<DT><span class="strong">GFACT_identity</span>
<DD>
<pre>
âŠ¢ âˆ€g a. FiniteAbelianGroup g âˆ§ a âˆˆ G â‡’ GFACT g = a ** CARD G * GFACT g
</pre>

<DT><span class="strong">GITSET_AS_ITSET</span>
<DD>
<pre>
âŠ¢ âˆ€g. (Î»s b. GITSET g s b) = ITSET (Î»e acc. e * acc)
</pre>

<DT><span class="strong">GPROD_SET_AS_GROUP_IMAGE</span>
<DD>
<pre>
âŠ¢ âˆ€g. GPROD_SET g = GROUP_IMAGE g I
</pre>

<DT><span class="strong">GPROD_SET_IMAGE</span>
<DD>
<pre>
âŠ¢ âˆ€g a. Group g âˆ§ a âˆˆ G â‡’ GPROD_SET g (a * G) = GPROD_SET g G
</pre>

<DT><span class="strong">GPROD_SET_REDUCTION</span>
<DD>
<pre>
âŠ¢ âˆ€g s.
    FiniteAbelianGroup g âˆ§ s âŠ† G â‡’
    âˆ€a::G.
      a ** CARD s * GPROD_SET g s * GPROD_SET g (a * (G DIFF s)) =
      GPROD_SET g G
</pre>

<DT><span class="strong">GPROD_SET_REDUCTION_INSERT</span>
<DD>
<pre>
âŠ¢ âˆ€g s.
    FiniteAbelianGroup g âˆ§ s âŠ† G â‡’
    âˆ€a x::G.
      x âˆ‰ s â‡’
      a * x * GPROD_SET g (a * (G DIFF (x INSERT s))) =
      GPROD_SET g (a * (G DIFF s))
</pre>

<DT><span class="strong">Generated_subset_exp</span>
<DD>
<pre>
âŠ¢ âˆ€g s. (gen_set s).exp = $**
</pre>

<DT><span class="strong">Generated_subset_gen</span>
<DD>
<pre>
âŠ¢ âˆ€g a. FiniteGroup g âˆ§ a âˆˆ G â‡’ gen_set (Gen a) = gen a
</pre>

<DT><span class="strong">Generated_subset_group</span>
<DD>
<pre>
âŠ¢ âˆ€g s. Group g âˆ§ s âŠ† G â‡’ Group (gen_set s)
</pre>

<DT><span class="strong">Generated_subset_has_set</span>
<DD>
<pre>
âŠ¢ âˆ€g s. s âŠ† (gen_set s).carrier
</pre>

<DT><span class="strong">Generated_subset_property</span>
<DD>
<pre>
âŠ¢ âˆ€g s.
    (gen_set s).carrier = BIGINTER (IMAGE (Î»h. H) {h | h â‰¤ g âˆ§ s âŠ† H}) âˆ§
    (gen_set s).op = $* âˆ§ (gen_set s).id = #e
</pre>

<DT><span class="strong">Generated_subset_subgroup</span>
<DD>
<pre>
âŠ¢ âˆ€g s. Group g âˆ§ s âŠ† G â‡’ gen_set s â‰¤ g
</pre>

<DT><span class="strong">Generated_subset_subset</span>
<DD>
<pre>
âŠ¢ âˆ€g s. Group g âˆ§ s âŠ† G â‡’ (gen_set s).carrier âŠ† G
</pre>

<DT><span class="strong">Invertibles_inv</span>
<DD>
<pre>
âŠ¢ âˆ€g x. Monoid g âˆ§ x âˆˆ G* â‡’ (Invertibles g).inv x = |/ x
</pre>

<DT><span class="strong">Lagrange_identity</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g âˆ§ FINITE G â‡’ CARD G = CARD H * CARD (CosetPartition g h)
</pre>

<DT><span class="strong">Lagrange_identity_alt</span>
<DD>
<pre>
âŠ¢ âˆ€g h.
    h â‰¤ g âˆ§ FINITE G â‡’ CARD G = CARD H * CARD (partition (left_coset g H) G)
</pre>

<DT><span class="strong">Lagrange_thm</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g âˆ§ FINITE G â‡’ CARD H divides CARD G
</pre>

<DT><span class="strong">OP_IMAGE_EMPTY</span>
<DD>
<pre>
âŠ¢ âˆ€op id f. OP_IMAGE op id f âˆ… = id
</pre>

<DT><span class="strong">OP_IMAGE_SING</span>
<DD>
<pre>
âŠ¢ âˆ€op id f x. OP_IMAGE op id f {x} = op (f x) id
</pre>

<DT><span class="strong">OP_IMAGE_THM</span>
<DD>
<pre>
âŠ¢ âˆ€op id f.
    OP_IMAGE op id f âˆ… = id âˆ§
    (FUN_COMM op f â‡’
     âˆ€s. FINITE s â‡’
         âˆ€e. OP_IMAGE op id f (e INSERT s) =
             op (f e) (OP_IMAGE op id f (s DELETE e)))
</pre>

<DT><span class="strong">PRIME_2</span>
<DD>
<pre>
âŠ¢ prime 2
</pre>

<DT><span class="strong">PRIME_3</span>
<DD>
<pre>
âŠ¢ prime 3
</pre>

<DT><span class="strong">PRIME_5</span>
<DD>
<pre>
âŠ¢ prime 5
</pre>

<DT><span class="strong">PRIME_7</span>
<DD>
<pre>
âŠ¢ prime 7
</pre>

<DT><span class="strong">SURJ_IMAGE_PREIMAGE</span>
<DD>
<pre>
âŠ¢ âˆ€f a b. s âŠ† b âˆ§ SURJ f a b â‡’ IMAGE f (PREIMAGE f s âˆ© a) = s
</pre>

<DT><span class="strong">Subgroup_homo_homo</span>
<DD>
<pre>
âŠ¢ âˆ€g h k f. h â‰¤ g âˆ§ GroupHomo f g k â‡’ GroupHomo f h k
</pre>

<DT><span class="strong">Subgroup_subgroup</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ subgroup h g
</pre>

<DT><span class="strong">Zadd_card</span>
<DD>
<pre>
âŠ¢ âˆ€n. CARD (Zadd n).carrier = n
</pre>

<DT><span class="strong">Zadd_carrier</span>
<DD>
<pre>
âŠ¢ âˆ€n. (Zadd n).carrier = count n
</pre>

<DT><span class="strong">Zadd_carrier_alt</span>
<DD>
<pre>
âŠ¢ âˆ€n. (Zadd n).carrier = {i | i < n}
</pre>

<DT><span class="strong">Zadd_element</span>
<DD>
<pre>
âŠ¢ âˆ€n x. x âˆˆ (Zadd n).carrier â‡” x < n
</pre>

<DT><span class="strong">Zadd_eval</span>
<DD>
<pre>
âŠ¢ âˆ€n. (Zadd n).carrier = count n âˆ§ (âˆ€x y. (Zadd n).op x y = (x + y) MOD n) âˆ§
      (Zadd n).id = 0
</pre>

<DT><span class="strong">Zadd_exp</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ âˆ€x m. (Zadd n).exp x m = (x * m) MOD n
</pre>

<DT><span class="strong">Zadd_finite</span>
<DD>
<pre>
âŠ¢ âˆ€n. FINITE (Zadd n).carrier
</pre>

<DT><span class="strong">Zadd_finite_abelian_group</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ FiniteAbelianGroup (Zadd n)
</pre>

<DT><span class="strong">Zadd_finite_group</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ FiniteGroup (Zadd n)
</pre>

<DT><span class="strong">Zadd_group</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ Group (Zadd n)
</pre>

<DT><span class="strong">Zadd_id</span>
<DD>
<pre>
âŠ¢ âˆ€n. (Zadd n).id = 0
</pre>

<DT><span class="strong">Zadd_inv</span>
<DD>
<pre>
âŠ¢ âˆ€n x. 0 < n âˆ§ x < n â‡’ (Zadd n).inv x = (n âˆ’ x) MOD n
</pre>

<DT><span class="strong">Zadd_inv_compute</span>
<DD>
<pre>
âŠ¢ âˆ€n x.
    (Zadd n).inv x =
    if 0 < n âˆ§ x < n then (n âˆ’ x) MOD n else FAIL ((Zadd n).inv x) bad_element
</pre>

<DT><span class="strong">Zadd_property</span>
<DD>
<pre>
âŠ¢ âˆ€n. (âˆ€x. x âˆˆ (Zadd n).carrier â‡” x < n) âˆ§ (Zadd n).id = 0 âˆ§
      (âˆ€x y. (Zadd n).op x y = (x + y) MOD n) âˆ§ FINITE (Zadd n).carrier âˆ§
      CARD (Zadd n).carrier = n
</pre>

<DT><span class="strong">Zstar_card</span>
<DD>
<pre>
âŠ¢ âˆ€p. 0 < p â‡’ CARD (Zstar p).carrier = p âˆ’ 1
</pre>

<DT><span class="strong">Zstar_carrier</span>
<DD>
<pre>
âŠ¢ âˆ€p. (Zstar p).carrier = residue p
</pre>

<DT><span class="strong">Zstar_carrier_alt</span>
<DD>
<pre>
âŠ¢ âˆ€p. (Zstar p).carrier = {i | 0 < i âˆ§ i < p}
</pre>

<DT><span class="strong">Zstar_element</span>
<DD>
<pre>
âŠ¢ âˆ€p x. x âˆˆ (Zstar p).carrier â‡” 0 < x âˆ§ x < p
</pre>

<DT><span class="strong">Zstar_eval</span>
<DD>
<pre>
âŠ¢ âˆ€p. (Zstar p).carrier = residue p âˆ§
      (âˆ€x y. (Zstar p).op x y = (x * y) MOD p) âˆ§ (Zstar p).id = 1
</pre>

<DT><span class="strong">Zstar_exp</span>
<DD>
<pre>
âŠ¢ âˆ€p a. prime p âˆ§ a âˆˆ (Zstar p).carrier â‡’ âˆ€n. (Zstar p).exp a n = a ** n MOD p
</pre>

<DT><span class="strong">Zstar_finite</span>
<DD>
<pre>
âŠ¢ âˆ€p. FINITE (Zstar p).carrier
</pre>

<DT><span class="strong">Zstar_finite_abelian_group</span>
<DD>
<pre>
âŠ¢ âˆ€p. prime p â‡’ FiniteAbelianGroup (Zstar p)
</pre>

<DT><span class="strong">Zstar_finite_group</span>
<DD>
<pre>
âŠ¢ âˆ€p. prime p â‡’ FiniteGroup (Zstar p)
</pre>

<DT><span class="strong">Zstar_group</span>
<DD>
<pre>
âŠ¢ âˆ€p. prime p â‡’ Group (Zstar p)
</pre>

<DT><span class="strong">Zstar_id</span>
<DD>
<pre>
âŠ¢ âˆ€p. (Zstar p).id = 1
</pre>

<DT><span class="strong">Zstar_inv</span>
<DD>
<pre>
âŠ¢ âˆ€p. prime p â‡’
      âˆ€x. 0 < x âˆ§ x < p â‡’
          (Zstar p).inv x = (Zstar p).exp x (order (Zstar p) x âˆ’ 1)
</pre>

<DT><span class="strong">Zstar_inv_compute</span>
<DD>
<pre>
âŠ¢ âˆ€p x.
    (Zstar p).inv x =
    if prime p âˆ§ 0 < x âˆ§ x < p then (Zstar p).exp x (order (Zstar p) x âˆ’ 1)
    else FAIL ((Zstar p).inv x) bad_element
</pre>

<DT><span class="strong">Zstar_inverse</span>
<DD>
<pre>
âŠ¢ âˆ€p. prime p â‡’ âˆ€a. 0 < a âˆ§ a < p â‡’ (Zstar p).inv a = a ** (p âˆ’ 2) MOD p
</pre>

<DT><span class="strong">Zstar_inverse_compute</span>
<DD>
<pre>
âŠ¢ âˆ€p a.
    (Zstar p).inv a =
    if prime p âˆ§ 0 < a âˆ§ a < p then a ** (p âˆ’ 2) MOD p else (Zstar p).inv a
</pre>

<DT><span class="strong">Zstar_property</span>
<DD>
<pre>
âŠ¢ âˆ€p. (Zstar p).carrier = residue p âˆ§ (Zstar p).id = 1 âˆ§
      (âˆ€x y. (Zstar p).op x y = (x * y) MOD p) âˆ§ FINITE (Zstar p).carrier âˆ§
      (0 < p â‡’ CARD (Zstar p).carrier = p âˆ’ 1)
</pre>

<DT><span class="strong">abelian_group_is_abelian_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€g. AbelianGroup g â‡’ AbelianMonoid g
</pre>

<DT><span class="strong">abelian_group_order_common</span>
<DD>
<pre>
âŠ¢ âˆ€g. AbelianGroup g â‡’
      âˆ€x y.
        x âˆˆ G âˆ§ y âˆˆ G â‡’
        âˆƒz. z âˆˆ G âˆ§ ord z * gcd (ord x) (ord y) = lcm (ord x) (ord y)
</pre>

<DT><span class="strong">abelian_group_order_common_coprime</span>
<DD>
<pre>
âŠ¢ âˆ€g. AbelianGroup g â‡’
      âˆ€x y.
        x âˆˆ G âˆ§ y âˆˆ G âˆ§ coprime (ord x) (ord y) â‡’
        âˆƒz. z âˆˆ G âˆ§ ord z = ord x * ord y
</pre>

<DT><span class="strong">abelian_monoid_invertible_excluding</span>
<DD>
<pre>
âŠ¢ âˆ€g. AbelianMonoid g â‡’ âˆ€z. z âˆ‰ G* â‡’ monoid_invertibles (g excluding z) = G*
</pre>

<DT><span class="strong">abelian_subgroup_abelian</span>
<DD>
<pre>
âŠ¢ âˆ€g h. AbelianGroup g âˆ§ h â‰¤ g â‡’ AbelianGroup h
</pre>

<DT><span class="strong">abelian_subgroup_cross_finite</span>
<DD>
<pre>
âŠ¢ âˆ€g. AbelianGroup g â‡’
      âˆ€h1 h2.
        h1 â‰¤ g âˆ§ h2 â‰¤ g âˆ§ FiniteGroup h1 âˆ§ FiniteGroup h2 â‡’
        FiniteGroup (h1 âˆ˜ h2)
</pre>

<DT><span class="strong">abelian_subgroup_cross_subgroup</span>
<DD>
<pre>
âŠ¢ âˆ€g. AbelianGroup g â‡’ âˆ€h1 h2. h1 â‰¤ g âˆ§ h2 â‰¤ g â‡’ h1 âˆ˜ h2 â‰¤ g
</pre>

<DT><span class="strong">action_closure</span>
<DD>
<pre>
âŠ¢ âˆ€f g X. (g act X) f â‡’ âˆ€a x. a âˆˆ G âˆ§ x âˆˆ X â‡’ f a x âˆˆ X
</pre>

<DT><span class="strong">action_compose</span>
<DD>
<pre>
âŠ¢ âˆ€f g X.
    (g act X) f â‡’ âˆ€a b x. a âˆˆ G âˆ§ b âˆˆ G âˆ§ x âˆˆ X â‡’ f a (f b x) = f (a * b) x
</pre>

<DT><span class="strong">action_id</span>
<DD>
<pre>
âŠ¢ âˆ€f g X. (g act X) f â‡’ âˆ€x. x âˆˆ X â‡’ f #e x = x
</pre>

<DT><span class="strong">action_match_condition</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x.
    Group g âˆ§ (g act X) f âˆ§ x âˆˆ X â‡’
    âˆ€a b. a âˆˆ G âˆ§ b âˆˆ G â‡’ (f a x = f b x â‡” |/ a * b âˆˆ stabilizer f g x)
</pre>

<DT><span class="strong">action_match_condition_alt</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x.
    Group g âˆ§ (g act X) f âˆ§ x âˆˆ X â‡’
    âˆ€a b::G. f a x = f b x â‡” |/ a * b âˆˆ stabilizer f g x
</pre>

<DT><span class="strong">action_reachable_coset</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x y.
    Group g âˆ§ (g act X) f âˆ§ x âˆˆ X âˆ§ y âˆˆ orbit f g x â‡’
    act_by f g x y * stabilizer f g x = {a | a âˆˆ G âˆ§ f a x = y}
</pre>

<DT><span class="strong">action_reachable_coset_alt</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x y.
    Group g âˆ§ (g act X) f âˆ§ x âˆˆ X âˆ§ y âˆˆ orbit f g x â‡’
    âˆ€a. a âˆˆ G âˆ§ f a x = y â‡’ a * stabilizer f g x = {b | b âˆˆ G âˆ§ f b x = y}
</pre>

<DT><span class="strong">action_reverse</span>
<DD>
<pre>
âŠ¢ âˆ€f g X.
    Group g âˆ§ (g act X) f â‡’
    âˆ€a x y. a âˆˆ G âˆ§ x âˆˆ X âˆ§ y âˆˆ X âˆ§ f a x = y â‡’ f ( |/ a) y = x
</pre>

<DT><span class="strong">action_to_orbit_surj</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x. (g act X) f âˆ§ x âˆˆ X â‡’ SURJ (Î»a. f a x) G (orbit f g x)
</pre>

<DT><span class="strong">action_trans</span>
<DD>
<pre>
âŠ¢ âˆ€f g X.
    (g act X) f â‡’
    âˆ€a b x y z.
      a âˆˆ G âˆ§ b âˆˆ G âˆ§ x âˆˆ X âˆ§ y âˆˆ X âˆ§ z âˆˆ X âˆ§ f a x = y âˆ§ f b y = z â‡’
      f (b * a) x = z
</pre>

<DT><span class="strong">add_mod_abelian_group</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ AbelianGroup (add_mod n)
</pre>

<DT><span class="strong">add_mod_card</span>
<DD>
<pre>
âŠ¢ âˆ€n. CARD (add_mod n).carrier = n
</pre>

<DT><span class="strong">add_mod_carrier</span>
<DD>
<pre>
âŠ¢ âˆ€n. (add_mod n).carrier = {i | i < n}
</pre>

<DT><span class="strong">add_mod_carrier_alt</span>
<DD>
<pre>
âŠ¢ âˆ€n. (add_mod n).carrier = count n
</pre>

<DT><span class="strong">add_mod_cylic</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ cyclic (add_mod n)
</pre>

<DT><span class="strong">add_mod_element</span>
<DD>
<pre>
âŠ¢ âˆ€n x. x âˆˆ (add_mod n).carrier â‡” x < n
</pre>

<DT><span class="strong">add_mod_eval</span>
<DD>
<pre>
âŠ¢ âˆ€n. (add_mod n).carrier = {i | i < n} âˆ§
      (âˆ€x y. (add_mod n).op x y = (x + y) MOD n) âˆ§ (add_mod n).id = 0
</pre>

<DT><span class="strong">add_mod_exp</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ âˆ€x m. (add_mod n).exp x m = (x * m) MOD n
</pre>

<DT><span class="strong">add_mod_finite</span>
<DD>
<pre>
âŠ¢ âˆ€n. FINITE (add_mod n).carrier
</pre>

<DT><span class="strong">add_mod_finite_abelian_group</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ FiniteAbelianGroup (add_mod n)
</pre>

<DT><span class="strong">add_mod_finite_group</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ FiniteGroup (add_mod n)
</pre>

<DT><span class="strong">add_mod_group</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ Group (add_mod n)
</pre>

<DT><span class="strong">add_mod_id</span>
<DD>
<pre>
âŠ¢ âˆ€n. (add_mod n).id = 0
</pre>

<DT><span class="strong">add_mod_inv</span>
<DD>
<pre>
âŠ¢ âˆ€n x. 0 < n âˆ§ x < n â‡’ (add_mod n).inv x = (n âˆ’ x) MOD n
</pre>

<DT><span class="strong">add_mod_inv_compute</span>
<DD>
<pre>
âŠ¢ âˆ€n x.
    (add_mod n).inv x =
    if 0 < n âˆ§ x < n then (n âˆ’ x) MOD n
    else FAIL ((add_mod n).inv x) bad_element
</pre>

<DT><span class="strong">add_mod_order_1</span>
<DD>
<pre>
âŠ¢ âˆ€n. 1 < n â‡’ order (add_mod n) 1 = n
</pre>

<DT><span class="strong">add_mod_property</span>
<DD>
<pre>
âŠ¢ âˆ€n. (âˆ€x. x âˆˆ (add_mod n).carrier â‡” x < n) âˆ§ (add_mod n).id = 0 âˆ§
      (âˆ€x y. (add_mod n).op x y = (x + y) MOD n) âˆ§
      FINITE (add_mod n).carrier âˆ§ CARD (add_mod n).carrier = n
</pre>

<DT><span class="strong">all_subgroups_element</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h âˆˆ all_subgroups g â‡” h â‰¤ g
</pre>

<DT><span class="strong">all_subgroups_finite</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteGroup g â‡’ FINITE (all_subgroups g)
</pre>

<DT><span class="strong">all_subgroups_has_gen_id</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ gen #e âˆˆ all_subgroups g
</pre>

<DT><span class="strong">all_subgroups_subset</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ IMAGE (Î»h. H) (all_subgroups g) âŠ† POW G
</pre>

<DT><span class="strong">bij_corres</span>
<DD>
<pre>
âŠ¢ âˆ€f g1 g2 h1 h2.
    Group g1 âˆ§ Group g2 âˆ§ h1 â‰¤ g1 âˆ§ h2 â‰¤ g2 âˆ§ GroupHomo f g1 g2 âˆ§
    SURJ f g1.carrier g2.carrier âˆ§ kernel f g1 g2 âŠ† h1.carrier â‡’
    IMAGE f (PREIMAGE f h2.carrier âˆ© g1.carrier) = h2.carrier âˆ§
    PREIMAGE f (IMAGE f h1.carrier) âˆ© g1.carrier = h1.carrier
</pre>

<DT><span class="strong">carrier_card_by_coset_partition</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g âˆ§ FINITE G â‡’ CARD G = âˆ‘ CARD (CosetPartition g h)
</pre>

<DT><span class="strong">carrier_card_by_subgroup_coset_partition</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g âˆ§ FINITE G â‡’ CARD G = âˆ‘ CARD (partition (left_coset g H) G)
</pre>

<DT><span class="strong">cogen_coset_element</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ âˆ€x. x âˆˆ G â‡’ cogen g h (x * H) âˆˆ G
</pre>

<DT><span class="strong">cogen_element</span>
<DD>
<pre>
âŠ¢ âˆ€h g e. h â‰¤ g âˆ§ e âˆˆ CosetPartition g h â‡’ cogen g h e âˆˆ G
</pre>

<DT><span class="strong">cogen_of_subgroup</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ cogen g h H * H = H
</pre>

<DT><span class="strong">conjugate_subgroup_group</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ âˆ€a. a âˆˆ G â‡’ Group (conjugate_subgroup h g a)
</pre>

<DT><span class="strong">conjugate_subgroup_subgroup</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ âˆ€a::G. conjugate_subgroup h g a â‰¤ g
</pre>

<DT><span class="strong">corres_thm</span>
<DD>
<pre>
âŠ¢ âˆ€f g1 g2 h1 h2.
    Group g1 âˆ§ Group g2 âˆ§ GroupHomo f g1 g2 âˆ§ SURJ f g1.carrier g2.carrier âˆ§
    h1 â‰¤ g1 âˆ§ kernel f g1 g2 âŠ† h1.carrier âˆ§ h2 â‰¤ g2 â‡’
    homo_image f h1 g2 â‰¤ g2 âˆ§ preimage_group f g1 g2 h2.carrier â‰¤ g1 âˆ§
    kernel f g1 g2 âŠ† PREIMAGE f h2.carrier âˆ© g1.carrier âˆ§
    (h2 << g2 â‡” preimage_group f g1 g2 h2.carrier << g1) âˆ§
    IMAGE f (PREIMAGE f h2.carrier âˆ© g1.carrier) = h2.carrier âˆ§
    PREIMAGE f (IMAGE f h1.carrier) âˆ© g1.carrier = h1.carrier âˆ§
    (FiniteGroup g1 â‡’
     CARD (preimage_group f g1 g2 h2.carrier).carrier =
     CARD h2.carrier * CARD (kernel f g1 g2))
</pre>

<DT><span class="strong">coset_alt</span>
<DD>
<pre>
âŠ¢ âˆ€g a X. a * X = {a * z | z âˆˆ X}
</pre>

<DT><span class="strong">coset_cogen_property</span>
<DD>
<pre>
âŠ¢ âˆ€h g e. h â‰¤ g âˆ§ e âˆˆ CosetPartition g h â‡’ e = cogen g h e * H
</pre>

<DT><span class="strong">coset_element</span>
<DD>
<pre>
âŠ¢ âˆ€g X a. a âˆˆ G â‡’ âˆ€x. x âˆˆ a * X â‡” âˆƒy. y âˆˆ X âˆ§ x = a * y
</pre>

<DT><span class="strong">coset_empty</span>
<DD>
<pre>
âŠ¢ âˆ€g a. Group g âˆ§ a âˆˆ G â‡’ a * âˆ… = âˆ…
</pre>

<DT><span class="strong">coset_homo_group_iso_quotient_group</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h << g â‡’ GroupIso I (homo_group g (left_coset g H)) (g / h)
</pre>

<DT><span class="strong">coset_id_eq_subgroup</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ #e * H = H
</pre>

<DT><span class="strong">coset_partition_card</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g âˆ§ FINITE G â‡’ CARD (CosetPartition g h) = CARD G DIV CARD H
</pre>

<DT><span class="strong">coset_partition_element</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ âˆ€e. e âˆˆ CosetPartition g h â‡” âˆƒa. a âˆˆ G âˆ§ e = a * H
</pre>

<DT><span class="strong">coset_partition_element_card</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g âˆ§ FINITE G â‡’ âˆ€e. e âˆˆ CosetPartition g h â‡’ CARD e = CARD H
</pre>

<DT><span class="strong">coset_partition_eq_coset_image</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ CosetPartition g h = IMAGE (left_coset g H) G
</pre>

<DT><span class="strong">coset_property</span>
<DD>
<pre>
âŠ¢ âˆ€g a. Group g âˆ§ a âˆˆ G â‡’ âˆ€X. X âŠ† G â‡’ a * X âŠ† G
</pre>

<DT><span class="strong">count_formula</span>
<DD>
<pre>
âŠ¢ âˆ€g h. FiniteGroup g âˆ§ h << g â‡’ CARD G = CARD H * CARD (g / h).carrier
</pre>

<DT><span class="strong">cyclic_element</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g â‡’ âˆ€x. x âˆˆ G â‡’ âˆƒn. x = cyclic_gen g ** n
</pre>

<DT><span class="strong">cyclic_element_by_gen</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g âˆ§ FINITE G â‡’ âˆ€x. x âˆˆ G â‡’ âˆƒn. n < CARD G âˆ§ x = cyclic_gen g ** n
</pre>

<DT><span class="strong">cyclic_element_in_generated</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g âˆ§ FINITE G â‡’
      âˆ€x. x âˆˆ G â‡’ x âˆˆ Gen (cyclic_gen g ** (CARD G DIV ord x))
</pre>

<DT><span class="strong">cyclic_eq_order_partition</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g âˆ§ FINITE G â‡’
      partition (eq_order g) G = {orders g n | n | n divides CARD G}
</pre>

<DT><span class="strong">cyclic_eq_order_partition_alt</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g âˆ§ FINITE G â‡’
      partition (eq_order g) G = {orders g n | n | n âˆˆ divisors (CARD G)}
</pre>

<DT><span class="strong">cyclic_eq_order_partition_by_card</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g âˆ§ FINITE G â‡’
      IMAGE CARD (partition (eq_order g) G) = IMAGE phi (divisors (CARD G))
</pre>

<DT><span class="strong">cyclic_finite_alt</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteGroup g â‡’ (cyclic g â‡” âˆƒz. z âˆˆ G âˆ§ ord z = CARD G)
</pre>

<DT><span class="strong">cyclic_finite_has_order_divisor</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g âˆ§ FINITE G â‡’ âˆ€n. n divides CARD G â‡’ âˆƒx. x âˆˆ G âˆ§ ord x = n
</pre>

<DT><span class="strong">cyclic_gen_element</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g â‡’ cyclic_gen g âˆˆ G
</pre>

<DT><span class="strong">cyclic_gen_order</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g âˆ§ FINITE G â‡’ ord (cyclic_gen g) = CARD G
</pre>

<DT><span class="strong">cyclic_gen_power_order</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g âˆ§ FINITE G â‡’
      âˆ€n. 0 < n âˆ§ CARD G MOD n = 0 â‡’ ord (cyclic_gen g ** (CARD G DIV n)) = n
</pre>

<DT><span class="strong">cyclic_generated_by_gen</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g â‡’ g = gen (cyclic_gen g)
</pre>

<DT><span class="strong">cyclic_generated_group</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteGroup g â‡’ âˆ€x. x âˆˆ G â‡’ cyclic (gen x)
</pre>

<DT><span class="strong">cyclic_generators_card</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g âˆ§ FINITE G â‡’ CARD (cyclic_generators g) = phi (CARD G)
</pre>

<DT><span class="strong">cyclic_generators_coprimes_bij</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g âˆ§ FINITE G â‡’
      BIJ (Î»j. cyclic_gen g ** j) (coprimes (CARD G)) (cyclic_generators g)
</pre>

<DT><span class="strong">cyclic_generators_element</span>
<DD>
<pre>
âŠ¢ âˆ€g z. z âˆˆ cyclic_generators g â‡” z âˆˆ G âˆ§ ord z = CARD G
</pre>

<DT><span class="strong">cyclic_generators_finite</span>
<DD>
<pre>
âŠ¢ âˆ€g. FINITE G â‡’ FINITE (cyclic_generators g)
</pre>

<DT><span class="strong">cyclic_generators_gen_cofactor_eq_orders</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g âˆ§ FINITE G â‡’
      âˆ€n. n divides CARD G â‡’
          cyclic_generators (gen (cyclic_gen g ** (CARD G DIV n))) =
          orders g n
</pre>

<DT><span class="strong">cyclic_generators_nonempty</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g âˆ§ FINITE G â‡’ cyclic_generators g â‰  âˆ…
</pre>

<DT><span class="strong">cyclic_generators_subset</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic_generators g âŠ† G
</pre>

<DT><span class="strong">cyclic_group</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g â‡’ Group g
</pre>

<DT><span class="strong">cyclic_group_abelian</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g â‡’ AbelianGroup g
</pre>

<DT><span class="strong">cyclic_group_comm</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g â‡’ âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ x * y = y * x
</pre>

<DT><span class="strong">cyclic_image_ord_is_divisors</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g âˆ§ FINITE G â‡’ IMAGE ord G = divisors (CARD G)
</pre>

<DT><span class="strong">cyclic_index_exists</span>
<DD>
<pre>
âŠ¢ âˆ€g x. cyclic g âˆ§ x âˆˆ G â‡’ âˆƒn. x = cyclic_gen g ** n âˆ§ (FINITE G â‡’ n < CARD G)
</pre>

<DT><span class="strong">cyclic_iso_gen</span>
<DD>
<pre>
âŠ¢ âˆ€g h f.
    cyclic g âˆ§ cyclic h âˆ§ FINITE G âˆ§ GroupIso f g h â‡’
    f (cyclic_gen g) âˆˆ cyclic_generators h
</pre>

<DT><span class="strong">cyclic_orders_card</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g âˆ§ FINITE G â‡’
      âˆ€n. CARD (orders g n) = if n divides CARD G then phi n else 0
</pre>

<DT><span class="strong">cyclic_orders_nonempty</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g âˆ§ FINITE G â‡’ âˆ€n. n divides CARD G â‡’ orders g n â‰  âˆ…
</pre>

<DT><span class="strong">cyclic_orders_partition</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g âˆ§ FINITE G â‡’
      partition (eq_order g) G = IMAGE (orders g) (divisors (CARD G))
</pre>

<DT><span class="strong">cyclic_subgroup_condition</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g âˆ§ FINITE G â‡’ âˆ€n. (âˆƒh. h â‰¤ g âˆ§ CARD H = n) â‡” n divides CARD G
</pre>

<DT><span class="strong">cyclic_subgroup_cyclic</span>
<DD>
<pre>
âŠ¢ âˆ€g h. cyclic g âˆ§ h â‰¤ g â‡’ cyclic h
</pre>

<DT><span class="strong">cyclic_uroots_cyclic</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g â‡’ âˆ€n. cyclic (uroots n)
</pre>

<DT><span class="strong">cyclic_uroots_has_primitive</span>
<DD>
<pre>
âŠ¢ âˆ€g. FINITE G âˆ§ cyclic g â‡’
      âˆ€n. âˆƒz. z âˆˆ (uroots n).carrier âˆ§ ord z = CARD (uroots n).carrier
</pre>

<DT><span class="strong">element_coset_property</span>
<DD>
<pre>
âŠ¢ âˆ€g X a. a âˆˆ G â‡’ âˆ€x. x âˆˆ X â‡’ a * x âˆˆ a * X
</pre>

<DT><span class="strong">eq_order_equiv</span>
<DD>
<pre>
âŠ¢ âˆ€g. eq_order g equiv_on G
</pre>

<DT><span class="strong">eq_order_is_feq_order</span>
<DD>
<pre>
âŠ¢ âˆ€g. eq_order g = feq ord
</pre>

<DT><span class="strong">fermat_little</span>
<DD>
<pre>
âŠ¢ âˆ€p a. prime p âˆ§ 0 < a âˆ§ a < p â‡’ a ** (p âˆ’ 1) MOD p = 1
</pre>

<DT><span class="strong">fermat_little_alt</span>
<DD>
<pre>
âŠ¢ âˆ€p a. prime p â‡’ a ** (p âˆ’ 1) MOD p = if a MOD p = 0 then 0 else 1
</pre>

<DT><span class="strong">fermat_little_thm</span>
<DD>
<pre>
âŠ¢ âˆ€p. prime p â‡’ âˆ€a. a ** p MOD p = a MOD p
</pre>

<DT><span class="strong">fermat_roots</span>
<DD>
<pre>
âŠ¢ âˆ€p. prime p â‡’ âˆ€x y z. x ** p + y ** p = z ** p â‡’ (x + y) MOD p = z MOD p
</pre>

<DT><span class="strong">finite_abelian_Fermat</span>
<DD>
<pre>
âŠ¢ âˆ€g a. FiniteAbelianGroup g âˆ§ a âˆˆ G â‡’ a ** CARD G = #e
</pre>

<DT><span class="strong">finite_abelian_group_is_finite_abelian_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteAbelianGroup g â‡’ FiniteAbelianMonoid g
</pre>

<DT><span class="strong">finite_cyclic_group_add_mod_bij</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g âˆ§ FINITE G â‡’
      BIJ (Î»n. cyclic_gen g ** n) (add_mod (CARD G)).carrier G
</pre>

<DT><span class="strong">finite_cyclic_group_add_mod_homo</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g âˆ§ FINITE G â‡’
      GroupHomo (Î»n. cyclic_gen g ** n) (add_mod (CARD G)) g
</pre>

<DT><span class="strong">finite_cyclic_group_add_mod_iso</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g âˆ§ FINITE G â‡’
      GroupIso (Î»n. cyclic_gen g ** n) (add_mod (CARD G)) g
</pre>

<DT><span class="strong">finite_cyclic_group_bij</span>
<DD>
<pre>
âŠ¢ âˆ€g1 g2.
    cyclic g1 âˆ§ cyclic g2 âˆ§ FINITE g1.carrier âˆ§ FINITE g2.carrier âˆ§
    CARD g1.carrier = CARD g2.carrier â‡’
    BIJ (Î»x. g2.exp (cyclic_gen g2) (cyclic_index g1 x)) g1.carrier g2.carrier
</pre>

<DT><span class="strong">finite_cyclic_group_existence</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ âˆƒg. cyclic g âˆ§ CARD g.carrier = n
</pre>

<DT><span class="strong">finite_cyclic_group_homo</span>
<DD>
<pre>
âŠ¢ âˆ€g1 g2.
    cyclic g1 âˆ§ cyclic g2 âˆ§ FINITE g1.carrier âˆ§ FINITE g2.carrier âˆ§
    CARD g1.carrier = CARD g2.carrier â‡’
    GroupHomo (Î»x. g2.exp (cyclic_gen g2) (cyclic_index g1 x)) g1 g2
</pre>

<DT><span class="strong">finite_cyclic_group_iso</span>
<DD>
<pre>
âŠ¢ âˆ€g1 g2.
    cyclic g1 âˆ§ cyclic g2 âˆ§ FINITE g1.carrier âˆ§ FINITE g2.carrier âˆ§
    CARD g1.carrier = CARD g2.carrier â‡’
    GroupIso (Î»x. g2.exp (cyclic_gen g2) (cyclic_index g1 x)) g1 g2
</pre>

<DT><span class="strong">finite_cyclic_group_uniqueness</span>
<DD>
<pre>
âŠ¢ âˆ€g1 g2.
    cyclic g1 âˆ§ cyclic g2 âˆ§ FINITE g1.carrier âˆ§ FINITE g2.carrier âˆ§
    CARD g1.carrier = CARD g2.carrier â‡’
    âˆƒf. GroupIso f g1 g2
</pre>

<DT><span class="strong">finite_cyclic_index_add</span>
<DD>
<pre>
âŠ¢ âˆ€g x y.
    cyclic g âˆ§ FINITE G âˆ§ x âˆˆ G âˆ§ y âˆˆ G â‡’
    cyclic_index g (x * y) = (cyclic_index g x + cyclic_index g y) MOD CARD G
</pre>

<DT><span class="strong">finite_cyclic_index_property</span>
<DD>
<pre>
âŠ¢ âˆ€g. cyclic g âˆ§ FINITE G â‡’
      âˆ€n. n < CARD G â‡’ cyclic_index g (cyclic_gen g ** n) = n
</pre>

<DT><span class="strong">finite_cyclic_index_unique</span>
<DD>
<pre>
âŠ¢ âˆ€g x.
    cyclic g âˆ§ FINITE G âˆ§ x âˆˆ G â‡’
    âˆ€n. n < CARD G â‡’ (x = cyclic_gen g ** n â‡” n = cyclic_index g x)
</pre>

<DT><span class="strong">finite_group_Fermat</span>
<DD>
<pre>
âŠ¢ âˆ€g a. FiniteGroup g âˆ§ a âˆˆ G â‡’ a ** CARD G = #e
</pre>

<DT><span class="strong">finite_group_card_pos</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteGroup g â‡’ 0 < CARD G
</pre>

<DT><span class="strong">finite_group_exp_not_distinct</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteGroup g â‡’ âˆ€x. x âˆˆ G â‡’ âˆƒh k. x ** h = x ** k âˆ§ h â‰  k
</pre>

<DT><span class="strong">finite_group_exp_period_exists</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteGroup g â‡’ âˆ€x. x âˆˆ G â‡’ âˆƒk. 0 < k âˆ§ x ** k = #e
</pre>

<DT><span class="strong">finite_group_is_finite_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteGroup g â‡’ FiniteMonoid g
</pre>

<DT><span class="strong">finite_group_is_group</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteGroup g â‡’ Group g
</pre>

<DT><span class="strong">finite_group_is_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteGroup g â‡’ Monoid g
</pre>

<DT><span class="strong">finite_group_order</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteGroup g â‡’
      âˆ€x. x âˆˆ G â‡’
          âˆ€n. ord x = n â‡’
              0 < n âˆ§ x ** n = #e âˆ§ âˆ€m. 0 < m âˆ§ m < n â‡’ x ** m â‰  #e
</pre>

<DT><span class="strong">finite_group_primitive_property</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteGroup g â‡’
      âˆ€z. z âˆˆ G âˆ§ ord z = CARD G â‡’ âˆ€x. x âˆˆ G â‡’ âˆƒn. n < CARD G âˆ§ x = z ** n
</pre>

<DT><span class="strong">finite_homo_image</span>
<DD>
<pre>
âŠ¢ âˆ€f g1 g2 h.
    FiniteGroup g1 âˆ§ Group g2 âˆ§ h â‰¤ g2 âˆ§ GroupHomo f g1 g2 â‡’
    FINITE (homo_image f (preimage_group f g1 g2 h.carrier) g2).carrier
</pre>

<DT><span class="strong">finite_monoid_invertibles_is_finite_group</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteMonoid g â‡’ FiniteGroup (Invertibles g)
</pre>

<DT><span class="strong">finite_subgroup_carrier_finite</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteGroup g â‡’ âˆ€h. h â‰¤ g â‡’ FINITE H
</pre>

<DT><span class="strong">finite_subgroup_finite_group</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteGroup g â‡’ âˆ€h. h â‰¤ g â‡’ FiniteGroup h
</pre>

<DT><span class="strong">fixed_points_element</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x. x âˆˆ fixed_points f g X â‡” x âˆˆ X âˆ§ âˆ€a. a âˆˆ G â‡’ f a x = x
</pre>

<DT><span class="strong">fixed_points_element_element</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x. x âˆˆ fixed_points f g X â‡’ x âˆˆ X
</pre>

<DT><span class="strong">fixed_points_finite</span>
<DD>
<pre>
âŠ¢ âˆ€f g X. FINITE X â‡’ FINITE (fixed_points f g X)
</pre>

<DT><span class="strong">fixed_points_orbit_iff_sing</span>
<DD>
<pre>
âŠ¢ âˆ€f g X.
    Group g âˆ§ (g act X) f â‡’
    âˆ€x. x âˆˆ X â‡’ (x âˆˆ fixed_points f g X â‡” SING (orbit f g x))
</pre>

<DT><span class="strong">fixed_points_orbit_sing</span>
<DD>
<pre>
âŠ¢ âˆ€f g X.
    Group g âˆ§ (g act X) f â‡’
    âˆ€x. x âˆˆ fixed_points f g X â‡” x âˆˆ X âˆ§ orbit f g x = {x}
</pre>

<DT><span class="strong">fixed_points_subset</span>
<DD>
<pre>
âŠ¢ âˆ€f g X. fixed_points f g X âŠ† X
</pre>

<DT><span class="strong">fn_cyclic_group_alt</span>
<DD>
<pre>
âŠ¢ âˆ€e f n.
    (âˆƒk. k â‰  0 âˆ§ FUNPOW f k e = e) âˆ§ n = (LEAST k. k â‰  0 âˆ§ FUNPOW f k e = e) â‡’
    (fn_cyclic_group e f).carrier = {FUNPOW f k e | k < n} âˆ§
    (fn_cyclic_group e f).id = e âˆ§
    âˆ€i j.
      (fn_cyclic_group e f).op (FUNPOW f i e) (FUNPOW f j e) =
      FUNPOW f ((i + j) MOD n) e
</pre>

<DT><span class="strong">fn_cyclic_group_carrier</span>
<DD>
<pre>
âŠ¢ âˆ€e f. (fn_cyclic_group e f).carrier = {x | âˆƒn. FUNPOW f n e = x}
</pre>

<DT><span class="strong">fn_cyclic_group_finite_abelian_group</span>
<DD>
<pre>
âŠ¢ âˆ€e f.
    (âˆƒn. n â‰  0 âˆ§ FUNPOW f n e = e) â‡’ FiniteAbelianGroup (fn_cyclic_group e f)
</pre>

<DT><span class="strong">fn_cyclic_group_finite_group</span>
<DD>
<pre>
âŠ¢ âˆ€e f. (âˆƒn. n â‰  0 âˆ§ FUNPOW f n e = e) â‡’ FiniteGroup (fn_cyclic_group e f)
</pre>

<DT><span class="strong">fn_cyclic_group_group</span>
<DD>
<pre>
âŠ¢ âˆ€e f. (âˆƒn. n â‰  0 âˆ§ FUNPOW f n e = e) â‡’ Group (fn_cyclic_group e f)
</pre>

<DT><span class="strong">fn_cyclic_group_id</span>
<DD>
<pre>
âŠ¢ âˆ€e f. (fn_cyclic_group e f).id = e
</pre>

<DT><span class="strong">generated_Fermat</span>
<DD>
<pre>
âŠ¢ âˆ€g a. FiniteGroup g âˆ§ a âˆˆ G â‡’ âˆ€x. x âˆˆ Gen a â‡’ x ** CARD (Gen a) = #e
</pre>

<DT><span class="strong">generated_carrier</span>
<DD>
<pre>
âŠ¢ âˆ€g a. a âˆˆ G â‡’ Gen a = IMAGE ($** a) ð•Œ(:num)
</pre>

<DT><span class="strong">generated_carrier_as_image</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’
      âˆ€a. a âˆˆ G âˆ§ 0 < ord a â‡’ Gen a = IMAGE (Î»j. a ** j) (count (ord a))
</pre>

<DT><span class="strong">generated_carrier_has_id</span>
<DD>
<pre>
âŠ¢ âˆ€g a. #e âˆˆ Gen a
</pre>

<DT><span class="strong">generated_element</span>
<DD>
<pre>
âŠ¢ âˆ€g a x. x âˆˆ Gen a â‡” âˆƒn. x = a ** n
</pre>

<DT><span class="strong">generated_exp</span>
<DD>
<pre>
âŠ¢ âˆ€g a z. a âˆˆ G âˆ§ z âˆˆ Gen a â‡’ âˆ€n. (gen a).exp z n = z ** n
</pre>

<DT><span class="strong">generated_finite_group</span>
<DD>
<pre>
âŠ¢ âˆ€g a. FiniteGroup g âˆ§ a âˆˆ G â‡’ FiniteGroup (gen a)
</pre>

<DT><span class="strong">generated_gen_element</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G â‡’ x âˆˆ Gen x
</pre>

<DT><span class="strong">generated_group</span>
<DD>
<pre>
âŠ¢ âˆ€g a. FiniteGroup g âˆ§ a âˆˆ G â‡’ Group (gen a)
</pre>

<DT><span class="strong">generated_group_card</span>
<DD>
<pre>
âŠ¢ âˆ€g a. Group g âˆ§ a âˆˆ G âˆ§ 0 < ord a â‡’ CARD (Gen a) = ord a
</pre>

<DT><span class="strong">generated_group_finite</span>
<DD>
<pre>
âŠ¢ âˆ€g a. FiniteGroup g âˆ§ a âˆˆ G â‡’ FINITE (Gen a)
</pre>

<DT><span class="strong">generated_id_carrier</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ Gen #e = {#e}
</pre>

<DT><span class="strong">generated_id_subgroup</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ gen #e â‰¤ g
</pre>

<DT><span class="strong">generated_image_subset_all_subgroups</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteGroup g â‡’ âˆ€s. s âŠ† G â‡’ IMAGE gen s âŠ† all_subgroups g
</pre>

<DT><span class="strong">generated_image_subset_power_set</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€s. s âŠ† G â‡’ IMAGE (Î»a. Gen a) s âŠ† POW G
</pre>

<DT><span class="strong">generated_property</span>
<DD>
<pre>
âŠ¢ âˆ€g a. (gen a).op = $* âˆ§ (gen a).id = #e
</pre>

<DT><span class="strong">generated_subgroup</span>
<DD>
<pre>
âŠ¢ âˆ€g a. FiniteGroup g âˆ§ a âˆˆ G â‡’ gen a â‰¤ g
</pre>

<DT><span class="strong">generated_subset</span>
<DD>
<pre>
âŠ¢ âˆ€g a. Group g âˆ§ a âˆˆ G â‡’ Gen a âŠ† G
</pre>

<DT><span class="strong">group_all_invertible</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ G* = G
</pre>

<DT><span class="strong">group_alt</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡”
      (âˆ€x y::G. x * y âˆˆ G) âˆ§ (âˆ€x y z::G. x * y * z = x * (y * z)) âˆ§ #e âˆˆ G âˆ§
      (âˆ€x::G. #e * x = x) âˆ§ âˆ€x::G. |/ x âˆˆ G âˆ§ |/ x * x = #e
</pre>

<DT><span class="strong">group_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x y z. x âˆˆ G âˆ§ y âˆˆ G âˆ§ z âˆˆ G â‡’ x * y * z = x * (y * z)
</pre>

<DT><span class="strong">group_auto_I</span>
<DD>
<pre>
âŠ¢ âˆ€g. GroupAuto I g
</pre>

<DT><span class="strong">group_auto_bij</span>
<DD>
<pre>
âŠ¢ âˆ€g f. GroupAuto f g â‡’ f PERMUTES G
</pre>

<DT><span class="strong">group_auto_compose</span>
<DD>
<pre>
âŠ¢ âˆ€g f1 f2. GroupAuto f1 g âˆ§ GroupAuto f2 g â‡’ GroupAuto (f1 âˆ˜ f2) g
</pre>

<DT><span class="strong">group_auto_element</span>
<DD>
<pre>
âŠ¢ âˆ€f g. GroupAuto f g â‡’ âˆ€x. x âˆˆ G â‡’ f x âˆˆ G
</pre>

<DT><span class="strong">group_auto_exp</span>
<DD>
<pre>
âŠ¢ âˆ€g f. Group g âˆ§ GroupAuto f g â‡’ âˆ€x. x âˆˆ G â‡’ âˆ€n. f (x ** n) = f x ** n
</pre>

<DT><span class="strong">group_auto_id</span>
<DD>
<pre>
âŠ¢ âˆ€f g. Group g âˆ§ GroupAuto f g â‡’ f #e = #e
</pre>

<DT><span class="strong">group_auto_is_monoid_auto</span>
<DD>
<pre>
âŠ¢ âˆ€g f. Group g âˆ§ GroupAuto f g â‡’ MonoidAuto f g
</pre>

<DT><span class="strong">group_auto_linv_auto</span>
<DD>
<pre>
âŠ¢ âˆ€g f. Group g âˆ§ GroupAuto f g â‡’ GroupAuto (LINV f G) g
</pre>

<DT><span class="strong">group_auto_order</span>
<DD>
<pre>
âŠ¢ âˆ€g f. Group g âˆ§ GroupAuto f g â‡’ âˆ€x. x âˆˆ G â‡’ ord (f x) = ord x
</pre>

<DT><span class="strong">group_carrier_nonempty</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ G â‰  âˆ…
</pre>

<DT><span class="strong">group_comm_exp</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’
      âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ x * y = y * x â‡’ âˆ€n. x ** n * y = y * x ** n
</pre>

<DT><span class="strong">group_comm_exp_exp</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’
      âˆ€x y.
        x âˆˆ G âˆ§ y âˆˆ G âˆ§ x * y = y * x â‡’
        âˆ€n m. x ** n * y ** m = y ** m * x ** n
</pre>

<DT><span class="strong">group_comm_op_exp</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’
      âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G âˆ§ x * y = y * x â‡’ âˆ€n. (x * y) ** n = x ** n * y ** n
</pre>

<DT><span class="strong">group_coset_eq_itself</span>
<DD>
<pre>
âŠ¢ âˆ€g a. Group g âˆ§ a âˆˆ G â‡’ a * G = G
</pre>

<DT><span class="strong">group_coset_is_permutation</span>
<DD>
<pre>
âŠ¢ âˆ€g a. Group g âˆ§ a âˆˆ G â‡’ a * G = G
</pre>

<DT><span class="strong">group_def_alt</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡”
      (âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ x * y âˆˆ G) âˆ§
      (âˆ€x y z. x âˆˆ G âˆ§ y âˆˆ G âˆ§ z âˆˆ G â‡’ x * y * z = x * (y * z)) âˆ§ #e âˆˆ G âˆ§
      (âˆ€x. x âˆˆ G â‡’ #e * x = x) âˆ§ âˆ€x. x âˆˆ G â‡’ âˆƒy. y âˆˆ G âˆ§ y * x = #e
</pre>

<DT><span class="strong">group_def_by_inverse</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡” Monoid g âˆ§ âˆ€x. x âˆˆ G â‡’ âˆƒy. y âˆˆ G âˆ§ y * x = #e
</pre>

<DT><span class="strong">group_div_cancel</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G â‡’ x / x = #e
</pre>

<DT><span class="strong">group_div_element</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ x / y âˆˆ G
</pre>

<DT><span class="strong">group_div_lsame</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’
      âˆ€x y z. x âˆˆ G âˆ§ y âˆˆ G âˆ§ z âˆˆ G â‡’ z * x / (z * y) = z * (x / y) / z
</pre>

<DT><span class="strong">group_div_pair</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’
      âˆ€x1 y1 x2 y2.
        x1 âˆˆ G âˆ§ y1 âˆˆ G âˆ§ x2 âˆˆ G âˆ§ y2 âˆˆ G â‡’
        x1 * y1 / (x2 * y2) = x1 * (y1 / y2) / x1 * (x1 / x2)
</pre>

<DT><span class="strong">group_div_rsame</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x y z. x âˆˆ G âˆ§ y âˆˆ G âˆ§ z âˆˆ G â‡’ x * z / (y * z) = x / y
</pre>

<DT><span class="strong">group_excluding_exp</span>
<DD>
<pre>
âŠ¢ âˆ€g z x n. (g excluding z).exp x n = x ** n
</pre>

<DT><span class="strong">group_excluding_op</span>
<DD>
<pre>
âŠ¢ âˆ€g z. (g excluding z).op = $*
</pre>

<DT><span class="strong">group_excluding_property</span>
<DD>
<pre>
âŠ¢ âˆ€g z.
    (g excluding z).op = $* âˆ§ (g excluding z).id = #e âˆ§
    âˆ€x. x âˆˆ (g excluding z).carrier â‡’ x âˆˆ G âˆ§ x â‰  z
</pre>

<DT><span class="strong">group_exp_0</span>
<DD>
<pre>
âŠ¢ âˆ€g x. x ** 0 = #e
</pre>

<DT><span class="strong">group_exp_1</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G â‡’ x ** 1 = x
</pre>

<DT><span class="strong">group_exp_SUC</span>
<DD>
<pre>
âŠ¢ âˆ€g x n. x ** SUC n = x * x ** n
</pre>

<DT><span class="strong">group_exp_add</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G â‡’ âˆ€n k. x ** (n + k) = x ** n * x ** k
</pre>

<DT><span class="strong">group_exp_comm</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G â‡’ âˆ€n. x ** n * x = x * x ** n
</pre>

<DT><span class="strong">group_exp_element</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G â‡’ âˆ€n. x ** n âˆˆ G
</pre>

<DT><span class="strong">group_exp_eq</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G â‡’ âˆ€m n. m < n âˆ§ x ** m = x ** n â‡’ x ** (n âˆ’ m) = #e
</pre>

<DT><span class="strong">group_exp_eq_condition</span>
<DD>
<pre>
âŠ¢ âˆ€g x.
    Group g âˆ§ x âˆˆ G âˆ§ 0 < ord x â‡’
    âˆ€n m. x ** n = x ** m â‡” n MOD ord x = m MOD ord x
</pre>

<DT><span class="strong">group_exp_equal</span>
<DD>
<pre>
âŠ¢ âˆ€g x.
    Group g âˆ§ x âˆˆ G â‡’ âˆ€n m. n < ord x âˆ§ m < ord x âˆ§ x ** n = x ** m â‡’ n = m
</pre>

<DT><span class="strong">group_exp_inv</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G â‡’ âˆ€n. |/ (x ** n) = |/ x ** n
</pre>

<DT><span class="strong">group_exp_mod</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G âˆ§ 0 < ord x â‡’ âˆ€n. x ** n = x ** (n MOD ord x)
</pre>

<DT><span class="strong">group_exp_mod_order</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G âˆ§ 0 < ord x â‡’ âˆ€n. x ** n = x ** (n MOD ord x)
</pre>

<DT><span class="strong">group_exp_mult</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G â‡’ âˆ€n k. x ** (n * k) = (x ** n) ** k
</pre>

<DT><span class="strong">group_exp_mult_comm</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G â‡’ âˆ€m n. (x ** m) ** n = (x ** n) ** m
</pre>

<DT><span class="strong">group_exp_suc</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G â‡’ âˆ€n. x ** SUC n = x ** n * x
</pre>

<DT><span class="strong">group_first_isomorphism_thm</span>
<DD>
<pre>
âŠ¢ âˆ€g h f.
    Group g âˆ§ Group h âˆ§ GroupHomo f g h â‡’
    kernel_group f g h << g âˆ§ homo_image f g h â‰¤ h âˆ§
    GroupIso (Î»z. CHOICE (preimage f G z) * kernel f g h) (homo_image f g h)
      (g / kernel_group f g h) âˆ§
    (SURJ f G h.carrier â‡’ GroupIso I h (homo_image f g h))
</pre>

<DT><span class="strong">group_homo_I_refl</span>
<DD>
<pre>
âŠ¢ âˆ€g. GroupHomo I g g
</pre>

<DT><span class="strong">group_homo_compose</span>
<DD>
<pre>
âŠ¢ âˆ€g h k f1 f2. GroupHomo f1 g h âˆ§ GroupHomo f2 h k â‡’ GroupHomo (f2 âˆ˜ f1) g k
</pre>

<DT><span class="strong">group_homo_cong</span>
<DD>
<pre>
âŠ¢ âˆ€g h f1 f2.
    Group g âˆ§ Group h âˆ§ (âˆ€x. x âˆˆ G â‡’ f1 x = f2 x) â‡’
    (GroupHomo f1 g h â‡” GroupHomo f2 g h)
</pre>

<DT><span class="strong">group_homo_element</span>
<DD>
<pre>
âŠ¢ âˆ€f g h. GroupHomo f g h â‡’ âˆ€x. x âˆˆ G â‡’ f x âˆˆ h.carrier
</pre>

<DT><span class="strong">group_homo_exp</span>
<DD>
<pre>
âŠ¢ âˆ€g h f.
    Group g âˆ§ Group h âˆ§ GroupHomo f g h â‡’
    âˆ€x. x âˆˆ G â‡’ âˆ€n. f (x ** n) = h.exp (f x) n
</pre>

<DT><span class="strong">group_homo_homo_image_group</span>
<DD>
<pre>
âŠ¢ âˆ€g h f. Group g âˆ§ MonoidHomo f g h â‡’ Group (homo_image f g h)
</pre>

<DT><span class="strong">group_homo_id</span>
<DD>
<pre>
âŠ¢ âˆ€f g h. Group g âˆ§ Group h âˆ§ GroupHomo f g h â‡’ f #e = h.id
</pre>

<DT><span class="strong">group_homo_image_surj_property</span>
<DD>
<pre>
âŠ¢ âˆ€g h f.
    Group g âˆ§ Group h âˆ§ SURJ f G h.carrier â‡’ GroupIso I h (homo_image f g h)
</pre>

<DT><span class="strong">group_homo_inv</span>
<DD>
<pre>
âŠ¢ âˆ€f g h.
    Group g âˆ§ Group h âˆ§ GroupHomo f g h â‡’ âˆ€x. x âˆˆ G â‡’ f ( |/ x) = h.inv (f x)
</pre>

<DT><span class="strong">group_homo_is_monoid_homo</span>
<DD>
<pre>
âŠ¢ âˆ€g h f. Group g âˆ§ Group h âˆ§ GroupHomo f g h â‡’ MonoidHomo f g h
</pre>

<DT><span class="strong">group_homo_monoid_homo</span>
<DD>
<pre>
âŠ¢ âˆ€f g h. GroupHomo f g h âˆ§ f #e = h.id â‡” MonoidHomo f g h
</pre>

<DT><span class="strong">group_homo_sym</span>
<DD>
<pre>
âŠ¢ âˆ€g h f.
    Group g âˆ§ GroupHomo f g h âˆ§ BIJ f G h.carrier â‡’ GroupHomo (LINV f G) h g
</pre>

<DT><span class="strong">group_homo_sym_any</span>
<DD>
<pre>
âŠ¢ Group g âˆ§ GroupHomo f g h âˆ§ (âˆ€x. x âˆˆ h.carrier â‡’ i x âˆˆ G âˆ§ f (i x) = x) âˆ§
  (âˆ€x. x âˆˆ G â‡’ i (f x) = x) â‡’
  GroupHomo i h g
</pre>

<DT><span class="strong">group_homo_trans</span>
<DD>
<pre>
âŠ¢ âˆ€g h k f1 f2. GroupHomo f1 g h âˆ§ GroupHomo f2 h k â‡’ GroupHomo (f2 âˆ˜ f1) g k
</pre>

<DT><span class="strong">group_id</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G â‡’ #e * x = x âˆ§ x * #e = x
</pre>

<DT><span class="strong">group_id_element</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ #e âˆˆ G
</pre>

<DT><span class="strong">group_id_exp</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€n. #e ** n = #e
</pre>

<DT><span class="strong">group_id_fix</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G â‡’ (x * x = x â‡” x = #e)
</pre>

<DT><span class="strong">group_id_id</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ #e * #e = #e
</pre>

<DT><span class="strong">group_id_unique</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’
      âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ (y * x = x â‡” y = #e) âˆ§ (x * y = x â‡” y = #e)
</pre>

<DT><span class="strong">group_image_as_op_image</span>
<DD>
<pre>
âŠ¢ âˆ€g. GROUP_IMAGE g = OP_IMAGE $* #e
</pre>

<DT><span class="strong">group_image_empty</span>
<DD>
<pre>
âŠ¢ âˆ€g f. GROUP_IMAGE g f âˆ… = #e
</pre>

<DT><span class="strong">group_image_sing</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ âˆ€f. group_fun g f â‡’ âˆ€x. x âˆˆ G â‡’ GROUP_IMAGE g f {x} = f x
</pre>

<DT><span class="strong">group_including_excluding_abelian</span>
<DD>
<pre>
âŠ¢ âˆ€g z. z âˆ‰ G â‡’ (AbelianGroup g â‡” AbelianGroup (g including z excluding z))
</pre>

<DT><span class="strong">group_including_excluding_eqn</span>
<DD>
<pre>
âŠ¢ âˆ€g z.
    g including z excluding z =
    if z âˆˆ G then <|carrier := G DELETE z; op := $*; id := #e|> else g
</pre>

<DT><span class="strong">group_including_excluding_group</span>
<DD>
<pre>
âŠ¢ âˆ€g z. z âˆ‰ G â‡’ (Group g â‡” Group (g including z excluding z))
</pre>

<DT><span class="strong">group_including_excluding_property</span>
<DD>
<pre>
âŠ¢ âˆ€g z.
    (g including z excluding z).op = $* âˆ§
    (g including z excluding z).id = #e âˆ§
    (z âˆ‰ G â‡’ (g including z excluding z).carrier = G)
</pre>

<DT><span class="strong">group_including_property</span>
<DD>
<pre>
âŠ¢ âˆ€g z.
    (g including z).op = $* âˆ§ (g including z).id = #e âˆ§
    âˆ€x. x âˆˆ (g including z).carrier â‡’ x âˆˆ G âˆ¨ x = z
</pre>

<DT><span class="strong">group_inj_image_abelian_group</span>
<DD>
<pre>
âŠ¢ âˆ€g f. AbelianGroup g âˆ§ INJ f G ð•Œ(:Î²) â‡’ AbelianGroup (monoid_inj_image g f)
</pre>

<DT><span class="strong">group_inj_image_excluding_abelian_group</span>
<DD>
<pre>
âŠ¢ âˆ€g f e.
    AbelianGroup (g excluding e) âˆ§ INJ f G ð•Œ(:Î²) âˆ§ e âˆˆ G â‡’
    AbelianGroup (monoid_inj_image g f excluding f e)
</pre>

<DT><span class="strong">group_inj_image_excluding_group</span>
<DD>
<pre>
âŠ¢ âˆ€g f e.
    Group (g excluding e) âˆ§ INJ f G ð•Œ(:Î²) âˆ§ e âˆˆ G â‡’
    Group (monoid_inj_image g f excluding f e)
</pre>

<DT><span class="strong">group_inj_image_group</span>
<DD>
<pre>
âŠ¢ âˆ€g f. Group g âˆ§ INJ f G ð•Œ(:Î²) â‡’ Group (monoid_inj_image g f)
</pre>

<DT><span class="strong">group_inj_image_group_homo</span>
<DD>
<pre>
âŠ¢ âˆ€g f. INJ f G ð•Œ(:Î²) â‡’ GroupHomo f g (monoid_inj_image g f)
</pre>

<DT><span class="strong">group_inv_element</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G â‡’ |/ x âˆˆ G
</pre>

<DT><span class="strong">group_inv_eq</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ ( |/ x = |/ y â‡” x = y)
</pre>

<DT><span class="strong">group_inv_eq_id</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G â‡’ ( |/ x = #e â‡” x = #e)
</pre>

<DT><span class="strong">group_inv_eq_swap</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ ( |/ x = y â‡” x = |/ y)
</pre>

<DT><span class="strong">group_inv_exp</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G â‡’ âˆ€n. |/ x ** n = |/ (x ** n)
</pre>

<DT><span class="strong">group_inv_id</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ |/ #e = #e
</pre>

<DT><span class="strong">group_inv_inv</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G â‡’ |/ ( |/ x) = x
</pre>

<DT><span class="strong">group_inv_op</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ |/ (x * y) = |/ y * |/ x
</pre>

<DT><span class="strong">group_inv_order</span>
<DD>
<pre>
âŠ¢ âˆ€g x. Group g âˆ§ x âˆˆ G â‡’ ord ( |/ x) = ord x
</pre>

<DT><span class="strong">group_inv_thm</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G â‡’ x * |/ x = #e âˆ§ |/ x * x = #e
</pre>

<DT><span class="strong">group_is_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ Monoid g
</pre>

<DT><span class="strong">group_iso_I_refl</span>
<DD>
<pre>
âŠ¢ âˆ€g. GroupIso I g g
</pre>

<DT><span class="strong">group_iso_bij</span>
<DD>
<pre>
âŠ¢ âˆ€g h f. GroupIso f g h â‡’ BIJ f G h.carrier
</pre>

<DT><span class="strong">group_iso_card_eq</span>
<DD>
<pre>
âŠ¢ âˆ€g h f. GroupIso f g h âˆ§ FINITE G â‡’ CARD G = CARD h.carrier
</pre>

<DT><span class="strong">group_iso_compose</span>
<DD>
<pre>
âŠ¢ âˆ€g h k f1 f2. GroupIso f1 g h âˆ§ GroupIso f2 h k â‡’ GroupIso (f2 âˆ˜ f1) g k
</pre>

<DT><span class="strong">group_iso_element</span>
<DD>
<pre>
âŠ¢ âˆ€f g h. GroupIso f g h â‡’ âˆ€x. x âˆˆ G â‡’ f x âˆˆ h.carrier
</pre>

<DT><span class="strong">group_iso_exp</span>
<DD>
<pre>
âŠ¢ âˆ€g h f.
    Group g âˆ§ Group h âˆ§ GroupIso f g h â‡’
    âˆ€x. x âˆˆ G â‡’ âˆ€n. f (x ** n) = h.exp (f x) n
</pre>

<DT><span class="strong">group_iso_group</span>
<DD>
<pre>
âŠ¢ âˆ€g h f. Group g âˆ§ GroupIso f g h âˆ§ f #e = h.id â‡’ Group h
</pre>

<DT><span class="strong">group_iso_id</span>
<DD>
<pre>
âŠ¢ âˆ€f g h. Group g âˆ§ Group h âˆ§ GroupIso f g h â‡’ f #e = h.id
</pre>

<DT><span class="strong">group_iso_is_monoid_iso</span>
<DD>
<pre>
âŠ¢ âˆ€g h f. Group g âˆ§ Group h âˆ§ GroupIso f g h â‡’ MonoidIso f g h
</pre>

<DT><span class="strong">group_iso_linv_iso</span>
<DD>
<pre>
âŠ¢ âˆ€g h f. Group g âˆ§ GroupIso f g h â‡’ GroupIso (LINV f G) h g
</pre>

<DT><span class="strong">group_iso_monoid_iso</span>
<DD>
<pre>
âŠ¢ âˆ€f g h. GroupIso f g h âˆ§ f #e = h.id â‡” MonoidIso f g h
</pre>

<DT><span class="strong">group_iso_order</span>
<DD>
<pre>
âŠ¢ âˆ€g h f.
    Group g âˆ§ Group h âˆ§ GroupIso f g h â‡’ âˆ€x. x âˆˆ G â‡’ order h (f x) = ord x
</pre>

<DT><span class="strong">group_iso_property</span>
<DD>
<pre>
âŠ¢ âˆ€f g h.
    GroupIso f g h â‡”
    GroupHomo f g h âˆ§ âˆ€y. y âˆˆ h.carrier â‡’ âˆƒ!x. x âˆˆ G âˆ§ f x = y
</pre>

<DT><span class="strong">group_iso_sym</span>
<DD>
<pre>
âŠ¢ âˆ€g h f. Group g âˆ§ GroupIso f g h â‡’ GroupIso (LINV f G) h g
</pre>

<DT><span class="strong">group_iso_trans</span>
<DD>
<pre>
âŠ¢ âˆ€g h k f1 f2. GroupIso f1 g h âˆ§ GroupIso f2 h k â‡’ GroupIso (f2 âˆ˜ f1) g k
</pre>

<DT><span class="strong">group_lcancel</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x y z. x âˆˆ G âˆ§ y âˆˆ G âˆ§ z âˆˆ G â‡’ (x * y = x * z â‡” y = z)
</pre>

<DT><span class="strong">group_lid</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G â‡’ #e * x = x
</pre>

<DT><span class="strong">group_lid_unique</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ (y * x = x â‡” y = #e)
</pre>

<DT><span class="strong">group_linv</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G â‡’ |/ x * x = #e
</pre>

<DT><span class="strong">group_linv_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ y = x * ( |/ x * y) âˆ§ y = |/ x * (x * y)
</pre>

<DT><span class="strong">group_linv_unique</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ (x * y = #e â‡” x = |/ y)
</pre>

<DT><span class="strong">group_lsolve</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x y z. x âˆˆ G âˆ§ y âˆˆ G âˆ§ z âˆˆ G â‡’ (x * y = z â‡” x = z * |/ y)
</pre>

<DT><span class="strong">group_normal_equiv</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h << g â‡’ $== equiv_on G
</pre>

<DT><span class="strong">group_normal_equiv_property</span>
<DD>
<pre>
âŠ¢ âˆ€h g. h << g â‡’ âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ (x == y â‡” x âˆˆ y * H)
</pre>

<DT><span class="strong">group_normal_equiv_reflexive</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h << g â‡’ âˆ€z. z âˆˆ G â‡’ z == z
</pre>

<DT><span class="strong">group_normal_equiv_symmetric</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h << g â‡’ âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ (x == y â‡” y == x)
</pre>

<DT><span class="strong">group_normal_equiv_transitive</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h << g â‡’ âˆ€x y z. x âˆˆ G âˆ§ y âˆˆ G âˆ§ z âˆˆ G â‡’ x == y âˆ§ y == z â‡’ x == z
</pre>

<DT><span class="strong">group_op_element</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ x * y âˆˆ G
</pre>

<DT><span class="strong">group_op_linv_eq_id</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ ( |/ x * y = #e â‡” x = y)
</pre>

<DT><span class="strong">group_op_linv_eqn</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x y z. x âˆˆ G âˆ§ y âˆˆ G âˆ§ z âˆˆ G â‡’ ( |/ x * y = z â‡” y = x * z)
</pre>

<DT><span class="strong">group_op_rinv_eq_id</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ (x * |/ y = #e â‡” x = y)
</pre>

<DT><span class="strong">group_op_rinv_eqn</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x y z. x âˆˆ G âˆ§ y âˆˆ G âˆ§ z âˆˆ G â‡’ (x * |/ y = z â‡” x = z * y)
</pre>

<DT><span class="strong">group_order_cofactor</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’
      âˆ€x n. x âˆˆ G âˆ§ 0 < ord x âˆ§ n divides ord x â‡’ ord (x ** (ord x DIV n)) = n
</pre>

<DT><span class="strong">group_order_common</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’
      âˆ€x y.
        x âˆˆ G âˆ§ y âˆˆ G âˆ§ x * y = y * x â‡’
        âˆƒz. z âˆˆ G âˆ§ ord z * gcd (ord x) (ord y) = lcm (ord x) (ord y)
</pre>

<DT><span class="strong">group_order_common_coprime</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’
      âˆ€x y.
        x âˆˆ G âˆ§ y âˆˆ G âˆ§ x * y = y * x âˆ§ coprime (ord x) (ord y) â‡’
        âˆƒz. z âˆˆ G âˆ§ ord z = ord x * ord y
</pre>

<DT><span class="strong">group_order_condition</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G â‡’ âˆ€m. x ** m = #e â‡” ord x divides m
</pre>

<DT><span class="strong">group_order_divides</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteGroup g â‡’ âˆ€x. x âˆˆ G â‡’ ord x divides CARD G
</pre>

<DT><span class="strong">group_order_divides_exp</span>
<DD>
<pre>
âŠ¢ âˆ€g x. Group g âˆ§ x âˆˆ G â‡’ âˆ€n. x ** n = #e â‡” ord x divides n
</pre>

<DT><span class="strong">group_order_divides_maximal</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteAbelianGroup g â‡’ âˆ€x. x âˆˆ G â‡’ ord x divides maximal_order g
</pre>

<DT><span class="strong">group_order_divisor</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’
      âˆ€x m. x âˆˆ G âˆ§ 0 < ord x âˆ§ m divides ord x â‡’ âˆƒy. y âˆˆ G âˆ§ ord y = m
</pre>

<DT><span class="strong">group_order_eq_1</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G â‡’ (ord x = 1 â‡” x = #e)
</pre>

<DT><span class="strong">group_order_exp_cofactor</span>
<DD>
<pre>
âŠ¢ âˆ€g x n.
    Group g âˆ§ x âˆˆ G âˆ§ 0 < ord x âˆ§ n divides ord x â‡’
    ord (x ** (ord x DIV n)) = n
</pre>

<DT><span class="strong">group_order_id</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ ord #e = 1
</pre>

<DT><span class="strong">group_order_inv</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G âˆ§ 0 < ord x â‡’ |/ x = x ** (ord x âˆ’ 1)
</pre>

<DT><span class="strong">group_order_nonzero</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteGroup g â‡’ âˆ€x. x âˆˆ G â‡’ ord x â‰  0
</pre>

<DT><span class="strong">group_order_pos</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteGroup g â‡’ âˆ€x. x âˆˆ G â‡’ 0 < ord x
</pre>

<DT><span class="strong">group_order_power</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G â‡’ âˆ€k. ord (x ** k) * gcd (ord x) k = ord x
</pre>

<DT><span class="strong">group_order_power_coprime</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G â‡’ âˆ€n. coprime n (ord x) â‡’ ord (x ** n) = ord x
</pre>

<DT><span class="strong">group_order_power_eq_0</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G â‡’ âˆ€k. ord (x ** k) = 0 â‡” 0 < k âˆ§ ord x = 0
</pre>

<DT><span class="strong">group_order_power_eq_order</span>
<DD>
<pre>
âŠ¢ âˆ€g x.
    Group g âˆ§ x âˆˆ G âˆ§ 0 < ord x â‡’ âˆ€k. ord (x ** k) = ord x â‡” coprime k (ord x)
</pre>

<DT><span class="strong">group_order_power_eqn</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x k. x âˆˆ G âˆ§ 0 < k â‡’ ord (x ** k) = ord x DIV gcd k (ord x)
</pre>

<DT><span class="strong">group_order_property</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteGroup g â‡’ âˆ€x. x âˆˆ G â‡’ 0 < ord x âˆ§ x ** ord x = #e
</pre>

<DT><span class="strong">group_order_thm</span>
<DD>
<pre>
âŠ¢ âˆ€g n. 0 < n â‡’ âˆ€x. ord x = n â‡” x ** n = #e âˆ§ âˆ€m. 0 < m âˆ§ m < n â‡’ x ** m â‰  #e
</pre>

<DT><span class="strong">group_order_to_generated_bij</span>
<DD>
<pre>
âŠ¢ âˆ€g a. Group g âˆ§ a âˆˆ G âˆ§ 0 < ord a â‡’ BIJ (Î»n. a ** n) (count (ord a)) (Gen a)
</pre>

<DT><span class="strong">group_order_unique</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’
      âˆ€x. x âˆˆ G â‡’ âˆ€m n. m < ord x âˆ§ n < ord x âˆ§ x ** m = x ** n â‡’ m = n
</pre>

<DT><span class="strong">group_orders_eq_1</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ orders g 1 = {#e}
</pre>

<DT><span class="strong">group_pair_reduce</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x y z. x âˆˆ G âˆ§ y âˆˆ G âˆ§ z âˆˆ G â‡’ x * z * |/ (y * z) = x * |/ y
</pre>

<DT><span class="strong">group_rcancel</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x y z. x âˆˆ G âˆ§ y âˆˆ G âˆ§ z âˆˆ G â‡’ (y * x = z * x â‡” y = z)
</pre>

<DT><span class="strong">group_rid</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G â‡’ x * #e = x
</pre>

<DT><span class="strong">group_rid_unique</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ (x * y = x â‡” y = #e)
</pre>

<DT><span class="strong">group_rinv</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x. x âˆˆ G â‡’ x * |/ x = #e
</pre>

<DT><span class="strong">group_rinv_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ y = y * |/ x * x âˆ§ y = y * x * |/ x
</pre>

<DT><span class="strong">group_rinv_unique</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ (x * y = #e â‡” y = |/ x)
</pre>

<DT><span class="strong">group_rsolve</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€x y z. x âˆˆ G âˆ§ y âˆˆ G âˆ§ z âˆˆ G â‡’ (x * y = z â‡” y = |/ x * z)
</pre>

<DT><span class="strong">group_uroots_group</span>
<DD>
<pre>
âŠ¢ âˆ€g. AbelianGroup g â‡’ âˆ€n. Group (uroots n)
</pre>

<DT><span class="strong">group_uroots_has_id</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€n. #e âˆˆ (uroots n).carrier
</pre>

<DT><span class="strong">group_uroots_subgroup</span>
<DD>
<pre>
âŠ¢ âˆ€g. AbelianGroup g â‡’ âˆ€n. uroots n â‰¤ g
</pre>

<DT><span class="strong">homo_count_formula</span>
<DD>
<pre>
âŠ¢ âˆ€f g1 g2 h.
    FiniteGroup g1 âˆ§ Group g2 âˆ§ h â‰¤ g2 âˆ§ GroupHomo f g1 g2 â‡’
    CARD (preimage_group f g1 g2 h.carrier).carrier =
    CARD (kernel_group f (preimage_group f g1 g2 h.carrier) g2).carrier *
    CARD
      (preimage_group f g1 g2 h.carrier /
       kernel_group f (preimage_group f g1 g2 h.carrier) g2).carrier
</pre>

<DT><span class="strong">homo_group_abelian_group</span>
<DD>
<pre>
âŠ¢ âˆ€g f.
    AbelianGroup g âˆ§ GroupHomo f g (homo_group g f) â‡’
    AbelianGroup (homo_group g f)
</pre>

<DT><span class="strong">homo_group_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€g f.
    Group g âˆ§ GroupHomo f g (homo_group g f) â‡’
    âˆ€x y z. x âˆˆ fG âˆ§ y âˆˆ fG âˆ§ z âˆˆ fG â‡’ (x âˆ˜ y) âˆ˜ z = x âˆ˜ y âˆ˜ z
</pre>

<DT><span class="strong">homo_group_by_inj</span>
<DD>
<pre>
âŠ¢ âˆ€g f. Group g âˆ§ INJ f G ð•Œ(:Î²) â‡’ GroupHomo f g (homo_group g f)
</pre>

<DT><span class="strong">homo_group_closure</span>
<DD>
<pre>
âŠ¢ âˆ€g f.
    Group g âˆ§ GroupHomo f g (homo_group g f) â‡’
    âˆ€x y. x âˆˆ fG âˆ§ y âˆˆ fG â‡’ x âˆ˜ y âˆˆ fG
</pre>

<DT><span class="strong">homo_group_comm</span>
<DD>
<pre>
âŠ¢ âˆ€g f.
    AbelianGroup g âˆ§ GroupHomo f g (homo_group g f) â‡’
    âˆ€x y. x âˆˆ fG âˆ§ y âˆˆ fG â‡’ x âˆ˜ y = y âˆ˜ x
</pre>

<DT><span class="strong">homo_group_group</span>
<DD>
<pre>
âŠ¢ âˆ€g f. Group g âˆ§ GroupHomo f g (homo_group g f) â‡’ Group (homo_group g f)
</pre>

<DT><span class="strong">homo_group_id</span>
<DD>
<pre>
âŠ¢ âˆ€g f.
    Group g âˆ§ GroupHomo f g (homo_group g f) â‡’
    #i âˆˆ fG âˆ§ âˆ€x. x âˆˆ fG â‡’ #i âˆ˜ x = x âˆ§ x âˆ˜ #i = x
</pre>

<DT><span class="strong">homo_group_inv</span>
<DD>
<pre>
âŠ¢ âˆ€g f.
    Group g âˆ§ GroupHomo f g (homo_group g f) â‡’
    âˆ€x. x âˆˆ fG â‡’ âˆƒz. z âˆˆ fG âˆ§ z âˆ˜ x = #i
</pre>

<DT><span class="strong">homo_image_group</span>
<DD>
<pre>
âŠ¢ âˆ€g h f. Group g âˆ§ Group h âˆ§ GroupHomo f g h â‡’ Group (homo_image f g h)
</pre>

<DT><span class="strong">homo_image_homo_quotient_kernel</span>
<DD>
<pre>
âŠ¢ âˆ€g h f.
    Group g âˆ§ Group h âˆ§ GroupHomo f g h â‡’
    GroupHomo (Î»z. CHOICE (preimage f G z) * kernel f g h) (homo_image f g h)
      (g / kernel_group f g h)
</pre>

<DT><span class="strong">homo_image_iso_quotient_kernel</span>
<DD>
<pre>
âŠ¢ âˆ€g h f.
    Group g âˆ§ Group h âˆ§ GroupHomo f g h â‡’
    GroupIso (Î»z. CHOICE (preimage f G z) * kernel f g h) (homo_image f g h)
      (g / kernel_group f g h)
</pre>

<DT><span class="strong">homo_image_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€g h f. Monoid g âˆ§ Monoid h âˆ§ MonoidHomo f g h â‡’ Monoid (homo_image f g h)
</pre>

<DT><span class="strong">homo_image_subgroup</span>
<DD>
<pre>
âŠ¢ âˆ€g h f. Group g âˆ§ Group h âˆ§ GroupHomo f g h â‡’ homo_image f g h â‰¤ h
</pre>

<DT><span class="strong">homo_image_to_quotient_kernel_bij</span>
<DD>
<pre>
âŠ¢ âˆ€g h f.
    Group g âˆ§ Group h âˆ§ GroupHomo f g h â‡’
    BIJ (Î»z. CHOICE (preimage f G z) * kernel f g h)
      (homo_image f g h).carrier (g / kernel_group f g h).carrier
</pre>

<DT><span class="strong">homo_restrict_same_kernel</span>
<DD>
<pre>
âŠ¢ âˆ€f g1 g2 h.
    H âŠ† g1.carrier âˆ§ GroupHomo f g1 g2 âˆ§ kernel f g1 g2 âŠ† H â‡’
    kernel f g1 g2 = kernel f h g2
</pre>

<DT><span class="strong">image_iso_preimage_quotient</span>
<DD>
<pre>
âŠ¢ âˆ€f g1 g2 h.
    Group g1 âˆ§ Group g2 âˆ§ h â‰¤ g2 âˆ§ GroupHomo f g1 g2 â‡’
    GroupIso
      (Î»z.
           coset (preimage_group f g1 g2 h.carrier)
             (CHOICE (preimage f (preimage_group f g1 g2 h.carrier).carrier z))
             (kernel f (preimage_group f g1 g2 h.carrier) g2))
      (homo_image f (preimage_group f g1 g2 h.carrier) g2)
      (preimage_group f g1 g2 h.carrier /
       kernel_group f (preimage_group f g1 g2 h.carrier) g2)
</pre>

<DT><span class="strong">image_preimage_group</span>
<DD>
<pre>
âŠ¢ âˆ€f g1 g2 h.
    Group g1 âˆ§ Group g2 âˆ§ h â‰¤ g2 âˆ§ GroupHomo f g1 g2 âˆ§
    SURJ f g1.carrier g2.carrier â‡’
    IMAGE f (PREIMAGE f h.carrier âˆ© g1.carrier) = h.carrier
</pre>

<DT><span class="strong">image_preimage_quotient_same_card</span>
<DD>
<pre>
âŠ¢ âˆ€f g1 g2 h.
    FiniteGroup g1 âˆ§ Group g2 âˆ§ h â‰¤ g2 âˆ§ GroupHomo f g1 g2 â‡’
    CARD (homo_image f (preimage_group f g1 g2 h.carrier) g2).carrier =
    CARD
      (preimage_group f g1 g2 h.carrier /
       kernel_group f (preimage_group f g1 g2 h.carrier) g2).carrier
</pre>

<DT><span class="strong">image_subgroup_subgroup</span>
<DD>
<pre>
âŠ¢ âˆ€g1 g2 h f.
    Group g1 âˆ§ Group g2 âˆ§ GroupHomo f g1 g2 âˆ§ h â‰¤ g1 â‡’ homo_image f h g2 â‰¤ g2
</pre>

<DT><span class="strong">inCoset_equiv_on_carrier</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ inCoset g h equiv_on G
</pre>

<DT><span class="strong">inCoset_refl</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ âˆ€a. a âˆˆ G â‡’ inCoset g h a a
</pre>

<DT><span class="strong">inCoset_sym</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ âˆ€a b. a âˆˆ G âˆ§ b âˆˆ G âˆ§ inCoset g h a b â‡’ inCoset g h b a
</pre>

<DT><span class="strong">inCoset_trans</span>
<DD>
<pre>
âŠ¢ âˆ€g h.
    h â‰¤ g â‡’
    âˆ€a b c.
      a âˆˆ G âˆ§ b âˆˆ G âˆ§ c âˆˆ G âˆ§ inCoset g h a b âˆ§ inCoset g h b c â‡’
      inCoset g h a c
</pre>

<DT><span class="strong">in_coset</span>
<DD>
<pre>
âŠ¢ âˆ€g X a. a âˆˆ G â‡’ âˆ€x. x âˆˆ a * X â‡” âˆƒy. y âˆˆ X âˆ§ x = a * y
</pre>

<DT><span class="strong">independent_generated_eq</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’
      âˆ€a b. a âˆˆ G âˆ§ b âˆˆ G âˆ§ independent g a b â‡’ (gen a = gen b â‡” a = b)
</pre>

<DT><span class="strong">independent_generator_2_card</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteGroup g â‡’
      âˆ€a b.
        a âˆˆ G âˆ§ b âˆˆ G âˆ§ independent g a b â‡’
        CARD (gen a âˆ˜ gen b).carrier = ord a * ord b
</pre>

<DT><span class="strong">independent_sym</span>
<DD>
<pre>
âŠ¢ âˆ€g a b. independent g a b â‡” independent g b a
</pre>

<DT><span class="strong">iso_group_same_card</span>
<DD>
<pre>
âŠ¢ âˆ€f g h. FINITE G âˆ§ GroupIso f g h â‡’ CARD G = CARD h.carrier
</pre>

<DT><span class="strong">kernel_element</span>
<DD>
<pre>
âŠ¢ âˆ€g h f x. x âˆˆ kernel f g h â‡” x âˆˆ G âˆ§ f x = h.id
</pre>

<DT><span class="strong">kernel_group_group</span>
<DD>
<pre>
âŠ¢ âˆ€g h f. Group g âˆ§ Group h âˆ§ GroupHomo f g h â‡’ Group (kernel_group f g h)
</pre>

<DT><span class="strong">kernel_group_normal</span>
<DD>
<pre>
âŠ¢ âˆ€g h f. Group g âˆ§ Group h âˆ§ GroupHomo f g h â‡’ kernel_group f g h << g
</pre>

<DT><span class="strong">kernel_group_subgroup</span>
<DD>
<pre>
âŠ¢ âˆ€g h f. Group g âˆ§ Group h âˆ§ GroupHomo f g h â‡’ kernel_group f g h â‰¤ g
</pre>

<DT><span class="strong">kernel_property</span>
<DD>
<pre>
âŠ¢ âˆ€g h f x. x âˆˆ kernel f g h â‡” x âˆˆ G âˆ§ f x = h.id
</pre>

<DT><span class="strong">kernel_quotient_group</span>
<DD>
<pre>
âŠ¢ âˆ€g h f. Group g âˆ§ Group h âˆ§ GroupHomo f g h â‡’ Group (g / kernel_group f g h)
</pre>

<DT><span class="strong">left_coset_alt</span>
<DD>
<pre>
âŠ¢ âˆ€g X a. left_coset g X a = {a * z | z âˆˆ X}
</pre>

<DT><span class="strong">make_group_property</span>
<DD>
<pre>
âŠ¢ âˆ€g s.
    (make_group g s).carrier = s âˆ§ (make_group g s).op = $* âˆ§
    (make_group g s).id = #e
</pre>

<DT><span class="strong">monoid_homo_homo_image_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€g h f. Monoid g âˆ§ MonoidHomo f g h â‡’ Monoid (homo_image f g h)
</pre>

<DT><span class="strong">monoid_inv_id</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ |/ #e = #e
</pre>

<DT><span class="strong">monoid_inv_order</span>
<DD>
<pre>
âŠ¢ âˆ€g x. Monoid g âˆ§ x âˆˆ G* â‡’ ord ( |/ x) = ord x
</pre>

<DT><span class="strong">monoid_inv_order_property</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteMonoid g â‡’ âˆ€x. x âˆˆ G* â‡’ 0 < ord x âˆ§ x ** ord x = #e
</pre>

<DT><span class="strong">monoid_invertibles_is_group</span>
<DD>
<pre>
âŠ¢ âˆ€g. Monoid g â‡’ Group (Invertibles g)
</pre>

<DT><span class="strong">mult_mod_abelian_group</span>
<DD>
<pre>
âŠ¢ âˆ€p. prime p â‡’ AbelianGroup (mult_mod p)
</pre>

<DT><span class="strong">mult_mod_card</span>
<DD>
<pre>
âŠ¢ âˆ€p. 0 < p â‡’ CARD (mult_mod p).carrier = p âˆ’ 1
</pre>

<DT><span class="strong">mult_mod_carrier</span>
<DD>
<pre>
âŠ¢ âˆ€p. (mult_mod p).carrier = {i | i â‰  0 âˆ§ i < p}
</pre>

<DT><span class="strong">mult_mod_carrier_alt</span>
<DD>
<pre>
âŠ¢ âˆ€p. (mult_mod p).carrier = residue p
</pre>

<DT><span class="strong">mult_mod_element</span>
<DD>
<pre>
âŠ¢ âˆ€p x. x âˆˆ (mult_mod p).carrier â‡” x â‰  0 âˆ§ x < p
</pre>

<DT><span class="strong">mult_mod_element_alt</span>
<DD>
<pre>
âŠ¢ âˆ€p x. x âˆˆ (mult_mod p).carrier â‡” 0 < x âˆ§ x < p
</pre>

<DT><span class="strong">mult_mod_eval</span>
<DD>
<pre>
âŠ¢ âˆ€p. (mult_mod p).carrier = {i | i â‰  0 âˆ§ i < p} âˆ§
      (âˆ€x y. (mult_mod p).op x y = (x * y) MOD p) âˆ§ (mult_mod p).id = 1
</pre>

<DT><span class="strong">mult_mod_exp</span>
<DD>
<pre>
âŠ¢ âˆ€p a.
    prime p âˆ§ a âˆˆ (mult_mod p).carrier â‡’
    âˆ€n. (mult_mod p).exp a n = a ** n MOD p
</pre>

<DT><span class="strong">mult_mod_finite</span>
<DD>
<pre>
âŠ¢ âˆ€p. FINITE (mult_mod p).carrier
</pre>

<DT><span class="strong">mult_mod_finite_abelian_group</span>
<DD>
<pre>
âŠ¢ âˆ€p. prime p â‡’ FiniteAbelianGroup (mult_mod p)
</pre>

<DT><span class="strong">mult_mod_finite_group</span>
<DD>
<pre>
âŠ¢ âˆ€p. prime p â‡’ FiniteGroup (mult_mod p)
</pre>

<DT><span class="strong">mult_mod_group</span>
<DD>
<pre>
âŠ¢ âˆ€p. prime p â‡’ Group (mult_mod p)
</pre>

<DT><span class="strong">mult_mod_id</span>
<DD>
<pre>
âŠ¢ âˆ€p. (mult_mod p).id = 1
</pre>

<DT><span class="strong">mult_mod_inv</span>
<DD>
<pre>
âŠ¢ âˆ€p. prime p â‡’
      âˆ€x. 0 < x âˆ§ x < p â‡’
          (mult_mod p).inv x = (mult_mod p).exp x (order (mult_mod p) x âˆ’ 1)
</pre>

<DT><span class="strong">mult_mod_inv_compute</span>
<DD>
<pre>
âŠ¢ âˆ€p x.
    (mult_mod p).inv x =
    if prime p âˆ§ 0 < x âˆ§ x < p then
      (mult_mod p).exp x (order (mult_mod p) x âˆ’ 1)
    else FAIL ((mult_mod p).inv x) bad_element
</pre>

<DT><span class="strong">mult_mod_inverse</span>
<DD>
<pre>
âŠ¢ âˆ€p. prime p â‡’ âˆ€a. 0 < a âˆ§ a < p â‡’ (mult_mod p).inv a = a ** (p âˆ’ 2) MOD p
</pre>

<DT><span class="strong">mult_mod_inverse_compute</span>
<DD>
<pre>
âŠ¢ âˆ€p a.
    (mult_mod p).inv a =
    if prime p âˆ§ 0 < a âˆ§ a < p then a ** (p âˆ’ 2) MOD p else (mult_mod p).inv a
</pre>

<DT><span class="strong">mult_mod_property</span>
<DD>
<pre>
âŠ¢ âˆ€p. (âˆ€x. x âˆˆ (mult_mod p).carrier â‡’ x â‰  0) âˆ§
      (âˆ€x. x âˆˆ (mult_mod p).carrier â‡” 0 < x âˆ§ x < p) âˆ§ (mult_mod p).id = 1 âˆ§
      (âˆ€x y. (mult_mod p).op x y = (x * y) MOD p) âˆ§
      FINITE (mult_mod p).carrier âˆ§
      (0 < p â‡’ CARD (mult_mod p).carrier = p âˆ’ 1)
</pre>

<DT><span class="strong">multi_orbits_element</span>
<DD>
<pre>
âŠ¢ âˆ€f g X e. e âˆˆ multi_orbits f g X â‡” e âˆˆ orbits f g X âˆ§ Â¬SING e
</pre>

<DT><span class="strong">multi_orbits_element_finite</span>
<DD>
<pre>
âŠ¢ âˆ€f g X e. (g act X) f âˆ§ FINITE X âˆ§ e âˆˆ multi_orbits f g X â‡’ FINITE e
</pre>

<DT><span class="strong">multi_orbits_element_subset</span>
<DD>
<pre>
âŠ¢ âˆ€f g X e. (g act X) f âˆ§ e âˆˆ multi_orbits f g X â‡’ e âŠ† X
</pre>

<DT><span class="strong">multi_orbits_finite</span>
<DD>
<pre>
âŠ¢ âˆ€f g X. FINITE X â‡’ FINITE (multi_orbits f g X)
</pre>

<DT><span class="strong">multi_orbits_subset</span>
<DD>
<pre>
âŠ¢ âˆ€f g X. multi_orbits f g X âŠ† orbits f g X
</pre>

<DT><span class="strong">non_fixed_points_card</span>
<DD>
<pre>
âŠ¢ âˆ€f g X.
    FINITE X â‡’
    CARD (X DIFF fixed_points f g X) = CARD X âˆ’ CARD (fixed_points f g X)
</pre>

<DT><span class="strong">non_fixed_points_orbit_not_sing</span>
<DD>
<pre>
âŠ¢ âˆ€f g X.
    Group g âˆ§ (g act X) f â‡’
    âˆ€x. x âˆˆ X DIFF fixed_points f g X â‡” x âˆˆ X âˆ§ Â¬SING (orbit f g x)
</pre>

<DT><span class="strong">normal_cogen_property</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h << g â‡’ âˆ€x. x âˆˆ G â‡’ x / cogen g h (x * H) âˆˆ H
</pre>

<DT><span class="strong">normal_coset_op_property</span>
<DD>
<pre>
âŠ¢ âˆ€g h.
    h << g â‡’
    âˆ€x y.
      x âˆˆ CosetPartition g h âˆ§ y âˆˆ CosetPartition g h â‡’
      x âˆ˜ y =
      CHOICE (preimage (left_coset g H) G x) *
      CHOICE (preimage (left_coset g H) G y) * H
</pre>

<DT><span class="strong">normal_coset_property</span>
<DD>
<pre>
âŠ¢ âˆ€g h.
    h << g â‡’
    âˆ€a b.
      a âˆˆ G âˆ§ b âˆˆ G â‡’ cogen g h (a * H) * cogen g h (b * H) * H = a * b * H
</pre>

<DT><span class="strong">normal_coset_property1</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h << g â‡’ âˆ€a b. a âˆˆ G âˆ§ b âˆˆ G â‡’ cogen g h (a * H) * b * H = a * b * H
</pre>

<DT><span class="strong">normal_coset_property2</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h << g â‡’ âˆ€a b. a âˆˆ G âˆ§ b âˆˆ G â‡’ a * cogen g h (b * H) * H = a * b * H
</pre>

<DT><span class="strong">normal_iff_preimage_normal</span>
<DD>
<pre>
âŠ¢ âˆ€f g1 g2 h2.
    Group g1 âˆ§ Group g2 âˆ§ h2 â‰¤ g2 âˆ§ GroupHomo f g1 g2 âˆ§
    SURJ f g1.carrier g2.carrier â‡’
    (h2 << g2 â‡” preimage_group f g1 g2 h2.carrier << g1)
</pre>

<DT><span class="strong">normal_preimage_normal</span>
<DD>
<pre>
âŠ¢ âˆ€f g1 g2 h2.
    Group g1 âˆ§ Group g2 âˆ§ h2 â‰¤ g2 âˆ§ GroupHomo f g1 g2 â‡’
    h2 << g2 â‡’
    preimage_group f g1 g2 h2.carrier << g1
</pre>

<DT><span class="strong">normal_subgroup_alt</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h << g â‡” h â‰¤ g âˆ§ âˆ€a. a âˆˆ G â‡’ a * H = H * a
</pre>

<DT><span class="strong">normal_subgroup_antisym</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h << g âˆ§ g << h â‡’ h = g
</pre>

<DT><span class="strong">normal_subgroup_coset_eq</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h << g â‡’ âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ (x * H = y * H â‡” x / y âˆˆ H)
</pre>

<DT><span class="strong">normal_subgroup_coset_homo</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h << g â‡’ GroupHomo (left_coset g H) g (g / h)
</pre>

<DT><span class="strong">normal_subgroup_groups</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h << g â‡’ h â‰¤ g âˆ§ Group h âˆ§ Group g
</pre>

<DT><span class="strong">normal_subgroup_property</span>
<DD>
<pre>
âŠ¢ âˆ€h g. h << g â‡’ âˆ€a z. a âˆˆ G âˆ§ z âˆˆ H â‡’ a * z / a âˆˆ H
</pre>

<DT><span class="strong">normal_subgroup_refl</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ g << g
</pre>

<DT><span class="strong">normal_subgroup_subgroup</span>
<DD>
<pre>
âŠ¢ âˆ€h g. h << g â‡’ h â‰¤ g
</pre>

<DT><span class="strong">normal_surj_normal</span>
<DD>
<pre>
âŠ¢ âˆ€f g1 g2 h2.
    Group g1 âˆ§ Group g2 âˆ§ h2 â‰¤ g2 âˆ§ GroupHomo f g1 g2 âˆ§
    SURJ f g1.carrier g2.carrier â‡’
    preimage_group f g1 g2 h2.carrier << g1 â‡’
    h2 << g2
</pre>

<DT><span class="strong">orbit_alt</span>
<DD>
<pre>
âŠ¢ âˆ€f g x. orbit f g x = {f a x | a âˆˆ G}
</pre>

<DT><span class="strong">orbit_card_divides_target_card</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x.
    FiniteGroup g âˆ§ (g act X) f âˆ§ x âˆˆ X âˆ§ FINITE X â‡’
    CARD (orbit f g x) divides CARD G
</pre>

<DT><span class="strong">orbit_element</span>
<DD>
<pre>
âŠ¢ âˆ€f g x y. y âˆˆ orbit f g x â‡” reach f g x y
</pre>

<DT><span class="strong">orbit_element_in_target</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x y. (g act X) f âˆ§ x âˆˆ X âˆ§ y âˆˆ orbit f g x â‡’ y âˆˆ X
</pre>

<DT><span class="strong">orbit_eq_equiv_class</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x. (g act X) f âˆ§ x âˆˆ X â‡’ orbit f g x = equiv_class (reach f g) X x
</pre>

<DT><span class="strong">orbit_eq_orbit</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x y.
    Group g âˆ§ (g act X) f âˆ§ x âˆˆ X âˆ§ y âˆˆ X â‡’
    (orbit f g x = orbit f g y â‡” reach f g x y)
</pre>

<DT><span class="strong">orbit_finite</span>
<DD>
<pre>
âŠ¢ âˆ€f g x. FINITE G â‡’ FINITE (orbit f g x)
</pre>

<DT><span class="strong">orbit_finite_by_target</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x. (g act X) f âˆ§ x âˆˆ X âˆ§ FINITE X â‡’ FINITE (orbit f g x)
</pre>

<DT><span class="strong">orbit_finite_inj_card_eq</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x.
    (g act X) f âˆ§ x âˆˆ X âˆ§ FINITE X âˆ§ INJ (Î»a. f a x) G (orbit f g x) â‡’
    CARD (orbit f g x) = CARD G
</pre>

<DT><span class="strong">orbit_has_action_element</span>
<DD>
<pre>
âŠ¢ âˆ€f g x a. a âˆˆ G â‡’ f a x âˆˆ orbit f g x
</pre>

<DT><span class="strong">orbit_has_self</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x. Group g âˆ§ (g act X) f âˆ§ x âˆˆ X â‡’ x âˆˆ orbit f g x
</pre>

<DT><span class="strong">orbit_is_orbits_element</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x. x âˆˆ X â‡’ orbit f g x âˆˆ orbits f g X
</pre>

<DT><span class="strong">orbit_sing_fixed_points</span>
<DD>
<pre>
âŠ¢ âˆ€f g X. (g act X) f â‡’ âˆ€x. x âˆˆ X âˆ§ orbit f g x = {x} â‡’ x âˆˆ fixed_points f g X
</pre>

<DT><span class="strong">orbit_stabilizer_cosets_bij</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x.
    Group g âˆ§ (g act X) f âˆ§ x âˆˆ X â‡’
    BIJ (Î»y. act_by f g x y * stabilizer f g x) (orbit f g x)
      {a * stabilizer f g x | a | a âˆˆ G}
</pre>

<DT><span class="strong">orbit_stabilizer_cosets_bij_alt</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x.
    Group g âˆ§ (g act X) f âˆ§ x âˆˆ X â‡’
    BIJ (Î»y. act_by f g x y * stabilizer f g x) (orbit f g x)
      (CosetPartition g (StabilizerGroup f g x))
</pre>

<DT><span class="strong">orbit_stabilizer_map_good</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x.
    Group g âˆ§ (g act X) f âˆ§ x âˆˆ X â‡’
    âˆ€a b.
      a âˆˆ G âˆ§ b âˆˆ G âˆ§ f a x = f b x â‡’
      a * stabilizer f g x = b * stabilizer f g x
</pre>

<DT><span class="strong">orbit_stabilizer_map_inj</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x.
    Group g âˆ§ (g act X) f âˆ§ x âˆˆ X â‡’
    âˆ€a b.
      a âˆˆ G âˆ§ b âˆˆ G âˆ§ a * stabilizer f g x = b * stabilizer f g x â‡’
      f a x = f b x
</pre>

<DT><span class="strong">orbit_stabilizer_thm</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x.
    FiniteGroup g âˆ§ (g act X) f âˆ§ x âˆˆ X âˆ§ FINITE X â‡’
    CARD G = CARD (orbit f g x) * CARD (stabilizer f g x)
</pre>

<DT><span class="strong">orbit_subset_target</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x. (g act X) f âˆ§ x âˆˆ X â‡’ orbit f g x âŠ† X
</pre>

<DT><span class="strong">orbits_alt</span>
<DD>
<pre>
âŠ¢ âˆ€f g X. orbits f g X = {orbit f g x | x âˆˆ X}
</pre>

<DT><span class="strong">orbits_element</span>
<DD>
<pre>
âŠ¢ âˆ€f g X e. e âˆˆ orbits f g X â‡” âˆƒx. x âˆˆ X âˆ§ e = orbit f g x
</pre>

<DT><span class="strong">orbits_element_element</span>
<DD>
<pre>
âŠ¢ âˆ€f g X e x. (g act X) f âˆ§ e âˆˆ orbits f g X âˆ§ x âˆˆ e â‡’ x âˆˆ X
</pre>

<DT><span class="strong">orbits_element_finite</span>
<DD>
<pre>
âŠ¢ âˆ€f g X. (g act X) f âˆ§ FINITE X â‡’ EVERY_FINITE (orbits f g X)
</pre>

<DT><span class="strong">orbits_element_is_orbit</span>
<DD>
<pre>
âŠ¢ âˆ€f g X e x.
    Group g âˆ§ (g act X) f âˆ§ e âˆˆ orbits f g X âˆ§ x âˆˆ e â‡’ e = orbit f g x
</pre>

<DT><span class="strong">orbits_element_nonempty</span>
<DD>
<pre>
âŠ¢ âˆ€f g X. Group g âˆ§ (g act X) f â‡’ âˆ€e. e âˆˆ orbits f g X â‡’ e â‰  âˆ…
</pre>

<DT><span class="strong">orbits_element_subset</span>
<DD>
<pre>
âŠ¢ âˆ€f g X e. (g act X) f âˆ§ e âˆˆ orbits f g X â‡’ e âŠ† X
</pre>

<DT><span class="strong">orbits_eq_partition</span>
<DD>
<pre>
âŠ¢ âˆ€f g X. (g act X) f â‡’ orbits f g X = partition (reach f g) X
</pre>

<DT><span class="strong">orbits_equal_size_partition_equal_size</span>
<DD>
<pre>
âŠ¢ âˆ€f g X n.
    Group g âˆ§ (g act X) f âˆ§ FINITE X âˆ§ (âˆ€x. x âˆˆ X â‡’ CARD (orbit f g x) = n) â‡’
    âˆ€e. e âˆˆ orbits f g X â‡’ CARD e = n
</pre>

<DT><span class="strong">orbits_equal_size_property</span>
<DD>
<pre>
âŠ¢ âˆ€f g X n.
    Group g âˆ§ (g act X) f âˆ§ FINITE X âˆ§ (âˆ€x. x âˆˆ X â‡’ CARD (orbit f g x) = n) â‡’
    n divides CARD X
</pre>

<DT><span class="strong">orbits_finite</span>
<DD>
<pre>
âŠ¢ âˆ€f g X. FINITE X â‡’ FINITE (orbits f g X)
</pre>

<DT><span class="strong">orbits_size_factor_partition_factor</span>
<DD>
<pre>
âŠ¢ âˆ€f g X n.
    Group g âˆ§ (g act X) f âˆ§ FINITE X âˆ§
    (âˆ€x. x âˆˆ X â‡’ n divides CARD (orbit f g x)) â‡’
    âˆ€e. e âˆˆ orbits f g X â‡’ n divides CARD e
</pre>

<DT><span class="strong">orbits_size_factor_property</span>
<DD>
<pre>
âŠ¢ âˆ€f g X n.
    Group g âˆ§ (g act X) f âˆ§ FINITE X âˆ§
    (âˆ€x. x âˆˆ X â‡’ n divides CARD (orbit f g x)) â‡’
    n divides CARD X
</pre>

<DT><span class="strong">orders_is_feq_class_order</span>
<DD>
<pre>
âŠ¢ âˆ€g. orders g = preimage ord G
</pre>

<DT><span class="strong">preimage_cardinality</span>
<DD>
<pre>
âŠ¢ âˆ€f g1 g2 h.
    FiniteGroup g1 âˆ§ Group g2 âˆ§ h â‰¤ g2 âˆ§ GroupHomo f g1 g2 âˆ§
    SURJ f g1.carrier g2.carrier â‡’
    CARD (preimage_group f g1 g2 h.carrier).carrier =
    CARD h.carrier * CARD (kernel f g1 g2)
</pre>

<DT><span class="strong">preimage_group_group</span>
<DD>
<pre>
âŠ¢ âˆ€f g1 g2 h.
    Group g1 âˆ§ Group g2 âˆ§ GroupHomo f g1 g2 âˆ§ h â‰¤ g2 â‡’
    Group (preimage_group f g1 g2 h.carrier)
</pre>

<DT><span class="strong">preimage_group_property</span>
<DD>
<pre>
âŠ¢ âˆ€f g1 g2 h x. x âˆˆ PREIMAGE f h âˆ© g1.carrier â‡’ x âˆˆ g1.carrier âˆ§ f x âˆˆ h
</pre>

<DT><span class="strong">preimage_image_subset</span>
<DD>
<pre>
âŠ¢ âˆ€f g1 g2 h.
    Group g1 âˆ§ Group g2 âˆ§ h â‰¤ g1 âˆ§ GroupHomo f g1 g2 âˆ§
    SURJ f g1.carrier g2.carrier âˆ§ kernel f g1 g2 âŠ† H â‡’
    PREIMAGE f (IMAGE f H) âˆ© g1.carrier âŠ† H
</pre>

<DT><span class="strong">preimage_subgroup_kernel</span>
<DD>
<pre>
âŠ¢ âˆ€f g1 g2 h2.
    Group g1 âˆ§ Group g2 âˆ§ h2 â‰¤ g2 âˆ§ GroupHomo f g1 g2 â‡’
    kernel f g1 g2 âŠ† PREIMAGE f h2.carrier âˆ© g1.carrier
</pre>

<DT><span class="strong">preimage_subgroup_subgroup</span>
<DD>
<pre>
âŠ¢ âˆ€f g1 g2 h.
    Group g1 âˆ§ Group g2 âˆ§ GroupHomo f g1 g2 âˆ§ h â‰¤ g2 â‡’
    preimage_group f g1 g2 h.carrier â‰¤ g1
</pre>

<DT><span class="strong">prod_image_as_op_image</span>
<DD>
<pre>
âŠ¢ âˆ = OP_IMAGE (Î»x y. x * y) 1
</pre>

<DT><span class="strong">quotient_group_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€g h.
    h << g â‡’
    âˆ€x y z.
      x âˆˆ CosetPartition g h âˆ§ y âˆˆ CosetPartition g h âˆ§ z âˆˆ CosetPartition g h â‡’
      (x âˆ˜ y) âˆ˜ z = x âˆ˜ y âˆ˜ z
</pre>

<DT><span class="strong">quotient_group_closure</span>
<DD>
<pre>
âŠ¢ âˆ€g h.
    h â‰¤ g â‡’
    âˆ€x y.
      x âˆˆ CosetPartition g h âˆ§ y âˆˆ CosetPartition g h â‡’
      x âˆ˜ y âˆˆ CosetPartition g h
</pre>

<DT><span class="strong">quotient_group_group</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h << g â‡’ Group (g / h)
</pre>

<DT><span class="strong">quotient_group_id</span>
<DD>
<pre>
âŠ¢ âˆ€g h.
    h << g â‡’ H âˆˆ CosetPartition g h âˆ§ âˆ€x. x âˆˆ CosetPartition g h â‡’ H âˆ˜ x = x
</pre>

<DT><span class="strong">quotient_group_inv</span>
<DD>
<pre>
âŠ¢ âˆ€g h.
    h << g â‡’
    âˆ€x. x âˆˆ CosetPartition g h â‡’ âˆƒy. y âˆˆ CosetPartition g h âˆ§ y âˆ˜ x = H
</pre>

<DT><span class="strong">reach_equiv</span>
<DD>
<pre>
âŠ¢ âˆ€f g X. Group g âˆ§ (g act X) f â‡’ reach f g equiv_on X
</pre>

<DT><span class="strong">reach_refl</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x. Group g âˆ§ (g act X) f âˆ§ x âˆˆ X â‡’ reach f g x x
</pre>

<DT><span class="strong">reach_sym</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x y.
    Group g âˆ§ (g act X) f âˆ§ x âˆˆ X âˆ§ y âˆˆ X âˆ§ reach f g x y â‡’ reach f g y x
</pre>

<DT><span class="strong">reach_trans</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x y z.
    Group g âˆ§ (g act X) f âˆ§ x âˆˆ X âˆ§ y âˆˆ X âˆ§ z âˆˆ X âˆ§ reach f g x y âˆ§
    reach f g y z â‡’
    reach f g x z
</pre>

<DT><span class="strong">right_coset_alt</span>
<DD>
<pre>
âŠ¢ âˆ€g X a. X * a = {z * a | z âˆˆ X}
</pre>

<DT><span class="strong">roots_of_unity_0</span>
<DD>
<pre>
âŠ¢ âˆ€g. (uroots 0).carrier = G
</pre>

<DT><span class="strong">roots_of_unity_element</span>
<DD>
<pre>
âŠ¢ âˆ€g n x. x âˆˆ (uroots n).carrier â‡” x âˆˆ G âˆ§ x ** n = #e
</pre>

<DT><span class="strong">roots_of_unity_subset</span>
<DD>
<pre>
âŠ¢ âˆ€g n. (uroots n).carrier âŠ† G
</pre>

<DT><span class="strong">sing_orbits_card_eqn</span>
<DD>
<pre>
âŠ¢ âˆ€f g X.
    Group g âˆ§ (g act X) f âˆ§ FINITE X â‡’
    CARD (sing_orbits f g X) = CARD (fixed_points f g X)
</pre>

<DT><span class="strong">sing_orbits_element</span>
<DD>
<pre>
âŠ¢ âˆ€f g X e. e âˆˆ sing_orbits f g X â‡” e âˆˆ orbits f g X âˆ§ SING e
</pre>

<DT><span class="strong">sing_orbits_element_card</span>
<DD>
<pre>
âŠ¢ âˆ€f g X e. e âˆˆ sing_orbits f g X â‡’ CARD e = 1
</pre>

<DT><span class="strong">sing_orbits_element_choice</span>
<DD>
<pre>
âŠ¢ âˆ€f g X.
    Group g âˆ§ (g act X) f â‡’
    âˆ€e. e âˆˆ sing_orbits f g X â‡’ CHOICE e âˆˆ fixed_points f g X
</pre>

<DT><span class="strong">sing_orbits_element_finite</span>
<DD>
<pre>
âŠ¢ âˆ€f g X e. e âˆˆ sing_orbits f g X â‡’ FINITE e
</pre>

<DT><span class="strong">sing_orbits_element_subset</span>
<DD>
<pre>
âŠ¢ âˆ€f g X e. (g act X) f âˆ§ e âˆˆ sing_orbits f g X â‡’ e âŠ† X
</pre>

<DT><span class="strong">sing_orbits_finite</span>
<DD>
<pre>
âŠ¢ âˆ€f g X. FINITE X â‡’ FINITE (sing_orbits f g X)
</pre>

<DT><span class="strong">sing_orbits_subset</span>
<DD>
<pre>
âŠ¢ âˆ€f g X. sing_orbits f g X âŠ† orbits f g X
</pre>

<DT><span class="strong">sing_orbits_to_fixed_points_bij</span>
<DD>
<pre>
âŠ¢ âˆ€f g X.
    Group g âˆ§ (g act X) f â‡’
    BIJ (Î»e. CHOICE e) (sing_orbits f g X) (fixed_points f g X)
</pre>

<DT><span class="strong">sing_orbits_to_fixed_points_inj</span>
<DD>
<pre>
âŠ¢ âˆ€f g X.
    Group g âˆ§ (g act X) f â‡’
    INJ (Î»e. CHOICE e) (sing_orbits f g X) (fixed_points f g X)
</pre>

<DT><span class="strong">sing_orbits_to_fixed_points_surj</span>
<DD>
<pre>
âŠ¢ âˆ€f g X.
    Group g âˆ§ (g act X) f â‡’
    SURJ (Î»e. CHOICE e) (sing_orbits f g X) (fixed_points f g X)
</pre>

<DT><span class="strong">stabilizer_as_image</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x.
    Group g âˆ§ (g act X) f âˆ§ x âˆˆ X â‡’
    stabilizer f g x = IMAGE (Î»a. if f a x = x then a else #e) G
</pre>

<DT><span class="strong">stabilizer_conjugate</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x a.
    Group g âˆ§ (g act X) f âˆ§ x âˆˆ X âˆ§ a âˆˆ G â‡’
    conjugate g a (stabilizer f g x) = stabilizer f g (f a x)
</pre>

<DT><span class="strong">stabilizer_element</span>
<DD>
<pre>
âŠ¢ âˆ€f g x a. a âˆˆ stabilizer f g x â‡” a âˆˆ G âˆ§ f a x = x
</pre>

<DT><span class="strong">stabilizer_group_card_divides</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x.
    FiniteGroup g âˆ§ (g act X) f âˆ§ x âˆˆ X â‡’
    CARD (stabilizer f g x) divides CARD G
</pre>

<DT><span class="strong">stabilizer_group_carrier</span>
<DD>
<pre>
âŠ¢ âˆ€f g x. (StabilizerGroup f g x).carrier = stabilizer f g x
</pre>

<DT><span class="strong">stabilizer_group_finite_group</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x.
    FiniteGroup g âˆ§ (g act X) f âˆ§ x âˆˆ X â‡’ FiniteGroup (StabilizerGroup f g x)
</pre>

<DT><span class="strong">stabilizer_group_group</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x. Group g âˆ§ (g act X) f âˆ§ x âˆˆ X â‡’ Group (StabilizerGroup f g x)
</pre>

<DT><span class="strong">stabilizer_group_id</span>
<DD>
<pre>
âŠ¢ âˆ€f g x. (StabilizerGroup f g x).id = #e
</pre>

<DT><span class="strong">stabilizer_group_property</span>
<DD>
<pre>
âŠ¢ âˆ€f g x.
    (StabilizerGroup f g x).carrier = stabilizer f g x âˆ§
    (StabilizerGroup f g x).op = $* âˆ§ (StabilizerGroup f g x).id = #e
</pre>

<DT><span class="strong">stabilizer_group_subgroup</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x. Group g âˆ§ (g act X) f âˆ§ x âˆˆ X â‡’ StabilizerGroup f g x â‰¤ g
</pre>

<DT><span class="strong">stabilizer_has_id</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x. Group g âˆ§ (g act X) f âˆ§ x âˆˆ X â‡’ #e âˆˆ stabilizer f g x
</pre>

<DT><span class="strong">stabilizer_nonempty</span>
<DD>
<pre>
âŠ¢ âˆ€f g X x. Group g âˆ§ (g act X) f âˆ§ x âˆˆ X â‡’ stabilizer f g x â‰  âˆ…
</pre>

<DT><span class="strong">stabilizer_subset</span>
<DD>
<pre>
âŠ¢ âˆ€f g x. stabilizer f g x âŠ† G
</pre>

<DT><span class="strong">subgroup_I_antisym</span>
<DD>
<pre>
âŠ¢ âˆ€g h. subgroup h g âˆ§ subgroup g h â‡’ GroupIso I h g
</pre>

<DT><span class="strong">subgroup_alt</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’
      âˆ€h. h â‰¤ g â‡”
          H â‰  âˆ… âˆ§ H âŠ† G âˆ§ h.op = $* âˆ§ h.id = #e âˆ§
          âˆ€x y. x âˆˆ H âˆ§ y âˆˆ H â‡’ x * |/ y âˆˆ H
</pre>

<DT><span class="strong">subgroup_antisym</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g âˆ§ g â‰¤ h â‡’ h = g
</pre>

<DT><span class="strong">subgroup_big_cross_empty</span>
<DD>
<pre>
âŠ¢ âˆ€g. sgbcross âˆ… = gen #e
</pre>

<DT><span class="strong">subgroup_big_cross_insert</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteAbelianGroup g â‡’
      âˆ€B. B âŠ† all_subgroups g â‡’
          âˆ€h. h âˆˆ all_subgroups g âˆ§ h âˆ‰ B â‡’
              sgbcross (h INSERT B) = h âˆ˜ sgbcross B
</pre>

<DT><span class="strong">subgroup_big_cross_thm</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteAbelianGroup g â‡’
      âˆ€B. B âŠ† all_subgroups g â‡’
          âˆ€h. h âˆˆ all_subgroups g â‡’
              sgbcross (h INSERT B) = h âˆ˜ sgbcross (B DELETE h)
</pre>

<DT><span class="strong">subgroup_big_intersect_element</span>
<DD>
<pre>
âŠ¢ âˆ€g x. x âˆˆ (sgbINTER g).carrier â‡” âˆ€h. h â‰¤ g â‡’ x âˆˆ H
</pre>

<DT><span class="strong">subgroup_big_intersect_group</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ Group (sgbINTER g)
</pre>

<DT><span class="strong">subgroup_big_intersect_has_id</span>
<DD>
<pre>
âŠ¢ âˆ€g. (sgbINTER g).id âˆˆ (sgbINTER g).carrier
</pre>

<DT><span class="strong">subgroup_big_intersect_has_inv</span>
<DD>
<pre>
âŠ¢ âˆ€g x. x âˆˆ (sgbINTER g).carrier â‡’ |/ x âˆˆ (sgbINTER g).carrier
</pre>

<DT><span class="strong">subgroup_big_intersect_op_element</span>
<DD>
<pre>
âŠ¢ âˆ€g x y.
    x âˆˆ (sgbINTER g).carrier âˆ§ y âˆˆ (sgbINTER g).carrier â‡’
    (sgbINTER g).op x y âˆˆ (sgbINTER g).carrier
</pre>

<DT><span class="strong">subgroup_big_intersect_property</span>
<DD>
<pre>
âŠ¢ âˆ€g. (sgbINTER g).carrier = BIGINTER (IMAGE (Î»h. H) {h | h â‰¤ g}) âˆ§
      (âˆ€x y.
         x âˆˆ (sgbINTER g).carrier âˆ§ y âˆˆ (sgbINTER g).carrier â‡’
         (sgbINTER g).op x y = x * y) âˆ§ (sgbINTER g).id = #e
</pre>

<DT><span class="strong">subgroup_big_intersect_subgroup</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ sgbINTER g â‰¤ g
</pre>

<DT><span class="strong">subgroup_big_intersect_subset</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ (sgbINTER g).carrier âŠ† G
</pre>

<DT><span class="strong">subgroup_carrier_antisym</span>
<DD>
<pre>
âŠ¢ âˆ€g h. subgroup h g âˆ§ G âŠ† H â‡’ GroupIso I h g
</pre>

<DT><span class="strong">subgroup_carrier_nonempty</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ H â‰  âˆ…
</pre>

<DT><span class="strong">subgroup_carrier_subset</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ H âŠ† G
</pre>

<DT><span class="strong">subgroup_conjugate_subgroup_bij</span>
<DD>
<pre>
âŠ¢ âˆ€g h.
    h â‰¤ g â‡’
    âˆ€a. a âˆˆ G â‡’ BIJ (Î»z. a * z * |/ a) H (conjugate_subgroup h g a).carrier
</pre>

<DT><span class="strong">subgroup_coset_card</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g âˆ§ FINITE H â‡’ âˆ€a. a âˆˆ G â‡’ CARD (a * H) = CARD H
</pre>

<DT><span class="strong">subgroup_coset_card_partition_element</span>
<DD>
<pre>
âŠ¢ âˆ€g h.
    h â‰¤ g âˆ§ FINITE G â‡’ âˆ€e. e âˆˆ partition (left_coset g H) G â‡’ CARD e = CARD H
</pre>

<DT><span class="strong">subgroup_coset_eq</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ âˆ€x y. x âˆˆ G âˆ§ y âˆˆ G â‡’ (x * H = y * H â‡” |/ y * x âˆˆ H)
</pre>

<DT><span class="strong">subgroup_coset_in_partition</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ âˆ€x. x âˆˆ IMAGE (left_coset g H) G â‡” x âˆˆ CosetPartition g h
</pre>

<DT><span class="strong">subgroup_coset_nonempty</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ âˆ€x. x âˆˆ G â‡’ x âˆˆ x * H
</pre>

<DT><span class="strong">subgroup_coset_partition_element</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ âˆ€e. e âˆˆ partition (left_coset g H) G â‡” âˆƒa. a âˆˆ G âˆ§ e = a * H
</pre>

<DT><span class="strong">subgroup_coset_subset</span>
<DD>
<pre>
âŠ¢ âˆ€g h a x. h â‰¤ g âˆ§ a âˆˆ G âˆ§ x âˆˆ a * H â‡’ x âˆˆ G
</pre>

<DT><span class="strong">subgroup_coset_sym</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ âˆ€a b. a âˆˆ G âˆ§ b âˆˆ G âˆ§ b âˆˆ a * H â‡’ a âˆˆ b * H
</pre>

<DT><span class="strong">subgroup_coset_trans</span>
<DD>
<pre>
âŠ¢ âˆ€g h.
    h â‰¤ g â‡’ âˆ€a b c. a âˆˆ G âˆ§ b âˆˆ G âˆ§ c âˆˆ G âˆ§ b âˆˆ a * H âˆ§ c âˆˆ b * H â‡’ c âˆˆ a * H
</pre>

<DT><span class="strong">subgroup_cross_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€g h1 h2 h3. h1 â‰¤ g âˆ§ h2 â‰¤ g âˆ§ h3 â‰¤ g â‡’ (h1 âˆ˜ h2) âˆ˜ h3 = h1 âˆ˜ h2 âˆ˜ h3
</pre>

<DT><span class="strong">subgroup_cross_card</span>
<DD>
<pre>
âŠ¢ âˆ€g h1 h2.
    h1 â‰¤ g âˆ§ h2 â‰¤ g âˆ§ FINITE G â‡’
    (let
       s1 = h1.carrier;
       s2 = h2.carrier
     in
       CARD (h1 âˆ˜ h2).carrier = CARD s1 * CARD s2 DIV CARD (s1 âˆ© s2))
</pre>

<DT><span class="strong">subgroup_cross_card_eqn</span>
<DD>
<pre>
âŠ¢ âˆ€g h1 h2.
    h1 â‰¤ g âˆ§ h2 â‰¤ g âˆ§ FINITE G â‡’
    (let
       s1 = h1.carrier;
       s2 = h2.carrier
     in
       CARD (h1 âˆ˜ h2).carrier * CARD (s1 âˆ© s2) = CARD s1 * CARD s2)
</pre>

<DT><span class="strong">subgroup_cross_closure_comm_assoc_fun</span>
<DD>
<pre>
âŠ¢ âˆ€g. AbelianGroup g â‡’ closure_comm_assoc_fun $o (all_subgroups g)
</pre>

<DT><span class="strong">subgroup_cross_comm</span>
<DD>
<pre>
âŠ¢ âˆ€g. AbelianGroup g â‡’ âˆ€h1 h2. h1 â‰¤ g âˆ§ h2 â‰¤ g â‡’ h1 âˆ˜ h2 = h2 âˆ˜ h1
</pre>

<DT><span class="strong">subgroup_cross_finite</span>
<DD>
<pre>
âŠ¢ âˆ€g h1 h2.
    h1 â‰¤ g âˆ§ h2 â‰¤ g âˆ§ h1 âˆ˜ h2 = h2 âˆ˜ h1 âˆ§ FiniteGroup h1 âˆ§ FiniteGroup h2 â‡’
    FiniteGroup (h1 âˆ˜ h2)
</pre>

<DT><span class="strong">subgroup_cross_group</span>
<DD>
<pre>
âŠ¢ âˆ€g h1 h2. h1 â‰¤ g âˆ§ h2 â‰¤ g âˆ§ h1 âˆ˜ h2 = h2 âˆ˜ h1 â‡’ Group (h1 âˆ˜ h2)
</pre>

<DT><span class="strong">subgroup_cross_property</span>
<DD>
<pre>
âŠ¢ âˆ€g h1 h2.
    (h1 âˆ˜ h2).carrier = h1.carrier âˆ˜ h2.carrier âˆ§ (h1 âˆ˜ h2).op = $* âˆ§
    (h1 âˆ˜ h2).id = #e
</pre>

<DT><span class="strong">subgroup_cross_self</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ h âˆ˜ h = h
</pre>

<DT><span class="strong">subgroup_cross_subgroup</span>
<DD>
<pre>
âŠ¢ âˆ€g h1 h2. h1 â‰¤ g âˆ§ h2 â‰¤ g âˆ§ h1 âˆ˜ h2 = h2 âˆ˜ h1 â‡’ h1 âˆ˜ h2 â‰¤ g
</pre>

<DT><span class="strong">subgroup_element</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ âˆ€z. z âˆˆ H â‡’ z âˆˆ G
</pre>

<DT><span class="strong">subgroup_eq</span>
<DD>
<pre>
âŠ¢ âˆ€g h1 h2. h1 â‰¤ g âˆ§ h2 â‰¤ g â‡’ (h1 = h2 â‡” h1.carrier = h2.carrier)
</pre>

<DT><span class="strong">subgroup_eq_carrier</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g âˆ§ H = G â‡’ h = g
</pre>

<DT><span class="strong">subgroup_eqn</span>
<DD>
<pre>
âŠ¢ âˆ€g h. subgroup h g â‡” H âŠ† G âˆ§ âˆ€x y. x âˆˆ H âˆ§ y âˆˆ H â‡’ h.op x y = x * y
</pre>

<DT><span class="strong">subgroup_exp</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ âˆ€x. x âˆˆ H â‡’ âˆ€n. h.exp x n = x ** n
</pre>

<DT><span class="strong">subgroup_groups</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ Group h âˆ§ Group g
</pre>

<DT><span class="strong">subgroup_has_groups</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ Group g âˆ§ Group h
</pre>

<DT><span class="strong">subgroup_homo_homo</span>
<DD>
<pre>
âŠ¢ âˆ€g h k f. subgroup h g âˆ§ GroupHomo f g k â‡’ GroupHomo f h k
</pre>

<DT><span class="strong">subgroup_homomorphism</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ Group h âˆ§ Group g âˆ§ subgroup h g
</pre>

<DT><span class="strong">subgroup_id</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ h.id = #e
</pre>

<DT><span class="strong">subgroup_incoset_equiv</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ left_coset g H equiv_on G
</pre>

<DT><span class="strong">subgroup_intersect_group</span>
<DD>
<pre>
âŠ¢ âˆ€g h k. h â‰¤ g âˆ§ k â‰¤ g â‡’ Group (h mINTER k)
</pre>

<DT><span class="strong">subgroup_intersect_has_inv</span>
<DD>
<pre>
âŠ¢ âˆ€g h k. h â‰¤ g âˆ§ k â‰¤ g â‡’ âˆ€x. x âˆˆ H âˆ© k.carrier â‡’ |/ x âˆˆ H âˆ© k.carrier
</pre>

<DT><span class="strong">subgroup_intersect_inv</span>
<DD>
<pre>
âŠ¢ âˆ€g h k. h â‰¤ g âˆ§ k â‰¤ g â‡’ âˆ€x. x âˆˆ H âˆ© k.carrier â‡’ (h mINTER k).inv x = |/ x
</pre>

<DT><span class="strong">subgroup_intersect_property</span>
<DD>
<pre>
âŠ¢ âˆ€g h k.
    h â‰¤ g âˆ§ k â‰¤ g â‡’
    (h mINTER k).carrier = H âˆ© k.carrier âˆ§
    (âˆ€x y. x âˆˆ H âˆ© k.carrier âˆ§ y âˆˆ H âˆ© k.carrier â‡’ (h mINTER k).op x y = x * y) âˆ§
    (h mINTER k).id = #e âˆ§ âˆ€x. x âˆˆ H âˆ© k.carrier â‡’ (h mINTER k).inv x = |/ x
</pre>

<DT><span class="strong">subgroup_intersect_subgroup</span>
<DD>
<pre>
âŠ¢ âˆ€g h k. h â‰¤ g âˆ§ k â‰¤ g â‡’ (h mINTER k) â‰¤ g
</pre>

<DT><span class="strong">subgroup_inv</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ âˆ€x. x âˆˆ H â‡’ h.inv x = |/ x
</pre>

<DT><span class="strong">subgroup_inv_closure</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ âˆ€x y. x âˆˆ H âˆ§ y âˆˆ H â‡’ x * |/ y âˆˆ H
</pre>

<DT><span class="strong">subgroup_is_group</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ Group h
</pre>

<DT><span class="strong">subgroup_is_submonoid</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ h << g
</pre>

<DT><span class="strong">subgroup_is_submonoid0</span>
<DD>
<pre>
âŠ¢ âˆ€g h. Group g âˆ§ Group h âˆ§ subgroup h g â‡’ submonoid h g
</pre>

<DT><span class="strong">subgroup_op</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ h.op = $*
</pre>

<DT><span class="strong">subgroup_order</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ âˆ€x. x âˆˆ H â‡’ order h x = ord x
</pre>

<DT><span class="strong">subgroup_order_eqn</span>
<DD>
<pre>
âŠ¢ âˆ€g h. Group g âˆ§ Group h âˆ§ subgroup h g â‡’ âˆ€x. x âˆˆ H â‡’ order h x = ord x
</pre>

<DT><span class="strong">subgroup_property</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ Group h âˆ§ Group g âˆ§ âˆ€x y. x âˆˆ H âˆ§ y âˆˆ H â‡’ h.op x y = x * y
</pre>

<DT><span class="strong">subgroup_property_all</span>
<DD>
<pre>
âŠ¢ âˆ€g h.
    h â‰¤ g â‡’
    Group g âˆ§ Group h âˆ§ H â‰  âˆ… âˆ§ H âŠ† G âˆ§ h.op = $* âˆ§ h.id = #e âˆ§
    (âˆ€x. x âˆˆ H â‡’ h.inv x = |/ x) âˆ§ âˆ€x y. x âˆˆ H âˆ§ y âˆˆ H â‡’ x * |/ y âˆˆ H
</pre>

<DT><span class="strong">subgroup_refl</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ g â‰¤ g
</pre>

<DT><span class="strong">subgroup_reflexive</span>
<DD>
<pre>
âŠ¢ âˆ€g. subgroup g g
</pre>

<DT><span class="strong">subgroup_subset</span>
<DD>
<pre>
âŠ¢ âˆ€g h. subgroup h g â‡’ H âŠ† G
</pre>

<DT><span class="strong">subgroup_test_by_cross</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€h. h â‰¤ g â‡” H â‰  âˆ… âˆ§ H âŠ† G âˆ§ h âˆ˜ h = h âˆ§ IMAGE |/ H = H
</pre>

<DT><span class="strong">subgroup_thm</span>
<DD>
<pre>
âŠ¢ âˆ€g h.
    h â‰¤ g â‡”
    Group g âˆ§ h.op = $* âˆ§ h.id = #e âˆ§ H â‰  âˆ… âˆ§ H âŠ† G âˆ§
    âˆ€x y. x âˆˆ H âˆ§ y âˆˆ H â‡’ x * |/ y âˆˆ H
</pre>

<DT><span class="strong">subgroup_to_coset_bij</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ âˆ€a. a âˆˆ G â‡’ BIJ (Î»x. a * x) H (a * H)
</pre>

<DT><span class="strong">subgroup_trans</span>
<DD>
<pre>
âŠ¢ âˆ€g h t. h â‰¤ t âˆ§ t â‰¤ g â‡’ h â‰¤ g
</pre>

<DT><span class="strong">subgroup_transitive</span>
<DD>
<pre>
âŠ¢ âˆ€g h k. subgroup g h âˆ§ subgroup h k â‡’ subgroup g k
</pre>

<DT><span class="strong">subset_big_cross_empty</span>
<DD>
<pre>
âŠ¢ âˆ€g. ssbcross âˆ… = {#e}
</pre>

<DT><span class="strong">subset_big_cross_insert</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteAbelianGroup g â‡’
      âˆ€B. B âŠ† POW G â‡’
          âˆ€s. s âŠ† G âˆ§ s âˆ‰ B â‡’ ssbcross (s INSERT B) = s âˆ˜ ssbcross B
</pre>

<DT><span class="strong">subset_big_cross_thm</span>
<DD>
<pre>
âŠ¢ âˆ€g. FiniteAbelianGroup g â‡’
      âˆ€B. B âŠ† POW G â‡’
          âˆ€s. s âŠ† G â‡’ ssbcross (s INSERT B) = s âˆ˜ ssbcross (B DELETE s)
</pre>

<DT><span class="strong">subset_cross_alt</span>
<DD>
<pre>
âŠ¢ âˆ€g s1 s2. s1 âˆ˜ s2 = IMAGE (Î»(x,y). x * y) (s1 Ã— s2)
</pre>

<DT><span class="strong">subset_cross_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’
      âˆ€s1 s2 s3. s1 âŠ† G âˆ§ s2 âŠ† G âˆ§ s3 âŠ† G â‡’ (s1 âˆ˜ s2) âˆ˜ s3 = s1 âˆ˜ s2 âˆ˜ s3
</pre>

<DT><span class="strong">subset_cross_closure_comm_assoc_fun</span>
<DD>
<pre>
âŠ¢ âˆ€g. AbelianGroup g â‡’ closure_comm_assoc_fun $o (POW G)
</pre>

<DT><span class="strong">subset_cross_comm</span>
<DD>
<pre>
âŠ¢ âˆ€g. AbelianGroup g â‡’ âˆ€s1 s2. s1 âŠ† G âˆ§ s2 âŠ† G â‡’ s1 âˆ˜ s2 = s2 âˆ˜ s1
</pre>

<DT><span class="strong">subset_cross_element</span>
<DD>
<pre>
âŠ¢ âˆ€g s1 s2 x y. x âˆˆ s1 âˆ§ y âˆˆ s2 â‡’ x * y âˆˆ s1 âˆ˜ s2
</pre>

<DT><span class="strong">subset_cross_element_iff</span>
<DD>
<pre>
âŠ¢ âˆ€g s1 s2 z. z âˆˆ s1 âˆ˜ s2 â‡” âˆƒx y. x âˆˆ s1 âˆ§ y âˆˆ s2 âˆ§ z = x * y
</pre>

<DT><span class="strong">subset_cross_element_preimage_card</span>
<DD>
<pre>
âŠ¢ âˆ€g h1 h2.
    h1 â‰¤ g âˆ§ h2 â‰¤ g âˆ§ FINITE G â‡’
    (let
       s1 = h1.carrier;
       s2 = h2.carrier;
       f (x,y) = x * y
     in
       âˆ€z. z âˆˆ s1 âˆ˜ s2 â‡’ CARD (preimage f (s1 Ã— s2) z) = CARD (s1 âˆ© s2))
</pre>

<DT><span class="strong">subset_cross_finite</span>
<DD>
<pre>
âŠ¢ âˆ€g s1 s2. FINITE s1 âˆ§ FINITE s2 â‡’ FINITE (s1 âˆ˜ s2)
</pre>

<DT><span class="strong">subset_cross_inv</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’
      âˆ€s1 s2. s1 âŠ† G âˆ§ s2 âŠ† G â‡’ IMAGE |/ (s1 âˆ˜ s2) = IMAGE |/ s2 âˆ˜ IMAGE |/ s1
</pre>

<DT><span class="strong">subset_cross_partition_property</span>
<DD>
<pre>
âŠ¢ âˆ€g h1 h2.
    h1 â‰¤ g âˆ§ h2 â‰¤ g âˆ§ FINITE G â‡’
    (let
       s1 = h1.carrier;
       s2 = h2.carrier;
       f (x,y) = x * y
     in
       âˆ€t. t âˆˆ partition (feq f) (s1 Ã— s2) â‡’ CARD t = CARD (s1 âˆ© s2))
</pre>

<DT><span class="strong">subset_cross_preimage_inj</span>
<DD>
<pre>
âŠ¢ âˆ€g s1 s2.
    INJ (preimage (Î»(x,y). x * y) (s1 Ã— s2)) (s1 âˆ˜ s2) ð•Œ(:Î± # Î± -> bool)
</pre>

<DT><span class="strong">subset_cross_self</span>
<DD>
<pre>
âŠ¢ âˆ€g h. h â‰¤ g â‡’ H âˆ˜ H = H
</pre>

<DT><span class="strong">subset_cross_subset</span>
<DD>
<pre>
âŠ¢ âˆ€g. Group g â‡’ âˆ€s1 s2. s1 âŠ† G âˆ§ s2 âŠ† G â‡’ s1 âˆ˜ s2 âŠ† G
</pre>

<DT><span class="strong">subset_cross_to_preimage_cross_bij</span>
<DD>
<pre>
âŠ¢ âˆ€g h1 h2.
    h1 â‰¤ g âˆ§ h2 â‰¤ g â‡’
    (let
       s1 = h1.carrier;
       s2 = h2.carrier;
       f (x,y) = x * y
     in
       âˆ€z. z âˆˆ s1 âˆ˜ s2 â‡’
           BIJ (Î»d. (left z * d,|/ d * right z)) (s1 âˆ© s2)
             (preimage f (s1 Ã— s2) z))
</pre>

<DT><span class="strong">subset_group_exp</span>
<DD>
<pre>
âŠ¢ âˆ€g s x. x âˆˆ s â‡’ âˆ€n. (subset_group g s).exp x n = x ** n
</pre>

<DT><span class="strong">subset_group_order</span>
<DD>
<pre>
âŠ¢ âˆ€g s x. x âˆˆ s â‡’ order (subset_group g s) x = ord x
</pre>

<DT><span class="strong">subset_group_property</span>
<DD>
<pre>
âŠ¢ âˆ€g s.
    (subset_group g s).carrier = s âˆ§ (subset_group g s).op = $* âˆ§
    (subset_group g s).id = #e
</pre>

<DT><span class="strong">subset_group_subgroup</span>
<DD>
<pre>
âŠ¢ âˆ€g s.
    Group g âˆ§ s â‰  âˆ… âˆ§ s âŠ† G âˆ§ (âˆ€x y. x âˆˆ s âˆ§ y âˆˆ s â‡’ x * |/ y âˆˆ s) â‡’
    subset_group g s â‰¤ g
</pre>

<DT><span class="strong">subset_group_submonoid</span>
<DD>
<pre>
âŠ¢ âˆ€g s.
    Monoid g âˆ§ #e âˆˆ s âˆ§ s âŠ† G âˆ§ (âˆ€x y. x âˆˆ s âˆ§ y âˆˆ s â‡’ x * y âˆˆ s) â‡’
    subset_group g s << g
</pre>

<DT><span class="strong">subset_preimage_image</span>
<DD>
<pre>
âŠ¢ âˆ€f g1 g2 h.
    Group g1 âˆ§ Group g2 âˆ§ h â‰¤ g1 âˆ§ GroupHomo f g1 g2 â‡’
    H âŠ† PREIMAGE f (IMAGE f H) âˆ© g1.carrier
</pre>

<DT><span class="strong">sum_image_as_op_image</span>
<DD>
<pre>
âŠ¢ âˆ‘ = OP_IMAGE (Î»x y. x + y) 0
</pre>

<DT><span class="strong">symdiff_set_abelian_group</span>
<DD>
<pre>
âŠ¢ AbelianGroup symdiff_set
</pre>

<DT><span class="strong">symdiff_set_group</span>
<DD>
<pre>
âŠ¢ Group symdiff_set
</pre>

<DT><span class="strong">target_card_and_fixed_points_congruence</span>
<DD>
<pre>
âŠ¢ âˆ€f g X n.
    Group g âˆ§ (g act X) f âˆ§ FINITE X âˆ§ 0 < n âˆ§
    (âˆ€e. e âˆˆ multi_orbits f g X â‡’ CARD e = n) â‡’
    CARD X MOD n = CARD (fixed_points f g X) MOD n
</pre>

<DT><span class="strong">target_card_by_fixed_points</span>
<DD>
<pre>
âŠ¢ âˆ€f g X.
    Group g âˆ§ (g act X) f âˆ§ FINITE X â‡’
    CARD X = CARD (fixed_points f g X) + âˆ‘ CARD (multi_orbits f g X)
</pre>

<DT><span class="strong">target_card_by_orbit_types</span>
<DD>
<pre>
âŠ¢ âˆ€f g X.
    Group g âˆ§ (g act X) f âˆ§ FINITE X â‡’
    CARD X = CARD (sing_orbits f g X) + âˆ‘ CARD (multi_orbits f g X)
</pre>

<DT><span class="strong">target_card_by_partition</span>
<DD>
<pre>
âŠ¢ âˆ€f g X. Group g âˆ§ (g act X) f âˆ§ FINITE X â‡’ CARD X = âˆ‘ CARD (orbits f g X)
</pre>

<DT><span class="strong">target_orbits_disjoint</span>
<DD>
<pre>
âŠ¢ âˆ€f g X. DISJOINT (sing_orbits f g X) (multi_orbits f g X)
</pre>

<DT><span class="strong">target_orbits_union</span>
<DD>
<pre>
âŠ¢ âˆ€f g X. orbits f g X = sing_orbits f g X âˆª multi_orbits f g X
</pre>

<DT><span class="strong">trivial_group</span>
<DD>
<pre>
âŠ¢ âˆ€e. FiniteAbelianGroup (trivial_group e)
</pre>

<DT><span class="strong">trivial_group_carrier</span>
<DD>
<pre>
âŠ¢ âˆ€e. (trivial_group e).carrier = {e}
</pre>

<DT><span class="strong">trivial_group_id</span>
<DD>
<pre>
âŠ¢ âˆ€e. (trivial_group e).id = e
</pre>

</DL>



<hr>
</body>
</html>
