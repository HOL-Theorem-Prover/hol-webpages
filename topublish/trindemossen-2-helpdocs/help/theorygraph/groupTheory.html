<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: group</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "group"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "monoidTheory.html"><span class="strong">monoid</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">AbelianGroup</span>
    <td>
    :α monoid -> bool
    <tr><td>
    <span class="strong">CosetPartition</span>
    <td>
    :α monoid -> α monoid -> (α -> bool) -> bool
    <tr><td>
    <span class="strong">ElGamal_decrypt</span>
    <td>
    :α monoid -> num -> α # α -> α
    <tr><td>
    <span class="strong">ElGamal_encrypt</span>
    <td>
    :α monoid -> α -> α -> α -> num -> α # α
    <tr><td> <span class="strong">Estar</span> <td> :num -> num monoid
    <tr><td>
    <span class="strong">FiniteAbelianGroup</span>
    <td>
    :α monoid -> bool
    <tr><td> <span class="strong">FiniteGroup</span> <td> :α monoid -> bool
    <tr><td> <span class="strong">GFACT</span> <td> :α monoid -> α
    <tr><td>
    <span class="strong">GROUP_IMAGE</span>
    <td>
    :α monoid -> (β -> α) -> (β -> bool) -> α
    <tr><td>
    <span class="strong">Generated</span>
    <td>
    :α monoid -> α -> α monoid
    <tr><td>
    <span class="strong">Generated_subset</span>
    <td>
    :α monoid -> (α -> bool) -> α monoid
    <tr><td> <span class="strong">Group</span> <td> :α monoid -> bool
    <tr><td>
    <span class="strong">GroupAuto</span>
    <td>
    :(α -> α) -> α monoid -> bool
    <tr><td>
    <span class="strong">GroupEndo</span>
    <td>
    :(α -> α) -> α monoid -> bool
    <tr><td>
    <span class="strong">GroupHomo</span>
    <td>
    :(α -> β) -> α monoid -> β monoid -> bool
    <tr><td>
    <span class="strong">GroupIso</span>
    <td>
    :(α -> β) -> α monoid -> β monoid -> bool
    <tr><td>
    <span class="strong">OP_IMAGE</span>
    <td>
    :(α -> α -> α) -> α -> (β -> α) -> (β -> bool) -> α
    <tr><td>
    <span class="strong">StabilizerGroup</span>
    <td>
    :(α -> β -> β) -> α monoid -> β -> α monoid
    <tr><td>
    <span class="strong">Subgroup</span>
    <td>
    :α monoid -> α monoid -> bool
    <tr><td> <span class="strong">Zadd</span> <td> :num -> num monoid
    <tr><td> <span class="strong">Zstar</span> <td> :num -> num monoid
    <tr><td>
    <span class="strong">act_by</span>
    <td>
    :(α -> β -> β) -> α monoid -> β -> β -> α
    <tr><td>
    <span class="strong">action</span>
    <td>
    :(α -> β -> β) -> α monoid -> (β -> bool) -> bool
    <tr><td> <span class="strong">add_mod</span> <td> :num -> num monoid
    <tr><td>
    <span class="strong">all_subgroups</span>
    <td>
    :α monoid -> α monoid -> bool
    <tr><td>
    <span class="strong">cogen</span>
    <td>
    :α monoid -> α monoid -> (α -> bool) -> α
    <tr><td>
    <span class="strong">conjugate</span>
    <td>
    :α monoid -> α -> (α -> bool) -> α -> bool
    <tr><td>
    <span class="strong">conjugate_subgroup</span>
    <td>
    :α monoid -> α monoid -> α -> α monoid
    <tr><td>
    <span class="strong">coset</span>
    <td>
    :α monoid -> α -> (α -> bool) -> α -> bool
    <tr><td>
    <span class="strong">coset_op</span>
    <td>
    :α monoid -> α monoid -> (α -> bool) -> (α -> bool) -> α -> bool
    <tr><td> <span class="strong">cyclic</span> <td> :α monoid -> bool
    <tr><td> <span class="strong">cyclic_gen</span> <td> :α monoid -> α
    <tr><td>
    <span class="strong">cyclic_generators</span>
    <td>
    :α monoid -> α -> bool
    <tr><td>
    <span class="strong">cyclic_index</span>
    <td>
    :α monoid -> α -> num
    <tr><td>
    <span class="strong">eq_order</span>
    <td>
    :α monoid -> α -> α -> bool
    <tr><td>
    <span class="strong">excluding</span>
    <td>
    :α monoid -> α -> α monoid
    <tr><td>
    <span class="strong">fixed_points</span>
    <td>
    :(α -> β -> β) -> α monoid -> (β -> bool) -> β -> bool
    <tr><td>
    <span class="strong">fn_cyclic_group</span>
    <td>
    :α -> (α -> α) -> α monoid
    <tr><td>
    <span class="strong">group_div</span>
    <td>
    :α monoid -> α -> α -> α
    <tr><td>
    <span class="strong">group_equiv</span>
    <td>
    :α monoid -> α monoid -> α -> α -> bool
    <tr><td>
    <span class="strong">group_fun</span>
    <td>
    :α monoid -> (α -> α) -> bool
    <tr><td>
    <span class="strong">homo_image</span>
    <td>
    :(α -> β) -> α monoid -> β monoid -> β monoid
    <tr><td>
    <span class="strong">inCoset</span>
    <td>
    :α monoid -> α monoid -> α -> α -> bool
    <tr><td>
    <span class="strong">including</span>
    <td>
    :α monoid -> α -> α monoid
    <tr><td>
    <span class="strong">kernel</span>
    <td>
    :(α -> β) -> α monoid -> β monoid -> α -> bool
    <tr><td>
    <span class="strong">kernel_group</span>
    <td>
    :(α -> β) -> α monoid -> β monoid -> α monoid
    <tr><td>
    <span class="strong">left_coset</span>
    <td>
    :α monoid -> (α -> bool) -> α -> α -> bool
    <tr><td>
    <span class="strong">make_group</span>
    <td>
    :α monoid -> (α -> bool) -> α monoid
    <tr><td> <span class="strong">mult_mod</span> <td> :num -> num monoid
    <tr><td>
    <span class="strong">multi_orbits</span>
    <td>
    :(α -> β -> β) -> α monoid -> (β -> bool) -> (β -> bool) -> bool
    <tr><td>
    <span class="strong">normal_subgroup</span>
    <td>
    :α monoid -> α monoid -> bool
    <tr><td>
    <span class="strong">orbit</span>
    <td>
    :(α -> β -> β) -> α monoid -> β -> β -> bool
    <tr><td>
    <span class="strong">orbits</span>
    <td>
    :(α -> β -> β) -> α monoid -> (β -> bool) -> (β -> bool) -> bool
    <tr><td>
    <span class="strong">preimage_group</span>
    <td>
    :(α -> β) -> α monoid -> β monoid -> (β -> bool) -> α monoid
    <tr><td>
    <span class="strong">quotient_group</span>
    <td>
    :α monoid -> α monoid -> (α -> bool) monoid
    <tr><td>
    <span class="strong">reach</span>
    <td>
    :(α -> β -> β) -> α monoid -> β -> β -> bool
    <tr><td>
    <span class="strong">right_coset</span>
    <td>
    :α monoid -> (α -> bool) -> α -> α -> bool
    <tr><td>
    <span class="strong">roots_of_unity</span>
    <td>
    :α monoid -> num -> α monoid
    <tr><td>
    <span class="strong">sing_orbits</span>
    <td>
    :(α -> β -> β) -> α monoid -> (β -> bool) -> (β -> bool) -> bool
    <tr><td>
    <span class="strong">stabilizer</span>
    <td>
    :(α -> β -> β) -> α monoid -> β -> α -> bool
    <tr><td>
    <span class="strong">subgroup</span>
    <td>
    :α monoid -> α monoid -> bool
    <tr><td>
    <span class="strong">subgroup_big_cross</span>
    <td>
    :α monoid -> (α monoid -> bool) -> α monoid
    <tr><td>
    <span class="strong">subgroup_big_intersect</span>
    <td>
    :α monoid -> α monoid
    <tr><td>
    <span class="strong">subgroup_cross</span>
    <td>
    :α monoid -> α monoid -> α monoid -> α monoid
    <tr><td>
    <span class="strong">subset_big_cross</span>
    <td>
    :α monoid -> ((α -> bool) -> bool) -> α -> bool
    <tr><td>
    <span class="strong">subset_cross</span>
    <td>
    :α monoid -> (α -> bool) -> (α -> bool) -> α -> bool
    <tr><td>
    <span class="strong">subset_cross_left</span>
    <td>
    :α monoid -> (α -> bool) -> (α -> bool) -> α -> α
    <tr><td>
    <span class="strong">subset_cross_right</span>
    <td>
    :α monoid -> (α -> bool) -> (α -> bool) -> α -> α
    <tr><td>
    <span class="strong">subset_group</span>
    <td>
    :α monoid -> (α -> bool) -> α monoid
    <tr><td>
    <span class="strong">symdiff</span>
    <td>
    :(α -> bool) -> (α -> bool) -> α -> bool
    <tr><td> <span class="strong">symdiff_set</span> <td> :(α -> bool) monoid
    <tr><td> <span class="strong">trivial_group</span> <td> :α -> α monoid
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">AbelianGroup_def</span>
<DD>
<pre>
⊢ ∀g. AbelianGroup g ⇔ Group g ∧ ∀x y. x ∈ G ∧ y ∈ G ⇒ x * y = y * x
</pre>

<DT><span class="strong">CosetPartition_def</span>
<DD>
<pre>
⊢ ∀g h. CosetPartition g h = partition (inCoset g h) G
</pre>

<DT><span class="strong">ElGamal_decrypt_def</span>
<DD>
<pre>
⊢ ∀g x a b. ElGamal_decrypt g x (a,b) = |/ (a ** x) * b
</pre>

<DT><span class="strong">ElGamal_encrypt_def</span>
<DD>
<pre>
⊢ ∀g y h m k. ElGamal_encrypt g y h m k = (y ** k,h ** k * m)
</pre>

<DT><span class="strong">Estar_def</span>
<DD>
<pre>
⊢ ∀n. Estar n = <|carrier := Euler n; id := 1; op := (λi j. (i * j) MOD n)|>
</pre>

<DT><span class="strong">FiniteAbelianGroup_def</span>
<DD>
<pre>
⊢ ∀g. FiniteAbelianGroup g ⇔ AbelianGroup g ∧ FINITE G
</pre>

<DT><span class="strong">FiniteGroup_def</span>
<DD>
<pre>
⊢ ∀g. FiniteGroup g ⇔ Group g ∧ FINITE G
</pre>

<DT><span class="strong">GFACT_def</span>
<DD>
<pre>
⊢ ∀g. GFACT g = GPROD_SET g G
</pre>

<DT><span class="strong">GROUP_IMAGE_def</span>
<DD>
<pre>
⊢ ∀g f s. GROUP_IMAGE g f s = ITSET (λe acc. f e * acc) s #e
</pre>

<DT><span class="strong">Generated_def</span>
<DD>
<pre>
⊢ ∀g a. gen a = <|carrier := {x | ∃k. x = a ** k}; op := $*; id := #e|>
</pre>

<DT><span class="strong">Generated_subset_def</span>
<DD>
<pre>
⊢ ∀g s.
    gen_set s =
    <|carrier := BIGINTER (IMAGE (λh. H) {h | h ≤ g ∧ s ⊆ H}); op := $*;
      id := #e|>
</pre>

<DT><span class="strong">GroupAuto_def</span>
<DD>
<pre>
⊢ ∀f g. GroupAuto f g ⇔ GroupIso f g g
</pre>

<DT><span class="strong">GroupEndo_def</span>
<DD>
<pre>
⊢ ∀f g. GroupEndo f g ⇔ GroupHomo f g g
</pre>

<DT><span class="strong">GroupHomo_def</span>
<DD>
<pre>
⊢ ∀f g h.
    GroupHomo f g h ⇔
    (∀x. x ∈ G ⇒ f x ∈ h.carrier) ∧
    ∀x y. x ∈ G ∧ y ∈ G ⇒ f (x * y) = h.op (f x) (f y)
</pre>

<DT><span class="strong">GroupIso_def</span>
<DD>
<pre>
⊢ ∀f g h. GroupIso f g h ⇔ GroupHomo f g h ∧ BIJ f G h.carrier
</pre>

<DT><span class="strong">Group_def</span>
<DD>
<pre>
⊢ ∀g. Group g ⇔ Monoid g ∧ G* = G
</pre>

<DT><span class="strong">OP_IMAGE_def</span>
<DD>
<pre>
⊢ ∀op id f s. OP_IMAGE op id f s = ITSET (λe acc. op (f e) acc) s id
</pre>

<DT><span class="strong">StabilizerGroup_def</span>
<DD>
<pre>
⊢ ∀f g x.
    StabilizerGroup f g x =
    <|carrier := stabilizer f g x; op := $*; id := #e|>
</pre>

<DT><span class="strong">Subgroup_def</span>
<DD>
<pre>
⊢ ∀h g. h ≤ g ⇔ Group h ∧ Group g ∧ H ⊆ G ∧ h.op = $*
</pre>

<DT><span class="strong">Zadd_def</span>
<DD>
<pre>
⊢ ∀n. Zadd n = <|carrier := count n; id := 0; op := (λi j. (i + j) MOD n)|>
</pre>

<DT><span class="strong">Zstar_def</span>
<DD>
<pre>
⊢ ∀p. Zstar p = <|carrier := residue p; id := 1; op := (λi j. (i * j) MOD p)|>
</pre>

<DT><span class="strong">act_by_def</span>
<DD>
<pre>
⊢ ∀f g x y. reach f g x y ⇒ act_by f g x y ∈ G ∧ f (act_by f g x y) x = y
</pre>

<DT><span class="strong">action_def</span>
<DD>
<pre>
⊢ ∀f g X.
    (g act X) f ⇔
    ∀x. x ∈ X ⇒
        (∀a. a ∈ G ⇒ f a x ∈ X) ∧ f #e x = x ∧
        ∀a b. a ∈ G ∧ b ∈ G ⇒ f a (f b x) = f (a * b) x
</pre>

<DT><span class="strong">add_mod_def</span>
<DD>
<pre>
⊢ ∀n. add_mod n =
      <|carrier := {i | i < n}; id := 0; op := (λi j. (i + j) MOD n)|>
</pre>

<DT><span class="strong">all_subgroups_def</span>
<DD>
<pre>
⊢ ∀g. all_subgroups g = {h | h ≤ g}
</pre>

<DT><span class="strong">cogen_def</span>
<DD>
<pre>
⊢ ∀g h e.
    h ≤ g ∧ e ∈ CosetPartition g h ⇒ cogen g h e ∈ G ∧ e = cogen g h e * H
</pre>

<DT><span class="strong">conjugate_def</span>
<DD>
<pre>
⊢ ∀g a s. conjugate g a s = {a * z * |/ a | z ∈ s}
</pre>

<DT><span class="strong">conjugate_subgroup_def</span>
<DD>
<pre>
⊢ ∀h g a.
    conjugate_subgroup h g a =
    <|carrier := conjugate g a H; id := #e; op := $* |>
</pre>

<DT><span class="strong">coset_def</span>
<DD>
<pre>
⊢ ∀g a X. a * X = IMAGE (λz. a * z) X
</pre>

<DT><span class="strong">coset_op_def</span>
<DD>
<pre>
⊢ ∀g h x y. x ∘ y = cogen g h x * cogen g h y * H
</pre>

<DT><span class="strong">cyclic_def</span>
<DD>
<pre>
⊢ ∀g. cyclic g ⇔ Group g ∧ ∃z. z ∈ G ∧ ∀x. x ∈ G ⇒ ∃n. x = z ** n
</pre>

<DT><span class="strong">cyclic_gen_def</span>
<DD>
<pre>
⊢ ∀g. cyclic g ⇒ cyclic_gen g ∈ G ∧ ∀x. x ∈ G ⇒ ∃n. x = cyclic_gen g ** n
</pre>

<DT><span class="strong">cyclic_generators_def</span>
<DD>
<pre>
⊢ ∀g. cyclic_generators g = {z | z ∈ G ∧ ord z = CARD G}
</pre>

<DT><span class="strong">cyclic_index_def</span>
<DD>
<pre>
⊢ ∀g x.
    cyclic g ∧ x ∈ G ⇒
    x = cyclic_gen g ** cyclic_index g x ∧
    (FINITE G ⇒ cyclic_index g x < CARD G)
</pre>

<DT><span class="strong">eq_order_def</span>
<DD>
<pre>
⊢ ∀g x y. eq_order g x y ⇔ ord x = ord y
</pre>

<DT><span class="strong">excluding_def</span>
<DD>
<pre>
⊢ ∀g z. g excluding z = <|carrier := G DIFF {z}; op := $*; id := #e|>
</pre>

<DT><span class="strong">fixed_points_def</span>
<DD>
<pre>
⊢ ∀f g X. fixed_points f g X = {x | x ∈ X ∧ ∀a. a ∈ G ⇒ f a x = x}
</pre>

<DT><span class="strong">fn_cyclic_group_def</span>
<DD>
<pre>
⊢ ∀e f.
    fn_cyclic_group e f =
    <|carrier := {x | ∃n. FUNPOW f n e = x}; id := e;
      op :=
        (λx y.
             @z. ∀xi yi.
               FUNPOW f xi e = x ∧ FUNPOW f yi e = y ⇒
               FUNPOW f (xi + yi) e = z)|>
</pre>

<DT><span class="strong">group_div_def</span>
<DD>
<pre>
⊢ ∀g x y. x / y = x * |/ y
</pre>

<DT><span class="strong">group_equiv_def</span>
<DD>
<pre>
⊢ ∀g h x y. x == y ⇔ x / y ∈ H
</pre>

<DT><span class="strong">group_fun_def</span>
<DD>
<pre>
⊢ ∀g f. group_fun g f ⇔ ∀x. x ∈ G ⇒ f x ∈ G
</pre>

<DT><span class="strong">homo_image_def</span>
<DD>
<pre>
⊢ ∀f g h. homo_image f g h = <|carrier := IMAGE f G; op := h.op; id := h.id|>
</pre>

<DT><span class="strong">inCoset_def</span>
<DD>
<pre>
⊢ ∀g h a b. inCoset g h a b ⇔ b ∈ a * H
</pre>

<DT><span class="strong">including_def</span>
<DD>
<pre>
⊢ ∀g z. g including z = <|carrier := G ∪ {z}; op := $*; id := #e|>
</pre>

<DT><span class="strong">kernel_def</span>
<DD>
<pre>
⊢ ∀f g h. kernel f g h = preimage f G h.id
</pre>

<DT><span class="strong">kernel_group_def</span>
<DD>
<pre>
⊢ ∀f g h.
    kernel_group f g h = <|carrier := kernel f g h; id := #e; op := $* |>
</pre>

<DT><span class="strong">left_coset_def</span>
<DD>
<pre>
⊢ ∀g X a. left_coset g X a = a * X
</pre>

<DT><span class="strong">make_group_def</span>
<DD>
<pre>
⊢ ∀g s. make_group g s = <|carrier := s; op := $*; id := #e|>
</pre>

<DT><span class="strong">mult_mod_def</span>
<DD>
<pre>
⊢ ∀p. mult_mod p =
      <|carrier := {i | i ≠ 0 ∧ i < p}; id := 1; op := (λi j. (i * j) MOD p)|>
</pre>

<DT><span class="strong">multi_orbits_def</span>
<DD>
<pre>
⊢ ∀f g X. multi_orbits f g X = {e | e ∈ orbits f g X ∧ ¬SING e}
</pre>

<DT><span class="strong">normal_subgroup_def</span>
<DD>
<pre>
⊢ ∀h g. h << g ⇔ h ≤ g ∧ ∀a z. a ∈ G ∧ z ∈ H ⇒ a * z / a ∈ H
</pre>

<DT><span class="strong">orbit_def</span>
<DD>
<pre>
⊢ ∀f g x. orbit f g x = IMAGE (λa. f a x) G
</pre>

<DT><span class="strong">orbits_def</span>
<DD>
<pre>
⊢ ∀f g X. orbits f g X = IMAGE (orbit f g) X
</pre>

<DT><span class="strong">preimage_group_def</span>
<DD>
<pre>
⊢ ∀f g1 g2 h.
    preimage_group f g1 g2 h =
    <|carrier := PREIMAGE f h ∩ g1.carrier; op := g1.op; id := g1.id|>
</pre>

<DT><span class="strong">quotient_group_def</span>
<DD>
<pre>
⊢ ∀g h. g / h = <|carrier := CosetPartition g h; op := $o; id := H|>
</pre>

<DT><span class="strong">reach_def</span>
<DD>
<pre>
⊢ ∀f g x y. reach f g x y ⇔ ∃a. a ∈ G ∧ f a x = y
</pre>

<DT><span class="strong">right_coset_def</span>
<DD>
<pre>
⊢ ∀g X a. X * a = IMAGE (λz. z * a) X
</pre>

<DT><span class="strong">roots_of_unity_def</span>
<DD>
<pre>
⊢ ∀g n.
    uroots n = <|carrier := {x | x ∈ G ∧ x ** n = #e}; op := $*; id := #e|>
</pre>

<DT><span class="strong">sing_orbits_def</span>
<DD>
<pre>
⊢ ∀f g X. sing_orbits f g X = {e | e ∈ orbits f g X ∧ SING e}
</pre>

<DT><span class="strong">stabilizer_def</span>
<DD>
<pre>
⊢ ∀f g x. stabilizer f g x = {a | a ∈ G ∧ f a x = x}
</pre>

<DT><span class="strong">subgroup_big_cross_def</span>
<DD>
<pre>
⊢ ∀g B. sgbcross B = ITSET $o B (gen #e)
</pre>

<DT><span class="strong">subgroup_big_intersect_def</span>
<DD>
<pre>
⊢ ∀g. sgbINTER g =
      <|carrier := BIGINTER (IMAGE (λh. H) {h | h ≤ g}); op := $*; id := #e|>
</pre>

<DT><span class="strong">subgroup_cross_def</span>
<DD>
<pre>
⊢ ∀g h1 h2. h1 ∘ h2 = make_group g (h1.carrier ∘ h2.carrier)
</pre>

<DT><span class="strong">subgroup_def</span>
<DD>
<pre>
⊢ ∀h g. subgroup h g ⇔ GroupHomo I h g
</pre>

<DT><span class="strong">subset_big_cross_def</span>
<DD>
<pre>
⊢ ∀g B. ssbcross B = ITSET $o B {#e}
</pre>

<DT><span class="strong">subset_cross_def</span>
<DD>
<pre>
⊢ ∀g s1 s2. s1 ∘ s2 = {x * y | x ∈ s1 ∧ y ∈ s2}
</pre>

<DT><span class="strong">subset_cross_left_right_def</span>
<DD>
<pre>
⊢ ∀g s1 s2 z. z ∈ s1 ∘ s2 ⇒ left z ∈ s1 ∧ right z ∈ s2 ∧ z = left z * right z
</pre>

<DT><span class="strong">subset_group_def</span>
<DD>
<pre>
⊢ ∀g s. subset_group g s = <|carrier := s; op := $*; id := #e|>
</pre>

<DT><span class="strong">symdiff_def</span>
<DD>
<pre>
⊢ ∀s1 s2. symdiff s1 s2 = s1 ∪ s2 DIFF s1 ∩ s2
</pre>

<DT><span class="strong">symdiff_set_def</span>
<DD>
<pre>
⊢ symdiff_set = <|carrier := 𝕌(:α -> bool); id := ∅; op := symdiff|>
</pre>

<DT><span class="strong">trivial_group_def</span>
<DD>
<pre>
⊢ ∀e. trivial_group e = <|carrier := {e}; id := e; op := (λx y. e)|>
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">ElGamal_correctness</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒
      ∀(y::G) (h::G) (m::G) k x.
        h = y ** x ⇒ ElGamal_decrypt g x (ElGamal_encrypt g y h m k) = m
</pre>

<DT><span class="strong">Estar_alt</span>
<DD>
<pre>
⊢ ∀n. Estar n =
      <|carrier := {i | 0 < i ∧ i < n ∧ coprime n i}; id := 1;
        op := (λi j. (i * j) MOD n)|>
</pre>

<DT><span class="strong">Estar_card</span>
<DD>
<pre>
⊢ ∀n. CARD (Estar n).carrier = totient n
</pre>

<DT><span class="strong">Estar_card_alt</span>
<DD>
<pre>
⊢ ∀n. 1 < n ⇒ CARD (Estar n).carrier = phi n
</pre>

<DT><span class="strong">Estar_carrier</span>
<DD>
<pre>
⊢ ∀n. (Estar n).carrier = Euler n
</pre>

<DT><span class="strong">Estar_carrier_alt</span>
<DD>
<pre>
⊢ ∀n. (Estar n).carrier = {i | 0 < i ∧ i < n ∧ coprime n i}
</pre>

<DT><span class="strong">Estar_element</span>
<DD>
<pre>
⊢ ∀n x. x ∈ (Estar n).carrier ⇔ 0 < x ∧ x < n ∧ coprime n x
</pre>

<DT><span class="strong">Estar_eval</span>
<DD>
<pre>
⊢ ∀n. (Estar n).carrier = Euler n ∧ (∀x y. (Estar n).op x y = (x * y) MOD n) ∧
      (Estar n).id = 1
</pre>

<DT><span class="strong">Estar_exp</span>
<DD>
<pre>
⊢ ∀n a. 1 < n ∧ a ∈ (Estar n).carrier ⇒ ∀k. (Estar n).exp a k = a ** k MOD n
</pre>

<DT><span class="strong">Estar_finite</span>
<DD>
<pre>
⊢ ∀n. FINITE (Estar n).carrier
</pre>

<DT><span class="strong">Estar_finite_abelian_group</span>
<DD>
<pre>
⊢ ∀n. 1 < n ⇒ FiniteAbelianGroup (Estar n)
</pre>

<DT><span class="strong">Estar_finite_group</span>
<DD>
<pre>
⊢ ∀n. 1 < n ⇒ FiniteGroup (Estar n)
</pre>

<DT><span class="strong">Estar_group</span>
<DD>
<pre>
⊢ ∀n. 1 < n ⇒ Group (Estar n)
</pre>

<DT><span class="strong">Estar_id</span>
<DD>
<pre>
⊢ ∀n. (Estar n).id = 1
</pre>

<DT><span class="strong">Estar_inv</span>
<DD>
<pre>
⊢ ∀n a.
    1 < n ∧ a < n ∧ coprime n a ⇒ (Estar n).inv a = a ** (totient n − 1) MOD n
</pre>

<DT><span class="strong">Estar_inv_compute</span>
<DD>
<pre>
⊢ ∀n a.
    (Estar n).inv a =
    if 1 < n ∧ a < n ∧ coprime n a then a ** (totient n − 1) MOD n
    else FAIL ((Estar n).inv a) bad_element
</pre>

<DT><span class="strong">Estar_property</span>
<DD>
<pre>
⊢ ∀n. (Estar n).carrier = Euler n ∧ (Estar n).id = 1 ∧
      (∀x y. (Estar n).op x y = (x * y) MOD n) ∧ FINITE (Estar n).carrier ∧
      CARD (Estar n).carrier = totient n
</pre>

<DT><span class="strong">Euler_Fermat_alt</span>
<DD>
<pre>
⊢ ∀n a. 1 < n ∧ coprime a n ⇒ a ** totient n MOD n = 1
</pre>

<DT><span class="strong">Euler_Fermat_eqn</span>
<DD>
<pre>
⊢ ∀n a. 1 < n ∧ a < n ∧ coprime n a ⇒ a ** totient n MOD n = 1
</pre>

<DT><span class="strong">Euler_Fermat_thm</span>
<DD>
<pre>
⊢ ∀n a. 1 < n ∧ coprime n a ⇒ a ** totient n MOD n = 1
</pre>

<DT><span class="strong">Fermat_little_eqn</span>
<DD>
<pre>
⊢ ∀p a. prime p ⇒ a ** p MOD p = a MOD p
</pre>

<DT><span class="strong">Fermat_little_thm</span>
<DD>
<pre>
⊢ ∀p a. prime p ∧ 0 < a ∧ a < p ⇒ a ** (p − 1) MOD p = 1
</pre>

<DT><span class="strong">FiniteAbelianGroup_def_alt</span>
<DD>
<pre>
⊢ ∀g. FiniteAbelianGroup g ⇔
      FiniteGroup g ∧ ∀x y. x ∈ G ∧ y ∈ G ⇒ x * y = y * x
</pre>

<DT><span class="strong">GFACT_element</span>
<DD>
<pre>
⊢ ∀g. FiniteAbelianMonoid g ⇒ GFACT g ∈ G
</pre>

<DT><span class="strong">GFACT_identity</span>
<DD>
<pre>
⊢ ∀g a. FiniteAbelianGroup g ∧ a ∈ G ⇒ GFACT g = a ** CARD G * GFACT g
</pre>

<DT><span class="strong">GITSET_AS_ITSET</span>
<DD>
<pre>
⊢ ∀g. (λs b. GITSET g s b) = ITSET (λe acc. e * acc)
</pre>

<DT><span class="strong">GPROD_SET_AS_GROUP_IMAGE</span>
<DD>
<pre>
⊢ ∀g. GPROD_SET g = GROUP_IMAGE g I
</pre>

<DT><span class="strong">GPROD_SET_IMAGE</span>
<DD>
<pre>
⊢ ∀g a. Group g ∧ a ∈ G ⇒ GPROD_SET g (a * G) = GPROD_SET g G
</pre>

<DT><span class="strong">GPROD_SET_REDUCTION</span>
<DD>
<pre>
⊢ ∀g s.
    FiniteAbelianGroup g ∧ s ⊆ G ⇒
    ∀a::G.
      a ** CARD s * GPROD_SET g s * GPROD_SET g (a * (G DIFF s)) =
      GPROD_SET g G
</pre>

<DT><span class="strong">GPROD_SET_REDUCTION_INSERT</span>
<DD>
<pre>
⊢ ∀g s.
    FiniteAbelianGroup g ∧ s ⊆ G ⇒
    ∀a x::G.
      x ∉ s ⇒
      a * x * GPROD_SET g (a * (G DIFF (x INSERT s))) =
      GPROD_SET g (a * (G DIFF s))
</pre>

<DT><span class="strong">Generated_subset_exp</span>
<DD>
<pre>
⊢ ∀g s. (gen_set s).exp = $**
</pre>

<DT><span class="strong">Generated_subset_gen</span>
<DD>
<pre>
⊢ ∀g a. FiniteGroup g ∧ a ∈ G ⇒ gen_set (Gen a) = gen a
</pre>

<DT><span class="strong">Generated_subset_group</span>
<DD>
<pre>
⊢ ∀g s. Group g ∧ s ⊆ G ⇒ Group (gen_set s)
</pre>

<DT><span class="strong">Generated_subset_has_set</span>
<DD>
<pre>
⊢ ∀g s. s ⊆ (gen_set s).carrier
</pre>

<DT><span class="strong">Generated_subset_property</span>
<DD>
<pre>
⊢ ∀g s.
    (gen_set s).carrier = BIGINTER (IMAGE (λh. H) {h | h ≤ g ∧ s ⊆ H}) ∧
    (gen_set s).op = $* ∧ (gen_set s).id = #e
</pre>

<DT><span class="strong">Generated_subset_subgroup</span>
<DD>
<pre>
⊢ ∀g s. Group g ∧ s ⊆ G ⇒ gen_set s ≤ g
</pre>

<DT><span class="strong">Generated_subset_subset</span>
<DD>
<pre>
⊢ ∀g s. Group g ∧ s ⊆ G ⇒ (gen_set s).carrier ⊆ G
</pre>

<DT><span class="strong">Invertibles_inv</span>
<DD>
<pre>
⊢ ∀g x. Monoid g ∧ x ∈ G* ⇒ (Invertibles g).inv x = |/ x
</pre>

<DT><span class="strong">Lagrange_identity</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ∧ FINITE G ⇒ CARD G = CARD H * CARD (CosetPartition g h)
</pre>

<DT><span class="strong">Lagrange_identity_alt</span>
<DD>
<pre>
⊢ ∀g h.
    h ≤ g ∧ FINITE G ⇒ CARD G = CARD H * CARD (partition (left_coset g H) G)
</pre>

<DT><span class="strong">Lagrange_thm</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ∧ FINITE G ⇒ CARD H divides CARD G
</pre>

<DT><span class="strong">OP_IMAGE_EMPTY</span>
<DD>
<pre>
⊢ ∀op id f. OP_IMAGE op id f ∅ = id
</pre>

<DT><span class="strong">OP_IMAGE_SING</span>
<DD>
<pre>
⊢ ∀op id f x. OP_IMAGE op id f {x} = op (f x) id
</pre>

<DT><span class="strong">OP_IMAGE_THM</span>
<DD>
<pre>
⊢ ∀op id f.
    OP_IMAGE op id f ∅ = id ∧
    (FUN_COMM op f ⇒
     ∀s. FINITE s ⇒
         ∀e. OP_IMAGE op id f (e INSERT s) =
             op (f e) (OP_IMAGE op id f (s DELETE e)))
</pre>

<DT><span class="strong">PRIME_2</span>
<DD>
<pre>
⊢ prime 2
</pre>

<DT><span class="strong">PRIME_3</span>
<DD>
<pre>
⊢ prime 3
</pre>

<DT><span class="strong">PRIME_5</span>
<DD>
<pre>
⊢ prime 5
</pre>

<DT><span class="strong">PRIME_7</span>
<DD>
<pre>
⊢ prime 7
</pre>

<DT><span class="strong">SURJ_IMAGE_PREIMAGE</span>
<DD>
<pre>
⊢ ∀f a b. s ⊆ b ∧ SURJ f a b ⇒ IMAGE f (PREIMAGE f s ∩ a) = s
</pre>

<DT><span class="strong">Subgroup_homo_homo</span>
<DD>
<pre>
⊢ ∀g h k f. h ≤ g ∧ GroupHomo f g k ⇒ GroupHomo f h k
</pre>

<DT><span class="strong">Subgroup_subgroup</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ subgroup h g
</pre>

<DT><span class="strong">Zadd_card</span>
<DD>
<pre>
⊢ ∀n. CARD (Zadd n).carrier = n
</pre>

<DT><span class="strong">Zadd_carrier</span>
<DD>
<pre>
⊢ ∀n. (Zadd n).carrier = count n
</pre>

<DT><span class="strong">Zadd_carrier_alt</span>
<DD>
<pre>
⊢ ∀n. (Zadd n).carrier = {i | i < n}
</pre>

<DT><span class="strong">Zadd_element</span>
<DD>
<pre>
⊢ ∀n x. x ∈ (Zadd n).carrier ⇔ x < n
</pre>

<DT><span class="strong">Zadd_eval</span>
<DD>
<pre>
⊢ ∀n. (Zadd n).carrier = count n ∧ (∀x y. (Zadd n).op x y = (x + y) MOD n) ∧
      (Zadd n).id = 0
</pre>

<DT><span class="strong">Zadd_exp</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ ∀x m. (Zadd n).exp x m = (x * m) MOD n
</pre>

<DT><span class="strong">Zadd_finite</span>
<DD>
<pre>
⊢ ∀n. FINITE (Zadd n).carrier
</pre>

<DT><span class="strong">Zadd_finite_abelian_group</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ FiniteAbelianGroup (Zadd n)
</pre>

<DT><span class="strong">Zadd_finite_group</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ FiniteGroup (Zadd n)
</pre>

<DT><span class="strong">Zadd_group</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ Group (Zadd n)
</pre>

<DT><span class="strong">Zadd_id</span>
<DD>
<pre>
⊢ ∀n. (Zadd n).id = 0
</pre>

<DT><span class="strong">Zadd_inv</span>
<DD>
<pre>
⊢ ∀n x. 0 < n ∧ x < n ⇒ (Zadd n).inv x = (n − x) MOD n
</pre>

<DT><span class="strong">Zadd_inv_compute</span>
<DD>
<pre>
⊢ ∀n x.
    (Zadd n).inv x =
    if 0 < n ∧ x < n then (n − x) MOD n else FAIL ((Zadd n).inv x) bad_element
</pre>

<DT><span class="strong">Zadd_property</span>
<DD>
<pre>
⊢ ∀n. (∀x. x ∈ (Zadd n).carrier ⇔ x < n) ∧ (Zadd n).id = 0 ∧
      (∀x y. (Zadd n).op x y = (x + y) MOD n) ∧ FINITE (Zadd n).carrier ∧
      CARD (Zadd n).carrier = n
</pre>

<DT><span class="strong">Zstar_card</span>
<DD>
<pre>
⊢ ∀p. 0 < p ⇒ CARD (Zstar p).carrier = p − 1
</pre>

<DT><span class="strong">Zstar_carrier</span>
<DD>
<pre>
⊢ ∀p. (Zstar p).carrier = residue p
</pre>

<DT><span class="strong">Zstar_carrier_alt</span>
<DD>
<pre>
⊢ ∀p. (Zstar p).carrier = {i | 0 < i ∧ i < p}
</pre>

<DT><span class="strong">Zstar_element</span>
<DD>
<pre>
⊢ ∀p x. x ∈ (Zstar p).carrier ⇔ 0 < x ∧ x < p
</pre>

<DT><span class="strong">Zstar_eval</span>
<DD>
<pre>
⊢ ∀p. (Zstar p).carrier = residue p ∧
      (∀x y. (Zstar p).op x y = (x * y) MOD p) ∧ (Zstar p).id = 1
</pre>

<DT><span class="strong">Zstar_exp</span>
<DD>
<pre>
⊢ ∀p a. prime p ∧ a ∈ (Zstar p).carrier ⇒ ∀n. (Zstar p).exp a n = a ** n MOD p
</pre>

<DT><span class="strong">Zstar_finite</span>
<DD>
<pre>
⊢ ∀p. FINITE (Zstar p).carrier
</pre>

<DT><span class="strong">Zstar_finite_abelian_group</span>
<DD>
<pre>
⊢ ∀p. prime p ⇒ FiniteAbelianGroup (Zstar p)
</pre>

<DT><span class="strong">Zstar_finite_group</span>
<DD>
<pre>
⊢ ∀p. prime p ⇒ FiniteGroup (Zstar p)
</pre>

<DT><span class="strong">Zstar_group</span>
<DD>
<pre>
⊢ ∀p. prime p ⇒ Group (Zstar p)
</pre>

<DT><span class="strong">Zstar_id</span>
<DD>
<pre>
⊢ ∀p. (Zstar p).id = 1
</pre>

<DT><span class="strong">Zstar_inv</span>
<DD>
<pre>
⊢ ∀p. prime p ⇒
      ∀x. 0 < x ∧ x < p ⇒
          (Zstar p).inv x = (Zstar p).exp x (order (Zstar p) x − 1)
</pre>

<DT><span class="strong">Zstar_inv_compute</span>
<DD>
<pre>
⊢ ∀p x.
    (Zstar p).inv x =
    if prime p ∧ 0 < x ∧ x < p then (Zstar p).exp x (order (Zstar p) x − 1)
    else FAIL ((Zstar p).inv x) bad_element
</pre>

<DT><span class="strong">Zstar_inverse</span>
<DD>
<pre>
⊢ ∀p. prime p ⇒ ∀a. 0 < a ∧ a < p ⇒ (Zstar p).inv a = a ** (p − 2) MOD p
</pre>

<DT><span class="strong">Zstar_inverse_compute</span>
<DD>
<pre>
⊢ ∀p a.
    (Zstar p).inv a =
    if prime p ∧ 0 < a ∧ a < p then a ** (p − 2) MOD p else (Zstar p).inv a
</pre>

<DT><span class="strong">Zstar_property</span>
<DD>
<pre>
⊢ ∀p. (Zstar p).carrier = residue p ∧ (Zstar p).id = 1 ∧
      (∀x y. (Zstar p).op x y = (x * y) MOD p) ∧ FINITE (Zstar p).carrier ∧
      (0 < p ⇒ CARD (Zstar p).carrier = p − 1)
</pre>

<DT><span class="strong">abelian_group_is_abelian_monoid</span>
<DD>
<pre>
⊢ ∀g. AbelianGroup g ⇒ AbelianMonoid g
</pre>

<DT><span class="strong">abelian_group_order_common</span>
<DD>
<pre>
⊢ ∀g. AbelianGroup g ⇒
      ∀x y.
        x ∈ G ∧ y ∈ G ⇒
        ∃z. z ∈ G ∧ ord z * gcd (ord x) (ord y) = lcm (ord x) (ord y)
</pre>

<DT><span class="strong">abelian_group_order_common_coprime</span>
<DD>
<pre>
⊢ ∀g. AbelianGroup g ⇒
      ∀x y.
        x ∈ G ∧ y ∈ G ∧ coprime (ord x) (ord y) ⇒
        ∃z. z ∈ G ∧ ord z = ord x * ord y
</pre>

<DT><span class="strong">abelian_monoid_invertible_excluding</span>
<DD>
<pre>
⊢ ∀g. AbelianMonoid g ⇒ ∀z. z ∉ G* ⇒ monoid_invertibles (g excluding z) = G*
</pre>

<DT><span class="strong">abelian_subgroup_abelian</span>
<DD>
<pre>
⊢ ∀g h. AbelianGroup g ∧ h ≤ g ⇒ AbelianGroup h
</pre>

<DT><span class="strong">abelian_subgroup_cross_finite</span>
<DD>
<pre>
⊢ ∀g. AbelianGroup g ⇒
      ∀h1 h2.
        h1 ≤ g ∧ h2 ≤ g ∧ FiniteGroup h1 ∧ FiniteGroup h2 ⇒
        FiniteGroup (h1 ∘ h2)
</pre>

<DT><span class="strong">abelian_subgroup_cross_subgroup</span>
<DD>
<pre>
⊢ ∀g. AbelianGroup g ⇒ ∀h1 h2. h1 ≤ g ∧ h2 ≤ g ⇒ h1 ∘ h2 ≤ g
</pre>

<DT><span class="strong">action_closure</span>
<DD>
<pre>
⊢ ∀f g X. (g act X) f ⇒ ∀a x. a ∈ G ∧ x ∈ X ⇒ f a x ∈ X
</pre>

<DT><span class="strong">action_compose</span>
<DD>
<pre>
⊢ ∀f g X.
    (g act X) f ⇒ ∀a b x. a ∈ G ∧ b ∈ G ∧ x ∈ X ⇒ f a (f b x) = f (a * b) x
</pre>

<DT><span class="strong">action_id</span>
<DD>
<pre>
⊢ ∀f g X. (g act X) f ⇒ ∀x. x ∈ X ⇒ f #e x = x
</pre>

<DT><span class="strong">action_match_condition</span>
<DD>
<pre>
⊢ ∀f g X x.
    Group g ∧ (g act X) f ∧ x ∈ X ⇒
    ∀a b. a ∈ G ∧ b ∈ G ⇒ (f a x = f b x ⇔ |/ a * b ∈ stabilizer f g x)
</pre>

<DT><span class="strong">action_match_condition_alt</span>
<DD>
<pre>
⊢ ∀f g X x.
    Group g ∧ (g act X) f ∧ x ∈ X ⇒
    ∀a b::G. f a x = f b x ⇔ |/ a * b ∈ stabilizer f g x
</pre>

<DT><span class="strong">action_reachable_coset</span>
<DD>
<pre>
⊢ ∀f g X x y.
    Group g ∧ (g act X) f ∧ x ∈ X ∧ y ∈ orbit f g x ⇒
    act_by f g x y * stabilizer f g x = {a | a ∈ G ∧ f a x = y}
</pre>

<DT><span class="strong">action_reachable_coset_alt</span>
<DD>
<pre>
⊢ ∀f g X x y.
    Group g ∧ (g act X) f ∧ x ∈ X ∧ y ∈ orbit f g x ⇒
    ∀a. a ∈ G ∧ f a x = y ⇒ a * stabilizer f g x = {b | b ∈ G ∧ f b x = y}
</pre>

<DT><span class="strong">action_reverse</span>
<DD>
<pre>
⊢ ∀f g X.
    Group g ∧ (g act X) f ⇒
    ∀a x y. a ∈ G ∧ x ∈ X ∧ y ∈ X ∧ f a x = y ⇒ f ( |/ a) y = x
</pre>

<DT><span class="strong">action_to_orbit_surj</span>
<DD>
<pre>
⊢ ∀f g X x. (g act X) f ∧ x ∈ X ⇒ SURJ (λa. f a x) G (orbit f g x)
</pre>

<DT><span class="strong">action_trans</span>
<DD>
<pre>
⊢ ∀f g X.
    (g act X) f ⇒
    ∀a b x y z.
      a ∈ G ∧ b ∈ G ∧ x ∈ X ∧ y ∈ X ∧ z ∈ X ∧ f a x = y ∧ f b y = z ⇒
      f (b * a) x = z
</pre>

<DT><span class="strong">add_mod_abelian_group</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ AbelianGroup (add_mod n)
</pre>

<DT><span class="strong">add_mod_card</span>
<DD>
<pre>
⊢ ∀n. CARD (add_mod n).carrier = n
</pre>

<DT><span class="strong">add_mod_carrier</span>
<DD>
<pre>
⊢ ∀n. (add_mod n).carrier = {i | i < n}
</pre>

<DT><span class="strong">add_mod_carrier_alt</span>
<DD>
<pre>
⊢ ∀n. (add_mod n).carrier = count n
</pre>

<DT><span class="strong">add_mod_cylic</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ cyclic (add_mod n)
</pre>

<DT><span class="strong">add_mod_element</span>
<DD>
<pre>
⊢ ∀n x. x ∈ (add_mod n).carrier ⇔ x < n
</pre>

<DT><span class="strong">add_mod_eval</span>
<DD>
<pre>
⊢ ∀n. (add_mod n).carrier = {i | i < n} ∧
      (∀x y. (add_mod n).op x y = (x + y) MOD n) ∧ (add_mod n).id = 0
</pre>

<DT><span class="strong">add_mod_exp</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ ∀x m. (add_mod n).exp x m = (x * m) MOD n
</pre>

<DT><span class="strong">add_mod_finite</span>
<DD>
<pre>
⊢ ∀n. FINITE (add_mod n).carrier
</pre>

<DT><span class="strong">add_mod_finite_abelian_group</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ FiniteAbelianGroup (add_mod n)
</pre>

<DT><span class="strong">add_mod_finite_group</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ FiniteGroup (add_mod n)
</pre>

<DT><span class="strong">add_mod_group</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ Group (add_mod n)
</pre>

<DT><span class="strong">add_mod_id</span>
<DD>
<pre>
⊢ ∀n. (add_mod n).id = 0
</pre>

<DT><span class="strong">add_mod_inv</span>
<DD>
<pre>
⊢ ∀n x. 0 < n ∧ x < n ⇒ (add_mod n).inv x = (n − x) MOD n
</pre>

<DT><span class="strong">add_mod_inv_compute</span>
<DD>
<pre>
⊢ ∀n x.
    (add_mod n).inv x =
    if 0 < n ∧ x < n then (n − x) MOD n
    else FAIL ((add_mod n).inv x) bad_element
</pre>

<DT><span class="strong">add_mod_order_1</span>
<DD>
<pre>
⊢ ∀n. 1 < n ⇒ order (add_mod n) 1 = n
</pre>

<DT><span class="strong">add_mod_property</span>
<DD>
<pre>
⊢ ∀n. (∀x. x ∈ (add_mod n).carrier ⇔ x < n) ∧ (add_mod n).id = 0 ∧
      (∀x y. (add_mod n).op x y = (x + y) MOD n) ∧
      FINITE (add_mod n).carrier ∧ CARD (add_mod n).carrier = n
</pre>

<DT><span class="strong">all_subgroups_element</span>
<DD>
<pre>
⊢ ∀g h. h ∈ all_subgroups g ⇔ h ≤ g
</pre>

<DT><span class="strong">all_subgroups_finite</span>
<DD>
<pre>
⊢ ∀g. FiniteGroup g ⇒ FINITE (all_subgroups g)
</pre>

<DT><span class="strong">all_subgroups_has_gen_id</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ gen #e ∈ all_subgroups g
</pre>

<DT><span class="strong">all_subgroups_subset</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ IMAGE (λh. H) (all_subgroups g) ⊆ POW G
</pre>

<DT><span class="strong">bij_corres</span>
<DD>
<pre>
⊢ ∀f g1 g2 h1 h2.
    Group g1 ∧ Group g2 ∧ h1 ≤ g1 ∧ h2 ≤ g2 ∧ GroupHomo f g1 g2 ∧
    SURJ f g1.carrier g2.carrier ∧ kernel f g1 g2 ⊆ h1.carrier ⇒
    IMAGE f (PREIMAGE f h2.carrier ∩ g1.carrier) = h2.carrier ∧
    PREIMAGE f (IMAGE f h1.carrier) ∩ g1.carrier = h1.carrier
</pre>

<DT><span class="strong">carrier_card_by_coset_partition</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ∧ FINITE G ⇒ CARD G = ∑ CARD (CosetPartition g h)
</pre>

<DT><span class="strong">carrier_card_by_subgroup_coset_partition</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ∧ FINITE G ⇒ CARD G = ∑ CARD (partition (left_coset g H) G)
</pre>

<DT><span class="strong">cogen_coset_element</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ ∀x. x ∈ G ⇒ cogen g h (x * H) ∈ G
</pre>

<DT><span class="strong">cogen_element</span>
<DD>
<pre>
⊢ ∀h g e. h ≤ g ∧ e ∈ CosetPartition g h ⇒ cogen g h e ∈ G
</pre>

<DT><span class="strong">cogen_of_subgroup</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ cogen g h H * H = H
</pre>

<DT><span class="strong">conjugate_subgroup_group</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ ∀a. a ∈ G ⇒ Group (conjugate_subgroup h g a)
</pre>

<DT><span class="strong">conjugate_subgroup_subgroup</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ ∀a::G. conjugate_subgroup h g a ≤ g
</pre>

<DT><span class="strong">corres_thm</span>
<DD>
<pre>
⊢ ∀f g1 g2 h1 h2.
    Group g1 ∧ Group g2 ∧ GroupHomo f g1 g2 ∧ SURJ f g1.carrier g2.carrier ∧
    h1 ≤ g1 ∧ kernel f g1 g2 ⊆ h1.carrier ∧ h2 ≤ g2 ⇒
    homo_image f h1 g2 ≤ g2 ∧ preimage_group f g1 g2 h2.carrier ≤ g1 ∧
    kernel f g1 g2 ⊆ PREIMAGE f h2.carrier ∩ g1.carrier ∧
    (h2 << g2 ⇔ preimage_group f g1 g2 h2.carrier << g1) ∧
    IMAGE f (PREIMAGE f h2.carrier ∩ g1.carrier) = h2.carrier ∧
    PREIMAGE f (IMAGE f h1.carrier) ∩ g1.carrier = h1.carrier ∧
    (FiniteGroup g1 ⇒
     CARD (preimage_group f g1 g2 h2.carrier).carrier =
     CARD h2.carrier * CARD (kernel f g1 g2))
</pre>

<DT><span class="strong">coset_alt</span>
<DD>
<pre>
⊢ ∀g a X. a * X = {a * z | z ∈ X}
</pre>

<DT><span class="strong">coset_cogen_property</span>
<DD>
<pre>
⊢ ∀h g e. h ≤ g ∧ e ∈ CosetPartition g h ⇒ e = cogen g h e * H
</pre>

<DT><span class="strong">coset_element</span>
<DD>
<pre>
⊢ ∀g X a. a ∈ G ⇒ ∀x. x ∈ a * X ⇔ ∃y. y ∈ X ∧ x = a * y
</pre>

<DT><span class="strong">coset_empty</span>
<DD>
<pre>
⊢ ∀g a. Group g ∧ a ∈ G ⇒ a * ∅ = ∅
</pre>

<DT><span class="strong">coset_homo_group_iso_quotient_group</span>
<DD>
<pre>
⊢ ∀g h. h << g ⇒ GroupIso I (homo_group g (left_coset g H)) (g / h)
</pre>

<DT><span class="strong">coset_id_eq_subgroup</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ #e * H = H
</pre>

<DT><span class="strong">coset_partition_card</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ∧ FINITE G ⇒ CARD (CosetPartition g h) = CARD G DIV CARD H
</pre>

<DT><span class="strong">coset_partition_element</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ ∀e. e ∈ CosetPartition g h ⇔ ∃a. a ∈ G ∧ e = a * H
</pre>

<DT><span class="strong">coset_partition_element_card</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ∧ FINITE G ⇒ ∀e. e ∈ CosetPartition g h ⇒ CARD e = CARD H
</pre>

<DT><span class="strong">coset_partition_eq_coset_image</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ CosetPartition g h = IMAGE (left_coset g H) G
</pre>

<DT><span class="strong">coset_property</span>
<DD>
<pre>
⊢ ∀g a. Group g ∧ a ∈ G ⇒ ∀X. X ⊆ G ⇒ a * X ⊆ G
</pre>

<DT><span class="strong">count_formula</span>
<DD>
<pre>
⊢ ∀g h. FiniteGroup g ∧ h << g ⇒ CARD G = CARD H * CARD (g / h).carrier
</pre>

<DT><span class="strong">cyclic_element</span>
<DD>
<pre>
⊢ ∀g. cyclic g ⇒ ∀x. x ∈ G ⇒ ∃n. x = cyclic_gen g ** n
</pre>

<DT><span class="strong">cyclic_element_by_gen</span>
<DD>
<pre>
⊢ ∀g. cyclic g ∧ FINITE G ⇒ ∀x. x ∈ G ⇒ ∃n. n < CARD G ∧ x = cyclic_gen g ** n
</pre>

<DT><span class="strong">cyclic_element_in_generated</span>
<DD>
<pre>
⊢ ∀g. cyclic g ∧ FINITE G ⇒
      ∀x. x ∈ G ⇒ x ∈ Gen (cyclic_gen g ** (CARD G DIV ord x))
</pre>

<DT><span class="strong">cyclic_eq_order_partition</span>
<DD>
<pre>
⊢ ∀g. cyclic g ∧ FINITE G ⇒
      partition (eq_order g) G = {orders g n | n | n divides CARD G}
</pre>

<DT><span class="strong">cyclic_eq_order_partition_alt</span>
<DD>
<pre>
⊢ ∀g. cyclic g ∧ FINITE G ⇒
      partition (eq_order g) G = {orders g n | n | n ∈ divisors (CARD G)}
</pre>

<DT><span class="strong">cyclic_eq_order_partition_by_card</span>
<DD>
<pre>
⊢ ∀g. cyclic g ∧ FINITE G ⇒
      IMAGE CARD (partition (eq_order g) G) = IMAGE phi (divisors (CARD G))
</pre>

<DT><span class="strong">cyclic_finite_alt</span>
<DD>
<pre>
⊢ ∀g. FiniteGroup g ⇒ (cyclic g ⇔ ∃z. z ∈ G ∧ ord z = CARD G)
</pre>

<DT><span class="strong">cyclic_finite_has_order_divisor</span>
<DD>
<pre>
⊢ ∀g. cyclic g ∧ FINITE G ⇒ ∀n. n divides CARD G ⇒ ∃x. x ∈ G ∧ ord x = n
</pre>

<DT><span class="strong">cyclic_gen_element</span>
<DD>
<pre>
⊢ ∀g. cyclic g ⇒ cyclic_gen g ∈ G
</pre>

<DT><span class="strong">cyclic_gen_order</span>
<DD>
<pre>
⊢ ∀g. cyclic g ∧ FINITE G ⇒ ord (cyclic_gen g) = CARD G
</pre>

<DT><span class="strong">cyclic_gen_power_order</span>
<DD>
<pre>
⊢ ∀g. cyclic g ∧ FINITE G ⇒
      ∀n. 0 < n ∧ CARD G MOD n = 0 ⇒ ord (cyclic_gen g ** (CARD G DIV n)) = n
</pre>

<DT><span class="strong">cyclic_generated_by_gen</span>
<DD>
<pre>
⊢ ∀g. cyclic g ⇒ g = gen (cyclic_gen g)
</pre>

<DT><span class="strong">cyclic_generated_group</span>
<DD>
<pre>
⊢ ∀g. FiniteGroup g ⇒ ∀x. x ∈ G ⇒ cyclic (gen x)
</pre>

<DT><span class="strong">cyclic_generators_card</span>
<DD>
<pre>
⊢ ∀g. cyclic g ∧ FINITE G ⇒ CARD (cyclic_generators g) = phi (CARD G)
</pre>

<DT><span class="strong">cyclic_generators_coprimes_bij</span>
<DD>
<pre>
⊢ ∀g. cyclic g ∧ FINITE G ⇒
      BIJ (λj. cyclic_gen g ** j) (coprimes (CARD G)) (cyclic_generators g)
</pre>

<DT><span class="strong">cyclic_generators_element</span>
<DD>
<pre>
⊢ ∀g z. z ∈ cyclic_generators g ⇔ z ∈ G ∧ ord z = CARD G
</pre>

<DT><span class="strong">cyclic_generators_finite</span>
<DD>
<pre>
⊢ ∀g. FINITE G ⇒ FINITE (cyclic_generators g)
</pre>

<DT><span class="strong">cyclic_generators_gen_cofactor_eq_orders</span>
<DD>
<pre>
⊢ ∀g. cyclic g ∧ FINITE G ⇒
      ∀n. n divides CARD G ⇒
          cyclic_generators (gen (cyclic_gen g ** (CARD G DIV n))) =
          orders g n
</pre>

<DT><span class="strong">cyclic_generators_nonempty</span>
<DD>
<pre>
⊢ ∀g. cyclic g ∧ FINITE G ⇒ cyclic_generators g ≠ ∅
</pre>

<DT><span class="strong">cyclic_generators_subset</span>
<DD>
<pre>
⊢ ∀g. cyclic_generators g ⊆ G
</pre>

<DT><span class="strong">cyclic_group</span>
<DD>
<pre>
⊢ ∀g. cyclic g ⇒ Group g
</pre>

<DT><span class="strong">cyclic_group_abelian</span>
<DD>
<pre>
⊢ ∀g. cyclic g ⇒ AbelianGroup g
</pre>

<DT><span class="strong">cyclic_group_comm</span>
<DD>
<pre>
⊢ ∀g. cyclic g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ x * y = y * x
</pre>

<DT><span class="strong">cyclic_image_ord_is_divisors</span>
<DD>
<pre>
⊢ ∀g. cyclic g ∧ FINITE G ⇒ IMAGE ord G = divisors (CARD G)
</pre>

<DT><span class="strong">cyclic_index_exists</span>
<DD>
<pre>
⊢ ∀g x. cyclic g ∧ x ∈ G ⇒ ∃n. x = cyclic_gen g ** n ∧ (FINITE G ⇒ n < CARD G)
</pre>

<DT><span class="strong">cyclic_iso_gen</span>
<DD>
<pre>
⊢ ∀g h f.
    cyclic g ∧ cyclic h ∧ FINITE G ∧ GroupIso f g h ⇒
    f (cyclic_gen g) ∈ cyclic_generators h
</pre>

<DT><span class="strong">cyclic_orders_card</span>
<DD>
<pre>
⊢ ∀g. cyclic g ∧ FINITE G ⇒
      ∀n. CARD (orders g n) = if n divides CARD G then phi n else 0
</pre>

<DT><span class="strong">cyclic_orders_nonempty</span>
<DD>
<pre>
⊢ ∀g. cyclic g ∧ FINITE G ⇒ ∀n. n divides CARD G ⇒ orders g n ≠ ∅
</pre>

<DT><span class="strong">cyclic_orders_partition</span>
<DD>
<pre>
⊢ ∀g. cyclic g ∧ FINITE G ⇒
      partition (eq_order g) G = IMAGE (orders g) (divisors (CARD G))
</pre>

<DT><span class="strong">cyclic_subgroup_condition</span>
<DD>
<pre>
⊢ ∀g. cyclic g ∧ FINITE G ⇒ ∀n. (∃h. h ≤ g ∧ CARD H = n) ⇔ n divides CARD G
</pre>

<DT><span class="strong">cyclic_subgroup_cyclic</span>
<DD>
<pre>
⊢ ∀g h. cyclic g ∧ h ≤ g ⇒ cyclic h
</pre>

<DT><span class="strong">cyclic_uroots_cyclic</span>
<DD>
<pre>
⊢ ∀g. cyclic g ⇒ ∀n. cyclic (uroots n)
</pre>

<DT><span class="strong">cyclic_uroots_has_primitive</span>
<DD>
<pre>
⊢ ∀g. FINITE G ∧ cyclic g ⇒
      ∀n. ∃z. z ∈ (uroots n).carrier ∧ ord z = CARD (uroots n).carrier
</pre>

<DT><span class="strong">element_coset_property</span>
<DD>
<pre>
⊢ ∀g X a. a ∈ G ⇒ ∀x. x ∈ X ⇒ a * x ∈ a * X
</pre>

<DT><span class="strong">eq_order_equiv</span>
<DD>
<pre>
⊢ ∀g. eq_order g equiv_on G
</pre>

<DT><span class="strong">eq_order_is_feq_order</span>
<DD>
<pre>
⊢ ∀g. eq_order g = feq ord
</pre>

<DT><span class="strong">fermat_little</span>
<DD>
<pre>
⊢ ∀p a. prime p ∧ 0 < a ∧ a < p ⇒ a ** (p − 1) MOD p = 1
</pre>

<DT><span class="strong">fermat_little_alt</span>
<DD>
<pre>
⊢ ∀p a. prime p ⇒ a ** (p − 1) MOD p = if a MOD p = 0 then 0 else 1
</pre>

<DT><span class="strong">fermat_little_thm</span>
<DD>
<pre>
⊢ ∀p. prime p ⇒ ∀a. a ** p MOD p = a MOD p
</pre>

<DT><span class="strong">fermat_roots</span>
<DD>
<pre>
⊢ ∀p. prime p ⇒ ∀x y z. x ** p + y ** p = z ** p ⇒ (x + y) MOD p = z MOD p
</pre>

<DT><span class="strong">finite_abelian_Fermat</span>
<DD>
<pre>
⊢ ∀g a. FiniteAbelianGroup g ∧ a ∈ G ⇒ a ** CARD G = #e
</pre>

<DT><span class="strong">finite_abelian_group_is_finite_abelian_monoid</span>
<DD>
<pre>
⊢ ∀g. FiniteAbelianGroup g ⇒ FiniteAbelianMonoid g
</pre>

<DT><span class="strong">finite_cyclic_group_add_mod_bij</span>
<DD>
<pre>
⊢ ∀g. cyclic g ∧ FINITE G ⇒
      BIJ (λn. cyclic_gen g ** n) (add_mod (CARD G)).carrier G
</pre>

<DT><span class="strong">finite_cyclic_group_add_mod_homo</span>
<DD>
<pre>
⊢ ∀g. cyclic g ∧ FINITE G ⇒
      GroupHomo (λn. cyclic_gen g ** n) (add_mod (CARD G)) g
</pre>

<DT><span class="strong">finite_cyclic_group_add_mod_iso</span>
<DD>
<pre>
⊢ ∀g. cyclic g ∧ FINITE G ⇒
      GroupIso (λn. cyclic_gen g ** n) (add_mod (CARD G)) g
</pre>

<DT><span class="strong">finite_cyclic_group_bij</span>
<DD>
<pre>
⊢ ∀g1 g2.
    cyclic g1 ∧ cyclic g2 ∧ FINITE g1.carrier ∧ FINITE g2.carrier ∧
    CARD g1.carrier = CARD g2.carrier ⇒
    BIJ (λx. g2.exp (cyclic_gen g2) (cyclic_index g1 x)) g1.carrier g2.carrier
</pre>

<DT><span class="strong">finite_cyclic_group_existence</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ ∃g. cyclic g ∧ CARD g.carrier = n
</pre>

<DT><span class="strong">finite_cyclic_group_homo</span>
<DD>
<pre>
⊢ ∀g1 g2.
    cyclic g1 ∧ cyclic g2 ∧ FINITE g1.carrier ∧ FINITE g2.carrier ∧
    CARD g1.carrier = CARD g2.carrier ⇒
    GroupHomo (λx. g2.exp (cyclic_gen g2) (cyclic_index g1 x)) g1 g2
</pre>

<DT><span class="strong">finite_cyclic_group_iso</span>
<DD>
<pre>
⊢ ∀g1 g2.
    cyclic g1 ∧ cyclic g2 ∧ FINITE g1.carrier ∧ FINITE g2.carrier ∧
    CARD g1.carrier = CARD g2.carrier ⇒
    GroupIso (λx. g2.exp (cyclic_gen g2) (cyclic_index g1 x)) g1 g2
</pre>

<DT><span class="strong">finite_cyclic_group_uniqueness</span>
<DD>
<pre>
⊢ ∀g1 g2.
    cyclic g1 ∧ cyclic g2 ∧ FINITE g1.carrier ∧ FINITE g2.carrier ∧
    CARD g1.carrier = CARD g2.carrier ⇒
    ∃f. GroupIso f g1 g2
</pre>

<DT><span class="strong">finite_cyclic_index_add</span>
<DD>
<pre>
⊢ ∀g x y.
    cyclic g ∧ FINITE G ∧ x ∈ G ∧ y ∈ G ⇒
    cyclic_index g (x * y) = (cyclic_index g x + cyclic_index g y) MOD CARD G
</pre>

<DT><span class="strong">finite_cyclic_index_property</span>
<DD>
<pre>
⊢ ∀g. cyclic g ∧ FINITE G ⇒
      ∀n. n < CARD G ⇒ cyclic_index g (cyclic_gen g ** n) = n
</pre>

<DT><span class="strong">finite_cyclic_index_unique</span>
<DD>
<pre>
⊢ ∀g x.
    cyclic g ∧ FINITE G ∧ x ∈ G ⇒
    ∀n. n < CARD G ⇒ (x = cyclic_gen g ** n ⇔ n = cyclic_index g x)
</pre>

<DT><span class="strong">finite_group_Fermat</span>
<DD>
<pre>
⊢ ∀g a. FiniteGroup g ∧ a ∈ G ⇒ a ** CARD G = #e
</pre>

<DT><span class="strong">finite_group_card_pos</span>
<DD>
<pre>
⊢ ∀g. FiniteGroup g ⇒ 0 < CARD G
</pre>

<DT><span class="strong">finite_group_exp_not_distinct</span>
<DD>
<pre>
⊢ ∀g. FiniteGroup g ⇒ ∀x. x ∈ G ⇒ ∃h k. x ** h = x ** k ∧ h ≠ k
</pre>

<DT><span class="strong">finite_group_exp_period_exists</span>
<DD>
<pre>
⊢ ∀g. FiniteGroup g ⇒ ∀x. x ∈ G ⇒ ∃k. 0 < k ∧ x ** k = #e
</pre>

<DT><span class="strong">finite_group_is_finite_monoid</span>
<DD>
<pre>
⊢ ∀g. FiniteGroup g ⇒ FiniteMonoid g
</pre>

<DT><span class="strong">finite_group_is_group</span>
<DD>
<pre>
⊢ ∀g. FiniteGroup g ⇒ Group g
</pre>

<DT><span class="strong">finite_group_is_monoid</span>
<DD>
<pre>
⊢ ∀g. FiniteGroup g ⇒ Monoid g
</pre>

<DT><span class="strong">finite_group_order</span>
<DD>
<pre>
⊢ ∀g. FiniteGroup g ⇒
      ∀x. x ∈ G ⇒
          ∀n. ord x = n ⇒
              0 < n ∧ x ** n = #e ∧ ∀m. 0 < m ∧ m < n ⇒ x ** m ≠ #e
</pre>

<DT><span class="strong">finite_group_primitive_property</span>
<DD>
<pre>
⊢ ∀g. FiniteGroup g ⇒
      ∀z. z ∈ G ∧ ord z = CARD G ⇒ ∀x. x ∈ G ⇒ ∃n. n < CARD G ∧ x = z ** n
</pre>

<DT><span class="strong">finite_homo_image</span>
<DD>
<pre>
⊢ ∀f g1 g2 h.
    FiniteGroup g1 ∧ Group g2 ∧ h ≤ g2 ∧ GroupHomo f g1 g2 ⇒
    FINITE (homo_image f (preimage_group f g1 g2 h.carrier) g2).carrier
</pre>

<DT><span class="strong">finite_monoid_invertibles_is_finite_group</span>
<DD>
<pre>
⊢ ∀g. FiniteMonoid g ⇒ FiniteGroup (Invertibles g)
</pre>

<DT><span class="strong">finite_subgroup_carrier_finite</span>
<DD>
<pre>
⊢ ∀g. FiniteGroup g ⇒ ∀h. h ≤ g ⇒ FINITE H
</pre>

<DT><span class="strong">finite_subgroup_finite_group</span>
<DD>
<pre>
⊢ ∀g. FiniteGroup g ⇒ ∀h. h ≤ g ⇒ FiniteGroup h
</pre>

<DT><span class="strong">fixed_points_element</span>
<DD>
<pre>
⊢ ∀f g X x. x ∈ fixed_points f g X ⇔ x ∈ X ∧ ∀a. a ∈ G ⇒ f a x = x
</pre>

<DT><span class="strong">fixed_points_element_element</span>
<DD>
<pre>
⊢ ∀f g X x. x ∈ fixed_points f g X ⇒ x ∈ X
</pre>

<DT><span class="strong">fixed_points_finite</span>
<DD>
<pre>
⊢ ∀f g X. FINITE X ⇒ FINITE (fixed_points f g X)
</pre>

<DT><span class="strong">fixed_points_orbit_iff_sing</span>
<DD>
<pre>
⊢ ∀f g X.
    Group g ∧ (g act X) f ⇒
    ∀x. x ∈ X ⇒ (x ∈ fixed_points f g X ⇔ SING (orbit f g x))
</pre>

<DT><span class="strong">fixed_points_orbit_sing</span>
<DD>
<pre>
⊢ ∀f g X.
    Group g ∧ (g act X) f ⇒
    ∀x. x ∈ fixed_points f g X ⇔ x ∈ X ∧ orbit f g x = {x}
</pre>

<DT><span class="strong">fixed_points_subset</span>
<DD>
<pre>
⊢ ∀f g X. fixed_points f g X ⊆ X
</pre>

<DT><span class="strong">fn_cyclic_group_alt</span>
<DD>
<pre>
⊢ ∀e f n.
    (∃k. k ≠ 0 ∧ FUNPOW f k e = e) ∧ n = (LEAST k. k ≠ 0 ∧ FUNPOW f k e = e) ⇒
    (fn_cyclic_group e f).carrier = {FUNPOW f k e | k < n} ∧
    (fn_cyclic_group e f).id = e ∧
    ∀i j.
      (fn_cyclic_group e f).op (FUNPOW f i e) (FUNPOW f j e) =
      FUNPOW f ((i + j) MOD n) e
</pre>

<DT><span class="strong">fn_cyclic_group_carrier</span>
<DD>
<pre>
⊢ ∀e f. (fn_cyclic_group e f).carrier = {x | ∃n. FUNPOW f n e = x}
</pre>

<DT><span class="strong">fn_cyclic_group_finite_abelian_group</span>
<DD>
<pre>
⊢ ∀e f.
    (∃n. n ≠ 0 ∧ FUNPOW f n e = e) ⇒ FiniteAbelianGroup (fn_cyclic_group e f)
</pre>

<DT><span class="strong">fn_cyclic_group_finite_group</span>
<DD>
<pre>
⊢ ∀e f. (∃n. n ≠ 0 ∧ FUNPOW f n e = e) ⇒ FiniteGroup (fn_cyclic_group e f)
</pre>

<DT><span class="strong">fn_cyclic_group_group</span>
<DD>
<pre>
⊢ ∀e f. (∃n. n ≠ 0 ∧ FUNPOW f n e = e) ⇒ Group (fn_cyclic_group e f)
</pre>

<DT><span class="strong">fn_cyclic_group_id</span>
<DD>
<pre>
⊢ ∀e f. (fn_cyclic_group e f).id = e
</pre>

<DT><span class="strong">generated_Fermat</span>
<DD>
<pre>
⊢ ∀g a. FiniteGroup g ∧ a ∈ G ⇒ ∀x. x ∈ Gen a ⇒ x ** CARD (Gen a) = #e
</pre>

<DT><span class="strong">generated_carrier</span>
<DD>
<pre>
⊢ ∀g a. a ∈ G ⇒ Gen a = IMAGE ($** a) 𝕌(:num)
</pre>

<DT><span class="strong">generated_carrier_as_image</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒
      ∀a. a ∈ G ∧ 0 < ord a ⇒ Gen a = IMAGE (λj. a ** j) (count (ord a))
</pre>

<DT><span class="strong">generated_carrier_has_id</span>
<DD>
<pre>
⊢ ∀g a. #e ∈ Gen a
</pre>

<DT><span class="strong">generated_element</span>
<DD>
<pre>
⊢ ∀g a x. x ∈ Gen a ⇔ ∃n. x = a ** n
</pre>

<DT><span class="strong">generated_exp</span>
<DD>
<pre>
⊢ ∀g a z. a ∈ G ∧ z ∈ Gen a ⇒ ∀n. (gen a).exp z n = z ** n
</pre>

<DT><span class="strong">generated_finite_group</span>
<DD>
<pre>
⊢ ∀g a. FiniteGroup g ∧ a ∈ G ⇒ FiniteGroup (gen a)
</pre>

<DT><span class="strong">generated_gen_element</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ x ∈ Gen x
</pre>

<DT><span class="strong">generated_group</span>
<DD>
<pre>
⊢ ∀g a. FiniteGroup g ∧ a ∈ G ⇒ Group (gen a)
</pre>

<DT><span class="strong">generated_group_card</span>
<DD>
<pre>
⊢ ∀g a. Group g ∧ a ∈ G ∧ 0 < ord a ⇒ CARD (Gen a) = ord a
</pre>

<DT><span class="strong">generated_group_finite</span>
<DD>
<pre>
⊢ ∀g a. FiniteGroup g ∧ a ∈ G ⇒ FINITE (Gen a)
</pre>

<DT><span class="strong">generated_id_carrier</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ Gen #e = {#e}
</pre>

<DT><span class="strong">generated_id_subgroup</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ gen #e ≤ g
</pre>

<DT><span class="strong">generated_image_subset_all_subgroups</span>
<DD>
<pre>
⊢ ∀g. FiniteGroup g ⇒ ∀s. s ⊆ G ⇒ IMAGE gen s ⊆ all_subgroups g
</pre>

<DT><span class="strong">generated_image_subset_power_set</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀s. s ⊆ G ⇒ IMAGE (λa. Gen a) s ⊆ POW G
</pre>

<DT><span class="strong">generated_property</span>
<DD>
<pre>
⊢ ∀g a. (gen a).op = $* ∧ (gen a).id = #e
</pre>

<DT><span class="strong">generated_subgroup</span>
<DD>
<pre>
⊢ ∀g a. FiniteGroup g ∧ a ∈ G ⇒ gen a ≤ g
</pre>

<DT><span class="strong">generated_subset</span>
<DD>
<pre>
⊢ ∀g a. Group g ∧ a ∈ G ⇒ Gen a ⊆ G
</pre>

<DT><span class="strong">group_all_invertible</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ G* = G
</pre>

<DT><span class="strong">group_alt</span>
<DD>
<pre>
⊢ ∀g. Group g ⇔
      (∀x y::G. x * y ∈ G) ∧ (∀x y z::G. x * y * z = x * (y * z)) ∧ #e ∈ G ∧
      (∀x::G. #e * x = x) ∧ ∀x::G. |/ x ∈ G ∧ |/ x * x = #e
</pre>

<DT><span class="strong">group_assoc</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x y z. x ∈ G ∧ y ∈ G ∧ z ∈ G ⇒ x * y * z = x * (y * z)
</pre>

<DT><span class="strong">group_auto_I</span>
<DD>
<pre>
⊢ ∀g. GroupAuto I g
</pre>

<DT><span class="strong">group_auto_bij</span>
<DD>
<pre>
⊢ ∀g f. GroupAuto f g ⇒ f PERMUTES G
</pre>

<DT><span class="strong">group_auto_compose</span>
<DD>
<pre>
⊢ ∀g f1 f2. GroupAuto f1 g ∧ GroupAuto f2 g ⇒ GroupAuto (f1 ∘ f2) g
</pre>

<DT><span class="strong">group_auto_element</span>
<DD>
<pre>
⊢ ∀f g. GroupAuto f g ⇒ ∀x. x ∈ G ⇒ f x ∈ G
</pre>

<DT><span class="strong">group_auto_exp</span>
<DD>
<pre>
⊢ ∀g f. Group g ∧ GroupAuto f g ⇒ ∀x. x ∈ G ⇒ ∀n. f (x ** n) = f x ** n
</pre>

<DT><span class="strong">group_auto_id</span>
<DD>
<pre>
⊢ ∀f g. Group g ∧ GroupAuto f g ⇒ f #e = #e
</pre>

<DT><span class="strong">group_auto_is_monoid_auto</span>
<DD>
<pre>
⊢ ∀g f. Group g ∧ GroupAuto f g ⇒ MonoidAuto f g
</pre>

<DT><span class="strong">group_auto_linv_auto</span>
<DD>
<pre>
⊢ ∀g f. Group g ∧ GroupAuto f g ⇒ GroupAuto (LINV f G) g
</pre>

<DT><span class="strong">group_auto_order</span>
<DD>
<pre>
⊢ ∀g f. Group g ∧ GroupAuto f g ⇒ ∀x. x ∈ G ⇒ ord (f x) = ord x
</pre>

<DT><span class="strong">group_carrier_nonempty</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ G ≠ ∅
</pre>

<DT><span class="strong">group_comm_exp</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒
      ∀x y. x ∈ G ∧ y ∈ G ⇒ x * y = y * x ⇒ ∀n. x ** n * y = y * x ** n
</pre>

<DT><span class="strong">group_comm_exp_exp</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒
      ∀x y.
        x ∈ G ∧ y ∈ G ∧ x * y = y * x ⇒
        ∀n m. x ** n * y ** m = y ** m * x ** n
</pre>

<DT><span class="strong">group_comm_op_exp</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒
      ∀x y. x ∈ G ∧ y ∈ G ∧ x * y = y * x ⇒ ∀n. (x * y) ** n = x ** n * y ** n
</pre>

<DT><span class="strong">group_coset_eq_itself</span>
<DD>
<pre>
⊢ ∀g a. Group g ∧ a ∈ G ⇒ a * G = G
</pre>

<DT><span class="strong">group_coset_is_permutation</span>
<DD>
<pre>
⊢ ∀g a. Group g ∧ a ∈ G ⇒ a * G = G
</pre>

<DT><span class="strong">group_def_alt</span>
<DD>
<pre>
⊢ ∀g. Group g ⇔
      (∀x y. x ∈ G ∧ y ∈ G ⇒ x * y ∈ G) ∧
      (∀x y z. x ∈ G ∧ y ∈ G ∧ z ∈ G ⇒ x * y * z = x * (y * z)) ∧ #e ∈ G ∧
      (∀x. x ∈ G ⇒ #e * x = x) ∧ ∀x. x ∈ G ⇒ ∃y. y ∈ G ∧ y * x = #e
</pre>

<DT><span class="strong">group_def_by_inverse</span>
<DD>
<pre>
⊢ ∀g. Group g ⇔ Monoid g ∧ ∀x. x ∈ G ⇒ ∃y. y ∈ G ∧ y * x = #e
</pre>

<DT><span class="strong">group_div_cancel</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ x / x = #e
</pre>

<DT><span class="strong">group_div_element</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ x / y ∈ G
</pre>

<DT><span class="strong">group_div_lsame</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒
      ∀x y z. x ∈ G ∧ y ∈ G ∧ z ∈ G ⇒ z * x / (z * y) = z * (x / y) / z
</pre>

<DT><span class="strong">group_div_pair</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒
      ∀x1 y1 x2 y2.
        x1 ∈ G ∧ y1 ∈ G ∧ x2 ∈ G ∧ y2 ∈ G ⇒
        x1 * y1 / (x2 * y2) = x1 * (y1 / y2) / x1 * (x1 / x2)
</pre>

<DT><span class="strong">group_div_rsame</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x y z. x ∈ G ∧ y ∈ G ∧ z ∈ G ⇒ x * z / (y * z) = x / y
</pre>

<DT><span class="strong">group_excluding_exp</span>
<DD>
<pre>
⊢ ∀g z x n. (g excluding z).exp x n = x ** n
</pre>

<DT><span class="strong">group_excluding_op</span>
<DD>
<pre>
⊢ ∀g z. (g excluding z).op = $*
</pre>

<DT><span class="strong">group_excluding_property</span>
<DD>
<pre>
⊢ ∀g z.
    (g excluding z).op = $* ∧ (g excluding z).id = #e ∧
    ∀x. x ∈ (g excluding z).carrier ⇒ x ∈ G ∧ x ≠ z
</pre>

<DT><span class="strong">group_exp_0</span>
<DD>
<pre>
⊢ ∀g x. x ** 0 = #e
</pre>

<DT><span class="strong">group_exp_1</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ x ** 1 = x
</pre>

<DT><span class="strong">group_exp_SUC</span>
<DD>
<pre>
⊢ ∀g x n. x ** SUC n = x * x ** n
</pre>

<DT><span class="strong">group_exp_add</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ ∀n k. x ** (n + k) = x ** n * x ** k
</pre>

<DT><span class="strong">group_exp_comm</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ ∀n. x ** n * x = x * x ** n
</pre>

<DT><span class="strong">group_exp_element</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ ∀n. x ** n ∈ G
</pre>

<DT><span class="strong">group_exp_eq</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ ∀m n. m < n ∧ x ** m = x ** n ⇒ x ** (n − m) = #e
</pre>

<DT><span class="strong">group_exp_eq_condition</span>
<DD>
<pre>
⊢ ∀g x.
    Group g ∧ x ∈ G ∧ 0 < ord x ⇒
    ∀n m. x ** n = x ** m ⇔ n MOD ord x = m MOD ord x
</pre>

<DT><span class="strong">group_exp_equal</span>
<DD>
<pre>
⊢ ∀g x.
    Group g ∧ x ∈ G ⇒ ∀n m. n < ord x ∧ m < ord x ∧ x ** n = x ** m ⇒ n = m
</pre>

<DT><span class="strong">group_exp_inv</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ ∀n. |/ (x ** n) = |/ x ** n
</pre>

<DT><span class="strong">group_exp_mod</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ∧ 0 < ord x ⇒ ∀n. x ** n = x ** (n MOD ord x)
</pre>

<DT><span class="strong">group_exp_mod_order</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ∧ 0 < ord x ⇒ ∀n. x ** n = x ** (n MOD ord x)
</pre>

<DT><span class="strong">group_exp_mult</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ ∀n k. x ** (n * k) = (x ** n) ** k
</pre>

<DT><span class="strong">group_exp_mult_comm</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ ∀m n. (x ** m) ** n = (x ** n) ** m
</pre>

<DT><span class="strong">group_exp_suc</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ ∀n. x ** SUC n = x ** n * x
</pre>

<DT><span class="strong">group_first_isomorphism_thm</span>
<DD>
<pre>
⊢ ∀g h f.
    Group g ∧ Group h ∧ GroupHomo f g h ⇒
    kernel_group f g h << g ∧ homo_image f g h ≤ h ∧
    GroupIso (λz. CHOICE (preimage f G z) * kernel f g h) (homo_image f g h)
      (g / kernel_group f g h) ∧
    (SURJ f G h.carrier ⇒ GroupIso I h (homo_image f g h))
</pre>

<DT><span class="strong">group_homo_I_refl</span>
<DD>
<pre>
⊢ ∀g. GroupHomo I g g
</pre>

<DT><span class="strong">group_homo_compose</span>
<DD>
<pre>
⊢ ∀g h k f1 f2. GroupHomo f1 g h ∧ GroupHomo f2 h k ⇒ GroupHomo (f2 ∘ f1) g k
</pre>

<DT><span class="strong">group_homo_cong</span>
<DD>
<pre>
⊢ ∀g h f1 f2.
    Group g ∧ Group h ∧ (∀x. x ∈ G ⇒ f1 x = f2 x) ⇒
    (GroupHomo f1 g h ⇔ GroupHomo f2 g h)
</pre>

<DT><span class="strong">group_homo_element</span>
<DD>
<pre>
⊢ ∀f g h. GroupHomo f g h ⇒ ∀x. x ∈ G ⇒ f x ∈ h.carrier
</pre>

<DT><span class="strong">group_homo_exp</span>
<DD>
<pre>
⊢ ∀g h f.
    Group g ∧ Group h ∧ GroupHomo f g h ⇒
    ∀x. x ∈ G ⇒ ∀n. f (x ** n) = h.exp (f x) n
</pre>

<DT><span class="strong">group_homo_homo_image_group</span>
<DD>
<pre>
⊢ ∀g h f. Group g ∧ MonoidHomo f g h ⇒ Group (homo_image f g h)
</pre>

<DT><span class="strong">group_homo_id</span>
<DD>
<pre>
⊢ ∀f g h. Group g ∧ Group h ∧ GroupHomo f g h ⇒ f #e = h.id
</pre>

<DT><span class="strong">group_homo_image_surj_property</span>
<DD>
<pre>
⊢ ∀g h f.
    Group g ∧ Group h ∧ SURJ f G h.carrier ⇒ GroupIso I h (homo_image f g h)
</pre>

<DT><span class="strong">group_homo_inv</span>
<DD>
<pre>
⊢ ∀f g h.
    Group g ∧ Group h ∧ GroupHomo f g h ⇒ ∀x. x ∈ G ⇒ f ( |/ x) = h.inv (f x)
</pre>

<DT><span class="strong">group_homo_is_monoid_homo</span>
<DD>
<pre>
⊢ ∀g h f. Group g ∧ Group h ∧ GroupHomo f g h ⇒ MonoidHomo f g h
</pre>

<DT><span class="strong">group_homo_monoid_homo</span>
<DD>
<pre>
⊢ ∀f g h. GroupHomo f g h ∧ f #e = h.id ⇔ MonoidHomo f g h
</pre>

<DT><span class="strong">group_homo_sym</span>
<DD>
<pre>
⊢ ∀g h f.
    Group g ∧ GroupHomo f g h ∧ BIJ f G h.carrier ⇒ GroupHomo (LINV f G) h g
</pre>

<DT><span class="strong">group_homo_sym_any</span>
<DD>
<pre>
⊢ Group g ∧ GroupHomo f g h ∧ (∀x. x ∈ h.carrier ⇒ i x ∈ G ∧ f (i x) = x) ∧
  (∀x. x ∈ G ⇒ i (f x) = x) ⇒
  GroupHomo i h g
</pre>

<DT><span class="strong">group_homo_trans</span>
<DD>
<pre>
⊢ ∀g h k f1 f2. GroupHomo f1 g h ∧ GroupHomo f2 h k ⇒ GroupHomo (f2 ∘ f1) g k
</pre>

<DT><span class="strong">group_id</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ #e * x = x ∧ x * #e = x
</pre>

<DT><span class="strong">group_id_element</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ #e ∈ G
</pre>

<DT><span class="strong">group_id_exp</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀n. #e ** n = #e
</pre>

<DT><span class="strong">group_id_fix</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ (x * x = x ⇔ x = #e)
</pre>

<DT><span class="strong">group_id_id</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ #e * #e = #e
</pre>

<DT><span class="strong">group_id_unique</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒
      ∀x y. x ∈ G ∧ y ∈ G ⇒ (y * x = x ⇔ y = #e) ∧ (x * y = x ⇔ y = #e)
</pre>

<DT><span class="strong">group_image_as_op_image</span>
<DD>
<pre>
⊢ ∀g. GROUP_IMAGE g = OP_IMAGE $* #e
</pre>

<DT><span class="strong">group_image_empty</span>
<DD>
<pre>
⊢ ∀g f. GROUP_IMAGE g f ∅ = #e
</pre>

<DT><span class="strong">group_image_sing</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ ∀f. group_fun g f ⇒ ∀x. x ∈ G ⇒ GROUP_IMAGE g f {x} = f x
</pre>

<DT><span class="strong">group_including_excluding_abelian</span>
<DD>
<pre>
⊢ ∀g z. z ∉ G ⇒ (AbelianGroup g ⇔ AbelianGroup (g including z excluding z))
</pre>

<DT><span class="strong">group_including_excluding_eqn</span>
<DD>
<pre>
⊢ ∀g z.
    g including z excluding z =
    if z ∈ G then <|carrier := G DELETE z; op := $*; id := #e|> else g
</pre>

<DT><span class="strong">group_including_excluding_group</span>
<DD>
<pre>
⊢ ∀g z. z ∉ G ⇒ (Group g ⇔ Group (g including z excluding z))
</pre>

<DT><span class="strong">group_including_excluding_property</span>
<DD>
<pre>
⊢ ∀g z.
    (g including z excluding z).op = $* ∧
    (g including z excluding z).id = #e ∧
    (z ∉ G ⇒ (g including z excluding z).carrier = G)
</pre>

<DT><span class="strong">group_including_property</span>
<DD>
<pre>
⊢ ∀g z.
    (g including z).op = $* ∧ (g including z).id = #e ∧
    ∀x. x ∈ (g including z).carrier ⇒ x ∈ G ∨ x = z
</pre>

<DT><span class="strong">group_inj_image_abelian_group</span>
<DD>
<pre>
⊢ ∀g f. AbelianGroup g ∧ INJ f G 𝕌(:β) ⇒ AbelianGroup (monoid_inj_image g f)
</pre>

<DT><span class="strong">group_inj_image_excluding_abelian_group</span>
<DD>
<pre>
⊢ ∀g f e.
    AbelianGroup (g excluding e) ∧ INJ f G 𝕌(:β) ∧ e ∈ G ⇒
    AbelianGroup (monoid_inj_image g f excluding f e)
</pre>

<DT><span class="strong">group_inj_image_excluding_group</span>
<DD>
<pre>
⊢ ∀g f e.
    Group (g excluding e) ∧ INJ f G 𝕌(:β) ∧ e ∈ G ⇒
    Group (monoid_inj_image g f excluding f e)
</pre>

<DT><span class="strong">group_inj_image_group</span>
<DD>
<pre>
⊢ ∀g f. Group g ∧ INJ f G 𝕌(:β) ⇒ Group (monoid_inj_image g f)
</pre>

<DT><span class="strong">group_inj_image_group_homo</span>
<DD>
<pre>
⊢ ∀g f. INJ f G 𝕌(:β) ⇒ GroupHomo f g (monoid_inj_image g f)
</pre>

<DT><span class="strong">group_inv_element</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ |/ x ∈ G
</pre>

<DT><span class="strong">group_inv_eq</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ ( |/ x = |/ y ⇔ x = y)
</pre>

<DT><span class="strong">group_inv_eq_id</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ ( |/ x = #e ⇔ x = #e)
</pre>

<DT><span class="strong">group_inv_eq_swap</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ ( |/ x = y ⇔ x = |/ y)
</pre>

<DT><span class="strong">group_inv_exp</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ ∀n. |/ x ** n = |/ (x ** n)
</pre>

<DT><span class="strong">group_inv_id</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ |/ #e = #e
</pre>

<DT><span class="strong">group_inv_inv</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ |/ ( |/ x) = x
</pre>

<DT><span class="strong">group_inv_op</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ |/ (x * y) = |/ y * |/ x
</pre>

<DT><span class="strong">group_inv_order</span>
<DD>
<pre>
⊢ ∀g x. Group g ∧ x ∈ G ⇒ ord ( |/ x) = ord x
</pre>

<DT><span class="strong">group_inv_thm</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ x * |/ x = #e ∧ |/ x * x = #e
</pre>

<DT><span class="strong">group_is_monoid</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ Monoid g
</pre>

<DT><span class="strong">group_iso_I_refl</span>
<DD>
<pre>
⊢ ∀g. GroupIso I g g
</pre>

<DT><span class="strong">group_iso_bij</span>
<DD>
<pre>
⊢ ∀g h f. GroupIso f g h ⇒ BIJ f G h.carrier
</pre>

<DT><span class="strong">group_iso_card_eq</span>
<DD>
<pre>
⊢ ∀g h f. GroupIso f g h ∧ FINITE G ⇒ CARD G = CARD h.carrier
</pre>

<DT><span class="strong">group_iso_compose</span>
<DD>
<pre>
⊢ ∀g h k f1 f2. GroupIso f1 g h ∧ GroupIso f2 h k ⇒ GroupIso (f2 ∘ f1) g k
</pre>

<DT><span class="strong">group_iso_element</span>
<DD>
<pre>
⊢ ∀f g h. GroupIso f g h ⇒ ∀x. x ∈ G ⇒ f x ∈ h.carrier
</pre>

<DT><span class="strong">group_iso_exp</span>
<DD>
<pre>
⊢ ∀g h f.
    Group g ∧ Group h ∧ GroupIso f g h ⇒
    ∀x. x ∈ G ⇒ ∀n. f (x ** n) = h.exp (f x) n
</pre>

<DT><span class="strong">group_iso_group</span>
<DD>
<pre>
⊢ ∀g h f. Group g ∧ GroupIso f g h ∧ f #e = h.id ⇒ Group h
</pre>

<DT><span class="strong">group_iso_id</span>
<DD>
<pre>
⊢ ∀f g h. Group g ∧ Group h ∧ GroupIso f g h ⇒ f #e = h.id
</pre>

<DT><span class="strong">group_iso_is_monoid_iso</span>
<DD>
<pre>
⊢ ∀g h f. Group g ∧ Group h ∧ GroupIso f g h ⇒ MonoidIso f g h
</pre>

<DT><span class="strong">group_iso_linv_iso</span>
<DD>
<pre>
⊢ ∀g h f. Group g ∧ GroupIso f g h ⇒ GroupIso (LINV f G) h g
</pre>

<DT><span class="strong">group_iso_monoid_iso</span>
<DD>
<pre>
⊢ ∀f g h. GroupIso f g h ∧ f #e = h.id ⇔ MonoidIso f g h
</pre>

<DT><span class="strong">group_iso_order</span>
<DD>
<pre>
⊢ ∀g h f.
    Group g ∧ Group h ∧ GroupIso f g h ⇒ ∀x. x ∈ G ⇒ order h (f x) = ord x
</pre>

<DT><span class="strong">group_iso_property</span>
<DD>
<pre>
⊢ ∀f g h.
    GroupIso f g h ⇔
    GroupHomo f g h ∧ ∀y. y ∈ h.carrier ⇒ ∃!x. x ∈ G ∧ f x = y
</pre>

<DT><span class="strong">group_iso_sym</span>
<DD>
<pre>
⊢ ∀g h f. Group g ∧ GroupIso f g h ⇒ GroupIso (LINV f G) h g
</pre>

<DT><span class="strong">group_iso_trans</span>
<DD>
<pre>
⊢ ∀g h k f1 f2. GroupIso f1 g h ∧ GroupIso f2 h k ⇒ GroupIso (f2 ∘ f1) g k
</pre>

<DT><span class="strong">group_lcancel</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x y z. x ∈ G ∧ y ∈ G ∧ z ∈ G ⇒ (x * y = x * z ⇔ y = z)
</pre>

<DT><span class="strong">group_lid</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ #e * x = x
</pre>

<DT><span class="strong">group_lid_unique</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ (y * x = x ⇔ y = #e)
</pre>

<DT><span class="strong">group_linv</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ |/ x * x = #e
</pre>

<DT><span class="strong">group_linv_assoc</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ y = x * ( |/ x * y) ∧ y = |/ x * (x * y)
</pre>

<DT><span class="strong">group_linv_unique</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ (x * y = #e ⇔ x = |/ y)
</pre>

<DT><span class="strong">group_lsolve</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x y z. x ∈ G ∧ y ∈ G ∧ z ∈ G ⇒ (x * y = z ⇔ x = z * |/ y)
</pre>

<DT><span class="strong">group_normal_equiv</span>
<DD>
<pre>
⊢ ∀g h. h << g ⇒ $== equiv_on G
</pre>

<DT><span class="strong">group_normal_equiv_property</span>
<DD>
<pre>
⊢ ∀h g. h << g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ (x == y ⇔ x ∈ y * H)
</pre>

<DT><span class="strong">group_normal_equiv_reflexive</span>
<DD>
<pre>
⊢ ∀g h. h << g ⇒ ∀z. z ∈ G ⇒ z == z
</pre>

<DT><span class="strong">group_normal_equiv_symmetric</span>
<DD>
<pre>
⊢ ∀g h. h << g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ (x == y ⇔ y == x)
</pre>

<DT><span class="strong">group_normal_equiv_transitive</span>
<DD>
<pre>
⊢ ∀g h. h << g ⇒ ∀x y z. x ∈ G ∧ y ∈ G ∧ z ∈ G ⇒ x == y ∧ y == z ⇒ x == z
</pre>

<DT><span class="strong">group_op_element</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ x * y ∈ G
</pre>

<DT><span class="strong">group_op_linv_eq_id</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ ( |/ x * y = #e ⇔ x = y)
</pre>

<DT><span class="strong">group_op_linv_eqn</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x y z. x ∈ G ∧ y ∈ G ∧ z ∈ G ⇒ ( |/ x * y = z ⇔ y = x * z)
</pre>

<DT><span class="strong">group_op_rinv_eq_id</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ (x * |/ y = #e ⇔ x = y)
</pre>

<DT><span class="strong">group_op_rinv_eqn</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x y z. x ∈ G ∧ y ∈ G ∧ z ∈ G ⇒ (x * |/ y = z ⇔ x = z * y)
</pre>

<DT><span class="strong">group_order_cofactor</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒
      ∀x n. x ∈ G ∧ 0 < ord x ∧ n divides ord x ⇒ ord (x ** (ord x DIV n)) = n
</pre>

<DT><span class="strong">group_order_common</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒
      ∀x y.
        x ∈ G ∧ y ∈ G ∧ x * y = y * x ⇒
        ∃z. z ∈ G ∧ ord z * gcd (ord x) (ord y) = lcm (ord x) (ord y)
</pre>

<DT><span class="strong">group_order_common_coprime</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒
      ∀x y.
        x ∈ G ∧ y ∈ G ∧ x * y = y * x ∧ coprime (ord x) (ord y) ⇒
        ∃z. z ∈ G ∧ ord z = ord x * ord y
</pre>

<DT><span class="strong">group_order_condition</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ ∀m. x ** m = #e ⇔ ord x divides m
</pre>

<DT><span class="strong">group_order_divides</span>
<DD>
<pre>
⊢ ∀g. FiniteGroup g ⇒ ∀x. x ∈ G ⇒ ord x divides CARD G
</pre>

<DT><span class="strong">group_order_divides_exp</span>
<DD>
<pre>
⊢ ∀g x. Group g ∧ x ∈ G ⇒ ∀n. x ** n = #e ⇔ ord x divides n
</pre>

<DT><span class="strong">group_order_divides_maximal</span>
<DD>
<pre>
⊢ ∀g. FiniteAbelianGroup g ⇒ ∀x. x ∈ G ⇒ ord x divides maximal_order g
</pre>

<DT><span class="strong">group_order_divisor</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒
      ∀x m. x ∈ G ∧ 0 < ord x ∧ m divides ord x ⇒ ∃y. y ∈ G ∧ ord y = m
</pre>

<DT><span class="strong">group_order_eq_1</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ (ord x = 1 ⇔ x = #e)
</pre>

<DT><span class="strong">group_order_exp_cofactor</span>
<DD>
<pre>
⊢ ∀g x n.
    Group g ∧ x ∈ G ∧ 0 < ord x ∧ n divides ord x ⇒
    ord (x ** (ord x DIV n)) = n
</pre>

<DT><span class="strong">group_order_id</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ord #e = 1
</pre>

<DT><span class="strong">group_order_inv</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ∧ 0 < ord x ⇒ |/ x = x ** (ord x − 1)
</pre>

<DT><span class="strong">group_order_nonzero</span>
<DD>
<pre>
⊢ ∀g. FiniteGroup g ⇒ ∀x. x ∈ G ⇒ ord x ≠ 0
</pre>

<DT><span class="strong">group_order_pos</span>
<DD>
<pre>
⊢ ∀g. FiniteGroup g ⇒ ∀x. x ∈ G ⇒ 0 < ord x
</pre>

<DT><span class="strong">group_order_power</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ ∀k. ord (x ** k) * gcd (ord x) k = ord x
</pre>

<DT><span class="strong">group_order_power_coprime</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ ∀n. coprime n (ord x) ⇒ ord (x ** n) = ord x
</pre>

<DT><span class="strong">group_order_power_eq_0</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ ∀k. ord (x ** k) = 0 ⇔ 0 < k ∧ ord x = 0
</pre>

<DT><span class="strong">group_order_power_eq_order</span>
<DD>
<pre>
⊢ ∀g x.
    Group g ∧ x ∈ G ∧ 0 < ord x ⇒ ∀k. ord (x ** k) = ord x ⇔ coprime k (ord x)
</pre>

<DT><span class="strong">group_order_power_eqn</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x k. x ∈ G ∧ 0 < k ⇒ ord (x ** k) = ord x DIV gcd k (ord x)
</pre>

<DT><span class="strong">group_order_property</span>
<DD>
<pre>
⊢ ∀g. FiniteGroup g ⇒ ∀x. x ∈ G ⇒ 0 < ord x ∧ x ** ord x = #e
</pre>

<DT><span class="strong">group_order_thm</span>
<DD>
<pre>
⊢ ∀g n. 0 < n ⇒ ∀x. ord x = n ⇔ x ** n = #e ∧ ∀m. 0 < m ∧ m < n ⇒ x ** m ≠ #e
</pre>

<DT><span class="strong">group_order_to_generated_bij</span>
<DD>
<pre>
⊢ ∀g a. Group g ∧ a ∈ G ∧ 0 < ord a ⇒ BIJ (λn. a ** n) (count (ord a)) (Gen a)
</pre>

<DT><span class="strong">group_order_unique</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒
      ∀x. x ∈ G ⇒ ∀m n. m < ord x ∧ n < ord x ∧ x ** m = x ** n ⇒ m = n
</pre>

<DT><span class="strong">group_orders_eq_1</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ orders g 1 = {#e}
</pre>

<DT><span class="strong">group_pair_reduce</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x y z. x ∈ G ∧ y ∈ G ∧ z ∈ G ⇒ x * z * |/ (y * z) = x * |/ y
</pre>

<DT><span class="strong">group_rcancel</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x y z. x ∈ G ∧ y ∈ G ∧ z ∈ G ⇒ (y * x = z * x ⇔ y = z)
</pre>

<DT><span class="strong">group_rid</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ x * #e = x
</pre>

<DT><span class="strong">group_rid_unique</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ (x * y = x ⇔ y = #e)
</pre>

<DT><span class="strong">group_rinv</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x. x ∈ G ⇒ x * |/ x = #e
</pre>

<DT><span class="strong">group_rinv_assoc</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ y = y * |/ x * x ∧ y = y * x * |/ x
</pre>

<DT><span class="strong">group_rinv_unique</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ (x * y = #e ⇔ y = |/ x)
</pre>

<DT><span class="strong">group_rsolve</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀x y z. x ∈ G ∧ y ∈ G ∧ z ∈ G ⇒ (x * y = z ⇔ y = |/ x * z)
</pre>

<DT><span class="strong">group_uroots_group</span>
<DD>
<pre>
⊢ ∀g. AbelianGroup g ⇒ ∀n. Group (uroots n)
</pre>

<DT><span class="strong">group_uroots_has_id</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀n. #e ∈ (uroots n).carrier
</pre>

<DT><span class="strong">group_uroots_subgroup</span>
<DD>
<pre>
⊢ ∀g. AbelianGroup g ⇒ ∀n. uroots n ≤ g
</pre>

<DT><span class="strong">homo_count_formula</span>
<DD>
<pre>
⊢ ∀f g1 g2 h.
    FiniteGroup g1 ∧ Group g2 ∧ h ≤ g2 ∧ GroupHomo f g1 g2 ⇒
    CARD (preimage_group f g1 g2 h.carrier).carrier =
    CARD (kernel_group f (preimage_group f g1 g2 h.carrier) g2).carrier *
    CARD
      (preimage_group f g1 g2 h.carrier /
       kernel_group f (preimage_group f g1 g2 h.carrier) g2).carrier
</pre>

<DT><span class="strong">homo_group_abelian_group</span>
<DD>
<pre>
⊢ ∀g f.
    AbelianGroup g ∧ GroupHomo f g (homo_group g f) ⇒
    AbelianGroup (homo_group g f)
</pre>

<DT><span class="strong">homo_group_assoc</span>
<DD>
<pre>
⊢ ∀g f.
    Group g ∧ GroupHomo f g (homo_group g f) ⇒
    ∀x y z. x ∈ fG ∧ y ∈ fG ∧ z ∈ fG ⇒ (x ∘ y) ∘ z = x ∘ y ∘ z
</pre>

<DT><span class="strong">homo_group_by_inj</span>
<DD>
<pre>
⊢ ∀g f. Group g ∧ INJ f G 𝕌(:β) ⇒ GroupHomo f g (homo_group g f)
</pre>

<DT><span class="strong">homo_group_closure</span>
<DD>
<pre>
⊢ ∀g f.
    Group g ∧ GroupHomo f g (homo_group g f) ⇒
    ∀x y. x ∈ fG ∧ y ∈ fG ⇒ x ∘ y ∈ fG
</pre>

<DT><span class="strong">homo_group_comm</span>
<DD>
<pre>
⊢ ∀g f.
    AbelianGroup g ∧ GroupHomo f g (homo_group g f) ⇒
    ∀x y. x ∈ fG ∧ y ∈ fG ⇒ x ∘ y = y ∘ x
</pre>

<DT><span class="strong">homo_group_group</span>
<DD>
<pre>
⊢ ∀g f. Group g ∧ GroupHomo f g (homo_group g f) ⇒ Group (homo_group g f)
</pre>

<DT><span class="strong">homo_group_id</span>
<DD>
<pre>
⊢ ∀g f.
    Group g ∧ GroupHomo f g (homo_group g f) ⇒
    #i ∈ fG ∧ ∀x. x ∈ fG ⇒ #i ∘ x = x ∧ x ∘ #i = x
</pre>

<DT><span class="strong">homo_group_inv</span>
<DD>
<pre>
⊢ ∀g f.
    Group g ∧ GroupHomo f g (homo_group g f) ⇒
    ∀x. x ∈ fG ⇒ ∃z. z ∈ fG ∧ z ∘ x = #i
</pre>

<DT><span class="strong">homo_image_group</span>
<DD>
<pre>
⊢ ∀g h f. Group g ∧ Group h ∧ GroupHomo f g h ⇒ Group (homo_image f g h)
</pre>

<DT><span class="strong">homo_image_homo_quotient_kernel</span>
<DD>
<pre>
⊢ ∀g h f.
    Group g ∧ Group h ∧ GroupHomo f g h ⇒
    GroupHomo (λz. CHOICE (preimage f G z) * kernel f g h) (homo_image f g h)
      (g / kernel_group f g h)
</pre>

<DT><span class="strong">homo_image_iso_quotient_kernel</span>
<DD>
<pre>
⊢ ∀g h f.
    Group g ∧ Group h ∧ GroupHomo f g h ⇒
    GroupIso (λz. CHOICE (preimage f G z) * kernel f g h) (homo_image f g h)
      (g / kernel_group f g h)
</pre>

<DT><span class="strong">homo_image_monoid</span>
<DD>
<pre>
⊢ ∀g h f. Monoid g ∧ Monoid h ∧ MonoidHomo f g h ⇒ Monoid (homo_image f g h)
</pre>

<DT><span class="strong">homo_image_subgroup</span>
<DD>
<pre>
⊢ ∀g h f. Group g ∧ Group h ∧ GroupHomo f g h ⇒ homo_image f g h ≤ h
</pre>

<DT><span class="strong">homo_image_to_quotient_kernel_bij</span>
<DD>
<pre>
⊢ ∀g h f.
    Group g ∧ Group h ∧ GroupHomo f g h ⇒
    BIJ (λz. CHOICE (preimage f G z) * kernel f g h)
      (homo_image f g h).carrier (g / kernel_group f g h).carrier
</pre>

<DT><span class="strong">homo_restrict_same_kernel</span>
<DD>
<pre>
⊢ ∀f g1 g2 h.
    H ⊆ g1.carrier ∧ GroupHomo f g1 g2 ∧ kernel f g1 g2 ⊆ H ⇒
    kernel f g1 g2 = kernel f h g2
</pre>

<DT><span class="strong">image_iso_preimage_quotient</span>
<DD>
<pre>
⊢ ∀f g1 g2 h.
    Group g1 ∧ Group g2 ∧ h ≤ g2 ∧ GroupHomo f g1 g2 ⇒
    GroupIso
      (λz.
           coset (preimage_group f g1 g2 h.carrier)
             (CHOICE (preimage f (preimage_group f g1 g2 h.carrier).carrier z))
             (kernel f (preimage_group f g1 g2 h.carrier) g2))
      (homo_image f (preimage_group f g1 g2 h.carrier) g2)
      (preimage_group f g1 g2 h.carrier /
       kernel_group f (preimage_group f g1 g2 h.carrier) g2)
</pre>

<DT><span class="strong">image_preimage_group</span>
<DD>
<pre>
⊢ ∀f g1 g2 h.
    Group g1 ∧ Group g2 ∧ h ≤ g2 ∧ GroupHomo f g1 g2 ∧
    SURJ f g1.carrier g2.carrier ⇒
    IMAGE f (PREIMAGE f h.carrier ∩ g1.carrier) = h.carrier
</pre>

<DT><span class="strong">image_preimage_quotient_same_card</span>
<DD>
<pre>
⊢ ∀f g1 g2 h.
    FiniteGroup g1 ∧ Group g2 ∧ h ≤ g2 ∧ GroupHomo f g1 g2 ⇒
    CARD (homo_image f (preimage_group f g1 g2 h.carrier) g2).carrier =
    CARD
      (preimage_group f g1 g2 h.carrier /
       kernel_group f (preimage_group f g1 g2 h.carrier) g2).carrier
</pre>

<DT><span class="strong">image_subgroup_subgroup</span>
<DD>
<pre>
⊢ ∀g1 g2 h f.
    Group g1 ∧ Group g2 ∧ GroupHomo f g1 g2 ∧ h ≤ g1 ⇒ homo_image f h g2 ≤ g2
</pre>

<DT><span class="strong">inCoset_equiv_on_carrier</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ inCoset g h equiv_on G
</pre>

<DT><span class="strong">inCoset_refl</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ ∀a. a ∈ G ⇒ inCoset g h a a
</pre>

<DT><span class="strong">inCoset_sym</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ ∀a b. a ∈ G ∧ b ∈ G ∧ inCoset g h a b ⇒ inCoset g h b a
</pre>

<DT><span class="strong">inCoset_trans</span>
<DD>
<pre>
⊢ ∀g h.
    h ≤ g ⇒
    ∀a b c.
      a ∈ G ∧ b ∈ G ∧ c ∈ G ∧ inCoset g h a b ∧ inCoset g h b c ⇒
      inCoset g h a c
</pre>

<DT><span class="strong">in_coset</span>
<DD>
<pre>
⊢ ∀g X a. a ∈ G ⇒ ∀x. x ∈ a * X ⇔ ∃y. y ∈ X ∧ x = a * y
</pre>

<DT><span class="strong">independent_generated_eq</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒
      ∀a b. a ∈ G ∧ b ∈ G ∧ independent g a b ⇒ (gen a = gen b ⇔ a = b)
</pre>

<DT><span class="strong">independent_generator_2_card</span>
<DD>
<pre>
⊢ ∀g. FiniteGroup g ⇒
      ∀a b.
        a ∈ G ∧ b ∈ G ∧ independent g a b ⇒
        CARD (gen a ∘ gen b).carrier = ord a * ord b
</pre>

<DT><span class="strong">independent_sym</span>
<DD>
<pre>
⊢ ∀g a b. independent g a b ⇔ independent g b a
</pre>

<DT><span class="strong">iso_group_same_card</span>
<DD>
<pre>
⊢ ∀f g h. FINITE G ∧ GroupIso f g h ⇒ CARD G = CARD h.carrier
</pre>

<DT><span class="strong">kernel_element</span>
<DD>
<pre>
⊢ ∀g h f x. x ∈ kernel f g h ⇔ x ∈ G ∧ f x = h.id
</pre>

<DT><span class="strong">kernel_group_group</span>
<DD>
<pre>
⊢ ∀g h f. Group g ∧ Group h ∧ GroupHomo f g h ⇒ Group (kernel_group f g h)
</pre>

<DT><span class="strong">kernel_group_normal</span>
<DD>
<pre>
⊢ ∀g h f. Group g ∧ Group h ∧ GroupHomo f g h ⇒ kernel_group f g h << g
</pre>

<DT><span class="strong">kernel_group_subgroup</span>
<DD>
<pre>
⊢ ∀g h f. Group g ∧ Group h ∧ GroupHomo f g h ⇒ kernel_group f g h ≤ g
</pre>

<DT><span class="strong">kernel_property</span>
<DD>
<pre>
⊢ ∀g h f x. x ∈ kernel f g h ⇔ x ∈ G ∧ f x = h.id
</pre>

<DT><span class="strong">kernel_quotient_group</span>
<DD>
<pre>
⊢ ∀g h f. Group g ∧ Group h ∧ GroupHomo f g h ⇒ Group (g / kernel_group f g h)
</pre>

<DT><span class="strong">left_coset_alt</span>
<DD>
<pre>
⊢ ∀g X a. left_coset g X a = {a * z | z ∈ X}
</pre>

<DT><span class="strong">make_group_property</span>
<DD>
<pre>
⊢ ∀g s.
    (make_group g s).carrier = s ∧ (make_group g s).op = $* ∧
    (make_group g s).id = #e
</pre>

<DT><span class="strong">monoid_homo_homo_image_monoid</span>
<DD>
<pre>
⊢ ∀g h f. Monoid g ∧ MonoidHomo f g h ⇒ Monoid (homo_image f g h)
</pre>

<DT><span class="strong">monoid_inv_id</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ |/ #e = #e
</pre>

<DT><span class="strong">monoid_inv_order</span>
<DD>
<pre>
⊢ ∀g x. Monoid g ∧ x ∈ G* ⇒ ord ( |/ x) = ord x
</pre>

<DT><span class="strong">monoid_inv_order_property</span>
<DD>
<pre>
⊢ ∀g. FiniteMonoid g ⇒ ∀x. x ∈ G* ⇒ 0 < ord x ∧ x ** ord x = #e
</pre>

<DT><span class="strong">monoid_invertibles_is_group</span>
<DD>
<pre>
⊢ ∀g. Monoid g ⇒ Group (Invertibles g)
</pre>

<DT><span class="strong">mult_mod_abelian_group</span>
<DD>
<pre>
⊢ ∀p. prime p ⇒ AbelianGroup (mult_mod p)
</pre>

<DT><span class="strong">mult_mod_card</span>
<DD>
<pre>
⊢ ∀p. 0 < p ⇒ CARD (mult_mod p).carrier = p − 1
</pre>

<DT><span class="strong">mult_mod_carrier</span>
<DD>
<pre>
⊢ ∀p. (mult_mod p).carrier = {i | i ≠ 0 ∧ i < p}
</pre>

<DT><span class="strong">mult_mod_carrier_alt</span>
<DD>
<pre>
⊢ ∀p. (mult_mod p).carrier = residue p
</pre>

<DT><span class="strong">mult_mod_element</span>
<DD>
<pre>
⊢ ∀p x. x ∈ (mult_mod p).carrier ⇔ x ≠ 0 ∧ x < p
</pre>

<DT><span class="strong">mult_mod_element_alt</span>
<DD>
<pre>
⊢ ∀p x. x ∈ (mult_mod p).carrier ⇔ 0 < x ∧ x < p
</pre>

<DT><span class="strong">mult_mod_eval</span>
<DD>
<pre>
⊢ ∀p. (mult_mod p).carrier = {i | i ≠ 0 ∧ i < p} ∧
      (∀x y. (mult_mod p).op x y = (x * y) MOD p) ∧ (mult_mod p).id = 1
</pre>

<DT><span class="strong">mult_mod_exp</span>
<DD>
<pre>
⊢ ∀p a.
    prime p ∧ a ∈ (mult_mod p).carrier ⇒
    ∀n. (mult_mod p).exp a n = a ** n MOD p
</pre>

<DT><span class="strong">mult_mod_finite</span>
<DD>
<pre>
⊢ ∀p. FINITE (mult_mod p).carrier
</pre>

<DT><span class="strong">mult_mod_finite_abelian_group</span>
<DD>
<pre>
⊢ ∀p. prime p ⇒ FiniteAbelianGroup (mult_mod p)
</pre>

<DT><span class="strong">mult_mod_finite_group</span>
<DD>
<pre>
⊢ ∀p. prime p ⇒ FiniteGroup (mult_mod p)
</pre>

<DT><span class="strong">mult_mod_group</span>
<DD>
<pre>
⊢ ∀p. prime p ⇒ Group (mult_mod p)
</pre>

<DT><span class="strong">mult_mod_id</span>
<DD>
<pre>
⊢ ∀p. (mult_mod p).id = 1
</pre>

<DT><span class="strong">mult_mod_inv</span>
<DD>
<pre>
⊢ ∀p. prime p ⇒
      ∀x. 0 < x ∧ x < p ⇒
          (mult_mod p).inv x = (mult_mod p).exp x (order (mult_mod p) x − 1)
</pre>

<DT><span class="strong">mult_mod_inv_compute</span>
<DD>
<pre>
⊢ ∀p x.
    (mult_mod p).inv x =
    if prime p ∧ 0 < x ∧ x < p then
      (mult_mod p).exp x (order (mult_mod p) x − 1)
    else FAIL ((mult_mod p).inv x) bad_element
</pre>

<DT><span class="strong">mult_mod_inverse</span>
<DD>
<pre>
⊢ ∀p. prime p ⇒ ∀a. 0 < a ∧ a < p ⇒ (mult_mod p).inv a = a ** (p − 2) MOD p
</pre>

<DT><span class="strong">mult_mod_inverse_compute</span>
<DD>
<pre>
⊢ ∀p a.
    (mult_mod p).inv a =
    if prime p ∧ 0 < a ∧ a < p then a ** (p − 2) MOD p else (mult_mod p).inv a
</pre>

<DT><span class="strong">mult_mod_property</span>
<DD>
<pre>
⊢ ∀p. (∀x. x ∈ (mult_mod p).carrier ⇒ x ≠ 0) ∧
      (∀x. x ∈ (mult_mod p).carrier ⇔ 0 < x ∧ x < p) ∧ (mult_mod p).id = 1 ∧
      (∀x y. (mult_mod p).op x y = (x * y) MOD p) ∧
      FINITE (mult_mod p).carrier ∧
      (0 < p ⇒ CARD (mult_mod p).carrier = p − 1)
</pre>

<DT><span class="strong">multi_orbits_element</span>
<DD>
<pre>
⊢ ∀f g X e. e ∈ multi_orbits f g X ⇔ e ∈ orbits f g X ∧ ¬SING e
</pre>

<DT><span class="strong">multi_orbits_element_finite</span>
<DD>
<pre>
⊢ ∀f g X e. (g act X) f ∧ FINITE X ∧ e ∈ multi_orbits f g X ⇒ FINITE e
</pre>

<DT><span class="strong">multi_orbits_element_subset</span>
<DD>
<pre>
⊢ ∀f g X e. (g act X) f ∧ e ∈ multi_orbits f g X ⇒ e ⊆ X
</pre>

<DT><span class="strong">multi_orbits_finite</span>
<DD>
<pre>
⊢ ∀f g X. FINITE X ⇒ FINITE (multi_orbits f g X)
</pre>

<DT><span class="strong">multi_orbits_subset</span>
<DD>
<pre>
⊢ ∀f g X. multi_orbits f g X ⊆ orbits f g X
</pre>

<DT><span class="strong">non_fixed_points_card</span>
<DD>
<pre>
⊢ ∀f g X.
    FINITE X ⇒
    CARD (X DIFF fixed_points f g X) = CARD X − CARD (fixed_points f g X)
</pre>

<DT><span class="strong">non_fixed_points_orbit_not_sing</span>
<DD>
<pre>
⊢ ∀f g X.
    Group g ∧ (g act X) f ⇒
    ∀x. x ∈ X DIFF fixed_points f g X ⇔ x ∈ X ∧ ¬SING (orbit f g x)
</pre>

<DT><span class="strong">normal_cogen_property</span>
<DD>
<pre>
⊢ ∀g h. h << g ⇒ ∀x. x ∈ G ⇒ x / cogen g h (x * H) ∈ H
</pre>

<DT><span class="strong">normal_coset_op_property</span>
<DD>
<pre>
⊢ ∀g h.
    h << g ⇒
    ∀x y.
      x ∈ CosetPartition g h ∧ y ∈ CosetPartition g h ⇒
      x ∘ y =
      CHOICE (preimage (left_coset g H) G x) *
      CHOICE (preimage (left_coset g H) G y) * H
</pre>

<DT><span class="strong">normal_coset_property</span>
<DD>
<pre>
⊢ ∀g h.
    h << g ⇒
    ∀a b.
      a ∈ G ∧ b ∈ G ⇒ cogen g h (a * H) * cogen g h (b * H) * H = a * b * H
</pre>

<DT><span class="strong">normal_coset_property1</span>
<DD>
<pre>
⊢ ∀g h. h << g ⇒ ∀a b. a ∈ G ∧ b ∈ G ⇒ cogen g h (a * H) * b * H = a * b * H
</pre>

<DT><span class="strong">normal_coset_property2</span>
<DD>
<pre>
⊢ ∀g h. h << g ⇒ ∀a b. a ∈ G ∧ b ∈ G ⇒ a * cogen g h (b * H) * H = a * b * H
</pre>

<DT><span class="strong">normal_iff_preimage_normal</span>
<DD>
<pre>
⊢ ∀f g1 g2 h2.
    Group g1 ∧ Group g2 ∧ h2 ≤ g2 ∧ GroupHomo f g1 g2 ∧
    SURJ f g1.carrier g2.carrier ⇒
    (h2 << g2 ⇔ preimage_group f g1 g2 h2.carrier << g1)
</pre>

<DT><span class="strong">normal_preimage_normal</span>
<DD>
<pre>
⊢ ∀f g1 g2 h2.
    Group g1 ∧ Group g2 ∧ h2 ≤ g2 ∧ GroupHomo f g1 g2 ⇒
    h2 << g2 ⇒
    preimage_group f g1 g2 h2.carrier << g1
</pre>

<DT><span class="strong">normal_subgroup_alt</span>
<DD>
<pre>
⊢ ∀g h. h << g ⇔ h ≤ g ∧ ∀a. a ∈ G ⇒ a * H = H * a
</pre>

<DT><span class="strong">normal_subgroup_antisym</span>
<DD>
<pre>
⊢ ∀g h. h << g ∧ g << h ⇒ h = g
</pre>

<DT><span class="strong">normal_subgroup_coset_eq</span>
<DD>
<pre>
⊢ ∀g h. h << g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ (x * H = y * H ⇔ x / y ∈ H)
</pre>

<DT><span class="strong">normal_subgroup_coset_homo</span>
<DD>
<pre>
⊢ ∀g h. h << g ⇒ GroupHomo (left_coset g H) g (g / h)
</pre>

<DT><span class="strong">normal_subgroup_groups</span>
<DD>
<pre>
⊢ ∀g h. h << g ⇒ h ≤ g ∧ Group h ∧ Group g
</pre>

<DT><span class="strong">normal_subgroup_property</span>
<DD>
<pre>
⊢ ∀h g. h << g ⇒ ∀a z. a ∈ G ∧ z ∈ H ⇒ a * z / a ∈ H
</pre>

<DT><span class="strong">normal_subgroup_refl</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ g << g
</pre>

<DT><span class="strong">normal_subgroup_subgroup</span>
<DD>
<pre>
⊢ ∀h g. h << g ⇒ h ≤ g
</pre>

<DT><span class="strong">normal_surj_normal</span>
<DD>
<pre>
⊢ ∀f g1 g2 h2.
    Group g1 ∧ Group g2 ∧ h2 ≤ g2 ∧ GroupHomo f g1 g2 ∧
    SURJ f g1.carrier g2.carrier ⇒
    preimage_group f g1 g2 h2.carrier << g1 ⇒
    h2 << g2
</pre>

<DT><span class="strong">orbit_alt</span>
<DD>
<pre>
⊢ ∀f g x. orbit f g x = {f a x | a ∈ G}
</pre>

<DT><span class="strong">orbit_card_divides_target_card</span>
<DD>
<pre>
⊢ ∀f g X x.
    FiniteGroup g ∧ (g act X) f ∧ x ∈ X ∧ FINITE X ⇒
    CARD (orbit f g x) divides CARD G
</pre>

<DT><span class="strong">orbit_element</span>
<DD>
<pre>
⊢ ∀f g x y. y ∈ orbit f g x ⇔ reach f g x y
</pre>

<DT><span class="strong">orbit_element_in_target</span>
<DD>
<pre>
⊢ ∀f g X x y. (g act X) f ∧ x ∈ X ∧ y ∈ orbit f g x ⇒ y ∈ X
</pre>

<DT><span class="strong">orbit_eq_equiv_class</span>
<DD>
<pre>
⊢ ∀f g X x. (g act X) f ∧ x ∈ X ⇒ orbit f g x = equiv_class (reach f g) X x
</pre>

<DT><span class="strong">orbit_eq_orbit</span>
<DD>
<pre>
⊢ ∀f g X x y.
    Group g ∧ (g act X) f ∧ x ∈ X ∧ y ∈ X ⇒
    (orbit f g x = orbit f g y ⇔ reach f g x y)
</pre>

<DT><span class="strong">orbit_finite</span>
<DD>
<pre>
⊢ ∀f g x. FINITE G ⇒ FINITE (orbit f g x)
</pre>

<DT><span class="strong">orbit_finite_by_target</span>
<DD>
<pre>
⊢ ∀f g X x. (g act X) f ∧ x ∈ X ∧ FINITE X ⇒ FINITE (orbit f g x)
</pre>

<DT><span class="strong">orbit_finite_inj_card_eq</span>
<DD>
<pre>
⊢ ∀f g X x.
    (g act X) f ∧ x ∈ X ∧ FINITE X ∧ INJ (λa. f a x) G (orbit f g x) ⇒
    CARD (orbit f g x) = CARD G
</pre>

<DT><span class="strong">orbit_has_action_element</span>
<DD>
<pre>
⊢ ∀f g x a. a ∈ G ⇒ f a x ∈ orbit f g x
</pre>

<DT><span class="strong">orbit_has_self</span>
<DD>
<pre>
⊢ ∀f g X x. Group g ∧ (g act X) f ∧ x ∈ X ⇒ x ∈ orbit f g x
</pre>

<DT><span class="strong">orbit_is_orbits_element</span>
<DD>
<pre>
⊢ ∀f g X x. x ∈ X ⇒ orbit f g x ∈ orbits f g X
</pre>

<DT><span class="strong">orbit_sing_fixed_points</span>
<DD>
<pre>
⊢ ∀f g X. (g act X) f ⇒ ∀x. x ∈ X ∧ orbit f g x = {x} ⇒ x ∈ fixed_points f g X
</pre>

<DT><span class="strong">orbit_stabilizer_cosets_bij</span>
<DD>
<pre>
⊢ ∀f g X x.
    Group g ∧ (g act X) f ∧ x ∈ X ⇒
    BIJ (λy. act_by f g x y * stabilizer f g x) (orbit f g x)
      {a * stabilizer f g x | a | a ∈ G}
</pre>

<DT><span class="strong">orbit_stabilizer_cosets_bij_alt</span>
<DD>
<pre>
⊢ ∀f g X x.
    Group g ∧ (g act X) f ∧ x ∈ X ⇒
    BIJ (λy. act_by f g x y * stabilizer f g x) (orbit f g x)
      (CosetPartition g (StabilizerGroup f g x))
</pre>

<DT><span class="strong">orbit_stabilizer_map_good</span>
<DD>
<pre>
⊢ ∀f g X x.
    Group g ∧ (g act X) f ∧ x ∈ X ⇒
    ∀a b.
      a ∈ G ∧ b ∈ G ∧ f a x = f b x ⇒
      a * stabilizer f g x = b * stabilizer f g x
</pre>

<DT><span class="strong">orbit_stabilizer_map_inj</span>
<DD>
<pre>
⊢ ∀f g X x.
    Group g ∧ (g act X) f ∧ x ∈ X ⇒
    ∀a b.
      a ∈ G ∧ b ∈ G ∧ a * stabilizer f g x = b * stabilizer f g x ⇒
      f a x = f b x
</pre>

<DT><span class="strong">orbit_stabilizer_thm</span>
<DD>
<pre>
⊢ ∀f g X x.
    FiniteGroup g ∧ (g act X) f ∧ x ∈ X ∧ FINITE X ⇒
    CARD G = CARD (orbit f g x) * CARD (stabilizer f g x)
</pre>

<DT><span class="strong">orbit_subset_target</span>
<DD>
<pre>
⊢ ∀f g X x. (g act X) f ∧ x ∈ X ⇒ orbit f g x ⊆ X
</pre>

<DT><span class="strong">orbits_alt</span>
<DD>
<pre>
⊢ ∀f g X. orbits f g X = {orbit f g x | x ∈ X}
</pre>

<DT><span class="strong">orbits_element</span>
<DD>
<pre>
⊢ ∀f g X e. e ∈ orbits f g X ⇔ ∃x. x ∈ X ∧ e = orbit f g x
</pre>

<DT><span class="strong">orbits_element_element</span>
<DD>
<pre>
⊢ ∀f g X e x. (g act X) f ∧ e ∈ orbits f g X ∧ x ∈ e ⇒ x ∈ X
</pre>

<DT><span class="strong">orbits_element_finite</span>
<DD>
<pre>
⊢ ∀f g X. (g act X) f ∧ FINITE X ⇒ EVERY_FINITE (orbits f g X)
</pre>

<DT><span class="strong">orbits_element_is_orbit</span>
<DD>
<pre>
⊢ ∀f g X e x.
    Group g ∧ (g act X) f ∧ e ∈ orbits f g X ∧ x ∈ e ⇒ e = orbit f g x
</pre>

<DT><span class="strong">orbits_element_nonempty</span>
<DD>
<pre>
⊢ ∀f g X. Group g ∧ (g act X) f ⇒ ∀e. e ∈ orbits f g X ⇒ e ≠ ∅
</pre>

<DT><span class="strong">orbits_element_subset</span>
<DD>
<pre>
⊢ ∀f g X e. (g act X) f ∧ e ∈ orbits f g X ⇒ e ⊆ X
</pre>

<DT><span class="strong">orbits_eq_partition</span>
<DD>
<pre>
⊢ ∀f g X. (g act X) f ⇒ orbits f g X = partition (reach f g) X
</pre>

<DT><span class="strong">orbits_equal_size_partition_equal_size</span>
<DD>
<pre>
⊢ ∀f g X n.
    Group g ∧ (g act X) f ∧ FINITE X ∧ (∀x. x ∈ X ⇒ CARD (orbit f g x) = n) ⇒
    ∀e. e ∈ orbits f g X ⇒ CARD e = n
</pre>

<DT><span class="strong">orbits_equal_size_property</span>
<DD>
<pre>
⊢ ∀f g X n.
    Group g ∧ (g act X) f ∧ FINITE X ∧ (∀x. x ∈ X ⇒ CARD (orbit f g x) = n) ⇒
    n divides CARD X
</pre>

<DT><span class="strong">orbits_finite</span>
<DD>
<pre>
⊢ ∀f g X. FINITE X ⇒ FINITE (orbits f g X)
</pre>

<DT><span class="strong">orbits_size_factor_partition_factor</span>
<DD>
<pre>
⊢ ∀f g X n.
    Group g ∧ (g act X) f ∧ FINITE X ∧
    (∀x. x ∈ X ⇒ n divides CARD (orbit f g x)) ⇒
    ∀e. e ∈ orbits f g X ⇒ n divides CARD e
</pre>

<DT><span class="strong">orbits_size_factor_property</span>
<DD>
<pre>
⊢ ∀f g X n.
    Group g ∧ (g act X) f ∧ FINITE X ∧
    (∀x. x ∈ X ⇒ n divides CARD (orbit f g x)) ⇒
    n divides CARD X
</pre>

<DT><span class="strong">orders_is_feq_class_order</span>
<DD>
<pre>
⊢ ∀g. orders g = preimage ord G
</pre>

<DT><span class="strong">preimage_cardinality</span>
<DD>
<pre>
⊢ ∀f g1 g2 h.
    FiniteGroup g1 ∧ Group g2 ∧ h ≤ g2 ∧ GroupHomo f g1 g2 ∧
    SURJ f g1.carrier g2.carrier ⇒
    CARD (preimage_group f g1 g2 h.carrier).carrier =
    CARD h.carrier * CARD (kernel f g1 g2)
</pre>

<DT><span class="strong">preimage_group_group</span>
<DD>
<pre>
⊢ ∀f g1 g2 h.
    Group g1 ∧ Group g2 ∧ GroupHomo f g1 g2 ∧ h ≤ g2 ⇒
    Group (preimage_group f g1 g2 h.carrier)
</pre>

<DT><span class="strong">preimage_group_property</span>
<DD>
<pre>
⊢ ∀f g1 g2 h x. x ∈ PREIMAGE f h ∩ g1.carrier ⇒ x ∈ g1.carrier ∧ f x ∈ h
</pre>

<DT><span class="strong">preimage_image_subset</span>
<DD>
<pre>
⊢ ∀f g1 g2 h.
    Group g1 ∧ Group g2 ∧ h ≤ g1 ∧ GroupHomo f g1 g2 ∧
    SURJ f g1.carrier g2.carrier ∧ kernel f g1 g2 ⊆ H ⇒
    PREIMAGE f (IMAGE f H) ∩ g1.carrier ⊆ H
</pre>

<DT><span class="strong">preimage_subgroup_kernel</span>
<DD>
<pre>
⊢ ∀f g1 g2 h2.
    Group g1 ∧ Group g2 ∧ h2 ≤ g2 ∧ GroupHomo f g1 g2 ⇒
    kernel f g1 g2 ⊆ PREIMAGE f h2.carrier ∩ g1.carrier
</pre>

<DT><span class="strong">preimage_subgroup_subgroup</span>
<DD>
<pre>
⊢ ∀f g1 g2 h.
    Group g1 ∧ Group g2 ∧ GroupHomo f g1 g2 ∧ h ≤ g2 ⇒
    preimage_group f g1 g2 h.carrier ≤ g1
</pre>

<DT><span class="strong">prod_image_as_op_image</span>
<DD>
<pre>
⊢ ∏ = OP_IMAGE (λx y. x * y) 1
</pre>

<DT><span class="strong">quotient_group_assoc</span>
<DD>
<pre>
⊢ ∀g h.
    h << g ⇒
    ∀x y z.
      x ∈ CosetPartition g h ∧ y ∈ CosetPartition g h ∧ z ∈ CosetPartition g h ⇒
      (x ∘ y) ∘ z = x ∘ y ∘ z
</pre>

<DT><span class="strong">quotient_group_closure</span>
<DD>
<pre>
⊢ ∀g h.
    h ≤ g ⇒
    ∀x y.
      x ∈ CosetPartition g h ∧ y ∈ CosetPartition g h ⇒
      x ∘ y ∈ CosetPartition g h
</pre>

<DT><span class="strong">quotient_group_group</span>
<DD>
<pre>
⊢ ∀g h. h << g ⇒ Group (g / h)
</pre>

<DT><span class="strong">quotient_group_id</span>
<DD>
<pre>
⊢ ∀g h.
    h << g ⇒ H ∈ CosetPartition g h ∧ ∀x. x ∈ CosetPartition g h ⇒ H ∘ x = x
</pre>

<DT><span class="strong">quotient_group_inv</span>
<DD>
<pre>
⊢ ∀g h.
    h << g ⇒
    ∀x. x ∈ CosetPartition g h ⇒ ∃y. y ∈ CosetPartition g h ∧ y ∘ x = H
</pre>

<DT><span class="strong">reach_equiv</span>
<DD>
<pre>
⊢ ∀f g X. Group g ∧ (g act X) f ⇒ reach f g equiv_on X
</pre>

<DT><span class="strong">reach_refl</span>
<DD>
<pre>
⊢ ∀f g X x. Group g ∧ (g act X) f ∧ x ∈ X ⇒ reach f g x x
</pre>

<DT><span class="strong">reach_sym</span>
<DD>
<pre>
⊢ ∀f g X x y.
    Group g ∧ (g act X) f ∧ x ∈ X ∧ y ∈ X ∧ reach f g x y ⇒ reach f g y x
</pre>

<DT><span class="strong">reach_trans</span>
<DD>
<pre>
⊢ ∀f g X x y z.
    Group g ∧ (g act X) f ∧ x ∈ X ∧ y ∈ X ∧ z ∈ X ∧ reach f g x y ∧
    reach f g y z ⇒
    reach f g x z
</pre>

<DT><span class="strong">right_coset_alt</span>
<DD>
<pre>
⊢ ∀g X a. X * a = {z * a | z ∈ X}
</pre>

<DT><span class="strong">roots_of_unity_0</span>
<DD>
<pre>
⊢ ∀g. (uroots 0).carrier = G
</pre>

<DT><span class="strong">roots_of_unity_element</span>
<DD>
<pre>
⊢ ∀g n x. x ∈ (uroots n).carrier ⇔ x ∈ G ∧ x ** n = #e
</pre>

<DT><span class="strong">roots_of_unity_subset</span>
<DD>
<pre>
⊢ ∀g n. (uroots n).carrier ⊆ G
</pre>

<DT><span class="strong">sing_orbits_card_eqn</span>
<DD>
<pre>
⊢ ∀f g X.
    Group g ∧ (g act X) f ∧ FINITE X ⇒
    CARD (sing_orbits f g X) = CARD (fixed_points f g X)
</pre>

<DT><span class="strong">sing_orbits_element</span>
<DD>
<pre>
⊢ ∀f g X e. e ∈ sing_orbits f g X ⇔ e ∈ orbits f g X ∧ SING e
</pre>

<DT><span class="strong">sing_orbits_element_card</span>
<DD>
<pre>
⊢ ∀f g X e. e ∈ sing_orbits f g X ⇒ CARD e = 1
</pre>

<DT><span class="strong">sing_orbits_element_choice</span>
<DD>
<pre>
⊢ ∀f g X.
    Group g ∧ (g act X) f ⇒
    ∀e. e ∈ sing_orbits f g X ⇒ CHOICE e ∈ fixed_points f g X
</pre>

<DT><span class="strong">sing_orbits_element_finite</span>
<DD>
<pre>
⊢ ∀f g X e. e ∈ sing_orbits f g X ⇒ FINITE e
</pre>

<DT><span class="strong">sing_orbits_element_subset</span>
<DD>
<pre>
⊢ ∀f g X e. (g act X) f ∧ e ∈ sing_orbits f g X ⇒ e ⊆ X
</pre>

<DT><span class="strong">sing_orbits_finite</span>
<DD>
<pre>
⊢ ∀f g X. FINITE X ⇒ FINITE (sing_orbits f g X)
</pre>

<DT><span class="strong">sing_orbits_subset</span>
<DD>
<pre>
⊢ ∀f g X. sing_orbits f g X ⊆ orbits f g X
</pre>

<DT><span class="strong">sing_orbits_to_fixed_points_bij</span>
<DD>
<pre>
⊢ ∀f g X.
    Group g ∧ (g act X) f ⇒
    BIJ (λe. CHOICE e) (sing_orbits f g X) (fixed_points f g X)
</pre>

<DT><span class="strong">sing_orbits_to_fixed_points_inj</span>
<DD>
<pre>
⊢ ∀f g X.
    Group g ∧ (g act X) f ⇒
    INJ (λe. CHOICE e) (sing_orbits f g X) (fixed_points f g X)
</pre>

<DT><span class="strong">sing_orbits_to_fixed_points_surj</span>
<DD>
<pre>
⊢ ∀f g X.
    Group g ∧ (g act X) f ⇒
    SURJ (λe. CHOICE e) (sing_orbits f g X) (fixed_points f g X)
</pre>

<DT><span class="strong">stabilizer_as_image</span>
<DD>
<pre>
⊢ ∀f g X x.
    Group g ∧ (g act X) f ∧ x ∈ X ⇒
    stabilizer f g x = IMAGE (λa. if f a x = x then a else #e) G
</pre>

<DT><span class="strong">stabilizer_conjugate</span>
<DD>
<pre>
⊢ ∀f g X x a.
    Group g ∧ (g act X) f ∧ x ∈ X ∧ a ∈ G ⇒
    conjugate g a (stabilizer f g x) = stabilizer f g (f a x)
</pre>

<DT><span class="strong">stabilizer_element</span>
<DD>
<pre>
⊢ ∀f g x a. a ∈ stabilizer f g x ⇔ a ∈ G ∧ f a x = x
</pre>

<DT><span class="strong">stabilizer_group_card_divides</span>
<DD>
<pre>
⊢ ∀f g X x.
    FiniteGroup g ∧ (g act X) f ∧ x ∈ X ⇒
    CARD (stabilizer f g x) divides CARD G
</pre>

<DT><span class="strong">stabilizer_group_carrier</span>
<DD>
<pre>
⊢ ∀f g x. (StabilizerGroup f g x).carrier = stabilizer f g x
</pre>

<DT><span class="strong">stabilizer_group_finite_group</span>
<DD>
<pre>
⊢ ∀f g X x.
    FiniteGroup g ∧ (g act X) f ∧ x ∈ X ⇒ FiniteGroup (StabilizerGroup f g x)
</pre>

<DT><span class="strong">stabilizer_group_group</span>
<DD>
<pre>
⊢ ∀f g X x. Group g ∧ (g act X) f ∧ x ∈ X ⇒ Group (StabilizerGroup f g x)
</pre>

<DT><span class="strong">stabilizer_group_id</span>
<DD>
<pre>
⊢ ∀f g x. (StabilizerGroup f g x).id = #e
</pre>

<DT><span class="strong">stabilizer_group_property</span>
<DD>
<pre>
⊢ ∀f g x.
    (StabilizerGroup f g x).carrier = stabilizer f g x ∧
    (StabilizerGroup f g x).op = $* ∧ (StabilizerGroup f g x).id = #e
</pre>

<DT><span class="strong">stabilizer_group_subgroup</span>
<DD>
<pre>
⊢ ∀f g X x. Group g ∧ (g act X) f ∧ x ∈ X ⇒ StabilizerGroup f g x ≤ g
</pre>

<DT><span class="strong">stabilizer_has_id</span>
<DD>
<pre>
⊢ ∀f g X x. Group g ∧ (g act X) f ∧ x ∈ X ⇒ #e ∈ stabilizer f g x
</pre>

<DT><span class="strong">stabilizer_nonempty</span>
<DD>
<pre>
⊢ ∀f g X x. Group g ∧ (g act X) f ∧ x ∈ X ⇒ stabilizer f g x ≠ ∅
</pre>

<DT><span class="strong">stabilizer_subset</span>
<DD>
<pre>
⊢ ∀f g x. stabilizer f g x ⊆ G
</pre>

<DT><span class="strong">subgroup_I_antisym</span>
<DD>
<pre>
⊢ ∀g h. subgroup h g ∧ subgroup g h ⇒ GroupIso I h g
</pre>

<DT><span class="strong">subgroup_alt</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒
      ∀h. h ≤ g ⇔
          H ≠ ∅ ∧ H ⊆ G ∧ h.op = $* ∧ h.id = #e ∧
          ∀x y. x ∈ H ∧ y ∈ H ⇒ x * |/ y ∈ H
</pre>

<DT><span class="strong">subgroup_antisym</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ∧ g ≤ h ⇒ h = g
</pre>

<DT><span class="strong">subgroup_big_cross_empty</span>
<DD>
<pre>
⊢ ∀g. sgbcross ∅ = gen #e
</pre>

<DT><span class="strong">subgroup_big_cross_insert</span>
<DD>
<pre>
⊢ ∀g. FiniteAbelianGroup g ⇒
      ∀B. B ⊆ all_subgroups g ⇒
          ∀h. h ∈ all_subgroups g ∧ h ∉ B ⇒
              sgbcross (h INSERT B) = h ∘ sgbcross B
</pre>

<DT><span class="strong">subgroup_big_cross_thm</span>
<DD>
<pre>
⊢ ∀g. FiniteAbelianGroup g ⇒
      ∀B. B ⊆ all_subgroups g ⇒
          ∀h. h ∈ all_subgroups g ⇒
              sgbcross (h INSERT B) = h ∘ sgbcross (B DELETE h)
</pre>

<DT><span class="strong">subgroup_big_intersect_element</span>
<DD>
<pre>
⊢ ∀g x. x ∈ (sgbINTER g).carrier ⇔ ∀h. h ≤ g ⇒ x ∈ H
</pre>

<DT><span class="strong">subgroup_big_intersect_group</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ Group (sgbINTER g)
</pre>

<DT><span class="strong">subgroup_big_intersect_has_id</span>
<DD>
<pre>
⊢ ∀g. (sgbINTER g).id ∈ (sgbINTER g).carrier
</pre>

<DT><span class="strong">subgroup_big_intersect_has_inv</span>
<DD>
<pre>
⊢ ∀g x. x ∈ (sgbINTER g).carrier ⇒ |/ x ∈ (sgbINTER g).carrier
</pre>

<DT><span class="strong">subgroup_big_intersect_op_element</span>
<DD>
<pre>
⊢ ∀g x y.
    x ∈ (sgbINTER g).carrier ∧ y ∈ (sgbINTER g).carrier ⇒
    (sgbINTER g).op x y ∈ (sgbINTER g).carrier
</pre>

<DT><span class="strong">subgroup_big_intersect_property</span>
<DD>
<pre>
⊢ ∀g. (sgbINTER g).carrier = BIGINTER (IMAGE (λh. H) {h | h ≤ g}) ∧
      (∀x y.
         x ∈ (sgbINTER g).carrier ∧ y ∈ (sgbINTER g).carrier ⇒
         (sgbINTER g).op x y = x * y) ∧ (sgbINTER g).id = #e
</pre>

<DT><span class="strong">subgroup_big_intersect_subgroup</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ sgbINTER g ≤ g
</pre>

<DT><span class="strong">subgroup_big_intersect_subset</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ (sgbINTER g).carrier ⊆ G
</pre>

<DT><span class="strong">subgroup_carrier_antisym</span>
<DD>
<pre>
⊢ ∀g h. subgroup h g ∧ G ⊆ H ⇒ GroupIso I h g
</pre>

<DT><span class="strong">subgroup_carrier_nonempty</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ H ≠ ∅
</pre>

<DT><span class="strong">subgroup_carrier_subset</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ H ⊆ G
</pre>

<DT><span class="strong">subgroup_conjugate_subgroup_bij</span>
<DD>
<pre>
⊢ ∀g h.
    h ≤ g ⇒
    ∀a. a ∈ G ⇒ BIJ (λz. a * z * |/ a) H (conjugate_subgroup h g a).carrier
</pre>

<DT><span class="strong">subgroup_coset_card</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ∧ FINITE H ⇒ ∀a. a ∈ G ⇒ CARD (a * H) = CARD H
</pre>

<DT><span class="strong">subgroup_coset_card_partition_element</span>
<DD>
<pre>
⊢ ∀g h.
    h ≤ g ∧ FINITE G ⇒ ∀e. e ∈ partition (left_coset g H) G ⇒ CARD e = CARD H
</pre>

<DT><span class="strong">subgroup_coset_eq</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ ∀x y. x ∈ G ∧ y ∈ G ⇒ (x * H = y * H ⇔ |/ y * x ∈ H)
</pre>

<DT><span class="strong">subgroup_coset_in_partition</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ ∀x. x ∈ IMAGE (left_coset g H) G ⇔ x ∈ CosetPartition g h
</pre>

<DT><span class="strong">subgroup_coset_nonempty</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ ∀x. x ∈ G ⇒ x ∈ x * H
</pre>

<DT><span class="strong">subgroup_coset_partition_element</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ ∀e. e ∈ partition (left_coset g H) G ⇔ ∃a. a ∈ G ∧ e = a * H
</pre>

<DT><span class="strong">subgroup_coset_subset</span>
<DD>
<pre>
⊢ ∀g h a x. h ≤ g ∧ a ∈ G ∧ x ∈ a * H ⇒ x ∈ G
</pre>

<DT><span class="strong">subgroup_coset_sym</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ ∀a b. a ∈ G ∧ b ∈ G ∧ b ∈ a * H ⇒ a ∈ b * H
</pre>

<DT><span class="strong">subgroup_coset_trans</span>
<DD>
<pre>
⊢ ∀g h.
    h ≤ g ⇒ ∀a b c. a ∈ G ∧ b ∈ G ∧ c ∈ G ∧ b ∈ a * H ∧ c ∈ b * H ⇒ c ∈ a * H
</pre>

<DT><span class="strong">subgroup_cross_assoc</span>
<DD>
<pre>
⊢ ∀g h1 h2 h3. h1 ≤ g ∧ h2 ≤ g ∧ h3 ≤ g ⇒ (h1 ∘ h2) ∘ h3 = h1 ∘ h2 ∘ h3
</pre>

<DT><span class="strong">subgroup_cross_card</span>
<DD>
<pre>
⊢ ∀g h1 h2.
    h1 ≤ g ∧ h2 ≤ g ∧ FINITE G ⇒
    (let
       s1 = h1.carrier;
       s2 = h2.carrier
     in
       CARD (h1 ∘ h2).carrier = CARD s1 * CARD s2 DIV CARD (s1 ∩ s2))
</pre>

<DT><span class="strong">subgroup_cross_card_eqn</span>
<DD>
<pre>
⊢ ∀g h1 h2.
    h1 ≤ g ∧ h2 ≤ g ∧ FINITE G ⇒
    (let
       s1 = h1.carrier;
       s2 = h2.carrier
     in
       CARD (h1 ∘ h2).carrier * CARD (s1 ∩ s2) = CARD s1 * CARD s2)
</pre>

<DT><span class="strong">subgroup_cross_closure_comm_assoc_fun</span>
<DD>
<pre>
⊢ ∀g. AbelianGroup g ⇒ closure_comm_assoc_fun $o (all_subgroups g)
</pre>

<DT><span class="strong">subgroup_cross_comm</span>
<DD>
<pre>
⊢ ∀g. AbelianGroup g ⇒ ∀h1 h2. h1 ≤ g ∧ h2 ≤ g ⇒ h1 ∘ h2 = h2 ∘ h1
</pre>

<DT><span class="strong">subgroup_cross_finite</span>
<DD>
<pre>
⊢ ∀g h1 h2.
    h1 ≤ g ∧ h2 ≤ g ∧ h1 ∘ h2 = h2 ∘ h1 ∧ FiniteGroup h1 ∧ FiniteGroup h2 ⇒
    FiniteGroup (h1 ∘ h2)
</pre>

<DT><span class="strong">subgroup_cross_group</span>
<DD>
<pre>
⊢ ∀g h1 h2. h1 ≤ g ∧ h2 ≤ g ∧ h1 ∘ h2 = h2 ∘ h1 ⇒ Group (h1 ∘ h2)
</pre>

<DT><span class="strong">subgroup_cross_property</span>
<DD>
<pre>
⊢ ∀g h1 h2.
    (h1 ∘ h2).carrier = h1.carrier ∘ h2.carrier ∧ (h1 ∘ h2).op = $* ∧
    (h1 ∘ h2).id = #e
</pre>

<DT><span class="strong">subgroup_cross_self</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ h ∘ h = h
</pre>

<DT><span class="strong">subgroup_cross_subgroup</span>
<DD>
<pre>
⊢ ∀g h1 h2. h1 ≤ g ∧ h2 ≤ g ∧ h1 ∘ h2 = h2 ∘ h1 ⇒ h1 ∘ h2 ≤ g
</pre>

<DT><span class="strong">subgroup_element</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ ∀z. z ∈ H ⇒ z ∈ G
</pre>

<DT><span class="strong">subgroup_eq</span>
<DD>
<pre>
⊢ ∀g h1 h2. h1 ≤ g ∧ h2 ≤ g ⇒ (h1 = h2 ⇔ h1.carrier = h2.carrier)
</pre>

<DT><span class="strong">subgroup_eq_carrier</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ∧ H = G ⇒ h = g
</pre>

<DT><span class="strong">subgroup_eqn</span>
<DD>
<pre>
⊢ ∀g h. subgroup h g ⇔ H ⊆ G ∧ ∀x y. x ∈ H ∧ y ∈ H ⇒ h.op x y = x * y
</pre>

<DT><span class="strong">subgroup_exp</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ ∀x. x ∈ H ⇒ ∀n. h.exp x n = x ** n
</pre>

<DT><span class="strong">subgroup_groups</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ Group h ∧ Group g
</pre>

<DT><span class="strong">subgroup_has_groups</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ Group g ∧ Group h
</pre>

<DT><span class="strong">subgroup_homo_homo</span>
<DD>
<pre>
⊢ ∀g h k f. subgroup h g ∧ GroupHomo f g k ⇒ GroupHomo f h k
</pre>

<DT><span class="strong">subgroup_homomorphism</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ Group h ∧ Group g ∧ subgroup h g
</pre>

<DT><span class="strong">subgroup_id</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ h.id = #e
</pre>

<DT><span class="strong">subgroup_incoset_equiv</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ left_coset g H equiv_on G
</pre>

<DT><span class="strong">subgroup_intersect_group</span>
<DD>
<pre>
⊢ ∀g h k. h ≤ g ∧ k ≤ g ⇒ Group (h mINTER k)
</pre>

<DT><span class="strong">subgroup_intersect_has_inv</span>
<DD>
<pre>
⊢ ∀g h k. h ≤ g ∧ k ≤ g ⇒ ∀x. x ∈ H ∩ k.carrier ⇒ |/ x ∈ H ∩ k.carrier
</pre>

<DT><span class="strong">subgroup_intersect_inv</span>
<DD>
<pre>
⊢ ∀g h k. h ≤ g ∧ k ≤ g ⇒ ∀x. x ∈ H ∩ k.carrier ⇒ (h mINTER k).inv x = |/ x
</pre>

<DT><span class="strong">subgroup_intersect_property</span>
<DD>
<pre>
⊢ ∀g h k.
    h ≤ g ∧ k ≤ g ⇒
    (h mINTER k).carrier = H ∩ k.carrier ∧
    (∀x y. x ∈ H ∩ k.carrier ∧ y ∈ H ∩ k.carrier ⇒ (h mINTER k).op x y = x * y) ∧
    (h mINTER k).id = #e ∧ ∀x. x ∈ H ∩ k.carrier ⇒ (h mINTER k).inv x = |/ x
</pre>

<DT><span class="strong">subgroup_intersect_subgroup</span>
<DD>
<pre>
⊢ ∀g h k. h ≤ g ∧ k ≤ g ⇒ (h mINTER k) ≤ g
</pre>

<DT><span class="strong">subgroup_inv</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ ∀x. x ∈ H ⇒ h.inv x = |/ x
</pre>

<DT><span class="strong">subgroup_inv_closure</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ ∀x y. x ∈ H ∧ y ∈ H ⇒ x * |/ y ∈ H
</pre>

<DT><span class="strong">subgroup_is_group</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ Group h
</pre>

<DT><span class="strong">subgroup_is_submonoid</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ h << g
</pre>

<DT><span class="strong">subgroup_is_submonoid0</span>
<DD>
<pre>
⊢ ∀g h. Group g ∧ Group h ∧ subgroup h g ⇒ submonoid h g
</pre>

<DT><span class="strong">subgroup_op</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ h.op = $*
</pre>

<DT><span class="strong">subgroup_order</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ ∀x. x ∈ H ⇒ order h x = ord x
</pre>

<DT><span class="strong">subgroup_order_eqn</span>
<DD>
<pre>
⊢ ∀g h. Group g ∧ Group h ∧ subgroup h g ⇒ ∀x. x ∈ H ⇒ order h x = ord x
</pre>

<DT><span class="strong">subgroup_property</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ Group h ∧ Group g ∧ ∀x y. x ∈ H ∧ y ∈ H ⇒ h.op x y = x * y
</pre>

<DT><span class="strong">subgroup_property_all</span>
<DD>
<pre>
⊢ ∀g h.
    h ≤ g ⇒
    Group g ∧ Group h ∧ H ≠ ∅ ∧ H ⊆ G ∧ h.op = $* ∧ h.id = #e ∧
    (∀x. x ∈ H ⇒ h.inv x = |/ x) ∧ ∀x y. x ∈ H ∧ y ∈ H ⇒ x * |/ y ∈ H
</pre>

<DT><span class="strong">subgroup_refl</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ g ≤ g
</pre>

<DT><span class="strong">subgroup_reflexive</span>
<DD>
<pre>
⊢ ∀g. subgroup g g
</pre>

<DT><span class="strong">subgroup_subset</span>
<DD>
<pre>
⊢ ∀g h. subgroup h g ⇒ H ⊆ G
</pre>

<DT><span class="strong">subgroup_test_by_cross</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀h. h ≤ g ⇔ H ≠ ∅ ∧ H ⊆ G ∧ h ∘ h = h ∧ IMAGE |/ H = H
</pre>

<DT><span class="strong">subgroup_thm</span>
<DD>
<pre>
⊢ ∀g h.
    h ≤ g ⇔
    Group g ∧ h.op = $* ∧ h.id = #e ∧ H ≠ ∅ ∧ H ⊆ G ∧
    ∀x y. x ∈ H ∧ y ∈ H ⇒ x * |/ y ∈ H
</pre>

<DT><span class="strong">subgroup_to_coset_bij</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ ∀a. a ∈ G ⇒ BIJ (λx. a * x) H (a * H)
</pre>

<DT><span class="strong">subgroup_trans</span>
<DD>
<pre>
⊢ ∀g h t. h ≤ t ∧ t ≤ g ⇒ h ≤ g
</pre>

<DT><span class="strong">subgroup_transitive</span>
<DD>
<pre>
⊢ ∀g h k. subgroup g h ∧ subgroup h k ⇒ subgroup g k
</pre>

<DT><span class="strong">subset_big_cross_empty</span>
<DD>
<pre>
⊢ ∀g. ssbcross ∅ = {#e}
</pre>

<DT><span class="strong">subset_big_cross_insert</span>
<DD>
<pre>
⊢ ∀g. FiniteAbelianGroup g ⇒
      ∀B. B ⊆ POW G ⇒
          ∀s. s ⊆ G ∧ s ∉ B ⇒ ssbcross (s INSERT B) = s ∘ ssbcross B
</pre>

<DT><span class="strong">subset_big_cross_thm</span>
<DD>
<pre>
⊢ ∀g. FiniteAbelianGroup g ⇒
      ∀B. B ⊆ POW G ⇒
          ∀s. s ⊆ G ⇒ ssbcross (s INSERT B) = s ∘ ssbcross (B DELETE s)
</pre>

<DT><span class="strong">subset_cross_alt</span>
<DD>
<pre>
⊢ ∀g s1 s2. s1 ∘ s2 = IMAGE (λ(x,y). x * y) (s1 × s2)
</pre>

<DT><span class="strong">subset_cross_assoc</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒
      ∀s1 s2 s3. s1 ⊆ G ∧ s2 ⊆ G ∧ s3 ⊆ G ⇒ (s1 ∘ s2) ∘ s3 = s1 ∘ s2 ∘ s3
</pre>

<DT><span class="strong">subset_cross_closure_comm_assoc_fun</span>
<DD>
<pre>
⊢ ∀g. AbelianGroup g ⇒ closure_comm_assoc_fun $o (POW G)
</pre>

<DT><span class="strong">subset_cross_comm</span>
<DD>
<pre>
⊢ ∀g. AbelianGroup g ⇒ ∀s1 s2. s1 ⊆ G ∧ s2 ⊆ G ⇒ s1 ∘ s2 = s2 ∘ s1
</pre>

<DT><span class="strong">subset_cross_element</span>
<DD>
<pre>
⊢ ∀g s1 s2 x y. x ∈ s1 ∧ y ∈ s2 ⇒ x * y ∈ s1 ∘ s2
</pre>

<DT><span class="strong">subset_cross_element_iff</span>
<DD>
<pre>
⊢ ∀g s1 s2 z. z ∈ s1 ∘ s2 ⇔ ∃x y. x ∈ s1 ∧ y ∈ s2 ∧ z = x * y
</pre>

<DT><span class="strong">subset_cross_element_preimage_card</span>
<DD>
<pre>
⊢ ∀g h1 h2.
    h1 ≤ g ∧ h2 ≤ g ∧ FINITE G ⇒
    (let
       s1 = h1.carrier;
       s2 = h2.carrier;
       f (x,y) = x * y
     in
       ∀z. z ∈ s1 ∘ s2 ⇒ CARD (preimage f (s1 × s2) z) = CARD (s1 ∩ s2))
</pre>

<DT><span class="strong">subset_cross_finite</span>
<DD>
<pre>
⊢ ∀g s1 s2. FINITE s1 ∧ FINITE s2 ⇒ FINITE (s1 ∘ s2)
</pre>

<DT><span class="strong">subset_cross_inv</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒
      ∀s1 s2. s1 ⊆ G ∧ s2 ⊆ G ⇒ IMAGE |/ (s1 ∘ s2) = IMAGE |/ s2 ∘ IMAGE |/ s1
</pre>

<DT><span class="strong">subset_cross_partition_property</span>
<DD>
<pre>
⊢ ∀g h1 h2.
    h1 ≤ g ∧ h2 ≤ g ∧ FINITE G ⇒
    (let
       s1 = h1.carrier;
       s2 = h2.carrier;
       f (x,y) = x * y
     in
       ∀t. t ∈ partition (feq f) (s1 × s2) ⇒ CARD t = CARD (s1 ∩ s2))
</pre>

<DT><span class="strong">subset_cross_preimage_inj</span>
<DD>
<pre>
⊢ ∀g s1 s2.
    INJ (preimage (λ(x,y). x * y) (s1 × s2)) (s1 ∘ s2) 𝕌(:α # α -> bool)
</pre>

<DT><span class="strong">subset_cross_self</span>
<DD>
<pre>
⊢ ∀g h. h ≤ g ⇒ H ∘ H = H
</pre>

<DT><span class="strong">subset_cross_subset</span>
<DD>
<pre>
⊢ ∀g. Group g ⇒ ∀s1 s2. s1 ⊆ G ∧ s2 ⊆ G ⇒ s1 ∘ s2 ⊆ G
</pre>

<DT><span class="strong">subset_cross_to_preimage_cross_bij</span>
<DD>
<pre>
⊢ ∀g h1 h2.
    h1 ≤ g ∧ h2 ≤ g ⇒
    (let
       s1 = h1.carrier;
       s2 = h2.carrier;
       f (x,y) = x * y
     in
       ∀z. z ∈ s1 ∘ s2 ⇒
           BIJ (λd. (left z * d,|/ d * right z)) (s1 ∩ s2)
             (preimage f (s1 × s2) z))
</pre>

<DT><span class="strong">subset_group_exp</span>
<DD>
<pre>
⊢ ∀g s x. x ∈ s ⇒ ∀n. (subset_group g s).exp x n = x ** n
</pre>

<DT><span class="strong">subset_group_order</span>
<DD>
<pre>
⊢ ∀g s x. x ∈ s ⇒ order (subset_group g s) x = ord x
</pre>

<DT><span class="strong">subset_group_property</span>
<DD>
<pre>
⊢ ∀g s.
    (subset_group g s).carrier = s ∧ (subset_group g s).op = $* ∧
    (subset_group g s).id = #e
</pre>

<DT><span class="strong">subset_group_subgroup</span>
<DD>
<pre>
⊢ ∀g s.
    Group g ∧ s ≠ ∅ ∧ s ⊆ G ∧ (∀x y. x ∈ s ∧ y ∈ s ⇒ x * |/ y ∈ s) ⇒
    subset_group g s ≤ g
</pre>

<DT><span class="strong">subset_group_submonoid</span>
<DD>
<pre>
⊢ ∀g s.
    Monoid g ∧ #e ∈ s ∧ s ⊆ G ∧ (∀x y. x ∈ s ∧ y ∈ s ⇒ x * y ∈ s) ⇒
    subset_group g s << g
</pre>

<DT><span class="strong">subset_preimage_image</span>
<DD>
<pre>
⊢ ∀f g1 g2 h.
    Group g1 ∧ Group g2 ∧ h ≤ g1 ∧ GroupHomo f g1 g2 ⇒
    H ⊆ PREIMAGE f (IMAGE f H) ∩ g1.carrier
</pre>

<DT><span class="strong">sum_image_as_op_image</span>
<DD>
<pre>
⊢ ∑ = OP_IMAGE (λx y. x + y) 0
</pre>

<DT><span class="strong">symdiff_set_abelian_group</span>
<DD>
<pre>
⊢ AbelianGroup symdiff_set
</pre>

<DT><span class="strong">symdiff_set_group</span>
<DD>
<pre>
⊢ Group symdiff_set
</pre>

<DT><span class="strong">target_card_and_fixed_points_congruence</span>
<DD>
<pre>
⊢ ∀f g X n.
    Group g ∧ (g act X) f ∧ FINITE X ∧ 0 < n ∧
    (∀e. e ∈ multi_orbits f g X ⇒ CARD e = n) ⇒
    CARD X MOD n = CARD (fixed_points f g X) MOD n
</pre>

<DT><span class="strong">target_card_by_fixed_points</span>
<DD>
<pre>
⊢ ∀f g X.
    Group g ∧ (g act X) f ∧ FINITE X ⇒
    CARD X = CARD (fixed_points f g X) + ∑ CARD (multi_orbits f g X)
</pre>

<DT><span class="strong">target_card_by_orbit_types</span>
<DD>
<pre>
⊢ ∀f g X.
    Group g ∧ (g act X) f ∧ FINITE X ⇒
    CARD X = CARD (sing_orbits f g X) + ∑ CARD (multi_orbits f g X)
</pre>

<DT><span class="strong">target_card_by_partition</span>
<DD>
<pre>
⊢ ∀f g X. Group g ∧ (g act X) f ∧ FINITE X ⇒ CARD X = ∑ CARD (orbits f g X)
</pre>

<DT><span class="strong">target_orbits_disjoint</span>
<DD>
<pre>
⊢ ∀f g X. DISJOINT (sing_orbits f g X) (multi_orbits f g X)
</pre>

<DT><span class="strong">target_orbits_union</span>
<DD>
<pre>
⊢ ∀f g X. orbits f g X = sing_orbits f g X ∪ multi_orbits f g X
</pre>

<DT><span class="strong">trivial_group</span>
<DD>
<pre>
⊢ ∀e. FiniteAbelianGroup (trivial_group e)
</pre>

<DT><span class="strong">trivial_group_carrier</span>
<DD>
<pre>
⊢ ∀e. (trivial_group e).carrier = {e}
</pre>

<DT><span class="strong">trivial_group_id</span>
<DD>
<pre>
⊢ ∀e. (trivial_group e).id = e
</pre>

</DL>



<hr>
</body>
</html>
