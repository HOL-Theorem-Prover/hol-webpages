<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: hreal</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "hreal"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "hratTheory.html"><span class="strong">hrat</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Type <th> Arity<tr><td> <span class="strong">hreal</span> <td> 0
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">cut</span>
    <td>
    :hreal -> hrat -> bool
    <tr><td>
    <span class="strong">cut_of_hrat</span>
    <td>
    :hrat -> hrat -> bool
    <tr><td> <span class="strong">hrat_lt</span> <td> :hrat -> hrat -> bool
    <tr><td> <span class="strong">hreal</span> <td> :(hrat -> bool) -> hreal
    <tr><td> <span class="strong">hreal_1</span> <td> :hreal
    <tr><td>
    <span class="strong">hreal_add</span>
    <td>
    :hreal -> hreal -> hreal
    <tr><td> <span class="strong">hreal_inv</span> <td> :hreal -> hreal
    <tr><td> <span class="strong">hreal_lt</span> <td> :hreal -> hreal -> bool
    <tr><td>
    <span class="strong">hreal_mul</span>
    <td>
    :hreal -> hreal -> hreal
    <tr><td>
    <span class="strong">hreal_of_treal</span>
    <td>
    :hreal # hreal -> hreal
    <tr><td>
    <span class="strong">hreal_sub</span>
    <td>
    :hreal -> hreal -> hreal
    <tr><td>
    <span class="strong">hreal_sup</span>
    <td>
    :(hreal -> bool) -> hreal
    <tr><td> <span class="strong">isacut</span> <td> :(hrat -> bool) -> bool
    <tr><td> <span class="strong">treal_0</span> <td> :hreal # hreal
    <tr><td> <span class="strong">treal_1</span> <td> :hreal # hreal
    <tr><td>
    <span class="strong">treal_add</span>
    <td>
    :hreal # hreal -> hreal # hreal -> hreal # hreal
    <tr><td>
    <span class="strong">treal_eq</span>
    <td>
    :hreal # hreal -> hreal # hreal -> bool
    <tr><td>
    <span class="strong">treal_inv</span>
    <td>
    :hreal # hreal -> hreal # hreal
    <tr><td>
    <span class="strong">treal_lt</span>
    <td>
    :hreal # hreal -> hreal # hreal -> bool
    <tr><td>
    <span class="strong">treal_mul</span>
    <td>
    :hreal # hreal -> hreal # hreal -> hreal # hreal
    <tr><td>
    <span class="strong">treal_neg</span>
    <td>
    :hreal # hreal -> hreal # hreal
    <tr><td>
    <span class="strong">treal_of_hreal</span>
    <td>
    :hreal -> hreal # hreal
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">cut_of_hrat</span>
<DD>
<pre>
⊢ ∀x. cut_of_hrat x = (λy. hrat_lt y x)
</pre>

<DT><span class="strong">hrat_lt</span>
<DD>
<pre>
⊢ ∀x y. hrat_lt x y ⇔ ∃d. y = x hrat_add d
</pre>

<DT><span class="strong">hreal_1</span>
<DD>
<pre>
⊢ hreal_1 = hreal (cut_of_hrat hrat_1)
</pre>

<DT><span class="strong">hreal_TY_DEF</span>
<DD>
<pre>
⊢ ∃rep. TYPE_DEFINITION isacut rep
</pre>

<DT><span class="strong">hreal_add</span>
<DD>
<pre>
⊢ ∀X Y. X hreal_add Y = hreal (λw. ∃x y. w = x hrat_add y ∧ cut X x ∧ cut Y y)
</pre>

<DT><span class="strong">hreal_inv</span>
<DD>
<pre>
⊢ ∀X. hreal_inv X =
      hreal
        (λw. ∃d. hrat_lt d hrat_1 ∧ ∀x. cut X x ⇒ hrat_lt (w hrat_mul x) d)
</pre>

<DT><span class="strong">hreal_lt</span>
<DD>
<pre>
⊢ ∀X Y. X hreal_lt Y ⇔ X ≠ Y ∧ ∀x. cut X x ⇒ cut Y x
</pre>

<DT><span class="strong">hreal_mul</span>
<DD>
<pre>
⊢ ∀X Y. X hreal_mul Y = hreal (λw. ∃x y. w = x hrat_mul y ∧ cut X x ∧ cut Y y)
</pre>

<DT><span class="strong">hreal_of_treal</span>
<DD>
<pre>
⊢ ∀x y. hreal_of_treal (x,y) = @d. x = y hreal_add d
</pre>

<DT><span class="strong">hreal_sub</span>
<DD>
<pre>
⊢ ∀Y X. Y hreal_sub X = hreal (λw. ∃x. ¬cut X x ∧ cut Y (x hrat_add w))
</pre>

<DT><span class="strong">hreal_sup</span>
<DD>
<pre>
⊢ ∀P. hreal_sup P = hreal (λw. ∃X. P X ∧ cut X w)
</pre>

<DT><span class="strong">hreal_tybij</span>
<DD>
<pre>
⊢ (∀a. hreal (cut a) = a) ∧ ∀r. isacut r ⇔ cut (hreal r) = r
</pre>

<DT><span class="strong">isacut</span>
<DD>
<pre>
⊢ ∀C. isacut C ⇔
      (∃x. C x) ∧ (∃x. ¬C x) ∧ (∀x y. C x ∧ hrat_lt y x ⇒ C y) ∧
      ∀x. C x ⇒ ∃y. C y ∧ hrat_lt x y
</pre>

<DT><span class="strong">treal_0</span>
<DD>
<pre>
⊢ treal_0 = (hreal_1,hreal_1)
</pre>

<DT><span class="strong">treal_1</span>
<DD>
<pre>
⊢ treal_1 = (hreal_1 hreal_add hreal_1,hreal_1)
</pre>

<DT><span class="strong">treal_add</span>
<DD>
<pre>
⊢ ∀x1 y1 x2 y2. (x1,y1) treal_add (x2,y2) = (x1 hreal_add x2,y1 hreal_add y2)
</pre>

<DT><span class="strong">treal_eq</span>
<DD>
<pre>
⊢ ∀x1 y1 x2 y2. treal_eq (x1,y1) (x2,y2) ⇔ x1 hreal_add y2 = x2 hreal_add y1
</pre>

<DT><span class="strong">treal_inv</span>
<DD>
<pre>
⊢ ∀x y.
    treal_inv (x,y) =
    if x = y then treal_0
    else if y hreal_lt x then
      (hreal_inv (x hreal_sub y) hreal_add hreal_1,hreal_1)
    else (hreal_1,hreal_inv (y hreal_sub x) hreal_add hreal_1)
</pre>

<DT><span class="strong">treal_lt</span>
<DD>
<pre>
⊢ ∀x1 y1 x2 y2.
    treal_lt (x1,y1) (x2,y2) ⇔ x1 hreal_add y2 hreal_lt x2 hreal_add y1
</pre>

<DT><span class="strong">treal_mul</span>
<DD>
<pre>
⊢ ∀x1 y1 x2 y2.
    (x1,y1) treal_mul (x2,y2) =
    (x1 hreal_mul x2 hreal_add y1 hreal_mul y2,
     x1 hreal_mul y2 hreal_add y1 hreal_mul x2)
</pre>

<DT><span class="strong">treal_neg</span>
<DD>
<pre>
⊢ ∀x y. treal_neg (x,y) = (y,x)
</pre>

<DT><span class="strong">treal_of_hreal</span>
<DD>
<pre>
⊢ ∀x. treal_of_hreal x = (x hreal_add hreal_1,hreal_1)
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">CUT_BOUNDED</span>
<DD>
<pre>
⊢ ∀X. ∃x. ¬cut X x
</pre>

<DT><span class="strong">CUT_DOWN</span>
<DD>
<pre>
⊢ ∀X x y. cut X x ∧ hrat_lt y x ⇒ cut X y
</pre>

<DT><span class="strong">CUT_ISACUT</span>
<DD>
<pre>
⊢ ∀X. isacut (cut X)
</pre>

<DT><span class="strong">CUT_NEARTOP_ADD</span>
<DD>
<pre>
⊢ ∀X e. ∃x. cut X x ∧ ¬cut X (x hrat_add e)
</pre>

<DT><span class="strong">CUT_NEARTOP_MUL</span>
<DD>
<pre>
⊢ ∀X u. hrat_lt hrat_1 u ⇒ ∃x. cut X x ∧ ¬cut X (u hrat_mul x)
</pre>

<DT><span class="strong">CUT_NONEMPTY</span>
<DD>
<pre>
⊢ ∀X. ∃x. cut X x
</pre>

<DT><span class="strong">CUT_STRADDLE</span>
<DD>
<pre>
⊢ ∀X x y. cut X x ∧ ¬cut X y ⇒ hrat_lt x y
</pre>

<DT><span class="strong">CUT_UBOUND</span>
<DD>
<pre>
⊢ ∀X x y. ¬cut X x ∧ hrat_lt x y ⇒ ¬cut X y
</pre>

<DT><span class="strong">CUT_UP</span>
<DD>
<pre>
⊢ ∀X x. cut X x ⇒ ∃y. cut X y ∧ hrat_lt x y
</pre>

<DT><span class="strong">EQUAL_CUTS</span>
<DD>
<pre>
⊢ ∀X Y. cut X = cut Y ⇒ X = Y
</pre>

<DT><span class="strong">HRAT_DOWN</span>
<DD>
<pre>
⊢ ∀x. ∃y. hrat_lt y x
</pre>

<DT><span class="strong">HRAT_DOWN2</span>
<DD>
<pre>
⊢ ∀x y. ∃z. hrat_lt z x ∧ hrat_lt z y
</pre>

<DT><span class="strong">HRAT_EQ_LADD</span>
<DD>
<pre>
⊢ ∀x y z. x hrat_add y = x hrat_add z ⇔ y = z
</pre>

<DT><span class="strong">HRAT_EQ_LMUL</span>
<DD>
<pre>
⊢ ∀x y z. x hrat_mul y = x hrat_mul z ⇔ y = z
</pre>

<DT><span class="strong">HRAT_GT_L1</span>
<DD>
<pre>
⊢ ∀x y. hrat_lt hrat_1 (hrat_inv x hrat_mul y) ⇔ hrat_lt x y
</pre>

<DT><span class="strong">HRAT_GT_LMUL1</span>
<DD>
<pre>
⊢ ∀x y. hrat_lt y (x hrat_mul y) ⇔ hrat_lt hrat_1 x
</pre>

<DT><span class="strong">HRAT_INV_MUL</span>
<DD>
<pre>
⊢ ∀x y. hrat_inv (x hrat_mul y) = hrat_inv x hrat_mul hrat_inv y
</pre>

<DT><span class="strong">HRAT_LT_ADD2</span>
<DD>
<pre>
⊢ ∀u v x y. hrat_lt u x ∧ hrat_lt v y ⇒ hrat_lt (u hrat_add v) (x hrat_add y)
</pre>

<DT><span class="strong">HRAT_LT_ADDL</span>
<DD>
<pre>
⊢ ∀x y. hrat_lt x (x hrat_add y)
</pre>

<DT><span class="strong">HRAT_LT_ADDR</span>
<DD>
<pre>
⊢ ∀x y. hrat_lt y (x hrat_add y)
</pre>

<DT><span class="strong">HRAT_LT_ANTISYM</span>
<DD>
<pre>
⊢ ∀x y. ¬(hrat_lt x y ∧ hrat_lt y x)
</pre>

<DT><span class="strong">HRAT_LT_GT</span>
<DD>
<pre>
⊢ ∀x y. hrat_lt x y ⇒ ¬hrat_lt y x
</pre>

<DT><span class="strong">HRAT_LT_L1</span>
<DD>
<pre>
⊢ ∀x y. hrat_lt (hrat_inv x hrat_mul y) hrat_1 ⇔ hrat_lt y x
</pre>

<DT><span class="strong">HRAT_LT_LADD</span>
<DD>
<pre>
⊢ ∀x y z. hrat_lt (z hrat_add x) (z hrat_add y) ⇔ hrat_lt x y
</pre>

<DT><span class="strong">HRAT_LT_LMUL</span>
<DD>
<pre>
⊢ ∀x y z. hrat_lt (z hrat_mul x) (z hrat_mul y) ⇔ hrat_lt x y
</pre>

<DT><span class="strong">HRAT_LT_LMUL1</span>
<DD>
<pre>
⊢ ∀x y. hrat_lt (x hrat_mul y) y ⇔ hrat_lt x hrat_1
</pre>

<DT><span class="strong">HRAT_LT_MUL2</span>
<DD>
<pre>
⊢ ∀u v x y. hrat_lt u x ∧ hrat_lt v y ⇒ hrat_lt (u hrat_mul v) (x hrat_mul y)
</pre>

<DT><span class="strong">HRAT_LT_NE</span>
<DD>
<pre>
⊢ ∀x y. hrat_lt x y ⇒ x ≠ y
</pre>

<DT><span class="strong">HRAT_LT_R1</span>
<DD>
<pre>
⊢ ∀x y. hrat_lt (x hrat_mul hrat_inv y) hrat_1 ⇔ hrat_lt x y
</pre>

<DT><span class="strong">HRAT_LT_RADD</span>
<DD>
<pre>
⊢ ∀x y z. hrat_lt (x hrat_add z) (y hrat_add z) ⇔ hrat_lt x y
</pre>

<DT><span class="strong">HRAT_LT_REFL</span>
<DD>
<pre>
⊢ ∀x. ¬hrat_lt x x
</pre>

<DT><span class="strong">HRAT_LT_RMUL</span>
<DD>
<pre>
⊢ ∀x y z. hrat_lt (x hrat_mul z) (y hrat_mul z) ⇔ hrat_lt x y
</pre>

<DT><span class="strong">HRAT_LT_RMUL1</span>
<DD>
<pre>
⊢ ∀x y. hrat_lt (x hrat_mul y) x ⇔ hrat_lt y hrat_1
</pre>

<DT><span class="strong">HRAT_LT_TOTAL</span>
<DD>
<pre>
⊢ ∀x y. x = y ∨ hrat_lt x y ∨ hrat_lt y x
</pre>

<DT><span class="strong">HRAT_LT_TRANS</span>
<DD>
<pre>
⊢ ∀x y z. hrat_lt x y ∧ hrat_lt y z ⇒ hrat_lt x z
</pre>

<DT><span class="strong">HRAT_MEAN</span>
<DD>
<pre>
⊢ ∀x y. hrat_lt x y ⇒ ∃z. hrat_lt x z ∧ hrat_lt z y
</pre>

<DT><span class="strong">HRAT_MUL_RID</span>
<DD>
<pre>
⊢ ∀x. x hrat_mul hrat_1 = x
</pre>

<DT><span class="strong">HRAT_MUL_RINV</span>
<DD>
<pre>
⊢ ∀x. x hrat_mul hrat_inv x = hrat_1
</pre>

<DT><span class="strong">HRAT_RDISTRIB</span>
<DD>
<pre>
⊢ ∀x y z. (x hrat_add y) hrat_mul z = x hrat_mul z hrat_add y hrat_mul z
</pre>

<DT><span class="strong">HRAT_UP</span>
<DD>
<pre>
⊢ ∀x. ∃y. hrat_lt x y
</pre>

<DT><span class="strong">HREAL_ADD_ASSOC</span>
<DD>
<pre>
⊢ ∀X Y Z. X hreal_add (Y hreal_add Z) = X hreal_add Y hreal_add Z
</pre>

<DT><span class="strong">HREAL_ADD_ISACUT</span>
<DD>
<pre>
⊢ ∀X Y. isacut (λw. ∃x y. w = x hrat_add y ∧ cut X x ∧ cut Y y)
</pre>

<DT><span class="strong">HREAL_ADD_SYM</span>
<DD>
<pre>
⊢ ∀X Y. X hreal_add Y = Y hreal_add X
</pre>

<DT><span class="strong">HREAL_ADD_TOTAL</span>
<DD>
<pre>
⊢ ∀X Y. X = Y ∨ (∃D. Y = X hreal_add D) ∨ ∃D. X = Y hreal_add D
</pre>

<DT><span class="strong">HREAL_EQ_ADDL</span>
<DD>
<pre>
⊢ ∀x y. x ≠ x hreal_add y
</pre>

<DT><span class="strong">HREAL_EQ_ADDR</span>
<DD>
<pre>
⊢ ∀x y. x hreal_add y ≠ x
</pre>

<DT><span class="strong">HREAL_EQ_LADD</span>
<DD>
<pre>
⊢ ∀x y z. x hreal_add y = x hreal_add z ⇔ y = z
</pre>

<DT><span class="strong">HREAL_INV_ISACUT</span>
<DD>
<pre>
⊢ ∀X. isacut
        (λw. ∃d. hrat_lt d hrat_1 ∧ ∀x. cut X x ⇒ hrat_lt (w hrat_mul x) d)
</pre>

<DT><span class="strong">HREAL_LDISTRIB</span>
<DD>
<pre>
⊢ ∀X Y Z. X hreal_mul (Y hreal_add Z) = X hreal_mul Y hreal_add X hreal_mul Z
</pre>

<DT><span class="strong">HREAL_LT</span>
<DD>
<pre>
⊢ ∀X Y. X hreal_lt Y ⇔ ∃D. Y = X hreal_add D
</pre>

<DT><span class="strong">HREAL_LT_ADD2</span>
<DD>
<pre>
⊢ ∀x1 x2 y1 y2.
    x1 hreal_lt y1 ∧ x2 hreal_lt y2 ⇒ x1 hreal_add x2 hreal_lt y1 hreal_add y2
</pre>

<DT><span class="strong">HREAL_LT_ADDL</span>
<DD>
<pre>
⊢ ∀x y. x hreal_lt x hreal_add y
</pre>

<DT><span class="strong">HREAL_LT_ADDR</span>
<DD>
<pre>
⊢ ∀x y. ¬(x hreal_add y hreal_lt x)
</pre>

<DT><span class="strong">HREAL_LT_GT</span>
<DD>
<pre>
⊢ ∀x y. x hreal_lt y ⇒ ¬(y hreal_lt x)
</pre>

<DT><span class="strong">HREAL_LT_LADD</span>
<DD>
<pre>
⊢ ∀x y z. x hreal_add y hreal_lt x hreal_add z ⇔ y hreal_lt z
</pre>

<DT><span class="strong">HREAL_LT_LEMMA</span>
<DD>
<pre>
⊢ ∀X Y. X hreal_lt Y ⇒ ∃x. ¬cut X x ∧ cut Y x
</pre>

<DT><span class="strong">HREAL_LT_NE</span>
<DD>
<pre>
⊢ ∀x y. x hreal_lt y ⇒ x ≠ y
</pre>

<DT><span class="strong">HREAL_LT_REFL</span>
<DD>
<pre>
⊢ ∀x. ¬(x hreal_lt x)
</pre>

<DT><span class="strong">HREAL_LT_TOTAL</span>
<DD>
<pre>
⊢ ∀X Y. X = Y ∨ X hreal_lt Y ∨ Y hreal_lt X
</pre>

<DT><span class="strong">HREAL_MUL_ASSOC</span>
<DD>
<pre>
⊢ ∀X Y Z. X hreal_mul (Y hreal_mul Z) = X hreal_mul Y hreal_mul Z
</pre>

<DT><span class="strong">HREAL_MUL_ISACUT</span>
<DD>
<pre>
⊢ ∀X Y. isacut (λw. ∃x y. w = x hrat_mul y ∧ cut X x ∧ cut Y y)
</pre>

<DT><span class="strong">HREAL_MUL_LID</span>
<DD>
<pre>
⊢ ∀X. hreal_1 hreal_mul X = X
</pre>

<DT><span class="strong">HREAL_MUL_LINV</span>
<DD>
<pre>
⊢ ∀X. hreal_inv X hreal_mul X = hreal_1
</pre>

<DT><span class="strong">HREAL_MUL_SYM</span>
<DD>
<pre>
⊢ ∀X Y. X hreal_mul Y = Y hreal_mul X
</pre>

<DT><span class="strong">HREAL_NOZERO</span>
<DD>
<pre>
⊢ ∀X Y. X hreal_add Y ≠ X
</pre>

<DT><span class="strong">HREAL_RDISTRIB</span>
<DD>
<pre>
⊢ ∀x y z. (x hreal_add y) hreal_mul z = x hreal_mul z hreal_add y hreal_mul z
</pre>

<DT><span class="strong">HREAL_SUB_ADD</span>
<DD>
<pre>
⊢ ∀X Y. X hreal_lt Y ⇒ Y hreal_sub X hreal_add X = Y
</pre>

<DT><span class="strong">HREAL_SUB_ISACUT</span>
<DD>
<pre>
⊢ ∀X Y. X hreal_lt Y ⇒ isacut (λw. ∃x. ¬cut X x ∧ cut Y (x hrat_add w))
</pre>

<DT><span class="strong">HREAL_SUP</span>
<DD>
<pre>
⊢ ∀P. (∃X. P X) ∧ (∃Y. ∀X. P X ⇒ X hreal_lt Y) ⇒
      ∀Y. (∃X. P X ∧ Y hreal_lt X) ⇔ Y hreal_lt hreal_sup P
</pre>

<DT><span class="strong">HREAL_SUP_ISACUT</span>
<DD>
<pre>
⊢ ∀P. (∃X. P X) ∧ (∃Y. ∀X. P X ⇒ X hreal_lt Y) ⇒
      isacut (λw. ∃X. P X ∧ cut X w)
</pre>

<DT><span class="strong">ISACUT_HRAT</span>
<DD>
<pre>
⊢ ∀h. isacut (cut_of_hrat h)
</pre>

<DT><span class="strong">TREAL_10</span>
<DD>
<pre>
⊢ ¬treal_eq treal_1 treal_0
</pre>

<DT><span class="strong">TREAL_ADD_ASSOC</span>
<DD>
<pre>
⊢ ∀x y z. x treal_add (y treal_add z) = x treal_add y treal_add z
</pre>

<DT><span class="strong">TREAL_ADD_LID</span>
<DD>
<pre>
⊢ ∀x. treal_eq (treal_0 treal_add x) x
</pre>

<DT><span class="strong">TREAL_ADD_LINV</span>
<DD>
<pre>
⊢ ∀x. treal_eq (treal_neg x treal_add x) treal_0
</pre>

<DT><span class="strong">TREAL_ADD_SYM</span>
<DD>
<pre>
⊢ ∀x y. x treal_add y = y treal_add x
</pre>

<DT><span class="strong">TREAL_ADD_WELLDEF</span>
<DD>
<pre>
⊢ ∀x1 x2 y1 y2.
    treal_eq x1 x2 ∧ treal_eq y1 y2 ⇒
    treal_eq (x1 treal_add y1) (x2 treal_add y2)
</pre>

<DT><span class="strong">TREAL_ADD_WELLDEFR</span>
<DD>
<pre>
⊢ ∀x1 x2 y. treal_eq x1 x2 ⇒ treal_eq (x1 treal_add y) (x2 treal_add y)
</pre>

<DT><span class="strong">TREAL_BIJ</span>
<DD>
<pre>
⊢ (∀h. hreal_of_treal (treal_of_hreal h) = h) ∧
  ∀r. treal_lt treal_0 r ⇔ treal_eq (treal_of_hreal (hreal_of_treal r)) r
</pre>

<DT><span class="strong">TREAL_BIJ_WELLDEF</span>
<DD>
<pre>
⊢ ∀h i. treal_eq h i ⇒ hreal_of_treal h = hreal_of_treal i
</pre>

<DT><span class="strong">TREAL_EQ_AP</span>
<DD>
<pre>
⊢ ∀p q. p = q ⇒ treal_eq p q
</pre>

<DT><span class="strong">TREAL_EQ_EQUIV</span>
<DD>
<pre>
⊢ ∀p q. treal_eq p q ⇔ treal_eq p = treal_eq q
</pre>

<DT><span class="strong">TREAL_EQ_REFL</span>
<DD>
<pre>
⊢ ∀x. treal_eq x x
</pre>

<DT><span class="strong">TREAL_EQ_SYM</span>
<DD>
<pre>
⊢ ∀x y. treal_eq x y ⇔ treal_eq y x
</pre>

<DT><span class="strong">TREAL_EQ_TRANS</span>
<DD>
<pre>
⊢ ∀x y z. treal_eq x y ∧ treal_eq y z ⇒ treal_eq x z
</pre>

<DT><span class="strong">TREAL_INV_0</span>
<DD>
<pre>
⊢ treal_eq (treal_inv treal_0) treal_0
</pre>

<DT><span class="strong">TREAL_INV_WELLDEF</span>
<DD>
<pre>
⊢ ∀x1 x2. treal_eq x1 x2 ⇒ treal_eq (treal_inv x1) (treal_inv x2)
</pre>

<DT><span class="strong">TREAL_ISO</span>
<DD>
<pre>
⊢ ∀h i. h hreal_lt i ⇒ treal_lt (treal_of_hreal h) (treal_of_hreal i)
</pre>

<DT><span class="strong">TREAL_LDISTRIB</span>
<DD>
<pre>
⊢ ∀x y z. x treal_mul (y treal_add z) = x treal_mul y treal_add x treal_mul z
</pre>

<DT><span class="strong">TREAL_LT_ADD</span>
<DD>
<pre>
⊢ ∀x y z. treal_lt y z ⇒ treal_lt (x treal_add y) (x treal_add z)
</pre>

<DT><span class="strong">TREAL_LT_MUL</span>
<DD>
<pre>
⊢ ∀x y.
    treal_lt treal_0 x ∧ treal_lt treal_0 y ⇒ treal_lt treal_0 (x treal_mul y)
</pre>

<DT><span class="strong">TREAL_LT_REFL</span>
<DD>
<pre>
⊢ ∀x. ¬treal_lt x x
</pre>

<DT><span class="strong">TREAL_LT_TOTAL</span>
<DD>
<pre>
⊢ ∀x y. treal_eq x y ∨ treal_lt x y ∨ treal_lt y x
</pre>

<DT><span class="strong">TREAL_LT_TRANS</span>
<DD>
<pre>
⊢ ∀x y z. treal_lt x y ∧ treal_lt y z ⇒ treal_lt x z
</pre>

<DT><span class="strong">TREAL_LT_WELLDEF</span>
<DD>
<pre>
⊢ ∀x1 x2 y1 y2.
    treal_eq x1 x2 ∧ treal_eq y1 y2 ⇒ (treal_lt x1 y1 ⇔ treal_lt x2 y2)
</pre>

<DT><span class="strong">TREAL_LT_WELLDEFL</span>
<DD>
<pre>
⊢ ∀x y1 y2. treal_eq y1 y2 ⇒ (treal_lt x y1 ⇔ treal_lt x y2)
</pre>

<DT><span class="strong">TREAL_LT_WELLDEFR</span>
<DD>
<pre>
⊢ ∀x1 x2 y. treal_eq x1 x2 ⇒ (treal_lt x1 y ⇔ treal_lt x2 y)
</pre>

<DT><span class="strong">TREAL_MUL_ASSOC</span>
<DD>
<pre>
⊢ ∀x y z. x treal_mul (y treal_mul z) = x treal_mul y treal_mul z
</pre>

<DT><span class="strong">TREAL_MUL_LID</span>
<DD>
<pre>
⊢ ∀x. treal_eq (treal_1 treal_mul x) x
</pre>

<DT><span class="strong">TREAL_MUL_LINV</span>
<DD>
<pre>
⊢ ∀x. ¬treal_eq x treal_0 ⇒ treal_eq (treal_inv x treal_mul x) treal_1
</pre>

<DT><span class="strong">TREAL_MUL_SYM</span>
<DD>
<pre>
⊢ ∀x y. x treal_mul y = y treal_mul x
</pre>

<DT><span class="strong">TREAL_MUL_WELLDEF</span>
<DD>
<pre>
⊢ ∀x1 x2 y1 y2.
    treal_eq x1 x2 ∧ treal_eq y1 y2 ⇒
    treal_eq (x1 treal_mul y1) (x2 treal_mul y2)
</pre>

<DT><span class="strong">TREAL_MUL_WELLDEFR</span>
<DD>
<pre>
⊢ ∀x1 x2 y. treal_eq x1 x2 ⇒ treal_eq (x1 treal_mul y) (x2 treal_mul y)
</pre>

<DT><span class="strong">TREAL_NEG_WELLDEF</span>
<DD>
<pre>
⊢ ∀x1 x2. treal_eq x1 x2 ⇒ treal_eq (treal_neg x1) (treal_neg x2)
</pre>

</DL>



<hr>
</body>
</html>
