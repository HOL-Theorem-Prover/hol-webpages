<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: list</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "list"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "pred_setTheory.html"><span class="strong">pred_set</span></a>&nbsp;&nbsp;
    <a href = "ind_typeTheory.html"><span class="strong">ind_type</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Type <th> Arity<tr><td> <span class="strong">list</span> <td> 1
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">ALL_DISTINCT</span>
    <td>
    :Œ± list -> bool
    <tr><td>
    <span class="strong">APPEND</span>
    <td>
    :Œ± list -> Œ± list -> Œ± list
    <tr><td> <span class="strong">CONS</span> <td> :Œ± -> Œ± list -> Œ± list
    <tr><td> <span class="strong">DROP</span> <td> :num -> Œ± list -> Œ± list
    <tr><td> <span class="strong">EL</span> <td> :num -> Œ± list -> Œ±
    <tr><td>
    <span class="strong">EVERY</span>
    <td>
    :(Œ± -> bool) -> Œ± list -> bool
    <tr><td>
    <span class="strong">EVERYi</span>
    <td>
    :(num -> Œ± -> bool) -> Œ± list -> bool
    <tr><td>
    <span class="strong">EXISTS</span>
    <td>
    :(Œ± -> bool) -> Œ± list -> bool
    <tr><td>
    <span class="strong">FILTER</span>
    <td>
    :(Œ± -> bool) -> Œ± list -> Œ± list
    <tr><td>
    <span class="strong">FIND</span>
    <td>
    :(Œ± -> bool) -> Œ± list -> Œ± option
    <tr><td> <span class="strong">FLAT</span> <td> :Œ± list list -> Œ± list
    <tr><td>
    <span class="strong">FOLDL</span>
    <td>
    :(Œ≤ -> Œ± -> Œ≤) -> Œ≤ -> Œ± list -> Œ≤
    <tr><td>
    <span class="strong">FOLDL2</span>
    <td>
    :(Œ± -> Œ≤ -> Œ≥ -> Œ±) -> Œ± -> Œ≤ list -> Œ≥ list -> Œ±
    <tr><td>
    <span class="strong">FOLDR</span>
    <td>
    :(Œ± -> Œ≤ -> Œ≤) -> Œ≤ -> Œ± list -> Œ≤
    <tr><td> <span class="strong">FRONT</span> <td> :Œ± list -> Œ± list
    <tr><td>
    <span class="strong">GENLIST</span>
    <td>
    :(num -> Œ±) -> num -> Œ± list
    <tr><td>
    <span class="strong">GENLIST_AUX</span>
    <td>
    :(num -> Œ±) -> num -> Œ± list -> Œ± list
    <tr><td> <span class="strong">HD</span> <td> :Œ± list -> Œ±
    <tr><td>
    <span class="strong">INDEX_FIND</span>
    <td>
    :num -> (Œ± -> bool) -> Œ± list -> (num # Œ±) option
    <tr><td>
    <span class="strong">INDEX_OF</span>
    <td>
    :Œ± -> Œ± list -> num option
    <tr><td> <span class="strong">LAST</span> <td> :Œ± list -> Œ±
    <tr><td> <span class="strong">LEN</span> <td> :Œ± list -> num -> num
    <tr><td> <span class="strong">LENGTH</span> <td> :Œ± list -> num
    <tr><td>
    <span class="strong">LIST_APPLY</span>
    <td>
    :(Œ≤ -> Œ±) list -> Œ≤ list -> Œ± list
    <tr><td>
    <span class="strong">LIST_BIND</span>
    <td>
    :Œ≤ list -> (Œ≤ -> Œ± list) -> Œ± list
    <tr><td> <span class="strong">LIST_GUARD</span> <td> :bool -> unit list
    <tr><td>
    <span class="strong">LIST_IGNORE_BIND</span>
    <td>
    :Œ≤ list -> Œ± list -> Œ± list
    <tr><td>
    <span class="strong">LIST_LIFT2</span>
    <td>
    :(Œ≤ -> Œ≥ -> Œ±) -> Œ≤ list -> Œ≥ list -> Œ± list
    <tr><td>
    <span class="strong">LIST_REL</span>
    <td>
    :(Œ± -> Œ≤ -> bool) -> Œ± list -> Œ≤ list -> bool
    <tr><td> <span class="strong">LIST_TO_SET</span> <td> :Œ± list -> Œ± -> bool
    <tr><td>
    <span class="strong">LLEX</span>
    <td>
    :(Œ± -> Œ± -> bool) -> Œ± list -> Œ± list -> bool
    <tr><td>
    <span class="strong">LRC</span>
    <td>
    :(Œ± -> Œ± -> bool) -> Œ± list -> Œ± -> Œ± -> bool
    <tr><td>
    <span class="strong">LUPDATE</span>
    <td>
    :Œ± -> num -> Œ± list -> Œ± list
    <tr><td>
    <span class="strong">MAP</span>
    <td>
    :(Œ± -> Œ≤) -> Œ± list -> Œ≤ list
    <tr><td>
    <span class="strong">MAP2</span>
    <td>
    :(Œ≤ -> Œ≥ -> Œ±) -> Œ≤ list -> Œ≥ list -> Œ± list
    <tr><td> <span class="strong">NIL</span> <td> :Œ± list
    <tr><td> <span class="strong">NULL</span> <td> :Œ± list -> bool
    <tr><td>
    <span class="strong">OPT_MMAP</span>
    <td>
    :(Œ≤ -> Œ± option) -> Œ≤ list -> Œ± list option
    <tr><td>
    <span class="strong">PAD_LEFT</span>
    <td>
    :Œ± -> num -> Œ± list -> Œ± list
    <tr><td>
    <span class="strong">PAD_RIGHT</span>
    <td>
    :Œ± -> num -> Œ± list -> Œ± list
    <tr><td> <span class="strong">REV</span> <td> :Œ± list -> Œ± list -> Œ± list
    <tr><td> <span class="strong">REVERSE</span> <td> :Œ± list -> Œ± list
    <tr><td>
    <span class="strong">SET_REL</span>
    <td>
    :(Œ± -> Œ≤ -> bool) -> (Œ± -> bool) -> (Œ≤ -> bool) -> bool
    <tr><td>
    <span class="strong">SET_TO_LIST</span>
    <td>
    :(Œ± -> bool) -> Œ± list
    <tr><td>
    <span class="strong">SHORTLEX</span>
    <td>
    :(Œ± -> Œ± -> bool) -> Œ± list -> Œ± list -> bool
    <tr><td> <span class="strong">SNOC</span> <td> :Œ± -> Œ± list -> Œ± list
    <tr><td> <span class="strong">SUM</span> <td> :num list -> num
    <tr><td> <span class="strong">SUM_ACC</span> <td> :num list -> num -> num
    <tr><td> <span class="strong">TAKE</span> <td> :num -> Œ± list -> Œ± list
    <tr><td> <span class="strong">TL</span> <td> :Œ± list -> Œ± list
    <tr><td> <span class="strong">UNIQUE</span> <td> :Œ± -> Œ± list -> bool
    <tr><td>
    <span class="strong">UNZIP</span>
    <td>
    :(Œ± # Œ≤) list -> Œ± list # Œ≤ list
    <tr><td>
    <span class="strong">ZIP</span>
    <td>
    :Œ± list # Œ≤ list -> (Œ± # Œ≤) list
    <tr><td>
    <span class="strong">adjacent</span>
    <td>
    :Œ± list -> Œ± -> Œ± -> bool
    <tr><td>
    <span class="strong">dropWhile</span>
    <td>
    :(Œ± -> bool) -> Œ± list -> Œ± list
    <tr><td>
    <span class="strong">isPREFIX</span>
    <td>
    :Œ± list -> Œ± list -> bool
    <tr><td>
    <span class="strong">list_CASE</span>
    <td>
    :Œ± list -> Œ≤ -> (Œ± -> Œ± list -> Œ≤) -> Œ≤
    <tr><td>
    <span class="strong">list_size</span>
    <td>
    :(Œ± -> num) -> Œ± list -> num
    <tr><td>
    <span class="strong">mapPartial</span>
    <td>
    :(Œ≤ -> Œ± option) -> Œ≤ list -> Œ± list
    <tr><td> <span class="strong">nub</span> <td> :Œ± list -> Œ± list
    <tr><td> <span class="strong">oEL</span> <td> :num -> Œ± list -> Œ± option
    <tr><td> <span class="strong">oHD</span> <td> :Œ± list -> Œ± option
    <tr><td>
    <span class="strong">splitAtPki</span>
    <td>
    :(num -> Œ≤ -> bool) -> (Œ≤ list -> Œ≤ list -> Œ±) -> Œ≤ list -> Œ±
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">@tempLIST_REL_def</span>
<DD>
<pre>
‚ä¢ LIST_REL =
  (ŒªR a0 a1.
       ‚àÄLIST_REL'.
         (‚àÄa0 a1.
            a0 = [] ‚àß a1 = [] ‚à®
            (‚àÉh1 h2 t1 t2.
               a0 = h1::t1 ‚àß a1 = h2::t2 ‚àß R h1 h2 ‚àß LIST_REL' t1 t2) ‚áí
            LIST_REL' a0 a1) ‚áí
         LIST_REL' a0 a1)
</pre>

<DT><span class="strong">@tempadjacent_def</span>
<DD>
<pre>
‚ä¢ adjacent =
  (Œªa0 a1 a2.
       ‚àÄadjacent'.
         (‚àÄa0 a1 a2.
            (‚àÉt. a0 = a1::a2::t) ‚à® (‚àÉh t. a0 = h::t ‚àß adjacent' t a1 a2) ‚áí
            adjacent' a0 a1 a2) ‚áí
         adjacent' a0 a1 a2)
</pre>

<DT><span class="strong">ALL_DISTINCT</span>
<DD>
<pre>
‚ä¢ (ALL_DISTINCT [] ‚áî T) ‚àß
  ‚àÄh t. ALL_DISTINCT (h::t) ‚áî ¬¨MEM h t ‚àß ALL_DISTINCT t
</pre>

<DT><span class="strong">APPEND_def</span>
<DD>
<pre>
‚ä¢ (‚àÄl. [] ++ l = l) ‚àß ‚àÄh l1 l2. h::l1 ++ l2 = h::(l1 ++ l2)
</pre>

<DT><span class="strong">DROP_def</span>
<DD>
<pre>
‚ä¢ (‚àÄn. DROP n [] = []) ‚àß
  ‚àÄn x xs. DROP n (x::xs) = if n = 0 then x::xs else DROP (n ‚àí 1) xs
</pre>

<DT><span class="strong">EL_def</span>
<DD>
<pre>
‚ä¢ (‚àÄl. EL 0 l = HD l) ‚àß ‚àÄn l. EL (SUC n) l = EL n (TL l)
</pre>

<DT><span class="strong">EVERY_DEF</span>
<DD>
<pre>
‚ä¢ (‚àÄP. EVERY P [] ‚áî T) ‚àß ‚àÄP h t. EVERY P (h::t) ‚áî P h ‚àß EVERY P t
</pre>

<DT><span class="strong">EVERYi_def</span>
<DD>
<pre>
‚ä¢ (‚àÄP. EVERYi P [] ‚áî T) ‚àß ‚àÄP h t. EVERYi P (h::t) ‚áî P 0 h ‚àß EVERYi (P ‚àò SUC) t
</pre>

<DT><span class="strong">EXISTS_DEF</span>
<DD>
<pre>
‚ä¢ (‚àÄP. EXISTS P [] ‚áî F) ‚àß ‚àÄP h t. EXISTS P (h::t) ‚áî P h ‚à® EXISTS P t
</pre>

<DT><span class="strong">FILTER</span>
<DD>
<pre>
‚ä¢ (‚àÄP. FILTER P [] = []) ‚àß
  ‚àÄP h t. FILTER P (h::t) = if P h then h::FILTER P t else FILTER P t
</pre>

<DT><span class="strong">FIND_def</span>
<DD>
<pre>
‚ä¢ ‚àÄP. FIND P = OPTION_MAP SND ‚àò INDEX_FIND 0 P
</pre>

<DT><span class="strong">FLAT</span>
<DD>
<pre>
‚ä¢ FLAT [] = [] ‚àß ‚àÄh t. FLAT (h::t) = h ++ FLAT t
</pre>

<DT><span class="strong">FOLDL</span>
<DD>
<pre>
‚ä¢ (‚àÄf e. FOLDL f e [] = e) ‚àß ‚àÄf e x l. FOLDL f e (x::l) = FOLDL f (f e x) l
</pre>

<DT><span class="strong">FOLDR</span>
<DD>
<pre>
‚ä¢ (‚àÄf e. FOLDR f e [] = e) ‚àß ‚àÄf e x l. FOLDR f e (x::l) = f x (FOLDR f e l)
</pre>

<DT><span class="strong">FRONT_DEF</span>
<DD>
<pre>
‚ä¢ ‚àÄh t. FRONT (h::t) = if t = [] then [] else h::FRONT t
</pre>

<DT><span class="strong">GENLIST</span>
<DD>
<pre>
‚ä¢ (‚àÄf. GENLIST f 0 = []) ‚àß ‚àÄf n. GENLIST f (SUC n) = SNOC (f n) (GENLIST f n)
</pre>

<DT><span class="strong">GENLIST_AUX</span>
<DD>
<pre>
‚ä¢ (‚àÄf l. GENLIST_AUX f 0 l = l) ‚àß
  ‚àÄf n l. GENLIST_AUX f (SUC n) l = GENLIST_AUX f n (f n::l)
</pre>

<DT><span class="strong">HD</span>
<DD>
<pre>
‚ä¢ ‚àÄh t. HD (h::t) = h
</pre>

<DT><span class="strong">INDEX_FIND_def</span>
<DD>
<pre>
‚ä¢ (‚àÄi P. INDEX_FIND i P [] = NONE) ‚àß
  ‚àÄi P h t.
    INDEX_FIND i P (h::t) = if P h then SOME (i,h) else INDEX_FIND (SUC i) P t
</pre>

<DT><span class="strong">INDEX_OF_def</span>
<DD>
<pre>
‚ä¢ ‚àÄx. INDEX_OF x = OPTION_MAP FST ‚àò INDEX_FIND 0 ($= x)
</pre>

<DT><span class="strong">LAST_DEF</span>
<DD>
<pre>
‚ä¢ ‚àÄh t. LAST (h::t) = if t = [] then h else LAST t
</pre>

<DT><span class="strong">LENGTH</span>
<DD>
<pre>
‚ä¢ LENGTH [] = 0 ‚àß ‚àÄh t. LENGTH (h::t) = SUC (LENGTH t)
</pre>

<DT><span class="strong">LEN_DEF</span>
<DD>
<pre>
‚ä¢ (‚àÄn. LEN [] n = n) ‚àß ‚àÄh t n. LEN (h::t) n = LEN t (n + 1)
</pre>

<DT><span class="strong">LIST_APPLY_def</span>
<DD>
<pre>
‚ä¢ ‚àÄfs xs. fs <*> xs = LIST_BIND fs (flip MAP xs)
</pre>

<DT><span class="strong">LIST_BIND_def</span>
<DD>
<pre>
‚ä¢ ‚àÄl f. LIST_BIND l f = FLAT (MAP f l)
</pre>

<DT><span class="strong">LIST_GUARD_def</span>
<DD>
<pre>
‚ä¢ ‚àÄb. LIST_GUARD b = if b then [()] else []
</pre>

<DT><span class="strong">LIST_IGNORE_BIND_def</span>
<DD>
<pre>
‚ä¢ ‚àÄm1 m2. LIST_IGNORE_BIND m1 m2 = LIST_BIND m1 (K m2)
</pre>

<DT><span class="strong">LIST_LIFT2_def</span>
<DD>
<pre>
‚ä¢ ‚àÄf xs ys. LIST_LIFT2 f xs ys = MAP f xs <*> ys
</pre>

<DT><span class="strong">LIST_TO_SET_DEF</span>
<DD>
<pre>
‚ä¢ (‚àÄx. LIST_TO_SET [] x ‚áî F) ‚àß
  ‚àÄh t x. LIST_TO_SET (h::t) x ‚áî x = h ‚à® LIST_TO_SET t x
</pre>

<DT><span class="strong">LLEX_def</span>
<DD>
<pre>
‚ä¢ (‚àÄR l2. LLEX R [] l2 ‚áî l2 ‚â† []) ‚àß
  ‚àÄR h1 t1 l2.
    LLEX R (h1::t1) l2 ‚áî
    case l2 of
      [] => F
    | h2::t2 => if R h1 h2 then T else if h1 = h2 then LLEX R t1 t2 else F
</pre>

<DT><span class="strong">LRC_def</span>
<DD>
<pre>
‚ä¢ (‚àÄR x y. LRC R [] x y ‚áî x = y) ‚àß
  ‚àÄR h t x y. LRC R (h::t) x y ‚áî x = h ‚àß ‚àÉz. R x z ‚àß LRC R t z y
</pre>

<DT><span class="strong">LUPDATE_DEF</span>
<DD>
<pre>
‚ä¢ (‚àÄe n. LUPDATE e n [] = []) ‚àß
  ‚àÄe n x l.
    LUPDATE e n (x::l) = if n = 0 then e::l else x::LUPDATE e (PRE n) l
</pre>

<DT><span class="strong">MAP</span>
<DD>
<pre>
‚ä¢ (‚àÄf. MAP f [] = []) ‚àß ‚àÄf h t. MAP f (h::t) = f h::MAP f t
</pre>

<DT><span class="strong">NULL_DEF</span>
<DD>
<pre>
‚ä¢ (NULL [] ‚áî T) ‚àß ‚àÄh t. NULL (h::t) ‚áî F
</pre>

<DT><span class="strong">OPT_MMAP_def</span>
<DD>
<pre>
‚ä¢ (‚àÄf. OPT_MMAP f [] = SOME []) ‚àß
  ‚àÄf h0 t0.
    OPT_MMAP f (h0::t0) = do h <- f h0; t <- OPT_MMAP f t0; SOME (h::t) od
</pre>

<DT><span class="strong">PAD_LEFT</span>
<DD>
<pre>
‚ä¢ ‚àÄc n s. PAD_LEFT c n s = GENLIST (K c) (n ‚àí LENGTH s) ++ s
</pre>

<DT><span class="strong">PAD_RIGHT</span>
<DD>
<pre>
‚ä¢ ‚àÄc n s. PAD_RIGHT c n s = s ++ GENLIST (K c) (n ‚àí LENGTH s)
</pre>

<DT><span class="strong">REVERSE_DEF</span>
<DD>
<pre>
‚ä¢ REVERSE [] = [] ‚àß ‚àÄh t. REVERSE (h::t) = REVERSE t ++ [h]
</pre>

<DT><span class="strong">REV_DEF</span>
<DD>
<pre>
‚ä¢ (‚àÄacc. REV [] acc = acc) ‚àß ‚àÄh t acc. REV (h::t) acc = REV t (h::acc)
</pre>

<DT><span class="strong">SET_REL_def</span>
<DD>
<pre>
‚ä¢ ‚àÄR s1 s2.
    SET_REL R s1 s2 ‚áî
    ‚àÉps.
      IMAGE FST ps = s1 ‚àß IMAGE SND ps = s2 ‚àß ‚àÄp. p ‚àà ps ‚áí R (FST p) (SND p)
</pre>

<DT><span class="strong">SET_TO_LIST_primitive_def</span>
<DD>
<pre>
‚ä¢ SET_TO_LIST =
  WFREC (@R. WF R ‚àß ‚àÄs. FINITE s ‚àß s ‚â† ‚àÖ ‚áí R (REST s) s)
    (ŒªSET_TO_LIST a.
         I
           (if FINITE a then
              if a = ‚àÖ then [] else CHOICE a::SET_TO_LIST (REST a)
            else ARB))
</pre>

<DT><span class="strong">SHORTLEX_def</span>
<DD>
<pre>
‚ä¢ (‚àÄR l2. SHORTLEX R [] l2 ‚áî l2 ‚â† []) ‚àß
  ‚àÄR h1 t1 l2.
    SHORTLEX R (h1::t1) l2 ‚áî
    case l2 of
      [] => F
    | h2::t2 =>
      if LENGTH t1 < LENGTH t2 then T
      else if LENGTH t1 = LENGTH t2 then
        if R h1 h2 then T else if h1 = h2 then SHORTLEX R t1 t2 else F
      else F
</pre>

<DT><span class="strong">SNOC</span>
<DD>
<pre>
‚ä¢ (‚àÄx. SNOC x [] = [x]) ‚àß ‚àÄx x' l. SNOC x (x'::l) = x'::SNOC x l
</pre>

<DT><span class="strong">SUM</span>
<DD>
<pre>
‚ä¢ SUM [] = 0 ‚àß ‚àÄh t. SUM (h::t) = h + SUM t
</pre>

<DT><span class="strong">SUM_ACC_DEF</span>
<DD>
<pre>
‚ä¢ (‚àÄacc. SUM_ACC [] acc = acc) ‚àß
  ‚àÄh t acc. SUM_ACC (h::t) acc = SUM_ACC t (h + acc)
</pre>

<DT><span class="strong">TAKE_def</span>
<DD>
<pre>
‚ä¢ (‚àÄn. TAKE n [] = []) ‚àß
  ‚àÄn x xs. TAKE n (x::xs) = if n = 0 then [] else x::TAKE (n ‚àí 1) xs
</pre>

<DT><span class="strong">TL_DEF</span>
<DD>
<pre>
‚ä¢ TL [] = [] ‚àß ‚àÄh t. TL (h::t) = t
</pre>

<DT><span class="strong">UNIQUE_DEF</span>
<DD>
<pre>
‚ä¢ ‚àÄe L. UNIQUE e L ‚áî ‚àÉL1 L2. L1 ++ [e] ++ L2 = L ‚àß ¬¨MEM e L1 ‚àß ¬¨MEM e L2
</pre>

<DT><span class="strong">UNZIP</span>
<DD>
<pre>
‚ä¢ UNZIP [] = ([],[]) ‚àß
  ‚àÄx l. UNZIP (x::l) = (FST x::FST (UNZIP l),SND x::SND (UNZIP l))
</pre>

<DT><span class="strong">ZIP_def</span>
<DD>
<pre>
‚ä¢ (‚àÄl2. ZIP ([],l2) = []) ‚àß (‚àÄl1. ZIP (l1,[]) = []) ‚àß
  ‚àÄx1 l1 x2 l2. ZIP (x1::l1,x2::l2) = (x1,x2)::ZIP (l1,l2)
</pre>

<DT><span class="strong">dropWhile_def</span>
<DD>
<pre>
‚ä¢ (‚àÄP. dropWhile P [] = []) ‚àß
  ‚àÄP h t. dropWhile P (h::t) = if P h then dropWhile P t else h::t
</pre>

<DT><span class="strong">isPREFIX</span>
<DD>
<pre>
‚ä¢ (‚àÄl. [] ‚âº l ‚áî T) ‚àß
  ‚àÄh t l. h::t ‚âº l ‚áî case l of [] => F | h'::t' => h = h' ‚àß t ‚âº t'
</pre>

<DT><span class="strong">list_TY_DEF</span>
<DD>
<pre>
‚ä¢ ‚àÉrep.
    TYPE_DEFINITION
      (Œªa0'.
           ‚àÄ $var$('list').
             (‚àÄa0'.
                a0' = ind_type$CONSTR 0 ARB (Œªn. ind_type$BOTTOM) ‚à®
                (‚àÉa0 a1.
                   a0' =
                   (Œªa0 a1.
                        ind_type$CONSTR (SUC 0) a0
                          (ind_type$FCONS a1 (Œªn. ind_type$BOTTOM))) a0 a1 ‚àß
                   $var$('list') a1) ‚áí
                $var$('list') a0') ‚áí
             $var$('list') a0') rep
</pre>

<DT><span class="strong">list_case_def</span>
<DD>
<pre>
‚ä¢ (‚àÄv f. list_CASE [] v f = v) ‚àß ‚àÄa0 a1 v f. list_CASE (a0::a1) v f = f a0 a1
</pre>

<DT><span class="strong">list_size_def</span>
<DD>
<pre>
‚ä¢ (‚àÄf. list_size f [] = 0) ‚àß
  ‚àÄf a0 a1. list_size f (a0::a1) = 1 + (f a0 + list_size f a1)
</pre>

<DT><span class="strong">mapPartial_def</span>
<DD>
<pre>
‚ä¢ (‚àÄf. mapPartial f [] = []) ‚àß
  ‚àÄf x xs.
    mapPartial f (x::xs) =
    case f x of NONE => mapPartial f xs | SOME y => y::mapPartial f xs
</pre>

<DT><span class="strong">nub_def</span>
<DD>
<pre>
‚ä¢ nub [] = [] ‚àß ‚àÄx l. nub (x::l) = if MEM x l then nub l else x::nub l
</pre>

<DT><span class="strong">oEL_def</span>
<DD>
<pre>
‚ä¢ (‚àÄn. oEL n [] = NONE) ‚àß
  ‚àÄn x xs. oEL n (x::xs) = if n = 0 then SOME x else oEL (n ‚àí 1) xs
</pre>

<DT><span class="strong">oHD_def</span>
<DD>
<pre>
‚ä¢ ‚àÄl. oHD l = case l of [] => NONE | h::v1 => SOME h
</pre>

<DT><span class="strong">splitAtPki_def</span>
<DD>
<pre>
‚ä¢ (‚àÄP k. splitAtPki P k [] = k [] []) ‚àß
  ‚àÄP k h t.
    splitAtPki P k (h::t) =
    if P 0 h then k [] (h::t) else splitAtPki (P ‚àò SUC) (Œªp s. k (h::p) s) t
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">ALL_DISTINCT_APPEND</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2.
    ALL_DISTINCT (l1 ++ l2) ‚áî
    ALL_DISTINCT l1 ‚àß ALL_DISTINCT l2 ‚àß ‚àÄe. MEM e l1 ‚áí ¬¨MEM e l2
</pre>

<DT><span class="strong">ALL_DISTINCT_APPEND'</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2.
    ALL_DISTINCT (l1 ++ l2) ‚áî
    ALL_DISTINCT l1 ‚àß ALL_DISTINCT l2 ‚àß
    DISJOINT (LIST_TO_SET l1) (LIST_TO_SET l2)
</pre>

<DT><span class="strong">ALL_DISTINCT_CARD_LIST_TO_SET</span>
<DD>
<pre>
‚ä¢ ‚àÄls. ALL_DISTINCT ls ‚áí CARD (LIST_TO_SET ls) = LENGTH ls
</pre>

<DT><span class="strong">ALL_DISTINCT_DROP</span>
<DD>
<pre>
‚ä¢ ‚àÄls n. ALL_DISTINCT ls ‚áí ALL_DISTINCT (DROP n ls)
</pre>

<DT><span class="strong">ALL_DISTINCT_EL_IMP</span>
<DD>
<pre>
‚ä¢ ‚àÄl n1 n2.
    ALL_DISTINCT l ‚àß n1 < LENGTH l ‚àß n2 < LENGTH l ‚áí
    (EL n1 l = EL n2 l ‚áî n1 = n2)
</pre>

<DT><span class="strong">ALL_DISTINCT_FILTER</span>
<DD>
<pre>
‚ä¢ ‚àÄl. ALL_DISTINCT l ‚áî ‚àÄx. MEM x l ‚áí FILTER ($= x) l = [x]
</pre>

<DT><span class="strong">ALL_DISTINCT_FILTER_EL_IMP</span>
<DD>
<pre>
‚ä¢ ‚àÄP l n1 n2.
    ALL_DISTINCT (FILTER P l) ‚àß n1 < LENGTH l ‚àß n2 < LENGTH l ‚àß P (EL n1 l) ‚àß
    EL n1 l = EL n2 l ‚áí
    n1 = n2
</pre>

<DT><span class="strong">ALL_DISTINCT_FLAT_REVERSE</span>
<DD>
<pre>
‚ä¢ ‚àÄxs. ALL_DISTINCT (FLAT (REVERSE xs)) ‚áî ALL_DISTINCT (FLAT xs)
</pre>

<DT><span class="strong">ALL_DISTINCT_GENLIST</span>
<DD>
<pre>
‚ä¢ ALL_DISTINCT (GENLIST f n) ‚áî ‚àÄm1 m2. m1 < n ‚àß m2 < n ‚àß f m1 = f m2 ‚áí m1 = m2
</pre>

<DT><span class="strong">ALL_DISTINCT_INDEX_OF_EL</span>
<DD>
<pre>
‚ä¢ ‚àÄl n. ALL_DISTINCT l ‚àß n < LENGTH l ‚áí INDEX_OF (EL n l) l = SOME n
</pre>

<DT><span class="strong">ALL_DISTINCT_MAP</span>
<DD>
<pre>
‚ä¢ ‚àÄf ls. ALL_DISTINCT (MAP f ls) ‚áí ALL_DISTINCT ls
</pre>

<DT><span class="strong">ALL_DISTINCT_MAP_INJ</span>
<DD>
<pre>
‚ä¢ ‚àÄls f.
    (‚àÄx y. MEM x ls ‚àß MEM y ls ‚àß f x = f y ‚áí x = y) ‚àß ALL_DISTINCT ls ‚áí
    ALL_DISTINCT (MAP f ls)
</pre>

<DT><span class="strong">ALL_DISTINCT_REVERSE</span>
<DD>
<pre>
‚ä¢ ‚àÄl. ALL_DISTINCT (REVERSE l) ‚áî ALL_DISTINCT l
</pre>

<DT><span class="strong">ALL_DISTINCT_SET_TO_LIST</span>
<DD>
<pre>
‚ä¢ ‚àÄs. FINITE s ‚áí ALL_DISTINCT (SET_TO_LIST s)
</pre>

<DT><span class="strong">ALL_DISTINCT_SING</span>
<DD>
<pre>
‚ä¢ ‚àÄx. ALL_DISTINCT [x]
</pre>

<DT><span class="strong">ALL_DISTINCT_SNOC</span>
<DD>
<pre>
‚ä¢ ‚àÄx l. ALL_DISTINCT (SNOC x l) ‚áî ¬¨MEM x l ‚àß ALL_DISTINCT l
</pre>

<DT><span class="strong">ALL_DISTINCT_TAKE</span>
<DD>
<pre>
‚ä¢ ‚àÄls n. ALL_DISTINCT ls ‚áí ALL_DISTINCT (TAKE n ls)
</pre>

<DT><span class="strong">ALL_DISTINCT_ZIP</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2. ALL_DISTINCT l1 ‚àß LENGTH l1 = LENGTH l2 ‚áí ALL_DISTINCT (ZIP (l1,l2))
</pre>

<DT><span class="strong">ALL_DISTINCT_ZIP_SWAP</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2.
    ALL_DISTINCT (ZIP (l1,l2)) ‚àß LENGTH l1 = LENGTH l2 ‚áí
    ALL_DISTINCT (ZIP (l2,l1))
</pre>

<DT><span class="strong">APPEND</span>
<DD>
<pre>
‚ä¢ (‚àÄl. [] ++ l = l) ‚àß ‚àÄl1 l2 h. h::l1 ++ l2 = h::(l1 ++ l2)
</pre>

<DT><span class="strong">APPEND_11</span>
<DD>
<pre>
‚ä¢ (‚àÄl1 l2 l3. l1 ++ l2 = l1 ++ l3 ‚áî l2 = l3) ‚àß
  ‚àÄl1 l2 l3. l2 ++ l1 = l3 ++ l1 ‚áî l2 = l3
</pre>

<DT><span class="strong">APPEND_11_LENGTH</span>
<DD>
<pre>
‚ä¢ (‚àÄl1 l2 l1' l2'.
     LENGTH l1 = LENGTH l1' ‚áí (l1 ++ l2 = l1' ++ l2' ‚áî l1 = l1' ‚àß l2 = l2')) ‚àß
  ‚àÄl1 l2 l1' l2'.
    LENGTH l2 = LENGTH l2' ‚áí (l1 ++ l2 = l1' ++ l2' ‚áî l1 = l1' ‚àß l2 = l2')
</pre>

<DT><span class="strong">APPEND_ASSOC</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2 l3. l1 ++ (l2 ++ l3) = l1 ++ l2 ++ l3
</pre>

<DT><span class="strong">APPEND_EQ_APPEND</span>
<DD>
<pre>
‚ä¢ l1 ++ l2 = m1 ++ m2 ‚áî
  (‚àÉl. l1 = m1 ++ l ‚àß m2 = l ++ l2) ‚à® ‚àÉl. m1 = l1 ++ l ‚àß l2 = l ++ m2
</pre>

<DT><span class="strong">APPEND_EQ_APPEND_MID</span>
<DD>
<pre>
‚ä¢ l1 ++ [e] ++ l2 = m1 ++ m2 ‚áî
  (‚àÉl. m1 = l1 ++ [e] ++ l ‚àß l2 = l ++ m2) ‚à®
  ‚àÉl. l1 = m1 ++ l ‚àß m2 = l ++ [e] ++ l2
</pre>

<DT><span class="strong">APPEND_EQ_CONS</span>
<DD>
<pre>
‚ä¢ l1 ++ l2 = h::t ‚áî l1 = [] ‚àß l2 = h::t ‚à® ‚àÉlt. l1 = h::lt ‚àß t = lt ++ l2
</pre>

<DT><span class="strong">APPEND_EQ_SELF</span>
<DD>
<pre>
‚ä¢ (‚àÄl1 l2. l1 ++ l2 = l1 ‚áî l2 = []) ‚àß (‚àÄl1 l2. l1 ++ l2 = l2 ‚áî l1 = []) ‚àß
  (‚àÄl1 l2. l1 = l1 ++ l2 ‚áî l2 = []) ‚àß ‚àÄl1 l2. l2 = l1 ++ l2 ‚áî l1 = []
</pre>

<DT><span class="strong">APPEND_EQ_SING</span>
<DD>
<pre>
‚ä¢ l1 ++ l2 = [e] ‚áî l1 = [e] ‚àß l2 = [] ‚à® l1 = [] ‚àß l2 = [e]
</pre>

<DT><span class="strong">APPEND_FRONT_LAST</span>
<DD>
<pre>
‚ä¢ ‚àÄl. l ‚â† [] ‚áí FRONT l ++ [LAST l] = l
</pre>

<DT><span class="strong">APPEND_LENGTH_EQ</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l1'.
    LENGTH l1 = LENGTH l1' ‚áí
    ‚àÄl2 l2'.
      LENGTH l2 = LENGTH l2' ‚áí (l1 ++ l2 = l1' ++ l2' ‚áî l1 = l1' ‚àß l2 = l2')
</pre>

<DT><span class="strong">APPEND_NIL</span>
<DD>
<pre>
‚ä¢ ‚àÄl. l ++ [] = l
</pre>

<DT><span class="strong">APPEND_SNOC</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 x l2. l1 ++ SNOC x l2 = SNOC x (l1 ++ l2)
</pre>

<DT><span class="strong">APPEND_eq_NIL</span>
<DD>
<pre>
‚ä¢ (‚àÄl1 l2. [] = l1 ++ l2 ‚áî l1 = [] ‚àß l2 = []) ‚àß
  ‚àÄl1 l2. l1 ++ l2 = [] ‚áî l1 = [] ‚àß l2 = []
</pre>

<DT><span class="strong">BIGUNION_IMAGE_set_SUBSET</span>
<DD>
<pre>
‚ä¢ BIGUNION (IMAGE f (LIST_TO_SET ls)) ‚äÜ s ‚áî ‚àÄx. MEM x ls ‚áí f x ‚äÜ s
</pre>

<DT><span class="strong">CARD_LIST_TO_SET</span>
<DD>
<pre>
‚ä¢ CARD (LIST_TO_SET ls) ‚â§ LENGTH ls
</pre>

<DT><span class="strong">CARD_LIST_TO_SET_ALL_DISTINCT</span>
<DD>
<pre>
‚ä¢ ‚àÄls. CARD (LIST_TO_SET ls) = LENGTH ls ‚áí ALL_DISTINCT ls
</pre>

<DT><span class="strong">CARD_LIST_TO_SET_EQN</span>
<DD>
<pre>
‚ä¢ CARD (LIST_TO_SET l) = LENGTH (nub l)
</pre>

<DT><span class="strong">CONS</span>
<DD>
<pre>
‚ä¢ ‚àÄl. ¬¨NULL l ‚áí HD l::TL l = l
</pre>

<DT><span class="strong">CONS_11</span>
<DD>
<pre>
‚ä¢ ‚àÄa0 a1 a0' a1'. a0::a1 = a0'::a1' ‚áî a0 = a0' ‚àß a1 = a1'
</pre>

<DT><span class="strong">CONS_ACYCLIC</span>
<DD>
<pre>
‚ä¢ ‚àÄl x. l ‚â† x::l ‚àß x::l ‚â† l
</pre>

<DT><span class="strong">CONS_PRS</span>
<DD>
<pre>
‚ä¢ ‚àÄR abs rep. QUOTIENT R abs rep ‚áí ‚àÄt h. h::t = MAP abs (rep h::MAP rep t)
</pre>

<DT><span class="strong">CONS_RSP</span>
<DD>
<pre>
‚ä¢ ‚àÄR abs rep.
    QUOTIENT R abs rep ‚áí
    ‚àÄt1 t2 h1 h2. R h1 h2 ‚àß LIST_REL R t1 t2 ‚áí LIST_REL R (h1::t1) (h2::t2)
</pre>

<DT><span class="strong">DISJOINT_GENLIST_PLUS</span>
<DD>
<pre>
‚ä¢ DISJOINT x (LIST_TO_SET (GENLIST ($+ n) (a + b))) ‚áí
  DISJOINT x (LIST_TO_SET (GENLIST ($+ n) a)) ‚àß
  DISJOINT x (LIST_TO_SET (GENLIST ($+ (n + a)) b))
</pre>

<DT><span class="strong">DROP_0</span>
<DD>
<pre>
‚ä¢ DROP 0 l = l
</pre>

<DT><span class="strong">DROP_APPEND</span>
<DD>
<pre>
‚ä¢ ‚àÄn l1 l2. DROP n (l1 ++ l2) = DROP n l1 ++ DROP (n ‚àí LENGTH l1) l2
</pre>

<DT><span class="strong">DROP_APPEND1</span>
<DD>
<pre>
‚ä¢ ‚àÄn l1. n ‚â§ LENGTH l1 ‚áí ‚àÄl2. DROP n (l1 ++ l2) = DROP n l1 ++ l2
</pre>

<DT><span class="strong">DROP_APPEND2</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 n. LENGTH l1 ‚â§ n ‚áí ‚àÄl2. DROP n (l1 ++ l2) = DROP (n ‚àí LENGTH l1) l2
</pre>

<DT><span class="strong">DROP_EQ_NIL</span>
<DD>
<pre>
‚ä¢ ‚àÄls n. DROP n ls = [] ‚áî LENGTH ls ‚â§ n
</pre>

<DT><span class="strong">DROP_GENLIST</span>
<DD>
<pre>
‚ä¢ DROP n (GENLIST f m) = GENLIST (f ‚àò $+ n) (m ‚àí n)
</pre>

<DT><span class="strong">DROP_LENGTH_NIL</span>
<DD>
<pre>
‚ä¢ ‚àÄl. DROP (LENGTH l) l = []
</pre>

<DT><span class="strong">DROP_LENGTH_TOO_LONG</span>
<DD>
<pre>
‚ä¢ ‚àÄl n. LENGTH l ‚â§ n ‚áí DROP n l = []
</pre>

<DT><span class="strong">DROP_TAKE</span>
<DD>
<pre>
‚ä¢ ‚àÄxs n k. DROP n (TAKE k xs) = TAKE (k ‚àí n) (DROP n xs)
</pre>

<DT><span class="strong">DROP_compute</span>
<DD>
<pre>
‚ä¢ (‚àÄl. DROP 0 l = l) ‚àß (‚àÄn. DROP <..num comp'n..> [] = []) ‚àß
  (‚àÄn. DROP <..num comp'n..> [] = []) ‚àß
  (‚àÄn h t. DROP <..num comp'n..> (h::t) = DROP (<..num comp'n..> ‚àí 1) t) ‚àß
  ‚àÄn h t. DROP <..num comp'n..> (h::t) = DROP <..num comp'n..> t
</pre>

<DT><span class="strong">DROP_cons</span>
<DD>
<pre>
‚ä¢ 0 < n ‚áí DROP n (x::xs) = DROP (n ‚àí 1) xs
</pre>

<DT><span class="strong">DROP_nil</span>
<DD>
<pre>
‚ä¢ ‚àÄn. DROP n [] = []
</pre>

<DT><span class="strong">DROP_splitAtPki</span>
<DD>
<pre>
‚ä¢ DROP n l = splitAtPki (K ‚àò $= n) (K I) l
</pre>

<DT><span class="strong">EL</span>
<DD>
<pre>
‚ä¢ (‚àÄl. EL 0 l = HD l) ‚àß ‚àÄl n. EL (SUC n) l = EL n (TL l)
</pre>

<DT><span class="strong">EL_ALL_DISTINCT_EL_EQ</span>
<DD>
<pre>
‚ä¢ ‚àÄl. ALL_DISTINCT l ‚áî
      ‚àÄn1 n2. n1 < LENGTH l ‚àß n2 < LENGTH l ‚áí (EL n1 l = EL n2 l ‚áî n1 = n2)
</pre>

<DT><span class="strong">EL_APPEND_EQN</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2 n.
    EL n (l1 ++ l2) = if n < LENGTH l1 then EL n l1 else EL (n ‚àí LENGTH l1) l2
</pre>

<DT><span class="strong">EL_DROP</span>
<DD>
<pre>
‚ä¢ ‚àÄm n l. m + n < LENGTH l ‚áí EL m (DROP n l) = EL (m + n) l
</pre>

<DT><span class="strong">EL_GENLIST</span>
<DD>
<pre>
‚ä¢ ‚àÄf n x. x < n ‚áí EL x (GENLIST f n) = f x
</pre>

<DT><span class="strong">EL_LENGTH_SNOC</span>
<DD>
<pre>
‚ä¢ ‚àÄl x. EL (LENGTH l) (SNOC x l) = x
</pre>

<DT><span class="strong">EL_LENGTH_dropWhile_REVERSE</span>
<DD>
<pre>
‚ä¢ ‚àÄP ls k. LENGTH (dropWhile P (REVERSE ls)) ‚â§ k ‚àß k < LENGTH ls ‚áí P (EL k ls)
</pre>

<DT><span class="strong">EL_LUPDATE</span>
<DD>
<pre>
‚ä¢ ‚àÄys x i k.
    EL i (LUPDATE x k ys) = if i = k ‚àß k < LENGTH ys then x else EL i ys
</pre>

<DT><span class="strong">EL_MAP</span>
<DD>
<pre>
‚ä¢ ‚àÄn l. n < LENGTH l ‚áí ‚àÄf. EL n (MAP f l) = f (EL n l)
</pre>

<DT><span class="strong">EL_MAP2</span>
<DD>
<pre>
‚ä¢ ‚àÄts tt n.
    n < MIN (LENGTH ts) (LENGTH tt) ‚áí
    EL n (MAP2 f ts tt) = f (EL n ts) (EL n tt)
</pre>

<DT><span class="strong">EL_MEM</span>
<DD>
<pre>
‚ä¢ ‚àÄn l. n < LENGTH l ‚áí MEM (EL n l) l
</pre>

<DT><span class="strong">EL_REVERSE</span>
<DD>
<pre>
‚ä¢ ‚àÄn l. n < LENGTH l ‚áí EL n (REVERSE l) = EL (PRE (LENGTH l ‚àí n)) l
</pre>

<DT><span class="strong">EL_SNOC</span>
<DD>
<pre>
‚ä¢ ‚àÄn l. n < LENGTH l ‚áí ‚àÄx. EL n (SNOC x l) = EL n l
</pre>

<DT><span class="strong">EL_TAKE</span>
<DD>
<pre>
‚ä¢ ‚àÄn x l. x < n ‚áí EL x (TAKE n l) = EL x l
</pre>

<DT><span class="strong">EL_ZIP</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2 n.
    LENGTH l1 = LENGTH l2 ‚àß n < LENGTH l1 ‚áí
    EL n (ZIP (l1,l2)) = (EL n l1,EL n l2)
</pre>

<DT><span class="strong">EL_compute</span>
<DD>
<pre>
‚ä¢ ‚àÄn. EL n l = if n = 0 then HD l else EL (PRE n) (TL l)
</pre>

<DT><span class="strong">EL_restricted</span>
<DD>
<pre>
‚ä¢ EL 0 = HD ‚àß EL (SUC n) (l::ls) = EL n ls
</pre>

<DT><span class="strong">EL_simp</span>
<DD>
<pre>
‚ä¢ EL <..num comp'n..> l = EL (PRE <..num comp'n..> ) (TL l) ‚àß
  EL <..num comp'n..> l = EL <..num comp'n..> (TL l)
</pre>

<DT><span class="strong">EL_simp_restricted</span>
<DD>
<pre>
‚ä¢ EL <..num comp'n..> (l::ls) = EL (PRE <..num comp'n..> ) ls ‚àß
  EL <..num comp'n..> (l::ls) = EL <..num comp'n..> ls
</pre>

<DT><span class="strong">EQ_LIST</span>
<DD>
<pre>
‚ä¢ ‚àÄh1 h2. h1 = h2 ‚áí ‚àÄl1 l2. l1 = l2 ‚áí h1::l1 = h2::l2
</pre>

<DT><span class="strong">EVERY2_EVERY</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2 f. LIST_REL f l1 l2 ‚áî LENGTH l1 = LENGTH l2 ‚àß EVERY f·¥æ (ZIP (l1,l2))
</pre>

<DT><span class="strong">EVERY2_LENGTH</span>
<DD>
<pre>
‚ä¢ ‚àÄP l1 l2. LIST_REL P l1 l2 ‚áí LENGTH l1 = LENGTH l2
</pre>

<DT><span class="strong">EVERY2_LUPDATE_same</span>
<DD>
<pre>
‚ä¢ ‚àÄP l1 l2 v1 v2 n.
    P v1 v2 ‚àß LIST_REL P l1 l2 ‚áí
    LIST_REL P (LUPDATE v1 n l1) (LUPDATE v2 n l2)
</pre>

<DT><span class="strong">EVERY2_MAP</span>
<DD>
<pre>
‚ä¢ (LIST_REL P (MAP f l1) l2 ‚áî LIST_REL (Œªx y. P (f x) y) l1 l2) ‚àß
  (LIST_REL Q l1 (MAP g l2) ‚áî LIST_REL (Œªx y. Q x (g y)) l1 l2)
</pre>

<DT><span class="strong">EVERY2_MEM_MONO</span>
<DD>
<pre>
‚ä¢ ‚àÄP Q l1 l2.
    (‚àÄx. MEM x (ZIP (l1,l2)) ‚àß P·¥æ x ‚áí Q·¥æ x) ‚àß LIST_REL P l1 l2 ‚áí
    LIST_REL Q l1 l2
</pre>

<DT><span class="strong">EVERY2_REVERSE</span>
<DD>
<pre>
‚ä¢ ‚àÄR l1 l2. LIST_REL R l1 l2 ‚áí LIST_REL R (REVERSE l1) (REVERSE l2)
</pre>

<DT><span class="strong">EVERY2_THM</span>
<DD>
<pre>
‚ä¢ (‚àÄP ys. LIST_REL P [] ys ‚áî ys = []) ‚àß
  (‚àÄP yys x xs.
     LIST_REL P (x::xs) yys ‚áî ‚àÉy ys. yys = y::ys ‚àß P x y ‚àß LIST_REL P xs ys) ‚àß
  (‚àÄP xs. LIST_REL P xs [] ‚áî xs = []) ‚àß
  ‚àÄP xxs y ys.
    LIST_REL P xxs (y::ys) ‚áî ‚àÉx xs. xxs = x::xs ‚àß P x y ‚àß LIST_REL P xs ys
</pre>

<DT><span class="strong">EVERY2_cong</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l1' l2 l2' P P'.
    l1 = l1' ‚àß l2 = l2' ‚àß (‚àÄx y. MEM x l1' ‚àß MEM y l2' ‚áí (P x y ‚áî P' x y)) ‚áí
    (LIST_REL P l1 l2 ‚áî LIST_REL P' l1' l2')
</pre>

<DT><span class="strong">EVERY2_mono</span>
<DD>
<pre>
‚ä¢ (‚àÄx y. R1 x y ‚áí R2 x y) ‚áí LIST_REL R1 l1 l2 ‚áí LIST_REL R2 l1 l2
</pre>

<DT><span class="strong">EVERY2_refl</span>
<DD>
<pre>
‚ä¢ (‚àÄx. MEM x ls ‚áí R x x) ‚áí LIST_REL R ls ls
</pre>

<DT><span class="strong">EVERY2_sym</span>
<DD>
<pre>
‚ä¢ (‚àÄx y. R1 x y ‚áí R2 y x) ‚áí ‚àÄx y. LIST_REL R1 x y ‚áí LIST_REL R2 y x
</pre>

<DT><span class="strong">EVERY2_trans</span>
<DD>
<pre>
‚ä¢ (‚àÄx y z. R x y ‚àß R y z ‚áí R x z) ‚áí
  ‚àÄx y z. LIST_REL R x y ‚àß LIST_REL R y z ‚áí LIST_REL R x z
</pre>

<DT><span class="strong">EVERY_APPEND</span>
<DD>
<pre>
‚ä¢ ‚àÄP l1 l2. EVERY P (l1 ++ l2) ‚áî EVERY P l1 ‚àß EVERY P l2
</pre>

<DT><span class="strong">EVERY_CONG</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2 P P'.
    l1 = l2 ‚àß (‚àÄx. MEM x l2 ‚áí (P x ‚áî P' x)) ‚áí (EVERY P l1 ‚áî EVERY P' l2)
</pre>

<DT><span class="strong">EVERY_CONJ</span>
<DD>
<pre>
‚ä¢ ‚àÄP Q l. EVERY (Œªx. P x ‚àß Q x) l ‚áî EVERY P l ‚àß EVERY Q l
</pre>

<DT><span class="strong">EVERY_EL</span>
<DD>
<pre>
‚ä¢ ‚àÄl P. EVERY P l ‚áî ‚àÄn. n < LENGTH l ‚áí P (EL n l)
</pre>

<DT><span class="strong">EVERY_FILTER</span>
<DD>
<pre>
‚ä¢ ‚àÄP1 P2 l. EVERY P1 (FILTER P2 l) ‚áî EVERY (Œªx. P2 x ‚áí P1 x) l
</pre>

<DT><span class="strong">EVERY_FILTER_IMP</span>
<DD>
<pre>
‚ä¢ ‚àÄP1 P2 l. EVERY P1 l ‚áí EVERY P1 (FILTER P2 l)
</pre>

<DT><span class="strong">EVERY_FLAT</span>
<DD>
<pre>
‚ä¢ EVERY P (FLAT ls) ‚áî EVERY (EVERY P) ls
</pre>

<DT><span class="strong">EVERY_GENLIST</span>
<DD>
<pre>
‚ä¢ ‚àÄn. EVERY P (GENLIST f n) ‚áî ‚àÄi. i < n ‚áí P (f i)
</pre>

<DT><span class="strong">EVERY_MAP</span>
<DD>
<pre>
‚ä¢ ‚àÄP f l. EVERY P (MAP f l) ‚áî EVERY (Œªx. P (f x)) l
</pre>

<DT><span class="strong">EVERY_MEM</span>
<DD>
<pre>
‚ä¢ ‚àÄP l. EVERY P l ‚áî ‚àÄe. MEM e l ‚áí P e
</pre>

<DT><span class="strong">EVERY_MEM_MONO</span>
<DD>
<pre>
‚ä¢ ‚àÄP Q l. (‚àÄx. MEM x l ‚àß P x ‚áí Q x) ‚àß EVERY P l ‚áí EVERY Q l
</pre>

<DT><span class="strong">EVERY_MONOTONIC</span>
<DD>
<pre>
‚ä¢ ‚àÄP Q. (‚àÄx. P x ‚áí Q x) ‚áí ‚àÄl. EVERY P l ‚áí EVERY Q l
</pre>

<DT><span class="strong">EVERY_NOT_EXISTS</span>
<DD>
<pre>
‚ä¢ ‚àÄP l. EVERY P l ‚áî ¬¨EXISTS (Œªx. ¬¨P x) l
</pre>

<DT><span class="strong">EVERY_PRS</span>
<DD>
<pre>
‚ä¢ ‚àÄR abs rep.
    QUOTIENT R abs rep ‚áí ‚àÄl P. EVERY P l ‚áî EVERY ((abs ‚ü∂ I) P) (MAP rep l)
</pre>

<DT><span class="strong">EVERY_RSP</span>
<DD>
<pre>
‚ä¢ ‚àÄR abs rep.
    QUOTIENT R abs rep ‚áí
    ‚àÄl1 l2 P1 P2.
      (R |==> $<=>) P1 P2 ‚àß LIST_REL R l1 l2 ‚áí (EVERY P1 l1 ‚áî EVERY P2 l2)
</pre>

<DT><span class="strong">EVERY_SIMP</span>
<DD>
<pre>
‚ä¢ ‚àÄc l. EVERY (Œªx. c) l ‚áî l = [] ‚à® c
</pre>

<DT><span class="strong">EVERY_SNOC</span>
<DD>
<pre>
‚ä¢ ‚àÄP x l. EVERY P (SNOC x l) ‚áî EVERY P l ‚àß P x
</pre>

<DT><span class="strong">EXISTS_APPEND</span>
<DD>
<pre>
‚ä¢ ‚àÄP l1 l2. EXISTS P (l1 ++ l2) ‚áî EXISTS P l1 ‚à® EXISTS P l2
</pre>

<DT><span class="strong">EXISTS_CONG</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2 P P'.
    l1 = l2 ‚àß (‚àÄx. MEM x l2 ‚áí (P x ‚áî P' x)) ‚áí (EXISTS P l1 ‚áî EXISTS P' l2)
</pre>

<DT><span class="strong">EXISTS_FIRST</span>
<DD>
<pre>
‚ä¢ ‚àÄP l. EXISTS P l ‚áî ‚àÉi. i < LENGTH l ‚àß P (EL i l) ‚àß ‚àÄj. j < i ‚áí ¬¨P (EL j l)
</pre>

<DT><span class="strong">EXISTS_GENLIST</span>
<DD>
<pre>
‚ä¢ ‚àÄn. EXISTS P (GENLIST f n) ‚áî ‚àÉi. i < n ‚àß P (f i)
</pre>

<DT><span class="strong">EXISTS_LIST</span>
<DD>
<pre>
‚ä¢ (‚àÉl. P l) ‚áî P [] ‚à® ‚àÉh t. P (h::t)
</pre>

<DT><span class="strong">EXISTS_LIST_EQ_MAP</span>
<DD>
<pre>
‚ä¢ ‚àÄls f. EVERY (Œªx. ‚àÉy. x = f y) ls ‚áí ‚àÉl. ls = MAP f l
</pre>

<DT><span class="strong">EXISTS_MAP</span>
<DD>
<pre>
‚ä¢ ‚àÄP f l. EXISTS P (MAP f l) ‚áî EXISTS (Œªx. P (f x)) l
</pre>

<DT><span class="strong">EXISTS_MEM</span>
<DD>
<pre>
‚ä¢ ‚àÄP l. EXISTS P l ‚áî ‚àÉe. MEM e l ‚àß P e
</pre>

<DT><span class="strong">EXISTS_NOT_EVERY</span>
<DD>
<pre>
‚ä¢ ‚àÄP l. EXISTS P l ‚áî ¬¨EVERY (Œªx. ¬¨P x) l
</pre>

<DT><span class="strong">EXISTS_SNOC</span>
<DD>
<pre>
‚ä¢ ‚àÄP x l. EXISTS P (SNOC x l) ‚áî P x ‚à® EXISTS P l
</pre>

<DT><span class="strong">FILTER_ALL_DISTINCT</span>
<DD>
<pre>
‚ä¢ ‚àÄP l. ALL_DISTINCT l ‚áí ALL_DISTINCT (FILTER P l)
</pre>

<DT><span class="strong">FILTER_APPEND_DISTRIB</span>
<DD>
<pre>
‚ä¢ ‚àÄP L M. FILTER P (L ++ M) = FILTER P L ++ FILTER P M
</pre>

<DT><span class="strong">FILTER_COND_REWRITE</span>
<DD>
<pre>
‚ä¢ FILTER P [] = [] ‚àß (‚àÄh. P h ‚áí FILTER P (h::l) = h::FILTER P l) ‚àß
  ‚àÄh. ¬¨P h ‚áí FILTER P (h::l) = FILTER P l
</pre>

<DT><span class="strong">FILTER_EQ_APPEND</span>
<DD>
<pre>
‚ä¢ ‚àÄP l l1 l2.
    FILTER P l = l1 ++ l2 ‚áî
    ‚àÉl3 l4. l = l3 ++ l4 ‚àß FILTER P l3 = l1 ‚àß FILTER P l4 = l2
</pre>

<DT><span class="strong">FILTER_EQ_CONS</span>
<DD>
<pre>
‚ä¢ ‚àÄP l h lr.
    FILTER P l = h::lr ‚áî
    ‚àÉl1 l2. l = l1 ++ [h] ++ l2 ‚àß FILTER P l1 = [] ‚àß FILTER P l2 = lr ‚àß P h
</pre>

<DT><span class="strong">FILTER_EQ_ID</span>
<DD>
<pre>
‚ä¢ ‚àÄP l. FILTER P l = l ‚áî EVERY P l
</pre>

<DT><span class="strong">FILTER_EQ_NIL</span>
<DD>
<pre>
‚ä¢ ‚àÄP l. FILTER P l = [] ‚áî EVERY (Œªx. ¬¨P x) l
</pre>

<DT><span class="strong">FILTER_F</span>
<DD>
<pre>
‚ä¢ ‚àÄxs. FILTER (Œªx. F) xs = []
</pre>

<DT><span class="strong">FILTER_NEQ_ID</span>
<DD>
<pre>
‚ä¢ ‚àÄP l. FILTER P l ‚â† l ‚áî ‚àÉx. MEM x l ‚àß ¬¨P x
</pre>

<DT><span class="strong">FILTER_NEQ_NIL</span>
<DD>
<pre>
‚ä¢ ‚àÄP l. FILTER P l ‚â† [] ‚áî ‚àÉx. MEM x l ‚àß P x
</pre>

<DT><span class="strong">FILTER_REVERSE</span>
<DD>
<pre>
‚ä¢ ‚àÄl P. FILTER P (REVERSE l) = REVERSE (FILTER P l)
</pre>

<DT><span class="strong">FILTER_T</span>
<DD>
<pre>
‚ä¢ ‚àÄxs. FILTER (Œªx. T) xs = xs
</pre>

<DT><span class="strong">FIND_thm</span>
<DD>
<pre>
‚ä¢ FIND P [] = NONE ‚àß FIND P (h::t) = if P h then SOME h else FIND P t
</pre>

<DT><span class="strong">FINITE_ALL_DISTINCT_LISTS</span>
<DD>
<pre>
‚ä¢ ‚àÄs. FINITE s ‚áí FINITE {l | LIST_TO_SET l ‚äÜ s ‚àß ALL_DISTINCT l}
</pre>

<DT><span class="strong">FINITE_BOUNDED_LISTS</span>
<DD>
<pre>
‚ä¢ ‚àÄs n. FINITE s ‚áí FINITE {l | LIST_TO_SET l ‚äÜ s ‚àß LENGTH l ‚â§ n}
</pre>

<DT><span class="strong">FINITE_LIST_TO_SET</span>
<DD>
<pre>
‚ä¢ ‚àÄl. FINITE (LIST_TO_SET l)
</pre>

<DT><span class="strong">FLAT_APPEND</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2. FLAT (l1 ++ l2) = FLAT l1 ++ FLAT l2
</pre>

<DT><span class="strong">FLAT_EQ_APPEND</span>
<DD>
<pre>
‚ä¢ FLAT l = x ++ y ‚áî
  (‚àÉp s. l = p ++ s ‚àß x = FLAT p ‚àß y = FLAT s) ‚à®
  ‚àÉp s ip is.
    l = p ++ [ip ++ is] ++ s ‚àß ip ‚â† [] ‚àß is ‚â† [] ‚àß x = FLAT p ++ ip ‚àß
    y = is ++ FLAT s
</pre>

<DT><span class="strong">FLAT_EQ_NIL</span>
<DD>
<pre>
‚ä¢ ‚àÄls. FLAT ls = [] ‚áî EVERY ($= []) ls
</pre>

<DT><span class="strong">FLAT_EQ_NIL'</span>
<DD>
<pre>
‚ä¢ FLAT l = [] ‚áî ‚àÄe. MEM e l ‚áí e = []
</pre>

<DT><span class="strong">FLAT_EQ_SING</span>
<DD>
<pre>
‚ä¢ FLAT l = [x] ‚áî ‚àÉp s. l = p ++ [[x]] ++ s ‚àß FLAT p = [] ‚àß FLAT s = []
</pre>

<DT><span class="strong">FLAT_MAP_K_NIL</span>
<DD>
<pre>
‚ä¢ ‚àÄls. FLAT (MAP (K []) ls) = []
</pre>

<DT><span class="strong">FLAT_compute</span>
<DD>
<pre>
‚ä¢ FLAT [] = [] ‚àß FLAT ([]::t) = FLAT t ‚àß FLAT ((h::t1)::t2) = h::FLAT (t1::t2)
</pre>

<DT><span class="strong">FOLDL2_FOLDL</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2.
    LENGTH l1 = LENGTH l2 ‚áí
    ‚àÄf a. FOLDL2 f a l1 l2 = FOLDL (Œªa. (f a)·¥æ) a (ZIP (l1,l2))
</pre>

<DT><span class="strong">FOLDL2_cong</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l1' l2 l2' a a' f f'.
    l1 = l1' ‚àß l2 = l2' ‚àß a = a' ‚àß
    (‚àÄz b c. MEM b l1' ‚àß MEM c l2' ‚áí f z b c = f' z b c) ‚áí
    FOLDL2 f a l1 l2 = FOLDL2 f' a' l1' l2'
</pre>

<DT><span class="strong">FOLDL2_def</span>
<DD>
<pre>
‚ä¢ (‚àÄf cs c bs b a. FOLDL2 f a (b::bs) (c::cs) = FOLDL2 f (f a b c) bs cs) ‚àß
  (‚àÄf cs a. FOLDL2 f a [] cs = a) ‚àß ‚àÄv7 v6 f a. FOLDL2 f a (v6::v7) [] = a
</pre>

<DT><span class="strong">FOLDL2_ind</span>
<DD>
<pre>
‚ä¢ ‚àÄP. (‚àÄf a b bs c cs. P f (f a b c) bs cs ‚áí P f a (b::bs) (c::cs)) ‚àß
      (‚àÄf a cs. P f a [] cs) ‚àß (‚àÄf a v6 v7. P f a (v6::v7) []) ‚áí
      ‚àÄv v1 v2 v3. P v v1 v2 v3
</pre>

<DT><span class="strong">FOLDL_CONG</span>
<DD>
<pre>
‚ä¢ ‚àÄl l' b b' f f'.
    l = l' ‚àß b = b' ‚àß (‚àÄx a. MEM x l' ‚áí f a x = f' a x) ‚áí
    FOLDL f b l = FOLDL f' b' l'
</pre>

<DT><span class="strong">FOLDL_EQ_FOLDR</span>
<DD>
<pre>
‚ä¢ ‚àÄf l e. ASSOC f ‚àß COMM f ‚áí FOLDL f e l = FOLDR f e l
</pre>

<DT><span class="strong">FOLDL_SNOC</span>
<DD>
<pre>
‚ä¢ ‚àÄf e x l. FOLDL f e (SNOC x l) = f (FOLDL f e l) x
</pre>

<DT><span class="strong">FOLDL_UNION_BIGUNION</span>
<DD>
<pre>
‚ä¢ ‚àÄf ls s.
    FOLDL (Œªs x. s ‚à™ f x) s ls = s ‚à™ BIGUNION (IMAGE f (LIST_TO_SET ls))
</pre>

<DT><span class="strong">FOLDL_UNION_BIGUNION_paired</span>
<DD>
<pre>
‚ä¢ ‚àÄf ls s.
    FOLDL (Œªs (x,y). s ‚à™ f x y) s ls =
    s ‚à™ BIGUNION (IMAGE f·¥æ (LIST_TO_SET ls))
</pre>

<DT><span class="strong">FOLDL_ZIP_SAME</span>
<DD>
<pre>
‚ä¢ ‚àÄls f e. FOLDL f e (ZIP (ls,ls)) = FOLDL (Œªx y. f x (y,y)) e ls
</pre>

<DT><span class="strong">FOLDR_CONG</span>
<DD>
<pre>
‚ä¢ ‚àÄl l' b b' f f'.
    l = l' ‚àß b = b' ‚àß (‚àÄx a. MEM x l' ‚áí f x a = f' x a) ‚áí
    FOLDR f b l = FOLDR f' b' l'
</pre>

<DT><span class="strong">FOLDR_CONS</span>
<DD>
<pre>
‚ä¢ ‚àÄf ls a. FOLDR (Œªx y. f x::y) a ls = MAP f ls ++ a
</pre>

<DT><span class="strong">FORALL_LIST</span>
<DD>
<pre>
‚ä¢ (‚àÄl. P l) ‚áî P [] ‚àß ‚àÄh t. P (h::t)
</pre>

<DT><span class="strong">FRONT_CONS</span>
<DD>
<pre>
‚ä¢ (‚àÄx. FRONT [x] = []) ‚àß ‚àÄx y z. FRONT (x::y::z) = x::FRONT (y::z)
</pre>

<DT><span class="strong">FRONT_CONS_EQ_NIL</span>
<DD>
<pre>
‚ä¢ (‚àÄx xs. FRONT (x::xs) = [] ‚áî xs = []) ‚àß
  (‚àÄx xs. [] = FRONT (x::xs) ‚áî xs = []) ‚àß
  ‚àÄx xs. NULL (FRONT (x::xs)) ‚áî NULL xs
</pre>

<DT><span class="strong">FRONT_SNOC</span>
<DD>
<pre>
‚ä¢ ‚àÄx l. FRONT (SNOC x l) = l
</pre>

<DT><span class="strong">FRONT_TAKE</span>
<DD>
<pre>
‚ä¢ ‚àÄl n. 0 < n ‚àß n ‚â§ LENGTH l ‚áí FRONT (TAKE n l) = TAKE (n ‚àí 1) l
</pre>

<DT><span class="strong">GENLIST_0</span>
<DD>
<pre>
‚ä¢ ‚àÄf. GENLIST f 0 = []
</pre>

<DT><span class="strong">GENLIST_1</span>
<DD>
<pre>
‚ä¢ ‚àÄf. GENLIST f 1 = [f 0]
</pre>

<DT><span class="strong">GENLIST_APPEND</span>
<DD>
<pre>
‚ä¢ ‚àÄf a b. GENLIST f (a + b) = GENLIST f b ++ GENLIST (Œªt. f (t + b)) a
</pre>

<DT><span class="strong">GENLIST_AUX_compute</span>
<DD>
<pre>
‚ä¢ (‚àÄf l. GENLIST_AUX f 0 l = l) ‚àß
  (‚àÄf n l.
     GENLIST_AUX f <..num comp'n..> l =
     GENLIST_AUX f (<..num comp'n..> ‚àí 1) (f (<..num comp'n..> ‚àí 1)::l)) ‚àß
  ‚àÄf n l.
    GENLIST_AUX f <..num comp'n..> l =
    GENLIST_AUX f <..num comp'n..> (f <..num comp'n..> ::l)
</pre>

<DT><span class="strong">GENLIST_CONG</span>
<DD>
<pre>
‚ä¢ ‚àÄn1 n2 f1 f2.
    n1 = n2 ‚àß (‚àÄm. m < n2 ‚áí f1 m = f2 m) ‚áí GENLIST f1 n1 = GENLIST f2 n2
</pre>

<DT><span class="strong">GENLIST_CONS</span>
<DD>
<pre>
‚ä¢ GENLIST f (SUC n) = f 0::GENLIST (f ‚àò SUC) n
</pre>

<DT><span class="strong">GENLIST_CONSTANT</span>
<DD>
<pre>
‚ä¢ ‚àÄf n c. (‚àÄk. k < n ‚áí f k = c) ‚áî EVERY (Œªx. x = c) (GENLIST f n)
</pre>

<DT><span class="strong">GENLIST_EL</span>
<DD>
<pre>
‚ä¢ ‚àÄls f n. n = LENGTH ls ‚àß (‚àÄi. i < n ‚áí f i = EL i ls) ‚áí GENLIST f n = ls
</pre>

<DT><span class="strong">GENLIST_EL_MAP</span>
<DD>
<pre>
‚ä¢ ‚àÄf ls. GENLIST (Œªn. f (EL n ls)) (LENGTH ls) = MAP f ls
</pre>

<DT><span class="strong">GENLIST_EQ</span>
<DD>
<pre>
‚ä¢ ‚àÄf1 f2 n n1 n2 f1 f2.
    n1 = n2 ‚àß (‚àÄm. m < n2 ‚áí f1 m = f2 m) ‚áí GENLIST f1 n1 = GENLIST f2 n2
</pre>

<DT><span class="strong">GENLIST_EQ_NIL</span>
<DD>
<pre>
‚ä¢ ‚àÄf n. GENLIST f n = [] ‚áî n = 0
</pre>

<DT><span class="strong">GENLIST_FUN_EQ</span>
<DD>
<pre>
‚ä¢ ‚àÄn f g. GENLIST f n = GENLIST g n ‚áî ‚àÄx. x < n ‚áí f x = g x
</pre>

<DT><span class="strong">GENLIST_GENLIST_AUX</span>
<DD>
<pre>
‚ä¢ ‚àÄn. GENLIST f n = GENLIST_AUX f n []
</pre>

<DT><span class="strong">GENLIST_ID</span>
<DD>
<pre>
‚ä¢ ‚àÄx. GENLIST (Œªi. EL i x) (LENGTH x) = x
</pre>

<DT><span class="strong">GENLIST_LAST</span>
<DD>
<pre>
‚ä¢ ‚àÄf n. LAST (GENLIST f (SUC n)) = f n
</pre>

<DT><span class="strong">GENLIST_NUMERALS</span>
<DD>
<pre>
‚ä¢ GENLIST f 0 = [] ‚àß
  GENLIST f <..num comp'n..> = GENLIST_AUX f <..num comp'n..> []
</pre>

<DT><span class="strong">GENLIST_PLUS_APPEND</span>
<DD>
<pre>
‚ä¢ GENLIST ($+ a) n1 ++ GENLIST ($+ (n1 + a)) n2 = GENLIST ($+ a) (n1 + n2)
</pre>

<DT><span class="strong">GENLIST_compute</span>
<DD>
<pre>
‚ä¢ (‚àÄf. GENLIST f 0 = []) ‚àß
  (‚àÄf n.
     GENLIST f <..num comp'n..> =
     SNOC (f (<..num comp'n..> ‚àí 1)) (GENLIST f (<..num comp'n..> ‚àí 1))) ‚àß
  ‚àÄf n.
    GENLIST f <..num comp'n..> =
    SNOC (f <..num comp'n..> ) (GENLIST f <..num comp'n..> )
</pre>

<DT><span class="strong">HD_DROP</span>
<DD>
<pre>
‚ä¢ ‚àÄn l. n < LENGTH l ‚áí HD (DROP n l) = EL n l
</pre>

<DT><span class="strong">HD_GENLIST</span>
<DD>
<pre>
‚ä¢ HD (GENLIST f (SUC n)) = f 0
</pre>

<DT><span class="strong">HD_GENLIST_COR</span>
<DD>
<pre>
‚ä¢ ‚àÄn f. 0 < n ‚áí HD (GENLIST f n) = f 0
</pre>

<DT><span class="strong">HD_REVERSE</span>
<DD>
<pre>
‚ä¢ ‚àÄx. x ‚â† [] ‚áí HD (REVERSE x) = LAST x
</pre>

<DT><span class="strong">HD_TAKE</span>
<DD>
<pre>
‚ä¢ ‚àÄn l. 0 < n ‚áí HD (TAKE n l) = HD l
</pre>

<DT><span class="strong">HD_dropWhile</span>
<DD>
<pre>
‚ä¢ ‚àÄP ls. EXISTS ($¬¨ ‚àò P) ls ‚áí ¬¨P (HD (dropWhile P ls))
</pre>

<DT><span class="strong">IMAGE_EL_count_LENGTH</span>
<DD>
<pre>
‚ä¢ ‚àÄf ls.
    IMAGE (Œªn. f (EL n ls)) (count (LENGTH ls)) = IMAGE f (LIST_TO_SET ls)
</pre>

<DT><span class="strong">IMP_EVERY_LUPDATE</span>
<DD>
<pre>
‚ä¢ ‚àÄxs h i. P h ‚àß EVERY P xs ‚áí EVERY P (LUPDATE h i xs)
</pre>

<DT><span class="strong">INDEX_FIND_add</span>
<DD>
<pre>
‚ä¢ ‚àÄls n.
    INDEX_FIND n P ls = OPTION_MAP (Œª(i,x). (i + n,x)) (INDEX_FIND 0 P ls)
</pre>

<DT><span class="strong">INDEX_OF_eq_NONE</span>
<DD>
<pre>
‚ä¢ ‚àÄx l. INDEX_OF x l = NONE ‚áî ¬¨MEM x l
</pre>

<DT><span class="strong">INDEX_OF_eq_SOME</span>
<DD>
<pre>
‚ä¢ ‚àÄx l i.
    INDEX_OF x l = SOME i ‚áî i < LENGTH l ‚àß EL i l = x ‚àß ‚àÄj. j < i ‚áí EL j l ‚â† x
</pre>

<DT><span class="strong">INFINITE_LIST_UNIV</span>
<DD>
<pre>
‚ä¢ INFINITE ùïå(:Œ± list)
</pre>

<DT><span class="strong">INJ_MAP_EQ</span>
<DD>
<pre>
‚ä¢ ‚àÄf l1 l2.
    INJ f (LIST_TO_SET l1 ‚à™ LIST_TO_SET l2) ùïå(:Œ≤) ‚àß MAP f l1 = MAP f l2 ‚áí
    l1 = l2
</pre>

<DT><span class="strong">INJ_MAP_EQ_IFF</span>
<DD>
<pre>
‚ä¢ ‚àÄf l1 l2.
    INJ f (LIST_TO_SET l1 ‚à™ LIST_TO_SET l2) ùïå(:Œ≤) ‚áí
    (MAP f l1 = MAP f l2 ‚áî l1 = l2)
</pre>

<DT><span class="strong">IS_SOME_OPT_MMAP</span>
<DD>
<pre>
‚ä¢ IS_SOME (OPT_MMAP f ls) ‚áî EVERY IS_SOME (MAP f ls)
</pre>

<DT><span class="strong">ITSET_eq_FOLDL_SET_TO_LIST</span>
<DD>
<pre>
‚ä¢ ‚àÄs. FINITE s ‚áí ‚àÄf a. ITSET f s a = FOLDL (flip f) a (SET_TO_LIST s)
</pre>

<DT><span class="strong">LAST_APPEND_CONS</span>
<DD>
<pre>
‚ä¢ ‚àÄh l1 l2. LAST (l1 ++ h::l2) = LAST (h::l2)
</pre>

<DT><span class="strong">LAST_CONS</span>
<DD>
<pre>
‚ä¢ (‚àÄx. LAST [x] = x) ‚àß ‚àÄx y z. LAST (x::y::z) = LAST (y::z)
</pre>

<DT><span class="strong">LAST_CONS_cond</span>
<DD>
<pre>
‚ä¢ LAST (h::t) = if t = [] then h else LAST t
</pre>

<DT><span class="strong">LAST_EL</span>
<DD>
<pre>
‚ä¢ ‚àÄls. ls ‚â† [] ‚áí LAST ls = EL (PRE (LENGTH ls)) ls
</pre>

<DT><span class="strong">LAST_MAP</span>
<DD>
<pre>
‚ä¢ ‚àÄl f. l ‚â† [] ‚áí LAST (MAP f l) = f (LAST l)
</pre>

<DT><span class="strong">LAST_REVERSE</span>
<DD>
<pre>
‚ä¢ ‚àÄls. ls ‚â† [] ‚áí LAST (REVERSE ls) = HD ls
</pre>

<DT><span class="strong">LAST_SNOC</span>
<DD>
<pre>
‚ä¢ ‚àÄx l. LAST (SNOC x l) = x
</pre>

<DT><span class="strong">LAST_compute</span>
<DD>
<pre>
‚ä¢ (‚àÄx. LAST [x] = x) ‚àß ‚àÄh1 h2 t. LAST (h1::h2::t) = LAST (h2::t)
</pre>

<DT><span class="strong">LENGTH1</span>
<DD>
<pre>
‚ä¢ 1 = LENGTH l ‚áî ‚àÉe. l = [e]
</pre>

<DT><span class="strong">LENGTH2</span>
<DD>
<pre>
‚ä¢ 2 = LENGTH l ‚áî ‚àÉa b. l = [a; b]
</pre>

<DT><span class="strong">LENGTH_APPEND</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2. LENGTH (l1 ++ l2) = LENGTH l1 + LENGTH l2
</pre>

<DT><span class="strong">LENGTH_CONS</span>
<DD>
<pre>
‚ä¢ ‚àÄl n. LENGTH l = SUC n ‚áî ‚àÉh l'. LENGTH l' = n ‚àß l = h::l'
</pre>

<DT><span class="strong">LENGTH_DROP</span>
<DD>
<pre>
‚ä¢ ‚àÄn l. LENGTH (DROP n l) = LENGTH l ‚àí n
</pre>

<DT><span class="strong">LENGTH_EQ_0</span>
<DD>
<pre>
‚ä¢ ‚àÄl. LENGTH l = 0 ‚áî l = []
</pre>

<DT><span class="strong">LENGTH_EQ_1</span>
<DD>
<pre>
‚ä¢ ‚àÄl. LENGTH l = 1 ‚áî ‚àÉx. l = [x]
</pre>

<DT><span class="strong">LENGTH_EQ_CONS</span>
<DD>
<pre>
‚ä¢ ‚àÄP n. (‚àÄl. LENGTH l = SUC n ‚áí P l) ‚áî ‚àÄl. LENGTH l = n ‚áí (Œªl. ‚àÄx. P (x::l)) l
</pre>

<DT><span class="strong">LENGTH_EQ_NIL</span>
<DD>
<pre>
‚ä¢ ‚àÄP. (‚àÄl. LENGTH l = 0 ‚áí P l) ‚áî P []
</pre>

<DT><span class="strong">LENGTH_EQ_NUM</span>
<DD>
<pre>
‚ä¢ (‚àÄl. LENGTH l = 0 ‚áî l = []) ‚àß
  (‚àÄl n. LENGTH l = SUC n ‚áî ‚àÉh l'. LENGTH l' = n ‚àß l = h::l') ‚àß
  ‚àÄl n1 n2.
    LENGTH l = n1 + n2 ‚áî
    ‚àÉl1 l2. LENGTH l1 = n1 ‚àß LENGTH l2 = n2 ‚àß l = l1 ++ l2
</pre>

<DT><span class="strong">LENGTH_EQ_NUM_compute</span>
<DD>
<pre>
‚ä¢ (‚àÄl. LENGTH l = 0 ‚áî l = []) ‚àß
  (‚àÄl n.
     LENGTH l = <..num comp'n..> ‚áî
     ‚àÉh l'. LENGTH l' = <..num comp'n..> ‚àí 1 ‚àß l = h::l') ‚àß
  (‚àÄl n.
     LENGTH l = <..num comp'n..> ‚áî
     ‚àÉh l'. LENGTH l' = <..num comp'n..> ‚àß l = h::l') ‚àß
  ‚àÄl n1 n2.
    LENGTH l = n1 + n2 ‚áî
    ‚àÉl1 l2. LENGTH l1 = n1 ‚àß LENGTH l2 = n2 ‚àß l = l1 ++ l2
</pre>

<DT><span class="strong">LENGTH_EQ_SUM</span>
<DD>
<pre>
‚ä¢ ‚àÄl n1 n2.
    LENGTH l = n1 + n2 ‚áî
    ‚àÉl1 l2. LENGTH l1 = n1 ‚àß LENGTH l2 = n2 ‚àß l = l1 ++ l2
</pre>

<DT><span class="strong">LENGTH_FILTER_LEQ_MONO</span>
<DD>
<pre>
‚ä¢ ‚àÄP Q. (‚àÄx. P x ‚áí Q x) ‚áí ‚àÄls. LENGTH (FILTER P ls) ‚â§ LENGTH (FILTER Q ls)
</pre>

<DT><span class="strong">LENGTH_FRONT_CONS</span>
<DD>
<pre>
‚ä¢ ‚àÄx xs. LENGTH (FRONT (x::xs)) = LENGTH xs
</pre>

<DT><span class="strong">LENGTH_GENLIST</span>
<DD>
<pre>
‚ä¢ ‚àÄf n. LENGTH (GENLIST f n) = n
</pre>

<DT><span class="strong">LENGTH_LEN</span>
<DD>
<pre>
‚ä¢ ‚àÄL. LENGTH L = LEN L 0
</pre>

<DT><span class="strong">LENGTH_LT_SHORTLEX</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2. LENGTH l1 < LENGTH l2 ‚áí SHORTLEX R l1 l2
</pre>

<DT><span class="strong">LENGTH_LUPDATE</span>
<DD>
<pre>
‚ä¢ ‚àÄx n ys. LENGTH (LUPDATE x n ys) = LENGTH ys
</pre>

<DT><span class="strong">LENGTH_MAP</span>
<DD>
<pre>
‚ä¢ ‚àÄl f. LENGTH (MAP f l) = LENGTH l
</pre>

<DT><span class="strong">LENGTH_MAP2</span>
<DD>
<pre>
‚ä¢ ‚àÄxs ys. LENGTH (MAP2 f xs ys) = MIN (LENGTH xs) (LENGTH ys)
</pre>

<DT><span class="strong">LENGTH_NIL</span>
<DD>
<pre>
‚ä¢ ‚àÄl. LENGTH l = 0 ‚áî l = []
</pre>

<DT><span class="strong">LENGTH_NIL_SYM</span>
<DD>
<pre>
‚ä¢ 0 = LENGTH l ‚áî l = []
</pre>

<DT><span class="strong">LENGTH_NON_NIL</span>
<DD>
<pre>
‚ä¢ ‚àÄl. 0 < LENGTH l ‚áî l ‚â† []
</pre>

<DT><span class="strong">LENGTH_REVERSE</span>
<DD>
<pre>
‚ä¢ ‚àÄl. LENGTH (REVERSE l) = LENGTH l
</pre>

<DT><span class="strong">LENGTH_SNOC</span>
<DD>
<pre>
‚ä¢ ‚àÄx l. LENGTH (SNOC x l) = SUC (LENGTH l)
</pre>

<DT><span class="strong">LENGTH_TAKE</span>
<DD>
<pre>
‚ä¢ ‚àÄn l. n ‚â§ LENGTH l ‚áí LENGTH (TAKE n l) = n
</pre>

<DT><span class="strong">LENGTH_TAKE_EQ</span>
<DD>
<pre>
‚ä¢ LENGTH (TAKE n xs) = if n ‚â§ LENGTH xs then n else LENGTH xs
</pre>

<DT><span class="strong">LENGTH_TL</span>
<DD>
<pre>
‚ä¢ ‚àÄl. 0 < LENGTH l ‚áí LENGTH (TL l) = LENGTH l ‚àí 1
</pre>

<DT><span class="strong">LENGTH_TL_LE</span>
<DD>
<pre>
‚ä¢ ‚àÄls. LENGTH (TL ls) ‚â§ LENGTH ls
</pre>

<DT><span class="strong">LENGTH_UNZIP</span>
<DD>
<pre>
‚ä¢ ‚àÄpl.
    LENGTH (FST (UNZIP pl)) = LENGTH pl ‚àß LENGTH (SND (UNZIP pl)) = LENGTH pl
</pre>

<DT><span class="strong">LENGTH_ZIP</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2.
    LENGTH l1 = LENGTH l2 ‚áí
    LENGTH (ZIP (l1,l2)) = LENGTH l1 ‚àß LENGTH (ZIP (l1,l2)) = LENGTH l2
</pre>

<DT><span class="strong">LENGTH_ZIP_MIN</span>
<DD>
<pre>
‚ä¢ ‚àÄxs ys. LENGTH (ZIP (xs,ys)) = MIN (LENGTH xs) (LENGTH ys)
</pre>

<DT><span class="strong">LENGTH_dropWhile_LESS_EQ</span>
<DD>
<pre>
‚ä¢ ‚àÄP ls. LENGTH (dropWhile P ls) ‚â§ LENGTH ls
</pre>

<DT><span class="strong">LENGTH_mapPartial</span>
<DD>
<pre>
‚ä¢ LENGTH (mapPartial f xs) ‚â§ LENGTH xs
</pre>

<DT><span class="strong">LENGTH_o_REVERSE</span>
<DD>
<pre>
‚ä¢ LENGTH ‚àò REVERSE = LENGTH ‚àß LENGTH ‚àò REVERSE ‚àò f = LENGTH ‚àò f
</pre>

<DT><span class="strong">LEN_LENGTH_LEM</span>
<DD>
<pre>
‚ä¢ ‚àÄL n. LEN L n = LENGTH L + n
</pre>

<DT><span class="strong">LIST_APPLY_o</span>
<DD>
<pre>
‚ä¢ [$o] <*> fs <*> gs <*> xs = fs <*> (gs <*> xs)
</pre>

<DT><span class="strong">LIST_BIND_APPEND</span>
<DD>
<pre>
‚ä¢ LIST_BIND (l1 ++ l2) f = LIST_BIND l1 f ++ LIST_BIND l2 f
</pre>

<DT><span class="strong">LIST_BIND_ID</span>
<DD>
<pre>
‚ä¢ LIST_BIND l (Œªx. x) = FLAT l ‚àß LIST_BIND l I = FLAT l
</pre>

<DT><span class="strong">LIST_BIND_LIST_BIND</span>
<DD>
<pre>
‚ä¢ LIST_BIND (LIST_BIND l g) f = LIST_BIND l (flip LIST_BIND f ‚àò g)
</pre>

<DT><span class="strong">LIST_BIND_MAP</span>
<DD>
<pre>
‚ä¢ LIST_BIND (MAP f l) g = LIST_BIND l (g ‚àò f)
</pre>

<DT><span class="strong">LIST_BIND_THM</span>
<DD>
<pre>
‚ä¢ LIST_BIND [] f = [] ‚àß LIST_BIND (h::t) f = f h ++ LIST_BIND t f
</pre>

<DT><span class="strong">LIST_EQ</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2.
    LENGTH l1 = LENGTH l2 ‚àß (‚àÄx. x < LENGTH l1 ‚áí EL x l1 = EL x l2) ‚áí l1 = l2
</pre>

<DT><span class="strong">LIST_EQUIV</span>
<DD>
<pre>
‚ä¢ ‚àÄR. EQUIV R ‚áí EQUIV (LIST_REL R)
</pre>

<DT><span class="strong">LIST_EQ_MAP_PAIR</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2. MAP FST l1 = MAP FST l2 ‚àß MAP SND l1 = MAP SND l2 ‚áí l1 = l2
</pre>

<DT><span class="strong">LIST_EQ_REWRITE</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2.
    l1 = l2 ‚áî LENGTH l1 = LENGTH l2 ‚àß ‚àÄx. x < LENGTH l1 ‚áí EL x l1 = EL x l2
</pre>

<DT><span class="strong">LIST_EXISTS_MONO</span>
<DD>
<pre>
‚ä¢ (‚àÄx. P x ‚áí Q x) ‚áí EXISTS P l ‚áí EXISTS Q l
</pre>

<DT><span class="strong">LIST_EXISTS_SIMP</span>
<DD>
<pre>
‚ä¢ ‚àÄc l. EXISTS (Œªx. c) l ‚áî l ‚â† [] ‚àß c
</pre>

<DT><span class="strong">LIST_NOT_EQ</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2. l1 ‚â† l2 ‚áí ‚àÄh1 h2. h1::l1 ‚â† h2::l2
</pre>

<DT><span class="strong">LIST_NOT_NIL</span>
<DD>
<pre>
‚ä¢ ‚àÄls. ls ‚â† [] ‚áî ls = HD ls::TL ls
</pre>

<DT><span class="strong">LIST_QUOTIENT</span>
<DD>
<pre>
‚ä¢ ‚àÄR abs rep. QUOTIENT R abs rep ‚áí QUOTIENT (LIST_REL R) (MAP abs) (MAP rep)
</pre>

<DT><span class="strong">LIST_REL_APPEND</span>
<DD>
<pre>
‚ä¢ LIST_REL R l1 l2 ‚àß LIST_REL R l3 l4 ‚áî
  LIST_REL R (l1 ++ l3) (l2 ++ l4) ‚àß LENGTH l1 = LENGTH l2 ‚àß
  LENGTH l3 = LENGTH l4
</pre>

<DT><span class="strong">LIST_REL_APPEND_EQ</span>
<DD>
<pre>
‚ä¢ LENGTH x1 = LENGTH x2 ‚áí
  (LIST_REL R (x1 ++ y1) (x2 ++ y2) ‚áî LIST_REL R x1 x2 ‚àß LIST_REL R y1 y2)
</pre>

<DT><span class="strong">LIST_REL_APPEND_IMP</span>
<DD>
<pre>
‚ä¢ ‚àÄxs ys xs1 ys1.
    LIST_REL P (xs ++ xs1) (ys ++ ys1) ‚àß LENGTH xs = LENGTH ys ‚áí
    LIST_REL P xs ys ‚àß LIST_REL P xs1 ys1
</pre>

<DT><span class="strong">LIST_REL_APPEND_suff</span>
<DD>
<pre>
‚ä¢ LIST_REL R l1 l2 ‚àß LIST_REL R l3 l4 ‚áí LIST_REL R (l1 ++ l3) (l2 ++ l4)
</pre>

<DT><span class="strong">LIST_REL_CONJ</span>
<DD>
<pre>
‚ä¢ LIST_REL (Œªa b. P a b ‚àß Q a b) l1 l2 ‚áî
  LIST_REL (Œªa b. P a b) l1 l2 ‚àß LIST_REL (Œªa b. Q a b) l1 l2
</pre>

<DT><span class="strong">LIST_REL_CONS1</span>
<DD>
<pre>
‚ä¢ LIST_REL R (h::t) xs ‚áî ‚àÉh' t'. xs = h'::t' ‚àß R h h' ‚àß LIST_REL R t t'
</pre>

<DT><span class="strong">LIST_REL_CONS2</span>
<DD>
<pre>
‚ä¢ LIST_REL R xs (h::t) ‚áî ‚àÉh' t'. xs = h'::t' ‚àß R h' h ‚àß LIST_REL R t' t
</pre>

<DT><span class="strong">LIST_REL_EL_EQN</span>
<DD>
<pre>
‚ä¢ ‚àÄR l1 l2.
    LIST_REL R l1 l2 ‚áî
    LENGTH l1 = LENGTH l2 ‚àß ‚àÄn. n < LENGTH l1 ‚áí R (EL n l1) (EL n l2)
</pre>

<DT><span class="strong">LIST_REL_EVERY_ZIP</span>
<DD>
<pre>
‚ä¢ ‚àÄR l1 l2. LIST_REL R l1 l2 ‚áî LENGTH l1 = LENGTH l2 ‚àß EVERY R·¥æ (ZIP (l1,l2))
</pre>

<DT><span class="strong">LIST_REL_LENGTH</span>
<DD>
<pre>
‚ä¢ ‚àÄx y. LIST_REL R x y ‚áí LENGTH x = LENGTH y
</pre>

<DT><span class="strong">LIST_REL_MAP1</span>
<DD>
<pre>
‚ä¢ LIST_REL R (MAP f l1) l2 ‚áî LIST_REL (R ‚àò f) l1 l2
</pre>

<DT><span class="strong">LIST_REL_MAP2</span>
<DD>
<pre>
‚ä¢ LIST_REL (Œªa b. R a b) l1 (MAP f l2) ‚áî LIST_REL (Œªa b. R a (f b)) l1 l2
</pre>

<DT><span class="strong">LIST_REL_MAP_inv_image</span>
<DD>
<pre>
‚ä¢ LIST_REL R (MAP f l1) (MAP f l2) ‚áî LIST_REL (inv_image R f) l1 l2
</pre>

<DT><span class="strong">LIST_REL_MEM_IMP</span>
<DD>
<pre>
‚ä¢ ‚àÄxs ys P x. LIST_REL P xs ys ‚àß MEM x xs ‚áí ‚àÉy. MEM y ys ‚àß P x y
</pre>

<DT><span class="strong">LIST_REL_MEM_IMP_R</span>
<DD>
<pre>
‚ä¢ ‚àÄxs ys P y. LIST_REL P xs ys ‚àß MEM y ys ‚áí ‚àÉx. MEM x xs ‚àß P x y
</pre>

<DT><span class="strong">LIST_REL_NIL</span>
<DD>
<pre>
‚ä¢ (LIST_REL R [] y ‚áî y = []) ‚àß (LIST_REL R x [] ‚áî x = [])
</pre>

<DT><span class="strong">LIST_REL_O</span>
<DD>
<pre>
‚ä¢ ‚àÄR1 R2. LIST_REL (R1 ‚àò·µ£ R2) = LIST_REL R1 ‚àò·µ£ LIST_REL R2
</pre>

<DT><span class="strong">LIST_REL_SNOC</span>
<DD>
<pre>
‚ä¢ (LIST_REL R (SNOC x xs) yys ‚áî
   ‚àÉy ys. yys = SNOC y ys ‚àß LIST_REL R xs ys ‚àß R x y) ‚àß
  (LIST_REL R xxs (SNOC y ys) ‚áî
   ‚àÉx xs. xxs = SNOC x xs ‚àß LIST_REL R xs ys ‚àß R x y)
</pre>

<DT><span class="strong">LIST_REL_SPLIT1</span>
<DD>
<pre>
‚ä¢ ‚àÄxs1 zs.
    LIST_REL P (xs1 ++ xs2) zs ‚áî
    ‚àÉys1 ys2. zs = ys1 ++ ys2 ‚àß LIST_REL P xs1 ys1 ‚àß LIST_REL P xs2 ys2
</pre>

<DT><span class="strong">LIST_REL_SPLIT2</span>
<DD>
<pre>
‚ä¢ ‚àÄxs1 zs.
    LIST_REL P zs (xs1 ++ xs2) ‚áî
    ‚àÉys1 ys2. zs = ys1 ++ ys2 ‚àß LIST_REL P ys1 xs1 ‚àß LIST_REL P ys2 xs2
</pre>

<DT><span class="strong">LIST_REL_cases</span>
<DD>
<pre>
‚ä¢ ‚àÄR a0 a1.
    LIST_REL R a0 a1 ‚áî
    a0 = [] ‚àß a1 = [] ‚à®
    ‚àÉh1 h2 t1 t2. a0 = h1::t1 ‚àß a1 = h2::t2 ‚àß R h1 h2 ‚àß LIST_REL R t1 t2
</pre>

<DT><span class="strong">LIST_REL_cons_I</span>
<DD>
<pre>
‚ä¢ ‚àÄR h1 h2 t1 t2. R h1 h2 ‚àß LIST_REL R t1 t2 ‚áí LIST_REL R (h1::t1) (h2::t2)
</pre>

<DT><span class="strong">LIST_REL_def</span>
<DD>
<pre>
‚ä¢ (LIST_REL R [] [] ‚áî T) ‚àß (LIST_REL R (a::as) [] ‚áî F) ‚àß
  (LIST_REL R [] (b::bs) ‚áî F) ‚àß
  (LIST_REL R (a::as) (b::bs) ‚áî R a b ‚àß LIST_REL R as bs)
</pre>

<DT><span class="strong">LIST_REL_eq</span>
<DD>
<pre>
‚ä¢ LIST_REL $= = $=
</pre>

<DT><span class="strong">LIST_REL_equivalence</span>
<DD>
<pre>
‚ä¢ ‚àÄR. equivalence R ‚áí equivalence (LIST_REL R)
</pre>

<DT><span class="strong">LIST_REL_ind</span>
<DD>
<pre>
‚ä¢ ‚àÄR LIST_REL'.
    LIST_REL' [] [] ‚àß
    (‚àÄh1 h2 t1 t2. R h1 h2 ‚àß LIST_REL' t1 t2 ‚áí LIST_REL' (h1::t1) (h2::t2)) ‚áí
    ‚àÄa0 a1. LIST_REL R a0 a1 ‚áí LIST_REL' a0 a1
</pre>

<DT><span class="strong">LIST_REL_mono</span>
<DD>
<pre>
‚ä¢ (‚àÄx y. R1 x y ‚áí R2 x y) ‚áí LIST_REL R1 l1 l2 ‚áí LIST_REL R2 l1 l2
</pre>

<DT><span class="strong">LIST_REL_nil_rule</span>
<DD>
<pre>
‚ä¢ ‚àÄR. LIST_REL R [] []
</pre>

<DT><span class="strong">LIST_REL_rules</span>
<DD>
<pre>
‚ä¢ ‚àÄR. LIST_REL R [] [] ‚àß
      ‚àÄh1 h2 t1 t2. R h1 h2 ‚àß LIST_REL R t1 t2 ‚áí LIST_REL R (h1::t1) (h2::t2)
</pre>

<DT><span class="strong">LIST_REL_strongind</span>
<DD>
<pre>
‚ä¢ ‚àÄR LIST_REL'.
    LIST_REL' [] [] ‚àß
    (‚àÄh1 h2 t1 t2.
       R h1 h2 ‚àß LIST_REL R t1 t2 ‚àß LIST_REL' t1 t2 ‚áí
       LIST_REL' (h1::t1) (h2::t2)) ‚áí
    ‚àÄa0 a1. LIST_REL R a0 a1 ‚áí LIST_REL' a0 a1
</pre>

<DT><span class="strong">LIST_REL_trans</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2 l3.
    (‚àÄn. n < LENGTH l1 ‚àß R (EL n l1) (EL n l2) ‚àß R (EL n l2) (EL n l3) ‚áí
         R (EL n l1) (EL n l3)) ‚àß LIST_REL R l1 l2 ‚àß LIST_REL R l2 l3 ‚áí
    LIST_REL R l1 l3
</pre>

<DT><span class="strong">LIST_TO_SET</span>
<DD>
<pre>
‚ä¢ LIST_TO_SET [] = ‚àÖ ‚àß LIST_TO_SET (h::t) = h INSERT LIST_TO_SET t
</pre>

<DT><span class="strong">LIST_TO_SET_APPEND</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2. LIST_TO_SET (l1 ++ l2) = LIST_TO_SET l1 ‚à™ LIST_TO_SET l2
</pre>

<DT><span class="strong">LIST_TO_SET_DROP</span>
<DD>
<pre>
‚ä¢ ‚àÄi l. LIST_TO_SET (DROP i l) ‚äÜ LIST_TO_SET l
</pre>

<DT><span class="strong">LIST_TO_SET_EQ_EMPTY</span>
<DD>
<pre>
‚ä¢ (LIST_TO_SET l = ‚àÖ ‚áî l = []) ‚àß (‚àÖ = LIST_TO_SET l ‚áî l = [])
</pre>

<DT><span class="strong">LIST_TO_SET_FILTER</span>
<DD>
<pre>
‚ä¢ LIST_TO_SET (FILTER P l) = {x | P x} ‚à© LIST_TO_SET l
</pre>

<DT><span class="strong">LIST_TO_SET_FLAT</span>
<DD>
<pre>
‚ä¢ ‚àÄls. LIST_TO_SET (FLAT ls) = BIGUNION (LIST_TO_SET (MAP LIST_TO_SET ls))
</pre>

<DT><span class="strong">LIST_TO_SET_GENLIST</span>
<DD>
<pre>
‚ä¢ ‚àÄf n. LIST_TO_SET (GENLIST f n) = IMAGE f (count n)
</pre>

<DT><span class="strong">LIST_TO_SET_MAP</span>
<DD>
<pre>
‚ä¢ ‚àÄf l. LIST_TO_SET (MAP f l) = IMAGE f (LIST_TO_SET l)
</pre>

<DT><span class="strong">LIST_TO_SET_PRS</span>
<DD>
<pre>
‚ä¢ ‚àÄR abs rep.
    QUOTIENT R abs rep ‚áí
    ‚àÄl. LIST_TO_SET l = IMAGE abs (LIST_TO_SET (MAP rep l))
</pre>

<DT><span class="strong">LIST_TO_SET_REVERSE</span>
<DD>
<pre>
‚ä¢ ‚àÄls. LIST_TO_SET (REVERSE ls) = LIST_TO_SET ls
</pre>

<DT><span class="strong">LIST_TO_SET_RSP</span>
<DD>
<pre>
‚ä¢ ‚àÄR abs rep.
    QUOTIENT R abs rep ‚áí
    ‚àÄl1 l2. LIST_REL R l1 l2 ‚áí SET_REL R (LIST_TO_SET l1) (LIST_TO_SET l2)
</pre>

<DT><span class="strong">LIST_TO_SET_SING</span>
<DD>
<pre>
‚ä¢ ‚àÄvs x. ALL_DISTINCT vs ‚àß LIST_TO_SET vs = {x} ‚áî vs = [x]
</pre>

<DT><span class="strong">LIST_TO_SET_SNOC</span>
<DD>
<pre>
‚ä¢ LIST_TO_SET (SNOC x ls) = x INSERT LIST_TO_SET ls
</pre>

<DT><span class="strong">LIST_TO_SET_TAKE</span>
<DD>
<pre>
‚ä¢ ‚àÄi l. LIST_TO_SET (TAKE i l) ‚äÜ LIST_TO_SET l
</pre>

<DT><span class="strong">LIST_TO_SET_THM</span>
<DD>
<pre>
‚ä¢ LIST_TO_SET [] = ‚àÖ ‚àß LIST_TO_SET (h::t) = h INSERT LIST_TO_SET t
</pre>

<DT><span class="strong">LLEX_CONG</span>
<DD>
<pre>
‚ä¢ ‚àÄR l1 l2 R' l1' l2'.
    l1 = l1' ‚àß l2 = l2' ‚àß (‚àÄa b. MEM a l1' ‚àß MEM b l2' ‚áí (R a b ‚áî R' a b)) ‚áí
    (LLEX R l1 l2 ‚áî LLEX R' l1' l2')
</pre>

<DT><span class="strong">LLEX_EL_THM</span>
<DD>
<pre>
‚ä¢ ‚àÄR l1 l2.
    LLEX R l1 l2 ‚áî
    ‚àÉn. n ‚â§ LENGTH l1 ‚àß n < LENGTH l2 ‚àß TAKE n l1 = TAKE n l2 ‚àß
        (n < LENGTH l1 ‚áí R (EL n l1) (EL n l2))
</pre>

<DT><span class="strong">LLEX_MONO</span>
<DD>
<pre>
‚ä¢ (‚àÄx y. R1 x y ‚áí R2 x y) ‚áí LLEX R1 x y ‚áí LLEX R2 x y
</pre>

<DT><span class="strong">LLEX_NIL2</span>
<DD>
<pre>
‚ä¢ ¬¨LLEX R l []
</pre>

<DT><span class="strong">LLEX_THM</span>
<DD>
<pre>
‚ä¢ (¬¨LLEX R [] [] ‚àß ¬¨LLEX R (h1::t1) []) ‚àß LLEX R [] (h2::t2) ‚àß
  (LLEX R (h1::t1) (h2::t2) ‚áî R h1 h2 ‚à® h1 = h2 ‚àß LLEX R t1 t2)
</pre>

<DT><span class="strong">LLEX_not_WF</span>
<DD>
<pre>
‚ä¢ (‚àÉa b. R a b) ‚áí ¬¨WF (LLEX R)
</pre>

<DT><span class="strong">LLEX_total</span>
<DD>
<pre>
‚ä¢ total (RC R) ‚áí total (RC (LLEX R))
</pre>

<DT><span class="strong">LLEX_transitive</span>
<DD>
<pre>
‚ä¢ transitive R ‚áí transitive (LLEX R)
</pre>

<DT><span class="strong">LRC_MEM</span>
<DD>
<pre>
‚ä¢ LRC R ls x y ‚àß MEM e ls ‚áí ‚àÉz t. R e z ‚àß LRC R t z y
</pre>

<DT><span class="strong">LRC_MEM_right</span>
<DD>
<pre>
‚ä¢ LRC R (h::t) x y ‚àß MEM e t ‚áí ‚àÉz p. R z e ‚àß LRC R p x z
</pre>

<DT><span class="strong">LUPDATE_GENLIST</span>
<DD>
<pre>
‚ä¢ ‚àÄm n e f. LUPDATE e n (GENLIST f m) = GENLIST f‚¶án ‚Ü¶ e‚¶à m
</pre>

<DT><span class="strong">LUPDATE_LENGTH</span>
<DD>
<pre>
‚ä¢ ‚àÄxs x y ys. LUPDATE x (LENGTH xs) (xs ++ y::ys) = xs ++ x::ys
</pre>

<DT><span class="strong">LUPDATE_MAP</span>
<DD>
<pre>
‚ä¢ ‚àÄx n l f. MAP f (LUPDATE x n l) = LUPDATE (f x) n (MAP f l)
</pre>

<DT><span class="strong">LUPDATE_NIL</span>
<DD>
<pre>
‚ä¢ ‚àÄxs n x. LUPDATE x n xs = [] ‚áî xs = []
</pre>

<DT><span class="strong">LUPDATE_SAME</span>
<DD>
<pre>
‚ä¢ ‚àÄn ls. n < LENGTH ls ‚áí LUPDATE (EL n ls) n ls = ls
</pre>

<DT><span class="strong">LUPDATE_SEM</span>
<DD>
<pre>
‚ä¢ (‚àÄe n l. LENGTH (LUPDATE e n l) = LENGTH l) ‚àß
  ‚àÄe n l p. p < LENGTH l ‚áí EL p (LUPDATE e n l) = if p = n then e else EL p l
</pre>

<DT><span class="strong">LUPDATE_SNOC</span>
<DD>
<pre>
‚ä¢ ‚àÄys k x y.
    LUPDATE x k (SNOC y ys) =
    if k = LENGTH ys then SNOC x ys else SNOC y (LUPDATE x k ys)
</pre>

<DT><span class="strong">LUPDATE_SOME_MAP</span>
<DD>
<pre>
‚ä¢ ‚àÄxs n f h.
    LUPDATE (SOME (f h)) n (MAP (OPTION_MAP f) xs) =
    MAP (OPTION_MAP f) (LUPDATE (SOME h) n xs)
</pre>

<DT><span class="strong">LUPDATE_compute</span>
<DD>
<pre>
‚ä¢ (‚àÄe n. LUPDATE e n [] = []) ‚àß (‚àÄe x l. LUPDATE e 0 (x::l) = e::l) ‚àß
  (‚àÄe n x l.
     LUPDATE e <..num comp'n..> (x::l) = x::LUPDATE e (<..num comp'n..> ‚àí 1) l) ‚àß
  ‚àÄe n x l.
    LUPDATE e <..num comp'n..> (x::l) = x::LUPDATE e <..num comp'n..> l
</pre>

<DT><span class="strong">LUPDATE_def</span>
<DD>
<pre>
‚ä¢ (‚àÄe n. LUPDATE e n [] = []) ‚àß (‚àÄe x l. LUPDATE e 0 (x::l) = e::l) ‚àß
  ‚àÄe n x l. LUPDATE e (SUC n) (x::l) = x::LUPDATE e n l
</pre>

<DT><span class="strong">MAP2</span>
<DD>
<pre>
‚ä¢ (‚àÄf. MAP2 f [] [] = []) ‚àß
  ‚àÄf h1 t1 h2 t2. MAP2 f (h1::t1) (h2::t2) = f h1 h2::MAP2 f t1 t2
</pre>

<DT><span class="strong">MAP2_APPEND</span>
<DD>
<pre>
‚ä¢ ‚àÄxs ys xs1 ys1 f.
    LENGTH xs = LENGTH xs1 ‚áí
    MAP2 f (xs ++ ys) (xs1 ++ ys1) = MAP2 f xs xs1 ++ MAP2 f ys ys1
</pre>

<DT><span class="strong">MAP2_CONG</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l1' l2 l2' f f'.
    l1 = l1' ‚àß l2 = l2' ‚àß (‚àÄx y. MEM x l1' ‚àß MEM y l2' ‚áí f x y = f' x y) ‚áí
    MAP2 f l1 l2 = MAP2 f' l1' l2'
</pre>

<DT><span class="strong">MAP2_DEF</span>
<DD>
<pre>
‚ä¢ (‚àÄt2 t1 h2 h1 f. MAP2 f (h1::t1) (h2::t2) = f h1 h2::MAP2 f t1 t2) ‚àß
  (‚àÄy f. MAP2 f [] y = []) ‚àß ‚àÄv5 v4 f. MAP2 f (v4::v5) [] = []
</pre>

<DT><span class="strong">MAP2_IND</span>
<DD>
<pre>
‚ä¢ ‚àÄP. (‚àÄf h1 t1 h2 t2. P f t1 t2 ‚áí P f (h1::t1) (h2::t2)) ‚àß (‚àÄf y. P f [] y) ‚àß
      (‚àÄf v4 v5. P f (v4::v5) []) ‚áí
      ‚àÄv v1 v2. P v v1 v2
</pre>

<DT><span class="strong">MAP2_MAP</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2. LENGTH l1 = LENGTH l2 ‚áí ‚àÄf. MAP2 f l1 l2 = MAP f·¥æ (ZIP (l1,l2))
</pre>

<DT><span class="strong">MAP2_NIL</span>
<DD>
<pre>
‚ä¢ MAP2 f x [] = []
</pre>

<DT><span class="strong">MAP2_ZIP</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2. LENGTH l1 = LENGTH l2 ‚áí ‚àÄf. MAP2 f l1 l2 = MAP f·¥æ (ZIP (l1,l2))
</pre>

<DT><span class="strong">MAP_APPEND</span>
<DD>
<pre>
‚ä¢ ‚àÄf l1 l2. MAP f (l1 ++ l2) = MAP f l1 ++ MAP f l2
</pre>

<DT><span class="strong">MAP_APPEND_MAP_EQ</span>
<DD>
<pre>
‚ä¢ ‚àÄxs ys.
    MAP f1 xs ++ MAP g1 ys = MAP f2 xs ++ MAP g2 ys ‚áî
    MAP f1 xs = MAP f2 xs ‚àß MAP g1 ys = MAP g2 ys
</pre>

<DT><span class="strong">MAP_COMPOSE</span>
<DD>
<pre>
‚ä¢ ‚àÄf g l. MAP f (MAP g l) = MAP (f ‚àò g) l
</pre>

<DT><span class="strong">MAP_CONG</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2 f f'. l1 = l2 ‚àß (‚àÄx. MEM x l2 ‚áí f x = f' x) ‚áí MAP f l1 = MAP f' l2
</pre>

<DT><span class="strong">MAP_DROP</span>
<DD>
<pre>
‚ä¢ ‚àÄl i. MAP f (DROP i l) = DROP i (MAP f l)
</pre>

<DT><span class="strong">MAP_EQ_APPEND</span>
<DD>
<pre>
‚ä¢ MAP f l = l1 ++ l2 ‚áî
  ‚àÉl10 l20. l = l10 ++ l20 ‚àß l1 = MAP f l10 ‚àß l2 = MAP f l20
</pre>

<DT><span class="strong">MAP_EQ_CONS</span>
<DD>
<pre>
‚ä¢ MAP f l = h::t ‚áî ‚àÉx0 t0. l = x0::t0 ‚àß h = f x0 ‚àß t = MAP f t0
</pre>

<DT><span class="strong">MAP_EQ_EVERY2</span>
<DD>
<pre>
‚ä¢ ‚àÄf1 f2 l1 l2.
    MAP f1 l1 = MAP f2 l2 ‚áî
    LENGTH l1 = LENGTH l2 ‚àß LIST_REL (Œªx y. f1 x = f2 y) l1 l2
</pre>

<DT><span class="strong">MAP_EQ_NIL</span>
<DD>
<pre>
‚ä¢ ‚àÄl f. (MAP f l = [] ‚áî l = []) ‚àß ([] = MAP f l ‚áî l = [])
</pre>

<DT><span class="strong">MAP_EQ_SING</span>
<DD>
<pre>
‚ä¢ MAP f l = [x] ‚áî ‚àÉx0. l = [x0] ‚àß x = f x0
</pre>

<DT><span class="strong">MAP_EQ_f</span>
<DD>
<pre>
‚ä¢ ‚àÄf1 f2 l. MAP f1 l = MAP f2 l ‚áî ‚àÄe. MEM e l ‚áí f1 e = f2 e
</pre>

<DT><span class="strong">MAP_FLAT</span>
<DD>
<pre>
‚ä¢ MAP f (FLAT l) = FLAT (MAP (MAP f) l)
</pre>

<DT><span class="strong">MAP_FRONT</span>
<DD>
<pre>
‚ä¢ ‚àÄls. ls ‚â† [] ‚áí MAP f (FRONT ls) = FRONT (MAP f ls)
</pre>

<DT><span class="strong">MAP_GENLIST</span>
<DD>
<pre>
‚ä¢ ‚àÄf g n. MAP f (GENLIST g n) = GENLIST (f ‚àò g) n
</pre>

<DT><span class="strong">MAP_ID</span>
<DD>
<pre>
‚ä¢ MAP (Œªx. x) l = l ‚àß MAP I l = l
</pre>

<DT><span class="strong">MAP_ID_I</span>
<DD>
<pre>
‚ä¢ MAP I = I
</pre>

<DT><span class="strong">MAP_LIST_BIND</span>
<DD>
<pre>
‚ä¢ MAP f (LIST_BIND l g) = LIST_BIND l (MAP f ‚àò g)
</pre>

<DT><span class="strong">MAP_MAP_o</span>
<DD>
<pre>
‚ä¢ ‚àÄf g l. MAP f (MAP g l) = MAP (f ‚àò g) l
</pre>

<DT><span class="strong">MAP_PRS</span>
<DD>
<pre>
‚ä¢ ‚àÄR1 abs1 rep1.
    QUOTIENT R1 abs1 rep1 ‚áí
    ‚àÄR2 abs2 rep2.
      QUOTIENT R2 abs2 rep2 ‚áí
      ‚àÄl f. MAP f l = MAP abs2 (MAP ((abs1 ‚ü∂ rep2) f) (MAP rep1 l))
</pre>

<DT><span class="strong">MAP_REVERSE</span>
<DD>
<pre>
‚ä¢ ‚àÄf l. MAP f (REVERSE l) = REVERSE (MAP f l)
</pre>

<DT><span class="strong">MAP_RSP</span>
<DD>
<pre>
‚ä¢ ‚àÄR1 abs1 rep1.
    QUOTIENT R1 abs1 rep1 ‚áí
    ‚àÄR2 abs2 rep2.
      QUOTIENT R2 abs2 rep2 ‚áí
      ‚àÄl1 l2 f1 f2.
        (R1 |==> R2) f1 f2 ‚àß LIST_REL R1 l1 l2 ‚áí
        LIST_REL R2 (MAP f1 l1) (MAP f2 l2)
</pre>

<DT><span class="strong">MAP_SNOC</span>
<DD>
<pre>
‚ä¢ ‚àÄf x l. MAP f (SNOC x l) = SNOC (f x) (MAP f l)
</pre>

<DT><span class="strong">MAP_TAKE</span>
<DD>
<pre>
‚ä¢ ‚àÄf n l. MAP f (TAKE n l) = TAKE n (MAP f l)
</pre>

<DT><span class="strong">MAP_TL</span>
<DD>
<pre>
‚ä¢ ‚àÄl f. MAP f (TL l) = TL (MAP f l)
</pre>

<DT><span class="strong">MAP_ZIP</span>
<DD>
<pre>
‚ä¢ LENGTH l1 = LENGTH l2 ‚áí
  MAP FST (ZIP (l1,l2)) = l1 ‚àß MAP SND (ZIP (l1,l2)) = l2 ‚àß
  MAP (f ‚àò FST) (ZIP (l1,l2)) = MAP f l1 ‚àß
  MAP (g ‚àò SND) (ZIP (l1,l2)) = MAP g l2
</pre>

<DT><span class="strong">MAP_ZIP_SAME</span>
<DD>
<pre>
‚ä¢ ‚àÄls f. MAP f (ZIP (ls,ls)) = MAP (Œªx. f (x,x)) ls
</pre>

<DT><span class="strong">MAP_o</span>
<DD>
<pre>
‚ä¢ ‚àÄf g. MAP (f ‚àò g) = MAP f ‚àò MAP g
</pre>

<DT><span class="strong">MEM</span>
<DD>
<pre>
‚ä¢ (‚àÄx. MEM x [] ‚áî F) ‚àß ‚àÄx h t. MEM x (h::t) ‚áî x = h ‚à® MEM x t
</pre>

<DT><span class="strong">MEM_APPEND</span>
<DD>
<pre>
‚ä¢ ‚àÄe l1 l2. MEM e (l1 ++ l2) ‚áî MEM e l1 ‚à® MEM e l2
</pre>

<DT><span class="strong">MEM_APPEND_lemma</span>
<DD>
<pre>
‚ä¢ ‚àÄa b c d x.
    a ++ [x] ++ b = c ++ [x] ++ d ‚àß ¬¨MEM x b ‚àß ¬¨MEM x a ‚áí a = c ‚àß b = d
</pre>

<DT><span class="strong">MEM_DROP</span>
<DD>
<pre>
‚ä¢ ‚àÄx ls n. MEM x (DROP n ls) ‚áî ‚àÉm. m + n < LENGTH ls ‚àß x = EL (m + n) ls
</pre>

<DT><span class="strong">MEM_EL</span>
<DD>
<pre>
‚ä¢ ‚àÄl x. MEM x l ‚áî ‚àÉn. n < LENGTH l ‚àß x = EL n l
</pre>

<DT><span class="strong">MEM_FILTER</span>
<DD>
<pre>
‚ä¢ ‚àÄP L x. MEM x (FILTER P L) ‚áî P x ‚àß MEM x L
</pre>

<DT><span class="strong">MEM_FLAT</span>
<DD>
<pre>
‚ä¢ ‚àÄx L. MEM x (FLAT L) ‚áî ‚àÉl. MEM l L ‚àß MEM x l
</pre>

<DT><span class="strong">MEM_GENLIST</span>
<DD>
<pre>
‚ä¢ MEM x (GENLIST f n) ‚áî ‚àÉm. m < n ‚àß x = f m
</pre>

<DT><span class="strong">MEM_LUPDATE</span>
<DD>
<pre>
‚ä¢ ‚àÄl x y i.
    MEM x (LUPDATE y i l) ‚áî
    i < LENGTH l ‚àß x = y ‚à® ‚àÉj. j < LENGTH l ‚àß i ‚â† j ‚àß EL j l = x
</pre>

<DT><span class="strong">MEM_LUPDATE_E</span>
<DD>
<pre>
‚ä¢ ‚àÄl x y i. MEM x (LUPDATE y i l) ‚áí x = y ‚à® MEM x l
</pre>

<DT><span class="strong">MEM_MAP</span>
<DD>
<pre>
‚ä¢ ‚àÄl f x. MEM x (MAP f l) ‚áî ‚àÉy. x = f y ‚àß MEM y l
</pre>

<DT><span class="strong">MEM_MAP_f</span>
<DD>
<pre>
‚ä¢ ‚àÄf l a. MEM a l ‚áí MEM (f a) (MAP f l)
</pre>

<DT><span class="strong">MEM_REVERSE</span>
<DD>
<pre>
‚ä¢ ‚àÄl x. MEM x (REVERSE l) ‚áî MEM x l
</pre>

<DT><span class="strong">MEM_SET_TO_LIST</span>
<DD>
<pre>
‚ä¢ ‚àÄs. FINITE s ‚áí ‚àÄx. MEM x (SET_TO_LIST s) ‚áî x ‚àà s
</pre>

<DT><span class="strong">MEM_SNOC</span>
<DD>
<pre>
‚ä¢ ‚àÄy x l. MEM y (SNOC x l) ‚áî y = x ‚à® MEM y l
</pre>

<DT><span class="strong">MEM_SPLIT</span>
<DD>
<pre>
‚ä¢ ‚àÄx l. MEM x l ‚áî ‚àÉl1 l2. l = l1 ++ x::l2
</pre>

<DT><span class="strong">MEM_SPLIT_APPEND_first</span>
<DD>
<pre>
‚ä¢ MEM e l ‚áî ‚àÉpfx sfx. l = pfx ++ [e] ++ sfx ‚àß ¬¨MEM e pfx
</pre>

<DT><span class="strong">MEM_SPLIT_APPEND_last</span>
<DD>
<pre>
‚ä¢ MEM e l ‚áî ‚àÉpfx sfx. l = pfx ++ [e] ++ sfx ‚àß ¬¨MEM e sfx
</pre>

<DT><span class="strong">MEM_TL</span>
<DD>
<pre>
‚ä¢ ‚àÄl x. MEM x (TL l) ‚áí MEM x l
</pre>

<DT><span class="strong">MEM_ZIP</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2 p.
    LENGTH l1 = LENGTH l2 ‚áí
    (MEM p (ZIP (l1,l2)) ‚áî ‚àÉn. n < LENGTH l1 ‚àß p = (EL n l1,EL n l2))
</pre>

<DT><span class="strong">MEM_ZIP_MEM_MAP</span>
<DD>
<pre>
‚ä¢ LENGTH (FST ps) = LENGTH (SND ps) ‚àß MEM p (ZIP ps) ‚áí
  MEM (FST p) (FST ps) ‚àß MEM (SND p) (SND ps)
</pre>

<DT><span class="strong">MEM_dropWhile_IMP</span>
<DD>
<pre>
‚ä¢ ‚àÄP ls x. MEM x (dropWhile P ls) ‚áí MEM x ls
</pre>

<DT><span class="strong">MEM_nub</span>
<DD>
<pre>
‚ä¢ MEM x (nub l) ‚áî MEM x l
</pre>

<DT><span class="strong">MONO_EVERY</span>
<DD>
<pre>
‚ä¢ (‚àÄx. P x ‚áí Q x) ‚áí EVERY P l ‚áí EVERY Q l
</pre>

<DT><span class="strong">NIL_PRS</span>
<DD>
<pre>
‚ä¢ ‚àÄR abs rep. QUOTIENT R abs rep ‚áí [] = MAP abs []
</pre>

<DT><span class="strong">NIL_RSP</span>
<DD>
<pre>
‚ä¢ ‚àÄR abs rep. QUOTIENT R abs rep ‚áí LIST_REL R [] []
</pre>

<DT><span class="strong">NOT_CONS_NIL</span>
<DD>
<pre>
‚ä¢ ‚àÄa1 a0. a0::a1 ‚â† []
</pre>

<DT><span class="strong">NOT_EQ_LIST</span>
<DD>
<pre>
‚ä¢ ‚àÄh1 h2. h1 ‚â† h2 ‚áí ‚àÄl1 l2. h1::l1 ‚â† h2::l2
</pre>

<DT><span class="strong">NOT_EVERY</span>
<DD>
<pre>
‚ä¢ ‚àÄP l. ¬¨EVERY P l ‚áî EXISTS ($¬¨ ‚àò P) l
</pre>

<DT><span class="strong">NOT_EVERY_EXISTS_FIRST</span>
<DD>
<pre>
‚ä¢ ‚àÄP l. ¬¨EVERY P l ‚áî ‚àÉi. i < LENGTH l ‚àß ¬¨P (EL i l) ‚àß ‚àÄj. j < i ‚áí P (EL j l)
</pre>

<DT><span class="strong">NOT_EXISTS</span>
<DD>
<pre>
‚ä¢ ‚àÄP l. ¬¨EXISTS P l ‚áî EVERY ($¬¨ ‚àò P) l
</pre>

<DT><span class="strong">NOT_NIL_CONS</span>
<DD>
<pre>
‚ä¢ ‚àÄa1 a0. [] ‚â† a0::a1
</pre>

<DT><span class="strong">NOT_NIL_EQ_LENGTH_NOT_0</span>
<DD>
<pre>
‚ä¢ x ‚â† [] ‚áî 0 < LENGTH x
</pre>

<DT><span class="strong">NOT_NULL_MEM</span>
<DD>
<pre>
‚ä¢ ‚àÄl. ¬¨NULL l ‚áî ‚àÉe. MEM e l
</pre>

<DT><span class="strong">NRC_LRC</span>
<DD>
<pre>
‚ä¢ NRC R n x y ‚áî ‚àÉls. LRC R ls x y ‚àß LENGTH ls = n
</pre>

<DT><span class="strong">NULL</span>
<DD>
<pre>
‚ä¢ NULL [] ‚àß ‚àÄh t. ¬¨NULL (h::t)
</pre>

<DT><span class="strong">NULL_APPEND</span>
<DD>
<pre>
‚ä¢ NULL (l1 ++ l2) ‚áî NULL l1 ‚àß NULL l2
</pre>

<DT><span class="strong">NULL_EQ</span>
<DD>
<pre>
‚ä¢ ‚àÄl. NULL l ‚áî l = []
</pre>

<DT><span class="strong">NULL_FILTER</span>
<DD>
<pre>
‚ä¢ ‚àÄP ls. NULL (FILTER P ls) ‚áî ‚àÄx. MEM x ls ‚áí ¬¨P x
</pre>

<DT><span class="strong">NULL_GENLIST</span>
<DD>
<pre>
‚ä¢ ‚àÄn f. NULL (GENLIST f n) ‚áî n = 0
</pre>

<DT><span class="strong">NULL_LENGTH</span>
<DD>
<pre>
‚ä¢ ‚àÄl. NULL l ‚áî LENGTH l = 0
</pre>

<DT><span class="strong">NULL_MAP</span>
<DD>
<pre>
‚ä¢ NULL (MAP f ls) ‚áî NULL ls
</pre>

<DT><span class="strong">OPT_MMAP_cong</span>
<DD>
<pre>
‚ä¢ ‚àÄf1 f2 x1 x2.
    x1 = x2 ‚àß (‚àÄa. MEM a x2 ‚áí f1 a = f2 a) ‚áí OPT_MMAP f1 x1 = OPT_MMAP f2 x2
</pre>

<DT><span class="strong">REVERSE_11</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2. REVERSE l1 = REVERSE l2 ‚áî l1 = l2
</pre>

<DT><span class="strong">REVERSE_APPEND</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2. REVERSE (l1 ++ l2) = REVERSE l2 ++ REVERSE l1
</pre>

<DT><span class="strong">REVERSE_EQ_NIL</span>
<DD>
<pre>
‚ä¢ REVERSE l = [] ‚áî l = []
</pre>

<DT><span class="strong">REVERSE_EQ_SING</span>
<DD>
<pre>
‚ä¢ REVERSE l = [e] ‚áî l = [e]
</pre>

<DT><span class="strong">REVERSE_GENLIST</span>
<DD>
<pre>
‚ä¢ REVERSE (GENLIST f n) = GENLIST (Œªm. f (PRE n ‚àí m)) n
</pre>

<DT><span class="strong">REVERSE_REV</span>
<DD>
<pre>
‚ä¢ ‚àÄL. REVERSE L = REV L []
</pre>

<DT><span class="strong">REVERSE_REVERSE</span>
<DD>
<pre>
‚ä¢ ‚àÄl. REVERSE (REVERSE l) = l
</pre>

<DT><span class="strong">REVERSE_SNOC</span>
<DD>
<pre>
‚ä¢ ‚àÄx l. REVERSE (SNOC x l) = x::REVERSE l
</pre>

<DT><span class="strong">REVERSE_SNOC_DEF</span>
<DD>
<pre>
‚ä¢ REVERSE [] = [] ‚àß ‚àÄx l. REVERSE (x::l) = SNOC x (REVERSE l)
</pre>

<DT><span class="strong">REVERSE_o_REVERSE</span>
<DD>
<pre>
‚ä¢ REVERSE ‚àò REVERSE ‚àò f = f
</pre>

<DT><span class="strong">REV_REVERSE_LEM</span>
<DD>
<pre>
‚ä¢ ‚àÄL1 L2. REV L1 L2 = REVERSE L1 ++ L2
</pre>

<DT><span class="strong">SET_QUOTIENT</span>
<DD>
<pre>
‚ä¢ ‚àÄR abs rep.
    QUOTIENT R abs rep ‚áí QUOTIENT (SET_REL R) (IMAGE abs) (IMAGE rep)
</pre>

<DT><span class="strong">SET_REL_EQ</span>
<DD>
<pre>
‚ä¢ SET_REL $= = $=
</pre>

<DT><span class="strong">SET_REL_THM</span>
<DD>
<pre>
‚ä¢ SET_REL R s1 s2 ‚áî
  (‚àÄx. x ‚àà s1 ‚áí ‚àÉy. y ‚àà s2 ‚àß R x y) ‚àß ‚àÄy. y ‚àà s2 ‚áí ‚àÉx. x ‚àà s1 ‚àß R x y
</pre>

<DT><span class="strong">SET_TO_LIST_CARD</span>
<DD>
<pre>
‚ä¢ ‚àÄs. FINITE s ‚áí LENGTH (SET_TO_LIST s) = CARD s
</pre>

<DT><span class="strong">SET_TO_LIST_EMPTY</span>
<DD>
<pre>
‚ä¢ SET_TO_LIST ‚àÖ = []
</pre>

<DT><span class="strong">SET_TO_LIST_EMPTY_IFF</span>
<DD>
<pre>
‚ä¢ ‚àÄs. FINITE s ‚áí (SET_TO_LIST s = [] ‚áî s = ‚àÖ)
</pre>

<DT><span class="strong">SET_TO_LIST_IND</span>
<DD>
<pre>
‚ä¢ ‚àÄP. (‚àÄs. (FINITE s ‚àß s ‚â† ‚àÖ ‚áí P (REST s)) ‚áí P s) ‚áí ‚àÄv. P v
</pre>

<DT><span class="strong">SET_TO_LIST_INV</span>
<DD>
<pre>
‚ä¢ ‚àÄs. FINITE s ‚áí LIST_TO_SET (SET_TO_LIST s) = s
</pre>

<DT><span class="strong">SET_TO_LIST_IN_MEM</span>
<DD>
<pre>
‚ä¢ ‚àÄs. FINITE s ‚áí ‚àÄx. x ‚àà s ‚áî MEM x (SET_TO_LIST s)
</pre>

<DT><span class="strong">SET_TO_LIST_SING</span>
<DD>
<pre>
‚ä¢ SET_TO_LIST {x} = [x]
</pre>

<DT><span class="strong">SET_TO_LIST_THM</span>
<DD>
<pre>
‚ä¢ FINITE s ‚áí
  SET_TO_LIST s = if s = ‚àÖ then [] else CHOICE s::SET_TO_LIST (REST s)
</pre>

<DT><span class="strong">SHORTLEX_LENGTH_LE</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2. SHORTLEX R l1 l2 ‚áí LENGTH l1 ‚â§ LENGTH l2
</pre>

<DT><span class="strong">SHORTLEX_MONO</span>
<DD>
<pre>
‚ä¢ (‚àÄx y. R1 x y ‚áí R2 x y) ‚áí SHORTLEX R1 x y ‚áí SHORTLEX R2 x y
</pre>

<DT><span class="strong">SHORTLEX_NIL2</span>
<DD>
<pre>
‚ä¢ ¬¨SHORTLEX R l []
</pre>

<DT><span class="strong">SHORTLEX_SNOC</span>
<DD>
<pre>
‚ä¢ ‚àÄR l h1 h2. R h1 h2 ‚áí SHORTLEX R (SNOC h1 l) (SNOC h2 l)
</pre>

<DT><span class="strong">SHORTLEX_THM</span>
<DD>
<pre>
‚ä¢ (¬¨SHORTLEX R [] [] ‚àß ¬¨SHORTLEX R (h1::t1) []) ‚àß SHORTLEX R [] (h2::t2) ‚àß
  (SHORTLEX R (h1::t1) (h2::t2) ‚áî
   LENGTH t1 < LENGTH t2 ‚à®
   LENGTH t1 = LENGTH t2 ‚àß (R h1 h2 ‚à® h1 = h2 ‚àß SHORTLEX R t1 t2))
</pre>

<DT><span class="strong">SHORTLEX_antisymmetric</span>
<DD>
<pre>
‚ä¢ ‚àÄR. irreflexive R ‚àß antisymmetric R ‚áí antisymmetric (SHORTLEX R)
</pre>

<DT><span class="strong">SHORTLEX_irreflexive</span>
<DD>
<pre>
‚ä¢ ‚àÄR. irreflexive R ‚áí irreflexive (SHORTLEX R)
</pre>

<DT><span class="strong">SHORTLEX_same_lengths</span>
<DD>
<pre>
‚ä¢ ‚àÄR h1 h2 t1 t2.
    LENGTH t1 = LENGTH t2 ‚áí
    (SHORTLEX R (h1::t1) (h2::t2) ‚áî R h1 h2 ‚à® h1 = h2 ‚àß SHORTLEX R t1 t2)
</pre>

<DT><span class="strong">SHORTLEX_total</span>
<DD>
<pre>
‚ä¢ total (RC R) ‚áí total (RC (SHORTLEX R))
</pre>

<DT><span class="strong">SHORTLEX_transitive</span>
<DD>
<pre>
‚ä¢ transitive R ‚áí transitive (SHORTLEX R)
</pre>

<DT><span class="strong">SINGL_APPLY_MAP</span>
<DD>
<pre>
‚ä¢ [f] <*> l = MAP f l
</pre>

<DT><span class="strong">SINGL_APPLY_PERMUTE</span>
<DD>
<pre>
‚ä¢ fs <*> [x] = [(Œªf. f x)] <*> fs
</pre>

<DT><span class="strong">SINGL_LIST_APPLY_L</span>
<DD>
<pre>
‚ä¢ LIST_BIND [x] f = f x
</pre>

<DT><span class="strong">SINGL_LIST_APPLY_R</span>
<DD>
<pre>
‚ä¢ LIST_BIND l (Œªx. [x]) = l
</pre>

<DT><span class="strong">SINGL_SINGL_APPLY</span>
<DD>
<pre>
‚ä¢ [f] <*> [x] = [f x]
</pre>

<DT><span class="strong">SING_HD</span>
<DD>
<pre>
‚ä¢ ([HD xs] = xs ‚áî LENGTH xs = 1) ‚àß (xs = [HD xs] ‚áî LENGTH xs = 1)
</pre>

<DT><span class="strong">SNOC_11</span>
<DD>
<pre>
‚ä¢ ‚àÄx y a b. SNOC x y = SNOC a b ‚áî x = a ‚àß y = b
</pre>

<DT><span class="strong">SNOC_APPEND</span>
<DD>
<pre>
‚ä¢ ‚àÄx l. SNOC x l = l ++ [x]
</pre>

<DT><span class="strong">SNOC_Axiom</span>
<DD>
<pre>
‚ä¢ ‚àÄe f. ‚àÉfn. fn [] = e ‚àß ‚àÄx l. fn (SNOC x l) = f x l (fn l)
</pre>

<DT><span class="strong">SNOC_CASES</span>
<DD>
<pre>
‚ä¢ ‚àÄll. ll = [] ‚à® ‚àÉx l. ll = SNOC x l
</pre>

<DT><span class="strong">SNOC_CONS</span>
<DD>
<pre>
‚ä¢ ‚àÄx x' l. SNOC x (x'::l) = x'::SNOC x l
</pre>

<DT><span class="strong">SNOC_INDUCT</span>
<DD>
<pre>
‚ä¢ ‚àÄP. P [] ‚àß (‚àÄl. P l ‚áí ‚àÄx. P (SNOC x l)) ‚áí ‚àÄl. P l
</pre>

<DT><span class="strong">SNOC_LAST_FRONT</span>
<DD>
<pre>
‚ä¢ ‚àÄl. l ‚â† [] ‚áí SNOC (LAST l) (FRONT l) = l
</pre>

<DT><span class="strong">SNOC_NIL</span>
<DD>
<pre>
‚ä¢ ‚àÄx. SNOC x [] = [x]
</pre>

<DT><span class="strong">SUM_ACC_SUM_LEM</span>
<DD>
<pre>
‚ä¢ ‚àÄL n. SUM_ACC L n = SUM L + n
</pre>

<DT><span class="strong">SUM_APPEND</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2. SUM (l1 ++ l2) = SUM l1 + SUM l2
</pre>

<DT><span class="strong">SUM_IMAGE_LIST_TO_SET_upper_bound</span>
<DD>
<pre>
‚ä¢ ‚àÄls. ‚àë f (LIST_TO_SET ls) ‚â§ SUM (MAP f ls)
</pre>

<DT><span class="strong">SUM_IMAGE_eq_SUM_MAP_SET_TO_LIST</span>
<DD>
<pre>
‚ä¢ FINITE s ‚áí ‚àë f s = SUM (MAP f (SET_TO_LIST s))
</pre>

<DT><span class="strong">SUM_MAP_FOLDL</span>
<DD>
<pre>
‚ä¢ ‚àÄls. SUM (MAP f ls) = FOLDL (Œªa e. a + f e) 0 ls
</pre>

<DT><span class="strong">SUM_MAP_MEM_bound</span>
<DD>
<pre>
‚ä¢ ‚àÄf x ls. MEM x ls ‚áí f x ‚â§ SUM (MAP f ls)
</pre>

<DT><span class="strong">SUM_MAP_PLUS</span>
<DD>
<pre>
‚ä¢ ‚àÄf g ls. SUM (MAP (Œªx. f x + g x) ls) = SUM (MAP f ls) + SUM (MAP g ls)
</pre>

<DT><span class="strong">SUM_MAP_PLUS_ZIP</span>
<DD>
<pre>
‚ä¢ ‚àÄls1 ls2.
    LENGTH ls1 = LENGTH ls2 ‚àß (‚àÄx y. f (x,y) = g x + h y) ‚áí
    SUM (MAP f (ZIP (ls1,ls2))) = SUM (MAP g ls1) + SUM (MAP h ls2)
</pre>

<DT><span class="strong">SUM_SNOC</span>
<DD>
<pre>
‚ä¢ ‚àÄx l. SUM (SNOC x l) = SUM l + x
</pre>

<DT><span class="strong">SUM_SUM_ACC</span>
<DD>
<pre>
‚ä¢ ‚àÄL. SUM L = SUM_ACC L 0
</pre>

<DT><span class="strong">SUM_eq_0</span>
<DD>
<pre>
‚ä¢ ‚àÄls. SUM ls = 0 ‚áî ‚àÄx. MEM x ls ‚áí x = 0
</pre>

<DT><span class="strong">SWAP_REVERSE</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2. l1 = REVERSE l2 ‚áî l2 = REVERSE l1
</pre>

<DT><span class="strong">SWAP_REVERSE_SYM</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2. REVERSE l1 = l2 ‚áî l1 = REVERSE l2
</pre>

<DT><span class="strong">TAKE1</span>
<DD>
<pre>
‚ä¢ ‚àÄl. l ‚â† [] ‚áí TAKE 1 l = [EL 0 l]
</pre>

<DT><span class="strong">TAKE1_DROP</span>
<DD>
<pre>
‚ä¢ ‚àÄn l. n < LENGTH l ‚áí TAKE 1 (DROP n l) = [EL n l]
</pre>

<DT><span class="strong">TAKE_0</span>
<DD>
<pre>
‚ä¢ TAKE 0 l = []
</pre>

<DT><span class="strong">TAKE_APPEND1</span>
<DD>
<pre>
‚ä¢ ‚àÄn. n ‚â§ LENGTH l1 ‚áí TAKE n (l1 ++ l2) = TAKE n l1
</pre>

<DT><span class="strong">TAKE_APPEND2</span>
<DD>
<pre>
‚ä¢ ‚àÄn. LENGTH l1 < n ‚áí TAKE n (l1 ++ l2) = l1 ++ TAKE (n ‚àí LENGTH l1) l2
</pre>

<DT><span class="strong">TAKE_DROP</span>
<DD>
<pre>
‚ä¢ ‚àÄn l. TAKE n l ++ DROP n l = l
</pre>

<DT><span class="strong">TAKE_DROP_SWAP</span>
<DD>
<pre>
‚ä¢ ‚àÄxs k n. TAKE k (DROP n xs) = DROP n (TAKE (k + n) xs)
</pre>

<DT><span class="strong">TAKE_EQ_NIL</span>
<DD>
<pre>
‚ä¢ TAKE n l = [] ‚áî n = 0 ‚à® l = []
</pre>

<DT><span class="strong">TAKE_EQ_REWRITE</span>
<DD>
<pre>
‚ä¢ ‚àÄl m n. m ‚â§ LENGTH l ‚àß n ‚â§ LENGTH l ‚áí (TAKE m l = TAKE n l ‚áî m = n)
</pre>

<DT><span class="strong">TAKE_GENLIST</span>
<DD>
<pre>
‚ä¢ TAKE n (GENLIST f m) = GENLIST f (MIN n m)
</pre>

<DT><span class="strong">TAKE_LENGTH_ID</span>
<DD>
<pre>
‚ä¢ ‚àÄl. TAKE (LENGTH l) l = l
</pre>

<DT><span class="strong">TAKE_LENGTH_ID_rwt</span>
<DD>
<pre>
‚ä¢ ‚àÄl m. m = LENGTH l ‚áí TAKE m l = l
</pre>

<DT><span class="strong">TAKE_LENGTH_ID_rwt2</span>
<DD>
<pre>
‚ä¢ ‚àÄl m. TAKE m l = l ‚áî LENGTH l ‚â§ m
</pre>

<DT><span class="strong">TAKE_LENGTH_TOO_LONG</span>
<DD>
<pre>
‚ä¢ ‚àÄl n. LENGTH l ‚â§ n ‚áí TAKE n l = l
</pre>

<DT><span class="strong">TAKE_SUM</span>
<DD>
<pre>
‚ä¢ ‚àÄn m l. TAKE (n + m) l = TAKE n l ++ TAKE m (DROP n l)
</pre>

<DT><span class="strong">TAKE_TAKE_MIN</span>
<DD>
<pre>
‚ä¢ ‚àÄm n. TAKE n (TAKE m l) = TAKE (MIN n m) l
</pre>

<DT><span class="strong">TAKE_compute</span>
<DD>
<pre>
‚ä¢ (‚àÄl. TAKE 0 l = []) ‚àß (‚àÄn. TAKE <..num comp'n..> [] = []) ‚àß
  (‚àÄn. TAKE <..num comp'n..> [] = []) ‚àß
  (‚àÄn h t. TAKE <..num comp'n..> (h::t) = h::TAKE (<..num comp'n..> ‚àí 1) t) ‚àß
  ‚àÄn h t. TAKE <..num comp'n..> (h::t) = h::TAKE <..num comp'n..> t
</pre>

<DT><span class="strong">TAKE_cons</span>
<DD>
<pre>
‚ä¢ 0 < n ‚áí TAKE n (x::xs) = x::TAKE (n ‚àí 1) xs
</pre>

<DT><span class="strong">TAKE_nil</span>
<DD>
<pre>
‚ä¢ ‚àÄn. TAKE n [] = []
</pre>

<DT><span class="strong">TAKE_splitAtPki</span>
<DD>
<pre>
‚ä¢ TAKE n l = splitAtPki (K ‚àò $= n) K l
</pre>

<DT><span class="strong">TL</span>
<DD>
<pre>
‚ä¢ ‚àÄh t. TL (h::t) = t
</pre>

<DT><span class="strong">TL_GENLIST</span>
<DD>
<pre>
‚ä¢ ‚àÄf n. TL (GENLIST f (SUC n)) = GENLIST (f ‚àò SUC) n
</pre>

<DT><span class="strong">UNION_APPEND</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2. LIST_TO_SET l1 ‚à™ LIST_TO_SET l2 = LIST_TO_SET (l1 ++ l2)
</pre>

<DT><span class="strong">UNIQUE_FILTER</span>
<DD>
<pre>
‚ä¢ ‚àÄe L. UNIQUE e L ‚áî FILTER ($= e) L = [e]
</pre>

<DT><span class="strong">UNIQUE_LENGTH_FILTER</span>
<DD>
<pre>
‚ä¢ ‚àÄe L. UNIQUE e L ‚áî LENGTH (FILTER ($= e) L) = 1
</pre>

<DT><span class="strong">UNZIP_MAP</span>
<DD>
<pre>
‚ä¢ ‚àÄL. UNZIP L = (MAP FST L,MAP SND L)
</pre>

<DT><span class="strong">UNZIP_THM</span>
<DD>
<pre>
‚ä¢ UNZIP [] = ([],[]) ‚àß
  UNZIP ((x,y)::t) = (let (L1,L2) = UNZIP t in (x::L1,y::L2))
</pre>

<DT><span class="strong">UNZIP_ZIP</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2. LENGTH l1 = LENGTH l2 ‚áí UNZIP (ZIP (l1,l2)) = (l1,l2)
</pre>

<DT><span class="strong">WF_LIST_PRED</span>
<DD>
<pre>
‚ä¢ WF (ŒªL1 L2. ‚àÉh. L2 = h::L1)
</pre>

<DT><span class="strong">WF_SHORTLEX</span>
<DD>
<pre>
‚ä¢ WF R ‚áí WF (SHORTLEX R)
</pre>

<DT><span class="strong">WF_SHORTLEX_same_lengths</span>
<DD>
<pre>
‚ä¢ WF R ‚áí
  ‚àÄl s.
    (‚àÄd. d ‚àà s ‚áí LENGTH d = l) ‚àß (‚àÉa. a ‚àà s) ‚áí
    ‚àÉb. b ‚àà s ‚àß ‚àÄc. SHORTLEX R c b ‚áí c ‚àâ s
</pre>

<DT><span class="strong">ZIP</span>
<DD>
<pre>
‚ä¢ ZIP ([],[]) = [] ‚àß ‚àÄx1 l1 x2 l2. ZIP (x1::l1,x2::l2) = (x1,x2)::ZIP (l1,l2)
</pre>

<DT><span class="strong">ZIP_DROP</span>
<DD>
<pre>
‚ä¢ ‚àÄa b n.
    n ‚â§ LENGTH a ‚àß LENGTH a = LENGTH b ‚áí
    ZIP (DROP n a,DROP n b) = DROP n (ZIP (a,b))
</pre>

<DT><span class="strong">ZIP_EQ_NIL</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2. LENGTH l1 = LENGTH l2 ‚áí (ZIP (l1,l2) = [] ‚áî l1 = [] ‚àß l2 = [])
</pre>

<DT><span class="strong">ZIP_GENLIST</span>
<DD>
<pre>
‚ä¢ ‚àÄl f n. LENGTH l = n ‚áí ZIP (l,GENLIST f n) = GENLIST (Œªx. (EL x l,f x)) n
</pre>

<DT><span class="strong">ZIP_MAP</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2 f1 f2.
    LENGTH l1 = LENGTH l2 ‚áí
    ZIP (MAP f1 l1,l2) = MAP (Œªp. (f1 (FST p),SND p)) (ZIP (l1,l2)) ‚àß
    ZIP (l1,MAP f2 l2) = MAP (Œªp. (FST p,f2 (SND p))) (ZIP (l1,l2))
</pre>

<DT><span class="strong">ZIP_UNZIP</span>
<DD>
<pre>
‚ä¢ ‚àÄl. ZIP (UNZIP l) = l
</pre>

<DT><span class="strong">ZIP_ind</span>
<DD>
<pre>
‚ä¢ ‚àÄP. (‚àÄl2. P ([],l2)) ‚àß (‚àÄl1. P (l1,[])) ‚àß
      (‚àÄl1 l2 h1 h2. P (l1,l2) ‚áí P (h1::l1,h2::l2)) ‚áí
      ‚àÄp. P p
</pre>

<DT><span class="strong">ZIP_ind_alt</span>
<DD>
<pre>
‚ä¢ ‚àÄP. (‚àÄl. P ([],l)) ‚àß (‚àÄh t. P (h::t,[])) ‚àß
      (‚àÄx xs y ys. P (xs,ys) ‚áí P (x::xs,y::ys)) ‚áí
      ‚àÄv v1. P (v,v1)
</pre>

<DT><span class="strong">adjacent_EL</span>
<DD>
<pre>
‚ä¢ adjacent L a b ‚áî ‚àÉi. i + 1 < LENGTH L ‚àß a = EL i L ‚àß b = EL (i + 1) L
</pre>

<DT><span class="strong">adjacent_MAP</span>
<DD>
<pre>
‚ä¢ ‚àÄxs a b f.
    adjacent (MAP f xs) a b ‚áî ‚àÉx y. adjacent xs x y ‚àß a = f x ‚àß b = f y
</pre>

<DT><span class="strong">adjacent_MEM</span>
<DD>
<pre>
‚ä¢ ‚àÄxs a b. adjacent xs a b ‚áí MEM a xs ‚àß MEM b xs
</pre>

<DT><span class="strong">adjacent_REVERSE</span>
<DD>
<pre>
‚ä¢ ‚àÄxs a b. adjacent (REVERSE xs) a b ‚áî adjacent xs b a
</pre>

<DT><span class="strong">adjacent_append1</span>
<DD>
<pre>
‚ä¢ ‚àÄxs ys a b. adjacent xs a b ‚áí adjacent (xs ++ ys) a b
</pre>

<DT><span class="strong">adjacent_append2</span>
<DD>
<pre>
‚ä¢ ‚àÄxs ys a b. adjacent ys a b ‚áí adjacent (xs ++ ys) a b
</pre>

<DT><span class="strong">adjacent_cases</span>
<DD>
<pre>
‚ä¢ ‚àÄa0 a1 a2.
    adjacent a0 a1 a2 ‚áî
    (‚àÉt. a0 = a1::a2::t) ‚à® ‚àÉh t. a0 = h::t ‚àß adjacent t a1 a2
</pre>

<DT><span class="strong">adjacent_iff</span>
<DD>
<pre>
‚ä¢ adjacent (h1::h2::t) a b ‚áî h1 = a ‚àß h2 = b ‚à® adjacent (h2::t) a b
</pre>

<DT><span class="strong">adjacent_ind</span>
<DD>
<pre>
‚ä¢ ‚àÄadjacent'.
    (‚àÄa b t. adjacent' (a::b::t) a b) ‚àß
    (‚àÄa b h t. adjacent' t a b ‚áí adjacent' (h::t) a b) ‚áí
    ‚àÄa0 a1 a2. adjacent a0 a1 a2 ‚áí adjacent' a0 a1 a2
</pre>

<DT><span class="strong">adjacent_ps_append</span>
<DD>
<pre>
‚ä¢ ‚àÄxs a b. adjacent xs a b ‚áî ‚àÉp s. xs = p ++ [a; b] ++ s
</pre>

<DT><span class="strong">adjacent_rules</span>
<DD>
<pre>
‚ä¢ (‚àÄa b t. adjacent (a::b::t) a b) ‚àß
  ‚àÄa b h t. adjacent t a b ‚áí adjacent (h::t) a b
</pre>

<DT><span class="strong">adjacent_strongind</span>
<DD>
<pre>
‚ä¢ ‚àÄadjacent'.
    (‚àÄa b t. adjacent' (a::b::t) a b) ‚àß
    (‚àÄa b h t. adjacent t a b ‚àß adjacent' t a b ‚áí adjacent' (h::t) a b) ‚áí
    ‚àÄa0 a1 a2. adjacent a0 a1 a2 ‚áí adjacent' a0 a1 a2
</pre>

<DT><span class="strong">adjacent_thm</span>
<DD>
<pre>
‚ä¢ (adjacent [] a b ‚áî F) ‚àß (adjacent [e] a b ‚áî F) ‚àß
  (adjacent (a::b::t) a b ‚áî T)
</pre>

<DT><span class="strong">all_distinct_nub</span>
<DD>
<pre>
‚ä¢ ‚àÄl. ALL_DISTINCT (nub l)
</pre>

<DT><span class="strong">all_distinct_nub_id</span>
<DD>
<pre>
‚ä¢ ‚àÄl. ALL_DISTINCT l ‚áí nub l = l
</pre>

<DT><span class="strong">bounded_length_FINITE</span>
<DD>
<pre>
‚ä¢ FINITE ùïå(:Œ±) ‚áí ‚àÄm s. (‚àÄx. x ‚àà s ‚áí LENGTH x ‚â§ m) ‚áí FINITE s
</pre>

<DT><span class="strong">datatype_list</span>
<DD>
<pre>
‚ä¢ DATATYPE (list [] CONS)
</pre>

<DT><span class="strong">dropWhile_APPEND_EVERY</span>
<DD>
<pre>
‚ä¢ ‚àÄP l1 l2. EVERY P l1 ‚áí dropWhile P (l1 ++ l2) = dropWhile P l2
</pre>

<DT><span class="strong">dropWhile_APPEND_EXISTS</span>
<DD>
<pre>
‚ä¢ ‚àÄP l1 l2. EXISTS ($¬¨ ‚àò P) l1 ‚áí dropWhile P (l1 ++ l2) = dropWhile P l1 ++ l2
</pre>

<DT><span class="strong">dropWhile_eq_nil</span>
<DD>
<pre>
‚ä¢ ‚àÄP ls. dropWhile P ls = [] ‚áî EVERY P ls
</pre>

<DT><span class="strong">dropWhile_id</span>
<DD>
<pre>
‚ä¢ dropWhile P ls = ls ‚áî NULL ls ‚à® ¬¨P (HD ls)
</pre>

<DT><span class="strong">dropWhile_splitAtPki</span>
<DD>
<pre>
‚ä¢ ‚àÄP. dropWhile P = splitAtPki (flip (K ‚àò $¬¨ ‚àò P)) (K I)
</pre>

<DT><span class="strong">el_append3</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 x l2. EL (LENGTH l1) (l1 ++ [x] ++ l2) = x
</pre>

<DT><span class="strong">every_zip_fst</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2 P.
    LENGTH l1 = LENGTH l2 ‚áí (EVERY (Œªx. P (FST x)) (ZIP (l1,l2)) ‚áî EVERY P l1)
</pre>

<DT><span class="strong">every_zip_snd</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2 P.
    LENGTH l1 = LENGTH l2 ‚áí (EVERY (Œªx. P (SND x)) (ZIP (l1,l2)) ‚áî EVERY P l2)
</pre>

<DT><span class="strong">exists_list_GENLIST</span>
<DD>
<pre>
‚ä¢ (‚àÉls. P ls) ‚áî ‚àÉn f. P (GENLIST f n)
</pre>

<DT><span class="strong">filter_size_less</span>
<DD>
<pre>
‚ä¢ ‚àÄh t. list_size f (FILTER P t) < list_size f (h::t)
</pre>

<DT><span class="strong">isPREFIX_ANTISYM</span>
<DD>
<pre>
‚ä¢ ‚àÄx y. x ‚âº y ‚àß y ‚âº x ‚áí x = y
</pre>

<DT><span class="strong">isPREFIX_CONSR</span>
<DD>
<pre>
‚ä¢ x ‚âº y::ys ‚áî x = [] ‚à® ‚àÉxs. x = y::xs ‚àß xs ‚âº ys
</pre>

<DT><span class="strong">isPREFIX_GENLIST</span>
<DD>
<pre>
‚ä¢ ‚àÄf m n. GENLIST f m ‚âº GENLIST f n ‚áî m ‚â§ n
</pre>

<DT><span class="strong">isPREFIX_MAP</span>
<DD>
<pre>
‚ä¢ ‚àÄf l1 l2. l1 ‚âº l2 ‚áí MAP f l1 ‚âº MAP f l2
</pre>

<DT><span class="strong">isPREFIX_NIL</span>
<DD>
<pre>
‚ä¢ ‚àÄx. [] ‚âº x ‚àß (x ‚âº [] ‚áî x = [])
</pre>

<DT><span class="strong">isPREFIX_NILR</span>
<DD>
<pre>
‚ä¢ x ‚âº [] ‚áî x = []
</pre>

<DT><span class="strong">isPREFIX_REFL</span>
<DD>
<pre>
‚ä¢ ‚àÄx. x ‚âº x
</pre>

<DT><span class="strong">isPREFIX_SNOC</span>
<DD>
<pre>
‚ä¢ l ‚âº SNOC x l
</pre>

<DT><span class="strong">isPREFIX_SNOC_EQ</span>
<DD>
<pre>
‚ä¢ ‚àÄx y z. z ‚âº SNOC x y ‚áî z ‚âº y ‚à® z = SNOC x y
</pre>

<DT><span class="strong">isPREFIX_THM</span>
<DD>
<pre>
‚ä¢ ([] ‚âº l ‚áî T) ‚àß (h::t ‚âº [] ‚áî F) ‚àß (h1::t1 ‚âº h2::t2 ‚áî h1 = h2 ‚àß t1 ‚âº t2)
</pre>

<DT><span class="strong">isPREFIX_TRANS</span>
<DD>
<pre>
‚ä¢ ‚àÄx y z. x ‚âº y ‚àß y ‚âº z ‚áí x ‚âº z
</pre>

<DT><span class="strong">last_drop</span>
<DD>
<pre>
‚ä¢ ‚àÄl n. n < LENGTH l ‚áí LAST (DROP n l) = LAST l
</pre>

<DT><span class="strong">lazy_list_case_compute</span>
<DD>
<pre>
‚ä¢ list_CASE = (Œªl b f. if NULL l then b else f (HD l) (TL l))
</pre>

<DT><span class="strong">length_nub_append</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2.
    LENGTH (nub (l1 ++ l2)) =
    LENGTH (nub l1) + LENGTH (nub (FILTER (Œªx. ¬¨MEM x l1) l2))
</pre>

<DT><span class="strong">list_11</span>
<DD>
<pre>
‚ä¢ ‚àÄa0 a1 a0' a1'. a0::a1 = a0'::a1' ‚áî a0 = a0' ‚àß a1 = a1'
</pre>

<DT><span class="strong">list_Axiom</span>
<DD>
<pre>
‚ä¢ ‚àÄf0 f1. ‚àÉfn. fn [] = f0 ‚àß ‚àÄa0 a1. fn (a0::a1) = f1 a0 a1 (fn a1)
</pre>

<DT><span class="strong">list_Axiom_old</span>
<DD>
<pre>
‚ä¢ ‚àÄx f. ‚àÉ!fn1. fn1 [] = x ‚àß ‚àÄh t. fn1 (h::t) = f (fn1 t) h t
</pre>

<DT><span class="strong">list_CASES</span>
<DD>
<pre>
‚ä¢ ‚àÄl. l = [] ‚à® ‚àÉh t. l = h::t
</pre>

<DT><span class="strong">list_INDUCT</span>
<DD>
<pre>
‚ä¢ ‚àÄP. P [] ‚àß (‚àÄt. P t ‚áí ‚àÄh. P (h::t)) ‚áí ‚àÄl. P l
</pre>

<DT><span class="strong">list_INDUCT0</span>
<DD>
<pre>
‚ä¢ ‚àÄP. P [] ‚àß (‚àÄl. P l ‚áí ‚àÄa. P (a::l)) ‚áí ‚àÄl. P l
</pre>

<DT><span class="strong">list_case_compute</span>
<DD>
<pre>
‚ä¢ ‚àÄl. list_CASE l b f = if NULL l then b else f (HD l) (TL l)
</pre>

<DT><span class="strong">list_case_cong</span>
<DD>
<pre>
‚ä¢ ‚àÄM M' v f.
    M = M' ‚àß (M' = [] ‚áí v = v') ‚àß (‚àÄa0 a1. M' = a0::a1 ‚áí f a0 a1 = f' a0 a1) ‚áí
    list_CASE M v f = list_CASE M' v' f'
</pre>

<DT><span class="strong">list_case_eq</span>
<DD>
<pre>
‚ä¢ list_CASE x v f = v' ‚áî x = [] ‚àß v = v' ‚à® ‚àÉa l. x = a::l ‚àß f a l = v'
</pre>

<DT><span class="strong">list_distinct</span>
<DD>
<pre>
‚ä¢ ‚àÄa1 a0. [] ‚â† a0::a1
</pre>

<DT><span class="strong">list_induction</span>
<DD>
<pre>
‚ä¢ ‚àÄP. P [] ‚àß (‚àÄt. P t ‚áí ‚àÄh. P (h::t)) ‚áí ‚àÄl. P l
</pre>

<DT><span class="strong">list_nchotomy</span>
<DD>
<pre>
‚ä¢ ‚àÄl. l = [] ‚à® ‚àÉh t. l = h::t
</pre>

<DT><span class="strong">list_size_append</span>
<DD>
<pre>
‚ä¢ ‚àÄf xs ys. list_size f (xs ++ ys) = list_size f xs + list_size f ys
</pre>

<DT><span class="strong">list_size_cong</span>
<DD>
<pre>
‚ä¢ ‚àÄM N f f'.
    M = N ‚àß (‚àÄx. MEM x N ‚áí f x = f' x) ‚áí list_size f M = list_size f' N
</pre>

<DT><span class="strong">list_size_drop</span>
<DD>
<pre>
‚ä¢ ‚àÄl n. list_size f (DROP n l) ‚â§ list_size f l
</pre>

<DT><span class="strong">list_size_filter</span>
<DD>
<pre>
‚ä¢ list_size f (FILTER P l) ‚â§ list_size f l
</pre>

<DT><span class="strong">list_size_map</span>
<DD>
<pre>
‚ä¢ list_size f (MAP g l) = list_size (Œªx. f (g x)) l
</pre>

<DT><span class="strong">list_size_reverse</span>
<DD>
<pre>
‚ä¢ list_size f (REVERSE l) = list_size f l
</pre>

<DT><span class="strong">list_size_snoc</span>
<DD>
<pre>
‚ä¢ list_size f (SNOC x l) = list_size f (x::l)
</pre>

<DT><span class="strong">list_size_take</span>
<DD>
<pre>
‚ä¢ ‚àÄl n. list_size f (TAKE n l) ‚â§ list_size f l
</pre>

<DT><span class="strong">list_size_thm</span>
<DD>
<pre>
‚ä¢ (‚àÄf. list_size f [] = 0) ‚àß
  ‚àÄf a0 a1. list_size f (a0::a1) = 1 + f a0 + list_size f a1
</pre>

<DT><span class="strong">list_size_zip</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2.
    LENGTH l1 = LENGTH l2 ‚áí
    list_size (pair_size f1 f2) (ZIP (l1,l2)) =
    list_size f1 l1 + list_size f2 l2
</pre>

<DT><span class="strong">list_to_set_diff</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2.
    LIST_TO_SET l2 DIFF LIST_TO_SET l1 =
    LIST_TO_SET (FILTER (Œªx. ¬¨MEM x l1) l2)
</pre>

<DT><span class="strong">lupdate_append</span>
<DD>
<pre>
‚ä¢ ‚àÄx n l1 l2. n < LENGTH l1 ‚áí LUPDATE x n (l1 ++ l2) = LUPDATE x n l1 ++ l2
</pre>

<DT><span class="strong">lupdate_append2</span>
<DD>
<pre>
‚ä¢ ‚àÄv l1 x l2 l3. LUPDATE v (LENGTH l1) (l1 ++ [x] ++ l2) = l1 ++ [v] ++ l2
</pre>

<DT><span class="strong">mapPartial_EQ_CONS</span>
<DD>
<pre>
‚ä¢ ‚àÄf xs y ys.
    mapPartial f xs = y::ys ‚áî
    ‚àÉp x s.
      xs = p ++ [x] ++ s ‚àß (‚àÄx0. MEM x0 p ‚áí f x0 = NONE) ‚àß f x = SOME y ‚àß
      mapPartial f s = ys
</pre>

<DT><span class="strong">mapPartial_EQ_NIL</span>
<DD>
<pre>
‚ä¢ mapPartial f xs = [] ‚áî ‚àÄx. MEM x xs ‚áí f x = NONE
</pre>

<DT><span class="strong">mem_exists_set</span>
<DD>
<pre>
‚ä¢ ‚àÄx y l. MEM (x,y) l ‚áí ‚àÉz. x = FST z ‚àß MEM z l
</pre>

<DT><span class="strong">nub_EQ0</span>
<DD>
<pre>
‚ä¢ nub l = [] ‚áî l = []
</pre>

<DT><span class="strong">nub_MAP_INJ</span>
<DD>
<pre>
‚ä¢ INJ f (LIST_TO_SET ls) ùïå(:Œ≤) ‚áí nub (MAP f ls) = MAP f (nub ls)
</pre>

<DT><span class="strong">nub_NIL</span>
<DD>
<pre>
‚ä¢ nub [] = []
</pre>

<DT><span class="strong">nub_append</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2. nub (l1 ++ l2) = nub (FILTER (Œªx. ¬¨MEM x l2) l1) ++ nub l2
</pre>

<DT><span class="strong">nub_set</span>
<DD>
<pre>
‚ä¢ ‚àÄl. LIST_TO_SET (nub l) = LIST_TO_SET l
</pre>

<DT><span class="strong">oEL_DROP</span>
<DD>
<pre>
‚ä¢ oEL n (DROP m xs) = oEL (m + n) xs
</pre>

<DT><span class="strong">oEL_EQ_EL</span>
<DD>
<pre>
‚ä¢ ‚àÄxs n y. oEL n xs = SOME y ‚áî n < LENGTH xs ‚àß y = EL n xs
</pre>

<DT><span class="strong">oEL_LUPDATE</span>
<DD>
<pre>
‚ä¢ ‚àÄxs i n x.
    oEL n (LUPDATE x i xs) =
    if i ‚â† n then oEL n xs else if i < LENGTH xs then SOME x else NONE
</pre>

<DT><span class="strong">oEL_TAKE_E</span>
<DD>
<pre>
‚ä¢ oEL n (TAKE m xs) = SOME x ‚áí oEL n xs = SOME x
</pre>

<DT><span class="strong">oEL_THM</span>
<DD>
<pre>
‚ä¢ ‚àÄxs n. oEL n xs = if n < LENGTH xs then SOME (EL n xs) else NONE
</pre>

<DT><span class="strong">oHD_thm</span>
<DD>
<pre>
‚ä¢ oHD [] = NONE ‚àß oHD (h::t) = SOME h
</pre>

<DT><span class="strong">splitAtPki_APPEND</span>
<DD>
<pre>
‚ä¢ ‚àÄl1 l2 P k.
    EVERYi (Œªi. $¬¨ ‚àò P i) l1 ‚àß (0 < LENGTH l2 ‚áí P (LENGTH l1) (HD l2)) ‚áí
    splitAtPki P k (l1 ++ l2) = k l1 l2
</pre>

<DT><span class="strong">splitAtPki_EQN</span>
<DD>
<pre>
‚ä¢ splitAtPki P k l =
  case OLEAST i. i < LENGTH l ‚àß P i (EL i l) of
    NONE => k l []
  | SOME i => k (TAKE i l) (DROP i l)
</pre>

<DT><span class="strong">splitAtPki_MAP</span>
<DD>
<pre>
‚ä¢ splitAtPki P k (MAP f l) =
  splitAtPki (flip ($o ‚àò P) f) (flip ($o ‚àò k ‚àò MAP f) (MAP f)) l
</pre>

<DT><span class="strong">splitAtPki_RAND</span>
<DD>
<pre>
‚ä¢ f (splitAtPki P k l) = splitAtPki P ($o f ‚àò k) l
</pre>

<DT><span class="strong">splitAtPki_change_predicate</span>
<DD>
<pre>
‚ä¢ (‚àÄi. i < LENGTH l ‚áí (P1 i (EL i l) ‚áî P2 i (EL i l))) ‚áí
  splitAtPki P1 k l = splitAtPki P2 k l
</pre>

</DL>



<hr>
</body>
</html>
