<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: itreeTau</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "itreeTau"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "alistTheory.html"><span class="strong">alist</span></a>&nbsp;&nbsp;
    <a href = "llistTheory.html"><span class="strong">llist</span></a>&nbsp;&nbsp;
    <a href = "itreeTheory.html"><span class="strong">itree</span></a>&nbsp;&nbsp;
    <a href = "companionTheory.html"><span class="strong">companion</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Type <th> Arity<tr><td> <span class="strong">itree</span> <td> 3
    <tr><td> <span class="strong">itree_el</span> <td> 2
    <tr><td> <span class="strong">itree_next</span> <td> 4
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">Event</span>
    <td>
    :ε -> (ε, ς) itree_el
    <tr><td> <span class="strong">Ret</span> <td> :γ -> (α, β, γ) itree
    <tr><td>
    <span class="strong">Ret'</span>
    <td>
    :ς -> (α, ε, ς, 'seed) itree_next
    <tr><td>
    <span class="strong">Ret_rep</span>
    <td>
    :ς -> α list -> (β, ς) itree_el
    <tr><td> <span class="strong">Return</span> <td> :ς -> (ε, ς) itree_el
    <tr><td> <span class="strong">Silence</span> <td> :(ε, ς) itree_el
    <tr><td>
    <span class="strong">Tau</span>
    <td>
    :(α, β, γ) itree -> (α, β, γ) itree
    <tr><td>
    <span class="strong">Tau'</span>
    <td>
    :'seed -> (α, ε, ς, 'seed) itree_next
    <tr><td>
    <span class="strong">Tau_rep</span>
    <td>
    :(α option list -> (ε, ς) itree_el) -> α option list -> (ε, ς) itree_el
    <tr><td>
    <span class="strong">Vis</span>
    <td>
    :β -> (α -> (α, β, γ) itree) -> (α, β, γ) itree
    <tr><td>
    <span class="strong">Vis'</span>
    <td>
    :ε -> (α -> 'seed) -> (α, ε, ς, 'seed) itree_next
    <tr><td>
    <span class="strong">Vis_rep</span>
    <td>
    :β ->
    (α -> α option list -> (β, γ) itree_el) ->
    α option list -> (β, γ) itree_el
    <tr><td>
    <span class="strong">after_taus</span>
    <td>
    :((α, β, γ) itree -> (δ, ε, ζ) itree -> bool) ->
    (α, β, γ) itree -> (δ, ε, ζ) itree -> bool
    <tr><td>
    <span class="strong">itree_CASE</span>
    <td>
    :(α, ε, ς) itree ->
    (ς -> β) ->
    ((α, ε, ς) itree -> β) -> (ε -> (α -> (α, ε, ς) itree) -> β) -> β
    <tr><td>
    <span class="strong">itree_abs</span>
    <td>
    :(α option list -> (ε, ς) itree_el) -> (α, ε, ς) itree
    <tr><td>
    <span class="strong">itree_bind</span>
    <td>
    :(α, β, δ) itree -> (δ -> (α, β, γ) itree) -> (α, β, γ) itree
    <tr><td>
    <span class="strong">itree_el</span>
    <td>
    :(γ, α, β) itree -> γ option list -> (α, β) itree_el
    <tr><td>
    <span class="strong">itree_el_CASE</span>
    <td>
    :(ε, ς) itree_el -> (ε -> α) -> (ς -> α) -> α -> α
    <tr><td>
    <span class="strong">itree_el_size</span>
    <td>
    :(ε -> num) -> (ς -> num) -> (ε, ς) itree_el -> num
    <tr><td>
    <span class="strong">itree_iter</span>
    <td>
    :(δ -> (α, β, δ + γ) itree) -> δ -> (α, β, γ) itree
    <tr><td>
    <span class="strong">itree_loop</span>
    <td>
    :(δ + ε -> (α, β, δ + γ) itree) -> ε -> (α, β, γ) itree
    <tr><td>
    <span class="strong">itree_next_CASE</span>
    <td>
    :(α, ε, ς, 'seed) itree_next ->
    (ς -> β) -> ('seed -> β) -> (ε -> (α -> 'seed) -> β) -> β
    <tr><td>
    <span class="strong">itree_next_size</span>
    <td>
    :(α -> num) ->
    (ε -> num) ->
    (ς -> num) -> ('seed -> num) -> (α, ε, ς, 'seed) itree_next -> num
    <tr><td>
    <span class="strong">itree_rep</span>
    <td>
    :(α, ε, ς) itree -> α option list -> (ε, ς) itree_el
    <tr><td>
    <span class="strong">itree_rep_ok</span>
    <td>
    :(α option list -> (ε, ς) itree_el) -> bool
    <tr><td>
    <span class="strong">itree_unfold</span>
    <td>
    :(δ -> (α, β, γ, δ) itree_next) -> δ -> (α, β, γ) itree
    <tr><td>
    <span class="strong">itree_unfold_path</span>
    <td>
    :(γ -> (δ, α, β, γ) itree_next) -> γ -> δ option list -> (α, β) itree_el
    <tr><td>
    <span class="strong">itree_wbisim</span>
    <td>
    :(α, β, γ) itree -> (α, β, γ) itree -> bool
    <tr><td>
    <span class="strong">path_ok</span>
    <td>
    :α option list -> (α option list -> (ε, ς) itree_el) -> bool
    <tr><td> <span class="strong">spin</span> <td> :(α, β, γ) itree
    <tr><td>
    <span class="strong">strip_tau</span>
    <td>
    :(α, β, γ) itree -> (α, β, γ) itree -> bool
    <tr><td>
    <span class="strong">untau</span>
    <td>
    :(α, β, γ) itree -> (α, β, γ) itree$itree
    <tr><td>
    <span class="strong">upto_taus_func</span>
    <td>
    :((α, β, γ) itree # (δ, ε, ζ) itree -> bool) ->
    (α, β, γ) itree # (δ, ε, ζ) itree -> bool
    <tr><td>
    <span class="strong">wbisim_functional</span>
    <td>
    :((α, β, γ) itree # (α, β, γ) itree -> bool) ->
    (α, β, γ) itree # (α, β, γ) itree -> bool
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">@tempafter_taus_def</span>
<DD>
<pre>
⊢ after_taus =
  (λR a0 a1.
       ∀after_taus'.
         (∀a0 a1.
            R a0 a1 ∨ (∃x. a0 = Tau x ∧ after_taus' x a1) ∨
            (∃y. a1 = Tau y ∧ after_taus' a0 y) ⇒
            after_taus' a0 a1) ⇒
         after_taus' a0 a1)
</pre>

<DT><span class="strong">@tempitree_wbisim_def</span>
<DD>
<pre>
⊢ itree_wbisim =
  (λa0 a1.
       ∃itree_wbisim'.
         itree_wbisim' a0 a1 ∧
         ∀a0 a1.
           itree_wbisim' a0 a1 ⇒
           (∃t t'. a0 = Tau t ∧ a1 = Tau t' ∧ itree_wbisim' t t') ∨
           (∃e k k'.
              strip_tau a0 (Vis e k) ∧ strip_tau a1 (Vis e k') ∧
              ∀r. itree_wbisim' (k r) (k' r)) ∨
           ∃r. strip_tau a0 (Ret r) ∧ strip_tau a1 (Ret r))
</pre>

<DT><span class="strong">@tempstrip_tau_def</span>
<DD>
<pre>
⊢ strip_tau =
  (λa0 a1.
       ∀strip_tau'.
         (∀a0 a1.
            (∃t. a0 = Tau t ∧ strip_tau' t a1) ∨
            (∃e k. a0 = Vis e k ∧ a1 = Vis e k) ∨
            (∃v. a0 = Ret v ∧ a1 = Ret v) ⇒
            strip_tau' a0 a1) ⇒
         strip_tau' a0 a1)
</pre>

<DT><span class="strong">itree_TY_DEF</span>
<DD>
<pre>
⊢ ∃rep. TYPE_DEFINITION itree_rep_ok rep
</pre>

<DT><span class="strong">itree_bind_def</span>
<DD>
<pre>
⊢ ∀t k.
    itree_bind t k =
    itree_unfold
      (λx.
           case x of
             INL (Ret r) =>
               (case k r of
                  Ret s => Ret' s
                | Tau t => Tau' (INR t)
                | Vis e g => Vis' e (INR ∘ g))
           | INL (Tau t) => Tau' (INL t)
           | INL (Vis e g) => Vis' e (INL ∘ g)
           | INR (Ret r') => Ret' r'
           | INR (Tau t') => Tau' (INR t')
           | INR (Vis e' g') => Vis' e' (INR ∘ g')) (INL t)
</pre>

<DT><span class="strong">itree_el_case_def</span>
<DD>
<pre>
⊢ (∀a f f1 v. itree_el_CASE (Event a) f f1 v = f a) ∧
  (∀a f f1 v. itree_el_CASE (Return a) f f1 v = f1 a) ∧
  ∀f f1 v. itree_el_CASE Silence f f1 v = v
</pre>

<DT><span class="strong">itree_el_size_def</span>
<DD>
<pre>
⊢ (∀f f1 a. itree_el_size f f1 (Event a) = 1 + f a) ∧
  (∀f f1 a. itree_el_size f f1 (Return a) = 1 + f1 a) ∧
  ∀f f1. itree_el_size f f1 Silence = 0
</pre>

<DT><span class="strong">itree_iter_def</span>
<DD>
<pre>
⊢ ∀body seed.
    itree_iter body seed =
    itree_unfold
      (λx.
           case x of
             Ret (INL seed') => Tau' (body seed')
           | Ret (INR v) => Ret' v
           | Tau u => Tau' u
           | Vis e g => Vis' e g) (body seed)
</pre>

<DT><span class="strong">itree_loop_def</span>
<DD>
<pre>
⊢ ∀body seed.
    itree_loop body seed =
    itree_iter
      (λx.
           itree_bind (body x)
             (λcb.
                  case cb of INL c => Ret (INL (INL c)) | INR b => Ret (INR b)))
      (INR seed)
</pre>

<DT><span class="strong">itree_next_case_def</span>
<DD>
<pre>
⊢ (∀a f f1 f2. itree_next_CASE (Ret' a) f f1 f2 = f a) ∧
  (∀a f f1 f2. itree_next_CASE (Tau' a) f f1 f2 = f1 a) ∧
  ∀a0 a1 f f1 f2. itree_next_CASE (Vis' a0 a1) f f1 f2 = f2 a0 a1
</pre>

<DT><span class="strong">itree_next_size_def</span>
<DD>
<pre>
⊢ (∀f f1 f2 f3 a. itree_next_size f f1 f2 f3 (Ret' a) = 1 + f2 a) ∧
  (∀f f1 f2 f3 a. itree_next_size f f1 f2 f3 (Tau' a) = 1 + f3 a) ∧
  ∀f f1 f2 f3 a0 a1. itree_next_size f f1 f2 f3 (Vis' a0 a1) = 1 + f1 a0
</pre>

<DT><span class="strong">untau_def</span>
<DD>
<pre>
⊢ untau =
  itree_unfold
    (λt.
         case some t'. strip_tau t t' of
           NONE => Div'
         | SOME (Ret v) => Ret' v
         | SOME (Tau t') => Div'
         | SOME (Vis e k) => Vis' e k)
</pre>

<DT><span class="strong">upto_taus_func_def</span>
<DD>
<pre>
⊢ ∀R. upto_taus_func R = R ∪ rel_to_reln (after_taus (reln_to_rel R))
</pre>

<DT><span class="strong">wbisim_functional_def</span>
<DD>
<pre>
⊢ ∀R. wbisim_functional R =
      {(t,t') | ∃r. strip_tau t (Ret r) ∧ strip_tau t' (Ret r)} ∪
      {(t,t') |
       ∃e k k'.
         strip_tau t (Vis e k) ∧ strip_tau t' (Vis e k') ∧ ∀r. (k r,k' r) ∈ R} ∪
      {(Tau t,Tau t') | (t,t') ∈ R}
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">FUNPOW_Tau_Ret_eq</span>
<DD>
<pre>
⊢ FUNPOW Tau n (Ret x) = FUNPOW Tau m (Ret y) ⇒ n = m ∧ x = y
</pre>

<DT><span class="strong">FUNPOW_Tau_Vis_eq</span>
<DD>
<pre>
⊢ FUNPOW Tau n (Vis a g) = FUNPOW Tau m (Vis e k) ⇒ n = m ∧ a = e ∧ g = k
</pre>

<DT><span class="strong">FUNPOW_Tau_bind</span>
<DD>
<pre>
⊢ itree_bind (FUNPOW Tau n t) g = FUNPOW Tau n (itree_bind t g)
</pre>

<DT><span class="strong">FUNPOW_Tau_imp_wbisim</span>
<DD>
<pre>
⊢ t = FUNPOW Tau n t' ⇒ itree_wbisim t t'
</pre>

<DT><span class="strong">FUNPOW_Tau_neq</span>
<DD>
<pre>
⊢ Ret x ≠ FUNPOW Tau n (Vis a g) ∧ Vis a g ≠ FUNPOW Tau n (Ret x)
</pre>

<DT><span class="strong">FUNPOW_Tau_neq2</span>
<DD>
<pre>
⊢ FUNPOW Tau n' (Ret x) ≠ FUNPOW Tau n (Vis a g)
</pre>

<DT><span class="strong">FUNPOW_Tau_wbisim</span>
<DD>
<pre>
⊢ itree_wbisim (FUNPOW Tau n x) x
</pre>

<DT><span class="strong">FUNPOW_Tau_wbisim_intro</span>
<DD>
<pre>
⊢ itree_wbisim x y ⇒ itree_wbisim (FUNPOW Tau n x) (FUNPOW Tau n' y)
</pre>

<DT><span class="strong">Ret_11</span>
<DD>
<pre>
⊢ ∀x y. Ret x = Ret y ⇔ x = y
</pre>

<DT><span class="strong">Tau_11</span>
<DD>
<pre>
⊢ ∀x y. Tau x = Tau y ⇔ x = y
</pre>

<DT><span class="strong">Tau_INJ</span>
<DD>
<pre>
⊢ INJ Tau 𝕌(:(α, β, γ) itree) 𝕌(:(α, β, γ) itree)
</pre>

<DT><span class="strong">Vis_11</span>
<DD>
<pre>
⊢ ∀x f y g. Vis x f = Vis y g ⇔ x = y ∧ f = g
</pre>

<DT><span class="strong">after_taus_cases</span>
<DD>
<pre>
⊢ ∀R a0 a1.
    after_taus R a0 a1 ⇔
    R a0 a1 ∨ (∃x. a0 = Tau x ∧ after_taus R x a1) ∨
    ∃y. a1 = Tau y ∧ after_taus R a0 y
</pre>

<DT><span class="strong">after_taus_ind</span>
<DD>
<pre>
⊢ ∀R after_taus'.
    (∀x y. R x y ⇒ after_taus' x y) ∧
    (∀x y. after_taus' x y ⇒ after_taus' (Tau x) y) ∧
    (∀x y. after_taus' x y ⇒ after_taus' x (Tau y)) ⇒
    ∀a0 a1. after_taus R a0 a1 ⇒ after_taus' a0 a1
</pre>

<DT><span class="strong">after_taus_rel</span>
<DD>
<pre>
⊢ ∀R x y. R x y ⇒ after_taus R x y
</pre>

<DT><span class="strong">after_taus_rules</span>
<DD>
<pre>
⊢ ∀R. (∀x y. R x y ⇒ after_taus R x y) ∧
      (∀x y. after_taus R x y ⇒ after_taus R (Tau x) y) ∧
      ∀x y. after_taus R x y ⇒ after_taus R x (Tau y)
</pre>

<DT><span class="strong">after_taus_strongind</span>
<DD>
<pre>
⊢ ∀R after_taus'.
    (∀x y. R x y ⇒ after_taus' x y) ∧
    (∀x y. after_taus R x y ∧ after_taus' x y ⇒ after_taus' (Tau x) y) ∧
    (∀x y. after_taus R x y ∧ after_taus' x y ⇒ after_taus' x (Tau y)) ⇒
    ∀a0 a1. after_taus R a0 a1 ⇒ after_taus' a0 a1
</pre>

<DT><span class="strong">after_taus_tauL</span>
<DD>
<pre>
⊢ ∀R x y. after_taus R x y ⇒ after_taus R (Tau x) y
</pre>

<DT><span class="strong">after_taus_tauR</span>
<DD>
<pre>
⊢ ∀R x y. after_taus R x y ⇒ after_taus R x (Tau y)
</pre>

<DT><span class="strong">datatype_itree</span>
<DD>
<pre>
⊢ DATATYPE (itree Ret Tau Vis)
</pre>

<DT><span class="strong">datatype_itree_el</span>
<DD>
<pre>
⊢ DATATYPE (itree_el Event Return Silence)
</pre>

<DT><span class="strong">datatype_itree_next</span>
<DD>
<pre>
⊢ DATATYPE (itree_next Ret' Tau' Vis')
</pre>

<DT><span class="strong">itree_11</span>
<DD>
<pre>
⊢ (∀x y. Ret x = Ret y ⇔ x = y) ∧ (∀x y. Tau x = Tau y ⇔ x = y) ∧
  ∀x f y g. Vis x f = Vis y g ⇔ x = y ∧ f = g
</pre>

<DT><span class="strong">itree_CASE</span>
<DD>
<pre>
⊢ itree_CASE (Ret r) ret tau vis = ret r ∧
  itree_CASE (Tau t) ret tau vis = tau t ∧
  itree_CASE (Vis a g) ret tau vis = vis a g
</pre>

<DT><span class="strong">itree_CASE_cong</span>
<DD>
<pre>
⊢ ∀M M' ret tau vis ret' tau' vis'.
    M = M' ∧ (∀x. M' = Ret x ⇒ ret x = ret' x) ∧
    (∀t. M' = Tau t ⇒ tau t = tau' t) ∧
    (∀a g. M' = Vis a g ⇒ vis a g = vis' a g) ⇒
    itree_CASE M ret tau vis = itree_CASE M' ret' tau' vis'
</pre>

<DT><span class="strong">itree_CASE_elim</span>
<DD>
<pre>
⊢ ∀f. f (itree_CASE t ret tau vis) ⇔
      (∃r. t = Ret r ∧ f (ret r)) ∨ (∃u. t = Tau u ∧ f (tau u)) ∨
      ∃a g. t = Vis a g ∧ f (vis a g)
</pre>

<DT><span class="strong">itree_CASE_eq</span>
<DD>
<pre>
⊢ itree_CASE t ret tau vis = v ⇔
  (∃r. t = Ret r ∧ ret r = v) ∨ (∃u. t = Tau u ∧ tau u = v) ∨
  ∃a g. t = Vis a g ∧ vis a g = v
</pre>

<DT><span class="strong">itree_bind_assoc</span>
<DD>
<pre>
⊢ itree_bind (itree_bind t k) k' = itree_bind t (λx. itree_bind (k x) k')
</pre>

<DT><span class="strong">itree_bind_resp_k_wbisim</span>
<DD>
<pre>
⊢ ∀t k1 k2.
    (∀r. itree_wbisim (k1 r) (k2 r)) ⇒
    itree_wbisim (itree_bind t k1) (itree_bind t k2)
</pre>

<DT><span class="strong">itree_bind_resp_t_wbisim</span>
<DD>
<pre>
⊢ ∀a b k. itree_wbisim a b ⇒ itree_wbisim (itree_bind a k) (itree_bind b k)
</pre>

<DT><span class="strong">itree_bind_resp_wbisim</span>
<DD>
<pre>
⊢ ∀a b k1 k2.
    itree_wbisim a b ∧ (∀r. itree_wbisim (k1 r) (k2 r)) ⇒
    itree_wbisim (itree_bind a k1) (itree_bind b k2)
</pre>

<DT><span class="strong">itree_bind_ret_inv</span>
<DD>
<pre>
⊢ itree_bind t k = Ret r ⇒ ∃r'. t = Ret r' ∧ k r' = Ret r
</pre>

<DT><span class="strong">itree_bind_right_identity</span>
<DD>
<pre>
⊢ itree_bind t Ret = t
</pre>

<DT><span class="strong">itree_bind_strip_tau_wbisim</span>
<DD>
<pre>
⊢ ∀u u' k. strip_tau u u' ⇒ itree_wbisim (itree_bind u k) (itree_bind u' k)
</pre>

<DT><span class="strong">itree_bind_thm</span>
<DD>
<pre>
⊢ itree_bind (Ret r) k = k r ∧ itree_bind (Tau t) k = Tau (itree_bind t k) ∧
  itree_bind (Vis e k') k = Vis e (λx. itree_bind (k' x) k)
</pre>

<DT><span class="strong">itree_bind_vis_strip_tau</span>
<DD>
<pre>
⊢ ∀u k k' e.
    strip_tau u (Vis e k') ⇒
    strip_tau (itree_bind u k) (Vis e (λx. itree_bind (k' x) k))
</pre>

<DT><span class="strong">itree_bisimulation</span>
<DD>
<pre>
⊢ ∀t1 t2.
    t1 = t2 ⇔
    ∃R. R t1 t2 ∧ (∀x t. R (Ret x) t ⇒ t = Ret x) ∧
        (∀u t. R (Tau u) t ⇒ ∃v. t = Tau v ∧ R u v) ∧
        ∀a f t. R (Vis a f) t ⇒ ∃g. t = Vis a g ∧ ∀s. R (f s) (g s)
</pre>

<DT><span class="strong">itree_cases</span>
<DD>
<pre>
⊢ ∀t. (∃x. t = Ret x) ∨ (∃u. t = Tau u) ∨ ∃a g. t = Vis a g
</pre>

<DT><span class="strong">itree_coind_upto_taus</span>
<DD>
<pre>
⊢ ∀R. rel_to_reln R ⊆
      rel_to_reln itree_wbisim ∪
      wbisim_functional
        (upto_taus_func (rel_to_reln R) ∪ rel_to_reln itree_wbisim) ⇒
      rel_to_reln R ⊆ rel_to_reln itree_wbisim
</pre>

<DT><span class="strong">itree_distinct</span>
<DD>
<pre>
⊢ Ret x ≠ Tau t ∧ Ret x ≠ Vis e g ∧ Tau t ≠ Vis e g
</pre>

<DT><span class="strong">itree_el_11</span>
<DD>
<pre>
⊢ (∀a a'. Event a = Event a' ⇔ a = a') ∧ ∀a a'. Return a = Return a' ⇔ a = a'
</pre>

<DT><span class="strong">itree_el_Axiom</span>
<DD>
<pre>
⊢ ∀f0 f1 f2. ∃fn.
    (∀a. fn (Event a) = f0 a) ∧ (∀a. fn (Return a) = f1 a) ∧ fn Silence = f2
</pre>

<DT><span class="strong">itree_el_case_cong</span>
<DD>
<pre>
⊢ ∀M M' f f1 v.
    M = M' ∧ (∀a. M' = Event a ⇒ f a = f' a) ∧
    (∀a. M' = Return a ⇒ f1 a = f1' a) ∧ (M' = Silence ⇒ v = v') ⇒
    itree_el_CASE M f f1 v = itree_el_CASE M' f' f1' v'
</pre>

<DT><span class="strong">itree_el_case_eq</span>
<DD>
<pre>
⊢ itree_el_CASE x f f1 v = v' ⇔
  (∃e. x = Event e ∧ f e = v') ∨ (∃r. x = Return r ∧ f1 r = v') ∨
  x = Silence ∧ v = v'
</pre>

<DT><span class="strong">itree_el_def</span>
<DD>
<pre>
⊢ (∀t. itree_el t [] =
       case t of Ret r => Return r | Tau t => Silence | Vis e g => Event e) ∧
  (∀t ns.
     itree_el t (NONE::ns) =
     case t of
       Ret r => Silence
     | Tau t' => itree_el t' ns
     | Vis e g => Silence) ∧
  ∀t ns a.
    itree_el t (SOME a::ns) =
    case t of
      Ret r => Silence
    | Tau t => Silence
    | Vis e g => itree_el (g a) ns
</pre>

<DT><span class="strong">itree_el_distinct</span>
<DD>
<pre>
⊢ (∀a' a. Event a ≠ Return a') ∧ (∀a. Event a ≠ Silence) ∧
  ∀a. Return a ≠ Silence
</pre>

<DT><span class="strong">itree_el_eqv</span>
<DD>
<pre>
⊢ ∀t1 t2. t1 = t2 ⇔ ∀path. itree_el t1 path = itree_el t2 path
</pre>

<DT><span class="strong">itree_el_ind</span>
<DD>
<pre>
⊢ ∀P. (∀t. P t []) ∧ (∀t ns. (∀t'. P t' ns) ⇒ P t (NONE::ns)) ∧
      (∀t a ns. (∀g. P (g a) ns) ⇒ P t (SOME a::ns)) ⇒
      ∀v v1. P v v1
</pre>

<DT><span class="strong">itree_el_induction</span>
<DD>
<pre>
⊢ ∀P. (∀e. P (Event e)) ∧ (∀r. P (Return r)) ∧ P Silence ⇒ ∀i. P i
</pre>

<DT><span class="strong">itree_el_nchotomy</span>
<DD>
<pre>
⊢ ∀ii. (∃e. ii = Event e) ∨ (∃r. ii = Return r) ∨ ii = Silence
</pre>

<DT><span class="strong">itree_el_thm</span>
<DD>
<pre>
⊢ itree_el (Ret r) [] = Return r ∧ itree_el (Tau t) [] = Silence ∧
  itree_el (Vis e g) [] = Event e ∧ itree_el (Ret r) (NONE::ns) = Silence ∧
  itree_el (Tau t) (NONE::ns) = itree_el t ns ∧
  itree_el (Vis e g) (NONE::ns) = Silence ∧
  itree_el (Ret r) (SOME a::ns) = Silence ∧
  itree_el (Tau t) (SOME a::ns) = Silence ∧
  itree_el (Vis e g) (SOME a::ns) = itree_el (g a) ns
</pre>

<DT><span class="strong">itree_iter_resp_wbisim</span>
<DD>
<pre>
⊢ ∀t k1 k2.
    (∀r. itree_wbisim (k1 r) (k2 r)) ⇒
    itree_wbisim (itree_iter k1 t) (itree_iter k2 t)
</pre>

<DT><span class="strong">itree_iter_thm</span>
<DD>
<pre>
⊢ itree_iter body seed =
  itree_bind (body seed)
    (λx. case x of INL a => Tau (itree_iter body a) | INR b => Ret b)
</pre>

<DT><span class="strong">itree_next_11</span>
<DD>
<pre>
⊢ (∀a a'. Ret' a = Ret' a' ⇔ a = a') ∧ (∀a a'. Tau' a = Tau' a' ⇔ a = a') ∧
  ∀a0 a1 a0' a1'. Vis' a0 a1 = Vis' a0' a1' ⇔ a0 = a0' ∧ a1 = a1'
</pre>

<DT><span class="strong">itree_next_Axiom</span>
<DD>
<pre>
⊢ ∀f0 f1 f2. ∃fn.
    (∀a. fn (Ret' a) = f0 a) ∧ (∀a. fn (Tau' a) = f1 a) ∧
    ∀a0 a1. fn (Vis' a0 a1) = f2 a0 a1
</pre>

<DT><span class="strong">itree_next_case_cong</span>
<DD>
<pre>
⊢ ∀M M' f f1 f2.
    M = M' ∧ (∀a. M' = Ret' a ⇒ f a = f' a) ∧
    (∀a. M' = Tau' a ⇒ f1 a = f1' a) ∧
    (∀a0 a1. M' = Vis' a0 a1 ⇒ f2 a0 a1 = f2' a0 a1) ⇒
    itree_next_CASE M f f1 f2 = itree_next_CASE M' f' f1' f2'
</pre>

<DT><span class="strong">itree_next_case_eq</span>
<DD>
<pre>
⊢ itree_next_CASE x f f1 f2 = v ⇔
  (∃r. x = Ret' r ∧ f r = v) ∨ (∃s. x = Tau' s ∧ f1 s = v) ∨
  ∃e f'. x = Vis' e f' ∧ f2 e f' = v
</pre>

<DT><span class="strong">itree_next_distinct</span>
<DD>
<pre>
⊢ (∀a' a. Ret' a ≠ Tau' a') ∧ (∀a1 a0 a. Ret' a ≠ Vis' a0 a1) ∧
  ∀a1 a0 a. Tau' a ≠ Vis' a0 a1
</pre>

<DT><span class="strong">itree_next_induction</span>
<DD>
<pre>
⊢ ∀P. (∀r. P (Ret' r)) ∧ (∀s. P (Tau' s)) ∧ (∀e f. P (Vis' e f)) ⇒ ∀i. P i
</pre>

<DT><span class="strong">itree_next_nchotomy</span>
<DD>
<pre>
⊢ ∀ii. (∃r. ii = Ret' r) ∨ (∃s. ii = Tau' s) ∨ ∃e f. ii = Vis' e f
</pre>

<DT><span class="strong">itree_strong_bisimulation</span>
<DD>
<pre>
⊢ ∀t1 t2.
    t1 = t2 ⇔
    ∃R. R t1 t2 ∧ (∀x t. R (Ret x) t ⇒ t = Ret x) ∧
        (∀u t. R (Tau u) t ⇒ ∃v. t = Tau v ∧ (R u v ∨ u = v)) ∧
        ∀a f t.
          R (Vis a f) t ⇒ ∃g. t = Vis a g ∧ ∀s. R (f s) (g s) ∨ f s = g s
</pre>

<DT><span class="strong">itree_unfold</span>
<DD>
<pre>
⊢ itree_unfold f seed =
  case f seed of
    Ret' r => Ret r
  | Tau' s => Tau (itree_unfold f s)
  | Vis' e g => Vis e (itree_unfold f ∘ g)
</pre>

<DT><span class="strong">itree_wbisim_Ret_FUNPOW</span>
<DD>
<pre>
⊢ itree_wbisim t (Ret x) ⇒ ∃n. t = FUNPOW Tau n (Ret x)
</pre>

<DT><span class="strong">itree_wbisim_Vis_FUNPOW</span>
<DD>
<pre>
⊢ itree_wbisim t (Vis a g) ⇒
  ∃n k. t = FUNPOW Tau n (Vis a k) ∧ ∀r. itree_wbisim (k r) (g r)
</pre>

<DT><span class="strong">itree_wbisim_cases</span>
<DD>
<pre>
⊢ ∀a0 a1.
    itree_wbisim a0 a1 ⇔
    (∃t t'. a0 = Tau t ∧ a1 = Tau t' ∧ itree_wbisim t t') ∨
    (∃e k k'.
       strip_tau a0 (Vis e k) ∧ strip_tau a1 (Vis e k') ∧
       ∀r. itree_wbisim (k r) (k' r)) ∨
    ∃r. strip_tau a0 (Ret r) ∧ strip_tau a1 (Ret r)
</pre>

<DT><span class="strong">itree_wbisim_coind</span>
<DD>
<pre>
⊢ ∀itree_wbisim'.
    (∀a0 a1.
       itree_wbisim' a0 a1 ⇒
       (∃t t'. a0 = Tau t ∧ a1 = Tau t' ∧ itree_wbisim' t t') ∨
       (∃e k k'.
          strip_tau a0 (Vis e k) ∧ strip_tau a1 (Vis e k') ∧
          ∀r. itree_wbisim' (k r) (k' r)) ∨
       ∃r. strip_tau a0 (Ret r) ∧ strip_tau a1 (Ret r)) ⇒
    ∀a0 a1. itree_wbisim' a0 a1 ⇒ itree_wbisim a0 a1
</pre>

<DT><span class="strong">itree_wbisim_coind_upto</span>
<DD>
<pre>
⊢ ∀R. (∀t t'.
         R t t' ⇒
         (∃t2 t3. t = Tau t2 ∧ t' = Tau t3 ∧ (R t2 t3 ∨ itree_wbisim t2 t3)) ∨
         (∃e k k'.
            strip_tau t (Vis e k) ∧ strip_tau t' (Vis e k') ∧
            ∀r. R (k r) (k' r) ∨ itree_wbisim (k r) (k' r)) ∨
         (∃r. strip_tau t (Ret r) ∧ strip_tau t' (Ret r)) ∨ itree_wbisim t t') ⇒
      ∀t t'. R t t' ⇒ itree_wbisim t t'
</pre>

<DT><span class="strong">itree_wbisim_coind_upto'</span>
<DD>
<pre>
⊢ ∀R. rel_to_reln R ⊆
      rel_to_reln itree_wbisim ∪
      wbisim_functional (set_companion wbisim_functional (rel_to_reln R)) ⇒
      rel_to_reln R ⊆ rel_to_reln itree_wbisim
</pre>

<DT><span class="strong">itree_wbisim_refl</span>
<DD>
<pre>
⊢ itree_wbisim t t
</pre>

<DT><span class="strong">itree_wbisim_rules</span>
<DD>
<pre>
⊢ (∀t t'. itree_wbisim t t' ⇒ itree_wbisim (Tau t) (Tau t')) ∧
  (∀e k k' t t'.
     strip_tau t (Vis e k) ∧ strip_tau t' (Vis e k') ∧
     (∀r. itree_wbisim (k r) (k' r)) ⇒
     itree_wbisim t t') ∧
  ∀r t t'. strip_tau t (Ret r) ∧ strip_tau t' (Ret r) ⇒ itree_wbisim t t'
</pre>

<DT><span class="strong">itree_wbisim_strip_tau</span>
<DD>
<pre>
⊢ ∀t t' t''. itree_wbisim t t' ∧ strip_tau t t'' ⇒ itree_wbisim t'' t'
</pre>

<DT><span class="strong">itree_wbisim_strip_tau_Ret</span>
<DD>
<pre>
⊢ ∀t t' v. itree_wbisim t t' ∧ strip_tau t (Ret v) ⇒ strip_tau t' (Ret v)
</pre>

<DT><span class="strong">itree_wbisim_strip_tau_Vis</span>
<DD>
<pre>
⊢ ∀t t' e k.
    itree_wbisim t t' ∧ strip_tau t (Vis e k) ⇒
    ∃k'. strip_tau t' (Vis e k') ∧ ∀r. itree_wbisim (k r) (k' r)
</pre>

<DT><span class="strong">itree_wbisim_strip_tau_sym</span>
<DD>
<pre>
⊢ ∀t t' t''. itree_wbisim t t' ∧ strip_tau t' t'' ⇒ itree_wbisim t t''
</pre>

<DT><span class="strong">itree_wbisim_strong_coind</span>
<DD>
<pre>
⊢ ∀R. (∀t t'.
         R t t' ⇒
         (∃t2 t3. t = Tau t2 ∧ t' = Tau t3 ∧ (R t2 t3 ∨ itree_wbisim t2 t3)) ∨
         (∃e k k'.
            strip_tau t (Vis e k) ∧ strip_tau t' (Vis e k') ∧
            ∀r. R (k r) (k' r) ∨ itree_wbisim (k r) (k' r)) ∨
         ∃r. strip_tau t (Ret r) ∧ strip_tau t' (Ret r)) ⇒
      ∀t t'. R t t' ⇒ itree_wbisim t t'
</pre>

<DT><span class="strong">itree_wbisim_sym</span>
<DD>
<pre>
⊢ ∀t t'. itree_wbisim t t' ⇒ itree_wbisim t' t
</pre>

<DT><span class="strong">itree_wbisim_tau</span>
<DD>
<pre>
⊢ ∀t t'. itree_wbisim (Tau t) t' ⇒ itree_wbisim t t'
</pre>

<DT><span class="strong">itree_wbisim_tau_eq</span>
<DD>
<pre>
⊢ itree_wbisim (Tau t) t
</pre>

<DT><span class="strong">itree_wbisim_tau_eqn</span>
<DD>
<pre>
⊢ (itree_wbisim (Tau t1) t2 ⇔ itree_wbisim t1 t2) ∧
  (itree_wbisim t1 (Tau t2) ⇔ itree_wbisim t1 t2)
</pre>

<DT><span class="strong">itree_wbisim_trans</span>
<DD>
<pre>
⊢ ∀t t' t''. itree_wbisim t t' ∧ itree_wbisim t' t'' ⇒ itree_wbisim t t''
</pre>

<DT><span class="strong">itree_wbisim_vis</span>
<DD>
<pre>
⊢ ∀e k1 k2.
    (∀r. itree_wbisim (k1 r) (k2 r)) ⇒ itree_wbisim (Vis e k1) (Vis e k2)
</pre>

<DT><span class="strong">spin</span>
<DD>
<pre>
⊢ spin = Tau spin
</pre>

<DT><span class="strong">spin_FUNPOW_Tau</span>
<DD>
<pre>
⊢ ∀n. spin = FUNPOW Tau n spin
</pre>

<DT><span class="strong">spin_bind</span>
<DD>
<pre>
⊢ itree_bind spin k = spin
</pre>

<DT><span class="strong">spin_strip_tau</span>
<DD>
<pre>
⊢ ∀t. strip_tau spin t ⇒ F
</pre>

<DT><span class="strong">strip_tau_FUNPOW</span>
<DD>
<pre>
⊢ ∀t1 t2. strip_tau t1 t2 ⇒ ∃n. t1 = FUNPOW Tau n t2
</pre>

<DT><span class="strong">strip_tau_FUNPOW_cancel</span>
<DD>
<pre>
⊢ (∀u. t ≠ Tau u) ⇒ strip_tau (FUNPOW Tau n t) t
</pre>

<DT><span class="strong">strip_tau_cases</span>
<DD>
<pre>
⊢ ∀a0 a1.
    strip_tau a0 a1 ⇔
    (∃t. a0 = Tau t ∧ strip_tau t a1) ∨ (∃e k. a0 = Vis e k ∧ a1 = Vis e k) ∨
    ∃v. a0 = Ret v ∧ a1 = Ret v
</pre>

<DT><span class="strong">strip_tau_ind</span>
<DD>
<pre>
⊢ ∀strip_tau'.
    (∀t t'. strip_tau' t t' ⇒ strip_tau' (Tau t) t') ∧
    (∀e k. strip_tau' (Vis e k) (Vis e k)) ∧ (∀v. strip_tau' (Ret v) (Ret v)) ⇒
    ∀a0 a1. strip_tau a0 a1 ⇒ strip_tau' a0 a1
</pre>

<DT><span class="strong">strip_tau_inj</span>
<DD>
<pre>
⊢ ∀t t' t''. strip_tau t t' ∧ strip_tau t t'' ⇒ t' = t''
</pre>

<DT><span class="strong">strip_tau_rules</span>
<DD>
<pre>
⊢ (∀t t'. strip_tau t t' ⇒ strip_tau (Tau t) t') ∧
  (∀e k. strip_tau (Vis e k) (Vis e k)) ∧ ∀v. strip_tau (Ret v) (Ret v)
</pre>

<DT><span class="strong">strip_tau_simps</span>
<DD>
<pre>
⊢ (strip_tau t' (Tau t) ⇔ F) ∧ (strip_tau (Ret v) (Vis e k) ⇔ F) ∧
  (strip_tau (Vis e k) (Ret v) ⇔ F) ∧ (strip_tau (Tau t) t' ⇔ strip_tau t t')
</pre>

<DT><span class="strong">strip_tau_simps2</span>
<DD>
<pre>
⊢ strip_tau (Ret v) (Ret v') ⇔ v = v'
</pre>

<DT><span class="strong">strip_tau_simps3</span>
<DD>
<pre>
⊢ strip_tau (Vis e k) (Vis e' k') ⇔ e = e' ∧ k = k'
</pre>

<DT><span class="strong">strip_tau_spin</span>
<DD>
<pre>
⊢ (∀t'. ¬strip_tau t t') ⇒ t = spin
</pre>

<DT><span class="strong">strip_tau_strongind</span>
<DD>
<pre>
⊢ ∀strip_tau'.
    (∀t t'. strip_tau t t' ∧ strip_tau' t t' ⇒ strip_tau' (Tau t) t') ∧
    (∀e k. strip_tau' (Vis e k) (Vis e k)) ∧ (∀v. strip_tau' (Ret v) (Ret v)) ⇒
    ∀a0 a1. strip_tau a0 a1 ⇒ strip_tau' a0 a1
</pre>

<DT><span class="strong">strip_tau_vis_wbisim</span>
<DD>
<pre>
⊢ ∀e k k'.
    strip_tau t (Vis e k) ∧ strip_tau t' (Vis e k') ∧
    (∀r. itree_wbisim (k r) (k' r)) ⇒
    itree_wbisim t t'
</pre>

<DT><span class="strong">untau_IMP_wbisim</span>
<DD>
<pre>
⊢ ∀t t'. untau t = untau t' ⇒ itree_wbisim t t'
</pre>

<DT><span class="strong">untau_spin</span>
<DD>
<pre>
⊢ untau spin = Div
</pre>

<DT><span class="strong">upto_taus_compatible</span>
<DD>
<pre>
⊢ set_compatible wbisim_functional upto_taus_func
</pre>

<DT><span class="strong">wbisim_FUNPOW_Tau</span>
<DD>
<pre>
⊢ (itree_wbisim t (FUNPOW Tau n ht) ⇔ itree_wbisim t ht) ∧
  (itree_wbisim (FUNPOW Tau n ht) t ⇔ itree_wbisim ht t)
</pre>

<DT><span class="strong">wbisim_IMP_untau</span>
<DD>
<pre>
⊢ ∀t t'. itree_wbisim t t' ⇒ untau t = untau t'
</pre>

<DT><span class="strong">wbisim_functional_cancel</span>
<DD>
<pre>
⊢ X ⊆ Y ⇒ wbisim_functional X ⊆ wbisim_functional Y
</pre>

<DT><span class="strong">wbisim_functional_gfp</span>
<DD>
<pre>
⊢ gfp wbisim_functional = rel_to_reln itree_wbisim
</pre>

<DT><span class="strong">wbisim_functional_mono</span>
<DD>
<pre>
⊢ monotone wbisim_functional
</pre>

<DT><span class="strong">wbisim_spin_eq</span>
<DD>
<pre>
⊢ itree_wbisim t spin ⇔ t = spin
</pre>

</DL>



<hr>
</body>
</html>
