<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: numeral</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "numeral"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "arithmeticTheory.html"><span class="strong">arithmetic</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">exactlog</span>
    <td>
    :num -> num
    <tr><td>
    <span class="strong">iBIT_cases</span>
    <td>
    :num -> α -> (num -> α) -> (num -> α) -> α
    <tr><td> <span class="strong">iDUB</span> <td> :num -> num
    <tr><td> <span class="strong">iSQR</span> <td> :num -> num
    <tr><td> <span class="strong">iSUB</span> <td> :bool -> num -> num -> num
    <tr><td> <span class="strong">iZ</span> <td> :num -> num
    <tr><td> <span class="strong">iiSUC</span> <td> :num -> num
    <tr><td> <span class="strong">internal_mult</span> <td> :num -> num -> num
    <tr><td> <span class="strong">onecount</span> <td> :num -> num -> num
    <tr><td> <span class="strong">texp_help</span> <td> :num -> num -> num
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">exactlog_def</span>
<DD>
<pre>
⊢ <..num comp'n..> = ZERO ∧ (∀n. <..num comp'n..> = ZERO) ∧
  ∀n. <..num comp'n..> =
      (let
         x = <..num comp'n..>
       in
         if x = ZERO then ZERO else <..num comp'n..> )
</pre>

<DT><span class="strong">iBIT_cases</span>
<DD>
<pre>
⊢ (∀zf bf1 bf2. iBIT_cases ZERO zf bf1 bf2 = zf) ∧
  (∀n zf bf1 bf2. iBIT_cases <..num comp'n..> zf bf1 bf2 = bf1 n) ∧
  ∀n zf bf1 bf2. iBIT_cases <..num comp'n..> zf bf1 bf2 = bf2 n
</pre>

<DT><span class="strong">iDUB</span>
<DD>
<pre>
⊢ ∀x. <..num comp'n..> = x + x
</pre>

<DT><span class="strong">iSQR</span>
<DD>
<pre>
⊢ ∀x. <..num comp'n..> = x * x
</pre>

<DT><span class="strong">iSUB_DEF</span>
<DD>
<pre>
⊢ (∀b x. <..num comp'n..> = ZERO) ∧
  (∀b n x. <..num comp'n..> = if b then <..num comp'n..> else <..num comp'n..> ) ∧
  ∀b n x. <..num comp'n..> = if b then <..num comp'n..> else <..num comp'n..>
</pre>

<DT><span class="strong">iZ</span>
<DD>
<pre>
⊢ ∀x. <..num comp'n..> = x
</pre>

<DT><span class="strong">iiSUC</span>
<DD>
<pre>
⊢ ∀n. <..num comp'n..> = SUC (SUC n)
</pre>

<DT><span class="strong">internal_mult_def</span>
<DD>
<pre>
⊢ internal_mult = $*
</pre>

<DT><span class="strong">onecount_def</span>
<DD>
<pre>
⊢ (∀x. <..num comp'n..> = x) ∧ (∀n x. <..num comp'n..> = <..num comp'n..> ) ∧
  ∀n x. <..num comp'n..> = ZERO
</pre>

<DT><span class="strong">texp_help_def</span>
<DD>
<pre>
⊢ (∀acc. <..num comp'n..> = <..num comp'n..> ) ∧
  ∀n acc. <..num comp'n..> = <..num comp'n..>
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">DIV2_BIT1</span>
<DD>
<pre>
⊢ DIV2 <..num comp'n..> = x
</pre>

<DT><span class="strong">DIVMOD_NUMERAL_CALC</span>
<DD>
<pre>
⊢ (∀m n. m DIV <..num comp'n..> = FST (DIVMOD (ZERO,m,<..num comp'n..> ))) ∧
  (∀m n. m DIV <..num comp'n..> = FST (DIVMOD (ZERO,m,<..num comp'n..> ))) ∧
  (∀m n. m MOD <..num comp'n..> = SND (DIVMOD (ZERO,m,<..num comp'n..> ))) ∧
  ∀m n. m MOD <..num comp'n..> = SND (DIVMOD (ZERO,m,<..num comp'n..> ))
</pre>

<DT><span class="strong">TWO_EXP_THM</span>
<DD>
<pre>
⊢ 2 ** 0 = 1 ∧ 2 ** <..num comp'n..> = <..num comp'n..> ∧
  2 ** <..num comp'n..> = <..num comp'n..>
</pre>

<DT><span class="strong">bit_induction</span>
<DD>
<pre>
⊢ ∀P. P ZERO ∧ (∀n. P n ⇒ P <..num comp'n..> ) ∧
      (∀n. P n ⇒ P <..num comp'n..> ) ⇒
      ∀n. P n
</pre>

<DT><span class="strong">bit_initiality</span>
<DD>
<pre>
⊢ ∀zf b1f b2f. ∃f.
    f ZERO = zf ∧ (∀n. f <..num comp'n..> = b1f n (f n)) ∧
    ∀n. f <..num comp'n..> = b2f n (f n)
</pre>

<DT><span class="strong">divmod_POS</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒
      DIVMOD (a,m,n) =
      if m < n then (a,m)
      else (let q = findq (1,m,n) in DIVMOD (a + q,m − n * q,n))
</pre>

<DT><span class="strong">enumeral_mult</span>
<DD>
<pre>
⊢ ZERO * n = ZERO ∧ n * ZERO = ZERO ∧
  <..num comp'n..> * <..num comp'n..> = <..num comp'n..> ∧
  <..num comp'n..> * <..num comp'n..> =
  (let
     n = <..num comp'n..>
   in
     if ODD n then <..num comp'n..> else <..num comp'n..> ) ∧
  <..num comp'n..> * <..num comp'n..> =
  (let
     m = <..num comp'n..>
   in
     if ODD m then <..num comp'n..> else <..num comp'n..> ) ∧
  <..num comp'n..> * <..num comp'n..> =
  (let
     m = <..num comp'n..> ;
     n = <..num comp'n..>
   in
     if ODD m then <..num comp'n..>
     else if ODD n then <..num comp'n..>
     else <..num comp'n..> )
</pre>

<DT><span class="strong">exactlog_characterisation</span>
<DD>
<pre>
⊢ ∀n m. <..num comp'n..> = <..num comp'n..> ⇒ n = 2 ** (m + 1)
</pre>

<DT><span class="strong">iDUB_removal</span>
<DD>
<pre>
⊢ ∀n. <..num comp'n..> = <..num comp'n..> ∧
      <..num comp'n..> = <..num comp'n..> ∧ <..num comp'n..> = ZERO
</pre>

<DT><span class="strong">iSUB_THM</span>
<DD>
<pre>
⊢ ∀b n m.
    <..num comp'n..> = ZERO ∧ <..num comp'n..> = n ∧
    <..num comp'n..> = <..num comp'n..> ∧
    <..num comp'n..> = <..num comp'n..> ∧
    <..num comp'n..> = <..num comp'n..> ∧
    <..num comp'n..> = <..num comp'n..> ∧
    <..num comp'n..> = <..num comp'n..> ∧
    <..num comp'n..> = <..num comp'n..> ∧
    <..num comp'n..> = <..num comp'n..> ∧
    <..num comp'n..> = <..num comp'n..> ∧
    <..num comp'n..> = <..num comp'n..> ∧ <..num comp'n..> = <..num comp'n..>
</pre>

<DT><span class="strong">internal_mult_characterisation</span>
<DD>
<pre>
⊢ ∀n m.
    <..num comp'n..> = ZERO ∧ <..num comp'n..> = ZERO ∧
    <..num comp'n..> = <..num comp'n..> ∧ <..num comp'n..> = <..num comp'n..>
</pre>

<DT><span class="strong">numeral_MAX</span>
<DD>
<pre>
⊢ MAX 0 x = x ∧ MAX x 0 = x ∧
  MAX <..num comp'n..> <..num comp'n..> = <..num comp'n..>
</pre>

<DT><span class="strong">numeral_MIN</span>
<DD>
<pre>
⊢ MIN 0 x = 0 ∧ MIN x 0 = 0 ∧
  MIN <..num comp'n..> <..num comp'n..> = <..num comp'n..>
</pre>

<DT><span class="strong">numeral_add</span>
<DD>
<pre>
⊢ ∀n m.
    <..num comp'n..> = n ∧ <..num comp'n..> = n ∧
    <..num comp'n..> = <..num comp'n..> ∧
    <..num comp'n..> = <..num comp'n..> ∧
    <..num comp'n..> = <..num comp'n..> ∧
    <..num comp'n..> = <..num comp'n..> ∧ SUC (ZERO + n) = SUC n ∧
    SUC (n + ZERO) = SUC n ∧
    SUC (<..num comp'n..> + <..num comp'n..> ) = <..num comp'n..> ∧
    SUC (<..num comp'n..> + <..num comp'n..> ) = <..num comp'n..> ∧
    SUC (<..num comp'n..> + <..num comp'n..> ) = <..num comp'n..> ∧
    SUC (<..num comp'n..> + <..num comp'n..> ) = <..num comp'n..> ∧
    <..num comp'n..> = <..num comp'n..> ∧
    <..num comp'n..> = <..num comp'n..> ∧
    <..num comp'n..> = <..num comp'n..> ∧
    <..num comp'n..> = <..num comp'n..> ∧
    <..num comp'n..> = <..num comp'n..> ∧ <..num comp'n..> = <..num comp'n..>
</pre>

<DT><span class="strong">numeral_distrib</span>
<DD>
<pre>
⊢ (∀n. 0 + n = n) ∧ (∀n. n + 0 = n) ∧
  (∀n m. <..num comp'n..> + <..num comp'n..> = <..num comp'n..> ) ∧
  (∀n. 0 * n = 0) ∧ (∀n. n * 0 = 0) ∧
  (∀n m. <..num comp'n..> * <..num comp'n..> = <..num comp'n..> ) ∧
  (∀n. 0 − n = 0) ∧ (∀n. n − 0 = n) ∧
  (∀n m. <..num comp'n..> − <..num comp'n..> = <..num comp'n..> ) ∧
  (∀n. 0 ** <..num comp'n..> = 0) ∧ (∀n. 0 ** <..num comp'n..> = 0) ∧
  (∀n. n ** 0 = 1) ∧
  (∀n m. <..num comp'n..> ** <..num comp'n..> = <..num comp'n..> ) ∧
  SUC 0 = 1 ∧ (∀n. SUC <..num comp'n..> = <..num comp'n..> ) ∧ PRE 0 = 0 ∧
  (∀n. PRE <..num comp'n..> = <..num comp'n..> ) ∧
  (∀n. <..num comp'n..> = 0 ⇔ n = ZERO) ∧
  (∀n. 0 = <..num comp'n..> ⇔ n = ZERO) ∧
  (∀n m. <..num comp'n..> = <..num comp'n..> ⇔ n = m) ∧ (∀n. n < 0 ⇔ F) ∧
  (∀n. 0 < <..num comp'n..> ⇔ ZERO < n) ∧
  (∀n m. <..num comp'n..> < <..num comp'n..> ⇔ n < m) ∧ (∀n. 0 > n ⇔ F) ∧
  (∀n. <..num comp'n..> > 0 ⇔ ZERO < n) ∧
  (∀n m. <..num comp'n..> > <..num comp'n..> ⇔ m < n) ∧ (∀n. 0 ≤ n ⇔ T) ∧
  (∀n. <..num comp'n..> ≤ 0 ⇔ n ≤ ZERO) ∧
  (∀n m. <..num comp'n..> ≤ <..num comp'n..> ⇔ n ≤ m) ∧ (∀n. n ≥ 0 ⇔ T) ∧
  (∀n. 0 ≥ n ⇔ n = 0) ∧ (∀n m. <..num comp'n..> ≥ <..num comp'n..> ⇔ m ≤ n) ∧
  (∀n. ODD <..num comp'n..> ⇔ ODD n) ∧ (∀n. EVEN <..num comp'n..> ⇔ EVEN n) ∧
  ¬ODD 0 ∧ EVEN 0
</pre>

<DT><span class="strong">numeral_div2</span>
<DD>
<pre>
⊢ DIV2 0 = 0 ∧ (∀n. DIV2 <..num comp'n..> = <..num comp'n..> ) ∧
  ∀n. DIV2 <..num comp'n..> = <..num comp'n..>
</pre>

<DT><span class="strong">numeral_eq</span>
<DD>
<pre>
⊢ ∀n m.
    (ZERO = <..num comp'n..> ⇔ F) ∧ (<..num comp'n..> = ZERO ⇔ F) ∧
    (ZERO = <..num comp'n..> ⇔ F) ∧ (<..num comp'n..> = ZERO ⇔ F) ∧
    (<..num comp'n..> = <..num comp'n..> ⇔ F) ∧
    (<..num comp'n..> = <..num comp'n..> ⇔ F) ∧
    (<..num comp'n..> = <..num comp'n..> ⇔ n = m) ∧
    (<..num comp'n..> = <..num comp'n..> ⇔ n = m)
</pre>

<DT><span class="strong">numeral_evenodd</span>
<DD>
<pre>
⊢ ∀n. EVEN ZERO ∧ EVEN <..num comp'n..> ∧ ¬EVEN <..num comp'n..> ∧ ¬ODD ZERO ∧
      ¬ODD <..num comp'n..> ∧ ODD <..num comp'n..>
</pre>

<DT><span class="strong">numeral_exp</span>
<DD>
<pre>
⊢ (∀n. n ** ZERO = <..num comp'n..> ) ∧
  (∀n m. n ** <..num comp'n..> = n * <..num comp'n..> ) ∧
  ∀n m. n ** <..num comp'n..> = <..num comp'n..> * <..num comp'n..>
</pre>

<DT><span class="strong">numeral_fact</span>
<DD>
<pre>
⊢ FACT 0 = 1 ∧
  (∀n. FACT <..num comp'n..> = <..num comp'n..> * FACT (PRE <..num comp'n..> )) ∧
  ∀n. FACT <..num comp'n..> = <..num comp'n..> * FACT <..num comp'n..>
</pre>

<DT><span class="strong">numeral_funpow</span>
<DD>
<pre>
⊢ FUNPOW f 0 x = x ∧
  FUNPOW f <..num comp'n..> x = FUNPOW f (PRE <..num comp'n..> ) (f x) ∧
  FUNPOW f <..num comp'n..> x = FUNPOW f <..num comp'n..> (f x)
</pre>

<DT><span class="strong">numeral_iisuc</span>
<DD>
<pre>
⊢ <..num comp'n..> = <..num comp'n..> ∧ <..num comp'n..> = <..num comp'n..> ∧
  <..num comp'n..> = <..num comp'n..>
</pre>

<DT><span class="strong">numeral_lt</span>
<DD>
<pre>
⊢ ∀n m.
    (ZERO < <..num comp'n..> ⇔ T) ∧ (ZERO < <..num comp'n..> ⇔ T) ∧
    (n < ZERO ⇔ F) ∧ (<..num comp'n..> < <..num comp'n..> ⇔ n < m) ∧
    (<..num comp'n..> < <..num comp'n..> ⇔ n < m) ∧
    (<..num comp'n..> < <..num comp'n..> ⇔ ¬(m < n)) ∧
    (<..num comp'n..> < <..num comp'n..> ⇔ n < m)
</pre>

<DT><span class="strong">numeral_lte</span>
<DD>
<pre>
⊢ ∀n m.
    (ZERO ≤ n ⇔ T) ∧ (<..num comp'n..> ≤ ZERO ⇔ F) ∧
    (<..num comp'n..> ≤ ZERO ⇔ F) ∧
    (<..num comp'n..> ≤ <..num comp'n..> ⇔ n ≤ m) ∧
    (<..num comp'n..> ≤ <..num comp'n..> ⇔ n ≤ m) ∧
    (<..num comp'n..> ≤ <..num comp'n..> ⇔ ¬(m ≤ n)) ∧
    (<..num comp'n..> ≤ <..num comp'n..> ⇔ n ≤ m)
</pre>

<DT><span class="strong">numeral_mult</span>
<DD>
<pre>
⊢ ∀n m.
    ZERO * n = ZERO ∧ n * ZERO = ZERO ∧
    <..num comp'n..> * m = <..num comp'n..> ∧
    <..num comp'n..> * m = <..num comp'n..>
</pre>

<DT><span class="strong">numeral_pre</span>
<DD>
<pre>
⊢ PRE ZERO = ZERO ∧ PRE <..num comp'n..> = ZERO ∧
  (∀n. PRE <..num comp'n..> = <..num comp'n..> ) ∧
  (∀n. PRE <..num comp'n..> = <..num comp'n..> ) ∧
  ∀n. PRE <..num comp'n..> = <..num comp'n..>
</pre>

<DT><span class="strong">numeral_sub</span>
<DD>
<pre>
⊢ ∀n m. <..num comp'n..> = if m < n then <..num comp'n..> else 0
</pre>

<DT><span class="strong">numeral_suc</span>
<DD>
<pre>
⊢ SUC ZERO = <..num comp'n..> ∧
  (∀n. SUC <..num comp'n..> = <..num comp'n..> ) ∧
  ∀n. SUC <..num comp'n..> = <..num comp'n..>
</pre>

<DT><span class="strong">numeral_texp_help</span>
<DD>
<pre>
⊢ <..num comp'n..> = <..num comp'n..> ∧ <..num comp'n..> = <..num comp'n..> ∧
  <..num comp'n..> = <..num comp'n..>
</pre>

<DT><span class="strong">onecount_characterisation</span>
<DD>
<pre>
⊢ ∀n a. 0 < <..num comp'n..> ∧ 0 < n ⇒ n = tops 2 (<..num comp'n..> − a)
</pre>

<DT><span class="strong">texp_help0</span>
<DD>
<pre>
⊢ <..num comp'n..> = 2 ** (n + 1)
</pre>

<DT><span class="strong">texp_help_thm</span>
<DD>
<pre>
⊢ ∀n a. <..num comp'n..> = (a + 1) * 2 ** (n + 1)
</pre>

</DL>



<hr>
</body>
</html>
