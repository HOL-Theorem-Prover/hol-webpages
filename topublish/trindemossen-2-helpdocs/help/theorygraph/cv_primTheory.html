<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: cv_prim</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "cv_prim"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "cv_repTheory.html"><span class="strong">cv_rep</span></a>&nbsp;&nbsp;
    <a href = "bitstringTheory.html"><span class="strong">bitstring</span></a>&nbsp;&nbsp;
    <a href = "integer_wordTheory.html"><span class="strong">integer_word</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">cv_abs</span>
    <td>
    :cv -> cv
    <tr><td> <span class="strong">cv_gcd</span> <td> :cv -> cv -> cv
    <tr><td> <span class="strong">cv_int_add</span> <td> :cv -> cv -> cv
    <tr><td> <span class="strong">cv_int_div</span> <td> :cv -> cv -> cv
    <tr><td> <span class="strong">cv_int_lt</span> <td> :cv -> cv -> cv
    <tr><td> <span class="strong">cv_int_mod</span> <td> :cv -> cv -> cv
    <tr><td> <span class="strong">cv_int_mul</span> <td> :cv -> cv -> cv
    <tr><td> <span class="strong">cv_int_neg</span> <td> :cv -> cv
    <tr><td> <span class="strong">cv_log2</span> <td> :cv -> cv -> cv
    <tr><td> <span class="strong">cv_max</span> <td> :cv -> cv -> cv
    <tr><td> <span class="strong">cv_min</span> <td> :cv -> cv -> cv
    <tr><td> <span class="strong">cv_rat_add</span> <td> :cv -> cv -> cv
    <tr><td> <span class="strong">cv_rat_lt</span> <td> :cv -> cv -> cv
    <tr><td> <span class="strong">cv_rat_mul</span> <td> :cv -> cv -> cv
    <tr><td> <span class="strong">cv_rat_neg</span> <td> :cv -> cv
    <tr><td> <span class="strong">cv_rat_norm</span> <td> :cv -> cv
    <tr><td> <span class="strong">cv_rat_reciprocal</span> <td> :cv -> cv
    <tr><td> <span class="strong">cv_total_int_div</span> <td> :cv -> cv -> cv
    <tr><td> <span class="strong">cv_total_int_mod</span> <td> :cv -> cv -> cv
    <tr><td> <span class="strong">cv_word_and</span> <td> :cv -> cv -> cv
    <tr><td> <span class="strong">cv_word_and_loop</span> <td> :cv -> cv -> cv
    <tr><td>
    <span class="strong">cv_word_lt</span>
    <td>
    :cv -> cv -> cv -> cv -> cv
    <tr><td> <span class="strong">cv_word_or</span> <td> :cv -> cv -> cv
    <tr><td> <span class="strong">cv_word_or_loop</span> <td> :cv -> cv -> cv
    <tr><td>
    <span class="strong">cv_word_sub</span>
    <td>
    :cv -> cv -> cv -> cv
    <tr><td> <span class="strong">cv_word_xor</span> <td> :cv -> cv -> cv
    <tr><td> <span class="strong">cv_word_xor_loop</span> <td> :cv -> cv -> cv
    <tr><td> <span class="strong">total_int_div</span> <td> :int -> int -> int
    <tr><td> <span class="strong">total_int_mod</span> <td> :int -> int -> int
    <tr><td>
    <span class="strong">v2n_custom</span>
    <td>
    :num -> bool list -> num
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">cv_abs_def</span>
<DD>
<pre>
⊢ ∀i. cv_abs i = cv_if (cv_ispair i) (cv_fst i) i
</pre>

<DT><span class="strong">cv_int_add_def</span>
<DD>
<pre>
⊢ ∀i j.
    cv_int_add i j =
    cv_if (cv_ispair i)
      (cv_if (cv_ispair j) (cv$Pair (cv_add (cv_fst i) (cv_fst j)) (cv$Num 0))
         (cv_if (cv_int_lt j (cv_fst i))
            (cv$Pair (cv_sub (cv_fst i) j) (cv$Num 0)) (cv_sub j (cv_fst i))))
      (cv_if (cv_ispair j)
         (cv_if (cv_int_lt i (cv_fst j))
            (cv$Pair (cv_sub (cv_fst j) i) (cv$Num 0)) (cv_sub i (cv_fst j)))
         (cv_add i j))
</pre>

<DT><span class="strong">cv_int_div_def</span>
<DD>
<pre>
⊢ ∀i j.
    cv_int_div i j =
    cv_if (cv_ispair j)
      (cv_if (cv_ispair i) (cv_div (cv_fst i) (cv_fst j))
         (cv_int_add (cv$Pair (cv_div i (cv_fst j)) (cv$Num 0))
            (cv_if (cv_mod i (cv_fst j)) (cv$Pair (cv$Num 1) (cv$Num 0))
               (cv$Num 0))))
      (cv_if (cv_ispair i)
         (cv_int_add (cv$Pair (cv_div (cv_fst i) j) (cv$Num 0))
            (cv_if (cv_mod (cv_fst i) j) (cv$Pair (cv$Num 1) (cv$Num 0))
               (cv$Num 0))) (cv_div i j))
</pre>

<DT><span class="strong">cv_int_lt_def</span>
<DD>
<pre>
⊢ ∀i j.
    cv_int_lt i j =
    cv_if (cv_ispair i)
      (cv_if (cv_ispair j) (cv_lt (cv_abs j) (cv_abs i)) (cv$Num 1))
      (cv_if (cv_ispair j) (cv$Num 0) (cv_lt i j))
</pre>

<DT><span class="strong">cv_int_mod_def</span>
<DD>
<pre>
⊢ ∀i j.
    cv_int_mod i j = cv_int_add i (cv_int_neg (cv_int_mul (cv_int_div i j) j))
</pre>

<DT><span class="strong">cv_int_mul_def</span>
<DD>
<pre>
⊢ ∀i j.
    cv_int_mul i j =
    cv_if (cv_eq i (cv$Num 0)) (cv$Num 0)
      (cv_if (cv_eq j (cv$Num 0)) (cv$Num 0)
         (cv_if (cv_ispair i)
            (cv_if (cv_ispair j) (cv_mul (cv_fst i) (cv_fst j))
               (cv$Pair (cv_mul (cv_fst i) j) (cv$Num 0)))
            (cv_if (cv_ispair j) (cv$Pair (cv_mul i (cv_fst j)) (cv$Num 0))
               (cv_mul i j))))
</pre>

<DT><span class="strong">cv_int_neg_def</span>
<DD>
<pre>
⊢ ∀x. cv_int_neg x =
      cv_if (cv_eq x (cv$Num 0)) x
        (cv_if (cv_ispair x) (cv_fst x) (cv$Pair x (cv$Num 0)))
</pre>

<DT><span class="strong">cv_max_def</span>
<DD>
<pre>
⊢ ∀x y. cv_max x y = cv_if (cv_lt x y) y x
</pre>

<DT><span class="strong">cv_min_def</span>
<DD>
<pre>
⊢ ∀x y. cv_min x y = cv_if (cv_lt x y) x y
</pre>

<DT><span class="strong">cv_rat_add_def</span>
<DD>
<pre>
⊢ ∀r1 r2.
    cv_rat_add r1 r2 =
    cv_rat_norm
      (cv$Pair
         (cv_int_add (cv_int_mul (cv_fst r1) (cv_snd r2))
            (cv_int_mul (cv_fst r2) (cv_snd r1)))
         (cv_mul (cv_snd r1) (cv_snd r2)))
</pre>

<DT><span class="strong">cv_rat_lt_def</span>
<DD>
<pre>
⊢ ∀r1 r2.
    cv_rat_lt r1 r2 =
    cv_int_lt (cv_int_mul (cv_fst r1) (cv_snd r2))
      (cv_int_mul (cv_fst r2) (cv_snd r1))
</pre>

<DT><span class="strong">cv_rat_mul_def</span>
<DD>
<pre>
⊢ ∀r1 r2.
    cv_rat_mul r1 r2 =
    cv_rat_norm
      (cv$Pair (cv_int_mul (cv_fst r1) (cv_fst r2))
         (cv_mul (cv_snd r1) (cv_snd r2)))
</pre>

<DT><span class="strong">cv_rat_neg_def</span>
<DD>
<pre>
⊢ ∀r. cv_rat_neg r = cv$Pair (cv_int_neg (cv_fst r)) (cv_snd r)
</pre>

<DT><span class="strong">cv_rat_norm_def</span>
<DD>
<pre>
⊢ ∀r. cv_rat_norm r =
      (let
         d = cv_gcd (cv_abs (cv_fst r)) (cv_snd r)
       in
         cv_if (cv_lt d (cv$Num 2)) r
           (cv$Pair (cv_total_int_div (cv_fst r) d) (cv_div (cv_snd r) d)))
</pre>

<DT><span class="strong">cv_rat_reciprocal_def</span>
<DD>
<pre>
⊢ ∀r. cv_rat_reciprocal r =
      cv_if (cv_int_lt (cv_fst r) (cv$Num 0))
        (cv$Pair (cv$Pair (cv_snd r) (cv$Num 0)) (cv_fst (cv_fst r)))
        (cv$Pair (cv_snd r) (cv_fst r))
</pre>

<DT><span class="strong">cv_total_int_div_def</span>
<DD>
<pre>
⊢ ∀i j.
    cv_total_int_div i j =
    cv_if (cv_eq j (cv$Num 0)) (cv$Num 0) (cv_int_div i j)
</pre>

<DT><span class="strong">cv_total_int_mod_def</span>
<DD>
<pre>
⊢ ∀i j. cv_total_int_mod i j = cv_if (cv_eq j (cv$Num 0)) i (cv_int_mod i j)
</pre>

<DT><span class="strong">cv_word_and_def</span>
<DD>
<pre>
⊢ ∀x y.
    cv_word_and x y =
    cv_if (cv_lt x y) (cv_word_and_loop x y) (cv_word_and_loop y x)
</pre>

<DT><span class="strong">cv_word_lt_def</span>
<DD>
<pre>
⊢ ∀w1 w2 msb1 msb2.
    cv_word_lt w1 w2 msb1 msb2 =
    cv_if (cv_eq msb1 msb2) (cv_lt w1 w2)
      (cv_if msb1 (cv$Num 1) (cv_sub (cv$Num 1) msb2))
</pre>

<DT><span class="strong">cv_word_or_def</span>
<DD>
<pre>
⊢ ∀x y.
    cv_word_or x y =
    cv_if (cv_lt x y) (cv_word_or_loop x y) (cv_word_or_loop y x)
</pre>

<DT><span class="strong">cv_word_sub_def</span>
<DD>
<pre>
⊢ ∀x y d.
    cv_word_sub x y d = cv_if (cv_lt x y) (cv_sub (cv_add x d) y) (cv_sub x y)
</pre>

<DT><span class="strong">cv_word_xor_def</span>
<DD>
<pre>
⊢ ∀x y.
    cv_word_xor x y =
    cv_if (cv_lt x y) (cv_word_xor_loop x y) (cv_word_xor_loop y x)
</pre>

<DT><span class="strong">total_int_div_def</span>
<DD>
<pre>
⊢ ∀i j. total_int_div i j = if j = 0 then 0 else i / j
</pre>

<DT><span class="strong">total_int_mod_def</span>
<DD>
<pre>
⊢ ∀i j. total_int_mod i j = if j = 0 then i else i % j
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">BITWISE</span>
<DD>
<pre>
⊢ BITWISE 0 b m n = 0 ∧
  BITWISE (SUC k) b m n =
  (if b (ODD m) (ODD n) then 1 else 0) + 2 * BITWISE k b (m DIV 2) (n DIV 2)
</pre>

<DT><span class="strong">BITWISE_ADD</span>
<DD>
<pre>
⊢ ∀l k m n b.
    BITWISE (l + k) b m n =
    BITWISE l b m n + BITWISE k b (m DIV 2 ** l) (n DIV 2 ** l) * 2 ** l
</pre>

<DT><span class="strong">cv_Num</span>
<DD>
<pre>
⊢ cv$Num (Num i) = cv_abs (from_int i)
</pre>

<DT><span class="strong">cv_chr_thm</span>
<DD>
<pre>
⊢ n < 256 ⇒ from_char (CHR n) = cv$Num n
</pre>

<DT><span class="strong">cv_gcd_def</span>
<DD>
<pre>
⊢ ∀b a. cv_gcd a b = cv_if a (cv_gcd (cv_mod b a) a) b
</pre>

<DT><span class="strong">cv_gcd_ind</span>
<DD>
<pre>
⊢ ∀P. (∀a b. (cv$c2b a ⇒ P (cv_mod b a) a) ⇒ P a b) ⇒ ∀v v1. P v v1
</pre>

<DT><span class="strong">cv_gcd_thm</span>
<DD>
<pre>
⊢ cv$Num (gcd a b) = cv_gcd (cv$Num a) (cv$Num b)
</pre>

<DT><span class="strong">cv_inline_imp</span>
<DD>
<pre>
⊢ b2c (a ⇒ b) = cv_if (b2c a) (b2c b) (cv$Num 1)
</pre>

<DT><span class="strong">cv_inline_v2n</span>
<DD>
<pre>
⊢ v2n = v2n_custom 0
</pre>

<DT><span class="strong">cv_inline_v2w</span>
<DD>
<pre>
⊢ ∀v. v2w v = n2w (v2n_custom 0 v)
</pre>

<DT><span class="strong">cv_inline_w2i</span>
<DD>
<pre>
⊢ w2i w = (let v = w in if word_msb v then -&w2n (-v) else &w2n v)
</pre>

<DT><span class="strong">cv_inline_w2v</span>
<DD>
<pre>
⊢ w2v w = (let d = dimindex (:α) in GENLIST (λi. word_bit (d − 1 − i) w) d)
</pre>

<DT><span class="strong">cv_inline_word_log2</span>
<DD>
<pre>
⊢ ∀w. word_log2 w = n2w (LOG2 (w2n w))
</pre>

<DT><span class="strong">cv_inline_word_ror</span>
<DD>
<pre>
⊢ ∀r a.
    a ⇄ r =
    (let a = a; d = dimindex (:α); r = r MOD d in a << (d − r) ‖ a ⋙ r)
</pre>

<DT><span class="strong">cv_inline_word_sw2sw</span>
<DD>
<pre>
⊢ sw2sw w =
  (let v = w in (if word_msb v then -1w << dimindex (:α) else 0w) + w2w v)
</pre>

<DT><span class="strong">cv_int_add</span>
<DD>
<pre>
⊢ from_int (i + j) = cv_int_add (from_int i) (from_int j)
</pre>

<DT><span class="strong">cv_int_div</span>
<DD>
<pre>
⊢ j ≠ 0 ⇒ from_int (i / j) = cv_int_div (from_int i) (from_int j)
</pre>

<DT><span class="strong">cv_int_ge</span>
<DD>
<pre>
⊢ b2c (i ≥ j) =
  cv_if (cv_int_lt (from_int i) (from_int j)) (cv$Num 0) (cv$Num 1)
</pre>

<DT><span class="strong">cv_int_gt</span>
<DD>
<pre>
⊢ b2c (i > j) = cv_int_lt (from_int j) (from_int i)
</pre>

<DT><span class="strong">cv_int_le</span>
<DD>
<pre>
⊢ b2c (i ≤ j) =
  cv_if (cv_int_lt (from_int j) (from_int i)) (cv$Num 0) (cv$Num 1)
</pre>

<DT><span class="strong">cv_int_lt</span>
<DD>
<pre>
⊢ b2c (i < j) = cv_int_lt (from_int i) (from_int j)
</pre>

<DT><span class="strong">cv_int_mod</span>
<DD>
<pre>
⊢ j ≠ 0 ⇒ from_int (i % j) = cv_int_mod (from_int i) (from_int j)
</pre>

<DT><span class="strong">cv_int_mul</span>
<DD>
<pre>
⊢ from_int (i * j) = cv_int_mul (from_int i) (from_int j)
</pre>

<DT><span class="strong">cv_int_of_num</span>
<DD>
<pre>
⊢ from_int (&n) = cv$Num n
</pre>

<DT><span class="strong">cv_int_sub</span>
<DD>
<pre>
⊢ from_int (i − j) = cv_int_add (from_int i) (cv_int_neg (from_int j))
</pre>

<DT><span class="strong">cv_log2_def</span>
<DD>
<pre>
⊢ ∀n acc.
    cv_log2 acc n =
    cv_if (cv_lt (cv$Num 1) n)
      (cv_log2 (cv_add acc (cv$Num 1)) (cv_div n (cv$Num 2))) acc
</pre>

<DT><span class="strong">cv_log2_ind</span>
<DD>
<pre>
⊢ ∀P. (∀acc n.
         (cv$c2b (cv_lt (cv$Num 1) n) ⇒
          P (cv_add acc (cv$Num 1)) (cv_div n (cv$Num 2))) ⇒
         P acc n) ⇒
      ∀v v1. P v v1
</pre>

<DT><span class="strong">cv_max_thm</span>
<DD>
<pre>
⊢ cv$Num (MAX m n) = cv_max (cv$Num m) (cv$Num n)
</pre>

<DT><span class="strong">cv_min_thm</span>
<DD>
<pre>
⊢ cv$Num (MIN m n) = cv_min (cv$Num m) (cv$Num n)
</pre>

<DT><span class="strong">cv_neg_int</span>
<DD>
<pre>
⊢ from_int (-x) = cv_int_neg (from_int x)
</pre>

<DT><span class="strong">cv_ord_thm</span>
<DD>
<pre>
⊢ cv$Num (ORD c) = from_char c
</pre>

<DT><span class="strong">cv_rat_add</span>
<DD>
<pre>
⊢ from_rat (r1 + r2) = cv_rat_add (from_rat r1) (from_rat r2)
</pre>

<DT><span class="strong">cv_rat_div</span>
<DD>
<pre>
⊢ r2 ≠ 0 ⇒
  from_rat (r1 / r2) =
  cv_rat_mul (from_rat r1) (cv_rat_reciprocal (from_rat r2))
</pre>

<DT><span class="strong">cv_rat_ge</span>
<DD>
<pre>
⊢ b2c (r1 ≥ r2) =
  cv_if (cv_rat_lt (from_rat r1) (from_rat r2)) (cv$Num 0) (cv$Num 1)
</pre>

<DT><span class="strong">cv_rat_gt</span>
<DD>
<pre>
⊢ b2c (r1 > r2) = cv_rat_lt (from_rat r2) (from_rat r1)
</pre>

<DT><span class="strong">cv_rat_le</span>
<DD>
<pre>
⊢ b2c (r1 ≤ r2) =
  cv_if (cv_rat_lt (from_rat r2) (from_rat r1)) (cv$Num 0) (cv$Num 1)
</pre>

<DT><span class="strong">cv_rat_lt</span>
<DD>
<pre>
⊢ b2c (r1 < r2) = cv_rat_lt (from_rat r1) (from_rat r2)
</pre>

<DT><span class="strong">cv_rat_mul</span>
<DD>
<pre>
⊢ from_rat (r1 * r2) = cv_rat_mul (from_rat r1) (from_rat r2)
</pre>

<DT><span class="strong">cv_rat_neg</span>
<DD>
<pre>
⊢ from_rat (-r) = cv_rat_neg (from_rat r)
</pre>

<DT><span class="strong">cv_rat_norm_div_gcd</span>
<DD>
<pre>
⊢ (λ(x,y). cv$Pair (from_int x) (cv$Num y)) (div_gcd a b) =
  cv_rat_norm (cv$Pair (from_int a) (cv$Num b))
</pre>

<DT><span class="strong">cv_rat_of_int</span>
<DD>
<pre>
⊢ from_rat (rat_of_int i) = cv$Pair (from_int i) (cv$Num 1)
</pre>

<DT><span class="strong">cv_rat_reciprocal</span>
<DD>
<pre>
⊢ r ≠ 0 ⇒ from_rat (rat_minv r) = cv_rat_reciprocal (from_rat r)
</pre>

<DT><span class="strong">cv_rat_sub</span>
<DD>
<pre>
⊢ from_rat (r1 − r2) = cv_rat_add (from_rat r1) (cv_rat_neg (from_rat r2))
</pre>

<DT><span class="strong">cv_rep_F</span>
<DD>
<pre>
⊢ b2c F = cv$Num 0
</pre>

<DT><span class="strong">cv_rep_LOG2</span>
<DD>
<pre>
⊢ n ≠ 0 ⇒ cv$Num (LOG2 n) = cv_log2 (cv$Num 0) (cv$Num n)
</pre>

<DT><span class="strong">cv_rep_T</span>
<DD>
<pre>
⊢ b2c T = cv$Num 1
</pre>

<DT><span class="strong">cv_rep_add</span>
<DD>
<pre>
⊢ cv$Num (n + m) = cv_add (cv$Num n) (cv$Num m)
</pre>

<DT><span class="strong">cv_rep_and</span>
<DD>
<pre>
⊢ b2c (b1 ∧ b2) = cv_if (b2c b1) (b2c b2) (cv$Num 0)
</pre>

<DT><span class="strong">cv_rep_arb</span>
<DD>
<pre>
⊢ F ⇒ f ARB = cv$Num 0
</pre>

<DT><span class="strong">cv_rep_dimindex</span>
<DD>
<pre>
⊢ cv$Num (dimindex (:α)) = cv$Num (dimindex (:α))
</pre>

<DT><span class="strong">cv_rep_div</span>
<DD>
<pre>
⊢ cv$Num (n DIV m) = cv_div (cv$Num n) (cv$Num m)
</pre>

<DT><span class="strong">cv_rep_eq</span>
<DD>
<pre>
⊢ cv_rep p1 c1 f x ∧ cv_rep p2 c2 f y ∧ from_to f t ⇒
  cv_rep (p1 ∧ p2) (cv_eq c1 c2) b2c (x = y)
</pre>

<DT><span class="strong">cv_rep_even</span>
<DD>
<pre>
⊢ b2c (EVEN n) = cv_sub (cv$Num 1) (cv_mod (cv$Num n) (cv$Num 2))
</pre>

<DT><span class="strong">cv_rep_exp</span>
<DD>
<pre>
⊢ cv$Num (n ** m) = cv_exp (cv$Num n) (cv$Num m)
</pre>

<DT><span class="strong">cv_rep_ge</span>
<DD>
<pre>
⊢ b2c (n ≥ m) = cv_sub (cv$Num 1) (cv_lt (cv$Num n) (cv$Num m))
</pre>

<DT><span class="strong">cv_rep_gt</span>
<DD>
<pre>
⊢ b2c (n > m) = cv_lt (cv$Num m) (cv$Num n)
</pre>

<DT><span class="strong">cv_rep_if</span>
<DD>
<pre>
⊢ cv_rep p1 c1 b2c b ∧ cv_rep p2 c2 f t ∧ cv_rep p3 c3 f e ⇒
  cv_rep (p1 ∧ (b ⇒ p2) ∧ (¬b ⇒ p3)) (cv_if c1 c2 c3) f (if b then t else e)
</pre>

<DT><span class="strong">cv_rep_le</span>
<DD>
<pre>
⊢ b2c (n ≤ m) = cv_sub (cv$Num 1) (cv_lt (cv$Num m) (cv$Num n))
</pre>

<DT><span class="strong">cv_rep_let</span>
<DD>
<pre>
⊢ cv_rep p1 c1 a x ∧ (∀v. cv_rep (p2 v) (c2 (a v)) b (y v)) ⇒
  cv_rep (p1 ∧ ∀v. v = x ⇒ p2 v) (LET c2 c1) b (LET y x)
</pre>

<DT><span class="strong">cv_rep_lt</span>
<DD>
<pre>
⊢ b2c (n < m) = cv_lt (cv$Num n) (cv$Num m)
</pre>

<DT><span class="strong">cv_rep_mod</span>
<DD>
<pre>
⊢ cv$Num (n MOD m) = cv_mod (cv$Num n) (cv$Num m)
</pre>

<DT><span class="strong">cv_rep_mul</span>
<DD>
<pre>
⊢ cv$Num (n * m) = cv_mul (cv$Num n) (cv$Num m)
</pre>

<DT><span class="strong">cv_rep_not</span>
<DD>
<pre>
⊢ b2c (¬b1) = cv_sub (cv$Num 1) (b2c b1)
</pre>

<DT><span class="strong">cv_rep_num_case</span>
<DD>
<pre>
⊢ cv_rep p1 c1 cv$Num x ∧ cv_rep p2 c2 a y ∧
  (∀v. cv_rep (p3 v) (c3 (cv$Num v)) a (z v)) ⇒
  cv_rep (p1 ∧ (x = 0 ⇒ p2) ∧ ∀n. x = SUC n ⇒ p3 n)
    (cv_if (cv_lt (cv$Num 0) c1) (let y = cv_sub c1 (cv$Num 1) in c3 y) c2) a
    (num_CASE x y z)
</pre>

<DT><span class="strong">cv_rep_odd</span>
<DD>
<pre>
⊢ b2c (ODD n) = cv_mod (cv$Num n) (cv$Num 2)
</pre>

<DT><span class="strong">cv_rep_or</span>
<DD>
<pre>
⊢ b2c (b1 ∨ b2) = cv_if (b2c b1) (cv$Num 1) (b2c b2)
</pre>

<DT><span class="strong">cv_rep_sub</span>
<DD>
<pre>
⊢ cv$Num (n − m) = cv_sub (cv$Num n) (cv$Num m)
</pre>

<DT><span class="strong">cv_rep_sub1</span>
<DD>
<pre>
⊢ cv$Num (PRE n) = cv_sub (cv$Num n) (cv$Num 1)
</pre>

<DT><span class="strong">cv_rep_suc</span>
<DD>
<pre>
⊢ cv$Num (SUC n) = cv_add (cv$Num n) (cv$Num 1)
</pre>

<DT><span class="strong">cv_rep_word_add</span>
<DD>
<pre>
⊢ from_word (w1 + w2) =
  cv_mod (cv_add (from_word w1) (from_word w2)) (cv$Num (dimword (:α)))
</pre>

<DT><span class="strong">cv_rep_word_and</span>
<DD>
<pre>
⊢ from_word (w1 && w2) = cv_word_and (from_word w1) (from_word w2)
</pre>

<DT><span class="strong">cv_rep_word_div</span>
<DD>
<pre>
⊢ from_word (w1 // w2) = cv_div (from_word w1) (from_word w2)
</pre>

<DT><span class="strong">cv_rep_word_lsl</span>
<DD>
<pre>
⊢ from_word (w << n) =
  cv_mod (cv_mul (from_word w) (cv_exp (cv$Num 2) (cv$Num n)))
    (cv$Num (2 ** dimindex (:α)))
</pre>

<DT><span class="strong">cv_rep_word_lsr</span>
<DD>
<pre>
⊢ from_word (w ⋙ n) =
  (let
     k = cv$Num n
   in
     cv_if (cv_lt k (cv$Num (dimindex (:α))))
       (cv_div (from_word w) (cv_exp (cv$Num 2) k)) (cv$Num 0))
</pre>

<DT><span class="strong">cv_rep_word_mod</span>
<DD>
<pre>
⊢ from_word (word_mod w1 w2) = cv_mod (from_word w1) (from_word w2)
</pre>

<DT><span class="strong">cv_rep_word_msb</span>
<DD>
<pre>
⊢ b2c (word_msb w) = cv_div (from_word w) (cv$Num (2 ** (dimindex (:α) − 1)))
</pre>

<DT><span class="strong">cv_rep_word_mul</span>
<DD>
<pre>
⊢ from_word (w1 * w2) =
  cv_mod (cv_mul (from_word w1) (from_word w2)) (cv$Num (dimword (:α)))
</pre>

<DT><span class="strong">cv_rep_word_n2w</span>
<DD>
<pre>
⊢ from_word (n2w n) = cv_mod (cv$Num n) (cv$Num (2 ** dimindex (:α)))
</pre>

<DT><span class="strong">cv_rep_word_neg</span>
<DD>
<pre>
⊢ from_word (-w1) =
  cv_word_sub (cv$Num 0) (from_word w1) (cv$Num (dimword (:α)))
</pre>

<DT><span class="strong">cv_rep_word_not</span>
<DD>
<pre>
⊢ from_word (¬w) = cv_word_xor (from_word w) (cv$Num (tops 2 (dimindex (:α))))
</pre>

<DT><span class="strong">cv_rep_word_or</span>
<DD>
<pre>
⊢ from_word (w1 ‖ w2) = cv_word_or (from_word w1) (from_word w2)
</pre>

<DT><span class="strong">cv_rep_word_sub</span>
<DD>
<pre>
⊢ from_word (w1 − w2) =
  cv_word_sub (from_word w1) (from_word w2) (cv$Num (dimword (:α)))
</pre>

<DT><span class="strong">cv_rep_word_uint_max</span>
<DD>
<pre>
⊢ from_word UINT_MAXw = cv$Num (tops 2 (dimindex (:α)))
</pre>

<DT><span class="strong">cv_rep_word_w2n</span>
<DD>
<pre>
⊢ cv$Num (w2n w) = from_word w
</pre>

<DT><span class="strong">cv_rep_word_w2w</span>
<DD>
<pre>
⊢ from_word (w2w w) =
  if dimindex (:α) ≤ dimindex (:β) then from_word w
  else cv_mod (from_word w) (cv$Num (2 ** dimindex (:β)))
</pre>

<DT><span class="strong">cv_rep_word_xor</span>
<DD>
<pre>
⊢ from_word (w1 ⊕ w2) = cv_word_xor (from_word w1) (from_word w2)
</pre>

<DT><span class="strong">cv_total_int_div</span>
<DD>
<pre>
⊢ from_int (total_int_div i j) = cv_total_int_div (from_int i) (from_int j)
</pre>

<DT><span class="strong">cv_total_int_mod</span>
<DD>
<pre>
⊢ from_int (total_int_mod i j) = cv_total_int_mod (from_int i) (from_int j)
</pre>

<DT><span class="strong">cv_word_and_loop_def</span>
<DD>
<pre>
⊢ ∀y x.
    cv_word_and_loop x y =
    cv_if (cv_lt (cv$Num 0) x)
      (cv_add
         (cv_mul (cv$Num 2)
            (cv_word_and_loop (cv_div x (cv$Num 2)) (cv_div y (cv$Num 2))))
         (cv_div (cv_add (cv_mod x (cv$Num 2)) (cv_mod y (cv$Num 2)))
            (cv$Num 2))) (cv$Num 0)
</pre>

<DT><span class="strong">cv_word_and_loop_ind</span>
<DD>
<pre>
⊢ ∀P. (∀x y.
         (cv$c2b (cv_lt (cv$Num 0) x) ⇒
          P (cv_div x (cv$Num 2)) (cv_div y (cv$Num 2))) ⇒
         P x y) ⇒
      ∀v v1. P v v1
</pre>

<DT><span class="strong">cv_word_and_loop_thm</span>
<DD>
<pre>
⊢ ∀m n.
    m ≤ n ∧ n < dimword (:α) ⇒
    cv_word_and_loop (cv$Num m) (cv$Num n) = cv$Num (w2n (n2w m && n2w n))
</pre>

<DT><span class="strong">cv_word_bit_thm</span>
<DD>
<pre>
⊢ b2c (word_bit b w) =
  cv_mod (cv_div (from_word w) (cv_exp (cv$Num 2) (cv$Num b))) (cv$Num 2)
</pre>

<DT><span class="strong">cv_word_bits_thm</span>
<DD>
<pre>
⊢ from_word ((h -- l) w) =
  cv_div
    (cv_mod (from_word w)
       (cv_exp (cv$Num 2)
          (cv_min (cv_add (cv$Num h) (cv$Num 1)) (cv$Num (dimindex (:α))))))
    (cv_exp (cv$Num 2) (cv$Num l))
</pre>

<DT><span class="strong">cv_word_concat_thm</span>
<DD>
<pre>
⊢ FINITE 𝕌(:α) ∧ FINITE 𝕌(:β) ⇒
  from_word (w1 @@ w2) =
  if dimindex (:α) + dimindex (:β) ≤ dimindex (:γ) then
    cv_add
      (cv_mul (from_word w1) (cv_exp (cv$Num 2) (cv$Num (dimindex (:β)))))
      (from_word w2)
  else
    cv_mod
      (cv_add
         (cv_mul (from_word w1) (cv_exp (cv$Num 2) (cv$Num (dimindex (:β)))))
         (from_word w2)) (cv$Num (2 ** dimindex (:γ)))
</pre>

<DT><span class="strong">cv_word_extract</span>
<DD>
<pre>
⊢ from_word ((h >< l) w) =
  if dimindex (:α) ≤ dimindex (:β) then
    cv_div
      (cv_mod (from_word w)
         (cv_exp (cv$Num 2)
            (cv_min (cv_add (cv$Num h) (cv$Num 1)) (cv$Num (dimindex (:α))))))
      (cv_exp (cv$Num 2) (cv$Num l))
  else
    cv_mod
      (cv_div
         (cv_mod (from_word w)
            (cv_exp (cv$Num 2)
               (cv_min (cv_add (cv$Num h) (cv$Num 1)) (cv$Num (dimindex (:α))))))
         (cv_exp (cv$Num 2) (cv$Num l))) (cv$Num (2 ** dimindex (:β)))
</pre>

<DT><span class="strong">cv_word_ge_thm</span>
<DD>
<pre>
⊢ b2c (w1 ≥ w2) =
  cv_sub (cv$Num 1)
    (cv_word_lt (from_word w1) (from_word w2)
       (cv_div (from_word w1) (cv$Num (2 ** (dimindex (:α) − 1))))
       (cv_div (from_word w2) (cv$Num (2 ** (dimindex (:α) − 1)))))
</pre>

<DT><span class="strong">cv_word_gt_thm</span>
<DD>
<pre>
⊢ b2c (w2 > w1) =
  cv_word_lt (from_word w1) (from_word w2)
    (cv_div (from_word w1) (cv$Num (2 ** (dimindex (:α) − 1))))
    (cv_div (from_word w2) (cv$Num (2 ** (dimindex (:α) − 1))))
</pre>

<DT><span class="strong">cv_word_hi_thm</span>
<DD>
<pre>
⊢ b2c (w2 >₊ w1) = cv_lt (from_word w1) (from_word w2)
</pre>

<DT><span class="strong">cv_word_hs_thm</span>
<DD>
<pre>
⊢ b2c (w1 ≥₊ w2) = cv_sub (cv$Num 1) (cv_lt (from_word w1) (from_word w2))
</pre>

<DT><span class="strong">cv_word_join_thm</span>
<DD>
<pre>
⊢ FINITE 𝕌(:α) ∧ FINITE 𝕌(:β) ⇒
  from_word (word_join w1 w2) =
  cv_add (cv_mul (from_word w1) (cv_exp (cv$Num 2) (cv$Num (dimindex (:β)))))
    (from_word w2)
</pre>

<DT><span class="strong">cv_word_le_thm</span>
<DD>
<pre>
⊢ b2c (w2 ≤ w1) =
  cv_sub (cv$Num 1)
    (cv_word_lt (from_word w1) (from_word w2)
       (cv_div (from_word w1) (cv$Num (2 ** (dimindex (:α) − 1))))
       (cv_div (from_word w2) (cv$Num (2 ** (dimindex (:α) − 1)))))
</pre>

<DT><span class="strong">cv_word_lo_thm</span>
<DD>
<pre>
⊢ b2c (w1 <₊ w2) = cv_lt (from_word w1) (from_word w2)
</pre>

<DT><span class="strong">cv_word_ls_thm</span>
<DD>
<pre>
⊢ b2c (w1 ≤₊ w2) = cv_sub (cv$Num 1) (cv_lt (from_word w2) (from_word w1))
</pre>

<DT><span class="strong">cv_word_lt_thm</span>
<DD>
<pre>
⊢ b2c (w1 < w2) =
  cv_word_lt (from_word w1) (from_word w2)
    (cv_div (from_word w1) (cv$Num (2 ** (dimindex (:α) − 1))))
    (cv_div (from_word w2) (cv$Num (2 ** (dimindex (:α) − 1))))
</pre>

<DT><span class="strong">cv_word_or_loop_def</span>
<DD>
<pre>
⊢ ∀y x.
    cv_word_or_loop x y =
    cv_if (cv_lt (cv$Num 0) x)
      (cv_add
         (cv_mul (cv$Num 2)
            (cv_word_or_loop (cv_div x (cv$Num 2)) (cv_div y (cv$Num 2))))
         (cv_max (cv_mod x (cv$Num 2)) (cv_mod y (cv$Num 2)))) y
</pre>

<DT><span class="strong">cv_word_or_loop_ind</span>
<DD>
<pre>
⊢ ∀P. (∀x y.
         (cv$c2b (cv_lt (cv$Num 0) x) ⇒
          P (cv_div x (cv$Num 2)) (cv_div y (cv$Num 2))) ⇒
         P x y) ⇒
      ∀v v1. P v v1
</pre>

<DT><span class="strong">cv_word_or_loop_thm</span>
<DD>
<pre>
⊢ ∀m n.
    m ≤ n ∧ n < dimword (:α) ⇒
    cv_word_or_loop (cv$Num m) (cv$Num n) = cv$Num (w2n (n2w m ‖ n2w n))
</pre>

<DT><span class="strong">cv_word_slice_thm</span>
<DD>
<pre>
⊢ from_word ((h '' l) w) =
  cv_mod
    (cv_mul
       (cv_div
          (cv_mod (from_word w)
             (cv_exp (cv$Num 2)
                (cv_min (cv_add (cv$Num h) (cv$Num 1))
                   (cv$Num (dimindex (:α)))))) (cv_exp (cv$Num 2) (cv$Num l)))
       (cv_exp (cv$Num 2) (cv$Num l))) (cv$Num (dimword (:α)))
</pre>

<DT><span class="strong">cv_word_xor_loop_def</span>
<DD>
<pre>
⊢ ∀y x.
    cv_word_xor_loop x y =
    cv_if (cv_lt (cv$Num 0) x)
      (cv_add
         (cv_mul (cv$Num 2)
            (cv_word_xor_loop (cv_div x (cv$Num 2)) (cv_div y (cv$Num 2))))
         (cv_mod (cv_add (cv_mod x (cv$Num 2)) (cv_mod y (cv$Num 2)))
            (cv$Num 2))) y
</pre>

<DT><span class="strong">cv_word_xor_loop_ind</span>
<DD>
<pre>
⊢ ∀P. (∀x y.
         (cv$c2b (cv_lt (cv$Num 0) x) ⇒
          P (cv_div x (cv$Num 2)) (cv_div y (cv$Num 2))) ⇒
         P x y) ⇒
      ∀v v1. P v v1
</pre>

<DT><span class="strong">cv_word_xor_loop_thm</span>
<DD>
<pre>
⊢ ∀m n.
    m ≤ n ∧ n < dimword (:α) ⇒
    cv_word_xor_loop (cv$Num m) (cv$Num n) = cv$Num (w2n (n2w m ⊕ n2w n))
</pre>

<DT><span class="strong">v2n_custom_def</span>
<DD>
<pre>
⊢ (∀acc. v2n_custom acc [] = acc) ∧
  (∀rest acc. v2n_custom acc (T::rest) = v2n_custom (2 * acc + 1) rest) ∧
  ∀rest acc. v2n_custom acc (F::rest) = v2n_custom (2 * acc) rest
</pre>

<DT><span class="strong">v2n_custom_ind</span>
<DD>
<pre>
⊢ ∀P. (∀acc. P acc []) ∧ (∀acc rest. P (2 * acc + 1) rest ⇒ P acc (T::rest)) ∧
      (∀acc rest. P (2 * acc) rest ⇒ P acc (F::rest)) ⇒
      ∀v v1. P v v1
</pre>

<DT><span class="strong">v2n_custom_thm</span>
<DD>
<pre>
⊢ v2n_custom 0 = v2n
</pre>

<DT><span class="strong">word_asr_add</span>
<DD>
<pre>
⊢ w ≫ n =
  (let
     x = w
   in
     if word_msb x then
       (dimindex (:α) − 1 '' dimindex (:α) − n) UINT_MAXw + x ⋙ n
     else x ⋙ n)
</pre>

</DL>



<hr>
</body>
</html>
