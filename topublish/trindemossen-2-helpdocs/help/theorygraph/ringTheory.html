<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: ring</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "ring"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "OmegaTheory.html"><span class="strong">Omega</span></a>&nbsp;&nbsp;
    <a href = "containerTheory.html"><span class="strong">container</span></a>&nbsp;&nbsp;
    <a href = "groupTheory.html"><span class="strong">group</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Type <th> Arity<tr><td> <span class="strong">ring</span> <td> 1
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">EuclideanRing</span>
    <td>
    :Î± ring -> (Î± -> num) -> bool
    <tr><td>
    <span class="strong">FiniteIntegralDomain</span>
    <td>
    :Î± ring -> bool
    <tr><td> <span class="strong">FiniteRing</span> <td> :Î± ring -> bool
    <tr><td> <span class="strong">IntegralDomain</span> <td> :Î± ring -> bool
    <tr><td>
    <span class="strong">PrincipalIdealRing</span>
    <td>
    :Î± ring -> bool
    <tr><td> <span class="strong">Ring</span> <td> :Î± ring -> bool
    <tr><td>
    <span class="strong">RingAuto</span>
    <td>
    :(Î± -> Î±) -> Î± ring -> bool
    <tr><td>
    <span class="strong">RingEndo</span>
    <td>
    :(Î± -> Î±) -> Î± ring -> bool
    <tr><td>
    <span class="strong">RingHomo</span>
    <td>
    :(Î± -> Î²) -> Î± ring -> Î² ring -> bool
    <tr><td>
    <span class="strong">RingIso</span>
    <td>
    :(Î± -> Î²) -> Î± ring -> Î² ring -> bool
    <tr><td> <span class="strong">Z</span> <td> :int ring
    <tr><td> <span class="strong">ZN</span> <td> :num -> num ring
    <tr><td> <span class="strong">ZP</span> <td> :num -> num ring
    <tr><td> <span class="strong">Z_add</span> <td> :int monoid
    <tr><td> <span class="strong">Z_ideal</span> <td> :num -> int ring
    <tr><td> <span class="strong">Z_mult</span> <td> :int monoid
    <tr><td> <span class="strong">Z_multiple</span> <td> :num -> int -> bool
    <tr><td> <span class="strong">char</span> <td> :Î± ring -> num
    <tr><td> <span class="strong">compute_ordz</span> <td> :num -> num -> num
    <tr><td>
    <span class="strong">homo_ideal</span>
    <td>
    :(Î± -> Î²) -> Î± ring -> Î² ring -> Î± ring -> Î² ring
    <tr><td>
    <span class="strong">homo_ring</span>
    <td>
    :Î± ring -> (Î± -> Î²) -> Î² ring
    <tr><td> <span class="strong">ideal</span> <td> :Î± ring -> Î± ring -> bool
    <tr><td>
    <span class="strong">ideal_congruence</span>
    <td>
    :Î± ring -> Î± ring -> Î± -> Î± -> bool
    <tr><td>
    <span class="strong">ideal_coset_add</span>
    <td>
    :Î± ring -> Î± ring -> (Î± -> bool) -> (Î± -> bool) -> Î± -> bool
    <tr><td>
    <span class="strong">ideal_coset_mult</span>
    <td>
    :Î± ring -> Î± ring -> (Î± -> bool) -> (Î± -> bool) -> Î± -> bool
    <tr><td>
    <span class="strong">ideal_gen</span>
    <td>
    :Î± ring -> Î± ring -> (Î± -> num) -> Î±
    <tr><td>
    <span class="strong">ideal_maximal</span>
    <td>
    :Î± ring -> Î± ring -> bool
    <tr><td>
    <span class="strong">ideal_sum</span>
    <td>
    :Î± ring -> Î± ring -> Î± ring -> Î± ring
    <tr><td> <span class="strong">irreducible</span> <td> :Î± ring -> Î± -> bool
    <tr><td>
    <span class="strong">kernel_ideal</span>
    <td>
    :(Î± -> Î²) -> Î± ring -> Î² ring -> Î± ring
    <tr><td>
    <span class="strong">monoid_of_ring_nonzero_mult</span>
    <td>
    :Î± ring -> Î± monoid
    <tr><td>
    <span class="strong">principal_ideal</span>
    <td>
    :Î± ring -> Î± -> Î± ring
    <tr><td>
    <span class="strong">quotient_ring</span>
    <td>
    :Î± ring -> Î± ring -> (Î± -> bool) ring
    <tr><td>
    <span class="strong">quotient_ring_add</span>
    <td>
    :Î± ring -> Î± ring -> (Î± -> bool) monoid
    <tr><td>
    <span class="strong">quotient_ring_mult</span>
    <td>
    :Î± ring -> Î± ring -> (Î± -> bool) monoid
    <tr><td>
    <span class="strong">recordtype.ring</span>
    <td>
    :(Î± -> bool) -> Î± monoid -> Î± monoid -> Î± ring
    <tr><td>
    <span class="strong">recordtype.ring.seldef.carrier</span>
    <td>
    :Î± ring -> Î± -> bool
    <tr><td>
    <span class="strong">recordtype.ring.seldef.carrier_fupd</span>
    <td>
    :((Î± -> bool) -> Î± -> bool) -> Î± ring -> Î± ring
    <tr><td>
    <span class="strong">recordtype.ring.seldef.prod</span>
    <td>
    :Î± ring -> Î± monoid
    <tr><td>
    <span class="strong">recordtype.ring.seldef.prod_fupd</span>
    <td>
    :(Î± monoid -> Î± monoid) -> Î± ring -> Î± ring
    <tr><td>
    <span class="strong">recordtype.ring.seldef.sum</span>
    <td>
    :Î± ring -> Î± monoid
    <tr><td>
    <span class="strong">recordtype.ring.seldef.sum_fupd</span>
    <td>
    :(Î± monoid -> Î± monoid) -> Î± ring -> Î± ring
    <tr><td>
    <span class="strong">ring_CASE</span>
    <td>
    :Î± ring -> ((Î± -> bool) -> Î± monoid -> Î± monoid -> Î²) -> Î²
    <tr><td>
    <span class="strong">ring_associates</span>
    <td>
    :Î± ring -> Î± -> Î± -> bool
    <tr><td>
    <span class="strong">ring_divides</span>
    <td>
    :Î± ring -> Î± -> Î± -> bool
    <tr><td>
    <span class="strong">ring_fun</span>
    <td>
    :Î± ring -> (Î² -> Î±) -> bool
    <tr><td>
    <span class="strong">ring_gcd</span>
    <td>
    :Î± ring -> (Î± -> num) -> Î± -> Î± -> Î±
    <tr><td>
    <span class="strong">ring_homo_image</span>
    <td>
    :(Î± -> Î²) -> Î± ring -> Î² ring -> Î² ring
    <tr><td>
    <span class="strong">ring_inj_image</span>
    <td>
    :Î± ring -> (Î± -> Î²) -> Î² ring
    <tr><td>
    <span class="strong">ring_list</span>
    <td>
    :Î± ring -> Î± list -> bool
    <tr><td>
    <span class="strong">ring_nonzero</span>
    <td>
    :Î± ring -> Î± -> bool
    <tr><td>
    <span class="strong">ring_ordering</span>
    <td>
    :Î± ring -> (Î± -> num) -> bool
    <tr><td> <span class="strong">ring_prime</span> <td> :Î± ring -> Î± -> bool
    <tr><td>
    <span class="strong">ring_size</span>
    <td>
    :(Î± -> num) -> Î± ring -> num
    <tr><td> <span class="strong">ring_sub</span> <td> :Î± ring -> Î± -> Î± -> Î±
    <tr><td> <span class="strong">ring_sum</span> <td> :Î± ring -> Î± list -> Î±
    <tr><td>
    <span class="strong">subring</span>
    <td>
    :Î± ring -> Î± ring -> bool
    <tr><td>
    <span class="strong">symdiff_set_inter</span>
    <td>
    :(Î± -> bool) ring
    <tr><td>
    <span class="strong">trivial_integal_domain</span>
    <td>
    :Î± -> Î± -> Î± ring
    <tr><td> <span class="strong">trivial_ring</span> <td> :Î± -> Î± ring
    <tr><td>
    <span class="strong">unit_eq</span>
    <td>
    :Î± ring -> Î± -> Î± -> bool
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">EuclideanRing_def</span>
<DD>
<pre>
âŠ¢ âˆ€r f.
    EuclideanRing r f â‡”
    Ring r âˆ§ (âˆ€x. f x = 0 â‡” x = #0) âˆ§
    âˆ€x y.
      x âˆˆ R âˆ§ y âˆˆ R âˆ§ y â‰  #0 â‡’ âˆƒq t. q âˆˆ R âˆ§ t âˆˆ R âˆ§ x = q * y + t âˆ§ f t < f y
</pre>

<DT><span class="strong">FiniteIntegralDomain_def</span>
<DD>
<pre>
âŠ¢ âˆ€r. FiniteIntegralDomain r â‡” IntegralDomain r âˆ§ FINITE R
</pre>

<DT><span class="strong">FiniteRing_def</span>
<DD>
<pre>
âŠ¢ âˆ€r. FiniteRing r â‡” Ring r âˆ§ FINITE R
</pre>

<DT><span class="strong">IntegralDomain_def</span>
<DD>
<pre>
âŠ¢ âˆ€r. IntegralDomain r â‡”
      Ring r âˆ§ #1 â‰  #0 âˆ§ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ (x * y = #0 â‡” x = #0 âˆ¨ y = #0)
</pre>

<DT><span class="strong">PrincipalIdealRing_def</span>
<DD>
<pre>
âŠ¢ âˆ€r. PrincipalIdealRing r â‡” Ring r âˆ§ âˆ€i. i << r â‡’ âˆƒp. p âˆˆ R âˆ§ <p> = i
</pre>

<DT><span class="strong">RingAuto_def</span>
<DD>
<pre>
âŠ¢ âˆ€f r. RingAuto f r â‡” RingIso f r r
</pre>

<DT><span class="strong">RingEndo_def</span>
<DD>
<pre>
âŠ¢ âˆ€f r. RingEndo f r â‡” RingHomo f r r
</pre>

<DT><span class="strong">RingHomo_def</span>
<DD>
<pre>
âŠ¢ âˆ€f r s.
    RingHomo f r s â‡”
    (âˆ€x. x âˆˆ R â‡’ f x âˆˆ s.carrier) âˆ§ GroupHomo f r.sum s.sum âˆ§
    MonoidHomo f r.prod s.prod
</pre>

<DT><span class="strong">RingIso_def</span>
<DD>
<pre>
âŠ¢ âˆ€f r s. RingIso f r s â‡” RingHomo f r s âˆ§ BIJ f R s.carrier
</pre>

<DT><span class="strong">Ring_def</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡”
      AbelianGroup r.sum âˆ§ AbelianMonoid r.prod âˆ§ r.sum.carrier = R âˆ§
      r.prod.carrier = R âˆ§
      âˆ€x y z. x âˆˆ R âˆ§ y âˆˆ R âˆ§ z âˆˆ R â‡’ x * (y + z) = x * y + x * z
</pre>

<DT><span class="strong">ZN_def</span>
<DD>
<pre>
âŠ¢ âˆ€n. ZN n = <|carrier := count n; sum := add_mod n; prod := times_mod n|>
</pre>

<DT><span class="strong">ZP_def</span>
<DD>
<pre>
âŠ¢ âˆ€p. ZP p = <|carrier := count p; sum := add_mod p; prod := times_mod p|>
</pre>

<DT><span class="strong">Z_add_def</span>
<DD>
<pre>
âŠ¢ Z_add = <|carrier := ğ•Œ(:int); op := (Î»x y. x + y); id := 0|>
</pre>

<DT><span class="strong">Z_def</span>
<DD>
<pre>
âŠ¢ Z = <|carrier := ğ•Œ(:int); sum := Z_add; prod := Z_mult|>
</pre>

<DT><span class="strong">Z_ideal_def</span>
<DD>
<pre>
âŠ¢ âˆ€n. Z* n =
      <|carrier := Z_multiple n;
        sum := <|carrier := Z_multiple n; op := Z.sum.op; id := Z.sum.id|>;
        prod := <|carrier := Z_multiple n; op := Z.prod.op; id := Z.prod.id|> |>
</pre>

<DT><span class="strong">Z_mult_def</span>
<DD>
<pre>
âŠ¢ Z_mult = <|carrier := ğ•Œ(:int); op := (Î»x y. x * y); id := 1|>
</pre>

<DT><span class="strong">Z_multiple_def</span>
<DD>
<pre>
âŠ¢ âˆ€n. Z_multiple n = {&n * z | z âˆˆ ğ•Œ(:int)}
</pre>

<DT><span class="strong">char_def</span>
<DD>
<pre>
âŠ¢ âˆ€r. char r = order r.sum #1
</pre>

<DT><span class="strong">compute_ordz_def</span>
<DD>
<pre>
âŠ¢ âˆ€m n.
    compute_ordz m n =
    if m = 0 then ordz 0 n
    else if m = 1 then 1
    else if coprime m n then WHILE (Î»i. n ** i MOD m â‰  1) SUC 1
    else 0
</pre>

<DT><span class="strong">homo_ideal_def</span>
<DD>
<pre>
âŠ¢ âˆ€f r s i.
    homo_ideal f r s i =
    <|carrier := IMAGE f i.carrier;
      sum := <|carrier := IMAGE f i.carrier; op := s.sum.op; id := f #0|>;
      prod := <|carrier := IMAGE f i.carrier; op := s.prod.op; id := f #1|> |>
</pre>

<DT><span class="strong">homo_ring_def</span>
<DD>
<pre>
âŠ¢ âˆ€r f.
    homo_ring r f =
    <|carrier := IMAGE f R; sum := homo_group r.sum f;
      prod := homo_group r.prod f|>
</pre>

<DT><span class="strong">ideal_congruence_def</span>
<DD>
<pre>
âŠ¢ âˆ€r i x y. x === y â‡” x âˆ’ y âˆˆ i.carrier
</pre>

<DT><span class="strong">ideal_coset_add_def</span>
<DD>
<pre>
âŠ¢ âˆ€r i x y. x + y = (gen x + gen y) âˆ˜ i.carrier
</pre>

<DT><span class="strong">ideal_coset_mult_def</span>
<DD>
<pre>
âŠ¢ âˆ€r i x y. x * y = (gen x * gen y) âˆ˜ i.carrier
</pre>

<DT><span class="strong">ideal_def</span>
<DD>
<pre>
âŠ¢ âˆ€i r.
    i << r â‡”
    i.sum â‰¤ r.sum âˆ§ i.sum.carrier = i.carrier âˆ§ i.prod.carrier = i.carrier âˆ§
    i.prod.op = $* âˆ§ i.prod.id = #1 âˆ§
    âˆ€x y. x âˆˆ i.carrier âˆ§ y âˆˆ R â‡’ x * y âˆˆ i.carrier âˆ§ y * x âˆˆ i.carrier
</pre>

<DT><span class="strong">ideal_gen_def</span>
<DD>
<pre>
âŠ¢ âˆ€r i f.
    Ring r âˆ§ i << r âˆ§ i â‰  <#0> âˆ§ (âˆ€x. f x = 0 â‡” x = #0) â‡’
    ideal_gen r i f âˆˆ i.carrier âˆ§ ideal_gen r i f â‰  #0 âˆ§
    âˆ€z. z âˆˆ i.carrier âˆ§ z â‰  #0 â‡’ f (ideal_gen r i f) â‰¤ f z
</pre>

<DT><span class="strong">ideal_maximal_def</span>
<DD>
<pre>
âŠ¢ âˆ€r i. maxi i â‡” i << r âˆ§ âˆ€j. i << j âˆ§ j << r â‡’ i = j âˆ¨ j = r
</pre>

<DT><span class="strong">ideal_sum_def</span>
<DD>
<pre>
âŠ¢ âˆ€r i j.
    i + j =
    <|carrier := {x + y | x âˆˆ i.carrier âˆ§ y âˆˆ j.carrier};
      sum :=
        <|carrier := {x + y | x âˆˆ i.carrier âˆ§ y âˆˆ j.carrier}; op := $+;
          id := #0|>;
      prod :=
        <|carrier := {x + y | x âˆˆ i.carrier âˆ§ y âˆˆ j.carrier}; op := $*;
          id := #1|> |>
</pre>

<DT><span class="strong">irreducible_def</span>
<DD>
<pre>
âŠ¢ âˆ€r z.
    atom z â‡”
    z âˆˆ R+ âˆ§ z âˆ‰ R* âˆ§ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R âˆ§ z = x * y â‡’ unit x âˆ¨ unit y
</pre>

<DT><span class="strong">kernel_ideal_def</span>
<DD>
<pre>
âŠ¢ âˆ€f r s.
    kernel_ideal f r s =
    <|carrier := kernel f r.sum s.sum;
      sum := <|carrier := kernel f r.sum s.sum; op := $+; id := #0|>;
      prod := <|carrier := kernel f r.sum s.sum; op := $*; id := #1|> |>
</pre>

<DT><span class="strong">monoid_of_ring_nonzero_mult_def</span>
<DD>
<pre>
âŠ¢ âˆ€r. monoid_of_ring_nonzero_mult r = <|carrier := R+; op := $*; id := #1|>
</pre>

<DT><span class="strong">principal_ideal_def</span>
<DD>
<pre>
âŠ¢ âˆ€r p.
    <p> =
    <|carrier := p * R; sum := <|carrier := p * R; op := $+; id := #0|>;
      prod := <|carrier := p * R; op := $*; id := #1|> |>
</pre>

<DT><span class="strong">quotient_ring_add_def</span>
<DD>
<pre>
âŠ¢ âˆ€r i. quotient_ring_add r i = <|carrier := R/I; id := i.carrier; op := $+ |>
</pre>

<DT><span class="strong">quotient_ring_def</span>
<DD>
<pre>
âŠ¢ âˆ€r i.
    r / i =
    <|carrier := R/I; sum := quotient_ring_add r i;
      prod := quotient_ring_mult r i|>
</pre>

<DT><span class="strong">quotient_ring_mult_def</span>
<DD>
<pre>
âŠ¢ âˆ€r i.
    quotient_ring_mult r i =
    <|carrier := R/I; id := #1 âˆ˜ i.carrier; op := $* |>
</pre>

<DT><span class="strong">recordtype_ring_seldef_carrier_def</span>
<DD>
<pre>
âŠ¢ âˆ€f m m0. (ring f m m0).carrier = f
</pre>

<DT><span class="strong">recordtype_ring_seldef_carrier_fupd_def</span>
<DD>
<pre>
âŠ¢ âˆ€f0 f m m0. ring f m m0 with carrier updated_by f0 = ring (f0 f) m m0
</pre>

<DT><span class="strong">recordtype_ring_seldef_prod_def</span>
<DD>
<pre>
âŠ¢ âˆ€f m m0. (ring f m m0).prod = m0
</pre>

<DT><span class="strong">recordtype_ring_seldef_prod_fupd_def</span>
<DD>
<pre>
âŠ¢ âˆ€f0 f m m0. ring f m m0 with prod updated_by f0 = ring f m (f0 m0)
</pre>

<DT><span class="strong">recordtype_ring_seldef_sum_def</span>
<DD>
<pre>
âŠ¢ âˆ€f m m0. (ring f m m0).sum = m
</pre>

<DT><span class="strong">recordtype_ring_seldef_sum_fupd_def</span>
<DD>
<pre>
âŠ¢ âˆ€f0 f m m0. ring f m m0 with sum updated_by f0 = ring f (f0 m) m0
</pre>

<DT><span class="strong">ring_TY_DEF</span>
<DD>
<pre>
âŠ¢ âˆƒrep.
    TYPE_DEFINITION
      (Î»a0'.
           âˆ€ $var$('ring').
             (âˆ€a0'.
                (âˆƒa0 a1 a2.
                   a0' =
                   (Î»a0 a1 a2.
                        ind_type$CONSTR 0 (a0,a1,a2) (Î»n. ind_type$BOTTOM)) a0
                     a1 a2) â‡’
                $var$('ring') a0') â‡’
             $var$('ring') a0') rep
</pre>

<DT><span class="strong">ring_associates_def</span>
<DD>
<pre>
âŠ¢ âˆ€r p q. rassoc p q â‡” âˆƒs. unit s âˆ§ p = s * q
</pre>

<DT><span class="strong">ring_case_def</span>
<DD>
<pre>
âŠ¢ âˆ€a0 a1 a2 f. ring_CASE (ring a0 a1 a2) f = f a0 a1 a2
</pre>

<DT><span class="strong">ring_divides_def</span>
<DD>
<pre>
âŠ¢ âˆ€r q p. q rdivides p â‡” âˆƒs. s âˆˆ R âˆ§ p = s * q
</pre>

<DT><span class="strong">ring_fun_def</span>
<DD>
<pre>
âŠ¢ âˆ€r f. rfun f â‡” âˆ€x. f x âˆˆ R
</pre>

<DT><span class="strong">ring_gcd_def</span>
<DD>
<pre>
âŠ¢ âˆ€r f p q.
    rgcd p q =
    if p = #0 then q
    else if q = #0 then p
    else
      (let
         s = {a * p + b * q | (a,b) | a âˆˆ R âˆ§ b âˆˆ R âˆ§ 0 < f (a * p + b * q)}
       in
         CHOICE (preimage f s (MIN_SET (IMAGE f s))))
</pre>

<DT><span class="strong">ring_homo_image_def</span>
<DD>
<pre>
âŠ¢ âˆ€f r r_.
    ring_homo_image f r r_ =
    <|carrier := IMAGE f R; sum := homo_image f r.sum r_.sum;
      prod := homo_image f r.prod r_.prod|>
</pre>

<DT><span class="strong">ring_inj_image_def</span>
<DD>
<pre>
âŠ¢ âˆ€r f.
    ring_inj_image r f =
    <|carrier := IMAGE f R;
      sum :=
        <|carrier := IMAGE f R; op := (Î»x y. f (LINV f R x + LINV f R y));
          id := f #0|>;
      prod :=
        <|carrier := IMAGE f R; op := (Î»x y. f (LINV f R x * LINV f R y));
          id := f #1|> |>
</pre>

<DT><span class="strong">ring_list_def</span>
<DD>
<pre>
âŠ¢ (âˆ€r. rlist [] â‡” T) âˆ§ âˆ€r h t. rlist (h::t) â‡” h âˆˆ R âˆ§ rlist t
</pre>

<DT><span class="strong">ring_nonzero_def</span>
<DD>
<pre>
âŠ¢ âˆ€r. R+ = R DIFF {#0}
</pre>

<DT><span class="strong">ring_ordering_def</span>
<DD>
<pre>
âŠ¢ âˆ€r f. ring_ordering r f â‡” âˆ€a b. a âˆˆ R âˆ§ b âˆˆ R âˆ§ b â‰  #0 â‡’ f a â‰¤ f (a * b)
</pre>

<DT><span class="strong">ring_prime_def</span>
<DD>
<pre>
âŠ¢ âˆ€r p.
    rprime p â‡”
    âˆ€a b. a âˆˆ R âˆ§ b âˆˆ R âˆ§ p rdivides a * b â‡’ p rdivides a âˆ¨ p rdivides b
</pre>

<DT><span class="strong">ring_size_def</span>
<DD>
<pre>
âŠ¢ âˆ€f a0 a1 a2.
    ring_size f (ring a0 a1 a2) = 1 + (monoid_size f a1 + monoid_size f a2)
</pre>

<DT><span class="strong">ring_sub_def</span>
<DD>
<pre>
âŠ¢ âˆ€r x y. x âˆ’ y = x + -y
</pre>

<DT><span class="strong">ring_sum_def</span>
<DD>
<pre>
âŠ¢ (âˆ€r. rsum [] = #0) âˆ§ âˆ€r h t. rsum (h::t) = h + rsum t
</pre>

<DT><span class="strong">subring_def</span>
<DD>
<pre>
âŠ¢ âˆ€s r. subring s r â‡” RingHomo I s r
</pre>

<DT><span class="strong">symdiff_set_inter_def</span>
<DD>
<pre>
âŠ¢ symdiff_set_inter =
  <|carrier := ğ•Œ(:Î± -> bool); sum := symdiff_set; prod := set_inter|>
</pre>

<DT><span class="strong">trivial_integal_domain_def</span>
<DD>
<pre>
âŠ¢ âˆ€e0 e1.
    trivial_integal_domain e0 e1 =
    <|carrier := {e0; e1};
      sum :=
        <|carrier := {e0; e1}; id := e0;
          op := (Î»x y. if x = e0 then y else if y = e0 then x else e0)|>;
      prod :=
        <|carrier := {e0; e1}; id := e1;
          op := (Î»x y. if x = e0 then e0 else if y = e0 then e0 else e1)|> |>
</pre>

<DT><span class="strong">trivial_ring_def</span>
<DD>
<pre>
âŠ¢ âˆ€z. trivial_ring z =
      <|carrier := {z}; sum := <|carrier := {z}; id := z; op := (Î»x y. z)|>;
        prod := <|carrier := {z}; id := z; op := (Î»x y. z)|> |>
</pre>

<DT><span class="strong">unit_eq_def</span>
<DD>
<pre>
âŠ¢ âˆ€r x y. x =~ y â‡” âˆƒu. unit u âˆ§ x = u * y
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">EXISTS_ring</span>
<DD>
<pre>
âŠ¢ âˆ€P. (âˆƒr. P r) â‡” âˆƒf m0 m. P <|carrier := f; sum := m0; prod := m|>
</pre>

<DT><span class="strong">FORALL_ring</span>
<DD>
<pre>
âŠ¢ âˆ€P. (âˆ€r. P r) â‡” âˆ€f m0 m. P <|carrier := f; sum := m0; prod := m|>
</pre>

<DT><span class="strong">LIST_REL_ring_associates_product</span>
<DD>
<pre>
âŠ¢ Ring r â‡’
  âˆ€l1 l2.
    LIST_REL rassoc l1 l2 âˆ§ LIST_TO_SET l2 âŠ† R â‡’
    rassoc (GBAG r.prod (LIST_TO_BAG l1)) (GBAG r.prod (LIST_TO_BAG l2))
</pre>

<DT><span class="strong">WHILE_RULE_PRE_POST</span>
<DD>
<pre>
âŠ¢ (âˆ€x. Invariant x âˆ§ Guard x â‡’ f (Cmd x) < f x) âˆ§
  (âˆ€x. Precond x â‡’ Invariant x) âˆ§ (âˆ€x. Invariant x âˆ§ Â¬Guard x â‡’ Postcond x) âˆ§
  HOARE_SPEC (Î»x. Invariant x âˆ§ Guard x) Cmd Invariant â‡’
  HOARE_SPEC Precond (WHILE Guard Cmd) Postcond
</pre>

<DT><span class="strong">ZN_1_exp</span>
<DD>
<pre>
âŠ¢ âˆ€n k. (ZN 1).prod.exp n k = 0
</pre>

<DT><span class="strong">ZN_card</span>
<DD>
<pre>
âŠ¢ âˆ€n. CARD (ZN n).carrier = n
</pre>

<DT><span class="strong">ZN_char</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ char (ZN n) = n
</pre>

<DT><span class="strong">ZN_coprime_euler_element</span>
<DD>
<pre>
âŠ¢ âˆ€m n. 1 < m âˆ§ coprime m n â‡’ n MOD m âˆˆ Euler m
</pre>

<DT><span class="strong">ZN_coprime_exp_mod</span>
<DD>
<pre>
âŠ¢ âˆ€m n. 0 < m âˆ§ coprime m n â‡’ âˆ€k. n ** k MOD m = n ** (k MOD ordz m n) MOD m
</pre>

<DT><span class="strong">ZN_coprime_invertible</span>
<DD>
<pre>
âŠ¢ âˆ€m n. 1 < m âˆ§ coprime m n â‡’ Unit (ZN m) (n MOD m)
</pre>

<DT><span class="strong">ZN_coprime_order</span>
<DD>
<pre>
âŠ¢ âˆ€m n. 0 < m âˆ§ coprime m n â‡’ 0 < ordz m n âˆ§ n ** ordz m n MOD m = 1 MOD m
</pre>

<DT><span class="strong">ZN_coprime_order_alt</span>
<DD>
<pre>
âŠ¢ âˆ€m n. 1 < m âˆ§ coprime m n â‡’ 0 < ordz m n âˆ§ n ** ordz m n MOD m = 1
</pre>

<DT><span class="strong">ZN_coprime_order_divides_phi</span>
<DD>
<pre>
âŠ¢ âˆ€m n. 0 < m âˆ§ coprime m n â‡’ ordz m n divides phi m
</pre>

<DT><span class="strong">ZN_coprime_order_divides_totient</span>
<DD>
<pre>
âŠ¢ âˆ€m n. 0 < m âˆ§ coprime m n â‡’ ordz m n divides totient m
</pre>

<DT><span class="strong">ZN_coprime_order_gt_1</span>
<DD>
<pre>
âŠ¢ âˆ€m n. 1 < m âˆ§ 1 < n MOD m âˆ§ coprime m n â‡’ 1 < ordz m n
</pre>

<DT><span class="strong">ZN_coprime_order_lt</span>
<DD>
<pre>
âŠ¢ âˆ€m n. 1 < m âˆ§ coprime m n â‡’ ordz m n < m
</pre>

<DT><span class="strong">ZN_eval</span>
<DD>
<pre>
âŠ¢ âˆ€n. (ZN n).carrier = count n âˆ§ (ZN n).sum = add_mod n âˆ§
      (ZN n).prod = times_mod n
</pre>

<DT><span class="strong">ZN_exp</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ âˆ€x k. (ZN n).prod.exp x k = x ** k MOD n
</pre>

<DT><span class="strong">ZN_finite</span>
<DD>
<pre>
âŠ¢ âˆ€n. FINITE (ZN n).carrier
</pre>

<DT><span class="strong">ZN_finite_ring</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ FiniteRing (ZN n)
</pre>

<DT><span class="strong">ZN_ids</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ (ZN n).sum.id = 0 âˆ§ (ZN n).prod.id = 1 MOD n
</pre>

<DT><span class="strong">ZN_ids_alt</span>
<DD>
<pre>
âŠ¢ âˆ€n. 1 < n â‡’ (ZN n).sum.id = 0 âˆ§ (ZN n).prod.id = 1
</pre>

<DT><span class="strong">ZN_invertibles</span>
<DD>
<pre>
âŠ¢ âˆ€n. 1 < n â‡’ Invertibles (ZN n).prod = Estar n
</pre>

<DT><span class="strong">ZN_invertibles_finite_group</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ FiniteGroup (Invertibles (ZN n).prod)
</pre>

<DT><span class="strong">ZN_invertibles_group</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ Group (Invertibles (ZN n).prod)
</pre>

<DT><span class="strong">ZN_invertibles_order</span>
<DD>
<pre>
âŠ¢ âˆ€m n. 0 < m â‡’ order (Invertibles (ZN m).prod) (n MOD m) = ordz m n
</pre>

<DT><span class="strong">ZN_mult_inv_coprime</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ âˆ€x y. (x * y) MOD n = 1 â‡’ coprime x n
</pre>

<DT><span class="strong">ZN_mult_inv_coprime_iff</span>
<DD>
<pre>
âŠ¢ âˆ€n. 1 < n â‡’ âˆ€x. coprime x n â‡” âˆƒy. (x * y) MOD n = 1
</pre>

<DT><span class="strong">ZN_not_coprime</span>
<DD>
<pre>
âŠ¢ âˆ€m n. 0 < m âˆ§ gcd m n â‰  1 â‡’ âˆ€k. 0 < k â‡’ n ** k MOD m â‰  1
</pre>

<DT><span class="strong">ZN_num</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ âˆ€k. (ZN n).sum.exp 1 k = k MOD n
</pre>

<DT><span class="strong">ZN_num_0</span>
<DD>
<pre>
âŠ¢ âˆ€n c. 0 < n â‡’ (ZN n).sum.exp 0 c = 0
</pre>

<DT><span class="strong">ZN_num_1</span>
<DD>
<pre>
âŠ¢ âˆ€n. (ZN n).sum.exp (ZN n).prod.id 1 = 1 MOD n
</pre>

<DT><span class="strong">ZN_num_mod</span>
<DD>
<pre>
âŠ¢ âˆ€n c. 0 < n â‡’ (ZN n).sum.exp (ZN n).prod.id c = c MOD n
</pre>

<DT><span class="strong">ZN_order_0</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ ordz n 0 = if n = 1 then 1 else 0
</pre>

<DT><span class="strong">ZN_order_1</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ ordz n 1 = 1
</pre>

<DT><span class="strong">ZN_order_divides_exp</span>
<DD>
<pre>
âŠ¢ âˆ€m n k. 1 < m âˆ§ 0 < k â‡’ (n ** k MOD m = 1 â‡” ordz m n divides k)
</pre>

<DT><span class="strong">ZN_order_divides_phi</span>
<DD>
<pre>
âŠ¢ âˆ€m n. 0 < m âˆ§ 0 < ordz m n â‡’ ordz m n divides phi m
</pre>

<DT><span class="strong">ZN_order_divides_tops_index</span>
<DD>
<pre>
âŠ¢ âˆ€n j k. 1 < n âˆ§ 0 < j âˆ§ 1 < k â‡’ (k divides tops n j â‡” ordz k n divides j)
</pre>

<DT><span class="strong">ZN_order_divisibility</span>
<DD>
<pre>
âŠ¢ âˆ€m n. 0 < m â‡’ m divides tops n (ordz m n)
</pre>

<DT><span class="strong">ZN_order_eq_0</span>
<DD>
<pre>
âŠ¢ âˆ€m n. 0 < m â‡’ (ordz m n = 0 â‡” gcd m n â‰  1)
</pre>

<DT><span class="strong">ZN_order_eq_0_iff</span>
<DD>
<pre>
âŠ¢ âˆ€m n. 1 < m â‡’ (ordz m n = 0 â‡” âˆ€k. 0 < k â‡’ n ** k MOD m â‰  1)
</pre>

<DT><span class="strong">ZN_order_eq_0_test</span>
<DD>
<pre>
âŠ¢ âˆ€m n. 1 < m â‡’ (ordz m n = 0 â‡” âˆ€j. 0 < j âˆ§ j < m â‡’ n ** j MOD m â‰  1)
</pre>

<DT><span class="strong">ZN_order_eq_1</span>
<DD>
<pre>
âŠ¢ âˆ€m n. 0 < m â‡’ (ordz m n = 1 â‡” n MOD m = 1 MOD m)
</pre>

<DT><span class="strong">ZN_order_eq_1_alt</span>
<DD>
<pre>
âŠ¢ âˆ€m n. 1 < m â‡’ (ordz m n = 1 â‡” n MOD m = 1)
</pre>

<DT><span class="strong">ZN_order_eq_1_by_prime_factors</span>
<DD>
<pre>
âŠ¢ âˆ€m n.
    0 < m âˆ§ coprime m n âˆ§ (âˆ€p. prime p âˆ§ p divides n â‡’ ordz m p = 1) â‡’
    ordz m n = 1
</pre>

<DT><span class="strong">ZN_order_gt_1_property</span>
<DD>
<pre>
âŠ¢ âˆ€m n. 0 < m âˆ§ 1 < ordz m n â‡’ âˆƒp. prime p âˆ§ p divides n âˆ§ 1 < ordz m p
</pre>

<DT><span class="strong">ZN_order_le</span>
<DD>
<pre>
âŠ¢ âˆ€m n. 0 < m â‡’ ordz m n â‰¤ m
</pre>

<DT><span class="strong">ZN_order_le_tops_index</span>
<DD>
<pre>
âŠ¢ âˆ€n j k. 1 < n âˆ§ 0 < j âˆ§ 1 < k âˆ§ k divides tops n j â‡’ ordz k n â‰¤ j
</pre>

<DT><span class="strong">ZN_order_lt</span>
<DD>
<pre>
âŠ¢ âˆ€k n m. 0 < k âˆ§ k < m â‡’ ordz k n < m
</pre>

<DT><span class="strong">ZN_order_minimal</span>
<DD>
<pre>
âŠ¢ âˆ€m n k. 0 < m âˆ§ 0 < k âˆ§ k < ordz m n â‡’ n ** k MOD m â‰  1
</pre>

<DT><span class="strong">ZN_order_mod</span>
<DD>
<pre>
âŠ¢ âˆ€m n. 0 < m â‡’ ordz m (n MOD m) = ordz m n
</pre>

<DT><span class="strong">ZN_order_mod_1</span>
<DD>
<pre>
âŠ¢ âˆ€n. ordz 1 n = 1
</pre>

<DT><span class="strong">ZN_order_nonzero</span>
<DD>
<pre>
âŠ¢ âˆ€m n. 0 < m â‡’ (ordz m n â‰  0 â‡” coprime m n)
</pre>

<DT><span class="strong">ZN_order_nonzero_iff</span>
<DD>
<pre>
âŠ¢ âˆ€m n. 1 < m â‡’ (ordz m n â‰  0 â‡” âˆƒk. 0 < k âˆ§ n ** k MOD m = 1)
</pre>

<DT><span class="strong">ZN_order_property</span>
<DD>
<pre>
âŠ¢ âˆ€m n. 0 < m â‡’ n ** ordz m n MOD m = 1 MOD m
</pre>

<DT><span class="strong">ZN_order_property_alt</span>
<DD>
<pre>
âŠ¢ âˆ€m n. 1 < m â‡’ n ** ordz m n MOD m = 1
</pre>

<DT><span class="strong">ZN_order_test_1</span>
<DD>
<pre>
âŠ¢ âˆ€m n k.
    1 < m âˆ§ 0 < k â‡’
    (ordz m n = k â‡” n ** k MOD m = 1 âˆ§ âˆ€j. 0 < j âˆ§ j < k â‡’ n ** j MOD m â‰  1)
</pre>

<DT><span class="strong">ZN_order_test_2</span>
<DD>
<pre>
âŠ¢ âˆ€m n k.
    1 < m âˆ§ 0 < k â‡’
    (ordz m n = k â‡”
     n ** k MOD m = 1 âˆ§ âˆ€j. 0 < j âˆ§ j < k âˆ§ j divides phi m â‡’ n ** j MOD m â‰  1)
</pre>

<DT><span class="strong">ZN_order_test_3</span>
<DD>
<pre>
âŠ¢ âˆ€m n k.
    1 < m âˆ§ 0 < k â‡’
    (ordz m n = k â‡”
     k divides phi m âˆ§ n ** k MOD m = 1 âˆ§
     âˆ€j. 0 < j âˆ§ j < k âˆ§ j divides phi m â‡’ n ** j MOD m â‰  1)
</pre>

<DT><span class="strong">ZN_order_test_4</span>
<DD>
<pre>
âŠ¢ âˆ€m n k.
    1 < m â‡’
    (ordz m n = k â‡”
     n ** k MOD m = 1 âˆ§
     âˆ€j. 0 < j âˆ§ j < (if k = 0 then m else k) â‡’ n ** j MOD m â‰  1)
</pre>

<DT><span class="strong">ZN_order_test_propery</span>
<DD>
<pre>
âŠ¢ âˆ€m n k.
    1 < m âˆ§ 0 < k âˆ§ n ** k MOD m = 1 âˆ§
    (âˆ€j. 0 < j âˆ§ j < k âˆ§ j divides phi m â‡’ n ** j MOD m â‰  1) â‡’
    âˆ€j. 0 < j âˆ§ j < k âˆ§ Â¬(j divides phi m) â‡’ ordz m n = k âˆ¨ n ** j MOD m â‰  1
</pre>

<DT><span class="strong">ZN_order_upper</span>
<DD>
<pre>
âŠ¢ âˆ€m n. 0 < m â‡’ ordz m n â‰¤ phi m
</pre>

<DT><span class="strong">ZN_order_with_coprime_1</span>
<DD>
<pre>
âŠ¢ âˆ€m n. 1 < n âˆ§ coprime m n âˆ§ 1 < ordz m n â‡’ 1 < m
</pre>

<DT><span class="strong">ZN_order_with_coprime_2</span>
<DD>
<pre>
âŠ¢ âˆ€m n k. 1 < m âˆ§ m divides n âˆ§ 1 < ordz k m âˆ§ coprime k n â‡’ 1 < n âˆ§ 1 < k
</pre>

<DT><span class="strong">ZN_property</span>
<DD>
<pre>
âŠ¢ âˆ€n. (âˆ€x. x âˆˆ (ZN n).carrier â‡” x < n) âˆ§ (ZN n).sum.id = 0 âˆ§
      (ZN n).prod.id = (if n = 1 then 0 else 1) âˆ§
      (âˆ€x y. (ZN n).sum.op x y = (x + y) MOD n) âˆ§
      (âˆ€x y. (ZN n).prod.op x y = (x * y) MOD n) âˆ§ FINITE (ZN n).carrier âˆ§
      CARD (ZN n).carrier = n
</pre>

<DT><span class="strong">ZN_ring</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’ Ring (ZN n)
</pre>

<DT><span class="strong">ZN_to_ZN_element</span>
<DD>
<pre>
âŠ¢ âˆ€n m x. 0 < m âˆ§ x âˆˆ (ZN n).carrier â‡’ x MOD m âˆˆ (ZN m).carrier
</pre>

<DT><span class="strong">ZN_to_ZN_prod_monoid_homo</span>
<DD>
<pre>
âŠ¢ âˆ€n m. 0 < n âˆ§ m divides n â‡’ MonoidHomo (Î»x. x MOD m) (ZN n).prod (ZN m).prod
</pre>

<DT><span class="strong">ZN_to_ZN_ring_homo</span>
<DD>
<pre>
âŠ¢ âˆ€n m. 0 < n âˆ§ m divides n â‡’ RingHomo (Î»x. x MOD m) (ZN n) (ZN m)
</pre>

<DT><span class="strong">ZN_to_ZN_sum_group_homo</span>
<DD>
<pre>
âŠ¢ âˆ€n m. 0 < n âˆ§ m divides n â‡’ GroupHomo (Î»x. x MOD m) (ZN n).sum (ZN m).sum
</pre>

<DT><span class="strong">ZP_finite</span>
<DD>
<pre>
âŠ¢ âˆ€p. FINITE (ZP p).carrier
</pre>

<DT><span class="strong">ZP_finite_integral_domain</span>
<DD>
<pre>
âŠ¢ âˆ€p. prime p â‡’ FiniteIntegralDomain (ZP p)
</pre>

<DT><span class="strong">ZP_integral_domain</span>
<DD>
<pre>
âŠ¢ âˆ€p. prime p â‡’ IntegralDomain (ZP p)
</pre>

<DT><span class="strong">Z_add_abelian_group</span>
<DD>
<pre>
âŠ¢ AbelianGroup Z_add
</pre>

<DT><span class="strong">Z_add_group</span>
<DD>
<pre>
âŠ¢ Group Z_add
</pre>

<DT><span class="strong">Z_add_inv</span>
<DD>
<pre>
âŠ¢ âˆ€z. z âˆˆ Z_add.carrier â‡’ Z_add.inv z = -z
</pre>

<DT><span class="strong">Z_euclid_ring</span>
<DD>
<pre>
âŠ¢ EuclideanRing Z Num
</pre>

<DT><span class="strong">Z_ideal_map_bij</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’
      BIJ (Î»j. coset Z.sum (&j) (Z* n).sum.carrier) (ZN n).carrier
        (Z / Z* n).carrier
</pre>

<DT><span class="strong">Z_ideal_map_element</span>
<DD>
<pre>
âŠ¢ âˆ€n j.
    0 < n âˆ§ j âˆˆ (ZN n).carrier â‡’
    coset Z.sum (&j) (Z* n).sum.carrier âˆˆ (Z / Z* n).carrier
</pre>

<DT><span class="strong">Z_ideal_map_group_homo</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’
      GroupHomo (Î»j. coset Z.sum (&j) (Z* n).sum.carrier) (ZN n).sum
        (Z / Z* n).sum
</pre>

<DT><span class="strong">Z_ideal_map_monoid_homo</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’
      MonoidHomo (Î»j. coset Z.sum (&j) (Z* n).sum.carrier) (ZN n).prod
        (Z / Z* n).prod
</pre>

<DT><span class="strong">Z_ideal_sum_group</span>
<DD>
<pre>
âŠ¢ âˆ€n. Group (Z* n).sum
</pre>

<DT><span class="strong">Z_ideal_sum_normal</span>
<DD>
<pre>
âŠ¢ âˆ€n. (Z* n).sum << Z.sum
</pre>

<DT><span class="strong">Z_ideal_sum_subgroup</span>
<DD>
<pre>
âŠ¢ âˆ€n. (Z* n).sum â‰¤ Z.sum
</pre>

<DT><span class="strong">Z_ideal_thm</span>
<DD>
<pre>
âŠ¢ âˆ€n. Z* n << Z
</pre>

<DT><span class="strong">Z_mult_abelian_monoid</span>
<DD>
<pre>
âŠ¢ AbelianMonoid Z_mult
</pre>

<DT><span class="strong">Z_mult_monoid</span>
<DD>
<pre>
âŠ¢ Monoid Z_mult
</pre>

<DT><span class="strong">Z_multiple_less_neg_eq</span>
<DD>
<pre>
âŠ¢ âˆ€n x y. 0 < n âˆ§ x < n âˆ§ y < n âˆ§ -&x + &y âˆˆ Z_multiple n â‡’ x = y
</pre>

<DT><span class="strong">Z_principal_ideal_ring</span>
<DD>
<pre>
âŠ¢ PrincipalIdealRing Z
</pre>

<DT><span class="strong">Z_quotient_iso_ZN</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’
      RingIso (Î»j. coset Z.sum (&j) (Z* n).sum.carrier) (ZN n) (Z / Z* n)
</pre>

<DT><span class="strong">Z_ring</span>
<DD>
<pre>
âŠ¢ Ring Z
</pre>

<DT><span class="strong">Z_sum_cogen</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’
      âˆ€x. x âˆˆ Z.sum.carrier â‡’
          âˆƒy. cogen Z.sum (Z* n).sum (coset Z.sum x (Z* n).sum.carrier) =
              x + &n * y
</pre>

<DT><span class="strong">Z_sum_coset_eq</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < n â‡’
      âˆ€p. coset Z.sum p (Z* n).sum.carrier =
          coset Z.sum (p % &n) (Z* n).sum.carrier
</pre>

<DT><span class="strong">char_eq_0</span>
<DD>
<pre>
âŠ¢ âˆ€r. char r = 0 â‡” âˆ€n. 0 < n â‡’ $## n â‰  #0
</pre>

<DT><span class="strong">char_minimal</span>
<DD>
<pre>
âŠ¢ âˆ€r. 0 < char r â‡’ âˆ€n. 0 < n âˆ§ n < char r â‡’ $## n â‰  #0
</pre>

<DT><span class="strong">char_property</span>
<DD>
<pre>
âŠ¢ âˆ€r. $## (char r) = #0
</pre>

<DT><span class="strong">compute_ordz_0</span>
<DD>
<pre>
âŠ¢ âˆ€n. compute_ordz 0 n = ordz 0 n
</pre>

<DT><span class="strong">compute_ordz_1</span>
<DD>
<pre>
âŠ¢ âˆ€n. compute_ordz 1 n = 1
</pre>

<DT><span class="strong">compute_ordz_eqn</span>
<DD>
<pre>
âŠ¢ âˆ€m n. compute_ordz m n = ordz m n
</pre>

<DT><span class="strong">compute_ordz_hoare</span>
<DD>
<pre>
âŠ¢ âˆ€m n.
    1 < m âˆ§ coprime m n â‡’
    HOARE_SPEC (Î»i. 0 < i âˆ§ i â‰¤ ordz m n) (WHILE (Î»i. n ** i MOD m â‰  1) SUC)
      (Î»i. i = ordz m n)
</pre>

<DT><span class="strong">datatype_ring</span>
<DD>
<pre>
âŠ¢ DATATYPE (record ring carrier sum prod)
</pre>

<DT><span class="strong">euclid_ring_map</span>
<DD>
<pre>
âŠ¢ âˆ€r f. EuclideanRing r f â‡’ âˆ€x. f x = 0 â‡” x = #0
</pre>

<DT><span class="strong">euclid_ring_principal_ideal_ring</span>
<DD>
<pre>
âŠ¢ âˆ€r f. EuclideanRing r f â‡’ PrincipalIdealRing r
</pre>

<DT><span class="strong">euclid_ring_property</span>
<DD>
<pre>
âŠ¢ âˆ€r f.
    EuclideanRing r f â‡’
    âˆ€x y.
      x âˆˆ R âˆ§ y âˆˆ R âˆ§ y â‰  #0 â‡’ âˆƒq t. q âˆˆ R âˆ§ t âˆˆ R âˆ§ x = q * y + t âˆ§ f t < f y
</pre>

<DT><span class="strong">euclid_ring_ring</span>
<DD>
<pre>
âŠ¢ âˆ€r f. EuclideanRing r f â‡’ Ring r
</pre>

<DT><span class="strong">finite_integral_domain_nonzero_group</span>
<DD>
<pre>
âŠ¢ âˆ€r. FiniteIntegralDomain r â‡’ Group f*
</pre>

<DT><span class="strong">finite_integral_domain_nonzero_invertible</span>
<DD>
<pre>
âŠ¢ âˆ€r. FiniteIntegralDomain r â‡’ monoid_invertibles r.prod = R+
</pre>

<DT><span class="strong">finite_integral_domain_nonzero_invertible_alt</span>
<DD>
<pre>
âŠ¢ âˆ€r. FiniteIntegralDomain r â‡’ monoid_invertibles f* = F*
</pre>

<DT><span class="strong">finite_integral_domain_period_exists</span>
<DD>
<pre>
âŠ¢ âˆ€r. FiniteIntegralDomain r â‡’ âˆ€x. x âˆˆ R+ â‡’ âˆƒk. 0 < k âˆ§ x ** k = #1
</pre>

<DT><span class="strong">finite_ring_add_finite_abelian_group</span>
<DD>
<pre>
âŠ¢ âˆ€r. FiniteRing r â‡’ FiniteAbelianGroup r.sum âˆ§ r.sum.carrier = R
</pre>

<DT><span class="strong">finite_ring_add_finite_group</span>
<DD>
<pre>
âŠ¢ âˆ€r. FiniteRing r â‡’ FiniteGroup r.sum âˆ§ r.sum.carrier = R
</pre>

<DT><span class="strong">finite_ring_card_eq_1</span>
<DD>
<pre>
âŠ¢ âˆ€r. FiniteRing r â‡’ (CARD R = 1 â‡” #1 = #0)
</pre>

<DT><span class="strong">finite_ring_card_pos</span>
<DD>
<pre>
âŠ¢ âˆ€r. FiniteRing r â‡’ 0 < CARD R
</pre>

<DT><span class="strong">finite_ring_card_prime</span>
<DD>
<pre>
âŠ¢ âˆ€r. FiniteRing r âˆ§ prime (CARD R) â‡’ char r = CARD R
</pre>

<DT><span class="strong">finite_ring_char</span>
<DD>
<pre>
âŠ¢ âˆ€r. FiniteRing r â‡’ 0 < char r âˆ§ char r = order r.sum #1
</pre>

<DT><span class="strong">finite_ring_char_alt</span>
<DD>
<pre>
âŠ¢ âˆ€r. FiniteRing r â‡’
      âˆ€n. char r = n â‡” 0 < n âˆ§ $## n = #0 âˆ§ âˆ€m. 0 < m âˆ§ m < n â‡’ $## m â‰  #0
</pre>

<DT><span class="strong">finite_ring_char_divides</span>
<DD>
<pre>
âŠ¢ âˆ€r. FiniteRing r â‡’ char r divides CARD R
</pre>

<DT><span class="strong">finite_ring_char_pos</span>
<DD>
<pre>
âŠ¢ âˆ€r. FiniteRing r â‡’ 0 < char r
</pre>

<DT><span class="strong">finite_ring_is_ring</span>
<DD>
<pre>
âŠ¢ âˆ€r. FiniteRing r â‡’ Ring r
</pre>

<DT><span class="strong">finite_ring_mult_finite_abelian_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€r. FiniteRing r â‡’ FiniteAbelianMonoid r.prod
</pre>

<DT><span class="strong">finite_ring_mult_finite_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€r. FiniteRing r â‡’ FiniteMonoid r.prod
</pre>

<DT><span class="strong">homo_ring_by_inj</span>
<DD>
<pre>
âŠ¢ âˆ€r f. Ring r âˆ§ INJ f R ğ•Œ(:Î²) â‡’ RingHomo f r (homo_ring r f)
</pre>

<DT><span class="strong">homo_ring_property</span>
<DD>
<pre>
âŠ¢ âˆ€r f.
    fR = IMAGE f R âˆ§ (homo_ring r f).sum = homo_group r.sum f âˆ§
    (homo_ring r f).prod = homo_group r.prod f
</pre>

<DT><span class="strong">homo_ring_ring</span>
<DD>
<pre>
âŠ¢ âˆ€r f. Ring r âˆ§ RingHomo f r (homo_ring r f) â‡’ Ring (homo_ring r f)
</pre>

<DT><span class="strong">homo_ring_subring</span>
<DD>
<pre>
âŠ¢ âˆ€r s f. (r ~r~ s) f â‡’ subring (homo_ring r f) s
</pre>

<DT><span class="strong">ideal_antisym</span>
<DD>
<pre>
âŠ¢ âˆ€r i. i << r âˆ§ r << i â‡’ i = r
</pre>

<DT><span class="strong">ideal_carrier_sing</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ (SING i.carrier â‡” i = <#0>)
</pre>

<DT><span class="strong">ideal_carriers</span>
<DD>
<pre>
âŠ¢ âˆ€r i. i << r â‡’ i.sum.carrier = i.carrier âˆ§ i.prod.carrier = i.carrier
</pre>

<DT><span class="strong">ideal_cogen_property</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ âˆ€x. x âˆˆ R/I â‡’ gen x âˆˆ R âˆ§ gen x âˆ˜ i.carrier = x
</pre>

<DT><span class="strong">ideal_congruence_elements</span>
<DD>
<pre>
âŠ¢ âˆ€r i.
    Ring r âˆ§ i << r â‡’ âˆ€x y. x âˆˆ i.carrier âˆ§ y âˆˆ R â‡’ (y âˆˆ i.carrier â‡” x === y)
</pre>

<DT><span class="strong">ideal_congruence_equiv</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ $=== equiv_on R
</pre>

<DT><span class="strong">ideal_congruence_iff_inCoset</span>
<DD>
<pre>
âŠ¢ âˆ€r i.
    Ring r âˆ§ i << r â‡’
    âˆ€x y. x âˆˆ i.carrier âˆ§ y âˆˆ i.carrier â‡’ (x === y â‡” inCoset r.sum i.sum x y)
</pre>

<DT><span class="strong">ideal_congruence_mult</span>
<DD>
<pre>
âŠ¢ âˆ€r i.
    Ring r âˆ§ i << r â‡’
    âˆ€x y z. x âˆˆ R âˆ§ y âˆˆ R âˆ§ z âˆˆ R â‡’ x === y â‡’ z * x === z * y
</pre>

<DT><span class="strong">ideal_congruence_refl</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ âˆ€x. x âˆˆ R â‡’ x === x
</pre>

<DT><span class="strong">ideal_congruence_sym</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ (x === y â‡” y === x)
</pre>

<DT><span class="strong">ideal_congruence_trans</span>
<DD>
<pre>
âŠ¢ âˆ€r i.
    Ring r âˆ§ i << r â‡’
    âˆ€x y z. x âˆˆ R âˆ§ y âˆˆ R âˆ§ z âˆˆ R â‡’ x === y âˆ§ y === z â‡’ x === z
</pre>

<DT><span class="strong">ideal_coset_add</span>
<DD>
<pre>
âŠ¢ âˆ€r i.
    Ring r âˆ§ i << r â‡’
    âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ x âˆ˜ i.carrier + y âˆ˜ i.carrier = (x + y) âˆ˜ i.carrier
</pre>

<DT><span class="strong">ideal_coset_element</span>
<DD>
<pre>
âŠ¢ âˆ€r i x.
    Ring r âˆ§ i << r âˆ§ x âˆˆ R â‡’
    âˆ€z. z âˆˆ x âˆ˜ i.carrier â‡” âˆƒy. y âˆˆ i.carrier âˆ§ z = x + y
</pre>

<DT><span class="strong">ideal_coset_eq</span>
<DD>
<pre>
âŠ¢ âˆ€r i.
    Ring r âˆ§ i << r â‡’
    âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ (x âˆ˜ i.carrier = y âˆ˜ i.carrier â‡” x âˆ’ y âˆˆ i.carrier)
</pre>

<DT><span class="strong">ideal_coset_eq_carrier</span>
<DD>
<pre>
âŠ¢ âˆ€r i.
    Ring r âˆ§ i << r â‡’ âˆ€x. x âˆˆ R âˆ§ x âˆ˜ i.carrier = i.carrier â‡” x âˆˆ i.carrier
</pre>

<DT><span class="strong">ideal_coset_eq_congruence</span>
<DD>
<pre>
âŠ¢ âˆ€r i.
    Ring r âˆ§ i << r â‡’
    âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ (x âˆ˜ i.carrier = y âˆ˜ i.carrier â‡” x === y)
</pre>

<DT><span class="strong">ideal_coset_has_gen_diff</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ âˆ€x. x âˆˆ R â‡’ gen (x âˆ˜ i.carrier) âˆ’ x âˆˆ i.carrier
</pre>

<DT><span class="strong">ideal_coset_mult</span>
<DD>
<pre>
âŠ¢ âˆ€r i.
    Ring r âˆ§ i << r â‡’
    âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ x âˆ˜ i.carrier * y âˆ˜ i.carrier = (x * y) âˆ˜ i.carrier
</pre>

<DT><span class="strong">ideal_coset_neg</span>
<DD>
<pre>
âŠ¢ âˆ€r i.
    Ring r âˆ§ i << r â‡’ âˆ€x. x âˆˆ R â‡’ x âˆ˜ i.carrier + -x âˆ˜ i.carrier = i.carrier
</pre>

<DT><span class="strong">ideal_coset_of_element</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ âˆ€x. x âˆˆ i.carrier â‡’ x âˆ˜ i.carrier = i.carrier
</pre>

<DT><span class="strong">ideal_coset_property</span>
<DD>
<pre>
âŠ¢ âˆ€r i.
    Ring r âˆ§ i << r â‡’
    âˆ€x. x âˆˆ R â‡’
        x âˆ˜ i.carrier âˆˆ R/I âˆ§ gen (x âˆ˜ i.carrier) âˆ˜ i.carrier = x âˆ˜ i.carrier
</pre>

<DT><span class="strong">ideal_coset_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ #0 âˆ˜ i.carrier = i.carrier
</pre>

<DT><span class="strong">ideal_element</span>
<DD>
<pre>
âŠ¢ âˆ€r i. i << r â‡’ âˆ€x. x âˆˆ i.carrier â‡’ x âˆˆ r.sum.carrier
</pre>

<DT><span class="strong">ideal_element_property</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ âˆ€x. x âˆˆ i.carrier â‡’ x âˆˆ R
</pre>

<DT><span class="strong">ideal_eq_ideal</span>
<DD>
<pre>
âŠ¢ âˆ€r i j. Ring r âˆ§ i << r âˆ§ j << r â‡’ (i = j â‡” i.carrier = j.carrier)
</pre>

<DT><span class="strong">ideal_gen_exists</span>
<DD>
<pre>
âŠ¢ âˆ€r i.
    Ring r âˆ§ i << r âˆ§ i â‰  <#0> â‡’
    âˆ€f. (âˆ€x. f x = 0 â‡” x = #0) â‡’
        âˆƒp. p âˆˆ i.carrier âˆ§ p â‰  #0 âˆ§ âˆ€z. z âˆˆ i.carrier âˆ§ z â‰  #0 â‡’ f p â‰¤ f z
</pre>

<DT><span class="strong">ideal_gen_minimal</span>
<DD>
<pre>
âŠ¢ âˆ€r i.
    Ring r âˆ§ i << r âˆ§ i â‰  <#0> â‡’
    âˆ€f. (âˆ€x. f x = 0 â‡” x = #0) â‡’
        âˆ€z. z âˆˆ i.carrier â‡’ (f z < f (ideal_gen r i f) â‡” z = #0)
</pre>

<DT><span class="strong">ideal_has_diff</span>
<DD>
<pre>
âŠ¢ âˆ€r i.
    Ring r âˆ§ i << r â‡’ âˆ€x y. x âˆˆ i.carrier âˆ§ y âˆˆ i.carrier â‡’ x âˆ’ y âˆˆ i.carrier
</pre>

<DT><span class="strong">ideal_has_multiple</span>
<DD>
<pre>
âŠ¢ âˆ€r i. i << r â‡’ âˆ€x y. x âˆˆ i.carrier âˆ§ y âˆˆ R â‡’ x * y âˆˆ i.carrier
</pre>

<DT><span class="strong">ideal_has_neg</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ âˆ€x. x âˆˆ i.carrier â‡’ -x âˆˆ i.carrier
</pre>

<DT><span class="strong">ideal_has_one</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r âˆ§ #1 âˆˆ i.carrier â‡’ i.carrier = R
</pre>

<DT><span class="strong">ideal_has_principal_ideal</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ âˆ€p. p âˆˆ R â‡’ (p âˆˆ i.carrier â‡” <p> << i)
</pre>

<DT><span class="strong">ideal_has_product</span>
<DD>
<pre>
âŠ¢ âˆ€r i.
    Ring r âˆ§ i << r â‡’ âˆ€x y. x âˆˆ i.carrier âˆ§ y âˆˆ i.carrier â‡’ x * y âˆˆ i.carrier
</pre>

<DT><span class="strong">ideal_has_subgroup</span>
<DD>
<pre>
âŠ¢ âˆ€r i. i << r â‡’ i.sum â‰¤ r.sum
</pre>

<DT><span class="strong">ideal_has_sum</span>
<DD>
<pre>
âŠ¢ âˆ€r i.
    Ring r âˆ§ i << r â‡’ âˆ€x y. x âˆˆ i.carrier âˆ§ y âˆˆ i.carrier â‡’ x + y âˆˆ i.carrier
</pre>

<DT><span class="strong">ideal_has_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ #0 âˆˆ i.carrier
</pre>

<DT><span class="strong">ideal_in_quotient_ring</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ i.carrier âˆˆ R/I
</pre>

<DT><span class="strong">ideal_ops</span>
<DD>
<pre>
âŠ¢ âˆ€r i. i << r â‡’ i.sum.op = $+ âˆ§ i.prod.op = $*
</pre>

<DT><span class="strong">ideal_product_property</span>
<DD>
<pre>
âŠ¢ âˆ€r i.
    i << r â‡’
    âˆ€x y. x âˆˆ i.carrier âˆ§ y âˆˆ R â‡’ x * y âˆˆ i.carrier âˆ§ y * x âˆˆ i.carrier
</pre>

<DT><span class="strong">ideal_property</span>
<DD>
<pre>
âŠ¢ âˆ€r i.
    Ring r âˆ§ i << r â‡’
    âˆ€x y.
      x âˆˆ i.carrier âˆ§ y âˆˆ i.carrier â‡’ x + y âˆˆ i.carrier âˆ§ x * y âˆˆ i.carrier
</pre>

<DT><span class="strong">ideal_refl</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ r << r
</pre>

<DT><span class="strong">ideal_sub_ideal</span>
<DD>
<pre>
âŠ¢ âˆ€r i j. Ring r âˆ§ i << r âˆ§ j << r â‡’ (i << j â‡” i.carrier âŠ† j.carrier)
</pre>

<DT><span class="strong">ideal_sub_itself</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ i << i
</pre>

<DT><span class="strong">ideal_subgroup_ideal_sum</span>
<DD>
<pre>
âŠ¢ âˆ€r i j. Ring r âˆ§ i << r âˆ§ j << r â‡’ i.sum â‰¤ (i + j).sum
</pre>

<DT><span class="strong">ideal_sum_comm</span>
<DD>
<pre>
âŠ¢ âˆ€r i j. Ring r âˆ§ i << r âˆ§ j << r â‡’ i + j = j + i
</pre>

<DT><span class="strong">ideal_sum_element</span>
<DD>
<pre>
âŠ¢ âˆ€i j x.
    x âˆˆ (i + j).carrier â‡” âˆƒy z. y âˆˆ i.carrier âˆ§ z âˆˆ j.carrier âˆ§ x = y + z
</pre>

<DT><span class="strong">ideal_sum_group</span>
<DD>
<pre>
âŠ¢ âˆ€r i j. Ring r âˆ§ i << r âˆ§ j << r â‡’ Group (i + j).sum
</pre>

<DT><span class="strong">ideal_sum_has_ideal</span>
<DD>
<pre>
âŠ¢ âˆ€r i j. Ring r âˆ§ i << r âˆ§ j << r â‡’ i << (i + j)
</pre>

<DT><span class="strong">ideal_sum_has_ideal_comm</span>
<DD>
<pre>
âŠ¢ âˆ€r i j. Ring r âˆ§ i << r âˆ§ j << r â‡’ j << (i + j)
</pre>

<DT><span class="strong">ideal_sum_ideal</span>
<DD>
<pre>
âŠ¢ âˆ€r i j. Ring r âˆ§ i << r âˆ§ j << r â‡’ (i + j) << r
</pre>

<DT><span class="strong">ideal_sum_sub_ideal</span>
<DD>
<pre>
âŠ¢ âˆ€r i j. Ring r âˆ§ i << r âˆ§ j << r â‡’ ((i + j) << j â‡” i << j)
</pre>

<DT><span class="strong">ideal_sum_subgroup</span>
<DD>
<pre>
âŠ¢ âˆ€r i j. Ring r âˆ§ i << r âˆ§ j << r â‡’ (i + j).sum â‰¤ r.sum
</pre>

<DT><span class="strong">ideal_with_one</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€i. i << r âˆ§ #1 âˆˆ i.carrier â‡” i = r
</pre>

<DT><span class="strong">ideal_with_unit</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ âˆ€x. x âˆˆ i.carrier âˆ§ unit x â‡’ i = r
</pre>

<DT><span class="strong">ideal_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ i.sum.id = #0
</pre>

<DT><span class="strong">integral_domain_char</span>
<DD>
<pre>
âŠ¢ âˆ€r. IntegralDomain r â‡’ char r = 0 âˆ¨ prime (char r)
</pre>

<DT><span class="strong">integral_domain_divides_prime</span>
<DD>
<pre>
âŠ¢ âˆ€r p x.
    IntegralDomain r âˆ§ x âˆˆ R âˆ§ p âˆˆ R âˆ§ p â‰  #0 âˆ§ rprime p âˆ§ p âˆ‰ R* âˆ§ x âˆ‰ R* âˆ§
    x rdivides p â‡’
    rassoc x p
</pre>

<DT><span class="strong">integral_domain_exp_eq</span>
<DD>
<pre>
âŠ¢ âˆ€r. IntegralDomain r â‡’
      âˆ€x. x âˆˆ R+ â‡’ âˆ€m n. m < n âˆ§ x ** m = x ** n â‡’ x ** (n âˆ’ m) = #1
</pre>

<DT><span class="strong">integral_domain_exp_eq_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r. IntegralDomain r â‡’ âˆ€x. x âˆˆ R â‡’ âˆ€n. x ** n = #0 â‡” n â‰  0 âˆ§ x = #0
</pre>

<DT><span class="strong">integral_domain_exp_nonzero</span>
<DD>
<pre>
âŠ¢ âˆ€r. IntegralDomain r â‡’ âˆ€x. x âˆˆ R+ â‡’ âˆ€n. x ** n âˆˆ R+
</pre>

<DT><span class="strong">integral_domain_is_ring</span>
<DD>
<pre>
âŠ¢ âˆ€r. IntegralDomain r â‡’ Ring r
</pre>

<DT><span class="strong">integral_domain_mult_eq_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r. IntegralDomain r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ (x * y = #0 â‡” x = #0 âˆ¨ y = #0)
</pre>

<DT><span class="strong">integral_domain_mult_lcancel</span>
<DD>
<pre>
âŠ¢ âˆ€r. IntegralDomain r â‡’
      âˆ€x y z. x âˆˆ R âˆ§ y âˆˆ R âˆ§ z âˆˆ R â‡’ (x * y = x * z â‡” x = #0 âˆ¨ y = z)
</pre>

<DT><span class="strong">integral_domain_mult_nonzero</span>
<DD>
<pre>
âŠ¢ âˆ€r. IntegralDomain r â‡’ âˆ€x y. x âˆˆ R+ âˆ§ y âˆˆ R+ â‡’ x * y âˆˆ R+
</pre>

<DT><span class="strong">integral_domain_mult_rcancel</span>
<DD>
<pre>
âŠ¢ âˆ€r. IntegralDomain r â‡’
      âˆ€x y z. x âˆˆ R âˆ§ y âˆˆ R âˆ§ z âˆˆ R â‡’ (y * x = z * x â‡” x = #0 âˆ¨ y = z)
</pre>

<DT><span class="strong">integral_domain_nonzero_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€r. IntegralDomain r â‡’ Monoid f*
</pre>

<DT><span class="strong">integral_domain_nonzero_mult_carrier</span>
<DD>
<pre>
âŠ¢ âˆ€r. IntegralDomain r â‡’ F* = R+
</pre>

<DT><span class="strong">integral_domain_nonzero_mult_is_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€r. IntegralDomain r â‡’ Monoid (monoid_of_ring_nonzero_mult r)
</pre>

<DT><span class="strong">integral_domain_nonzero_mult_property</span>
<DD>
<pre>
âŠ¢ âˆ€r. IntegralDomain r â‡’ F* = R+ âˆ§ f*.id = #1 âˆ§ f*.op = $* âˆ§ f*.exp = $**
</pre>

<DT><span class="strong">integral_domain_nonzero_order</span>
<DD>
<pre>
âŠ¢ âˆ€r. IntegralDomain r â‡’ âˆ€x. order r.prod x = order f* x
</pre>

<DT><span class="strong">integral_domain_one_ne_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r. IntegralDomain r â‡’ #1 â‰  #0
</pre>

<DT><span class="strong">integral_domain_one_nonzero</span>
<DD>
<pre>
âŠ¢ âˆ€r. IntegralDomain r â‡’ #1 âˆˆ R+
</pre>

<DT><span class="strong">integral_domain_order_eq_0</span>
<DD>
<pre>
âŠ¢ âˆ€r. FiniteIntegralDomain r â‡’ âˆ€x. x âˆˆ R â‡’ (order f* x = 0 â‡” x = #0)
</pre>

<DT><span class="strong">integral_domain_order_nonzero</span>
<DD>
<pre>
âŠ¢ âˆ€r. FiniteIntegralDomain r â‡’ âˆ€x. x âˆˆ R+ â‡’ order f* x â‰  0
</pre>

<DT><span class="strong">integral_domain_order_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r. IntegralDomain r â‡’ order f* #0 = 0
</pre>

<DT><span class="strong">integral_domain_prime_factors_unique</span>
<DD>
<pre>
âŠ¢ IntegralDomain r â‡’
  âˆ€l1 l2.
    (âˆ€m. MEM m l1 â‡’ m âˆˆ R âˆ§ rprime m âˆ§ m â‰  #0 âˆ§ m âˆ‰ R* ) âˆ§
    (âˆ€m. MEM m l2 â‡’ m âˆˆ R âˆ§ rprime m âˆ§ m â‰  #0 âˆ§ m âˆ‰ R* ) âˆ§
    rassoc (GBAG r.prod (LIST_TO_BAG l1)) (GBAG r.prod (LIST_TO_BAG l2)) â‡’
    âˆƒl3. PERM l2 l3 âˆ§ LIST_REL rassoc l1 l3
</pre>

<DT><span class="strong">integral_domain_ring_iso</span>
<DD>
<pre>
âŠ¢ IntegralDomain r âˆ§ Ring s âˆ§ RingIso f r s â‡’ IntegralDomain s
</pre>

<DT><span class="strong">integral_domain_zero_not_unit</span>
<DD>
<pre>
âŠ¢ âˆ€r. IntegralDomain r â‡’ #0 âˆ‰ R*
</pre>

<DT><span class="strong">integral_domain_zero_product</span>
<DD>
<pre>
âŠ¢ âˆ€r. IntegralDomain r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ (x * y = #0 â‡” x = #0 âˆ¨ y = #0)
</pre>

<DT><span class="strong">irreducible_associates</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r âˆ§ #1 â‰  #0 â‡’ âˆ€p s. p âˆˆ R âˆ§ unit s â‡’ (atom p â‡” atom (s * p))
</pre>

<DT><span class="strong">irreducible_element</span>
<DD>
<pre>
âŠ¢ âˆ€r p. atom p â‡’ p âˆˆ R
</pre>

<DT><span class="strong">irreducible_factors</span>
<DD>
<pre>
âŠ¢ âˆ€r z.
    atom z â‡’ z âˆˆ R+ âˆ§ z âˆ‰ R* âˆ§ âˆ€p. p âˆˆ R âˆ§ p rdivides z â‡’ rassoc z p âˆ¨ unit p
</pre>

<DT><span class="strong">kernel_ideal_element</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f x. x âˆˆ (kernel_ideal f r r_).carrier â‡” x âˆˆ r.sum.carrier âˆ§ f x = #0_
</pre>

<DT><span class="strong">kernel_ideal_gen_add_map</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f.
    (r ~r~ r_) f â‡’
    (let
       i = kernel_ideal f r r_
     in
       âˆ€x y.
         x âˆˆ R/I âˆ§ y âˆˆ R/I â‡’
         f (gen ((gen x + gen y) âˆ˜ i.carrier)) = f (gen x) +_ f (gen y))
</pre>

<DT><span class="strong">kernel_ideal_gen_id_map</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f.
    (r ~r~ r_) f â‡’
    (let i = kernel_ideal f r r_ in f (gen (#1 âˆ˜ i.carrier)) = #1_)
</pre>

<DT><span class="strong">kernel_ideal_gen_mult_map</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f.
    (r ~r~ r_) f â‡’
    (let
       i = kernel_ideal f r r_
     in
       âˆ€x y.
         x âˆˆ R/I âˆ§ y âˆˆ R/I â‡’
         f (gen ((gen x * gen y) âˆ˜ i.carrier)) = f (gen x) *_ f (gen y))
</pre>

<DT><span class="strong">kernel_ideal_quotient_bij</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f.
    (r ~r~ r_) f â‡’
    (let i = kernel_ideal f r r_ in BIJ (f âˆ˜ gen) R/I (IMAGE f R))
</pre>

<DT><span class="strong">kernel_ideal_quotient_element_eq</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f.
    (r ~r~ r_) f â‡’
    (let
       i = kernel_ideal f r r_
     in
       âˆ€x y. x âˆˆ R/I âˆ§ y âˆˆ R/I â‡’ (gen x âˆ’ gen y âˆˆ i.carrier â‡” x = y))
</pre>

<DT><span class="strong">kernel_ideal_quotient_homo</span>
<DD>
<pre>
âŠ¢ âˆ€r s f.
    (r ~r~ s) f â‡’
    (let
       i = kernel_ideal f r s
     in
       RingHomo (f âˆ˜ gen) (r / i) (ring_homo_image f r s))
</pre>

<DT><span class="strong">kernel_ideal_quotient_inj</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f.
    (r ~r~ r_) f â‡’
    (let i = kernel_ideal f r r_ in INJ (f âˆ˜ gen) R/I (IMAGE f R))
</pre>

<DT><span class="strong">kernel_ideal_quotient_iso</span>
<DD>
<pre>
âŠ¢ âˆ€r s f.
    (r ~r~ s) f â‡’
    (let
       i = kernel_ideal f r s
     in
       RingIso (f âˆ˜ gen) (r / i) (ring_homo_image f r s))
</pre>

<DT><span class="strong">kernel_ideal_quotient_surj</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f.
    (r ~r~ r_) f â‡’
    (let i = kernel_ideal f r r_ in SURJ (f âˆ˜ gen) R/I (IMAGE f R))
</pre>

<DT><span class="strong">kernel_ideal_sum_eqn</span>
<DD>
<pre>
âŠ¢ âˆ€r s f. (kernel_ideal f r s).sum = kernel_group f r.sum s.sum
</pre>

<DT><span class="strong">ordz_eval</span>
<DD>
<pre>
âŠ¢ âˆ€m n. order (times_mod m) n = compute_ordz m n
</pre>

<DT><span class="strong">prime_is_irreducible</span>
<DD>
<pre>
âŠ¢ âˆ€r p. IntegralDomain r âˆ§ p âˆˆ R âˆ§ rprime p âˆ§ p â‰  #0 âˆ§ p âˆ‰ R* â‡’ atom p
</pre>

<DT><span class="strong">principal_ideal_element</span>
<DD>
<pre>
âŠ¢ âˆ€p x. x âˆˆ <p>.carrier â‡” âˆƒz. z âˆˆ R âˆ§ x = p * z
</pre>

<DT><span class="strong">principal_ideal_element_divides</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€p. p âˆˆ R â‡’ âˆ€x. x âˆˆ <p>.carrier â‡” p rdivides x
</pre>

<DT><span class="strong">principal_ideal_eq_principal_ideal</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€p q u. p âˆˆ R âˆ§ q âˆˆ R âˆ§ unit u âˆ§ p = q * u â‡’ <p> = <q>
</pre>

<DT><span class="strong">principal_ideal_equal_principal_ideal</span>
<DD>
<pre>
âŠ¢ âˆ€r. IntegralDomain r â‡’
      âˆ€p q. p âˆˆ R âˆ§ q âˆˆ R â‡’ (<p> = <q> â‡” âˆƒu. unit u âˆ§ p = q * u)
</pre>

<DT><span class="strong">principal_ideal_group</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€p. p âˆˆ R â‡’ Group <p>.sum
</pre>

<DT><span class="strong">principal_ideal_has_element</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€p. p âˆˆ R â‡’ p âˆˆ <p>.carrier
</pre>

<DT><span class="strong">principal_ideal_has_principal_ideal</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€p q. p âˆˆ R âˆ§ q âˆˆ <p>.carrier â‡’ <q> << <p>
</pre>

<DT><span class="strong">principal_ideal_ideal</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€p. p âˆˆ R â‡’ <p> << r
</pre>

<DT><span class="strong">principal_ideal_property</span>
<DD>
<pre>
âŠ¢ âˆ€r p.
    <p>.carrier = p * R âˆ§ <p>.sum.carrier = p * R âˆ§ <p>.prod.carrier = p * R âˆ§
    <p>.sum.op = $+ âˆ§ <p>.prod.op = $* âˆ§ <p>.sum.id = #0 âˆ§ <p>.prod.id = #1
</pre>

<DT><span class="strong">principal_ideal_ring_atom_is_prime</span>
<DD>
<pre>
âŠ¢ âˆ€r. PrincipalIdealRing r â‡’ âˆ€p. atom p â‡’ rprime p
</pre>

<DT><span class="strong">principal_ideal_ring_ideal_maximal</span>
<DD>
<pre>
âŠ¢ âˆ€r. PrincipalIdealRing r â‡’ âˆ€p. atom p â‡’ maxi <p>
</pre>

<DT><span class="strong">principal_ideal_ring_irreducible_is_prime</span>
<DD>
<pre>
âŠ¢ âˆ€r. PrincipalIdealRing r â‡’ âˆ€p. atom p â‡’ rprime p
</pre>

<DT><span class="strong">principal_ideal_sub_implies_divides</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€p q. p âˆˆ R âˆ§ q âˆˆ R â‡’ (q rdivides p â‡” <p> << <q>)
</pre>

<DT><span class="strong">principal_ideal_subgroup</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€p. p âˆˆ R â‡’ <p>.sum â‰¤ r.sum
</pre>

<DT><span class="strong">principal_ideal_subgroup_normal</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€p. p âˆˆ R â‡’ <p>.sum << r.sum
</pre>

<DT><span class="strong">principal_ideal_sum_eq_ideal</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ âˆ€p. p âˆˆ i.carrier â‡’ <p> + i = i
</pre>

<DT><span class="strong">principal_ideal_sum_equal_ideal</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ âˆ€p. p âˆˆ i.carrier â‡” p âˆˆ R âˆ§ <p> + i = i
</pre>

<DT><span class="strong">quotient_ring_add_abelian_group</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r âˆ§ i << r â‡’ AbelianGroup (quotient_ring_add r i)
</pre>

<DT><span class="strong">quotient_ring_add_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€r i.
    Ring r âˆ§ i << r â‡’
    âˆ€x y z. x âˆˆ R/I âˆ§ y âˆˆ R/I âˆ§ z âˆˆ R/I â‡’ x + y + z = x + (y + z)
</pre>

<DT><span class="strong">quotient_ring_add_comm</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ âˆ€x y. x âˆˆ R/I âˆ§ y âˆˆ R/I â‡’ x + y = y + x
</pre>

<DT><span class="strong">quotient_ring_add_element</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ âˆ€x y. x âˆˆ R/I âˆ§ y âˆˆ R/I â‡’ x + y âˆˆ R/I
</pre>

<DT><span class="strong">quotient_ring_add_group</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ Group (quotient_ring_add r i)
</pre>

<DT><span class="strong">quotient_ring_add_id</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ âˆ€x. x âˆˆ R/I â‡’ i.carrier + x = x
</pre>

<DT><span class="strong">quotient_ring_add_inv</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ âˆ€x. x âˆˆ R/I â‡’ âˆƒy. y âˆˆ R/I âˆ§ y + x = i.carrier
</pre>

<DT><span class="strong">quotient_ring_by_principal_ideal</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€p. p âˆˆ R â‡’ Ring (r / <p>)
</pre>

<DT><span class="strong">quotient_ring_element</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ âˆ€z. z âˆˆ R/I â‡” âˆƒx. x âˆˆ R âˆ§ z = x âˆ˜ i.carrier
</pre>

<DT><span class="strong">quotient_ring_has_ideal</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ i.carrier âˆˆ R/I
</pre>

<DT><span class="strong">quotient_ring_homo</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ RingHomo (Î»x. x âˆ˜ i.carrier) r (r / i)
</pre>

<DT><span class="strong">quotient_ring_homo_kernel</span>
<DD>
<pre>
âŠ¢ âˆ€r i.
    Ring r âˆ§ i << r â‡’ kernel (Î»x. x âˆ˜ i.carrier) r.sum (r / i).sum = i.carrier
</pre>

<DT><span class="strong">quotient_ring_homo_kernel_ideal</span>
<DD>
<pre>
âŠ¢ âˆ€r i.
    Ring r âˆ§ i << r â‡’
    RingHomo (Î»x. x âˆ˜ i.carrier) r (r / i) âˆ§
    kernel_ideal (Î»x. x âˆ˜ i.carrier) r (r / i) = i
</pre>

<DT><span class="strong">quotient_ring_homo_surj</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ SURJ (Î»x. x âˆ˜ i.carrier) R R/I
</pre>

<DT><span class="strong">quotient_ring_mult_abelian_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r âˆ§ i << r â‡’ AbelianMonoid (quotient_ring_mult r i)
</pre>

<DT><span class="strong">quotient_ring_mult_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€r i.
    Ring r âˆ§ i << r â‡’
    âˆ€x y z. x âˆˆ R/I âˆ§ y âˆˆ R/I âˆ§ z âˆˆ R/I â‡’ x * y * z = x * (y * z)
</pre>

<DT><span class="strong">quotient_ring_mult_comm</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ âˆ€x y. x âˆˆ R/I âˆ§ y âˆˆ R/I â‡’ x * y = y * x
</pre>

<DT><span class="strong">quotient_ring_mult_element</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ âˆ€x y. x âˆˆ R/I âˆ§ y âˆˆ R/I â‡’ x * y âˆˆ R/I
</pre>

<DT><span class="strong">quotient_ring_mult_id</span>
<DD>
<pre>
âŠ¢ âˆ€r i.
    Ring r âˆ§ i << r â‡’
    âˆ€x. x âˆˆ R/I â‡’ #1 âˆ˜ i.carrier * x = x âˆ§ x * #1 âˆ˜ i.carrier = x
</pre>

<DT><span class="strong">quotient_ring_mult_ladd</span>
<DD>
<pre>
âŠ¢ âˆ€r i.
    Ring r âˆ§ i << r â‡’
    âˆ€x y z. x âˆˆ R/I âˆ§ y âˆˆ R/I âˆ§ z âˆˆ R/I â‡’ x * (y + z) = x * y + x * z
</pre>

<DT><span class="strong">quotient_ring_mult_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ Monoid (quotient_ring_mult r i)
</pre>

<DT><span class="strong">quotient_ring_property</span>
<DD>
<pre>
âŠ¢ âˆ€r i.
    (r / i).carrier = R/I âˆ§ (r / i).sum = quotient_ring_add r i âˆ§
    (r / i).prod = quotient_ring_mult r i
</pre>

<DT><span class="strong">quotient_ring_ring</span>
<DD>
<pre>
âŠ¢ âˆ€r i. Ring r âˆ§ i << r â‡’ Ring (r / i)
</pre>

<DT><span class="strong">quotient_ring_ring_sing</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ (r / r).carrier = {R}
</pre>

<DT><span class="strong">ring_11</span>
<DD>
<pre>
âŠ¢ âˆ€a0 a1 a2 a0' a1' a2'.
    ring a0 a1 a2 = ring a0' a1' a2' â‡” a0 = a0' âˆ§ a1 = a1' âˆ§ a2 = a2'
</pre>

<DT><span class="strong">ring_Axiom</span>
<DD>
<pre>
âŠ¢ âˆ€f. âˆƒfn. âˆ€a0 a1 a2. fn (ring a0 a1 a2) = f a0 a1 a2
</pre>

<DT><span class="strong">ring_accessors</span>
<DD>
<pre>
âŠ¢ (âˆ€f m m0. (ring f m m0).carrier = f) âˆ§ (âˆ€f m m0. (ring f m m0).sum = m) âˆ§
  âˆ€f m m0. (ring f m m0).prod = m0
</pre>

<DT><span class="strong">ring_accfupds</span>
<DD>
<pre>
âŠ¢ (âˆ€r f. (r with sum updated_by f).carrier = R) âˆ§
  (âˆ€r f. (r with prod updated_by f).carrier = R) âˆ§
  (âˆ€r f. (r with carrier updated_by f).sum = r.sum) âˆ§
  (âˆ€r f. (r with prod updated_by f).sum = r.sum) âˆ§
  (âˆ€r f. (r with carrier updated_by f).prod = r.prod) âˆ§
  (âˆ€r f. (r with sum updated_by f).prod = r.prod) âˆ§
  (âˆ€r f. (r with carrier updated_by f).carrier = f R) âˆ§
  (âˆ€r f. (r with sum updated_by f).sum = f r.sum) âˆ§
  âˆ€r f. (r with prod updated_by f).prod = f r.prod
</pre>

<DT><span class="strong">ring_add_abelian_group</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ AbelianGroup r.sum
</pre>

<DT><span class="strong">ring_add_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y z. x âˆˆ R âˆ§ y âˆˆ R âˆ§ z âˆˆ R â‡’ x + y + z = x + (y + z)
</pre>

<DT><span class="strong">ring_add_assoc_comm</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y z. x âˆˆ R âˆ§ y âˆˆ R âˆ§ z âˆˆ R â‡’ x + (y + z) = y + (x + z)
</pre>

<DT><span class="strong">ring_add_char_2</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r âˆ§ char r = 2 â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ x + y = x âˆ’ y
</pre>

<DT><span class="strong">ring_add_comm</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ x + y = y + x
</pre>

<DT><span class="strong">ring_add_element</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ x + y âˆˆ R
</pre>

<DT><span class="strong">ring_add_eq_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ (x + y = #0 â‡” y = -x)
</pre>

<DT><span class="strong">ring_add_exp_eqn</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ âˆ€n. r.sum.exp x n = x * $## n
</pre>

<DT><span class="strong">ring_add_group</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      Group r.sum âˆ§ r.sum.carrier = R âˆ§ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ x + y = y + x
</pre>

<DT><span class="strong">ring_add_group_rwt</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ Group r.sum âˆ§ r.sum.carrier = R
</pre>

<DT><span class="strong">ring_add_lcancel</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y z. x âˆˆ R âˆ§ y âˆˆ R âˆ§ z âˆˆ R â‡’ (x + y = x + z â‡” y = z)
</pre>

<DT><span class="strong">ring_add_lneg</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ -x + x = #0
</pre>

<DT><span class="strong">ring_add_lneg_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ y = x + (-x + y) âˆ§ y = -x + (x + y)
</pre>

<DT><span class="strong">ring_add_lzero</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ #0 + x = x
</pre>

<DT><span class="strong">ring_add_pair_sub</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x y p q.
        x âˆˆ R âˆ§ y âˆˆ R âˆ§ p âˆˆ R âˆ§ q âˆˆ R â‡’ x + y âˆ’ (p + q) = x âˆ’ p + (y âˆ’ q)
</pre>

<DT><span class="strong">ring_add_rcancel</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y z. x âˆˆ R âˆ§ y âˆˆ R âˆ§ z âˆˆ R â‡’ (y + x = z + x â‡” y = z)
</pre>

<DT><span class="strong">ring_add_rneg</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ x + -x = #0
</pre>

<DT><span class="strong">ring_add_rneg_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ y = y + -x + x âˆ§ y = y + x + -x
</pre>

<DT><span class="strong">ring_add_rzero</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ x + #0 = x
</pre>

<DT><span class="strong">ring_add_sub</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ x + y âˆ’ y = x
</pre>

<DT><span class="strong">ring_add_sub_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y z. x âˆˆ R âˆ§ y âˆˆ R âˆ§ z âˆˆ R â‡’ x + y âˆ’ z = x + (y âˆ’ z)
</pre>

<DT><span class="strong">ring_add_sub_comm</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ y + x âˆ’ y = x
</pre>

<DT><span class="strong">ring_add_sub_identity</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x y z t.
        x âˆˆ R âˆ§ y âˆˆ R âˆ§ z âˆˆ R âˆ§ t âˆˆ R â‡’ (x + y = z + t â‡” x âˆ’ z = t âˆ’ y)
</pre>

<DT><span class="strong">ring_add_zero_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ #0 + #0 = #0
</pre>

<DT><span class="strong">ring_associates_divides</span>
<DD>
<pre>
âŠ¢ âˆ€r p q x. Ring r âˆ§ rassoc p q âˆ§ q âˆˆ R âˆ§ p rdivides x â‡’ q rdivides x
</pre>

<DT><span class="strong">ring_associates_mult</span>
<DD>
<pre>
âŠ¢ âˆ€r p q x.
    Ring r âˆ§ p âˆˆ R âˆ§ q âˆˆ R âˆ§ x âˆˆ R âˆ§ rassoc p q â‡’ rassoc (x * p) (x * q)
</pre>

<DT><span class="strong">ring_associates_refl</span>
<DD>
<pre>
âŠ¢ âˆ€r x. Ring r âˆ§ x âˆˆ R â‡’ rassoc x x
</pre>

<DT><span class="strong">ring_associates_sym</span>
<DD>
<pre>
âŠ¢ âˆ€r p q. Ring r âˆ§ q âˆˆ R âˆ§ rassoc p q â‡’ rassoc q p
</pre>

<DT><span class="strong">ring_associates_trans</span>
<DD>
<pre>
âŠ¢ âˆ€r x y z. Ring r âˆ§ z âˆˆ R âˆ§ rassoc x y âˆ§ rassoc y z â‡’ rassoc x z
</pre>

<DT><span class="strong">ring_auto_I</span>
<DD>
<pre>
âŠ¢ âˆ€r. RingAuto I r
</pre>

<DT><span class="strong">ring_auto_bij</span>
<DD>
<pre>
âŠ¢ âˆ€r f. Ring r âˆ§ RingAuto f r â‡’ f PERMUTES R
</pre>

<DT><span class="strong">ring_auto_cong</span>
<DD>
<pre>
âŠ¢ âˆ€r f1 f2.
    Ring r âˆ§ (âˆ€x. x âˆˆ R â‡’ f1 x = f2 x) â‡’ (RingAuto f1 r â‡” RingAuto f2 r)
</pre>

<DT><span class="strong">ring_auto_element</span>
<DD>
<pre>
âŠ¢ âˆ€r f. RingAuto f r â‡’ âˆ€x. x âˆˆ R â‡’ f x âˆˆ R
</pre>

<DT><span class="strong">ring_auto_ids</span>
<DD>
<pre>
âŠ¢ âˆ€r f. Ring r âˆ§ RingAuto f r â‡’ f #0 = #0 âˆ§ f #1 = #1
</pre>

<DT><span class="strong">ring_auto_linv_auto</span>
<DD>
<pre>
âŠ¢ âˆ€r f. Ring r âˆ§ RingAuto f r â‡’ RingAuto (LINV f R) r
</pre>

<DT><span class="strong">ring_auto_one</span>
<DD>
<pre>
âŠ¢ âˆ€r f. Ring r âˆ§ RingAuto f r â‡’ f #1 = #1
</pre>

<DT><span class="strong">ring_auto_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r f. Ring r âˆ§ RingAuto f r â‡’ f #0 = #0
</pre>

<DT><span class="strong">ring_binomial_2</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ (x + y) ** 2 = x ** 2 + $## 2 * (x * y) + y ** 2
</pre>

<DT><span class="strong">ring_binomial_3</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x y.
        x âˆˆ R âˆ§ y âˆˆ R â‡’
        (x + y) ** 3 =
        x ** 3 + $## 3 * (x ** 2 * y) + $## 3 * (x * y ** 2) + y ** 3
</pre>

<DT><span class="strong">ring_binomial_4</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x y.
        x âˆˆ R âˆ§ y âˆˆ R â‡’
        (x + y) ** 4 =
        x ** 4 + $## 4 * (x ** 3 * y) + $## 6 * (x ** 2 * y ** 2) +
        $## 4 * (x * y ** 3) + y ** 4
</pre>

<DT><span class="strong">ring_binomial_genlist_index_shift</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x y.
        x âˆˆ R âˆ§ y âˆˆ R â‡’
        âˆ€n. GENLIST
              ((Î»k. $## (binomial n k) * x ** SUC (n âˆ’ k) * y ** k) âˆ˜ SUC) n =
            GENLIST (Î»k. $## (binomial n (SUC k)) * x ** (n âˆ’ k) * y ** SUC k)
              n
</pre>

<DT><span class="strong">ring_binomial_index_shift</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x y.
        x âˆˆ R âˆ§ y âˆˆ R â‡’
        âˆ€n. (Î»k. $## (binomial (SUC n) k) * x ** (SUC n âˆ’ k) * y ** k) âˆ˜ SUC =
            (Î»k. $## (binomial (SUC n) (SUC k)) * x ** (n âˆ’ k) * y ** SUC k)
</pre>

<DT><span class="strong">ring_binomial_term_merge_x</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x y.
        x âˆˆ R âˆ§ y âˆˆ R â‡’
        âˆ€n. (Î»k. x * k) âˆ˜ (Î»k. $## (binomial n k) * x ** (n âˆ’ k) * y ** k) =
            (Î»k. $## (binomial n k) * x ** SUC (n âˆ’ k) * y ** k)
</pre>

<DT><span class="strong">ring_binomial_term_merge_y</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x y.
        x âˆˆ R âˆ§ y âˆˆ R â‡’
        âˆ€n. (Î»k. y * k) âˆ˜ (Î»k. $## (binomial n k) * x ** (n âˆ’ k) * y ** k) =
            (Î»k. $## (binomial n k) * x ** (n âˆ’ k) * y ** SUC k)
</pre>

<DT><span class="strong">ring_binomial_thm</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x y.
        x âˆˆ R âˆ§ y âˆˆ R â‡’
        âˆ€n. (x + y) ** n =
            rsum
              (GENLIST (Î»k. $## (binomial n k) * x ** (n âˆ’ k) * y ** k)
                 (SUC n))
</pre>

<DT><span class="strong">ring_carrier_nonempty</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ R â‰  âˆ…
</pre>

<DT><span class="strong">ring_carriers</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ r.sum.carrier = R âˆ§ r.prod.carrier = R
</pre>

<DT><span class="strong">ring_case_cong</span>
<DD>
<pre>
âŠ¢ âˆ€M M' f.
    M = M' âˆ§ (âˆ€a0 a1 a2. M' = ring a0 a1 a2 â‡’ f a0 a1 a2 = f' a0 a1 a2) â‡’
    ring_CASE M f = ring_CASE M' f'
</pre>

<DT><span class="strong">ring_case_eq</span>
<DD>
<pre>
âŠ¢ ring_CASE x f = v â‡” âˆƒf' m m0. x = ring f' m m0 âˆ§ f f' m m0 = v
</pre>

<DT><span class="strong">ring_char_0</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r âˆ§ char r = 0 â‡’ INFINITE R
</pre>

<DT><span class="strong">ring_char_1</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r âˆ§ char r = 1 â‡’ R = {#0}
</pre>

<DT><span class="strong">ring_char_2_double</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r âˆ§ char r = 2 â‡’ âˆ€x. x âˆˆ R â‡’ x + x = #0
</pre>

<DT><span class="strong">ring_char_2_neg_one</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r âˆ§ char r = 2 â‡’ -#1 = #1
</pre>

<DT><span class="strong">ring_char_2_property</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r âˆ§ char r = 2 â‡’ #1 + #1 = #0
</pre>

<DT><span class="strong">ring_char_alt</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€n. 0 < n â‡’ (char r = n â‡” $## n = #0 âˆ§ âˆ€m. 0 < m âˆ§ m < n â‡’ $## m â‰  #0)
</pre>

<DT><span class="strong">ring_char_divides</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€n. $## n = #0 â‡” char r divides n
</pre>

<DT><span class="strong">ring_char_eq_1</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ (char r = 1 â‡” #1 = #0)
</pre>

<DT><span class="strong">ring_char_prime</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      (prime (char r) â‡”
       1 < char r âˆ§ âˆ€k. 0 < k âˆ§ k < char r â‡’ $## (binomial (char r) k) = #0)
</pre>

<DT><span class="strong">ring_char_prime_endo</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r âˆ§ prime (char r) â‡’ RingEndo (Î»x. x ** char r) r
</pre>

<DT><span class="strong">ring_component_equality</span>
<DD>
<pre>
âŠ¢ âˆ€r1 r2.
    r1 = r2 â‡” r1.carrier = r2.carrier âˆ§ r1.sum = r2.sum âˆ§ r1.prod = r2.prod
</pre>

<DT><span class="strong">ring_divides_associates</span>
<DD>
<pre>
âŠ¢ âˆ€r x y p. Ring r âˆ§ rassoc x y âˆ§ p âˆˆ R âˆ§ y âˆˆ R âˆ§ p rdivides x â‡’ p rdivides y
</pre>

<DT><span class="strong">ring_divides_by_one</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€p. p âˆˆ R â‡’ #1 rdivides p
</pre>

<DT><span class="strong">ring_divides_by_unit</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€p t. p âˆˆ R âˆ§ unit t â‡’ t rdivides p
</pre>

<DT><span class="strong">ring_divides_iso</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f.
    (r =r= r_) f â‡’ âˆ€p q. p âˆˆ R âˆ§ p rdivides q â‡’ ring_divides r_ (f p) (f q)
</pre>

<DT><span class="strong">ring_divides_le</span>
<DD>
<pre>
âŠ¢ âˆ€r f.
    EuclideanRing r f âˆ§ ring_ordering r f â‡’
    âˆ€p q. p âˆˆ R âˆ§ q âˆˆ R âˆ§ p â‰  #0 âˆ§ q rdivides p â‡’ f q â‰¤ f p
</pre>

<DT><span class="strong">ring_divides_refl</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€p. p âˆˆ R â‡’ p rdivides p
</pre>

<DT><span class="strong">ring_divides_trans</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€p q t.
        p âˆˆ R âˆ§ q âˆˆ R âˆ§ t âˆˆ R âˆ§ p rdivides q âˆ§ q rdivides t â‡’ p rdivides t
</pre>

<DT><span class="strong">ring_divides_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€p. p âˆˆ R â‡’ p rdivides #0
</pre>

<DT><span class="strong">ring_eq_unit_eq</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R âˆ§ x = y â‡’ x =~ y
</pre>

<DT><span class="strong">ring_exp_0</span>
<DD>
<pre>
âŠ¢ âˆ€x. x ** 0 = #1
</pre>

<DT><span class="strong">ring_exp_1</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ x ** 1 = x
</pre>

<DT><span class="strong">ring_exp_SUC</span>
<DD>
<pre>
âŠ¢ âˆ€x n. x ** SUC n = x * x ** n
</pre>

<DT><span class="strong">ring_exp_add</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ âˆ€n k. x ** (n + k) = x ** n * x ** k
</pre>

<DT><span class="strong">ring_exp_add_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ âˆ€n k. x ** n * (x ** k * y) = x ** (n + k) * y
</pre>

<DT><span class="strong">ring_exp_comm</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ âˆ€n. x ** n * x = x * x ** n
</pre>

<DT><span class="strong">ring_exp_element</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ âˆ€n. x ** n âˆˆ R
</pre>

<DT><span class="strong">ring_exp_mod_order</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x. x âˆˆ R âˆ§ 0 < order r.prod x â‡’
          âˆ€n. x ** n = x ** (n MOD order r.prod x)
</pre>

<DT><span class="strong">ring_exp_mult</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ âˆ€n k. x ** (n * k) = (x ** n) ** k
</pre>

<DT><span class="strong">ring_exp_mult_comm</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ âˆ€m n. (x ** m) ** n = (x ** n) ** m
</pre>

<DT><span class="strong">ring_exp_neg</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ âˆ€n. -x ** n = if EVEN n then x ** n else -(x ** n)
</pre>

<DT><span class="strong">ring_exp_small</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x. x âˆˆ R â‡’
          x ** 0 = #1 âˆ§ x ** 1 = x âˆ§ x ** 2 = x * x âˆ§ x ** 3 = x * x ** 2 âˆ§
          x ** 4 = x * x ** 3 âˆ§ x ** 5 = x * x ** 4 âˆ§ x ** 6 = x * x ** 5 âˆ§
          x ** 7 = x * x ** 6 âˆ§ x ** 8 = x * x ** 7 âˆ§ x ** 9 = x * x ** 8
</pre>

<DT><span class="strong">ring_exp_suc</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ âˆ€n. x ** SUC n = x ** n * x
</pre>

<DT><span class="strong">ring_factor_multiple</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€p q.
        p âˆˆ R âˆ§ q âˆˆ R âˆ§ (âˆƒk. k âˆˆ R âˆ§ p = k * q) â‡’
        âˆ€z. z âˆˆ R âˆ§ (âˆƒs. s âˆˆ R âˆ§ z = s * p) â‡’ âˆƒt. t âˆˆ R âˆ§ z = t * q
</pre>

<DT><span class="strong">ring_fermat_all</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r âˆ§ prime (char r) â‡’ âˆ€n k. $## n ** char r ** k = $## n
</pre>

<DT><span class="strong">ring_fermat_thm</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r âˆ§ prime (char r) â‡’ âˆ€n. $## n ** char r = $## n
</pre>

<DT><span class="strong">ring_first_isomorphism_thm</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f.
    (r ~r~ r_) f â‡’
    (let
       i = kernel_ideal f r r_
     in
       i << r âˆ§ ring_homo_image f r r_ â‰¤ r_ âˆ§
       RingIso (f âˆ˜ gen) (r / i) (ring_homo_image f r r_))
</pre>

<DT><span class="strong">ring_fn_updates</span>
<DD>
<pre>
âŠ¢ (âˆ€f0 f m m0. ring f m m0 with carrier updated_by f0 = ring (f0 f) m m0) âˆ§
  (âˆ€f0 f m m0. ring f m m0 with sum updated_by f0 = ring f (f0 m) m0) âˆ§
  âˆ€f0 f m m0. ring f m m0 with prod updated_by f0 = ring f m (f0 m0)
</pre>

<DT><span class="strong">ring_freshman_all</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r âˆ§ prime (char r) â‡’
      âˆ€x y.
        x âˆˆ R âˆ§ y âˆˆ R â‡’
        âˆ€n. (x + y) ** char r ** n = x ** char r ** n + y ** char r ** n
</pre>

<DT><span class="strong">ring_freshman_all_sub</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r âˆ§ prime (char r) â‡’
      âˆ€x y.
        x âˆˆ R âˆ§ y âˆˆ R â‡’
        âˆ€n. (x âˆ’ y) ** char r ** n = x ** char r ** n âˆ’ y ** char r ** n
</pre>

<DT><span class="strong">ring_freshman_thm</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r âˆ§ prime (char r) â‡’
      âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ (x + y) ** char r = x ** char r + y ** char r
</pre>

<DT><span class="strong">ring_freshman_thm_sub</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r âˆ§ prime (char r) â‡’
      âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ (x âˆ’ y) ** char r = x ** char r âˆ’ y ** char r
</pre>

<DT><span class="strong">ring_fun_add</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€a b. rfun a âˆ§ rfun b â‡’ rfun (Î»k. a k + b k)
</pre>

<DT><span class="strong">ring_fun_from_ring_fun</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€f. rfun f â‡’ âˆ€x. x âˆˆ R â‡’ rfun (Î»j. f j * x ** j)
</pre>

<DT><span class="strong">ring_fun_from_ring_fun_exp</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€f. rfun f â‡’ âˆ€x. x âˆˆ R â‡’ âˆ€n. rfun (Î»j. (f j * x ** j) ** n)
</pre>

<DT><span class="strong">ring_fun_genlist</span>
<DD>
<pre>
âŠ¢ âˆ€f. rfun f â‡’ âˆ€n. rlist (GENLIST f n)
</pre>

<DT><span class="strong">ring_fun_map</span>
<DD>
<pre>
âŠ¢ âˆ€f l. rfun f â‡’ rlist (MAP f l)
</pre>

<DT><span class="strong">ring_fupdcanon</span>
<DD>
<pre>
âŠ¢ (âˆ€r g f.
     r with <|sum updated_by f; carrier updated_by g|> =
     r with <|carrier updated_by g; sum updated_by f|>) âˆ§
  (âˆ€r g f.
     r with <|prod updated_by f; carrier updated_by g|> =
     r with <|carrier updated_by g; prod updated_by f|>) âˆ§
  âˆ€r g f.
    r with <|prod updated_by f; sum updated_by g|> =
    r with <|sum updated_by g; prod updated_by f|>
</pre>

<DT><span class="strong">ring_fupdcanon_comp</span>
<DD>
<pre>
âŠ¢ ((âˆ€g f. sum_fupd f âˆ˜ carrier_fupd g = carrier_fupd g âˆ˜ sum_fupd f) âˆ§
   âˆ€h g f. sum_fupd f âˆ˜ carrier_fupd g âˆ˜ h = carrier_fupd g âˆ˜ sum_fupd f âˆ˜ h) âˆ§
  ((âˆ€g f. prod_fupd f âˆ˜ carrier_fupd g = carrier_fupd g âˆ˜ prod_fupd f) âˆ§
   âˆ€h g f. prod_fupd f âˆ˜ carrier_fupd g âˆ˜ h = carrier_fupd g âˆ˜ prod_fupd f âˆ˜ h) âˆ§
  (âˆ€g f. prod_fupd f âˆ˜ sum_fupd g = sum_fupd g âˆ˜ prod_fupd f) âˆ§
  âˆ€h g f. prod_fupd f âˆ˜ sum_fupd g âˆ˜ h = sum_fupd g âˆ˜ prod_fupd f âˆ˜ h
</pre>

<DT><span class="strong">ring_fupdfupds</span>
<DD>
<pre>
âŠ¢ (âˆ€r g f.
     r with <|carrier updated_by f; carrier updated_by g|> =
     r with carrier updated_by f âˆ˜ g) âˆ§
  (âˆ€r g f.
     r with <|sum updated_by f; sum updated_by g|> =
     r with sum updated_by f âˆ˜ g) âˆ§
  âˆ€r g f.
    r with <|prod updated_by f; prod updated_by g|> =
    r with prod updated_by f âˆ˜ g
</pre>

<DT><span class="strong">ring_fupdfupds_comp</span>
<DD>
<pre>
âŠ¢ ((âˆ€g f. carrier_fupd f âˆ˜ carrier_fupd g = carrier_fupd (f âˆ˜ g)) âˆ§
   âˆ€h g f. carrier_fupd f âˆ˜ carrier_fupd g âˆ˜ h = carrier_fupd (f âˆ˜ g) âˆ˜ h) âˆ§
  ((âˆ€g f. sum_fupd f âˆ˜ sum_fupd g = sum_fupd (f âˆ˜ g)) âˆ§
   âˆ€h g f. sum_fupd f âˆ˜ sum_fupd g âˆ˜ h = sum_fupd (f âˆ˜ g) âˆ˜ h) âˆ§
  (âˆ€g f. prod_fupd f âˆ˜ prod_fupd g = prod_fupd (f âˆ˜ g)) âˆ§
  âˆ€h g f. prod_fupd f âˆ˜ prod_fupd g âˆ˜ h = prod_fupd (f âˆ˜ g) âˆ˜ h
</pre>

<DT><span class="strong">ring_gcd_divides</span>
<DD>
<pre>
âŠ¢ âˆ€r f.
    EuclideanRing r f â‡’
    âˆ€p q. p âˆˆ R âˆ§ q âˆˆ R â‡’ rgcd p q rdivides p âˆ§ rgcd p q rdivides q
</pre>

<DT><span class="strong">ring_gcd_element</span>
<DD>
<pre>
âŠ¢ âˆ€r f. EuclideanRing r f â‡’ âˆ€p q. p âˆˆ R âˆ§ q âˆˆ R â‡’ rgcd p q âˆˆ R
</pre>

<DT><span class="strong">ring_gcd_is_gcd</span>
<DD>
<pre>
âŠ¢ âˆ€r f.
    EuclideanRing r f â‡’
    âˆ€p q.
      p âˆˆ R âˆ§ q âˆˆ R â‡’
      rgcd p q rdivides p âˆ§ rgcd p q rdivides q âˆ§
      âˆ€d. d âˆˆ R âˆ§ d rdivides p âˆ§ d rdivides q â‡’ d rdivides rgcd p q
</pre>

<DT><span class="strong">ring_gcd_linear</span>
<DD>
<pre>
âŠ¢ âˆ€r f.
    EuclideanRing r f â‡’
    âˆ€p q. p âˆˆ R âˆ§ q âˆˆ R â‡’ âˆƒa b. a âˆˆ R âˆ§ b âˆˆ R âˆ§ rgcd p q = a * p + b * q
</pre>

<DT><span class="strong">ring_gcd_property</span>
<DD>
<pre>
âŠ¢ âˆ€r f.
    EuclideanRing r f â‡’
    âˆ€p q.
      p âˆˆ R âˆ§ q âˆˆ R â‡’
      âˆ€d. d âˆˆ R âˆ§ d rdivides p âˆ§ d rdivides q â‡’ d rdivides rgcd p q
</pre>

<DT><span class="strong">ring_gcd_sym</span>
<DD>
<pre>
âŠ¢ âˆ€r f. EuclideanRing r f â‡’ âˆ€p q. p âˆˆ R âˆ§ q âˆˆ R â‡’ rgcd p q = rgcd q p
</pre>

<DT><span class="strong">ring_gcd_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r f p. rgcd p #0 = p âˆ§ rgcd #0 p = p
</pre>

<DT><span class="strong">ring_homo_I_refl</span>
<DD>
<pre>
âŠ¢ âˆ€r. RingHomo I r r
</pre>

<DT><span class="strong">ring_homo_add</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r ~r~ r_) f â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ f (x + y) = f x +_ f y
</pre>

<DT><span class="strong">ring_homo_char_divides</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r ~r~ r_) f â‡’ char r_ divides char r
</pre>

<DT><span class="strong">ring_homo_compose</span>
<DD>
<pre>
âŠ¢ âˆ€r s t f1 f2. RingHomo f1 r s âˆ§ RingHomo f2 s t â‡’ RingHomo (f2 âˆ˜ f1) r t
</pre>

<DT><span class="strong">ring_homo_cong</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f1 f2.
    Ring r âˆ§ Ring r_ âˆ§ (âˆ€x. x âˆˆ R â‡’ f1 x = f2 x) â‡’
    (RingHomo f1 r r_ â‡” RingHomo f2 r r_)
</pre>

<DT><span class="strong">ring_homo_element</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. RingHomo f r r_ â‡’ âˆ€x. x âˆˆ R â‡’ f x âˆˆ R_
</pre>

<DT><span class="strong">ring_homo_eq_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r ~r~ r_) f âˆ§ INJ f R R_ â‡’ âˆ€x. x âˆˆ R â‡’ (f x = #0_ â‡” x = #0)
</pre>

<DT><span class="strong">ring_homo_exp</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r ~r~ r_) f â‡’ âˆ€x. x âˆˆ R â‡’ âˆ€n. f (x ** n) = f x **_ n
</pre>

<DT><span class="strong">ring_homo_ideal_group</span>
<DD>
<pre>
âŠ¢ âˆ€r s f. (r ~r~ s) f â‡’ âˆ€i. i << r â‡’ Group (homo_ideal f r s i).sum
</pre>

<DT><span class="strong">ring_homo_ideal_ideal</span>
<DD>
<pre>
âŠ¢ âˆ€r s f.
    Ring r âˆ§ Ring s âˆ§ RingHomo f r s âˆ§ SURJ f R s.carrier â‡’
    âˆ€i. i << r â‡’ homo_ideal f r s i << s
</pre>

<DT><span class="strong">ring_homo_ideal_subgroup</span>
<DD>
<pre>
âŠ¢ âˆ€r s f. (r ~r~ s) f â‡’ âˆ€i. i << r â‡’ (homo_ideal f r s i).sum â‰¤ s.sum
</pre>

<DT><span class="strong">ring_homo_ids</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r ~r~ r_) f â‡’ f #0 = #0_ âˆ§ f #1 = #1_
</pre>

<DT><span class="strong">ring_homo_image_bij</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f.
    (r ~r~ r_) f âˆ§ INJ f R R_ â‡’ BIJ f R (ring_homo_image f r r_).carrier
</pre>

<DT><span class="strong">ring_homo_image_carrier</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (ring_homo_image f r r_).carrier = IMAGE f R
</pre>

<DT><span class="strong">ring_homo_image_homo</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r ~r~ r_) f â‡’ RingHomo f r (ring_homo_image f r r_)
</pre>

<DT><span class="strong">ring_homo_image_is_subring</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r ~r~ r_) f â‡’ subring (ring_homo_image f r r_) r_
</pre>

<DT><span class="strong">ring_homo_image_iso</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r ~r~ r_) f âˆ§ INJ f R R_ â‡’ RingIso f r (ring_homo_image f r r_)
</pre>

<DT><span class="strong">ring_homo_image_ring</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r ~r~ r_) f â‡’ Ring (ring_homo_image f r r_)
</pre>

<DT><span class="strong">ring_homo_image_subring</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r ~r~ r_) f â‡’ ring_homo_image f r r_ â‰¤ r_
</pre>

<DT><span class="strong">ring_homo_image_subring_subring</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f.
    (r ~r~ r_) f â‡’
    âˆ€s. Ring s âˆ§ subring s r â‡’ subring (ring_homo_image f s r_) r_
</pre>

<DT><span class="strong">ring_homo_image_surj_property</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f.
    Ring r âˆ§ Ring r_ âˆ§ SURJ f R R_ â‡’ RingIso I r_ (ring_homo_image f r r_)
</pre>

<DT><span class="strong">ring_homo_inv</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r ~r~ r_) f â‡’ âˆ€x. unit x â‡’ f ( |/ x) = |/_ (f x)
</pre>

<DT><span class="strong">ring_homo_kernel_ideal</span>
<DD>
<pre>
âŠ¢ âˆ€f r s. (r ~r~ s) f â‡’ kernel_ideal f r s << r
</pre>

<DT><span class="strong">ring_homo_linv_homo</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r ~r~ r_) f âˆ§ BIJ f R R_ â‡’ RingHomo (LINV f R) r_ r
</pre>

<DT><span class="strong">ring_homo_mult</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r ~r~ r_) f â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ f (x * y) = f x *_ f y
</pre>

<DT><span class="strong">ring_homo_neg</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r ~r~ r_) f â‡’ âˆ€x. x âˆˆ R â‡’ f (-x) = $-_ (f x)
</pre>

<DT><span class="strong">ring_homo_num</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r ~r~ r_) f â‡’ âˆ€n. f ($## n) = ##_ #1_ n
</pre>

<DT><span class="strong">ring_homo_num_nonzero</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f.
    (r ~r~ r_) f â‡’ âˆ€c. 0 < c âˆ§ c < char r_ â‡’ $## c â‰  #0 âˆ§ f ($## c) â‰  #0_
</pre>

<DT><span class="strong">ring_homo_one</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r ~r~ r_) f â‡’ f #1 = #1_
</pre>

<DT><span class="strong">ring_homo_one_eq_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r ~r~ r_) f âˆ§ #1 = #0 â‡’ #1_ = #0_
</pre>

<DT><span class="strong">ring_homo_property</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f.
    Ring r âˆ§ RingHomo f r r_ â‡’
    âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ f (x + y) = f x +_ f y âˆ§ f (x * y) = f x *_ f y
</pre>

<DT><span class="strong">ring_homo_ring_homo_subring</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r ~r~ r_) f â‡’ subring (ring_homo_image f r r_) r_
</pre>

<DT><span class="strong">ring_homo_sub</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r ~r~ r_) f â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ f (x âˆ’ y) = f x -_ f y
</pre>

<DT><span class="strong">ring_homo_subring_homo</span>
<DD>
<pre>
âŠ¢ âˆ€r s r_ f. (r ~r~ r_) f âˆ§ s â‰¤ r â‡’ (s ~r~ ring_homo_image f s r_) f
</pre>

<DT><span class="strong">ring_homo_sum_num_property</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f.
    (r ~r~ r_) f â‡’ âˆ€c. 0 < c âˆ§ c < char r_ â‡’ $## c â‰  #0 âˆ§ ##_ #1_ c â‰  #0_
</pre>

<DT><span class="strong">ring_homo_sym</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r ~r~ r_) f âˆ§ BIJ f R R_ â‡’ RingHomo (LINV f R) r_ r
</pre>

<DT><span class="strong">ring_homo_sym_any</span>
<DD>
<pre>
âŠ¢ Ring r âˆ§ Ring s âˆ§ RingHomo f r s âˆ§
  (âˆ€x. x âˆˆ s.carrier â‡’ i x âˆˆ R âˆ§ f (i x) = x) âˆ§ (âˆ€x. x âˆˆ R â‡’ i (f x) = x) â‡’
  RingHomo i s r
</pre>

<DT><span class="strong">ring_homo_trans</span>
<DD>
<pre>
âŠ¢ âˆ€r s t f1 f2. RingHomo f1 r s âˆ§ RingHomo f2 s t â‡’ RingHomo (f2 âˆ˜ f1) r t
</pre>

<DT><span class="strong">ring_homo_unit</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r ~r~ r_) f â‡’ âˆ€x. unit x â‡’ unit_ (f x)
</pre>

<DT><span class="strong">ring_homo_unit_inv</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r ~r~ r_) f â‡’ âˆ€x. unit x â‡’ |/_ (f x) = f ( |/ x)
</pre>

<DT><span class="strong">ring_homo_unit_inv_element</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r ~r~ r_) f â‡’ âˆ€x. unit x â‡’ |/_ (f x) âˆˆ R_
</pre>

<DT><span class="strong">ring_homo_unit_inv_nonzero</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r ~r~ r_) f âˆ§ #1_ â‰  #0_ â‡’ âˆ€x. unit x â‡’ |/_ (f x) â‰  #0_
</pre>

<DT><span class="strong">ring_homo_unit_nonzero</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r ~r~ r_) f âˆ§ #1_ â‰  #0_ â‡’ âˆ€x. unit x â‡’ f x â‰  #0_
</pre>

<DT><span class="strong">ring_homo_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r ~r~ r_) f â‡’ f #0 = #0_
</pre>

<DT><span class="strong">ring_induction</span>
<DD>
<pre>
âŠ¢ âˆ€P. (âˆ€f m m0. P (ring f m m0)) â‡’ âˆ€r. P r
</pre>

<DT><span class="strong">ring_inj_image_alt</span>
<DD>
<pre>
âŠ¢ âˆ€r f.
    Ring r â‡’
    ring_inj_image r f =
    <|carrier := IMAGE f R; sum := monoid_inj_image r.sum f;
      prod := monoid_inj_image r.prod f|>
</pre>

<DT><span class="strong">ring_inj_image_carrier</span>
<DD>
<pre>
âŠ¢ âˆ€r f. (ring_inj_image r f).carrier = IMAGE f R
</pre>

<DT><span class="strong">ring_inj_image_prod_abelian_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€r f. Ring r âˆ§ INJ f R ğ•Œ(:Î²) â‡’ AbelianMonoid (ring_inj_image r f).prod
</pre>

<DT><span class="strong">ring_inj_image_prod_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€r f. Ring r âˆ§ INJ f R ğ•Œ(:Î²) â‡’ Monoid (ring_inj_image r f).prod
</pre>

<DT><span class="strong">ring_inj_image_prod_monoid_homo</span>
<DD>
<pre>
âŠ¢ âˆ€r f. Ring r âˆ§ INJ f R ğ•Œ(:Î²) â‡’ MonoidHomo f r.prod (ring_inj_image r f).prod
</pre>

<DT><span class="strong">ring_inj_image_ring</span>
<DD>
<pre>
âŠ¢ âˆ€r f. Ring r âˆ§ INJ f R ğ•Œ(:Î²) â‡’ Ring (ring_inj_image r f)
</pre>

<DT><span class="strong">ring_inj_image_ring_homo</span>
<DD>
<pre>
âŠ¢ âˆ€r f. Ring r âˆ§ INJ f R ğ•Œ(:Î²) â‡’ RingHomo f r (ring_inj_image r f)
</pre>

<DT><span class="strong">ring_inj_image_sum_abelian_group</span>
<DD>
<pre>
âŠ¢ âˆ€r f. Ring r âˆ§ INJ f R ğ•Œ(:Î²) â‡’ AbelianGroup (ring_inj_image r f).sum
</pre>

<DT><span class="strong">ring_inj_image_sum_group</span>
<DD>
<pre>
âŠ¢ âˆ€r f. Ring r âˆ§ INJ f R ğ•Œ(:Î²) â‡’ Group (ring_inj_image r f).sum
</pre>

<DT><span class="strong">ring_inj_image_sum_group_homo</span>
<DD>
<pre>
âŠ¢ âˆ€r f. Ring r âˆ§ INJ f R ğ•Œ(:Î²) â‡’ GroupHomo f r.sum (ring_inj_image r f).sum
</pre>

<DT><span class="strong">ring_inj_image_sum_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€r f. Ring r âˆ§ INJ f R ğ•Œ(:Î²) â‡’ Monoid (ring_inj_image r f).sum
</pre>

<DT><span class="strong">ring_inv_one</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ |/ #1 = #1
</pre>

<DT><span class="strong">ring_irreducible_gcd</span>
<DD>
<pre>
âŠ¢ âˆ€r f.
    EuclideanRing r f â‡’
    âˆ€p. p âˆˆ R âˆ§ atom p â‡’ âˆ€q. q âˆˆ R â‡’ unit (rgcd p q) âˆ¨ p rdivides q
</pre>

<DT><span class="strong">ring_iso_I_refl</span>
<DD>
<pre>
âŠ¢ âˆ€r. RingIso I r r
</pre>

<DT><span class="strong">ring_iso_add</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r =r= r_) f â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ f (x + y) = f x +_ f y
</pre>

<DT><span class="strong">ring_iso_bij</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r =r= r_) f â‡’ BIJ f R R_
</pre>

<DT><span class="strong">ring_iso_card_eq</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. RingIso f r r_ âˆ§ FINITE R â‡’ CARD R = CARD R_
</pre>

<DT><span class="strong">ring_iso_char_eq</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r =r= r_) f â‡’ char r_ = char r
</pre>

<DT><span class="strong">ring_iso_compose</span>
<DD>
<pre>
âŠ¢ âˆ€r s t f1 f2. RingIso f1 r s âˆ§ RingIso f2 s t â‡’ RingIso (f2 âˆ˜ f1) r t
</pre>

<DT><span class="strong">ring_iso_cong</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f1 f2.
    Ring r âˆ§ Ring r_ âˆ§ (âˆ€x. x âˆˆ R â‡’ f1 x = f2 x) â‡’
    (RingIso f1 r r_ â‡” RingIso f2 r r_)
</pre>

<DT><span class="strong">ring_iso_element</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. RingIso f r r_ â‡’ âˆ€x. x âˆˆ R â‡’ f x âˆˆ R_
</pre>

<DT><span class="strong">ring_iso_element_unique</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r =r= r_) f â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ (f x = f y â‡” x = y)
</pre>

<DT><span class="strong">ring_iso_eq_one</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r =r= r_) f â‡’ âˆ€x. x âˆˆ R â‡’ (f x = #1_ â‡” x = #1)
</pre>

<DT><span class="strong">ring_iso_eq_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r =r= r_) f â‡’ âˆ€x. x âˆˆ R â‡’ (f x = #0_ â‡” x = #0)
</pre>

<DT><span class="strong">ring_iso_exp</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r =r= r_) f â‡’ âˆ€x. x âˆˆ R â‡’ âˆ€n. f (x ** n) = f x **_ n
</pre>

<DT><span class="strong">ring_iso_ids</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r =r= r_) f â‡’ f #0 = #0_ âˆ§ f #1 = #1_
</pre>

<DT><span class="strong">ring_iso_inv</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r =r= r_) f â‡’ âˆ€x. unit x â‡’ f ( |/ x) = |/_ (f x)
</pre>

<DT><span class="strong">ring_iso_inverse</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r =r= r_) f â‡’ âˆ€y. y âˆˆ R_ â‡’ âˆƒx. x âˆˆ R âˆ§ y = f x
</pre>

<DT><span class="strong">ring_iso_inverse_element</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r =r= r_) f â‡’ âˆ€y. y âˆˆ R_ â‡’ LINV f R y âˆˆ R âˆ§ y = f (LINV f R y)
</pre>

<DT><span class="strong">ring_iso_linv_iso</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r =r= r_) f â‡’ RingIso (LINV f R) r_ r
</pre>

<DT><span class="strong">ring_iso_mult</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r =r= r_) f â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ f (x * y) = f x *_ f y
</pre>

<DT><span class="strong">ring_iso_neg</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r =r= r_) f â‡’ âˆ€x. x âˆˆ R â‡’ f (-x) = $-_ (f x)
</pre>

<DT><span class="strong">ring_iso_nonzero</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r =r= r_) f â‡’ âˆ€x. x âˆˆ R+ â‡’ f x âˆˆ R+_
</pre>

<DT><span class="strong">ring_iso_num</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r =r= r_) f â‡’ âˆ€n. f ($## n) = ##_ #1_ n
</pre>

<DT><span class="strong">ring_iso_one</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r =r= r_) f â‡’ f #1 = #1_
</pre>

<DT><span class="strong">ring_iso_property</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f.
    Ring r âˆ§ RingIso f r r_ â‡’
    âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ f (x + y) = f x +_ f y âˆ§ f (x * y) = f x *_ f y
</pre>

<DT><span class="strong">ring_iso_ring_homo_subring</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r =r= r_) f â‡’ subring (ring_homo_image f r r_) r_
</pre>

<DT><span class="strong">ring_iso_sub</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r =r= r_) f â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ f (x âˆ’ y) = f x -_ f y
</pre>

<DT><span class="strong">ring_iso_subring_iso</span>
<DD>
<pre>
âŠ¢ âˆ€r s r_ f. (r =r= r_) f âˆ§ s â‰¤ r â‡’ (s =r= ring_homo_image f s r_) f
</pre>

<DT><span class="strong">ring_iso_sym</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r =r= r_) f â‡’ RingIso (LINV f R) r_ r
</pre>

<DT><span class="strong">ring_iso_sym_any</span>
<DD>
<pre>
âŠ¢ Ring r âˆ§ Ring s âˆ§ RingIso f r s âˆ§
  (âˆ€x. x âˆˆ s.carrier â‡’ i x âˆˆ R âˆ§ f (i x) = x) âˆ§ (âˆ€x. x âˆˆ R â‡’ i (f x) = x) â‡’
  RingIso i s r
</pre>

<DT><span class="strong">ring_iso_trans</span>
<DD>
<pre>
âŠ¢ âˆ€r s t f1 f2. RingIso f1 r s âˆ§ RingIso f2 s t â‡’ RingIso (f2 âˆ˜ f1) r t
</pre>

<DT><span class="strong">ring_iso_unit</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r =r= r_) f â‡’ âˆ€x. unit x â‡’ unit_ (f x)
</pre>

<DT><span class="strong">ring_iso_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r =r= r_) f â‡’ f #0 = #0_
</pre>

<DT><span class="strong">ring_list_SNOC</span>
<DD>
<pre>
âŠ¢ âˆ€x s. rlist (SNOC x s) â‡” x âˆˆ R âˆ§ rlist s
</pre>

<DT><span class="strong">ring_list_cons</span>
<DD>
<pre>
âŠ¢ âˆ€r h t. rlist (h::t) â‡” h âˆˆ R âˆ§ rlist t
</pre>

<DT><span class="strong">ring_list_from_genlist</span>
<DD>
<pre>
âŠ¢ âˆ€r f. rfun f â‡’ âˆ€n. rlist (GENLIST f n)
</pre>

<DT><span class="strong">ring_list_from_genlist_ring_fun</span>
<DD>
<pre>
âŠ¢ âˆ€r f. rfun f â‡’ âˆ€n g. rlist (GENLIST (f âˆ˜ g) n)
</pre>

<DT><span class="strong">ring_list_front_last</span>
<DD>
<pre>
âŠ¢ âˆ€s. rlist (FRONT s) âˆ§ LAST s âˆˆ R â‡’ rlist s
</pre>

<DT><span class="strong">ring_list_gen_from_ring_fun</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€f. rfun f â‡’ âˆ€x. x âˆˆ R â‡’ âˆ€n. rlist (GENLIST (Î»j. f j * x ** j) n)
</pre>

<DT><span class="strong">ring_list_nil</span>
<DD>
<pre>
âŠ¢ âˆ€r. rlist [] â‡” T
</pre>

<DT><span class="strong">ring_literal_11</span>
<DD>
<pre>
âŠ¢ âˆ€f1 m01 m1 f2 m02 m2.
    <|carrier := f1; sum := m01; prod := m1|> =
    <|carrier := f2; sum := m02; prod := m2|> â‡” f1 = f2 âˆ§ m01 = m02 âˆ§ m1 = m2
</pre>

<DT><span class="strong">ring_literal_nchotomy</span>
<DD>
<pre>
âŠ¢ âˆ€r. âˆƒf m0 m. r = <|carrier := f; sum := m0; prod := m|>
</pre>

<DT><span class="strong">ring_mult_abelian_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ AbelianMonoid r.prod
</pre>

<DT><span class="strong">ring_mult_add</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€z y x.
        x âˆˆ R âˆ§ y âˆˆ R âˆ§ z âˆˆ R â‡’
        x * (y + z) = x * y + x * z âˆ§ (y + z) * x = y * x + z * x
</pre>

<DT><span class="strong">ring_mult_add_neg</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x. x âˆˆ R â‡’ âˆ€n. $## n * x + -x = if n = 0 then -x else $## (n âˆ’ 1) * x
</pre>

<DT><span class="strong">ring_mult_add_neg_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x y.
        x âˆˆ R âˆ§ y âˆˆ R â‡’
        âˆ€n. $## n * x + (-x + y) =
            if n = 0 then -x + y else $## (n âˆ’ 1) * x + y
</pre>

<DT><span class="strong">ring_mult_add_neg_mult</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x. x âˆˆ R â‡’
          âˆ€m n.
            $## m * x + -($## n * x) =
            if m < n then -($## (n âˆ’ m) * x) else $## (m âˆ’ n) * x
</pre>

<DT><span class="strong">ring_mult_add_neg_mult_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x y.
        x âˆˆ R âˆ§ y âˆˆ R â‡’
        âˆ€m n.
          $## m * x + (-($## n * x) + y) =
          if m < n then -($## (n âˆ’ m) * x) + y else $## (m âˆ’ n) * x + y
</pre>

<DT><span class="strong">ring_mult_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y z. x âˆˆ R âˆ§ y âˆˆ R âˆ§ z âˆˆ R â‡’ x * y * z = x * (y * z)
</pre>

<DT><span class="strong">ring_mult_assoc_comm</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y z. x âˆˆ R âˆ§ y âˆˆ R âˆ§ z âˆˆ R â‡’ x * (y * z) = y * (x * z)
</pre>

<DT><span class="strong">ring_mult_comm</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ x * y = y * x
</pre>

<DT><span class="strong">ring_mult_divides</span>
<DD>
<pre>
âŠ¢ âˆ€r p q x.
    Ring r âˆ§ p * q rdivides x âˆ§ p âˆˆ R âˆ§ q âˆˆ R â‡’ p rdivides x âˆ§ q rdivides x
</pre>

<DT><span class="strong">ring_mult_element</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ x * y âˆˆ R
</pre>

<DT><span class="strong">ring_mult_exp</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ âˆ€n. (x * y) ** n = x ** n * y ** n
</pre>

<DT><span class="strong">ring_mult_ladd</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y z. x âˆˆ R âˆ§ y âˆˆ R âˆ§ z âˆˆ R â‡’ (y + z) * x = y * x + z * x
</pre>

<DT><span class="strong">ring_mult_lneg</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ -x * y = -(x * y)
</pre>

<DT><span class="strong">ring_mult_lone</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ #1 * x = x
</pre>

<DT><span class="strong">ring_mult_lsub</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y z. x âˆˆ R âˆ§ y âˆˆ R âˆ§ z âˆˆ R â‡’ x * z âˆ’ y * z = (x âˆ’ y) * z
</pre>

<DT><span class="strong">ring_mult_lzero</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ #0 * x = #0
</pre>

<DT><span class="strong">ring_mult_monoid</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      Monoid r.prod âˆ§ r.prod.carrier = R âˆ§ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ x * y = y * x
</pre>

<DT><span class="strong">ring_mult_monoid_rwt</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ Monoid r.prod âˆ§ r.prod.carrier = R
</pre>

<DT><span class="strong">ring_mult_neg_neg</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ -x * -y = x * y
</pre>

<DT><span class="strong">ring_mult_one_one</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ #1 * #1 = #1
</pre>

<DT><span class="strong">ring_mult_pair_diff</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x y p q.
        x âˆˆ R âˆ§ y âˆˆ R âˆ§ p âˆˆ R âˆ§ q âˆˆ R â‡’
        x * y âˆ’ p * q = (x âˆ’ p) * y + p * (y âˆ’ q)
</pre>

<DT><span class="strong">ring_mult_pair_sub</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x y p q.
        x âˆˆ R âˆ§ y âˆˆ R âˆ§ p âˆˆ R âˆ§ q âˆˆ R â‡’
        x * y âˆ’ p * q = (x âˆ’ p) * (y âˆ’ q) + (x âˆ’ p) * q + p * (y âˆ’ q)
</pre>

<DT><span class="strong">ring_mult_radd</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y z. x âˆˆ R âˆ§ y âˆˆ R âˆ§ z âˆˆ R â‡’ x * (y + z) = x * y + x * z
</pre>

<DT><span class="strong">ring_mult_rneg</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ x * -y = -(x * y)
</pre>

<DT><span class="strong">ring_mult_rone</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ x * #1 = x
</pre>

<DT><span class="strong">ring_mult_rsub</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y z. x âˆˆ R âˆ§ y âˆˆ R âˆ§ z âˆˆ R â‡’ x * y âˆ’ x * z = x * (y âˆ’ z)
</pre>

<DT><span class="strong">ring_mult_rzero</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ x * #0 = #0
</pre>

<DT><span class="strong">ring_mult_zero_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ #0 * #0 = #0
</pre>

<DT><span class="strong">ring_nchotomy</span>
<DD>
<pre>
âŠ¢ âˆ€rr. âˆƒf m m0. rr = ring f m m0
</pre>

<DT><span class="strong">ring_neg_add</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ -(x + y) = -x + -y
</pre>

<DT><span class="strong">ring_neg_add_comm</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ -(x + y) = -y + -x
</pre>

<DT><span class="strong">ring_neg_add_neg</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ -x + -x = -($## 2 * x)
</pre>

<DT><span class="strong">ring_neg_add_neg_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ -x + (-x + y) = -($## 2 * x) + y
</pre>

<DT><span class="strong">ring_neg_add_neg_mult</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ âˆ€n. -x + -($## n * x) = -($## (n + 1) * x)
</pre>

<DT><span class="strong">ring_neg_add_neg_mult_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x y.
        x âˆˆ R âˆ§ y âˆˆ R â‡’ âˆ€n. -x + (-($## n * x) + y) = -($## (n + 1) * x) + y
</pre>

<DT><span class="strong">ring_neg_char_2</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r âˆ§ char r = 2 â‡’ âˆ€x. x âˆˆ R â‡’ -x = x
</pre>

<DT><span class="strong">ring_neg_element</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ -x âˆˆ R
</pre>

<DT><span class="strong">ring_neg_eq</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ (-x = -y â‡” x = y)
</pre>

<DT><span class="strong">ring_neg_eq_swap</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ (-x = y â‡” x = -y)
</pre>

<DT><span class="strong">ring_neg_eq_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ (-x = #0 â‡” x = #0)
</pre>

<DT><span class="strong">ring_neg_exp</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ âˆ€n. -x ** n = if EVEN n then x ** n else -(x ** n)
</pre>

<DT><span class="strong">ring_neg_mult</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ -(x * y) = -x * y âˆ§ -(x * y) = x * -y
</pre>

<DT><span class="strong">ring_neg_mult_add_neg_mult</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x. x âˆˆ R â‡’ âˆ€m n. -($## m * x) + -($## n * x) = -($## (m + n) * x)
</pre>

<DT><span class="strong">ring_neg_mult_add_neg_mult_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x y.
        x âˆˆ R âˆ§ y âˆˆ R â‡’
        âˆ€m n. -($## m * x) + (-($## n * x) + y) = -($## (m + n) * x) + y
</pre>

<DT><span class="strong">ring_neg_neg</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ - -x = x
</pre>

<DT><span class="strong">ring_neg_nonzero</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R+ â‡’ -x âˆˆ R+
</pre>

<DT><span class="strong">ring_neg_one_eq_one</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r âˆ§ #1 â‰  #0 â‡’ (-#1 = #1 â‡” char r = 2)
</pre>

<DT><span class="strong">ring_neg_square</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ -x ** 2 = x ** 2
</pre>

<DT><span class="strong">ring_neg_sub</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ -(x âˆ’ y) = y âˆ’ x
</pre>

<DT><span class="strong">ring_neg_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ -#0 = #0
</pre>

<DT><span class="strong">ring_nonzero_element</span>
<DD>
<pre>
âŠ¢ âˆ€r x. x âˆˆ R+ â‡’ x âˆˆ R
</pre>

<DT><span class="strong">ring_nonzero_eq</span>
<DD>
<pre>
âŠ¢ âˆ€r x. x âˆˆ R+ â‡” x âˆˆ R âˆ§ x â‰  #0
</pre>

<DT><span class="strong">ring_nonzero_mult_carrier</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ F* = R+
</pre>

<DT><span class="strong">ring_num_0</span>
<DD>
<pre>
âŠ¢ âˆ€r. $## 0 = #0
</pre>

<DT><span class="strong">ring_num_1</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ $## 1 = #1
</pre>

<DT><span class="strong">ring_num_2</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ $## 2 = #1 + #1
</pre>

<DT><span class="strong">ring_num_SUC</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€n. $## (SUC n) = #1 + $## n
</pre>

<DT><span class="strong">ring_num_add</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€n k. $## (n + k) = $## n + $## k
</pre>

<DT><span class="strong">ring_num_add_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ âˆ€m n. $## m + ($## n + x) = $## (m + n) + x
</pre>

<DT><span class="strong">ring_num_add_mult</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ âˆ€m n. $## (m + n) * x = $## m * x + $## n * x
</pre>

<DT><span class="strong">ring_num_add_mult_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x y.
        x âˆˆ R âˆ§ y âˆˆ R â‡’
        âˆ€m n. $## (m + n) * x + y = $## m * x + ($## n * x + y)
</pre>

<DT><span class="strong">ring_num_all_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ #1 = #0 â‡’ âˆ€c. $## c = #0
</pre>

<DT><span class="strong">ring_num_char_coprime_nonzero</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r âˆ§ #1 â‰  #0 â‡’ âˆ€c. coprime c (char r) â‡’ $## c â‰  #0
</pre>

<DT><span class="strong">ring_num_element</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€n. $## n âˆˆ R
</pre>

<DT><span class="strong">ring_num_eq</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€n m. n < char r âˆ§ m < char r â‡’ ($## n = $## m â‡” n = m)
</pre>

<DT><span class="strong">ring_num_exp</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€m n. $## m ** n = $## (m ** n)
</pre>

<DT><span class="strong">ring_num_mod</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r âˆ§ 0 < char r â‡’ âˆ€n. $## n = $## (n MOD char r)
</pre>

<DT><span class="strong">ring_num_mult</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€m n. $## m * $## n = $## (m * n)
</pre>

<DT><span class="strong">ring_num_mult_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€m n x. x âˆˆ R â‡’ $## m * ($## n * x) = $## (m * n) * x
</pre>

<DT><span class="strong">ring_num_mult_element</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ âˆ€n. $## n * x âˆˆ R
</pre>

<DT><span class="strong">ring_num_mult_exp</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€k m n. $## k * $## m ** n = $## (k * m ** n)
</pre>

<DT><span class="strong">ring_num_mult_neg</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ âˆ€n. -($## n * x) = $## n * -x
</pre>

<DT><span class="strong">ring_num_mult_radd</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ âˆ€n. $## n * (x + y) = $## n * x + $## n * y
</pre>

<DT><span class="strong">ring_num_mult_small</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x. x âˆˆ R â‡’
          #0 * x = #0 âˆ§ #1 * x = x âˆ§ $## 2 * x = x + x âˆ§
          $## 3 * x = $## 2 * x + x
</pre>

<DT><span class="strong">ring_num_mult_suc</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ âˆ€n. $## (SUC n) * x = $## n * x + x
</pre>

<DT><span class="strong">ring_num_negative</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r âˆ§ 0 < char r â‡’ âˆ€z. âˆƒy x. y = $## x âˆ§ y + $## z = #0
</pre>

<DT><span class="strong">ring_num_one</span>
<DD>
<pre>
âŠ¢ âˆ€r. $## 1 = #1 + #0
</pre>

<DT><span class="strong">ring_num_sub</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€n m. m < n â‡’ $## (n âˆ’ m) = $## n âˆ’ $## m
</pre>

<DT><span class="strong">ring_num_suc</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€n. $## (SUC n) = $## n + #1
</pre>

<DT><span class="strong">ring_one_element</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ #1 âˆˆ R
</pre>

<DT><span class="strong">ring_one_eq_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ (#1 = #0 â‡” R = {#0})
</pre>

<DT><span class="strong">ring_one_exp</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€n. #1 ** n = #1
</pre>

<DT><span class="strong">ring_one_unique</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€y. y âˆˆ R â‡’ ((âˆ€x. x âˆˆ R â‡’ y * x = x âˆ¨ x * y = x) â‡” y = #1)
</pre>

<DT><span class="strong">ring_prime_divides_product</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€p. p âˆˆ R â‡’
          (rprime p âˆ§ p âˆ‰ R* â‡”
           âˆ€b. FINITE_BAG b âˆ§ SET_OF_BAG b âŠ† R âˆ§ p rdivides GBAG r.prod b â‡’
               âˆƒx. x â‹² b âˆ§ p rdivides x)
</pre>

<DT><span class="strong">ring_prime_iso</span>
<DD>
<pre>
âŠ¢ âˆ€r r_ f. (r =r= r_) f â‡’ âˆ€p. p âˆˆ R âˆ§ rprime p â‡’ ring_prime r_ (f p)
</pre>

<DT><span class="strong">ring_product_factors_divide</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€b. FINITE_BAG b â‡’
          SET_OF_BAG b âŠ† R âˆ§ GBAG r.prod b rdivides x â‡’
          âˆ€y. y â‹² b â‡’ y rdivides x
</pre>

<DT><span class="strong">ring_single_add_mult</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ âˆ€n. x + $## n * x = $## (n + 1) * x
</pre>

<DT><span class="strong">ring_single_add_mult_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ âˆ€n. x + ($## n * x + y) = $## (n + 1) * x + y
</pre>

<DT><span class="strong">ring_single_add_neg_mult</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x. x âˆˆ R â‡’
          âˆ€n. x + -($## n * x) = if n = 0 then x else -($## (n âˆ’ 1) * x)
</pre>

<DT><span class="strong">ring_single_add_neg_mult_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x y.
        x âˆˆ R âˆ§ y âˆˆ R â‡’
        âˆ€n. x + (-($## n * x) + y) =
            if n = 0 then x + y else -($## (n âˆ’ 1) * x) + y
</pre>

<DT><span class="strong">ring_single_add_single</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ x + x = $## 2 * x
</pre>

<DT><span class="strong">ring_single_add_single_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ x + (x + y) = $## 2 * x + y
</pre>

<DT><span class="strong">ring_single_mult_exp</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ âˆ€n. x * x ** n = x ** (n + 1)
</pre>

<DT><span class="strong">ring_single_mult_exp_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ âˆ€n. x * (x ** n * y) = x ** (n + 1) * y
</pre>

<DT><span class="strong">ring_single_mult_single</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ x * x = x ** 2
</pre>

<DT><span class="strong">ring_single_mult_single_assoc</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ x * (x * y) = x ** 2 * y
</pre>

<DT><span class="strong">ring_sub_add</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ x âˆ’ y + y = x
</pre>

<DT><span class="strong">ring_sub_element</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ x âˆ’ y âˆˆ R
</pre>

<DT><span class="strong">ring_sub_eq</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R â‡’ x âˆ’ x = #0
</pre>

<DT><span class="strong">ring_sub_eq_add</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y z. x âˆˆ R âˆ§ y âˆˆ R âˆ§ z âˆˆ R â‡’ (x âˆ’ y = z â‡” x = y + z)
</pre>

<DT><span class="strong">ring_sub_eq_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ (x âˆ’ y = #0 â‡” x = y)
</pre>

<DT><span class="strong">ring_sub_lcancel</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y z. x âˆˆ R âˆ§ y âˆˆ R âˆ§ z âˆˆ R â‡’ (x âˆ’ y = x âˆ’ z â‡” y = z)
</pre>

<DT><span class="strong">ring_sub_pair_reduce</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y z. x âˆˆ R âˆ§ y âˆˆ R âˆ§ z âˆˆ R â‡’ x + z âˆ’ (y + z) = x âˆ’ y
</pre>

<DT><span class="strong">ring_sub_rcancel</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y z. x âˆˆ R âˆ§ y âˆˆ R âˆ§ z âˆˆ R â‡’ (y âˆ’ x = z âˆ’ x â‡” y = z)
</pre>

<DT><span class="strong">ring_sub_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ x âˆ’ #0 = x
</pre>

<DT><span class="strong">ring_sum_SNOC</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€k s. k âˆˆ R âˆ§ rlist s â‡’ rsum (SNOC k s) = rsum s + k
</pre>

<DT><span class="strong">ring_sum_append</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€s t. rlist s âˆ§ rlist t â‡’ rsum (s ++ t) = rsum s + rsum t
</pre>

<DT><span class="strong">ring_sum_cons</span>
<DD>
<pre>
âŠ¢ âˆ€r h t. rsum (h::t) = h + rsum t
</pre>

<DT><span class="strong">ring_sum_decompose_first</span>
<DD>
<pre>
âŠ¢ âˆ€r f n. rsum (GENLIST f (SUC n)) = f 0 + rsum (GENLIST (f âˆ˜ SUC) n)
</pre>

<DT><span class="strong">ring_sum_decompose_first_last</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€f n.
        rfun f âˆ§ 0 < n â‡’
        rsum (GENLIST f (SUC n)) =
        f 0 + rsum (GENLIST (f âˆ˜ SUC) (PRE n)) + f n
</pre>

<DT><span class="strong">ring_sum_decompose_last</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€f n. rfun f â‡’ rsum (GENLIST f (SUC n)) = rsum (GENLIST f n) + f n
</pre>

<DT><span class="strong">ring_sum_element</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€s. rlist s â‡’ rsum s âˆˆ R
</pre>

<DT><span class="strong">ring_sum_freshman_all</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r âˆ§ prime (char r) â‡’
      âˆ€f. rfun f â‡’
          âˆ€x. x âˆˆ R â‡’
              âˆ€n k.
                rsum (GENLIST (Î»j. f j * x ** j) n) ** char r ** k =
                rsum (GENLIST (Î»j. (f j * x ** j) ** char r ** k) n)
</pre>

<DT><span class="strong">ring_sum_freshman_thm</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r âˆ§ prime (char r) â‡’
      âˆ€f. rfun f â‡’
          âˆ€x. x âˆˆ R â‡’
              âˆ€n. rsum (GENLIST (Î»j. f j * x ** j) n) ** char r =
                  rsum (GENLIST (Î»j. (f j * x ** j) ** char r) n)
</pre>

<DT><span class="strong">ring_sum_fun_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€f. rfun f â‡’
          âˆ€n. (âˆ€k. 0 < k âˆ§ k < n â‡’ f k = #0) â‡’
              rsum (MAP f (GENLIST SUC (PRE n))) = #0
</pre>

<DT><span class="strong">ring_sum_genlist_add</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€a b.
        rfun a âˆ§ rfun b â‡’
        âˆ€n. rsum (GENLIST a n) + rsum (GENLIST b n) =
            rsum (GENLIST (Î»k. a k + b k) n)
</pre>

<DT><span class="strong">ring_sum_genlist_append</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€a b.
        rfun a âˆ§ rfun b â‡’
        âˆ€n. rsum (GENLIST a n ++ GENLIST b n) =
            rsum (GENLIST (Î»k. a k + b k) n)
</pre>

<DT><span class="strong">ring_sum_genlist_const</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ âˆ€n. rsum (GENLIST (K x) n) = $## n * x
</pre>

<DT><span class="strong">ring_sum_genlist_sum</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€f. rfun f â‡’
          âˆ€n m.
            rsum (GENLIST f (n + m)) =
            rsum (GENLIST f m) + rsum (GENLIST (Î»k. f (k + m)) n)
</pre>

<DT><span class="strong">ring_sum_mult</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€k s. k âˆˆ R âˆ§ rlist s â‡’ k * rsum s = rsum (MAP (Î»x. k * x) s)
</pre>

<DT><span class="strong">ring_sum_mult_ladd</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€m n s.
        m âˆˆ R âˆ§ n âˆˆ R âˆ§ rlist s â‡’
        (m + n) * rsum s = rsum (MAP (Î»x. m * x) s) + rsum (MAP (Î»x. n * x) s)
</pre>

<DT><span class="strong">ring_sum_nil</span>
<DD>
<pre>
âŠ¢ âˆ€r. rsum [] = #0
</pre>

<DT><span class="strong">ring_sum_sing</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ rsum [x] = x
</pre>

<DT><span class="strong">ring_sum_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€n. r.sum.exp #0 n = #0
</pre>

<DT><span class="strong">ring_unit_element</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. unit x â‡’ x âˆˆ R
</pre>

<DT><span class="strong">ring_unit_has_inv</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. unit x â‡’ unit ( |/ x)
</pre>

<DT><span class="strong">ring_unit_inv_element</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. unit x â‡’ |/ x âˆˆ R
</pre>

<DT><span class="strong">ring_unit_inv_inv</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€u. unit u â‡’ u = |/ ( |/ u)
</pre>

<DT><span class="strong">ring_unit_inv_nonzero</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r âˆ§ #1 â‰  #0 â‡’ âˆ€x. unit x â‡’ |/ x â‰  #0
</pre>

<DT><span class="strong">ring_unit_linv</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. unit x â‡’ |/ x * x = #1
</pre>

<DT><span class="strong">ring_unit_linv_inv</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€u v. unit u âˆ§ v âˆˆ R âˆ§ |/ u * v = #1 â‡’ u = v
</pre>

<DT><span class="strong">ring_unit_linv_unique</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€u v. u âˆˆ R âˆ§ unit v âˆ§ u * v = #1 â‡’ u = |/ v
</pre>

<DT><span class="strong">ring_unit_mult_eq_unit</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ (unit (x * y) â‡” unit x âˆ§ unit y)
</pre>

<DT><span class="strong">ring_unit_mult_unit</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€u v. unit u âˆ§ unit v â‡’ unit (u * v)
</pre>

<DT><span class="strong">ring_unit_mult_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. unit x âˆ§ y âˆˆ R â‡’ (x * y = #0 â‡” y = #0)
</pre>

<DT><span class="strong">ring_unit_neg</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. unit x â‡’ unit (-x)
</pre>

<DT><span class="strong">ring_unit_nonzero</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r âˆ§ #1 â‰  #0 â‡’ âˆ€x. unit x â‡’ x â‰  #0
</pre>

<DT><span class="strong">ring_unit_one</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ unit #1
</pre>

<DT><span class="strong">ring_unit_property</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€u. unit u â‡” u âˆˆ R âˆ§ âˆƒv. v âˆˆ R âˆ§ u * v = #1
</pre>

<DT><span class="strong">ring_unit_rinv</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. unit x â‡’ x * |/ x = #1
</pre>

<DT><span class="strong">ring_unit_rinv_inv</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€u v. u âˆˆ R âˆ§ unit v âˆ§ u * |/ v = #1 â‡’ u = v
</pre>

<DT><span class="strong">ring_unit_rinv_unique</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€u v. unit u âˆ§ v âˆˆ R âˆ§ u * v = #1 â‡’ v = |/ u
</pre>

<DT><span class="strong">ring_unit_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ (unit #0 â‡” #1 = #0)
</pre>

<DT><span class="strong">ring_units_abelain_group</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ AbelianGroup r*
</pre>

<DT><span class="strong">ring_units_element</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. unit x â‡’ x âˆˆ R
</pre>

<DT><span class="strong">ring_units_group</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ Group r*
</pre>

<DT><span class="strong">ring_units_has_one</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ unit #1
</pre>

<DT><span class="strong">ring_units_has_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ (unit #0 â‡” #1 = #0)
</pre>

<DT><span class="strong">ring_units_property</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ r*.op = $* âˆ§ r*.id = #1
</pre>

<DT><span class="strong">ring_updates_eq_literal</span>
<DD>
<pre>
âŠ¢ âˆ€r f m0 m.
    r with <|carrier := f; sum := m0; prod := m|> =
    <|carrier := f; sum := m0; prod := m|>
</pre>

<DT><span class="strong">ring_zero_divides</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ (#0 rdivides x â‡” x = #0)
</pre>

<DT><span class="strong">ring_zero_element</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ #0 âˆˆ R
</pre>

<DT><span class="strong">ring_zero_exp</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€n. #0 ** n = if n = 0 then #1 else #0
</pre>

<DT><span class="strong">ring_zero_fix</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ (x + x = x â‡” x = #0)
</pre>

<DT><span class="strong">ring_zero_sub</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ #0 âˆ’ x = -x
</pre>

<DT><span class="strong">ring_zero_unique</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’
      âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R â‡’ (y + x = x â‡” y = #0) âˆ§ (x + y = x â‡” y = #0)
</pre>

<DT><span class="strong">subring_I_antisym</span>
<DD>
<pre>
âŠ¢ âˆ€r s. subring s r âˆ§ subring r s â‡’ RingIso I s r
</pre>

<DT><span class="strong">subring_add</span>
<DD>
<pre>
âŠ¢ âˆ€r s. s â‰¤ r â‡’ âˆ€x y. x âˆˆ B âˆ§ y âˆˆ B â‡’ s.sum.op x y = x + y
</pre>

<DT><span class="strong">subring_by_subgroup_submonoid</span>
<DD>
<pre>
âŠ¢ âˆ€r s.
    s â‰¤ r â‡” Ring r âˆ§ Ring s âˆ§ subgroup s.sum r.sum âˆ§ submonoid s.prod r.prod
</pre>

<DT><span class="strong">subring_carrier_antisym</span>
<DD>
<pre>
âŠ¢ âˆ€r s. subring s r âˆ§ R âŠ† B â‡’ RingIso I s r
</pre>

<DT><span class="strong">subring_carrier_finite</span>
<DD>
<pre>
âŠ¢ âˆ€r s. FiniteRing r âˆ§ subring s r â‡’ FINITE B
</pre>

<DT><span class="strong">subring_carrier_subset</span>
<DD>
<pre>
âŠ¢ âˆ€r s. subring s r â‡’ B âŠ† R
</pre>

<DT><span class="strong">subring_char</span>
<DD>
<pre>
âŠ¢ âˆ€r s. s â‰¤ r â‡’ char s = char r
</pre>

<DT><span class="strong">subring_char_divides</span>
<DD>
<pre>
âŠ¢ âˆ€r s. s â‰¤ r â‡’ char r divides char s
</pre>

<DT><span class="strong">subring_element</span>
<DD>
<pre>
âŠ¢ âˆ€r s. subring s r â‡’ âˆ€x. x âˆˆ B â‡’ x âˆˆ R
</pre>

<DT><span class="strong">subring_element_alt</span>
<DD>
<pre>
âŠ¢ âˆ€r s. s â‰¤ r â‡’ âˆ€x. x âˆˆ B â‡’ x âˆˆ R
</pre>

<DT><span class="strong">subring_exp</span>
<DD>
<pre>
âŠ¢ âˆ€r s. s â‰¤ r â‡’ âˆ€x. x âˆˆ B â‡’ âˆ€n. s.prod.exp x n = x ** n
</pre>

<DT><span class="strong">subring_finite_ring</span>
<DD>
<pre>
âŠ¢ âˆ€r s. FiniteRing r âˆ§ s â‰¤ r â‡’ FiniteRing s
</pre>

<DT><span class="strong">subring_homo_homo</span>
<DD>
<pre>
âŠ¢ âˆ€r s r_ f. subring s r âˆ§ RingHomo f r r_ â‡’ RingHomo f s r_
</pre>

<DT><span class="strong">subring_ids</span>
<DD>
<pre>
âŠ¢ âˆ€r s. s â‰¤ r â‡’ s.sum.id = #0 âˆ§ s.prod.id = #1
</pre>

<DT><span class="strong">subring_mult</span>
<DD>
<pre>
âŠ¢ âˆ€r s. s â‰¤ r â‡’ âˆ€x y. x âˆˆ B âˆ§ y âˆˆ B â‡’ s.prod.op x y = x * y
</pre>

<DT><span class="strong">subring_neg</span>
<DD>
<pre>
âŠ¢ âˆ€r s. s â‰¤ r â‡’ âˆ€x. x âˆˆ B â‡’ s.sum.inv x = -x
</pre>

<DT><span class="strong">subring_num</span>
<DD>
<pre>
âŠ¢ âˆ€r s. s â‰¤ r â‡’ âˆ€n. s.sum.exp s.prod.id n = $## n
</pre>

<DT><span class="strong">subring_one</span>
<DD>
<pre>
âŠ¢ âˆ€r s. s â‰¤ r â‡’ s.prod.id = #1
</pre>

<DT><span class="strong">subring_prod_submonoid</span>
<DD>
<pre>
âŠ¢ âˆ€r s. subring s r â‡’ submonoid s.prod r.prod
</pre>

<DT><span class="strong">subring_property</span>
<DD>
<pre>
âŠ¢ âˆ€r s.
    Ring s âˆ§ subring s r â‡’
    âˆ€x y. x âˆˆ B âˆ§ y âˆˆ B â‡’ s.sum.op x y = x + y âˆ§ s.prod.op x y = x * y
</pre>

<DT><span class="strong">subring_refl</span>
<DD>
<pre>
âŠ¢ âˆ€r. subring r r
</pre>

<DT><span class="strong">subring_ring_iso_compose</span>
<DD>
<pre>
âŠ¢ âˆ€r s r_ f. subring s r âˆ§ RingIso f r r_ â‡’ RingHomo f s r_
</pre>

<DT><span class="strong">subring_ring_iso_ring_homo_subring</span>
<DD>
<pre>
âŠ¢ âˆ€r s r_ f. s â‰¤ r âˆ§ (r =r= r_) f â‡’ ring_homo_image f s r_ â‰¤ r_
</pre>

<DT><span class="strong">subring_sub</span>
<DD>
<pre>
âŠ¢ âˆ€r s. s â‰¤ r â‡’ âˆ€x y. x âˆˆ B âˆ§ y âˆˆ B â‡’ ring_sub s x y = x âˆ’ y
</pre>

<DT><span class="strong">subring_sum_subgroup</span>
<DD>
<pre>
âŠ¢ âˆ€r s. subring s r â‡’ subgroup s.sum r.sum
</pre>

<DT><span class="strong">subring_trans</span>
<DD>
<pre>
âŠ¢ âˆ€r s t. subring r s âˆ§ subring s t â‡’ subring r t
</pre>

<DT><span class="strong">subring_unit</span>
<DD>
<pre>
âŠ¢ âˆ€r s. s â‰¤ r â‡’ âˆ€x. Unit s x â‡’ unit x
</pre>

<DT><span class="strong">subring_unit_inv</span>
<DD>
<pre>
âŠ¢ âˆ€r s. s â‰¤ r â‡’ âˆ€x. Unit s x â‡’ Inv s x = |/ x
</pre>

<DT><span class="strong">subring_unit_inv_element</span>
<DD>
<pre>
âŠ¢ âˆ€r s. s â‰¤ r â‡’ âˆ€x. Unit s x â‡’ Inv s x âˆˆ B
</pre>

<DT><span class="strong">subring_unit_inv_nonzero</span>
<DD>
<pre>
âŠ¢ âˆ€r s. s â‰¤ r âˆ§ #1 â‰  #0 â‡’ âˆ€x. Unit s x â‡’ Inv s x â‰  #0
</pre>

<DT><span class="strong">subring_unit_nonzero</span>
<DD>
<pre>
âŠ¢ âˆ€r s. s â‰¤ r âˆ§ #1 â‰  #0 â‡’ âˆ€x. Unit s x â‡’ x â‰  #0
</pre>

<DT><span class="strong">subring_zero</span>
<DD>
<pre>
âŠ¢ âˆ€r s. s â‰¤ r â‡’ s.sum.id = #0
</pre>

<DT><span class="strong">symdiff_eval</span>
<DD>
<pre>
âŠ¢ symdiff_set.carrier = ğ•Œ(:Î± -> bool) âˆ§
  (âˆ€x y. symdiff_set.op x y = x âˆª y DIFF x âˆ© y) âˆ§ symdiff_set.id = âˆ…
</pre>

<DT><span class="strong">symdiff_set_inter_char</span>
<DD>
<pre>
âŠ¢ char symdiff_set_inter = 2
</pre>

<DT><span class="strong">symdiff_set_inter_ring</span>
<DD>
<pre>
âŠ¢ Ring symdiff_set_inter
</pre>

<DT><span class="strong">symdiff_univ_univ_eq_empty</span>
<DD>
<pre>
âŠ¢ symdiff ğ•Œ(:Î±) ğ•Œ(:Î±) = âˆ…
</pre>

<DT><span class="strong">trivial_char</span>
<DD>
<pre>
âŠ¢ âˆ€z. char (trivial_ring z) = 1
</pre>

<DT><span class="strong">trivial_integral_domain</span>
<DD>
<pre>
âŠ¢ âˆ€e0 e1. e0 â‰  e1 â‡’ FiniteIntegralDomain (trivial_integal_domain e0 e1)
</pre>

<DT><span class="strong">trivial_ring</span>
<DD>
<pre>
âŠ¢ âˆ€z. FiniteRing (trivial_ring z)
</pre>

<DT><span class="strong">trivial_ring_thm</span>
<DD>
<pre>
âŠ¢ âˆ€z. Ring (trivial_ring z)
</pre>

<DT><span class="strong">unit_eq_refl</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x. x âˆˆ R â‡’ x =~ x
</pre>

<DT><span class="strong">unit_eq_sym</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y. x âˆˆ R âˆ§ y âˆˆ R âˆ§ x =~ y â‡’ y =~ x
</pre>

<DT><span class="strong">unit_eq_trans</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ âˆ€x y z. x âˆˆ R âˆ§ y âˆˆ R âˆ§ z âˆˆ R âˆ§ x =~ y âˆ§ y =~ z â‡’ x =~ z
</pre>

<DT><span class="strong">zero_ideal_ideal</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ <#0> << r
</pre>

<DT><span class="strong">zero_ideal_sing</span>
<DD>
<pre>
âŠ¢ âˆ€r. Ring r â‡’ <#0>.carrier = {#0}
</pre>

</DL>



<hr>
</body>
</html>
