<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: ring</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "ring"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "OmegaTheory.html"><span class="strong">Omega</span></a>&nbsp;&nbsp;
    <a href = "containerTheory.html"><span class="strong">container</span></a>&nbsp;&nbsp;
    <a href = "groupTheory.html"><span class="strong">group</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Type <th> Arity<tr><td> <span class="strong">ring</span> <td> 1
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">EuclideanRing</span>
    <td>
    :α ring -> (α -> num) -> bool
    <tr><td>
    <span class="strong">FiniteIntegralDomain</span>
    <td>
    :α ring -> bool
    <tr><td> <span class="strong">FiniteRing</span> <td> :α ring -> bool
    <tr><td> <span class="strong">IntegralDomain</span> <td> :α ring -> bool
    <tr><td>
    <span class="strong">PrincipalIdealRing</span>
    <td>
    :α ring -> bool
    <tr><td> <span class="strong">Ring</span> <td> :α ring -> bool
    <tr><td>
    <span class="strong">RingAuto</span>
    <td>
    :(α -> α) -> α ring -> bool
    <tr><td>
    <span class="strong">RingEndo</span>
    <td>
    :(α -> α) -> α ring -> bool
    <tr><td>
    <span class="strong">RingHomo</span>
    <td>
    :(α -> β) -> α ring -> β ring -> bool
    <tr><td>
    <span class="strong">RingIso</span>
    <td>
    :(α -> β) -> α ring -> β ring -> bool
    <tr><td> <span class="strong">Z</span> <td> :int ring
    <tr><td> <span class="strong">ZN</span> <td> :num -> num ring
    <tr><td> <span class="strong">ZP</span> <td> :num -> num ring
    <tr><td> <span class="strong">Z_add</span> <td> :int monoid
    <tr><td> <span class="strong">Z_ideal</span> <td> :num -> int ring
    <tr><td> <span class="strong">Z_mult</span> <td> :int monoid
    <tr><td> <span class="strong">Z_multiple</span> <td> :num -> int -> bool
    <tr><td> <span class="strong">char</span> <td> :α ring -> num
    <tr><td> <span class="strong">compute_ordz</span> <td> :num -> num -> num
    <tr><td>
    <span class="strong">homo_ideal</span>
    <td>
    :(α -> β) -> α ring -> β ring -> α ring -> β ring
    <tr><td>
    <span class="strong">homo_ring</span>
    <td>
    :α ring -> (α -> β) -> β ring
    <tr><td> <span class="strong">ideal</span> <td> :α ring -> α ring -> bool
    <tr><td>
    <span class="strong">ideal_congruence</span>
    <td>
    :α ring -> α ring -> α -> α -> bool
    <tr><td>
    <span class="strong">ideal_coset_add</span>
    <td>
    :α ring -> α ring -> (α -> bool) -> (α -> bool) -> α -> bool
    <tr><td>
    <span class="strong">ideal_coset_mult</span>
    <td>
    :α ring -> α ring -> (α -> bool) -> (α -> bool) -> α -> bool
    <tr><td>
    <span class="strong">ideal_gen</span>
    <td>
    :α ring -> α ring -> (α -> num) -> α
    <tr><td>
    <span class="strong">ideal_maximal</span>
    <td>
    :α ring -> α ring -> bool
    <tr><td>
    <span class="strong">ideal_sum</span>
    <td>
    :α ring -> α ring -> α ring -> α ring
    <tr><td> <span class="strong">irreducible</span> <td> :α ring -> α -> bool
    <tr><td>
    <span class="strong">kernel_ideal</span>
    <td>
    :(α -> β) -> α ring -> β ring -> α ring
    <tr><td>
    <span class="strong">monoid_of_ring_nonzero_mult</span>
    <td>
    :α ring -> α monoid
    <tr><td>
    <span class="strong">principal_ideal</span>
    <td>
    :α ring -> α -> α ring
    <tr><td>
    <span class="strong">quotient_ring</span>
    <td>
    :α ring -> α ring -> (α -> bool) ring
    <tr><td>
    <span class="strong">quotient_ring_add</span>
    <td>
    :α ring -> α ring -> (α -> bool) monoid
    <tr><td>
    <span class="strong">quotient_ring_mult</span>
    <td>
    :α ring -> α ring -> (α -> bool) monoid
    <tr><td>
    <span class="strong">recordtype.ring</span>
    <td>
    :(α -> bool) -> α monoid -> α monoid -> α ring
    <tr><td>
    <span class="strong">recordtype.ring.seldef.carrier</span>
    <td>
    :α ring -> α -> bool
    <tr><td>
    <span class="strong">recordtype.ring.seldef.carrier_fupd</span>
    <td>
    :((α -> bool) -> α -> bool) -> α ring -> α ring
    <tr><td>
    <span class="strong">recordtype.ring.seldef.prod</span>
    <td>
    :α ring -> α monoid
    <tr><td>
    <span class="strong">recordtype.ring.seldef.prod_fupd</span>
    <td>
    :(α monoid -> α monoid) -> α ring -> α ring
    <tr><td>
    <span class="strong">recordtype.ring.seldef.sum</span>
    <td>
    :α ring -> α monoid
    <tr><td>
    <span class="strong">recordtype.ring.seldef.sum_fupd</span>
    <td>
    :(α monoid -> α monoid) -> α ring -> α ring
    <tr><td>
    <span class="strong">ring_CASE</span>
    <td>
    :α ring -> ((α -> bool) -> α monoid -> α monoid -> β) -> β
    <tr><td>
    <span class="strong">ring_associates</span>
    <td>
    :α ring -> α -> α -> bool
    <tr><td>
    <span class="strong">ring_divides</span>
    <td>
    :α ring -> α -> α -> bool
    <tr><td>
    <span class="strong">ring_fun</span>
    <td>
    :α ring -> (β -> α) -> bool
    <tr><td>
    <span class="strong">ring_gcd</span>
    <td>
    :α ring -> (α -> num) -> α -> α -> α
    <tr><td>
    <span class="strong">ring_homo_image</span>
    <td>
    :(α -> β) -> α ring -> β ring -> β ring
    <tr><td>
    <span class="strong">ring_inj_image</span>
    <td>
    :α ring -> (α -> β) -> β ring
    <tr><td>
    <span class="strong">ring_list</span>
    <td>
    :α ring -> α list -> bool
    <tr><td>
    <span class="strong">ring_nonzero</span>
    <td>
    :α ring -> α -> bool
    <tr><td>
    <span class="strong">ring_ordering</span>
    <td>
    :α ring -> (α -> num) -> bool
    <tr><td> <span class="strong">ring_prime</span> <td> :α ring -> α -> bool
    <tr><td>
    <span class="strong">ring_size</span>
    <td>
    :(α -> num) -> α ring -> num
    <tr><td> <span class="strong">ring_sub</span> <td> :α ring -> α -> α -> α
    <tr><td> <span class="strong">ring_sum</span> <td> :α ring -> α list -> α
    <tr><td>
    <span class="strong">subring</span>
    <td>
    :α ring -> α ring -> bool
    <tr><td>
    <span class="strong">symdiff_set_inter</span>
    <td>
    :(α -> bool) ring
    <tr><td>
    <span class="strong">trivial_integal_domain</span>
    <td>
    :α -> α -> α ring
    <tr><td> <span class="strong">trivial_ring</span> <td> :α -> α ring
    <tr><td>
    <span class="strong">unit_eq</span>
    <td>
    :α ring -> α -> α -> bool
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">EuclideanRing_def</span>
<DD>
<pre>
⊢ ∀r f.
    EuclideanRing r f ⇔
    Ring r ∧ (∀x. f x = 0 ⇔ x = #0) ∧
    ∀x y.
      x ∈ R ∧ y ∈ R ∧ y ≠ #0 ⇒ ∃q t. q ∈ R ∧ t ∈ R ∧ x = q * y + t ∧ f t < f y
</pre>

<DT><span class="strong">FiniteIntegralDomain_def</span>
<DD>
<pre>
⊢ ∀r. FiniteIntegralDomain r ⇔ IntegralDomain r ∧ FINITE R
</pre>

<DT><span class="strong">FiniteRing_def</span>
<DD>
<pre>
⊢ ∀r. FiniteRing r ⇔ Ring r ∧ FINITE R
</pre>

<DT><span class="strong">IntegralDomain_def</span>
<DD>
<pre>
⊢ ∀r. IntegralDomain r ⇔
      Ring r ∧ #1 ≠ #0 ∧ ∀x y. x ∈ R ∧ y ∈ R ⇒ (x * y = #0 ⇔ x = #0 ∨ y = #0)
</pre>

<DT><span class="strong">PrincipalIdealRing_def</span>
<DD>
<pre>
⊢ ∀r. PrincipalIdealRing r ⇔ Ring r ∧ ∀i. i << r ⇒ ∃p. p ∈ R ∧ <p> = i
</pre>

<DT><span class="strong">RingAuto_def</span>
<DD>
<pre>
⊢ ∀f r. RingAuto f r ⇔ RingIso f r r
</pre>

<DT><span class="strong">RingEndo_def</span>
<DD>
<pre>
⊢ ∀f r. RingEndo f r ⇔ RingHomo f r r
</pre>

<DT><span class="strong">RingHomo_def</span>
<DD>
<pre>
⊢ ∀f r s.
    RingHomo f r s ⇔
    (∀x. x ∈ R ⇒ f x ∈ s.carrier) ∧ GroupHomo f r.sum s.sum ∧
    MonoidHomo f r.prod s.prod
</pre>

<DT><span class="strong">RingIso_def</span>
<DD>
<pre>
⊢ ∀f r s. RingIso f r s ⇔ RingHomo f r s ∧ BIJ f R s.carrier
</pre>

<DT><span class="strong">Ring_def</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇔
      AbelianGroup r.sum ∧ AbelianMonoid r.prod ∧ r.sum.carrier = R ∧
      r.prod.carrier = R ∧
      ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ x * (y + z) = x * y + x * z
</pre>

<DT><span class="strong">ZN_def</span>
<DD>
<pre>
⊢ ∀n. ZN n = <|carrier := count n; sum := add_mod n; prod := times_mod n|>
</pre>

<DT><span class="strong">ZP_def</span>
<DD>
<pre>
⊢ ∀p. ZP p = <|carrier := count p; sum := add_mod p; prod := times_mod p|>
</pre>

<DT><span class="strong">Z_add_def</span>
<DD>
<pre>
⊢ Z_add = <|carrier := 𝕌(:int); op := (λx y. x + y); id := 0|>
</pre>

<DT><span class="strong">Z_def</span>
<DD>
<pre>
⊢ Z = <|carrier := 𝕌(:int); sum := Z_add; prod := Z_mult|>
</pre>

<DT><span class="strong">Z_ideal_def</span>
<DD>
<pre>
⊢ ∀n. Z* n =
      <|carrier := Z_multiple n;
        sum := <|carrier := Z_multiple n; op := Z.sum.op; id := Z.sum.id|>;
        prod := <|carrier := Z_multiple n; op := Z.prod.op; id := Z.prod.id|> |>
</pre>

<DT><span class="strong">Z_mult_def</span>
<DD>
<pre>
⊢ Z_mult = <|carrier := 𝕌(:int); op := (λx y. x * y); id := 1|>
</pre>

<DT><span class="strong">Z_multiple_def</span>
<DD>
<pre>
⊢ ∀n. Z_multiple n = {&n * z | z ∈ 𝕌(:int)}
</pre>

<DT><span class="strong">char_def</span>
<DD>
<pre>
⊢ ∀r. char r = order r.sum #1
</pre>

<DT><span class="strong">compute_ordz_def</span>
<DD>
<pre>
⊢ ∀m n.
    compute_ordz m n =
    if m = 0 then ordz 0 n
    else if m = 1 then 1
    else if coprime m n then WHILE (λi. n ** i MOD m ≠ 1) SUC 1
    else 0
</pre>

<DT><span class="strong">homo_ideal_def</span>
<DD>
<pre>
⊢ ∀f r s i.
    homo_ideal f r s i =
    <|carrier := IMAGE f i.carrier;
      sum := <|carrier := IMAGE f i.carrier; op := s.sum.op; id := f #0|>;
      prod := <|carrier := IMAGE f i.carrier; op := s.prod.op; id := f #1|> |>
</pre>

<DT><span class="strong">homo_ring_def</span>
<DD>
<pre>
⊢ ∀r f.
    homo_ring r f =
    <|carrier := IMAGE f R; sum := homo_group r.sum f;
      prod := homo_group r.prod f|>
</pre>

<DT><span class="strong">ideal_congruence_def</span>
<DD>
<pre>
⊢ ∀r i x y. x === y ⇔ x − y ∈ i.carrier
</pre>

<DT><span class="strong">ideal_coset_add_def</span>
<DD>
<pre>
⊢ ∀r i x y. x + y = (gen x + gen y) ∘ i.carrier
</pre>

<DT><span class="strong">ideal_coset_mult_def</span>
<DD>
<pre>
⊢ ∀r i x y. x * y = (gen x * gen y) ∘ i.carrier
</pre>

<DT><span class="strong">ideal_def</span>
<DD>
<pre>
⊢ ∀i r.
    i << r ⇔
    i.sum ≤ r.sum ∧ i.sum.carrier = i.carrier ∧ i.prod.carrier = i.carrier ∧
    i.prod.op = $* ∧ i.prod.id = #1 ∧
    ∀x y. x ∈ i.carrier ∧ y ∈ R ⇒ x * y ∈ i.carrier ∧ y * x ∈ i.carrier
</pre>

<DT><span class="strong">ideal_gen_def</span>
<DD>
<pre>
⊢ ∀r i f.
    Ring r ∧ i << r ∧ i ≠ <#0> ∧ (∀x. f x = 0 ⇔ x = #0) ⇒
    ideal_gen r i f ∈ i.carrier ∧ ideal_gen r i f ≠ #0 ∧
    ∀z. z ∈ i.carrier ∧ z ≠ #0 ⇒ f (ideal_gen r i f) ≤ f z
</pre>

<DT><span class="strong">ideal_maximal_def</span>
<DD>
<pre>
⊢ ∀r i. maxi i ⇔ i << r ∧ ∀j. i << j ∧ j << r ⇒ i = j ∨ j = r
</pre>

<DT><span class="strong">ideal_sum_def</span>
<DD>
<pre>
⊢ ∀r i j.
    i + j =
    <|carrier := {x + y | x ∈ i.carrier ∧ y ∈ j.carrier};
      sum :=
        <|carrier := {x + y | x ∈ i.carrier ∧ y ∈ j.carrier}; op := $+;
          id := #0|>;
      prod :=
        <|carrier := {x + y | x ∈ i.carrier ∧ y ∈ j.carrier}; op := $*;
          id := #1|> |>
</pre>

<DT><span class="strong">irreducible_def</span>
<DD>
<pre>
⊢ ∀r z.
    atom z ⇔
    z ∈ R+ ∧ z ∉ R* ∧ ∀x y. x ∈ R ∧ y ∈ R ∧ z = x * y ⇒ unit x ∨ unit y
</pre>

<DT><span class="strong">kernel_ideal_def</span>
<DD>
<pre>
⊢ ∀f r s.
    kernel_ideal f r s =
    <|carrier := kernel f r.sum s.sum;
      sum := <|carrier := kernel f r.sum s.sum; op := $+; id := #0|>;
      prod := <|carrier := kernel f r.sum s.sum; op := $*; id := #1|> |>
</pre>

<DT><span class="strong">monoid_of_ring_nonzero_mult_def</span>
<DD>
<pre>
⊢ ∀r. monoid_of_ring_nonzero_mult r = <|carrier := R+; op := $*; id := #1|>
</pre>

<DT><span class="strong">principal_ideal_def</span>
<DD>
<pre>
⊢ ∀r p.
    <p> =
    <|carrier := p * R; sum := <|carrier := p * R; op := $+; id := #0|>;
      prod := <|carrier := p * R; op := $*; id := #1|> |>
</pre>

<DT><span class="strong">quotient_ring_add_def</span>
<DD>
<pre>
⊢ ∀r i. quotient_ring_add r i = <|carrier := R/I; id := i.carrier; op := $+ |>
</pre>

<DT><span class="strong">quotient_ring_def</span>
<DD>
<pre>
⊢ ∀r i.
    r / i =
    <|carrier := R/I; sum := quotient_ring_add r i;
      prod := quotient_ring_mult r i|>
</pre>

<DT><span class="strong">quotient_ring_mult_def</span>
<DD>
<pre>
⊢ ∀r i.
    quotient_ring_mult r i =
    <|carrier := R/I; id := #1 ∘ i.carrier; op := $* |>
</pre>

<DT><span class="strong">recordtype_ring_seldef_carrier_def</span>
<DD>
<pre>
⊢ ∀f m m0. (ring f m m0).carrier = f
</pre>

<DT><span class="strong">recordtype_ring_seldef_carrier_fupd_def</span>
<DD>
<pre>
⊢ ∀f0 f m m0. ring f m m0 with carrier updated_by f0 = ring (f0 f) m m0
</pre>

<DT><span class="strong">recordtype_ring_seldef_prod_def</span>
<DD>
<pre>
⊢ ∀f m m0. (ring f m m0).prod = m0
</pre>

<DT><span class="strong">recordtype_ring_seldef_prod_fupd_def</span>
<DD>
<pre>
⊢ ∀f0 f m m0. ring f m m0 with prod updated_by f0 = ring f m (f0 m0)
</pre>

<DT><span class="strong">recordtype_ring_seldef_sum_def</span>
<DD>
<pre>
⊢ ∀f m m0. (ring f m m0).sum = m
</pre>

<DT><span class="strong">recordtype_ring_seldef_sum_fupd_def</span>
<DD>
<pre>
⊢ ∀f0 f m m0. ring f m m0 with sum updated_by f0 = ring f (f0 m) m0
</pre>

<DT><span class="strong">ring_TY_DEF</span>
<DD>
<pre>
⊢ ∃rep.
    TYPE_DEFINITION
      (λa0'.
           ∀ $var$('ring').
             (∀a0'.
                (∃a0 a1 a2.
                   a0' =
                   (λa0 a1 a2.
                        ind_type$CONSTR 0 (a0,a1,a2) (λn. ind_type$BOTTOM)) a0
                     a1 a2) ⇒
                $var$('ring') a0') ⇒
             $var$('ring') a0') rep
</pre>

<DT><span class="strong">ring_associates_def</span>
<DD>
<pre>
⊢ ∀r p q. rassoc p q ⇔ ∃s. unit s ∧ p = s * q
</pre>

<DT><span class="strong">ring_case_def</span>
<DD>
<pre>
⊢ ∀a0 a1 a2 f. ring_CASE (ring a0 a1 a2) f = f a0 a1 a2
</pre>

<DT><span class="strong">ring_divides_def</span>
<DD>
<pre>
⊢ ∀r q p. q rdivides p ⇔ ∃s. s ∈ R ∧ p = s * q
</pre>

<DT><span class="strong">ring_fun_def</span>
<DD>
<pre>
⊢ ∀r f. rfun f ⇔ ∀x. f x ∈ R
</pre>

<DT><span class="strong">ring_gcd_def</span>
<DD>
<pre>
⊢ ∀r f p q.
    rgcd p q =
    if p = #0 then q
    else if q = #0 then p
    else
      (let
         s = {a * p + b * q | (a,b) | a ∈ R ∧ b ∈ R ∧ 0 < f (a * p + b * q)}
       in
         CHOICE (preimage f s (MIN_SET (IMAGE f s))))
</pre>

<DT><span class="strong">ring_homo_image_def</span>
<DD>
<pre>
⊢ ∀f r r_.
    ring_homo_image f r r_ =
    <|carrier := IMAGE f R; sum := homo_image f r.sum r_.sum;
      prod := homo_image f r.prod r_.prod|>
</pre>

<DT><span class="strong">ring_inj_image_def</span>
<DD>
<pre>
⊢ ∀r f.
    ring_inj_image r f =
    <|carrier := IMAGE f R;
      sum :=
        <|carrier := IMAGE f R; op := (λx y. f (LINV f R x + LINV f R y));
          id := f #0|>;
      prod :=
        <|carrier := IMAGE f R; op := (λx y. f (LINV f R x * LINV f R y));
          id := f #1|> |>
</pre>

<DT><span class="strong">ring_list_def</span>
<DD>
<pre>
⊢ (∀r. rlist [] ⇔ T) ∧ ∀r h t. rlist (h::t) ⇔ h ∈ R ∧ rlist t
</pre>

<DT><span class="strong">ring_nonzero_def</span>
<DD>
<pre>
⊢ ∀r. R+ = R DIFF {#0}
</pre>

<DT><span class="strong">ring_ordering_def</span>
<DD>
<pre>
⊢ ∀r f. ring_ordering r f ⇔ ∀a b. a ∈ R ∧ b ∈ R ∧ b ≠ #0 ⇒ f a ≤ f (a * b)
</pre>

<DT><span class="strong">ring_prime_def</span>
<DD>
<pre>
⊢ ∀r p.
    rprime p ⇔
    ∀a b. a ∈ R ∧ b ∈ R ∧ p rdivides a * b ⇒ p rdivides a ∨ p rdivides b
</pre>

<DT><span class="strong">ring_size_def</span>
<DD>
<pre>
⊢ ∀f a0 a1 a2.
    ring_size f (ring a0 a1 a2) = 1 + (monoid_size f a1 + monoid_size f a2)
</pre>

<DT><span class="strong">ring_sub_def</span>
<DD>
<pre>
⊢ ∀r x y. x − y = x + -y
</pre>

<DT><span class="strong">ring_sum_def</span>
<DD>
<pre>
⊢ (∀r. rsum [] = #0) ∧ ∀r h t. rsum (h::t) = h + rsum t
</pre>

<DT><span class="strong">subring_def</span>
<DD>
<pre>
⊢ ∀s r. subring s r ⇔ RingHomo I s r
</pre>

<DT><span class="strong">symdiff_set_inter_def</span>
<DD>
<pre>
⊢ symdiff_set_inter =
  <|carrier := 𝕌(:α -> bool); sum := symdiff_set; prod := set_inter|>
</pre>

<DT><span class="strong">trivial_integal_domain_def</span>
<DD>
<pre>
⊢ ∀e0 e1.
    trivial_integal_domain e0 e1 =
    <|carrier := {e0; e1};
      sum :=
        <|carrier := {e0; e1}; id := e0;
          op := (λx y. if x = e0 then y else if y = e0 then x else e0)|>;
      prod :=
        <|carrier := {e0; e1}; id := e1;
          op := (λx y. if x = e0 then e0 else if y = e0 then e0 else e1)|> |>
</pre>

<DT><span class="strong">trivial_ring_def</span>
<DD>
<pre>
⊢ ∀z. trivial_ring z =
      <|carrier := {z}; sum := <|carrier := {z}; id := z; op := (λx y. z)|>;
        prod := <|carrier := {z}; id := z; op := (λx y. z)|> |>
</pre>

<DT><span class="strong">unit_eq_def</span>
<DD>
<pre>
⊢ ∀r x y. x =~ y ⇔ ∃u. unit u ∧ x = u * y
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">EXISTS_ring</span>
<DD>
<pre>
⊢ ∀P. (∃r. P r) ⇔ ∃f m0 m. P <|carrier := f; sum := m0; prod := m|>
</pre>

<DT><span class="strong">FORALL_ring</span>
<DD>
<pre>
⊢ ∀P. (∀r. P r) ⇔ ∀f m0 m. P <|carrier := f; sum := m0; prod := m|>
</pre>

<DT><span class="strong">LIST_REL_ring_associates_product</span>
<DD>
<pre>
⊢ Ring r ⇒
  ∀l1 l2.
    LIST_REL rassoc l1 l2 ∧ LIST_TO_SET l2 ⊆ R ⇒
    rassoc (GBAG r.prod (LIST_TO_BAG l1)) (GBAG r.prod (LIST_TO_BAG l2))
</pre>

<DT><span class="strong">WHILE_RULE_PRE_POST</span>
<DD>
<pre>
⊢ (∀x. Invariant x ∧ Guard x ⇒ f (Cmd x) < f x) ∧
  (∀x. Precond x ⇒ Invariant x) ∧ (∀x. Invariant x ∧ ¬Guard x ⇒ Postcond x) ∧
  HOARE_SPEC (λx. Invariant x ∧ Guard x) Cmd Invariant ⇒
  HOARE_SPEC Precond (WHILE Guard Cmd) Postcond
</pre>

<DT><span class="strong">ZN_1_exp</span>
<DD>
<pre>
⊢ ∀n k. (ZN 1).prod.exp n k = 0
</pre>

<DT><span class="strong">ZN_card</span>
<DD>
<pre>
⊢ ∀n. CARD (ZN n).carrier = n
</pre>

<DT><span class="strong">ZN_char</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ char (ZN n) = n
</pre>

<DT><span class="strong">ZN_coprime_euler_element</span>
<DD>
<pre>
⊢ ∀m n. 1 < m ∧ coprime m n ⇒ n MOD m ∈ Euler m
</pre>

<DT><span class="strong">ZN_coprime_exp_mod</span>
<DD>
<pre>
⊢ ∀m n. 0 < m ∧ coprime m n ⇒ ∀k. n ** k MOD m = n ** (k MOD ordz m n) MOD m
</pre>

<DT><span class="strong">ZN_coprime_invertible</span>
<DD>
<pre>
⊢ ∀m n. 1 < m ∧ coprime m n ⇒ Unit (ZN m) (n MOD m)
</pre>

<DT><span class="strong">ZN_coprime_order</span>
<DD>
<pre>
⊢ ∀m n. 0 < m ∧ coprime m n ⇒ 0 < ordz m n ∧ n ** ordz m n MOD m = 1 MOD m
</pre>

<DT><span class="strong">ZN_coprime_order_alt</span>
<DD>
<pre>
⊢ ∀m n. 1 < m ∧ coprime m n ⇒ 0 < ordz m n ∧ n ** ordz m n MOD m = 1
</pre>

<DT><span class="strong">ZN_coprime_order_divides_phi</span>
<DD>
<pre>
⊢ ∀m n. 0 < m ∧ coprime m n ⇒ ordz m n divides phi m
</pre>

<DT><span class="strong">ZN_coprime_order_divides_totient</span>
<DD>
<pre>
⊢ ∀m n. 0 < m ∧ coprime m n ⇒ ordz m n divides totient m
</pre>

<DT><span class="strong">ZN_coprime_order_gt_1</span>
<DD>
<pre>
⊢ ∀m n. 1 < m ∧ 1 < n MOD m ∧ coprime m n ⇒ 1 < ordz m n
</pre>

<DT><span class="strong">ZN_coprime_order_lt</span>
<DD>
<pre>
⊢ ∀m n. 1 < m ∧ coprime m n ⇒ ordz m n < m
</pre>

<DT><span class="strong">ZN_eval</span>
<DD>
<pre>
⊢ ∀n. (ZN n).carrier = count n ∧ (ZN n).sum = add_mod n ∧
      (ZN n).prod = times_mod n
</pre>

<DT><span class="strong">ZN_exp</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ ∀x k. (ZN n).prod.exp x k = x ** k MOD n
</pre>

<DT><span class="strong">ZN_finite</span>
<DD>
<pre>
⊢ ∀n. FINITE (ZN n).carrier
</pre>

<DT><span class="strong">ZN_finite_ring</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ FiniteRing (ZN n)
</pre>

<DT><span class="strong">ZN_ids</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ (ZN n).sum.id = 0 ∧ (ZN n).prod.id = 1 MOD n
</pre>

<DT><span class="strong">ZN_ids_alt</span>
<DD>
<pre>
⊢ ∀n. 1 < n ⇒ (ZN n).sum.id = 0 ∧ (ZN n).prod.id = 1
</pre>

<DT><span class="strong">ZN_invertibles</span>
<DD>
<pre>
⊢ ∀n. 1 < n ⇒ Invertibles (ZN n).prod = Estar n
</pre>

<DT><span class="strong">ZN_invertibles_finite_group</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ FiniteGroup (Invertibles (ZN n).prod)
</pre>

<DT><span class="strong">ZN_invertibles_group</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ Group (Invertibles (ZN n).prod)
</pre>

<DT><span class="strong">ZN_invertibles_order</span>
<DD>
<pre>
⊢ ∀m n. 0 < m ⇒ order (Invertibles (ZN m).prod) (n MOD m) = ordz m n
</pre>

<DT><span class="strong">ZN_mult_inv_coprime</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ ∀x y. (x * y) MOD n = 1 ⇒ coprime x n
</pre>

<DT><span class="strong">ZN_mult_inv_coprime_iff</span>
<DD>
<pre>
⊢ ∀n. 1 < n ⇒ ∀x. coprime x n ⇔ ∃y. (x * y) MOD n = 1
</pre>

<DT><span class="strong">ZN_not_coprime</span>
<DD>
<pre>
⊢ ∀m n. 0 < m ∧ gcd m n ≠ 1 ⇒ ∀k. 0 < k ⇒ n ** k MOD m ≠ 1
</pre>

<DT><span class="strong">ZN_num</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ ∀k. (ZN n).sum.exp 1 k = k MOD n
</pre>

<DT><span class="strong">ZN_num_0</span>
<DD>
<pre>
⊢ ∀n c. 0 < n ⇒ (ZN n).sum.exp 0 c = 0
</pre>

<DT><span class="strong">ZN_num_1</span>
<DD>
<pre>
⊢ ∀n. (ZN n).sum.exp (ZN n).prod.id 1 = 1 MOD n
</pre>

<DT><span class="strong">ZN_num_mod</span>
<DD>
<pre>
⊢ ∀n c. 0 < n ⇒ (ZN n).sum.exp (ZN n).prod.id c = c MOD n
</pre>

<DT><span class="strong">ZN_order_0</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ ordz n 0 = if n = 1 then 1 else 0
</pre>

<DT><span class="strong">ZN_order_1</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ ordz n 1 = 1
</pre>

<DT><span class="strong">ZN_order_divides_exp</span>
<DD>
<pre>
⊢ ∀m n k. 1 < m ∧ 0 < k ⇒ (n ** k MOD m = 1 ⇔ ordz m n divides k)
</pre>

<DT><span class="strong">ZN_order_divides_phi</span>
<DD>
<pre>
⊢ ∀m n. 0 < m ∧ 0 < ordz m n ⇒ ordz m n divides phi m
</pre>

<DT><span class="strong">ZN_order_divides_tops_index</span>
<DD>
<pre>
⊢ ∀n j k. 1 < n ∧ 0 < j ∧ 1 < k ⇒ (k divides tops n j ⇔ ordz k n divides j)
</pre>

<DT><span class="strong">ZN_order_divisibility</span>
<DD>
<pre>
⊢ ∀m n. 0 < m ⇒ m divides tops n (ordz m n)
</pre>

<DT><span class="strong">ZN_order_eq_0</span>
<DD>
<pre>
⊢ ∀m n. 0 < m ⇒ (ordz m n = 0 ⇔ gcd m n ≠ 1)
</pre>

<DT><span class="strong">ZN_order_eq_0_iff</span>
<DD>
<pre>
⊢ ∀m n. 1 < m ⇒ (ordz m n = 0 ⇔ ∀k. 0 < k ⇒ n ** k MOD m ≠ 1)
</pre>

<DT><span class="strong">ZN_order_eq_0_test</span>
<DD>
<pre>
⊢ ∀m n. 1 < m ⇒ (ordz m n = 0 ⇔ ∀j. 0 < j ∧ j < m ⇒ n ** j MOD m ≠ 1)
</pre>

<DT><span class="strong">ZN_order_eq_1</span>
<DD>
<pre>
⊢ ∀m n. 0 < m ⇒ (ordz m n = 1 ⇔ n MOD m = 1 MOD m)
</pre>

<DT><span class="strong">ZN_order_eq_1_alt</span>
<DD>
<pre>
⊢ ∀m n. 1 < m ⇒ (ordz m n = 1 ⇔ n MOD m = 1)
</pre>

<DT><span class="strong">ZN_order_eq_1_by_prime_factors</span>
<DD>
<pre>
⊢ ∀m n.
    0 < m ∧ coprime m n ∧ (∀p. prime p ∧ p divides n ⇒ ordz m p = 1) ⇒
    ordz m n = 1
</pre>

<DT><span class="strong">ZN_order_gt_1_property</span>
<DD>
<pre>
⊢ ∀m n. 0 < m ∧ 1 < ordz m n ⇒ ∃p. prime p ∧ p divides n ∧ 1 < ordz m p
</pre>

<DT><span class="strong">ZN_order_le</span>
<DD>
<pre>
⊢ ∀m n. 0 < m ⇒ ordz m n ≤ m
</pre>

<DT><span class="strong">ZN_order_le_tops_index</span>
<DD>
<pre>
⊢ ∀n j k. 1 < n ∧ 0 < j ∧ 1 < k ∧ k divides tops n j ⇒ ordz k n ≤ j
</pre>

<DT><span class="strong">ZN_order_lt</span>
<DD>
<pre>
⊢ ∀k n m. 0 < k ∧ k < m ⇒ ordz k n < m
</pre>

<DT><span class="strong">ZN_order_minimal</span>
<DD>
<pre>
⊢ ∀m n k. 0 < m ∧ 0 < k ∧ k < ordz m n ⇒ n ** k MOD m ≠ 1
</pre>

<DT><span class="strong">ZN_order_mod</span>
<DD>
<pre>
⊢ ∀m n. 0 < m ⇒ ordz m (n MOD m) = ordz m n
</pre>

<DT><span class="strong">ZN_order_mod_1</span>
<DD>
<pre>
⊢ ∀n. ordz 1 n = 1
</pre>

<DT><span class="strong">ZN_order_nonzero</span>
<DD>
<pre>
⊢ ∀m n. 0 < m ⇒ (ordz m n ≠ 0 ⇔ coprime m n)
</pre>

<DT><span class="strong">ZN_order_nonzero_iff</span>
<DD>
<pre>
⊢ ∀m n. 1 < m ⇒ (ordz m n ≠ 0 ⇔ ∃k. 0 < k ∧ n ** k MOD m = 1)
</pre>

<DT><span class="strong">ZN_order_property</span>
<DD>
<pre>
⊢ ∀m n. 0 < m ⇒ n ** ordz m n MOD m = 1 MOD m
</pre>

<DT><span class="strong">ZN_order_property_alt</span>
<DD>
<pre>
⊢ ∀m n. 1 < m ⇒ n ** ordz m n MOD m = 1
</pre>

<DT><span class="strong">ZN_order_test_1</span>
<DD>
<pre>
⊢ ∀m n k.
    1 < m ∧ 0 < k ⇒
    (ordz m n = k ⇔ n ** k MOD m = 1 ∧ ∀j. 0 < j ∧ j < k ⇒ n ** j MOD m ≠ 1)
</pre>

<DT><span class="strong">ZN_order_test_2</span>
<DD>
<pre>
⊢ ∀m n k.
    1 < m ∧ 0 < k ⇒
    (ordz m n = k ⇔
     n ** k MOD m = 1 ∧ ∀j. 0 < j ∧ j < k ∧ j divides phi m ⇒ n ** j MOD m ≠ 1)
</pre>

<DT><span class="strong">ZN_order_test_3</span>
<DD>
<pre>
⊢ ∀m n k.
    1 < m ∧ 0 < k ⇒
    (ordz m n = k ⇔
     k divides phi m ∧ n ** k MOD m = 1 ∧
     ∀j. 0 < j ∧ j < k ∧ j divides phi m ⇒ n ** j MOD m ≠ 1)
</pre>

<DT><span class="strong">ZN_order_test_4</span>
<DD>
<pre>
⊢ ∀m n k.
    1 < m ⇒
    (ordz m n = k ⇔
     n ** k MOD m = 1 ∧
     ∀j. 0 < j ∧ j < (if k = 0 then m else k) ⇒ n ** j MOD m ≠ 1)
</pre>

<DT><span class="strong">ZN_order_test_propery</span>
<DD>
<pre>
⊢ ∀m n k.
    1 < m ∧ 0 < k ∧ n ** k MOD m = 1 ∧
    (∀j. 0 < j ∧ j < k ∧ j divides phi m ⇒ n ** j MOD m ≠ 1) ⇒
    ∀j. 0 < j ∧ j < k ∧ ¬(j divides phi m) ⇒ ordz m n = k ∨ n ** j MOD m ≠ 1
</pre>

<DT><span class="strong">ZN_order_upper</span>
<DD>
<pre>
⊢ ∀m n. 0 < m ⇒ ordz m n ≤ phi m
</pre>

<DT><span class="strong">ZN_order_with_coprime_1</span>
<DD>
<pre>
⊢ ∀m n. 1 < n ∧ coprime m n ∧ 1 < ordz m n ⇒ 1 < m
</pre>

<DT><span class="strong">ZN_order_with_coprime_2</span>
<DD>
<pre>
⊢ ∀m n k. 1 < m ∧ m divides n ∧ 1 < ordz k m ∧ coprime k n ⇒ 1 < n ∧ 1 < k
</pre>

<DT><span class="strong">ZN_property</span>
<DD>
<pre>
⊢ ∀n. (∀x. x ∈ (ZN n).carrier ⇔ x < n) ∧ (ZN n).sum.id = 0 ∧
      (ZN n).prod.id = (if n = 1 then 0 else 1) ∧
      (∀x y. (ZN n).sum.op x y = (x + y) MOD n) ∧
      (∀x y. (ZN n).prod.op x y = (x * y) MOD n) ∧ FINITE (ZN n).carrier ∧
      CARD (ZN n).carrier = n
</pre>

<DT><span class="strong">ZN_ring</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ Ring (ZN n)
</pre>

<DT><span class="strong">ZN_to_ZN_element</span>
<DD>
<pre>
⊢ ∀n m x. 0 < m ∧ x ∈ (ZN n).carrier ⇒ x MOD m ∈ (ZN m).carrier
</pre>

<DT><span class="strong">ZN_to_ZN_prod_monoid_homo</span>
<DD>
<pre>
⊢ ∀n m. 0 < n ∧ m divides n ⇒ MonoidHomo (λx. x MOD m) (ZN n).prod (ZN m).prod
</pre>

<DT><span class="strong">ZN_to_ZN_ring_homo</span>
<DD>
<pre>
⊢ ∀n m. 0 < n ∧ m divides n ⇒ RingHomo (λx. x MOD m) (ZN n) (ZN m)
</pre>

<DT><span class="strong">ZN_to_ZN_sum_group_homo</span>
<DD>
<pre>
⊢ ∀n m. 0 < n ∧ m divides n ⇒ GroupHomo (λx. x MOD m) (ZN n).sum (ZN m).sum
</pre>

<DT><span class="strong">ZP_finite</span>
<DD>
<pre>
⊢ ∀p. FINITE (ZP p).carrier
</pre>

<DT><span class="strong">ZP_finite_integral_domain</span>
<DD>
<pre>
⊢ ∀p. prime p ⇒ FiniteIntegralDomain (ZP p)
</pre>

<DT><span class="strong">ZP_integral_domain</span>
<DD>
<pre>
⊢ ∀p. prime p ⇒ IntegralDomain (ZP p)
</pre>

<DT><span class="strong">Z_add_abelian_group</span>
<DD>
<pre>
⊢ AbelianGroup Z_add
</pre>

<DT><span class="strong">Z_add_group</span>
<DD>
<pre>
⊢ Group Z_add
</pre>

<DT><span class="strong">Z_add_inv</span>
<DD>
<pre>
⊢ ∀z. z ∈ Z_add.carrier ⇒ Z_add.inv z = -z
</pre>

<DT><span class="strong">Z_euclid_ring</span>
<DD>
<pre>
⊢ EuclideanRing Z Num
</pre>

<DT><span class="strong">Z_ideal_map_bij</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒
      BIJ (λj. coset Z.sum (&j) (Z* n).sum.carrier) (ZN n).carrier
        (Z / Z* n).carrier
</pre>

<DT><span class="strong">Z_ideal_map_element</span>
<DD>
<pre>
⊢ ∀n j.
    0 < n ∧ j ∈ (ZN n).carrier ⇒
    coset Z.sum (&j) (Z* n).sum.carrier ∈ (Z / Z* n).carrier
</pre>

<DT><span class="strong">Z_ideal_map_group_homo</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒
      GroupHomo (λj. coset Z.sum (&j) (Z* n).sum.carrier) (ZN n).sum
        (Z / Z* n).sum
</pre>

<DT><span class="strong">Z_ideal_map_monoid_homo</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒
      MonoidHomo (λj. coset Z.sum (&j) (Z* n).sum.carrier) (ZN n).prod
        (Z / Z* n).prod
</pre>

<DT><span class="strong">Z_ideal_sum_group</span>
<DD>
<pre>
⊢ ∀n. Group (Z* n).sum
</pre>

<DT><span class="strong">Z_ideal_sum_normal</span>
<DD>
<pre>
⊢ ∀n. (Z* n).sum << Z.sum
</pre>

<DT><span class="strong">Z_ideal_sum_subgroup</span>
<DD>
<pre>
⊢ ∀n. (Z* n).sum ≤ Z.sum
</pre>

<DT><span class="strong">Z_ideal_thm</span>
<DD>
<pre>
⊢ ∀n. Z* n << Z
</pre>

<DT><span class="strong">Z_mult_abelian_monoid</span>
<DD>
<pre>
⊢ AbelianMonoid Z_mult
</pre>

<DT><span class="strong">Z_mult_monoid</span>
<DD>
<pre>
⊢ Monoid Z_mult
</pre>

<DT><span class="strong">Z_multiple_less_neg_eq</span>
<DD>
<pre>
⊢ ∀n x y. 0 < n ∧ x < n ∧ y < n ∧ -&x + &y ∈ Z_multiple n ⇒ x = y
</pre>

<DT><span class="strong">Z_principal_ideal_ring</span>
<DD>
<pre>
⊢ PrincipalIdealRing Z
</pre>

<DT><span class="strong">Z_quotient_iso_ZN</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒
      RingIso (λj. coset Z.sum (&j) (Z* n).sum.carrier) (ZN n) (Z / Z* n)
</pre>

<DT><span class="strong">Z_ring</span>
<DD>
<pre>
⊢ Ring Z
</pre>

<DT><span class="strong">Z_sum_cogen</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒
      ∀x. x ∈ Z.sum.carrier ⇒
          ∃y. cogen Z.sum (Z* n).sum (coset Z.sum x (Z* n).sum.carrier) =
              x + &n * y
</pre>

<DT><span class="strong">Z_sum_coset_eq</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒
      ∀p. coset Z.sum p (Z* n).sum.carrier =
          coset Z.sum (p % &n) (Z* n).sum.carrier
</pre>

<DT><span class="strong">char_eq_0</span>
<DD>
<pre>
⊢ ∀r. char r = 0 ⇔ ∀n. 0 < n ⇒ $## n ≠ #0
</pre>

<DT><span class="strong">char_minimal</span>
<DD>
<pre>
⊢ ∀r. 0 < char r ⇒ ∀n. 0 < n ∧ n < char r ⇒ $## n ≠ #0
</pre>

<DT><span class="strong">char_property</span>
<DD>
<pre>
⊢ ∀r. $## (char r) = #0
</pre>

<DT><span class="strong">compute_ordz_0</span>
<DD>
<pre>
⊢ ∀n. compute_ordz 0 n = ordz 0 n
</pre>

<DT><span class="strong">compute_ordz_1</span>
<DD>
<pre>
⊢ ∀n. compute_ordz 1 n = 1
</pre>

<DT><span class="strong">compute_ordz_eqn</span>
<DD>
<pre>
⊢ ∀m n. compute_ordz m n = ordz m n
</pre>

<DT><span class="strong">compute_ordz_hoare</span>
<DD>
<pre>
⊢ ∀m n.
    1 < m ∧ coprime m n ⇒
    HOARE_SPEC (λi. 0 < i ∧ i ≤ ordz m n) (WHILE (λi. n ** i MOD m ≠ 1) SUC)
      (λi. i = ordz m n)
</pre>

<DT><span class="strong">datatype_ring</span>
<DD>
<pre>
⊢ DATATYPE (record ring carrier sum prod)
</pre>

<DT><span class="strong">euclid_ring_map</span>
<DD>
<pre>
⊢ ∀r f. EuclideanRing r f ⇒ ∀x. f x = 0 ⇔ x = #0
</pre>

<DT><span class="strong">euclid_ring_principal_ideal_ring</span>
<DD>
<pre>
⊢ ∀r f. EuclideanRing r f ⇒ PrincipalIdealRing r
</pre>

<DT><span class="strong">euclid_ring_property</span>
<DD>
<pre>
⊢ ∀r f.
    EuclideanRing r f ⇒
    ∀x y.
      x ∈ R ∧ y ∈ R ∧ y ≠ #0 ⇒ ∃q t. q ∈ R ∧ t ∈ R ∧ x = q * y + t ∧ f t < f y
</pre>

<DT><span class="strong">euclid_ring_ring</span>
<DD>
<pre>
⊢ ∀r f. EuclideanRing r f ⇒ Ring r
</pre>

<DT><span class="strong">finite_integral_domain_nonzero_group</span>
<DD>
<pre>
⊢ ∀r. FiniteIntegralDomain r ⇒ Group f*
</pre>

<DT><span class="strong">finite_integral_domain_nonzero_invertible</span>
<DD>
<pre>
⊢ ∀r. FiniteIntegralDomain r ⇒ monoid_invertibles r.prod = R+
</pre>

<DT><span class="strong">finite_integral_domain_nonzero_invertible_alt</span>
<DD>
<pre>
⊢ ∀r. FiniteIntegralDomain r ⇒ monoid_invertibles f* = F*
</pre>

<DT><span class="strong">finite_integral_domain_period_exists</span>
<DD>
<pre>
⊢ ∀r. FiniteIntegralDomain r ⇒ ∀x. x ∈ R+ ⇒ ∃k. 0 < k ∧ x ** k = #1
</pre>

<DT><span class="strong">finite_ring_add_finite_abelian_group</span>
<DD>
<pre>
⊢ ∀r. FiniteRing r ⇒ FiniteAbelianGroup r.sum ∧ r.sum.carrier = R
</pre>

<DT><span class="strong">finite_ring_add_finite_group</span>
<DD>
<pre>
⊢ ∀r. FiniteRing r ⇒ FiniteGroup r.sum ∧ r.sum.carrier = R
</pre>

<DT><span class="strong">finite_ring_card_eq_1</span>
<DD>
<pre>
⊢ ∀r. FiniteRing r ⇒ (CARD R = 1 ⇔ #1 = #0)
</pre>

<DT><span class="strong">finite_ring_card_pos</span>
<DD>
<pre>
⊢ ∀r. FiniteRing r ⇒ 0 < CARD R
</pre>

<DT><span class="strong">finite_ring_card_prime</span>
<DD>
<pre>
⊢ ∀r. FiniteRing r ∧ prime (CARD R) ⇒ char r = CARD R
</pre>

<DT><span class="strong">finite_ring_char</span>
<DD>
<pre>
⊢ ∀r. FiniteRing r ⇒ 0 < char r ∧ char r = order r.sum #1
</pre>

<DT><span class="strong">finite_ring_char_alt</span>
<DD>
<pre>
⊢ ∀r. FiniteRing r ⇒
      ∀n. char r = n ⇔ 0 < n ∧ $## n = #0 ∧ ∀m. 0 < m ∧ m < n ⇒ $## m ≠ #0
</pre>

<DT><span class="strong">finite_ring_char_divides</span>
<DD>
<pre>
⊢ ∀r. FiniteRing r ⇒ char r divides CARD R
</pre>

<DT><span class="strong">finite_ring_char_pos</span>
<DD>
<pre>
⊢ ∀r. FiniteRing r ⇒ 0 < char r
</pre>

<DT><span class="strong">finite_ring_is_ring</span>
<DD>
<pre>
⊢ ∀r. FiniteRing r ⇒ Ring r
</pre>

<DT><span class="strong">finite_ring_mult_finite_abelian_monoid</span>
<DD>
<pre>
⊢ ∀r. FiniteRing r ⇒ FiniteAbelianMonoid r.prod
</pre>

<DT><span class="strong">finite_ring_mult_finite_monoid</span>
<DD>
<pre>
⊢ ∀r. FiniteRing r ⇒ FiniteMonoid r.prod
</pre>

<DT><span class="strong">homo_ring_by_inj</span>
<DD>
<pre>
⊢ ∀r f. Ring r ∧ INJ f R 𝕌(:β) ⇒ RingHomo f r (homo_ring r f)
</pre>

<DT><span class="strong">homo_ring_property</span>
<DD>
<pre>
⊢ ∀r f.
    fR = IMAGE f R ∧ (homo_ring r f).sum = homo_group r.sum f ∧
    (homo_ring r f).prod = homo_group r.prod f
</pre>

<DT><span class="strong">homo_ring_ring</span>
<DD>
<pre>
⊢ ∀r f. Ring r ∧ RingHomo f r (homo_ring r f) ⇒ Ring (homo_ring r f)
</pre>

<DT><span class="strong">homo_ring_subring</span>
<DD>
<pre>
⊢ ∀r s f. (r ~r~ s) f ⇒ subring (homo_ring r f) s
</pre>

<DT><span class="strong">ideal_antisym</span>
<DD>
<pre>
⊢ ∀r i. i << r ∧ r << i ⇒ i = r
</pre>

<DT><span class="strong">ideal_carrier_sing</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ (SING i.carrier ⇔ i = <#0>)
</pre>

<DT><span class="strong">ideal_carriers</span>
<DD>
<pre>
⊢ ∀r i. i << r ⇒ i.sum.carrier = i.carrier ∧ i.prod.carrier = i.carrier
</pre>

<DT><span class="strong">ideal_cogen_property</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ ∀x. x ∈ R/I ⇒ gen x ∈ R ∧ gen x ∘ i.carrier = x
</pre>

<DT><span class="strong">ideal_congruence_elements</span>
<DD>
<pre>
⊢ ∀r i.
    Ring r ∧ i << r ⇒ ∀x y. x ∈ i.carrier ∧ y ∈ R ⇒ (y ∈ i.carrier ⇔ x === y)
</pre>

<DT><span class="strong">ideal_congruence_equiv</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ $=== equiv_on R
</pre>

<DT><span class="strong">ideal_congruence_iff_inCoset</span>
<DD>
<pre>
⊢ ∀r i.
    Ring r ∧ i << r ⇒
    ∀x y. x ∈ i.carrier ∧ y ∈ i.carrier ⇒ (x === y ⇔ inCoset r.sum i.sum x y)
</pre>

<DT><span class="strong">ideal_congruence_mult</span>
<DD>
<pre>
⊢ ∀r i.
    Ring r ∧ i << r ⇒
    ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ x === y ⇒ z * x === z * y
</pre>

<DT><span class="strong">ideal_congruence_refl</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ ∀x. x ∈ R ⇒ x === x
</pre>

<DT><span class="strong">ideal_congruence_sym</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ (x === y ⇔ y === x)
</pre>

<DT><span class="strong">ideal_congruence_trans</span>
<DD>
<pre>
⊢ ∀r i.
    Ring r ∧ i << r ⇒
    ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ x === y ∧ y === z ⇒ x === z
</pre>

<DT><span class="strong">ideal_coset_add</span>
<DD>
<pre>
⊢ ∀r i.
    Ring r ∧ i << r ⇒
    ∀x y. x ∈ R ∧ y ∈ R ⇒ x ∘ i.carrier + y ∘ i.carrier = (x + y) ∘ i.carrier
</pre>

<DT><span class="strong">ideal_coset_element</span>
<DD>
<pre>
⊢ ∀r i x.
    Ring r ∧ i << r ∧ x ∈ R ⇒
    ∀z. z ∈ x ∘ i.carrier ⇔ ∃y. y ∈ i.carrier ∧ z = x + y
</pre>

<DT><span class="strong">ideal_coset_eq</span>
<DD>
<pre>
⊢ ∀r i.
    Ring r ∧ i << r ⇒
    ∀x y. x ∈ R ∧ y ∈ R ⇒ (x ∘ i.carrier = y ∘ i.carrier ⇔ x − y ∈ i.carrier)
</pre>

<DT><span class="strong">ideal_coset_eq_carrier</span>
<DD>
<pre>
⊢ ∀r i.
    Ring r ∧ i << r ⇒ ∀x. x ∈ R ∧ x ∘ i.carrier = i.carrier ⇔ x ∈ i.carrier
</pre>

<DT><span class="strong">ideal_coset_eq_congruence</span>
<DD>
<pre>
⊢ ∀r i.
    Ring r ∧ i << r ⇒
    ∀x y. x ∈ R ∧ y ∈ R ⇒ (x ∘ i.carrier = y ∘ i.carrier ⇔ x === y)
</pre>

<DT><span class="strong">ideal_coset_has_gen_diff</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ ∀x. x ∈ R ⇒ gen (x ∘ i.carrier) − x ∈ i.carrier
</pre>

<DT><span class="strong">ideal_coset_mult</span>
<DD>
<pre>
⊢ ∀r i.
    Ring r ∧ i << r ⇒
    ∀x y. x ∈ R ∧ y ∈ R ⇒ x ∘ i.carrier * y ∘ i.carrier = (x * y) ∘ i.carrier
</pre>

<DT><span class="strong">ideal_coset_neg</span>
<DD>
<pre>
⊢ ∀r i.
    Ring r ∧ i << r ⇒ ∀x. x ∈ R ⇒ x ∘ i.carrier + -x ∘ i.carrier = i.carrier
</pre>

<DT><span class="strong">ideal_coset_of_element</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ ∀x. x ∈ i.carrier ⇒ x ∘ i.carrier = i.carrier
</pre>

<DT><span class="strong">ideal_coset_property</span>
<DD>
<pre>
⊢ ∀r i.
    Ring r ∧ i << r ⇒
    ∀x. x ∈ R ⇒
        x ∘ i.carrier ∈ R/I ∧ gen (x ∘ i.carrier) ∘ i.carrier = x ∘ i.carrier
</pre>

<DT><span class="strong">ideal_coset_zero</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ #0 ∘ i.carrier = i.carrier
</pre>

<DT><span class="strong">ideal_element</span>
<DD>
<pre>
⊢ ∀r i. i << r ⇒ ∀x. x ∈ i.carrier ⇒ x ∈ r.sum.carrier
</pre>

<DT><span class="strong">ideal_element_property</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ ∀x. x ∈ i.carrier ⇒ x ∈ R
</pre>

<DT><span class="strong">ideal_eq_ideal</span>
<DD>
<pre>
⊢ ∀r i j. Ring r ∧ i << r ∧ j << r ⇒ (i = j ⇔ i.carrier = j.carrier)
</pre>

<DT><span class="strong">ideal_gen_exists</span>
<DD>
<pre>
⊢ ∀r i.
    Ring r ∧ i << r ∧ i ≠ <#0> ⇒
    ∀f. (∀x. f x = 0 ⇔ x = #0) ⇒
        ∃p. p ∈ i.carrier ∧ p ≠ #0 ∧ ∀z. z ∈ i.carrier ∧ z ≠ #0 ⇒ f p ≤ f z
</pre>

<DT><span class="strong">ideal_gen_minimal</span>
<DD>
<pre>
⊢ ∀r i.
    Ring r ∧ i << r ∧ i ≠ <#0> ⇒
    ∀f. (∀x. f x = 0 ⇔ x = #0) ⇒
        ∀z. z ∈ i.carrier ⇒ (f z < f (ideal_gen r i f) ⇔ z = #0)
</pre>

<DT><span class="strong">ideal_has_diff</span>
<DD>
<pre>
⊢ ∀r i.
    Ring r ∧ i << r ⇒ ∀x y. x ∈ i.carrier ∧ y ∈ i.carrier ⇒ x − y ∈ i.carrier
</pre>

<DT><span class="strong">ideal_has_multiple</span>
<DD>
<pre>
⊢ ∀r i. i << r ⇒ ∀x y. x ∈ i.carrier ∧ y ∈ R ⇒ x * y ∈ i.carrier
</pre>

<DT><span class="strong">ideal_has_neg</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ ∀x. x ∈ i.carrier ⇒ -x ∈ i.carrier
</pre>

<DT><span class="strong">ideal_has_one</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ∧ #1 ∈ i.carrier ⇒ i.carrier = R
</pre>

<DT><span class="strong">ideal_has_principal_ideal</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ ∀p. p ∈ R ⇒ (p ∈ i.carrier ⇔ <p> << i)
</pre>

<DT><span class="strong">ideal_has_product</span>
<DD>
<pre>
⊢ ∀r i.
    Ring r ∧ i << r ⇒ ∀x y. x ∈ i.carrier ∧ y ∈ i.carrier ⇒ x * y ∈ i.carrier
</pre>

<DT><span class="strong">ideal_has_subgroup</span>
<DD>
<pre>
⊢ ∀r i. i << r ⇒ i.sum ≤ r.sum
</pre>

<DT><span class="strong">ideal_has_sum</span>
<DD>
<pre>
⊢ ∀r i.
    Ring r ∧ i << r ⇒ ∀x y. x ∈ i.carrier ∧ y ∈ i.carrier ⇒ x + y ∈ i.carrier
</pre>

<DT><span class="strong">ideal_has_zero</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ #0 ∈ i.carrier
</pre>

<DT><span class="strong">ideal_in_quotient_ring</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ i.carrier ∈ R/I
</pre>

<DT><span class="strong">ideal_ops</span>
<DD>
<pre>
⊢ ∀r i. i << r ⇒ i.sum.op = $+ ∧ i.prod.op = $*
</pre>

<DT><span class="strong">ideal_product_property</span>
<DD>
<pre>
⊢ ∀r i.
    i << r ⇒
    ∀x y. x ∈ i.carrier ∧ y ∈ R ⇒ x * y ∈ i.carrier ∧ y * x ∈ i.carrier
</pre>

<DT><span class="strong">ideal_property</span>
<DD>
<pre>
⊢ ∀r i.
    Ring r ∧ i << r ⇒
    ∀x y.
      x ∈ i.carrier ∧ y ∈ i.carrier ⇒ x + y ∈ i.carrier ∧ x * y ∈ i.carrier
</pre>

<DT><span class="strong">ideal_refl</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ r << r
</pre>

<DT><span class="strong">ideal_sub_ideal</span>
<DD>
<pre>
⊢ ∀r i j. Ring r ∧ i << r ∧ j << r ⇒ (i << j ⇔ i.carrier ⊆ j.carrier)
</pre>

<DT><span class="strong">ideal_sub_itself</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ i << i
</pre>

<DT><span class="strong">ideal_subgroup_ideal_sum</span>
<DD>
<pre>
⊢ ∀r i j. Ring r ∧ i << r ∧ j << r ⇒ i.sum ≤ (i + j).sum
</pre>

<DT><span class="strong">ideal_sum_comm</span>
<DD>
<pre>
⊢ ∀r i j. Ring r ∧ i << r ∧ j << r ⇒ i + j = j + i
</pre>

<DT><span class="strong">ideal_sum_element</span>
<DD>
<pre>
⊢ ∀i j x.
    x ∈ (i + j).carrier ⇔ ∃y z. y ∈ i.carrier ∧ z ∈ j.carrier ∧ x = y + z
</pre>

<DT><span class="strong">ideal_sum_group</span>
<DD>
<pre>
⊢ ∀r i j. Ring r ∧ i << r ∧ j << r ⇒ Group (i + j).sum
</pre>

<DT><span class="strong">ideal_sum_has_ideal</span>
<DD>
<pre>
⊢ ∀r i j. Ring r ∧ i << r ∧ j << r ⇒ i << (i + j)
</pre>

<DT><span class="strong">ideal_sum_has_ideal_comm</span>
<DD>
<pre>
⊢ ∀r i j. Ring r ∧ i << r ∧ j << r ⇒ j << (i + j)
</pre>

<DT><span class="strong">ideal_sum_ideal</span>
<DD>
<pre>
⊢ ∀r i j. Ring r ∧ i << r ∧ j << r ⇒ (i + j) << r
</pre>

<DT><span class="strong">ideal_sum_sub_ideal</span>
<DD>
<pre>
⊢ ∀r i j. Ring r ∧ i << r ∧ j << r ⇒ ((i + j) << j ⇔ i << j)
</pre>

<DT><span class="strong">ideal_sum_subgroup</span>
<DD>
<pre>
⊢ ∀r i j. Ring r ∧ i << r ∧ j << r ⇒ (i + j).sum ≤ r.sum
</pre>

<DT><span class="strong">ideal_with_one</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀i. i << r ∧ #1 ∈ i.carrier ⇔ i = r
</pre>

<DT><span class="strong">ideal_with_unit</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ ∀x. x ∈ i.carrier ∧ unit x ⇒ i = r
</pre>

<DT><span class="strong">ideal_zero</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ i.sum.id = #0
</pre>

<DT><span class="strong">integral_domain_char</span>
<DD>
<pre>
⊢ ∀r. IntegralDomain r ⇒ char r = 0 ∨ prime (char r)
</pre>

<DT><span class="strong">integral_domain_divides_prime</span>
<DD>
<pre>
⊢ ∀r p x.
    IntegralDomain r ∧ x ∈ R ∧ p ∈ R ∧ p ≠ #0 ∧ rprime p ∧ p ∉ R* ∧ x ∉ R* ∧
    x rdivides p ⇒
    rassoc x p
</pre>

<DT><span class="strong">integral_domain_exp_eq</span>
<DD>
<pre>
⊢ ∀r. IntegralDomain r ⇒
      ∀x. x ∈ R+ ⇒ ∀m n. m < n ∧ x ** m = x ** n ⇒ x ** (n − m) = #1
</pre>

<DT><span class="strong">integral_domain_exp_eq_zero</span>
<DD>
<pre>
⊢ ∀r. IntegralDomain r ⇒ ∀x. x ∈ R ⇒ ∀n. x ** n = #0 ⇔ n ≠ 0 ∧ x = #0
</pre>

<DT><span class="strong">integral_domain_exp_nonzero</span>
<DD>
<pre>
⊢ ∀r. IntegralDomain r ⇒ ∀x. x ∈ R+ ⇒ ∀n. x ** n ∈ R+
</pre>

<DT><span class="strong">integral_domain_is_ring</span>
<DD>
<pre>
⊢ ∀r. IntegralDomain r ⇒ Ring r
</pre>

<DT><span class="strong">integral_domain_mult_eq_zero</span>
<DD>
<pre>
⊢ ∀r. IntegralDomain r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ (x * y = #0 ⇔ x = #0 ∨ y = #0)
</pre>

<DT><span class="strong">integral_domain_mult_lcancel</span>
<DD>
<pre>
⊢ ∀r. IntegralDomain r ⇒
      ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ (x * y = x * z ⇔ x = #0 ∨ y = z)
</pre>

<DT><span class="strong">integral_domain_mult_nonzero</span>
<DD>
<pre>
⊢ ∀r. IntegralDomain r ⇒ ∀x y. x ∈ R+ ∧ y ∈ R+ ⇒ x * y ∈ R+
</pre>

<DT><span class="strong">integral_domain_mult_rcancel</span>
<DD>
<pre>
⊢ ∀r. IntegralDomain r ⇒
      ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ (y * x = z * x ⇔ x = #0 ∨ y = z)
</pre>

<DT><span class="strong">integral_domain_nonzero_monoid</span>
<DD>
<pre>
⊢ ∀r. IntegralDomain r ⇒ Monoid f*
</pre>

<DT><span class="strong">integral_domain_nonzero_mult_carrier</span>
<DD>
<pre>
⊢ ∀r. IntegralDomain r ⇒ F* = R+
</pre>

<DT><span class="strong">integral_domain_nonzero_mult_is_monoid</span>
<DD>
<pre>
⊢ ∀r. IntegralDomain r ⇒ Monoid (monoid_of_ring_nonzero_mult r)
</pre>

<DT><span class="strong">integral_domain_nonzero_mult_property</span>
<DD>
<pre>
⊢ ∀r. IntegralDomain r ⇒ F* = R+ ∧ f*.id = #1 ∧ f*.op = $* ∧ f*.exp = $**
</pre>

<DT><span class="strong">integral_domain_nonzero_order</span>
<DD>
<pre>
⊢ ∀r. IntegralDomain r ⇒ ∀x. order r.prod x = order f* x
</pre>

<DT><span class="strong">integral_domain_one_ne_zero</span>
<DD>
<pre>
⊢ ∀r. IntegralDomain r ⇒ #1 ≠ #0
</pre>

<DT><span class="strong">integral_domain_one_nonzero</span>
<DD>
<pre>
⊢ ∀r. IntegralDomain r ⇒ #1 ∈ R+
</pre>

<DT><span class="strong">integral_domain_order_eq_0</span>
<DD>
<pre>
⊢ ∀r. FiniteIntegralDomain r ⇒ ∀x. x ∈ R ⇒ (order f* x = 0 ⇔ x = #0)
</pre>

<DT><span class="strong">integral_domain_order_nonzero</span>
<DD>
<pre>
⊢ ∀r. FiniteIntegralDomain r ⇒ ∀x. x ∈ R+ ⇒ order f* x ≠ 0
</pre>

<DT><span class="strong">integral_domain_order_zero</span>
<DD>
<pre>
⊢ ∀r. IntegralDomain r ⇒ order f* #0 = 0
</pre>

<DT><span class="strong">integral_domain_prime_factors_unique</span>
<DD>
<pre>
⊢ IntegralDomain r ⇒
  ∀l1 l2.
    (∀m. MEM m l1 ⇒ m ∈ R ∧ rprime m ∧ m ≠ #0 ∧ m ∉ R* ) ∧
    (∀m. MEM m l2 ⇒ m ∈ R ∧ rprime m ∧ m ≠ #0 ∧ m ∉ R* ) ∧
    rassoc (GBAG r.prod (LIST_TO_BAG l1)) (GBAG r.prod (LIST_TO_BAG l2)) ⇒
    ∃l3. PERM l2 l3 ∧ LIST_REL rassoc l1 l3
</pre>

<DT><span class="strong">integral_domain_ring_iso</span>
<DD>
<pre>
⊢ IntegralDomain r ∧ Ring s ∧ RingIso f r s ⇒ IntegralDomain s
</pre>

<DT><span class="strong">integral_domain_zero_not_unit</span>
<DD>
<pre>
⊢ ∀r. IntegralDomain r ⇒ #0 ∉ R*
</pre>

<DT><span class="strong">integral_domain_zero_product</span>
<DD>
<pre>
⊢ ∀r. IntegralDomain r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ (x * y = #0 ⇔ x = #0 ∨ y = #0)
</pre>

<DT><span class="strong">irreducible_associates</span>
<DD>
<pre>
⊢ ∀r. Ring r ∧ #1 ≠ #0 ⇒ ∀p s. p ∈ R ∧ unit s ⇒ (atom p ⇔ atom (s * p))
</pre>

<DT><span class="strong">irreducible_element</span>
<DD>
<pre>
⊢ ∀r p. atom p ⇒ p ∈ R
</pre>

<DT><span class="strong">irreducible_factors</span>
<DD>
<pre>
⊢ ∀r z.
    atom z ⇒ z ∈ R+ ∧ z ∉ R* ∧ ∀p. p ∈ R ∧ p rdivides z ⇒ rassoc z p ∨ unit p
</pre>

<DT><span class="strong">kernel_ideal_element</span>
<DD>
<pre>
⊢ ∀r r_ f x. x ∈ (kernel_ideal f r r_).carrier ⇔ x ∈ r.sum.carrier ∧ f x = #0_
</pre>

<DT><span class="strong">kernel_ideal_gen_add_map</span>
<DD>
<pre>
⊢ ∀r r_ f.
    (r ~r~ r_) f ⇒
    (let
       i = kernel_ideal f r r_
     in
       ∀x y.
         x ∈ R/I ∧ y ∈ R/I ⇒
         f (gen ((gen x + gen y) ∘ i.carrier)) = f (gen x) +_ f (gen y))
</pre>

<DT><span class="strong">kernel_ideal_gen_id_map</span>
<DD>
<pre>
⊢ ∀r r_ f.
    (r ~r~ r_) f ⇒
    (let i = kernel_ideal f r r_ in f (gen (#1 ∘ i.carrier)) = #1_)
</pre>

<DT><span class="strong">kernel_ideal_gen_mult_map</span>
<DD>
<pre>
⊢ ∀r r_ f.
    (r ~r~ r_) f ⇒
    (let
       i = kernel_ideal f r r_
     in
       ∀x y.
         x ∈ R/I ∧ y ∈ R/I ⇒
         f (gen ((gen x * gen y) ∘ i.carrier)) = f (gen x) *_ f (gen y))
</pre>

<DT><span class="strong">kernel_ideal_quotient_bij</span>
<DD>
<pre>
⊢ ∀r r_ f.
    (r ~r~ r_) f ⇒
    (let i = kernel_ideal f r r_ in BIJ (f ∘ gen) R/I (IMAGE f R))
</pre>

<DT><span class="strong">kernel_ideal_quotient_element_eq</span>
<DD>
<pre>
⊢ ∀r r_ f.
    (r ~r~ r_) f ⇒
    (let
       i = kernel_ideal f r r_
     in
       ∀x y. x ∈ R/I ∧ y ∈ R/I ⇒ (gen x − gen y ∈ i.carrier ⇔ x = y))
</pre>

<DT><span class="strong">kernel_ideal_quotient_homo</span>
<DD>
<pre>
⊢ ∀r s f.
    (r ~r~ s) f ⇒
    (let
       i = kernel_ideal f r s
     in
       RingHomo (f ∘ gen) (r / i) (ring_homo_image f r s))
</pre>

<DT><span class="strong">kernel_ideal_quotient_inj</span>
<DD>
<pre>
⊢ ∀r r_ f.
    (r ~r~ r_) f ⇒
    (let i = kernel_ideal f r r_ in INJ (f ∘ gen) R/I (IMAGE f R))
</pre>

<DT><span class="strong">kernel_ideal_quotient_iso</span>
<DD>
<pre>
⊢ ∀r s f.
    (r ~r~ s) f ⇒
    (let
       i = kernel_ideal f r s
     in
       RingIso (f ∘ gen) (r / i) (ring_homo_image f r s))
</pre>

<DT><span class="strong">kernel_ideal_quotient_surj</span>
<DD>
<pre>
⊢ ∀r r_ f.
    (r ~r~ r_) f ⇒
    (let i = kernel_ideal f r r_ in SURJ (f ∘ gen) R/I (IMAGE f R))
</pre>

<DT><span class="strong">kernel_ideal_sum_eqn</span>
<DD>
<pre>
⊢ ∀r s f. (kernel_ideal f r s).sum = kernel_group f r.sum s.sum
</pre>

<DT><span class="strong">ordz_eval</span>
<DD>
<pre>
⊢ ∀m n. order (times_mod m) n = compute_ordz m n
</pre>

<DT><span class="strong">prime_is_irreducible</span>
<DD>
<pre>
⊢ ∀r p. IntegralDomain r ∧ p ∈ R ∧ rprime p ∧ p ≠ #0 ∧ p ∉ R* ⇒ atom p
</pre>

<DT><span class="strong">principal_ideal_element</span>
<DD>
<pre>
⊢ ∀p x. x ∈ <p>.carrier ⇔ ∃z. z ∈ R ∧ x = p * z
</pre>

<DT><span class="strong">principal_ideal_element_divides</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀p. p ∈ R ⇒ ∀x. x ∈ <p>.carrier ⇔ p rdivides x
</pre>

<DT><span class="strong">principal_ideal_eq_principal_ideal</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀p q u. p ∈ R ∧ q ∈ R ∧ unit u ∧ p = q * u ⇒ <p> = <q>
</pre>

<DT><span class="strong">principal_ideal_equal_principal_ideal</span>
<DD>
<pre>
⊢ ∀r. IntegralDomain r ⇒
      ∀p q. p ∈ R ∧ q ∈ R ⇒ (<p> = <q> ⇔ ∃u. unit u ∧ p = q * u)
</pre>

<DT><span class="strong">principal_ideal_group</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀p. p ∈ R ⇒ Group <p>.sum
</pre>

<DT><span class="strong">principal_ideal_has_element</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀p. p ∈ R ⇒ p ∈ <p>.carrier
</pre>

<DT><span class="strong">principal_ideal_has_principal_ideal</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀p q. p ∈ R ∧ q ∈ <p>.carrier ⇒ <q> << <p>
</pre>

<DT><span class="strong">principal_ideal_ideal</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀p. p ∈ R ⇒ <p> << r
</pre>

<DT><span class="strong">principal_ideal_property</span>
<DD>
<pre>
⊢ ∀r p.
    <p>.carrier = p * R ∧ <p>.sum.carrier = p * R ∧ <p>.prod.carrier = p * R ∧
    <p>.sum.op = $+ ∧ <p>.prod.op = $* ∧ <p>.sum.id = #0 ∧ <p>.prod.id = #1
</pre>

<DT><span class="strong">principal_ideal_ring_atom_is_prime</span>
<DD>
<pre>
⊢ ∀r. PrincipalIdealRing r ⇒ ∀p. atom p ⇒ rprime p
</pre>

<DT><span class="strong">principal_ideal_ring_ideal_maximal</span>
<DD>
<pre>
⊢ ∀r. PrincipalIdealRing r ⇒ ∀p. atom p ⇒ maxi <p>
</pre>

<DT><span class="strong">principal_ideal_ring_irreducible_is_prime</span>
<DD>
<pre>
⊢ ∀r. PrincipalIdealRing r ⇒ ∀p. atom p ⇒ rprime p
</pre>

<DT><span class="strong">principal_ideal_sub_implies_divides</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀p q. p ∈ R ∧ q ∈ R ⇒ (q rdivides p ⇔ <p> << <q>)
</pre>

<DT><span class="strong">principal_ideal_subgroup</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀p. p ∈ R ⇒ <p>.sum ≤ r.sum
</pre>

<DT><span class="strong">principal_ideal_subgroup_normal</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀p. p ∈ R ⇒ <p>.sum << r.sum
</pre>

<DT><span class="strong">principal_ideal_sum_eq_ideal</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ ∀p. p ∈ i.carrier ⇒ <p> + i = i
</pre>

<DT><span class="strong">principal_ideal_sum_equal_ideal</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ ∀p. p ∈ i.carrier ⇔ p ∈ R ∧ <p> + i = i
</pre>

<DT><span class="strong">quotient_ring_add_abelian_group</span>
<DD>
<pre>
⊢ ∀r. Ring r ∧ i << r ⇒ AbelianGroup (quotient_ring_add r i)
</pre>

<DT><span class="strong">quotient_ring_add_assoc</span>
<DD>
<pre>
⊢ ∀r i.
    Ring r ∧ i << r ⇒
    ∀x y z. x ∈ R/I ∧ y ∈ R/I ∧ z ∈ R/I ⇒ x + y + z = x + (y + z)
</pre>

<DT><span class="strong">quotient_ring_add_comm</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ ∀x y. x ∈ R/I ∧ y ∈ R/I ⇒ x + y = y + x
</pre>

<DT><span class="strong">quotient_ring_add_element</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ ∀x y. x ∈ R/I ∧ y ∈ R/I ⇒ x + y ∈ R/I
</pre>

<DT><span class="strong">quotient_ring_add_group</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ Group (quotient_ring_add r i)
</pre>

<DT><span class="strong">quotient_ring_add_id</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ ∀x. x ∈ R/I ⇒ i.carrier + x = x
</pre>

<DT><span class="strong">quotient_ring_add_inv</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ ∀x. x ∈ R/I ⇒ ∃y. y ∈ R/I ∧ y + x = i.carrier
</pre>

<DT><span class="strong">quotient_ring_by_principal_ideal</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀p. p ∈ R ⇒ Ring (r / <p>)
</pre>

<DT><span class="strong">quotient_ring_element</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ ∀z. z ∈ R/I ⇔ ∃x. x ∈ R ∧ z = x ∘ i.carrier
</pre>

<DT><span class="strong">quotient_ring_has_ideal</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ i.carrier ∈ R/I
</pre>

<DT><span class="strong">quotient_ring_homo</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ RingHomo (λx. x ∘ i.carrier) r (r / i)
</pre>

<DT><span class="strong">quotient_ring_homo_kernel</span>
<DD>
<pre>
⊢ ∀r i.
    Ring r ∧ i << r ⇒ kernel (λx. x ∘ i.carrier) r.sum (r / i).sum = i.carrier
</pre>

<DT><span class="strong">quotient_ring_homo_kernel_ideal</span>
<DD>
<pre>
⊢ ∀r i.
    Ring r ∧ i << r ⇒
    RingHomo (λx. x ∘ i.carrier) r (r / i) ∧
    kernel_ideal (λx. x ∘ i.carrier) r (r / i) = i
</pre>

<DT><span class="strong">quotient_ring_homo_surj</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ SURJ (λx. x ∘ i.carrier) R R/I
</pre>

<DT><span class="strong">quotient_ring_mult_abelian_monoid</span>
<DD>
<pre>
⊢ ∀r. Ring r ∧ i << r ⇒ AbelianMonoid (quotient_ring_mult r i)
</pre>

<DT><span class="strong">quotient_ring_mult_assoc</span>
<DD>
<pre>
⊢ ∀r i.
    Ring r ∧ i << r ⇒
    ∀x y z. x ∈ R/I ∧ y ∈ R/I ∧ z ∈ R/I ⇒ x * y * z = x * (y * z)
</pre>

<DT><span class="strong">quotient_ring_mult_comm</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ ∀x y. x ∈ R/I ∧ y ∈ R/I ⇒ x * y = y * x
</pre>

<DT><span class="strong">quotient_ring_mult_element</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ ∀x y. x ∈ R/I ∧ y ∈ R/I ⇒ x * y ∈ R/I
</pre>

<DT><span class="strong">quotient_ring_mult_id</span>
<DD>
<pre>
⊢ ∀r i.
    Ring r ∧ i << r ⇒
    ∀x. x ∈ R/I ⇒ #1 ∘ i.carrier * x = x ∧ x * #1 ∘ i.carrier = x
</pre>

<DT><span class="strong">quotient_ring_mult_ladd</span>
<DD>
<pre>
⊢ ∀r i.
    Ring r ∧ i << r ⇒
    ∀x y z. x ∈ R/I ∧ y ∈ R/I ∧ z ∈ R/I ⇒ x * (y + z) = x * y + x * z
</pre>

<DT><span class="strong">quotient_ring_mult_monoid</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ Monoid (quotient_ring_mult r i)
</pre>

<DT><span class="strong">quotient_ring_property</span>
<DD>
<pre>
⊢ ∀r i.
    (r / i).carrier = R/I ∧ (r / i).sum = quotient_ring_add r i ∧
    (r / i).prod = quotient_ring_mult r i
</pre>

<DT><span class="strong">quotient_ring_ring</span>
<DD>
<pre>
⊢ ∀r i. Ring r ∧ i << r ⇒ Ring (r / i)
</pre>

<DT><span class="strong">quotient_ring_ring_sing</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ (r / r).carrier = {R}
</pre>

<DT><span class="strong">ring_11</span>
<DD>
<pre>
⊢ ∀a0 a1 a2 a0' a1' a2'.
    ring a0 a1 a2 = ring a0' a1' a2' ⇔ a0 = a0' ∧ a1 = a1' ∧ a2 = a2'
</pre>

<DT><span class="strong">ring_Axiom</span>
<DD>
<pre>
⊢ ∀f. ∃fn. ∀a0 a1 a2. fn (ring a0 a1 a2) = f a0 a1 a2
</pre>

<DT><span class="strong">ring_accessors</span>
<DD>
<pre>
⊢ (∀f m m0. (ring f m m0).carrier = f) ∧ (∀f m m0. (ring f m m0).sum = m) ∧
  ∀f m m0. (ring f m m0).prod = m0
</pre>

<DT><span class="strong">ring_accfupds</span>
<DD>
<pre>
⊢ (∀r f. (r with sum updated_by f).carrier = R) ∧
  (∀r f. (r with prod updated_by f).carrier = R) ∧
  (∀r f. (r with carrier updated_by f).sum = r.sum) ∧
  (∀r f. (r with prod updated_by f).sum = r.sum) ∧
  (∀r f. (r with carrier updated_by f).prod = r.prod) ∧
  (∀r f. (r with sum updated_by f).prod = r.prod) ∧
  (∀r f. (r with carrier updated_by f).carrier = f R) ∧
  (∀r f. (r with sum updated_by f).sum = f r.sum) ∧
  ∀r f. (r with prod updated_by f).prod = f r.prod
</pre>

<DT><span class="strong">ring_add_abelian_group</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ AbelianGroup r.sum
</pre>

<DT><span class="strong">ring_add_assoc</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ x + y + z = x + (y + z)
</pre>

<DT><span class="strong">ring_add_assoc_comm</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ x + (y + z) = y + (x + z)
</pre>

<DT><span class="strong">ring_add_char_2</span>
<DD>
<pre>
⊢ ∀r. Ring r ∧ char r = 2 ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ x + y = x − y
</pre>

<DT><span class="strong">ring_add_comm</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ x + y = y + x
</pre>

<DT><span class="strong">ring_add_element</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ x + y ∈ R
</pre>

<DT><span class="strong">ring_add_eq_zero</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ (x + y = #0 ⇔ y = -x)
</pre>

<DT><span class="strong">ring_add_exp_eqn</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀n. r.sum.exp x n = x * $## n
</pre>

<DT><span class="strong">ring_add_group</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      Group r.sum ∧ r.sum.carrier = R ∧ ∀x y. x ∈ R ∧ y ∈ R ⇒ x + y = y + x
</pre>

<DT><span class="strong">ring_add_group_rwt</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ Group r.sum ∧ r.sum.carrier = R
</pre>

<DT><span class="strong">ring_add_lcancel</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ (x + y = x + z ⇔ y = z)
</pre>

<DT><span class="strong">ring_add_lneg</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ -x + x = #0
</pre>

<DT><span class="strong">ring_add_lneg_assoc</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ y = x + (-x + y) ∧ y = -x + (x + y)
</pre>

<DT><span class="strong">ring_add_lzero</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ #0 + x = x
</pre>

<DT><span class="strong">ring_add_pair_sub</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x y p q.
        x ∈ R ∧ y ∈ R ∧ p ∈ R ∧ q ∈ R ⇒ x + y − (p + q) = x − p + (y − q)
</pre>

<DT><span class="strong">ring_add_rcancel</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ (y + x = z + x ⇔ y = z)
</pre>

<DT><span class="strong">ring_add_rneg</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ x + -x = #0
</pre>

<DT><span class="strong">ring_add_rneg_assoc</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ y = y + -x + x ∧ y = y + x + -x
</pre>

<DT><span class="strong">ring_add_rzero</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ x + #0 = x
</pre>

<DT><span class="strong">ring_add_sub</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ x + y − y = x
</pre>

<DT><span class="strong">ring_add_sub_assoc</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ x + y − z = x + (y − z)
</pre>

<DT><span class="strong">ring_add_sub_comm</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ y + x − y = x
</pre>

<DT><span class="strong">ring_add_sub_identity</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x y z t.
        x ∈ R ∧ y ∈ R ∧ z ∈ R ∧ t ∈ R ⇒ (x + y = z + t ⇔ x − z = t − y)
</pre>

<DT><span class="strong">ring_add_zero_zero</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ #0 + #0 = #0
</pre>

<DT><span class="strong">ring_associates_divides</span>
<DD>
<pre>
⊢ ∀r p q x. Ring r ∧ rassoc p q ∧ q ∈ R ∧ p rdivides x ⇒ q rdivides x
</pre>

<DT><span class="strong">ring_associates_mult</span>
<DD>
<pre>
⊢ ∀r p q x.
    Ring r ∧ p ∈ R ∧ q ∈ R ∧ x ∈ R ∧ rassoc p q ⇒ rassoc (x * p) (x * q)
</pre>

<DT><span class="strong">ring_associates_refl</span>
<DD>
<pre>
⊢ ∀r x. Ring r ∧ x ∈ R ⇒ rassoc x x
</pre>

<DT><span class="strong">ring_associates_sym</span>
<DD>
<pre>
⊢ ∀r p q. Ring r ∧ q ∈ R ∧ rassoc p q ⇒ rassoc q p
</pre>

<DT><span class="strong">ring_associates_trans</span>
<DD>
<pre>
⊢ ∀r x y z. Ring r ∧ z ∈ R ∧ rassoc x y ∧ rassoc y z ⇒ rassoc x z
</pre>

<DT><span class="strong">ring_auto_I</span>
<DD>
<pre>
⊢ ∀r. RingAuto I r
</pre>

<DT><span class="strong">ring_auto_bij</span>
<DD>
<pre>
⊢ ∀r f. Ring r ∧ RingAuto f r ⇒ f PERMUTES R
</pre>

<DT><span class="strong">ring_auto_cong</span>
<DD>
<pre>
⊢ ∀r f1 f2.
    Ring r ∧ (∀x. x ∈ R ⇒ f1 x = f2 x) ⇒ (RingAuto f1 r ⇔ RingAuto f2 r)
</pre>

<DT><span class="strong">ring_auto_element</span>
<DD>
<pre>
⊢ ∀r f. RingAuto f r ⇒ ∀x. x ∈ R ⇒ f x ∈ R
</pre>

<DT><span class="strong">ring_auto_ids</span>
<DD>
<pre>
⊢ ∀r f. Ring r ∧ RingAuto f r ⇒ f #0 = #0 ∧ f #1 = #1
</pre>

<DT><span class="strong">ring_auto_linv_auto</span>
<DD>
<pre>
⊢ ∀r f. Ring r ∧ RingAuto f r ⇒ RingAuto (LINV f R) r
</pre>

<DT><span class="strong">ring_auto_one</span>
<DD>
<pre>
⊢ ∀r f. Ring r ∧ RingAuto f r ⇒ f #1 = #1
</pre>

<DT><span class="strong">ring_auto_zero</span>
<DD>
<pre>
⊢ ∀r f. Ring r ∧ RingAuto f r ⇒ f #0 = #0
</pre>

<DT><span class="strong">ring_binomial_2</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x y. x ∈ R ∧ y ∈ R ⇒ (x + y) ** 2 = x ** 2 + $## 2 * (x * y) + y ** 2
</pre>

<DT><span class="strong">ring_binomial_3</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x y.
        x ∈ R ∧ y ∈ R ⇒
        (x + y) ** 3 =
        x ** 3 + $## 3 * (x ** 2 * y) + $## 3 * (x * y ** 2) + y ** 3
</pre>

<DT><span class="strong">ring_binomial_4</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x y.
        x ∈ R ∧ y ∈ R ⇒
        (x + y) ** 4 =
        x ** 4 + $## 4 * (x ** 3 * y) + $## 6 * (x ** 2 * y ** 2) +
        $## 4 * (x * y ** 3) + y ** 4
</pre>

<DT><span class="strong">ring_binomial_genlist_index_shift</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x y.
        x ∈ R ∧ y ∈ R ⇒
        ∀n. GENLIST
              ((λk. $## (binomial n k) * x ** SUC (n − k) * y ** k) ∘ SUC) n =
            GENLIST (λk. $## (binomial n (SUC k)) * x ** (n − k) * y ** SUC k)
              n
</pre>

<DT><span class="strong">ring_binomial_index_shift</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x y.
        x ∈ R ∧ y ∈ R ⇒
        ∀n. (λk. $## (binomial (SUC n) k) * x ** (SUC n − k) * y ** k) ∘ SUC =
            (λk. $## (binomial (SUC n) (SUC k)) * x ** (n − k) * y ** SUC k)
</pre>

<DT><span class="strong">ring_binomial_term_merge_x</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x y.
        x ∈ R ∧ y ∈ R ⇒
        ∀n. (λk. x * k) ∘ (λk. $## (binomial n k) * x ** (n − k) * y ** k) =
            (λk. $## (binomial n k) * x ** SUC (n − k) * y ** k)
</pre>

<DT><span class="strong">ring_binomial_term_merge_y</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x y.
        x ∈ R ∧ y ∈ R ⇒
        ∀n. (λk. y * k) ∘ (λk. $## (binomial n k) * x ** (n − k) * y ** k) =
            (λk. $## (binomial n k) * x ** (n − k) * y ** SUC k)
</pre>

<DT><span class="strong">ring_binomial_thm</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x y.
        x ∈ R ∧ y ∈ R ⇒
        ∀n. (x + y) ** n =
            rsum
              (GENLIST (λk. $## (binomial n k) * x ** (n − k) * y ** k)
                 (SUC n))
</pre>

<DT><span class="strong">ring_carrier_nonempty</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ R ≠ ∅
</pre>

<DT><span class="strong">ring_carriers</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ r.sum.carrier = R ∧ r.prod.carrier = R
</pre>

<DT><span class="strong">ring_case_cong</span>
<DD>
<pre>
⊢ ∀M M' f.
    M = M' ∧ (∀a0 a1 a2. M' = ring a0 a1 a2 ⇒ f a0 a1 a2 = f' a0 a1 a2) ⇒
    ring_CASE M f = ring_CASE M' f'
</pre>

<DT><span class="strong">ring_case_eq</span>
<DD>
<pre>
⊢ ring_CASE x f = v ⇔ ∃f' m m0. x = ring f' m m0 ∧ f f' m m0 = v
</pre>

<DT><span class="strong">ring_char_0</span>
<DD>
<pre>
⊢ ∀r. Ring r ∧ char r = 0 ⇒ INFINITE R
</pre>

<DT><span class="strong">ring_char_1</span>
<DD>
<pre>
⊢ ∀r. Ring r ∧ char r = 1 ⇒ R = {#0}
</pre>

<DT><span class="strong">ring_char_2_double</span>
<DD>
<pre>
⊢ ∀r. Ring r ∧ char r = 2 ⇒ ∀x. x ∈ R ⇒ x + x = #0
</pre>

<DT><span class="strong">ring_char_2_neg_one</span>
<DD>
<pre>
⊢ ∀r. Ring r ∧ char r = 2 ⇒ -#1 = #1
</pre>

<DT><span class="strong">ring_char_2_property</span>
<DD>
<pre>
⊢ ∀r. Ring r ∧ char r = 2 ⇒ #1 + #1 = #0
</pre>

<DT><span class="strong">ring_char_alt</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀n. 0 < n ⇒ (char r = n ⇔ $## n = #0 ∧ ∀m. 0 < m ∧ m < n ⇒ $## m ≠ #0)
</pre>

<DT><span class="strong">ring_char_divides</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀n. $## n = #0 ⇔ char r divides n
</pre>

<DT><span class="strong">ring_char_eq_1</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ (char r = 1 ⇔ #1 = #0)
</pre>

<DT><span class="strong">ring_char_prime</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      (prime (char r) ⇔
       1 < char r ∧ ∀k. 0 < k ∧ k < char r ⇒ $## (binomial (char r) k) = #0)
</pre>

<DT><span class="strong">ring_char_prime_endo</span>
<DD>
<pre>
⊢ ∀r. Ring r ∧ prime (char r) ⇒ RingEndo (λx. x ** char r) r
</pre>

<DT><span class="strong">ring_component_equality</span>
<DD>
<pre>
⊢ ∀r1 r2.
    r1 = r2 ⇔ r1.carrier = r2.carrier ∧ r1.sum = r2.sum ∧ r1.prod = r2.prod
</pre>

<DT><span class="strong">ring_divides_associates</span>
<DD>
<pre>
⊢ ∀r x y p. Ring r ∧ rassoc x y ∧ p ∈ R ∧ y ∈ R ∧ p rdivides x ⇒ p rdivides y
</pre>

<DT><span class="strong">ring_divides_by_one</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀p. p ∈ R ⇒ #1 rdivides p
</pre>

<DT><span class="strong">ring_divides_by_unit</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀p t. p ∈ R ∧ unit t ⇒ t rdivides p
</pre>

<DT><span class="strong">ring_divides_iso</span>
<DD>
<pre>
⊢ ∀r r_ f.
    (r =r= r_) f ⇒ ∀p q. p ∈ R ∧ p rdivides q ⇒ ring_divides r_ (f p) (f q)
</pre>

<DT><span class="strong">ring_divides_le</span>
<DD>
<pre>
⊢ ∀r f.
    EuclideanRing r f ∧ ring_ordering r f ⇒
    ∀p q. p ∈ R ∧ q ∈ R ∧ p ≠ #0 ∧ q rdivides p ⇒ f q ≤ f p
</pre>

<DT><span class="strong">ring_divides_refl</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀p. p ∈ R ⇒ p rdivides p
</pre>

<DT><span class="strong">ring_divides_trans</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀p q t.
        p ∈ R ∧ q ∈ R ∧ t ∈ R ∧ p rdivides q ∧ q rdivides t ⇒ p rdivides t
</pre>

<DT><span class="strong">ring_divides_zero</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀p. p ∈ R ⇒ p rdivides #0
</pre>

<DT><span class="strong">ring_eq_unit_eq</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ∧ x = y ⇒ x =~ y
</pre>

<DT><span class="strong">ring_exp_0</span>
<DD>
<pre>
⊢ ∀x. x ** 0 = #1
</pre>

<DT><span class="strong">ring_exp_1</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ x ** 1 = x
</pre>

<DT><span class="strong">ring_exp_SUC</span>
<DD>
<pre>
⊢ ∀x n. x ** SUC n = x * x ** n
</pre>

<DT><span class="strong">ring_exp_add</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀n k. x ** (n + k) = x ** n * x ** k
</pre>

<DT><span class="strong">ring_exp_add_assoc</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x y. x ∈ R ∧ y ∈ R ⇒ ∀n k. x ** n * (x ** k * y) = x ** (n + k) * y
</pre>

<DT><span class="strong">ring_exp_comm</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀n. x ** n * x = x * x ** n
</pre>

<DT><span class="strong">ring_exp_element</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀n. x ** n ∈ R
</pre>

<DT><span class="strong">ring_exp_mod_order</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x. x ∈ R ∧ 0 < order r.prod x ⇒
          ∀n. x ** n = x ** (n MOD order r.prod x)
</pre>

<DT><span class="strong">ring_exp_mult</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀n k. x ** (n * k) = (x ** n) ** k
</pre>

<DT><span class="strong">ring_exp_mult_comm</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀m n. (x ** m) ** n = (x ** n) ** m
</pre>

<DT><span class="strong">ring_exp_neg</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀n. -x ** n = if EVEN n then x ** n else -(x ** n)
</pre>

<DT><span class="strong">ring_exp_small</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x. x ∈ R ⇒
          x ** 0 = #1 ∧ x ** 1 = x ∧ x ** 2 = x * x ∧ x ** 3 = x * x ** 2 ∧
          x ** 4 = x * x ** 3 ∧ x ** 5 = x * x ** 4 ∧ x ** 6 = x * x ** 5 ∧
          x ** 7 = x * x ** 6 ∧ x ** 8 = x * x ** 7 ∧ x ** 9 = x * x ** 8
</pre>

<DT><span class="strong">ring_exp_suc</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀n. x ** SUC n = x ** n * x
</pre>

<DT><span class="strong">ring_factor_multiple</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀p q.
        p ∈ R ∧ q ∈ R ∧ (∃k. k ∈ R ∧ p = k * q) ⇒
        ∀z. z ∈ R ∧ (∃s. s ∈ R ∧ z = s * p) ⇒ ∃t. t ∈ R ∧ z = t * q
</pre>

<DT><span class="strong">ring_fermat_all</span>
<DD>
<pre>
⊢ ∀r. Ring r ∧ prime (char r) ⇒ ∀n k. $## n ** char r ** k = $## n
</pre>

<DT><span class="strong">ring_fermat_thm</span>
<DD>
<pre>
⊢ ∀r. Ring r ∧ prime (char r) ⇒ ∀n. $## n ** char r = $## n
</pre>

<DT><span class="strong">ring_first_isomorphism_thm</span>
<DD>
<pre>
⊢ ∀r r_ f.
    (r ~r~ r_) f ⇒
    (let
       i = kernel_ideal f r r_
     in
       i << r ∧ ring_homo_image f r r_ ≤ r_ ∧
       RingIso (f ∘ gen) (r / i) (ring_homo_image f r r_))
</pre>

<DT><span class="strong">ring_fn_updates</span>
<DD>
<pre>
⊢ (∀f0 f m m0. ring f m m0 with carrier updated_by f0 = ring (f0 f) m m0) ∧
  (∀f0 f m m0. ring f m m0 with sum updated_by f0 = ring f (f0 m) m0) ∧
  ∀f0 f m m0. ring f m m0 with prod updated_by f0 = ring f m (f0 m0)
</pre>

<DT><span class="strong">ring_freshman_all</span>
<DD>
<pre>
⊢ ∀r. Ring r ∧ prime (char r) ⇒
      ∀x y.
        x ∈ R ∧ y ∈ R ⇒
        ∀n. (x + y) ** char r ** n = x ** char r ** n + y ** char r ** n
</pre>

<DT><span class="strong">ring_freshman_all_sub</span>
<DD>
<pre>
⊢ ∀r. Ring r ∧ prime (char r) ⇒
      ∀x y.
        x ∈ R ∧ y ∈ R ⇒
        ∀n. (x − y) ** char r ** n = x ** char r ** n − y ** char r ** n
</pre>

<DT><span class="strong">ring_freshman_thm</span>
<DD>
<pre>
⊢ ∀r. Ring r ∧ prime (char r) ⇒
      ∀x y. x ∈ R ∧ y ∈ R ⇒ (x + y) ** char r = x ** char r + y ** char r
</pre>

<DT><span class="strong">ring_freshman_thm_sub</span>
<DD>
<pre>
⊢ ∀r. Ring r ∧ prime (char r) ⇒
      ∀x y. x ∈ R ∧ y ∈ R ⇒ (x − y) ** char r = x ** char r − y ** char r
</pre>

<DT><span class="strong">ring_fun_add</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀a b. rfun a ∧ rfun b ⇒ rfun (λk. a k + b k)
</pre>

<DT><span class="strong">ring_fun_from_ring_fun</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀f. rfun f ⇒ ∀x. x ∈ R ⇒ rfun (λj. f j * x ** j)
</pre>

<DT><span class="strong">ring_fun_from_ring_fun_exp</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀f. rfun f ⇒ ∀x. x ∈ R ⇒ ∀n. rfun (λj. (f j * x ** j) ** n)
</pre>

<DT><span class="strong">ring_fun_genlist</span>
<DD>
<pre>
⊢ ∀f. rfun f ⇒ ∀n. rlist (GENLIST f n)
</pre>

<DT><span class="strong">ring_fun_map</span>
<DD>
<pre>
⊢ ∀f l. rfun f ⇒ rlist (MAP f l)
</pre>

<DT><span class="strong">ring_fupdcanon</span>
<DD>
<pre>
⊢ (∀r g f.
     r with <|sum updated_by f; carrier updated_by g|> =
     r with <|carrier updated_by g; sum updated_by f|>) ∧
  (∀r g f.
     r with <|prod updated_by f; carrier updated_by g|> =
     r with <|carrier updated_by g; prod updated_by f|>) ∧
  ∀r g f.
    r with <|prod updated_by f; sum updated_by g|> =
    r with <|sum updated_by g; prod updated_by f|>
</pre>

<DT><span class="strong">ring_fupdcanon_comp</span>
<DD>
<pre>
⊢ ((∀g f. sum_fupd f ∘ carrier_fupd g = carrier_fupd g ∘ sum_fupd f) ∧
   ∀h g f. sum_fupd f ∘ carrier_fupd g ∘ h = carrier_fupd g ∘ sum_fupd f ∘ h) ∧
  ((∀g f. prod_fupd f ∘ carrier_fupd g = carrier_fupd g ∘ prod_fupd f) ∧
   ∀h g f. prod_fupd f ∘ carrier_fupd g ∘ h = carrier_fupd g ∘ prod_fupd f ∘ h) ∧
  (∀g f. prod_fupd f ∘ sum_fupd g = sum_fupd g ∘ prod_fupd f) ∧
  ∀h g f. prod_fupd f ∘ sum_fupd g ∘ h = sum_fupd g ∘ prod_fupd f ∘ h
</pre>

<DT><span class="strong">ring_fupdfupds</span>
<DD>
<pre>
⊢ (∀r g f.
     r with <|carrier updated_by f; carrier updated_by g|> =
     r with carrier updated_by f ∘ g) ∧
  (∀r g f.
     r with <|sum updated_by f; sum updated_by g|> =
     r with sum updated_by f ∘ g) ∧
  ∀r g f.
    r with <|prod updated_by f; prod updated_by g|> =
    r with prod updated_by f ∘ g
</pre>

<DT><span class="strong">ring_fupdfupds_comp</span>
<DD>
<pre>
⊢ ((∀g f. carrier_fupd f ∘ carrier_fupd g = carrier_fupd (f ∘ g)) ∧
   ∀h g f. carrier_fupd f ∘ carrier_fupd g ∘ h = carrier_fupd (f ∘ g) ∘ h) ∧
  ((∀g f. sum_fupd f ∘ sum_fupd g = sum_fupd (f ∘ g)) ∧
   ∀h g f. sum_fupd f ∘ sum_fupd g ∘ h = sum_fupd (f ∘ g) ∘ h) ∧
  (∀g f. prod_fupd f ∘ prod_fupd g = prod_fupd (f ∘ g)) ∧
  ∀h g f. prod_fupd f ∘ prod_fupd g ∘ h = prod_fupd (f ∘ g) ∘ h
</pre>

<DT><span class="strong">ring_gcd_divides</span>
<DD>
<pre>
⊢ ∀r f.
    EuclideanRing r f ⇒
    ∀p q. p ∈ R ∧ q ∈ R ⇒ rgcd p q rdivides p ∧ rgcd p q rdivides q
</pre>

<DT><span class="strong">ring_gcd_element</span>
<DD>
<pre>
⊢ ∀r f. EuclideanRing r f ⇒ ∀p q. p ∈ R ∧ q ∈ R ⇒ rgcd p q ∈ R
</pre>

<DT><span class="strong">ring_gcd_is_gcd</span>
<DD>
<pre>
⊢ ∀r f.
    EuclideanRing r f ⇒
    ∀p q.
      p ∈ R ∧ q ∈ R ⇒
      rgcd p q rdivides p ∧ rgcd p q rdivides q ∧
      ∀d. d ∈ R ∧ d rdivides p ∧ d rdivides q ⇒ d rdivides rgcd p q
</pre>

<DT><span class="strong">ring_gcd_linear</span>
<DD>
<pre>
⊢ ∀r f.
    EuclideanRing r f ⇒
    ∀p q. p ∈ R ∧ q ∈ R ⇒ ∃a b. a ∈ R ∧ b ∈ R ∧ rgcd p q = a * p + b * q
</pre>

<DT><span class="strong">ring_gcd_property</span>
<DD>
<pre>
⊢ ∀r f.
    EuclideanRing r f ⇒
    ∀p q.
      p ∈ R ∧ q ∈ R ⇒
      ∀d. d ∈ R ∧ d rdivides p ∧ d rdivides q ⇒ d rdivides rgcd p q
</pre>

<DT><span class="strong">ring_gcd_sym</span>
<DD>
<pre>
⊢ ∀r f. EuclideanRing r f ⇒ ∀p q. p ∈ R ∧ q ∈ R ⇒ rgcd p q = rgcd q p
</pre>

<DT><span class="strong">ring_gcd_zero</span>
<DD>
<pre>
⊢ ∀r f p. rgcd p #0 = p ∧ rgcd #0 p = p
</pre>

<DT><span class="strong">ring_homo_I_refl</span>
<DD>
<pre>
⊢ ∀r. RingHomo I r r
</pre>

<DT><span class="strong">ring_homo_add</span>
<DD>
<pre>
⊢ ∀r r_ f. (r ~r~ r_) f ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ f (x + y) = f x +_ f y
</pre>

<DT><span class="strong">ring_homo_char_divides</span>
<DD>
<pre>
⊢ ∀r r_ f. (r ~r~ r_) f ⇒ char r_ divides char r
</pre>

<DT><span class="strong">ring_homo_compose</span>
<DD>
<pre>
⊢ ∀r s t f1 f2. RingHomo f1 r s ∧ RingHomo f2 s t ⇒ RingHomo (f2 ∘ f1) r t
</pre>

<DT><span class="strong">ring_homo_cong</span>
<DD>
<pre>
⊢ ∀r r_ f1 f2.
    Ring r ∧ Ring r_ ∧ (∀x. x ∈ R ⇒ f1 x = f2 x) ⇒
    (RingHomo f1 r r_ ⇔ RingHomo f2 r r_)
</pre>

<DT><span class="strong">ring_homo_element</span>
<DD>
<pre>
⊢ ∀r r_ f. RingHomo f r r_ ⇒ ∀x. x ∈ R ⇒ f x ∈ R_
</pre>

<DT><span class="strong">ring_homo_eq_zero</span>
<DD>
<pre>
⊢ ∀r r_ f. (r ~r~ r_) f ∧ INJ f R R_ ⇒ ∀x. x ∈ R ⇒ (f x = #0_ ⇔ x = #0)
</pre>

<DT><span class="strong">ring_homo_exp</span>
<DD>
<pre>
⊢ ∀r r_ f. (r ~r~ r_) f ⇒ ∀x. x ∈ R ⇒ ∀n. f (x ** n) = f x **_ n
</pre>

<DT><span class="strong">ring_homo_ideal_group</span>
<DD>
<pre>
⊢ ∀r s f. (r ~r~ s) f ⇒ ∀i. i << r ⇒ Group (homo_ideal f r s i).sum
</pre>

<DT><span class="strong">ring_homo_ideal_ideal</span>
<DD>
<pre>
⊢ ∀r s f.
    Ring r ∧ Ring s ∧ RingHomo f r s ∧ SURJ f R s.carrier ⇒
    ∀i. i << r ⇒ homo_ideal f r s i << s
</pre>

<DT><span class="strong">ring_homo_ideal_subgroup</span>
<DD>
<pre>
⊢ ∀r s f. (r ~r~ s) f ⇒ ∀i. i << r ⇒ (homo_ideal f r s i).sum ≤ s.sum
</pre>

<DT><span class="strong">ring_homo_ids</span>
<DD>
<pre>
⊢ ∀r r_ f. (r ~r~ r_) f ⇒ f #0 = #0_ ∧ f #1 = #1_
</pre>

<DT><span class="strong">ring_homo_image_bij</span>
<DD>
<pre>
⊢ ∀r r_ f.
    (r ~r~ r_) f ∧ INJ f R R_ ⇒ BIJ f R (ring_homo_image f r r_).carrier
</pre>

<DT><span class="strong">ring_homo_image_carrier</span>
<DD>
<pre>
⊢ ∀r r_ f. (ring_homo_image f r r_).carrier = IMAGE f R
</pre>

<DT><span class="strong">ring_homo_image_homo</span>
<DD>
<pre>
⊢ ∀r r_ f. (r ~r~ r_) f ⇒ RingHomo f r (ring_homo_image f r r_)
</pre>

<DT><span class="strong">ring_homo_image_is_subring</span>
<DD>
<pre>
⊢ ∀r r_ f. (r ~r~ r_) f ⇒ subring (ring_homo_image f r r_) r_
</pre>

<DT><span class="strong">ring_homo_image_iso</span>
<DD>
<pre>
⊢ ∀r r_ f. (r ~r~ r_) f ∧ INJ f R R_ ⇒ RingIso f r (ring_homo_image f r r_)
</pre>

<DT><span class="strong">ring_homo_image_ring</span>
<DD>
<pre>
⊢ ∀r r_ f. (r ~r~ r_) f ⇒ Ring (ring_homo_image f r r_)
</pre>

<DT><span class="strong">ring_homo_image_subring</span>
<DD>
<pre>
⊢ ∀r r_ f. (r ~r~ r_) f ⇒ ring_homo_image f r r_ ≤ r_
</pre>

<DT><span class="strong">ring_homo_image_subring_subring</span>
<DD>
<pre>
⊢ ∀r r_ f.
    (r ~r~ r_) f ⇒
    ∀s. Ring s ∧ subring s r ⇒ subring (ring_homo_image f s r_) r_
</pre>

<DT><span class="strong">ring_homo_image_surj_property</span>
<DD>
<pre>
⊢ ∀r r_ f.
    Ring r ∧ Ring r_ ∧ SURJ f R R_ ⇒ RingIso I r_ (ring_homo_image f r r_)
</pre>

<DT><span class="strong">ring_homo_inv</span>
<DD>
<pre>
⊢ ∀r r_ f. (r ~r~ r_) f ⇒ ∀x. unit x ⇒ f ( |/ x) = |/_ (f x)
</pre>

<DT><span class="strong">ring_homo_kernel_ideal</span>
<DD>
<pre>
⊢ ∀f r s. (r ~r~ s) f ⇒ kernel_ideal f r s << r
</pre>

<DT><span class="strong">ring_homo_linv_homo</span>
<DD>
<pre>
⊢ ∀r r_ f. (r ~r~ r_) f ∧ BIJ f R R_ ⇒ RingHomo (LINV f R) r_ r
</pre>

<DT><span class="strong">ring_homo_mult</span>
<DD>
<pre>
⊢ ∀r r_ f. (r ~r~ r_) f ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ f (x * y) = f x *_ f y
</pre>

<DT><span class="strong">ring_homo_neg</span>
<DD>
<pre>
⊢ ∀r r_ f. (r ~r~ r_) f ⇒ ∀x. x ∈ R ⇒ f (-x) = $-_ (f x)
</pre>

<DT><span class="strong">ring_homo_num</span>
<DD>
<pre>
⊢ ∀r r_ f. (r ~r~ r_) f ⇒ ∀n. f ($## n) = ##_ #1_ n
</pre>

<DT><span class="strong">ring_homo_num_nonzero</span>
<DD>
<pre>
⊢ ∀r r_ f.
    (r ~r~ r_) f ⇒ ∀c. 0 < c ∧ c < char r_ ⇒ $## c ≠ #0 ∧ f ($## c) ≠ #0_
</pre>

<DT><span class="strong">ring_homo_one</span>
<DD>
<pre>
⊢ ∀r r_ f. (r ~r~ r_) f ⇒ f #1 = #1_
</pre>

<DT><span class="strong">ring_homo_one_eq_zero</span>
<DD>
<pre>
⊢ ∀r r_ f. (r ~r~ r_) f ∧ #1 = #0 ⇒ #1_ = #0_
</pre>

<DT><span class="strong">ring_homo_property</span>
<DD>
<pre>
⊢ ∀r r_ f.
    Ring r ∧ RingHomo f r r_ ⇒
    ∀x y. x ∈ R ∧ y ∈ R ⇒ f (x + y) = f x +_ f y ∧ f (x * y) = f x *_ f y
</pre>

<DT><span class="strong">ring_homo_ring_homo_subring</span>
<DD>
<pre>
⊢ ∀r r_ f. (r ~r~ r_) f ⇒ subring (ring_homo_image f r r_) r_
</pre>

<DT><span class="strong">ring_homo_sub</span>
<DD>
<pre>
⊢ ∀r r_ f. (r ~r~ r_) f ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ f (x − y) = f x -_ f y
</pre>

<DT><span class="strong">ring_homo_subring_homo</span>
<DD>
<pre>
⊢ ∀r s r_ f. (r ~r~ r_) f ∧ s ≤ r ⇒ (s ~r~ ring_homo_image f s r_) f
</pre>

<DT><span class="strong">ring_homo_sum_num_property</span>
<DD>
<pre>
⊢ ∀r r_ f.
    (r ~r~ r_) f ⇒ ∀c. 0 < c ∧ c < char r_ ⇒ $## c ≠ #0 ∧ ##_ #1_ c ≠ #0_
</pre>

<DT><span class="strong">ring_homo_sym</span>
<DD>
<pre>
⊢ ∀r r_ f. (r ~r~ r_) f ∧ BIJ f R R_ ⇒ RingHomo (LINV f R) r_ r
</pre>

<DT><span class="strong">ring_homo_sym_any</span>
<DD>
<pre>
⊢ Ring r ∧ Ring s ∧ RingHomo f r s ∧
  (∀x. x ∈ s.carrier ⇒ i x ∈ R ∧ f (i x) = x) ∧ (∀x. x ∈ R ⇒ i (f x) = x) ⇒
  RingHomo i s r
</pre>

<DT><span class="strong">ring_homo_trans</span>
<DD>
<pre>
⊢ ∀r s t f1 f2. RingHomo f1 r s ∧ RingHomo f2 s t ⇒ RingHomo (f2 ∘ f1) r t
</pre>

<DT><span class="strong">ring_homo_unit</span>
<DD>
<pre>
⊢ ∀r r_ f. (r ~r~ r_) f ⇒ ∀x. unit x ⇒ unit_ (f x)
</pre>

<DT><span class="strong">ring_homo_unit_inv</span>
<DD>
<pre>
⊢ ∀r r_ f. (r ~r~ r_) f ⇒ ∀x. unit x ⇒ |/_ (f x) = f ( |/ x)
</pre>

<DT><span class="strong">ring_homo_unit_inv_element</span>
<DD>
<pre>
⊢ ∀r r_ f. (r ~r~ r_) f ⇒ ∀x. unit x ⇒ |/_ (f x) ∈ R_
</pre>

<DT><span class="strong">ring_homo_unit_inv_nonzero</span>
<DD>
<pre>
⊢ ∀r r_ f. (r ~r~ r_) f ∧ #1_ ≠ #0_ ⇒ ∀x. unit x ⇒ |/_ (f x) ≠ #0_
</pre>

<DT><span class="strong">ring_homo_unit_nonzero</span>
<DD>
<pre>
⊢ ∀r r_ f. (r ~r~ r_) f ∧ #1_ ≠ #0_ ⇒ ∀x. unit x ⇒ f x ≠ #0_
</pre>

<DT><span class="strong">ring_homo_zero</span>
<DD>
<pre>
⊢ ∀r r_ f. (r ~r~ r_) f ⇒ f #0 = #0_
</pre>

<DT><span class="strong">ring_induction</span>
<DD>
<pre>
⊢ ∀P. (∀f m m0. P (ring f m m0)) ⇒ ∀r. P r
</pre>

<DT><span class="strong">ring_inj_image_alt</span>
<DD>
<pre>
⊢ ∀r f.
    Ring r ⇒
    ring_inj_image r f =
    <|carrier := IMAGE f R; sum := monoid_inj_image r.sum f;
      prod := monoid_inj_image r.prod f|>
</pre>

<DT><span class="strong">ring_inj_image_carrier</span>
<DD>
<pre>
⊢ ∀r f. (ring_inj_image r f).carrier = IMAGE f R
</pre>

<DT><span class="strong">ring_inj_image_prod_abelian_monoid</span>
<DD>
<pre>
⊢ ∀r f. Ring r ∧ INJ f R 𝕌(:β) ⇒ AbelianMonoid (ring_inj_image r f).prod
</pre>

<DT><span class="strong">ring_inj_image_prod_monoid</span>
<DD>
<pre>
⊢ ∀r f. Ring r ∧ INJ f R 𝕌(:β) ⇒ Monoid (ring_inj_image r f).prod
</pre>

<DT><span class="strong">ring_inj_image_prod_monoid_homo</span>
<DD>
<pre>
⊢ ∀r f. Ring r ∧ INJ f R 𝕌(:β) ⇒ MonoidHomo f r.prod (ring_inj_image r f).prod
</pre>

<DT><span class="strong">ring_inj_image_ring</span>
<DD>
<pre>
⊢ ∀r f. Ring r ∧ INJ f R 𝕌(:β) ⇒ Ring (ring_inj_image r f)
</pre>

<DT><span class="strong">ring_inj_image_ring_homo</span>
<DD>
<pre>
⊢ ∀r f. Ring r ∧ INJ f R 𝕌(:β) ⇒ RingHomo f r (ring_inj_image r f)
</pre>

<DT><span class="strong">ring_inj_image_sum_abelian_group</span>
<DD>
<pre>
⊢ ∀r f. Ring r ∧ INJ f R 𝕌(:β) ⇒ AbelianGroup (ring_inj_image r f).sum
</pre>

<DT><span class="strong">ring_inj_image_sum_group</span>
<DD>
<pre>
⊢ ∀r f. Ring r ∧ INJ f R 𝕌(:β) ⇒ Group (ring_inj_image r f).sum
</pre>

<DT><span class="strong">ring_inj_image_sum_group_homo</span>
<DD>
<pre>
⊢ ∀r f. Ring r ∧ INJ f R 𝕌(:β) ⇒ GroupHomo f r.sum (ring_inj_image r f).sum
</pre>

<DT><span class="strong">ring_inj_image_sum_monoid</span>
<DD>
<pre>
⊢ ∀r f. Ring r ∧ INJ f R 𝕌(:β) ⇒ Monoid (ring_inj_image r f).sum
</pre>

<DT><span class="strong">ring_inv_one</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ |/ #1 = #1
</pre>

<DT><span class="strong">ring_irreducible_gcd</span>
<DD>
<pre>
⊢ ∀r f.
    EuclideanRing r f ⇒
    ∀p. p ∈ R ∧ atom p ⇒ ∀q. q ∈ R ⇒ unit (rgcd p q) ∨ p rdivides q
</pre>

<DT><span class="strong">ring_iso_I_refl</span>
<DD>
<pre>
⊢ ∀r. RingIso I r r
</pre>

<DT><span class="strong">ring_iso_add</span>
<DD>
<pre>
⊢ ∀r r_ f. (r =r= r_) f ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ f (x + y) = f x +_ f y
</pre>

<DT><span class="strong">ring_iso_bij</span>
<DD>
<pre>
⊢ ∀r r_ f. (r =r= r_) f ⇒ BIJ f R R_
</pre>

<DT><span class="strong">ring_iso_card_eq</span>
<DD>
<pre>
⊢ ∀r r_ f. RingIso f r r_ ∧ FINITE R ⇒ CARD R = CARD R_
</pre>

<DT><span class="strong">ring_iso_char_eq</span>
<DD>
<pre>
⊢ ∀r r_ f. (r =r= r_) f ⇒ char r_ = char r
</pre>

<DT><span class="strong">ring_iso_compose</span>
<DD>
<pre>
⊢ ∀r s t f1 f2. RingIso f1 r s ∧ RingIso f2 s t ⇒ RingIso (f2 ∘ f1) r t
</pre>

<DT><span class="strong">ring_iso_cong</span>
<DD>
<pre>
⊢ ∀r r_ f1 f2.
    Ring r ∧ Ring r_ ∧ (∀x. x ∈ R ⇒ f1 x = f2 x) ⇒
    (RingIso f1 r r_ ⇔ RingIso f2 r r_)
</pre>

<DT><span class="strong">ring_iso_element</span>
<DD>
<pre>
⊢ ∀r r_ f. RingIso f r r_ ⇒ ∀x. x ∈ R ⇒ f x ∈ R_
</pre>

<DT><span class="strong">ring_iso_element_unique</span>
<DD>
<pre>
⊢ ∀r r_ f. (r =r= r_) f ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ (f x = f y ⇔ x = y)
</pre>

<DT><span class="strong">ring_iso_eq_one</span>
<DD>
<pre>
⊢ ∀r r_ f. (r =r= r_) f ⇒ ∀x. x ∈ R ⇒ (f x = #1_ ⇔ x = #1)
</pre>

<DT><span class="strong">ring_iso_eq_zero</span>
<DD>
<pre>
⊢ ∀r r_ f. (r =r= r_) f ⇒ ∀x. x ∈ R ⇒ (f x = #0_ ⇔ x = #0)
</pre>

<DT><span class="strong">ring_iso_exp</span>
<DD>
<pre>
⊢ ∀r r_ f. (r =r= r_) f ⇒ ∀x. x ∈ R ⇒ ∀n. f (x ** n) = f x **_ n
</pre>

<DT><span class="strong">ring_iso_ids</span>
<DD>
<pre>
⊢ ∀r r_ f. (r =r= r_) f ⇒ f #0 = #0_ ∧ f #1 = #1_
</pre>

<DT><span class="strong">ring_iso_inv</span>
<DD>
<pre>
⊢ ∀r r_ f. (r =r= r_) f ⇒ ∀x. unit x ⇒ f ( |/ x) = |/_ (f x)
</pre>

<DT><span class="strong">ring_iso_inverse</span>
<DD>
<pre>
⊢ ∀r r_ f. (r =r= r_) f ⇒ ∀y. y ∈ R_ ⇒ ∃x. x ∈ R ∧ y = f x
</pre>

<DT><span class="strong">ring_iso_inverse_element</span>
<DD>
<pre>
⊢ ∀r r_ f. (r =r= r_) f ⇒ ∀y. y ∈ R_ ⇒ LINV f R y ∈ R ∧ y = f (LINV f R y)
</pre>

<DT><span class="strong">ring_iso_linv_iso</span>
<DD>
<pre>
⊢ ∀r r_ f. (r =r= r_) f ⇒ RingIso (LINV f R) r_ r
</pre>

<DT><span class="strong">ring_iso_mult</span>
<DD>
<pre>
⊢ ∀r r_ f. (r =r= r_) f ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ f (x * y) = f x *_ f y
</pre>

<DT><span class="strong">ring_iso_neg</span>
<DD>
<pre>
⊢ ∀r r_ f. (r =r= r_) f ⇒ ∀x. x ∈ R ⇒ f (-x) = $-_ (f x)
</pre>

<DT><span class="strong">ring_iso_nonzero</span>
<DD>
<pre>
⊢ ∀r r_ f. (r =r= r_) f ⇒ ∀x. x ∈ R+ ⇒ f x ∈ R+_
</pre>

<DT><span class="strong">ring_iso_num</span>
<DD>
<pre>
⊢ ∀r r_ f. (r =r= r_) f ⇒ ∀n. f ($## n) = ##_ #1_ n
</pre>

<DT><span class="strong">ring_iso_one</span>
<DD>
<pre>
⊢ ∀r r_ f. (r =r= r_) f ⇒ f #1 = #1_
</pre>

<DT><span class="strong">ring_iso_property</span>
<DD>
<pre>
⊢ ∀r r_ f.
    Ring r ∧ RingIso f r r_ ⇒
    ∀x y. x ∈ R ∧ y ∈ R ⇒ f (x + y) = f x +_ f y ∧ f (x * y) = f x *_ f y
</pre>

<DT><span class="strong">ring_iso_ring_homo_subring</span>
<DD>
<pre>
⊢ ∀r r_ f. (r =r= r_) f ⇒ subring (ring_homo_image f r r_) r_
</pre>

<DT><span class="strong">ring_iso_sub</span>
<DD>
<pre>
⊢ ∀r r_ f. (r =r= r_) f ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ f (x − y) = f x -_ f y
</pre>

<DT><span class="strong">ring_iso_subring_iso</span>
<DD>
<pre>
⊢ ∀r s r_ f. (r =r= r_) f ∧ s ≤ r ⇒ (s =r= ring_homo_image f s r_) f
</pre>

<DT><span class="strong">ring_iso_sym</span>
<DD>
<pre>
⊢ ∀r r_ f. (r =r= r_) f ⇒ RingIso (LINV f R) r_ r
</pre>

<DT><span class="strong">ring_iso_sym_any</span>
<DD>
<pre>
⊢ Ring r ∧ Ring s ∧ RingIso f r s ∧
  (∀x. x ∈ s.carrier ⇒ i x ∈ R ∧ f (i x) = x) ∧ (∀x. x ∈ R ⇒ i (f x) = x) ⇒
  RingIso i s r
</pre>

<DT><span class="strong">ring_iso_trans</span>
<DD>
<pre>
⊢ ∀r s t f1 f2. RingIso f1 r s ∧ RingIso f2 s t ⇒ RingIso (f2 ∘ f1) r t
</pre>

<DT><span class="strong">ring_iso_unit</span>
<DD>
<pre>
⊢ ∀r r_ f. (r =r= r_) f ⇒ ∀x. unit x ⇒ unit_ (f x)
</pre>

<DT><span class="strong">ring_iso_zero</span>
<DD>
<pre>
⊢ ∀r r_ f. (r =r= r_) f ⇒ f #0 = #0_
</pre>

<DT><span class="strong">ring_list_SNOC</span>
<DD>
<pre>
⊢ ∀x s. rlist (SNOC x s) ⇔ x ∈ R ∧ rlist s
</pre>

<DT><span class="strong">ring_list_cons</span>
<DD>
<pre>
⊢ ∀r h t. rlist (h::t) ⇔ h ∈ R ∧ rlist t
</pre>

<DT><span class="strong">ring_list_from_genlist</span>
<DD>
<pre>
⊢ ∀r f. rfun f ⇒ ∀n. rlist (GENLIST f n)
</pre>

<DT><span class="strong">ring_list_from_genlist_ring_fun</span>
<DD>
<pre>
⊢ ∀r f. rfun f ⇒ ∀n g. rlist (GENLIST (f ∘ g) n)
</pre>

<DT><span class="strong">ring_list_front_last</span>
<DD>
<pre>
⊢ ∀s. rlist (FRONT s) ∧ LAST s ∈ R ⇒ rlist s
</pre>

<DT><span class="strong">ring_list_gen_from_ring_fun</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀f. rfun f ⇒ ∀x. x ∈ R ⇒ ∀n. rlist (GENLIST (λj. f j * x ** j) n)
</pre>

<DT><span class="strong">ring_list_nil</span>
<DD>
<pre>
⊢ ∀r. rlist [] ⇔ T
</pre>

<DT><span class="strong">ring_literal_11</span>
<DD>
<pre>
⊢ ∀f1 m01 m1 f2 m02 m2.
    <|carrier := f1; sum := m01; prod := m1|> =
    <|carrier := f2; sum := m02; prod := m2|> ⇔ f1 = f2 ∧ m01 = m02 ∧ m1 = m2
</pre>

<DT><span class="strong">ring_literal_nchotomy</span>
<DD>
<pre>
⊢ ∀r. ∃f m0 m. r = <|carrier := f; sum := m0; prod := m|>
</pre>

<DT><span class="strong">ring_mult_abelian_monoid</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ AbelianMonoid r.prod
</pre>

<DT><span class="strong">ring_mult_add</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀z y x.
        x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒
        x * (y + z) = x * y + x * z ∧ (y + z) * x = y * x + z * x
</pre>

<DT><span class="strong">ring_mult_add_neg</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x. x ∈ R ⇒ ∀n. $## n * x + -x = if n = 0 then -x else $## (n − 1) * x
</pre>

<DT><span class="strong">ring_mult_add_neg_assoc</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x y.
        x ∈ R ∧ y ∈ R ⇒
        ∀n. $## n * x + (-x + y) =
            if n = 0 then -x + y else $## (n − 1) * x + y
</pre>

<DT><span class="strong">ring_mult_add_neg_mult</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x. x ∈ R ⇒
          ∀m n.
            $## m * x + -($## n * x) =
            if m < n then -($## (n − m) * x) else $## (m − n) * x
</pre>

<DT><span class="strong">ring_mult_add_neg_mult_assoc</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x y.
        x ∈ R ∧ y ∈ R ⇒
        ∀m n.
          $## m * x + (-($## n * x) + y) =
          if m < n then -($## (n − m) * x) + y else $## (m − n) * x + y
</pre>

<DT><span class="strong">ring_mult_assoc</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ x * y * z = x * (y * z)
</pre>

<DT><span class="strong">ring_mult_assoc_comm</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ x * (y * z) = y * (x * z)
</pre>

<DT><span class="strong">ring_mult_comm</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ x * y = y * x
</pre>

<DT><span class="strong">ring_mult_divides</span>
<DD>
<pre>
⊢ ∀r p q x.
    Ring r ∧ p * q rdivides x ∧ p ∈ R ∧ q ∈ R ⇒ p rdivides x ∧ q rdivides x
</pre>

<DT><span class="strong">ring_mult_element</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ x * y ∈ R
</pre>

<DT><span class="strong">ring_mult_exp</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ ∀n. (x * y) ** n = x ** n * y ** n
</pre>

<DT><span class="strong">ring_mult_ladd</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ (y + z) * x = y * x + z * x
</pre>

<DT><span class="strong">ring_mult_lneg</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ -x * y = -(x * y)
</pre>

<DT><span class="strong">ring_mult_lone</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ #1 * x = x
</pre>

<DT><span class="strong">ring_mult_lsub</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ x * z − y * z = (x − y) * z
</pre>

<DT><span class="strong">ring_mult_lzero</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ #0 * x = #0
</pre>

<DT><span class="strong">ring_mult_monoid</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      Monoid r.prod ∧ r.prod.carrier = R ∧ ∀x y. x ∈ R ∧ y ∈ R ⇒ x * y = y * x
</pre>

<DT><span class="strong">ring_mult_monoid_rwt</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ Monoid r.prod ∧ r.prod.carrier = R
</pre>

<DT><span class="strong">ring_mult_neg_neg</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ -x * -y = x * y
</pre>

<DT><span class="strong">ring_mult_one_one</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ #1 * #1 = #1
</pre>

<DT><span class="strong">ring_mult_pair_diff</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x y p q.
        x ∈ R ∧ y ∈ R ∧ p ∈ R ∧ q ∈ R ⇒
        x * y − p * q = (x − p) * y + p * (y − q)
</pre>

<DT><span class="strong">ring_mult_pair_sub</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x y p q.
        x ∈ R ∧ y ∈ R ∧ p ∈ R ∧ q ∈ R ⇒
        x * y − p * q = (x − p) * (y − q) + (x − p) * q + p * (y − q)
</pre>

<DT><span class="strong">ring_mult_radd</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ x * (y + z) = x * y + x * z
</pre>

<DT><span class="strong">ring_mult_rneg</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ x * -y = -(x * y)
</pre>

<DT><span class="strong">ring_mult_rone</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ x * #1 = x
</pre>

<DT><span class="strong">ring_mult_rsub</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ x * y − x * z = x * (y − z)
</pre>

<DT><span class="strong">ring_mult_rzero</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ x * #0 = #0
</pre>

<DT><span class="strong">ring_mult_zero_zero</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ #0 * #0 = #0
</pre>

<DT><span class="strong">ring_nchotomy</span>
<DD>
<pre>
⊢ ∀rr. ∃f m m0. rr = ring f m m0
</pre>

<DT><span class="strong">ring_neg_add</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ -(x + y) = -x + -y
</pre>

<DT><span class="strong">ring_neg_add_comm</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ -(x + y) = -y + -x
</pre>

<DT><span class="strong">ring_neg_add_neg</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ -x + -x = -($## 2 * x)
</pre>

<DT><span class="strong">ring_neg_add_neg_assoc</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ -x + (-x + y) = -($## 2 * x) + y
</pre>

<DT><span class="strong">ring_neg_add_neg_mult</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀n. -x + -($## n * x) = -($## (n + 1) * x)
</pre>

<DT><span class="strong">ring_neg_add_neg_mult_assoc</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x y.
        x ∈ R ∧ y ∈ R ⇒ ∀n. -x + (-($## n * x) + y) = -($## (n + 1) * x) + y
</pre>

<DT><span class="strong">ring_neg_char_2</span>
<DD>
<pre>
⊢ ∀r. Ring r ∧ char r = 2 ⇒ ∀x. x ∈ R ⇒ -x = x
</pre>

<DT><span class="strong">ring_neg_element</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ -x ∈ R
</pre>

<DT><span class="strong">ring_neg_eq</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ (-x = -y ⇔ x = y)
</pre>

<DT><span class="strong">ring_neg_eq_swap</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ (-x = y ⇔ x = -y)
</pre>

<DT><span class="strong">ring_neg_eq_zero</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ (-x = #0 ⇔ x = #0)
</pre>

<DT><span class="strong">ring_neg_exp</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀n. -x ** n = if EVEN n then x ** n else -(x ** n)
</pre>

<DT><span class="strong">ring_neg_mult</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ -(x * y) = -x * y ∧ -(x * y) = x * -y
</pre>

<DT><span class="strong">ring_neg_mult_add_neg_mult</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x. x ∈ R ⇒ ∀m n. -($## m * x) + -($## n * x) = -($## (m + n) * x)
</pre>

<DT><span class="strong">ring_neg_mult_add_neg_mult_assoc</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x y.
        x ∈ R ∧ y ∈ R ⇒
        ∀m n. -($## m * x) + (-($## n * x) + y) = -($## (m + n) * x) + y
</pre>

<DT><span class="strong">ring_neg_neg</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ - -x = x
</pre>

<DT><span class="strong">ring_neg_nonzero</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R+ ⇒ -x ∈ R+
</pre>

<DT><span class="strong">ring_neg_one_eq_one</span>
<DD>
<pre>
⊢ ∀r. Ring r ∧ #1 ≠ #0 ⇒ (-#1 = #1 ⇔ char r = 2)
</pre>

<DT><span class="strong">ring_neg_square</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ -x ** 2 = x ** 2
</pre>

<DT><span class="strong">ring_neg_sub</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ -(x − y) = y − x
</pre>

<DT><span class="strong">ring_neg_zero</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ -#0 = #0
</pre>

<DT><span class="strong">ring_nonzero_element</span>
<DD>
<pre>
⊢ ∀r x. x ∈ R+ ⇒ x ∈ R
</pre>

<DT><span class="strong">ring_nonzero_eq</span>
<DD>
<pre>
⊢ ∀r x. x ∈ R+ ⇔ x ∈ R ∧ x ≠ #0
</pre>

<DT><span class="strong">ring_nonzero_mult_carrier</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ F* = R+
</pre>

<DT><span class="strong">ring_num_0</span>
<DD>
<pre>
⊢ ∀r. $## 0 = #0
</pre>

<DT><span class="strong">ring_num_1</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ $## 1 = #1
</pre>

<DT><span class="strong">ring_num_2</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ $## 2 = #1 + #1
</pre>

<DT><span class="strong">ring_num_SUC</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀n. $## (SUC n) = #1 + $## n
</pre>

<DT><span class="strong">ring_num_add</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀n k. $## (n + k) = $## n + $## k
</pre>

<DT><span class="strong">ring_num_add_assoc</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀m n. $## m + ($## n + x) = $## (m + n) + x
</pre>

<DT><span class="strong">ring_num_add_mult</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀m n. $## (m + n) * x = $## m * x + $## n * x
</pre>

<DT><span class="strong">ring_num_add_mult_assoc</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x y.
        x ∈ R ∧ y ∈ R ⇒
        ∀m n. $## (m + n) * x + y = $## m * x + ($## n * x + y)
</pre>

<DT><span class="strong">ring_num_all_zero</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ #1 = #0 ⇒ ∀c. $## c = #0
</pre>

<DT><span class="strong">ring_num_char_coprime_nonzero</span>
<DD>
<pre>
⊢ ∀r. Ring r ∧ #1 ≠ #0 ⇒ ∀c. coprime c (char r) ⇒ $## c ≠ #0
</pre>

<DT><span class="strong">ring_num_element</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀n. $## n ∈ R
</pre>

<DT><span class="strong">ring_num_eq</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀n m. n < char r ∧ m < char r ⇒ ($## n = $## m ⇔ n = m)
</pre>

<DT><span class="strong">ring_num_exp</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀m n. $## m ** n = $## (m ** n)
</pre>

<DT><span class="strong">ring_num_mod</span>
<DD>
<pre>
⊢ ∀r. Ring r ∧ 0 < char r ⇒ ∀n. $## n = $## (n MOD char r)
</pre>

<DT><span class="strong">ring_num_mult</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀m n. $## m * $## n = $## (m * n)
</pre>

<DT><span class="strong">ring_num_mult_assoc</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀m n x. x ∈ R ⇒ $## m * ($## n * x) = $## (m * n) * x
</pre>

<DT><span class="strong">ring_num_mult_element</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀n. $## n * x ∈ R
</pre>

<DT><span class="strong">ring_num_mult_exp</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀k m n. $## k * $## m ** n = $## (k * m ** n)
</pre>

<DT><span class="strong">ring_num_mult_neg</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀n. -($## n * x) = $## n * -x
</pre>

<DT><span class="strong">ring_num_mult_radd</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x y. x ∈ R ∧ y ∈ R ⇒ ∀n. $## n * (x + y) = $## n * x + $## n * y
</pre>

<DT><span class="strong">ring_num_mult_small</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x. x ∈ R ⇒
          #0 * x = #0 ∧ #1 * x = x ∧ $## 2 * x = x + x ∧
          $## 3 * x = $## 2 * x + x
</pre>

<DT><span class="strong">ring_num_mult_suc</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀n. $## (SUC n) * x = $## n * x + x
</pre>

<DT><span class="strong">ring_num_negative</span>
<DD>
<pre>
⊢ ∀r. Ring r ∧ 0 < char r ⇒ ∀z. ∃y x. y = $## x ∧ y + $## z = #0
</pre>

<DT><span class="strong">ring_num_one</span>
<DD>
<pre>
⊢ ∀r. $## 1 = #1 + #0
</pre>

<DT><span class="strong">ring_num_sub</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀n m. m < n ⇒ $## (n − m) = $## n − $## m
</pre>

<DT><span class="strong">ring_num_suc</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀n. $## (SUC n) = $## n + #1
</pre>

<DT><span class="strong">ring_one_element</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ #1 ∈ R
</pre>

<DT><span class="strong">ring_one_eq_zero</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ (#1 = #0 ⇔ R = {#0})
</pre>

<DT><span class="strong">ring_one_exp</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀n. #1 ** n = #1
</pre>

<DT><span class="strong">ring_one_unique</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀y. y ∈ R ⇒ ((∀x. x ∈ R ⇒ y * x = x ∨ x * y = x) ⇔ y = #1)
</pre>

<DT><span class="strong">ring_prime_divides_product</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀p. p ∈ R ⇒
          (rprime p ∧ p ∉ R* ⇔
           ∀b. FINITE_BAG b ∧ SET_OF_BAG b ⊆ R ∧ p rdivides GBAG r.prod b ⇒
               ∃x. x ⋲ b ∧ p rdivides x)
</pre>

<DT><span class="strong">ring_prime_iso</span>
<DD>
<pre>
⊢ ∀r r_ f. (r =r= r_) f ⇒ ∀p. p ∈ R ∧ rprime p ⇒ ring_prime r_ (f p)
</pre>

<DT><span class="strong">ring_product_factors_divide</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀b. FINITE_BAG b ⇒
          SET_OF_BAG b ⊆ R ∧ GBAG r.prod b rdivides x ⇒
          ∀y. y ⋲ b ⇒ y rdivides x
</pre>

<DT><span class="strong">ring_single_add_mult</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀n. x + $## n * x = $## (n + 1) * x
</pre>

<DT><span class="strong">ring_single_add_mult_assoc</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x y. x ∈ R ∧ y ∈ R ⇒ ∀n. x + ($## n * x + y) = $## (n + 1) * x + y
</pre>

<DT><span class="strong">ring_single_add_neg_mult</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x. x ∈ R ⇒
          ∀n. x + -($## n * x) = if n = 0 then x else -($## (n − 1) * x)
</pre>

<DT><span class="strong">ring_single_add_neg_mult_assoc</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x y.
        x ∈ R ∧ y ∈ R ⇒
        ∀n. x + (-($## n * x) + y) =
            if n = 0 then x + y else -($## (n − 1) * x) + y
</pre>

<DT><span class="strong">ring_single_add_single</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ x + x = $## 2 * x
</pre>

<DT><span class="strong">ring_single_add_single_assoc</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ x + (x + y) = $## 2 * x + y
</pre>

<DT><span class="strong">ring_single_mult_exp</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀n. x * x ** n = x ** (n + 1)
</pre>

<DT><span class="strong">ring_single_mult_exp_assoc</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ ∀n. x * (x ** n * y) = x ** (n + 1) * y
</pre>

<DT><span class="strong">ring_single_mult_single</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ x * x = x ** 2
</pre>

<DT><span class="strong">ring_single_mult_single_assoc</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ x * (x * y) = x ** 2 * y
</pre>

<DT><span class="strong">ring_sub_add</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ x − y + y = x
</pre>

<DT><span class="strong">ring_sub_element</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ x − y ∈ R
</pre>

<DT><span class="strong">ring_sub_eq</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ⇒ x − x = #0
</pre>

<DT><span class="strong">ring_sub_eq_add</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ (x − y = z ⇔ x = y + z)
</pre>

<DT><span class="strong">ring_sub_eq_zero</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ (x − y = #0 ⇔ x = y)
</pre>

<DT><span class="strong">ring_sub_lcancel</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ (x − y = x − z ⇔ y = z)
</pre>

<DT><span class="strong">ring_sub_pair_reduce</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ x + z − (y + z) = x − y
</pre>

<DT><span class="strong">ring_sub_rcancel</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ⇒ (y − x = z − x ⇔ y = z)
</pre>

<DT><span class="strong">ring_sub_zero</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ x − #0 = x
</pre>

<DT><span class="strong">ring_sum_SNOC</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀k s. k ∈ R ∧ rlist s ⇒ rsum (SNOC k s) = rsum s + k
</pre>

<DT><span class="strong">ring_sum_append</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀s t. rlist s ∧ rlist t ⇒ rsum (s ++ t) = rsum s + rsum t
</pre>

<DT><span class="strong">ring_sum_cons</span>
<DD>
<pre>
⊢ ∀r h t. rsum (h::t) = h + rsum t
</pre>

<DT><span class="strong">ring_sum_decompose_first</span>
<DD>
<pre>
⊢ ∀r f n. rsum (GENLIST f (SUC n)) = f 0 + rsum (GENLIST (f ∘ SUC) n)
</pre>

<DT><span class="strong">ring_sum_decompose_first_last</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀f n.
        rfun f ∧ 0 < n ⇒
        rsum (GENLIST f (SUC n)) =
        f 0 + rsum (GENLIST (f ∘ SUC) (PRE n)) + f n
</pre>

<DT><span class="strong">ring_sum_decompose_last</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀f n. rfun f ⇒ rsum (GENLIST f (SUC n)) = rsum (GENLIST f n) + f n
</pre>

<DT><span class="strong">ring_sum_element</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀s. rlist s ⇒ rsum s ∈ R
</pre>

<DT><span class="strong">ring_sum_freshman_all</span>
<DD>
<pre>
⊢ ∀r. Ring r ∧ prime (char r) ⇒
      ∀f. rfun f ⇒
          ∀x. x ∈ R ⇒
              ∀n k.
                rsum (GENLIST (λj. f j * x ** j) n) ** char r ** k =
                rsum (GENLIST (λj. (f j * x ** j) ** char r ** k) n)
</pre>

<DT><span class="strong">ring_sum_freshman_thm</span>
<DD>
<pre>
⊢ ∀r. Ring r ∧ prime (char r) ⇒
      ∀f. rfun f ⇒
          ∀x. x ∈ R ⇒
              ∀n. rsum (GENLIST (λj. f j * x ** j) n) ** char r =
                  rsum (GENLIST (λj. (f j * x ** j) ** char r) n)
</pre>

<DT><span class="strong">ring_sum_fun_zero</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀f. rfun f ⇒
          ∀n. (∀k. 0 < k ∧ k < n ⇒ f k = #0) ⇒
              rsum (MAP f (GENLIST SUC (PRE n))) = #0
</pre>

<DT><span class="strong">ring_sum_genlist_add</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀a b.
        rfun a ∧ rfun b ⇒
        ∀n. rsum (GENLIST a n) + rsum (GENLIST b n) =
            rsum (GENLIST (λk. a k + b k) n)
</pre>

<DT><span class="strong">ring_sum_genlist_append</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀a b.
        rfun a ∧ rfun b ⇒
        ∀n. rsum (GENLIST a n ++ GENLIST b n) =
            rsum (GENLIST (λk. a k + b k) n)
</pre>

<DT><span class="strong">ring_sum_genlist_const</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ ∀n. rsum (GENLIST (K x) n) = $## n * x
</pre>

<DT><span class="strong">ring_sum_genlist_sum</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀f. rfun f ⇒
          ∀n m.
            rsum (GENLIST f (n + m)) =
            rsum (GENLIST f m) + rsum (GENLIST (λk. f (k + m)) n)
</pre>

<DT><span class="strong">ring_sum_mult</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀k s. k ∈ R ∧ rlist s ⇒ k * rsum s = rsum (MAP (λx. k * x) s)
</pre>

<DT><span class="strong">ring_sum_mult_ladd</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀m n s.
        m ∈ R ∧ n ∈ R ∧ rlist s ⇒
        (m + n) * rsum s = rsum (MAP (λx. m * x) s) + rsum (MAP (λx. n * x) s)
</pre>

<DT><span class="strong">ring_sum_nil</span>
<DD>
<pre>
⊢ ∀r. rsum [] = #0
</pre>

<DT><span class="strong">ring_sum_sing</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ rsum [x] = x
</pre>

<DT><span class="strong">ring_sum_zero</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀n. r.sum.exp #0 n = #0
</pre>

<DT><span class="strong">ring_unit_element</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. unit x ⇒ x ∈ R
</pre>

<DT><span class="strong">ring_unit_has_inv</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. unit x ⇒ unit ( |/ x)
</pre>

<DT><span class="strong">ring_unit_inv_element</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. unit x ⇒ |/ x ∈ R
</pre>

<DT><span class="strong">ring_unit_inv_inv</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀u. unit u ⇒ u = |/ ( |/ u)
</pre>

<DT><span class="strong">ring_unit_inv_nonzero</span>
<DD>
<pre>
⊢ ∀r. Ring r ∧ #1 ≠ #0 ⇒ ∀x. unit x ⇒ |/ x ≠ #0
</pre>

<DT><span class="strong">ring_unit_linv</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. unit x ⇒ |/ x * x = #1
</pre>

<DT><span class="strong">ring_unit_linv_inv</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀u v. unit u ∧ v ∈ R ∧ |/ u * v = #1 ⇒ u = v
</pre>

<DT><span class="strong">ring_unit_linv_unique</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀u v. u ∈ R ∧ unit v ∧ u * v = #1 ⇒ u = |/ v
</pre>

<DT><span class="strong">ring_unit_mult_eq_unit</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ⇒ (unit (x * y) ⇔ unit x ∧ unit y)
</pre>

<DT><span class="strong">ring_unit_mult_unit</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀u v. unit u ∧ unit v ⇒ unit (u * v)
</pre>

<DT><span class="strong">ring_unit_mult_zero</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. unit x ∧ y ∈ R ⇒ (x * y = #0 ⇔ y = #0)
</pre>

<DT><span class="strong">ring_unit_neg</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. unit x ⇒ unit (-x)
</pre>

<DT><span class="strong">ring_unit_nonzero</span>
<DD>
<pre>
⊢ ∀r. Ring r ∧ #1 ≠ #0 ⇒ ∀x. unit x ⇒ x ≠ #0
</pre>

<DT><span class="strong">ring_unit_one</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ unit #1
</pre>

<DT><span class="strong">ring_unit_property</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀u. unit u ⇔ u ∈ R ∧ ∃v. v ∈ R ∧ u * v = #1
</pre>

<DT><span class="strong">ring_unit_rinv</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. unit x ⇒ x * |/ x = #1
</pre>

<DT><span class="strong">ring_unit_rinv_inv</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀u v. u ∈ R ∧ unit v ∧ u * |/ v = #1 ⇒ u = v
</pre>

<DT><span class="strong">ring_unit_rinv_unique</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀u v. unit u ∧ v ∈ R ∧ u * v = #1 ⇒ v = |/ u
</pre>

<DT><span class="strong">ring_unit_zero</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ (unit #0 ⇔ #1 = #0)
</pre>

<DT><span class="strong">ring_units_abelain_group</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ AbelianGroup r*
</pre>

<DT><span class="strong">ring_units_element</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. unit x ⇒ x ∈ R
</pre>

<DT><span class="strong">ring_units_group</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ Group r*
</pre>

<DT><span class="strong">ring_units_has_one</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ unit #1
</pre>

<DT><span class="strong">ring_units_has_zero</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ (unit #0 ⇔ #1 = #0)
</pre>

<DT><span class="strong">ring_units_property</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ r*.op = $* ∧ r*.id = #1
</pre>

<DT><span class="strong">ring_updates_eq_literal</span>
<DD>
<pre>
⊢ ∀r f m0 m.
    r with <|carrier := f; sum := m0; prod := m|> =
    <|carrier := f; sum := m0; prod := m|>
</pre>

<DT><span class="strong">ring_zero_divides</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ (#0 rdivides x ⇔ x = #0)
</pre>

<DT><span class="strong">ring_zero_element</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ #0 ∈ R
</pre>

<DT><span class="strong">ring_zero_exp</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀n. #0 ** n = if n = 0 then #1 else #0
</pre>

<DT><span class="strong">ring_zero_fix</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ (x + x = x ⇔ x = #0)
</pre>

<DT><span class="strong">ring_zero_sub</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ #0 − x = -x
</pre>

<DT><span class="strong">ring_zero_unique</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒
      ∀x y. x ∈ R ∧ y ∈ R ⇒ (y + x = x ⇔ y = #0) ∧ (x + y = x ⇔ y = #0)
</pre>

<DT><span class="strong">subring_I_antisym</span>
<DD>
<pre>
⊢ ∀r s. subring s r ∧ subring r s ⇒ RingIso I s r
</pre>

<DT><span class="strong">subring_add</span>
<DD>
<pre>
⊢ ∀r s. s ≤ r ⇒ ∀x y. x ∈ B ∧ y ∈ B ⇒ s.sum.op x y = x + y
</pre>

<DT><span class="strong">subring_by_subgroup_submonoid</span>
<DD>
<pre>
⊢ ∀r s.
    s ≤ r ⇔ Ring r ∧ Ring s ∧ subgroup s.sum r.sum ∧ submonoid s.prod r.prod
</pre>

<DT><span class="strong">subring_carrier_antisym</span>
<DD>
<pre>
⊢ ∀r s. subring s r ∧ R ⊆ B ⇒ RingIso I s r
</pre>

<DT><span class="strong">subring_carrier_finite</span>
<DD>
<pre>
⊢ ∀r s. FiniteRing r ∧ subring s r ⇒ FINITE B
</pre>

<DT><span class="strong">subring_carrier_subset</span>
<DD>
<pre>
⊢ ∀r s. subring s r ⇒ B ⊆ R
</pre>

<DT><span class="strong">subring_char</span>
<DD>
<pre>
⊢ ∀r s. s ≤ r ⇒ char s = char r
</pre>

<DT><span class="strong">subring_char_divides</span>
<DD>
<pre>
⊢ ∀r s. s ≤ r ⇒ char r divides char s
</pre>

<DT><span class="strong">subring_element</span>
<DD>
<pre>
⊢ ∀r s. subring s r ⇒ ∀x. x ∈ B ⇒ x ∈ R
</pre>

<DT><span class="strong">subring_element_alt</span>
<DD>
<pre>
⊢ ∀r s. s ≤ r ⇒ ∀x. x ∈ B ⇒ x ∈ R
</pre>

<DT><span class="strong">subring_exp</span>
<DD>
<pre>
⊢ ∀r s. s ≤ r ⇒ ∀x. x ∈ B ⇒ ∀n. s.prod.exp x n = x ** n
</pre>

<DT><span class="strong">subring_finite_ring</span>
<DD>
<pre>
⊢ ∀r s. FiniteRing r ∧ s ≤ r ⇒ FiniteRing s
</pre>

<DT><span class="strong">subring_homo_homo</span>
<DD>
<pre>
⊢ ∀r s r_ f. subring s r ∧ RingHomo f r r_ ⇒ RingHomo f s r_
</pre>

<DT><span class="strong">subring_ids</span>
<DD>
<pre>
⊢ ∀r s. s ≤ r ⇒ s.sum.id = #0 ∧ s.prod.id = #1
</pre>

<DT><span class="strong">subring_mult</span>
<DD>
<pre>
⊢ ∀r s. s ≤ r ⇒ ∀x y. x ∈ B ∧ y ∈ B ⇒ s.prod.op x y = x * y
</pre>

<DT><span class="strong">subring_neg</span>
<DD>
<pre>
⊢ ∀r s. s ≤ r ⇒ ∀x. x ∈ B ⇒ s.sum.inv x = -x
</pre>

<DT><span class="strong">subring_num</span>
<DD>
<pre>
⊢ ∀r s. s ≤ r ⇒ ∀n. s.sum.exp s.prod.id n = $## n
</pre>

<DT><span class="strong">subring_one</span>
<DD>
<pre>
⊢ ∀r s. s ≤ r ⇒ s.prod.id = #1
</pre>

<DT><span class="strong">subring_prod_submonoid</span>
<DD>
<pre>
⊢ ∀r s. subring s r ⇒ submonoid s.prod r.prod
</pre>

<DT><span class="strong">subring_property</span>
<DD>
<pre>
⊢ ∀r s.
    Ring s ∧ subring s r ⇒
    ∀x y. x ∈ B ∧ y ∈ B ⇒ s.sum.op x y = x + y ∧ s.prod.op x y = x * y
</pre>

<DT><span class="strong">subring_refl</span>
<DD>
<pre>
⊢ ∀r. subring r r
</pre>

<DT><span class="strong">subring_ring_iso_compose</span>
<DD>
<pre>
⊢ ∀r s r_ f. subring s r ∧ RingIso f r r_ ⇒ RingHomo f s r_
</pre>

<DT><span class="strong">subring_ring_iso_ring_homo_subring</span>
<DD>
<pre>
⊢ ∀r s r_ f. s ≤ r ∧ (r =r= r_) f ⇒ ring_homo_image f s r_ ≤ r_
</pre>

<DT><span class="strong">subring_sub</span>
<DD>
<pre>
⊢ ∀r s. s ≤ r ⇒ ∀x y. x ∈ B ∧ y ∈ B ⇒ ring_sub s x y = x − y
</pre>

<DT><span class="strong">subring_sum_subgroup</span>
<DD>
<pre>
⊢ ∀r s. subring s r ⇒ subgroup s.sum r.sum
</pre>

<DT><span class="strong">subring_trans</span>
<DD>
<pre>
⊢ ∀r s t. subring r s ∧ subring s t ⇒ subring r t
</pre>

<DT><span class="strong">subring_unit</span>
<DD>
<pre>
⊢ ∀r s. s ≤ r ⇒ ∀x. Unit s x ⇒ unit x
</pre>

<DT><span class="strong">subring_unit_inv</span>
<DD>
<pre>
⊢ ∀r s. s ≤ r ⇒ ∀x. Unit s x ⇒ Inv s x = |/ x
</pre>

<DT><span class="strong">subring_unit_inv_element</span>
<DD>
<pre>
⊢ ∀r s. s ≤ r ⇒ ∀x. Unit s x ⇒ Inv s x ∈ B
</pre>

<DT><span class="strong">subring_unit_inv_nonzero</span>
<DD>
<pre>
⊢ ∀r s. s ≤ r ∧ #1 ≠ #0 ⇒ ∀x. Unit s x ⇒ Inv s x ≠ #0
</pre>

<DT><span class="strong">subring_unit_nonzero</span>
<DD>
<pre>
⊢ ∀r s. s ≤ r ∧ #1 ≠ #0 ⇒ ∀x. Unit s x ⇒ x ≠ #0
</pre>

<DT><span class="strong">subring_zero</span>
<DD>
<pre>
⊢ ∀r s. s ≤ r ⇒ s.sum.id = #0
</pre>

<DT><span class="strong">symdiff_eval</span>
<DD>
<pre>
⊢ symdiff_set.carrier = 𝕌(:α -> bool) ∧
  (∀x y. symdiff_set.op x y = x ∪ y DIFF x ∩ y) ∧ symdiff_set.id = ∅
</pre>

<DT><span class="strong">symdiff_set_inter_char</span>
<DD>
<pre>
⊢ char symdiff_set_inter = 2
</pre>

<DT><span class="strong">symdiff_set_inter_ring</span>
<DD>
<pre>
⊢ Ring symdiff_set_inter
</pre>

<DT><span class="strong">symdiff_univ_univ_eq_empty</span>
<DD>
<pre>
⊢ symdiff 𝕌(:α) 𝕌(:α) = ∅
</pre>

<DT><span class="strong">trivial_char</span>
<DD>
<pre>
⊢ ∀z. char (trivial_ring z) = 1
</pre>

<DT><span class="strong">trivial_integral_domain</span>
<DD>
<pre>
⊢ ∀e0 e1. e0 ≠ e1 ⇒ FiniteIntegralDomain (trivial_integal_domain e0 e1)
</pre>

<DT><span class="strong">trivial_ring</span>
<DD>
<pre>
⊢ ∀z. FiniteRing (trivial_ring z)
</pre>

<DT><span class="strong">trivial_ring_thm</span>
<DD>
<pre>
⊢ ∀z. Ring (trivial_ring z)
</pre>

<DT><span class="strong">unit_eq_refl</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x. x ∈ R ⇒ x =~ x
</pre>

<DT><span class="strong">unit_eq_sym</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y. x ∈ R ∧ y ∈ R ∧ x =~ y ⇒ y =~ x
</pre>

<DT><span class="strong">unit_eq_trans</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ ∀x y z. x ∈ R ∧ y ∈ R ∧ z ∈ R ∧ x =~ y ∧ y =~ z ⇒ x =~ z
</pre>

<DT><span class="strong">zero_ideal_ideal</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ <#0> << r
</pre>

<DT><span class="strong">zero_ideal_sing</span>
<DD>
<pre>
⊢ ∀r. Ring r ⇒ <#0>.carrier = {#0}
</pre>

</DL>



<hr>
</body>
</html>
