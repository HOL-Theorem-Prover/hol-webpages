<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: itree</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "itree"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "holTheory.html"><span class="strong">hol</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Type <th> Arity<tr><td> <span class="strong">itree</span> <td> 3
    <tr><td> <span class="strong">itree_el</span> <td> 2
    <tr><td> <span class="strong">itree_next</span> <td> 4
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">Div</span>
    <td>
    :(α, β, γ) itree$itree
    <tr><td>
    <span class="strong">Div'</span>
    <td>
    :(α, ε, ς, 'seed) itree$itree_next
    <tr><td>
    <span class="strong">Div_rep</span>
    <td>
    :α list -> (β, γ) itree$itree_el
    <tr><td>
    <span class="strong">Event</span>
    <td>
    :ε -> (ε, ς) itree$itree_el
    <tr><td> <span class="strong">Ret</span> <td> :γ -> (α, β, γ) itree$itree
    <tr><td>
    <span class="strong">Ret'</span>
    <td>
    :ς -> (α, ε, ς, 'seed) itree$itree_next
    <tr><td>
    <span class="strong">Ret_rep</span>
    <td>
    :ς -> α list -> (β, ς) itree$itree_el
    <tr><td>
    <span class="strong">Return</span>
    <td>
    :ς -> (ε, ς) itree$itree_el
    <tr><td> <span class="strong">Stuck</span> <td> :(ε, ς) itree$itree_el
    <tr><td>
    <span class="strong">Vis</span>
    <td>
    :β -> (α -> (α, β, γ) itree$itree) -> (α, β, γ) itree$itree
    <tr><td>
    <span class="strong">Vis'</span>
    <td>
    :ε -> (α -> 'seed) -> (α, ε, ς, 'seed) itree$itree_next
    <tr><td>
    <span class="strong">Vis_rep</span>
    <td>
    :β ->
    (α -> α list -> (β, γ) itree$itree_el) -> α list -> (β, γ) itree$itree_el
    <tr><td>
    <span class="strong">at_path</span>
    <td>
    :(α, β, γ) itree$itree -> (β # α) list -> γ -> bool
    <tr><td>
    <span class="strong">ibind</span>
    <td>
    :(α, β, δ) itree$itree ->
    (δ -> (α, β, γ) itree$itree) -> (α, β, γ) itree$itree
    <tr><td>
    <span class="strong">ievery</span>
    <td>
    :(α -> bool) -> (β, γ, α) itree$itree -> bool
    <tr><td>
    <span class="strong">iexists</span>
    <td>
    :(α -> bool) -> (β, γ, α) itree$itree -> bool
    <tr><td>
    <span class="strong">ifinite</span>
    <td>
    :(α, β, γ) itree$itree -> bool
    <tr><td>
    <span class="strong">iflat</span>
    <td>
    :(α, β, (α, β, γ) itree$itree) itree$itree -> (α, β, γ) itree$itree
    <tr><td>
    <span class="strong">imap</span>
    <td>
    :(δ -> γ) -> (α, β, δ) itree$itree -> (α, β, γ) itree$itree
    <tr><td>
    <span class="strong">iset</span>
    <td>
    :(β, γ, α) itree$itree -> α -> bool
    <tr><td>
    <span class="strong">itree_CASE</span>
    <td>
    :(α, ε, ς) itree$itree ->
    (ς -> β) -> β -> (ε -> (α -> (α, ε, ς) itree$itree) -> β) -> β
    <tr><td>
    <span class="strong">itree_abs</span>
    <td>
    :(α list -> (ε, ς) itree$itree_el) -> (α, ε, ς) itree$itree
    <tr><td>
    <span class="strong">itree_el</span>
    <td>
    :(γ, α, β) itree$itree -> γ list -> (α, β) itree$itree_el
    <tr><td>
    <span class="strong">itree_el_CASE</span>
    <td>
    :(ε, ς) itree$itree_el -> (ε -> α) -> (ς -> α) -> α -> α
    <tr><td>
    <span class="strong">itree_el_size</span>
    <td>
    :(ε -> num) -> (ς -> num) -> (ε, ς) itree$itree_el -> num
    <tr><td>
    <span class="strong">itree_next_CASE</span>
    <td>
    :(α, ε, ς, 'seed) itree$itree_next ->
    (ς -> β) -> β -> (ε -> (α -> 'seed) -> β) -> β
    <tr><td>
    <span class="strong">itree_next_size</span>
    <td>
    :(α -> num) ->
    (ε -> num) ->
    (ς -> num) -> ('seed -> num) -> (α, ε, ς, 'seed) itree$itree_next -> num
    <tr><td>
    <span class="strong">itree_rep</span>
    <td>
    :(α, ε, ς) itree$itree -> α list -> (ε, ς) itree$itree_el
    <tr><td>
    <span class="strong">itree_rep_ok</span>
    <td>
    :(α list -> (ε, ς) itree$itree_el) -> bool
    <tr><td>
    <span class="strong">itree_unfold</span>
    <td>
    :(δ -> (α, β, γ, δ) itree$itree_next) -> δ -> (α, β, γ) itree$itree
    <tr><td>
    <span class="strong">itree_unfold_err</span>
    <td>
    :(ε -> (β, γ, δ, ε) itree$itree_next) ->
    (γ -> β -> bool) # (γ -> α -> δ) # (γ -> δ) ->
    ε -> (α + β, γ, δ) itree$itree
    <tr><td>
    <span class="strong">itree_unfold_err_path</span>
    <td>
    :(γ -> (δ, α, β, γ) itree$itree_next) ->
    (α -> δ -> bool) # (α -> ε -> β) # (α -> β) ->
    γ -> (ε + δ) list -> (α, β) itree$itree_el
    <tr><td>
    <span class="strong">itree_unfold_path</span>
    <td>
    :(γ -> (δ, α, β, γ) itree$itree_next) ->
    γ -> δ list -> (α, β) itree$itree_el
    <tr><td>
    <span class="strong">itruncate</span>
    <td>
    :num -> (α, β, γ) itree$itree -> (α, β, γ) itree$itree
    <tr><td>
    <span class="strong">path_ok</span>
    <td>
    :α list -> (α list -> (ε, ς) itree$itree_el) -> bool
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">@tempat_path_def</span>
<DD>
<pre>
⊢ at_path =
  (λa0 a1 a2.
       ∀at_path'.
         (∀a0 a1 a2.
            a0 = ireturn a2 ∧ a1 = [] ∨
            (∃f i ov p. a0 = Vis ov f ∧ a1 = (ov,i)::p ∧ at_path' (f i) p a2) ⇒
            at_path' a0 a1 a2) ⇒
         at_path' a0 a1 a2)
</pre>

<DT><span class="strong">@tempievery_def</span>
<DD>
<pre>
⊢ ievery =
  (λP a0.
       ∃ievery'.
         ievery' a0 ∧
         ∀a0.
           ievery' a0 ⇒
           a0 = Div ∨ (∃e. a0 = ireturn e ∧ P e) ∨
           ∃f ov. a0 = Vis ov f ∧ ∀iv. ievery' (f iv))
</pre>

<DT><span class="strong">@tempiexists_def</span>
<DD>
<pre>
⊢ iexists =
  (λP a0.
       ∀iexists'.
         (∀a0.
            (∃e. a0 = ireturn e ∧ P e) ∨
            (∃f ov. a0 = Vis ov f ∧ ∃iv. iexists' (f iv)) ⇒
            iexists' a0) ⇒
         iexists' a0)
</pre>

<DT><span class="strong">@tempifinite_def</span>
<DD>
<pre>
⊢ ifinite =
  (λa0.
       ∀ifinite'.
         (∀a0.
            (∃e. a0 = ireturn e) ∨ a0 = Div ∨
            (∃f ov. a0 = Vis ov f ∧ ∀iv. ifinite' (f iv)) ⇒
            ifinite' a0) ⇒
         ifinite' a0)
</pre>

<DT><span class="strong">@tempiset_def</span>
<DD>
<pre>
⊢ iset =
  (λa0 a1.
       ∀iset'.
         (∀a0 a1.
            a0 = ireturn a1 ∨ (∃f i ov. a0 = Vis ov f ∧ iset' (f i) a1) ⇒
            iset' a0 a1) ⇒
         iset' a0 a1)
</pre>

<DT><span class="strong">ibind_def</span>
<DD>
<pre>
⊢ ∀itr f. ibind itr f = iflat (imap f itr)
</pre>

<DT><span class="strong">iflat_def</span>
<DD>
<pre>
⊢ ∀itr.
    iflat itr =
    itree_unfold
      (λx.
           case x of
             INL (ireturn (ireturn r0)) => Ret' r0
           | INL (ireturn Div) => Div'
           | INL (ireturn (Vis e f)) => Vis' e (λi. INR (f i))
           | INL Div => Div'
           | INL (Vis e f) => Vis' e (λi. INL (f i))
           | INR (ireturn r) => Ret' r
           | INR Div => Div'
           | INR (Vis e' f') => Vis' e' (λi. INR (f' i))) (INL itr)
</pre>

<DT><span class="strong">imap_def</span>
<DD>
<pre>
⊢ ∀g itr.
    imap g itr =
    itree_unfold (λx. itree_CASE x (λr. Ret' (g r)) Div' (λe f. Vis' e f)) itr
</pre>

<DT><span class="strong">itree_TY_DEF</span>
<DD>
<pre>
⊢ ∃rep. TYPE_DEFINITION itree_rep_ok rep
</pre>

<DT><span class="strong">itree_el_case_def</span>
<DD>
<pre>
⊢ (∀a f f1 v. itree_el_CASE (Event a) f f1 v = f a) ∧
  (∀a f f1 v. itree_el_CASE (Return a) f f1 v = f1 a) ∧
  ∀f f1 v. itree_el_CASE Stuck f f1 v = v
</pre>

<DT><span class="strong">itree_el_size_def</span>
<DD>
<pre>
⊢ (∀f f1 a. itree_el_size f f1 (Event a) = 1 + f a) ∧
  (∀f f1 a. itree_el_size f f1 (Return a) = 1 + f1 a) ∧
  ∀f f1. itree_el_size f f1 Stuck = 0
</pre>

<DT><span class="strong">itree_next_case_def</span>
<DD>
<pre>
⊢ (∀a f v f1. itree_next_CASE (Ret' a) f v f1 = f a) ∧
  (∀f v f1. itree_next_CASE Div' f v f1 = v) ∧
  ∀a0 a1 f v f1. itree_next_CASE (Vis' a0 a1) f v f1 = f1 a0 a1
</pre>

<DT><span class="strong">itree_next_size_def</span>
<DD>
<pre>
⊢ (∀f f1 f2 f3 a. itree_next_size f f1 f2 f3 (Ret' a) = 1 + f2 a) ∧
  (∀f f1 f2 f3. itree_next_size f f1 f2 f3 Div' = 0) ∧
  ∀f f1 f2 f3 a0 a1. itree_next_size f f1 f2 f3 (Vis' a0 a1) = 1 + f1 a0
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">Ret_11</span>
<DD>
<pre>
⊢ ∀x y. ireturn x = ireturn y ⇔ x = y
</pre>

<DT><span class="strong">Vis_11</span>
<DD>
<pre>
⊢ ∀x f y g. Vis x f = Vis y g ⇔ x = y ∧ f = g
</pre>

<DT><span class="strong">at_path_cases</span>
<DD>
<pre>
⊢ ∀a0 a1 a2.
    at_path a0 a1 a2 ⇔
    a0 = ireturn a2 ∧ a1 = [] ∨
    ∃f i ov p. a0 = Vis ov f ∧ a1 = (ov,i)::p ∧ at_path (f i) p a2
</pre>

<DT><span class="strong">at_path_implies_iset</span>
<DD>
<pre>
⊢ at_path itree p e ⇒ iset itree e
</pre>

<DT><span class="strong">at_path_ind</span>
<DD>
<pre>
⊢ ∀at_path'.
    (∀e. at_path' (ireturn e) [] e) ∧
    (∀e f i ov p. at_path' (f i) p e ⇒ at_path' (Vis ov f) ((ov,i)::p) e) ⇒
    ∀a0 a1 a2. at_path a0 a1 a2 ⇒ at_path' a0 a1 a2
</pre>

<DT><span class="strong">at_path_ret</span>
<DD>
<pre>
⊢ ∀e. at_path (ireturn e) [] e
</pre>

<DT><span class="strong">at_path_rules</span>
<DD>
<pre>
⊢ (∀e. at_path (ireturn e) [] e) ∧
  ∀e f i ov p. at_path (f i) p e ⇒ at_path (Vis ov f) ((ov,i)::p) e
</pre>

<DT><span class="strong">at_path_strongind</span>
<DD>
<pre>
⊢ ∀at_path'.
    (∀e. at_path' (ireturn e) [] e) ∧
    (∀e f i ov p.
       at_path (f i) p e ∧ at_path' (f i) p e ⇒
       at_path' (Vis ov f) ((ov,i)::p) e) ⇒
    ∀a0 a1 a2. at_path a0 a1 a2 ⇒ at_path' a0 a1 a2
</pre>

<DT><span class="strong">at_path_thm</span>
<DD>
<pre>
⊢ (at_path Div p e ⇔ F) ∧ (at_path (ireturn e) p a ⇔ p = [] ∧ a = e) ∧
  (at_path (Vis ov f) p e ⇔ ∃i l. p = (ov,i)::l ∧ at_path (f i) l e)
</pre>

<DT><span class="strong">at_path_vis</span>
<DD>
<pre>
⊢ ∀e f i ov p. at_path (f i) p e ⇒ at_path (Vis ov f) ((ov,i)::p) e
</pre>

<DT><span class="strong">datatype_itree</span>
<DD>
<pre>
⊢ DATATYPE (itree ireturn Div Vis)
</pre>

<DT><span class="strong">datatype_itree_el</span>
<DD>
<pre>
⊢ DATATYPE (itree_el Event Return Stuck)
</pre>

<DT><span class="strong">datatype_itree_next</span>
<DD>
<pre>
⊢ DATATYPE (itree_next Ret' Div' Vis')
</pre>

<DT><span class="strong">ibind_assoc</span>
<DD>
<pre>
⊢ ibind itr (λx. ibind (f x) g) = ibind (ibind itr f) g
</pre>

<DT><span class="strong">ibind_eq_div</span>
<DD>
<pre>
⊢ ibind itr f = Div ⇔ itr = Div ∨ ∃x. itr = ireturn x ∧ f x = Div
</pre>

<DT><span class="strong">ibind_eq_ret</span>
<DD>
<pre>
⊢ ibind itr f = ireturn v ⇔ ∃v'. itr = ireturn v' ∧ f v' = ireturn v
</pre>

<DT><span class="strong">ibind_eq_vis</span>
<DD>
<pre>
⊢ ibind itr f = Vis rv g ⇔
  (∃h. itr = Vis rv h ∧ iflat ∘ imap f ∘ h = g) ∨
  ∃x. itr = ireturn x ∧ f x = Vis rv g
</pre>

<DT><span class="strong">ibind_left_id</span>
<DD>
<pre>
⊢ ibind (ireturn itr) f = f itr
</pre>

<DT><span class="strong">ibind_right_id</span>
<DD>
<pre>
⊢ ibind itr ireturn = itr
</pre>

<DT><span class="strong">ievery_cases</span>
<DD>
<pre>
⊢ ∀P a0.
    ievery P a0 ⇔
    a0 = Div ∨ (∃e. a0 = ireturn e ∧ P e) ∨
    ∃f ov. a0 = Vis ov f ∧ ∀iv. ievery P (f iv)
</pre>

<DT><span class="strong">ievery_coind</span>
<DD>
<pre>
⊢ ∀P ievery'.
    (∀a0.
       ievery' a0 ⇒
       a0 = Div ∨ (∃e. a0 = ireturn e ∧ P e) ∨
       ∃f ov. a0 = Vis ov f ∧ ∀iv. ievery' (f iv)) ⇒
    ∀a0. ievery' a0 ⇒ ievery P a0
</pre>

<DT><span class="strong">ievery_div</span>
<DD>
<pre>
⊢ ∀P. ievery P Div
</pre>

<DT><span class="strong">ievery_ret</span>
<DD>
<pre>
⊢ ∀P e. P e ⇒ ievery P (ireturn e)
</pre>

<DT><span class="strong">ievery_rules</span>
<DD>
<pre>
⊢ ∀P. ievery P Div ∧ (∀e. P e ⇒ ievery P (ireturn e)) ∧
      ∀f ov. (∀iv. ievery P (f iv)) ⇒ ievery P (Vis ov f)
</pre>

<DT><span class="strong">ievery_set</span>
<DD>
<pre>
⊢ ∀itr. ievery P itr ⇔ ∀rv. iset itr rv ⇒ P rv
</pre>

<DT><span class="strong">ievery_thm</span>
<DD>
<pre>
⊢ (ievery P Div ⇔ T) ∧ (ievery P (ireturn e) ⇔ P e) ∧
  (ievery P (Vis ov f) ⇔ ∀iv. ievery P (f iv))
</pre>

<DT><span class="strong">ievery_vis</span>
<DD>
<pre>
⊢ ∀P f ov. (∀iv. ievery P (f iv)) ⇒ ievery P (Vis ov f)
</pre>

<DT><span class="strong">iexists_cases</span>
<DD>
<pre>
⊢ ∀P a0.
    iexists P a0 ⇔
    (∃e. a0 = ireturn e ∧ P e) ∨ ∃f ov. a0 = Vis ov f ∧ ∃iv. iexists P (f iv)
</pre>

<DT><span class="strong">iexists_ind</span>
<DD>
<pre>
⊢ ∀P iexists'.
    (∀e. P e ⇒ iexists' (ireturn e)) ∧
    (∀f ov. (∃iv. iexists' (f iv)) ⇒ iexists' (Vis ov f)) ⇒
    ∀a0. iexists P a0 ⇒ iexists' a0
</pre>

<DT><span class="strong">iexists_ret</span>
<DD>
<pre>
⊢ ∀P e. P e ⇒ iexists P (ireturn e)
</pre>

<DT><span class="strong">iexists_rules</span>
<DD>
<pre>
⊢ ∀P. (∀e. P e ⇒ iexists P (ireturn e)) ∧
      ∀f ov. (∃iv. iexists P (f iv)) ⇒ iexists P (Vis ov f)
</pre>

<DT><span class="strong">iexists_set</span>
<DD>
<pre>
⊢ iexists P itr ⇔ ∃x. iset itr x ∧ P x
</pre>

<DT><span class="strong">iexists_strongind</span>
<DD>
<pre>
⊢ ∀P iexists'.
    (∀e. P e ⇒ iexists' (ireturn e)) ∧
    (∀f ov. (∃iv. iexists P (f iv) ∧ iexists' (f iv)) ⇒ iexists' (Vis ov f)) ⇒
    ∀a0. iexists P a0 ⇒ iexists' a0
</pre>

<DT><span class="strong">iexists_thm</span>
<DD>
<pre>
⊢ (iexists P Div ⇔ F) ∧ (iexists P (ireturn e) ⇔ P e) ∧
  (iexists P (Vis ov f) ⇔ ∃iv. iexists P (f iv))
</pre>

<DT><span class="strong">iexists_vis</span>
<DD>
<pre>
⊢ ∀P f ov. (∃iv. iexists P (f iv)) ⇒ iexists P (Vis ov f)
</pre>

<DT><span class="strong">ifinite_cases</span>
<DD>
<pre>
⊢ ∀a0.
    ifinite a0 ⇔
    (∃e. a0 = ireturn e) ∨ a0 = Div ∨
    ∃f ov. a0 = Vis ov f ∧ ∀iv. ifinite (f iv)
</pre>

<DT><span class="strong">ifinite_div</span>
<DD>
<pre>
⊢ ifinite Div
</pre>

<DT><span class="strong">ifinite_ind</span>
<DD>
<pre>
⊢ ∀ifinite'.
    (∀e. ifinite' (ireturn e)) ∧ ifinite' Div ∧
    (∀f ov. (∀iv. ifinite' (f iv)) ⇒ ifinite' (Vis ov f)) ⇒
    ∀a0. ifinite a0 ⇒ ifinite' a0
</pre>

<DT><span class="strong">ifinite_ret</span>
<DD>
<pre>
⊢ ∀e. ifinite (ireturn e)
</pre>

<DT><span class="strong">ifinite_rules</span>
<DD>
<pre>
⊢ (∀e. ifinite (ireturn e)) ∧ ifinite Div ∧
  ∀f ov. (∀iv. ifinite (f iv)) ⇒ ifinite (Vis ov f)
</pre>

<DT><span class="strong">ifinite_strongind</span>
<DD>
<pre>
⊢ ∀ifinite'.
    (∀e. ifinite' (ireturn e)) ∧ ifinite' Div ∧
    (∀f ov. (∀iv. ifinite (f iv) ∧ ifinite' (f iv)) ⇒ ifinite' (Vis ov f)) ⇒
    ∀a0. ifinite a0 ⇒ ifinite' a0
</pre>

<DT><span class="strong">ifinite_vis</span>
<DD>
<pre>
⊢ ∀f ov. (∀iv. ifinite (f iv)) ⇒ ifinite (Vis ov f)
</pre>

<DT><span class="strong">iflat_div</span>
<DD>
<pre>
⊢ iflat Div = Div
</pre>

<DT><span class="strong">iflat_eq_div</span>
<DD>
<pre>
⊢ iflat itr = Div ⇔ itr = Div ∨ itr = ireturn Div
</pre>

<DT><span class="strong">iflat_eq_ret</span>
<DD>
<pre>
⊢ (iflat itr = ireturn rv ⇔ itr = ireturn (ireturn rv)) ∧
  (ireturn rv = iflat itr ⇔ itr = ireturn (ireturn rv))
</pre>

<DT><span class="strong">iflat_eq_vis</span>
<DD>
<pre>
⊢ iflat itr = Vis ov f ⇔
  (∃g. itr = Vis ov g ∧ iflat ∘ g = f) ∨ itr = ireturn (Vis ov f)
</pre>

<DT><span class="strong">iflat_ret</span>
<DD>
<pre>
⊢ iflat (ireturn r) = r
</pre>

<DT><span class="strong">iflat_vis</span>
<DD>
<pre>
⊢ iflat (Vis ov f) = Vis ov (iflat ∘ f)
</pre>

<DT><span class="strong">imap_composition</span>
<DD>
<pre>
⊢ imap (f ∘ g) itr = imap f (imap g itr)
</pre>

<DT><span class="strong">imap_div</span>
<DD>
<pre>
⊢ imap g Div = Div
</pre>

<DT><span class="strong">imap_eq_div</span>
<DD>
<pre>
⊢ (imap g itr = Div ⇔ itr = Div) ∧ (Div = imap g itr ⇔ itr = Div)
</pre>

<DT><span class="strong">imap_eq_ret</span>
<DD>
<pre>
⊢ ireturn r = imap g itr ⇔ ∃x. itr = ireturn x ∧ g x = r
</pre>

<DT><span class="strong">imap_eq_vis</span>
<DD>
<pre>
⊢ Vis rv f = imap g itr ⇔ ∃h. itr = Vis rv h ∧ imap g ∘ h = f
</pre>

<DT><span class="strong">imap_id</span>
<DD>
<pre>
⊢ imap (λx. x) itr = itr
</pre>

<DT><span class="strong">imap_ret</span>
<DD>
<pre>
⊢ imap g (ireturn rv) = ireturn (g rv)
</pre>

<DT><span class="strong">imap_vis</span>
<DD>
<pre>
⊢ imap f (Vis ov g) = Vis ov (imap f ∘ g)
</pre>

<DT><span class="strong">iset_cases</span>
<DD>
<pre>
⊢ ∀a0 a1.
    iset a0 a1 ⇔ a0 = ireturn a1 ∨ ∃f i ov. a0 = Vis ov f ∧ iset (f i) a1
</pre>

<DT><span class="strong">iset_flat</span>
<DD>
<pre>
⊢ ∀itr e. iset (iflat itr) e ⇔ ∃t0. iset itr t0 ∧ iset t0 e
</pre>

<DT><span class="strong">iset_flat_1</span>
<DD>
<pre>
⊢ ∀itr e. iset (iflat itr) e ⇒ ∃t0. iset itr t0 ∧ iset t0 e
</pre>

<DT><span class="strong">iset_flat_2</span>
<DD>
<pre>
⊢ ∀itr t0 e. iset itr t0 ∧ iset t0 e ⇒ iset (iflat itr) e
</pre>

<DT><span class="strong">iset_iff_exists_path</span>
<DD>
<pre>
⊢ iset itree e ⇔ ∃p. at_path itree p e
</pre>

<DT><span class="strong">iset_ind</span>
<DD>
<pre>
⊢ ∀iset'.
    (∀e. iset' (ireturn e) e) ∧
    (∀e f i ov. iset' (f i) e ⇒ iset' (Vis ov f) e) ⇒
    ∀a0 a1. iset a0 a1 ⇒ iset' a0 a1
</pre>

<DT><span class="strong">iset_map</span>
<DD>
<pre>
⊢ iset (imap f itr) = IMAGE f (iset itr)
</pre>

<DT><span class="strong">iset_map_1</span>
<DD>
<pre>
⊢ ∀itr x. iset (imap f itr) x ⇒ ∃y. x = f y ∧ iset itr y
</pre>

<DT><span class="strong">iset_map_2</span>
<DD>
<pre>
⊢ ∀itr. iset itr y ⇒ iset (imap f itr) (f y)
</pre>

<DT><span class="strong">iset_ret</span>
<DD>
<pre>
⊢ ∀e. iset (ireturn e) e
</pre>

<DT><span class="strong">iset_rules</span>
<DD>
<pre>
⊢ (∀e. iset (ireturn e) e) ∧ ∀e f i ov. iset (f i) e ⇒ iset (Vis ov f) e
</pre>

<DT><span class="strong">iset_strongind</span>
<DD>
<pre>
⊢ ∀iset'.
    (∀e. iset' (ireturn e) e) ∧
    (∀e f i ov. iset (f i) e ∧ iset' (f i) e ⇒ iset' (Vis ov f) e) ⇒
    ∀a0 a1. iset a0 a1 ⇒ iset' a0 a1
</pre>

<DT><span class="strong">iset_thm</span>
<DD>
<pre>
⊢ (iset (ireturn e) e' ⇔ e = e') ∧ (iset Div e ⇔ F) ∧
  (iset (Vis ov f) e ⇔ ∃i. iset (f i) e)
</pre>

<DT><span class="strong">iset_truncate</span>
<DD>
<pre>
⊢ iset itr elem ⇒ ∃n. iset (itruncate n itr) elem
</pre>

<DT><span class="strong">iset_vis</span>
<DD>
<pre>
⊢ ∀e f i ov. iset (f i) e ⇒ iset (Vis ov f) e
</pre>

<DT><span class="strong">itree_11</span>
<DD>
<pre>
⊢ (∀x y. ireturn x = ireturn y ⇔ x = y) ∧
  ∀x f y g. Vis x f = Vis y g ⇔ x = y ∧ f = g
</pre>

<DT><span class="strong">itree_CASE</span>
<DD>
<pre>
⊢ itree_CASE (ireturn r) ret div vis = ret r ∧
  itree_CASE Div ret div vis = div ∧
  itree_CASE (Vis a g) ret div vis = vis a g
</pre>

<DT><span class="strong">itree_CASE_cong</span>
<DD>
<pre>
⊢ ∀M M' ret div vis ret' div' vis'.
    M = M' ∧ (∀x. M' = ireturn x ⇒ ret x = ret' x) ∧ (M' = Div ⇒ div = div') ∧
    (∀a g. M' = Vis a g ⇒ vis a g = vis' a g) ⇒
    itree_CASE M ret div vis = itree_CASE M' ret' div' vis'
</pre>

<DT><span class="strong">itree_CASE_elim</span>
<DD>
<pre>
⊢ ∀f. f (itree_CASE t ret div vis) ⇔
      (∃r. t = ireturn r ∧ f (ret r)) ∨ t = Div ∧ f div ∨
      ∃a g. t = Vis a g ∧ f (vis a g)
</pre>

<DT><span class="strong">itree_CASE_eq</span>
<DD>
<pre>
⊢ itree_CASE t ret div vis = v ⇔
  (∃r. t = ireturn r ∧ ret r = v) ∨ t = Div ∧ div = v ∨
  ∃a g. t = Vis a g ∧ vis a g = v
</pre>

<DT><span class="strong">itree_bisimulation</span>
<DD>
<pre>
⊢ ∀t1 t2.
    t1 = t2 ⇔
    ∃R. R t1 t2 ∧ (∀x t. R (ireturn x) t ⇒ t = ireturn x) ∧
        (∀t. R Div t ⇒ t = Div) ∧
        ∀a f t. R (Vis a f) t ⇒ ∃b g. t = Vis a g ∧ ∀s. R (f s) (g s)
</pre>

<DT><span class="strong">itree_cases</span>
<DD>
<pre>
⊢ ∀t. (∃x. t = ireturn x) ∨ t = Div ∨ ∃a g. t = Vis a g
</pre>

<DT><span class="strong">itree_distinct</span>
<DD>
<pre>
⊢ (∀x. ireturn x ≠ Div) ∧ (∀x g e. ireturn x ≠ Vis e g) ∧ ∀g e. Div ≠ Vis e g
</pre>

<DT><span class="strong">itree_el_11</span>
<DD>
<pre>
⊢ (∀a a'. Event a = Event a' ⇔ a = a') ∧ ∀a a'. Return a = Return a' ⇔ a = a'
</pre>

<DT><span class="strong">itree_el_Axiom</span>
<DD>
<pre>
⊢ ∀f0 f1 f2. ∃fn.
    (∀a. fn (Event a) = f0 a) ∧ (∀a. fn (Return a) = f1 a) ∧ fn Stuck = f2
</pre>

<DT><span class="strong">itree_el_case_cong</span>
<DD>
<pre>
⊢ ∀M M' f f1 v.
    M = M' ∧ (∀a. M' = Event a ⇒ f a = f' a) ∧
    (∀a. M' = Return a ⇒ f1 a = f1' a) ∧ (M' = Stuck ⇒ v = v') ⇒
    itree_el_CASE M f f1 v = itree_el_CASE M' f' f1' v'
</pre>

<DT><span class="strong">itree_el_case_eq</span>
<DD>
<pre>
⊢ itree_el_CASE x f f1 v = v' ⇔
  (∃e. x = Event e ∧ f e = v') ∨ (∃r. x = Return r ∧ f1 r = v') ∨
  x = Stuck ∧ v = v'
</pre>

<DT><span class="strong">itree_el_def</span>
<DD>
<pre>
⊢ itree_el (ireturn r) [] = Return r ∧ itree_el Div [] = Stuck ∧
  itree_el (Vis e g) [] = Event e ∧
  itree_el (ireturn r) (a::ns) = Return ARB ∧
  itree_el Div (a::ns) = Return ARB ∧
  itree_el (Vis e g) (a::ns) = itree_el (g a) ns
</pre>

<DT><span class="strong">itree_el_distinct</span>
<DD>
<pre>
⊢ (∀a' a. Event a ≠ Return a') ∧ (∀a. Event a ≠ Stuck) ∧ ∀a. Return a ≠ Stuck
</pre>

<DT><span class="strong">itree_el_eqv</span>
<DD>
<pre>
⊢ ∀t1 t2. t1 = t2 ⇔ ∀path. itree_el t1 path = itree_el t2 path
</pre>

<DT><span class="strong">itree_el_induction</span>
<DD>
<pre>
⊢ ∀P. (∀e. P (Event e)) ∧ (∀r. P (Return r)) ∧ P Stuck ⇒ ∀i. P i
</pre>

<DT><span class="strong">itree_el_nchotomy</span>
<DD>
<pre>
⊢ ∀ii. (∃e. ii = Event e) ∨ (∃r. ii = Return r) ∨ ii = Stuck
</pre>

<DT><span class="strong">itree_next_11</span>
<DD>
<pre>
⊢ (∀a a'. Ret' a = Ret' a' ⇔ a = a') ∧
  ∀a0 a1 a0' a1'. Vis' a0 a1 = Vis' a0' a1' ⇔ a0 = a0' ∧ a1 = a1'
</pre>

<DT><span class="strong">itree_next_Axiom</span>
<DD>
<pre>
⊢ ∀f0 f1 f2. ∃fn.
    (∀a. fn (Ret' a) = f0 a) ∧ fn Div' = f1 ∧
    ∀a0 a1. fn (Vis' a0 a1) = f2 a0 a1
</pre>

<DT><span class="strong">itree_next_case_cong</span>
<DD>
<pre>
⊢ ∀M M' f v f1.
    M = M' ∧ (∀a. M' = Ret' a ⇒ f a = f' a) ∧ (M' = Div' ⇒ v = v') ∧
    (∀a0 a1. M' = Vis' a0 a1 ⇒ f1 a0 a1 = f1' a0 a1) ⇒
    itree_next_CASE M f v f1 = itree_next_CASE M' f' v' f1'
</pre>

<DT><span class="strong">itree_next_case_eq</span>
<DD>
<pre>
⊢ itree_next_CASE x f v f1 = v' ⇔
  (∃r. x = Ret' r ∧ f r = v') ∨ x = Div' ∧ v = v' ∨
  ∃e f'. x = Vis' e f' ∧ f1 e f' = v'
</pre>

<DT><span class="strong">itree_next_distinct</span>
<DD>
<pre>
⊢ (∀a. Ret' a ≠ Div') ∧ (∀a1 a0 a. Ret' a ≠ Vis' a0 a1) ∧
  ∀a1 a0. Div' ≠ Vis' a0 a1
</pre>

<DT><span class="strong">itree_next_induction</span>
<DD>
<pre>
⊢ ∀P. (∀r. P (Ret' r)) ∧ P Div' ∧ (∀e f. P (Vis' e f)) ⇒ ∀i. P i
</pre>

<DT><span class="strong">itree_next_nchotomy</span>
<DD>
<pre>
⊢ ∀ii. (∃r. ii = Ret' r) ∨ ii = Div' ∨ ∃e f. ii = Vis' e f
</pre>

<DT><span class="strong">itree_unfold</span>
<DD>
<pre>
⊢ itree_unfold f seed =
  case f seed of
    Ret' r => ireturn r
  | Div' => Div
  | Vis' e g => Vis e (itree_unfold f ∘ g)
</pre>

<DT><span class="strong">itree_unfold_err</span>
<DD>
<pre>
⊢ itree_unfold_err f (rel,err_f,err) seed =
  case f seed of
    Ret' r => ireturn r
  | Div' => Div
  | Vis' e g =>
    Vis e
      (λa.
           case a of
             INL x => ireturn (err_f e x)
           | INR y =>
             if rel e y then itree_unfold_err f (rel,err_f,err) (g y)
             else ireturn (err e))
</pre>

<DT><span class="strong">itruncate_compute</span>
<DD>
<pre>
⊢ (∀itr. itruncate 0 itr = Div) ∧
  (∀v2. itruncate <..num comp'n..> Div = Div) ∧
  (∀v2. itruncate <..num comp'n..> Div = Div) ∧
  (∀v3 rv. itruncate <..num comp'n..> (ireturn rv) = ireturn rv) ∧
  (∀v3 rv. itruncate <..num comp'n..> (ireturn rv) = ireturn rv) ∧
  (∀v4 ov f.
     itruncate <..num comp'n..> (Vis ov f) =
     Vis ov (λx. itruncate (<..num comp'n..> − 1) (f x))) ∧
  ∀v4 ov f.
    itruncate <..num comp'n..> (Vis ov f) =
    Vis ov (λx. itruncate (<..num comp'n..> − 1) (f x))
</pre>

<DT><span class="strong">itruncate_def</span>
<DD>
<pre>
⊢ (∀itr. itruncate 0 itr = Div) ∧ (∀v2. itruncate (SUC v2) Div = Div) ∧
  (∀v3 rv. itruncate (SUC v3) (ireturn rv) = ireturn rv) ∧
  ∀v4 ov f.
    itruncate (SUC v4) (Vis ov f) = Vis ov (λx. itruncate (SUC v4 − 1) (f x))
</pre>

<DT><span class="strong">itruncate_implies_ifinite</span>
<DD>
<pre>
⊢ ∀itr. itruncate n itr = itr ⇒ ifinite itr
</pre>

<DT><span class="strong">itruncate_ind</span>
<DD>
<pre>
⊢ ∀P. (∀itr. P 0 itr) ∧ (∀v2. P (SUC v2) Div) ∧
      (∀v3 rv. P (SUC v3) (ireturn rv)) ∧
      (∀v4 ov f. (∀x. P (SUC v4 − 1) (f x)) ⇒ P (SUC v4) (Vis ov f)) ⇒
      ∀v v1. P v v1
</pre>

<DT><span class="strong">itruncate_ret</span>
<DD>
<pre>
⊢ ∀n. itruncate n itr = ireturn r ⇔ itr = ireturn r ∧ n ≠ 0
</pre>

<DT><span class="strong">not_ievery_exists</span>
<DD>
<pre>
⊢ ¬ievery P itr ⇔ iexists (λx. ¬P x) itr
</pre>

</DL>



<hr>
</body>
</html>
