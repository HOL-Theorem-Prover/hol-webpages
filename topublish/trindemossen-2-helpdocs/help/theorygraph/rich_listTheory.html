<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: rich_list</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "rich_list"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "listTheory.html"><span class="strong">list</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">AND_EL</span>
    <td>
    :bool list -> bool
    <tr><td>
    <span class="strong">BUTLASTN</span>
    <td>
    :num -> α list -> α list
    <tr><td> <span class="strong">COUNT_LIST</span> <td> :num -> num list
    <tr><td>
    <span class="strong">COUNT_LIST_AUX</span>
    <td>
    :num -> num list -> num list
    <tr><td>
    <span class="strong">DELETE_ELEMENT</span>
    <td>
    :α -> α list -> α list
    <tr><td> <span class="strong">ELL</span> <td> :num -> α list -> α
    <tr><td>
    <span class="strong">IS_SUBLIST</span>
    <td>
    :α list -> α list -> bool
    <tr><td>
    <span class="strong">IS_SUFFIX</span>
    <td>
    :α list -> α list -> bool
    <tr><td> <span class="strong">LASTN</span> <td> :num -> α list -> α list
    <tr><td>
    <span class="strong">LIST_ELEM_COUNT</span>
    <td>
    :α -> α list -> num
    <tr><td> <span class="strong">MAX_LIST</span> <td> :num list -> num
    <tr><td> <span class="strong">MIN_LIST</span> <td> :num list -> num
    <tr><td> <span class="strong">OR_EL</span> <td> :bool list -> bool
    <tr><td>
    <span class="strong">PREFIX</span>
    <td>
    :(α -> bool) -> α list -> α list
    <tr><td> <span class="strong">REPLICATE</span> <td> :num -> α -> α list
    <tr><td>
    <span class="strong">SCANL</span>
    <td>
    :(β -> α -> β) -> β -> α list -> β list
    <tr><td>
    <span class="strong">SCANR</span>
    <td>
    :(α -> β -> β) -> β -> α list -> β list
    <tr><td>
    <span class="strong">SEG</span>
    <td>
    :num -> num -> α list -> α list
    <tr><td>
    <span class="strong">SPLITL</span>
    <td>
    :(α -> bool) -> α list -> α list # α list
    <tr><td>
    <span class="strong">SPLITP</span>
    <td>
    :(α -> bool) -> α list -> α list # α list
    <tr><td>
    <span class="strong">SPLITP_AUX</span>
    <td>
    :α list -> (α -> bool) -> α list -> α list # α list
    <tr><td>
    <span class="strong">SPLITR</span>
    <td>
    :(α -> bool) -> α list -> α list # α list
    <tr><td>
    <span class="strong">SUFFIX</span>
    <td>
    :(α -> bool) -> α list -> α list
    <tr><td> <span class="strong">TL_T</span> <td> :α list -> α list
    <tr><td>
    <span class="strong">UNZIP_FST</span>
    <td>
    :(α # β) list -> α list
    <tr><td>
    <span class="strong">UNZIP_SND</span>
    <td>
    :(β # α) list -> α list
    <tr><td>
    <span class="strong">chunks</span>
    <td>
    :num -> α list -> α list list
    <tr><td>
    <span class="strong">chunks_tr</span>
    <td>
    :num -> α list -> α list list
    <tr><td>
    <span class="strong">chunks_tr_aux</span>
    <td>
    :num -> α list -> α list list -> α list list
    <tr><td>
    <span class="strong">common_prefixes</span>
    <td>
    :(α list -> bool) -> α list -> bool
    <tr><td>
    <span class="strong">longest_prefix</span>
    <td>
    :(α list -> bool) -> α list
    <tr><td>
    <span class="strong">sublist</span>
    <td>
    :α list -> α list -> bool
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">AND_EL_DEF</span>
<DD>
<pre>
⊢ AND_EL = EVERY I
</pre>

<DT><span class="strong">BUTLASTN_def</span>
<DD>
<pre>
⊢ ∀n xs. BUTLASTN n xs = REVERSE (DROP n (REVERSE xs))
</pre>

<DT><span class="strong">COUNT_LIST_AUX_def</span>
<DD>
<pre>
⊢ (∀l. COUNT_LIST_AUX 0 l = l) ∧
  ∀n l. COUNT_LIST_AUX (SUC n) l = COUNT_LIST_AUX n (n::l)
</pre>

<DT><span class="strong">COUNT_LIST_def</span>
<DD>
<pre>
⊢ COUNT_LIST 0 = [] ∧ ∀n. COUNT_LIST (SUC n) = 0::MAP SUC (COUNT_LIST n)
</pre>

<DT><span class="strong">DELETE_ELEMENT</span>
<DD>
<pre>
⊢ (∀e. DELETE_ELEMENT e [] = []) ∧
  ∀e x l.
    DELETE_ELEMENT e (x::l) =
    if e = x then DELETE_ELEMENT e l else x::DELETE_ELEMENT e l
</pre>

<DT><span class="strong">ELL</span>
<DD>
<pre>
⊢ (∀l. ELL 0 l = LAST l) ∧ ∀n l. ELL (SUC n) l = ELL n (FRONT l)
</pre>

<DT><span class="strong">IS_SUBLIST</span>
<DD>
<pre>
⊢ (∀l. IS_SUBLIST l [] ⇔ T) ∧ (∀x l. IS_SUBLIST [] (x::l) ⇔ F) ∧
  ∀x1 l1 x2 l2.
    IS_SUBLIST (x1::l1) (x2::l2) ⇔ x1 = x2 ∧ l2 ≼ l1 ∨ IS_SUBLIST l1 (x2::l2)
</pre>

<DT><span class="strong">IS_SUFFIX</span>
<DD>
<pre>
⊢ (∀l. IS_SUFFIX l [] ⇔ T) ∧ (∀x l. IS_SUFFIX [] (SNOC x l) ⇔ F) ∧
  ∀x1 l1 x2 l2.
    IS_SUFFIX (SNOC x1 l1) (SNOC x2 l2) ⇔ x1 = x2 ∧ IS_SUFFIX l1 l2
</pre>

<DT><span class="strong">LASTN_def</span>
<DD>
<pre>
⊢ ∀n xs. LASTN n xs = REVERSE (TAKE n (REVERSE xs))
</pre>

<DT><span class="strong">LIST_ELEM_COUNT_DEF</span>
<DD>
<pre>
⊢ ∀e l. LIST_ELEM_COUNT e l = LENGTH (FILTER (λx. x = e) l)
</pre>

<DT><span class="strong">MAX_LIST_def</span>
<DD>
<pre>
⊢ MAX_LIST [] = 0 ∧ ∀h t. MAX_LIST (h::t) = MAX h (MAX_LIST t)
</pre>

<DT><span class="strong">MIN_LIST_def</span>
<DD>
<pre>
⊢ ∀h t. MIN_LIST (h::t) = if t = [] then h else MIN h (MIN_LIST t)
</pre>

<DT><span class="strong">OR_EL_DEF</span>
<DD>
<pre>
⊢ OR_EL = EXISTS I
</pre>

<DT><span class="strong">PREFIX_DEF</span>
<DD>
<pre>
⊢ ∀P l. PREFIX P l = FST (SPLITP ($¬ ∘ P) l)
</pre>

<DT><span class="strong">REPLICATE</span>
<DD>
<pre>
⊢ (∀x. REPLICATE 0 x = []) ∧ ∀n x. REPLICATE (SUC n) x = x::REPLICATE n x
</pre>

<DT><span class="strong">SCANL</span>
<DD>
<pre>
⊢ (∀f e. SCANL f e [] = [e]) ∧
  ∀f e x l. SCANL f e (x::l) = e::SCANL f (f e x) l
</pre>

<DT><span class="strong">SCANR</span>
<DD>
<pre>
⊢ (∀f e. SCANR f e [] = [e]) ∧
  ∀f e x l. SCANR f e (x::l) = f x (HD (SCANR f e l))::SCANR f e l
</pre>

<DT><span class="strong">SEG</span>
<DD>
<pre>
⊢ (∀k l. SEG 0 k l = []) ∧ (∀m x l. SEG (SUC m) 0 (x::l) = x::SEG m 0 l) ∧
  ∀m k x l. SEG (SUC m) (SUC k) (x::l) = SEG (SUC m) k l
</pre>

<DT><span class="strong">SPLITL_def</span>
<DD>
<pre>
⊢ ∀P. SPLITL P = SPLITP ($¬ ∘ P)
</pre>

<DT><span class="strong">SPLITP</span>
<DD>
<pre>
⊢ (∀P. SPLITP P [] = ([],[])) ∧
  ∀P x l.
    SPLITP P (x::l) =
    if P x then ([],x::l) else (x::FST (SPLITP P l),SND (SPLITP P l))
</pre>

<DT><span class="strong">SPLITP_AUX_def</span>
<DD>
<pre>
⊢ (∀acc P. SPLITP_AUX acc P [] = (acc,[])) ∧
  ∀acc P h t.
    SPLITP_AUX acc P (h::t) =
    if P h then (acc,h::t) else SPLITP_AUX (acc ++ [h]) P t
</pre>

<DT><span class="strong">SPLITR_def</span>
<DD>
<pre>
⊢ ∀P l.
    SPLITR P l =
    (let (a,b) = SPLITP ($¬ ∘ P) (REVERSE l) in (REVERSE b,REVERSE a))
</pre>

<DT><span class="strong">SUFFIX_DEF</span>
<DD>
<pre>
⊢ ∀P l. SUFFIX P l = FOLDL (λl' x. if P x then SNOC x l' else []) [] l
</pre>

<DT><span class="strong">TL_T_def</span>
<DD>
<pre>
⊢ TL_T [] = [] ∧ ∀h t. TL_T (h::t) = t
</pre>

<DT><span class="strong">UNZIP_FST_DEF</span>
<DD>
<pre>
⊢ ∀l. UNZIP_FST l = FST (UNZIP l)
</pre>

<DT><span class="strong">UNZIP_SND_DEF</span>
<DD>
<pre>
⊢ ∀l. UNZIP_SND l = SND (UNZIP l)
</pre>

<DT><span class="strong">chunks_tr_def</span>
<DD>
<pre>
⊢ ∀n ls. chunks_tr n ls = if n = 0 then [ls] else chunks_tr_aux (n − 1) ls []
</pre>

<DT><span class="strong">common_prefixes_def</span>
<DD>
<pre>
⊢ ∀s. common_prefixes s = {p | ∀m. m ∈ s ⇒ p ≼ m}
</pre>

<DT><span class="strong">longest_prefix_def</span>
<DD>
<pre>
⊢ ∀s. longest_prefix s =
      if s = ∅ then []
      else @x. is_measure_maximal LENGTH (common_prefixes s) x
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">ALL_DISTINCT_APPEND_3</span>
<DD>
<pre>
⊢ ∀l1 x l2. ALL_DISTINCT (l1 ++ [x] ++ l2) ⇔ ALL_DISTINCT (x::(l1 ++ l2))
</pre>

<DT><span class="strong">ALL_DISTINCT_EL_APPEND</span>
<DD>
<pre>
⊢ ∀ls l1 l2 j.
    ALL_DISTINCT ls ∧ j < LENGTH ls ∧ ls = l1 ++ [EL j ls] ++ l2 ⇒
    j = LENGTH l1
</pre>

<DT><span class="strong">ALL_DISTINCT_FRONT</span>
<DD>
<pre>
⊢ ∀l. l ≠ [] ∧ ALL_DISTINCT l ⇒ ALL_DISTINCT (FRONT l)
</pre>

<DT><span class="strong">ALL_DISTINCT_LAST_EL_IFF</span>
<DD>
<pre>
⊢ ∀ls j.
    ALL_DISTINCT ls ∧ ls ≠ [] ∧ j < LENGTH ls ⇒
    (EL j ls = LAST ls ⇔ j + 1 = LENGTH ls)
</pre>

<DT><span class="strong">ALL_DISTINCT_MEM_ZIP_MAP</span>
<DD>
<pre>
⊢ ∀f x ls.
    ALL_DISTINCT ls ⇒
    (MEM x (ZIP (ls,MAP f ls)) ⇔ MEM (FST x) ls ∧ SND x = f (FST x))
</pre>

<DT><span class="strong">ALL_DISTINCT_SNOC</span>
<DD>
<pre>
⊢ ∀x l. ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l
</pre>

<DT><span class="strong">ALL_DISTINCT_SWAP</span>
<DD>
<pre>
⊢ ∀ls x y. ALL_DISTINCT (x::y::ls) ⇔ ALL_DISTINCT (y::x::ls)
</pre>

<DT><span class="strong">ALL_DISTINCT_TAKE</span>
<DD>
<pre>
⊢ ∀ls n. ALL_DISTINCT ls ⇒ ALL_DISTINCT (TAKE n ls)
</pre>

<DT><span class="strong">ALL_DISTINCT_TAKE_DROP</span>
<DD>
<pre>
⊢ ∀ls. ALL_DISTINCT ls ⇒ ∀k e. MEM e (TAKE k ls) ∧ MEM e (DROP k ls) ⇒ F
</pre>

<DT><span class="strong">ALL_EL</span>
<DD>
<pre>
⊢ (∀P. EVERY P [] ⇔ T) ∧ ∀P h t. EVERY P (h::t) ⇔ P h ∧ EVERY P t
</pre>

<DT><span class="strong">ALL_EL_APPEND</span>
<DD>
<pre>
⊢ ∀P l1 l2. EVERY P (l1 ++ l2) ⇔ EVERY P l1 ∧ EVERY P l2
</pre>

<DT><span class="strong">ALL_EL_BUTFIRSTN</span>
<DD>
<pre>
⊢ ∀P l m. EVERY P l ⇒ EVERY P (DROP m l)
</pre>

<DT><span class="strong">ALL_EL_BUTLASTN</span>
<DD>
<pre>
⊢ ∀P l m. EVERY P l ⇒ EVERY P (BUTLASTN m l)
</pre>

<DT><span class="strong">ALL_EL_CONJ</span>
<DD>
<pre>
⊢ ∀P Q l. EVERY (λx. P x ∧ Q x) l ⇔ EVERY P l ∧ EVERY Q l
</pre>

<DT><span class="strong">ALL_EL_FIRSTN</span>
<DD>
<pre>
⊢ ∀P l m. EVERY P l ⇒ EVERY P (TAKE m l)
</pre>

<DT><span class="strong">ALL_EL_FOLDL</span>
<DD>
<pre>
⊢ ∀P l. EVERY P l ⇔ FOLDL (λl' x. l' ∧ P x) T l
</pre>

<DT><span class="strong">ALL_EL_FOLDL_MAP</span>
<DD>
<pre>
⊢ ∀P l. EVERY P l ⇔ FOLDL $/\ T (MAP P l)
</pre>

<DT><span class="strong">ALL_EL_FOLDR</span>
<DD>
<pre>
⊢ ∀P l. EVERY P l ⇔ FOLDR (λx l'. P x ∧ l') T l
</pre>

<DT><span class="strong">ALL_EL_FOLDR_MAP</span>
<DD>
<pre>
⊢ ∀P l. EVERY P l ⇔ FOLDR $/\ T (MAP P l)
</pre>

<DT><span class="strong">ALL_EL_LASTN</span>
<DD>
<pre>
⊢ ∀P l m. EVERY P l ⇒ EVERY P (LASTN m l)
</pre>

<DT><span class="strong">ALL_EL_MAP</span>
<DD>
<pre>
⊢ ∀P f l. EVERY P (MAP f l) ⇔ EVERY (P ∘ f) l
</pre>

<DT><span class="strong">ALL_EL_REPLICATE</span>
<DD>
<pre>
⊢ ∀f n x. EVERY f (REPLICATE n x) ⇔ n = 0 ∨ f x
</pre>

<DT><span class="strong">ALL_EL_REVERSE</span>
<DD>
<pre>
⊢ ∀P l. EVERY P (REVERSE l) ⇔ EVERY P l
</pre>

<DT><span class="strong">ALL_EL_SEG</span>
<DD>
<pre>
⊢ ∀P l. EVERY P l ⇒ ∀m k. m + k ≤ LENGTH l ⇒ EVERY P (SEG m k l)
</pre>

<DT><span class="strong">ALL_EL_SNOC</span>
<DD>
<pre>
⊢ ∀P x l. EVERY P (SNOC x l) ⇔ EVERY P l ∧ P x
</pre>

<DT><span class="strong">AND_EL_FOLDL</span>
<DD>
<pre>
⊢ ∀l. AND_EL l ⇔ FOLDL $/\ T l
</pre>

<DT><span class="strong">AND_EL_FOLDR</span>
<DD>
<pre>
⊢ ∀l. AND_EL l ⇔ FOLDR $/\ T l
</pre>

<DT><span class="strong">APPEND</span>
<DD>
<pre>
⊢ (∀l. [] ++ l = l) ∧ ∀l1 l2 h. h::l1 ++ l2 = h::(l1 ++ l2)
</pre>

<DT><span class="strong">APPEND_11_LENGTH</span>
<DD>
<pre>
⊢ (∀l1 l2 l1' l2'.
     LENGTH l1 = LENGTH l1' ⇒ (l1 ++ l2 = l1' ++ l2' ⇔ l1 = l1' ∧ l2 = l2')) ∧
  ∀l1 l2 l1' l2'.
    LENGTH l2 = LENGTH l2' ⇒ (l1 ++ l2 = l1' ++ l2' ⇔ l1 = l1' ∧ l2 = l2')
</pre>

<DT><span class="strong">APPEND_ASSOC</span>
<DD>
<pre>
⊢ ∀l1 l2 l3. l1 ++ (l2 ++ l3) = l1 ++ l2 ++ l3
</pre>

<DT><span class="strong">APPEND_ASSOC_CONS</span>
<DD>
<pre>
⊢ ∀l1 h l2 l3. l1 ++ h::l2 ++ l3 = l1 ++ h::(l2 ++ l3)
</pre>

<DT><span class="strong">APPEND_BUTLASTN_BUTFIRSTN</span>
<DD>
<pre>
⊢ ∀m n l. m + n = LENGTH l ⇒ BUTLASTN m l ++ DROP n l = l
</pre>

<DT><span class="strong">APPEND_BUTLASTN_DROP</span>
<DD>
<pre>
⊢ ∀m n l. m + n = LENGTH l ⇒ BUTLASTN m l ++ DROP n l = l
</pre>

<DT><span class="strong">APPEND_BUTLASTN_LASTN</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ BUTLASTN n l ++ LASTN n l = l
</pre>

<DT><span class="strong">APPEND_BUTLAST_LAST</span>
<DD>
<pre>
⊢ ∀l. l ≠ [] ⇒ FRONT l ++ [LAST l] = l
</pre>

<DT><span class="strong">APPEND_EQ_APPEND_EQ</span>
<DD>
<pre>
⊢ ∀l1 l2 m1 m2.
    l1 ++ l2 = m1 ++ m2 ∧ LENGTH l1 = LENGTH m1 ⇔ l1 = m1 ∧ l2 = m2
</pre>

<DT><span class="strong">APPEND_FIRSTN_BUTFIRSTN</span>
<DD>
<pre>
⊢ ∀n l. TAKE n l ++ DROP n l = l
</pre>

<DT><span class="strong">APPEND_FIRSTN_LASTN</span>
<DD>
<pre>
⊢ ∀m n l. m + n = LENGTH l ⇒ TAKE n l ++ LASTN m l = l
</pre>

<DT><span class="strong">APPEND_FOLDL</span>
<DD>
<pre>
⊢ ∀l1 l2. l1 ++ l2 = FOLDL (λl' x. SNOC x l') l1 l2
</pre>

<DT><span class="strong">APPEND_FOLDR</span>
<DD>
<pre>
⊢ ∀l1 l2. l1 ++ l2 = FOLDR CONS l2 l1
</pre>

<DT><span class="strong">APPEND_LENGTH_EQ</span>
<DD>
<pre>
⊢ ∀l1 l1'.
    LENGTH l1 = LENGTH l1' ⇒
    ∀l2 l2'.
      LENGTH l2 = LENGTH l2' ⇒ (l1 ++ l2 = l1' ++ l2' ⇔ l1 = l1' ∧ l2 = l2')
</pre>

<DT><span class="strong">APPEND_NIL</span>
<DD>
<pre>
⊢ (∀l. l ++ [] = l) ∧ ∀l. [] ++ l = l
</pre>

<DT><span class="strong">APPEND_SNOC</span>
<DD>
<pre>
⊢ ∀l1 x l2. l1 ++ SNOC x l2 = SNOC x (l1 ++ l2)
</pre>

<DT><span class="strong">APPEND_SNOC1</span>
<DD>
<pre>
⊢ ∀l1 x l2. SNOC x l1 ++ l2 = l1 ++ x::l2
</pre>

<DT><span class="strong">APPEND_TAKE_LASTN</span>
<DD>
<pre>
⊢ ∀m n l. m + n = LENGTH l ⇒ TAKE n l ++ LASTN m l = l
</pre>

<DT><span class="strong">ASSOC_APPEND</span>
<DD>
<pre>
⊢ ASSOC $++
</pre>

<DT><span class="strong">ASSOC_FOLDL_FLAT</span>
<DD>
<pre>
⊢ ∀f. ASSOC f ⇒
      ∀e. RIGHT_ID f e ⇒
          ∀l. FOLDL f e (FLAT l) = FOLDL f e (MAP (FOLDL f e) l)
</pre>

<DT><span class="strong">ASSOC_FOLDR_FLAT</span>
<DD>
<pre>
⊢ ∀f. ASSOC f ⇒
      ∀e. LEFT_ID f e ⇒ ∀l. FOLDR f e (FLAT l) = FOLDR f e (MAP (FOLDR f e) l)
</pre>

<DT><span class="strong">BUTFIRSTN</span>
<DD>
<pre>
⊢ (∀l. DROP 0 l = l) ∧ ∀n x l. DROP (SUC n) (x::l) = DROP n l
</pre>

<DT><span class="strong">BUTFIRSTN_APPEND1</span>
<DD>
<pre>
⊢ ∀n l1. n ≤ LENGTH l1 ⇒ ∀l2. DROP n (l1 ++ l2) = DROP n l1 ++ l2
</pre>

<DT><span class="strong">BUTFIRSTN_APPEND2</span>
<DD>
<pre>
⊢ ∀l1 n. LENGTH l1 ≤ n ⇒ ∀l2. DROP n (l1 ++ l2) = DROP (n − LENGTH l1) l2
</pre>

<DT><span class="strong">BUTFIRSTN_BUTFIRSTN</span>
<DD>
<pre>
⊢ ∀n m l. n + m ≤ LENGTH l ⇒ DROP n (DROP m l) = DROP (n + m) l
</pre>

<DT><span class="strong">BUTFIRSTN_CONS_EL</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ DROP n l = EL n l::DROP (SUC n) l
</pre>

<DT><span class="strong">BUTFIRSTN_LASTN</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ DROP n l = LASTN (LENGTH l − n) l
</pre>

<DT><span class="strong">BUTFIRSTN_LENGTH_APPEND</span>
<DD>
<pre>
⊢ ∀l1 l2. DROP (LENGTH l1) (l1 ++ l2) = l2
</pre>

<DT><span class="strong">BUTFIRSTN_LENGTH_NIL</span>
<DD>
<pre>
⊢ ∀l. DROP (LENGTH l) l = []
</pre>

<DT><span class="strong">BUTFIRSTN_REVERSE</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ DROP n (REVERSE l) = REVERSE (BUTLASTN n l)
</pre>

<DT><span class="strong">BUTFIRSTN_SEG</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ DROP n l = SEG (LENGTH l − n) n l
</pre>

<DT><span class="strong">BUTFIRSTN_SNOC</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ ∀x. DROP n (SNOC x l) = SNOC x (DROP n l)
</pre>

<DT><span class="strong">BUTLAST</span>
<DD>
<pre>
⊢ ∀x l. FRONT (SNOC x l) = l
</pre>

<DT><span class="strong">BUTLASTN</span>
<DD>
<pre>
⊢ (∀l. BUTLASTN 0 l = l) ∧ ∀n x l. BUTLASTN (SUC n) (SNOC x l) = BUTLASTN n l
</pre>

<DT><span class="strong">BUTLASTN_1</span>
<DD>
<pre>
⊢ ∀l. l ≠ [] ⇒ BUTLASTN 1 l = FRONT l
</pre>

<DT><span class="strong">BUTLASTN_APPEND1</span>
<DD>
<pre>
⊢ ∀l2 n.
    LENGTH l2 ≤ n ⇒ ∀l1. BUTLASTN n (l1 ++ l2) = BUTLASTN (n − LENGTH l2) l1
</pre>

<DT><span class="strong">BUTLASTN_APPEND2</span>
<DD>
<pre>
⊢ ∀n l1 l2. n ≤ LENGTH l2 ⇒ BUTLASTN n (l1 ++ l2) = l1 ++ BUTLASTN n l2
</pre>

<DT><span class="strong">BUTLASTN_BUTLAST</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ BUTLASTN n (FRONT l) = FRONT (BUTLASTN n l)
</pre>

<DT><span class="strong">BUTLASTN_BUTLASTN</span>
<DD>
<pre>
⊢ ∀m n l. n + m ≤ LENGTH l ⇒ BUTLASTN n (BUTLASTN m l) = BUTLASTN (n + m) l
</pre>

<DT><span class="strong">BUTLASTN_CONS</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ ∀x. BUTLASTN n (x::l) = x::BUTLASTN n l
</pre>

<DT><span class="strong">BUTLASTN_FIRSTN</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ BUTLASTN n l = TAKE (LENGTH l − n) l
</pre>

<DT><span class="strong">BUTLASTN_FRONT</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ BUTLASTN n (FRONT l) = FRONT (BUTLASTN n l)
</pre>

<DT><span class="strong">BUTLASTN_LASTN</span>
<DD>
<pre>
⊢ ∀m n l.
    m ≤ n ∧ n ≤ LENGTH l ⇒
    BUTLASTN m (LASTN n l) = LASTN (n − m) (BUTLASTN m l)
</pre>

<DT><span class="strong">BUTLASTN_LASTN_NIL</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ BUTLASTN n (LASTN n l) = []
</pre>

<DT><span class="strong">BUTLASTN_LENGTH_APPEND</span>
<DD>
<pre>
⊢ ∀l2 l1. BUTLASTN (LENGTH l2) (l1 ++ l2) = l1
</pre>

<DT><span class="strong">BUTLASTN_LENGTH_CONS</span>
<DD>
<pre>
⊢ ∀l x. BUTLASTN (LENGTH l) (x::l) = [x]
</pre>

<DT><span class="strong">BUTLASTN_LENGTH_NIL</span>
<DD>
<pre>
⊢ ∀l. BUTLASTN (LENGTH l) l = []
</pre>

<DT><span class="strong">BUTLASTN_MAP</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ ∀f. BUTLASTN n (MAP f l) = MAP f (BUTLASTN n l)
</pre>

<DT><span class="strong">BUTLASTN_REVERSE</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ BUTLASTN n (REVERSE l) = REVERSE (DROP n l)
</pre>

<DT><span class="strong">BUTLASTN_SEG</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ BUTLASTN n l = SEG (LENGTH l − n) 0 l
</pre>

<DT><span class="strong">BUTLASTN_SUC_BUTLAST</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ BUTLASTN (SUC n) l = BUTLASTN n (FRONT l)
</pre>

<DT><span class="strong">BUTLASTN_SUC_FRONT</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ BUTLASTN (SUC n) l = BUTLASTN n (FRONT l)
</pre>

<DT><span class="strong">BUTLASTN_TAKE</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ BUTLASTN n l = TAKE (LENGTH l − n) l
</pre>

<DT><span class="strong">BUTLASTN_TAKE_UNCOND</span>
<DD>
<pre>
⊢ ∀n l. BUTLASTN n l = TAKE (LENGTH l − n) l
</pre>

<DT><span class="strong">BUTLASTN_compute</span>
<DD>
<pre>
⊢ ∀n l.
    BUTLASTN n l =
    (let
       m = LENGTH l
     in
       if n ≤ m then TAKE (m − n) l
       else FAIL BUTLASTN $var$(longer than list) n l)
</pre>

<DT><span class="strong">BUTLAST_CONS</span>
<DD>
<pre>
⊢ (∀x. FRONT [x] = []) ∧ ∀x y z. FRONT (x::y::z) = x::FRONT (y::z)
</pre>

<DT><span class="strong">COMM_ASSOC_FOLDL_REVERSE</span>
<DD>
<pre>
⊢ ∀f. COMM f ⇒ ASSOC f ⇒ ∀e l. FOLDL f e (REVERSE l) = FOLDL f e l
</pre>

<DT><span class="strong">COMM_ASSOC_FOLDR_REVERSE</span>
<DD>
<pre>
⊢ ∀f. COMM f ⇒ ASSOC f ⇒ ∀e l. FOLDR f e (REVERSE l) = FOLDR f e l
</pre>

<DT><span class="strong">COMM_MONOID_FOLDL</span>
<DD>
<pre>
⊢ ∀f. COMM f ⇒ ∀e'. MONOID f e' ⇒ ∀e l. FOLDL f e l = f e (FOLDL f e' l)
</pre>

<DT><span class="strong">COMM_MONOID_FOLDR</span>
<DD>
<pre>
⊢ ∀f. COMM f ⇒ ∀e'. MONOID f e' ⇒ ∀e l. FOLDR f e l = f e (FOLDR f e' l)
</pre>

<DT><span class="strong">CONS</span>
<DD>
<pre>
⊢ ∀l. ¬NULL l ⇒ HD l::TL l = l
</pre>

<DT><span class="strong">CONS_11</span>
<DD>
<pre>
⊢ ∀a0 a1 a0' a1'. a0::a1 = a0'::a1' ⇔ a0 = a0' ∧ a1 = a1'
</pre>

<DT><span class="strong">CONS_APPEND</span>
<DD>
<pre>
⊢ ∀x l. x::l = [x] ++ l
</pre>

<DT><span class="strong">COUNT_LIST_ADD</span>
<DD>
<pre>
⊢ ∀n m. COUNT_LIST (n + m) = COUNT_LIST n ++ MAP (λn'. n' + n) (COUNT_LIST m)
</pre>

<DT><span class="strong">COUNT_LIST_AUX_compute</span>
<DD>
<pre>
⊢ (∀l. COUNT_LIST_AUX 0 l = l) ∧
  (∀n l.
     COUNT_LIST_AUX <..num comp'n..> l =
     COUNT_LIST_AUX (<..num comp'n..> − 1) (<..num comp'n..> − 1::l)) ∧
  ∀n l.
    COUNT_LIST_AUX <..num comp'n..> l =
    COUNT_LIST_AUX <..num comp'n..> (<..num comp'n..> ::l)
</pre>

<DT><span class="strong">COUNT_LIST_COUNT</span>
<DD>
<pre>
⊢ ∀n. LIST_TO_SET (COUNT_LIST n) = count n
</pre>

<DT><span class="strong">COUNT_LIST_GENLIST</span>
<DD>
<pre>
⊢ ∀n. COUNT_LIST n = GENLIST I n
</pre>

<DT><span class="strong">COUNT_LIST_SNOC</span>
<DD>
<pre>
⊢ COUNT_LIST 0 = [] ∧ ∀n. COUNT_LIST (SUC n) = SNOC n (COUNT_LIST n)
</pre>

<DT><span class="strong">COUNT_LIST_compute</span>
<DD>
<pre>
⊢ ∀n. COUNT_LIST n = COUNT_LIST_AUX n []
</pre>

<DT><span class="strong">DELETE_ELEMENT_APPEND</span>
<DD>
<pre>
⊢ ∀a L L'.
    DELETE_ELEMENT a (L ++ L') = DELETE_ELEMENT a L ++ DELETE_ELEMENT a L'
</pre>

<DT><span class="strong">DELETE_ELEMENT_FILTER</span>
<DD>
<pre>
⊢ ∀e L. DELETE_ELEMENT e L = FILTER (λy. e ≠ y) L
</pre>

<DT><span class="strong">DISTINCT_LIST_TO_SET_EQ_SING</span>
<DD>
<pre>
⊢ ∀l x. ALL_DISTINCT l ∧ LIST_TO_SET l = {x} ⇔ l = [x]
</pre>

<DT><span class="strong">DROP</span>
<DD>
<pre>
⊢ (∀l. DROP 0 l = l) ∧ ∀n x l. DROP (SUC n) (x::l) = DROP n l
</pre>

<DT><span class="strong">DROP_1</span>
<DD>
<pre>
⊢ ∀h t. DROP 1 (h::t) = t
</pre>

<DT><span class="strong">DROP_1_APPEND</span>
<DD>
<pre>
⊢ ∀x y. x ≠ [] ⇒ DROP 1 (x ++ y) = DROP 1 x ++ y
</pre>

<DT><span class="strong">DROP_APPEND</span>
<DD>
<pre>
⊢ ∀n l1 l2. DROP n (l1 ++ l2) = DROP n l1 ++ DROP (n − LENGTH l1) l2
</pre>

<DT><span class="strong">DROP_APPEND1</span>
<DD>
<pre>
⊢ ∀n l1. n ≤ LENGTH l1 ⇒ ∀l2. DROP n (l1 ++ l2) = DROP n l1 ++ l2
</pre>

<DT><span class="strong">DROP_APPEND2</span>
<DD>
<pre>
⊢ ∀l1 n. LENGTH l1 ≤ n ⇒ ∀l2. DROP n (l1 ++ l2) = DROP (n − LENGTH l1) l2
</pre>

<DT><span class="strong">DROP_BY_DROP_SUC</span>
<DD>
<pre>
⊢ ∀k x. k < LENGTH x ⇒ DROP k x = EL k x::DROP (SUC k) x
</pre>

<DT><span class="strong">DROP_CONS_EL</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ DROP n l = EL n l::DROP (SUC n) l
</pre>

<DT><span class="strong">DROP_DROP</span>
<DD>
<pre>
⊢ ∀n m l. n + m ≤ LENGTH l ⇒ DROP n (DROP m l) = DROP (n + m) l
</pre>

<DT><span class="strong">DROP_DROP_T</span>
<DD>
<pre>
⊢ ∀n m l. DROP n (DROP m l) = DROP (n + m) l
</pre>

<DT><span class="strong">DROP_EL_CONS</span>
<DD>
<pre>
⊢ ∀ls n. n < LENGTH ls ⇒ DROP n ls = EL n ls::DROP (n + 1) ls
</pre>

<DT><span class="strong">DROP_FUNPOW_TL</span>
<DD>
<pre>
⊢ ∀n l. DROP n l = FUNPOW TL_T n l
</pre>

<DT><span class="strong">DROP_HEAD_ELEMENT</span>
<DD>
<pre>
⊢ ∀ls n. n < LENGTH ls ⇒ ∃u. DROP n ls = [EL n ls] ++ u
</pre>

<DT><span class="strong">DROP_LASTN</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ DROP n l = LASTN (LENGTH l − n) l
</pre>

<DT><span class="strong">DROP_LENGTH_APPEND</span>
<DD>
<pre>
⊢ ∀l1 l2. DROP (LENGTH l1) (l1 ++ l2) = l2
</pre>

<DT><span class="strong">DROP_LENGTH_NIL</span>
<DD>
<pre>
⊢ ∀l. DROP (LENGTH l) l = []
</pre>

<DT><span class="strong">DROP_LENGTH_NIL_rwt</span>
<DD>
<pre>
⊢ ∀l m. m = LENGTH l ⇒ DROP m l = []
</pre>

<DT><span class="strong">DROP_PREn_LAST_CONS</span>
<DD>
<pre>
⊢ ∀l n. 0 < n ∧ n ≤ LENGTH l ⇒ DROP (n − 1) l = LAST (TAKE n l)::DROP n l
</pre>

<DT><span class="strong">DROP_REPLICATE</span>
<DD>
<pre>
⊢ DROP n (REPLICATE m a) = REPLICATE (m − n) a
</pre>

<DT><span class="strong">DROP_REVERSE</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ DROP n (REVERSE l) = REVERSE (BUTLASTN n l)
</pre>

<DT><span class="strong">DROP_SEG</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ DROP n l = SEG (LENGTH l − n) n l
</pre>

<DT><span class="strong">DROP_SNOC</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ ∀x. DROP n (SNOC x l) = SNOC x (DROP n l)
</pre>

<DT><span class="strong">DROP_SUC</span>
<DD>
<pre>
⊢ ∀n x. DROP (SUC n) x = DROP 1 (DROP n x)
</pre>

<DT><span class="strong">DROP_TAKE_EQ_NIL</span>
<DD>
<pre>
⊢ ∀ls n. DROP n (TAKE n ls) = []
</pre>

<DT><span class="strong">EL</span>
<DD>
<pre>
⊢ (∀l. EL 0 l = HD l) ∧ ∀l n. EL (SUC n) l = EL n (TL l)
</pre>

<DT><span class="strong">ELL_0_SNOC</span>
<DD>
<pre>
⊢ ∀l x. ELL 0 (SNOC x l) = x
</pre>

<DT><span class="strong">ELL_APPEND1</span>
<DD>
<pre>
⊢ ∀l2 n. LENGTH l2 ≤ n ⇒ ∀l1. ELL n (l1 ++ l2) = ELL (n − LENGTH l2) l1
</pre>

<DT><span class="strong">ELL_APPEND2</span>
<DD>
<pre>
⊢ ∀n l2. n < LENGTH l2 ⇒ ∀l1. ELL n (l1 ++ l2) = ELL n l2
</pre>

<DT><span class="strong">ELL_CONS</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ ∀x. ELL n (x::l) = ELL n l
</pre>

<DT><span class="strong">ELL_EL</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ ELL n l = EL (PRE (LENGTH l − n)) l
</pre>

<DT><span class="strong">ELL_IS_EL</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ MEM (ELL n l) l
</pre>

<DT><span class="strong">ELL_LAST</span>
<DD>
<pre>
⊢ ∀l. ¬NULL l ⇒ ELL 0 l = LAST l
</pre>

<DT><span class="strong">ELL_LENGTH_APPEND</span>
<DD>
<pre>
⊢ ∀l1 l2. ¬NULL l1 ⇒ ELL (LENGTH l2) (l1 ++ l2) = LAST l1
</pre>

<DT><span class="strong">ELL_LENGTH_CONS</span>
<DD>
<pre>
⊢ ∀l x. ELL (LENGTH l) (x::l) = x
</pre>

<DT><span class="strong">ELL_LENGTH_SNOC</span>
<DD>
<pre>
⊢ ∀l x. ELL (LENGTH l) (SNOC x l) = if NULL l then x else HD l
</pre>

<DT><span class="strong">ELL_MAP</span>
<DD>
<pre>
⊢ ∀n l f. n < LENGTH l ⇒ ELL n (MAP f l) = f (ELL n l)
</pre>

<DT><span class="strong">ELL_MEM</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ MEM (ELL n l) l
</pre>

<DT><span class="strong">ELL_PRE_LENGTH</span>
<DD>
<pre>
⊢ ∀l. l ≠ [] ⇒ ELL (PRE (LENGTH l)) l = HD l
</pre>

<DT><span class="strong">ELL_REVERSE</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ ELL n (REVERSE l) = ELL (PRE (LENGTH l − n)) l
</pre>

<DT><span class="strong">ELL_REVERSE_EL</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ ELL n (REVERSE l) = EL n l
</pre>

<DT><span class="strong">ELL_SEG</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ ELL n l = HD (SEG 1 (PRE (LENGTH l − n)) l)
</pre>

<DT><span class="strong">ELL_SNOC</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ ∀x l. ELL n (SNOC x l) = ELL (PRE n) l
</pre>

<DT><span class="strong">ELL_SUC_SNOC</span>
<DD>
<pre>
⊢ ∀n x l. ELL (SUC n) (SNOC x l) = ELL n l
</pre>

<DT><span class="strong">ELL_compute</span>
<DD>
<pre>
⊢ (∀l. ELL 0 l = LAST l) ∧
  (∀n l. ELL <..num comp'n..> l = ELL (<..num comp'n..> − 1) (FRONT l)) ∧
  ∀n l. ELL <..num comp'n..> l = ELL <..num comp'n..> (FRONT l)
</pre>

<DT><span class="strong">EL_APPEND</span>
<DD>
<pre>
⊢ ∀n l1 l2.
    EL n (l1 ++ l2) = if n < LENGTH l1 then EL n l1 else EL (n − LENGTH l1) l2
</pre>

<DT><span class="strong">EL_APPEND1</span>
<DD>
<pre>
⊢ ∀n l1 l2. n < LENGTH l1 ⇒ EL n (l1 ++ l2) = EL n l1
</pre>

<DT><span class="strong">EL_APPEND2</span>
<DD>
<pre>
⊢ ∀l1 n. LENGTH l1 ≤ n ⇒ ∀l2. EL n (l1 ++ l2) = EL (n − LENGTH l1) l2
</pre>

<DT><span class="strong">EL_BUTFIRSTN</span>
<DD>
<pre>
⊢ ∀m n l. m + n < LENGTH l ⇒ EL m (DROP n l) = EL (m + n) l
</pre>

<DT><span class="strong">EL_CONS</span>
<DD>
<pre>
⊢ ∀n. 0 < n ⇒ ∀x l. EL n (x::l) = EL (PRE n) l
</pre>

<DT><span class="strong">EL_COUNT_LIST</span>
<DD>
<pre>
⊢ ∀m n. m < n ⇒ EL m (COUNT_LIST n) = m
</pre>

<DT><span class="strong">EL_DROP</span>
<DD>
<pre>
⊢ ∀m n l. m + n < LENGTH l ⇒ EL m (DROP n l) = EL (m + n) l
</pre>

<DT><span class="strong">EL_ELL</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ EL n l = ELL (PRE (LENGTH l − n)) l
</pre>

<DT><span class="strong">EL_FIRSTN</span>
<DD>
<pre>
⊢ ∀n x l. x < n ⇒ EL x (TAKE n l) = EL x l
</pre>

<DT><span class="strong">EL_FRONT</span>
<DD>
<pre>
⊢ ∀l n. n < LENGTH (FRONT l) ∧ ¬NULL l ⇒ EL n (FRONT l) = EL n l
</pre>

<DT><span class="strong">EL_GENLIST</span>
<DD>
<pre>
⊢ ∀f n x. x < n ⇒ EL x (GENLIST f n) = f x
</pre>

<DT><span class="strong">EL_IS_EL</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ MEM (EL n l) l
</pre>

<DT><span class="strong">EL_LENGTH_APPEND</span>
<DD>
<pre>
⊢ ∀l2 l1. ¬NULL l2 ⇒ EL (LENGTH l1) (l1 ++ l2) = HD l2
</pre>

<DT><span class="strong">EL_LENGTH_APPEND_0</span>
<DD>
<pre>
⊢ ∀ls h t. EL (LENGTH ls) (ls ++ h::t) = h
</pre>

<DT><span class="strong">EL_LENGTH_APPEND_1</span>
<DD>
<pre>
⊢ ∀ls h k t. EL (LENGTH ls + 1) (ls ++ h::k::t) = k
</pre>

<DT><span class="strong">EL_LENGTH_APPEND_rwt</span>
<DD>
<pre>
⊢ ¬NULL l2 ∧ n = LENGTH l1 ⇒ EL n (l1 ++ l2) = HD l2
</pre>

<DT><span class="strong">EL_LENGTH_SNOC</span>
<DD>
<pre>
⊢ ∀l x. EL (LENGTH l) (SNOC x l) = x
</pre>

<DT><span class="strong">EL_MAP</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ ∀f. EL n (MAP f l) = f (EL n l)
</pre>

<DT><span class="strong">EL_MEM</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ MEM (EL n l) l
</pre>

<DT><span class="strong">EL_PRE_LENGTH</span>
<DD>
<pre>
⊢ ∀l. l ≠ [] ⇒ EL (PRE (LENGTH l)) l = LAST l
</pre>

<DT><span class="strong">EL_REPLICATE</span>
<DD>
<pre>
⊢ ∀n1 n2 x. n1 < n2 ⇒ EL n1 (REPLICATE n2 x) = x
</pre>

<DT><span class="strong">EL_REVERSE</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ EL n (REVERSE l) = EL (PRE (LENGTH l − n)) l
</pre>

<DT><span class="strong">EL_REVERSE_ELL</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ EL n (REVERSE l) = ELL n l
</pre>

<DT><span class="strong">EL_SEG</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ EL n l = HD (SEG 1 n l)
</pre>

<DT><span class="strong">EL_SNOC</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ ∀x. EL n (SNOC x l) = EL n l
</pre>

<DT><span class="strong">EL_SPLIT</span>
<DD>
<pre>
⊢ ∀ls j. j < LENGTH ls ⇒ ∃l1 l2. ls = l1 ++ EL j ls::l2
</pre>

<DT><span class="strong">EL_SPLIT_2</span>
<DD>
<pre>
⊢ ∀ls j k.
    j < k ∧ k < LENGTH ls ⇒ ∃l1 l2 l3. ls = l1 ++ EL j ls::l2 ++ EL k ls::l3
</pre>

<DT><span class="strong">EL_TAIL</span>
<DD>
<pre>
⊢ ∀h t n. 0 ≠ n ⇒ EL (n − 1) t = EL n (h::t)
</pre>

<DT><span class="strong">EL_TAKE</span>
<DD>
<pre>
⊢ ∀n x l. x < n ⇒ EL x (TAKE n l) = EL x l
</pre>

<DT><span class="strong">EL_chunks</span>
<DD>
<pre>
⊢ ∀k ls n.
    n < LENGTH (chunks k ls) ∧ 0 < k ∧ ¬NULL ls ⇒
    EL n (chunks k ls) = TAKE k (DROP (n * k) ls)
</pre>

<DT><span class="strong">EQ_LIST</span>
<DD>
<pre>
⊢ ∀h1 h2. h1 = h2 ⇒ ∀l1 l2. l1 = l2 ⇒ h1::l1 = h2::l2
</pre>

<DT><span class="strong">EVERY2_APPEND</span>
<DD>
<pre>
⊢ LIST_REL R l1 l2 ∧ LIST_REL R l3 l4 ⇔
  LIST_REL R (l1 ++ l3) (l2 ++ l4) ∧ LENGTH l1 = LENGTH l2 ∧
  LENGTH l3 = LENGTH l4
</pre>

<DT><span class="strong">EVERY2_APPEND_suff</span>
<DD>
<pre>
⊢ LIST_REL R l1 l2 ∧ LIST_REL R l3 l4 ⇒ LIST_REL R (l1 ++ l3) (l2 ++ l4)
</pre>

<DT><span class="strong">EVERY2_DROP</span>
<DD>
<pre>
⊢ ∀R l1 l2 n. LIST_REL R l1 l2 ⇒ LIST_REL R (DROP n l1) (DROP n l2)
</pre>

<DT><span class="strong">EVERY2_REVERSE1</span>
<DD>
<pre>
⊢ ∀l1 l2. LIST_REL R l1 (REVERSE l2) ⇔ LIST_REL R (REVERSE l1) l2
</pre>

<DT><span class="strong">EVERY2_TAKE</span>
<DD>
<pre>
⊢ ∀P xs ys n. LIST_REL P xs ys ⇒ LIST_REL P (TAKE n xs) (TAKE n ys)
</pre>

<DT><span class="strong">EVERY_BUTLASTN</span>
<DD>
<pre>
⊢ ∀P l m. EVERY P l ⇒ EVERY P (BUTLASTN m l)
</pre>

<DT><span class="strong">EVERY_DELETE_ELEMENT</span>
<DD>
<pre>
⊢ ∀e L P. P e ∧ EVERY P (DELETE_ELEMENT e L) ⇒ EVERY P L
</pre>

<DT><span class="strong">EVERY_DROP</span>
<DD>
<pre>
⊢ ∀P l m. EVERY P l ⇒ EVERY P (DROP m l)
</pre>

<DT><span class="strong">EVERY_FOLDL</span>
<DD>
<pre>
⊢ ∀P l. EVERY P l ⇔ FOLDL (λl' x. l' ∧ P x) T l
</pre>

<DT><span class="strong">EVERY_FOLDL_MAP</span>
<DD>
<pre>
⊢ ∀P l. EVERY P l ⇔ FOLDL $/\ T (MAP P l)
</pre>

<DT><span class="strong">EVERY_FOLDR</span>
<DD>
<pre>
⊢ ∀P l. EVERY P l ⇔ FOLDR (λx l'. P x ∧ l') T l
</pre>

<DT><span class="strong">EVERY_FOLDR_MAP</span>
<DD>
<pre>
⊢ ∀P l. EVERY P l ⇔ FOLDR $/\ T (MAP P l)
</pre>

<DT><span class="strong">EVERY_GENLIST</span>
<DD>
<pre>
⊢ ∀n. EVERY P (GENLIST f n) ⇔ ∀i. i < n ⇒ P (f i)
</pre>

<DT><span class="strong">EVERY_LASTN</span>
<DD>
<pre>
⊢ ∀P l m. EVERY P l ⇒ EVERY P (LASTN m l)
</pre>

<DT><span class="strong">EVERY_REPLICATE</span>
<DD>
<pre>
⊢ ∀f n x. EVERY f (REPLICATE n x) ⇔ n = 0 ∨ f x
</pre>

<DT><span class="strong">EVERY_REVERSE</span>
<DD>
<pre>
⊢ ∀P l. EVERY P (REVERSE l) ⇔ EVERY P l
</pre>

<DT><span class="strong">EVERY_SEG</span>
<DD>
<pre>
⊢ ∀P l. EVERY P l ⇒ ∀m k. m + k ≤ LENGTH l ⇒ EVERY P (SEG m k l)
</pre>

<DT><span class="strong">EVERY_TAKE</span>
<DD>
<pre>
⊢ ∀P l m. EVERY P l ⇒ EVERY P (TAKE m l)
</pre>

<DT><span class="strong">EXISTS_BUTLASTN</span>
<DD>
<pre>
⊢ ∀l m P. EXISTS P (BUTLASTN m l) ⇒ EXISTS P l
</pre>

<DT><span class="strong">EXISTS_DISJ</span>
<DD>
<pre>
⊢ ∀P Q l. (EXISTS (λx. P x ∨ Q x) l ⇔ EXISTS P l) ∨ EXISTS Q l
</pre>

<DT><span class="strong">EXISTS_DROP</span>
<DD>
<pre>
⊢ ∀l m P. EXISTS P (DROP m l) ⇒ EXISTS P l
</pre>

<DT><span class="strong">EXISTS_FOLDL</span>
<DD>
<pre>
⊢ ∀P l. EXISTS P l ⇔ FOLDL (λl' x. l' ∨ P x) F l
</pre>

<DT><span class="strong">EXISTS_FOLDL_MAP</span>
<DD>
<pre>
⊢ ∀P l. EXISTS P l ⇔ FOLDL $\/ F (MAP P l)
</pre>

<DT><span class="strong">EXISTS_FOLDR</span>
<DD>
<pre>
⊢ ∀P l. EXISTS P l ⇔ FOLDR (λx l'. P x ∨ l') F l
</pre>

<DT><span class="strong">EXISTS_FOLDR_MAP</span>
<DD>
<pre>
⊢ ∀P l. EXISTS P l ⇔ FOLDR $\/ F (MAP P l)
</pre>

<DT><span class="strong">EXISTS_GENLIST</span>
<DD>
<pre>
⊢ ∀n. EXISTS P (GENLIST f n) ⇔ ∃i. i < n ∧ P (f i)
</pre>

<DT><span class="strong">EXISTS_LASTN</span>
<DD>
<pre>
⊢ ∀l m P. EXISTS P (LASTN m l) ⇒ EXISTS P l
</pre>

<DT><span class="strong">EXISTS_REVERSE</span>
<DD>
<pre>
⊢ ∀P l. EXISTS P (REVERSE l) ⇔ EXISTS P l
</pre>

<DT><span class="strong">EXISTS_SEG</span>
<DD>
<pre>
⊢ ∀m k l. m + k ≤ LENGTH l ⇒ ∀P. EXISTS P (SEG m k l) ⇒ EXISTS P l
</pre>

<DT><span class="strong">EXISTS_TAKE</span>
<DD>
<pre>
⊢ ∀l m P. EXISTS P (TAKE m l) ⇒ EXISTS P l
</pre>

<DT><span class="strong">FCOMM_FOLDL_APPEND</span>
<DD>
<pre>
⊢ ∀f g.
    FCOMM f g ⇒
    ∀e. RIGHT_ID g e ⇒
        ∀l1 l2. FOLDL f e (l1 ++ l2) = g (FOLDL f e l1) (FOLDL f e l2)
</pre>

<DT><span class="strong">FCOMM_FOLDL_FLAT</span>
<DD>
<pre>
⊢ ∀f g.
    FCOMM f g ⇒
    ∀e. RIGHT_ID g e ⇒ ∀l. FOLDL f e (FLAT l) = FOLDL g e (MAP (FOLDL f e) l)
</pre>

<DT><span class="strong">FCOMM_FOLDR_APPEND</span>
<DD>
<pre>
⊢ ∀g f.
    FCOMM g f ⇒
    ∀e. LEFT_ID g e ⇒
        ∀l1 l2. FOLDR f e (l1 ++ l2) = g (FOLDR f e l1) (FOLDR f e l2)
</pre>

<DT><span class="strong">FCOMM_FOLDR_FLAT</span>
<DD>
<pre>
⊢ ∀g f.
    FCOMM g f ⇒
    ∀e. LEFT_ID g e ⇒ ∀l. FOLDR f e (FLAT l) = FOLDR g e (MAP (FOLDR f e) l)
</pre>

<DT><span class="strong">FILTER</span>
<DD>
<pre>
⊢ (∀P. FILTER P [] = []) ∧
  ∀P h t. FILTER P (h::t) = if P h then h::FILTER P t else FILTER P t
</pre>

<DT><span class="strong">FILTER_APPEND</span>
<DD>
<pre>
⊢ ∀P L M. FILTER P (L ++ M) = FILTER P L ++ FILTER P M
</pre>

<DT><span class="strong">FILTER_COMM</span>
<DD>
<pre>
⊢ ∀f1 f2 l. FILTER f1 (FILTER f2 l) = FILTER f2 (FILTER f1 l)
</pre>

<DT><span class="strong">FILTER_EL_IFF</span>
<DD>
<pre>
⊢ ∀P ls l1 l2 x j.
    (let
       fs = FILTER P ls
     in
       ALL_DISTINCT ls ∧ ls = l1 ++ x::l2 ∧ j < LENGTH fs ⇒
       (x = EL j fs ⇔ P x ∧ j = LENGTH (FILTER P l1)))
</pre>

<DT><span class="strong">FILTER_EL_IMP</span>
<DD>
<pre>
⊢ ∀P ls l1 l2 x.
    (let
       fs = FILTER P ls
     in
       ls = l1 ++ x::l2 ∧ P x ⇒ x = EL (LENGTH (FILTER P l1)) fs)
</pre>

<DT><span class="strong">FILTER_EL_NEXT</span>
<DD>
<pre>
⊢ ∀P ls l1 l2 l3 x y.
    (let
       fs = FILTER P ls;
       j = LENGTH (FILTER P l1)
     in
       ls = l1 ++ x::l2 ++ y::l3 ∧ P x ∧ P y ∧ FILTER P l2 = [] ⇒
       x = EL j fs ∧ y = EL (j + 1) fs)
</pre>

<DT><span class="strong">FILTER_EL_NEXT_IFF</span>
<DD>
<pre>
⊢ ∀P ls l1 l2 l3 x y.
    (let
       fs = FILTER P ls;
       j = LENGTH (FILTER P l1)
     in
       ALL_DISTINCT ls ∧ ls = l1 ++ x::l2 ++ y::l3 ∧ P x ∧ P y ⇒
       (x = EL j fs ∧ y = EL (j + 1) fs ⇔ FILTER P l2 = []))
</pre>

<DT><span class="strong">FILTER_EQ</span>
<DD>
<pre>
⊢ ∀P1 P2 l. FILTER P1 l = FILTER P2 l ⇔ ∀x. MEM x l ⇒ (P1 x ⇔ P2 x)
</pre>

<DT><span class="strong">FILTER_FILTER</span>
<DD>
<pre>
⊢ ∀P Q l. FILTER P (FILTER Q l) = FILTER (λx. P x ∧ Q x) l
</pre>

<DT><span class="strong">FILTER_FLAT</span>
<DD>
<pre>
⊢ ∀P l. FILTER P (FLAT l) = FLAT (MAP (FILTER P) l)
</pre>

<DT><span class="strong">FILTER_FOLDL</span>
<DD>
<pre>
⊢ ∀P l. FILTER P l = FOLDL (λl' x. if P x then SNOC x l' else l') [] l
</pre>

<DT><span class="strong">FILTER_FOLDR</span>
<DD>
<pre>
⊢ ∀P l. FILTER P l = FOLDR (λx l'. if P x then x::l' else l') [] l
</pre>

<DT><span class="strong">FILTER_HD</span>
<DD>
<pre>
⊢ ∀P ls l1 l2 x.
    ls = l1 ++ x::l2 ∧ P x ∧ FILTER P l1 = [] ⇒ x = HD (FILTER P ls)
</pre>

<DT><span class="strong">FILTER_HD_IFF</span>
<DD>
<pre>
⊢ ∀P ls l1 l2 x.
    ALL_DISTINCT ls ∧ ls = l1 ++ x::l2 ∧ P x ⇒
    (x = HD (FILTER P ls) ⇔ FILTER P l1 = [])
</pre>

<DT><span class="strong">FILTER_IDEM</span>
<DD>
<pre>
⊢ ∀f l. FILTER f (FILTER f l) = FILTER f l
</pre>

<DT><span class="strong">FILTER_LAST</span>
<DD>
<pre>
⊢ ∀P ls l1 l2 x.
    ls = l1 ++ x::l2 ∧ P x ∧ FILTER P l2 = [] ⇒ x = LAST (FILTER P ls)
</pre>

<DT><span class="strong">FILTER_LAST_IFF</span>
<DD>
<pre>
⊢ ∀P ls l1 l2 x.
    ALL_DISTINCT ls ∧ ls = l1 ++ x::l2 ∧ P x ⇒
    (x = LAST (FILTER P ls) ⇔ FILTER P l2 = [])
</pre>

<DT><span class="strong">FILTER_MAP</span>
<DD>
<pre>
⊢ ∀f1 f2 l. FILTER f1 (MAP f2 l) = MAP f2 (FILTER (f1 ∘ f2) l)
</pre>

<DT><span class="strong">FILTER_MONO_DEC</span>
<DD>
<pre>
⊢ ∀P ls. MONO_DEC ls ⇒ MONO_DEC (FILTER P ls)
</pre>

<DT><span class="strong">FILTER_MONO_INC</span>
<DD>
<pre>
⊢ ∀P ls. MONO_INC ls ⇒ MONO_INC (FILTER P ls)
</pre>

<DT><span class="strong">FILTER_REVERSE</span>
<DD>
<pre>
⊢ ∀l P. FILTER P (REVERSE l) = REVERSE (FILTER P l)
</pre>

<DT><span class="strong">FILTER_SNOC</span>
<DD>
<pre>
⊢ ∀P x l.
    FILTER P (SNOC x l) = if P x then SNOC x (FILTER P l) else FILTER P l
</pre>

<DT><span class="strong">FILTER_sublist</span>
<DD>
<pre>
⊢ ∀P ls. sublist (FILTER P ls) ls
</pre>

<DT><span class="strong">FINITE_common_prefixes</span>
<DD>
<pre>
⊢ s ≠ ∅ ⇒ FINITE (common_prefixes s)
</pre>

<DT><span class="strong">FINITE_prefix</span>
<DD>
<pre>
⊢ FINITE {a | a ≼ b}
</pre>

<DT><span class="strong">FIRSTN</span>
<DD>
<pre>
⊢ (∀l. TAKE 0 l = []) ∧ ∀n x l. TAKE (SUC n) (x::l) = x::TAKE n l
</pre>

<DT><span class="strong">FIRSTN_APPEND1</span>
<DD>
<pre>
⊢ ∀n l1. n ≤ LENGTH l1 ⇒ ∀l2. TAKE n (l1 ++ l2) = TAKE n l1
</pre>

<DT><span class="strong">FIRSTN_APPEND2</span>
<DD>
<pre>
⊢ ∀l1 n.
    LENGTH l1 ≤ n ⇒ ∀l2. TAKE n (l1 ++ l2) = l1 ++ TAKE (n − LENGTH l1) l2
</pre>

<DT><span class="strong">FIRSTN_BUTLASTN</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ TAKE n l = BUTLASTN (LENGTH l − n) l
</pre>

<DT><span class="strong">FIRSTN_FIRSTN</span>
<DD>
<pre>
⊢ ∀m l. m ≤ LENGTH l ⇒ ∀n. n ≤ m ⇒ TAKE n (TAKE m l) = TAKE n l
</pre>

<DT><span class="strong">FIRSTN_LENGTH_APPEND</span>
<DD>
<pre>
⊢ ∀l1 l2. TAKE (LENGTH l1) (l1 ++ l2) = l1
</pre>

<DT><span class="strong">FIRSTN_LENGTH_ID</span>
<DD>
<pre>
⊢ ∀l. TAKE (LENGTH l) l = l
</pre>

<DT><span class="strong">FIRSTN_REVERSE</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ TAKE n (REVERSE l) = REVERSE (LASTN n l)
</pre>

<DT><span class="strong">FIRSTN_SEG</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ TAKE n l = SEG n 0 l
</pre>

<DT><span class="strong">FIRSTN_SNOC</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ ∀x. TAKE n (SNOC x l) = TAKE n l
</pre>

<DT><span class="strong">FLAT</span>
<DD>
<pre>
⊢ FLAT [] = [] ∧ ∀h t. FLAT (h::t) = h ++ FLAT t
</pre>

<DT><span class="strong">FLAT_APPEND</span>
<DD>
<pre>
⊢ ∀l1 l2. FLAT (l1 ++ l2) = FLAT l1 ++ FLAT l2
</pre>

<DT><span class="strong">FLAT_FLAT</span>
<DD>
<pre>
⊢ ∀l. FLAT (FLAT l) = FLAT (MAP FLAT l)
</pre>

<DT><span class="strong">FLAT_FOLDL</span>
<DD>
<pre>
⊢ ∀l. FLAT l = FOLDL $++ [] l
</pre>

<DT><span class="strong">FLAT_FOLDR</span>
<DD>
<pre>
⊢ ∀l. FLAT l = FOLDR $++ [] l
</pre>

<DT><span class="strong">FLAT_REVERSE</span>
<DD>
<pre>
⊢ ∀l. FLAT (REVERSE l) = REVERSE (FLAT (MAP REVERSE l))
</pre>

<DT><span class="strong">FLAT_SNOC</span>
<DD>
<pre>
⊢ ∀x l. FLAT (SNOC x l) = FLAT l ++ x
</pre>

<DT><span class="strong">FLAT_chunks</span>
<DD>
<pre>
⊢ FLAT (chunks n ls) = ls
</pre>

<DT><span class="strong">FOLDL</span>
<DD>
<pre>
⊢ (∀f e. FOLDL f e [] = e) ∧ ∀f e x l. FOLDL f e (x::l) = FOLDL f (f e x) l
</pre>

<DT><span class="strong">FOLDL_APPEND</span>
<DD>
<pre>
⊢ ∀f e l1 l2. FOLDL f e (l1 ++ l2) = FOLDL f (FOLDL f e l1) l2
</pre>

<DT><span class="strong">FOLDL_CONG_invariant</span>
<DD>
<pre>
⊢ ∀P f1 f2 l e.
    P e ∧ (∀x a. MEM x l ∧ P a ⇒ f1 a x = f2 a x ∧ P (f2 a x)) ⇒
    FOLDL f1 e l = FOLDL f2 e l ∧ P (FOLDL f2 e l)
</pre>

<DT><span class="strong">FOLDL_FILTER</span>
<DD>
<pre>
⊢ ∀f e P l.
    FOLDL f e (FILTER P l) = FOLDL (λx y. if P y then f x y else x) e l
</pre>

<DT><span class="strong">FOLDL_FOLDR_REVERSE</span>
<DD>
<pre>
⊢ ∀f e l. FOLDL f e l = FOLDR (λx y. f y x) e (REVERSE l)
</pre>

<DT><span class="strong">FOLDL_MAP</span>
<DD>
<pre>
⊢ ∀f e g l. FOLDL f e (MAP g l) = FOLDL (λx y. f x (g y)) e l
</pre>

<DT><span class="strong">FOLDL_MAP2</span>
<DD>
<pre>
⊢ ∀f e g l. FOLDL f e (MAP g l) = FOLDL (λx y. f x (g y)) e l
</pre>

<DT><span class="strong">FOLDL_REVERSE</span>
<DD>
<pre>
⊢ ∀f e l. FOLDL f e (REVERSE l) = FOLDR (λx y. f y x) e l
</pre>

<DT><span class="strong">FOLDL_SINGLE</span>
<DD>
<pre>
⊢ ∀f e x. FOLDL f e [x] = f e x
</pre>

<DT><span class="strong">FOLDL_SNOC</span>
<DD>
<pre>
⊢ ∀f e x l. FOLDL f e (SNOC x l) = f (FOLDL f e l) x
</pre>

<DT><span class="strong">FOLDL_SNOC_NIL</span>
<DD>
<pre>
⊢ ∀l. FOLDL (λxs x. SNOC x xs) [] l = l
</pre>

<DT><span class="strong">FOLDR</span>
<DD>
<pre>
⊢ (∀f e. FOLDR f e [] = e) ∧ ∀f e x l. FOLDR f e (x::l) = f x (FOLDR f e l)
</pre>

<DT><span class="strong">FOLDR_APPEND</span>
<DD>
<pre>
⊢ ∀f e l1 l2. FOLDR f e (l1 ++ l2) = FOLDR f (FOLDR f e l2) l1
</pre>

<DT><span class="strong">FOLDR_CONS_NIL</span>
<DD>
<pre>
⊢ ∀l. FOLDR CONS [] l = l
</pre>

<DT><span class="strong">FOLDR_FILTER</span>
<DD>
<pre>
⊢ ∀f e P l.
    FOLDR f e (FILTER P l) = FOLDR (λx y. if P x then f x y else y) e l
</pre>

<DT><span class="strong">FOLDR_FILTER_REVERSE</span>
<DD>
<pre>
⊢ ∀f. (∀a b c. f a (f b c) = f b (f a c)) ⇒
      ∀e P l. FOLDR f e (FILTER P (REVERSE l)) = FOLDR f e (FILTER P l)
</pre>

<DT><span class="strong">FOLDR_FOLDL</span>
<DD>
<pre>
⊢ ∀f e. MONOID f e ⇒ ∀l. FOLDR f e l = FOLDL f e l
</pre>

<DT><span class="strong">FOLDR_FOLDL_REVERSE</span>
<DD>
<pre>
⊢ ∀f e l. FOLDR f e l = FOLDL (λx y. f y x) e (REVERSE l)
</pre>

<DT><span class="strong">FOLDR_MAP</span>
<DD>
<pre>
⊢ ∀f e g l. FOLDR f e (MAP g l) = FOLDR (λx y. f (g x) y) e l
</pre>

<DT><span class="strong">FOLDR_MAP_REVERSE</span>
<DD>
<pre>
⊢ ∀f. (∀a b c. f a (f b c) = f b (f a c)) ⇒
      ∀e g l. FOLDR f e (MAP g (REVERSE l)) = FOLDR f e (MAP g l)
</pre>

<DT><span class="strong">FOLDR_REVERSE</span>
<DD>
<pre>
⊢ ∀f e l. FOLDR f e (REVERSE l) = FOLDL (λx y. f y x) e l
</pre>

<DT><span class="strong">FOLDR_SINGLE</span>
<DD>
<pre>
⊢ ∀f e x. FOLDR f e [x] = f x e
</pre>

<DT><span class="strong">FOLDR_SNOC</span>
<DD>
<pre>
⊢ ∀f e x l. FOLDR f e (SNOC x l) = FOLDR f (f x e) l
</pre>

<DT><span class="strong">FRONT_APPEND</span>
<DD>
<pre>
⊢ ∀l1 l2 e. FRONT (l1 ++ e::l2) = l1 ++ FRONT (e::l2)
</pre>

<DT><span class="strong">FRONT_APPEND_NOT_NIL</span>
<DD>
<pre>
⊢ ∀l1 l2. l2 ≠ [] ⇒ FRONT (l1 ++ l2) = l1 ++ FRONT l2
</pre>

<DT><span class="strong">FRONT_BY_TAKE</span>
<DD>
<pre>
⊢ ∀ls. ls ≠ [] ⇒ FRONT ls = TAKE (LENGTH ls − 1) ls
</pre>

<DT><span class="strong">FRONT_EL</span>
<DD>
<pre>
⊢ ∀l n. l ≠ [] ∧ n < LENGTH (FRONT l) ⇒ EL n (FRONT l) = EL n l
</pre>

<DT><span class="strong">FRONT_EQ_NIL</span>
<DD>
<pre>
⊢ ∀l. LENGTH l = 1 ⇒ FRONT l = []
</pre>

<DT><span class="strong">FRONT_LENGTH</span>
<DD>
<pre>
⊢ ∀l. l ≠ [] ⇒ LENGTH (FRONT l) = PRE (LENGTH l)
</pre>

<DT><span class="strong">FRONT_NON_NIL</span>
<DD>
<pre>
⊢ ∀l. 1 < LENGTH l ⇒ FRONT l ≠ []
</pre>

<DT><span class="strong">FRONT_SING</span>
<DD>
<pre>
⊢ ∀x. FRONT [x] = []
</pre>

<DT><span class="strong">GENLIST</span>
<DD>
<pre>
⊢ (∀f. GENLIST f 0 = []) ∧ ∀f n. GENLIST f (SUC n) = SNOC (f n) (GENLIST f n)
</pre>

<DT><span class="strong">GENLIST_APPEND</span>
<DD>
<pre>
⊢ ∀f a b. GENLIST f (a + b) = GENLIST f b ++ GENLIST (λt. f (t + b)) a
</pre>

<DT><span class="strong">GENLIST_CONS</span>
<DD>
<pre>
⊢ GENLIST f (SUC n) = f 0::GENLIST (f ∘ SUC) n
</pre>

<DT><span class="strong">GENLIST_FUN_EQ</span>
<DD>
<pre>
⊢ ∀n f g. GENLIST f n = GENLIST g n ⇔ ∀x. x < n ⇒ f x = g x
</pre>

<DT><span class="strong">GENLIST_K_ADD</span>
<DD>
<pre>
⊢ ∀e n m. GENLIST (K e) (n + m) = GENLIST (K e) m ++ GENLIST (K e) n
</pre>

<DT><span class="strong">GENLIST_K_APPEND</span>
<DD>
<pre>
⊢ ∀a b c. GENLIST (K c) a ++ GENLIST (K c) b = GENLIST (K c) (a + b)
</pre>

<DT><span class="strong">GENLIST_K_APPEND_K</span>
<DD>
<pre>
⊢ ∀c n. GENLIST (K c) n ++ [c] = [c] ++ GENLIST (K c) n
</pre>

<DT><span class="strong">GENLIST_K_CONS</span>
<DD>
<pre>
⊢ ∀e n. GENLIST (K e) (SUC n) = e::GENLIST (K e) n
</pre>

<DT><span class="strong">GENLIST_K_LESS</span>
<DD>
<pre>
⊢ ∀f e n. (∀k. k < n ⇒ f k = e) ⇒ GENLIST f n = GENLIST (K e) n
</pre>

<DT><span class="strong">GENLIST_K_MEM</span>
<DD>
<pre>
⊢ ∀x c n. 0 < n ⇒ (MEM x (GENLIST (K c) n) ⇔ x = c)
</pre>

<DT><span class="strong">GENLIST_K_RANGE</span>
<DD>
<pre>
⊢ ∀f e n.
    (∀k. 0 < k ∧ k ≤ n ⇒ f k = e) ⇒ GENLIST (f ∘ SUC) n = GENLIST (K e) n
</pre>

<DT><span class="strong">GENLIST_K_SET</span>
<DD>
<pre>
⊢ ∀c n. 0 < n ⇒ LIST_TO_SET (GENLIST (K c) n) = {c}
</pre>

<DT><span class="strong">HD</span>
<DD>
<pre>
⊢ ∀h t. HD (h::t) = h
</pre>

<DT><span class="strong">HD_APPEND</span>
<DD>
<pre>
⊢ ∀h t ls. HD (h::t ++ ls) = h
</pre>

<DT><span class="strong">HD_APPEND_NOT_NIL</span>
<DD>
<pre>
⊢ ∀l1 l2. l1 ≠ [] ⇒ HD (l1 ++ l2) = HD l1
</pre>

<DT><span class="strong">HD_GENLIST</span>
<DD>
<pre>
⊢ HD (GENLIST f (SUC n)) = f 0
</pre>

<DT><span class="strong">HEAD_MEM</span>
<DD>
<pre>
⊢ ∀ls. ls ≠ [] ⇒ MEM (HD ls) ls
</pre>

<DT><span class="strong">IS_EL</span>
<DD>
<pre>
⊢ (∀x. MEM x [] ⇔ F) ∧ ∀x h t. MEM x (h::t) ⇔ x = h ∨ MEM x t
</pre>

<DT><span class="strong">IS_EL_APPEND</span>
<DD>
<pre>
⊢ ∀e l1 l2. MEM e (l1 ++ l2) ⇔ MEM e l1 ∨ MEM e l2
</pre>

<DT><span class="strong">IS_EL_BUTFIRSTN</span>
<DD>
<pre>
⊢ ∀l m x. MEM x (DROP m l) ⇒ MEM x l
</pre>

<DT><span class="strong">IS_EL_BUTLASTN</span>
<DD>
<pre>
⊢ ∀l m x. MEM x (BUTLASTN m l) ⇒ MEM x l
</pre>

<DT><span class="strong">IS_EL_DEF</span>
<DD>
<pre>
⊢ ∀x l. MEM x l ⇔ EXISTS ($= x) l
</pre>

<DT><span class="strong">IS_EL_FILTER</span>
<DD>
<pre>
⊢ ∀P L x. MEM x (FILTER P L) ⇔ P x ∧ MEM x L
</pre>

<DT><span class="strong">IS_EL_FIRSTN</span>
<DD>
<pre>
⊢ ∀l m x. MEM x (TAKE m l) ⇒ MEM x l
</pre>

<DT><span class="strong">IS_EL_FOLDL</span>
<DD>
<pre>
⊢ ∀y l. MEM y l ⇔ FOLDL (λl' x. l' ∨ y = x) F l
</pre>

<DT><span class="strong">IS_EL_FOLDL_MAP</span>
<DD>
<pre>
⊢ ∀x l. MEM x l ⇔ FOLDL $\/ F (MAP ($= x) l)
</pre>

<DT><span class="strong">IS_EL_FOLDR</span>
<DD>
<pre>
⊢ ∀y l. MEM y l ⇔ FOLDR (λx l'. y = x ∨ l') F l
</pre>

<DT><span class="strong">IS_EL_FOLDR_MAP</span>
<DD>
<pre>
⊢ ∀x l. MEM x l ⇔ FOLDR $\/ F (MAP ($= x) l)
</pre>

<DT><span class="strong">IS_EL_LASTN</span>
<DD>
<pre>
⊢ ∀m l x. MEM x (LASTN m l) ⇒ MEM x l
</pre>

<DT><span class="strong">IS_EL_REPLICATE</span>
<DD>
<pre>
⊢ ∀n x y. MEM y (REPLICATE n x) ⇔ x = y ∧ 0 < n
</pre>

<DT><span class="strong">IS_EL_REVERSE</span>
<DD>
<pre>
⊢ ∀l x. MEM x (REVERSE l) ⇔ MEM x l
</pre>

<DT><span class="strong">IS_EL_SEG</span>
<DD>
<pre>
⊢ ∀n m l. n + m ≤ LENGTH l ⇒ ∀x. MEM x (SEG n m l) ⇒ MEM x l
</pre>

<DT><span class="strong">IS_EL_SNOC</span>
<DD>
<pre>
⊢ ∀y x l. MEM y (SNOC x l) ⇔ y = x ∨ MEM y l
</pre>

<DT><span class="strong">IS_EL_SOME_EL</span>
<DD>
<pre>
⊢ ∀x l. MEM x l ⇔ EXISTS ($= x) l
</pre>

<DT><span class="strong">IS_PREFIX</span>
<DD>
<pre>
⊢ (∀l. [] ≼ l ⇔ T) ∧ (∀x l. x::l ≼ [] ⇔ F) ∧
  ∀x1 l1 x2 l2. x2::l2 ≼ x1::l1 ⇔ x1 = x2 ∧ l2 ≼ l1
</pre>

<DT><span class="strong">IS_PREFIX_ALL_DISTINCT</span>
<DD>
<pre>
⊢ ∀l l1. l1 ≼ l ∧ ALL_DISTINCT l ⇒ ALL_DISTINCT l1
</pre>

<DT><span class="strong">IS_PREFIX_ANTISYM</span>
<DD>
<pre>
⊢ ∀x y. x ≼ y ∧ y ≼ x ⇒ x = y
</pre>

<DT><span class="strong">IS_PREFIX_APPEND</span>
<DD>
<pre>
⊢ ∀l1 l2. l2 ≼ l1 ⇔ ∃l. l1 = l2 ++ l
</pre>

<DT><span class="strong">IS_PREFIX_APPEND1</span>
<DD>
<pre>
⊢ ∀a b c. a ++ b ≼ c ⇒ a ≼ c
</pre>

<DT><span class="strong">IS_PREFIX_APPEND2</span>
<DD>
<pre>
⊢ ∀a b c. a ≼ b ++ c ⇒ a ≼ b ∨ b ≼ a
</pre>

<DT><span class="strong">IS_PREFIX_APPEND3</span>
<DD>
<pre>
⊢ ∀c a. a ≼ a ++ c
</pre>

<DT><span class="strong">IS_PREFIX_APPENDS</span>
<DD>
<pre>
⊢ ∀a b c. a ++ b ≼ a ++ c ⇔ b ≼ c
</pre>

<DT><span class="strong">IS_PREFIX_BUTLAST</span>
<DD>
<pre>
⊢ ∀x y. FRONT (x::y) ≼ x::y
</pre>

<DT><span class="strong">IS_PREFIX_BUTLAST'</span>
<DD>
<pre>
⊢ ∀l. l ≠ [] ⇒ FRONT l ≼ l
</pre>

<DT><span class="strong">IS_PREFIX_EQ_REWRITE</span>
<DD>
<pre>
⊢ ∀l1 l2 l. l1 ≼ l ∧ l2 ≼ l ⇒ (l1 = l2 ⇔ LENGTH l1 = LENGTH l2)
</pre>

<DT><span class="strong">IS_PREFIX_EQ_TAKE</span>
<DD>
<pre>
⊢ ∀l l1. l1 ≼ l ⇔ ∃n. n ≤ LENGTH l ∧ l1 = TAKE n l
</pre>

<DT><span class="strong">IS_PREFIX_EQ_TAKE'</span>
<DD>
<pre>
⊢ ∀l l1. l1 ≼ l ⇔ ∃n. l1 = TAKE n l
</pre>

<DT><span class="strong">IS_PREFIX_FRONT_CASES</span>
<DD>
<pre>
⊢ ∀l l1. l ≠ [] ⇒ (l1 ≼ l ⇔ l = l1 ∨ l1 ≼ FRONT l)
</pre>

<DT><span class="strong">IS_PREFIX_FRONT_MONO</span>
<DD>
<pre>
⊢ ∀l1 l2. l1 ≠ [] ∧ l2 ≠ [] ∧ l1 ≼ l2 ⇒ FRONT l1 ≼ FRONT l2
</pre>

<DT><span class="strong">IS_PREFIX_GENLIST</span>
<DD>
<pre>
⊢ ∀f m n. GENLIST f m ≼ GENLIST f n ⇔ m ≤ n
</pre>

<DT><span class="strong">IS_PREFIX_IMP_TAKE</span>
<DD>
<pre>
⊢ ∀l l1. l1 ≼ l ⇒ l1 = TAKE (LENGTH l1) l
</pre>

<DT><span class="strong">IS_PREFIX_IS_SUBLIST</span>
<DD>
<pre>
⊢ ∀l1 l2. l2 ≼ l1 ⇒ IS_SUBLIST l1 l2
</pre>

<DT><span class="strong">IS_PREFIX_LENGTH</span>
<DD>
<pre>
⊢ ∀x y. x ≼ y ⇒ LENGTH x ≤ LENGTH y
</pre>

<DT><span class="strong">IS_PREFIX_LENGTH_ANTI</span>
<DD>
<pre>
⊢ ∀x y. x ≼ y ∧ LENGTH x = LENGTH y ⇔ x = y
</pre>

<DT><span class="strong">IS_PREFIX_NIL</span>
<DD>
<pre>
⊢ ∀x. [] ≼ x ∧ (x ≼ [] ⇔ x = [])
</pre>

<DT><span class="strong">IS_PREFIX_PREFIX</span>
<DD>
<pre>
⊢ ∀P l. PREFIX P l ≼ l
</pre>

<DT><span class="strong">IS_PREFIX_REFL</span>
<DD>
<pre>
⊢ ∀x. x ≼ x
</pre>

<DT><span class="strong">IS_PREFIX_REVERSE</span>
<DD>
<pre>
⊢ ∀l1 l2. REVERSE l2 ≼ REVERSE l1 ⇔ IS_SUFFIX l1 l2
</pre>

<DT><span class="strong">IS_PREFIX_SNOC</span>
<DD>
<pre>
⊢ l ≼ SNOC x l
</pre>

<DT><span class="strong">IS_PREFIX_TRANS</span>
<DD>
<pre>
⊢ ∀x y z. y ≼ x ∧ z ≼ y ⇒ z ≼ x
</pre>

<DT><span class="strong">IS_SUBLIST_APPEND</span>
<DD>
<pre>
⊢ ∀l1 l2. IS_SUBLIST l1 l2 ⇔ ∃l l'. l1 = l ++ (l2 ++ l')
</pre>

<DT><span class="strong">IS_SUBLIST_REVERSE</span>
<DD>
<pre>
⊢ ∀l1 l2. IS_SUBLIST (REVERSE l1) (REVERSE l2) ⇔ IS_SUBLIST l1 l2
</pre>

<DT><span class="strong">IS_SUFFIX_ALL_DISTINCT</span>
<DD>
<pre>
⊢ ∀l l1. IS_SUFFIX l l1 ∧ ALL_DISTINCT l ⇒ ALL_DISTINCT l1
</pre>

<DT><span class="strong">IS_SUFFIX_APPEND</span>
<DD>
<pre>
⊢ ∀l1 l2. IS_SUFFIX l1 l2 ⇔ ∃l. l1 = l ++ l2
</pre>

<DT><span class="strong">IS_SUFFIX_APPEND1</span>
<DD>
<pre>
⊢ ∀l1 l2 l. IS_SUFFIX l2 l ⇒ IS_SUFFIX (l1 ++ l2) l
</pre>

<DT><span class="strong">IS_SUFFIX_CONS</span>
<DD>
<pre>
⊢ ∀l1 l2 a. IS_SUFFIX l1 l2 ⇒ IS_SUFFIX (a::l1) l2
</pre>

<DT><span class="strong">IS_SUFFIX_CONS2_E</span>
<DD>
<pre>
⊢ ∀s h t. IS_SUFFIX s (h::t) ⇒ IS_SUFFIX s t
</pre>

<DT><span class="strong">IS_SUFFIX_EQ_DROP</span>
<DD>
<pre>
⊢ ∀l l1. IS_SUFFIX l l1 ⇔ ∃n. n ≤ LENGTH l ∧ l1 = DROP n l
</pre>

<DT><span class="strong">IS_SUFFIX_EQ_DROP'</span>
<DD>
<pre>
⊢ ∀l l1. IS_SUFFIX l l1 ⇔ ∃n. l1 = DROP n l
</pre>

<DT><span class="strong">IS_SUFFIX_IMP_DROP</span>
<DD>
<pre>
⊢ ∀l l1. IS_SUFFIX l l1 ⇒ l1 = DROP (LENGTH l − LENGTH l1) l
</pre>

<DT><span class="strong">IS_SUFFIX_IMP_LASTN</span>
<DD>
<pre>
⊢ ∀l l1. IS_SUFFIX l l1 ⇒ l1 = LASTN (LENGTH l1) l
</pre>

<DT><span class="strong">IS_SUFFIX_IS_SUBLIST</span>
<DD>
<pre>
⊢ ∀l1 l2. IS_SUFFIX l1 l2 ⇒ IS_SUBLIST l1 l2
</pre>

<DT><span class="strong">IS_SUFFIX_REFL</span>
<DD>
<pre>
⊢ ∀l. IS_SUFFIX l l
</pre>

<DT><span class="strong">IS_SUFFIX_REVERSE</span>
<DD>
<pre>
⊢ ∀l2 l1. IS_SUFFIX (REVERSE l1) (REVERSE l2) ⇔ l2 ≼ l1
</pre>

<DT><span class="strong">IS_SUFFIX_TRANS</span>
<DD>
<pre>
⊢ ∀l1 l2 l3. IS_SUFFIX l1 l2 ∧ IS_SUFFIX l2 l3 ⇒ IS_SUFFIX l1 l3
</pre>

<DT><span class="strong">IS_SUFFIX_compute</span>
<DD>
<pre>
⊢ ∀l1 l2. IS_SUFFIX l1 l2 ⇔ REVERSE l2 ≼ REVERSE l1
</pre>

<DT><span class="strong">IS_SUFFIX_dropWhile</span>
<DD>
<pre>
⊢ IS_SUFFIX ls (dropWhile P ls)
</pre>

<DT><span class="strong">ITSET_TO_FOLDR</span>
<DD>
<pre>
⊢ ∀f s b. FINITE s ⇒ ITSET f s b = FOLDR f b (REVERSE (SET_TO_LIST s))
</pre>

<DT><span class="strong">LAST</span>
<DD>
<pre>
⊢ ∀x l. LAST (SNOC x l) = x
</pre>

<DT><span class="strong">LASTN</span>
<DD>
<pre>
⊢ (∀l. LASTN 0 l = []) ∧ ∀n x l. LASTN (SUC n) (SNOC x l) = SNOC x (LASTN n l)
</pre>

<DT><span class="strong">LASTN_1</span>
<DD>
<pre>
⊢ ∀l. l ≠ [] ⇒ LASTN 1 l = [LAST l]
</pre>

<DT><span class="strong">LASTN_APPEND1</span>
<DD>
<pre>
⊢ ∀l2 n.
    LENGTH l2 ≤ n ⇒ ∀l1. LASTN n (l1 ++ l2) = LASTN (n − LENGTH l2) l1 ++ l2
</pre>

<DT><span class="strong">LASTN_APPEND2</span>
<DD>
<pre>
⊢ ∀n l2. n ≤ LENGTH l2 ⇒ ∀l1. LASTN n (l1 ++ l2) = LASTN n l2
</pre>

<DT><span class="strong">LASTN_BUTFIRSTN</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ LASTN n l = DROP (LENGTH l − n) l
</pre>

<DT><span class="strong">LASTN_BUTLASTN</span>
<DD>
<pre>
⊢ ∀n m l.
    n + m ≤ LENGTH l ⇒ LASTN n (BUTLASTN m l) = BUTLASTN m (LASTN (n + m) l)
</pre>

<DT><span class="strong">LASTN_CONS</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ ∀x. LASTN n (x::l) = LASTN n l
</pre>

<DT><span class="strong">LASTN_DROP</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ LASTN n l = DROP (LENGTH l − n) l
</pre>

<DT><span class="strong">LASTN_DROP_UNCOND</span>
<DD>
<pre>
⊢ ∀n l. LASTN n l = DROP (LENGTH l − n) l
</pre>

<DT><span class="strong">LASTN_LASTN</span>
<DD>
<pre>
⊢ ∀l n m. m ≤ LENGTH l ⇒ n ≤ m ⇒ LASTN n (LASTN m l) = LASTN n l
</pre>

<DT><span class="strong">LASTN_LENGTH_APPEND</span>
<DD>
<pre>
⊢ ∀l2 l1. LASTN (LENGTH l2) (l1 ++ l2) = l2
</pre>

<DT><span class="strong">LASTN_LENGTH_ID</span>
<DD>
<pre>
⊢ ∀l. LASTN (LENGTH l) l = l
</pre>

<DT><span class="strong">LASTN_MAP</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ ∀f. LASTN n (MAP f l) = MAP f (LASTN n l)
</pre>

<DT><span class="strong">LASTN_REVERSE</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ LASTN n (REVERSE l) = REVERSE (TAKE n l)
</pre>

<DT><span class="strong">LASTN_SEG</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ LASTN n l = SEG n (LENGTH l − n) l
</pre>

<DT><span class="strong">LASTN_compute</span>
<DD>
<pre>
⊢ ∀n l.
    LASTN n l =
    (let
       m = LENGTH l
     in
       if n ≤ m then DROP (m − n) l
       else FAIL LASTN $var$(longer than list) n l)
</pre>

<DT><span class="strong">LAST_APPEND</span>
<DD>
<pre>
⊢ ∀h l1 l2. LAST (l1 ++ h::l2) = LAST (h::l2)
</pre>

<DT><span class="strong">LAST_APPEND_NOT_NIL</span>
<DD>
<pre>
⊢ ∀l1 l2. l2 ≠ [] ⇒ LAST (l1 ++ l2) = LAST l2
</pre>

<DT><span class="strong">LAST_CONS</span>
<DD>
<pre>
⊢ (∀x. LAST [x] = x) ∧ ∀x y z. LAST (x::y::z) = LAST (y::z)
</pre>

<DT><span class="strong">LAST_EL_CONS</span>
<DD>
<pre>
⊢ ∀h t. t ≠ [] ⇒ LAST t = EL (LENGTH t) (h::t)
</pre>

<DT><span class="strong">LAST_EQ_HD</span>
<DD>
<pre>
⊢ ∀h t. ¬MEM h t ∧ LAST (h::t) = h ⇔ t = []
</pre>

<DT><span class="strong">LAST_LASTN_LAST</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ 0 < n ⇒ LAST (LASTN n l) = LAST l
</pre>

<DT><span class="strong">LAST_MEM</span>
<DD>
<pre>
⊢ ∀ls. ls ≠ [] ⇒ MEM (LAST ls) ls
</pre>

<DT><span class="strong">LENGTH</span>
<DD>
<pre>
⊢ LENGTH [] = 0 ∧ ∀h t. LENGTH (h::t) = SUC (LENGTH t)
</pre>

<DT><span class="strong">LENGTH_APPEND</span>
<DD>
<pre>
⊢ ∀l1 l2. LENGTH (l1 ++ l2) = LENGTH l1 + LENGTH l2
</pre>

<DT><span class="strong">LENGTH_BUTFIRSTN</span>
<DD>
<pre>
⊢ ∀n l. LENGTH (DROP n l) = LENGTH l − n
</pre>

<DT><span class="strong">LENGTH_BUTLAST</span>
<DD>
<pre>
⊢ ∀l. l ≠ [] ⇒ LENGTH (FRONT l) = PRE (LENGTH l)
</pre>

<DT><span class="strong">LENGTH_BUTLASTN</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ LENGTH (BUTLASTN n l) = LENGTH l − n
</pre>

<DT><span class="strong">LENGTH_CONS</span>
<DD>
<pre>
⊢ ∀l n. LENGTH l = SUC n ⇔ ∃h l'. LENGTH l' = n ∧ l = h::l'
</pre>

<DT><span class="strong">LENGTH_COUNT_LIST</span>
<DD>
<pre>
⊢ ∀n. LENGTH (COUNT_LIST n) = n
</pre>

<DT><span class="strong">LENGTH_DELETE_ELEMENT_LE</span>
<DD>
<pre>
⊢ ∀e L. MEM e L ⇒ LENGTH (DELETE_ELEMENT e L) < LENGTH L
</pre>

<DT><span class="strong">LENGTH_DELETE_ELEMENT_LEQ</span>
<DD>
<pre>
⊢ ∀e L. LENGTH (DELETE_ELEMENT e L) ≤ LENGTH L
</pre>

<DT><span class="strong">LENGTH_EQ_NIL</span>
<DD>
<pre>
⊢ ∀P. (∀l. LENGTH l = 0 ⇒ P l) ⇔ P []
</pre>

<DT><span class="strong">LENGTH_FILTER_LEQ</span>
<DD>
<pre>
⊢ ∀P l. LENGTH (FILTER P l) ≤ LENGTH l
</pre>

<DT><span class="strong">LENGTH_FILTER_LESS</span>
<DD>
<pre>
⊢ ∀P ls. EXISTS ($¬ ∘ P) ls ⇒ LENGTH (FILTER P ls) < LENGTH ls
</pre>

<DT><span class="strong">LENGTH_FIRSTN</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ LENGTH (TAKE n l) = n
</pre>

<DT><span class="strong">LENGTH_FLAT</span>
<DD>
<pre>
⊢ ∀l. LENGTH (FLAT l) = SUM (MAP LENGTH l)
</pre>

<DT><span class="strong">LENGTH_FLAT_REPLICATE</span>
<DD>
<pre>
⊢ ∀n. LENGTH (FLAT (REPLICATE n ls)) = n * LENGTH ls
</pre>

<DT><span class="strong">LENGTH_FOLDL</span>
<DD>
<pre>
⊢ ∀l. LENGTH l = FOLDL (λl' x. SUC l') 0 l
</pre>

<DT><span class="strong">LENGTH_FOLDR</span>
<DD>
<pre>
⊢ ∀l. LENGTH l = FOLDR (λx l'. SUC l') 0 l
</pre>

<DT><span class="strong">LENGTH_FRONT</span>
<DD>
<pre>
⊢ ∀l. l ≠ [] ⇒ LENGTH (FRONT l) = PRE (LENGTH l)
</pre>

<DT><span class="strong">LENGTH_GENLIST</span>
<DD>
<pre>
⊢ ∀f n. LENGTH (GENLIST f n) = n
</pre>

<DT><span class="strong">LENGTH_LASTN</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ LENGTH (LASTN n l) = n
</pre>

<DT><span class="strong">LENGTH_MAP</span>
<DD>
<pre>
⊢ ∀l f. LENGTH (MAP f l) = LENGTH l
</pre>

<DT><span class="strong">LENGTH_NIL</span>
<DD>
<pre>
⊢ ∀l. LENGTH l = 0 ⇔ l = []
</pre>

<DT><span class="strong">LENGTH_NOT_NULL</span>
<DD>
<pre>
⊢ ∀l. 0 < LENGTH l ⇔ ¬NULL l
</pre>

<DT><span class="strong">LENGTH_REPLICATE</span>
<DD>
<pre>
⊢ ∀n x. LENGTH (REPLICATE n x) = n
</pre>

<DT><span class="strong">LENGTH_REVERSE</span>
<DD>
<pre>
⊢ ∀l. LENGTH (REVERSE l) = LENGTH l
</pre>

<DT><span class="strong">LENGTH_SCANL</span>
<DD>
<pre>
⊢ ∀f e l. LENGTH (SCANL f e l) = SUC (LENGTH l)
</pre>

<DT><span class="strong">LENGTH_SCANR</span>
<DD>
<pre>
⊢ ∀f e l. LENGTH (SCANR f e l) = SUC (LENGTH l)
</pre>

<DT><span class="strong">LENGTH_SEG</span>
<DD>
<pre>
⊢ ∀n k l. n + k ≤ LENGTH l ⇒ LENGTH (SEG n k l) = n
</pre>

<DT><span class="strong">LENGTH_SING</span>
<DD>
<pre>
⊢ ∀x. LENGTH [x] = 1
</pre>

<DT><span class="strong">LENGTH_SNOC</span>
<DD>
<pre>
⊢ ∀x l. LENGTH (SNOC x l) = SUC (LENGTH l)
</pre>

<DT><span class="strong">LENGTH_TAKE_LE</span>
<DD>
<pre>
⊢ ∀n l. LENGTH (TAKE n l) ≤ LENGTH l
</pre>

<DT><span class="strong">LENGTH_TL_LT</span>
<DD>
<pre>
⊢ ∀ls. ls ≠ [] ⇒ LENGTH (TL ls) < LENGTH ls
</pre>

<DT><span class="strong">LENGTH_UNZIP_FST</span>
<DD>
<pre>
⊢ ∀l. LENGTH (UNZIP_FST l) = LENGTH l
</pre>

<DT><span class="strong">LENGTH_UNZIP_SND</span>
<DD>
<pre>
⊢ ∀l. LENGTH (UNZIP_SND l) = LENGTH l
</pre>

<DT><span class="strong">LENGTH_ZIP</span>
<DD>
<pre>
⊢ ∀l1 l2.
    LENGTH l1 = LENGTH l2 ⇒
    LENGTH (ZIP (l1,l2)) = LENGTH l1 ∧ LENGTH (ZIP (l1,l2)) = LENGTH l2
</pre>

<DT><span class="strong">LENGTH_chunks</span>
<DD>
<pre>
⊢ ∀n ls.
    0 < n ∧ ¬NULL ls ⇒
    LENGTH (chunks n ls) =
    LENGTH ls DIV n + bool_to_bit (¬(n divides LENGTH ls))
</pre>

<DT><span class="strong">LENGTH_dropWhile_id</span>
<DD>
<pre>
⊢ LENGTH (dropWhile P ls) = LENGTH ls ⇔ dropWhile P ls = ls
</pre>

<DT><span class="strong">LIST_ELEM_COUNT_CARD_EL</span>
<DD>
<pre>
⊢ ∀ls. LIST_ELEM_COUNT x ls = CARD {n | n < LENGTH ls ∧ EL n ls = x}
</pre>

<DT><span class="strong">LIST_ELEM_COUNT_MEM</span>
<DD>
<pre>
⊢ ∀e l. LIST_ELEM_COUNT e l > 0 ⇔ MEM e l
</pre>

<DT><span class="strong">LIST_ELEM_COUNT_THM</span>
<DD>
<pre>
⊢ (∀e. LIST_ELEM_COUNT e [] = 0) ∧
  (∀e l1 l2.
     LIST_ELEM_COUNT e (l1 ++ l2) =
     LIST_ELEM_COUNT e l1 + LIST_ELEM_COUNT e l2) ∧
  (∀e h l. h = e ⇒ LIST_ELEM_COUNT e (h::l) = SUC (LIST_ELEM_COUNT e l)) ∧
  ∀e h l. h ≠ e ⇒ LIST_ELEM_COUNT e (h::l) = LIST_ELEM_COUNT e l
</pre>

<DT><span class="strong">LIST_EQ_HEAD_TAIL</span>
<DD>
<pre>
⊢ ∀p q. p ≠ [] ∧ q ≠ [] ⇒ (p = q ⇔ HD p = HD q ∧ TL p = TL q)
</pre>

<DT><span class="strong">LIST_HEAD_TAIL</span>
<DD>
<pre>
⊢ ∀ls. 0 < LENGTH ls ⇔ ls = HD ls::TL ls
</pre>

<DT><span class="strong">LIST_NOT_EQ</span>
<DD>
<pre>
⊢ ∀l1 l2. l1 ≠ l2 ⇒ ∀h1 h2. h1::l1 ≠ h2::l2
</pre>

<DT><span class="strong">LIST_REL_APPEND_SING</span>
<DD>
<pre>
⊢ LIST_REL R (l1 ++ [x1]) (l2 ++ [x2]) ⇔ LIST_REL R l1 l2 ∧ R x1 x2
</pre>

<DT><span class="strong">LIST_REL_GENLIST</span>
<DD>
<pre>
⊢ LIST_REL P (GENLIST f l) (GENLIST g l) ⇔ ∀i. i < l ⇒ P (f i) (g i)
</pre>

<DT><span class="strong">LIST_REL_REPLICATE_same</span>
<DD>
<pre>
⊢ LIST_REL P (REPLICATE n x) (REPLICATE n y) ⇔ 0 < n ⇒ P x y
</pre>

<DT><span class="strong">LIST_REL_REVERSE_EQ</span>
<DD>
<pre>
⊢ LIST_REL R (REVERSE l1) (REVERSE l2) ⇔ LIST_REL R l1 l2
</pre>

<DT><span class="strong">LIST_SING_EQ</span>
<DD>
<pre>
⊢ ∀x y. [x] = [y] ⇔ x = y
</pre>

<DT><span class="strong">LIST_TO_SET_EQ_SING</span>
<DD>
<pre>
⊢ ∀x ls. LIST_TO_SET ls = {x} ⇔ ls ≠ [] ∧ EVERY ($= x) ls
</pre>

<DT><span class="strong">LIST_TO_SET_PREFIX</span>
<DD>
<pre>
⊢ ∀l l1. l1 ≼ l ⇒ LIST_TO_SET l1 ⊆ LIST_TO_SET l
</pre>

<DT><span class="strong">LIST_TO_SET_SING_IFF</span>
<DD>
<pre>
⊢ ∀ls. ls ≠ [] ⇒ (SING (LIST_TO_SET ls) ⇔ ∃c. ls = GENLIST (K c) (LENGTH ls))
</pre>

<DT><span class="strong">LIST_TO_SET_SUFFIX</span>
<DD>
<pre>
⊢ ∀l l1. IS_SUFFIX l l1 ⇒ LIST_TO_SET l1 ⊆ LIST_TO_SET l
</pre>

<DT><span class="strong">LUPDATE_APPEND1</span>
<DD>
<pre>
⊢ ∀l1 l2 n x. n < LENGTH l1 ⇒ LUPDATE x n (l1 ++ l2) = LUPDATE x n l1 ++ l2
</pre>

<DT><span class="strong">LUPDATE_APPEND2</span>
<DD>
<pre>
⊢ ∀l1 l2 n x.
    LENGTH l1 ≤ n ⇒
    LUPDATE x n (l1 ++ l2) = l1 ++ LUPDATE x (n − LENGTH l1) l2
</pre>

<DT><span class="strong">MAP</span>
<DD>
<pre>
⊢ (∀f. MAP f [] = []) ∧ ∀f h t. MAP f (h::t) = f h::MAP f t
</pre>

<DT><span class="strong">MAP2</span>
<DD>
<pre>
⊢ (∀f. MAP2 f [] [] = []) ∧
  ∀f h1 t1 h2 t2. MAP2 f (h1::t1) (h2::t2) = f h1 h2::MAP2 f t1 t2
</pre>

<DT><span class="strong">MAP2_MAP_MAP</span>
<DD>
<pre>
⊢ ∀ls f g1 g2. MAP2 f (MAP g1 ls) (MAP g2 ls) = MAP (λx. f (g1 x) (g2 x)) ls
</pre>

<DT><span class="strong">MAP2_ZIP</span>
<DD>
<pre>
⊢ ∀l1 l2. LENGTH l1 = LENGTH l2 ⇒ ∀f. MAP2 f l1 l2 = MAP fᴾ (ZIP (l1,l2))
</pre>

<DT><span class="strong">MAP_APPEND</span>
<DD>
<pre>
⊢ ∀f l1 l2. MAP f (l1 ++ l2) = MAP f l1 ++ MAP f l2
</pre>

<DT><span class="strong">MAP_COUNT_LIST</span>
<DD>
<pre>
⊢ MAP f (COUNT_LIST n) = GENLIST f n
</pre>

<DT><span class="strong">MAP_EQ_f</span>
<DD>
<pre>
⊢ ∀f1 f2 l. MAP f1 l = MAP f2 l ⇔ ∀e. MEM e l ⇒ f1 e = f2 e
</pre>

<DT><span class="strong">MAP_FILTER</span>
<DD>
<pre>
⊢ ∀f P l. (∀x. P (f x) ⇔ P x) ⇒ MAP f (FILTER P l) = FILTER P (MAP f l)
</pre>

<DT><span class="strong">MAP_FLAT</span>
<DD>
<pre>
⊢ ∀f l. MAP f (FLAT l) = FLAT (MAP (MAP f) l)
</pre>

<DT><span class="strong">MAP_FOLDL</span>
<DD>
<pre>
⊢ ∀f l. MAP f l = FOLDL (λl' x. SNOC (f x) l') [] l
</pre>

<DT><span class="strong">MAP_FOLDR</span>
<DD>
<pre>
⊢ ∀f l. MAP f l = FOLDR (λx l'. f x::l') [] l
</pre>

<DT><span class="strong">MAP_FST_funs</span>
<DD>
<pre>
⊢ MAP (λ(x,y,z). x) funs = MAP FST funs
</pre>

<DT><span class="strong">MAP_GENLIST</span>
<DD>
<pre>
⊢ ∀f g n. MAP f (GENLIST g n) = GENLIST (f ∘ g) n
</pre>

<DT><span class="strong">MAP_HD</span>
<DD>
<pre>
⊢ ∀ls f. ls ≠ [] ⇒ HD (MAP f ls) = f (HD ls)
</pre>

<DT><span class="strong">MAP_MAP_o</span>
<DD>
<pre>
⊢ ∀f g l. MAP f (MAP g l) = MAP (f ∘ g) l
</pre>

<DT><span class="strong">MAP_REVERSE</span>
<DD>
<pre>
⊢ ∀f l. MAP f (REVERSE l) = REVERSE (MAP f l)
</pre>

<DT><span class="strong">MAP_SING</span>
<DD>
<pre>
⊢ ∀f x. MAP f [x] = [f x]
</pre>

<DT><span class="strong">MAP_SND_FILTER_NEQ</span>
<DD>
<pre>
⊢ MAP SND (FILTER (λ(x,y). y ≠ z) ls) = FILTER (λy. z ≠ y) (MAP SND ls)
</pre>

<DT><span class="strong">MAP_SNOC</span>
<DD>
<pre>
⊢ ∀f x l. MAP f (SNOC x l) = SNOC (f x) (MAP f l)
</pre>

<DT><span class="strong">MAP_SUBLIST</span>
<DD>
<pre>
⊢ ∀f p q. sublist p q ⇒ sublist (MAP f p) (MAP f q)
</pre>

<DT><span class="strong">MAP_o</span>
<DD>
<pre>
⊢ ∀f g. MAP (f ∘ g) = MAP f ∘ MAP g
</pre>

<DT><span class="strong">MAX_LIST_CONS</span>
<DD>
<pre>
⊢ ∀h t. MAX_LIST (h::t) = MAX h (MAX_LIST t)
</pre>

<DT><span class="strong">MAX_LIST_EQ_0</span>
<DD>
<pre>
⊢ ∀l. MAX_LIST l = 0 ⇔ EVERY (λx. x = 0) l
</pre>

<DT><span class="strong">MAX_LIST_LE</span>
<DD>
<pre>
⊢ ∀h t. MAX_LIST t ≤ MAX_LIST (h::t)
</pre>

<DT><span class="strong">MAX_LIST_MAP_LE</span>
<DD>
<pre>
⊢ ∀f g. (∀x. f x ≤ g x) ⇒ ∀ls. MAX_LIST (MAP f ls) ≤ MAX_LIST (MAP g ls)
</pre>

<DT><span class="strong">MAX_LIST_MEM</span>
<DD>
<pre>
⊢ ∀l. l ≠ [] ⇒ MEM (MAX_LIST l) l
</pre>

<DT><span class="strong">MAX_LIST_MONO_DEC</span>
<DD>
<pre>
⊢ ∀ls. ls ≠ [] ∧ MONO_DEC ls ⇒ MAX_LIST ls = HD ls
</pre>

<DT><span class="strong">MAX_LIST_MONO_INC</span>
<DD>
<pre>
⊢ ∀ls. ls ≠ [] ∧ MONO_INC ls ⇒ MAX_LIST ls = LAST ls
</pre>

<DT><span class="strong">MAX_LIST_NIL</span>
<DD>
<pre>
⊢ MAX_LIST [] = 0
</pre>

<DT><span class="strong">MAX_LIST_PROPERTY</span>
<DD>
<pre>
⊢ ∀l x. MEM x l ⇒ x ≤ MAX_LIST l
</pre>

<DT><span class="strong">MAX_LIST_SING</span>
<DD>
<pre>
⊢ ∀x. MAX_LIST [x] = x
</pre>

<DT><span class="strong">MAX_LIST_TEST</span>
<DD>
<pre>
⊢ ∀l. l ≠ [] ⇒ ∀x. MEM x l ∧ (∀y. MEM y l ⇒ y ≤ x) ⇒ x = MAX_LIST l
</pre>

<DT><span class="strong">MEM_APPEND_3</span>
<DD>
<pre>
⊢ ∀l1 x l2 h. MEM h (l1 ++ [x] ++ l2) ⇔ MEM h (x::(l1 ++ l2))
</pre>

<DT><span class="strong">MEM_BUTLASTN</span>
<DD>
<pre>
⊢ ∀l m x. MEM x (BUTLASTN m l) ⇒ MEM x l
</pre>

<DT><span class="strong">MEM_COUNT_LIST</span>
<DD>
<pre>
⊢ ∀m n. MEM m (COUNT_LIST n) ⇔ m < n
</pre>

<DT><span class="strong">MEM_DROP_IMP</span>
<DD>
<pre>
⊢ ∀l m x. MEM x (DROP m l) ⇒ MEM x l
</pre>

<DT><span class="strong">MEM_EXISTS</span>
<DD>
<pre>
⊢ ∀x l. MEM x l ⇔ EXISTS ($= x) l
</pre>

<DT><span class="strong">MEM_FOLDL</span>
<DD>
<pre>
⊢ ∀y l. MEM y l ⇔ FOLDL (λl' x. l' ∨ y = x) F l
</pre>

<DT><span class="strong">MEM_FOLDL_MAP</span>
<DD>
<pre>
⊢ ∀x l. MEM x l ⇔ FOLDL $\/ F (MAP ($= x) l)
</pre>

<DT><span class="strong">MEM_FOLDR</span>
<DD>
<pre>
⊢ ∀y l. MEM y l ⇔ FOLDR (λx l'. y = x ∨ l') F l
</pre>

<DT><span class="strong">MEM_FOLDR_MAP</span>
<DD>
<pre>
⊢ ∀x l. MEM x l ⇔ FOLDR $\/ F (MAP ($= x) l)
</pre>

<DT><span class="strong">MEM_FRONT</span>
<DD>
<pre>
⊢ ∀l e y. MEM y (FRONT (e::l)) ⇒ MEM y (e::l)
</pre>

<DT><span class="strong">MEM_FRONT_NOT_LAST</span>
<DD>
<pre>
⊢ ∀ls. ls ≠ [] ∧ ALL_DISTINCT ls ⇒ ¬MEM (LAST ls) (FRONT ls)
</pre>

<DT><span class="strong">MEM_FRONT_NOT_NIL</span>
<DD>
<pre>
⊢ ∀l y. l ≠ [] ∧ MEM y (FRONT l) ⇒ MEM y l
</pre>

<DT><span class="strong">MEM_LAST</span>
<DD>
<pre>
⊢ ∀e l. MEM (LAST (e::l)) (e::l)
</pre>

<DT><span class="strong">MEM_LASTN</span>
<DD>
<pre>
⊢ ∀m l x. MEM x (LASTN m l) ⇒ MEM x l
</pre>

<DT><span class="strong">MEM_LAST_FRONT</span>
<DD>
<pre>
⊢ ∀e l h. MEM e l ∧ e ≠ LAST (h::l) ⇒ MEM e (FRONT (h::l))
</pre>

<DT><span class="strong">MEM_LAST_NOT_NIL</span>
<DD>
<pre>
⊢ ∀e l. l ≠ [] ⇒ MEM (LAST l) l
</pre>

<DT><span class="strong">MEM_REPLICATE</span>
<DD>
<pre>
⊢ ∀n x y. MEM y (REPLICATE n x) ⇔ x = y ∧ 0 < n
</pre>

<DT><span class="strong">MEM_SEG</span>
<DD>
<pre>
⊢ ∀n m l. n + m ≤ LENGTH l ⇒ ∀x. MEM x (SEG n m l) ⇒ MEM x l
</pre>

<DT><span class="strong">MEM_SING_APPEND</span>
<DD>
<pre>
⊢ (∀a c. d ≠ a ++ [b] ++ c) ⇔ ¬MEM b d
</pre>

<DT><span class="strong">MEM_SPLIT_APPEND_distinct</span>
<DD>
<pre>
⊢ ∀l. ALL_DISTINCT l ⇒
      ∀x. MEM x l ⇔ ∃p1 p2. l = p1 ++ [x] ++ p2 ∧ ¬MEM x p1 ∧ ¬MEM x p2
</pre>

<DT><span class="strong">MEM_SPLIT_TAKE_DROP_distinct</span>
<DD>
<pre>
⊢ ∀ls.
    ALL_DISTINCT ls ⇒
    ∀x. MEM x ls ⇔
        ∃k. k < LENGTH ls ∧ x = EL k ls ∧
            ls = TAKE k ls ++ x::DROP (k + 1) ls ∧ ¬MEM x (TAKE k ls) ∧
            ¬MEM x (DROP (k + 1) ls)
</pre>

<DT><span class="strong">MEM_SPLIT_TAKE_DROP_first</span>
<DD>
<pre>
⊢ ∀ls x.
    MEM x ls ⇔
    ∃k. k < LENGTH ls ∧ x = EL k ls ∧ ls = TAKE k ls ++ x::DROP (k + 1) ls ∧
        ¬MEM x (TAKE k ls)
</pre>

<DT><span class="strong">MEM_SPLIT_TAKE_DROP_last</span>
<DD>
<pre>
⊢ ∀ls x.
    MEM x ls ⇔
    ∃k. k < LENGTH ls ∧ x = EL k ls ∧ ls = TAKE k ls ++ x::DROP (k + 1) ls ∧
        ¬MEM x (DROP (k + 1) ls)
</pre>

<DT><span class="strong">MEM_TAKE</span>
<DD>
<pre>
⊢ ∀l m x. MEM x (TAKE m l) ⇒ MEM x l
</pre>

<DT><span class="strong">MIN_LIST_CONS</span>
<DD>
<pre>
⊢ ∀h t. t ≠ [] ⇒ MIN_LIST (h::t) = MIN h (MIN_LIST t)
</pre>

<DT><span class="strong">MIN_LIST_LE</span>
<DD>
<pre>
⊢ ∀h t. t ≠ [] ⇒ MIN_LIST (h::t) ≤ MIN_LIST t
</pre>

<DT><span class="strong">MIN_LIST_LE_MAX_LIST</span>
<DD>
<pre>
⊢ ∀l. l ≠ [] ⇒ MIN_LIST l ≤ MAX_LIST l
</pre>

<DT><span class="strong">MIN_LIST_MAP_LE</span>
<DD>
<pre>
⊢ ∀f g. (∀x. f x ≤ g x) ⇒ ∀ls. MIN_LIST (MAP f ls) ≤ MIN_LIST (MAP g ls)
</pre>

<DT><span class="strong">MIN_LIST_MEM</span>
<DD>
<pre>
⊢ ∀l. l ≠ [] ⇒ MEM (MIN_LIST l) l
</pre>

<DT><span class="strong">MIN_LIST_MONO_DEC</span>
<DD>
<pre>
⊢ ∀ls. ls ≠ [] ∧ MONO_DEC ls ⇒ MIN_LIST ls = LAST ls
</pre>

<DT><span class="strong">MIN_LIST_MONO_INC</span>
<DD>
<pre>
⊢ ∀ls. ls ≠ [] ∧ MONO_INC ls ⇒ MIN_LIST ls = HD ls
</pre>

<DT><span class="strong">MIN_LIST_PROPERTY</span>
<DD>
<pre>
⊢ ∀l. l ≠ [] ⇒ ∀x. MEM x l ⇒ MIN_LIST l ≤ x
</pre>

<DT><span class="strong">MIN_LIST_SING</span>
<DD>
<pre>
⊢ ∀x. MIN_LIST [x] = x
</pre>

<DT><span class="strong">MIN_LIST_TEST</span>
<DD>
<pre>
⊢ ∀l. l ≠ [] ⇒ ∀x. MEM x l ∧ (∀y. MEM y l ⇒ x ≤ y) ⇒ x = MIN_LIST l
</pre>

<DT><span class="strong">MONOID_APPEND_NIL</span>
<DD>
<pre>
⊢ MONOID $++ []
</pre>

<DT><span class="strong">MONOLIST_EQ</span>
<DD>
<pre>
⊢ ∀l1 l2.
    SING (LIST_TO_SET l1) ∧ SING (LIST_TO_SET l2) ⇒
    (l1 = l2 ⇔ LENGTH l1 = LENGTH l2 ∧ LIST_TO_SET l1 = LIST_TO_SET l2)
</pre>

<DT><span class="strong">MONOLIST_SET_SING</span>
<DD>
<pre>
⊢ ∀c ls. ls ≠ [] ∧ EVERY ($= c) ls ⇒ SING (LIST_TO_SET ls)
</pre>

<DT><span class="strong">MONO_DEC_CONS</span>
<DD>
<pre>
⊢ ∀h t. MONO_DEC (h::t) ⇒ MONO_DEC t
</pre>

<DT><span class="strong">MONO_DEC_HD</span>
<DD>
<pre>
⊢ ∀h t x. MONO_DEC (h::t) ∧ MEM x t ⇒ x ≤ h
</pre>

<DT><span class="strong">MONO_DEC_NIL</span>
<DD>
<pre>
⊢ MONO_DEC []
</pre>

<DT><span class="strong">MONO_INC_CONS</span>
<DD>
<pre>
⊢ ∀h t. MONO_INC (h::t) ⇒ MONO_INC t
</pre>

<DT><span class="strong">MONO_INC_HD</span>
<DD>
<pre>
⊢ ∀h t x. MONO_INC (h::t) ∧ MEM x t ⇒ h ≤ x
</pre>

<DT><span class="strong">MONO_INC_NIL</span>
<DD>
<pre>
⊢ MONO_INC []
</pre>

<DT><span class="strong">NIL_IN_common_prefixes</span>
<DD>
<pre>
⊢ [] ∈ common_prefixes s
</pre>

<DT><span class="strong">NIL_NO_MEM</span>
<DD>
<pre>
⊢ ∀ls. ls = [] ⇔ ∀x. ¬MEM x ls
</pre>

<DT><span class="strong">NON_MONO_TAIL_PROPERTY</span>
<DD>
<pre>
⊢ ∀l. ¬SING (LIST_TO_SET (h::t)) ⇒ ∃h'. MEM h' t ∧ h' ≠ h
</pre>

<DT><span class="strong">NOT_ALL_EL_SOME_EL</span>
<DD>
<pre>
⊢ ∀P l. ¬EVERY P l ⇔ EXISTS ($¬ ∘ P) l
</pre>

<DT><span class="strong">NOT_CONS_NIL</span>
<DD>
<pre>
⊢ ∀a1 a0. a0::a1 ≠ []
</pre>

<DT><span class="strong">NOT_EQ_LIST</span>
<DD>
<pre>
⊢ ∀h1 h2. h1 ≠ h2 ⇒ ∀l1 l2. h1::l1 ≠ h2::l2
</pre>

<DT><span class="strong">NOT_IN_DELETE_ELEMENT</span>
<DD>
<pre>
⊢ ∀e L. ¬MEM e (DELETE_ELEMENT e L)
</pre>

<DT><span class="strong">NOT_NIL_CONS</span>
<DD>
<pre>
⊢ ∀a1 a0. [] ≠ a0::a1
</pre>

<DT><span class="strong">NOT_NIL_SNOC</span>
<DD>
<pre>
⊢ ∀x l. [] ≠ SNOC x l
</pre>

<DT><span class="strong">NOT_NULL_SNOC</span>
<DD>
<pre>
⊢ ∀x l. ¬NULL (SNOC x l)
</pre>

<DT><span class="strong">NOT_SNOC_NIL</span>
<DD>
<pre>
⊢ ∀x l. SNOC x l ≠ []
</pre>

<DT><span class="strong">NOT_SOME_EL_ALL_EL</span>
<DD>
<pre>
⊢ ∀P l. ¬EXISTS P l ⇔ EVERY ($¬ ∘ P) l
</pre>

<DT><span class="strong">NULL</span>
<DD>
<pre>
⊢ NULL [] ∧ ∀h t. ¬NULL (h::t)
</pre>

<DT><span class="strong">NULL_DEF</span>
<DD>
<pre>
⊢ (NULL [] ⇔ T) ∧ ∀h t. NULL (h::t) ⇔ F
</pre>

<DT><span class="strong">NULL_EQ_NIL</span>
<DD>
<pre>
⊢ ∀l. NULL l ⇔ l = []
</pre>

<DT><span class="strong">NULL_FOLDL</span>
<DD>
<pre>
⊢ ∀l. NULL l ⇔ FOLDL (λx l'. F) T l
</pre>

<DT><span class="strong">NULL_FOLDR</span>
<DD>
<pre>
⊢ ∀l. NULL l ⇔ FOLDR (λx l'. F) T l
</pre>

<DT><span class="strong">OR_EL_FOLDL</span>
<DD>
<pre>
⊢ ∀l. OR_EL l ⇔ FOLDL $\/ F l
</pre>

<DT><span class="strong">OR_EL_FOLDR</span>
<DD>
<pre>
⊢ ∀l. OR_EL l ⇔ FOLDR $\/ F l
</pre>

<DT><span class="strong">PREFIX</span>
<DD>
<pre>
⊢ (∀P. PREFIX P [] = []) ∧
  ∀P x l. PREFIX P (x::l) = if P x then x::PREFIX P l else []
</pre>

<DT><span class="strong">PREFIX_FOLDR</span>
<DD>
<pre>
⊢ ∀P l. PREFIX P l = FOLDR (λx l'. if P x then x::l' else []) [] l
</pre>

<DT><span class="strong">REPLICATE_APPEND</span>
<DD>
<pre>
⊢ REPLICATE n a ++ REPLICATE m a = REPLICATE (n + m) a
</pre>

<DT><span class="strong">REPLICATE_EQ_CONS</span>
<DD>
<pre>
⊢ REPLICATE n x = y::r ⇔ y = x ∧ ∃m. n = SUC m ∧ r = REPLICATE m x
</pre>

<DT><span class="strong">REPLICATE_GENLIST</span>
<DD>
<pre>
⊢ ∀n x. REPLICATE n x = GENLIST (K x) n
</pre>

<DT><span class="strong">REPLICATE_NIL</span>
<DD>
<pre>
⊢ REPLICATE x y = [] ⇔ x = 0
</pre>

<DT><span class="strong">REPLICATE_compute</span>
<DD>
<pre>
⊢ (∀x. REPLICATE 0 x = []) ∧
  (∀n x. REPLICATE <..num comp'n..> x = x::REPLICATE (<..num comp'n..> − 1) x) ∧
  ∀n x. REPLICATE <..num comp'n..> x = x::REPLICATE <..num comp'n..> x
</pre>

<DT><span class="strong">REVERSE_APPEND</span>
<DD>
<pre>
⊢ ∀l1 l2. REVERSE (l1 ++ l2) = REVERSE l2 ++ REVERSE l1
</pre>

<DT><span class="strong">REVERSE_DROP</span>
<DD>
<pre>
⊢ ∀ls n.
    n ≤ LENGTH ls ⇒ REVERSE (DROP n ls) = REVERSE (LASTN (LENGTH ls − n) ls)
</pre>

<DT><span class="strong">REVERSE_EQ_NIL</span>
<DD>
<pre>
⊢ REVERSE l = [] ⇔ l = []
</pre>

<DT><span class="strong">REVERSE_FLAT</span>
<DD>
<pre>
⊢ ∀l. REVERSE (FLAT l) = FLAT (REVERSE (MAP REVERSE l))
</pre>

<DT><span class="strong">REVERSE_FOLDL</span>
<DD>
<pre>
⊢ ∀l. REVERSE l = FOLDL (λl' x. x::l') [] l
</pre>

<DT><span class="strong">REVERSE_FOLDR</span>
<DD>
<pre>
⊢ ∀l. REVERSE l = FOLDR SNOC [] l
</pre>

<DT><span class="strong">REVERSE_HD</span>
<DD>
<pre>
⊢ ∀ls. ls ≠ [] ⇒ HD (REVERSE ls) = LAST ls
</pre>

<DT><span class="strong">REVERSE_REPLICATE</span>
<DD>
<pre>
⊢ ∀n x. REVERSE (REPLICATE n x) = REPLICATE n x
</pre>

<DT><span class="strong">REVERSE_REVERSE</span>
<DD>
<pre>
⊢ ∀l. REVERSE (REVERSE l) = l
</pre>

<DT><span class="strong">REVERSE_SING</span>
<DD>
<pre>
⊢ ∀x. REVERSE [x] = [x]
</pre>

<DT><span class="strong">REVERSE_SNOC</span>
<DD>
<pre>
⊢ ∀x l. REVERSE (SNOC x l) = x::REVERSE l
</pre>

<DT><span class="strong">REVERSE_TL</span>
<DD>
<pre>
⊢ ∀ls. ls ≠ [] ⇒ TL (REVERSE ls) = REVERSE (FRONT ls)
</pre>

<DT><span class="strong">REVERSE_ZIP</span>
<DD>
<pre>
⊢ ∀l1 l2.
    LENGTH l1 = LENGTH l2 ⇒
    REVERSE (ZIP (l1,l2)) = ZIP (REVERSE l1,REVERSE l2)
</pre>

<DT><span class="strong">SEG1</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ SEG 1 n l = [EL n l]
</pre>

<DT><span class="strong">SEG_0_SNOC</span>
<DD>
<pre>
⊢ ∀m l x. m ≤ LENGTH l ⇒ SEG m 0 (SNOC x l) = SEG m 0 l
</pre>

<DT><span class="strong">SEG_APPEND</span>
<DD>
<pre>
⊢ ∀m l1 n l2.
    m < LENGTH l1 ∧ LENGTH l1 ≤ n + m ∧ n + m ≤ LENGTH l1 + LENGTH l2 ⇒
    SEG n m (l1 ++ l2) =
    SEG (LENGTH l1 − m) m l1 ++ SEG (n + m − LENGTH l1) 0 l2
</pre>

<DT><span class="strong">SEG_APPEND1</span>
<DD>
<pre>
⊢ ∀n m l1. n + m ≤ LENGTH l1 ⇒ ∀l2. SEG n m (l1 ++ l2) = SEG n m l1
</pre>

<DT><span class="strong">SEG_APPEND2</span>
<DD>
<pre>
⊢ ∀l1 m n l2.
    LENGTH l1 ≤ m ∧ n ≤ LENGTH l2 ⇒
    SEG n m (l1 ++ l2) = SEG n (m − LENGTH l1) l2
</pre>

<DT><span class="strong">SEG_CONS</span>
<DD>
<pre>
⊢ ∀j n h t. 0 < j ∧ n + j ≤ LENGTH t + 1 ⇒ SEG n j (h::t) = SEG n (j − 1) t
</pre>

<DT><span class="strong">SEG_LASTN_BUTLASTN</span>
<DD>
<pre>
⊢ ∀n m l.
    n + m ≤ LENGTH l ⇒ SEG n m l = LASTN n (BUTLASTN (LENGTH l − (n + m)) l)
</pre>

<DT><span class="strong">SEG_LENGTH_ID</span>
<DD>
<pre>
⊢ ∀l. SEG (LENGTH l) 0 l = l
</pre>

<DT><span class="strong">SEG_LENGTH_SNOC</span>
<DD>
<pre>
⊢ ∀l x. SEG 1 (LENGTH l) (SNOC x l) = [x]
</pre>

<DT><span class="strong">SEG_REVERSE</span>
<DD>
<pre>
⊢ ∀n m l.
    n + m ≤ LENGTH l ⇒
    SEG n m (REVERSE l) = REVERSE (SEG n (LENGTH l − (n + m)) l)
</pre>

<DT><span class="strong">SEG_SEG</span>
<DD>
<pre>
⊢ ∀n1 m1 n2 m2 l.
    n1 + m1 ≤ LENGTH l ∧ n2 + m2 ≤ n1 ⇒
    SEG n2 m2 (SEG n1 m1 l) = SEG n2 (m1 + m2) l
</pre>

<DT><span class="strong">SEG_SNOC</span>
<DD>
<pre>
⊢ ∀n m l. n + m ≤ LENGTH l ⇒ ∀x. SEG n m (SNOC x l) = SEG n m l
</pre>

<DT><span class="strong">SEG_SUC_CONS</span>
<DD>
<pre>
⊢ ∀m n l x. SEG m (SUC n) (x::l) = SEG m n l
</pre>

<DT><span class="strong">SEG_SUC_EL</span>
<DD>
<pre>
⊢ ∀n i l. i + n < LENGTH l ⇒ SEG (SUC n) i l = EL i l::SEG n (i + 1) l
</pre>

<DT><span class="strong">SEG_TAKE_DROP</span>
<DD>
<pre>
⊢ ∀n m l. n + m ≤ LENGTH l ⇒ SEG n m l = TAKE n (DROP m l)
</pre>

<DT><span class="strong">SEG_compute</span>
<DD>
<pre>
⊢ (∀k l. SEG 0 k l = []) ∧
  (∀m x l. SEG <..num comp'n..> 0 (x::l) = x::SEG (<..num comp'n..> − 1) 0 l) ∧
  (∀m x l. SEG <..num comp'n..> 0 (x::l) = x::SEG <..num comp'n..> 0 l) ∧
  (∀m k x l.
     SEG <..num comp'n..> <..num comp'n..> (x::l) =
     SEG <..num comp'n..> (<..num comp'n..> − 1) l) ∧
  (∀m k x l.
     SEG <..num comp'n..> <..num comp'n..> (x::l) =
     SEG <..num comp'n..> (<..num comp'n..> − 1) l) ∧
  (∀m k x l.
     SEG <..num comp'n..> <..num comp'n..> (x::l) =
     SEG <..num comp'n..> <..num comp'n..> l) ∧
  ∀m k x l.
    SEG <..num comp'n..> <..num comp'n..> (x::l) =
    SEG <..num comp'n..> <..num comp'n..> l
</pre>

<DT><span class="strong">SING_LIST_TO_SET</span>
<DD>
<pre>
⊢ ∀l. LENGTH l = 1 ⇒ SING (LIST_TO_SET l)
</pre>

<DT><span class="strong">SNOC</span>
<DD>
<pre>
⊢ (∀x. SNOC x [] = [x]) ∧ ∀x x' l. SNOC x (x'::l) = x'::SNOC x l
</pre>

<DT><span class="strong">SNOC_11</span>
<DD>
<pre>
⊢ ∀x y a b. SNOC x y = SNOC a b ⇔ x = a ∧ y = b
</pre>

<DT><span class="strong">SNOC_ACYCLIC</span>
<DD>
<pre>
⊢ l ≠ SNOC x l ∧ SNOC x l ≠ l
</pre>

<DT><span class="strong">SNOC_APPEND</span>
<DD>
<pre>
⊢ ∀x l. SNOC x l = l ++ [x]
</pre>

<DT><span class="strong">SNOC_Axiom</span>
<DD>
<pre>
⊢ ∀e f. ∃fn. fn [] = e ∧ ∀x l. fn (SNOC x l) = f x l (fn l)
</pre>

<DT><span class="strong">SNOC_CASES</span>
<DD>
<pre>
⊢ ∀ll. ll = [] ∨ ∃x l. ll = SNOC x l
</pre>

<DT><span class="strong">SNOC_EL_FIRSTN</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ SNOC (EL n l) (TAKE n l) = TAKE (SUC n) l
</pre>

<DT><span class="strong">SNOC_EL_TAKE</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ SNOC (EL n l) (TAKE n l) = TAKE (SUC n) l
</pre>

<DT><span class="strong">SNOC_EQ_LENGTH_EQ</span>
<DD>
<pre>
⊢ ∀x1 l1 x2 l2. SNOC x1 l1 = SNOC x2 l2 ⇒ LENGTH l1 = LENGTH l2
</pre>

<DT><span class="strong">SNOC_FOLDR</span>
<DD>
<pre>
⊢ ∀x l. SNOC x l = FOLDR CONS [x] l
</pre>

<DT><span class="strong">SNOC_INDUCT</span>
<DD>
<pre>
⊢ ∀P. P [] ∧ (∀l. P l ⇒ ∀x. P (SNOC x l)) ⇒ ∀l. P l
</pre>

<DT><span class="strong">SNOC_LASTN</span>
<DD>
<pre>
⊢ ∀l x n. LASTN (SUC n) (SNOC x l) = SNOC x (LASTN n l)
</pre>

<DT><span class="strong">SNOC_LAST_FRONT'</span>
<DD>
<pre>
⊢ ∀l. l ≠ [] ⇒ l = SNOC (LAST l) (FRONT l)
</pre>

<DT><span class="strong">SNOC_REPLICATE</span>
<DD>
<pre>
⊢ ∀n x. SNOC x (REPLICATE n x) = REPLICATE (SUC n) x
</pre>

<DT><span class="strong">SNOC_REVERSE_CONS</span>
<DD>
<pre>
⊢ ∀x l. SNOC x l = REVERSE (x::REVERSE l)
</pre>

<DT><span class="strong">SOME_EL</span>
<DD>
<pre>
⊢ (∀P. EXISTS P [] ⇔ F) ∧ ∀P h t. EXISTS P (h::t) ⇔ P h ∨ EXISTS P t
</pre>

<DT><span class="strong">SOME_EL_APPEND</span>
<DD>
<pre>
⊢ ∀P l1 l2. EXISTS P (l1 ++ l2) ⇔ EXISTS P l1 ∨ EXISTS P l2
</pre>

<DT><span class="strong">SOME_EL_BUTFIRSTN</span>
<DD>
<pre>
⊢ ∀l m P. EXISTS P (DROP m l) ⇒ EXISTS P l
</pre>

<DT><span class="strong">SOME_EL_BUTLASTN</span>
<DD>
<pre>
⊢ ∀l m P. EXISTS P (BUTLASTN m l) ⇒ EXISTS P l
</pre>

<DT><span class="strong">SOME_EL_DISJ</span>
<DD>
<pre>
⊢ ∀P Q l. (EXISTS (λx. P x ∨ Q x) l ⇔ EXISTS P l) ∨ EXISTS Q l
</pre>

<DT><span class="strong">SOME_EL_FIRSTN</span>
<DD>
<pre>
⊢ ∀l m P. EXISTS P (TAKE m l) ⇒ EXISTS P l
</pre>

<DT><span class="strong">SOME_EL_FOLDL</span>
<DD>
<pre>
⊢ ∀P l. EXISTS P l ⇔ FOLDL (λl' x. l' ∨ P x) F l
</pre>

<DT><span class="strong">SOME_EL_FOLDL_MAP</span>
<DD>
<pre>
⊢ ∀P l. EXISTS P l ⇔ FOLDL $\/ F (MAP P l)
</pre>

<DT><span class="strong">SOME_EL_FOLDR</span>
<DD>
<pre>
⊢ ∀P l. EXISTS P l ⇔ FOLDR (λx l'. P x ∨ l') F l
</pre>

<DT><span class="strong">SOME_EL_FOLDR_MAP</span>
<DD>
<pre>
⊢ ∀P l. EXISTS P l ⇔ FOLDR $\/ F (MAP P l)
</pre>

<DT><span class="strong">SOME_EL_LASTN</span>
<DD>
<pre>
⊢ ∀l m P. EXISTS P (LASTN m l) ⇒ EXISTS P l
</pre>

<DT><span class="strong">SOME_EL_MAP</span>
<DD>
<pre>
⊢ ∀P f l. EXISTS P (MAP f l) ⇔ EXISTS (λx. P (f x)) l
</pre>

<DT><span class="strong">SOME_EL_REVERSE</span>
<DD>
<pre>
⊢ ∀P l. EXISTS P (REVERSE l) ⇔ EXISTS P l
</pre>

<DT><span class="strong">SOME_EL_SEG</span>
<DD>
<pre>
⊢ ∀m k l. m + k ≤ LENGTH l ⇒ ∀P. EXISTS P (SEG m k l) ⇒ EXISTS P l
</pre>

<DT><span class="strong">SOME_EL_SNOC</span>
<DD>
<pre>
⊢ ∀P x l. EXISTS P (SNOC x l) ⇔ P x ∨ EXISTS P l
</pre>

<DT><span class="strong">SPLITP_APPEND</span>
<DD>
<pre>
⊢ ∀l1 l2.
    SPLITP P (l1 ++ l2) =
    if EXISTS P l1 then (FST (SPLITP P l1),SND (SPLITP P l1) ++ l2)
    else (l1 ++ FST (SPLITP P l2),SND (SPLITP P l2))
</pre>

<DT><span class="strong">SPLITP_EVERY</span>
<DD>
<pre>
⊢ ∀P l. EVERY (λx. ¬P x) l ⇒ SPLITP P l = (l,[])
</pre>

<DT><span class="strong">SPLITP_IMP</span>
<DD>
<pre>
⊢ ∀P ls l r. SPLITP P ls = (l,r) ⇒ EVERY ($¬ ∘ P) l ∧ (¬NULL r ⇒ P (HD r))
</pre>

<DT><span class="strong">SPLITP_JOIN</span>
<DD>
<pre>
⊢ ∀ls l r. SPLITP P ls = (l,r) ⇒ ls = l ++ r
</pre>

<DT><span class="strong">SPLITP_LENGTH</span>
<DD>
<pre>
⊢ ∀l. LENGTH (FST (SPLITP P l)) + LENGTH (SND (SPLITP P l)) = LENGTH l
</pre>

<DT><span class="strong">SPLITP_NIL_FST_IMP</span>
<DD>
<pre>
⊢ ∀ls r. SPLITP P ls = ([],r) ⇒ r = ls
</pre>

<DT><span class="strong">SPLITP_NIL_SND_EVERY</span>
<DD>
<pre>
⊢ ∀ls r. SPLITP P ls = (r,[]) ⇔ r = ls ∧ EVERY ($¬ ∘ P) ls
</pre>

<DT><span class="strong">SPLITP_compute</span>
<DD>
<pre>
⊢ SPLITP = SPLITP_AUX []
</pre>

<DT><span class="strong">SPLITP_splitAtPki</span>
<DD>
<pre>
⊢ SPLITP P = splitAtPki (K P) $,
</pre>

<DT><span class="strong">SUM</span>
<DD>
<pre>
⊢ SUM [] = 0 ∧ ∀h t. SUM (h::t) = h + SUM t
</pre>

<DT><span class="strong">SUM_APPEND</span>
<DD>
<pre>
⊢ ∀l1 l2. SUM (l1 ++ l2) = SUM l1 + SUM l2
</pre>

<DT><span class="strong">SUM_FLAT</span>
<DD>
<pre>
⊢ ∀l. SUM (FLAT l) = SUM (MAP SUM l)
</pre>

<DT><span class="strong">SUM_FOLDL</span>
<DD>
<pre>
⊢ ∀l. SUM l = FOLDL $+ 0 l
</pre>

<DT><span class="strong">SUM_FOLDR</span>
<DD>
<pre>
⊢ ∀l. SUM l = FOLDR $+ 0 l
</pre>

<DT><span class="strong">SUM_IMAGE_count_MULT</span>
<DD>
<pre>
⊢ (∀m. m < n ⇒ g m = ∑ (λx. f (x + k * m)) (count k)) ⇒
  ∑ f (count (k * n)) = ∑ g (count n)
</pre>

<DT><span class="strong">SUM_IMAGE_count_SUM_GENLIST</span>
<DD>
<pre>
⊢ ∑ f (count n) = SUM (GENLIST f n)
</pre>

<DT><span class="strong">SUM_REPLICATE</span>
<DD>
<pre>
⊢ ∀n k. SUM (REPLICATE n k) = n * k
</pre>

<DT><span class="strong">SUM_REVERSE</span>
<DD>
<pre>
⊢ ∀l. SUM (REVERSE l) = SUM l
</pre>

<DT><span class="strong">SUM_SNOC</span>
<DD>
<pre>
⊢ ∀x l. SUM (SNOC x l) = SUM l + x
</pre>

<DT><span class="strong">SUM_SUBLIST</span>
<DD>
<pre>
⊢ ∀p q. sublist p q ⇒ SUM p ≤ SUM q
</pre>

<DT><span class="strong">TAIL_BY_DROP</span>
<DD>
<pre>
⊢ ∀ls. ls ≠ [] ⇒ TL ls = DROP 1 ls
</pre>

<DT><span class="strong">TAKE</span>
<DD>
<pre>
⊢ (∀l. TAKE 0 l = []) ∧ ∀n x l. TAKE (SUC n) (x::l) = x::TAKE n l
</pre>

<DT><span class="strong">TAKE_1_APPEND</span>
<DD>
<pre>
⊢ ∀x y. x ≠ [] ⇒ TAKE 1 (x ++ y) = TAKE 1 x
</pre>

<DT><span class="strong">TAKE_APPEND</span>
<DD>
<pre>
⊢ ∀n l1 l2. TAKE n (l1 ++ l2) = TAKE n l1 ++ TAKE (n − LENGTH l1) l2
</pre>

<DT><span class="strong">TAKE_APPEND1</span>
<DD>
<pre>
⊢ ∀n l1. n ≤ LENGTH l1 ⇒ ∀l2. TAKE n (l1 ++ l2) = TAKE n l1
</pre>

<DT><span class="strong">TAKE_APPEND2</span>
<DD>
<pre>
⊢ ∀l1 n.
    LENGTH l1 ≤ n ⇒ ∀l2. TAKE n (l1 ++ l2) = l1 ++ TAKE (n − LENGTH l1) l2
</pre>

<DT><span class="strong">TAKE_BUTLASTN</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ TAKE n l = BUTLASTN (LENGTH l − n) l
</pre>

<DT><span class="strong">TAKE_DROP_SUC</span>
<DD>
<pre>
⊢ ∀n l. n < LENGTH l ⇒ TAKE n l ++ [EL n l] ++ DROP (SUC n) l = l
</pre>

<DT><span class="strong">TAKE_DROP_SWAP</span>
<DD>
<pre>
⊢ ∀ls m n. TAKE m (DROP n ls) = DROP n (TAKE (n + m) ls)
</pre>

<DT><span class="strong">TAKE_EL_SNOC</span>
<DD>
<pre>
⊢ ∀ls n. n < LENGTH ls ⇒ TAKE (n + 1) ls = SNOC (EL n ls) (TAKE n ls)
</pre>

<DT><span class="strong">TAKE_FRONT</span>
<DD>
<pre>
⊢ ∀l n. l ≠ [] ∧ n < LENGTH l ⇒ TAKE n (FRONT l) = TAKE n l
</pre>

<DT><span class="strong">TAKE_LENGTH_APPEND</span>
<DD>
<pre>
⊢ ∀l1 l2. TAKE (LENGTH l1) (l1 ++ l2) = l1
</pre>

<DT><span class="strong">TAKE_LENGTH_APPEND2</span>
<DD>
<pre>
⊢ ∀l1 l2 x k. TAKE (LENGTH l1) (LUPDATE x (LENGTH l1 + k) (l1 ++ l2)) = l1
</pre>

<DT><span class="strong">TAKE_PRE_LENGTH</span>
<DD>
<pre>
⊢ ∀ls. ls ≠ [] ⇒ TAKE (PRE (LENGTH ls)) ls = FRONT ls
</pre>

<DT><span class="strong">TAKE_REVERSE</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ TAKE n (REVERSE l) = REVERSE (LASTN n l)
</pre>

<DT><span class="strong">TAKE_SEG</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ TAKE n l = SEG n 0 l
</pre>

<DT><span class="strong">TAKE_SEG_DROP</span>
<DD>
<pre>
⊢ ∀n i l. i + n ≤ LENGTH l ⇒ TAKE i l ++ SEG n i l ++ DROP (i + n) l = l
</pre>

<DT><span class="strong">TAKE_SNOC</span>
<DD>
<pre>
⊢ ∀n l. n ≤ LENGTH l ⇒ ∀x. TAKE n (SNOC x l) = TAKE n l
</pre>

<DT><span class="strong">TAKE_SUC</span>
<DD>
<pre>
⊢ ∀n x. TAKE (SUC n) x = TAKE n x ++ TAKE 1 (DROP n x)
</pre>

<DT><span class="strong">TAKE_SUC_BY_TAKE</span>
<DD>
<pre>
⊢ ∀k x. k < LENGTH x ⇒ TAKE (SUC k) x = SNOC (EL k x) (TAKE k x)
</pre>

<DT><span class="strong">TAKE_TAKE</span>
<DD>
<pre>
⊢ ∀m l. m ≤ LENGTH l ⇒ ∀n. n ≤ m ⇒ TAKE n (TAKE m l) = TAKE n l
</pre>

<DT><span class="strong">TAKE_TAKE_T</span>
<DD>
<pre>
⊢ ∀m l n. n ≤ m ⇒ TAKE n (TAKE m l) = TAKE n l
</pre>

<DT><span class="strong">TL</span>
<DD>
<pre>
⊢ ∀h t. TL (h::t) = t
</pre>

<DT><span class="strong">TL_DROP</span>
<DD>
<pre>
⊢ ∀ls n. n < LENGTH ls ⇒ TL (DROP n ls) = DROP n (TL ls)
</pre>

<DT><span class="strong">TL_GENLIST</span>
<DD>
<pre>
⊢ ∀f n. TL (GENLIST f (SUC n)) = GENLIST (f ∘ SUC) n
</pre>

<DT><span class="strong">TL_SNOC</span>
<DD>
<pre>
⊢ ∀x l. TL (SNOC x l) = if NULL l then [] else SNOC x (TL l)
</pre>

<DT><span class="strong">UNIQUE_LIST_ELEM_COUNT</span>
<DD>
<pre>
⊢ ∀e L. UNIQUE e L ⇔ LIST_ELEM_COUNT e L = 1
</pre>

<DT><span class="strong">UNZIP</span>
<DD>
<pre>
⊢ UNZIP [] = ([],[]) ∧
  ∀x l. UNZIP (x::l) = (FST x::FST (UNZIP l),SND x::SND (UNZIP l))
</pre>

<DT><span class="strong">UNZIP_SNOC</span>
<DD>
<pre>
⊢ ∀x l.
    UNZIP (SNOC x l) =
    (SNOC (FST x) (FST (UNZIP l)),SNOC (SND x) (SND (UNZIP l)))
</pre>

<DT><span class="strong">UNZIP_ZIP</span>
<DD>
<pre>
⊢ ∀l1 l2. LENGTH l1 = LENGTH l2 ⇒ UNZIP (ZIP (l1,l2)) = (l1,l2)
</pre>

<DT><span class="strong">ZIP</span>
<DD>
<pre>
⊢ ZIP ([],[]) = [] ∧ ∀x1 l1 x2 l2. ZIP (x1::l1,x2::l2) = (x1,x2)::ZIP (l1,l2)
</pre>

<DT><span class="strong">ZIP_APPEND</span>
<DD>
<pre>
⊢ ∀a b c d.
    LENGTH a = LENGTH b ∧ LENGTH c = LENGTH d ⇒
    ZIP (a,b) ++ ZIP (c,d) = ZIP (a ++ c,b ++ d)
</pre>

<DT><span class="strong">ZIP_COUNT_LIST</span>
<DD>
<pre>
⊢ n = LENGTH l1 ⇒
  ZIP (l1,COUNT_LIST n) = GENLIST (λn. (EL n l1,n)) (LENGTH l1)
</pre>

<DT><span class="strong">ZIP_FIRSTN</span>
<DD>
<pre>
⊢ ∀n a b.
    n ≤ LENGTH a ∧ LENGTH a = LENGTH b ⇒
    ZIP (TAKE n a,TAKE n b) = TAKE n (ZIP (a,b))
</pre>

<DT><span class="strong">ZIP_FIRSTN_LEQ</span>
<DD>
<pre>
⊢ ∀n a b.
    n ≤ LENGTH a ∧ LENGTH a ≤ LENGTH b ⇒
    ZIP (TAKE n a,TAKE n b) = TAKE n (ZIP (a,TAKE (LENGTH a) b))
</pre>

<DT><span class="strong">ZIP_GENLIST</span>
<DD>
<pre>
⊢ ∀l f n. LENGTH l = n ⇒ ZIP (l,GENLIST f n) = GENLIST (λx. (EL x l,f x)) n
</pre>

<DT><span class="strong">ZIP_MAP_MAP</span>
<DD>
<pre>
⊢ ∀ls f g. ZIP (MAP f ls,MAP g ls) = MAP (λx. (f x,g x)) ls
</pre>

<DT><span class="strong">ZIP_SNOC</span>
<DD>
<pre>
⊢ ∀l1 l2.
    LENGTH l1 = LENGTH l2 ⇒
    ∀x1 x2. ZIP (SNOC x1 l1,SNOC x2 l2) = SNOC (x1,x2) (ZIP (l1,l2))
</pre>

<DT><span class="strong">ZIP_TAKE</span>
<DD>
<pre>
⊢ ∀n a b.
    n ≤ LENGTH a ∧ LENGTH a = LENGTH b ⇒
    ZIP (TAKE n a,TAKE n b) = TAKE n (ZIP (a,b))
</pre>

<DT><span class="strong">ZIP_TAKE_LEQ</span>
<DD>
<pre>
⊢ ∀n a b.
    n ≤ LENGTH a ∧ LENGTH a ≤ LENGTH b ⇒
    ZIP (TAKE n a,TAKE n b) = TAKE n (ZIP (a,TAKE (LENGTH a) b))
</pre>

<DT><span class="strong">ZIP_UNZIP</span>
<DD>
<pre>
⊢ ∀l. ZIP (UNZIP l) = l
</pre>

<DT><span class="strong">all_distinct_count_list</span>
<DD>
<pre>
⊢ ∀n. ALL_DISTINCT (COUNT_LIST n)
</pre>

<DT><span class="strong">all_distinct_list_el_inj</span>
<DD>
<pre>
⊢ ∀ls. ALL_DISTINCT ls ⇒ INJ (λj. EL j ls) (count (LENGTH ls)) 𝕌(:α)
</pre>

<DT><span class="strong">chunks_0</span>
<DD>
<pre>
⊢ chunks 0 ls = [ls]
</pre>

<DT><span class="strong">chunks_MAP</span>
<DD>
<pre>
⊢ ∀n ls. chunks n (MAP f ls) = MAP (MAP f) (chunks n ls)
</pre>

<DT><span class="strong">chunks_NIL</span>
<DD>
<pre>
⊢ chunks n [] = [[]]
</pre>

<DT><span class="strong">chunks_TAKE</span>
<DD>
<pre>
⊢ ∀n ls m.
    n divides m ∧ 0 < m ⇒ chunks n (TAKE m ls) = TAKE (m DIV n) (chunks n ls)
</pre>

<DT><span class="strong">chunks_ZIP</span>
<DD>
<pre>
⊢ ∀n ls l2.
    LENGTH ls = LENGTH l2 ⇒
    chunks n (ZIP (ls,l2)) = MAP ZIP (ZIP (chunks n ls,chunks n l2))
</pre>

<DT><span class="strong">chunks_append_divides</span>
<DD>
<pre>
⊢ ∀n l1 l2.
    0 < n ∧ n divides LENGTH l1 ∧ ¬NULL l1 ∧ ¬NULL l2 ⇒
    chunks n (l1 ++ l2) = chunks n l1 ++ chunks n l2
</pre>

<DT><span class="strong">chunks_def</span>
<DD>
<pre>
⊢ ∀n ls.
    chunks n ls =
    if LENGTH ls ≤ n ∨ n = 0 then [ls] else TAKE n ls::chunks n (DROP n ls)
</pre>

<DT><span class="strong">chunks_ind</span>
<DD>
<pre>
⊢ ∀P. (∀n ls. (¬(LENGTH ls ≤ n ∨ n = 0) ⇒ P n (DROP n ls)) ⇒ P n ls) ⇒
      ∀v v1. P v v1
</pre>

<DT><span class="strong">chunks_length</span>
<DD>
<pre>
⊢ chunks (LENGTH ls) ls = [ls]
</pre>

<DT><span class="strong">chunks_not_nil</span>
<DD>
<pre>
⊢ ∀n ls. chunks n ls ≠ []
</pre>

<DT><span class="strong">chunks_tr_aux_def</span>
<DD>
<pre>
⊢ ∀n ls acc.
    chunks_tr_aux n ls acc =
    if LENGTH ls ≤ SUC n then REVERSE (ls::acc)
    else chunks_tr_aux n (DROP (SUC n) ls) (TAKE (SUC n) ls::acc)
</pre>

<DT><span class="strong">chunks_tr_aux_ind</span>
<DD>
<pre>
⊢ ∀P. (∀n ls acc.
         (¬(LENGTH ls ≤ SUC n) ⇒ P n (DROP (SUC n) ls) (TAKE (SUC n) ls::acc)) ⇒
         P n ls acc) ⇒
      ∀v v1 v2. P v v1 v2
</pre>

<DT><span class="strong">chunks_tr_aux_thm</span>
<DD>
<pre>
⊢ ∀n ls acc. chunks_tr_aux n ls acc = REVERSE acc ++ chunks (SUC n) ls
</pre>

<DT><span class="strong">chunks_tr_thm</span>
<DD>
<pre>
⊢ chunks_tr = chunks
</pre>

<DT><span class="strong">common_prefixes_BIGINTER</span>
<DD>
<pre>
⊢ common_prefixes s = BIGINTER (IMAGE (λl. {p | p ≼ l}) s)
</pre>

<DT><span class="strong">common_prefixes_NIL</span>
<DD>
<pre>
⊢ [] ∈ s ⇒ common_prefixes s = {[]}
</pre>

<DT><span class="strong">common_prefixes_NONEMPTY</span>
<DD>
<pre>
⊢ common_prefixes s ≠ ∅
</pre>

<DT><span class="strong">common_prefixes_PAIR</span>
<DD>
<pre>
⊢ common_prefixes {[]; x} = {[]} ∧ common_prefixes {x; []} = {[]} ∧
  common_prefixes {a::xs; b::ys} =
  [] INSERT if a = b then IMAGE (CONS a) (common_prefixes {xs; ys}) else ∅
</pre>

<DT><span class="strong">count_list_sub1</span>
<DD>
<pre>
⊢ ∀n. n ≠ 0 ⇒ COUNT_LIST n = 0::MAP SUC (COUNT_LIST (n − 1))
</pre>

<DT><span class="strong">divides_EVERY_LENGTH_chunks</span>
<DD>
<pre>
⊢ ∀n ls. ls ≠ [] ∧ n divides LENGTH ls ⇒ EVERY ($= n ∘ LENGTH) (chunks n ls)
</pre>

<DT><span class="strong">el_map_count</span>
<DD>
<pre>
⊢ ∀n f m. n < m ⇒ EL n (MAP f (COUNT_LIST m)) = f n
</pre>

<DT><span class="strong">every_count_list</span>
<DD>
<pre>
⊢ ∀P n. EVERY P (COUNT_LIST n) ⇔ ∀m. m < n ⇒ P m
</pre>

<DT><span class="strong">is_prefix_el</span>
<DD>
<pre>
⊢ ∀n l1 l2. l1 ≼ l2 ∧ n < LENGTH l1 ∧ n < LENGTH l2 ⇒ EL n l1 = EL n l2
</pre>

<DT><span class="strong">list_rel_butlastn</span>
<DD>
<pre>
⊢ ∀f l1 l2 n.
    n ≤ LENGTH l1 ∧ LIST_REL f l1 l2 ⇒
    LIST_REL f (BUTLASTN n l1) (BUTLASTN n l2)
</pre>

<DT><span class="strong">list_rel_lastn</span>
<DD>
<pre>
⊢ ∀f l1 l2 n.
    n ≤ LENGTH l1 ∧ LIST_REL f l1 l2 ⇒ LIST_REL f (LASTN n l1) (LASTN n l2)
</pre>

<DT><span class="strong">list_to_set_eq_el_image</span>
<DD>
<pre>
⊢ ∀ls. LIST_TO_SET ls = IMAGE (λj. EL j ls) (count (LENGTH ls))
</pre>

<DT><span class="strong">longest_prefix_EMPTY</span>
<DD>
<pre>
⊢ longest_prefix ∅ = []
</pre>

<DT><span class="strong">longest_prefix_NIL</span>
<DD>
<pre>
⊢ [] ∈ s ⇒ longest_prefix s = []
</pre>

<DT><span class="strong">longest_prefix_PAIR</span>
<DD>
<pre>
⊢ longest_prefix {[]; ys} = [] ∧ longest_prefix {xs; []} = [] ∧
  longest_prefix {x::xs; y::ys} =
  if x = y then x::longest_prefix {xs; ys} else []
</pre>

<DT><span class="strong">longest_prefix_SING</span>
<DD>
<pre>
⊢ longest_prefix {s} = s
</pre>

<DT><span class="strong">longest_prefix_UNIQUE</span>
<DD>
<pre>
⊢ s ≠ ∅ ∧ is_measure_maximal LENGTH (common_prefixes s) x ∧
  is_measure_maximal LENGTH (common_prefixes s) y ⇒
  x = y
</pre>

<DT><span class="strong">map_replicate</span>
<DD>
<pre>
⊢ ∀f n x. MAP f (REPLICATE n x) = REPLICATE n (f x)
</pre>

<DT><span class="strong">nub_GENLIST</span>
<DD>
<pre>
⊢ nub (GENLIST f n) =
  MAP f (FILTER (λi. ∀j. i < j ∧ j < n ⇒ f i ≠ f j) (COUNT_LIST n))
</pre>

<DT><span class="strong">prefixes_is_prefix_total</span>
<DD>
<pre>
⊢ ∀l l1 l2. l1 ≼ l ∧ l2 ≼ l ⇒ l1 ≼ l2 ∨ l2 ≼ l1
</pre>

<DT><span class="strong">set_list_eq_count</span>
<DD>
<pre>
⊢ ∀ls n. LIST_TO_SET ls = count n ⇒ ∀j. j < LENGTH ls ⇒ EL j ls < n
</pre>

<DT><span class="strong">sublist_ALL_DISTINCT</span>
<DD>
<pre>
⊢ ∀p q. sublist p q ∧ ALL_DISTINCT q ⇒ ALL_DISTINCT p
</pre>

<DT><span class="strong">sublist_MONO_DEC</span>
<DD>
<pre>
⊢ ∀ls sl. sublist sl ls ∧ MONO_DEC ls ⇒ MONO_DEC sl
</pre>

<DT><span class="strong">sublist_MONO_INC</span>
<DD>
<pre>
⊢ ∀ls sl. sublist sl ls ∧ MONO_INC ls ⇒ MONO_INC sl
</pre>

<DT><span class="strong">sublist_antisym</span>
<DD>
<pre>
⊢ ∀p q. sublist p q ∧ sublist q p ⇒ p = q
</pre>

<DT><span class="strong">sublist_append_extend</span>
<DD>
<pre>
⊢ ∀h t q. sublist (h::t) q ⇔ ∃x y. q = x ++ h::y ∧ sublist t y
</pre>

<DT><span class="strong">sublist_append_if</span>
<DD>
<pre>
⊢ ∀p q h. sublist p q ⇒ sublist (p ++ [h]) (q ++ [h])
</pre>

<DT><span class="strong">sublist_append_iff</span>
<DD>
<pre>
⊢ ∀p q h. sublist p q ⇔ sublist (p ++ [h]) (q ++ [h])
</pre>

<DT><span class="strong">sublist_append_include</span>
<DD>
<pre>
⊢ ∀p q x. sublist p q ⇒ sublist p (x ++ q)
</pre>

<DT><span class="strong">sublist_append_only_if</span>
<DD>
<pre>
⊢ ∀p q h. sublist (p ++ [h]) (q ++ [h]) ⇒ sublist p q
</pre>

<DT><span class="strong">sublist_append_pair</span>
<DD>
<pre>
⊢ ∀a b c d. sublist a b ∧ sublist c d ⇒ sublist (a ++ c) (b ++ d)
</pre>

<DT><span class="strong">sublist_append_prefix</span>
<DD>
<pre>
⊢ ∀p q. sublist p (q ++ p)
</pre>

<DT><span class="strong">sublist_append_remove</span>
<DD>
<pre>
⊢ ∀p q x. sublist (x ++ p) q ⇒ sublist p q
</pre>

<DT><span class="strong">sublist_append_suffix</span>
<DD>
<pre>
⊢ ∀p q. sublist p (p ++ q)
</pre>

<DT><span class="strong">sublist_cons</span>
<DD>
<pre>
⊢ ∀h p q. sublist p q ⇔ sublist (h::p) (h::q)
</pre>

<DT><span class="strong">sublist_cons_eq</span>
<DD>
<pre>
⊢ ∀h. (∀p q. sublist (h::p) q ⇒ sublist p q) ⇔
      ∀p q. sublist p q ⇒ sublist p (h::q)
</pre>

<DT><span class="strong">sublist_cons_include</span>
<DD>
<pre>
⊢ ∀h p q. sublist p q ⇒ sublist p (h::q)
</pre>

<DT><span class="strong">sublist_cons_remove</span>
<DD>
<pre>
⊢ ∀h p q. sublist (h::p) q ⇒ sublist p q
</pre>

<DT><span class="strong">sublist_def</span>
<DD>
<pre>
⊢ (∀x. sublist [] x ⇔ T) ∧ (∀t1 h1. sublist (h1::t1) [] ⇔ F) ∧
  ∀t2 t1 h2 h1.
    sublist (h1::t1) (h2::t2) ⇔
    h1 = h2 ∧ sublist t1 t2 ∨ h1 ≠ h2 ∧ sublist (h1::t1) t2
</pre>

<DT><span class="strong">sublist_drop</span>
<DD>
<pre>
⊢ ∀ls n. sublist (DROP n ls) ls
</pre>

<DT><span class="strong">sublist_every</span>
<DD>
<pre>
⊢ ∀l ls. sublist l ls ⇒ ∀P. EVERY P ls ⇒ EVERY P l
</pre>

<DT><span class="strong">sublist_front</span>
<DD>
<pre>
⊢ ∀ls. ls ≠ [] ⇒ sublist (FRONT ls) ls
</pre>

<DT><span class="strong">sublist_head_sing</span>
<DD>
<pre>
⊢ ∀ls. ls ≠ [] ⇒ sublist [HD ls] ls
</pre>

<DT><span class="strong">sublist_ind</span>
<DD>
<pre>
⊢ ∀P. (∀x. P [] x) ∧ (∀h1 t1. P (h1::t1) []) ∧
      (∀h1 t1 h2 t2. P t1 t2 ∧ P (h1::t1) t2 ⇒ P (h1::t1) (h2::t2)) ⇒
      ∀v v1. P v v1
</pre>

<DT><span class="strong">sublist_induct</span>
<DD>
<pre>
⊢ ∀P. (∀y. P [] y) ∧ (∀h x y. P x y ∧ sublist x y ⇒ P (h::x) (h::y)) ∧
      (∀h x y. P x y ∧ sublist x y ⇒ P x (h::y)) ⇒
      ∀x y. sublist x y ⇒ P x y
</pre>

<DT><span class="strong">sublist_last_sing</span>
<DD>
<pre>
⊢ ∀ls. ls ≠ [] ⇒ sublist [LAST ls] ls
</pre>

<DT><span class="strong">sublist_length</span>
<DD>
<pre>
⊢ ∀p q. sublist p q ⇒ LENGTH p ≤ LENGTH q
</pre>

<DT><span class="strong">sublist_mem</span>
<DD>
<pre>
⊢ ∀p q x. sublist p q ∧ MEM x p ⇒ MEM x q
</pre>

<DT><span class="strong">sublist_member_sing</span>
<DD>
<pre>
⊢ ∀ls x. MEM x ls ⇒ sublist [x] ls
</pre>

<DT><span class="strong">sublist_nil</span>
<DD>
<pre>
⊢ ∀p. sublist [] p
</pre>

<DT><span class="strong">sublist_of_nil</span>
<DD>
<pre>
⊢ ∀p. sublist p [] ⇔ p = []
</pre>

<DT><span class="strong">sublist_order</span>
<DD>
<pre>
⊢ ∀ls sl x.
    sublist sl ls ∧ MEM x sl ⇒
    ∃l1 l2 l3 l4.
      ls = l1 ++ [x] ++ l2 ∧ sl = l3 ++ [x] ++ l4 ∧ sublist l3 l1 ∧
      sublist l4 l2
</pre>

<DT><span class="strong">sublist_prefix</span>
<DD>
<pre>
⊢ ∀x p q. sublist p q ⇔ sublist (x ++ p) (x ++ q)
</pre>

<DT><span class="strong">sublist_prefix_nil</span>
<DD>
<pre>
⊢ ∀p q. sublist (p ++ q) q ⇒ p = []
</pre>

<DT><span class="strong">sublist_refl</span>
<DD>
<pre>
⊢ ∀p. sublist p p
</pre>

<DT><span class="strong">sublist_snoc</span>
<DD>
<pre>
⊢ ∀h p q. sublist p q ⇒ sublist (SNOC h p) (SNOC h q)
</pre>

<DT><span class="strong">sublist_subset</span>
<DD>
<pre>
⊢ ∀ls sl. sublist sl ls ⇒ LIST_TO_SET sl ⊆ LIST_TO_SET ls
</pre>

<DT><span class="strong">sublist_suffix</span>
<DD>
<pre>
⊢ ∀x p q. sublist p q ⇔ sublist (p ++ x) (q ++ x)
</pre>

<DT><span class="strong">sublist_tail</span>
<DD>
<pre>
⊢ ∀ls. ls ≠ [] ⇒ sublist (TL ls) ls
</pre>

<DT><span class="strong">sublist_take</span>
<DD>
<pre>
⊢ ∀ls n. sublist (TAKE n ls) ls
</pre>

<DT><span class="strong">sublist_trans</span>
<DD>
<pre>
⊢ ∀p q r. sublist p q ∧ sublist q r ⇒ sublist p r
</pre>

<DT><span class="strong">sum_of_sums</span>
<DD>
<pre>
⊢ ∑ (λm. ∑ (f m) (count a)) (count b) =
  ∑ (λm. f (m DIV a) (m MOD a)) (count (a * b))
</pre>

<DT><span class="strong">take_drop_partition</span>
<DD>
<pre>
⊢ ∀n m l. m ≤ n ⇒ TAKE m l ++ TAKE (n − m) (DROP m l) = TAKE n l
</pre>

<DT><span class="strong">two_common_prefixes</span>
<DD>
<pre>
⊢ s ≠ ∅ ∧ p1 ∈ common_prefixes s ∧ p2 ∈ common_prefixes s ⇒ p1 ≼ p2 ∨ p2 ≼ p1
</pre>

</DL>



<hr>
</body>
</html>
