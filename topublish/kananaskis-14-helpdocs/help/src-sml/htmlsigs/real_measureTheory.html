<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure real_measureTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure real_measureTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/probability/real_measureScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature real_measureTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#additive_def-val">additive_def</a> : thm
<a name="line7"></a>    val <a href="#closed_cdi_def-val">closed_cdi_def</a> : thm
<a name="line8"></a>    val <a href="#countably_additive_def-val">countably_additive_def</a> : thm
<a name="line9"></a>    val <a href="#countably_subadditive_def-val">countably_subadditive_def</a> : thm
<a name="line10"></a>    val <a href="#increasing_def-val">increasing_def</a> : thm
<a name="line11"></a>    val <a href="#inf_measure_def-val">inf_measure_def</a> : thm
<a name="line12"></a>    val <a href="#lambda_system_def-val">lambda_system_def</a> : thm
<a name="line13"></a>    val <a href="#m_space_def-val">m_space_def</a> : thm
<a name="line14"></a>    val <a href="#measurable_sets_def-val">measurable_sets_def</a> : thm
<a name="line15"></a>    val <a href="#measure_def-val">measure_def</a> : thm
<a name="line16"></a>    val <a href="#measure_preserving_def-val">measure_preserving_def</a> : thm
<a name="line17"></a>    val <a href="#measure_space_def-val">measure_space_def</a> : thm
<a name="line18"></a>    val <a href="#mono_convergent_def-val">mono_convergent_def</a> : thm
<a name="line19"></a>    val <a href="#outer_measure_space_def-val">outer_measure_space_def</a> : thm
<a name="line20"></a>    val <a href="#positive_def-val">positive_def</a> : thm
<a name="line21"></a>    val <a href="#smallest_closed_cdi_def-val">smallest_closed_cdi_def</a> : thm
<a name="line22"></a>    val <a href="#subadditive_def-val">subadditive_def</a> : thm
<a name="line23"></a>  
<a name="line24"></a>  (*  Theorems  *)
<a name="line25"></a>    val <a href="#ADDITIVE-val">ADDITIVE</a> : thm
<a name="line26"></a>    val <a href="#ADDITIVE_INCREASING-val">ADDITIVE_INCREASING</a> : thm
<a name="line27"></a>    val <a href="#ADDITIVE_SUM-val">ADDITIVE_SUM</a> : thm
<a name="line28"></a>    val <a href="#ALGEBRA_SUBSET_LAMBDA_SYSTEM-val">ALGEBRA_SUBSET_LAMBDA_SYSTEM</a> : thm
<a name="line29"></a>    val <a href="#CARATHEODORY-val">CARATHEODORY</a> : thm
<a name="line30"></a>    val <a href="#CARATHEODORY_LEMMA-val">CARATHEODORY_LEMMA</a> : thm
<a name="line31"></a>    val <a href="#CLOSED_CDI_COMPL-val">CLOSED_CDI_COMPL</a> : thm
<a name="line32"></a>    val <a href="#CLOSED_CDI_DISJOINT-val">CLOSED_CDI_DISJOINT</a> : thm
<a name="line33"></a>    val <a href="#CLOSED_CDI_DUNION-val">CLOSED_CDI_DUNION</a> : thm
<a name="line34"></a>    val <a href="#CLOSED_CDI_INCREASING-val">CLOSED_CDI_INCREASING</a> : thm
<a name="line35"></a>    val <a href="#COUNTABLY_ADDITIVE-val">COUNTABLY_ADDITIVE</a> : thm
<a name="line36"></a>    val <a href="#COUNTABLY_ADDITIVE_ADDITIVE-val">COUNTABLY_ADDITIVE_ADDITIVE</a> : thm
<a name="line37"></a>    val <a href="#COUNTABLY_SUBADDITIVE-val">COUNTABLY_SUBADDITIVE</a> : thm
<a name="line38"></a>    val <a href="#COUNTABLY_SUBADDITIVE_SUBADDITIVE-val">COUNTABLY_SUBADDITIVE_SUBADDITIVE</a> : thm
<a name="line39"></a>    val <a href="#INCREASING-val">INCREASING</a> : thm
<a name="line40"></a>    val <a href="#INCREASING_ADDITIVE_SUMMABLE-val">INCREASING_ADDITIVE_SUMMABLE</a> : thm
<a name="line41"></a>    val <a href="#INF_MEASURE_AGREES-val">INF_MEASURE_AGREES</a> : thm
<a name="line42"></a>    val <a href="#INF_MEASURE_CLOSE-val">INF_MEASURE_CLOSE</a> : thm
<a name="line43"></a>    val <a href="#INF_MEASURE_COUNTABLY_SUBADDITIVE-val">INF_MEASURE_COUNTABLY_SUBADDITIVE</a> : thm
<a name="line44"></a>    val <a href="#INF_MEASURE_EMPTY-val">INF_MEASURE_EMPTY</a> : thm
<a name="line45"></a>    val <a href="#INF_MEASURE_INCREASING-val">INF_MEASURE_INCREASING</a> : thm
<a name="line46"></a>    val <a href="#INF_MEASURE_LE-val">INF_MEASURE_LE</a> : thm
<a name="line47"></a>    val <a href="#INF_MEASURE_NONEMPTY-val">INF_MEASURE_NONEMPTY</a> : thm
<a name="line48"></a>    val <a href="#INF_MEASURE_OUTER-val">INF_MEASURE_OUTER</a> : thm
<a name="line49"></a>    val <a href="#INF_MEASURE_POS-val">INF_MEASURE_POS</a> : thm
<a name="line50"></a>    val <a href="#INF_MEASURE_POS0-val">INF_MEASURE_POS0</a> : thm
<a name="line51"></a>    val <a href="#INF_MEASURE_POSITIVE-val">INF_MEASURE_POSITIVE</a> : thm
<a name="line52"></a>    val <a href="#IN_MEASURE_PRESERVING-val">IN_MEASURE_PRESERVING</a> : thm
<a name="line53"></a>    val <a href="#LAMBDA_SYSTEM_ADDITIVE-val">LAMBDA_SYSTEM_ADDITIVE</a> : thm
<a name="line54"></a>    val <a href="#LAMBDA_SYSTEM_ALGEBRA-val">LAMBDA_SYSTEM_ALGEBRA</a> : thm
<a name="line55"></a>    val <a href="#LAMBDA_SYSTEM_CARATHEODORY-val">LAMBDA_SYSTEM_CARATHEODORY</a> : thm
<a name="line56"></a>    val <a href="#LAMBDA_SYSTEM_COMPL-val">LAMBDA_SYSTEM_COMPL</a> : thm
<a name="line57"></a>    val <a href="#LAMBDA_SYSTEM_EMPTY-val">LAMBDA_SYSTEM_EMPTY</a> : thm
<a name="line58"></a>    val <a href="#LAMBDA_SYSTEM_INCREASING-val">LAMBDA_SYSTEM_INCREASING</a> : thm
<a name="line59"></a>    val <a href="#LAMBDA_SYSTEM_INTER-val">LAMBDA_SYSTEM_INTER</a> : thm
<a name="line60"></a>    val <a href="#LAMBDA_SYSTEM_POSITIVE-val">LAMBDA_SYSTEM_POSITIVE</a> : thm
<a name="line61"></a>    val <a href="#LAMBDA_SYSTEM_STRONG_ADDITIVE-val">LAMBDA_SYSTEM_STRONG_ADDITIVE</a> : thm
<a name="line62"></a>    val <a href="#LAMBDA_SYSTEM_STRONG_SUM-val">LAMBDA_SYSTEM_STRONG_SUM</a> : thm
<a name="line63"></a>    val <a href="#MEASURABLE_POW_TO_POW-val">MEASURABLE_POW_TO_POW</a> : thm
<a name="line64"></a>    val <a href="#MEASURABLE_POW_TO_POW_IMAGE-val">MEASURABLE_POW_TO_POW_IMAGE</a> : thm
<a name="line65"></a>    val <a href="#MEASURABLE_RANGE_REDUCE-val">MEASURABLE_RANGE_REDUCE</a> : thm
<a name="line66"></a>    val <a href="#MEASURABLE_SETS_SUBSET_SPACE-val">MEASURABLE_SETS_SUBSET_SPACE</a> : thm
<a name="line67"></a>    val <a href="#MEASURE_ADDITIVE-val">MEASURE_ADDITIVE</a> : thm
<a name="line68"></a>    val <a href="#MEASURE_COMPL-val">MEASURE_COMPL</a> : thm
<a name="line69"></a>    val <a href="#MEASURE_COMPL_SUBSET-val">MEASURE_COMPL_SUBSET</a> : thm
<a name="line70"></a>    val <a href="#MEASURE_COUNTABLE_INCREASING-val">MEASURE_COUNTABLE_INCREASING</a> : thm
<a name="line71"></a>    val <a href="#MEASURE_COUNTABLY_ADDITIVE-val">MEASURE_COUNTABLY_ADDITIVE</a> : thm
<a name="line72"></a>    val <a href="#MEASURE_DOWN-val">MEASURE_DOWN</a> : thm
<a name="line73"></a>    val <a href="#MEASURE_EMPTY-val">MEASURE_EMPTY</a> : thm
<a name="line74"></a>    val <a href="#MEASURE_PRESERVING_LIFT-val">MEASURE_PRESERVING_LIFT</a> : thm
<a name="line75"></a>    val <a href="#MEASURE_PRESERVING_SUBSET-val">MEASURE_PRESERVING_SUBSET</a> : thm
<a name="line76"></a>    val <a href="#MEASURE_PRESERVING_UP_LIFT-val">MEASURE_PRESERVING_UP_LIFT</a> : thm
<a name="line77"></a>    val <a href="#MEASURE_PRESERVING_UP_SIGMA-val">MEASURE_PRESERVING_UP_SIGMA</a> : thm
<a name="line78"></a>    val <a href="#MEASURE_PRESERVING_UP_SUBSET-val">MEASURE_PRESERVING_UP_SUBSET</a> : thm
<a name="line79"></a>    val <a href="#MEASURE_REAL_SUM_IMAGE-val">MEASURE_REAL_SUM_IMAGE</a> : thm
<a name="line80"></a>    val <a href="#MEASURE_SPACE_ADDITIVE-val">MEASURE_SPACE_ADDITIVE</a> : thm
<a name="line81"></a>    val <a href="#MEASURE_SPACE_BIGINTER-val">MEASURE_SPACE_BIGINTER</a> : thm
<a name="line82"></a>    val <a href="#MEASURE_SPACE_BIGUNION-val">MEASURE_SPACE_BIGUNION</a> : thm
<a name="line83"></a>    val <a href="#MEASURE_SPACE_CMUL-val">MEASURE_SPACE_CMUL</a> : thm
<a name="line84"></a>    val <a href="#MEASURE_SPACE_DIFF-val">MEASURE_SPACE_DIFF</a> : thm
<a name="line85"></a>    val <a href="#MEASURE_SPACE_EMPTY_MEASURABLE-val">MEASURE_SPACE_EMPTY_MEASURABLE</a> : thm
<a name="line86"></a>    val <a href="#MEASURE_SPACE_INCREASING-val">MEASURE_SPACE_INCREASING</a> : thm
<a name="line87"></a>    val <a href="#MEASURE_SPACE_INTER-val">MEASURE_SPACE_INTER</a> : thm
<a name="line88"></a>    val <a href="#MEASURE_SPACE_IN_MSPACE-val">MEASURE_SPACE_IN_MSPACE</a> : thm
<a name="line89"></a>    val <a href="#MEASURE_SPACE_MSPACE_MEASURABLE-val">MEASURE_SPACE_MSPACE_MEASURABLE</a> : thm
<a name="line90"></a>    val <a href="#MEASURE_SPACE_POSITIVE-val">MEASURE_SPACE_POSITIVE</a> : thm
<a name="line91"></a>    val <a href="#MEASURE_SPACE_REDUCE-val">MEASURE_SPACE_REDUCE</a> : thm
<a name="line92"></a>    val <a href="#MEASURE_SPACE_RESTRICTED-val">MEASURE_SPACE_RESTRICTED</a> : thm
<a name="line93"></a>    val <a href="#MEASURE_SPACE_SUBSET-val">MEASURE_SPACE_SUBSET</a> : thm
<a name="line94"></a>    val <a href="#MEASURE_SPACE_SUBSET_MSPACE-val">MEASURE_SPACE_SUBSET_MSPACE</a> : thm
<a name="line95"></a>    val <a href="#MEASURE_SPACE_UNION-val">MEASURE_SPACE_UNION</a> : thm
<a name="line96"></a>    val <a href="#MONOTONE_CONVERGENCE-val">MONOTONE_CONVERGENCE</a> : thm
<a name="line97"></a>    val <a href="#MONOTONE_CONVERGENCE2-val">MONOTONE_CONVERGENCE2</a> : thm
<a name="line98"></a>    val <a href="#MONOTONE_CONVERGENCE_BIGINTER-val">MONOTONE_CONVERGENCE_BIGINTER</a> : thm
<a name="line99"></a>    val <a href="#MONOTONE_CONVERGENCE_BIGINTER2-val">MONOTONE_CONVERGENCE_BIGINTER2</a> : thm
<a name="line100"></a>    val <a href="#OUTER_MEASURE_SPACE_POSITIVE-val">OUTER_MEASURE_SPACE_POSITIVE</a> : thm
<a name="line101"></a>    val <a href="#SIGMA_PROPERTY_DISJOINT_LEMMA-val">SIGMA_PROPERTY_DISJOINT_LEMMA</a> : thm
<a name="line102"></a>    val <a href="#SIGMA_PROPERTY_DISJOINT_LEMMA1-val">SIGMA_PROPERTY_DISJOINT_LEMMA1</a> : thm
<a name="line103"></a>    val <a href="#SIGMA_PROPERTY_DISJOINT_LEMMA2-val">SIGMA_PROPERTY_DISJOINT_LEMMA2</a> : thm
<a name="line104"></a>    val <a href="#SIGMA_SUBSET_MEASURABLE_SETS-val">SIGMA_SUBSET_MEASURABLE_SETS</a> : thm
<a name="line105"></a>    val <a href="#SMALLEST_CLOSED_CDI-val">SMALLEST_CLOSED_CDI</a> : thm
<a name="line106"></a>    val <a href="#SPACE_SMALLEST_CLOSED_CDI-val">SPACE_SMALLEST_CLOSED_CDI</a> : thm
<a name="line107"></a>    val <a href="#STRONG_MEASURE_SPACE_SUBSET-val">STRONG_MEASURE_SPACE_SUBSET</a> : thm
<a name="line108"></a>    val <a href="#SUBADDITIVE-val">SUBADDITIVE</a> : thm
<a name="line109"></a>    val <a href="#affine_borel_measurable-val">affine_borel_measurable</a> : thm
<a name="line110"></a>    val <a href="#borel_measurable_SIGMA_borel_measurable-val">borel_measurable_SIGMA_borel_measurable</a> : thm
<a name="line111"></a>    val <a href="#borel_measurable_eq_borel_measurable-val">borel_measurable_eq_borel_measurable</a> : thm
<a name="line112"></a>    val <a href="#borel_measurable_ge_iff-val">borel_measurable_ge_iff</a> : thm
<a name="line113"></a>    val <a href="#borel_measurable_gr_iff-val">borel_measurable_gr_iff</a> : thm
<a name="line114"></a>    val <a href="#borel_measurable_le_iff-val">borel_measurable_le_iff</a> : thm
<a name="line115"></a>    val <a href="#borel_measurable_leq_borel_measurable-val">borel_measurable_leq_borel_measurable</a> : thm
<a name="line116"></a>    val <a href="#borel_measurable_less_borel_measurable-val">borel_measurable_less_borel_measurable</a> : thm
<a name="line117"></a>    val <a href="#borel_measurable_less_iff-val">borel_measurable_less_iff</a> : thm
<a name="line118"></a>    val <a href="#borel_measurable_neq_borel_measurable-val">borel_measurable_neq_borel_measurable</a> : thm
<a name="line119"></a>    val <a href="#borel_measurable_plus_borel_measurable-val">borel_measurable_plus_borel_measurable</a> : thm
<a name="line120"></a>    val <a href="#borel_measurable_square-val">borel_measurable_square</a> : thm
<a name="line121"></a>    val <a href="#borel_measurable_sub_borel_measurable-val">borel_measurable_sub_borel_measurable</a> : thm
<a name="line122"></a>    val <a href="#borel_measurable_times_borel_measurable-val">borel_measurable_times_borel_measurable</a> : thm
<a name="line123"></a>    val <a href="#finite_additivity_sufficient_for_finite_spaces-val">finite_additivity_sufficient_for_finite_spaces</a> : thm
<a name="line124"></a>    val <a href="#finite_additivity_sufficient_for_finite_spaces2-val">finite_additivity_sufficient_for_finite_spaces2</a> : thm
<a name="line125"></a>    val <a href="#mono_convergent_borel_measurable-val">mono_convergent_borel_measurable</a> : thm
<a name="line126"></a>  
<a name="line127"></a>  val real_measure_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line128"></a>(*
   [real_borel] Parent theory of "real_measure"
   
   [<a name="additive_def-val"><b>additive_def</b></a>]  Definition
      
      ⊢ ∀m. additive m ⇔
            ∀s t.
              s ∈ measurable_sets m ∧ t ∈ measurable_sets m ∧ DISJOINT s t ⇒
              measure m (s ∪ t) = measure m s + measure m t
   
   [<a name="closed_cdi_def-val"><b>closed_cdi_def</b></a>]  Definition
      
      ⊢ ∀p. closed_cdi p ⇔
            subset_class (space p) (subsets p) ∧
            (∀s. s ∈ subsets p ⇒ space p DIFF s ∈ subsets p) ∧
            (∀f. f ∈ (𝕌(:num) → subsets p) ∧ f 0 = ∅ ∧
                 (∀n. f n ⊆ f (SUC n)) ⇒
                 BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets p) ∧
            ∀f. f ∈ (𝕌(:num) → subsets p) ∧
                (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ⇒
                BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets p
   
   [<a name="countably_additive_def-val"><b>countably_additive_def</b></a>]  Definition
      
      ⊢ ∀m. countably_additive m ⇔
            ∀f. f ∈ (𝕌(:num) → measurable_sets m) ∧
                (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ∧
                BIGUNION (IMAGE f 𝕌(:num)) ∈ measurable_sets m ⇒
                measure m ∘ f sums measure m (BIGUNION (IMAGE f 𝕌(:num)))
   
   [<a name="countably_subadditive_def-val"><b>countably_subadditive_def</b></a>]  Definition
      
      ⊢ ∀m. countably_subadditive m ⇔
            ∀f. f ∈ (𝕌(:num) → measurable_sets m) ∧
                BIGUNION (IMAGE f 𝕌(:num)) ∈ measurable_sets m ∧
                summable (measure m ∘ f) ⇒
                measure m (BIGUNION (IMAGE f 𝕌(:num))) ≤
                suminf (measure m ∘ f)
   
   [<a name="increasing_def-val"><b>increasing_def</b></a>]  Definition
      
      ⊢ ∀m. increasing m ⇔
            ∀s t.
              s ∈ measurable_sets m ∧ t ∈ measurable_sets m ∧ s ⊆ t ⇒
              measure m s ≤ measure m t
   
   [<a name="inf_measure_def-val"><b>inf_measure_def</b></a>]  Definition
      
      ⊢ ∀m s.
          inf_measure m s =
          inf
            {r |
             (∃f. f ∈ (𝕌(:num) → measurable_sets m) ∧
                  (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ∧
                  s ⊆ BIGUNION (IMAGE f 𝕌(:num)) ∧ measure m ∘ f sums r)}
   
   [<a name="lambda_system_def-val"><b>lambda_system_def</b></a>]  Definition
      
      ⊢ ∀gen lam.
          lambda_system gen lam =
          {l |
           l ∈ subsets gen ∧
           ∀s. s ∈ subsets gen ⇒
               lam (l ∩ s) + lam ((space gen DIFF l) ∩ s) = lam s}
   
   [<a name="m_space_def-val"><b>m_space_def</b></a>]  Definition
      
      ⊢ ∀sp sts mu. m_space (sp,sts,mu) = sp
   
   [<a name="measurable_sets_def-val"><b>measurable_sets_def</b></a>]  Definition
      
      ⊢ ∀sp sts mu. measurable_sets (sp,sts,mu) = sts
   
   [<a name="measure_def-val"><b>measure_def</b></a>]  Definition
      
      ⊢ ∀sp sts mu. measure (sp,sts,mu) = mu
   
   [<a name="measure_preserving_def-val"><b>measure_preserving_def</b></a>]  Definition
      
      ⊢ ∀m1 m2.
          measure_preserving m1 m2 =
          {f |
           f ∈
           measurable (m_space m1,measurable_sets m1)
             (m_space m2,measurable_sets m2) ∧ measure_space m1 ∧
           measure_space m2 ∧
           ∀s. s ∈ measurable_sets m2 ⇒
               measure m1 (PREIMAGE f s ∩ m_space m1) = measure m2 s}
   
   [<a name="measure_space_def-val"><b>measure_space_def</b></a>]  Definition
      
      ⊢ ∀m. measure_space m ⇔
            sigma_algebra (m_space m,measurable_sets m) ∧ positive m ∧
            countably_additive m
   
   [<a name="mono_convergent_def-val"><b>mono_convergent_def</b></a>]  Definition
      
      ⊢ ∀u f s.
          mono_convergent u f s ⇔
          (∀x m n. m ≤ n ∧ x ∈ s ⇒ u m x ≤ u n x) ∧
          ∀x. x ∈ s ⇒ (λi. u i x) ⟶ f x
   
   [<a name="outer_measure_space_def-val"><b>outer_measure_space_def</b></a>]  Definition
      
      ⊢ ∀m. outer_measure_space m ⇔
            positive m ∧ increasing m ∧ countably_subadditive m
   
   [<a name="positive_def-val"><b>positive_def</b></a>]  Definition
      
      ⊢ ∀m. positive m ⇔
            measure m ∅ = 0 ∧ ∀s. s ∈ measurable_sets m ⇒ 0 ≤ measure m s
   
   [<a name="smallest_closed_cdi_def-val"><b>smallest_closed_cdi_def</b></a>]  Definition
      
      ⊢ ∀a. smallest_closed_cdi a =
            (space a,BIGINTER {b | subsets a ⊆ b ∧ closed_cdi (space a,b)})
   
   [<a name="subadditive_def-val"><b>subadditive_def</b></a>]  Definition
      
      ⊢ ∀m. subadditive m ⇔
            ∀s t.
              s ∈ measurable_sets m ∧ t ∈ measurable_sets m ⇒
              measure m (s ∪ t) ≤ measure m s + measure m t
   
   [<a name="ADDITIVE-val"><b>ADDITIVE</b></a>]  Theorem
      
      ⊢ ∀m s t u.
          additive m ∧ s ∈ measurable_sets m ∧ t ∈ measurable_sets m ∧
          DISJOINT s t ∧ u = s ∪ t ⇒
          measure m u = measure m s + measure m t
   
   [<a name="ADDITIVE_INCREASING-val"><b>ADDITIVE_INCREASING</b></a>]  Theorem
      
      ⊢ ∀m. algebra (m_space m,measurable_sets m) ∧ positive m ∧ additive m ⇒
            increasing m
   
   [<a name="ADDITIVE_SUM-val"><b>ADDITIVE_SUM</b></a>]  Theorem
      
      ⊢ ∀m f n.
          algebra (m_space m,measurable_sets m) ∧ positive m ∧ additive m ∧
          f ∈ (𝕌(:num) → measurable_sets m) ∧
          (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ⇒
          sum (0,n) (measure m ∘ f) =
          measure m (BIGUNION (IMAGE f (count n)))
   
   [<a name="ALGEBRA_SUBSET_LAMBDA_SYSTEM-val"><b>ALGEBRA_SUBSET_LAMBDA_SYSTEM</b></a>]  Theorem
      
      ⊢ ∀m. algebra (m_space m,measurable_sets m) ∧ positive m ∧
            increasing m ∧ additive m ⇒
            measurable_sets m ⊆
            lambda_system (m_space m,POW (m_space m)) (inf_measure m)
   
   [<a name="CARATHEODORY-val"><b>CARATHEODORY</b></a>]  Theorem
      
      ⊢ ∀m0.
          algebra (m_space m0,measurable_sets m0) ∧ positive m0 ∧
          countably_additive m0 ⇒
          ∃m. (∀s. s ∈ measurable_sets m0 ⇒ measure m s = measure m0 s) ∧
              (m_space m,measurable_sets m) =
              sigma (m_space m0) (measurable_sets m0) ∧ measure_space m
   
   [<a name="CARATHEODORY_LEMMA-val"><b>CARATHEODORY_LEMMA</b></a>]  Theorem
      
      ⊢ ∀gsig lam.
          sigma_algebra gsig ∧
          outer_measure_space (space gsig,subsets gsig,lam) ⇒
          measure_space (space gsig,lambda_system gsig lam,lam)
   
   [<a name="CLOSED_CDI_COMPL-val"><b>CLOSED_CDI_COMPL</b></a>]  Theorem
      
      ⊢ ∀p s. closed_cdi p ∧ s ∈ subsets p ⇒ space p DIFF s ∈ subsets p
   
   [<a name="CLOSED_CDI_DISJOINT-val"><b>CLOSED_CDI_DISJOINT</b></a>]  Theorem
      
      ⊢ ∀p f.
          closed_cdi p ∧ f ∈ (𝕌(:num) → subsets p) ∧
          (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ⇒
          BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets p
   
   [<a name="CLOSED_CDI_DUNION-val"><b>CLOSED_CDI_DUNION</b></a>]  Theorem
      
      ⊢ ∀p s t.
          ∅ ∈ subsets p ∧ closed_cdi p ∧ s ∈ subsets p ∧ t ∈ subsets p ∧
          DISJOINT s t ⇒
          s ∪ t ∈ subsets p
   
   [<a name="CLOSED_CDI_INCREASING-val"><b>CLOSED_CDI_INCREASING</b></a>]  Theorem
      
      ⊢ ∀p f.
          closed_cdi p ∧ f ∈ (𝕌(:num) → subsets p) ∧ f 0 = ∅ ∧
          (∀n. f n ⊆ f (SUC n)) ⇒
          BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets p
   
   [<a name="COUNTABLY_ADDITIVE-val"><b>COUNTABLY_ADDITIVE</b></a>]  Theorem
      
      ⊢ ∀m s f.
          countably_additive m ∧ f ∈ (𝕌(:num) → measurable_sets m) ∧
          (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ∧
          s = BIGUNION (IMAGE f 𝕌(:num)) ∧ s ∈ measurable_sets m ⇒
          measure m ∘ f sums measure m s
   
   [<a name="COUNTABLY_ADDITIVE_ADDITIVE-val"><b>COUNTABLY_ADDITIVE_ADDITIVE</b></a>]  Theorem
      
      ⊢ ∀m. algebra (m_space m,measurable_sets m) ∧ positive m ∧
            countably_additive m ⇒
            additive m
   
   [<a name="COUNTABLY_SUBADDITIVE-val"><b>COUNTABLY_SUBADDITIVE</b></a>]  Theorem
      
      ⊢ ∀m f s.
          countably_subadditive m ∧ f ∈ (𝕌(:num) → measurable_sets m) ∧
          summable (measure m ∘ f) ∧ s = BIGUNION (IMAGE f 𝕌(:num)) ∧
          s ∈ measurable_sets m ⇒
          measure m s ≤ suminf (measure m ∘ f)
   
   [<a name="COUNTABLY_SUBADDITIVE_SUBADDITIVE-val"><b>COUNTABLY_SUBADDITIVE_SUBADDITIVE</b></a>]  Theorem
      
      ⊢ ∀m. algebra (m_space m,measurable_sets m) ∧ positive m ∧
            countably_subadditive m ⇒
            subadditive m
   
   [<a name="INCREASING-val"><b>INCREASING</b></a>]  Theorem
      
      ⊢ ∀m s t.
          increasing m ∧ s ⊆ t ∧ s ∈ measurable_sets m ∧
          t ∈ measurable_sets m ⇒
          measure m s ≤ measure m t
   
   [<a name="INCREASING_ADDITIVE_SUMMABLE-val"><b>INCREASING_ADDITIVE_SUMMABLE</b></a>]  Theorem
      
      ⊢ ∀m f.
          algebra (m_space m,measurable_sets m) ∧ positive m ∧
          increasing m ∧ additive m ∧ f ∈ (𝕌(:num) → measurable_sets m) ∧
          (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ⇒
          summable (measure m ∘ f)
   
   [<a name="INF_MEASURE_AGREES-val"><b>INF_MEASURE_AGREES</b></a>]  Theorem
      
      ⊢ ∀m s.
          algebra (m_space m,measurable_sets m) ∧ positive m ∧
          countably_additive m ∧ s ∈ measurable_sets m ⇒
          inf_measure m s = measure m s
   
   [<a name="INF_MEASURE_CLOSE-val"><b>INF_MEASURE_CLOSE</b></a>]  Theorem
      
      ⊢ ∀m s e.
          algebra (m_space m,measurable_sets m) ∧ positive m ∧ 0 &lt; e ∧
          s ⊆ m_space m ⇒
          ∃f l.
            f ∈ (𝕌(:num) → measurable_sets m) ∧
            s ⊆ BIGUNION (IMAGE f 𝕌(:num)) ∧
            (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ∧ measure m ∘ f sums l ∧
            l ≤ inf_measure m s + e
   
   [<a name="INF_MEASURE_COUNTABLY_SUBADDITIVE-val"><b>INF_MEASURE_COUNTABLY_SUBADDITIVE</b></a>]  Theorem
      
      ⊢ ∀m. algebra (m_space m,measurable_sets m) ∧ positive m ∧
            increasing m ⇒
            countably_subadditive (m_space m,POW (m_space m),inf_measure m)
   
   [<a name="INF_MEASURE_EMPTY-val"><b>INF_MEASURE_EMPTY</b></a>]  Theorem
      
      ⊢ ∀m. algebra (m_space m,measurable_sets m) ∧ positive m ⇒
            inf_measure m ∅ = 0
   
   [<a name="INF_MEASURE_INCREASING-val"><b>INF_MEASURE_INCREASING</b></a>]  Theorem
      
      ⊢ ∀m. algebra (m_space m,measurable_sets m) ∧ positive m ⇒
            increasing (m_space m,POW (m_space m),inf_measure m)
   
   [<a name="INF_MEASURE_LE-val"><b>INF_MEASURE_LE</b></a>]  Theorem
      
      ⊢ ∀m s x.
          algebra (m_space m,measurable_sets m) ∧ positive m ∧
          increasing m ∧
          x ∈
          {r |
           ∃f. f ∈ (𝕌(:num) → measurable_sets m) ∧
               s ⊆ BIGUNION (IMAGE f 𝕌(:num)) ∧ measure m ∘ f sums r} ⇒
          inf_measure m s ≤ x
   
   [<a name="INF_MEASURE_NONEMPTY-val"><b>INF_MEASURE_NONEMPTY</b></a>]  Theorem
      
      ⊢ ∀m g s.
          algebra (m_space m,measurable_sets m) ∧ positive m ∧
          s ∈ measurable_sets m ∧ g ⊆ s ⇒
          measure m s ∈
          {r |
           ∃f. f ∈ (𝕌(:num) → measurable_sets m) ∧
               (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ∧
               g ⊆ BIGUNION (IMAGE f 𝕌(:num)) ∧ measure m ∘ f sums r}
   
   [<a name="INF_MEASURE_OUTER-val"><b>INF_MEASURE_OUTER</b></a>]  Theorem
      
      ⊢ ∀m. algebra (m_space m,measurable_sets m) ∧ positive m ∧
            increasing m ⇒
            outer_measure_space (m_space m,POW (m_space m),inf_measure m)
   
   [<a name="INF_MEASURE_POS-val"><b>INF_MEASURE_POS</b></a>]  Theorem
      
      ⊢ ∀m g.
          algebra (m_space m,measurable_sets m) ∧ positive m ∧
          g ⊆ m_space m ⇒
          0 ≤ inf_measure m g
   
   [<a name="INF_MEASURE_POS0-val"><b>INF_MEASURE_POS0</b></a>]  Theorem
      
      ⊢ ∀m g x.
          algebra (m_space m,measurable_sets m) ∧ positive m ∧
          x ∈
          {r |
           ∃f. f ∈ (𝕌(:num) → measurable_sets m) ∧
               (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ∧
               g ⊆ BIGUNION (IMAGE f 𝕌(:num)) ∧ measure m ∘ f sums r} ⇒
          0 ≤ x
   
   [<a name="INF_MEASURE_POSITIVE-val"><b>INF_MEASURE_POSITIVE</b></a>]  Theorem
      
      ⊢ ∀m. algebra (m_space m,measurable_sets m) ∧ positive m ⇒
            positive (m_space m,POW (m_space m),inf_measure m)
   
   [<a name="IN_MEASURE_PRESERVING-val"><b>IN_MEASURE_PRESERVING</b></a>]  Theorem
      
      ⊢ ∀m1 m2 f.
          f ∈ measure_preserving m1 m2 ⇔
          f ∈
          measurable (m_space m1,measurable_sets m1)
            (m_space m2,measurable_sets m2) ∧ measure_space m1 ∧
          measure_space m2 ∧
          ∀s. s ∈ measurable_sets m2 ⇒
              measure m1 (PREIMAGE f s ∩ m_space m1) = measure m2 s
   
   [<a name="LAMBDA_SYSTEM_ADDITIVE-val"><b>LAMBDA_SYSTEM_ADDITIVE</b></a>]  Theorem
      
      ⊢ ∀g0 lam l1 l2.
          algebra g0 ∧ positive (space g0,subsets g0,lam) ⇒
          additive (space g0,lambda_system g0 lam,lam)
   
   [<a name="LAMBDA_SYSTEM_ALGEBRA-val"><b>LAMBDA_SYSTEM_ALGEBRA</b></a>]  Theorem
      
      ⊢ ∀g0 lam.
          algebra g0 ∧ positive (space g0,subsets g0,lam) ⇒
          algebra (space g0,lambda_system g0 lam)
   
   [<a name="LAMBDA_SYSTEM_CARATHEODORY-val"><b>LAMBDA_SYSTEM_CARATHEODORY</b></a>]  Theorem
      
      ⊢ ∀gsig lam.
          sigma_algebra gsig ∧
          outer_measure_space (space gsig,subsets gsig,lam) ⇒
          ∀f. f ∈ (𝕌(:num) → lambda_system gsig lam) ∧
              (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ⇒
              BIGUNION (IMAGE f 𝕌(:num)) ∈ lambda_system gsig lam ∧
              lam ∘ f sums lam (BIGUNION (IMAGE f 𝕌(:num)))
   
   [<a name="LAMBDA_SYSTEM_COMPL-val"><b>LAMBDA_SYSTEM_COMPL</b></a>]  Theorem
      
      ⊢ ∀g0 lam l.
          algebra g0 ∧ positive (space g0,subsets g0,lam) ∧
          l ∈ lambda_system g0 lam ⇒
          space g0 DIFF l ∈ lambda_system g0 lam
   
   [<a name="LAMBDA_SYSTEM_EMPTY-val"><b>LAMBDA_SYSTEM_EMPTY</b></a>]  Theorem
      
      ⊢ ∀g0 lam.
          algebra g0 ∧ positive (space g0,subsets g0,lam) ⇒
          ∅ ∈ lambda_system g0 lam
   
   [<a name="LAMBDA_SYSTEM_INCREASING-val"><b>LAMBDA_SYSTEM_INCREASING</b></a>]  Theorem
      
      ⊢ ∀g0 lam.
          increasing (space g0,subsets g0,lam) ⇒
          increasing (space g0,lambda_system g0 lam,lam)
   
   [<a name="LAMBDA_SYSTEM_INTER-val"><b>LAMBDA_SYSTEM_INTER</b></a>]  Theorem
      
      ⊢ ∀g0 lam l1 l2.
          algebra g0 ∧ positive (space g0,subsets g0,lam) ∧
          l1 ∈ lambda_system g0 lam ∧ l2 ∈ lambda_system g0 lam ⇒
          l1 ∩ l2 ∈ lambda_system g0 lam
   
   [<a name="LAMBDA_SYSTEM_POSITIVE-val"><b>LAMBDA_SYSTEM_POSITIVE</b></a>]  Theorem
      
      ⊢ ∀g0 lam.
          positive (space g0,subsets g0,lam) ⇒
          positive (space g0,lambda_system g0 lam,lam)
   
   [<a name="LAMBDA_SYSTEM_STRONG_ADDITIVE-val"><b>LAMBDA_SYSTEM_STRONG_ADDITIVE</b></a>]  Theorem
      
      ⊢ ∀g0 lam g l1 l2.
          algebra g0 ∧ positive (space g0,subsets g0,lam) ∧
          g ∈ subsets g0 ∧ DISJOINT l1 l2 ∧ l1 ∈ lambda_system g0 lam ∧
          l2 ∈ lambda_system g0 lam ⇒
          lam ((l1 ∪ l2) ∩ g) = lam (l1 ∩ g) + lam (l2 ∩ g)
   
   [<a name="LAMBDA_SYSTEM_STRONG_SUM-val"><b>LAMBDA_SYSTEM_STRONG_SUM</b></a>]  Theorem
      
      ⊢ ∀g0 lam g f n.
          algebra g0 ∧ positive (space g0,subsets g0,lam) ∧
          g ∈ subsets g0 ∧ f ∈ (𝕌(:num) → lambda_system g0 lam) ∧
          (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ⇒
          sum (0,n) (lam ∘ (λs. s ∩ g) ∘ f) =
          lam (BIGUNION (IMAGE f (count n)) ∩ g)
   
   [<a name="MEASURABLE_POW_TO_POW-val"><b>MEASURABLE_POW_TO_POW</b></a>]  Theorem
      
      ⊢ ∀m f.
          measure_space m ∧ measurable_sets m = POW (m_space m) ⇒
          f ∈ measurable (m_space m,measurable_sets m) (𝕌(:β),POW 𝕌(:β))
   
   [<a name="MEASURABLE_POW_TO_POW_IMAGE-val"><b>MEASURABLE_POW_TO_POW_IMAGE</b></a>]  Theorem
      
      ⊢ ∀m f.
          measure_space m ∧ measurable_sets m = POW (m_space m) ⇒
          f ∈
          measurable (m_space m,measurable_sets m)
            (IMAGE f (m_space m),POW (IMAGE f (m_space m)))
   
   [<a name="MEASURABLE_RANGE_REDUCE-val"><b>MEASURABLE_RANGE_REDUCE</b></a>]  Theorem
      
      ⊢ ∀m f s.
          measure_space m ∧
          f ∈ measurable (m_space m,measurable_sets m) (s,POW s) ∧ s ≠ ∅ ⇒
          f ∈
          measurable (m_space m,measurable_sets m)
            (s ∩ IMAGE f (m_space m),POW (s ∩ IMAGE f (m_space m)))
   
   [<a name="MEASURABLE_SETS_SUBSET_SPACE-val"><b>MEASURABLE_SETS_SUBSET_SPACE</b></a>]  Theorem
      
      ⊢ ∀m s. measure_space m ∧ s ∈ measurable_sets m ⇒ s ⊆ m_space m
   
   [<a name="MEASURE_ADDITIVE-val"><b>MEASURE_ADDITIVE</b></a>]  Theorem
      
      ⊢ ∀m s t u.
          measure_space m ∧ s ∈ measurable_sets m ∧ t ∈ measurable_sets m ∧
          DISJOINT s t ∧ u = s ∪ t ⇒
          measure m u = measure m s + measure m t
   
   [<a name="MEASURE_COMPL-val"><b>MEASURE_COMPL</b></a>]  Theorem
      
      ⊢ ∀m s.
          measure_space m ∧ s ∈ measurable_sets m ⇒
          measure m (m_space m DIFF s) =
          measure m (m_space m) − measure m s
   
   [<a name="MEASURE_COMPL_SUBSET-val"><b>MEASURE_COMPL_SUBSET</b></a>]  Theorem
      
      ⊢ ∀m s t.
          measure_space m ∧ s ∈ measurable_sets m ∧ t ∈ measurable_sets m ∧
          t ⊆ s ⇒
          measure m (s DIFF t) = measure m s − measure m t
   
   [<a name="MEASURE_COUNTABLE_INCREASING-val"><b>MEASURE_COUNTABLE_INCREASING</b></a>]  Theorem
      
      ⊢ ∀m s f.
          measure_space m ∧ f ∈ (𝕌(:num) → measurable_sets m) ∧ f 0 = ∅ ∧
          (∀n. f n ⊆ f (SUC n)) ∧ s = BIGUNION (IMAGE f 𝕌(:num)) ⇒
          measure m ∘ f ⟶ measure m s
   
   [<a name="MEASURE_COUNTABLY_ADDITIVE-val"><b>MEASURE_COUNTABLY_ADDITIVE</b></a>]  Theorem
      
      ⊢ ∀m s f.
          measure_space m ∧ f ∈ (𝕌(:num) → measurable_sets m) ∧
          (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ∧
          s = BIGUNION (IMAGE f 𝕌(:num)) ⇒
          measure m ∘ f sums measure m s
   
   [<a name="MEASURE_DOWN-val"><b>MEASURE_DOWN</b></a>]  Theorem
      
      ⊢ ∀m0 m1.
          sigma_algebra (m_space m0,measurable_sets m0) ∧
          measurable_sets m0 ⊆ measurable_sets m1 ∧
          measure m0 = measure m1 ∧ measure_space m1 ⇒
          measure_space m0
   
   [<a name="MEASURE_EMPTY-val"><b>MEASURE_EMPTY</b></a>]  Theorem
      
      ⊢ ∀m. measure_space m ⇒ measure m ∅ = 0
   
   [<a name="MEASURE_PRESERVING_LIFT-val"><b>MEASURE_PRESERVING_LIFT</b></a>]  Theorem
      
      ⊢ ∀m1 m2 a f.
          measure_space m1 ∧ measure_space m2 ∧
          measurable_sets m2 = subsets (sigma (m_space m2) a) ∧
          f ∈ measure_preserving m1 (m_space m2,a,measure m2) ⇒
          f ∈ measure_preserving m1 m2
   
   [<a name="MEASURE_PRESERVING_SUBSET-val"><b>MEASURE_PRESERVING_SUBSET</b></a>]  Theorem
      
      ⊢ ∀m1 m2 a.
          measure_space m1 ∧ measure_space m2 ∧
          measurable_sets m2 = subsets (sigma (m_space m2) a) ⇒
          measure_preserving m1 (m_space m2,a,measure m2) ⊆
          measure_preserving m1 m2
   
   [<a name="MEASURE_PRESERVING_UP_LIFT-val"><b>MEASURE_PRESERVING_UP_LIFT</b></a>]  Theorem
      
      ⊢ ∀m1 m2 f a.
          measure_space m1 ∧
          f ∈ measure_preserving (m_space m1,a,measure m1) m2 ∧
          sigma_algebra (m_space m1,measurable_sets m1) ∧
          a ⊆ measurable_sets m1 ⇒
          f ∈ measure_preserving m1 m2
   
   [<a name="MEASURE_PRESERVING_UP_SIGMA-val"><b>MEASURE_PRESERVING_UP_SIGMA</b></a>]  Theorem
      
      ⊢ ∀m1 m2 a.
          measure_space m1 ∧
          measurable_sets m1 = subsets (sigma (m_space m1) a) ⇒
          measure_preserving (m_space m1,a,measure m1) m2 ⊆
          measure_preserving m1 m2
   
   [<a name="MEASURE_PRESERVING_UP_SUBSET-val"><b>MEASURE_PRESERVING_UP_SUBSET</b></a>]  Theorem
      
      ⊢ ∀m1 m2 a.
          measure_space m1 ∧ a ⊆ measurable_sets m1 ∧
          sigma_algebra (m_space m1,measurable_sets m1) ⇒
          measure_preserving (m_space m1,a,measure m1) m2 ⊆
          measure_preserving m1 m2
   
   [<a name="MEASURE_REAL_SUM_IMAGE-val"><b>MEASURE_REAL_SUM_IMAGE</b></a>]  Theorem
      
      ⊢ ∀m s.
          measure_space m ∧ s ∈ measurable_sets m ∧
          (∀x. x ∈ s ⇒ {x} ∈ measurable_sets m) ∧ FINITE s ⇒
          measure m s = SIGMA (λx. measure m {x}) s
   
   [<a name="MEASURE_SPACE_ADDITIVE-val"><b>MEASURE_SPACE_ADDITIVE</b></a>]  Theorem
      
      ⊢ ∀m. measure_space m ⇒ additive m
   
   [<a name="MEASURE_SPACE_BIGINTER-val"><b>MEASURE_SPACE_BIGINTER</b></a>]  Theorem
      
      ⊢ ∀m s.
          measure_space m ∧ (∀n. s n ∈ measurable_sets m) ⇒
          BIGINTER (IMAGE s 𝕌(:num)) ∈ measurable_sets m
   
   [<a name="MEASURE_SPACE_BIGUNION-val"><b>MEASURE_SPACE_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀m s.
          measure_space m ∧ (∀n. s n ∈ measurable_sets m) ⇒
          BIGUNION (IMAGE s 𝕌(:num)) ∈ measurable_sets m
   
   [<a name="MEASURE_SPACE_CMUL-val"><b>MEASURE_SPACE_CMUL</b></a>]  Theorem
      
      ⊢ ∀m c.
          measure_space m ∧ 0 ≤ c ⇒
          measure_space (m_space m,measurable_sets m,(λa. c * measure m a))
   
   [<a name="MEASURE_SPACE_DIFF-val"><b>MEASURE_SPACE_DIFF</b></a>]  Theorem
      
      ⊢ ∀m s t.
          measure_space m ∧ s ∈ measurable_sets m ∧ t ∈ measurable_sets m ⇒
          s DIFF t ∈ measurable_sets m
   
   [<a name="MEASURE_SPACE_EMPTY_MEASURABLE-val"><b>MEASURE_SPACE_EMPTY_MEASURABLE</b></a>]  Theorem
      
      ⊢ ∀m. measure_space m ⇒ ∅ ∈ measurable_sets m
   
   [<a name="MEASURE_SPACE_INCREASING-val"><b>MEASURE_SPACE_INCREASING</b></a>]  Theorem
      
      ⊢ ∀m. measure_space m ⇒ increasing m
   
   [<a name="MEASURE_SPACE_INTER-val"><b>MEASURE_SPACE_INTER</b></a>]  Theorem
      
      ⊢ ∀m s t.
          measure_space m ∧ s ∈ measurable_sets m ∧ t ∈ measurable_sets m ⇒
          s ∩ t ∈ measurable_sets m
   
   [<a name="MEASURE_SPACE_IN_MSPACE-val"><b>MEASURE_SPACE_IN_MSPACE</b></a>]  Theorem
      
      ⊢ ∀m A.
          measure_space m ∧ A ∈ measurable_sets m ⇒
          ∀x. x ∈ A ⇒ x ∈ m_space m
   
   [<a name="MEASURE_SPACE_MSPACE_MEASURABLE-val"><b>MEASURE_SPACE_MSPACE_MEASURABLE</b></a>]  Theorem
      
      ⊢ ∀m. measure_space m ⇒ m_space m ∈ measurable_sets m
   
   [<a name="MEASURE_SPACE_POSITIVE-val"><b>MEASURE_SPACE_POSITIVE</b></a>]  Theorem
      
      ⊢ ∀m. measure_space m ⇒ positive m
   
   [<a name="MEASURE_SPACE_REDUCE-val"><b>MEASURE_SPACE_REDUCE</b></a>]  Theorem
      
      ⊢ ∀m. (m_space m,measurable_sets m,measure m) = m
   
   [<a name="MEASURE_SPACE_RESTRICTED-val"><b>MEASURE_SPACE_RESTRICTED</b></a>]  Theorem
      
      ⊢ ∀m s.
          measure_space m ∧ s ∈ measurable_sets m ⇒
          measure_space (s,IMAGE (λt. s ∩ t) (measurable_sets m),measure m)
   
   [<a name="MEASURE_SPACE_SUBSET-val"><b>MEASURE_SPACE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s s' m.
          s' ⊆ s ∧ measure_space (s,POW s,m) ⇒ measure_space (s',POW s',m)
   
   [<a name="MEASURE_SPACE_SUBSET_MSPACE-val"><b>MEASURE_SPACE_SUBSET_MSPACE</b></a>]  Theorem
      
      ⊢ ∀A m. measure_space m ∧ A ∈ measurable_sets m ⇒ A ⊆ m_space m
   
   [<a name="MEASURE_SPACE_UNION-val"><b>MEASURE_SPACE_UNION</b></a>]  Theorem
      
      ⊢ ∀m s t.
          measure_space m ∧ s ∈ measurable_sets m ∧ t ∈ measurable_sets m ⇒
          s ∪ t ∈ measurable_sets m
   
   [<a name="MONOTONE_CONVERGENCE-val"><b>MONOTONE_CONVERGENCE</b></a>]  Theorem
      
      ⊢ ∀m s f.
          measure_space m ∧ f ∈ (𝕌(:num) → measurable_sets m) ∧
          (∀n. f n ⊆ f (SUC n)) ∧ s = BIGUNION (IMAGE f 𝕌(:num)) ⇒
          measure m ∘ f ⟶ measure m s
   
   [<a name="MONOTONE_CONVERGENCE2-val"><b>MONOTONE_CONVERGENCE2</b></a>]  Theorem
      
      ⊢ ∀m f.
          measure_space m ∧ f ∈ (𝕌(:num) → measurable_sets m) ∧
          (∀n. f n ⊆ f (SUC n)) ⇒
          measure m ∘ f ⟶ measure m (BIGUNION (IMAGE f 𝕌(:num)))
   
   [<a name="MONOTONE_CONVERGENCE_BIGINTER-val"><b>MONOTONE_CONVERGENCE_BIGINTER</b></a>]  Theorem
      
      ⊢ ∀m s f.
          measure_space m ∧ f ∈ (𝕌(:num) → measurable_sets m) ∧
          (∀n. f (SUC n) ⊆ f n) ∧ s = BIGINTER (IMAGE f 𝕌(:num)) ⇒
          measure m ∘ f ⟶ measure m s
   
   [<a name="MONOTONE_CONVERGENCE_BIGINTER2-val"><b>MONOTONE_CONVERGENCE_BIGINTER2</b></a>]  Theorem
      
      ⊢ ∀m f.
          measure_space m ∧ f ∈ (𝕌(:num) → measurable_sets m) ∧
          (∀n. f (SUC n) ⊆ f n) ⇒
          measure m ∘ f ⟶ measure m (BIGINTER (IMAGE f 𝕌(:num)))
   
   [<a name="OUTER_MEASURE_SPACE_POSITIVE-val"><b>OUTER_MEASURE_SPACE_POSITIVE</b></a>]  Theorem
      
      ⊢ ∀m. outer_measure_space m ⇒ positive m
   
   [<a name="SIGMA_PROPERTY_DISJOINT_LEMMA-val"><b>SIGMA_PROPERTY_DISJOINT_LEMMA</b></a>]  Theorem
      
      ⊢ ∀sp a p.
          algebra (sp,a) ∧ a ⊆ p ∧ closed_cdi (sp,p) ⇒
          subsets (sigma sp a) ⊆ p
   
   [<a name="SIGMA_PROPERTY_DISJOINT_LEMMA1-val"><b>SIGMA_PROPERTY_DISJOINT_LEMMA1</b></a>]  Theorem
      
      ⊢ ∀a. algebra a ⇒
            ∀s t.
              s ∈ subsets a ∧ t ∈ subsets (smallest_closed_cdi a) ⇒
              s ∩ t ∈ subsets (smallest_closed_cdi a)
   
   [<a name="SIGMA_PROPERTY_DISJOINT_LEMMA2-val"><b>SIGMA_PROPERTY_DISJOINT_LEMMA2</b></a>]  Theorem
      
      ⊢ ∀a. algebra a ⇒
            ∀s t.
              s ∈ subsets (smallest_closed_cdi a) ∧
              t ∈ subsets (smallest_closed_cdi a) ⇒
              s ∩ t ∈ subsets (smallest_closed_cdi a)
   
   [<a name="SIGMA_SUBSET_MEASURABLE_SETS-val"><b>SIGMA_SUBSET_MEASURABLE_SETS</b></a>]  Theorem
      
      ⊢ ∀a m.
          measure_space m ∧ a ⊆ measurable_sets m ⇒
          subsets (sigma (m_space m) a) ⊆ measurable_sets m
   
   [<a name="SMALLEST_CLOSED_CDI-val"><b>SMALLEST_CLOSED_CDI</b></a>]  Theorem
      
      ⊢ ∀a. algebra a ⇒
            subsets a ⊆ subsets (smallest_closed_cdi a) ∧
            closed_cdi (smallest_closed_cdi a) ∧
            subset_class (space a) (subsets (smallest_closed_cdi a))
   
   [<a name="SPACE_SMALLEST_CLOSED_CDI-val"><b>SPACE_SMALLEST_CLOSED_CDI</b></a>]  Theorem
      
      ⊢ ∀a. space (smallest_closed_cdi a) = space a
   
   [<a name="STRONG_MEASURE_SPACE_SUBSET-val"><b>STRONG_MEASURE_SPACE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀s s'.
          s' ⊆ m_space s ∧ measure_space s ∧ POW s' ⊆ measurable_sets s ⇒
          measure_space (s',POW s',measure s)
   
   [<a name="SUBADDITIVE-val"><b>SUBADDITIVE</b></a>]  Theorem
      
      ⊢ ∀m s t u.
          subadditive m ∧ s ∈ measurable_sets m ∧ t ∈ measurable_sets m ∧
          u = s ∪ t ⇒
          measure m u ≤ measure m s + measure m t
   
   [<a name="affine_borel_measurable-val"><b>affine_borel_measurable</b></a>]  Theorem
      
      ⊢ ∀m g.
          measure_space m ∧
          g ∈ borel_measurable (m_space m,measurable_sets m) ⇒
          ∀a b.
            (λx. a + g x * b) ∈
            borel_measurable (m_space m,measurable_sets m)
   
   [<a name="borel_measurable_SIGMA_borel_measurable-val"><b>borel_measurable_SIGMA_borel_measurable</b></a>]  Theorem
      
      ⊢ ∀m f s.
          measure_space m ∧ FINITE s ∧
          (∀i. i ∈ s ⇒ f i ∈ borel_measurable (m_space m,measurable_sets m)) ⇒
          (λx. SIGMA (λi. f i x) s) ∈
          borel_measurable (m_space m,measurable_sets m)
   
   [<a name="borel_measurable_eq_borel_measurable-val"><b>borel_measurable_eq_borel_measurable</b></a>]  Theorem
      
      ⊢ ∀m f g.
          measure_space m ∧
          f ∈ borel_measurable (m_space m,measurable_sets m) ∧
          g ∈ borel_measurable (m_space m,measurable_sets m) ⇒
          {w | w ∈ m_space m ∧ f w = g w} ∈ measurable_sets m
   
   [<a name="borel_measurable_ge_iff-val"><b>borel_measurable_ge_iff</b></a>]  Theorem
      
      ⊢ ∀m. measure_space m ⇒
            ∀f. f ∈ borel_measurable (m_space m,measurable_sets m) ⇔
                ∀a. {w | w ∈ m_space m ∧ a ≤ f w} ∈ measurable_sets m
   
   [<a name="borel_measurable_gr_iff-val"><b>borel_measurable_gr_iff</b></a>]  Theorem
      
      ⊢ ∀m. measure_space m ⇒
            ∀f. f ∈ borel_measurable (m_space m,measurable_sets m) ⇔
                ∀a. {w | w ∈ m_space m ∧ a &lt; f w} ∈ measurable_sets m
   
   [<a name="borel_measurable_le_iff-val"><b>borel_measurable_le_iff</b></a>]  Theorem
      
      ⊢ ∀m. measure_space m ⇒
            ∀f. f ∈ borel_measurable (m_space m,measurable_sets m) ⇔
                ∀a. {w | w ∈ m_space m ∧ f w ≤ a} ∈ measurable_sets m
   
   [<a name="borel_measurable_leq_borel_measurable-val"><b>borel_measurable_leq_borel_measurable</b></a>]  Theorem
      
      ⊢ ∀m f g.
          measure_space m ∧
          f ∈ borel_measurable (m_space m,measurable_sets m) ∧
          g ∈ borel_measurable (m_space m,measurable_sets m) ⇒
          {w | w ∈ m_space m ∧ f w ≤ g w} ∈ measurable_sets m
   
   [<a name="borel_measurable_less_borel_measurable-val"><b>borel_measurable_less_borel_measurable</b></a>]  Theorem
      
      ⊢ ∀m f g.
          measure_space m ∧
          f ∈ borel_measurable (m_space m,measurable_sets m) ∧
          g ∈ borel_measurable (m_space m,measurable_sets m) ⇒
          {w | w ∈ m_space m ∧ f w &lt; g w} ∈ measurable_sets m
   
   [<a name="borel_measurable_less_iff-val"><b>borel_measurable_less_iff</b></a>]  Theorem
      
      ⊢ ∀m. measure_space m ⇒
            ∀f. f ∈ borel_measurable (m_space m,measurable_sets m) ⇔
                ∀a. {w | w ∈ m_space m ∧ f w &lt; a} ∈ measurable_sets m
   
   [<a name="borel_measurable_neq_borel_measurable-val"><b>borel_measurable_neq_borel_measurable</b></a>]  Theorem
      
      ⊢ ∀m f g.
          measure_space m ∧
          f ∈ borel_measurable (m_space m,measurable_sets m) ∧
          g ∈ borel_measurable (m_space m,measurable_sets m) ⇒
          {w | w ∈ m_space m ∧ f w ≠ g w} ∈ measurable_sets m
   
   [<a name="borel_measurable_plus_borel_measurable-val"><b>borel_measurable_plus_borel_measurable</b></a>]  Theorem
      
      ⊢ ∀m f g.
          measure_space m ∧
          f ∈ borel_measurable (m_space m,measurable_sets m) ∧
          g ∈ borel_measurable (m_space m,measurable_sets m) ⇒
          (λx. f x + g x) ∈ borel_measurable (m_space m,measurable_sets m)
   
   [<a name="borel_measurable_square-val"><b>borel_measurable_square</b></a>]  Theorem
      
      ⊢ ∀m f g.
          measure_space m ∧
          f ∈ borel_measurable (m_space m,measurable_sets m) ⇒
          (λx. (f x)²) ∈ borel_measurable (m_space m,measurable_sets m)
   
   [<a name="borel_measurable_sub_borel_measurable-val"><b>borel_measurable_sub_borel_measurable</b></a>]  Theorem
      
      ⊢ ∀m f g.
          measure_space m ∧
          f ∈ borel_measurable (m_space m,measurable_sets m) ∧
          g ∈ borel_measurable (m_space m,measurable_sets m) ⇒
          (λx. f x − g x) ∈ borel_measurable (m_space m,measurable_sets m)
   
   [<a name="borel_measurable_times_borel_measurable-val"><b>borel_measurable_times_borel_measurable</b></a>]  Theorem
      
      ⊢ ∀m f g.
          measure_space m ∧
          f ∈ borel_measurable (m_space m,measurable_sets m) ∧
          g ∈ borel_measurable (m_space m,measurable_sets m) ⇒
          (λx. f x * g x) ∈ borel_measurable (m_space m,measurable_sets m)
   
   [<a name="finite_additivity_sufficient_for_finite_spaces-val"><b>finite_additivity_sufficient_for_finite_spaces</b></a>]  Theorem
      
      ⊢ ∀s m.
          sigma_algebra s ∧ FINITE (space s) ∧
          positive (space s,subsets s,m) ∧ additive (space s,subsets s,m) ⇒
          measure_space (space s,subsets s,m)
   
   [<a name="finite_additivity_sufficient_for_finite_spaces2-val"><b>finite_additivity_sufficient_for_finite_spaces2</b></a>]  Theorem
      
      ⊢ ∀m. sigma_algebra (m_space m,measurable_sets m) ∧
            FINITE (m_space m) ∧ positive m ∧ additive m ⇒
            measure_space m
   
   [<a name="mono_convergent_borel_measurable-val"><b>mono_convergent_borel_measurable</b></a>]  Theorem
      
      ⊢ ∀u m f.
          measure_space m ∧
          (∀n. u n ∈ borel_measurable (m_space m,measurable_sets m)) ∧
          mono_convergent u f (m_space m) ⇒
          f ∈ borel_measurable (m_space m,measurable_sets m)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/probability/real_measureScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-14</a></em></p></body></html>
