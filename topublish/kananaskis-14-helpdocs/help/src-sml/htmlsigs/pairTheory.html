<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure pairTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure pairTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/coretypes/pairScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature pairTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#ABS_REP_prod-val">ABS_REP_prod</a> : thm
<a name="line7"></a>    val <a href="#COMMA_DEF-val">COMMA_DEF</a> : thm
<a name="line8"></a>    val <a href="#CURRY_DEF-val">CURRY_DEF</a> : thm
<a name="line9"></a>    val <a href="#LEX_DEF-val">LEX_DEF</a> : thm
<a name="line10"></a>    val <a href="#PAIR-val">PAIR</a> : thm
<a name="line11"></a>    val <a href="#PAIR_MAP-val">PAIR_MAP</a> : thm
<a name="line12"></a>    val <a href="#PROD_ALL_def-val">PROD_ALL_def</a> : thm
<a name="line13"></a>    val <a href="#RPROD_DEF-val">RPROD_DEF</a> : thm
<a name="line14"></a>    val <a href="#SWAP_def-val">SWAP_def</a> : thm
<a name="line15"></a>    val <a href="#UNCURRY-val">UNCURRY</a> : thm
<a name="line16"></a>    val <a href="#pair_CASE_def-val">pair_CASE_def</a> : thm
<a name="line17"></a>    val <a href="#prod_TY_DEF-val">prod_TY_DEF</a> : thm
<a name="line18"></a>  
<a name="line19"></a>  (*  Theorems  *)
<a name="line20"></a>    val <a href="#ABS_PAIR_THM-val">ABS_PAIR_THM</a> : thm
<a name="line21"></a>    val <a href="#CLOSED_PAIR_EQ-val">CLOSED_PAIR_EQ</a> : thm
<a name="line22"></a>    val <a href="#CURRY_ONE_ONE_THM-val">CURRY_ONE_ONE_THM</a> : thm
<a name="line23"></a>    val <a href="#CURRY_UNCURRY_THM-val">CURRY_UNCURRY_THM</a> : thm
<a name="line24"></a>    val <a href="#C_UNCURRY_L-val">C_UNCURRY_L</a> : thm
<a name="line25"></a>    val <a href="#ELIM_PEXISTS-val">ELIM_PEXISTS</a> : thm
<a name="line26"></a>    val <a href="#ELIM_PEXISTS_EVAL-val">ELIM_PEXISTS_EVAL</a> : thm
<a name="line27"></a>    val <a href="#ELIM_PFORALL-val">ELIM_PFORALL</a> : thm
<a name="line28"></a>    val <a href="#ELIM_PFORALL_EVAL-val">ELIM_PFORALL_EVAL</a> : thm
<a name="line29"></a>    val <a href="#ELIM_UNCURRY-val">ELIM_UNCURRY</a> : thm
<a name="line30"></a>    val <a href="#EXISTS_PROD-val">EXISTS_PROD</a> : thm
<a name="line31"></a>    val <a href="#FORALL_PROD-val">FORALL_PROD</a> : thm
<a name="line32"></a>    val <a href="#FORALL_UNCURRY-val">FORALL_UNCURRY</a> : thm
<a name="line33"></a>    val <a href="#FST-val">FST</a> : thm
<a name="line34"></a>    val <a href="#FST_EQ_EQUIV-val">FST_EQ_EQUIV</a> : thm
<a name="line35"></a>    val <a href="#FST_PAIR_MAP-val">FST_PAIR_MAP</a> : thm
<a name="line36"></a>    val <a href="#LAMBDA_PROD-val">LAMBDA_PROD</a> : thm
<a name="line37"></a>    val <a href="#LET2_RAND-val">LET2_RAND</a> : thm
<a name="line38"></a>    val <a href="#LET2_RATOR-val">LET2_RATOR</a> : thm
<a name="line39"></a>    val <a href="#LEX_CONG-val">LEX_CONG</a> : thm
<a name="line40"></a>    val <a href="#LEX_DEF_THM-val">LEX_DEF_THM</a> : thm
<a name="line41"></a>    val <a href="#LEX_MONO-val">LEX_MONO</a> : thm
<a name="line42"></a>    val <a href="#PAIR_EQ-val">PAIR_EQ</a> : thm
<a name="line43"></a>    val <a href="#PAIR_FST_SND_EQ-val">PAIR_FST_SND_EQ</a> : thm
<a name="line44"></a>    val <a href="#PAIR_FUN_THM-val">PAIR_FUN_THM</a> : thm
<a name="line45"></a>    val <a href="#PAIR_MAP_THM-val">PAIR_MAP_THM</a> : thm
<a name="line46"></a>    val <a href="#PEXISTS_THM-val">PEXISTS_THM</a> : thm
<a name="line47"></a>    val <a href="#PFORALL_THM-val">PFORALL_THM</a> : thm
<a name="line48"></a>    val <a href="#PROD_ALL_CONG-val">PROD_ALL_CONG</a> : thm
<a name="line49"></a>    val <a href="#PROD_ALL_MONO-val">PROD_ALL_MONO</a> : thm
<a name="line50"></a>    val <a href="#PROD_ALL_THM-val">PROD_ALL_THM</a> : thm
<a name="line51"></a>    val <a href="#SND-val">SND</a> : thm
<a name="line52"></a>    val <a href="#SND_EQ_EQUIV-val">SND_EQ_EQUIV</a> : thm
<a name="line53"></a>    val <a href="#SND_PAIR_MAP-val">SND_PAIR_MAP</a> : thm
<a name="line54"></a>    val <a href="#S_UNCURRY_R-val">S_UNCURRY_R</a> : thm
<a name="line55"></a>    val <a href="#UNCURRY_CONG-val">UNCURRY_CONG</a> : thm
<a name="line56"></a>    val <a href="#UNCURRY_CURRY_THM-val">UNCURRY_CURRY_THM</a> : thm
<a name="line57"></a>    val <a href="#UNCURRY_DEF-val">UNCURRY_DEF</a> : thm
<a name="line58"></a>    val <a href="#UNCURRY_ONE_ONE_THM-val">UNCURRY_ONE_ONE_THM</a> : thm
<a name="line59"></a>    val <a href="#UNCURRY_VAR-val">UNCURRY_VAR</a> : thm
<a name="line60"></a>    val <a href="#WF_LEX-val">WF_LEX</a> : thm
<a name="line61"></a>    val <a href="#WF_RPROD-val">WF_RPROD</a> : thm
<a name="line62"></a>    val <a href="#datatype_pair-val">datatype_pair</a> : thm
<a name="line63"></a>    val <a href="#o_UNCURRY_R-val">o_UNCURRY_R</a> : thm
<a name="line64"></a>    val <a href="#pair_Axiom-val">pair_Axiom</a> : thm
<a name="line65"></a>    val <a href="#pair_CASES-val">pair_CASES</a> : thm
<a name="line66"></a>    val <a href="#pair_case_cong-val">pair_case_cong</a> : thm
<a name="line67"></a>    val <a href="#pair_case_def-val">pair_case_def</a> : thm
<a name="line68"></a>    val <a href="#pair_case_eq-val">pair_case_eq</a> : thm
<a name="line69"></a>    val <a href="#pair_case_thm-val">pair_case_thm</a> : thm
<a name="line70"></a>    val <a href="#pair_induction-val">pair_induction</a> : thm
<a name="line71"></a>    val <a href="#reflexive_LEX-val">reflexive_LEX</a> : thm
<a name="line72"></a>    val <a href="#symmetric_LEX-val">symmetric_LEX</a> : thm
<a name="line73"></a>    val <a href="#total_LEX-val">total_LEX</a> : thm
<a name="line74"></a>    val <a href="#transitive_LEX-val">transitive_LEX</a> : thm
<a name="line75"></a>  
<a name="line76"></a>  val pair_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line77"></a>  
<a name="line78"></a>  val pair_rws : thm list
<a name="line79"></a>  
<a name="line80"></a>  type hol_type = Abbrev.hol_type
<a name="line81"></a>  type term     = Abbrev.term
<a name="line82"></a>  type conv     = Abbrev.conv
<a name="line83"></a>  
<a name="line84"></a>  val uncurry_tm       : term
<a name="line85"></a>  val comma_tm         : term
<a name="line86"></a>  val dest_pair        : term -&gt; term * term
<a name="line87"></a>  val strip_pair       : term -&gt; term list
<a name="line88"></a>  val spine_pair       : term -&gt; term list
<a name="line89"></a>  val is_vstruct       : term -&gt; bool
<a name="line90"></a>  val mk_pabs          : term * term -&gt; term
<a name="line91"></a>  val PAIRED_BETA_CONV : conv
<a name="line92"></a>  
<a name="line93"></a>(*
   [relation] Parent theory of "pair"
   
   [<a name="ABS_REP_prod-val"><b>ABS_REP_prod</b></a>]  Definition
      
      ⊢ (∀a. ABS_prod (REP_prod a) = a) ∧
        ∀r. (λp. ∃x y. p = (λa b. a = x ∧ b = y)) r ⇔
            REP_prod (ABS_prod r) = r
   
   [<a name="COMMA_DEF-val"><b>COMMA_DEF</b></a>]  Definition
      
      ⊢ ∀x y. (x,y) = ABS_prod (λa b. a = x ∧ b = y)
   
   [<a name="CURRY_DEF-val"><b>CURRY_DEF</b></a>]  Definition
      
      ⊢ ∀f x y. CURRY f x y = f (x,y)
   
   [<a name="LEX_DEF-val"><b>LEX_DEF</b></a>]  Definition
      
      ⊢ ∀R1 R2. R1 LEX R2 = (λ(s,t) (u,v). R1 s u ∨ s = u ∧ R2 t v)
   
   [<a name="PAIR-val"><b>PAIR</b></a>]  Definition
      
      ⊢ ∀x. (FST x,SND x) = x
   
   [<a name="PAIR_MAP-val"><b>PAIR_MAP</b></a>]  Definition
      
      ⊢ ∀f g p. (f ## g) p = (f (FST p),g (SND p))
   
   [<a name="PROD_ALL_def-val"><b>PROD_ALL_def</b></a>]  Definition
      
      ⊢ ∀P Q p. PROD_ALL P Q p ⇔ P (FST p) ∧ Q (SND p)
   
   [<a name="RPROD_DEF-val"><b>RPROD_DEF</b></a>]  Definition
      
      ⊢ ∀R1 R2. RPROD R1 R2 = (λ(s,t) (u,v). R1 s u ∧ R2 t v)
   
   [<a name="SWAP_def-val"><b>SWAP_def</b></a>]  Definition
      
      ⊢ ∀a. SWAP a = (SND a,FST a)
   
   [<a name="UNCURRY-val"><b>UNCURRY</b></a>]  Definition
      
      ⊢ ∀f v. UNCURRY f v = f (FST v) (SND v)
   
   [<a name="pair_CASE_def-val"><b>pair_CASE_def</b></a>]  Definition
      
      ⊢ ∀p f. pair_CASE p f = f (FST p) (SND p)
   
   [<a name="prod_TY_DEF-val"><b>prod_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep. TYPE_DEFINITION (λp. ∃x y. p = (λa b. a = x ∧ b = y)) rep
   
   [<a name="ABS_PAIR_THM-val"><b>ABS_PAIR_THM</b></a>]  Theorem
      
      ⊢ ∀x. ∃q r. x = (q,r)
   
   [<a name="CLOSED_PAIR_EQ-val"><b>CLOSED_PAIR_EQ</b></a>]  Theorem
      
      ⊢ ∀x y a b. (x,y) = (a,b) ⇔ x = a ∧ y = b
   
   [<a name="CURRY_ONE_ONE_THM-val"><b>CURRY_ONE_ONE_THM</b></a>]  Theorem
      
      ⊢ CURRY f = CURRY g ⇔ f = g
   
   [<a name="CURRY_UNCURRY_THM-val"><b>CURRY_UNCURRY_THM</b></a>]  Theorem
      
      ⊢ ∀f. CURRY (UNCURRY f) = f
   
   [<a name="C_UNCURRY_L-val"><b>C_UNCURRY_L</b></a>]  Theorem
      
      ⊢ flip (UNCURRY f) x = UNCURRY (flip (flip ∘ f) x)
   
   [<a name="ELIM_PEXISTS-val"><b>ELIM_PEXISTS</b></a>]  Theorem
      
      ⊢ (∃p. P (FST p) (SND p)) ⇔ ∃p1 p2. P p1 p2
   
   [<a name="ELIM_PEXISTS_EVAL-val"><b>ELIM_PEXISTS_EVAL</b></a>]  Theorem
      
      ⊢ $? (UNCURRY (λx. P x)) ⇔ ∃x. $? (P x)
   
   [<a name="ELIM_PFORALL-val"><b>ELIM_PFORALL</b></a>]  Theorem
      
      ⊢ (∀p. P (FST p) (SND p)) ⇔ ∀p1 p2. P p1 p2
   
   [<a name="ELIM_PFORALL_EVAL-val"><b>ELIM_PFORALL_EVAL</b></a>]  Theorem
      
      ⊢ $! (UNCURRY (λx. P x)) ⇔ ∀x. $! (P x)
   
   [<a name="ELIM_UNCURRY-val"><b>ELIM_UNCURRY</b></a>]  Theorem
      
      ⊢ ∀f. UNCURRY f = (λx. f (FST x) (SND x))
   
   [<a name="EXISTS_PROD-val"><b>EXISTS_PROD</b></a>]  Theorem
      
      ⊢ (∃p. P p) ⇔ ∃p_1 p_2. P (p_1,p_2)
   
   [<a name="FORALL_PROD-val"><b>FORALL_PROD</b></a>]  Theorem
      
      ⊢ (∀p. P p) ⇔ ∀p_1 p_2. P (p_1,p_2)
   
   [<a name="FORALL_UNCURRY-val"><b>FORALL_UNCURRY</b></a>]  Theorem
      
      ⊢ $! (UNCURRY f) ⇔ $! ($! ∘ f)
   
   [<a name="FST-val"><b>FST</b></a>]  Theorem
      
      ⊢ ∀x y. FST (x,y) = x
   
   [<a name="FST_EQ_EQUIV-val"><b>FST_EQ_EQUIV</b></a>]  Theorem
      
      ⊢ FST p = x ⇔ ∃y. p = (x,y)
   
   [<a name="FST_PAIR_MAP-val"><b>FST_PAIR_MAP</b></a>]  Theorem
      
      ⊢ ∀p f g. FST ((f ## g) p) = f (FST p)
   
   [<a name="LAMBDA_PROD-val"><b>LAMBDA_PROD</b></a>]  Theorem
      
      ⊢ ∀P. (λp. P p) = (λ(p1,p2). P (p1,p2))
   
   [<a name="LET2_RAND-val"><b>LET2_RAND</b></a>]  Theorem
      
      ⊢ ∀P M N. P (let (x,y) = M in N x y) = (let (x,y) = M in P (N x y))
   
   [<a name="LET2_RATOR-val"><b>LET2_RATOR</b></a>]  Theorem
      
      ⊢ ∀M N b. (let (x,y) = M in N x y) b = (let (x,y) = M in N x y b)
   
   [<a name="LEX_CONG-val"><b>LEX_CONG</b></a>]  Theorem
      
      ⊢ ∀R1 R2 v1 v2 R1' R2' v1' v2'.
          v1 = v1' ∧ v2 = v2' ∧
          (∀a b c d. v1' = (a,b) ∧ v2' = (c,d) ⇒ (R1 a c ⇔ R1' a c)) ∧
          (∀a b c d. v1' = (a,b) ∧ v2' = (c,d) ∧ a = c ⇒ (R2 b d ⇔ R2' b d)) ⇒
          ((R1 LEX R2) v1 v2 ⇔ (R1' LEX R2') v1' v2')
   
   [<a name="LEX_DEF_THM-val"><b>LEX_DEF_THM</b></a>]  Theorem
      
      ⊢ (R1 LEX R2) (a,b) (c,d) ⇔ R1 a c ∨ a = c ∧ R2 b d
   
   [<a name="LEX_MONO-val"><b>LEX_MONO</b></a>]  Theorem
      
      ⊢ (∀x y. R1 x y ⇒ R2 x y) ∧ (∀x y. R3 x y ⇒ R4 x y) ⇒
        (R1 LEX R3) x y ⇒
        (R2 LEX R4) x y
   
   [<a name="PAIR_EQ-val"><b>PAIR_EQ</b></a>]  Theorem
      
      ⊢ (x,y) = (a,b) ⇔ x = a ∧ y = b
   
   [<a name="PAIR_FST_SND_EQ-val"><b>PAIR_FST_SND_EQ</b></a>]  Theorem
      
      ⊢ ∀p q. p = q ⇔ FST p = FST q ∧ SND p = SND q
   
   [<a name="PAIR_FUN_THM-val"><b>PAIR_FUN_THM</b></a>]  Theorem
      
      ⊢ ∀P. (∃!f. P f) ⇔ ∃!p. P (λa. (FST p a,SND p a))
   
   [<a name="PAIR_MAP_THM-val"><b>PAIR_MAP_THM</b></a>]  Theorem
      
      ⊢ ∀f g x y. (f ## g) (x,y) = (f x,g y)
   
   [<a name="PEXISTS_THM-val"><b>PEXISTS_THM</b></a>]  Theorem
      
      ⊢ ∀P. (∃x y. P x y) ⇔ ∃(x,y). P x y
   
   [<a name="PFORALL_THM-val"><b>PFORALL_THM</b></a>]  Theorem
      
      ⊢ ∀P. (∀x y. P x y) ⇔ ∀(x,y). P x y
   
   [<a name="PROD_ALL_CONG-val"><b>PROD_ALL_CONG</b></a>]  Theorem
      
      ⊢ ∀p p' P P' Q Q'.
          p = p' ∧ (∀x y. p' = (x,y) ⇒ (P x ⇔ P' x)) ∧
          (∀x y. p' = (x,y) ⇒ (Q y ⇔ Q' y)) ⇒
          (PROD_ALL P Q p ⇔ PROD_ALL P' Q' p')
   
   [<a name="PROD_ALL_MONO-val"><b>PROD_ALL_MONO</b></a>]  Theorem
      
      ⊢ (∀x. P x ⇒ P' x) ∧ (∀y. Q y ⇒ Q' y) ⇒
        PROD_ALL P Q p ⇒
        PROD_ALL P' Q' p
   
   [<a name="PROD_ALL_THM-val"><b>PROD_ALL_THM</b></a>]  Theorem
      
      ⊢ PROD_ALL P Q (x,y) ⇔ P x ∧ Q y
   
   [<a name="SND-val"><b>SND</b></a>]  Theorem
      
      ⊢ ∀x y. SND (x,y) = y
   
   [<a name="SND_EQ_EQUIV-val"><b>SND_EQ_EQUIV</b></a>]  Theorem
      
      ⊢ SND p = y ⇔ ∃x. p = (x,y)
   
   [<a name="SND_PAIR_MAP-val"><b>SND_PAIR_MAP</b></a>]  Theorem
      
      ⊢ ∀p f g. SND ((f ## g) p) = g (SND p)
   
   [<a name="S_UNCURRY_R-val"><b>S_UNCURRY_R</b></a>]  Theorem
      
      ⊢ S f (UNCURRY g) = UNCURRY (S (S ∘ $o f ∘ $,) g)
   
   [<a name="UNCURRY_CONG-val"><b>UNCURRY_CONG</b></a>]  Theorem
      
      ⊢ ∀f' f M' M.
          M = M' ∧ (∀x y. M' = (x,y) ⇒ f x y = f' x y) ⇒
          UNCURRY f M = UNCURRY f' M'
   
   [<a name="UNCURRY_CURRY_THM-val"><b>UNCURRY_CURRY_THM</b></a>]  Theorem
      
      ⊢ ∀f. UNCURRY (CURRY f) = f
   
   [<a name="UNCURRY_DEF-val"><b>UNCURRY_DEF</b></a>]  Theorem
      
      ⊢ ∀f x y. UNCURRY f (x,y) = f x y
   
   [<a name="UNCURRY_ONE_ONE_THM-val"><b>UNCURRY_ONE_ONE_THM</b></a>]  Theorem
      
      ⊢ UNCURRY f = UNCURRY g ⇔ f = g
   
   [<a name="UNCURRY_VAR-val"><b>UNCURRY_VAR</b></a>]  Theorem
      
      ⊢ ∀f v. UNCURRY f v = f (FST v) (SND v)
   
   [<a name="WF_LEX-val"><b>WF_LEX</b></a>]  Theorem
      
      ⊢ ∀R Q. WF R ∧ WF Q ⇒ WF (R LEX Q)
   
   [<a name="WF_RPROD-val"><b>WF_RPROD</b></a>]  Theorem
      
      ⊢ ∀R Q. WF R ∧ WF Q ⇒ WF (RPROD R Q)
   
   [<a name="datatype_pair-val"><b>datatype_pair</b></a>]  Theorem
      
      ⊢ DATATYPE (pair $,)
   
   [<a name="o_UNCURRY_R-val"><b>o_UNCURRY_R</b></a>]  Theorem
      
      ⊢ f ∘ UNCURRY g = UNCURRY ($o f ∘ g)
   
   [<a name="pair_Axiom-val"><b>pair_Axiom</b></a>]  Theorem
      
      ⊢ ∀f. ∃fn. ∀x y. fn (x,y) = f x y
   
   [<a name="pair_CASES-val"><b>pair_CASES</b></a>]  Theorem
      
      ⊢ ∀x. ∃q r. x = (q,r)
   
   [<a name="pair_case_cong-val"><b>pair_case_cong</b></a>]  Theorem
      
      ⊢ ∀M M' f.
          M = M' ∧ (∀x y. M' = (x,y) ⇒ f x y = f' x y) ⇒
          pair_CASE M f = pair_CASE M' f'
   
   [<a name="pair_case_def-val"><b>pair_case_def</b></a>]  Theorem
      
      ⊢ pair_CASE (x,y) f = f x y
   
   [<a name="pair_case_eq-val"><b>pair_case_eq</b></a>]  Theorem
      
      ⊢ pair_CASE p f = v ⇔ ∃x y. p = (x,y) ∧ f x y = v
   
   [<a name="pair_case_thm-val"><b>pair_case_thm</b></a>]  Theorem
      
      ⊢ pair_CASE (x,y) f = f x y
   
   [<a name="pair_induction-val"><b>pair_induction</b></a>]  Theorem
      
      ⊢ ∀P. (∀p_1 p_2. P (p_1,p_2)) ⇒ ∀p. P p
   
   [<a name="reflexive_LEX-val"><b>reflexive_LEX</b></a>]  Theorem
      
      ⊢ reflexive (R1 LEX R2) ⇔ reflexive R1 ∨ reflexive R2
   
   [<a name="symmetric_LEX-val"><b>symmetric_LEX</b></a>]  Theorem
      
      ⊢ symmetric R1 ∧ symmetric R2 ⇒ symmetric (R1 LEX R2)
   
   [<a name="total_LEX-val"><b>total_LEX</b></a>]  Theorem
      
      ⊢ total R1 ∧ total R2 ⇒ total (R1 LEX R2)
   
   [<a name="transitive_LEX-val"><b>transitive_LEX</b></a>]  Theorem
      
      ⊢ transitive R1 ∧ transitive R2 ⇒ transitive (R1 LEX R2)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/coretypes/pairScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-14</a></em></p></body></html>
