<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure ltreeTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure ltreeTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/coalgebras/ltreeScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature ltreeTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#ltree_TY_DEF-val">ltree_TY_DEF</a> : thm
<a name="line7"></a>    val <a href="#ltree_map_def-val">ltree_map_def</a> : thm
<a name="line8"></a>    val <a href="#ltree_rel_def-val">ltree_rel_def</a> : thm
<a name="line9"></a>    val <a href="#ltree_set_def-val">ltree_set_def</a> : thm
<a name="line10"></a>    val <a href="#rose_tree_TY_DEF-val">rose_tree_TY_DEF</a> : thm
<a name="line11"></a>    val <a href="#rose_tree_case_def-val">rose_tree_case_def</a> : thm
<a name="line12"></a>    val <a href="#rose_tree_size_def-val">rose_tree_size_def</a> : thm
<a name="line13"></a>    val <a href="#subtrees_def-val">subtrees_def</a> : thm
<a name="line14"></a>  
<a name="line15"></a>  (*  Theorems  *)
<a name="line16"></a>    val <a href="#Branch_11-val">Branch_11</a> : thm
<a name="line17"></a>    val <a href="#datatype_ltree-val">datatype_ltree</a> : thm
<a name="line18"></a>    val <a href="#datatype_rose_tree-val">datatype_rose_tree</a> : thm
<a name="line19"></a>    val <a href="#from_rose_def-val">from_rose_def</a> : thm
<a name="line20"></a>    val <a href="#from_rose_ind-val">from_rose_ind</a> : thm
<a name="line21"></a>    val <a href="#gen_ltree-val">gen_ltree</a> : thm
<a name="line22"></a>    val <a href="#gen_ltree_LNIL-val">gen_ltree_LNIL</a> : thm
<a name="line23"></a>    val <a href="#ltree_CASE-val">ltree_CASE</a> : thm
<a name="line24"></a>    val <a href="#ltree_CASE_cong-val">ltree_CASE_cong</a> : thm
<a name="line25"></a>    val <a href="#ltree_CASE_eq-val">ltree_CASE_eq</a> : thm
<a name="line26"></a>    val <a href="#ltree_bisimulation-val">ltree_bisimulation</a> : thm
<a name="line27"></a>    val <a href="#ltree_cases-val">ltree_cases</a> : thm
<a name="line28"></a>    val <a href="#ltree_el_def-val">ltree_el_def</a> : thm
<a name="line29"></a>    val <a href="#ltree_el_eqv-val">ltree_el_eqv</a> : thm
<a name="line30"></a>    val <a href="#ltree_finite-val">ltree_finite</a> : thm
<a name="line31"></a>    val <a href="#ltree_finite_cases-val">ltree_finite_cases</a> : thm
<a name="line32"></a>    val <a href="#ltree_finite_from_rose-val">ltree_finite_from_rose</a> : thm
<a name="line33"></a>    val <a href="#ltree_finite_ind-val">ltree_finite_ind</a> : thm
<a name="line34"></a>    val <a href="#ltree_finite_rules-val">ltree_finite_rules</a> : thm
<a name="line35"></a>    val <a href="#ltree_finite_strongind-val">ltree_finite_strongind</a> : thm
<a name="line36"></a>    val <a href="#ltree_lookup_def-val">ltree_lookup_def</a> : thm
<a name="line37"></a>    val <a href="#ltree_map-val">ltree_map</a> : thm
<a name="line38"></a>    val <a href="#ltree_map_id-val">ltree_map_id</a> : thm
<a name="line39"></a>    val <a href="#ltree_map_map-val">ltree_map_map</a> : thm
<a name="line40"></a>    val <a href="#ltree_rel-val">ltree_rel</a> : thm
<a name="line41"></a>    val <a href="#ltree_rel_O-val">ltree_rel_O</a> : thm
<a name="line42"></a>    val <a href="#ltree_rel_eq-val">ltree_rel_eq</a> : thm
<a name="line43"></a>    val <a href="#ltree_set-val">ltree_set</a> : thm
<a name="line44"></a>    val <a href="#ltree_set_map-val">ltree_set_map</a> : thm
<a name="line45"></a>    val <a href="#ltree_unfold-val">ltree_unfold</a> : thm
<a name="line46"></a>    val <a href="#rose_tree_11-val">rose_tree_11</a> : thm
<a name="line47"></a>    val <a href="#rose_tree_Axiom-val">rose_tree_Axiom</a> : thm
<a name="line48"></a>    val <a href="#rose_tree_case_cong-val">rose_tree_case_cong</a> : thm
<a name="line49"></a>    val <a href="#rose_tree_case_eq-val">rose_tree_case_eq</a> : thm
<a name="line50"></a>    val <a href="#rose_tree_induction-val">rose_tree_induction</a> : thm
<a name="line51"></a>    val <a href="#rose_tree_nchotomy-val">rose_tree_nchotomy</a> : thm
<a name="line52"></a>    val <a href="#subtrees-val">subtrees</a> : thm
<a name="line53"></a>  
<a name="line54"></a>  val ltree_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line55"></a>(*
   [alist] Parent theory of "ltree"
   
   [llist] Parent theory of "ltree"
   
   [<a name="ltree_TY_DEF-val"><b>ltree_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep. TYPE_DEFINITION ltree_rep_ok rep
   
   [<a name="ltree_map_def-val"><b>ltree_map_def</b></a>]  Definition
      
      ⊢ ∀f. ltree_map f =
            ltree_unfold (λt. case t of Branch a ts =&gt; (f a,ts))
   
   [<a name="ltree_rel_def-val"><b>ltree_rel_def</b></a>]  Definition
      
      ⊢ ∀R x y.
          ltree_rel R x y ⇔
          ∀path.
            OPTREL (λx y. R (FST x) (FST y) ∧ SND x = SND y)
              (ltree_el x path) (ltree_el y path)
   
   [<a name="ltree_set_def-val"><b>ltree_set_def</b></a>]  Definition
      
      ⊢ ∀t. ltree_set t = {a | ∃ts. Branch a ts ∈ subtrees t}
   
   [<a name="rose_tree_TY_DEF-val"><b>rose_tree_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep.
          TYPE_DEFINITION
            (λa0'.
                 ∀ $var$('rose_tree') $var$('@temp @ind_typeltree0list').
                   (∀a0'.
                      (∃a0 a1.
                         a0' =
                         (λa0 a1.
                              ind_type$CONSTR 0 a0
                                (ind_type$FCONS a1 (λn. ind_type$BOTTOM)))
                           a0 a1 ∧ $var$('@temp @ind_typeltree0list') a1) ⇒
                      $var$('rose_tree') a0') ∧
                   (∀a1'.
                      a1' =
                      ind_type$CONSTR (SUC 0) ARB (λn. ind_type$BOTTOM) ∨
                      (∃a0 a1.
                         a1' =
                         (λa0 a1.
                              ind_type$CONSTR (SUC (SUC 0)) ARB
                                (ind_type$FCONS a0
                                   (ind_type$FCONS a1 (λn. ind_type$BOTTOM))))
                           a0 a1 ∧ $var$('rose_tree') a0 ∧
                         $var$('@temp @ind_typeltree0list') a1) ⇒
                      $var$('@temp @ind_typeltree0list') a1') ⇒
                   $var$('rose_tree') a0') rep
   
   [<a name="rose_tree_case_def-val"><b>rose_tree_case_def</b></a>]  Definition
      
      ⊢ ∀a0 a1 f. rose_tree_CASE (Rose a0 a1) f = f a0 a1
   
   [<a name="rose_tree_size_def-val"><b>rose_tree_size_def</b></a>]  Definition
      
      ⊢ (∀f a0 a1.
           rose_tree_size f (Rose a0 a1) =
           1 + (f a0 + rose_tree1_size f a1)) ∧
        (∀f. rose_tree1_size f [] = 0) ∧
        ∀f a0 a1.
          rose_tree1_size f (a0::a1) =
          1 + (rose_tree_size f a0 + rose_tree1_size f a1)
   
   [<a name="subtrees_def-val"><b>subtrees_def</b></a>]  Definition
      
      ⊢ ∀t. subtrees t = {u | ∃path. ltree_lookup t path = SOME u}
   
   [<a name="Branch_11-val"><b>Branch_11</b></a>]  Theorem
      
      ⊢ ∀a1 a2 ts1 ts2. Branch a1 ts1 = Branch a2 ts2 ⇔ a1 = a2 ∧ ts1 = ts2
   
   [<a name="datatype_ltree-val"><b>datatype_ltree</b></a>]  Theorem
      
      ⊢ DATATYPE (ltree Branch)
   
   [<a name="datatype_rose_tree-val"><b>datatype_rose_tree</b></a>]  Theorem
      
      ⊢ DATATYPE (rose_tree Rose)
   
   [<a name="from_rose_def-val"><b>from_rose_def</b></a>]  Theorem
      
      ⊢ ∀ts a.
          from_rose (Rose a ts) =
          Branch a (fromList (MAP (λa'. from_rose a') ts))
   
   [<a name="from_rose_ind-val"><b>from_rose_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀a ts. (∀a'. MEM a' ts ⇒ P a') ⇒ P (Rose a ts)) ⇒ ∀v. P v
   
   [<a name="gen_ltree-val"><b>gen_ltree</b></a>]  Theorem
      
      ⊢ gen_ltree f =
        (let
           (a,len) = f []
         in
           Branch a (LGENLIST (λn. gen_ltree (λpath. f (n::path))) len))
   
   [<a name="gen_ltree_LNIL-val"><b>gen_ltree_LNIL</b></a>]  Theorem
      
      ⊢ gen_ltree f = Branch a [||] ⇔ f [] = (a,SOME 0)
   
   [<a name="ltree_CASE-val"><b>ltree_CASE</b></a>]  Theorem
      
      ⊢ ltree_CASE (Branch a ts) f = f a ts
   
   [<a name="ltree_CASE_cong-val"><b>ltree_CASE_cong</b></a>]  Theorem
      
      ⊢ ∀M M' f f'.
          M = M' ∧ (∀a ts. M' = Branch a ts ⇒ f a ts = f' a ts) ⇒
          ltree_CASE M f = ltree_CASE M' f'
   
   [<a name="ltree_CASE_eq-val"><b>ltree_CASE_eq</b></a>]  Theorem
      
      ⊢ ltree_CASE t f = v ⇔ ∃a ts. t = Branch a ts ∧ f a ts = v
   
   [<a name="ltree_bisimulation-val"><b>ltree_bisimulation</b></a>]  Theorem
      
      ⊢ ∀t1 t2.
          t1 = t2 ⇔
          ∃R. R t1 t2 ∧
              ∀a ts a' ts'.
                R (Branch a ts) (Branch a' ts') ⇒
                a = a' ∧ llist_rel R ts ts'
   
   [<a name="ltree_cases-val"><b>ltree_cases</b></a>]  Theorem
      
      ⊢ ∀t. ∃a ts. t = Branch a ts
   
   [<a name="ltree_el_def-val"><b>ltree_el_def</b></a>]  Theorem
      
      ⊢ ltree_el (Branch a ts) [] = SOME (a,LLENGTH ts) ∧
        ltree_el (Branch a ts) (n::ns) =
        case LNTH n ts of NONE =&gt; NONE | SOME t =&gt; ltree_el t ns
   
   [<a name="ltree_el_eqv-val"><b>ltree_el_eqv</b></a>]  Theorem
      
      ⊢ ∀t1 t2. t1 = t2 ⇔ ∀path. ltree_el t1 path = ltree_el t2 path
   
   [<a name="ltree_finite-val"><b>ltree_finite</b></a>]  Theorem
      
      ⊢ ltree_finite (Branch a ts) ⇔
        LFINITE ts ∧ ∀t. t ∈ LSET ts ⇒ ltree_finite t
   
   [<a name="ltree_finite_cases-val"><b>ltree_finite_cases</b></a>]  Theorem
      
      ⊢ ∀a0.
          ltree_finite a0 ⇔
          ∃a ts. a0 = Branch a (fromList ts) ∧ EVERY ltree_finite ts
   
   [<a name="ltree_finite_from_rose-val"><b>ltree_finite_from_rose</b></a>]  Theorem
      
      ⊢ ltree_finite t ⇔ ∃r. from_rose r = t
   
   [<a name="ltree_finite_ind-val"><b>ltree_finite_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀a ts. EVERY P ts ⇒ P (Branch a (fromList ts))) ⇒
            ∀t. ltree_finite t ⇒ P t
   
   [<a name="ltree_finite_rules-val"><b>ltree_finite_rules</b></a>]  Theorem
      
      ⊢ ∀a ts.
          EVERY ltree_finite ts ⇒ ltree_finite (Branch a (fromList ts))
   
   [<a name="ltree_finite_strongind-val"><b>ltree_finite_strongind</b></a>]  Theorem
      
      ⊢ ∀P. (∀a ts.
               EVERY (λa0. ltree_finite a0 ∧ P a0) ts ⇒
               P (Branch a (fromList ts))) ⇒
            ∀t. ltree_finite t ⇒ P t
   
   [<a name="ltree_lookup_def-val"><b>ltree_lookup_def</b></a>]  Theorem
      
      ⊢ ltree_lookup t [] = SOME t ∧
        ltree_lookup (Branch a ts) (n::ns) =
        case LNTH n ts of NONE =&gt; NONE | SOME t =&gt; ltree_lookup t ns
   
   [<a name="ltree_map-val"><b>ltree_map</b></a>]  Theorem
      
      ⊢ ltree_map f (Branch a xs) = Branch (f a) (LMAP (ltree_map f) xs)
   
   [<a name="ltree_map_id-val"><b>ltree_map_id</b></a>]  Theorem
      
      ⊢ ltree_map I t = t
   
   [<a name="ltree_map_map-val"><b>ltree_map_map</b></a>]  Theorem
      
      ⊢ ltree_map f (ltree_map g t) = ltree_map (f ∘ g) t
   
   [<a name="ltree_rel-val"><b>ltree_rel</b></a>]  Theorem
      
      ⊢ ltree_rel R (Branch a ts) (Branch b us) ⇔
        R a b ∧ llist_rel (ltree_rel R) ts us
   
   [<a name="ltree_rel_O-val"><b>ltree_rel_O</b></a>]  Theorem
      
      ⊢ ltree_rel R1 ∘ᵣ ltree_rel R2 ⊆ᵣ ltree_rel (R1 ∘ᵣ R2)
   
   [<a name="ltree_rel_eq-val"><b>ltree_rel_eq</b></a>]  Theorem
      
      ⊢ ltree_rel $= x y ⇔ x = y
   
   [<a name="ltree_set-val"><b>ltree_set</b></a>]  Theorem
      
      ⊢ ltree_set (Branch a ts) =
        a INSERT BIGUNION (IMAGE ltree_set (LSET ts))
   
   [<a name="ltree_set_map-val"><b>ltree_set_map</b></a>]  Theorem
      
      ⊢ ltree_set (ltree_map f t) = IMAGE f (ltree_set t)
   
   [<a name="ltree_unfold-val"><b>ltree_unfold</b></a>]  Theorem
      
      ⊢ ltree_unfold f seed =
        (let (a,seeds) = f seed in Branch a (LMAP (ltree_unfold f) seeds))
   
   [<a name="rose_tree_11-val"><b>rose_tree_11</b></a>]  Theorem
      
      ⊢ ∀a0 a1 a0' a1'. Rose a0 a1 = Rose a0' a1' ⇔ a0 = a0' ∧ a1 = a1'
   
   [<a name="rose_tree_Axiom-val"><b>rose_tree_Axiom</b></a>]  Theorem
      
      ⊢ ∀f0 f1 f2. ∃fn0 fn1.
          (∀a0 a1. fn0 (Rose a0 a1) = f0 a0 a1 (fn1 a1)) ∧ fn1 [] = f1 ∧
          ∀a0 a1. fn1 (a0::a1) = f2 a0 a1 (fn0 a0) (fn1 a1)
   
   [<a name="rose_tree_case_cong-val"><b>rose_tree_case_cong</b></a>]  Theorem
      
      ⊢ ∀M M' f.
          M = M' ∧ (∀a0 a1. M' = Rose a0 a1 ⇒ f a0 a1 = f' a0 a1) ⇒
          rose_tree_CASE M f = rose_tree_CASE M' f'
   
   [<a name="rose_tree_case_eq-val"><b>rose_tree_case_eq</b></a>]  Theorem
      
      ⊢ rose_tree_CASE x f = v ⇔ ∃a l. x = Rose a l ∧ f a l = v
   
   [<a name="rose_tree_induction-val"><b>rose_tree_induction</b></a>]  Theorem
      
      ⊢ ∀P. (∀a ts. (∀a'. MEM a' ts ⇒ P a') ⇒ P (Rose a ts)) ⇒ ∀v. P v
   
   [<a name="rose_tree_nchotomy-val"><b>rose_tree_nchotomy</b></a>]  Theorem
      
      ⊢ ∀rr. ∃a l. rr = Rose a l
   
   [<a name="subtrees-val"><b>subtrees</b></a>]  Theorem
      
      ⊢ subtrees (Branch a ts) =
        Branch a ts INSERT BIGUNION (IMAGE subtrees (LSET ts))
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/coalgebras/ltreeScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-14</a></em></p></body></html>
