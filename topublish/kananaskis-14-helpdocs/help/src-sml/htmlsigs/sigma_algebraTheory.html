<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure sigma_algebraTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure sigma_algebraTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/probability/sigma_algebraScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature sigma_algebraTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#algebra_def-val">algebra_def</a> : thm
<a name="line7"></a>    val <a href="#dynkin_def-val">dynkin_def</a> : thm
<a name="line8"></a>    val <a href="#dynkin_system_def-val">dynkin_system_def</a> : thm
<a name="line9"></a>    val <a href="#measurable_def-val">measurable_def</a> : thm
<a name="line10"></a>    val <a href="#prod_sigma_def-val">prod_sigma_def</a> : thm
<a name="line11"></a>    val <a href="#ring_def-val">ring_def</a> : thm
<a name="line12"></a>    val <a href="#semiring_def-val">semiring_def</a> : thm
<a name="line13"></a>    val <a href="#sigma_algebra_def-val">sigma_algebra_def</a> : thm
<a name="line14"></a>    val <a href="#sigma_def-val">sigma_def</a> : thm
<a name="line15"></a>    val <a href="#sigma_function_def-val">sigma_function_def</a> : thm
<a name="line16"></a>    val <a href="#sigma_functions_def-val">sigma_functions_def</a> : thm
<a name="line17"></a>    val <a href="#sigma_sets_def-val">sigma_sets_def</a> : thm
<a name="line18"></a>    val <a href="#smallest_ring_def-val">smallest_ring_def</a> : thm
<a name="line19"></a>    val <a href="#space_def-val">space_def</a> : thm
<a name="line20"></a>    val <a href="#subset_class_def-val">subset_class_def</a> : thm
<a name="line21"></a>    val <a href="#subsets_def-val">subsets_def</a> : thm
<a name="line22"></a>  
<a name="line23"></a>  (*  Theorems  *)
<a name="line24"></a>    val <a href="#ALGEBRA_ALT_INTER-val">ALGEBRA_ALT_INTER</a> : thm
<a name="line25"></a>    val <a href="#ALGEBRA_COMPL-val">ALGEBRA_COMPL</a> : thm
<a name="line26"></a>    val <a href="#ALGEBRA_COMPL_SETS-val">ALGEBRA_COMPL_SETS</a> : thm
<a name="line27"></a>    val <a href="#ALGEBRA_DIFF-val">ALGEBRA_DIFF</a> : thm
<a name="line28"></a>    val <a href="#ALGEBRA_EMPTY-val">ALGEBRA_EMPTY</a> : thm
<a name="line29"></a>    val <a href="#ALGEBRA_FINITE_UNION-val">ALGEBRA_FINITE_UNION</a> : thm
<a name="line30"></a>    val <a href="#ALGEBRA_IMP_RING-val">ALGEBRA_IMP_RING</a> : thm
<a name="line31"></a>    val <a href="#ALGEBRA_IMP_SEMIRING-val">ALGEBRA_IMP_SEMIRING</a> : thm
<a name="line32"></a>    val <a href="#ALGEBRA_INTER-val">ALGEBRA_INTER</a> : thm
<a name="line33"></a>    val <a href="#ALGEBRA_INTER_SPACE-val">ALGEBRA_INTER_SPACE</a> : thm
<a name="line34"></a>    val <a href="#ALGEBRA_RESTRICT-val">ALGEBRA_RESTRICT</a> : thm
<a name="line35"></a>    val <a href="#ALGEBRA_SETS_COLLECT_CONST-val">ALGEBRA_SETS_COLLECT_CONST</a> : thm
<a name="line36"></a>    val <a href="#ALGEBRA_SETS_COLLECT_IMP-val">ALGEBRA_SETS_COLLECT_IMP</a> : thm
<a name="line37"></a>    val <a href="#ALGEBRA_SETS_COLLECT_NEG-val">ALGEBRA_SETS_COLLECT_NEG</a> : thm
<a name="line38"></a>    val <a href="#ALGEBRA_SINGLE_SET-val">ALGEBRA_SINGLE_SET</a> : thm
<a name="line39"></a>    val <a href="#ALGEBRA_SPACE-val">ALGEBRA_SPACE</a> : thm
<a name="line40"></a>    val <a href="#ALGEBRA_UNION-val">ALGEBRA_UNION</a> : thm
<a name="line41"></a>    val <a href="#DYNKIN-val">DYNKIN</a> : thm
<a name="line42"></a>    val <a href="#DYNKIN_LEMMA-val">DYNKIN_LEMMA</a> : thm
<a name="line43"></a>    val <a href="#DYNKIN_MONOTONE-val">DYNKIN_MONOTONE</a> : thm
<a name="line44"></a>    val <a href="#DYNKIN_SMALLEST-val">DYNKIN_SMALLEST</a> : thm
<a name="line45"></a>    val <a href="#DYNKIN_STABLE-val">DYNKIN_STABLE</a> : thm
<a name="line46"></a>    val <a href="#DYNKIN_STABLE_LEMMA-val">DYNKIN_STABLE_LEMMA</a> : thm
<a name="line47"></a>    val <a href="#DYNKIN_SUBSET-val">DYNKIN_SUBSET</a> : thm
<a name="line48"></a>    val <a href="#DYNKIN_SUBSET_SIGMA-val">DYNKIN_SUBSET_SIGMA</a> : thm
<a name="line49"></a>    val <a href="#DYNKIN_SUBSET_SUBSETS-val">DYNKIN_SUBSET_SUBSETS</a> : thm
<a name="line50"></a>    val <a href="#DYNKIN_SYSTEM_ALT-val">DYNKIN_SYSTEM_ALT</a> : thm
<a name="line51"></a>    val <a href="#DYNKIN_SYSTEM_ALT_MONO-val">DYNKIN_SYSTEM_ALT_MONO</a> : thm
<a name="line52"></a>    val <a href="#DYNKIN_SYSTEM_COMPL-val">DYNKIN_SYSTEM_COMPL</a> : thm
<a name="line53"></a>    val <a href="#DYNKIN_SYSTEM_COUNTABLY_DUNION-val">DYNKIN_SYSTEM_COUNTABLY_DUNION</a> : thm
<a name="line54"></a>    val <a href="#DYNKIN_SYSTEM_DUNION-val">DYNKIN_SYSTEM_DUNION</a> : thm
<a name="line55"></a>    val <a href="#DYNKIN_SYSTEM_EMPTY-val">DYNKIN_SYSTEM_EMPTY</a> : thm
<a name="line56"></a>    val <a href="#DYNKIN_SYSTEM_INCREASING-val">DYNKIN_SYSTEM_INCREASING</a> : thm
<a name="line57"></a>    val <a href="#DYNKIN_SYSTEM_SPACE-val">DYNKIN_SYSTEM_SPACE</a> : thm
<a name="line58"></a>    val <a href="#DYNKIN_THM-val">DYNKIN_THM</a> : thm
<a name="line59"></a>    val <a href="#INTER_SPACE_EQ1-val">INTER_SPACE_EQ1</a> : thm
<a name="line60"></a>    val <a href="#INTER_SPACE_REDUCE-val">INTER_SPACE_REDUCE</a> : thm
<a name="line61"></a>    val <a href="#IN_DYNKIN-val">IN_DYNKIN</a> : thm
<a name="line62"></a>    val <a href="#IN_MEASURABLE-val">IN_MEASURABLE</a> : thm
<a name="line63"></a>    val <a href="#IN_SIGMA-val">IN_SIGMA</a> : thm
<a name="line64"></a>    val <a href="#MEASUBABLE_BIGUNION_LEMMA-val">MEASUBABLE_BIGUNION_LEMMA</a> : thm
<a name="line65"></a>    val <a href="#MEASURABLE_BIGUNION_PROPERTY-val">MEASURABLE_BIGUNION_PROPERTY</a> : thm
<a name="line66"></a>    val <a href="#MEASURABLE_COMP-val">MEASURABLE_COMP</a> : thm
<a name="line67"></a>    val <a href="#MEASURABLE_COMP_STRONG-val">MEASURABLE_COMP_STRONG</a> : thm
<a name="line68"></a>    val <a href="#MEASURABLE_COMP_STRONGER-val">MEASURABLE_COMP_STRONGER</a> : thm
<a name="line69"></a>    val <a href="#MEASURABLE_DIFF_PROPERTY-val">MEASURABLE_DIFF_PROPERTY</a> : thm
<a name="line70"></a>    val <a href="#MEASURABLE_I-val">MEASURABLE_I</a> : thm
<a name="line71"></a>    val <a href="#MEASURABLE_LIFT-val">MEASURABLE_LIFT</a> : thm
<a name="line72"></a>    val <a href="#MEASURABLE_PROD_SIGMA-val">MEASURABLE_PROD_SIGMA</a> : thm
<a name="line73"></a>    val <a href="#MEASURABLE_PROD_SIGMA'-val">MEASURABLE_PROD_SIGMA'</a> : thm
<a name="line74"></a>    val <a href="#MEASURABLE_SIGMA-val">MEASURABLE_SIGMA</a> : thm
<a name="line75"></a>    val <a href="#MEASURABLE_SIGMA_PREIMAGES-val">MEASURABLE_SIGMA_PREIMAGES</a> : thm
<a name="line76"></a>    val <a href="#MEASURABLE_SUBSET-val">MEASURABLE_SUBSET</a> : thm
<a name="line77"></a>    val <a href="#MEASURABLE_UP_LIFT-val">MEASURABLE_UP_LIFT</a> : thm
<a name="line78"></a>    val <a href="#MEASURABLE_UP_SIGMA-val">MEASURABLE_UP_SIGMA</a> : thm
<a name="line79"></a>    val <a href="#MEASURABLE_UP_SUBSET-val">MEASURABLE_UP_SUBSET</a> : thm
<a name="line80"></a>    val <a href="#POW_ALGEBRA-val">POW_ALGEBRA</a> : thm
<a name="line81"></a>    val <a href="#POW_SIGMA_ALGEBRA-val">POW_SIGMA_ALGEBRA</a> : thm
<a name="line82"></a>    val <a href="#PREIMAGE_SIGMA-val">PREIMAGE_SIGMA</a> : thm
<a name="line83"></a>    val <a href="#PREIMAGE_SIGMA_ALGEBRA-val">PREIMAGE_SIGMA_ALGEBRA</a> : thm
<a name="line84"></a>    val <a href="#RING_BIGUNION-val">RING_BIGUNION</a> : thm
<a name="line85"></a>    val <a href="#RING_DIFF-val">RING_DIFF</a> : thm
<a name="line86"></a>    val <a href="#RING_DIFF_ALT-val">RING_DIFF_ALT</a> : thm
<a name="line87"></a>    val <a href="#RING_EMPTY-val">RING_EMPTY</a> : thm
<a name="line88"></a>    val <a href="#RING_FINITE_BIGUNION1-val">RING_FINITE_BIGUNION1</a> : thm
<a name="line89"></a>    val <a href="#RING_FINITE_BIGUNION2-val">RING_FINITE_BIGUNION2</a> : thm
<a name="line90"></a>    val <a href="#RING_FINITE_INTER-val">RING_FINITE_INTER</a> : thm
<a name="line91"></a>    val <a href="#RING_FINITE_UNION-val">RING_FINITE_UNION</a> : thm
<a name="line92"></a>    val <a href="#RING_FINITE_UNION_ALT-val">RING_FINITE_UNION_ALT</a> : thm
<a name="line93"></a>    val <a href="#RING_IMP_SEMIRING-val">RING_IMP_SEMIRING</a> : thm
<a name="line94"></a>    val <a href="#RING_INSERT-val">RING_INSERT</a> : thm
<a name="line95"></a>    val <a href="#RING_INTER-val">RING_INTER</a> : thm
<a name="line96"></a>    val <a href="#RING_SETS_COLLECT_FINITE-val">RING_SETS_COLLECT_FINITE</a> : thm
<a name="line97"></a>    val <a href="#RING_SPACE_IMP_ALGEBRA-val">RING_SPACE_IMP_ALGEBRA</a> : thm
<a name="line98"></a>    val <a href="#RING_UNION-val">RING_UNION</a> : thm
<a name="line99"></a>    val <a href="#SEMIRING_DIFF-val">SEMIRING_DIFF</a> : thm
<a name="line100"></a>    val <a href="#SEMIRING_DIFF_ALT-val">SEMIRING_DIFF_ALT</a> : thm
<a name="line101"></a>    val <a href="#SEMIRING_EMPTY-val">SEMIRING_EMPTY</a> : thm
<a name="line102"></a>    val <a href="#SEMIRING_INTER-val">SEMIRING_INTER</a> : thm
<a name="line103"></a>    val <a href="#SEMIRING_PROD_SETS-val">SEMIRING_PROD_SETS</a> : thm
<a name="line104"></a>    val <a href="#SEMIRING_PROD_SETS'-val">SEMIRING_PROD_SETS'</a> : thm
<a name="line105"></a>    val <a href="#SEMIRING_SETS_COLLECT-val">SEMIRING_SETS_COLLECT</a> : thm
<a name="line106"></a>    val <a href="#SIGMA_ALGEBRA-val">SIGMA_ALGEBRA</a> : thm
<a name="line107"></a>    val <a href="#SIGMA_ALGEBRA_ALGEBRA-val">SIGMA_ALGEBRA_ALGEBRA</a> : thm
<a name="line108"></a>    val <a href="#SIGMA_ALGEBRA_ALT-val">SIGMA_ALGEBRA_ALT</a> : thm
<a name="line109"></a>    val <a href="#SIGMA_ALGEBRA_ALT_DISJOINT-val">SIGMA_ALGEBRA_ALT_DISJOINT</a> : thm
<a name="line110"></a>    val <a href="#SIGMA_ALGEBRA_ALT_MONO-val">SIGMA_ALGEBRA_ALT_MONO</a> : thm
<a name="line111"></a>    val <a href="#SIGMA_ALGEBRA_ALT_SPACE-val">SIGMA_ALGEBRA_ALT_SPACE</a> : thm
<a name="line112"></a>    val <a href="#SIGMA_ALGEBRA_COMPL-val">SIGMA_ALGEBRA_COMPL</a> : thm
<a name="line113"></a>    val <a href="#SIGMA_ALGEBRA_COUNTABLE_INT-val">SIGMA_ALGEBRA_COUNTABLE_INT</a> : thm
<a name="line114"></a>    val <a href="#SIGMA_ALGEBRA_COUNTABLE_INT'-val">SIGMA_ALGEBRA_COUNTABLE_INT'</a> : thm
<a name="line115"></a>    val <a href="#SIGMA_ALGEBRA_COUNTABLE_UN-val">SIGMA_ALGEBRA_COUNTABLE_UN</a> : thm
<a name="line116"></a>    val <a href="#SIGMA_ALGEBRA_COUNTABLE_UN'-val">SIGMA_ALGEBRA_COUNTABLE_UN'</a> : thm
<a name="line117"></a>    val <a href="#SIGMA_ALGEBRA_COUNTABLE_UNION-val">SIGMA_ALGEBRA_COUNTABLE_UNION</a> : thm
<a name="line118"></a>    val <a href="#SIGMA_ALGEBRA_DIFF-val">SIGMA_ALGEBRA_DIFF</a> : thm
<a name="line119"></a>    val <a href="#SIGMA_ALGEBRA_EMPTY-val">SIGMA_ALGEBRA_EMPTY</a> : thm
<a name="line120"></a>    val <a href="#SIGMA_ALGEBRA_ENUM-val">SIGMA_ALGEBRA_ENUM</a> : thm
<a name="line121"></a>    val <a href="#SIGMA_ALGEBRA_FN-val">SIGMA_ALGEBRA_FN</a> : thm
<a name="line122"></a>    val <a href="#SIGMA_ALGEBRA_FN_BIGINTER-val">SIGMA_ALGEBRA_FN_BIGINTER</a> : thm
<a name="line123"></a>    val <a href="#SIGMA_ALGEBRA_FN_DISJOINT-val">SIGMA_ALGEBRA_FN_DISJOINT</a> : thm
<a name="line124"></a>    val <a href="#SIGMA_ALGEBRA_IMP_DYNKIN_SYSTEM-val">SIGMA_ALGEBRA_IMP_DYNKIN_SYSTEM</a> : thm
<a name="line125"></a>    val <a href="#SIGMA_ALGEBRA_INTER-val">SIGMA_ALGEBRA_INTER</a> : thm
<a name="line126"></a>    val <a href="#SIGMA_ALGEBRA_PROD_SIGMA-val">SIGMA_ALGEBRA_PROD_SIGMA</a> : thm
<a name="line127"></a>    val <a href="#SIGMA_ALGEBRA_PROD_SIGMA'-val">SIGMA_ALGEBRA_PROD_SIGMA'</a> : thm
<a name="line128"></a>    val <a href="#SIGMA_ALGEBRA_RESTRICT-val">SIGMA_ALGEBRA_RESTRICT</a> : thm
<a name="line129"></a>    val <a href="#SIGMA_ALGEBRA_RESTRICT_SUBSET-val">SIGMA_ALGEBRA_RESTRICT_SUBSET</a> : thm
<a name="line130"></a>    val <a href="#SIGMA_ALGEBRA_SIGMA-val">SIGMA_ALGEBRA_SIGMA</a> : thm
<a name="line131"></a>    val <a href="#SIGMA_ALGEBRA_SPACE-val">SIGMA_ALGEBRA_SPACE</a> : thm
<a name="line132"></a>    val <a href="#SIGMA_ALGEBRA_UNION-val">SIGMA_ALGEBRA_UNION</a> : thm
<a name="line133"></a>    val <a href="#SIGMA_CONG-val">SIGMA_CONG</a> : thm
<a name="line134"></a>    val <a href="#SIGMA_MEASURABLE-val">SIGMA_MEASURABLE</a> : thm
<a name="line135"></a>    val <a href="#SIGMA_MONOTONE-val">SIGMA_MONOTONE</a> : thm
<a name="line136"></a>    val <a href="#SIGMA_POW-val">SIGMA_POW</a> : thm
<a name="line137"></a>    val <a href="#SIGMA_PROPERTY-val">SIGMA_PROPERTY</a> : thm
<a name="line138"></a>    val <a href="#SIGMA_PROPERTY_ALT-val">SIGMA_PROPERTY_ALT</a> : thm
<a name="line139"></a>    val <a href="#SIGMA_PROPERTY_DISJOINT-val">SIGMA_PROPERTY_DISJOINT</a> : thm
<a name="line140"></a>    val <a href="#SIGMA_PROPERTY_DISJOINT_LEMMA-val">SIGMA_PROPERTY_DISJOINT_LEMMA</a> : thm
<a name="line141"></a>    val <a href="#SIGMA_PROPERTY_DISJOINT_LEMMA1-val">SIGMA_PROPERTY_DISJOINT_LEMMA1</a> : thm
<a name="line142"></a>    val <a href="#SIGMA_PROPERTY_DISJOINT_LEMMA2-val">SIGMA_PROPERTY_DISJOINT_LEMMA2</a> : thm
<a name="line143"></a>    val <a href="#SIGMA_PROPERTY_DISJOINT_WEAK-val">SIGMA_PROPERTY_DISJOINT_WEAK</a> : thm
<a name="line144"></a>    val <a href="#SIGMA_PROPERTY_DISJOINT_WEAK_ALT-val">SIGMA_PROPERTY_DISJOINT_WEAK_ALT</a> : thm
<a name="line145"></a>    val <a href="#SIGMA_REDUCE-val">SIGMA_REDUCE</a> : thm
<a name="line146"></a>    val <a href="#SIGMA_SIMULTANEOUSLY_MEASURABLE-val">SIGMA_SIMULTANEOUSLY_MEASURABLE</a> : thm
<a name="line147"></a>    val <a href="#SIGMA_SMALLEST-val">SIGMA_SMALLEST</a> : thm
<a name="line148"></a>    val <a href="#SIGMA_STABLE-val">SIGMA_STABLE</a> : thm
<a name="line149"></a>    val <a href="#SIGMA_STABLE_LEMMA-val">SIGMA_STABLE_LEMMA</a> : thm
<a name="line150"></a>    val <a href="#SIGMA_SUBSET-val">SIGMA_SUBSET</a> : thm
<a name="line151"></a>    val <a href="#SIGMA_SUBSET_SUBSETS-val">SIGMA_SUBSET_SUBSETS</a> : thm
<a name="line152"></a>    val <a href="#SMALLEST_RING-val">SMALLEST_RING</a> : thm
<a name="line153"></a>    val <a href="#SMALLEST_RING_OF_SEMIRING-val">SMALLEST_RING_OF_SEMIRING</a> : thm
<a name="line154"></a>    val <a href="#SMALLEST_RING_SUBSET_SUBSETS-val">SMALLEST_RING_SUBSET_SUBSETS</a> : thm
<a name="line155"></a>    val <a href="#SPACE-val">SPACE</a> : thm
<a name="line156"></a>    val <a href="#SPACE_DYNKIN-val">SPACE_DYNKIN</a> : thm
<a name="line157"></a>    val <a href="#SPACE_PROD_SIGMA-val">SPACE_PROD_SIGMA</a> : thm
<a name="line158"></a>    val <a href="#SPACE_SIGMA-val">SPACE_SIGMA</a> : thm
<a name="line159"></a>    val <a href="#SPACE_SMALLEST_RING-val">SPACE_SMALLEST_RING</a> : thm
<a name="line160"></a>    val <a href="#UNIV_SIGMA_ALGEBRA-val">UNIV_SIGMA_ALGEBRA</a> : thm
<a name="line161"></a>    val <a href="#algebra_alt-val">algebra_alt</a> : thm
<a name="line162"></a>    val <a href="#algebra_alt_inter-val">algebra_alt_inter</a> : thm
<a name="line163"></a>    val <a href="#algebra_alt_union-val">algebra_alt_union</a> : thm
<a name="line164"></a>    val <a href="#prod_sigma_alt_sigma_functions-val">prod_sigma_alt_sigma_functions</a> : thm
<a name="line165"></a>    val <a href="#ring_alt-val">ring_alt</a> : thm
<a name="line166"></a>    val <a href="#ring_alt_pow-val">ring_alt_pow</a> : thm
<a name="line167"></a>    val <a href="#ring_alt_pow_imp-val">ring_alt_pow_imp</a> : thm
<a name="line168"></a>    val <a href="#ring_and_semiring-val">ring_and_semiring</a> : thm
<a name="line169"></a>    val <a href="#ring_disjointed_sets-val">ring_disjointed_sets</a> : thm
<a name="line170"></a>    val <a href="#semiring_alt-val">semiring_alt</a> : thm
<a name="line171"></a>    val <a href="#sigma_algebra_alt-val">sigma_algebra_alt</a> : thm
<a name="line172"></a>    val <a href="#sigma_algebra_alt_pow-val">sigma_algebra_alt_pow</a> : thm
<a name="line173"></a>    val <a href="#sigma_algebra_sigma_sets-val">sigma_algebra_sigma_sets</a> : thm
<a name="line174"></a>    val <a href="#sigma_sets_BIGINTER-val">sigma_sets_BIGINTER</a> : thm
<a name="line175"></a>    val <a href="#sigma_sets_BIGINTER2-val">sigma_sets_BIGINTER2</a> : thm
<a name="line176"></a>    val <a href="#sigma_sets_BIGUNION-val">sigma_sets_BIGUNION</a> : thm
<a name="line177"></a>    val <a href="#sigma_sets_basic-val">sigma_sets_basic</a> : thm
<a name="line178"></a>    val <a href="#sigma_sets_cases-val">sigma_sets_cases</a> : thm
<a name="line179"></a>    val <a href="#sigma_sets_compl-val">sigma_sets_compl</a> : thm
<a name="line180"></a>    val <a href="#sigma_sets_empty-val">sigma_sets_empty</a> : thm
<a name="line181"></a>    val <a href="#sigma_sets_fixpoint-val">sigma_sets_fixpoint</a> : thm
<a name="line182"></a>    val <a href="#sigma_sets_ind-val">sigma_sets_ind</a> : thm
<a name="line183"></a>    val <a href="#sigma_sets_into_sp-val">sigma_sets_into_sp</a> : thm
<a name="line184"></a>    val <a href="#sigma_sets_least_sigma_algebra-val">sigma_sets_least_sigma_algebra</a> : thm
<a name="line185"></a>    val <a href="#sigma_sets_rules-val">sigma_sets_rules</a> : thm
<a name="line186"></a>    val <a href="#sigma_sets_strongind-val">sigma_sets_strongind</a> : thm
<a name="line187"></a>    val <a href="#sigma_sets_subset-val">sigma_sets_subset</a> : thm
<a name="line188"></a>    val <a href="#sigma_sets_superset_generator-val">sigma_sets_superset_generator</a> : thm
<a name="line189"></a>    val <a href="#sigma_sets_top-val">sigma_sets_top</a> : thm
<a name="line190"></a>    val <a href="#sigma_sets_union-val">sigma_sets_union</a> : thm
<a name="line191"></a>    val <a href="#subset_class_POW-val">subset_class_POW</a> : thm
<a name="line192"></a>  
<a name="line193"></a>  val sigma_algebra_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line194"></a>(*
   [util_prob] Parent theory of "sigma_algebra"
   
   [<a name="algebra_def-val"><b>algebra_def</b></a>]  Definition
      
      ⊢ ∀a. algebra a ⇔
            subset_class (space a) (subsets a) ∧ ∅ ∈ subsets a ∧
            (∀s. s ∈ subsets a ⇒ space a DIFF s ∈ subsets a) ∧
            ∀s t. s ∈ subsets a ∧ t ∈ subsets a ⇒ s ∪ t ∈ subsets a
   
   [<a name="dynkin_def-val"><b>dynkin_def</b></a>]  Definition
      
      ⊢ ∀sp sts.
          dynkin sp sts =
          (sp,BIGINTER {d | sts ⊆ d ∧ dynkin_system (sp,d)})
   
   [<a name="dynkin_system_def-val"><b>dynkin_system_def</b></a>]  Definition
      
      ⊢ ∀d. dynkin_system d ⇔
            subset_class (space d) (subsets d) ∧ space d ∈ subsets d ∧
            (∀s. s ∈ subsets d ⇒ space d DIFF s ∈ subsets d) ∧
            ∀f. f ∈ (𝕌(:num) → subsets d) ∧
                (∀i j. i ≠ j ⇒ DISJOINT (f i) (f j)) ⇒
                BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets d
   
   [<a name="measurable_def-val"><b>measurable_def</b></a>]  Definition
      
      ⊢ ∀a b.
          measurable a b =
          {f |
           sigma_algebra a ∧ sigma_algebra b ∧ f ∈ (space a → space b) ∧
           ∀s. s ∈ subsets b ⇒ PREIMAGE f s ∩ space a ∈ subsets a}
   
   [<a name="prod_sigma_def-val"><b>prod_sigma_def</b></a>]  Definition
      
      ⊢ ∀a b.
          a × b =
          sigma (space a × space b) (prod_sets (subsets a) (subsets b))
   
   [<a name="ring_def-val"><b>ring_def</b></a>]  Definition
      
      ⊢ ∀r. ring r ⇔
            subset_class (space r) (subsets r) ∧ ∅ ∈ subsets r ∧
            (∀s t. s ∈ subsets r ∧ t ∈ subsets r ⇒ s ∪ t ∈ subsets r) ∧
            ∀s t. s ∈ subsets r ∧ t ∈ subsets r ⇒ s DIFF t ∈ subsets r
   
   [<a name="semiring_def-val"><b>semiring_def</b></a>]  Definition
      
      ⊢ ∀r. semiring r ⇔
            subset_class (space r) (subsets r) ∧ ∅ ∈ subsets r ∧
            (∀s t. s ∈ subsets r ∧ t ∈ subsets r ⇒ s ∩ t ∈ subsets r) ∧
            ∀s t.
              s ∈ subsets r ∧ t ∈ subsets r ⇒
              ∃c. c ⊆ subsets r ∧ FINITE c ∧ disjoint c ∧
                  s DIFF t = BIGUNION c
   
   [<a name="sigma_algebra_def-val"><b>sigma_algebra_def</b></a>]  Definition
      
      ⊢ ∀a. sigma_algebra a ⇔
            algebra a ∧
            ∀c. countable c ∧ c ⊆ subsets a ⇒ BIGUNION c ∈ subsets a
   
   [<a name="sigma_def-val"><b>sigma_def</b></a>]  Definition
      
      ⊢ ∀sp sts.
          sigma sp sts = (sp,BIGINTER {s | sts ⊆ s ∧ sigma_algebra (sp,s)})
   
   [<a name="sigma_function_def-val"><b>sigma_function_def</b></a>]  Definition
      
      ⊢ ∀sp A f.
          sigma sp A f = (sp,IMAGE (λs. PREIMAGE f s ∩ sp) (subsets A))
   
   [<a name="sigma_functions_def-val"><b>sigma_functions_def</b></a>]  Definition
      
      ⊢ ∀sp A f J.
          sigma sp A f J =
          sigma sp
            (BIGUNION
               (IMAGE
                  (λi. IMAGE (λs. PREIMAGE (f i) s ∩ sp) (subsets (A i))) J))
   
   [<a name="sigma_sets_def-val"><b>sigma_sets_def</b></a>]  Definition
      
      ⊢ sigma_sets =
        (λsp st a0.
             ∀sigma_sets'.
               (∀a0.
                  a0 = ∅ ∨ st a0 ∨ (∃a. a0 = sp DIFF a ∧ sigma_sets' a) ∨
                  (∃A. a0 = BIGUNION {A i | i ∈ 𝕌(:num)} ∧
                       ∀i. sigma_sets' (A i)) ⇒
                  sigma_sets' a0) ⇒
               sigma_sets' a0)
   
   [<a name="smallest_ring_def-val"><b>smallest_ring_def</b></a>]  Definition
      
      ⊢ ∀sp sts.
          smallest_ring sp sts = (sp,BIGINTER {s | sts ⊆ s ∧ ring (sp,s)})
   
   [<a name="space_def-val"><b>space_def</b></a>]  Definition
      
      ⊢ ∀x y. space (x,y) = x
   
   [<a name="subset_class_def-val"><b>subset_class_def</b></a>]  Definition
      
      ⊢ ∀sp sts. subset_class sp sts ⇔ ∀x. x ∈ sts ⇒ x ⊆ sp
   
   [<a name="subsets_def-val"><b>subsets_def</b></a>]  Definition
      
      ⊢ ∀x y. subsets (x,y) = y
   
   [<a name="ALGEBRA_ALT_INTER-val"><b>ALGEBRA_ALT_INTER</b></a>]  Theorem
      
      ⊢ ∀a. algebra a ⇔
            subset_class (space a) (subsets a) ∧ ∅ ∈ subsets a ∧
            (∀s. s ∈ subsets a ⇒ space a DIFF s ∈ subsets a) ∧
            ∀s t. s ∈ subsets a ∧ t ∈ subsets a ⇒ s ∩ t ∈ subsets a
   
   [<a name="ALGEBRA_COMPL-val"><b>ALGEBRA_COMPL</b></a>]  Theorem
      
      ⊢ ∀a s. algebra a ∧ s ∈ subsets a ⇒ space a DIFF s ∈ subsets a
   
   [<a name="ALGEBRA_COMPL_SETS-val"><b>ALGEBRA_COMPL_SETS</b></a>]  Theorem
      
      ⊢ ∀sp sts a. algebra (sp,sts) ∧ a ∈ sts ⇒ sp DIFF a ∈ sts
   
   [<a name="ALGEBRA_DIFF-val"><b>ALGEBRA_DIFF</b></a>]  Theorem
      
      ⊢ ∀a s t.
          algebra a ∧ s ∈ subsets a ∧ t ∈ subsets a ⇒ s DIFF t ∈ subsets a
   
   [<a name="ALGEBRA_EMPTY-val"><b>ALGEBRA_EMPTY</b></a>]  Theorem
      
      ⊢ ∀a. algebra a ⇒ ∅ ∈ subsets a
   
   [<a name="ALGEBRA_FINITE_UNION-val"><b>ALGEBRA_FINITE_UNION</b></a>]  Theorem
      
      ⊢ ∀a c. algebra a ∧ FINITE c ∧ c ⊆ subsets a ⇒ BIGUNION c ∈ subsets a
   
   [<a name="ALGEBRA_IMP_RING-val"><b>ALGEBRA_IMP_RING</b></a>]  Theorem
      
      ⊢ ∀a. algebra a ⇒ ring a
   
   [<a name="ALGEBRA_IMP_SEMIRING-val"><b>ALGEBRA_IMP_SEMIRING</b></a>]  Theorem
      
      ⊢ ∀a. algebra a ⇒ semiring a
   
   [<a name="ALGEBRA_INTER-val"><b>ALGEBRA_INTER</b></a>]  Theorem
      
      ⊢ ∀a s t.
          algebra a ∧ s ∈ subsets a ∧ t ∈ subsets a ⇒ s ∩ t ∈ subsets a
   
   [<a name="ALGEBRA_INTER_SPACE-val"><b>ALGEBRA_INTER_SPACE</b></a>]  Theorem
      
      ⊢ ∀a s. algebra a ∧ s ∈ subsets a ⇒ space a ∩ s = s ∧ s ∩ space a = s
   
   [<a name="ALGEBRA_RESTRICT-val"><b>ALGEBRA_RESTRICT</b></a>]  Theorem
      
      ⊢ ∀sp sts a.
          algebra (sp,sts) ∧ a ∈ sts ⇒ algebra (a,IMAGE (λs. s ∩ a) sts)
   
   [<a name="ALGEBRA_SETS_COLLECT_CONST-val"><b>ALGEBRA_SETS_COLLECT_CONST</b></a>]  Theorem
      
      ⊢ ∀sp sts P. algebra (sp,sts) ⇒ {x | x ∈ sp ∧ P} ∈ sts
   
   [<a name="ALGEBRA_SETS_COLLECT_IMP-val"><b>ALGEBRA_SETS_COLLECT_IMP</b></a>]  Theorem
      
      ⊢ ∀sp sts P Q.
          algebra (sp,sts) ∧ {x | x ∈ sp ∧ P x} ∈ sts ⇒
          {x | x ∈ sp ∧ Q x} ∈ sts ⇒
          {x | x ∈ sp ∧ (Q x ⇒ P x)} ∈ sts
   
   [<a name="ALGEBRA_SETS_COLLECT_NEG-val"><b>ALGEBRA_SETS_COLLECT_NEG</b></a>]  Theorem
      
      ⊢ ∀sp sts P.
          algebra (sp,sts) ∧ {x | x ∈ sp ∧ P x} ∈ sts ⇒
          {x | x ∈ sp ∧ ¬P x} ∈ sts
   
   [<a name="ALGEBRA_SINGLE_SET-val"><b>ALGEBRA_SINGLE_SET</b></a>]  Theorem
      
      ⊢ ∀X S. X ⊆ S ⇒ algebra (S,{∅; X; S DIFF X; S})
   
   [<a name="ALGEBRA_SPACE-val"><b>ALGEBRA_SPACE</b></a>]  Theorem
      
      ⊢ ∀a. algebra a ⇒ space a ∈ subsets a
   
   [<a name="ALGEBRA_UNION-val"><b>ALGEBRA_UNION</b></a>]  Theorem
      
      ⊢ ∀a s t.
          algebra a ∧ s ∈ subsets a ∧ t ∈ subsets a ⇒ s ∪ t ∈ subsets a
   
   [<a name="DYNKIN-val"><b>DYNKIN</b></a>]  Theorem
      
      ⊢ ∀sp sts.
          subset_class sp sts ⇒
          sts ⊆ subsets (dynkin sp sts) ∧ dynkin_system (dynkin sp sts) ∧
          subset_class sp (subsets (dynkin sp sts))
   
   [<a name="DYNKIN_LEMMA-val"><b>DYNKIN_LEMMA</b></a>]  Theorem
      
      ⊢ ∀d. dynkin_system d ∧
            (∀s t. s ∈ subsets d ∧ t ∈ subsets d ⇒ s ∩ t ∈ subsets d) ⇔
            sigma_algebra d
   
   [<a name="DYNKIN_MONOTONE-val"><b>DYNKIN_MONOTONE</b></a>]  Theorem
      
      ⊢ ∀sp a b. a ⊆ b ⇒ subsets (dynkin sp a) ⊆ subsets (dynkin sp b)
   
   [<a name="DYNKIN_SMALLEST-val"><b>DYNKIN_SMALLEST</b></a>]  Theorem
      
      ⊢ ∀sp sts D.
          sts ⊆ D ∧ D ⊆ subsets (dynkin sp sts) ∧ dynkin_system (sp,D) ⇒
          D = subsets (dynkin sp sts)
   
   [<a name="DYNKIN_STABLE-val"><b>DYNKIN_STABLE</b></a>]  Theorem
      
      ⊢ ∀d. dynkin_system d ⇒ dynkin (space d) (subsets d) = d
   
   [<a name="DYNKIN_STABLE_LEMMA-val"><b>DYNKIN_STABLE_LEMMA</b></a>]  Theorem
      
      ⊢ ∀sp sts. dynkin_system (sp,sts) ⇒ dynkin sp sts = (sp,sts)
   
   [<a name="DYNKIN_SUBSET-val"><b>DYNKIN_SUBSET</b></a>]  Theorem
      
      ⊢ ∀a b.
          dynkin_system b ∧ a ⊆ subsets b ⇒
          subsets (dynkin (space b) a) ⊆ subsets b
   
   [<a name="DYNKIN_SUBSET_SIGMA-val"><b>DYNKIN_SUBSET_SIGMA</b></a>]  Theorem
      
      ⊢ ∀sp sts.
          subset_class sp sts ⇒
          subsets (dynkin sp sts) ⊆ subsets (sigma sp sts)
   
   [<a name="DYNKIN_SUBSET_SUBSETS-val"><b>DYNKIN_SUBSET_SUBSETS</b></a>]  Theorem
      
      ⊢ ∀sp a. a ⊆ subsets (dynkin sp a)
   
   [<a name="DYNKIN_SYSTEM_ALT-val"><b>DYNKIN_SYSTEM_ALT</b></a>]  Theorem
      
      ⊢ ∀d. dynkin_system d ⇔
            subset_class (space d) (subsets d) ∧ space d ∈ subsets d ∧
            (∀s. s ∈ subsets d ⇒ space d DIFF s ∈ subsets d) ∧
            (∀f. f ∈ (𝕌(:num) → subsets d) ∧ f 0 = ∅ ∧
                 (∀n. f n ⊆ f (SUC n)) ⇒
                 BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets d) ∧
            ∀f. f ∈ (𝕌(:num) → subsets d) ∧
                (∀i j. i ≠ j ⇒ DISJOINT (f i) (f j)) ⇒
                BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets d
   
   [<a name="DYNKIN_SYSTEM_ALT_MONO-val"><b>DYNKIN_SYSTEM_ALT_MONO</b></a>]  Theorem
      
      ⊢ ∀d. dynkin_system d ⇔
            subset_class (space d) (subsets d) ∧ space d ∈ subsets d ∧
            (∀s t.
               s ∈ subsets d ∧ t ∈ subsets d ∧ s ⊆ t ⇒ t DIFF s ∈ subsets d) ∧
            ∀f. f ∈ (𝕌(:num) → subsets d) ∧ f 0 = ∅ ∧ (∀n. f n ⊆ f (SUC n)) ⇒
                BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets d
   
   [<a name="DYNKIN_SYSTEM_COMPL-val"><b>DYNKIN_SYSTEM_COMPL</b></a>]  Theorem
      
      ⊢ ∀d s. dynkin_system d ∧ s ∈ subsets d ⇒ space d DIFF s ∈ subsets d
   
   [<a name="DYNKIN_SYSTEM_COUNTABLY_DUNION-val"><b>DYNKIN_SYSTEM_COUNTABLY_DUNION</b></a>]  Theorem
      
      ⊢ ∀d f.
          dynkin_system d ∧ f ∈ (𝕌(:num) → subsets d) ∧
          (∀i j. i ≠ j ⇒ DISJOINT (f i) (f j)) ⇒
          BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets d
   
   [<a name="DYNKIN_SYSTEM_DUNION-val"><b>DYNKIN_SYSTEM_DUNION</b></a>]  Theorem
      
      ⊢ ∀d s t.
          dynkin_system d ∧ s ∈ subsets d ∧ t ∈ subsets d ∧ DISJOINT s t ⇒
          s ∪ t ∈ subsets d
   
   [<a name="DYNKIN_SYSTEM_EMPTY-val"><b>DYNKIN_SYSTEM_EMPTY</b></a>]  Theorem
      
      ⊢ ∀d. dynkin_system d ⇒ ∅ ∈ subsets d
   
   [<a name="DYNKIN_SYSTEM_INCREASING-val"><b>DYNKIN_SYSTEM_INCREASING</b></a>]  Theorem
      
      ⊢ ∀p f.
          dynkin_system p ∧ f ∈ (𝕌(:num) → subsets p) ∧ f 0 = ∅ ∧
          (∀n. f n ⊆ f (SUC n)) ⇒
          BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets p
   
   [<a name="DYNKIN_SYSTEM_SPACE-val"><b>DYNKIN_SYSTEM_SPACE</b></a>]  Theorem
      
      ⊢ ∀d. dynkin_system d ⇒ space d ∈ subsets d
   
   [<a name="DYNKIN_THM-val"><b>DYNKIN_THM</b></a>]  Theorem
      
      ⊢ ∀sp sts.
          subset_class sp sts ∧ (∀s t. s ∈ sts ∧ t ∈ sts ⇒ s ∩ t ∈ sts) ⇒
          dynkin sp sts = sigma sp sts
   
   [<a name="INTER_SPACE_EQ1-val"><b>INTER_SPACE_EQ1</b></a>]  Theorem
      
      ⊢ ∀sp sts. subset_class sp sts ⇒ ∀x. x ∈ sts ⇒ sp ∩ x = x
   
   [<a name="INTER_SPACE_REDUCE-val"><b>INTER_SPACE_REDUCE</b></a>]  Theorem
      
      ⊢ ∀sp sts. subset_class sp sts ⇒ ∀x. x ∈ sts ⇒ x ∩ sp = x
   
   [<a name="IN_DYNKIN-val"><b>IN_DYNKIN</b></a>]  Theorem
      
      ⊢ ∀sp a x. x ∈ a ⇒ x ∈ subsets (dynkin sp a)
   
   [<a name="IN_MEASURABLE-val"><b>IN_MEASURABLE</b></a>]  Theorem
      
      ⊢ ∀a b f.
          f ∈ measurable a b ⇔
          sigma_algebra a ∧ sigma_algebra b ∧ f ∈ (space a → space b) ∧
          ∀s. s ∈ subsets b ⇒ PREIMAGE f s ∩ space a ∈ subsets a
   
   [<a name="IN_SIGMA-val"><b>IN_SIGMA</b></a>]  Theorem
      
      ⊢ ∀sp a x. x ∈ a ⇒ x ∈ subsets (sigma sp a)
   
   [<a name="MEASUBABLE_BIGUNION_LEMMA-val"><b>MEASUBABLE_BIGUNION_LEMMA</b></a>]  Theorem
      
      ⊢ ∀a b f.
          sigma_algebra a ∧ sigma_algebra b ∧ f ∈ (space a → space b) ∧
          (∀s. s ∈ subsets b ⇒ PREIMAGE f s ∈ subsets a) ⇒
          ∀c. countable c ∧ c ⊆ IMAGE (PREIMAGE f) (subsets b) ⇒
              BIGUNION c ∈ IMAGE (PREIMAGE f) (subsets b)
   
   [<a name="MEASURABLE_BIGUNION_PROPERTY-val"><b>MEASURABLE_BIGUNION_PROPERTY</b></a>]  Theorem
      
      ⊢ ∀a b f.
          sigma_algebra a ∧ sigma_algebra b ∧ f ∈ (space a → space b) ∧
          (∀s. s ∈ subsets b ⇒ PREIMAGE f s ∈ subsets a) ⇒
          ∀c. c ⊆ subsets b ⇒
              PREIMAGE f (BIGUNION c) = BIGUNION (IMAGE (PREIMAGE f) c)
   
   [<a name="MEASURABLE_COMP-val"><b>MEASURABLE_COMP</b></a>]  Theorem
      
      ⊢ ∀f g a b c.
          f ∈ measurable a b ∧ g ∈ measurable b c ⇒ g ∘ f ∈ measurable a c
   
   [<a name="MEASURABLE_COMP_STRONG-val"><b>MEASURABLE_COMP_STRONG</b></a>]  Theorem
      
      ⊢ ∀f g a b c.
          f ∈ measurable a b ∧ sigma_algebra c ∧ g ∈ (space b → space c) ∧
          (∀x. x ∈ subsets c ⇒ PREIMAGE g x ∩ IMAGE f (space a) ∈ subsets b) ⇒
          g ∘ f ∈ measurable a c
   
   [<a name="MEASURABLE_COMP_STRONGER-val"><b>MEASURABLE_COMP_STRONGER</b></a>]  Theorem
      
      ⊢ ∀f g a b c t.
          f ∈ measurable a b ∧ sigma_algebra c ∧ g ∈ (space b → space c) ∧
          IMAGE f (space a) ⊆ t ∧
          (∀s. s ∈ subsets c ⇒ PREIMAGE g s ∩ t ∈ subsets b) ⇒
          g ∘ f ∈ measurable a c
   
   [<a name="MEASURABLE_DIFF_PROPERTY-val"><b>MEASURABLE_DIFF_PROPERTY</b></a>]  Theorem
      
      ⊢ ∀a b f.
          sigma_algebra a ∧ sigma_algebra b ∧ f ∈ (space a → space b) ∧
          (∀s. s ∈ subsets b ⇒ PREIMAGE f s ∈ subsets a) ⇒
          ∀s. s ∈ subsets b ⇒
              PREIMAGE f (space b DIFF s) = space a DIFF PREIMAGE f s
   
   [<a name="MEASURABLE_I-val"><b>MEASURABLE_I</b></a>]  Theorem
      
      ⊢ ∀a. sigma_algebra a ⇒ I ∈ measurable a a
   
   [<a name="MEASURABLE_LIFT-val"><b>MEASURABLE_LIFT</b></a>]  Theorem
      
      ⊢ ∀f a b.
          f ∈ measurable a b ⇒
          f ∈ measurable a (sigma (space b) (subsets b))
   
   [<a name="MEASURABLE_PROD_SIGMA-val"><b>MEASURABLE_PROD_SIGMA</b></a>]  Theorem
      
      ⊢ ∀a a1 a2 f.
          sigma_algebra a ∧ FST ∘ f ∈ measurable a a1 ∧
          SND ∘ f ∈ measurable a a2 ⇒
          f ∈
          measurable a
            (sigma (space a1 × space a2)
               (prod_sets (subsets a1) (subsets a2)))
   
   [<a name="MEASURABLE_PROD_SIGMA'-val"><b>MEASURABLE_PROD_SIGMA'</b></a>]  Theorem
      
      ⊢ ∀a a1 a2 f.
          sigma_algebra a ∧ FST ∘ f ∈ measurable a a1 ∧
          SND ∘ f ∈ measurable a a2 ⇒
          f ∈ measurable a (a1 × a2)
   
   [<a name="MEASURABLE_SIGMA-val"><b>MEASURABLE_SIGMA</b></a>]  Theorem
      
      ⊢ ∀f a b sp.
          sigma_algebra a ∧ subset_class sp b ∧ f ∈ (space a → sp) ∧
          (∀s. s ∈ b ⇒ PREIMAGE f s ∩ space a ∈ subsets a) ⇒
          f ∈ measurable a (sigma sp b)
   
   [<a name="MEASURABLE_SIGMA_PREIMAGES-val"><b>MEASURABLE_SIGMA_PREIMAGES</b></a>]  Theorem
      
      ⊢ ∀a b f.
          sigma_algebra a ∧ sigma_algebra b ∧ f ∈ (space a → space b) ∧
          (∀s. s ∈ subsets b ⇒ PREIMAGE f s ∈ subsets a) ⇒
          sigma_algebra (space a,IMAGE (PREIMAGE f) (subsets b))
   
   [<a name="MEASURABLE_SUBSET-val"><b>MEASURABLE_SUBSET</b></a>]  Theorem
      
      ⊢ ∀a b. measurable a b ⊆ measurable a (sigma (space b) (subsets b))
   
   [<a name="MEASURABLE_UP_LIFT-val"><b>MEASURABLE_UP_LIFT</b></a>]  Theorem
      
      ⊢ ∀sp a b c f.
          f ∈ measurable (sp,a) c ∧ sigma_algebra (sp,b) ∧ a ⊆ b ⇒
          f ∈ measurable (sp,b) c
   
   [<a name="MEASURABLE_UP_SIGMA-val"><b>MEASURABLE_UP_SIGMA</b></a>]  Theorem
      
      ⊢ ∀a b. measurable a b ⊆ measurable (sigma (space a) (subsets a)) b
   
   [<a name="MEASURABLE_UP_SUBSET-val"><b>MEASURABLE_UP_SUBSET</b></a>]  Theorem
      
      ⊢ ∀sp a b c.
          a ⊆ b ∧ sigma_algebra (sp,b) ⇒
          measurable (sp,a) c ⊆ measurable (sp,b) c
   
   [<a name="POW_ALGEBRA-val"><b>POW_ALGEBRA</b></a>]  Theorem
      
      ⊢ ∀sp. algebra (sp,POW sp)
   
   [<a name="POW_SIGMA_ALGEBRA-val"><b>POW_SIGMA_ALGEBRA</b></a>]  Theorem
      
      ⊢ ∀sp. sigma_algebra (sp,POW sp)
   
   [<a name="PREIMAGE_SIGMA-val"><b>PREIMAGE_SIGMA</b></a>]  Theorem
      
      ⊢ ∀Z sp sts f.
          subset_class sp sts ∧ f ∈ (Z → sp) ⇒
          IMAGE (λs. PREIMAGE f s ∩ Z) (subsets (sigma sp sts)) =
          subsets (sigma Z (IMAGE (λs. PREIMAGE f s ∩ Z) sts))
   
   [<a name="PREIMAGE_SIGMA_ALGEBRA-val"><b>PREIMAGE_SIGMA_ALGEBRA</b></a>]  Theorem
      
      ⊢ ∀sp A f.
          sigma_algebra A ∧ f ∈ (sp → space A) ⇒
          sigma_algebra (sp,IMAGE (λs. PREIMAGE f s ∩ sp) (subsets A))
   
   [<a name="RING_BIGUNION-val"><b>RING_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀sp sts A n.
          ring (sp,sts) ∧ IMAGE A 𝕌(:num) ⊆ sts ⇒
          BIGUNION {A i | i &lt; n} ∈ sts
   
   [<a name="RING_DIFF-val"><b>RING_DIFF</b></a>]  Theorem
      
      ⊢ ∀r s t.
          ring r ∧ s ∈ subsets r ∧ t ∈ subsets r ⇒ s DIFF t ∈ subsets r
   
   [<a name="RING_DIFF_ALT-val"><b>RING_DIFF_ALT</b></a>]  Theorem
      
      ⊢ ∀a b sp sts. ring (sp,sts) ∧ a ∈ sts ∧ b ∈ sts ⇒ a DIFF b ∈ sts
   
   [<a name="RING_EMPTY-val"><b>RING_EMPTY</b></a>]  Theorem
      
      ⊢ ∀r. ring r ⇒ ∅ ∈ subsets r
   
   [<a name="RING_FINITE_BIGUNION1-val"><b>RING_FINITE_BIGUNION1</b></a>]  Theorem
      
      ⊢ ∀X sp sts. ring (sp,sts) ∧ FINITE X ⇒ X ⊆ sts ⇒ BIGUNION X ∈ sts
   
   [<a name="RING_FINITE_BIGUNION2-val"><b>RING_FINITE_BIGUNION2</b></a>]  Theorem
      
      ⊢ ∀A N sp sts.
          ring (sp,sts) ∧ FINITE N ∧ (∀i. i ∈ N ⇒ A i ∈ sts) ⇒
          BIGUNION {A i | i ∈ N} ∈ sts
   
   [<a name="RING_FINITE_INTER-val"><b>RING_FINITE_INTER</b></a>]  Theorem
      
      ⊢ ∀r f n.
          ring r ∧ 0 &lt; n ∧ (∀i. i &lt; n ⇒ f i ∈ subsets r) ⇒
          BIGINTER (IMAGE f (count n)) ∈ subsets r
   
   [<a name="RING_FINITE_UNION-val"><b>RING_FINITE_UNION</b></a>]  Theorem
      
      ⊢ ∀r c. ring r ∧ c ⊆ subsets r ∧ FINITE c ⇒ BIGUNION c ∈ subsets r
   
   [<a name="RING_FINITE_UNION_ALT-val"><b>RING_FINITE_UNION_ALT</b></a>]  Theorem
      
      ⊢ ∀r f n.
          ring r ∧ (∀i. i &lt; n ⇒ f i ∈ subsets r) ⇒
          BIGUNION (IMAGE f (count n)) ∈ subsets r
   
   [<a name="RING_IMP_SEMIRING-val"><b>RING_IMP_SEMIRING</b></a>]  Theorem
      
      ⊢ ∀r. ring r ⇒ semiring r
   
   [<a name="RING_INSERT-val"><b>RING_INSERT</b></a>]  Theorem
      
      ⊢ ∀x A sp sts. ring (sp,sts) ∧ {x} ∈ sts ∧ A ∈ sts ⇒ x INSERT A ∈ sts
   
   [<a name="RING_INTER-val"><b>RING_INTER</b></a>]  Theorem
      
      ⊢ ∀r s t. ring r ∧ s ∈ subsets r ∧ t ∈ subsets r ⇒ s ∩ t ∈ subsets r
   
   [<a name="RING_SETS_COLLECT_FINITE-val"><b>RING_SETS_COLLECT_FINITE</b></a>]  Theorem
      
      ⊢ ∀sp sts s P.
          ring (sp,sts) ∧ (∀i. i ∈ s ⇒ {x | x ∈ sp ∧ P i x} ∈ sts) ∧
          FINITE s ⇒
          {x | x ∈ sp ∧ ∃i. i ∈ s ∧ P i x} ∈ sts
   
   [<a name="RING_SPACE_IMP_ALGEBRA-val"><b>RING_SPACE_IMP_ALGEBRA</b></a>]  Theorem
      
      ⊢ ∀r. ring r ∧ space r ∈ subsets r ⇒ algebra r
   
   [<a name="RING_UNION-val"><b>RING_UNION</b></a>]  Theorem
      
      ⊢ ∀r s t. ring r ∧ s ∈ subsets r ∧ t ∈ subsets r ⇒ s ∪ t ∈ subsets r
   
   [<a name="SEMIRING_DIFF-val"><b>SEMIRING_DIFF</b></a>]  Theorem
      
      ⊢ ∀r s t.
          semiring r ∧ s ∈ subsets r ∧ t ∈ subsets r ⇒
          ∃c. c ⊆ subsets r ∧ FINITE c ∧ disjoint c ∧ s DIFF t = BIGUNION c
   
   [<a name="SEMIRING_DIFF_ALT-val"><b>SEMIRING_DIFF_ALT</b></a>]  Theorem
      
      ⊢ ∀r s t.
          semiring r ∧ s ∈ subsets r ∧ t ∈ subsets r ⇒
          ∃f n.
            (∀i. i &lt; n ⇒ f i ∈ subsets r) ∧
            (∀i j. i &lt; n ∧ j &lt; n ∧ i ≠ j ⇒ DISJOINT (f i) (f j)) ∧
            s DIFF t = BIGUNION (IMAGE f (count n))
   
   [<a name="SEMIRING_EMPTY-val"><b>SEMIRING_EMPTY</b></a>]  Theorem
      
      ⊢ ∀r. semiring r ⇒ ∅ ∈ subsets r
   
   [<a name="SEMIRING_INTER-val"><b>SEMIRING_INTER</b></a>]  Theorem
      
      ⊢ ∀r s t.
          semiring r ∧ s ∈ subsets r ∧ t ∈ subsets r ⇒ s ∩ t ∈ subsets r
   
   [<a name="SEMIRING_PROD_SETS-val"><b>SEMIRING_PROD_SETS</b></a>]  Theorem
      
      ⊢ ∀a b.
          semiring a ∧ semiring b ⇒
          semiring (space a × space b,prod_sets (subsets a) (subsets b))
   
   [<a name="SEMIRING_PROD_SETS'-val"><b>SEMIRING_PROD_SETS'</b></a>]  Theorem
      
      ⊢ ∀a b.
          sigma_algebra a ∧ sigma_algebra b ⇒
          semiring (space a × space b,prod_sets (subsets a) (subsets b))
   
   [<a name="SEMIRING_SETS_COLLECT-val"><b>SEMIRING_SETS_COLLECT</b></a>]  Theorem
      
      ⊢ ∀sp sts P Q.
          semiring (sp,sts) ∧ {x | x ∈ sp ∧ P x} ∈ sts ∧
          {x | x ∈ sp ∧ Q x} ∈ sts ⇒
          {x | x ∈ sp ∧ P x ∧ Q x} ∈ sts
   
   [<a name="SIGMA_ALGEBRA-val"><b>SIGMA_ALGEBRA</b></a>]  Theorem
      
      ⊢ ∀p. sigma_algebra p ⇔
            subset_class (space p) (subsets p) ∧ ∅ ∈ subsets p ∧
            (∀s. s ∈ subsets p ⇒ space p DIFF s ∈ subsets p) ∧
            ∀c. countable c ∧ c ⊆ subsets p ⇒ BIGUNION c ∈ subsets p
   
   [<a name="SIGMA_ALGEBRA_ALGEBRA-val"><b>SIGMA_ALGEBRA_ALGEBRA</b></a>]  Theorem
      
      ⊢ ∀a. sigma_algebra a ⇒ algebra a
   
   [<a name="SIGMA_ALGEBRA_ALT-val"><b>SIGMA_ALGEBRA_ALT</b></a>]  Theorem
      
      ⊢ ∀a. sigma_algebra a ⇔
            algebra a ∧
            ∀f. f ∈ (𝕌(:num) → subsets a) ⇒
                BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_ALT_DISJOINT-val"><b>SIGMA_ALGEBRA_ALT_DISJOINT</b></a>]  Theorem
      
      ⊢ ∀a. sigma_algebra a ⇔
            algebra a ∧
            ∀f. f ∈ (𝕌(:num) → subsets a) ∧
                (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ⇒
                BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_ALT_MONO-val"><b>SIGMA_ALGEBRA_ALT_MONO</b></a>]  Theorem
      
      ⊢ ∀a. sigma_algebra a ⇔
            algebra a ∧
            ∀f. f ∈ (𝕌(:num) → subsets a) ∧ f 0 = ∅ ∧ (∀n. f n ⊆ f (SUC n)) ⇒
                BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_ALT_SPACE-val"><b>SIGMA_ALGEBRA_ALT_SPACE</b></a>]  Theorem
      
      ⊢ ∀a. sigma_algebra a ⇔
            subset_class (space a) (subsets a) ∧ space a ∈ subsets a ∧
            (∀s. s ∈ subsets a ⇒ space a DIFF s ∈ subsets a) ∧
            ∀f. f ∈ (𝕌(:num) → subsets a) ⇒
                BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_COMPL-val"><b>SIGMA_ALGEBRA_COMPL</b></a>]  Theorem
      
      ⊢ ∀a s. sigma_algebra a ∧ s ∈ subsets a ⇒ space a DIFF s ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_COUNTABLE_INT-val"><b>SIGMA_ALGEBRA_COUNTABLE_INT</b></a>]  Theorem
      
      ⊢ ∀sp sts A X.
          sigma_algebra (sp,sts) ∧ IMAGE A X ⊆ sts ∧ X ≠ ∅ ⇒
          BIGINTER {A x | x ∈ X} ∈ sts
   
   [<a name="SIGMA_ALGEBRA_COUNTABLE_INT'-val"><b>SIGMA_ALGEBRA_COUNTABLE_INT'</b></a>]  Theorem
      
      ⊢ ∀sp sts A X.
          sigma_algebra (sp,sts) ∧ countable X ∧ X ≠ ∅ ∧ IMAGE A X ⊆ sts ⇒
          BIGINTER {A x | x ∈ X} ∈ sts
   
   [<a name="SIGMA_ALGEBRA_COUNTABLE_UN-val"><b>SIGMA_ALGEBRA_COUNTABLE_UN</b></a>]  Theorem
      
      ⊢ ∀sp sts A X.
          sigma_algebra (sp,sts) ∧ IMAGE A X ⊆ sts ⇒
          BIGUNION {A x | x ∈ X} ∈ sts
   
   [<a name="SIGMA_ALGEBRA_COUNTABLE_UN'-val"><b>SIGMA_ALGEBRA_COUNTABLE_UN'</b></a>]  Theorem
      
      ⊢ ∀sp sts A X.
          sigma_algebra (sp,sts) ∧ IMAGE A X ⊆ sts ∧ countable X ⇒
          BIGUNION {A x | x ∈ X} ∈ sts
   
   [<a name="SIGMA_ALGEBRA_COUNTABLE_UNION-val"><b>SIGMA_ALGEBRA_COUNTABLE_UNION</b></a>]  Theorem
      
      ⊢ ∀a c.
          sigma_algebra a ∧ countable c ∧ c ⊆ subsets a ⇒
          BIGUNION c ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_DIFF-val"><b>SIGMA_ALGEBRA_DIFF</b></a>]  Theorem
      
      ⊢ ∀a s t.
          sigma_algebra a ∧ s ∈ subsets a ∧ t ∈ subsets a ⇒
          s DIFF t ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_EMPTY-val"><b>SIGMA_ALGEBRA_EMPTY</b></a>]  Theorem
      
      ⊢ ∀a. sigma_algebra a ⇒ ∅ ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_ENUM-val"><b>SIGMA_ALGEBRA_ENUM</b></a>]  Theorem
      
      ⊢ ∀a f.
          sigma_algebra a ∧ f ∈ (𝕌(:num) → subsets a) ⇒
          BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_FN-val"><b>SIGMA_ALGEBRA_FN</b></a>]  Theorem
      
      ⊢ ∀a. sigma_algebra a ⇔
            subset_class (space a) (subsets a) ∧ ∅ ∈ subsets a ∧
            (∀s. s ∈ subsets a ⇒ space a DIFF s ∈ subsets a) ∧
            ∀f. f ∈ (𝕌(:num) → subsets a) ⇒
                BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_FN_BIGINTER-val"><b>SIGMA_ALGEBRA_FN_BIGINTER</b></a>]  Theorem
      
      ⊢ ∀a. sigma_algebra a ⇒
            subset_class (space a) (subsets a) ∧ ∅ ∈ subsets a ∧
            (∀s. s ∈ subsets a ⇒ space a DIFF s ∈ subsets a) ∧
            ∀f. f ∈ (𝕌(:num) → subsets a) ⇒
                BIGINTER (IMAGE f 𝕌(:num)) ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_FN_DISJOINT-val"><b>SIGMA_ALGEBRA_FN_DISJOINT</b></a>]  Theorem
      
      ⊢ ∀a. sigma_algebra a ⇔
            subset_class (space a) (subsets a) ∧ ∅ ∈ subsets a ∧
            (∀s. s ∈ subsets a ⇒ space a DIFF s ∈ subsets a) ∧
            (∀s t. s ∈ subsets a ∧ t ∈ subsets a ⇒ s ∪ t ∈ subsets a) ∧
            ∀f. f ∈ (𝕌(:num) → subsets a) ∧
                (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ⇒
                BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_IMP_DYNKIN_SYSTEM-val"><b>SIGMA_ALGEBRA_IMP_DYNKIN_SYSTEM</b></a>]  Theorem
      
      ⊢ ∀a. sigma_algebra a ⇒ dynkin_system a
   
   [<a name="SIGMA_ALGEBRA_INTER-val"><b>SIGMA_ALGEBRA_INTER</b></a>]  Theorem
      
      ⊢ ∀a s t.
          sigma_algebra a ∧ s ∈ subsets a ∧ t ∈ subsets a ⇒
          s ∩ t ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_PROD_SIGMA-val"><b>SIGMA_ALGEBRA_PROD_SIGMA</b></a>]  Theorem
      
      ⊢ ∀a b.
          subset_class (space a) (subsets a) ∧
          subset_class (space b) (subsets b) ⇒
          sigma_algebra (a × b)
   
   [<a name="SIGMA_ALGEBRA_PROD_SIGMA'-val"><b>SIGMA_ALGEBRA_PROD_SIGMA'</b></a>]  Theorem
      
      ⊢ ∀X Y A B.
          subset_class X A ∧ subset_class Y B ⇒
          sigma_algebra ((X,A) × (Y,B))
   
   [<a name="SIGMA_ALGEBRA_RESTRICT-val"><b>SIGMA_ALGEBRA_RESTRICT</b></a>]  Theorem
      
      ⊢ ∀sp sts a.
          sigma_algebra (sp,sts) ∧ a ∈ sts ⇒
          sigma_algebra (a,IMAGE (λs. s ∩ a) sts)
   
   [<a name="SIGMA_ALGEBRA_RESTRICT_SUBSET-val"><b>SIGMA_ALGEBRA_RESTRICT_SUBSET</b></a>]  Theorem
      
      ⊢ ∀sp sts a.
          sigma_algebra (sp,sts) ∧ a ∈ sts ⇒ IMAGE (λs. s ∩ a) sts ⊆ sts
   
   [<a name="SIGMA_ALGEBRA_SIGMA-val"><b>SIGMA_ALGEBRA_SIGMA</b></a>]  Theorem
      
      ⊢ ∀sp sts. subset_class sp sts ⇒ sigma_algebra (sigma sp sts)
   
   [<a name="SIGMA_ALGEBRA_SPACE-val"><b>SIGMA_ALGEBRA_SPACE</b></a>]  Theorem
      
      ⊢ ∀a. sigma_algebra a ⇒ space a ∈ subsets a
   
   [<a name="SIGMA_ALGEBRA_UNION-val"><b>SIGMA_ALGEBRA_UNION</b></a>]  Theorem
      
      ⊢ ∀a s t.
          sigma_algebra a ∧ s ∈ subsets a ∧ t ∈ subsets a ⇒
          s ∪ t ∈ subsets a
   
   [<a name="SIGMA_CONG-val"><b>SIGMA_CONG</b></a>]  Theorem
      
      ⊢ ∀sp a b.
          subsets (sigma sp a) = subsets (sigma sp b) ⇒
          sigma sp a = sigma sp b
   
   [<a name="SIGMA_MEASURABLE-val"><b>SIGMA_MEASURABLE</b></a>]  Theorem
      
      ⊢ ∀sp A f.
          sigma_algebra A ∧ f ∈ (sp → space A) ⇒
          f ∈ measurable (sigma sp A f) A
   
   [<a name="SIGMA_MONOTONE-val"><b>SIGMA_MONOTONE</b></a>]  Theorem
      
      ⊢ ∀sp a b. a ⊆ b ⇒ subsets (sigma sp a) ⊆ subsets (sigma sp b)
   
   [<a name="SIGMA_POW-val"><b>SIGMA_POW</b></a>]  Theorem
      
      ⊢ ∀s. sigma s (POW s) = (s,POW s)
   
   [<a name="SIGMA_PROPERTY-val"><b>SIGMA_PROPERTY</b></a>]  Theorem
      
      ⊢ ∀sp p a.
          subset_class sp p ∧ ∅ ∈ p ∧ a ⊆ p ∧
          (∀s. s ∈ p ∩ subsets (sigma sp a) ⇒ sp DIFF s ∈ p) ∧
          (∀c. countable c ∧ c ⊆ p ∩ subsets (sigma sp a) ⇒ BIGUNION c ∈ p) ⇒
          subsets (sigma sp a) ⊆ p
   
   [<a name="SIGMA_PROPERTY_ALT-val"><b>SIGMA_PROPERTY_ALT</b></a>]  Theorem
      
      ⊢ ∀sp p a.
          subset_class sp p ∧ ∅ ∈ p ∧ a ⊆ p ∧
          (∀s. s ∈ p ∩ subsets (sigma sp a) ⇒ sp DIFF s ∈ p) ∧
          (∀f. f ∈ (𝕌(:num) → p ∩ subsets (sigma sp a)) ⇒
               BIGUNION (IMAGE f 𝕌(:num)) ∈ p) ⇒
          subsets (sigma sp a) ⊆ p
   
   [<a name="SIGMA_PROPERTY_DISJOINT-val"><b>SIGMA_PROPERTY_DISJOINT</b></a>]  Theorem
      
      ⊢ ∀sp p a.
          algebra (sp,a) ∧ a ⊆ p ∧
          (∀s. s ∈ p ∩ subsets (sigma sp a) ⇒ sp DIFF s ∈ p) ∧
          (∀f. f ∈ (𝕌(:num) → p ∩ subsets (sigma sp a)) ∧ f 0 = ∅ ∧
               (∀n. f n ⊆ f (SUC n)) ⇒
               BIGUNION (IMAGE f 𝕌(:num)) ∈ p) ∧
          (∀f. f ∈ (𝕌(:num) → p ∩ subsets (sigma sp a)) ∧
               (∀i j. i ≠ j ⇒ DISJOINT (f i) (f j)) ⇒
               BIGUNION (IMAGE f 𝕌(:num)) ∈ p) ⇒
          subsets (sigma sp a) ⊆ p
   
   [<a name="SIGMA_PROPERTY_DISJOINT_LEMMA-val"><b>SIGMA_PROPERTY_DISJOINT_LEMMA</b></a>]  Theorem
      
      ⊢ ∀sp a d.
          algebra (sp,a) ∧ a ⊆ d ∧ dynkin_system (sp,d) ⇒
          subsets (sigma sp a) ⊆ d
   
   [<a name="SIGMA_PROPERTY_DISJOINT_LEMMA1-val"><b>SIGMA_PROPERTY_DISJOINT_LEMMA1</b></a>]  Theorem
      
      ⊢ ∀sp sts.
          algebra (sp,sts) ⇒
          ∀s t.
            s ∈ sts ∧ t ∈ subsets (dynkin sp sts) ⇒
            s ∩ t ∈ subsets (dynkin sp sts)
   
   [<a name="SIGMA_PROPERTY_DISJOINT_LEMMA2-val"><b>SIGMA_PROPERTY_DISJOINT_LEMMA2</b></a>]  Theorem
      
      ⊢ ∀sp sts.
          algebra (sp,sts) ⇒
          ∀s t.
            s ∈ subsets (dynkin sp sts) ∧ t ∈ subsets (dynkin sp sts) ⇒
            s ∩ t ∈ subsets (dynkin sp sts)
   
   [<a name="SIGMA_PROPERTY_DISJOINT_WEAK-val"><b>SIGMA_PROPERTY_DISJOINT_WEAK</b></a>]  Theorem
      
      ⊢ ∀sp p a.
          subset_class sp p ∧ ∅ ∈ p ∧ a ⊆ p ∧
          (∀s. s ∈ p ∩ subsets (sigma sp a) ⇒ sp DIFF s ∈ p) ∧
          (∀s t. s ∈ p ∧ t ∈ p ⇒ s ∪ t ∈ p) ∧
          (∀f. f ∈ (𝕌(:num) → p ∩ subsets (sigma sp a)) ∧
               (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ⇒
               BIGUNION (IMAGE f 𝕌(:num)) ∈ p) ⇒
          subsets (sigma sp a) ⊆ p
   
   [<a name="SIGMA_PROPERTY_DISJOINT_WEAK_ALT-val"><b>SIGMA_PROPERTY_DISJOINT_WEAK_ALT</b></a>]  Theorem
      
      ⊢ ∀sp p a.
          algebra (sp,a) ∧ a ⊆ p ∧ subset_class sp p ∧
          (∀s. s ∈ p ⇒ sp DIFF s ∈ p) ∧
          (∀f. f ∈ (𝕌(:num) → p) ∧ f 0 = ∅ ∧ (∀n. f n ⊆ f (SUC n)) ⇒
               BIGUNION (IMAGE f 𝕌(:num)) ∈ p) ∧
          (∀f. f ∈ (𝕌(:num) → p) ∧ (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ⇒
               BIGUNION (IMAGE f 𝕌(:num)) ∈ p) ⇒
          subsets (sigma sp a) ⊆ p
   
   [<a name="SIGMA_REDUCE-val"><b>SIGMA_REDUCE</b></a>]  Theorem
      
      ⊢ ∀sp a. (sp,subsets (sigma sp a)) = sigma sp a
   
   [<a name="SIGMA_SIMULTANEOUSLY_MEASURABLE-val"><b>SIGMA_SIMULTANEOUSLY_MEASURABLE</b></a>]  Theorem
      
      ⊢ ∀sp A f J.
          (∀i. i ∈ J ⇒ sigma_algebra (A i)) ∧
          (∀i. f i ∈ (sp → space (A i))) ⇒
          ∀i. i ∈ J ⇒ f i ∈ measurable (sigma sp A f J) (A i)
   
   [<a name="SIGMA_SMALLEST-val"><b>SIGMA_SMALLEST</b></a>]  Theorem
      
      ⊢ ∀sp sts A.
          sts ⊆ A ∧ A ⊆ subsets (sigma sp sts) ∧ sigma_algebra (sp,A) ⇒
          A = subsets (sigma sp sts)
   
   [<a name="SIGMA_STABLE-val"><b>SIGMA_STABLE</b></a>]  Theorem
      
      ⊢ ∀a. sigma_algebra a ⇒ sigma (space a) (subsets a) = a
   
   [<a name="SIGMA_STABLE_LEMMA-val"><b>SIGMA_STABLE_LEMMA</b></a>]  Theorem
      
      ⊢ ∀sp sts. sigma_algebra (sp,sts) ⇒ sigma sp sts = (sp,sts)
   
   [<a name="SIGMA_SUBSET-val"><b>SIGMA_SUBSET</b></a>]  Theorem
      
      ⊢ ∀a b.
          sigma_algebra b ∧ a ⊆ subsets b ⇒
          subsets (sigma (space b) a) ⊆ subsets b
   
   [<a name="SIGMA_SUBSET_SUBSETS-val"><b>SIGMA_SUBSET_SUBSETS</b></a>]  Theorem
      
      ⊢ ∀sp a. a ⊆ subsets (sigma sp a)
   
   [<a name="SMALLEST_RING-val"><b>SMALLEST_RING</b></a>]  Theorem
      
      ⊢ ∀sp sts. subset_class sp sts ⇒ ring (smallest_ring sp sts)
   
   [<a name="SMALLEST_RING_OF_SEMIRING-val"><b>SMALLEST_RING_OF_SEMIRING</b></a>]  Theorem
      
      ⊢ ∀sp sts.
          semiring (sp,sts) ⇒
          subsets (smallest_ring sp sts) =
          {BIGUNION c | c ⊆ sts ∧ FINITE c ∧ disjoint c}
   
   [<a name="SMALLEST_RING_SUBSET_SUBSETS-val"><b>SMALLEST_RING_SUBSET_SUBSETS</b></a>]  Theorem
      
      ⊢ ∀sp a. a ⊆ subsets (smallest_ring sp a)
   
   [<a name="SPACE-val"><b>SPACE</b></a>]  Theorem
      
      ⊢ ∀a. (space a,subsets a) = a
   
   [<a name="SPACE_DYNKIN-val"><b>SPACE_DYNKIN</b></a>]  Theorem
      
      ⊢ ∀sp sts. space (dynkin sp sts) = sp
   
   [<a name="SPACE_PROD_SIGMA-val"><b>SPACE_PROD_SIGMA</b></a>]  Theorem
      
      ⊢ ∀a b. space (a × b) = space a × space b
   
   [<a name="SPACE_SIGMA-val"><b>SPACE_SIGMA</b></a>]  Theorem
      
      ⊢ ∀sp a. space (sigma sp a) = sp
   
   [<a name="SPACE_SMALLEST_RING-val"><b>SPACE_SMALLEST_RING</b></a>]  Theorem
      
      ⊢ ∀sp sts. space (smallest_ring sp sts) = sp
   
   [<a name="UNIV_SIGMA_ALGEBRA-val"><b>UNIV_SIGMA_ALGEBRA</b></a>]  Theorem
      
      ⊢ sigma_algebra (𝕌(:α),𝕌(:α -&gt; bool))
   
   [<a name="algebra_alt-val"><b>algebra_alt</b></a>]  Theorem
      
      ⊢ ∀sp sts. algebra (sp,sts) ⇔ ring (sp,sts) ∧ sp ∈ sts
   
   [<a name="algebra_alt_inter-val"><b>algebra_alt_inter</b></a>]  Theorem
      
      ⊢ ∀sp sts.
          algebra (sp,sts) ⇔
          sts ⊆ POW sp ∧ ∅ ∈ sts ∧ (∀a. a ∈ sts ⇒ sp DIFF a ∈ sts) ∧
          ∀a b. a ∈ sts ∧ b ∈ sts ⇒ a ∩ b ∈ sts
   
   [<a name="algebra_alt_union-val"><b>algebra_alt_union</b></a>]  Theorem
      
      ⊢ ∀sp sts.
          algebra (sp,sts) ⇔
          sts ⊆ POW sp ∧ ∅ ∈ sts ∧ (∀a. a ∈ sts ⇒ sp DIFF a ∈ sts) ∧
          ∀a b. a ∈ sts ∧ b ∈ sts ⇒ a ∪ b ∈ sts
   
   [<a name="prod_sigma_alt_sigma_functions-val"><b>prod_sigma_alt_sigma_functions</b></a>]  Theorem
      
      ⊢ ∀A B.
          sigma_algebra A ∧ sigma_algebra B ⇒
          A × B =
          sigma (space A × space B) (binary A B) (binary FST SND) {0; 1}
   
   [<a name="ring_alt-val"><b>ring_alt</b></a>]  Theorem
      
      ⊢ ring (sp,sts) ⇔
        subset_class sp sts ∧ ∅ ∈ sts ∧
        (∀s t. s ∈ sts ∧ t ∈ sts ⇒ s ∪ t ∈ sts) ∧
        ∀s t. s ∈ sts ∧ t ∈ sts ⇒ s DIFF t ∈ sts
   
   [<a name="ring_alt_pow-val"><b>ring_alt_pow</b></a>]  Theorem
      
      ⊢ ∀sp sts.
          ring (sp,sts) ⇔
          sts ⊆ POW sp ∧ ∅ ∈ sts ∧
          (∀s t. s ∈ sts ∧ t ∈ sts ⇒ s ∪ t ∈ sts) ∧
          ∀s t. s ∈ sts ∧ t ∈ sts ⇒ s DIFF t ∈ sts
   
   [<a name="ring_alt_pow_imp-val"><b>ring_alt_pow_imp</b></a>]  Theorem
      
      ⊢ ∀sp sts.
          sts ⊆ POW sp ∧ ∅ ∈ sts ∧
          (∀a b. a ∈ sts ∧ b ∈ sts ⇒ a ∪ b ∈ sts) ∧
          (∀a b. a ∈ sts ∧ b ∈ sts ⇒ a DIFF b ∈ sts) ⇒
          ring (sp,sts)
   
   [<a name="ring_and_semiring-val"><b>ring_and_semiring</b></a>]  Theorem
      
      ⊢ ∀r. ring r ⇔
            semiring r ∧
            ∀s t. s ∈ subsets r ∧ t ∈ subsets r ⇒ s ∪ t ∈ subsets r
   
   [<a name="ring_disjointed_sets-val"><b>ring_disjointed_sets</b></a>]  Theorem
      
      ⊢ ∀sp sts A.
          ring (sp,sts) ∧ IMAGE A 𝕌(:num) ⊆ sts ⇒
          IMAGE (λn. disjointed A n) 𝕌(:num) ⊆ sts
   
   [<a name="semiring_alt-val"><b>semiring_alt</b></a>]  Theorem
      
      ⊢ semiring (sp,sts) ⇔
        subset_class sp sts ∧ ∅ ∈ sts ∧
        (∀s t. s ∈ sts ∧ t ∈ sts ⇒ s ∩ t ∈ sts) ∧
        ∀s t.
          s ∈ sts ∧ t ∈ sts ⇒
          ∃c. c ⊆ sts ∧ FINITE c ∧ disjoint c ∧ s DIFF t = BIGUNION c
   
   [<a name="sigma_algebra_alt-val"><b>sigma_algebra_alt</b></a>]  Theorem
      
      ⊢ ∀sp sts.
          sigma_algebra (sp,sts) ⇔
          algebra (sp,sts) ∧
          ∀A. IMAGE A 𝕌(:num) ⊆ sts ⇒ BIGUNION {A i | i ∈ 𝕌(:num)} ∈ sts
   
   [<a name="sigma_algebra_alt_pow-val"><b>sigma_algebra_alt_pow</b></a>]  Theorem
      
      ⊢ ∀sp sts.
          sigma_algebra (sp,sts) ⇔
          sts ⊆ POW sp ∧ ∅ ∈ sts ∧ (∀s. s ∈ sts ⇒ sp DIFF s ∈ sts) ∧
          ∀A. IMAGE A 𝕌(:num) ⊆ sts ⇒ BIGUNION {A i | i ∈ 𝕌(:num)} ∈ sts
   
   [<a name="sigma_algebra_sigma_sets-val"><b>sigma_algebra_sigma_sets</b></a>]  Theorem
      
      ⊢ ∀sp st. st ⊆ POW sp ⇒ sigma_algebra (sp,sigma_sets sp st)
   
   [<a name="sigma_sets_BIGINTER-val"><b>sigma_sets_BIGINTER</b></a>]  Theorem
      
      ⊢ ∀sp st A.
          st ⊆ POW sp ⇒
          (∀i. A i ∈ sigma_sets sp st) ⇒
          BIGINTER {A i | i ∈ 𝕌(:num)} ∈ sigma_sets sp st
   
   [<a name="sigma_sets_BIGINTER2-val"><b>sigma_sets_BIGINTER2</b></a>]  Theorem
      
      ⊢ ∀sp st A N.
          st ⊆ POW sp ∧ (∀i. i ∈ N ⇒ A i ∈ sigma_sets sp st) ∧ N ≠ ∅ ⇒
          BIGINTER {A i | i ∈ N} ∈ sigma_sets sp st
   
   [<a name="sigma_sets_BIGUNION-val"><b>sigma_sets_BIGUNION</b></a>]  Theorem
      
      ⊢ ∀sp st A.
          (∀i. A i ∈ sigma_sets sp st) ⇒
          BIGUNION {A i | i ∈ 𝕌(:num)} ∈ sigma_sets sp st
   
   [<a name="sigma_sets_basic-val"><b>sigma_sets_basic</b></a>]  Theorem
      
      ⊢ ∀sp st a. a ∈ st ⇒ a ∈ sigma_sets sp st
   
   [<a name="sigma_sets_cases-val"><b>sigma_sets_cases</b></a>]  Theorem
      
      ⊢ ∀sp st a0.
          sigma_sets sp st a0 ⇔
          a0 = ∅ ∨ st a0 ∨ (∃a. a0 = sp DIFF a ∧ sigma_sets sp st a) ∨
          ∃A. a0 = BIGUNION {A i | i ∈ 𝕌(:num)} ∧
              ∀i. sigma_sets sp st (A i)
   
   [<a name="sigma_sets_compl-val"><b>sigma_sets_compl</b></a>]  Theorem
      
      ⊢ ∀sp st a. a ∈ sigma_sets sp st ⇒ sp DIFF a ∈ sigma_sets sp st
   
   [<a name="sigma_sets_empty-val"><b>sigma_sets_empty</b></a>]  Theorem
      
      ⊢ ∀sp st. ∅ ∈ sigma_sets sp st
   
   [<a name="sigma_sets_fixpoint-val"><b>sigma_sets_fixpoint</b></a>]  Theorem
      
      ⊢ ∀sp sts. sigma_algebra (sp,sts) ⇒ sigma_sets sp sts = sts
   
   [<a name="sigma_sets_ind-val"><b>sigma_sets_ind</b></a>]  Theorem
      
      ⊢ ∀sp st sigma_sets'.
          sigma_sets' ∅ ∧ (∀a. st a ⇒ sigma_sets' a) ∧
          (∀a. sigma_sets' a ⇒ sigma_sets' (sp DIFF a)) ∧
          (∀A. (∀i. sigma_sets' (A i)) ⇒
               sigma_sets' (BIGUNION {A i | i ∈ 𝕌(:num)})) ⇒
          ∀a0. sigma_sets sp st a0 ⇒ sigma_sets' a0
   
   [<a name="sigma_sets_into_sp-val"><b>sigma_sets_into_sp</b></a>]  Theorem
      
      ⊢ ∀sp st. st ⊆ POW sp ⇒ ∀x. x ∈ sigma_sets sp st ⇒ x ⊆ sp
   
   [<a name="sigma_sets_least_sigma_algebra-val"><b>sigma_sets_least_sigma_algebra</b></a>]  Theorem
      
      ⊢ ∀sp A.
          A ⊆ POW sp ⇒
          sigma_sets sp A = BIGINTER {B | A ⊆ B ∧ sigma_algebra (sp,B)}
   
   [<a name="sigma_sets_rules-val"><b>sigma_sets_rules</b></a>]  Theorem
      
      ⊢ ∀sp st.
          sigma_sets sp st ∅ ∧ (∀a. st a ⇒ sigma_sets sp st a) ∧
          (∀a. sigma_sets sp st a ⇒ sigma_sets sp st (sp DIFF a)) ∧
          ∀A. (∀i. sigma_sets sp st (A i)) ⇒
              sigma_sets sp st (BIGUNION {A i | i ∈ 𝕌(:num)})
   
   [<a name="sigma_sets_strongind-val"><b>sigma_sets_strongind</b></a>]  Theorem
      
      ⊢ ∀sp st sigma_sets'.
          sigma_sets' ∅ ∧ (∀a. st a ⇒ sigma_sets' a) ∧
          (∀a. sigma_sets sp st a ∧ sigma_sets' a ⇒ sigma_sets' (sp DIFF a)) ∧
          (∀A. (∀i. sigma_sets sp st (A i) ∧ sigma_sets' (A i)) ⇒
               sigma_sets' (BIGUNION {A i | i ∈ 𝕌(:num)})) ⇒
          ∀a0. sigma_sets sp st a0 ⇒ sigma_sets' a0
   
   [<a name="sigma_sets_subset-val"><b>sigma_sets_subset</b></a>]  Theorem
      
      ⊢ ∀sp sts st.
          sigma_algebra (sp,sts) ∧ st ⊆ sts ⇒ sigma_sets sp st ⊆ sts
   
   [<a name="sigma_sets_superset_generator-val"><b>sigma_sets_superset_generator</b></a>]  Theorem
      
      ⊢ ∀X A. A ⊆ sigma_sets X A
   
   [<a name="sigma_sets_top-val"><b>sigma_sets_top</b></a>]  Theorem
      
      ⊢ ∀sp A. sp ∈ sigma_sets sp A
   
   [<a name="sigma_sets_union-val"><b>sigma_sets_union</b></a>]  Theorem
      
      ⊢ ∀sp st a b.
          a ∈ sigma_sets sp st ∧ b ∈ sigma_sets sp st ⇒
          a ∪ b ∈ sigma_sets sp st
   
   [<a name="subset_class_POW-val"><b>subset_class_POW</b></a>]  Theorem
      
      ⊢ ∀sp. subset_class sp (POW sp)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/probability/sigma_algebraScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-14</a></em></p></body></html>
