<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure llistTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure llistTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/coalgebras/llistScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature llistTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#LAPPEND-val">LAPPEND</a> : thm
<a name="line7"></a>    val <a href="#LCONS-val">LCONS</a> : thm
<a name="line8"></a>    val <a href="#LDROP-val">LDROP</a> : thm
<a name="line9"></a>    val <a href="#LFILTER-val">LFILTER</a> : thm
<a name="line10"></a>    val <a href="#LFINITE_def-val">LFINITE_def</a> : thm
<a name="line11"></a>    val <a href="#LFLATTEN-val">LFLATTEN</a> : thm
<a name="line12"></a>    val <a href="#LGENLIST_def-val">LGENLIST_def</a> : thm
<a name="line13"></a>    val <a href="#LHD-val">LHD</a> : thm
<a name="line14"></a>    val <a href="#LLENGTH-val">LLENGTH</a> : thm
<a name="line15"></a>    val <a href="#LMAP-val">LMAP</a> : thm
<a name="line16"></a>    val <a href="#LNIL-val">LNIL</a> : thm
<a name="line17"></a>    val <a href="#LNTH-val">LNTH</a> : thm
<a name="line18"></a>    val <a href="#LPREFIX_def-val">LPREFIX_def</a> : thm
<a name="line19"></a>    val <a href="#LREPEAT_def-val">LREPEAT_def</a> : thm
<a name="line20"></a>    val <a href="#LSET_def-val">LSET_def</a> : thm
<a name="line21"></a>    val <a href="#LSUFFIX_def-val">LSUFFIX_def</a> : thm
<a name="line22"></a>    val <a href="#LTAKE-val">LTAKE</a> : thm
<a name="line23"></a>    val <a href="#LTL-val">LTL</a> : thm
<a name="line24"></a>    val <a href="#LTL_HD_def-val">LTL_HD_def</a> : thm
<a name="line25"></a>    val <a href="#LUNFOLD_def-val">LUNFOLD_def</a> : thm
<a name="line26"></a>    val <a href="#LUNZIP_THM-val">LUNZIP_THM</a> : thm
<a name="line27"></a>    val <a href="#LZIP_THM-val">LZIP_THM</a> : thm
<a name="line28"></a>    val <a href="#always_def-val">always_def</a> : thm
<a name="line29"></a>    val <a href="#eventually_def-val">eventually_def</a> : thm
<a name="line30"></a>    val <a href="#every_def-val">every_def</a> : thm
<a name="line31"></a>    val <a href="#exists_def-val">exists_def</a> : thm
<a name="line32"></a>    val <a href="#fromList_def-val">fromList_def</a> : thm
<a name="line33"></a>    val <a href="#fromSeq_def-val">fromSeq_def</a> : thm
<a name="line34"></a>    val <a href="#linear_order_to_list_f_def-val">linear_order_to_list_f_def</a> : thm
<a name="line35"></a>    val <a href="#llength_rel_def-val">llength_rel_def</a> : thm
<a name="line36"></a>    val <a href="#llist_CASE_def-val">llist_CASE_def</a> : thm
<a name="line37"></a>    val <a href="#llist_TY_DEF-val">llist_TY_DEF</a> : thm
<a name="line38"></a>    val <a href="#llist_absrep-val">llist_absrep</a> : thm
<a name="line39"></a>    val <a href="#llist_rel_def-val">llist_rel_def</a> : thm
<a name="line40"></a>    val <a href="#llist_upto_def-val">llist_upto_def</a> : thm
<a name="line41"></a>    val <a href="#lrep_ok_def-val">lrep_ok_def</a> : thm
<a name="line42"></a>    val <a href="#toList-val">toList</a> : thm
<a name="line43"></a>    val <a href="#until_def-val">until_def</a> : thm
<a name="line44"></a>  
<a name="line45"></a>  (*  Theorems  *)
<a name="line46"></a>    val <a href="#LAPPEND_ASSOC-val">LAPPEND_ASSOC</a> : thm
<a name="line47"></a>    val <a href="#LAPPEND_EQ_LNIL-val">LAPPEND_EQ_LNIL</a> : thm
<a name="line48"></a>    val <a href="#LAPPEND_NIL_2ND-val">LAPPEND_NIL_2ND</a> : thm
<a name="line49"></a>    val <a href="#LAPPEND_fromList-val">LAPPEND_fromList</a> : thm
<a name="line50"></a>    val <a href="#LAPPEND_fromSeq-val">LAPPEND_fromSeq</a> : thm
<a name="line51"></a>    val <a href="#LCONS_11-val">LCONS_11</a> : thm
<a name="line52"></a>    val <a href="#LCONS_NOT_NIL-val">LCONS_NOT_NIL</a> : thm
<a name="line53"></a>    val <a href="#LDROP1_THM-val">LDROP1_THM</a> : thm
<a name="line54"></a>    val <a href="#LDROP_1-val">LDROP_1</a> : thm
<a name="line55"></a>    val <a href="#LDROP_ADD-val">LDROP_ADD</a> : thm
<a name="line56"></a>    val <a href="#LDROP_APPEND1-val">LDROP_APPEND1</a> : thm
<a name="line57"></a>    val <a href="#LDROP_EQ_LNIL-val">LDROP_EQ_LNIL</a> : thm
<a name="line58"></a>    val <a href="#LDROP_FUNPOW-val">LDROP_FUNPOW</a> : thm
<a name="line59"></a>    val <a href="#LDROP_LDROP-val">LDROP_LDROP</a> : thm
<a name="line60"></a>    val <a href="#LDROP_NONE_LFINITE-val">LDROP_NONE_LFINITE</a> : thm
<a name="line61"></a>    val <a href="#LDROP_SOME_LLENGTH-val">LDROP_SOME_LLENGTH</a> : thm
<a name="line62"></a>    val <a href="#LDROP_SUC-val">LDROP_SUC</a> : thm
<a name="line63"></a>    val <a href="#LDROP_THM-val">LDROP_THM</a> : thm
<a name="line64"></a>    val <a href="#LDROP_fromList-val">LDROP_fromList</a> : thm
<a name="line65"></a>    val <a href="#LDROP_fromSeq-val">LDROP_fromSeq</a> : thm
<a name="line66"></a>    val <a href="#LFILTER_APPEND-val">LFILTER_APPEND</a> : thm
<a name="line67"></a>    val <a href="#LFILTER_EQ_CONS-val">LFILTER_EQ_CONS</a> : thm
<a name="line68"></a>    val <a href="#LFILTER_EQ_NIL-val">LFILTER_EQ_NIL</a> : thm
<a name="line69"></a>    val <a href="#LFILTER_NIL-val">LFILTER_NIL</a> : thm
<a name="line70"></a>    val <a href="#LFILTER_THM-val">LFILTER_THM</a> : thm
<a name="line71"></a>    val <a href="#LFILTER_fromList-val">LFILTER_fromList</a> : thm
<a name="line72"></a>    val <a href="#LFILTER_fromSeq-val">LFILTER_fromSeq</a> : thm
<a name="line73"></a>    val <a href="#LFINITE-val">LFINITE</a> : thm
<a name="line74"></a>    val <a href="#LFINITE_APPEND-val">LFINITE_APPEND</a> : thm
<a name="line75"></a>    val <a href="#LFINITE_DROP-val">LFINITE_DROP</a> : thm
<a name="line76"></a>    val <a href="#LFINITE_HAS_LENGTH-val">LFINITE_HAS_LENGTH</a> : thm
<a name="line77"></a>    val <a href="#LFINITE_IMP_fromList-val">LFINITE_IMP_fromList</a> : thm
<a name="line78"></a>    val <a href="#LFINITE_INDUCTION-val">LFINITE_INDUCTION</a> : thm
<a name="line79"></a>    val <a href="#LFINITE_LAPPEND_IMP_NIL-val">LFINITE_LAPPEND_IMP_NIL</a> : thm
<a name="line80"></a>    val <a href="#LFINITE_LFLATTEN-val">LFINITE_LFLATTEN</a> : thm
<a name="line81"></a>    val <a href="#LFINITE_LGENLIST-val">LFINITE_LGENLIST</a> : thm
<a name="line82"></a>    val <a href="#LFINITE_LLENGTH-val">LFINITE_LLENGTH</a> : thm
<a name="line83"></a>    val <a href="#LFINITE_LNTH_NONE-val">LFINITE_LNTH_NONE</a> : thm
<a name="line84"></a>    val <a href="#LFINITE_MAP-val">LFINITE_MAP</a> : thm
<a name="line85"></a>    val <a href="#LFINITE_STRONG_INDUCTION-val">LFINITE_STRONG_INDUCTION</a> : thm
<a name="line86"></a>    val <a href="#LFINITE_TAKE-val">LFINITE_TAKE</a> : thm
<a name="line87"></a>    val <a href="#LFINITE_THM-val">LFINITE_THM</a> : thm
<a name="line88"></a>    val <a href="#LFINITE_cases-val">LFINITE_cases</a> : thm
<a name="line89"></a>    val <a href="#LFINITE_fromList-val">LFINITE_fromList</a> : thm
<a name="line90"></a>    val <a href="#LFINITE_fromSeq-val">LFINITE_fromSeq</a> : thm
<a name="line91"></a>    val <a href="#LFINITE_ind-val">LFINITE_ind</a> : thm
<a name="line92"></a>    val <a href="#LFINITE_rules-val">LFINITE_rules</a> : thm
<a name="line93"></a>    val <a href="#LFINITE_strongind-val">LFINITE_strongind</a> : thm
<a name="line94"></a>    val <a href="#LFINITE_toList-val">LFINITE_toList</a> : thm
<a name="line95"></a>    val <a href="#LFINITE_toList_SOME-val">LFINITE_toList_SOME</a> : thm
<a name="line96"></a>    val <a href="#LFLATTEN_APPEND-val">LFLATTEN_APPEND</a> : thm
<a name="line97"></a>    val <a href="#LFLATTEN_EQ_NIL-val">LFLATTEN_EQ_NIL</a> : thm
<a name="line98"></a>    val <a href="#LFLATTEN_SINGLETON-val">LFLATTEN_SINGLETON</a> : thm
<a name="line99"></a>    val <a href="#LFLATTEN_THM-val">LFLATTEN_THM</a> : thm
<a name="line100"></a>    val <a href="#LFLATTEN_fromList-val">LFLATTEN_fromList</a> : thm
<a name="line101"></a>    val <a href="#LGENLIST_CHUNK_GENLIST-val">LGENLIST_CHUNK_GENLIST</a> : thm
<a name="line102"></a>    val <a href="#LGENLIST_EQ_CONS-val">LGENLIST_EQ_CONS</a> : thm
<a name="line103"></a>    val <a href="#LGENLIST_EQ_LNIL-val">LGENLIST_EQ_LNIL</a> : thm
<a name="line104"></a>    val <a href="#LGENLIST_EQ_fromList-val">LGENLIST_EQ_fromList</a> : thm
<a name="line105"></a>    val <a href="#LGENLIST_EQ_fromSeq-val">LGENLIST_EQ_fromSeq</a> : thm
<a name="line106"></a>    val <a href="#LGENLIST_SOME-val">LGENLIST_SOME</a> : thm
<a name="line107"></a>    val <a href="#LGENLIST_SOME_compute-val">LGENLIST_SOME_compute</a> : thm
<a name="line108"></a>    val <a href="#LHDTL_CONS_THM-val">LHDTL_CONS_THM</a> : thm
<a name="line109"></a>    val <a href="#LHDTL_EQ_SOME-val">LHDTL_EQ_SOME</a> : thm
<a name="line110"></a>    val <a href="#LHD_EQ_NONE-val">LHD_EQ_NONE</a> : thm
<a name="line111"></a>    val <a href="#LHD_LAPPEND-val">LHD_LAPPEND</a> : thm
<a name="line112"></a>    val <a href="#LHD_LCONS-val">LHD_LCONS</a> : thm
<a name="line113"></a>    val <a href="#LHD_LGENLIST-val">LHD_LGENLIST</a> : thm
<a name="line114"></a>    val <a href="#LHD_LREPEAT-val">LHD_LREPEAT</a> : thm
<a name="line115"></a>    val <a href="#LHD_LUNFOLD-val">LHD_LUNFOLD</a> : thm
<a name="line116"></a>    val <a href="#LHD_THM-val">LHD_THM</a> : thm
<a name="line117"></a>    val <a href="#LHD_fromList-val">LHD_fromList</a> : thm
<a name="line118"></a>    val <a href="#LHD_fromSeq-val">LHD_fromSeq</a> : thm
<a name="line119"></a>    val <a href="#LLENGTH_0-val">LLENGTH_0</a> : thm
<a name="line120"></a>    val <a href="#LLENGTH_APPEND-val">LLENGTH_APPEND</a> : thm
<a name="line121"></a>    val <a href="#LLENGTH_LGENLIST-val">LLENGTH_LGENLIST</a> : thm
<a name="line122"></a>    val <a href="#LLENGTH_LREPEAT-val">LLENGTH_LREPEAT</a> : thm
<a name="line123"></a>    val <a href="#LLENGTH_MAP-val">LLENGTH_MAP</a> : thm
<a name="line124"></a>    val <a href="#LLENGTH_THM-val">LLENGTH_THM</a> : thm
<a name="line125"></a>    val <a href="#LLENGTH_fromList-val">LLENGTH_fromList</a> : thm
<a name="line126"></a>    val <a href="#LLENGTH_fromSeq-val">LLENGTH_fromSeq</a> : thm
<a name="line127"></a>    val <a href="#LLIST_BISIMULATION-val">LLIST_BISIMULATION</a> : thm
<a name="line128"></a>    val <a href="#LLIST_BISIMULATION0-val">LLIST_BISIMULATION0</a> : thm
<a name="line129"></a>    val <a href="#LLIST_BISIMULATION_I-val">LLIST_BISIMULATION_I</a> : thm
<a name="line130"></a>    val <a href="#LLIST_BISIM_UPTO-val">LLIST_BISIM_UPTO</a> : thm
<a name="line131"></a>    val <a href="#LLIST_CASE_CONG-val">LLIST_CASE_CONG</a> : thm
<a name="line132"></a>    val <a href="#LLIST_CASE_EQ-val">LLIST_CASE_EQ</a> : thm
<a name="line133"></a>    val <a href="#LLIST_DISTINCT-val">LLIST_DISTINCT</a> : thm
<a name="line134"></a>    val <a href="#LLIST_EQ-val">LLIST_EQ</a> : thm
<a name="line135"></a>    val <a href="#LLIST_STRONG_BISIMULATION-val">LLIST_STRONG_BISIMULATION</a> : thm
<a name="line136"></a>    val <a href="#LL_ALL_THM-val">LL_ALL_THM</a> : thm
<a name="line137"></a>    val <a href="#LMAP_APPEND-val">LMAP_APPEND</a> : thm
<a name="line138"></a>    val <a href="#LMAP_LGENLIST-val">LMAP_LGENLIST</a> : thm
<a name="line139"></a>    val <a href="#LMAP_LUNFOLD-val">LMAP_LUNFOLD</a> : thm
<a name="line140"></a>    val <a href="#LMAP_MAP-val">LMAP_MAP</a> : thm
<a name="line141"></a>    val <a href="#LMAP_fromList-val">LMAP_fromList</a> : thm
<a name="line142"></a>    val <a href="#LMAP_fromSeq-val">LMAP_fromSeq</a> : thm
<a name="line143"></a>    val <a href="#LNTH_ADD-val">LNTH_ADD</a> : thm
<a name="line144"></a>    val <a href="#LNTH_EQ-val">LNTH_EQ</a> : thm
<a name="line145"></a>    val <a href="#LNTH_HD_LDROP-val">LNTH_HD_LDROP</a> : thm
<a name="line146"></a>    val <a href="#LNTH_LAPPEND-val">LNTH_LAPPEND</a> : thm
<a name="line147"></a>    val <a href="#LNTH_LDROP-val">LNTH_LDROP</a> : thm
<a name="line148"></a>    val <a href="#LNTH_LGENLIST-val">LNTH_LGENLIST</a> : thm
<a name="line149"></a>    val <a href="#LNTH_LLENGTH_NONE-val">LNTH_LLENGTH_NONE</a> : thm
<a name="line150"></a>    val <a href="#LNTH_LMAP-val">LNTH_LMAP</a> : thm
<a name="line151"></a>    val <a href="#LNTH_LUNFOLD-val">LNTH_LUNFOLD</a> : thm
<a name="line152"></a>    val <a href="#LNTH_LUNFOLD_compute-val">LNTH_LUNFOLD_compute</a> : thm
<a name="line153"></a>    val <a href="#LNTH_NONE_MONO-val">LNTH_NONE_MONO</a> : thm
<a name="line154"></a>    val <a href="#LNTH_THM-val">LNTH_THM</a> : thm
<a name="line155"></a>    val <a href="#LNTH_fromList-val">LNTH_fromList</a> : thm
<a name="line156"></a>    val <a href="#LNTH_fromSeq-val">LNTH_fromSeq</a> : thm
<a name="line157"></a>    val <a href="#LNTH_rep-val">LNTH_rep</a> : thm
<a name="line158"></a>    val <a href="#LPREFIX_ANTISYM-val">LPREFIX_ANTISYM</a> : thm
<a name="line159"></a>    val <a href="#LPREFIX_APPEND-val">LPREFIX_APPEND</a> : thm
<a name="line160"></a>    val <a href="#LPREFIX_LCONS-val">LPREFIX_LCONS</a> : thm
<a name="line161"></a>    val <a href="#LPREFIX_LNIL-val">LPREFIX_LNIL</a> : thm
<a name="line162"></a>    val <a href="#LPREFIX_LUNFOLD-val">LPREFIX_LUNFOLD</a> : thm
<a name="line163"></a>    val <a href="#LPREFIX_NTH-val">LPREFIX_NTH</a> : thm
<a name="line164"></a>    val <a href="#LPREFIX_REFL-val">LPREFIX_REFL</a> : thm
<a name="line165"></a>    val <a href="#LPREFIX_TRANS-val">LPREFIX_TRANS</a> : thm
<a name="line166"></a>    val <a href="#LPREFIX_fromList-val">LPREFIX_fromList</a> : thm
<a name="line167"></a>    val <a href="#LREPEAT_EQ_LNIL-val">LREPEAT_EQ_LNIL</a> : thm
<a name="line168"></a>    val <a href="#LREPEAT_NIL-val">LREPEAT_NIL</a> : thm
<a name="line169"></a>    val <a href="#LREPEAT_thm-val">LREPEAT_thm</a> : thm
<a name="line170"></a>    val <a href="#LSET-val">LSET</a> : thm
<a name="line171"></a>    val <a href="#LSUFFIX-val">LSUFFIX</a> : thm
<a name="line172"></a>    val <a href="#LSUFFIX_ANTISYM-val">LSUFFIX_ANTISYM</a> : thm
<a name="line173"></a>    val <a href="#LSUFFIX_REFL-val">LSUFFIX_REFL</a> : thm
<a name="line174"></a>    val <a href="#LSUFFIX_TRANS-val">LSUFFIX_TRANS</a> : thm
<a name="line175"></a>    val <a href="#LSUFFIX_fromList-val">LSUFFIX_fromList</a> : thm
<a name="line176"></a>    val <a href="#LTAKE_CONS_EQ_NONE-val">LTAKE_CONS_EQ_NONE</a> : thm
<a name="line177"></a>    val <a href="#LTAKE_CONS_EQ_SOME-val">LTAKE_CONS_EQ_SOME</a> : thm
<a name="line178"></a>    val <a href="#LTAKE_DROP-val">LTAKE_DROP</a> : thm
<a name="line179"></a>    val <a href="#LTAKE_EQ-val">LTAKE_EQ</a> : thm
<a name="line180"></a>    val <a href="#LTAKE_EQ_NONE_LNTH-val">LTAKE_EQ_NONE_LNTH</a> : thm
<a name="line181"></a>    val <a href="#LTAKE_EQ_SOME_CONS-val">LTAKE_EQ_SOME_CONS</a> : thm
<a name="line182"></a>    val <a href="#LTAKE_IMP_LDROP-val">LTAKE_IMP_LDROP</a> : thm
<a name="line183"></a>    val <a href="#LTAKE_LAPPEND1-val">LTAKE_LAPPEND1</a> : thm
<a name="line184"></a>    val <a href="#LTAKE_LAPPEND2-val">LTAKE_LAPPEND2</a> : thm
<a name="line185"></a>    val <a href="#LTAKE_LAPPEND_fromList-val">LTAKE_LAPPEND_fromList</a> : thm
<a name="line186"></a>    val <a href="#LTAKE_LENGTH-val">LTAKE_LENGTH</a> : thm
<a name="line187"></a>    val <a href="#LTAKE_LLENGTH_NONE-val">LTAKE_LLENGTH_NONE</a> : thm
<a name="line188"></a>    val <a href="#LTAKE_LLENGTH_SOME-val">LTAKE_LLENGTH_SOME</a> : thm
<a name="line189"></a>    val <a href="#LTAKE_LMAP-val">LTAKE_LMAP</a> : thm
<a name="line190"></a>    val <a href="#LTAKE_LNTH_EL-val">LTAKE_LNTH_EL</a> : thm
<a name="line191"></a>    val <a href="#LTAKE_LPREFIX-val">LTAKE_LPREFIX</a> : thm
<a name="line192"></a>    val <a href="#LTAKE_LUNFOLD-val">LTAKE_LUNFOLD</a> : thm
<a name="line193"></a>    val <a href="#LTAKE_NIL_EQ_NONE-val">LTAKE_NIL_EQ_NONE</a> : thm
<a name="line194"></a>    val <a href="#LTAKE_NIL_EQ_SOME-val">LTAKE_NIL_EQ_SOME</a> : thm
<a name="line195"></a>    val <a href="#LTAKE_SNOC_LNTH-val">LTAKE_SNOC_LNTH</a> : thm
<a name="line196"></a>    val <a href="#LTAKE_TAKE_LESS-val">LTAKE_TAKE_LESS</a> : thm
<a name="line197"></a>    val <a href="#LTAKE_THM-val">LTAKE_THM</a> : thm
<a name="line198"></a>    val <a href="#LTAKE_fromList-val">LTAKE_fromList</a> : thm
<a name="line199"></a>    val <a href="#LTAKE_fromSeq-val">LTAKE_fromSeq</a> : thm
<a name="line200"></a>    val <a href="#LTL_EQ_NONE-val">LTL_EQ_NONE</a> : thm
<a name="line201"></a>    val <a href="#LTL_HD_11-val">LTL_HD_11</a> : thm
<a name="line202"></a>    val <a href="#LTL_HD_HD-val">LTL_HD_HD</a> : thm
<a name="line203"></a>    val <a href="#LTL_HD_LCONS-val">LTL_HD_LCONS</a> : thm
<a name="line204"></a>    val <a href="#LTL_HD_LNIL-val">LTL_HD_LNIL</a> : thm
<a name="line205"></a>    val <a href="#LTL_HD_LTL_LHD-val">LTL_HD_LTL_LHD</a> : thm
<a name="line206"></a>    val <a href="#LTL_HD_LUNFOLD-val">LTL_HD_LUNFOLD</a> : thm
<a name="line207"></a>    val <a href="#LTL_HD_TL-val">LTL_HD_TL</a> : thm
<a name="line208"></a>    val <a href="#LTL_HD_iff-val">LTL_HD_iff</a> : thm
<a name="line209"></a>    val <a href="#LTL_LAPPEND-val">LTL_LAPPEND</a> : thm
<a name="line210"></a>    val <a href="#LTL_LCONS-val">LTL_LCONS</a> : thm
<a name="line211"></a>    val <a href="#LTL_LGENLIST-val">LTL_LGENLIST</a> : thm
<a name="line212"></a>    val <a href="#LTL_LREPEAT-val">LTL_LREPEAT</a> : thm
<a name="line213"></a>    val <a href="#LTL_LUNFOLD-val">LTL_LUNFOLD</a> : thm
<a name="line214"></a>    val <a href="#LTL_THM-val">LTL_THM</a> : thm
<a name="line215"></a>    val <a href="#LTL_fromList-val">LTL_fromList</a> : thm
<a name="line216"></a>    val <a href="#LTL_fromSeq-val">LTL_fromSeq</a> : thm
<a name="line217"></a>    val <a href="#LUNFOLD-val">LUNFOLD</a> : thm
<a name="line218"></a>    val <a href="#LUNFOLD_BISIMULATION-val">LUNFOLD_BISIMULATION</a> : thm
<a name="line219"></a>    val <a href="#LUNFOLD_EQ-val">LUNFOLD_EQ</a> : thm
<a name="line220"></a>    val <a href="#LUNFOLD_LTL_HD-val">LUNFOLD_LTL_HD</a> : thm
<a name="line221"></a>    val <a href="#LUNFOLD_THM-val">LUNFOLD_THM</a> : thm
<a name="line222"></a>    val <a href="#LUNFOLD_UNIQUE-val">LUNFOLD_UNIQUE</a> : thm
<a name="line223"></a>    val <a href="#LZIP_LUNZIP-val">LZIP_LUNZIP</a> : thm
<a name="line224"></a>    val <a href="#MONO_every-val">MONO_every</a> : thm
<a name="line225"></a>    val <a href="#MONO_exists-val">MONO_exists</a> : thm
<a name="line226"></a>    val <a href="#NOT_LFINITE_APPEND-val">NOT_LFINITE_APPEND</a> : thm
<a name="line227"></a>    val <a href="#NOT_LFINITE_DROP-val">NOT_LFINITE_DROP</a> : thm
<a name="line228"></a>    val <a href="#NOT_LFINITE_DROP_LFINITE-val">NOT_LFINITE_DROP_LFINITE</a> : thm
<a name="line229"></a>    val <a href="#NOT_LFINITE_IMP_fromSeq-val">NOT_LFINITE_IMP_fromSeq</a> : thm
<a name="line230"></a>    val <a href="#NOT_LFINITE_NO_LENGTH-val">NOT_LFINITE_NO_LENGTH</a> : thm
<a name="line231"></a>    val <a href="#NOT_LFINITE_TAKE-val">NOT_LFINITE_TAKE</a> : thm
<a name="line232"></a>    val <a href="#always_DROP-val">always_DROP</a> : thm
<a name="line233"></a>    val <a href="#always_cases-val">always_cases</a> : thm
<a name="line234"></a>    val <a href="#always_coind-val">always_coind</a> : thm
<a name="line235"></a>    val <a href="#always_conj_l-val">always_conj_l</a> : thm
<a name="line236"></a>    val <a href="#always_eventually_ind-val">always_eventually_ind</a> : thm
<a name="line237"></a>    val <a href="#always_rules-val">always_rules</a> : thm
<a name="line238"></a>    val <a href="#always_thm-val">always_thm</a> : thm
<a name="line239"></a>    val <a href="#eventually_cases-val">eventually_cases</a> : thm
<a name="line240"></a>    val <a href="#eventually_ind-val">eventually_ind</a> : thm
<a name="line241"></a>    val <a href="#eventually_rules-val">eventually_rules</a> : thm
<a name="line242"></a>    val <a href="#eventually_strongind-val">eventually_strongind</a> : thm
<a name="line243"></a>    val <a href="#eventually_thm-val">eventually_thm</a> : thm
<a name="line244"></a>    val <a href="#eventually_until_EQN-val">eventually_until_EQN</a> : thm
<a name="line245"></a>    val <a href="#every_LAPPEND1-val">every_LAPPEND1</a> : thm
<a name="line246"></a>    val <a href="#every_LAPPEND2_LFINITE-val">every_LAPPEND2_LFINITE</a> : thm
<a name="line247"></a>    val <a href="#every_LDROP-val">every_LDROP</a> : thm
<a name="line248"></a>    val <a href="#every_LFILTER-val">every_LFILTER</a> : thm
<a name="line249"></a>    val <a href="#every_LFILTER_imp-val">every_LFILTER_imp</a> : thm
<a name="line250"></a>    val <a href="#every_LNTH-val">every_LNTH</a> : thm
<a name="line251"></a>    val <a href="#every_coind-val">every_coind</a> : thm
<a name="line252"></a>    val <a href="#every_fromList_EVERY-val">every_fromList_EVERY</a> : thm
<a name="line253"></a>    val <a href="#every_fromSeq-val">every_fromSeq</a> : thm
<a name="line254"></a>    val <a href="#every_strong_coind-val">every_strong_coind</a> : thm
<a name="line255"></a>    val <a href="#every_thm-val">every_thm</a> : thm
<a name="line256"></a>    val <a href="#exists_LDROP-val">exists_LDROP</a> : thm
<a name="line257"></a>    val <a href="#exists_LNTH-val">exists_LNTH</a> : thm
<a name="line258"></a>    val <a href="#exists_cases-val">exists_cases</a> : thm
<a name="line259"></a>    val <a href="#exists_fromSeq-val">exists_fromSeq</a> : thm
<a name="line260"></a>    val <a href="#exists_ind-val">exists_ind</a> : thm
<a name="line261"></a>    val <a href="#exists_rules-val">exists_rules</a> : thm
<a name="line262"></a>    val <a href="#exists_strong_ind-val">exists_strong_ind</a> : thm
<a name="line263"></a>    val <a href="#exists_strongind-val">exists_strongind</a> : thm
<a name="line264"></a>    val <a href="#exists_thm-val">exists_thm</a> : thm
<a name="line265"></a>    val <a href="#exists_thm_strong-val">exists_thm_strong</a> : thm
<a name="line266"></a>    val <a href="#fromList_11-val">fromList_11</a> : thm
<a name="line267"></a>    val <a href="#fromList_EQ_LNIL-val">fromList_EQ_LNIL</a> : thm
<a name="line268"></a>    val <a href="#fromList_NEQ_fromSeq-val">fromList_NEQ_fromSeq</a> : thm
<a name="line269"></a>    val <a href="#fromList_fromSeq-val">fromList_fromSeq</a> : thm
<a name="line270"></a>    val <a href="#fromSeq_11-val">fromSeq_11</a> : thm
<a name="line271"></a>    val <a href="#fromSeq_LCONS-val">fromSeq_LCONS</a> : thm
<a name="line272"></a>    val <a href="#from_toList-val">from_toList</a> : thm
<a name="line273"></a>    val <a href="#infinite_lnth_some-val">infinite_lnth_some</a> : thm
<a name="line274"></a>    val <a href="#linear_order_to_llist-val">linear_order_to_llist</a> : thm
<a name="line275"></a>    val <a href="#linear_order_to_llist_eq-val">linear_order_to_llist_eq</a> : thm
<a name="line276"></a>    val <a href="#llength_rel_cases-val">llength_rel_cases</a> : thm
<a name="line277"></a>    val <a href="#llength_rel_ind-val">llength_rel_ind</a> : thm
<a name="line278"></a>    val <a href="#llength_rel_rules-val">llength_rel_rules</a> : thm
<a name="line279"></a>    val <a href="#llength_rel_strongind-val">llength_rel_strongind</a> : thm
<a name="line280"></a>    val <a href="#llist_Axiom-val">llist_Axiom</a> : thm
<a name="line281"></a>    val <a href="#llist_Axiom_1-val">llist_Axiom_1</a> : thm
<a name="line282"></a>    val <a href="#llist_Axiom_1ue-val">llist_Axiom_1ue</a> : thm
<a name="line283"></a>    val <a href="#llist_CASES-val">llist_CASES</a> : thm
<a name="line284"></a>    val <a href="#llist_CASE_compute-val">llist_CASE_compute</a> : thm
<a name="line285"></a>    val <a href="#llist_forall_split-val">llist_forall_split</a> : thm
<a name="line286"></a>    val <a href="#llist_rep_LCONS-val">llist_rep_LCONS</a> : thm
<a name="line287"></a>    val <a href="#llist_rep_LNIL-val">llist_rep_LNIL</a> : thm
<a name="line288"></a>    val <a href="#llist_ue_Axiom-val">llist_ue_Axiom</a> : thm
<a name="line289"></a>    val <a href="#llist_upto_cases-val">llist_upto_cases</a> : thm
<a name="line290"></a>    val <a href="#llist_upto_context-val">llist_upto_context</a> : thm
<a name="line291"></a>    val <a href="#llist_upto_eq-val">llist_upto_eq</a> : thm
<a name="line292"></a>    val <a href="#llist_upto_ind-val">llist_upto_ind</a> : thm
<a name="line293"></a>    val <a href="#llist_upto_rel-val">llist_upto_rel</a> : thm
<a name="line294"></a>    val <a href="#llist_upto_rules-val">llist_upto_rules</a> : thm
<a name="line295"></a>    val <a href="#llist_upto_strongind-val">llist_upto_strongind</a> : thm
<a name="line296"></a>    val <a href="#llist_upto_trans-val">llist_upto_trans</a> : thm
<a name="line297"></a>    val <a href="#lnth_fromList_some-val">lnth_fromList_some</a> : thm
<a name="line298"></a>    val <a href="#lnth_some_down_closed-val">lnth_some_down_closed</a> : thm
<a name="line299"></a>    val <a href="#lrep_ok_FUNPOW_BIND-val">lrep_ok_FUNPOW_BIND</a> : thm
<a name="line300"></a>    val <a href="#lrep_ok_MAP-val">lrep_ok_MAP</a> : thm
<a name="line301"></a>    val <a href="#lrep_ok_alt-val">lrep_ok_alt</a> : thm
<a name="line302"></a>    val <a href="#lrep_ok_cases-val">lrep_ok_cases</a> : thm
<a name="line303"></a>    val <a href="#lrep_ok_coind-val">lrep_ok_coind</a> : thm
<a name="line304"></a>    val <a href="#lrep_ok_rules-val">lrep_ok_rules</a> : thm
<a name="line305"></a>    val <a href="#numopt_BISIMULATION-val">numopt_BISIMULATION</a> : thm
<a name="line306"></a>    val <a href="#prefixes_lprefix_total-val">prefixes_lprefix_total</a> : thm
<a name="line307"></a>    val <a href="#toList_LAPPEND_APPEND-val">toList_LAPPEND_APPEND</a> : thm
<a name="line308"></a>    val <a href="#toList_THM-val">toList_THM</a> : thm
<a name="line309"></a>    val <a href="#to_fromList-val">to_fromList</a> : thm
<a name="line310"></a>    val <a href="#until_cases-val">until_cases</a> : thm
<a name="line311"></a>    val <a href="#until_ind-val">until_ind</a> : thm
<a name="line312"></a>    val <a href="#until_rules-val">until_rules</a> : thm
<a name="line313"></a>    val <a href="#until_strongind-val">until_strongind</a> : thm
<a name="line314"></a>  
<a name="line315"></a>  val llist_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line316"></a>(*
   [indexedLists] Parent theory of "llist"
   
   [patternMatches] Parent theory of "llist"
   
   [set_relation] Parent theory of "llist"
   
   [<a name="LAPPEND-val"><b>LAPPEND</b></a>]  Definition
      
      ⊢ (∀x. LAPPEND [||] x = x) ∧
        ∀h t x. LAPPEND (h:::t) x = h:::LAPPEND t x
   
   [<a name="LCONS-val"><b>LCONS</b></a>]  Definition
      
      ⊢ ∀h t.
          h:::t =
          llist_abs (λn. if n = 0 then SOME h else llist_rep t (n − 1))
   
   [<a name="LDROP-val"><b>LDROP</b></a>]  Definition
      
      ⊢ (∀ll. LDROP 0 ll = SOME ll) ∧
        ∀n ll.
          LDROP (SUC n) ll = OPTION_JOIN (OPTION_MAP (LDROP n) (LTL ll))
   
   [<a name="LFILTER-val"><b>LFILTER</b></a>]  Definition
      
      ⊢ ∀P ll.
          LFILTER P ll =
          if ¬exists P ll then [||]
          else if P (THE (LHD ll)) then
            THE (LHD ll):::LFILTER P (THE (LTL ll))
          else LFILTER P (THE (LTL ll))
   
   [<a name="LFINITE_def-val"><b>LFINITE_def</b></a>]  Definition
      
      ⊢ LFINITE =
        (λa0.
             ∀LFINITE'.
               (∀a0.
                  a0 = [||] ∨ (∃h t. a0 = h:::t ∧ LFINITE' t) ⇒ LFINITE' a0) ⇒
               LFINITE' a0)
   
   [<a name="LFLATTEN-val"><b>LFLATTEN</b></a>]  Definition
      
      ⊢ ∀ll.
          LFLATTEN ll =
          if every ($= [||]) ll then [||]
          else if THE (LHD ll) = [||] then LFLATTEN (THE (LTL ll))
          else
            THE (LHD (THE (LHD ll))):::
                LFLATTEN (THE (LTL (THE (LHD ll))):::THE (LTL ll))
   
   [<a name="LGENLIST_def-val"><b>LGENLIST_def</b></a>]  Definition
      
      ⊢ (∀f. LGENLIST f NONE = LUNFOLD (λn. SOME (n + 1,f n)) 0) ∧
        ∀f lim.
          LGENLIST f (SOME lim) =
          LUNFOLD (λn. if n &lt; lim then SOME (n + 1,f n) else NONE) 0
   
   [<a name="LHD-val"><b>LHD</b></a>]  Definition
      
      ⊢ ∀ll. LHD ll = llist_rep ll 0
   
   [<a name="LLENGTH-val"><b>LLENGTH</b></a>]  Definition
      
      ⊢ ∀ll.
          LLENGTH ll =
          if LFINITE ll then SOME (@n. llength_rel ll n) else NONE
   
   [<a name="LMAP-val"><b>LMAP</b></a>]  Definition
      
      ⊢ (∀f. LMAP f [||] = [||]) ∧ ∀f h t. LMAP f (h:::t) = f h:::LMAP f t
   
   [<a name="LNIL-val"><b>LNIL</b></a>]  Definition
      
      ⊢ [||] = llist_abs (λn. NONE)
   
   [<a name="LNTH-val"><b>LNTH</b></a>]  Definition
      
      ⊢ (∀ll. LNTH 0 ll = LHD ll) ∧
        ∀n ll. LNTH (SUC n) ll = OPTION_JOIN (OPTION_MAP (LNTH n) (LTL ll))
   
   [<a name="LPREFIX_def-val"><b>LPREFIX_def</b></a>]  Definition
      
      ⊢ ∀l1 l2.
          LPREFIX l1 l2 ⇔
          case toList l1 of
            NONE =&gt; l1 = l2
          | SOME xs =&gt;
            case toList l2 of
              NONE =&gt; LTAKE (LENGTH xs) l2 = SOME xs
            | SOME ys =&gt; xs ≼ ys
   
   [<a name="LREPEAT_def-val"><b>LREPEAT_def</b></a>]  Definition
      
      ⊢ ∀l. LREPEAT l =
            if NULL l then [||]
            else LGENLIST (λn. EL (n MOD LENGTH l) l) NONE
   
   [<a name="LSET_def-val"><b>LSET_def</b></a>]  Definition
      
      ⊢ ∀l x. LSET l x ⇔ ∃n. LNTH n l = SOME x
   
   [<a name="LSUFFIX_def-val"><b>LSUFFIX_def</b></a>]  Definition
      
      ⊢ ∀xs zs.
          LSUFFIX xs zs ⇔ ∃ys. xs = LAPPEND (fromList ys) zs ∨ zs = [||]
   
   [<a name="LTAKE-val"><b>LTAKE</b></a>]  Definition
      
      ⊢ (∀ll. LTAKE 0 ll = SOME []) ∧
        ∀n ll.
          LTAKE (SUC n) ll =
          case LHD ll of
            NONE =&gt; NONE
          | SOME hd =&gt;
            case LTAKE n (THE (LTL ll)) of
              NONE =&gt; NONE
            | SOME tl =&gt; SOME (hd::tl)
   
   [<a name="LTL-val"><b>LTL</b></a>]  Definition
      
      ⊢ ∀ll.
          LTL ll =
          case LHD ll of
            NONE =&gt; NONE
          | SOME v =&gt; SOME (llist_abs (λn. llist_rep ll (n + 1)))
   
   [<a name="LTL_HD_def-val"><b>LTL_HD_def</b></a>]  Definition
      
      ⊢ ∀ll.
          LTL_HD ll =
          case llist_rep ll 0 of
            NONE =&gt; NONE
          | SOME h =&gt; SOME (llist_abs (llist_rep ll ∘ SUC),h)
   
   [<a name="LUNFOLD_def-val"><b>LUNFOLD_def</b></a>]  Definition
      
      ⊢ ∀f z.
          LUNFOLD f z =
          llist_abs
            (λn.
                 OPTION_MAP SND
                   (FUNPOW (λm. OPTION_BIND m (UNCURRY (K ∘ f))) n (f z)))
   
   [<a name="LUNZIP_THM-val"><b>LUNZIP_THM</b></a>]  Definition
      
      ⊢ LUNZIP [||] = ([||],[||]) ∧
        ∀x y t.
          LUNZIP ((x,y):::t) =
          (let (ll1,ll2) = LUNZIP t in (x:::ll1,y:::ll2))
   
   [<a name="LZIP_THM-val"><b>LZIP_THM</b></a>]  Definition
      
      ⊢ (∀l1. LZIP (l1,[||]) = [||]) ∧ (∀l2. LZIP ([||],l2) = [||]) ∧
        ∀h1 h2 t1 t2. LZIP (h1:::t1,h2:::t2) = (h1,h2):::LZIP (t1,t2)
   
   [<a name="always_def-val"><b>always_def</b></a>]  Definition
      
      ⊢ always =
        (λP a0.
             ∃always'.
               always' a0 ∧
               ∀a0. always' a0 ⇒ ∃h t. a0 = h:::t ∧ P (h:::t) ∧ always' t)
   
   [<a name="eventually_def-val"><b>eventually_def</b></a>]  Definition
      
      ⊢ eventually =
        (λP a0.
             ∀eventually'.
               (∀a0.
                  P a0 ∨ (∃h t. a0 = h:::t ∧ eventually' t) ⇒
                  eventually' a0) ⇒
               eventually' a0)
   
   [<a name="every_def-val"><b>every_def</b></a>]  Definition
      
      ⊢ ∀P ll. every P ll ⇔ ¬exists ($¬ ∘ P) ll
   
   [<a name="exists_def-val"><b>exists_def</b></a>]  Definition
      
      ⊢ exists =
        (λP a0.
             ∀exists'.
               (∀a0.
                  (∃h t. a0 = h:::t ∧ P h) ∨ (∃h t. a0 = h:::t ∧ exists' t) ⇒
                  exists' a0) ⇒
               exists' a0)
   
   [<a name="fromList_def-val"><b>fromList_def</b></a>]  Definition
      
      ⊢ fromList [] = [||] ∧ ∀h t. fromList (h::t) = h:::fromList t
   
   [<a name="fromSeq_def-val"><b>fromSeq_def</b></a>]  Definition
      
      ⊢ ∀f. fromSeq f = LUNFOLD (λx. SOME (SUC x,f x)) 0
   
   [<a name="linear_order_to_list_f_def-val"><b>linear_order_to_list_f_def</b></a>]  Definition
      
      ⊢ ∀lo.
          linear_order_to_list_f lo =
          (let
             min = minimal_elements (domain lo ∪ range lo) lo
           in
             if min = ∅ then NONE
             else
               SOME
                 (rrestrict lo (domain lo ∪ range lo DIFF min),CHOICE min))
   
   [<a name="llength_rel_def-val"><b>llength_rel_def</b></a>]  Definition
      
      ⊢ llength_rel =
        (λa0 a1.
             ∀llength_rel'.
               (∀a0 a1.
                  a0 = [||] ∧ a1 = 0 ∨
                  (∃h n t. a0 = h:::t ∧ a1 = SUC n ∧ llength_rel' t n) ⇒
                  llength_rel' a0 a1) ⇒
               llength_rel' a0 a1)
   
   [<a name="llist_CASE_def-val"><b>llist_CASE_def</b></a>]  Definition
      
      ⊢ ∀ll b f.
          llist_CASE ll b f =
          case LTL_HD ll of NONE =&gt; b | SOME (ltl,lhd) =&gt; f lhd ltl
   
   [<a name="llist_TY_DEF-val"><b>llist_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep. TYPE_DEFINITION lrep_ok rep
   
   [<a name="llist_absrep-val"><b>llist_absrep</b></a>]  Definition
      
      ⊢ (∀a. llist_abs (llist_rep a) = a) ∧
        ∀r. lrep_ok r ⇔ llist_rep (llist_abs r) = r
   
   [<a name="llist_rel_def-val"><b>llist_rel_def</b></a>]  Definition
      
      ⊢ ∀R l1 l2.
          llist_rel R l1 l2 ⇔
          LLENGTH l1 = LLENGTH l2 ∧
          ∀i x y. LNTH i l1 = SOME x ∧ LNTH i l2 = SOME y ⇒ R x y
   
   [<a name="llist_upto_def-val"><b>llist_upto_def</b></a>]  Definition
      
      ⊢ llist_upto =
        (λR a0 a1.
             ∀llist_upto'.
               (∀a0 a1.
                  a1 = a0 ∨ R a0 a1 ∨
                  (∃y. llist_upto' a0 y ∧ llist_upto' y a1) ∨
                  (∃x y z.
                     a0 = LAPPEND z x ∧ a1 = LAPPEND z y ∧ llist_upto' x y) ⇒
                  llist_upto' a0 a1) ⇒
               llist_upto' a0 a1)
   
   [<a name="lrep_ok_def-val"><b>lrep_ok_def</b></a>]  Definition
      
      ⊢ lrep_ok =
        (λa0.
             ∃lrep_ok'.
               lrep_ok' a0 ∧
               ∀a0.
                 lrep_ok' a0 ⇒
                 a0 = (λn. NONE) ∨
                 ∃h t.
                   a0 = (λn. if n = 0 then SOME h else t (n − 1)) ∧
                   lrep_ok' t)
   
   [<a name="toList-val"><b>toList</b></a>]  Definition
      
      ⊢ ∀ll.
          toList ll =
          if LFINITE ll then LTAKE (THE (LLENGTH ll)) ll else NONE
   
   [<a name="until_def-val"><b>until_def</b></a>]  Definition
      
      ⊢ until =
        (λP Q a0.
             ∀until'.
               (∀a0.
                  Q a0 ∨ (∃h t. a0 = h:::t ∧ P (h:::t) ∧ until' t) ⇒
                  until' a0) ⇒
               until' a0)
   
   [<a name="LAPPEND_ASSOC-val"><b>LAPPEND_ASSOC</b></a>]  Theorem
      
      ⊢ ∀ll1 ll2 ll3.
          LAPPEND (LAPPEND ll1 ll2) ll3 = LAPPEND ll1 (LAPPEND ll2 ll3)
   
   [<a name="LAPPEND_EQ_LNIL-val"><b>LAPPEND_EQ_LNIL</b></a>]  Theorem
      
      ⊢ LAPPEND l1 l2 = [||] ⇔ l1 = [||] ∧ l2 = [||]
   
   [<a name="LAPPEND_NIL_2ND-val"><b>LAPPEND_NIL_2ND</b></a>]  Theorem
      
      ⊢ ∀ll. LAPPEND ll [||] = ll
   
   [<a name="LAPPEND_fromList-val"><b>LAPPEND_fromList</b></a>]  Theorem
      
      ⊢ ∀l1 l2. LAPPEND (fromList l1) (fromList l2) = fromList (l1 ⧺ l2)
   
   [<a name="LAPPEND_fromSeq-val"><b>LAPPEND_fromSeq</b></a>]  Theorem
      
      ⊢ (∀f ll. LAPPEND (fromSeq f) ll = fromSeq f) ∧
        ∀l f.
          LAPPEND (fromList l) (fromSeq f) =
          fromSeq (λn. if n &lt; LENGTH l then EL n l else f (n − LENGTH l))
   
   [<a name="LCONS_11-val"><b>LCONS_11</b></a>]  Theorem
      
      ⊢ ∀h1 t1 h2 t2. h1:::t1 = h2:::t2 ⇔ h1 = h2 ∧ t1 = t2
   
   [<a name="LCONS_NOT_NIL-val"><b>LCONS_NOT_NIL</b></a>]  Theorem
      
      ⊢ ∀h t. h:::t ≠ [||] ∧ [||] ≠ h:::t
   
   [<a name="LDROP1_THM-val"><b>LDROP1_THM</b></a>]  Theorem
      
      ⊢ LDROP 1 = LTL
   
   [<a name="LDROP_1-val"><b>LDROP_1</b></a>]  Theorem
      
      ⊢ LDROP 1 (h:::t) = SOME t
   
   [<a name="LDROP_ADD-val"><b>LDROP_ADD</b></a>]  Theorem
      
      ⊢ ∀k1 k2 x.
          LDROP (k1 + k2) x =
          case LDROP k1 x of NONE =&gt; NONE | SOME ll =&gt; LDROP k2 ll
   
   [<a name="LDROP_APPEND1-val"><b>LDROP_APPEND1</b></a>]  Theorem
      
      ⊢ LDROP n l1 = SOME l ⇒ LDROP n (LAPPEND l1 l2) = SOME (LAPPEND l l2)
   
   [<a name="LDROP_EQ_LNIL-val"><b>LDROP_EQ_LNIL</b></a>]  Theorem
      
      ⊢ LDROP n ll = SOME [||] ⇔ LLENGTH ll = SOME n
   
   [<a name="LDROP_FUNPOW-val"><b>LDROP_FUNPOW</b></a>]  Theorem
      
      ⊢ ∀n ll. LDROP n ll = FUNPOW (λm. OPTION_BIND m LTL) n (SOME ll)
   
   [<a name="LDROP_LDROP-val"><b>LDROP_LDROP</b></a>]  Theorem
      
      ⊢ ∀ll k1 k2.
          ¬LFINITE ll ⇒
          THE (LDROP k2 (THE (LDROP k1 ll))) =
          THE (LDROP k1 (THE (LDROP k2 ll)))
   
   [<a name="LDROP_NONE_LFINITE-val"><b>LDROP_NONE_LFINITE</b></a>]  Theorem
      
      ⊢ LDROP k l = NONE ⇒ LFINITE l
   
   [<a name="LDROP_SOME_LLENGTH-val"><b>LDROP_SOME_LLENGTH</b></a>]  Theorem
      
      ⊢ LDROP n ll = SOME l ∧ LLENGTH ll = SOME m ⇒
        n ≤ m ∧ LLENGTH l = SOME (m − n)
   
   [<a name="LDROP_SUC-val"><b>LDROP_SUC</b></a>]  Theorem
      
      ⊢ LDROP (SUC n) ls = OPTION_BIND (LDROP n ls) LTL
   
   [<a name="LDROP_THM-val"><b>LDROP_THM</b></a>]  Theorem
      
      ⊢ (∀ll. LDROP 0 ll = SOME ll) ∧ (∀n. LDROP (SUC n) [||] = NONE) ∧
        ∀n h t. LDROP (SUC n) (h:::t) = LDROP n t
   
   [<a name="LDROP_fromList-val"><b>LDROP_fromList</b></a>]  Theorem
      
      ⊢ ∀ls n.
          LDROP n (fromList ls) =
          if n ≤ LENGTH ls then SOME (fromList (DROP n ls)) else NONE
   
   [<a name="LDROP_fromSeq-val"><b>LDROP_fromSeq</b></a>]  Theorem
      
      ⊢ ∀n f. LDROP n (fromSeq f) = SOME (fromSeq (f ∘ $+ n))
   
   [<a name="LFILTER_APPEND-val"><b>LFILTER_APPEND</b></a>]  Theorem
      
      ⊢ ∀P ll1 ll2.
          LFINITE ll1 ⇒
          LFILTER P (LAPPEND ll1 ll2) =
          LAPPEND (LFILTER P ll1) (LFILTER P ll2)
   
   [<a name="LFILTER_EQ_CONS-val"><b>LFILTER_EQ_CONS</b></a>]  Theorem
      
      ⊢ LFILTER P ll = h:::t ⇒
        ∃l ll'.
          ll = LAPPEND (fromList l) (h:::ll') ∧ EVERY ($¬ ∘ P) l ∧ P h ∧
          LFILTER P ll' = t
   
   [<a name="LFILTER_EQ_NIL-val"><b>LFILTER_EQ_NIL</b></a>]  Theorem
      
      ⊢ ∀ll. LFILTER P ll = [||] ⇔ every ($¬ ∘ P) ll
   
   [<a name="LFILTER_NIL-val"><b>LFILTER_NIL</b></a>]  Theorem
      
      ⊢ ∀P ll. every ($¬ ∘ P) ll ⇒ LFILTER P ll = [||]
   
   [<a name="LFILTER_THM-val"><b>LFILTER_THM</b></a>]  Theorem
      
      ⊢ (∀P. LFILTER P [||] = [||]) ∧
        ∀P h t.
          LFILTER P (h:::t) = if P h then h:::LFILTER P t else LFILTER P t
   
   [<a name="LFILTER_fromList-val"><b>LFILTER_fromList</b></a>]  Theorem
      
      ⊢ ∀p l. LFILTER p (fromList l) = fromList (FILTER p l)
   
   [<a name="LFILTER_fromSeq-val"><b>LFILTER_fromSeq</b></a>]  Theorem
      
      ⊢ ∀p f.
          LFILTER p (fromSeq f) =
          if ∀i. ¬p (f i) then [||]
          else if p (f 0) then f 0:::LFILTER p (fromSeq (f ∘ SUC))
          else LFILTER p (fromSeq (f ∘ SUC))
   
   [<a name="LFINITE-val"><b>LFINITE</b></a>]  Theorem
      
      ⊢ LFINITE ll ⇔ ∃n. LTAKE n ll = NONE
   
   [<a name="LFINITE_APPEND-val"><b>LFINITE_APPEND</b></a>]  Theorem
      
      ⊢ ∀ll1 ll2. LFINITE (LAPPEND ll1 ll2) ⇔ LFINITE ll1 ∧ LFINITE ll2
   
   [<a name="LFINITE_DROP-val"><b>LFINITE_DROP</b></a>]  Theorem
      
      ⊢ ∀n ll. LFINITE ll ∧ n ≤ THE (LLENGTH ll) ⇒ ∃y. LDROP n ll = SOME y
   
   [<a name="LFINITE_HAS_LENGTH-val"><b>LFINITE_HAS_LENGTH</b></a>]  Theorem
      
      ⊢ ∀ll. LFINITE ll ⇒ ∃n. LLENGTH ll = SOME n
   
   [<a name="LFINITE_IMP_fromList-val"><b>LFINITE_IMP_fromList</b></a>]  Theorem
      
      ⊢ ∀ll. LFINITE ll ⇒ ∃l. ll = fromList l
   
   [<a name="LFINITE_INDUCTION-val"><b>LFINITE_INDUCTION</b></a>]  Theorem
      
      ⊢ ∀P. P [||] ∧ (∀h t. P t ⇒ P (h:::t)) ⇒ ∀a0. LFINITE a0 ⇒ P a0
   
   [<a name="LFINITE_LAPPEND_IMP_NIL-val"><b>LFINITE_LAPPEND_IMP_NIL</b></a>]  Theorem
      
      ⊢ ∀ll. LFINITE ll ⇒ ∀l2. LAPPEND ll l2 = ll ⇒ l2 = [||]
   
   [<a name="LFINITE_LFLATTEN-val"><b>LFINITE_LFLATTEN</b></a>]  Theorem
      
      ⊢ ∀lll.
          every (λll. LFINITE ll ∧ ll ≠ [||]) lll ⇒
          (LFINITE (LFLATTEN lll) ⇔ LFINITE lll)
   
   [<a name="LFINITE_LGENLIST-val"><b>LFINITE_LGENLIST</b></a>]  Theorem
      
      ⊢ LFINITE (LGENLIST f n) ⇔ n ≠ NONE
   
   [<a name="LFINITE_LLENGTH-val"><b>LFINITE_LLENGTH</b></a>]  Theorem
      
      ⊢ LFINITE ll ⇔ ∃n. LLENGTH ll = SOME n
   
   [<a name="LFINITE_LNTH_NONE-val"><b>LFINITE_LNTH_NONE</b></a>]  Theorem
      
      ⊢ LFINITE ll ⇔ ∃n. LNTH n ll = NONE
   
   [<a name="LFINITE_MAP-val"><b>LFINITE_MAP</b></a>]  Theorem
      
      ⊢ ∀f ll. LFINITE (LMAP f ll) ⇔ LFINITE ll
   
   [<a name="LFINITE_STRONG_INDUCTION-val"><b>LFINITE_STRONG_INDUCTION</b></a>]  Theorem
      
      ⊢ P [||] ∧ (∀h t. LFINITE t ∧ P t ⇒ P (h:::t)) ⇒
        ∀a0. LFINITE a0 ⇒ P a0
   
   [<a name="LFINITE_TAKE-val"><b>LFINITE_TAKE</b></a>]  Theorem
      
      ⊢ ∀n ll. LFINITE ll ∧ n ≤ THE (LLENGTH ll) ⇒ ∃y. LTAKE n ll = SOME y
   
   [<a name="LFINITE_THM-val"><b>LFINITE_THM</b></a>]  Theorem
      
      ⊢ (LFINITE [||] ⇔ T) ∧ ∀h t. LFINITE (h:::t) ⇔ LFINITE t
   
   [<a name="LFINITE_cases-val"><b>LFINITE_cases</b></a>]  Theorem
      
      ⊢ ∀a0. LFINITE a0 ⇔ a0 = [||] ∨ ∃h t. a0 = h:::t ∧ LFINITE t
   
   [<a name="LFINITE_fromList-val"><b>LFINITE_fromList</b></a>]  Theorem
      
      ⊢ ∀l. LFINITE (fromList l)
   
   [<a name="LFINITE_fromSeq-val"><b>LFINITE_fromSeq</b></a>]  Theorem
      
      ⊢ ∀f. ¬LFINITE (fromSeq f)
   
   [<a name="LFINITE_ind-val"><b>LFINITE_ind</b></a>]  Theorem
      
      ⊢ ∀LFINITE'.
          LFINITE' [||] ∧ (∀h t. LFINITE' t ⇒ LFINITE' (h:::t)) ⇒
          ∀a0. LFINITE a0 ⇒ LFINITE' a0
   
   [<a name="LFINITE_rules-val"><b>LFINITE_rules</b></a>]  Theorem
      
      ⊢ LFINITE [||] ∧ ∀h t. LFINITE t ⇒ LFINITE (h:::t)
   
   [<a name="LFINITE_strongind-val"><b>LFINITE_strongind</b></a>]  Theorem
      
      ⊢ ∀LFINITE'.
          LFINITE' [||] ∧ (∀h t. LFINITE t ∧ LFINITE' t ⇒ LFINITE' (h:::t)) ⇒
          ∀a0. LFINITE a0 ⇒ LFINITE' a0
   
   [<a name="LFINITE_toList-val"><b>LFINITE_toList</b></a>]  Theorem
      
      ⊢ ∀ll. LFINITE ll ⇒ ∃l. toList ll = SOME l
   
   [<a name="LFINITE_toList_SOME-val"><b>LFINITE_toList_SOME</b></a>]  Theorem
      
      ⊢ LFINITE ll ⇔ IS_SOME (toList ll)
   
   [<a name="LFLATTEN_APPEND-val"><b>LFLATTEN_APPEND</b></a>]  Theorem
      
      ⊢ ∀h t. LFLATTEN (h:::t) = LAPPEND h (LFLATTEN t)
   
   [<a name="LFLATTEN_EQ_NIL-val"><b>LFLATTEN_EQ_NIL</b></a>]  Theorem
      
      ⊢ ∀ll. LFLATTEN ll = [||] ⇔ every ($= [||]) ll
   
   [<a name="LFLATTEN_SINGLETON-val"><b>LFLATTEN_SINGLETON</b></a>]  Theorem
      
      ⊢ ∀h. LFLATTEN [|h|] = h
   
   [<a name="LFLATTEN_THM-val"><b>LFLATTEN_THM</b></a>]  Theorem
      
      ⊢ LFLATTEN [||] = [||] ∧ (∀tl. LFLATTEN ([||]:::t) = LFLATTEN t) ∧
        ∀h t tl. LFLATTEN ((h:::t):::tl) = h:::LFLATTEN (t:::tl)
   
   [<a name="LFLATTEN_fromList-val"><b>LFLATTEN_fromList</b></a>]  Theorem
      
      ⊢ ∀l. LFLATTEN (fromList (MAP fromList l)) = fromList (FLAT l)
   
   [<a name="LGENLIST_CHUNK_GENLIST-val"><b>LGENLIST_CHUNK_GENLIST</b></a>]  Theorem
      
      ⊢ LGENLIST f NONE =
        LAPPEND (fromList (GENLIST f n)) (LGENLIST (f ∘ $+ n) NONE)
   
   [<a name="LGENLIST_EQ_CONS-val"><b>LGENLIST_EQ_CONS</b></a>]  Theorem
      
      ⊢ LGENLIST f NONE = h:::t ⇔ h = f 0 ∧ t = LGENLIST (f ∘ $+ 1) NONE
   
   [<a name="LGENLIST_EQ_LNIL-val"><b>LGENLIST_EQ_LNIL</b></a>]  Theorem
      
      ⊢ (LGENLIST f n = [||] ⇔ n = SOME 0) ∧
        ([||] = LGENLIST f n ⇔ n = SOME 0)
   
   [<a name="LGENLIST_EQ_fromList-val"><b>LGENLIST_EQ_fromList</b></a>]  Theorem
      
      ⊢ ∀f k. LGENLIST f (SOME k) = fromList (GENLIST f k)
   
   [<a name="LGENLIST_EQ_fromSeq-val"><b>LGENLIST_EQ_fromSeq</b></a>]  Theorem
      
      ⊢ ∀f. LGENLIST f NONE = fromSeq f
   
   [<a name="LGENLIST_SOME-val"><b>LGENLIST_SOME</b></a>]  Theorem
      
      ⊢ LGENLIST f (SOME 0) = [||] ∧
        ∀n. LGENLIST f (SOME (SUC n)) = f 0:::LGENLIST (f ∘ SUC) (SOME n)
   
   [<a name="LGENLIST_SOME_compute-val"><b>LGENLIST_SOME_compute</b></a>]  Theorem
      
      ⊢ LGENLIST f (SOME 0) = [||] ∧
        (∀n. LGENLIST f (SOME (NUMERAL (BIT1 n))) =
             f 0:::LGENLIST (f ∘ SUC) (SOME (NUMERAL (BIT1 n) − 1))) ∧
        ∀n. LGENLIST f (SOME (NUMERAL (BIT2 n))) =
            f 0:::LGENLIST (f ∘ SUC) (SOME (NUMERAL (BIT1 n)))
   
   [<a name="LHDTL_CONS_THM-val"><b>LHDTL_CONS_THM</b></a>]  Theorem
      
      ⊢ ∀h t. LHD (h:::t) = SOME h ∧ LTL (h:::t) = SOME t
   
   [<a name="LHDTL_EQ_SOME-val"><b>LHDTL_EQ_SOME</b></a>]  Theorem
      
      ⊢ ∀h t ll. ll = h:::t ⇔ LHD ll = SOME h ∧ LTL ll = SOME t
   
   [<a name="LHD_EQ_NONE-val"><b>LHD_EQ_NONE</b></a>]  Theorem
      
      ⊢ ∀ll. (LHD ll = NONE ⇔ ll = [||]) ∧ (NONE = LHD ll ⇔ ll = [||])
   
   [<a name="LHD_LAPPEND-val"><b>LHD_LAPPEND</b></a>]  Theorem
      
      ⊢ LHD (LAPPEND l1 l2) = if l1 = [||] then LHD l2 else LHD l1
   
   [<a name="LHD_LCONS-val"><b>LHD_LCONS</b></a>]  Theorem
      
      ⊢ LHD (h:::t) = SOME h
   
   [<a name="LHD_LGENLIST-val"><b>LHD_LGENLIST</b></a>]  Theorem
      
      ⊢ LHD (LGENLIST f limopt) =
        if limopt = SOME 0 then NONE else SOME (f 0)
   
   [<a name="LHD_LREPEAT-val"><b>LHD_LREPEAT</b></a>]  Theorem
      
      ⊢ LHD (LREPEAT l) = LHD (fromList l)
   
   [<a name="LHD_LUNFOLD-val"><b>LHD_LUNFOLD</b></a>]  Theorem
      
      ⊢ LHD (LUNFOLD f x) = OPTION_MAP SND (f x)
   
   [<a name="LHD_THM-val"><b>LHD_THM</b></a>]  Theorem
      
      ⊢ LHD [||] = NONE ∧ ∀h t. LHD (h:::t) = SOME h
   
   [<a name="LHD_fromList-val"><b>LHD_fromList</b></a>]  Theorem
      
      ⊢ LHD (fromList l) = if NULL l then NONE else SOME (HD l)
   
   [<a name="LHD_fromSeq-val"><b>LHD_fromSeq</b></a>]  Theorem
      
      ⊢ ∀f. LHD (fromSeq f) = SOME (f 0)
   
   [<a name="LLENGTH_0-val"><b>LLENGTH_0</b></a>]  Theorem
      
      ⊢ LLENGTH x = SOME 0 ⇔ x = [||]
   
   [<a name="LLENGTH_APPEND-val"><b>LLENGTH_APPEND</b></a>]  Theorem
      
      ⊢ ∀ll1 ll2.
          LLENGTH (LAPPEND ll1 ll2) =
          if LFINITE ll1 ∧ LFINITE ll2 then
            SOME (THE (LLENGTH ll1) + THE (LLENGTH ll2))
          else NONE
   
   [<a name="LLENGTH_LGENLIST-val"><b>LLENGTH_LGENLIST</b></a>]  Theorem
      
      ⊢ ∀f. LLENGTH (LGENLIST f limopt) = limopt
   
   [<a name="LLENGTH_LREPEAT-val"><b>LLENGTH_LREPEAT</b></a>]  Theorem
      
      ⊢ LLENGTH (LREPEAT l) = if NULL l then SOME 0 else NONE
   
   [<a name="LLENGTH_MAP-val"><b>LLENGTH_MAP</b></a>]  Theorem
      
      ⊢ ∀ll f. LLENGTH (LMAP f ll) = LLENGTH ll
   
   [<a name="LLENGTH_THM-val"><b>LLENGTH_THM</b></a>]  Theorem
      
      ⊢ LLENGTH [||] = SOME 0 ∧
        ∀h t. LLENGTH (h:::t) = OPTION_MAP SUC (LLENGTH t)
   
   [<a name="LLENGTH_fromList-val"><b>LLENGTH_fromList</b></a>]  Theorem
      
      ⊢ ∀l. LLENGTH (fromList l) = SOME (LENGTH l)
   
   [<a name="LLENGTH_fromSeq-val"><b>LLENGTH_fromSeq</b></a>]  Theorem
      
      ⊢ ∀f. LLENGTH (fromSeq f) = NONE
   
   [<a name="LLIST_BISIMULATION-val"><b>LLIST_BISIMULATION</b></a>]  Theorem
      
      ⊢ ∀ll1 ll2.
          ll1 = ll2 ⇔
          ∃R. R ll1 ll2 ∧
              ∀ll3 ll4.
                R ll3 ll4 ⇒
                ll3 = [||] ∧ ll4 = [||] ∨
                LHD ll3 = LHD ll4 ∧ R (THE (LTL ll3)) (THE (LTL ll4))
   
   [<a name="LLIST_BISIMULATION0-val"><b>LLIST_BISIMULATION0</b></a>]  Theorem
      
      ⊢ ∀ll1 ll2.
          ll1 = ll2 ⇔
          ∃R. R ll1 ll2 ∧
              ∀ll3 ll4.
                R ll3 ll4 ⇒
                ll3 = [||] ∧ ll4 = [||] ∨
                ∃h t1 t2. ll3 = h:::t1 ∧ ll4 = h:::t2 ∧ R t1 t2
   
   [<a name="LLIST_BISIMULATION_I-val"><b>LLIST_BISIMULATION_I</b></a>]  Theorem
      
      ⊢ ∀ll2 ll1.
          (∃R. R ll1 ll2 ∧
               ∀ll3 ll4.
                 R ll3 ll4 ⇒
                 ll3 = [||] ∧ ll4 = [||] ∨
                 LHD ll3 = LHD ll4 ∧ R (THE (LTL ll3)) (THE (LTL ll4))) ⇒
          ll1 = ll2
   
   [<a name="LLIST_BISIM_UPTO-val"><b>LLIST_BISIM_UPTO</b></a>]  Theorem
      
      ⊢ ∀ll1 ll2 R.
          R ll1 ll2 ∧
          (∀ll3 ll4.
             R ll3 ll4 ⇒
             ll3 = [||] ∧ ll4 = [||] ∨
             LHD ll3 = LHD ll4 ∧
             llist_upto R (THE (LTL ll3)) (THE (LTL ll4))) ⇒
          ll1 = ll2
   
   [<a name="LLIST_CASE_CONG-val"><b>LLIST_CASE_CONG</b></a>]  Theorem
      
      ⊢ ∀M M' v f.
          M = M' ∧ (M' = [||] ⇒ v = v') ∧
          (∀a0 a1. M' = a0:::a1 ⇒ f a0 a1 = f' a0 a1) ⇒
          llist_CASE M v f = llist_CASE M' v' f'
   
   [<a name="LLIST_CASE_EQ-val"><b>LLIST_CASE_EQ</b></a>]  Theorem
      
      ⊢ llist_CASE x v f = v' ⇔
        x = [||] ∧ v = v' ∨ ∃a l. x = a:::l ∧ f a l = v'
   
   [<a name="LLIST_DISTINCT-val"><b>LLIST_DISTINCT</b></a>]  Theorem
      
      ⊢ ∀a1 a0. [||] ≠ a0:::a1
   
   [<a name="LLIST_EQ-val"><b>LLIST_EQ</b></a>]  Theorem
      
      ⊢ ∀f g.
          (∀x. f x = [||] ∧ g x = [||] ∨
               ∃h y. f x = h:::f y ∧ g x = h:::g y) ⇒
          ∀x. f x = g x
   
   [<a name="LLIST_STRONG_BISIMULATION-val"><b>LLIST_STRONG_BISIMULATION</b></a>]  Theorem
      
      ⊢ ∀ll1 ll2.
          ll1 = ll2 ⇔
          ∃R. R ll1 ll2 ∧
              ∀ll3 ll4.
                R ll3 ll4 ⇒
                ll3 = ll4 ∨ ∃h t1 t2. ll3 = h:::t1 ∧ ll4 = h:::t2 ∧ R t1 t2
   
   [<a name="LL_ALL_THM-val"><b>LL_ALL_THM</b></a>]  Theorem
      
      ⊢ (every P [||] ⇔ T) ∧ (every P (h:::t) ⇔ P h ∧ every P t)
   
   [<a name="LMAP_APPEND-val"><b>LMAP_APPEND</b></a>]  Theorem
      
      ⊢ ∀f ll1 ll2.
          LMAP f (LAPPEND ll1 ll2) = LAPPEND (LMAP f ll1) (LMAP f ll2)
   
   [<a name="LMAP_LGENLIST-val"><b>LMAP_LGENLIST</b></a>]  Theorem
      
      ⊢ LMAP f (LGENLIST g limopt) = LGENLIST (f ∘ g) limopt
   
   [<a name="LMAP_LUNFOLD-val"><b>LMAP_LUNFOLD</b></a>]  Theorem
      
      ⊢ ∀f g s.
          LMAP f (LUNFOLD g s) =
          LUNFOLD (λs. OPTION_MAP (λ(x,y). (x,f y)) (g s)) s
   
   [<a name="LMAP_MAP-val"><b>LMAP_MAP</b></a>]  Theorem
      
      ⊢ ∀f g ll. LMAP f (LMAP g ll) = LMAP (f ∘ g) ll
   
   [<a name="LMAP_fromList-val"><b>LMAP_fromList</b></a>]  Theorem
      
      ⊢ LMAP f (fromList l) = fromList (MAP f l)
   
   [<a name="LMAP_fromSeq-val"><b>LMAP_fromSeq</b></a>]  Theorem
      
      ⊢ ∀f g. LMAP f (fromSeq g) = fromSeq (f ∘ g)
   
   [<a name="LNTH_ADD-val"><b>LNTH_ADD</b></a>]  Theorem
      
      ⊢ ∀a b ll. LNTH (a + b) ll = OPTION_BIND (LDROP a ll) (LNTH b)
   
   [<a name="LNTH_EQ-val"><b>LNTH_EQ</b></a>]  Theorem
      
      ⊢ ∀ll1 ll2. ll1 = ll2 ⇔ ∀n. LNTH n ll1 = LNTH n ll2
   
   [<a name="LNTH_HD_LDROP-val"><b>LNTH_HD_LDROP</b></a>]  Theorem
      
      ⊢ ∀n ll. LNTH n ll = OPTION_BIND (LDROP n ll) LHD
   
   [<a name="LNTH_LAPPEND-val"><b>LNTH_LAPPEND</b></a>]  Theorem
      
      ⊢ LNTH n (LAPPEND l1 l2) =
        case LLENGTH l1 of
          NONE =&gt; LNTH n l1
        | SOME m =&gt; if n &lt; m then LNTH n l1 else LNTH (n − m) l2
   
   [<a name="LNTH_LDROP-val"><b>LNTH_LDROP</b></a>]  Theorem
      
      ⊢ ∀n l x. LNTH n l = SOME x ⇒ LHD (THE (LDROP n l)) = SOME x
   
   [<a name="LNTH_LGENLIST-val"><b>LNTH_LGENLIST</b></a>]  Theorem
      
      ⊢ ∀n f lim.
          LNTH n (LGENLIST f lim) =
          case lim of
            NONE =&gt; SOME (f n)
          | SOME lim0 =&gt; if n &lt; lim0 then SOME (f n) else NONE
   
   [<a name="LNTH_LLENGTH_NONE-val"><b>LNTH_LLENGTH_NONE</b></a>]  Theorem
      
      ⊢ LLENGTH l = SOME x ∧ x ≤ n ⇒ LNTH n l = NONE
   
   [<a name="LNTH_LMAP-val"><b>LNTH_LMAP</b></a>]  Theorem
      
      ⊢ ∀n f l. LNTH n (LMAP f l) = OPTION_MAP f (LNTH n l)
   
   [<a name="LNTH_LUNFOLD-val"><b>LNTH_LUNFOLD</b></a>]  Theorem
      
      ⊢ LNTH 0 (LUNFOLD f x) = OPTION_MAP SND (f x) ∧
        LNTH (SUC n) (LUNFOLD f x) =
        case f x of NONE =&gt; NONE | SOME (tx,hx) =&gt; LNTH n (LUNFOLD f tx)
   
   [<a name="LNTH_LUNFOLD_compute-val"><b>LNTH_LUNFOLD_compute</b></a>]  Theorem
      
      ⊢ LNTH 0 (LUNFOLD f x) = OPTION_MAP SND (f x) ∧
        (∀n. LNTH (NUMERAL (BIT1 n)) (LUNFOLD f x) =
             case f x of
               NONE =&gt; NONE
             | SOME (tx,hx) =&gt; LNTH (NUMERAL (BIT1 n) − 1) (LUNFOLD f tx)) ∧
        ∀n. LNTH (NUMERAL (BIT2 n)) (LUNFOLD f x) =
            case f x of
              NONE =&gt; NONE
            | SOME (tx,hx) =&gt; LNTH (NUMERAL (BIT1 n)) (LUNFOLD f tx)
   
   [<a name="LNTH_NONE_MONO-val"><b>LNTH_NONE_MONO</b></a>]  Theorem
      
      ⊢ ∀m n l. LNTH m l = NONE ∧ m ≤ n ⇒ LNTH n l = NONE
   
   [<a name="LNTH_THM-val"><b>LNTH_THM</b></a>]  Theorem
      
      ⊢ (∀n. LNTH n [||] = NONE) ∧ (∀h t. LNTH 0 (h:::t) = SOME h) ∧
        ∀n h t. LNTH (SUC n) (h:::t) = LNTH n t
   
   [<a name="LNTH_fromList-val"><b>LNTH_fromList</b></a>]  Theorem
      
      ⊢ ∀n xs.
          LNTH n (fromList xs) =
          if n &lt; LENGTH xs then SOME (EL n xs) else NONE
   
   [<a name="LNTH_fromSeq-val"><b>LNTH_fromSeq</b></a>]  Theorem
      
      ⊢ ∀n f. LNTH n (fromSeq f) = SOME (f n)
   
   [<a name="LNTH_rep-val"><b>LNTH_rep</b></a>]  Theorem
      
      ⊢ ∀i ll. LNTH i ll = llist_rep ll i
   
   [<a name="LPREFIX_ANTISYM-val"><b>LPREFIX_ANTISYM</b></a>]  Theorem
      
      ⊢ LPREFIX l1 l2 ∧ LPREFIX l2 l1 ⇒ l1 = l2
   
   [<a name="LPREFIX_APPEND-val"><b>LPREFIX_APPEND</b></a>]  Theorem
      
      ⊢ LPREFIX l1 l2 ⇔ ∃ll. l2 = LAPPEND l1 ll
   
   [<a name="LPREFIX_LCONS-val"><b>LPREFIX_LCONS</b></a>]  Theorem
      
      ⊢ (∀ll h t.
           LPREFIX ll (h:::t) ⇔ ll = [||] ∨ ∃l. ll = h:::l ∧ LPREFIX l t) ∧
        ∀h t ll. LPREFIX (h:::t) ll ⇔ ∃l. ll = h:::l ∧ LPREFIX t l
   
   [<a name="LPREFIX_LNIL-val"><b>LPREFIX_LNIL</b></a>]  Theorem
      
      ⊢ LPREFIX [||] ll ∧ (LPREFIX ll [||] ⇔ ll = [||])
   
   [<a name="LPREFIX_LUNFOLD-val"><b>LPREFIX_LUNFOLD</b></a>]  Theorem
      
      ⊢ LPREFIX ll (LUNFOLD f n) ⇔
        case f n of
          NONE =&gt; ll = [||]
        | SOME (n,x) =&gt; ∀h t. ll = h:::t ⇒ h = x ∧ LPREFIX t (LUNFOLD f n)
   
   [<a name="LPREFIX_NTH-val"><b>LPREFIX_NTH</b></a>]  Theorem
      
      ⊢ LPREFIX l1 l2 ⇔ ∀i v. LNTH i l1 = SOME v ⇒ LNTH i l2 = SOME v
   
   [<a name="LPREFIX_REFL-val"><b>LPREFIX_REFL</b></a>]  Theorem
      
      ⊢ LPREFIX ll ll
   
   [<a name="LPREFIX_TRANS-val"><b>LPREFIX_TRANS</b></a>]  Theorem
      
      ⊢ LPREFIX l1 l2 ∧ LPREFIX l2 l3 ⇒ LPREFIX l1 l3
   
   [<a name="LPREFIX_fromList-val"><b>LPREFIX_fromList</b></a>]  Theorem
      
      ⊢ ∀l ll.
          LPREFIX (fromList l) ll ⇔
          case toList ll of
            NONE =&gt; LTAKE (LENGTH l) ll = SOME l
          | SOME ys =&gt; l ≼ ys
   
   [<a name="LREPEAT_EQ_LNIL-val"><b>LREPEAT_EQ_LNIL</b></a>]  Theorem
      
      ⊢ (LREPEAT l = [||] ⇔ l = []) ∧ ([||] = LREPEAT l ⇔ l = [])
   
   [<a name="LREPEAT_NIL-val"><b>LREPEAT_NIL</b></a>]  Theorem
      
      ⊢ LREPEAT [] = [||]
   
   [<a name="LREPEAT_thm-val"><b>LREPEAT_thm</b></a>]  Theorem
      
      ⊢ LREPEAT l = LAPPEND (fromList l) (LREPEAT l)
   
   [<a name="LSET-val"><b>LSET</b></a>]  Theorem
      
      ⊢ LSET [||] = ∅ ∧ LSET (x:::xs) = x INSERT LSET xs
   
   [<a name="LSUFFIX-val"><b>LSUFFIX</b></a>]  Theorem
      
      ⊢ (LSUFFIX l [||] ⇔ T) ∧ (LSUFFIX [||] (y:::ys) ⇔ F) ∧
        (LSUFFIX (x:::xs) l ⇔ x:::xs = l ∨ LSUFFIX xs l)
   
   [<a name="LSUFFIX_ANTISYM-val"><b>LSUFFIX_ANTISYM</b></a>]  Theorem
      
      ⊢ ∀x y. LSUFFIX x y ∧ LSUFFIX y x ∧ LFINITE x ⇒ x = y
   
   [<a name="LSUFFIX_REFL-val"><b>LSUFFIX_REFL</b></a>]  Theorem
      
      ⊢ ∀s. LSUFFIX s s
   
   [<a name="LSUFFIX_TRANS-val"><b>LSUFFIX_TRANS</b></a>]  Theorem
      
      ⊢ ∀x y z. LSUFFIX x y ∧ LSUFFIX y z ⇒ LSUFFIX x z
   
   [<a name="LSUFFIX_fromList-val"><b>LSUFFIX_fromList</b></a>]  Theorem
      
      ⊢ ∀xs ys. LSUFFIX (fromList xs) (fromList ys) ⇔ IS_SUFFIX xs ys
   
   [<a name="LTAKE_CONS_EQ_NONE-val"><b>LTAKE_CONS_EQ_NONE</b></a>]  Theorem
      
      ⊢ ∀m h t. LTAKE m (h:::t) = NONE ⇔ ∃n. m = SUC n ∧ LTAKE n t = NONE
   
   [<a name="LTAKE_CONS_EQ_SOME-val"><b>LTAKE_CONS_EQ_SOME</b></a>]  Theorem
      
      ⊢ ∀m h t l.
          LTAKE m (h:::t) = SOME l ⇔
          m = 0 ∧ l = [] ∨
          ∃n l'. m = SUC n ∧ LTAKE n t = SOME l' ∧ l = h::l'
   
   [<a name="LTAKE_DROP-val"><b>LTAKE_DROP</b></a>]  Theorem
      
      ⊢ (∀n ll.
           ¬LFINITE ll ⇒
           LAPPEND (fromList (THE (LTAKE n ll))) (THE (LDROP n ll)) = ll) ∧
        ∀n ll.
          LFINITE ll ∧ n ≤ THE (LLENGTH ll) ⇒
          LAPPEND (fromList (THE (LTAKE n ll))) (THE (LDROP n ll)) = ll
   
   [<a name="LTAKE_EQ-val"><b>LTAKE_EQ</b></a>]  Theorem
      
      ⊢ ∀ll1 ll2. ll1 = ll2 ⇔ ∀n. LTAKE n ll1 = LTAKE n ll2
   
   [<a name="LTAKE_EQ_NONE_LNTH-val"><b>LTAKE_EQ_NONE_LNTH</b></a>]  Theorem
      
      ⊢ ∀n ll. LTAKE n ll = NONE ⇒ LNTH n ll = NONE
   
   [<a name="LTAKE_EQ_SOME_CONS-val"><b>LTAKE_EQ_SOME_CONS</b></a>]  Theorem
      
      ⊢ ∀n l x. LTAKE n l = SOME x ⇒ ∀h. ∃y. LTAKE n (h:::l) = SOME y
   
   [<a name="LTAKE_IMP_LDROP-val"><b>LTAKE_IMP_LDROP</b></a>]  Theorem
      
      ⊢ ∀n ll l1.
          LTAKE n ll = SOME l1 ⇒
          ∃l2. LDROP n ll = SOME l2 ∧ LAPPEND (fromList l1) l2 = ll
   
   [<a name="LTAKE_LAPPEND1-val"><b>LTAKE_LAPPEND1</b></a>]  Theorem
      
      ⊢ ∀n l1 l2.
          IS_SOME (LTAKE n l1) ⇒ LTAKE n (LAPPEND l1 l2) = LTAKE n l1
   
   [<a name="LTAKE_LAPPEND2-val"><b>LTAKE_LAPPEND2</b></a>]  Theorem
      
      ⊢ ∀n l1 l2.
          LTAKE n l1 = NONE ⇒
          LTAKE n (LAPPEND l1 l2) =
          OPTION_MAP ($++ (THE (toList l1)))
            (LTAKE (n − THE (LLENGTH l1)) l2)
   
   [<a name="LTAKE_LAPPEND_fromList-val"><b>LTAKE_LAPPEND_fromList</b></a>]  Theorem
      
      ⊢ ∀ll l n.
          LTAKE (n + LENGTH l) (LAPPEND (fromList l) ll) =
          OPTION_MAP ($++ l) (LTAKE n ll)
   
   [<a name="LTAKE_LENGTH-val"><b>LTAKE_LENGTH</b></a>]  Theorem
      
      ⊢ ∀n ll l. LTAKE n ll = SOME l ⇒ n = LENGTH l
   
   [<a name="LTAKE_LLENGTH_NONE-val"><b>LTAKE_LLENGTH_NONE</b></a>]  Theorem
      
      ⊢ LLENGTH ll = SOME n ∧ n &lt; m ⇒ LTAKE m ll = NONE
   
   [<a name="LTAKE_LLENGTH_SOME-val"><b>LTAKE_LLENGTH_SOME</b></a>]  Theorem
      
      ⊢ LLENGTH ll = SOME n ⇒ ∃l. LTAKE n ll = SOME l ∧ toList ll = SOME l
   
   [<a name="LTAKE_LMAP-val"><b>LTAKE_LMAP</b></a>]  Theorem
      
      ⊢ ∀n f ll. LTAKE n (LMAP f ll) = OPTION_MAP (MAP f) (LTAKE n ll)
   
   [<a name="LTAKE_LNTH_EL-val"><b>LTAKE_LNTH_EL</b></a>]  Theorem
      
      ⊢ ∀n ll m l. LTAKE n ll = SOME l ∧ m &lt; n ⇒ LNTH m ll = SOME (EL m l)
   
   [<a name="LTAKE_LPREFIX-val"><b>LTAKE_LPREFIX</b></a>]  Theorem
      
      ⊢ ∀x ll.
          ¬LFINITE ll ⇒ ∃l. LTAKE x ll = SOME l ∧ LPREFIX (fromList l) ll
   
   [<a name="LTAKE_LUNFOLD-val"><b>LTAKE_LUNFOLD</b></a>]  Theorem
      
      ⊢ LTAKE 0 (LUNFOLD f x) = SOME [] ∧
        LTAKE (SUC n) (LUNFOLD f x) =
        case f x of
          NONE =&gt; NONE
        | SOME (tx,hx) =&gt; OPTION_MAP (CONS hx) (LTAKE n (LUNFOLD f tx))
   
   [<a name="LTAKE_NIL_EQ_NONE-val"><b>LTAKE_NIL_EQ_NONE</b></a>]  Theorem
      
      ⊢ ∀m. LTAKE m [||] = NONE ⇔ 0 &lt; m
   
   [<a name="LTAKE_NIL_EQ_SOME-val"><b>LTAKE_NIL_EQ_SOME</b></a>]  Theorem
      
      ⊢ ∀l m. LTAKE m [||] = SOME l ⇔ m = 0 ∧ l = []
   
   [<a name="LTAKE_SNOC_LNTH-val"><b>LTAKE_SNOC_LNTH</b></a>]  Theorem
      
      ⊢ ∀n ll.
          LTAKE (SUC n) ll =
          case LTAKE n ll of
            NONE =&gt; NONE
          | SOME l =&gt;
            case LNTH n ll of NONE =&gt; NONE | SOME e =&gt; SOME (l ⧺ [e])
   
   [<a name="LTAKE_TAKE_LESS-val"><b>LTAKE_TAKE_LESS</b></a>]  Theorem
      
      ⊢ LTAKE n ll = SOME l ∧ m ≤ n ⇒ LTAKE m ll = SOME (TAKE m l)
   
   [<a name="LTAKE_THM-val"><b>LTAKE_THM</b></a>]  Theorem
      
      ⊢ (∀l. LTAKE 0 l = SOME []) ∧ (∀n. LTAKE (SUC n) [||] = NONE) ∧
        ∀n h t. LTAKE (SUC n) (h:::t) = OPTION_MAP (CONS h) (LTAKE n t)
   
   [<a name="LTAKE_fromList-val"><b>LTAKE_fromList</b></a>]  Theorem
      
      ⊢ ∀l. LTAKE (LENGTH l) (fromList l) = SOME l
   
   [<a name="LTAKE_fromSeq-val"><b>LTAKE_fromSeq</b></a>]  Theorem
      
      ⊢ ∀n f. LTAKE n (fromSeq f) = SOME (GENLIST f n)
   
   [<a name="LTL_EQ_NONE-val"><b>LTL_EQ_NONE</b></a>]  Theorem
      
      ⊢ ∀ll. (LTL ll = NONE ⇔ ll = [||]) ∧ (NONE = LTL ll ⇔ ll = [||])
   
   [<a name="LTL_HD_11-val"><b>LTL_HD_11</b></a>]  Theorem
      
      ⊢ LTL_HD ll1 = LTL_HD ll2 ⇒ ll1 = ll2
   
   [<a name="LTL_HD_HD-val"><b>LTL_HD_HD</b></a>]  Theorem
      
      ⊢ LHD ll = OPTION_MAP SND (LTL_HD ll)
   
   [<a name="LTL_HD_LCONS-val"><b>LTL_HD_LCONS</b></a>]  Theorem
      
      ⊢ LTL_HD (h:::t) = SOME (t,h)
   
   [<a name="LTL_HD_LNIL-val"><b>LTL_HD_LNIL</b></a>]  Theorem
      
      ⊢ LTL_HD [||] = NONE
   
   [<a name="LTL_HD_LTL_LHD-val"><b>LTL_HD_LTL_LHD</b></a>]  Theorem
      
      ⊢ LTL_HD l =
        OPTION_BIND (LHD l) (λh. OPTION_BIND (LTL l) (λt. SOME (t,h)))
   
   [<a name="LTL_HD_LUNFOLD-val"><b>LTL_HD_LUNFOLD</b></a>]  Theorem
      
      ⊢ LTL_HD (LUNFOLD f x) = OPTION_MAP (LUNFOLD f ## I) (f x)
   
   [<a name="LTL_HD_TL-val"><b>LTL_HD_TL</b></a>]  Theorem
      
      ⊢ LTL ll = OPTION_MAP FST (LTL_HD ll)
   
   [<a name="LTL_HD_iff-val"><b>LTL_HD_iff</b></a>]  Theorem
      
      ⊢ (LTL_HD x = SOME (t,h) ⇔ x = h:::t) ∧ (LTL_HD x = NONE ⇔ x = [||])
   
   [<a name="LTL_LAPPEND-val"><b>LTL_LAPPEND</b></a>]  Theorem
      
      ⊢ LTL (LAPPEND l1 l2) =
        if l1 = [||] then LTL l2 else SOME (LAPPEND (THE (LTL l1)) l2)
   
   [<a name="LTL_LCONS-val"><b>LTL_LCONS</b></a>]  Theorem
      
      ⊢ LTL (h:::t) = SOME t
   
   [<a name="LTL_LGENLIST-val"><b>LTL_LGENLIST</b></a>]  Theorem
      
      ⊢ LTL (LGENLIST f limopt) =
        if limopt = SOME 0 then NONE
        else SOME (LGENLIST (f ∘ SUC) (OPTION_MAP PRE limopt))
   
   [<a name="LTL_LREPEAT-val"><b>LTL_LREPEAT</b></a>]  Theorem
      
      ⊢ LTL (LREPEAT l) =
        OPTION_MAP (λt. LAPPEND t (LREPEAT l)) (LTL (fromList l))
   
   [<a name="LTL_LUNFOLD-val"><b>LTL_LUNFOLD</b></a>]  Theorem
      
      ⊢ LTL (LUNFOLD f x) = OPTION_MAP (LUNFOLD f ∘ FST) (f x)
   
   [<a name="LTL_THM-val"><b>LTL_THM</b></a>]  Theorem
      
      ⊢ LTL [||] = NONE ∧ ∀h t. LTL (h:::t) = SOME t
   
   [<a name="LTL_fromList-val"><b>LTL_fromList</b></a>]  Theorem
      
      ⊢ LTL (fromList l) = if NULL l then NONE else SOME (fromList (TL l))
   
   [<a name="LTL_fromSeq-val"><b>LTL_fromSeq</b></a>]  Theorem
      
      ⊢ ∀f. LTL (fromSeq f) = SOME (fromSeq (f ∘ SUC))
   
   [<a name="LUNFOLD-val"><b>LUNFOLD</b></a>]  Theorem
      
      ⊢ ∀f x.
          LUNFOLD f x =
          case f x of NONE =&gt; [||] | SOME (v1,v2) =&gt; v2:::LUNFOLD f v1
   
   [<a name="LUNFOLD_BISIMULATION-val"><b>LUNFOLD_BISIMULATION</b></a>]  Theorem
      
      ⊢ ∀f1 f2 x1 x2.
          LUNFOLD f1 x1 = LUNFOLD f2 x2 ⇔
          ∃R. R x1 x2 ∧
              ∀y1 y2.
                R y1 y2 ⇒
                f1 y1 = NONE ∧ f2 y2 = NONE ∨
                ∃h t1 t2.
                  f1 y1 = SOME (t1,h) ∧ f2 y2 = SOME (t2,h) ∧ R t1 t2
   
   [<a name="LUNFOLD_EQ-val"><b>LUNFOLD_EQ</b></a>]  Theorem
      
      ⊢ ∀R f s ll.
          R s ll ∧
          (∀s ll.
             R s ll ⇒
             f s = NONE ∧ ll = [||] ∨
             ∃s' x ll'.
               f s = SOME (s',x) ∧ LHD ll = SOME x ∧ LTL ll = SOME ll' ∧
               R s' ll') ⇒
          LUNFOLD f s = ll
   
   [<a name="LUNFOLD_LTL_HD-val"><b>LUNFOLD_LTL_HD</b></a>]  Theorem
      
      ⊢ LUNFOLD LTL_HD ll = ll
   
   [<a name="LUNFOLD_THM-val"><b>LUNFOLD_THM</b></a>]  Theorem
      
      ⊢ ∀f x v1 v2.
          (f x = NONE ⇒ LUNFOLD f x = [||]) ∧
          (f x = SOME (v1,v2) ⇒ LUNFOLD f x = v2:::LUNFOLD f v1)
   
   [<a name="LUNFOLD_UNIQUE-val"><b>LUNFOLD_UNIQUE</b></a>]  Theorem
      
      ⊢ ∀f g.
          (∀x. g x = case f x of NONE =&gt; [||] | SOME (v1,v2) =&gt; v2:::g v1) ⇒
          ∀y. g y = LUNFOLD f y
   
   [<a name="LZIP_LUNZIP-val"><b>LZIP_LUNZIP</b></a>]  Theorem
      
      ⊢ ∀ll. LZIP (LUNZIP ll) = ll
   
   [<a name="MONO_every-val"><b>MONO_every</b></a>]  Theorem
      
      ⊢ (∀x. P x ⇒ Q x) ⇒ every P l ⇒ every Q l
   
   [<a name="MONO_exists-val"><b>MONO_exists</b></a>]  Theorem
      
      ⊢ (∀x. P x ⇒ Q x) ⇒ exists P l ⇒ exists Q l
   
   [<a name="NOT_LFINITE_APPEND-val"><b>NOT_LFINITE_APPEND</b></a>]  Theorem
      
      ⊢ ∀ll1 ll2. ¬LFINITE ll1 ⇒ LAPPEND ll1 ll2 = ll1
   
   [<a name="NOT_LFINITE_DROP-val"><b>NOT_LFINITE_DROP</b></a>]  Theorem
      
      ⊢ ∀ll. ¬LFINITE ll ⇒ ∀n. ∃y. LDROP n ll = SOME y
   
   [<a name="NOT_LFINITE_DROP_LFINITE-val"><b>NOT_LFINITE_DROP_LFINITE</b></a>]  Theorem
      
      ⊢ ∀n l t. ¬LFINITE l ∧ LDROP n l = SOME t ⇒ ¬LFINITE t
   
   [<a name="NOT_LFINITE_IMP_fromSeq-val"><b>NOT_LFINITE_IMP_fromSeq</b></a>]  Theorem
      
      ⊢ ∀ll. ¬LFINITE ll ⇒ ∃f. ll = fromSeq f
   
   [<a name="NOT_LFINITE_NO_LENGTH-val"><b>NOT_LFINITE_NO_LENGTH</b></a>]  Theorem
      
      ⊢ ∀ll. ¬LFINITE ll ⇒ LLENGTH ll = NONE
   
   [<a name="NOT_LFINITE_TAKE-val"><b>NOT_LFINITE_TAKE</b></a>]  Theorem
      
      ⊢ ∀ll. ¬LFINITE ll ⇒ ∀n. ∃y. LTAKE n ll = SOME y
   
   [<a name="always_DROP-val"><b>always_DROP</b></a>]  Theorem
      
      ⊢ ∀ll. always P ll ⇒ always P (THE (LDROP k ll))
   
   [<a name="always_cases-val"><b>always_cases</b></a>]  Theorem
      
      ⊢ ∀P a0. always P a0 ⇔ ∃h t. a0 = h:::t ∧ P (h:::t) ∧ always P t
   
   [<a name="always_coind-val"><b>always_coind</b></a>]  Theorem
      
      ⊢ ∀P always'.
          (∀a0. always' a0 ⇒ ∃h t. a0 = h:::t ∧ P (h:::t) ∧ always' t) ⇒
          ∀a0. always' a0 ⇒ always P a0
   
   [<a name="always_conj_l-val"><b>always_conj_l</b></a>]  Theorem
      
      ⊢ ∀ll. always (λx. P x ∧ Q x) ll ⇒ always P ll
   
   [<a name="always_eventually_ind-val"><b>always_eventually_ind</b></a>]  Theorem
      
      ⊢ (∀ll. P ll ∨ ¬P ll ∧ Q (THE (LTL ll)) ⇒ Q ll) ⇒
        ∀ll. ll ≠ [||] ⇒ always (eventually P) ll ⇒ Q ll
   
   [<a name="always_rules-val"><b>always_rules</b></a>]  Theorem
      
      ⊢ ∀P h t. P (h:::t) ∧ always P t ⇒ always P (h:::t)
   
   [<a name="always_thm-val"><b>always_thm</b></a>]  Theorem
      
      ⊢ (always P [||] ⇔ F) ∧
        ∀h t. always P (h:::t) ⇔ P (h:::t) ∧ always P t
   
   [<a name="eventually_cases-val"><b>eventually_cases</b></a>]  Theorem
      
      ⊢ ∀P a0. eventually P a0 ⇔ P a0 ∨ ∃h t. a0 = h:::t ∧ eventually P t
   
   [<a name="eventually_ind-val"><b>eventually_ind</b></a>]  Theorem
      
      ⊢ ∀P eventually'.
          (∀ll. P ll ⇒ eventually' ll) ∧
          (∀h t. eventually' t ⇒ eventually' (h:::t)) ⇒
          ∀a0. eventually P a0 ⇒ eventually' a0
   
   [<a name="eventually_rules-val"><b>eventually_rules</b></a>]  Theorem
      
      ⊢ ∀P. (∀ll. P ll ⇒ eventually P ll) ∧
            ∀h t. eventually P t ⇒ eventually P (h:::t)
   
   [<a name="eventually_strongind-val"><b>eventually_strongind</b></a>]  Theorem
      
      ⊢ ∀P eventually'.
          (∀ll. P ll ⇒ eventually' ll) ∧
          (∀h t. eventually P t ∧ eventually' t ⇒ eventually' (h:::t)) ⇒
          ∀a0. eventually P a0 ⇒ eventually' a0
   
   [<a name="eventually_thm-val"><b>eventually_thm</b></a>]  Theorem
      
      ⊢ (eventually P [||] ⇔ P [||]) ∧
        (eventually P (h:::t) ⇔ P (h:::t) ∨ eventually P t)
   
   [<a name="eventually_until_EQN-val"><b>eventually_until_EQN</b></a>]  Theorem
      
      ⊢ eventually P = until (K T) P
   
   [<a name="every_LAPPEND1-val"><b>every_LAPPEND1</b></a>]  Theorem
      
      ⊢ ∀P ll1 ll2. every P (LAPPEND ll1 ll2) ⇒ every P ll1
   
   [<a name="every_LAPPEND2_LFINITE-val"><b>every_LAPPEND2_LFINITE</b></a>]  Theorem
      
      ⊢ ∀l P ll. LFINITE l ∧ every P (LAPPEND l ll) ⇒ every P ll
   
   [<a name="every_LDROP-val"><b>every_LDROP</b></a>]  Theorem
      
      ⊢ ∀f i ll1 ll2. every f ll1 ∧ LDROP i ll1 = SOME ll2 ⇒ every f ll2
   
   [<a name="every_LFILTER-val"><b>every_LFILTER</b></a>]  Theorem
      
      ⊢ ∀ll P. every P (LFILTER P ll)
   
   [<a name="every_LFILTER_imp-val"><b>every_LFILTER_imp</b></a>]  Theorem
      
      ⊢ ∀Q P ll. every Q ll ⇒ every Q (LFILTER P ll)
   
   [<a name="every_LNTH-val"><b>every_LNTH</b></a>]  Theorem
      
      ⊢ ∀P ll. every P ll ⇔ ∀n e. LNTH n ll = SOME e ⇒ P e
   
   [<a name="every_coind-val"><b>every_coind</b></a>]  Theorem
      
      ⊢ ∀P Q. (∀h t. Q (h:::t) ⇒ P h ∧ Q t) ⇒ ∀ll. Q ll ⇒ every P ll
   
   [<a name="every_fromList_EVERY-val"><b>every_fromList_EVERY</b></a>]  Theorem
      
      ⊢ ∀l P. every P (fromList l) ⇔ EVERY P l
   
   [<a name="every_fromSeq-val"><b>every_fromSeq</b></a>]  Theorem
      
      ⊢ ∀p f. every p (fromSeq f) ⇔ ∀i. p (f i)
   
   [<a name="every_strong_coind-val"><b>every_strong_coind</b></a>]  Theorem
      
      ⊢ ∀P Q.
          (∀h t. Q (h:::t) ⇒ P h) ∧ (∀h t. Q (h:::t) ⇒ Q t ∨ every P t) ⇒
          ∀ll. Q ll ⇒ every P ll
   
   [<a name="every_thm-val"><b>every_thm</b></a>]  Theorem
      
      ⊢ (every P [||] ⇔ T) ∧ (every P (h:::t) ⇔ P h ∧ every P t)
   
   [<a name="exists_LDROP-val"><b>exists_LDROP</b></a>]  Theorem
      
      ⊢ exists P ll ⇔ ∃n a t. LDROP n ll = SOME (a:::t) ∧ P a
   
   [<a name="exists_LNTH-val"><b>exists_LNTH</b></a>]  Theorem
      
      ⊢ ∀l. exists P l ⇔ ∃n e. SOME e = LNTH n l ∧ P e
   
   [<a name="exists_cases-val"><b>exists_cases</b></a>]  Theorem
      
      ⊢ ∀P a0.
          exists P a0 ⇔
          (∃h t. a0 = h:::t ∧ P h) ∨ ∃h t. a0 = h:::t ∧ exists P t
   
   [<a name="exists_fromSeq-val"><b>exists_fromSeq</b></a>]  Theorem
      
      ⊢ ∀p f. exists p (fromSeq f) ⇔ ∃i. p (f i)
   
   [<a name="exists_ind-val"><b>exists_ind</b></a>]  Theorem
      
      ⊢ ∀P exists'.
          (∀h t. P h ⇒ exists' (h:::t)) ∧
          (∀h t. exists' t ⇒ exists' (h:::t)) ⇒
          ∀a0. exists P a0 ⇒ exists' a0
   
   [<a name="exists_rules-val"><b>exists_rules</b></a>]  Theorem
      
      ⊢ ∀P. (∀h t. P h ⇒ exists P (h:::t)) ∧
            ∀h t. exists P t ⇒ exists P (h:::t)
   
   [<a name="exists_strong_ind-val"><b>exists_strong_ind</b></a>]  Theorem
      
      ⊢ ∀P Q.
          (∀h t. P h ⇒ Q (h:::t)) ∧ (∀h t. Q t ∧ exists P t ⇒ Q (h:::t)) ⇒
          ∀a0. exists P a0 ⇒ Q a0
   
   [<a name="exists_strongind-val"><b>exists_strongind</b></a>]  Theorem
      
      ⊢ ∀P exists'.
          (∀h t. P h ⇒ exists' (h:::t)) ∧
          (∀h t. exists P t ∧ exists' t ⇒ exists' (h:::t)) ⇒
          ∀a0. exists P a0 ⇒ exists' a0
   
   [<a name="exists_thm-val"><b>exists_thm</b></a>]  Theorem
      
      ⊢ (exists P [||] ⇔ F) ∧ (exists P (h:::t) ⇔ P h ∨ exists P t)
   
   [<a name="exists_thm_strong-val"><b>exists_thm_strong</b></a>]  Theorem
      
      ⊢ exists P ll ⇔
        ∃n a t l.
          LDROP n ll = SOME (a:::t) ∧ P a ∧ LTAKE n ll = SOME l ∧
          EVERY ($¬ ∘ P) l
   
   [<a name="fromList_11-val"><b>fromList_11</b></a>]  Theorem
      
      ⊢ ∀xs ys. fromList xs = fromList ys ⇔ xs = ys
   
   [<a name="fromList_EQ_LNIL-val"><b>fromList_EQ_LNIL</b></a>]  Theorem
      
      ⊢ fromList l = [||] ⇔ l = []
   
   [<a name="fromList_NEQ_fromSeq-val"><b>fromList_NEQ_fromSeq</b></a>]  Theorem
      
      ⊢ ∀l f. fromList l ≠ fromSeq f
   
   [<a name="fromList_fromSeq-val"><b>fromList_fromSeq</b></a>]  Theorem
      
      ⊢ ∀ll. (∃l. ll = fromList l) ∨ ∃f. ll = fromSeq f
   
   [<a name="fromSeq_11-val"><b>fromSeq_11</b></a>]  Theorem
      
      ⊢ ∀f g. fromSeq f = fromSeq g ⇔ f = g
   
   [<a name="fromSeq_LCONS-val"><b>fromSeq_LCONS</b></a>]  Theorem
      
      ⊢ fromSeq f = f 0:::fromSeq (f ∘ SUC)
   
   [<a name="from_toList-val"><b>from_toList</b></a>]  Theorem
      
      ⊢ ∀l. toList (fromList l) = SOME l
   
   [<a name="infinite_lnth_some-val"><b>infinite_lnth_some</b></a>]  Theorem
      
      ⊢ ∀ll. ¬LFINITE ll ⇔ ∀n. ∃x. LNTH n ll = SOME x
   
   [<a name="linear_order_to_llist-val"><b>linear_order_to_llist</b></a>]  Theorem
      
      ⊢ ∀lo X.
          linear_order lo X ∧ finite_prefixes lo X ⇒
          ∃ll.
            X = {x | ∃i. LNTH i ll = SOME x} ∧
            lo ⊆
            {(x,y) | ∃i j. i ≤ j ∧ LNTH i ll = SOME x ∧ LNTH j ll = SOME y} ∧
            ∀i j x. LNTH i ll = SOME x ∧ LNTH j ll = SOME x ⇒ i = j
   
   [<a name="linear_order_to_llist_eq-val"><b>linear_order_to_llist_eq</b></a>]  Theorem
      
      ⊢ ∀lo X.
          linear_order lo X ∧ finite_prefixes lo X ⇒
          ∃ll.
            X = {x | ∃i. LNTH i ll = SOME x} ∧
            lo =
            {(x,y) | ∃i j. i ≤ j ∧ LNTH i ll = SOME x ∧ LNTH j ll = SOME y} ∧
            ∀i j x. LNTH i ll = SOME x ∧ LNTH j ll = SOME x ⇒ i = j
   
   [<a name="llength_rel_cases-val"><b>llength_rel_cases</b></a>]  Theorem
      
      ⊢ ∀a0 a1.
          llength_rel a0 a1 ⇔
          a0 = [||] ∧ a1 = 0 ∨
          ∃h n t. a0 = h:::t ∧ a1 = SUC n ∧ llength_rel t n
   
   [<a name="llength_rel_ind-val"><b>llength_rel_ind</b></a>]  Theorem
      
      ⊢ ∀llength_rel'.
          llength_rel' [||] 0 ∧
          (∀h n t. llength_rel' t n ⇒ llength_rel' (h:::t) (SUC n)) ⇒
          ∀a0 a1. llength_rel a0 a1 ⇒ llength_rel' a0 a1
   
   [<a name="llength_rel_rules-val"><b>llength_rel_rules</b></a>]  Theorem
      
      ⊢ llength_rel [||] 0 ∧
        ∀h n t. llength_rel t n ⇒ llength_rel (h:::t) (SUC n)
   
   [<a name="llength_rel_strongind-val"><b>llength_rel_strongind</b></a>]  Theorem
      
      ⊢ ∀llength_rel'.
          llength_rel' [||] 0 ∧
          (∀h n t.
             llength_rel t n ∧ llength_rel' t n ⇒
             llength_rel' (h:::t) (SUC n)) ⇒
          ∀a0 a1. llength_rel a0 a1 ⇒ llength_rel' a0 a1
   
   [<a name="llist_Axiom-val"><b>llist_Axiom</b></a>]  Theorem
      
      ⊢ ∀f. ∃g.
          (∀x. LHD (g x) = OPTION_MAP SND (f x)) ∧
          ∀x. LTL (g x) = OPTION_MAP (g ∘ FST) (f x)
   
   [<a name="llist_Axiom_1-val"><b>llist_Axiom_1</b></a>]  Theorem
      
      ⊢ ∀f. ∃g. ∀x. g x = case f x of NONE =&gt; [||] | SOME (a,b) =&gt; b:::g a
   
   [<a name="llist_Axiom_1ue-val"><b>llist_Axiom_1ue</b></a>]  Theorem
      
      ⊢ ∀f. ∃!g. ∀x. g x = case f x of NONE =&gt; [||] | SOME (a,b) =&gt; b:::g a
   
   [<a name="llist_CASES-val"><b>llist_CASES</b></a>]  Theorem
      
      ⊢ ∀l. l = [||] ∨ ∃h t. l = h:::t
   
   [<a name="llist_CASE_compute-val"><b>llist_CASE_compute</b></a>]  Theorem
      
      ⊢ llist_CASE [||] b f = b ∧ llist_CASE (x:::ll) b f = f x ll
   
   [<a name="llist_forall_split-val"><b>llist_forall_split</b></a>]  Theorem
      
      ⊢ ∀P. (∀ll. P ll) ⇔ (∀l. P (fromList l)) ∧ ∀f. P (fromSeq f)
   
   [<a name="llist_rep_LCONS-val"><b>llist_rep_LCONS</b></a>]  Theorem
      
      ⊢ llist_rep (h:::t) =
        (λn. if n = 0 then SOME h else llist_rep t (n − 1))
   
   [<a name="llist_rep_LNIL-val"><b>llist_rep_LNIL</b></a>]  Theorem
      
      ⊢ llist_rep [||] = (λn. NONE)
   
   [<a name="llist_ue_Axiom-val"><b>llist_ue_Axiom</b></a>]  Theorem
      
      ⊢ ∀f. ∃!g.
          (∀x. LHD (g x) = OPTION_MAP SND (f x)) ∧
          ∀x. LTL (g x) = OPTION_MAP (g ∘ FST) (f x)
   
   [<a name="llist_upto_cases-val"><b>llist_upto_cases</b></a>]  Theorem
      
      ⊢ ∀R a0 a1.
          llist_upto R a0 a1 ⇔
          a1 = a0 ∨ R a0 a1 ∨ (∃y. llist_upto R a0 y ∧ llist_upto R y a1) ∨
          ∃x y z. a0 = LAPPEND z x ∧ a1 = LAPPEND z y ∧ llist_upto R x y
   
   [<a name="llist_upto_context-val"><b>llist_upto_context</b></a>]  Theorem
      
      ⊢ ∀R x y z.
          llist_upto R x y ⇒ llist_upto R (LAPPEND z x) (LAPPEND z y)
   
   [<a name="llist_upto_eq-val"><b>llist_upto_eq</b></a>]  Theorem
      
      ⊢ ∀R x. llist_upto R x x
   
   [<a name="llist_upto_ind-val"><b>llist_upto_ind</b></a>]  Theorem
      
      ⊢ ∀R llist_upto'.
          (∀x. llist_upto' x x) ∧ (∀x y. R x y ⇒ llist_upto' x y) ∧
          (∀x y z. llist_upto' x y ∧ llist_upto' y z ⇒ llist_upto' x z) ∧
          (∀x y z.
             llist_upto' x y ⇒ llist_upto' (LAPPEND z x) (LAPPEND z y)) ⇒
          ∀a0 a1. llist_upto R a0 a1 ⇒ llist_upto' a0 a1
   
   [<a name="llist_upto_rel-val"><b>llist_upto_rel</b></a>]  Theorem
      
      ⊢ ∀R x y. R x y ⇒ llist_upto R x y
   
   [<a name="llist_upto_rules-val"><b>llist_upto_rules</b></a>]  Theorem
      
      ⊢ ∀R. (∀x. llist_upto R x x) ∧ (∀x y. R x y ⇒ llist_upto R x y) ∧
            (∀x y z. llist_upto R x y ∧ llist_upto R y z ⇒ llist_upto R x z) ∧
            ∀x y z.
              llist_upto R x y ⇒ llist_upto R (LAPPEND z x) (LAPPEND z y)
   
   [<a name="llist_upto_strongind-val"><b>llist_upto_strongind</b></a>]  Theorem
      
      ⊢ ∀R llist_upto'.
          (∀x. llist_upto' x x) ∧ (∀x y. R x y ⇒ llist_upto' x y) ∧
          (∀x y z.
             llist_upto R x y ∧ llist_upto' x y ∧ llist_upto R y z ∧
             llist_upto' y z ⇒
             llist_upto' x z) ∧
          (∀x y z.
             llist_upto R x y ∧ llist_upto' x y ⇒
             llist_upto' (LAPPEND z x) (LAPPEND z y)) ⇒
          ∀a0 a1. llist_upto R a0 a1 ⇒ llist_upto' a0 a1
   
   [<a name="llist_upto_trans-val"><b>llist_upto_trans</b></a>]  Theorem
      
      ⊢ ∀R x y z. llist_upto R x y ∧ llist_upto R y z ⇒ llist_upto R x z
   
   [<a name="lnth_fromList_some-val"><b>lnth_fromList_some</b></a>]  Theorem
      
      ⊢ ∀n l. n &lt; LENGTH l ⇔ LNTH n (fromList l) = SOME (EL n l)
   
   [<a name="lnth_some_down_closed-val"><b>lnth_some_down_closed</b></a>]  Theorem
      
      ⊢ ∀ll x n1 n2.
          LNTH n1 ll = SOME x ∧ n2 ≤ n1 ⇒ ∃y. LNTH n2 ll = SOME y
   
   [<a name="lrep_ok_FUNPOW_BIND-val"><b>lrep_ok_FUNPOW_BIND</b></a>]  Theorem
      
      ⊢ lrep_ok (λn. FUNPOW (λm. OPTION_BIND m g) n fz)
   
   [<a name="lrep_ok_MAP-val"><b>lrep_ok_MAP</b></a>]  Theorem
      
      ⊢ lrep_ok (λn. OPTION_MAP f (g n)) ⇔ lrep_ok g
   
   [<a name="lrep_ok_alt-val"><b>lrep_ok_alt</b></a>]  Theorem
      
      ⊢ lrep_ok f ⇔ ∀n. IS_SOME (f (SUC n)) ⇒ IS_SOME (f n)
   
   [<a name="lrep_ok_cases-val"><b>lrep_ok_cases</b></a>]  Theorem
      
      ⊢ ∀a0.
          lrep_ok a0 ⇔
          a0 = (λn. NONE) ∨
          ∃h t. a0 = (λn. if n = 0 then SOME h else t (n − 1)) ∧ lrep_ok t
   
   [<a name="lrep_ok_coind-val"><b>lrep_ok_coind</b></a>]  Theorem
      
      ⊢ ∀lrep_ok'.
          (∀a0.
             lrep_ok' a0 ⇒
             a0 = (λn. NONE) ∨
             ∃h t.
               a0 = (λn. if n = 0 then SOME h else t (n − 1)) ∧ lrep_ok' t) ⇒
          ∀a0. lrep_ok' a0 ⇒ lrep_ok a0
   
   [<a name="lrep_ok_rules-val"><b>lrep_ok_rules</b></a>]  Theorem
      
      ⊢ lrep_ok (λn. NONE) ∧
        ∀h t. lrep_ok t ⇒ lrep_ok (λn. if n = 0 then SOME h else t (n − 1))
   
   [<a name="numopt_BISIMULATION-val"><b>numopt_BISIMULATION</b></a>]  Theorem
      
      ⊢ ∀mopt nopt.
          mopt = nopt ⇔
          ∃R. R mopt nopt ∧
              ∀m n.
                R m n ⇒
                m = SOME 0 ∧ n = SOME 0 ∨
                m ≠ SOME 0 ∧ n ≠ SOME 0 ∧
                R (OPTION_MAP PRE m) (OPTION_MAP PRE n)
   
   [<a name="prefixes_lprefix_total-val"><b>prefixes_lprefix_total</b></a>]  Theorem
      
      ⊢ ∀ll l1 l2.
          LPREFIX l1 ll ∧ LPREFIX l2 ll ⇒ LPREFIX l1 l2 ∨ LPREFIX l2 l1
   
   [<a name="toList_LAPPEND_APPEND-val"><b>toList_LAPPEND_APPEND</b></a>]  Theorem
      
      ⊢ toList (LAPPEND l1 l2) = SOME x ⇒
        x = THE (toList l1) ⧺ THE (toList l2)
   
   [<a name="toList_THM-val"><b>toList_THM</b></a>]  Theorem
      
      ⊢ toList [||] = SOME [] ∧
        ∀h t. toList (h:::t) = OPTION_MAP (CONS h) (toList t)
   
   [<a name="to_fromList-val"><b>to_fromList</b></a>]  Theorem
      
      ⊢ ∀ll. LFINITE ll ⇒ fromList (THE (toList ll)) = ll
   
   [<a name="until_cases-val"><b>until_cases</b></a>]  Theorem
      
      ⊢ ∀P Q a0.
          until P Q a0 ⇔ Q a0 ∨ ∃h t. a0 = h:::t ∧ P (h:::t) ∧ until P Q t
   
   [<a name="until_ind-val"><b>until_ind</b></a>]  Theorem
      
      ⊢ ∀P Q until'.
          (∀ll. Q ll ⇒ until' ll) ∧
          (∀h t. P (h:::t) ∧ until' t ⇒ until' (h:::t)) ⇒
          ∀a0. until P Q a0 ⇒ until' a0
   
   [<a name="until_rules-val"><b>until_rules</b></a>]  Theorem
      
      ⊢ ∀P Q.
          (∀ll. Q ll ⇒ until P Q ll) ∧
          ∀h t. P (h:::t) ∧ until P Q t ⇒ until P Q (h:::t)
   
   [<a name="until_strongind-val"><b>until_strongind</b></a>]  Theorem
      
      ⊢ ∀P Q until'.
          (∀ll. Q ll ⇒ until' ll) ∧
          (∀h t. P (h:::t) ∧ until P Q t ∧ until' t ⇒ until' (h:::t)) ⇒
          ∀a0. until P Q a0 ⇒ until' a0
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/coalgebras/llistScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-14</a></em></p></body></html>
