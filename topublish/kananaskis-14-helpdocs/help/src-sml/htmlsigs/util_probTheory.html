<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure util_probTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure util_probTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/probability/util_probScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature util_probTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#binary_def-val">binary_def</a> : thm
<a name="line7"></a>    val <a href="#disjoint_def-val">disjoint_def</a> : thm
<a name="line8"></a>    val <a href="#disjoint_family-val">disjoint_family</a> : thm
<a name="line9"></a>    val <a href="#disjoint_family_on-val">disjoint_family_on</a> : thm
<a name="line10"></a>    val <a href="#disjointed-val">disjointed</a> : thm
<a name="line11"></a>    val <a href="#fcp_cross_def-val">fcp_cross_def</a> : thm
<a name="line12"></a>    val <a href="#fcp_prod_def-val">fcp_prod_def</a> : thm
<a name="line13"></a>    val <a href="#general_cross_def-val">general_cross_def</a> : thm
<a name="line14"></a>    val <a href="#general_prod_def-val">general_prod_def</a> : thm
<a name="line15"></a>    val <a href="#lg_def-val">lg_def</a> : thm
<a name="line16"></a>    val <a href="#logr_def-val">logr_def</a> : thm
<a name="line17"></a>    val <a href="#minimal_def-val">minimal_def</a> : thm
<a name="line18"></a>    val <a href="#pair_operation_def-val">pair_operation_def</a> : thm
<a name="line19"></a>    val <a href="#prod_sets_def-val">prod_sets_def</a> : thm
<a name="line20"></a>  
<a name="line21"></a>  (*  Theorems  *)
<a name="line22"></a>    val <a href="#ADD_POW_2-val">ADD_POW_2</a> : thm
<a name="line23"></a>    val <a href="#BIGINTER_IMAGE_OVER_INTER_L-val">BIGINTER_IMAGE_OVER_INTER_L</a> : thm
<a name="line24"></a>    val <a href="#BIGINTER_IMAGE_OVER_INTER_R-val">BIGINTER_IMAGE_OVER_INTER_R</a> : thm
<a name="line25"></a>    val <a href="#BIGINTER_PAIR-val">BIGINTER_PAIR</a> : thm
<a name="line26"></a>    val <a href="#BIGUNION_IMAGE_BIGUNION_IMAGE_UNIV-val">BIGUNION_IMAGE_BIGUNION_IMAGE_UNIV</a> : thm
<a name="line27"></a>    val <a href="#BIGUNION_IMAGE_COUNT_IMP_UNIV-val">BIGUNION_IMAGE_COUNT_IMP_UNIV</a> : thm
<a name="line28"></a>    val <a href="#BIGUNION_IMAGE_OVER_INTER_L-val">BIGUNION_IMAGE_OVER_INTER_L</a> : thm
<a name="line29"></a>    val <a href="#BIGUNION_IMAGE_OVER_INTER_R-val">BIGUNION_IMAGE_OVER_INTER_R</a> : thm
<a name="line30"></a>    val <a href="#BIGUNION_IMAGE_UNIV_CROSS_UNIV-val">BIGUNION_IMAGE_UNIV_CROSS_UNIV</a> : thm
<a name="line31"></a>    val <a href="#BIGUNION_OVER_DIFF-val">BIGUNION_OVER_DIFF</a> : thm
<a name="line32"></a>    val <a href="#BIGUNION_OVER_INTER_L-val">BIGUNION_OVER_INTER_L</a> : thm
<a name="line33"></a>    val <a href="#BIGUNION_OVER_INTER_R-val">BIGUNION_OVER_INTER_R</a> : thm
<a name="line34"></a>    val <a href="#BIGUNION_disjointed-val">BIGUNION_disjointed</a> : thm
<a name="line35"></a>    val <a href="#BINARY_RANGE-val">BINARY_RANGE</a> : thm
<a name="line36"></a>    val <a href="#COMPL_BIGINTER-val">COMPL_BIGINTER</a> : thm
<a name="line37"></a>    val <a href="#COMPL_BIGINTER_IMAGE-val">COMPL_BIGINTER_IMAGE</a> : thm
<a name="line38"></a>    val <a href="#COMPL_BIGUNION-val">COMPL_BIGUNION</a> : thm
<a name="line39"></a>    val <a href="#COMPL_BIGUNION_IMAGE-val">COMPL_BIGUNION_IMAGE</a> : thm
<a name="line40"></a>    val <a href="#CROSS_ALT-val">CROSS_ALT</a> : thm
<a name="line41"></a>    val <a href="#DIFF_INTER_PAIR-val">DIFF_INTER_PAIR</a> : thm
<a name="line42"></a>    val <a href="#DINTER_IMP_FINITE_INTER-val">DINTER_IMP_FINITE_INTER</a> : thm
<a name="line43"></a>    val <a href="#DISJOINT_CROSS_L-val">DISJOINT_CROSS_L</a> : thm
<a name="line44"></a>    val <a href="#DISJOINT_CROSS_R-val">DISJOINT_CROSS_R</a> : thm
<a name="line45"></a>    val <a href="#DISJOINT_RESTRICT_L-val">DISJOINT_RESTRICT_L</a> : thm
<a name="line46"></a>    val <a href="#DISJOINT_RESTRICT_R-val">DISJOINT_RESTRICT_R</a> : thm
<a name="line47"></a>    val <a href="#DUNION_IMP_FINITE_UNION-val">DUNION_IMP_FINITE_UNION</a> : thm
<a name="line48"></a>    val <a href="#FCP_BIGUNION_CROSS-val">FCP_BIGUNION_CROSS</a> : thm
<a name="line49"></a>    val <a href="#FCP_CROSS_BIGUNION-val">FCP_CROSS_BIGUNION</a> : thm
<a name="line50"></a>    val <a href="#FCP_CROSS_DIFF-val">FCP_CROSS_DIFF</a> : thm
<a name="line51"></a>    val <a href="#FCP_CROSS_DIFF'-val">FCP_CROSS_DIFF'</a> : thm
<a name="line52"></a>    val <a href="#FCP_INTER_CROSS-val">FCP_INTER_CROSS</a> : thm
<a name="line53"></a>    val <a href="#FCP_SUBSET_CROSS-val">FCP_SUBSET_CROSS</a> : thm
<a name="line54"></a>    val <a href="#GBIGUNION_IMAGE-val">GBIGUNION_IMAGE</a> : thm
<a name="line55"></a>    val <a href="#GEN_COMPL_BIGINTER-val">GEN_COMPL_BIGINTER</a> : thm
<a name="line56"></a>    val <a href="#GEN_COMPL_BIGINTER_IMAGE-val">GEN_COMPL_BIGINTER_IMAGE</a> : thm
<a name="line57"></a>    val <a href="#GEN_COMPL_BIGUNION-val">GEN_COMPL_BIGUNION</a> : thm
<a name="line58"></a>    val <a href="#GEN_COMPL_BIGUNION_IMAGE-val">GEN_COMPL_BIGUNION_IMAGE</a> : thm
<a name="line59"></a>    val <a href="#GEN_COMPL_FINITE_INTER-val">GEN_COMPL_FINITE_INTER</a> : thm
<a name="line60"></a>    val <a href="#GEN_COMPL_FINITE_UNION-val">GEN_COMPL_FINITE_UNION</a> : thm
<a name="line61"></a>    val <a href="#GEN_COMPL_INTER-val">GEN_COMPL_INTER</a> : thm
<a name="line62"></a>    val <a href="#GEN_COMPL_UNION-val">GEN_COMPL_UNION</a> : thm
<a name="line63"></a>    val <a href="#GEN_DIFF_INTER-val">GEN_DIFF_INTER</a> : thm
<a name="line64"></a>    val <a href="#HARMONIC_SERIES_POW_2-val">HARMONIC_SERIES_POW_2</a> : thm
<a name="line65"></a>    val <a href="#INCREASING_TO_DISJOINT_SETS-val">INCREASING_TO_DISJOINT_SETS</a> : thm
<a name="line66"></a>    val <a href="#INCREASING_TO_DISJOINT_SETS'-val">INCREASING_TO_DISJOINT_SETS'</a> : thm
<a name="line67"></a>    val <a href="#INF_CLOSE-val">INF_CLOSE</a> : thm
<a name="line68"></a>    val <a href="#INF_DEF_ALT-val">INF_DEF_ALT</a> : thm
<a name="line69"></a>    val <a href="#INF_GREATER-val">INF_GREATER</a> : thm
<a name="line70"></a>    val <a href="#INF_LE-val">INF_LE</a> : thm
<a name="line71"></a>    val <a href="#INTER_BINARY-val">INTER_BINARY</a> : thm
<a name="line72"></a>    val <a href="#IN_FCP_CROSS-val">IN_FCP_CROSS</a> : thm
<a name="line73"></a>    val <a href="#IN_FCP_PROD-val">IN_FCP_PROD</a> : thm
<a name="line74"></a>    val <a href="#IN_PROD_SETS-val">IN_PROD_SETS</a> : thm
<a name="line75"></a>    val <a href="#IN_general_cross-val">IN_general_cross</a> : thm
<a name="line76"></a>    val <a href="#IN_general_prod-val">IN_general_prod</a> : thm
<a name="line77"></a>    val <a href="#IN_o-val">IN_o</a> : thm
<a name="line78"></a>    val <a href="#LE_INF-val">LE_INF</a> : thm
<a name="line79"></a>    val <a href="#LOGR_MONO_LE-val">LOGR_MONO_LE</a> : thm
<a name="line80"></a>    val <a href="#LOGR_MONO_LE_IMP-val">LOGR_MONO_LE_IMP</a> : thm
<a name="line81"></a>    val <a href="#MINIMAL_EQ-val">MINIMAL_EQ</a> : thm
<a name="line82"></a>    val <a href="#MINIMAL_EQ_IMP-val">MINIMAL_EQ_IMP</a> : thm
<a name="line83"></a>    val <a href="#MINIMAL_EXISTS-val">MINIMAL_EXISTS</a> : thm
<a name="line84"></a>    val <a href="#MINIMAL_EXISTS0-val">MINIMAL_EXISTS0</a> : thm
<a name="line85"></a>    val <a href="#MINIMAL_EXISTS_IMP-val">MINIMAL_EXISTS_IMP</a> : thm
<a name="line86"></a>    val <a href="#MINIMAL_SUC-val">MINIMAL_SUC</a> : thm
<a name="line87"></a>    val <a href="#MINIMAL_SUC_IMP-val">MINIMAL_SUC_IMP</a> : thm
<a name="line88"></a>    val <a href="#NUM_2D_BIJ-val">NUM_2D_BIJ</a> : thm
<a name="line89"></a>    val <a href="#NUM_2D_BIJ_INV-val">NUM_2D_BIJ_INV</a> : thm
<a name="line90"></a>    val <a href="#NUM_2D_BIJ_NZ-val">NUM_2D_BIJ_NZ</a> : thm
<a name="line91"></a>    val <a href="#NUM_2D_BIJ_NZ_ALT-val">NUM_2D_BIJ_NZ_ALT</a> : thm
<a name="line92"></a>    val <a href="#NUM_2D_BIJ_NZ_ALT2-val">NUM_2D_BIJ_NZ_ALT2</a> : thm
<a name="line93"></a>    val <a href="#NUM_2D_BIJ_NZ_ALT2_INV-val">NUM_2D_BIJ_NZ_ALT2_INV</a> : thm
<a name="line94"></a>    val <a href="#NUM_2D_BIJ_NZ_ALT_INV-val">NUM_2D_BIJ_NZ_ALT_INV</a> : thm
<a name="line95"></a>    val <a href="#NUM_2D_BIJ_NZ_INV-val">NUM_2D_BIJ_NZ_INV</a> : thm
<a name="line96"></a>    val <a href="#NUM_2D_BIJ_nfst_nsnd-val">NUM_2D_BIJ_nfst_nsnd</a> : thm
<a name="line97"></a>    val <a href="#NUM_2D_BIJ_npair-val">NUM_2D_BIJ_npair</a> : thm
<a name="line98"></a>    val <a href="#PAIRED_BETA_THM-val">PAIRED_BETA_THM</a> : thm
<a name="line99"></a>    val <a href="#POW_HALF_MONO-val">POW_HALF_MONO</a> : thm
<a name="line100"></a>    val <a href="#POW_HALF_POS-val">POW_HALF_POS</a> : thm
<a name="line101"></a>    val <a href="#POW_HALF_SMALL-val">POW_HALF_SMALL</a> : thm
<a name="line102"></a>    val <a href="#POW_NEG_ODD-val">POW_NEG_ODD</a> : thm
<a name="line103"></a>    val <a href="#POW_POS_EVEN-val">POW_POS_EVEN</a> : thm
<a name="line104"></a>    val <a href="#PREIMAGE_REAL_COMPL1-val">PREIMAGE_REAL_COMPL1</a> : thm
<a name="line105"></a>    val <a href="#PREIMAGE_REAL_COMPL2-val">PREIMAGE_REAL_COMPL2</a> : thm
<a name="line106"></a>    val <a href="#PREIMAGE_REAL_COMPL3-val">PREIMAGE_REAL_COMPL3</a> : thm
<a name="line107"></a>    val <a href="#PREIMAGE_REAL_COMPL4-val">PREIMAGE_REAL_COMPL4</a> : thm
<a name="line108"></a>    val <a href="#REAL_ARCH_INV'-val">REAL_ARCH_INV'</a> : thm
<a name="line109"></a>    val <a href="#REAL_ARCH_INV_SUC-val">REAL_ARCH_INV_SUC</a> : thm
<a name="line110"></a>    val <a href="#REAL_LE_LT_MUL-val">REAL_LE_LT_MUL</a> : thm
<a name="line111"></a>    val <a href="#REAL_LE_RDIV_EQ_NEG-val">REAL_LE_RDIV_EQ_NEG</a> : thm
<a name="line112"></a>    val <a href="#REAL_LT_LE_MUL-val">REAL_LT_LE_MUL</a> : thm
<a name="line113"></a>    val <a href="#REAL_LT_LMUL_0_NEG-val">REAL_LT_LMUL_0_NEG</a> : thm
<a name="line114"></a>    val <a href="#REAL_LT_LMUL_NEG_0-val">REAL_LT_LMUL_NEG_0</a> : thm
<a name="line115"></a>    val <a href="#REAL_LT_LMUL_NEG_0_NEG-val">REAL_LT_LMUL_NEG_0_NEG</a> : thm
<a name="line116"></a>    val <a href="#REAL_LT_MAX_BETWEEN-val">REAL_LT_MAX_BETWEEN</a> : thm
<a name="line117"></a>    val <a href="#REAL_LT_RDIV_EQ_NEG-val">REAL_LT_RDIV_EQ_NEG</a> : thm
<a name="line118"></a>    val <a href="#REAL_LT_RMUL_0_NEG-val">REAL_LT_RMUL_0_NEG</a> : thm
<a name="line119"></a>    val <a href="#REAL_LT_RMUL_NEG_0-val">REAL_LT_RMUL_NEG_0</a> : thm
<a name="line120"></a>    val <a href="#REAL_LT_RMUL_NEG_0_NEG-val">REAL_LT_RMUL_NEG_0_NEG</a> : thm
<a name="line121"></a>    val <a href="#REAL_MAX_REDUCE-val">REAL_MAX_REDUCE</a> : thm
<a name="line122"></a>    val <a href="#REAL_MIN_LE_BETWEEN-val">REAL_MIN_LE_BETWEEN</a> : thm
<a name="line123"></a>    val <a href="#REAL_MIN_REDUCE-val">REAL_MIN_REDUCE</a> : thm
<a name="line124"></a>    val <a href="#REAL_MUL_IDEMPOT-val">REAL_MUL_IDEMPOT</a> : thm
<a name="line125"></a>    val <a href="#REAL_NEG_NZ-val">REAL_NEG_NZ</a> : thm
<a name="line126"></a>    val <a href="#REAL_SUP_LE_X-val">REAL_SUP_LE_X</a> : thm
<a name="line127"></a>    val <a href="#REAL_X_LE_SUP-val">REAL_X_LE_SUP</a> : thm
<a name="line128"></a>    val <a href="#SETS_TO_DISJOINT_SETS-val">SETS_TO_DISJOINT_SETS</a> : thm
<a name="line129"></a>    val <a href="#SETS_TO_DISJOINT_SETS'-val">SETS_TO_DISJOINT_SETS'</a> : thm
<a name="line130"></a>    val <a href="#SETS_TO_INCREASING_SETS-val">SETS_TO_INCREASING_SETS</a> : thm
<a name="line131"></a>    val <a href="#SETS_TO_INCREASING_SETS'-val">SETS_TO_INCREASING_SETS'</a> : thm
<a name="line132"></a>    val <a href="#SUBSET_DIFF_DISJOINT-val">SUBSET_DIFF_DISJOINT</a> : thm
<a name="line133"></a>    val <a href="#SUBSET_DIFF_SUBSET-val">SUBSET_DIFF_SUBSET</a> : thm
<a name="line134"></a>    val <a href="#SUBSET_INTER_SUBSET_L-val">SUBSET_INTER_SUBSET_L</a> : thm
<a name="line135"></a>    val <a href="#SUBSET_INTER_SUBSET_R-val">SUBSET_INTER_SUBSET_R</a> : thm
<a name="line136"></a>    val <a href="#SUBSET_MONO_DIFF-val">SUBSET_MONO_DIFF</a> : thm
<a name="line137"></a>    val <a href="#SUBSET_RESTRICT_DIFF-val">SUBSET_RESTRICT_DIFF</a> : thm
<a name="line138"></a>    val <a href="#SUBSET_RESTRICT_L-val">SUBSET_RESTRICT_L</a> : thm
<a name="line139"></a>    val <a href="#SUBSET_RESTRICT_R-val">SUBSET_RESTRICT_R</a> : thm
<a name="line140"></a>    val <a href="#UNION_BINARY-val">UNION_BINARY</a> : thm
<a name="line141"></a>    val <a href="#UNION_TO_3_DISJOINT_UNIONS-val">UNION_TO_3_DISJOINT_UNIONS</a> : thm
<a name="line142"></a>    val <a href="#countable_disjoint_decomposition-val">countable_disjoint_decomposition</a> : thm
<a name="line143"></a>    val <a href="#disjoint-val">disjoint</a> : thm
<a name="line144"></a>    val <a href="#disjointD-val">disjointD</a> : thm
<a name="line145"></a>    val <a href="#disjointI-val">disjointI</a> : thm
<a name="line146"></a>    val <a href="#disjoint_empty-val">disjoint_empty</a> : thm
<a name="line147"></a>    val <a href="#disjoint_family_disjoint-val">disjoint_family_disjoint</a> : thm
<a name="line148"></a>    val <a href="#disjoint_image-val">disjoint_image</a> : thm
<a name="line149"></a>    val <a href="#disjoint_insert-val">disjoint_insert</a> : thm
<a name="line150"></a>    val <a href="#disjoint_insert_imp-val">disjoint_insert_imp</a> : thm
<a name="line151"></a>    val <a href="#disjoint_insert_notin-val">disjoint_insert_notin</a> : thm
<a name="line152"></a>    val <a href="#disjoint_restrict-val">disjoint_restrict</a> : thm
<a name="line153"></a>    val <a href="#disjoint_same-val">disjoint_same</a> : thm
<a name="line154"></a>    val <a href="#disjoint_sing-val">disjoint_sing</a> : thm
<a name="line155"></a>    val <a href="#disjoint_two-val">disjoint_two</a> : thm
<a name="line156"></a>    val <a href="#disjoint_union-val">disjoint_union</a> : thm
<a name="line157"></a>    val <a href="#disjointed_subset-val">disjointed_subset</a> : thm
<a name="line158"></a>    val <a href="#fcp_cross_UNIV-val">fcp_cross_UNIV</a> : thm
<a name="line159"></a>    val <a href="#fcp_cross_alt-val">fcp_cross_alt</a> : thm
<a name="line160"></a>    val <a href="#fcp_prod_alt-val">fcp_prod_alt</a> : thm
<a name="line161"></a>    val <a href="#finite_decomposition-val">finite_decomposition</a> : thm
<a name="line162"></a>    val <a href="#finite_decomposition_simple-val">finite_decomposition_simple</a> : thm
<a name="line163"></a>    val <a href="#finite_disjoint_decomposition-val">finite_disjoint_decomposition</a> : thm
<a name="line164"></a>    val <a href="#finite_enumeration_of_sets_has_max_non_empty-val">finite_enumeration_of_sets_has_max_non_empty</a> : thm
<a name="line165"></a>    val <a href="#general_BIGUNION_CROSS-val">general_BIGUNION_CROSS</a> : thm
<a name="line166"></a>    val <a href="#general_CROSS_BIGUNION-val">general_CROSS_BIGUNION</a> : thm
<a name="line167"></a>    val <a href="#general_CROSS_DIFF-val">general_CROSS_DIFF</a> : thm
<a name="line168"></a>    val <a href="#general_CROSS_DIFF'-val">general_CROSS_DIFF'</a> : thm
<a name="line169"></a>    val <a href="#general_INTER_CROSS-val">general_INTER_CROSS</a> : thm
<a name="line170"></a>    val <a href="#general_SUBSET_CROSS-val">general_SUBSET_CROSS</a> : thm
<a name="line171"></a>    val <a href="#infinitely_often_lemma-val">infinitely_often_lemma</a> : thm
<a name="line172"></a>    val <a href="#infinity_bound_lemma-val">infinity_bound_lemma</a> : thm
<a name="line173"></a>    val <a href="#lg_1-val">lg_1</a> : thm
<a name="line174"></a>    val <a href="#lg_2-val">lg_2</a> : thm
<a name="line175"></a>    val <a href="#lg_inv-val">lg_inv</a> : thm
<a name="line176"></a>    val <a href="#lg_mul-val">lg_mul</a> : thm
<a name="line177"></a>    val <a href="#lg_nonzero-val">lg_nonzero</a> : thm
<a name="line178"></a>    val <a href="#lg_pow-val">lg_pow</a> : thm
<a name="line179"></a>    val <a href="#logr_1-val">logr_1</a> : thm
<a name="line180"></a>    val <a href="#logr_div-val">logr_div</a> : thm
<a name="line181"></a>    val <a href="#logr_inv-val">logr_inv</a> : thm
<a name="line182"></a>    val <a href="#logr_mul-val">logr_mul</a> : thm
<a name="line183"></a>    val <a href="#neg_lg-val">neg_lg</a> : thm
<a name="line184"></a>    val <a href="#neg_logr-val">neg_logr</a> : thm
<a name="line185"></a>    val <a href="#pair_operation_FCP_CONCAT-val">pair_operation_FCP_CONCAT</a> : thm
<a name="line186"></a>    val <a href="#pair_operation_pair-val">pair_operation_pair</a> : thm
<a name="line187"></a>    val <a href="#prod_sets_alt-val">prod_sets_alt</a> : thm
<a name="line188"></a>    val <a href="#tail_countable-val">tail_countable</a> : thm
<a name="line189"></a>    val <a href="#tail_not_empty-val">tail_not_empty</a> : thm
<a name="line190"></a>  
<a name="line191"></a>  val util_prob_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line192"></a>(*
   [fcp] Parent theory of "util_prob"
   
   [numeral_bit] Parent theory of "util_prob"
   
   [real_sigma] Parent theory of "util_prob"
   
   [sorting] Parent theory of "util_prob"
   
   [<a name="binary_def-val"><b>binary_def</b></a>]  Definition
      
      âŠ¢ âˆ€a b. binary a b = (Î»x. if x = 0 then a else b)
   
   [<a name="disjoint_def-val"><b>disjoint_def</b></a>]  Definition
      
      âŠ¢ âˆ€A. disjoint A â‡” âˆ€a b. a âˆˆ A âˆ§ b âˆˆ A âˆ§ a â‰  b â‡’ DISJOINT a b
   
   [<a name="disjoint_family-val"><b>disjoint_family</b></a>]  Definition
      
      âŠ¢ âˆ€A. disjoint_family A â‡” disjoint_family_on A ğ•Œ(:Î±)
   
   [<a name="disjoint_family_on-val"><b>disjoint_family_on</b></a>]  Definition
      
      âŠ¢ âˆ€a s.
          disjoint_family_on a s â‡”
          âˆ€m n. m âˆˆ s âˆ§ n âˆˆ s âˆ§ m â‰  n â‡’ a m âˆ© a n = âˆ…
   
   [<a name="disjointed-val"><b>disjointed</b></a>]  Definition
      
      âŠ¢ âˆ€A n.
          disjointed A n =
          A n DIFF BIGUNION {A i | i âˆˆ {x | 0 â‰¤ x âˆ§ x &lt; n}}
   
   [<a name="fcp_cross_def-val"><b>fcp_cross_def</b></a>]  Definition
      
      âŠ¢ âˆ€A B. fcp_cross A B = {FCP_CONCAT a b | a âˆˆ A âˆ§ b âˆˆ B}
   
   [<a name="fcp_prod_def-val"><b>fcp_prod_def</b></a>]  Definition
      
      âŠ¢ âˆ€a b. fcp_prod a b = {fcp_cross s t | s âˆˆ a âˆ§ t âˆˆ b}
   
   [<a name="general_cross_def-val"><b>general_cross_def</b></a>]  Definition
      
      âŠ¢ âˆ€cons A B. general_cross cons A B = {cons a b | a âˆˆ A âˆ§ b âˆˆ B}
   
   [<a name="general_prod_def-val"><b>general_prod_def</b></a>]  Definition
      
      âŠ¢ âˆ€cons A B.
          general_prod cons A B = {general_cross cons a b | a âˆˆ A âˆ§ b âˆˆ B}
   
   [<a name="lg_def-val"><b>lg_def</b></a>]  Definition
      
      âŠ¢ âˆ€x. lg x = logr 2 x
   
   [<a name="logr_def-val"><b>logr_def</b></a>]  Definition
      
      âŠ¢ âˆ€a x. logr a x = ln x / ln a
   
   [<a name="minimal_def-val"><b>minimal_def</b></a>]  Definition
      
      âŠ¢ âˆ€p. minimal p = @n. p n âˆ§ âˆ€m. m &lt; n â‡’ Â¬p m
   
   [<a name="pair_operation_def-val"><b>pair_operation_def</b></a>]  Definition
      
      âŠ¢ âˆ€cons car cdr.
          pair_operation cons car cdr â‡”
          (âˆ€a b. car (cons a b) = a âˆ§ cdr (cons a b) = b) âˆ§
          âˆ€a b c d. cons a b = cons c d â‡” a = c âˆ§ b = d
   
   [<a name="prod_sets_def-val"><b>prod_sets_def</b></a>]  Definition
      
      âŠ¢ âˆ€a b. prod_sets a b = {s Ã— t | s âˆˆ a âˆ§ t âˆˆ b}
   
   [<a name="ADD_POW_2-val"><b>ADD_POW_2</b></a>]  Theorem
      
      âŠ¢ âˆ€x y. (x + y)Â² = xÂ² + yÂ² + 2 * x * y
   
   [<a name="BIGINTER_IMAGE_OVER_INTER_L-val"><b>BIGINTER_IMAGE_OVER_INTER_L</b></a>]  Theorem
      
      âŠ¢ âˆ€f n d.
          0 &lt; n â‡’
          BIGINTER (IMAGE f (count n)) âˆ© d =
          BIGINTER (IMAGE (Î»i. f i âˆ© d) (count n))
   
   [<a name="BIGINTER_IMAGE_OVER_INTER_R-val"><b>BIGINTER_IMAGE_OVER_INTER_R</b></a>]  Theorem
      
      âŠ¢ âˆ€f n d.
          0 &lt; n â‡’
          d âˆ© BIGINTER (IMAGE f (count n)) =
          BIGINTER (IMAGE (Î»i. d âˆ© f i) (count n))
   
   [<a name="BIGINTER_PAIR-val"><b>BIGINTER_PAIR</b></a>]  Theorem
      
      âŠ¢ âˆ€s t. BIGINTER {s; t} = s âˆ© t
   
   [<a name="BIGUNION_IMAGE_BIGUNION_IMAGE_UNIV-val"><b>BIGUNION_IMAGE_BIGUNION_IMAGE_UNIV</b></a>]  Theorem
      
      âŠ¢ âˆ€f. BIGUNION (IMAGE (Î»n. BIGUNION (IMAGE (f n) ğ•Œ(:num))) ğ•Œ(:num)) =
            BIGUNION (IMAGE (UNCURRY f) ğ•Œ(:num # num))
   
   [<a name="BIGUNION_IMAGE_COUNT_IMP_UNIV-val"><b>BIGUNION_IMAGE_COUNT_IMP_UNIV</b></a>]  Theorem
      
      âŠ¢ âˆ€f g.
          (âˆ€n. BIGUNION (IMAGE g (count n)) = BIGUNION (IMAGE f (count n))) â‡’
          BIGUNION (IMAGE f ğ•Œ(:num)) = BIGUNION (IMAGE g ğ•Œ(:num))
   
   [<a name="BIGUNION_IMAGE_OVER_INTER_L-val"><b>BIGUNION_IMAGE_OVER_INTER_L</b></a>]  Theorem
      
      âŠ¢ âˆ€f n d.
          BIGUNION (IMAGE f (count n)) âˆ© d =
          BIGUNION (IMAGE (Î»i. f i âˆ© d) (count n))
   
   [<a name="BIGUNION_IMAGE_OVER_INTER_R-val"><b>BIGUNION_IMAGE_OVER_INTER_R</b></a>]  Theorem
      
      âŠ¢ âˆ€f n d.
          d âˆ© BIGUNION (IMAGE f (count n)) =
          BIGUNION (IMAGE (Î»i. d âˆ© f i) (count n))
   
   [<a name="BIGUNION_IMAGE_UNIV_CROSS_UNIV-val"><b>BIGUNION_IMAGE_UNIV_CROSS_UNIV</b></a>]  Theorem
      
      âŠ¢ âˆ€f h.
          BIJ h ğ•Œ(:num) (ğ•Œ(:num) Ã— ğ•Œ(:num)) â‡’
          BIGUNION (IMAGE (UNCURRY f) ğ•Œ(:num # num)) =
          BIGUNION (IMAGE (UNCURRY f âˆ˜ h) ğ•Œ(:num))
   
   [<a name="BIGUNION_OVER_DIFF-val"><b>BIGUNION_OVER_DIFF</b></a>]  Theorem
      
      âŠ¢ âˆ€f d.
          BIGUNION (IMAGE f ğ•Œ(:num)) DIFF d =
          BIGUNION (IMAGE (Î»i. f i DIFF d) ğ•Œ(:num))
   
   [<a name="BIGUNION_OVER_INTER_L-val"><b>BIGUNION_OVER_INTER_L</b></a>]  Theorem
      
      âŠ¢ âˆ€f d.
          BIGUNION (IMAGE f ğ•Œ(:num)) âˆ© d =
          BIGUNION (IMAGE (Î»i. f i âˆ© d) ğ•Œ(:num))
   
   [<a name="BIGUNION_OVER_INTER_R-val"><b>BIGUNION_OVER_INTER_R</b></a>]  Theorem
      
      âŠ¢ âˆ€f d.
          d âˆ© BIGUNION (IMAGE f ğ•Œ(:num)) =
          BIGUNION (IMAGE (Î»i. d âˆ© f i) ğ•Œ(:num))
   
   [<a name="BIGUNION_disjointed-val"><b>BIGUNION_disjointed</b></a>]  Theorem
      
      âŠ¢ âˆ€A. BIGUNION {disjointed A i | i âˆˆ ğ•Œ(:num)} =
            BIGUNION {A i | i âˆˆ ğ•Œ(:num)}
   
   [<a name="BINARY_RANGE-val"><b>BINARY_RANGE</b></a>]  Theorem
      
      âŠ¢ âˆ€a b. IMAGE (binary a b) ğ•Œ(:num) = {a; b}
   
   [<a name="COMPL_BIGINTER-val"><b>COMPL_BIGINTER</b></a>]  Theorem
      
      âŠ¢ âˆ€c. COMPL (BIGINTER c) = BIGUNION (IMAGE COMPL c)
   
   [<a name="COMPL_BIGINTER_IMAGE-val"><b>COMPL_BIGINTER_IMAGE</b></a>]  Theorem
      
      âŠ¢ âˆ€f. COMPL (BIGINTER (IMAGE f ğ•Œ(:num))) =
            BIGUNION (IMAGE (COMPL âˆ˜ f) ğ•Œ(:num))
   
   [<a name="COMPL_BIGUNION-val"><b>COMPL_BIGUNION</b></a>]  Theorem
      
      âŠ¢ âˆ€c. c â‰  âˆ… â‡’ COMPL (BIGUNION c) = BIGINTER (IMAGE COMPL c)
   
   [<a name="COMPL_BIGUNION_IMAGE-val"><b>COMPL_BIGUNION_IMAGE</b></a>]  Theorem
      
      âŠ¢ âˆ€f. COMPL (BIGUNION (IMAGE f ğ•Œ(:num))) =
            BIGINTER (IMAGE (COMPL âˆ˜ f) ğ•Œ(:num))
   
   [<a name="CROSS_ALT-val"><b>CROSS_ALT</b></a>]  Theorem
      
      âŠ¢ âˆ€A B. A Ã— B = general_cross $, A B
   
   [<a name="DIFF_INTER_PAIR-val"><b>DIFF_INTER_PAIR</b></a>]  Theorem
      
      âŠ¢ âˆ€sp x y. sp DIFF x âˆ© y = sp DIFF x âˆª (sp DIFF y)
   
   [<a name="DINTER_IMP_FINITE_INTER-val"><b>DINTER_IMP_FINITE_INTER</b></a>]  Theorem
      
      âŠ¢ âˆ€sts f.
          (âˆ€s t. s âˆˆ sts âˆ§ t âˆˆ sts â‡’ s âˆ© t âˆˆ sts) âˆ§ f âˆˆ (ğ•Œ(:num) â†’ sts) â‡’
          âˆ€n. 0 &lt; n â‡’ BIGINTER (IMAGE f (count n)) âˆˆ sts
   
   [<a name="DISJOINT_CROSS_L-val"><b>DISJOINT_CROSS_L</b></a>]  Theorem
      
      âŠ¢ âˆ€s t c. DISJOINT s t â‡’ DISJOINT (s Ã— c) (t Ã— c)
   
   [<a name="DISJOINT_CROSS_R-val"><b>DISJOINT_CROSS_R</b></a>]  Theorem
      
      âŠ¢ âˆ€s t c. DISJOINT s t â‡’ DISJOINT (c Ã— s) (c Ã— t)
   
   [<a name="DISJOINT_RESTRICT_L-val"><b>DISJOINT_RESTRICT_L</b></a>]  Theorem
      
      âŠ¢ âˆ€s t c. DISJOINT s t â‡’ DISJOINT (s âˆ© c) (t âˆ© c)
   
   [<a name="DISJOINT_RESTRICT_R-val"><b>DISJOINT_RESTRICT_R</b></a>]  Theorem
      
      âŠ¢ âˆ€s t c. DISJOINT s t â‡’ DISJOINT (c âˆ© s) (c âˆ© t)
   
   [<a name="DUNION_IMP_FINITE_UNION-val"><b>DUNION_IMP_FINITE_UNION</b></a>]  Theorem
      
      âŠ¢ âˆ€sts f.
          (âˆ€s t. s âˆˆ sts âˆ§ t âˆˆ sts â‡’ s âˆª t âˆˆ sts) â‡’
          âˆ€n. 0 &lt; n âˆ§ (âˆ€i. i &lt; n â‡’ f i âˆˆ sts) â‡’
              BIGUNION (IMAGE f (count n)) âˆˆ sts
   
   [<a name="FCP_BIGUNION_CROSS-val"><b>FCP_BIGUNION_CROSS</b></a>]  Theorem
      
      âŠ¢ âˆ€f s t.
          fcp_cross (BIGUNION (IMAGE f s)) t =
          BIGUNION (IMAGE (Î»n. fcp_cross (f n) t) s)
   
   [<a name="FCP_CROSS_BIGUNION-val"><b>FCP_CROSS_BIGUNION</b></a>]  Theorem
      
      âŠ¢ âˆ€f s t.
          fcp_cross t (BIGUNION (IMAGE f s)) =
          BIGUNION (IMAGE (Î»n. fcp_cross t (f n)) s)
   
   [<a name="FCP_CROSS_DIFF-val"><b>FCP_CROSS_DIFF</b></a>]  Theorem
      
      âŠ¢ âˆ€X s t.
          FINITE ğ•Œ(:Î²) âˆ§ FINITE ğ•Œ(:Î³) â‡’
          fcp_cross (X DIFF s) t = fcp_cross X t DIFF fcp_cross s t
   
   [<a name="FCP_CROSS_DIFF'-val"><b>FCP_CROSS_DIFF'</b></a>]  Theorem
      
      âŠ¢ âˆ€s X t.
          FINITE ğ•Œ(:Î²) âˆ§ FINITE ğ•Œ(:Î³) â‡’
          fcp_cross s (X DIFF t) = fcp_cross s X DIFF fcp_cross s t
   
   [<a name="FCP_INTER_CROSS-val"><b>FCP_INTER_CROSS</b></a>]  Theorem
      
      âŠ¢ âˆ€a b c d.
          FINITE ğ•Œ(:Î²) âˆ§ FINITE ğ•Œ(:Î³) â‡’
          fcp_cross a b âˆ© fcp_cross c d = fcp_cross (a âˆ© c) (b âˆ© d)
   
   [<a name="FCP_SUBSET_CROSS-val"><b>FCP_SUBSET_CROSS</b></a>]  Theorem
      
      âŠ¢ âˆ€a b c d. a âŠ† b âˆ§ c âŠ† d â‡’ fcp_cross a c âŠ† fcp_cross b d
   
   [<a name="GBIGUNION_IMAGE-val"><b>GBIGUNION_IMAGE</b></a>]  Theorem
      
      âŠ¢ âˆ€s p n. {s | âˆƒn. p s n} = BIGUNION (IMAGE (Î»n. {s | p s n}) ğ•Œ(:Î³))
   
   [<a name="GEN_COMPL_BIGINTER-val"><b>GEN_COMPL_BIGINTER</b></a>]  Theorem
      
      âŠ¢ âˆ€sp c.
          (âˆ€x. x âˆˆ c â‡’ x âŠ† sp) â‡’
          sp DIFF BIGINTER c = BIGUNION (IMAGE (Î»x. sp DIFF x) c)
   
   [<a name="GEN_COMPL_BIGINTER_IMAGE-val"><b>GEN_COMPL_BIGINTER_IMAGE</b></a>]  Theorem
      
      âŠ¢ âˆ€sp f.
          (âˆ€n. f n âŠ† sp) â‡’
          sp DIFF BIGINTER (IMAGE f ğ•Œ(:num)) =
          BIGUNION (IMAGE (Î»n. sp DIFF f n) ğ•Œ(:num))
   
   [<a name="GEN_COMPL_BIGUNION-val"><b>GEN_COMPL_BIGUNION</b></a>]  Theorem
      
      âŠ¢ âˆ€sp c.
          c â‰  âˆ… âˆ§ (âˆ€x. x âˆˆ c â‡’ x âŠ† sp) â‡’
          sp DIFF BIGUNION c = BIGINTER (IMAGE (Î»x. sp DIFF x) c)
   
   [<a name="GEN_COMPL_BIGUNION_IMAGE-val"><b>GEN_COMPL_BIGUNION_IMAGE</b></a>]  Theorem
      
      âŠ¢ âˆ€sp f.
          (âˆ€n. f n âŠ† sp) â‡’
          sp DIFF BIGUNION (IMAGE f ğ•Œ(:num)) =
          BIGINTER (IMAGE (Î»n. sp DIFF f n) ğ•Œ(:num))
   
   [<a name="GEN_COMPL_FINITE_INTER-val"><b>GEN_COMPL_FINITE_INTER</b></a>]  Theorem
      
      âŠ¢ âˆ€sp f n.
          0 &lt; n â‡’
          sp DIFF BIGINTER (IMAGE f (count n)) =
          BIGUNION (IMAGE (Î»i. sp DIFF f i) (count n))
   
   [<a name="GEN_COMPL_FINITE_UNION-val"><b>GEN_COMPL_FINITE_UNION</b></a>]  Theorem
      
      âŠ¢ âˆ€sp f n.
          0 &lt; n â‡’
          sp DIFF BIGUNION (IMAGE f (count n)) =
          BIGINTER (IMAGE (Î»i. sp DIFF f i) (count n))
   
   [<a name="GEN_COMPL_INTER-val"><b>GEN_COMPL_INTER</b></a>]  Theorem
      
      âŠ¢ âˆ€sp s t. s âŠ† sp âˆ§ t âŠ† sp â‡’ sp DIFF s âˆ© t = sp DIFF s âˆª (sp DIFF t)
   
   [<a name="GEN_COMPL_UNION-val"><b>GEN_COMPL_UNION</b></a>]  Theorem
      
      âŠ¢ âˆ€sp s t.
          s âŠ† sp âˆ§ t âŠ† sp â‡’ sp DIFF (s âˆª t) = (sp DIFF s) âˆ© (sp DIFF t)
   
   [<a name="GEN_DIFF_INTER-val"><b>GEN_DIFF_INTER</b></a>]  Theorem
      
      âŠ¢ âˆ€sp s t. s âŠ† sp âˆ§ t âŠ† sp â‡’ s DIFF t = s âˆ© (sp DIFF t)
   
   [<a name="HARMONIC_SERIES_POW_2-val"><b>HARMONIC_SERIES_POW_2</b></a>]  Theorem
      
      âŠ¢ summable (Î»n. (&SUC n)Â² â»Â¹)
   
   [<a name="INCREASING_TO_DISJOINT_SETS-val"><b>INCREASING_TO_DISJOINT_SETS</b></a>]  Theorem
      
      âŠ¢ âˆ€f. (âˆ€n. f n âŠ† f (SUC n)) â‡’
            âˆƒg. g 0 = f 0 âˆ§ (âˆ€n. 0 &lt; n â‡’ g n = f n DIFF f (PRE n)) âˆ§
                (âˆ€i j. i â‰  j â‡’ DISJOINT (g i) (g j)) âˆ§
                BIGUNION (IMAGE f ğ•Œ(:num)) = BIGUNION (IMAGE g ğ•Œ(:num))
   
   [<a name="INCREASING_TO_DISJOINT_SETS'-val"><b>INCREASING_TO_DISJOINT_SETS'</b></a>]  Theorem
      
      âŠ¢ âˆ€f. f 0 = âˆ… âˆ§ (âˆ€n. f n âŠ† f (SUC n)) â‡’
            âˆƒg. (âˆ€n. g n = f (SUC n) DIFF f n) âˆ§
                (âˆ€i j. i â‰  j â‡’ DISJOINT (g i) (g j)) âˆ§
                BIGUNION (IMAGE f ğ•Œ(:num)) = BIGUNION (IMAGE g ğ•Œ(:num))
   
   [<a name="INF_CLOSE-val"><b>INF_CLOSE</b></a>]  Theorem
      
      âŠ¢ âˆ€p e. (âˆƒx. x âˆˆ p) âˆ§ 0 &lt; e â‡’ âˆƒx. x âˆˆ p âˆ§ x &lt; inf p + e
   
   [<a name="INF_DEF_ALT-val"><b>INF_DEF_ALT</b></a>]  Theorem
      
      âŠ¢ âˆ€p. inf p = -sup (Î»r. -r âˆˆ p)
   
   [<a name="INF_GREATER-val"><b>INF_GREATER</b></a>]  Theorem
      
      âŠ¢ âˆ€p z. (âˆƒx. x âˆˆ p) âˆ§ inf p &lt; z â‡’ âˆƒx. x âˆˆ p âˆ§ x &lt; z
   
   [<a name="INF_LE-val"><b>INF_LE</b></a>]  Theorem
      
      âŠ¢ âˆ€p r. (âˆƒz. âˆ€x. x âˆˆ p â‡’ z â‰¤ x) âˆ§ (âˆƒx. x âˆˆ p âˆ§ x â‰¤ r) â‡’ inf p â‰¤ r
   
   [<a name="INTER_BINARY-val"><b>INTER_BINARY</b></a>]  Theorem
      
      âŠ¢ âˆ€a b. a âˆ© b = BIGINTER {binary a b i | i âˆˆ ğ•Œ(:num)}
   
   [<a name="IN_FCP_CROSS-val"><b>IN_FCP_CROSS</b></a>]  Theorem
      
      âŠ¢ âˆ€s a b.
          s âˆˆ fcp_cross a b â‡” âˆƒt u. s = FCP_CONCAT t u âˆ§ t âˆˆ a âˆ§ u âˆˆ b
   
   [<a name="IN_FCP_PROD-val"><b>IN_FCP_PROD</b></a>]  Theorem
      
      âŠ¢ âˆ€s A B. s âˆˆ fcp_prod A B â‡” âˆƒa b. s = fcp_cross a b âˆ§ a âˆˆ A âˆ§ b âˆˆ B
   
   [<a name="IN_PROD_SETS-val"><b>IN_PROD_SETS</b></a>]  Theorem
      
      âŠ¢ âˆ€s a b. s âˆˆ prod_sets a b â‡” âˆƒt u. s = t Ã— u âˆ§ t âˆˆ a âˆ§ u âˆˆ b
   
   [<a name="IN_general_cross-val"><b>IN_general_cross</b></a>]  Theorem
      
      âŠ¢ âˆ€cons s A B.
          s âˆˆ general_cross cons A B â‡” âˆƒa b. s = cons a b âˆ§ a âˆˆ A âˆ§ b âˆˆ B
   
   [<a name="IN_general_prod-val"><b>IN_general_prod</b></a>]  Theorem
      
      âŠ¢ âˆ€cons s A B.
          s âˆˆ general_prod cons A B â‡”
          âˆƒa b. s = general_cross cons a b âˆ§ a âˆˆ A âˆ§ b âˆˆ B
   
   [<a name="IN_o-val"><b>IN_o</b></a>]  Theorem
      
      âŠ¢ âˆ€x f s. x âˆˆ s âˆ˜ f â‡” f x âˆˆ s
   
   [<a name="LE_INF-val"><b>LE_INF</b></a>]  Theorem
      
      âŠ¢ âˆ€p r. (âˆƒx. x âˆˆ p) âˆ§ (âˆ€x. x âˆˆ p â‡’ r â‰¤ x) â‡’ r â‰¤ inf p
   
   [<a name="LOGR_MONO_LE-val"><b>LOGR_MONO_LE</b></a>]  Theorem
      
      âŠ¢ âˆ€x y b. 0 &lt; x âˆ§ 0 &lt; y âˆ§ 1 &lt; b â‡’ (logr b x â‰¤ logr b y â‡” x â‰¤ y)
   
   [<a name="LOGR_MONO_LE_IMP-val"><b>LOGR_MONO_LE_IMP</b></a>]  Theorem
      
      âŠ¢ âˆ€x y b. 0 &lt; x âˆ§ x â‰¤ y âˆ§ 1 â‰¤ b â‡’ logr b x â‰¤ logr b y
   
   [<a name="MINIMAL_EQ-val"><b>MINIMAL_EQ</b></a>]  Theorem
      
      âŠ¢ âˆ€p m. p m âˆ§ m = minimal p â‡” p m âˆ§ âˆ€n. n &lt; m â‡’ Â¬p n
   
   [<a name="MINIMAL_EQ_IMP-val"><b>MINIMAL_EQ_IMP</b></a>]  Theorem
      
      âŠ¢ âˆ€m p. p m âˆ§ (âˆ€n. n &lt; m â‡’ Â¬p n) â‡’ m = minimal p
   
   [<a name="MINIMAL_EXISTS-val"><b>MINIMAL_EXISTS</b></a>]  Theorem
      
      âŠ¢ âˆ€P. (âˆƒn. P n) â‡” P (minimal P) âˆ§ âˆ€n. n &lt; minimal P â‡’ Â¬P n
   
   [<a name="MINIMAL_EXISTS0-val"><b>MINIMAL_EXISTS0</b></a>]  Theorem
      
      âŠ¢ (âˆƒn. P n) â‡” âˆƒn. P n âˆ§ âˆ€m. m &lt; n â‡’ Â¬P m
   
   [<a name="MINIMAL_EXISTS_IMP-val"><b>MINIMAL_EXISTS_IMP</b></a>]  Theorem
      
      âŠ¢ âˆ€P. (âˆƒn. P n) â‡’ âˆƒm. P m âˆ§ âˆ€n. n &lt; m â‡’ Â¬P n
   
   [<a name="MINIMAL_SUC-val"><b>MINIMAL_SUC</b></a>]  Theorem
      
      âŠ¢ âˆ€n p.
          SUC n = minimal p âˆ§ p (SUC n) â‡”
          Â¬p 0 âˆ§ n = minimal (p âˆ˜ SUC) âˆ§ p (SUC n)
   
   [<a name="MINIMAL_SUC_IMP-val"><b>MINIMAL_SUC_IMP</b></a>]  Theorem
      
      âŠ¢ âˆ€n p. p (SUC n) âˆ§ Â¬p 0 âˆ§ n = minimal (p âˆ˜ SUC) â‡’ SUC n = minimal p
   
   [<a name="NUM_2D_BIJ-val"><b>NUM_2D_BIJ</b></a>]  Theorem
      
      âŠ¢ âˆƒf. BIJ f (ğ•Œ(:num) Ã— ğ•Œ(:num)) ğ•Œ(:num)
   
   [<a name="NUM_2D_BIJ_INV-val"><b>NUM_2D_BIJ_INV</b></a>]  Theorem
      
      âŠ¢ âˆƒf. BIJ f ğ•Œ(:num) (ğ•Œ(:num) Ã— ğ•Œ(:num))
   
   [<a name="NUM_2D_BIJ_NZ-val"><b>NUM_2D_BIJ_NZ</b></a>]  Theorem
      
      âŠ¢ âˆƒf. BIJ f (ğ•Œ(:num) Ã— (ğ•Œ(:num) DIFF {0})) ğ•Œ(:num)
   
   [<a name="NUM_2D_BIJ_NZ_ALT-val"><b>NUM_2D_BIJ_NZ_ALT</b></a>]  Theorem
      
      âŠ¢ âˆƒf. BIJ f (ğ•Œ(:num) Ã— ğ•Œ(:num)) (ğ•Œ(:num) DIFF {0})
   
   [<a name="NUM_2D_BIJ_NZ_ALT2-val"><b>NUM_2D_BIJ_NZ_ALT2</b></a>]  Theorem
      
      âŠ¢ âˆƒf. BIJ f ((ğ•Œ(:num) DIFF {0}) Ã— (ğ•Œ(:num) DIFF {0})) ğ•Œ(:num)
   
   [<a name="NUM_2D_BIJ_NZ_ALT2_INV-val"><b>NUM_2D_BIJ_NZ_ALT2_INV</b></a>]  Theorem
      
      âŠ¢ âˆƒf. BIJ f ğ•Œ(:num) ((ğ•Œ(:num) DIFF {0}) Ã— (ğ•Œ(:num) DIFF {0}))
   
   [<a name="NUM_2D_BIJ_NZ_ALT_INV-val"><b>NUM_2D_BIJ_NZ_ALT_INV</b></a>]  Theorem
      
      âŠ¢ âˆƒf. BIJ f (ğ•Œ(:num) DIFF {0}) (ğ•Œ(:num) Ã— ğ•Œ(:num))
   
   [<a name="NUM_2D_BIJ_NZ_INV-val"><b>NUM_2D_BIJ_NZ_INV</b></a>]  Theorem
      
      âŠ¢ âˆƒf. BIJ f ğ•Œ(:num) (ğ•Œ(:num) Ã— (ğ•Œ(:num) DIFF {0}))
   
   [<a name="NUM_2D_BIJ_nfst_nsnd-val"><b>NUM_2D_BIJ_nfst_nsnd</b></a>]  Theorem
      
      âŠ¢ BIJ (Î»n. (nfst n,nsnd n)) ğ•Œ(:num) (ğ•Œ(:num) Ã— ğ•Œ(:num))
   
   [<a name="NUM_2D_BIJ_npair-val"><b>NUM_2D_BIJ_npair</b></a>]  Theorem
      
      âŠ¢ BIJ (UNCURRY $*,) (ğ•Œ(:num) Ã— ğ•Œ(:num)) ğ•Œ(:num)
   
   [<a name="PAIRED_BETA_THM-val"><b>PAIRED_BETA_THM</b></a>]  Theorem
      
      âŠ¢ âˆ€f z. UNCURRY f z = f (FST z) (SND z)
   
   [<a name="POW_HALF_MONO-val"><b>POW_HALF_MONO</b></a>]  Theorem
      
      âŠ¢ âˆ€m n. m â‰¤ n â‡’ (1 / 2) pow n â‰¤ (1 / 2) pow m
   
   [<a name="POW_HALF_POS-val"><b>POW_HALF_POS</b></a>]  Theorem
      
      âŠ¢ âˆ€n. 0 &lt; (1 / 2) pow n
   
   [<a name="POW_HALF_SMALL-val"><b>POW_HALF_SMALL</b></a>]  Theorem
      
      âŠ¢ âˆ€e. 0 &lt; e â‡’ âˆƒn. (1 / 2) pow n &lt; e
   
   [<a name="POW_NEG_ODD-val"><b>POW_NEG_ODD</b></a>]  Theorem
      
      âŠ¢ âˆ€x. x &lt; 0 â‡’ (x pow n &lt; 0 â‡” ODD n)
   
   [<a name="POW_POS_EVEN-val"><b>POW_POS_EVEN</b></a>]  Theorem
      
      âŠ¢ âˆ€x. x &lt; 0 â‡’ (0 &lt; x pow n â‡” EVEN n)
   
   [<a name="PREIMAGE_REAL_COMPL1-val"><b>PREIMAGE_REAL_COMPL1</b></a>]  Theorem
      
      âŠ¢ âˆ€c. COMPL {x | c &lt; x} = {x | x â‰¤ c}
   
   [<a name="PREIMAGE_REAL_COMPL2-val"><b>PREIMAGE_REAL_COMPL2</b></a>]  Theorem
      
      âŠ¢ âˆ€c. COMPL {x | c â‰¤ x} = {x | x &lt; c}
   
   [<a name="PREIMAGE_REAL_COMPL3-val"><b>PREIMAGE_REAL_COMPL3</b></a>]  Theorem
      
      âŠ¢ âˆ€c. COMPL {x | x â‰¤ c} = {x | c &lt; x}
   
   [<a name="PREIMAGE_REAL_COMPL4-val"><b>PREIMAGE_REAL_COMPL4</b></a>]  Theorem
      
      âŠ¢ âˆ€c. COMPL {x | x &lt; c} = {x | c â‰¤ x}
   
   [<a name="REAL_ARCH_INV'-val"><b>REAL_ARCH_INV'</b></a>]  Theorem
      
      âŠ¢ âˆ€x. 0 &lt; x â‡’ âˆƒn. (&n)â»Â¹ &lt; x
   
   [<a name="REAL_ARCH_INV_SUC-val"><b>REAL_ARCH_INV_SUC</b></a>]  Theorem
      
      âŠ¢ âˆ€x. 0 &lt; x â‡’ âˆƒn. (&SUC n)â»Â¹ &lt; x
   
   [<a name="REAL_LE_LT_MUL-val"><b>REAL_LE_LT_MUL</b></a>]  Theorem
      
      âŠ¢ âˆ€x y. 0 â‰¤ x âˆ§ 0 &lt; y â‡’ 0 â‰¤ x * y
   
   [<a name="REAL_LE_RDIV_EQ_NEG-val"><b>REAL_LE_RDIV_EQ_NEG</b></a>]  Theorem
      
      âŠ¢ âˆ€x y z. z &lt; 0 â‡’ (y / z â‰¤ x â‡” x * z â‰¤ y)
   
   [<a name="REAL_LT_LE_MUL-val"><b>REAL_LT_LE_MUL</b></a>]  Theorem
      
      âŠ¢ âˆ€x y. 0 &lt; x âˆ§ 0 â‰¤ y â‡’ 0 â‰¤ x * y
   
   [<a name="REAL_LT_LMUL_0_NEG-val"><b>REAL_LT_LMUL_0_NEG</b></a>]  Theorem
      
      âŠ¢ âˆ€x y. 0 &lt; x * y âˆ§ x &lt; 0 â‡’ y &lt; 0
   
   [<a name="REAL_LT_LMUL_NEG_0-val"><b>REAL_LT_LMUL_NEG_0</b></a>]  Theorem
      
      âŠ¢ âˆ€x y. x * y &lt; 0 âˆ§ 0 &lt; x â‡’ y &lt; 0
   
   [<a name="REAL_LT_LMUL_NEG_0_NEG-val"><b>REAL_LT_LMUL_NEG_0_NEG</b></a>]  Theorem
      
      âŠ¢ âˆ€x y. x * y &lt; 0 âˆ§ x &lt; 0 â‡’ 0 &lt; y
   
   [<a name="REAL_LT_MAX_BETWEEN-val"><b>REAL_LT_MAX_BETWEEN</b></a>]  Theorem
      
      âŠ¢ âˆ€x b d. x &lt; max b d âˆ§ b â‰¤ x â‡’ x &lt; d
   
   [<a name="REAL_LT_RDIV_EQ_NEG-val"><b>REAL_LT_RDIV_EQ_NEG</b></a>]  Theorem
      
      âŠ¢ âˆ€x y z. z &lt; 0 â‡’ (y / z &lt; x â‡” x * z &lt; y)
   
   [<a name="REAL_LT_RMUL_0_NEG-val"><b>REAL_LT_RMUL_0_NEG</b></a>]  Theorem
      
      âŠ¢ âˆ€x y. 0 &lt; x * y âˆ§ y &lt; 0 â‡’ x &lt; 0
   
   [<a name="REAL_LT_RMUL_NEG_0-val"><b>REAL_LT_RMUL_NEG_0</b></a>]  Theorem
      
      âŠ¢ âˆ€x y. x * y &lt; 0 âˆ§ 0 &lt; y â‡’ x &lt; 0
   
   [<a name="REAL_LT_RMUL_NEG_0_NEG-val"><b>REAL_LT_RMUL_NEG_0_NEG</b></a>]  Theorem
      
      âŠ¢ âˆ€x y. x * y &lt; 0 âˆ§ y &lt; 0 â‡’ 0 &lt; x
   
   [<a name="REAL_MAX_REDUCE-val"><b>REAL_MAX_REDUCE</b></a>]  Theorem
      
      âŠ¢ âˆ€x y. x â‰¤ y âˆ¨ x &lt; y â‡’ max x y = y âˆ§ max y x = y
   
   [<a name="REAL_MIN_LE_BETWEEN-val"><b>REAL_MIN_LE_BETWEEN</b></a>]  Theorem
      
      âŠ¢ âˆ€x a c. min a c â‰¤ x âˆ§ x &lt; a â‡’ c â‰¤ x
   
   [<a name="REAL_MIN_REDUCE-val"><b>REAL_MIN_REDUCE</b></a>]  Theorem
      
      âŠ¢ âˆ€x y. x â‰¤ y âˆ¨ x &lt; y â‡’ min x y = x âˆ§ min y x = x
   
   [<a name="REAL_MUL_IDEMPOT-val"><b>REAL_MUL_IDEMPOT</b></a>]  Theorem
      
      âŠ¢ âˆ€r. r * r = r â‡” r = 0 âˆ¨ r = 1
   
   [<a name="REAL_NEG_NZ-val"><b>REAL_NEG_NZ</b></a>]  Theorem
      
      âŠ¢ âˆ€x. x &lt; 0 â‡’ x â‰  0
   
   [<a name="REAL_SUP_LE_X-val"><b>REAL_SUP_LE_X</b></a>]  Theorem
      
      âŠ¢ âˆ€P x. (âˆƒr. P r) âˆ§ (âˆ€r. P r â‡’ r â‰¤ x) â‡’ sup P â‰¤ x
   
   [<a name="REAL_X_LE_SUP-val"><b>REAL_X_LE_SUP</b></a>]  Theorem
      
      âŠ¢ âˆ€P x.
          (âˆƒr. P r) âˆ§ (âˆƒz. âˆ€r. P r â‡’ r â‰¤ z) âˆ§ (âˆƒr. P r âˆ§ x â‰¤ r) â‡’ x â‰¤ sup P
   
   [<a name="SETS_TO_DISJOINT_SETS-val"><b>SETS_TO_DISJOINT_SETS</b></a>]  Theorem
      
      âŠ¢ âˆ€sp sts f.
          (âˆ€s. s âˆˆ sts â‡’ s âŠ† sp) âˆ§ (âˆ€n. f n âˆˆ sts) â‡’
          âˆƒg. g 0 = f 0 âˆ§
              (âˆ€n. 0 &lt; n â‡’
                   g n = f n âˆ© BIGINTER (IMAGE (Î»i. sp DIFF f i) (count n))) âˆ§
              (âˆ€i j. i â‰  j â‡’ DISJOINT (g i) (g j)) âˆ§
              BIGUNION (IMAGE f ğ•Œ(:num)) = BIGUNION (IMAGE g ğ•Œ(:num))
   
   [<a name="SETS_TO_DISJOINT_SETS'-val"><b>SETS_TO_DISJOINT_SETS'</b></a>]  Theorem
      
      âŠ¢ âˆ€f. âˆƒg.
          g 0 = f 0 âˆ§
          (âˆ€n. 0 &lt; n â‡’ g n = f n âˆ© BIGINTER (IMAGE (COMPL âˆ˜ f) (count n))) âˆ§
          (âˆ€i j. i â‰  j â‡’ DISJOINT (g i) (g j)) âˆ§
          BIGUNION (IMAGE f ğ•Œ(:num)) = BIGUNION (IMAGE g ğ•Œ(:num))
   
   [<a name="SETS_TO_INCREASING_SETS-val"><b>SETS_TO_INCREASING_SETS</b></a>]  Theorem
      
      âŠ¢ âˆ€f. âˆƒg.
          g 0 = f 0 âˆ§ (âˆ€n. g n = BIGUNION (IMAGE f (count (SUC n)))) âˆ§
          (âˆ€n. g n âŠ† g (SUC n)) âˆ§
          BIGUNION (IMAGE f ğ•Œ(:num)) = BIGUNION (IMAGE g ğ•Œ(:num))
   
   [<a name="SETS_TO_INCREASING_SETS'-val"><b>SETS_TO_INCREASING_SETS'</b></a>]  Theorem
      
      âŠ¢ âˆ€f. âˆƒg.
          g 0 = âˆ… âˆ§ (âˆ€n. g n = BIGUNION (IMAGE f (count n))) âˆ§
          (âˆ€n. g n âŠ† g (SUC n)) âˆ§
          BIGUNION (IMAGE f ğ•Œ(:num)) = BIGUNION (IMAGE g ğ•Œ(:num))
   
   [<a name="SUBSET_DIFF_DISJOINT-val"><b>SUBSET_DIFF_DISJOINT</b></a>]  Theorem
      
      âŠ¢ âˆ€s1 s2 s3. s1 âŠ† s2 DIFF s3 â‡’ DISJOINT s1 s3
   
   [<a name="SUBSET_DIFF_SUBSET-val"><b>SUBSET_DIFF_SUBSET</b></a>]  Theorem
      
      âŠ¢ âˆ€r s t. s âŠ† t â‡’ s DIFF r âŠ† t
   
   [<a name="SUBSET_INTER_SUBSET_L-val"><b>SUBSET_INTER_SUBSET_L</b></a>]  Theorem
      
      âŠ¢ âˆ€r s t. s âŠ† t â‡’ s âˆ© r âŠ† t
   
   [<a name="SUBSET_INTER_SUBSET_R-val"><b>SUBSET_INTER_SUBSET_R</b></a>]  Theorem
      
      âŠ¢ âˆ€r s t. s âŠ† t â‡’ r âˆ© s âŠ† t
   
   [<a name="SUBSET_MONO_DIFF-val"><b>SUBSET_MONO_DIFF</b></a>]  Theorem
      
      âŠ¢ âˆ€r s t. s âŠ† t â‡’ s DIFF r âŠ† t DIFF r
   
   [<a name="SUBSET_RESTRICT_DIFF-val"><b>SUBSET_RESTRICT_DIFF</b></a>]  Theorem
      
      âŠ¢ âˆ€r s t. s âŠ† t â‡’ r DIFF t âŠ† r DIFF s
   
   [<a name="SUBSET_RESTRICT_L-val"><b>SUBSET_RESTRICT_L</b></a>]  Theorem
      
      âŠ¢ âˆ€r s t. s âŠ† t â‡’ s âˆ© r âŠ† t âˆ© r
   
   [<a name="SUBSET_RESTRICT_R-val"><b>SUBSET_RESTRICT_R</b></a>]  Theorem
      
      âŠ¢ âˆ€r s t. s âŠ† t â‡’ r âˆ© s âŠ† r âˆ© t
   
   [<a name="UNION_BINARY-val"><b>UNION_BINARY</b></a>]  Theorem
      
      âŠ¢ âˆ€a b. a âˆª b = BIGUNION {binary a b i | i âˆˆ ğ•Œ(:num)}
   
   [<a name="UNION_TO_3_DISJOINT_UNIONS-val"><b>UNION_TO_3_DISJOINT_UNIONS</b></a>]  Theorem
      
      âŠ¢ âˆ€s t.
          s âˆª t = s DIFF t âˆª s âˆ© t âˆª (t DIFF s) âˆ§
          disjoint {s DIFF t; s âˆ© t; t DIFF s}
   
   [<a name="countable_disjoint_decomposition-val"><b>countable_disjoint_decomposition</b></a>]  Theorem
      
      âŠ¢ âˆ€c. FINITE c âˆ§ disjoint c â‡’
            âˆƒf n.
              (âˆ€i. i &lt; n â‡’ f i âˆˆ c) âˆ§ (âˆ€i. n â‰¤ i â‡’ f i = âˆ…) âˆ§
              c = IMAGE f (count n) âˆ§
              BIGUNION c = BIGUNION (IMAGE f ğ•Œ(:num)) âˆ§
              (âˆ€i j. i &lt; n âˆ§ j &lt; n âˆ§ i â‰  j â‡’ f i â‰  f j) âˆ§
              âˆ€i j. i &lt; n âˆ§ j &lt; n âˆ§ i â‰  j â‡’ DISJOINT (f i) (f j)
   
   [<a name="disjoint-val"><b>disjoint</b></a>]  Theorem
      
      âŠ¢ âˆ€A. disjoint A â‡” âˆ€a b. a âˆˆ A âˆ§ b âˆˆ A âˆ§ a â‰  b â‡’ a âˆ© b = âˆ…
   
   [<a name="disjointD-val"><b>disjointD</b></a>]  Theorem
      
      âŠ¢ âˆ€A a b. disjoint A â‡’ a âˆˆ A â‡’ b âˆˆ A â‡’ a â‰  b â‡’ DISJOINT a b
   
   [<a name="disjointI-val"><b>disjointI</b></a>]  Theorem
      
      âŠ¢ âˆ€A. (âˆ€a b. a âˆˆ A â‡’ b âˆˆ A â‡’ a â‰  b â‡’ DISJOINT a b) â‡’ disjoint A
   
   [<a name="disjoint_empty-val"><b>disjoint_empty</b></a>]  Theorem
      
      âŠ¢ disjoint âˆ…
   
   [<a name="disjoint_family_disjoint-val"><b>disjoint_family_disjoint</b></a>]  Theorem
      
      âŠ¢ âˆ€A. disjoint_family (disjointed A)
   
   [<a name="disjoint_image-val"><b>disjoint_image</b></a>]  Theorem
      
      âŠ¢ âˆ€f. (âˆ€i j. i â‰  j â‡’ DISJOINT (f i) (f j)) â‡’ disjoint (IMAGE f ğ•Œ(:Î±))
   
   [<a name="disjoint_insert-val"><b>disjoint_insert</b></a>]  Theorem
      
      âŠ¢ âˆ€e c.
          disjoint c âˆ§ (âˆ€x. x âˆˆ c â‡’ DISJOINT x e) â‡’ disjoint (e INSERT c)
   
   [<a name="disjoint_insert_imp-val"><b>disjoint_insert_imp</b></a>]  Theorem
      
      âŠ¢ âˆ€e c. disjoint (e INSERT c) â‡’ disjoint c
   
   [<a name="disjoint_insert_notin-val"><b>disjoint_insert_notin</b></a>]  Theorem
      
      âŠ¢ âˆ€e c. disjoint (e INSERT c) âˆ§ e âˆ‰ c â‡’ âˆ€s. s âˆˆ c â‡’ DISJOINT e s
   
   [<a name="disjoint_restrict-val"><b>disjoint_restrict</b></a>]  Theorem
      
      âŠ¢ âˆ€e c. disjoint c â‡’ disjoint (IMAGE ($INTER e) c)
   
   [<a name="disjoint_same-val"><b>disjoint_same</b></a>]  Theorem
      
      âŠ¢ âˆ€s t. s = t â‡’ disjoint {s; t}
   
   [<a name="disjoint_sing-val"><b>disjoint_sing</b></a>]  Theorem
      
      âŠ¢ âˆ€a. disjoint {a}
   
   [<a name="disjoint_two-val"><b>disjoint_two</b></a>]  Theorem
      
      âŠ¢ âˆ€s t. s â‰  t âˆ§ DISJOINT s t â‡’ disjoint {s; t}
   
   [<a name="disjoint_union-val"><b>disjoint_union</b></a>]  Theorem
      
      âŠ¢ âˆ€A B.
          disjoint A âˆ§ disjoint B âˆ§ BIGUNION A âˆ© BIGUNION B = âˆ… â‡’
          disjoint (A âˆª B)
   
   [<a name="disjointed_subset-val"><b>disjointed_subset</b></a>]  Theorem
      
      âŠ¢ âˆ€A n. disjointed A n âŠ† A n
   
   [<a name="fcp_cross_UNIV-val"><b>fcp_cross_UNIV</b></a>]  Theorem
      
      âŠ¢ FINITE ğ•Œ(:Î²) âˆ§ FINITE ğ•Œ(:Î³) â‡’
        fcp_cross ğ•Œ(:Î±[Î²]) ğ•Œ(:Î±[Î³]) = ğ•Œ(:Î±[Î² + Î³])
   
   [<a name="fcp_cross_alt-val"><b>fcp_cross_alt</b></a>]  Theorem
      
      âŠ¢ âˆ€A B. fcp_cross A B = general_cross FCP_CONCAT A B
   
   [<a name="fcp_prod_alt-val"><b>fcp_prod_alt</b></a>]  Theorem
      
      âŠ¢ âˆ€A B. fcp_prod A B = general_prod FCP_CONCAT A B
   
   [<a name="finite_decomposition-val"><b>finite_decomposition</b></a>]  Theorem
      
      âŠ¢ âˆ€c. FINITE c â‡’
            âˆƒf n.
              (âˆ€x. x &lt; n â‡’ f x âˆˆ c) âˆ§ c = IMAGE f (count n) âˆ§
              âˆ€i j. i &lt; n âˆ§ j &lt; n âˆ§ i â‰  j â‡’ f i â‰  f j
   
   [<a name="finite_decomposition_simple-val"><b>finite_decomposition_simple</b></a>]  Theorem
      
      âŠ¢ âˆ€c. FINITE c â‡’ âˆƒf n. (âˆ€x. x &lt; n â‡’ f x âˆˆ c) âˆ§ c = IMAGE f (count n)
   
   [<a name="finite_disjoint_decomposition-val"><b>finite_disjoint_decomposition</b></a>]  Theorem
      
      âŠ¢ âˆ€c. FINITE c âˆ§ disjoint c â‡’
            âˆƒf n.
              (âˆ€i. i &lt; n â‡’ f i âˆˆ c) âˆ§ c = IMAGE f (count n) âˆ§
              (âˆ€i j. i &lt; n âˆ§ j &lt; n âˆ§ i â‰  j â‡’ f i â‰  f j) âˆ§
              âˆ€i j. i &lt; n âˆ§ j &lt; n âˆ§ i â‰  j â‡’ DISJOINT (f i) (f j)
   
   [<a name="finite_enumeration_of_sets_has_max_non_empty-val"><b>finite_enumeration_of_sets_has_max_non_empty</b></a>]  Theorem
      
      âŠ¢ âˆ€f s.
          FINITE s âˆ§ (âˆ€x. f x âˆˆ s) âˆ§ (âˆ€m n. m â‰  n â‡’ DISJOINT (f m) (f n)) â‡’
          âˆƒN. âˆ€n. n â‰¥ N â‡’ f n = âˆ…
   
   [<a name="general_BIGUNION_CROSS-val"><b>general_BIGUNION_CROSS</b></a>]  Theorem
      
      âŠ¢ âˆ€cons f s t.
          general_cross cons (BIGUNION (IMAGE f s)) t =
          BIGUNION (IMAGE (Î»n. general_cross cons (f n) t) s)
   
   [<a name="general_CROSS_BIGUNION-val"><b>general_CROSS_BIGUNION</b></a>]  Theorem
      
      âŠ¢ âˆ€cons f s t.
          general_cross cons t (BIGUNION (IMAGE f s)) =
          BIGUNION (IMAGE (Î»n. general_cross cons t (f n)) s)
   
   [<a name="general_CROSS_DIFF-val"><b>general_CROSS_DIFF</b></a>]  Theorem
      
      âŠ¢ âˆ€cons car cdr X s t.
          pair_operation cons car cdr â‡’
          general_cross cons (X DIFF s) t =
          general_cross cons X t DIFF general_cross cons s t
   
   [<a name="general_CROSS_DIFF'-val"><b>general_CROSS_DIFF'</b></a>]  Theorem
      
      âŠ¢ âˆ€cons car cdr s X t.
          pair_operation cons car cdr â‡’
          general_cross cons s (X DIFF t) =
          general_cross cons s X DIFF general_cross cons s t
   
   [<a name="general_INTER_CROSS-val"><b>general_INTER_CROSS</b></a>]  Theorem
      
      âŠ¢ âˆ€cons car cdr a b c d.
          pair_operation cons car cdr â‡’
          general_cross cons a b âˆ© general_cross cons c d =
          general_cross cons (a âˆ© c) (b âˆ© d)
   
   [<a name="general_SUBSET_CROSS-val"><b>general_SUBSET_CROSS</b></a>]  Theorem
      
      âŠ¢ âˆ€cons a b c d.
          a âŠ† b âˆ§ c âŠ† d â‡’ general_cross cons a c âŠ† general_cross cons b d
   
   [<a name="infinitely_often_lemma-val"><b>infinitely_often_lemma</b></a>]  Theorem
      
      âŠ¢ âˆ€P. Â¬(âˆƒN. INFINITE N âˆ§ âˆ€n. n âˆˆ N â‡’ P n) â‡” âˆƒm. âˆ€n. m â‰¤ n â‡’ Â¬P n
   
   [<a name="infinity_bound_lemma-val"><b>infinity_bound_lemma</b></a>]  Theorem
      
      âŠ¢ âˆ€N m. INFINITE N â‡’ âˆƒn. m â‰¤ n âˆ§ n âˆˆ N
   
   [<a name="lg_1-val"><b>lg_1</b></a>]  Theorem
      
      âŠ¢ lg 1 = 0
   
   [<a name="lg_2-val"><b>lg_2</b></a>]  Theorem
      
      âŠ¢ lg 2 = 1
   
   [<a name="lg_inv-val"><b>lg_inv</b></a>]  Theorem
      
      âŠ¢ âˆ€x. 0 &lt; x â‡’ lg xâ»Â¹ = -lg x
   
   [<a name="lg_mul-val"><b>lg_mul</b></a>]  Theorem
      
      âŠ¢ âˆ€x y. 0 &lt; x âˆ§ 0 &lt; y â‡’ lg (x * y) = lg x + lg y
   
   [<a name="lg_nonzero-val"><b>lg_nonzero</b></a>]  Theorem
      
      âŠ¢ âˆ€x. x â‰  0 âˆ§ 0 â‰¤ x â‡’ (lg x â‰  0 â‡” x â‰  1)
   
   [<a name="lg_pow-val"><b>lg_pow</b></a>]  Theorem
      
      âŠ¢ âˆ€n. lg (2 pow n) = &n
   
   [<a name="logr_1-val"><b>logr_1</b></a>]  Theorem
      
      âŠ¢ âˆ€b. logr b 1 = 0
   
   [<a name="logr_div-val"><b>logr_div</b></a>]  Theorem
      
      âŠ¢ âˆ€b x y. 0 &lt; x âˆ§ 0 &lt; y â‡’ logr b (x / y) = logr b x âˆ’ logr b y
   
   [<a name="logr_inv-val"><b>logr_inv</b></a>]  Theorem
      
      âŠ¢ âˆ€b x. 0 &lt; x â‡’ logr b xâ»Â¹ = -logr b x
   
   [<a name="logr_mul-val"><b>logr_mul</b></a>]  Theorem
      
      âŠ¢ âˆ€b x y. 0 &lt; x âˆ§ 0 &lt; y â‡’ logr b (x * y) = logr b x + logr b y
   
   [<a name="neg_lg-val"><b>neg_lg</b></a>]  Theorem
      
      âŠ¢ âˆ€x. 0 &lt; x â‡’ -lg x = lg xâ»Â¹
   
   [<a name="neg_logr-val"><b>neg_logr</b></a>]  Theorem
      
      âŠ¢ âˆ€b x. 0 &lt; x â‡’ -logr b x = logr b xâ»Â¹
   
   [<a name="pair_operation_FCP_CONCAT-val"><b>pair_operation_FCP_CONCAT</b></a>]  Theorem
      
      âŠ¢ FINITE ğ•Œ(:Î²) âˆ§ FINITE ğ•Œ(:Î³) â‡’
        pair_operation FCP_CONCAT FCP_FST FCP_SND
   
   [<a name="pair_operation_pair-val"><b>pair_operation_pair</b></a>]  Theorem
      
      âŠ¢ pair_operation $, FST SND
   
   [<a name="prod_sets_alt-val"><b>prod_sets_alt</b></a>]  Theorem
      
      âŠ¢ âˆ€A B. prod_sets A B = general_prod $, A B
   
   [<a name="tail_countable-val"><b>tail_countable</b></a>]  Theorem
      
      âŠ¢ âˆ€A m. countable {A n | m â‰¤ n}
   
   [<a name="tail_not_empty-val"><b>tail_not_empty</b></a>]  Theorem
      
      âŠ¢ âˆ€A m. {A n | m â‰¤ n} â‰  âˆ…
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/probability/util_probScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-14</a></em></p></body></html>
