<!DOCTYPE html>
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta charset="utf-8">
<title>Structure totoTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure totoTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/finite_maps/totoScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature totoTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#ListOrd-val">ListOrd</a> : thm
<a name="line7"></a>    val <a href="#StrongLinearOrder_of_TO-val">StrongLinearOrder_of_TO</a> : thm
<a name="line8"></a>    val <a href="#TO_inv-val">TO_inv</a> : thm
<a name="line9"></a>    val <a href="#TO_of_LinearOrder-val">TO_of_LinearOrder</a> : thm
<a name="line10"></a>    val <a href="#TotOrd-val">TotOrd</a> : thm
<a name="line11"></a>    val <a href="#WeakLinearOrder_of_TO-val">WeakLinearOrder_of_TO</a> : thm
<a name="line12"></a>    val <a href="#charOrd-val">charOrd</a> : thm
<a name="line13"></a>    val <a href="#charto-val">charto</a> : thm
<a name="line14"></a>    val <a href="#imageOrd-val">imageOrd</a> : thm
<a name="line15"></a>    val <a href="#lexTO-val">lexTO</a> : thm
<a name="line16"></a>    val <a href="#lextoto-val">lextoto</a> : thm
<a name="line17"></a>    val <a href="#listoto-val">listoto</a> : thm
<a name="line18"></a>    val <a href="#numOrd-val">numOrd</a> : thm
<a name="line19"></a>    val <a href="#num_dt_TY_DEF-val">num_dt_TY_DEF</a> : thm
<a name="line20"></a>    val <a href="#num_dt_case_def-val">num_dt_case_def</a> : thm
<a name="line21"></a>    val <a href="#num_dt_size_def-val">num_dt_size_def</a> : thm
<a name="line22"></a>    val <a href="#num_to_dt_primitive-val">num_to_dt_primitive</a> : thm
<a name="line23"></a>    val <a href="#numto-val">numto</a> : thm
<a name="line24"></a>    val <a href="#qk_numOrd_def-val">qk_numOrd_def</a> : thm
<a name="line25"></a>    val <a href="#qk_numto-val">qk_numto</a> : thm
<a name="line26"></a>    val <a href="#stringto-val">stringto</a> : thm
<a name="line27"></a>    val <a href="#to_bij-val">to_bij</a> : thm
<a name="line28"></a>    val <a href="#toto_TY_DEF-val">toto_TY_DEF</a> : thm
<a name="line29"></a>    val <a href="#toto_inv-val">toto_inv</a> : thm
<a name="line30"></a>    val <a href="#toto_of_LinearOrder-val">toto_of_LinearOrder</a> : thm
<a name="line31"></a>  
<a name="line32"></a>  (*  Theorems  *)
<a name="line33"></a>    val <a href="#LEX_ALT-val">LEX_ALT</a> : thm
<a name="line34"></a>    val <a href="#ListOrd_THM-val">ListOrd_THM</a> : thm
<a name="line35"></a>    val <a href="#NOT_EQ_LESS_IMP-val">NOT_EQ_LESS_IMP</a> : thm
<a name="line36"></a>    val <a href="#SLO_LEX-val">SLO_LEX</a> : thm
<a name="line37"></a>    val <a href="#SLO_listorder-val">SLO_listorder</a> : thm
<a name="line38"></a>    val <a href="#SPLIT_PAIRS-val">SPLIT_PAIRS</a> : thm
<a name="line39"></a>    val <a href="#STRORD_SLO-val">STRORD_SLO</a> : thm
<a name="line40"></a>    val <a href="#StrongLinearOrderExists-val">StrongLinearOrderExists</a> : thm
<a name="line41"></a>    val <a href="#StrongLinearOrder_LESS-val">StrongLinearOrder_LESS</a> : thm
<a name="line42"></a>    val <a href="#StrongLinearOrder_of_TO_TO_of_LinearOrder-val">StrongLinearOrder_of_TO_TO_of_LinearOrder</a> : thm
<a name="line43"></a>    val <a href="#StrongOrder_ALT-val">StrongOrder_ALT</a> : thm
<a name="line44"></a>    val <a href="#Strong_Strong_of-val">Strong_Strong_of</a> : thm
<a name="line45"></a>    val <a href="#Strong_Strong_of_TO-val">Strong_Strong_of_TO</a> : thm
<a name="line46"></a>    val <a href="#Strong_toto_inv-val">Strong_toto_inv</a> : thm
<a name="line47"></a>    val <a href="#Strong_toto_thm-val">Strong_toto_thm</a> : thm
<a name="line48"></a>    val <a href="#Strongof_toto_STRORD-val">Strongof_toto_STRORD</a> : thm
<a name="line49"></a>    val <a href="#TO_11-val">TO_11</a> : thm
<a name="line50"></a>    val <a href="#TO_ListOrd-val">TO_ListOrd</a> : thm
<a name="line51"></a>    val <a href="#TO_antisym-val">TO_antisym</a> : thm
<a name="line52"></a>    val <a href="#TO_apto_ID-val">TO_apto_ID</a> : thm
<a name="line53"></a>    val <a href="#TO_apto_TO_ID-val">TO_apto_TO_ID</a> : thm
<a name="line54"></a>    val <a href="#TO_apto_TO_IMP-val">TO_apto_TO_IMP</a> : thm
<a name="line55"></a>    val <a href="#TO_charOrd-val">TO_charOrd</a> : thm
<a name="line56"></a>    val <a href="#TO_cpn_eqn-val">TO_cpn_eqn</a> : thm
<a name="line57"></a>    val <a href="#TO_equal_eq-val">TO_equal_eq</a> : thm
<a name="line58"></a>    val <a href="#TO_exists-val">TO_exists</a> : thm
<a name="line59"></a>    val <a href="#TO_injection-val">TO_injection</a> : thm
<a name="line60"></a>    val <a href="#TO_inv_Ord-val">TO_inv_Ord</a> : thm
<a name="line61"></a>    val <a href="#TO_inv_TO_inv-val">TO_inv_TO_inv</a> : thm
<a name="line62"></a>    val <a href="#TO_lexTO-val">TO_lexTO</a> : thm
<a name="line63"></a>    val <a href="#TO_numOrd-val">TO_numOrd</a> : thm
<a name="line64"></a>    val <a href="#TO_of_LinearOrder_LEX-val">TO_of_LinearOrder_LEX</a> : thm
<a name="line65"></a>    val <a href="#TO_of_greater_ler-val">TO_of_greater_ler</a> : thm
<a name="line66"></a>    val <a href="#TO_of_less_rel-val">TO_of_less_rel</a> : thm
<a name="line67"></a>    val <a href="#TO_onto-val">TO_onto</a> : thm
<a name="line68"></a>    val <a href="#TO_qk_numOrd-val">TO_qk_numOrd</a> : thm
<a name="line69"></a>    val <a href="#TO_refl-val">TO_refl</a> : thm
<a name="line70"></a>    val <a href="#TotOrd_TO_of_LO-val">TotOrd_TO_of_LO</a> : thm
<a name="line71"></a>    val <a href="#TotOrd_TO_of_Strong-val">TotOrd_TO_of_Strong</a> : thm
<a name="line72"></a>    val <a href="#TotOrd_TO_of_Weak-val">TotOrd_TO_of_Weak</a> : thm
<a name="line73"></a>    val <a href="#TotOrd_apto-val">TotOrd_apto</a> : thm
<a name="line74"></a>    val <a href="#TotOrd_inv-val">TotOrd_inv</a> : thm
<a name="line75"></a>    val <a href="#Weak_Weak_of-val">Weak_Weak_of</a> : thm
<a name="line76"></a>    val <a href="#Weak_toto_inv-val">Weak_toto_inv</a> : thm
<a name="line77"></a>    val <a href="#Weak_toto_thm-val">Weak_toto_thm</a> : thm
<a name="line78"></a>    val <a href="#all_cpn_distinct-val">all_cpn_distinct</a> : thm
<a name="line79"></a>    val <a href="#ap_qk_numto_thm-val">ap_qk_numto_thm</a> : thm
<a name="line80"></a>    val <a href="#apcharto_thm-val">apcharto_thm</a> : thm
<a name="line81"></a>    val <a href="#aplextoto-val">aplextoto</a> : thm
<a name="line82"></a>    val <a href="#aplistoto-val">aplistoto</a> : thm
<a name="line83"></a>    val <a href="#apnumto_thm-val">apnumto_thm</a> : thm
<a name="line84"></a>    val <a href="#apto_inv-val">apto_inv</a> : thm
<a name="line85"></a>    val <a href="#charOrd_eq_lem-val">charOrd_eq_lem</a> : thm
<a name="line86"></a>    val <a href="#charOrd_gt_lem-val">charOrd_gt_lem</a> : thm
<a name="line87"></a>    val <a href="#charOrd_lt_lem-val">charOrd_lt_lem</a> : thm
<a name="line88"></a>    val <a href="#charOrd_thm-val">charOrd_thm</a> : thm
<a name="line89"></a>    val <a href="#datatype_num_dt-val">datatype_num_dt</a> : thm
<a name="line90"></a>    val <a href="#inv_TO-val">inv_TO</a> : thm
<a name="line91"></a>    val <a href="#lexTO_ALT-val">lexTO_ALT</a> : thm
<a name="line92"></a>    val <a href="#lexTO_thm-val">lexTO_thm</a> : thm
<a name="line93"></a>    val <a href="#listorder-val">listorder</a> : thm
<a name="line94"></a>    val <a href="#listorder_ind-val">listorder_ind</a> : thm
<a name="line95"></a>    val <a href="#num_dtOrd-val">num_dtOrd</a> : thm
<a name="line96"></a>    val <a href="#num_dtOrd_ind-val">num_dtOrd_ind</a> : thm
<a name="line97"></a>    val <a href="#num_dt_11-val">num_dt_11</a> : thm
<a name="line98"></a>    val <a href="#num_dt_Axiom-val">num_dt_Axiom</a> : thm
<a name="line99"></a>    val <a href="#num_dt_case_cong-val">num_dt_case_cong</a> : thm
<a name="line100"></a>    val <a href="#num_dt_case_eq-val">num_dt_case_eq</a> : thm
<a name="line101"></a>    val <a href="#num_dt_distinct-val">num_dt_distinct</a> : thm
<a name="line102"></a>    val <a href="#num_dt_induction-val">num_dt_induction</a> : thm
<a name="line103"></a>    val <a href="#num_dt_nchotomy-val">num_dt_nchotomy</a> : thm
<a name="line104"></a>    val <a href="#numeralOrd-val">numeralOrd</a> : thm
<a name="line105"></a>    val <a href="#onto_apto-val">onto_apto</a> : thm
<a name="line106"></a>    val <a href="#pre_aplextoto-val">pre_aplextoto</a> : thm
<a name="line107"></a>    val <a href="#qk_numeralOrd-val">qk_numeralOrd</a> : thm
<a name="line108"></a>    val <a href="#totoEEtrans-val">totoEEtrans</a> : thm
<a name="line109"></a>    val <a href="#totoELtrans-val">totoELtrans</a> : thm
<a name="line110"></a>    val <a href="#totoGGtrans-val">totoGGtrans</a> : thm
<a name="line111"></a>    val <a href="#totoGLtrans-val">totoGLtrans</a> : thm
<a name="line112"></a>    val <a href="#totoLEtrans-val">totoLEtrans</a> : thm
<a name="line113"></a>    val <a href="#totoLGtrans-val">totoLGtrans</a> : thm
<a name="line114"></a>    val <a href="#totoLLtrans-val">totoLLtrans</a> : thm
<a name="line115"></a>    val <a href="#toto_Strong_thm-val">toto_Strong_thm</a> : thm
<a name="line116"></a>    val <a href="#toto_Weak_thm-val">toto_Weak_thm</a> : thm
<a name="line117"></a>    val <a href="#toto_antisym-val">toto_antisym</a> : thm
<a name="line118"></a>    val <a href="#toto_cpn_eqn-val">toto_cpn_eqn</a> : thm
<a name="line119"></a>    val <a href="#toto_equal_eq-val">toto_equal_eq</a> : thm
<a name="line120"></a>    val <a href="#toto_equal_imp-val">toto_equal_imp</a> : thm
<a name="line121"></a>    val <a href="#toto_equal_imp_eq-val">toto_equal_imp_eq</a> : thm
<a name="line122"></a>    val <a href="#toto_equal_sym-val">toto_equal_sym</a> : thm
<a name="line123"></a>    val <a href="#toto_glneq-val">toto_glneq</a> : thm
<a name="line124"></a>    val <a href="#toto_inv_toto_inv-val">toto_inv_toto_inv</a> : thm
<a name="line125"></a>    val <a href="#toto_not_less_refl-val">toto_not_less_refl</a> : thm
<a name="line126"></a>    val <a href="#toto_refl-val">toto_refl</a> : thm
<a name="line127"></a>    val <a href="#toto_swap_cases-val">toto_swap_cases</a> : thm
<a name="line128"></a>    val <a href="#toto_thm-val">toto_thm</a> : thm
<a name="line129"></a>    val <a href="#toto_trans_less-val">toto_trans_less</a> : thm
<a name="line130"></a>    val <a href="#toto_unequal_imp-val">toto_unequal_imp</a> : thm
<a name="line131"></a>    val <a href="#trichotomous_ALT-val">trichotomous_ALT</a> : thm
<a name="line132"></a>  
<a name="line133"></a>  val toto_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line134"></a>(*
   [ternaryComparisons] Parent theory of "toto"
   
   [wot] Parent theory of "toto"
   
   [<a name="ListOrd-val"><b>ListOrd</b></a>]  Definition
      
      |- !c. ListOrd c =
             TO_of_LinearOrder
               (listorder (StrongLinearOrder_of_TO (apto c)))
   
   [<a name="StrongLinearOrder_of_TO-val"><b>StrongLinearOrder_of_TO</b></a>]  Definition
      
      |- !c x y.
           StrongLinearOrder_of_TO c x y &lt;=&gt;
           case c x y of LESS =&gt; T | EQUAL =&gt; F | GREATER =&gt; F
   
   [<a name="TO_inv-val"><b>TO_inv</b></a>]  Definition
      
      |- !c x y. TO_inv c x y = c y x
   
   [<a name="TO_of_LinearOrder-val"><b>TO_of_LinearOrder</b></a>]  Definition
      
      |- !r x y.
           TO_of_LinearOrder r x y =
           if x = y then EQUAL else if r x y then LESS else GREATER
   
   [<a name="TotOrd-val"><b>TotOrd</b></a>]  Definition
      
      |- !c. TotOrd c &lt;=&gt;
             (!x y. (c x y = EQUAL) &lt;=&gt; (x = y)) /\
             (!x y. (c x y = GREATER) &lt;=&gt; (c y x = LESS)) /\
             !x y z. (c x y = LESS) /\ (c y z = LESS) ==&gt; (c x z = LESS)
   
   [<a name="WeakLinearOrder_of_TO-val"><b>WeakLinearOrder_of_TO</b></a>]  Definition
      
      |- !c x y.
           WeakLinearOrder_of_TO c x y &lt;=&gt;
           case c x y of LESS =&gt; T | EQUAL =&gt; T | GREATER =&gt; F
   
   [<a name="charOrd-val"><b>charOrd</b></a>]  Definition
      
      |- !a b. charOrd a b = numOrd (ORD a) (ORD b)
   
   [<a name="charto-val"><b>charto</b></a>]  Definition
      
      |- charto = TO charOrd
   
   [<a name="imageOrd-val"><b>imageOrd</b></a>]  Definition
      
      |- !f cp a b. imageOrd f cp a b = cp (f a) (f b)
   
   [<a name="lexTO-val"><b>lexTO</b></a>]  Definition
      
      |- !R V.
           R lexTO V =
           TO_of_LinearOrder
             (StrongLinearOrder_of_TO R LEX StrongLinearOrder_of_TO V)
   
   [<a name="lextoto-val"><b>lextoto</b></a>]  Definition
      
      |- !c v. c lextoto v = TO (apto c lexTO apto v)
   
   [<a name="listoto-val"><b>listoto</b></a>]  Definition
      
      |- !c. listoto c = TO (ListOrd c)
   
   [<a name="numOrd-val"><b>numOrd</b></a>]  Definition
      
      |- numOrd = TO_of_LinearOrder $&lt;
   
   [<a name="num_dt_TY_DEF-val"><b>num_dt_TY_DEF</b></a>]  Definition
      
      |- ?rep.
           TYPE_DEFINITION
             (\a0.
                  ! $var$('num_dt').
                    (!a0.
                       (a0 = ind_type$CONSTR 0 ARB (\n. ind_type$BOTTOM)) \/
                       (?a. (a0 =
                             (\a.
                                  ind_type$CONSTR (SUC 0) ARB
                                    (ind_type$FCONS a (\n. ind_type$BOTTOM)))
                               a) /\ $var$('num_dt') a) \/
                       (?a. (a0 =
                             (\a.
                                  ind_type$CONSTR (SUC (SUC 0)) ARB
                                    (ind_type$FCONS a (\n. ind_type$BOTTOM)))
                               a) /\ $var$('num_dt') a) ==&gt;
                       $var$('num_dt') a0) ==&gt;
                    $var$('num_dt') a0) rep
   
   [<a name="num_dt_case_def-val"><b>num_dt_case_def</b></a>]  Definition
      
      |- (!v f f1. num_dt_CASE zer v f f1 = v) /\
         (!a v f f1. num_dt_CASE (bit1 a) v f f1 = f a) /\
         !a v f f1. num_dt_CASE (bit2 a) v f f1 = f1 a
   
   [<a name="num_dt_size_def-val"><b>num_dt_size_def</b></a>]  Definition
      
      |- (num_dt_size zer = 0) /\
         (!a. num_dt_size (bit1 a) = 1 + num_dt_size a) /\
         !a. num_dt_size (bit2 a) = 1 + num_dt_size a
   
   [<a name="num_to_dt_primitive-val"><b>num_to_dt_primitive</b></a>]  Definition
      
      |- num_to_dt =
         WFREC
           (@R. WF R /\ (!n. n &lt;&gt; 0 /\ ODD n ==&gt; R (DIV2 (n - 1)) n) /\
                !n. n &lt;&gt; 0 /\ ~ODD n ==&gt; R (DIV2 (n - 2)) n)
           (\num_to_dt a.
                I
                  (if a = 0 then zer
                   else if ODD a then bit1 (num_to_dt (DIV2 (a - 1)))
                   else bit2 (num_to_dt (DIV2 (a - 2)))))
   
   [<a name="numto-val"><b>numto</b></a>]  Definition
      
      |- numto = TO numOrd
   
   [<a name="qk_numOrd_def-val"><b>qk_numOrd_def</b></a>]  Definition
      
      |- !m n. qk_numOrd m n = num_dtOrd (num_to_dt m) (num_to_dt n)
   
   [<a name="qk_numto-val"><b>qk_numto</b></a>]  Definition
      
      |- qk_numto = TO qk_numOrd
   
   [<a name="stringto-val"><b>stringto</b></a>]  Definition
      
      |- stringto = listoto charto
   
   [<a name="to_bij-val"><b>to_bij</b></a>]  Definition
      
      |- (!a. TO (apto a) = a) /\ !r. TotOrd r &lt;=&gt; (apto (TO r) = r)
   
   [<a name="toto_TY_DEF-val"><b>toto_TY_DEF</b></a>]  Definition
      
      |- ?rep. TYPE_DEFINITION TotOrd rep
   
   [<a name="toto_inv-val"><b>toto_inv</b></a>]  Definition
      
      |- !c. toto_inv c = TO (TO_inv (apto c))
   
   [<a name="toto_of_LinearOrder-val"><b>toto_of_LinearOrder</b></a>]  Definition
      
      |- !r. toto_of_LinearOrder r = TO (TO_of_LinearOrder r)
   
   [<a name="LEX_ALT-val"><b>LEX_ALT</b></a>]  Theorem
      
      |- !R U c d.
           (R LEX U) c d &lt;=&gt;
           R (FST c) (FST d) \/ (FST c = FST d) /\ U (SND c) (SND d)
   
   [<a name="ListOrd_THM-val"><b>ListOrd_THM</b></a>]  Theorem
      
      |- !c. (ListOrd c [] [] = EQUAL) /\
             (!b y. ListOrd c [] (b::y) = LESS) /\
             (!a x. ListOrd c (a::x) [] = GREATER) /\
             !a x b y.
               ListOrd c (a::x) (b::y) =
               case apto c a b of
                 LESS =&gt; LESS
               | EQUAL =&gt; ListOrd c x y
               | GREATER =&gt; GREATER
   
   [<a name="NOT_EQ_LESS_IMP-val"><b>NOT_EQ_LESS_IMP</b></a>]  Theorem
      
      |- !cmp x y.
           apto cmp x y &lt;&gt; LESS ==&gt; (x = y) \/ (apto cmp y x = LESS)
   
   [<a name="SLO_LEX-val"><b>SLO_LEX</b></a>]  Theorem
      
      |- !R V.
           StrongLinearOrder R /\ StrongLinearOrder V ==&gt;
           StrongLinearOrder (R LEX V)
   
   [<a name="SLO_listorder-val"><b>SLO_listorder</b></a>]  Theorem
      
      |- !V. StrongLinearOrder V ==&gt; StrongLinearOrder (listorder V)
   
   [<a name="SPLIT_PAIRS-val"><b>SPLIT_PAIRS</b></a>]  Theorem
      
      |- !x y. (x = y) &lt;=&gt; (FST x = FST y) /\ (SND x = SND y)
   
   [<a name="STRORD_SLO-val"><b>STRORD_SLO</b></a>]  Theorem
      
      |- !R. WeakLinearOrder R ==&gt; StrongLinearOrder (STRORD R)
   
   [<a name="StrongLinearOrderExists-val"><b>StrongLinearOrderExists</b></a>]  Theorem
      
      |- ?R. StrongLinearOrder R
   
   [<a name="StrongLinearOrder_LESS-val"><b>StrongLinearOrder_LESS</b></a>]  Theorem
      
      |- StrongLinearOrder $&lt;
   
   [<a name="StrongLinearOrder_of_TO_TO_of_LinearOrder-val"><b>StrongLinearOrder_of_TO_TO_of_LinearOrder</b></a>]  Theorem
      
      |- !R. irreflexive R ==&gt;
             (StrongLinearOrder_of_TO (TO_of_LinearOrder R) = R)
   
   [<a name="StrongOrder_ALT-val"><b>StrongOrder_ALT</b></a>]  Theorem
      
      |- !Z. StrongOrder Z &lt;=&gt; irreflexive Z /\ transitive Z
   
   [<a name="Strong_Strong_of-val"><b>Strong_Strong_of</b></a>]  Theorem
      
      |- !c. StrongLinearOrder (StrongLinearOrder_of_TO (apto c))
   
   [<a name="Strong_Strong_of_TO-val"><b>Strong_Strong_of_TO</b></a>]  Theorem
      
      |- !c. TotOrd c ==&gt; StrongLinearOrder (StrongLinearOrder_of_TO c)
   
   [<a name="Strong_toto_inv-val"><b>Strong_toto_inv</b></a>]  Theorem
      
      |- !c. StrongLinearOrder_of_TO (apto (toto_inv c)) =
             relinv (StrongLinearOrder_of_TO (apto c))
   
   [<a name="Strong_toto_thm-val"><b>Strong_toto_thm</b></a>]  Theorem
      
      |- !r. StrongLinearOrder r ==&gt;
             (StrongLinearOrder_of_TO (apto (toto_of_LinearOrder r)) = r)
   
   [<a name="Strongof_toto_STRORD-val"><b>Strongof_toto_STRORD</b></a>]  Theorem
      
      |- !c. StrongLinearOrder_of_TO (apto c) =
             STRORD (WeakLinearOrder_of_TO (apto c))
   
   [<a name="TO_11-val"><b>TO_11</b></a>]  Theorem
      
      |- !r r'. TotOrd r ==&gt; TotOrd r' ==&gt; ((TO r = TO r') &lt;=&gt; (r = r'))
   
   [<a name="TO_ListOrd-val"><b>TO_ListOrd</b></a>]  Theorem
      
      |- !c. TotOrd (ListOrd c)
   
   [<a name="TO_antisym-val"><b>TO_antisym</b></a>]  Theorem
      
      |- !c. TotOrd c ==&gt; !x y. (c x y = GREATER) &lt;=&gt; (c y x = LESS)
   
   [<a name="TO_apto_ID-val"><b>TO_apto_ID</b></a>]  Theorem
      
      |- !a. TO (apto a) = a
   
   [<a name="TO_apto_TO_ID-val"><b>TO_apto_TO_ID</b></a>]  Theorem
      
      |- !r. TotOrd r &lt;=&gt; (apto (TO r) = r)
   
   [<a name="TO_apto_TO_IMP-val"><b>TO_apto_TO_IMP</b></a>]  Theorem
      
      |- !r. TotOrd r ==&gt; (apto (TO r) = r)
   
   [<a name="TO_charOrd-val"><b>TO_charOrd</b></a>]  Theorem
      
      |- TotOrd charOrd
   
   [<a name="TO_cpn_eqn-val"><b>TO_cpn_eqn</b></a>]  Theorem
      
      |- !c. TotOrd c ==&gt;
             (!x y. (c x y = LESS) ==&gt; x &lt;&gt; y) /\
             (!x y. (c x y = GREATER) ==&gt; x &lt;&gt; y) /\
             !x y. (c x y = EQUAL) ==&gt; (x = y)
   
   [<a name="TO_equal_eq-val"><b>TO_equal_eq</b></a>]  Theorem
      
      |- !c. TotOrd c ==&gt; !x y. (c x y = EQUAL) &lt;=&gt; (x = y)
   
   [<a name="TO_exists-val"><b>TO_exists</b></a>]  Theorem
      
      |- ?x. TotOrd x
   
   [<a name="TO_injection-val"><b>TO_injection</b></a>]  Theorem
      
      |- !cp. TotOrd cp ==&gt; !f. ONE_ONE f ==&gt; TotOrd (imageOrd f cp)
   
   [<a name="TO_inv_Ord-val"><b>TO_inv_Ord</b></a>]  Theorem
      
      |- !r. TO_of_LinearOrder (relinv r) = TO_inv (TO_of_LinearOrder r)
   
   [<a name="TO_inv_TO_inv-val"><b>TO_inv_TO_inv</b></a>]  Theorem
      
      |- !c. TO_inv (TO_inv c) = c
   
   [<a name="TO_lexTO-val"><b>TO_lexTO</b></a>]  Theorem
      
      |- !R V. TotOrd R /\ TotOrd V ==&gt; TotOrd (R lexTO V)
   
   [<a name="TO_numOrd-val"><b>TO_numOrd</b></a>]  Theorem
      
      |- TotOrd numOrd
   
   [<a name="TO_of_LinearOrder_LEX-val"><b>TO_of_LinearOrder_LEX</b></a>]  Theorem
      
      |- !R V.
           irreflexive R /\ irreflexive V ==&gt;
           (TO_of_LinearOrder (R LEX V) =
            TO_of_LinearOrder R lexTO TO_of_LinearOrder V)
   
   [<a name="TO_of_greater_ler-val"><b>TO_of_greater_ler</b></a>]  Theorem
      
      |- !r. StrongLinearOrder r ==&gt;
             !x y. (TO_of_LinearOrder r x y = GREATER) &lt;=&gt; r y x
   
   [<a name="TO_of_less_rel-val"><b>TO_of_less_rel</b></a>]  Theorem
      
      |- !r. StrongLinearOrder r ==&gt;
             !x y. (TO_of_LinearOrder r x y = LESS) &lt;=&gt; r x y
   
   [<a name="TO_onto-val"><b>TO_onto</b></a>]  Theorem
      
      |- !a. ?r. (a = TO r) /\ TotOrd r
   
   [<a name="TO_qk_numOrd-val"><b>TO_qk_numOrd</b></a>]  Theorem
      
      |- TotOrd qk_numOrd
   
   [<a name="TO_refl-val"><b>TO_refl</b></a>]  Theorem
      
      |- !c. TotOrd c ==&gt; !x. c x x = EQUAL
   
   [<a name="TotOrd_TO_of_LO-val"><b>TotOrd_TO_of_LO</b></a>]  Theorem
      
      |- !r. LinearOrder r ==&gt; TotOrd (TO_of_LinearOrder r)
   
   [<a name="TotOrd_TO_of_Strong-val"><b>TotOrd_TO_of_Strong</b></a>]  Theorem
      
      |- !r. StrongLinearOrder r ==&gt; TotOrd (TO_of_LinearOrder r)
   
   [<a name="TotOrd_TO_of_Weak-val"><b>TotOrd_TO_of_Weak</b></a>]  Theorem
      
      |- !r. WeakLinearOrder r ==&gt; TotOrd (TO_of_LinearOrder r)
   
   [<a name="TotOrd_apto-val"><b>TotOrd_apto</b></a>]  Theorem
      
      |- !c. TotOrd (apto c)
   
   [<a name="TotOrd_inv-val"><b>TotOrd_inv</b></a>]  Theorem
      
      |- !c. TotOrd c ==&gt; TotOrd (TO_inv c)
   
   [<a name="Weak_Weak_of-val"><b>Weak_Weak_of</b></a>]  Theorem
      
      |- !c. WeakLinearOrder (WeakLinearOrder_of_TO (apto c))
   
   [<a name="Weak_toto_inv-val"><b>Weak_toto_inv</b></a>]  Theorem
      
      |- !c. WeakLinearOrder_of_TO (apto (toto_inv c)) =
             relinv (WeakLinearOrder_of_TO (apto c))
   
   [<a name="Weak_toto_thm-val"><b>Weak_toto_thm</b></a>]  Theorem
      
      |- !r. WeakLinearOrder r ==&gt;
             (WeakLinearOrder_of_TO (apto (toto_of_LinearOrder r)) = r)
   
   [<a name="all_cpn_distinct-val"><b>all_cpn_distinct</b></a>]  Theorem
      
      |- (LESS &lt;&gt; EQUAL /\ LESS &lt;&gt; GREATER /\ EQUAL &lt;&gt; GREATER) /\
         EQUAL &lt;&gt; LESS /\ GREATER &lt;&gt; LESS /\ GREATER &lt;&gt; EQUAL
   
   [<a name="ap_qk_numto_thm-val"><b>ap_qk_numto_thm</b></a>]  Theorem
      
      |- apto qk_numto = qk_numOrd
   
   [<a name="apcharto_thm-val"><b>apcharto_thm</b></a>]  Theorem
      
      |- apto charto = charOrd
   
   [<a name="aplextoto-val"><b>aplextoto</b></a>]  Theorem
      
      |- !c v x1 x2 y1 y2.
           apto (c lextoto v) (x1,x2) (y1,y2) =
           case apto c x1 y1 of
             LESS =&gt; LESS
           | EQUAL =&gt; apto v x2 y2
           | GREATER =&gt; GREATER
   
   [<a name="aplistoto-val"><b>aplistoto</b></a>]  Theorem
      
      |- !c. (apto (listoto c) [] [] = EQUAL) /\
             (!b y. apto (listoto c) [] (b::y) = LESS) /\
             (!a x. apto (listoto c) (a::x) [] = GREATER) /\
             !a x b y.
               apto (listoto c) (a::x) (b::y) =
               case apto c a b of
                 LESS =&gt; LESS
               | EQUAL =&gt; apto (listoto c) x y
               | GREATER =&gt; GREATER
   
   [<a name="apnumto_thm-val"><b>apnumto_thm</b></a>]  Theorem
      
      |- apto numto = numOrd
   
   [<a name="apto_inv-val"><b>apto_inv</b></a>]  Theorem
      
      |- !c. apto (toto_inv c) = TO_inv (apto c)
   
   [<a name="charOrd_eq_lem-val"><b>charOrd_eq_lem</b></a>]  Theorem
      
      |- !a b. (numOrd a b = EQUAL) ==&gt; (charOrd (CHR a) (CHR b) = EQUAL)
   
   [<a name="charOrd_gt_lem-val"><b>charOrd_gt_lem</b></a>]  Theorem
      
      |- !a b.
           (numOrd a b = GREATER) ==&gt;
           (a &lt; 256 &lt;=&gt; T) ==&gt;
           (charOrd (CHR a) (CHR b) = GREATER)
   
   [<a name="charOrd_lt_lem-val"><b>charOrd_lt_lem</b></a>]  Theorem
      
      |- !a b.
           (numOrd a b = LESS) ==&gt;
           (b &lt; 256 &lt;=&gt; T) ==&gt;
           (charOrd (CHR a) (CHR b) = LESS)
   
   [<a name="charOrd_thm-val"><b>charOrd_thm</b></a>]  Theorem
      
      |- charOrd = TO_of_LinearOrder $&lt;
   
   [<a name="datatype_num_dt-val"><b>datatype_num_dt</b></a>]  Theorem
      
      |- DATATYPE (num_dt zer bit1 bit2)
   
   [<a name="inv_TO-val"><b>inv_TO</b></a>]  Theorem
      
      |- !r. TotOrd r ==&gt; (toto_inv (TO r) = TO (TO_inv r))
   
   [<a name="lexTO_ALT-val"><b>lexTO_ALT</b></a>]  Theorem
      
      |- !R V.
           TotOrd R /\ TotOrd V ==&gt;
           !(r,u) (r',u').
             (R lexTO V) (r,u) (r',u') =
             case R r r' of
               LESS =&gt; LESS
             | EQUAL =&gt; V u u'
             | GREATER =&gt; GREATER
   
   [<a name="lexTO_thm-val"><b>lexTO_thm</b></a>]  Theorem
      
      |- !R V.
           TotOrd R /\ TotOrd V ==&gt;
           !x y.
             (R lexTO V) x y =
             case R (FST x) (FST y) of
               LESS =&gt; LESS
             | EQUAL =&gt; V (SND x) (SND y)
             | GREATER =&gt; GREATER
   
   [<a name="listorder-val"><b>listorder</b></a>]  Theorem
      
      |- (!l V. listorder V l [] &lt;=&gt; F) /\
         (!s m V. listorder V [] (s::m) &lt;=&gt; T) /\
         !s r m l V.
           listorder V (r::l) (s::m) &lt;=&gt;
           V r s \/ (r = s) /\ listorder V l m
   
   [<a name="listorder_ind-val"><b>listorder_ind</b></a>]  Theorem
      
      |- !P. (!V l. P V l []) /\ (!V s m. P V [] (s::m)) /\
             (!V r l s m. P V l m ==&gt; P V (r::l) (s::m)) ==&gt;
             !v v1 v2. P v v1 v2
   
   [<a name="num_dtOrd-val"><b>num_dtOrd</b></a>]  Theorem
      
      |- (num_dtOrd zer zer = EQUAL) /\
         (!x. num_dtOrd zer (bit1 x) = LESS) /\
         (!x. num_dtOrd zer (bit2 x) = LESS) /\
         (!x. num_dtOrd (bit1 x) zer = GREATER) /\
         (!x. num_dtOrd (bit2 x) zer = GREATER) /\
         (!y x. num_dtOrd (bit1 x) (bit2 y) = LESS) /\
         (!y x. num_dtOrd (bit2 x) (bit1 y) = GREATER) /\
         (!y x. num_dtOrd (bit1 x) (bit1 y) = num_dtOrd x y) /\
         !y x. num_dtOrd (bit2 x) (bit2 y) = num_dtOrd x y
   
   [<a name="num_dtOrd_ind-val"><b>num_dtOrd_ind</b></a>]  Theorem
      
      |- !P. P zer zer /\ (!x. P zer (bit1 x)) /\ (!x. P zer (bit2 x)) /\
             (!x. P (bit1 x) zer) /\ (!x. P (bit2 x) zer) /\
             (!x y. P (bit1 x) (bit2 y)) /\ (!x y. P (bit2 x) (bit1 y)) /\
             (!x y. P x y ==&gt; P (bit1 x) (bit1 y)) /\
             (!x y. P x y ==&gt; P (bit2 x) (bit2 y)) ==&gt;
             !v v1. P v v1
   
   [<a name="num_dt_11-val"><b>num_dt_11</b></a>]  Theorem
      
      |- (!a a'. (bit1 a = bit1 a') &lt;=&gt; (a = a')) /\
         !a a'. (bit2 a = bit2 a') &lt;=&gt; (a = a')
   
   [<a name="num_dt_Axiom-val"><b>num_dt_Axiom</b></a>]  Theorem
      
      |- !f0 f1 f2. ?fn.
           (fn zer = f0) /\ (!a. fn (bit1 a) = f1 a (fn a)) /\
           !a. fn (bit2 a) = f2 a (fn a)
   
   [<a name="num_dt_case_cong-val"><b>num_dt_case_cong</b></a>]  Theorem
      
      |- !M M' v f f1.
           (M = M') /\ ((M' = zer) ==&gt; (v = v')) /\
           (!a. (M' = bit1 a) ==&gt; (f a = f' a)) /\
           (!a. (M' = bit2 a) ==&gt; (f1 a = f1' a)) ==&gt;
           (num_dt_CASE M v f f1 = num_dt_CASE M' v' f' f1')
   
   [<a name="num_dt_case_eq-val"><b>num_dt_case_eq</b></a>]  Theorem
      
      |- (num_dt_CASE x v f f1 = v') &lt;=&gt;
         (x = zer) /\ (v = v') \/ (?n. (x = bit1 n) /\ (f n = v')) \/
         ?n. (x = bit2 n) /\ (f1 n = v')
   
   [<a name="num_dt_distinct-val"><b>num_dt_distinct</b></a>]  Theorem
      
      |- (!a. zer &lt;&gt; bit1 a) /\ (!a. zer &lt;&gt; bit2 a) /\
         !a' a. bit1 a &lt;&gt; bit2 a'
   
   [<a name="num_dt_induction-val"><b>num_dt_induction</b></a>]  Theorem
      
      |- !P. P zer /\ (!n. P n ==&gt; P (bit1 n)) /\ (!n. P n ==&gt; P (bit2 n)) ==&gt;
             !n. P n
   
   [<a name="num_dt_nchotomy-val"><b>num_dt_nchotomy</b></a>]  Theorem
      
      |- !nn. (nn = zer) \/ (?n. nn = bit1 n) \/ ?n. nn = bit2 n
   
   [<a name="numeralOrd-val"><b>numeralOrd</b></a>]  Theorem
      
      |- !x y.
           (numOrd ZERO ZERO = EQUAL) /\ (numOrd ZERO (BIT1 y) = LESS) /\
           (numOrd ZERO (BIT2 y) = LESS) /\
           (numOrd (BIT1 x) ZERO = GREATER) /\
           (numOrd (BIT2 x) ZERO = GREATER) /\
           (numOrd (BIT1 x) (BIT1 y) = numOrd x y) /\
           (numOrd (BIT2 x) (BIT2 y) = numOrd x y) /\
           (numOrd (BIT1 x) (BIT2 y) =
            case numOrd x y of
              LESS =&gt; LESS
            | EQUAL =&gt; LESS
            | GREATER =&gt; GREATER) /\
           (numOrd (BIT2 x) (BIT1 y) =
            case numOrd x y of
              LESS =&gt; LESS
            | EQUAL =&gt; GREATER
            | GREATER =&gt; GREATER)
   
   [<a name="onto_apto-val"><b>onto_apto</b></a>]  Theorem
      
      |- !r. TotOrd r &lt;=&gt; ?a. r = apto a
   
   [<a name="pre_aplextoto-val"><b>pre_aplextoto</b></a>]  Theorem
      
      |- !c v x y.
           apto (c lextoto v) x y =
           case apto c (FST x) (FST y) of
             LESS =&gt; LESS
           | EQUAL =&gt; apto v (SND x) (SND y)
           | GREATER =&gt; GREATER
   
   [<a name="qk_numeralOrd-val"><b>qk_numeralOrd</b></a>]  Theorem
      
      |- !x y.
           (qk_numOrd ZERO ZERO = EQUAL) /\
           (qk_numOrd ZERO (BIT1 y) = LESS) /\
           (qk_numOrd ZERO (BIT2 y) = LESS) /\
           (qk_numOrd (BIT1 x) ZERO = GREATER) /\
           (qk_numOrd (BIT2 x) ZERO = GREATER) /\
           (qk_numOrd (BIT1 x) (BIT1 y) = qk_numOrd x y) /\
           (qk_numOrd (BIT2 x) (BIT2 y) = qk_numOrd x y) /\
           (qk_numOrd (BIT1 x) (BIT2 y) = LESS) /\
           (qk_numOrd (BIT2 x) (BIT1 y) = GREATER)
   
   [<a name="totoEEtrans-val"><b>totoEEtrans</b></a>]  Theorem
      
      |- !c x y z.
           ((apto c x y = EQUAL) /\ (apto c y z = EQUAL) ==&gt;
            (apto c x z = EQUAL)) /\
           ((apto c x y = EQUAL) /\ (apto c z y = EQUAL) ==&gt;
            (apto c x z = EQUAL))
   
   [<a name="totoELtrans-val"><b>totoELtrans</b></a>]  Theorem
      
      |- !c x y z.
           (apto c x y = EQUAL) /\ (apto c y z = LESS) ==&gt;
           (apto c x z = LESS)
   
   [<a name="totoGGtrans-val"><b>totoGGtrans</b></a>]  Theorem
      
      |- !c x y z.
           (apto c y x = GREATER) /\ (apto c z y = GREATER) ==&gt;
           (apto c x z = LESS)
   
   [<a name="totoGLtrans-val"><b>totoGLtrans</b></a>]  Theorem
      
      |- !c x y z.
           (apto c y x = GREATER) /\ (apto c y z = LESS) ==&gt;
           (apto c x z = LESS)
   
   [<a name="totoLEtrans-val"><b>totoLEtrans</b></a>]  Theorem
      
      |- !c x y z.
           (apto c x y = LESS) /\ (apto c y z = EQUAL) ==&gt;
           (apto c x z = LESS)
   
   [<a name="totoLGtrans-val"><b>totoLGtrans</b></a>]  Theorem
      
      |- !c x y z.
           (apto c x y = LESS) /\ (apto c z y = GREATER) ==&gt;
           (apto c x z = LESS)
   
   [<a name="totoLLtrans-val"><b>totoLLtrans</b></a>]  Theorem
      
      |- !c x y z.
           (apto c x y = LESS) /\ (apto c y z = LESS) ==&gt;
           (apto c x z = LESS)
   
   [<a name="toto_Strong_thm-val"><b>toto_Strong_thm</b></a>]  Theorem
      
      |- !c. toto_of_LinearOrder (StrongLinearOrder_of_TO (apto c)) = c
   
   [<a name="toto_Weak_thm-val"><b>toto_Weak_thm</b></a>]  Theorem
      
      |- !c. toto_of_LinearOrder (WeakLinearOrder_of_TO (apto c)) = c
   
   [<a name="toto_antisym-val"><b>toto_antisym</b></a>]  Theorem
      
      |- !c x y. (apto c x y = GREATER) &lt;=&gt; (apto c y x = LESS)
   
   [<a name="toto_cpn_eqn-val"><b>toto_cpn_eqn</b></a>]  Theorem
      
      |- (!c x y. (apto c x y = EQUAL) ==&gt; (x = y)) /\
         (!c x y. (apto c x y = LESS) ==&gt; x &lt;&gt; y) /\
         !c x y. (apto c x y = GREATER) ==&gt; x &lt;&gt; y
   
   [<a name="toto_equal_eq-val"><b>toto_equal_eq</b></a>]  Theorem
      
      |- !c x y. (apto c x y = EQUAL) &lt;=&gt; (x = y)
   
   [<a name="toto_equal_imp-val"><b>toto_equal_imp</b></a>]  Theorem
      
      |- !cmp phi.
           LinearOrder phi /\ (cmp = toto_of_LinearOrder phi) ==&gt;
           !x y. ((x = y) &lt;=&gt; T) ==&gt; (apto cmp x y = EQUAL)
   
   [<a name="toto_equal_imp_eq-val"><b>toto_equal_imp_eq</b></a>]  Theorem
      
      |- !c x y. (apto c x y = EQUAL) ==&gt; (x = y)
   
   [<a name="toto_equal_sym-val"><b>toto_equal_sym</b></a>]  Theorem
      
      |- !c x y. (apto c x y = EQUAL) &lt;=&gt; (apto c y x = EQUAL)
   
   [<a name="toto_glneq-val"><b>toto_glneq</b></a>]  Theorem
      
      |- (!c x y. (apto c x y = LESS) ==&gt; x &lt;&gt; y) /\
         !c x y. (apto c x y = GREATER) ==&gt; x &lt;&gt; y
   
   [<a name="toto_inv_toto_inv-val"><b>toto_inv_toto_inv</b></a>]  Theorem
      
      |- !c. toto_inv (toto_inv c) = c
   
   [<a name="toto_not_less_refl-val"><b>toto_not_less_refl</b></a>]  Theorem
      
      |- !cmp h. (apto cmp h h = LESS) &lt;=&gt; F
   
   [<a name="toto_refl-val"><b>toto_refl</b></a>]  Theorem
      
      |- !c x. apto c x x = EQUAL
   
   [<a name="toto_swap_cases-val"><b>toto_swap_cases</b></a>]  Theorem
      
      |- !c x y.
           apto c y x =
           case apto c x y of
             LESS =&gt; GREATER
           | EQUAL =&gt; EQUAL
           | GREATER =&gt; LESS
   
   [<a name="toto_thm-val"><b>toto_thm</b></a>]  Theorem
      
      |- !c. (!x y. (apto c x y = EQUAL) &lt;=&gt; (x = y)) /\
             (!x y. (apto c x y = GREATER) &lt;=&gt; (apto c y x = LESS)) /\
             !x y z.
               (apto c x y = LESS) /\ (apto c y z = LESS) ==&gt;
               (apto c x z = LESS)
   
   [<a name="toto_trans_less-val"><b>toto_trans_less</b></a>]  Theorem
      
      |- (!c x y z.
            (apto c x y = LESS) /\ (apto c y z = LESS) ==&gt;
            (apto c x z = LESS)) /\
         (!c x y z.
            (apto c x y = LESS) /\ (apto c z y = GREATER) ==&gt;
            (apto c x z = LESS)) /\
         (!c x y z.
            (apto c y x = GREATER) /\ (apto c z y = GREATER) ==&gt;
            (apto c x z = LESS)) /\
         (!c x y z.
            (apto c y x = GREATER) /\ (apto c y z = LESS) ==&gt;
            (apto c x z = LESS)) /\
         (!c x y z.
            (apto c x y = LESS) /\ (apto c y z = EQUAL) ==&gt;
            (apto c x z = LESS)) /\
         !c x y z.
           (apto c x y = EQUAL) /\ (apto c y z = LESS) ==&gt;
           (apto c x z = LESS)
   
   [<a name="toto_unequal_imp-val"><b>toto_unequal_imp</b></a>]  Theorem
      
      |- !cmp phi.
           LinearOrder phi /\ (cmp = toto_of_LinearOrder phi) ==&gt;
           !x y.
             ((x = y) &lt;=&gt; F) ==&gt;
             if phi x y then apto cmp x y = LESS
             else apto cmp x y = GREATER
   
   [<a name="trichotomous_ALT-val"><b>trichotomous_ALT</b></a>]  Theorem
      
      |- !R. trichotomous R &lt;=&gt; !x y. ~R x y /\ ~R y x ==&gt; (x = y)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/finite_maps/totoScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-14</a></em></p></body></html>
