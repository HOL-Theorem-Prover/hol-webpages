<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: util_prob</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "util_prob"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "fcpTheory.html"><span class="strong">fcp</span></a>&nbsp;&nbsp;
    <a href = "numeral_bitTheory.html"><span class="strong">numeral_bit</span></a>&nbsp;&nbsp;
    <a href = "sortingTheory.html"><span class="strong">sorting</span></a>&nbsp;&nbsp;
    <a href = "real_sigmaTheory.html"><span class="strong">real_sigma</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">binary</span>
    <td>
    :α -> α -> num -> α
    <tr><td>
    <span class="strong">disjoint</span>
    <td>
    :((α -> bool) -> bool) -> bool
    <tr><td>
    <span class="strong">disjoint_family</span>
    <td>
    :(α -> β -> bool) -> bool
    <tr><td>
    <span class="strong">disjoint_family_on</span>
    <td>
    :(α -> β -> bool) -> (α -> bool) -> bool
    <tr><td>
    <span class="strong">disjointed</span>
    <td>
    :(num -> α -> bool) -> num -> α -> bool
    <tr><td>
    <span class="strong">fcp_cross</span>
    <td>
    :(α[β] -> bool) -> (α[γ] -> bool) -> α[β + γ] -> bool
    <tr><td>
    <span class="strong">fcp_prod</span>
    <td>
    :((α[β] -> bool) -> bool) ->
    ((α[γ] -> bool) -> bool) -> (α[β + γ] -> bool) -> bool
    <tr><td>
    <span class="strong">general_cross</span>
    <td>
    :(α -> β -> γ) -> (α -> bool) -> (β -> bool) -> γ -> bool
    <tr><td>
    <span class="strong">general_prod</span>
    <td>
    :(α -> β -> γ) ->
    ((α -> bool) -> bool) -> ((β -> bool) -> bool) -> (γ -> bool) -> bool
    <tr><td> <span class="strong">lg</span> <td> :real -> real
    <tr><td> <span class="strong">logr</span> <td> :real -> real -> real
    <tr><td> <span class="strong">minimal</span> <td> :(num -> bool) -> num
    <tr><td>
    <span class="strong">pair_operation</span>
    <td>
    :(α -> β -> γ) -> (γ -> α) -> (γ -> β) -> bool
    <tr><td>
    <span class="strong">prod_sets</span>
    <td>
    :((α -> bool) -> bool) -> ((β -> bool) -> bool) -> (α # β -> bool) -> bool
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">binary_def</span>
<DD>
<pre>
⊢ ∀a b. binary a b = (λx. if x = 0 then a else b)
</pre>

<DT><span class="strong">disjoint_def</span>
<DD>
<pre>
⊢ ∀A. disjoint A ⇔ ∀a b. a ∈ A ∧ b ∈ A ∧ a ≠ b ⇒ DISJOINT a b
</pre>

<DT><span class="strong">disjoint_family</span>
<DD>
<pre>
⊢ ∀A. disjoint_family A ⇔ disjoint_family_on A 𝕌(:α)
</pre>

<DT><span class="strong">disjoint_family_on</span>
<DD>
<pre>
⊢ ∀a s. disjoint_family_on a s ⇔ ∀m n. m ∈ s ∧ n ∈ s ∧ m ≠ n ⇒ (a m ∩ a n = ∅)
</pre>

<DT><span class="strong">disjointed</span>
<DD>
<pre>
⊢ ∀A n. disjointed A n = A n DIFF BIGUNION {A i | i ∈ {x | 0 ≤ x ∧ x < n}}
</pre>

<DT><span class="strong">fcp_cross_def</span>
<DD>
<pre>
⊢ ∀A B. fcp_cross A B = {FCP_CONCAT a b | a ∈ A ∧ b ∈ B}
</pre>

<DT><span class="strong">fcp_prod_def</span>
<DD>
<pre>
⊢ ∀a b. fcp_prod a b = {fcp_cross s t | s ∈ a ∧ t ∈ b}
</pre>

<DT><span class="strong">general_cross_def</span>
<DD>
<pre>
⊢ ∀cons A B. general_cross cons A B = {cons a b | a ∈ A ∧ b ∈ B}
</pre>

<DT><span class="strong">general_prod_def</span>
<DD>
<pre>
⊢ ∀cons A B. general_prod cons A B = {general_cross cons a b | a ∈ A ∧ b ∈ B}
</pre>

<DT><span class="strong">lg_def</span>
<DD>
<pre>
⊢ ∀x. lg x = logr 2 x
</pre>

<DT><span class="strong">logr_def</span>
<DD>
<pre>
⊢ ∀a x. logr a x = ln x / ln a
</pre>

<DT><span class="strong">minimal_def</span>
<DD>
<pre>
⊢ ∀p. minimal p = @n. p n ∧ ∀m. m < n ⇒ ¬p m
</pre>

<DT><span class="strong">pair_operation_def</span>
<DD>
<pre>
⊢ ∀cons car cdr.
    pair_operation cons car cdr ⇔
    (∀a b. (car (cons a b) = a) ∧ (cdr (cons a b) = b)) ∧
    ∀a b c d. (cons a b = cons c d) ⇔ (a = c) ∧ (b = d)
</pre>

<DT><span class="strong">prod_sets_def</span>
<DD>
<pre>
⊢ ∀a b. prod_sets a b = {s × t | s ∈ a ∧ t ∈ b}
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">ADD_POW_2</span>
<DD>
<pre>
⊢ ∀x y. (x + y)² = x² + y² + 2 * x * y
</pre>

<DT><span class="strong">BIGINTER_IMAGE_OVER_INTER_L</span>
<DD>
<pre>
⊢ ∀f n d.
    0 < n ⇒
    (BIGINTER (IMAGE f (count n)) ∩ d =
     BIGINTER (IMAGE (λi. f i ∩ d) (count n)))
</pre>

<DT><span class="strong">BIGINTER_IMAGE_OVER_INTER_R</span>
<DD>
<pre>
⊢ ∀f n d.
    0 < n ⇒
    (d ∩ BIGINTER (IMAGE f (count n)) =
     BIGINTER (IMAGE (λi. d ∩ f i) (count n)))
</pre>

<DT><span class="strong">BIGINTER_PAIR</span>
<DD>
<pre>
⊢ ∀s t. BIGINTER {s; t} = s ∩ t
</pre>

<DT><span class="strong">BIGUNION_IMAGE_BIGUNION_IMAGE_UNIV</span>
<DD>
<pre>
⊢ ∀f. BIGUNION (IMAGE (λn. BIGUNION (IMAGE (f n) 𝕌(:num))) 𝕌(:num)) =
      BIGUNION (IMAGE fᴾ 𝕌(:num # num))
</pre>

<DT><span class="strong">BIGUNION_IMAGE_COUNT_IMP_UNIV</span>
<DD>
<pre>
⊢ ∀f g.
    (∀n. BIGUNION (IMAGE g (count n)) = BIGUNION (IMAGE f (count n))) ⇒
    (BIGUNION (IMAGE f 𝕌(:num)) = BIGUNION (IMAGE g 𝕌(:num)))
</pre>

<DT><span class="strong">BIGUNION_IMAGE_OVER_INTER_L</span>
<DD>
<pre>
⊢ ∀f n d.
    BIGUNION (IMAGE f (count n)) ∩ d =
    BIGUNION (IMAGE (λi. f i ∩ d) (count n))
</pre>

<DT><span class="strong">BIGUNION_IMAGE_OVER_INTER_R</span>
<DD>
<pre>
⊢ ∀f n d.
    d ∩ BIGUNION (IMAGE f (count n)) =
    BIGUNION (IMAGE (λi. d ∩ f i) (count n))
</pre>

<DT><span class="strong">BIGUNION_IMAGE_UNIV_CROSS_UNIV</span>
<DD>
<pre>
⊢ ∀f h.
    BIJ h 𝕌(:num) (𝕌(:num) × 𝕌(:num)) ⇒
    (BIGUNION (IMAGE fᴾ 𝕌(:num # num)) = BIGUNION (IMAGE (fᴾ ∘ h) 𝕌(:num)))
</pre>

<DT><span class="strong">BIGUNION_OVER_DIFF</span>
<DD>
<pre>
⊢ ∀f d.
    BIGUNION (IMAGE f 𝕌(:num)) DIFF d =
    BIGUNION (IMAGE (λi. f i DIFF d) 𝕌(:num))
</pre>

<DT><span class="strong">BIGUNION_OVER_INTER_L</span>
<DD>
<pre>
⊢ ∀f d.
    BIGUNION (IMAGE f 𝕌(:num)) ∩ d = BIGUNION (IMAGE (λi. f i ∩ d) 𝕌(:num))
</pre>

<DT><span class="strong">BIGUNION_OVER_INTER_R</span>
<DD>
<pre>
⊢ ∀f d.
    d ∩ BIGUNION (IMAGE f 𝕌(:num)) = BIGUNION (IMAGE (λi. d ∩ f i) 𝕌(:num))
</pre>

<DT><span class="strong">BIGUNION_disjointed</span>
<DD>
<pre>
⊢ ∀A. BIGUNION {disjointed A i | i ∈ 𝕌(:num)} = BIGUNION {A i | i ∈ 𝕌(:num)}
</pre>

<DT><span class="strong">BINARY_RANGE</span>
<DD>
<pre>
⊢ ∀a b. IMAGE (binary a b) 𝕌(:num) = {a; b}
</pre>

<DT><span class="strong">COMPL_BIGINTER</span>
<DD>
<pre>
⊢ ∀c. COMPL (BIGINTER c) = BIGUNION (IMAGE COMPL c)
</pre>

<DT><span class="strong">COMPL_BIGINTER_IMAGE</span>
<DD>
<pre>
⊢ ∀f. COMPL (BIGINTER (IMAGE f 𝕌(:num))) =
      BIGUNION (IMAGE (COMPL ∘ f) 𝕌(:num))
</pre>

<DT><span class="strong">COMPL_BIGUNION</span>
<DD>
<pre>
⊢ ∀c. c ≠ ∅ ⇒ (COMPL (BIGUNION c) = BIGINTER (IMAGE COMPL c))
</pre>

<DT><span class="strong">COMPL_BIGUNION_IMAGE</span>
<DD>
<pre>
⊢ ∀f. COMPL (BIGUNION (IMAGE f 𝕌(:num))) =
      BIGINTER (IMAGE (COMPL ∘ f) 𝕌(:num))
</pre>

<DT><span class="strong">CROSS_ALT</span>
<DD>
<pre>
⊢ ∀A B. A × B = general_cross $, A B
</pre>

<DT><span class="strong">DIFF_INTER_PAIR</span>
<DD>
<pre>
⊢ ∀sp x y. sp DIFF x ∩ y = sp DIFF x ∪ (sp DIFF y)
</pre>

<DT><span class="strong">DINTER_IMP_FINITE_INTER</span>
<DD>
<pre>
⊢ ∀sts f.
    (∀s t. s ∈ sts ∧ t ∈ sts ⇒ s ∩ t ∈ sts) ∧ f ∈ (𝕌(:num) → sts) ⇒
    ∀n. 0 < n ⇒ BIGINTER (IMAGE f (count n)) ∈ sts
</pre>

<DT><span class="strong">DISJOINT_CROSS_L</span>
<DD>
<pre>
⊢ ∀s t c. DISJOINT s t ⇒ DISJOINT (s × c) (t × c)
</pre>

<DT><span class="strong">DISJOINT_CROSS_R</span>
<DD>
<pre>
⊢ ∀s t c. DISJOINT s t ⇒ DISJOINT (c × s) (c × t)
</pre>

<DT><span class="strong">DISJOINT_RESTRICT_L</span>
<DD>
<pre>
⊢ ∀s t c. DISJOINT s t ⇒ DISJOINT (s ∩ c) (t ∩ c)
</pre>

<DT><span class="strong">DISJOINT_RESTRICT_R</span>
<DD>
<pre>
⊢ ∀s t c. DISJOINT s t ⇒ DISJOINT (c ∩ s) (c ∩ t)
</pre>

<DT><span class="strong">DUNION_IMP_FINITE_UNION</span>
<DD>
<pre>
⊢ ∀sts f.
    (∀s t. s ∈ sts ∧ t ∈ sts ⇒ s ∪ t ∈ sts) ⇒
    ∀n. 0 < n ∧ (∀i. i < n ⇒ f i ∈ sts) ⇒ BIGUNION (IMAGE f (count n)) ∈ sts
</pre>

<DT><span class="strong">FCP_BIGUNION_CROSS</span>
<DD>
<pre>
⊢ ∀f s t.
    fcp_cross (BIGUNION (IMAGE f s)) t =
    BIGUNION (IMAGE (λn. fcp_cross (f n) t) s)
</pre>

<DT><span class="strong">FCP_CROSS_BIGUNION</span>
<DD>
<pre>
⊢ ∀f s t.
    fcp_cross t (BIGUNION (IMAGE f s)) =
    BIGUNION (IMAGE (λn. fcp_cross t (f n)) s)
</pre>

<DT><span class="strong">FCP_CROSS_DIFF</span>
<DD>
<pre>
⊢ ∀X s t.
    FINITE 𝕌(:β) ∧ FINITE 𝕌(:γ) ⇒
    (fcp_cross (X DIFF s) t = fcp_cross X t DIFF fcp_cross s t)
</pre>

<DT><span class="strong">FCP_CROSS_DIFF'</span>
<DD>
<pre>
⊢ ∀s X t.
    FINITE 𝕌(:β) ∧ FINITE 𝕌(:γ) ⇒
    (fcp_cross s (X DIFF t) = fcp_cross s X DIFF fcp_cross s t)
</pre>

<DT><span class="strong">FCP_INTER_CROSS</span>
<DD>
<pre>
⊢ ∀a b c d.
    FINITE 𝕌(:β) ∧ FINITE 𝕌(:γ) ⇒
    (fcp_cross a b ∩ fcp_cross c d = fcp_cross (a ∩ c) (b ∩ d))
</pre>

<DT><span class="strong">FCP_SUBSET_CROSS</span>
<DD>
<pre>
⊢ ∀a b c d. a ⊆ b ∧ c ⊆ d ⇒ fcp_cross a c ⊆ fcp_cross b d
</pre>

<DT><span class="strong">GBIGUNION_IMAGE</span>
<DD>
<pre>
⊢ ∀s p n. {s | ∃n. p s n} = BIGUNION (IMAGE (λn. {s | p s n}) 𝕌(:γ))
</pre>

<DT><span class="strong">GEN_COMPL_BIGINTER</span>
<DD>
<pre>
⊢ ∀sp c.
    (∀x. x ∈ c ⇒ x ⊆ sp) ⇒
    (sp DIFF BIGINTER c = BIGUNION (IMAGE (λx. sp DIFF x) c))
</pre>

<DT><span class="strong">GEN_COMPL_BIGINTER_IMAGE</span>
<DD>
<pre>
⊢ ∀sp f.
    (∀n. f n ⊆ sp) ⇒
    (sp DIFF BIGINTER (IMAGE f 𝕌(:num)) =
     BIGUNION (IMAGE (λn. sp DIFF f n) 𝕌(:num)))
</pre>

<DT><span class="strong">GEN_COMPL_BIGUNION</span>
<DD>
<pre>
⊢ ∀sp c.
    c ≠ ∅ ∧ (∀x. x ∈ c ⇒ x ⊆ sp) ⇒
    (sp DIFF BIGUNION c = BIGINTER (IMAGE (λx. sp DIFF x) c))
</pre>

<DT><span class="strong">GEN_COMPL_BIGUNION_IMAGE</span>
<DD>
<pre>
⊢ ∀sp f.
    (∀n. f n ⊆ sp) ⇒
    (sp DIFF BIGUNION (IMAGE f 𝕌(:num)) =
     BIGINTER (IMAGE (λn. sp DIFF f n) 𝕌(:num)))
</pre>

<DT><span class="strong">GEN_COMPL_FINITE_INTER</span>
<DD>
<pre>
⊢ ∀sp f n.
    0 < n ⇒
    (sp DIFF BIGINTER (IMAGE f (count n)) =
     BIGUNION (IMAGE (λi. sp DIFF f i) (count n)))
</pre>

<DT><span class="strong">GEN_COMPL_FINITE_UNION</span>
<DD>
<pre>
⊢ ∀sp f n.
    0 < n ⇒
    (sp DIFF BIGUNION (IMAGE f (count n)) =
     BIGINTER (IMAGE (λi. sp DIFF f i) (count n)))
</pre>

<DT><span class="strong">GEN_COMPL_INTER</span>
<DD>
<pre>
⊢ ∀sp s t. s ⊆ sp ∧ t ⊆ sp ⇒ (sp DIFF s ∩ t = sp DIFF s ∪ (sp DIFF t))
</pre>

<DT><span class="strong">GEN_COMPL_UNION</span>
<DD>
<pre>
⊢ ∀sp s t. s ⊆ sp ∧ t ⊆ sp ⇒ (sp DIFF (s ∪ t) = (sp DIFF s) ∩ (sp DIFF t))
</pre>

<DT><span class="strong">GEN_DIFF_INTER</span>
<DD>
<pre>
⊢ ∀sp s t. s ⊆ sp ∧ t ⊆ sp ⇒ (s DIFF t = s ∩ (sp DIFF t))
</pre>

<DT><span class="strong">HARMONIC_SERIES_POW_2</span>
<DD>
<pre>
⊢ summable (λn. (&SUC n)² ⁻¹)
</pre>

<DT><span class="strong">INCREASING_TO_DISJOINT_SETS</span>
<DD>
<pre>
⊢ ∀f. (∀n. f n ⊆ f (SUC n)) ⇒
      ∃g. (g 0 = f 0) ∧ (∀n. 0 < n ⇒ (g n = f n DIFF f (PRE n))) ∧
          (∀i j. i ≠ j ⇒ DISJOINT (g i) (g j)) ∧
          (BIGUNION (IMAGE f 𝕌(:num)) = BIGUNION (IMAGE g 𝕌(:num)))
</pre>

<DT><span class="strong">INCREASING_TO_DISJOINT_SETS'</span>
<DD>
<pre>
⊢ ∀f. (f 0 = ∅) ∧ (∀n. f n ⊆ f (SUC n)) ⇒
      ∃g. (∀n. g n = f (SUC n) DIFF f n) ∧
          (∀i j. i ≠ j ⇒ DISJOINT (g i) (g j)) ∧
          (BIGUNION (IMAGE f 𝕌(:num)) = BIGUNION (IMAGE g 𝕌(:num)))
</pre>

<DT><span class="strong">INF_CLOSE</span>
<DD>
<pre>
⊢ ∀p e. (∃x. x ∈ p) ∧ 0 < e ⇒ ∃x. x ∈ p ∧ x < inf p + e
</pre>

<DT><span class="strong">INF_DEF_ALT</span>
<DD>
<pre>
⊢ ∀p. inf p = -sup (λr. -r ∈ p)
</pre>

<DT><span class="strong">INF_GREATER</span>
<DD>
<pre>
⊢ ∀p z. (∃x. x ∈ p) ∧ inf p < z ⇒ ∃x. x ∈ p ∧ x < z
</pre>

<DT><span class="strong">INF_LE</span>
<DD>
<pre>
⊢ ∀p r. (∃z. ∀x. x ∈ p ⇒ z ≤ x) ∧ (∃x. x ∈ p ∧ x ≤ r) ⇒ inf p ≤ r
</pre>

<DT><span class="strong">INTER_BINARY</span>
<DD>
<pre>
⊢ ∀a b. a ∩ b = BIGINTER {binary a b i | i ∈ 𝕌(:num)}
</pre>

<DT><span class="strong">IN_FCP_CROSS</span>
<DD>
<pre>
⊢ ∀s a b. s ∈ fcp_cross a b ⇔ ∃t u. (s = FCP_CONCAT t u) ∧ t ∈ a ∧ u ∈ b
</pre>

<DT><span class="strong">IN_FCP_PROD</span>
<DD>
<pre>
⊢ ∀s A B. s ∈ fcp_prod A B ⇔ ∃a b. (s = fcp_cross a b) ∧ a ∈ A ∧ b ∈ B
</pre>

<DT><span class="strong">IN_PROD_SETS</span>
<DD>
<pre>
⊢ ∀s a b. s ∈ prod_sets a b ⇔ ∃t u. (s = t × u) ∧ t ∈ a ∧ u ∈ b
</pre>

<DT><span class="strong">IN_general_cross</span>
<DD>
<pre>
⊢ ∀cons s A B.
    s ∈ general_cross cons A B ⇔ ∃a b. (s = cons a b) ∧ a ∈ A ∧ b ∈ B
</pre>

<DT><span class="strong">IN_general_prod</span>
<DD>
<pre>
⊢ ∀cons s A B.
    s ∈ general_prod cons A B ⇔
    ∃a b. (s = general_cross cons a b) ∧ a ∈ A ∧ b ∈ B
</pre>

<DT><span class="strong">IN_o</span>
<DD>
<pre>
⊢ ∀x f s. x ∈ s ∘ f ⇔ f x ∈ s
</pre>

<DT><span class="strong">LE_INF</span>
<DD>
<pre>
⊢ ∀p r. (∃x. x ∈ p) ∧ (∀x. x ∈ p ⇒ r ≤ x) ⇒ r ≤ inf p
</pre>

<DT><span class="strong">LOGR_MONO_LE</span>
<DD>
<pre>
⊢ ∀x y b. 0 < x ∧ 0 < y ∧ 1 < b ⇒ (logr b x ≤ logr b y ⇔ x ≤ y)
</pre>

<DT><span class="strong">LOGR_MONO_LE_IMP</span>
<DD>
<pre>
⊢ ∀x y b. 0 < x ∧ x ≤ y ∧ 1 ≤ b ⇒ logr b x ≤ logr b y
</pre>

<DT><span class="strong">MINIMAL_EQ</span>
<DD>
<pre>
⊢ ∀p m. p m ∧ (m = minimal p) ⇔ p m ∧ ∀n. n < m ⇒ ¬p n
</pre>

<DT><span class="strong">MINIMAL_EQ_IMP</span>
<DD>
<pre>
⊢ ∀m p. p m ∧ (∀n. n < m ⇒ ¬p n) ⇒ (m = minimal p)
</pre>

<DT><span class="strong">MINIMAL_EXISTS</span>
<DD>
<pre>
⊢ ∀P. (∃n. P n) ⇔ P (minimal P) ∧ ∀n. n < minimal P ⇒ ¬P n
</pre>

<DT><span class="strong">MINIMAL_EXISTS0</span>
<DD>
<pre>
⊢ (∃n. P n) ⇔ ∃n. P n ∧ ∀m. m < n ⇒ ¬P m
</pre>

<DT><span class="strong">MINIMAL_EXISTS_IMP</span>
<DD>
<pre>
⊢ ∀P. (∃n. P n) ⇒ ∃m. P m ∧ ∀n. n < m ⇒ ¬P n
</pre>

<DT><span class="strong">MINIMAL_SUC</span>
<DD>
<pre>
⊢ ∀n p.
    (SUC n = minimal p) ∧ p (SUC n) ⇔
    ¬p 0 ∧ (n = minimal (p ∘ SUC)) ∧ p (SUC n)
</pre>

<DT><span class="strong">MINIMAL_SUC_IMP</span>
<DD>
<pre>
⊢ ∀n p. p (SUC n) ∧ ¬p 0 ∧ (n = minimal (p ∘ SUC)) ⇒ (SUC n = minimal p)
</pre>

<DT><span class="strong">NUM_2D_BIJ</span>
<DD>
<pre>
⊢ ∃f. BIJ f (𝕌(:num) × 𝕌(:num)) 𝕌(:num)
</pre>

<DT><span class="strong">NUM_2D_BIJ_INV</span>
<DD>
<pre>
⊢ ∃f. BIJ f 𝕌(:num) (𝕌(:num) × 𝕌(:num))
</pre>

<DT><span class="strong">NUM_2D_BIJ_NZ</span>
<DD>
<pre>
⊢ ∃f. BIJ f (𝕌(:num) × (𝕌(:num) DIFF {0})) 𝕌(:num)
</pre>

<DT><span class="strong">NUM_2D_BIJ_NZ_ALT</span>
<DD>
<pre>
⊢ ∃f. BIJ f (𝕌(:num) × 𝕌(:num)) (𝕌(:num) DIFF {0})
</pre>

<DT><span class="strong">NUM_2D_BIJ_NZ_ALT2</span>
<DD>
<pre>
⊢ ∃f. BIJ f ((𝕌(:num) DIFF {0}) × (𝕌(:num) DIFF {0})) 𝕌(:num)
</pre>

<DT><span class="strong">NUM_2D_BIJ_NZ_ALT2_INV</span>
<DD>
<pre>
⊢ ∃f. BIJ f 𝕌(:num) ((𝕌(:num) DIFF {0}) × (𝕌(:num) DIFF {0}))
</pre>

<DT><span class="strong">NUM_2D_BIJ_NZ_ALT_INV</span>
<DD>
<pre>
⊢ ∃f. BIJ f (𝕌(:num) DIFF {0}) (𝕌(:num) × 𝕌(:num))
</pre>

<DT><span class="strong">NUM_2D_BIJ_NZ_INV</span>
<DD>
<pre>
⊢ ∃f. BIJ f 𝕌(:num) (𝕌(:num) × (𝕌(:num) DIFF {0}))
</pre>

<DT><span class="strong">NUM_2D_BIJ_nfst_nsnd</span>
<DD>
<pre>
⊢ BIJ (λn. (nfst n,nsnd n)) 𝕌(:num) (𝕌(:num) × 𝕌(:num))
</pre>

<DT><span class="strong">NUM_2D_BIJ_npair</span>
<DD>
<pre>
⊢ BIJ $*,ᴾ (𝕌(:num) × 𝕌(:num)) 𝕌(:num)
</pre>

<DT><span class="strong">PAIRED_BETA_THM</span>
<DD>
<pre>
⊢ ∀f z. fᴾ z = f (FST z) (SND z)
</pre>

<DT><span class="strong">POW_HALF_MONO</span>
<DD>
<pre>
⊢ ∀m n. m ≤ n ⇒ (1 / 2) pow n ≤ (1 / 2) pow m
</pre>

<DT><span class="strong">POW_HALF_POS</span>
<DD>
<pre>
⊢ ∀n. 0 < (1 / 2) pow n
</pre>

<DT><span class="strong">POW_HALF_SMALL</span>
<DD>
<pre>
⊢ ∀e. 0 < e ⇒ ∃n. (1 / 2) pow n < e
</pre>

<DT><span class="strong">POW_NEG_ODD</span>
<DD>
<pre>
⊢ ∀x. x < 0 ⇒ (x pow n < 0 ⇔ ODD n)
</pre>

<DT><span class="strong">POW_POS_EVEN</span>
<DD>
<pre>
⊢ ∀x. x < 0 ⇒ (0 < x pow n ⇔ EVEN n)
</pre>

<DT><span class="strong">PREIMAGE_REAL_COMPL1</span>
<DD>
<pre>
⊢ ∀c. COMPL {x | c < x} = {x | x ≤ c}
</pre>

<DT><span class="strong">PREIMAGE_REAL_COMPL2</span>
<DD>
<pre>
⊢ ∀c. COMPL {x | c ≤ x} = {x | x < c}
</pre>

<DT><span class="strong">PREIMAGE_REAL_COMPL3</span>
<DD>
<pre>
⊢ ∀c. COMPL {x | x ≤ c} = {x | c < x}
</pre>

<DT><span class="strong">PREIMAGE_REAL_COMPL4</span>
<DD>
<pre>
⊢ ∀c. COMPL {x | x < c} = {x | c ≤ x}
</pre>

<DT><span class="strong">REAL_ARCH_INV'</span>
<DD>
<pre>
⊢ ∀x. 0 < x ⇒ ∃n. (&n)⁻¹ < x
</pre>

<DT><span class="strong">REAL_ARCH_INV_SUC</span>
<DD>
<pre>
⊢ ∀x. 0 < x ⇒ ∃n. (&SUC n)⁻¹ < x
</pre>

<DT><span class="strong">REAL_LE_LT_MUL</span>
<DD>
<pre>
⊢ ∀x y. 0 ≤ x ∧ 0 < y ⇒ 0 ≤ x * y
</pre>

<DT><span class="strong">REAL_LE_RDIV_EQ_NEG</span>
<DD>
<pre>
⊢ ∀x y z. z < 0 ⇒ (y / z ≤ x ⇔ x * z ≤ y)
</pre>

<DT><span class="strong">REAL_LT_LE_MUL</span>
<DD>
<pre>
⊢ ∀x y. 0 < x ∧ 0 ≤ y ⇒ 0 ≤ x * y
</pre>

<DT><span class="strong">REAL_LT_LMUL_0_NEG</span>
<DD>
<pre>
⊢ ∀x y. 0 < x * y ∧ x < 0 ⇒ y < 0
</pre>

<DT><span class="strong">REAL_LT_LMUL_NEG_0</span>
<DD>
<pre>
⊢ ∀x y. x * y < 0 ∧ 0 < x ⇒ y < 0
</pre>

<DT><span class="strong">REAL_LT_LMUL_NEG_0_NEG</span>
<DD>
<pre>
⊢ ∀x y. x * y < 0 ∧ x < 0 ⇒ 0 < y
</pre>

<DT><span class="strong">REAL_LT_MAX_BETWEEN</span>
<DD>
<pre>
⊢ ∀x b d. x < max b d ∧ b ≤ x ⇒ x < d
</pre>

<DT><span class="strong">REAL_LT_RDIV_EQ_NEG</span>
<DD>
<pre>
⊢ ∀x y z. z < 0 ⇒ (y / z < x ⇔ x * z < y)
</pre>

<DT><span class="strong">REAL_LT_RMUL_0_NEG</span>
<DD>
<pre>
⊢ ∀x y. 0 < x * y ∧ y < 0 ⇒ x < 0
</pre>

<DT><span class="strong">REAL_LT_RMUL_NEG_0</span>
<DD>
<pre>
⊢ ∀x y. x * y < 0 ∧ 0 < y ⇒ x < 0
</pre>

<DT><span class="strong">REAL_LT_RMUL_NEG_0_NEG</span>
<DD>
<pre>
⊢ ∀x y. x * y < 0 ∧ y < 0 ⇒ 0 < x
</pre>

<DT><span class="strong">REAL_MAX_REDUCE</span>
<DD>
<pre>
⊢ ∀x y. x ≤ y ∨ x < y ⇒ (max x y = y) ∧ (max y x = y)
</pre>

<DT><span class="strong">REAL_MIN_LE_BETWEEN</span>
<DD>
<pre>
⊢ ∀x a c. min a c ≤ x ∧ x < a ⇒ c ≤ x
</pre>

<DT><span class="strong">REAL_MIN_REDUCE</span>
<DD>
<pre>
⊢ ∀x y. x ≤ y ∨ x < y ⇒ (min x y = x) ∧ (min y x = x)
</pre>

<DT><span class="strong">REAL_MUL_IDEMPOT</span>
<DD>
<pre>
⊢ ∀r. (r * r = r) ⇔ (r = 0) ∨ (r = 1)
</pre>

<DT><span class="strong">REAL_NEG_NZ</span>
<DD>
<pre>
⊢ ∀x. x < 0 ⇒ x ≠ 0
</pre>

<DT><span class="strong">REAL_SUP_LE_X</span>
<DD>
<pre>
⊢ ∀P x. (∃r. P r) ∧ (∀r. P r ⇒ r ≤ x) ⇒ sup P ≤ x
</pre>

<DT><span class="strong">REAL_X_LE_SUP</span>
<DD>
<pre>
⊢ ∀P x. (∃r. P r) ∧ (∃z. ∀r. P r ⇒ r ≤ z) ∧ (∃r. P r ∧ x ≤ r) ⇒ x ≤ sup P
</pre>

<DT><span class="strong">SETS_TO_DISJOINT_SETS</span>
<DD>
<pre>
⊢ ∀sp sts f.
    (∀s. s ∈ sts ⇒ s ⊆ sp) ∧ (∀n. f n ∈ sts) ⇒
    ∃g. (g 0 = f 0) ∧
        (∀n. 0 < n ⇒
             (g n = f n ∩ BIGINTER (IMAGE (λi. sp DIFF f i) (count n)))) ∧
        (∀i j. i ≠ j ⇒ DISJOINT (g i) (g j)) ∧
        (BIGUNION (IMAGE f 𝕌(:num)) = BIGUNION (IMAGE g 𝕌(:num)))
</pre>

<DT><span class="strong">SETS_TO_DISJOINT_SETS'</span>
<DD>
<pre>
⊢ ∀f. ∃g.
    (g 0 = f 0) ∧
    (∀n. 0 < n ⇒ (g n = f n ∩ BIGINTER (IMAGE (COMPL ∘ f) (count n)))) ∧
    (∀i j. i ≠ j ⇒ DISJOINT (g i) (g j)) ∧
    (BIGUNION (IMAGE f 𝕌(:num)) = BIGUNION (IMAGE g 𝕌(:num)))
</pre>

<DT><span class="strong">SETS_TO_INCREASING_SETS</span>
<DD>
<pre>
⊢ ∀f. ∃g.
    (g 0 = f 0) ∧ (∀n. g n = BIGUNION (IMAGE f (count (SUC n)))) ∧
    (∀n. g n ⊆ g (SUC n)) ∧
    (BIGUNION (IMAGE f 𝕌(:num)) = BIGUNION (IMAGE g 𝕌(:num)))
</pre>

<DT><span class="strong">SETS_TO_INCREASING_SETS'</span>
<DD>
<pre>
⊢ ∀f. ∃g.
    (g 0 = ∅) ∧ (∀n. g n = BIGUNION (IMAGE f (count n))) ∧
    (∀n. g n ⊆ g (SUC n)) ∧
    (BIGUNION (IMAGE f 𝕌(:num)) = BIGUNION (IMAGE g 𝕌(:num)))
</pre>

<DT><span class="strong">SUBSET_DIFF_DISJOINT</span>
<DD>
<pre>
⊢ ∀s1 s2 s3. s1 ⊆ s2 DIFF s3 ⇒ DISJOINT s1 s3
</pre>

<DT><span class="strong">SUBSET_DIFF_SUBSET</span>
<DD>
<pre>
⊢ ∀r s t. s ⊆ t ⇒ s DIFF r ⊆ t
</pre>

<DT><span class="strong">SUBSET_INTER_SUBSET_L</span>
<DD>
<pre>
⊢ ∀r s t. s ⊆ t ⇒ s ∩ r ⊆ t
</pre>

<DT><span class="strong">SUBSET_INTER_SUBSET_R</span>
<DD>
<pre>
⊢ ∀r s t. s ⊆ t ⇒ r ∩ s ⊆ t
</pre>

<DT><span class="strong">SUBSET_MONO_DIFF</span>
<DD>
<pre>
⊢ ∀r s t. s ⊆ t ⇒ s DIFF r ⊆ t DIFF r
</pre>

<DT><span class="strong">SUBSET_RESTRICT_DIFF</span>
<DD>
<pre>
⊢ ∀r s t. s ⊆ t ⇒ r DIFF t ⊆ r DIFF s
</pre>

<DT><span class="strong">SUBSET_RESTRICT_L</span>
<DD>
<pre>
⊢ ∀r s t. s ⊆ t ⇒ s ∩ r ⊆ t ∩ r
</pre>

<DT><span class="strong">SUBSET_RESTRICT_R</span>
<DD>
<pre>
⊢ ∀r s t. s ⊆ t ⇒ r ∩ s ⊆ r ∩ t
</pre>

<DT><span class="strong">UNION_BINARY</span>
<DD>
<pre>
⊢ ∀a b. a ∪ b = BIGUNION {binary a b i | i ∈ 𝕌(:num)}
</pre>

<DT><span class="strong">UNION_TO_3_DISJOINT_UNIONS</span>
<DD>
<pre>
⊢ ∀s t.
    (s ∪ t = s DIFF t ∪ s ∩ t ∪ (t DIFF s)) ∧
    disjoint {s DIFF t; s ∩ t; t DIFF s}
</pre>

<DT><span class="strong">countable_disjoint_decomposition</span>
<DD>
<pre>
⊢ ∀c. FINITE c ∧ disjoint c ⇒
      ∃f n.
        (∀i. i < n ⇒ f i ∈ c) ∧ (∀i. n ≤ i ⇒ (f i = ∅)) ∧
        (c = IMAGE f (count n)) ∧ (BIGUNION c = BIGUNION (IMAGE f 𝕌(:num))) ∧
        (∀i j. i < n ∧ j < n ∧ i ≠ j ⇒ f i ≠ f j) ∧
        ∀i j. i < n ∧ j < n ∧ i ≠ j ⇒ DISJOINT (f i) (f j)
</pre>

<DT><span class="strong">disjoint</span>
<DD>
<pre>
⊢ ∀A. disjoint A ⇔ ∀a b. a ∈ A ∧ b ∈ A ∧ a ≠ b ⇒ (a ∩ b = ∅)
</pre>

<DT><span class="strong">disjointD</span>
<DD>
<pre>
⊢ ∀A a b. disjoint A ⇒ a ∈ A ⇒ b ∈ A ⇒ a ≠ b ⇒ DISJOINT a b
</pre>

<DT><span class="strong">disjointI</span>
<DD>
<pre>
⊢ ∀A. (∀a b. a ∈ A ⇒ b ∈ A ⇒ a ≠ b ⇒ DISJOINT a b) ⇒ disjoint A
</pre>

<DT><span class="strong">disjoint_empty</span>
<DD>
<pre>
⊢ disjoint ∅
</pre>

<DT><span class="strong">disjoint_family_disjoint</span>
<DD>
<pre>
⊢ ∀A. disjoint_family (disjointed A)
</pre>

<DT><span class="strong">disjoint_image</span>
<DD>
<pre>
⊢ ∀f. (∀i j. i ≠ j ⇒ DISJOINT (f i) (f j)) ⇒ disjoint (IMAGE f 𝕌(:α))
</pre>

<DT><span class="strong">disjoint_insert</span>
<DD>
<pre>
⊢ ∀e c. disjoint c ∧ (∀x. x ∈ c ⇒ DISJOINT x e) ⇒ disjoint (e INSERT c)
</pre>

<DT><span class="strong">disjoint_insert_imp</span>
<DD>
<pre>
⊢ ∀e c. disjoint (e INSERT c) ⇒ disjoint c
</pre>

<DT><span class="strong">disjoint_insert_notin</span>
<DD>
<pre>
⊢ ∀e c. disjoint (e INSERT c) ∧ e ∉ c ⇒ ∀s. s ∈ c ⇒ DISJOINT e s
</pre>

<DT><span class="strong">disjoint_restrict</span>
<DD>
<pre>
⊢ ∀e c. disjoint c ⇒ disjoint (IMAGE ($INTER e) c)
</pre>

<DT><span class="strong">disjoint_same</span>
<DD>
<pre>
⊢ ∀s t. (s = t) ⇒ disjoint {s; t}
</pre>

<DT><span class="strong">disjoint_sing</span>
<DD>
<pre>
⊢ ∀a. disjoint {a}
</pre>

<DT><span class="strong">disjoint_two</span>
<DD>
<pre>
⊢ ∀s t. s ≠ t ∧ DISJOINT s t ⇒ disjoint {s; t}
</pre>

<DT><span class="strong">disjoint_union</span>
<DD>
<pre>
⊢ ∀A B.
    disjoint A ∧ disjoint B ∧ (BIGUNION A ∩ BIGUNION B = ∅) ⇒ disjoint (A ∪ B)
</pre>

<DT><span class="strong">disjointed_subset</span>
<DD>
<pre>
⊢ ∀A n. disjointed A n ⊆ A n
</pre>

<DT><span class="strong">fcp_cross_UNIV</span>
<DD>
<pre>
⊢ FINITE 𝕌(:β) ∧ FINITE 𝕌(:γ) ⇒ (fcp_cross 𝕌(:α[β]) 𝕌(:α[γ]) = 𝕌(:α[β + γ]))
</pre>

<DT><span class="strong">fcp_cross_alt</span>
<DD>
<pre>
⊢ ∀A B. fcp_cross A B = general_cross FCP_CONCAT A B
</pre>

<DT><span class="strong">fcp_prod_alt</span>
<DD>
<pre>
⊢ ∀A B. fcp_prod A B = general_prod FCP_CONCAT A B
</pre>

<DT><span class="strong">finite_decomposition</span>
<DD>
<pre>
⊢ ∀c. FINITE c ⇒
      ∃f n.
        (∀x. x < n ⇒ f x ∈ c) ∧ (c = IMAGE f (count n)) ∧
        ∀i j. i < n ∧ j < n ∧ i ≠ j ⇒ f i ≠ f j
</pre>

<DT><span class="strong">finite_decomposition_simple</span>
<DD>
<pre>
⊢ ∀c. FINITE c ⇒ ∃f n. (∀x. x < n ⇒ f x ∈ c) ∧ (c = IMAGE f (count n))
</pre>

<DT><span class="strong">finite_disjoint_decomposition</span>
<DD>
<pre>
⊢ ∀c. FINITE c ∧ disjoint c ⇒
      ∃f n.
        (∀i. i < n ⇒ f i ∈ c) ∧ (c = IMAGE f (count n)) ∧
        (∀i j. i < n ∧ j < n ∧ i ≠ j ⇒ f i ≠ f j) ∧
        ∀i j. i < n ∧ j < n ∧ i ≠ j ⇒ DISJOINT (f i) (f j)
</pre>

<DT><span class="strong">finite_enumeration_of_sets_has_max_non_empty</span>
<DD>
<pre>
⊢ ∀f s.
    FINITE s ∧ (∀x. f x ∈ s) ∧ (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ⇒
    ∃N. ∀n. n ≥ N ⇒ (f n = ∅)
</pre>

<DT><span class="strong">general_BIGUNION_CROSS</span>
<DD>
<pre>
⊢ ∀cons f s t.
    general_cross cons (BIGUNION (IMAGE f s)) t =
    BIGUNION (IMAGE (λn. general_cross cons (f n) t) s)
</pre>

<DT><span class="strong">general_CROSS_BIGUNION</span>
<DD>
<pre>
⊢ ∀cons f s t.
    general_cross cons t (BIGUNION (IMAGE f s)) =
    BIGUNION (IMAGE (λn. general_cross cons t (f n)) s)
</pre>

<DT><span class="strong">general_CROSS_DIFF</span>
<DD>
<pre>
⊢ ∀cons car cdr X s t.
    pair_operation cons car cdr ⇒
    (general_cross cons (X DIFF s) t =
     general_cross cons X t DIFF general_cross cons s t)
</pre>

<DT><span class="strong">general_CROSS_DIFF'</span>
<DD>
<pre>
⊢ ∀cons car cdr s X t.
    pair_operation cons car cdr ⇒
    (general_cross cons s (X DIFF t) =
     general_cross cons s X DIFF general_cross cons s t)
</pre>

<DT><span class="strong">general_INTER_CROSS</span>
<DD>
<pre>
⊢ ∀cons car cdr a b c d.
    pair_operation cons car cdr ⇒
    (general_cross cons a b ∩ general_cross cons c d =
     general_cross cons (a ∩ c) (b ∩ d))
</pre>

<DT><span class="strong">general_SUBSET_CROSS</span>
<DD>
<pre>
⊢ ∀cons a b c d.
    a ⊆ b ∧ c ⊆ d ⇒ general_cross cons a c ⊆ general_cross cons b d
</pre>

<DT><span class="strong">infinitely_often_lemma</span>
<DD>
<pre>
⊢ ∀P. ¬(∃N. INFINITE N ∧ ∀n. n ∈ N ⇒ P n) ⇔ ∃m. ∀n. m ≤ n ⇒ ¬P n
</pre>

<DT><span class="strong">infinity_bound_lemma</span>
<DD>
<pre>
⊢ ∀N m. INFINITE N ⇒ ∃n. m ≤ n ∧ n ∈ N
</pre>

<DT><span class="strong">lg_1</span>
<DD>
<pre>
⊢ lg 1 = 0
</pre>

<DT><span class="strong">lg_2</span>
<DD>
<pre>
⊢ lg 2 = 1
</pre>

<DT><span class="strong">lg_inv</span>
<DD>
<pre>
⊢ ∀x. 0 < x ⇒ (lg x⁻¹ = -lg x)
</pre>

<DT><span class="strong">lg_mul</span>
<DD>
<pre>
⊢ ∀x y. 0 < x ∧ 0 < y ⇒ (lg (x * y) = lg x + lg y)
</pre>

<DT><span class="strong">lg_nonzero</span>
<DD>
<pre>
⊢ ∀x. x ≠ 0 ∧ 0 ≤ x ⇒ (lg x ≠ 0 ⇔ x ≠ 1)
</pre>

<DT><span class="strong">lg_pow</span>
<DD>
<pre>
⊢ ∀n. lg (2 pow n) = &n
</pre>

<DT><span class="strong">logr_1</span>
<DD>
<pre>
⊢ ∀b. logr b 1 = 0
</pre>

<DT><span class="strong">logr_div</span>
<DD>
<pre>
⊢ ∀b x y. 0 < x ∧ 0 < y ⇒ (logr b (x / y) = logr b x − logr b y)
</pre>

<DT><span class="strong">logr_inv</span>
<DD>
<pre>
⊢ ∀b x. 0 < x ⇒ (logr b x⁻¹ = -logr b x)
</pre>

<DT><span class="strong">logr_mul</span>
<DD>
<pre>
⊢ ∀b x y. 0 < x ∧ 0 < y ⇒ (logr b (x * y) = logr b x + logr b y)
</pre>

<DT><span class="strong">neg_lg</span>
<DD>
<pre>
⊢ ∀x. 0 < x ⇒ (-lg x = lg x⁻¹)
</pre>

<DT><span class="strong">neg_logr</span>
<DD>
<pre>
⊢ ∀b x. 0 < x ⇒ (-logr b x = logr b x⁻¹)
</pre>

<DT><span class="strong">pair_operation_FCP_CONCAT</span>
<DD>
<pre>
⊢ FINITE 𝕌(:β) ∧ FINITE 𝕌(:γ) ⇒ pair_operation FCP_CONCAT FCP_FST FCP_SND
</pre>

<DT><span class="strong">pair_operation_pair</span>
<DD>
<pre>
⊢ pair_operation $, FST SND
</pre>

<DT><span class="strong">prod_sets_alt</span>
<DD>
<pre>
⊢ ∀A B. prod_sets A B = general_prod $, A B
</pre>

<DT><span class="strong">tail_countable</span>
<DD>
<pre>
⊢ ∀A m. COUNTABLE {A n | m ≤ n}
</pre>

<DT><span class="strong">tail_not_empty</span>
<DD>
<pre>
⊢ ∀A m. {A n | m ≤ n} ≠ ∅
</pre>

</DL>



<hr>
</body>
</html>
