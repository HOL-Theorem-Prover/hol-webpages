<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: enumeral</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "enumeral"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "totoTheory.html"><span class="strong">toto</span></a>&nbsp;&nbsp;
    <a href = "res_quanTheory.html"><span class="strong">res_quan</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Type <th> Arity<tr><td> <span class="strong">bl</span> <td> 1
    <tr><td> <span class="strong">bt</span> <td> 1
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">BL_ACCUM</span>
    <td>
    :α -> α bt -> α bl -> α bl
    <tr><td> <span class="strong">BL_CONS</span> <td> :α -> α bl -> α bl
    <tr><td>
    <span class="strong">ENUMERAL</span>
    <td>
    :α toto -> α bt -> α -> bool
    <tr><td> <span class="strong">K2</span> <td> :α -> num
    <tr><td>
    <span class="strong">LESS_ALL</span>
    <td>
    :α toto -> α -> (α -> bool) -> bool
    <tr><td> <span class="strong">OL</span> <td> :α toto -> α list -> bool
    <tr><td> <span class="strong">OL_bt</span> <td> :α toto -> α bt -> bool
    <tr><td>
    <span class="strong">OL_bt_lb</span>
    <td>
    :α toto -> α -> α bt -> bool
    <tr><td>
    <span class="strong">OL_bt_lb_ub</span>
    <td>
    :α toto -> α -> α bt -> α -> bool
    <tr><td>
    <span class="strong">OL_bt_ub</span>
    <td>
    :α toto -> α bt -> α -> bool
    <tr><td>
    <span class="strong">OL_sublists</span>
    <td>
    :α toto -> α list option list -> bool
    <tr><td>
    <span class="strong">OU</span>
    <td>
    :α toto -> (α -> bool) -> (α -> bool) -> α -> bool
    <tr><td>
    <span class="strong">OWL</span>
    <td>
    :α toto -> (α -> bool) -> α list -> bool
    <tr><td>
    <span class="strong">UO</span>
    <td>
    :α toto -> (α -> bool) -> (α -> bool) -> α -> bool
    <tr><td>
    <span class="strong">bl_CASE</span>
    <td>
    :α bl -> β -> (α bl -> β) -> (α -> α bt -> α bl -> β) -> β
    <tr><td> <span class="strong">bl_rev</span> <td> :α bt -> α bl -> α bt
    <tr><td>
    <span class="strong">bl_size</span>
    <td>
    :(α -> num) -> α bl -> num
    <tr><td> <span class="strong">bl_to_bt</span> <td> :α bl -> α bt
    <tr><td>
    <span class="strong">bl_to_set</span>
    <td>
    :α toto -> α bl -> α -> bool
    <tr><td>
    <span class="strong">bt_CASE</span>
    <td>
    :α bt -> β -> (α bt -> α -> α bt -> β) -> β
    <tr><td> <span class="strong">bt_rev</span> <td> :α bt -> α bl -> α bl
    <tr><td>
    <span class="strong">bt_size</span>
    <td>
    :(α -> num) -> α bt -> num
    <tr><td> <span class="strong">bt_to_bl</span> <td> :α bt -> α bl
    <tr><td> <span class="strong">bt_to_list</span> <td> :α bt -> α list
    <tr><td>
    <span class="strong">bt_to_list_ac</span>
    <td>
    :α bt -> α list -> α list
    <tr><td>
    <span class="strong">bt_to_ol</span>
    <td>
    :α toto -> α bt -> α list
    <tr><td>
    <span class="strong">bt_to_ol_ac</span>
    <td>
    :α toto -> α bt -> α list -> α list
    <tr><td>
    <span class="strong">bt_to_ol_lb</span>
    <td>
    :α toto -> α -> α bt -> α list
    <tr><td>
    <span class="strong">bt_to_ol_lb_ac</span>
    <td>
    :α toto -> α -> α bt -> α list -> α list
    <tr><td>
    <span class="strong">bt_to_ol_lb_ub</span>
    <td>
    :α toto -> α -> α bt -> α -> α list
    <tr><td>
    <span class="strong">bt_to_ol_lb_ub_ac</span>
    <td>
    :α toto -> α -> α bt -> α -> α list -> α list
    <tr><td>
    <span class="strong">bt_to_ol_ub</span>
    <td>
    :α toto -> α bt -> α -> α list
    <tr><td>
    <span class="strong">bt_to_ol_ub_ac</span>
    <td>
    :α toto -> α bt -> α -> α list -> α list
    <tr><td>
    <span class="strong">bt_to_set_lb</span>
    <td>
    :α toto -> α -> α bt -> α -> bool
    <tr><td>
    <span class="strong">bt_to_set_lb_ub</span>
    <td>
    :α toto -> α -> α bt -> α -> α -> bool
    <tr><td>
    <span class="strong">bt_to_set_ub</span>
    <td>
    :α toto -> α bt -> α -> α -> bool
    <tr><td>
    <span class="strong">incr_sbuild</span>
    <td>
    :α toto -> α list -> α list option list
    <tr><td>
    <span class="strong">incr_smerge</span>
    <td>
    :α toto -> α list -> α list option list -> α list option list
    <tr><td>
    <span class="strong">incr_ssort</span>
    <td>
    :α toto -> α list -> α list
    <tr><td> <span class="strong">list_to_bl</span> <td> :α list -> α bl
    <tr><td> <span class="strong">list_to_bt</span> <td> :γ list -> γ bt
    <tr><td>
    <span class="strong">lol_set</span>
    <td>
    :α list option list -> α -> bool
    <tr><td> <span class="strong">nbl</span> <td> :α bl
    <tr><td> <span class="strong">node</span> <td> :α bt -> α -> α bt -> α bt
    <tr><td> <span class="strong">nt</span> <td> :α bt
    <tr><td> <span class="strong">onebl</span> <td> :α -> α bt -> α bl -> α bl
    <tr><td>
    <span class="strong">sdiff</span>
    <td>
    :α toto -> α list -> α list -> α list
    <tr><td>
    <span class="strong">sinter</span>
    <td>
    :α toto -> α list -> α list -> α list
    <tr><td>
    <span class="strong">smerge</span>
    <td>
    :α toto -> α list -> α list -> α list
    <tr><td>
    <span class="strong">smerge_out</span>
    <td>
    :α toto -> α list -> α list option list -> α list
    <tr><td> <span class="strong">zerbl</span> <td> :α bl -> α bl
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">BL_ACCUM</span>
<DD>
<pre>
⊢ (∀a ac. BL_ACCUM a ac nbl = onebl a ac nbl) ∧
  (∀a ac bl. BL_ACCUM a ac (zerbl bl) = onebl a ac bl) ∧
  ∀a ac r rft bl.
    BL_ACCUM a ac (onebl r rft bl) = zerbl (BL_ACCUM a (node ac r rft) bl)
</pre>

<DT><span class="strong">BL_CONS</span>
<DD>
<pre>
⊢ ∀a bl. BL_CONS a bl = BL_ACCUM a nt bl
</pre>

<DT><span class="strong">K2</span>
<DD>
<pre>
⊢ ∀a. K2 a = 2
</pre>

<DT><span class="strong">LESS_ALL</span>
<DD>
<pre>
⊢ ∀cmp x s. LESS_ALL cmp x s ⇔ ∀y. y ∈ s ⇒ (apto cmp x y = Less)
</pre>

<DT><span class="strong">OL</span>
<DD>
<pre>
⊢ (∀cmp. OL cmp [] ⇔ T) ∧
  ∀cmp a l. OL cmp (a::l) ⇔ OL cmp l ∧ ∀p. MEM p l ⇒ (apto cmp a p = Less)
</pre>

<DT><span class="strong">OL_bt</span>
<DD>
<pre>
⊢ (∀cmp. OL_bt cmp nt ⇔ T) ∧
  ∀cmp l x r. OL_bt cmp (node l x r) ⇔ OL_bt_ub cmp l x ∧ OL_bt_lb cmp x r
</pre>

<DT><span class="strong">OL_bt_lb</span>
<DD>
<pre>
⊢ (∀cmp lb. OL_bt_lb cmp lb nt ⇔ T) ∧
  ∀cmp lb l x r.
    OL_bt_lb cmp lb (node l x r) ⇔ OL_bt_lb_ub cmp lb l x ∧ OL_bt_lb cmp x r
</pre>

<DT><span class="strong">OL_bt_lb_ub</span>
<DD>
<pre>
⊢ (∀cmp lb ub. OL_bt_lb_ub cmp lb nt ub ⇔ (apto cmp lb ub = Less)) ∧
  ∀cmp lb l x r ub.
    OL_bt_lb_ub cmp lb (node l x r) ub ⇔
    OL_bt_lb_ub cmp lb l x ∧ OL_bt_lb_ub cmp x r ub
</pre>

<DT><span class="strong">OL_bt_ub</span>
<DD>
<pre>
⊢ (∀cmp ub. OL_bt_ub cmp nt ub ⇔ T) ∧
  ∀cmp l x r ub.
    OL_bt_ub cmp (node l x r) ub ⇔ OL_bt_ub cmp l x ∧ OL_bt_lb_ub cmp x r ub
</pre>

<DT><span class="strong">OU</span>
<DD>
<pre>
⊢ ∀cmp t u. OU cmp t u = {x | x ∈ t ∧ ∀z. z ∈ u ⇒ (apto cmp x z = Less)} ∪ u
</pre>

<DT><span class="strong">OWL</span>
<DD>
<pre>
⊢ ∀cmp s l. OWL cmp s l ⇔ (s = LIST_TO_SET l) ∧ OL cmp l
</pre>

<DT><span class="strong">UO</span>
<DD>
<pre>
⊢ ∀cmp s t. UO cmp s t = s ∪ {y | y ∈ t ∧ ∀z. z ∈ s ⇒ (apto cmp z y = Less)}
</pre>

<DT><span class="strong">bl_TY_DEF</span>
<DD>
<pre>
⊢ ∃rep.
    TYPE_DEFINITION
      (λa0'.
           ∀ $var$('bl').
             (∀a0'.
                (a0' = ind_type$CONSTR 0 (ARB,ARB) (λn. ind_type$BOTTOM)) ∨
                (∃a. (a0' =
                      (λa.
                           ind_type$CONSTR (SUC 0) (ARB,ARB)
                             (ind_type$FCONS a (λn. ind_type$BOTTOM))) a) ∧
                     $var$('bl') a) ∨
                (∃a0 a1 a2.
                   (a0' =
                    (λa0 a1 a2.
                         ind_type$CONSTR (SUC (SUC 0)) (a0,a1)
                           (ind_type$FCONS a2 (λn. ind_type$BOTTOM))) a0 a1 a2) ∧
                   $var$('bl') a2) ⇒
                $var$('bl') a0') ⇒
             $var$('bl') a0') rep
</pre>

<DT><span class="strong">bl_case_def</span>
<DD>
<pre>
⊢ (∀v f f1. bl_CASE nbl v f f1 = v) ∧
  (∀a v f f1. bl_CASE (zerbl a) v f f1 = f a) ∧
  ∀a0 a1 a2 v f f1. bl_CASE (onebl a0 a1 a2) v f f1 = f1 a0 a1 a2
</pre>

<DT><span class="strong">bl_rev</span>
<DD>
<pre>
⊢ (∀ft. bl_rev ft nbl = ft) ∧ (∀ft b. bl_rev ft (zerbl b) = bl_rev ft b) ∧
  ∀ft a f b. bl_rev ft (onebl a f b) = bl_rev (node ft a f) b
</pre>

<DT><span class="strong">bl_size_def</span>
<DD>
<pre>
⊢ (∀f. bl_size f nbl = 0) ∧ (∀f a. bl_size f (zerbl a) = 1 + bl_size f a) ∧
  ∀f a0 a1 a2.
    bl_size f (onebl a0 a1 a2) = 1 + (f a0 + (bt_size f a1 + bl_size f a2))
</pre>

<DT><span class="strong">bl_to_bt</span>
<DD>
<pre>
⊢ bl_to_bt = bl_rev nt
</pre>

<DT><span class="strong">bl_to_set</span>
<DD>
<pre>
⊢ (∀cmp. bl_to_set cmp nbl = ∅) ∧
  (∀cmp b. bl_to_set cmp (zerbl b) = bl_to_set cmp b) ∧
  ∀cmp x t b.
    bl_to_set cmp (onebl x t b) =
    OU cmp ({x} ∪ {y | y ∈ ENUMERAL cmp t ∧ (apto cmp x y = Less)})
      (bl_to_set cmp b)
</pre>

<DT><span class="strong">bt_TY_DEF</span>
<DD>
<pre>
⊢ ∃rep.
    TYPE_DEFINITION
      (λa0'.
           ∀ $var$('bt').
             (∀a0'.
                (a0' = ind_type$CONSTR 0 ARB (λn. ind_type$BOTTOM)) ∨
                (∃a0 a1 a2.
                   (a0' =
                    (λa0 a1 a2.
                         ind_type$CONSTR (SUC 0) a1
                           (ind_type$FCONS a0
                              (ind_type$FCONS a2 (λn. ind_type$BOTTOM)))) a0
                      a1 a2) ∧ $var$('bt') a0 ∧ $var$('bt') a2) ⇒
                $var$('bt') a0') ⇒
             $var$('bt') a0') rep
</pre>

<DT><span class="strong">bt_rev</span>
<DD>
<pre>
⊢ (∀bl. bt_rev nt bl = bl) ∧
  ∀lft r rft bl. bt_rev (node lft r rft) bl = bt_rev lft (onebl r rft bl)
</pre>

<DT><span class="strong">bt_size_def</span>
<DD>
<pre>
⊢ (∀f. bt_size f nt = 0) ∧
  ∀f a0 a1 a2.
    bt_size f (node a0 a1 a2) = 1 + (bt_size f a0 + (f a1 + bt_size f a2))
</pre>

<DT><span class="strong">bt_to_bl</span>
<DD>
<pre>
⊢ ∀t. bt_to_bl t = bt_rev t nbl
</pre>

<DT><span class="strong">bt_to_list</span>
<DD>
<pre>
⊢ (bt_to_list nt = []) ∧
  ∀l x r. bt_to_list (node l x r) = bt_to_list l ++ [x] ++ bt_to_list r
</pre>

<DT><span class="strong">bt_to_list_ac</span>
<DD>
<pre>
⊢ (∀m. bt_to_list_ac nt m = m) ∧
  ∀l x r m.
    bt_to_list_ac (node l x r) m = bt_to_list_ac l (x::bt_to_list_ac r m)
</pre>

<DT><span class="strong">bt_to_ol</span>
<DD>
<pre>
⊢ (∀cmp. bt_to_ol cmp nt = []) ∧
  ∀cmp l x r.
    bt_to_ol cmp (node l x r) =
    bt_to_ol_ub cmp l x ++ [x] ++ bt_to_ol_lb cmp x r
</pre>

<DT><span class="strong">bt_to_ol_ac</span>
<DD>
<pre>
⊢ (∀cmp m. bt_to_ol_ac cmp nt m = m) ∧
  ∀cmp l x r m.
    bt_to_ol_ac cmp (node l x r) m =
    bt_to_ol_ub_ac cmp l x (x::bt_to_ol_lb_ac cmp x r m)
</pre>

<DT><span class="strong">bt_to_ol_lb</span>
<DD>
<pre>
⊢ (∀cmp lb. bt_to_ol_lb cmp lb nt = []) ∧
  ∀cmp lb l x r.
    bt_to_ol_lb cmp lb (node l x r) =
    if apto cmp lb x = Less then
      bt_to_ol_lb_ub cmp lb l x ++ [x] ++ bt_to_ol_lb cmp x r
    else bt_to_ol_lb cmp lb r
</pre>

<DT><span class="strong">bt_to_ol_lb_ac</span>
<DD>
<pre>
⊢ (∀cmp lb m. bt_to_ol_lb_ac cmp lb nt m = m) ∧
  ∀cmp lb l x r m.
    bt_to_ol_lb_ac cmp lb (node l x r) m =
    if apto cmp lb x = Less then
      bt_to_ol_lb_ub_ac cmp lb l x (x::bt_to_ol_lb_ac cmp x r m)
    else bt_to_ol_lb_ac cmp lb r m
</pre>

<DT><span class="strong">bt_to_ol_lb_ub</span>
<DD>
<pre>
⊢ (∀cmp lb ub. bt_to_ol_lb_ub cmp lb nt ub = []) ∧
  ∀cmp lb l x r ub.
    bt_to_ol_lb_ub cmp lb (node l x r) ub =
    if apto cmp lb x = Less then
      if apto cmp x ub = Less then
        bt_to_ol_lb_ub cmp lb l x ++ [x] ++ bt_to_ol_lb_ub cmp x r ub
      else bt_to_ol_lb_ub cmp lb l ub
    else bt_to_ol_lb_ub cmp lb r ub
</pre>

<DT><span class="strong">bt_to_ol_lb_ub_ac</span>
<DD>
<pre>
⊢ (∀cmp lb ub m. bt_to_ol_lb_ub_ac cmp lb nt ub m = m) ∧
  ∀cmp lb l x r ub m.
    bt_to_ol_lb_ub_ac cmp lb (node l x r) ub m =
    if apto cmp lb x = Less then
      if apto cmp x ub = Less then
        bt_to_ol_lb_ub_ac cmp lb l x (x::bt_to_ol_lb_ub_ac cmp x r ub m)
      else bt_to_ol_lb_ub_ac cmp lb l ub m
    else bt_to_ol_lb_ub_ac cmp lb r ub m
</pre>

<DT><span class="strong">bt_to_ol_ub</span>
<DD>
<pre>
⊢ (∀cmp ub. bt_to_ol_ub cmp nt ub = []) ∧
  ∀cmp l x r ub.
    bt_to_ol_ub cmp (node l x r) ub =
    if apto cmp x ub = Less then
      bt_to_ol_ub cmp l x ++ [x] ++ bt_to_ol_lb_ub cmp x r ub
    else bt_to_ol_ub cmp l ub
</pre>

<DT><span class="strong">bt_to_ol_ub_ac</span>
<DD>
<pre>
⊢ (∀cmp ub m. bt_to_ol_ub_ac cmp nt ub m = m) ∧
  ∀cmp l x r ub m.
    bt_to_ol_ub_ac cmp (node l x r) ub m =
    if apto cmp x ub = Less then
      bt_to_ol_ub_ac cmp l x (x::bt_to_ol_lb_ub_ac cmp x r ub m)
    else bt_to_ol_ub_ac cmp l ub m
</pre>

<DT><span class="strong">bt_to_set</span>
<DD>
<pre>
⊢ (∀cmp. ENUMERAL cmp nt = ∅) ∧
  ∀cmp l x r.
    ENUMERAL cmp (node l x r) =
    {y | y ∈ ENUMERAL cmp l ∧ (apto cmp y x = Less)} ∪ {x} ∪
    {z | z ∈ ENUMERAL cmp r ∧ (apto cmp x z = Less)}
</pre>

<DT><span class="strong">bt_to_set_lb</span>
<DD>
<pre>
⊢ ∀cmp lb t.
    bt_to_set_lb cmp lb t = {x | x ∈ ENUMERAL cmp t ∧ (apto cmp lb x = Less)}
</pre>

<DT><span class="strong">bt_to_set_lb_ub</span>
<DD>
<pre>
⊢ ∀cmp lb t ub.
    bt_to_set_lb_ub cmp lb t ub =
    {x | x ∈ ENUMERAL cmp t ∧ (apto cmp lb x = Less) ∧ (apto cmp x ub = Less)}
</pre>

<DT><span class="strong">bt_to_set_ub</span>
<DD>
<pre>
⊢ ∀cmp t ub.
    bt_to_set_ub cmp t ub = {x | x ∈ ENUMERAL cmp t ∧ (apto cmp x ub = Less)}
</pre>

<DT><span class="strong">incr_sbuild</span>
<DD>
<pre>
⊢ (∀cmp. incr_sbuild cmp [] = []) ∧
  ∀cmp x l. incr_sbuild cmp (x::l) = incr_smerge cmp [x] (incr_sbuild cmp l)
</pre>

<DT><span class="strong">incr_ssort</span>
<DD>
<pre>
⊢ ∀cmp l. incr_ssort cmp l = smerge_out cmp [] (incr_sbuild cmp l)
</pre>

<DT><span class="strong">list_to_bl</span>
<DD>
<pre>
⊢ (list_to_bl [] = nbl) ∧ ∀a l. list_to_bl (a::l) = BL_CONS a (list_to_bl l)
</pre>

<DT><span class="strong">list_to_bt</span>
<DD>
<pre>
⊢ ∀l. list_to_bt l = bl_to_bt (list_to_bl l)
</pre>

<DT><span class="strong">lol_set_primitive</span>
<DD>
<pre>
⊢ lol_set =
  WFREC (@R. WF R ∧ (∀lol. R lol (NONE::lol)) ∧ ∀m lol. R lol (SOME m::lol))
    (λlol_set a.
         case a of
           [] => I ∅
         | NONE::lol => I (lol_set lol)
         | SOME m::lol => I (LIST_TO_SET m ∪ lol_set lol))
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">EMPTY_OU</span>
<DD>
<pre>
⊢ ∀cmp sl. OU cmp ∅ sl = sl
</pre>

<DT><span class="strong">ENUMERAL_set</span>
<DD>
<pre>
⊢ ∀cmp l. LIST_TO_SET l = ENUMERAL cmp (list_to_bt (incr_ssort cmp l))
</pre>

<DT><span class="strong">IN_bt_to_set</span>
<DD>
<pre>
⊢ (∀cmp y. y ∈ ENUMERAL cmp nt ⇔ F) ∧
  ∀cmp l x r y.
    y ∈ ENUMERAL cmp (node l x r) ⇔
    y ∈ ENUMERAL cmp l ∧ (apto cmp y x = Less) ∨ (y = x) ∨
    y ∈ ENUMERAL cmp r ∧ (apto cmp x y = Less)
</pre>

<DT><span class="strong">IN_node</span>
<DD>
<pre>
⊢ ∀cmp x l y r.
    x ∈ ENUMERAL cmp (node l y r) ⇔
    case apto cmp x y of
      Less => x ∈ ENUMERAL cmp l
    | Equal => T
    | Greater => x ∈ ENUMERAL cmp r
</pre>

<DT><span class="strong">LESS_ALL_OU</span>
<DD>
<pre>
⊢ ∀cmp x u v.
    LESS_ALL cmp x (OU cmp u v) ⇔ LESS_ALL cmp x u ∧ LESS_ALL cmp x v
</pre>

<DT><span class="strong">LESS_ALL_OU_UO_LEM</span>
<DD>
<pre>
⊢ ∀cmp a s t.
    LESS_ALL cmp a s ∧ LESS_ALL cmp a t ⇒
    (OU cmp (UO cmp {a} s) t = a INSERT OU cmp s t)
</pre>

<DT><span class="strong">LESS_ALL_UO_LEM</span>
<DD>
<pre>
⊢ ∀cmp a s. LESS_ALL cmp a s ⇒ (UO cmp {a} s = a INSERT s)
</pre>

<DT><span class="strong">LESS_UO_LEM</span>
<DD>
<pre>
⊢ ∀cmp x y s.
    (∀z. z ∈ UO cmp {x} s ⇒ (apto cmp y z = Less)) ⇔ (apto cmp y x = Less)
</pre>

<DT><span class="strong">NOT_IN_nt</span>
<DD>
<pre>
⊢ ∀cmp y. y ∈ ENUMERAL cmp nt ⇔ F
</pre>

<DT><span class="strong">OL_DIFF_IMP</span>
<DD>
<pre>
⊢ ∀cmp l.
    OL cmp l ⇒
    ∀m. OL cmp m ⇒
        OL cmp (sdiff cmp l m) ∧
        (LIST_TO_SET (sdiff cmp l m) = LIST_TO_SET l DIFF LIST_TO_SET m)
</pre>

<DT><span class="strong">OL_ENUMERAL</span>
<DD>
<pre>
⊢ ∀cmp l. OL cmp l ⇒ (LIST_TO_SET l = ENUMERAL cmp (list_to_bt l))
</pre>

<DT><span class="strong">OL_INTER_IMP</span>
<DD>
<pre>
⊢ ∀cmp l.
    OL cmp l ⇒
    ∀m. OL cmp m ⇒
        OL cmp (sinter cmp l m) ∧
        (LIST_TO_SET (sinter cmp l m) = LIST_TO_SET l ∩ LIST_TO_SET m)
</pre>

<DT><span class="strong">OL_UNION_IMP</span>
<DD>
<pre>
⊢ ∀cmp l.
    OL cmp l ⇒
    ∀m. OL cmp m ⇒
        OL cmp (smerge cmp l m) ∧
        (LIST_TO_SET (smerge cmp l m) = LIST_TO_SET l ∪ LIST_TO_SET m)
</pre>

<DT><span class="strong">OL_bt_to_ol</span>
<DD>
<pre>
⊢ ∀cmp t. OL cmp (bt_to_ol cmp t)
</pre>

<DT><span class="strong">OL_bt_to_ol_lb</span>
<DD>
<pre>
⊢ ∀cmp t lb. OL cmp (bt_to_ol_lb cmp lb t)
</pre>

<DT><span class="strong">OL_bt_to_ol_lb_ub</span>
<DD>
<pre>
⊢ ∀cmp t lb ub. OL cmp (bt_to_ol_lb_ub cmp lb t ub)
</pre>

<DT><span class="strong">OL_bt_to_ol_ub</span>
<DD>
<pre>
⊢ ∀cmp t ub. OL cmp (bt_to_ol_ub cmp t ub)
</pre>

<DT><span class="strong">OL_sublists</span>
<DD>
<pre>
⊢ (∀cmp. OL_sublists cmp [] ⇔ T) ∧
  (∀lol cmp. OL_sublists cmp (NONE::lol) ⇔ OL_sublists cmp lol) ∧
  ∀m lol cmp. OL_sublists cmp (SOME m::lol) ⇔ OL cmp m ∧ OL_sublists cmp lol
</pre>

<DT><span class="strong">OL_sublists_ind</span>
<DD>
<pre>
⊢ ∀P. (∀cmp. P cmp []) ∧ (∀cmp lol. P cmp lol ⇒ P cmp (NONE::lol)) ∧
      (∀cmp m lol. P cmp lol ⇒ P cmp (SOME m::lol)) ⇒
      ∀v v1. P v v1
</pre>

<DT><span class="strong">OU_ASSOC</span>
<DD>
<pre>
⊢ ∀cmp a b c. OU cmp a (OU cmp b c) = OU cmp (OU cmp a b) c
</pre>

<DT><span class="strong">OU_EMPTY</span>
<DD>
<pre>
⊢ ∀cmp t. OU cmp t ∅ = t
</pre>

<DT><span class="strong">OWL_DIFF_THM</span>
<DD>
<pre>
⊢ ∀cmp s l t m. OWL cmp s l ∧ OWL cmp t m ⇒ OWL cmp (s DIFF t) (sdiff cmp l m)
</pre>

<DT><span class="strong">OWL_INTER_THM</span>
<DD>
<pre>
⊢ ∀cmp s l t m. OWL cmp s l ∧ OWL cmp t m ⇒ OWL cmp (s ∩ t) (sinter cmp l m)
</pre>

<DT><span class="strong">OWL_UNION_THM</span>
<DD>
<pre>
⊢ ∀cmp s l t m. OWL cmp s l ∧ OWL cmp t m ⇒ OWL cmp (s ∪ t) (smerge cmp l m)
</pre>

<DT><span class="strong">OWL_bt_to_ol</span>
<DD>
<pre>
⊢ ∀cmp t. OWL cmp (ENUMERAL cmp t) (bt_to_ol cmp t)
</pre>

<DT><span class="strong">better_bt_to_ol</span>
<DD>
<pre>
⊢ ∀cmp t.
    bt_to_ol cmp t =
    if OL_bt cmp t then bt_to_list_ac t [] else bt_to_ol_ac cmp t []
</pre>

<DT><span class="strong">bl_11</span>
<DD>
<pre>
⊢ (∀a a'. (zerbl a = zerbl a') ⇔ (a = a')) ∧
  ∀a0 a1 a2 a0' a1' a2'.
    (onebl a0 a1 a2 = onebl a0' a1' a2') ⇔
    (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2')
</pre>

<DT><span class="strong">bl_Axiom</span>
<DD>
<pre>
⊢ ∀f0 f1 f2. ∃fn.
    (fn nbl = f0) ∧ (∀a. fn (zerbl a) = f1 a (fn a)) ∧
    ∀a0 a1 a2. fn (onebl a0 a1 a2) = f2 a0 a1 a2 (fn a2)
</pre>

<DT><span class="strong">bl_case_cong</span>
<DD>
<pre>
⊢ ∀M M' v f f1.
    (M = M') ∧ ((M' = nbl) ⇒ (v = v')) ∧ (∀a. (M' = zerbl a) ⇒ (f a = f' a)) ∧
    (∀a0 a1 a2. (M' = onebl a0 a1 a2) ⇒ (f1 a0 a1 a2 = f1' a0 a1 a2)) ⇒
    (bl_CASE M v f f1 = bl_CASE M' v' f' f1')
</pre>

<DT><span class="strong">bl_case_eq</span>
<DD>
<pre>
⊢ (bl_CASE x v f f1 = v') ⇔
  (x = nbl) ∧ (v = v') ∨ (∃b. (x = zerbl b) ∧ (f b = v')) ∨
  ∃a b0 b. (x = onebl a b0 b) ∧ (f1 a b0 b = v')
</pre>

<DT><span class="strong">bl_distinct</span>
<DD>
<pre>
⊢ (∀a. nbl ≠ zerbl a) ∧ (∀a2 a1 a0. nbl ≠ onebl a0 a1 a2) ∧
  ∀a2 a1 a0 a. zerbl a ≠ onebl a0 a1 a2
</pre>

<DT><span class="strong">bl_induction</span>
<DD>
<pre>
⊢ ∀P. P nbl ∧ (∀b. P b ⇒ P (zerbl b)) ∧ (∀b. P b ⇒ ∀b0 a. P (onebl a b0 b)) ⇒
      ∀b. P b
</pre>

<DT><span class="strong">bl_nchotomy</span>
<DD>
<pre>
⊢ ∀bb. (bb = nbl) ∨ (∃b. bb = zerbl b) ∨ ∃a b0 b. bb = onebl a b0 b
</pre>

<DT><span class="strong">bt_11</span>
<DD>
<pre>
⊢ ∀a0 a1 a2 a0' a1' a2'.
    (node a0 a1 a2 = node a0' a1' a2') ⇔ (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2')
</pre>

<DT><span class="strong">bt_Axiom</span>
<DD>
<pre>
⊢ ∀f0 f1. ∃fn.
    (fn nt = f0) ∧ ∀a0 a1 a2. fn (node a0 a1 a2) = f1 a1 a0 a2 (fn a0) (fn a2)
</pre>

<DT><span class="strong">bt_case_cong</span>
<DD>
<pre>
⊢ ∀M M' v f.
    (M = M') ∧ ((M' = nt) ⇒ (v = v')) ∧
    (∀a0 a1 a2. (M' = node a0 a1 a2) ⇒ (f a0 a1 a2 = f' a0 a1 a2)) ⇒
    (bt_CASE M v f = bt_CASE M' v' f')
</pre>

<DT><span class="strong">bt_case_def</span>
<DD>
<pre>
⊢ (∀v f. bt_CASE nt v f = v) ∧
  ∀a0 a1 a2 v f. bt_CASE (node a0 a1 a2) v f = f a0 a1 a2
</pre>

<DT><span class="strong">bt_case_eq</span>
<DD>
<pre>
⊢ (bt_CASE x v f = v') ⇔
  (x = nt) ∧ (v = v') ∨ ∃b a b0. (x = node b a b0) ∧ (f b a b0 = v')
</pre>

<DT><span class="strong">bt_distinct</span>
<DD>
<pre>
⊢ ∀a2 a1 a0. nt ≠ node a0 a1 a2
</pre>

<DT><span class="strong">bt_induction</span>
<DD>
<pre>
⊢ ∀P. P nt ∧ (∀b b0. P b ∧ P b0 ⇒ ∀a. P (node b a b0)) ⇒ ∀b. P b
</pre>

<DT><span class="strong">bt_nchotomy</span>
<DD>
<pre>
⊢ ∀bb. (bb = nt) ∨ ∃b a b0. bb = node b a b0
</pre>

<DT><span class="strong">bt_to_list_thm</span>
<DD>
<pre>
⊢ ∀t. bt_to_list t = bt_to_list_ac t []
</pre>

<DT><span class="strong">bt_to_ol_ID_IMP</span>
<DD>
<pre>
⊢ ∀cmp l. OL cmp l ⇒ (bt_to_ol cmp (list_to_bt l) = l)
</pre>

<DT><span class="strong">datatype_bl</span>
<DD>
<pre>
⊢ DATATYPE (bl nbl zerbl onebl)
</pre>

<DT><span class="strong">datatype_bt</span>
<DD>
<pre>
⊢ DATATYPE (bt nt node)
</pre>

<DT><span class="strong">incr_smerge</span>
<DD>
<pre>
⊢ (∀l cmp. incr_smerge cmp l [] = [SOME l]) ∧
  (∀lol l cmp. incr_smerge cmp l (NONE::lol) = SOME l::lol) ∧
  ∀m lol l cmp.
    incr_smerge cmp l (SOME m::lol) =
    NONE::incr_smerge cmp (smerge cmp l m) lol
</pre>

<DT><span class="strong">incr_smerge_OL</span>
<DD>
<pre>
⊢ ∀cmp lol l.
    OL_sublists cmp lol ∧ OL cmp l ⇒ OL_sublists cmp (incr_smerge cmp l lol)
</pre>

<DT><span class="strong">incr_smerge_ind</span>
<DD>
<pre>
⊢ ∀P. (∀cmp l. P cmp l []) ∧ (∀cmp l lol. P cmp l (NONE::lol)) ∧
      (∀cmp l m lol. P cmp (smerge cmp l m) lol ⇒ P cmp l (SOME m::lol)) ⇒
      ∀v v1 v2. P v v1 v2
</pre>

<DT><span class="strong">lol_set</span>
<DD>
<pre>
⊢ (lol_set [] = ∅) ∧ (∀lol. lol_set (NONE::lol) = lol_set lol) ∧
  ∀m lol. lol_set (SOME m::lol) = LIST_TO_SET m ∪ lol_set lol
</pre>

<DT><span class="strong">lol_set_ind</span>
<DD>
<pre>
⊢ ∀P. P [] ∧ (∀lol. P lol ⇒ P (NONE::lol)) ∧ (∀m lol. P lol ⇒ P (SOME m::lol)) ⇒
      ∀v. P v
</pre>

<DT><span class="strong">ol_set</span>
<DD>
<pre>
⊢ ∀cmp t. ENUMERAL cmp t = LIST_TO_SET (bt_to_ol cmp t)
</pre>

<DT><span class="strong">sdiff</span>
<DD>
<pre>
⊢ (∀cmp. sdiff cmp [] [] = []) ∧ (∀x l cmp. sdiff cmp (x::l) [] = x::l) ∧
  (∀y m cmp. sdiff cmp [] (y::m) = []) ∧
  ∀y x m l cmp.
    sdiff cmp (x::l) (y::m) =
    case apto cmp x y of
      Less => x::sdiff cmp l (y::m)
    | Equal => sdiff cmp l m
    | Greater => sdiff cmp (x::l) m
</pre>

<DT><span class="strong">sdiff_ind</span>
<DD>
<pre>
⊢ ∀P. (∀cmp. P cmp [] []) ∧ (∀cmp x l. P cmp (x::l) []) ∧
      (∀cmp y m. P cmp [] (y::m)) ∧
      (∀cmp x l y m.
         ((apto cmp x y = Equal) ⇒ P cmp l m) ∧
         ((apto cmp x y = Greater) ⇒ P cmp (x::l) m) ∧
         ((apto cmp x y = Less) ⇒ P cmp l (y::m)) ⇒
         P cmp (x::l) (y::m)) ⇒
      ∀v v1 v2. P v v1 v2
</pre>

<DT><span class="strong">set_OWL_thm</span>
<DD>
<pre>
⊢ ∀cmp l. OWL cmp (LIST_TO_SET l) (incr_ssort cmp l)
</pre>

<DT><span class="strong">sinter</span>
<DD>
<pre>
⊢ (∀cmp. sinter cmp [] [] = []) ∧ (∀x l cmp. sinter cmp (x::l) [] = []) ∧
  (∀y m cmp. sinter cmp [] (y::m) = []) ∧
  ∀y x m l cmp.
    sinter cmp (x::l) (y::m) =
    case apto cmp x y of
      Less => sinter cmp l (y::m)
    | Equal => x::sinter cmp l m
    | Greater => sinter cmp (x::l) m
</pre>

<DT><span class="strong">sinter_ind</span>
<DD>
<pre>
⊢ ∀P. (∀cmp. P cmp [] []) ∧ (∀cmp x l. P cmp (x::l) []) ∧
      (∀cmp y m. P cmp [] (y::m)) ∧
      (∀cmp x l y m.
         ((apto cmp x y = Equal) ⇒ P cmp l m) ∧
         ((apto cmp x y = Greater) ⇒ P cmp (x::l) m) ∧
         ((apto cmp x y = Less) ⇒ P cmp l (y::m)) ⇒
         P cmp (x::l) (y::m)) ⇒
      ∀v v1 v2. P v v1 v2
</pre>

<DT><span class="strong">smerge</span>
<DD>
<pre>
⊢ (∀cmp. smerge cmp [] [] = []) ∧ (∀x l cmp. smerge cmp (x::l) [] = x::l) ∧
  (∀y m cmp. smerge cmp [] (y::m) = y::m) ∧
  ∀y x m l cmp.
    smerge cmp (x::l) (y::m) =
    case apto cmp x y of
      Less => x::smerge cmp l (y::m)
    | Equal => x::smerge cmp l m
    | Greater => y::smerge cmp (x::l) m
</pre>

<DT><span class="strong">smerge_OL</span>
<DD>
<pre>
⊢ ∀cmp l m. OL cmp l ∧ OL cmp m ⇒ OL cmp (smerge cmp l m)
</pre>

<DT><span class="strong">smerge_ind</span>
<DD>
<pre>
⊢ ∀P. (∀cmp. P cmp [] []) ∧ (∀cmp x l. P cmp (x::l) []) ∧
      (∀cmp y m. P cmp [] (y::m)) ∧
      (∀cmp x l y m.
         ((apto cmp x y = Equal) ⇒ P cmp l m) ∧
         ((apto cmp x y = Greater) ⇒ P cmp (x::l) m) ∧
         ((apto cmp x y = Less) ⇒ P cmp l (y::m)) ⇒
         P cmp (x::l) (y::m)) ⇒
      ∀v v1 v2. P v v1 v2
</pre>

<DT><span class="strong">smerge_nil</span>
<DD>
<pre>
⊢ ∀cmp l. (smerge cmp l [] = l) ∧ (smerge cmp [] l = l)
</pre>

<DT><span class="strong">smerge_out</span>
<DD>
<pre>
⊢ (∀l cmp. smerge_out cmp l [] = l) ∧
  (∀lol l cmp. smerge_out cmp l (NONE::lol) = smerge_out cmp l lol) ∧
  ∀m lol l cmp.
    smerge_out cmp l (SOME m::lol) = smerge_out cmp (smerge cmp l m) lol
</pre>

<DT><span class="strong">smerge_out_ind</span>
<DD>
<pre>
⊢ ∀P. (∀cmp l. P cmp l []) ∧ (∀cmp l lol. P cmp l lol ⇒ P cmp l (NONE::lol)) ∧
      (∀cmp l m lol. P cmp (smerge cmp l m) lol ⇒ P cmp l (SOME m::lol)) ⇒
      ∀v v1 v2. P v v1 v2
</pre>

</DL>



<hr>
</body>
</html>
