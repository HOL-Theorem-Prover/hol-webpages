<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure containerTheory</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure containerTheory</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/bag/containerScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>signature containerTheory =
<A NAME="line2"></A>sig
<A NAME="line3"></A>  type thm = Thm.thm
<A NAME="line4"></A>  
<A NAME="line5"></A>  (*  Definitions  *)
<A NAME="line6"></A>    val <A HREF="#BAG_OF_FMAP_def-val">BAG_OF_FMAP_def</A> : thm
<A NAME="line7"></A>    val <A HREF="#BAG_TO_LIST_primitive_def-val">BAG_TO_LIST_primitive_def</A> : thm
<A NAME="line8"></A>    val <A HREF="#LIST_TO_BAG_def-val">LIST_TO_BAG_def</A> : thm
<A NAME="line9"></A>  
<A NAME="line10"></A>  (*  Theorems  *)
<A NAME="line11"></A>    val <A HREF="#BAG_IN_BAG_OF_FMAP-val">BAG_IN_BAG_OF_FMAP</A> : thm
<A NAME="line12"></A>    val <A HREF="#BAG_IN_MEM-val">BAG_IN_MEM</A> : thm
<A NAME="line13"></A>    val <A HREF="#BAG_OF_FMAP_THM-val">BAG_OF_FMAP_THM</A> : thm
<A NAME="line14"></A>    val <A HREF="#BAG_TO_LIST_CARD-val">BAG_TO_LIST_CARD</A> : thm
<A NAME="line15"></A>    val <A HREF="#BAG_TO_LIST_IND-val">BAG_TO_LIST_IND</A> : thm
<A NAME="line16"></A>    val <A HREF="#BAG_TO_LIST_INV-val">BAG_TO_LIST_INV</A> : thm
<A NAME="line17"></A>    val <A HREF="#BAG_TO_LIST_THM-val">BAG_TO_LIST_THM</A> : thm
<A NAME="line18"></A>    val <A HREF="#FINITE_BAG_OF_FMAP-val">FINITE_BAG_OF_FMAP</A> : thm
<A NAME="line19"></A>    val <A HREF="#FINITE_LIST_TO_SET-val">FINITE_LIST_TO_SET</A> : thm
<A NAME="line20"></A>    val <A HREF="#IN_LIST_TO_BAG-val">IN_LIST_TO_BAG</A> : thm
<A NAME="line21"></A>    val <A HREF="#LIST_TO_BAG_APPEND-val">LIST_TO_BAG_APPEND</A> : thm
<A NAME="line22"></A>    val <A HREF="#LIST_TO_BAG_EQ_EMPTY-val">LIST_TO_BAG_EQ_EMPTY</A> : thm
<A NAME="line23"></A>    val <A HREF="#LIST_TO_SET_APPEND-val">LIST_TO_SET_APPEND</A> : thm
<A NAME="line24"></A>    val <A HREF="#LIST_TO_SET_THM-val">LIST_TO_SET_THM</A> : thm
<A NAME="line25"></A>    val <A HREF="#MEM_BAG_TO_LIST-val">MEM_BAG_TO_LIST</A> : thm
<A NAME="line26"></A>    val <A HREF="#MEM_SET_TO_LIST-val">MEM_SET_TO_LIST</A> : thm
<A NAME="line27"></A>    val <A HREF="#PERM_LIST_TO_BAG-val">PERM_LIST_TO_BAG</A> : thm
<A NAME="line28"></A>    val <A HREF="#SET_TO_LIST_CARD-val">SET_TO_LIST_CARD</A> : thm
<A NAME="line29"></A>    val <A HREF="#SET_TO_LIST_IND-val">SET_TO_LIST_IND</A> : thm
<A NAME="line30"></A>    val <A HREF="#SET_TO_LIST_INV-val">SET_TO_LIST_INV</A> : thm
<A NAME="line31"></A>    val <A HREF="#SET_TO_LIST_IN_MEM-val">SET_TO_LIST_IN_MEM</A> : thm
<A NAME="line32"></A>    val <A HREF="#SET_TO_LIST_SING-val">SET_TO_LIST_SING</A> : thm
<A NAME="line33"></A>    val <A HREF="#SET_TO_LIST_THM-val">SET_TO_LIST_THM</A> : thm
<A NAME="line34"></A>    val <A HREF="#UNION_APPEND-val">UNION_APPEND</A> : thm
<A NAME="line35"></A>  
<A NAME="line36"></A>  val container_grammars : type_grammar.grammar * term_grammar.grammar
<A NAME="line37"></A>  
<A NAME="line38"></A>  val container_rwts : simpLib.ssfrag
<A NAME="line39"></A>(*
   [bag] Parent theory of "container"
   
   [finite_map] Parent theory of "container"
   
   [sorting] Parent theory of "container"
   
   [<A NAME="BAG_OF_FMAP_def-val"><B>BAG_OF_FMAP_def</B></A>]  Definition
      
      |- !f b.
           BAG_OF_FMAP f b =
           (\x. CARD (\k. k IN FDOM b /\ (x = f k (b ' k))))
   
   [<A NAME="BAG_TO_LIST_primitive_def-val"><B>BAG_TO_LIST_primitive_def</B></A>]  Definition
      
      |- BAG_TO_LIST =
         WFREC
           (@R.
              WF R /\
              !bag. FINITE_BAG bag /\ bag &lt;&gt; {||} ==&gt; R (BAG_REST bag) bag)
           (\BAG_TO_LIST bag.
              I
                (if FINITE_BAG bag then
                   if bag = {||} then
                     []
                   else
                     BAG_CHOICE bag::BAG_TO_LIST (BAG_REST bag)
                 else
                   ARB))
   
   [<A NAME="LIST_TO_BAG_def-val"><B>LIST_TO_BAG_def</B></A>]  Definition
      
      |- (LIST_TO_BAG [] = {||}) /\
         !h t. LIST_TO_BAG (h::t) = BAG_INSERT h (LIST_TO_BAG t)
   
   [<A NAME="BAG_IN_BAG_OF_FMAP-val"><B>BAG_IN_BAG_OF_FMAP</B></A>]  Theorem
      
      |- !x f b.
           x &lt;: BAG_OF_FMAP f b &lt;=&gt; ?k. k IN FDOM b /\ (x = f k (b ' k))
   
   [<A NAME="BAG_IN_MEM-val"><B>BAG_IN_MEM</B></A>]  Theorem
      
      |- !b. FINITE_BAG b ==&gt; !x. x &lt;: b &lt;=&gt; MEM x (BAG_TO_LIST b)
   
   [<A NAME="BAG_OF_FMAP_THM-val"><B>BAG_OF_FMAP_THM</B></A>]  Theorem
      
      |- (!f. BAG_OF_FMAP f FEMPTY = {||}) /\
         !f b k v.
           BAG_OF_FMAP f (b |+ (k,v)) =
           BAG_INSERT (f k v) (BAG_OF_FMAP f (b \\ k))
   
   [<A NAME="BAG_TO_LIST_CARD-val"><B>BAG_TO_LIST_CARD</B></A>]  Theorem
      
      |- !b. FINITE_BAG b ==&gt; (LENGTH (BAG_TO_LIST b) = BAG_CARD b)
   
   [<A NAME="BAG_TO_LIST_IND-val"><B>BAG_TO_LIST_IND</B></A>]  Theorem
      
      |- !P.
           (!bag.
              (FINITE_BAG bag /\ bag &lt;&gt; {||} ==&gt; P (BAG_REST bag)) ==&gt;
              P bag) ==&gt;
           !v. P v
   
   [<A NAME="BAG_TO_LIST_INV-val"><B>BAG_TO_LIST_INV</B></A>]  Theorem
      
      |- !b. FINITE_BAG b ==&gt; (LIST_TO_BAG (BAG_TO_LIST b) = b)
   
   [<A NAME="BAG_TO_LIST_THM-val"><B>BAG_TO_LIST_THM</B></A>]  Theorem
      
      |- FINITE_BAG bag ==&gt;
         (BAG_TO_LIST bag =
          if bag = {||} then
            []
          else
            BAG_CHOICE bag::BAG_TO_LIST (BAG_REST bag))
   
   [<A NAME="FINITE_BAG_OF_FMAP-val"><B>FINITE_BAG_OF_FMAP</B></A>]  Theorem
      
      |- !f b. FINITE_BAG (BAG_OF_FMAP f b)
   
   [<A NAME="FINITE_LIST_TO_SET-val"><B>FINITE_LIST_TO_SET</B></A>]  Theorem
      
      |- !l. FINITE (set l)
   
   [<A NAME="IN_LIST_TO_BAG-val"><B>IN_LIST_TO_BAG</B></A>]  Theorem
      
      |- !h l. h &lt;: LIST_TO_BAG l &lt;=&gt; MEM h l
   
   [<A NAME="LIST_TO_BAG_APPEND-val"><B>LIST_TO_BAG_APPEND</B></A>]  Theorem
      
      |- !l1 l2. LIST_TO_BAG (l1 ++ l2) = LIST_TO_BAG l1 + LIST_TO_BAG l2
   
   [<A NAME="LIST_TO_BAG_EQ_EMPTY-val"><B>LIST_TO_BAG_EQ_EMPTY</B></A>]  Theorem
      
      |- !l. (LIST_TO_BAG l = {||}) &lt;=&gt; (l = [])
   
   [<A NAME="LIST_TO_SET_APPEND-val"><B>LIST_TO_SET_APPEND</B></A>]  Theorem
      
      |- !l1 l2. set (l1 ++ l2) = set l1 UNION set l2
   
   [<A NAME="LIST_TO_SET_THM-val"><B>LIST_TO_SET_THM</B></A>]  Theorem
      
      |- (set [] = {}) /\ (set (h::t) = h INSERT set t)
   
   [<A NAME="MEM_BAG_TO_LIST-val"><B>MEM_BAG_TO_LIST</B></A>]  Theorem
      
      |- !b. FINITE_BAG b ==&gt; !x. MEM x (BAG_TO_LIST b) &lt;=&gt; x &lt;: b
   
   [<A NAME="MEM_SET_TO_LIST-val"><B>MEM_SET_TO_LIST</B></A>]  Theorem
      
      |- !s. FINITE s ==&gt; !x. MEM x (SET_TO_LIST s) &lt;=&gt; x IN s
   
   [<A NAME="PERM_LIST_TO_BAG-val"><B>PERM_LIST_TO_BAG</B></A>]  Theorem
      
      |- !l1 l2. (LIST_TO_BAG l1 = LIST_TO_BAG l2) &lt;=&gt; PERM l1 l2
   
   [<A NAME="SET_TO_LIST_CARD-val"><B>SET_TO_LIST_CARD</B></A>]  Theorem
      
      |- !s. FINITE s ==&gt; (LENGTH (SET_TO_LIST s) = CARD s)
   
   [<A NAME="SET_TO_LIST_IND-val"><B>SET_TO_LIST_IND</B></A>]  Theorem
      
      |- !P. (!s. (FINITE s /\ s &lt;&gt; {} ==&gt; P (REST s)) ==&gt; P s) ==&gt; !v. P v
   
   [<A NAME="SET_TO_LIST_INV-val"><B>SET_TO_LIST_INV</B></A>]  Theorem
      
      |- !s. FINITE s ==&gt; (set (SET_TO_LIST s) = s)
   
   [<A NAME="SET_TO_LIST_IN_MEM-val"><B>SET_TO_LIST_IN_MEM</B></A>]  Theorem
      
      |- !s. FINITE s ==&gt; !x. x IN s &lt;=&gt; MEM x (SET_TO_LIST s)
   
   [<A NAME="SET_TO_LIST_SING-val"><B>SET_TO_LIST_SING</B></A>]  Theorem
      
      |- SET_TO_LIST {x} = [x]
   
   [<A NAME="SET_TO_LIST_THM-val"><B>SET_TO_LIST_THM</B></A>]  Theorem
      
      |- FINITE s ==&gt;
         (SET_TO_LIST s =
          if s = {} then [] else CHOICE s::SET_TO_LIST (REST s))
   
   [<A NAME="UNION_APPEND-val"><B>UNION_APPEND</B></A>]  Theorem
      
      |- !l1 l2. set l1 UNION set l2 = set (l1 ++ l2)
   
   
*)
end

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/bag/containerScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
