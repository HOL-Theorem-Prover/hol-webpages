<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure boolSimps</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure boolSimps</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/simp/src/boolSimps.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>signature boolSimps =
<A NAME="line2"></A>sig
<A NAME="line3"></A>     val <A HREF="../../Docfiles/HTML/boolSimps.bool_ss.html">bool_ss</A> : simpLib.simpset
<A NAME="line4"></A>     val BOOL_ss : simpLib.ssfrag       (* boolean rewrites and
<A NAME="line5"></A>                                           beta conversion *)
<A NAME="line6"></A>     val CONG_ss : simpLib.ssfrag       (* congruence rules for ==&gt; and
<A NAME="line7"></A>                                           if-then-else *)
<A NAME="line8"></A>     val CONJ_ss : simpLib.ssfrag       (* congruence rules for /\; not
<A NAME="line9"></A>                                           included in bool_ss, but
<A NAME="line10"></A>                                           occasionally useful *)
<A NAME="line11"></A>     val NOT_ss : simpLib.ssfrag        (* rewrites that move negations
<A NAME="line12"></A>                                           inwards, included in bool_ss *)
<A NAME="line13"></A>     val COND_elim_ss : simpLib.ssfrag  (* eliminates if-then-else's;
<A NAME="line14"></A>                                           not in bool_ss *)
<A NAME="line15"></A>     val LIFT_COND_ss : simpLib.ssfrag  (* lifts conds high in a term, but
<A NAME="line16"></A>                                           doesn't eliminate them; can merge
<A NAME="line17"></A>                                           those of the same guard or
<A NAME="line18"></A>                                           opposing guards *)
<A NAME="line19"></A>     val UNWIND_ss : simpLib.ssfrag     (* "pointwise" elimination for
<A NAME="line20"></A>                                            ? and !, included in bool_ss *)
<A NAME="line21"></A>     val ETA_ss : simpLib.ssfrag        (* eta conversion;
<A NAME="line22"></A>                                           not included in bool_ss *)
<A NAME="line23"></A>
<A NAME="line24"></A>     val LET_ss : simpLib.ssfrag        (* writes out let terms, using a
<A NAME="line25"></A>                                           congruence to evaluate the
<A NAME="line26"></A>                                           second argument first *)
<A NAME="line27"></A>
<A NAME="line28"></A>     val literal_case_ss : simpLib.ssfrag (* writes out literal case terms,
<A NAME="line29"></A>                                           using a congruence to evaluate
<A NAME="line30"></A>                                           the second argument first *)
<A NAME="line31"></A>
<A NAME="line32"></A>     val DNF_ss : simpLib.ssfrag
<A NAME="line33"></A>        (* converts a term to DNF at the level of propositional logic, and
<A NAME="line34"></A>           also moves quantifiers around to give them maximum useful scope
<A NAME="line35"></A>           over their bodies:
<A NAME="line36"></A>               (?x. P x) /\ Q   --&gt;  ?x. P x /\ Q
<A NAME="line37"></A>               P /\ (?x. Q x)   --&gt;  ?x. P /\ Q x
<A NAME="line38"></A>               (?x. P x) ==&gt; Q  --&gt;  !x. P x ==&gt; Q
<A NAME="line39"></A>               P ==&gt; !x. Q x    --&gt;  !x. P ==&gt; Q x
<A NAME="line40"></A>               !x. P x /\ Q x   --&gt;  (!x. P x) /\ (!x. Q x)
<A NAME="line41"></A>               ?x. P x \/ Q x   --&gt;  (?x. P x) \/ (?x. Q x)
<A NAME="line42"></A>           Think of this simpset fragment as attempting to achieve as
<A NAME="line43"></A>           much as possible of STRIP_TAC within a single goal.
<A NAME="line44"></A>
<A NAME="line45"></A>           Note that it leaves ==&gt; alone, but includes the following
<A NAME="line46"></A>           extra rewrites:
<A NAME="line47"></A>               P \/ Q ==&gt; R     --&gt;  (P ==&gt; R) /\ (Q ==&gt; R)
<A NAME="line48"></A>               P ==&gt; Q /\ R     --&gt;  (P ==&gt; Q) /\ (P ==&gt; R)
<A NAME="line49"></A>
<A NAME="line50"></A>           This simpset fragment will give UNWIND_ss maximum opportunity to
<A NAME="line51"></A>           eliminate equalities. *)
<A NAME="line52"></A>
<A NAME="line53"></A>     val EQUIV_EXTRACT_ss : simpLib.ssfrag 
<A NAME="line54"></A>        (* Extracts common terms from both sides of an equivalence. Example:
<A NAME="line55"></A>
<A NAME="line56"></A>           ``A /\ B /\ C &lt;=&gt; C /\ B /\ D`` is transformed to
<A NAME="line57"></A>
<A NAME="line58"></A>           |- (A /\ B /\ C &lt;=&gt; C /\ B /\ D) &lt;=&gt; C /\ B ==&gt; (A &lt;=&gt; D)				
<A NAME="line59"></A>         *)
<A NAME="line60"></A>
<A NAME="line61"></A>
<A NAME="line62"></A>end
<A NAME="line63"></A>
<A NAME="line64"></A>
</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/simp/src/boolSimps.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
