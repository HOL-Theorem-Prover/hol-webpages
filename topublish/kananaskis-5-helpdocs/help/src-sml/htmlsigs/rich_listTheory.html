<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure rich_listTheory</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure rich_listTheory</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/list/src/rich_listScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>signature rich_listTheory =
<A NAME="line2"></A>sig
<A NAME="line3"></A>  type thm = Thm.thm
<A NAME="line4"></A>  
<A NAME="line5"></A>  (*  Definitions  *)
<A NAME="line6"></A>    val <A HREF="#AND_EL_DEF-val">AND_EL_DEF</A> : thm
<A NAME="line7"></A>    val <A HREF="#BUTLASTN-val">BUTLASTN</A> : thm
<A NAME="line8"></A>    val <A HREF="#ELL-val">ELL</A> : thm
<A NAME="line9"></A>    val <A HREF="#GENLIST-val">GENLIST</A> : thm
<A NAME="line10"></A>    val <A HREF="#IS_SUBLIST-val">IS_SUBLIST</A> : thm
<A NAME="line11"></A>    val <A HREF="#IS_SUFFIX-val">IS_SUFFIX</A> : thm
<A NAME="line12"></A>    val <A HREF="#LASTN-val">LASTN</A> : thm
<A NAME="line13"></A>    val <A HREF="#LIST_ELEM_COUNT_DEF-val">LIST_ELEM_COUNT_DEF</A> : thm
<A NAME="line14"></A>    val <A HREF="#OR_EL_DEF-val">OR_EL_DEF</A> : thm
<A NAME="line15"></A>    val <A HREF="#PREFIX_DEF-val">PREFIX_DEF</A> : thm
<A NAME="line16"></A>    val <A HREF="#REPLACE_ELEMENT_DEF-val">REPLACE_ELEMENT_DEF</A> : thm
<A NAME="line17"></A>    val <A HREF="#REPLICATE-val">REPLICATE</A> : thm
<A NAME="line18"></A>    val <A HREF="#SCANL-val">SCANL</A> : thm
<A NAME="line19"></A>    val <A HREF="#SCANR-val">SCANR</A> : thm
<A NAME="line20"></A>    val <A HREF="#SEG-val">SEG</A> : thm
<A NAME="line21"></A>    val <A HREF="#SNOC-val">SNOC</A> : thm
<A NAME="line22"></A>    val <A HREF="#SPLITP-val">SPLITP</A> : thm
<A NAME="line23"></A>    val <A HREF="#SUFFIX_DEF-val">SUFFIX_DEF</A> : thm
<A NAME="line24"></A>    val <A HREF="#UNZIP_FST_DEF-val">UNZIP_FST_DEF</A> : thm
<A NAME="line25"></A>    val <A HREF="#UNZIP_SND_DEF-val">UNZIP_SND_DEF</A> : thm
<A NAME="line26"></A>  
<A NAME="line27"></A>  (*  Theorems  *)
<A NAME="line28"></A>    val <A HREF="#ALL_DISTINCT_SNOC-val">ALL_DISTINCT_SNOC</A> : thm
<A NAME="line29"></A>    val <A HREF="#ALL_EL-val">ALL_EL</A> : thm
<A NAME="line30"></A>    val <A HREF="#ALL_EL_APPEND-val">ALL_EL_APPEND</A> : thm
<A NAME="line31"></A>    val <A HREF="#ALL_EL_BUTFIRSTN-val">ALL_EL_BUTFIRSTN</A> : thm
<A NAME="line32"></A>    val <A HREF="#ALL_EL_BUTLASTN-val">ALL_EL_BUTLASTN</A> : thm
<A NAME="line33"></A>    val <A HREF="#ALL_EL_CONJ-val">ALL_EL_CONJ</A> : thm
<A NAME="line34"></A>    val <A HREF="#ALL_EL_FIRSTN-val">ALL_EL_FIRSTN</A> : thm
<A NAME="line35"></A>    val <A HREF="#ALL_EL_FOLDL-val">ALL_EL_FOLDL</A> : thm
<A NAME="line36"></A>    val <A HREF="#ALL_EL_FOLDL_MAP-val">ALL_EL_FOLDL_MAP</A> : thm
<A NAME="line37"></A>    val <A HREF="#ALL_EL_FOLDR-val">ALL_EL_FOLDR</A> : thm
<A NAME="line38"></A>    val <A HREF="#ALL_EL_FOLDR_MAP-val">ALL_EL_FOLDR_MAP</A> : thm
<A NAME="line39"></A>    val <A HREF="#ALL_EL_LASTN-val">ALL_EL_LASTN</A> : thm
<A NAME="line40"></A>    val <A HREF="#ALL_EL_MAP-val">ALL_EL_MAP</A> : thm
<A NAME="line41"></A>    val <A HREF="#ALL_EL_REPLICATE-val">ALL_EL_REPLICATE</A> : thm
<A NAME="line42"></A>    val <A HREF="#ALL_EL_REVERSE-val">ALL_EL_REVERSE</A> : thm
<A NAME="line43"></A>    val <A HREF="#ALL_EL_SEG-val">ALL_EL_SEG</A> : thm
<A NAME="line44"></A>    val <A HREF="#ALL_EL_SNOC-val">ALL_EL_SNOC</A> : thm
<A NAME="line45"></A>    val <A HREF="#AND_EL_FOLDL-val">AND_EL_FOLDL</A> : thm
<A NAME="line46"></A>    val <A HREF="#AND_EL_FOLDR-val">AND_EL_FOLDR</A> : thm
<A NAME="line47"></A>    val <A HREF="#APPEND-val">APPEND</A> : thm
<A NAME="line48"></A>    val <A HREF="#APPEND_ASSOC-val">APPEND_ASSOC</A> : thm
<A NAME="line49"></A>    val <A HREF="#APPEND_ASSOC_CONS-val">APPEND_ASSOC_CONS</A> : thm
<A NAME="line50"></A>    val <A HREF="#APPEND_BUTLASTN_BUTFIRSTN-val">APPEND_BUTLASTN_BUTFIRSTN</A> : thm
<A NAME="line51"></A>    val <A HREF="#APPEND_BUTLASTN_LASTN-val">APPEND_BUTLASTN_LASTN</A> : thm
<A NAME="line52"></A>    val <A HREF="#APPEND_BUTLAST_LAST-val">APPEND_BUTLAST_LAST</A> : thm
<A NAME="line53"></A>    val <A HREF="#APPEND_FIRSTN_BUTFIRSTN-val">APPEND_FIRSTN_BUTFIRSTN</A> : thm
<A NAME="line54"></A>    val <A HREF="#APPEND_FIRSTN_LASTN-val">APPEND_FIRSTN_LASTN</A> : thm
<A NAME="line55"></A>    val <A HREF="#APPEND_FOLDL-val">APPEND_FOLDL</A> : thm
<A NAME="line56"></A>    val <A HREF="#APPEND_FOLDR-val">APPEND_FOLDR</A> : thm
<A NAME="line57"></A>    val <A HREF="#APPEND_LENGTH_EQ-val">APPEND_LENGTH_EQ</A> : thm
<A NAME="line58"></A>    val <A HREF="#APPEND_NIL-val">APPEND_NIL</A> : thm
<A NAME="line59"></A>    val <A HREF="#APPEND_SNOC-val">APPEND_SNOC</A> : thm
<A NAME="line60"></A>    val <A HREF="#APPEND_SNOC1-val">APPEND_SNOC1</A> : thm
<A NAME="line61"></A>    val <A HREF="#ASSOC_APPEND-val">ASSOC_APPEND</A> : thm
<A NAME="line62"></A>    val <A HREF="#ASSOC_FOLDL_FLAT-val">ASSOC_FOLDL_FLAT</A> : thm
<A NAME="line63"></A>    val <A HREF="#ASSOC_FOLDR_FLAT-val">ASSOC_FOLDR_FLAT</A> : thm
<A NAME="line64"></A>    val <A HREF="#BUTFIRSTN-val">BUTFIRSTN</A> : thm
<A NAME="line65"></A>    val <A HREF="#BUTFIRSTN_APPEND1-val">BUTFIRSTN_APPEND1</A> : thm
<A NAME="line66"></A>    val <A HREF="#BUTFIRSTN_APPEND2-val">BUTFIRSTN_APPEND2</A> : thm
<A NAME="line67"></A>    val <A HREF="#BUTFIRSTN_BUTFIRSTN-val">BUTFIRSTN_BUTFIRSTN</A> : thm
<A NAME="line68"></A>    val <A HREF="#BUTFIRSTN_CONS_EL-val">BUTFIRSTN_CONS_EL</A> : thm
<A NAME="line69"></A>    val <A HREF="#BUTFIRSTN_LASTN-val">BUTFIRSTN_LASTN</A> : thm
<A NAME="line70"></A>    val <A HREF="#BUTFIRSTN_LENGTH_APPEND-val">BUTFIRSTN_LENGTH_APPEND</A> : thm
<A NAME="line71"></A>    val <A HREF="#BUTFIRSTN_LENGTH_NIL-val">BUTFIRSTN_LENGTH_NIL</A> : thm
<A NAME="line72"></A>    val <A HREF="#BUTFIRSTN_REVERSE-val">BUTFIRSTN_REVERSE</A> : thm
<A NAME="line73"></A>    val <A HREF="#BUTFIRSTN_SEG-val">BUTFIRSTN_SEG</A> : thm
<A NAME="line74"></A>    val <A HREF="#BUTFIRSTN_SNOC-val">BUTFIRSTN_SNOC</A> : thm
<A NAME="line75"></A>    val <A HREF="#BUTFIRSTN_compute-val">BUTFIRSTN_compute</A> : thm
<A NAME="line76"></A>    val <A HREF="#BUTLAST-val">BUTLAST</A> : thm
<A NAME="line77"></A>    val <A HREF="#BUTLASTN_1-val">BUTLASTN_1</A> : thm
<A NAME="line78"></A>    val <A HREF="#BUTLASTN_APPEND1-val">BUTLASTN_APPEND1</A> : thm
<A NAME="line79"></A>    val <A HREF="#BUTLASTN_APPEND2-val">BUTLASTN_APPEND2</A> : thm
<A NAME="line80"></A>    val <A HREF="#BUTLASTN_BUTLAST-val">BUTLASTN_BUTLAST</A> : thm
<A NAME="line81"></A>    val <A HREF="#BUTLASTN_BUTLASTN-val">BUTLASTN_BUTLASTN</A> : thm
<A NAME="line82"></A>    val <A HREF="#BUTLASTN_CONS-val">BUTLASTN_CONS</A> : thm
<A NAME="line83"></A>    val <A HREF="#BUTLASTN_FIRSTN-val">BUTLASTN_FIRSTN</A> : thm
<A NAME="line84"></A>    val <A HREF="#BUTLASTN_LASTN-val">BUTLASTN_LASTN</A> : thm
<A NAME="line85"></A>    val <A HREF="#BUTLASTN_LASTN_NIL-val">BUTLASTN_LASTN_NIL</A> : thm
<A NAME="line86"></A>    val <A HREF="#BUTLASTN_LENGTH_APPEND-val">BUTLASTN_LENGTH_APPEND</A> : thm
<A NAME="line87"></A>    val <A HREF="#BUTLASTN_LENGTH_CONS-val">BUTLASTN_LENGTH_CONS</A> : thm
<A NAME="line88"></A>    val <A HREF="#BUTLASTN_LENGTH_NIL-val">BUTLASTN_LENGTH_NIL</A> : thm
<A NAME="line89"></A>    val <A HREF="#BUTLASTN_MAP-val">BUTLASTN_MAP</A> : thm
<A NAME="line90"></A>    val <A HREF="#BUTLASTN_REVERSE-val">BUTLASTN_REVERSE</A> : thm
<A NAME="line91"></A>    val <A HREF="#BUTLASTN_SEG-val">BUTLASTN_SEG</A> : thm
<A NAME="line92"></A>    val <A HREF="#BUTLASTN_SUC_BUTLAST-val">BUTLASTN_SUC_BUTLAST</A> : thm
<A NAME="line93"></A>    val <A HREF="#BUTLASTN_compute-val">BUTLASTN_compute</A> : thm
<A NAME="line94"></A>    val <A HREF="#BUTLAST_CONS-val">BUTLAST_CONS</A> : thm
<A NAME="line95"></A>    val <A HREF="#COMM_ASSOC_FOLDL_REVERSE-val">COMM_ASSOC_FOLDL_REVERSE</A> : thm
<A NAME="line96"></A>    val <A HREF="#COMM_ASSOC_FOLDR_REVERSE-val">COMM_ASSOC_FOLDR_REVERSE</A> : thm
<A NAME="line97"></A>    val <A HREF="#COMM_MONOID_FOLDL-val">COMM_MONOID_FOLDL</A> : thm
<A NAME="line98"></A>    val <A HREF="#COMM_MONOID_FOLDR-val">COMM_MONOID_FOLDR</A> : thm
<A NAME="line99"></A>    val <A HREF="#CONS-val">CONS</A> : thm
<A NAME="line100"></A>    val <A HREF="#CONS_11-val">CONS_11</A> : thm
<A NAME="line101"></A>    val <A HREF="#CONS_APPEND-val">CONS_APPEND</A> : thm
<A NAME="line102"></A>    val <A HREF="#EL-val">EL</A> : thm
<A NAME="line103"></A>    val <A HREF="#ELL_0_SNOC-val">ELL_0_SNOC</A> : thm
<A NAME="line104"></A>    val <A HREF="#ELL_APPEND1-val">ELL_APPEND1</A> : thm
<A NAME="line105"></A>    val <A HREF="#ELL_APPEND2-val">ELL_APPEND2</A> : thm
<A NAME="line106"></A>    val <A HREF="#ELL_CONS-val">ELL_CONS</A> : thm
<A NAME="line107"></A>    val <A HREF="#ELL_EL-val">ELL_EL</A> : thm
<A NAME="line108"></A>    val <A HREF="#ELL_IS_EL-val">ELL_IS_EL</A> : thm
<A NAME="line109"></A>    val <A HREF="#ELL_LAST-val">ELL_LAST</A> : thm
<A NAME="line110"></A>    val <A HREF="#ELL_LENGTH_APPEND-val">ELL_LENGTH_APPEND</A> : thm
<A NAME="line111"></A>    val <A HREF="#ELL_LENGTH_CONS-val">ELL_LENGTH_CONS</A> : thm
<A NAME="line112"></A>    val <A HREF="#ELL_LENGTH_SNOC-val">ELL_LENGTH_SNOC</A> : thm
<A NAME="line113"></A>    val <A HREF="#ELL_MAP-val">ELL_MAP</A> : thm
<A NAME="line114"></A>    val <A HREF="#ELL_PRE_LENGTH-val">ELL_PRE_LENGTH</A> : thm
<A NAME="line115"></A>    val <A HREF="#ELL_REVERSE-val">ELL_REVERSE</A> : thm
<A NAME="line116"></A>    val <A HREF="#ELL_REVERSE_EL-val">ELL_REVERSE_EL</A> : thm
<A NAME="line117"></A>    val <A HREF="#ELL_SEG-val">ELL_SEG</A> : thm
<A NAME="line118"></A>    val <A HREF="#ELL_SNOC-val">ELL_SNOC</A> : thm
<A NAME="line119"></A>    val <A HREF="#ELL_SUC_SNOC-val">ELL_SUC_SNOC</A> : thm
<A NAME="line120"></A>    val <A HREF="#ELL_compute-val">ELL_compute</A> : thm
<A NAME="line121"></A>    val <A HREF="#EL_APPEND1-val">EL_APPEND1</A> : thm
<A NAME="line122"></A>    val <A HREF="#EL_APPEND2-val">EL_APPEND2</A> : thm
<A NAME="line123"></A>    val <A HREF="#EL_BUTFIRSTN-val">EL_BUTFIRSTN</A> : thm
<A NAME="line124"></A>    val <A HREF="#EL_CONS-val">EL_CONS</A> : thm
<A NAME="line125"></A>    val <A HREF="#EL_ELL-val">EL_ELL</A> : thm
<A NAME="line126"></A>    val <A HREF="#EL_FIRSTN-val">EL_FIRSTN</A> : thm
<A NAME="line127"></A>    val <A HREF="#EL_FRONT-val">EL_FRONT</A> : thm
<A NAME="line128"></A>    val <A HREF="#EL_GENLIST-val">EL_GENLIST</A> : thm
<A NAME="line129"></A>    val <A HREF="#EL_IS_EL-val">EL_IS_EL</A> : thm
<A NAME="line130"></A>    val <A HREF="#EL_LENGTH_APPEND-val">EL_LENGTH_APPEND</A> : thm
<A NAME="line131"></A>    val <A HREF="#EL_LENGTH_SNOC-val">EL_LENGTH_SNOC</A> : thm
<A NAME="line132"></A>    val <A HREF="#EL_MAP-val">EL_MAP</A> : thm
<A NAME="line133"></A>    val <A HREF="#EL_PRE_LENGTH-val">EL_PRE_LENGTH</A> : thm
<A NAME="line134"></A>    val <A HREF="#EL_REVERSE-val">EL_REVERSE</A> : thm
<A NAME="line135"></A>    val <A HREF="#EL_REVERSE_ELL-val">EL_REVERSE_ELL</A> : thm
<A NAME="line136"></A>    val <A HREF="#EL_SEG-val">EL_SEG</A> : thm
<A NAME="line137"></A>    val <A HREF="#EL_SNOC-val">EL_SNOC</A> : thm
<A NAME="line138"></A>    val <A HREF="#EQ_LIST-val">EQ_LIST</A> : thm
<A NAME="line139"></A>    val <A HREF="#EVERY_GENLIST-val">EVERY_GENLIST</A> : thm
<A NAME="line140"></A>    val <A HREF="#FCOMM_FOLDL_APPEND-val">FCOMM_FOLDL_APPEND</A> : thm
<A NAME="line141"></A>    val <A HREF="#FCOMM_FOLDL_FLAT-val">FCOMM_FOLDL_FLAT</A> : thm
<A NAME="line142"></A>    val <A HREF="#FCOMM_FOLDR_APPEND-val">FCOMM_FOLDR_APPEND</A> : thm
<A NAME="line143"></A>    val <A HREF="#FCOMM_FOLDR_FLAT-val">FCOMM_FOLDR_FLAT</A> : thm
<A NAME="line144"></A>    val <A HREF="#FILTER-val">FILTER</A> : thm
<A NAME="line145"></A>    val <A HREF="#FILTER_APPEND-val">FILTER_APPEND</A> : thm
<A NAME="line146"></A>    val <A HREF="#FILTER_COMM-val">FILTER_COMM</A> : thm
<A NAME="line147"></A>    val <A HREF="#FILTER_FILTER-val">FILTER_FILTER</A> : thm
<A NAME="line148"></A>    val <A HREF="#FILTER_FLAT-val">FILTER_FLAT</A> : thm
<A NAME="line149"></A>    val <A HREF="#FILTER_FOLDL-val">FILTER_FOLDL</A> : thm
<A NAME="line150"></A>    val <A HREF="#FILTER_FOLDR-val">FILTER_FOLDR</A> : thm
<A NAME="line151"></A>    val <A HREF="#FILTER_IDEM-val">FILTER_IDEM</A> : thm
<A NAME="line152"></A>    val <A HREF="#FILTER_MAP-val">FILTER_MAP</A> : thm
<A NAME="line153"></A>    val <A HREF="#FILTER_REVERSE-val">FILTER_REVERSE</A> : thm
<A NAME="line154"></A>    val <A HREF="#FILTER_SNOC-val">FILTER_SNOC</A> : thm
<A NAME="line155"></A>    val <A HREF="#FIRSTN-val">FIRSTN</A> : thm
<A NAME="line156"></A>    val <A HREF="#FIRSTN_APPEND1-val">FIRSTN_APPEND1</A> : thm
<A NAME="line157"></A>    val <A HREF="#FIRSTN_APPEND2-val">FIRSTN_APPEND2</A> : thm
<A NAME="line158"></A>    val <A HREF="#FIRSTN_BUTLASTN-val">FIRSTN_BUTLASTN</A> : thm
<A NAME="line159"></A>    val <A HREF="#FIRSTN_FIRSTN-val">FIRSTN_FIRSTN</A> : thm
<A NAME="line160"></A>    val <A HREF="#FIRSTN_LENGTH_APPEND-val">FIRSTN_LENGTH_APPEND</A> : thm
<A NAME="line161"></A>    val <A HREF="#FIRSTN_LENGTH_ID-val">FIRSTN_LENGTH_ID</A> : thm
<A NAME="line162"></A>    val <A HREF="#FIRSTN_REVERSE-val">FIRSTN_REVERSE</A> : thm
<A NAME="line163"></A>    val <A HREF="#FIRSTN_SEG-val">FIRSTN_SEG</A> : thm
<A NAME="line164"></A>    val <A HREF="#FIRSTN_SNOC-val">FIRSTN_SNOC</A> : thm
<A NAME="line165"></A>    val <A HREF="#FIRSTN_compute-val">FIRSTN_compute</A> : thm
<A NAME="line166"></A>    val <A HREF="#FLAT-val">FLAT</A> : thm
<A NAME="line167"></A>    val <A HREF="#FLAT_APPEND-val">FLAT_APPEND</A> : thm
<A NAME="line168"></A>    val <A HREF="#FLAT_FLAT-val">FLAT_FLAT</A> : thm
<A NAME="line169"></A>    val <A HREF="#FLAT_FOLDL-val">FLAT_FOLDL</A> : thm
<A NAME="line170"></A>    val <A HREF="#FLAT_FOLDR-val">FLAT_FOLDR</A> : thm
<A NAME="line171"></A>    val <A HREF="#FLAT_REVERSE-val">FLAT_REVERSE</A> : thm
<A NAME="line172"></A>    val <A HREF="#FLAT_SNOC-val">FLAT_SNOC</A> : thm
<A NAME="line173"></A>    val <A HREF="#FOLDL-val">FOLDL</A> : thm
<A NAME="line174"></A>    val <A HREF="#FOLDL_APPEND-val">FOLDL_APPEND</A> : thm
<A NAME="line175"></A>    val <A HREF="#FOLDL_FILTER-val">FOLDL_FILTER</A> : thm
<A NAME="line176"></A>    val <A HREF="#FOLDL_FOLDR_REVERSE-val">FOLDL_FOLDR_REVERSE</A> : thm
<A NAME="line177"></A>    val <A HREF="#FOLDL_MAP-val">FOLDL_MAP</A> : thm
<A NAME="line178"></A>    val <A HREF="#FOLDL_MAP2-val">FOLDL_MAP2</A> : thm
<A NAME="line179"></A>    val <A HREF="#FOLDL_REVERSE-val">FOLDL_REVERSE</A> : thm
<A NAME="line180"></A>    val <A HREF="#FOLDL_SINGLE-val">FOLDL_SINGLE</A> : thm
<A NAME="line181"></A>    val <A HREF="#FOLDL_SNOC-val">FOLDL_SNOC</A> : thm
<A NAME="line182"></A>    val <A HREF="#FOLDL_SNOC_NIL-val">FOLDL_SNOC_NIL</A> : thm
<A NAME="line183"></A>    val <A HREF="#FOLDR-val">FOLDR</A> : thm
<A NAME="line184"></A>    val <A HREF="#FOLDR_APPEND-val">FOLDR_APPEND</A> : thm
<A NAME="line185"></A>    val <A HREF="#FOLDR_CONS_NIL-val">FOLDR_CONS_NIL</A> : thm
<A NAME="line186"></A>    val <A HREF="#FOLDR_FILTER-val">FOLDR_FILTER</A> : thm
<A NAME="line187"></A>    val <A HREF="#FOLDR_FILTER_REVERSE-val">FOLDR_FILTER_REVERSE</A> : thm
<A NAME="line188"></A>    val <A HREF="#FOLDR_FOLDL-val">FOLDR_FOLDL</A> : thm
<A NAME="line189"></A>    val <A HREF="#FOLDR_FOLDL_REVERSE-val">FOLDR_FOLDL_REVERSE</A> : thm
<A NAME="line190"></A>    val <A HREF="#FOLDR_MAP-val">FOLDR_MAP</A> : thm
<A NAME="line191"></A>    val <A HREF="#FOLDR_MAP_REVERSE-val">FOLDR_MAP_REVERSE</A> : thm
<A NAME="line192"></A>    val <A HREF="#FOLDR_REVERSE-val">FOLDR_REVERSE</A> : thm
<A NAME="line193"></A>    val <A HREF="#FOLDR_SINGLE-val">FOLDR_SINGLE</A> : thm
<A NAME="line194"></A>    val <A HREF="#FOLDR_SNOC-val">FOLDR_SNOC</A> : thm
<A NAME="line195"></A>    val <A HREF="#FRONT_APPEND-val">FRONT_APPEND</A> : thm
<A NAME="line196"></A>    val <A HREF="#FRONT___LENGTH-val">FRONT___LENGTH</A> : thm
<A NAME="line197"></A>    val <A HREF="#GENLIST_APPEND-val">GENLIST_APPEND</A> : thm
<A NAME="line198"></A>    val <A HREF="#GENLIST_FUN_EQ-val">GENLIST_FUN_EQ</A> : thm
<A NAME="line199"></A>    val <A HREF="#GENLIST_compute-val">GENLIST_compute</A> : thm
<A NAME="line200"></A>    val <A HREF="#HD-val">HD</A> : thm
<A NAME="line201"></A>    val <A HREF="#HD_GENLIST-val">HD_GENLIST</A> : thm
<A NAME="line202"></A>    val <A HREF="#IS_EL-val">IS_EL</A> : thm
<A NAME="line203"></A>    val <A HREF="#IS_EL_APPEND-val">IS_EL_APPEND</A> : thm
<A NAME="line204"></A>    val <A HREF="#IS_EL_BUTFIRSTN-val">IS_EL_BUTFIRSTN</A> : thm
<A NAME="line205"></A>    val <A HREF="#IS_EL_BUTLASTN-val">IS_EL_BUTLASTN</A> : thm
<A NAME="line206"></A>    val <A HREF="#IS_EL_DEF-val">IS_EL_DEF</A> : thm
<A NAME="line207"></A>    val <A HREF="#IS_EL_FILTER-val">IS_EL_FILTER</A> : thm
<A NAME="line208"></A>    val <A HREF="#IS_EL_FIRSTN-val">IS_EL_FIRSTN</A> : thm
<A NAME="line209"></A>    val <A HREF="#IS_EL_FOLDL-val">IS_EL_FOLDL</A> : thm
<A NAME="line210"></A>    val <A HREF="#IS_EL_FOLDL_MAP-val">IS_EL_FOLDL_MAP</A> : thm
<A NAME="line211"></A>    val <A HREF="#IS_EL_FOLDR-val">IS_EL_FOLDR</A> : thm
<A NAME="line212"></A>    val <A HREF="#IS_EL_FOLDR_MAP-val">IS_EL_FOLDR_MAP</A> : thm
<A NAME="line213"></A>    val <A HREF="#IS_EL_LASTN-val">IS_EL_LASTN</A> : thm
<A NAME="line214"></A>    val <A HREF="#IS_EL_REPLICATE-val">IS_EL_REPLICATE</A> : thm
<A NAME="line215"></A>    val <A HREF="#IS_EL_REVERSE-val">IS_EL_REVERSE</A> : thm
<A NAME="line216"></A>    val <A HREF="#IS_EL_SEG-val">IS_EL_SEG</A> : thm
<A NAME="line217"></A>    val <A HREF="#IS_EL_SNOC-val">IS_EL_SNOC</A> : thm
<A NAME="line218"></A>    val <A HREF="#IS_EL_SOME_EL-val">IS_EL_SOME_EL</A> : thm
<A NAME="line219"></A>    val <A HREF="#IS_PREFIX-val">IS_PREFIX</A> : thm
<A NAME="line220"></A>    val <A HREF="#IS_PREFIX_ANTISYM-val">IS_PREFIX_ANTISYM</A> : thm
<A NAME="line221"></A>    val <A HREF="#IS_PREFIX_APPEND-val">IS_PREFIX_APPEND</A> : thm
<A NAME="line222"></A>    val <A HREF="#IS_PREFIX_APPEND1-val">IS_PREFIX_APPEND1</A> : thm
<A NAME="line223"></A>    val <A HREF="#IS_PREFIX_APPEND2-val">IS_PREFIX_APPEND2</A> : thm
<A NAME="line224"></A>    val <A HREF="#IS_PREFIX_APPENDS-val">IS_PREFIX_APPENDS</A> : thm
<A NAME="line225"></A>    val <A HREF="#IS_PREFIX_BUTLAST-val">IS_PREFIX_BUTLAST</A> : thm
<A NAME="line226"></A>    val <A HREF="#IS_PREFIX_IS_SUBLIST-val">IS_PREFIX_IS_SUBLIST</A> : thm
<A NAME="line227"></A>    val <A HREF="#IS_PREFIX_LENGTH-val">IS_PREFIX_LENGTH</A> : thm
<A NAME="line228"></A>    val <A HREF="#IS_PREFIX_LENGTH_ANTI-val">IS_PREFIX_LENGTH_ANTI</A> : thm
<A NAME="line229"></A>    val <A HREF="#IS_PREFIX_NIL-val">IS_PREFIX_NIL</A> : thm
<A NAME="line230"></A>    val <A HREF="#IS_PREFIX_PREFIX-val">IS_PREFIX_PREFIX</A> : thm
<A NAME="line231"></A>    val <A HREF="#IS_PREFIX_REFL-val">IS_PREFIX_REFL</A> : thm
<A NAME="line232"></A>    val <A HREF="#IS_PREFIX_REVERSE-val">IS_PREFIX_REVERSE</A> : thm
<A NAME="line233"></A>    val <A HREF="#IS_PREFIX_SNOC-val">IS_PREFIX_SNOC</A> : thm
<A NAME="line234"></A>    val <A HREF="#IS_PREFIX_TRANS-val">IS_PREFIX_TRANS</A> : thm
<A NAME="line235"></A>    val <A HREF="#IS_SUBLIST_APPEND-val">IS_SUBLIST_APPEND</A> : thm
<A NAME="line236"></A>    val <A HREF="#IS_SUBLIST_REVERSE-val">IS_SUBLIST_REVERSE</A> : thm
<A NAME="line237"></A>    val <A HREF="#IS_SUFFIX_APPEND-val">IS_SUFFIX_APPEND</A> : thm
<A NAME="line238"></A>    val <A HREF="#IS_SUFFIX_IS_SUBLIST-val">IS_SUFFIX_IS_SUBLIST</A> : thm
<A NAME="line239"></A>    val <A HREF="#IS_SUFFIX_REVERSE-val">IS_SUFFIX_REVERSE</A> : thm
<A NAME="line240"></A>    val <A HREF="#IS_SUFFIX_compute-val">IS_SUFFIX_compute</A> : thm
<A NAME="line241"></A>    val <A HREF="#LAST-val">LAST</A> : thm
<A NAME="line242"></A>    val <A HREF="#LASTN_1-val">LASTN_1</A> : thm
<A NAME="line243"></A>    val <A HREF="#LASTN_APPEND1-val">LASTN_APPEND1</A> : thm
<A NAME="line244"></A>    val <A HREF="#LASTN_APPEND2-val">LASTN_APPEND2</A> : thm
<A NAME="line245"></A>    val <A HREF="#LASTN_BUTFIRSTN-val">LASTN_BUTFIRSTN</A> : thm
<A NAME="line246"></A>    val <A HREF="#LASTN_BUTLASTN-val">LASTN_BUTLASTN</A> : thm
<A NAME="line247"></A>    val <A HREF="#LASTN_CONS-val">LASTN_CONS</A> : thm
<A NAME="line248"></A>    val <A HREF="#LASTN_LASTN-val">LASTN_LASTN</A> : thm
<A NAME="line249"></A>    val <A HREF="#LASTN_LENGTH_APPEND-val">LASTN_LENGTH_APPEND</A> : thm
<A NAME="line250"></A>    val <A HREF="#LASTN_LENGTH_ID-val">LASTN_LENGTH_ID</A> : thm
<A NAME="line251"></A>    val <A HREF="#LASTN_MAP-val">LASTN_MAP</A> : thm
<A NAME="line252"></A>    val <A HREF="#LASTN_REVERSE-val">LASTN_REVERSE</A> : thm
<A NAME="line253"></A>    val <A HREF="#LASTN_SEG-val">LASTN_SEG</A> : thm
<A NAME="line254"></A>    val <A HREF="#LASTN_compute-val">LASTN_compute</A> : thm
<A NAME="line255"></A>    val <A HREF="#LAST_APPEND-val">LAST_APPEND</A> : thm
<A NAME="line256"></A>    val <A HREF="#LAST_CONS-val">LAST_CONS</A> : thm
<A NAME="line257"></A>    val <A HREF="#LAST_LASTN_LAST-val">LAST_LASTN_LAST</A> : thm
<A NAME="line258"></A>    val <A HREF="#LENGTH-val">LENGTH</A> : thm
<A NAME="line259"></A>    val <A HREF="#LENGTH_APPEND-val">LENGTH_APPEND</A> : thm
<A NAME="line260"></A>    val <A HREF="#LENGTH_BUTFIRSTN-val">LENGTH_BUTFIRSTN</A> : thm
<A NAME="line261"></A>    val <A HREF="#LENGTH_BUTLAST-val">LENGTH_BUTLAST</A> : thm
<A NAME="line262"></A>    val <A HREF="#LENGTH_BUTLASTN-val">LENGTH_BUTLASTN</A> : thm
<A NAME="line263"></A>    val <A HREF="#LENGTH_CONS-val">LENGTH_CONS</A> : thm
<A NAME="line264"></A>    val <A HREF="#LENGTH_EQ-val">LENGTH_EQ</A> : thm
<A NAME="line265"></A>    val <A HREF="#LENGTH_EQ_NIL-val">LENGTH_EQ_NIL</A> : thm
<A NAME="line266"></A>    val <A HREF="#LENGTH_FIRSTN-val">LENGTH_FIRSTN</A> : thm
<A NAME="line267"></A>    val <A HREF="#LENGTH_FLAT-val">LENGTH_FLAT</A> : thm
<A NAME="line268"></A>    val <A HREF="#LENGTH_FOLDL-val">LENGTH_FOLDL</A> : thm
<A NAME="line269"></A>    val <A HREF="#LENGTH_FOLDR-val">LENGTH_FOLDR</A> : thm
<A NAME="line270"></A>    val <A HREF="#LENGTH_GENLIST-val">LENGTH_GENLIST</A> : thm
<A NAME="line271"></A>    val <A HREF="#LENGTH_LASTN-val">LENGTH_LASTN</A> : thm
<A NAME="line272"></A>    val <A HREF="#LENGTH_MAP-val">LENGTH_MAP</A> : thm
<A NAME="line273"></A>    val <A HREF="#LENGTH_MAP2-val">LENGTH_MAP2</A> : thm
<A NAME="line274"></A>    val <A HREF="#LENGTH_NIL-val">LENGTH_NIL</A> : thm
<A NAME="line275"></A>    val <A HREF="#LENGTH_NOT_NULL-val">LENGTH_NOT_NULL</A> : thm
<A NAME="line276"></A>    val <A HREF="#LENGTH_REPLICATE-val">LENGTH_REPLICATE</A> : thm
<A NAME="line277"></A>    val <A HREF="#LENGTH_REVERSE-val">LENGTH_REVERSE</A> : thm
<A NAME="line278"></A>    val <A HREF="#LENGTH_SCANL-val">LENGTH_SCANL</A> : thm
<A NAME="line279"></A>    val <A HREF="#LENGTH_SCANR-val">LENGTH_SCANR</A> : thm
<A NAME="line280"></A>    val <A HREF="#LENGTH_SEG-val">LENGTH_SEG</A> : thm
<A NAME="line281"></A>    val <A HREF="#LENGTH_SNOC-val">LENGTH_SNOC</A> : thm
<A NAME="line282"></A>    val <A HREF="#LENGTH_UNZIP_FST-val">LENGTH_UNZIP_FST</A> : thm
<A NAME="line283"></A>    val <A HREF="#LENGTH_UNZIP_SND-val">LENGTH_UNZIP_SND</A> : thm
<A NAME="line284"></A>    val <A HREF="#LENGTH_ZIP-val">LENGTH_ZIP</A> : thm
<A NAME="line285"></A>    val <A HREF="#LIST_ELEM_COUNT_MEM-val">LIST_ELEM_COUNT_MEM</A> : thm
<A NAME="line286"></A>    val <A HREF="#LIST_ELEM_COUNT_THM-val">LIST_ELEM_COUNT_THM</A> : thm
<A NAME="line287"></A>    val <A HREF="#LIST_NOT_EQ-val">LIST_NOT_EQ</A> : thm
<A NAME="line288"></A>    val <A HREF="#MAP-val">MAP</A> : thm
<A NAME="line289"></A>    val <A HREF="#MAP2-val">MAP2</A> : thm
<A NAME="line290"></A>    val <A HREF="#MAP2_ZIP-val">MAP2_ZIP</A> : thm
<A NAME="line291"></A>    val <A HREF="#MAP_APPEND-val">MAP_APPEND</A> : thm
<A NAME="line292"></A>    val <A HREF="#MAP_EQ_f-val">MAP_EQ_f</A> : thm
<A NAME="line293"></A>    val <A HREF="#MAP_FILTER-val">MAP_FILTER</A> : thm
<A NAME="line294"></A>    val <A HREF="#MAP_FLAT-val">MAP_FLAT</A> : thm
<A NAME="line295"></A>    val <A HREF="#MAP_FOLDL-val">MAP_FOLDL</A> : thm
<A NAME="line296"></A>    val <A HREF="#MAP_FOLDR-val">MAP_FOLDR</A> : thm
<A NAME="line297"></A>    val <A HREF="#MAP_GENLIST-val">MAP_GENLIST</A> : thm
<A NAME="line298"></A>    val <A HREF="#MAP_MAP_o-val">MAP_MAP_o</A> : thm
<A NAME="line299"></A>    val <A HREF="#MAP_REVERSE-val">MAP_REVERSE</A> : thm
<A NAME="line300"></A>    val <A HREF="#MAP_SNOC-val">MAP_SNOC</A> : thm
<A NAME="line301"></A>    val <A HREF="#MAP_o-val">MAP_o</A> : thm
<A NAME="line302"></A>    val <A HREF="#MEM_FRONT-val">MEM_FRONT</A> : thm
<A NAME="line303"></A>    val <A HREF="#MEM_LAST-val">MEM_LAST</A> : thm
<A NAME="line304"></A>    val <A HREF="#MEM_LAST_FRONT-val">MEM_LAST_FRONT</A> : thm
<A NAME="line305"></A>    val <A HREF="#MONOID_APPEND_NIL-val">MONOID_APPEND_NIL</A> : thm
<A NAME="line306"></A>    val <A HREF="#NOT_ALL_EL_SOME_EL-val">NOT_ALL_EL_SOME_EL</A> : thm
<A NAME="line307"></A>    val <A HREF="#NOT_CONS_NIL-val">NOT_CONS_NIL</A> : thm
<A NAME="line308"></A>    val <A HREF="#NOT_EQ_LIST-val">NOT_EQ_LIST</A> : thm
<A NAME="line309"></A>    val <A HREF="#NOT_NIL_CONS-val">NOT_NIL_CONS</A> : thm
<A NAME="line310"></A>    val <A HREF="#NOT_NIL_SNOC-val">NOT_NIL_SNOC</A> : thm
<A NAME="line311"></A>    val <A HREF="#NOT_NULL_SNOC-val">NOT_NULL_SNOC</A> : thm
<A NAME="line312"></A>    val <A HREF="#NOT_SNOC_NIL-val">NOT_SNOC_NIL</A> : thm
<A NAME="line313"></A>    val <A HREF="#NOT_SOME_EL_ALL_EL-val">NOT_SOME_EL_ALL_EL</A> : thm
<A NAME="line314"></A>    val <A HREF="#NULL-val">NULL</A> : thm
<A NAME="line315"></A>    val <A HREF="#NULL_DEF-val">NULL_DEF</A> : thm
<A NAME="line316"></A>    val <A HREF="#NULL_EQ_NIL-val">NULL_EQ_NIL</A> : thm
<A NAME="line317"></A>    val <A HREF="#NULL_FOLDL-val">NULL_FOLDL</A> : thm
<A NAME="line318"></A>    val <A HREF="#NULL_FOLDR-val">NULL_FOLDR</A> : thm
<A NAME="line319"></A>    val <A HREF="#OR_EL_FOLDL-val">OR_EL_FOLDL</A> : thm
<A NAME="line320"></A>    val <A HREF="#OR_EL_FOLDR-val">OR_EL_FOLDR</A> : thm
<A NAME="line321"></A>    val <A HREF="#PREFIX-val">PREFIX</A> : thm
<A NAME="line322"></A>    val <A HREF="#PREFIX_FOLDR-val">PREFIX_FOLDR</A> : thm
<A NAME="line323"></A>    val <A HREF="#REPLACE_ELEMENT_SEM-val">REPLACE_ELEMENT_SEM</A> : thm
<A NAME="line324"></A>    val <A HREF="#REPLICATE_compute-val">REPLICATE_compute</A> : thm
<A NAME="line325"></A>    val <A HREF="#REVERSE-val">REVERSE</A> : thm
<A NAME="line326"></A>    val <A HREF="#REVERSE_APPEND-val">REVERSE_APPEND</A> : thm
<A NAME="line327"></A>    val <A HREF="#REVERSE_EQ_NIL-val">REVERSE_EQ_NIL</A> : thm
<A NAME="line328"></A>    val <A HREF="#REVERSE_FLAT-val">REVERSE_FLAT</A> : thm
<A NAME="line329"></A>    val <A HREF="#REVERSE_FOLDL-val">REVERSE_FOLDL</A> : thm
<A NAME="line330"></A>    val <A HREF="#REVERSE_FOLDR-val">REVERSE_FOLDR</A> : thm
<A NAME="line331"></A>    val <A HREF="#REVERSE_REVERSE-val">REVERSE_REVERSE</A> : thm
<A NAME="line332"></A>    val <A HREF="#REVERSE_SNOC-val">REVERSE_SNOC</A> : thm
<A NAME="line333"></A>    val <A HREF="#SEG_0_SNOC-val">SEG_0_SNOC</A> : thm
<A NAME="line334"></A>    val <A HREF="#SEG_APPEND-val">SEG_APPEND</A> : thm
<A NAME="line335"></A>    val <A HREF="#SEG_APPEND1-val">SEG_APPEND1</A> : thm
<A NAME="line336"></A>    val <A HREF="#SEG_APPEND2-val">SEG_APPEND2</A> : thm
<A NAME="line337"></A>    val <A HREF="#SEG_FIRSTN_BUTFISTN-val">SEG_FIRSTN_BUTFISTN</A> : thm
<A NAME="line338"></A>    val <A HREF="#SEG_LASTN_BUTLASTN-val">SEG_LASTN_BUTLASTN</A> : thm
<A NAME="line339"></A>    val <A HREF="#SEG_LENGTH_ID-val">SEG_LENGTH_ID</A> : thm
<A NAME="line340"></A>    val <A HREF="#SEG_LENGTH_SNOC-val">SEG_LENGTH_SNOC</A> : thm
<A NAME="line341"></A>    val <A HREF="#SEG_REVERSE-val">SEG_REVERSE</A> : thm
<A NAME="line342"></A>    val <A HREF="#SEG_SEG-val">SEG_SEG</A> : thm
<A NAME="line343"></A>    val <A HREF="#SEG_SNOC-val">SEG_SNOC</A> : thm
<A NAME="line344"></A>    val <A HREF="#SEG_SUC_CONS-val">SEG_SUC_CONS</A> : thm
<A NAME="line345"></A>    val <A HREF="#SEG_compute-val">SEG_compute</A> : thm
<A NAME="line346"></A>    val <A HREF="#SNOC_11-val">SNOC_11</A> : thm
<A NAME="line347"></A>    val <A HREF="#SNOC_APPEND-val">SNOC_APPEND</A> : thm
<A NAME="line348"></A>    val <A HREF="#SNOC_Axiom-val">SNOC_Axiom</A> : thm
<A NAME="line349"></A>    val <A HREF="#SNOC_CASES-val">SNOC_CASES</A> : thm
<A NAME="line350"></A>    val <A HREF="#SNOC_EL_FIRSTN-val">SNOC_EL_FIRSTN</A> : thm
<A NAME="line351"></A>    val <A HREF="#SNOC_EQ_LENGTH_EQ-val">SNOC_EQ_LENGTH_EQ</A> : thm
<A NAME="line352"></A>    val <A HREF="#SNOC_FOLDR-val">SNOC_FOLDR</A> : thm
<A NAME="line353"></A>    val <A HREF="#SNOC_INDUCT-val">SNOC_INDUCT</A> : thm
<A NAME="line354"></A>    val <A HREF="#SNOC_REVERSE_CONS-val">SNOC_REVERSE_CONS</A> : thm
<A NAME="line355"></A>    val <A HREF="#SOME_EL-val">SOME_EL</A> : thm
<A NAME="line356"></A>    val <A HREF="#SOME_EL_APPEND-val">SOME_EL_APPEND</A> : thm
<A NAME="line357"></A>    val <A HREF="#SOME_EL_BUTFIRSTN-val">SOME_EL_BUTFIRSTN</A> : thm
<A NAME="line358"></A>    val <A HREF="#SOME_EL_BUTLASTN-val">SOME_EL_BUTLASTN</A> : thm
<A NAME="line359"></A>    val <A HREF="#SOME_EL_DISJ-val">SOME_EL_DISJ</A> : thm
<A NAME="line360"></A>    val <A HREF="#SOME_EL_FIRSTN-val">SOME_EL_FIRSTN</A> : thm
<A NAME="line361"></A>    val <A HREF="#SOME_EL_FOLDL-val">SOME_EL_FOLDL</A> : thm
<A NAME="line362"></A>    val <A HREF="#SOME_EL_FOLDL_MAP-val">SOME_EL_FOLDL_MAP</A> : thm
<A NAME="line363"></A>    val <A HREF="#SOME_EL_FOLDR-val">SOME_EL_FOLDR</A> : thm
<A NAME="line364"></A>    val <A HREF="#SOME_EL_FOLDR_MAP-val">SOME_EL_FOLDR_MAP</A> : thm
<A NAME="line365"></A>    val <A HREF="#SOME_EL_LASTN-val">SOME_EL_LASTN</A> : thm
<A NAME="line366"></A>    val <A HREF="#SOME_EL_MAP-val">SOME_EL_MAP</A> : thm
<A NAME="line367"></A>    val <A HREF="#SOME_EL_REVERSE-val">SOME_EL_REVERSE</A> : thm
<A NAME="line368"></A>    val <A HREF="#SOME_EL_SEG-val">SOME_EL_SEG</A> : thm
<A NAME="line369"></A>    val <A HREF="#SOME_EL_SNOC-val">SOME_EL_SNOC</A> : thm
<A NAME="line370"></A>    val <A HREF="#SPLITP_EVERY-val">SPLITP_EVERY</A> : thm
<A NAME="line371"></A>    val <A HREF="#SUM-val">SUM</A> : thm
<A NAME="line372"></A>    val <A HREF="#SUM_APPEND-val">SUM_APPEND</A> : thm
<A NAME="line373"></A>    val <A HREF="#SUM_FLAT-val">SUM_FLAT</A> : thm
<A NAME="line374"></A>    val <A HREF="#SUM_FOLDL-val">SUM_FOLDL</A> : thm
<A NAME="line375"></A>    val <A HREF="#SUM_FOLDR-val">SUM_FOLDR</A> : thm
<A NAME="line376"></A>    val <A HREF="#SUM_REVERSE-val">SUM_REVERSE</A> : thm
<A NAME="line377"></A>    val <A HREF="#SUM_SNOC-val">SUM_SNOC</A> : thm
<A NAME="line378"></A>    val <A HREF="#TL-val">TL</A> : thm
<A NAME="line379"></A>    val <A HREF="#TL_SNOC-val">TL_SNOC</A> : thm
<A NAME="line380"></A>    val <A HREF="#UNZIP-val">UNZIP</A> : thm
<A NAME="line381"></A>    val <A HREF="#UNZIP_SNOC-val">UNZIP_SNOC</A> : thm
<A NAME="line382"></A>    val <A HREF="#UNZIP_ZIP-val">UNZIP_ZIP</A> : thm
<A NAME="line383"></A>    val <A HREF="#ZIP-val">ZIP</A> : thm
<A NAME="line384"></A>    val <A HREF="#ZIP_APPEND-val">ZIP_APPEND</A> : thm
<A NAME="line385"></A>    val <A HREF="#ZIP_FIRSTN-val">ZIP_FIRSTN</A> : thm
<A NAME="line386"></A>    val <A HREF="#ZIP_FIRSTN_LEQ-val">ZIP_FIRSTN_LEQ</A> : thm
<A NAME="line387"></A>    val <A HREF="#ZIP_GENLIST-val">ZIP_GENLIST</A> : thm
<A NAME="line388"></A>    val <A HREF="#ZIP_SNOC-val">ZIP_SNOC</A> : thm
<A NAME="line389"></A>    val <A HREF="#ZIP_UNZIP-val">ZIP_UNZIP</A> : thm
<A NAME="line390"></A>    val <A HREF="#list_CASES-val">list_CASES</A> : thm
<A NAME="line391"></A>    val <A HREF="#list_INDUCT-val">list_INDUCT</A> : thm
<A NAME="line392"></A>  
<A NAME="line393"></A>  val rich_list_grammars : type_grammar.grammar * term_grammar.grammar
<A NAME="line394"></A>  
<A NAME="line395"></A>  
<A NAME="line396"></A>(*
   [list] Parent theory of "rich_list"
   
   [<A NAME="AND_EL_DEF-val"><B>AND_EL_DEF</B></A>]  Definition
      
      |- AND_EL = EVERY I
   
   [<A NAME="BUTLASTN-val"><B>BUTLASTN</B></A>]  Definition
      
      |- (!l. BUTLASTN 0 l = l) /\
         !n x l. BUTLASTN (SUC n) (SNOC x l) = BUTLASTN n l
   
   [<A NAME="ELL-val"><B>ELL</B></A>]  Definition
      
      |- (!l. ELL 0 l = LAST l) /\ !n l. ELL (SUC n) l = ELL n (FRONT l)
   
   [<A NAME="GENLIST-val"><B>GENLIST</B></A>]  Definition
      
      |- (!f. GENLIST f 0 = []) /\
         !f n. GENLIST f (SUC n) = SNOC (f n) (GENLIST f n)
   
   [<A NAME="IS_SUBLIST-val"><B>IS_SUBLIST</B></A>]  Definition
      
      |- (!l. IS_SUBLIST l [] &lt;=&gt; T) /\
         (!x l. IS_SUBLIST [] (x::l) &lt;=&gt; F) /\
         !x1 l1 x2 l2.
           IS_SUBLIST (x1::l1) (x2::l2) &lt;=&gt;
           (x1 = x2) /\ l2 &lt;&lt;= l1 \/ IS_SUBLIST l1 (x2::l2)
   
   [<A NAME="IS_SUFFIX-val"><B>IS_SUFFIX</B></A>]  Definition
      
      |- (!l. IS_SUFFIX l [] &lt;=&gt; T) /\
         (!x l. IS_SUFFIX [] (SNOC x l) &lt;=&gt; F) /\
         !x1 l1 x2 l2.
           IS_SUFFIX (SNOC x1 l1) (SNOC x2 l2) &lt;=&gt;
           (x1 = x2) /\ IS_SUFFIX l1 l2
   
   [<A NAME="LASTN-val"><B>LASTN</B></A>]  Definition
      
      |- (!l. LASTN 0 l = []) /\
         !n x l. LASTN (SUC n) (SNOC x l) = SNOC x (LASTN n l)
   
   [<A NAME="LIST_ELEM_COUNT_DEF-val"><B>LIST_ELEM_COUNT_DEF</B></A>]  Definition
      
      |- !e l. LIST_ELEM_COUNT e l = LENGTH (FILTER (\x. x = e) l)
   
   [<A NAME="OR_EL_DEF-val"><B>OR_EL_DEF</B></A>]  Definition
      
      |- OR_EL = EXISTS I
   
   [<A NAME="PREFIX_DEF-val"><B>PREFIX_DEF</B></A>]  Definition
      
      |- !P l. PREFIX P l = FST (SPLITP ($~ o P) l)
   
   [<A NAME="REPLACE_ELEMENT_DEF-val"><B>REPLACE_ELEMENT_DEF</B></A>]  Definition
      
      |- (!e n. REPLACE_ELEMENT e n [] = []) /\
         (!e x l. REPLACE_ELEMENT e 0 (x::l) = e::l) /\
         !e n x l.
           REPLACE_ELEMENT e (SUC n) (x::l) = x::REPLACE_ELEMENT e n l
   
   [<A NAME="REPLICATE-val"><B>REPLICATE</B></A>]  Definition
      
      |- (!x. REPLICATE 0 x = []) /\
         !n x. REPLICATE (SUC n) x = x::REPLICATE n x
   
   [<A NAME="SCANL-val"><B>SCANL</B></A>]  Definition
      
      |- (!f e. SCANL f e [] = [e]) /\
         !f e x l. SCANL f e (x::l) = e::SCANL f (f e x) l
   
   [<A NAME="SCANR-val"><B>SCANR</B></A>]  Definition
      
      |- (!f e. SCANR f e [] = [e]) /\
         !f e x l. SCANR f e (x::l) = f x (HD (SCANR f e l))::SCANR f e l
   
   [<A NAME="SEG-val"><B>SEG</B></A>]  Definition
      
      |- (!k l. SEG 0 k l = []) /\
         (!m x l. SEG (SUC m) 0 (x::l) = x::SEG m 0 l) /\
         !m k x l. SEG (SUC m) (SUC k) (x::l) = SEG (SUC m) k l
   
   [<A NAME="SNOC-val"><B>SNOC</B></A>]  Definition
      
      |- (!x. SNOC x [] = [x]) /\ !x x' l. SNOC x (x'::l) = x'::SNOC x l
   
   [<A NAME="SPLITP-val"><B>SPLITP</B></A>]  Definition
      
      |- (!P. SPLITP P [] = ([],[])) /\
         !P x l.
           SPLITP P (x::l) =
           if P x then
             ([],x::l)
           else
             (x::FST (SPLITP P l),SND (SPLITP P l))
   
   [<A NAME="SUFFIX_DEF-val"><B>SUFFIX_DEF</B></A>]  Definition
      
      |- !P l.
           SUFFIX P l = FOLDL (\l' x. if P x then SNOC x l' else []) [] l
   
   [<A NAME="UNZIP_FST_DEF-val"><B>UNZIP_FST_DEF</B></A>]  Definition
      
      |- !l. UNZIP_FST l = FST (UNZIP l)
   
   [<A NAME="UNZIP_SND_DEF-val"><B>UNZIP_SND_DEF</B></A>]  Definition
      
      |- !l. UNZIP_SND l = SND (UNZIP l)
   
   [<A NAME="ALL_DISTINCT_SNOC-val"><B>ALL_DISTINCT_SNOC</B></A>]  Theorem
      
      |- !x l. ALL_DISTINCT (SNOC x l) &lt;=&gt; ~MEM x l /\ ALL_DISTINCT l
   
   [<A NAME="ALL_EL-val"><B>ALL_EL</B></A>]  Theorem
      
      |- (!P. EVERY P [] &lt;=&gt; T) /\
         !P h t. EVERY P (h::t) &lt;=&gt; P h /\ EVERY P t
   
   [<A NAME="ALL_EL_APPEND-val"><B>ALL_EL_APPEND</B></A>]  Theorem
      
      |- !P l1 l2. EVERY P (l1 ++ l2) &lt;=&gt; EVERY P l1 /\ EVERY P l2
   
   [<A NAME="ALL_EL_BUTFIRSTN-val"><B>ALL_EL_BUTFIRSTN</B></A>]  Theorem
      
      |- !P l. EVERY P l ==&gt; !m. m &lt;= LENGTH l ==&gt; EVERY P (DROP m l)
   
   [<A NAME="ALL_EL_BUTLASTN-val"><B>ALL_EL_BUTLASTN</B></A>]  Theorem
      
      |- !P l. EVERY P l ==&gt; !m. m &lt;= LENGTH l ==&gt; EVERY P (BUTLASTN m l)
   
   [<A NAME="ALL_EL_CONJ-val"><B>ALL_EL_CONJ</B></A>]  Theorem
      
      |- !P Q l. EVERY (\x. P x /\ Q x) l &lt;=&gt; EVERY P l /\ EVERY Q l
   
   [<A NAME="ALL_EL_FIRSTN-val"><B>ALL_EL_FIRSTN</B></A>]  Theorem
      
      |- !P l. EVERY P l ==&gt; !m. m &lt;= LENGTH l ==&gt; EVERY P (TAKE m l)
   
   [<A NAME="ALL_EL_FOLDL-val"><B>ALL_EL_FOLDL</B></A>]  Theorem
      
      |- !P l. EVERY P l &lt;=&gt; FOLDL (\l' x. l' /\ P x) T l
   
   [<A NAME="ALL_EL_FOLDL_MAP-val"><B>ALL_EL_FOLDL_MAP</B></A>]  Theorem
      
      |- !P l. EVERY P l &lt;=&gt; FOLDL $/\ T (MAP P l)
   
   [<A NAME="ALL_EL_FOLDR-val"><B>ALL_EL_FOLDR</B></A>]  Theorem
      
      |- !P l. EVERY P l &lt;=&gt; FOLDR (\x l'. P x /\ l') T l
   
   [<A NAME="ALL_EL_FOLDR_MAP-val"><B>ALL_EL_FOLDR_MAP</B></A>]  Theorem
      
      |- !P l. EVERY P l &lt;=&gt; FOLDR $/\ T (MAP P l)
   
   [<A NAME="ALL_EL_LASTN-val"><B>ALL_EL_LASTN</B></A>]  Theorem
      
      |- !P l. EVERY P l ==&gt; !m. m &lt;= LENGTH l ==&gt; EVERY P (LASTN m l)
   
   [<A NAME="ALL_EL_MAP-val"><B>ALL_EL_MAP</B></A>]  Theorem
      
      |- !P f l. EVERY P (MAP f l) &lt;=&gt; EVERY (P o f) l
   
   [<A NAME="ALL_EL_REPLICATE-val"><B>ALL_EL_REPLICATE</B></A>]  Theorem
      
      |- !x n. EVERY ($= x) (REPLICATE n x)
   
   [<A NAME="ALL_EL_REVERSE-val"><B>ALL_EL_REVERSE</B></A>]  Theorem
      
      |- !P l. EVERY P (REVERSE l) &lt;=&gt; EVERY P l
   
   [<A NAME="ALL_EL_SEG-val"><B>ALL_EL_SEG</B></A>]  Theorem
      
      |- !P l.
           EVERY P l ==&gt; !m k. m + k &lt;= LENGTH l ==&gt; EVERY P (SEG m k l)
   
   [<A NAME="ALL_EL_SNOC-val"><B>ALL_EL_SNOC</B></A>]  Theorem
      
      |- !P x l. EVERY P (SNOC x l) &lt;=&gt; EVERY P l /\ P x
   
   [<A NAME="AND_EL_FOLDL-val"><B>AND_EL_FOLDL</B></A>]  Theorem
      
      |- !l. AND_EL l &lt;=&gt; FOLDL $/\ T l
   
   [<A NAME="AND_EL_FOLDR-val"><B>AND_EL_FOLDR</B></A>]  Theorem
      
      |- !l. AND_EL l &lt;=&gt; FOLDR $/\ T l
   
   [<A NAME="APPEND-val"><B>APPEND</B></A>]  Theorem
      
      |- (!l. [] ++ l = l) /\ !l1 l2 x. x::l1 ++ l2 = x::(l1 ++ l2)
   
   [<A NAME="APPEND_ASSOC-val"><B>APPEND_ASSOC</B></A>]  Theorem
      
      |- !l1 l2 l3. l1 ++ (l2 ++ l3) = l1 ++ l2 ++ l3
   
   [<A NAME="APPEND_ASSOC_CONS-val"><B>APPEND_ASSOC_CONS</B></A>]  Theorem
      
      |- !l1 h l2 l3. l1 ++ h::l2 ++ l3 = l1 ++ h::(l2 ++ l3)
   
   [<A NAME="APPEND_BUTLASTN_BUTFIRSTN-val"><B>APPEND_BUTLASTN_BUTFIRSTN</B></A>]  Theorem
      
      |- !m n l. (m + n = LENGTH l) ==&gt; (BUTLASTN m l ++ DROP n l = l)
   
   [<A NAME="APPEND_BUTLASTN_LASTN-val"><B>APPEND_BUTLASTN_LASTN</B></A>]  Theorem
      
      |- !n l. n &lt;= LENGTH l ==&gt; (BUTLASTN n l ++ LASTN n l = l)
   
   [<A NAME="APPEND_BUTLAST_LAST-val"><B>APPEND_BUTLAST_LAST</B></A>]  Theorem
      
      |- !l. l &lt;&gt; [] ==&gt; (FRONT l ++ [LAST l] = l)
   
   [<A NAME="APPEND_FIRSTN_BUTFIRSTN-val"><B>APPEND_FIRSTN_BUTFIRSTN</B></A>]  Theorem
      
      |- !n l. n &lt;= LENGTH l ==&gt; (TAKE n l ++ DROP n l = l)
   
   [<A NAME="APPEND_FIRSTN_LASTN-val"><B>APPEND_FIRSTN_LASTN</B></A>]  Theorem
      
      |- !m n l. (m + n = LENGTH l) ==&gt; (TAKE n l ++ LASTN m l = l)
   
   [<A NAME="APPEND_FOLDL-val"><B>APPEND_FOLDL</B></A>]  Theorem
      
      |- !l1 l2. l1 ++ l2 = FOLDL (\l' x. SNOC x l') l1 l2
   
   [<A NAME="APPEND_FOLDR-val"><B>APPEND_FOLDR</B></A>]  Theorem
      
      |- !l1 l2. l1 ++ l2 = FOLDR CONS l2 l1
   
   [<A NAME="APPEND_LENGTH_EQ-val"><B>APPEND_LENGTH_EQ</B></A>]  Theorem
      
      |- !l1 l1'.
           (LENGTH l1 = LENGTH l1') ==&gt;
           !l2 l2'.
             (LENGTH l2 = LENGTH l2') ==&gt;
             ((l1 ++ l2 = l1' ++ l2') &lt;=&gt; (l1 = l1') /\ (l2 = l2'))
   
   [<A NAME="APPEND_NIL-val"><B>APPEND_NIL</B></A>]  Theorem
      
      |- (!l. l ++ [] = l) /\ !l. [] ++ l = l
   
   [<A NAME="APPEND_SNOC-val"><B>APPEND_SNOC</B></A>]  Theorem
      
      |- !l1 x l2. l1 ++ SNOC x l2 = SNOC x (l1 ++ l2)
   
   [<A NAME="APPEND_SNOC1-val"><B>APPEND_SNOC1</B></A>]  Theorem
      
      |- !l1 x l2. SNOC x l1 ++ l2 = l1 ++ x::l2
   
   [<A NAME="ASSOC_APPEND-val"><B>ASSOC_APPEND</B></A>]  Theorem
      
      |- ASSOC $++
   
   [<A NAME="ASSOC_FOLDL_FLAT-val"><B>ASSOC_FOLDL_FLAT</B></A>]  Theorem
      
      |- !f.
           ASSOC f ==&gt;
           !e.
             RIGHT_ID f e ==&gt;
             !l. FOLDL f e (FLAT l) = FOLDL f e (MAP (FOLDL f e) l)
   
   [<A NAME="ASSOC_FOLDR_FLAT-val"><B>ASSOC_FOLDR_FLAT</B></A>]  Theorem
      
      |- !f.
           ASSOC f ==&gt;
           !e.
             LEFT_ID f e ==&gt;
             !l. FOLDR f e (FLAT l) = FOLDR f e (MAP (FOLDR f e) l)
   
   [<A NAME="BUTFIRSTN-val"><B>BUTFIRSTN</B></A>]  Theorem
      
      |- (!l. DROP 0 l = l) /\ !n x l. DROP (SUC n) (x::l) = DROP n l
   
   [<A NAME="BUTFIRSTN_APPEND1-val"><B>BUTFIRSTN_APPEND1</B></A>]  Theorem
      
      |- !n l1. n &lt;= LENGTH l1 ==&gt; !l2. DROP n (l1 ++ l2) = DROP n l1 ++ l2
   
   [<A NAME="BUTFIRSTN_APPEND2-val"><B>BUTFIRSTN_APPEND2</B></A>]  Theorem
      
      |- !l1 n.
           LENGTH l1 &lt;= n ==&gt;
           !l2. DROP n (l1 ++ l2) = DROP (n - LENGTH l1) l2
   
   [<A NAME="BUTFIRSTN_BUTFIRSTN-val"><B>BUTFIRSTN_BUTFIRSTN</B></A>]  Theorem
      
      |- !n m l. n + m &lt;= LENGTH l ==&gt; (DROP n (DROP m l) = DROP (n + m) l)
   
   [<A NAME="BUTFIRSTN_CONS_EL-val"><B>BUTFIRSTN_CONS_EL</B></A>]  Theorem
      
      |- !n. n &lt; LENGTH l ==&gt; (DROP n l = EL n l::DROP (SUC n) l)
   
   [<A NAME="BUTFIRSTN_LASTN-val"><B>BUTFIRSTN_LASTN</B></A>]  Theorem
      
      |- !n l. n &lt;= LENGTH l ==&gt; (DROP n l = LASTN (LENGTH l - n) l)
   
   [<A NAME="BUTFIRSTN_LENGTH_APPEND-val"><B>BUTFIRSTN_LENGTH_APPEND</B></A>]  Theorem
      
      |- !l1 l2. DROP (LENGTH l1) (l1 ++ l2) = l2
   
   [<A NAME="BUTFIRSTN_LENGTH_NIL-val"><B>BUTFIRSTN_LENGTH_NIL</B></A>]  Theorem
      
      |- !l. DROP (LENGTH l) l = []
   
   [<A NAME="BUTFIRSTN_REVERSE-val"><B>BUTFIRSTN_REVERSE</B></A>]  Theorem
      
      |- !n l.
           n &lt;= LENGTH l ==&gt; (DROP n (REVERSE l) = REVERSE (BUTLASTN n l))
   
   [<A NAME="BUTFIRSTN_SEG-val"><B>BUTFIRSTN_SEG</B></A>]  Theorem
      
      |- !n l. n &lt;= LENGTH l ==&gt; (DROP n l = SEG (LENGTH l - n) n l)
   
   [<A NAME="BUTFIRSTN_SNOC-val"><B>BUTFIRSTN_SNOC</B></A>]  Theorem
      
      |- !n l. n &lt;= LENGTH l ==&gt; !x. DROP n (SNOC x l) = SNOC x (DROP n l)
   
   [<A NAME="BUTFIRSTN_compute-val"><B>BUTFIRSTN_compute</B></A>]  Theorem
      
      |- (!l. DROP 0 l = l) /\
         (!n x l.
            DROP (NUMERAL (BIT1 n)) (x::l) =
            DROP (NUMERAL (BIT1 n) - 1) l) /\
         !n x l. DROP (NUMERAL (BIT2 n)) (x::l) = DROP (NUMERAL (BIT1 n)) l
   
   [<A NAME="BUTLAST-val"><B>BUTLAST</B></A>]  Theorem
      
      |- !x l. FRONT (SNOC x l) = l
   
   [<A NAME="BUTLASTN_1-val"><B>BUTLASTN_1</B></A>]  Theorem
      
      |- !l. l &lt;&gt; [] ==&gt; (BUTLASTN 1 l = FRONT l)
   
   [<A NAME="BUTLASTN_APPEND1-val"><B>BUTLASTN_APPEND1</B></A>]  Theorem
      
      |- !l2 n.
           LENGTH l2 &lt;= n ==&gt;
           !l1. BUTLASTN n (l1 ++ l2) = BUTLASTN (n - LENGTH l2) l1
   
   [<A NAME="BUTLASTN_APPEND2-val"><B>BUTLASTN_APPEND2</B></A>]  Theorem
      
      |- !n l1 l2.
           n &lt;= LENGTH l2 ==&gt; (BUTLASTN n (l1 ++ l2) = l1 ++ BUTLASTN n l2)
   
   [<A NAME="BUTLASTN_BUTLAST-val"><B>BUTLASTN_BUTLAST</B></A>]  Theorem
      
      |- !n l.
           n &lt; LENGTH l ==&gt; (BUTLASTN n (FRONT l) = FRONT (BUTLASTN n l))
   
   [<A NAME="BUTLASTN_BUTLASTN-val"><B>BUTLASTN_BUTLASTN</B></A>]  Theorem
      
      |- !m n l.
           n + m &lt;= LENGTH l ==&gt;
           (BUTLASTN n (BUTLASTN m l) = BUTLASTN (n + m) l)
   
   [<A NAME="BUTLASTN_CONS-val"><B>BUTLASTN_CONS</B></A>]  Theorem
      
      |- !n l. n &lt;= LENGTH l ==&gt; !x. BUTLASTN n (x::l) = x::BUTLASTN n l
   
   [<A NAME="BUTLASTN_FIRSTN-val"><B>BUTLASTN_FIRSTN</B></A>]  Theorem
      
      |- !n l. n &lt;= LENGTH l ==&gt; (BUTLASTN n l = TAKE (LENGTH l - n) l)
   
   [<A NAME="BUTLASTN_LASTN-val"><B>BUTLASTN_LASTN</B></A>]  Theorem
      
      |- !m n l.
           m &lt;= n /\ n &lt;= LENGTH l ==&gt;
           (BUTLASTN m (LASTN n l) = LASTN (n - m) (BUTLASTN m l))
   
   [<A NAME="BUTLASTN_LASTN_NIL-val"><B>BUTLASTN_LASTN_NIL</B></A>]  Theorem
      
      |- !n l. n &lt;= LENGTH l ==&gt; (BUTLASTN n (LASTN n l) = [])
   
   [<A NAME="BUTLASTN_LENGTH_APPEND-val"><B>BUTLASTN_LENGTH_APPEND</B></A>]  Theorem
      
      |- !l2 l1. BUTLASTN (LENGTH l2) (l1 ++ l2) = l1
   
   [<A NAME="BUTLASTN_LENGTH_CONS-val"><B>BUTLASTN_LENGTH_CONS</B></A>]  Theorem
      
      |- !l x. BUTLASTN (LENGTH l) (x::l) = [x]
   
   [<A NAME="BUTLASTN_LENGTH_NIL-val"><B>BUTLASTN_LENGTH_NIL</B></A>]  Theorem
      
      |- !l. BUTLASTN (LENGTH l) l = []
   
   [<A NAME="BUTLASTN_MAP-val"><B>BUTLASTN_MAP</B></A>]  Theorem
      
      |- !n l.
           n &lt;= LENGTH l ==&gt;
           !f. BUTLASTN n (MAP f l) = MAP f (BUTLASTN n l)
   
   [<A NAME="BUTLASTN_REVERSE-val"><B>BUTLASTN_REVERSE</B></A>]  Theorem
      
      |- !n l.
           n &lt;= LENGTH l ==&gt; (BUTLASTN n (REVERSE l) = REVERSE (DROP n l))
   
   [<A NAME="BUTLASTN_SEG-val"><B>BUTLASTN_SEG</B></A>]  Theorem
      
      |- !n l. n &lt;= LENGTH l ==&gt; (BUTLASTN n l = SEG (LENGTH l - n) 0 l)
   
   [<A NAME="BUTLASTN_SUC_BUTLAST-val"><B>BUTLASTN_SUC_BUTLAST</B></A>]  Theorem
      
      |- !n l. n &lt; LENGTH l ==&gt; (BUTLASTN (SUC n) l = BUTLASTN n (FRONT l))
   
   [<A NAME="BUTLASTN_compute-val"><B>BUTLASTN_compute</B></A>]  Theorem
      
      |- !n l.
           BUTLASTN n l =
           (let m = LENGTH l in
              if n &lt;= m then
                TAKE (m - n) l
              else
                FAIL BUTLASTN longer than list n l)
   
   [<A NAME="BUTLAST_CONS-val"><B>BUTLAST_CONS</B></A>]  Theorem
      
      |- (!x. FRONT [x] = []) /\ !x y z. FRONT (x::y::z) = x::FRONT (y::z)
   
   [<A NAME="COMM_ASSOC_FOLDL_REVERSE-val"><B>COMM_ASSOC_FOLDL_REVERSE</B></A>]  Theorem
      
      |- !f.
           COMM f ==&gt; ASSOC f ==&gt; !e l. FOLDL f e (REVERSE l) = FOLDL f e l
   
   [<A NAME="COMM_ASSOC_FOLDR_REVERSE-val"><B>COMM_ASSOC_FOLDR_REVERSE</B></A>]  Theorem
      
      |- !f.
           COMM f ==&gt; ASSOC f ==&gt; !e l. FOLDR f e (REVERSE l) = FOLDR f e l
   
   [<A NAME="COMM_MONOID_FOLDL-val"><B>COMM_MONOID_FOLDL</B></A>]  Theorem
      
      |- !f.
           COMM f ==&gt;
           !e'. MONOID f e' ==&gt; !e l. FOLDL f e l = f e (FOLDL f e' l)
   
   [<A NAME="COMM_MONOID_FOLDR-val"><B>COMM_MONOID_FOLDR</B></A>]  Theorem
      
      |- !f.
           COMM f ==&gt;
           !e'. MONOID f e' ==&gt; !e l. FOLDR f e l = f e (FOLDR f e' l)
   
   [<A NAME="CONS-val"><B>CONS</B></A>]  Theorem
      
      |- !l. ~NULL l ==&gt; (HD l::TL l = l)
   
   [<A NAME="CONS_11-val"><B>CONS_11</B></A>]  Theorem
      
      |- !x l x' l'. (x::l = x'::l') &lt;=&gt; (x = x') /\ (l = l')
   
   [<A NAME="CONS_APPEND-val"><B>CONS_APPEND</B></A>]  Theorem
      
      |- !x l. x::l = [x] ++ l
   
   [<A NAME="EL-val"><B>EL</B></A>]  Theorem
      
      |- (!l. EL 0 l = HD l) /\ !n l. EL (SUC n) l = EL n (TL l)
   
   [<A NAME="ELL_0_SNOC-val"><B>ELL_0_SNOC</B></A>]  Theorem
      
      |- !l x. ELL 0 (SNOC x l) = x
   
   [<A NAME="ELL_APPEND1-val"><B>ELL_APPEND1</B></A>]  Theorem
      
      |- !l2 n.
           LENGTH l2 &lt;= n ==&gt;
           !l1. ELL n (l1 ++ l2) = ELL (n - LENGTH l2) l1
   
   [<A NAME="ELL_APPEND2-val"><B>ELL_APPEND2</B></A>]  Theorem
      
      |- !n l2. n &lt; LENGTH l2 ==&gt; !l1. ELL n (l1 ++ l2) = ELL n l2
   
   [<A NAME="ELL_CONS-val"><B>ELL_CONS</B></A>]  Theorem
      
      |- !n l. n &lt; LENGTH l ==&gt; !x. ELL n (x::l) = ELL n l
   
   [<A NAME="ELL_EL-val"><B>ELL_EL</B></A>]  Theorem
      
      |- !n l. n &lt; LENGTH l ==&gt; (ELL n l = EL (PRE (LENGTH l - n)) l)
   
   [<A NAME="ELL_IS_EL-val"><B>ELL_IS_EL</B></A>]  Theorem
      
      |- !n l. n &lt; LENGTH l ==&gt; MEM (ELL n l) l
   
   [<A NAME="ELL_LAST-val"><B>ELL_LAST</B></A>]  Theorem
      
      |- !l. ~NULL l ==&gt; (ELL 0 l = LAST l)
   
   [<A NAME="ELL_LENGTH_APPEND-val"><B>ELL_LENGTH_APPEND</B></A>]  Theorem
      
      |- !l1 l2. ~NULL l1 ==&gt; (ELL (LENGTH l2) (l1 ++ l2) = LAST l1)
   
   [<A NAME="ELL_LENGTH_CONS-val"><B>ELL_LENGTH_CONS</B></A>]  Theorem
      
      |- !l x. ELL (LENGTH l) (x::l) = x
   
   [<A NAME="ELL_LENGTH_SNOC-val"><B>ELL_LENGTH_SNOC</B></A>]  Theorem
      
      |- !l x. ELL (LENGTH l) (SNOC x l) = if NULL l then x else HD l
   
   [<A NAME="ELL_MAP-val"><B>ELL_MAP</B></A>]  Theorem
      
      |- !n l f. n &lt; LENGTH l ==&gt; (ELL n (MAP f l) = f (ELL n l))
   
   [<A NAME="ELL_PRE_LENGTH-val"><B>ELL_PRE_LENGTH</B></A>]  Theorem
      
      |- !l. l &lt;&gt; [] ==&gt; (ELL (PRE (LENGTH l)) l = HD l)
   
   [<A NAME="ELL_REVERSE-val"><B>ELL_REVERSE</B></A>]  Theorem
      
      |- !n l.
           n &lt; LENGTH l ==&gt;
           (ELL n (REVERSE l) = ELL (PRE (LENGTH l - n)) l)
   
   [<A NAME="ELL_REVERSE_EL-val"><B>ELL_REVERSE_EL</B></A>]  Theorem
      
      |- !n l. n &lt; LENGTH l ==&gt; (ELL n (REVERSE l) = EL n l)
   
   [<A NAME="ELL_SEG-val"><B>ELL_SEG</B></A>]  Theorem
      
      |- !n l.
           n &lt; LENGTH l ==&gt; (ELL n l = HD (SEG 1 (PRE (LENGTH l - n)) l))
   
   [<A NAME="ELL_SNOC-val"><B>ELL_SNOC</B></A>]  Theorem
      
      |- !n. 0 &lt; n ==&gt; !x l. ELL n (SNOC x l) = ELL (PRE n) l
   
   [<A NAME="ELL_SUC_SNOC-val"><B>ELL_SUC_SNOC</B></A>]  Theorem
      
      |- !n x l. ELL (SUC n) (SNOC x l) = ELL n l
   
   [<A NAME="ELL_compute-val"><B>ELL_compute</B></A>]  Theorem
      
      |- (!l. ELL 0 l = LAST l) /\
         (!n l.
            ELL (NUMERAL (BIT1 n)) l =
            ELL (NUMERAL (BIT1 n) - 1) (FRONT l)) /\
         !n l. ELL (NUMERAL (BIT2 n)) l = ELL (NUMERAL (BIT1 n)) (FRONT l)
   
   [<A NAME="EL_APPEND1-val"><B>EL_APPEND1</B></A>]  Theorem
      
      |- !n l1 l2. n &lt; LENGTH l1 ==&gt; (EL n (l1 ++ l2) = EL n l1)
   
   [<A NAME="EL_APPEND2-val"><B>EL_APPEND2</B></A>]  Theorem
      
      |- !l1 n.
           LENGTH l1 &lt;= n ==&gt; !l2. EL n (l1 ++ l2) = EL (n - LENGTH l1) l2
   
   [<A NAME="EL_BUTFIRSTN-val"><B>EL_BUTFIRSTN</B></A>]  Theorem
      
      |- !m n l. m + n &lt; LENGTH l ==&gt; (EL m (DROP n l) = EL (m + n) l)
   
   [<A NAME="EL_CONS-val"><B>EL_CONS</B></A>]  Theorem
      
      |- !n. 0 &lt; n ==&gt; !x l. EL n (x::l) = EL (PRE n) l
   
   [<A NAME="EL_ELL-val"><B>EL_ELL</B></A>]  Theorem
      
      |- !n l. n &lt; LENGTH l ==&gt; (EL n l = ELL (PRE (LENGTH l - n)) l)
   
   [<A NAME="EL_FIRSTN-val"><B>EL_FIRSTN</B></A>]  Theorem
      
      |- !n x l. x &lt; n /\ n &lt;= LENGTH l ==&gt; (EL x (TAKE n l) = EL x l)
   
   [<A NAME="EL_FRONT-val"><B>EL_FRONT</B></A>]  Theorem
      
      |- !l n.
           n &lt; LENGTH (FRONT l) /\ ~NULL l ==&gt; (EL n (FRONT l) = EL n l)
   
   [<A NAME="EL_GENLIST-val"><B>EL_GENLIST</B></A>]  Theorem
      
      |- !f n x. x &lt; n ==&gt; (EL x (GENLIST f n) = f x)
   
   [<A NAME="EL_IS_EL-val"><B>EL_IS_EL</B></A>]  Theorem
      
      |- !n l. n &lt; LENGTH l ==&gt; MEM (EL n l) l
   
   [<A NAME="EL_LENGTH_APPEND-val"><B>EL_LENGTH_APPEND</B></A>]  Theorem
      
      |- !l2 l1. ~NULL l2 ==&gt; (EL (LENGTH l1) (l1 ++ l2) = HD l2)
   
   [<A NAME="EL_LENGTH_SNOC-val"><B>EL_LENGTH_SNOC</B></A>]  Theorem
      
      |- !l x. EL (LENGTH l) (SNOC x l) = x
   
   [<A NAME="EL_MAP-val"><B>EL_MAP</B></A>]  Theorem
      
      |- !n l. n &lt; LENGTH l ==&gt; !f. EL n (MAP f l) = f (EL n l)
   
   [<A NAME="EL_PRE_LENGTH-val"><B>EL_PRE_LENGTH</B></A>]  Theorem
      
      |- !l. l &lt;&gt; [] ==&gt; (EL (PRE (LENGTH l)) l = LAST l)
   
   [<A NAME="EL_REVERSE-val"><B>EL_REVERSE</B></A>]  Theorem
      
      |- !n l.
           n &lt; LENGTH l ==&gt; (EL n (REVERSE l) = EL (PRE (LENGTH l - n)) l)
   
   [<A NAME="EL_REVERSE_ELL-val"><B>EL_REVERSE_ELL</B></A>]  Theorem
      
      |- !n l. n &lt; LENGTH l ==&gt; (EL n (REVERSE l) = ELL n l)
   
   [<A NAME="EL_SEG-val"><B>EL_SEG</B></A>]  Theorem
      
      |- !n l. n &lt; LENGTH l ==&gt; (EL n l = HD (SEG 1 n l))
   
   [<A NAME="EL_SNOC-val"><B>EL_SNOC</B></A>]  Theorem
      
      |- !n l. n &lt; LENGTH l ==&gt; !x. EL n (SNOC x l) = EL n l
   
   [<A NAME="EQ_LIST-val"><B>EQ_LIST</B></A>]  Theorem
      
      |- !x1 x2. (x1 = x2) ==&gt; !l1 l2. (l1 = l2) ==&gt; (x1::l1 = x2::l2)
   
   [<A NAME="EVERY_GENLIST-val"><B>EVERY_GENLIST</B></A>]  Theorem
      
      |- !n. (!i. i &lt; n ==&gt; P (f i)) ==&gt; EVERY P (GENLIST f n)
   
   [<A NAME="FCOMM_FOLDL_APPEND-val"><B>FCOMM_FOLDL_APPEND</B></A>]  Theorem
      
      |- !f g.
           FCOMM f g ==&gt;
           !e.
             RIGHT_ID g e ==&gt;
             !l1 l2. FOLDL f e (l1 ++ l2) = g (FOLDL f e l1) (FOLDL f e l2)
   
   [<A NAME="FCOMM_FOLDL_FLAT-val"><B>FCOMM_FOLDL_FLAT</B></A>]  Theorem
      
      |- !f g.
           FCOMM f g ==&gt;
           !e.
             RIGHT_ID g e ==&gt;
             !l. FOLDL f e (FLAT l) = FOLDL g e (MAP (FOLDL f e) l)
   
   [<A NAME="FCOMM_FOLDR_APPEND-val"><B>FCOMM_FOLDR_APPEND</B></A>]  Theorem
      
      |- !g f.
           FCOMM g f ==&gt;
           !e.
             LEFT_ID g e ==&gt;
             !l1 l2. FOLDR f e (l1 ++ l2) = g (FOLDR f e l1) (FOLDR f e l2)
   
   [<A NAME="FCOMM_FOLDR_FLAT-val"><B>FCOMM_FOLDR_FLAT</B></A>]  Theorem
      
      |- !g f.
           FCOMM g f ==&gt;
           !e.
             LEFT_ID g e ==&gt;
             !l. FOLDR f e (FLAT l) = FOLDR g e (MAP (FOLDR f e) l)
   
   [<A NAME="FILTER-val"><B>FILTER</B></A>]  Theorem
      
      |- (!P. FILTER P [] = []) /\
         !P h t.
           FILTER P (h::t) = if P h then h::FILTER P t else FILTER P t
   
   [<A NAME="FILTER_APPEND-val"><B>FILTER_APPEND</B></A>]  Theorem
      
      |- !f l1 l2. FILTER f (l1 ++ l2) = FILTER f l1 ++ FILTER f l2
   
   [<A NAME="FILTER_COMM-val"><B>FILTER_COMM</B></A>]  Theorem
      
      |- !f1 f2 l. FILTER f1 (FILTER f2 l) = FILTER f2 (FILTER f1 l)
   
   [<A NAME="FILTER_FILTER-val"><B>FILTER_FILTER</B></A>]  Theorem
      
      |- !P Q l. FILTER P (FILTER Q l) = FILTER (\x. P x /\ Q x) l
   
   [<A NAME="FILTER_FLAT-val"><B>FILTER_FLAT</B></A>]  Theorem
      
      |- !P l. FILTER P (FLAT l) = FLAT (MAP (FILTER P) l)
   
   [<A NAME="FILTER_FOLDL-val"><B>FILTER_FOLDL</B></A>]  Theorem
      
      |- !P l.
           FILTER P l = FOLDL (\l' x. if P x then SNOC x l' else l') [] l
   
   [<A NAME="FILTER_FOLDR-val"><B>FILTER_FOLDR</B></A>]  Theorem
      
      |- !P l. FILTER P l = FOLDR (\x l'. if P x then x::l' else l') [] l
   
   [<A NAME="FILTER_IDEM-val"><B>FILTER_IDEM</B></A>]  Theorem
      
      |- !f l. FILTER f (FILTER f l) = FILTER f l
   
   [<A NAME="FILTER_MAP-val"><B>FILTER_MAP</B></A>]  Theorem
      
      |- !f1 f2 l. FILTER f1 (MAP f2 l) = MAP f2 (FILTER (f1 o f2) l)
   
   [<A NAME="FILTER_REVERSE-val"><B>FILTER_REVERSE</B></A>]  Theorem
      
      |- !P l. FILTER P (REVERSE l) = REVERSE (FILTER P l)
   
   [<A NAME="FILTER_SNOC-val"><B>FILTER_SNOC</B></A>]  Theorem
      
      |- !P x l.
           FILTER P (SNOC x l) =
           if P x then SNOC x (FILTER P l) else FILTER P l
   
   [<A NAME="FIRSTN-val"><B>FIRSTN</B></A>]  Theorem
      
      |- (!l. TAKE 0 l = []) /\ !n x l. TAKE (SUC n) (x::l) = x::TAKE n l
   
   [<A NAME="FIRSTN_APPEND1-val"><B>FIRSTN_APPEND1</B></A>]  Theorem
      
      |- !n l1. n &lt;= LENGTH l1 ==&gt; !l2. TAKE n (l1 ++ l2) = TAKE n l1
   
   [<A NAME="FIRSTN_APPEND2-val"><B>FIRSTN_APPEND2</B></A>]  Theorem
      
      |- !l1 n.
           LENGTH l1 &lt;= n ==&gt;
           !l2. TAKE n (l1 ++ l2) = l1 ++ TAKE (n - LENGTH l1) l2
   
   [<A NAME="FIRSTN_BUTLASTN-val"><B>FIRSTN_BUTLASTN</B></A>]  Theorem
      
      |- !n l. n &lt;= LENGTH l ==&gt; (TAKE n l = BUTLASTN (LENGTH l - n) l)
   
   [<A NAME="FIRSTN_FIRSTN-val"><B>FIRSTN_FIRSTN</B></A>]  Theorem
      
      |- !m l.
           m &lt;= LENGTH l ==&gt; !n. n &lt;= m ==&gt; (TAKE n (TAKE m l) = TAKE n l)
   
   [<A NAME="FIRSTN_LENGTH_APPEND-val"><B>FIRSTN_LENGTH_APPEND</B></A>]  Theorem
      
      |- !l1 l2. TAKE (LENGTH l1) (l1 ++ l2) = l1
   
   [<A NAME="FIRSTN_LENGTH_ID-val"><B>FIRSTN_LENGTH_ID</B></A>]  Theorem
      
      |- !l. TAKE (LENGTH l) l = l
   
   [<A NAME="FIRSTN_REVERSE-val"><B>FIRSTN_REVERSE</B></A>]  Theorem
      
      |- !n l. n &lt;= LENGTH l ==&gt; (TAKE n (REVERSE l) = REVERSE (LASTN n l))
   
   [<A NAME="FIRSTN_SEG-val"><B>FIRSTN_SEG</B></A>]  Theorem
      
      |- !n l. n &lt;= LENGTH l ==&gt; (TAKE n l = SEG n 0 l)
   
   [<A NAME="FIRSTN_SNOC-val"><B>FIRSTN_SNOC</B></A>]  Theorem
      
      |- !n l. n &lt;= LENGTH l ==&gt; !x. TAKE n (SNOC x l) = TAKE n l
   
   [<A NAME="FIRSTN_compute-val"><B>FIRSTN_compute</B></A>]  Theorem
      
      |- (!l. TAKE 0 l = []) /\
         (!n x l.
            TAKE (NUMERAL (BIT1 n)) (x::l) =
            x::TAKE (NUMERAL (BIT1 n) - 1) l) /\
         !n x l.
           TAKE (NUMERAL (BIT2 n)) (x::l) = x::TAKE (NUMERAL (BIT1 n)) l
   
   [<A NAME="FLAT-val"><B>FLAT</B></A>]  Theorem
      
      |- (FLAT [] = []) /\ !x l. FLAT (x::l) = x ++ FLAT l
   
   [<A NAME="FLAT_APPEND-val"><B>FLAT_APPEND</B></A>]  Theorem
      
      |- !l1 l2. FLAT (l1 ++ l2) = FLAT l1 ++ FLAT l2
   
   [<A NAME="FLAT_FLAT-val"><B>FLAT_FLAT</B></A>]  Theorem
      
      |- !l. FLAT (FLAT l) = FLAT (MAP FLAT l)
   
   [<A NAME="FLAT_FOLDL-val"><B>FLAT_FOLDL</B></A>]  Theorem
      
      |- !l. FLAT l = FOLDL $++ [] l
   
   [<A NAME="FLAT_FOLDR-val"><B>FLAT_FOLDR</B></A>]  Theorem
      
      |- !l. FLAT l = FOLDR $++ [] l
   
   [<A NAME="FLAT_REVERSE-val"><B>FLAT_REVERSE</B></A>]  Theorem
      
      |- !l. FLAT (REVERSE l) = REVERSE (FLAT (MAP REVERSE l))
   
   [<A NAME="FLAT_SNOC-val"><B>FLAT_SNOC</B></A>]  Theorem
      
      |- !x l. FLAT (SNOC x l) = FLAT l ++ x
   
   [<A NAME="FOLDL-val"><B>FOLDL</B></A>]  Theorem
      
      |- (!f e. FOLDL f e [] = e) /\
         !f e x l. FOLDL f e (x::l) = FOLDL f (f e x) l
   
   [<A NAME="FOLDL_APPEND-val"><B>FOLDL_APPEND</B></A>]  Theorem
      
      |- !f e l1 l2. FOLDL f e (l1 ++ l2) = FOLDL f (FOLDL f e l1) l2
   
   [<A NAME="FOLDL_FILTER-val"><B>FOLDL_FILTER</B></A>]  Theorem
      
      |- !f e P l.
           FOLDL f e (FILTER P l) =
           FOLDL (\x y. if P y then f x y else x) e l
   
   [<A NAME="FOLDL_FOLDR_REVERSE-val"><B>FOLDL_FOLDR_REVERSE</B></A>]  Theorem
      
      |- !f e l. FOLDL f e l = FOLDR (\x y. f y x) e (REVERSE l)
   
   [<A NAME="FOLDL_MAP-val"><B>FOLDL_MAP</B></A>]  Theorem
      
      |- !f e g l. FOLDL f e (MAP g l) = FOLDL (\x y. f x (g y)) e l
   
   [<A NAME="FOLDL_MAP2-val"><B>FOLDL_MAP2</B></A>]  Theorem
      
      |- !f e g l. FOLDL f e (MAP g l) = FOLDL (\x y. f x (g y)) e l
   
   [<A NAME="FOLDL_REVERSE-val"><B>FOLDL_REVERSE</B></A>]  Theorem
      
      |- !f e l. FOLDL f e (REVERSE l) = FOLDR (\x y. f y x) e l
   
   [<A NAME="FOLDL_SINGLE-val"><B>FOLDL_SINGLE</B></A>]  Theorem
      
      |- !f e x. FOLDL f e [x] = f e x
   
   [<A NAME="FOLDL_SNOC-val"><B>FOLDL_SNOC</B></A>]  Theorem
      
      |- !f e x l. FOLDL f e (SNOC x l) = f (FOLDL f e l) x
   
   [<A NAME="FOLDL_SNOC_NIL-val"><B>FOLDL_SNOC_NIL</B></A>]  Theorem
      
      |- !l. FOLDL (\xs x. SNOC x xs) [] l = l
   
   [<A NAME="FOLDR-val"><B>FOLDR</B></A>]  Theorem
      
      |- (!f e. FOLDR f e [] = e) /\
         !f e x l. FOLDR f e (x::l) = f x (FOLDR f e l)
   
   [<A NAME="FOLDR_APPEND-val"><B>FOLDR_APPEND</B></A>]  Theorem
      
      |- !f e l1 l2. FOLDR f e (l1 ++ l2) = FOLDR f (FOLDR f e l2) l1
   
   [<A NAME="FOLDR_CONS_NIL-val"><B>FOLDR_CONS_NIL</B></A>]  Theorem
      
      |- !l. FOLDR CONS [] l = l
   
   [<A NAME="FOLDR_FILTER-val"><B>FOLDR_FILTER</B></A>]  Theorem
      
      |- !f e P l.
           FOLDR f e (FILTER P l) =
           FOLDR (\x y. if P x then f x y else y) e l
   
   [<A NAME="FOLDR_FILTER_REVERSE-val"><B>FOLDR_FILTER_REVERSE</B></A>]  Theorem
      
      |- !f.
           (!a b c. f a (f b c) = f b (f a c)) ==&gt;
           !e P l.
             FOLDR f e (FILTER P (REVERSE l)) = FOLDR f e (FILTER P l)
   
   [<A NAME="FOLDR_FOLDL-val"><B>FOLDR_FOLDL</B></A>]  Theorem
      
      |- !f e. MONOID f e ==&gt; !l. FOLDR f e l = FOLDL f e l
   
   [<A NAME="FOLDR_FOLDL_REVERSE-val"><B>FOLDR_FOLDL_REVERSE</B></A>]  Theorem
      
      |- !f e l. FOLDR f e l = FOLDL (\x y. f y x) e (REVERSE l)
   
   [<A NAME="FOLDR_MAP-val"><B>FOLDR_MAP</B></A>]  Theorem
      
      |- !f e g l. FOLDR f e (MAP g l) = FOLDR (\x y. f (g x) y) e l
   
   [<A NAME="FOLDR_MAP_REVERSE-val"><B>FOLDR_MAP_REVERSE</B></A>]  Theorem
      
      |- !f.
           (!a b c. f a (f b c) = f b (f a c)) ==&gt;
           !e g l. FOLDR f e (MAP g (REVERSE l)) = FOLDR f e (MAP g l)
   
   [<A NAME="FOLDR_REVERSE-val"><B>FOLDR_REVERSE</B></A>]  Theorem
      
      |- !f e l. FOLDR f e (REVERSE l) = FOLDL (\x y. f y x) e l
   
   [<A NAME="FOLDR_SINGLE-val"><B>FOLDR_SINGLE</B></A>]  Theorem
      
      |- !f e x. FOLDR f e [x] = f x e
   
   [<A NAME="FOLDR_SNOC-val"><B>FOLDR_SNOC</B></A>]  Theorem
      
      |- !f e x l. FOLDR f e (SNOC x l) = FOLDR f (f x e) l
   
   [<A NAME="FRONT_APPEND-val"><B>FRONT_APPEND</B></A>]  Theorem
      
      |- FRONT (l1 ++ e::l2) = l1 ++ FRONT (e::l2)
   
   [<A NAME="FRONT___LENGTH-val"><B>FRONT___LENGTH</B></A>]  Theorem
      
      |- !l. l &lt;&gt; [] ==&gt; (LENGTH (FRONT l) = PRE (LENGTH l))
   
   [<A NAME="GENLIST_APPEND-val"><B>GENLIST_APPEND</B></A>]  Theorem
      
      |- !f a b.
           GENLIST f (a + b) = GENLIST f b ++ GENLIST (\t. f (t + b)) a
   
   [<A NAME="GENLIST_FUN_EQ-val"><B>GENLIST_FUN_EQ</B></A>]  Theorem
      
      |- !n f g.
           (!x. x &lt; n ==&gt; (f x = g x)) ==&gt; (GENLIST f n = GENLIST g n)
   
   [<A NAME="GENLIST_compute-val"><B>GENLIST_compute</B></A>]  Theorem
      
      |- (!f. GENLIST f 0 = []) /\
         (!f n.
            GENLIST f (NUMERAL (BIT1 n)) =
            SNOC (f (NUMERAL (BIT1 n) - 1))
              (GENLIST f (NUMERAL (BIT1 n) - 1))) /\
         !f n.
           GENLIST f (NUMERAL (BIT2 n)) =
           SNOC (f (NUMERAL (BIT1 n))) (GENLIST f (NUMERAL (BIT1 n)))
   
   [<A NAME="HD-val"><B>HD</B></A>]  Theorem
      
      |- !x l. HD (x::l) = x
   
   [<A NAME="HD_GENLIST-val"><B>HD_GENLIST</B></A>]  Theorem
      
      |- HD (GENLIST f (SUC n)) = f 0
   
   [<A NAME="IS_EL-val"><B>IS_EL</B></A>]  Theorem
      
      |- (!x. MEM x [] &lt;=&gt; F) /\
         !y x l. MEM y (x::l) &lt;=&gt; (y = x) \/ MEM y l
   
   [<A NAME="IS_EL_APPEND-val"><B>IS_EL_APPEND</B></A>]  Theorem
      
      |- !l1 l2 x. MEM x (l1 ++ l2) &lt;=&gt; MEM x l1 \/ MEM x l2
   
   [<A NAME="IS_EL_BUTFIRSTN-val"><B>IS_EL_BUTFIRSTN</B></A>]  Theorem
      
      |- !m l. m &lt;= LENGTH l ==&gt; !x. MEM x (DROP m l) ==&gt; MEM x l
   
   [<A NAME="IS_EL_BUTLASTN-val"><B>IS_EL_BUTLASTN</B></A>]  Theorem
      
      |- !m l. m &lt;= LENGTH l ==&gt; !x. MEM x (BUTLASTN m l) ==&gt; MEM x l
   
   [<A NAME="IS_EL_DEF-val"><B>IS_EL_DEF</B></A>]  Theorem
      
      |- !x l. MEM x l &lt;=&gt; EXISTS ($= x) l
   
   [<A NAME="IS_EL_FILTER-val"><B>IS_EL_FILTER</B></A>]  Theorem
      
      |- !P x. P x ==&gt; !l. MEM x (FILTER P l) &lt;=&gt; MEM x l
   
   [<A NAME="IS_EL_FIRSTN-val"><B>IS_EL_FIRSTN</B></A>]  Theorem
      
      |- !m l. m &lt;= LENGTH l ==&gt; !x. MEM x (TAKE m l) ==&gt; MEM x l
   
   [<A NAME="IS_EL_FOLDL-val"><B>IS_EL_FOLDL</B></A>]  Theorem
      
      |- !y l. MEM y l &lt;=&gt; FOLDL (\l' x. l' \/ (y = x)) F l
   
   [<A NAME="IS_EL_FOLDL_MAP-val"><B>IS_EL_FOLDL_MAP</B></A>]  Theorem
      
      |- !x l. MEM x l &lt;=&gt; FOLDL $\/ F (MAP ($= x) l)
   
   [<A NAME="IS_EL_FOLDR-val"><B>IS_EL_FOLDR</B></A>]  Theorem
      
      |- !y l. MEM y l &lt;=&gt; FOLDR (\x l'. (y = x) \/ l') F l
   
   [<A NAME="IS_EL_FOLDR_MAP-val"><B>IS_EL_FOLDR_MAP</B></A>]  Theorem
      
      |- !x l. MEM x l &lt;=&gt; FOLDR $\/ F (MAP ($= x) l)
   
   [<A NAME="IS_EL_LASTN-val"><B>IS_EL_LASTN</B></A>]  Theorem
      
      |- !m l. m &lt;= LENGTH l ==&gt; !x. MEM x (LASTN m l) ==&gt; MEM x l
   
   [<A NAME="IS_EL_REPLICATE-val"><B>IS_EL_REPLICATE</B></A>]  Theorem
      
      |- !n. 0 &lt; n ==&gt; !x. MEM x (REPLICATE n x)
   
   [<A NAME="IS_EL_REVERSE-val"><B>IS_EL_REVERSE</B></A>]  Theorem
      
      |- !x l. MEM x (REVERSE l) &lt;=&gt; MEM x l
   
   [<A NAME="IS_EL_SEG-val"><B>IS_EL_SEG</B></A>]  Theorem
      
      |- !n m l. n + m &lt;= LENGTH l ==&gt; !x. MEM x (SEG n m l) ==&gt; MEM x l
   
   [<A NAME="IS_EL_SNOC-val"><B>IS_EL_SNOC</B></A>]  Theorem
      
      |- !y x l. MEM y (SNOC x l) &lt;=&gt; (y = x) \/ MEM y l
   
   [<A NAME="IS_EL_SOME_EL-val"><B>IS_EL_SOME_EL</B></A>]  Theorem
      
      |- !x l. MEM x l &lt;=&gt; EXISTS ($= x) l
   
   [<A NAME="IS_PREFIX-val"><B>IS_PREFIX</B></A>]  Theorem
      
      |- (!l. [] &lt;&lt;= l &lt;=&gt; T) /\ (!x l. x::l &lt;&lt;= [] &lt;=&gt; F) /\
         !x1 l1 x2 l2. x2::l2 &lt;&lt;= x1::l1 &lt;=&gt; (x1 = x2) /\ l2 &lt;&lt;= l1
   
   [<A NAME="IS_PREFIX_ANTISYM-val"><B>IS_PREFIX_ANTISYM</B></A>]  Theorem
      
      |- !x y. x &lt;&lt;= y /\ y &lt;&lt;= x ==&gt; (x = y)
   
   [<A NAME="IS_PREFIX_APPEND-val"><B>IS_PREFIX_APPEND</B></A>]  Theorem
      
      |- !l1 l2. l2 &lt;&lt;= l1 &lt;=&gt; ?l. l1 = l2 ++ l
   
   [<A NAME="IS_PREFIX_APPEND1-val"><B>IS_PREFIX_APPEND1</B></A>]  Theorem
      
      |- !a b c. a ++ b &lt;&lt;= c ==&gt; a &lt;&lt;= c
   
   [<A NAME="IS_PREFIX_APPEND2-val"><B>IS_PREFIX_APPEND2</B></A>]  Theorem
      
      |- !a b c. a &lt;&lt;= b ++ c ==&gt; a &lt;&lt;= b \/ b &lt;&lt;= a
   
   [<A NAME="IS_PREFIX_APPENDS-val"><B>IS_PREFIX_APPENDS</B></A>]  Theorem
      
      |- !a b c. a ++ b &lt;&lt;= a ++ c &lt;=&gt; b &lt;&lt;= c
   
   [<A NAME="IS_PREFIX_BUTLAST-val"><B>IS_PREFIX_BUTLAST</B></A>]  Theorem
      
      |- !x y. FRONT (x::y) &lt;&lt;= x::y
   
   [<A NAME="IS_PREFIX_IS_SUBLIST-val"><B>IS_PREFIX_IS_SUBLIST</B></A>]  Theorem
      
      |- !l1 l2. l2 &lt;&lt;= l1 ==&gt; IS_SUBLIST l1 l2
   
   [<A NAME="IS_PREFIX_LENGTH-val"><B>IS_PREFIX_LENGTH</B></A>]  Theorem
      
      |- !x y. x &lt;&lt;= y ==&gt; LENGTH x &lt;= LENGTH y
   
   [<A NAME="IS_PREFIX_LENGTH_ANTI-val"><B>IS_PREFIX_LENGTH_ANTI</B></A>]  Theorem
      
      |- !x y. x &lt;&lt;= y /\ (LENGTH x = LENGTH y) &lt;=&gt; (x = y)
   
   [<A NAME="IS_PREFIX_NIL-val"><B>IS_PREFIX_NIL</B></A>]  Theorem
      
      |- !x. [] &lt;&lt;= x /\ (x &lt;&lt;= [] &lt;=&gt; (x = []))
   
   [<A NAME="IS_PREFIX_PREFIX-val"><B>IS_PREFIX_PREFIX</B></A>]  Theorem
      
      |- !P l. PREFIX P l &lt;&lt;= l
   
   [<A NAME="IS_PREFIX_REFL-val"><B>IS_PREFIX_REFL</B></A>]  Theorem
      
      |- !x. x &lt;&lt;= x
   
   [<A NAME="IS_PREFIX_REVERSE-val"><B>IS_PREFIX_REVERSE</B></A>]  Theorem
      
      |- !l1 l2. REVERSE l2 &lt;&lt;= REVERSE l1 &lt;=&gt; IS_SUFFIX l1 l2
   
   [<A NAME="IS_PREFIX_SNOC-val"><B>IS_PREFIX_SNOC</B></A>]  Theorem
      
      |- !x y z. z &lt;&lt;= SNOC x y &lt;=&gt; z &lt;&lt;= y \/ (z = SNOC x y)
   
   [<A NAME="IS_PREFIX_TRANS-val"><B>IS_PREFIX_TRANS</B></A>]  Theorem
      
      |- !x y z. y &lt;&lt;= x /\ z &lt;&lt;= y ==&gt; z &lt;&lt;= x
   
   [<A NAME="IS_SUBLIST_APPEND-val"><B>IS_SUBLIST_APPEND</B></A>]  Theorem
      
      |- !l1 l2. IS_SUBLIST l1 l2 &lt;=&gt; ?l l'. l1 = l ++ (l2 ++ l')
   
   [<A NAME="IS_SUBLIST_REVERSE-val"><B>IS_SUBLIST_REVERSE</B></A>]  Theorem
      
      |- !l1 l2. IS_SUBLIST (REVERSE l1) (REVERSE l2) &lt;=&gt; IS_SUBLIST l1 l2
   
   [<A NAME="IS_SUFFIX_APPEND-val"><B>IS_SUFFIX_APPEND</B></A>]  Theorem
      
      |- !l1 l2. IS_SUFFIX l1 l2 &lt;=&gt; ?l. l1 = l ++ l2
   
   [<A NAME="IS_SUFFIX_IS_SUBLIST-val"><B>IS_SUFFIX_IS_SUBLIST</B></A>]  Theorem
      
      |- !l1 l2. IS_SUFFIX l1 l2 ==&gt; IS_SUBLIST l1 l2
   
   [<A NAME="IS_SUFFIX_REVERSE-val"><B>IS_SUFFIX_REVERSE</B></A>]  Theorem
      
      |- !l2 l1. IS_SUFFIX (REVERSE l1) (REVERSE l2) &lt;=&gt; l2 &lt;&lt;= l1
   
   [<A NAME="IS_SUFFIX_compute-val"><B>IS_SUFFIX_compute</B></A>]  Theorem
      
      |- !l1 l2. IS_SUFFIX l1 l2 &lt;=&gt; REVERSE l2 &lt;&lt;= REVERSE l1
   
   [<A NAME="LAST-val"><B>LAST</B></A>]  Theorem
      
      |- !x l. LAST (SNOC x l) = x
   
   [<A NAME="LASTN_1-val"><B>LASTN_1</B></A>]  Theorem
      
      |- !l. l &lt;&gt; [] ==&gt; (LASTN 1 l = [LAST l])
   
   [<A NAME="LASTN_APPEND1-val"><B>LASTN_APPEND1</B></A>]  Theorem
      
      |- !l2 n.
           LENGTH l2 &lt;= n ==&gt;
           !l1. LASTN n (l1 ++ l2) = LASTN (n - LENGTH l2) l1 ++ l2
   
   [<A NAME="LASTN_APPEND2-val"><B>LASTN_APPEND2</B></A>]  Theorem
      
      |- !n l2. n &lt;= LENGTH l2 ==&gt; !l1. LASTN n (l1 ++ l2) = LASTN n l2
   
   [<A NAME="LASTN_BUTFIRSTN-val"><B>LASTN_BUTFIRSTN</B></A>]  Theorem
      
      |- !n l. n &lt;= LENGTH l ==&gt; (LASTN n l = DROP (LENGTH l - n) l)
   
   [<A NAME="LASTN_BUTLASTN-val"><B>LASTN_BUTLASTN</B></A>]  Theorem
      
      |- !n m l.
           n + m &lt;= LENGTH l ==&gt;
           (LASTN n (BUTLASTN m l) = BUTLASTN m (LASTN (n + m) l))
   
   [<A NAME="LASTN_CONS-val"><B>LASTN_CONS</B></A>]  Theorem
      
      |- !n l. n &lt;= LENGTH l ==&gt; !x. LASTN n (x::l) = LASTN n l
   
   [<A NAME="LASTN_LASTN-val"><B>LASTN_LASTN</B></A>]  Theorem
      
      |- !l n m.
           m &lt;= LENGTH l ==&gt; n &lt;= m ==&gt; (LASTN n (LASTN m l) = LASTN n l)
   
   [<A NAME="LASTN_LENGTH_APPEND-val"><B>LASTN_LENGTH_APPEND</B></A>]  Theorem
      
      |- !l2 l1. LASTN (LENGTH l2) (l1 ++ l2) = l2
   
   [<A NAME="LASTN_LENGTH_ID-val"><B>LASTN_LENGTH_ID</B></A>]  Theorem
      
      |- !l. LASTN (LENGTH l) l = l
   
   [<A NAME="LASTN_MAP-val"><B>LASTN_MAP</B></A>]  Theorem
      
      |- !n l. n &lt;= LENGTH l ==&gt; !f. LASTN n (MAP f l) = MAP f (LASTN n l)
   
   [<A NAME="LASTN_REVERSE-val"><B>LASTN_REVERSE</B></A>]  Theorem
      
      |- !n l. n &lt;= LENGTH l ==&gt; (LASTN n (REVERSE l) = REVERSE (TAKE n l))
   
   [<A NAME="LASTN_SEG-val"><B>LASTN_SEG</B></A>]  Theorem
      
      |- !n l. n &lt;= LENGTH l ==&gt; (LASTN n l = SEG n (LENGTH l - n) l)
   
   [<A NAME="LASTN_compute-val"><B>LASTN_compute</B></A>]  Theorem
      
      |- !n l.
           LASTN n l =
           (let m = LENGTH l in
              if n &lt;= m then
                DROP (m - n) l
              else
                FAIL LASTN longer than list n l)
   
   [<A NAME="LAST_APPEND-val"><B>LAST_APPEND</B></A>]  Theorem
      
      |- !e l1 l2. LAST (l1 ++ e::l2) = LAST (e::l2)
   
   [<A NAME="LAST_CONS-val"><B>LAST_CONS</B></A>]  Theorem
      
      |- (!x. LAST [x] = x) /\ !x y z. LAST (x::y::z) = LAST (y::z)
   
   [<A NAME="LAST_LASTN_LAST-val"><B>LAST_LASTN_LAST</B></A>]  Theorem
      
      |- !n l. n &lt;= LENGTH l ==&gt; 0 &lt; n ==&gt; (LAST (LASTN n l) = LAST l)
   
   [<A NAME="LENGTH-val"><B>LENGTH</B></A>]  Theorem
      
      |- (LENGTH [] = 0) /\ !x l. LENGTH (x::l) = SUC (LENGTH l)
   
   [<A NAME="LENGTH_APPEND-val"><B>LENGTH_APPEND</B></A>]  Theorem
      
      |- !l1 l2. LENGTH (l1 ++ l2) = LENGTH l1 + LENGTH l2
   
   [<A NAME="LENGTH_BUTFIRSTN-val"><B>LENGTH_BUTFIRSTN</B></A>]  Theorem
      
      |- !n l. n &lt;= LENGTH l ==&gt; (LENGTH (DROP n l) = LENGTH l - n)
   
   [<A NAME="LENGTH_BUTLAST-val"><B>LENGTH_BUTLAST</B></A>]  Theorem
      
      |- !l. l &lt;&gt; [] ==&gt; (LENGTH (FRONT l) = PRE (LENGTH l))
   
   [<A NAME="LENGTH_BUTLASTN-val"><B>LENGTH_BUTLASTN</B></A>]  Theorem
      
      |- !n l. n &lt;= LENGTH l ==&gt; (LENGTH (BUTLASTN n l) = LENGTH l - n)
   
   [<A NAME="LENGTH_CONS-val"><B>LENGTH_CONS</B></A>]  Theorem
      
      |- !l n. (LENGTH l = SUC n) &lt;=&gt; ?x l'. (LENGTH l' = n) /\ (l = x::l')
   
   [<A NAME="LENGTH_EQ-val"><B>LENGTH_EQ</B></A>]  Theorem
      
      |- !x y. (x = y) ==&gt; (LENGTH x = LENGTH y)
   
   [<A NAME="LENGTH_EQ_NIL-val"><B>LENGTH_EQ_NIL</B></A>]  Theorem
      
      |- !P. (!l. (LENGTH l = 0) ==&gt; P l) &lt;=&gt; P []
   
   [<A NAME="LENGTH_FIRSTN-val"><B>LENGTH_FIRSTN</B></A>]  Theorem
      
      |- !n l. n &lt;= LENGTH l ==&gt; (LENGTH (TAKE n l) = n)
   
   [<A NAME="LENGTH_FLAT-val"><B>LENGTH_FLAT</B></A>]  Theorem
      
      |- !l. LENGTH (FLAT l) = SUM (MAP LENGTH l)
   
   [<A NAME="LENGTH_FOLDL-val"><B>LENGTH_FOLDL</B></A>]  Theorem
      
      |- !l. LENGTH l = FOLDL (\l' x. SUC l') 0 l
   
   [<A NAME="LENGTH_FOLDR-val"><B>LENGTH_FOLDR</B></A>]  Theorem
      
      |- !l. LENGTH l = FOLDR (\x l'. SUC l') 0 l
   
   [<A NAME="LENGTH_GENLIST-val"><B>LENGTH_GENLIST</B></A>]  Theorem
      
      |- !f n. LENGTH (GENLIST f n) = n
   
   [<A NAME="LENGTH_LASTN-val"><B>LENGTH_LASTN</B></A>]  Theorem
      
      |- !n l. n &lt;= LENGTH l ==&gt; (LENGTH (LASTN n l) = n)
   
   [<A NAME="LENGTH_MAP-val"><B>LENGTH_MAP</B></A>]  Theorem
      
      |- !l f. LENGTH (MAP f l) = LENGTH l
   
   [<A NAME="LENGTH_MAP2-val"><B>LENGTH_MAP2</B></A>]  Theorem
      
      |- !l1 l2.
           (LENGTH l1 = LENGTH l2) ==&gt;
           !f.
             (LENGTH (MAP2 f l1 l2) = LENGTH l1) /\
             (LENGTH (MAP2 f l1 l2) = LENGTH l2)
   
   [<A NAME="LENGTH_NIL-val"><B>LENGTH_NIL</B></A>]  Theorem
      
      |- !l. (LENGTH l = 0) &lt;=&gt; (l = [])
   
   [<A NAME="LENGTH_NOT_NULL-val"><B>LENGTH_NOT_NULL</B></A>]  Theorem
      
      |- !l. 0 &lt; LENGTH l &lt;=&gt; ~NULL l
   
   [<A NAME="LENGTH_REPLICATE-val"><B>LENGTH_REPLICATE</B></A>]  Theorem
      
      |- !n x. LENGTH (REPLICATE n x) = n
   
   [<A NAME="LENGTH_REVERSE-val"><B>LENGTH_REVERSE</B></A>]  Theorem
      
      |- !l. LENGTH (REVERSE l) = LENGTH l
   
   [<A NAME="LENGTH_SCANL-val"><B>LENGTH_SCANL</B></A>]  Theorem
      
      |- !f e l. LENGTH (SCANL f e l) = SUC (LENGTH l)
   
   [<A NAME="LENGTH_SCANR-val"><B>LENGTH_SCANR</B></A>]  Theorem
      
      |- !f e l. LENGTH (SCANR f e l) = SUC (LENGTH l)
   
   [<A NAME="LENGTH_SEG-val"><B>LENGTH_SEG</B></A>]  Theorem
      
      |- !n k l. n + k &lt;= LENGTH l ==&gt; (LENGTH (SEG n k l) = n)
   
   [<A NAME="LENGTH_SNOC-val"><B>LENGTH_SNOC</B></A>]  Theorem
      
      |- !x l. LENGTH (SNOC x l) = SUC (LENGTH l)
   
   [<A NAME="LENGTH_UNZIP_FST-val"><B>LENGTH_UNZIP_FST</B></A>]  Theorem
      
      |- !l. LENGTH (UNZIP_FST l) = LENGTH l
   
   [<A NAME="LENGTH_UNZIP_SND-val"><B>LENGTH_UNZIP_SND</B></A>]  Theorem
      
      |- !l. LENGTH (UNZIP_SND l) = LENGTH l
   
   [<A NAME="LENGTH_ZIP-val"><B>LENGTH_ZIP</B></A>]  Theorem
      
      |- !l1 l2.
           (LENGTH l1 = LENGTH l2) ==&gt;
           (LENGTH (ZIP (l1,l2)) = LENGTH l1) /\
           (LENGTH (ZIP (l1,l2)) = LENGTH l2)
   
   [<A NAME="LIST_ELEM_COUNT_MEM-val"><B>LIST_ELEM_COUNT_MEM</B></A>]  Theorem
      
      |- !e l. LIST_ELEM_COUNT e l &gt; 0 &lt;=&gt; MEM e l
   
   [<A NAME="LIST_ELEM_COUNT_THM-val"><B>LIST_ELEM_COUNT_THM</B></A>]  Theorem
      
      |- (!e. LIST_ELEM_COUNT e [] = 0) /\
         (!e l1 l2.
            LIST_ELEM_COUNT e (l1 ++ l2) =
            LIST_ELEM_COUNT e l1 + LIST_ELEM_COUNT e l2) /\
         (!e h l.
            (h = e) ==&gt;
            (LIST_ELEM_COUNT e (h::l) = SUC (LIST_ELEM_COUNT e l))) /\
         !e h l.
           h &lt;&gt; e ==&gt; (LIST_ELEM_COUNT e (h::l) = LIST_ELEM_COUNT e l)
   
   [<A NAME="LIST_NOT_EQ-val"><B>LIST_NOT_EQ</B></A>]  Theorem
      
      |- !l1 l2. l1 &lt;&gt; l2 ==&gt; !x1 x2. x1::l1 &lt;&gt; x2::l2
   
   [<A NAME="MAP-val"><B>MAP</B></A>]  Theorem
      
      |- (!f. MAP f [] = []) /\ !f x l. MAP f (x::l) = f x::MAP f l
   
   [<A NAME="MAP2-val"><B>MAP2</B></A>]  Theorem
      
      |- (!f. MAP2 f [] [] = []) /\
         !f x1 l1 x2 l2. MAP2 f (x1::l1) (x2::l2) = f x1 x2::MAP2 f l1 l2
   
   [<A NAME="MAP2_ZIP-val"><B>MAP2_ZIP</B></A>]  Theorem
      
      |- !l1 l2.
           (LENGTH l1 = LENGTH l2) ==&gt;
           !f. MAP2 f l1 l2 = MAP (UNCURRY f) (ZIP (l1,l2))
   
   [<A NAME="MAP_APPEND-val"><B>MAP_APPEND</B></A>]  Theorem
      
      |- !f l1 l2. MAP f (l1 ++ l2) = MAP f l1 ++ MAP f l2
   
   [<A NAME="MAP_EQ_f-val"><B>MAP_EQ_f</B></A>]  Theorem
      
      |- !f1 f2 l. (MAP f1 l = MAP f2 l) &lt;=&gt; !e. MEM e l ==&gt; (f1 e = f2 e)
   
   [<A NAME="MAP_FILTER-val"><B>MAP_FILTER</B></A>]  Theorem
      
      |- !f P l.
           (!x. P (f x) &lt;=&gt; P x) ==&gt;
           (MAP f (FILTER P l) = FILTER P (MAP f l))
   
   [<A NAME="MAP_FLAT-val"><B>MAP_FLAT</B></A>]  Theorem
      
      |- !f l. MAP f (FLAT l) = FLAT (MAP (MAP f) l)
   
   [<A NAME="MAP_FOLDL-val"><B>MAP_FOLDL</B></A>]  Theorem
      
      |- !f l. MAP f l = FOLDL (\l' x. SNOC (f x) l') [] l
   
   [<A NAME="MAP_FOLDR-val"><B>MAP_FOLDR</B></A>]  Theorem
      
      |- !f l. MAP f l = FOLDR (\x l'. f x::l') [] l
   
   [<A NAME="MAP_GENLIST-val"><B>MAP_GENLIST</B></A>]  Theorem
      
      |- !f g n. MAP f (GENLIST g n) = GENLIST (f o g) n
   
   [<A NAME="MAP_MAP_o-val"><B>MAP_MAP_o</B></A>]  Theorem
      
      |- !f g l. MAP f (MAP g l) = MAP (f o g) l
   
   [<A NAME="MAP_REVERSE-val"><B>MAP_REVERSE</B></A>]  Theorem
      
      |- !f l. MAP f (REVERSE l) = REVERSE (MAP f l)
   
   [<A NAME="MAP_SNOC-val"><B>MAP_SNOC</B></A>]  Theorem
      
      |- !f x l. MAP f (SNOC x l) = SNOC (f x) (MAP f l)
   
   [<A NAME="MAP_o-val"><B>MAP_o</B></A>]  Theorem
      
      |- !f g. MAP (f o g) = MAP f o MAP g
   
   [<A NAME="MEM_FRONT-val"><B>MEM_FRONT</B></A>]  Theorem
      
      |- !l e y. MEM y (FRONT (e::l)) ==&gt; MEM y (e::l)
   
   [<A NAME="MEM_LAST-val"><B>MEM_LAST</B></A>]  Theorem
      
      |- !e l. MEM (LAST (e::l)) (e::l)
   
   [<A NAME="MEM_LAST_FRONT-val"><B>MEM_LAST_FRONT</B></A>]  Theorem
      
      |- !e l h. MEM e l /\ e &lt;&gt; LAST (h::l) ==&gt; MEM e (FRONT (h::l))
   
   [<A NAME="MONOID_APPEND_NIL-val"><B>MONOID_APPEND_NIL</B></A>]  Theorem
      
      |- MONOID $++ []
   
   [<A NAME="NOT_ALL_EL_SOME_EL-val"><B>NOT_ALL_EL_SOME_EL</B></A>]  Theorem
      
      |- !P l. ~EVERY P l &lt;=&gt; EXISTS ($~ o P) l
   
   [<A NAME="NOT_CONS_NIL-val"><B>NOT_CONS_NIL</B></A>]  Theorem
      
      |- !x l. x::l &lt;&gt; []
   
   [<A NAME="NOT_EQ_LIST-val"><B>NOT_EQ_LIST</B></A>]  Theorem
      
      |- !x1 x2. x1 &lt;&gt; x2 ==&gt; !l1 l2. x1::l1 &lt;&gt; x2::l2
   
   [<A NAME="NOT_NIL_CONS-val"><B>NOT_NIL_CONS</B></A>]  Theorem
      
      |- !x l. [] &lt;&gt; x::l
   
   [<A NAME="NOT_NIL_SNOC-val"><B>NOT_NIL_SNOC</B></A>]  Theorem
      
      |- !x l. [] &lt;&gt; SNOC x l
   
   [<A NAME="NOT_NULL_SNOC-val"><B>NOT_NULL_SNOC</B></A>]  Theorem
      
      |- !x l. ~NULL (SNOC x l)
   
   [<A NAME="NOT_SNOC_NIL-val"><B>NOT_SNOC_NIL</B></A>]  Theorem
      
      |- !x l. SNOC x l &lt;&gt; []
   
   [<A NAME="NOT_SOME_EL_ALL_EL-val"><B>NOT_SOME_EL_ALL_EL</B></A>]  Theorem
      
      |- !P l. ~EXISTS P l &lt;=&gt; EVERY ($~ o P) l
   
   [<A NAME="NULL-val"><B>NULL</B></A>]  Theorem
      
      |- NULL [] /\ !x l. ~NULL (x::l)
   
   [<A NAME="NULL_DEF-val"><B>NULL_DEF</B></A>]  Theorem
      
      |- (NULL [] &lt;=&gt; T) /\ !x l. NULL (x::l) &lt;=&gt; F
   
   [<A NAME="NULL_EQ_NIL-val"><B>NULL_EQ_NIL</B></A>]  Theorem
      
      |- !l. NULL l &lt;=&gt; (l = [])
   
   [<A NAME="NULL_FOLDL-val"><B>NULL_FOLDL</B></A>]  Theorem
      
      |- !l. NULL l &lt;=&gt; FOLDL (\x l'. F) T l
   
   [<A NAME="NULL_FOLDR-val"><B>NULL_FOLDR</B></A>]  Theorem
      
      |- !l. NULL l &lt;=&gt; FOLDR (\x l'. F) T l
   
   [<A NAME="OR_EL_FOLDL-val"><B>OR_EL_FOLDL</B></A>]  Theorem
      
      |- !l. OR_EL l &lt;=&gt; FOLDL $\/ F l
   
   [<A NAME="OR_EL_FOLDR-val"><B>OR_EL_FOLDR</B></A>]  Theorem
      
      |- !l. OR_EL l &lt;=&gt; FOLDR $\/ F l
   
   [<A NAME="PREFIX-val"><B>PREFIX</B></A>]  Theorem
      
      |- (!P. PREFIX P [] = []) /\
         !P x l. PREFIX P (x::l) = if P x then x::PREFIX P l else []
   
   [<A NAME="PREFIX_FOLDR-val"><B>PREFIX_FOLDR</B></A>]  Theorem
      
      |- !P l. PREFIX P l = FOLDR (\x l'. if P x then x::l' else []) [] l
   
   [<A NAME="REPLACE_ELEMENT_SEM-val"><B>REPLACE_ELEMENT_SEM</B></A>]  Theorem
      
      |- (!e n l. LENGTH (REPLACE_ELEMENT e n l) = LENGTH l) /\
         !e n l p.
           p &lt; LENGTH l ==&gt;
           (EL p (REPLACE_ELEMENT e n l) = if p = n then e else EL p l)
   
   [<A NAME="REPLICATE_compute-val"><B>REPLICATE_compute</B></A>]  Theorem
      
      |- (!x. REPLICATE 0 x = []) /\
         (!n x.
            REPLICATE (NUMERAL (BIT1 n)) x =
            x::REPLICATE (NUMERAL (BIT1 n) - 1) x) /\
         !n x.
           REPLICATE (NUMERAL (BIT2 n)) x =
           x::REPLICATE (NUMERAL (BIT1 n)) x
   
   [<A NAME="REVERSE-val"><B>REVERSE</B></A>]  Theorem
      
      |- (REVERSE [] = []) /\ !x l. REVERSE (x::l) = SNOC x (REVERSE l)
   
   [<A NAME="REVERSE_APPEND-val"><B>REVERSE_APPEND</B></A>]  Theorem
      
      |- !l1 l2. REVERSE (l1 ++ l2) = REVERSE l2 ++ REVERSE l1
   
   [<A NAME="REVERSE_EQ_NIL-val"><B>REVERSE_EQ_NIL</B></A>]  Theorem
      
      |- !l. (REVERSE l = []) &lt;=&gt; (l = [])
   
   [<A NAME="REVERSE_FLAT-val"><B>REVERSE_FLAT</B></A>]  Theorem
      
      |- !l. REVERSE (FLAT l) = FLAT (REVERSE (MAP REVERSE l))
   
   [<A NAME="REVERSE_FOLDL-val"><B>REVERSE_FOLDL</B></A>]  Theorem
      
      |- !l. REVERSE l = FOLDL (\l' x. x::l') [] l
   
   [<A NAME="REVERSE_FOLDR-val"><B>REVERSE_FOLDR</B></A>]  Theorem
      
      |- !l. REVERSE l = FOLDR SNOC [] l
   
   [<A NAME="REVERSE_REVERSE-val"><B>REVERSE_REVERSE</B></A>]  Theorem
      
      |- !l. REVERSE (REVERSE l) = l
   
   [<A NAME="REVERSE_SNOC-val"><B>REVERSE_SNOC</B></A>]  Theorem
      
      |- !x l. REVERSE (SNOC x l) = x::REVERSE l
   
   [<A NAME="SEG_0_SNOC-val"><B>SEG_0_SNOC</B></A>]  Theorem
      
      |- !m l x. m &lt;= LENGTH l ==&gt; (SEG m 0 (SNOC x l) = SEG m 0 l)
   
   [<A NAME="SEG_APPEND-val"><B>SEG_APPEND</B></A>]  Theorem
      
      |- !m l1 n l2.
           m &lt; LENGTH l1 /\ LENGTH l1 &lt;= n + m /\
           n + m &lt;= LENGTH l1 + LENGTH l2 ==&gt;
           (SEG n m (l1 ++ l2) =
            SEG (LENGTH l1 - m) m l1 ++ SEG (n + m - LENGTH l1) 0 l2)
   
   [<A NAME="SEG_APPEND1-val"><B>SEG_APPEND1</B></A>]  Theorem
      
      |- !n m l1.
           n + m &lt;= LENGTH l1 ==&gt; !l2. SEG n m (l1 ++ l2) = SEG n m l1
   
   [<A NAME="SEG_APPEND2-val"><B>SEG_APPEND2</B></A>]  Theorem
      
      |- !l1 m n l2.
           LENGTH l1 &lt;= m /\ n &lt;= LENGTH l2 ==&gt;
           (SEG n m (l1 ++ l2) = SEG n (m - LENGTH l1) l2)
   
   [<A NAME="SEG_FIRSTN_BUTFISTN-val"><B>SEG_FIRSTN_BUTFISTN</B></A>]  Theorem
      
      |- !n m l. n + m &lt;= LENGTH l ==&gt; (SEG n m l = TAKE n (DROP m l))
   
   [<A NAME="SEG_LASTN_BUTLASTN-val"><B>SEG_LASTN_BUTLASTN</B></A>]  Theorem
      
      |- !n m l.
           n + m &lt;= LENGTH l ==&gt;
           (SEG n m l = LASTN n (BUTLASTN (LENGTH l - (n + m)) l))
   
   [<A NAME="SEG_LENGTH_ID-val"><B>SEG_LENGTH_ID</B></A>]  Theorem
      
      |- !l. SEG (LENGTH l) 0 l = l
   
   [<A NAME="SEG_LENGTH_SNOC-val"><B>SEG_LENGTH_SNOC</B></A>]  Theorem
      
      |- !l x. SEG 1 (LENGTH l) (SNOC x l) = [x]
   
   [<A NAME="SEG_REVERSE-val"><B>SEG_REVERSE</B></A>]  Theorem
      
      |- !n m l.
           n + m &lt;= LENGTH l ==&gt;
           (SEG n m (REVERSE l) = REVERSE (SEG n (LENGTH l - (n + m)) l))
   
   [<A NAME="SEG_SEG-val"><B>SEG_SEG</B></A>]  Theorem
      
      |- !n1 m1 n2 m2 l.
           n1 + m1 &lt;= LENGTH l /\ n2 + m2 &lt;= n1 ==&gt;
           (SEG n2 m2 (SEG n1 m1 l) = SEG n2 (m1 + m2) l)
   
   [<A NAME="SEG_SNOC-val"><B>SEG_SNOC</B></A>]  Theorem
      
      |- !n m l. n + m &lt;= LENGTH l ==&gt; !x. SEG n m (SNOC x l) = SEG n m l
   
   [<A NAME="SEG_SUC_CONS-val"><B>SEG_SUC_CONS</B></A>]  Theorem
      
      |- !m n l x. SEG m (SUC n) (x::l) = SEG m n l
   
   [<A NAME="SEG_compute-val"><B>SEG_compute</B></A>]  Theorem
      
      |- (!k l. SEG 0 k l = []) /\
         (!m x l.
            SEG (NUMERAL (BIT1 m)) 0 (x::l) =
            x::SEG (NUMERAL (BIT1 m) - 1) 0 l) /\
         (!m x l.
            SEG (NUMERAL (BIT2 m)) 0 (x::l) =
            x::SEG (NUMERAL (BIT1 m)) 0 l) /\
         (!m k x l.
            SEG (NUMERAL (BIT1 m)) (NUMERAL (BIT1 k)) (x::l) =
            SEG (NUMERAL (BIT1 m)) (NUMERAL (BIT1 k) - 1) l) /\
         (!m k x l.
            SEG (NUMERAL (BIT2 m)) (NUMERAL (BIT1 k)) (x::l) =
            SEG (NUMERAL (BIT2 m)) (NUMERAL (BIT1 k) - 1) l) /\
         (!m k x l.
            SEG (NUMERAL (BIT1 m)) (NUMERAL (BIT2 k)) (x::l) =
            SEG (NUMERAL (BIT1 m)) (NUMERAL (BIT1 k)) l) /\
         !m k x l.
           SEG (NUMERAL (BIT2 m)) (NUMERAL (BIT2 k)) (x::l) =
           SEG (NUMERAL (BIT2 m)) (NUMERAL (BIT1 k)) l
   
   [<A NAME="SNOC_11-val"><B>SNOC_11</B></A>]  Theorem
      
      |- !x l x' l'. (SNOC x l = SNOC x' l') &lt;=&gt; (x = x') /\ (l = l')
   
   [<A NAME="SNOC_APPEND-val"><B>SNOC_APPEND</B></A>]  Theorem
      
      |- !x l. SNOC x l = l ++ [x]
   
   [<A NAME="SNOC_Axiom-val"><B>SNOC_Axiom</B></A>]  Theorem
      
      |- !e f. ?fn. (fn [] = e) /\ !x l. fn (SNOC x l) = f x l (fn l)
   
   [<A NAME="SNOC_CASES-val"><B>SNOC_CASES</B></A>]  Theorem
      
      |- !ll. (ll = []) \/ ?x l. ll = SNOC x l
   
   [<A NAME="SNOC_EL_FIRSTN-val"><B>SNOC_EL_FIRSTN</B></A>]  Theorem
      
      |- !n l. n &lt; LENGTH l ==&gt; (SNOC (EL n l) (TAKE n l) = TAKE (SUC n) l)
   
   [<A NAME="SNOC_EQ_LENGTH_EQ-val"><B>SNOC_EQ_LENGTH_EQ</B></A>]  Theorem
      
      |- !x1 l1 x2 l2.
           (SNOC x1 l1 = SNOC x2 l2) ==&gt; (LENGTH l1 = LENGTH l2)
   
   [<A NAME="SNOC_FOLDR-val"><B>SNOC_FOLDR</B></A>]  Theorem
      
      |- !x l. SNOC x l = FOLDR CONS [x] l
   
   [<A NAME="SNOC_INDUCT-val"><B>SNOC_INDUCT</B></A>]  Theorem
      
      |- !P. P [] /\ (!l. P l ==&gt; !x. P (SNOC x l)) ==&gt; !l. P l
   
   [<A NAME="SNOC_REVERSE_CONS-val"><B>SNOC_REVERSE_CONS</B></A>]  Theorem
      
      |- !x l. SNOC x l = REVERSE (x::REVERSE l)
   
   [<A NAME="SOME_EL-val"><B>SOME_EL</B></A>]  Theorem
      
      |- (!P. EXISTS P [] &lt;=&gt; F) /\
         !P h t. EXISTS P (h::t) &lt;=&gt; P h \/ EXISTS P t
   
   [<A NAME="SOME_EL_APPEND-val"><B>SOME_EL_APPEND</B></A>]  Theorem
      
      |- !P l1 l2. EXISTS P (l1 ++ l2) &lt;=&gt; EXISTS P l1 \/ EXISTS P l2
   
   [<A NAME="SOME_EL_BUTFIRSTN-val"><B>SOME_EL_BUTFIRSTN</B></A>]  Theorem
      
      |- !m l. m &lt;= LENGTH l ==&gt; !P. EXISTS P (DROP m l) ==&gt; EXISTS P l
   
   [<A NAME="SOME_EL_BUTLASTN-val"><B>SOME_EL_BUTLASTN</B></A>]  Theorem
      
      |- !m l. m &lt;= LENGTH l ==&gt; !P. EXISTS P (BUTLASTN m l) ==&gt; EXISTS P l
   
   [<A NAME="SOME_EL_DISJ-val"><B>SOME_EL_DISJ</B></A>]  Theorem
      
      |- !P Q l. EXISTS (\x. P x \/ Q x) l &lt;=&gt; EXISTS P l \/ EXISTS Q l
   
   [<A NAME="SOME_EL_FIRSTN-val"><B>SOME_EL_FIRSTN</B></A>]  Theorem
      
      |- !m l. m &lt;= LENGTH l ==&gt; !P. EXISTS P (TAKE m l) ==&gt; EXISTS P l
   
   [<A NAME="SOME_EL_FOLDL-val"><B>SOME_EL_FOLDL</B></A>]  Theorem
      
      |- !P l. EXISTS P l &lt;=&gt; FOLDL (\l' x. l' \/ P x) F l
   
   [<A NAME="SOME_EL_FOLDL_MAP-val"><B>SOME_EL_FOLDL_MAP</B></A>]  Theorem
      
      |- !P l. EXISTS P l &lt;=&gt; FOLDL $\/ F (MAP P l)
   
   [<A NAME="SOME_EL_FOLDR-val"><B>SOME_EL_FOLDR</B></A>]  Theorem
      
      |- !P l. EXISTS P l &lt;=&gt; FOLDR (\x l'. P x \/ l') F l
   
   [<A NAME="SOME_EL_FOLDR_MAP-val"><B>SOME_EL_FOLDR_MAP</B></A>]  Theorem
      
      |- !P l. EXISTS P l &lt;=&gt; FOLDR $\/ F (MAP P l)
   
   [<A NAME="SOME_EL_LASTN-val"><B>SOME_EL_LASTN</B></A>]  Theorem
      
      |- !m l. m &lt;= LENGTH l ==&gt; !P. EXISTS P (LASTN m l) ==&gt; EXISTS P l
   
   [<A NAME="SOME_EL_MAP-val"><B>SOME_EL_MAP</B></A>]  Theorem
      
      |- !P f l. EXISTS P (MAP f l) &lt;=&gt; EXISTS (P o f) l
   
   [<A NAME="SOME_EL_REVERSE-val"><B>SOME_EL_REVERSE</B></A>]  Theorem
      
      |- !P l. EXISTS P (REVERSE l) &lt;=&gt; EXISTS P l
   
   [<A NAME="SOME_EL_SEG-val"><B>SOME_EL_SEG</B></A>]  Theorem
      
      |- !m k l.
           m + k &lt;= LENGTH l ==&gt; !P. EXISTS P (SEG m k l) ==&gt; EXISTS P l
   
   [<A NAME="SOME_EL_SNOC-val"><B>SOME_EL_SNOC</B></A>]  Theorem
      
      |- !P x l. EXISTS P (SNOC x l) &lt;=&gt; P x \/ EXISTS P l
   
   [<A NAME="SPLITP_EVERY-val"><B>SPLITP_EVERY</B></A>]  Theorem
      
      |- !P l. EVERY (\x. ~P x) l ==&gt; (SPLITP P l = (l,[]))
   
   [<A NAME="SUM-val"><B>SUM</B></A>]  Theorem
      
      |- (SUM [] = 0) /\ !x l. SUM (x::l) = x + SUM l
   
   [<A NAME="SUM_APPEND-val"><B>SUM_APPEND</B></A>]  Theorem
      
      |- !l1 l2. SUM (l1 ++ l2) = SUM l1 + SUM l2
   
   [<A NAME="SUM_FLAT-val"><B>SUM_FLAT</B></A>]  Theorem
      
      |- !l. SUM (FLAT l) = SUM (MAP SUM l)
   
   [<A NAME="SUM_FOLDL-val"><B>SUM_FOLDL</B></A>]  Theorem
      
      |- !l. SUM l = FOLDL $+ 0 l
   
   [<A NAME="SUM_FOLDR-val"><B>SUM_FOLDR</B></A>]  Theorem
      
      |- !l. SUM l = FOLDR $+ 0 l
   
   [<A NAME="SUM_REVERSE-val"><B>SUM_REVERSE</B></A>]  Theorem
      
      |- !l. SUM (REVERSE l) = SUM l
   
   [<A NAME="SUM_SNOC-val"><B>SUM_SNOC</B></A>]  Theorem
      
      |- !x l. SUM (SNOC x l) = SUM l + x
   
   [<A NAME="TL-val"><B>TL</B></A>]  Theorem
      
      |- !x l. TL (x::l) = l
   
   [<A NAME="TL_SNOC-val"><B>TL_SNOC</B></A>]  Theorem
      
      |- !x l. TL (SNOC x l) = if NULL l then [] else SNOC x (TL l)
   
   [<A NAME="UNZIP-val"><B>UNZIP</B></A>]  Theorem
      
      |- (UNZIP [] = ([],[])) /\
         !x l. UNZIP (x::l) = (FST x::FST (UNZIP l),SND x::SND (UNZIP l))
   
   [<A NAME="UNZIP_SNOC-val"><B>UNZIP_SNOC</B></A>]  Theorem
      
      |- !x l.
           UNZIP (SNOC x l) =
           (SNOC (FST x) (FST (UNZIP l)),SNOC (SND x) (SND (UNZIP l)))
   
   [<A NAME="UNZIP_ZIP-val"><B>UNZIP_ZIP</B></A>]  Theorem
      
      |- !l1 l2.
           (LENGTH l1 = LENGTH l2) ==&gt; (UNZIP (ZIP (l1,l2)) = (l1,l2))
   
   [<A NAME="ZIP-val"><B>ZIP</B></A>]  Theorem
      
      |- (ZIP ([],[]) = []) /\
         !x1 l1 x2 l2. ZIP (x1::l1,x2::l2) = (x1,x2)::ZIP (l1,l2)
   
   [<A NAME="ZIP_APPEND-val"><B>ZIP_APPEND</B></A>]  Theorem
      
      |- !a b c d.
           (LENGTH a = LENGTH b) /\ (LENGTH c = LENGTH d) ==&gt;
           (ZIP (a,b) ++ ZIP (c,d) = ZIP (a ++ c,b ++ d))
   
   [<A NAME="ZIP_FIRSTN-val"><B>ZIP_FIRSTN</B></A>]  Theorem
      
      |- !n a b.
           n &lt;= LENGTH a /\ (LENGTH a = LENGTH b) ==&gt;
           (ZIP (TAKE n a,TAKE n b) = TAKE n (ZIP (a,b)))
   
   [<A NAME="ZIP_FIRSTN_LEQ-val"><B>ZIP_FIRSTN_LEQ</B></A>]  Theorem
      
      |- !n a b.
           n &lt;= LENGTH a /\ LENGTH a &lt;= LENGTH b ==&gt;
           (ZIP (TAKE n a,TAKE n b) = TAKE n (ZIP (a,TAKE (LENGTH a) b)))
   
   [<A NAME="ZIP_GENLIST-val"><B>ZIP_GENLIST</B></A>]  Theorem
      
      |- !l f n.
           (LENGTH l = n) ==&gt;
           (ZIP (l,GENLIST f n) = GENLIST (\x. (EL x l,f x)) n)
   
   [<A NAME="ZIP_SNOC-val"><B>ZIP_SNOC</B></A>]  Theorem
      
      |- !l1 l2.
           (LENGTH l1 = LENGTH l2) ==&gt;
           !x1 x2. ZIP (SNOC x1 l1,SNOC x2 l2) = SNOC (x1,x2) (ZIP (l1,l2))
   
   [<A NAME="ZIP_UNZIP-val"><B>ZIP_UNZIP</B></A>]  Theorem
      
      |- !l. ZIP (UNZIP l) = l
   
   [<A NAME="list_CASES-val"><B>list_CASES</B></A>]  Theorem
      
      |- !l. (l = []) \/ ?t h. l = h::t
   
   [<A NAME="list_INDUCT-val"><B>list_INDUCT</B></A>]  Theorem
      
      |- !P. P [] /\ (!l. P l ==&gt; !x. P (x::l)) ==&gt; !l. P l
   
   
*)
end

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/list/src/rich_listScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
