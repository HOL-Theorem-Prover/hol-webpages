<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure patriciaTheory</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure patriciaTheory</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/patricia/patriciaScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>signature patriciaTheory =
<A NAME="line2"></A>sig
<A NAME="line3"></A>  type thm = Thm.thm
<A NAME="line4"></A>  
<A NAME="line5"></A>  (*  Definitions  *)
<A NAME="line6"></A>    val <A HREF="#ADD_LIST_def-val">ADD_LIST_def</A> : thm
<A NAME="line7"></A>    val <A HREF="#ADD_curried_def-val">ADD_curried_def</A> : thm
<A NAME="line8"></A>    val <A HREF="#ADD_tupled_primitive_def-val">ADD_tupled_primitive_def</A> : thm
<A NAME="line9"></A>    val <A HREF="#BRANCHING_BIT_curried_def-val">BRANCHING_BIT_curried_def</A> : thm
<A NAME="line10"></A>    val <A HREF="#BRANCHING_BIT_tupled_primitive_def-val">BRANCHING_BIT_tupled_primitive_def</A> : thm
<A NAME="line11"></A>    val <A HREF="#BRANCH_primitive_def-val">BRANCH_primitive_def</A> : thm
<A NAME="line12"></A>    val <A HREF="#DEPTH_def-val">DEPTH_def</A> : thm
<A NAME="line13"></A>    val <A HREF="#EVERY_LEAF_def-val">EVERY_LEAF_def</A> : thm
<A NAME="line14"></A>    val <A HREF="#EXISTS_LEAF_def-val">EXISTS_LEAF_def</A> : thm
<A NAME="line15"></A>    val <A HREF="#FIND_def-val">FIND_def</A> : thm
<A NAME="line16"></A>    val <A HREF="#INSERT_PTREE_def-val">INSERT_PTREE_def</A> : thm
<A NAME="line17"></A>    val <A HREF="#IN_PTREE_def-val">IN_PTREE_def</A> : thm
<A NAME="line18"></A>    val <A HREF="#IS_EMPTY_primitive_def-val">IS_EMPTY_primitive_def</A> : thm
<A NAME="line19"></A>    val <A HREF="#IS_PTREE_def-val">IS_PTREE_def</A> : thm
<A NAME="line20"></A>    val <A HREF="#JOIN_def-val">JOIN_def</A> : thm
<A NAME="line21"></A>    val <A HREF="#KEYS_def-val">KEYS_def</A> : thm
<A NAME="line22"></A>    val <A HREF="#NUMSET_OF_PTREE_def-val">NUMSET_OF_PTREE_def</A> : thm
<A NAME="line23"></A>    val <A HREF="#PEEK_curried_def-val">PEEK_curried_def</A> : thm
<A NAME="line24"></A>    val <A HREF="#PEEK_tupled_primitive_def-val">PEEK_tupled_primitive_def</A> : thm
<A NAME="line25"></A>    val <A HREF="#PTREE_OF_NUMSET_def-val">PTREE_OF_NUMSET_def</A> : thm
<A NAME="line26"></A>    val <A HREF="#REMOVE_def-val">REMOVE_def</A> : thm
<A NAME="line27"></A>    val <A HREF="#SIZE_def-val">SIZE_def</A> : thm
<A NAME="line28"></A>    val <A HREF="#TRANSFORM_def-val">TRANSFORM_def</A> : thm
<A NAME="line29"></A>    val <A HREF="#TRAVERSE_AUX_def-val">TRAVERSE_AUX_def</A> : thm
<A NAME="line30"></A>    val <A HREF="#TRAVERSE_def-val">TRAVERSE_def</A> : thm
<A NAME="line31"></A>    val <A HREF="#UNION_PTREE_def-val">UNION_PTREE_def</A> : thm
<A NAME="line32"></A>    val <A HREF="#ptree_TY_DEF-val">ptree_TY_DEF</A> : thm
<A NAME="line33"></A>    val <A HREF="#ptree_case_def-val">ptree_case_def</A> : thm
<A NAME="line34"></A>    val <A HREF="#ptree_repfns-val">ptree_repfns</A> : thm
<A NAME="line35"></A>    val <A HREF="#ptree_size_def-val">ptree_size_def</A> : thm
<A NAME="line36"></A>  
<A NAME="line37"></A>  (*  Theorems  *)
<A NAME="line38"></A>    val <A HREF="#ADD_ADD-val">ADD_ADD</A> : thm
<A NAME="line39"></A>    val <A HREF="#ADD_ADD_SYM-val">ADD_ADD_SYM</A> : thm
<A NAME="line40"></A>    val <A HREF="#ADD_INSERT-val">ADD_INSERT</A> : thm
<A NAME="line41"></A>    val <A HREF="#ADD_IS_PTREE-val">ADD_IS_PTREE</A> : thm
<A NAME="line42"></A>    val <A HREF="#ADD_LIST_IS_PTREE-val">ADD_LIST_IS_PTREE</A> : thm
<A NAME="line43"></A>    val <A HREF="#ADD_TRANSFORM-val">ADD_TRANSFORM</A> : thm
<A NAME="line44"></A>    val <A HREF="#ADD_def-val">ADD_def</A> : thm
<A NAME="line45"></A>    val <A HREF="#ADD_ind-val">ADD_ind</A> : thm
<A NAME="line46"></A>    val <A HREF="#ALL_DISTINCT_TRAVERSE-val">ALL_DISTINCT_TRAVERSE</A> : thm
<A NAME="line47"></A>    val <A HREF="#BRANCH-val">BRANCH</A> : thm
<A NAME="line48"></A>    val <A HREF="#BRANCHING_BIT-val">BRANCHING_BIT</A> : thm
<A NAME="line49"></A>    val <A HREF="#BRANCHING_BIT_SYM-val">BRANCHING_BIT_SYM</A> : thm
<A NAME="line50"></A>    val <A HREF="#BRANCHING_BIT_ZERO-val">BRANCHING_BIT_ZERO</A> : thm
<A NAME="line51"></A>    val <A HREF="#BRANCHING_BIT_def-val">BRANCHING_BIT_def</A> : thm
<A NAME="line52"></A>    val <A HREF="#BRANCHING_BIT_ind-val">BRANCHING_BIT_ind</A> : thm
<A NAME="line53"></A>    val <A HREF="#BRANCH_def-val">BRANCH_def</A> : thm
<A NAME="line54"></A>    val <A HREF="#BRANCH_ind-val">BRANCH_ind</A> : thm
<A NAME="line55"></A>    val <A HREF="#CARD_LIST_TO_SET-val">CARD_LIST_TO_SET</A> : thm
<A NAME="line56"></A>    val <A HREF="#CARD_NUMSET_OF_PTREE-val">CARD_NUMSET_OF_PTREE</A> : thm
<A NAME="line57"></A>    val <A HREF="#DELETE_UNION-val">DELETE_UNION</A> : thm
<A NAME="line58"></A>    val <A HREF="#EMPTY_IS_PTREE-val">EMPTY_IS_PTREE</A> : thm
<A NAME="line59"></A>    val <A HREF="#EVERY_LEAF_ADD-val">EVERY_LEAF_ADD</A> : thm
<A NAME="line60"></A>    val <A HREF="#EVERY_LEAF_BRANCH-val">EVERY_LEAF_BRANCH</A> : thm
<A NAME="line61"></A>    val <A HREF="#EVERY_LEAF_PEEK-val">EVERY_LEAF_PEEK</A> : thm
<A NAME="line62"></A>    val <A HREF="#EVERY_LEAF_REMOVE-val">EVERY_LEAF_REMOVE</A> : thm
<A NAME="line63"></A>    val <A HREF="#EVERY_LEAF_TRANSFORM-val">EVERY_LEAF_TRANSFORM</A> : thm
<A NAME="line64"></A>    val <A HREF="#FILTER_ALL-val">FILTER_ALL</A> : thm
<A NAME="line65"></A>    val <A HREF="#FILTER_NONE-val">FILTER_NONE</A> : thm
<A NAME="line66"></A>    val <A HREF="#FINITE_NUMSET_OF_PTREE-val">FINITE_NUMSET_OF_PTREE</A> : thm
<A NAME="line67"></A>    val <A HREF="#INSERT_PTREE_IS_PTREE-val">INSERT_PTREE_IS_PTREE</A> : thm
<A NAME="line68"></A>    val <A HREF="#IN_NUMSET_OF_PTREE-val">IN_NUMSET_OF_PTREE</A> : thm
<A NAME="line69"></A>    val <A HREF="#IN_PTREE_EMPTY-val">IN_PTREE_EMPTY</A> : thm
<A NAME="line70"></A>    val <A HREF="#IN_PTREE_INSERT_PTREE-val">IN_PTREE_INSERT_PTREE</A> : thm
<A NAME="line71"></A>    val <A HREF="#IN_PTREE_OF_NUMSET-val">IN_PTREE_OF_NUMSET</A> : thm
<A NAME="line72"></A>    val <A HREF="#IN_PTREE_OF_NUMSET_EMPTY-val">IN_PTREE_OF_NUMSET_EMPTY</A> : thm
<A NAME="line73"></A>    val <A HREF="#IN_PTREE_REMOVE-val">IN_PTREE_REMOVE</A> : thm
<A NAME="line74"></A>    val <A HREF="#IN_PTREE_UNION_PTREE-val">IN_PTREE_UNION_PTREE</A> : thm
<A NAME="line75"></A>    val <A HREF="#IS_EMPTY_def-val">IS_EMPTY_def</A> : thm
<A NAME="line76"></A>    val <A HREF="#IS_EMPTY_ind-val">IS_EMPTY_ind</A> : thm
<A NAME="line77"></A>    val <A HREF="#IS_PTREE_BRANCH-val">IS_PTREE_BRANCH</A> : thm
<A NAME="line78"></A>    val <A HREF="#IS_PTREE_PEEK-val">IS_PTREE_PEEK</A> : thm
<A NAME="line79"></A>    val <A HREF="#KEYS_PEEK-val">KEYS_PEEK</A> : thm
<A NAME="line80"></A>    val <A HREF="#LIST_EQ-val">LIST_EQ</A> : thm
<A NAME="line81"></A>    val <A HREF="#MEM_ALL_DISTINCT_IMP_PERM-val">MEM_ALL_DISTINCT_IMP_PERM</A> : thm
<A NAME="line82"></A>    val <A HREF="#MEM_TRAVERSE-val">MEM_TRAVERSE</A> : thm
<A NAME="line83"></A>    val <A HREF="#MEM_TRAVERSE_INSERT_PTREE-val">MEM_TRAVERSE_INSERT_PTREE</A> : thm
<A NAME="line84"></A>    val <A HREF="#MEM_TRAVERSE_PEEK-val">MEM_TRAVERSE_PEEK</A> : thm
<A NAME="line85"></A>    val <A HREF="#MONO_EVERY_LEAF-val">MONO_EVERY_LEAF</A> : thm
<A NAME="line86"></A>    val <A HREF="#NOT_ADD_EMPTY-val">NOT_ADD_EMPTY</A> : thm
<A NAME="line87"></A>    val <A HREF="#NOT_KEY_LEFT_AND_RIGHT-val">NOT_KEY_LEFT_AND_RIGHT</A> : thm
<A NAME="line88"></A>    val <A HREF="#NUMSET_OF_PTREE_EMPTY-val">NUMSET_OF_PTREE_EMPTY</A> : thm
<A NAME="line89"></A>    val <A HREF="#NUMSET_OF_PTREE_PTREE_OF_NUMSET-val">NUMSET_OF_PTREE_PTREE_OF_NUMSET</A> : thm
<A NAME="line90"></A>    val <A HREF="#NUMSET_OF_PTREE_PTREE_OF_NUMSET_EMPTY-val">NUMSET_OF_PTREE_PTREE_OF_NUMSET_EMPTY</A> : thm
<A NAME="line91"></A>    val <A HREF="#PEEK_ADD-val">PEEK_ADD</A> : thm
<A NAME="line92"></A>    val <A HREF="#PEEK_INSERT_PTREE-val">PEEK_INSERT_PTREE</A> : thm
<A NAME="line93"></A>    val <A HREF="#PEEK_NONE-val">PEEK_NONE</A> : thm
<A NAME="line94"></A>    val <A HREF="#PEEK_REMOVE-val">PEEK_REMOVE</A> : thm
<A NAME="line95"></A>    val <A HREF="#PEEK_TRANSFORM-val">PEEK_TRANSFORM</A> : thm
<A NAME="line96"></A>    val <A HREF="#PEEK_def-val">PEEK_def</A> : thm
<A NAME="line97"></A>    val <A HREF="#PEEK_ind-val">PEEK_ind</A> : thm
<A NAME="line98"></A>    val <A HREF="#PERM_ADD-val">PERM_ADD</A> : thm
<A NAME="line99"></A>    val <A HREF="#PERM_DELETE_PTREE-val">PERM_DELETE_PTREE</A> : thm
<A NAME="line100"></A>    val <A HREF="#PERM_INSERT_PTREE-val">PERM_INSERT_PTREE</A> : thm
<A NAME="line101"></A>    val <A HREF="#PERM_NOT_ADD-val">PERM_NOT_ADD</A> : thm
<A NAME="line102"></A>    val <A HREF="#PERM_NOT_REMOVE-val">PERM_NOT_REMOVE</A> : thm
<A NAME="line103"></A>    val <A HREF="#PERM_REMOVE-val">PERM_REMOVE</A> : thm
<A NAME="line104"></A>    val <A HREF="#PTREE_EQ-val">PTREE_EQ</A> : thm
<A NAME="line105"></A>    val <A HREF="#PTREE_EXTENSION-val">PTREE_EXTENSION</A> : thm
<A NAME="line106"></A>    val <A HREF="#PTREE_OF_NUMSET_DELETE-val">PTREE_OF_NUMSET_DELETE</A> : thm
<A NAME="line107"></A>    val <A HREF="#PTREE_OF_NUMSET_EMPTY-val">PTREE_OF_NUMSET_EMPTY</A> : thm
<A NAME="line108"></A>    val <A HREF="#PTREE_OF_NUMSET_INSERT-val">PTREE_OF_NUMSET_INSERT</A> : thm
<A NAME="line109"></A>    val <A HREF="#PTREE_OF_NUMSET_INSERT_EMPTY-val">PTREE_OF_NUMSET_INSERT_EMPTY</A> : thm
<A NAME="line110"></A>    val <A HREF="#PTREE_OF_NUMSET_IS_PTREE-val">PTREE_OF_NUMSET_IS_PTREE</A> : thm
<A NAME="line111"></A>    val <A HREF="#PTREE_OF_NUMSET_IS_PTREE_EMPTY-val">PTREE_OF_NUMSET_IS_PTREE_EMPTY</A> : thm
<A NAME="line112"></A>    val <A HREF="#PTREE_OF_NUMSET_NUMSET_OF_PTREE-val">PTREE_OF_NUMSET_NUMSET_OF_PTREE</A> : thm
<A NAME="line113"></A>    val <A HREF="#PTREE_OF_NUMSET_UNION-val">PTREE_OF_NUMSET_UNION</A> : thm
<A NAME="line114"></A>    val <A HREF="#PTREE_TRAVERSE_EQ-val">PTREE_TRAVERSE_EQ</A> : thm
<A NAME="line115"></A>    val <A HREF="#QSORT_MEM_EQ-val">QSORT_MEM_EQ</A> : thm
<A NAME="line116"></A>    val <A HREF="#REMOVE_ADD-val">REMOVE_ADD</A> : thm
<A NAME="line117"></A>    val <A HREF="#REMOVE_ADD_EQ-val">REMOVE_ADD_EQ</A> : thm
<A NAME="line118"></A>    val <A HREF="#REMOVE_IS_PTREE-val">REMOVE_IS_PTREE</A> : thm
<A NAME="line119"></A>    val <A HREF="#REMOVE_REMOVE-val">REMOVE_REMOVE</A> : thm
<A NAME="line120"></A>    val <A HREF="#REMOVE_TRANSFORM-val">REMOVE_TRANSFORM</A> : thm
<A NAME="line121"></A>    val <A HREF="#SIZE-val">SIZE</A> : thm
<A NAME="line122"></A>    val <A HREF="#SIZE_ADD-val">SIZE_ADD</A> : thm
<A NAME="line123"></A>    val <A HREF="#SIZE_PTREE_OF_NUMSET-val">SIZE_PTREE_OF_NUMSET</A> : thm
<A NAME="line124"></A>    val <A HREF="#SIZE_PTREE_OF_NUMSET_EMPTY-val">SIZE_PTREE_OF_NUMSET_EMPTY</A> : thm
<A NAME="line125"></A>    val <A HREF="#SIZE_REMOVE-val">SIZE_REMOVE</A> : thm
<A NAME="line126"></A>    val <A HREF="#TRANSFORM_BRANCH-val">TRANSFORM_BRANCH</A> : thm
<A NAME="line127"></A>    val <A HREF="#TRANSFORM_EMPTY-val">TRANSFORM_EMPTY</A> : thm
<A NAME="line128"></A>    val <A HREF="#TRANSFORM_IS_PTREE-val">TRANSFORM_IS_PTREE</A> : thm
<A NAME="line129"></A>    val <A HREF="#TRAVERSE_AUX-val">TRAVERSE_AUX</A> : thm
<A NAME="line130"></A>    val <A HREF="#TRAVERSE_TRANSFORM-val">TRAVERSE_TRANSFORM</A> : thm
<A NAME="line131"></A>    val <A HREF="#UNION_PTREE_ASSOC-val">UNION_PTREE_ASSOC</A> : thm
<A NAME="line132"></A>    val <A HREF="#UNION_PTREE_COMM-val">UNION_PTREE_COMM</A> : thm
<A NAME="line133"></A>    val <A HREF="#UNION_PTREE_COMM_EMPTY-val">UNION_PTREE_COMM_EMPTY</A> : thm
<A NAME="line134"></A>    val <A HREF="#UNION_PTREE_EMPTY-val">UNION_PTREE_EMPTY</A> : thm
<A NAME="line135"></A>    val <A HREF="#UNION_PTREE_IS_PTREE-val">UNION_PTREE_IS_PTREE</A> : thm
<A NAME="line136"></A>    val <A HREF="#datatype_ptree-val">datatype_ptree</A> : thm
<A NAME="line137"></A>    val <A HREF="#ptree_11-val">ptree_11</A> : thm
<A NAME="line138"></A>    val <A HREF="#ptree_Axiom-val">ptree_Axiom</A> : thm
<A NAME="line139"></A>    val <A HREF="#ptree_case_cong-val">ptree_case_cong</A> : thm
<A NAME="line140"></A>    val <A HREF="#ptree_distinct-val">ptree_distinct</A> : thm
<A NAME="line141"></A>    val <A HREF="#ptree_induction-val">ptree_induction</A> : thm
<A NAME="line142"></A>    val <A HREF="#ptree_nchotomy-val">ptree_nchotomy</A> : thm
<A NAME="line143"></A>  
<A NAME="line144"></A>  val patricia_grammars : type_grammar.grammar * term_grammar.grammar
<A NAME="line145"></A>  
<A NAME="line146"></A>  val patricia_rwts : simpLib.ssfrag
<A NAME="line147"></A>(*
   [sorting] Parent theory of "patricia"
   
   [words] Parent theory of "patricia"
   
   [<A NAME="ADD_LIST_def-val"><B>ADD_LIST_def</B></A>]  Definition
      
      |- $|++ = FOLDL $|+
   
   [<A NAME="ADD_curried_def-val"><B>ADD_curried_def</B></A>]  Definition
      
      |- !x x1. x |+ x1 = ADD_tupled (x,x1)
   
   [<A NAME="ADD_tupled_primitive_def-val"><B>ADD_tupled_primitive_def</B></A>]  Definition
      
      |- ADD_tupled =
         WFREC
           (@R.
              WF R /\
              (!l e r p k m.
                 MOD_2EXP_EQ m k p /\ ~BIT m k ==&gt;
                 R (r,k,e) (Branch p m l r,k,e)) /\
              !r e l p k m.
                MOD_2EXP_EQ m k p /\ BIT m k ==&gt;
                R (l,k,e) (Branch p m l r,k,e))
           (\ADD_tupled a.
              case a of
                 (&lt;{}&gt;,k,e) -&gt; I (Leaf k e)
              || (Leaf j d,k',e') -&gt;
                   I
                     (if j = k' then
                        Leaf k' e'
                      else
                        JOIN (k',Leaf k' e',j,Leaf j d))
              || (Branch p m l r,k'',e'') -&gt;
                   I
                     (if MOD_2EXP_EQ m k'' p then
                        if BIT m k'' then
                          Branch p m (ADD_tupled (l,k'',e'')) r
                        else
                          Branch p m l (ADD_tupled (r,k'',e''))
                      else
                        JOIN (k'',Leaf k'' e'',p,Branch p m l r)))
   
   [<A NAME="BRANCHING_BIT_curried_def-val"><B>BRANCHING_BIT_curried_def</B></A>]  Definition
      
      |- !x x1. BRANCHING_BIT x x1 = BRANCHING_BIT_tupled (x,x1)
   
   [<A NAME="BRANCHING_BIT_tupled_primitive_def-val"><B>BRANCHING_BIT_tupled_primitive_def</B></A>]  Definition
      
      |- BRANCHING_BIT_tupled =
         WFREC
           (@R.
              WF R /\
              !p1 p0.
                ~((ODD p0 &lt;=&gt; EVEN p1) \/ (p0 = p1)) ==&gt;
                R (DIV2 p0,DIV2 p1) (p0,p1))
           (\BRANCHING_BIT_tupled a.
              case a of
                 (p0,p1) -&gt;
                   I
                     (if (ODD p0 &lt;=&gt; EVEN p1) \/ (p0 = p1) then
                        0
                      else
                        SUC (BRANCHING_BIT_tupled (DIV2 p0,DIV2 p1))))
   
   [<A NAME="BRANCH_primitive_def-val"><B>BRANCH_primitive_def</B></A>]  Definition
      
      |- BRANCH =
         WFREC (@R. WF R)
           (\BRANCH a.
              case a of
                 (v,v2,&lt;{}&gt;,&lt;{}&gt;) -&gt; I &lt;{}&gt;
              || (v,v2,&lt;{}&gt;,Leaf v36 v37) -&gt; I (Leaf v36 v37)
              || (v,v2,&lt;{}&gt;,Branch v38 v39 v40 v41) -&gt;
                   I (Branch v38 v39 v40 v41)
              || (v,v2,Leaf v18 v19,&lt;{}&gt;) -&gt; I (Leaf v18 v19)
              || (v,v2,Leaf v18 v19,Leaf v48 v49) -&gt;
                   I (Branch v v2 (Leaf v18 v19) (Leaf v48 v49))
              || (v,v2,Leaf v18 v19,Branch v50 v51 v52 v53) -&gt;
                   I (Branch v v2 (Leaf v18 v19) (Branch v50 v51 v52 v53))
              || (v,v2,Branch v20 v21 v22 v23,&lt;{}&gt;) -&gt;
                   I (Branch v20 v21 v22 v23)
              || (v,v2,Branch v20 v21 v22 v23,Leaf v60 v61) -&gt;
                   I (Branch v v2 (Branch v20 v21 v22 v23) (Leaf v60 v61))
              || (v,v2,Branch v20 v21 v22 v23,Branch v62 v63 v64 v65) -&gt;
                   I
                     (Branch v v2 (Branch v20 v21 v22 v23)
                        (Branch v62 v63 v64 v65)))
   
   [<A NAME="DEPTH_def-val"><B>DEPTH_def</B></A>]  Definition
      
      |- (DEPTH &lt;{}&gt; = 0) /\ (!j d. DEPTH (Leaf j d) = 1) /\
         !p m l r. DEPTH (Branch p m l r) = 1 + MAX (DEPTH l) (DEPTH r)
   
   [<A NAME="EVERY_LEAF_def-val"><B>EVERY_LEAF_def</B></A>]  Definition
      
      |- (!P. EVERY_LEAF P &lt;{}&gt; &lt;=&gt; T) /\
         (!P j d. EVERY_LEAF P (Leaf j d) &lt;=&gt; P j d) /\
         !P p m l r.
           EVERY_LEAF P (Branch p m l r) &lt;=&gt;
           EVERY_LEAF P l /\ EVERY_LEAF P r
   
   [<A NAME="EXISTS_LEAF_def-val"><B>EXISTS_LEAF_def</B></A>]  Definition
      
      |- (!P. EXISTS_LEAF P &lt;{}&gt; &lt;=&gt; F) /\
         (!P j d. EXISTS_LEAF P (Leaf j d) &lt;=&gt; P j d) /\
         !P p m l r.
           EXISTS_LEAF P (Branch p m l r) &lt;=&gt;
           EXISTS_LEAF P l \/ EXISTS_LEAF P r
   
   [<A NAME="FIND_def-val"><B>FIND_def</B></A>]  Definition
      
      |- !t k. FIND t k = THE (t ' k)
   
   [<A NAME="INSERT_PTREE_def-val"><B>INSERT_PTREE_def</B></A>]  Definition
      
      |- !n t. n INSERT_PTREE t = t |+ (n,())
   
   [<A NAME="IN_PTREE_def-val"><B>IN_PTREE_def</B></A>]  Definition
      
      |- !n t. n IN_PTREE t &lt;=&gt; IS_SOME (t ' n)
   
   [<A NAME="IS_EMPTY_primitive_def-val"><B>IS_EMPTY_primitive_def</B></A>]  Definition
      
      |- IS_EMPTY =
         WFREC (@R. WF R)
           (\IS_EMPTY a.
              case a of
                 &lt;{}&gt; -&gt; I T
              || Leaf v6 v7 -&gt; I F
              || Branch v8 v9 v10 v11 -&gt; I F)
   
   [<A NAME="IS_PTREE_def-val"><B>IS_PTREE_def</B></A>]  Definition
      
      |- (IS_PTREE &lt;{}&gt; &lt;=&gt; T) /\ (!k d. IS_PTREE (Leaf k d) &lt;=&gt; T) /\
         !p m l r.
           IS_PTREE (Branch p m l r) &lt;=&gt;
           p &lt; 2 ** m /\ IS_PTREE l /\ IS_PTREE r /\ l &lt;&gt; &lt;{}&gt; /\
           r &lt;&gt; &lt;{}&gt; /\
           EVERY_LEAF (\k d. MOD_2EXP_EQ m k p /\ BIT m k) l /\
           EVERY_LEAF (\k d. MOD_2EXP_EQ m k p /\ ~BIT m k) r
   
   [<A NAME="JOIN_def-val"><B>JOIN_def</B></A>]  Definition
      
      |- !p0 t0 p1 t1.
           JOIN (p0,t0,p1,t1) =
           (let m = BRANCHING_BIT p0 p1 in
              if BIT m p0 then
                Branch (MOD_2EXP m p0) m t0 t1
              else
                Branch (MOD_2EXP m p0) m t1 t0)
   
   [<A NAME="KEYS_def-val"><B>KEYS_def</B></A>]  Definition
      
      |- !t. KEYS t = QSORT $&lt; (TRAVERSE t)
   
   [<A NAME="NUMSET_OF_PTREE_def-val"><B>NUMSET_OF_PTREE_def</B></A>]  Definition
      
      |- !t. NUMSET_OF_PTREE t = LIST_TO_SET (TRAVERSE t)
   
   [<A NAME="PEEK_curried_def-val"><B>PEEK_curried_def</B></A>]  Definition
      
      |- !x x1. x ' x1 = PEEK_tupled (x,x1)
   
   [<A NAME="PEEK_tupled_primitive_def-val"><B>PEEK_tupled_primitive_def</B></A>]  Definition
      
      |- PEEK_tupled =
         WFREC
           (@R.
              WF R /\
              !p r l k m.
                R (if BIT m k then l else r,k) (Branch p m l r,k))
           (\PEEK_tupled a.
              case a of
                 (&lt;{}&gt;,k) -&gt; I NONE
              || (Leaf j d,k) -&gt; I (if k = j then SOME d else NONE)
              || (Branch p m l r,k) -&gt;
                   I (PEEK_tupled (if BIT m k then l else r,k)))
   
   [<A NAME="PTREE_OF_NUMSET_def-val"><B>PTREE_OF_NUMSET_def</B></A>]  Definition
      
      |- !t s. t |++ s = FOLDL (combin$C $INSERT_PTREE) t (SET_TO_LIST s)
   
   [<A NAME="REMOVE_def-val"><B>REMOVE_def</B></A>]  Definition
      
      |- (!k. &lt;{}&gt; \\ k = &lt;{}&gt;) /\
         (!j d k. Leaf j d \\ k = if j = k then &lt;{}&gt; else Leaf j d) /\
         !p m l r k.
           Branch p m l r \\ k =
           if MOD_2EXP_EQ m k p then
             if BIT m k then
               BRANCH (p,m,l \\ k,r)
             else
               BRANCH (p,m,l,r \\ k)
           else
             Branch p m l r
   
   [<A NAME="SIZE_def-val"><B>SIZE_def</B></A>]  Definition
      
      |- !t. SIZE t = LENGTH (TRAVERSE t)
   
   [<A NAME="TRANSFORM_def-val"><B>TRANSFORM_def</B></A>]  Definition
      
      |- (!f. TRANSFORM f &lt;{}&gt; = &lt;{}&gt;) /\
         (!f j d. TRANSFORM f (Leaf j d) = Leaf j (f d)) /\
         !f p m l r.
           TRANSFORM f (Branch p m l r) =
           Branch p m (TRANSFORM f l) (TRANSFORM f r)
   
   [<A NAME="TRAVERSE_AUX_def-val"><B>TRAVERSE_AUX_def</B></A>]  Definition
      
      |- (!a. TRAVERSE_AUX &lt;{}&gt; a = a) /\
         (!k d a. TRAVERSE_AUX (Leaf k d) a = k::a) /\
         !p m l r a.
           TRAVERSE_AUX (Branch p m l r) a =
           TRAVERSE_AUX l (TRAVERSE_AUX r a)
   
   [<A NAME="TRAVERSE_def-val"><B>TRAVERSE_def</B></A>]  Definition
      
      |- (TRAVERSE &lt;{}&gt; = []) /\ (!j d. TRAVERSE (Leaf j d) = [j]) /\
         !p m l r. TRAVERSE (Branch p m l r) = TRAVERSE l ++ TRAVERSE r
   
   [<A NAME="UNION_PTREE_def-val"><B>UNION_PTREE_def</B></A>]  Definition
      
      |- !t1 t2. t1 UNION_PTREE t2 = t1 |++ NUMSET_OF_PTREE t2
   
   [<A NAME="ptree_TY_DEF-val"><B>ptree_TY_DEF</B></A>]  Definition
      
      |- ?rep.
           TYPE_DEFINITION
             (\a0'.
                !'ptree' .
                  (!a0'.
                     (a0' =
                      ind_type$CONSTR 0 (ARB,ARB,ARB)
                        (\n. ind_type$BOTTOM)) \/
                     (?a0 a1.
                        a0' =
                        (\a0 a1.
                           ind_type$CONSTR (SUC 0) (a0,a1,ARB)
                             (\n. ind_type$BOTTOM)) a0 a1) \/
                     (?a0 a1 a2 a3.
                        (a0' =
                         (\a0 a1 a2 a3.
                            ind_type$CONSTR (SUC (SUC 0)) (a0,ARB,a1)
                              (ind_type$FCONS a2
                                 (ind_type$FCONS a3
                                    (\n. ind_type$BOTTOM)))) a0 a1 a2
                           a3) /\ 'ptree' a2 /\ 'ptree' a3) ==&gt;
                     'ptree' a0') ==&gt;
                  'ptree' a0') rep
   
   [<A NAME="ptree_case_def-val"><B>ptree_case_def</B></A>]  Definition
      
      |- (!v f f1. ptree_case v f f1 &lt;{}&gt; = v) /\
         (!v f f1 a0 a1. ptree_case v f f1 (Leaf a0 a1) = f a0 a1) /\
         !v f f1 a0 a1 a2 a3.
           ptree_case v f f1 (Branch a0 a1 a2 a3) = f1 a0 a1 a2 a3
   
   [<A NAME="ptree_repfns-val"><B>ptree_repfns</B></A>]  Definition
      
      |- (!a. mk_ptree (dest_ptree a) = a) /\
         !r.
           (\a0'.
              !'ptree' .
                (!a0'.
                   (a0' =
                    ind_type$CONSTR 0 (ARB,ARB,ARB)
                      (\n. ind_type$BOTTOM)) \/
                   (?a0 a1.
                      a0' =
                      (\a0 a1.
                         ind_type$CONSTR (SUC 0) (a0,a1,ARB)
                           (\n. ind_type$BOTTOM)) a0 a1) \/
                   (?a0 a1 a2 a3.
                      (a0' =
                       (\a0 a1 a2 a3.
                          ind_type$CONSTR (SUC (SUC 0)) (a0,ARB,a1)
                            (ind_type$FCONS a2
                               (ind_type$FCONS a3 (\n. ind_type$BOTTOM))))
                         a0 a1 a2 a3) /\ 'ptree' a2 /\ 'ptree' a3) ==&gt;
                   'ptree' a0') ==&gt;
                'ptree' a0') r &lt;=&gt; (dest_ptree (mk_ptree r) = r)
   
   [<A NAME="ptree_size_def-val"><B>ptree_size_def</B></A>]  Definition
      
      |- (!f. ptree_size f &lt;{}&gt; = 0) /\
         (!f a0 a1. ptree_size f (Leaf a0 a1) = 1 + (a0 + f a1)) /\
         !f a0 a1 a2 a3.
           ptree_size f (Branch a0 a1 a2 a3) =
           1 + (a0 + (a1 + (ptree_size f a2 + ptree_size f a3)))
   
   [<A NAME="ADD_ADD-val"><B>ADD_ADD</B></A>]  Theorem
      
      |- !t k d e. t |+ (k,d) |+ (k,e) = t |+ (k,e)
   
   [<A NAME="ADD_ADD_SYM-val"><B>ADD_ADD_SYM</B></A>]  Theorem
      
      |- !t k j d e.
           IS_PTREE t /\ k &lt;&gt; j ==&gt;
           (t |+ (k,d) |+ (j,e) = t |+ (j,e) |+ (k,d))
   
   [<A NAME="ADD_INSERT-val"><B>ADD_INSERT</B></A>]  Theorem
      
      |- !v t n. t |+ (n,v) = n INSERT_PTREE t
   
   [<A NAME="ADD_IS_PTREE-val"><B>ADD_IS_PTREE</B></A>]  Theorem
      
      |- !t x. IS_PTREE t ==&gt; IS_PTREE (t |+ x)
   
   [<A NAME="ADD_LIST_IS_PTREE-val"><B>ADD_LIST_IS_PTREE</B></A>]  Theorem
      
      |- !t l. IS_PTREE t ==&gt; IS_PTREE (t |++ l)
   
   [<A NAME="ADD_TRANSFORM-val"><B>ADD_TRANSFORM</B></A>]  Theorem
      
      |- !f t k d. TRANSFORM f (t |+ (k,d)) = TRANSFORM f t |+ (k,f d)
   
   [<A NAME="ADD_def-val"><B>ADD_def</B></A>]  Theorem
      
      |- (!k e. &lt;{}&gt; |+ (k,e) = Leaf k e) /\
         (!k j e d.
            Leaf j d |+ (k,e) =
            if j = k then Leaf k e else JOIN (k,Leaf k e,j,Leaf j d)) /\
         !r p m l k e.
           Branch p m l r |+ (k,e) =
           if MOD_2EXP_EQ m k p then
             if BIT m k then
               Branch p m (l |+ (k,e)) r
             else
               Branch p m l (r |+ (k,e))
           else
             JOIN (k,Leaf k e,p,Branch p m l r)
   
   [<A NAME="ADD_ind-val"><B>ADD_ind</B></A>]  Theorem
      
      |- !P.
           (!k e. P &lt;{}&gt; (k,e)) /\ (!j d k e. P (Leaf j d) (k,e)) /\
           (!p m l r k e.
              (MOD_2EXP_EQ m k p /\ ~BIT m k ==&gt; P r (k,e)) /\
              (MOD_2EXP_EQ m k p /\ BIT m k ==&gt; P l (k,e)) ==&gt;
              P (Branch p m l r) (k,e)) ==&gt;
           !v v1 v2. P v (v1,v2)
   
   [<A NAME="ALL_DISTINCT_TRAVERSE-val"><B>ALL_DISTINCT_TRAVERSE</B></A>]  Theorem
      
      |- !t. IS_PTREE t ==&gt; ALL_DISTINCT (TRAVERSE t)
   
   [<A NAME="BRANCH-val"><B>BRANCH</B></A>]  Theorem
      
      |- !k p m l r.
           BRANCH (p,m,l,r) =
           if l = &lt;{}&gt; then r else if r = &lt;{}&gt; then l else Branch p m l r
   
   [<A NAME="BRANCHING_BIT-val"><B>BRANCHING_BIT</B></A>]  Theorem
      
      |- !a b.
           a &lt;&gt; b ==&gt;
           (BIT (BRANCHING_BIT a b) a &lt;=/=&gt; BIT (BRANCHING_BIT a b) b)
   
   [<A NAME="BRANCHING_BIT_SYM-val"><B>BRANCHING_BIT_SYM</B></A>]  Theorem
      
      |- !a b. BRANCHING_BIT a b = BRANCHING_BIT b a
   
   [<A NAME="BRANCHING_BIT_ZERO-val"><B>BRANCHING_BIT_ZERO</B></A>]  Theorem
      
      |- !a b. (BRANCHING_BIT a b = 0) &lt;=&gt; (ODD a &lt;=&gt; EVEN b) \/ (a = b)
   
   [<A NAME="BRANCHING_BIT_def-val"><B>BRANCHING_BIT_def</B></A>]  Theorem
      
      |- BRANCHING_BIT p0 p1 =
         if (ODD p0 &lt;=&gt; EVEN p1) \/ (p0 = p1) then
           0
         else
           SUC (BRANCHING_BIT (DIV2 p0) (DIV2 p1))
   
   [<A NAME="BRANCHING_BIT_ind-val"><B>BRANCHING_BIT_ind</B></A>]  Theorem
      
      |- !P.
           (!p0 p1.
              (~((ODD p0 &lt;=&gt; EVEN p1) \/ (p0 = p1)) ==&gt;
               P (DIV2 p0) (DIV2 p1)) ==&gt;
              P p0 p1) ==&gt;
           !v v1. P v v1
   
   [<A NAME="BRANCH_def-val"><B>BRANCH_def</B></A>]  Theorem
      
      |- (BRANCH (p,m,&lt;{}&gt;,&lt;{}&gt;) = &lt;{}&gt;) /\
         (BRANCH (p,m,&lt;{}&gt;,Leaf v24 v25) = Leaf v24 v25) /\
         (BRANCH (p,m,&lt;{}&gt;,Branch v26 v27 v28 v29) =
          Branch v26 v27 v28 v29) /\
         (BRANCH (p,m,Leaf v6 v7,&lt;{}&gt;) = Leaf v6 v7) /\
         (BRANCH (p,m,Branch v8 v9 v10 v11,&lt;{}&gt;) = Branch v8 v9 v10 v11) /\
         (BRANCH (p,m,Leaf v12 v13,Leaf v42 v43) =
          Branch p m (Leaf v12 v13) (Leaf v42 v43)) /\
         (BRANCH (p,m,Leaf v12 v13,Branch v44 v45 v46 v47) =
          Branch p m (Leaf v12 v13) (Branch v44 v45 v46 v47)) /\
         (BRANCH (p,m,Branch v14 v15 v16 v17,Leaf v54 v55) =
          Branch p m (Branch v14 v15 v16 v17) (Leaf v54 v55)) /\
         (BRANCH (p,m,Branch v14 v15 v16 v17,Branch v56 v57 v58 v59) =
          Branch p m (Branch v14 v15 v16 v17) (Branch v56 v57 v58 v59))
   
   [<A NAME="BRANCH_ind-val"><B>BRANCH_ind</B></A>]  Theorem
      
      |- !P.
           (!p m. P (p,m,&lt;{}&gt;,&lt;{}&gt;)) /\
           (!p m v24 v25. P (p,m,&lt;{}&gt;,Leaf v24 v25)) /\
           (!p m v26 v27 v28 v29. P (p,m,&lt;{}&gt;,Branch v26 v27 v28 v29)) /\
           (!p m v6 v7. P (p,m,Leaf v6 v7,&lt;{}&gt;)) /\
           (!p m v8 v9 v10 v11. P (p,m,Branch v8 v9 v10 v11,&lt;{}&gt;)) /\
           (!p m v12 v13 v42 v43. P (p,m,Leaf v12 v13,Leaf v42 v43)) /\
           (!p m v12 v13 v44 v45 v46 v47.
              P (p,m,Leaf v12 v13,Branch v44 v45 v46 v47)) /\
           (!p m v14 v15 v16 v17 v54 v55.
              P (p,m,Branch v14 v15 v16 v17,Leaf v54 v55)) /\
           (!p m v14 v15 v16 v17 v56 v57 v58 v59.
              P (p,m,Branch v14 v15 v16 v17,Branch v56 v57 v58 v59)) ==&gt;
           !v v1 v2 v3. P (v,v1,v2,v3)
   
   [<A NAME="CARD_LIST_TO_SET-val"><B>CARD_LIST_TO_SET</B></A>]  Theorem
      
      |- !l. ALL_DISTINCT l ==&gt; (CARD (LIST_TO_SET l) = LENGTH l)
   
   [<A NAME="CARD_NUMSET_OF_PTREE-val"><B>CARD_NUMSET_OF_PTREE</B></A>]  Theorem
      
      |- !t. IS_PTREE t ==&gt; (CARD (NUMSET_OF_PTREE t) = SIZE t)
   
   [<A NAME="DELETE_UNION-val"><B>DELETE_UNION</B></A>]  Theorem
      
      |- !x s1 s2. s1 UNION s2 DELETE x = s1 DELETE x UNION (s2 DELETE x)
   
   [<A NAME="EMPTY_IS_PTREE-val"><B>EMPTY_IS_PTREE</B></A>]  Theorem
      
      |- IS_PTREE &lt;{}&gt;
   
   [<A NAME="EVERY_LEAF_ADD-val"><B>EVERY_LEAF_ADD</B></A>]  Theorem
      
      |- !P t k d. P k d /\ EVERY_LEAF P t ==&gt; EVERY_LEAF P (t |+ (k,d))
   
   [<A NAME="EVERY_LEAF_BRANCH-val"><B>EVERY_LEAF_BRANCH</B></A>]  Theorem
      
      |- !p m l r.
           EVERY_LEAF P (BRANCH (p,m,l,r)) &lt;=&gt;
           EVERY_LEAF P l /\ EVERY_LEAF P r
   
   [<A NAME="EVERY_LEAF_PEEK-val"><B>EVERY_LEAF_PEEK</B></A>]  Theorem
      
      |- !P t k. EVERY_LEAF P t /\ IS_SOME (t ' k) ==&gt; P k (THE (t ' k))
   
   [<A NAME="EVERY_LEAF_REMOVE-val"><B>EVERY_LEAF_REMOVE</B></A>]  Theorem
      
      |- !P t k. EVERY_LEAF P t ==&gt; EVERY_LEAF P (t \\ k)
   
   [<A NAME="EVERY_LEAF_TRANSFORM-val"><B>EVERY_LEAF_TRANSFORM</B></A>]  Theorem
      
      |- !P Q f t.
           (!k d. P k d ==&gt; Q k (f d)) /\ EVERY_LEAF P t ==&gt;
           EVERY_LEAF Q (TRANSFORM f t)
   
   [<A NAME="FILTER_ALL-val"><B>FILTER_ALL</B></A>]  Theorem
      
      |- !P l. (!n. n &lt; LENGTH l ==&gt; ~P (EL n l)) &lt;=&gt; (FILTER P l = [])
   
   [<A NAME="FILTER_NONE-val"><B>FILTER_NONE</B></A>]  Theorem
      
      |- !l. (!n. n &lt; LENGTH l ==&gt; P (EL n l)) ==&gt; (FILTER P l = l)
   
   [<A NAME="FINITE_NUMSET_OF_PTREE-val"><B>FINITE_NUMSET_OF_PTREE</B></A>]  Theorem
      
      |- !t. FINITE (NUMSET_OF_PTREE t)
   
   [<A NAME="INSERT_PTREE_IS_PTREE-val"><B>INSERT_PTREE_IS_PTREE</B></A>]  Theorem
      
      |- !t x. IS_PTREE t ==&gt; IS_PTREE (x INSERT_PTREE t)
   
   [<A NAME="IN_NUMSET_OF_PTREE-val"><B>IN_NUMSET_OF_PTREE</B></A>]  Theorem
      
      |- !t n. IS_PTREE t ==&gt; (n IN NUMSET_OF_PTREE t &lt;=&gt; n IN_PTREE t)
   
   [<A NAME="IN_PTREE_EMPTY-val"><B>IN_PTREE_EMPTY</B></A>]  Theorem
      
      |- !n. ~(n IN_PTREE &lt;{}&gt;)
   
   [<A NAME="IN_PTREE_INSERT_PTREE-val"><B>IN_PTREE_INSERT_PTREE</B></A>]  Theorem
      
      |- !t m n.
           IS_PTREE t ==&gt;
           (n IN_PTREE m INSERT_PTREE t &lt;=&gt; (m = n) \/ n IN_PTREE t)
   
   [<A NAME="IN_PTREE_OF_NUMSET-val"><B>IN_PTREE_OF_NUMSET</B></A>]  Theorem
      
      |- !t s n.
           IS_PTREE t /\ FINITE s ==&gt;
           (n IN_PTREE t |++ s &lt;=&gt; n IN_PTREE t \/ n IN s)
   
   [<A NAME="IN_PTREE_OF_NUMSET_EMPTY-val"><B>IN_PTREE_OF_NUMSET_EMPTY</B></A>]  Theorem
      
      |- !s n. FINITE s ==&gt; (n IN s &lt;=&gt; n IN_PTREE &lt;{}&gt; |++ s)
   
   [<A NAME="IN_PTREE_REMOVE-val"><B>IN_PTREE_REMOVE</B></A>]  Theorem
      
      |- !t m n.
           IS_PTREE t ==&gt; (n IN_PTREE t \\ m &lt;=&gt; n &lt;&gt; m /\ n IN_PTREE t)
   
   [<A NAME="IN_PTREE_UNION_PTREE-val"><B>IN_PTREE_UNION_PTREE</B></A>]  Theorem
      
      |- !t1 t2 n.
           IS_PTREE t1 /\ IS_PTREE t2 ==&gt;
           (n IN_PTREE t1 UNION_PTREE t2 &lt;=&gt;
            n IN_PTREE t1 \/ n IN_PTREE t2)
   
   [<A NAME="IS_EMPTY_def-val"><B>IS_EMPTY_def</B></A>]  Theorem
      
      |- (IS_EMPTY &lt;{}&gt; &lt;=&gt; T) /\ (IS_EMPTY (Leaf v v1) &lt;=&gt; F) /\
         (IS_EMPTY (Branch v2 v3 v4 v5) &lt;=&gt; F)
   
   [<A NAME="IS_EMPTY_ind-val"><B>IS_EMPTY_ind</B></A>]  Theorem
      
      |- !P.
           P &lt;{}&gt; /\ (!v v1. P (Leaf v v1)) /\
           (!v2 v3 v4 v5. P (Branch v2 v3 v4 v5)) ==&gt;
           !v. P v
   
   [<A NAME="IS_PTREE_BRANCH-val"><B>IS_PTREE_BRANCH</B></A>]  Theorem
      
      |- !p m l r.
           p &lt; 2 ** m /\ ~((l = &lt;{}&gt;) /\ (r = &lt;{}&gt;)) /\
           EVERY_LEAF (\k d. MOD_2EXP_EQ m k p /\ BIT m k) l /\
           EVERY_LEAF (\k d. MOD_2EXP_EQ m k p /\ ~BIT m k) r /\
           IS_PTREE l /\ IS_PTREE r ==&gt;
           IS_PTREE (BRANCH (p,m,l,r))
   
   [<A NAME="IS_PTREE_PEEK-val"><B>IS_PTREE_PEEK</B></A>]  Theorem
      
      |- (!k. ~IS_SOME (&lt;{}&gt; ' k)) /\
         (!k j b. IS_SOME (Leaf j b ' k) &lt;=&gt; (j = k)) /\
         !p m l r.
           IS_PTREE (Branch p m l r) ==&gt;
           (?k. BIT m k /\ IS_SOME (l ' k)) /\
           (?k. ~BIT m k /\ IS_SOME (r ' k)) /\
           !k n.
             ~MOD_2EXP_EQ m k p \/ n &lt; m /\ (BIT n p &lt;=/=&gt; BIT n k) ==&gt;
             ~IS_SOME (l ' k) /\ ~IS_SOME (r ' k)
   
   [<A NAME="KEYS_PEEK-val"><B>KEYS_PEEK</B></A>]  Theorem
      
      |- !t1 t2.
           IS_PTREE t1 /\ IS_PTREE t2 ==&gt;
           ((KEYS t1 = KEYS t2) &lt;=&gt; (TRAVERSE t1 = TRAVERSE t2))
   
   [<A NAME="LIST_EQ-val"><B>LIST_EQ</B></A>]  Theorem
      
      |- !a b.
           (LENGTH a = LENGTH b) /\
           (!x. x &lt; LENGTH a ==&gt; (EL x a = EL x b)) ==&gt;
           (a = b)
   
   [<A NAME="MEM_ALL_DISTINCT_IMP_PERM-val"><B>MEM_ALL_DISTINCT_IMP_PERM</B></A>]  Theorem
      
      |- !l1 l2.
           ALL_DISTINCT l1 /\ ALL_DISTINCT l2 /\
           (!x. MEM x l1 &lt;=&gt; MEM x l2) ==&gt;
           PERM l1 l2
   
   [<A NAME="MEM_TRAVERSE-val"><B>MEM_TRAVERSE</B></A>]  Theorem
      
      |- !t k.
           IS_PTREE t ==&gt; (MEM k (TRAVERSE t) &lt;=&gt; k IN NUMSET_OF_PTREE t)
   
   [<A NAME="MEM_TRAVERSE_INSERT_PTREE-val"><B>MEM_TRAVERSE_INSERT_PTREE</B></A>]  Theorem
      
      |- !t x.
           IS_PTREE t ==&gt;
           (MEM x (TRAVERSE (h INSERT_PTREE t)) &lt;=&gt;
            (x = h) \/ x &lt;&gt; h /\ MEM x (TRAVERSE t))
   
   [<A NAME="MEM_TRAVERSE_PEEK-val"><B>MEM_TRAVERSE_PEEK</B></A>]  Theorem
      
      |- !t k. IS_PTREE t ==&gt; (MEM k (TRAVERSE t) &lt;=&gt; IS_SOME (t ' k))
   
   [<A NAME="MONO_EVERY_LEAF-val"><B>MONO_EVERY_LEAF</B></A>]  Theorem
      
      |- !P Q t.
           (!k d. P k d ==&gt; Q k d) /\ EVERY_LEAF P t ==&gt; EVERY_LEAF Q t
   
   [<A NAME="NOT_ADD_EMPTY-val"><B>NOT_ADD_EMPTY</B></A>]  Theorem
      
      |- !t k d. t |+ (k,d) &lt;&gt; &lt;{}&gt;
   
   [<A NAME="NOT_KEY_LEFT_AND_RIGHT-val"><B>NOT_KEY_LEFT_AND_RIGHT</B></A>]  Theorem
      
      |- !p m l r k j.
           IS_PTREE (Branch p m l r) /\ IS_SOME (l ' k) /\
           IS_SOME (r ' j) ==&gt;
           k &lt;&gt; j
   
   [<A NAME="NUMSET_OF_PTREE_EMPTY-val"><B>NUMSET_OF_PTREE_EMPTY</B></A>]  Theorem
      
      |- NUMSET_OF_PTREE &lt;{}&gt; = {}
   
   [<A NAME="NUMSET_OF_PTREE_PTREE_OF_NUMSET-val"><B>NUMSET_OF_PTREE_PTREE_OF_NUMSET</B></A>]  Theorem
      
      |- !t s.
           IS_PTREE t /\ FINITE s ==&gt;
           (NUMSET_OF_PTREE (t |++ s) = NUMSET_OF_PTREE t UNION s)
   
   [<A NAME="NUMSET_OF_PTREE_PTREE_OF_NUMSET_EMPTY-val"><B>NUMSET_OF_PTREE_PTREE_OF_NUMSET_EMPTY</B></A>]  Theorem
      
      |- !s. FINITE s ==&gt; (NUMSET_OF_PTREE (&lt;{}&gt; |++ s) = s)
   
   [<A NAME="PEEK_ADD-val"><B>PEEK_ADD</B></A>]  Theorem
      
      |- !t k d.
           IS_PTREE t ==&gt;
           ((t |+ (k,d)) ' j = if k = j then SOME d else t ' j)
   
   [<A NAME="PEEK_INSERT_PTREE-val"><B>PEEK_INSERT_PTREE</B></A>]  Theorem
      
      |- !t j k d.
           IS_PTREE t ==&gt;
           ((k INSERT_PTREE t) ' j = if k = j then SOME () else t ' j)
   
   [<A NAME="PEEK_NONE-val"><B>PEEK_NONE</B></A>]  Theorem
      
      |- !P t k. (!d. ~P k d) /\ EVERY_LEAF P t ==&gt; (t ' k = NONE)
   
   [<A NAME="PEEK_REMOVE-val"><B>PEEK_REMOVE</B></A>]  Theorem
      
      |- !t k j d.
           IS_PTREE t ==&gt; ((t \\ k) ' j = if k = j then NONE else t ' j)
   
   [<A NAME="PEEK_TRANSFORM-val"><B>PEEK_TRANSFORM</B></A>]  Theorem
      
      |- !f t k.
           TRANSFORM f t ' k =
           case t ' k of NONE -&gt; NONE || SOME x -&gt; SOME (f x)
   
   [<A NAME="PEEK_def-val"><B>PEEK_def</B></A>]  Theorem
      
      |- (!k. &lt;{}&gt; ' k = NONE) /\
         (!k j d. Leaf j d ' k = if k = j then SOME d else NONE) /\
         !r p m l k. Branch p m l r ' k = (if BIT m k then l else r) ' k
   
   [<A NAME="PEEK_ind-val"><B>PEEK_ind</B></A>]  Theorem
      
      |- !P.
           (!k. P &lt;{}&gt; k) /\ (!j d k. P (Leaf j d) k) /\
           (!p m l r k.
              P (if BIT m k then l else r) k ==&gt; P (Branch p m l r) k) ==&gt;
           !v v1. P v v1
   
   [<A NAME="PERM_ADD-val"><B>PERM_ADD</B></A>]  Theorem
      
      |- !t k d.
           IS_PTREE t /\ ~MEM k (TRAVERSE t) ==&gt;
           PERM (TRAVERSE (t |+ (k,d))) (k::TRAVERSE t)
   
   [<A NAME="PERM_DELETE_PTREE-val"><B>PERM_DELETE_PTREE</B></A>]  Theorem
      
      |- !t k d.
           IS_PTREE t /\ MEM k (TRAVERSE t) ==&gt;
           PERM (TRAVERSE (t \\ k)) (FILTER (\x. x &lt;&gt; k) (TRAVERSE t))
   
   [<A NAME="PERM_INSERT_PTREE-val"><B>PERM_INSERT_PTREE</B></A>]  Theorem
      
      |- !t s.
           FINITE s ==&gt;
           IS_PTREE t ==&gt;
           PERM
             (TRAVERSE (FOLDL (combin$C $INSERT_PTREE) t (SET_TO_LIST s)))
             (SET_TO_LIST (NUMSET_OF_PTREE t UNION s))
   
   [<A NAME="PERM_NOT_ADD-val"><B>PERM_NOT_ADD</B></A>]  Theorem
      
      |- !t k d.
           IS_PTREE t /\ MEM k (TRAVERSE t) ==&gt;
           (TRAVERSE (t |+ (k,d)) = TRAVERSE t)
   
   [<A NAME="PERM_NOT_REMOVE-val"><B>PERM_NOT_REMOVE</B></A>]  Theorem
      
      |- !t k.
           IS_PTREE t /\ ~MEM k (TRAVERSE t) ==&gt;
           (TRAVERSE (t \\ k) = TRAVERSE t)
   
   [<A NAME="PERM_REMOVE-val"><B>PERM_REMOVE</B></A>]  Theorem
      
      |- !t k d.
           IS_PTREE t /\ MEM k (TRAVERSE t) ==&gt;
           PERM (TRAVERSE (t \\ k)) (FILTER (\x. x &lt;&gt; k) (TRAVERSE t))
   
   [<A NAME="PTREE_EQ-val"><B>PTREE_EQ</B></A>]  Theorem
      
      |- !t1 t2.
           IS_PTREE t1 /\ IS_PTREE t2 ==&gt;
           ((!k. t1 ' k = t2 ' k) &lt;=&gt; (t1 = t2))
   
   [<A NAME="PTREE_EXTENSION-val"><B>PTREE_EXTENSION</B></A>]  Theorem
      
      |- !t1 t2.
           IS_PTREE t1 /\ IS_PTREE t2 ==&gt;
           ((t1 = t2) &lt;=&gt; !x. x IN_PTREE t1 &lt;=&gt; x IN_PTREE t2)
   
   [<A NAME="PTREE_OF_NUMSET_DELETE-val"><B>PTREE_OF_NUMSET_DELETE</B></A>]  Theorem
      
      |- !s x. FINITE s ==&gt; (&lt;{}&gt; |++ (s DELETE x) = (&lt;{}&gt; |++ s) \\ x)
   
   [<A NAME="PTREE_OF_NUMSET_EMPTY-val"><B>PTREE_OF_NUMSET_EMPTY</B></A>]  Theorem
      
      |- !t. t |++ {} = t
   
   [<A NAME="PTREE_OF_NUMSET_INSERT-val"><B>PTREE_OF_NUMSET_INSERT</B></A>]  Theorem
      
      |- !t s x.
           IS_PTREE t /\ FINITE s ==&gt;
           (t |++ (x INSERT s) = x INSERT_PTREE t |++ s)
   
   [<A NAME="PTREE_OF_NUMSET_INSERT_EMPTY-val"><B>PTREE_OF_NUMSET_INSERT_EMPTY</B></A>]  Theorem
      
      |- !s x.
           FINITE s ==&gt; (&lt;{}&gt; |++ (x INSERT s) = x INSERT_PTREE &lt;{}&gt; |++ s)
   
   [<A NAME="PTREE_OF_NUMSET_IS_PTREE-val"><B>PTREE_OF_NUMSET_IS_PTREE</B></A>]  Theorem
      
      |- !t s. IS_PTREE t ==&gt; IS_PTREE (t |++ s)
   
   [<A NAME="PTREE_OF_NUMSET_IS_PTREE_EMPTY-val"><B>PTREE_OF_NUMSET_IS_PTREE_EMPTY</B></A>]  Theorem
      
      |- !s. IS_PTREE (&lt;{}&gt; |++ s)
   
   [<A NAME="PTREE_OF_NUMSET_NUMSET_OF_PTREE-val"><B>PTREE_OF_NUMSET_NUMSET_OF_PTREE</B></A>]  Theorem
      
      |- !s n.
           IS_PTREE t /\ FINITE s ==&gt;
           (&lt;{}&gt; |++ (NUMSET_OF_PTREE t UNION s) = t |++ s)
   
   [<A NAME="PTREE_OF_NUMSET_UNION-val"><B>PTREE_OF_NUMSET_UNION</B></A>]  Theorem
      
      |- !t s1 s2.
           IS_PTREE t /\ FINITE s1 /\ FINITE s2 ==&gt;
           (t |++ (s1 UNION s2) = t |++ s1 |++ s2)
   
   [<A NAME="PTREE_TRAVERSE_EQ-val"><B>PTREE_TRAVERSE_EQ</B></A>]  Theorem
      
      |- !t1 t2.
           IS_PTREE t1 /\ IS_PTREE t2 ==&gt;
           ((!k. MEM k (TRAVERSE t1) &lt;=&gt; MEM k (TRAVERSE t2)) &lt;=&gt;
            (TRAVERSE t1 = TRAVERSE t2))
   
   [<A NAME="QSORT_MEM_EQ-val"><B>QSORT_MEM_EQ</B></A>]  Theorem
      
      |- !l2 l1 R. (QSORT R l1 = QSORT R l2) ==&gt; !x. MEM x l1 &lt;=&gt; MEM x l2
   
   [<A NAME="REMOVE_ADD-val"><B>REMOVE_ADD</B></A>]  Theorem
      
      |- !t k d.
           IS_PTREE t ==&gt;
           (t |+ (k,d) \\ j = if k = j then t \\ j else t \\ j |+ (k,d))
   
   [<A NAME="REMOVE_ADD_EQ-val"><B>REMOVE_ADD_EQ</B></A>]  Theorem
      
      |- !t k d. t |+ (k,d) \\ k = t \\ k
   
   [<A NAME="REMOVE_IS_PTREE-val"><B>REMOVE_IS_PTREE</B></A>]  Theorem
      
      |- !t k. IS_PTREE t ==&gt; IS_PTREE (t \\ k)
   
   [<A NAME="REMOVE_REMOVE-val"><B>REMOVE_REMOVE</B></A>]  Theorem
      
      |- !t k. IS_PTREE t ==&gt; (t \\ k \\ k = t \\ k)
   
   [<A NAME="REMOVE_TRANSFORM-val"><B>REMOVE_TRANSFORM</B></A>]  Theorem
      
      |- !f t k. TRANSFORM f (t \\ k) = TRANSFORM f t \\ k
   
   [<A NAME="SIZE-val"><B>SIZE</B></A>]  Theorem
      
      |- (SIZE &lt;{}&gt; = 0) /\ (!k d. SIZE (Leaf k d) = 1) /\
         !p m l r. SIZE (Branch p m l r) = SIZE l + SIZE r
   
   [<A NAME="SIZE_ADD-val"><B>SIZE_ADD</B></A>]  Theorem
      
      |- !t k d.
           IS_PTREE t ==&gt;
           (SIZE (t |+ (k,d)) =
            if MEM k (TRAVERSE t) then SIZE t else SIZE t + 1)
   
   [<A NAME="SIZE_PTREE_OF_NUMSET-val"><B>SIZE_PTREE_OF_NUMSET</B></A>]  Theorem
      
      |- !t s.
           FINITE s ==&gt;
           IS_PTREE t /\ ALL_DISTINCT (TRAVERSE t ++ SET_TO_LIST s) ==&gt;
           (SIZE (t |++ s) = SIZE t + CARD s)
   
   [<A NAME="SIZE_PTREE_OF_NUMSET_EMPTY-val"><B>SIZE_PTREE_OF_NUMSET_EMPTY</B></A>]  Theorem
      
      |- !s. FINITE s ==&gt; (SIZE (&lt;{}&gt; |++ s) = CARD s)
   
   [<A NAME="SIZE_REMOVE-val"><B>SIZE_REMOVE</B></A>]  Theorem
      
      |- !t k d.
           IS_PTREE t ==&gt;
           (SIZE (t \\ k) =
            if MEM k (TRAVERSE t) then SIZE t - 1 else SIZE t)
   
   [<A NAME="TRANSFORM_BRANCH-val"><B>TRANSFORM_BRANCH</B></A>]  Theorem
      
      |- !f p m l r.
           TRANSFORM f (BRANCH (p,m,l,r)) =
           BRANCH (p,m,TRANSFORM f l,TRANSFORM f r)
   
   [<A NAME="TRANSFORM_EMPTY-val"><B>TRANSFORM_EMPTY</B></A>]  Theorem
      
      |- !f t. (TRANSFORM f t = &lt;{}&gt;) &lt;=&gt; (t = &lt;{}&gt;)
   
   [<A NAME="TRANSFORM_IS_PTREE-val"><B>TRANSFORM_IS_PTREE</B></A>]  Theorem
      
      |- !f t. IS_PTREE t ==&gt; IS_PTREE (TRANSFORM f t)
   
   [<A NAME="TRAVERSE_AUX-val"><B>TRAVERSE_AUX</B></A>]  Theorem
      
      |- !t. TRAVERSE t = TRAVERSE_AUX t []
   
   [<A NAME="TRAVERSE_TRANSFORM-val"><B>TRAVERSE_TRANSFORM</B></A>]  Theorem
      
      |- !f t. TRAVERSE (TRANSFORM f t) = TRAVERSE t
   
   [<A NAME="UNION_PTREE_ASSOC-val"><B>UNION_PTREE_ASSOC</B></A>]  Theorem
      
      |- !t1 t2 t3.
           IS_PTREE t1 /\ IS_PTREE t2 /\ IS_PTREE t3 ==&gt;
           (t1 UNION_PTREE (t2 UNION_PTREE t3) =
            t1 UNION_PTREE t2 UNION_PTREE t3)
   
   [<A NAME="UNION_PTREE_COMM-val"><B>UNION_PTREE_COMM</B></A>]  Theorem
      
      |- !t1 t2.
           IS_PTREE t1 /\ IS_PTREE t2 ==&gt;
           (t1 UNION_PTREE t2 = t2 UNION_PTREE t1)
   
   [<A NAME="UNION_PTREE_COMM_EMPTY-val"><B>UNION_PTREE_COMM_EMPTY</B></A>]  Theorem
      
      |- !t. IS_PTREE t ==&gt; (&lt;{}&gt; UNION_PTREE t = t UNION_PTREE &lt;{}&gt;)
   
   [<A NAME="UNION_PTREE_EMPTY-val"><B>UNION_PTREE_EMPTY</B></A>]  Theorem
      
      |- (!t. t UNION_PTREE &lt;{}&gt; = t) /\
         !t. IS_PTREE t ==&gt; (&lt;{}&gt; UNION_PTREE t = t)
   
   [<A NAME="UNION_PTREE_IS_PTREE-val"><B>UNION_PTREE_IS_PTREE</B></A>]  Theorem
      
      |- !t1 t2.
           IS_PTREE t1 /\ IS_PTREE t2 ==&gt; IS_PTREE (t1 UNION_PTREE t2)
   
   [<A NAME="datatype_ptree-val"><B>datatype_ptree</B></A>]  Theorem
      
      |- DATATYPE (ptree &lt;{}&gt; Leaf Branch)
   
   [<A NAME="ptree_11-val"><B>ptree_11</B></A>]  Theorem
      
      |- (!a0 a1 a0' a1'.
            (Leaf a0 a1 = Leaf a0' a1') &lt;=&gt; (a0 = a0') /\ (a1 = a1')) /\
         !a0 a1 a2 a3 a0' a1' a2' a3'.
           (Branch a0 a1 a2 a3 = Branch a0' a1' a2' a3') &lt;=&gt;
           (a0 = a0') /\ (a1 = a1') /\ (a2 = a2') /\ (a3 = a3')
   
   [<A NAME="ptree_Axiom-val"><B>ptree_Axiom</B></A>]  Theorem
      
      |- !f0 f1 f2.
           ?fn.
             (fn &lt;{}&gt; = f0) /\ (!a0 a1. fn (Leaf a0 a1) = f1 a0 a1) /\
             !a0 a1 a2 a3.
               fn (Branch a0 a1 a2 a3) = f2 a0 a1 a2 a3 (fn a2) (fn a3)
   
   [<A NAME="ptree_case_cong-val"><B>ptree_case_cong</B></A>]  Theorem
      
      |- !M M' v f f1.
           (M = M') /\ ((M' = &lt;{}&gt;) ==&gt; (v = v')) /\
           (!a0 a1. (M' = Leaf a0 a1) ==&gt; (f a0 a1 = f' a0 a1)) /\
           (!a0 a1 a2 a3.
              (M' = Branch a0 a1 a2 a3) ==&gt;
              (f1 a0 a1 a2 a3 = f1' a0 a1 a2 a3)) ==&gt;
           (ptree_case v f f1 M = ptree_case v' f' f1' M')
   
   [<A NAME="ptree_distinct-val"><B>ptree_distinct</B></A>]  Theorem
      
      |- (!a1 a0. &lt;{}&gt; &lt;&gt; Leaf a0 a1) /\
         (!a3 a2 a1 a0. &lt;{}&gt; &lt;&gt; Branch a0 a1 a2 a3) /\
         !a3 a2 a1' a1 a0' a0. Leaf a0 a1 &lt;&gt; Branch a0' a1' a2 a3
   
   [<A NAME="ptree_induction-val"><B>ptree_induction</B></A>]  Theorem
      
      |- !P.
           P &lt;{}&gt; /\ (!n a. P (Leaf n a)) /\
           (!p p0. P p /\ P p0 ==&gt; !n n0. P (Branch n0 n p p0)) ==&gt;
           !p. P p
   
   [<A NAME="ptree_nchotomy-val"><B>ptree_nchotomy</B></A>]  Theorem
      
      |- !pp.
           (pp = &lt;{}&gt;) \/ (?n a. pp = Leaf n a) \/
           ?n0 n p p0. pp = Branch n0 n p p0
   
   
*)
end

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/patricia/patriciaScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
