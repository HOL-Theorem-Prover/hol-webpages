<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure sortingTheory</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure sortingTheory</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/sort/sortingScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>signature sortingTheory =
<A NAME="line2"></A>sig
<A NAME="line3"></A>  type thm = Thm.thm
<A NAME="line4"></A>  
<A NAME="line5"></A>  (*  Definitions  *)
<A NAME="line6"></A>    val <A HREF="#PARTITION_DEF-val">PARTITION_DEF</A> : thm
<A NAME="line7"></A>    val <A HREF="#PART_DEF-val">PART_DEF</A> : thm
<A NAME="line8"></A>    val <A HREF="#PERM_DEF-val">PERM_DEF</A> : thm
<A NAME="line9"></A>    val <A HREF="#PERM_SINGLE_SWAP_DEF-val">PERM_SINGLE_SWAP_DEF</A> : thm
<A NAME="line10"></A>    val <A HREF="#QSORT_curried_DEF-val">QSORT_curried_DEF</A> : thm
<A NAME="line11"></A>    val <A HREF="#QSORT_tupled_primitive_DEF-val">QSORT_tupled_primitive_DEF</A> : thm
<A NAME="line12"></A>    val <A HREF="#SORTED_curried_DEF-val">SORTED_curried_DEF</A> : thm
<A NAME="line13"></A>    val <A HREF="#SORTED_tupled_primitive_DEF-val">SORTED_tupled_primitive_DEF</A> : thm
<A NAME="line14"></A>    val <A HREF="#SORTS_DEF-val">SORTS_DEF</A> : thm
<A NAME="line15"></A>  
<A NAME="line16"></A>  (*  Theorems  *)
<A NAME="line17"></A>    val <A HREF="#ALL_DISTINCT_PERM-val">ALL_DISTINCT_PERM</A> : thm
<A NAME="line18"></A>    val <A HREF="#APPEND_PERM_SYM-val">APPEND_PERM_SYM</A> : thm
<A NAME="line19"></A>    val <A HREF="#CONS_PERM-val">CONS_PERM</A> : thm
<A NAME="line20"></A>    val <A HREF="#FOLDR_PERM-val">FOLDR_PERM</A> : thm
<A NAME="line21"></A>    val <A HREF="#PART_LENGTH-val">PART_LENGTH</A> : thm
<A NAME="line22"></A>    val <A HREF="#PART_LENGTH_LEM-val">PART_LENGTH_LEM</A> : thm
<A NAME="line23"></A>    val <A HREF="#PART_MEM-val">PART_MEM</A> : thm
<A NAME="line24"></A>    val <A HREF="#PARTs_HAVE_PROP-val">PARTs_HAVE_PROP</A> : thm
<A NAME="line25"></A>    val <A HREF="#PERM_ALL_DISTINCT-val">PERM_ALL_DISTINCT</A> : thm
<A NAME="line26"></A>    val <A HREF="#PERM_APPEND-val">PERM_APPEND</A> : thm
<A NAME="line27"></A>    val <A HREF="#PERM_APPEND_IFF-val">PERM_APPEND_IFF</A> : thm
<A NAME="line28"></A>    val <A HREF="#PERM_CONG-val">PERM_CONG</A> : thm
<A NAME="line29"></A>    val <A HREF="#PERM_CONG_2-val">PERM_CONG_2</A> : thm
<A NAME="line30"></A>    val <A HREF="#PERM_CONG_APPEND_IFF-val">PERM_CONG_APPEND_IFF</A> : thm
<A NAME="line31"></A>    val <A HREF="#PERM_CONS_EQ_APPEND-val">PERM_CONS_EQ_APPEND</A> : thm
<A NAME="line32"></A>    val <A HREF="#PERM_CONS_IFF-val">PERM_CONS_IFF</A> : thm
<A NAME="line33"></A>    val <A HREF="#PERM_EQC-val">PERM_EQC</A> : thm
<A NAME="line34"></A>    val <A HREF="#PERM_EQUIVALENCE-val">PERM_EQUIVALENCE</A> : thm
<A NAME="line35"></A>    val <A HREF="#PERM_EQUIVALENCE_ALT_DEF-val">PERM_EQUIVALENCE_ALT_DEF</A> : thm
<A NAME="line36"></A>    val <A HREF="#PERM_FILTER-val">PERM_FILTER</A> : thm
<A NAME="line37"></A>    val <A HREF="#PERM_FUN_APPEND-val">PERM_FUN_APPEND</A> : thm
<A NAME="line38"></A>    val <A HREF="#PERM_FUN_APPEND_APPEND_1-val">PERM_FUN_APPEND_APPEND_1</A> : thm
<A NAME="line39"></A>    val <A HREF="#PERM_FUN_APPEND_APPEND_2-val">PERM_FUN_APPEND_APPEND_2</A> : thm
<A NAME="line40"></A>    val <A HREF="#PERM_FUN_APPEND_CONS-val">PERM_FUN_APPEND_CONS</A> : thm
<A NAME="line41"></A>    val <A HREF="#PERM_FUN_APPEND_IFF-val">PERM_FUN_APPEND_IFF</A> : thm
<A NAME="line42"></A>    val <A HREF="#PERM_FUN_CONG-val">PERM_FUN_CONG</A> : thm
<A NAME="line43"></A>    val <A HREF="#PERM_FUN_CONS-val">PERM_FUN_CONS</A> : thm
<A NAME="line44"></A>    val <A HREF="#PERM_FUN_CONS_11_APPEND-val">PERM_FUN_CONS_11_APPEND</A> : thm
<A NAME="line45"></A>    val <A HREF="#PERM_FUN_CONS_11_SWAP_AT_FRONT-val">PERM_FUN_CONS_11_SWAP_AT_FRONT</A> : thm
<A NAME="line46"></A>    val <A HREF="#PERM_FUN_CONS_APPEND_1-val">PERM_FUN_CONS_APPEND_1</A> : thm
<A NAME="line47"></A>    val <A HREF="#PERM_FUN_CONS_APPEND_2-val">PERM_FUN_CONS_APPEND_2</A> : thm
<A NAME="line48"></A>    val <A HREF="#PERM_FUN_CONS_IFF-val">PERM_FUN_CONS_IFF</A> : thm
<A NAME="line49"></A>    val <A HREF="#PERM_FUN_SPLIT-val">PERM_FUN_SPLIT</A> : thm
<A NAME="line50"></A>    val <A HREF="#PERM_FUN_SWAP_AT_FRONT-val">PERM_FUN_SWAP_AT_FRONT</A> : thm
<A NAME="line51"></A>    val <A HREF="#PERM_IND-val">PERM_IND</A> : thm
<A NAME="line52"></A>    val <A HREF="#PERM_INTRO-val">PERM_INTRO</A> : thm
<A NAME="line53"></A>    val <A HREF="#PERM_LENGTH-val">PERM_LENGTH</A> : thm
<A NAME="line54"></A>    val <A HREF="#PERM_MAP-val">PERM_MAP</A> : thm
<A NAME="line55"></A>    val <A HREF="#PERM_MEM_EQ-val">PERM_MEM_EQ</A> : thm
<A NAME="line56"></A>    val <A HREF="#PERM_MONO-val">PERM_MONO</A> : thm
<A NAME="line57"></A>    val <A HREF="#PERM_NIL-val">PERM_NIL</A> : thm
<A NAME="line58"></A>    val <A HREF="#PERM_REFL-val">PERM_REFL</A> : thm
<A NAME="line59"></A>    val <A HREF="#PERM_REWR-val">PERM_REWR</A> : thm
<A NAME="line60"></A>    val <A HREF="#PERM_RTC-val">PERM_RTC</A> : thm
<A NAME="line61"></A>    val <A HREF="#PERM_SING-val">PERM_SING</A> : thm
<A NAME="line62"></A>    val <A HREF="#PERM_SINGLE_SWAP_REFL-val">PERM_SINGLE_SWAP_REFL</A> : thm
<A NAME="line63"></A>    val <A HREF="#PERM_SINGLE_SWAP_SYM-val">PERM_SINGLE_SWAP_SYM</A> : thm
<A NAME="line64"></A>    val <A HREF="#PERM_SPLIT-val">PERM_SPLIT</A> : thm
<A NAME="line65"></A>    val <A HREF="#PERM_SWAP_AT_FRONT-val">PERM_SWAP_AT_FRONT</A> : thm
<A NAME="line66"></A>    val <A HREF="#PERM_SYM-val">PERM_SYM</A> : thm
<A NAME="line67"></A>    val <A HREF="#PERM_TC-val">PERM_TC</A> : thm
<A NAME="line68"></A>    val <A HREF="#PERM_TRANS-val">PERM_TRANS</A> : thm
<A NAME="line69"></A>    val <A HREF="#PERM_lifts_equalities-val">PERM_lifts_equalities</A> : thm
<A NAME="line70"></A>    val <A HREF="#PERM_lifts_invariants-val">PERM_lifts_invariants</A> : thm
<A NAME="line71"></A>    val <A HREF="#PERM_lifts_monotonicities-val">PERM_lifts_monotonicities</A> : thm
<A NAME="line72"></A>    val <A HREF="#PERM_lifts_transitive_relations-val">PERM_lifts_transitive_relations</A> : thm
<A NAME="line73"></A>    val <A HREF="#PERM_transitive-val">PERM_transitive</A> : thm
<A NAME="line74"></A>    val <A HREF="#QSORT_DEF-val">QSORT_DEF</A> : thm
<A NAME="line75"></A>    val <A HREF="#QSORT_IND-val">QSORT_IND</A> : thm
<A NAME="line76"></A>    val <A HREF="#QSORT_MEM-val">QSORT_MEM</A> : thm
<A NAME="line77"></A>    val <A HREF="#QSORT_PERM-val">QSORT_PERM</A> : thm
<A NAME="line78"></A>    val <A HREF="#QSORT_SORTED-val">QSORT_SORTED</A> : thm
<A NAME="line79"></A>    val <A HREF="#QSORT_SORTS-val">QSORT_SORTS</A> : thm
<A NAME="line80"></A>    val <A HREF="#SORTED_APPEND-val">SORTED_APPEND</A> : thm
<A NAME="line81"></A>    val <A HREF="#SORTED_DEF-val">SORTED_DEF</A> : thm
<A NAME="line82"></A>    val <A HREF="#SORTED_EQ-val">SORTED_EQ</A> : thm
<A NAME="line83"></A>    val <A HREF="#SORTED_IND-val">SORTED_IND</A> : thm
<A NAME="line84"></A>  
<A NAME="line85"></A>  val sorting_grammars : type_grammar.grammar * term_grammar.grammar
<A NAME="line86"></A>  
<A NAME="line87"></A>  val sorting_rwts : simpLib.ssfrag
<A NAME="line88"></A>(*
   [list] Parent theory of "sorting"
   
   [<A NAME="PARTITION_DEF-val"><B>PARTITION_DEF</B></A>]  Definition
      
      |- !P l. PARTITION P l = PART P l [] []
   
   [<A NAME="PART_DEF-val"><B>PART_DEF</B></A>]  Definition
      
      |- (!P l1 l2. PART P [] l1 l2 = (l1,l2)) /\
         !P h rst l1 l2.
           PART P (h::rst) l1 l2 =
           if P h then PART P rst (h::l1) l2 else PART P rst l1 (h::l2)
   
   [<A NAME="PERM_DEF-val"><B>PERM_DEF</B></A>]  Definition
      
      |- !L1 L2. PERM L1 L2 &lt;=&gt; !x. FILTER ($= x) L1 = FILTER ($= x) L2
   
   [<A NAME="PERM_SINGLE_SWAP_DEF-val"><B>PERM_SINGLE_SWAP_DEF</B></A>]  Definition
      
      |- !l1 l2.
           PERM_SINGLE_SWAP l1 l2 &lt;=&gt;
           ?x1 x2 x3. (l1 = x1 ++ x2 ++ x3) /\ (l2 = x1 ++ x3 ++ x2)
   
   [<A NAME="QSORT_curried_DEF-val"><B>QSORT_curried_DEF</B></A>]  Definition
      
      |- !x x1. QSORT x x1 = QSORT_tupled (x,x1)
   
   [<A NAME="QSORT_tupled_primitive_DEF-val"><B>QSORT_tupled_primitive_DEF</B></A>]  Definition
      
      |- QSORT_tupled =
         WFREC
           (@R.
              WF R /\
              (!t h ord l1 l2.
                 ((l1,l2) = PARTITION (\y. ord y h) t) ==&gt;
                 R (ord,l2) (ord,h::t)) /\
              !t h ord l1 l2.
                ((l1,l2) = PARTITION (\y. ord y h) t) ==&gt;
                R (ord,l1) (ord,h::t))
           (\QSORT_tupled a.
              case a of
                 (ord,[]) -&gt; I []
              || (ord,h::t) -&gt;
                   I
                     (let (l1,l2) = PARTITION (\y. ord y h) t in
                        QSORT_tupled (ord,l1) ++ [h] ++
                        QSORT_tupled (ord,l2)))
   
   [<A NAME="SORTED_curried_DEF-val"><B>SORTED_curried_DEF</B></A>]  Definition
      
      |- !x x1. SORTED x x1 &lt;=&gt; SORTED_tupled (x,x1)
   
   [<A NAME="SORTED_tupled_primitive_DEF-val"><B>SORTED_tupled_primitive_DEF</B></A>]  Definition
      
      |- SORTED_tupled =
         WFREC (@R'. WF R' /\ !x rst y R. R' (R,y::rst) (R,x::y::rst))
           (\SORTED_tupled a.
              case a of
                 (R,[]) -&gt; I T
              || (R,[x]) -&gt; I T
              || (R,x::y::rst) -&gt; I (R x y /\ SORTED_tupled (R,y::rst)))
   
   [<A NAME="SORTS_DEF-val"><B>SORTS_DEF</B></A>]  Definition
      
      |- !f R. SORTS f R &lt;=&gt; !l. PERM l (f R l) /\ SORTED R (f R l)
   
   [<A NAME="ALL_DISTINCT_PERM-val"><B>ALL_DISTINCT_PERM</B></A>]  Theorem
      
      |- !l1 l2. PERM l1 l2 ==&gt; (ALL_DISTINCT l1 &lt;=&gt; ALL_DISTINCT l2)
   
   [<A NAME="APPEND_PERM_SYM-val"><B>APPEND_PERM_SYM</B></A>]  Theorem
      
      |- !A B C. PERM (A ++ B) C ==&gt; PERM (B ++ A) C
   
   [<A NAME="CONS_PERM-val"><B>CONS_PERM</B></A>]  Theorem
      
      |- !x L M N. PERM L (M ++ N) ==&gt; PERM (x::L) (M ++ x::N)
   
   [<A NAME="FOLDR_PERM-val"><B>FOLDR_PERM</B></A>]  Theorem
      
      |- !f l1 l2 e.
           ASSOC f /\ COMM f ==&gt;
           PERM l1 l2 ==&gt;
           (FOLDR f e l1 = FOLDR f e l2)
   
   [<A NAME="PART_LENGTH-val"><B>PART_LENGTH</B></A>]  Theorem
      
      |- !P L l1 l2 p q.
           ((p,q) = PART P L l1 l2) ==&gt;
           (LENGTH L + LENGTH l1 + LENGTH l2 = LENGTH p + LENGTH q)
   
   [<A NAME="PART_LENGTH_LEM-val"><B>PART_LENGTH_LEM</B></A>]  Theorem
      
      |- !P L l1 l2 p q.
           ((p,q) = PART P L l1 l2) ==&gt;
           LENGTH p &lt;= LENGTH L + LENGTH l1 + LENGTH l2 /\
           LENGTH q &lt;= LENGTH L + LENGTH l1 + LENGTH l2
   
   [<A NAME="PART_MEM-val"><B>PART_MEM</B></A>]  Theorem
      
      |- !P L a1 a2 l1 l2.
           ((a1,a2) = PART P L l1 l2) ==&gt;
           !x. MEM x (L ++ (l1 ++ l2)) &lt;=&gt; MEM x (a1 ++ a2)
   
   [<A NAME="PARTs_HAVE_PROP-val"><B>PARTs_HAVE_PROP</B></A>]  Theorem
      
      |- !P L A B l1 l2.
           ((A,B) = PART P L l1 l2) /\ (!x. MEM x l1 ==&gt; P x) /\
           (!x. MEM x l2 ==&gt; ~P x) ==&gt;
           (!z. MEM z A ==&gt; P z) /\ !z. MEM z B ==&gt; ~P z
   
   [<A NAME="PERM_ALL_DISTINCT-val"><B>PERM_ALL_DISTINCT</B></A>]  Theorem
      
      |- !l1 l2.
           ALL_DISTINCT l1 /\ ALL_DISTINCT l2 /\
           (!x. MEM x l1 &lt;=&gt; MEM x l2) ==&gt;
           PERM l1 l2
   
   [<A NAME="PERM_APPEND-val"><B>PERM_APPEND</B></A>]  Theorem
      
      |- !l1 l2. PERM (l1 ++ l2) (l2 ++ l1)
   
   [<A NAME="PERM_APPEND_IFF-val"><B>PERM_APPEND_IFF</B></A>]  Theorem
      
      |- (!l l1 l2. PERM (l ++ l1) (l ++ l2) &lt;=&gt; PERM l1 l2) /\
         !l l1 l2. PERM (l1 ++ l) (l2 ++ l) &lt;=&gt; PERM l1 l2
   
   [<A NAME="PERM_CONG-val"><B>PERM_CONG</B></A>]  Theorem
      
      |- !L1 L2 L3 L4.
           PERM L1 L3 /\ PERM L2 L4 ==&gt; PERM (L1 ++ L2) (L3 ++ L4)
   
   [<A NAME="PERM_CONG_2-val"><B>PERM_CONG_2</B></A>]  Theorem
      
      |- !l1 l1' l2 l2'.
           PERM l1 l1' ==&gt; PERM l2 l2' ==&gt; (PERM l1 l2 &lt;=&gt; PERM l1' l2')
   
   [<A NAME="PERM_CONG_APPEND_IFF-val"><B>PERM_CONG_APPEND_IFF</B></A>]  Theorem
      
      |- !l l1 l1' l2 l2'.
           PERM l1 (l ++ l1') ==&gt;
           PERM l2 (l ++ l2') ==&gt;
           (PERM l1 l2 &lt;=&gt; PERM l1' l2')
   
   [<A NAME="PERM_CONS_EQ_APPEND-val"><B>PERM_CONS_EQ_APPEND</B></A>]  Theorem
      
      |- !L h. PERM (h::t) L &lt;=&gt; ?M N. (L = M ++ h::N) /\ PERM t (M ++ N)
   
   [<A NAME="PERM_CONS_IFF-val"><B>PERM_CONS_IFF</B></A>]  Theorem
      
      |- !x l2 l1. PERM (x::l1) (x::l2) &lt;=&gt; PERM l1 l2
   
   [<A NAME="PERM_EQC-val"><B>PERM_EQC</B></A>]  Theorem
      
      |- PERM = PERM_SINGLE_SWAP^=
   
   [<A NAME="PERM_EQUIVALENCE-val"><B>PERM_EQUIVALENCE</B></A>]  Theorem
      
      |- equivalence PERM
   
   [<A NAME="PERM_EQUIVALENCE_ALT_DEF-val"><B>PERM_EQUIVALENCE_ALT_DEF</B></A>]  Theorem
      
      |- !x y. PERM x y &lt;=&gt; (PERM x = PERM y)
   
   [<A NAME="PERM_FILTER-val"><B>PERM_FILTER</B></A>]  Theorem
      
      |- !P l1 l2. PERM l1 l2 ==&gt; PERM (FILTER P l1) (FILTER P l2)
   
   [<A NAME="PERM_FUN_APPEND-val"><B>PERM_FUN_APPEND</B></A>]  Theorem
      
      |- !l1 l2. PERM (l1 ++ l2) = PERM (l2 ++ l1)
   
   [<A NAME="PERM_FUN_APPEND_APPEND_1-val"><B>PERM_FUN_APPEND_APPEND_1</B></A>]  Theorem
      
      |- !l1 l2 l3 l4.
           (PERM l1 = PERM (l2 ++ l3)) ==&gt;
           (PERM (l1 ++ l4) = PERM (l2 ++ (l3 ++ l4)))
   
   [<A NAME="PERM_FUN_APPEND_APPEND_2-val"><B>PERM_FUN_APPEND_APPEND_2</B></A>]  Theorem
      
      |- !l1 l2 l3 l4.
           (PERM l1 = PERM (l2 ++ l3)) ==&gt;
           (PERM (l4 ++ l1) = PERM (l2 ++ (l4 ++ l3)))
   
   [<A NAME="PERM_FUN_APPEND_CONS-val"><B>PERM_FUN_APPEND_CONS</B></A>]  Theorem
      
      |- !x l1 l2. PERM (l1 ++ x::l2) = PERM (x::l1 ++ l2)
   
   [<A NAME="PERM_FUN_APPEND_IFF-val"><B>PERM_FUN_APPEND_IFF</B></A>]  Theorem
      
      |- !l l1 l2.
           (PERM l1 = PERM l2) ==&gt; (PERM (l ++ l1) = PERM (l ++ l2))
   
   [<A NAME="PERM_FUN_CONG-val"><B>PERM_FUN_CONG</B></A>]  Theorem
      
      |- !l1 l1' l2 l2'.
           (PERM l1 = PERM l1') ==&gt;
           (PERM l2 = PERM l2') ==&gt;
           (PERM l1 l2 &lt;=&gt; PERM l1' l2')
   
   [<A NAME="PERM_FUN_CONS-val"><B>PERM_FUN_CONS</B></A>]  Theorem
      
      |- !x l1 l1'. (PERM l1 = PERM l1') ==&gt; (PERM (x::l1) = PERM (x::l1'))
   
   [<A NAME="PERM_FUN_CONS_11_APPEND-val"><B>PERM_FUN_CONS_11_APPEND</B></A>]  Theorem
      
      |- !y l1 l2 l3.
           (PERM l1 = PERM (l2 ++ l3)) ==&gt;
           (PERM (y::l1) = PERM (l2 ++ y::l3))
   
   [<A NAME="PERM_FUN_CONS_11_SWAP_AT_FRONT-val"><B>PERM_FUN_CONS_11_SWAP_AT_FRONT</B></A>]  Theorem
      
      |- !y l1 x l2.
           (PERM l1 = PERM (x::l2)) ==&gt; (PERM (y::l1) = PERM (x::y::l2))
   
   [<A NAME="PERM_FUN_CONS_APPEND_1-val"><B>PERM_FUN_CONS_APPEND_1</B></A>]  Theorem
      
      |- !l l1 x l2.
           (PERM l1 = PERM (x::l2)) ==&gt;
           (PERM (l1 ++ l) = PERM (x::(l2 ++ l)))
   
   [<A NAME="PERM_FUN_CONS_APPEND_2-val"><B>PERM_FUN_CONS_APPEND_2</B></A>]  Theorem
      
      |- !l l1 x l2.
           (PERM l1 = PERM (x::l2)) ==&gt;
           (PERM (l ++ l1) = PERM (x::(l ++ l2)))
   
   [<A NAME="PERM_FUN_CONS_IFF-val"><B>PERM_FUN_CONS_IFF</B></A>]  Theorem
      
      |- !x l1 l2. (PERM l1 = PERM l2) ==&gt; (PERM (x::l1) = PERM (x::l2))
   
   [<A NAME="PERM_FUN_SPLIT-val"><B>PERM_FUN_SPLIT</B></A>]  Theorem
      
      |- !l l1 l1' l2.
           PERM l (l1 ++ l2) ==&gt; PERM l1' l1 ==&gt; PERM l (l1' ++ l2)
   
   [<A NAME="PERM_FUN_SWAP_AT_FRONT-val"><B>PERM_FUN_SWAP_AT_FRONT</B></A>]  Theorem
      
      |- !x y l. PERM (x::y::l) = PERM (y::x::l)
   
   [<A NAME="PERM_IND-val"><B>PERM_IND</B></A>]  Theorem
      
      |- !P.
           P [] [] /\ (!x l1 l2. P l1 l2 ==&gt; P (x::l1) (x::l2)) /\
           (!x y l1 l2. P l1 l2 ==&gt; P (x::y::l1) (y::x::l2)) /\
           (!l1 l2 l3. P l1 l2 /\ P l2 l3 ==&gt; P l1 l3) ==&gt;
           !l1 l2. PERM l1 l2 ==&gt; P l1 l2
   
   [<A NAME="PERM_INTRO-val"><B>PERM_INTRO</B></A>]  Theorem
      
      |- !x y. (x = y) ==&gt; PERM x y
   
   [<A NAME="PERM_LENGTH-val"><B>PERM_LENGTH</B></A>]  Theorem
      
      |- !l1 l2. PERM l1 l2 ==&gt; (LENGTH l1 = LENGTH l2)
   
   [<A NAME="PERM_MAP-val"><B>PERM_MAP</B></A>]  Theorem
      
      |- !f l1 l2. PERM l1 l2 ==&gt; PERM (MAP f l1) (MAP f l2)
   
   [<A NAME="PERM_MEM_EQ-val"><B>PERM_MEM_EQ</B></A>]  Theorem
      
      |- !l1 l2. PERM l1 l2 ==&gt; !x. MEM x l1 &lt;=&gt; MEM x l2
   
   [<A NAME="PERM_MONO-val"><B>PERM_MONO</B></A>]  Theorem
      
      |- !l1 l2 x. PERM l1 l2 ==&gt; PERM (x::l1) (x::l2)
   
   [<A NAME="PERM_NIL-val"><B>PERM_NIL</B></A>]  Theorem
      
      |- !L. (PERM L [] &lt;=&gt; (L = [])) /\ (PERM [] L &lt;=&gt; (L = []))
   
   [<A NAME="PERM_REFL-val"><B>PERM_REFL</B></A>]  Theorem
      
      |- !L. PERM L L
   
   [<A NAME="PERM_REWR-val"><B>PERM_REWR</B></A>]  Theorem
      
      |- !l r l1 l2. PERM l r ==&gt; (PERM (l ++ l1) l2 &lt;=&gt; PERM (r ++ l1) l2)
   
   [<A NAME="PERM_RTC-val"><B>PERM_RTC</B></A>]  Theorem
      
      |- PERM = PERM_SINGLE_SWAP^*
   
   [<A NAME="PERM_SING-val"><B>PERM_SING</B></A>]  Theorem
      
      |- (PERM L [x] &lt;=&gt; (L = [x])) /\ (PERM [x] L &lt;=&gt; (L = [x]))
   
   [<A NAME="PERM_SINGLE_SWAP_REFL-val"><B>PERM_SINGLE_SWAP_REFL</B></A>]  Theorem
      
      |- !l. PERM_SINGLE_SWAP l l
   
   [<A NAME="PERM_SINGLE_SWAP_SYM-val"><B>PERM_SINGLE_SWAP_SYM</B></A>]  Theorem
      
      |- !l1 l2. PERM_SINGLE_SWAP l1 l2 &lt;=&gt; PERM_SINGLE_SWAP l2 l1
   
   [<A NAME="PERM_SPLIT-val"><B>PERM_SPLIT</B></A>]  Theorem
      
      |- !P l. PERM l (FILTER P l ++ FILTER ($~ o P) l)
   
   [<A NAME="PERM_SWAP_AT_FRONT-val"><B>PERM_SWAP_AT_FRONT</B></A>]  Theorem
      
      |- PERM (x::y::l1) (y::x::l2) &lt;=&gt; PERM l1 l2
   
   [<A NAME="PERM_SYM-val"><B>PERM_SYM</B></A>]  Theorem
      
      |- !l1 l2. PERM l1 l2 &lt;=&gt; PERM l2 l1
   
   [<A NAME="PERM_TC-val"><B>PERM_TC</B></A>]  Theorem
      
      |- PERM = PERM_SINGLE_SWAP^+
   
   [<A NAME="PERM_TRANS-val"><B>PERM_TRANS</B></A>]  Theorem
      
      |- !x y z. PERM x y /\ PERM y z ==&gt; PERM x z
   
   [<A NAME="PERM_lifts_equalities-val"><B>PERM_lifts_equalities</B></A>]  Theorem
      
      |- !f.
           (!x1 x2 x3. f (x1 ++ x2 ++ x3) = f (x1 ++ x3 ++ x2)) ==&gt;
           !x y. PERM x y ==&gt; (f x = f y)
   
   [<A NAME="PERM_lifts_invariants-val"><B>PERM_lifts_invariants</B></A>]  Theorem
      
      |- !P.
           (!x1 x2 x3. P (x1 ++ x2 ++ x3) ==&gt; P (x1 ++ x3 ++ x2)) ==&gt;
           !x y. P x /\ PERM x y ==&gt; P y
   
   [<A NAME="PERM_lifts_monotonicities-val"><B>PERM_lifts_monotonicities</B></A>]  Theorem
      
      |- !f.
           (!x1 x2 x3.
              ?x1' x2' x3'.
                (f (x1 ++ x2 ++ x3) = x1' ++ x2' ++ x3') /\
                (f (x1 ++ x3 ++ x2) = x1' ++ x3' ++ x2')) ==&gt;
           !x y. PERM x y ==&gt; PERM (f x) (f y)
   
   [<A NAME="PERM_lifts_transitive_relations-val"><B>PERM_lifts_transitive_relations</B></A>]  Theorem
      
      |- !f Q.
           (!x1 x2 x3. Q (f (x1 ++ x2 ++ x3)) (f (x1 ++ x3 ++ x2))) /\
           transitive Q ==&gt;
           !x y. PERM x y ==&gt; Q (f x) (f y)
   
   [<A NAME="PERM_transitive-val"><B>PERM_transitive</B></A>]  Theorem
      
      |- transitive PERM
   
   [<A NAME="QSORT_DEF-val"><B>QSORT_DEF</B></A>]  Theorem
      
      |- (QSORT ord [] = []) /\
         (QSORT ord (h::t) =
          (let (l1,l2) = PARTITION (\y. ord y h) t in
             QSORT ord l1 ++ [h] ++ QSORT ord l2))
   
   [<A NAME="QSORT_IND-val"><B>QSORT_IND</B></A>]  Theorem
      
      |- !P.
           (!ord. P ord []) /\
           (!ord h t.
              (!l1 l2.
                 ((l1,l2) = PARTITION (\y. ord y h) t) ==&gt; P ord l2) /\
              (!l1 l2.
                 ((l1,l2) = PARTITION (\y. ord y h) t) ==&gt; P ord l1) ==&gt;
              P ord (h::t)) ==&gt;
           !v v1. P v v1
   
   [<A NAME="QSORT_MEM-val"><B>QSORT_MEM</B></A>]  Theorem
      
      |- !R L x. MEM x (QSORT R L) &lt;=&gt; MEM x L
   
   [<A NAME="QSORT_PERM-val"><B>QSORT_PERM</B></A>]  Theorem
      
      |- !R L. PERM L (QSORT R L)
   
   [<A NAME="QSORT_SORTED-val"><B>QSORT_SORTED</B></A>]  Theorem
      
      |- !R L. transitive R /\ total R ==&gt; SORTED R (QSORT R L)
   
   [<A NAME="QSORT_SORTS-val"><B>QSORT_SORTS</B></A>]  Theorem
      
      |- !R. transitive R /\ total R ==&gt; SORTS QSORT R
   
   [<A NAME="SORTED_APPEND-val"><B>SORTED_APPEND</B></A>]  Theorem
      
      |- !R L1 L2.
           transitive R /\ SORTED R L1 /\ SORTED R L2 /\
           (!x y. MEM x L1 /\ MEM y L2 ==&gt; R x y) ==&gt;
           SORTED R (L1 ++ L2)
   
   [<A NAME="SORTED_DEF-val"><B>SORTED_DEF</B></A>]  Theorem
      
      |- (!R. SORTED R [] &lt;=&gt; T) /\ (!x R. SORTED R [x] &lt;=&gt; T) /\
         !y x rst R. SORTED R (x::y::rst) &lt;=&gt; R x y /\ SORTED R (y::rst)
   
   [<A NAME="SORTED_EQ-val"><B>SORTED_EQ</B></A>]  Theorem
      
      |- !R L x.
           transitive R ==&gt;
           (SORTED R (x::L) &lt;=&gt; SORTED R L /\ !y. MEM y L ==&gt; R x y)
   
   [<A NAME="SORTED_IND-val"><B>SORTED_IND</B></A>]  Theorem
      
      |- !P.
           (!R. P R []) /\ (!R x. P R [x]) /\
           (!R x y rst. P R (y::rst) ==&gt; P R (x::y::rst)) ==&gt;
           !v v1. P v v1
   
   
*)
end

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/sort/sortingScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
