<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure polyTheory</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure polyTheory</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/real/polyScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>signature polyTheory =
<A NAME="line2"></A>sig
<A NAME="line3"></A>  type thm = Thm.thm
<A NAME="line4"></A>  
<A NAME="line5"></A>  (*  Definitions  *)
<A NAME="line6"></A>    val <A HREF="#degree-val">degree</A> : thm
<A NAME="line7"></A>    val <A HREF="#normalize-val">normalize</A> : thm
<A NAME="line8"></A>    val <A HREF="#poly_add_def-val">poly_add_def</A> : thm
<A NAME="line9"></A>    val <A HREF="#poly_cmul_def-val">poly_cmul_def</A> : thm
<A NAME="line10"></A>    val <A HREF="#poly_def-val">poly_def</A> : thm
<A NAME="line11"></A>    val <A HREF="#poly_diff_aux_def-val">poly_diff_aux_def</A> : thm
<A NAME="line12"></A>    val <A HREF="#poly_diff_def-val">poly_diff_def</A> : thm
<A NAME="line13"></A>    val <A HREF="#poly_divides-val">poly_divides</A> : thm
<A NAME="line14"></A>    val <A HREF="#poly_exp_def-val">poly_exp_def</A> : thm
<A NAME="line15"></A>    val <A HREF="#poly_mul_def-val">poly_mul_def</A> : thm
<A NAME="line16"></A>    val <A HREF="#poly_neg_def-val">poly_neg_def</A> : thm
<A NAME="line17"></A>    val <A HREF="#poly_order-val">poly_order</A> : thm
<A NAME="line18"></A>    val <A HREF="#rsquarefree-val">rsquarefree</A> : thm
<A NAME="line19"></A>  
<A NAME="line20"></A>  (*  Theorems  *)
<A NAME="line21"></A>    val <A HREF="#DEGREE_ZERO-val">DEGREE_ZERO</A> : thm
<A NAME="line22"></A>    val <A HREF="#FINITE_LEMMA-val">FINITE_LEMMA</A> : thm
<A NAME="line23"></A>    val <A HREF="#ORDER-val">ORDER</A> : thm
<A NAME="line24"></A>    val <A HREF="#ORDER_DECOMP-val">ORDER_DECOMP</A> : thm
<A NAME="line25"></A>    val <A HREF="#ORDER_DIFF-val">ORDER_DIFF</A> : thm
<A NAME="line26"></A>    val <A HREF="#ORDER_DIVIDES-val">ORDER_DIVIDES</A> : thm
<A NAME="line27"></A>    val <A HREF="#ORDER_MUL-val">ORDER_MUL</A> : thm
<A NAME="line28"></A>    val <A HREF="#ORDER_POLY-val">ORDER_POLY</A> : thm
<A NAME="line29"></A>    val <A HREF="#ORDER_ROOT-val">ORDER_ROOT</A> : thm
<A NAME="line30"></A>    val <A HREF="#ORDER_THM-val">ORDER_THM</A> : thm
<A NAME="line31"></A>    val <A HREF="#ORDER_UNIQUE-val">ORDER_UNIQUE</A> : thm
<A NAME="line32"></A>    val <A HREF="#POLY_ADD-val">POLY_ADD</A> : thm
<A NAME="line33"></A>    val <A HREF="#POLY_ADD_CLAUSES-val">POLY_ADD_CLAUSES</A> : thm
<A NAME="line34"></A>    val <A HREF="#POLY_ADD_RZERO-val">POLY_ADD_RZERO</A> : thm
<A NAME="line35"></A>    val <A HREF="#POLY_CMUL-val">POLY_CMUL</A> : thm
<A NAME="line36"></A>    val <A HREF="#POLY_CMUL_CLAUSES-val">POLY_CMUL_CLAUSES</A> : thm
<A NAME="line37"></A>    val <A HREF="#POLY_CONT-val">POLY_CONT</A> : thm
<A NAME="line38"></A>    val <A HREF="#POLY_DIFF-val">POLY_DIFF</A> : thm
<A NAME="line39"></A>    val <A HREF="#POLY_DIFFERENTIABLE-val">POLY_DIFFERENTIABLE</A> : thm
<A NAME="line40"></A>    val <A HREF="#POLY_DIFF_ADD-val">POLY_DIFF_ADD</A> : thm
<A NAME="line41"></A>    val <A HREF="#POLY_DIFF_AUX_ADD-val">POLY_DIFF_AUX_ADD</A> : thm
<A NAME="line42"></A>    val <A HREF="#POLY_DIFF_AUX_CMUL-val">POLY_DIFF_AUX_CMUL</A> : thm
<A NAME="line43"></A>    val <A HREF="#POLY_DIFF_AUX_ISZERO-val">POLY_DIFF_AUX_ISZERO</A> : thm
<A NAME="line44"></A>    val <A HREF="#POLY_DIFF_AUX_MUL_LEMMA-val">POLY_DIFF_AUX_MUL_LEMMA</A> : thm
<A NAME="line45"></A>    val <A HREF="#POLY_DIFF_AUX_NEG-val">POLY_DIFF_AUX_NEG</A> : thm
<A NAME="line46"></A>    val <A HREF="#POLY_DIFF_CLAUSES-val">POLY_DIFF_CLAUSES</A> : thm
<A NAME="line47"></A>    val <A HREF="#POLY_DIFF_CMUL-val">POLY_DIFF_CMUL</A> : thm
<A NAME="line48"></A>    val <A HREF="#POLY_DIFF_EXP-val">POLY_DIFF_EXP</A> : thm
<A NAME="line49"></A>    val <A HREF="#POLY_DIFF_EXP_PRIME-val">POLY_DIFF_EXP_PRIME</A> : thm
<A NAME="line50"></A>    val <A HREF="#POLY_DIFF_ISZERO-val">POLY_DIFF_ISZERO</A> : thm
<A NAME="line51"></A>    val <A HREF="#POLY_DIFF_LEMMA-val">POLY_DIFF_LEMMA</A> : thm
<A NAME="line52"></A>    val <A HREF="#POLY_DIFF_MUL-val">POLY_DIFF_MUL</A> : thm
<A NAME="line53"></A>    val <A HREF="#POLY_DIFF_MUL_LEMMA-val">POLY_DIFF_MUL_LEMMA</A> : thm
<A NAME="line54"></A>    val <A HREF="#POLY_DIFF_NEG-val">POLY_DIFF_NEG</A> : thm
<A NAME="line55"></A>    val <A HREF="#POLY_DIFF_WELLDEF-val">POLY_DIFF_WELLDEF</A> : thm
<A NAME="line56"></A>    val <A HREF="#POLY_DIFF_ZERO-val">POLY_DIFF_ZERO</A> : thm
<A NAME="line57"></A>    val <A HREF="#POLY_DIVIDES_ADD-val">POLY_DIVIDES_ADD</A> : thm
<A NAME="line58"></A>    val <A HREF="#POLY_DIVIDES_EXP-val">POLY_DIVIDES_EXP</A> : thm
<A NAME="line59"></A>    val <A HREF="#POLY_DIVIDES_REFL-val">POLY_DIVIDES_REFL</A> : thm
<A NAME="line60"></A>    val <A HREF="#POLY_DIVIDES_SUB-val">POLY_DIVIDES_SUB</A> : thm
<A NAME="line61"></A>    val <A HREF="#POLY_DIVIDES_SUB2-val">POLY_DIVIDES_SUB2</A> : thm
<A NAME="line62"></A>    val <A HREF="#POLY_DIVIDES_TRANS-val">POLY_DIVIDES_TRANS</A> : thm
<A NAME="line63"></A>    val <A HREF="#POLY_DIVIDES_ZERO-val">POLY_DIVIDES_ZERO</A> : thm
<A NAME="line64"></A>    val <A HREF="#POLY_ENTIRE-val">POLY_ENTIRE</A> : thm
<A NAME="line65"></A>    val <A HREF="#POLY_ENTIRE_LEMMA-val">POLY_ENTIRE_LEMMA</A> : thm
<A NAME="line66"></A>    val <A HREF="#POLY_EXP-val">POLY_EXP</A> : thm
<A NAME="line67"></A>    val <A HREF="#POLY_EXP_ADD-val">POLY_EXP_ADD</A> : thm
<A NAME="line68"></A>    val <A HREF="#POLY_EXP_DIVIDES-val">POLY_EXP_DIVIDES</A> : thm
<A NAME="line69"></A>    val <A HREF="#POLY_EXP_EQ_0-val">POLY_EXP_EQ_0</A> : thm
<A NAME="line70"></A>    val <A HREF="#POLY_EXP_PRIME_EQ_0-val">POLY_EXP_PRIME_EQ_0</A> : thm
<A NAME="line71"></A>    val <A HREF="#POLY_IVT_NEG-val">POLY_IVT_NEG</A> : thm
<A NAME="line72"></A>    val <A HREF="#POLY_IVT_POS-val">POLY_IVT_POS</A> : thm
<A NAME="line73"></A>    val <A HREF="#POLY_LENGTH_MUL-val">POLY_LENGTH_MUL</A> : thm
<A NAME="line74"></A>    val <A HREF="#POLY_LINEAR_DIVIDES-val">POLY_LINEAR_DIVIDES</A> : thm
<A NAME="line75"></A>    val <A HREF="#POLY_LINEAR_REM-val">POLY_LINEAR_REM</A> : thm
<A NAME="line76"></A>    val <A HREF="#POLY_MONO-val">POLY_MONO</A> : thm
<A NAME="line77"></A>    val <A HREF="#POLY_MUL-val">POLY_MUL</A> : thm
<A NAME="line78"></A>    val <A HREF="#POLY_MUL_ASSOC-val">POLY_MUL_ASSOC</A> : thm
<A NAME="line79"></A>    val <A HREF="#POLY_MUL_CLAUSES-val">POLY_MUL_CLAUSES</A> : thm
<A NAME="line80"></A>    val <A HREF="#POLY_MUL_LCANCEL-val">POLY_MUL_LCANCEL</A> : thm
<A NAME="line81"></A>    val <A HREF="#POLY_MVT-val">POLY_MVT</A> : thm
<A NAME="line82"></A>    val <A HREF="#POLY_NEG-val">POLY_NEG</A> : thm
<A NAME="line83"></A>    val <A HREF="#POLY_NEG_CLAUSES-val">POLY_NEG_CLAUSES</A> : thm
<A NAME="line84"></A>    val <A HREF="#POLY_NORMALIZE-val">POLY_NORMALIZE</A> : thm
<A NAME="line85"></A>    val <A HREF="#POLY_ORDER-val">POLY_ORDER</A> : thm
<A NAME="line86"></A>    val <A HREF="#POLY_ORDER_EXISTS-val">POLY_ORDER_EXISTS</A> : thm
<A NAME="line87"></A>    val <A HREF="#POLY_PRIMES-val">POLY_PRIMES</A> : thm
<A NAME="line88"></A>    val <A HREF="#POLY_PRIME_EQ_0-val">POLY_PRIME_EQ_0</A> : thm
<A NAME="line89"></A>    val <A HREF="#POLY_ROOTS_FINITE-val">POLY_ROOTS_FINITE</A> : thm
<A NAME="line90"></A>    val <A HREF="#POLY_ROOTS_FINITE_LEMMA-val">POLY_ROOTS_FINITE_LEMMA</A> : thm
<A NAME="line91"></A>    val <A HREF="#POLY_ROOTS_FINITE_SET-val">POLY_ROOTS_FINITE_SET</A> : thm
<A NAME="line92"></A>    val <A HREF="#POLY_ROOTS_INDEX_LEMMA-val">POLY_ROOTS_INDEX_LEMMA</A> : thm
<A NAME="line93"></A>    val <A HREF="#POLY_ROOTS_INDEX_LENGTH-val">POLY_ROOTS_INDEX_LENGTH</A> : thm
<A NAME="line94"></A>    val <A HREF="#POLY_SQUAREFREE_DECOMP-val">POLY_SQUAREFREE_DECOMP</A> : thm
<A NAME="line95"></A>    val <A HREF="#POLY_SQUAREFREE_DECOMP_ORDER-val">POLY_SQUAREFREE_DECOMP_ORDER</A> : thm
<A NAME="line96"></A>    val <A HREF="#POLY_ZERO-val">POLY_ZERO</A> : thm
<A NAME="line97"></A>    val <A HREF="#POLY_ZERO_LEMMA-val">POLY_ZERO_LEMMA</A> : thm
<A NAME="line98"></A>    val <A HREF="#RSQUAREFREE_DECOMP-val">RSQUAREFREE_DECOMP</A> : thm
<A NAME="line99"></A>    val <A HREF="#RSQUAREFREE_ROOTS-val">RSQUAREFREE_ROOTS</A> : thm
<A NAME="line100"></A>  
<A NAME="line101"></A>  val poly_grammars : type_grammar.grammar * term_grammar.grammar
<A NAME="line102"></A>  
<A NAME="line103"></A>  
<A NAME="line104"></A>(*
   [lim] Parent theory of "poly"
   
   [<A NAME="degree-val"><B>degree</B></A>]  Definition
      
      |- !p. degree p = PRE (LENGTH (normalize p))
   
   [<A NAME="normalize-val"><B>normalize</B></A>]  Definition
      
      |- (normalize [] = []) /\
         !h t.
           normalize (h::t) =
           if normalize t = [] then
             if h = 0 then [] else [h]
           else
             h::normalize t
   
   [<A NAME="poly_add_def-val"><B>poly_add_def</B></A>]  Definition
      
      |- (!l2. [] + l2 = l2) /\
         !h t l2.
           (h::t) + l2 = if l2 = [] then h::t else h + HD l2::t + TL l2
   
   [<A NAME="poly_cmul_def-val"><B>poly_cmul_def</B></A>]  Definition
      
      |- (!c. c ## [] = []) /\ !c h t. c ## (h::t) = c * h::c ## t
   
   [<A NAME="poly_def-val"><B>poly_def</B></A>]  Definition
      
      |- (!x. poly [] x = 0) /\ !h t x. poly (h::t) x = h + x * poly t x
   
   [<A NAME="poly_diff_aux_def-val"><B>poly_diff_aux_def</B></A>]  Definition
      
      |- (!n. poly_diff_aux n [] = []) /\
         !n h t. poly_diff_aux n (h::t) = &n * h::poly_diff_aux (SUC n) t
   
   [<A NAME="poly_diff_def-val"><B>poly_diff_def</B></A>]  Definition
      
      |- !l. diff l = if l = [] then [] else poly_diff_aux 1 (TL l)
   
   [<A NAME="poly_divides-val"><B>poly_divides</B></A>]  Definition
      
      |- !p1 p2. p1 poly_divides p2 &lt;=&gt; ?q. poly p2 = poly (p1 * q)
   
   [<A NAME="poly_exp_def-val"><B>poly_exp_def</B></A>]  Definition
      
      |- (!p. p poly_exp 0 = [1]) /\
         !p n. p poly_exp SUC n = p * p poly_exp n
   
   [<A NAME="poly_mul_def-val"><B>poly_mul_def</B></A>]  Definition
      
      |- (!l2. [] * l2 = []) /\
         !h t l2.
           (h::t) * l2 = if t = [] then h ## l2 else h ## l2 + (0::t * l2)
   
   [<A NAME="poly_neg_def-val"><B>poly_neg_def</B></A>]  Definition
      
      |- $~ = $## (-1)
   
   [<A NAME="poly_order-val"><B>poly_order</B></A>]  Definition
      
      |- !a p.
           poly_order a p =
           @n.
             [-a; 1] poly_exp n poly_divides p /\
             ~([-a; 1] poly_exp SUC n poly_divides p)
   
   [<A NAME="rsquarefree-val"><B>rsquarefree</B></A>]  Definition
      
      |- !p.
           rsquarefree p &lt;=&gt;
           poly p &lt;&gt; poly [] /\
           !a. (poly_order a p = 0) \/ (poly_order a p = 1)
   
   [<A NAME="DEGREE_ZERO-val"><B>DEGREE_ZERO</B></A>]  Theorem
      
      |- !p. (poly p = poly []) ==&gt; (degree p = 0)
   
   [<A NAME="FINITE_LEMMA-val"><B>FINITE_LEMMA</B></A>]  Theorem
      
      |- !i N P.
           (!x. P x ==&gt; ?n. n &lt; N /\ (x = i n)) ==&gt; ?a. !x. P x ==&gt; x &lt; a
   
   [<A NAME="ORDER-val"><B>ORDER</B></A>]  Theorem
      
      |- !p a n.
           [-a; 1] poly_exp n poly_divides p /\
           ~([-a; 1] poly_exp SUC n poly_divides p) &lt;=&gt;
           (n = poly_order a p) /\ poly p &lt;&gt; poly []
   
   [<A NAME="ORDER_DECOMP-val"><B>ORDER_DECOMP</B></A>]  Theorem
      
      |- !p a.
           poly p &lt;&gt; poly [] ==&gt;
           ?q.
             (poly p = poly ([-a; 1] poly_exp poly_order a p * q)) /\
             ~([-a; 1] poly_divides q)
   
   [<A NAME="ORDER_DIFF-val"><B>ORDER_DIFF</B></A>]  Theorem
      
      |- !p a.
           poly (diff p) &lt;&gt; poly [] /\ poly_order a p &lt;&gt; 0 ==&gt;
           (poly_order a p = SUC (poly_order a (diff p)))
   
   [<A NAME="ORDER_DIVIDES-val"><B>ORDER_DIVIDES</B></A>]  Theorem
      
      |- !p a n.
           [-a; 1] poly_exp n poly_divides p &lt;=&gt;
           (poly p = poly []) \/ n &lt;= poly_order a p
   
   [<A NAME="ORDER_MUL-val"><B>ORDER_MUL</B></A>]  Theorem
      
      |- !a p q.
           poly (p * q) &lt;&gt; poly [] ==&gt;
           (poly_order a (p * q) = poly_order a p + poly_order a q)
   
   [<A NAME="ORDER_POLY-val"><B>ORDER_POLY</B></A>]  Theorem
      
      |- !p q a. (poly p = poly q) ==&gt; (poly_order a p = poly_order a q)
   
   [<A NAME="ORDER_ROOT-val"><B>ORDER_ROOT</B></A>]  Theorem
      
      |- !p a. (poly p a = 0) &lt;=&gt; (poly p = poly []) \/ poly_order a p &lt;&gt; 0
   
   [<A NAME="ORDER_THM-val"><B>ORDER_THM</B></A>]  Theorem
      
      |- !p a.
           poly p &lt;&gt; poly [] ==&gt;
           [-a; 1] poly_exp poly_order a p poly_divides p /\
           ~([-a; 1] poly_exp SUC (poly_order a p) poly_divides p)
   
   [<A NAME="ORDER_UNIQUE-val"><B>ORDER_UNIQUE</B></A>]  Theorem
      
      |- !p a n.
           poly p &lt;&gt; poly [] /\ [-a; 1] poly_exp n poly_divides p /\
           ~([-a; 1] poly_exp SUC n poly_divides p) ==&gt;
           (n = poly_order a p)
   
   [<A NAME="POLY_ADD-val"><B>POLY_ADD</B></A>]  Theorem
      
      |- !p1 p2 x. poly (p1 + p2) x = poly p1 x + poly p2 x
   
   [<A NAME="POLY_ADD_CLAUSES-val"><B>POLY_ADD_CLAUSES</B></A>]  Theorem
      
      |- ([] + p2 = p2) /\ (p1 + [] = p1) /\
         ((h1::t1) + (h2::t2) = h1 + h2::t1 + t2)
   
   [<A NAME="POLY_ADD_RZERO-val"><B>POLY_ADD_RZERO</B></A>]  Theorem
      
      |- !p. poly (p + []) = poly p
   
   [<A NAME="POLY_CMUL-val"><B>POLY_CMUL</B></A>]  Theorem
      
      |- !p c x. poly (c ## p) x = c * poly p x
   
   [<A NAME="POLY_CMUL_CLAUSES-val"><B>POLY_CMUL_CLAUSES</B></A>]  Theorem
      
      |- (c ## [] = []) /\ (c ## (h::t) = c * h::c ## t)
   
   [<A NAME="POLY_CONT-val"><B>POLY_CONT</B></A>]  Theorem
      
      |- !l x. (\x. poly l x) contl x
   
   [<A NAME="POLY_DIFF-val"><B>POLY_DIFF</B></A>]  Theorem
      
      |- !l x. ((\x. poly l x) diffl poly (diff l) x) x
   
   [<A NAME="POLY_DIFFERENTIABLE-val"><B>POLY_DIFFERENTIABLE</B></A>]  Theorem
      
      |- !l x. (\x. poly l x) differentiable x
   
   [<A NAME="POLY_DIFF_ADD-val"><B>POLY_DIFF_ADD</B></A>]  Theorem
      
      |- !p1 p2. poly (diff (p1 + p2)) = poly (diff p1 + diff p2)
   
   [<A NAME="POLY_DIFF_AUX_ADD-val"><B>POLY_DIFF_AUX_ADD</B></A>]  Theorem
      
      |- !p1 p2 n.
           poly (poly_diff_aux n (p1 + p2)) =
           poly (poly_diff_aux n p1 + poly_diff_aux n p2)
   
   [<A NAME="POLY_DIFF_AUX_CMUL-val"><B>POLY_DIFF_AUX_CMUL</B></A>]  Theorem
      
      |- !p c n.
           poly (poly_diff_aux n (c ## p)) = poly (c ## poly_diff_aux n p)
   
   [<A NAME="POLY_DIFF_AUX_ISZERO-val"><B>POLY_DIFF_AUX_ISZERO</B></A>]  Theorem
      
      |- !p n.
           EVERY (\c. c = 0) (poly_diff_aux (SUC n) p) &lt;=&gt;
           EVERY (\c. c = 0) p
   
   [<A NAME="POLY_DIFF_AUX_MUL_LEMMA-val"><B>POLY_DIFF_AUX_MUL_LEMMA</B></A>]  Theorem
      
      |- !p n.
           poly (poly_diff_aux (SUC n) p) = poly (poly_diff_aux n p + p)
   
   [<A NAME="POLY_DIFF_AUX_NEG-val"><B>POLY_DIFF_AUX_NEG</B></A>]  Theorem
      
      |- !p n. poly (poly_diff_aux n (~p)) = poly (~poly_diff_aux n p)
   
   [<A NAME="POLY_DIFF_CLAUSES-val"><B>POLY_DIFF_CLAUSES</B></A>]  Theorem
      
      |- (diff [] = []) /\ (diff [c] = []) /\
         (diff (h::t) = poly_diff_aux 1 t)
   
   [<A NAME="POLY_DIFF_CMUL-val"><B>POLY_DIFF_CMUL</B></A>]  Theorem
      
      |- !p c. poly (diff (c ## p)) = poly (c ## diff p)
   
   [<A NAME="POLY_DIFF_EXP-val"><B>POLY_DIFF_EXP</B></A>]  Theorem
      
      |- !p n.
           poly (diff (p poly_exp SUC n)) =
           poly (&SUC n ## p poly_exp n * diff p)
   
   [<A NAME="POLY_DIFF_EXP_PRIME-val"><B>POLY_DIFF_EXP_PRIME</B></A>]  Theorem
      
      |- !n a.
           poly (diff ([-a; 1] poly_exp SUC n)) =
           poly (&SUC n ## [-a; 1] poly_exp n)
   
   [<A NAME="POLY_DIFF_ISZERO-val"><B>POLY_DIFF_ISZERO</B></A>]  Theorem
      
      |- !p. (poly (diff p) = poly []) ==&gt; ?h. poly p = poly [h]
   
   [<A NAME="POLY_DIFF_LEMMA-val"><B>POLY_DIFF_LEMMA</B></A>]  Theorem
      
      |- !l n x.
           ((\x. x pow SUC n * poly l x) diffl
            (x pow n * poly (poly_diff_aux (SUC n) l) x)) x
   
   [<A NAME="POLY_DIFF_MUL-val"><B>POLY_DIFF_MUL</B></A>]  Theorem
      
      |- !p1 p2. poly (diff (p1 * p2)) = poly (p1 * diff p2 + diff p1 * p2)
   
   [<A NAME="POLY_DIFF_MUL_LEMMA-val"><B>POLY_DIFF_MUL_LEMMA</B></A>]  Theorem
      
      |- !t h. poly (diff (h::t)) = poly ((0::diff t) + t)
   
   [<A NAME="POLY_DIFF_NEG-val"><B>POLY_DIFF_NEG</B></A>]  Theorem
      
      |- !p. poly (diff (~p)) = poly (~diff p)
   
   [<A NAME="POLY_DIFF_WELLDEF-val"><B>POLY_DIFF_WELLDEF</B></A>]  Theorem
      
      |- !p q. (poly p = poly q) ==&gt; (poly (diff p) = poly (diff q))
   
   [<A NAME="POLY_DIFF_ZERO-val"><B>POLY_DIFF_ZERO</B></A>]  Theorem
      
      |- !p. (poly p = poly []) ==&gt; (poly (diff p) = poly [])
   
   [<A NAME="POLY_DIVIDES_ADD-val"><B>POLY_DIVIDES_ADD</B></A>]  Theorem
      
      |- !p q r.
           p poly_divides q /\ p poly_divides r ==&gt; p poly_divides q + r
   
   [<A NAME="POLY_DIVIDES_EXP-val"><B>POLY_DIVIDES_EXP</B></A>]  Theorem
      
      |- !p m n. m &lt;= n ==&gt; p poly_exp m poly_divides p poly_exp n
   
   [<A NAME="POLY_DIVIDES_REFL-val"><B>POLY_DIVIDES_REFL</B></A>]  Theorem
      
      |- !p. p poly_divides p
   
   [<A NAME="POLY_DIVIDES_SUB-val"><B>POLY_DIVIDES_SUB</B></A>]  Theorem
      
      |- !p q r.
           p poly_divides q /\ p poly_divides q + r ==&gt; p poly_divides r
   
   [<A NAME="POLY_DIVIDES_SUB2-val"><B>POLY_DIVIDES_SUB2</B></A>]  Theorem
      
      |- !p q r.
           p poly_divides r /\ p poly_divides q + r ==&gt; p poly_divides q
   
   [<A NAME="POLY_DIVIDES_TRANS-val"><B>POLY_DIVIDES_TRANS</B></A>]  Theorem
      
      |- !p q r. p poly_divides q /\ q poly_divides r ==&gt; p poly_divides r
   
   [<A NAME="POLY_DIVIDES_ZERO-val"><B>POLY_DIVIDES_ZERO</B></A>]  Theorem
      
      |- !p q. (poly p = poly []) ==&gt; q poly_divides p
   
   [<A NAME="POLY_ENTIRE-val"><B>POLY_ENTIRE</B></A>]  Theorem
      
      |- !p q.
           (poly (p * q) = poly []) &lt;=&gt;
           (poly p = poly []) \/ (poly q = poly [])
   
   [<A NAME="POLY_ENTIRE_LEMMA-val"><B>POLY_ENTIRE_LEMMA</B></A>]  Theorem
      
      |- !p q.
           poly p &lt;&gt; poly [] /\ poly q &lt;&gt; poly [] ==&gt;
           poly (p * q) &lt;&gt; poly []
   
   [<A NAME="POLY_EXP-val"><B>POLY_EXP</B></A>]  Theorem
      
      |- !p n x. poly (p poly_exp n) x = poly p x pow n
   
   [<A NAME="POLY_EXP_ADD-val"><B>POLY_EXP_ADD</B></A>]  Theorem
      
      |- !d n p.
           poly (p poly_exp (n + d)) = poly (p poly_exp n * p poly_exp d)
   
   [<A NAME="POLY_EXP_DIVIDES-val"><B>POLY_EXP_DIVIDES</B></A>]  Theorem
      
      |- !p q m n.
           p poly_exp n poly_divides q /\ m &lt;= n ==&gt;
           p poly_exp m poly_divides q
   
   [<A NAME="POLY_EXP_EQ_0-val"><B>POLY_EXP_EQ_0</B></A>]  Theorem
      
      |- !p n.
           (poly (p poly_exp n) = poly []) &lt;=&gt; (poly p = poly []) /\ n &lt;&gt; 0
   
   [<A NAME="POLY_EXP_PRIME_EQ_0-val"><B>POLY_EXP_PRIME_EQ_0</B></A>]  Theorem
      
      |- !a n. poly ([a; 1] poly_exp n) &lt;&gt; poly []
   
   [<A NAME="POLY_IVT_NEG-val"><B>POLY_IVT_NEG</B></A>]  Theorem
      
      |- !p a b.
           a &lt; b /\ poly p a &gt; 0 /\ poly p b &lt; 0 ==&gt;
           ?x. a &lt; x /\ x &lt; b /\ (poly p x = 0)
   
   [<A NAME="POLY_IVT_POS-val"><B>POLY_IVT_POS</B></A>]  Theorem
      
      |- !p a b.
           a &lt; b /\ poly p a &lt; 0 /\ poly p b &gt; 0 ==&gt;
           ?x. a &lt; x /\ x &lt; b /\ (poly p x = 0)
   
   [<A NAME="POLY_LENGTH_MUL-val"><B>POLY_LENGTH_MUL</B></A>]  Theorem
      
      |- !q. LENGTH ([-a; 1] * q) = SUC (LENGTH q)
   
   [<A NAME="POLY_LINEAR_DIVIDES-val"><B>POLY_LINEAR_DIVIDES</B></A>]  Theorem
      
      |- !a p. (poly p a = 0) &lt;=&gt; (p = []) \/ ?q. p = [-a; 1] * q
   
   [<A NAME="POLY_LINEAR_REM-val"><B>POLY_LINEAR_REM</B></A>]  Theorem
      
      |- !t h. ?q r. h::t = [r] + [-a; 1] * q
   
   [<A NAME="POLY_MONO-val"><B>POLY_MONO</B></A>]  Theorem
      
      |- !x k p. abs x &lt;= k ==&gt; abs (poly p x) &lt;= poly (MAP abs p) k
   
   [<A NAME="POLY_MUL-val"><B>POLY_MUL</B></A>]  Theorem
      
      |- !x p1 p2. poly (p1 * p2) x = poly p1 x * poly p2 x
   
   [<A NAME="POLY_MUL_ASSOC-val"><B>POLY_MUL_ASSOC</B></A>]  Theorem
      
      |- !p q r. poly (p * (q * r)) = poly (p * q * r)
   
   [<A NAME="POLY_MUL_CLAUSES-val"><B>POLY_MUL_CLAUSES</B></A>]  Theorem
      
      |- ([] * p2 = []) /\ ([h1] * p2 = h1 ## p2) /\
         ((h1::k1::t1) * p2 = h1 ## p2 + (0::(k1::t1) * p2))
   
   [<A NAME="POLY_MUL_LCANCEL-val"><B>POLY_MUL_LCANCEL</B></A>]  Theorem
      
      |- !p q r.
           (poly (p * q) = poly (p * r)) &lt;=&gt;
           (poly p = poly []) \/ (poly q = poly r)
   
   [<A NAME="POLY_MVT-val"><B>POLY_MVT</B></A>]  Theorem
      
      |- !p a b.
           a &lt; b ==&gt;
           ?x.
             a &lt; x /\ x &lt; b /\
             (poly p b - poly p a = (b - a) * poly (diff p) x)
   
   [<A NAME="POLY_NEG-val"><B>POLY_NEG</B></A>]  Theorem
      
      |- !p x. poly (~p) x = -poly p x
   
   [<A NAME="POLY_NEG_CLAUSES-val"><B>POLY_NEG_CLAUSES</B></A>]  Theorem
      
      |- (~[] = []) /\ (~(h::t) = -h::~t)
   
   [<A NAME="POLY_NORMALIZE-val"><B>POLY_NORMALIZE</B></A>]  Theorem
      
      |- !p. poly (normalize p) = poly p
   
   [<A NAME="POLY_ORDER-val"><B>POLY_ORDER</B></A>]  Theorem
      
      |- !p a.
           poly p &lt;&gt; poly [] ==&gt;
           ?!n.
             [-a; 1] poly_exp n poly_divides p /\
             ~([-a; 1] poly_exp SUC n poly_divides p)
   
   [<A NAME="POLY_ORDER_EXISTS-val"><B>POLY_ORDER_EXISTS</B></A>]  Theorem
      
      |- !a d p.
           (LENGTH p = d) /\ poly p &lt;&gt; poly [] ==&gt;
           ?n.
             [-a; 1] poly_exp n poly_divides p /\
             ~([-a; 1] poly_exp SUC n poly_divides p)
   
   [<A NAME="POLY_PRIMES-val"><B>POLY_PRIMES</B></A>]  Theorem
      
      |- !a p q.
           [a; 1] poly_divides p * q &lt;=&gt;
           [a; 1] poly_divides p \/ [a; 1] poly_divides q
   
   [<A NAME="POLY_PRIME_EQ_0-val"><B>POLY_PRIME_EQ_0</B></A>]  Theorem
      
      |- !a. poly [a; 1] &lt;&gt; poly []
   
   [<A NAME="POLY_ROOTS_FINITE-val"><B>POLY_ROOTS_FINITE</B></A>]  Theorem
      
      |- !p.
           poly p &lt;&gt; poly [] &lt;=&gt;
           ?N i. !x. (poly p x = 0) ==&gt; ?n. n &lt; N /\ (x = i n)
   
   [<A NAME="POLY_ROOTS_FINITE_LEMMA-val"><B>POLY_ROOTS_FINITE_LEMMA</B></A>]  Theorem
      
      |- !p.
           poly p &lt;&gt; poly [] ==&gt;
           ?N i. !x. (poly p x = 0) ==&gt; ?n. n &lt; N /\ (x = i n)
   
   [<A NAME="POLY_ROOTS_FINITE_SET-val"><B>POLY_ROOTS_FINITE_SET</B></A>]  Theorem
      
      |- !p. poly p &lt;&gt; poly [] ==&gt; FINITE {x | poly p x = 0}
   
   [<A NAME="POLY_ROOTS_INDEX_LEMMA-val"><B>POLY_ROOTS_INDEX_LEMMA</B></A>]  Theorem
      
      |- !n p.
           poly p &lt;&gt; poly [] /\ (LENGTH p = n) ==&gt;
           ?i. !x. (poly p x = 0) ==&gt; ?m. m &lt;= n /\ (x = i m)
   
   [<A NAME="POLY_ROOTS_INDEX_LENGTH-val"><B>POLY_ROOTS_INDEX_LENGTH</B></A>]  Theorem
      
      |- !p.
           poly p &lt;&gt; poly [] ==&gt;
           ?i. !x. (poly p x = 0) ==&gt; ?n. n &lt;= LENGTH p /\ (x = i n)
   
   [<A NAME="POLY_SQUAREFREE_DECOMP-val"><B>POLY_SQUAREFREE_DECOMP</B></A>]  Theorem
      
      |- !p q d e r s.
           poly (diff p) &lt;&gt; poly [] /\ (poly p = poly (q * d)) /\
           (poly (diff p) = poly (e * d)) /\
           (poly d = poly (r * p + s * diff p)) ==&gt;
           rsquarefree q /\ !a. (poly q a = 0) &lt;=&gt; (poly p a = 0)
   
   [<A NAME="POLY_SQUAREFREE_DECOMP_ORDER-val"><B>POLY_SQUAREFREE_DECOMP_ORDER</B></A>]  Theorem
      
      |- !p q d e r s.
           poly (diff p) &lt;&gt; poly [] /\ (poly p = poly (q * d)) /\
           (poly (diff p) = poly (e * d)) /\
           (poly d = poly (r * p + s * diff p)) ==&gt;
           !a. poly_order a q = if poly_order a p = 0 then 0 else 1
   
   [<A NAME="POLY_ZERO-val"><B>POLY_ZERO</B></A>]  Theorem
      
      |- !p. (poly p = poly []) &lt;=&gt; EVERY (\c. c = 0) p
   
   [<A NAME="POLY_ZERO_LEMMA-val"><B>POLY_ZERO_LEMMA</B></A>]  Theorem
      
      |- !h t. (poly (h::t) = poly []) ==&gt; (h = 0) /\ (poly t = poly [])
   
   [<A NAME="RSQUAREFREE_DECOMP-val"><B>RSQUAREFREE_DECOMP</B></A>]  Theorem
      
      |- !p a.
           rsquarefree p /\ (poly p a = 0) ==&gt;
           ?q. (poly p = poly ([-a; 1] * q)) /\ poly q a &lt;&gt; 0
   
   [<A NAME="RSQUAREFREE_ROOTS-val"><B>RSQUAREFREE_ROOTS</B></A>]  Theorem
      
      |- !p.
           rsquarefree p &lt;=&gt; !a. ~((poly p a = 0) /\ (poly (diff p) a = 0))
   
   
*)
end

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/real/polyScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
