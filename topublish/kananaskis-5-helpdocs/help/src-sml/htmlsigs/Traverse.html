<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure Traverse</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure Traverse</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/simp/src/Traverse.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>(* =====================================================================
<A NAME="line2"></A> * FILE          : traverse.sig
<A NAME="line3"></A> * DESCRIPTION   : A programmable term traversal engine for hol90
<A NAME="line4"></A> *
<A NAME="line5"></A> * AUTHOR        : Donald Syme
<A NAME="line6"></A> * ===================================================================== *)
<A NAME="line7"></A>
<A NAME="line8"></A>signature Traverse =
<A NAME="line9"></A>sig
<A NAME="line10"></A>  include Abbrev
<A NAME="line11"></A>
<A NAME="line12"></A>   (* ---------------------------------------------------------------------
<A NAME="line13"></A>    * type context
<A NAME="line14"></A>    *
<A NAME="line15"></A>    * Each reducer collects the working context on its own.
<A NAME="line16"></A>    * A context object is the current state of a single reducer.
<A NAME="line17"></A>    * ---------------------------------------------------------------------*)
<A NAME="line18"></A>
<A NAME="line19"></A>  type context = exn (* well known SML hack to allow any kind of data *)
<A NAME="line20"></A>
<A NAME="line21"></A>   (* ---------------------------------------------------------------------
<A NAME="line22"></A>    * Reducers
<A NAME="line23"></A>    *   These are the things that get applied to terms during
<A NAME="line24"></A>    * traversal.  They prove theorems which state that the
<A NAME="line25"></A>    * current term reduces to a related
<A NAME="line26"></A>    *
<A NAME="line27"></A>    * Each reducer manages its own storage of the working context (of one
<A NAME="line28"></A>    * of the forms above - Nb. in SML exceptions are able to contain
<A NAME="line29"></A>    * any kind of data, so contexts can be any appropriate format.  This
<A NAME="line30"></A>    * is a hack, but it is the best way to get good data hiding in SML
<A NAME="line31"></A>    * without resorting to functors)
<A NAME="line32"></A>    *
<A NAME="line33"></A>    * The fields of a reducer are:
<A NAME="line34"></A>    *
<A NAME="line35"></A>    * apply:  This is the reducer itself.  The arguments passed by
<A NAME="line36"></A>    *   the traversal engine to the reduce routine are:
<A NAME="line37"></A>    *    solver:
<A NAME="line38"></A>    *      A continuation function, to be used if the reducer needs to
<A NAME="line39"></A>    *      solve some side conditions and want to continue traversing
<A NAME="line40"></A>    *      in order to do so.  The continuation invokes traversal
<A NAME="line41"></A>    *      under equality, then calls EQT_ELIM.
<A NAME="line42"></A>    *
<A NAME="line43"></A>    *      At the moment the continuation is primarily designed to
<A NAME="line44"></A>    *      be used to solve side conditions in context.
<A NAME="line45"></A>    *
<A NAME="line46"></A>    *      Note that this function is *not* the same as
<A NAME="line47"></A>    *      the congruence side condition solver.
<A NAME="line48"></A>    *
<A NAME="line49"></A>    *    context:
<A NAME="line50"></A>    *      The reducer's current view of the context, as
<A NAME="line51"></A>    *      collected by its "addcontext" function.
<A NAME="line52"></A>    *    term list:
<A NAME="line53"></A>    *      The current side condition stack, which grows as nested calls
<A NAME="line54"></A>    *      to the solver are made.
<A NAME="line55"></A>    *
<A NAME="line56"></A>    * addcontext: routine is invoked every time more context is added
<A NAME="line57"></A>    *   to the current environment by virtue of congruence routines.
<A NAME="line58"></A>    *
<A NAME="line59"></A>    * initial:  The inital context.
<A NAME="line60"></A>    * ---------------------------------------------------------------------*)
<A NAME="line61"></A>
<A NAME="line62"></A>  datatype reducer = REDUCER of {
<A NAME="line63"></A>         name : string option,
<A NAME="line64"></A>         initial: context,
<A NAME="line65"></A>         addcontext : context * thm list -&gt; context,
<A NAME="line66"></A>         apply: {solver:term list -&gt; term -&gt; thm,
<A NAME="line67"></A>                 context: context,
<A NAME="line68"></A>                 stack:term list,
<A NAME="line69"></A>     relation : Travrules.preorder} -&gt; conv
<A NAME="line70"></A>       }
<A NAME="line71"></A>
<A NAME="line72"></A>  val dest_reducer : reducer -&gt;
<A NAME="line73"></A>        {name : string option,
<A NAME="line74"></A>         initial: context,
<A NAME="line75"></A>         addcontext : context * thm list -&gt; context,
<A NAME="line76"></A>         apply: {solver:term list -&gt; term -&gt; thm,
<A NAME="line77"></A>                 context: context,
<A NAME="line78"></A>                 stack:term list,
<A NAME="line79"></A>         relation : Travrules.preorder} -&gt; conv}
<A NAME="line80"></A>
<A NAME="line81"></A> (* ----------------------------------------------------------------------
<A NAME="line82"></A>     TRAVERSE : {rewriters: reducer list,
<A NAME="line83"></A>                 dprocs: reducer list,
<A NAME="line84"></A>                 travrules: travrules,
<A NAME="line85"></A>                 relation: term,
<A NAME="line86"></A>                 limit : int option}
<A NAME="line87"></A>                -&gt; thm list -&gt; conv
<A NAME="line88"></A>
<A NAME="line89"></A>     Implements a procedure which tries to prove a term is related
<A NAME="line90"></A>     to a (simpler) term by the relation given in the travrules.
<A NAME="line91"></A>     This is done by traversing the term, applying the
<A NAME="line92"></A>     procedures specified in the travrules at certain subterms.
<A NAME="line93"></A>     The traversal strategy is similar to TOP_DEPTH_CONV.
<A NAME="line94"></A>
<A NAME="line95"></A>     The traversal has to be justified by congruence rules.
<A NAME="line96"></A>     These are also in the travrules.  See "Congprocs" for a more
<A NAME="line97"></A>     detailed description of congruence rules.
<A NAME="line98"></A>
<A NAME="line99"></A>     In the case of rewriting and simplification, the relation used is
<A NAME="line100"></A>     equality (--`$=`--).  However traversal can also be used with
<A NAME="line101"></A>     other congruences and preorders.
<A NAME="line102"></A>
<A NAME="line103"></A>     The behavious of TRAVERSE depends almost totally on what
<A NAME="line104"></A>     is contained in the input travrules.
<A NAME="line105"></A>
<A NAME="line106"></A>     The theorem list is a set of theorems to add initially as context
<A NAME="line107"></A>     to the traversal.
<A NAME="line108"></A>
<A NAME="line109"></A>     FAILURE CONDITIONS
<A NAME="line110"></A>
<A NAME="line111"></A>     TRAVERSE never fails, though it may diverge or raise an exception
<A NAME="line112"></A>     indicating that a term is unchanged by the traversal.
<A NAME="line113"></A>
<A NAME="line114"></A>     Bad congruence rules may cause very strange behaviour.
<A NAME="line115"></A>    ---------------------------------------------------------------------- *)
<A NAME="line116"></A>
<A NAME="line117"></A>   type traverse_data = {rewriters: reducer list,
<A NAME="line118"></A>                         limit : int option,
<A NAME="line119"></A>                         dprocs: reducer list,
<A NAME="line120"></A>                         travrules: Travrules.travrules,
<A NAME="line121"></A>                         relation: term};
<A NAME="line122"></A>
<A NAME="line123"></A>   val TRAVERSE : traverse_data -&gt; thm list -&gt; conv
<A NAME="line124"></A>
<A NAME="line125"></A>end (* sig *)
<A NAME="line126"></A>
</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/simp/src/Traverse.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
