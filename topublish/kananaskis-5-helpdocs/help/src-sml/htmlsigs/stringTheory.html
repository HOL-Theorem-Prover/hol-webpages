<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure stringTheory</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure stringTheory</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/string/stringScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>signature stringTheory =
<A NAME="line2"></A>sig
<A NAME="line3"></A>  type thm = Thm.thm
<A NAME="line4"></A>  
<A NAME="line5"></A>  (*  Definitions  *)
<A NAME="line6"></A>    val <A HREF="#DEST_STRING_def-val">DEST_STRING_def</A> : thm
<A NAME="line7"></A>    val <A HREF="#EXPLODE_def-val">EXPLODE_def</A> : thm
<A NAME="line8"></A>    val <A HREF="#EXTRACT_primitive_def-val">EXTRACT_primitive_def</A> : thm
<A NAME="line9"></A>    val <A HREF="#FIELDS_curried_def-val">FIELDS_curried_def</A> : thm
<A NAME="line10"></A>    val <A HREF="#FIELDS_tupled_primitive_def-val">FIELDS_tupled_primitive_def</A> : thm
<A NAME="line11"></A>    val <A HREF="#IMPLODE_def-val">IMPLODE_def</A> : thm
<A NAME="line12"></A>    val <A HREF="#STR_def-val">STR_def</A> : thm
<A NAME="line13"></A>    val <A HREF="#SUBSTRING_def-val">SUBSTRING_def</A> : thm
<A NAME="line14"></A>    val <A HREF="#SUB_def-val">SUB_def</A> : thm
<A NAME="line15"></A>    val <A HREF="#TOKENS_curried_def-val">TOKENS_curried_def</A> : thm
<A NAME="line16"></A>    val <A HREF="#TOKENS_tupled_primitive_def-val">TOKENS_tupled_primitive_def</A> : thm
<A NAME="line17"></A>    val <A HREF="#TRANSLATE_def-val">TRANSLATE_def</A> : thm
<A NAME="line18"></A>    val <A HREF="#char_BIJ-val">char_BIJ</A> : thm
<A NAME="line19"></A>    val <A HREF="#char_TY_DEF-val">char_TY_DEF</A> : thm
<A NAME="line20"></A>    val <A HREF="#char_ge_def-val">char_ge_def</A> : thm
<A NAME="line21"></A>    val <A HREF="#char_gt_def-val">char_gt_def</A> : thm
<A NAME="line22"></A>    val <A HREF="#char_le_def-val">char_le_def</A> : thm
<A NAME="line23"></A>    val <A HREF="#char_lt_def-val">char_lt_def</A> : thm
<A NAME="line24"></A>    val <A HREF="#char_size_def-val">char_size_def</A> : thm
<A NAME="line25"></A>    val <A HREF="#isAlphaNum_def-val">isAlphaNum_def</A> : thm
<A NAME="line26"></A>    val <A HREF="#isAlpha_def-val">isAlpha_def</A> : thm
<A NAME="line27"></A>    val <A HREF="#isAscii_def-val">isAscii_def</A> : thm
<A NAME="line28"></A>    val <A HREF="#isCntrl_def-val">isCntrl_def</A> : thm
<A NAME="line29"></A>    val <A HREF="#isDigit_def-val">isDigit_def</A> : thm
<A NAME="line30"></A>    val <A HREF="#isGraph_def-val">isGraph_def</A> : thm
<A NAME="line31"></A>    val <A HREF="#isHexDigit_def-val">isHexDigit_def</A> : thm
<A NAME="line32"></A>    val <A HREF="#isLower_def-val">isLower_def</A> : thm
<A NAME="line33"></A>    val <A HREF="#isPrint_def-val">isPrint_def</A> : thm
<A NAME="line34"></A>    val <A HREF="#isPunct_def-val">isPunct_def</A> : thm
<A NAME="line35"></A>    val <A HREF="#isSpace_def-val">isSpace_def</A> : thm
<A NAME="line36"></A>    val <A HREF="#isUpper_def-val">isUpper_def</A> : thm
<A NAME="line37"></A>    val <A HREF="#string_ge_def-val">string_ge_def</A> : thm
<A NAME="line38"></A>    val <A HREF="#string_gt_def-val">string_gt_def</A> : thm
<A NAME="line39"></A>    val <A HREF="#string_le_def-val">string_le_def</A> : thm
<A NAME="line40"></A>    val <A HREF="#string_lt_curried_def-val">string_lt_curried_def</A> : thm
<A NAME="line41"></A>    val <A HREF="#string_lt_tupled_primitive_def-val">string_lt_tupled_primitive_def</A> : thm
<A NAME="line42"></A>    val <A HREF="#toLower_def-val">toLower_def</A> : thm
<A NAME="line43"></A>    val <A HREF="#toUpper_def-val">toUpper_def</A> : thm
<A NAME="line44"></A>  
<A NAME="line45"></A>  (*  Theorems  *)
<A NAME="line46"></A>    val <A HREF="#CHAR_EQ_THM-val">CHAR_EQ_THM</A> : thm
<A NAME="line47"></A>    val <A HREF="#CHAR_INDUCT_THM-val">CHAR_INDUCT_THM</A> : thm
<A NAME="line48"></A>    val <A HREF="#CHR_11-val">CHR_11</A> : thm
<A NAME="line49"></A>    val <A HREF="#CHR_ONTO-val">CHR_ONTO</A> : thm
<A NAME="line50"></A>    val <A HREF="#CHR_ORD-val">CHR_ORD</A> : thm
<A NAME="line51"></A>    val <A HREF="#DEST_STRING_LEMS-val">DEST_STRING_LEMS</A> : thm
<A NAME="line52"></A>    val <A HREF="#EXPLODE_11-val">EXPLODE_11</A> : thm
<A NAME="line53"></A>    val <A HREF="#EXPLODE_DEST_STRING-val">EXPLODE_DEST_STRING</A> : thm
<A NAME="line54"></A>    val <A HREF="#EXPLODE_EQNS-val">EXPLODE_EQNS</A> : thm
<A NAME="line55"></A>    val <A HREF="#EXPLODE_EQ_NIL-val">EXPLODE_EQ_NIL</A> : thm
<A NAME="line56"></A>    val <A HREF="#EXPLODE_EQ_THM-val">EXPLODE_EQ_THM</A> : thm
<A NAME="line57"></A>    val <A HREF="#EXPLODE_IMPLODE-val">EXPLODE_IMPLODE</A> : thm
<A NAME="line58"></A>    val <A HREF="#EXPLODE_ONTO-val">EXPLODE_ONTO</A> : thm
<A NAME="line59"></A>    val <A HREF="#EXTRACT_def-val">EXTRACT_def</A> : thm
<A NAME="line60"></A>    val <A HREF="#EXTRACT_ind-val">EXTRACT_ind</A> : thm
<A NAME="line61"></A>    val <A HREF="#FIELDS_def-val">FIELDS_def</A> : thm
<A NAME="line62"></A>    val <A HREF="#FIELDS_ind-val">FIELDS_ind</A> : thm
<A NAME="line63"></A>    val <A HREF="#IMPLODE_11-val">IMPLODE_11</A> : thm
<A NAME="line64"></A>    val <A HREF="#IMPLODE_EQNS-val">IMPLODE_EQNS</A> : thm
<A NAME="line65"></A>    val <A HREF="#IMPLODE_EQ_EMPTYSTRING-val">IMPLODE_EQ_EMPTYSTRING</A> : thm
<A NAME="line66"></A>    val <A HREF="#IMPLODE_EQ_THM-val">IMPLODE_EQ_THM</A> : thm
<A NAME="line67"></A>    val <A HREF="#IMPLODE_EXPLODE-val">IMPLODE_EXPLODE</A> : thm
<A NAME="line68"></A>    val <A HREF="#IMPLODE_EXPLODE_I-val">IMPLODE_EXPLODE_I</A> : thm
<A NAME="line69"></A>    val <A HREF="#IMPLODE_ONTO-val">IMPLODE_ONTO</A> : thm
<A NAME="line70"></A>    val <A HREF="#IMPLODE_STRING-val">IMPLODE_STRING</A> : thm
<A NAME="line71"></A>    val <A HREF="#ORD_11-val">ORD_11</A> : thm
<A NAME="line72"></A>    val <A HREF="#ORD_BOUND-val">ORD_BOUND</A> : thm
<A NAME="line73"></A>    val <A HREF="#ORD_CHR-val">ORD_CHR</A> : thm
<A NAME="line74"></A>    val <A HREF="#ORD_CHR_COMPUTE-val">ORD_CHR_COMPUTE</A> : thm
<A NAME="line75"></A>    val <A HREF="#ORD_CHR_RWT-val">ORD_CHR_RWT</A> : thm
<A NAME="line76"></A>    val <A HREF="#ORD_ONTO-val">ORD_ONTO</A> : thm
<A NAME="line77"></A>    val <A HREF="#STRCAT-val">STRCAT</A> : thm
<A NAME="line78"></A>    val <A HREF="#STRCAT_11-val">STRCAT_11</A> : thm
<A NAME="line79"></A>    val <A HREF="#STRCAT_ACYCLIC-val">STRCAT_ACYCLIC</A> : thm
<A NAME="line80"></A>    val <A HREF="#STRCAT_ASSOC-val">STRCAT_ASSOC</A> : thm
<A NAME="line81"></A>    val <A HREF="#STRCAT_EQNS-val">STRCAT_EQNS</A> : thm
<A NAME="line82"></A>    val <A HREF="#STRCAT_EQ_EMPTY-val">STRCAT_EQ_EMPTY</A> : thm
<A NAME="line83"></A>    val <A HREF="#STRCAT_EXPLODE-val">STRCAT_EXPLODE</A> : thm
<A NAME="line84"></A>    val <A HREF="#STRCAT_def-val">STRCAT_def</A> : thm
<A NAME="line85"></A>    val <A HREF="#STRING_ACYCLIC-val">STRING_ACYCLIC</A> : thm
<A NAME="line86"></A>    val <A HREF="#STRLEN_CAT-val">STRLEN_CAT</A> : thm
<A NAME="line87"></A>    val <A HREF="#STRLEN_DEF-val">STRLEN_DEF</A> : thm
<A NAME="line88"></A>    val <A HREF="#STRLEN_EQ_0-val">STRLEN_EQ_0</A> : thm
<A NAME="line89"></A>    val <A HREF="#STRLEN_EXPLODE_THM-val">STRLEN_EXPLODE_THM</A> : thm
<A NAME="line90"></A>    val <A HREF="#STRLEN_THM-val">STRLEN_THM</A> : thm
<A NAME="line91"></A>    val <A HREF="#TOKENS_def-val">TOKENS_def</A> : thm
<A NAME="line92"></A>    val <A HREF="#TOKENS_ind-val">TOKENS_ind</A> : thm
<A NAME="line93"></A>    val <A HREF="#char_nchotomy-val">char_nchotomy</A> : thm
<A NAME="line94"></A>    val <A HREF="#isPREFIX_DEF-val">isPREFIX_DEF</A> : thm
<A NAME="line95"></A>    val <A HREF="#isPREFIX_IND-val">isPREFIX_IND</A> : thm
<A NAME="line96"></A>    val <A HREF="#isPREFIX_STRCAT-val">isPREFIX_STRCAT</A> : thm
<A NAME="line97"></A>    val <A HREF="#ranged_char_nchotomy-val">ranged_char_nchotomy</A> : thm
<A NAME="line98"></A>    val <A HREF="#string_lt_def-val">string_lt_def</A> : thm
<A NAME="line99"></A>    val <A HREF="#string_lt_ind-val">string_lt_ind</A> : thm
<A NAME="line100"></A>  
<A NAME="line101"></A>  val string_grammars : type_grammar.grammar * term_grammar.grammar
<A NAME="line102"></A>  
<A NAME="line103"></A>  val string_rwts : simpLib.ssfrag
<A NAME="line104"></A>(*
   [rich_list] Parent theory of "string"
   
   [<A NAME="DEST_STRING_def-val"><B>DEST_STRING_def</B></A>]  Definition
      
      |- (DEST_STRING "" = NONE) /\
         !c rst. DEST_STRING (STRING c rst) = SOME (c,rst)
   
   [<A NAME="EXPLODE_def-val"><B>EXPLODE_def</B></A>]  Definition
      
      |- (EXPLODE "" = "") /\
         !c s. EXPLODE (STRING c s) = STRING c (EXPLODE s)
   
   [<A NAME="EXTRACT_primitive_def-val"><B>EXTRACT_primitive_def</B></A>]  Definition
      
      |- EXTRACT =
         WFREC (@R. WF R)
           (\EXTRACT a.
              case a of
                 (s,i,NONE) -&gt; I (SUBSTRING (s,i,STRLEN s - i))
              || (s,i,SOME n) -&gt; I (SUBSTRING (s,i,n)))
   
   [<A NAME="FIELDS_curried_def-val"><B>FIELDS_curried_def</B></A>]  Definition
      
      |- !x x1. FIELDS x x1 = FIELDS_tupled (x,x1)
   
   [<A NAME="FIELDS_tupled_primitive_def-val"><B>FIELDS_tupled_primitive_def</B></A>]  Definition
      
      |- FIELDS_tupled =
         WFREC
           (@R.
              WF R /\
              (!t h P l r.
                 ((l,r) = SPLITP P (STRING h t)) /\ NULL l ==&gt;
                 R (P,TL r) (P,STRING h t)) /\
              !t h P l r.
                ((l,r) = SPLITP P (STRING h t)) /\ ~NULL l /\ ~NULL r ==&gt;
                R (P,TL r) (P,STRING h t))
           (\FIELDS_tupled a.
              case a of
                 (P,"") -&gt; I [""]
              || (P,STRING h t) -&gt;
                   I
                     (let (l,r) = SPLITP P (STRING h t) in
                        if NULL l then
                          ""::FIELDS_tupled (P,TL r)
                        else
                          if NULL r then
                            [l]
                          else
                            l::FIELDS_tupled (P,TL r)))
   
   [<A NAME="IMPLODE_def-val"><B>IMPLODE_def</B></A>]  Definition
      
      |- (IMPLODE "" = "") /\
         !c cs. IMPLODE (STRING c cs) = STRING c (IMPLODE cs)
   
   [<A NAME="STR_def-val"><B>STR_def</B></A>]  Definition
      
      |- !c. STR c = STRING c ""
   
   [<A NAME="SUBSTRING_def-val"><B>SUBSTRING_def</B></A>]  Definition
      
      |- !s i n. SUBSTRING (s,i,n) = SEG n i s
   
   [<A NAME="SUB_def-val"><B>SUB_def</B></A>]  Definition
      
      |- !s n. SUB (s,n) = EL n s
   
   [<A NAME="TOKENS_curried_def-val"><B>TOKENS_curried_def</B></A>]  Definition
      
      |- !x x1. TOKENS x x1 = TOKENS_tupled (x,x1)
   
   [<A NAME="TOKENS_tupled_primitive_def-val"><B>TOKENS_tupled_primitive_def</B></A>]  Definition
      
      |- TOKENS_tupled =
         WFREC
           (@R.
              WF R /\
              (!t h P l r.
                 ((l,r) = SPLITP P (STRING h t)) /\ NULL l ==&gt;
                 R (P,TL r) (P,STRING h t)) /\
              !t h P l r.
                ((l,r) = SPLITP P (STRING h t)) /\ ~NULL l ==&gt;
                R (P,r) (P,STRING h t))
           (\TOKENS_tupled a.
              case a of
                 (P,"") -&gt; I []
              || (P,STRING h t) -&gt;
                   I
                     (let (l,r) = SPLITP P (STRING h t) in
                        if NULL l then
                          TOKENS_tupled (P,TL r)
                        else
                          l::TOKENS_tupled (P,r)))
   
   [<A NAME="TRANSLATE_def-val"><B>TRANSLATE_def</B></A>]  Definition
      
      |- !f s. TRANSLATE f s = CONCAT (MAP f s)
   
   [<A NAME="char_BIJ-val"><B>char_BIJ</B></A>]  Definition
      
      |- (!a. CHR (ORD a) = a) /\ !r. (\n. n &lt; 256) r &lt;=&gt; (ORD (CHR r) = r)
   
   [<A NAME="char_TY_DEF-val"><B>char_TY_DEF</B></A>]  Definition
      
      |- ?rep. TYPE_DEFINITION (\n. n &lt; 256) rep
   
   [<A NAME="char_ge_def-val"><B>char_ge_def</B></A>]  Definition
      
      |- !a b. a &gt;= b &lt;=&gt; ORD a &gt;= ORD b
   
   [<A NAME="char_gt_def-val"><B>char_gt_def</B></A>]  Definition
      
      |- !a b. a &gt; b &lt;=&gt; ORD a &gt; ORD b
   
   [<A NAME="char_le_def-val"><B>char_le_def</B></A>]  Definition
      
      |- !a b. a &lt;= b &lt;=&gt; ORD a &lt;= ORD b
   
   [<A NAME="char_lt_def-val"><B>char_lt_def</B></A>]  Definition
      
      |- !a b. a &lt; b &lt;=&gt; ORD a &lt; ORD b
   
   [<A NAME="char_size_def-val"><B>char_size_def</B></A>]  Definition
      
      |- !c. char_size c = 0
   
   [<A NAME="isAlphaNum_def-val"><B>isAlphaNum_def</B></A>]  Definition
      
      |- !c. isAlphaNum c &lt;=&gt; isAlpha c \/ isDigit c
   
   [<A NAME="isAlpha_def-val"><B>isAlpha_def</B></A>]  Definition
      
      |- !c. isAlpha c &lt;=&gt; isLower c \/ isUpper c
   
   [<A NAME="isAscii_def-val"><B>isAscii_def</B></A>]  Definition
      
      |- !c. isAscii c &lt;=&gt; ORD c &lt;= 127
   
   [<A NAME="isCntrl_def-val"><B>isCntrl_def</B></A>]  Definition
      
      |- !c. isCntrl c &lt;=&gt; ORD c &lt; 32 \/ 127 &lt;= ORD c
   
   [<A NAME="isDigit_def-val"><B>isDigit_def</B></A>]  Definition
      
      |- !c. isDigit c &lt;=&gt; 48 &lt;= ORD c /\ ORD c &lt;= 57
   
   [<A NAME="isGraph_def-val"><B>isGraph_def</B></A>]  Definition
      
      |- !c. isGraph c &lt;=&gt; isPrint c /\ ~isSpace c
   
   [<A NAME="isHexDigit_def-val"><B>isHexDigit_def</B></A>]  Definition
      
      |- !c.
           isHexDigit c &lt;=&gt;
           48 &lt;= ORD c /\ ORD c &lt;= 57 \/ 97 &lt;= ORD c /\ ORD c &lt;= 102 \/
           65 &lt;= ORD c /\ ORD c &lt;= 70
   
   [<A NAME="isLower_def-val"><B>isLower_def</B></A>]  Definition
      
      |- !c. isLower c &lt;=&gt; 97 &lt;= ORD c /\ ORD c &lt;= 122
   
   [<A NAME="isPrint_def-val"><B>isPrint_def</B></A>]  Definition
      
      |- !c. isPrint c &lt;=&gt; 32 &lt;= ORD c /\ ORD c &lt; 127
   
   [<A NAME="isPunct_def-val"><B>isPunct_def</B></A>]  Definition
      
      |- !c. isPunct c &lt;=&gt; isGraph c /\ ~isAlphaNum c
   
   [<A NAME="isSpace_def-val"><B>isSpace_def</B></A>]  Definition
      
      |- !c. isSpace c &lt;=&gt; (ORD c = 32) \/ 9 &lt;= ORD c /\ ORD c &lt;= 13
   
   [<A NAME="isUpper_def-val"><B>isUpper_def</B></A>]  Definition
      
      |- !c. isUpper c &lt;=&gt; 65 &lt;= ORD c /\ ORD c &lt;= 90
   
   [<A NAME="string_ge_def-val"><B>string_ge_def</B></A>]  Definition
      
      |- !s1 s2. s1 &gt;= s2 &lt;=&gt; s2 &lt;= s1
   
   [<A NAME="string_gt_def-val"><B>string_gt_def</B></A>]  Definition
      
      |- !s1 s2. s1 &gt; s2 &lt;=&gt; s2 &lt; s1
   
   [<A NAME="string_le_def-val"><B>string_le_def</B></A>]  Definition
      
      |- !s1 s2. s1 &lt;= s2 &lt;=&gt; (s1 = s2) \/ s1 &lt; s2
   
   [<A NAME="string_lt_curried_def-val"><B>string_lt_curried_def</B></A>]  Definition
      
      |- !x x1. x &lt; x1 &lt;=&gt; string_lt_tupled (x,x1)
   
   [<A NAME="string_lt_tupled_primitive_def-val"><B>string_lt_tupled_primitive_def</B></A>]  Definition
      
      |- string_lt_tupled =
         WFREC
           (@R.
              WF R /\ !c2 c1 s2 s1. R (s1,s2) (STRING c1 s1,STRING c2 s2))
           (\string_lt_tupled a.
              case a of
                 ("","") -&gt; I F
              || ("",STRING c s) -&gt; I T
              || (STRING c1 s1,"") -&gt; I F
              || (STRING c1 s1,STRING c2 s2) -&gt;
                   I (c1 &lt; c2 \/ (c1 = c2) /\ string_lt_tupled (s1,s2)))
   
   [<A NAME="toLower_def-val"><B>toLower_def</B></A>]  Definition
      
      |- !c. toLower c = if isUpper c then CHR (ORD c + 32) else c
   
   [<A NAME="toUpper_def-val"><B>toUpper_def</B></A>]  Definition
      
      |- !c. toUpper c = if isLower c then CHR (ORD c - 32) else c
   
   [<A NAME="CHAR_EQ_THM-val"><B>CHAR_EQ_THM</B></A>]  Theorem
      
      |- !c1 c2. (c1 = c2) &lt;=&gt; (ORD c1 = ORD c2)
   
   [<A NAME="CHAR_INDUCT_THM-val"><B>CHAR_INDUCT_THM</B></A>]  Theorem
      
      |- !P. (!n. n &lt; 256 ==&gt; P (CHR n)) ==&gt; !c. P c
   
   [<A NAME="CHR_11-val"><B>CHR_11</B></A>]  Theorem
      
      |- !r r'. r &lt; 256 ==&gt; r' &lt; 256 ==&gt; ((CHR r = CHR r') &lt;=&gt; (r = r'))
   
   [<A NAME="CHR_ONTO-val"><B>CHR_ONTO</B></A>]  Theorem
      
      |- !a. ?r. (a = CHR r) /\ r &lt; 256
   
   [<A NAME="CHR_ORD-val"><B>CHR_ORD</B></A>]  Theorem
      
      |- !a. CHR (ORD a) = a
   
   [<A NAME="DEST_STRING_LEMS-val"><B>DEST_STRING_LEMS</B></A>]  Theorem
      
      |- !s.
           ((DEST_STRING s = NONE) &lt;=&gt; (s = "")) /\
           ((DEST_STRING s = SOME (c,t)) &lt;=&gt; (s = STRING c t))
   
   [<A NAME="EXPLODE_11-val"><B>EXPLODE_11</B></A>]  Theorem
      
      |- (EXPLODE s1 = EXPLODE s2) &lt;=&gt; (s1 = s2)
   
   [<A NAME="EXPLODE_DEST_STRING-val"><B>EXPLODE_DEST_STRING</B></A>]  Theorem
      
      |- !s.
           EXPLODE s =
           case DEST_STRING s of
              NONE -&gt; ""
           || SOME (c,t) -&gt; STRING c (EXPLODE t)
   
   [<A NAME="EXPLODE_EQNS-val"><B>EXPLODE_EQNS</B></A>]  Theorem
      
      |- (EXPLODE "" = "") /\
         !c s. EXPLODE (STRING c s) = STRING c (EXPLODE s)
   
   [<A NAME="EXPLODE_EQ_NIL-val"><B>EXPLODE_EQ_NIL</B></A>]  Theorem
      
      |- ((EXPLODE s = "") &lt;=&gt; (s = "")) /\ (("" = EXPLODE s) &lt;=&gt; (s = ""))
   
   [<A NAME="EXPLODE_EQ_THM-val"><B>EXPLODE_EQ_THM</B></A>]  Theorem
      
      |- !s h t.
           ((STRING h t = EXPLODE s) &lt;=&gt; (s = STRING h (IMPLODE t))) /\
           ((EXPLODE s = STRING h t) &lt;=&gt; (s = STRING h (IMPLODE t)))
   
   [<A NAME="EXPLODE_IMPLODE-val"><B>EXPLODE_IMPLODE</B></A>]  Theorem
      
      |- EXPLODE (IMPLODE cs) = cs
   
   [<A NAME="EXPLODE_ONTO-val"><B>EXPLODE_ONTO</B></A>]  Theorem
      
      |- !cs. ?s. cs = EXPLODE s
   
   [<A NAME="EXTRACT_def-val"><B>EXTRACT_def</B></A>]  Theorem
      
      |- (EXTRACT (s,i,NONE) = SUBSTRING (s,i,STRLEN s - i)) /\
         (EXTRACT (s,i,SOME n) = SUBSTRING (s,i,n))
   
   [<A NAME="EXTRACT_ind-val"><B>EXTRACT_ind</B></A>]  Theorem
      
      |- !P.
           (!s i. P (s,i,NONE)) /\ (!s i n. P (s,i,SOME n)) ==&gt;
           !v v1 v2. P (v,v1,v2)
   
   [<A NAME="FIELDS_def-val"><B>FIELDS_def</B></A>]  Theorem
      
      |- (FIELDS P "" = [""]) /\
         (FIELDS P (STRING h t) =
          (let (l,r) = SPLITP P (STRING h t) in
             if NULL l then
               ""::FIELDS P (TL r)
             else
               if NULL r then [l] else l::FIELDS P (TL r)))
   
   [<A NAME="FIELDS_ind-val"><B>FIELDS_ind</B></A>]  Theorem
      
      |- !P'.
           (!P. P' P "") /\
           (!P h t.
              (!l r.
                 ((l,r) = SPLITP P (STRING h t)) /\ NULL l ==&gt;
                 P' P (TL r)) /\
              (!l r.
                 ((l,r) = SPLITP P (STRING h t)) /\ ~NULL l /\ ~NULL r ==&gt;
                 P' P (TL r)) ==&gt;
              P' P (STRING h t)) ==&gt;
           !v v1. P' v v1
   
   [<A NAME="IMPLODE_11-val"><B>IMPLODE_11</B></A>]  Theorem
      
      |- (IMPLODE cs1 = IMPLODE cs2) &lt;=&gt; (cs1 = cs2)
   
   [<A NAME="IMPLODE_EQNS-val"><B>IMPLODE_EQNS</B></A>]  Theorem
      
      |- (IMPLODE "" = "") /\
         !c cs. IMPLODE (STRING c cs) = STRING c (IMPLODE cs)
   
   [<A NAME="IMPLODE_EQ_EMPTYSTRING-val"><B>IMPLODE_EQ_EMPTYSTRING</B></A>]  Theorem
      
      |- ((IMPLODE l = "") &lt;=&gt; (l = "")) /\ (("" = IMPLODE l) &lt;=&gt; (l = ""))
   
   [<A NAME="IMPLODE_EQ_THM-val"><B>IMPLODE_EQ_THM</B></A>]  Theorem
      
      |- !c s l.
           ((STRING c s = IMPLODE l) &lt;=&gt; (l = STRING c (EXPLODE s))) /\
           ((IMPLODE l = STRING c s) &lt;=&gt; (l = STRING c (EXPLODE s)))
   
   [<A NAME="IMPLODE_EXPLODE-val"><B>IMPLODE_EXPLODE</B></A>]  Theorem
      
      |- IMPLODE (EXPLODE s) = s
   
   [<A NAME="IMPLODE_EXPLODE_I-val"><B>IMPLODE_EXPLODE_I</B></A>]  Theorem
      
      |- (EXPLODE s = s) /\ (IMPLODE s = s)
   
   [<A NAME="IMPLODE_ONTO-val"><B>IMPLODE_ONTO</B></A>]  Theorem
      
      |- !s. ?cs. s = IMPLODE cs
   
   [<A NAME="IMPLODE_STRING-val"><B>IMPLODE_STRING</B></A>]  Theorem
      
      |- !clist. IMPLODE clist = FOLDR STRING "" clist
   
   [<A NAME="ORD_11-val"><B>ORD_11</B></A>]  Theorem
      
      |- !a a'. (ORD a = ORD a') &lt;=&gt; (a = a')
   
   [<A NAME="ORD_BOUND-val"><B>ORD_BOUND</B></A>]  Theorem
      
      |- !c. ORD c &lt; 256
   
   [<A NAME="ORD_CHR-val"><B>ORD_CHR</B></A>]  Theorem
      
      |- !r. r &lt; 256 &lt;=&gt; (ORD (CHR r) = r)
   
   [<A NAME="ORD_CHR_COMPUTE-val"><B>ORD_CHR_COMPUTE</B></A>]  Theorem
      
      |- !n. ORD (CHR n) = if n &lt; 256 then n else FAIL ORD &gt; 255 (CHR n)
   
   [<A NAME="ORD_CHR_RWT-val"><B>ORD_CHR_RWT</B></A>]  Theorem
      
      |- !r. r &lt; 256 ==&gt; (ORD (CHR r) = r)
   
   [<A NAME="ORD_ONTO-val"><B>ORD_ONTO</B></A>]  Theorem
      
      |- !r. r &lt; 256 &lt;=&gt; ?a. r = ORD a
   
   [<A NAME="STRCAT-val"><B>STRCAT</B></A>]  Theorem
      
      |- STRCAT s1 s2 = STRCAT s1 s2
   
   [<A NAME="STRCAT_11-val"><B>STRCAT_11</B></A>]  Theorem
      
      |- (!l1 l2 l3. (STRCAT l1 l2 = STRCAT l1 l3) &lt;=&gt; (l2 = l3)) /\
         !l1 l2 l3. (STRCAT l2 l1 = STRCAT l3 l1) &lt;=&gt; (l2 = l3)
   
   [<A NAME="STRCAT_ACYCLIC-val"><B>STRCAT_ACYCLIC</B></A>]  Theorem
      
      |- !s s1.
           ((s = STRCAT s s1) &lt;=&gt; (s1 = "")) /\
           ((s = STRCAT s1 s) &lt;=&gt; (s1 = ""))
   
   [<A NAME="STRCAT_ASSOC-val"><B>STRCAT_ASSOC</B></A>]  Theorem
      
      |- !l1 l2 l3. STRCAT l1 (STRCAT l2 l3) = STRCAT (STRCAT l1 l2) l3
   
   [<A NAME="STRCAT_EQNS-val"><B>STRCAT_EQNS</B></A>]  Theorem
      
      |- (STRCAT "" s = s) /\ (STRCAT s "" = s) /\
         (STRCAT (STRING c s1) s2 = STRING c (STRCAT s1 s2))
   
   [<A NAME="STRCAT_EQ_EMPTY-val"><B>STRCAT_EQ_EMPTY</B></A>]  Theorem
      
      |- !l1 l2. (STRCAT l1 l2 = "") &lt;=&gt; (l1 = "") /\ (l2 = "")
   
   [<A NAME="STRCAT_EXPLODE-val"><B>STRCAT_EXPLODE</B></A>]  Theorem
      
      |- !s1 s2. STRCAT s1 s2 = FOLDR STRING s2 (EXPLODE s1)
   
   [<A NAME="STRCAT_def-val"><B>STRCAT_def</B></A>]  Theorem
      
      |- (!l. STRCAT "" l = l) /\
         !l1 l2 x. STRCAT (STRING x l1) l2 = STRING x (STRCAT l1 l2)
   
   [<A NAME="STRING_ACYCLIC-val"><B>STRING_ACYCLIC</B></A>]  Theorem
      
      |- !s c. STRING c s &lt;&gt; s /\ s &lt;&gt; STRING c s
   
   [<A NAME="STRLEN_CAT-val"><B>STRLEN_CAT</B></A>]  Theorem
      
      |- !l1 l2. STRLEN (STRCAT l1 l2) = STRLEN l1 + STRLEN l2
   
   [<A NAME="STRLEN_DEF-val"><B>STRLEN_DEF</B></A>]  Theorem
      
      |- (STRLEN "" = 0) /\ !x l. STRLEN (STRING x l) = SUC (STRLEN l)
   
   [<A NAME="STRLEN_EQ_0-val"><B>STRLEN_EQ_0</B></A>]  Theorem
      
      |- !l. (STRLEN l = 0) &lt;=&gt; (l = "")
   
   [<A NAME="STRLEN_EXPLODE_THM-val"><B>STRLEN_EXPLODE_THM</B></A>]  Theorem
      
      |- STRLEN s = STRLEN (EXPLODE s)
   
   [<A NAME="STRLEN_THM-val"><B>STRLEN_THM</B></A>]  Theorem
      
      |- (STRLEN "" = 0) /\ !x l. STRLEN (STRING x l) = SUC (STRLEN l)
   
   [<A NAME="TOKENS_def-val"><B>TOKENS_def</B></A>]  Theorem
      
      |- (TOKENS P "" = []) /\
         (TOKENS P (STRING h t) =
          (let (l,r) = SPLITP P (STRING h t) in
             if NULL l then TOKENS P (TL r) else l::TOKENS P r))
   
   [<A NAME="TOKENS_ind-val"><B>TOKENS_ind</B></A>]  Theorem
      
      |- !P'.
           (!P. P' P "") /\
           (!P h t.
              (!l r.
                 ((l,r) = SPLITP P (STRING h t)) /\ NULL l ==&gt;
                 P' P (TL r)) /\
              (!l r.
                 ((l,r) = SPLITP P (STRING h t)) /\ ~NULL l ==&gt; P' P r) ==&gt;
              P' P (STRING h t)) ==&gt;
           !v v1. P' v v1
   
   [<A NAME="char_nchotomy-val"><B>char_nchotomy</B></A>]  Theorem
      
      |- !c. ?n. c = CHR n
   
   [<A NAME="isPREFIX_DEF-val"><B>isPREFIX_DEF</B></A>]  Theorem
      
      |- !s1 s2.
           s1 &lt;&lt;= s2 &lt;=&gt;
           case (DEST_STRING s1,DEST_STRING s2) of
              (NONE,v1) -&gt; T
           || (SOME (c1,t1),NONE) -&gt; F
           || (SOME (c1,t1),SOME (c2,t2)) -&gt; (c1 = c2) /\ t1 &lt;&lt;= t2
   
   [<A NAME="isPREFIX_IND-val"><B>isPREFIX_IND</B></A>]  Theorem
      
      |- !P.
           (!s1 s2.
              (!c t1 t2.
                 (DEST_STRING s1 = SOME (c,t1)) /\
                 (DEST_STRING s2 = SOME (c,t2)) ==&gt;
                 P t1 t2) ==&gt;
              P s1 s2) ==&gt;
           !v v1. P v v1
   
   [<A NAME="isPREFIX_STRCAT-val"><B>isPREFIX_STRCAT</B></A>]  Theorem
      
      |- !s1 s2. s1 &lt;&lt;= s2 &lt;=&gt; ?s3. s2 = STRCAT s1 s3
   
   [<A NAME="ranged_char_nchotomy-val"><B>ranged_char_nchotomy</B></A>]  Theorem
      
      |- !c. ?n. (c = CHR n) /\ n &lt; 256
   
   [<A NAME="string_lt_def-val"><B>string_lt_def</B></A>]  Theorem
      
      |- ("" &lt; "" &lt;=&gt; F) /\ (!v3 v2. STRING v2 v3 &lt; "" &lt;=&gt; F) /\
         (!s c. "" &lt; STRING c s &lt;=&gt; T) /\
         !s2 s1 c2 c1.
           STRING c1 s1 &lt; STRING c2 s2 &lt;=&gt; c1 &lt; c2 \/ (c1 = c2) /\ s1 &lt; s2
   
   [<A NAME="string_lt_ind-val"><B>string_lt_ind</B></A>]  Theorem
      
      |- !P.
           P "" "" /\ (!v2 v3. P (STRING v2 v3) "") /\
           (!c s. P "" (STRING c s)) /\
           (!c1 s1 c2 s2. P s1 s2 ==&gt; P (STRING c1 s1) (STRING c2 s2)) ==&gt;
           !v v1. P v v1
   
   
*)
end

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/string/stringScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
