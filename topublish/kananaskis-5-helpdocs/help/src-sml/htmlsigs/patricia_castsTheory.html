<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure patricia_castsTheory</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure patricia_castsTheory</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/patricia/patricia_castsScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>signature patricia_castsTheory =
<A NAME="line2"></A>sig
<A NAME="line3"></A>  type thm = Thm.thm
<A NAME="line4"></A>  
<A NAME="line5"></A>  (*  Definitions  *)
<A NAME="line6"></A>    val <A HREF="#ADD_LISTs_def-val">ADD_LISTs_def</A> : thm
<A NAME="line7"></A>    val <A HREF="#ADD_LISTw_def-val">ADD_LISTw_def</A> : thm
<A NAME="line8"></A>    val <A HREF="#ADDs_def-val">ADDs_def</A> : thm
<A NAME="line9"></A>    val <A HREF="#ADDw_def-val">ADDw_def</A> : thm
<A NAME="line10"></A>    val <A HREF="#DEPTHw_def-val">DEPTHw_def</A> : thm
<A NAME="line11"></A>    val <A HREF="#EVERY_LEAFw_def-val">EVERY_LEAFw_def</A> : thm
<A NAME="line12"></A>    val <A HREF="#EXISTS_LEAFw_def-val">EXISTS_LEAFw_def</A> : thm
<A NAME="line13"></A>    val <A HREF="#FINDs_def-val">FINDs_def</A> : thm
<A NAME="line14"></A>    val <A HREF="#FINDw_def-val">FINDw_def</A> : thm
<A NAME="line15"></A>    val <A HREF="#INSERT_PTREEs_def-val">INSERT_PTREEs_def</A> : thm
<A NAME="line16"></A>    val <A HREF="#INSERT_PTREEw_def-val">INSERT_PTREEw_def</A> : thm
<A NAME="line17"></A>    val <A HREF="#IN_PTREEs_def-val">IN_PTREEs_def</A> : thm
<A NAME="line18"></A>    val <A HREF="#IN_PTREEw_def-val">IN_PTREEw_def</A> : thm
<A NAME="line19"></A>    val <A HREF="#KEYSs_def-val">KEYSs_def</A> : thm
<A NAME="line20"></A>    val <A HREF="#KEYSw_def-val">KEYSw_def</A> : thm
<A NAME="line21"></A>    val <A HREF="#PEEKs_def-val">PEEKs_def</A> : thm
<A NAME="line22"></A>    val <A HREF="#PEEKw_def-val">PEEKw_def</A> : thm
<A NAME="line23"></A>    val <A HREF="#PTREE_OF_STRINGSET_def-val">PTREE_OF_STRINGSET_def</A> : thm
<A NAME="line24"></A>    val <A HREF="#PTREE_OF_WORDSET_def-val">PTREE_OF_WORDSET_def</A> : thm
<A NAME="line25"></A>    val <A HREF="#REMOVEs_def-val">REMOVEs_def</A> : thm
<A NAME="line26"></A>    val <A HREF="#REMOVEw_def-val">REMOVEw_def</A> : thm
<A NAME="line27"></A>    val <A HREF="#SIZEw_def-val">SIZEw_def</A> : thm
<A NAME="line28"></A>    val <A HREF="#SKIP1_def-val">SKIP1_def</A> : thm
<A NAME="line29"></A>    val <A HREF="#SOME_PTREE_def-val">SOME_PTREE_def</A> : thm
<A NAME="line30"></A>    val <A HREF="#STRINGSET_OF_PTREE_def-val">STRINGSET_OF_PTREE_def</A> : thm
<A NAME="line31"></A>    val <A HREF="#THE_PTREE_def-val">THE_PTREE_def</A> : thm
<A NAME="line32"></A>    val <A HREF="#TRANSFORMw_def-val">TRANSFORMw_def</A> : thm
<A NAME="line33"></A>    val <A HREF="#TRAVERSEs_def-val">TRAVERSEs_def</A> : thm
<A NAME="line34"></A>    val <A HREF="#TRAVERSEw_def-val">TRAVERSEw_def</A> : thm
<A NAME="line35"></A>    val <A HREF="#UNION_PTREEw_def-val">UNION_PTREEw_def</A> : thm
<A NAME="line36"></A>    val <A HREF="#WORDSET_OF_PTREE_def-val">WORDSET_OF_PTREE_def</A> : thm
<A NAME="line37"></A>    val <A HREF="#WordEmpty_def-val">WordEmpty_def</A> : thm
<A NAME="line38"></A>    val <A HREF="#num_to_string_def-val">num_to_string_def</A> : thm
<A NAME="line39"></A>    val <A HREF="#string_to_num_def-val">string_to_num_def</A> : thm
<A NAME="line40"></A>    val <A HREF="#word_ptree_TY_DEF-val">word_ptree_TY_DEF</A> : thm
<A NAME="line41"></A>    val <A HREF="#word_ptree_case_def-val">word_ptree_case_def</A> : thm
<A NAME="line42"></A>    val <A HREF="#word_ptree_repfns-val">word_ptree_repfns</A> : thm
<A NAME="line43"></A>    val <A HREF="#word_ptree_size_def-val">word_ptree_size_def</A> : thm
<A NAME="line44"></A>  
<A NAME="line45"></A>  (*  Theorems  *)
<A NAME="line46"></A>    val <A HREF="#ADD_INSERT_STRING-val">ADD_INSERT_STRING</A> : thm
<A NAME="line47"></A>    val <A HREF="#ADD_INSERT_WORD-val">ADD_INSERT_WORD</A> : thm
<A NAME="line48"></A>    val <A HREF="#EVERY_MAP_ORD-val">EVERY_MAP_ORD</A> : thm
<A NAME="line49"></A>    val <A HREF="#IMAGE_string_to_num-val">IMAGE_string_to_num</A> : thm
<A NAME="line50"></A>    val <A HREF="#MAP_11-val">MAP_11</A> : thm
<A NAME="line51"></A>    val <A HREF="#REVERSE_11-val">REVERSE_11</A> : thm
<A NAME="line52"></A>    val <A HREF="#THE_PTREE_SOME_PTREE-val">THE_PTREE_SOME_PTREE</A> : thm
<A NAME="line53"></A>    val <A HREF="#datatype_word_ptree-val">datatype_word_ptree</A> : thm
<A NAME="line54"></A>    val <A HREF="#l2n_11-val">l2n_11</A> : thm
<A NAME="line55"></A>    val <A HREF="#l2n_APPEND-val">l2n_APPEND</A> : thm
<A NAME="line56"></A>    val <A HREF="#l2n_LENGTH-val">l2n_LENGTH</A> : thm
<A NAME="line57"></A>    val <A HREF="#num_to_string_string_to_num-val">num_to_string_string_to_num</A> : thm
<A NAME="line58"></A>    val <A HREF="#string_to_num_11-val">string_to_num_11</A> : thm
<A NAME="line59"></A>    val <A HREF="#string_to_num_num_to_string-val">string_to_num_num_to_string</A> : thm
<A NAME="line60"></A>    val <A HREF="#word_ptree_11-val">word_ptree_11</A> : thm
<A NAME="line61"></A>    val <A HREF="#word_ptree_Axiom-val">word_ptree_Axiom</A> : thm
<A NAME="line62"></A>    val <A HREF="#word_ptree_case_cong-val">word_ptree_case_cong</A> : thm
<A NAME="line63"></A>    val <A HREF="#word_ptree_induction-val">word_ptree_induction</A> : thm
<A NAME="line64"></A>    val <A HREF="#word_ptree_nchotomy-val">word_ptree_nchotomy</A> : thm
<A NAME="line65"></A>  
<A NAME="line66"></A>  val patricia_casts_grammars : type_grammar.grammar * term_grammar.grammar
<A NAME="line67"></A>  
<A NAME="line68"></A>  val patricia_casts_rwts : simpLib.ssfrag
<A NAME="line69"></A>(*
   [patricia] Parent theory of "patricia_casts"
   
   [<A NAME="ADD_LISTs_def-val"><B>ADD_LISTs_def</B></A>]  Definition
      
      |- $|++ = FOLDL $|+
   
   [<A NAME="ADD_LISTw_def-val"><B>ADD_LISTw_def</B></A>]  Definition
      
      |- $|++ = FOLDL $|+
   
   [<A NAME="ADDs_def-val"><B>ADDs_def</B></A>]  Definition
      
      |- !t w d. t |+ (w,d) = t |+ (string_to_num w,d)
   
   [<A NAME="ADDw_def-val"><B>ADDw_def</B></A>]  Definition
      
      |- !t w d. t |+ (w,d) = SOME_PTREE (THE_PTREE t |+ (w2n w,d))
   
   [<A NAME="DEPTHw_def-val"><B>DEPTHw_def</B></A>]  Definition
      
      |- !t. DEPTHw t = DEPTH (THE_PTREE t)
   
   [<A NAME="EVERY_LEAFw_def-val"><B>EVERY_LEAFw_def</B></A>]  Definition
      
      |- !P t.
           EVERY_LEAFw P t &lt;=&gt; EVERY_LEAF (\k d. P (n2w k) d) (THE_PTREE t)
   
   [<A NAME="EXISTS_LEAFw_def-val"><B>EXISTS_LEAFw_def</B></A>]  Definition
      
      |- !P t.
           EXISTS_LEAFw P t &lt;=&gt;
           EXISTS_LEAF (\k d. P (n2w k) d) (THE_PTREE t)
   
   [<A NAME="FINDs_def-val"><B>FINDs_def</B></A>]  Definition
      
      |- !t w. FINDs t w = THE (t ' w)
   
   [<A NAME="FINDw_def-val"><B>FINDw_def</B></A>]  Definition
      
      |- !t w. FINDw t w = THE (t ' w)
   
   [<A NAME="INSERT_PTREEs_def-val"><B>INSERT_PTREEs_def</B></A>]  Definition
      
      |- !w t. w INSERT_PTREEs t = string_to_num w INSERT_PTREE t
   
   [<A NAME="INSERT_PTREEw_def-val"><B>INSERT_PTREEw_def</B></A>]  Definition
      
      |- !w t.
           w INSERT_PTREEw t = SOME_PTREE (w2n w INSERT_PTREE THE_PTREE t)
   
   [<A NAME="IN_PTREEs_def-val"><B>IN_PTREEs_def</B></A>]  Definition
      
      |- !w t. w IN_PTREEs t &lt;=&gt; string_to_num w IN_PTREE t
   
   [<A NAME="IN_PTREEw_def-val"><B>IN_PTREEw_def</B></A>]  Definition
      
      |- !w t. w IN_PTREEw t &lt;=&gt; w2n w IN_PTREE THE_PTREE t
   
   [<A NAME="KEYSs_def-val"><B>KEYSs_def</B></A>]  Definition
      
      |- !t. KEYSs t = QSORT $&lt; (TRAVERSEs t)
   
   [<A NAME="KEYSw_def-val"><B>KEYSw_def</B></A>]  Definition
      
      |- !t. KEYSw t = QSORT $&lt;+ (TRAVERSEw t)
   
   [<A NAME="PEEKs_def-val"><B>PEEKs_def</B></A>]  Definition
      
      |- !t w. t ' w = t ' (string_to_num w)
   
   [<A NAME="PEEKw_def-val"><B>PEEKw_def</B></A>]  Definition
      
      |- !t w. t ' w = THE_PTREE t ' (w2n w)
   
   [<A NAME="PTREE_OF_STRINGSET_def-val"><B>PTREE_OF_STRINGSET_def</B></A>]  Definition
      
      |- !t s. t |++ s = t |++ IMAGE string_to_num s
   
   [<A NAME="PTREE_OF_WORDSET_def-val"><B>PTREE_OF_WORDSET_def</B></A>]  Definition
      
      |- !t s. t |++ s = SOME_PTREE (THE_PTREE t |++ IMAGE w2n s)
   
   [<A NAME="REMOVEs_def-val"><B>REMOVEs_def</B></A>]  Definition
      
      |- !t w. t \\ w = t \\ string_to_num w
   
   [<A NAME="REMOVEw_def-val"><B>REMOVEw_def</B></A>]  Definition
      
      |- !t w. t \\ w = SOME_PTREE (THE_PTREE t \\ w2n w)
   
   [<A NAME="SIZEw_def-val"><B>SIZEw_def</B></A>]  Definition
      
      |- !t. SIZEw t = SIZE (THE_PTREE t)
   
   [<A NAME="SKIP1_def-val"><B>SKIP1_def</B></A>]  Definition
      
      |- !c s. SKIP1 (STRING c s) = s
   
   [<A NAME="SOME_PTREE_def-val"><B>SOME_PTREE_def</B></A>]  Definition
      
      |- !t. SOME_PTREE t = Word_ptree (K ()) t
   
   [<A NAME="STRINGSET_OF_PTREE_def-val"><B>STRINGSET_OF_PTREE_def</B></A>]  Definition
      
      |- !t. STRINGSET_OF_PTREE t = LIST_TO_SET (TRAVERSEs t)
   
   [<A NAME="THE_PTREE_def-val"><B>THE_PTREE_def</B></A>]  Definition
      
      |- !a t. THE_PTREE (Word_ptree a t) = t
   
   [<A NAME="TRANSFORMw_def-val"><B>TRANSFORMw_def</B></A>]  Definition
      
      |- !f t. TRANSFORMw f t = SOME_PTREE (TRANSFORM f (THE_PTREE t))
   
   [<A NAME="TRAVERSEs_def-val"><B>TRAVERSEs_def</B></A>]  Definition
      
      |- !t. TRAVERSEs t = MAP num_to_string (TRAVERSE t)
   
   [<A NAME="TRAVERSEw_def-val"><B>TRAVERSEw_def</B></A>]  Definition
      
      |- !t. TRAVERSEw t = MAP n2w (TRAVERSE (THE_PTREE t))
   
   [<A NAME="UNION_PTREEw_def-val"><B>UNION_PTREEw_def</B></A>]  Definition
      
      |- !t1 t2.
           t1 UNION_PTREEw t2 =
           SOME_PTREE (THE_PTREE t1 UNION_PTREE THE_PTREE t2)
   
   [<A NAME="WORDSET_OF_PTREE_def-val"><B>WORDSET_OF_PTREE_def</B></A>]  Definition
      
      |- !t. WORDSET_OF_PTREE t = LIST_TO_SET (TRAVERSEw t)
   
   [<A NAME="WordEmpty_def-val"><B>WordEmpty_def</B></A>]  Definition
      
      |- +{}+ = SOME_PTREE &lt;{}&gt;
   
   [<A NAME="num_to_string_def-val"><B>num_to_string_def</B></A>]  Definition
      
      |- !n. num_to_string n = SKIP1 (n2s 256 CHR n)
   
   [<A NAME="string_to_num_def-val"><B>string_to_num_def</B></A>]  Definition
      
      |- !s. string_to_num s = s2n 256 ORD (STRING #"\^A" s)
   
   [<A NAME="word_ptree_TY_DEF-val"><B>word_ptree_TY_DEF</B></A>]  Definition
      
      |- ?rep.
           TYPE_DEFINITION
             (\a0'.
                !'word_ptree' .
                  (!a0'.
                     (?a0 a1.
                        a0' =
                        (\a0 a1.
                           ind_type$CONSTR 0 (a0,a1) (\n. ind_type$BOTTOM))
                          a0 a1) ==&gt;
                     'word_ptree' a0') ==&gt;
                  'word_ptree' a0') rep
   
   [<A NAME="word_ptree_case_def-val"><B>word_ptree_case_def</B></A>]  Definition
      
      |- !f a0 a1. word_ptree_case f (Word_ptree a0 a1) = f a0 a1
   
   [<A NAME="word_ptree_repfns-val"><B>word_ptree_repfns</B></A>]  Definition
      
      |- (!a. mk_word_ptree (dest_word_ptree a) = a) /\
         !r.
           (\a0'.
              !'word_ptree' .
                (!a0'.
                   (?a0 a1.
                      a0' =
                      (\a0 a1.
                         ind_type$CONSTR 0 (a0,a1) (\n. ind_type$BOTTOM))
                        a0 a1) ==&gt;
                   'word_ptree' a0') ==&gt;
                'word_ptree' a0') r &lt;=&gt;
           (dest_word_ptree (mk_word_ptree r) = r)
   
   [<A NAME="word_ptree_size_def-val"><B>word_ptree_size_def</B></A>]  Definition
      
      |- !f f1 a0 a1.
           word_ptree_size f f1 (Word_ptree a0 a1) = 1 + ptree_size f1 a1
   
   [<A NAME="ADD_INSERT_STRING-val"><B>ADD_INSERT_STRING</B></A>]  Theorem
      
      |- !w v t. t |+ (w,v) = t |+ (w,())
   
   [<A NAME="ADD_INSERT_WORD-val"><B>ADD_INSERT_WORD</B></A>]  Theorem
      
      |- !w v t. t |+ (w,v) = t |+ (w,())
   
   [<A NAME="EVERY_MAP_ORD-val"><B>EVERY_MAP_ORD</B></A>]  Theorem
      
      |- !l. EVERY ($&gt; 256) (MAP ORD l)
   
   [<A NAME="IMAGE_string_to_num-val"><B>IMAGE_string_to_num</B></A>]  Theorem
      
      |- !n.
           (n = 1) \/ 256 &lt;= n /\ (n DIV 256 ** LOG 256 n = 1) &lt;=&gt;
           n IN IMAGE string_to_num UNIV
   
   [<A NAME="MAP_11-val"><B>MAP_11</B></A>]  Theorem
      
      |- !f l1 l2.
           (!x y. (f x = f y) &lt;=&gt; (x = y)) ==&gt;
           ((MAP f l1 = MAP f l2) &lt;=&gt; (l1 = l2))
   
   [<A NAME="REVERSE_11-val"><B>REVERSE_11</B></A>]  Theorem
      
      |- !l1 l2. (REVERSE l1 = REVERSE l2) &lt;=&gt; (l1 = l2)
   
   [<A NAME="THE_PTREE_SOME_PTREE-val"><B>THE_PTREE_SOME_PTREE</B></A>]  Theorem
      
      |- !t. THE_PTREE (SOME_PTREE t) = t
   
   [<A NAME="datatype_word_ptree-val"><B>datatype_word_ptree</B></A>]  Theorem
      
      |- DATATYPE (word_ptree Word_ptree)
   
   [<A NAME="l2n_11-val"><B>l2n_11</B></A>]  Theorem
      
      |- !b l1 l2.
           1 &lt; b /\ EVERY ($&gt; b) l1 /\ EVERY ($&gt; b) l2 ==&gt;
           ((l2n b (l1 ++ [1]) = l2n b (l2 ++ [1])) &lt;=&gt; (l1 = l2))
   
   [<A NAME="l2n_APPEND-val"><B>l2n_APPEND</B></A>]  Theorem
      
      |- !b l1 l2. l2n b (l1 ++ l2) = l2n b l1 + b ** LENGTH l1 * l2n b l2
   
   [<A NAME="l2n_LENGTH-val"><B>l2n_LENGTH</B></A>]  Theorem
      
      |- !b l. 1 &lt; b ==&gt; l2n b l &lt; b ** LENGTH l
   
   [<A NAME="num_to_string_string_to_num-val"><B>num_to_string_string_to_num</B></A>]  Theorem
      
      |- !s. num_to_string (string_to_num s) = s
   
   [<A NAME="string_to_num_11-val"><B>string_to_num_11</B></A>]  Theorem
      
      |- !s t. (string_to_num s = string_to_num t) &lt;=&gt; (s = t)
   
   [<A NAME="string_to_num_num_to_string-val"><B>string_to_num_num_to_string</B></A>]  Theorem
      
      |- !n.
           n IN IMAGE string_to_num UNIV ==&gt;
           (string_to_num (num_to_string n) = n)
   
   [<A NAME="word_ptree_11-val"><B>word_ptree_11</B></A>]  Theorem
      
      |- !a0 a1 a0' a1'.
           (Word_ptree a0 a1 = Word_ptree a0' a1') &lt;=&gt;
           (a0 = a0') /\ (a1 = a1')
   
   [<A NAME="word_ptree_Axiom-val"><B>word_ptree_Axiom</B></A>]  Theorem
      
      |- !f. ?fn. !a0 a1. fn (Word_ptree a0 a1) = f a0 a1
   
   [<A NAME="word_ptree_case_cong-val"><B>word_ptree_case_cong</B></A>]  Theorem
      
      |- !M M' f.
           (M = M') /\
           (!a0 a1. (M' = Word_ptree a0 a1) ==&gt; (f a0 a1 = f' a0 a1)) ==&gt;
           (word_ptree_case f M = word_ptree_case f' M')
   
   [<A NAME="word_ptree_induction-val"><B>word_ptree_induction</B></A>]  Theorem
      
      |- !P. (!f p. P (Word_ptree f p)) ==&gt; !w. P w
   
   [<A NAME="word_ptree_nchotomy-val"><B>word_ptree_nchotomy</B></A>]  Theorem
      
      |- !ww. ?f p. ww = Word_ptree f p
   
   
*)
end

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/patricia/patricia_castsScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
