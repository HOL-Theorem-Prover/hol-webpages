<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure Travrules</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure Travrules</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/simp/src/Travrules.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>(* =====================================================================
<A NAME="line2"></A> * FILE          : travrules.sig
<A NAME="line3"></A> * DESCRIPTION   : Sets of rules for traversing terms.  Used for
<A NAME="line4"></A> *	           simpification and term traversal.
<A NAME="line5"></A> *
<A NAME="line6"></A> * AUTHOR        : Donald Syme
<A NAME="line7"></A> *                 Based loosely on ideas from window inference.
<A NAME="line8"></A> * ===================================================================== *)
<A NAME="line9"></A>
<A NAME="line10"></A>signature Travrules =
<A NAME="line11"></A>sig
<A NAME="line12"></A>   include Abbrev
<A NAME="line13"></A>
<A NAME="line14"></A>   (* ---------------------------------------------------------------------
<A NAME="line15"></A>    * preorders
<A NAME="line16"></A>    *
<A NAME="line17"></A>    * Nb. Preorders must be constants.  This restriction may be lifted
<A NAME="line18"></A>    * in the future.
<A NAME="line19"></A>    *
<A NAME="line20"></A>    * Once things are set up, the user of this module generally
<A NAME="line21"></A>    * specifies a preorder as a term, e.g. (--`$=`--).
<A NAME="line22"></A>    * ---------------------------------------------------------------------*)
<A NAME="line23"></A>
<A NAME="line24"></A>  datatype preorder = PREORDER of term
<A NAME="line25"></A>                                   * (thm -&gt; thm -&gt; thm)
<A NAME="line26"></A>                                   * (term -&gt; thm)
<A NAME="line27"></A>  val samerel : term -&gt; term -&gt; bool
<A NAME="line28"></A>
<A NAME="line29"></A>  val mk_preorder : (thm * thm) -&gt; preorder;
<A NAME="line30"></A>  val find_relation : term -&gt; preorder list -&gt; preorder;
<A NAME="line31"></A>
<A NAME="line32"></A>   (* ---------------------------------------------------------------------
<A NAME="line33"></A>    * type travrules
<A NAME="line34"></A>    *
<A NAME="line35"></A>    * An object of type "travrules" specifies a colelction of theorems
<A NAME="line36"></A>    * and procedures which are used when automatically traversing a term.
<A NAME="line37"></A>    *
<A NAME="line38"></A>    * The collection of rules may contain rules for multiple relations.
<A NAME="line39"></A>    * The traversal engine is trying to reduce the "current term"
<A NAME="line40"></A>    * via various "reducers" under the "current relation".
<A NAME="line41"></A>    * In normal equality reasoning (see SIMP_TAC) the relation is (--`$=`--).
<A NAME="line42"></A>    *
<A NAME="line43"></A>    * Traversal is achieved by means of congruence procedures.
<A NAME="line44"></A>    * A congruence procedure has ML type
<A NAME="line45"></A>    *       {solver, depther} -&gt; conv
<A NAME="line46"></A>    * where "conv" here is interpreted in the wider sense that the
<A NAME="line47"></A>    * function will return a theorem showing REL(t1,t2) for the
<A NAME="line48"></A>    * relation over which the congruence procedure acts.
<A NAME="line49"></A>    *
<A NAME="line50"></A>    * Congruence procedures are typically simple layers on top
<A NAME="line51"></A>    * of a congruence theorem (though they may also implement an
<A NAME="line52"></A>    * infinite class of congurence theorems).  For example,
<A NAME="line53"></A>    *    !f x. (x = x') ==&gt; (f = f') --&gt; (f x = f' x')
<A NAME="line54"></A>    * is a very simple congruence theorem for constructs of
<A NAME="line55"></A>    * the form (--`f x`--) under the (--`$=`--) relation.
<A NAME="line56"></A>    * (Nb. This congruence procedure is actually implemented
<A NAME="line57"></A>    * by a special procedure for efficiency reasons).
<A NAME="line58"></A>    *
<A NAME="line59"></A>    * Congruence procedures are typically created by using
<A NAME="line60"></A>    * the function CONGRULE.
<A NAME="line61"></A>    *
<A NAME="line62"></A>    * Congruence rules may have side conditions which should be solved
<A NAME="line63"></A>    * by the solver provided to the congruence procedure.  If they
<A NAME="line64"></A>    * are not solved they can be added as assumptions to the theorem
<A NAME="line65"></A>    * returned, and will need to be discharged by the user after
<A NAME="line66"></A>    * traversal.
<A NAME="line67"></A>    * ---------------------------------------------------------------------*)
<A NAME="line68"></A>
<A NAME="line69"></A>   datatype travrules = TRAVRULES of {
<A NAME="line70"></A>       relations : preorder list,
<A NAME="line71"></A>       congprocs : Opening.congproc list,
<A NAME="line72"></A>       weakenprocs : Opening.congproc list
<A NAME="line73"></A>    };
<A NAME="line74"></A>
<A NAME="line75"></A>
<A NAME="line76"></A>   (* ---------------------------------------------------------------------
<A NAME="line77"></A>    * Basic operations on travruless
<A NAME="line78"></A>    *  merge should only be used on non-overlapping travrule fragments.
<A NAME="line79"></A>    * ---------------------------------------------------------------------*)
<A NAME="line80"></A>
<A NAME="line81"></A>  val merge_travrules: travrules list -&gt; travrules
<A NAME="line82"></A>
<A NAME="line83"></A>  val gen_mk_travrules :
<A NAME="line84"></A>    {relations : preorder list,
<A NAME="line85"></A>     congprocs : Opening.congproc list,
<A NAME="line86"></A>     weakenprocs : Opening.congproc list} -&gt; travrules
<A NAME="line87"></A>
<A NAME="line88"></A>
<A NAME="line89"></A>  val mk_travrules : preorder list -&gt; thm list -&gt; travrules
<A NAME="line90"></A>  val cong2proc : preorder list -&gt; thm -&gt; Opening.congproc
<A NAME="line91"></A>
<A NAME="line92"></A>  (* the equality case - all theorems are interpeted as equality congruences *)
<A NAME="line93"></A>  val EQ_tr : travrules
<A NAME="line94"></A>
<A NAME="line95"></A>end (* sig *)
<A NAME="line96"></A>
<A NAME="line97"></A>
<A NAME="line98"></A>
<A NAME="line99"></A>
</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/simp/src/Travrules.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
