<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure numeralTheory</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure numeralTheory</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/num/theories/numeralScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>signature numeralTheory =
<A NAME="line2"></A>sig
<A NAME="line3"></A>  type thm = Thm.thm
<A NAME="line4"></A>  
<A NAME="line5"></A>  (*  Definitions  *)
<A NAME="line6"></A>    val <A HREF="#exactlog_def-val">exactlog_def</A> : thm
<A NAME="line7"></A>    val <A HREF="#iBIT_cases-val">iBIT_cases</A> : thm
<A NAME="line8"></A>    val <A HREF="#iDUB-val">iDUB</A> : thm
<A NAME="line9"></A>    val <A HREF="#iMOD_2EXP-val">iMOD_2EXP</A> : thm
<A NAME="line10"></A>    val <A HREF="#iSQR-val">iSQR</A> : thm
<A NAME="line11"></A>    val <A HREF="#iSUB_DEF-val">iSUB_DEF</A> : thm
<A NAME="line12"></A>    val <A HREF="#iZ-val">iZ</A> : thm
<A NAME="line13"></A>    val <A HREF="#iiSUC-val">iiSUC</A> : thm
<A NAME="line14"></A>    val <A HREF="#internal_mult_def-val">internal_mult_def</A> : thm
<A NAME="line15"></A>    val <A HREF="#onecount_def-val">onecount_def</A> : thm
<A NAME="line16"></A>    val <A HREF="#texp_help_def-val">texp_help_def</A> : thm
<A NAME="line17"></A>  
<A NAME="line18"></A>  (*  Theorems  *)
<A NAME="line19"></A>    val <A HREF="#DIV2_BIT1-val">DIV2_BIT1</A> : thm
<A NAME="line20"></A>    val <A HREF="#DIVMOD_NUMERAL_CALC-val">DIVMOD_NUMERAL_CALC</A> : thm
<A NAME="line21"></A>    val <A HREF="#DIV_2EXP-val">DIV_2EXP</A> : thm
<A NAME="line22"></A>    val <A HREF="#MOD_2EXP-val">MOD_2EXP</A> : thm
<A NAME="line23"></A>    val <A HREF="#TWO_EXP_THM-val">TWO_EXP_THM</A> : thm
<A NAME="line24"></A>    val <A HREF="#bit_induction-val">bit_induction</A> : thm
<A NAME="line25"></A>    val <A HREF="#bit_initiality-val">bit_initiality</A> : thm
<A NAME="line26"></A>    val <A HREF="#divmod_POS-val">divmod_POS</A> : thm
<A NAME="line27"></A>    val <A HREF="#enumeral_mult-val">enumeral_mult</A> : thm
<A NAME="line28"></A>    val <A HREF="#exactlog_characterisation-val">exactlog_characterisation</A> : thm
<A NAME="line29"></A>    val <A HREF="#iDUB_removal-val">iDUB_removal</A> : thm
<A NAME="line30"></A>    val <A HREF="#iSUB_THM-val">iSUB_THM</A> : thm
<A NAME="line31"></A>    val <A HREF="#internal_mult_characterisation-val">internal_mult_characterisation</A> : thm
<A NAME="line32"></A>    val <A HREF="#numeral_MAX-val">numeral_MAX</A> : thm
<A NAME="line33"></A>    val <A HREF="#numeral_MIN-val">numeral_MIN</A> : thm
<A NAME="line34"></A>    val <A HREF="#numeral_add-val">numeral_add</A> : thm
<A NAME="line35"></A>    val <A HREF="#numeral_distrib-val">numeral_distrib</A> : thm
<A NAME="line36"></A>    val <A HREF="#numeral_div2-val">numeral_div2</A> : thm
<A NAME="line37"></A>    val <A HREF="#numeral_eq-val">numeral_eq</A> : thm
<A NAME="line38"></A>    val <A HREF="#numeral_evenodd-val">numeral_evenodd</A> : thm
<A NAME="line39"></A>    val <A HREF="#numeral_exp-val">numeral_exp</A> : thm
<A NAME="line40"></A>    val <A HREF="#numeral_fact-val">numeral_fact</A> : thm
<A NAME="line41"></A>    val <A HREF="#numeral_funpow-val">numeral_funpow</A> : thm
<A NAME="line42"></A>    val <A HREF="#numeral_iisuc-val">numeral_iisuc</A> : thm
<A NAME="line43"></A>    val <A HREF="#numeral_imod_2exp-val">numeral_imod_2exp</A> : thm
<A NAME="line44"></A>    val <A HREF="#numeral_lt-val">numeral_lt</A> : thm
<A NAME="line45"></A>    val <A HREF="#numeral_lte-val">numeral_lte</A> : thm
<A NAME="line46"></A>    val <A HREF="#numeral_mult-val">numeral_mult</A> : thm
<A NAME="line47"></A>    val <A HREF="#numeral_pre-val">numeral_pre</A> : thm
<A NAME="line48"></A>    val <A HREF="#numeral_sub-val">numeral_sub</A> : thm
<A NAME="line49"></A>    val <A HREF="#numeral_suc-val">numeral_suc</A> : thm
<A NAME="line50"></A>    val <A HREF="#numeral_texp_help-val">numeral_texp_help</A> : thm
<A NAME="line51"></A>    val <A HREF="#onecount_characterisation-val">onecount_characterisation</A> : thm
<A NAME="line52"></A>    val <A HREF="#texp_help0-val">texp_help0</A> : thm
<A NAME="line53"></A>    val <A HREF="#texp_help_thm-val">texp_help_thm</A> : thm
<A NAME="line54"></A>  
<A NAME="line55"></A>  val numeral_grammars : type_grammar.grammar * term_grammar.grammar
<A NAME="line56"></A>  
<A NAME="line57"></A>  
<A NAME="line58"></A>(*
   [arithmetic] Parent theory of "numeral"
   
   [<A NAME="exactlog_def-val"><B>exactlog_def</B></A>]  Definition
      
      |- (numeral$exactlog ZERO = ZERO) /\
         (!n. numeral$exactlog (BIT1 n) = ZERO) /\
         !n.
           numeral$exactlog (BIT2 n) =
           (let x = numeral$onecount n ZERO in
              if x = ZERO then ZERO else BIT1 x)
   
   [<A NAME="iBIT_cases-val"><B>iBIT_cases</B></A>]  Definition
      
      |- (!zf bf1 bf2. iBIT_cases ZERO zf bf1 bf2 = zf) /\
         (!n zf bf1 bf2. iBIT_cases (BIT1 n) zf bf1 bf2 = bf1 n) /\
         !n zf bf1 bf2. iBIT_cases (BIT2 n) zf bf1 bf2 = bf2 n
   
   [<A NAME="iDUB-val"><B>iDUB</B></A>]  Definition
      
      |- !x. numeral$iDUB x = x + x
   
   [<A NAME="iMOD_2EXP-val"><B>iMOD_2EXP</B></A>]  Definition
      
      |- numeral$iMOD_2EXP = MOD_2EXP
   
   [<A NAME="iSQR-val"><B>iSQR</B></A>]  Definition
      
      |- !x. numeral$iSQR x = x * x
   
   [<A NAME="iSUB_DEF-val"><B>iSUB_DEF</B></A>]  Definition
      
      |- (!b x. numeral$iSUB b ZERO x = ZERO) /\
         (!b n x.
            numeral$iSUB b (BIT1 n) x =
            if b then
              iBIT_cases x (BIT1 n) (\m. numeral$iDUB (numeral$iSUB T n m))
                (\m. BIT1 (numeral$iSUB F n m))
            else
              iBIT_cases x (numeral$iDUB n) (\m. BIT1 (numeral$iSUB F n m))
                (\m. numeral$iDUB (numeral$iSUB F n m))) /\
         !b n x.
           numeral$iSUB b (BIT2 n) x =
           if b then
             iBIT_cases x (BIT2 n) (\m. BIT1 (numeral$iSUB T n m))
               (\m. numeral$iDUB (numeral$iSUB T n m))
           else
             iBIT_cases x (BIT1 n) (\m. numeral$iDUB (numeral$iSUB T n m))
               (\m. BIT1 (numeral$iSUB F n m))
   
   [<A NAME="iZ-val"><B>iZ</B></A>]  Definition
      
      |- !x. numeral$iZ x = x
   
   [<A NAME="iiSUC-val"><B>iiSUC</B></A>]  Definition
      
      |- !n. numeral$iiSUC n = SUC (SUC n)
   
   [<A NAME="internal_mult_def-val"><B>internal_mult_def</B></A>]  Definition
      
      |- internal_mult = $*
   
   [<A NAME="onecount_def-val"><B>onecount_def</B></A>]  Definition
      
      |- (!x. numeral$onecount ZERO x = x) /\
         (!n x.
            numeral$onecount (BIT1 n) x = numeral$onecount n (SUC x)) /\
         !n x. numeral$onecount (BIT2 n) x = ZERO
   
   [<A NAME="texp_help_def-val"><B>texp_help_def</B></A>]  Definition
      
      |- (!acc. numeral$texp_help 0 acc = BIT2 acc) /\
         !n acc.
           numeral$texp_help (SUC n) acc = numeral$texp_help n (BIT1 acc)
   
   [<A NAME="DIV2_BIT1-val"><B>DIV2_BIT1</B></A>]  Theorem
      
      |- DIV2 (BIT1 x) = x
   
   [<A NAME="DIVMOD_NUMERAL_CALC-val"><B>DIVMOD_NUMERAL_CALC</B></A>]  Theorem
      
      |- (!m n. m DIV BIT1 n = FST (DIVMOD (ZERO,m,BIT1 n))) /\
         (!m n. m DIV BIT2 n = FST (DIVMOD (ZERO,m,BIT2 n))) /\
         (!m n. m MOD BIT1 n = SND (DIVMOD (ZERO,m,BIT1 n))) /\
         !m n. m MOD BIT2 n = SND (DIVMOD (ZERO,m,BIT2 n))
   
   [<A NAME="DIV_2EXP-val"><B>DIV_2EXP</B></A>]  Theorem
      
      |- !n x. DIV_2EXP n x = FUNPOW DIV2 n x
   
   [<A NAME="MOD_2EXP-val"><B>MOD_2EXP</B></A>]  Theorem
      
      |- (!x. MOD_2EXP x 0 = 0) /\
         !x n. MOD_2EXP x (NUMERAL n) = NUMERAL (numeral$iMOD_2EXP x n)
   
   [<A NAME="TWO_EXP_THM-val"><B>TWO_EXP_THM</B></A>]  Theorem
      
      |- (2 ** 0 = 1) /\
         (2 ** NUMERAL (BIT1 n) =
          NUMERAL (numeral$texp_help (PRE (BIT1 n)) ZERO)) /\
         (2 ** NUMERAL (BIT2 n) =
          NUMERAL (numeral$texp_help (BIT1 n) ZERO))
   
   [<A NAME="bit_induction-val"><B>bit_induction</B></A>]  Theorem
      
      |- !P.
           P ZERO /\ (!n. P n ==&gt; P (BIT1 n)) /\
           (!n. P n ==&gt; P (BIT2 n)) ==&gt;
           !n. P n
   
   [<A NAME="bit_initiality-val"><B>bit_initiality</B></A>]  Theorem
      
      |- !zf b1f b2f.
           ?f.
             (f ZERO = zf) /\ (!n. f (BIT1 n) = b1f n (f n)) /\
             !n. f (BIT2 n) = b2f n (f n)
   
   [<A NAME="divmod_POS-val"><B>divmod_POS</B></A>]  Theorem
      
      |- !n.
           0 &lt; n ==&gt;
           (DIVMOD (a,m,n) =
            if m &lt; n then
              (a,m)
            else
              (let q = findq (1,m,n) in DIVMOD (a + q,m - n * q,n)))
   
   [<A NAME="enumeral_mult-val"><B>enumeral_mult</B></A>]  Theorem
      
      |- (ZERO * n = ZERO) /\ (n * ZERO = ZERO) /\
         (BIT1 x * BIT1 y = internal_mult (BIT1 x) (BIT1 y)) /\
         (BIT1 x * BIT2 y =
          (let n = numeral$exactlog (BIT2 y) in
             if ODD n then
               numeral$texp_help (DIV2 n) (PRE (BIT1 x))
             else
               internal_mult (BIT1 x) (BIT2 y))) /\
         (BIT2 x * BIT1 y =
          (let m = numeral$exactlog (BIT2 x) in
             if ODD m then
               numeral$texp_help (DIV2 m) (PRE (BIT1 y))
             else
               internal_mult (BIT2 x) (BIT1 y))) /\
         (BIT2 x * BIT2 y =
          (let m = numeral$exactlog (BIT2 x) in
           let n = numeral$exactlog (BIT2 y) in
             if ODD m then
               numeral$texp_help (DIV2 m) (PRE (BIT2 y))
             else
               if ODD n then
                 numeral$texp_help (DIV2 n) (PRE (BIT2 x))
               else
                 internal_mult (BIT2 x) (BIT2 y)))
   
   [<A NAME="exactlog_characterisation-val"><B>exactlog_characterisation</B></A>]  Theorem
      
      |- !n m. (numeral$exactlog n = BIT1 m) ==&gt; (n = 2 ** (m + 1))
   
   [<A NAME="iDUB_removal-val"><B>iDUB_removal</B></A>]  Theorem
      
      |- !n.
           (numeral$iDUB (BIT1 n) = BIT2 (numeral$iDUB n)) /\
           (numeral$iDUB (BIT2 n) = BIT2 (BIT1 n)) /\
           (numeral$iDUB ZERO = ZERO)
   
   [<A NAME="iSUB_THM-val"><B>iSUB_THM</B></A>]  Theorem
      
      |- !b n m.
           (numeral$iSUB b ZERO x = ZERO) /\ (numeral$iSUB T n ZERO = n) /\
           (numeral$iSUB F (BIT1 n) ZERO = numeral$iDUB n) /\
           (numeral$iSUB T (BIT1 n) (BIT1 m) =
            numeral$iDUB (numeral$iSUB T n m)) /\
           (numeral$iSUB F (BIT1 n) (BIT1 m) =
            BIT1 (numeral$iSUB F n m)) /\
           (numeral$iSUB T (BIT1 n) (BIT2 m) =
            BIT1 (numeral$iSUB F n m)) /\
           (numeral$iSUB F (BIT1 n) (BIT2 m) =
            numeral$iDUB (numeral$iSUB F n m)) /\
           (numeral$iSUB F (BIT2 n) ZERO = BIT1 n) /\
           (numeral$iSUB T (BIT2 n) (BIT1 m) =
            BIT1 (numeral$iSUB T n m)) /\
           (numeral$iSUB F (BIT2 n) (BIT1 m) =
            numeral$iDUB (numeral$iSUB T n m)) /\
           (numeral$iSUB T (BIT2 n) (BIT2 m) =
            numeral$iDUB (numeral$iSUB T n m)) /\
           (numeral$iSUB F (BIT2 n) (BIT2 m) = BIT1 (numeral$iSUB F n m))
   
   [<A NAME="internal_mult_characterisation-val"><B>internal_mult_characterisation</B></A>]  Theorem
      
      |- !n m.
           (internal_mult ZERO n = ZERO) /\
           (internal_mult n ZERO = ZERO) /\
           (internal_mult (BIT1 n) m =
            numeral$iZ (numeral$iDUB (internal_mult n m) + m)) /\
           (internal_mult (BIT2 n) m =
            numeral$iDUB (numeral$iZ (internal_mult n m + m)))
   
   [<A NAME="numeral_MAX-val"><B>numeral_MAX</B></A>]  Theorem
      
      |- (MAX 0 x = x) /\ (MAX x 0 = x) /\
         (MAX (NUMERAL x) (NUMERAL y) = NUMERAL (if x &lt; y then y else x))
   
   [<A NAME="numeral_MIN-val"><B>numeral_MIN</B></A>]  Theorem
      
      |- (MIN 0 x = 0) /\ (MIN x 0 = 0) /\
         (MIN (NUMERAL x) (NUMERAL y) = NUMERAL (if x &lt; y then x else y))
   
   [<A NAME="numeral_add-val"><B>numeral_add</B></A>]  Theorem
      
      |- !n m.
           (numeral$iZ (ZERO + n) = n) /\ (numeral$iZ (n + ZERO) = n) /\
           (numeral$iZ (BIT1 n + BIT1 m) = BIT2 (numeral$iZ (n + m))) /\
           (numeral$iZ (BIT1 n + BIT2 m) = BIT1 (SUC (n + m))) /\
           (numeral$iZ (BIT2 n + BIT1 m) = BIT1 (SUC (n + m))) /\
           (numeral$iZ (BIT2 n + BIT2 m) = BIT2 (SUC (n + m))) /\
           (SUC (ZERO + n) = SUC n) /\ (SUC (n + ZERO) = SUC n) /\
           (SUC (BIT1 n + BIT1 m) = BIT1 (SUC (n + m))) /\
           (SUC (BIT1 n + BIT2 m) = BIT2 (SUC (n + m))) /\
           (SUC (BIT2 n + BIT1 m) = BIT2 (SUC (n + m))) /\
           (SUC (BIT2 n + BIT2 m) = BIT1 (numeral$iiSUC (n + m))) /\
           (numeral$iiSUC (ZERO + n) = numeral$iiSUC n) /\
           (numeral$iiSUC (n + ZERO) = numeral$iiSUC n) /\
           (numeral$iiSUC (BIT1 n + BIT1 m) = BIT2 (SUC (n + m))) /\
           (numeral$iiSUC (BIT1 n + BIT2 m) =
            BIT1 (numeral$iiSUC (n + m))) /\
           (numeral$iiSUC (BIT2 n + BIT1 m) =
            BIT1 (numeral$iiSUC (n + m))) /\
           (numeral$iiSUC (BIT2 n + BIT2 m) = BIT2 (numeral$iiSUC (n + m)))
   
   [<A NAME="numeral_distrib-val"><B>numeral_distrib</B></A>]  Theorem
      
      |- (!n. 0 + n = n) /\ (!n. n + 0 = n) /\
         (!n m. NUMERAL n + NUMERAL m = NUMERAL (numeral$iZ (n + m))) /\
         (!n. 0 * n = 0) /\ (!n. n * 0 = 0) /\
         (!n m. NUMERAL n * NUMERAL m = NUMERAL (n * m)) /\
         (!n. 0 - n = 0) /\ (!n. n - 0 = n) /\
         (!n m. NUMERAL n - NUMERAL m = NUMERAL (n - m)) /\
         (!n. 0 ** NUMERAL (BIT1 n) = 0) /\
         (!n. 0 ** NUMERAL (BIT2 n) = 0) /\ (!n. n ** 0 = 1) /\
         (!n m. NUMERAL n ** NUMERAL m = NUMERAL (n ** m)) /\
         (SUC 0 = 1) /\ (!n. SUC (NUMERAL n) = NUMERAL (SUC n)) /\
         (PRE 0 = 0) /\ (!n. PRE (NUMERAL n) = NUMERAL (PRE n)) /\
         (!n. (NUMERAL n = 0) &lt;=&gt; (n = ZERO)) /\
         (!n. (0 = NUMERAL n) &lt;=&gt; (n = ZERO)) /\
         (!n m. (NUMERAL n = NUMERAL m) &lt;=&gt; (n = m)) /\
         (!n. n &lt; 0 &lt;=&gt; F) /\ (!n. 0 &lt; NUMERAL n &lt;=&gt; ZERO &lt; n) /\
         (!n m. NUMERAL n &lt; NUMERAL m &lt;=&gt; n &lt; m) /\ (!n. 0 &gt; n &lt;=&gt; F) /\
         (!n. NUMERAL n &gt; 0 &lt;=&gt; ZERO &lt; n) /\
         (!n m. NUMERAL n &gt; NUMERAL m &lt;=&gt; m &lt; n) /\ (!n. 0 &lt;= n &lt;=&gt; T) /\
         (!n. NUMERAL n &lt;= 0 &lt;=&gt; n &lt;= ZERO) /\
         (!n m. NUMERAL n &lt;= NUMERAL m &lt;=&gt; n &lt;= m) /\ (!n. n &gt;= 0 &lt;=&gt; T) /\
         (!n. 0 &gt;= n &lt;=&gt; (n = 0)) /\
         (!n m. NUMERAL n &gt;= NUMERAL m &lt;=&gt; m &lt;= n) /\
         (!n. ODD (NUMERAL n) &lt;=&gt; ODD n) /\
         (!n. EVEN (NUMERAL n) &lt;=&gt; EVEN n) /\ ~ODD 0 /\ EVEN 0
   
   [<A NAME="numeral_div2-val"><B>numeral_div2</B></A>]  Theorem
      
      |- (DIV2 0 = 0) /\ (!n. DIV2 (NUMERAL (BIT1 n)) = NUMERAL n) /\
         !n. DIV2 (NUMERAL (BIT2 n)) = NUMERAL (SUC n)
   
   [<A NAME="numeral_eq-val"><B>numeral_eq</B></A>]  Theorem
      
      |- !n m.
           ((ZERO = BIT1 n) &lt;=&gt; F) /\ ((BIT1 n = ZERO) &lt;=&gt; F) /\
           ((ZERO = BIT2 n) &lt;=&gt; F) /\ ((BIT2 n = ZERO) &lt;=&gt; F) /\
           ((BIT1 n = BIT2 m) &lt;=&gt; F) /\ ((BIT2 n = BIT1 m) &lt;=&gt; F) /\
           ((BIT1 n = BIT1 m) &lt;=&gt; (n = m)) /\
           ((BIT2 n = BIT2 m) &lt;=&gt; (n = m))
   
   [<A NAME="numeral_evenodd-val"><B>numeral_evenodd</B></A>]  Theorem
      
      |- !n.
           EVEN ZERO /\ EVEN (BIT2 n) /\ ~EVEN (BIT1 n) /\ ~ODD ZERO /\
           ~ODD (BIT2 n) /\ ODD (BIT1 n)
   
   [<A NAME="numeral_exp-val"><B>numeral_exp</B></A>]  Theorem
      
      |- (!n. n ** ZERO = BIT1 ZERO) /\
         (!n m. n ** BIT1 m = n * numeral$iSQR (n ** m)) /\
         !n m. n ** BIT2 m = numeral$iSQR n * numeral$iSQR (n ** m)
   
   [<A NAME="numeral_fact-val"><B>numeral_fact</B></A>]  Theorem
      
      |- (FACT 0 = 1) /\
         (!n.
            FACT (NUMERAL (BIT1 n)) =
            NUMERAL (BIT1 n) * FACT (PRE (NUMERAL (BIT1 n)))) /\
         !n.
           FACT (NUMERAL (BIT2 n)) =
           NUMERAL (BIT2 n) * FACT (NUMERAL (BIT1 n))
   
   [<A NAME="numeral_funpow-val"><B>numeral_funpow</B></A>]  Theorem
      
      |- (FUNPOW f 0 x = x) /\
         (FUNPOW f (NUMERAL (BIT1 n)) x =
          FUNPOW f (PRE (NUMERAL (BIT1 n))) (f x)) /\
         (FUNPOW f (NUMERAL (BIT2 n)) x =
          FUNPOW f (NUMERAL (BIT1 n)) (f x))
   
   [<A NAME="numeral_iisuc-val"><B>numeral_iisuc</B></A>]  Theorem
      
      |- (numeral$iiSUC ZERO = BIT2 ZERO) /\
         (numeral$iiSUC (BIT1 n) = BIT1 (SUC n)) /\
         (numeral$iiSUC (BIT2 n) = BIT2 (SUC n))
   
   [<A NAME="numeral_imod_2exp-val"><B>numeral_imod_2exp</B></A>]  Theorem
      
      |- (!n. numeral$iMOD_2EXP 0 n = ZERO) /\
         (!x n. numeral$iMOD_2EXP x ZERO = ZERO) /\
         (!x n.
            numeral$iMOD_2EXP (NUMERAL (BIT1 x)) (BIT1 n) =
            BIT1 (numeral$iMOD_2EXP (NUMERAL (BIT1 x) - 1) n)) /\
         (!x n.
            numeral$iMOD_2EXP (NUMERAL (BIT2 x)) (BIT1 n) =
            BIT1 (numeral$iMOD_2EXP (NUMERAL (BIT1 x)) n)) /\
         (!x n.
            numeral$iMOD_2EXP (NUMERAL (BIT1 x)) (BIT2 n) =
            numeral$iDUB
              (numeral$iMOD_2EXP (NUMERAL (BIT1 x) - 1) (SUC n))) /\
         !x n.
           numeral$iMOD_2EXP (NUMERAL (BIT2 x)) (BIT2 n) =
           numeral$iDUB (numeral$iMOD_2EXP (NUMERAL (BIT1 x)) (SUC n))
   
   [<A NAME="numeral_lt-val"><B>numeral_lt</B></A>]  Theorem
      
      |- !n m.
           (ZERO &lt; BIT1 n &lt;=&gt; T) /\ (ZERO &lt; BIT2 n &lt;=&gt; T) /\
           (n &lt; ZERO &lt;=&gt; F) /\ (BIT1 n &lt; BIT1 m &lt;=&gt; n &lt; m) /\
           (BIT2 n &lt; BIT2 m &lt;=&gt; n &lt; m) /\ (BIT1 n &lt; BIT2 m &lt;=&gt; ~(m &lt; n)) /\
           (BIT2 n &lt; BIT1 m &lt;=&gt; n &lt; m)
   
   [<A NAME="numeral_lte-val"><B>numeral_lte</B></A>]  Theorem
      
      |- !n m.
           (ZERO &lt;= n &lt;=&gt; T) /\ (BIT1 n &lt;= ZERO &lt;=&gt; F) /\
           (BIT2 n &lt;= ZERO &lt;=&gt; F) /\ (BIT1 n &lt;= BIT1 m &lt;=&gt; n &lt;= m) /\
           (BIT1 n &lt;= BIT2 m &lt;=&gt; n &lt;= m) /\
           (BIT2 n &lt;= BIT1 m &lt;=&gt; ~(m &lt;= n)) /\
           (BIT2 n &lt;= BIT2 m &lt;=&gt; n &lt;= m)
   
   [<A NAME="numeral_mult-val"><B>numeral_mult</B></A>]  Theorem
      
      |- !n m.
           (ZERO * n = ZERO) /\ (n * ZERO = ZERO) /\
           (BIT1 n * m = numeral$iZ (numeral$iDUB (n * m) + m)) /\
           (BIT2 n * m = numeral$iDUB (numeral$iZ (n * m + m)))
   
   [<A NAME="numeral_pre-val"><B>numeral_pre</B></A>]  Theorem
      
      |- (PRE ZERO = ZERO) /\ (PRE (BIT1 ZERO) = ZERO) /\
         (!n. PRE (BIT1 (BIT1 n)) = BIT2 (PRE (BIT1 n))) /\
         (!n. PRE (BIT1 (BIT2 n)) = BIT2 (BIT1 n)) /\
         !n. PRE (BIT2 n) = BIT1 n
   
   [<A NAME="numeral_sub-val"><B>numeral_sub</B></A>]  Theorem
      
      |- !n m.
           NUMERAL (n - m) =
           if m &lt; n then NUMERAL (numeral$iSUB T n m) else 0
   
   [<A NAME="numeral_suc-val"><B>numeral_suc</B></A>]  Theorem
      
      |- (SUC ZERO = BIT1 ZERO) /\ (!n. SUC (BIT1 n) = BIT2 n) /\
         !n. SUC (BIT2 n) = BIT1 (SUC n)
   
   [<A NAME="numeral_texp_help-val"><B>numeral_texp_help</B></A>]  Theorem
      
      |- (numeral$texp_help ZERO acc = BIT2 acc) /\
         (numeral$texp_help (BIT1 n) acc =
          numeral$texp_help (PRE (BIT1 n)) (BIT1 acc)) /\
         (numeral$texp_help (BIT2 n) acc =
          numeral$texp_help (BIT1 n) (BIT1 acc))
   
   [<A NAME="onecount_characterisation-val"><B>onecount_characterisation</B></A>]  Theorem
      
      |- !n a.
           0 &lt; numeral$onecount n a /\ 0 &lt; n ==&gt;
           (n = 2 ** (numeral$onecount n a - a) - 1)
   
   [<A NAME="texp_help0-val"><B>texp_help0</B></A>]  Theorem
      
      |- numeral$texp_help n 0 = 2 ** (n + 1)
   
   [<A NAME="texp_help_thm-val"><B>texp_help_thm</B></A>]  Theorem
      
      |- !n a. numeral$texp_help n a = (a + 1) * 2 ** (n + 1)
   
   
*)
end

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/num/theories/numeralScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
