<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure Temporal_LogicTheory</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure Temporal_LogicTheory</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/temporal/src/Temporal_LogicScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>signature Temporal_LogicTheory =
<A NAME="line2"></A>sig
<A NAME="line3"></A>  type thm = Thm.thm
<A NAME="line4"></A>  
<A NAME="line5"></A>  (*  Definitions  *)
<A NAME="line6"></A>    val <A HREF="#ALWAYS-val">ALWAYS</A> : thm
<A NAME="line7"></A>    val <A HREF="#BEFORE-val">BEFORE</A> : thm
<A NAME="line8"></A>    val <A HREF="#EVENTUAL-val">EVENTUAL</A> : thm
<A NAME="line9"></A>    val <A HREF="#NEXT-val">NEXT</A> : thm
<A NAME="line10"></A>    val <A HREF="#SBEFORE-val">SBEFORE</A> : thm
<A NAME="line11"></A>    val <A HREF="#SUNTIL-val">SUNTIL</A> : thm
<A NAME="line12"></A>    val <A HREF="#SWHEN-val">SWHEN</A> : thm
<A NAME="line13"></A>    val <A HREF="#UNTIL-val">UNTIL</A> : thm
<A NAME="line14"></A>    val <A HREF="#UPTO-val">UPTO</A> : thm
<A NAME="line15"></A>    val <A HREF="#WATCH-val">WATCH</A> : thm
<A NAME="line16"></A>    val <A HREF="#WHEN-val">WHEN</A> : thm
<A NAME="line17"></A>  
<A NAME="line18"></A>  (*  Theorems  *)
<A NAME="line19"></A>    val <A HREF="#ALWAYS_AS_BEFORE-val">ALWAYS_AS_BEFORE</A> : thm
<A NAME="line20"></A>    val <A HREF="#ALWAYS_AS_SBEFORE-val">ALWAYS_AS_SBEFORE</A> : thm
<A NAME="line21"></A>    val <A HREF="#ALWAYS_AS_SUNTIL-val">ALWAYS_AS_SUNTIL</A> : thm
<A NAME="line22"></A>    val <A HREF="#ALWAYS_AS_SWHEN-val">ALWAYS_AS_SWHEN</A> : thm
<A NAME="line23"></A>    val <A HREF="#ALWAYS_AS_UNTIL-val">ALWAYS_AS_UNTIL</A> : thm
<A NAME="line24"></A>    val <A HREF="#ALWAYS_AS_WHEN-val">ALWAYS_AS_WHEN</A> : thm
<A NAME="line25"></A>    val <A HREF="#ALWAYS_FIX-val">ALWAYS_FIX</A> : thm
<A NAME="line26"></A>    val <A HREF="#ALWAYS_IDEM-val">ALWAYS_IDEM</A> : thm
<A NAME="line27"></A>    val <A HREF="#ALWAYS_INVARIANT-val">ALWAYS_INVARIANT</A> : thm
<A NAME="line28"></A>    val <A HREF="#ALWAYS_LINORD-val">ALWAYS_LINORD</A> : thm
<A NAME="line29"></A>    val <A HREF="#ALWAYS_NEXT-val">ALWAYS_NEXT</A> : thm
<A NAME="line30"></A>    val <A HREF="#ALWAYS_REC-val">ALWAYS_REC</A> : thm
<A NAME="line31"></A>    val <A HREF="#ALWAYS_SIGNAL-val">ALWAYS_SIGNAL</A> : thm
<A NAME="line32"></A>    val <A HREF="#AND_NEXT-val">AND_NEXT</A> : thm
<A NAME="line33"></A>    val <A HREF="#BEFORE_AS_NOT_SWHEN-val">BEFORE_AS_NOT_SWHEN</A> : thm
<A NAME="line34"></A>    val <A HREF="#BEFORE_AS_SBEFORE-val">BEFORE_AS_SBEFORE</A> : thm
<A NAME="line35"></A>    val <A HREF="#BEFORE_AS_SUNTIL-val">BEFORE_AS_SUNTIL</A> : thm
<A NAME="line36"></A>    val <A HREF="#BEFORE_AS_SWHEN-val">BEFORE_AS_SWHEN</A> : thm
<A NAME="line37"></A>    val <A HREF="#BEFORE_AS_UNTIL-val">BEFORE_AS_UNTIL</A> : thm
<A NAME="line38"></A>    val <A HREF="#BEFORE_AS_WHEN-val">BEFORE_AS_WHEN</A> : thm
<A NAME="line39"></A>    val <A HREF="#BEFORE_AS_WHEN_UNTIL-val">BEFORE_AS_WHEN_UNTIL</A> : thm
<A NAME="line40"></A>    val <A HREF="#BEFORE_EVENT-val">BEFORE_EVENT</A> : thm
<A NAME="line41"></A>    val <A HREF="#BEFORE_FIX-val">BEFORE_FIX</A> : thm
<A NAME="line42"></A>    val <A HREF="#BEFORE_HW-val">BEFORE_HW</A> : thm
<A NAME="line43"></A>    val <A HREF="#BEFORE_IDEM-val">BEFORE_IDEM</A> : thm
<A NAME="line44"></A>    val <A HREF="#BEFORE_IMP-val">BEFORE_IMP</A> : thm
<A NAME="line45"></A>    val <A HREF="#BEFORE_INVARIANT-val">BEFORE_INVARIANT</A> : thm
<A NAME="line46"></A>    val <A HREF="#BEFORE_LINORD-val">BEFORE_LINORD</A> : thm
<A NAME="line47"></A>    val <A HREF="#BEFORE_NEXT-val">BEFORE_NEXT</A> : thm
<A NAME="line48"></A>    val <A HREF="#BEFORE_REC-val">BEFORE_REC</A> : thm
<A NAME="line49"></A>    val <A HREF="#BEFORE_SIGNAL-val">BEFORE_SIGNAL</A> : thm
<A NAME="line50"></A>    val <A HREF="#BEFORE_SIMP-val">BEFORE_SIMP</A> : thm
<A NAME="line51"></A>    val <A HREF="#DELTA_CASES-val">DELTA_CASES</A> : thm
<A NAME="line52"></A>    val <A HREF="#EQUIV_NEXT-val">EQUIV_NEXT</A> : thm
<A NAME="line53"></A>    val <A HREF="#EVENTUAL_AS_BEFORE-val">EVENTUAL_AS_BEFORE</A> : thm
<A NAME="line54"></A>    val <A HREF="#EVENTUAL_AS_SBEFORE-val">EVENTUAL_AS_SBEFORE</A> : thm
<A NAME="line55"></A>    val <A HREF="#EVENTUAL_AS_SUNTIL-val">EVENTUAL_AS_SUNTIL</A> : thm
<A NAME="line56"></A>    val <A HREF="#EVENTUAL_AS_SWHEN-val">EVENTUAL_AS_SWHEN</A> : thm
<A NAME="line57"></A>    val <A HREF="#EVENTUAL_AS_UNTIL-val">EVENTUAL_AS_UNTIL</A> : thm
<A NAME="line58"></A>    val <A HREF="#EVENTUAL_AS_WHEN-val">EVENTUAL_AS_WHEN</A> : thm
<A NAME="line59"></A>    val <A HREF="#EVENTUAL_FIX-val">EVENTUAL_FIX</A> : thm
<A NAME="line60"></A>    val <A HREF="#EVENTUAL_IDEM-val">EVENTUAL_IDEM</A> : thm
<A NAME="line61"></A>    val <A HREF="#EVENTUAL_INVARIANT-val">EVENTUAL_INVARIANT</A> : thm
<A NAME="line62"></A>    val <A HREF="#EVENTUAL_LINORD-val">EVENTUAL_LINORD</A> : thm
<A NAME="line63"></A>    val <A HREF="#EVENTUAL_NEXT-val">EVENTUAL_NEXT</A> : thm
<A NAME="line64"></A>    val <A HREF="#EVENTUAL_REC-val">EVENTUAL_REC</A> : thm
<A NAME="line65"></A>    val <A HREF="#EVENTUAL_SIGNAL-val">EVENTUAL_SIGNAL</A> : thm
<A NAME="line66"></A>    val <A HREF="#IMMEDIATE_EVENT-val">IMMEDIATE_EVENT</A> : thm
<A NAME="line67"></A>    val <A HREF="#IMP_NEXT-val">IMP_NEXT</A> : thm
<A NAME="line68"></A>    val <A HREF="#MORE_EVENT-val">MORE_EVENT</A> : thm
<A NAME="line69"></A>    val <A HREF="#NEXT_LINORD-val">NEXT_LINORD</A> : thm
<A NAME="line70"></A>    val <A HREF="#NOT_ALWAYS-val">NOT_ALWAYS</A> : thm
<A NAME="line71"></A>    val <A HREF="#NOT_BEFORE-val">NOT_BEFORE</A> : thm
<A NAME="line72"></A>    val <A HREF="#NOT_EVENTUAL-val">NOT_EVENTUAL</A> : thm
<A NAME="line73"></A>    val <A HREF="#NOT_NEXT-val">NOT_NEXT</A> : thm
<A NAME="line74"></A>    val <A HREF="#NOT_SBEFORE-val">NOT_SBEFORE</A> : thm
<A NAME="line75"></A>    val <A HREF="#NOT_SUNTIL-val">NOT_SUNTIL</A> : thm
<A NAME="line76"></A>    val <A HREF="#NOT_SWHEN-val">NOT_SWHEN</A> : thm
<A NAME="line77"></A>    val <A HREF="#NOT_UNTIL-val">NOT_UNTIL</A> : thm
<A NAME="line78"></A>    val <A HREF="#NOT_WHEN-val">NOT_WHEN</A> : thm
<A NAME="line79"></A>    val <A HREF="#NO_EVENT-val">NO_EVENT</A> : thm
<A NAME="line80"></A>    val <A HREF="#OR_NEXT-val">OR_NEXT</A> : thm
<A NAME="line81"></A>    val <A HREF="#SBEFORE_AS_BEFORE-val">SBEFORE_AS_BEFORE</A> : thm
<A NAME="line82"></A>    val <A HREF="#SBEFORE_AS_SUNTIL-val">SBEFORE_AS_SUNTIL</A> : thm
<A NAME="line83"></A>    val <A HREF="#SBEFORE_AS_SWHEN-val">SBEFORE_AS_SWHEN</A> : thm
<A NAME="line84"></A>    val <A HREF="#SBEFORE_AS_UNTIL-val">SBEFORE_AS_UNTIL</A> : thm
<A NAME="line85"></A>    val <A HREF="#SBEFORE_AS_WHEN-val">SBEFORE_AS_WHEN</A> : thm
<A NAME="line86"></A>    val <A HREF="#SBEFORE_EVENT-val">SBEFORE_EVENT</A> : thm
<A NAME="line87"></A>    val <A HREF="#SBEFORE_IDEM-val">SBEFORE_IDEM</A> : thm
<A NAME="line88"></A>    val <A HREF="#SBEFORE_IMP-val">SBEFORE_IMP</A> : thm
<A NAME="line89"></A>    val <A HREF="#SBEFORE_INVARIANT-val">SBEFORE_INVARIANT</A> : thm
<A NAME="line90"></A>    val <A HREF="#SBEFORE_LINORD-val">SBEFORE_LINORD</A> : thm
<A NAME="line91"></A>    val <A HREF="#SBEFORE_NEXT-val">SBEFORE_NEXT</A> : thm
<A NAME="line92"></A>    val <A HREF="#SBEFORE_REC-val">SBEFORE_REC</A> : thm
<A NAME="line93"></A>    val <A HREF="#SBEFORE_SIGNAL-val">SBEFORE_SIGNAL</A> : thm
<A NAME="line94"></A>    val <A HREF="#SBEFORE_SIMP-val">SBEFORE_SIMP</A> : thm
<A NAME="line95"></A>    val <A HREF="#SOME_EVENT-val">SOME_EVENT</A> : thm
<A NAME="line96"></A>    val <A HREF="#SUNTIL_AS_BEFORE-val">SUNTIL_AS_BEFORE</A> : thm
<A NAME="line97"></A>    val <A HREF="#SUNTIL_AS_SBEFORE-val">SUNTIL_AS_SBEFORE</A> : thm
<A NAME="line98"></A>    val <A HREF="#SUNTIL_AS_SWHEN-val">SUNTIL_AS_SWHEN</A> : thm
<A NAME="line99"></A>    val <A HREF="#SUNTIL_AS_UNTIL-val">SUNTIL_AS_UNTIL</A> : thm
<A NAME="line100"></A>    val <A HREF="#SUNTIL_AS_WHEN-val">SUNTIL_AS_WHEN</A> : thm
<A NAME="line101"></A>    val <A HREF="#SUNTIL_EVENT-val">SUNTIL_EVENT</A> : thm
<A NAME="line102"></A>    val <A HREF="#SUNTIL_IDEM-val">SUNTIL_IDEM</A> : thm
<A NAME="line103"></A>    val <A HREF="#SUNTIL_IMP-val">SUNTIL_IMP</A> : thm
<A NAME="line104"></A>    val <A HREF="#SUNTIL_INVARIANT-val">SUNTIL_INVARIANT</A> : thm
<A NAME="line105"></A>    val <A HREF="#SUNTIL_LINORD-val">SUNTIL_LINORD</A> : thm
<A NAME="line106"></A>    val <A HREF="#SUNTIL_NEXT-val">SUNTIL_NEXT</A> : thm
<A NAME="line107"></A>    val <A HREF="#SUNTIL_REC-val">SUNTIL_REC</A> : thm
<A NAME="line108"></A>    val <A HREF="#SUNTIL_SIGNAL-val">SUNTIL_SIGNAL</A> : thm
<A NAME="line109"></A>    val <A HREF="#SUNTIL_SIMP-val">SUNTIL_SIMP</A> : thm
<A NAME="line110"></A>    val <A HREF="#SWHEN_AS_BEFORE-val">SWHEN_AS_BEFORE</A> : thm
<A NAME="line111"></A>    val <A HREF="#SWHEN_AS_NOT_WHEN-val">SWHEN_AS_NOT_WHEN</A> : thm
<A NAME="line112"></A>    val <A HREF="#SWHEN_AS_SBEFORE-val">SWHEN_AS_SBEFORE</A> : thm
<A NAME="line113"></A>    val <A HREF="#SWHEN_AS_SUNTIL-val">SWHEN_AS_SUNTIL</A> : thm
<A NAME="line114"></A>    val <A HREF="#SWHEN_AS_UNTIL-val">SWHEN_AS_UNTIL</A> : thm
<A NAME="line115"></A>    val <A HREF="#SWHEN_AS_WHEN-val">SWHEN_AS_WHEN</A> : thm
<A NAME="line116"></A>    val <A HREF="#SWHEN_EVENT-val">SWHEN_EVENT</A> : thm
<A NAME="line117"></A>    val <A HREF="#SWHEN_IDEM-val">SWHEN_IDEM</A> : thm
<A NAME="line118"></A>    val <A HREF="#SWHEN_IMP-val">SWHEN_IMP</A> : thm
<A NAME="line119"></A>    val <A HREF="#SWHEN_INVARIANT-val">SWHEN_INVARIANT</A> : thm
<A NAME="line120"></A>    val <A HREF="#SWHEN_LINORD-val">SWHEN_LINORD</A> : thm
<A NAME="line121"></A>    val <A HREF="#SWHEN_NEXT-val">SWHEN_NEXT</A> : thm
<A NAME="line122"></A>    val <A HREF="#SWHEN_REC-val">SWHEN_REC</A> : thm
<A NAME="line123"></A>    val <A HREF="#SWHEN_SIGNAL-val">SWHEN_SIGNAL</A> : thm
<A NAME="line124"></A>    val <A HREF="#SWHEN_SIMP-val">SWHEN_SIMP</A> : thm
<A NAME="line125"></A>    val <A HREF="#UNTIL_AS_BEFORE-val">UNTIL_AS_BEFORE</A> : thm
<A NAME="line126"></A>    val <A HREF="#UNTIL_AS_SBEFORE-val">UNTIL_AS_SBEFORE</A> : thm
<A NAME="line127"></A>    val <A HREF="#UNTIL_AS_SUNTIL-val">UNTIL_AS_SUNTIL</A> : thm
<A NAME="line128"></A>    val <A HREF="#UNTIL_AS_SWHEN-val">UNTIL_AS_SWHEN</A> : thm
<A NAME="line129"></A>    val <A HREF="#UNTIL_AS_WHEN-val">UNTIL_AS_WHEN</A> : thm
<A NAME="line130"></A>    val <A HREF="#UNTIL_EVENT-val">UNTIL_EVENT</A> : thm
<A NAME="line131"></A>    val <A HREF="#UNTIL_FIX-val">UNTIL_FIX</A> : thm
<A NAME="line132"></A>    val <A HREF="#UNTIL_IDEM-val">UNTIL_IDEM</A> : thm
<A NAME="line133"></A>    val <A HREF="#UNTIL_IMP-val">UNTIL_IMP</A> : thm
<A NAME="line134"></A>    val <A HREF="#UNTIL_INVARIANT-val">UNTIL_INVARIANT</A> : thm
<A NAME="line135"></A>    val <A HREF="#UNTIL_LINORD-val">UNTIL_LINORD</A> : thm
<A NAME="line136"></A>    val <A HREF="#UNTIL_NEXT-val">UNTIL_NEXT</A> : thm
<A NAME="line137"></A>    val <A HREF="#UNTIL_REC-val">UNTIL_REC</A> : thm
<A NAME="line138"></A>    val <A HREF="#UNTIL_SIGNAL-val">UNTIL_SIGNAL</A> : thm
<A NAME="line139"></A>    val <A HREF="#UNTIL_SIMP-val">UNTIL_SIMP</A> : thm
<A NAME="line140"></A>    val <A HREF="#WATCH_EXISTS-val">WATCH_EXISTS</A> : thm
<A NAME="line141"></A>    val <A HREF="#WATCH_REC-val">WATCH_REC</A> : thm
<A NAME="line142"></A>    val <A HREF="#WATCH_SIGNAL-val">WATCH_SIGNAL</A> : thm
<A NAME="line143"></A>    val <A HREF="#WELL_ORDER-val">WELL_ORDER</A> : thm
<A NAME="line144"></A>    val <A HREF="#WELL_ORDER_UNIQUE-val">WELL_ORDER_UNIQUE</A> : thm
<A NAME="line145"></A>    val <A HREF="#WHEN_AS_BEFORE-val">WHEN_AS_BEFORE</A> : thm
<A NAME="line146"></A>    val <A HREF="#WHEN_AS_NOT_SWHEN-val">WHEN_AS_NOT_SWHEN</A> : thm
<A NAME="line147"></A>    val <A HREF="#WHEN_AS_SBEFORE-val">WHEN_AS_SBEFORE</A> : thm
<A NAME="line148"></A>    val <A HREF="#WHEN_AS_SUNTIL-val">WHEN_AS_SUNTIL</A> : thm
<A NAME="line149"></A>    val <A HREF="#WHEN_AS_SWHEN-val">WHEN_AS_SWHEN</A> : thm
<A NAME="line150"></A>    val <A HREF="#WHEN_AS_UNTIL-val">WHEN_AS_UNTIL</A> : thm
<A NAME="line151"></A>    val <A HREF="#WHEN_EVENT-val">WHEN_EVENT</A> : thm
<A NAME="line152"></A>    val <A HREF="#WHEN_FIX-val">WHEN_FIX</A> : thm
<A NAME="line153"></A>    val <A HREF="#WHEN_IDEM-val">WHEN_IDEM</A> : thm
<A NAME="line154"></A>    val <A HREF="#WHEN_IMP-val">WHEN_IMP</A> : thm
<A NAME="line155"></A>    val <A HREF="#WHEN_INVARIANT-val">WHEN_INVARIANT</A> : thm
<A NAME="line156"></A>    val <A HREF="#WHEN_LINORD-val">WHEN_LINORD</A> : thm
<A NAME="line157"></A>    val <A HREF="#WHEN_NEXT-val">WHEN_NEXT</A> : thm
<A NAME="line158"></A>    val <A HREF="#WHEN_REC-val">WHEN_REC</A> : thm
<A NAME="line159"></A>    val <A HREF="#WHEN_SIGNAL-val">WHEN_SIGNAL</A> : thm
<A NAME="line160"></A>    val <A HREF="#WHEN_SIMP-val">WHEN_SIMP</A> : thm
<A NAME="line161"></A>    val <A HREF="#WHEN_SWHEN_LEMMA-val">WHEN_SWHEN_LEMMA</A> : thm
<A NAME="line162"></A>  
<A NAME="line163"></A>  val Temporal_Logic_grammars : type_grammar.grammar * term_grammar.grammar
<A NAME="line164"></A>  
<A NAME="line165"></A>  
<A NAME="line166"></A>(*
   [list] Parent theory of "Temporal_Logic"
   
   [<A NAME="ALWAYS-val"><B>ALWAYS</B></A>]  Definition
      
      |- !P t0. ALWAYS P t0 &lt;=&gt; !t. P (t + t0)
   
   [<A NAME="BEFORE-val"><B>BEFORE</B></A>]  Definition
      
      |- !a b t0.
           (a BEFORE b) t0 &lt;=&gt;
           ?q.
             (q WATCH b) t0 /\
             ((?t. ~q (t + t0) /\ ~b (t + t0) /\ a (t + t0)) \/
              !t. ~b (t + t0))
   
   [<A NAME="EVENTUAL-val"><B>EVENTUAL</B></A>]  Definition
      
      |- !P t0. EVENTUAL P t0 &lt;=&gt; ?t. P (t + t0)
   
   [<A NAME="NEXT-val"><B>NEXT</B></A>]  Definition
      
      |- !P. NEXT P = (\t. P (SUC t))
   
   [<A NAME="SBEFORE-val"><B>SBEFORE</B></A>]  Definition
      
      |- !a b t0.
           (a SBEFORE b) t0 &lt;=&gt;
           ?q.
             (q WATCH b) t0 /\ ?t. ~q (t + t0) /\ ~b (t + t0) /\ a (t + t0)
   
   [<A NAME="SUNTIL-val"><B>SUNTIL</B></A>]  Definition
      
      |- !a b t0.
           (a SUNTIL b) t0 &lt;=&gt;
           ?q.
             (q WATCH b) t0 /\
             (!t. q (t + t0) \/ b (t + t0) \/ a (t + t0)) /\ ?t. b (t + t0)
   
   [<A NAME="SWHEN-val"><B>SWHEN</B></A>]  Definition
      
      |- !a b t0.
           (a SWHEN b) t0 &lt;=&gt;
           ?q.
             (q WATCH b) t0 /\ ?t. ~q (t + t0) /\ b (t + t0) /\ a (t + t0)
   
   [<A NAME="UNTIL-val"><B>UNTIL</B></A>]  Definition
      
      |- !a b t0.
           (a UNTIL b) t0 &lt;=&gt;
           ?q. (q WATCH b) t0 /\ !t. q (t + t0) \/ b (t + t0) \/ a (t + t0)
   
   [<A NAME="UPTO-val"><B>UPTO</B></A>]  Definition
      
      |- !t0 t1 a. UPTO (t0,t1,a) &lt;=&gt; !t2. t0 &lt;= t2 /\ t2 &lt; t1 ==&gt; a t2
   
   [<A NAME="WATCH-val"><B>WATCH</B></A>]  Definition
      
      |- !q b t0.
           (q WATCH b) t0 &lt;=&gt;
           !t.
             (q t0 &lt;=&gt; F) /\
             (q (SUC (t + t0)) &lt;=&gt; q (t + t0) \/ b (t + t0))
   
   [<A NAME="WHEN-val"><B>WHEN</B></A>]  Definition
      
      |- !a b t0.
           (a WHEN b) t0 &lt;=&gt;
           ?q.
             (q WATCH b) t0 /\
             !t. q (t + t0) \/ (b (t + t0) ==&gt; a (t + t0))
   
   [<A NAME="ALWAYS_AS_BEFORE-val"><B>ALWAYS_AS_BEFORE</B></A>]  Theorem
      
      |- ALWAYS b = (\t. F) BEFORE (\t. ~b t)
   
   [<A NAME="ALWAYS_AS_SBEFORE-val"><B>ALWAYS_AS_SBEFORE</B></A>]  Theorem
      
      |- ALWAYS b = (\t0. ~((\t. ~b t) SBEFORE (\t. F)) t0)
   
   [<A NAME="ALWAYS_AS_SUNTIL-val"><B>ALWAYS_AS_SUNTIL</B></A>]  Theorem
      
      |- ALWAYS a = (\t. ~((\t. T) SUNTIL (\t. ~a t)) t)
   
   [<A NAME="ALWAYS_AS_SWHEN-val"><B>ALWAYS_AS_SWHEN</B></A>]  Theorem
      
      |- ALWAYS a = (\t. ~((\t. T) SWHEN (\t. ~a t)) t)
   
   [<A NAME="ALWAYS_AS_UNTIL-val"><B>ALWAYS_AS_UNTIL</B></A>]  Theorem
      
      |- ALWAYS a = a UNTIL (\t. F)
   
   [<A NAME="ALWAYS_AS_WHEN-val"><B>ALWAYS_AS_WHEN</B></A>]  Theorem
      
      |- ALWAYS a = (\t. F) WHEN (\t. ~a t)
   
   [<A NAME="ALWAYS_FIX-val"><B>ALWAYS_FIX</B></A>]  Theorem
      
      |- (y = (\t. a t /\ y (t + 1))) &lt;=&gt; (y = ALWAYS a) \/ (y = (\t. F))
   
   [<A NAME="ALWAYS_IDEM-val"><B>ALWAYS_IDEM</B></A>]  Theorem
      
      |- ALWAYS a = ALWAYS (ALWAYS a)
   
   [<A NAME="ALWAYS_INVARIANT-val"><B>ALWAYS_INVARIANT</B></A>]  Theorem
      
      |- ALWAYS a t0 &lt;=&gt;
         ?J. J t0 /\ !t. J (t + t0) ==&gt; a (t + t0) /\ J (t + (t0 + 1))
   
   [<A NAME="ALWAYS_LINORD-val"><B>ALWAYS_LINORD</B></A>]  Theorem
      
      |- ALWAYS a t0 &lt;=&gt; !t1. t0 &lt;= t1 ==&gt; a t1
   
   [<A NAME="ALWAYS_NEXT-val"><B>ALWAYS_NEXT</B></A>]  Theorem
      
      |- !a. NEXT (ALWAYS a) = ALWAYS (NEXT a)
   
   [<A NAME="ALWAYS_REC-val"><B>ALWAYS_REC</B></A>]  Theorem
      
      |- ALWAYS P t0 &lt;=&gt; P t0 /\ NEXT (ALWAYS P) t0
   
   [<A NAME="ALWAYS_SIGNAL-val"><B>ALWAYS_SIGNAL</B></A>]  Theorem
      
      |- ALWAYS a t0 &lt;=&gt; !t. a (t + t0)
   
   [<A NAME="AND_NEXT-val"><B>AND_NEXT</B></A>]  Theorem
      
      |- !Q P. NEXT (\t. P t /\ Q t) = (\t. NEXT P t /\ NEXT Q t)
   
   [<A NAME="BEFORE_AS_NOT_SWHEN-val"><B>BEFORE_AS_NOT_SWHEN</B></A>]  Theorem
      
      |- a BEFORE b = (\t0. ~(b SWHEN (\t. a t \/ b t)) t0)
   
   [<A NAME="BEFORE_AS_SBEFORE-val"><B>BEFORE_AS_SBEFORE</B></A>]  Theorem
      
      |- a BEFORE b = (\t0. (a SBEFORE b) t0 \/ ALWAYS (\t. ~b t) t0)
   
   [<A NAME="BEFORE_AS_SUNTIL-val"><B>BEFORE_AS_SUNTIL</B></A>]  Theorem
      
      |- a BEFORE b = (\t. ~((\t. ~a t) SUNTIL b) t)
   
   [<A NAME="BEFORE_AS_SWHEN-val"><B>BEFORE_AS_SWHEN</B></A>]  Theorem
      
      |- a BEFORE b =
         (\t0.
            ((\t. ~b t) SWHEN (\t. a t \/ b t)) t0 \/
            ALWAYS (\t. ~a t /\ ~b t) t0)
   
   [<A NAME="BEFORE_AS_UNTIL-val"><B>BEFORE_AS_UNTIL</B></A>]  Theorem
      
      |- a BEFORE b =
         (\t0. ~((\t. ~a t) UNTIL b) t0 \/ ALWAYS (\t. ~b t) t0)
   
   [<A NAME="BEFORE_AS_WHEN-val"><B>BEFORE_AS_WHEN</B></A>]  Theorem
      
      |- a BEFORE b = (\t. ~b t) WHEN (\t. a t \/ b t)
   
   [<A NAME="BEFORE_AS_WHEN_UNTIL-val"><B>BEFORE_AS_WHEN_UNTIL</B></A>]  Theorem
      
      |- a BEFORE b = (\t. ((\t. ~b t) UNTIL a) t /\ ((\t. ~b t) WHEN a) t)
   
   [<A NAME="BEFORE_EVENT-val"><B>BEFORE_EVENT</B></A>]  Theorem
      
      |- a BEFORE b = (\t. a t /\ ~b t) BEFORE b
   
   [<A NAME="BEFORE_FIX-val"><B>BEFORE_FIX</B></A>]  Theorem
      
      |- !y.
           (y = (\t. ~b t /\ (a t \/ y (t + 1)))) &lt;=&gt;
           (y = a BEFORE b) \/ (y = a SBEFORE b)
   
   [<A NAME="BEFORE_HW-val"><B>BEFORE_HW</B></A>]  Theorem
      
      |- (a BEFORE b) t0 &lt;=&gt;
         ?q. (q WATCH a) t0 /\ !t. q (t + t0) \/ ~b (t + t0)
   
   [<A NAME="BEFORE_IDEM-val"><B>BEFORE_IDEM</B></A>]  Theorem
      
      |- a BEFORE b = (a BEFORE b) BEFORE b
   
   [<A NAME="BEFORE_IMP-val"><B>BEFORE_IMP</B></A>]  Theorem
      
      |- (a BEFORE b) t0 &lt;=&gt;
         !q.
           (q WATCH b) t0 ==&gt;
           (?t. ~q (t + t0) /\ ~b (t + t0) /\ a (t + t0)) \/
           !t. ~b (t + t0)
   
   [<A NAME="BEFORE_INVARIANT-val"><B>BEFORE_INVARIANT</B></A>]  Theorem
      
      |- (a BEFORE b) t0 &lt;=&gt;
         ?J.
           J t0 /\ (!t. J (t + t0) /\ ~a (t + t0) ==&gt; J (SUC (t + t0))) /\
           !d. J (d + t0) ==&gt; ~b (d + t0)
   
   [<A NAME="BEFORE_LINORD-val"><B>BEFORE_LINORD</B></A>]  Theorem
      
      |- (a BEFORE b) t0 &lt;=&gt;
         !t1. t0 &lt;= t1 /\ UPTO (t0,t1,(\t. ~a t)) ==&gt; ~b t1
   
   [<A NAME="BEFORE_NEXT-val"><B>BEFORE_NEXT</B></A>]  Theorem
      
      |- !a b. NEXT (a BEFORE b) = NEXT a BEFORE NEXT b
   
   [<A NAME="BEFORE_REC-val"><B>BEFORE_REC</B></A>]  Theorem
      
      |- (a BEFORE b) t0 &lt;=&gt; ~b t0 /\ (a t0 \/ NEXT (a BEFORE b) t0)
   
   [<A NAME="BEFORE_SIGNAL-val"><B>BEFORE_SIGNAL</B></A>]  Theorem
      
      |- (a BEFORE b) t0 &lt;=&gt;
         !delta.
           (!t. t &lt; delta ==&gt; ~b (t + t0)) /\ b (delta + t0) ==&gt;
           ?t. t &lt; delta /\ a (t + t0)
   
   [<A NAME="BEFORE_SIMP-val"><B>BEFORE_SIMP</B></A>]  Theorem
      
      |- ((\t. F) BEFORE b = ALWAYS (\t. ~b t)) /\
         ((\t. T) BEFORE b = (\t. ~b t)) /\ (a BEFORE (\t. F) = (\t. T)) /\
         (a BEFORE (\t. T) = (\t. F)) /\ (a BEFORE a = ALWAYS (\t. ~a t))
   
   [<A NAME="DELTA_CASES-val"><B>DELTA_CASES</B></A>]  Theorem
      
      |- (?d. (!t. t &lt; d ==&gt; ~b (t + t0)) /\ b (d + t0)) \/ !d. ~b (d + t0)
   
   [<A NAME="EQUIV_NEXT-val"><B>EQUIV_NEXT</B></A>]  Theorem
      
      |- !Q P. NEXT (\t. P t &lt;=&gt; Q t) = (\t. NEXT P t &lt;=&gt; NEXT Q t)
   
   [<A NAME="EVENTUAL_AS_BEFORE-val"><B>EVENTUAL_AS_BEFORE</B></A>]  Theorem
      
      |- EVENTUAL b = (\t0. ~((\t. F) BEFORE b) t0)
   
   [<A NAME="EVENTUAL_AS_SBEFORE-val"><B>EVENTUAL_AS_SBEFORE</B></A>]  Theorem
      
      |- EVENTUAL b = b SBEFORE (\t. F)
   
   [<A NAME="EVENTUAL_AS_SUNTIL-val"><B>EVENTUAL_AS_SUNTIL</B></A>]  Theorem
      
      |- EVENTUAL a = (\t. T) SUNTIL a
   
   [<A NAME="EVENTUAL_AS_SWHEN-val"><B>EVENTUAL_AS_SWHEN</B></A>]  Theorem
      
      |- EVENTUAL a = (\t. T) SWHEN a
   
   [<A NAME="EVENTUAL_AS_UNTIL-val"><B>EVENTUAL_AS_UNTIL</B></A>]  Theorem
      
      |- EVENTUAL a = (\t. ~((\t. ~a t) UNTIL (\t. F)) t)
   
   [<A NAME="EVENTUAL_AS_WHEN-val"><B>EVENTUAL_AS_WHEN</B></A>]  Theorem
      
      |- EVENTUAL a = (\t. ~((\t. F) WHEN a) t)
   
   [<A NAME="EVENTUAL_FIX-val"><B>EVENTUAL_FIX</B></A>]  Theorem
      
      |- (y = (\t. a t \/ y (t + 1))) &lt;=&gt; (y = EVENTUAL a) \/ (y = (\t. T))
   
   [<A NAME="EVENTUAL_IDEM-val"><B>EVENTUAL_IDEM</B></A>]  Theorem
      
      |- EVENTUAL a = EVENTUAL (EVENTUAL a)
   
   [<A NAME="EVENTUAL_INVARIANT-val"><B>EVENTUAL_INVARIANT</B></A>]  Theorem
      
      |- EVENTUAL b t0 &lt;=&gt;
         ?J.
           0 &lt; J t0 /\
           (!t. J (SUC (t + t0)) &lt; J (t + t0) \/ (J (SUC (t + t0)) = 0)) /\
           !t. 0 &lt; J (t + t0) /\ (J (SUC (t + t0)) = 0) ==&gt; b (t + t0)
   
   [<A NAME="EVENTUAL_LINORD-val"><B>EVENTUAL_LINORD</B></A>]  Theorem
      
      |- EVENTUAL a t0 &lt;=&gt; ?t1. t0 &lt;= t1 /\ a t1
   
   [<A NAME="EVENTUAL_NEXT-val"><B>EVENTUAL_NEXT</B></A>]  Theorem
      
      |- !a. NEXT (EVENTUAL a) = EVENTUAL (NEXT a)
   
   [<A NAME="EVENTUAL_REC-val"><B>EVENTUAL_REC</B></A>]  Theorem
      
      |- EVENTUAL P t0 &lt;=&gt; P t0 \/ NEXT (EVENTUAL P) t0
   
   [<A NAME="EVENTUAL_SIGNAL-val"><B>EVENTUAL_SIGNAL</B></A>]  Theorem
      
      |- EVENTUAL a t0 &lt;=&gt; ?t. a (t + t0)
   
   [<A NAME="IMMEDIATE_EVENT-val"><B>IMMEDIATE_EVENT</B></A>]  Theorem
      
      |- b t0 ==&gt;
         (!a. (a WHEN b) t0 &lt;=&gt; a t0) /\ (!a. (a UNTIL b) t0 &lt;=&gt; T) /\
         (!a. (a BEFORE b) t0 &lt;=&gt; F) /\ (!a. (a SWHEN b) t0 &lt;=&gt; a t0) /\
         (!a. (a SUNTIL b) t0 &lt;=&gt; T) /\ !a. (a SBEFORE b) t0 &lt;=&gt; F
   
   [<A NAME="IMP_NEXT-val"><B>IMP_NEXT</B></A>]  Theorem
      
      |- !Q P. NEXT (\t. P t ==&gt; Q t) = (\t. NEXT P t ==&gt; NEXT Q t)
   
   [<A NAME="MORE_EVENT-val"><B>MORE_EVENT</B></A>]  Theorem
      
      |- (a WHEN b = (\t. a t /\ b t) WHEN b) /\
         (a UNTIL b = (\t. a t /\ ~b t) UNTIL b) /\
         (a BEFORE b = (\t. a t /\ ~b t) BEFORE b) /\
         (a SWHEN b = (\t. a t /\ b t) SWHEN b) /\
         (a SUNTIL b = (\t. a t /\ ~b t) SUNTIL b) /\
         (a SBEFORE b = (\t. a t /\ ~b t) SBEFORE b)
   
   [<A NAME="NEXT_LINORD-val"><B>NEXT_LINORD</B></A>]  Theorem
      
      |- NEXT a t0 &lt;=&gt; ?t1. t0 &lt; t1 /\ (!t3. t0 &lt; t3 ==&gt; t1 &lt;= t3) /\ a t1
   
   [<A NAME="NOT_ALWAYS-val"><B>NOT_ALWAYS</B></A>]  Theorem
      
      |- ~ALWAYS a t0 &lt;=&gt; EVENTUAL (\t. ~a t) t0
   
   [<A NAME="NOT_BEFORE-val"><B>NOT_BEFORE</B></A>]  Theorem
      
      |- ~(a BEFORE b) t0 &lt;=&gt; ((\t. ~a t) SUNTIL b) t0
   
   [<A NAME="NOT_EVENTUAL-val"><B>NOT_EVENTUAL</B></A>]  Theorem
      
      |- ~EVENTUAL a t0 &lt;=&gt; ALWAYS (\t. ~a t) t0
   
   [<A NAME="NOT_NEXT-val"><B>NOT_NEXT</B></A>]  Theorem
      
      |- !P. NEXT (\t. ~P t) = (\t. ~NEXT P t)
   
   [<A NAME="NOT_SBEFORE-val"><B>NOT_SBEFORE</B></A>]  Theorem
      
      |- ~(a SBEFORE b) t0 &lt;=&gt; ((\t. ~a t) UNTIL b) t0
   
   [<A NAME="NOT_SUNTIL-val"><B>NOT_SUNTIL</B></A>]  Theorem
      
      |- ~(a SUNTIL b) t0 &lt;=&gt; ((\t. ~a t) BEFORE b) t0
   
   [<A NAME="NOT_SWHEN-val"><B>NOT_SWHEN</B></A>]  Theorem
      
      |- ~(a SWHEN b) t0 &lt;=&gt; ((\t. ~a t) WHEN b) t0
   
   [<A NAME="NOT_UNTIL-val"><B>NOT_UNTIL</B></A>]  Theorem
      
      |- ~(a UNTIL b) t0 &lt;=&gt; ((\t. ~a t) SBEFORE b) t0
   
   [<A NAME="NOT_WHEN-val"><B>NOT_WHEN</B></A>]  Theorem
      
      |- ~(a WHEN b) t0 &lt;=&gt; ((\t. ~a t) SWHEN b) t0
   
   [<A NAME="NO_EVENT-val"><B>NO_EVENT</B></A>]  Theorem
      
      |- ALWAYS (\t. ~b t) t0 ==&gt;
         (!a. (a WHEN b) t0 &lt;=&gt; T) /\
         (!a. (a UNTIL b) t0 &lt;=&gt; ALWAYS a t0) /\
         (!a. (a BEFORE b) t0 &lt;=&gt; T) /\ (!a. (a SWHEN b) t0 &lt;=&gt; F) /\
         (!a. (a SUNTIL b) t0 &lt;=&gt; F) /\
         !a. (a SBEFORE b) t0 &lt;=&gt; EVENTUAL a t0
   
   [<A NAME="OR_NEXT-val"><B>OR_NEXT</B></A>]  Theorem
      
      |- !Q P. NEXT (\t. P t \/ Q t) = (\t. NEXT P t \/ NEXT Q t)
   
   [<A NAME="SBEFORE_AS_BEFORE-val"><B>SBEFORE_AS_BEFORE</B></A>]  Theorem
      
      |- a SBEFORE b = (\t0. (a BEFORE b) t0 /\ EVENTUAL a t0)
   
   [<A NAME="SBEFORE_AS_SUNTIL-val"><B>SBEFORE_AS_SUNTIL</B></A>]  Theorem
      
      |- a SBEFORE b = (\t0. ~((\t. ~a t) SUNTIL b) t0 /\ EVENTUAL a t0)
   
   [<A NAME="SBEFORE_AS_SWHEN-val"><B>SBEFORE_AS_SWHEN</B></A>]  Theorem
      
      |- a SBEFORE b = (\t. ~b t) SWHEN (\t. a t \/ b t)
   
   [<A NAME="SBEFORE_AS_UNTIL-val"><B>SBEFORE_AS_UNTIL</B></A>]  Theorem
      
      |- a SBEFORE b = (\t0. ~((\t. ~a t) UNTIL b) t0)
   
   [<A NAME="SBEFORE_AS_WHEN-val"><B>SBEFORE_AS_WHEN</B></A>]  Theorem
      
      |- a SBEFORE b =
         (\t0. ((\t. ~b t) WHEN (\t. a t \/ b t)) t0 /\ EVENTUAL a t0)
   
   [<A NAME="SBEFORE_EVENT-val"><B>SBEFORE_EVENT</B></A>]  Theorem
      
      |- a SBEFORE b = (\t. a t /\ ~b t) SBEFORE b
   
   [<A NAME="SBEFORE_IDEM-val"><B>SBEFORE_IDEM</B></A>]  Theorem
      
      |- a SBEFORE b = (a SBEFORE b) SBEFORE b
   
   [<A NAME="SBEFORE_IMP-val"><B>SBEFORE_IMP</B></A>]  Theorem
      
      |- (a SBEFORE b) t0 &lt;=&gt;
         !q.
           (q WATCH b) t0 ==&gt; ?t. ~q (t + t0) /\ ~b (t + t0) /\ a (t + t0)
   
   [<A NAME="SBEFORE_INVARIANT-val"><B>SBEFORE_INVARIANT</B></A>]  Theorem
      
      |- (a SBEFORE b) t0 &lt;=&gt;
         (?J1.
            J1 t0 /\
            (!t. J1 (t + t0) /\ ~a (t + t0) ==&gt; J1 (SUC (t + t0))) /\
            !d. J1 (d + t0) ==&gt; ~b (d + t0)) /\
         ?J2.
           0 &lt; J2 t0 /\
           (!t.
              J2 (SUC (t + t0)) &lt; J2 (t + t0) \/
              (J2 (SUC (t + t0)) = 0)) /\
           !t. 0 &lt; J2 (t + t0) /\ (J2 (SUC (t + t0)) = 0) ==&gt; a (t + t0)
   
   [<A NAME="SBEFORE_LINORD-val"><B>SBEFORE_LINORD</B></A>]  Theorem
      
      |- (a SBEFORE b) t0 &lt;=&gt;
         ?t1. t0 &lt;= t1 /\ a t1 /\ ~b t1 /\ UPTO (t0,t1,(\t. ~b t))
   
   [<A NAME="SBEFORE_NEXT-val"><B>SBEFORE_NEXT</B></A>]  Theorem
      
      |- !a b. NEXT (a SBEFORE b) = NEXT a SBEFORE NEXT b
   
   [<A NAME="SBEFORE_REC-val"><B>SBEFORE_REC</B></A>]  Theorem
      
      |- (a SBEFORE b) t0 &lt;=&gt; ~b t0 /\ (a t0 \/ NEXT (a SBEFORE b) t0)
   
   [<A NAME="SBEFORE_SIGNAL-val"><B>SBEFORE_SIGNAL</B></A>]  Theorem
      
      |- (a SBEFORE b) t0 &lt;=&gt;
         ?delta. a (delta + t0) /\ !t. t &lt;= delta ==&gt; ~b (t + t0)
   
   [<A NAME="SBEFORE_SIMP-val"><B>SBEFORE_SIMP</B></A>]  Theorem
      
      |- ((\t. F) SBEFORE b = (\t. F)) /\
         ((\t. T) SBEFORE b = (\t. ~b t)) /\
         (a SBEFORE (\t. F) = EVENTUAL a) /\
         (a SBEFORE (\t. T) = (\t. F)) /\ (a SBEFORE a = (\t. F))
   
   [<A NAME="SOME_EVENT-val"><B>SOME_EVENT</B></A>]  Theorem
      
      |- (EVENTUAL b t0 &lt;=&gt; !a. (a WHEN b) t0 &lt;=&gt; (a SWHEN b) t0) /\
         (EVENTUAL b t0 &lt;=&gt; !a. (a UNTIL b) t0 &lt;=&gt; (a SUNTIL b) t0) /\
         (EVENTUAL b t0 &lt;=&gt; !a. (a BEFORE b) t0 &lt;=&gt; (a SBEFORE b) t0)
   
   [<A NAME="SUNTIL_AS_BEFORE-val"><B>SUNTIL_AS_BEFORE</B></A>]  Theorem
      
      |- a SUNTIL b = (\t0. ~((\t. ~a t) BEFORE b) t0)
   
   [<A NAME="SUNTIL_AS_SBEFORE-val"><B>SUNTIL_AS_SBEFORE</B></A>]  Theorem
      
      |- a SUNTIL b = (\t0. ~((\t. ~a t) SBEFORE b) t0 /\ EVENTUAL b t0)
   
   [<A NAME="SUNTIL_AS_SWHEN-val"><B>SUNTIL_AS_SWHEN</B></A>]  Theorem
      
      |- a SUNTIL b = b SWHEN (\t. a t ==&gt; b t)
   
   [<A NAME="SUNTIL_AS_UNTIL-val"><B>SUNTIL_AS_UNTIL</B></A>]  Theorem
      
      |- a SUNTIL b = (\t0. (a UNTIL b) t0 /\ EVENTUAL b t0)
   
   [<A NAME="SUNTIL_AS_WHEN-val"><B>SUNTIL_AS_WHEN</B></A>]  Theorem
      
      |- a SUNTIL b = (\t. (b WHEN (\t. a t ==&gt; b t)) t /\ EVENTUAL b t)
   
   [<A NAME="SUNTIL_EVENT-val"><B>SUNTIL_EVENT</B></A>]  Theorem
      
      |- a SUNTIL b = (\t. a t /\ ~b t) SUNTIL b
   
   [<A NAME="SUNTIL_IDEM-val"><B>SUNTIL_IDEM</B></A>]  Theorem
      
      |- a SUNTIL b = (a SUNTIL b) SUNTIL b
   
   [<A NAME="SUNTIL_IMP-val"><B>SUNTIL_IMP</B></A>]  Theorem
      
      |- (a SUNTIL b) t0 &lt;=&gt;
         !q.
           (q WATCH b) t0 ==&gt;
           (!t. q (t + t0) \/ b (t + t0) \/ a (t + t0)) /\ ?t. b (t + t0)
   
   [<A NAME="SUNTIL_INVARIANT-val"><B>SUNTIL_INVARIANT</B></A>]  Theorem
      
      |- (a SUNTIL b) t0 &lt;=&gt;
         (?J1.
            J1 t0 /\
            !t.
              J1 (t + t0) /\ ~b (t + t0) ==&gt;
              a (t + t0) /\ J1 (SUC (t + t0))) /\
         ?J2.
           0 &lt; J2 t0 /\
           (!t.
              J2 (SUC (t + t0)) &lt; J2 (t + t0) \/
              (J2 (SUC (t + t0)) = 0)) /\
           !t. 0 &lt; J2 (t + t0) /\ (J2 (SUC (t + t0)) = 0) ==&gt; b (t + t0)
   
   [<A NAME="SUNTIL_LINORD-val"><B>SUNTIL_LINORD</B></A>]  Theorem
      
      |- (a SUNTIL b) t0 &lt;=&gt; ?t1. t0 &lt;= t1 /\ b t1 /\ UPTO (t0,t1,a)
   
   [<A NAME="SUNTIL_NEXT-val"><B>SUNTIL_NEXT</B></A>]  Theorem
      
      |- !a b. NEXT (a SUNTIL b) = NEXT a SUNTIL NEXT b
   
   [<A NAME="SUNTIL_REC-val"><B>SUNTIL_REC</B></A>]  Theorem
      
      |- (a SUNTIL b) t0 &lt;=&gt; ~b t0 ==&gt; a t0 /\ NEXT (a SUNTIL b) t0
   
   [<A NAME="SUNTIL_SIGNAL-val"><B>SUNTIL_SIGNAL</B></A>]  Theorem
      
      |- (a SUNTIL b) t0 &lt;=&gt;
         ?delta.
           (!t. t &lt; delta ==&gt; a (t + t0) /\ ~b (t + t0)) /\ b (delta + t0)
   
   [<A NAME="SUNTIL_SIMP-val"><B>SUNTIL_SIMP</B></A>]  Theorem
      
      |- ((\t. F) SUNTIL b = (\t. b t)) /\
         ((\t. T) SUNTIL b = EVENTUAL b) /\ (a SUNTIL (\t. F) = (\t. F)) /\
         (a SUNTIL (\t. T) = (\t. T)) /\ (a SUNTIL a = (\t. a t))
   
   [<A NAME="SWHEN_AS_BEFORE-val"><B>SWHEN_AS_BEFORE</B></A>]  Theorem
      
      |- a SWHEN b = (\t0. ~(b BEFORE (\t. a t /\ b t)) t0)
   
   [<A NAME="SWHEN_AS_NOT_WHEN-val"><B>SWHEN_AS_NOT_WHEN</B></A>]  Theorem
      
      |- (a SWHEN b) t0 &lt;=&gt; ~((\t. ~a t) WHEN b) t0
   
   [<A NAME="SWHEN_AS_SBEFORE-val"><B>SWHEN_AS_SBEFORE</B></A>]  Theorem
      
      |- a SWHEN b = b SBEFORE (\t. ~a t /\ b t)
   
   [<A NAME="SWHEN_AS_SUNTIL-val"><B>SWHEN_AS_SUNTIL</B></A>]  Theorem
      
      |- a SWHEN b = (\t. ~b t) SUNTIL (\t. a t /\ b t)
   
   [<A NAME="SWHEN_AS_UNTIL-val"><B>SWHEN_AS_UNTIL</B></A>]  Theorem
      
      |- a SWHEN b =
         (\t. ((\t. ~b t) UNTIL (\t. a t /\ b t)) t /\ EVENTUAL b t)
   
   [<A NAME="SWHEN_AS_WHEN-val"><B>SWHEN_AS_WHEN</B></A>]  Theorem
      
      |- a SWHEN b = (\t0. (a WHEN b) t0 /\ EVENTUAL b t0)
   
   [<A NAME="SWHEN_EVENT-val"><B>SWHEN_EVENT</B></A>]  Theorem
      
      |- a SWHEN b = (\t. a t /\ b t) SWHEN b
   
   [<A NAME="SWHEN_IDEM-val"><B>SWHEN_IDEM</B></A>]  Theorem
      
      |- a SWHEN b = (a SWHEN b) SWHEN b
   
   [<A NAME="SWHEN_IMP-val"><B>SWHEN_IMP</B></A>]  Theorem
      
      |- (a SWHEN b) t0 &lt;=&gt;
         !q. (q WATCH b) t0 ==&gt; ?t. ~q (t + t0) /\ b (t + t0) /\ a (t + t0)
   
   [<A NAME="SWHEN_INVARIANT-val"><B>SWHEN_INVARIANT</B></A>]  Theorem
      
      |- (a SWHEN b) t0 &lt;=&gt;
         (?J1.
            J1 t0 /\
            (!t. ~b (t + t0) /\ J1 (t + t0) ==&gt; J1 (SUC (t + t0))) /\
            !d. b (d + t0) /\ J1 (d + t0) ==&gt; a (d + t0)) /\
         ?J2.
           0 &lt; J2 t0 /\
           (!t.
              J2 (SUC (t + t0)) &lt; J2 (t + t0) \/
              (J2 (SUC (t + t0)) = 0)) /\
           !t. 0 &lt; J2 (t + t0) /\ (J2 (SUC (t + t0)) = 0) ==&gt; b (t + t0)
   
   [<A NAME="SWHEN_LINORD-val"><B>SWHEN_LINORD</B></A>]  Theorem
      
      |- (a SWHEN b) t0 &lt;=&gt;
         ?t1. t0 &lt;= t1 /\ a t1 /\ b t1 /\ UPTO (t0,t1,(\t. ~b t))
   
   [<A NAME="SWHEN_NEXT-val"><B>SWHEN_NEXT</B></A>]  Theorem
      
      |- !a b. NEXT (a SWHEN b) = NEXT a SWHEN NEXT b
   
   [<A NAME="SWHEN_REC-val"><B>SWHEN_REC</B></A>]  Theorem
      
      |- (a SWHEN b) t0 &lt;=&gt; if b t0 then a t0 else NEXT (a SWHEN b) t0
   
   [<A NAME="SWHEN_SIGNAL-val"><B>SWHEN_SIGNAL</B></A>]  Theorem
      
      |- (a SWHEN b) t0 &lt;=&gt;
         ?delta.
           (!t. t &lt; delta ==&gt; ~b (t + t0)) /\ b (delta + t0) /\
           a (delta + t0)
   
   [<A NAME="SWHEN_SIMP-val"><B>SWHEN_SIMP</B></A>]  Theorem
      
      |- ((\t. F) SWHEN b = (\t. F)) /\ ((\t. T) SWHEN b = EVENTUAL b) /\
         (a SWHEN (\t. F) = (\t. F)) /\ (a SWHEN (\t. T) = (\t. a t)) /\
         (a SWHEN a = EVENTUAL a)
   
   [<A NAME="UNTIL_AS_BEFORE-val"><B>UNTIL_AS_BEFORE</B></A>]  Theorem
      
      |- a UNTIL b = (\t0. ~((\t. ~a t) BEFORE b) t0 \/ ALWAYS a t0)
   
   [<A NAME="UNTIL_AS_SBEFORE-val"><B>UNTIL_AS_SBEFORE</B></A>]  Theorem
      
      |- a UNTIL b = (\t0. ~((\t. ~a t) SBEFORE b) t0)
   
   [<A NAME="UNTIL_AS_SUNTIL-val"><B>UNTIL_AS_SUNTIL</B></A>]  Theorem
      
      |- a UNTIL b = (\t. (a SUNTIL b) t \/ ALWAYS a t)
   
   [<A NAME="UNTIL_AS_SWHEN-val"><B>UNTIL_AS_SWHEN</B></A>]  Theorem
      
      |- a UNTIL b = (\t. (b SWHEN (\t. a t ==&gt; b t)) t \/ ALWAYS a t)
   
   [<A NAME="UNTIL_AS_WHEN-val"><B>UNTIL_AS_WHEN</B></A>]  Theorem
      
      |- a UNTIL b = b WHEN (\t. a t ==&gt; b t)
   
   [<A NAME="UNTIL_EVENT-val"><B>UNTIL_EVENT</B></A>]  Theorem
      
      |- a UNTIL b = (\t. a t /\ ~b t) UNTIL b
   
   [<A NAME="UNTIL_FIX-val"><B>UNTIL_FIX</B></A>]  Theorem
      
      |- (y = (\t. ~b t ==&gt; a t /\ y (t + 1))) &lt;=&gt;
         (y = a UNTIL b) \/ (y = a SUNTIL b)
   
   [<A NAME="UNTIL_IDEM-val"><B>UNTIL_IDEM</B></A>]  Theorem
      
      |- a UNTIL b = (a UNTIL b) UNTIL b
   
   [<A NAME="UNTIL_IMP-val"><B>UNTIL_IMP</B></A>]  Theorem
      
      |- (a UNTIL b) t0 &lt;=&gt;
         !q. (q WATCH b) t0 ==&gt; !t. q (t + t0) \/ b (t + t0) \/ a (t + t0)
   
   [<A NAME="UNTIL_INVARIANT-val"><B>UNTIL_INVARIANT</B></A>]  Theorem
      
      |- !t0.
           (a UNTIL b) t0 &lt;=&gt;
           ?J.
             J t0 /\
             !t.
               J (t + t0) /\ ~b (t + t0) ==&gt; a (t + t0) /\ J (SUC (t + t0))
   
   [<A NAME="UNTIL_LINORD-val"><B>UNTIL_LINORD</B></A>]  Theorem
      
      |- (a UNTIL b) t0 &lt;=&gt;
         !t1. t0 &lt;= t1 /\ ~b t1 /\ UPTO (t0,t1,(\t. ~b t)) ==&gt; a t1
   
   [<A NAME="UNTIL_NEXT-val"><B>UNTIL_NEXT</B></A>]  Theorem
      
      |- !a b. NEXT (a UNTIL b) = NEXT a UNTIL NEXT b
   
   [<A NAME="UNTIL_REC-val"><B>UNTIL_REC</B></A>]  Theorem
      
      |- (a UNTIL b) t0 &lt;=&gt; ~b t0 ==&gt; a t0 /\ NEXT (a UNTIL b) t0
   
   [<A NAME="UNTIL_SIGNAL-val"><B>UNTIL_SIGNAL</B></A>]  Theorem
      
      |- (a UNTIL b) t0 &lt;=&gt;
         ((!t. ~b (t + t0)) ==&gt; !t. a (t + t0)) /\
         !d.
           (!t. t &lt; d ==&gt; ~b (t + t0)) /\ b (d + t0) ==&gt;
           !t. t &lt; d ==&gt; a (t + t0)
   
   [<A NAME="UNTIL_SIMP-val"><B>UNTIL_SIMP</B></A>]  Theorem
      
      |- ((\t. F) UNTIL b = (\t. b t)) /\ ((\t. T) UNTIL b = (\t. T)) /\
         (a UNTIL (\t. F) = ALWAYS a) /\ (a UNTIL (\t. T) = (\t. T)) /\
         (a UNTIL a = (\t. a t))
   
   [<A NAME="WATCH_EXISTS-val"><B>WATCH_EXISTS</B></A>]  Theorem
      
      |- !b t0. ?q. (q WATCH b) t0
   
   [<A NAME="WATCH_REC-val"><B>WATCH_REC</B></A>]  Theorem
      
      |- (q WATCH b) t0 &lt;=&gt;
         ~q t0 /\ if b t0 then NEXT (ALWAYS q) t0 else NEXT (q WATCH b) t0
   
   [<A NAME="WATCH_SIGNAL-val"><B>WATCH_SIGNAL</B></A>]  Theorem
      
      |- (q WATCH b) t0 &lt;=&gt;
         ((!t. ~b (t + t0)) ==&gt; !t. ~q (t + t0)) /\
         !d.
           b (d + t0) /\ (!t. t &lt; d ==&gt; ~b (t + t0)) ==&gt;
           (!t. t &lt;= d ==&gt; ~q (t + t0)) /\ !t. q (SUC (t + (d + t0)))
   
   [<A NAME="WELL_ORDER-val"><B>WELL_ORDER</B></A>]  Theorem
      
      |- (?n. P n) &lt;=&gt; ?m. P m /\ !n. n &lt; m ==&gt; ~P n
   
   [<A NAME="WELL_ORDER_UNIQUE-val"><B>WELL_ORDER_UNIQUE</B></A>]  Theorem
      
      |- !m2 m1 P.
           (P m1 /\ !n. n &lt; m1 ==&gt; ~P n) /\ P m2 /\
           (!n. n &lt; m2 ==&gt; ~P n) ==&gt;
           (m1 = m2)
   
   [<A NAME="WHEN_AS_BEFORE-val"><B>WHEN_AS_BEFORE</B></A>]  Theorem
      
      |- a WHEN b =
         (\t0. ~(b BEFORE (\t. a t /\ b t)) t0 \/ ALWAYS (\t. ~b t) t0)
   
   [<A NAME="WHEN_AS_NOT_SWHEN-val"><B>WHEN_AS_NOT_SWHEN</B></A>]  Theorem
      
      |- (a WHEN b) t0 &lt;=&gt; ~((\t. ~a t) SWHEN b) t0
   
   [<A NAME="WHEN_AS_SBEFORE-val"><B>WHEN_AS_SBEFORE</B></A>]  Theorem
      
      |- a WHEN b =
         (\t0. (b SBEFORE (\t. ~a t /\ b t)) t0 \/ ALWAYS (\t. ~b t) t0)
   
   [<A NAME="WHEN_AS_SUNTIL-val"><B>WHEN_AS_SUNTIL</B></A>]  Theorem
      
      |- a WHEN b =
         (\t.
            ((\t. ~b t) SUNTIL (\t. a t /\ b t)) t \/ ALWAYS (\t. ~b t) t)
   
   [<A NAME="WHEN_AS_SWHEN-val"><B>WHEN_AS_SWHEN</B></A>]  Theorem
      
      |- a WHEN b = (\t. (a SWHEN b) t \/ ALWAYS (\t. ~b t) t)
   
   [<A NAME="WHEN_AS_UNTIL-val"><B>WHEN_AS_UNTIL</B></A>]  Theorem
      
      |- a WHEN b = (\t. ~b t) UNTIL (\t. a t /\ b t)
   
   [<A NAME="WHEN_EVENT-val"><B>WHEN_EVENT</B></A>]  Theorem
      
      |- a WHEN b = (\t. a t /\ b t) WHEN b
   
   [<A NAME="WHEN_FIX-val"><B>WHEN_FIX</B></A>]  Theorem
      
      |- (y = (\t. if b t then a t else y (t + 1))) &lt;=&gt;
         (y = a WHEN b) \/ (y = a SWHEN b)
   
   [<A NAME="WHEN_IDEM-val"><B>WHEN_IDEM</B></A>]  Theorem
      
      |- a WHEN b = (a WHEN b) WHEN b
   
   [<A NAME="WHEN_IMP-val"><B>WHEN_IMP</B></A>]  Theorem
      
      |- (a WHEN b) t0 &lt;=&gt;
         !q.
           (q WATCH b) t0 ==&gt; !t. q (t + t0) \/ (b (t + t0) ==&gt; a (t + t0))
   
   [<A NAME="WHEN_INVARIANT-val"><B>WHEN_INVARIANT</B></A>]  Theorem
      
      |- (a WHEN b) t0 &lt;=&gt;
         ?J.
           J t0 /\ (!t. ~b (t + t0) /\ J (t + t0) ==&gt; J (SUC (t + t0))) /\
           !d. b (d + t0) /\ J (d + t0) ==&gt; a (d + t0)
   
   [<A NAME="WHEN_LINORD-val"><B>WHEN_LINORD</B></A>]  Theorem
      
      |- (a WHEN b) t0 &lt;=&gt;
         !t1. t0 &lt;= t1 /\ b t1 /\ UPTO (t0,t1,(\t. ~b t)) ==&gt; a t1
   
   [<A NAME="WHEN_NEXT-val"><B>WHEN_NEXT</B></A>]  Theorem
      
      |- !a b. NEXT (a WHEN b) = NEXT a WHEN NEXT b
   
   [<A NAME="WHEN_REC-val"><B>WHEN_REC</B></A>]  Theorem
      
      |- (a WHEN b) t0 &lt;=&gt; if b t0 then a t0 else NEXT (a WHEN b) t0
   
   [<A NAME="WHEN_SIGNAL-val"><B>WHEN_SIGNAL</B></A>]  Theorem
      
      |- (a WHEN b) t0 &lt;=&gt;
         !delta.
           (!t. t &lt; delta ==&gt; ~b (t + t0)) /\ b (delta + t0) ==&gt;
           a (delta + t0)
   
   [<A NAME="WHEN_SIMP-val"><B>WHEN_SIMP</B></A>]  Theorem
      
      |- ((\t. F) WHEN b = ALWAYS (\t. ~b t)) /\
         ((\t. T) WHEN b = (\t. T)) /\ (a WHEN (\t. F) = (\t. T)) /\
         (a WHEN (\t. T) = (\t. a t)) /\ (a WHEN a = (\t. T))
   
   [<A NAME="WHEN_SWHEN_LEMMA-val"><B>WHEN_SWHEN_LEMMA</B></A>]  Theorem
      
      |- if !t1. ?t2. b (t2 + t1) then
           !t0. (a WHEN b) t0 &lt;=&gt; (a SWHEN b) t0
         else
           ?t1. !t2. (a WHEN b) (t2 + t1) /\ ~(a SWHEN b) (t2 + t1)
   
   
*)
end

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/temporal/src/Temporal_LogicScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
