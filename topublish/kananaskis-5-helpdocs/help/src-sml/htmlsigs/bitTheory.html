<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure bitTheory</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure bitTheory</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/n-bit/bitScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>signature bitTheory =
<A NAME="line2"></A>sig
<A NAME="line3"></A>  type thm = Thm.thm
<A NAME="line4"></A>  
<A NAME="line5"></A>  (*  Definitions  *)
<A NAME="line6"></A>    val <A HREF="#BITS_def-val">BITS_def</A> : thm
<A NAME="line7"></A>    val <A HREF="#BITV_def-val">BITV_def</A> : thm
<A NAME="line8"></A>    val <A HREF="#BITWISE_def-val">BITWISE_def</A> : thm
<A NAME="line9"></A>    val <A HREF="#BIT_MODIFY_def-val">BIT_MODIFY_def</A> : thm
<A NAME="line10"></A>    val <A HREF="#BIT_REVERSE_def-val">BIT_REVERSE_def</A> : thm
<A NAME="line11"></A>    val <A HREF="#BIT_def-val">BIT_def</A> : thm
<A NAME="line12"></A>    val <A HREF="#DIVMOD_2EXP_def-val">DIVMOD_2EXP_def</A> : thm
<A NAME="line13"></A>    val <A HREF="#HEX_primitive_def-val">HEX_primitive_def</A> : thm
<A NAME="line14"></A>    val <A HREF="#LOG2_def-val">LOG2_def</A> : thm
<A NAME="line15"></A>    val <A HREF="#LOWEST_SET_BIT_def-val">LOWEST_SET_BIT_def</A> : thm
<A NAME="line16"></A>    val <A HREF="#LSB_def-val">LSB_def</A> : thm
<A NAME="line17"></A>    val <A HREF="#MOD_2EXP_EQ_def-val">MOD_2EXP_EQ_def</A> : thm
<A NAME="line18"></A>    val <A HREF="#MOD_2EXP_MAX_def-val">MOD_2EXP_MAX_def</A> : thm
<A NAME="line19"></A>    val <A HREF="#SBIT_def-val">SBIT_def</A> : thm
<A NAME="line20"></A>    val <A HREF="#SIGN_EXTEND_def-val">SIGN_EXTEND_def</A> : thm
<A NAME="line21"></A>    val <A HREF="#SLICE_def-val">SLICE_def</A> : thm
<A NAME="line22"></A>    val <A HREF="#TIMES_2EXP_def-val">TIMES_2EXP_def</A> : thm
<A NAME="line23"></A>    val <A HREF="#UNHEX_primitive_def-val">UNHEX_primitive_def</A> : thm
<A NAME="line24"></A>    val <A HREF="#l2n_def-val">l2n_def</A> : thm
<A NAME="line25"></A>    val <A HREF="#n2l_curried_def-val">n2l_curried_def</A> : thm
<A NAME="line26"></A>    val <A HREF="#n2l_tupled_primitive_def-val">n2l_tupled_primitive_def</A> : thm
<A NAME="line27"></A>    val <A HREF="#n2s_def-val">n2s_def</A> : thm
<A NAME="line28"></A>    val <A HREF="#num_from_bin_list_def-val">num_from_bin_list_def</A> : thm
<A NAME="line29"></A>    val <A HREF="#num_from_bin_string_def-val">num_from_bin_string_def</A> : thm
<A NAME="line30"></A>    val <A HREF="#num_from_dec_list_def-val">num_from_dec_list_def</A> : thm
<A NAME="line31"></A>    val <A HREF="#num_from_dec_string_def-val">num_from_dec_string_def</A> : thm
<A NAME="line32"></A>    val <A HREF="#num_from_hex_list_def-val">num_from_hex_list_def</A> : thm
<A NAME="line33"></A>    val <A HREF="#num_from_hex_string_def-val">num_from_hex_string_def</A> : thm
<A NAME="line34"></A>    val <A HREF="#num_from_oct_list_def-val">num_from_oct_list_def</A> : thm
<A NAME="line35"></A>    val <A HREF="#num_from_oct_string_def-val">num_from_oct_string_def</A> : thm
<A NAME="line36"></A>    val <A HREF="#num_to_bin_list_def-val">num_to_bin_list_def</A> : thm
<A NAME="line37"></A>    val <A HREF="#num_to_bin_string_def-val">num_to_bin_string_def</A> : thm
<A NAME="line38"></A>    val <A HREF="#num_to_dec_list_def-val">num_to_dec_list_def</A> : thm
<A NAME="line39"></A>    val <A HREF="#num_to_dec_string_def-val">num_to_dec_string_def</A> : thm
<A NAME="line40"></A>    val <A HREF="#num_to_hex_list_def-val">num_to_hex_list_def</A> : thm
<A NAME="line41"></A>    val <A HREF="#num_to_hex_string_def-val">num_to_hex_string_def</A> : thm
<A NAME="line42"></A>    val <A HREF="#num_to_oct_list_def-val">num_to_oct_list_def</A> : thm
<A NAME="line43"></A>    val <A HREF="#num_to_oct_string_def-val">num_to_oct_string_def</A> : thm
<A NAME="line44"></A>    val <A HREF="#s2n_def-val">s2n_def</A> : thm
<A NAME="line45"></A>  
<A NAME="line46"></A>  (*  Theorems  *)
<A NAME="line47"></A>    val <A HREF="#ADD_BIT0-val">ADD_BIT0</A> : thm
<A NAME="line48"></A>    val <A HREF="#ADD_BITS_SUC-val">ADD_BITS_SUC</A> : thm
<A NAME="line49"></A>    val <A HREF="#ADD_BIT_SUC-val">ADD_BIT_SUC</A> : thm
<A NAME="line50"></A>    val <A HREF="#BITSLT_THM-val">BITSLT_THM</A> : thm
<A NAME="line51"></A>    val <A HREF="#BITS_COMP_THM-val">BITS_COMP_THM</A> : thm
<A NAME="line52"></A>    val <A HREF="#BITS_COMP_THM2-val">BITS_COMP_THM2</A> : thm
<A NAME="line53"></A>    val <A HREF="#BITS_DIV_THM-val">BITS_DIV_THM</A> : thm
<A NAME="line54"></A>    val <A HREF="#BITS_LT_HIGH-val">BITS_LT_HIGH</A> : thm
<A NAME="line55"></A>    val <A HREF="#BITS_LT_LOW-val">BITS_LT_LOW</A> : thm
<A NAME="line56"></A>    val <A HREF="#BITS_SLICE_THM-val">BITS_SLICE_THM</A> : thm
<A NAME="line57"></A>    val <A HREF="#BITS_SLICE_THM2-val">BITS_SLICE_THM2</A> : thm
<A NAME="line58"></A>    val <A HREF="#BITS_SUC-val">BITS_SUC</A> : thm
<A NAME="line59"></A>    val <A HREF="#BITS_SUC_THM-val">BITS_SUC_THM</A> : thm
<A NAME="line60"></A>    val <A HREF="#BITS_SUM-val">BITS_SUM</A> : thm
<A NAME="line61"></A>    val <A HREF="#BITS_SUM2-val">BITS_SUM2</A> : thm
<A NAME="line62"></A>    val <A HREF="#BITS_SUM3-val">BITS_SUM3</A> : thm
<A NAME="line63"></A>    val <A HREF="#BITS_THM-val">BITS_THM</A> : thm
<A NAME="line64"></A>    val <A HREF="#BITS_THM2-val">BITS_THM2</A> : thm
<A NAME="line65"></A>    val <A HREF="#BITS_ZERO-val">BITS_ZERO</A> : thm
<A NAME="line66"></A>    val <A HREF="#BITS_ZERO2-val">BITS_ZERO2</A> : thm
<A NAME="line67"></A>    val <A HREF="#BITS_ZERO3-val">BITS_ZERO3</A> : thm
<A NAME="line68"></A>    val <A HREF="#BITS_ZERO4-val">BITS_ZERO4</A> : thm
<A NAME="line69"></A>    val <A HREF="#BITS_ZEROL-val">BITS_ZEROL</A> : thm
<A NAME="line70"></A>    val <A HREF="#BITV_THM-val">BITV_THM</A> : thm
<A NAME="line71"></A>    val <A HREF="#BITWISE_BITS-val">BITWISE_BITS</A> : thm
<A NAME="line72"></A>    val <A HREF="#BITWISE_COR-val">BITWISE_COR</A> : thm
<A NAME="line73"></A>    val <A HREF="#BITWISE_EVAL-val">BITWISE_EVAL</A> : thm
<A NAME="line74"></A>    val <A HREF="#BITWISE_LT_2EXP-val">BITWISE_LT_2EXP</A> : thm
<A NAME="line75"></A>    val <A HREF="#BITWISE_NOT_COR-val">BITWISE_NOT_COR</A> : thm
<A NAME="line76"></A>    val <A HREF="#BITWISE_ONE_COMP_LEM-val">BITWISE_ONE_COMP_LEM</A> : thm
<A NAME="line77"></A>    val <A HREF="#BITWISE_THM-val">BITWISE_THM</A> : thm
<A NAME="line78"></A>    val <A HREF="#BIT_B-val">BIT_B</A> : thm
<A NAME="line79"></A>    val <A HREF="#BIT_BITS_THM-val">BIT_BITS_THM</A> : thm
<A NAME="line80"></A>    val <A HREF="#BIT_B_NEQ-val">BIT_B_NEQ</A> : thm
<A NAME="line81"></A>    val <A HREF="#BIT_COMP_THM3-val">BIT_COMP_THM3</A> : thm
<A NAME="line82"></A>    val <A HREF="#BIT_DIV2-val">BIT_DIV2</A> : thm
<A NAME="line83"></A>    val <A HREF="#BIT_EXP_SUB1-val">BIT_EXP_SUB1</A> : thm
<A NAME="line84"></A>    val <A HREF="#BIT_LOG2-val">BIT_LOG2</A> : thm
<A NAME="line85"></A>    val <A HREF="#BIT_MODIFY_THM-val">BIT_MODIFY_THM</A> : thm
<A NAME="line86"></A>    val <A HREF="#BIT_OF_BITS_THM-val">BIT_OF_BITS_THM</A> : thm
<A NAME="line87"></A>    val <A HREF="#BIT_OF_BITS_THM2-val">BIT_OF_BITS_THM2</A> : thm
<A NAME="line88"></A>    val <A HREF="#BIT_REVERSE_THM-val">BIT_REVERSE_THM</A> : thm
<A NAME="line89"></A>    val <A HREF="#BIT_SHIFT_THM-val">BIT_SHIFT_THM</A> : thm
<A NAME="line90"></A>    val <A HREF="#BIT_SHIFT_THM2-val">BIT_SHIFT_THM2</A> : thm
<A NAME="line91"></A>    val <A HREF="#BIT_SHIFT_THM3-val">BIT_SHIFT_THM3</A> : thm
<A NAME="line92"></A>    val <A HREF="#BIT_SIGN_EXTEND-val">BIT_SIGN_EXTEND</A> : thm
<A NAME="line93"></A>    val <A HREF="#BIT_SLICE-val">BIT_SLICE</A> : thm
<A NAME="line94"></A>    val <A HREF="#BIT_SLICE_LEM-val">BIT_SLICE_LEM</A> : thm
<A NAME="line95"></A>    val <A HREF="#BIT_SLICE_THM-val">BIT_SLICE_THM</A> : thm
<A NAME="line96"></A>    val <A HREF="#BIT_SLICE_THM2-val">BIT_SLICE_THM2</A> : thm
<A NAME="line97"></A>    val <A HREF="#BIT_SLICE_THM3-val">BIT_SLICE_THM3</A> : thm
<A NAME="line98"></A>    val <A HREF="#BIT_SLICE_THM4-val">BIT_SLICE_THM4</A> : thm
<A NAME="line99"></A>    val <A HREF="#BIT_ZERO-val">BIT_ZERO</A> : thm
<A NAME="line100"></A>    val <A HREF="#BIT_num_from_bin_list-val">BIT_num_from_bin_list</A> : thm
<A NAME="line101"></A>    val <A HREF="#BIT_num_from_bin_string-val">BIT_num_from_bin_string</A> : thm
<A NAME="line102"></A>    val <A HREF="#DEC_UNDEC-val">DEC_UNDEC</A> : thm
<A NAME="line103"></A>    val <A HREF="#DIVMOD_2EXP-val">DIVMOD_2EXP</A> : thm
<A NAME="line104"></A>    val <A HREF="#DIV_0_IMP_LT-val">DIV_0_IMP_LT</A> : thm
<A NAME="line105"></A>    val <A HREF="#DIV_MULT_1-val">DIV_MULT_1</A> : thm
<A NAME="line106"></A>    val <A HREF="#DIV_MULT_THM-val">DIV_MULT_THM</A> : thm
<A NAME="line107"></A>    val <A HREF="#DIV_MULT_THM2-val">DIV_MULT_THM2</A> : thm
<A NAME="line108"></A>    val <A HREF="#EL_TAKE-val">EL_TAKE</A> : thm
<A NAME="line109"></A>    val <A HREF="#EL_n2l-val">EL_n2l</A> : thm
<A NAME="line110"></A>    val <A HREF="#EL_num_to_bin_list-val">EL_num_to_bin_list</A> : thm
<A NAME="line111"></A>    val <A HREF="#EXP_SUB_LESS_EQ-val">EXP_SUB_LESS_EQ</A> : thm
<A NAME="line112"></A>    val <A HREF="#HEX_UNHEX-val">HEX_UNHEX</A> : thm
<A NAME="line113"></A>    val <A HREF="#HEX_def-val">HEX_def</A> : thm
<A NAME="line114"></A>    val <A HREF="#HEX_ind-val">HEX_ind</A> : thm
<A NAME="line115"></A>    val <A HREF="#LEAST_THM-val">LEAST_THM</A> : thm
<A NAME="line116"></A>    val <A HREF="#LENGTH_l2n-val">LENGTH_l2n</A> : thm
<A NAME="line117"></A>    val <A HREF="#LENGTH_n2l-val">LENGTH_n2l</A> : thm
<A NAME="line118"></A>    val <A HREF="#LESS_EQ_EXP_MULT-val">LESS_EQ_EXP_MULT</A> : thm
<A NAME="line119"></A>    val <A HREF="#LOG2_UNIQUE-val">LOG2_UNIQUE</A> : thm
<A NAME="line120"></A>    val <A HREF="#LOG_RWT-val">LOG_RWT</A> : thm
<A NAME="line121"></A>    val <A HREF="#LSB_ODD-val">LSB_ODD</A> : thm
<A NAME="line122"></A>    val <A HREF="#LT_TWOEXP-val">LT_TWOEXP</A> : thm
<A NAME="line123"></A>    val <A HREF="#MOD_2EXP_LT-val">MOD_2EXP_LT</A> : thm
<A NAME="line124"></A>    val <A HREF="#MOD_2EXP_MONO-val">MOD_2EXP_MONO</A> : thm
<A NAME="line125"></A>    val <A HREF="#MOD_ADD_1-val">MOD_ADD_1</A> : thm
<A NAME="line126"></A>    val <A HREF="#MOD_PLUS_1-val">MOD_PLUS_1</A> : thm
<A NAME="line127"></A>    val <A HREF="#MOD_PLUS_RIGHT-val">MOD_PLUS_RIGHT</A> : thm
<A NAME="line128"></A>    val <A HREF="#NOT_BIT-val">NOT_BIT</A> : thm
<A NAME="line129"></A>    val <A HREF="#NOT_BITS-val">NOT_BITS</A> : thm
<A NAME="line130"></A>    val <A HREF="#NOT_BITS2-val">NOT_BITS2</A> : thm
<A NAME="line131"></A>    val <A HREF="#NOT_BIT_GT_BITWISE-val">NOT_BIT_GT_BITWISE</A> : thm
<A NAME="line132"></A>    val <A HREF="#NOT_BIT_GT_LOG2-val">NOT_BIT_GT_LOG2</A> : thm
<A NAME="line133"></A>    val <A HREF="#NOT_BIT_GT_TWOEXP-val">NOT_BIT_GT_TWOEXP</A> : thm
<A NAME="line134"></A>    val <A HREF="#NOT_MOD2_LEM-val">NOT_MOD2_LEM</A> : thm
<A NAME="line135"></A>    val <A HREF="#NOT_MOD2_LEM2-val">NOT_MOD2_LEM2</A> : thm
<A NAME="line136"></A>    val <A HREF="#NOT_ZERO_ADD1-val">NOT_ZERO_ADD1</A> : thm
<A NAME="line137"></A>    val <A HREF="#ODD_MOD2_LEM-val">ODD_MOD2_LEM</A> : thm
<A NAME="line138"></A>    val <A HREF="#SBIT_DIV-val">SBIT_DIV</A> : thm
<A NAME="line139"></A>    val <A HREF="#SBIT_MULT-val">SBIT_MULT</A> : thm
<A NAME="line140"></A>    val <A HREF="#SLICELT_THM-val">SLICELT_THM</A> : thm
<A NAME="line141"></A>    val <A HREF="#SLICE_COMP_RWT-val">SLICE_COMP_RWT</A> : thm
<A NAME="line142"></A>    val <A HREF="#SLICE_COMP_THM-val">SLICE_COMP_THM</A> : thm
<A NAME="line143"></A>    val <A HREF="#SLICE_COMP_THM2-val">SLICE_COMP_THM2</A> : thm
<A NAME="line144"></A>    val <A HREF="#SLICE_THM-val">SLICE_THM</A> : thm
<A NAME="line145"></A>    val <A HREF="#SLICE_ZERO-val">SLICE_ZERO</A> : thm
<A NAME="line146"></A>    val <A HREF="#SLICE_ZERO2-val">SLICE_ZERO2</A> : thm
<A NAME="line147"></A>    val <A HREF="#SLICE_ZERO_THM-val">SLICE_ZERO_THM</A> : thm
<A NAME="line148"></A>    val <A HREF="#SUB_num_to_bin_string-val">SUB_num_to_bin_string</A> : thm
<A NAME="line149"></A>    val <A HREF="#SUC_SUB-val">SUC_SUB</A> : thm
<A NAME="line150"></A>    val <A HREF="#TWOEXP_DIVISION-val">TWOEXP_DIVISION</A> : thm
<A NAME="line151"></A>    val <A HREF="#TWOEXP_MONO-val">TWOEXP_MONO</A> : thm
<A NAME="line152"></A>    val <A HREF="#TWOEXP_MONO2-val">TWOEXP_MONO2</A> : thm
<A NAME="line153"></A>    val <A HREF="#TWOEXP_NOT_ZERO-val">TWOEXP_NOT_ZERO</A> : thm
<A NAME="line154"></A>    val <A HREF="#UNHEX_HEX-val">UNHEX_HEX</A> : thm
<A NAME="line155"></A>    val <A HREF="#UNHEX_def-val">UNHEX_def</A> : thm
<A NAME="line156"></A>    val <A HREF="#UNHEX_ind-val">UNHEX_ind</A> : thm
<A NAME="line157"></A>    val <A HREF="#ZERO_LT_TWOEXP-val">ZERO_LT_TWOEXP</A> : thm
<A NAME="line158"></A>    val <A HREF="#l2n_DIGIT-val">l2n_DIGIT</A> : thm
<A NAME="line159"></A>    val <A HREF="#l2n_n2l-val">l2n_n2l</A> : thm
<A NAME="line160"></A>    val <A HREF="#n2l_BOUND-val">n2l_BOUND</A> : thm
<A NAME="line161"></A>    val <A HREF="#n2l_def-val">n2l_def</A> : thm
<A NAME="line162"></A>    val <A HREF="#n2l_ind-val">n2l_ind</A> : thm
<A NAME="line163"></A>    val <A HREF="#n2l_l2n-val">n2l_l2n</A> : thm
<A NAME="line164"></A>    val <A HREF="#n2s_compute-val">n2s_compute</A> : thm
<A NAME="line165"></A>    val <A HREF="#n2s_s2n-val">n2s_s2n</A> : thm
<A NAME="line166"></A>    val <A HREF="#num_bin_list-val">num_bin_list</A> : thm
<A NAME="line167"></A>    val <A HREF="#num_bin_string-val">num_bin_string</A> : thm
<A NAME="line168"></A>    val <A HREF="#num_dec_list-val">num_dec_list</A> : thm
<A NAME="line169"></A>    val <A HREF="#num_dec_string-val">num_dec_string</A> : thm
<A NAME="line170"></A>    val <A HREF="#num_hex_list-val">num_hex_list</A> : thm
<A NAME="line171"></A>    val <A HREF="#num_hex_string-val">num_hex_string</A> : thm
<A NAME="line172"></A>    val <A HREF="#num_oct_list-val">num_oct_list</A> : thm
<A NAME="line173"></A>    val <A HREF="#num_oct_string-val">num_oct_string</A> : thm
<A NAME="line174"></A>    val <A HREF="#s2n_compute-val">s2n_compute</A> : thm
<A NAME="line175"></A>    val <A HREF="#s2n_n2s-val">s2n_n2s</A> : thm
<A NAME="line176"></A>  
<A NAME="line177"></A>  val bit_grammars : type_grammar.grammar * term_grammar.grammar
<A NAME="line178"></A>  
<A NAME="line179"></A>  
<A NAME="line180"></A>(*
   [logroot] Parent theory of "bit"
   
   [string] Parent theory of "bit"
   
   [<A NAME="BITS_def-val"><B>BITS_def</B></A>]  Definition
      
      |- !h l n. BITS h l n = MOD_2EXP (SUC h - l) (DIV_2EXP l n)
   
   [<A NAME="BITV_def-val"><B>BITV_def</B></A>]  Definition
      
      |- !n b. BITV n b = BITS b b n
   
   [<A NAME="BITWISE_def-val"><B>BITWISE_def</B></A>]  Definition
      
      |- (!op x y. BITWISE 0 op x y = 0) /\
         !n op x y.
           BITWISE (SUC n) op x y =
           BITWISE n op x y + SBIT (op (BIT n x) (BIT n y)) n
   
   [<A NAME="BIT_MODIFY_def-val"><B>BIT_MODIFY_def</B></A>]  Definition
      
      |- (!f x. BIT_MODIFY 0 f x = 0) /\
         !n f x.
           BIT_MODIFY (SUC n) f x =
           BIT_MODIFY n f x + SBIT (f n (BIT n x)) n
   
   [<A NAME="BIT_REVERSE_def-val"><B>BIT_REVERSE_def</B></A>]  Definition
      
      |- (!x. BIT_REVERSE 0 x = 0) /\
         !n x.
           BIT_REVERSE (SUC n) x = BIT_REVERSE n x * 2 + SBIT (BIT n x) 0
   
   [<A NAME="BIT_def-val"><B>BIT_def</B></A>]  Definition
      
      |- !b n. BIT b n &lt;=&gt; (BITS b b n = 1)
   
   [<A NAME="DIVMOD_2EXP_def-val"><B>DIVMOD_2EXP_def</B></A>]  Definition
      
      |- !x n. DIVMOD_2EXP x n = (n DIV 2 ** x,n MOD 2 ** x)
   
   [<A NAME="HEX_primitive_def-val"><B>HEX_primitive_def</B></A>]  Definition
      
      |- HEX =
         WFREC (@R. WF R)
           (\HEX a.
              case a of
                 0 -&gt; I #"0"
              || 1 -&gt; I #"1"
              || 2 -&gt; I #"2"
              || 3 -&gt; I #"3"
              || 4 -&gt; I #"4"
              || 5 -&gt; I #"5"
              || 6 -&gt; I #"6"
              || 7 -&gt; I #"7"
              || 8 -&gt; I #"8"
              || 9 -&gt; I #"9"
              || 10 -&gt; I #"A"
              || 11 -&gt; I #"B"
              || 12 -&gt; I #"C"
              || 13 -&gt; I #"D"
              || 14 -&gt; I #"E"
              || 15 -&gt; I #"F"
              || v -&gt; ARB)
   
   [<A NAME="LOG2_def-val"><B>LOG2_def</B></A>]  Definition
      
      |- LOG2 = LOG 2
   
   [<A NAME="LOWEST_SET_BIT_def-val"><B>LOWEST_SET_BIT_def</B></A>]  Definition
      
      |- !n. LOWEST_SET_BIT n = LEAST i. BIT i n
   
   [<A NAME="LSB_def-val"><B>LSB_def</B></A>]  Definition
      
      |- LSB = BIT 0
   
   [<A NAME="MOD_2EXP_EQ_def-val"><B>MOD_2EXP_EQ_def</B></A>]  Definition
      
      |- !n a b. MOD_2EXP_EQ n a b &lt;=&gt; (MOD_2EXP n a = MOD_2EXP n b)
   
   [<A NAME="MOD_2EXP_MAX_def-val"><B>MOD_2EXP_MAX_def</B></A>]  Definition
      
      |- !n a. MOD_2EXP_MAX n a &lt;=&gt; (MOD_2EXP n a = 2 ** n - 1)
   
   [<A NAME="SBIT_def-val"><B>SBIT_def</B></A>]  Definition
      
      |- !b n. SBIT b n = if b then 2 ** n else 0
   
   [<A NAME="SIGN_EXTEND_def-val"><B>SIGN_EXTEND_def</B></A>]  Definition
      
      |- !l h n.
           SIGN_EXTEND l h n =
           (let m = n MOD 2 ** l in
              if BIT (l - 1) n then 2 ** h - 2 ** l + m else m)
   
   [<A NAME="SLICE_def-val"><B>SLICE_def</B></A>]  Definition
      
      |- !h l n. SLICE h l n = MOD_2EXP (SUC h) n - MOD_2EXP l n
   
   [<A NAME="TIMES_2EXP_def-val"><B>TIMES_2EXP_def</B></A>]  Definition
      
      |- !x n. TIMES_2EXP x n = n * 2 ** x
   
   [<A NAME="UNHEX_primitive_def-val"><B>UNHEX_primitive_def</B></A>]  Definition
      
      |- UNHEX =
         WFREC (@R. WF R)
           (\UNHEX a.
              case a of
                 #"0" -&gt; I 0
              || #"1" -&gt; I 1
              || #"2" -&gt; I 2
              || #"3" -&gt; I 3
              || #"4" -&gt; I 4
              || #"5" -&gt; I 5
              || #"6" -&gt; I 6
              || #"7" -&gt; I 7
              || #"8" -&gt; I 8
              || #"9" -&gt; I 9
              || #"a" -&gt; I 10
              || #"b" -&gt; I 11
              || #"c" -&gt; I 12
              || #"d" -&gt; I 13
              || #"e" -&gt; I 14
              || #"f" -&gt; I 15
              || #"A" -&gt; I 10
              || #"B" -&gt; I 11
              || #"C" -&gt; I 12
              || #"D" -&gt; I 13
              || #"E" -&gt; I 14
              || #"F" -&gt; I 15
              || v -&gt; ARB)
   
   [<A NAME="l2n_def-val"><B>l2n_def</B></A>]  Definition
      
      |- (!b. l2n b [] = 0) /\ !b h t. l2n b (h::t) = h MOD b + b * l2n b t
   
   [<A NAME="n2l_curried_def-val"><B>n2l_curried_def</B></A>]  Definition
      
      |- !x x1. n2l x x1 = n2l_tupled (x,x1)
   
   [<A NAME="n2l_tupled_primitive_def-val"><B>n2l_tupled_primitive_def</B></A>]  Definition
      
      |- n2l_tupled =
         WFREC
           (@R. WF R /\ !b n. ~(n &lt; b \/ b &lt; 2) ==&gt; R (b,n DIV b) (b,n))
           (\n2l_tupled a.
              case a of
                 (b,n) -&gt;
                   I
                     (if n &lt; b \/ b &lt; 2 then
                        [n MOD b]
                      else
                        n MOD b::n2l_tupled (b,n DIV b)))
   
   [<A NAME="n2s_def-val"><B>n2s_def</B></A>]  Definition
      
      |- !b f n. n2s b f n = REVERSE (MAP f (n2l b n))
   
   [<A NAME="num_from_bin_list_def-val"><B>num_from_bin_list_def</B></A>]  Definition
      
      |- num_from_bin_list = l2n 2
   
   [<A NAME="num_from_bin_string_def-val"><B>num_from_bin_string_def</B></A>]  Definition
      
      |- num_from_bin_string = s2n 2 UNHEX
   
   [<A NAME="num_from_dec_list_def-val"><B>num_from_dec_list_def</B></A>]  Definition
      
      |- num_from_dec_list = l2n 10
   
   [<A NAME="num_from_dec_string_def-val"><B>num_from_dec_string_def</B></A>]  Definition
      
      |- num_from_dec_string = s2n 10 UNHEX
   
   [<A NAME="num_from_hex_list_def-val"><B>num_from_hex_list_def</B></A>]  Definition
      
      |- num_from_hex_list = l2n 16
   
   [<A NAME="num_from_hex_string_def-val"><B>num_from_hex_string_def</B></A>]  Definition
      
      |- num_from_hex_string = s2n 16 UNHEX
   
   [<A NAME="num_from_oct_list_def-val"><B>num_from_oct_list_def</B></A>]  Definition
      
      |- num_from_oct_list = l2n 8
   
   [<A NAME="num_from_oct_string_def-val"><B>num_from_oct_string_def</B></A>]  Definition
      
      |- num_from_oct_string = s2n 8 UNHEX
   
   [<A NAME="num_to_bin_list_def-val"><B>num_to_bin_list_def</B></A>]  Definition
      
      |- num_to_bin_list = n2l 2
   
   [<A NAME="num_to_bin_string_def-val"><B>num_to_bin_string_def</B></A>]  Definition
      
      |- num_to_bin_string = n2s 2 HEX
   
   [<A NAME="num_to_dec_list_def-val"><B>num_to_dec_list_def</B></A>]  Definition
      
      |- num_to_dec_list = n2l 10
   
   [<A NAME="num_to_dec_string_def-val"><B>num_to_dec_string_def</B></A>]  Definition
      
      |- num_to_dec_string = n2s 10 HEX
   
   [<A NAME="num_to_hex_list_def-val"><B>num_to_hex_list_def</B></A>]  Definition
      
      |- num_to_hex_list = n2l 16
   
   [<A NAME="num_to_hex_string_def-val"><B>num_to_hex_string_def</B></A>]  Definition
      
      |- num_to_hex_string = n2s 16 HEX
   
   [<A NAME="num_to_oct_list_def-val"><B>num_to_oct_list_def</B></A>]  Definition
      
      |- num_to_oct_list = n2l 8
   
   [<A NAME="num_to_oct_string_def-val"><B>num_to_oct_string_def</B></A>]  Definition
      
      |- num_to_oct_string = n2s 8 HEX
   
   [<A NAME="s2n_def-val"><B>s2n_def</B></A>]  Definition
      
      |- !b f s. s2n b f s = l2n b (MAP f (REVERSE s))
   
   [<A NAME="ADD_BIT0-val"><B>ADD_BIT0</B></A>]  Theorem
      
      |- !m n. BIT 0 (m + n) &lt;=&gt; (BIT 0 m &lt;=/=&gt; BIT 0 n)
   
   [<A NAME="ADD_BITS_SUC-val"><B>ADD_BITS_SUC</B></A>]  Theorem
      
      |- !n a b.
           BITS (SUC n) (SUC n) (a + b) =
           (BITS (SUC n) (SUC n) a + BITS (SUC n) (SUC n) b +
            BITS (SUC n) (SUC n) (BITS n 0 a + BITS n 0 b)) MOD 2
   
   [<A NAME="ADD_BIT_SUC-val"><B>ADD_BIT_SUC</B></A>]  Theorem
      
      |- !n a b.
           BIT (SUC n) (a + b) &lt;=&gt;
           if BIT (SUC n) (BITS n 0 a + BITS n 0 b) then
             BIT (SUC n) a &lt;=&gt; BIT (SUC n) b
           else
             BIT (SUC n) a &lt;=/=&gt; BIT (SUC n) b
   
   [<A NAME="BITSLT_THM-val"><B>BITSLT_THM</B></A>]  Theorem
      
      |- !h l n. BITS h l n &lt; 2 ** (SUC h - l)
   
   [<A NAME="BITS_COMP_THM-val"><B>BITS_COMP_THM</B></A>]  Theorem
      
      |- !h1 l1 h2 l2 n.
           h2 + l1 &lt;= h1 ==&gt;
           (BITS h2 l2 (BITS h1 l1 n) = BITS (h2 + l1) (l2 + l1) n)
   
   [<A NAME="BITS_COMP_THM2-val"><B>BITS_COMP_THM2</B></A>]  Theorem
      
      |- !h1 l1 h2 l2 n.
           BITS h2 l2 (BITS h1 l1 n) = BITS (MIN h1 (h2 + l1)) (l2 + l1) n
   
   [<A NAME="BITS_DIV_THM-val"><B>BITS_DIV_THM</B></A>]  Theorem
      
      |- !h l x n. BITS h l x DIV 2 ** n = BITS h (l + n) x
   
   [<A NAME="BITS_LT_HIGH-val"><B>BITS_LT_HIGH</B></A>]  Theorem
      
      |- !h l n. n &lt; 2 ** SUC h ==&gt; (BITS h l n = n DIV 2 ** l)
   
   [<A NAME="BITS_LT_LOW-val"><B>BITS_LT_LOW</B></A>]  Theorem
      
      |- !h l n. n &lt; 2 ** l ==&gt; (BITS h l n = 0)
   
   [<A NAME="BITS_SLICE_THM-val"><B>BITS_SLICE_THM</B></A>]  Theorem
      
      |- !h l n. BITS h l (SLICE h l n) = BITS h l n
   
   [<A NAME="BITS_SLICE_THM2-val"><B>BITS_SLICE_THM2</B></A>]  Theorem
      
      |- !h l n. h &lt;= h2 ==&gt; (BITS h2 l (SLICE h l n) = BITS h l n)
   
   [<A NAME="BITS_SUC-val"><B>BITS_SUC</B></A>]  Theorem
      
      |- !h l n.
           l &lt;= SUC h ==&gt;
           (SBIT (BIT (SUC h) n) (SUC h - l) + BITS h l n =
            BITS (SUC h) l n)
   
   [<A NAME="BITS_SUC_THM-val"><B>BITS_SUC_THM</B></A>]  Theorem
      
      |- !h l n.
           BITS (SUC h) l n =
           if SUC h &lt; l then
             0
           else
             SBIT (BIT (SUC h) n) (SUC h - l) + BITS h l n
   
   [<A NAME="BITS_SUM-val"><B>BITS_SUM</B></A>]  Theorem
      
      |- !h l a b.
           b &lt; 2 ** l ==&gt;
           (BITS h l (a * 2 ** l + b) = BITS h l (a * 2 ** l))
   
   [<A NAME="BITS_SUM2-val"><B>BITS_SUM2</B></A>]  Theorem
      
      |- !h l a b. BITS h l (a * 2 ** SUC h + b) = BITS h l b
   
   [<A NAME="BITS_SUM3-val"><B>BITS_SUM3</B></A>]  Theorem
      
      |- !h a b. BITS h 0 (BITS h 0 a + BITS h 0 b) = BITS h 0 (a + b)
   
   [<A NAME="BITS_THM-val"><B>BITS_THM</B></A>]  Theorem
      
      |- !h l n. BITS h l n = (n DIV 2 ** l) MOD 2 ** (SUC h - l)
   
   [<A NAME="BITS_THM2-val"><B>BITS_THM2</B></A>]  Theorem
      
      |- !h l n. BITS h l n = n MOD 2 ** SUC h DIV 2 ** l
   
   [<A NAME="BITS_ZERO-val"><B>BITS_ZERO</B></A>]  Theorem
      
      |- !h l n. h &lt; l ==&gt; (BITS h l n = 0)
   
   [<A NAME="BITS_ZERO2-val"><B>BITS_ZERO2</B></A>]  Theorem
      
      |- !h l. BITS h l 0 = 0
   
   [<A NAME="BITS_ZERO3-val"><B>BITS_ZERO3</B></A>]  Theorem
      
      |- !h n. BITS h 0 n = n MOD 2 ** SUC h
   
   [<A NAME="BITS_ZERO4-val"><B>BITS_ZERO4</B></A>]  Theorem
      
      |- !h l n. l &lt;= h ==&gt; (BITS h l (a * 2 ** l) = BITS (h - l) 0 a)
   
   [<A NAME="BITS_ZEROL-val"><B>BITS_ZEROL</B></A>]  Theorem
      
      |- !h a. a &lt; 2 ** SUC h ==&gt; (BITS h 0 a = a)
   
   [<A NAME="BITV_THM-val"><B>BITV_THM</B></A>]  Theorem
      
      |- !b n. BITV n b = SBIT (BIT b n) 0
   
   [<A NAME="BITWISE_BITS-val"><B>BITWISE_BITS</B></A>]  Theorem
      
      |- !wl op a b.
           BITWISE (SUC wl) op (BITS wl 0 a) (BITS wl 0 b) =
           BITWISE (SUC wl) op a b
   
   [<A NAME="BITWISE_COR-val"><B>BITWISE_COR</B></A>]  Theorem
      
      |- !x n op a b.
           x &lt; n ==&gt;
           op (BIT x a) (BIT x b) ==&gt;
           ((BITWISE n op a b DIV 2 ** x) MOD 2 = 1)
   
   [<A NAME="BITWISE_EVAL-val"><B>BITWISE_EVAL</B></A>]  Theorem
      
      |- !n op a b.
           BITWISE (SUC n) op a b =
           2 * BITWISE n op (a DIV 2) (b DIV 2) +
           SBIT (op (LSB a) (LSB b)) 0
   
   [<A NAME="BITWISE_LT_2EXP-val"><B>BITWISE_LT_2EXP</B></A>]  Theorem
      
      |- !n op a b. BITWISE n op a b &lt; 2 ** n
   
   [<A NAME="BITWISE_NOT_COR-val"><B>BITWISE_NOT_COR</B></A>]  Theorem
      
      |- !x n op a b.
           x &lt; n ==&gt;
           ~op (BIT x a) (BIT x b) ==&gt;
           ((BITWISE n op a b DIV 2 ** x) MOD 2 = 0)
   
   [<A NAME="BITWISE_ONE_COMP_LEM-val"><B>BITWISE_ONE_COMP_LEM</B></A>]  Theorem
      
      |- !n a b.
           BITWISE (SUC n) (\x y. ~x) a b = 2 ** SUC n - 1 - BITS n 0 a
   
   [<A NAME="BITWISE_THM-val"><B>BITWISE_THM</B></A>]  Theorem
      
      |- !x n op a b.
           x &lt; n ==&gt; (BIT x (BITWISE n op a b) &lt;=&gt; op (BIT x a) (BIT x b))
   
   [<A NAME="BIT_B-val"><B>BIT_B</B></A>]  Theorem
      
      |- !b. BIT b (2 ** b)
   
   [<A NAME="BIT_BITS_THM-val"><B>BIT_BITS_THM</B></A>]  Theorem
      
      |- !h l a b.
           (!x. l &lt;= x /\ x &lt;= h ==&gt; (BIT x a &lt;=&gt; BIT x b)) &lt;=&gt;
           (BITS h l a = BITS h l b)
   
   [<A NAME="BIT_B_NEQ-val"><B>BIT_B_NEQ</B></A>]  Theorem
      
      |- !a b. a &lt;&gt; b ==&gt; ~BIT a (2 ** b)
   
   [<A NAME="BIT_COMP_THM3-val"><B>BIT_COMP_THM3</B></A>]  Theorem
      
      |- !h m l n.
           SUC m &lt;= h /\ l &lt;= m ==&gt;
           (BITS h (SUC m) n * 2 ** (SUC m - l) + BITS m l n = BITS h l n)
   
   [<A NAME="BIT_DIV2-val"><B>BIT_DIV2</B></A>]  Theorem
      
      |- !n i. BIT n (i DIV 2) &lt;=&gt; BIT (SUC n) i
   
   [<A NAME="BIT_EXP_SUB1-val"><B>BIT_EXP_SUB1</B></A>]  Theorem
      
      |- !b n. BIT b (2 ** n - 1) &lt;=&gt; b &lt; n
   
   [<A NAME="BIT_LOG2-val"><B>BIT_LOG2</B></A>]  Theorem
      
      |- !n. n &lt;&gt; 0 ==&gt; BIT (LOG2 n) n
   
   [<A NAME="BIT_MODIFY_THM-val"><B>BIT_MODIFY_THM</B></A>]  Theorem
      
      |- !x n f a. x &lt; n ==&gt; (BIT x (BIT_MODIFY n f a) &lt;=&gt; f x (BIT x a))
   
   [<A NAME="BIT_OF_BITS_THM-val"><B>BIT_OF_BITS_THM</B></A>]  Theorem
      
      |- !n h l a. l + n &lt;= h ==&gt; (BIT n (BITS h l a) &lt;=&gt; BIT (l + n) a)
   
   [<A NAME="BIT_OF_BITS_THM2-val"><B>BIT_OF_BITS_THM2</B></A>]  Theorem
      
      |- !h l x n. h &lt; l + x ==&gt; ~BIT x (BITS h l n)
   
   [<A NAME="BIT_REVERSE_THM-val"><B>BIT_REVERSE_THM</B></A>]  Theorem
      
      |- !x n a. x &lt; n ==&gt; (BIT x (BIT_REVERSE n a) &lt;=&gt; BIT (n - 1 - x) a)
   
   [<A NAME="BIT_SHIFT_THM-val"><B>BIT_SHIFT_THM</B></A>]  Theorem
      
      |- !n a s. BIT (n + s) (a * 2 ** s) &lt;=&gt; BIT n a
   
   [<A NAME="BIT_SHIFT_THM2-val"><B>BIT_SHIFT_THM2</B></A>]  Theorem
      
      |- !n a s. s &lt;= n ==&gt; (BIT n (a * 2 ** s) &lt;=&gt; BIT (n - s) a)
   
   [<A NAME="BIT_SHIFT_THM3-val"><B>BIT_SHIFT_THM3</B></A>]  Theorem
      
      |- !n a s. n &lt; s ==&gt; ~BIT n (a * 2 ** s)
   
   [<A NAME="BIT_SIGN_EXTEND-val"><B>BIT_SIGN_EXTEND</B></A>]  Theorem
      
      |- !l h n i.
           l &lt;&gt; 0 ==&gt;
           (BIT i (SIGN_EXTEND l h n) &lt;=&gt;
            if l &lt;= h ==&gt; i &lt; l then
              BIT i (n MOD 2 ** l)
            else
              i &lt; h /\ BIT (l - 1) n)
   
   [<A NAME="BIT_SLICE-val"><B>BIT_SLICE</B></A>]  Theorem
      
      |- !n a b. (BIT n a &lt;=&gt; BIT n b) &lt;=&gt; (SLICE n n a = SLICE n n b)
   
   [<A NAME="BIT_SLICE_LEM-val"><B>BIT_SLICE_LEM</B></A>]  Theorem
      
      |- !y x n. SBIT (BIT x n) (x + y) = SLICE x x n * 2 ** y
   
   [<A NAME="BIT_SLICE_THM-val"><B>BIT_SLICE_THM</B></A>]  Theorem
      
      |- !x n. SBIT (BIT x n) x = SLICE x x n
   
   [<A NAME="BIT_SLICE_THM2-val"><B>BIT_SLICE_THM2</B></A>]  Theorem
      
      |- !b n. BIT b n &lt;=&gt; (SLICE b b n = 2 ** b)
   
   [<A NAME="BIT_SLICE_THM3-val"><B>BIT_SLICE_THM3</B></A>]  Theorem
      
      |- !b n. ~BIT b n &lt;=&gt; (SLICE b b n = 0)
   
   [<A NAME="BIT_SLICE_THM4-val"><B>BIT_SLICE_THM4</B></A>]  Theorem
      
      |- !b h l n. BIT b (SLICE h l n) &lt;=&gt; l &lt;= b /\ b &lt;= h /\ BIT b n
   
   [<A NAME="BIT_ZERO-val"><B>BIT_ZERO</B></A>]  Theorem
      
      |- !b. ~BIT b 0
   
   [<A NAME="BIT_num_from_bin_list-val"><B>BIT_num_from_bin_list</B></A>]  Theorem
      
      |- !x l.
           EVERY ($&gt; 2) l /\ x &lt; LENGTH l ==&gt;
           (BIT x (num_from_bin_list l) &lt;=&gt; (EL x l = 1))
   
   [<A NAME="BIT_num_from_bin_string-val"><B>BIT_num_from_bin_string</B></A>]  Theorem
      
      |- !x s.
           EVERY ($&gt; 2 o UNHEX) s /\ x &lt; STRLEN s ==&gt;
           (BIT x (num_from_bin_string s) &lt;=&gt;
            (UNHEX (SUB (s,PRE (STRLEN s - x))) = 1))
   
   [<A NAME="DEC_UNDEC-val"><B>DEC_UNDEC</B></A>]  Theorem
      
      |- !c. isDigit c ==&gt; (HEX (UNHEX c) = c)
   
   [<A NAME="DIVMOD_2EXP-val"><B>DIVMOD_2EXP</B></A>]  Theorem
      
      |- !x n. DIVMOD_2EXP x n = (DIV_2EXP x n,MOD_2EXP x n)
   
   [<A NAME="DIV_0_IMP_LT-val"><B>DIV_0_IMP_LT</B></A>]  Theorem
      
      |- !b n. 1 &lt; b /\ (n DIV b = 0) ==&gt; n &lt; b
   
   [<A NAME="DIV_MULT_1-val"><B>DIV_MULT_1</B></A>]  Theorem
      
      |- !r n. r &lt; n ==&gt; ((n + r) DIV n = 1)
   
   [<A NAME="DIV_MULT_THM-val"><B>DIV_MULT_THM</B></A>]  Theorem
      
      |- !x n. n DIV 2 ** x * 2 ** x = n - n MOD 2 ** x
   
   [<A NAME="DIV_MULT_THM2-val"><B>DIV_MULT_THM2</B></A>]  Theorem
      
      |- !n. 2 * (n DIV 2) = n - n MOD 2
   
   [<A NAME="EL_TAKE-val"><B>EL_TAKE</B></A>]  Theorem
      
      |- !x n l. x &lt; n /\ n &lt;= LENGTH l ==&gt; (EL x (TAKE n l) = EL x l)
   
   [<A NAME="EL_n2l-val"><B>EL_n2l</B></A>]  Theorem
      
      |- !b x n.
           1 &lt; b /\ x &lt; LENGTH (n2l b n) ==&gt;
           (EL x (n2l b n) = (n DIV b ** x) MOD b)
   
   [<A NAME="EL_num_to_bin_list-val"><B>EL_num_to_bin_list</B></A>]  Theorem
      
      |- !x n.
           x &lt; LENGTH (num_to_bin_list n) ==&gt;
           (EL x (num_to_bin_list n) = BITV n x)
   
   [<A NAME="EXP_SUB_LESS_EQ-val"><B>EXP_SUB_LESS_EQ</B></A>]  Theorem
      
      |- !a b. 2 ** (a - b) &lt;= 2 ** a
   
   [<A NAME="HEX_UNHEX-val"><B>HEX_UNHEX</B></A>]  Theorem
      
      |- !c. isHexDigit c ==&gt; (HEX (UNHEX c) = toUpper c)
   
   [<A NAME="HEX_def-val"><B>HEX_def</B></A>]  Theorem
      
      |- (HEX 0 = #"0") /\ (HEX 1 = #"1") /\ (HEX 2 = #"2") /\
         (HEX 3 = #"3") /\ (HEX 4 = #"4") /\ (HEX 5 = #"5") /\
         (HEX 6 = #"6") /\ (HEX 7 = #"7") /\ (HEX 8 = #"8") /\
         (HEX 9 = #"9") /\ (HEX 10 = #"A") /\ (HEX 11 = #"B") /\
         (HEX 12 = #"C") /\ (HEX 13 = #"D") /\ (HEX 14 = #"E") /\
         (HEX 15 = #"F")
   
   [<A NAME="HEX_ind-val"><B>HEX_ind</B></A>]  Theorem
      
      |- !P.
           P 0 /\ P 1 /\ P 2 /\ P 3 /\ P 4 /\ P 5 /\ P 6 /\ P 7 /\ P 8 /\
           P 9 /\ P 10 /\ P 11 /\ P 12 /\ P 13 /\ P 14 /\ P 15 /\
           (!v18. P v18) ==&gt;
           !v. P v
   
   [<A NAME="LEAST_THM-val"><B>LEAST_THM</B></A>]  Theorem
      
      |- !n. (!m. m &lt; n ==&gt; ~P m) /\ P n ==&gt; ($LEAST P = n)
   
   [<A NAME="LENGTH_l2n-val"><B>LENGTH_l2n</B></A>]  Theorem
      
      |- !b l.
           1 &lt; b /\ EVERY ($&gt; b) l /\ l2n b l &lt;&gt; 0 ==&gt;
           SUC (LOG b (l2n b l)) &lt;= LENGTH l
   
   [<A NAME="LENGTH_n2l-val"><B>LENGTH_n2l</B></A>]  Theorem
      
      |- !b n.
           1 &lt; b ==&gt;
           (LENGTH (n2l b n) = if n = 0 then 1 else SUC (LOG b n))
   
   [<A NAME="LESS_EQ_EXP_MULT-val"><B>LESS_EQ_EXP_MULT</B></A>]  Theorem
      
      |- !a b. a &lt;= b ==&gt; ?p. 2 ** b = p * 2 ** a
   
   [<A NAME="LOG2_UNIQUE-val"><B>LOG2_UNIQUE</B></A>]  Theorem
      
      |- !n p. 2 ** p &lt;= n /\ n &lt; 2 ** SUC p ==&gt; (LOG2 n = p)
   
   [<A NAME="LOG_RWT-val"><B>LOG_RWT</B></A>]  Theorem
      
      |- !m n.
           1 &lt; m /\ 0 &lt; n ==&gt;
           (LOG m n = if n &lt; m then 0 else SUC (LOG m (n DIV m)))
   
   [<A NAME="LSB_ODD-val"><B>LSB_ODD</B></A>]  Theorem
      
      |- LSB = ODD
   
   [<A NAME="LT_TWOEXP-val"><B>LT_TWOEXP</B></A>]  Theorem
      
      |- !x n. x &lt; 2 ** n &lt;=&gt; (x = 0) \/ LOG2 x &lt; n
   
   [<A NAME="MOD_2EXP_LT-val"><B>MOD_2EXP_LT</B></A>]  Theorem
      
      |- !n k. k MOD 2 ** n &lt; 2 ** n
   
   [<A NAME="MOD_2EXP_MONO-val"><B>MOD_2EXP_MONO</B></A>]  Theorem
      
      |- !n h l. l &lt;= h ==&gt; n MOD 2 ** l &lt;= n MOD 2 ** SUC h
   
   [<A NAME="MOD_ADD_1-val"><B>MOD_ADD_1</B></A>]  Theorem
      
      |- !n.
           0 &lt; n ==&gt;
           !x. (x + 1) MOD n &lt;&gt; 0 ==&gt; ((x + 1) MOD n = x MOD n + 1)
   
   [<A NAME="MOD_PLUS_1-val"><B>MOD_PLUS_1</B></A>]  Theorem
      
      |- !n. 0 &lt; n ==&gt; !x. ((x + 1) MOD n = 0) &lt;=&gt; (x MOD n + 1 = n)
   
   [<A NAME="MOD_PLUS_RIGHT-val"><B>MOD_PLUS_RIGHT</B></A>]  Theorem
      
      |- !n. 0 &lt; n ==&gt; !j k. (j + k MOD n) MOD n = (j + k) MOD n
   
   [<A NAME="NOT_BIT-val"><B>NOT_BIT</B></A>]  Theorem
      
      |- !n a. ~BIT n a &lt;=&gt; (BITS n n a = 0)
   
   [<A NAME="NOT_BITS-val"><B>NOT_BITS</B></A>]  Theorem
      
      |- !n a. BITS n n a &lt;&gt; 0 &lt;=&gt; (BITS n n a = 1)
   
   [<A NAME="NOT_BITS2-val"><B>NOT_BITS2</B></A>]  Theorem
      
      |- !n a. BITS n n a &lt;&gt; 1 &lt;=&gt; (BITS n n a = 0)
   
   [<A NAME="NOT_BIT_GT_BITWISE-val"><B>NOT_BIT_GT_BITWISE</B></A>]  Theorem
      
      |- !i n op a b. n &lt;= i ==&gt; ~BIT i (BITWISE n op a b)
   
   [<A NAME="NOT_BIT_GT_LOG2-val"><B>NOT_BIT_GT_LOG2</B></A>]  Theorem
      
      |- !i n. LOG2 n &lt; i ==&gt; ~BIT i n
   
   [<A NAME="NOT_BIT_GT_TWOEXP-val"><B>NOT_BIT_GT_TWOEXP</B></A>]  Theorem
      
      |- !i n. n &lt; 2 ** i ==&gt; ~BIT i n
   
   [<A NAME="NOT_MOD2_LEM-val"><B>NOT_MOD2_LEM</B></A>]  Theorem
      
      |- !n. n MOD 2 &lt;&gt; 0 &lt;=&gt; (n MOD 2 = 1)
   
   [<A NAME="NOT_MOD2_LEM2-val"><B>NOT_MOD2_LEM2</B></A>]  Theorem
      
      |- !n a. n MOD 2 &lt;&gt; 1 &lt;=&gt; (n MOD 2 = 0)
   
   [<A NAME="NOT_ZERO_ADD1-val"><B>NOT_ZERO_ADD1</B></A>]  Theorem
      
      |- !m. m &lt;&gt; 0 ==&gt; ?p. m = SUC p
   
   [<A NAME="ODD_MOD2_LEM-val"><B>ODD_MOD2_LEM</B></A>]  Theorem
      
      |- !n. ODD n &lt;=&gt; (n MOD 2 = 1)
   
   [<A NAME="SBIT_DIV-val"><B>SBIT_DIV</B></A>]  Theorem
      
      |- !b m n. n &lt; m ==&gt; (SBIT b (m - n) = SBIT b m DIV 2 ** n)
   
   [<A NAME="SBIT_MULT-val"><B>SBIT_MULT</B></A>]  Theorem
      
      |- !b m n. SBIT b n * 2 ** m = SBIT b (n + m)
   
   [<A NAME="SLICELT_THM-val"><B>SLICELT_THM</B></A>]  Theorem
      
      |- !h l n. SLICE h l n &lt; 2 ** SUC h
   
   [<A NAME="SLICE_COMP_RWT-val"><B>SLICE_COMP_RWT</B></A>]  Theorem
      
      |- !h m' m l n.
           l &lt;= m /\ (m' = m + 1) /\ m &lt; h ==&gt;
           (SLICE h m' n + SLICE m l n = SLICE h l n)
   
   [<A NAME="SLICE_COMP_THM-val"><B>SLICE_COMP_THM</B></A>]  Theorem
      
      |- !h m l n.
           SUC m &lt;= h /\ l &lt;= m ==&gt;
           (SLICE h (SUC m) n + SLICE m l n = SLICE h l n)
   
   [<A NAME="SLICE_COMP_THM2-val"><B>SLICE_COMP_THM2</B></A>]  Theorem
      
      |- !h l x y n.
           h &lt;= x /\ y &lt;= l ==&gt; (SLICE h l (SLICE x y n) = SLICE h l n)
   
   [<A NAME="SLICE_THM-val"><B>SLICE_THM</B></A>]  Theorem
      
      |- !n h l. SLICE h l n = BITS h l n * 2 ** l
   
   [<A NAME="SLICE_ZERO-val"><B>SLICE_ZERO</B></A>]  Theorem
      
      |- !h l n. h &lt; l ==&gt; (SLICE h l n = 0)
   
   [<A NAME="SLICE_ZERO2-val"><B>SLICE_ZERO2</B></A>]  Theorem
      
      |- SLICE h l 0 = 0
   
   [<A NAME="SLICE_ZERO_THM-val"><B>SLICE_ZERO_THM</B></A>]  Theorem
      
      |- !n h. SLICE h 0 n = BITS h 0 n
   
   [<A NAME="SUB_num_to_bin_string-val"><B>SUB_num_to_bin_string</B></A>]  Theorem
      
      |- !x n.
           x &lt; STRLEN (num_to_bin_string n) ==&gt;
           (SUB (num_to_bin_string n,x) =
            HEX (BITV n (PRE (STRLEN (num_to_bin_string n) - x))))
   
   [<A NAME="SUC_SUB-val"><B>SUC_SUB</B></A>]  Theorem
      
      |- SUC a - a = 1
   
   [<A NAME="TWOEXP_DIVISION-val"><B>TWOEXP_DIVISION</B></A>]  Theorem
      
      |- !n k. k = k DIV 2 ** n * 2 ** n + k MOD 2 ** n
   
   [<A NAME="TWOEXP_MONO-val"><B>TWOEXP_MONO</B></A>]  Theorem
      
      |- !a b. a &lt; b ==&gt; 2 ** a &lt; 2 ** b
   
   [<A NAME="TWOEXP_MONO2-val"><B>TWOEXP_MONO2</B></A>]  Theorem
      
      |- !a b. a &lt;= b ==&gt; 2 ** a &lt;= 2 ** b
   
   [<A NAME="TWOEXP_NOT_ZERO-val"><B>TWOEXP_NOT_ZERO</B></A>]  Theorem
      
      |- !n. 2 ** n &lt;&gt; 0
   
   [<A NAME="UNHEX_HEX-val"><B>UNHEX_HEX</B></A>]  Theorem
      
      |- !n. n &lt; 16 ==&gt; (UNHEX (HEX n) = n)
   
   [<A NAME="UNHEX_def-val"><B>UNHEX_def</B></A>]  Theorem
      
      |- (UNHEX #"0" = 0) /\ (UNHEX #"1" = 1) /\ (UNHEX #"2" = 2) /\
         (UNHEX #"3" = 3) /\ (UNHEX #"4" = 4) /\ (UNHEX #"5" = 5) /\
         (UNHEX #"6" = 6) /\ (UNHEX #"7" = 7) /\ (UNHEX #"8" = 8) /\
         (UNHEX #"9" = 9) /\ (UNHEX #"a" = 10) /\ (UNHEX #"b" = 11) /\
         (UNHEX #"c" = 12) /\ (UNHEX #"d" = 13) /\ (UNHEX #"e" = 14) /\
         (UNHEX #"f" = 15) /\ (UNHEX #"A" = 10) /\ (UNHEX #"B" = 11) /\
         (UNHEX #"C" = 12) /\ (UNHEX #"D" = 13) /\ (UNHEX #"E" = 14) /\
         (UNHEX #"F" = 15)
   
   [<A NAME="UNHEX_ind-val"><B>UNHEX_ind</B></A>]  Theorem
      
      |- !P.
           P #"0" /\ P #"1" /\ P #"2" /\ P #"3" /\ P #"4" /\ P #"5" /\
           P #"6" /\ P #"7" /\ P #"8" /\ P #"9" /\ P #"a" /\ P #"b" /\
           P #"c" /\ P #"d" /\ P #"e" /\ P #"f" /\ P #"A" /\ P #"B" /\
           P #"C" /\ P #"D" /\ P #"E" /\ P #"F" /\ (!v24. P v24) ==&gt;
           !v. P v
   
   [<A NAME="ZERO_LT_TWOEXP-val"><B>ZERO_LT_TWOEXP</B></A>]  Theorem
      
      |- !n. 0 &lt; 2 ** n
   
   [<A NAME="l2n_DIGIT-val"><B>l2n_DIGIT</B></A>]  Theorem
      
      |- !b l x.
           1 &lt; b /\ EVERY ($&gt; b) l /\ x &lt; LENGTH l ==&gt;
           ((l2n b l DIV b ** x) MOD b = EL x l)
   
   [<A NAME="l2n_n2l-val"><B>l2n_n2l</B></A>]  Theorem
      
      |- !b n. 1 &lt; b ==&gt; (l2n b (n2l b n) = n)
   
   [<A NAME="n2l_BOUND-val"><B>n2l_BOUND</B></A>]  Theorem
      
      |- !b n. 0 &lt; b ==&gt; EVERY ($&gt; b) (n2l b n)
   
   [<A NAME="n2l_def-val"><B>n2l_def</B></A>]  Theorem
      
      |- !n b.
           n2l b n =
           if n &lt; b \/ b &lt; 2 then [n MOD b] else n MOD b::n2l b (n DIV b)
   
   [<A NAME="n2l_ind-val"><B>n2l_ind</B></A>]  Theorem
      
      |- !P.
           (!b n. (~(n &lt; b \/ b &lt; 2) ==&gt; P b (n DIV b)) ==&gt; P b n) ==&gt;
           !v v1. P v v1
   
   [<A NAME="n2l_l2n-val"><B>n2l_l2n</B></A>]  Theorem
      
      |- !b l.
           1 &lt; b /\ EVERY ($&gt; b) l ==&gt;
           (n2l b (l2n b l) =
            if l2n b l = 0 then [0] else TAKE (SUC (LOG b (l2n b l))) l)
   
   [<A NAME="n2s_compute-val"><B>n2s_compute</B></A>]  Theorem
      
      |- n2s b f n = IMPLODE (REVERSE (MAP f (n2l b n)))
   
   [<A NAME="n2s_s2n-val"><B>n2s_s2n</B></A>]  Theorem
      
      |- !c2n n2c b s.
           1 &lt; b /\ EVERY ($&gt; b o c2n) s ==&gt;
           (n2s b n2c (s2n b c2n s) =
            if s2n b c2n s = 0 then
              STRING (n2c 0) ""
            else
              MAP (n2c o c2n) (LASTN (SUC (LOG b (s2n b c2n s))) s))
   
   [<A NAME="num_bin_list-val"><B>num_bin_list</B></A>]  Theorem
      
      |- num_from_bin_list o num_to_bin_list = I
   
   [<A NAME="num_bin_string-val"><B>num_bin_string</B></A>]  Theorem
      
      |- num_from_bin_string o num_to_bin_string = I
   
   [<A NAME="num_dec_list-val"><B>num_dec_list</B></A>]  Theorem
      
      |- num_from_dec_list o num_to_dec_list = I
   
   [<A NAME="num_dec_string-val"><B>num_dec_string</B></A>]  Theorem
      
      |- num_from_dec_string o num_to_dec_string = I
   
   [<A NAME="num_hex_list-val"><B>num_hex_list</B></A>]  Theorem
      
      |- num_from_hex_list o num_to_hex_list = I
   
   [<A NAME="num_hex_string-val"><B>num_hex_string</B></A>]  Theorem
      
      |- num_from_hex_string o num_to_hex_string = I
   
   [<A NAME="num_oct_list-val"><B>num_oct_list</B></A>]  Theorem
      
      |- num_from_oct_list o num_to_oct_list = I
   
   [<A NAME="num_oct_string-val"><B>num_oct_string</B></A>]  Theorem
      
      |- num_from_oct_string o num_to_oct_string = I
   
   [<A NAME="s2n_compute-val"><B>s2n_compute</B></A>]  Theorem
      
      |- s2n b f s = l2n b (MAP f (REVERSE (EXPLODE s)))
   
   [<A NAME="s2n_n2s-val"><B>s2n_n2s</B></A>]  Theorem
      
      |- !c2n n2c b n.
           1 &lt; b /\ (!x. x &lt; b ==&gt; (c2n (n2c x) = x)) ==&gt;
           (s2n b c2n (n2s b n2c n) = n)
   
   
*)
end

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/n-bit/bitScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
