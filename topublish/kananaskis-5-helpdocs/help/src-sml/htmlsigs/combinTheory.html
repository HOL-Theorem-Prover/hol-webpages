<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure combinTheory</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure combinTheory</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/combin/combinScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>signature combinTheory =
<A NAME="line2"></A>sig
<A NAME="line3"></A>  type thm = Thm.thm
<A NAME="line4"></A>  
<A NAME="line5"></A>  (*  Definitions  *)
<A NAME="line6"></A>    val <A HREF="#C_DEF-val">C_DEF</A> : thm
<A NAME="line7"></A>    val <A HREF="#FAIL_DEF-val">FAIL_DEF</A> : thm
<A NAME="line8"></A>    val <A HREF="#I_DEF-val">I_DEF</A> : thm
<A NAME="line9"></A>    val <A HREF="#K_DEF-val">K_DEF</A> : thm
<A NAME="line10"></A>    val <A HREF="#S_DEF-val">S_DEF</A> : thm
<A NAME="line11"></A>    val <A HREF="#UPDATE_def-val">UPDATE_def</A> : thm
<A NAME="line12"></A>    val <A HREF="#W_DEF-val">W_DEF</A> : thm
<A NAME="line13"></A>    val <A HREF="#o_DEF-val">o_DEF</A> : thm
<A NAME="line14"></A>  
<A NAME="line15"></A>  (*  Theorems  *)
<A NAME="line16"></A>    val <A HREF="#APPLY_UPDATE_ID-val">APPLY_UPDATE_ID</A> : thm
<A NAME="line17"></A>    val <A HREF="#APPLY_UPDATE_THM-val">APPLY_UPDATE_THM</A> : thm
<A NAME="line18"></A>    val <A HREF="#C_ABS_L-val">C_ABS_L</A> : thm
<A NAME="line19"></A>    val <A HREF="#C_THM-val">C_THM</A> : thm
<A NAME="line20"></A>    val <A HREF="#FAIL_THM-val">FAIL_THM</A> : thm
<A NAME="line21"></A>    val <A HREF="#GEN_LET_RAND-val">GEN_LET_RAND</A> : thm
<A NAME="line22"></A>    val <A HREF="#GEN_LET_RATOR-val">GEN_LET_RATOR</A> : thm
<A NAME="line23"></A>    val <A HREF="#GEN_literal_case_RAND-val">GEN_literal_case_RAND</A> : thm
<A NAME="line24"></A>    val <A HREF="#GEN_literal_case_RATOR-val">GEN_literal_case_RATOR</A> : thm
<A NAME="line25"></A>    val <A HREF="#I_THM-val">I_THM</A> : thm
<A NAME="line26"></A>    val <A HREF="#I_o_ID-val">I_o_ID</A> : thm
<A NAME="line27"></A>    val <A HREF="#K_THM-val">K_THM</A> : thm
<A NAME="line28"></A>    val <A HREF="#K_o_THM-val">K_o_THM</A> : thm
<A NAME="line29"></A>    val <A HREF="#LET_FORALL_ELIM-val">LET_FORALL_ELIM</A> : thm
<A NAME="line30"></A>    val <A HREF="#SAME_KEY_UPDATE_DIFFER-val">SAME_KEY_UPDATE_DIFFER</A> : thm
<A NAME="line31"></A>    val <A HREF="#S_ABS_L-val">S_ABS_L</A> : thm
<A NAME="line32"></A>    val <A HREF="#S_ABS_R-val">S_ABS_R</A> : thm
<A NAME="line33"></A>    val <A HREF="#S_THM-val">S_THM</A> : thm
<A NAME="line34"></A>    val <A HREF="#UPD11_SAME_BASE-val">UPD11_SAME_BASE</A> : thm
<A NAME="line35"></A>    val <A HREF="#UPD11_SAME_KEY_AND_BASE-val">UPD11_SAME_KEY_AND_BASE</A> : thm
<A NAME="line36"></A>    val <A HREF="#UPDATE_APPLY_ID-val">UPDATE_APPLY_ID</A> : thm
<A NAME="line37"></A>    val <A HREF="#UPDATE_APPLY_IMP_ID-val">UPDATE_APPLY_IMP_ID</A> : thm
<A NAME="line38"></A>    val <A HREF="#UPDATE_COMMUTES-val">UPDATE_COMMUTES</A> : thm
<A NAME="line39"></A>    val <A HREF="#UPDATE_EQ-val">UPDATE_EQ</A> : thm
<A NAME="line40"></A>    val <A HREF="#UPD_SAME_KEY_UNWIND-val">UPD_SAME_KEY_UNWIND</A> : thm
<A NAME="line41"></A>    val <A HREF="#W_THM-val">W_THM</A> : thm
<A NAME="line42"></A>    val <A HREF="#literal_case_FORALL_ELIM-val">literal_case_FORALL_ELIM</A> : thm
<A NAME="line43"></A>    val <A HREF="#o_ABS_R-val">o_ABS_R</A> : thm
<A NAME="line44"></A>    val <A HREF="#o_ASSOC-val">o_ASSOC</A> : thm
<A NAME="line45"></A>    val <A HREF="#o_THM-val">o_THM</A> : thm
<A NAME="line46"></A>  
<A NAME="line47"></A>  val combin_grammars : type_grammar.grammar * term_grammar.grammar
<A NAME="line48"></A>(*
   [marker] Parent theory of "combin"
   
   [<A NAME="C_DEF-val"><B>C_DEF</B></A>]  Definition
      
      |- C = (\f x y. f y x)
   
   [<A NAME="FAIL_DEF-val"><B>FAIL_DEF</B></A>]  Definition
      
      |- FAIL = (\x y. x)
   
   [<A NAME="I_DEF-val"><B>I_DEF</B></A>]  Definition
      
      |- I = S K K
   
   [<A NAME="K_DEF-val"><B>K_DEF</B></A>]  Definition
      
      |- K = (\x y. x)
   
   [<A NAME="S_DEF-val"><B>S_DEF</B></A>]  Definition
      
      |- S = (\f g x. f x (g x))
   
   [<A NAME="UPDATE_def-val"><B>UPDATE_def</B></A>]  Definition
      
      |- !a b. a =+ b = (\f c. if a = c then b else f c)
   
   [<A NAME="W_DEF-val"><B>W_DEF</B></A>]  Definition
      
      |- W = (\f x. f x x)
   
   [<A NAME="o_DEF-val"><B>o_DEF</B></A>]  Definition
      
      |- !f g. f o g = (\x. f (g x))
   
   [<A NAME="APPLY_UPDATE_ID-val"><B>APPLY_UPDATE_ID</B></A>]  Theorem
      
      |- !f a. (a =+ f a) f = f
   
   [<A NAME="APPLY_UPDATE_THM-val"><B>APPLY_UPDATE_THM</B></A>]  Theorem
      
      |- !f a b c. (a =+ b) f c = if a = c then b else f c
   
   [<A NAME="C_ABS_L-val"><B>C_ABS_L</B></A>]  Theorem
      
      |- C (\x. f x) y = (\x. f x y)
   
   [<A NAME="C_THM-val"><B>C_THM</B></A>]  Theorem
      
      |- !f x y. C f x y = f y x
   
   [<A NAME="FAIL_THM-val"><B>FAIL_THM</B></A>]  Theorem
      
      |- FAIL x y = x
   
   [<A NAME="GEN_LET_RAND-val"><B>GEN_LET_RAND</B></A>]  Theorem
      
      |- P (LET f v) = LET (P o f) v
   
   [<A NAME="GEN_LET_RATOR-val"><B>GEN_LET_RATOR</B></A>]  Theorem
      
      |- LET f v x = LET (C f x) v
   
   [<A NAME="GEN_literal_case_RAND-val"><B>GEN_literal_case_RAND</B></A>]  Theorem
      
      |- P (literal_case f v) = literal_case (P o f) v
   
   [<A NAME="GEN_literal_case_RATOR-val"><B>GEN_literal_case_RATOR</B></A>]  Theorem
      
      |- literal_case f v x = literal_case (C f x) v
   
   [<A NAME="I_THM-val"><B>I_THM</B></A>]  Theorem
      
      |- !x. I x = x
   
   [<A NAME="I_o_ID-val"><B>I_o_ID</B></A>]  Theorem
      
      |- !f. (I o f = f) /\ (f o I = f)
   
   [<A NAME="K_THM-val"><B>K_THM</B></A>]  Theorem
      
      |- !x y. K x y = x
   
   [<A NAME="K_o_THM-val"><B>K_o_THM</B></A>]  Theorem
      
      |- (!f v. K v o f = K v) /\ !f v. f o K v = K (f v)
   
   [<A NAME="LET_FORALL_ELIM-val"><B>LET_FORALL_ELIM</B></A>]  Theorem
      
      |- LET f v &lt;=&gt; $! (S ($==&gt; o Abbrev o C $= v) f)
   
   [<A NAME="SAME_KEY_UPDATE_DIFFER-val"><B>SAME_KEY_UPDATE_DIFFER</B></A>]  Theorem
      
      |- !f1 f2 a b c. b &lt;&gt; c ==&gt; (a =+ b) f &lt;&gt; (a =+ c) f
   
   [<A NAME="S_ABS_L-val"><B>S_ABS_L</B></A>]  Theorem
      
      |- S (\x. f x) g = (\x. f x (g x))
   
   [<A NAME="S_ABS_R-val"><B>S_ABS_R</B></A>]  Theorem
      
      |- S f (\x. g x) = (\x. f x (g x))
   
   [<A NAME="S_THM-val"><B>S_THM</B></A>]  Theorem
      
      |- !f g x. S f g x = f x (g x)
   
   [<A NAME="UPD11_SAME_BASE-val"><B>UPD11_SAME_BASE</B></A>]  Theorem
      
      |- !f a b c d.
           ((a =+ c) f = (b =+ d) f) &lt;=&gt;
           (a = b) /\ (c = d) \/
           a &lt;&gt; b /\ ((a =+ c) f = f) /\ ((b =+ d) f = f)
   
   [<A NAME="UPD11_SAME_KEY_AND_BASE-val"><B>UPD11_SAME_KEY_AND_BASE</B></A>]  Theorem
      
      |- !f a b c. ((a =+ b) f = (a =+ c) f) &lt;=&gt; (b = c)
   
   [<A NAME="UPDATE_APPLY_ID-val"><B>UPDATE_APPLY_ID</B></A>]  Theorem
      
      |- !f a b. (f a = b) &lt;=&gt; ((a =+ b) f = f)
   
   [<A NAME="UPDATE_APPLY_IMP_ID-val"><B>UPDATE_APPLY_IMP_ID</B></A>]  Theorem
      
      |- !f b a. (f a = b) ==&gt; ((a =+ b) f = f)
   
   [<A NAME="UPDATE_COMMUTES-val"><B>UPDATE_COMMUTES</B></A>]  Theorem
      
      |- !f a b c d.
           a &lt;&gt; b ==&gt; ((a =+ c) ((b =+ d) f) = (b =+ d) ((a =+ c) f))
   
   [<A NAME="UPDATE_EQ-val"><B>UPDATE_EQ</B></A>]  Theorem
      
      |- !f a b c. (a =+ c) ((a =+ b) f) = (a =+ c) f
   
   [<A NAME="UPD_SAME_KEY_UNWIND-val"><B>UPD_SAME_KEY_UNWIND</B></A>]  Theorem
      
      |- !f1 f2 a b c.
           ((a =+ b) f1 = (a =+ c) f2) ==&gt;
           (b = c) /\ !v. (a =+ v) f1 = (a =+ v) f2
   
   [<A NAME="W_THM-val"><B>W_THM</B></A>]  Theorem
      
      |- !f x. W f x = f x x
   
   [<A NAME="literal_case_FORALL_ELIM-val"><B>literal_case_FORALL_ELIM</B></A>]  Theorem
      
      |- literal_case f v &lt;=&gt; $! (S ($==&gt; o Abbrev o C $= v) f)
   
   [<A NAME="o_ABS_R-val"><B>o_ABS_R</B></A>]  Theorem
      
      |- f o (\x. g x) = (\x. f (g x))
   
   [<A NAME="o_ASSOC-val"><B>o_ASSOC</B></A>]  Theorem
      
      |- !f g h. f o g o h = (f o g) o h
   
   [<A NAME="o_THM-val"><B>o_THM</B></A>]  Theorem
      
      |- !f g x. (f o g) x = f (g x)
   
   
*)
end

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/combin/combinScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
