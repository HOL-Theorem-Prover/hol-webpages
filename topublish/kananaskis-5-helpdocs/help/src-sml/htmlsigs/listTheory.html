<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure listTheory</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure listTheory</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/list/src/listScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>signature listTheory =
<A NAME="line2"></A>sig
<A NAME="line3"></A>  type thm = Thm.thm
<A NAME="line4"></A>  
<A NAME="line5"></A>  (*  Definitions  *)
<A NAME="line6"></A>    val <A HREF="#ALL_DISTINCT-val">ALL_DISTINCT</A> : thm
<A NAME="line7"></A>    val <A HREF="#APPEND-val">APPEND</A> : thm
<A NAME="line8"></A>    val <A HREF="#DROP_def-val">DROP_def</A> : thm
<A NAME="line9"></A>    val <A HREF="#EL-val">EL</A> : thm
<A NAME="line10"></A>    val <A HREF="#EVERY_DEF-val">EVERY_DEF</A> : thm
<A NAME="line11"></A>    val <A HREF="#EXISTS_DEF-val">EXISTS_DEF</A> : thm
<A NAME="line12"></A>    val <A HREF="#FILTER-val">FILTER</A> : thm
<A NAME="line13"></A>    val <A HREF="#FLAT-val">FLAT</A> : thm
<A NAME="line14"></A>    val <A HREF="#FOLDL-val">FOLDL</A> : thm
<A NAME="line15"></A>    val <A HREF="#FOLDR-val">FOLDR</A> : thm
<A NAME="line16"></A>    val <A HREF="#FRONT_DEF-val">FRONT_DEF</A> : thm
<A NAME="line17"></A>    val <A HREF="#HD-val">HD</A> : thm
<A NAME="line18"></A>    val <A HREF="#LAST_DEF-val">LAST_DEF</A> : thm
<A NAME="line19"></A>    val <A HREF="#LENGTH-val">LENGTH</A> : thm
<A NAME="line20"></A>    val <A HREF="#LEN_DEF-val">LEN_DEF</A> : thm
<A NAME="line21"></A>    val <A HREF="#LIST_TO_SET-val">LIST_TO_SET</A> : thm
<A NAME="line22"></A>    val <A HREF="#MAP-val">MAP</A> : thm
<A NAME="line23"></A>    val <A HREF="#MAP2-val">MAP2</A> : thm
<A NAME="line24"></A>    val <A HREF="#MEM-val">MEM</A> : thm
<A NAME="line25"></A>    val <A HREF="#NULL_DEF-val">NULL_DEF</A> : thm
<A NAME="line26"></A>    val <A HREF="#REVERSE_DEF-val">REVERSE_DEF</A> : thm
<A NAME="line27"></A>    val <A HREF="#REV_DEF-val">REV_DEF</A> : thm
<A NAME="line28"></A>    val <A HREF="#SET_TO_LIST_primitive-val">SET_TO_LIST_primitive</A> : thm
<A NAME="line29"></A>    val <A HREF="#SUM-val">SUM</A> : thm
<A NAME="line30"></A>    val <A HREF="#TAKE_def-val">TAKE_def</A> : thm
<A NAME="line31"></A>    val <A HREF="#TL-val">TL</A> : thm
<A NAME="line32"></A>    val <A HREF="#UNZIP-val">UNZIP</A> : thm
<A NAME="line33"></A>    val <A HREF="#ZIP-val">ZIP</A> : thm
<A NAME="line34"></A>    val <A HREF="#isPREFIX-val">isPREFIX</A> : thm
<A NAME="line35"></A>    val <A HREF="#listRel-val">listRel</A> : thm
<A NAME="line36"></A>    val <A HREF="#list_TY_DEF-val">list_TY_DEF</A> : thm
<A NAME="line37"></A>    val <A HREF="#list_case_def-val">list_case_def</A> : thm
<A NAME="line38"></A>    val <A HREF="#list_repfns-val">list_repfns</A> : thm
<A NAME="line39"></A>    val <A HREF="#list_size_def-val">list_size_def</A> : thm
<A NAME="line40"></A>  
<A NAME="line41"></A>  (*  Theorems  *)
<A NAME="line42"></A>    val <A HREF="#ALL_DISTINCT_APPEND-val">ALL_DISTINCT_APPEND</A> : thm
<A NAME="line43"></A>    val <A HREF="#ALL_DISTINCT_EL_IMP-val">ALL_DISTINCT_EL_IMP</A> : thm
<A NAME="line44"></A>    val <A HREF="#ALL_DISTINCT_FILTER-val">ALL_DISTINCT_FILTER</A> : thm
<A NAME="line45"></A>    val <A HREF="#ALL_DISTINCT_SET_TO_LIST-val">ALL_DISTINCT_SET_TO_LIST</A> : thm
<A NAME="line46"></A>    val <A HREF="#ALL_DISTINCT_SING-val">ALL_DISTINCT_SING</A> : thm
<A NAME="line47"></A>    val <A HREF="#APPEND_11-val">APPEND_11</A> : thm
<A NAME="line48"></A>    val <A HREF="#APPEND_ASSOC-val">APPEND_ASSOC</A> : thm
<A NAME="line49"></A>    val <A HREF="#APPEND_EQ_SELF-val">APPEND_EQ_SELF</A> : thm
<A NAME="line50"></A>    val <A HREF="#APPEND_FRONT_LAST-val">APPEND_FRONT_LAST</A> : thm
<A NAME="line51"></A>    val <A HREF="#APPEND_NIL-val">APPEND_NIL</A> : thm
<A NAME="line52"></A>    val <A HREF="#APPEND_eq_NIL-val">APPEND_eq_NIL</A> : thm
<A NAME="line53"></A>    val <A HREF="#CONS-val">CONS</A> : thm
<A NAME="line54"></A>    val <A HREF="#CONS_11-val">CONS_11</A> : thm
<A NAME="line55"></A>    val <A HREF="#CONS_ACYCLIC-val">CONS_ACYCLIC</A> : thm
<A NAME="line56"></A>    val <A HREF="#DROP_0-val">DROP_0</A> : thm
<A NAME="line57"></A>    val <A HREF="#EL_ALL_DISTINCT_EL_EQ-val">EL_ALL_DISTINCT_EL_EQ</A> : thm
<A NAME="line58"></A>    val <A HREF="#EL_ZIP-val">EL_ZIP</A> : thm
<A NAME="line59"></A>    val <A HREF="#EL_compute-val">EL_compute</A> : thm
<A NAME="line60"></A>    val <A HREF="#EL_simp-val">EL_simp</A> : thm
<A NAME="line61"></A>    val <A HREF="#EQ_LIST-val">EQ_LIST</A> : thm
<A NAME="line62"></A>    val <A HREF="#EVERY_APPEND-val">EVERY_APPEND</A> : thm
<A NAME="line63"></A>    val <A HREF="#EVERY_CONG-val">EVERY_CONG</A> : thm
<A NAME="line64"></A>    val <A HREF="#EVERY_CONJ-val">EVERY_CONJ</A> : thm
<A NAME="line65"></A>    val <A HREF="#EVERY_EL-val">EVERY_EL</A> : thm
<A NAME="line66"></A>    val <A HREF="#EVERY_FILTER-val">EVERY_FILTER</A> : thm
<A NAME="line67"></A>    val <A HREF="#EVERY_MAP-val">EVERY_MAP</A> : thm
<A NAME="line68"></A>    val <A HREF="#EVERY_MEM-val">EVERY_MEM</A> : thm
<A NAME="line69"></A>    val <A HREF="#EVERY_MONOTONIC-val">EVERY_MONOTONIC</A> : thm
<A NAME="line70"></A>    val <A HREF="#EVERY_NOT_EXISTS-val">EVERY_NOT_EXISTS</A> : thm
<A NAME="line71"></A>    val <A HREF="#EVERY_SIMP-val">EVERY_SIMP</A> : thm
<A NAME="line72"></A>    val <A HREF="#EXISTS_APPEND-val">EXISTS_APPEND</A> : thm
<A NAME="line73"></A>    val <A HREF="#EXISTS_CONG-val">EXISTS_CONG</A> : thm
<A NAME="line74"></A>    val <A HREF="#EXISTS_MAP-val">EXISTS_MAP</A> : thm
<A NAME="line75"></A>    val <A HREF="#EXISTS_MEM-val">EXISTS_MEM</A> : thm
<A NAME="line76"></A>    val <A HREF="#EXISTS_NOT_EVERY-val">EXISTS_NOT_EVERY</A> : thm
<A NAME="line77"></A>    val <A HREF="#EXISTS_SIMP-val">EXISTS_SIMP</A> : thm
<A NAME="line78"></A>    val <A HREF="#FILTER_ALL_DISTINCT-val">FILTER_ALL_DISTINCT</A> : thm
<A NAME="line79"></A>    val <A HREF="#FILTER_APPEND_DISTRIB-val">FILTER_APPEND_DISTRIB</A> : thm
<A NAME="line80"></A>    val <A HREF="#FILTER_COND_REWRITE-val">FILTER_COND_REWRITE</A> : thm
<A NAME="line81"></A>    val <A HREF="#FILTER_EQ_APPEND-val">FILTER_EQ_APPEND</A> : thm
<A NAME="line82"></A>    val <A HREF="#FILTER_EQ_CONS-val">FILTER_EQ_CONS</A> : thm
<A NAME="line83"></A>    val <A HREF="#FILTER_EQ_ID-val">FILTER_EQ_ID</A> : thm
<A NAME="line84"></A>    val <A HREF="#FILTER_EQ_NIL-val">FILTER_EQ_NIL</A> : thm
<A NAME="line85"></A>    val <A HREF="#FILTER_NEQ_ID-val">FILTER_NEQ_ID</A> : thm
<A NAME="line86"></A>    val <A HREF="#FILTER_NEQ_NIL-val">FILTER_NEQ_NIL</A> : thm
<A NAME="line87"></A>    val <A HREF="#FINITE_LIST_TO_SET-val">FINITE_LIST_TO_SET</A> : thm
<A NAME="line88"></A>    val <A HREF="#FOLDL_CONG-val">FOLDL_CONG</A> : thm
<A NAME="line89"></A>    val <A HREF="#FOLDL_EQ_FOLDR-val">FOLDL_EQ_FOLDR</A> : thm
<A NAME="line90"></A>    val <A HREF="#FOLDR_CONG-val">FOLDR_CONG</A> : thm
<A NAME="line91"></A>    val <A HREF="#FORALL_LIST-val">FORALL_LIST</A> : thm
<A NAME="line92"></A>    val <A HREF="#FRONT_CONS-val">FRONT_CONS</A> : thm
<A NAME="line93"></A>    val <A HREF="#IN_LIST_TO_SET-val">IN_LIST_TO_SET</A> : thm
<A NAME="line94"></A>    val <A HREF="#LAST_CONS-val">LAST_CONS</A> : thm
<A NAME="line95"></A>    val <A HREF="#LENGTH_APPEND-val">LENGTH_APPEND</A> : thm
<A NAME="line96"></A>    val <A HREF="#LENGTH_CONS-val">LENGTH_CONS</A> : thm
<A NAME="line97"></A>    val <A HREF="#LENGTH_DROP-val">LENGTH_DROP</A> : thm
<A NAME="line98"></A>    val <A HREF="#LENGTH_EQ_CONS-val">LENGTH_EQ_CONS</A> : thm
<A NAME="line99"></A>    val <A HREF="#LENGTH_EQ_NIL-val">LENGTH_EQ_NIL</A> : thm
<A NAME="line100"></A>    val <A HREF="#LENGTH_LEN-val">LENGTH_LEN</A> : thm
<A NAME="line101"></A>    val <A HREF="#LENGTH_MAP-val">LENGTH_MAP</A> : thm
<A NAME="line102"></A>    val <A HREF="#LENGTH_NIL-val">LENGTH_NIL</A> : thm
<A NAME="line103"></A>    val <A HREF="#LENGTH_TAKE-val">LENGTH_TAKE</A> : thm
<A NAME="line104"></A>    val <A HREF="#LENGTH_TL-val">LENGTH_TL</A> : thm
<A NAME="line105"></A>    val <A HREF="#LENGTH_UNZIP-val">LENGTH_UNZIP</A> : thm
<A NAME="line106"></A>    val <A HREF="#LENGTH_ZIP-val">LENGTH_ZIP</A> : thm
<A NAME="line107"></A>    val <A HREF="#LEN_LENGTH_LEM-val">LEN_LENGTH_LEM</A> : thm
<A NAME="line108"></A>    val <A HREF="#LIST_EQ-val">LIST_EQ</A> : thm
<A NAME="line109"></A>    val <A HREF="#LIST_EQ_REWRITE-val">LIST_EQ_REWRITE</A> : thm
<A NAME="line110"></A>    val <A HREF="#LIST_NOT_EQ-val">LIST_NOT_EQ</A> : thm
<A NAME="line111"></A>    val <A HREF="#LIST_TO_SET_APPEND-val">LIST_TO_SET_APPEND</A> : thm
<A NAME="line112"></A>    val <A HREF="#LIST_TO_SET_THM-val">LIST_TO_SET_THM</A> : thm
<A NAME="line113"></A>    val <A HREF="#MAP2_ZIP-val">MAP2_ZIP</A> : thm
<A NAME="line114"></A>    val <A HREF="#MAP_APPEND-val">MAP_APPEND</A> : thm
<A NAME="line115"></A>    val <A HREF="#MAP_CONG-val">MAP_CONG</A> : thm
<A NAME="line116"></A>    val <A HREF="#MAP_EQ_NIL-val">MAP_EQ_NIL</A> : thm
<A NAME="line117"></A>    val <A HREF="#MEM_APPEND-val">MEM_APPEND</A> : thm
<A NAME="line118"></A>    val <A HREF="#MEM_EL-val">MEM_EL</A> : thm
<A NAME="line119"></A>    val <A HREF="#MEM_FILTER-val">MEM_FILTER</A> : thm
<A NAME="line120"></A>    val <A HREF="#MEM_FLAT-val">MEM_FLAT</A> : thm
<A NAME="line121"></A>    val <A HREF="#MEM_MAP-val">MEM_MAP</A> : thm
<A NAME="line122"></A>    val <A HREF="#MEM_REVERSE-val">MEM_REVERSE</A> : thm
<A NAME="line123"></A>    val <A HREF="#MEM_SET_TO_LIST-val">MEM_SET_TO_LIST</A> : thm
<A NAME="line124"></A>    val <A HREF="#MEM_SPLIT-val">MEM_SPLIT</A> : thm
<A NAME="line125"></A>    val <A HREF="#MEM_ZIP-val">MEM_ZIP</A> : thm
<A NAME="line126"></A>    val <A HREF="#MONO_EVERY-val">MONO_EVERY</A> : thm
<A NAME="line127"></A>    val <A HREF="#MONO_EXISTS-val">MONO_EXISTS</A> : thm
<A NAME="line128"></A>    val <A HREF="#MONO_listRel-val">MONO_listRel</A> : thm
<A NAME="line129"></A>    val <A HREF="#NOT_CONS_NIL-val">NOT_CONS_NIL</A> : thm
<A NAME="line130"></A>    val <A HREF="#NOT_EQ_LIST-val">NOT_EQ_LIST</A> : thm
<A NAME="line131"></A>    val <A HREF="#NOT_EVERY-val">NOT_EVERY</A> : thm
<A NAME="line132"></A>    val <A HREF="#NOT_EXISTS-val">NOT_EXISTS</A> : thm
<A NAME="line133"></A>    val <A HREF="#NOT_NIL_CONS-val">NOT_NIL_CONS</A> : thm
<A NAME="line134"></A>    val <A HREF="#NOT_NULL_MEM-val">NOT_NULL_MEM</A> : thm
<A NAME="line135"></A>    val <A HREF="#NULL-val">NULL</A> : thm
<A NAME="line136"></A>    val <A HREF="#NULL_EQ-val">NULL_EQ</A> : thm
<A NAME="line137"></A>    val <A HREF="#NULL_LENGTH-val">NULL_LENGTH</A> : thm
<A NAME="line138"></A>    val <A HREF="#REVERSE_APPEND-val">REVERSE_APPEND</A> : thm
<A NAME="line139"></A>    val <A HREF="#REVERSE_REV-val">REVERSE_REV</A> : thm
<A NAME="line140"></A>    val <A HREF="#REVERSE_REVERSE-val">REVERSE_REVERSE</A> : thm
<A NAME="line141"></A>    val <A HREF="#REV_REVERSE_LEM-val">REV_REVERSE_LEM</A> : thm
<A NAME="line142"></A>    val <A HREF="#SET_TO_LIST_CARD-val">SET_TO_LIST_CARD</A> : thm
<A NAME="line143"></A>    val <A HREF="#SET_TO_LIST_IND-val">SET_TO_LIST_IND</A> : thm
<A NAME="line144"></A>    val <A HREF="#SET_TO_LIST_INV-val">SET_TO_LIST_INV</A> : thm
<A NAME="line145"></A>    val <A HREF="#SET_TO_LIST_IN_MEM-val">SET_TO_LIST_IN_MEM</A> : thm
<A NAME="line146"></A>    val <A HREF="#SET_TO_LIST_SING-val">SET_TO_LIST_SING</A> : thm
<A NAME="line147"></A>    val <A HREF="#SET_TO_LIST_THM-val">SET_TO_LIST_THM</A> : thm
<A NAME="line148"></A>    val <A HREF="#TAKE_0-val">TAKE_0</A> : thm
<A NAME="line149"></A>    val <A HREF="#TAKE_APPEND1-val">TAKE_APPEND1</A> : thm
<A NAME="line150"></A>    val <A HREF="#TAKE_APPEND2-val">TAKE_APPEND2</A> : thm
<A NAME="line151"></A>    val <A HREF="#TAKE_DROP-val">TAKE_DROP</A> : thm
<A NAME="line152"></A>    val <A HREF="#TAKE_LENGTH_ID-val">TAKE_LENGTH_ID</A> : thm
<A NAME="line153"></A>    val <A HREF="#UNION_APPEND-val">UNION_APPEND</A> : thm
<A NAME="line154"></A>    val <A HREF="#UNZIP_THM-val">UNZIP_THM</A> : thm
<A NAME="line155"></A>    val <A HREF="#UNZIP_ZIP-val">UNZIP_ZIP</A> : thm
<A NAME="line156"></A>    val <A HREF="#WF_LIST_PRED-val">WF_LIST_PRED</A> : thm
<A NAME="line157"></A>    val <A HREF="#ZIP_MAP-val">ZIP_MAP</A> : thm
<A NAME="line158"></A>    val <A HREF="#ZIP_UNZIP-val">ZIP_UNZIP</A> : thm
<A NAME="line159"></A>    val <A HREF="#datatype_list-val">datatype_list</A> : thm
<A NAME="line160"></A>    val <A HREF="#isPREFIX_THM-val">isPREFIX_THM</A> : thm
<A NAME="line161"></A>    val <A HREF="#listRel_CONS-val">listRel_CONS</A> : thm
<A NAME="line162"></A>    val <A HREF="#listRel_LENGTH-val">listRel_LENGTH</A> : thm
<A NAME="line163"></A>    val <A HREF="#listRel_NIL-val">listRel_NIL</A> : thm
<A NAME="line164"></A>    val <A HREF="#listRel_cases-val">listRel_cases</A> : thm
<A NAME="line165"></A>    val <A HREF="#listRel_ind-val">listRel_ind</A> : thm
<A NAME="line166"></A>    val <A HREF="#listRel_rules-val">listRel_rules</A> : thm
<A NAME="line167"></A>    val <A HREF="#listRel_strong_ind-val">listRel_strong_ind</A> : thm
<A NAME="line168"></A>    val <A HREF="#list_11-val">list_11</A> : thm
<A NAME="line169"></A>    val <A HREF="#list_Axiom-val">list_Axiom</A> : thm
<A NAME="line170"></A>    val <A HREF="#list_Axiom_old-val">list_Axiom_old</A> : thm
<A NAME="line171"></A>    val <A HREF="#list_CASES-val">list_CASES</A> : thm
<A NAME="line172"></A>    val <A HREF="#list_INDUCT-val">list_INDUCT</A> : thm
<A NAME="line173"></A>    val <A HREF="#list_case_compute-val">list_case_compute</A> : thm
<A NAME="line174"></A>    val <A HREF="#list_case_cong-val">list_case_cong</A> : thm
<A NAME="line175"></A>    val <A HREF="#list_distinct-val">list_distinct</A> : thm
<A NAME="line176"></A>    val <A HREF="#list_induction-val">list_induction</A> : thm
<A NAME="line177"></A>    val <A HREF="#list_nchotomy-val">list_nchotomy</A> : thm
<A NAME="line178"></A>    val <A HREF="#list_size_cong-val">list_size_cong</A> : thm
<A NAME="line179"></A>  
<A NAME="line180"></A>  val list_grammars : type_grammar.grammar * term_grammar.grammar
<A NAME="line181"></A>  
<A NAME="line182"></A>  val list_rwts : simpLib.ssfrag
<A NAME="line183"></A>(*
   [ind_type] Parent theory of "list"
   
   [operator] Parent theory of "list"
   
   [pred_set] Parent theory of "list"
   
   [<A NAME="ALL_DISTINCT-val"><B>ALL_DISTINCT</B></A>]  Definition
      
      |- (ALL_DISTINCT [] &lt;=&gt; T) /\
         !h t. ALL_DISTINCT (h::t) &lt;=&gt; ~MEM h t /\ ALL_DISTINCT t
   
   [<A NAME="APPEND-val"><B>APPEND</B></A>]  Definition
      
      |- (!l. [] ++ l = l) /\ !l1 l2 h. h::l1 ++ l2 = h::(l1 ++ l2)
   
   [<A NAME="DROP_def-val"><B>DROP_def</B></A>]  Definition
      
      |- (!n. DROP n [] = []) /\
         !n x xs. DROP n (x::xs) = if n = 0 then x::xs else DROP (n - 1) xs
   
   [<A NAME="EL-val"><B>EL</B></A>]  Definition
      
      |- (!l. EL 0 l = HD l) /\ !l n. EL (SUC n) l = EL n (TL l)
   
   [<A NAME="EVERY_DEF-val"><B>EVERY_DEF</B></A>]  Definition
      
      |- (!P. EVERY P [] &lt;=&gt; T) /\
         !P h t. EVERY P (h::t) &lt;=&gt; P h /\ EVERY P t
   
   [<A NAME="EXISTS_DEF-val"><B>EXISTS_DEF</B></A>]  Definition
      
      |- (!P. EXISTS P [] &lt;=&gt; F) /\
         !P h t. EXISTS P (h::t) &lt;=&gt; P h \/ EXISTS P t
   
   [<A NAME="FILTER-val"><B>FILTER</B></A>]  Definition
      
      |- (!P. FILTER P [] = []) /\
         !P h t.
           FILTER P (h::t) = if P h then h::FILTER P t else FILTER P t
   
   [<A NAME="FLAT-val"><B>FLAT</B></A>]  Definition
      
      |- (FLAT [] = []) /\ !h t. FLAT (h::t) = h ++ FLAT t
   
   [<A NAME="FOLDL-val"><B>FOLDL</B></A>]  Definition
      
      |- (!f e. FOLDL f e [] = e) /\
         !f e x l. FOLDL f e (x::l) = FOLDL f (f e x) l
   
   [<A NAME="FOLDR-val"><B>FOLDR</B></A>]  Definition
      
      |- (!f e. FOLDR f e [] = e) /\
         !f e x l. FOLDR f e (x::l) = f x (FOLDR f e l)
   
   [<A NAME="FRONT_DEF-val"><B>FRONT_DEF</B></A>]  Definition
      
      |- !h t. FRONT (h::t) = if t = [] then [] else h::FRONT t
   
   [<A NAME="HD-val"><B>HD</B></A>]  Definition
      
      |- !h t. HD (h::t) = h
   
   [<A NAME="LAST_DEF-val"><B>LAST_DEF</B></A>]  Definition
      
      |- !h t. LAST (h::t) = if t = [] then h else LAST t
   
   [<A NAME="LENGTH-val"><B>LENGTH</B></A>]  Definition
      
      |- (LENGTH [] = 0) /\ !h t. LENGTH (h::t) = SUC (LENGTH t)
   
   [<A NAME="LEN_DEF-val"><B>LEN_DEF</B></A>]  Definition
      
      |- (!n. LEN [] n = n) /\ !h t n. LEN (h::t) n = LEN t (n + 1)
   
   [<A NAME="LIST_TO_SET-val"><B>LIST_TO_SET</B></A>]  Definition
      
      |- set = combin$C MEM
   
   [<A NAME="MAP-val"><B>MAP</B></A>]  Definition
      
      |- (!f. MAP f [] = []) /\ !f h t. MAP f (h::t) = f h::MAP f t
   
   [<A NAME="MAP2-val"><B>MAP2</B></A>]  Definition
      
      |- (!f. MAP2 f [] [] = []) /\
         !f h1 t1 h2 t2. MAP2 f (h1::t1) (h2::t2) = f h1 h2::MAP2 f t1 t2
   
   [<A NAME="MEM-val"><B>MEM</B></A>]  Definition
      
      |- (!x. MEM x [] &lt;=&gt; F) /\
         !x h t. MEM x (h::t) &lt;=&gt; (x = h) \/ MEM x t
   
   [<A NAME="NULL_DEF-val"><B>NULL_DEF</B></A>]  Definition
      
      |- (NULL [] &lt;=&gt; T) /\ !h t. NULL (h::t) &lt;=&gt; F
   
   [<A NAME="REVERSE_DEF-val"><B>REVERSE_DEF</B></A>]  Definition
      
      |- (REVERSE [] = []) /\ !h t. REVERSE (h::t) = REVERSE t ++ [h]
   
   [<A NAME="REV_DEF-val"><B>REV_DEF</B></A>]  Definition
      
      |- (!acc. REV [] acc = acc) /\
         !h t acc. REV (h::t) acc = REV t (h::acc)
   
   [<A NAME="SET_TO_LIST_primitive-val"><B>SET_TO_LIST_primitive</B></A>]  Definition
      
      |- SET_TO_LIST =
         WFREC (@R. WF R /\ !s. FINITE s /\ s &lt;&gt; {} ==&gt; R (REST s) s)
           (\SET_TO_LIST s.
              I
                (if FINITE s then
                   if s = {} then [] else CHOICE s::SET_TO_LIST (REST s)
                 else
                   ARB))
   
   [<A NAME="SUM-val"><B>SUM</B></A>]  Definition
      
      |- (SUM [] = 0) /\ !h t. SUM (h::t) = h + SUM t
   
   [<A NAME="TAKE_def-val"><B>TAKE_def</B></A>]  Definition
      
      |- (!n. TAKE n [] = []) /\
         !n x xs. TAKE n (x::xs) = if n = 0 then [] else x::TAKE (n - 1) xs
   
   [<A NAME="TL-val"><B>TL</B></A>]  Definition
      
      |- !h t. TL (h::t) = t
   
   [<A NAME="UNZIP-val"><B>UNZIP</B></A>]  Definition
      
      |- (UNZIP [] = ([],[])) /\
         !x l. UNZIP (x::l) = (FST x::FST (UNZIP l),SND x::SND (UNZIP l))
   
   [<A NAME="ZIP-val"><B>ZIP</B></A>]  Definition
      
      |- (ZIP ([],[]) = []) /\
         !x1 l1 x2 l2. ZIP (x1::l1,x2::l2) = (x1,x2)::ZIP (l1,l2)
   
   [<A NAME="isPREFIX-val"><B>isPREFIX</B></A>]  Definition
      
      |- (!l. [] &lt;&lt;= l &lt;=&gt; T) /\
         !h t l.
           h::t &lt;&lt;= l &lt;=&gt;
           case l of [] -&gt; F || h'::t' -&gt; (h = h') /\ t &lt;&lt;= t'
   
   [<A NAME="listRel-val"><B>listRel</B></A>]  Definition
      
      |- listRel =
         (\R a0 a1.
            !listRel'.
              (!a0 a1.
                 (a0 = []) /\ (a1 = []) \/
                 (?h1 h2 t1 t2.
                    (a0 = h1::t1) /\ (a1 = h2::t2) /\ R h1 h2 /\
                    listRel' t1 t2) ==&gt;
                 listRel' a0 a1) ==&gt;
              listRel' a0 a1)
   
   [<A NAME="list_TY_DEF-val"><B>list_TY_DEF</B></A>]  Definition
      
      |- ?rep.
           TYPE_DEFINITION
             (\a0'.
                !'list' .
                  (!a0'.
                     (a0' = ind_type$CONSTR 0 ARB (\n. ind_type$BOTTOM)) \/
                     (?a0 a1.
                        (a0' =
                         (\a0 a1.
                            ind_type$CONSTR (SUC 0) a0
                              (ind_type$FCONS a1 (\n. ind_type$BOTTOM))) a0
                           a1) /\ 'list' a1) ==&gt;
                     'list' a0') ==&gt;
                  'list' a0') rep
   
   [<A NAME="list_case_def-val"><B>list_case_def</B></A>]  Definition
      
      |- (!v f. list_case v f [] = v) /\
         !v f a0 a1. list_case v f (a0::a1) = f a0 a1
   
   [<A NAME="list_repfns-val"><B>list_repfns</B></A>]  Definition
      
      |- (!a. mk_list (dest_list a) = a) /\
         !r.
           (\a0'.
              !'list' .
                (!a0'.
                   (a0' = ind_type$CONSTR 0 ARB (\n. ind_type$BOTTOM)) \/
                   (?a0 a1.
                      (a0' =
                       (\a0 a1.
                          ind_type$CONSTR (SUC 0) a0
                            (ind_type$FCONS a1 (\n. ind_type$BOTTOM))) a0
                         a1) /\ 'list' a1) ==&gt;
                   'list' a0') ==&gt;
                'list' a0') r &lt;=&gt; (dest_list (mk_list r) = r)
   
   [<A NAME="list_size_def-val"><B>list_size_def</B></A>]  Definition
      
      |- (!f. list_size f [] = 0) /\
         !f a0 a1. list_size f (a0::a1) = 1 + (f a0 + list_size f a1)
   
   [<A NAME="ALL_DISTINCT_APPEND-val"><B>ALL_DISTINCT_APPEND</B></A>]  Theorem
      
      |- !l1 l2.
           ALL_DISTINCT (l1 ++ l2) &lt;=&gt;
           ALL_DISTINCT l1 /\ ALL_DISTINCT l2 /\ !e. MEM e l1 ==&gt; ~MEM e l2
   
   [<A NAME="ALL_DISTINCT_EL_IMP-val"><B>ALL_DISTINCT_EL_IMP</B></A>]  Theorem
      
      |- !l n1 n2.
           ALL_DISTINCT l /\ n1 &lt; LENGTH l /\ n2 &lt; LENGTH l ==&gt;
           ((EL n1 l = EL n2 l) &lt;=&gt; (n1 = n2))
   
   [<A NAME="ALL_DISTINCT_FILTER-val"><B>ALL_DISTINCT_FILTER</B></A>]  Theorem
      
      |- !l. ALL_DISTINCT l &lt;=&gt; !x. MEM x l ==&gt; (FILTER ($= x) l = [x])
   
   [<A NAME="ALL_DISTINCT_SET_TO_LIST-val"><B>ALL_DISTINCT_SET_TO_LIST</B></A>]  Theorem
      
      |- !s. FINITE s ==&gt; ALL_DISTINCT (SET_TO_LIST s)
   
   [<A NAME="ALL_DISTINCT_SING-val"><B>ALL_DISTINCT_SING</B></A>]  Theorem
      
      |- !x. ALL_DISTINCT [x]
   
   [<A NAME="APPEND_11-val"><B>APPEND_11</B></A>]  Theorem
      
      |- (!l1 l2 l3. (l1 ++ l2 = l1 ++ l3) &lt;=&gt; (l2 = l3)) /\
         !l1 l2 l3. (l2 ++ l1 = l3 ++ l1) &lt;=&gt; (l2 = l3)
   
   [<A NAME="APPEND_ASSOC-val"><B>APPEND_ASSOC</B></A>]  Theorem
      
      |- !l1 l2 l3. l1 ++ (l2 ++ l3) = l1 ++ l2 ++ l3
   
   [<A NAME="APPEND_EQ_SELF-val"><B>APPEND_EQ_SELF</B></A>]  Theorem
      
      |- (!l1 l2. (l1 ++ l2 = l1) &lt;=&gt; (l2 = [])) /\
         (!l1 l2. (l1 ++ l2 = l2) &lt;=&gt; (l1 = [])) /\
         (!l1 l2. (l1 = l1 ++ l2) &lt;=&gt; (l2 = [])) /\
         !l1 l2. (l2 = l1 ++ l2) &lt;=&gt; (l1 = [])
   
   [<A NAME="APPEND_FRONT_LAST-val"><B>APPEND_FRONT_LAST</B></A>]  Theorem
      
      |- !l. l &lt;&gt; [] ==&gt; (FRONT l ++ [LAST l] = l)
   
   [<A NAME="APPEND_NIL-val"><B>APPEND_NIL</B></A>]  Theorem
      
      |- !l. l ++ [] = l
   
   [<A NAME="APPEND_eq_NIL-val"><B>APPEND_eq_NIL</B></A>]  Theorem
      
      |- (!l1 l2. ([] = l1 ++ l2) &lt;=&gt; (l1 = []) /\ (l2 = [])) /\
         !l1 l2. (l1 ++ l2 = []) &lt;=&gt; (l1 = []) /\ (l2 = [])
   
   [<A NAME="CONS-val"><B>CONS</B></A>]  Theorem
      
      |- !l. ~NULL l ==&gt; (HD l::TL l = l)
   
   [<A NAME="CONS_11-val"><B>CONS_11</B></A>]  Theorem
      
      |- !a0 a1 a0' a1'. (a0::a1 = a0'::a1') &lt;=&gt; (a0 = a0') /\ (a1 = a1')
   
   [<A NAME="CONS_ACYCLIC-val"><B>CONS_ACYCLIC</B></A>]  Theorem
      
      |- !l x. l &lt;&gt; x::l /\ x::l &lt;&gt; l
   
   [<A NAME="DROP_0-val"><B>DROP_0</B></A>]  Theorem
      
      |- DROP 0 l = l
   
   [<A NAME="EL_ALL_DISTINCT_EL_EQ-val"><B>EL_ALL_DISTINCT_EL_EQ</B></A>]  Theorem
      
      |- !l.
           ALL_DISTINCT l &lt;=&gt;
           !n1 n2.
             n1 &lt; LENGTH l /\ n2 &lt; LENGTH l ==&gt;
             ((EL n1 l = EL n2 l) &lt;=&gt; (n1 = n2))
   
   [<A NAME="EL_ZIP-val"><B>EL_ZIP</B></A>]  Theorem
      
      |- !l1 l2 n.
           (LENGTH l1 = LENGTH l2) /\ n &lt; LENGTH l1 ==&gt;
           (EL n (ZIP (l1,l2)) = (EL n l1,EL n l2))
   
   [<A NAME="EL_compute-val"><B>EL_compute</B></A>]  Theorem
      
      |- !n. EL n l = if n = 0 then HD l else EL (PRE n) (TL l)
   
   [<A NAME="EL_simp-val"><B>EL_simp</B></A>]  Theorem
      
      |- (EL (NUMERAL (BIT1 n)) l = EL (PRE (NUMERAL (BIT1 n))) (TL l)) /\
         (EL (NUMERAL (BIT2 n)) l = EL (NUMERAL (BIT1 n)) (TL l))
   
   [<A NAME="EQ_LIST-val"><B>EQ_LIST</B></A>]  Theorem
      
      |- !h1 h2. (h1 = h2) ==&gt; !l1 l2. (l1 = l2) ==&gt; (h1::l1 = h2::l2)
   
   [<A NAME="EVERY_APPEND-val"><B>EVERY_APPEND</B></A>]  Theorem
      
      |- !P l1 l2. EVERY P (l1 ++ l2) &lt;=&gt; EVERY P l1 /\ EVERY P l2
   
   [<A NAME="EVERY_CONG-val"><B>EVERY_CONG</B></A>]  Theorem
      
      |- !l1 l2 P P'.
           (l1 = l2) /\ (!x. MEM x l2 ==&gt; (P x &lt;=&gt; P' x)) ==&gt;
           (EVERY P l1 &lt;=&gt; EVERY P' l2)
   
   [<A NAME="EVERY_CONJ-val"><B>EVERY_CONJ</B></A>]  Theorem
      
      |- !l. EVERY (\x. P x /\ Q x) l &lt;=&gt; EVERY P l /\ EVERY Q l
   
   [<A NAME="EVERY_EL-val"><B>EVERY_EL</B></A>]  Theorem
      
      |- !l P. EVERY P l &lt;=&gt; !n. n &lt; LENGTH l ==&gt; P (EL n l)
   
   [<A NAME="EVERY_FILTER-val"><B>EVERY_FILTER</B></A>]  Theorem
      
      |- !P1 P2 l. EVERY P1 (FILTER P2 l) &lt;=&gt; EVERY (\x. P2 x ==&gt; P1 x) l
   
   [<A NAME="EVERY_MAP-val"><B>EVERY_MAP</B></A>]  Theorem
      
      |- !P f l. EVERY P (MAP f l) &lt;=&gt; EVERY (\x. P (f x)) l
   
   [<A NAME="EVERY_MEM-val"><B>EVERY_MEM</B></A>]  Theorem
      
      |- !P l. EVERY P l &lt;=&gt; !e. MEM e l ==&gt; P e
   
   [<A NAME="EVERY_MONOTONIC-val"><B>EVERY_MONOTONIC</B></A>]  Theorem
      
      |- !P Q. (!x. P x ==&gt; Q x) ==&gt; !l. EVERY P l ==&gt; EVERY Q l
   
   [<A NAME="EVERY_NOT_EXISTS-val"><B>EVERY_NOT_EXISTS</B></A>]  Theorem
      
      |- !P l. EVERY P l &lt;=&gt; ~EXISTS (\x. ~P x) l
   
   [<A NAME="EVERY_SIMP-val"><B>EVERY_SIMP</B></A>]  Theorem
      
      |- !c l. EVERY (\x. c) l &lt;=&gt; (l = []) \/ c
   
   [<A NAME="EXISTS_APPEND-val"><B>EXISTS_APPEND</B></A>]  Theorem
      
      |- !P l1 l2. EXISTS P (l1 ++ l2) &lt;=&gt; EXISTS P l1 \/ EXISTS P l2
   
   [<A NAME="EXISTS_CONG-val"><B>EXISTS_CONG</B></A>]  Theorem
      
      |- !l1 l2 P P'.
           (l1 = l2) /\ (!x. MEM x l2 ==&gt; (P x &lt;=&gt; P' x)) ==&gt;
           (EXISTS P l1 &lt;=&gt; EXISTS P' l2)
   
   [<A NAME="EXISTS_MAP-val"><B>EXISTS_MAP</B></A>]  Theorem
      
      |- !P f l. EXISTS P (MAP f l) &lt;=&gt; EXISTS (\x. P (f x)) l
   
   [<A NAME="EXISTS_MEM-val"><B>EXISTS_MEM</B></A>]  Theorem
      
      |- !P l. EXISTS P l &lt;=&gt; ?e. MEM e l /\ P e
   
   [<A NAME="EXISTS_NOT_EVERY-val"><B>EXISTS_NOT_EVERY</B></A>]  Theorem
      
      |- !P l. EXISTS P l &lt;=&gt; ~EVERY (\x. ~P x) l
   
   [<A NAME="EXISTS_SIMP-val"><B>EXISTS_SIMP</B></A>]  Theorem
      
      |- !c l. EXISTS (\x. c) l &lt;=&gt; l &lt;&gt; [] /\ c
   
   [<A NAME="FILTER_ALL_DISTINCT-val"><B>FILTER_ALL_DISTINCT</B></A>]  Theorem
      
      |- !P l. ALL_DISTINCT l ==&gt; ALL_DISTINCT (FILTER P l)
   
   [<A NAME="FILTER_APPEND_DISTRIB-val"><B>FILTER_APPEND_DISTRIB</B></A>]  Theorem
      
      |- !P L M. FILTER P (L ++ M) = FILTER P L ++ FILTER P M
   
   [<A NAME="FILTER_COND_REWRITE-val"><B>FILTER_COND_REWRITE</B></A>]  Theorem
      
      |- (FILTER P [] = []) /\
         (!h. P h ==&gt; (FILTER P (h::l) = h::FILTER P l)) /\
         !h. ~P h ==&gt; (FILTER P (h::l) = FILTER P l)
   
   [<A NAME="FILTER_EQ_APPEND-val"><B>FILTER_EQ_APPEND</B></A>]  Theorem
      
      |- !P l l1 l2.
           (FILTER P l = l1 ++ l2) &lt;=&gt;
           ?l3 l4.
             (l = l3 ++ l4) /\ (FILTER P l3 = l1) /\ (FILTER P l4 = l2)
   
   [<A NAME="FILTER_EQ_CONS-val"><B>FILTER_EQ_CONS</B></A>]  Theorem
      
      |- !P l h lr.
           (FILTER P l = h::lr) &lt;=&gt;
           ?l1 l2.
             (l = l1 ++ [h] ++ l2) /\ (FILTER P l1 = []) /\
             (FILTER P l2 = lr) /\ P h
   
   [<A NAME="FILTER_EQ_ID-val"><B>FILTER_EQ_ID</B></A>]  Theorem
      
      |- !P l. (FILTER P l = l) &lt;=&gt; EVERY P l
   
   [<A NAME="FILTER_EQ_NIL-val"><B>FILTER_EQ_NIL</B></A>]  Theorem
      
      |- !P l. (FILTER P l = []) &lt;=&gt; EVERY (\x. ~P x) l
   
   [<A NAME="FILTER_NEQ_ID-val"><B>FILTER_NEQ_ID</B></A>]  Theorem
      
      |- !P l. FILTER P l &lt;&gt; l &lt;=&gt; ?x. MEM x l /\ ~P x
   
   [<A NAME="FILTER_NEQ_NIL-val"><B>FILTER_NEQ_NIL</B></A>]  Theorem
      
      |- !P l. FILTER P l &lt;&gt; [] &lt;=&gt; ?x. MEM x l /\ P x
   
   [<A NAME="FINITE_LIST_TO_SET-val"><B>FINITE_LIST_TO_SET</B></A>]  Theorem
      
      |- !l. FINITE (set l)
   
   [<A NAME="FOLDL_CONG-val"><B>FOLDL_CONG</B></A>]  Theorem
      
      |- !l l' b b' f f'.
           (l = l') /\ (b = b') /\
           (!x a. MEM x l' ==&gt; (f a x = f' a x)) ==&gt;
           (FOLDL f b l = FOLDL f' b' l')
   
   [<A NAME="FOLDL_EQ_FOLDR-val"><B>FOLDL_EQ_FOLDR</B></A>]  Theorem
      
      |- !f l e. ASSOC f /\ COMM f ==&gt; (FOLDL f e l = FOLDR f e l)
   
   [<A NAME="FOLDR_CONG-val"><B>FOLDR_CONG</B></A>]  Theorem
      
      |- !l l' b b' f f'.
           (l = l') /\ (b = b') /\
           (!x a. MEM x l' ==&gt; (f x a = f' x a)) ==&gt;
           (FOLDR f b l = FOLDR f' b' l')
   
   [<A NAME="FORALL_LIST-val"><B>FORALL_LIST</B></A>]  Theorem
      
      |- (!l. P l) &lt;=&gt; P [] /\ !h t. P t ==&gt; P (h::t)
   
   [<A NAME="FRONT_CONS-val"><B>FRONT_CONS</B></A>]  Theorem
      
      |- (!x. FRONT [x] = []) /\ !x y z. FRONT (x::y::z) = x::FRONT (y::z)
   
   [<A NAME="IN_LIST_TO_SET-val"><B>IN_LIST_TO_SET</B></A>]  Theorem
      
      |- x IN set l &lt;=&gt; MEM x l
   
   [<A NAME="LAST_CONS-val"><B>LAST_CONS</B></A>]  Theorem
      
      |- (!x. LAST [x] = x) /\ !x y z. LAST (x::y::z) = LAST (y::z)
   
   [<A NAME="LENGTH_APPEND-val"><B>LENGTH_APPEND</B></A>]  Theorem
      
      |- !l1 l2. LENGTH (l1 ++ l2) = LENGTH l1 + LENGTH l2
   
   [<A NAME="LENGTH_CONS-val"><B>LENGTH_CONS</B></A>]  Theorem
      
      |- !l n. (LENGTH l = SUC n) &lt;=&gt; ?h l'. (LENGTH l' = n) /\ (l = h::l')
   
   [<A NAME="LENGTH_DROP-val"><B>LENGTH_DROP</B></A>]  Theorem
      
      |- !n. LENGTH (DROP n l) = LENGTH l - n
   
   [<A NAME="LENGTH_EQ_CONS-val"><B>LENGTH_EQ_CONS</B></A>]  Theorem
      
      |- !P n.
           (!l. (LENGTH l = SUC n) ==&gt; P l) &lt;=&gt;
           !l. (LENGTH l = n) ==&gt; (\l. !x. P (x::l)) l
   
   [<A NAME="LENGTH_EQ_NIL-val"><B>LENGTH_EQ_NIL</B></A>]  Theorem
      
      |- !P. (!l. (LENGTH l = 0) ==&gt; P l) &lt;=&gt; P []
   
   [<A NAME="LENGTH_LEN-val"><B>LENGTH_LEN</B></A>]  Theorem
      
      |- !L. LENGTH L = LEN L 0
   
   [<A NAME="LENGTH_MAP-val"><B>LENGTH_MAP</B></A>]  Theorem
      
      |- !l f. LENGTH (MAP f l) = LENGTH l
   
   [<A NAME="LENGTH_NIL-val"><B>LENGTH_NIL</B></A>]  Theorem
      
      |- !l. (LENGTH l = 0) &lt;=&gt; (l = [])
   
   [<A NAME="LENGTH_TAKE-val"><B>LENGTH_TAKE</B></A>]  Theorem
      
      |- !n. n &lt;= LENGTH l ==&gt; (LENGTH (TAKE n l) = n)
   
   [<A NAME="LENGTH_TL-val"><B>LENGTH_TL</B></A>]  Theorem
      
      |- !l. 0 &lt; LENGTH l ==&gt; (LENGTH (TL l) = LENGTH l - 1)
   
   [<A NAME="LENGTH_UNZIP-val"><B>LENGTH_UNZIP</B></A>]  Theorem
      
      |- !pl.
           (LENGTH (FST (UNZIP pl)) = LENGTH pl) /\
           (LENGTH (SND (UNZIP pl)) = LENGTH pl)
   
   [<A NAME="LENGTH_ZIP-val"><B>LENGTH_ZIP</B></A>]  Theorem
      
      |- !l1 l2.
           (LENGTH l1 = LENGTH l2) ==&gt;
           (LENGTH (ZIP (l1,l2)) = LENGTH l1) /\
           (LENGTH (ZIP (l1,l2)) = LENGTH l2)
   
   [<A NAME="LEN_LENGTH_LEM-val"><B>LEN_LENGTH_LEM</B></A>]  Theorem
      
      |- !L n. LEN L n = LENGTH L + n
   
   [<A NAME="LIST_EQ-val"><B>LIST_EQ</B></A>]  Theorem
      
      |- !l1 l2.
           (LENGTH l1 = LENGTH l2) /\
           (!x. x &lt; LENGTH l1 ==&gt; (EL x l1 = EL x l2)) ==&gt;
           (l1 = l2)
   
   [<A NAME="LIST_EQ_REWRITE-val"><B>LIST_EQ_REWRITE</B></A>]  Theorem
      
      |- !l1 l2.
           (l1 = l2) &lt;=&gt;
           (LENGTH l1 = LENGTH l2) /\
           !x. x &lt; LENGTH l1 ==&gt; (EL x l1 = EL x l2)
   
   [<A NAME="LIST_NOT_EQ-val"><B>LIST_NOT_EQ</B></A>]  Theorem
      
      |- !l1 l2. l1 &lt;&gt; l2 ==&gt; !h1 h2. h1::l1 &lt;&gt; h2::l2
   
   [<A NAME="LIST_TO_SET_APPEND-val"><B>LIST_TO_SET_APPEND</B></A>]  Theorem
      
      |- !l1 l2. set (l1 ++ l2) = set l1 UNION set l2
   
   [<A NAME="LIST_TO_SET_THM-val"><B>LIST_TO_SET_THM</B></A>]  Theorem
      
      |- (set [] = {}) /\ (set (h::t) = h INSERT set t)
   
   [<A NAME="MAP2_ZIP-val"><B>MAP2_ZIP</B></A>]  Theorem
      
      |- !l1 l2.
           (LENGTH l1 = LENGTH l2) ==&gt;
           !f. MAP2 f l1 l2 = MAP (UNCURRY f) (ZIP (l1,l2))
   
   [<A NAME="MAP_APPEND-val"><B>MAP_APPEND</B></A>]  Theorem
      
      |- !f l1 l2. MAP f (l1 ++ l2) = MAP f l1 ++ MAP f l2
   
   [<A NAME="MAP_CONG-val"><B>MAP_CONG</B></A>]  Theorem
      
      |- !l1 l2 f f'.
           (l1 = l2) /\ (!x. MEM x l2 ==&gt; (f x = f' x)) ==&gt;
           (MAP f l1 = MAP f' l2)
   
   [<A NAME="MAP_EQ_NIL-val"><B>MAP_EQ_NIL</B></A>]  Theorem
      
      |- !l f.
           ((MAP f l = []) &lt;=&gt; (l = [])) /\ (([] = MAP f l) &lt;=&gt; (l = []))
   
   [<A NAME="MEM_APPEND-val"><B>MEM_APPEND</B></A>]  Theorem
      
      |- !e l1 l2. MEM e (l1 ++ l2) &lt;=&gt; MEM e l1 \/ MEM e l2
   
   [<A NAME="MEM_EL-val"><B>MEM_EL</B></A>]  Theorem
      
      |- !l x. MEM x l &lt;=&gt; ?n. n &lt; LENGTH l /\ (x = EL n l)
   
   [<A NAME="MEM_FILTER-val"><B>MEM_FILTER</B></A>]  Theorem
      
      |- !P L x. MEM x (FILTER P L) &lt;=&gt; P x /\ MEM x L
   
   [<A NAME="MEM_FLAT-val"><B>MEM_FLAT</B></A>]  Theorem
      
      |- !x L. MEM x (FLAT L) &lt;=&gt; ?l. MEM l L /\ MEM x l
   
   [<A NAME="MEM_MAP-val"><B>MEM_MAP</B></A>]  Theorem
      
      |- !l f x. MEM x (MAP f l) &lt;=&gt; ?y. (x = f y) /\ MEM y l
   
   [<A NAME="MEM_REVERSE-val"><B>MEM_REVERSE</B></A>]  Theorem
      
      |- !l x. MEM x (REVERSE l) &lt;=&gt; MEM x l
   
   [<A NAME="MEM_SET_TO_LIST-val"><B>MEM_SET_TO_LIST</B></A>]  Theorem
      
      |- !s. FINITE s ==&gt; !x. MEM x (SET_TO_LIST s) &lt;=&gt; x IN s
   
   [<A NAME="MEM_SPLIT-val"><B>MEM_SPLIT</B></A>]  Theorem
      
      |- !x l. MEM x l &lt;=&gt; ?l1 l2. l = l1 ++ x::l2
   
   [<A NAME="MEM_ZIP-val"><B>MEM_ZIP</B></A>]  Theorem
      
      |- !l1 l2 p.
           (LENGTH l1 = LENGTH l2) ==&gt;
           (MEM p (ZIP (l1,l2)) &lt;=&gt;
            ?n. n &lt; LENGTH l1 /\ (p = (EL n l1,EL n l2)))
   
   [<A NAME="MONO_EVERY-val"><B>MONO_EVERY</B></A>]  Theorem
      
      |- (!x. P x ==&gt; Q x) ==&gt; EVERY P l ==&gt; EVERY Q l
   
   [<A NAME="MONO_EXISTS-val"><B>MONO_EXISTS</B></A>]  Theorem
      
      |- (!x. P x ==&gt; Q x) ==&gt; EXISTS P l ==&gt; EXISTS Q l
   
   [<A NAME="MONO_listRel-val"><B>MONO_listRel</B></A>]  Theorem
      
      |- (!x y. R x y ==&gt; R' x y) ==&gt; listRel R x y ==&gt; listRel R' x y
   
   [<A NAME="NOT_CONS_NIL-val"><B>NOT_CONS_NIL</B></A>]  Theorem
      
      |- !a1 a0. a0::a1 &lt;&gt; []
   
   [<A NAME="NOT_EQ_LIST-val"><B>NOT_EQ_LIST</B></A>]  Theorem
      
      |- !h1 h2. h1 &lt;&gt; h2 ==&gt; !l1 l2. h1::l1 &lt;&gt; h2::l2
   
   [<A NAME="NOT_EVERY-val"><B>NOT_EVERY</B></A>]  Theorem
      
      |- !P l. ~EVERY P l &lt;=&gt; EXISTS ($~ o P) l
   
   [<A NAME="NOT_EXISTS-val"><B>NOT_EXISTS</B></A>]  Theorem
      
      |- !P l. ~EXISTS P l &lt;=&gt; EVERY ($~ o P) l
   
   [<A NAME="NOT_NIL_CONS-val"><B>NOT_NIL_CONS</B></A>]  Theorem
      
      |- !a1 a0. [] &lt;&gt; a0::a1
   
   [<A NAME="NOT_NULL_MEM-val"><B>NOT_NULL_MEM</B></A>]  Theorem
      
      |- !l. ~NULL l &lt;=&gt; ?e. MEM e l
   
   [<A NAME="NULL-val"><B>NULL</B></A>]  Theorem
      
      |- NULL [] /\ !h t. ~NULL (h::t)
   
   [<A NAME="NULL_EQ-val"><B>NULL_EQ</B></A>]  Theorem
      
      |- !l. NULL l &lt;=&gt; (l = [])
   
   [<A NAME="NULL_LENGTH-val"><B>NULL_LENGTH</B></A>]  Theorem
      
      |- !l. NULL l &lt;=&gt; (LENGTH l = 0)
   
   [<A NAME="REVERSE_APPEND-val"><B>REVERSE_APPEND</B></A>]  Theorem
      
      |- !l1 l2. REVERSE (l1 ++ l2) = REVERSE l2 ++ REVERSE l1
   
   [<A NAME="REVERSE_REV-val"><B>REVERSE_REV</B></A>]  Theorem
      
      |- !L. REVERSE L = REV L []
   
   [<A NAME="REVERSE_REVERSE-val"><B>REVERSE_REVERSE</B></A>]  Theorem
      
      |- !l. REVERSE (REVERSE l) = l
   
   [<A NAME="REV_REVERSE_LEM-val"><B>REV_REVERSE_LEM</B></A>]  Theorem
      
      |- !L1 L2. REV L1 L2 = REVERSE L1 ++ L2
   
   [<A NAME="SET_TO_LIST_CARD-val"><B>SET_TO_LIST_CARD</B></A>]  Theorem
      
      |- !s. FINITE s ==&gt; (LENGTH (SET_TO_LIST s) = CARD s)
   
   [<A NAME="SET_TO_LIST_IND-val"><B>SET_TO_LIST_IND</B></A>]  Theorem
      
      |- !P. (!s. (FINITE s /\ s &lt;&gt; {} ==&gt; P (REST s)) ==&gt; P s) ==&gt; !v. P v
   
   [<A NAME="SET_TO_LIST_INV-val"><B>SET_TO_LIST_INV</B></A>]  Theorem
      
      |- !s. FINITE s ==&gt; (set (SET_TO_LIST s) = s)
   
   [<A NAME="SET_TO_LIST_IN_MEM-val"><B>SET_TO_LIST_IN_MEM</B></A>]  Theorem
      
      |- !s. FINITE s ==&gt; !x. x IN s &lt;=&gt; MEM x (SET_TO_LIST s)
   
   [<A NAME="SET_TO_LIST_SING-val"><B>SET_TO_LIST_SING</B></A>]  Theorem
      
      |- SET_TO_LIST {x} = [x]
   
   [<A NAME="SET_TO_LIST_THM-val"><B>SET_TO_LIST_THM</B></A>]  Theorem
      
      |- FINITE s ==&gt;
         (SET_TO_LIST s =
          if s = {} then [] else CHOICE s::SET_TO_LIST (REST s))
   
   [<A NAME="TAKE_0-val"><B>TAKE_0</B></A>]  Theorem
      
      |- TAKE 0 l = []
   
   [<A NAME="TAKE_APPEND1-val"><B>TAKE_APPEND1</B></A>]  Theorem
      
      |- !n. n &lt;= LENGTH l1 ==&gt; (TAKE n (l1 ++ l2) = TAKE n l1)
   
   [<A NAME="TAKE_APPEND2-val"><B>TAKE_APPEND2</B></A>]  Theorem
      
      |- !n.
           LENGTH l1 &lt; n ==&gt;
           (TAKE n (l1 ++ l2) = l1 ++ TAKE (n - LENGTH l1) l2)
   
   [<A NAME="TAKE_DROP-val"><B>TAKE_DROP</B></A>]  Theorem
      
      |- !n. TAKE n l ++ DROP n l = l
   
   [<A NAME="TAKE_LENGTH_ID-val"><B>TAKE_LENGTH_ID</B></A>]  Theorem
      
      |- TAKE (LENGTH l) l = l
   
   [<A NAME="UNION_APPEND-val"><B>UNION_APPEND</B></A>]  Theorem
      
      |- !l1 l2. set l1 UNION set l2 = set (l1 ++ l2)
   
   [<A NAME="UNZIP_THM-val"><B>UNZIP_THM</B></A>]  Theorem
      
      |- (UNZIP [] = ([],[])) /\
         (UNZIP ((x,y)::t) = (let (L1,L2) = UNZIP t in (x::L1,y::L2)))
   
   [<A NAME="UNZIP_ZIP-val"><B>UNZIP_ZIP</B></A>]  Theorem
      
      |- !l1 l2.
           (LENGTH l1 = LENGTH l2) ==&gt; (UNZIP (ZIP (l1,l2)) = (l1,l2))
   
   [<A NAME="WF_LIST_PRED-val"><B>WF_LIST_PRED</B></A>]  Theorem
      
      |- WF (\L1 L2. ?h. L2 = h::L1)
   
   [<A NAME="ZIP_MAP-val"><B>ZIP_MAP</B></A>]  Theorem
      
      |- !l1 l2 f1 f2.
           (LENGTH l1 = LENGTH l2) ==&gt;
           (ZIP (MAP f1 l1,l2) =
            MAP (\p. (f1 (FST p),SND p)) (ZIP (l1,l2))) /\
           (ZIP (l1,MAP f2 l2) =
            MAP (\p. (FST p,f2 (SND p))) (ZIP (l1,l2)))
   
   [<A NAME="ZIP_UNZIP-val"><B>ZIP_UNZIP</B></A>]  Theorem
      
      |- !l. ZIP (UNZIP l) = l
   
   [<A NAME="datatype_list-val"><B>datatype_list</B></A>]  Theorem
      
      |- DATATYPE (list [] CONS)
   
   [<A NAME="isPREFIX_THM-val"><B>isPREFIX_THM</B></A>]  Theorem
      
      |- ([] &lt;&lt;= l &lt;=&gt; T) /\ (h::t &lt;&lt;= [] &lt;=&gt; F) /\
         (h1::t1 &lt;&lt;= h2::t2 &lt;=&gt; (h1 = h2) /\ t1 &lt;&lt;= t2)
   
   [<A NAME="listRel_CONS-val"><B>listRel_CONS</B></A>]  Theorem
      
      |- (listRel R (h::t) y &lt;=&gt;
          ?h' t'. (y = h'::t') /\ R h h' /\ listRel R t t') /\
         (listRel R x (h'::t') &lt;=&gt;
          ?h t. (x = h::t) /\ R h h' /\ listRel R t t')
   
   [<A NAME="listRel_LENGTH-val"><B>listRel_LENGTH</B></A>]  Theorem
      
      |- !x y. listRel R x y ==&gt; (LENGTH x = LENGTH y)
   
   [<A NAME="listRel_NIL-val"><B>listRel_NIL</B></A>]  Theorem
      
      |- (listRel R [] y &lt;=&gt; (y = [])) /\ (listRel R x [] &lt;=&gt; (x = []))
   
   [<A NAME="listRel_cases-val"><B>listRel_cases</B></A>]  Theorem
      
      |- !R a0 a1.
           listRel R a0 a1 &lt;=&gt;
           (a0 = []) /\ (a1 = []) \/
           ?h1 h2 t1 t2.
             (a0 = h1::t1) /\ (a1 = h2::t2) /\ R h1 h2 /\ listRel R t1 t2
   
   [<A NAME="listRel_ind-val"><B>listRel_ind</B></A>]  Theorem
      
      |- !R listRel'.
           listRel' [] [] /\
           (!h1 h2 t1 t2.
              R h1 h2 /\ listRel' t1 t2 ==&gt; listRel' (h1::t1) (h2::t2)) ==&gt;
           !a0 a1. listRel R a0 a1 ==&gt; listRel' a0 a1
   
   [<A NAME="listRel_rules-val"><B>listRel_rules</B></A>]  Theorem
      
      |- !R.
           listRel R [] [] /\
           !h1 h2 t1 t2.
             R h1 h2 /\ listRel R t1 t2 ==&gt; listRel R (h1::t1) (h2::t2)
   
   [<A NAME="listRel_strong_ind-val"><B>listRel_strong_ind</B></A>]  Theorem
      
      |- !R listRel'.
           listRel' [] [] /\
           (!h1 h2 t1 t2.
              R h1 h2 /\ listRel R t1 t2 /\ listRel' t1 t2 ==&gt;
              listRel' (h1::t1) (h2::t2)) ==&gt;
           !a0 a1. listRel R a0 a1 ==&gt; listRel' a0 a1
   
   [<A NAME="list_11-val"><B>list_11</B></A>]  Theorem
      
      |- !a0 a1 a0' a1'. (a0::a1 = a0'::a1') &lt;=&gt; (a0 = a0') /\ (a1 = a1')
   
   [<A NAME="list_Axiom-val"><B>list_Axiom</B></A>]  Theorem
      
      |- !f0 f1.
           ?fn. (fn [] = f0) /\ !a0 a1. fn (a0::a1) = f1 a0 a1 (fn a1)
   
   [<A NAME="list_Axiom_old-val"><B>list_Axiom_old</B></A>]  Theorem
      
      |- !x f. ?!fn1. (fn1 [] = x) /\ !h t. fn1 (h::t) = f (fn1 t) h t
   
   [<A NAME="list_CASES-val"><B>list_CASES</B></A>]  Theorem
      
      |- !l. (l = []) \/ ?t h. l = h::t
   
   [<A NAME="list_INDUCT-val"><B>list_INDUCT</B></A>]  Theorem
      
      |- !P. P [] /\ (!t. P t ==&gt; !h. P (h::t)) ==&gt; !l. P l
   
   [<A NAME="list_case_compute-val"><B>list_case_compute</B></A>]  Theorem
      
      |- !l. list_case b f l = if NULL l then b else f (HD l) (TL l)
   
   [<A NAME="list_case_cong-val"><B>list_case_cong</B></A>]  Theorem
      
      |- !M M' v f.
           (M = M') /\ ((M' = []) ==&gt; (v = v')) /\
           (!a0 a1. (M' = a0::a1) ==&gt; (f a0 a1 = f' a0 a1)) ==&gt;
           (list_case v f M = list_case v' f' M')
   
   [<A NAME="list_distinct-val"><B>list_distinct</B></A>]  Theorem
      
      |- !a1 a0. [] &lt;&gt; a0::a1
   
   [<A NAME="list_induction-val"><B>list_induction</B></A>]  Theorem
      
      |- !P. P [] /\ (!t. P t ==&gt; !h. P (h::t)) ==&gt; !l. P l
   
   [<A NAME="list_nchotomy-val"><B>list_nchotomy</B></A>]  Theorem
      
      |- !l. (l = []) \/ ?t h. l = h::t
   
   [<A NAME="list_size_cong-val"><B>list_size_cong</B></A>]  Theorem
      
      |- !M N f f'.
           (M = N) /\ (!x. MEM x N ==&gt; (f x = f' x)) ==&gt;
           (list_size f M = list_size f' N)
   
   
*)
end

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/list/src/listScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
