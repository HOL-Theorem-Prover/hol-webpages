<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure fcpTheory</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure fcpTheory</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/n-bit/fcpScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>signature fcpTheory =
<A NAME="line2"></A>sig
<A NAME="line3"></A>  type thm = Thm.thm
<A NAME="line4"></A>  
<A NAME="line5"></A>  (*  Definitions  *)
<A NAME="line6"></A>    val <A HREF="#EQUAL_def-val">EQUAL_def</A> : thm
<A NAME="line7"></A>    val <A HREF="#FCP-val">FCP</A> : thm
<A NAME="line8"></A>    val <A HREF="#FCP_CONS_def-val">FCP_CONS_def</A> : thm
<A NAME="line9"></A>    val <A HREF="#FCP_EVERY_def-val">FCP_EVERY_def</A> : thm
<A NAME="line10"></A>    val <A HREF="#FCP_EXISTS_def-val">FCP_EXISTS_def</A> : thm
<A NAME="line11"></A>    val <A HREF="#FCP_HD_def-val">FCP_HD_def</A> : thm
<A NAME="line12"></A>    val <A HREF="#FCP_MAP_def-val">FCP_MAP_def</A> : thm
<A NAME="line13"></A>    val <A HREF="#FCP_TL_def-val">FCP_TL_def</A> : thm
<A NAME="line14"></A>    val <A HREF="#FCP_UPDATE_def-val">FCP_UPDATE_def</A> : thm
<A NAME="line15"></A>    val <A HREF="#HAS_SIZE_def-val">HAS_SIZE_def</A> : thm
<A NAME="line16"></A>    val <A HREF="#IS_BIT0A_def-val">IS_BIT0A_def</A> : thm
<A NAME="line17"></A>    val <A HREF="#IS_BIT0B_def-val">IS_BIT0B_def</A> : thm
<A NAME="line18"></A>    val <A HREF="#IS_BIT1A_def-val">IS_BIT1A_def</A> : thm
<A NAME="line19"></A>    val <A HREF="#IS_BIT1B_def-val">IS_BIT1B_def</A> : thm
<A NAME="line20"></A>    val <A HREF="#IS_BIT1C_def-val">IS_BIT1C_def</A> : thm
<A NAME="line21"></A>    val <A HREF="#L2V_def-val">L2V_def</A> : thm
<A NAME="line22"></A>    val <A HREF="#V2L_def-val">V2L_def</A> : thm
<A NAME="line23"></A>    val <A HREF="#abs_sub1_def-val">abs_sub1_def</A> : thm
<A NAME="line24"></A>    val <A HREF="#bit0_TY_DEF-val">bit0_TY_DEF</A> : thm
<A NAME="line25"></A>    val <A HREF="#bit0_case_def-val">bit0_case_def</A> : thm
<A NAME="line26"></A>    val <A HREF="#bit0_repfns-val">bit0_repfns</A> : thm
<A NAME="line27"></A>    val <A HREF="#bit0_size_def-val">bit0_size_def</A> : thm
<A NAME="line28"></A>    val <A HREF="#bit1_TY_DEF-val">bit1_TY_DEF</A> : thm
<A NAME="line29"></A>    val <A HREF="#bit1_case_def-val">bit1_case_def</A> : thm
<A NAME="line30"></A>    val <A HREF="#bit1_repfns-val">bit1_repfns</A> : thm
<A NAME="line31"></A>    val <A HREF="#bit1_size_def-val">bit1_size_def</A> : thm
<A NAME="line32"></A>    val <A HREF="#cart_TY_DEF-val">cart_TY_DEF</A> : thm
<A NAME="line33"></A>    val <A HREF="#cart_tybij-val">cart_tybij</A> : thm
<A NAME="line34"></A>    val <A HREF="#dimindex_def-val">dimindex_def</A> : thm
<A NAME="line35"></A>    val <A HREF="#fcp_case_def-val">fcp_case_def</A> : thm
<A NAME="line36"></A>    val <A HREF="#fcp_index-val">fcp_index</A> : thm
<A NAME="line37"></A>    val <A HREF="#finite_image_TY_DEF-val">finite_image_TY_DEF</A> : thm
<A NAME="line38"></A>    val <A HREF="#finite_image_tybij-val">finite_image_tybij</A> : thm
<A NAME="line39"></A>    val <A HREF="#finite_index_def-val">finite_index_def</A> : thm
<A NAME="line40"></A>    val <A HREF="#rep_sub1_def-val">rep_sub1_def</A> : thm
<A NAME="line41"></A>    val <A HREF="#sub1_TY_DEF-val">sub1_TY_DEF</A> : thm
<A NAME="line42"></A>    val <A HREF="#sub1_bijections-val">sub1_bijections</A> : thm
<A NAME="line43"></A>    val <A HREF="#sub_equiv_def-val">sub_equiv_def</A> : thm
<A NAME="line44"></A>  
<A NAME="line45"></A>  (*  Theorems  *)
<A NAME="line46"></A>    val <A HREF="#APPLY_FCP_UPDATE_ID-val">APPLY_FCP_UPDATE_ID</A> : thm
<A NAME="line47"></A>    val <A HREF="#CART_EQ-val">CART_EQ</A> : thm
<A NAME="line48"></A>    val <A HREF="#DIMINDEX_GE_1-val">DIMINDEX_GE_1</A> : thm
<A NAME="line49"></A>    val <A HREF="#EL_V2L-val">EL_V2L</A> : thm
<A NAME="line50"></A>    val <A HREF="#FCP_APPLY_UPDATE_THM-val">FCP_APPLY_UPDATE_THM</A> : thm
<A NAME="line51"></A>    val <A HREF="#FCP_BETA-val">FCP_BETA</A> : thm
<A NAME="line52"></A>    val <A HREF="#FCP_CONS-val">FCP_CONS</A> : thm
<A NAME="line53"></A>    val <A HREF="#FCP_ETA-val">FCP_ETA</A> : thm
<A NAME="line54"></A>    val <A HREF="#FCP_EVERY-val">FCP_EVERY</A> : thm
<A NAME="line55"></A>    val <A HREF="#FCP_EXISTS-val">FCP_EXISTS</A> : thm
<A NAME="line56"></A>    val <A HREF="#FCP_HD-val">FCP_HD</A> : thm
<A NAME="line57"></A>    val <A HREF="#FCP_MAP-val">FCP_MAP</A> : thm
<A NAME="line58"></A>    val <A HREF="#FCP_TL-val">FCP_TL</A> : thm
<A NAME="line59"></A>    val <A HREF="#FCP_UPDATE_COMMUTES-val">FCP_UPDATE_COMMUTES</A> : thm
<A NAME="line60"></A>    val <A HREF="#FCP_UPDATE_EQ-val">FCP_UPDATE_EQ</A> : thm
<A NAME="line61"></A>    val <A HREF="#FCP_UPDATE_IMP_ID-val">FCP_UPDATE_IMP_ID</A> : thm
<A NAME="line62"></A>    val <A HREF="#INDEX_SUB1-val">INDEX_SUB1</A> : thm
<A NAME="line63"></A>    val <A HREF="#LENGTH_V2L-val">LENGTH_V2L</A> : thm
<A NAME="line64"></A>    val <A HREF="#LISTS_EQ-val">LISTS_EQ</A> : thm
<A NAME="line65"></A>    val <A HREF="#NULL_V2L-val">NULL_V2L</A> : thm
<A NAME="line66"></A>    val <A HREF="#READ_L2V-val">READ_L2V</A> : thm
<A NAME="line67"></A>    val <A HREF="#READ_TL-val">READ_TL</A> : thm
<A NAME="line68"></A>    val <A HREF="#V2L_L2V-val">V2L_L2V</A> : thm
<A NAME="line69"></A>    val <A HREF="#V2L_RECURSIVE-val">V2L_RECURSIVE</A> : thm
<A NAME="line70"></A>    val <A HREF="#bit0_11-val">bit0_11</A> : thm
<A NAME="line71"></A>    val <A HREF="#bit0_Axiom-val">bit0_Axiom</A> : thm
<A NAME="line72"></A>    val <A HREF="#bit0_case_cong-val">bit0_case_cong</A> : thm
<A NAME="line73"></A>    val <A HREF="#bit0_distinct-val">bit0_distinct</A> : thm
<A NAME="line74"></A>    val <A HREF="#bit0_induction-val">bit0_induction</A> : thm
<A NAME="line75"></A>    val <A HREF="#bit0_nchotomy-val">bit0_nchotomy</A> : thm
<A NAME="line76"></A>    val <A HREF="#bit1_11-val">bit1_11</A> : thm
<A NAME="line77"></A>    val <A HREF="#bit1_Axiom-val">bit1_Axiom</A> : thm
<A NAME="line78"></A>    val <A HREF="#bit1_case_cong-val">bit1_case_cong</A> : thm
<A NAME="line79"></A>    val <A HREF="#bit1_distinct-val">bit1_distinct</A> : thm
<A NAME="line80"></A>    val <A HREF="#bit1_induction-val">bit1_induction</A> : thm
<A NAME="line81"></A>    val <A HREF="#bit1_nchotomy-val">bit1_nchotomy</A> : thm
<A NAME="line82"></A>    val <A HREF="#card_dimindex-val">card_dimindex</A> : thm
<A NAME="line83"></A>    val <A HREF="#datatype_bit0-val">datatype_bit0</A> : thm
<A NAME="line84"></A>    val <A HREF="#datatype_bit1-val">datatype_bit1</A> : thm
<A NAME="line85"></A>    val <A HREF="#dimindex-val">dimindex</A> : thm
<A NAME="line86"></A>    val <A HREF="#exists_v2l_thm-val">exists_v2l_thm</A> : thm
<A NAME="line87"></A>    val <A HREF="#fcp_Axiom-val">fcp_Axiom</A> : thm
<A NAME="line88"></A>    val <A HREF="#fcp_ind-val">fcp_ind</A> : thm
<A NAME="line89"></A>    val <A HREF="#fcp_subst_comp-val">fcp_subst_comp</A> : thm
<A NAME="line90"></A>    val <A HREF="#finite_bit0-val">finite_bit0</A> : thm
<A NAME="line91"></A>    val <A HREF="#finite_bit1-val">finite_bit1</A> : thm
<A NAME="line92"></A>    val <A HREF="#finite_one-val">finite_one</A> : thm
<A NAME="line93"></A>    val <A HREF="#finite_sub1-val">finite_sub1</A> : thm
<A NAME="line94"></A>    val <A HREF="#finite_sum-val">finite_sum</A> : thm
<A NAME="line95"></A>    val <A HREF="#index_bit0-val">index_bit0</A> : thm
<A NAME="line96"></A>    val <A HREF="#index_bit1-val">index_bit1</A> : thm
<A NAME="line97"></A>    val <A HREF="#index_comp-val">index_comp</A> : thm
<A NAME="line98"></A>    val <A HREF="#index_one-val">index_one</A> : thm
<A NAME="line99"></A>    val <A HREF="#index_sum-val">index_sum</A> : thm
<A NAME="line100"></A>    val <A HREF="#sub1_ABS_REP_CLASS-val">sub1_ABS_REP_CLASS</A> : thm
<A NAME="line101"></A>    val <A HREF="#sub1_QUOTIENT-val">sub1_QUOTIENT</A> : thm
<A NAME="line102"></A>  
<A NAME="line103"></A>  val fcp_grammars : type_grammar.grammar * term_grammar.grammar
<A NAME="line104"></A>  
<A NAME="line105"></A>  
<A NAME="line106"></A>(*
   [quotient_list] Parent theory of "fcp"
   
   [quotient_option] Parent theory of "fcp"
   
   [quotient_pair] Parent theory of "fcp"
   
   [quotient_sum] Parent theory of "fcp"
   
   [<A NAME="EQUAL_def-val"><B>EQUAL_def</B></A>]  Definition
      
      |- EQUAL = {CHOICE UNIV; CHOICE (REST UNIV)}
   
   [<A NAME="FCP-val"><B>FCP</B></A>]  Definition
      
      |- $FCP = (\g. @f. !i. i &lt; dimindex (:'b) ==&gt; (f ' i = g i))
   
   [<A NAME="FCP_CONS_def-val"><B>FCP_CONS_def</B></A>]  Definition
      
      |- !h v. FCP_CONS h v = (0 :+ h) (FCP i. v ' (PRE i))
   
   [<A NAME="FCP_EVERY_def-val"><B>FCP_EVERY_def</B></A>]  Definition
      
      |- !P v. FCP_EVERY P v &lt;=&gt; !i. dimindex (:'a) &lt;= i \/ P (v ' i)
   
   [<A NAME="FCP_EXISTS_def-val"><B>FCP_EXISTS_def</B></A>]  Definition
      
      |- !P v. FCP_EXISTS P v &lt;=&gt; ?i. i &lt; dimindex (:'a) /\ P (v ' i)
   
   [<A NAME="FCP_HD_def-val"><B>FCP_HD_def</B></A>]  Definition
      
      |- !v. FCP_HD v = v ' 0
   
   [<A NAME="FCP_MAP_def-val"><B>FCP_MAP_def</B></A>]  Definition
      
      |- !f v. FCP_MAP f v = FCP i. f (v ' i)
   
   [<A NAME="FCP_TL_def-val"><B>FCP_TL_def</B></A>]  Definition
      
      |- !v. FCP_TL v = FCP i. v ' (SUC i)
   
   [<A NAME="FCP_UPDATE_def-val"><B>FCP_UPDATE_def</B></A>]  Definition
      
      |- !a b. a :+ b = (\m. FCP c. if a = c then b else m ' c)
   
   [<A NAME="HAS_SIZE_def-val"><B>HAS_SIZE_def</B></A>]  Definition
      
      |- !s n. (s HAS_SIZE n) &lt;=&gt; FINITE s /\ (CARD s = n)
   
   [<A NAME="IS_BIT0A_def-val"><B>IS_BIT0A_def</B></A>]  Definition
      
      |- (!x. IS_BIT0A (BIT0A x) &lt;=&gt; T) /\ !x. IS_BIT0A (BIT0B x) &lt;=&gt; F
   
   [<A NAME="IS_BIT0B_def-val"><B>IS_BIT0B_def</B></A>]  Definition
      
      |- (!x. IS_BIT0B (BIT0A x) &lt;=&gt; F) /\ !x. IS_BIT0B (BIT0B x) &lt;=&gt; T
   
   [<A NAME="IS_BIT1A_def-val"><B>IS_BIT1A_def</B></A>]  Definition
      
      |- (!x. IS_BIT1A (BIT1A x) &lt;=&gt; T) /\
         (!x. IS_BIT1A (BIT1B x) &lt;=&gt; F) /\ (IS_BIT1A BIT1C &lt;=&gt; F)
   
   [<A NAME="IS_BIT1B_def-val"><B>IS_BIT1B_def</B></A>]  Definition
      
      |- (!x. IS_BIT1B (BIT1A x) &lt;=&gt; F) /\
         (!x. IS_BIT1B (BIT1B x) &lt;=&gt; T) /\ (IS_BIT1B BIT1C &lt;=&gt; F)
   
   [<A NAME="IS_BIT1C_def-val"><B>IS_BIT1C_def</B></A>]  Definition
      
      |- (!x. IS_BIT1C (BIT1A x) &lt;=&gt; F) /\
         (!x. IS_BIT1C (BIT1B x) &lt;=&gt; F) /\ (IS_BIT1C BIT1C &lt;=&gt; T)
   
   [<A NAME="L2V_def-val"><B>L2V_def</B></A>]  Definition
      
      |- !L. L2V L = FCP i. EL i L
   
   [<A NAME="V2L_def-val"><B>V2L_def</B></A>]  Definition
      
      |- !v.
           V2L v =
           @L.
             (LENGTH L = dimindex (:'b)) /\
             !i. i &lt; dimindex (:'b) ==&gt; (EL i L = v ' i)
   
   [<A NAME="abs_sub1_def-val"><B>abs_sub1_def</B></A>]  Definition
      
      |- !r. abs_sub1 r = abs_sub1_CLASS (sub_equiv r)
   
   [<A NAME="bit0_TY_DEF-val"><B>bit0_TY_DEF</B></A>]  Definition
      
      |- ?rep.
           TYPE_DEFINITION
             (\a0.
                !'bit0' .
                  (!a0.
                     (?a.
                        a0 =
                        (\a. ind_type$CONSTR 0 a (\n. ind_type$BOTTOM))
                          a) \/
                     (?a.
                        a0 =
                        (\a.
                           ind_type$CONSTR (SUC 0) a (\n. ind_type$BOTTOM))
                          a) ==&gt;
                     'bit0' a0) ==&gt;
                  'bit0' a0) rep
   
   [<A NAME="bit0_case_def-val"><B>bit0_case_def</B></A>]  Definition
      
      |- (!f f1 a. bit0_case f f1 (BIT0A a) = f a) /\
         !f f1 a. bit0_case f f1 (BIT0B a) = f1 a
   
   [<A NAME="bit0_repfns-val"><B>bit0_repfns</B></A>]  Definition
      
      |- (!a. mk_bit0 (dest_bit0 a) = a) /\
         !r.
           (\a0.
              !'bit0' .
                (!a0.
                   (?a.
                      a0 =
                      (\a. ind_type$CONSTR 0 a (\n. ind_type$BOTTOM)) a) \/
                   (?a.
                      a0 =
                      (\a. ind_type$CONSTR (SUC 0) a (\n. ind_type$BOTTOM))
                        a) ==&gt;
                   'bit0' a0) ==&gt;
                'bit0' a0) r &lt;=&gt; (dest_bit0 (mk_bit0 r) = r)
   
   [<A NAME="bit0_size_def-val"><B>bit0_size_def</B></A>]  Definition
      
      |- (!f a. bit0_size f (BIT0A a) = 1 + f a) /\
         !f a. bit0_size f (BIT0B a) = 1 + f a
   
   [<A NAME="bit1_TY_DEF-val"><B>bit1_TY_DEF</B></A>]  Definition
      
      |- ?rep.
           TYPE_DEFINITION
             (\a0.
                !'bit1' .
                  (!a0.
                     (?a.
                        a0 =
                        (\a. ind_type$CONSTR 0 a (\n. ind_type$BOTTOM))
                          a) \/
                     (?a.
                        a0 =
                        (\a.
                           ind_type$CONSTR (SUC 0) a (\n. ind_type$BOTTOM))
                          a) \/
                     (a0 =
                      ind_type$CONSTR (SUC (SUC 0)) ARB
                        (\n. ind_type$BOTTOM)) ==&gt;
                     'bit1' a0) ==&gt;
                  'bit1' a0) rep
   
   [<A NAME="bit1_case_def-val"><B>bit1_case_def</B></A>]  Definition
      
      |- (!f f1 v a. bit1_case f f1 v (BIT1A a) = f a) /\
         (!f f1 v a. bit1_case f f1 v (BIT1B a) = f1 a) /\
         !f f1 v. bit1_case f f1 v BIT1C = v
   
   [<A NAME="bit1_repfns-val"><B>bit1_repfns</B></A>]  Definition
      
      |- (!a. mk_bit1 (dest_bit1 a) = a) /\
         !r.
           (\a0.
              !'bit1' .
                (!a0.
                   (?a.
                      a0 =
                      (\a. ind_type$CONSTR 0 a (\n. ind_type$BOTTOM)) a) \/
                   (?a.
                      a0 =
                      (\a. ind_type$CONSTR (SUC 0) a (\n. ind_type$BOTTOM))
                        a) \/
                   (a0 =
                    ind_type$CONSTR (SUC (SUC 0)) ARB
                      (\n. ind_type$BOTTOM)) ==&gt;
                   'bit1' a0) ==&gt;
                'bit1' a0) r &lt;=&gt; (dest_bit1 (mk_bit1 r) = r)
   
   [<A NAME="bit1_size_def-val"><B>bit1_size_def</B></A>]  Definition
      
      |- (!f a. bit1_size f (BIT1A a) = 1 + f a) /\
         (!f a. bit1_size f (BIT1B a) = 1 + f a) /\
         !f. bit1_size f BIT1C = 0
   
   [<A NAME="cart_TY_DEF-val"><B>cart_TY_DEF</B></A>]  Definition
      
      |- ?rep. TYPE_DEFINITION (\f. T) rep
   
   [<A NAME="cart_tybij-val"><B>cart_tybij</B></A>]  Definition
      
      |- (!a. mk_cart (dest_cart a) = a) /\
         !r. (\f. T) r &lt;=&gt; (dest_cart (mk_cart r) = r)
   
   [<A NAME="dimindex_def-val"><B>dimindex_def</B></A>]  Definition
      
      |- dimindex (:'a) = if FINITE UNIV then CARD UNIV else 1
   
   [<A NAME="fcp_case_def-val"><B>fcp_case_def</B></A>]  Definition
      
      |- !f' h. fcp_case f' (mk_cart h) = f' h
   
   [<A NAME="fcp_index-val"><B>fcp_index</B></A>]  Definition
      
      |- !x i. x ' i = dest_cart x (finite_index i)
   
   [<A NAME="finite_image_TY_DEF-val"><B>finite_image_TY_DEF</B></A>]  Definition
      
      |- ?rep. TYPE_DEFINITION (\x. (x = ARB) \/ FINITE UNIV) rep
   
   [<A NAME="finite_image_tybij-val"><B>finite_image_tybij</B></A>]  Definition
      
      |- (!a. mk_finite_image (dest_finite_image a) = a) /\
         !r.
           (\x. (x = ARB) \/ FINITE UNIV) r &lt;=&gt;
           (dest_finite_image (mk_finite_image r) = r)
   
   [<A NAME="finite_index_def-val"><B>finite_index_def</B></A>]  Definition
      
      |- finite_index = @f. !x. ?!n. n &lt; dimindex (:'a) /\ (f n = x)
   
   [<A NAME="rep_sub1_def-val"><B>rep_sub1_def</B></A>]  Definition
      
      |- !a. rep_sub1 a = $@ (rep_sub1_CLASS a)
   
   [<A NAME="sub1_TY_DEF-val"><B>sub1_TY_DEF</B></A>]  Definition
      
      |- ?rep.
           TYPE_DEFINITION (\c. ?r. sub_equiv r r /\ (c = sub_equiv r)) rep
   
   [<A NAME="sub1_bijections-val"><B>sub1_bijections</B></A>]  Definition
      
      |- (!a. abs_sub1_CLASS (rep_sub1_CLASS a) = a) /\
         !r.
           (\c. ?r. sub_equiv r r /\ (c = sub_equiv r)) r &lt;=&gt;
           (rep_sub1_CLASS (abs_sub1_CLASS r) = r)
   
   [<A NAME="sub_equiv_def-val"><B>sub_equiv_def</B></A>]  Definition
      
      |- !a b. sub_equiv a b &lt;=&gt; a IN EQUAL /\ b IN EQUAL \/ (a = b)
   
   [<A NAME="APPLY_FCP_UPDATE_ID-val"><B>APPLY_FCP_UPDATE_ID</B></A>]  Theorem
      
      |- !m a. (a :+ m ' a) m = m
   
   [<A NAME="CART_EQ-val"><B>CART_EQ</B></A>]  Theorem
      
      |- !x y. (x = y) &lt;=&gt; !i. i &lt; dimindex (:'b) ==&gt; (x ' i = y ' i)
   
   [<A NAME="DIMINDEX_GE_1-val"><B>DIMINDEX_GE_1</B></A>]  Theorem
      
      |- 1 &lt;= dimindex (:'a)
   
   [<A NAME="EL_V2L-val"><B>EL_V2L</B></A>]  Theorem
      
      |- i &lt; dimindex (:'b) ==&gt; (EL i (V2L v) = v ' i)
   
   [<A NAME="FCP_APPLY_UPDATE_THM-val"><B>FCP_APPLY_UPDATE_THM</B></A>]  Theorem
      
      |- !m a w b.
           (a :+ w) m ' b =
           if b &lt; dimindex (:'b) then
             if a = b then w else m ' b
           else
             (a :+ w) m ' b
   
   [<A NAME="FCP_BETA-val"><B>FCP_BETA</B></A>]  Theorem
      
      |- !i. i &lt; dimindex (:'b) ==&gt; ($FCP g ' i = g i)
   
   [<A NAME="FCP_CONS-val"><B>FCP_CONS</B></A>]  Theorem
      
      |- FCP_CONS a v = L2V (a::V2L v)
   
   [<A NAME="FCP_ETA-val"><B>FCP_ETA</B></A>]  Theorem
      
      |- !g. (FCP i. g ' i) = g
   
   [<A NAME="FCP_EVERY-val"><B>FCP_EVERY</B></A>]  Theorem
      
      |- FCP_EVERY P v &lt;=&gt; EVERY P (V2L v)
   
   [<A NAME="FCP_EXISTS-val"><B>FCP_EXISTS</B></A>]  Theorem
      
      |- FCP_EXISTS P v &lt;=&gt; EXISTS P (V2L v)
   
   [<A NAME="FCP_HD-val"><B>FCP_HD</B></A>]  Theorem
      
      |- FCP_HD v = HD (V2L v)
   
   [<A NAME="FCP_MAP-val"><B>FCP_MAP</B></A>]  Theorem
      
      |- FCP_MAP f v = L2V (MAP f (V2L v))
   
   [<A NAME="FCP_TL-val"><B>FCP_TL</B></A>]  Theorem
      
      |- 1 &lt; dimindex (:'b) ==&gt; (FCP_TL v = L2V (TL (V2L v)))
   
   [<A NAME="FCP_UPDATE_COMMUTES-val"><B>FCP_UPDATE_COMMUTES</B></A>]  Theorem
      
      |- !m a b c d.
           a &lt;&gt; b ==&gt; ((a :+ c) ((b :+ d) m) = (b :+ d) ((a :+ c) m))
   
   [<A NAME="FCP_UPDATE_EQ-val"><B>FCP_UPDATE_EQ</B></A>]  Theorem
      
      |- !m a b c. (a :+ c) ((a :+ b) m) = (a :+ c) m
   
   [<A NAME="FCP_UPDATE_IMP_ID-val"><B>FCP_UPDATE_IMP_ID</B></A>]  Theorem
      
      |- !m a v. (m ' a = v) ==&gt; ((a :+ v) m = m)
   
   [<A NAME="INDEX_SUB1-val"><B>INDEX_SUB1</B></A>]  Theorem
      
      |- dimindex (:'a sub1) =
         if 1 &lt; dimindex (:'a) then PRE (dimindex (:'a)) else 1
   
   [<A NAME="LENGTH_V2L-val"><B>LENGTH_V2L</B></A>]  Theorem
      
      |- LENGTH (V2L v) = dimindex (:'b)
   
   [<A NAME="LISTS_EQ-val"><B>LISTS_EQ</B></A>]  Theorem
      
      |- (x = y) &lt;=&gt;
         (LENGTH x = LENGTH y) /\ !i. i &lt; LENGTH x ==&gt; (EL i x = EL i y)
   
   [<A NAME="NULL_V2L-val"><B>NULL_V2L</B></A>]  Theorem
      
      |- ~NULL (V2L v)
   
   [<A NAME="READ_L2V-val"><B>READ_L2V</B></A>]  Theorem
      
      |- i &lt; dimindex (:'b) ==&gt; (L2V a ' i = EL i a)
   
   [<A NAME="READ_TL-val"><B>READ_TL</B></A>]  Theorem
      
      |- i &lt; dimindex (:'b) ==&gt; (FCP_TL a ' i = a ' (SUC i))
   
   [<A NAME="V2L_L2V-val"><B>V2L_L2V</B></A>]  Theorem
      
      |- !x. (dimindex (:'b) = LENGTH x) ==&gt; (V2L (L2V x) = x)
   
   [<A NAME="V2L_RECURSIVE-val"><B>V2L_RECURSIVE</B></A>]  Theorem
      
      |- V2L v =
         FCP_HD v::if dimindex (:'b) = 1 then [] else V2L (FCP_TL v)
   
   [<A NAME="bit0_11-val"><B>bit0_11</B></A>]  Theorem
      
      |- (!a a'. (BIT0A a = BIT0A a') &lt;=&gt; (a = a')) /\
         !a a'. (BIT0B a = BIT0B a') &lt;=&gt; (a = a')
   
   [<A NAME="bit0_Axiom-val"><B>bit0_Axiom</B></A>]  Theorem
      
      |- !f0 f1. ?fn. (!a. fn (BIT0A a) = f0 a) /\ !a. fn (BIT0B a) = f1 a
   
   [<A NAME="bit0_case_cong-val"><B>bit0_case_cong</B></A>]  Theorem
      
      |- !M M' f f1.
           (M = M') /\ (!a. (M' = BIT0A a) ==&gt; (f a = f' a)) /\
           (!a. (M' = BIT0B a) ==&gt; (f1 a = f1' a)) ==&gt;
           (bit0_case f f1 M = bit0_case f' f1' M')
   
   [<A NAME="bit0_distinct-val"><B>bit0_distinct</B></A>]  Theorem
      
      |- !a' a. BIT0A a &lt;&gt; BIT0B a'
   
   [<A NAME="bit0_induction-val"><B>bit0_induction</B></A>]  Theorem
      
      |- !P. (!a. P (BIT0A a)) /\ (!a. P (BIT0B a)) ==&gt; !b. P b
   
   [<A NAME="bit0_nchotomy-val"><B>bit0_nchotomy</B></A>]  Theorem
      
      |- !bb. (?a. bb = BIT0A a) \/ ?a. bb = BIT0B a
   
   [<A NAME="bit1_11-val"><B>bit1_11</B></A>]  Theorem
      
      |- (!a a'. (BIT1A a = BIT1A a') &lt;=&gt; (a = a')) /\
         !a a'. (BIT1B a = BIT1B a') &lt;=&gt; (a = a')
   
   [<A NAME="bit1_Axiom-val"><B>bit1_Axiom</B></A>]  Theorem
      
      |- !f0 f1 f2.
           ?fn.
             (!a. fn (BIT1A a) = f0 a) /\ (!a. fn (BIT1B a) = f1 a) /\
             (fn BIT1C = f2)
   
   [<A NAME="bit1_case_cong-val"><B>bit1_case_cong</B></A>]  Theorem
      
      |- !M M' f f1 v.
           (M = M') /\ (!a. (M' = BIT1A a) ==&gt; (f a = f' a)) /\
           (!a. (M' = BIT1B a) ==&gt; (f1 a = f1' a)) /\
           ((M' = BIT1C) ==&gt; (v = v')) ==&gt;
           (bit1_case f f1 v M = bit1_case f' f1' v' M')
   
   [<A NAME="bit1_distinct-val"><B>bit1_distinct</B></A>]  Theorem
      
      |- (!a' a. BIT1A a &lt;&gt; BIT1B a') /\ (!a. BIT1A a &lt;&gt; BIT1C) /\
         !a. BIT1B a &lt;&gt; BIT1C
   
   [<A NAME="bit1_induction-val"><B>bit1_induction</B></A>]  Theorem
      
      |- !P. (!a. P (BIT1A a)) /\ (!a. P (BIT1B a)) /\ P BIT1C ==&gt; !b. P b
   
   [<A NAME="bit1_nchotomy-val"><B>bit1_nchotomy</B></A>]  Theorem
      
      |- !bb. (?a. bb = BIT1A a) \/ (?a. bb = BIT1B a) \/ (bb = BIT1C)
   
   [<A NAME="card_dimindex-val"><B>card_dimindex</B></A>]  Theorem
      
      |- FINITE UNIV ==&gt; (CARD UNIV = dimindex (:'a))
   
   [<A NAME="datatype_bit0-val"><B>datatype_bit0</B></A>]  Theorem
      
      |- DATATYPE (bit0 BIT0A BIT0B)
   
   [<A NAME="datatype_bit1-val"><B>datatype_bit1</B></A>]  Theorem
      
      |- DATATYPE (bit1 BIT1A BIT1B BIT1C)
   
   [<A NAME="dimindex-val"><B>dimindex</B></A>]  Theorem
      
      |- dimindex (:'a) = if FINITE UNIV then CARD UNIV else 1
   
   [<A NAME="exists_v2l_thm-val"><B>exists_v2l_thm</B></A>]  Theorem
      
      |- ?x.
           (LENGTH x = dimindex (:'b)) /\
           !i. i &lt; dimindex (:'b) ==&gt; (EL i x = v ' i)
   
   [<A NAME="fcp_Axiom-val"><B>fcp_Axiom</B></A>]  Theorem
      
      |- !f. ?g. !h. g (mk_cart h) = f h
   
   [<A NAME="fcp_ind-val"><B>fcp_ind</B></A>]  Theorem
      
      |- !P. (!f. P (mk_cart f)) ==&gt; !a. P a
   
   [<A NAME="fcp_subst_comp-val"><B>fcp_subst_comp</B></A>]  Theorem
      
      |- !a b f. (x :+ y) ($FCP f) = FCP c. if x = c then y else f c
   
   [<A NAME="finite_bit0-val"><B>finite_bit0</B></A>]  Theorem
      
      |- FINITE UNIV &lt;=&gt; FINITE UNIV
   
   [<A NAME="finite_bit1-val"><B>finite_bit1</B></A>]  Theorem
      
      |- FINITE UNIV &lt;=&gt; FINITE UNIV
   
   [<A NAME="finite_one-val"><B>finite_one</B></A>]  Theorem
      
      |- FINITE UNIV
   
   [<A NAME="finite_sub1-val"><B>finite_sub1</B></A>]  Theorem
      
      |- FINITE UNIV &lt;=&gt; FINITE UNIV
   
   [<A NAME="finite_sum-val"><B>finite_sum</B></A>]  Theorem
      
      |- FINITE UNIV &lt;=&gt; FINITE UNIV /\ FINITE UNIV
   
   [<A NAME="index_bit0-val"><B>index_bit0</B></A>]  Theorem
      
      |- dimindex (:'a bit0) =
         if FINITE UNIV then 2 * dimindex (:'a) else 1
   
   [<A NAME="index_bit1-val"><B>index_bit1</B></A>]  Theorem
      
      |- dimindex (:'a bit1) =
         if FINITE UNIV then 2 * dimindex (:'a) + 1 else 1
   
   [<A NAME="index_comp-val"><B>index_comp</B></A>]  Theorem
      
      |- !f n.
           $FCP f ' n =
           if n &lt; dimindex (:'b) then
             f n
           else
             FAIL $' FCP out of bounds ($FCP f) n
   
   [<A NAME="index_one-val"><B>index_one</B></A>]  Theorem
      
      |- dimindex (:unit) = 1
   
   [<A NAME="index_sum-val"><B>index_sum</B></A>]  Theorem
      
      |- dimindex (:'a + 'b) =
         if FINITE UNIV /\ FINITE UNIV then
           dimindex (:'a) + dimindex (:'b)
         else
           1
   
   [<A NAME="sub1_ABS_REP_CLASS-val"><B>sub1_ABS_REP_CLASS</B></A>]  Theorem
      
      |- (!a. abs_sub1_CLASS (rep_sub1_CLASS a) = a) /\
         !c.
           (?r. sub_equiv r r /\ (c = sub_equiv r)) &lt;=&gt;
           (rep_sub1_CLASS (abs_sub1_CLASS c) = c)
   
   [<A NAME="sub1_QUOTIENT-val"><B>sub1_QUOTIENT</B></A>]  Theorem
      
      |- QUOTIENT sub_equiv abs_sub1 rep_sub1
   
   
*)
end

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/n-bit/fcpScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
