<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure quotient</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure quotient</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/quotient/src/quotient.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>(* ===================================================================== *)
<A NAME="line2"></A>(*                                                                       *)
<A NAME="line3"></A>(* FILE          : quotient.sig                                          *)
<A NAME="line4"></A>(* VERSION       : 2.2                                                   *)
<A NAME="line5"></A>(* DESCRIPTION   : Functions for creating a quotient type.               *)
<A NAME="line6"></A>(*                                                                       *)
<A NAME="line7"></A>(* AUTHOR        : Peter Vincent Homeier                                 *)
<A NAME="line8"></A>(* DATE          : April 15, 2005                                        *)
<A NAME="line9"></A>(* COPYRIGHT     : Copyright (c) 2005 by Peter Vincent Homeier           *)
<A NAME="line10"></A>(*                                                                       *)
<A NAME="line11"></A>(* ===================================================================== *)
<A NAME="line12"></A>
<A NAME="line13"></A>
<A NAME="line14"></A>signature quotient =
<A NAME="line15"></A>sig
<A NAME="line16"></A>
<A NAME="line17"></A>(* =================================================================== *)
<A NAME="line18"></A>(*           Q U O T I E N T   T Y P E S   D E F I N E D               *)
<A NAME="line19"></A>(* =================================================================== *)
<A NAME="line20"></A>
<A NAME="line21"></A>(* ------------------------------------------------------------------- *)
<A NAME="line22"></A>(* This file defines the function "define_quotient_type", which takes  *)
<A NAME="line23"></A>(* an existing type and theorems about it, along with a theorem about  *)
<A NAME="line24"></A>(* an equivalence relation on the type, and creates a new type which   *)
<A NAME="line25"></A>(* is isomorphic to the equivalence classes of the old type.           *)
<A NAME="line26"></A>(* In addition to creating the new type, functions are defined in the  *)
<A NAME="line27"></A>(* HOL logic to translate between the old and new types in both        *)
<A NAME="line28"></A>(* directions.                                                         *)
<A NAME="line29"></A>(*                                                                     *)
<A NAME="line30"></A>(* The arguments to "define_quotient_type" includes a theorem which    *)
<A NAME="line31"></A>(* -&gt;implies&lt;- that the equivalence relation is in fact reflexive,     *)
<A NAME="line32"></A>(* symmetric, and transitive.  These properties all follow from        *)
<A NAME="line33"></A>(*      |- !x y. EQUIV x y = (EQUIV x = EQUIV y)                       *)
<A NAME="line34"></A>(*                                                                     *)
<A NAME="line35"></A>(* The "define_quotient_type" function returns a theorem of the form   *)
<A NAME="line36"></A>(*      |- (!a. abs(rep a) = a) /\                                     *)
<A NAME="line37"></A>(*         (!r r'. EQUIV r r' = (abs r = abs r'))                      *)
<A NAME="line38"></A>(*                                                                     *)
<A NAME="line39"></A>(* We call theorems of this form "quotient theorems"; they are used    *)
<A NAME="line40"></A>(* a good deal as inputs to or results from other functions in this    *)
<A NAME="line41"></A>(* package.                                                            *)
<A NAME="line42"></A>(* ------------------------------------------------------------------- *)
<A NAME="line43"></A>
<A NAME="line44"></A>val chatting : bool ref (* default is false, no trace of quotient operation *)
<A NAME="line45"></A>
<A NAME="line46"></A>val caching  : bool ref (* default is true, do cache quotient thms for speed *)
<A NAME="line47"></A>
<A NAME="line48"></A>val reset_cache : unit -&gt; unit
<A NAME="line49"></A>val list_cache  : unit -&gt; (Type.hol_type * Thm.thm) list
<A NAME="line50"></A>
<A NAME="line51"></A>val define_quotient_type :
<A NAME="line52"></A>        string -&gt;      (* name of new quotient type *)
<A NAME="line53"></A>        string -&gt;      (* name of abstraction function from old to new *)
<A NAME="line54"></A>        string -&gt;      (* name of representation function from new to old *)
<A NAME="line55"></A>        Thm.thm -&gt;     (* equivalence or partial equivalence theorem *)
<A NAME="line56"></A>        Thm.thm        (* returns one theorem:
<A NAME="line57"></A>
<A NAME="line58"></A>              abs of rep is identity /\
<A NAME="line59"></A>              equivalence is equality of abs
<A NAME="line60"></A>*)
<A NAME="line61"></A>
<A NAME="line62"></A>
<A NAME="line63"></A>(* Equivalence theorems have the form:
<A NAME="line64"></A>
<A NAME="line65"></A>              !x y. R x y = (R x = R y)
<A NAME="line66"></A>
<A NAME="line67"></A>   Here are routines to create equivalence theorems,
<A NAME="line68"></A>   and to convert them into theorems of
<A NAME="line69"></A>   reflexivity, symmetry, and transitivity.              *)
<A NAME="line70"></A>
<A NAME="line71"></A>val equiv_refl :
<A NAME="line72"></A>        Thm.thm -&gt;     (* equivalence theorem *)
<A NAME="line73"></A>        Thm.thm        (* returns reflexivity theorem for equivalence:
<A NAME="line74"></A>
<A NAME="line75"></A>              !x. R x x
<A NAME="line76"></A>*)
<A NAME="line77"></A>
<A NAME="line78"></A>val equiv_sym :
<A NAME="line79"></A>        Thm.thm -&gt;     (* equivalence theorem *)
<A NAME="line80"></A>        Thm.thm        (* returns symmetry theorem for equivalence:
<A NAME="line81"></A>
<A NAME="line82"></A>              !x y. R x y ==&gt; R y x
<A NAME="line83"></A>*)
<A NAME="line84"></A>
<A NAME="line85"></A>val equiv_trans :
<A NAME="line86"></A>        Thm.thm -&gt;     (* equivalence theorem *)
<A NAME="line87"></A>        Thm.thm        (* returns transitivity theorem for equivalence:
<A NAME="line88"></A>
<A NAME="line89"></A>              !x y z. R x y /\ R y z ==&gt; R y x
<A NAME="line90"></A>*)
<A NAME="line91"></A>
<A NAME="line92"></A>val refl_sym_trans_equiv :
<A NAME="line93"></A>        Thm.thm -&gt;     (* reflexivity theorem *)
<A NAME="line94"></A>        Thm.thm -&gt;     (* symmetry theorem *)
<A NAME="line95"></A>        Thm.thm -&gt;     (* transitivity theorem *)
<A NAME="line96"></A>        Thm.thm        (* returns equivalence theorem:
<A NAME="line97"></A>
<A NAME="line98"></A>              !x y. R x y = (R x = R y)
<A NAME="line99"></A>*)
<A NAME="line100"></A>
<A NAME="line101"></A>val identity_equiv :
<A NAME="line102"></A>        Type.hol_type -&gt; (* type, whose equivalence relation is equality *)
<A NAME="line103"></A>        Thm.thm        (* returns identity equivalence theorem for type:
<A NAME="line104"></A>
<A NAME="line105"></A>              !x y. $= x y = ($= x = $= y)
<A NAME="line106"></A>*)
<A NAME="line107"></A>
<A NAME="line108"></A>val pair_equiv :
<A NAME="line109"></A>        Thm.thm -&gt;     (* equivalence theorem for left element of pair *)
<A NAME="line110"></A>        Thm.thm -&gt;     (* equivalence theorem for right element of pair *)
<A NAME="line111"></A>        Thm.thm        (* returns equivalence theorem for pair:
<A NAME="line112"></A>
<A NAME="line113"></A>              !x y. (R1 ### R2) x y = ((R1 ### R2) x = (R1 ### R2) y)
<A NAME="line114"></A>*)
<A NAME="line115"></A>
<A NAME="line116"></A>val sum_equiv :
<A NAME="line117"></A>        Thm.thm -&gt;     (* equivalence theorem for left element of sum *)
<A NAME="line118"></A>        Thm.thm -&gt;     (* equivalence theorem for right element of sum *)
<A NAME="line119"></A>        Thm.thm        (* returns equivalence theorem for sum:
<A NAME="line120"></A>
<A NAME="line121"></A>              !x y. (R1 +++ R2) x y = ((R1 +++ R2) x = (R1 +++ R2) y)
<A NAME="line122"></A>*)
<A NAME="line123"></A>
<A NAME="line124"></A>val list_equiv :
<A NAME="line125"></A>        Thm.thm -&gt;     (* equivalence theorem for element of list *)
<A NAME="line126"></A>        Thm.thm        (* returns equivalence theorem for list:
<A NAME="line127"></A>
<A NAME="line128"></A>              !x y. LIST_REL R x y = (LIST_REL R x = LIST_REL R y)
<A NAME="line129"></A>*)
<A NAME="line130"></A>
<A NAME="line131"></A>val option_equiv :
<A NAME="line132"></A>        Thm.thm -&gt;     (* equivalence theorem for element of option *)
<A NAME="line133"></A>        Thm.thm        (* returns equivalence theorem for option:
<A NAME="line134"></A>
<A NAME="line135"></A>              !x y. OPTION_REL R x y = (OPTION_REL R x = OPTION_REL R y)
<A NAME="line136"></A>*)
<A NAME="line137"></A>
<A NAME="line138"></A>val make_equiv :
<A NAME="line139"></A>        Thm.thm list -&gt;  (* base equivalence theorems *)
<A NAME="line140"></A>        Thm.thm list -&gt;  (* polymorphic type operator equivalence theorems *)
<A NAME="line141"></A>        Type.hol_type -&gt; (* type, whose equivalence relation is desired *)
<A NAME="line142"></A>        Thm.thm          (* returns equivalence theorem for hol_type:
<A NAME="line143"></A>
<A NAME="line144"></A>              !x y. R x y = (R x = R y)
<A NAME="line145"></A>*)
<A NAME="line146"></A>
<A NAME="line147"></A>
<A NAME="line148"></A>(* Quotient theorems have the form:
<A NAME="line149"></A>
<A NAME="line150"></A>              (!a. abs (rep a) = a) /\
<A NAME="line151"></A>              (|x y. R x y = (abs x = abs y))
<A NAME="line152"></A>
<A NAME="line153"></A>   These are returned by define_quotient_type.
<A NAME="line154"></A>   Here are more routines to create quotient theorems.  *)
<A NAME="line155"></A>
<A NAME="line156"></A>val identity_quotient :
<A NAME="line157"></A>        Type.hol_type -&gt; (* type, whose equivalence relation is equality *)
<A NAME="line158"></A>        Thm.thm        (* returns identity quotient theorem for type:
<A NAME="line159"></A>
<A NAME="line160"></A>              (!a. I (I a) = a) /\
<A NAME="line161"></A>              (|x y. $= x y = (I x = I y))
<A NAME="line162"></A>*)
<A NAME="line163"></A>
<A NAME="line164"></A>val pair_quotient :
<A NAME="line165"></A>        Thm.thm -&gt;     (* quotient theorem for left element of pair *)
<A NAME="line166"></A>        Thm.thm -&gt;     (* quotient theorem for right element of pair *)
<A NAME="line167"></A>        Thm.thm        (* returns quotient theorem for pair:
<A NAME="line168"></A>
<A NAME="line169"></A>              (!a. (abs1 ## abs2) ((rep1 ## rep2) a) = a) /\
<A NAME="line170"></A>              (|x y. (R1 ### R2) x y = ((abs1 ## abs2) x = (abs1 ## abs2) y))
<A NAME="line171"></A>*)
<A NAME="line172"></A>
<A NAME="line173"></A>val sum_quotient :
<A NAME="line174"></A>        Thm.thm -&gt;     (* quotient theorem for left element of sum *)
<A NAME="line175"></A>        Thm.thm -&gt;     (* quotient theorem for right element of sum *)
<A NAME="line176"></A>        Thm.thm        (* returns quotient theorem for sum:
<A NAME="line177"></A>
<A NAME="line178"></A>              (!a. (abs1 ++ abs2) ((rep1 ++ rep2) a) = a) /\
<A NAME="line179"></A>              (|x y. (R1 +++ R2) x y = ((abs1 ++ abs2) x = (abs1 ++ abs2) y))
<A NAME="line180"></A>*)
<A NAME="line181"></A>
<A NAME="line182"></A>val list_quotient :
<A NAME="line183"></A>        Thm.thm -&gt;     (* quotient theorem for element of list *)
<A NAME="line184"></A>        Thm.thm        (* returns quotient theorem for list:
<A NAME="line185"></A>
<A NAME="line186"></A>              (!a. MAP abs (MAP rep a) = a) /\
<A NAME="line187"></A>              (|x y. LIST_REL R x y = (MAP abs x = MAP abs y))
<A NAME="line188"></A>*)
<A NAME="line189"></A>
<A NAME="line190"></A>val option_quotient :
<A NAME="line191"></A>        Thm.thm -&gt;     (* quotient theorem for base type of option *)
<A NAME="line192"></A>        Thm.thm        (* returns quotient theorem for option:
<A NAME="line193"></A>
<A NAME="line194"></A>              (!a. OPTION_MAP abs (OPTION_MAP rep a) = a) /\
<A NAME="line195"></A>              (|x y. OPTION_REL R x y = (OPTION_MAP abs x = OPTION_MAP abs y))
<A NAME="line196"></A>*)
<A NAME="line197"></A>
<A NAME="line198"></A>val fun_quotient :
<A NAME="line199"></A>        Thm.thm -&gt;     (* quotient theorem for domain of function *)
<A NAME="line200"></A>        Thm.thm -&gt;     (* quotient theorem for range of function *)
<A NAME="line201"></A>        Thm.thm        (* returns quotient theorem for function:
<A NAME="line202"></A>
<A NAME="line203"></A>          (!a. (rep1 --&gt; abs2) ((abs1 --&gt; rep2) a) = a) /\
<A NAME="line204"></A>          (|f g. (rep1 =-&gt; abs2) f g = ((rep1 --&gt; abs2) f = (rep1 --&gt; abs2) g))
<A NAME="line205"></A>*)
<A NAME="line206"></A>
<A NAME="line207"></A>val make_quotient :
<A NAME="line208"></A>        Thm.thm list -&gt;  (* quotient theorems for primary lifted types *)
<A NAME="line209"></A>        Thm.thm list -&gt;  (* conditional quotient ths for type operators *)
<A NAME="line210"></A>        Type.hol_type -&gt; (* type (not lifted) of desired quotient *)
<A NAME="line211"></A>        Thm.thm        (* returns quotient theorem for given type:
<A NAME="line212"></A>
<A NAME="line213"></A>              (!a. abs (rep a) = a) /\
<A NAME="line214"></A>              (|x y. R x y = (abs x = abs y))
<A NAME="line215"></A>*)
<A NAME="line216"></A>
<A NAME="line217"></A>
<A NAME="line218"></A>
<A NAME="line219"></A>val define_quotient_lifted_function :
<A NAME="line220"></A>        Thm.thm list -&gt; (* quotient thms, e.g. from define_quotient_type *)
<A NAME="line221"></A>        Thm.thm list -&gt;             (* conditional quotient ths for type ops*)
<A NAME="line222"></A>        Thm.thm list -&gt;             (* rel & map simplifications for type ops*)
<A NAME="line223"></A>        {def_name : string,         (* name to store the definition under *)
<A NAME="line224"></A>         fname : string,            (* name of new function *)
<A NAME="line225"></A>         func : Term.term,          (* old function, to be lifted *)
<A NAME="line226"></A>         fixity : Parse.fixity} -&gt;  (* fixity of new function *)
<A NAME="line227"></A>        Thm.thm                     (* definition of a new lifted function *)
<A NAME="line228"></A>
<A NAME="line229"></A>
<A NAME="line230"></A>(*
<A NAME="line231"></A>val regularize :
<A NAME="line232"></A>        Term.term -&gt;    (* term to be lifted, may not be regular *)
<A NAME="line233"></A>        Term.term       (* version of input term, that is now regular *)
<A NAME="line234"></A>
<A NAME="line235"></A>
<A NAME="line236"></A>val REGULARIZE :
<A NAME="line237"></A>        Thm.thm -&gt;      (* theorem to be lifted, may not be regular *)
<A NAME="line238"></A>        Thm.thm         (* version of input theorem, that is now regular *)
<A NAME="line239"></A>*)
<A NAME="line240"></A>
<A NAME="line241"></A>
<A NAME="line242"></A>val lift_theorem_by_quotients :
<A NAME="line243"></A>        Thm.thm list -&gt; (* quotient thms, e.g. from define_quotient_type *)
<A NAME="line244"></A>        Thm.thm list -&gt; (* equivalence thms, e.g. from user or make_equiv *)
<A NAME="line245"></A>        Thm.thm list -&gt; (* above + conditional equivalence thms for type ops *)
<A NAME="line246"></A>        Thm.thm list -&gt; (* conditional quotient ths for type ops *)
<A NAME="line247"></A>        Thm.thm list -&gt; (* simplification ths for rel/map idents of type ops *)
<A NAME="line248"></A>        Thm.thm list -&gt; (* new function definitions formed by d_q_l_f *)
<A NAME="line249"></A>        Thm.thm list -&gt; (* old functions are well-defined to respect the
<A NAME="line250"></A>                           equivalence relations mentioned above *)
<A NAME="line251"></A>        Thm.thm list -&gt; (* polymorphic function definitions on quotient types
<A NAME="line252"></A>                           as lifted from instanciations on old types,
<A NAME="line253"></A>                           for all quotient theorems *)
<A NAME="line254"></A>        Thm.thm list -&gt; (* polymorphic functions are well-defined to respect
<A NAME="line255"></A>                           all quotient theorems *)
<A NAME="line256"></A>        Thm.thm -&gt;      (* theorem (regarding old functions) to be lifted *)
<A NAME="line257"></A>        Thm.thm         (* lifted version of previous theorem *)
<A NAME="line258"></A>
<A NAME="line259"></A>
<A NAME="line260"></A>
<A NAME="line261"></A>(*---------------------------------------------------------------------------*)
<A NAME="line262"></A>(* Main function of package: define_equivalence_types                        *)
<A NAME="line263"></A>(*                                                                           *)
<A NAME="line264"></A>(* Defines a type of equivalence classes, and transfers a list of            *)
<A NAME="line265"></A>(* functions and theorems about the representatives over to the new type.    *)
<A NAME="line266"></A>(* It returns a list of the transferred theorems.                            *)
<A NAME="line267"></A>(*                                                                           *)
<A NAME="line268"></A>(* types    - list of records of two fields:                                 *)
<A NAME="line269"></A>(*                                                                           *)
<A NAME="line270"></A>(*   name     - desired name of new type                                     *)
<A NAME="line271"></A>(*   equiv    - Theorem that R is an equivalence relation; in the form:      *)
<A NAME="line272"></A>(*               |- !x y. x R y = (R x = R y)                                *)
<A NAME="line273"></A>(*                                                                           *)
<A NAME="line274"></A>(* tyops    - list of conditional quotient theorems; in the form:            *)
<A NAME="line275"></A>(*               |- !R1 (abs1:'a1-&gt;'b1) rep1 ... Rn (absn:'an-&gt;'bn) repn.    *)
<A NAME="line276"></A>(*                   (!a:'b1. abs1 (rep1 a) = a) /\                          *)
<A NAME="line277"></A>(*                   (|(r:'a1) (r':'a1). R1 r r' = (abs1 r = abs1 r')) ==&gt;   *)
<A NAME="line278"></A>(*                   ...                                                     *)
<A NAME="line279"></A>(*                   (!a:'bn. absn (repn a) = a) /\                          *)
<A NAME="line280"></A>(*                   (|(r:'an) (r':'an). Rn r r' = (absn r = absn r')) ==&gt;   *)
<A NAME="line281"></A>(*                   (!a:('b1,...,'bn)tyop.                                  *)
<A NAME="line282"></A>(*                         F abs1 ... absn (F rep1 ... repn a) = a) /\       *)
<A NAME="line283"></A>(*                   (|(r:('a1,...,'an)tyop) (r':('a1,...,'an)tyop).         *)
<A NAME="line284"></A>(*                         R R1 ... Rn r r' =                                *)
<A NAME="line285"></A>(*                           (F abs1 ... absn r = F abs1 ... absn r'))       *)
<A NAME="line286"></A>(*             where F and R are predefined constants in the logic.          *)
<A NAME="line287"></A>(*                                                                           *)
<A NAME="line288"></A>(*                                                                           *)
<A NAME="line289"></A>(* defs     - list of records of four fields:                                *)
<A NAME="line290"></A>(*                                                                           *)
<A NAME="line291"></A>(*   def_name - string, name of theorem stored in current theory             *)
<A NAME="line292"></A>(*   fname    - string, name of the new function defined in HOL logic        *)
<A NAME="line293"></A>(*   func     - term, the old term which is to be lifted                     *)
<A NAME="line294"></A>(*   fixity   - Parse.fixity, gives the parsing status of the new function   *)
<A NAME="line295"></A>(*                                                                           *)
<A NAME="line296"></A>(* respects - list of theorems asserting that the old functions are          *)
<A NAME="line297"></A>(*            welldefined;  of the form                                      *)
<A NAME="line298"></A>(*                       |- (R1 x1 y1) /\ .. /\ (Rn xn yn) ==&gt;               *)
<A NAME="line299"></A>(*                             R (f x1 .. xn) (f y1 .. yn)                   *)
<A NAME="line300"></A>(*            where "R[i]" becomes "=" for types other than the              *)
<A NAME="line301"></A>(*            representing types.                                            *)
<A NAME="line302"></A>(*                                                                           *)
<A NAME="line303"></A>(* poly_preserves - list of theorems asserting that polymorphic functions    *)
<A NAME="line304"></A>(*            apply to lifted values as they did to representing values;     *)
<A NAME="line305"></A>(*            of the form                                                    *)
<A NAME="line306"></A>(*                       |- ((!a. abs1 (rep1 a) = a) /\                      *)
<A NAME="line307"></A>(*                           (!x y. R1 x y = (abs1 x = abs1 y)) ==&gt;          *)
<A NAME="line308"></A>(*                          ... ==&gt;                                          *)
<A NAME="line309"></A>(*                          ((!a. absk (repk a) = a) /\                      *)
<A NAME="line310"></A>(*                           (!x y. Rk x y = (absk x = absk y)) ==&gt;          *)
<A NAME="line311"></A>(*                          (!x1 ... xn.                                     *)
<A NAME="line312"></A>(*                            f x1 ... xn = abs (f (rep1 x1) ... (repn xn))) *)
<A NAME="line313"></A>(*            where "R[i]" becomes "=" and "abs[i]" or "rep[i]" becomes "I"  *)
<A NAME="line314"></A>(*            for types other than the representing types.                   *)
<A NAME="line315"></A>(*            The k antecedents need not include duplicates, and may be in   *)
<A NAME="line316"></A>(*            any order, so long as all argument and return value types      *)
<A NAME="line317"></A>(*            of f are represented.                                          *)
<A NAME="line318"></A>(*                                                                           *)
<A NAME="line319"></A>(* poly_respects - list of theorems asserting that polymorphic functions     *)
<A NAME="line320"></A>(*            respect the equivalence relations;  of the form                *)
<A NAME="line321"></A>(*                       |- ((!a. abs1 (rep1 a) = a) /\                      *)
<A NAME="line322"></A>(*                           (!x y. R1 x y = (abs1 x = abs1 y)) ==&gt;          *)
<A NAME="line323"></A>(*                          ... ==&gt;                                          *)
<A NAME="line324"></A>(*                          ((!a. absk (repk a) = a) /\                      *)
<A NAME="line325"></A>(*                           (!x y. Rk x y = (absk x = absk y)) ==&gt;          *)
<A NAME="line326"></A>(*                          (R1 x1 y1) /\ .. /\ (Rn xn yn) ==&gt;               *)
<A NAME="line327"></A>(*                             R (f x1 .. xn) (f y1 .. yn)                   *)
<A NAME="line328"></A>(*            where "R[i]" becomes "=" and "abs[i]" or "rep[i]" becomes "I"  *)
<A NAME="line329"></A>(*            for types other than the representing types.                   *)
<A NAME="line330"></A>(*            The k antecedents need not include duplicates, and may be in   *)
<A NAME="line331"></A>(*            any order, so long as all argument and return value types      *)
<A NAME="line332"></A>(*            of f are represented.                                          *)
<A NAME="line333"></A>(*                                                                           *)
<A NAME="line334"></A>(* old_thms - list of theorems about the old functions, on the old types     *)
<A NAME="line335"></A>(*                                                                           *)
<A NAME="line336"></A>(* Restrictions:                                                             *)
<A NAME="line337"></A>(*                                                                           *)
<A NAME="line338"></A>(*  * R[i] must be an equivalence relation over the whole types, no subsets. *)
<A NAME="line339"></A>(*                                                                           *)
<A NAME="line340"></A>(*  * All original functions must be curried (as are the new ones).          *)
<A NAME="line341"></A>(*                                                                           *)
<A NAME="line342"></A>(*  * The theorems must have all variables bound by existential or           *)
<A NAME="line343"></A>(*    universal quantifiers.                                                 *)
<A NAME="line344"></A>(*                                                                           *)
<A NAME="line345"></A>(*  * The theorems must be obviously `well-defined', i.e. invariant under    *)
<A NAME="line346"></A>(*    substitution [t/u] whenever |- t R[i] u. Essentially "R[i]" becomes    *)
<A NAME="line347"></A>(*    "=" and  old functions become the new ones.                            *)
<A NAME="line348"></A>(*                                                                           *)
<A NAME="line349"></A>(*  * All arguments/results of the representing type will be transferred     *)
<A NAME="line350"></A>(*    to the new type.                                                       *)
<A NAME="line351"></A>(*                                                                           *)
<A NAME="line352"></A>(* Original Author: John Harrison                                            *)
<A NAME="line353"></A>(* Revised and extended to lift second-order theorems: Peter V. Homeier      *)
<A NAME="line354"></A>(*---------------------------------------------------------------------------*)
<A NAME="line355"></A>
<A NAME="line356"></A>(* MAIN ENTRY POINT: *)
<A NAME="line357"></A>
<A NAME="line358"></A>val define_quotient_types :
<A NAME="line359"></A>        {types: {name:string,          (* name of new quotient type *)
<A NAME="line360"></A>                 equiv:Thm.thm} list,  (* relation is an equivalence *)
<A NAME="line361"></A>         defs: {def_name:string,            (* name of stored definition *)
<A NAME="line362"></A>                fname:string,               (* name of new lifted function *)
<A NAME="line363"></A>                func:Term.term,             (* old function to be lifted *)
<A NAME="line364"></A>                fixity: Parse.fixity} list, (* fixity of new function *)
<A NAME="line365"></A>         tyop_equivs: Thm.thm list,  (* conditional equiv ths for type ops *)
<A NAME="line366"></A>         tyop_quotients: Thm.thm list,(*conditional quotient ths for type ops*)
<A NAME="line367"></A>         tyop_simps: Thm.thm list, (* rel/map simplification ths for type ops*)
<A NAME="line368"></A>         respects : Thm.thm list,    (* old functions respect equivalence *)
<A NAME="line369"></A>         poly_preserves : Thm.thm list, (* polymorphic fns are preserved
<A NAME="line370"></A>                                           by quotients *)
<A NAME="line371"></A>         poly_respects : Thm.thm list,(* polymorphic fns respect equivalence *)
<A NAME="line372"></A>         old_thms : Thm.thm list} -&gt; (* theorems of old fns to be lifted *)
<A NAME="line373"></A>        Thm.thm list                 (* new lifted theorems *)
<A NAME="line374"></A>
<A NAME="line375"></A>(* ALTERNATE ENTRY POINT: *)
<A NAME="line376"></A>
<A NAME="line377"></A>val define_quotient_types_rule :
<A NAME="line378"></A>        {types: {name:string,          (* name of new quotient type *)
<A NAME="line379"></A>                 equiv:Thm.thm} list,  (* relation is an equivalence *)
<A NAME="line380"></A>         defs: {def_name:string,            (* name of stored definition *)
<A NAME="line381"></A>                fname:string,               (* name of new lifted function *)
<A NAME="line382"></A>                func:Term.term,             (* old function to be lifted *)
<A NAME="line383"></A>                fixity: Parse.fixity} list, (* fixity of new function *)
<A NAME="line384"></A>         tyop_equivs: Thm.thm list,  (* conditional equiv ths for type ops *)
<A NAME="line385"></A>         tyop_quotients: Thm.thm list,(*conditional quotient ths for type ops*)
<A NAME="line386"></A>         tyop_simps: Thm.thm list, (* rel/map simplification ths for type ops*)
<A NAME="line387"></A>         respects : Thm.thm list,    (* old functions respect equivalence *)
<A NAME="line388"></A>         poly_preserves : Thm.thm list, (* polymorphic fns are preserved
<A NAME="line389"></A>                                           by quotients *)
<A NAME="line390"></A>         poly_respects : Thm.thm list} -&gt;
<A NAME="line391"></A>                                     (* polymorphic fns respect equivalence *)
<A NAME="line392"></A>        (Thm.thm -&gt; Thm.thm)          (* rule for lifting theorems *)
<A NAME="line393"></A>
<A NAME="line394"></A>(* MAIN ENTRY POINT INCLUDING STANDARD THEOREMS: *)
<A NAME="line395"></A>
<A NAME="line396"></A>val define_quotient_types_full :
<A NAME="line397"></A>        {types: {name:string,          (* name of new quotient type *)
<A NAME="line398"></A>                 equiv:Thm.thm} list,  (* relation is an equivalence *)
<A NAME="line399"></A>         defs: {def_name:string,            (* name of stored definition *)
<A NAME="line400"></A>                fname:string,               (* name of new lifted function *)
<A NAME="line401"></A>                func:Term.term,             (* old function to be lifted *)
<A NAME="line402"></A>                fixity: Parse.fixity} list, (* fixity of new function *)
<A NAME="line403"></A>         tyop_equivs: Thm.thm list,  (* conditional equiv ths for type ops *)
<A NAME="line404"></A>         tyop_quotients: Thm.thm list,(*conditional quotient ths for type ops*)
<A NAME="line405"></A>         tyop_simps: Thm.thm list, (* rel/map simplification ths for type ops*)
<A NAME="line406"></A>         respects : Thm.thm list,    (* old functions respect equivalence *)
<A NAME="line407"></A>         poly_preserves : Thm.thm list, (* polymorphic fns are preserved
<A NAME="line408"></A>                                           by quotients *)
<A NAME="line409"></A>         poly_respects : Thm.thm list,(* polymorphic fns respect equivalence *)
<A NAME="line410"></A>         old_thms : Thm.thm list} -&gt; (* theorems of old fns to be lifted *)
<A NAME="line411"></A>        Thm.thm list                 (* new lifted theorems *)
<A NAME="line412"></A>
<A NAME="line413"></A>(* ALTERNATE ENTRY POINT INCLUDING STANDARD THEOREMS: *)
<A NAME="line414"></A>
<A NAME="line415"></A>val define_quotient_types_full_rule :
<A NAME="line416"></A>        {types: {name:string,          (* name of new quotient type *)
<A NAME="line417"></A>                 equiv:Thm.thm} list,  (* relation is an equivalence *)
<A NAME="line418"></A>         defs: {def_name:string,            (* name of stored definition *)
<A NAME="line419"></A>                fname:string,               (* name of new lifted function *)
<A NAME="line420"></A>                func:Term.term,             (* old function to be lifted *)
<A NAME="line421"></A>                fixity: Parse.fixity} list, (* fixity of new function *)
<A NAME="line422"></A>         tyop_equivs: Thm.thm list,  (* conditional equiv ths for type ops *)
<A NAME="line423"></A>         tyop_quotients: Thm.thm list,(*conditional quotient ths for type ops*)
<A NAME="line424"></A>         tyop_simps: Thm.thm list, (* rel/map simplification ths for type ops*)
<A NAME="line425"></A>         respects : Thm.thm list,    (* old functions respect equivalence *)
<A NAME="line426"></A>         poly_preserves : Thm.thm list, (* polymorphic fns are preserved
<A NAME="line427"></A>                                           by quotients *)
<A NAME="line428"></A>         poly_respects : Thm.thm list} -&gt;
<A NAME="line429"></A>                                     (* polymorphic fns respect equivalence *)
<A NAME="line430"></A>        (Thm.thm -&gt; Thm.thm)          (* rule for lifting theorems *)
<A NAME="line431"></A>
<A NAME="line432"></A>(* MAIN ENTRY POINT WITH JUST STANDARD THEOREMS: *)
<A NAME="line433"></A>(* This is a quick, simple entry point if the only type operators involved are
<A NAME="line434"></A>   the list, pair, sum, option, and function ones, and no new polymorphic
<A NAME="line435"></A>   operators need to have their respectfulness or preservation proven.   *)
<A NAME="line436"></A>
<A NAME="line437"></A>val define_quotient_types_std :
<A NAME="line438"></A>        {types: {name:string,          (* name of new quotient type *)
<A NAME="line439"></A>                 equiv:Thm.thm} list,  (* relation is an equivalence *)
<A NAME="line440"></A>         defs: {def_name:string,            (* name of stored definition *)
<A NAME="line441"></A>                fname:string,               (* name of new lifted function *)
<A NAME="line442"></A>                func:Term.term,             (* old function to be lifted *)
<A NAME="line443"></A>                fixity: Parse.fixity} list, (* fixity of new function *)
<A NAME="line444"></A>         respects : Thm.thm list,    (* old functions respect equivalence *)
<A NAME="line445"></A>         old_thms : Thm.thm list} -&gt; (* theorems of old fns to be lifted *)
<A NAME="line446"></A>        Thm.thm list                 (* new lifted theorems *)
<A NAME="line447"></A>
<A NAME="line448"></A>(* ALTERNATE ENTRY POINT WITH JUST STANDARD THEOREMS: *)
<A NAME="line449"></A>
<A NAME="line450"></A>val define_quotient_types_std_rule :
<A NAME="line451"></A>        {types: {name:string,          (* name of new quotient type *)
<A NAME="line452"></A>                 equiv:Thm.thm} list,  (* relation is an equivalence *)
<A NAME="line453"></A>         defs: {def_name:string,            (* name of stored definition *)
<A NAME="line454"></A>                fname:string,               (* name of new lifted function *)
<A NAME="line455"></A>                func:Term.term,             (* old function to be lifted *)
<A NAME="line456"></A>                fixity: Parse.fixity} list, (* fixity of new function *)
<A NAME="line457"></A>         respects : Thm.thm list} -&gt;   (* old functions respect equivalence *)
<A NAME="line458"></A>        (Thm.thm -&gt; Thm.thm)          (* rule for lifting theorems *)
<A NAME="line459"></A>
<A NAME="line460"></A>(* For backwards compatibility with John Harrison's package: *)
<A NAME="line461"></A>
<A NAME="line462"></A>val define_equivalence_type :
<A NAME="line463"></A>        {name : string,              (* name of new quotient type *)
<A NAME="line464"></A>         equiv : Thm.thm,            (* thm that relation is an equivalence *)
<A NAME="line465"></A>         defs: {def_name:string,            (* name of stored definition *)
<A NAME="line466"></A>                fname:string,               (* name of new lifted function *)
<A NAME="line467"></A>                func:Term.term,             (* old function to be lifted *)
<A NAME="line468"></A>                fixity: Parse.fixity} list, (* fixity of new function *)
<A NAME="line469"></A>         welldefs : Thm.thm list,    (* old functions respect equivalence *)
<A NAME="line470"></A>         old_thms : Thm.thm list} -&gt; (* theorems of old fns to be lifted *)
<A NAME="line471"></A>        Thm.thm list                 (* definitions of new lifted functions *)
<A NAME="line472"></A>
<A NAME="line473"></A>
<A NAME="line474"></A>
<A NAME="line475"></A>end;  (* of signature quotient *)
<A NAME="line476"></A>
</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/quotient/src/quotient.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
