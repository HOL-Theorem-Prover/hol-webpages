<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure MLY_base</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure MLY_base</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="file:///home/michaeln/phol/tools/mlyacc/mlyacclib/MLY_base.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>(* Modified by sweeks@acm.org on 2000-8-24.
<A NAME="line2"></A> * Ported to MLton.
<A NAME="line3"></A> *)
<A NAME="line4"></A>type int = Int.int
<A NAME="line5"></A>   
<A NAME="line6"></A>(* ML-Yacc Parser Generator (c) 1989 Andrew W. Appel, David R. Tarditi 
<A NAME="line7"></A> *
<A NAME="line8"></A> * $Log$
<A NAME="line9"></A> * Revision 1.1  2006/06/23 03:21:27  michaeln
<A NAME="line10"></A> * Changed the names of the files in mlyacclib because I want these files
<A NAME="line11"></A> * to move into sigobj, and I don't want name-clashes, particularly with
<A NAME="line12"></A> * names like stream.sml.  (If you use a parser generated by mlyacc, then
<A NAME="line13"></A> * you need to have the files in mlyacclib available too.)
<A NAME="line14"></A> *
<A NAME="line15"></A> * Revision 1.1  2006/06/22 07:40:27  michaeln
<A NAME="line16"></A> * Add a MoscowML compilable implementation of MLyacc, using the MLton sources
<A NAME="line17"></A> * as the base.
<A NAME="line18"></A> *
<A NAME="line19"></A> * Revision 1.1.1.1  1997/01/14 01:38:04  george
<A NAME="line20"></A> *   Version 109.24
<A NAME="line21"></A> *
<A NAME="line22"></A> * Revision 1.1.1.1  1996/01/31  16:01:42  george
<A NAME="line23"></A> * Version 109
<A NAME="line24"></A> * 
<A NAME="line25"></A> *)
<A NAME="line26"></A>
<A NAME="line27"></A>(* base.sig: Base signature file for SML-Yacc.  This file contains signatures
<A NAME="line28"></A>   that must be loaded before any of the files produced by ML-Yacc are loaded
<A NAME="line29"></A>*)
<A NAME="line30"></A>
<A NAME="line31"></A>(* STREAM: signature for a lazy stream.*)
<A NAME="line32"></A>
<A NAME="line33"></A>signature STREAM =
<A NAME="line34"></A> sig type 'xa stream
<A NAME="line35"></A>     val streamify : (unit -&gt; '_a) -&gt; '_a stream
<A NAME="line36"></A>     val cons : '_a * '_a stream -&gt; '_a stream
<A NAME="line37"></A>     val get : '_a stream -&gt; '_a * '_a stream
<A NAME="line38"></A> end
<A NAME="line39"></A>
<A NAME="line40"></A>(* LR_TABLE: signature for an LR Table.
<A NAME="line41"></A>
<A NAME="line42"></A>   The list of actions and gotos passed to mkLrTable must be ordered by state
<A NAME="line43"></A>   number. The values for state 0 are the first in the list, the values for
<A NAME="line44"></A>    state 1 are next, etc.
<A NAME="line45"></A>*)
<A NAME="line46"></A>
<A NAME="line47"></A>signature LR_TABLE =
<A NAME="line48"></A>    sig
<A NAME="line49"></A>        datatype ('a,'b) pairlist = EMPTY | PAIR of 'a * 'b * ('a,'b) pairlist
<A NAME="line50"></A>	datatype state = STATE of int
<A NAME="line51"></A>	datatype term = T of int
<A NAME="line52"></A>	datatype nonterm = NT of int
<A NAME="line53"></A>	datatype action = SHIFT of state
<A NAME="line54"></A>			| REDUCE of int
<A NAME="line55"></A>			| ACCEPT
<A NAME="line56"></A>			| ERROR
<A NAME="line57"></A>	type table
<A NAME="line58"></A>	
<A NAME="line59"></A>	val numStates : table -&gt; int
<A NAME="line60"></A>	val numRules : table -&gt; int
<A NAME="line61"></A>	val describeActions : table -&gt; state -&gt;
<A NAME="line62"></A>				(term,action) pairlist * action
<A NAME="line63"></A>	val describeGoto : table -&gt; state -&gt; (nonterm,state) pairlist
<A NAME="line64"></A>	val action : table -&gt; state * term -&gt; action
<A NAME="line65"></A>	val goto : table -&gt; state * nonterm -&gt; state
<A NAME="line66"></A>	val initialState : table -&gt; state
<A NAME="line67"></A>	exception Goto of state * nonterm
<A NAME="line68"></A>
<A NAME="line69"></A>	val mkLrTable : {actions : ((term,action) pairlist * action) array,
<A NAME="line70"></A>			 gotos : (nonterm,state) pairlist array,
<A NAME="line71"></A>			 numStates : int, numRules : int,
<A NAME="line72"></A>			 initialState : state} -&gt; table
<A NAME="line73"></A>    end
<A NAME="line74"></A>
<A NAME="line75"></A>(* TOKEN: signature revealing the internal structure of a token. This signature
<A NAME="line76"></A>   TOKEN distinct from the signature {parser name}_TOKENS produced by ML-Yacc.
<A NAME="line77"></A>   The {parser name}_TOKENS structures contain some types and functions to
<A NAME="line78"></A>    construct tokens from values and positions.
<A NAME="line79"></A>
<A NAME="line80"></A>   The representation of token was very carefully chosen here to allow the
<A NAME="line81"></A>   polymorphic parser to work without knowing the types of semantic values
<A NAME="line82"></A>   or line numbers.
<A NAME="line83"></A>
<A NAME="line84"></A>   This has had an impact on the TOKENS structure produced by SML-Yacc, which
<A NAME="line85"></A>   is a structure parameter to lexer functors.  We would like to have some
<A NAME="line86"></A>   type 'a token which functions to construct tokens would create.  A
<A NAME="line87"></A>   constructor function for a integer token might be
<A NAME="line88"></A>
<A NAME="line89"></A>	  INT: int * 'a * 'a -&gt; 'a token.
<A NAME="line90"></A> 
<A NAME="line91"></A>   This is not possible because we need to have tokens with the representation
<A NAME="line92"></A>   given below for the polymorphic parser.
<A NAME="line93"></A>
<A NAME="line94"></A>   Thus our constructur functions for tokens have the form:
<A NAME="line95"></A>
<A NAME="line96"></A>	  INT: int * 'a * 'a -&gt; (svalue,'a) token
<A NAME="line97"></A>
<A NAME="line98"></A>   This in turn has had an impact on the signature that lexers for SML-Yacc
<A NAME="line99"></A>   must match and the types that a user must declare in the user declarations
<A NAME="line100"></A>   section of lexers.
<A NAME="line101"></A>*)
<A NAME="line102"></A>
<A NAME="line103"></A>signature TOKEN =
<A NAME="line104"></A>    sig
<A NAME="line105"></A>	structure LrTable : LR_TABLE
<A NAME="line106"></A>        datatype ('a,'b) token = TOKEN of LrTable.term * ('a * 'b * 'b)
<A NAME="line107"></A>	val sameToken : ('a,'b) token * ('a,'b) token -&gt; bool
<A NAME="line108"></A>    end
<A NAME="line109"></A>
<A NAME="line110"></A>(* LR_PARSER: signature for a polymorphic LR parser *)
<A NAME="line111"></A>
<A NAME="line112"></A>signature LR_PARSER =
<A NAME="line113"></A>    sig
<A NAME="line114"></A>	structure Stream: STREAM
<A NAME="line115"></A>	structure LrTable : LR_TABLE
<A NAME="line116"></A>	structure Token : TOKEN
<A NAME="line117"></A>
<A NAME="line118"></A>	sharing LrTable = Token.LrTable
<A NAME="line119"></A>
<A NAME="line120"></A>	exception ParseError
<A NAME="line121"></A>
<A NAME="line122"></A>	val parse : {table : LrTable.table,
<A NAME="line123"></A>		     lexer : ('_b,'_c) Token.token Stream.stream,
<A NAME="line124"></A>		     arg: 'arg,
<A NAME="line125"></A>		     saction : int *
<A NAME="line126"></A>			       '_c *
<A NAME="line127"></A>				(LrTable.state * ('_b * '_c * '_c)) list * 
<A NAME="line128"></A>				'arg -&gt;
<A NAME="line129"></A>				     LrTable.nonterm *
<A NAME="line130"></A>				     ('_b * '_c * '_c) *
<A NAME="line131"></A>				     ((LrTable.state *('_b * '_c * '_c)) list),
<A NAME="line132"></A>		     void : '_b,
<A NAME="line133"></A>		     ec : { is_keyword : LrTable.term -&gt; bool,
<A NAME="line134"></A>			    noShift : LrTable.term -&gt; bool,
<A NAME="line135"></A>			    preferred_change : (LrTable.term list * LrTable.term list) list,
<A NAME="line136"></A>			    errtermvalue : LrTable.term -&gt; '_b,
<A NAME="line137"></A>			    showTerminal : LrTable.term -&gt; string,
<A NAME="line138"></A>			    terms: LrTable.term list,
<A NAME="line139"></A>			    error : string * '_c * '_c -&gt; unit
<A NAME="line140"></A>			   },
<A NAME="line141"></A>		     lookahead : int  (* max amount of lookahead used in *)
<A NAME="line142"></A>				      (* error correction *)
<A NAME="line143"></A>			} -&gt; '_b *
<A NAME="line144"></A>			     (('_b,'_c) Token.token Stream.stream)
<A NAME="line145"></A>    end
<A NAME="line146"></A>
<A NAME="line147"></A>(* LEXER: a signature that most lexers produced for use with SML-Yacc's
<A NAME="line148"></A>   output will match.  The user is responsible for declaring type token,
<A NAME="line149"></A>   type pos, and type svalue in the UserDeclarations section of a lexer.
<A NAME="line150"></A>
<A NAME="line151"></A>   Note that type token is abstract in the lexer.  This allows SML-Yacc to
<A NAME="line152"></A>   create a TOKENS signature for use with lexers produced by ML-Lex that
<A NAME="line153"></A>   treats the type token abstractly.  Lexers that are functors parametrized by
<A NAME="line154"></A>   a Tokens structure matching a TOKENS signature cannot examine the structure
<A NAME="line155"></A>   of tokens.
<A NAME="line156"></A>*)
<A NAME="line157"></A>
<A NAME="line158"></A>signature LEXER =
<A NAME="line159"></A>   sig
<A NAME="line160"></A>       structure UserDeclarations :
<A NAME="line161"></A>	   sig
<A NAME="line162"></A>	        type ('a,'b) token
<A NAME="line163"></A>		type pos
<A NAME="line164"></A>		type svalue
<A NAME="line165"></A>	   end
<A NAME="line166"></A>	val makeLexer : (int -&gt; string) -&gt; unit -&gt; 
<A NAME="line167"></A>         (UserDeclarations.svalue,UserDeclarations.pos) UserDeclarations.token
<A NAME="line168"></A>   end
<A NAME="line169"></A>
<A NAME="line170"></A>(* ARG_LEXER: the %arg option of ML-Lex allows users to produce lexers which
<A NAME="line171"></A>   also take an argument before yielding a function from unit to a token
<A NAME="line172"></A>*)
<A NAME="line173"></A>
<A NAME="line174"></A>signature ARG_LEXER =
<A NAME="line175"></A>   sig
<A NAME="line176"></A>       structure UserDeclarations :
<A NAME="line177"></A>	   sig
<A NAME="line178"></A>	        type ('a,'b) token
<A NAME="line179"></A>		type pos
<A NAME="line180"></A>		type svalue
<A NAME="line181"></A>		type arg
<A NAME="line182"></A>	   end
<A NAME="line183"></A>	val makeLexer : (int -&gt; string) -&gt; UserDeclarations.arg -&gt; unit -&gt; 
<A NAME="line184"></A>         (UserDeclarations.svalue,UserDeclarations.pos) UserDeclarations.token
<A NAME="line185"></A>   end
<A NAME="line186"></A>
<A NAME="line187"></A>(* PARSER_DATA: the signature of ParserData structures in {parser name}LrValsFun
<A NAME="line188"></A>   produced by  SML-Yacc.  All such structures match this signature.  
<A NAME="line189"></A>
<A NAME="line190"></A>   The {parser name}LrValsFun produces a structure which contains all the values
<A NAME="line191"></A>   except for the lexer needed to call the polymorphic parser mentioned
<A NAME="line192"></A>   before.
<A NAME="line193"></A>
<A NAME="line194"></A>*)
<A NAME="line195"></A>
<A NAME="line196"></A>signature PARSER_DATA =
<A NAME="line197"></A>   sig
<A NAME="line198"></A>        (* the type of line numbers *)
<A NAME="line199"></A>
<A NAME="line200"></A>	type pos
<A NAME="line201"></A>
<A NAME="line202"></A>	(* the type of semantic values *)
<A NAME="line203"></A>
<A NAME="line204"></A>	type svalue
<A NAME="line205"></A>
<A NAME="line206"></A>         (* the type of the user-supplied argument to the parser *)
<A NAME="line207"></A> 	type arg
<A NAME="line208"></A> 
<A NAME="line209"></A>	(* the intended type of the result of the parser.  This value is
<A NAME="line210"></A>	   produced by applying extract from the structure Actions to the
<A NAME="line211"></A>	   final semantic value resultiing from a parse.
<A NAME="line212"></A>	 *)
<A NAME="line213"></A>
<A NAME="line214"></A>	type result
<A NAME="line215"></A>
<A NAME="line216"></A>	structure LrTable : LR_TABLE
<A NAME="line217"></A>	structure Token : TOKEN
<A NAME="line218"></A>	sharing Token.LrTable = LrTable
<A NAME="line219"></A>
<A NAME="line220"></A>	(* structure Actions contains the functions which mantain the
<A NAME="line221"></A>	   semantic values stack in the parser.  Void is used to provide
<A NAME="line222"></A>	   a default value for the semantic stack.
<A NAME="line223"></A>	 *)
<A NAME="line224"></A>
<A NAME="line225"></A>	structure Actions : 
<A NAME="line226"></A>	  sig
<A NAME="line227"></A>	      val actions : int * pos *
<A NAME="line228"></A>		   (LrTable.state * (svalue * pos * pos)) list * arg-&gt;
<A NAME="line229"></A>		         LrTable.nonterm * (svalue * pos * pos) *
<A NAME="line230"></A>			 ((LrTable.state *(svalue * pos * pos)) list)
<A NAME="line231"></A>	      val void : svalue
<A NAME="line232"></A>	      val extract : svalue -&gt; result
<A NAME="line233"></A>	  end
<A NAME="line234"></A>
<A NAME="line235"></A>	(* structure EC contains information used to improve error
<A NAME="line236"></A>	   recovery in an error-correcting parser *)
<A NAME="line237"></A>
<A NAME="line238"></A>	structure EC :
<A NAME="line239"></A>	   sig
<A NAME="line240"></A>	     val is_keyword : LrTable.term -&gt; bool
<A NAME="line241"></A>	     val noShift : LrTable.term -&gt; bool
<A NAME="line242"></A> 	     val preferred_change : (LrTable.term list * LrTable.term list) list
<A NAME="line243"></A>	     val errtermvalue : LrTable.term -&gt; svalue
<A NAME="line244"></A>	     val showTerminal : LrTable.term -&gt; string
<A NAME="line245"></A>	     val terms: LrTable.term list
<A NAME="line246"></A>	   end
<A NAME="line247"></A>
<A NAME="line248"></A>	(* table is the LR table for the parser *)
<A NAME="line249"></A>
<A NAME="line250"></A>	val table : LrTable.table
<A NAME="line251"></A>    end
<A NAME="line252"></A>
<A NAME="line253"></A>(* signature PARSER is the signature that most user parsers created by 
<A NAME="line254"></A>   SML-Yacc will match.
<A NAME="line255"></A>*)
<A NAME="line256"></A>
<A NAME="line257"></A>signature PARSER =
<A NAME="line258"></A>    sig
<A NAME="line259"></A>        structure Token : TOKEN
<A NAME="line260"></A>	structure Stream : STREAM
<A NAME="line261"></A>	exception ParseError
<A NAME="line262"></A>
<A NAME="line263"></A>	(* type pos is the type of line numbers *)
<A NAME="line264"></A>
<A NAME="line265"></A>	type pos
<A NAME="line266"></A>
<A NAME="line267"></A>	(* type result is the type of the result from the parser *)
<A NAME="line268"></A>
<A NAME="line269"></A>	type result
<A NAME="line270"></A>
<A NAME="line271"></A>         (* the type of the user-supplied argument to the parser *)
<A NAME="line272"></A> 	type arg
<A NAME="line273"></A>	
<A NAME="line274"></A>	(* type svalue is the type of semantic values for the semantic value
<A NAME="line275"></A>	   stack
<A NAME="line276"></A>	 *)
<A NAME="line277"></A>
<A NAME="line278"></A>	type svalue
<A NAME="line279"></A>
<A NAME="line280"></A>	(* val makeLexer is used to create a stream of tokens for the parser *)
<A NAME="line281"></A>
<A NAME="line282"></A>	val makeLexer : (int -&gt; string) -&gt;
<A NAME="line283"></A>			 (svalue,pos) Token.token Stream.stream
<A NAME="line284"></A>
<A NAME="line285"></A>	(* val parse takes a stream of tokens and a function to print
<A NAME="line286"></A>	   errors and returns a value of type result and a stream containing
<A NAME="line287"></A>	   the unused tokens
<A NAME="line288"></A>	 *)
<A NAME="line289"></A>
<A NAME="line290"></A>	val parse : int * ((svalue,pos) Token.token Stream.stream) *
<A NAME="line291"></A>		    (string * pos * pos -&gt; unit) * arg -&gt;
<A NAME="line292"></A>				result * (svalue,pos) Token.token Stream.stream
<A NAME="line293"></A>
<A NAME="line294"></A>	val sameToken : (svalue,pos) Token.token * (svalue,pos) Token.token -&gt;
<A NAME="line295"></A>				bool
<A NAME="line296"></A>     end
<A NAME="line297"></A>
<A NAME="line298"></A>(* signature ARG_PARSER is the signature that will be matched by parsers whose
<A NAME="line299"></A>    lexer takes an additional argument.
<A NAME="line300"></A>*)
<A NAME="line301"></A>
<A NAME="line302"></A>signature ARG_PARSER = 
<A NAME="line303"></A>    sig
<A NAME="line304"></A>        structure Token : TOKEN
<A NAME="line305"></A>	structure Stream : STREAM
<A NAME="line306"></A>	exception ParseError
<A NAME="line307"></A>
<A NAME="line308"></A>	type arg
<A NAME="line309"></A>	type lexarg
<A NAME="line310"></A>	type pos
<A NAME="line311"></A>	type result
<A NAME="line312"></A>	type svalue
<A NAME="line313"></A>
<A NAME="line314"></A>	val makeLexer : (int -&gt; string) -&gt; lexarg -&gt;
<A NAME="line315"></A>			 (svalue,pos) Token.token Stream.stream
<A NAME="line316"></A>	val parse : int * ((svalue,pos) Token.token Stream.stream) *
<A NAME="line317"></A>		    (string * pos * pos -&gt; unit) * arg -&gt;
<A NAME="line318"></A>				result * (svalue,pos) Token.token Stream.stream
<A NAME="line319"></A>
<A NAME="line320"></A>	val sameToken : (svalue,pos) Token.token * (svalue,pos) Token.token -&gt;
<A NAME="line321"></A>				bool
<A NAME="line322"></A>     end
<A NAME="line323"></A>
<A NAME="line324"></A>
</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="file:///home/michaeln/phol/tools/mlyacc/mlyacclib/MLY_base.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
