<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure EncodeTheory</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure EncodeTheory</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/Boolify/src/EncodeScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>signature EncodeTheory =
<A NAME="line2"></A>sig
<A NAME="line3"></A>  type thm = Thm.thm
<A NAME="line4"></A>  
<A NAME="line5"></A>  (*  Definitions  *)
<A NAME="line6"></A>    val <A HREF="#biprefix_def-val">biprefix_def</A> : thm
<A NAME="line7"></A>    val <A HREF="#collision_free_def-val">collision_free_def</A> : thm
<A NAME="line8"></A>    val <A HREF="#encode_blist_def-val">encode_blist_def</A> : thm
<A NAME="line9"></A>    val <A HREF="#encode_bnum_def-val">encode_bnum_def</A> : thm
<A NAME="line10"></A>    val <A HREF="#encode_bool_def-val">encode_bool_def</A> : thm
<A NAME="line11"></A>    val <A HREF="#encode_list_def-val">encode_list_def</A> : thm
<A NAME="line12"></A>    val <A HREF="#encode_num_primitive_def-val">encode_num_primitive_def</A> : thm
<A NAME="line13"></A>    val <A HREF="#encode_option_def-val">encode_option_def</A> : thm
<A NAME="line14"></A>    val <A HREF="#encode_prod_def-val">encode_prod_def</A> : thm
<A NAME="line15"></A>    val <A HREF="#encode_sum_def-val">encode_sum_def</A> : thm
<A NAME="line16"></A>    val <A HREF="#encode_tree_curried_def-val">encode_tree_curried_def</A> : thm
<A NAME="line17"></A>    val <A HREF="#encode_tree_tupled_primitive_def-val">encode_tree_tupled_primitive_def</A> : thm
<A NAME="line18"></A>    val <A HREF="#encode_unit_def-val">encode_unit_def</A> : thm
<A NAME="line19"></A>    val <A HREF="#lift_blist_def-val">lift_blist_def</A> : thm
<A NAME="line20"></A>    val <A HREF="#lift_option_def-val">lift_option_def</A> : thm
<A NAME="line21"></A>    val <A HREF="#lift_prod_def-val">lift_prod_def</A> : thm
<A NAME="line22"></A>    val <A HREF="#lift_sum_def-val">lift_sum_def</A> : thm
<A NAME="line23"></A>    val <A HREF="#lift_tree_curried_def-val">lift_tree_curried_def</A> : thm
<A NAME="line24"></A>    val <A HREF="#lift_tree_tupled_primitive_def-val">lift_tree_tupled_primitive_def</A> : thm
<A NAME="line25"></A>    val <A HREF="#tree_TY_DEF-val">tree_TY_DEF</A> : thm
<A NAME="line26"></A>    val <A HREF="#tree_case_def-val">tree_case_def</A> : thm
<A NAME="line27"></A>    val <A HREF="#tree_repfns-val">tree_repfns</A> : thm
<A NAME="line28"></A>    val <A HREF="#tree_size_def-val">tree_size_def</A> : thm
<A NAME="line29"></A>    val <A HREF="#wf_encoder_def-val">wf_encoder_def</A> : thm
<A NAME="line30"></A>    val <A HREF="#wf_pred_bnum_def-val">wf_pred_bnum_def</A> : thm
<A NAME="line31"></A>    val <A HREF="#wf_pred_def-val">wf_pred_def</A> : thm
<A NAME="line32"></A>  
<A NAME="line33"></A>  (*  Theorems  *)
<A NAME="line34"></A>    val <A HREF="#biprefix_append-val">biprefix_append</A> : thm
<A NAME="line35"></A>    val <A HREF="#biprefix_appends-val">biprefix_appends</A> : thm
<A NAME="line36"></A>    val <A HREF="#biprefix_cons-val">biprefix_cons</A> : thm
<A NAME="line37"></A>    val <A HREF="#biprefix_refl-val">biprefix_refl</A> : thm
<A NAME="line38"></A>    val <A HREF="#biprefix_sym-val">biprefix_sym</A> : thm
<A NAME="line39"></A>    val <A HREF="#datatype_tree-val">datatype_tree</A> : thm
<A NAME="line40"></A>    val <A HREF="#encode_bnum_inj-val">encode_bnum_inj</A> : thm
<A NAME="line41"></A>    val <A HREF="#encode_bnum_length-val">encode_bnum_length</A> : thm
<A NAME="line42"></A>    val <A HREF="#encode_list_cong-val">encode_list_cong</A> : thm
<A NAME="line43"></A>    val <A HREF="#encode_num_def-val">encode_num_def</A> : thm
<A NAME="line44"></A>    val <A HREF="#encode_num_ind-val">encode_num_ind</A> : thm
<A NAME="line45"></A>    val <A HREF="#encode_prod_alt-val">encode_prod_alt</A> : thm
<A NAME="line46"></A>    val <A HREF="#encode_tree_def-val">encode_tree_def</A> : thm
<A NAME="line47"></A>    val <A HREF="#lift_blist_suc-val">lift_blist_suc</A> : thm
<A NAME="line48"></A>    val <A HREF="#lift_tree_def-val">lift_tree_def</A> : thm
<A NAME="line49"></A>    val <A HREF="#tree_11-val">tree_11</A> : thm
<A NAME="line50"></A>    val <A HREF="#tree_Axiom-val">tree_Axiom</A> : thm
<A NAME="line51"></A>    val <A HREF="#tree_case_cong-val">tree_case_cong</A> : thm
<A NAME="line52"></A>    val <A HREF="#tree_ind-val">tree_ind</A> : thm
<A NAME="line53"></A>    val <A HREF="#tree_induction-val">tree_induction</A> : thm
<A NAME="line54"></A>    val <A HREF="#tree_nchotomy-val">tree_nchotomy</A> : thm
<A NAME="line55"></A>    val <A HREF="#wf_encode_blist-val">wf_encode_blist</A> : thm
<A NAME="line56"></A>    val <A HREF="#wf_encode_bnum-val">wf_encode_bnum</A> : thm
<A NAME="line57"></A>    val <A HREF="#wf_encode_bnum_collision_free-val">wf_encode_bnum_collision_free</A> : thm
<A NAME="line58"></A>    val <A HREF="#wf_encode_bool-val">wf_encode_bool</A> : thm
<A NAME="line59"></A>    val <A HREF="#wf_encode_list-val">wf_encode_list</A> : thm
<A NAME="line60"></A>    val <A HREF="#wf_encode_num-val">wf_encode_num</A> : thm
<A NAME="line61"></A>    val <A HREF="#wf_encode_option-val">wf_encode_option</A> : thm
<A NAME="line62"></A>    val <A HREF="#wf_encode_prod-val">wf_encode_prod</A> : thm
<A NAME="line63"></A>    val <A HREF="#wf_encode_sum-val">wf_encode_sum</A> : thm
<A NAME="line64"></A>    val <A HREF="#wf_encode_tree-val">wf_encode_tree</A> : thm
<A NAME="line65"></A>    val <A HREF="#wf_encode_unit-val">wf_encode_unit</A> : thm
<A NAME="line66"></A>    val <A HREF="#wf_encoder_alt-val">wf_encoder_alt</A> : thm
<A NAME="line67"></A>    val <A HREF="#wf_encoder_eq-val">wf_encoder_eq</A> : thm
<A NAME="line68"></A>    val <A HREF="#wf_encoder_total-val">wf_encoder_total</A> : thm
<A NAME="line69"></A>    val <A HREF="#wf_pred_bnum-val">wf_pred_bnum</A> : thm
<A NAME="line70"></A>    val <A HREF="#wf_pred_bnum_total-val">wf_pred_bnum_total</A> : thm
<A NAME="line71"></A>  
<A NAME="line72"></A>  val Encode_grammars : type_grammar.grammar * term_grammar.grammar
<A NAME="line73"></A>  
<A NAME="line74"></A>  
<A NAME="line75"></A>(*
   [rich_list] Parent theory of "Encode"
   
   [<A NAME="biprefix_def-val"><B>biprefix_def</B></A>]  Definition
      
      |- !a b. biprefix a b &lt;=&gt; b &lt;&lt;= a \/ a &lt;&lt;= b
   
   [<A NAME="collision_free_def-val"><B>collision_free_def</B></A>]  Definition
      
      |- !m p.
           collision_free m p &lt;=&gt;
           !x y. p x /\ p y /\ (x MOD 2 ** m = y MOD 2 ** m) ==&gt; (x = y)
   
   [<A NAME="encode_blist_def-val"><B>encode_blist_def</B></A>]  Definition
      
      |- (!e l. encode_blist 0 e l = []) /\
         !m e l.
           encode_blist (SUC m) e l = e (HD l) ++ encode_blist m e (TL l)
   
   [<A NAME="encode_bnum_def-val"><B>encode_bnum_def</B></A>]  Definition
      
      |- (!n. encode_bnum 0 n = []) /\
         !m n. encode_bnum (SUC m) n = ~EVEN n::encode_bnum m (n DIV 2)
   
   [<A NAME="encode_bool_def-val"><B>encode_bool_def</B></A>]  Definition
      
      |- !x. encode_bool x = [x]
   
   [<A NAME="encode_list_def-val"><B>encode_list_def</B></A>]  Definition
      
      |- (!xb. encode_list xb [] = [F]) /\
         !xb x xs. encode_list xb (x::xs) = T::(xb x ++ encode_list xb xs)
   
   [<A NAME="encode_num_primitive_def-val"><B>encode_num_primitive_def</B></A>]  Definition
      
      |- encode_num =
         WFREC
           (@R.
              WF R /\ (!n. n &lt;&gt; 0 /\ EVEN n ==&gt; R ((n - 2) DIV 2) n) /\
              !n. n &lt;&gt; 0 /\ ~EVEN n ==&gt; R ((n - 1) DIV 2) n)
           (\encode_num n.
              I
                (if n = 0 then
                   [T; T]
                 else
                   if EVEN n then
                     F::encode_num ((n - 2) DIV 2)
                   else
                     T::F::encode_num ((n - 1) DIV 2)))
   
   [<A NAME="encode_option_def-val"><B>encode_option_def</B></A>]  Definition
      
      |- (!xb. encode_option xb NONE = [F]) /\
         !xb x. encode_option xb (SOME x) = T::xb x
   
   [<A NAME="encode_prod_def-val"><B>encode_prod_def</B></A>]  Definition
      
      |- !xb yb x y. encode_prod xb yb (x,y) = xb x ++ yb y
   
   [<A NAME="encode_sum_def-val"><B>encode_sum_def</B></A>]  Definition
      
      |- (!xb yb x. encode_sum xb yb (INL x) = T::xb x) /\
         !xb yb y. encode_sum xb yb (INR y) = F::yb y
   
   [<A NAME="encode_tree_curried_def-val"><B>encode_tree_curried_def</B></A>]  Definition
      
      |- !x x1. encode_tree x x1 = encode_tree_tupled (x,x1)
   
   [<A NAME="encode_tree_tupled_primitive_def-val"><B>encode_tree_tupled_primitive_def</B></A>]  Definition
      
      |- encode_tree_tupled =
         WFREC
           (@R. WF R /\ !a e ts a'. MEM a' ts ==&gt; R (e,a') (e,Node a ts))
           (\encode_tree_tupled a'.
              case a' of
                 (e,Node a ts) -&gt;
                   I
                     (e a ++
                      encode_list (\a. encode_tree_tupled (e,a)) ts))
   
   [<A NAME="encode_unit_def-val"><B>encode_unit_def</B></A>]  Definition
      
      |- !v0. encode_unit v0 = []
   
   [<A NAME="lift_blist_def-val"><B>lift_blist_def</B></A>]  Definition
      
      |- !m p x. lift_blist m p x &lt;=&gt; EVERY p x /\ (LENGTH x = m)
   
   [<A NAME="lift_option_def-val"><B>lift_option_def</B></A>]  Definition
      
      |- !p x. lift_option p x &lt;=&gt; case x of NONE -&gt; T || SOME y -&gt; p y
   
   [<A NAME="lift_prod_def-val"><B>lift_prod_def</B></A>]  Definition
      
      |- !p1 p2 x. lift_prod p1 p2 x &lt;=&gt; p1 (FST x) /\ p2 (SND x)
   
   [<A NAME="lift_sum_def-val"><B>lift_sum_def</B></A>]  Definition
      
      |- !p1 p2 x.
           lift_sum p1 p2 x &lt;=&gt;
           case x of INL x1 -&gt; p1 x1 || INR x2 -&gt; p2 x2
   
   [<A NAME="lift_tree_curried_def-val"><B>lift_tree_curried_def</B></A>]  Definition
      
      |- !x x1. lift_tree x x1 &lt;=&gt; lift_tree_tupled (x,x1)
   
   [<A NAME="lift_tree_tupled_primitive_def-val"><B>lift_tree_tupled_primitive_def</B></A>]  Definition
      
      |- lift_tree_tupled =
         WFREC
           (@R. WF R /\ !a p ts a'. MEM a' ts ==&gt; R (p,a') (p,Node a ts))
           (\lift_tree_tupled a'.
              case a' of
                 (p,Node a ts) -&gt;
                   I (p a /\ EVERY (\a. lift_tree_tupled (p,a)) ts))
   
   [<A NAME="tree_TY_DEF-val"><B>tree_TY_DEF</B></A>]  Definition
      
      |- ?rep.
           TYPE_DEFINITION
             (\a0'.
                !'tree' 'list @ind_typeEncode0' .
                  (!a0'.
                     (?a0 a1.
                        (a0' =
                         (\a0 a1.
                            ind_type$CONSTR 0 a0
                              (ind_type$FCONS a1 (\n. ind_type$BOTTOM))) a0
                           a1) /\ 'list @ind_typeEncode0' a1) ==&gt;
                     'tree' a0') /\
                  (!a1'.
                     (a1' =
                      ind_type$CONSTR (SUC 0) ARB (\n. ind_type$BOTTOM)) \/
                     (?a0 a1.
                        (a1' =
                         (\a0 a1.
                            ind_type$CONSTR (SUC (SUC 0)) ARB
                              (ind_type$FCONS a0
                                 (ind_type$FCONS a1
                                    (\n. ind_type$BOTTOM)))) a0 a1) /\
                        'tree' a0 /\ 'list @ind_typeEncode0' a1) ==&gt;
                     'list @ind_typeEncode0' a1') ==&gt;
                  'tree' a0') rep
   
   [<A NAME="tree_case_def-val"><B>tree_case_def</B></A>]  Definition
      
      |- !f a0 a1. tree_case f (Node a0 a1) = f a0 a1
   
   [<A NAME="tree_repfns-val"><B>tree_repfns</B></A>]  Definition
      
      |- (!a. mk_tree (dest_tree a) = a) /\
         !r.
           (\a0'.
              !'tree' 'list @ind_typeEncode0' .
                (!a0'.
                   (?a0 a1.
                      (a0' =
                       (\a0 a1.
                          ind_type$CONSTR 0 a0
                            (ind_type$FCONS a1 (\n. ind_type$BOTTOM))) a0
                         a1) /\ 'list @ind_typeEncode0' a1) ==&gt;
                   'tree' a0') /\
                (!a1'.
                   (a1' =
                    ind_type$CONSTR (SUC 0) ARB (\n. ind_type$BOTTOM)) \/
                   (?a0 a1.
                      (a1' =
                       (\a0 a1.
                          ind_type$CONSTR (SUC (SUC 0)) ARB
                            (ind_type$FCONS a0
                               (ind_type$FCONS a1 (\n. ind_type$BOTTOM))))
                         a0 a1) /\ 'tree' a0 /\
                      'list @ind_typeEncode0' a1) ==&gt;
                   'list @ind_typeEncode0' a1') ==&gt;
                'tree' a0') r &lt;=&gt; (dest_tree (mk_tree r) = r)
   
   [<A NAME="tree_size_def-val"><B>tree_size_def</B></A>]  Definition
      
      |- (!f a0 a1.
            tree_size f (Node a0 a1) = 1 + (f a0 + tree1_size f a1)) /\
         (!f. tree1_size f [] = 0) /\
         !f a0 a1.
           tree1_size f (a0::a1) = 1 + (tree_size f a0 + tree1_size f a1)
   
   [<A NAME="wf_encoder_def-val"><B>wf_encoder_def</B></A>]  Definition
      
      |- !p e.
           wf_encoder p e &lt;=&gt; !x y. p x /\ p y /\ e y &lt;&lt;= e x ==&gt; (x = y)
   
   [<A NAME="wf_pred_bnum_def-val"><B>wf_pred_bnum_def</B></A>]  Definition
      
      |- !m p. wf_pred_bnum m p &lt;=&gt; wf_pred p /\ !x. p x ==&gt; x &lt; 2 ** m
   
   [<A NAME="wf_pred_def-val"><B>wf_pred_def</B></A>]  Definition
      
      |- !p. wf_pred p &lt;=&gt; ?x. p x
   
   [<A NAME="biprefix_append-val"><B>biprefix_append</B></A>]  Theorem
      
      |- !a b c d. biprefix (a ++ b) (c ++ d) ==&gt; biprefix a c
   
   [<A NAME="biprefix_appends-val"><B>biprefix_appends</B></A>]  Theorem
      
      |- !a b c. biprefix (a ++ b) (a ++ c) &lt;=&gt; biprefix b c
   
   [<A NAME="biprefix_cons-val"><B>biprefix_cons</B></A>]  Theorem
      
      |- !a b c d. biprefix (a::b) (c::d) &lt;=&gt; (a = c) /\ biprefix b d
   
   [<A NAME="biprefix_refl-val"><B>biprefix_refl</B></A>]  Theorem
      
      |- !x. biprefix x x
   
   [<A NAME="biprefix_sym-val"><B>biprefix_sym</B></A>]  Theorem
      
      |- !x y. biprefix x y ==&gt; biprefix y x
   
   [<A NAME="datatype_tree-val"><B>datatype_tree</B></A>]  Theorem
      
      |- DATATYPE (tree Node)
   
   [<A NAME="encode_bnum_inj-val"><B>encode_bnum_inj</B></A>]  Theorem
      
      |- !m x y.
           x &lt; 2 ** m /\ y &lt; 2 ** m /\
           (encode_bnum m x = encode_bnum m y) ==&gt;
           (x = y)
   
   [<A NAME="encode_bnum_length-val"><B>encode_bnum_length</B></A>]  Theorem
      
      |- !m n. LENGTH (encode_bnum m n) = m
   
   [<A NAME="encode_list_cong-val"><B>encode_list_cong</B></A>]  Theorem
      
      |- !l1 l2 f1 f2.
           (l1 = l2) /\ (!x. MEM x l2 ==&gt; (f1 x = f2 x)) ==&gt;
           (encode_list f1 l1 = encode_list f2 l2)
   
   [<A NAME="encode_num_def-val"><B>encode_num_def</B></A>]  Theorem
      
      |- encode_num n =
         if n = 0 then
           [T; T]
         else
           if EVEN n then
             F::encode_num ((n - 2) DIV 2)
           else
             T::F::encode_num ((n - 1) DIV 2)
   
   [<A NAME="encode_num_ind-val"><B>encode_num_ind</B></A>]  Theorem
      
      |- !P.
           (!n.
              (n &lt;&gt; 0 /\ EVEN n ==&gt; P ((n - 2) DIV 2)) /\
              (n &lt;&gt; 0 /\ ~EVEN n ==&gt; P ((n - 1) DIV 2)) ==&gt;
              P n) ==&gt;
           !v. P v
   
   [<A NAME="encode_prod_alt-val"><B>encode_prod_alt</B></A>]  Theorem
      
      |- !xb yb p. encode_prod xb yb p = xb (FST p) ++ yb (SND p)
   
   [<A NAME="encode_tree_def-val"><B>encode_tree_def</B></A>]  Theorem
      
      |- encode_tree e (Node a ts) = e a ++ encode_list (encode_tree e) ts
   
   [<A NAME="lift_blist_suc-val"><B>lift_blist_suc</B></A>]  Theorem
      
      |- !n p h t. lift_blist (SUC n) p (h::t) &lt;=&gt; p h /\ lift_blist n p t
   
   [<A NAME="lift_tree_def-val"><B>lift_tree_def</B></A>]  Theorem
      
      |- lift_tree p (Node a ts) &lt;=&gt; p a /\ EVERY (lift_tree p) ts
   
   [<A NAME="tree_11-val"><B>tree_11</B></A>]  Theorem
      
      |- !a0 a1 a0' a1'.
           (Node a0 a1 = Node a0' a1') &lt;=&gt; (a0 = a0') /\ (a1 = a1')
   
   [<A NAME="tree_Axiom-val"><B>tree_Axiom</B></A>]  Theorem
      
      |- !f0 f1 f2.
           ?fn0 fn1.
             (!a0 a1. fn0 (Node a0 a1) = f0 a0 a1 (fn1 a1)) /\
             (fn1 [] = f1) /\
             !a0 a1. fn1 (a0::a1) = f2 a0 a1 (fn0 a0) (fn1 a1)
   
   [<A NAME="tree_case_cong-val"><B>tree_case_cong</B></A>]  Theorem
      
      |- !M M' f.
           (M = M') /\
           (!a0 a1. (M' = Node a0 a1) ==&gt; (f a0 a1 = f' a0 a1)) ==&gt;
           (tree_case f M = tree_case f' M')
   
   [<A NAME="tree_ind-val"><B>tree_ind</B></A>]  Theorem
      
      |- !p. (!a ts. (!t. MEM t ts ==&gt; p t) ==&gt; p (Node a ts)) ==&gt; !t. p t
   
   [<A NAME="tree_induction-val"><B>tree_induction</B></A>]  Theorem
      
      |- !P0 P1.
           (!l. P1 l ==&gt; !a. P0 (Node a l)) /\ P1 [] /\
           (!t l. P0 t /\ P1 l ==&gt; P1 (t::l)) ==&gt;
           (!t. P0 t) /\ !l. P1 l
   
   [<A NAME="tree_nchotomy-val"><B>tree_nchotomy</B></A>]  Theorem
      
      |- !tt. ?a l. tt = Node a l
   
   [<A NAME="wf_encode_blist-val"><B>wf_encode_blist</B></A>]  Theorem
      
      |- !m p e.
           wf_encoder p e ==&gt;
           wf_encoder (lift_blist m p) (encode_blist m e)
   
   [<A NAME="wf_encode_bnum-val"><B>wf_encode_bnum</B></A>]  Theorem
      
      |- !m p. wf_pred_bnum m p ==&gt; wf_encoder p (encode_bnum m)
   
   [<A NAME="wf_encode_bnum_collision_free-val"><B>wf_encode_bnum_collision_free</B></A>]  Theorem
      
      |- !m p. wf_encoder p (encode_bnum m) &lt;=&gt; collision_free m p
   
   [<A NAME="wf_encode_bool-val"><B>wf_encode_bool</B></A>]  Theorem
      
      |- !p. wf_encoder p encode_bool
   
   [<A NAME="wf_encode_list-val"><B>wf_encode_list</B></A>]  Theorem
      
      |- !p e. wf_encoder p e ==&gt; wf_encoder (EVERY p) (encode_list e)
   
   [<A NAME="wf_encode_num-val"><B>wf_encode_num</B></A>]  Theorem
      
      |- !p. wf_encoder p encode_num
   
   [<A NAME="wf_encode_option-val"><B>wf_encode_option</B></A>]  Theorem
      
      |- !p e.
           wf_encoder p e ==&gt; wf_encoder (lift_option p) (encode_option e)
   
   [<A NAME="wf_encode_prod-val"><B>wf_encode_prod</B></A>]  Theorem
      
      |- !p1 p2 e1 e2.
           wf_encoder p1 e1 /\ wf_encoder p2 e2 ==&gt;
           wf_encoder (lift_prod p1 p2) (encode_prod e1 e2)
   
   [<A NAME="wf_encode_sum-val"><B>wf_encode_sum</B></A>]  Theorem
      
      |- !p1 p2 e1 e2.
           wf_encoder p1 e1 /\ wf_encoder p2 e2 ==&gt;
           wf_encoder (lift_sum p1 p2) (encode_sum e1 e2)
   
   [<A NAME="wf_encode_tree-val"><B>wf_encode_tree</B></A>]  Theorem
      
      |- !p e. wf_encoder p e ==&gt; wf_encoder (lift_tree p) (encode_tree e)
   
   [<A NAME="wf_encode_unit-val"><B>wf_encode_unit</B></A>]  Theorem
      
      |- !p. wf_encoder p encode_unit
   
   [<A NAME="wf_encoder_alt-val"><B>wf_encoder_alt</B></A>]  Theorem
      
      |- wf_encoder p e &lt;=&gt;
         !x y. p x /\ p y /\ biprefix (e x) (e y) ==&gt; (x = y)
   
   [<A NAME="wf_encoder_eq-val"><B>wf_encoder_eq</B></A>]  Theorem
      
      |- !p e f.
           wf_encoder p e /\ (!x. p x ==&gt; (e x = f x)) ==&gt; wf_encoder p f
   
   [<A NAME="wf_encoder_total-val"><B>wf_encoder_total</B></A>]  Theorem
      
      |- !p e. wf_encoder (K T) e ==&gt; wf_encoder p e
   
   [<A NAME="wf_pred_bnum-val"><B>wf_pred_bnum</B></A>]  Theorem
      
      |- !m p. wf_pred_bnum m p ==&gt; collision_free m p
   
   [<A NAME="wf_pred_bnum_total-val"><B>wf_pred_bnum_total</B></A>]  Theorem
      
      |- !m. wf_pred_bnum m (\x. x &lt; 2 ** m)
   
   
*)
end

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/Boolify/src/EncodeScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
