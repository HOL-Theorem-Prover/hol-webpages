<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure pred_setTheory</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure pred_setTheory</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/pred_set/src/pred_setScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>signature pred_setTheory =
<A NAME="line2"></A>sig
<A NAME="line3"></A>  type thm = Thm.thm
<A NAME="line4"></A>  
<A NAME="line5"></A>  (*  Definitions  *)
<A NAME="line6"></A>    val <A HREF="#BIGINTER-val">BIGINTER</A> : thm
<A NAME="line7"></A>    val <A HREF="#BIGUNION-val">BIGUNION</A> : thm
<A NAME="line8"></A>    val <A HREF="#BIJ_DEF-val">BIJ_DEF</A> : thm
<A NAME="line9"></A>    val <A HREF="#CARD_DEF-val">CARD_DEF</A> : thm
<A NAME="line10"></A>    val <A HREF="#CHOICE_DEF-val">CHOICE_DEF</A> : thm
<A NAME="line11"></A>    val <A HREF="#COMPL_DEF-val">COMPL_DEF</A> : thm
<A NAME="line12"></A>    val <A HREF="#CROSS_DEF-val">CROSS_DEF</A> : thm
<A NAME="line13"></A>    val <A HREF="#DELETE_DEF-val">DELETE_DEF</A> : thm
<A NAME="line14"></A>    val <A HREF="#DIFF_DEF-val">DIFF_DEF</A> : thm
<A NAME="line15"></A>    val <A HREF="#DISJOINT_DEF-val">DISJOINT_DEF</A> : thm
<A NAME="line16"></A>    val <A HREF="#EMPTY_DEF-val">EMPTY_DEF</A> : thm
<A NAME="line17"></A>    val <A HREF="#FINITE_DEF-val">FINITE_DEF</A> : thm
<A NAME="line18"></A>    val <A HREF="#GSPECIFICATION-val">GSPECIFICATION</A> : thm
<A NAME="line19"></A>    val <A HREF="#IMAGE_DEF-val">IMAGE_DEF</A> : thm
<A NAME="line20"></A>    val <A HREF="#INFINITE_DEF-val">INFINITE_DEF</A> : thm
<A NAME="line21"></A>    val <A HREF="#INJ_DEF-val">INJ_DEF</A> : thm
<A NAME="line22"></A>    val <A HREF="#INSERT_DEF-val">INSERT_DEF</A> : thm
<A NAME="line23"></A>    val <A HREF="#INTER_DEF-val">INTER_DEF</A> : thm
<A NAME="line24"></A>    val <A HREF="#ITSET_curried_def-val">ITSET_curried_def</A> : thm
<A NAME="line25"></A>    val <A HREF="#ITSET_tupled_primitive_def-val">ITSET_tupled_primitive_def</A> : thm
<A NAME="line26"></A>    val <A HREF="#LINV_DEF-val">LINV_DEF</A> : thm
<A NAME="line27"></A>    val <A HREF="#MAX_SET_DEF-val">MAX_SET_DEF</A> : thm
<A NAME="line28"></A>    val <A HREF="#MIN_SET_DEF-val">MIN_SET_DEF</A> : thm
<A NAME="line29"></A>    val <A HREF="#POW_DEF-val">POW_DEF</A> : thm
<A NAME="line30"></A>    val <A HREF="#PSUBSET_DEF-val">PSUBSET_DEF</A> : thm
<A NAME="line31"></A>    val <A HREF="#REST_DEF-val">REST_DEF</A> : thm
<A NAME="line32"></A>    val <A HREF="#RINV_DEF-val">RINV_DEF</A> : thm
<A NAME="line33"></A>    val <A HREF="#SING_DEF-val">SING_DEF</A> : thm
<A NAME="line34"></A>    val <A HREF="#SUBSET_DEF-val">SUBSET_DEF</A> : thm
<A NAME="line35"></A>    val <A HREF="#SUM_IMAGE_DEF-val">SUM_IMAGE_DEF</A> : thm
<A NAME="line36"></A>    val <A HREF="#SUM_SET_DEF-val">SUM_SET_DEF</A> : thm
<A NAME="line37"></A>    val <A HREF="#SURJ_DEF-val">SURJ_DEF</A> : thm
<A NAME="line38"></A>    val <A HREF="#UNION_DEF-val">UNION_DEF</A> : thm
<A NAME="line39"></A>    val <A HREF="#UNIV_DEF-val">UNIV_DEF</A> : thm
<A NAME="line40"></A>    val <A HREF="#chooser_def-val">chooser_def</A> : thm
<A NAME="line41"></A>    val <A HREF="#count_def-val">count_def</A> : thm
<A NAME="line42"></A>    val <A HREF="#countable_def-val">countable_def</A> : thm
<A NAME="line43"></A>    val <A HREF="#equiv_on_def-val">equiv_on_def</A> : thm
<A NAME="line44"></A>    val <A HREF="#num_to_pair_def-val">num_to_pair_def</A> : thm
<A NAME="line45"></A>    val <A HREF="#pair_to_num_primitive_def-val">pair_to_num_primitive_def</A> : thm
<A NAME="line46"></A>    val <A HREF="#partition_def-val">partition_def</A> : thm
<A NAME="line47"></A>  
<A NAME="line48"></A>  (*  Theorems  *)
<A NAME="line49"></A>    val <A HREF="#ABSORPTION-val">ABSORPTION</A> : thm
<A NAME="line50"></A>    val <A HREF="#BIGINTER_EMPTY-val">BIGINTER_EMPTY</A> : thm
<A NAME="line51"></A>    val <A HREF="#BIGINTER_INSERT-val">BIGINTER_INSERT</A> : thm
<A NAME="line52"></A>    val <A HREF="#BIGINTER_INTER-val">BIGINTER_INTER</A> : thm
<A NAME="line53"></A>    val <A HREF="#BIGINTER_SING-val">BIGINTER_SING</A> : thm
<A NAME="line54"></A>    val <A HREF="#BIGUNION_EMPTY-val">BIGUNION_EMPTY</A> : thm
<A NAME="line55"></A>    val <A HREF="#BIGUNION_EQ_EMPTY-val">BIGUNION_EQ_EMPTY</A> : thm
<A NAME="line56"></A>    val <A HREF="#BIGUNION_INSERT-val">BIGUNION_INSERT</A> : thm
<A NAME="line57"></A>    val <A HREF="#BIGUNION_SING-val">BIGUNION_SING</A> : thm
<A NAME="line58"></A>    val <A HREF="#BIGUNION_SUBSET-val">BIGUNION_SUBSET</A> : thm
<A NAME="line59"></A>    val <A HREF="#BIGUNION_UNION-val">BIGUNION_UNION</A> : thm
<A NAME="line60"></A>    val <A HREF="#BIGUNION_partition-val">BIGUNION_partition</A> : thm
<A NAME="line61"></A>    val <A HREF="#BIJ_COMPOSE-val">BIJ_COMPOSE</A> : thm
<A NAME="line62"></A>    val <A HREF="#BIJ_DELETE-val">BIJ_DELETE</A> : thm
<A NAME="line63"></A>    val <A HREF="#BIJ_EMPTY-val">BIJ_EMPTY</A> : thm
<A NAME="line64"></A>    val <A HREF="#BIJ_ID-val">BIJ_ID</A> : thm
<A NAME="line65"></A>    val <A HREF="#BIJ_LINV_BIJ-val">BIJ_LINV_BIJ</A> : thm
<A NAME="line66"></A>    val <A HREF="#BIJ_LINV_INV-val">BIJ_LINV_INV</A> : thm
<A NAME="line67"></A>    val <A HREF="#CARD_COUNT-val">CARD_COUNT</A> : thm
<A NAME="line68"></A>    val <A HREF="#CARD_CROSS-val">CARD_CROSS</A> : thm
<A NAME="line69"></A>    val <A HREF="#CARD_DELETE-val">CARD_DELETE</A> : thm
<A NAME="line70"></A>    val <A HREF="#CARD_DIFF-val">CARD_DIFF</A> : thm
<A NAME="line71"></A>    val <A HREF="#CARD_EMPTY-val">CARD_EMPTY</A> : thm
<A NAME="line72"></A>    val <A HREF="#CARD_EQ_0-val">CARD_EQ_0</A> : thm
<A NAME="line73"></A>    val <A HREF="#CARD_INSERT-val">CARD_INSERT</A> : thm
<A NAME="line74"></A>    val <A HREF="#CARD_INTER_LESS_EQ-val">CARD_INTER_LESS_EQ</A> : thm
<A NAME="line75"></A>    val <A HREF="#CARD_POW-val">CARD_POW</A> : thm
<A NAME="line76"></A>    val <A HREF="#CARD_PSUBSET-val">CARD_PSUBSET</A> : thm
<A NAME="line77"></A>    val <A HREF="#CARD_SING-val">CARD_SING</A> : thm
<A NAME="line78"></A>    val <A HREF="#CARD_SING_CROSS-val">CARD_SING_CROSS</A> : thm
<A NAME="line79"></A>    val <A HREF="#CARD_SUBSET-val">CARD_SUBSET</A> : thm
<A NAME="line80"></A>    val <A HREF="#CARD_UNION-val">CARD_UNION</A> : thm
<A NAME="line81"></A>    val <A HREF="#CHOICE_INSERT_REST-val">CHOICE_INSERT_REST</A> : thm
<A NAME="line82"></A>    val <A HREF="#CHOICE_NOT_IN_REST-val">CHOICE_NOT_IN_REST</A> : thm
<A NAME="line83"></A>    val <A HREF="#CHOICE_SING-val">CHOICE_SING</A> : thm
<A NAME="line84"></A>    val <A HREF="#COMMUTING_ITSET_INSERT-val">COMMUTING_ITSET_INSERT</A> : thm
<A NAME="line85"></A>    val <A HREF="#COMMUTING_ITSET_RECURSES-val">COMMUTING_ITSET_RECURSES</A> : thm
<A NAME="line86"></A>    val <A HREF="#COMPL_CLAUSES-val">COMPL_CLAUSES</A> : thm
<A NAME="line87"></A>    val <A HREF="#COMPL_COMPL-val">COMPL_COMPL</A> : thm
<A NAME="line88"></A>    val <A HREF="#COMPL_EMPTY-val">COMPL_EMPTY</A> : thm
<A NAME="line89"></A>    val <A HREF="#COMPL_INTER-val">COMPL_INTER</A> : thm
<A NAME="line90"></A>    val <A HREF="#COMPL_SPLITS-val">COMPL_SPLITS</A> : thm
<A NAME="line91"></A>    val <A HREF="#COMPONENT-val">COMPONENT</A> : thm
<A NAME="line92"></A>    val <A HREF="#COUNT_SUC-val">COUNT_SUC</A> : thm
<A NAME="line93"></A>    val <A HREF="#COUNT_ZERO-val">COUNT_ZERO</A> : thm
<A NAME="line94"></A>    val <A HREF="#CROSS_EMPTY-val">CROSS_EMPTY</A> : thm
<A NAME="line95"></A>    val <A HREF="#CROSS_EQNS-val">CROSS_EQNS</A> : thm
<A NAME="line96"></A>    val <A HREF="#CROSS_INSERT_LEFT-val">CROSS_INSERT_LEFT</A> : thm
<A NAME="line97"></A>    val <A HREF="#CROSS_INSERT_RIGHT-val">CROSS_INSERT_RIGHT</A> : thm
<A NAME="line98"></A>    val <A HREF="#CROSS_SINGS-val">CROSS_SINGS</A> : thm
<A NAME="line99"></A>    val <A HREF="#CROSS_SUBSET-val">CROSS_SUBSET</A> : thm
<A NAME="line100"></A>    val <A HREF="#DECOMPOSITION-val">DECOMPOSITION</A> : thm
<A NAME="line101"></A>    val <A HREF="#DELETE_COMM-val">DELETE_COMM</A> : thm
<A NAME="line102"></A>    val <A HREF="#DELETE_DELETE-val">DELETE_DELETE</A> : thm
<A NAME="line103"></A>    val <A HREF="#DELETE_EQ_SING-val">DELETE_EQ_SING</A> : thm
<A NAME="line104"></A>    val <A HREF="#DELETE_INSERT-val">DELETE_INSERT</A> : thm
<A NAME="line105"></A>    val <A HREF="#DELETE_INTER-val">DELETE_INTER</A> : thm
<A NAME="line106"></A>    val <A HREF="#DELETE_NON_ELEMENT-val">DELETE_NON_ELEMENT</A> : thm
<A NAME="line107"></A>    val <A HREF="#DELETE_SUBSET-val">DELETE_SUBSET</A> : thm
<A NAME="line108"></A>    val <A HREF="#DELETE_SUBSET_INSERT-val">DELETE_SUBSET_INSERT</A> : thm
<A NAME="line109"></A>    val <A HREF="#DIFF_DIFF-val">DIFF_DIFF</A> : thm
<A NAME="line110"></A>    val <A HREF="#DIFF_EMPTY-val">DIFF_EMPTY</A> : thm
<A NAME="line111"></A>    val <A HREF="#DIFF_EQ_EMPTY-val">DIFF_EQ_EMPTY</A> : thm
<A NAME="line112"></A>    val <A HREF="#DIFF_INSERT-val">DIFF_INSERT</A> : thm
<A NAME="line113"></A>    val <A HREF="#DIFF_SUBSET-val">DIFF_SUBSET</A> : thm
<A NAME="line114"></A>    val <A HREF="#DIFF_UNIV-val">DIFF_UNIV</A> : thm
<A NAME="line115"></A>    val <A HREF="#DISJOINT_BIGINTER-val">DISJOINT_BIGINTER</A> : thm
<A NAME="line116"></A>    val <A HREF="#DISJOINT_BIGUNION-val">DISJOINT_BIGUNION</A> : thm
<A NAME="line117"></A>    val <A HREF="#DISJOINT_DELETE_SYM-val">DISJOINT_DELETE_SYM</A> : thm
<A NAME="line118"></A>    val <A HREF="#DISJOINT_EMPTY-val">DISJOINT_EMPTY</A> : thm
<A NAME="line119"></A>    val <A HREF="#DISJOINT_EMPTY_REFL-val">DISJOINT_EMPTY_REFL</A> : thm
<A NAME="line120"></A>    val <A HREF="#DISJOINT_EMPTY_REFL_RWT-val">DISJOINT_EMPTY_REFL_RWT</A> : thm
<A NAME="line121"></A>    val <A HREF="#DISJOINT_INSERT-val">DISJOINT_INSERT</A> : thm
<A NAME="line122"></A>    val <A HREF="#DISJOINT_SING_EMPTY-val">DISJOINT_SING_EMPTY</A> : thm
<A NAME="line123"></A>    val <A HREF="#DISJOINT_SUBSET-val">DISJOINT_SUBSET</A> : thm
<A NAME="line124"></A>    val <A HREF="#DISJOINT_SYM-val">DISJOINT_SYM</A> : thm
<A NAME="line125"></A>    val <A HREF="#DISJOINT_UNION-val">DISJOINT_UNION</A> : thm
<A NAME="line126"></A>    val <A HREF="#DISJOINT_UNION_BOTH-val">DISJOINT_UNION_BOTH</A> : thm
<A NAME="line127"></A>    val <A HREF="#EMPTY_DELETE-val">EMPTY_DELETE</A> : thm
<A NAME="line128"></A>    val <A HREF="#EMPTY_DIFF-val">EMPTY_DIFF</A> : thm
<A NAME="line129"></A>    val <A HREF="#EMPTY_NOT_IN_partition-val">EMPTY_NOT_IN_partition</A> : thm
<A NAME="line130"></A>    val <A HREF="#EMPTY_NOT_UNIV-val">EMPTY_NOT_UNIV</A> : thm
<A NAME="line131"></A>    val <A HREF="#EMPTY_SUBSET-val">EMPTY_SUBSET</A> : thm
<A NAME="line132"></A>    val <A HREF="#EMPTY_UNION-val">EMPTY_UNION</A> : thm
<A NAME="line133"></A>    val <A HREF="#EQUAL_SING-val">EQUAL_SING</A> : thm
<A NAME="line134"></A>    val <A HREF="#EQ_UNIV-val">EQ_UNIV</A> : thm
<A NAME="line135"></A>    val <A HREF="#EXTENSION-val">EXTENSION</A> : thm
<A NAME="line136"></A>    val <A HREF="#FINITELY_INJECTIVE_IMAGE_FINITE-val">FINITELY_INJECTIVE_IMAGE_FINITE</A> : thm
<A NAME="line137"></A>    val <A HREF="#FINITE_BIGUNION-val">FINITE_BIGUNION</A> : thm
<A NAME="line138"></A>    val <A HREF="#FINITE_BIGUNION_EQ-val">FINITE_BIGUNION_EQ</A> : thm
<A NAME="line139"></A>    val <A HREF="#FINITE_BIJ_CARD_EQ-val">FINITE_BIJ_CARD_EQ</A> : thm
<A NAME="line140"></A>    val <A HREF="#FINITE_COMPLETE_INDUCTION-val">FINITE_COMPLETE_INDUCTION</A> : thm
<A NAME="line141"></A>    val <A HREF="#FINITE_COUNT-val">FINITE_COUNT</A> : thm
<A NAME="line142"></A>    val <A HREF="#FINITE_CROSS-val">FINITE_CROSS</A> : thm
<A NAME="line143"></A>    val <A HREF="#FINITE_CROSS_EQ-val">FINITE_CROSS_EQ</A> : thm
<A NAME="line144"></A>    val <A HREF="#FINITE_DELETE-val">FINITE_DELETE</A> : thm
<A NAME="line145"></A>    val <A HREF="#FINITE_DIFF-val">FINITE_DIFF</A> : thm
<A NAME="line146"></A>    val <A HREF="#FINITE_DIFF_down-val">FINITE_DIFF_down</A> : thm
<A NAME="line147"></A>    val <A HREF="#FINITE_EMPTY-val">FINITE_EMPTY</A> : thm
<A NAME="line148"></A>    val <A HREF="#FINITE_INDUCT-val">FINITE_INDUCT</A> : thm
<A NAME="line149"></A>    val <A HREF="#FINITE_INJ-val">FINITE_INJ</A> : thm
<A NAME="line150"></A>    val <A HREF="#FINITE_INSERT-val">FINITE_INSERT</A> : thm
<A NAME="line151"></A>    val <A HREF="#FINITE_INTER-val">FINITE_INTER</A> : thm
<A NAME="line152"></A>    val <A HREF="#FINITE_ISO_NUM-val">FINITE_ISO_NUM</A> : thm
<A NAME="line153"></A>    val <A HREF="#FINITE_POW-val">FINITE_POW</A> : thm
<A NAME="line154"></A>    val <A HREF="#FINITE_PSUBSET_INFINITE-val">FINITE_PSUBSET_INFINITE</A> : thm
<A NAME="line155"></A>    val <A HREF="#FINITE_PSUBSET_UNIV-val">FINITE_PSUBSET_UNIV</A> : thm
<A NAME="line156"></A>    val <A HREF="#FINITE_SING-val">FINITE_SING</A> : thm
<A NAME="line157"></A>    val <A HREF="#FINITE_UNION-val">FINITE_UNION</A> : thm
<A NAME="line158"></A>    val <A HREF="#FINITE_WEAK_ENUMERATE-val">FINITE_WEAK_ENUMERATE</A> : thm
<A NAME="line159"></A>    val <A HREF="#FINITE_partition-val">FINITE_partition</A> : thm
<A NAME="line160"></A>    val <A HREF="#GSPEC_AND-val">GSPEC_AND</A> : thm
<A NAME="line161"></A>    val <A HREF="#GSPEC_EQ-val">GSPEC_EQ</A> : thm
<A NAME="line162"></A>    val <A HREF="#GSPEC_EQ2-val">GSPEC_EQ2</A> : thm
<A NAME="line163"></A>    val <A HREF="#GSPEC_F-val">GSPEC_F</A> : thm
<A NAME="line164"></A>    val <A HREF="#GSPEC_F_COND-val">GSPEC_F_COND</A> : thm
<A NAME="line165"></A>    val <A HREF="#GSPEC_ID-val">GSPEC_ID</A> : thm
<A NAME="line166"></A>    val <A HREF="#GSPEC_OR-val">GSPEC_OR</A> : thm
<A NAME="line167"></A>    val <A HREF="#GSPEC_T-val">GSPEC_T</A> : thm
<A NAME="line168"></A>    val <A HREF="#IMAGE_11_INFINITE-val">IMAGE_11_INFINITE</A> : thm
<A NAME="line169"></A>    val <A HREF="#IMAGE_BIGUNION-val">IMAGE_BIGUNION</A> : thm
<A NAME="line170"></A>    val <A HREF="#IMAGE_COMPOSE-val">IMAGE_COMPOSE</A> : thm
<A NAME="line171"></A>    val <A HREF="#IMAGE_DELETE-val">IMAGE_DELETE</A> : thm
<A NAME="line172"></A>    val <A HREF="#IMAGE_EMPTY-val">IMAGE_EMPTY</A> : thm
<A NAME="line173"></A>    val <A HREF="#IMAGE_EQ_EMPTY-val">IMAGE_EQ_EMPTY</A> : thm
<A NAME="line174"></A>    val <A HREF="#IMAGE_FINITE-val">IMAGE_FINITE</A> : thm
<A NAME="line175"></A>    val <A HREF="#IMAGE_ID-val">IMAGE_ID</A> : thm
<A NAME="line176"></A>    val <A HREF="#IMAGE_IN-val">IMAGE_IN</A> : thm
<A NAME="line177"></A>    val <A HREF="#IMAGE_INSERT-val">IMAGE_INSERT</A> : thm
<A NAME="line178"></A>    val <A HREF="#IMAGE_INTER-val">IMAGE_INTER</A> : thm
<A NAME="line179"></A>    val <A HREF="#IMAGE_SUBSET-val">IMAGE_SUBSET</A> : thm
<A NAME="line180"></A>    val <A HREF="#IMAGE_SURJ-val">IMAGE_SURJ</A> : thm
<A NAME="line181"></A>    val <A HREF="#IMAGE_UNION-val">IMAGE_UNION</A> : thm
<A NAME="line182"></A>    val <A HREF="#INFINITE_DIFF_FINITE-val">INFINITE_DIFF_FINITE</A> : thm
<A NAME="line183"></A>    val <A HREF="#INFINITE_INHAB-val">INFINITE_INHAB</A> : thm
<A NAME="line184"></A>    val <A HREF="#INFINITE_SUBSET-val">INFINITE_SUBSET</A> : thm
<A NAME="line185"></A>    val <A HREF="#INFINITE_UNIV-val">INFINITE_UNIV</A> : thm
<A NAME="line186"></A>    val <A HREF="#INJECTIVE_IMAGE_FINITE-val">INJECTIVE_IMAGE_FINITE</A> : thm
<A NAME="line187"></A>    val <A HREF="#INJ_CARD-val">INJ_CARD</A> : thm
<A NAME="line188"></A>    val <A HREF="#INJ_COMPOSE-val">INJ_COMPOSE</A> : thm
<A NAME="line189"></A>    val <A HREF="#INJ_DELETE-val">INJ_DELETE</A> : thm
<A NAME="line190"></A>    val <A HREF="#INJ_EMPTY-val">INJ_EMPTY</A> : thm
<A NAME="line191"></A>    val <A HREF="#INJ_ID-val">INJ_ID</A> : thm
<A NAME="line192"></A>    val <A HREF="#INSERT_COMM-val">INSERT_COMM</A> : thm
<A NAME="line193"></A>    val <A HREF="#INSERT_DELETE-val">INSERT_DELETE</A> : thm
<A NAME="line194"></A>    val <A HREF="#INSERT_DIFF-val">INSERT_DIFF</A> : thm
<A NAME="line195"></A>    val <A HREF="#INSERT_INSERT-val">INSERT_INSERT</A> : thm
<A NAME="line196"></A>    val <A HREF="#INSERT_INTER-val">INSERT_INTER</A> : thm
<A NAME="line197"></A>    val <A HREF="#INSERT_SING_UNION-val">INSERT_SING_UNION</A> : thm
<A NAME="line198"></A>    val <A HREF="#INSERT_SUBSET-val">INSERT_SUBSET</A> : thm
<A NAME="line199"></A>    val <A HREF="#INSERT_UNION-val">INSERT_UNION</A> : thm
<A NAME="line200"></A>    val <A HREF="#INSERT_UNION_EQ-val">INSERT_UNION_EQ</A> : thm
<A NAME="line201"></A>    val <A HREF="#INSERT_UNIV-val">INSERT_UNIV</A> : thm
<A NAME="line202"></A>    val <A HREF="#INTER_ASSOC-val">INTER_ASSOC</A> : thm
<A NAME="line203"></A>    val <A HREF="#INTER_COMM-val">INTER_COMM</A> : thm
<A NAME="line204"></A>    val <A HREF="#INTER_EMPTY-val">INTER_EMPTY</A> : thm
<A NAME="line205"></A>    val <A HREF="#INTER_FINITE-val">INTER_FINITE</A> : thm
<A NAME="line206"></A>    val <A HREF="#INTER_IDEMPOT-val">INTER_IDEMPOT</A> : thm
<A NAME="line207"></A>    val <A HREF="#INTER_OVER_UNION-val">INTER_OVER_UNION</A> : thm
<A NAME="line208"></A>    val <A HREF="#INTER_SUBSET-val">INTER_SUBSET</A> : thm
<A NAME="line209"></A>    val <A HREF="#INTER_SUBSET_EQN-val">INTER_SUBSET_EQN</A> : thm
<A NAME="line210"></A>    val <A HREF="#INTER_UNION-val">INTER_UNION</A> : thm
<A NAME="line211"></A>    val <A HREF="#INTER_UNION_COMPL-val">INTER_UNION_COMPL</A> : thm
<A NAME="line212"></A>    val <A HREF="#INTER_UNIV-val">INTER_UNIV</A> : thm
<A NAME="line213"></A>    val <A HREF="#IN_ABS-val">IN_ABS</A> : thm
<A NAME="line214"></A>    val <A HREF="#IN_BIGINTER-val">IN_BIGINTER</A> : thm
<A NAME="line215"></A>    val <A HREF="#IN_BIGUNION-val">IN_BIGUNION</A> : thm
<A NAME="line216"></A>    val <A HREF="#IN_COMPL-val">IN_COMPL</A> : thm
<A NAME="line217"></A>    val <A HREF="#IN_COUNT-val">IN_COUNT</A> : thm
<A NAME="line218"></A>    val <A HREF="#IN_CROSS-val">IN_CROSS</A> : thm
<A NAME="line219"></A>    val <A HREF="#IN_DELETE-val">IN_DELETE</A> : thm
<A NAME="line220"></A>    val <A HREF="#IN_DELETE_EQ-val">IN_DELETE_EQ</A> : thm
<A NAME="line221"></A>    val <A HREF="#IN_DIFF-val">IN_DIFF</A> : thm
<A NAME="line222"></A>    val <A HREF="#IN_DISJOINT-val">IN_DISJOINT</A> : thm
<A NAME="line223"></A>    val <A HREF="#IN_IMAGE-val">IN_IMAGE</A> : thm
<A NAME="line224"></A>    val <A HREF="#IN_INFINITE_NOT_FINITE-val">IN_INFINITE_NOT_FINITE</A> : thm
<A NAME="line225"></A>    val <A HREF="#IN_INSERT-val">IN_INSERT</A> : thm
<A NAME="line226"></A>    val <A HREF="#IN_INSERT_EXPAND-val">IN_INSERT_EXPAND</A> : thm
<A NAME="line227"></A>    val <A HREF="#IN_INTER-val">IN_INTER</A> : thm
<A NAME="line228"></A>    val <A HREF="#IN_POW-val">IN_POW</A> : thm
<A NAME="line229"></A>    val <A HREF="#IN_SING-val">IN_SING</A> : thm
<A NAME="line230"></A>    val <A HREF="#IN_UNION-val">IN_UNION</A> : thm
<A NAME="line231"></A>    val <A HREF="#IN_UNIV-val">IN_UNIV</A> : thm
<A NAME="line232"></A>    val <A HREF="#ITSET_EMPTY-val">ITSET_EMPTY</A> : thm
<A NAME="line233"></A>    val <A HREF="#ITSET_IND-val">ITSET_IND</A> : thm
<A NAME="line234"></A>    val <A HREF="#ITSET_INSERT-val">ITSET_INSERT</A> : thm
<A NAME="line235"></A>    val <A HREF="#ITSET_THM-val">ITSET_THM</A> : thm
<A NAME="line236"></A>    val <A HREF="#ITSET_def-val">ITSET_def</A> : thm
<A NAME="line237"></A>    val <A HREF="#ITSET_ind-val">ITSET_ind</A> : thm
<A NAME="line238"></A>    val <A HREF="#KoenigsLemma-val">KoenigsLemma</A> : thm
<A NAME="line239"></A>    val <A HREF="#KoenigsLemma_WF-val">KoenigsLemma_WF</A> : thm
<A NAME="line240"></A>    val <A HREF="#LESS_CARD_DIFF-val">LESS_CARD_DIFF</A> : thm
<A NAME="line241"></A>    val <A HREF="#MAX_SET_THM-val">MAX_SET_THM</A> : thm
<A NAME="line242"></A>    val <A HREF="#MAX_SET_UNION-val">MAX_SET_UNION</A> : thm
<A NAME="line243"></A>    val <A HREF="#MEMBER_NOT_EMPTY-val">MEMBER_NOT_EMPTY</A> : thm
<A NAME="line244"></A>    val <A HREF="#MIN_SET_ELIM-val">MIN_SET_ELIM</A> : thm
<A NAME="line245"></A>    val <A HREF="#MIN_SET_LEM-val">MIN_SET_LEM</A> : thm
<A NAME="line246"></A>    val <A HREF="#MIN_SET_LEQ_MAX_SET-val">MIN_SET_LEQ_MAX_SET</A> : thm
<A NAME="line247"></A>    val <A HREF="#MIN_SET_THM-val">MIN_SET_THM</A> : thm
<A NAME="line248"></A>    val <A HREF="#MIN_SET_UNION-val">MIN_SET_UNION</A> : thm
<A NAME="line249"></A>    val <A HREF="#NOT_EMPTY_INSERT-val">NOT_EMPTY_INSERT</A> : thm
<A NAME="line250"></A>    val <A HREF="#NOT_EMPTY_SING-val">NOT_EMPTY_SING</A> : thm
<A NAME="line251"></A>    val <A HREF="#NOT_EQUAL_SETS-val">NOT_EQUAL_SETS</A> : thm
<A NAME="line252"></A>    val <A HREF="#NOT_INSERT_EMPTY-val">NOT_INSERT_EMPTY</A> : thm
<A NAME="line253"></A>    val <A HREF="#NOT_IN_EMPTY-val">NOT_IN_EMPTY</A> : thm
<A NAME="line254"></A>    val <A HREF="#NOT_IN_FINITE-val">NOT_IN_FINITE</A> : thm
<A NAME="line255"></A>    val <A HREF="#NOT_PSUBSET_EMPTY-val">NOT_PSUBSET_EMPTY</A> : thm
<A NAME="line256"></A>    val <A HREF="#NOT_SING_EMPTY-val">NOT_SING_EMPTY</A> : thm
<A NAME="line257"></A>    val <A HREF="#NOT_UNIV_PSUBSET-val">NOT_UNIV_PSUBSET</A> : thm
<A NAME="line258"></A>    val <A HREF="#NUM_SET_WOP-val">NUM_SET_WOP</A> : thm
<A NAME="line259"></A>    val <A HREF="#PHP-val">PHP</A> : thm
<A NAME="line260"></A>    val <A HREF="#POW_EQNS-val">POW_EQNS</A> : thm
<A NAME="line261"></A>    val <A HREF="#POW_INSERT-val">POW_INSERT</A> : thm
<A NAME="line262"></A>    val <A HREF="#PSUBSET_EQN-val">PSUBSET_EQN</A> : thm
<A NAME="line263"></A>    val <A HREF="#PSUBSET_FINITE-val">PSUBSET_FINITE</A> : thm
<A NAME="line264"></A>    val <A HREF="#PSUBSET_INSERT_SUBSET-val">PSUBSET_INSERT_SUBSET</A> : thm
<A NAME="line265"></A>    val <A HREF="#PSUBSET_IRREFL-val">PSUBSET_IRREFL</A> : thm
<A NAME="line266"></A>    val <A HREF="#PSUBSET_MEMBER-val">PSUBSET_MEMBER</A> : thm
<A NAME="line267"></A>    val <A HREF="#PSUBSET_SING-val">PSUBSET_SING</A> : thm
<A NAME="line268"></A>    val <A HREF="#PSUBSET_TRANS-val">PSUBSET_TRANS</A> : thm
<A NAME="line269"></A>    val <A HREF="#PSUBSET_UNIV-val">PSUBSET_UNIV</A> : thm
<A NAME="line270"></A>    val <A HREF="#REST_PSUBSET-val">REST_PSUBSET</A> : thm
<A NAME="line271"></A>    val <A HREF="#REST_SING-val">REST_SING</A> : thm
<A NAME="line272"></A>    val <A HREF="#REST_SUBSET-val">REST_SUBSET</A> : thm
<A NAME="line273"></A>    val <A HREF="#SET_CASES-val">SET_CASES</A> : thm
<A NAME="line274"></A>    val <A HREF="#SET_EQ_SUBSET-val">SET_EQ_SUBSET</A> : thm
<A NAME="line275"></A>    val <A HREF="#SET_MINIMUM-val">SET_MINIMUM</A> : thm
<A NAME="line276"></A>    val <A HREF="#SING-val">SING</A> : thm
<A NAME="line277"></A>    val <A HREF="#SING_DELETE-val">SING_DELETE</A> : thm
<A NAME="line278"></A>    val <A HREF="#SING_FINITE-val">SING_FINITE</A> : thm
<A NAME="line279"></A>    val <A HREF="#SING_IFF_CARD1-val">SING_IFF_CARD1</A> : thm
<A NAME="line280"></A>    val <A HREF="#SING_IFF_EMPTY_REST-val">SING_IFF_EMPTY_REST</A> : thm
<A NAME="line281"></A>    val <A HREF="#SPECIFICATION-val">SPECIFICATION</A> : thm
<A NAME="line282"></A>    val <A HREF="#SUBSET_ANTISYM-val">SUBSET_ANTISYM</A> : thm
<A NAME="line283"></A>    val <A HREF="#SUBSET_BIGINTER-val">SUBSET_BIGINTER</A> : thm
<A NAME="line284"></A>    val <A HREF="#SUBSET_DELETE-val">SUBSET_DELETE</A> : thm
<A NAME="line285"></A>    val <A HREF="#SUBSET_DELETE_BOTH-val">SUBSET_DELETE_BOTH</A> : thm
<A NAME="line286"></A>    val <A HREF="#SUBSET_DIFF-val">SUBSET_DIFF</A> : thm
<A NAME="line287"></A>    val <A HREF="#SUBSET_EMPTY-val">SUBSET_EMPTY</A> : thm
<A NAME="line288"></A>    val <A HREF="#SUBSET_EQ_CARD-val">SUBSET_EQ_CARD</A> : thm
<A NAME="line289"></A>    val <A HREF="#SUBSET_FINITE-val">SUBSET_FINITE</A> : thm
<A NAME="line290"></A>    val <A HREF="#SUBSET_INSERT-val">SUBSET_INSERT</A> : thm
<A NAME="line291"></A>    val <A HREF="#SUBSET_INSERT_DELETE-val">SUBSET_INSERT_DELETE</A> : thm
<A NAME="line292"></A>    val <A HREF="#SUBSET_INSERT_RIGHT-val">SUBSET_INSERT_RIGHT</A> : thm
<A NAME="line293"></A>    val <A HREF="#SUBSET_INTER-val">SUBSET_INTER</A> : thm
<A NAME="line294"></A>    val <A HREF="#SUBSET_INTER_ABSORPTION-val">SUBSET_INTER_ABSORPTION</A> : thm
<A NAME="line295"></A>    val <A HREF="#SUBSET_MAX_SET-val">SUBSET_MAX_SET</A> : thm
<A NAME="line296"></A>    val <A HREF="#SUBSET_MIN_SET-val">SUBSET_MIN_SET</A> : thm
<A NAME="line297"></A>    val <A HREF="#SUBSET_POW-val">SUBSET_POW</A> : thm
<A NAME="line298"></A>    val <A HREF="#SUBSET_REFL-val">SUBSET_REFL</A> : thm
<A NAME="line299"></A>    val <A HREF="#SUBSET_TRANS-val">SUBSET_TRANS</A> : thm
<A NAME="line300"></A>    val <A HREF="#SUBSET_UNION-val">SUBSET_UNION</A> : thm
<A NAME="line301"></A>    val <A HREF="#SUBSET_UNION_ABSORPTION-val">SUBSET_UNION_ABSORPTION</A> : thm
<A NAME="line302"></A>    val <A HREF="#SUBSET_UNIV-val">SUBSET_UNIV</A> : thm
<A NAME="line303"></A>    val <A HREF="#SUM_IMAGE_DELETE-val">SUM_IMAGE_DELETE</A> : thm
<A NAME="line304"></A>    val <A HREF="#SUM_IMAGE_IN_LE-val">SUM_IMAGE_IN_LE</A> : thm
<A NAME="line305"></A>    val <A HREF="#SUM_IMAGE_SING-val">SUM_IMAGE_SING</A> : thm
<A NAME="line306"></A>    val <A HREF="#SUM_IMAGE_SUBSET_LE-val">SUM_IMAGE_SUBSET_LE</A> : thm
<A NAME="line307"></A>    val <A HREF="#SUM_IMAGE_THM-val">SUM_IMAGE_THM</A> : thm
<A NAME="line308"></A>    val <A HREF="#SUM_IMAGE_UNION-val">SUM_IMAGE_UNION</A> : thm
<A NAME="line309"></A>    val <A HREF="#SUM_IMAGE_lower_bound-val">SUM_IMAGE_lower_bound</A> : thm
<A NAME="line310"></A>    val <A HREF="#SUM_IMAGE_upper_bound-val">SUM_IMAGE_upper_bound</A> : thm
<A NAME="line311"></A>    val <A HREF="#SUM_SAME_IMAGE-val">SUM_SAME_IMAGE</A> : thm
<A NAME="line312"></A>    val <A HREF="#SUM_SET_DELETE-val">SUM_SET_DELETE</A> : thm
<A NAME="line313"></A>    val <A HREF="#SUM_SET_IN_LE-val">SUM_SET_IN_LE</A> : thm
<A NAME="line314"></A>    val <A HREF="#SUM_SET_SING-val">SUM_SET_SING</A> : thm
<A NAME="line315"></A>    val <A HREF="#SUM_SET_SUBSET_LE-val">SUM_SET_SUBSET_LE</A> : thm
<A NAME="line316"></A>    val <A HREF="#SUM_SET_THM-val">SUM_SET_THM</A> : thm
<A NAME="line317"></A>    val <A HREF="#SUM_SET_UNION-val">SUM_SET_UNION</A> : thm
<A NAME="line318"></A>    val <A HREF="#SURJ_COMPOSE-val">SURJ_COMPOSE</A> : thm
<A NAME="line319"></A>    val <A HREF="#SURJ_EMPTY-val">SURJ_EMPTY</A> : thm
<A NAME="line320"></A>    val <A HREF="#SURJ_ID-val">SURJ_ID</A> : thm
<A NAME="line321"></A>    val <A HREF="#UNION_ASSOC-val">UNION_ASSOC</A> : thm
<A NAME="line322"></A>    val <A HREF="#UNION_COMM-val">UNION_COMM</A> : thm
<A NAME="line323"></A>    val <A HREF="#UNION_DELETE-val">UNION_DELETE</A> : thm
<A NAME="line324"></A>    val <A HREF="#UNION_EMPTY-val">UNION_EMPTY</A> : thm
<A NAME="line325"></A>    val <A HREF="#UNION_IDEMPOT-val">UNION_IDEMPOT</A> : thm
<A NAME="line326"></A>    val <A HREF="#UNION_OVER_INTER-val">UNION_OVER_INTER</A> : thm
<A NAME="line327"></A>    val <A HREF="#UNION_SUBSET-val">UNION_SUBSET</A> : thm
<A NAME="line328"></A>    val <A HREF="#UNION_UNIV-val">UNION_UNIV</A> : thm
<A NAME="line329"></A>    val <A HREF="#UNIQUE_MEMBER_SING-val">UNIQUE_MEMBER_SING</A> : thm
<A NAME="line330"></A>    val <A HREF="#UNIV_NOT_EMPTY-val">UNIV_NOT_EMPTY</A> : thm
<A NAME="line331"></A>    val <A HREF="#UNIV_SUBSET-val">UNIV_SUBSET</A> : thm
<A NAME="line332"></A>    val <A HREF="#bigunion_countable-val">bigunion_countable</A> : thm
<A NAME="line333"></A>    val <A HREF="#count_EQN-val">count_EQN</A> : thm
<A NAME="line334"></A>    val <A HREF="#countable_surj-val">countable_surj</A> : thm
<A NAME="line335"></A>    val <A HREF="#cross_countable-val">cross_countable</A> : thm
<A NAME="line336"></A>    val <A HREF="#finite_countable-val">finite_countable</A> : thm
<A NAME="line337"></A>    val <A HREF="#image_countable-val">image_countable</A> : thm
<A NAME="line338"></A>    val <A HREF="#infinite_num_inj-val">infinite_num_inj</A> : thm
<A NAME="line339"></A>    val <A HREF="#infinite_pow_uncountable-val">infinite_pow_uncountable</A> : thm
<A NAME="line340"></A>    val <A HREF="#infinite_rest-val">infinite_rest</A> : thm
<A NAME="line341"></A>    val <A HREF="#inj_countable-val">inj_countable</A> : thm
<A NAME="line342"></A>    val <A HREF="#inj_surj-val">inj_surj</A> : thm
<A NAME="line343"></A>    val <A HREF="#inter_countable-val">inter_countable</A> : thm
<A NAME="line344"></A>    val <A HREF="#num_countable-val">num_countable</A> : thm
<A NAME="line345"></A>    val <A HREF="#pair_to_num_def-val">pair_to_num_def</A> : thm
<A NAME="line346"></A>    val <A HREF="#pair_to_num_formula-val">pair_to_num_formula</A> : thm
<A NAME="line347"></A>    val <A HREF="#pair_to_num_ind-val">pair_to_num_ind</A> : thm
<A NAME="line348"></A>    val <A HREF="#pair_to_num_inv-val">pair_to_num_inv</A> : thm
<A NAME="line349"></A>    val <A HREF="#partition_CARD-val">partition_CARD</A> : thm
<A NAME="line350"></A>    val <A HREF="#partition_SUBSET-val">partition_SUBSET</A> : thm
<A NAME="line351"></A>    val <A HREF="#partition_elements_disjoint-val">partition_elements_disjoint</A> : thm
<A NAME="line352"></A>    val <A HREF="#partition_elements_interrelate-val">partition_elements_interrelate</A> : thm
<A NAME="line353"></A>    val <A HREF="#pow_no_surj-val">pow_no_surj</A> : thm
<A NAME="line354"></A>    val <A HREF="#subset_countable-val">subset_countable</A> : thm
<A NAME="line355"></A>    val <A HREF="#union_countable-val">union_countable</A> : thm
<A NAME="line356"></A>  
<A NAME="line357"></A>  val pred_set_grammars : type_grammar.grammar * term_grammar.grammar
<A NAME="line358"></A>  
<A NAME="line359"></A>  val pred_set_rwts : simpLib.ssfrag
<A NAME="line360"></A>  
<A NAME="line361"></A>  val SET_SPEC_ss : simpLib.ssfrag
<A NAME="line362"></A>  
<A NAME="line363"></A>(*
   [basicSize] Parent theory of "pred_set"
   
   [while] Parent theory of "pred_set"
   
   [<A NAME="BIGINTER-val"><B>BIGINTER</B></A>]  Definition
      
      |- !P. BIGINTER P = {x | !s. s IN P ==&gt; x IN s}
   
   [<A NAME="BIGUNION-val"><B>BIGUNION</B></A>]  Definition
      
      |- !P. BIGUNION P = {x | ?s. s IN P /\ x IN s}
   
   [<A NAME="BIJ_DEF-val"><B>BIJ_DEF</B></A>]  Definition
      
      |- !f s t. BIJ f s t &lt;=&gt; INJ f s t /\ SURJ f s t
   
   [<A NAME="CARD_DEF-val"><B>CARD_DEF</B></A>]  Definition
      
      |- (CARD {} = 0) /\
         !s.
           FINITE s ==&gt;
           !x. CARD (x INSERT s) = if x IN s then CARD s else SUC (CARD s)
   
   [<A NAME="CHOICE_DEF-val"><B>CHOICE_DEF</B></A>]  Definition
      
      |- !s. s &lt;&gt; {} ==&gt; CHOICE s IN s
   
   [<A NAME="COMPL_DEF-val"><B>COMPL_DEF</B></A>]  Definition
      
      |- !P. COMPL P = UNIV DIFF P
   
   [<A NAME="CROSS_DEF-val"><B>CROSS_DEF</B></A>]  Definition
      
      |- !P Q. P CROSS Q = {p | FST p IN P /\ SND p IN Q}
   
   [<A NAME="DELETE_DEF-val"><B>DELETE_DEF</B></A>]  Definition
      
      |- !s x. s DELETE x = s DIFF {x}
   
   [<A NAME="DIFF_DEF-val"><B>DIFF_DEF</B></A>]  Definition
      
      |- !s t. s DIFF t = {x | x IN s /\ x NOTIN t}
   
   [<A NAME="DISJOINT_DEF-val"><B>DISJOINT_DEF</B></A>]  Definition
      
      |- !s t. DISJOINT s t &lt;=&gt; (s INTER t = {})
   
   [<A NAME="EMPTY_DEF-val"><B>EMPTY_DEF</B></A>]  Definition
      
      |- {} = (\x. F)
   
   [<A NAME="FINITE_DEF-val"><B>FINITE_DEF</B></A>]  Definition
      
      |- !s.
           FINITE s &lt;=&gt;
           !P. P {} /\ (!s. P s ==&gt; !e. P (e INSERT s)) ==&gt; P s
   
   [<A NAME="GSPECIFICATION-val"><B>GSPECIFICATION</B></A>]  Definition
      
      |- !f v. v IN GSPEC f &lt;=&gt; ?x. (v,T) = f x
   
   [<A NAME="IMAGE_DEF-val"><B>IMAGE_DEF</B></A>]  Definition
      
      |- !f s. IMAGE f s = {f x | x IN s}
   
   [<A NAME="INFINITE_DEF-val"><B>INFINITE_DEF</B></A>]  Definition
      
      |- !s. INFINITE s &lt;=&gt; ~FINITE s
   
   [<A NAME="INJ_DEF-val"><B>INJ_DEF</B></A>]  Definition
      
      |- !f s t.
           INJ f s t &lt;=&gt;
           (!x. x IN s ==&gt; f x IN t) /\
           !x y. x IN s /\ y IN s ==&gt; (f x = f y) ==&gt; (x = y)
   
   [<A NAME="INSERT_DEF-val"><B>INSERT_DEF</B></A>]  Definition
      
      |- !x s. x INSERT s = {y | (y = x) \/ y IN s}
   
   [<A NAME="INTER_DEF-val"><B>INTER_DEF</B></A>]  Definition
      
      |- !s t. s INTER t = {x | x IN s /\ x IN t}
   
   [<A NAME="ITSET_curried_def-val"><B>ITSET_curried_def</B></A>]  Definition
      
      |- !f x x1. ITSET f x x1 = ITSET_tupled f (x,x1)
   
   [<A NAME="ITSET_tupled_primitive_def-val"><B>ITSET_tupled_primitive_def</B></A>]  Definition
      
      |- !f.
           ITSET_tupled f =
           WFREC
             (@R.
                WF R /\
                !b s.
                  FINITE s /\ s &lt;&gt; {} ==&gt; R (REST s,f (CHOICE s) b) (s,b))
             (\ITSET_tupled a.
                case a of
                   (s,b) -&gt;
                     I
                       (if FINITE s then
                          if s = {} then
                            b
                          else
                            ITSET_tupled (REST s,f (CHOICE s) b)
                        else
                          ARB))
   
   [<A NAME="LINV_DEF-val"><B>LINV_DEF</B></A>]  Definition
      
      |- !f s t. INJ f s t ==&gt; !x. x IN s ==&gt; (LINV f s (f x) = x)
   
   [<A NAME="MAX_SET_DEF-val"><B>MAX_SET_DEF</B></A>]  Definition
      
      |- !s.
           FINITE s /\ s &lt;&gt; {} ==&gt;
           MAX_SET s IN s /\ !y. y IN s ==&gt; y &lt;= MAX_SET s
   
   [<A NAME="MIN_SET_DEF-val"><B>MIN_SET_DEF</B></A>]  Definition
      
      |- MIN_SET = $LEAST
   
   [<A NAME="POW_DEF-val"><B>POW_DEF</B></A>]  Definition
      
      |- !set. POW set = {s | s SUBSET set}
   
   [<A NAME="PSUBSET_DEF-val"><B>PSUBSET_DEF</B></A>]  Definition
      
      |- !s t. s PSUBSET t &lt;=&gt; s SUBSET t /\ s &lt;&gt; t
   
   [<A NAME="REST_DEF-val"><B>REST_DEF</B></A>]  Definition
      
      |- !s. REST s = s DELETE CHOICE s
   
   [<A NAME="RINV_DEF-val"><B>RINV_DEF</B></A>]  Definition
      
      |- !f s t. SURJ f s t ==&gt; !x. x IN t ==&gt; (f (RINV f s x) = x)
   
   [<A NAME="SING_DEF-val"><B>SING_DEF</B></A>]  Definition
      
      |- !s. SING s &lt;=&gt; ?x. s = {x}
   
   [<A NAME="SUBSET_DEF-val"><B>SUBSET_DEF</B></A>]  Definition
      
      |- !s t. s SUBSET t &lt;=&gt; !x. x IN s ==&gt; x IN t
   
   [<A NAME="SUM_IMAGE_DEF-val"><B>SUM_IMAGE_DEF</B></A>]  Definition
      
      |- !f s. SIGMA f s = ITSET (\e acc. f e + acc) s 0
   
   [<A NAME="SUM_SET_DEF-val"><B>SUM_SET_DEF</B></A>]  Definition
      
      |- SUM_SET = SIGMA I
   
   [<A NAME="SURJ_DEF-val"><B>SURJ_DEF</B></A>]  Definition
      
      |- !f s t.
           SURJ f s t &lt;=&gt;
           (!x. x IN s ==&gt; f x IN t) /\
           !x. x IN t ==&gt; ?y. y IN s /\ (f y = x)
   
   [<A NAME="UNION_DEF-val"><B>UNION_DEF</B></A>]  Definition
      
      |- !s t. s UNION t = {x | x IN s \/ x IN t}
   
   [<A NAME="UNIV_DEF-val"><B>UNIV_DEF</B></A>]  Definition
      
      |- UNIV = (\x. T)
   
   [<A NAME="chooser_def-val"><B>chooser_def</B></A>]  Definition
      
      |- (!s. chooser s 0 = CHOICE s) /\
         !s n. chooser s (SUC n) = chooser (REST s) n
   
   [<A NAME="count_def-val"><B>count_def</B></A>]  Definition
      
      |- !n. count n = {m | m &lt; n}
   
   [<A NAME="countable_def-val"><B>countable_def</B></A>]  Definition
      
      |- !s. countable s &lt;=&gt; ?f. INJ f s UNIV
   
   [<A NAME="equiv_on_def-val"><B>equiv_on_def</B></A>]  Definition
      
      |- !R s.
           R equiv_on s &lt;=&gt;
           (!x. x IN s ==&gt; R x x) /\
           (!x y. x IN s /\ y IN s ==&gt; (R x y &lt;=&gt; R y x)) /\
           !x y z. x IN s /\ y IN s /\ z IN s /\ R x y /\ R y z ==&gt; R x z
   
   [<A NAME="num_to_pair_def-val"><B>num_to_pair_def</B></A>]  Definition
      
      |- (num_to_pair 0 = (0,0)) /\
         !n.
           num_to_pair (SUC n) =
           case num_to_pair n of
              (0,y) -&gt; (SUC y,0)
           || (SUC x,y) -&gt; (x,SUC y)
   
   [<A NAME="pair_to_num_primitive_def-val"><B>pair_to_num_primitive_def</B></A>]  Definition
      
      |- pair_to_num =
         WFREC
           (@R.
              WF R /\ (!x. R (0,x) (SUC x,0)) /\
              (!y. R (SUC 0,y) (0,SUC y)) /\
              !y v2. R (SUC (SUC v2),y) (SUC v2,SUC y))
           (\pair_to_num a.
              case a of
                 (0,0) -&gt; I 0
              || (0,SUC v4) -&gt; I (SUC (pair_to_num (SUC 0,v4)))
              || (SUC x,0) -&gt; I (SUC (pair_to_num (0,x)))
              || (SUC x,SUC v5) -&gt; I (SUC (pair_to_num (SUC (SUC x),v5))))
   
   [<A NAME="partition_def-val"><B>partition_def</B></A>]  Definition
      
      |- !R s.
           partition R s = {t | ?x. x IN s /\ (t = {y | y IN s /\ R x y})}
   
   [<A NAME="ABSORPTION-val"><B>ABSORPTION</B></A>]  Theorem
      
      |- !x s. x IN s &lt;=&gt; (x INSERT s = s)
   
   [<A NAME="BIGINTER_EMPTY-val"><B>BIGINTER_EMPTY</B></A>]  Theorem
      
      |- BIGINTER {} = UNIV
   
   [<A NAME="BIGINTER_INSERT-val"><B>BIGINTER_INSERT</B></A>]  Theorem
      
      |- !P B. BIGINTER (P INSERT B) = P INTER BIGINTER B
   
   [<A NAME="BIGINTER_INTER-val"><B>BIGINTER_INTER</B></A>]  Theorem
      
      |- !P Q. BIGINTER {P; Q} = P INTER Q
   
   [<A NAME="BIGINTER_SING-val"><B>BIGINTER_SING</B></A>]  Theorem
      
      |- !P. BIGINTER {P} = P
   
   [<A NAME="BIGUNION_EMPTY-val"><B>BIGUNION_EMPTY</B></A>]  Theorem
      
      |- BIGUNION {} = {}
   
   [<A NAME="BIGUNION_EQ_EMPTY-val"><B>BIGUNION_EQ_EMPTY</B></A>]  Theorem
      
      |- !P.
           ((BIGUNION P = {}) &lt;=&gt; (P = {}) \/ (P = {{}})) /\
           (({} = BIGUNION P) &lt;=&gt; (P = {}) \/ (P = {{}}))
   
   [<A NAME="BIGUNION_INSERT-val"><B>BIGUNION_INSERT</B></A>]  Theorem
      
      |- !s P. BIGUNION (s INSERT P) = s UNION BIGUNION P
   
   [<A NAME="BIGUNION_SING-val"><B>BIGUNION_SING</B></A>]  Theorem
      
      |- !x. BIGUNION {x} = x
   
   [<A NAME="BIGUNION_SUBSET-val"><B>BIGUNION_SUBSET</B></A>]  Theorem
      
      |- !X P. BIGUNION P SUBSET X &lt;=&gt; !Y. Y IN P ==&gt; Y SUBSET X
   
   [<A NAME="BIGUNION_UNION-val"><B>BIGUNION_UNION</B></A>]  Theorem
      
      |- !s1 s2. BIGUNION (s1 UNION s2) = BIGUNION s1 UNION BIGUNION s2
   
   [<A NAME="BIGUNION_partition-val"><B>BIGUNION_partition</B></A>]  Theorem
      
      |- R equiv_on s ==&gt; (BIGUNION (partition R s) = s)
   
   [<A NAME="BIJ_COMPOSE-val"><B>BIJ_COMPOSE</B></A>]  Theorem
      
      |- !f g s t u. BIJ f s t /\ BIJ g t u ==&gt; BIJ (g o f) s u
   
   [<A NAME="BIJ_DELETE-val"><B>BIJ_DELETE</B></A>]  Theorem
      
      |- !s t f.
           BIJ f s t ==&gt; !e. e IN s ==&gt; BIJ f (s DELETE e) (t DELETE f e)
   
   [<A NAME="BIJ_EMPTY-val"><B>BIJ_EMPTY</B></A>]  Theorem
      
      |- !f. (!s. BIJ f {} s &lt;=&gt; (s = {})) /\ !s. BIJ f s {} &lt;=&gt; (s = {})
   
   [<A NAME="BIJ_ID-val"><B>BIJ_ID</B></A>]  Theorem
      
      |- !s. BIJ (\x. x) s s
   
   [<A NAME="BIJ_LINV_BIJ-val"><B>BIJ_LINV_BIJ</B></A>]  Theorem
      
      |- !f s t. BIJ f s t ==&gt; BIJ (LINV f s) t s
   
   [<A NAME="BIJ_LINV_INV-val"><B>BIJ_LINV_INV</B></A>]  Theorem
      
      |- !f s t. BIJ f s t ==&gt; !x. x IN t ==&gt; (f (LINV f s x) = x)
   
   [<A NAME="CARD_COUNT-val"><B>CARD_COUNT</B></A>]  Theorem
      
      |- !n. CARD (count n) = n
   
   [<A NAME="CARD_CROSS-val"><B>CARD_CROSS</B></A>]  Theorem
      
      |- !P Q.
           FINITE P /\ FINITE Q ==&gt; (CARD (P CROSS Q) = CARD P * CARD Q)
   
   [<A NAME="CARD_DELETE-val"><B>CARD_DELETE</B></A>]  Theorem
      
      |- !s.
           FINITE s ==&gt;
           !x. CARD (s DELETE x) = if x IN s then CARD s - 1 else CARD s
   
   [<A NAME="CARD_DIFF-val"><B>CARD_DIFF</B></A>]  Theorem
      
      |- !t.
           FINITE t ==&gt;
           !s. FINITE s ==&gt; (CARD (s DIFF t) = CARD s - CARD (s INTER t))
   
   [<A NAME="CARD_EMPTY-val"><B>CARD_EMPTY</B></A>]  Theorem
      
      |- CARD {} = 0
   
   [<A NAME="CARD_EQ_0-val"><B>CARD_EQ_0</B></A>]  Theorem
      
      |- !s. FINITE s ==&gt; ((CARD s = 0) &lt;=&gt; (s = {}))
   
   [<A NAME="CARD_INSERT-val"><B>CARD_INSERT</B></A>]  Theorem
      
      |- !s.
           FINITE s ==&gt;
           !x. CARD (x INSERT s) = if x IN s then CARD s else SUC (CARD s)
   
   [<A NAME="CARD_INTER_LESS_EQ-val"><B>CARD_INTER_LESS_EQ</B></A>]  Theorem
      
      |- !s. FINITE s ==&gt; !t. CARD (s INTER t) &lt;= CARD s
   
   [<A NAME="CARD_POW-val"><B>CARD_POW</B></A>]  Theorem
      
      |- !s. FINITE s ==&gt; (CARD (POW s) = 2 ** CARD s)
   
   [<A NAME="CARD_PSUBSET-val"><B>CARD_PSUBSET</B></A>]  Theorem
      
      |- !s. FINITE s ==&gt; !t. t PSUBSET s ==&gt; CARD t &lt; CARD s
   
   [<A NAME="CARD_SING-val"><B>CARD_SING</B></A>]  Theorem
      
      |- !x. CARD {x} = 1
   
   [<A NAME="CARD_SING_CROSS-val"><B>CARD_SING_CROSS</B></A>]  Theorem
      
      |- !x P. FINITE P ==&gt; (CARD ({x} CROSS P) = CARD P)
   
   [<A NAME="CARD_SUBSET-val"><B>CARD_SUBSET</B></A>]  Theorem
      
      |- !s. FINITE s ==&gt; !t. t SUBSET s ==&gt; CARD t &lt;= CARD s
   
   [<A NAME="CARD_UNION-val"><B>CARD_UNION</B></A>]  Theorem
      
      |- !s.
           FINITE s ==&gt;
           !t.
             FINITE t ==&gt;
             (CARD (s UNION t) + CARD (s INTER t) = CARD s + CARD t)
   
   [<A NAME="CHOICE_INSERT_REST-val"><B>CHOICE_INSERT_REST</B></A>]  Theorem
      
      |- !s. s &lt;&gt; {} ==&gt; (CHOICE s INSERT REST s = s)
   
   [<A NAME="CHOICE_NOT_IN_REST-val"><B>CHOICE_NOT_IN_REST</B></A>]  Theorem
      
      |- !s. CHOICE s NOTIN REST s
   
   [<A NAME="CHOICE_SING-val"><B>CHOICE_SING</B></A>]  Theorem
      
      |- !x. CHOICE {x} = x
   
   [<A NAME="COMMUTING_ITSET_INSERT-val"><B>COMMUTING_ITSET_INSERT</B></A>]  Theorem
      
      |- !f s.
           (!x y z. f x (f y z) = f y (f x z)) /\ FINITE s ==&gt;
           !x b. ITSET f (x INSERT s) b = ITSET f (s DELETE x) (f x b)
   
   [<A NAME="COMMUTING_ITSET_RECURSES-val"><B>COMMUTING_ITSET_RECURSES</B></A>]  Theorem
      
      |- !f e s b.
           (!x y z. f x (f y z) = f y (f x z)) /\ FINITE s ==&gt;
           (ITSET f (e INSERT s) b = f e (ITSET f (s DELETE e) b))
   
   [<A NAME="COMPL_CLAUSES-val"><B>COMPL_CLAUSES</B></A>]  Theorem
      
      |- !s. (COMPL s INTER s = {}) /\ (COMPL s UNION s = UNIV)
   
   [<A NAME="COMPL_COMPL-val"><B>COMPL_COMPL</B></A>]  Theorem
      
      |- !s. COMPL (COMPL s) = s
   
   [<A NAME="COMPL_EMPTY-val"><B>COMPL_EMPTY</B></A>]  Theorem
      
      |- COMPL {} = UNIV
   
   [<A NAME="COMPL_INTER-val"><B>COMPL_INTER</B></A>]  Theorem
      
      |- (x INTER COMPL x = {}) /\ (COMPL x INTER x = {})
   
   [<A NAME="COMPL_SPLITS-val"><B>COMPL_SPLITS</B></A>]  Theorem
      
      |- !p q. p INTER q UNION COMPL p INTER q = q
   
   [<A NAME="COMPONENT-val"><B>COMPONENT</B></A>]  Theorem
      
      |- !x s. x IN x INSERT s
   
   [<A NAME="COUNT_SUC-val"><B>COUNT_SUC</B></A>]  Theorem
      
      |- !n. count (SUC n) = n INSERT count n
   
   [<A NAME="COUNT_ZERO-val"><B>COUNT_ZERO</B></A>]  Theorem
      
      |- count 0 = {}
   
   [<A NAME="CROSS_EMPTY-val"><B>CROSS_EMPTY</B></A>]  Theorem
      
      |- !P. (P CROSS {} = {}) /\ ({} CROSS P = {})
   
   [<A NAME="CROSS_EQNS-val"><B>CROSS_EQNS</B></A>]  Theorem
      
      |- !s1 s2.
           ({} CROSS s2 = {}) /\
           ((a INSERT s1) CROSS s2 =
            IMAGE (\y. (a,y)) s2 UNION s1 CROSS s2)
   
   [<A NAME="CROSS_INSERT_LEFT-val"><B>CROSS_INSERT_LEFT</B></A>]  Theorem
      
      |- !P Q x. (x INSERT P) CROSS Q = {x} CROSS Q UNION P CROSS Q
   
   [<A NAME="CROSS_INSERT_RIGHT-val"><B>CROSS_INSERT_RIGHT</B></A>]  Theorem
      
      |- !P Q x. P CROSS (x INSERT Q) = P CROSS {x} UNION P CROSS Q
   
   [<A NAME="CROSS_SINGS-val"><B>CROSS_SINGS</B></A>]  Theorem
      
      |- !x y. {x} CROSS {y} = {(x,y)}
   
   [<A NAME="CROSS_SUBSET-val"><B>CROSS_SUBSET</B></A>]  Theorem
      
      |- !P Q P0 Q0.
           P0 CROSS Q0 SUBSET P CROSS Q &lt;=&gt;
           (P0 = {}) \/ (Q0 = {}) \/ P0 SUBSET P /\ Q0 SUBSET Q
   
   [<A NAME="DECOMPOSITION-val"><B>DECOMPOSITION</B></A>]  Theorem
      
      |- !s x. x IN s &lt;=&gt; ?t. (s = x INSERT t) /\ x NOTIN t
   
   [<A NAME="DELETE_COMM-val"><B>DELETE_COMM</B></A>]  Theorem
      
      |- !x y s. s DELETE x DELETE y = s DELETE y DELETE x
   
   [<A NAME="DELETE_DELETE-val"><B>DELETE_DELETE</B></A>]  Theorem
      
      |- !x s. s DELETE x DELETE x = s DELETE x
   
   [<A NAME="DELETE_EQ_SING-val"><B>DELETE_EQ_SING</B></A>]  Theorem
      
      |- !s x. x IN s ==&gt; ((s DELETE x = {}) &lt;=&gt; (s = {x}))
   
   [<A NAME="DELETE_INSERT-val"><B>DELETE_INSERT</B></A>]  Theorem
      
      |- !x y s.
           (x INSERT s) DELETE y =
           if x = y then s DELETE y else x INSERT s DELETE y
   
   [<A NAME="DELETE_INTER-val"><B>DELETE_INTER</B></A>]  Theorem
      
      |- !s t x. (s DELETE x) INTER t = s INTER t DELETE x
   
   [<A NAME="DELETE_NON_ELEMENT-val"><B>DELETE_NON_ELEMENT</B></A>]  Theorem
      
      |- !x s. x NOTIN s &lt;=&gt; (s DELETE x = s)
   
   [<A NAME="DELETE_SUBSET-val"><B>DELETE_SUBSET</B></A>]  Theorem
      
      |- !x s. s DELETE x SUBSET s
   
   [<A NAME="DELETE_SUBSET_INSERT-val"><B>DELETE_SUBSET_INSERT</B></A>]  Theorem
      
      |- !s e s2. s DELETE e SUBSET s2 &lt;=&gt; s SUBSET e INSERT s2
   
   [<A NAME="DIFF_DIFF-val"><B>DIFF_DIFF</B></A>]  Theorem
      
      |- !s t. s DIFF t DIFF t = s DIFF t
   
   [<A NAME="DIFF_EMPTY-val"><B>DIFF_EMPTY</B></A>]  Theorem
      
      |- !s. s DIFF {} = s
   
   [<A NAME="DIFF_EQ_EMPTY-val"><B>DIFF_EQ_EMPTY</B></A>]  Theorem
      
      |- !s. s DIFF s = {}
   
   [<A NAME="DIFF_INSERT-val"><B>DIFF_INSERT</B></A>]  Theorem
      
      |- !s t x. s DIFF (x INSERT t) = s DELETE x DIFF t
   
   [<A NAME="DIFF_SUBSET-val"><B>DIFF_SUBSET</B></A>]  Theorem
      
      |- !s t. s DIFF t SUBSET s
   
   [<A NAME="DIFF_UNIV-val"><B>DIFF_UNIV</B></A>]  Theorem
      
      |- !s. s DIFF UNIV = {}
   
   [<A NAME="DISJOINT_BIGINTER-val"><B>DISJOINT_BIGINTER</B></A>]  Theorem
      
      |- !X Y P.
           Y IN P /\ DISJOINT Y X ==&gt;
           DISJOINT X (BIGINTER P) /\ DISJOINT (BIGINTER P) X
   
   [<A NAME="DISJOINT_BIGUNION-val"><B>DISJOINT_BIGUNION</B></A>]  Theorem
      
      |- (!s t.
            DISJOINT (BIGUNION s) t &lt;=&gt; !s'. s' IN s ==&gt; DISJOINT s' t) /\
         !s t. DISJOINT t (BIGUNION s) &lt;=&gt; !s'. s' IN s ==&gt; DISJOINT t s'
   
   [<A NAME="DISJOINT_DELETE_SYM-val"><B>DISJOINT_DELETE_SYM</B></A>]  Theorem
      
      |- !s t x. DISJOINT (s DELETE x) t &lt;=&gt; DISJOINT (t DELETE x) s
   
   [<A NAME="DISJOINT_EMPTY-val"><B>DISJOINT_EMPTY</B></A>]  Theorem
      
      |- !s. DISJOINT {} s /\ DISJOINT s {}
   
   [<A NAME="DISJOINT_EMPTY_REFL-val"><B>DISJOINT_EMPTY_REFL</B></A>]  Theorem
      
      |- !s. (s = {}) &lt;=&gt; DISJOINT s s
   
   [<A NAME="DISJOINT_EMPTY_REFL_RWT-val"><B>DISJOINT_EMPTY_REFL_RWT</B></A>]  Theorem
      
      |- !s. DISJOINT s s &lt;=&gt; (s = {})
   
   [<A NAME="DISJOINT_INSERT-val"><B>DISJOINT_INSERT</B></A>]  Theorem
      
      |- !x s t. DISJOINT (x INSERT s) t &lt;=&gt; DISJOINT s t /\ x NOTIN t
   
   [<A NAME="DISJOINT_SING_EMPTY-val"><B>DISJOINT_SING_EMPTY</B></A>]  Theorem
      
      |- !x. DISJOINT {x} {}
   
   [<A NAME="DISJOINT_SUBSET-val"><B>DISJOINT_SUBSET</B></A>]  Theorem
      
      |- !s t u. DISJOINT s t /\ u SUBSET t ==&gt; DISJOINT s u
   
   [<A NAME="DISJOINT_SYM-val"><B>DISJOINT_SYM</B></A>]  Theorem
      
      |- !s t. DISJOINT s t &lt;=&gt; DISJOINT t s
   
   [<A NAME="DISJOINT_UNION-val"><B>DISJOINT_UNION</B></A>]  Theorem
      
      |- !s t u. DISJOINT (s UNION t) u &lt;=&gt; DISJOINT s u /\ DISJOINT t u
   
   [<A NAME="DISJOINT_UNION_BOTH-val"><B>DISJOINT_UNION_BOTH</B></A>]  Theorem
      
      |- !s t u.
           (DISJOINT (s UNION t) u &lt;=&gt; DISJOINT s u /\ DISJOINT t u) /\
           (DISJOINT u (s UNION t) &lt;=&gt; DISJOINT s u /\ DISJOINT t u)
   
   [<A NAME="EMPTY_DELETE-val"><B>EMPTY_DELETE</B></A>]  Theorem
      
      |- !x. {} DELETE x = {}
   
   [<A NAME="EMPTY_DIFF-val"><B>EMPTY_DIFF</B></A>]  Theorem
      
      |- !s. {} DIFF s = {}
   
   [<A NAME="EMPTY_NOT_IN_partition-val"><B>EMPTY_NOT_IN_partition</B></A>]  Theorem
      
      |- R equiv_on s ==&gt; {} NOTIN partition R s
   
   [<A NAME="EMPTY_NOT_UNIV-val"><B>EMPTY_NOT_UNIV</B></A>]  Theorem
      
      |- {} &lt;&gt; UNIV
   
   [<A NAME="EMPTY_SUBSET-val"><B>EMPTY_SUBSET</B></A>]  Theorem
      
      |- !s. {} SUBSET s
   
   [<A NAME="EMPTY_UNION-val"><B>EMPTY_UNION</B></A>]  Theorem
      
      |- !s t. (s UNION t = {}) &lt;=&gt; (s = {}) /\ (t = {})
   
   [<A NAME="EQUAL_SING-val"><B>EQUAL_SING</B></A>]  Theorem
      
      |- !x y. ({x} = {y}) &lt;=&gt; (x = y)
   
   [<A NAME="EQ_UNIV-val"><B>EQ_UNIV</B></A>]  Theorem
      
      |- (!x. x IN s) &lt;=&gt; (s = UNIV)
   
   [<A NAME="EXTENSION-val"><B>EXTENSION</B></A>]  Theorem
      
      |- !s t. (s = t) &lt;=&gt; !x. x IN s &lt;=&gt; x IN t
   
   [<A NAME="FINITELY_INJECTIVE_IMAGE_FINITE-val"><B>FINITELY_INJECTIVE_IMAGE_FINITE</B></A>]  Theorem
      
      |- !f.
           (!x. FINITE {y | x = f y}) ==&gt;
           !s. FINITE (IMAGE f s) &lt;=&gt; FINITE s
   
   [<A NAME="FINITE_BIGUNION-val"><B>FINITE_BIGUNION</B></A>]  Theorem
      
      |- !P. FINITE P /\ (!s. s IN P ==&gt; FINITE s) ==&gt; FINITE (BIGUNION P)
   
   [<A NAME="FINITE_BIGUNION_EQ-val"><B>FINITE_BIGUNION_EQ</B></A>]  Theorem
      
      |- !P. FINITE (BIGUNION P) &lt;=&gt; FINITE P /\ !s. s IN P ==&gt; FINITE s
   
   [<A NAME="FINITE_BIJ_CARD_EQ-val"><B>FINITE_BIJ_CARD_EQ</B></A>]  Theorem
      
      |- !S. FINITE S ==&gt; !t f. BIJ f S t /\ FINITE t ==&gt; (CARD S = CARD t)
   
   [<A NAME="FINITE_COMPLETE_INDUCTION-val"><B>FINITE_COMPLETE_INDUCTION</B></A>]  Theorem
      
      |- !P.
           (!x. (!y. y PSUBSET x ==&gt; P y) ==&gt; FINITE x ==&gt; P x) ==&gt;
           !x. FINITE x ==&gt; P x
   
   [<A NAME="FINITE_COUNT-val"><B>FINITE_COUNT</B></A>]  Theorem
      
      |- !n. FINITE (count n)
   
   [<A NAME="FINITE_CROSS-val"><B>FINITE_CROSS</B></A>]  Theorem
      
      |- !P Q. FINITE P /\ FINITE Q ==&gt; FINITE (P CROSS Q)
   
   [<A NAME="FINITE_CROSS_EQ-val"><B>FINITE_CROSS_EQ</B></A>]  Theorem
      
      |- !P Q.
           FINITE (P CROSS Q) &lt;=&gt;
           (P = {}) \/ (Q = {}) \/ FINITE P /\ FINITE Q
   
   [<A NAME="FINITE_DELETE-val"><B>FINITE_DELETE</B></A>]  Theorem
      
      |- !x s. FINITE (s DELETE x) &lt;=&gt; FINITE s
   
   [<A NAME="FINITE_DIFF-val"><B>FINITE_DIFF</B></A>]  Theorem
      
      |- !s. FINITE s ==&gt; !t. FINITE (s DIFF t)
   
   [<A NAME="FINITE_DIFF_down-val"><B>FINITE_DIFF_down</B></A>]  Theorem
      
      |- !P Q. FINITE (P DIFF Q) /\ FINITE Q ==&gt; FINITE P
   
   [<A NAME="FINITE_EMPTY-val"><B>FINITE_EMPTY</B></A>]  Theorem
      
      |- FINITE {}
   
   [<A NAME="FINITE_INDUCT-val"><B>FINITE_INDUCT</B></A>]  Theorem
      
      |- !P.
           P {} /\
           (!s. FINITE s /\ P s ==&gt; !e. e NOTIN s ==&gt; P (e INSERT s)) ==&gt;
           !s. FINITE s ==&gt; P s
   
   [<A NAME="FINITE_INJ-val"><B>FINITE_INJ</B></A>]  Theorem
      
      |- !f s t. INJ f s t /\ FINITE t ==&gt; FINITE s
   
   [<A NAME="FINITE_INSERT-val"><B>FINITE_INSERT</B></A>]  Theorem
      
      |- !x s. FINITE (x INSERT s) &lt;=&gt; FINITE s
   
   [<A NAME="FINITE_INTER-val"><B>FINITE_INTER</B></A>]  Theorem
      
      |- !s1 s2. FINITE s1 \/ FINITE s2 ==&gt; FINITE (s1 INTER s2)
   
   [<A NAME="FINITE_ISO_NUM-val"><B>FINITE_ISO_NUM</B></A>]  Theorem
      
      |- !s.
           FINITE s ==&gt;
           ?f.
             (!n m.
                n &lt; CARD s /\ m &lt; CARD s ==&gt; (f n = f m) ==&gt; (n = m)) /\
             (s = {f n | n &lt; CARD s})
   
   [<A NAME="FINITE_POW-val"><B>FINITE_POW</B></A>]  Theorem
      
      |- !s. FINITE s ==&gt; FINITE (POW s)
   
   [<A NAME="FINITE_PSUBSET_INFINITE-val"><B>FINITE_PSUBSET_INFINITE</B></A>]  Theorem
      
      |- !s. INFINITE s &lt;=&gt; !t. FINITE t ==&gt; t SUBSET s ==&gt; t PSUBSET s
   
   [<A NAME="FINITE_PSUBSET_UNIV-val"><B>FINITE_PSUBSET_UNIV</B></A>]  Theorem
      
      |- INFINITE UNIV &lt;=&gt; !s. FINITE s ==&gt; s PSUBSET UNIV
   
   [<A NAME="FINITE_SING-val"><B>FINITE_SING</B></A>]  Theorem
      
      |- !x. FINITE {x}
   
   [<A NAME="FINITE_UNION-val"><B>FINITE_UNION</B></A>]  Theorem
      
      |- !s t. FINITE (s UNION t) &lt;=&gt; FINITE s /\ FINITE t
   
   [<A NAME="FINITE_WEAK_ENUMERATE-val"><B>FINITE_WEAK_ENUMERATE</B></A>]  Theorem
      
      |- !s. FINITE s &lt;=&gt; ?f b. !e. e IN s &lt;=&gt; ?n. n &lt; b /\ (e = f n)
   
   [<A NAME="FINITE_partition-val"><B>FINITE_partition</B></A>]  Theorem
      
      |- !R s.
           R equiv_on s /\ FINITE s ==&gt;
           FINITE (partition R s) /\ !t. t IN partition R s ==&gt; FINITE t
   
   [<A NAME="GSPEC_AND-val"><B>GSPEC_AND</B></A>]  Theorem
      
      |- !P Q. {x | P x /\ Q x} = {x | P x} INTER {x | Q x}
   
   [<A NAME="GSPEC_EQ-val"><B>GSPEC_EQ</B></A>]  Theorem
      
      |- {x | x = y} = {y}
   
   [<A NAME="GSPEC_EQ2-val"><B>GSPEC_EQ2</B></A>]  Theorem
      
      |- {x | y = x} = {y}
   
   [<A NAME="GSPEC_F-val"><B>GSPEC_F</B></A>]  Theorem
      
      |- {x | F} = {}
   
   [<A NAME="GSPEC_F_COND-val"><B>GSPEC_F_COND</B></A>]  Theorem
      
      |- !f. (!x. ~SND (f x)) ==&gt; (GSPEC f = {})
   
   [<A NAME="GSPEC_ID-val"><B>GSPEC_ID</B></A>]  Theorem
      
      |- {x | x IN y} = y
   
   [<A NAME="GSPEC_OR-val"><B>GSPEC_OR</B></A>]  Theorem
      
      |- !P Q. {x | P x \/ Q x} = {x | P x} UNION {x | Q x}
   
   [<A NAME="GSPEC_T-val"><B>GSPEC_T</B></A>]  Theorem
      
      |- {x | T} = UNIV
   
   [<A NAME="IMAGE_11_INFINITE-val"><B>IMAGE_11_INFINITE</B></A>]  Theorem
      
      |- !f.
           (!x y. (f x = f y) ==&gt; (x = y)) ==&gt;
           !s. INFINITE s ==&gt; INFINITE (IMAGE f s)
   
   [<A NAME="IMAGE_BIGUNION-val"><B>IMAGE_BIGUNION</B></A>]  Theorem
      
      |- !f M. IMAGE f (BIGUNION M) = BIGUNION (IMAGE (IMAGE f) M)
   
   [<A NAME="IMAGE_COMPOSE-val"><B>IMAGE_COMPOSE</B></A>]  Theorem
      
      |- !f g s. IMAGE (f o g) s = IMAGE f (IMAGE g s)
   
   [<A NAME="IMAGE_DELETE-val"><B>IMAGE_DELETE</B></A>]  Theorem
      
      |- !f x s. x NOTIN s ==&gt; (IMAGE f (s DELETE x) = IMAGE f s)
   
   [<A NAME="IMAGE_EMPTY-val"><B>IMAGE_EMPTY</B></A>]  Theorem
      
      |- !f. IMAGE f {} = {}
   
   [<A NAME="IMAGE_EQ_EMPTY-val"><B>IMAGE_EQ_EMPTY</B></A>]  Theorem
      
      |- !s f. (IMAGE f s = {}) &lt;=&gt; (s = {})
   
   [<A NAME="IMAGE_FINITE-val"><B>IMAGE_FINITE</B></A>]  Theorem
      
      |- !s. FINITE s ==&gt; !f. FINITE (IMAGE f s)
   
   [<A NAME="IMAGE_ID-val"><B>IMAGE_ID</B></A>]  Theorem
      
      |- !s. IMAGE (\x. x) s = s
   
   [<A NAME="IMAGE_IN-val"><B>IMAGE_IN</B></A>]  Theorem
      
      |- !x s. x IN s ==&gt; !f. f x IN IMAGE f s
   
   [<A NAME="IMAGE_INSERT-val"><B>IMAGE_INSERT</B></A>]  Theorem
      
      |- !f x s. IMAGE f (x INSERT s) = f x INSERT IMAGE f s
   
   [<A NAME="IMAGE_INTER-val"><B>IMAGE_INTER</B></A>]  Theorem
      
      |- !f s t. IMAGE f (s INTER t) SUBSET IMAGE f s INTER IMAGE f t
   
   [<A NAME="IMAGE_SUBSET-val"><B>IMAGE_SUBSET</B></A>]  Theorem
      
      |- !s t. s SUBSET t ==&gt; !f. IMAGE f s SUBSET IMAGE f t
   
   [<A NAME="IMAGE_SURJ-val"><B>IMAGE_SURJ</B></A>]  Theorem
      
      |- !f s t. SURJ f s t &lt;=&gt; (IMAGE f s = t)
   
   [<A NAME="IMAGE_UNION-val"><B>IMAGE_UNION</B></A>]  Theorem
      
      |- !f s t. IMAGE f (s UNION t) = IMAGE f s UNION IMAGE f t
   
   [<A NAME="INFINITE_DIFF_FINITE-val"><B>INFINITE_DIFF_FINITE</B></A>]  Theorem
      
      |- !s t. INFINITE s /\ FINITE t ==&gt; s DIFF t &lt;&gt; {}
   
   [<A NAME="INFINITE_INHAB-val"><B>INFINITE_INHAB</B></A>]  Theorem
      
      |- !P. INFINITE P ==&gt; ?x. x IN P
   
   [<A NAME="INFINITE_SUBSET-val"><B>INFINITE_SUBSET</B></A>]  Theorem
      
      |- !s. INFINITE s ==&gt; !t. s SUBSET t ==&gt; INFINITE t
   
   [<A NAME="INFINITE_UNIV-val"><B>INFINITE_UNIV</B></A>]  Theorem
      
      |- INFINITE UNIV &lt;=&gt;
         ?f. (!x y. (f x = f y) ==&gt; (x = y)) /\ ?y. !x. f x &lt;&gt; y
   
   [<A NAME="INJECTIVE_IMAGE_FINITE-val"><B>INJECTIVE_IMAGE_FINITE</B></A>]  Theorem
      
      |- !f.
           (!x y. (f x = f y) &lt;=&gt; (x = y)) ==&gt;
           !s. FINITE (IMAGE f s) &lt;=&gt; FINITE s
   
   [<A NAME="INJ_CARD-val"><B>INJ_CARD</B></A>]  Theorem
      
      |- !f s t. INJ f s t /\ FINITE t ==&gt; CARD s &lt;= CARD t
   
   [<A NAME="INJ_COMPOSE-val"><B>INJ_COMPOSE</B></A>]  Theorem
      
      |- !f g s t u. INJ f s t /\ INJ g t u ==&gt; INJ (g o f) s u
   
   [<A NAME="INJ_DELETE-val"><B>INJ_DELETE</B></A>]  Theorem
      
      |- !s t f.
           INJ f s t ==&gt; !e. e IN s ==&gt; INJ f (s DELETE e) (t DELETE f e)
   
   [<A NAME="INJ_EMPTY-val"><B>INJ_EMPTY</B></A>]  Theorem
      
      |- !f. (!s. INJ f {} s) /\ !s. INJ f s {} &lt;=&gt; (s = {})
   
   [<A NAME="INJ_ID-val"><B>INJ_ID</B></A>]  Theorem
      
      |- !s. INJ (\x. x) s s
   
   [<A NAME="INSERT_COMM-val"><B>INSERT_COMM</B></A>]  Theorem
      
      |- !x y s. x INSERT y INSERT s = y INSERT x INSERT s
   
   [<A NAME="INSERT_DELETE-val"><B>INSERT_DELETE</B></A>]  Theorem
      
      |- !x s. x IN s ==&gt; (x INSERT s DELETE x = s)
   
   [<A NAME="INSERT_DIFF-val"><B>INSERT_DIFF</B></A>]  Theorem
      
      |- !s t x.
           (x INSERT s) DIFF t =
           if x IN t then s DIFF t else x INSERT s DIFF t
   
   [<A NAME="INSERT_INSERT-val"><B>INSERT_INSERT</B></A>]  Theorem
      
      |- !x s. x INSERT x INSERT s = x INSERT s
   
   [<A NAME="INSERT_INTER-val"><B>INSERT_INTER</B></A>]  Theorem
      
      |- !x s t.
           (x INSERT s) INTER t =
           if x IN t then x INSERT s INTER t else s INTER t
   
   [<A NAME="INSERT_SING_UNION-val"><B>INSERT_SING_UNION</B></A>]  Theorem
      
      |- !s x. x INSERT s = {x} UNION s
   
   [<A NAME="INSERT_SUBSET-val"><B>INSERT_SUBSET</B></A>]  Theorem
      
      |- !x s t. x INSERT s SUBSET t &lt;=&gt; x IN t /\ s SUBSET t
   
   [<A NAME="INSERT_UNION-val"><B>INSERT_UNION</B></A>]  Theorem
      
      |- !x s t.
           (x INSERT s) UNION t =
           if x IN t then s UNION t else x INSERT s UNION t
   
   [<A NAME="INSERT_UNION_EQ-val"><B>INSERT_UNION_EQ</B></A>]  Theorem
      
      |- !x s t. (x INSERT s) UNION t = x INSERT s UNION t
   
   [<A NAME="INSERT_UNIV-val"><B>INSERT_UNIV</B></A>]  Theorem
      
      |- !x. x INSERT UNIV = UNIV
   
   [<A NAME="INTER_ASSOC-val"><B>INTER_ASSOC</B></A>]  Theorem
      
      |- !s t u. s INTER (t INTER u) = s INTER t INTER u
   
   [<A NAME="INTER_COMM-val"><B>INTER_COMM</B></A>]  Theorem
      
      |- !s t. s INTER t = t INTER s
   
   [<A NAME="INTER_EMPTY-val"><B>INTER_EMPTY</B></A>]  Theorem
      
      |- (!s. {} INTER s = {}) /\ !s. s INTER {} = {}
   
   [<A NAME="INTER_FINITE-val"><B>INTER_FINITE</B></A>]  Theorem
      
      |- !s. FINITE s ==&gt; !t. FINITE (s INTER t)
   
   [<A NAME="INTER_IDEMPOT-val"><B>INTER_IDEMPOT</B></A>]  Theorem
      
      |- !s. s INTER s = s
   
   [<A NAME="INTER_OVER_UNION-val"><B>INTER_OVER_UNION</B></A>]  Theorem
      
      |- !s t u. s UNION t INTER u = (s UNION t) INTER (s UNION u)
   
   [<A NAME="INTER_SUBSET-val"><B>INTER_SUBSET</B></A>]  Theorem
      
      |- (!s t. s INTER t SUBSET s) /\ !s t. t INTER s SUBSET s
   
   [<A NAME="INTER_SUBSET_EQN-val"><B>INTER_SUBSET_EQN</B></A>]  Theorem
      
      |- ((A INTER B = A) &lt;=&gt; A SUBSET B) /\
         ((A INTER B = B) &lt;=&gt; B SUBSET A)
   
   [<A NAME="INTER_UNION-val"><B>INTER_UNION</B></A>]  Theorem
      
      |- ((A UNION B) INTER A = A) /\ ((B UNION A) INTER A = A) /\
         (A INTER (A UNION B) = A) /\ (A INTER (B UNION A) = A)
   
   [<A NAME="INTER_UNION_COMPL-val"><B>INTER_UNION_COMPL</B></A>]  Theorem
      
      |- !s t. s INTER t = COMPL (COMPL s UNION COMPL t)
   
   [<A NAME="INTER_UNIV-val"><B>INTER_UNIV</B></A>]  Theorem
      
      |- (!s. UNIV INTER s = s) /\ !s. s INTER UNIV = s
   
   [<A NAME="IN_ABS-val"><B>IN_ABS</B></A>]  Theorem
      
      |- !x P. x IN (\x. P x) &lt;=&gt; P x
   
   [<A NAME="IN_BIGINTER-val"><B>IN_BIGINTER</B></A>]  Theorem
      
      |- x IN BIGINTER B &lt;=&gt; !P. P IN B ==&gt; x IN P
   
   [<A NAME="IN_BIGUNION-val"><B>IN_BIGUNION</B></A>]  Theorem
      
      |- !x sos. x IN BIGUNION sos &lt;=&gt; ?s. x IN s /\ s IN sos
   
   [<A NAME="IN_COMPL-val"><B>IN_COMPL</B></A>]  Theorem
      
      |- !x s. x IN COMPL s &lt;=&gt; x NOTIN s
   
   [<A NAME="IN_COUNT-val"><B>IN_COUNT</B></A>]  Theorem
      
      |- !m n. m IN count n &lt;=&gt; m &lt; n
   
   [<A NAME="IN_CROSS-val"><B>IN_CROSS</B></A>]  Theorem
      
      |- !P Q x. x IN P CROSS Q &lt;=&gt; FST x IN P /\ SND x IN Q
   
   [<A NAME="IN_DELETE-val"><B>IN_DELETE</B></A>]  Theorem
      
      |- !s x y. x IN s DELETE y &lt;=&gt; x IN s /\ x &lt;&gt; y
   
   [<A NAME="IN_DELETE_EQ-val"><B>IN_DELETE_EQ</B></A>]  Theorem
      
      |- !s x x'.
           (x IN s &lt;=&gt; x' IN s) &lt;=&gt; (x IN s DELETE x' &lt;=&gt; x' IN s DELETE x)
   
   [<A NAME="IN_DIFF-val"><B>IN_DIFF</B></A>]  Theorem
      
      |- !s t x. x IN s DIFF t &lt;=&gt; x IN s /\ x NOTIN t
   
   [<A NAME="IN_DISJOINT-val"><B>IN_DISJOINT</B></A>]  Theorem
      
      |- !s t. DISJOINT s t &lt;=&gt; ~?x. x IN s /\ x IN t
   
   [<A NAME="IN_IMAGE-val"><B>IN_IMAGE</B></A>]  Theorem
      
      |- !y s f. y IN IMAGE f s &lt;=&gt; ?x. (y = f x) /\ x IN s
   
   [<A NAME="IN_INFINITE_NOT_FINITE-val"><B>IN_INFINITE_NOT_FINITE</B></A>]  Theorem
      
      |- !s t. INFINITE s /\ FINITE t ==&gt; ?x. x IN s /\ x NOTIN t
   
   [<A NAME="IN_INSERT-val"><B>IN_INSERT</B></A>]  Theorem
      
      |- !x y s. x IN y INSERT s &lt;=&gt; (x = y) \/ x IN s
   
   [<A NAME="IN_INSERT_EXPAND-val"><B>IN_INSERT_EXPAND</B></A>]  Theorem
      
      |- !x y P. x IN y INSERT P &lt;=&gt; (x = y) \/ x &lt;&gt; y /\ x IN P
   
   [<A NAME="IN_INTER-val"><B>IN_INTER</B></A>]  Theorem
      
      |- !s t x. x IN s INTER t &lt;=&gt; x IN s /\ x IN t
   
   [<A NAME="IN_POW-val"><B>IN_POW</B></A>]  Theorem
      
      |- !set e. e IN POW set &lt;=&gt; e SUBSET set
   
   [<A NAME="IN_SING-val"><B>IN_SING</B></A>]  Theorem
      
      |- !x y. x IN {y} &lt;=&gt; (x = y)
   
   [<A NAME="IN_UNION-val"><B>IN_UNION</B></A>]  Theorem
      
      |- !s t x. x IN s UNION t &lt;=&gt; x IN s \/ x IN t
   
   [<A NAME="IN_UNIV-val"><B>IN_UNIV</B></A>]  Theorem
      
      |- !x. x IN UNIV
   
   [<A NAME="ITSET_EMPTY-val"><B>ITSET_EMPTY</B></A>]  Theorem
      
      |- !f b. ITSET f {} b = b
   
   [<A NAME="ITSET_IND-val"><B>ITSET_IND</B></A>]  Theorem
      
      |- !P.
           (!s b.
              (FINITE s /\ s &lt;&gt; {} ==&gt; P (REST s) (f (CHOICE s) b)) ==&gt;
              P s b) ==&gt;
           !v v1. P v v1
   
   [<A NAME="ITSET_INSERT-val"><B>ITSET_INSERT</B></A>]  Theorem
      
      |- !s.
           FINITE s ==&gt;
           !f x b.
             ITSET f (x INSERT s) b =
             ITSET f (REST (x INSERT s)) (f (CHOICE (x INSERT s)) b)
   
   [<A NAME="ITSET_THM-val"><B>ITSET_THM</B></A>]  Theorem
      
      |- !s f b.
           FINITE s ==&gt;
           (ITSET f s b =
            if s = {} then b else ITSET f (REST s) (f (CHOICE s) b))
   
   [<A NAME="ITSET_def-val"><B>ITSET_def</B></A>]  Theorem
      
      |- ITSET f s b =
         if FINITE s then
           if s = {} then b else ITSET f (REST s) (f (CHOICE s) b)
         else
           ARB
   
   [<A NAME="ITSET_ind-val"><B>ITSET_ind</B></A>]  Theorem
      
      |- !P.
           (!s b.
              (FINITE s /\ s &lt;&gt; {} ==&gt; P (REST s) (f (CHOICE s) b)) ==&gt;
              P s b) ==&gt;
           !v v1. P v v1
   
   [<A NAME="KoenigsLemma-val"><B>KoenigsLemma</B></A>]  Theorem
      
      |- !R.
           (!x. FINITE {y | R x y}) ==&gt;
           !x.
             ~FINITE {y | R^* x y} ==&gt;
             ?f. (f 0 = x) /\ !n. R (f n) (f (SUC n))
   
   [<A NAME="KoenigsLemma_WF-val"><B>KoenigsLemma_WF</B></A>]  Theorem
      
      |- !R.
           (!x. FINITE {y | R x y}) /\ WF (inv R) ==&gt;
           !x. FINITE {y | R^* x y}
   
   [<A NAME="LESS_CARD_DIFF-val"><B>LESS_CARD_DIFF</B></A>]  Theorem
      
      |- !t.
           FINITE t ==&gt;
           !s. FINITE s ==&gt; CARD t &lt; CARD s ==&gt; 0 &lt; CARD (s DIFF t)
   
   [<A NAME="MAX_SET_THM-val"><B>MAX_SET_THM</B></A>]  Theorem
      
      |- (!e. MAX_SET {e} = e) /\
         !s.
           FINITE s ==&gt;
           !e1 e2.
             MAX_SET (e1 INSERT e2 INSERT s) =
             MAX e1 (MAX_SET (e2 INSERT s))
   
   [<A NAME="MAX_SET_UNION-val"><B>MAX_SET_UNION</B></A>]  Theorem
      
      |- !A B.
           FINITE A /\ FINITE B /\ A &lt;&gt; {} /\ B &lt;&gt; {} ==&gt;
           (MAX_SET (A UNION B) = MAX (MAX_SET A) (MAX_SET B))
   
   [<A NAME="MEMBER_NOT_EMPTY-val"><B>MEMBER_NOT_EMPTY</B></A>]  Theorem
      
      |- !s. (?x. x IN s) &lt;=&gt; s &lt;&gt; {}
   
   [<A NAME="MIN_SET_ELIM-val"><B>MIN_SET_ELIM</B></A>]  Theorem
      
      |- !P Q.
           P &lt;&gt; {} /\ (!x. (!y. y IN P ==&gt; x &lt;= y) /\ x IN P ==&gt; Q x) ==&gt;
           Q (MIN_SET P)
   
   [<A NAME="MIN_SET_LEM-val"><B>MIN_SET_LEM</B></A>]  Theorem
      
      |- !s. s &lt;&gt; {} ==&gt; MIN_SET s IN s /\ !x. x IN s ==&gt; MIN_SET s &lt;= x
   
   [<A NAME="MIN_SET_LEQ_MAX_SET-val"><B>MIN_SET_LEQ_MAX_SET</B></A>]  Theorem
      
      |- !s. s &lt;&gt; {} /\ FINITE s ==&gt; MIN_SET s &lt;= MAX_SET s
   
   [<A NAME="MIN_SET_THM-val"><B>MIN_SET_THM</B></A>]  Theorem
      
      |- (!e. MIN_SET {e} = e) /\
         !s e1 e2.
           MIN_SET (e1 INSERT e2 INSERT s) = MIN e1 (MIN_SET (e2 INSERT s))
   
   [<A NAME="MIN_SET_UNION-val"><B>MIN_SET_UNION</B></A>]  Theorem
      
      |- !A B.
           FINITE A /\ FINITE B /\ A &lt;&gt; {} /\ B &lt;&gt; {} ==&gt;
           (MIN_SET (A UNION B) = MIN (MIN_SET A) (MIN_SET B))
   
   [<A NAME="NOT_EMPTY_INSERT-val"><B>NOT_EMPTY_INSERT</B></A>]  Theorem
      
      |- !x s. {} &lt;&gt; x INSERT s
   
   [<A NAME="NOT_EMPTY_SING-val"><B>NOT_EMPTY_SING</B></A>]  Theorem
      
      |- !x. {} &lt;&gt; {x}
   
   [<A NAME="NOT_EQUAL_SETS-val"><B>NOT_EQUAL_SETS</B></A>]  Theorem
      
      |- !s t. s &lt;&gt; t &lt;=&gt; ?x. x IN t &lt;=&gt; x NOTIN s
   
   [<A NAME="NOT_INSERT_EMPTY-val"><B>NOT_INSERT_EMPTY</B></A>]  Theorem
      
      |- !x s. x INSERT s &lt;&gt; {}
   
   [<A NAME="NOT_IN_EMPTY-val"><B>NOT_IN_EMPTY</B></A>]  Theorem
      
      |- !x. x NOTIN {}
   
   [<A NAME="NOT_IN_FINITE-val"><B>NOT_IN_FINITE</B></A>]  Theorem
      
      |- INFINITE UNIV &lt;=&gt; !s. FINITE s ==&gt; ?x. x NOTIN s
   
   [<A NAME="NOT_PSUBSET_EMPTY-val"><B>NOT_PSUBSET_EMPTY</B></A>]  Theorem
      
      |- !s. ~(s PSUBSET {})
   
   [<A NAME="NOT_SING_EMPTY-val"><B>NOT_SING_EMPTY</B></A>]  Theorem
      
      |- !x. {x} &lt;&gt; {}
   
   [<A NAME="NOT_UNIV_PSUBSET-val"><B>NOT_UNIV_PSUBSET</B></A>]  Theorem
      
      |- !s. ~(UNIV PSUBSET s)
   
   [<A NAME="NUM_SET_WOP-val"><B>NUM_SET_WOP</B></A>]  Theorem
      
      |- !s. (?n. n IN s) &lt;=&gt; ?n. n IN s /\ !m. m IN s ==&gt; n &lt;= m
   
   [<A NAME="PHP-val"><B>PHP</B></A>]  Theorem
      
      |- !f s t. FINITE t /\ CARD t &lt; CARD s ==&gt; ~INJ f s t
   
   [<A NAME="POW_EQNS-val"><B>POW_EQNS</B></A>]  Theorem
      
      |- (POW {} = {{}}) /\
         !e s.
           POW (e INSERT s) =
           (let ps = POW s in IMAGE ($INSERT e) ps UNION ps)
   
   [<A NAME="POW_INSERT-val"><B>POW_INSERT</B></A>]  Theorem
      
      |- !e s. POW (e INSERT s) = IMAGE ($INSERT e) (POW s) UNION POW s
   
   [<A NAME="PSUBSET_EQN-val"><B>PSUBSET_EQN</B></A>]  Theorem
      
      |- !s1 s2. s1 PSUBSET s2 &lt;=&gt; s1 SUBSET s2 /\ ~(s2 SUBSET s1)
   
   [<A NAME="PSUBSET_FINITE-val"><B>PSUBSET_FINITE</B></A>]  Theorem
      
      |- !s. FINITE s ==&gt; !t. t PSUBSET s ==&gt; FINITE t
   
   [<A NAME="PSUBSET_INSERT_SUBSET-val"><B>PSUBSET_INSERT_SUBSET</B></A>]  Theorem
      
      |- !s t. s PSUBSET t &lt;=&gt; ?x. x NOTIN s /\ x INSERT s SUBSET t
   
   [<A NAME="PSUBSET_IRREFL-val"><B>PSUBSET_IRREFL</B></A>]  Theorem
      
      |- !s. ~(s PSUBSET s)
   
   [<A NAME="PSUBSET_MEMBER-val"><B>PSUBSET_MEMBER</B></A>]  Theorem
      
      |- !s t. s PSUBSET t &lt;=&gt; s SUBSET t /\ ?y. y IN t /\ y NOTIN s
   
   [<A NAME="PSUBSET_SING-val"><B>PSUBSET_SING</B></A>]  Theorem
      
      |- !s x. x PSUBSET {s} &lt;=&gt; (x = {})
   
   [<A NAME="PSUBSET_TRANS-val"><B>PSUBSET_TRANS</B></A>]  Theorem
      
      |- !s t u. s PSUBSET t /\ t PSUBSET u ==&gt; s PSUBSET u
   
   [<A NAME="PSUBSET_UNIV-val"><B>PSUBSET_UNIV</B></A>]  Theorem
      
      |- !s. s PSUBSET UNIV &lt;=&gt; ?x. x NOTIN s
   
   [<A NAME="REST_PSUBSET-val"><B>REST_PSUBSET</B></A>]  Theorem
      
      |- !s. s &lt;&gt; {} ==&gt; REST s PSUBSET s
   
   [<A NAME="REST_SING-val"><B>REST_SING</B></A>]  Theorem
      
      |- !x. REST {x} = {}
   
   [<A NAME="REST_SUBSET-val"><B>REST_SUBSET</B></A>]  Theorem
      
      |- !s. REST s SUBSET s
   
   [<A NAME="SET_CASES-val"><B>SET_CASES</B></A>]  Theorem
      
      |- !s. (s = {}) \/ ?x t. (s = x INSERT t) /\ x NOTIN t
   
   [<A NAME="SET_EQ_SUBSET-val"><B>SET_EQ_SUBSET</B></A>]  Theorem
      
      |- !s1 s2. (s1 = s2) &lt;=&gt; s1 SUBSET s2 /\ s2 SUBSET s1
   
   [<A NAME="SET_MINIMUM-val"><B>SET_MINIMUM</B></A>]  Theorem
      
      |- !s M. (?x. x IN s) &lt;=&gt; ?x. x IN s /\ !y. y IN s ==&gt; M x &lt;= M y
   
   [<A NAME="SING-val"><B>SING</B></A>]  Theorem
      
      |- !x. SING {x}
   
   [<A NAME="SING_DELETE-val"><B>SING_DELETE</B></A>]  Theorem
      
      |- !x. {x} DELETE x = {}
   
   [<A NAME="SING_FINITE-val"><B>SING_FINITE</B></A>]  Theorem
      
      |- !s. SING s ==&gt; FINITE s
   
   [<A NAME="SING_IFF_CARD1-val"><B>SING_IFF_CARD1</B></A>]  Theorem
      
      |- !s. SING s &lt;=&gt; (CARD s = 1) /\ FINITE s
   
   [<A NAME="SING_IFF_EMPTY_REST-val"><B>SING_IFF_EMPTY_REST</B></A>]  Theorem
      
      |- !s. SING s &lt;=&gt; s &lt;&gt; {} /\ (REST s = {})
   
   [<A NAME="SPECIFICATION-val"><B>SPECIFICATION</B></A>]  Theorem
      
      |- !P x. x IN P &lt;=&gt; P x
   
   [<A NAME="SUBSET_ANTISYM-val"><B>SUBSET_ANTISYM</B></A>]  Theorem
      
      |- !s t. s SUBSET t /\ t SUBSET s ==&gt; (s = t)
   
   [<A NAME="SUBSET_BIGINTER-val"><B>SUBSET_BIGINTER</B></A>]  Theorem
      
      |- !X P. X SUBSET BIGINTER P &lt;=&gt; !Y. Y IN P ==&gt; X SUBSET Y
   
   [<A NAME="SUBSET_DELETE-val"><B>SUBSET_DELETE</B></A>]  Theorem
      
      |- !x s t. s SUBSET t DELETE x &lt;=&gt; x NOTIN s /\ s SUBSET t
   
   [<A NAME="SUBSET_DELETE_BOTH-val"><B>SUBSET_DELETE_BOTH</B></A>]  Theorem
      
      |- !s1 s2 x. s1 SUBSET s2 ==&gt; s1 DELETE x SUBSET s2 DELETE x
   
   [<A NAME="SUBSET_DIFF-val"><B>SUBSET_DIFF</B></A>]  Theorem
      
      |- !s1 s2 s3. s1 SUBSET s2 DIFF s3 &lt;=&gt; s1 SUBSET s2 /\ DISJOINT s1 s3
   
   [<A NAME="SUBSET_EMPTY-val"><B>SUBSET_EMPTY</B></A>]  Theorem
      
      |- !s. s SUBSET {} &lt;=&gt; (s = {})
   
   [<A NAME="SUBSET_EQ_CARD-val"><B>SUBSET_EQ_CARD</B></A>]  Theorem
      
      |- !s.
           FINITE s ==&gt;
           !t. FINITE t /\ (CARD s = CARD t) /\ s SUBSET t ==&gt; (s = t)
   
   [<A NAME="SUBSET_FINITE-val"><B>SUBSET_FINITE</B></A>]  Theorem
      
      |- !s. FINITE s ==&gt; !t. t SUBSET s ==&gt; FINITE t
   
   [<A NAME="SUBSET_INSERT-val"><B>SUBSET_INSERT</B></A>]  Theorem
      
      |- !x s. x NOTIN s ==&gt; !t. s SUBSET x INSERT t &lt;=&gt; s SUBSET t
   
   [<A NAME="SUBSET_INSERT_DELETE-val"><B>SUBSET_INSERT_DELETE</B></A>]  Theorem
      
      |- !x s t. s SUBSET x INSERT t &lt;=&gt; s DELETE x SUBSET t
   
   [<A NAME="SUBSET_INSERT_RIGHT-val"><B>SUBSET_INSERT_RIGHT</B></A>]  Theorem
      
      |- !e s1 s2. s1 SUBSET s2 ==&gt; s1 SUBSET e INSERT s2
   
   [<A NAME="SUBSET_INTER-val"><B>SUBSET_INTER</B></A>]  Theorem
      
      |- !s t u. s SUBSET t INTER u &lt;=&gt; s SUBSET t /\ s SUBSET u
   
   [<A NAME="SUBSET_INTER_ABSORPTION-val"><B>SUBSET_INTER_ABSORPTION</B></A>]  Theorem
      
      |- !s t. s SUBSET t &lt;=&gt; (s INTER t = s)
   
   [<A NAME="SUBSET_MAX_SET-val"><B>SUBSET_MAX_SET</B></A>]  Theorem
      
      |- !I J n.
           FINITE I /\ FINITE J /\ I &lt;&gt; {} /\ J &lt;&gt; {} /\ I SUBSET J ==&gt;
           MAX_SET I &lt;= MAX_SET J
   
   [<A NAME="SUBSET_MIN_SET-val"><B>SUBSET_MIN_SET</B></A>]  Theorem
      
      |- !I J n.
           I &lt;&gt; {} /\ J &lt;&gt; {} /\ I SUBSET J ==&gt; MIN_SET J &lt;= MIN_SET I
   
   [<A NAME="SUBSET_POW-val"><B>SUBSET_POW</B></A>]  Theorem
      
      |- !s1 s2. s1 SUBSET s2 ==&gt; POW s1 SUBSET POW s2
   
   [<A NAME="SUBSET_REFL-val"><B>SUBSET_REFL</B></A>]  Theorem
      
      |- !s. s SUBSET s
   
   [<A NAME="SUBSET_TRANS-val"><B>SUBSET_TRANS</B></A>]  Theorem
      
      |- !s t u. s SUBSET t /\ t SUBSET u ==&gt; s SUBSET u
   
   [<A NAME="SUBSET_UNION-val"><B>SUBSET_UNION</B></A>]  Theorem
      
      |- (!s t. s SUBSET s UNION t) /\ !s t. s SUBSET t UNION s
   
   [<A NAME="SUBSET_UNION_ABSORPTION-val"><B>SUBSET_UNION_ABSORPTION</B></A>]  Theorem
      
      |- !s t. s SUBSET t &lt;=&gt; (s UNION t = t)
   
   [<A NAME="SUBSET_UNIV-val"><B>SUBSET_UNIV</B></A>]  Theorem
      
      |- !s. s SUBSET UNIV
   
   [<A NAME="SUM_IMAGE_DELETE-val"><B>SUM_IMAGE_DELETE</B></A>]  Theorem
      
      |- !f s.
           FINITE s ==&gt;
           !e.
             SIGMA f (s DELETE e) =
             if e IN s then SIGMA f s - f e else SIGMA f s
   
   [<A NAME="SUM_IMAGE_IN_LE-val"><B>SUM_IMAGE_IN_LE</B></A>]  Theorem
      
      |- !f s e. FINITE s /\ e IN s ==&gt; f e &lt;= SIGMA f s
   
   [<A NAME="SUM_IMAGE_SING-val"><B>SUM_IMAGE_SING</B></A>]  Theorem
      
      |- !f e. SIGMA f {e} = f e
   
   [<A NAME="SUM_IMAGE_SUBSET_LE-val"><B>SUM_IMAGE_SUBSET_LE</B></A>]  Theorem
      
      |- !f s t. FINITE s /\ t SUBSET s ==&gt; SIGMA f t &lt;= SIGMA f s
   
   [<A NAME="SUM_IMAGE_THM-val"><B>SUM_IMAGE_THM</B></A>]  Theorem
      
      |- !f.
           (SIGMA f {} = 0) /\
           !e s.
             FINITE s ==&gt;
             (SIGMA f (e INSERT s) = f e + SIGMA f (s DELETE e))
   
   [<A NAME="SUM_IMAGE_UNION-val"><B>SUM_IMAGE_UNION</B></A>]  Theorem
      
      |- !f s t.
           FINITE s /\ FINITE t ==&gt;
           (SIGMA f (s UNION t) =
            SIGMA f s + SIGMA f t - SIGMA f (s INTER t))
   
   [<A NAME="SUM_IMAGE_lower_bound-val"><B>SUM_IMAGE_lower_bound</B></A>]  Theorem
      
      |- !s.
           FINITE s ==&gt;
           !n. (!x. x IN s ==&gt; n &lt;= f x) ==&gt; CARD s * n &lt;= SIGMA f s
   
   [<A NAME="SUM_IMAGE_upper_bound-val"><B>SUM_IMAGE_upper_bound</B></A>]  Theorem
      
      |- !s.
           FINITE s ==&gt;
           !n. (!x. x IN s ==&gt; f x &lt;= n) ==&gt; SIGMA f s &lt;= CARD s * n
   
   [<A NAME="SUM_SAME_IMAGE-val"><B>SUM_SAME_IMAGE</B></A>]  Theorem
      
      |- !P.
           FINITE P ==&gt;
           !f p.
             p IN P /\ (!q. q IN P ==&gt; (f p = f q)) ==&gt;
             (SIGMA f P = CARD P * f p)
   
   [<A NAME="SUM_SET_DELETE-val"><B>SUM_SET_DELETE</B></A>]  Theorem
      
      |- !s.
           FINITE s ==&gt;
           !e.
             SUM_SET (s DELETE e) =
             if e IN s then SUM_SET s - e else SUM_SET s
   
   [<A NAME="SUM_SET_IN_LE-val"><B>SUM_SET_IN_LE</B></A>]  Theorem
      
      |- !x s. FINITE s /\ x IN s ==&gt; x &lt;= SUM_SET s
   
   [<A NAME="SUM_SET_SING-val"><B>SUM_SET_SING</B></A>]  Theorem
      
      |- !n. SUM_SET {n} = n
   
   [<A NAME="SUM_SET_SUBSET_LE-val"><B>SUM_SET_SUBSET_LE</B></A>]  Theorem
      
      |- !s t. FINITE t /\ s SUBSET t ==&gt; SUM_SET s &lt;= SUM_SET t
   
   [<A NAME="SUM_SET_THM-val"><B>SUM_SET_THM</B></A>]  Theorem
      
      |- (SUM_SET {} = 0) /\
         !x s.
           FINITE s ==&gt; (SUM_SET (x INSERT s) = x + SUM_SET (s DELETE x))
   
   [<A NAME="SUM_SET_UNION-val"><B>SUM_SET_UNION</B></A>]  Theorem
      
      |- !s t.
           FINITE s /\ FINITE t ==&gt;
           (SUM_SET (s UNION t) =
            SUM_SET s + SUM_SET t - SUM_SET (s INTER t))
   
   [<A NAME="SURJ_COMPOSE-val"><B>SURJ_COMPOSE</B></A>]  Theorem
      
      |- !f g s t u. SURJ f s t /\ SURJ g t u ==&gt; SURJ (g o f) s u
   
   [<A NAME="SURJ_EMPTY-val"><B>SURJ_EMPTY</B></A>]  Theorem
      
      |- !f. (!s. SURJ f {} s &lt;=&gt; (s = {})) /\ !s. SURJ f s {} &lt;=&gt; (s = {})
   
   [<A NAME="SURJ_ID-val"><B>SURJ_ID</B></A>]  Theorem
      
      |- !s. SURJ (\x. x) s s
   
   [<A NAME="UNION_ASSOC-val"><B>UNION_ASSOC</B></A>]  Theorem
      
      |- !s t u. s UNION (t UNION u) = s UNION t UNION u
   
   [<A NAME="UNION_COMM-val"><B>UNION_COMM</B></A>]  Theorem
      
      |- !s t. s UNION t = t UNION s
   
   [<A NAME="UNION_DELETE-val"><B>UNION_DELETE</B></A>]  Theorem
      
      |- !A B x. A UNION B DELETE x = A DELETE x UNION (B DELETE x)
   
   [<A NAME="UNION_EMPTY-val"><B>UNION_EMPTY</B></A>]  Theorem
      
      |- (!s. {} UNION s = s) /\ !s. s UNION {} = s
   
   [<A NAME="UNION_IDEMPOT-val"><B>UNION_IDEMPOT</B></A>]  Theorem
      
      |- !s. s UNION s = s
   
   [<A NAME="UNION_OVER_INTER-val"><B>UNION_OVER_INTER</B></A>]  Theorem
      
      |- !s t u. s INTER (t UNION u) = s INTER t UNION s INTER u
   
   [<A NAME="UNION_SUBSET-val"><B>UNION_SUBSET</B></A>]  Theorem
      
      |- !s t u. s UNION t SUBSET u &lt;=&gt; s SUBSET u /\ t SUBSET u
   
   [<A NAME="UNION_UNIV-val"><B>UNION_UNIV</B></A>]  Theorem
      
      |- (!s. UNIV UNION s = UNIV) /\ !s. s UNION UNIV = UNIV
   
   [<A NAME="UNIQUE_MEMBER_SING-val"><B>UNIQUE_MEMBER_SING</B></A>]  Theorem
      
      |- !x s. x IN s /\ (!y. y IN s ==&gt; (x = y)) &lt;=&gt; (s = {x})
   
   [<A NAME="UNIV_NOT_EMPTY-val"><B>UNIV_NOT_EMPTY</B></A>]  Theorem
      
      |- UNIV &lt;&gt; {}
   
   [<A NAME="UNIV_SUBSET-val"><B>UNIV_SUBSET</B></A>]  Theorem
      
      |- !s. UNIV SUBSET s &lt;=&gt; (s = UNIV)
   
   [<A NAME="bigunion_countable-val"><B>bigunion_countable</B></A>]  Theorem
      
      |- !s.
           countable s /\ (!x. x IN s ==&gt; countable x) ==&gt;
           countable (BIGUNION s)
   
   [<A NAME="count_EQN-val"><B>count_EQN</B></A>]  Theorem
      
      |- !n.
           count n =
           if n = 0 then {} else (let p = PRE n in p INSERT count p)
   
   [<A NAME="countable_surj-val"><B>countable_surj</B></A>]  Theorem
      
      |- !s. countable s &lt;=&gt; (s = {}) \/ ?f. SURJ f UNIV s
   
   [<A NAME="cross_countable-val"><B>cross_countable</B></A>]  Theorem
      
      |- !s t. countable s /\ countable t ==&gt; countable (s CROSS t)
   
   [<A NAME="finite_countable-val"><B>finite_countable</B></A>]  Theorem
      
      |- !s. FINITE s ==&gt; countable s
   
   [<A NAME="image_countable-val"><B>image_countable</B></A>]  Theorem
      
      |- !f s. countable s ==&gt; countable (IMAGE f s)
   
   [<A NAME="infinite_num_inj-val"><B>infinite_num_inj</B></A>]  Theorem
      
      |- !s. INFINITE s &lt;=&gt; ?f. INJ f UNIV s
   
   [<A NAME="infinite_pow_uncountable-val"><B>infinite_pow_uncountable</B></A>]  Theorem
      
      |- !s. INFINITE s ==&gt; ~countable (POW s)
   
   [<A NAME="infinite_rest-val"><B>infinite_rest</B></A>]  Theorem
      
      |- !s. INFINITE s ==&gt; INFINITE (REST s)
   
   [<A NAME="inj_countable-val"><B>inj_countable</B></A>]  Theorem
      
      |- !f s t. countable t /\ INJ f s t ==&gt; countable s
   
   [<A NAME="inj_surj-val"><B>inj_surj</B></A>]  Theorem
      
      |- !f s t. INJ f s t ==&gt; (s = {}) \/ ?f'. SURJ f' t s
   
   [<A NAME="inter_countable-val"><B>inter_countable</B></A>]  Theorem
      
      |- !s t. countable s \/ countable t ==&gt; countable (s INTER t)
   
   [<A NAME="num_countable-val"><B>num_countable</B></A>]  Theorem
      
      |- countable UNIV
   
   [<A NAME="pair_to_num_def-val"><B>pair_to_num_def</B></A>]  Theorem
      
      |- (pair_to_num (0,0) = 0) /\
         (pair_to_num (SUC x,0) = SUC (pair_to_num (0,x))) /\
         (pair_to_num (0,SUC y) = SUC (pair_to_num (SUC 0,y))) /\
         (pair_to_num (SUC v2,SUC y) = SUC (pair_to_num (SUC (SUC v2),y)))
   
   [<A NAME="pair_to_num_formula-val"><B>pair_to_num_formula</B></A>]  Theorem
      
      |- !x y. pair_to_num (x,y) = (x + y + 1) * (x + y) DIV 2 + y
   
   [<A NAME="pair_to_num_ind-val"><B>pair_to_num_ind</B></A>]  Theorem
      
      |- !P.
           P (0,0) /\ (!x. P (0,x) ==&gt; P (SUC x,0)) /\
           (!y. P (SUC 0,y) ==&gt; P (0,SUC y)) /\
           (!v2 y. P (SUC (SUC v2),y) ==&gt; P (SUC v2,SUC y)) ==&gt;
           !v v1. P (v,v1)
   
   [<A NAME="pair_to_num_inv-val"><B>pair_to_num_inv</B></A>]  Theorem
      
      |- (!x. pair_to_num (num_to_pair x) = x) /\
         !x y. num_to_pair (pair_to_num (x,y)) = (x,y)
   
   [<A NAME="partition_CARD-val"><B>partition_CARD</B></A>]  Theorem
      
      |- !R s.
           R equiv_on s /\ FINITE s ==&gt;
           (CARD s = SIGMA CARD (partition R s))
   
   [<A NAME="partition_SUBSET-val"><B>partition_SUBSET</B></A>]  Theorem
      
      |- !R s t. R equiv_on s /\ t IN partition R s ==&gt; t SUBSET s
   
   [<A NAME="partition_elements_disjoint-val"><B>partition_elements_disjoint</B></A>]  Theorem
      
      |- R equiv_on s ==&gt;
         !t1 t2.
           t1 IN partition R s /\ t2 IN partition R s /\ t1 &lt;&gt; t2 ==&gt;
           DISJOINT t1 t2
   
   [<A NAME="partition_elements_interrelate-val"><B>partition_elements_interrelate</B></A>]  Theorem
      
      |- R equiv_on s ==&gt;
         !t. t IN partition R s ==&gt; !x y. x IN t /\ y IN t ==&gt; R x y
   
   [<A NAME="pow_no_surj-val"><B>pow_no_surj</B></A>]  Theorem
      
      |- !s. ~?f. SURJ f s (POW s)
   
   [<A NAME="subset_countable-val"><B>subset_countable</B></A>]  Theorem
      
      |- !s t. countable s /\ t SUBSET s ==&gt; countable t
   
   [<A NAME="union_countable-val"><B>union_countable</B></A>]  Theorem
      
      |- !s t. countable s /\ countable t ==&gt; countable (s UNION t)
   
   
*)
end

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/pred_set/src/pred_setScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
