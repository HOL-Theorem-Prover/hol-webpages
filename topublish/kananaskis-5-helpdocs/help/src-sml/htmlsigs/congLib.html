<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure congLib</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure congLib</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/simp/src/congLib.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>(* ========================================================================= *)
<A NAME="line2"></A>(* Simplification of terms similar to SIMP_CONV but regarding arbitrary      *)
<A NAME="line3"></A>(* preorders instead of just equality                                        *)
<A NAME="line4"></A>(* Created by Thomas Tuerk, March 2006                                       *)
<A NAME="line5"></A>(* ========================================================================= *)
<A NAME="line6"></A>
<A NAME="line7"></A>signature congLib =
<A NAME="line8"></A>sig
<A NAME="line9"></A>  include Abbrev
<A NAME="line10"></A>
<A NAME="line11"></A>  (* ---------------------------------------------------------------------
<A NAME="line12"></A>  * congLib
<A NAME="line13"></A>  *
<A NAME="line14"></A>  * SIMP_CONV as defined in simpLib is a very useful tool. However,
<A NAME="line15"></A>  * it is limited to simplify a term t1 to a term t2 which is equivalent
<A NAME="line16"></A>  * according to the congruence =. The underlying traverser (TRAVERSER.sml)
<A NAME="line17"></A>  * however is able to handle arbitrary congruences.
<A NAME="line18"></A>  *
<A NAME="line19"></A>  * This lib tries to provide this ability of the traverser to handle arbitrary
<A NAME="line20"></A>  * congruences (or in fact preorders) to the the end user. Therefore, an
<A NAME="line21"></A>  * interface similar to the interface of SimpLib is provided.
<A NAME="line22"></A>  *)
<A NAME="line23"></A>
<A NAME="line24"></A>  
<A NAME="line25"></A>  (* ---------------------------------------------------------------------
<A NAME="line26"></A>  * congsetfrag
<A NAME="line27"></A>  *
<A NAME="line28"></A>  * Similar to ssfrag the datatype congsetfrag is a type used to construct
<A NAME="line29"></A>  * congsets. It contains:
<A NAME="line30"></A>  *    relations: a list of preorders, that may be used for simplification
<A NAME="line31"></A>  *               a preorder is defined as in travrules. You may use mk_preorder from
<A NAME="line32"></A>  *               to create preorders
<A NAME="line33"></A>  *    rewrs:     a set of rewrite theorems
<A NAME="line34"></A>  *               unlike simpLib conditional and ordered rewriting is not supported
<A NAME="line35"></A>  *               ad the moment. Therefore rewrite thms have to be of the form
<A NAME="line36"></A>  *               (R x y) where R is a preorder contained in relations or the equality.
<A NAME="line37"></A>  *               Additionally it is possible to provide theorems that use 
<A NAME="line38"></A>  *               allquantification and that are conjunctions of such theorems.
<A NAME="line39"></A>  *               Notice, that providing rewrites like (x + y = y + x) will cause the
<A NAME="line40"></A>  *               simplification to loop, because no ordered rewriting is provided.
<A NAME="line41"></A>  *    congs:     The congruence rules for the preorders. These rules are just defined
<A NAME="line42"></A>  *               as congruence rules, for the simplifier, since both are in fact 
<A NAME="line43"></A>  *               congruence rules for the traverser. This means a congruence Rule is of
<A NAME="line44"></A>  *               the form 
<A NAME="line45"></A>  *               R1 x1 y1 ==&gt; R2 x2 y2 ==&gt; ... Rn xn yn ==&gt; R x y
<A NAME="line46"></A>  *               When simplifing a term t that matches x, where x contains x1, ... xn, *               it first simplifies (x1 to y1 according to R1) then
<A NAME="line47"></A>  *               (x2 to y2 according to R2)... and finally return R x y where
<A NAME="line48"></A>  *               (y is instanciated by the match and the values for y1 ... yn.
<A NAME="line49"></A>  *    dprocs:    a list of decision procedures as used by the traverser
<A NAME="line50"></A>  *               normally, you won't need dprocs. However, it provides some interface *               to convert terms much more intelligent as rewrs do.
<A NAME="line51"></A>  *)
<A NAME="line52"></A>  datatype congsetfrag = CSFRAG of
<A NAME="line53"></A>    {relations : Travrules.preorder list,
<A NAME="line54"></A>     rewrs  : thm list,
<A NAME="line55"></A>     congs  : thm list,     
<A NAME="line56"></A>     dprocs : Traverse.reducer list
<A NAME="line57"></A>     };
<A NAME="line58"></A>  
<A NAME="line59"></A>  (* ---------------------------------------------------------------------
<A NAME="line60"></A>  * congset
<A NAME="line61"></A>  *  
<A NAME="line62"></A>  * The real datastructure. It contains processed informations of consetfrags
<A NAME="line63"></A>  *) 
<A NAME="line64"></A>  type congset;
<A NAME="line65"></A>  
<A NAME="line66"></A>  
<A NAME="line67"></A>  (*Some elemantary functions to handle congsets and congsetfrags*)
<A NAME="line68"></A>
<A NAME="line69"></A>  (*The empty congset, containing just equality*)
<A NAME="line70"></A>  val empty_congset : congset;
<A NAME="line71"></A>
<A NAME="line72"></A>  (*Creates a congset out of a list of congsetfrags*)  
<A NAME="line73"></A>  val mk_congset : congsetfrag list -&gt; congset
<A NAME="line74"></A>
<A NAME="line75"></A>  (*Adds a congsetfrag to a congset*)
<A NAME="line76"></A>  val cs_addfrag : congset -&gt; congsetfrag -&gt; congset
<A NAME="line77"></A>
<A NAME="line78"></A>  (*Merges several congsetfrags*)  
<A NAME="line79"></A>  val merge_cs : congsetfrag list -&gt; congsetfrag
<A NAME="line80"></A>
<A NAME="line81"></A>  (*creates a congsetfrag just containing rewrites*)  
<A NAME="line82"></A>  val csfrag_rewrites : thm list -&gt; congsetfrag
<A NAME="line83"></A>
<A NAME="line84"></A>  (*adds rewrites to a congsetfrag*)  
<A NAME="line85"></A>  val add_csfrag_rewrites : congsetfrag -&gt; thm list -&gt; congsetfrag
<A NAME="line86"></A>
<A NAME="line87"></A>
<A NAME="line88"></A>
<A NAME="line89"></A>  (* ---------------------------------------------------------------------
<A NAME="line90"></A>  * CONGRUENCE_SIMP_CONV
<A NAME="line91"></A>  *
<A NAME="line92"></A>  * This is the main function. It is quite similar to SIMP_CONV. Additionally to
<A NAME="line93"></A>  * SIMP_CONV, it takes as the first argument the relation it
<A NAME="line94"></A>  * should simplify according to and as the second argument a congset. 
<A NAME="line95"></A>  * The other parameters are just like the parameters of SIMP_CONV.
<A NAME="line96"></A>  * Notice, that CONGRUENCE_SIMP_CONV ``$=`` empty_congset shoult behave
<A NAME="line97"></A>  * exactly like SIMP_CONV.
<A NAME="line98"></A>  * ---------------------------------------------------------------------*)
<A NAME="line99"></A>
<A NAME="line100"></A>  val CONGRUENCE_SIMP_CONV: term -&gt; congset -&gt; simpLib.simpset -&gt; thm list -&gt; term -&gt; thm
<A NAME="line101"></A>
<A NAME="line102"></A>
<A NAME="line103"></A>  (*
<A NAME="line104"></A>  * CONGRUENCE_SIMP_QCONV
<A NAME="line105"></A>  *
<A NAME="line106"></A>  * Similar to CONGRUENCE_SIMP_CONV. However, CONGRUENCE_SIMP_CONV returns R x x, if
<A NAME="line107"></A>  * it can not simplify x. CONGRUENCE_SIMP_QCONV will fail in this case.
<A NAME="line108"></A>  *)
<A NAME="line109"></A>  val CONGRUENCE_SIMP_QCONV: term -&gt; congset -&gt; simpLib.simpset -&gt; thm list -&gt; term -&gt; thm
<A NAME="line110"></A>
<A NAME="line111"></A>
<A NAME="line112"></A>  (* ---------------------------------------------------------------------
<A NAME="line113"></A>  * CONGRUENCE_EQ_SIMP_CONV
<A NAME="line114"></A>  *
<A NAME="line115"></A>  * CONGRUENCE_SIMP_CONV with the equality relation, i.e. CONGRUENCE_SIMP_CONV ``$=``
<A NAME="line116"></A>  * ---------------------------------------------------------------------*)
<A NAME="line117"></A>  val CONGRUENCE_EQ_SIMP_CONV: congset -&gt; simpLib.simpset -&gt; thm list -&gt; term -&gt; thm
<A NAME="line118"></A>
<A NAME="line119"></A>
<A NAME="line120"></A>  (* ---------------------------------------------------------------------
<A NAME="line121"></A>  * Tactics and rule similar to simpLib. They all use the equality relation as
<A NAME="line122"></A>  * starting relation. However, by congruence rules, some other relations may be used
<A NAME="line123"></A>  * for subterms
<A NAME="line124"></A>  * ---------------------------------------------------------------------*)
<A NAME="line125"></A>
<A NAME="line126"></A>  val CONGRUENCE_SIMP_RULE : congset -&gt; simpLib.simpset -&gt; thm list -&gt; thm -&gt; thm
<A NAME="line127"></A>  val CONGRUENCE_SIMP_TAC : congset -&gt; simpLib.simpset -&gt; thm list -&gt; tactic
<A NAME="line128"></A>  val ASM_CONGRUENCE_SIMP_TAC : congset -&gt; simpLib.simpset -&gt; thm list -&gt; tactic
<A NAME="line129"></A>  val FULL_CONGRUENCE_SIMP_TAC : congset -&gt; simpLib.simpset -&gt; thm list -&gt; tactic
<A NAME="line130"></A>
<A NAME="line131"></A>
<A NAME="line132"></A>end
<A NAME="line133"></A>
<A NAME="line134"></A>
</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/simp/src/congLib.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
