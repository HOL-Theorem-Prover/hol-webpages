<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure folTools</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure folTools</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/metis/folTools.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>(* ========================================================================= *)
<A NAME="line2"></A>(* A HOL INTERFACE TO THE FIRST-ORDER PROVERS.                               *)
<A NAME="line3"></A>(* Created by Joe Hurd, October 2001                                         *)
<A NAME="line4"></A>(* ========================================================================= *)
<A NAME="line5"></A>
<A NAME="line6"></A>signature folTools =
<A NAME="line7"></A>sig
<A NAME="line8"></A>
<A NAME="line9"></A>type 'a pp       = 'a mlibUseful.pp
<A NAME="line10"></A>type 'a stream   = 'a mlibStream.stream
<A NAME="line11"></A>type formula1    = mlibTerm.formula
<A NAME="line12"></A>type thm1        = mlibThm.thm
<A NAME="line13"></A>type limit       = mlibMeter.limit
<A NAME="line14"></A>type solver_node = mlibSolver.solver_node
<A NAME="line15"></A>type hol_type    = Type.hol_type
<A NAME="line16"></A>type term        = Term.term
<A NAME="line17"></A>type thm         = Thm.thm
<A NAME="line18"></A>type conv        = Abbrev.conv
<A NAME="line19"></A>type rule        = Abbrev.rule
<A NAME="line20"></A>type tactic      = Abbrev.tactic
<A NAME="line21"></A>type vars        = term list * hol_type list
<A NAME="line22"></A>  
<A NAME="line23"></A>(* First-order parameters *)
<A NAME="line24"></A>type parameters =
<A NAME="line25"></A>  {equality     : bool,     (* Add equality axioms if needed *)
<A NAME="line26"></A>   combinator   : bool,     (* Add combinator reduction rules *)
<A NAME="line27"></A>   boolean      : bool,     (* Add rules for reasoning about booleans *)
<A NAME="line28"></A>   mapping_parm : folMapping.parameters}
<A NAME="line29"></A>
<A NAME="line30"></A>type 'a parmupdate = ('a -&gt; 'a) -&gt; parameters -&gt; parameters
<A NAME="line31"></A>val defaults            : parameters
<A NAME="line32"></A>val update_equality     : bool parmupdate
<A NAME="line33"></A>val update_combinator   : bool parmupdate
<A NAME="line34"></A>val update_boolean      : bool parmupdate
<A NAME="line35"></A>val update_mapping_parm : folMapping.parameters parmupdate
<A NAME="line36"></A>
<A NAME="line37"></A>(* If recent_fol_problems is set to NONE then nothing happens (the default). *)
<A NAME="line38"></A>(* If it is set to SOME l then every compiled FOL problem is cons'ed to l. *)
<A NAME="line39"></A>type fol_problem = {thms : thm1 list, hyps : thm1 list, query : formula1 list}
<A NAME="line40"></A>val recent_fol_problems : fol_problem list option ref
<A NAME="line41"></A>
<A NAME="line42"></A>(* Logic maps manage the interface between HOL and first-order logic *)
<A NAME="line43"></A>type logic_map
<A NAME="line44"></A>val new_map      : parameters -&gt; logic_map
<A NAME="line45"></A>val empty_map    : logic_map                      (* Uses defaults *)
<A NAME="line46"></A>val add_thm      : vars * thm -&gt; logic_map -&gt; logic_map
<A NAME="line47"></A>val add_hyp      : vars * thm -&gt; logic_map -&gt; logic_map
<A NAME="line48"></A>val add_const    : string -&gt; logic_map -&gt; logic_map
<A NAME="line49"></A>val build_map    : parameters * string list * thm list -&gt; logic_map
<A NAME="line50"></A>val pp_logic_map : logic_map pp
<A NAME="line51"></A>
<A NAME="line52"></A>(* A pure interface to the first-order solver: no normalization *)
<A NAME="line53"></A>type Query  = vars * term list
<A NAME="line54"></A>type Result = vars * thm list
<A NAME="line55"></A>val FOL_SOLVE  : solver_node -&gt; logic_map -&gt; limit -&gt; Query -&gt; Result stream
<A NAME="line56"></A>val FOL_FIND   : solver_node -&gt; logic_map -&gt; limit -&gt; Query -&gt; Result
<A NAME="line57"></A>val FOL_REFUTE : solver_node -&gt; logic_map -&gt; limit -&gt; thm
<A NAME="line58"></A>val FOL_TACTIC : solver_node -&gt; logic_map -&gt; limit -&gt; tactic
<A NAME="line59"></A>
<A NAME="line60"></A>(* HOL normalization to conjunctive normal form *)
<A NAME="line61"></A>val FOL_NORM      : thm list -&gt; string list * thm list  (* Definitional CNF *)
<A NAME="line62"></A>val FOL_NORM_TAC  : tactic                  (* Stripping + Elimination of @ *)
<A NAME="line63"></A>val FOL_NORM_TTAC : (string list * thm list -&gt; tactic) -&gt; thm list -&gt; tactic
<A NAME="line64"></A>
<A NAME="line65"></A>(* Reading in TPTP problems *)
<A NAME="line66"></A>val tptp_read : {filename : string} -&gt; term
<A NAME="line67"></A>
<A NAME="line68"></A>end
<A NAME="line69"></A>
</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/metis/folTools.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
