<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure pathTheory</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure pathTheory</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/path/pathScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>signature pathTheory =
<A NAME="line2"></A>sig
<A NAME="line3"></A>  type thm = Thm.thm
<A NAME="line4"></A>  
<A NAME="line5"></A>  (*  Definitions  *)
<A NAME="line6"></A>    val <A HREF="#PL_def-val">PL_def</A> : thm
<A NAME="line7"></A>    val <A HREF="#SN_def-val">SN_def</A> : thm
<A NAME="line8"></A>    val <A HREF="#drop_def-val">drop_def</A> : thm
<A NAME="line9"></A>    val <A HREF="#el_def-val">el_def</A> : thm
<A NAME="line10"></A>    val <A HREF="#every_def-val">every_def</A> : thm
<A NAME="line11"></A>    val <A HREF="#exists_def-val">exists_def</A> : thm
<A NAME="line12"></A>    val <A HREF="#filter_def-val">filter_def</A> : thm
<A NAME="line13"></A>    val <A HREF="#finite_def-val">finite_def</A> : thm
<A NAME="line14"></A>    val <A HREF="#firstP_at_def-val">firstP_at_def</A> : thm
<A NAME="line15"></A>    val <A HREF="#first_def-val">first_def</A> : thm
<A NAME="line16"></A>    val <A HREF="#first_label_def-val">first_label_def</A> : thm
<A NAME="line17"></A>    val <A HREF="#is_stopped_def-val">is_stopped_def</A> : thm
<A NAME="line18"></A>    val <A HREF="#labels_def-val">labels_def</A> : thm
<A NAME="line19"></A>    val <A HREF="#last_thm-val">last_thm</A> : thm
<A NAME="line20"></A>    val <A HREF="#length_def-val">length_def</A> : thm
<A NAME="line21"></A>    val <A HREF="#mem_def-val">mem_def</A> : thm
<A NAME="line22"></A>    val <A HREF="#nth_label_def-val">nth_label_def</A> : thm
<A NAME="line23"></A>    val <A HREF="#okpath_def-val">okpath_def</A> : thm
<A NAME="line24"></A>    val <A HREF="#okpath_f_def-val">okpath_f_def</A> : thm
<A NAME="line25"></A>    val <A HREF="#path_TY_DEF-val">path_TY_DEF</A> : thm
<A NAME="line26"></A>    val <A HREF="#path_absrep_bijections-val">path_absrep_bijections</A> : thm
<A NAME="line27"></A>    val <A HREF="#pconcat_def-val">pconcat_def</A> : thm
<A NAME="line28"></A>    val <A HREF="#pcons_def-val">pcons_def</A> : thm
<A NAME="line29"></A>    val <A HREF="#pgenerate_def-val">pgenerate_def</A> : thm
<A NAME="line30"></A>    val <A HREF="#plink_def-val">plink_def</A> : thm
<A NAME="line31"></A>    val <A HREF="#pmap_def-val">pmap_def</A> : thm
<A NAME="line32"></A>    val <A HREF="#seg_def-val">seg_def</A> : thm
<A NAME="line33"></A>    val <A HREF="#stopped_at_def-val">stopped_at_def</A> : thm
<A NAME="line34"></A>    val <A HREF="#tail_def-val">tail_def</A> : thm
<A NAME="line35"></A>    val <A HREF="#take_def-val">take_def</A> : thm
<A NAME="line36"></A>  
<A NAME="line37"></A>  (*  Theorems  *)
<A NAME="line38"></A>    val <A HREF="#FORALL_path-val">FORALL_path</A> : thm
<A NAME="line39"></A>    val <A HREF="#IN_PL_drop-val">IN_PL_drop</A> : thm
<A NAME="line40"></A>    val <A HREF="#PL_0-val">PL_0</A> : thm
<A NAME="line41"></A>    val <A HREF="#PL_downward_closed-val">PL_downward_closed</A> : thm
<A NAME="line42"></A>    val <A HREF="#PL_drop-val">PL_drop</A> : thm
<A NAME="line43"></A>    val <A HREF="#PL_pcons-val">PL_pcons</A> : thm
<A NAME="line44"></A>    val <A HREF="#PL_pmap-val">PL_pmap</A> : thm
<A NAME="line45"></A>    val <A HREF="#PL_seg-val">PL_seg</A> : thm
<A NAME="line46"></A>    val <A HREF="#PL_stopped_at-val">PL_stopped_at</A> : thm
<A NAME="line47"></A>    val <A HREF="#PL_take-val">PL_take</A> : thm
<A NAME="line48"></A>    val <A HREF="#PL_thm-val">PL_thm</A> : thm
<A NAME="line49"></A>    val <A HREF="#SN_finite_paths-val">SN_finite_paths</A> : thm
<A NAME="line50"></A>    val <A HREF="#SN_finite_paths_EQ-val">SN_finite_paths_EQ</A> : thm
<A NAME="line51"></A>    val <A HREF="#alt_length_thm-val">alt_length_thm</A> : thm
<A NAME="line52"></A>    val <A HREF="#el_drop-val">el_drop</A> : thm
<A NAME="line53"></A>    val <A HREF="#el_pgenerate-val">el_pgenerate</A> : thm
<A NAME="line54"></A>    val <A HREF="#el_pmap-val">el_pmap</A> : thm
<A NAME="line55"></A>    val <A HREF="#every_coinduction-val">every_coinduction</A> : thm
<A NAME="line56"></A>    val <A HREF="#every_el-val">every_el</A> : thm
<A NAME="line57"></A>    val <A HREF="#every_thm-val">every_thm</A> : thm
<A NAME="line58"></A>    val <A HREF="#exists_el-val">exists_el</A> : thm
<A NAME="line59"></A>    val <A HREF="#exists_induction-val">exists_induction</A> : thm
<A NAME="line60"></A>    val <A HREF="#exists_thm-val">exists_thm</A> : thm
<A NAME="line61"></A>    val <A HREF="#filter_every-val">filter_every</A> : thm
<A NAME="line62"></A>    val <A HREF="#finite_drop-val">finite_drop</A> : thm
<A NAME="line63"></A>    val <A HREF="#finite_length-val">finite_length</A> : thm
<A NAME="line64"></A>    val <A HREF="#finite_okpath_ind-val">finite_okpath_ind</A> : thm
<A NAME="line65"></A>    val <A HREF="#finite_path_ind-val">finite_path_ind</A> : thm
<A NAME="line66"></A>    val <A HREF="#finite_paths_SN-val">finite_paths_SN</A> : thm
<A NAME="line67"></A>    val <A HREF="#finite_pconcat-val">finite_pconcat</A> : thm
<A NAME="line68"></A>    val <A HREF="#finite_plink-val">finite_plink</A> : thm
<A NAME="line69"></A>    val <A HREF="#finite_pmap-val">finite_pmap</A> : thm
<A NAME="line70"></A>    val <A HREF="#finite_seg-val">finite_seg</A> : thm
<A NAME="line71"></A>    val <A HREF="#finite_take-val">finite_take</A> : thm
<A NAME="line72"></A>    val <A HREF="#finite_thm-val">finite_thm</A> : thm
<A NAME="line73"></A>    val <A HREF="#firstP_at_thm-val">firstP_at_thm</A> : thm
<A NAME="line74"></A>    val <A HREF="#firstP_at_unique-val">firstP_at_unique</A> : thm
<A NAME="line75"></A>    val <A HREF="#firstP_at_zero-val">firstP_at_zero</A> : thm
<A NAME="line76"></A>    val <A HREF="#first_drop-val">first_drop</A> : thm
<A NAME="line77"></A>    val <A HREF="#first_label_drop-val">first_label_drop</A> : thm
<A NAME="line78"></A>    val <A HREF="#first_plink-val">first_plink</A> : thm
<A NAME="line79"></A>    val <A HREF="#first_pmap-val">first_pmap</A> : thm
<A NAME="line80"></A>    val <A HREF="#first_seg-val">first_seg</A> : thm
<A NAME="line81"></A>    val <A HREF="#first_take-val">first_take</A> : thm
<A NAME="line82"></A>    val <A HREF="#first_thm-val">first_thm</A> : thm
<A NAME="line83"></A>    val <A HREF="#fromPath_11-val">fromPath_11</A> : thm
<A NAME="line84"></A>    val <A HREF="#fromPath_onto-val">fromPath_onto</A> : thm
<A NAME="line85"></A>    val <A HREF="#infinite_PL-val">infinite_PL</A> : thm
<A NAME="line86"></A>    val <A HREF="#is_stopped_thm-val">is_stopped_thm</A> : thm
<A NAME="line87"></A>    val <A HREF="#last_plink-val">last_plink</A> : thm
<A NAME="line88"></A>    val <A HREF="#last_pmap-val">last_pmap</A> : thm
<A NAME="line89"></A>    val <A HREF="#last_seg-val">last_seg</A> : thm
<A NAME="line90"></A>    val <A HREF="#last_take-val">last_take</A> : thm
<A NAME="line91"></A>    val <A HREF="#length_drop-val">length_drop</A> : thm
<A NAME="line92"></A>    val <A HREF="#length_never_zero-val">length_never_zero</A> : thm
<A NAME="line93"></A>    val <A HREF="#length_pmap-val">length_pmap</A> : thm
<A NAME="line94"></A>    val <A HREF="#length_take-val">length_take</A> : thm
<A NAME="line95"></A>    val <A HREF="#length_thm-val">length_thm</A> : thm
<A NAME="line96"></A>    val <A HREF="#mem_thm-val">mem_thm</A> : thm
<A NAME="line97"></A>    val <A HREF="#not_every-val">not_every</A> : thm
<A NAME="line98"></A>    val <A HREF="#not_exists-val">not_exists</A> : thm
<A NAME="line99"></A>    val <A HREF="#nth_label_drop-val">nth_label_drop</A> : thm
<A NAME="line100"></A>    val <A HREF="#nth_label_pgenerate-val">nth_label_pgenerate</A> : thm
<A NAME="line101"></A>    val <A HREF="#nth_label_pmap-val">nth_label_pmap</A> : thm
<A NAME="line102"></A>    val <A HREF="#nth_label_take-val">nth_label_take</A> : thm
<A NAME="line103"></A>    val <A HREF="#numeral_drop-val">numeral_drop</A> : thm
<A NAME="line104"></A>    val <A HREF="#okpath_cases-val">okpath_cases</A> : thm
<A NAME="line105"></A>    val <A HREF="#okpath_co_ind-val">okpath_co_ind</A> : thm
<A NAME="line106"></A>    val <A HREF="#okpath_drop-val">okpath_drop</A> : thm
<A NAME="line107"></A>    val <A HREF="#okpath_monotone-val">okpath_monotone</A> : thm
<A NAME="line108"></A>    val <A HREF="#okpath_plink-val">okpath_plink</A> : thm
<A NAME="line109"></A>    val <A HREF="#okpath_pmap-val">okpath_pmap</A> : thm
<A NAME="line110"></A>    val <A HREF="#okpath_seg-val">okpath_seg</A> : thm
<A NAME="line111"></A>    val <A HREF="#okpath_take-val">okpath_take</A> : thm
<A NAME="line112"></A>    val <A HREF="#okpath_thm-val">okpath_thm</A> : thm
<A NAME="line113"></A>    val <A HREF="#path_Axiom-val">path_Axiom</A> : thm
<A NAME="line114"></A>    val <A HREF="#path_bisimulation-val">path_bisimulation</A> : thm
<A NAME="line115"></A>    val <A HREF="#path_cases-val">path_cases</A> : thm
<A NAME="line116"></A>    val <A HREF="#path_rep_bijections_thm-val">path_rep_bijections_thm</A> : thm
<A NAME="line117"></A>    val <A HREF="#pconcat_eq_pcons-val">pconcat_eq_pcons</A> : thm
<A NAME="line118"></A>    val <A HREF="#pconcat_eq_stopped-val">pconcat_eq_stopped</A> : thm
<A NAME="line119"></A>    val <A HREF="#pconcat_thm-val">pconcat_thm</A> : thm
<A NAME="line120"></A>    val <A HREF="#pcons_11-val">pcons_11</A> : thm
<A NAME="line121"></A>    val <A HREF="#pgenerate_11-val">pgenerate_11</A> : thm
<A NAME="line122"></A>    val <A HREF="#pgenerate_infinite-val">pgenerate_infinite</A> : thm
<A NAME="line123"></A>    val <A HREF="#pgenerate_not_stopped-val">pgenerate_not_stopped</A> : thm
<A NAME="line124"></A>    val <A HREF="#pgenerate_onto-val">pgenerate_onto</A> : thm
<A NAME="line125"></A>    val <A HREF="#pmap_thm-val">pmap_thm</A> : thm
<A NAME="line126"></A>    val <A HREF="#recursive_seg-val">recursive_seg</A> : thm
<A NAME="line127"></A>    val <A HREF="#singleton_seg-val">singleton_seg</A> : thm
<A NAME="line128"></A>    val <A HREF="#stopped_at_11-val">stopped_at_11</A> : thm
<A NAME="line129"></A>    val <A HREF="#stopped_at_not_pcons-val">stopped_at_not_pcons</A> : thm
<A NAME="line130"></A>    val <A HREF="#tail_drop-val">tail_drop</A> : thm
<A NAME="line131"></A>    val <A HREF="#toPath_11-val">toPath_11</A> : thm
<A NAME="line132"></A>    val <A HREF="#toPath_onto-val">toPath_onto</A> : thm
<A NAME="line133"></A>  
<A NAME="line134"></A>  val path_grammars : type_grammar.grammar * term_grammar.grammar
<A NAME="line135"></A>  
<A NAME="line136"></A>  val path_rwts : simpLib.ssfrag
<A NAME="line137"></A>(*
   [fixedPoint] Parent theory of "path"
   
   [llist] Parent theory of "path"
   
   [<A NAME="PL_def-val"><B>PL_def</B></A>]  Definition
      
      |- !p. PL p = {i | finite p ==&gt; i &lt; THE (length p)}
   
   [<A NAME="SN_def-val"><B>SN_def</B></A>]  Definition
      
      |- !R. SN R &lt;=&gt; WF (\x y. ?l. R y l x)
   
   [<A NAME="drop_def-val"><B>drop_def</B></A>]  Definition
      
      |- (!p. drop 0 p = p) /\ !n p. drop (SUC n) p = drop n (tail p)
   
   [<A NAME="el_def-val"><B>el_def</B></A>]  Definition
      
      |- (!p. el 0 p = first p) /\ !n p. el (SUC n) p = el n (tail p)
   
   [<A NAME="every_def-val"><B>every_def</B></A>]  Definition
      
      |- !P p. every P p &lt;=&gt; ~exists ($~ o P) p
   
   [<A NAME="exists_def-val"><B>exists_def</B></A>]  Definition
      
      |- !P p. exists P p &lt;=&gt; ?i. firstP_at P p i
   
   [<A NAME="filter_def-val"><B>filter_def</B></A>]  Definition
      
      |- !P.
           (!x. P x ==&gt; (filter P (stopped_at x) = stopped_at x)) /\
           !x r p.
             filter P (pcons x r p) =
             if P x then
               if exists P p then pcons x r (filter P p) else stopped_at x
             else
               filter P p
   
   [<A NAME="finite_def-val"><B>finite_def</B></A>]  Definition
      
      |- !sigma. finite sigma &lt;=&gt; LFINITE (SND (fromPath sigma))
   
   [<A NAME="firstP_at_def-val"><B>firstP_at_def</B></A>]  Definition
      
      |- !P p i.
           firstP_at P p i &lt;=&gt;
           i IN PL p /\ P (el i p) /\ !j. j &lt; i ==&gt; ~P (el j p)
   
   [<A NAME="first_def-val"><B>first_def</B></A>]  Definition
      
      |- !p. first p = FST (fromPath p)
   
   [<A NAME="first_label_def-val"><B>first_label_def</B></A>]  Definition
      
      |- !x r p. first_label (pcons x r p) = r
   
   [<A NAME="is_stopped_def-val"><B>is_stopped_def</B></A>]  Definition
      
      |- !p. is_stopped p &lt;=&gt; ?x. p = stopped_at x
   
   [<A NAME="labels_def-val"><B>labels_def</B></A>]  Definition
      
      |- (!x. labels (stopped_at x) = [||]) /\
         !x r p. labels (pcons x r p) = r:::labels p
   
   [<A NAME="last_thm-val"><B>last_thm</B></A>]  Definition
      
      |- (!x. last (stopped_at x) = x) /\
         !x r p. last (pcons x r p) = last p
   
   [<A NAME="length_def-val"><B>length_def</B></A>]  Definition
      
      |- !p.
           length p =
           if finite p then
             SOME (LENGTH (THE (toList (SND (fromPath p)))) + 1)
           else
             NONE
   
   [<A NAME="mem_def-val"><B>mem_def</B></A>]  Definition
      
      |- !s p. mem s p &lt;=&gt; ?i. i IN PL p /\ (s = el i p)
   
   [<A NAME="nth_label_def-val"><B>nth_label_def</B></A>]  Definition
      
      |- (!p. nth_label 0 p = first_label p) /\
         !n p. nth_label (SUC n) p = nth_label n (tail p)
   
   [<A NAME="okpath_def-val"><B>okpath_def</B></A>]  Definition
      
      |- !R. okpath R = gfp (okpath_f R)
   
   [<A NAME="okpath_f_def-val"><B>okpath_f_def</B></A>]  Definition
      
      |- !R X.
           okpath_f R X =
           {stopped_at x | x IN UNIV} UNION
           {pcons x r p | R x r (first p) /\ p IN X}
   
   [<A NAME="path_TY_DEF-val"><B>path_TY_DEF</B></A>]  Definition
      
      |- ?rep. TYPE_DEFINITION (\x. T) rep
   
   [<A NAME="path_absrep_bijections-val"><B>path_absrep_bijections</B></A>]  Definition
      
      |- (!a. toPath (fromPath a) = a) /\
         !r. (\x. T) r &lt;=&gt; (fromPath (toPath r) = r)
   
   [<A NAME="pconcat_def-val"><B>pconcat_def</B></A>]  Definition
      
      |- !p1 lab p2.
           pconcat p1 lab p2 =
           toPath
             (first p1,
              LAPPEND (SND (fromPath p1))
                ((lab,first p2):::SND (fromPath p2)))
   
   [<A NAME="pcons_def-val"><B>pcons_def</B></A>]  Definition
      
      |- !x r p. pcons x r p = toPath (x,(r,first p):::SND (fromPath p))
   
   [<A NAME="pgenerate_def-val"><B>pgenerate_def</B></A>]  Definition
      
      |- !f g.
           pgenerate f g =
           pcons (f 0) (g 0) (pgenerate (f o SUC) (g o SUC))
   
   [<A NAME="plink_def-val"><B>plink_def</B></A>]  Definition
      
      |- (!x p. plink (stopped_at x) p = p) /\
         !x r p1 p2. plink (pcons x r p1) p2 = pcons x r (plink p1 p2)
   
   [<A NAME="pmap_def-val"><B>pmap_def</B></A>]  Definition
      
      |- !f g p. pmap f g p = toPath ((f ## LMAP (g ## f)) (fromPath p))
   
   [<A NAME="seg_def-val"><B>seg_def</B></A>]  Definition
      
      |- !i j p. seg i j p = take (j - i) (drop i p)
   
   [<A NAME="stopped_at_def-val"><B>stopped_at_def</B></A>]  Definition
      
      |- !x. stopped_at x = toPath (x,[||])
   
   [<A NAME="tail_def-val"><B>tail_def</B></A>]  Definition
      
      |- !x r p. tail (pcons x r p) = p
   
   [<A NAME="take_def-val"><B>take_def</B></A>]  Definition
      
      |- (!p. take 0 p = stopped_at (first p)) /\
         !n p.
           take (SUC n) p =
           pcons (first p) (first_label p) (take n (tail p))
   
   [<A NAME="FORALL_path-val"><B>FORALL_path</B></A>]  Theorem
      
      |- !P.
           (!p. P p) &lt;=&gt; (!x. P (stopped_at x)) /\ !x r p. P (pcons x r p)
   
   [<A NAME="IN_PL_drop-val"><B>IN_PL_drop</B></A>]  Theorem
      
      |- !i j p. i IN PL p ==&gt; (j IN PL (drop i p) &lt;=&gt; i + j IN PL p)
   
   [<A NAME="PL_0-val"><B>PL_0</B></A>]  Theorem
      
      |- !p. 0 IN PL p
   
   [<A NAME="PL_downward_closed-val"><B>PL_downward_closed</B></A>]  Theorem
      
      |- !i p. i IN PL p ==&gt; !j. j &lt; i ==&gt; j IN PL p
   
   [<A NAME="PL_drop-val"><B>PL_drop</B></A>]  Theorem
      
      |- !p i. i IN PL p ==&gt; (PL (drop i p) = IMAGE (\n. n - i) (PL p))
   
   [<A NAME="PL_pcons-val"><B>PL_pcons</B></A>]  Theorem
      
      |- !x r q. PL (pcons x r q) = 0 INSERT IMAGE SUC (PL q)
   
   [<A NAME="PL_pmap-val"><B>PL_pmap</B></A>]  Theorem
      
      |- PL (pmap f g p) = PL p
   
   [<A NAME="PL_seg-val"><B>PL_seg</B></A>]  Theorem
      
      |- !i j p.
           i &lt;= j /\ j IN PL p ==&gt; (PL (seg i j p) = {n | n &lt;= j - i})
   
   [<A NAME="PL_stopped_at-val"><B>PL_stopped_at</B></A>]  Theorem
      
      |- !x. PL (stopped_at x) = {0}
   
   [<A NAME="PL_take-val"><B>PL_take</B></A>]  Theorem
      
      |- !p i. i IN PL p ==&gt; (PL (take i p) = {n | n &lt;= i})
   
   [<A NAME="PL_thm-val"><B>PL_thm</B></A>]  Theorem
      
      |- (!x. PL (stopped_at x) = {0}) /\
         !x r q. PL (pcons x r q) = 0 INSERT IMAGE SUC (PL q)
   
   [<A NAME="SN_finite_paths-val"><B>SN_finite_paths</B></A>]  Theorem
      
      |- !R p. SN R /\ okpath R p ==&gt; finite p
   
   [<A NAME="SN_finite_paths_EQ-val"><B>SN_finite_paths_EQ</B></A>]  Theorem
      
      |- !R. SN R &lt;=&gt; !p. okpath R p ==&gt; finite p
   
   [<A NAME="alt_length_thm-val"><B>alt_length_thm</B></A>]  Theorem
      
      |- (!x. length (stopped_at x) = SOME 1) /\
         !x r p. length (pcons x r p) = OPTION_MAP SUC (length p)
   
   [<A NAME="el_drop-val"><B>el_drop</B></A>]  Theorem
      
      |- !i j p. i + j IN PL p ==&gt; (el i (drop j p) = el (i + j) p)
   
   [<A NAME="el_pgenerate-val"><B>el_pgenerate</B></A>]  Theorem
      
      |- !n f g. el n (pgenerate f g) = f n
   
   [<A NAME="el_pmap-val"><B>el_pmap</B></A>]  Theorem
      
      |- !i p. i IN PL p ==&gt; (el i (pmap f g p) = f (el i p))
   
   [<A NAME="every_coinduction-val"><B>every_coinduction</B></A>]  Theorem
      
      |- !P Q.
           (!x. P (stopped_at x) ==&gt; Q x) /\
           (!x r p. P (pcons x r p) ==&gt; Q x /\ P p) ==&gt;
           !p. P p ==&gt; every Q p
   
   [<A NAME="every_el-val"><B>every_el</B></A>]  Theorem
      
      |- !P p. every P p &lt;=&gt; !i. i IN PL p ==&gt; P (el i p)
   
   [<A NAME="every_thm-val"><B>every_thm</B></A>]  Theorem
      
      |- !P.
           (!x. every P (stopped_at x) &lt;=&gt; P x) /\
           !x r p. every P (pcons x r p) &lt;=&gt; P x /\ every P p
   
   [<A NAME="exists_el-val"><B>exists_el</B></A>]  Theorem
      
      |- !P p. exists P p &lt;=&gt; ?i. i IN PL p /\ P (el i p)
   
   [<A NAME="exists_induction-val"><B>exists_induction</B></A>]  Theorem
      
      |- (!x. Q x ==&gt; P (stopped_at x)) /\
         (!x r p. Q x ==&gt; P (pcons x r p)) /\
         (!x r p. P p ==&gt; P (pcons x r p)) ==&gt;
         !p. exists Q p ==&gt; P p
   
   [<A NAME="exists_thm-val"><B>exists_thm</B></A>]  Theorem
      
      |- !P.
           (!x. exists P (stopped_at x) &lt;=&gt; P x) /\
           !x r p. exists P (pcons x r p) &lt;=&gt; P x \/ exists P p
   
   [<A NAME="filter_every-val"><B>filter_every</B></A>]  Theorem
      
      |- !P p. exists P p ==&gt; every P (filter P p)
   
   [<A NAME="finite_drop-val"><B>finite_drop</B></A>]  Theorem
      
      |- !p n. n IN PL p ==&gt; (finite (drop n p) &lt;=&gt; finite p)
   
   [<A NAME="finite_length-val"><B>finite_length</B></A>]  Theorem
      
      |- !p.
           (finite p &lt;=&gt; ?n. length p = SOME n) /\
           (~finite p &lt;=&gt; (length p = NONE))
   
   [<A NAME="finite_okpath_ind-val"><B>finite_okpath_ind</B></A>]  Theorem
      
      |- !R.
           (!x. P (stopped_at x)) /\
           (!x r p.
              okpath R p /\ finite p /\ R x r (first p) /\ P p ==&gt;
              P (pcons x r p)) ==&gt;
           !sigma. okpath R sigma /\ finite sigma ==&gt; P sigma
   
   [<A NAME="finite_path_ind-val"><B>finite_path_ind</B></A>]  Theorem
      
      |- !P.
           (!x. P (stopped_at x)) /\
           (!x r p. finite p /\ P p ==&gt; P (pcons x r p)) ==&gt;
           !q. finite q ==&gt; P q
   
   [<A NAME="finite_paths_SN-val"><B>finite_paths_SN</B></A>]  Theorem
      
      |- !R. (!p. okpath R p ==&gt; finite p) ==&gt; SN R
   
   [<A NAME="finite_pconcat-val"><B>finite_pconcat</B></A>]  Theorem
      
      |- !p1 lab p2. finite (pconcat p1 lab p2) &lt;=&gt; finite p1 /\ finite p2
   
   [<A NAME="finite_plink-val"><B>finite_plink</B></A>]  Theorem
      
      |- !p1 p2. finite (plink p1 p2) &lt;=&gt; finite p1 /\ finite p2
   
   [<A NAME="finite_pmap-val"><B>finite_pmap</B></A>]  Theorem
      
      |- !f g p. finite (pmap f g p) &lt;=&gt; finite p
   
   [<A NAME="finite_seg-val"><B>finite_seg</B></A>]  Theorem
      
      |- !p i j. i &lt;= j /\ j IN PL p ==&gt; finite (seg i j p)
   
   [<A NAME="finite_take-val"><B>finite_take</B></A>]  Theorem
      
      |- !p i. i IN PL p ==&gt; finite (take i p)
   
   [<A NAME="finite_thm-val"><B>finite_thm</B></A>]  Theorem
      
      |- (!x. finite (stopped_at x) &lt;=&gt; T) /\
         !x r p. finite (pcons x r p) &lt;=&gt; finite p
   
   [<A NAME="firstP_at_thm-val"><B>firstP_at_thm</B></A>]  Theorem
      
      |- (!P x n. firstP_at P (stopped_at x) n &lt;=&gt; (n = 0) /\ P x) /\
         !P n x r p.
           firstP_at P (pcons x r p) n &lt;=&gt;
           (n = 0) /\ P x \/ 0 &lt; n /\ ~P x /\ firstP_at P p (n - 1)
   
   [<A NAME="firstP_at_unique-val"><B>firstP_at_unique</B></A>]  Theorem
      
      |- !P p n. firstP_at P p n ==&gt; !m. firstP_at P p m &lt;=&gt; (m = n)
   
   [<A NAME="firstP_at_zero-val"><B>firstP_at_zero</B></A>]  Theorem
      
      |- !P p. firstP_at P p 0 &lt;=&gt; P (first p)
   
   [<A NAME="first_drop-val"><B>first_drop</B></A>]  Theorem
      
      |- !i p. i IN PL p ==&gt; (first (drop i p) = el i p)
   
   [<A NAME="first_label_drop-val"><B>first_label_drop</B></A>]  Theorem
      
      |- !i p. i IN PL p ==&gt; (first_label (drop i p) = nth_label i p)
   
   [<A NAME="first_plink-val"><B>first_plink</B></A>]  Theorem
      
      |- !p1 p2. (last p1 = first p2) ==&gt; (first (plink p1 p2) = first p1)
   
   [<A NAME="first_pmap-val"><B>first_pmap</B></A>]  Theorem
      
      |- !p. first (pmap f g p) = f (first p)
   
   [<A NAME="first_seg-val"><B>first_seg</B></A>]  Theorem
      
      |- !i j p. i &lt;= j /\ j IN PL p ==&gt; (first (seg i j p) = el i p)
   
   [<A NAME="first_take-val"><B>first_take</B></A>]  Theorem
      
      |- !p i. first (take i p) = first p
   
   [<A NAME="first_thm-val"><B>first_thm</B></A>]  Theorem
      
      |- (!x. first (stopped_at x) = x) /\ !x r p. first (pcons x r p) = x
   
   [<A NAME="fromPath_11-val"><B>fromPath_11</B></A>]  Theorem
      
      |- !a a'. (fromPath a = fromPath a') &lt;=&gt; (a = a')
   
   [<A NAME="fromPath_onto-val"><B>fromPath_onto</B></A>]  Theorem
      
      |- !r. ?a. r = fromPath a
   
   [<A NAME="infinite_PL-val"><B>infinite_PL</B></A>]  Theorem
      
      |- !p. ~finite p ==&gt; !i. i IN PL p
   
   [<A NAME="is_stopped_thm-val"><B>is_stopped_thm</B></A>]  Theorem
      
      |- (!x. is_stopped (stopped_at x) &lt;=&gt; T) /\
         !x r p. is_stopped (pcons x r p) &lt;=&gt; F
   
   [<A NAME="last_plink-val"><B>last_plink</B></A>]  Theorem
      
      |- !p1 p2.
           finite p1 /\ finite p2 /\ (last p1 = first p2) ==&gt;
           (last (plink p1 p2) = last p2)
   
   [<A NAME="last_pmap-val"><B>last_pmap</B></A>]  Theorem
      
      |- !p. finite p ==&gt; (last (pmap f g p) = f (last p))
   
   [<A NAME="last_seg-val"><B>last_seg</B></A>]  Theorem
      
      |- !i j p. i &lt;= j /\ j IN PL p ==&gt; (last (seg i j p) = el j p)
   
   [<A NAME="last_take-val"><B>last_take</B></A>]  Theorem
      
      |- !i p. i IN PL p ==&gt; (last (take i p) = el i p)
   
   [<A NAME="length_drop-val"><B>length_drop</B></A>]  Theorem
      
      |- !p n.
           n IN PL p ==&gt;
           (length (drop n p) =
            case length p of NONE -&gt; NONE || SOME m -&gt; SOME (m - n))
   
   [<A NAME="length_never_zero-val"><B>length_never_zero</B></A>]  Theorem
      
      |- !p. length p &lt;&gt; SOME 0
   
   [<A NAME="length_pmap-val"><B>length_pmap</B></A>]  Theorem
      
      |- !f g p. length (pmap f g p) = length p
   
   [<A NAME="length_take-val"><B>length_take</B></A>]  Theorem
      
      |- !p i. i IN PL p ==&gt; (length (take i p) = SOME (i + 1))
   
   [<A NAME="length_thm-val"><B>length_thm</B></A>]  Theorem
      
      |- (!x. length (stopped_at x) = SOME 1) /\
         !x r p.
           length (pcons x r p) =
           if finite p then SOME (THE (length p) + 1) else NONE
   
   [<A NAME="mem_thm-val"><B>mem_thm</B></A>]  Theorem
      
      |- (!x s. mem s (stopped_at x) &lt;=&gt; (s = x)) /\
         !x r p s. mem s (pcons x r p) &lt;=&gt; (s = x) \/ mem s p
   
   [<A NAME="not_every-val"><B>not_every</B></A>]  Theorem
      
      |- !P p. ~every P p &lt;=&gt; exists ($~ o P) p
   
   [<A NAME="not_exists-val"><B>not_exists</B></A>]  Theorem
      
      |- !P p. ~exists P p &lt;=&gt; every ($~ o P) p
   
   [<A NAME="nth_label_drop-val"><B>nth_label_drop</B></A>]  Theorem
      
      |- !i j p.
           SUC (i + j) IN PL p ==&gt;
           (nth_label i (drop j p) = nth_label (i + j) p)
   
   [<A NAME="nth_label_pgenerate-val"><B>nth_label_pgenerate</B></A>]  Theorem
      
      |- !n f g. nth_label n (pgenerate f g) = g n
   
   [<A NAME="nth_label_pmap-val"><B>nth_label_pmap</B></A>]  Theorem
      
      |- !i p.
           SUC i IN PL p ==&gt; (nth_label i (pmap f g p) = g (nth_label i p))
   
   [<A NAME="nth_label_take-val"><B>nth_label_take</B></A>]  Theorem
      
      |- !n p i.
           i &lt; n /\ n IN PL p ==&gt; (nth_label i (take n p) = nth_label i p)
   
   [<A NAME="numeral_drop-val"><B>numeral_drop</B></A>]  Theorem
      
      |- (!n p.
            drop (NUMERAL (BIT1 n)) p =
            drop (NUMERAL (BIT1 n) - 1) (tail p)) /\
         !n p. drop (NUMERAL (BIT2 n)) p = drop (NUMERAL (BIT1 n)) (tail p)
   
   [<A NAME="okpath_cases-val"><B>okpath_cases</B></A>]  Theorem
      
      |- !R x.
           okpath R x &lt;=&gt;
           (?x'. x = stopped_at x') \/
           ?x' r p. (x = pcons x' r p) /\ R x' r (first p) /\ okpath R p
   
   [<A NAME="okpath_co_ind-val"><B>okpath_co_ind</B></A>]  Theorem
      
      |- !P.
           (!x r p. P (pcons x r p) ==&gt; R x r (first p) /\ P p) ==&gt;
           !p. P p ==&gt; okpath R p
   
   [<A NAME="okpath_drop-val"><B>okpath_drop</B></A>]  Theorem
      
      |- !R p i. i IN PL p /\ okpath R p ==&gt; okpath R (drop i p)
   
   [<A NAME="okpath_monotone-val"><B>okpath_monotone</B></A>]  Theorem
      
      |- !R. monotone (okpath_f R)
   
   [<A NAME="okpath_plink-val"><B>okpath_plink</B></A>]  Theorem
      
      |- !R p1 p2.
           finite p1 /\ (last p1 = first p2) ==&gt;
           (okpath R (plink p1 p2) &lt;=&gt; okpath R p1 /\ okpath R p2)
   
   [<A NAME="okpath_pmap-val"><B>okpath_pmap</B></A>]  Theorem
      
      |- !R f g p.
           okpath R p /\ (!x r y. R x r y ==&gt; R (f x) (g r) (f y)) ==&gt;
           okpath R (pmap f g p)
   
   [<A NAME="okpath_seg-val"><B>okpath_seg</B></A>]  Theorem
      
      |- !R p i j.
           i &lt;= j /\ j IN PL p /\ okpath R p ==&gt; okpath R (seg i j p)
   
   [<A NAME="okpath_take-val"><B>okpath_take</B></A>]  Theorem
      
      |- !R p i. i IN PL p /\ okpath R p ==&gt; okpath R (take i p)
   
   [<A NAME="okpath_thm-val"><B>okpath_thm</B></A>]  Theorem
      
      |- !R.
           (!x. okpath R (stopped_at x)) /\
           !x r p. okpath R (pcons x r p) &lt;=&gt; R x r (first p) /\ okpath R p
   
   [<A NAME="path_Axiom-val"><B>path_Axiom</B></A>]  Theorem
      
      |- !f.
           ?g.
             !x.
               g x =
               case f x of
                  (y,NONE) -&gt; stopped_at y
               || (y,SOME (l,v)) -&gt; pcons y l (g v)
   
   [<A NAME="path_bisimulation-val"><B>path_bisimulation</B></A>]  Theorem
      
      |- !p1 p2.
           (p1 = p2) &lt;=&gt;
           ?R.
             R p1 p2 /\
             !q1 q2.
               R q1 q2 ==&gt;
               (?x. (q1 = stopped_at x) /\ (q2 = stopped_at x)) \/
               ?x r q1' q2'.
                 (q1 = pcons x r q1') /\ (q2 = pcons x r q2') /\ R q1' q2'
   
   [<A NAME="path_cases-val"><B>path_cases</B></A>]  Theorem
      
      |- !p. (?x. p = stopped_at x) \/ ?x r q. p = pcons x r q
   
   [<A NAME="path_rep_bijections_thm-val"><B>path_rep_bijections_thm</B></A>]  Theorem
      
      |- (!a. toPath (fromPath a) = a) /\ !r. fromPath (toPath r) = r
   
   [<A NAME="pconcat_eq_pcons-val"><B>pconcat_eq_pcons</B></A>]  Theorem
      
      |- !x r p p1 lab p2.
           ((pconcat p1 lab p2 = pcons x r p) &lt;=&gt;
            (lab = r) /\ (p1 = stopped_at x) /\ (p = p2) \/
            ?p1'. (p1 = pcons x r p1') /\ (p = pconcat p1' lab p2)) /\
           ((pcons x r p = pconcat p1 lab p2) &lt;=&gt;
            (lab = r) /\ (p1 = stopped_at x) /\ (p = p2) \/
            ?p1'. (p1 = pcons x r p1') /\ (p = pconcat p1' lab p2))
   
   [<A NAME="pconcat_eq_stopped-val"><B>pconcat_eq_stopped</B></A>]  Theorem
      
      |- !p1 lab p2 x.
           pconcat p1 lab p2 &lt;&gt; stopped_at x /\
           stopped_at x &lt;&gt; pconcat p1 lab p2
   
   [<A NAME="pconcat_thm-val"><B>pconcat_thm</B></A>]  Theorem
      
      |- (!x lab p2. pconcat (stopped_at x) lab p2 = pcons x lab p2) /\
         !x r p lab p2.
           pconcat (pcons x r p) lab p2 = pcons x r (pconcat p lab p2)
   
   [<A NAME="pcons_11-val"><B>pcons_11</B></A>]  Theorem
      
      |- !x r p y s q.
           (pcons x r p = pcons y s q) &lt;=&gt; (x = y) /\ (r = s) /\ (p = q)
   
   [<A NAME="pgenerate_11-val"><B>pgenerate_11</B></A>]  Theorem
      
      |- !f1 g1 f2 g2.
           (pgenerate f1 g1 = pgenerate f2 g2) &lt;=&gt; (f1 = f2) /\ (g1 = g2)
   
   [<A NAME="pgenerate_infinite-val"><B>pgenerate_infinite</B></A>]  Theorem
      
      |- !f g. ~finite (pgenerate f g)
   
   [<A NAME="pgenerate_not_stopped-val"><B>pgenerate_not_stopped</B></A>]  Theorem
      
      |- !f g x. stopped_at x &lt;&gt; pgenerate f g
   
   [<A NAME="pgenerate_onto-val"><B>pgenerate_onto</B></A>]  Theorem
      
      |- !p. ~finite p ==&gt; ?f g. p = pgenerate f g
   
   [<A NAME="pmap_thm-val"><B>pmap_thm</B></A>]  Theorem
      
      |- (!x. pmap f g (stopped_at x) = stopped_at (f x)) /\
         !x r p. pmap f g (pcons x r p) = pcons (f x) (g r) (pmap f g p)
   
   [<A NAME="recursive_seg-val"><B>recursive_seg</B></A>]  Theorem
      
      |- !i j p.
           i &lt; j /\ j IN PL p ==&gt;
           (seg i j p = pcons (el i p) (nth_label i p) (seg (i + 1) j p))
   
   [<A NAME="singleton_seg-val"><B>singleton_seg</B></A>]  Theorem
      
      |- !i p. i IN PL p ==&gt; (seg i i p = stopped_at (el i p))
   
   [<A NAME="stopped_at_11-val"><B>stopped_at_11</B></A>]  Theorem
      
      |- !x y. (stopped_at x = stopped_at y) &lt;=&gt; (x = y)
   
   [<A NAME="stopped_at_not_pcons-val"><B>stopped_at_not_pcons</B></A>]  Theorem
      
      |- !x y r p.
           stopped_at x &lt;&gt; pcons y r p /\ pcons y r p &lt;&gt; stopped_at x
   
   [<A NAME="tail_drop-val"><B>tail_drop</B></A>]  Theorem
      
      |- !i p. i + 1 IN PL p ==&gt; (tail (drop i p) = drop (i + 1) p)
   
   [<A NAME="toPath_11-val"><B>toPath_11</B></A>]  Theorem
      
      |- !r r'. (toPath r = toPath r') &lt;=&gt; (r = r')
   
   [<A NAME="toPath_onto-val"><B>toPath_onto</B></A>]  Theorem
      
      |- !a. ?r. a = toPath r
   
   
*)
end

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/path/pathScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
