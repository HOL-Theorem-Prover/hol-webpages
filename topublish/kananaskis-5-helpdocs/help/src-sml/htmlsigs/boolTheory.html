<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure boolTheory</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure boolTheory</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/bool/boolScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>signature boolTheory =
<A NAME="line2"></A>sig
<A NAME="line3"></A>  type thm = Thm.thm
<A NAME="line4"></A>  
<A NAME="line5"></A>  (*  Axioms  *)
<A NAME="line6"></A>    val <A HREF="#BOOL_CASES_AX-val">BOOL_CASES_AX</A> : thm
<A NAME="line7"></A>    val <A HREF="#ETA_AX-val">ETA_AX</A> : thm
<A NAME="line8"></A>    val <A HREF="#INFINITY_AX-val">INFINITY_AX</A> : thm
<A NAME="line9"></A>    val <A HREF="#SELECT_AX-val">SELECT_AX</A> : thm
<A NAME="line10"></A>  
<A NAME="line11"></A>  (*  Definitions  *)
<A NAME="line12"></A>    val <A HREF="#AND_DEF-val">AND_DEF</A> : thm
<A NAME="line13"></A>    val <A HREF="#BOUNDED_DEF-val">BOUNDED_DEF</A> : thm
<A NAME="line14"></A>    val <A HREF="#COND_DEF-val">COND_DEF</A> : thm
<A NAME="line15"></A>    val <A HREF="#DATATYPE_TAG_DEF-val">DATATYPE_TAG_DEF</A> : thm
<A NAME="line16"></A>    val <A HREF="#EXISTS_DEF-val">EXISTS_DEF</A> : thm
<A NAME="line17"></A>    val <A HREF="#EXISTS_UNIQUE_DEF-val">EXISTS_UNIQUE_DEF</A> : thm
<A NAME="line18"></A>    val <A HREF="#FORALL_DEF-val">FORALL_DEF</A> : thm
<A NAME="line19"></A>    val <A HREF="#F_DEF-val">F_DEF</A> : thm
<A NAME="line20"></A>    val <A HREF="#IN_DEF-val">IN_DEF</A> : thm
<A NAME="line21"></A>    val <A HREF="#LET_DEF-val">LET_DEF</A> : thm
<A NAME="line22"></A>    val <A HREF="#NOT_DEF-val">NOT_DEF</A> : thm
<A NAME="line23"></A>    val <A HREF="#ONE_ONE_DEF-val">ONE_ONE_DEF</A> : thm
<A NAME="line24"></A>    val <A HREF="#ONTO_DEF-val">ONTO_DEF</A> : thm
<A NAME="line25"></A>    val <A HREF="#OR_DEF-val">OR_DEF</A> : thm
<A NAME="line26"></A>    val <A HREF="#RES_ABSTRACT_DEF-val">RES_ABSTRACT_DEF</A> : thm
<A NAME="line27"></A>    val <A HREF="#RES_EXISTS_DEF-val">RES_EXISTS_DEF</A> : thm
<A NAME="line28"></A>    val <A HREF="#RES_EXISTS_UNIQUE_DEF-val">RES_EXISTS_UNIQUE_DEF</A> : thm
<A NAME="line29"></A>    val <A HREF="#RES_FORALL_DEF-val">RES_FORALL_DEF</A> : thm
<A NAME="line30"></A>    val <A HREF="#RES_SELECT_DEF-val">RES_SELECT_DEF</A> : thm
<A NAME="line31"></A>    val <A HREF="#TYPE_DEFINITION-val">TYPE_DEFINITION</A> : thm
<A NAME="line32"></A>    val <A HREF="#T_DEF-val">T_DEF</A> : thm
<A NAME="line33"></A>    val <A HREF="#bool_case_DEF-val">bool_case_DEF</A> : thm
<A NAME="line34"></A>    val <A HREF="#itself_TY_DEF-val">itself_TY_DEF</A> : thm
<A NAME="line35"></A>    val <A HREF="#itself_case_thm-val">itself_case_thm</A> : thm
<A NAME="line36"></A>    val <A HREF="#literal_case_DEF-val">literal_case_DEF</A> : thm
<A NAME="line37"></A>  
<A NAME="line38"></A>  (*  Theorems  *)
<A NAME="line39"></A>    val <A HREF="#ABS_REP_THM-val">ABS_REP_THM</A> : thm
<A NAME="line40"></A>    val <A HREF="#ABS_SIMP-val">ABS_SIMP</A> : thm
<A NAME="line41"></A>    val <A HREF="#AND1_THM-val">AND1_THM</A> : thm
<A NAME="line42"></A>    val <A HREF="#AND2_THM-val">AND2_THM</A> : thm
<A NAME="line43"></A>    val <A HREF="#AND_CLAUSES-val">AND_CLAUSES</A> : thm
<A NAME="line44"></A>    val <A HREF="#AND_CONG-val">AND_CONG</A> : thm
<A NAME="line45"></A>    val <A HREF="#AND_IMP_INTRO-val">AND_IMP_INTRO</A> : thm
<A NAME="line46"></A>    val <A HREF="#AND_INTRO_THM-val">AND_INTRO_THM</A> : thm
<A NAME="line47"></A>    val <A HREF="#BETA_THM-val">BETA_THM</A> : thm
<A NAME="line48"></A>    val <A HREF="#BOOL_EQ_DISTINCT-val">BOOL_EQ_DISTINCT</A> : thm
<A NAME="line49"></A>    val <A HREF="#BOOL_FUN_CASES_THM-val">BOOL_FUN_CASES_THM</A> : thm
<A NAME="line50"></A>    val <A HREF="#BOOL_FUN_INDUCT-val">BOOL_FUN_INDUCT</A> : thm
<A NAME="line51"></A>    val <A HREF="#BOTH_EXISTS_AND_THM-val">BOTH_EXISTS_AND_THM</A> : thm
<A NAME="line52"></A>    val <A HREF="#BOTH_EXISTS_IMP_THM-val">BOTH_EXISTS_IMP_THM</A> : thm
<A NAME="line53"></A>    val <A HREF="#BOTH_FORALL_IMP_THM-val">BOTH_FORALL_IMP_THM</A> : thm
<A NAME="line54"></A>    val <A HREF="#BOTH_FORALL_OR_THM-val">BOTH_FORALL_OR_THM</A> : thm
<A NAME="line55"></A>    val <A HREF="#BOUNDED_THM-val">BOUNDED_THM</A> : thm
<A NAME="line56"></A>    val <A HREF="#COND_ABS-val">COND_ABS</A> : thm
<A NAME="line57"></A>    val <A HREF="#COND_CLAUSES-val">COND_CLAUSES</A> : thm
<A NAME="line58"></A>    val <A HREF="#COND_CONG-val">COND_CONG</A> : thm
<A NAME="line59"></A>    val <A HREF="#COND_EXPAND-val">COND_EXPAND</A> : thm
<A NAME="line60"></A>    val <A HREF="#COND_EXPAND_IMP-val">COND_EXPAND_IMP</A> : thm
<A NAME="line61"></A>    val <A HREF="#COND_EXPAND_OR-val">COND_EXPAND_OR</A> : thm
<A NAME="line62"></A>    val <A HREF="#COND_ID-val">COND_ID</A> : thm
<A NAME="line63"></A>    val <A HREF="#COND_RAND-val">COND_RAND</A> : thm
<A NAME="line64"></A>    val <A HREF="#COND_RATOR-val">COND_RATOR</A> : thm
<A NAME="line65"></A>    val <A HREF="#CONJ_ASSOC-val">CONJ_ASSOC</A> : thm
<A NAME="line66"></A>    val <A HREF="#CONJ_COMM-val">CONJ_COMM</A> : thm
<A NAME="line67"></A>    val <A HREF="#CONJ_SYM-val">CONJ_SYM</A> : thm
<A NAME="line68"></A>    val <A HREF="#DATATYPE_BOOL-val">DATATYPE_BOOL</A> : thm
<A NAME="line69"></A>    val <A HREF="#DATATYPE_TAG_THM-val">DATATYPE_TAG_THM</A> : thm
<A NAME="line70"></A>    val <A HREF="#DE_MORGAN_THM-val">DE_MORGAN_THM</A> : thm
<A NAME="line71"></A>    val <A HREF="#DISJ_ASSOC-val">DISJ_ASSOC</A> : thm
<A NAME="line72"></A>    val <A HREF="#DISJ_COMM-val">DISJ_COMM</A> : thm
<A NAME="line73"></A>    val <A HREF="#DISJ_IMP_THM-val">DISJ_IMP_THM</A> : thm
<A NAME="line74"></A>    val <A HREF="#DISJ_SYM-val">DISJ_SYM</A> : thm
<A NAME="line75"></A>    val <A HREF="#EQ_CLAUSES-val">EQ_CLAUSES</A> : thm
<A NAME="line76"></A>    val <A HREF="#EQ_EXPAND-val">EQ_EXPAND</A> : thm
<A NAME="line77"></A>    val <A HREF="#EQ_EXT-val">EQ_EXT</A> : thm
<A NAME="line78"></A>    val <A HREF="#EQ_IMP_THM-val">EQ_IMP_THM</A> : thm
<A NAME="line79"></A>    val <A HREF="#EQ_REFL-val">EQ_REFL</A> : thm
<A NAME="line80"></A>    val <A HREF="#EQ_SYM-val">EQ_SYM</A> : thm
<A NAME="line81"></A>    val <A HREF="#EQ_SYM_EQ-val">EQ_SYM_EQ</A> : thm
<A NAME="line82"></A>    val <A HREF="#EQ_TRANS-val">EQ_TRANS</A> : thm
<A NAME="line83"></A>    val <A HREF="#ETA_THM-val">ETA_THM</A> : thm
<A NAME="line84"></A>    val <A HREF="#EXCLUDED_MIDDLE-val">EXCLUDED_MIDDLE</A> : thm
<A NAME="line85"></A>    val <A HREF="#EXISTS_OR_THM-val">EXISTS_OR_THM</A> : thm
<A NAME="line86"></A>    val <A HREF="#EXISTS_REFL-val">EXISTS_REFL</A> : thm
<A NAME="line87"></A>    val <A HREF="#EXISTS_SIMP-val">EXISTS_SIMP</A> : thm
<A NAME="line88"></A>    val <A HREF="#EXISTS_THM-val">EXISTS_THM</A> : thm
<A NAME="line89"></A>    val <A HREF="#EXISTS_UNIQUE_REFL-val">EXISTS_UNIQUE_REFL</A> : thm
<A NAME="line90"></A>    val <A HREF="#EXISTS_UNIQUE_THM-val">EXISTS_UNIQUE_THM</A> : thm
<A NAME="line91"></A>    val <A HREF="#FALSITY-val">FALSITY</A> : thm
<A NAME="line92"></A>    val <A HREF="#FORALL_AND_THM-val">FORALL_AND_THM</A> : thm
<A NAME="line93"></A>    val <A HREF="#FORALL_BOOL-val">FORALL_BOOL</A> : thm
<A NAME="line94"></A>    val <A HREF="#FORALL_SIMP-val">FORALL_SIMP</A> : thm
<A NAME="line95"></A>    val <A HREF="#FORALL_THM-val">FORALL_THM</A> : thm
<A NAME="line96"></A>    val <A HREF="#FUN_EQ_THM-val">FUN_EQ_THM</A> : thm
<A NAME="line97"></A>    val <A HREF="#F_IMP-val">F_IMP</A> : thm
<A NAME="line98"></A>    val <A HREF="#IMP_ANTISYM_AX-val">IMP_ANTISYM_AX</A> : thm
<A NAME="line99"></A>    val <A HREF="#IMP_CLAUSES-val">IMP_CLAUSES</A> : thm
<A NAME="line100"></A>    val <A HREF="#IMP_CONG-val">IMP_CONG</A> : thm
<A NAME="line101"></A>    val <A HREF="#IMP_CONJ_THM-val">IMP_CONJ_THM</A> : thm
<A NAME="line102"></A>    val <A HREF="#IMP_DISJ_THM-val">IMP_DISJ_THM</A> : thm
<A NAME="line103"></A>    val <A HREF="#IMP_F-val">IMP_F</A> : thm
<A NAME="line104"></A>    val <A HREF="#IMP_F_EQ_F-val">IMP_F_EQ_F</A> : thm
<A NAME="line105"></A>    val <A HREF="#ITSELF_UNIQUE-val">ITSELF_UNIQUE</A> : thm
<A NAME="line106"></A>    val <A HREF="#JRH_INDUCT_UTIL-val">JRH_INDUCT_UTIL</A> : thm
<A NAME="line107"></A>    val <A HREF="#LCOMM_THM-val">LCOMM_THM</A> : thm
<A NAME="line108"></A>    val <A HREF="#LEFT_AND_CONG-val">LEFT_AND_CONG</A> : thm
<A NAME="line109"></A>    val <A HREF="#LEFT_AND_FORALL_THM-val">LEFT_AND_FORALL_THM</A> : thm
<A NAME="line110"></A>    val <A HREF="#LEFT_AND_OVER_OR-val">LEFT_AND_OVER_OR</A> : thm
<A NAME="line111"></A>    val <A HREF="#LEFT_EXISTS_AND_THM-val">LEFT_EXISTS_AND_THM</A> : thm
<A NAME="line112"></A>    val <A HREF="#LEFT_EXISTS_IMP_THM-val">LEFT_EXISTS_IMP_THM</A> : thm
<A NAME="line113"></A>    val <A HREF="#LEFT_FORALL_IMP_THM-val">LEFT_FORALL_IMP_THM</A> : thm
<A NAME="line114"></A>    val <A HREF="#LEFT_FORALL_OR_THM-val">LEFT_FORALL_OR_THM</A> : thm
<A NAME="line115"></A>    val <A HREF="#LEFT_OR_CONG-val">LEFT_OR_CONG</A> : thm
<A NAME="line116"></A>    val <A HREF="#LEFT_OR_EXISTS_THM-val">LEFT_OR_EXISTS_THM</A> : thm
<A NAME="line117"></A>    val <A HREF="#LEFT_OR_OVER_AND-val">LEFT_OR_OVER_AND</A> : thm
<A NAME="line118"></A>    val <A HREF="#LET_CONG-val">LET_CONG</A> : thm
<A NAME="line119"></A>    val <A HREF="#LET_RAND-val">LET_RAND</A> : thm
<A NAME="line120"></A>    val <A HREF="#LET_RATOR-val">LET_RATOR</A> : thm
<A NAME="line121"></A>    val <A HREF="#LET_THM-val">LET_THM</A> : thm
<A NAME="line122"></A>    val <A HREF="#MONO_ALL-val">MONO_ALL</A> : thm
<A NAME="line123"></A>    val <A HREF="#MONO_AND-val">MONO_AND</A> : thm
<A NAME="line124"></A>    val <A HREF="#MONO_COND-val">MONO_COND</A> : thm
<A NAME="line125"></A>    val <A HREF="#MONO_EXISTS-val">MONO_EXISTS</A> : thm
<A NAME="line126"></A>    val <A HREF="#MONO_IMP-val">MONO_IMP</A> : thm
<A NAME="line127"></A>    val <A HREF="#MONO_NOT-val">MONO_NOT</A> : thm
<A NAME="line128"></A>    val <A HREF="#MONO_NOT_EQ-val">MONO_NOT_EQ</A> : thm
<A NAME="line129"></A>    val <A HREF="#MONO_OR-val">MONO_OR</A> : thm
<A NAME="line130"></A>    val <A HREF="#NOT_AND-val">NOT_AND</A> : thm
<A NAME="line131"></A>    val <A HREF="#NOT_CLAUSES-val">NOT_CLAUSES</A> : thm
<A NAME="line132"></A>    val <A HREF="#NOT_EXISTS_THM-val">NOT_EXISTS_THM</A> : thm
<A NAME="line133"></A>    val <A HREF="#NOT_F-val">NOT_F</A> : thm
<A NAME="line134"></A>    val <A HREF="#NOT_FORALL_THM-val">NOT_FORALL_THM</A> : thm
<A NAME="line135"></A>    val <A HREF="#NOT_IMP-val">NOT_IMP</A> : thm
<A NAME="line136"></A>    val <A HREF="#ONE_ONE_THM-val">ONE_ONE_THM</A> : thm
<A NAME="line137"></A>    val <A HREF="#ONTO_THM-val">ONTO_THM</A> : thm
<A NAME="line138"></A>    val <A HREF="#OR_CLAUSES-val">OR_CLAUSES</A> : thm
<A NAME="line139"></A>    val <A HREF="#OR_CONG-val">OR_CONG</A> : thm
<A NAME="line140"></A>    val <A HREF="#OR_ELIM_THM-val">OR_ELIM_THM</A> : thm
<A NAME="line141"></A>    val <A HREF="#OR_IMP_THM-val">OR_IMP_THM</A> : thm
<A NAME="line142"></A>    val <A HREF="#OR_INTRO_THM1-val">OR_INTRO_THM1</A> : thm
<A NAME="line143"></A>    val <A HREF="#OR_INTRO_THM2-val">OR_INTRO_THM2</A> : thm
<A NAME="line144"></A>    val <A HREF="#PEIRCE-val">PEIRCE</A> : thm
<A NAME="line145"></A>    val <A HREF="#REFL_CLAUSE-val">REFL_CLAUSE</A> : thm
<A NAME="line146"></A>    val <A HREF="#RES_EXISTS_CONG-val">RES_EXISTS_CONG</A> : thm
<A NAME="line147"></A>    val <A HREF="#RES_EXISTS_FALSE-val">RES_EXISTS_FALSE</A> : thm
<A NAME="line148"></A>    val <A HREF="#RES_EXISTS_THM-val">RES_EXISTS_THM</A> : thm
<A NAME="line149"></A>    val <A HREF="#RES_EXISTS_UNIQUE_THM-val">RES_EXISTS_UNIQUE_THM</A> : thm
<A NAME="line150"></A>    val <A HREF="#RES_FORALL_CONG-val">RES_FORALL_CONG</A> : thm
<A NAME="line151"></A>    val <A HREF="#RES_FORALL_THM-val">RES_FORALL_THM</A> : thm
<A NAME="line152"></A>    val <A HREF="#RES_FORALL_TRUE-val">RES_FORALL_TRUE</A> : thm
<A NAME="line153"></A>    val <A HREF="#RES_SELECT_THM-val">RES_SELECT_THM</A> : thm
<A NAME="line154"></A>    val <A HREF="#RIGHT_AND_FORALL_THM-val">RIGHT_AND_FORALL_THM</A> : thm
<A NAME="line155"></A>    val <A HREF="#RIGHT_AND_OVER_OR-val">RIGHT_AND_OVER_OR</A> : thm
<A NAME="line156"></A>    val <A HREF="#RIGHT_EXISTS_AND_THM-val">RIGHT_EXISTS_AND_THM</A> : thm
<A NAME="line157"></A>    val <A HREF="#RIGHT_EXISTS_IMP_THM-val">RIGHT_EXISTS_IMP_THM</A> : thm
<A NAME="line158"></A>    val <A HREF="#RIGHT_FORALL_IMP_THM-val">RIGHT_FORALL_IMP_THM</A> : thm
<A NAME="line159"></A>    val <A HREF="#RIGHT_FORALL_OR_THM-val">RIGHT_FORALL_OR_THM</A> : thm
<A NAME="line160"></A>    val <A HREF="#RIGHT_OR_EXISTS_THM-val">RIGHT_OR_EXISTS_THM</A> : thm
<A NAME="line161"></A>    val <A HREF="#RIGHT_OR_OVER_AND-val">RIGHT_OR_OVER_AND</A> : thm
<A NAME="line162"></A>    val <A HREF="#SELECT_ELIM_THM-val">SELECT_ELIM_THM</A> : thm
<A NAME="line163"></A>    val <A HREF="#SELECT_REFL-val">SELECT_REFL</A> : thm
<A NAME="line164"></A>    val <A HREF="#SELECT_REFL_2-val">SELECT_REFL_2</A> : thm
<A NAME="line165"></A>    val <A HREF="#SELECT_THM-val">SELECT_THM</A> : thm
<A NAME="line166"></A>    val <A HREF="#SELECT_UNIQUE-val">SELECT_UNIQUE</A> : thm
<A NAME="line167"></A>    val <A HREF="#SKOLEM_THM-val">SKOLEM_THM</A> : thm
<A NAME="line168"></A>    val <A HREF="#SWAP_EXISTS_THM-val">SWAP_EXISTS_THM</A> : thm
<A NAME="line169"></A>    val <A HREF="#SWAP_FORALL_THM-val">SWAP_FORALL_THM</A> : thm
<A NAME="line170"></A>    val <A HREF="#TRUTH-val">TRUTH</A> : thm
<A NAME="line171"></A>    val <A HREF="#TYPE_DEFINITION_THM-val">TYPE_DEFINITION_THM</A> : thm
<A NAME="line172"></A>    val <A HREF="#UEXISTS_OR_THM-val">UEXISTS_OR_THM</A> : thm
<A NAME="line173"></A>    val <A HREF="#UEXISTS_SIMP-val">UEXISTS_SIMP</A> : thm
<A NAME="line174"></A>    val <A HREF="#UNWIND_FORALL_THM1-val">UNWIND_FORALL_THM1</A> : thm
<A NAME="line175"></A>    val <A HREF="#UNWIND_FORALL_THM2-val">UNWIND_FORALL_THM2</A> : thm
<A NAME="line176"></A>    val <A HREF="#UNWIND_THM1-val">UNWIND_THM1</A> : thm
<A NAME="line177"></A>    val <A HREF="#UNWIND_THM2-val">UNWIND_THM2</A> : thm
<A NAME="line178"></A>    val <A HREF="#boolAxiom-val">boolAxiom</A> : thm
<A NAME="line179"></A>    val <A HREF="#bool_INDUCT-val">bool_INDUCT</A> : thm
<A NAME="line180"></A>    val <A HREF="#bool_case_CONG-val">bool_case_CONG</A> : thm
<A NAME="line181"></A>    val <A HREF="#bool_case_EQ_COND-val">bool_case_EQ_COND</A> : thm
<A NAME="line182"></A>    val <A HREF="#bool_case_ID-val">bool_case_ID</A> : thm
<A NAME="line183"></A>    val <A HREF="#bool_case_thm-val">bool_case_thm</A> : thm
<A NAME="line184"></A>    val <A HREF="#itself_Axiom-val">itself_Axiom</A> : thm
<A NAME="line185"></A>    val <A HREF="#itself_induction-val">itself_induction</A> : thm
<A NAME="line186"></A>    val <A HREF="#literal_case_CONG-val">literal_case_CONG</A> : thm
<A NAME="line187"></A>    val <A HREF="#literal_case_RAND-val">literal_case_RAND</A> : thm
<A NAME="line188"></A>    val <A HREF="#literal_case_RATOR-val">literal_case_RATOR</A> : thm
<A NAME="line189"></A>    val <A HREF="#literal_case_THM-val">literal_case_THM</A> : thm
<A NAME="line190"></A>    val <A HREF="#literal_case_id-val">literal_case_id</A> : thm
<A NAME="line191"></A>  
<A NAME="line192"></A>  val bool_grammars : type_grammar.grammar * term_grammar.grammar
<A NAME="line193"></A>(*
   [min] Parent theory of "bool"
   
   [<A NAME="BOOL_CASES_AX-val"><B>BOOL_CASES_AX</B></A>]  Axiom
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- !t. (t = T) \/ (t = F)
   
   [<A NAME="ETA_AX-val"><B>ETA_AX</B></A>]  Axiom
      
      [oracles: ] [axioms: ETA_AX] [] |- !t. (\x. t x) = t
   
   [<A NAME="INFINITY_AX-val"><B>INFINITY_AX</B></A>]  Axiom
      
      [oracles: ] [axioms: INFINITY_AX] [] |- ?f. ONE_ONE f /\ ~ONTO f
   
   [<A NAME="SELECT_AX-val"><B>SELECT_AX</B></A>]  Axiom
      
      [oracles: ] [axioms: SELECT_AX] [] |- !P x. P x ==&gt; P ($@ P)
   
   [<A NAME="AND_DEF-val"><B>AND_DEF</B></A>]  Definition
      
      |- $/\ = (\t1 t2. !t. (t1 ==&gt; t2 ==&gt; t) ==&gt; t)
   
   [<A NAME="BOUNDED_DEF-val"><B>BOUNDED_DEF</B></A>]  Definition
      
      |- BOUNDED = (\v. T)
   
   [<A NAME="COND_DEF-val"><B>COND_DEF</B></A>]  Definition
      
      |- COND =
         (\t t1 t2. @x. ((t = T) ==&gt; (x = t1)) /\ ((t = F) ==&gt; (x = t2)))
   
   [<A NAME="DATATYPE_TAG_DEF-val"><B>DATATYPE_TAG_DEF</B></A>]  Definition
      
      |- DATATYPE = (\x. T)
   
   [<A NAME="EXISTS_DEF-val"><B>EXISTS_DEF</B></A>]  Definition
      
      |- $? = (\P. P ($@ P))
   
   [<A NAME="EXISTS_UNIQUE_DEF-val"><B>EXISTS_UNIQUE_DEF</B></A>]  Definition
      
      |- $?! = (\P. $? P /\ !x y. P x /\ P y ==&gt; (x = y))
   
   [<A NAME="FORALL_DEF-val"><B>FORALL_DEF</B></A>]  Definition
      
      |- $! = (\P. P = (\x. T))
   
   [<A NAME="F_DEF-val"><B>F_DEF</B></A>]  Definition
      
      |- F = !t. t
   
   [<A NAME="IN_DEF-val"><B>IN_DEF</B></A>]  Definition
      
      |- $IN = (\x f. f x)
   
   [<A NAME="LET_DEF-val"><B>LET_DEF</B></A>]  Definition
      
      |- LET = (\f x. f x)
   
   [<A NAME="NOT_DEF-val"><B>NOT_DEF</B></A>]  Definition
      
      |- $~ = (\t. t ==&gt; F)
   
   [<A NAME="ONE_ONE_DEF-val"><B>ONE_ONE_DEF</B></A>]  Definition
      
      |- ONE_ONE = (\f. !x1 x2. (f x1 = f x2) ==&gt; (x1 = x2))
   
   [<A NAME="ONTO_DEF-val"><B>ONTO_DEF</B></A>]  Definition
      
      |- ONTO = (\f. !y. ?x. y = f x)
   
   [<A NAME="OR_DEF-val"><B>OR_DEF</B></A>]  Definition
      
      |- $\/ = (\t1 t2. !t. (t1 ==&gt; t) ==&gt; (t2 ==&gt; t) ==&gt; t)
   
   [<A NAME="RES_ABSTRACT_DEF-val"><B>RES_ABSTRACT_DEF</B></A>]  Definition
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] []
      |- (!p m x. x IN p ==&gt; (RES_ABSTRACT p m x = m x)) /\
         !p m1 m2.
           (!x. x IN p ==&gt; (m1 x = m2 x)) ==&gt;
           (RES_ABSTRACT p m1 = RES_ABSTRACT p m2)
   
   [<A NAME="RES_EXISTS_DEF-val"><B>RES_EXISTS_DEF</B></A>]  Definition
      
      |- RES_EXISTS = (\p m. ?x. x IN p /\ m x)
   
   [<A NAME="RES_EXISTS_UNIQUE_DEF-val"><B>RES_EXISTS_UNIQUE_DEF</B></A>]  Definition
      
      |- RES_EXISTS_UNIQUE =
         (\p m. (?x::p. m x) /\ !x y::p. m x /\ m y ==&gt; (x = y))
   
   [<A NAME="RES_FORALL_DEF-val"><B>RES_FORALL_DEF</B></A>]  Definition
      
      |- RES_FORALL = (\p m. !x. x IN p ==&gt; m x)
   
   [<A NAME="RES_SELECT_DEF-val"><B>RES_SELECT_DEF</B></A>]  Definition
      
      |- RES_SELECT = (\p m. @x. x IN p /\ m x)
   
   [<A NAME="TYPE_DEFINITION-val"><B>TYPE_DEFINITION</B></A>]  Definition
      
      |- TYPE_DEFINITION =
         (\P rep.
            (!x' x''. (rep x' = rep x'') ==&gt; (x' = x'')) /\
            !x. P x = ?x'. x = rep x')
   
   [<A NAME="T_DEF-val"><B>T_DEF</B></A>]  Definition
      
      |- T = ((\x. x) = (\x. x))
   
   [<A NAME="bool_case_DEF-val"><B>bool_case_DEF</B></A>]  Definition
      
      |- bool_case = (\x y b. if b then x else y)
   
   [<A NAME="itself_TY_DEF-val"><B>itself_TY_DEF</B></A>]  Definition
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- ?rep. TYPE_DEFINITION ($= ARB) rep
   
   [<A NAME="itself_case_thm-val"><B>itself_case_thm</B></A>]  Definition
      
      |- !b. itself_case b (:'a) = b
   
   [<A NAME="literal_case_DEF-val"><B>literal_case_DEF</B></A>]  Definition
      
      |- literal_case = (\f x. f x)
   
   [<A NAME="ABS_REP_THM-val"><B>ABS_REP_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] []
      |- !P.
           (?rep. TYPE_DEFINITION P rep) ==&gt;
           ?rep abs. (!a. abs (rep a) = a) /\ !r. P r = (rep (abs r) = r)
   
   [<A NAME="ABS_SIMP-val"><B>ABS_SIMP</B></A>]  Theorem
      
      |- !t1 t2. (\x. t1) t2 = t1
   
   [<A NAME="AND1_THM-val"><B>AND1_THM</B></A>]  Theorem
      
      |- !t1 t2. t1 /\ t2 ==&gt; t1
   
   [<A NAME="AND2_THM-val"><B>AND2_THM</B></A>]  Theorem
      
      |- !t1 t2. t1 /\ t2 ==&gt; t2
   
   [<A NAME="AND_CLAUSES-val"><B>AND_CLAUSES</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !t.
           (T /\ t = t) /\ (t /\ T = t) /\ (F /\ t = F) /\ (t /\ F = F) /\
           (t /\ t = t)
   
   [<A NAME="AND_CONG-val"><B>AND_CONG</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P P' Q Q'.
           (Q ==&gt; (P = P')) /\ (P' ==&gt; (Q = Q')) ==&gt; (P /\ Q = P' /\ Q')
   
   [<A NAME="AND_IMP_INTRO-val"><B>AND_IMP_INTRO</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !t1 t2 t3. t1 ==&gt; t2 ==&gt; t3 = t1 /\ t2 ==&gt; t3
   
   [<A NAME="AND_INTRO_THM-val"><B>AND_INTRO_THM</B></A>]  Theorem
      
      |- !t1 t2. t1 ==&gt; t2 ==&gt; t1 /\ t2
   
   [<A NAME="BETA_THM-val"><B>BETA_THM</B></A>]  Theorem
      
      |- !f y. (\x. f x) y = f y
   
   [<A NAME="BOOL_EQ_DISTINCT-val"><B>BOOL_EQ_DISTINCT</B></A>]  Theorem
      
      |- ~(T = F) /\ ~(F = T)
   
   [<A NAME="BOOL_FUN_CASES_THM-val"><B>BOOL_FUN_CASES_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !f.
           (f = (\b. T)) \/ (f = (\b. F)) \/ (f = (\b. b)) \/
           (f = (\b. ~b))
   
   [<A NAME="BOOL_FUN_INDUCT-val"><B>BOOL_FUN_INDUCT</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P. P (\b. T) /\ P (\b. F) /\ P (\b. b) /\ P (\b. ~b) ==&gt; !f. P f
   
   [<A NAME="BOTH_EXISTS_AND_THM-val"><B>BOTH_EXISTS_AND_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P Q. (?x. P /\ Q) = (?x. P) /\ ?x. Q
   
   [<A NAME="BOTH_EXISTS_IMP_THM-val"><B>BOTH_EXISTS_IMP_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P Q. (?x. P ==&gt; Q) = (!x. P) ==&gt; ?x. Q
   
   [<A NAME="BOTH_FORALL_IMP_THM-val"><B>BOTH_FORALL_IMP_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P Q. (!x. P ==&gt; Q) = (?x. P) ==&gt; !x. Q
   
   [<A NAME="BOTH_FORALL_OR_THM-val"><B>BOTH_FORALL_OR_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P Q. (!x. P \/ Q) = (!x. P) \/ !x. Q
   
   [<A NAME="BOUNDED_THM-val"><B>BOUNDED_THM</B></A>]  Theorem
      
      |- !v. BOUNDED v = T
   
   [<A NAME="COND_ABS-val"><B>COND_ABS</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] []
      |- !b f g. (\x. if b then f x else g x) = if b then f else g
   
   [<A NAME="COND_CLAUSES-val"><B>COND_CLAUSES</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] []
      |- !t1 t2.
           ((if T then t1 else t2) = t1) /\ ((if F then t1 else t2) = t2)
   
   [<A NAME="COND_CONG-val"><B>COND_CONG</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] []
      |- !P Q x x' y y'.
           (P = Q) /\ (Q ==&gt; (x = x')) /\ (~Q ==&gt; (y = y')) ==&gt;
           ((if P then x else y) = if Q then x' else y')
   
   [<A NAME="COND_EXPAND-val"><B>COND_EXPAND</B></A>]  Theorem
      
      [oracles: ] [axioms: SELECT_AX, BOOL_CASES_AX] []
      |- !b t1 t2. (if b then t1 else t2) = (~b \/ t1) /\ (b \/ t2)
   
   [<A NAME="COND_EXPAND_IMP-val"><B>COND_EXPAND_IMP</B></A>]  Theorem
      
      [oracles: ] [axioms: SELECT_AX, BOOL_CASES_AX] []
      |- !b t1 t2. (if b then t1 else t2) = (b ==&gt; t1) /\ (~b ==&gt; t2)
   
   [<A NAME="COND_EXPAND_OR-val"><B>COND_EXPAND_OR</B></A>]  Theorem
      
      [oracles: ] [axioms: SELECT_AX, BOOL_CASES_AX] []
      |- !b t1 t2. (if b then t1 else t2) = b /\ t1 \/ ~b /\ t2
   
   [<A NAME="COND_ID-val"><B>COND_ID</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] []
      |- !b t. (if b then t else t) = t
   
   [<A NAME="COND_RAND-val"><B>COND_RAND</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] []
      |- !f b x y. f (if b then x else y) = if b then f x else f y
   
   [<A NAME="COND_RATOR-val"><B>COND_RATOR</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] []
      |- !b f g x. (if b then f else g) x = if b then f x else g x
   
   [<A NAME="CONJ_ASSOC-val"><B>CONJ_ASSOC</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !t1 t2 t3. t1 /\ t2 /\ t3 = (t1 /\ t2) /\ t3
   
   [<A NAME="CONJ_COMM-val"><B>CONJ_COMM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- !t1 t2. t1 /\ t2 = t2 /\ t1
   
   [<A NAME="CONJ_SYM-val"><B>CONJ_SYM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- !t1 t2. t1 /\ t2 = t2 /\ t1
   
   [<A NAME="DATATYPE_BOOL-val"><B>DATATYPE_BOOL</B></A>]  Theorem
      
      |- DATATYPE (bool T F) = T
   
   [<A NAME="DATATYPE_TAG_THM-val"><B>DATATYPE_TAG_THM</B></A>]  Theorem
      
      |- !x. DATATYPE x = T
   
   [<A NAME="DE_MORGAN_THM-val"><B>DE_MORGAN_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !A B. (~(A /\ B) = ~A \/ ~B) /\ (~(A \/ B) = ~A /\ ~B)
   
   [<A NAME="DISJ_ASSOC-val"><B>DISJ_ASSOC</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !A B C. A \/ B \/ C = (A \/ B) \/ C
   
   [<A NAME="DISJ_COMM-val"><B>DISJ_COMM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- !A B. A \/ B = B \/ A
   
   [<A NAME="DISJ_IMP_THM-val"><B>DISJ_IMP_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P Q R. P \/ Q ==&gt; R = (P ==&gt; R) /\ (Q ==&gt; R)
   
   [<A NAME="DISJ_SYM-val"><B>DISJ_SYM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- !A B. A \/ B = B \/ A
   
   [<A NAME="EQ_CLAUSES-val"><B>EQ_CLAUSES</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !t.
           ((T = t) = t) /\ ((t = T) = t) /\ ((F = t) = ~t) /\
           ((t = F) = ~t)
   
   [<A NAME="EQ_EXPAND-val"><B>EQ_EXPAND</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !t1 t2. (t1 = t2) = t1 /\ t2 \/ ~t1 /\ ~t2
   
   [<A NAME="EQ_EXT-val"><B>EQ_EXT</B></A>]  Theorem
      
      |- !f g. (!x. f x = g x) ==&gt; (f = g)
   
   [<A NAME="EQ_IMP_THM-val"><B>EQ_IMP_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !t1 t2. (t1 = t2) = (t1 ==&gt; t2) /\ (t2 ==&gt; t1)
   
   [<A NAME="EQ_REFL-val"><B>EQ_REFL</B></A>]  Theorem
      
      |- !x. x = x
   
   [<A NAME="EQ_SYM-val"><B>EQ_SYM</B></A>]  Theorem
      
      |- !x y. (x = y) ==&gt; (y = x)
   
   [<A NAME="EQ_SYM_EQ-val"><B>EQ_SYM_EQ</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- !x y. (x = y) = (y = x)
   
   [<A NAME="EQ_TRANS-val"><B>EQ_TRANS</B></A>]  Theorem
      
      |- !x y z. (x = y) /\ (y = z) ==&gt; (x = z)
   
   [<A NAME="ETA_THM-val"><B>ETA_THM</B></A>]  Theorem
      
      |- !M. (\x. M x) = M
   
   [<A NAME="EXCLUDED_MIDDLE-val"><B>EXCLUDED_MIDDLE</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- !t. t \/ ~t
   
   [<A NAME="EXISTS_OR_THM-val"><B>EXISTS_OR_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P Q. (?x. P x \/ Q x) = (?x. P x) \/ ?x. Q x
   
   [<A NAME="EXISTS_REFL-val"><B>EXISTS_REFL</B></A>]  Theorem
      
      |- !a. ?x. x = a
   
   [<A NAME="EXISTS_SIMP-val"><B>EXISTS_SIMP</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- !t. (?x. t) = t
   
   [<A NAME="EXISTS_THM-val"><B>EXISTS_THM</B></A>]  Theorem
      
      |- $? f = ?x. f x
   
   [<A NAME="EXISTS_UNIQUE_REFL-val"><B>EXISTS_UNIQUE_REFL</B></A>]  Theorem
      
      |- !a. ?!x. x = a
   
   [<A NAME="EXISTS_UNIQUE_THM-val"><B>EXISTS_UNIQUE_THM</B></A>]  Theorem
      
      |- (?!x. P x) = (?x. P x) /\ !x y. P x /\ P y ==&gt; (x = y)
   
   [<A NAME="FALSITY-val"><B>FALSITY</B></A>]  Theorem
      
      |- !t. F ==&gt; t
   
   [<A NAME="FORALL_AND_THM-val"><B>FORALL_AND_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P Q. (!x. P x /\ Q x) = (!x. P x) /\ !x. Q x
   
   [<A NAME="FORALL_BOOL-val"><B>FORALL_BOOL</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- (!b. P b) = P T /\ P F
   
   [<A NAME="FORALL_SIMP-val"><B>FORALL_SIMP</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- !t. (!x. t) = t
   
   [<A NAME="FORALL_THM-val"><B>FORALL_THM</B></A>]  Theorem
      
      |- $! f = !x. f x
   
   [<A NAME="FUN_EQ_THM-val"><B>FUN_EQ_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !f g. (f = g) = !x. f x = g x
   
   [<A NAME="F_IMP-val"><B>F_IMP</B></A>]  Theorem
      
      |- !t. ~t ==&gt; t ==&gt; F
   
   [<A NAME="IMP_ANTISYM_AX-val"><B>IMP_ANTISYM_AX</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !t1 t2. (t1 ==&gt; t2) ==&gt; (t2 ==&gt; t1) ==&gt; (t1 = t2)
   
   [<A NAME="IMP_CLAUSES-val"><B>IMP_CLAUSES</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !t.
           (T ==&gt; t = t) /\ (t ==&gt; T = T) /\ (F ==&gt; t = T) /\
           (t ==&gt; t = T) /\ (t ==&gt; F = ~t)
   
   [<A NAME="IMP_CONG-val"><B>IMP_CONG</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !x x' y y'.
           (x = x') /\ (x' ==&gt; (y = y')) ==&gt; (x ==&gt; y = x' ==&gt; y')
   
   [<A NAME="IMP_CONJ_THM-val"><B>IMP_CONJ_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P Q R. P ==&gt; Q /\ R = (P ==&gt; Q) /\ (P ==&gt; R)
   
   [<A NAME="IMP_DISJ_THM-val"><B>IMP_DISJ_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- !A B. A ==&gt; B = ~A \/ B
   
   [<A NAME="IMP_F-val"><B>IMP_F</B></A>]  Theorem
      
      |- !t. (t ==&gt; F) ==&gt; ~t
   
   [<A NAME="IMP_F_EQ_F-val"><B>IMP_F_EQ_F</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- !t. t ==&gt; F = (t = F)
   
   [<A NAME="ITSELF_UNIQUE-val"><B>ITSELF_UNIQUE</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- !i. i = (:'a)
   
   [<A NAME="JRH_INDUCT_UTIL-val"><B>JRH_INDUCT_UTIL</B></A>]  Theorem
      
      [oracles: ] [axioms: ETA_AX] []
      |- !P t. (!x. (x = t) ==&gt; P x) ==&gt; $? P
   
   [<A NAME="LCOMM_THM-val"><B>LCOMM_THM</B></A>]  Theorem
      
      |- !f.
           (!x y z. f x (f y z) = f (f x y) z) ==&gt;
           (!x y. f x y = f y x) ==&gt;
           !x y z. f x (f y z) = f y (f x z)
   
   [<A NAME="LEFT_AND_CONG-val"><B>LEFT_AND_CONG</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P P' Q Q'. (P = P') /\ (P' ==&gt; (Q = Q')) ==&gt; (P /\ Q = P' /\ Q')
   
   [<A NAME="LEFT_AND_FORALL_THM-val"><B>LEFT_AND_FORALL_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P Q. (!x. P x) /\ Q = !x. P x /\ Q
   
   [<A NAME="LEFT_AND_OVER_OR-val"><B>LEFT_AND_OVER_OR</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !A B C. A /\ (B \/ C) = A /\ B \/ A /\ C
   
   [<A NAME="LEFT_EXISTS_AND_THM-val"><B>LEFT_EXISTS_AND_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P Q. (?x. P x /\ Q) = (?x. P x) /\ Q
   
   [<A NAME="LEFT_EXISTS_IMP_THM-val"><B>LEFT_EXISTS_IMP_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P Q. (?x. P x ==&gt; Q) = (!x. P x) ==&gt; Q
   
   [<A NAME="LEFT_FORALL_IMP_THM-val"><B>LEFT_FORALL_IMP_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P Q. (!x. P x ==&gt; Q) = (?x. P x) ==&gt; Q
   
   [<A NAME="LEFT_FORALL_OR_THM-val"><B>LEFT_FORALL_OR_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !Q P. (!x. P x \/ Q) = (!x. P x) \/ Q
   
   [<A NAME="LEFT_OR_CONG-val"><B>LEFT_OR_CONG</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P P' Q Q'. (P = P') /\ (~P' ==&gt; (Q = Q')) ==&gt; (P \/ Q = P' \/ Q')
   
   [<A NAME="LEFT_OR_EXISTS_THM-val"><B>LEFT_OR_EXISTS_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P Q. (?x. P x) \/ Q = ?x. P x \/ Q
   
   [<A NAME="LEFT_OR_OVER_AND-val"><B>LEFT_OR_OVER_AND</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !A B C. A \/ B /\ C = (A \/ B) /\ (A \/ C)
   
   [<A NAME="LET_CONG-val"><B>LET_CONG</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !f g M N.
           (M = N) /\ (!x. (x = N) ==&gt; (f x = g x)) ==&gt; (LET f M = LET g N)
   
   [<A NAME="LET_RAND-val"><B>LET_RAND</B></A>]  Theorem
      
      |- P (let x = M in N x) = (let x = M in P (N x))
   
   [<A NAME="LET_RATOR-val"><B>LET_RATOR</B></A>]  Theorem
      
      |- (let x = M in N x) b = (let x = M in N x b)
   
   [<A NAME="LET_THM-val"><B>LET_THM</B></A>]  Theorem
      
      |- !f x. LET f x = f x
   
   [<A NAME="MONO_ALL-val"><B>MONO_ALL</B></A>]  Theorem
      
      |- (!x. P x ==&gt; Q x) ==&gt; (!x. P x) ==&gt; !x. Q x
   
   [<A NAME="MONO_AND-val"><B>MONO_AND</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- (x ==&gt; y) /\ (z ==&gt; w) ==&gt; x /\ z ==&gt; y /\ w
   
   [<A NAME="MONO_COND-val"><B>MONO_COND</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] []
      |- (x ==&gt; y) ==&gt;
         (z ==&gt; w) ==&gt;
         (if b then x else z) ==&gt;
         if b then y else w
   
   [<A NAME="MONO_EXISTS-val"><B>MONO_EXISTS</B></A>]  Theorem
      
      |- (!x. P x ==&gt; Q x) ==&gt; (?x. P x) ==&gt; ?x. Q x
   
   [<A NAME="MONO_IMP-val"><B>MONO_IMP</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- (y ==&gt; x) /\ (z ==&gt; w) ==&gt; (x ==&gt; z) ==&gt; y ==&gt; w
   
   [<A NAME="MONO_NOT-val"><B>MONO_NOT</B></A>]  Theorem
      
      |- (y ==&gt; x) ==&gt; ~x ==&gt; ~y
   
   [<A NAME="MONO_NOT_EQ-val"><B>MONO_NOT_EQ</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- y ==&gt; x = ~x ==&gt; ~y
   
   [<A NAME="MONO_OR-val"><B>MONO_OR</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- (x ==&gt; y) /\ (z ==&gt; w) ==&gt; x \/ z ==&gt; y \/ w
   
   [<A NAME="NOT_AND-val"><B>NOT_AND</B></A>]  Theorem
      
      |- ~(t /\ ~t)
   
   [<A NAME="NOT_CLAUSES-val"><B>NOT_CLAUSES</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- (!t. ~~t = t) /\ (~T = F) /\ (~F = T)
   
   [<A NAME="NOT_EXISTS_THM-val"><B>NOT_EXISTS_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- !P. ~(?x. P x) = !x. ~P x
   
   [<A NAME="NOT_F-val"><B>NOT_F</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- !t. ~t ==&gt; (t = F)
   
   [<A NAME="NOT_FORALL_THM-val"><B>NOT_FORALL_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- !P. ~(!x. P x) = ?x. ~P x
   
   [<A NAME="NOT_IMP-val"><B>NOT_IMP</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- !A B. ~(A ==&gt; B) = A /\ ~B
   
   [<A NAME="ONE_ONE_THM-val"><B>ONE_ONE_THM</B></A>]  Theorem
      
      |- !f. ONE_ONE f = !x1 x2. (f x1 = f x2) ==&gt; (x1 = x2)
   
   [<A NAME="ONTO_THM-val"><B>ONTO_THM</B></A>]  Theorem
      
      |- !f. ONTO f = !y. ?x. y = f x
   
   [<A NAME="OR_CLAUSES-val"><B>OR_CLAUSES</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !t.
           (T \/ t = T) /\ (t \/ T = T) /\ (F \/ t = t) /\ (t \/ F = t) /\
           (t \/ t = t)
   
   [<A NAME="OR_CONG-val"><B>OR_CONG</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P P' Q Q'.
           (~Q ==&gt; (P = P')) /\ (~P' ==&gt; (Q = Q')) ==&gt; (P \/ Q = P' \/ Q')
   
   [<A NAME="OR_ELIM_THM-val"><B>OR_ELIM_THM</B></A>]  Theorem
      
      |- !t t1 t2. t1 \/ t2 ==&gt; (t1 ==&gt; t) ==&gt; (t2 ==&gt; t) ==&gt; t
   
   [<A NAME="OR_IMP_THM-val"><B>OR_IMP_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !A B. (A = B \/ A) = B ==&gt; A
   
   [<A NAME="OR_INTRO_THM1-val"><B>OR_INTRO_THM1</B></A>]  Theorem
      
      |- !t1 t2. t1 ==&gt; t1 \/ t2
   
   [<A NAME="OR_INTRO_THM2-val"><B>OR_INTRO_THM2</B></A>]  Theorem
      
      |- !t1 t2. t2 ==&gt; t1 \/ t2
   
   [<A NAME="PEIRCE-val"><B>PEIRCE</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- ((P ==&gt; Q) ==&gt; P) ==&gt; P
   
   [<A NAME="REFL_CLAUSE-val"><B>REFL_CLAUSE</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- !x. (x = x) = T
   
   [<A NAME="RES_EXISTS_CONG-val"><B>RES_EXISTS_CONG</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- (P = Q) ==&gt;
         (!x. x IN Q ==&gt; (f x = g x)) ==&gt;
         (RES_EXISTS P f = RES_EXISTS Q g)
   
   [<A NAME="RES_EXISTS_FALSE-val"><B>RES_EXISTS_FALSE</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- (?x::P. F) = F
   
   [<A NAME="RES_EXISTS_THM-val"><B>RES_EXISTS_THM</B></A>]  Theorem
      
      |- !P f. RES_EXISTS P f = ?x. x IN P /\ f x
   
   [<A NAME="RES_EXISTS_UNIQUE_THM-val"><B>RES_EXISTS_UNIQUE_THM</B></A>]  Theorem
      
      |- !P f.
           RES_EXISTS_UNIQUE P f =
           (?x::P. f x) /\ !x y::P. f x /\ f y ==&gt; (x = y)
   
   [<A NAME="RES_FORALL_CONG-val"><B>RES_FORALL_CONG</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- (P = Q) ==&gt;
         (!x. x IN Q ==&gt; (f x = g x)) ==&gt;
         (RES_FORALL P f = RES_FORALL Q g)
   
   [<A NAME="RES_FORALL_THM-val"><B>RES_FORALL_THM</B></A>]  Theorem
      
      |- !P f. RES_FORALL P f = !x. x IN P ==&gt; f x
   
   [<A NAME="RES_FORALL_TRUE-val"><B>RES_FORALL_TRUE</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- (!x::P. T) = T
   
   [<A NAME="RES_SELECT_THM-val"><B>RES_SELECT_THM</B></A>]  Theorem
      
      |- !P f. RES_SELECT P f = @x. x IN P /\ f x
   
   [<A NAME="RIGHT_AND_FORALL_THM-val"><B>RIGHT_AND_FORALL_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P Q. P /\ (!x. Q x) = !x. P /\ Q x
   
   [<A NAME="RIGHT_AND_OVER_OR-val"><B>RIGHT_AND_OVER_OR</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !A B C. (B \/ C) /\ A = B /\ A \/ C /\ A
   
   [<A NAME="RIGHT_EXISTS_AND_THM-val"><B>RIGHT_EXISTS_AND_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P Q. (?x. P /\ Q x) = P /\ ?x. Q x
   
   [<A NAME="RIGHT_EXISTS_IMP_THM-val"><B>RIGHT_EXISTS_IMP_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P Q. (?x. P ==&gt; Q x) = P ==&gt; ?x. Q x
   
   [<A NAME="RIGHT_FORALL_IMP_THM-val"><B>RIGHT_FORALL_IMP_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P Q. (!x. P ==&gt; Q x) = P ==&gt; !x. Q x
   
   [<A NAME="RIGHT_FORALL_OR_THM-val"><B>RIGHT_FORALL_OR_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P Q. (!x. P \/ Q x) = P \/ !x. Q x
   
   [<A NAME="RIGHT_OR_EXISTS_THM-val"><B>RIGHT_OR_EXISTS_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P Q. P \/ (?x. Q x) = ?x. P \/ Q x
   
   [<A NAME="RIGHT_OR_OVER_AND-val"><B>RIGHT_OR_OVER_AND</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !A B C. B /\ C \/ A = (B \/ A) /\ (C \/ A)
   
   [<A NAME="SELECT_ELIM_THM-val"><B>SELECT_ELIM_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: SELECT_AX] []
      |- !P Q. (?x. P x) /\ (!x. P x ==&gt; Q x) ==&gt; Q ($@ P)
   
   [<A NAME="SELECT_REFL-val"><B>SELECT_REFL</B></A>]  Theorem
      
      [oracles: ] [axioms: SELECT_AX] [] |- !x. (@y. y = x) = x
   
   [<A NAME="SELECT_REFL_2-val"><B>SELECT_REFL_2</B></A>]  Theorem
      
      [oracles: ] [axioms: SELECT_AX] [] |- !x. (@y. x = y) = x
   
   [<A NAME="SELECT_THM-val"><B>SELECT_THM</B></A>]  Theorem
      
      |- !P. P (@x. P x) = ?x. P x
   
   [<A NAME="SELECT_UNIQUE-val"><B>SELECT_UNIQUE</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] []
      |- !P x. (!y. P y = (y = x)) ==&gt; ($@ P = x)
   
   [<A NAME="SKOLEM_THM-val"><B>SKOLEM_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] []
      |- !P. (!x. ?y. P x y) = ?f. !x. P x (f x)
   
   [<A NAME="SWAP_EXISTS_THM-val"><B>SWAP_EXISTS_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P. (?x y. P x y) = ?y x. P x y
   
   [<A NAME="SWAP_FORALL_THM-val"><B>SWAP_FORALL_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P. (!x y. P x y) = !y x. P x y
   
   [<A NAME="TRUTH-val"><B>TRUTH</B></A>]  Theorem
      
      |- T
   
   [<A NAME="TYPE_DEFINITION_THM-val"><B>TYPE_DEFINITION_THM</B></A>]  Theorem
      
      |- !P rep.
           TYPE_DEFINITION P rep =
           (!x' x''. (rep x' = rep x'') ==&gt; (x' = x'')) /\
           !x. P x = ?x'. x = rep x'
   
   [<A NAME="UEXISTS_OR_THM-val"><B>UEXISTS_OR_THM</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P Q. (?!x. P x \/ Q x) ==&gt; (?!x. P x) \/ ?!x. Q x
   
   [<A NAME="UEXISTS_SIMP-val"><B>UEXISTS_SIMP</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- (?!x. t) = t /\ !x y. x = y
   
   [<A NAME="UNWIND_FORALL_THM1-val"><B>UNWIND_FORALL_THM1</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !f v. (!x. (v = x) ==&gt; f x) = f v
   
   [<A NAME="UNWIND_FORALL_THM2-val"><B>UNWIND_FORALL_THM2</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !f v. (!x. (x = v) ==&gt; f x) = f v
   
   [<A NAME="UNWIND_THM1-val"><B>UNWIND_THM1</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P a. (?x. (a = x) /\ P x) = P a
   
   [<A NAME="UNWIND_THM2-val"><B>UNWIND_THM2</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !P a. (?x. (x = a) /\ P x) = P a
   
   [<A NAME="boolAxiom-val"><B>boolAxiom</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] []
      |- !e0 e1. ?fn. (fn T = e0) /\ (fn F = e1)
   
   [<A NAME="bool_INDUCT-val"><B>bool_INDUCT</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- !P. P T /\ P F ==&gt; !b. P b
   
   [<A NAME="bool_case_CONG-val"><B>bool_case_CONG</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] []
      |- !P Q x x' y y'.
           (P = Q) /\ (Q ==&gt; (x = x')) /\ (~Q ==&gt; (y = y')) ==&gt;
           (bool_case x y P = if Q then x' else y')
   
   [<A NAME="bool_case_EQ_COND-val"><B>bool_case_EQ_COND</B></A>]  Theorem
      
      |- !b x y. bool_case x y b = if b then x else y
   
   [<A NAME="bool_case_ID-val"><B>bool_case_ID</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] []
      |- !x b. bool_case x x b = x
   
   [<A NAME="bool_case_thm-val"><B>bool_case_thm</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] []
      |- (!e0 e1. bool_case e0 e1 T = e0) /\ !e0 e1. bool_case e0 e1 F = e1
   
   [<A NAME="itself_Axiom-val"><B>itself_Axiom</B></A>]  Theorem
      
      |- !e. ?f. f (:'b) = e
   
   [<A NAME="itself_induction-val"><B>itself_induction</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] [] |- !P. P (:'a) ==&gt; !i. P i
   
   [<A NAME="literal_case_CONG-val"><B>literal_case_CONG</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX] []
      |- !f g M N.
           (M = N) /\ (!x. (x = N) ==&gt; (f x = g x)) ==&gt;
           (literal_case f M = literal_case g N)
   
   [<A NAME="literal_case_RAND-val"><B>literal_case_RAND</B></A>]  Theorem
      
      |- P (literal_case (\x. N x) M) = literal_case (\x. P (N x)) M
   
   [<A NAME="literal_case_RATOR-val"><B>literal_case_RATOR</B></A>]  Theorem
      
      |- literal_case (\x. N x) M b = literal_case (\x. N x b) M
   
   [<A NAME="literal_case_THM-val"><B>literal_case_THM</B></A>]  Theorem
      
      |- !f x. literal_case f x = f x
   
   [<A NAME="literal_case_id-val"><B>literal_case_id</B></A>]  Theorem
      
      [oracles: ] [axioms: BOOL_CASES_AX, SELECT_AX] []
      |- literal_case (\x. bool_case t u (x = a)) a = t
   
   
*)
end

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/bool/boolScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
