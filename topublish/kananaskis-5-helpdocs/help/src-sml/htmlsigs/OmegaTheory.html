<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure OmegaTheory</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure OmegaTheory</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/integer/OmegaScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>signature OmegaTheory =
<A NAME="line2"></A>sig
<A NAME="line3"></A>  type thm = Thm.thm
<A NAME="line4"></A>  
<A NAME="line5"></A>  (*  Definitions  *)
<A NAME="line6"></A>    val MAP2_curried_def : thm
<A NAME="line7"></A>    val MAP2_tupled_primitive_def : thm
<A NAME="line8"></A>    val calc_nightmare_curried_def : thm
<A NAME="line9"></A>    val calc_nightmare_tupled_primitive_def : thm
<A NAME="line10"></A>    val dark_shadow_cond_row_curried_def : thm
<A NAME="line11"></A>    val dark_shadow_cond_row_tupled_primitive_def : thm
<A NAME="line12"></A>    val dark_shadow_condition_curried_def : thm
<A NAME="line13"></A>    val dark_shadow_condition_tupled_primitive_def : thm
<A NAME="line14"></A>    val dark_shadow_curried_def : thm
<A NAME="line15"></A>    val dark_shadow_row_curried_def : thm
<A NAME="line16"></A>    val dark_shadow_row_tupled_primitive_def : thm
<A NAME="line17"></A>    val dark_shadow_tupled_primitive_def : thm
<A NAME="line18"></A>    val evallower_curried_def : thm
<A NAME="line19"></A>    val evallower_tupled_primitive_def : thm
<A NAME="line20"></A>    val evalupper_curried_def : thm
<A NAME="line21"></A>    val evalupper_tupled_primitive_def : thm
<A NAME="line22"></A>    val fst1_def : thm
<A NAME="line23"></A>    val fst_nzero_def : thm
<A NAME="line24"></A>    val modhat_def : thm
<A NAME="line25"></A>    val nightmare_curried_def : thm
<A NAME="line26"></A>    val nightmare_tupled_primitive_def : thm
<A NAME="line27"></A>    val real_shadow_def : thm
<A NAME="line28"></A>    val rshadow_row_curried_def : thm
<A NAME="line29"></A>    val rshadow_row_tupled_primitive_def : thm
<A NAME="line30"></A>    val sumc_curried_def : thm
<A NAME="line31"></A>    val sumc_tupled_primitive_def : thm
<A NAME="line32"></A>  
<A NAME="line33"></A>  (*  Theorems  *)
<A NAME="line34"></A>    val MAP2_def : thm
<A NAME="line35"></A>    val MAP2_ind : thm
<A NAME="line36"></A>    val MAP2_zero_ADD : thm
<A NAME="line37"></A>    val alternative_equivalence : thm
<A NAME="line38"></A>    val basic_shadow_equivalence : thm
<A NAME="line39"></A>    val bigger_satisfies_lowers : thm
<A NAME="line40"></A>    val calc_nightmare_def : thm
<A NAME="line41"></A>    val calc_nightmare_ind : thm
<A NAME="line42"></A>    val calculational_nightmare : thm
<A NAME="line43"></A>    val dark_implies_real : thm
<A NAME="line44"></A>    val dark_shadow_FORALL : thm
<A NAME="line45"></A>    val dark_shadow_cond_row_def : thm
<A NAME="line46"></A>    val dark_shadow_cond_row_ind : thm
<A NAME="line47"></A>    val dark_shadow_condition_def : thm
<A NAME="line48"></A>    val dark_shadow_condition_ind : thm
<A NAME="line49"></A>    val dark_shadow_def : thm
<A NAME="line50"></A>    val dark_shadow_ind : thm
<A NAME="line51"></A>    val dark_shadow_row_def : thm
<A NAME="line52"></A>    val dark_shadow_row_ind : thm
<A NAME="line53"></A>    val darkrow_implies_realrow : thm
<A NAME="line54"></A>    val equality_removal : thm
<A NAME="line55"></A>    val eval_base : thm
<A NAME="line56"></A>    val eval_step_extra1 : thm
<A NAME="line57"></A>    val eval_step_extra2 : thm
<A NAME="line58"></A>    val eval_step_extra3 : thm
<A NAME="line59"></A>    val eval_step_extra4 : thm
<A NAME="line60"></A>    val eval_step_lower1 : thm
<A NAME="line61"></A>    val eval_step_lower2 : thm
<A NAME="line62"></A>    val eval_step_upper1 : thm
<A NAME="line63"></A>    val eval_step_upper2 : thm
<A NAME="line64"></A>    val evallower_FORALL : thm
<A NAME="line65"></A>    val evallower_def : thm
<A NAME="line66"></A>    val evallower_ind : thm
<A NAME="line67"></A>    val evalupper_FORALL : thm
<A NAME="line68"></A>    val evalupper_def : thm
<A NAME="line69"></A>    val evalupper_ind : thm
<A NAME="line70"></A>    val exact_shadow_case : thm
<A NAME="line71"></A>    val final_equivalence : thm
<A NAME="line72"></A>    val nightmare_EXISTS : thm
<A NAME="line73"></A>    val nightmare_def : thm
<A NAME="line74"></A>    val nightmare_implies_LHS : thm
<A NAME="line75"></A>    val nightmare_ind : thm
<A NAME="line76"></A>    val onlylowers_satisfiable : thm
<A NAME="line77"></A>    val onlyuppers_satisfiable : thm
<A NAME="line78"></A>    val real_shadow_FORALL : thm
<A NAME="line79"></A>    val real_shadow_always_implied : thm
<A NAME="line80"></A>    val real_shadow_revimp_lowers1 : thm
<A NAME="line81"></A>    val real_shadow_revimp_uppers1 : thm
<A NAME="line82"></A>    val rshadow_row_def : thm
<A NAME="line83"></A>    val rshadow_row_ind : thm
<A NAME="line84"></A>    val singleton_real_shadow : thm
<A NAME="line85"></A>    val smaller_satisfies_uppers : thm
<A NAME="line86"></A>    val sumc_ADD : thm
<A NAME="line87"></A>    val sumc_MULT : thm
<A NAME="line88"></A>    val sumc_def : thm
<A NAME="line89"></A>    val sumc_ind : thm
<A NAME="line90"></A>    val sumc_nonsingle : thm
<A NAME="line91"></A>    val sumc_singleton : thm
<A NAME="line92"></A>    val sumc_thm : thm
<A NAME="line93"></A>  
<A NAME="line94"></A>  val Omega_grammars : type_grammar.grammar * term_grammar.grammar
<A NAME="line95"></A>  
<A NAME="line96"></A>  
<A NAME="line97"></A>(*
   [integer] Parent theory of "Omega"
   
   [MAP2_curried_def]  Definition
      
      |- !x x1 x2 x3. MAP2 x x1 x2 x3 = MAP2_tupled (x,x1,x2,x3)
   
   [MAP2_tupled_primitive_def]  Definition
      
      |- MAP2_tupled =
         WFREC
           (@R.
              WF R /\ (!y ys f pad. R (pad,f,[],ys) (pad,f,[],y::ys)) /\
              (!x xs f pad. R (pad,f,xs,[]) (pad,f,x::xs,[])) /\
              !y x ys xs f pad. R (pad,f,xs,ys) (pad,f,x::xs,y::ys))
           (\MAP2_tupled a.
              case a of
                 (pad,f,[],[]) -&gt; I []
              || (pad,f,[],y::ys) -&gt; I (f pad y::MAP2_tupled (pad,f,[],ys))
              || (pad,f,x::xs,[]) -&gt; I (f x pad::MAP2_tupled (pad,f,xs,[]))
              || (pad,f,x::xs,y'::ys') -&gt;
                   I (f x y'::MAP2_tupled (pad,f,xs,ys')))
   
   [calc_nightmare_curried_def]  Definition
      
      |- !x x1 x2.
           calc_nightmare x x1 x2 &lt;=&gt; calc_nightmare_tupled (x,x1,x2)
   
   [calc_nightmare_tupled_primitive_def]  Definition
      
      |- calc_nightmare_tupled =
         WFREC (@R'. WF R' /\ !R d rs c x. R' (x,c,rs) (x,c,(d,R)::rs))
           (\calc_nightmare_tupled a.
              case a of
                 (x,c,[]) -&gt; I F
              || (x,c,(d,R)::rs) -&gt;
                   I
                     ((?i.
                         (0 &lt;= i /\ i &lt;= (&c * &d - &c - &d) / &c) /\
                         (&d * x = R + i)) \/
                      calc_nightmare_tupled (x,c,rs)))
   
   [dark_shadow_cond_row_curried_def]  Definition
      
      |- !x x1.
           dark_shadow_cond_row x x1 &lt;=&gt; dark_shadow_cond_row_tupled (x,x1)
   
   [dark_shadow_cond_row_tupled_primitive_def]  Definition
      
      |- dark_shadow_cond_row_tupled =
         WFREC (@R'. WF R' /\ !R d t L c. R' ((c,L),t) ((c,L),(d,R)::t))
           (\dark_shadow_cond_row_tupled a.
              case a of
                 ((c,L),[]) -&gt; I T
              || ((c,L),(d,R)::t) -&gt;
                   I
                     (~(?i.
                          &c * &d * i &lt; &c * R /\ &c * R &lt;= &d * L /\
                          &d * L &lt; &c * &d * (i + 1)) /\
                      dark_shadow_cond_row_tupled ((c,L),t)))
   
   [dark_shadow_condition_curried_def]  Definition
      
      |- !x x1.
           dark_shadow_condition x x1 &lt;=&gt;
           dark_shadow_condition_tupled (x,x1)
   
   [dark_shadow_condition_tupled_primitive_def]  Definition
      
      |- dark_shadow_condition_tupled =
         WFREC
           (@R.
              WF R /\
              !L c lowers uppers. R (uppers,lowers) ((c,L)::uppers,lowers))
           (\dark_shadow_condition_tupled a.
              case a of
                 ([],lowers) -&gt; I T
              || ((c,L)::uppers,lowers) -&gt;
                   I
                     (dark_shadow_cond_row (c,L) lowers /\
                      dark_shadow_condition_tupled (uppers,lowers)))
   
   [dark_shadow_curried_def]  Definition
      
      |- !x x1. dark_shadow x x1 &lt;=&gt; dark_shadow_tupled (x,x1)
   
   [dark_shadow_row_curried_def]  Definition
      
      |- !x x1 x2.
           dark_shadow_row x x1 x2 &lt;=&gt; dark_shadow_row_tupled (x,x1,x2)
   
   [dark_shadow_row_tupled_primitive_def]  Definition
      
      |- dark_shadow_row_tupled =
         WFREC (@R'. WF R' /\ !R d rs L c. R' (c,L,rs) (c,L,(d,R)::rs))
           (\dark_shadow_row_tupled a.
              case a of
                 (c,L,[]) -&gt; I T
              || (c,L,(d,R)::rs) -&gt;
                   I
                     (&d * L - &c * R &gt;= (&c - 1) * (&d - 1) /\
                      dark_shadow_row_tupled (c,L,rs)))
   
   [dark_shadow_tupled_primitive_def]  Definition
      
      |- dark_shadow_tupled =
         WFREC
           (@R.
              WF R /\
              !L c lowers uppers. R (uppers,lowers) ((c,L)::uppers,lowers))
           (\dark_shadow_tupled a.
              case a of
                 ([],lowers) -&gt; I T
              || ((c,L)::uppers,lowers) -&gt;
                   I
                     (dark_shadow_row c L lowers /\
                      dark_shadow_tupled (uppers,lowers)))
   
   [evallower_curried_def]  Definition
      
      |- !x x1. evallower x x1 &lt;=&gt; evallower_tupled (x,x1)
   
   [evallower_tupled_primitive_def]  Definition
      
      |- evallower_tupled =
         WFREC (@R. WF R /\ !y c cs x. R (x,cs) (x,(c,y)::cs))
           (\evallower_tupled a.
              case a of
                 (x,[]) -&gt; I T
              || (x,(c,y)::cs) -&gt;
                   I (y &lt;= &c * x /\ evallower_tupled (x,cs)))
   
   [evalupper_curried_def]  Definition
      
      |- !x x1. evalupper x x1 &lt;=&gt; evalupper_tupled (x,x1)
   
   [evalupper_tupled_primitive_def]  Definition
      
      |- evalupper_tupled =
         WFREC (@R. WF R /\ !y c cs x. R (x,cs) (x,(c,y)::cs))
           (\evalupper_tupled a.
              case a of
                 (x,[]) -&gt; I T
              || (x,(c,y)::cs) -&gt;
                   I (&c * x &lt;= y /\ evalupper_tupled (x,cs)))
   
   [fst1_def]  Definition
      
      |- !x. fst1 x &lt;=&gt; (FST x = 1)
   
   [fst_nzero_def]  Definition
      
      |- !x. fst_nzero x &lt;=&gt; 0 &lt; FST x
   
   [modhat_def]  Definition
      
      |- !x y. modhat x y = x - y * ((2 * x + y) / (2 * y))
   
   [nightmare_curried_def]  Definition
      
      |- !x x1 x2 x3 x4.
           nightmare x x1 x2 x3 x4 &lt;=&gt; nightmare_tupled (x,x1,x2,x3,x4)
   
   [nightmare_tupled_primitive_def]  Definition
      
      |- nightmare_tupled =
         WFREC
           (@R'.
              WF R' /\
              !R d rs lowers uppers c x.
                R' (x,c,uppers,lowers,rs) (x,c,uppers,lowers,(d,R)::rs))
           (\nightmare_tupled a.
              case a of
                 (x,c,uppers,lowers,[]) -&gt; I F
              || (x,c,uppers,lowers,(d,R)::rs) -&gt;
                   I
                     ((?i.
                         (0 &lt;= i /\ i &lt;= (&c * &d - &c - &d) / &c) /\
                         (&d * x = R + i) /\ evalupper x uppers /\
                         evallower x lowers) \/
                      nightmare_tupled (x,c,uppers,lowers,rs)))
   
   [real_shadow_def]  Definition
      
      |- (!lowers. real_shadow [] lowers &lt;=&gt; T) /\
         !upper ls lowers.
           real_shadow (upper::ls) lowers &lt;=&gt;
           rshadow_row upper lowers /\ real_shadow ls lowers
   
   [rshadow_row_curried_def]  Definition
      
      |- !x x1. rshadow_row x x1 &lt;=&gt; rshadow_row_tupled (x,x1)
   
   [rshadow_row_tupled_primitive_def]  Definition
      
      |- rshadow_row_tupled =
         WFREC
           (@R.
              WF R /\
              !lowery lowerc rs uppery upperc.
                R ((upperc,uppery),rs)
                  ((upperc,uppery),(lowerc,lowery)::rs))
           (\rshadow_row_tupled a.
              case a of
                 ((upperc,uppery),[]) -&gt; I T
              || ((upperc,uppery),(lowerc,lowery)::rs) -&gt;
                   I
                     (&upperc * lowery &lt;= &lowerc * uppery /\
                      rshadow_row_tupled ((upperc,uppery),rs)))
   
   [sumc_curried_def]  Definition
      
      |- !x x1. sumc x x1 = sumc_tupled (x,x1)
   
   [sumc_tupled_primitive_def]  Definition
      
      |- sumc_tupled =
         WFREC (@R. WF R /\ !v c vs cs. R (cs,vs) (c::cs,v::vs))
           (\sumc_tupled a.
              case a of
                 ([],[]) -&gt; I 0
              || ([],v10::v11) -&gt; I 0
              || (c::cs,[]) -&gt; I 0
              || (c::cs,v::vs) -&gt; I (c * v + sumc_tupled (cs,vs)))
   
   [MAP2_def]  Theorem
      
      |- (!pad f. MAP2 pad f [] [] = []) /\
         (!ys y pad f.
            MAP2 pad f [] (y::ys) = f pad y::MAP2 pad f [] ys) /\
         (!xs x pad f.
            MAP2 pad f (x::xs) [] = f x pad::MAP2 pad f xs []) /\
         !ys y xs x pad f.
           MAP2 pad f (x::xs) (y::ys) = f x y::MAP2 pad f xs ys
   
   [MAP2_ind]  Theorem
      
      |- !P.
           (!pad f. P pad f [] []) /\
           (!pad f y ys. P pad f [] ys ==&gt; P pad f [] (y::ys)) /\
           (!pad f x xs. P pad f xs [] ==&gt; P pad f (x::xs) []) /\
           (!pad f x xs y ys.
              P pad f xs ys ==&gt; P pad f (x::xs) (y::ys)) ==&gt;
           !v v1 v2 v3. P v v1 v2 v3
   
   [MAP2_zero_ADD]  Theorem
      
      |- !xs. (MAP2 0 $+ [] xs = xs) /\ (MAP2 0 $+ xs [] = xs)
   
   [alternative_equivalence]  Theorem
      
      |- !uppers lowers m.
           EVERY fst_nzero uppers /\ EVERY fst_nzero lowers /\
           EVERY (\p. FST p &lt;= m) uppers ==&gt;
           ((?x. evalupper x uppers /\ evallower x lowers) &lt;=&gt;
            dark_shadow uppers lowers \/
            ?x. nightmare x m uppers lowers lowers)
   
   [basic_shadow_equivalence]  Theorem
      
      |- !uppers lowers.
           EVERY fst_nzero uppers /\ EVERY fst_nzero lowers ==&gt;
           ((?x. evalupper x uppers /\ evallower x lowers) &lt;=&gt;
            real_shadow uppers lowers /\
            dark_shadow_condition uppers lowers)
   
   [bigger_satisfies_lowers]  Theorem
      
      |- !lowers x y. evallower x lowers /\ x &lt; y ==&gt; evallower y lowers
   
   [calc_nightmare_def]  Theorem
      
      |- (!x c. calc_nightmare x c [] &lt;=&gt; F) /\
         !x rs d c R.
           calc_nightmare x c ((d,R)::rs) &lt;=&gt;
           (?i.
              (0 &lt;= i /\ i &lt;= (&c * &d - &c - &d) / &c) /\
              (&d * x = R + i)) \/ calc_nightmare x c rs
   
   [calc_nightmare_ind]  Theorem
      
      |- !P.
           (!x c. P x c []) /\
           (!x c d R rs. P x c rs ==&gt; P x c ((d,R)::rs)) ==&gt;
           !v v1 v2. P v v1 v2
   
   [calculational_nightmare]  Theorem
      
      |- !rs.
           nightmare x c uppers lowers rs &lt;=&gt;
           calc_nightmare x c rs /\ evalupper x uppers /\
           evallower x lowers
   
   [dark_implies_real]  Theorem
      
      |- !uppers lowers.
           EVERY fst_nzero uppers /\ EVERY fst_nzero lowers /\
           dark_shadow uppers lowers ==&gt;
           real_shadow uppers lowers
   
   [dark_shadow_FORALL]  Theorem
      
      |- !uppers lowers.
           dark_shadow uppers lowers &lt;=&gt;
           !c d L R.
             MEM (c,L) uppers /\ MEM (d,R) lowers ==&gt;
             &d * L - &c * R &gt;= (&c - 1) * (&d - 1)
   
   [dark_shadow_cond_row_def]  Theorem
      
      |- (!c L. dark_shadow_cond_row (c,L) [] &lt;=&gt; T) /\
         !t d c R L.
           dark_shadow_cond_row (c,L) ((d,R)::t) &lt;=&gt;
           ~(?i.
               &c * &d * i &lt; &c * R /\ &c * R &lt;= &d * L /\
               &d * L &lt; &c * &d * (i + 1)) /\ dark_shadow_cond_row (c,L) t
   
   [dark_shadow_cond_row_ind]  Theorem
      
      |- !P.
           (!c L. P (c,L) []) /\
           (!c L d R t. P (c,L) t ==&gt; P (c,L) ((d,R)::t)) ==&gt;
           !v v1 v2. P (v,v1) v2
   
   [dark_shadow_condition_def]  Theorem
      
      |- (!lowers. dark_shadow_condition [] lowers &lt;=&gt; T) /\
         !uppers lowers c L.
           dark_shadow_condition ((c,L)::uppers) lowers &lt;=&gt;
           dark_shadow_cond_row (c,L) lowers /\
           dark_shadow_condition uppers lowers
   
   [dark_shadow_condition_ind]  Theorem
      
      |- !P.
           (!lowers. P [] lowers) /\
           (!c L uppers lowers.
              P uppers lowers ==&gt; P ((c,L)::uppers) lowers) ==&gt;
           !v v1. P v v1
   
   [dark_shadow_def]  Theorem
      
      |- (!lowers. dark_shadow [] lowers &lt;=&gt; T) /\
         !uppers lowers c L.
           dark_shadow ((c,L)::uppers) lowers &lt;=&gt;
           dark_shadow_row c L lowers /\ dark_shadow uppers lowers
   
   [dark_shadow_ind]  Theorem
      
      |- !P.
           (!lowers. P [] lowers) /\
           (!c L uppers lowers.
              P uppers lowers ==&gt; P ((c,L)::uppers) lowers) ==&gt;
           !v v1. P v v1
   
   [dark_shadow_row_def]  Theorem
      
      |- (!c L. dark_shadow_row c L [] &lt;=&gt; T) /\
         !rs d c R L.
           dark_shadow_row c L ((d,R)::rs) &lt;=&gt;
           &d * L - &c * R &gt;= (&c - 1) * (&d - 1) /\ dark_shadow_row c L rs
   
   [dark_shadow_row_ind]  Theorem
      
      |- !P.
           (!c L. P c L []) /\
           (!c L d R rs. P c L rs ==&gt; P c L ((d,R)::rs)) ==&gt;
           !v v1 v2. P v v1 v2
   
   [darkrow_implies_realrow]  Theorem
      
      |- !lowers c L.
           0 &lt; c /\ EVERY fst_nzero lowers /\
           dark_shadow_row c L lowers ==&gt;
           rshadow_row (c,L) lowers
   
   [equality_removal]  Theorem
      
      |- !c x cs vs.
           0 &lt; c ==&gt;
           ((0 = c * x + sumc cs vs) &lt;=&gt;
            ?s.
              (x =
               -(c + 1) * s + sumc (MAP (\x. modhat x (c + 1)) cs) vs) /\
              (0 = c * x + sumc cs vs))
   
   [eval_base]  Theorem
      
      |- p &lt;=&gt; ((evalupper x [] /\ evallower x []) /\ T) /\ p
   
   [eval_step_extra1]  Theorem
      
      |- ((evalupper x ups /\ evallower x lows) /\ T) /\ ex' &lt;=&gt;
         (evalupper x ups /\ evallower x lows) /\ ex'
   
   [eval_step_extra2]  Theorem
      
      |- ((evalupper x ups /\ evallower x lows) /\ ex) /\ ex' &lt;=&gt;
         (evalupper x ups /\ evallower x lows) /\ ex /\ ex'
   
   [eval_step_extra3]  Theorem
      
      |- ((evalupper x ups /\ evallower x lows) /\ T) /\ ex' /\ p &lt;=&gt;
         ((evalupper x ups /\ evallower x lows) /\ ex') /\ p
   
   [eval_step_extra4]  Theorem
      
      |- ((evalupper x ups /\ evallower x lows) /\ ex) /\ ex' /\ p &lt;=&gt;
         ((evalupper x ups /\ evallower x lows) /\ ex /\ ex') /\ p
   
   [eval_step_lower1]  Theorem
      
      |- ((evalupper x ups /\ evallower x lows) /\ ex) /\ r &lt;= &c * x &lt;=&gt;
         (evalupper x ups /\ evallower x ((c,r)::lows)) /\ ex
   
   [eval_step_lower2]  Theorem
      
      |- ((evalupper x ups /\ evallower x lows) /\ ex) /\ r &lt;= &c * x /\
         p &lt;=&gt; ((evalupper x ups /\ evallower x ((c,r)::lows)) /\ ex) /\ p
   
   [eval_step_upper1]  Theorem
      
      |- ((evalupper x ups /\ evallower x lows) /\ ex) /\ &c * x &lt;= r &lt;=&gt;
         (evalupper x ((c,r)::ups) /\ evallower x lows) /\ ex
   
   [eval_step_upper2]  Theorem
      
      |- ((evalupper x ups /\ evallower x lows) /\ ex) /\ &c * x &lt;= r /\
         p &lt;=&gt; ((evalupper x ((c,r)::ups) /\ evallower x lows) /\ ex) /\ p
   
   [evallower_FORALL]  Theorem
      
      |- !lowers x.
           evallower x lowers &lt;=&gt; !d R. MEM (d,R) lowers ==&gt; R &lt;= &d * x
   
   [evallower_def]  Theorem
      
      |- (!x. evallower x [] &lt;=&gt; T) /\
         !y x cs c.
           evallower x ((c,y)::cs) &lt;=&gt; y &lt;= &c * x /\ evallower x cs
   
   [evallower_ind]  Theorem
      
      |- !P.
           (!x. P x []) /\ (!x c y cs. P x cs ==&gt; P x ((c,y)::cs)) ==&gt;
           !v v1. P v v1
   
   [evalupper_FORALL]  Theorem
      
      |- !uppers x.
           evalupper x uppers &lt;=&gt; !c L. MEM (c,L) uppers ==&gt; &c * x &lt;= L
   
   [evalupper_def]  Theorem
      
      |- (!x. evalupper x [] &lt;=&gt; T) /\
         !y x cs c.
           evalupper x ((c,y)::cs) &lt;=&gt; &c * x &lt;= y /\ evalupper x cs
   
   [evalupper_ind]  Theorem
      
      |- !P.
           (!x. P x []) /\ (!x c y cs. P x cs ==&gt; P x ((c,y)::cs)) ==&gt;
           !v v1. P v v1
   
   [exact_shadow_case]  Theorem
      
      |- !uppers lowers.
           EVERY fst_nzero uppers /\ EVERY fst_nzero lowers ==&gt;
           EVERY fst1 uppers \/ EVERY fst1 lowers ==&gt;
           ((?x. evalupper x uppers /\ evallower x lowers) &lt;=&gt;
            real_shadow uppers lowers)
   
   [final_equivalence]  Theorem
      
      |- !uppers lowers m.
           EVERY fst_nzero uppers /\ EVERY fst_nzero lowers /\
           EVERY (\p. FST p &lt;= m) uppers ==&gt;
           ((?x. evalupper x uppers /\ evallower x lowers) &lt;=&gt;
            real_shadow uppers lowers /\
            (dark_shadow uppers lowers \/
             ?x. nightmare x m uppers lowers lowers))
   
   [nightmare_EXISTS]  Theorem
      
      |- !rs x c uppers lowers.
           nightmare x c uppers lowers rs &lt;=&gt;
           ?i d R.
             0 &lt;= i /\ i &lt;= (&d * &c - &c - &d) / &c /\ MEM (d,R) rs /\
             evalupper x uppers /\ evallower x lowers /\ (&d * x = R + i)
   
   [nightmare_def]  Theorem
      
      |- (!x uppers lowers c. nightmare x c uppers lowers [] &lt;=&gt; F) /\
         !x uppers rs lowers d c R.
           nightmare x c uppers lowers ((d,R)::rs) &lt;=&gt;
           (?i.
              (0 &lt;= i /\ i &lt;= (&c * &d - &c - &d) / &c) /\
              (&d * x = R + i) /\ evalupper x uppers /\
              evallower x lowers) \/ nightmare x c uppers lowers rs
   
   [nightmare_implies_LHS]  Theorem
      
      |- !rs x uppers lowers c.
           nightmare x c uppers lowers rs ==&gt;
           evalupper x uppers /\ evallower x lowers
   
   [nightmare_ind]  Theorem
      
      |- !P.
           (!x c uppers lowers. P x c uppers lowers []) /\
           (!x c uppers lowers d R rs.
              P x c uppers lowers rs ==&gt;
              P x c uppers lowers ((d,R)::rs)) ==&gt;
           !v v1 v2 v3 v4. P v v1 v2 v3 v4
   
   [onlylowers_satisfiable]  Theorem
      
      |- !lowers. EVERY fst_nzero lowers ==&gt; ?x. evallower x lowers
   
   [onlyuppers_satisfiable]  Theorem
      
      |- !uppers. EVERY fst_nzero uppers ==&gt; ?x. evalupper x uppers
   
   [real_shadow_FORALL]  Theorem
      
      |- !uppers lowers.
           real_shadow uppers lowers &lt;=&gt;
           !c d L R.
             MEM (c,L) uppers /\ MEM (d,R) lowers ==&gt; &c * R &lt;= &d * L
   
   [real_shadow_always_implied]  Theorem
      
      |- !uppers lowers x.
           evalupper x uppers /\ evallower x lowers /\
           EVERY fst_nzero uppers /\ EVERY fst_nzero lowers ==&gt;
           real_shadow uppers lowers
   
   [real_shadow_revimp_lowers1]  Theorem
      
      |- !uppers lowers c L x.
           0 &lt; c /\ rshadow_row (c,L) lowers /\ evalupper x uppers /\
           evallower x lowers /\ EVERY fst_nzero uppers /\
           EVERY fst1 lowers ==&gt;
           ?x. &c * x &lt;= L /\ evalupper x uppers /\ evallower x lowers
   
   [real_shadow_revimp_uppers1]  Theorem
      
      |- !uppers lowers L x.
           rshadow_row (1,L) lowers /\ evallower x lowers /\
           evalupper x uppers /\ EVERY fst_nzero lowers /\
           EVERY fst1 uppers ==&gt;
           ?x. x &lt;= L /\ evalupper x uppers /\ evallower x lowers
   
   [rshadow_row_def]  Theorem
      
      |- (!uppery upperc. rshadow_row (upperc,uppery) [] &lt;=&gt; T) /\
         !uppery upperc rs lowery lowerc.
           rshadow_row (upperc,uppery) ((lowerc,lowery)::rs) &lt;=&gt;
           &upperc * lowery &lt;= &lowerc * uppery /\
           rshadow_row (upperc,uppery) rs
   
   [rshadow_row_ind]  Theorem
      
      |- !P.
           (!upperc uppery. P (upperc,uppery) []) /\
           (!upperc uppery lowerc lowery rs.
              P (upperc,uppery) rs ==&gt;
              P (upperc,uppery) ((lowerc,lowery)::rs)) ==&gt;
           !v v1 v2. P (v,v1) v2
   
   [singleton_real_shadow]  Theorem
      
      |- !c L x.
           &c * x &lt;= L /\ 0 &lt; c ==&gt;
           !lowers.
             EVERY fst_nzero lowers /\ evallower x lowers ==&gt;
             rshadow_row (c,L) lowers
   
   [smaller_satisfies_uppers]  Theorem
      
      |- !uppers x y. evalupper x uppers /\ y &lt; x ==&gt; evalupper y uppers
   
   [sumc_ADD]  Theorem
      
      |- !cs vs ds. sumc cs vs + sumc ds vs = sumc (MAP2 0 $+ cs ds) vs
   
   [sumc_MULT]  Theorem
      
      |- !cs vs f. f * sumc cs vs = sumc (MAP (\x. f * x) cs) vs
   
   [sumc_def]  Theorem
      
      |- (sumc [] [] = 0) /\ (!v5 v4. sumc (v4::v5) [] = 0) /\
         (!v9 v8. sumc [] (v8::v9) = 0) /\
         !vs v cs c. sumc (c::cs) (v::vs) = c * v + sumc cs vs
   
   [sumc_ind]  Theorem
      
      |- !P.
           P [] [] /\ (!v4 v5. P (v4::v5) []) /\ (!v8 v9. P [] (v8::v9)) /\
           (!c cs v vs. P cs vs ==&gt; P (c::cs) (v::vs)) ==&gt;
           !v v1. P v v1
   
   [sumc_nonsingle]  Theorem
      
      |- !f cs c v vs.
           sumc (MAP f (c::cs)) (v::vs) = f c * v + sumc (MAP f cs) vs
   
   [sumc_singleton]  Theorem
      
      |- !f c. sumc (MAP f [c]) [1] = f c
   
   [sumc_thm]  Theorem
      
      |- !cs vs c v.
           (sumc [] vs = 0) /\ (sumc cs [] = 0) /\
           (sumc (c::cs) (v::vs) = c * v + sumc cs vs)
   
   
*)
end

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/integer/OmegaScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
