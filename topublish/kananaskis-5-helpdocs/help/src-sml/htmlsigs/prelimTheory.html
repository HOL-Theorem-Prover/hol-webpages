<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure prelimTheory</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure prelimTheory</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/ring/src/prelimScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>signature prelimTheory =
<A NAME="line2"></A>sig
<A NAME="line3"></A>  type thm = Thm.thm
<A NAME="line4"></A>  
<A NAME="line5"></A>  (*  Definitions  *)
<A NAME="line6"></A>    val <A HREF="#EQUAL_def-val">EQUAL_def</A> : thm
<A NAME="line7"></A>    val <A HREF="#GREATER_def-val">GREATER_def</A> : thm
<A NAME="line8"></A>    val <A HREF="#LESS_def-val">LESS_def</A> : thm
<A NAME="line9"></A>    val <A HREF="#compare_def-val">compare_def</A> : thm
<A NAME="line10"></A>    val <A HREF="#list_compare_curried_def-val">list_compare_curried_def</A> : thm
<A NAME="line11"></A>    val <A HREF="#list_compare_tupled_primitive_def-val">list_compare_tupled_primitive_def</A> : thm
<A NAME="line12"></A>    val <A HREF="#list_merge_curried_def-val">list_merge_curried_def</A> : thm
<A NAME="line13"></A>    val <A HREF="#list_merge_tupled_primitive_def-val">list_merge_tupled_primitive_def</A> : thm
<A NAME="line14"></A>    val <A HREF="#ordering_BIJ-val">ordering_BIJ</A> : thm
<A NAME="line15"></A>    val <A HREF="#ordering_TY_DEF-val">ordering_TY_DEF</A> : thm
<A NAME="line16"></A>    val <A HREF="#ordering_case-val">ordering_case</A> : thm
<A NAME="line17"></A>    val <A HREF="#ordering_size_def-val">ordering_size_def</A> : thm
<A NAME="line18"></A>  
<A NAME="line19"></A>  (*  Theorems  *)
<A NAME="line20"></A>    val <A HREF="#compare_equal-val">compare_equal</A> : thm
<A NAME="line21"></A>    val <A HREF="#datatype_ordering-val">datatype_ordering</A> : thm
<A NAME="line22"></A>    val <A HREF="#list_compare_def-val">list_compare_def</A> : thm
<A NAME="line23"></A>    val <A HREF="#list_compare_ind-val">list_compare_ind</A> : thm
<A NAME="line24"></A>    val <A HREF="#list_merge_def-val">list_merge_def</A> : thm
<A NAME="line25"></A>    val <A HREF="#list_merge_ind-val">list_merge_ind</A> : thm
<A NAME="line26"></A>    val <A HREF="#num2ordering_11-val">num2ordering_11</A> : thm
<A NAME="line27"></A>    val <A HREF="#num2ordering_ONTO-val">num2ordering_ONTO</A> : thm
<A NAME="line28"></A>    val <A HREF="#num2ordering_ordering2num-val">num2ordering_ordering2num</A> : thm
<A NAME="line29"></A>    val <A HREF="#num2ordering_thm-val">num2ordering_thm</A> : thm
<A NAME="line30"></A>    val <A HREF="#ordering2num_11-val">ordering2num_11</A> : thm
<A NAME="line31"></A>    val <A HREF="#ordering2num_ONTO-val">ordering2num_ONTO</A> : thm
<A NAME="line32"></A>    val <A HREF="#ordering2num_num2ordering-val">ordering2num_num2ordering</A> : thm
<A NAME="line33"></A>    val <A HREF="#ordering2num_thm-val">ordering2num_thm</A> : thm
<A NAME="line34"></A>    val <A HREF="#ordering_Axiom-val">ordering_Axiom</A> : thm
<A NAME="line35"></A>    val <A HREF="#ordering_EQ_ordering-val">ordering_EQ_ordering</A> : thm
<A NAME="line36"></A>    val <A HREF="#ordering_case_cong-val">ordering_case_cong</A> : thm
<A NAME="line37"></A>    val <A HREF="#ordering_case_def-val">ordering_case_def</A> : thm
<A NAME="line38"></A>    val <A HREF="#ordering_distinct-val">ordering_distinct</A> : thm
<A NAME="line39"></A>    val <A HREF="#ordering_eq_dec-val">ordering_eq_dec</A> : thm
<A NAME="line40"></A>    val <A HREF="#ordering_induction-val">ordering_induction</A> : thm
<A NAME="line41"></A>    val <A HREF="#ordering_nchotomy-val">ordering_nchotomy</A> : thm
<A NAME="line42"></A>  
<A NAME="line43"></A>  val prelim_grammars : type_grammar.grammar * term_grammar.grammar
<A NAME="line44"></A>  
<A NAME="line45"></A>  
<A NAME="line46"></A>(*
   [list] Parent theory of "prelim"
   
   [<A NAME="EQUAL_def-val"><B>EQUAL_def</B></A>]  Definition
      
      |- EQUAL = num2ordering 1
   
   [<A NAME="GREATER_def-val"><B>GREATER_def</B></A>]  Definition
      
      |- GREATER = num2ordering 2
   
   [<A NAME="LESS_def-val"><B>LESS_def</B></A>]  Definition
      
      |- LESS = num2ordering 0
   
   [<A NAME="compare_def-val"><B>compare_def</B></A>]  Definition
      
      |- (!lt eq gt. compare LESS lt eq gt = lt) /\
         (!lt eq gt. compare EQUAL lt eq gt = eq) /\
         !lt eq gt. compare GREATER lt eq gt = gt
   
   [<A NAME="list_compare_curried_def-val"><B>list_compare_curried_def</B></A>]  Definition
      
      |- !x x1 x2. list_compare x x1 x2 = list_compare_tupled (x,x1,x2)
   
   [<A NAME="list_compare_tupled_primitive_def-val"><B>list_compare_tupled_primitive_def</B></A>]  Definition
      
      |- list_compare_tupled =
         WFREC
           (@R. WF R /\ !y x l2 l1 cmp. R (cmp,l1,l2) (cmp,x::l1,y::l2))
           (\list_compare_tupled a.
              case a of
                 (cmp,[],[]) -&gt; I EQUAL
              || (cmp,[],v10::v11) -&gt; I LESS
              || (cmp,x::l1,[]) -&gt; I GREATER
              || (cmp,x::l1,y::l2) -&gt;
                   I
                     (compare (cmp x y) LESS
                        (list_compare_tupled (cmp,l1,l2)) GREATER))
   
   [<A NAME="list_merge_curried_def-val"><B>list_merge_curried_def</B></A>]  Definition
      
      |- !x x1 x2. list_merge x x1 x2 = list_merge_tupled (x,x1,x2)
   
   [<A NAME="list_merge_tupled_primitive_def-val"><B>list_merge_tupled_primitive_def</B></A>]  Definition
      
      |- list_merge_tupled =
         WFREC
           (@R.
              WF R /\
              (!l2 l1 y x a_lt.
                 ~a_lt x y ==&gt; R (a_lt,x::l1,l2) (a_lt,x::l1,y::l2)) /\
              !l2 l1 y x a_lt.
                a_lt x y ==&gt; R (a_lt,l1,y::l2) (a_lt,x::l1,y::l2))
           (\list_merge_tupled a.
              case a of
                 (a_lt,[],[]) -&gt; I []
              || (a_lt,[],v10::v11) -&gt; I (v10::v11)
              || (a_lt,x::l1,[]) -&gt; I (x::l1)
              || (a_lt,x::l1,y::l2) -&gt;
                   I
                     (if a_lt x y then
                        x::list_merge_tupled (a_lt,l1,y::l2)
                      else
                        y::list_merge_tupled (a_lt,x::l1,l2)))
   
   [<A NAME="ordering_BIJ-val"><B>ordering_BIJ</B></A>]  Definition
      
      |- (!a. num2ordering (ordering2num a) = a) /\
         !r. (\n. n &lt; 3) r &lt;=&gt; (ordering2num (num2ordering r) = r)
   
   [<A NAME="ordering_TY_DEF-val"><B>ordering_TY_DEF</B></A>]  Definition
      
      |- ?rep. TYPE_DEFINITION (\n. n &lt; 3) rep
   
   [<A NAME="ordering_case-val"><B>ordering_case</B></A>]  Definition
      
      |- !v0 v1 v2 x.
           (case x of LESS -&gt; v0 || EQUAL -&gt; v1 || GREATER -&gt; v2) =
           (\m. if m &lt; 1 then v0 else if m = 1 then v1 else v2)
             (ordering2num x)
   
   [<A NAME="ordering_size_def-val"><B>ordering_size_def</B></A>]  Definition
      
      |- !x. ordering_size x = 0
   
   [<A NAME="compare_equal-val"><B>compare_equal</B></A>]  Theorem
      
      |- (!x y. (cmp x y = EQUAL) &lt;=&gt; (x = y)) ==&gt;
         !l1 l2. (list_compare cmp l1 l2 = EQUAL) &lt;=&gt; (l1 = l2)
   
   [<A NAME="datatype_ordering-val"><B>datatype_ordering</B></A>]  Theorem
      
      |- DATATYPE (ordering LESS EQUAL GREATER)
   
   [<A NAME="list_compare_def-val"><B>list_compare_def</B></A>]  Theorem
      
      |- (!cmp. list_compare cmp [] [] = EQUAL) /\
         (!v9 v8 cmp. list_compare cmp [] (v8::v9) = LESS) /\
         (!v5 v4 cmp. list_compare cmp (v4::v5) [] = GREATER) /\
         !y x l2 l1 cmp.
           list_compare cmp (x::l1) (y::l2) =
           compare (cmp x y) LESS (list_compare cmp l1 l2) GREATER
   
   [<A NAME="list_compare_ind-val"><B>list_compare_ind</B></A>]  Theorem
      
      |- !P.
           (!cmp. P cmp [] []) /\ (!cmp v8 v9. P cmp [] (v8::v9)) /\
           (!cmp v4 v5. P cmp (v4::v5) []) /\
           (!cmp x l1 y l2. P cmp l1 l2 ==&gt; P cmp (x::l1) (y::l2)) ==&gt;
           !v v1 v2. P v v1 v2
   
   [<A NAME="list_merge_def-val"><B>list_merge_def</B></A>]  Theorem
      
      |- (!a_lt. list_merge a_lt [] [] = []) /\
         (!v5 v4 a_lt. list_merge a_lt (v4::v5) [] = v4::v5) /\
         (!v9 v8 a_lt. list_merge a_lt [] (v8::v9) = v8::v9) /\
         !y x l2 l1 a_lt.
           list_merge a_lt (x::l1) (y::l2) =
           if a_lt x y then
             x::list_merge a_lt l1 (y::l2)
           else
             y::list_merge a_lt (x::l1) l2
   
   [<A NAME="list_merge_ind-val"><B>list_merge_ind</B></A>]  Theorem
      
      |- !P.
           (!a_lt. P a_lt [] []) /\ (!a_lt v4 v5. P a_lt (v4::v5) []) /\
           (!a_lt v8 v9. P a_lt [] (v8::v9)) /\
           (!a_lt x l1 y l2.
              (~a_lt x y ==&gt; P a_lt (x::l1) l2) /\
              (a_lt x y ==&gt; P a_lt l1 (y::l2)) ==&gt;
              P a_lt (x::l1) (y::l2)) ==&gt;
           !v v1 v2. P v v1 v2
   
   [<A NAME="num2ordering_11-val"><B>num2ordering_11</B></A>]  Theorem
      
      |- !r r'.
           r &lt; 3 ==&gt;
           r' &lt; 3 ==&gt;
           ((num2ordering r = num2ordering r') &lt;=&gt; (r = r'))
   
   [<A NAME="num2ordering_ONTO-val"><B>num2ordering_ONTO</B></A>]  Theorem
      
      |- !a. ?r. (a = num2ordering r) /\ r &lt; 3
   
   [<A NAME="num2ordering_ordering2num-val"><B>num2ordering_ordering2num</B></A>]  Theorem
      
      |- !a. num2ordering (ordering2num a) = a
   
   [<A NAME="num2ordering_thm-val"><B>num2ordering_thm</B></A>]  Theorem
      
      |- (num2ordering 0 = LESS) /\ (num2ordering 1 = EQUAL) /\
         (num2ordering 2 = GREATER)
   
   [<A NAME="ordering2num_11-val"><B>ordering2num_11</B></A>]  Theorem
      
      |- !a a'. (ordering2num a = ordering2num a') &lt;=&gt; (a = a')
   
   [<A NAME="ordering2num_ONTO-val"><B>ordering2num_ONTO</B></A>]  Theorem
      
      |- !r. r &lt; 3 &lt;=&gt; ?a. r = ordering2num a
   
   [<A NAME="ordering2num_num2ordering-val"><B>ordering2num_num2ordering</B></A>]  Theorem
      
      |- !r. r &lt; 3 &lt;=&gt; (ordering2num (num2ordering r) = r)
   
   [<A NAME="ordering2num_thm-val"><B>ordering2num_thm</B></A>]  Theorem
      
      |- (ordering2num LESS = 0) /\ (ordering2num EQUAL = 1) /\
         (ordering2num GREATER = 2)
   
   [<A NAME="ordering_Axiom-val"><B>ordering_Axiom</B></A>]  Theorem
      
      |- !x0 x1 x2. ?f. (f LESS = x0) /\ (f EQUAL = x1) /\ (f GREATER = x2)
   
   [<A NAME="ordering_EQ_ordering-val"><B>ordering_EQ_ordering</B></A>]  Theorem
      
      |- !a a'. (a = a') &lt;=&gt; (ordering2num a = ordering2num a')
   
   [<A NAME="ordering_case_cong-val"><B>ordering_case_cong</B></A>]  Theorem
      
      |- !M M' v0 v1 v2.
           (M = M') /\ ((M' = LESS) ==&gt; (v0 = v0')) /\
           ((M' = EQUAL) ==&gt; (v1 = v1')) /\
           ((M' = GREATER) ==&gt; (v2 = v2')) ==&gt;
           ((case M of LESS -&gt; v0 || EQUAL -&gt; v1 || GREATER -&gt; v2) =
            case M' of LESS -&gt; v0' || EQUAL -&gt; v1' || GREATER -&gt; v2')
   
   [<A NAME="ordering_case_def-val"><B>ordering_case_def</B></A>]  Theorem
      
      |- (!v0 v1 v2.
            (case LESS of LESS -&gt; v0 || EQUAL -&gt; v1 || GREATER -&gt; v2) =
            v0) /\
         (!v0 v1 v2.
            (case EQUAL of LESS -&gt; v0 || EQUAL -&gt; v1 || GREATER -&gt; v2) =
            v1) /\
         !v0 v1 v2.
           (case GREATER of LESS -&gt; v0 || EQUAL -&gt; v1 || GREATER -&gt; v2) =
           v2
   
   [<A NAME="ordering_distinct-val"><B>ordering_distinct</B></A>]  Theorem
      
      |- LESS &lt;&gt; EQUAL /\ LESS &lt;&gt; GREATER /\ EQUAL &lt;&gt; GREATER
   
   [<A NAME="ordering_eq_dec-val"><B>ordering_eq_dec</B></A>]  Theorem
      
      |- (!x. (x = x) &lt;=&gt; T) /\ ((LESS = EQUAL) &lt;=&gt; F) /\
         ((LESS = GREATER) &lt;=&gt; F) /\ ((EQUAL = GREATER) &lt;=&gt; F) /\
         ((EQUAL = LESS) &lt;=&gt; F) /\ ((GREATER = LESS) &lt;=&gt; F) /\
         ((GREATER = EQUAL) &lt;=&gt; F)
   
   [<A NAME="ordering_induction-val"><B>ordering_induction</B></A>]  Theorem
      
      |- !P. P EQUAL /\ P GREATER /\ P LESS ==&gt; !a. P a
   
   [<A NAME="ordering_nchotomy-val"><B>ordering_nchotomy</B></A>]  Theorem
      
      |- !a. (a = LESS) \/ (a = EQUAL) \/ (a = GREATER)
   
   
*)
end

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/ring/src/prelimScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
