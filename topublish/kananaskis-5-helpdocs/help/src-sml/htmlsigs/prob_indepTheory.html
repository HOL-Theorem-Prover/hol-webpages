<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure prob_indepTheory</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure prob_indepTheory</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/prob/prob_indepScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>signature prob_indepTheory =
<A NAME="line2"></A>sig
<A NAME="line3"></A>  type thm = Thm.thm
<A NAME="line4"></A>  
<A NAME="line5"></A>  (*  Definitions  *)
<A NAME="line6"></A>    val <A HREF="#alg_cover_def-val">alg_cover_def</A> : thm
<A NAME="line7"></A>    val <A HREF="#alg_cover_set_def-val">alg_cover_set_def</A> : thm
<A NAME="line8"></A>    val <A HREF="#indep_def-val">indep_def</A> : thm
<A NAME="line9"></A>    val <A HREF="#indep_set_def-val">indep_set_def</A> : thm
<A NAME="line10"></A>  
<A NAME="line11"></A>  (*  Theorems  *)
<A NAME="line12"></A>    val <A HREF="#ALG_COVER_EXISTS_UNIQUE-val">ALG_COVER_EXISTS_UNIQUE</A> : thm
<A NAME="line13"></A>    val <A HREF="#ALG_COVER_HEAD-val">ALG_COVER_HEAD</A> : thm
<A NAME="line14"></A>    val <A HREF="#ALG_COVER_SET_BASIC-val">ALG_COVER_SET_BASIC</A> : thm
<A NAME="line15"></A>    val <A HREF="#ALG_COVER_SET_CASES-val">ALG_COVER_SET_CASES</A> : thm
<A NAME="line16"></A>    val <A HREF="#ALG_COVER_SET_CASES_THM-val">ALG_COVER_SET_CASES_THM</A> : thm
<A NAME="line17"></A>    val <A HREF="#ALG_COVER_SET_INDUCTION-val">ALG_COVER_SET_INDUCTION</A> : thm
<A NAME="line18"></A>    val <A HREF="#ALG_COVER_STEP-val">ALG_COVER_STEP</A> : thm
<A NAME="line19"></A>    val <A HREF="#ALG_COVER_TAIL_MEASURABLE-val">ALG_COVER_TAIL_MEASURABLE</A> : thm
<A NAME="line20"></A>    val <A HREF="#ALG_COVER_TAIL_PROB-val">ALG_COVER_TAIL_PROB</A> : thm
<A NAME="line21"></A>    val <A HREF="#ALG_COVER_TAIL_STEP-val">ALG_COVER_TAIL_STEP</A> : thm
<A NAME="line22"></A>    val <A HREF="#ALG_COVER_UNIQUE-val">ALG_COVER_UNIQUE</A> : thm
<A NAME="line23"></A>    val <A HREF="#ALG_COVER_UNIV-val">ALG_COVER_UNIV</A> : thm
<A NAME="line24"></A>    val <A HREF="#ALG_COVER_WELL_DEFINED-val">ALG_COVER_WELL_DEFINED</A> : thm
<A NAME="line25"></A>    val <A HREF="#BIND_STEP-val">BIND_STEP</A> : thm
<A NAME="line26"></A>    val <A HREF="#INDEP_BIND-val">INDEP_BIND</A> : thm
<A NAME="line27"></A>    val <A HREF="#INDEP_BIND_SDEST-val">INDEP_BIND_SDEST</A> : thm
<A NAME="line28"></A>    val <A HREF="#INDEP_INDEP_SET-val">INDEP_INDEP_SET</A> : thm
<A NAME="line29"></A>    val <A HREF="#INDEP_INDEP_SET_LEMMA-val">INDEP_INDEP_SET_LEMMA</A> : thm
<A NAME="line30"></A>    val <A HREF="#INDEP_MEASURABLE1-val">INDEP_MEASURABLE1</A> : thm
<A NAME="line31"></A>    val <A HREF="#INDEP_MEASURABLE2-val">INDEP_MEASURABLE2</A> : thm
<A NAME="line32"></A>    val <A HREF="#INDEP_PROB-val">INDEP_PROB</A> : thm
<A NAME="line33"></A>    val <A HREF="#INDEP_SDEST-val">INDEP_SDEST</A> : thm
<A NAME="line34"></A>    val <A HREF="#INDEP_SET_BASIC-val">INDEP_SET_BASIC</A> : thm
<A NAME="line35"></A>    val <A HREF="#INDEP_SET_DISJOINT_DECOMP-val">INDEP_SET_DISJOINT_DECOMP</A> : thm
<A NAME="line36"></A>    val <A HREF="#INDEP_SET_LIST-val">INDEP_SET_LIST</A> : thm
<A NAME="line37"></A>    val <A HREF="#INDEP_SET_SYM-val">INDEP_SET_SYM</A> : thm
<A NAME="line38"></A>    val <A HREF="#INDEP_UNIT-val">INDEP_UNIT</A> : thm
<A NAME="line39"></A>    val <A HREF="#MAP_CONS_TL_FILTER-val">MAP_CONS_TL_FILTER</A> : thm
<A NAME="line40"></A>    val <A HREF="#PROB_INDEP_BOUND-val">PROB_INDEP_BOUND</A> : thm
<A NAME="line41"></A>  
<A NAME="line42"></A>  val prob_indep_grammars : type_grammar.grammar * term_grammar.grammar
<A NAME="line43"></A>  
<A NAME="line44"></A>  
<A NAME="line45"></A>(*
   [prob] Parent theory of "prob_indep"
   
   [state_transformer] Parent theory of "prob_indep"
   
   [<A NAME="alg_cover_def-val"><B>alg_cover_def</B></A>]  Definition
      
      |- !l x. alg_cover l x = @b. MEM b l /\ alg_embed b x
   
   [<A NAME="alg_cover_set_def-val"><B>alg_cover_set_def</B></A>]  Definition
      
      |- !l.
           alg_cover_set l &lt;=&gt;
           alg_sorted l /\ alg_prefixfree l /\ (algebra_embed l = UNIV)
   
   [<A NAME="indep_def-val"><B>indep_def</B></A>]  Definition
      
      |- !f.
           indep f &lt;=&gt;
           ?l r.
             alg_cover_set l /\
             !s. f s = (let c = alg_cover l s in (r c,SDROP (LENGTH c) s))
   
   [<A NAME="indep_set_def-val"><B>indep_set_def</B></A>]  Definition
      
      |- !p q.
           indep_set p q &lt;=&gt;
           measurable p /\ measurable q /\
           (prob (p INTER q) = prob p * prob q)
   
   [<A NAME="ALG_COVER_EXISTS_UNIQUE-val"><B>ALG_COVER_EXISTS_UNIQUE</B></A>]  Theorem
      
      |- !l. alg_cover_set l ==&gt; !s. ?!x. MEM x l /\ alg_embed x s
   
   [<A NAME="ALG_COVER_HEAD-val"><B>ALG_COVER_HEAD</B></A>]  Theorem
      
      |- !l.
           alg_cover_set l ==&gt;
           !f. f o alg_cover l = algebra_embed (FILTER f l)
   
   [<A NAME="ALG_COVER_SET_BASIC-val"><B>ALG_COVER_SET_BASIC</B></A>]  Theorem
      
      |- ~alg_cover_set [] /\ alg_cover_set [[]] /\
         alg_cover_set [[T]; [F]]
   
   [<A NAME="ALG_COVER_SET_CASES-val"><B>ALG_COVER_SET_CASES</B></A>]  Theorem
      
      |- !P.
           P [[]] /\
           (!l1 l2.
              alg_cover_set l1 /\ alg_cover_set l2 /\
              alg_cover_set (MAP (CONS T) l1 ++ MAP (CONS F) l2) ==&gt;
              P (MAP (CONS T) l1 ++ MAP (CONS F) l2)) ==&gt;
           !l. alg_cover_set l ==&gt; P l
   
   [<A NAME="ALG_COVER_SET_CASES_THM-val"><B>ALG_COVER_SET_CASES_THM</B></A>]  Theorem
      
      |- !l.
           alg_cover_set l &lt;=&gt;
           (l = [[]]) \/
           ?l1 l2.
             alg_cover_set l1 /\ alg_cover_set l2 /\
             (l = MAP (CONS T) l1 ++ MAP (CONS F) l2)
   
   [<A NAME="ALG_COVER_SET_INDUCTION-val"><B>ALG_COVER_SET_INDUCTION</B></A>]  Theorem
      
      |- !P.
           P [[]] /\
           (!l1 l2.
              alg_cover_set l1 /\ alg_cover_set l2 /\ P l1 /\ P l2 /\
              alg_cover_set (MAP (CONS T) l1 ++ MAP (CONS F) l2) ==&gt;
              P (MAP (CONS T) l1 ++ MAP (CONS F) l2)) ==&gt;
           !l. alg_cover_set l ==&gt; P l
   
   [<A NAME="ALG_COVER_STEP-val"><B>ALG_COVER_STEP</B></A>]  Theorem
      
      |- !l1 l2 h t.
           alg_cover_set l1 /\ alg_cover_set l2 ==&gt;
           (alg_cover (MAP (CONS T) l1 ++ MAP (CONS F) l2) (SCONS h t) =
            if h then T::alg_cover l1 t else F::alg_cover l2 t)
   
   [<A NAME="ALG_COVER_TAIL_MEASURABLE-val"><B>ALG_COVER_TAIL_MEASURABLE</B></A>]  Theorem
      
      |- !l.
           alg_cover_set l ==&gt;
           !q.
             measurable (q o (\x. SDROP (LENGTH (alg_cover l x)) x)) &lt;=&gt;
             measurable q
   
   [<A NAME="ALG_COVER_TAIL_PROB-val"><B>ALG_COVER_TAIL_PROB</B></A>]  Theorem
      
      |- !l.
           alg_cover_set l ==&gt;
           !q.
             measurable q ==&gt;
             (prob (q o (\x. SDROP (LENGTH (alg_cover l x)) x)) = prob q)
   
   [<A NAME="ALG_COVER_TAIL_STEP-val"><B>ALG_COVER_TAIL_STEP</B></A>]  Theorem
      
      |- !l1 l2 q.
           alg_cover_set l1 /\ alg_cover_set l2 ==&gt;
           (q o
            (\x.
               SDROP
                 (LENGTH
                    (alg_cover (MAP (CONS T) l1 ++ MAP (CONS F) l2) x))
                 x) =
            (\x. SHD x &lt;=&gt; T) INTER
            q o (\x. SDROP (LENGTH (alg_cover l1 x)) x) o STL UNION
            (\x. SHD x &lt;=&gt; F) INTER
            q o (\x. SDROP (LENGTH (alg_cover l2 x)) x) o STL)
   
   [<A NAME="ALG_COVER_UNIQUE-val"><B>ALG_COVER_UNIQUE</B></A>]  Theorem
      
      |- !l x s.
           alg_cover_set l /\ MEM x l /\ alg_embed x s ==&gt;
           (alg_cover l s = x)
   
   [<A NAME="ALG_COVER_UNIV-val"><B>ALG_COVER_UNIV</B></A>]  Theorem
      
      |- alg_cover [[]] = K []
   
   [<A NAME="ALG_COVER_WELL_DEFINED-val"><B>ALG_COVER_WELL_DEFINED</B></A>]  Theorem
      
      |- !l x.
           alg_cover_set l ==&gt;
           MEM (alg_cover l x) l /\ alg_embed (alg_cover l x) x
   
   [<A NAME="BIND_STEP-val"><B>BIND_STEP</B></A>]  Theorem
      
      |- !f. BIND SDEST (\k. f o SCONS k) = f
   
   [<A NAME="INDEP_BIND-val"><B>INDEP_BIND</B></A>]  Theorem
      
      |- !f g. indep f /\ (!x. indep (g x)) ==&gt; indep (BIND f g)
   
   [<A NAME="INDEP_BIND_SDEST-val"><B>INDEP_BIND_SDEST</B></A>]  Theorem
      
      |- !f. (!x. indep (f x)) ==&gt; indep (BIND SDEST f)
   
   [<A NAME="INDEP_INDEP_SET-val"><B>INDEP_INDEP_SET</B></A>]  Theorem
      
      |- !f p q.
           indep f /\ measurable q ==&gt;
           indep_set (p o FST o f) (q o SND o f)
   
   [<A NAME="INDEP_INDEP_SET_LEMMA-val"><B>INDEP_INDEP_SET_LEMMA</B></A>]  Theorem
      
      |- !l.
           alg_cover_set l ==&gt;
           !q.
             measurable q ==&gt;
             !x.
               MEM x l ==&gt;
               (prob
                  (alg_embed x INTER
                   q o (\x. SDROP (LENGTH (alg_cover l x)) x)) =
                (1 / 2) pow LENGTH x * prob q)
   
   [<A NAME="INDEP_MEASURABLE1-val"><B>INDEP_MEASURABLE1</B></A>]  Theorem
      
      |- !f p. indep f ==&gt; measurable (p o FST o f)
   
   [<A NAME="INDEP_MEASURABLE2-val"><B>INDEP_MEASURABLE2</B></A>]  Theorem
      
      |- !f q. indep f /\ measurable q ==&gt; measurable (q o SND o f)
   
   [<A NAME="INDEP_PROB-val"><B>INDEP_PROB</B></A>]  Theorem
      
      |- !f p q.
           indep f /\ measurable q ==&gt;
           (prob (p o FST o f INTER q o SND o f) =
            prob (p o FST o f) * prob q)
   
   [<A NAME="INDEP_SDEST-val"><B>INDEP_SDEST</B></A>]  Theorem
      
      |- indep SDEST
   
   [<A NAME="INDEP_SET_BASIC-val"><B>INDEP_SET_BASIC</B></A>]  Theorem
      
      |- !p. measurable p ==&gt; indep_set {} p /\ indep_set UNIV p
   
   [<A NAME="INDEP_SET_DISJOINT_DECOMP-val"><B>INDEP_SET_DISJOINT_DECOMP</B></A>]  Theorem
      
      |- !p q r.
           indep_set p r /\ indep_set q r /\ (p INTER q = {}) ==&gt;
           indep_set (p UNION q) r
   
   [<A NAME="INDEP_SET_LIST-val"><B>INDEP_SET_LIST</B></A>]  Theorem
      
      |- !q l.
           alg_sorted l /\ alg_prefixfree l /\ measurable q /\
           (!x. MEM x l ==&gt; indep_set (alg_embed x) q) ==&gt;
           indep_set (algebra_embed l) q
   
   [<A NAME="INDEP_SET_SYM-val"><B>INDEP_SET_SYM</B></A>]  Theorem
      
      |- !p q. indep_set p q &lt;=&gt; indep_set p q
   
   [<A NAME="INDEP_UNIT-val"><B>INDEP_UNIT</B></A>]  Theorem
      
      |- !x. indep (UNIT x)
   
   [<A NAME="MAP_CONS_TL_FILTER-val"><B>MAP_CONS_TL_FILTER</B></A>]  Theorem
      
      |- !l b.
           ~MEM [] l ==&gt;
           (MAP (CONS b) (MAP TL (FILTER (\x. HD x &lt;=&gt; b) l)) =
            FILTER (\x. HD x &lt;=&gt; b) l)
   
   [<A NAME="PROB_INDEP_BOUND-val"><B>PROB_INDEP_BOUND</B></A>]  Theorem
      
      |- !f n.
           indep f ==&gt;
           (prob (\s. FST (f s) &lt; SUC n) =
            prob (\s. FST (f s) &lt; n) + prob (\s. FST (f s) = n))
   
   
*)
end

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/prob/prob_indepScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
