<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure prob_extraTheory</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure prob_extraTheory</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/prob/prob_extraScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>signature prob_extraTheory =
<A NAME="line2"></A>sig
<A NAME="line3"></A>  type thm = Thm.thm
<A NAME="line4"></A>  
<A NAME="line5"></A>  (*  Definitions  *)
<A NAME="line6"></A>    val <A HREF="#inf_def-val">inf_def</A> : thm
<A NAME="line7"></A>  
<A NAME="line8"></A>  (*  Theorems  *)
<A NAME="line9"></A>    val <A HREF="#ABS_BETWEEN_LE-val">ABS_BETWEEN_LE</A> : thm
<A NAME="line10"></A>    val <A HREF="#ABS_UNIT_INTERVAL-val">ABS_UNIT_INTERVAL</A> : thm
<A NAME="line11"></A>    val <A HREF="#APPEND_MEM-val">APPEND_MEM</A> : thm
<A NAME="line12"></A>    val <A HREF="#BOOL_BOOL_CASES-val">BOOL_BOOL_CASES</A> : thm
<A NAME="line13"></A>    val <A HREF="#BOOL_BOOL_CASES_THM-val">BOOL_BOOL_CASES_THM</A> : thm
<A NAME="line14"></A>    val <A HREF="#COMPL_CLAUSES-val">COMPL_CLAUSES</A> : thm
<A NAME="line15"></A>    val <A HREF="#COMPL_COMPL-val">COMPL_COMPL</A> : thm
<A NAME="line16"></A>    val <A HREF="#COMPL_SPLITS-val">COMPL_SPLITS</A> : thm
<A NAME="line17"></A>    val <A HREF="#DIVISION_TWO-val">DIVISION_TWO</A> : thm
<A NAME="line18"></A>    val <A HREF="#DIV_THEN_MULT-val">DIV_THEN_MULT</A> : thm
<A NAME="line19"></A>    val <A HREF="#DIV_TWO-val">DIV_TWO</A> : thm
<A NAME="line20"></A>    val <A HREF="#DIV_TWO_BASIC-val">DIV_TWO_BASIC</A> : thm
<A NAME="line21"></A>    val <A HREF="#DIV_TWO_CANCEL-val">DIV_TWO_CANCEL</A> : thm
<A NAME="line22"></A>    val <A HREF="#DIV_TWO_EXP-val">DIV_TWO_EXP</A> : thm
<A NAME="line23"></A>    val <A HREF="#DIV_TWO_MONO-val">DIV_TWO_MONO</A> : thm
<A NAME="line24"></A>    val <A HREF="#DIV_TWO_MONO_EVEN-val">DIV_TWO_MONO_EVEN</A> : thm
<A NAME="line25"></A>    val <A HREF="#DIV_TWO_UNIQUE-val">DIV_TWO_UNIQUE</A> : thm
<A NAME="line26"></A>    val <A HREF="#EQ_EXT_EQ-val">EQ_EXT_EQ</A> : thm
<A NAME="line27"></A>    val <A HREF="#EVEN_EXP_TWO-val">EVEN_EXP_TWO</A> : thm
<A NAME="line28"></A>    val <A HREF="#EVEN_ODD_BASIC-val">EVEN_ODD_BASIC</A> : thm
<A NAME="line29"></A>    val <A HREF="#EVEN_ODD_EXISTS_EQ-val">EVEN_ODD_EXISTS_EQ</A> : thm
<A NAME="line30"></A>    val <A HREF="#EXISTS_LONGEST-val">EXISTS_LONGEST</A> : thm
<A NAME="line31"></A>    val <A HREF="#EXP_DIV_TWO-val">EXP_DIV_TWO</A> : thm
<A NAME="line32"></A>    val <A HREF="#FILTER_FALSE-val">FILTER_FALSE</A> : thm
<A NAME="line33"></A>    val <A HREF="#FILTER_MEM-val">FILTER_MEM</A> : thm
<A NAME="line34"></A>    val <A HREF="#FILTER_OUT_ELT-val">FILTER_OUT_ELT</A> : thm
<A NAME="line35"></A>    val <A HREF="#FILTER_TRUE-val">FILTER_TRUE</A> : thm
<A NAME="line36"></A>    val <A HREF="#FOLDR_MAP-val">FOLDR_MAP</A> : thm
<A NAME="line37"></A>    val <A HREF="#GSPEC_DEF_ALT-val">GSPEC_DEF_ALT</A> : thm
<A NAME="line38"></A>    val <A HREF="#HALF_CANCEL-val">HALF_CANCEL</A> : thm
<A NAME="line39"></A>    val <A HREF="#HALF_LT_1-val">HALF_LT_1</A> : thm
<A NAME="line40"></A>    val <A HREF="#HALF_POS-val">HALF_POS</A> : thm
<A NAME="line41"></A>    val <A HREF="#INF_DEF_ALT-val">INF_DEF_ALT</A> : thm
<A NAME="line42"></A>    val <A HREF="#INTER_IS_EMPTY-val">INTER_IS_EMPTY</A> : thm
<A NAME="line43"></A>    val <A HREF="#INTER_UNION_COMPL-val">INTER_UNION_COMPL</A> : thm
<A NAME="line44"></A>    val <A HREF="#INTER_UNION_RDISTRIB-val">INTER_UNION_RDISTRIB</A> : thm
<A NAME="line45"></A>    val <A HREF="#INV_SUC-val">INV_SUC</A> : thm
<A NAME="line46"></A>    val <A HREF="#INV_SUC_MAX-val">INV_SUC_MAX</A> : thm
<A NAME="line47"></A>    val <A HREF="#INV_SUC_POS-val">INV_SUC_POS</A> : thm
<A NAME="line48"></A>    val <A HREF="#IN_COMPL-val">IN_COMPL</A> : thm
<A NAME="line49"></A>    val <A HREF="#IN_EMPTY-val">IN_EMPTY</A> : thm
<A NAME="line50"></A>    val <A HREF="#IS_PREFIX_ANTISYM-val">IS_PREFIX_ANTISYM</A> : thm
<A NAME="line51"></A>    val <A HREF="#IS_PREFIX_BUTLAST-val">IS_PREFIX_BUTLAST</A> : thm
<A NAME="line52"></A>    val <A HREF="#IS_PREFIX_LENGTH-val">IS_PREFIX_LENGTH</A> : thm
<A NAME="line53"></A>    val <A HREF="#IS_PREFIX_LENGTH_ANTI-val">IS_PREFIX_LENGTH_ANTI</A> : thm
<A NAME="line54"></A>    val <A HREF="#IS_PREFIX_NIL-val">IS_PREFIX_NIL</A> : thm
<A NAME="line55"></A>    val <A HREF="#IS_PREFIX_REFL-val">IS_PREFIX_REFL</A> : thm
<A NAME="line56"></A>    val <A HREF="#IS_PREFIX_SNOC-val">IS_PREFIX_SNOC</A> : thm
<A NAME="line57"></A>    val <A HREF="#IS_PREFIX_TRANS-val">IS_PREFIX_TRANS</A> : thm
<A NAME="line58"></A>    val <A HREF="#LAST_MAP_CONS-val">LAST_MAP_CONS</A> : thm
<A NAME="line59"></A>    val <A HREF="#LAST_MEM-val">LAST_MEM</A> : thm
<A NAME="line60"></A>    val <A HREF="#LENGTH_FILTER-val">LENGTH_FILTER</A> : thm
<A NAME="line61"></A>    val <A HREF="#MAP_ID-val">MAP_ID</A> : thm
<A NAME="line62"></A>    val <A HREF="#MAP_MEM-val">MAP_MEM</A> : thm
<A NAME="line63"></A>    val <A HREF="#MEM_FILTER-val">MEM_FILTER</A> : thm
<A NAME="line64"></A>    val <A HREF="#MEM_NIL-val">MEM_NIL</A> : thm
<A NAME="line65"></A>    val <A HREF="#MEM_NIL_MAP_CONS-val">MEM_NIL_MAP_CONS</A> : thm
<A NAME="line66"></A>    val <A HREF="#MOD_TWO-val">MOD_TWO</A> : thm
<A NAME="line67"></A>    val <A HREF="#ONE_MINUS_HALF-val">ONE_MINUS_HALF</A> : thm
<A NAME="line68"></A>    val <A HREF="#POW_HALF_EXP-val">POW_HALF_EXP</A> : thm
<A NAME="line69"></A>    val <A HREF="#POW_HALF_MONO-val">POW_HALF_MONO</A> : thm
<A NAME="line70"></A>    val <A HREF="#POW_HALF_POS-val">POW_HALF_POS</A> : thm
<A NAME="line71"></A>    val <A HREF="#POW_HALF_TWICE-val">POW_HALF_TWICE</A> : thm
<A NAME="line72"></A>    val <A HREF="#RAND_THM-val">RAND_THM</A> : thm
<A NAME="line73"></A>    val <A HREF="#REAL_INF_MIN-val">REAL_INF_MIN</A> : thm
<A NAME="line74"></A>    val <A HREF="#REAL_INVINV_ALL-val">REAL_INVINV_ALL</A> : thm
<A NAME="line75"></A>    val <A HREF="#REAL_LE_EQ-val">REAL_LE_EQ</A> : thm
<A NAME="line76"></A>    val <A HREF="#REAL_LE_INV_LE-val">REAL_LE_INV_LE</A> : thm
<A NAME="line77"></A>    val <A HREF="#REAL_POW-val">REAL_POW</A> : thm
<A NAME="line78"></A>    val <A HREF="#REAL_SUP_EXISTS_UNIQUE-val">REAL_SUP_EXISTS_UNIQUE</A> : thm
<A NAME="line79"></A>    val <A HREF="#REAL_SUP_LE_X-val">REAL_SUP_LE_X</A> : thm
<A NAME="line80"></A>    val <A HREF="#REAL_SUP_MAX-val">REAL_SUP_MAX</A> : thm
<A NAME="line81"></A>    val <A HREF="#REAL_X_LE_SUP-val">REAL_X_LE_SUP</A> : thm
<A NAME="line82"></A>    val <A HREF="#SET_EQ_EXT-val">SET_EQ_EXT</A> : thm
<A NAME="line83"></A>    val <A HREF="#SUBSET_EQ-val">SUBSET_EQ</A> : thm
<A NAME="line84"></A>    val <A HREF="#SUBSET_EQ_DECOMP-val">SUBSET_EQ_DECOMP</A> : thm
<A NAME="line85"></A>    val <A HREF="#UNION_DEF_ALT-val">UNION_DEF_ALT</A> : thm
<A NAME="line86"></A>    val <A HREF="#UNION_DISJOINT_SPLIT-val">UNION_DISJOINT_SPLIT</A> : thm
<A NAME="line87"></A>    val <A HREF="#X_HALF_HALF-val">X_HALF_HALF</A> : thm
<A NAME="line88"></A>  
<A NAME="line89"></A>  val prob_extra_grammars : type_grammar.grammar * term_grammar.grammar
<A NAME="line90"></A>  
<A NAME="line91"></A>  
<A NAME="line92"></A>(*
   [poly] Parent theory of "prob_extra"
   
   [transc] Parent theory of "prob_extra"
   
   [<A NAME="inf_def-val"><B>inf_def</B></A>]  Definition
      
      |- !P. inf P = -sup (IMAGE numeric_negate P)
   
   [<A NAME="ABS_BETWEEN_LE-val"><B>ABS_BETWEEN_LE</B></A>]  Theorem
      
      |- !x y d. 0 &lt;= d /\ x - d &lt;= y /\ y &lt;= x + d &lt;=&gt; abs (y - x) &lt;= d
   
   [<A NAME="ABS_UNIT_INTERVAL-val"><B>ABS_UNIT_INTERVAL</B></A>]  Theorem
      
      |- !x y. 0 &lt;= x /\ x &lt;= 1 /\ 0 &lt;= y /\ y &lt;= 1 ==&gt; abs (x - y) &lt;= 1
   
   [<A NAME="APPEND_MEM-val"><B>APPEND_MEM</B></A>]  Theorem
      
      |- !x l1 l2. MEM x (l1 ++ l2) &lt;=&gt; MEM x l1 \/ MEM x l2
   
   [<A NAME="BOOL_BOOL_CASES-val"><B>BOOL_BOOL_CASES</B></A>]  Theorem
      
      |- !P. P (\b. F) /\ P (\b. T) /\ P (\b. b) /\ P (\b. ~b) ==&gt; !f. P f
   
   [<A NAME="BOOL_BOOL_CASES_THM-val"><B>BOOL_BOOL_CASES_THM</B></A>]  Theorem
      
      |- !f.
           (f = (\b. F)) \/ (f = (\b. T)) \/ (f = (\b. b)) \/
           (f = (\b. ~b))
   
   [<A NAME="COMPL_CLAUSES-val"><B>COMPL_CLAUSES</B></A>]  Theorem
      
      |- !s. (COMPL s INTER s = {}) /\ (COMPL s UNION s = UNIV)
   
   [<A NAME="COMPL_COMPL-val"><B>COMPL_COMPL</B></A>]  Theorem
      
      |- !s. COMPL (COMPL s) = s
   
   [<A NAME="COMPL_SPLITS-val"><B>COMPL_SPLITS</B></A>]  Theorem
      
      |- !p q. p INTER q UNION COMPL p INTER q = q
   
   [<A NAME="DIVISION_TWO-val"><B>DIVISION_TWO</B></A>]  Theorem
      
      |- !n.
           (n = 2 * (n DIV 2) + n MOD 2) /\
           ((n MOD 2 = 0) \/ (n MOD 2 = 1))
   
   [<A NAME="DIV_THEN_MULT-val"><B>DIV_THEN_MULT</B></A>]  Theorem
      
      |- !p q. SUC q * (p DIV SUC q) &lt;= p
   
   [<A NAME="DIV_TWO-val"><B>DIV_TWO</B></A>]  Theorem
      
      |- !n. n = 2 * (n DIV 2) + n MOD 2
   
   [<A NAME="DIV_TWO_BASIC-val"><B>DIV_TWO_BASIC</B></A>]  Theorem
      
      |- (0 DIV 2 = 0) /\ (1 DIV 2 = 0) /\ (2 DIV 2 = 1)
   
   [<A NAME="DIV_TWO_CANCEL-val"><B>DIV_TWO_CANCEL</B></A>]  Theorem
      
      |- !n. (2 * n DIV 2 = n) /\ (SUC (2 * n) DIV 2 = n)
   
   [<A NAME="DIV_TWO_EXP-val"><B>DIV_TWO_EXP</B></A>]  Theorem
      
      |- !n k. k DIV 2 &lt; 2 ** n &lt;=&gt; k &lt; 2 ** SUC n
   
   [<A NAME="DIV_TWO_MONO-val"><B>DIV_TWO_MONO</B></A>]  Theorem
      
      |- !m n. m DIV 2 &lt; n DIV 2 ==&gt; m &lt; n
   
   [<A NAME="DIV_TWO_MONO_EVEN-val"><B>DIV_TWO_MONO_EVEN</B></A>]  Theorem
      
      |- !m n. EVEN n ==&gt; (m DIV 2 &lt; n DIV 2 &lt;=&gt; m &lt; n)
   
   [<A NAME="DIV_TWO_UNIQUE-val"><B>DIV_TWO_UNIQUE</B></A>]  Theorem
      
      |- !n q r.
           (n = 2 * q + r) /\ ((r = 0) \/ (r = 1)) ==&gt;
           (q = n DIV 2) /\ (r = n MOD 2)
   
   [<A NAME="EQ_EXT_EQ-val"><B>EQ_EXT_EQ</B></A>]  Theorem
      
      |- !f g. (!x. f x = g x) &lt;=&gt; (f = g)
   
   [<A NAME="EVEN_EXP_TWO-val"><B>EVEN_EXP_TWO</B></A>]  Theorem
      
      |- !n. EVEN (2 ** n) &lt;=&gt; n &lt;&gt; 0
   
   [<A NAME="EVEN_ODD_BASIC-val"><B>EVEN_ODD_BASIC</B></A>]  Theorem
      
      |- EVEN 0 /\ ~EVEN 1 /\ EVEN 2 /\ ~ODD 0 /\ ODD 1 /\ ~ODD 2
   
   [<A NAME="EVEN_ODD_EXISTS_EQ-val"><B>EVEN_ODD_EXISTS_EQ</B></A>]  Theorem
      
      |- !n. (EVEN n &lt;=&gt; ?m. n = 2 * m) /\ (ODD n &lt;=&gt; ?m. n = SUC (2 * m))
   
   [<A NAME="EXISTS_LONGEST-val"><B>EXISTS_LONGEST</B></A>]  Theorem
      
      |- !x y.
           ?z. MEM z (x::y) /\ !w. MEM w (x::y) ==&gt; LENGTH w &lt;= LENGTH z
   
   [<A NAME="EXP_DIV_TWO-val"><B>EXP_DIV_TWO</B></A>]  Theorem
      
      |- !n. 2 ** SUC n DIV 2 = 2 ** n
   
   [<A NAME="FILTER_FALSE-val"><B>FILTER_FALSE</B></A>]  Theorem
      
      |- !l. FILTER (\x. F) l = []
   
   [<A NAME="FILTER_MEM-val"><B>FILTER_MEM</B></A>]  Theorem
      
      |- !P x l. MEM x (FILTER P l) ==&gt; P x
   
   [<A NAME="FILTER_OUT_ELT-val"><B>FILTER_OUT_ELT</B></A>]  Theorem
      
      |- !x l. MEM x l \/ (FILTER (\y. y &lt;&gt; x) l = l)
   
   [<A NAME="FILTER_TRUE-val"><B>FILTER_TRUE</B></A>]  Theorem
      
      |- !l. FILTER (\x. T) l = l
   
   [<A NAME="FOLDR_MAP-val"><B>FOLDR_MAP</B></A>]  Theorem
      
      |- !f e g l. FOLDR f e (MAP g l) = FOLDR (\x y. f (g x) y) e l
   
   [<A NAME="GSPEC_DEF_ALT-val"><B>GSPEC_DEF_ALT</B></A>]  Theorem
      
      |- !f. GSPEC f = (\v. ?x. (v,T) = f x)
   
   [<A NAME="HALF_CANCEL-val"><B>HALF_CANCEL</B></A>]  Theorem
      
      |- 2 * (1 / 2) = 1
   
   [<A NAME="HALF_LT_1-val"><B>HALF_LT_1</B></A>]  Theorem
      
      |- 1 / 2 &lt; 1
   
   [<A NAME="HALF_POS-val"><B>HALF_POS</B></A>]  Theorem
      
      |- 0 &lt; 1 / 2
   
   [<A NAME="INF_DEF_ALT-val"><B>INF_DEF_ALT</B></A>]  Theorem
      
      |- !P. inf P = -sup (\r. P (-r))
   
   [<A NAME="INTER_IS_EMPTY-val"><B>INTER_IS_EMPTY</B></A>]  Theorem
      
      |- !s t. (s INTER t = {}) &lt;=&gt; !x. ~s x \/ ~t x
   
   [<A NAME="INTER_UNION_COMPL-val"><B>INTER_UNION_COMPL</B></A>]  Theorem
      
      |- !s t. s INTER t = COMPL (COMPL s UNION COMPL t)
   
   [<A NAME="INTER_UNION_RDISTRIB-val"><B>INTER_UNION_RDISTRIB</B></A>]  Theorem
      
      |- !p q r. (p UNION q) INTER r = p INTER r UNION q INTER r
   
   [<A NAME="INV_SUC-val"><B>INV_SUC</B></A>]  Theorem
      
      |- !n. 0 &lt; 1 / &SUC n /\ 1 / &SUC n &lt;= 1
   
   [<A NAME="INV_SUC_MAX-val"><B>INV_SUC_MAX</B></A>]  Theorem
      
      |- !n. 1 / &SUC n &lt;= 1
   
   [<A NAME="INV_SUC_POS-val"><B>INV_SUC_POS</B></A>]  Theorem
      
      |- !n. 0 &lt; 1 / &SUC n
   
   [<A NAME="IN_COMPL-val"><B>IN_COMPL</B></A>]  Theorem
      
      |- !x s. x IN COMPL s &lt;=&gt; x NOTIN s
   
   [<A NAME="IN_EMPTY-val"><B>IN_EMPTY</B></A>]  Theorem
      
      |- !x. x NOTIN {}
   
   [<A NAME="IS_PREFIX_ANTISYM-val"><B>IS_PREFIX_ANTISYM</B></A>]  Theorem
      
      |- !x y. x &lt;&lt;= y /\ y &lt;&lt;= x ==&gt; (x = y)
   
   [<A NAME="IS_PREFIX_BUTLAST-val"><B>IS_PREFIX_BUTLAST</B></A>]  Theorem
      
      |- !x y. FRONT (x::y) &lt;&lt;= x::y
   
   [<A NAME="IS_PREFIX_LENGTH-val"><B>IS_PREFIX_LENGTH</B></A>]  Theorem
      
      |- !x y. x &lt;&lt;= y ==&gt; LENGTH x &lt;= LENGTH y
   
   [<A NAME="IS_PREFIX_LENGTH_ANTI-val"><B>IS_PREFIX_LENGTH_ANTI</B></A>]  Theorem
      
      |- !x y. x &lt;&lt;= y /\ (LENGTH x = LENGTH y) ==&gt; (x = y)
   
   [<A NAME="IS_PREFIX_NIL-val"><B>IS_PREFIX_NIL</B></A>]  Theorem
      
      |- !x. [] &lt;&lt;= x /\ (x &lt;&lt;= [] &lt;=&gt; (x = []))
   
   [<A NAME="IS_PREFIX_REFL-val"><B>IS_PREFIX_REFL</B></A>]  Theorem
      
      |- !x. x &lt;&lt;= x
   
   [<A NAME="IS_PREFIX_SNOC-val"><B>IS_PREFIX_SNOC</B></A>]  Theorem
      
      |- !x y z. z &lt;&lt;= SNOC x y &lt;=&gt; z &lt;&lt;= y \/ (z = SNOC x y)
   
   [<A NAME="IS_PREFIX_TRANS-val"><B>IS_PREFIX_TRANS</B></A>]  Theorem
      
      |- !x y z. y &lt;&lt;= x /\ z &lt;&lt;= y ==&gt; z &lt;&lt;= x
   
   [<A NAME="LAST_MAP_CONS-val"><B>LAST_MAP_CONS</B></A>]  Theorem
      
      |- !b h t. ?x. LAST (MAP (CONS b) (h::t)) = b::x
   
   [<A NAME="LAST_MEM-val"><B>LAST_MEM</B></A>]  Theorem
      
      |- !h t. MEM (LAST (h::t)) (h::t)
   
   [<A NAME="LENGTH_FILTER-val"><B>LENGTH_FILTER</B></A>]  Theorem
      
      |- !P l. LENGTH (FILTER P l) &lt;= LENGTH l
   
   [<A NAME="MAP_ID-val"><B>MAP_ID</B></A>]  Theorem
      
      |- !l. MAP (\x. x) l = l
   
   [<A NAME="MAP_MEM-val"><B>MAP_MEM</B></A>]  Theorem
      
      |- !f l x. MEM x (MAP f l) &lt;=&gt; ?y. MEM y l /\ (x = f y)
   
   [<A NAME="MEM_FILTER-val"><B>MEM_FILTER</B></A>]  Theorem
      
      |- !P l x. MEM x (FILTER P l) ==&gt; MEM x l
   
   [<A NAME="MEM_NIL-val"><B>MEM_NIL</B></A>]  Theorem
      
      |- !l. (!x. ~MEM x l) &lt;=&gt; (l = [])
   
   [<A NAME="MEM_NIL_MAP_CONS-val"><B>MEM_NIL_MAP_CONS</B></A>]  Theorem
      
      |- !x l. ~MEM [] (MAP (CONS x) l)
   
   [<A NAME="MOD_TWO-val"><B>MOD_TWO</B></A>]  Theorem
      
      |- !n. n MOD 2 = if EVEN n then 0 else 1
   
   [<A NAME="ONE_MINUS_HALF-val"><B>ONE_MINUS_HALF</B></A>]  Theorem
      
      |- 1 - 1 / 2 = 1 / 2
   
   [<A NAME="POW_HALF_EXP-val"><B>POW_HALF_EXP</B></A>]  Theorem
      
      |- !n. (1 / 2) pow n = inv (&(2 ** n))
   
   [<A NAME="POW_HALF_MONO-val"><B>POW_HALF_MONO</B></A>]  Theorem
      
      |- !m n. m &lt;= n ==&gt; (1 / 2) pow n &lt;= (1 / 2) pow m
   
   [<A NAME="POW_HALF_POS-val"><B>POW_HALF_POS</B></A>]  Theorem
      
      |- !n. 0 &lt; (1 / 2) pow n
   
   [<A NAME="POW_HALF_TWICE-val"><B>POW_HALF_TWICE</B></A>]  Theorem
      
      |- !n. (1 / 2) pow n = 2 * (1 / 2) pow SUC n
   
   [<A NAME="RAND_THM-val"><B>RAND_THM</B></A>]  Theorem
      
      |- !f x y. (x = y) ==&gt; (f x = f y)
   
   [<A NAME="REAL_INF_MIN-val"><B>REAL_INF_MIN</B></A>]  Theorem
      
      |- !P z. P z /\ (!x. P x ==&gt; z &lt;= x) ==&gt; (inf P = z)
   
   [<A NAME="REAL_INVINV_ALL-val"><B>REAL_INVINV_ALL</B></A>]  Theorem
      
      |- !x. inv (inv x) = x
   
   [<A NAME="REAL_LE_EQ-val"><B>REAL_LE_EQ</B></A>]  Theorem
      
      |- !x y. x &lt;= y /\ y &lt;= x ==&gt; (x = y)
   
   [<A NAME="REAL_LE_INV_LE-val"><B>REAL_LE_INV_LE</B></A>]  Theorem
      
      |- !x y. 0 &lt; x /\ x &lt;= y ==&gt; inv y &lt;= inv x
   
   [<A NAME="REAL_POW-val"><B>REAL_POW</B></A>]  Theorem
      
      |- !m n. &m pow n = &(m ** n)
   
   [<A NAME="REAL_SUP_EXISTS_UNIQUE-val"><B>REAL_SUP_EXISTS_UNIQUE</B></A>]  Theorem
      
      |- !P.
           (?x. P x) /\ (?z. !x. P x ==&gt; x &lt;= z) ==&gt;
           ?!s. !y. (?x. P x /\ y &lt; x) &lt;=&gt; y &lt; s
   
   [<A NAME="REAL_SUP_LE_X-val"><B>REAL_SUP_LE_X</B></A>]  Theorem
      
      |- !P x. (?r. P r) /\ (!r. P r ==&gt; r &lt;= x) ==&gt; sup P &lt;= x
   
   [<A NAME="REAL_SUP_MAX-val"><B>REAL_SUP_MAX</B></A>]  Theorem
      
      |- !P z. P z /\ (!x. P x ==&gt; x &lt;= z) ==&gt; (sup P = z)
   
   [<A NAME="REAL_X_LE_SUP-val"><B>REAL_X_LE_SUP</B></A>]  Theorem
      
      |- !P x.
           (?r. P r) /\ (?z. !r. P r ==&gt; r &lt;= z) /\ (?r. P r /\ x &lt;= r) ==&gt;
           x &lt;= sup P
   
   [<A NAME="SET_EQ_EXT-val"><B>SET_EQ_EXT</B></A>]  Theorem
      
      |- !s t. (s = t) &lt;=&gt; !v. v IN s &lt;=&gt; v IN t
   
   [<A NAME="SUBSET_EQ-val"><B>SUBSET_EQ</B></A>]  Theorem
      
      |- !s t. (s = t) &lt;=&gt; s SUBSET t /\ t SUBSET s
   
   [<A NAME="SUBSET_EQ_DECOMP-val"><B>SUBSET_EQ_DECOMP</B></A>]  Theorem
      
      |- !s t. s SUBSET t /\ t SUBSET s ==&gt; (s = t)
   
   [<A NAME="UNION_DEF_ALT-val"><B>UNION_DEF_ALT</B></A>]  Theorem
      
      |- !s t. s UNION t = (\x. s x \/ t x)
   
   [<A NAME="UNION_DISJOINT_SPLIT-val"><B>UNION_DISJOINT_SPLIT</B></A>]  Theorem
      
      |- !s t u.
           (s UNION t = s UNION u) /\ (s INTER t = {}) /\
           (s INTER u = {}) ==&gt;
           (t = u)
   
   [<A NAME="X_HALF_HALF-val"><B>X_HALF_HALF</B></A>]  Theorem
      
      |- !x. 1 / 2 * x + 1 / 2 * x = x
   
   
*)
end

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/prob/prob_extraScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
