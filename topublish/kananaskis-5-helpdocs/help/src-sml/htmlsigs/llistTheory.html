<HTML><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Structure llistTheory</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure llistTheory</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/llist/llistScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>signature llistTheory =
<A NAME="line2"></A>sig
<A NAME="line3"></A>  type thm = Thm.thm
<A NAME="line4"></A>  
<A NAME="line5"></A>  (*  Definitions  *)
<A NAME="line6"></A>    val <A HREF="#LAPPEND-val">LAPPEND</A> : thm
<A NAME="line7"></A>    val <A HREF="#LCONS-val">LCONS</A> : thm
<A NAME="line8"></A>    val <A HREF="#LDROP-val">LDROP</A> : thm
<A NAME="line9"></A>    val <A HREF="#LFILTER-val">LFILTER</A> : thm
<A NAME="line10"></A>    val <A HREF="#LFLATTEN-val">LFLATTEN</A> : thm
<A NAME="line11"></A>    val <A HREF="#LHD-val">LHD</A> : thm
<A NAME="line12"></A>    val <A HREF="#LLENGTH-val">LLENGTH</A> : thm
<A NAME="line13"></A>    val <A HREF="#LMAP-val">LMAP</A> : thm
<A NAME="line14"></A>    val <A HREF="#LNIL-val">LNIL</A> : thm
<A NAME="line15"></A>    val <A HREF="#LNTH-val">LNTH</A> : thm
<A NAME="line16"></A>    val <A HREF="#LTAKE-val">LTAKE</A> : thm
<A NAME="line17"></A>    val <A HREF="#LTL-val">LTL</A> : thm
<A NAME="line18"></A>    val <A HREF="#LUNFOLD-val">LUNFOLD</A> : thm
<A NAME="line19"></A>    val <A HREF="#LUNZIP_THM-val">LUNZIP_THM</A> : thm
<A NAME="line20"></A>    val <A HREF="#LZIP_THM-val">LZIP_THM</A> : thm
<A NAME="line21"></A>    val <A HREF="#every_def-val">every_def</A> : thm
<A NAME="line22"></A>    val <A HREF="#exists-val">exists</A> : thm
<A NAME="line23"></A>    val <A HREF="#fromList-val">fromList</A> : thm
<A NAME="line24"></A>    val <A HREF="#llength_rel-val">llength_rel</A> : thm
<A NAME="line25"></A>    val <A HREF="#llist_TY_DEF-val">llist_TY_DEF</A> : thm
<A NAME="line26"></A>    val <A HREF="#llist_absrep-val">llist_absrep</A> : thm
<A NAME="line27"></A>    val <A HREF="#lrep_ok_def-val">lrep_ok_def</A> : thm
<A NAME="line28"></A>    val <A HREF="#toList-val">toList</A> : thm
<A NAME="line29"></A>  
<A NAME="line30"></A>  (*  Theorems  *)
<A NAME="line31"></A>    val <A HREF="#LAPPEND_ASSOC-val">LAPPEND_ASSOC</A> : thm
<A NAME="line32"></A>    val <A HREF="#LAPPEND_EQ_LNIL-val">LAPPEND_EQ_LNIL</A> : thm
<A NAME="line33"></A>    val <A HREF="#LAPPEND_NIL_2ND-val">LAPPEND_NIL_2ND</A> : thm
<A NAME="line34"></A>    val <A HREF="#LCONS_11-val">LCONS_11</A> : thm
<A NAME="line35"></A>    val <A HREF="#LCONS_NOT_NIL-val">LCONS_NOT_NIL</A> : thm
<A NAME="line36"></A>    val <A HREF="#LDROP1_THM-val">LDROP1_THM</A> : thm
<A NAME="line37"></A>    val <A HREF="#LDROP_THM-val">LDROP_THM</A> : thm
<A NAME="line38"></A>    val <A HREF="#LFILTER_APPEND-val">LFILTER_APPEND</A> : thm
<A NAME="line39"></A>    val <A HREF="#LFILTER_EQ_NIL-val">LFILTER_EQ_NIL</A> : thm
<A NAME="line40"></A>    val <A HREF="#LFILTER_NIL-val">LFILTER_NIL</A> : thm
<A NAME="line41"></A>    val <A HREF="#LFILTER_THM-val">LFILTER_THM</A> : thm
<A NAME="line42"></A>    val <A HREF="#LFINITE-val">LFINITE</A> : thm
<A NAME="line43"></A>    val <A HREF="#LFINITE_APPEND-val">LFINITE_APPEND</A> : thm
<A NAME="line44"></A>    val <A HREF="#LFINITE_DROP-val">LFINITE_DROP</A> : thm
<A NAME="line45"></A>    val <A HREF="#LFINITE_HAS_LENGTH-val">LFINITE_HAS_LENGTH</A> : thm
<A NAME="line46"></A>    val <A HREF="#LFINITE_INDUCTION-val">LFINITE_INDUCTION</A> : thm
<A NAME="line47"></A>    val <A HREF="#LFINITE_MAP-val">LFINITE_MAP</A> : thm
<A NAME="line48"></A>    val <A HREF="#LFINITE_STRONG_INDUCTION-val">LFINITE_STRONG_INDUCTION</A> : thm
<A NAME="line49"></A>    val <A HREF="#LFINITE_TAKE-val">LFINITE_TAKE</A> : thm
<A NAME="line50"></A>    val <A HREF="#LFINITE_THM-val">LFINITE_THM</A> : thm
<A NAME="line51"></A>    val <A HREF="#LFINITE_cases-val">LFINITE_cases</A> : thm
<A NAME="line52"></A>    val <A HREF="#LFINITE_fromList-val">LFINITE_fromList</A> : thm
<A NAME="line53"></A>    val <A HREF="#LFINITE_ind-val">LFINITE_ind</A> : thm
<A NAME="line54"></A>    val <A HREF="#LFINITE_rules-val">LFINITE_rules</A> : thm
<A NAME="line55"></A>    val <A HREF="#LFINITE_toList-val">LFINITE_toList</A> : thm
<A NAME="line56"></A>    val <A HREF="#LFLATTEN_APPEND-val">LFLATTEN_APPEND</A> : thm
<A NAME="line57"></A>    val <A HREF="#LFLATTEN_EQ_NIL-val">LFLATTEN_EQ_NIL</A> : thm
<A NAME="line58"></A>    val <A HREF="#LFLATTEN_SINGLETON-val">LFLATTEN_SINGLETON</A> : thm
<A NAME="line59"></A>    val <A HREF="#LFLATTEN_THM-val">LFLATTEN_THM</A> : thm
<A NAME="line60"></A>    val <A HREF="#LHDTL_CONS_THM-val">LHDTL_CONS_THM</A> : thm
<A NAME="line61"></A>    val <A HREF="#LHDTL_EQ_SOME-val">LHDTL_EQ_SOME</A> : thm
<A NAME="line62"></A>    val <A HREF="#LHD_EQ_NONE-val">LHD_EQ_NONE</A> : thm
<A NAME="line63"></A>    val <A HREF="#LHD_LCONS-val">LHD_LCONS</A> : thm
<A NAME="line64"></A>    val <A HREF="#LHD_THM-val">LHD_THM</A> : thm
<A NAME="line65"></A>    val <A HREF="#LLENGTH_APPEND-val">LLENGTH_APPEND</A> : thm
<A NAME="line66"></A>    val <A HREF="#LLENGTH_MAP-val">LLENGTH_MAP</A> : thm
<A NAME="line67"></A>    val <A HREF="#LLENGTH_THM-val">LLENGTH_THM</A> : thm
<A NAME="line68"></A>    val <A HREF="#LLENGTH_fromList-val">LLENGTH_fromList</A> : thm
<A NAME="line69"></A>    val <A HREF="#LLIST_BISIMULATION-val">LLIST_BISIMULATION</A> : thm
<A NAME="line70"></A>    val <A HREF="#LLIST_BISIMULATION0-val">LLIST_BISIMULATION0</A> : thm
<A NAME="line71"></A>    val <A HREF="#LLIST_STRONG_BISIMULATION-val">LLIST_STRONG_BISIMULATION</A> : thm
<A NAME="line72"></A>    val <A HREF="#LL_ALL_THM-val">LL_ALL_THM</A> : thm
<A NAME="line73"></A>    val <A HREF="#LMAP_APPEND-val">LMAP_APPEND</A> : thm
<A NAME="line74"></A>    val <A HREF="#LMAP_MAP-val">LMAP_MAP</A> : thm
<A NAME="line75"></A>    val <A HREF="#LNTH_EQ-val">LNTH_EQ</A> : thm
<A NAME="line76"></A>    val <A HREF="#LNTH_THM-val">LNTH_THM</A> : thm
<A NAME="line77"></A>    val <A HREF="#LTAKE_CONS_EQ_NONE-val">LTAKE_CONS_EQ_NONE</A> : thm
<A NAME="line78"></A>    val <A HREF="#LTAKE_CONS_EQ_SOME-val">LTAKE_CONS_EQ_SOME</A> : thm
<A NAME="line79"></A>    val <A HREF="#LTAKE_DROP-val">LTAKE_DROP</A> : thm
<A NAME="line80"></A>    val <A HREF="#LTAKE_EQ-val">LTAKE_EQ</A> : thm
<A NAME="line81"></A>    val <A HREF="#LTAKE_EQ_SOME_CONS-val">LTAKE_EQ_SOME_CONS</A> : thm
<A NAME="line82"></A>    val <A HREF="#LTAKE_LNTH-val">LTAKE_LNTH</A> : thm
<A NAME="line83"></A>    val <A HREF="#LTAKE_NIL_EQ_NONE-val">LTAKE_NIL_EQ_NONE</A> : thm
<A NAME="line84"></A>    val <A HREF="#LTAKE_NIL_EQ_SOME-val">LTAKE_NIL_EQ_SOME</A> : thm
<A NAME="line85"></A>    val <A HREF="#LTAKE_SNOC_LNTH-val">LTAKE_SNOC_LNTH</A> : thm
<A NAME="line86"></A>    val <A HREF="#LTAKE_THM-val">LTAKE_THM</A> : thm
<A NAME="line87"></A>    val <A HREF="#LTAKE_fromList-val">LTAKE_fromList</A> : thm
<A NAME="line88"></A>    val <A HREF="#LTL_EQ_NONE-val">LTL_EQ_NONE</A> : thm
<A NAME="line89"></A>    val <A HREF="#LTL_LCONS-val">LTL_LCONS</A> : thm
<A NAME="line90"></A>    val <A HREF="#LTL_THM-val">LTL_THM</A> : thm
<A NAME="line91"></A>    val <A HREF="#LZIP_LUNZIP-val">LZIP_LUNZIP</A> : thm
<A NAME="line92"></A>    val <A HREF="#MONO_every-val">MONO_every</A> : thm
<A NAME="line93"></A>    val <A HREF="#MONO_exists-val">MONO_exists</A> : thm
<A NAME="line94"></A>    val <A HREF="#NOT_LFINITE_APPEND-val">NOT_LFINITE_APPEND</A> : thm
<A NAME="line95"></A>    val <A HREF="#NOT_LFINITE_DROP-val">NOT_LFINITE_DROP</A> : thm
<A NAME="line96"></A>    val <A HREF="#NOT_LFINITE_NO_LENGTH-val">NOT_LFINITE_NO_LENGTH</A> : thm
<A NAME="line97"></A>    val <A HREF="#NOT_LFINITE_TAKE-val">NOT_LFINITE_TAKE</A> : thm
<A NAME="line98"></A>    val <A HREF="#every_coind-val">every_coind</A> : thm
<A NAME="line99"></A>    val <A HREF="#every_thm-val">every_thm</A> : thm
<A NAME="line100"></A>    val <A HREF="#exists_LNTH-val">exists_LNTH</A> : thm
<A NAME="line101"></A>    val <A HREF="#exists_cases-val">exists_cases</A> : thm
<A NAME="line102"></A>    val <A HREF="#exists_ind-val">exists_ind</A> : thm
<A NAME="line103"></A>    val <A HREF="#exists_rules-val">exists_rules</A> : thm
<A NAME="line104"></A>    val <A HREF="#exists_thm-val">exists_thm</A> : thm
<A NAME="line105"></A>    val <A HREF="#from_toList-val">from_toList</A> : thm
<A NAME="line106"></A>    val <A HREF="#llength_rel_cases-val">llength_rel_cases</A> : thm
<A NAME="line107"></A>    val <A HREF="#llength_rel_ind-val">llength_rel_ind</A> : thm
<A NAME="line108"></A>    val <A HREF="#llength_rel_rules-val">llength_rel_rules</A> : thm
<A NAME="line109"></A>    val <A HREF="#llist_Axiom-val">llist_Axiom</A> : thm
<A NAME="line110"></A>    val <A HREF="#llist_Axiom_1-val">llist_Axiom_1</A> : thm
<A NAME="line111"></A>    val <A HREF="#llist_Axiom_1ue-val">llist_Axiom_1ue</A> : thm
<A NAME="line112"></A>    val <A HREF="#llist_CASES-val">llist_CASES</A> : thm
<A NAME="line113"></A>    val <A HREF="#llist_rep_LCONS-val">llist_rep_LCONS</A> : thm
<A NAME="line114"></A>    val <A HREF="#llist_ue_Axiom-val">llist_ue_Axiom</A> : thm
<A NAME="line115"></A>    val <A HREF="#toList_THM-val">toList_THM</A> : thm
<A NAME="line116"></A>    val <A HREF="#to_fromList-val">to_fromList</A> : thm
<A NAME="line117"></A>  
<A NAME="line118"></A>  val llist_grammars : type_grammar.grammar * term_grammar.grammar
<A NAME="line119"></A>  
<A NAME="line120"></A>  val llist_rwts : simpLib.ssfrag
<A NAME="line121"></A>(*
   [list] Parent theory of "llist"
   
   [<A NAME="LAPPEND-val"><B>LAPPEND</B></A>]  Definition
      
      |- (!x. LAPPEND [||] x = x) /\
         !h t x. LAPPEND (h:::t) x = h:::LAPPEND t x
   
   [<A NAME="LCONS-val"><B>LCONS</B></A>]  Definition
      
      |- !h t.
           h:::t =
           llist_abs (\n. if n = 0 then SOME h else llist_rep t (n - 1))
   
   [<A NAME="LDROP-val"><B>LDROP</B></A>]  Definition
      
      |- (!ll. LDROP 0 ll = SOME ll) /\
         !n ll.
           LDROP (SUC n) ll = OPTION_JOIN (OPTION_MAP (LDROP n) (LTL ll))
   
   [<A NAME="LFILTER-val"><B>LFILTER</B></A>]  Definition
      
      |- !P ll.
           LFILTER P ll =
           if ~exists P ll then
             [||]
           else
             if P (THE (LHD ll)) then
               THE (LHD ll):::LFILTER P (THE (LTL ll))
             else
               LFILTER P (THE (LTL ll))
   
   [<A NAME="LFLATTEN-val"><B>LFLATTEN</B></A>]  Definition
      
      |- !ll.
           LFLATTEN ll =
           if every ($= [||]) ll then
             [||]
           else
             if THE (LHD ll) = [||] then
               LFLATTEN (THE (LTL ll))
             else
               THE (LHD (THE (LHD ll))):::
                   LFLATTEN (THE (LTL (THE (LHD ll))):::THE (LTL ll))
   
   [<A NAME="LHD-val"><B>LHD</B></A>]  Definition
      
      |- !ll. LHD ll = llist_rep ll 0
   
   [<A NAME="LLENGTH-val"><B>LLENGTH</B></A>]  Definition
      
      |- !ll.
           LLENGTH ll =
           if LFINITE ll then SOME (@n. llength_rel ll n) else NONE
   
   [<A NAME="LMAP-val"><B>LMAP</B></A>]  Definition
      
      |- (!f. LMAP f [||] = [||]) /\
         !f h t. LMAP f (h:::t) = f h:::LMAP f t
   
   [<A NAME="LNIL-val"><B>LNIL</B></A>]  Definition
      
      |- [||] = llist_abs (\n. NONE)
   
   [<A NAME="LNTH-val"><B>LNTH</B></A>]  Definition
      
      |- (!ll. LNTH 0 ll = LHD ll) /\
         !n ll.
           LNTH (SUC n) ll = OPTION_JOIN (OPTION_MAP (LNTH n) (LTL ll))
   
   [<A NAME="LTAKE-val"><B>LTAKE</B></A>]  Definition
      
      |- (!ll. LTAKE 0 ll = SOME []) /\
         !n ll.
           LTAKE (SUC n) ll =
           case LHD ll of
              NONE -&gt; NONE
           || SOME hd -&gt;
                case LTAKE n (THE (LTL ll)) of
                   NONE -&gt; NONE
                || SOME tl -&gt; SOME (hd::tl)
   
   [<A NAME="LTL-val"><B>LTL</B></A>]  Definition
      
      |- !ll.
           LTL ll =
           case LHD ll of
              NONE -&gt; NONE
           || SOME v -&gt; SOME (llist_abs (\n. llist_rep ll (n + 1)))
   
   [<A NAME="LUNFOLD-val"><B>LUNFOLD</B></A>]  Definition
      
      |- !f x.
           LUNFOLD f x =
           case f x of NONE -&gt; [||] || SOME (v1,v2) -&gt; v2:::LUNFOLD f v1
   
   [<A NAME="LUNZIP_THM-val"><B>LUNZIP_THM</B></A>]  Definition
      
      |- (LUNZIP [||] = ([||],[||])) /\
         !x y t.
           LUNZIP ((x,y):::t) =
           (let (ll1,ll2) = LUNZIP t in (x:::ll1,y:::ll2))
   
   [<A NAME="LZIP_THM-val"><B>LZIP_THM</B></A>]  Definition
      
      |- (!l1. LZIP (l1,[||]) = [||]) /\ (!l2. LZIP ([||],l2) = [||]) /\
         !h1 h2 t1 t2. LZIP (h1:::t1,h2:::t2) = (h1,h2):::LZIP (t1,t2)
   
   [<A NAME="every_def-val"><B>every_def</B></A>]  Definition
      
      |- !P ll. every P ll &lt;=&gt; ~exists ($~ o P) ll
   
   [<A NAME="exists-val"><B>exists</B></A>]  Definition
      
      |- exists =
         (\P a0.
            !exists'.
              (!a0.
                 (?h t. (a0 = h:::t) /\ P h) \/
                 (?h t. (a0 = h:::t) /\ exists' t) ==&gt;
                 exists' a0) ==&gt;
              exists' a0)
   
   [<A NAME="fromList-val"><B>fromList</B></A>]  Definition
      
      |- (fromList [] = [||]) /\ !h t. fromList (h::t) = h:::fromList t
   
   [<A NAME="llength_rel-val"><B>llength_rel</B></A>]  Definition
      
      |- llength_rel =
         (\a0 a1.
            !llength_rel'.
              (!a0 a1.
                 (a0 = [||]) /\ (a1 = 0) \/
                 (?h n t.
                    (a0 = h:::t) /\ (a1 = SUC n) /\ llength_rel' t n) ==&gt;
                 llength_rel' a0 a1) ==&gt;
              llength_rel' a0 a1)
   
   [<A NAME="llist_TY_DEF-val"><B>llist_TY_DEF</B></A>]  Definition
      
      |- ?rep. TYPE_DEFINITION lrep_ok rep
   
   [<A NAME="llist_absrep-val"><B>llist_absrep</B></A>]  Definition
      
      |- (!a. llist_abs (llist_rep a) = a) /\
         !r. lrep_ok r &lt;=&gt; (llist_rep (llist_abs r) = r)
   
   [<A NAME="lrep_ok_def-val"><B>lrep_ok_def</B></A>]  Definition
      
      |- !f.
           lrep_ok f &lt;=&gt;
           ?P.
             (!g.
                P g ==&gt;
                (g = (\n. NONE)) \/
                ?h t.
                  P t /\
                  (g = (\n. if n = 0 then SOME h else t (n - 1)))) /\ P f
   
   [<A NAME="toList-val"><B>toList</B></A>]  Definition
      
      |- !ll.
           toList ll =
           if LFINITE ll then LTAKE (THE (LLENGTH ll)) ll else NONE
   
   [<A NAME="LAPPEND_ASSOC-val"><B>LAPPEND_ASSOC</B></A>]  Theorem
      
      |- !ll1 ll2 ll3.
           LAPPEND (LAPPEND ll1 ll2) ll3 = LAPPEND ll1 (LAPPEND ll2 ll3)
   
   [<A NAME="LAPPEND_EQ_LNIL-val"><B>LAPPEND_EQ_LNIL</B></A>]  Theorem
      
      |- (LAPPEND l1 l2 = [||]) &lt;=&gt; (l1 = [||]) /\ (l2 = [||])
   
   [<A NAME="LAPPEND_NIL_2ND-val"><B>LAPPEND_NIL_2ND</B></A>]  Theorem
      
      |- !ll. LAPPEND ll [||] = ll
   
   [<A NAME="LCONS_11-val"><B>LCONS_11</B></A>]  Theorem
      
      |- !h1 t1 h2 t2. (h1:::t1 = h2:::t2) &lt;=&gt; (h1 = h2) /\ (t1 = t2)
   
   [<A NAME="LCONS_NOT_NIL-val"><B>LCONS_NOT_NIL</B></A>]  Theorem
      
      |- !h t. h:::t &lt;&gt; [||] /\ [||] &lt;&gt; h:::t
   
   [<A NAME="LDROP1_THM-val"><B>LDROP1_THM</B></A>]  Theorem
      
      |- LDROP 1 = LTL
   
   [<A NAME="LDROP_THM-val"><B>LDROP_THM</B></A>]  Theorem
      
      |- (!ll. LDROP 0 ll = SOME ll) /\ (!n. LDROP (SUC n) [||] = NONE) /\
         !n h t. LDROP (SUC n) (h:::t) = LDROP n t
   
   [<A NAME="LFILTER_APPEND-val"><B>LFILTER_APPEND</B></A>]  Theorem
      
      |- !P ll1 ll2.
           LFINITE ll1 ==&gt;
           (LFILTER P (LAPPEND ll1 ll2) =
            LAPPEND (LFILTER P ll1) (LFILTER P ll2))
   
   [<A NAME="LFILTER_EQ_NIL-val"><B>LFILTER_EQ_NIL</B></A>]  Theorem
      
      |- !ll. (LFILTER P ll = [||]) &lt;=&gt; every ($~ o P) ll
   
   [<A NAME="LFILTER_NIL-val"><B>LFILTER_NIL</B></A>]  Theorem
      
      |- !P ll. every ($~ o P) ll ==&gt; (LFILTER P ll = [||])
   
   [<A NAME="LFILTER_THM-val"><B>LFILTER_THM</B></A>]  Theorem
      
      |- (!P. LFILTER P [||] = [||]) /\
         !P h t.
           LFILTER P (h:::t) = if P h then h:::LFILTER P t else LFILTER P t
   
   [<A NAME="LFINITE-val"><B>LFINITE</B></A>]  Theorem
      
      |- LFINITE ll &lt;=&gt; ?n. LTAKE n ll = NONE
   
   [<A NAME="LFINITE_APPEND-val"><B>LFINITE_APPEND</B></A>]  Theorem
      
      |- !ll1 ll2. LFINITE (LAPPEND ll1 ll2) &lt;=&gt; LFINITE ll1 /\ LFINITE ll2
   
   [<A NAME="LFINITE_DROP-val"><B>LFINITE_DROP</B></A>]  Theorem
      
      |- !n ll.
           LFINITE ll /\ n &lt;= THE (LLENGTH ll) ==&gt; ?y. LDROP n ll = SOME y
   
   [<A NAME="LFINITE_HAS_LENGTH-val"><B>LFINITE_HAS_LENGTH</B></A>]  Theorem
      
      |- !ll. LFINITE ll ==&gt; ?n. LLENGTH ll = SOME n
   
   [<A NAME="LFINITE_INDUCTION-val"><B>LFINITE_INDUCTION</B></A>]  Theorem
      
      |- !P.
           P [||] /\ (!h t. P t ==&gt; P (h:::t)) ==&gt; !a0. LFINITE a0 ==&gt; P a0
   
   [<A NAME="LFINITE_MAP-val"><B>LFINITE_MAP</B></A>]  Theorem
      
      |- !f ll. LFINITE (LMAP f ll) &lt;=&gt; LFINITE ll
   
   [<A NAME="LFINITE_STRONG_INDUCTION-val"><B>LFINITE_STRONG_INDUCTION</B></A>]  Theorem
      
      |- P [||] /\ (!h t. LFINITE t /\ P t ==&gt; P (h:::t)) ==&gt;
         !a0. LFINITE a0 ==&gt; P a0
   
   [<A NAME="LFINITE_TAKE-val"><B>LFINITE_TAKE</B></A>]  Theorem
      
      |- !n ll.
           LFINITE ll /\ n &lt;= THE (LLENGTH ll) ==&gt; ?y. LTAKE n ll = SOME y
   
   [<A NAME="LFINITE_THM-val"><B>LFINITE_THM</B></A>]  Theorem
      
      |- (LFINITE [||] &lt;=&gt; T) /\ !h t. LFINITE (h:::t) &lt;=&gt; LFINITE t
   
   [<A NAME="LFINITE_cases-val"><B>LFINITE_cases</B></A>]  Theorem
      
      |- !a0. LFINITE a0 &lt;=&gt; (a0 = [||]) \/ ?h t. (a0 = h:::t) /\ LFINITE t
   
   [<A NAME="LFINITE_fromList-val"><B>LFINITE_fromList</B></A>]  Theorem
      
      |- !l. LFINITE (fromList l)
   
   [<A NAME="LFINITE_ind-val"><B>LFINITE_ind</B></A>]  Theorem
      
      |- !LFINITE'.
           LFINITE' [||] /\ (!h t. LFINITE' t ==&gt; LFINITE' (h:::t)) ==&gt;
           !a0. LFINITE a0 ==&gt; LFINITE' a0
   
   [<A NAME="LFINITE_rules-val"><B>LFINITE_rules</B></A>]  Theorem
      
      |- LFINITE [||] /\ !h t. LFINITE t ==&gt; LFINITE (h:::t)
   
   [<A NAME="LFINITE_toList-val"><B>LFINITE_toList</B></A>]  Theorem
      
      |- !ll. LFINITE ll ==&gt; ?l. toList ll = SOME l
   
   [<A NAME="LFLATTEN_APPEND-val"><B>LFLATTEN_APPEND</B></A>]  Theorem
      
      |- !h t. LFLATTEN (h:::t) = LAPPEND h (LFLATTEN t)
   
   [<A NAME="LFLATTEN_EQ_NIL-val"><B>LFLATTEN_EQ_NIL</B></A>]  Theorem
      
      |- !ll. (LFLATTEN ll = [||]) &lt;=&gt; every ($= [||]) ll
   
   [<A NAME="LFLATTEN_SINGLETON-val"><B>LFLATTEN_SINGLETON</B></A>]  Theorem
      
      |- !h. LFLATTEN [|h|] = h
   
   [<A NAME="LFLATTEN_THM-val"><B>LFLATTEN_THM</B></A>]  Theorem
      
      |- (LFLATTEN [||] = [||]) /\
         (!tl. LFLATTEN ([||]:::t) = LFLATTEN t) /\
         !h t tl. LFLATTEN ((h:::t):::tl) = h:::LFLATTEN (t:::tl)
   
   [<A NAME="LHDTL_CONS_THM-val"><B>LHDTL_CONS_THM</B></A>]  Theorem
      
      |- !h t. (LHD (h:::t) = SOME h) /\ (LTL (h:::t) = SOME t)
   
   [<A NAME="LHDTL_EQ_SOME-val"><B>LHDTL_EQ_SOME</B></A>]  Theorem
      
      |- !h t ll. (ll = h:::t) &lt;=&gt; (LHD ll = SOME h) /\ (LTL ll = SOME t)
   
   [<A NAME="LHD_EQ_NONE-val"><B>LHD_EQ_NONE</B></A>]  Theorem
      
      |- !ll.
           ((LHD ll = NONE) &lt;=&gt; (ll = [||])) /\
           ((NONE = LHD ll) &lt;=&gt; (ll = [||]))
   
   [<A NAME="LHD_LCONS-val"><B>LHD_LCONS</B></A>]  Theorem
      
      |- LHD (h:::t) = SOME h
   
   [<A NAME="LHD_THM-val"><B>LHD_THM</B></A>]  Theorem
      
      |- (LHD [||] = NONE) /\ !h t. LHD (h:::t) = SOME h
   
   [<A NAME="LLENGTH_APPEND-val"><B>LLENGTH_APPEND</B></A>]  Theorem
      
      |- !ll1 ll2.
           LLENGTH (LAPPEND ll1 ll2) =
           if LFINITE ll1 /\ LFINITE ll2 then
             SOME (THE (LLENGTH ll1) + THE (LLENGTH ll2))
           else
             NONE
   
   [<A NAME="LLENGTH_MAP-val"><B>LLENGTH_MAP</B></A>]  Theorem
      
      |- !ll f. LLENGTH (LMAP f ll) = LLENGTH ll
   
   [<A NAME="LLENGTH_THM-val"><B>LLENGTH_THM</B></A>]  Theorem
      
      |- (LLENGTH [||] = SOME 0) /\
         !h t. LLENGTH (h:::t) = OPTION_MAP SUC (LLENGTH t)
   
   [<A NAME="LLENGTH_fromList-val"><B>LLENGTH_fromList</B></A>]  Theorem
      
      |- !l. LLENGTH (fromList l) = SOME (LENGTH l)
   
   [<A NAME="LLIST_BISIMULATION-val"><B>LLIST_BISIMULATION</B></A>]  Theorem
      
      |- !ll1 ll2.
           (ll1 = ll2) &lt;=&gt;
           ?R.
             R ll1 ll2 /\
             !ll3 ll4.
               R ll3 ll4 ==&gt;
               (ll3 = [||]) /\ (ll4 = [||]) \/
               (LHD ll3 = LHD ll4) /\ R (THE (LTL ll3)) (THE (LTL ll4))
   
   [<A NAME="LLIST_BISIMULATION0-val"><B>LLIST_BISIMULATION0</B></A>]  Theorem
      
      |- !ll1 ll2.
           (ll1 = ll2) &lt;=&gt;
           ?R.
             R ll1 ll2 /\
             !ll3 ll4.
               R ll3 ll4 ==&gt;
               (ll3 = [||]) /\ (ll4 = [||]) \/
               ?h t1 t2. (ll3 = h:::t1) /\ (ll4 = h:::t2) /\ R t1 t2
   
   [<A NAME="LLIST_STRONG_BISIMULATION-val"><B>LLIST_STRONG_BISIMULATION</B></A>]  Theorem
      
      |- !ll1 ll2.
           (ll1 = ll2) &lt;=&gt;
           ?R.
             R ll1 ll2 /\
             !ll3 ll4.
               R ll3 ll4 ==&gt;
               (ll3 = ll4) \/
               ?h t1 t2. (ll3 = h:::t1) /\ (ll4 = h:::t2) /\ R t1 t2
   
   [<A NAME="LL_ALL_THM-val"><B>LL_ALL_THM</B></A>]  Theorem
      
      |- (every P [||] &lt;=&gt; T) /\ (every P (h:::t) &lt;=&gt; P h /\ every P t)
   
   [<A NAME="LMAP_APPEND-val"><B>LMAP_APPEND</B></A>]  Theorem
      
      |- !f ll1 ll2.
           LMAP f (LAPPEND ll1 ll2) = LAPPEND (LMAP f ll1) (LMAP f ll2)
   
   [<A NAME="LMAP_MAP-val"><B>LMAP_MAP</B></A>]  Theorem
      
      |- !f g ll. LMAP f (LMAP g ll) = LMAP (f o g) ll
   
   [<A NAME="LNTH_EQ-val"><B>LNTH_EQ</B></A>]  Theorem
      
      |- !ll1 ll2. (ll1 = ll2) &lt;=&gt; !n. LNTH n ll1 = LNTH n ll2
   
   [<A NAME="LNTH_THM-val"><B>LNTH_THM</B></A>]  Theorem
      
      |- (!n. LNTH n [||] = NONE) /\ (!h t. LNTH 0 (h:::t) = SOME h) /\
         !n h t. LNTH (SUC n) (h:::t) = LNTH n t
   
   [<A NAME="LTAKE_CONS_EQ_NONE-val"><B>LTAKE_CONS_EQ_NONE</B></A>]  Theorem
      
      |- !m h t.
           (LTAKE m (h:::t) = NONE) &lt;=&gt;
           ?n. (m = SUC n) /\ (LTAKE n t = NONE)
   
   [<A NAME="LTAKE_CONS_EQ_SOME-val"><B>LTAKE_CONS_EQ_SOME</B></A>]  Theorem
      
      |- !m h t l.
           (LTAKE m (h:::t) = SOME l) &lt;=&gt;
           (m = 0) /\ (l = []) \/
           ?n l'. (m = SUC n) /\ (LTAKE n t = SOME l') /\ (l = h::l')
   
   [<A NAME="LTAKE_DROP-val"><B>LTAKE_DROP</B></A>]  Theorem
      
      |- (!n ll.
            ~LFINITE ll ==&gt;
            (LAPPEND (fromList (THE (LTAKE n ll))) (THE (LDROP n ll)) =
             ll)) /\
         !n ll.
           LFINITE ll /\ n &lt;= THE (LLENGTH ll) ==&gt;
           (LAPPEND (fromList (THE (LTAKE n ll))) (THE (LDROP n ll)) = ll)
   
   [<A NAME="LTAKE_EQ-val"><B>LTAKE_EQ</B></A>]  Theorem
      
      |- !ll1 ll2. (ll1 = ll2) &lt;=&gt; !n. LTAKE n ll1 = LTAKE n ll2
   
   [<A NAME="LTAKE_EQ_SOME_CONS-val"><B>LTAKE_EQ_SOME_CONS</B></A>]  Theorem
      
      |- !n l x. (LTAKE n l = SOME x) ==&gt; !h. ?y. LTAKE n (h:::l) = SOME y
   
   [<A NAME="LTAKE_LNTH-val"><B>LTAKE_LNTH</B></A>]  Theorem
      
      |- !n ll. (LTAKE n ll = NONE) ==&gt; (LNTH n ll = NONE)
   
   [<A NAME="LTAKE_NIL_EQ_NONE-val"><B>LTAKE_NIL_EQ_NONE</B></A>]  Theorem
      
      |- !m. (LTAKE m [||] = NONE) &lt;=&gt; 0 &lt; m
   
   [<A NAME="LTAKE_NIL_EQ_SOME-val"><B>LTAKE_NIL_EQ_SOME</B></A>]  Theorem
      
      |- !l m. (LTAKE m [||] = SOME l) &lt;=&gt; (m = 0) /\ (l = [])
   
   [<A NAME="LTAKE_SNOC_LNTH-val"><B>LTAKE_SNOC_LNTH</B></A>]  Theorem
      
      |- !n ll.
           LTAKE (SUC n) ll =
           case LTAKE n ll of
              NONE -&gt; NONE
           || SOME l -&gt;
                case LNTH n ll of NONE -&gt; NONE || SOME e -&gt; SOME (l ++ [e])
   
   [<A NAME="LTAKE_THM-val"><B>LTAKE_THM</B></A>]  Theorem
      
      |- (!l. LTAKE 0 l = SOME []) /\ (!n. LTAKE (SUC n) [||] = NONE) /\
         !n h t. LTAKE (SUC n) (h:::t) = OPTION_MAP (CONS h) (LTAKE n t)
   
   [<A NAME="LTAKE_fromList-val"><B>LTAKE_fromList</B></A>]  Theorem
      
      |- !l. LTAKE (LENGTH l) (fromList l) = SOME l
   
   [<A NAME="LTL_EQ_NONE-val"><B>LTL_EQ_NONE</B></A>]  Theorem
      
      |- !ll.
           ((LTL ll = NONE) &lt;=&gt; (ll = [||])) /\
           ((NONE = LTL ll) &lt;=&gt; (ll = [||]))
   
   [<A NAME="LTL_LCONS-val"><B>LTL_LCONS</B></A>]  Theorem
      
      |- LTL (h:::t) = SOME t
   
   [<A NAME="LTL_THM-val"><B>LTL_THM</B></A>]  Theorem
      
      |- (LTL [||] = NONE) /\ !h t. LTL (h:::t) = SOME t
   
   [<A NAME="LZIP_LUNZIP-val"><B>LZIP_LUNZIP</B></A>]  Theorem
      
      |- !ll. LZIP (LUNZIP ll) = ll
   
   [<A NAME="MONO_every-val"><B>MONO_every</B></A>]  Theorem
      
      |- (!x. P x ==&gt; Q x) ==&gt; every P l ==&gt; every Q l
   
   [<A NAME="MONO_exists-val"><B>MONO_exists</B></A>]  Theorem
      
      |- (!x. P x ==&gt; Q x) ==&gt; exists P l ==&gt; exists Q l
   
   [<A NAME="NOT_LFINITE_APPEND-val"><B>NOT_LFINITE_APPEND</B></A>]  Theorem
      
      |- !ll1 ll2. ~LFINITE ll1 ==&gt; (LAPPEND ll1 ll2 = ll1)
   
   [<A NAME="NOT_LFINITE_DROP-val"><B>NOT_LFINITE_DROP</B></A>]  Theorem
      
      |- !ll. ~LFINITE ll ==&gt; !n. ?y. LDROP n ll = SOME y
   
   [<A NAME="NOT_LFINITE_NO_LENGTH-val"><B>NOT_LFINITE_NO_LENGTH</B></A>]  Theorem
      
      |- !ll. ~LFINITE ll ==&gt; (LLENGTH ll = NONE)
   
   [<A NAME="NOT_LFINITE_TAKE-val"><B>NOT_LFINITE_TAKE</B></A>]  Theorem
      
      |- !ll. ~LFINITE ll ==&gt; !n. ?y. LTAKE n ll = SOME y
   
   [<A NAME="every_coind-val"><B>every_coind</B></A>]  Theorem
      
      |- !P Q.
           (!h t. Q (h:::t) ==&gt; P h /\ Q t) ==&gt; !ll. Q ll ==&gt; every P ll
   
   [<A NAME="every_thm-val"><B>every_thm</B></A>]  Theorem
      
      |- (every P [||] &lt;=&gt; T) /\ (every P (h:::t) &lt;=&gt; P h /\ every P t)
   
   [<A NAME="exists_LNTH-val"><B>exists_LNTH</B></A>]  Theorem
      
      |- !l. exists P l &lt;=&gt; ?n e. (SOME e = LNTH n l) /\ P e
   
   [<A NAME="exists_cases-val"><B>exists_cases</B></A>]  Theorem
      
      |- !P a0.
           exists P a0 &lt;=&gt;
           (?h t. (a0 = h:::t) /\ P h) \/ ?h t. (a0 = h:::t) /\ exists P t
   
   [<A NAME="exists_ind-val"><B>exists_ind</B></A>]  Theorem
      
      |- !P exists'.
           (!h t. P h ==&gt; exists' (h:::t)) /\
           (!h t. exists' t ==&gt; exists' (h:::t)) ==&gt;
           !a0. exists P a0 ==&gt; exists' a0
   
   [<A NAME="exists_rules-val"><B>exists_rules</B></A>]  Theorem
      
      |- !P.
           (!h t. P h ==&gt; exists P (h:::t)) /\
           !h t. exists P t ==&gt; exists P (h:::t)
   
   [<A NAME="exists_thm-val"><B>exists_thm</B></A>]  Theorem
      
      |- (exists P [||] &lt;=&gt; F) /\ (exists P (h:::t) &lt;=&gt; P h \/ exists P t)
   
   [<A NAME="from_toList-val"><B>from_toList</B></A>]  Theorem
      
      |- !l. toList (fromList l) = SOME l
   
   [<A NAME="llength_rel_cases-val"><B>llength_rel_cases</B></A>]  Theorem
      
      |- !a0 a1.
           llength_rel a0 a1 &lt;=&gt;
           (a0 = [||]) /\ (a1 = 0) \/
           ?h n t. (a0 = h:::t) /\ (a1 = SUC n) /\ llength_rel t n
   
   [<A NAME="llength_rel_ind-val"><B>llength_rel_ind</B></A>]  Theorem
      
      |- !llength_rel'.
           llength_rel' [||] 0 /\
           (!h n t. llength_rel' t n ==&gt; llength_rel' (h:::t) (SUC n)) ==&gt;
           !a0 a1. llength_rel a0 a1 ==&gt; llength_rel' a0 a1
   
   [<A NAME="llength_rel_rules-val"><B>llength_rel_rules</B></A>]  Theorem
      
      |- llength_rel [||] 0 /\
         !h n t. llength_rel t n ==&gt; llength_rel (h:::t) (SUC n)
   
   [<A NAME="llist_Axiom-val"><B>llist_Axiom</B></A>]  Theorem
      
      |- !f.
           ?g.
             (!x. LHD (g x) = OPTION_MAP SND (f x)) /\
             !x. LTL (g x) = OPTION_MAP (g o FST) (f x)
   
   [<A NAME="llist_Axiom_1-val"><B>llist_Axiom_1</B></A>]  Theorem
      
      |- !f.
           ?g. !x. g x = case f x of NONE -&gt; [||] || SOME (a,b) -&gt; b:::g a
   
   [<A NAME="llist_Axiom_1ue-val"><B>llist_Axiom_1ue</B></A>]  Theorem
      
      |- !f.
           ?!g. !x. g x = case f x of NONE -&gt; [||] || SOME (a,b) -&gt; b:::g a
   
   [<A NAME="llist_CASES-val"><B>llist_CASES</B></A>]  Theorem
      
      |- !l. (l = [||]) \/ ?h t. l = h:::t
   
   [<A NAME="llist_rep_LCONS-val"><B>llist_rep_LCONS</B></A>]  Theorem
      
      |- llist_rep (h:::t) =
         (\n. if n = 0 then SOME h else llist_rep t (n - 1))
   
   [<A NAME="llist_ue_Axiom-val"><B>llist_ue_Axiom</B></A>]  Theorem
      
      |- !f.
           ?!g.
             (!x. LHD (g x) = OPTION_MAP SND (f x)) /\
             !x. LTL (g x) = OPTION_MAP (g o FST) (f x)
   
   [<A NAME="toList_THM-val"><B>toList_THM</B></A>]  Theorem
      
      |- (toList [||] = SOME []) /\
         !h t. toList (h:::t) = OPTION_MAP (CONS h) (toList t)
   
   [<A NAME="to_fromList-val"><B>to_fromList</B></A>]  Theorem
      
      |- !ll. LFINITE ll ==&gt; (fromList (THE (toList ll)) = ll)
   
   
*)
end

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="../../../src/llist/llistScript.sml" type="text/plain">Source File</A>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="TheoryIndex.html">Theory binding index</A>
</TABLE><HR>
<BR><EM><A HREF="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-5</EM></BODY></HTML>
