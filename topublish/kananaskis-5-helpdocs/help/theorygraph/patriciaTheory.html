<HTML>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Theory: patricia</TITLE><meta http-equiv="content-type" content="text/html;charset=UTF-8">
</HEAD>
<BODY bgcolor=linen text=midnightblue>
<H1><font color="black">Theory "patricia"</font></H1>
<STRONG><font size=+3 color="black">Parents</font></STRONG>&nbsp;&nbsp;&nbsp;&nbsp;
    <A HREF = "wordsTheory.html"><STRONG><font color="black">words</font></STRONG></A>&nbsp;&nbsp;
    <A HREF = "sortingTheory.html"><STRONG><font color="black">sorting</font></STRONG></A>

<H1><font color="black">Signature</font></H1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr>
    <th>
    <font color="crimson">Type</font>
    <th>
    <font color="crimson">Arity</font><tr><td>
                                          <STRONG><font color="black">ptree</font></STRONG>
                                          <td>
                                          1
    <tr>
    <th>
    <font color="crimson">Constant</font>
    <th>
    <font color="crimson">Type</font><tr><td>
                                         <STRONG><font color="black">ADD</font></STRONG>
                                         <td>
                                         :'a ptree -> num # 'a -> 'a ptree
    <tr><td>
        <STRONG><font color="black">ADD_LIST</font></STRONG>
        <td>
        :'a ptree -> (num # 'a) list -> 'a ptree
    <tr><td>
        <STRONG><font color="black">ADD_tupled</font></STRONG>
        <td>
        :'a ptree # num # 'a -> 'a ptree
    <tr><td>
        <STRONG><font color="black">BRANCH</font></STRONG>
        <td>
        :num # num # 'a ptree # 'a ptree -> 'a ptree
    <tr><td>
        <STRONG><font color="black">BRANCHING_BIT</font></STRONG>
        <td>
        :num -> num -> num
    <tr><td>
        <STRONG><font color="black">BRANCHING_BIT_tupled</font></STRONG>
        <td>
        :num # num -> num
    <tr><td>
        <STRONG><font color="black">Branch</font></STRONG>
        <td>
        :num -> num -> 'a ptree -> 'a ptree -> 'a ptree
    <tr><td>
        <STRONG><font color="black">DEPTH</font></STRONG>
        <td>
        :'a ptree -> num
    <tr><td>
        <STRONG><font color="black">EVERY_LEAF</font></STRONG>
        <td>
        :(num -> 'a -> bool) -> 'a ptree -> bool
    <tr><td>
        <STRONG><font color="black">EXISTS_LEAF</font></STRONG>
        <td>
        :(num -> 'a -> bool) -> 'a ptree -> bool
    <tr><td> <STRONG><font color="black">Empty</font></STRONG> <td> :'a ptree
    <tr><td>
        <STRONG><font color="black">FIND</font></STRONG>
        <td>
        :'a ptree -> num -> 'a
    <tr><td>
        <STRONG><font color="black">INSERT_PTREE</font></STRONG>
        <td>
        :num -> ptreeset -> ptreeset
    <tr><td>
        <STRONG><font color="black">IN_PTREE</font></STRONG>
        <td>
        :num -> ptreeset -> bool
    <tr><td>
        <STRONG><font color="black">IS_EMPTY</font></STRONG>
        <td>
        :'a ptree -> bool
    <tr><td>
        <STRONG><font color="black">IS_PTREE</font></STRONG>
        <td>
        :'a ptree -> bool
    <tr><td>
        <STRONG><font color="black">JOIN</font></STRONG>
        <td>
        :num # 'a ptree # num # 'a ptree -> 'a ptree
    <tr><td>
        <STRONG><font color="black">KEYS</font></STRONG>
        <td>
        :'a ptree -> num list
    <tr><td>
        <STRONG><font color="black">Leaf</font></STRONG>
        <td>
        :num -> 'a -> 'a ptree
    <tr><td>
        <STRONG><font color="black">NUMSET_OF_PTREE</font></STRONG>
        <td>
        :ptreeset -> num -> bool
    <tr><td>
        <STRONG><font color="black">PEEK</font></STRONG>
        <td>
        :'a ptree -> num -> 'a option
    <tr><td>
        <STRONG><font color="black">PEEK_tupled</font></STRONG>
        <td>
        :'a ptree # num -> 'a option
    <tr><td>
        <STRONG><font color="black">PTREE_OF_NUMSET</font></STRONG>
        <td>
        :ptreeset -> (num -> bool) -> ptreeset
    <tr><td>
        <STRONG><font color="black">REMOVE</font></STRONG>
        <td>
        :'a ptree -> num -> 'a ptree
    <tr><td>
        <STRONG><font color="black">SIZE</font></STRONG>
        <td>
        :'a ptree -> num
    <tr><td>
        <STRONG><font color="black">TRANSFORM</font></STRONG>
        <td>
        :('b -> 'a) -> 'b ptree -> 'a ptree
    <tr><td>
        <STRONG><font color="black">TRAVERSE</font></STRONG>
        <td>
        :'a ptree -> num list
    <tr><td>
        <STRONG><font color="black">TRAVERSE_AUX</font></STRONG>
        <td>
        :'a ptree -> num list -> num list
    <tr><td>
        <STRONG><font color="black">UNION_PTREE</font></STRONG>
        <td>
        :ptreeset -> ptreeset -> ptreeset
    <tr><td>
        <STRONG><font color="black">dest_ptree</font></STRONG>
        <td>
        :'a ptree -> (num # 'a # num) recspace
    <tr><td>
        <STRONG><font color="black">mk_ptree</font></STRONG>
        <td>
        :(num # 'a # num) recspace -> 'a ptree
    <tr><td>
        <STRONG><font color="black">ptree_case</font></STRONG>
        <td>
        :'b ->
         (num -> 'a -> 'b) ->
         (num -> num -> 'a ptree -> 'a ptree -> 'b) -> 'a ptree -> 'b
    <tr><td>
        <STRONG><font color="black">ptree_size</font></STRONG>
        <td>
        :('a -> num) -> 'a ptree -> num
    
</table>
</center>

<H1><font color="black">Definitions</font></H1>
<DL>
<DT><STRONG><font color="black">ptree_TY_DEF</font></STRONG>
<DD>
<PRE>
|- ?rep.
     TYPE_DEFINITION
       (\a0'.
          !'ptree' .
            (!a0'.
               (a0' =
                ind_type$CONSTR 0 (ARB,ARB,ARB) (\n. ind_type$BOTTOM)) \/
               (?a0 a1.
                  a0' =
                  (\a0 a1.
                     ind_type$CONSTR (SUC 0) (a0,a1,ARB)
                       (\n. ind_type$BOTTOM)) a0 a1) \/
               (?a0 a1 a2 a3.
                  (a0' =
                   (\a0 a1 a2 a3.
                      ind_type$CONSTR (SUC (SUC 0)) (a0,ARB,a1)
                        (ind_type$FCONS a2
                           (ind_type$FCONS a3 (\n. ind_type$BOTTOM)))) a0 a1
                     a2 a3) /\ 'ptree' a2 /\ 'ptree' a3) ==>
               'ptree' a0') ==>
            'ptree' a0') rep
</PRE>

<DT><STRONG><font color="black">ptree_repfns</font></STRONG>
<DD>
<PRE>
|- (!a. mk_ptree (dest_ptree a) = a) /\
   !r.
     (\a0'.
        !'ptree' .
          (!a0'.
             (a0' = ind_type$CONSTR 0 (ARB,ARB,ARB) (\n. ind_type$BOTTOM)) \/
             (?a0 a1.
                a0' =
                (\a0 a1.
                   ind_type$CONSTR (SUC 0) (a0,a1,ARB) (\n. ind_type$BOTTOM))
                  a0 a1) \/
             (?a0 a1 a2 a3.
                (a0' =
                 (\a0 a1 a2 a3.
                    ind_type$CONSTR (SUC (SUC 0)) (a0,ARB,a1)
                      (ind_type$FCONS a2
                         (ind_type$FCONS a3 (\n. ind_type$BOTTOM)))) a0 a1 a2
                   a3) /\ 'ptree' a2 /\ 'ptree' a3) ==>
             'ptree' a0') ==>
          'ptree' a0') r <=> (dest_ptree (mk_ptree r) = r)
</PRE>

<DT><STRONG><font color="black">ptree_case_def</font></STRONG>
<DD>
<PRE>
|- (!v f f1. ptree_case v f f1 <{}> = v) /\
   (!v f f1 a0 a1. ptree_case v f f1 (Leaf a0 a1) = f a0 a1) /\
   !v f f1 a0 a1 a2 a3.
     ptree_case v f f1 (Branch a0 a1 a2 a3) = f1 a0 a1 a2 a3
</PRE>

<DT><STRONG><font color="black">ptree_size_def</font></STRONG>
<DD>
<PRE>
|- (!f. ptree_size f <{}> = 0) /\
   (!f a0 a1. ptree_size f (Leaf a0 a1) = 1 + (a0 + f a1)) /\
   !f a0 a1 a2 a3.
     ptree_size f (Branch a0 a1 a2 a3) =
     1 + (a0 + (a1 + (ptree_size f a2 + ptree_size f a3)))
</PRE>

<DT><STRONG><font color="black">BRANCHING_BIT_tupled_primitive_def</font></STRONG>
<DD>
<PRE>
|- BRANCHING_BIT_tupled =
   WFREC
     (@R.
        WF R /\
        !p1 p0.
          ~((ODD p0 <=> EVEN p1) \/ (p0 = p1)) ==>
          R (DIV2 p0,DIV2 p1) (p0,p1))
     (\BRANCHING_BIT_tupled a.
        case a of
           (p0,p1) ->
             I
               (if (ODD p0 <=> EVEN p1) \/ (p0 = p1) then
                  0
                else
                  SUC (BRANCHING_BIT_tupled (DIV2 p0,DIV2 p1))))
</PRE>

<DT><STRONG><font color="black">BRANCHING_BIT_curried_def</font></STRONG>
<DD>
<PRE>
|- !x x1. BRANCHING_BIT x x1 = BRANCHING_BIT_tupled (x,x1)
</PRE>

<DT><STRONG><font color="black">PEEK_tupled_primitive_def</font></STRONG>
<DD>
<PRE>
|- PEEK_tupled =
   WFREC
     (@R.
        WF R /\ !p r l k m. R (if BIT m k then l else r,k) (Branch p m l r,k))
     (\PEEK_tupled a.
        case a of
           (<{}>,k) -> I NONE
        || (Leaf j d,k) -> I (if k = j then SOME d else NONE)
        || (Branch p m l r,k) -> I (PEEK_tupled (if BIT m k then l else r,k)))
</PRE>

<DT><STRONG><font color="black">PEEK_curried_def</font></STRONG>
<DD>
<PRE>
|- !x x1. x ' x1 = PEEK_tupled (x,x1)
</PRE>

<DT><STRONG><font color="black">JOIN_def</font></STRONG>
<DD>
<PRE>
|- !p0 t0 p1 t1.
     JOIN (p0,t0,p1,t1) =
     (let m = BRANCHING_BIT p0 p1 in
        if BIT m p0 then
          Branch (MOD_2EXP m p0) m t0 t1
        else
          Branch (MOD_2EXP m p0) m t1 t0)
</PRE>

<DT><STRONG><font color="black">ADD_tupled_primitive_def</font></STRONG>
<DD>
<PRE>
|- ADD_tupled =
   WFREC
     (@R.
        WF R /\
        (!l e r p k m.
           MOD_2EXP_EQ m k p /\ ~BIT m k ==>
           R (r,k,e) (Branch p m l r,k,e)) /\
        !r e l p k m.
          MOD_2EXP_EQ m k p /\ BIT m k ==> R (l,k,e) (Branch p m l r,k,e))
     (\ADD_tupled a.
        case a of
           (<{}>,k,e) -> I (Leaf k e)
        || (Leaf j d,k',e') ->
             I
               (if j = k' then
                  Leaf k' e'
                else
                  JOIN (k',Leaf k' e',j,Leaf j d))
        || (Branch p m l r,k'',e'') ->
             I
               (if MOD_2EXP_EQ m k'' p then
                  if BIT m k'' then
                    Branch p m (ADD_tupled (l,k'',e'')) r
                  else
                    Branch p m l (ADD_tupled (r,k'',e''))
                else
                  JOIN (k'',Leaf k'' e'',p,Branch p m l r)))
</PRE>

<DT><STRONG><font color="black">ADD_curried_def</font></STRONG>
<DD>
<PRE>
|- !x x1. x |+ x1 = ADD_tupled (x,x1)
</PRE>

<DT><STRONG><font color="black">BRANCH_primitive_def</font></STRONG>
<DD>
<PRE>
|- BRANCH =
   WFREC (@R. WF R)
     (\BRANCH a.
        case a of
           (v,v2,<{}>,<{}>) -> I <{}>
        || (v,v2,<{}>,Leaf v36 v37) -> I (Leaf v36 v37)
        || (v,v2,<{}>,Branch v38 v39 v40 v41) -> I (Branch v38 v39 v40 v41)
        || (v,v2,Leaf v18 v19,<{}>) -> I (Leaf v18 v19)
        || (v,v2,Leaf v18 v19,Leaf v48 v49) ->
             I (Branch v v2 (Leaf v18 v19) (Leaf v48 v49))
        || (v,v2,Leaf v18 v19,Branch v50 v51 v52 v53) ->
             I (Branch v v2 (Leaf v18 v19) (Branch v50 v51 v52 v53))
        || (v,v2,Branch v20 v21 v22 v23,<{}>) -> I (Branch v20 v21 v22 v23)
        || (v,v2,Branch v20 v21 v22 v23,Leaf v60 v61) ->
             I (Branch v v2 (Branch v20 v21 v22 v23) (Leaf v60 v61))
        || (v,v2,Branch v20 v21 v22 v23,Branch v62 v63 v64 v65) ->
             I
               (Branch v v2 (Branch v20 v21 v22 v23)
                  (Branch v62 v63 v64 v65)))
</PRE>

<DT><STRONG><font color="black">REMOVE_def</font></STRONG>
<DD>
<PRE>
|- (!k. <{}> \\ k = <{}>) /\
   (!j d k. Leaf j d \\ k = if j = k then <{}> else Leaf j d) /\
   !p m l r k.
     Branch p m l r \\ k =
     if MOD_2EXP_EQ m k p then
       if BIT m k then BRANCH (p,m,l \\ k,r) else BRANCH (p,m,l,r \\ k)
     else
       Branch p m l r
</PRE>

<DT><STRONG><font color="black">TRAVERSE_AUX_def</font></STRONG>
<DD>
<PRE>
|- (!a. TRAVERSE_AUX <{}> a = a) /\
   (!k d a. TRAVERSE_AUX (Leaf k d) a = k::a) /\
   !p m l r a.
     TRAVERSE_AUX (Branch p m l r) a = TRAVERSE_AUX l (TRAVERSE_AUX r a)
</PRE>

<DT><STRONG><font color="black">TRAVERSE_def</font></STRONG>
<DD>
<PRE>
|- (TRAVERSE <{}> = []) /\ (!j d. TRAVERSE (Leaf j d) = [j]) /\
   !p m l r. TRAVERSE (Branch p m l r) = TRAVERSE l ++ TRAVERSE r
</PRE>

<DT><STRONG><font color="black">KEYS_def</font></STRONG>
<DD>
<PRE>
|- !t. KEYS t = QSORT $< (TRAVERSE t)
</PRE>

<DT><STRONG><font color="black">TRANSFORM_def</font></STRONG>
<DD>
<PRE>
|- (!f. TRANSFORM f <{}> = <{}>) /\
   (!f j d. TRANSFORM f (Leaf j d) = Leaf j (f d)) /\
   !f p m l r.
     TRANSFORM f (Branch p m l r) = Branch p m (TRANSFORM f l) (TRANSFORM f r)
</PRE>

<DT><STRONG><font color="black">EVERY_LEAF_def</font></STRONG>
<DD>
<PRE>
|- (!P. EVERY_LEAF P <{}> <=> T) /\
   (!P j d. EVERY_LEAF P (Leaf j d) <=> P j d) /\
   !P p m l r.
     EVERY_LEAF P (Branch p m l r) <=> EVERY_LEAF P l /\ EVERY_LEAF P r
</PRE>

<DT><STRONG><font color="black">EXISTS_LEAF_def</font></STRONG>
<DD>
<PRE>
|- (!P. EXISTS_LEAF P <{}> <=> F) /\
   (!P j d. EXISTS_LEAF P (Leaf j d) <=> P j d) /\
   !P p m l r.
     EXISTS_LEAF P (Branch p m l r) <=> EXISTS_LEAF P l \/ EXISTS_LEAF P r
</PRE>

<DT><STRONG><font color="black">SIZE_def</font></STRONG>
<DD>
<PRE>
|- !t. SIZE t = LENGTH (TRAVERSE t)
</PRE>

<DT><STRONG><font color="black">DEPTH_def</font></STRONG>
<DD>
<PRE>
|- (DEPTH <{}> = 0) /\ (!j d. DEPTH (Leaf j d) = 1) /\
   !p m l r. DEPTH (Branch p m l r) = 1 + MAX (DEPTH l) (DEPTH r)
</PRE>

<DT><STRONG><font color="black">IS_PTREE_def</font></STRONG>
<DD>
<PRE>
|- (IS_PTREE <{}> <=> T) /\ (!k d. IS_PTREE (Leaf k d) <=> T) /\
   !p m l r.
     IS_PTREE (Branch p m l r) <=>
     p < 2 ** m /\ IS_PTREE l /\ IS_PTREE r /\ l <> <{}> /\ r <> <{}> /\
     EVERY_LEAF (\k d. MOD_2EXP_EQ m k p /\ BIT m k) l /\
     EVERY_LEAF (\k d. MOD_2EXP_EQ m k p /\ ~BIT m k) r
</PRE>

<DT><STRONG><font color="black">IN_PTREE_def</font></STRONG>
<DD>
<PRE>
|- !n t. n IN_PTREE t <=> IS_SOME (t ' n)
</PRE>

<DT><STRONG><font color="black">INSERT_PTREE_def</font></STRONG>
<DD>
<PRE>
|- !n t. n INSERT_PTREE t = t |+ (n,())
</PRE>

<DT><STRONG><font color="black">PTREE_OF_NUMSET_def</font></STRONG>
<DD>
<PRE>
|- !t s. t |++ s = FOLDL (combin$C $INSERT_PTREE) t (SET_TO_LIST s)
</PRE>

<DT><STRONG><font color="black">NUMSET_OF_PTREE_def</font></STRONG>
<DD>
<PRE>
|- !t. NUMSET_OF_PTREE t = LIST_TO_SET (TRAVERSE t)
</PRE>

<DT><STRONG><font color="black">UNION_PTREE_def</font></STRONG>
<DD>
<PRE>
|- !t1 t2. t1 UNION_PTREE t2 = t1 |++ NUMSET_OF_PTREE t2
</PRE>

<DT><STRONG><font color="black">IS_EMPTY_primitive_def</font></STRONG>
<DD>
<PRE>
|- IS_EMPTY =
   WFREC (@R. WF R)
     (\IS_EMPTY a.
        case a of
           <{}> -> I T
        || Leaf v6 v7 -> I F
        || Branch v8 v9 v10 v11 -> I F)
</PRE>

<DT><STRONG><font color="black">FIND_def</font></STRONG>
<DD>
<PRE>
|- !t k. FIND t k = THE (t ' k)
</PRE>

<DT><STRONG><font color="black">ADD_LIST_def</font></STRONG>
<DD>
<PRE>
|- $|++ = FOLDL $|+
</PRE>

</DL>


<HR>

<HR>
<H1><font color="black">Theorems</font></H1>
<DL>
<DT><STRONG><font color="black">datatype_ptree</font></STRONG>
<DD>
<PRE>
|- DATATYPE (ptree <{}> Leaf Branch)
</PRE>

<DT><STRONG><font color="black">ptree_11</font></STRONG>
<DD>
<PRE>
|- (!a0 a1 a0' a1'.
      (Leaf a0 a1 = Leaf a0' a1') <=> (a0 = a0') /\ (a1 = a1')) /\
   !a0 a1 a2 a3 a0' a1' a2' a3'.
     (Branch a0 a1 a2 a3 = Branch a0' a1' a2' a3') <=>
     (a0 = a0') /\ (a1 = a1') /\ (a2 = a2') /\ (a3 = a3')
</PRE>

<DT><STRONG><font color="black">ptree_distinct</font></STRONG>
<DD>
<PRE>
|- (!a1 a0. <{}> <> Leaf a0 a1) /\
   (!a3 a2 a1 a0. <{}> <> Branch a0 a1 a2 a3) /\
   !a3 a2 a1' a1 a0' a0. Leaf a0 a1 <> Branch a0' a1' a2 a3
</PRE>

<DT><STRONG><font color="black">ptree_case_cong</font></STRONG>
<DD>
<PRE>
|- !M M' v f f1.
     (M = M') /\ ((M' = <{}>) ==> (v = v')) /\
     (!a0 a1. (M' = Leaf a0 a1) ==> (f a0 a1 = f' a0 a1)) /\
     (!a0 a1 a2 a3.
        (M' = Branch a0 a1 a2 a3) ==> (f1 a0 a1 a2 a3 = f1' a0 a1 a2 a3)) ==>
     (ptree_case v f f1 M = ptree_case v' f' f1' M')
</PRE>

<DT><STRONG><font color="black">ptree_nchotomy</font></STRONG>
<DD>
<PRE>
|- !pp.
     (pp = <{}>) \/ (?n a. pp = Leaf n a) \/ ?n0 n p p0. pp = Branch n0 n p p0
</PRE>

<DT><STRONG><font color="black">ptree_Axiom</font></STRONG>
<DD>
<PRE>
|- !f0 f1 f2.
     ?fn.
       (fn <{}> = f0) /\ (!a0 a1. fn (Leaf a0 a1) = f1 a0 a1) /\
       !a0 a1 a2 a3. fn (Branch a0 a1 a2 a3) = f2 a0 a1 a2 a3 (fn a2) (fn a3)
</PRE>

<DT><STRONG><font color="black">ptree_induction</font></STRONG>
<DD>
<PRE>
|- !P.
     P <{}> /\ (!n a. P (Leaf n a)) /\
     (!p p0. P p /\ P p0 ==> !n n0. P (Branch n0 n p p0)) ==>
     !p. P p
</PRE>

<DT><STRONG><font color="black">BRANCHING_BIT_ind</font></STRONG>
<DD>
<PRE>
|- !P.
     (!p0 p1.
        (~((ODD p0 <=> EVEN p1) \/ (p0 = p1)) ==> P (DIV2 p0) (DIV2 p1)) ==>
        P p0 p1) ==>
     !v v1. P v v1
</PRE>

<DT><STRONG><font color="black">BRANCHING_BIT_def</font></STRONG>
<DD>
<PRE>
|- BRANCHING_BIT p0 p1 =
   if (ODD p0 <=> EVEN p1) \/ (p0 = p1) then
     0
   else
     SUC (BRANCHING_BIT (DIV2 p0) (DIV2 p1))
</PRE>

<DT><STRONG><font color="black">PEEK_ind</font></STRONG>
<DD>
<PRE>
|- !P.
     (!k. P <{}> k) /\ (!j d k. P (Leaf j d) k) /\
     (!p m l r k. P (if BIT m k then l else r) k ==> P (Branch p m l r) k) ==>
     !v v1. P v v1
</PRE>

<DT><STRONG><font color="black">PEEK_def</font></STRONG>
<DD>
<PRE>
|- (!k. <{}> ' k = NONE) /\
   (!k j d. Leaf j d ' k = if k = j then SOME d else NONE) /\
   !r p m l k. Branch p m l r ' k = (if BIT m k then l else r) ' k
</PRE>

<DT><STRONG><font color="black">ADD_ind</font></STRONG>
<DD>
<PRE>
|- !P.
     (!k e. P <{}> (k,e)) /\ (!j d k e. P (Leaf j d) (k,e)) /\
     (!p m l r k e.
        (MOD_2EXP_EQ m k p /\ ~BIT m k ==> P r (k,e)) /\
        (MOD_2EXP_EQ m k p /\ BIT m k ==> P l (k,e)) ==>
        P (Branch p m l r) (k,e)) ==>
     !v v1 v2. P v (v1,v2)
</PRE>

<DT><STRONG><font color="black">ADD_def</font></STRONG>
<DD>
<PRE>
|- (!k e. <{}> |+ (k,e) = Leaf k e) /\
   (!k j e d.
      Leaf j d |+ (k,e) =
      if j = k then Leaf k e else JOIN (k,Leaf k e,j,Leaf j d)) /\
   !r p m l k e.
     Branch p m l r |+ (k,e) =
     if MOD_2EXP_EQ m k p then
       if BIT m k then
         Branch p m (l |+ (k,e)) r
       else
         Branch p m l (r |+ (k,e))
     else
       JOIN (k,Leaf k e,p,Branch p m l r)
</PRE>

<DT><STRONG><font color="black">BRANCH_ind</font></STRONG>
<DD>
<PRE>
|- !P.
     (!p m. P (p,m,<{}>,<{}>)) /\ (!p m v24 v25. P (p,m,<{}>,Leaf v24 v25)) /\
     (!p m v26 v27 v28 v29. P (p,m,<{}>,Branch v26 v27 v28 v29)) /\
     (!p m v6 v7. P (p,m,Leaf v6 v7,<{}>)) /\
     (!p m v8 v9 v10 v11. P (p,m,Branch v8 v9 v10 v11,<{}>)) /\
     (!p m v12 v13 v42 v43. P (p,m,Leaf v12 v13,Leaf v42 v43)) /\
     (!p m v12 v13 v44 v45 v46 v47.
        P (p,m,Leaf v12 v13,Branch v44 v45 v46 v47)) /\
     (!p m v14 v15 v16 v17 v54 v55.
        P (p,m,Branch v14 v15 v16 v17,Leaf v54 v55)) /\
     (!p m v14 v15 v16 v17 v56 v57 v58 v59.
        P (p,m,Branch v14 v15 v16 v17,Branch v56 v57 v58 v59)) ==>
     !v v1 v2 v3. P (v,v1,v2,v3)
</PRE>

<DT><STRONG><font color="black">BRANCH_def</font></STRONG>
<DD>
<PRE>
|- (BRANCH (p,m,<{}>,<{}>) = <{}>) /\
   (BRANCH (p,m,<{}>,Leaf v24 v25) = Leaf v24 v25) /\
   (BRANCH (p,m,<{}>,Branch v26 v27 v28 v29) = Branch v26 v27 v28 v29) /\
   (BRANCH (p,m,Leaf v6 v7,<{}>) = Leaf v6 v7) /\
   (BRANCH (p,m,Branch v8 v9 v10 v11,<{}>) = Branch v8 v9 v10 v11) /\
   (BRANCH (p,m,Leaf v12 v13,Leaf v42 v43) =
    Branch p m (Leaf v12 v13) (Leaf v42 v43)) /\
   (BRANCH (p,m,Leaf v12 v13,Branch v44 v45 v46 v47) =
    Branch p m (Leaf v12 v13) (Branch v44 v45 v46 v47)) /\
   (BRANCH (p,m,Branch v14 v15 v16 v17,Leaf v54 v55) =
    Branch p m (Branch v14 v15 v16 v17) (Leaf v54 v55)) /\
   (BRANCH (p,m,Branch v14 v15 v16 v17,Branch v56 v57 v58 v59) =
    Branch p m (Branch v14 v15 v16 v17) (Branch v56 v57 v58 v59))
</PRE>

<DT><STRONG><font color="black">IS_EMPTY_ind</font></STRONG>
<DD>
<PRE>
|- !P.
     P <{}> /\ (!v v1. P (Leaf v v1)) /\
     (!v2 v3 v4 v5. P (Branch v2 v3 v4 v5)) ==>
     !v. P v
</PRE>

<DT><STRONG><font color="black">IS_EMPTY_def</font></STRONG>
<DD>
<PRE>
|- (IS_EMPTY <{}> <=> T) /\ (IS_EMPTY (Leaf v v1) <=> F) /\
   (IS_EMPTY (Branch v2 v3 v4 v5) <=> F)
</PRE>

<DT><STRONG><font color="black">BRANCHING_BIT</font></STRONG>
<DD>
<PRE>
|- !a b.
     a <> b ==> (BIT (BRANCHING_BIT a b) a <=/=> BIT (BRANCHING_BIT a b) b)
</PRE>

<DT><STRONG><font color="black">BRANCHING_BIT_ZERO</font></STRONG>
<DD>
<PRE>
|- !a b. (BRANCHING_BIT a b = 0) <=> (ODD a <=> EVEN b) \/ (a = b)
</PRE>

<DT><STRONG><font color="black">BRANCHING_BIT_SYM</font></STRONG>
<DD>
<PRE>
|- !a b. BRANCHING_BIT a b = BRANCHING_BIT b a
</PRE>

<DT><STRONG><font color="black">EVERY_LEAF_ADD</font></STRONG>
<DD>
<PRE>
|- !P t k d. P k d /\ EVERY_LEAF P t ==> EVERY_LEAF P (t |+ (k,d))
</PRE>

<DT><STRONG><font color="black">MONO_EVERY_LEAF</font></STRONG>
<DD>
<PRE>
|- !P Q t. (!k d. P k d ==> Q k d) /\ EVERY_LEAF P t ==> EVERY_LEAF Q t
</PRE>

<DT><STRONG><font color="black">NOT_ADD_EMPTY</font></STRONG>
<DD>
<PRE>
|- !t k d. t |+ (k,d) <> <{}>
</PRE>

<DT><STRONG><font color="black">EMPTY_IS_PTREE</font></STRONG>
<DD>
<PRE>
|- IS_PTREE <{}>
</PRE>

<DT><STRONG><font color="black">ADD_IS_PTREE</font></STRONG>
<DD>
<PRE>
|- !t x. IS_PTREE t ==> IS_PTREE (t |+ x)
</PRE>

<DT><STRONG><font color="black">EVERY_LEAF_BRANCH</font></STRONG>
<DD>
<PRE>
|- !p m l r.
     EVERY_LEAF P (BRANCH (p,m,l,r)) <=> EVERY_LEAF P l /\ EVERY_LEAF P r
</PRE>

<DT><STRONG><font color="black">EVERY_LEAF_REMOVE</font></STRONG>
<DD>
<PRE>
|- !P t k. EVERY_LEAF P t ==> EVERY_LEAF P (t \\ k)
</PRE>

<DT><STRONG><font color="black">IS_PTREE_BRANCH</font></STRONG>
<DD>
<PRE>
|- !p m l r.
     p < 2 ** m /\ ~((l = <{}>) /\ (r = <{}>)) /\
     EVERY_LEAF (\k d. MOD_2EXP_EQ m k p /\ BIT m k) l /\
     EVERY_LEAF (\k d. MOD_2EXP_EQ m k p /\ ~BIT m k) r /\ IS_PTREE l /\
     IS_PTREE r ==>
     IS_PTREE (BRANCH (p,m,l,r))
</PRE>

<DT><STRONG><font color="black">REMOVE_IS_PTREE</font></STRONG>
<DD>
<PRE>
|- !t k. IS_PTREE t ==> IS_PTREE (t \\ k)
</PRE>

<DT><STRONG><font color="black">PEEK_NONE</font></STRONG>
<DD>
<PRE>
|- !P t k. (!d. ~P k d) /\ EVERY_LEAF P t ==> (t ' k = NONE)
</PRE>

<DT><STRONG><font color="black">PEEK_ADD</font></STRONG>
<DD>
<PRE>
|- !t k d. IS_PTREE t ==> ((t |+ (k,d)) ' j = if k = j then SOME d else t ' j)
</PRE>

<DT><STRONG><font color="black">BRANCH</font></STRONG>
<DD>
<PRE>
|- !k p m l r.
     BRANCH (p,m,l,r) =
     if l = <{}> then r else if r = <{}> then l else Branch p m l r
</PRE>

<DT><STRONG><font color="black">PEEK_REMOVE</font></STRONG>
<DD>
<PRE>
|- !t k j d. IS_PTREE t ==> ((t \\ k) ' j = if k = j then NONE else t ' j)
</PRE>

<DT><STRONG><font color="black">EVERY_LEAF_TRANSFORM</font></STRONG>
<DD>
<PRE>
|- !P Q f t.
     (!k d. P k d ==> Q k (f d)) /\ EVERY_LEAF P t ==>
     EVERY_LEAF Q (TRANSFORM f t)
</PRE>

<DT><STRONG><font color="black">TRANSFORM_EMPTY</font></STRONG>
<DD>
<PRE>
|- !f t. (TRANSFORM f t = <{}>) <=> (t = <{}>)
</PRE>

<DT><STRONG><font color="black">TRANSFORM_IS_PTREE</font></STRONG>
<DD>
<PRE>
|- !f t. IS_PTREE t ==> IS_PTREE (TRANSFORM f t)
</PRE>

<DT><STRONG><font color="black">PEEK_TRANSFORM</font></STRONG>
<DD>
<PRE>
|- !f t k.
     TRANSFORM f t ' k = case t ' k of NONE -> NONE || SOME x -> SOME (f x)
</PRE>

<DT><STRONG><font color="black">ADD_TRANSFORM</font></STRONG>
<DD>
<PRE>
|- !f t k d. TRANSFORM f (t |+ (k,d)) = TRANSFORM f t |+ (k,f d)
</PRE>

<DT><STRONG><font color="black">TRANSFORM_BRANCH</font></STRONG>
<DD>
<PRE>
|- !f p m l r.
     TRANSFORM f (BRANCH (p,m,l,r)) = BRANCH (p,m,TRANSFORM f l,TRANSFORM f r)
</PRE>

<DT><STRONG><font color="black">REMOVE_TRANSFORM</font></STRONG>
<DD>
<PRE>
|- !f t k. TRANSFORM f (t \\ k) = TRANSFORM f t \\ k
</PRE>

<DT><STRONG><font color="black">REMOVE_ADD_EQ</font></STRONG>
<DD>
<PRE>
|- !t k d. t |+ (k,d) \\ k = t \\ k
</PRE>

<DT><STRONG><font color="black">ADD_ADD</font></STRONG>
<DD>
<PRE>
|- !t k d e. t |+ (k,d) |+ (k,e) = t |+ (k,e)
</PRE>

<DT><STRONG><font color="black">EVERY_LEAF_PEEK</font></STRONG>
<DD>
<PRE>
|- !P t k. EVERY_LEAF P t /\ IS_SOME (t ' k) ==> P k (THE (t ' k))
</PRE>

<DT><STRONG><font color="black">IS_PTREE_PEEK</font></STRONG>
<DD>
<PRE>
|- (!k. ~IS_SOME (<{}> ' k)) /\
   (!k j b. IS_SOME (Leaf j b ' k) <=> (j = k)) /\
   !p m l r.
     IS_PTREE (Branch p m l r) ==>
     (?k. BIT m k /\ IS_SOME (l ' k)) /\ (?k. ~BIT m k /\ IS_SOME (r ' k)) /\
     !k n.
       ~MOD_2EXP_EQ m k p \/ n < m /\ (BIT n p <=/=> BIT n k) ==>
       ~IS_SOME (l ' k) /\ ~IS_SOME (r ' k)
</PRE>

<DT><STRONG><font color="black">PTREE_EQ</font></STRONG>
<DD>
<PRE>
|- !t1 t2.
     IS_PTREE t1 /\ IS_PTREE t2 ==> ((!k. t1 ' k = t2 ' k) <=> (t1 = t2))
</PRE>

<DT><STRONG><font color="black">REMOVE_REMOVE</font></STRONG>
<DD>
<PRE>
|- !t k. IS_PTREE t ==> (t \\ k \\ k = t \\ k)
</PRE>

<DT><STRONG><font color="black">REMOVE_ADD</font></STRONG>
<DD>
<PRE>
|- !t k d.
     IS_PTREE t ==>
     (t |+ (k,d) \\ j = if k = j then t \\ j else t \\ j |+ (k,d))
</PRE>

<DT><STRONG><font color="black">ADD_ADD_SYM</font></STRONG>
<DD>
<PRE>
|- !t k j d e.
     IS_PTREE t /\ k <> j ==> (t |+ (k,d) |+ (j,e) = t |+ (j,e) |+ (k,d))
</PRE>

<DT><STRONG><font color="black">LIST_EQ</font></STRONG>
<DD>
<PRE>
|- !a b.
     (LENGTH a = LENGTH b) /\ (!x. x < LENGTH a ==> (EL x a = EL x b)) ==>
     (a = b)
</PRE>

<DT><STRONG><font color="black">FILTER_ALL</font></STRONG>
<DD>
<PRE>
|- !P l. (!n. n < LENGTH l ==> ~P (EL n l)) <=> (FILTER P l = [])
</PRE>

<DT><STRONG><font color="black">TRAVERSE_TRANSFORM</font></STRONG>
<DD>
<PRE>
|- !f t. TRAVERSE (TRANSFORM f t) = TRAVERSE t
</PRE>

<DT><STRONG><font color="black">MEM_TRAVERSE_PEEK</font></STRONG>
<DD>
<PRE>
|- !t k. IS_PTREE t ==> (MEM k (TRAVERSE t) <=> IS_SOME (t ' k))
</PRE>

<DT><STRONG><font color="black">IN_NUMSET_OF_PTREE</font></STRONG>
<DD>
<PRE>
|- !t n. IS_PTREE t ==> (n IN NUMSET_OF_PTREE t <=> n IN_PTREE t)
</PRE>

<DT><STRONG><font color="black">ADD_LIST_IS_PTREE</font></STRONG>
<DD>
<PRE>
|- !t l. IS_PTREE t ==> IS_PTREE (t |++ l)
</PRE>

<DT><STRONG><font color="black">PTREE_OF_NUMSET_IS_PTREE</font></STRONG>
<DD>
<PRE>
|- !t s. IS_PTREE t ==> IS_PTREE (t |++ s)
</PRE>

<DT><STRONG><font color="black">PTREE_OF_NUMSET_IS_PTREE_EMPTY</font></STRONG>
<DD>
<PRE>
|- !s. IS_PTREE (<{}> |++ s)
</PRE>

<DT><STRONG><font color="black">NOT_KEY_LEFT_AND_RIGHT</font></STRONG>
<DD>
<PRE>
|- !p m l r k j.
     IS_PTREE (Branch p m l r) /\ IS_SOME (l ' k) /\ IS_SOME (r ' j) ==>
     k <> j
</PRE>

<DT><STRONG><font color="black">ALL_DISTINCT_TRAVERSE</font></STRONG>
<DD>
<PRE>
|- !t. IS_PTREE t ==> ALL_DISTINCT (TRAVERSE t)
</PRE>

<DT><STRONG><font color="black">MEM_ALL_DISTINCT_IMP_PERM</font></STRONG>
<DD>
<PRE>
|- !l1 l2.
     ALL_DISTINCT l1 /\ ALL_DISTINCT l2 /\ (!x. MEM x l1 <=> MEM x l2) ==>
     PERM l1 l2
</PRE>

<DT><STRONG><font color="black">MEM_TRAVERSE</font></STRONG>
<DD>
<PRE>
|- !t k. IS_PTREE t ==> (MEM k (TRAVERSE t) <=> k IN NUMSET_OF_PTREE t)
</PRE>

<DT><STRONG><font color="black">INSERT_PTREE_IS_PTREE</font></STRONG>
<DD>
<PRE>
|- !t x. IS_PTREE t ==> IS_PTREE (x INSERT_PTREE t)
</PRE>

<DT><STRONG><font color="black">FINITE_NUMSET_OF_PTREE</font></STRONG>
<DD>
<PRE>
|- !t. FINITE (NUMSET_OF_PTREE t)
</PRE>

<DT><STRONG><font color="black">ADD_INSERT</font></STRONG>
<DD>
<PRE>
|- !v t n. t |+ (n,v) = n INSERT_PTREE t
</PRE>

<DT><STRONG><font color="black">PEEK_INSERT_PTREE</font></STRONG>
<DD>
<PRE>
|- !t j k d.
     IS_PTREE t ==>
     ((k INSERT_PTREE t) ' j = if k = j then SOME () else t ' j)
</PRE>

<DT><STRONG><font color="black">MEM_TRAVERSE_INSERT_PTREE</font></STRONG>
<DD>
<PRE>
|- !t x.
     IS_PTREE t ==>
     (MEM x (TRAVERSE (h INSERT_PTREE t)) <=>
      (x = h) \/ x <> h /\ MEM x (TRAVERSE t))
</PRE>

<DT><STRONG><font color="black">PERM_INSERT_PTREE</font></STRONG>
<DD>
<PRE>
|- !t s.
     FINITE s ==>
     IS_PTREE t ==>
     PERM (TRAVERSE (FOLDL (combin$C $INSERT_PTREE) t (SET_TO_LIST s)))
       (SET_TO_LIST (NUMSET_OF_PTREE t UNION s))
</PRE>

<DT><STRONG><font color="black">IN_PTREE_OF_NUMSET</font></STRONG>
<DD>
<PRE>
|- !t s n.
     IS_PTREE t /\ FINITE s ==>
     (n IN_PTREE t |++ s <=> n IN_PTREE t \/ n IN s)
</PRE>

<DT><STRONG><font color="black">IN_PTREE_EMPTY</font></STRONG>
<DD>
<PRE>
|- !n. ~(n IN_PTREE <{}>)
</PRE>

<DT><STRONG><font color="black">IN_PTREE_OF_NUMSET_EMPTY</font></STRONG>
<DD>
<PRE>
|- !s n. FINITE s ==> (n IN s <=> n IN_PTREE <{}> |++ s)
</PRE>

<DT><STRONG><font color="black">PTREE_EXTENSION</font></STRONG>
<DD>
<PRE>
|- !t1 t2.
     IS_PTREE t1 /\ IS_PTREE t2 ==>
     ((t1 = t2) <=> !x. x IN_PTREE t1 <=> x IN_PTREE t2)
</PRE>

<DT><STRONG><font color="black">PTREE_OF_NUMSET_NUMSET_OF_PTREE</font></STRONG>
<DD>
<PRE>
|- !s n.
     IS_PTREE t /\ FINITE s ==>
     (<{}> |++ (NUMSET_OF_PTREE t UNION s) = t |++ s)
</PRE>

<DT><STRONG><font color="black">NUMSET_OF_PTREE_PTREE_OF_NUMSET</font></STRONG>
<DD>
<PRE>
|- !t s.
     IS_PTREE t /\ FINITE s ==>
     (NUMSET_OF_PTREE (t |++ s) = NUMSET_OF_PTREE t UNION s)
</PRE>

<DT><STRONG><font color="black">NUMSET_OF_PTREE_EMPTY</font></STRONG>
<DD>
<PRE>
|- NUMSET_OF_PTREE <{}> = {}
</PRE>

<DT><STRONG><font color="black">PTREE_OF_NUMSET_EMPTY</font></STRONG>
<DD>
<PRE>
|- !t. t |++ {} = t
</PRE>

<DT><STRONG><font color="black">NUMSET_OF_PTREE_PTREE_OF_NUMSET_EMPTY</font></STRONG>
<DD>
<PRE>
|- !s. FINITE s ==> (NUMSET_OF_PTREE (<{}> |++ s) = s)
</PRE>

<DT><STRONG><font color="black">IN_PTREE_INSERT_PTREE</font></STRONG>
<DD>
<PRE>
|- !t m n.
     IS_PTREE t ==> (n IN_PTREE m INSERT_PTREE t <=> (m = n) \/ n IN_PTREE t)
</PRE>

<DT><STRONG><font color="black">IN_PTREE_REMOVE</font></STRONG>
<DD>
<PRE>
|- !t m n. IS_PTREE t ==> (n IN_PTREE t \\ m <=> n <> m /\ n IN_PTREE t)
</PRE>

<DT><STRONG><font color="black">IN_PTREE_UNION_PTREE</font></STRONG>
<DD>
<PRE>
|- !t1 t2 n.
     IS_PTREE t1 /\ IS_PTREE t2 ==>
     (n IN_PTREE t1 UNION_PTREE t2 <=> n IN_PTREE t1 \/ n IN_PTREE t2)
</PRE>

<DT><STRONG><font color="black">UNION_PTREE_IS_PTREE</font></STRONG>
<DD>
<PRE>
|- !t1 t2. IS_PTREE t1 /\ IS_PTREE t2 ==> IS_PTREE (t1 UNION_PTREE t2)
</PRE>

<DT><STRONG><font color="black">UNION_PTREE_COMM</font></STRONG>
<DD>
<PRE>
|- !t1 t2.
     IS_PTREE t1 /\ IS_PTREE t2 ==> (t1 UNION_PTREE t2 = t2 UNION_PTREE t1)
</PRE>

<DT><STRONG><font color="black">UNION_PTREE_COMM_EMPTY</font></STRONG>
<DD>
<PRE>
|- !t. IS_PTREE t ==> (<{}> UNION_PTREE t = t UNION_PTREE <{}>)
</PRE>

<DT><STRONG><font color="black">UNION_PTREE_EMPTY</font></STRONG>
<DD>
<PRE>
|- (!t. t UNION_PTREE <{}> = t) /\ !t. IS_PTREE t ==> (<{}> UNION_PTREE t = t)
</PRE>

<DT><STRONG><font color="black">UNION_PTREE_ASSOC</font></STRONG>
<DD>
<PRE>
|- !t1 t2 t3.
     IS_PTREE t1 /\ IS_PTREE t2 /\ IS_PTREE t3 ==>
     (t1 UNION_PTREE (t2 UNION_PTREE t3) = t1 UNION_PTREE t2 UNION_PTREE t3)
</PRE>

<DT><STRONG><font color="black">PTREE_OF_NUMSET_UNION</font></STRONG>
<DD>
<PRE>
|- !t s1 s2.
     IS_PTREE t /\ FINITE s1 /\ FINITE s2 ==>
     (t |++ (s1 UNION s2) = t |++ s1 |++ s2)
</PRE>

<DT><STRONG><font color="black">PTREE_OF_NUMSET_INSERT</font></STRONG>
<DD>
<PRE>
|- !t s x.
     IS_PTREE t /\ FINITE s ==> (t |++ (x INSERT s) = x INSERT_PTREE t |++ s)
</PRE>

<DT><STRONG><font color="black">PTREE_OF_NUMSET_INSERT_EMPTY</font></STRONG>
<DD>
<PRE>
|- !s x. FINITE s ==> (<{}> |++ (x INSERT s) = x INSERT_PTREE <{}> |++ s)
</PRE>

<DT><STRONG><font color="black">PTREE_OF_NUMSET_DELETE</font></STRONG>
<DD>
<PRE>
|- !s x. FINITE s ==> (<{}> |++ (s DELETE x) = (<{}> |++ s) \\ x)
</PRE>

<DT><STRONG><font color="black">TRAVERSE_AUX</font></STRONG>
<DD>
<PRE>
|- !t. TRAVERSE t = TRAVERSE_AUX t []
</PRE>

<DT><STRONG><font color="black">PTREE_TRAVERSE_EQ</font></STRONG>
<DD>
<PRE>
|- !t1 t2.
     IS_PTREE t1 /\ IS_PTREE t2 ==>
     ((!k. MEM k (TRAVERSE t1) <=> MEM k (TRAVERSE t2)) <=>
      (TRAVERSE t1 = TRAVERSE t2))
</PRE>

<DT><STRONG><font color="black">QSORT_MEM_EQ</font></STRONG>
<DD>
<PRE>
|- !l2 l1 R. (QSORT R l1 = QSORT R l2) ==> !x. MEM x l1 <=> MEM x l2
</PRE>

<DT><STRONG><font color="black">KEYS_PEEK</font></STRONG>
<DD>
<PRE>
|- !t1 t2.
     IS_PTREE t1 /\ IS_PTREE t2 ==>
     ((KEYS t1 = KEYS t2) <=> (TRAVERSE t1 = TRAVERSE t2))
</PRE>

<DT><STRONG><font color="black">PERM_ADD</font></STRONG>
<DD>
<PRE>
|- !t k d.
     IS_PTREE t /\ ~MEM k (TRAVERSE t) ==>
     PERM (TRAVERSE (t |+ (k,d))) (k::TRAVERSE t)
</PRE>

<DT><STRONG><font color="black">PERM_NOT_ADD</font></STRONG>
<DD>
<PRE>
|- !t k d.
     IS_PTREE t /\ MEM k (TRAVERSE t) ==> (TRAVERSE (t |+ (k,d)) = TRAVERSE t)
</PRE>

<DT><STRONG><font color="black">PERM_NOT_REMOVE</font></STRONG>
<DD>
<PRE>
|- !t k.
     IS_PTREE t /\ ~MEM k (TRAVERSE t) ==> (TRAVERSE (t \\ k) = TRAVERSE t)
</PRE>

<DT><STRONG><font color="black">PERM_DELETE_PTREE</font></STRONG>
<DD>
<PRE>
|- !t k d.
     IS_PTREE t /\ MEM k (TRAVERSE t) ==>
     PERM (TRAVERSE (t \\ k)) (FILTER (\x. x <> k) (TRAVERSE t))
</PRE>

<DT><STRONG><font color="black">FILTER_NONE</font></STRONG>
<DD>
<PRE>
|- !l. (!n. n < LENGTH l ==> P (EL n l)) ==> (FILTER P l = l)
</PRE>

<DT><STRONG><font color="black">PERM_REMOVE</font></STRONG>
<DD>
<PRE>
|- !t k d.
     IS_PTREE t /\ MEM k (TRAVERSE t) ==>
     PERM (TRAVERSE (t \\ k)) (FILTER (\x. x <> k) (TRAVERSE t))
</PRE>

<DT><STRONG><font color="black">SIZE_ADD</font></STRONG>
<DD>
<PRE>
|- !t k d.
     IS_PTREE t ==>
     (SIZE (t |+ (k,d)) = if MEM k (TRAVERSE t) then SIZE t else SIZE t + 1)
</PRE>

<DT><STRONG><font color="black">SIZE_REMOVE</font></STRONG>
<DD>
<PRE>
|- !t k d.
     IS_PTREE t ==>
     (SIZE (t \\ k) = if MEM k (TRAVERSE t) then SIZE t - 1 else SIZE t)
</PRE>

<DT><STRONG><font color="black">SIZE</font></STRONG>
<DD>
<PRE>
|- (SIZE <{}> = 0) /\ (!k d. SIZE (Leaf k d) = 1) /\
   !p m l r. SIZE (Branch p m l r) = SIZE l + SIZE r
</PRE>

<DT><STRONG><font color="black">SIZE_PTREE_OF_NUMSET</font></STRONG>
<DD>
<PRE>
|- !t s.
     FINITE s ==>
     IS_PTREE t /\ ALL_DISTINCT (TRAVERSE t ++ SET_TO_LIST s) ==>
     (SIZE (t |++ s) = SIZE t + CARD s)
</PRE>

<DT><STRONG><font color="black">SIZE_PTREE_OF_NUMSET_EMPTY</font></STRONG>
<DD>
<PRE>
|- !s. FINITE s ==> (SIZE (<{}> |++ s) = CARD s)
</PRE>

<DT><STRONG><font color="black">CARD_LIST_TO_SET</font></STRONG>
<DD>
<PRE>
|- !l. ALL_DISTINCT l ==> (CARD (LIST_TO_SET l) = LENGTH l)
</PRE>

<DT><STRONG><font color="black">CARD_NUMSET_OF_PTREE</font></STRONG>
<DD>
<PRE>
|- !t. IS_PTREE t ==> (CARD (NUMSET_OF_PTREE t) = SIZE t)
</PRE>

<DT><STRONG><font color="black">DELETE_UNION</font></STRONG>
<DD>
<PRE>
|- !x s1 s2. s1 UNION s2 DELETE x = s1 DELETE x UNION (s2 DELETE x)
</PRE>

</DL>



<HR>
</BODY>
</HTML>
