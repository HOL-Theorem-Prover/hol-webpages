<HTML>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Theory: prob_uniform</TITLE><meta http-equiv="content-type" content="text/html;charset=UTF-8">
</HEAD>
<BODY bgcolor=linen text=midnightblue>
<H1><font color="black">Theory "prob_uniform"</font></H1>
<STRONG><font size=+3 color="black">Parents</font></STRONG>&nbsp;&nbsp;&nbsp;&nbsp;
    <A HREF = "prob_indepTheory.html"><STRONG><font color="black">prob_indep</font></STRONG></A>

<H1><font color="black">Signature</font></H1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr>
    <th>
    <font color="crimson">Constant</font>
    <th>
    <font color="crimson">Type</font><tr><td>
                                         <STRONG><font color="black">unif</font></STRONG>
                                         <td>
                                         :num ->
                                          (num -> bool) -> num # (num -> bool)
    <tr><td>
        <STRONG><font color="black">unif_bound</font></STRONG>
        <td>
        :num -> num
    <tr><td>
        <STRONG><font color="black">unif_tupled</font></STRONG>
        <td>
        :num # (num -> bool) -> num # (num -> bool)
    <tr><td>
        <STRONG><font color="black">uniform</font></STRONG>
        <td>
        :num -> num -> (num -> bool) -> num # (num -> bool)
    <tr><td>
        <STRONG><font color="black">uniform_tupled</font></STRONG>
        <td>
        :num # num # (num -> bool) -> num # (num -> bool)
    
</table>
</center>

<H1><font color="black">Definitions</font></H1>
<DL>
<DT><STRONG><font color="black">unif_bound_primitive_def</font></STRONG>
<DD>
<PRE>
|- unif_bound =
   WFREC (@R. WF R /\ !v. R (SUC v DIV 2) (SUC v))
     (\unif_bound a.
        case a of 0 -> I 0 || SUC v1 -> I (SUC (unif_bound (SUC v1 DIV 2))))
</PRE>

<DT><STRONG><font color="black">unif_tupled_primitive_def</font></STRONG>
<DD>
<PRE>
|- unif_tupled =
   WFREC (@R. WF R /\ !s v2. R (SUC v2 DIV 2,s) (SUC v2,s))
     (\unif_tupled a.
        case a of
           (0,s) -> I (0,s)
        || (SUC v3,s) ->
             I
               (let (m,s') = unif_tupled (SUC v3 DIV 2,s) in
                  (if SHD s' then 2 * m + 1 else 2 * m,STL s')))
</PRE>

<DT><STRONG><font color="black">unif_curried_def</font></STRONG>
<DD>
<PRE>
|- !x x1. unif x x1 = unif_tupled (x,x1)
</PRE>

<DT><STRONG><font color="black">uniform_tupled_primitive_def</font></STRONG>
<DD>
<PRE>
|- uniform_tupled =
   WFREC
     (@R.
        WF R /\
        !t s n res s'.
          ((res,s') = unif n s) /\ ~(res < SUC n) ==>
          R (t,SUC n,s') (SUC t,SUC n,s))
     (\uniform_tupled a.
        case a of
           (0,0,s) -> ARB
        || (0,SUC n,s) -> I (0,s)
        || (SUC t,0,s') -> ARB
        || (SUC t,SUC n',s') ->
             I
               (let (res,s') = unif n' s' in
                  if res < SUC n' then
                    (res,s')
                  else
                    uniform_tupled (t,SUC n',s')))
</PRE>

<DT><STRONG><font color="black">uniform_curried_def</font></STRONG>
<DD>
<PRE>
|- !x x1 x2. uniform x x1 x2 = uniform_tupled (x,x1,x2)
</PRE>

</DL>


<HR>

<HR>
<H1><font color="black">Theorems</font></H1>
<DL>
<DT><STRONG><font color="black">unif_bound_def</font></STRONG>
<DD>
<PRE>
|- (unif_bound 0 = 0) /\ (unif_bound (SUC v) = SUC (unif_bound (SUC v DIV 2)))
</PRE>

<DT><STRONG><font color="black">unif_bound_ind</font></STRONG>
<DD>
<PRE>
|- !P. P 0 /\ (!v. P (SUC v DIV 2) ==> P (SUC v)) ==> !v. P v
</PRE>

<DT><STRONG><font color="black">unif_def</font></STRONG>
<DD>
<PRE>
|- (unif 0 s = (0,s)) /\
   (unif (SUC v2) s =
    (let (m,s') = unif (SUC v2 DIV 2) s in
       (if SHD s' then 2 * m + 1 else 2 * m,STL s')))
</PRE>

<DT><STRONG><font color="black">unif_ind</font></STRONG>
<DD>
<PRE>
|- !P.
     (!s. P 0 s) /\ (!v2 s. P (SUC v2 DIV 2) s ==> P (SUC v2) s) ==>
     !v v1. P v v1
</PRE>

<DT><STRONG><font color="black">uniform_ind</font></STRONG>
<DD>
<PRE>
|- !P.
     (!n s. P 0 (SUC n) s) /\
     (!t n s.
        (!res s'.
           ((res,s') = unif n s) /\ ~(res < SUC n) ==> P t (SUC n) s') ==>
        P (SUC t) (SUC n) s) /\ (!v6. P 0 0 v6) /\
     (!t v10. P (SUC t) 0 v10) ==>
     !v v1 v2. P v v1 v2
</PRE>

<DT><STRONG><font color="black">uniform_def</font></STRONG>
<DD>
<PRE>
|- (!s n. uniform 0 (SUC n) s = (0,s)) /\
   !t s n.
     uniform (SUC t) (SUC n) s =
     (let (res,s') = unif n s in
        if res < SUC n then (res,s') else uniform t (SUC n) s')
</PRE>

<DT><STRONG><font color="black">SUC_DIV_TWO_ZERO</font></STRONG>
<DD>
<PRE>
|- !n. (SUC n DIV 2 = 0) <=> (n = 0)
</PRE>

<DT><STRONG><font color="black">UNIF_BOUND_LOWER</font></STRONG>
<DD>
<PRE>
|- !n. n < 2 ** unif_bound n
</PRE>

<DT><STRONG><font color="black">UNIF_BOUND_LOWER_SUC</font></STRONG>
<DD>
<PRE>
|- !n. SUC n <= 2 ** unif_bound n
</PRE>

<DT><STRONG><font color="black">UNIF_BOUND_UPPER</font></STRONG>
<DD>
<PRE>
|- !n. n <> 0 ==> 2 ** unif_bound n <= 2 * n
</PRE>

<DT><STRONG><font color="black">UNIF_BOUND_UPPER_SUC</font></STRONG>
<DD>
<PRE>
|- !n. 2 ** unif_bound n <= SUC (2 * n)
</PRE>

<DT><STRONG><font color="black">UNIF_DEF_MONAD</font></STRONG>
<DD>
<PRE>
|- (unif 0 = UNIT 0) /\
   !n.
     unif (SUC n) =
     BIND (unif (SUC n DIV 2))
       (\m. BIND SDEST (\b. UNIT (if b then 2 * m + 1 else 2 * m)))
</PRE>

<DT><STRONG><font color="black">UNIFORM_DEF_MONAD</font></STRONG>
<DD>
<PRE>
|- (!n. uniform 0 (SUC n) = UNIT 0) /\
   !t n.
     uniform (SUC t) (SUC n) =
     BIND (unif n) (\m. if m < SUC n then UNIT m else uniform t (SUC n))
</PRE>

<DT><STRONG><font color="black">INDEP_UNIF</font></STRONG>
<DD>
<PRE>
|- !n. indep (unif n)
</PRE>

<DT><STRONG><font color="black">INDEP_UNIFORM</font></STRONG>
<DD>
<PRE>
|- !t n. indep (uniform t (SUC n))
</PRE>

<DT><STRONG><font color="black">PROB_UNIF</font></STRONG>
<DD>
<PRE>
|- !n k.
     prob (\s. FST (unif n s) = k) =
     if k < 2 ** unif_bound n then (1 / 2) pow unif_bound n else 0
</PRE>

<DT><STRONG><font color="black">UNIF_RANGE</font></STRONG>
<DD>
<PRE>
|- !n s. FST (unif n s) < 2 ** unif_bound n
</PRE>

<DT><STRONG><font color="black">PROB_UNIF_PAIR</font></STRONG>
<DD>
<PRE>
|- !n k k'.
     (prob (\s. FST (unif n s) = k) = prob (\s. FST (unif n s) = k')) <=>
     (k < 2 ** unif_bound n <=> k' < 2 ** unif_bound n)
</PRE>

<DT><STRONG><font color="black">PROB_UNIF_BOUND</font></STRONG>
<DD>
<PRE>
|- !n k.
     k <= 2 ** unif_bound n ==>
     (prob (\s. FST (unif n s) < k) = &k * (1 / 2) pow unif_bound n)
</PRE>

<DT><STRONG><font color="black">PROB_UNIF_GOOD</font></STRONG>
<DD>
<PRE>
|- !n. 1 / 2 <= prob (\s. FST (unif n s) < SUC n)
</PRE>

<DT><STRONG><font color="black">UNIFORM_RANGE</font></STRONG>
<DD>
<PRE>
|- !t n s. FST (uniform t (SUC n) s) < SUC n
</PRE>

<DT><STRONG><font color="black">PROB_UNIFORM_LOWER_BOUND</font></STRONG>
<DD>
<PRE>
|- !b.
     (!k. k < SUC n ==> prob (\s. FST (uniform t (SUC n) s) = k) < b) ==>
     !m.
       m < SUC n ==> prob (\s. FST (uniform t (SUC n) s) < SUC m) < &SUC m * b
</PRE>

<DT><STRONG><font color="black">PROB_UNIFORM_UPPER_BOUND</font></STRONG>
<DD>
<PRE>
|- !b.
     (!k. k < SUC n ==> b < prob (\s. FST (uniform t (SUC n) s) = k)) ==>
     !m.
       m < SUC n ==> &SUC m * b < prob (\s. FST (uniform t (SUC n) s) < SUC m)
</PRE>

<DT><STRONG><font color="black">PROB_UNIFORM_PAIR_SUC</font></STRONG>
<DD>
<PRE>
|- !t n k k'.
     k < SUC n /\ k' < SUC n ==>
     abs
       (prob (\s. FST (uniform t (SUC n) s) = k) -
        prob (\s. FST (uniform t (SUC n) s) = k')) <= (1 / 2) pow t
</PRE>

<DT><STRONG><font color="black">PROB_UNIFORM_SUC</font></STRONG>
<DD>
<PRE>
|- !t n k.
     k < SUC n ==>
     abs (prob (\s. FST (uniform t (SUC n) s) = k) - 1 / &SUC n) <=
     (1 / 2) pow t
</PRE>

<DT><STRONG><font color="black">PROB_UNIFORM</font></STRONG>
<DD>
<PRE>
|- !t n k.
     k < n ==>
     abs (prob (\s. FST (uniform t n s) = k) - 1 / &n) <= (1 / 2) pow t
</PRE>

</DL>



<HR>
</BODY>
</HTML>
