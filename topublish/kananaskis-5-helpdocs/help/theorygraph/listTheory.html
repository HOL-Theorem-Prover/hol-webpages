<HTML>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Theory: list</TITLE><meta http-equiv="content-type" content="text/html;charset=UTF-8">
</HEAD>
<BODY bgcolor=linen text=midnightblue>
<H1><font color="black">Theory "list"</font></H1>
<STRONG><font size=+3 color="black">Parents</font></STRONG>&nbsp;&nbsp;&nbsp;&nbsp;
    <A HREF = "pred_setTheory.html"><STRONG><font color="black">pred_set</font></STRONG></A>&nbsp;&nbsp;
    <A HREF = "operatorTheory.html"><STRONG><font color="black">operator</font></STRONG></A>&nbsp;&nbsp;
    <A HREF = "ind_typeTheory.html"><STRONG><font color="black">ind_type</font></STRONG></A>

<H1><font color="black">Signature</font></H1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr>
    <th>
    <font color="crimson">Type</font>
    <th>
    <font color="crimson">Arity</font><tr><td>
                                          <STRONG><font color="black">list</font></STRONG>
                                          <td>
                                          1
    <tr>
    <th>
    <font color="crimson">Constant</font>
    <th>
    <font color="crimson">Type</font><tr><td>
                                         <STRONG><font color="black">ALL_DISTINCT</font></STRONG>
                                         <td>
                                         :'a list -> bool
    <tr><td>
        <STRONG><font color="black">APPEND</font></STRONG>
        <td>
        :'a list -> 'a list -> 'a list
    <tr><td>
        <STRONG><font color="black">CONS</font></STRONG>
        <td>
        :'a -> 'a list -> 'a list
    <tr><td>
        <STRONG><font color="black">DROP</font></STRONG>
        <td>
        :num -> 'a list -> 'a list
    <tr><td>
        <STRONG><font color="black">EL</font></STRONG>
        <td>
        :num -> 'a list -> 'a
    <tr><td>
        <STRONG><font color="black">EVERY</font></STRONG>
        <td>
        :('a -> bool) -> 'a list -> bool
    <tr><td>
        <STRONG><font color="black">EXISTS</font></STRONG>
        <td>
        :('a -> bool) -> 'a list -> bool
    <tr><td>
        <STRONG><font color="black">FILTER</font></STRONG>
        <td>
        :('a -> bool) -> 'a list -> 'a list
    <tr><td>
        <STRONG><font color="black">FLAT</font></STRONG>
        <td>
        :'a list list -> 'a list
    <tr><td>
        <STRONG><font color="black">FOLDL</font></STRONG>
        <td>
        :('b -> 'a -> 'b) -> 'b -> 'a list -> 'b
    <tr><td>
        <STRONG><font color="black">FOLDR</font></STRONG>
        <td>
        :('a -> 'b -> 'b) -> 'b -> 'a list -> 'b
    <tr><td>
        <STRONG><font color="black">FRONT</font></STRONG>
        <td>
        :'a list -> 'a list
    <tr><td>
        <STRONG><font color="black">HD</font></STRONG>
        <td>
        :'a list -> 'a
    <tr><td>
        <STRONG><font color="black">LAST</font></STRONG>
        <td>
        :'a list -> 'a
    <tr><td>
        <STRONG><font color="black">LEN</font></STRONG>
        <td>
        :'a list -> num -> num
    <tr><td>
        <STRONG><font color="black">LENGTH</font></STRONG>
        <td>
        :'a list -> num
    <tr><td>
        <STRONG><font color="black">LIST_TO_SET</font></STRONG>
        <td>
        :'a list -> 'a -> bool
    <tr><td>
        <STRONG><font color="black">MAP</font></STRONG>
        <td>
        :('a -> 'b) -> 'a list -> 'b list
    <tr><td>
        <STRONG><font color="black">MAP2</font></STRONG>
        <td>
        :('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list
    <tr><td>
        <STRONG><font color="black">MEM</font></STRONG>
        <td>
        :'a -> 'a list -> bool
    <tr><td> <STRONG><font color="black">NIL</font></STRONG> <td> :'a list
    <tr><td>
        <STRONG><font color="black">NULL</font></STRONG>
        <td>
        :'a list -> bool
    <tr><td>
        <STRONG><font color="black">REV</font></STRONG>
        <td>
        :'a list -> 'a list -> 'a list
    <tr><td>
        <STRONG><font color="black">REVERSE</font></STRONG>
        <td>
        :'a list -> 'a list
    <tr><td>
        <STRONG><font color="black">SET_TO_LIST</font></STRONG>
        <td>
        :('a -> bool) -> 'a list
    <tr><td>
        <STRONG><font color="black">SUM</font></STRONG>
        <td>
        :num list -> num
    <tr><td>
        <STRONG><font color="black">TAKE</font></STRONG>
        <td>
        :num -> 'a list -> 'a list
    <tr><td>
        <STRONG><font color="black">TL</font></STRONG>
        <td>
        :'a list -> 'a list
    <tr><td>
        <STRONG><font color="black">UNZIP</font></STRONG>
        <td>
        :('a # 'b) list -> 'a list # 'b list
    <tr><td>
        <STRONG><font color="black">ZIP</font></STRONG>
        <td>
        :'a list # 'b list -> ('a # 'b) list
    <tr><td>
        <STRONG><font color="black">dest_list</font></STRONG>
        <td>
        :'a list -> 'a recspace
    <tr><td>
        <STRONG><font color="black">isPREFIX</font></STRONG>
        <td>
        :'a list -> 'a list -> bool
    <tr><td>
        <STRONG><font color="black">listRel</font></STRONG>
        <td>
        :('a -> 'b -> bool) -> 'a list -> 'b list -> bool
    <tr><td>
        <STRONG><font color="black">list_case</font></STRONG>
        <td>
        :'b -> ('a -> 'a list -> 'b) -> 'a list -> 'b
    <tr><td>
        <STRONG><font color="black">list_size</font></STRONG>
        <td>
        :('a -> num) -> 'a list -> num
    <tr><td>
        <STRONG><font color="black">mk_list</font></STRONG>
        <td>
        :'a recspace -> 'a list
    
</table>
</center>

<H1><font color="black">Definitions</font></H1>
<DL>
<DT><STRONG><font color="black">MAP2</font></STRONG>
<DD>
<PRE>
|- (!f. MAP2 f [] [] = []) /\
   !f h1 t1 h2 t2. MAP2 f (h1::t1) (h2::t2) = f h1 h2::MAP2 f t1 t2
</PRE>

<DT><STRONG><font color="black">EL</font></STRONG>
<DD>
<PRE>
|- (!l. EL 0 l = HD l) /\ !l n. EL (SUC n) l = EL n (TL l)
</PRE>

<DT><STRONG><font color="black">EXISTS_DEF</font></STRONG>
<DD>
<PRE>
|- (!P. EXISTS P [] <=> F) /\ !P h t. EXISTS P (h::t) <=> P h \/ EXISTS P t
</PRE>

<DT><STRONG><font color="black">EVERY_DEF</font></STRONG>
<DD>
<PRE>
|- (!P. EVERY P [] <=> T) /\ !P h t. EVERY P (h::t) <=> P h /\ EVERY P t
</PRE>

<DT><STRONG><font color="black">FOLDL</font></STRONG>
<DD>
<PRE>
|- (!f e. FOLDL f e [] = e) /\ !f e x l. FOLDL f e (x::l) = FOLDL f (f e x) l
</PRE>

<DT><STRONG><font color="black">FOLDR</font></STRONG>
<DD>
<PRE>
|- (!f e. FOLDR f e [] = e) /\ !f e x l. FOLDR f e (x::l) = f x (FOLDR f e l)
</PRE>

<DT><STRONG><font color="black">FILTER</font></STRONG>
<DD>
<PRE>
|- (!P. FILTER P [] = []) /\
   !P h t. FILTER P (h::t) = if P h then h::FILTER P t else FILTER P t
</PRE>

<DT><STRONG><font color="black">MEM</font></STRONG>
<DD>
<PRE>
|- (!x. MEM x [] <=> F) /\ !x h t. MEM x (h::t) <=> (x = h) \/ MEM x t
</PRE>

<DT><STRONG><font color="black">MAP</font></STRONG>
<DD>
<PRE>
|- (!f. MAP f [] = []) /\ !f h t. MAP f (h::t) = f h::MAP f t
</PRE>

<DT><STRONG><font color="black">LENGTH</font></STRONG>
<DD>
<PRE>
|- (LENGTH [] = 0) /\ !h t. LENGTH (h::t) = SUC (LENGTH t)
</PRE>

<DT><STRONG><font color="black">FLAT</font></STRONG>
<DD>
<PRE>
|- (FLAT [] = []) /\ !h t. FLAT (h::t) = h ++ FLAT t
</PRE>

<DT><STRONG><font color="black">APPEND</font></STRONG>
<DD>
<PRE>
|- (!l. [] ++ l = l) /\ !l1 l2 h. h::l1 ++ l2 = h::(l1 ++ l2)
</PRE>

<DT><STRONG><font color="black">SUM</font></STRONG>
<DD>
<PRE>
|- (SUM [] = 0) /\ !h t. SUM (h::t) = h + SUM t
</PRE>

<DT><STRONG><font color="black">TL</font></STRONG>
<DD>
<PRE>
|- !h t. TL (h::t) = t
</PRE>

<DT><STRONG><font color="black">HD</font></STRONG>
<DD>
<PRE>
|- !h t. HD (h::t) = h
</PRE>

<DT><STRONG><font color="black">NULL_DEF</font></STRONG>
<DD>
<PRE>
|- (NULL [] <=> T) /\ !h t. NULL (h::t) <=> F
</PRE>

<DT><STRONG><font color="black">list_TY_DEF</font></STRONG>
<DD>
<PRE>
|- ?rep.
     TYPE_DEFINITION
       (\a0'.
          !'list' .
            (!a0'.
               (a0' = ind_type$CONSTR 0 ARB (\n. ind_type$BOTTOM)) \/
               (?a0 a1.
                  (a0' =
                   (\a0 a1.
                      ind_type$CONSTR (SUC 0) a0
                        (ind_type$FCONS a1 (\n. ind_type$BOTTOM))) a0 a1) /\
                  'list' a1) ==>
               'list' a0') ==>
            'list' a0') rep
</PRE>

<DT><STRONG><font color="black">list_repfns</font></STRONG>
<DD>
<PRE>
|- (!a. mk_list (dest_list a) = a) /\
   !r.
     (\a0'.
        !'list' .
          (!a0'.
             (a0' = ind_type$CONSTR 0 ARB (\n. ind_type$BOTTOM)) \/
             (?a0 a1.
                (a0' =
                 (\a0 a1.
                    ind_type$CONSTR (SUC 0) a0
                      (ind_type$FCONS a1 (\n. ind_type$BOTTOM))) a0 a1) /\
                'list' a1) ==>
             'list' a0') ==>
          'list' a0') r <=> (dest_list (mk_list r) = r)
</PRE>

<DT><STRONG><font color="black">list_case_def</font></STRONG>
<DD>
<PRE>
|- (!v f. list_case v f [] = v) /\
   !v f a0 a1. list_case v f (a0::a1) = f a0 a1
</PRE>

<DT><STRONG><font color="black">list_size_def</font></STRONG>
<DD>
<PRE>
|- (!f. list_size f [] = 0) /\
   !f a0 a1. list_size f (a0::a1) = 1 + (f a0 + list_size f a1)
</PRE>

<DT><STRONG><font color="black">ZIP</font></STRONG>
<DD>
<PRE>
|- (ZIP ([],[]) = []) /\
   !x1 l1 x2 l2. ZIP (x1::l1,x2::l2) = (x1,x2)::ZIP (l1,l2)
</PRE>

<DT><STRONG><font color="black">UNZIP</font></STRONG>
<DD>
<PRE>
|- (UNZIP [] = ([],[])) /\
   !x l. UNZIP (x::l) = (FST x::FST (UNZIP l),SND x::SND (UNZIP l))
</PRE>

<DT><STRONG><font color="black">REVERSE_DEF</font></STRONG>
<DD>
<PRE>
|- (REVERSE [] = []) /\ !h t. REVERSE (h::t) = REVERSE t ++ [h]
</PRE>

<DT><STRONG><font color="black">LAST_DEF</font></STRONG>
<DD>
<PRE>
|- !h t. LAST (h::t) = if t = [] then h else LAST t
</PRE>

<DT><STRONG><font color="black">FRONT_DEF</font></STRONG>
<DD>
<PRE>
|- !h t. FRONT (h::t) = if t = [] then [] else h::FRONT t
</PRE>

<DT><STRONG><font color="black">TAKE_def</font></STRONG>
<DD>
<PRE>
|- (!n. TAKE n [] = []) /\
   !n x xs. TAKE n (x::xs) = if n = 0 then [] else x::TAKE (n - 1) xs
</PRE>

<DT><STRONG><font color="black">DROP_def</font></STRONG>
<DD>
<PRE>
|- (!n. DROP n [] = []) /\
   !n x xs. DROP n (x::xs) = if n = 0 then x::xs else DROP (n - 1) xs
</PRE>

<DT><STRONG><font color="black">ALL_DISTINCT</font></STRONG>
<DD>
<PRE>
|- (ALL_DISTINCT [] <=> T) /\
   !h t. ALL_DISTINCT (h::t) <=> ~MEM h t /\ ALL_DISTINCT t
</PRE>

<DT><STRONG><font color="black">LIST_TO_SET</font></STRONG>
<DD>
<PRE>
|- LIST_TO_SET = combin$C MEM
</PRE>

<DT><STRONG><font color="black">listRel</font></STRONG>
<DD>
<PRE>
|- listRel =
   (\R a0 a1.
      !listRel'.
        (!a0 a1.
           (a0 = []) /\ (a1 = []) \/
           (?h1 h2 t1 t2.
              (a0 = h1::t1) /\ (a1 = h2::t2) /\ R h1 h2 /\ listRel' t1 t2) ==>
           listRel' a0 a1) ==>
        listRel' a0 a1)
</PRE>

<DT><STRONG><font color="black">LEN_DEF</font></STRONG>
<DD>
<PRE>
|- (!n. LEN [] n = n) /\ !h t n. LEN (h::t) n = LEN t (n + 1)
</PRE>

<DT><STRONG><font color="black">REV_DEF</font></STRONG>
<DD>
<PRE>
|- (!acc. REV [] acc = acc) /\ !h t acc. REV (h::t) acc = REV t (h::acc)
</PRE>

<DT><STRONG><font color="black">SET_TO_LIST_primitive</font></STRONG>
<DD>
<PRE>
|- SET_TO_LIST =
   WFREC (@R. WF R /\ !s. FINITE s /\ s <> {} ==> R (REST s) s)
     (\SET_TO_LIST s.
        I
          (if FINITE s then
             if s = {} then [] else CHOICE s::SET_TO_LIST (REST s)
           else
             ARB))
</PRE>

<DT><STRONG><font color="black">isPREFIX</font></STRONG>
<DD>
<PRE>
|- (!l. [] <<= l <=> T) /\
   !h t l. h::t <<= l <=> case l of [] -> F || h'::t' -> (h = h') /\ t <<= t'
</PRE>

</DL>


<HR>

<HR>
<H1><font color="black">Theorems</font></H1>
<DL>
<DT><STRONG><font color="black">UNION_APPEND</font></STRONG>
<DD>
<PRE>
|- !l1 l2. LIST_TO_SET l1 UNION LIST_TO_SET l2 = LIST_TO_SET (l1 ++ l2)
</PRE>

<DT><STRONG><font color="black">SET_TO_LIST_SING</font></STRONG>
<DD>
<PRE>
|- SET_TO_LIST {x} = [x]
</PRE>

<DT><STRONG><font color="black">MEM_SET_TO_LIST</font></STRONG>
<DD>
<PRE>
|- !s. FINITE s ==> !x. MEM x (SET_TO_LIST s) <=> x IN s
</PRE>

<DT><STRONG><font color="black">SET_TO_LIST_IN_MEM</font></STRONG>
<DD>
<PRE>
|- !s. FINITE s ==> !x. x IN s <=> MEM x (SET_TO_LIST s)
</PRE>

<DT><STRONG><font color="black">SET_TO_LIST_CARD</font></STRONG>
<DD>
<PRE>
|- !s. FINITE s ==> (LENGTH (SET_TO_LIST s) = CARD s)
</PRE>

<DT><STRONG><font color="black">SET_TO_LIST_INV</font></STRONG>
<DD>
<PRE>
|- !s. FINITE s ==> (LIST_TO_SET (SET_TO_LIST s) = s)
</PRE>

<DT><STRONG><font color="black">list_CASES</font></STRONG>
<DD>
<PRE>
|- !l. (l = []) \/ ?t h. l = h::t
</PRE>

<DT><STRONG><font color="black">FORALL_LIST</font></STRONG>
<DD>
<PRE>
|- (!l. P l) <=> P [] /\ !h t. P t ==> P (h::t)
</PRE>

<DT><STRONG><font color="black">list_induction</font></STRONG>
<DD>
<PRE>
|- !P. P [] /\ (!t. P t ==> !h. P (h::t)) ==> !l. P l
</PRE>

<DT><STRONG><font color="black">list_Axiom</font></STRONG>
<DD>
<PRE>
|- !f0 f1. ?fn. (fn [] = f0) /\ !a0 a1. fn (a0::a1) = f1 a0 a1 (fn a1)
</PRE>

<DT><STRONG><font color="black">list_INDUCT</font></STRONG>
<DD>
<PRE>
|- !P. P [] /\ (!t. P t ==> !h. P (h::t)) ==> !l. P l
</PRE>

<DT><STRONG><font color="black">NULL</font></STRONG>
<DD>
<PRE>
|- NULL [] /\ !h t. ~NULL (h::t)
</PRE>

<DT><STRONG><font color="black">list_Axiom_old</font></STRONG>
<DD>
<PRE>
|- !x f. ?!fn1. (fn1 [] = x) /\ !h t. fn1 (h::t) = f (fn1 t) h t
</PRE>

<DT><STRONG><font color="black">datatype_list</font></STRONG>
<DD>
<PRE>
|- DATATYPE (list [] CONS)
</PRE>

<DT><STRONG><font color="black">list_11</font></STRONG>
<DD>
<PRE>
|- !a0 a1 a0' a1'. (a0::a1 = a0'::a1') <=> (a0 = a0') /\ (a1 = a1')
</PRE>

<DT><STRONG><font color="black">list_distinct</font></STRONG>
<DD>
<PRE>
|- !a1 a0. [] <> a0::a1
</PRE>

<DT><STRONG><font color="black">list_case_cong</font></STRONG>
<DD>
<PRE>
|- !M M' v f.
     (M = M') /\ ((M' = []) ==> (v = v')) /\
     (!a0 a1. (M' = a0::a1) ==> (f a0 a1 = f' a0 a1)) ==>
     (list_case v f M = list_case v' f' M')
</PRE>

<DT><STRONG><font color="black">list_nchotomy</font></STRONG>
<DD>
<PRE>
|- !l. (l = []) \/ ?t h. l = h::t
</PRE>

<DT><STRONG><font color="black">list_case_compute</font></STRONG>
<DD>
<PRE>
|- !l. list_case b f l = if NULL l then b else f (HD l) (TL l)
</PRE>

<DT><STRONG><font color="black">CONS_11</font></STRONG>
<DD>
<PRE>
|- !a0 a1 a0' a1'. (a0::a1 = a0'::a1') <=> (a0 = a0') /\ (a1 = a1')
</PRE>

<DT><STRONG><font color="black">NOT_NIL_CONS</font></STRONG>
<DD>
<PRE>
|- !a1 a0. [] <> a0::a1
</PRE>

<DT><STRONG><font color="black">NOT_CONS_NIL</font></STRONG>
<DD>
<PRE>
|- !a1 a0. a0::a1 <> []
</PRE>

<DT><STRONG><font color="black">LIST_NOT_EQ</font></STRONG>
<DD>
<PRE>
|- !l1 l2. l1 <> l2 ==> !h1 h2. h1::l1 <> h2::l2
</PRE>

<DT><STRONG><font color="black">NOT_EQ_LIST</font></STRONG>
<DD>
<PRE>
|- !h1 h2. h1 <> h2 ==> !l1 l2. h1::l1 <> h2::l2
</PRE>

<DT><STRONG><font color="black">EQ_LIST</font></STRONG>
<DD>
<PRE>
|- !h1 h2. (h1 = h2) ==> !l1 l2. (l1 = l2) ==> (h1::l1 = h2::l2)
</PRE>

<DT><STRONG><font color="black">CONS</font></STRONG>
<DD>
<PRE>
|- !l. ~NULL l ==> (HD l::TL l = l)
</PRE>

<DT><STRONG><font color="black">APPEND_NIL</font></STRONG>
<DD>
<PRE>
|- !l. l ++ [] = l
</PRE>

<DT><STRONG><font color="black">APPEND_ASSOC</font></STRONG>
<DD>
<PRE>
|- !l1 l2 l3. l1 ++ (l2 ++ l3) = l1 ++ l2 ++ l3
</PRE>

<DT><STRONG><font color="black">LENGTH_APPEND</font></STRONG>
<DD>
<PRE>
|- !l1 l2. LENGTH (l1 ++ l2) = LENGTH l1 + LENGTH l2
</PRE>

<DT><STRONG><font color="black">MAP_APPEND</font></STRONG>
<DD>
<PRE>
|- !f l1 l2. MAP f (l1 ++ l2) = MAP f l1 ++ MAP f l2
</PRE>

<DT><STRONG><font color="black">LENGTH_MAP</font></STRONG>
<DD>
<PRE>
|- !l f. LENGTH (MAP f l) = LENGTH l
</PRE>

<DT><STRONG><font color="black">MAP_EQ_NIL</font></STRONG>
<DD>
<PRE>
|- !l f. ((MAP f l = []) <=> (l = [])) /\ (([] = MAP f l) <=> (l = []))
</PRE>

<DT><STRONG><font color="black">EVERY_EL</font></STRONG>
<DD>
<PRE>
|- !l P. EVERY P l <=> !n. n < LENGTH l ==> P (EL n l)
</PRE>

<DT><STRONG><font color="black">EVERY_CONJ</font></STRONG>
<DD>
<PRE>
|- !l. EVERY (\x. P x /\ Q x) l <=> EVERY P l /\ EVERY Q l
</PRE>

<DT><STRONG><font color="black">EVERY_MEM</font></STRONG>
<DD>
<PRE>
|- !P l. EVERY P l <=> !e. MEM e l ==> P e
</PRE>

<DT><STRONG><font color="black">EVERY_MAP</font></STRONG>
<DD>
<PRE>
|- !P f l. EVERY P (MAP f l) <=> EVERY (\x. P (f x)) l
</PRE>

<DT><STRONG><font color="black">EVERY_SIMP</font></STRONG>
<DD>
<PRE>
|- !c l. EVERY (\x. c) l <=> (l = []) \/ c
</PRE>

<DT><STRONG><font color="black">MONO_EVERY</font></STRONG>
<DD>
<PRE>
|- (!x. P x ==> Q x) ==> EVERY P l ==> EVERY Q l
</PRE>

<DT><STRONG><font color="black">EXISTS_MEM</font></STRONG>
<DD>
<PRE>
|- !P l. EXISTS P l <=> ?e. MEM e l /\ P e
</PRE>

<DT><STRONG><font color="black">EXISTS_MAP</font></STRONG>
<DD>
<PRE>
|- !P f l. EXISTS P (MAP f l) <=> EXISTS (\x. P (f x)) l
</PRE>

<DT><STRONG><font color="black">EXISTS_SIMP</font></STRONG>
<DD>
<PRE>
|- !c l. EXISTS (\x. c) l <=> l <> [] /\ c
</PRE>

<DT><STRONG><font color="black">MONO_EXISTS</font></STRONG>
<DD>
<PRE>
|- (!x. P x ==> Q x) ==> EXISTS P l ==> EXISTS Q l
</PRE>

<DT><STRONG><font color="black">EVERY_NOT_EXISTS</font></STRONG>
<DD>
<PRE>
|- !P l. EVERY P l <=> ~EXISTS (\x. ~P x) l
</PRE>

<DT><STRONG><font color="black">EXISTS_NOT_EVERY</font></STRONG>
<DD>
<PRE>
|- !P l. EXISTS P l <=> ~EVERY (\x. ~P x) l
</PRE>

<DT><STRONG><font color="black">MEM_APPEND</font></STRONG>
<DD>
<PRE>
|- !e l1 l2. MEM e (l1 ++ l2) <=> MEM e l1 \/ MEM e l2
</PRE>

<DT><STRONG><font color="black">MEM_FILTER</font></STRONG>
<DD>
<PRE>
|- !P L x. MEM x (FILTER P L) <=> P x /\ MEM x L
</PRE>

<DT><STRONG><font color="black">MEM_FLAT</font></STRONG>
<DD>
<PRE>
|- !x L. MEM x (FLAT L) <=> ?l. MEM l L /\ MEM x l
</PRE>

<DT><STRONG><font color="black">EVERY_APPEND</font></STRONG>
<DD>
<PRE>
|- !P l1 l2. EVERY P (l1 ++ l2) <=> EVERY P l1 /\ EVERY P l2
</PRE>

<DT><STRONG><font color="black">EXISTS_APPEND</font></STRONG>
<DD>
<PRE>
|- !P l1 l2. EXISTS P (l1 ++ l2) <=> EXISTS P l1 \/ EXISTS P l2
</PRE>

<DT><STRONG><font color="black">NOT_EVERY</font></STRONG>
<DD>
<PRE>
|- !P l. ~EVERY P l <=> EXISTS ($~ o P) l
</PRE>

<DT><STRONG><font color="black">NOT_EXISTS</font></STRONG>
<DD>
<PRE>
|- !P l. ~EXISTS P l <=> EVERY ($~ o P) l
</PRE>

<DT><STRONG><font color="black">MEM_MAP</font></STRONG>
<DD>
<PRE>
|- !l f x. MEM x (MAP f l) <=> ?y. (x = f y) /\ MEM y l
</PRE>

<DT><STRONG><font color="black">LENGTH_NIL</font></STRONG>
<DD>
<PRE>
|- !l. (LENGTH l = 0) <=> (l = [])
</PRE>

<DT><STRONG><font color="black">NULL_EQ</font></STRONG>
<DD>
<PRE>
|- !l. NULL l <=> (l = [])
</PRE>

<DT><STRONG><font color="black">NULL_LENGTH</font></STRONG>
<DD>
<PRE>
|- !l. NULL l <=> (LENGTH l = 0)
</PRE>

<DT><STRONG><font color="black">LENGTH_CONS</font></STRONG>
<DD>
<PRE>
|- !l n. (LENGTH l = SUC n) <=> ?h l'. (LENGTH l' = n) /\ (l = h::l')
</PRE>

<DT><STRONG><font color="black">LENGTH_EQ_CONS</font></STRONG>
<DD>
<PRE>
|- !P n.
     (!l. (LENGTH l = SUC n) ==> P l) <=>
     !l. (LENGTH l = n) ==> (\l. !x. P (x::l)) l
</PRE>

<DT><STRONG><font color="black">LENGTH_EQ_NIL</font></STRONG>
<DD>
<PRE>
|- !P. (!l. (LENGTH l = 0) ==> P l) <=> P []
</PRE>

<DT><STRONG><font color="black">CONS_ACYCLIC</font></STRONG>
<DD>
<PRE>
|- !l x. l <> x::l /\ x::l <> l
</PRE>

<DT><STRONG><font color="black">APPEND_eq_NIL</font></STRONG>
<DD>
<PRE>
|- (!l1 l2. ([] = l1 ++ l2) <=> (l1 = []) /\ (l2 = [])) /\
   !l1 l2. (l1 ++ l2 = []) <=> (l1 = []) /\ (l2 = [])
</PRE>

<DT><STRONG><font color="black">APPEND_11</font></STRONG>
<DD>
<PRE>
|- (!l1 l2 l3. (l1 ++ l2 = l1 ++ l3) <=> (l2 = l3)) /\
   !l1 l2 l3. (l2 ++ l1 = l3 ++ l1) <=> (l2 = l3)
</PRE>

<DT><STRONG><font color="black">APPEND_EQ_SELF</font></STRONG>
<DD>
<PRE>
|- (!l1 l2. (l1 ++ l2 = l1) <=> (l2 = [])) /\
   (!l1 l2. (l1 ++ l2 = l2) <=> (l1 = [])) /\
   (!l1 l2. (l1 = l1 ++ l2) <=> (l2 = [])) /\
   !l1 l2. (l2 = l1 ++ l2) <=> (l1 = [])
</PRE>

<DT><STRONG><font color="black">MEM_SPLIT</font></STRONG>
<DD>
<PRE>
|- !x l. MEM x l <=> ?l1 l2. l = l1 ++ x::l2
</PRE>

<DT><STRONG><font color="black">LIST_EQ_REWRITE</font></STRONG>
<DD>
<PRE>
|- !l1 l2.
     (l1 = l2) <=>
     (LENGTH l1 = LENGTH l2) /\ !x. x < LENGTH l1 ==> (EL x l1 = EL x l2)
</PRE>

<DT><STRONG><font color="black">LIST_EQ</font></STRONG>
<DD>
<PRE>
|- !l1 l2.
     (LENGTH l1 = LENGTH l2) /\
     (!x. x < LENGTH l1 ==> (EL x l1 = EL x l2)) ==>
     (l1 = l2)
</PRE>

<DT><STRONG><font color="black">FOLDL_EQ_FOLDR</font></STRONG>
<DD>
<PRE>
|- !f l e. ASSOC f /\ COMM f ==> (FOLDL f e l = FOLDR f e l)
</PRE>

<DT><STRONG><font color="black">LENGTH_TL</font></STRONG>
<DD>
<PRE>
|- !l. 0 < LENGTH l ==> (LENGTH (TL l) = LENGTH l - 1)
</PRE>

<DT><STRONG><font color="black">FILTER_EQ_NIL</font></STRONG>
<DD>
<PRE>
|- !P l. (FILTER P l = []) <=> EVERY (\x. ~P x) l
</PRE>

<DT><STRONG><font color="black">FILTER_NEQ_NIL</font></STRONG>
<DD>
<PRE>
|- !P l. FILTER P l <> [] <=> ?x. MEM x l /\ P x
</PRE>

<DT><STRONG><font color="black">FILTER_EQ_ID</font></STRONG>
<DD>
<PRE>
|- !P l. (FILTER P l = l) <=> EVERY P l
</PRE>

<DT><STRONG><font color="black">FILTER_NEQ_ID</font></STRONG>
<DD>
<PRE>
|- !P l. FILTER P l <> l <=> ?x. MEM x l /\ ~P x
</PRE>

<DT><STRONG><font color="black">FILTER_EQ_CONS</font></STRONG>
<DD>
<PRE>
|- !P l h lr.
     (FILTER P l = h::lr) <=>
     ?l1 l2.
       (l = l1 ++ [h] ++ l2) /\ (FILTER P l1 = []) /\ (FILTER P l2 = lr) /\
       P h
</PRE>

<DT><STRONG><font color="black">FILTER_EQ_APPEND</font></STRONG>
<DD>
<PRE>
|- !P l l1 l2.
     (FILTER P l = l1 ++ l2) <=>
     ?l3 l4. (l = l3 ++ l4) /\ (FILTER P l3 = l1) /\ (FILTER P l4 = l2)
</PRE>

<DT><STRONG><font color="black">EVERY_FILTER</font></STRONG>
<DD>
<PRE>
|- !P1 P2 l. EVERY P1 (FILTER P2 l) <=> EVERY (\x. P2 x ==> P1 x) l
</PRE>

<DT><STRONG><font color="black">FILTER_COND_REWRITE</font></STRONG>
<DD>
<PRE>
|- (FILTER P [] = []) /\ (!h. P h ==> (FILTER P (h::l) = h::FILTER P l)) /\
   !h. ~P h ==> (FILTER P (h::l) = FILTER P l)
</PRE>

<DT><STRONG><font color="black">NOT_NULL_MEM</font></STRONG>
<DD>
<PRE>
|- !l. ~NULL l <=> ?e. MEM e l
</PRE>

<DT><STRONG><font color="black">EL_compute</font></STRONG>
<DD>
<PRE>
|- !n. EL n l = if n = 0 then HD l else EL (PRE n) (TL l)
</PRE>

<DT><STRONG><font color="black">EL_simp</font></STRONG>
<DD>
<PRE>
|- (EL (NUMERAL (BIT1 n)) l = EL (PRE (NUMERAL (BIT1 n))) (TL l)) /\
   (EL (NUMERAL (BIT2 n)) l = EL (NUMERAL (BIT1 n)) (TL l))
</PRE>

<DT><STRONG><font color="black">WF_LIST_PRED</font></STRONG>
<DD>
<PRE>
|- WF (\L1 L2. ?h. L2 = h::L1)
</PRE>

<DT><STRONG><font color="black">list_size_cong</font></STRONG>
<DD>
<PRE>
|- !M N f f'.
     (M = N) /\ (!x. MEM x N ==> (f x = f' x)) ==>
     (list_size f M = list_size f' N)
</PRE>

<DT><STRONG><font color="black">FOLDR_CONG</font></STRONG>
<DD>
<PRE>
|- !l l' b b' f f'.
     (l = l') /\ (b = b') /\ (!x a. MEM x l' ==> (f x a = f' x a)) ==>
     (FOLDR f b l = FOLDR f' b' l')
</PRE>

<DT><STRONG><font color="black">FOLDL_CONG</font></STRONG>
<DD>
<PRE>
|- !l l' b b' f f'.
     (l = l') /\ (b = b') /\ (!x a. MEM x l' ==> (f a x = f' a x)) ==>
     (FOLDL f b l = FOLDL f' b' l')
</PRE>

<DT><STRONG><font color="black">MAP_CONG</font></STRONG>
<DD>
<PRE>
|- !l1 l2 f f'.
     (l1 = l2) /\ (!x. MEM x l2 ==> (f x = f' x)) ==> (MAP f l1 = MAP f' l2)
</PRE>

<DT><STRONG><font color="black">EXISTS_CONG</font></STRONG>
<DD>
<PRE>
|- !l1 l2 P P'.
     (l1 = l2) /\ (!x. MEM x l2 ==> (P x <=> P' x)) ==>
     (EXISTS P l1 <=> EXISTS P' l2)
</PRE>

<DT><STRONG><font color="black">EVERY_CONG</font></STRONG>
<DD>
<PRE>
|- !l1 l2 P P'.
     (l1 = l2) /\ (!x. MEM x l2 ==> (P x <=> P' x)) ==>
     (EVERY P l1 <=> EVERY P' l2)
</PRE>

<DT><STRONG><font color="black">EVERY_MONOTONIC</font></STRONG>
<DD>
<PRE>
|- !P Q. (!x. P x ==> Q x) ==> !l. EVERY P l ==> EVERY Q l
</PRE>

<DT><STRONG><font color="black">UNZIP_THM</font></STRONG>
<DD>
<PRE>
|- (UNZIP [] = ([],[])) /\
   (UNZIP ((x,y)::t) = (let (L1,L2) = UNZIP t in (x::L1,y::L2)))
</PRE>

<DT><STRONG><font color="black">LENGTH_ZIP</font></STRONG>
<DD>
<PRE>
|- !l1 l2.
     (LENGTH l1 = LENGTH l2) ==>
     (LENGTH (ZIP (l1,l2)) = LENGTH l1) /\ (LENGTH (ZIP (l1,l2)) = LENGTH l2)
</PRE>

<DT><STRONG><font color="black">LENGTH_UNZIP</font></STRONG>
<DD>
<PRE>
|- !pl.
     (LENGTH (FST (UNZIP pl)) = LENGTH pl) /\
     (LENGTH (SND (UNZIP pl)) = LENGTH pl)
</PRE>

<DT><STRONG><font color="black">ZIP_UNZIP</font></STRONG>
<DD>
<PRE>
|- !l. ZIP (UNZIP l) = l
</PRE>

<DT><STRONG><font color="black">UNZIP_ZIP</font></STRONG>
<DD>
<PRE>
|- !l1 l2. (LENGTH l1 = LENGTH l2) ==> (UNZIP (ZIP (l1,l2)) = (l1,l2))
</PRE>

<DT><STRONG><font color="black">ZIP_MAP</font></STRONG>
<DD>
<PRE>
|- !l1 l2 f1 f2.
     (LENGTH l1 = LENGTH l2) ==>
     (ZIP (MAP f1 l1,l2) = MAP (\p. (f1 (FST p),SND p)) (ZIP (l1,l2))) /\
     (ZIP (l1,MAP f2 l2) = MAP (\p. (FST p,f2 (SND p))) (ZIP (l1,l2)))
</PRE>

<DT><STRONG><font color="black">MEM_ZIP</font></STRONG>
<DD>
<PRE>
|- !l1 l2 p.
     (LENGTH l1 = LENGTH l2) ==>
     (MEM p (ZIP (l1,l2)) <=> ?n. n < LENGTH l1 /\ (p = (EL n l1,EL n l2)))
</PRE>

<DT><STRONG><font color="black">EL_ZIP</font></STRONG>
<DD>
<PRE>
|- !l1 l2 n.
     (LENGTH l1 = LENGTH l2) /\ n < LENGTH l1 ==>
     (EL n (ZIP (l1,l2)) = (EL n l1,EL n l2))
</PRE>

<DT><STRONG><font color="black">MAP2_ZIP</font></STRONG>
<DD>
<PRE>
|- !l1 l2.
     (LENGTH l1 = LENGTH l2) ==>
     !f. MAP2 f l1 l2 = MAP (UNCURRY f) (ZIP (l1,l2))
</PRE>

<DT><STRONG><font color="black">MEM_EL</font></STRONG>
<DD>
<PRE>
|- !l x. MEM x l <=> ?n. n < LENGTH l /\ (x = EL n l)
</PRE>

<DT><STRONG><font color="black">REVERSE_APPEND</font></STRONG>
<DD>
<PRE>
|- !l1 l2. REVERSE (l1 ++ l2) = REVERSE l2 ++ REVERSE l1
</PRE>

<DT><STRONG><font color="black">REVERSE_REVERSE</font></STRONG>
<DD>
<PRE>
|- !l. REVERSE (REVERSE l) = l
</PRE>

<DT><STRONG><font color="black">MEM_REVERSE</font></STRONG>
<DD>
<PRE>
|- !l x. MEM x (REVERSE l) <=> MEM x l
</PRE>

<DT><STRONG><font color="black">LAST_CONS</font></STRONG>
<DD>
<PRE>
|- (!x. LAST [x] = x) /\ !x y z. LAST (x::y::z) = LAST (y::z)
</PRE>

<DT><STRONG><font color="black">FRONT_CONS</font></STRONG>
<DD>
<PRE>
|- (!x. FRONT [x] = []) /\ !x y z. FRONT (x::y::z) = x::FRONT (y::z)
</PRE>

<DT><STRONG><font color="black">APPEND_FRONT_LAST</font></STRONG>
<DD>
<PRE>
|- !l. l <> [] ==> (FRONT l ++ [LAST l] = l)
</PRE>

<DT><STRONG><font color="black">FILTER_APPEND_DISTRIB</font></STRONG>
<DD>
<PRE>
|- !P L M. FILTER P (L ++ M) = FILTER P L ++ FILTER P M
</PRE>

<DT><STRONG><font color="black">TAKE_0</font></STRONG>
<DD>
<PRE>
|- TAKE 0 l = []
</PRE>

<DT><STRONG><font color="black">TAKE_LENGTH_ID</font></STRONG>
<DD>
<PRE>
|- TAKE (LENGTH l) l = l
</PRE>

<DT><STRONG><font color="black">LENGTH_TAKE</font></STRONG>
<DD>
<PRE>
|- !n. n <= LENGTH l ==> (LENGTH (TAKE n l) = n)
</PRE>

<DT><STRONG><font color="black">TAKE_APPEND1</font></STRONG>
<DD>
<PRE>
|- !n. n <= LENGTH l1 ==> (TAKE n (l1 ++ l2) = TAKE n l1)
</PRE>

<DT><STRONG><font color="black">TAKE_APPEND2</font></STRONG>
<DD>
<PRE>
|- !n. LENGTH l1 < n ==> (TAKE n (l1 ++ l2) = l1 ++ TAKE (n - LENGTH l1) l2)
</PRE>

<DT><STRONG><font color="black">DROP_0</font></STRONG>
<DD>
<PRE>
|- DROP 0 l = l
</PRE>

<DT><STRONG><font color="black">TAKE_DROP</font></STRONG>
<DD>
<PRE>
|- !n. TAKE n l ++ DROP n l = l
</PRE>

<DT><STRONG><font color="black">LENGTH_DROP</font></STRONG>
<DD>
<PRE>
|- !n. LENGTH (DROP n l) = LENGTH l - n
</PRE>

<DT><STRONG><font color="black">ALL_DISTINCT_FILTER</font></STRONG>
<DD>
<PRE>
|- !l. ALL_DISTINCT l <=> !x. MEM x l ==> (FILTER ($= x) l = [x])
</PRE>

<DT><STRONG><font color="black">FILTER_ALL_DISTINCT</font></STRONG>
<DD>
<PRE>
|- !P l. ALL_DISTINCT l ==> ALL_DISTINCT (FILTER P l)
</PRE>

<DT><STRONG><font color="black">EL_ALL_DISTINCT_EL_EQ</font></STRONG>
<DD>
<PRE>
|- !l.
     ALL_DISTINCT l <=>
     !n1 n2.
       n1 < LENGTH l /\ n2 < LENGTH l ==> ((EL n1 l = EL n2 l) <=> (n1 = n2))
</PRE>

<DT><STRONG><font color="black">ALL_DISTINCT_EL_IMP</font></STRONG>
<DD>
<PRE>
|- !l n1 n2.
     ALL_DISTINCT l /\ n1 < LENGTH l /\ n2 < LENGTH l ==>
     ((EL n1 l = EL n2 l) <=> (n1 = n2))
</PRE>

<DT><STRONG><font color="black">ALL_DISTINCT_APPEND</font></STRONG>
<DD>
<PRE>
|- !l1 l2.
     ALL_DISTINCT (l1 ++ l2) <=>
     ALL_DISTINCT l1 /\ ALL_DISTINCT l2 /\ !e. MEM e l1 ==> ~MEM e l2
</PRE>

<DT><STRONG><font color="black">ALL_DISTINCT_SING</font></STRONG>
<DD>
<PRE>
|- !x. ALL_DISTINCT [x]
</PRE>

<DT><STRONG><font color="black">IN_LIST_TO_SET</font></STRONG>
<DD>
<PRE>
|- x IN LIST_TO_SET l <=> MEM x l
</PRE>

<DT><STRONG><font color="black">listRel_rules</font></STRONG>
<DD>
<PRE>
|- !R.
     listRel R [] [] /\
     !h1 h2 t1 t2. R h1 h2 /\ listRel R t1 t2 ==> listRel R (h1::t1) (h2::t2)
</PRE>

<DT><STRONG><font color="black">listRel_ind</font></STRONG>
<DD>
<PRE>
|- !R listRel'.
     listRel' [] [] /\
     (!h1 h2 t1 t2.
        R h1 h2 /\ listRel' t1 t2 ==> listRel' (h1::t1) (h2::t2)) ==>
     !a0 a1. listRel R a0 a1 ==> listRel' a0 a1
</PRE>

<DT><STRONG><font color="black">listRel_cases</font></STRONG>
<DD>
<PRE>
|- !R a0 a1.
     listRel R a0 a1 <=>
     (a0 = []) /\ (a1 = []) \/
     ?h1 h2 t1 t2.
       (a0 = h1::t1) /\ (a1 = h2::t2) /\ R h1 h2 /\ listRel R t1 t2
</PRE>

<DT><STRONG><font color="black">listRel_NIL</font></STRONG>
<DD>
<PRE>
|- (listRel R [] y <=> (y = [])) /\ (listRel R x [] <=> (x = []))
</PRE>

<DT><STRONG><font color="black">listRel_CONS</font></STRONG>
<DD>
<PRE>
|- (listRel R (h::t) y <=>
    ?h' t'. (y = h'::t') /\ R h h' /\ listRel R t t') /\
   (listRel R x (h'::t') <=> ?h t. (x = h::t) /\ R h h' /\ listRel R t t')
</PRE>

<DT><STRONG><font color="black">listRel_LENGTH</font></STRONG>
<DD>
<PRE>
|- !x y. listRel R x y ==> (LENGTH x = LENGTH y)
</PRE>

<DT><STRONG><font color="black">listRel_strong_ind</font></STRONG>
<DD>
<PRE>
|- !R listRel'.
     listRel' [] [] /\
     (!h1 h2 t1 t2.
        R h1 h2 /\ listRel R t1 t2 /\ listRel' t1 t2 ==>
        listRel' (h1::t1) (h2::t2)) ==>
     !a0 a1. listRel R a0 a1 ==> listRel' a0 a1
</PRE>

<DT><STRONG><font color="black">MONO_listRel</font></STRONG>
<DD>
<PRE>
|- (!x y. R x y ==> R' x y) ==> listRel R x y ==> listRel R' x y
</PRE>

<DT><STRONG><font color="black">LEN_LENGTH_LEM</font></STRONG>
<DD>
<PRE>
|- !L n. LEN L n = LENGTH L + n
</PRE>

<DT><STRONG><font color="black">REV_REVERSE_LEM</font></STRONG>
<DD>
<PRE>
|- !L1 L2. REV L1 L2 = REVERSE L1 ++ L2
</PRE>

<DT><STRONG><font color="black">LENGTH_LEN</font></STRONG>
<DD>
<PRE>
|- !L. LENGTH L = LEN L 0
</PRE>

<DT><STRONG><font color="black">REVERSE_REV</font></STRONG>
<DD>
<PRE>
|- !L. REVERSE L = REV L []
</PRE>

<DT><STRONG><font color="black">SET_TO_LIST_THM</font></STRONG>
<DD>
<PRE>
|- FINITE s ==>
   (SET_TO_LIST s = if s = {} then [] else CHOICE s::SET_TO_LIST (REST s))
</PRE>

<DT><STRONG><font color="black">SET_TO_LIST_IND</font></STRONG>
<DD>
<PRE>
|- !P. (!s. (FINITE s /\ s <> {} ==> P (REST s)) ==> P s) ==> !v. P v
</PRE>

<DT><STRONG><font color="black">LIST_TO_SET_THM</font></STRONG>
<DD>
<PRE>
|- (LIST_TO_SET [] = {}) /\ (LIST_TO_SET (h::t) = h INSERT LIST_TO_SET t)
</PRE>

<DT><STRONG><font color="black">LIST_TO_SET_APPEND</font></STRONG>
<DD>
<PRE>
|- !l1 l2. LIST_TO_SET (l1 ++ l2) = LIST_TO_SET l1 UNION LIST_TO_SET l2
</PRE>

<DT><STRONG><font color="black">FINITE_LIST_TO_SET</font></STRONG>
<DD>
<PRE>
|- !l. FINITE (LIST_TO_SET l)
</PRE>

<DT><STRONG><font color="black">ALL_DISTINCT_SET_TO_LIST</font></STRONG>
<DD>
<PRE>
|- !s. FINITE s ==> ALL_DISTINCT (SET_TO_LIST s)
</PRE>

<DT><STRONG><font color="black">isPREFIX_THM</font></STRONG>
<DD>
<PRE>
|- ([] <<= l <=> T) /\ (h::t <<= [] <=> F) /\
   (h1::t1 <<= h2::t2 <=> (h1 = h2) /\ t1 <<= t2)
</PRE>

</DL>



<HR>
</BODY>
</HTML>
