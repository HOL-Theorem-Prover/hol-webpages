<HTML>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Theory: path</TITLE><meta http-equiv="content-type" content="text/html;charset=UTF-8">
</HEAD>
<BODY bgcolor=linen text=midnightblue>
<H1><font color="black">Theory "path"</font></H1>
<STRONG><font size=+3 color="black">Parents</font></STRONG>&nbsp;&nbsp;&nbsp;&nbsp;
    <A HREF = "llistTheory.html"><STRONG><font color="black">llist</font></STRONG></A>&nbsp;&nbsp;
    <A HREF = "fixedPointTheory.html"><STRONG><font color="black">fixedPoint</font></STRONG></A>

<H1><font color="black">Signature</font></H1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr>
    <th>
    <font color="crimson">Type</font>
    <th>
    <font color="crimson">Arity</font><tr><td>
                                          <STRONG><font color="black">path</font></STRONG>
                                          <td>
                                          2
    <tr>
    <th>
    <font color="crimson">Constant</font>
    <th>
    <font color="crimson">Type</font><tr><td>
                                         <STRONG><font color="black">PL</font></STRONG>
                                         <td>
                                         :('a, 'b) path -> num -> bool
    <tr><td>
        <STRONG><font color="black">SN</font></STRONG>
        <td>
        :('a -> 'b -> 'a -> bool) -> bool
    <tr><td>
        <STRONG><font color="black">drop</font></STRONG>
        <td>
        :num -> ('a, 'b) path -> ('a, 'b) path
    <tr><td>
        <STRONG><font color="black">el</font></STRONG>
        <td>
        :num -> ('a, 'b) path -> 'a
    <tr><td>
        <STRONG><font color="black">every</font></STRONG>
        <td>
        :('a -> bool) -> ('a, 'b) path -> bool
    <tr><td>
        <STRONG><font color="black">exists</font></STRONG>
        <td>
        :('a -> bool) -> ('a, 'b) path -> bool
    <tr><td>
        <STRONG><font color="black">filter</font></STRONG>
        <td>
        :('a -> bool) -> ('a, 'b) path -> ('a, 'b) path
    <tr><td>
        <STRONG><font color="black">finite</font></STRONG>
        <td>
        :('a, 'b) path -> bool
    <tr><td>
        <STRONG><font color="black">first</font></STRONG>
        <td>
        :('a, 'b) path -> 'a
    <tr><td>
        <STRONG><font color="black">firstP_at</font></STRONG>
        <td>
        :('a -> bool) -> ('a, 'b) path -> num -> bool
    <tr><td>
        <STRONG><font color="black">first_label</font></STRONG>
        <td>
        :('a, 'b) path -> 'b
    <tr><td>
        <STRONG><font color="black">fromPath</font></STRONG>
        <td>
        :('a, 'b) path -> 'a # ('b # 'a) llist
    <tr><td>
        <STRONG><font color="black">is_stopped</font></STRONG>
        <td>
        :('a, 'b) path -> bool
    <tr><td>
        <STRONG><font color="black">labels</font></STRONG>
        <td>
        :('a, 'b) path -> 'b llist
    <tr><td>
        <STRONG><font color="black">last</font></STRONG>
        <td>
        :('a, 'b) path -> 'a
    <tr><td>
        <STRONG><font color="black">length</font></STRONG>
        <td>
        :('a, 'b) path -> num option
    <tr><td>
        <STRONG><font color="black">mem</font></STRONG>
        <td>
        :'a -> ('a, 'b) path -> bool
    <tr><td>
        <STRONG><font color="black">nth_label</font></STRONG>
        <td>
        :num -> ('b, 'a) path -> 'a
    <tr><td>
        <STRONG><font color="black">okpath</font></STRONG>
        <td>
        :('a -> 'b -> 'a -> bool) -> ('a, 'b) path -> bool
    <tr><td>
        <STRONG><font color="black">okpath_f</font></STRONG>
        <td>
        :('a -> 'b -> 'a -> bool) ->
         (('a, 'b) path -> bool) -> ('a, 'b) path -> bool
    <tr><td>
        <STRONG><font color="black">pconcat</font></STRONG>
        <td>
        :('a, 'b) path -> 'b -> ('a, 'b) path -> ('a, 'b) path
    <tr><td>
        <STRONG><font color="black">pcons</font></STRONG>
        <td>
        :'a -> 'b -> ('a, 'b) path -> ('a, 'b) path
    <tr><td>
        <STRONG><font color="black">pgenerate</font></STRONG>
        <td>
        :(num -> 'a) -> (num -> 'b) -> ('a, 'b) path
    <tr><td>
        <STRONG><font color="black">plink</font></STRONG>
        <td>
        :('a, 'b) path -> ('a, 'b) path -> ('a, 'b) path
    <tr><td>
        <STRONG><font color="black">pmap</font></STRONG>
        <td>
        :('a -> 'c) -> ('b -> 'd) -> ('a, 'b) path -> ('c, 'd) path
    <tr><td>
        <STRONG><font color="black">seg</font></STRONG>
        <td>
        :num -> num -> ('a, 'b) path -> ('a, 'b) path
    <tr><td>
        <STRONG><font color="black">stopped_at</font></STRONG>
        <td>
        :'a -> ('a, 'b) path
    <tr><td>
        <STRONG><font color="black">tail</font></STRONG>
        <td>
        :('a, 'b) path -> ('a, 'b) path
    <tr><td>
        <STRONG><font color="black">take</font></STRONG>
        <td>
        :num -> ('a, 'b) path -> ('a, 'b) path
    <tr><td>
        <STRONG><font color="black">toPath</font></STRONG>
        <td>
        :'a # ('b # 'a) llist -> ('a, 'b) path
    
</table>
</center>

<H1><font color="black">Definitions</font></H1>
<DL>
<DT><STRONG><font color="black">path_TY_DEF</font></STRONG>
<DD>
<PRE>
|- ?rep. TYPE_DEFINITION (\x. T) rep
</PRE>

<DT><STRONG><font color="black">path_absrep_bijections</font></STRONG>
<DD>
<PRE>
|- (!a. toPath (fromPath a) = a) /\
   !r. (\x. T) r <=> (fromPath (toPath r) = r)
</PRE>

<DT><STRONG><font color="black">first_def</font></STRONG>
<DD>
<PRE>
|- !p. first p = FST (fromPath p)
</PRE>

<DT><STRONG><font color="black">stopped_at_def</font></STRONG>
<DD>
<PRE>
|- !x. stopped_at x = toPath (x,[||])
</PRE>

<DT><STRONG><font color="black">pcons_def</font></STRONG>
<DD>
<PRE>
|- !x r p. pcons x r p = toPath (x,(r,first p):::SND (fromPath p))
</PRE>

<DT><STRONG><font color="black">finite_def</font></STRONG>
<DD>
<PRE>
|- !sigma. finite sigma <=> LFINITE (SND (fromPath sigma))
</PRE>

<DT><STRONG><font color="black">last_thm</font></STRONG>
<DD>
<PRE>
|- (!x. last (stopped_at x) = x) /\ !x r p. last (pcons x r p) = last p
</PRE>

<DT><STRONG><font color="black">pmap_def</font></STRONG>
<DD>
<PRE>
|- !f g p. pmap f g p = toPath ((f ## LMAP (g ## f)) (fromPath p))
</PRE>

<DT><STRONG><font color="black">tail_def</font></STRONG>
<DD>
<PRE>
|- !x r p. tail (pcons x r p) = p
</PRE>

<DT><STRONG><font color="black">first_label_def</font></STRONG>
<DD>
<PRE>
|- !x r p. first_label (pcons x r p) = r
</PRE>

<DT><STRONG><font color="black">length_def</font></STRONG>
<DD>
<PRE>
|- !p.
     length p =
     if finite p then
       SOME (LENGTH (THE (toList (SND (fromPath p)))) + 1)
     else
       NONE
</PRE>

<DT><STRONG><font color="black">el_def</font></STRONG>
<DD>
<PRE>
|- (!p. el 0 p = first p) /\ !n p. el (SUC n) p = el n (tail p)
</PRE>

<DT><STRONG><font color="black">nth_label_def</font></STRONG>
<DD>
<PRE>
|- (!p. nth_label 0 p = first_label p) /\
   !n p. nth_label (SUC n) p = nth_label n (tail p)
</PRE>

<DT><STRONG><font color="black">pconcat_def</font></STRONG>
<DD>
<PRE>
|- !p1 lab p2.
     pconcat p1 lab p2 =
     toPath
       (first p1,
        LAPPEND (SND (fromPath p1)) ((lab,first p2):::SND (fromPath p2)))
</PRE>

<DT><STRONG><font color="black">PL_def</font></STRONG>
<DD>
<PRE>
|- !p. PL p = {i | finite p ==> i < THE (length p)}
</PRE>

<DT><STRONG><font color="black">firstP_at_def</font></STRONG>
<DD>
<PRE>
|- !P p i.
     firstP_at P p i <=> i IN PL p /\ P (el i p) /\ !j. j < i ==> ~P (el j p)
</PRE>

<DT><STRONG><font color="black">exists_def</font></STRONG>
<DD>
<PRE>
|- !P p. exists P p <=> ?i. firstP_at P p i
</PRE>

<DT><STRONG><font color="black">every_def</font></STRONG>
<DD>
<PRE>
|- !P p. every P p <=> ~exists ($~ o P) p
</PRE>

<DT><STRONG><font color="black">mem_def</font></STRONG>
<DD>
<PRE>
|- !s p. mem s p <=> ?i. i IN PL p /\ (s = el i p)
</PRE>

<DT><STRONG><font color="black">drop_def</font></STRONG>
<DD>
<PRE>
|- (!p. drop 0 p = p) /\ !n p. drop (SUC n) p = drop n (tail p)
</PRE>

<DT><STRONG><font color="black">take_def</font></STRONG>
<DD>
<PRE>
|- (!p. take 0 p = stopped_at (first p)) /\
   !n p. take (SUC n) p = pcons (first p) (first_label p) (take n (tail p))
</PRE>

<DT><STRONG><font color="black">seg_def</font></STRONG>
<DD>
<PRE>
|- !i j p. seg i j p = take (j - i) (drop i p)
</PRE>

<DT><STRONG><font color="black">labels_def</font></STRONG>
<DD>
<PRE>
|- (!x. labels (stopped_at x) = [||]) /\
   !x r p. labels (pcons x r p) = r:::labels p
</PRE>

<DT><STRONG><font color="black">is_stopped_def</font></STRONG>
<DD>
<PRE>
|- !p. is_stopped p <=> ?x. p = stopped_at x
</PRE>

<DT><STRONG><font color="black">filter_def</font></STRONG>
<DD>
<PRE>
|- !P.
     (!x. P x ==> (filter P (stopped_at x) = stopped_at x)) /\
     !x r p.
       filter P (pcons x r p) =
       if P x then
         if exists P p then pcons x r (filter P p) else stopped_at x
       else
         filter P p
</PRE>

<DT><STRONG><font color="black">pgenerate_def</font></STRONG>
<DD>
<PRE>
|- !f g. pgenerate f g = pcons (f 0) (g 0) (pgenerate (f o SUC) (g o SUC))
</PRE>

<DT><STRONG><font color="black">okpath_f_def</font></STRONG>
<DD>
<PRE>
|- !R X.
     okpath_f R X =
     {stopped_at x | x IN UNIV} UNION
     {pcons x r p | R x r (first p) /\ p IN X}
</PRE>

<DT><STRONG><font color="black">okpath_def</font></STRONG>
<DD>
<PRE>
|- !R. okpath R = gfp (okpath_f R)
</PRE>

<DT><STRONG><font color="black">plink_def</font></STRONG>
<DD>
<PRE>
|- (!x p. plink (stopped_at x) p = p) /\
   !x r p1 p2. plink (pcons x r p1) p2 = pcons x r (plink p1 p2)
</PRE>

<DT><STRONG><font color="black">SN_def</font></STRONG>
<DD>
<PRE>
|- !R. SN R <=> WF (\x y. ?l. R y l x)
</PRE>

</DL>


<HR>

<HR>
<H1><font color="black">Theorems</font></H1>
<DL>
<DT><STRONG><font color="black">path_rep_bijections_thm</font></STRONG>
<DD>
<PRE>
|- (!a. toPath (fromPath a) = a) /\ !r. fromPath (toPath r) = r
</PRE>

<DT><STRONG><font color="black">toPath_11</font></STRONG>
<DD>
<PRE>
|- !r r'. (toPath r = toPath r') <=> (r = r')
</PRE>

<DT><STRONG><font color="black">fromPath_11</font></STRONG>
<DD>
<PRE>
|- !a a'. (fromPath a = fromPath a') <=> (a = a')
</PRE>

<DT><STRONG><font color="black">fromPath_onto</font></STRONG>
<DD>
<PRE>
|- !r. ?a. r = fromPath a
</PRE>

<DT><STRONG><font color="black">toPath_onto</font></STRONG>
<DD>
<PRE>
|- !a. ?r. a = toPath r
</PRE>

<DT><STRONG><font color="black">stopped_at_11</font></STRONG>
<DD>
<PRE>
|- !x y. (stopped_at x = stopped_at y) <=> (x = y)
</PRE>

<DT><STRONG><font color="black">pcons_11</font></STRONG>
<DD>
<PRE>
|- !x r p y s q. (pcons x r p = pcons y s q) <=> (x = y) /\ (r = s) /\ (p = q)
</PRE>

<DT><STRONG><font color="black">stopped_at_not_pcons</font></STRONG>
<DD>
<PRE>
|- !x y r p. stopped_at x <> pcons y r p /\ pcons y r p <> stopped_at x
</PRE>

<DT><STRONG><font color="black">path_cases</font></STRONG>
<DD>
<PRE>
|- !p. (?x. p = stopped_at x) \/ ?x r q. p = pcons x r q
</PRE>

<DT><STRONG><font color="black">FORALL_path</font></STRONG>
<DD>
<PRE>
|- !P. (!p. P p) <=> (!x. P (stopped_at x)) /\ !x r p. P (pcons x r p)
</PRE>

<DT><STRONG><font color="black">first_thm</font></STRONG>
<DD>
<PRE>
|- (!x. first (stopped_at x) = x) /\ !x r p. first (pcons x r p) = x
</PRE>

<DT><STRONG><font color="black">finite_thm</font></STRONG>
<DD>
<PRE>
|- (!x. finite (stopped_at x) <=> T) /\
   !x r p. finite (pcons x r p) <=> finite p
</PRE>

<DT><STRONG><font color="black">path_bisimulation</font></STRONG>
<DD>
<PRE>
|- !p1 p2.
     (p1 = p2) <=>
     ?R.
       R p1 p2 /\
       !q1 q2.
         R q1 q2 ==>
         (?x. (q1 = stopped_at x) /\ (q2 = stopped_at x)) \/
         ?x r q1' q2'.
           (q1 = pcons x r q1') /\ (q2 = pcons x r q2') /\ R q1' q2'
</PRE>

<DT><STRONG><font color="black">finite_path_ind</font></STRONG>
<DD>
<PRE>
|- !P.
     (!x. P (stopped_at x)) /\
     (!x r p. finite p /\ P p ==> P (pcons x r p)) ==>
     !q. finite q ==> P q
</PRE>

<DT><STRONG><font color="black">pmap_thm</font></STRONG>
<DD>
<PRE>
|- (!x. pmap f g (stopped_at x) = stopped_at (f x)) /\
   !x r p. pmap f g (pcons x r p) = pcons (f x) (g r) (pmap f g p)
</PRE>

<DT><STRONG><font color="black">first_pmap</font></STRONG>
<DD>
<PRE>
|- !p. first (pmap f g p) = f (first p)
</PRE>

<DT><STRONG><font color="black">last_pmap</font></STRONG>
<DD>
<PRE>
|- !p. finite p ==> (last (pmap f g p) = f (last p))
</PRE>

<DT><STRONG><font color="black">finite_pmap</font></STRONG>
<DD>
<PRE>
|- !f g p. finite (pmap f g p) <=> finite p
</PRE>

<DT><STRONG><font color="black">length_thm</font></STRONG>
<DD>
<PRE>
|- (!x. length (stopped_at x) = SOME 1) /\
   !x r p.
     length (pcons x r p) =
     if finite p then SOME (THE (length p) + 1) else NONE
</PRE>

<DT><STRONG><font color="black">alt_length_thm</font></STRONG>
<DD>
<PRE>
|- (!x. length (stopped_at x) = SOME 1) /\
   !x r p. length (pcons x r p) = OPTION_MAP SUC (length p)
</PRE>

<DT><STRONG><font color="black">length_never_zero</font></STRONG>
<DD>
<PRE>
|- !p. length p <> SOME 0
</PRE>

<DT><STRONG><font color="black">finite_length</font></STRONG>
<DD>
<PRE>
|- !p.
     (finite p <=> ?n. length p = SOME n) /\ (~finite p <=> (length p = NONE))
</PRE>

<DT><STRONG><font color="black">length_pmap</font></STRONG>
<DD>
<PRE>
|- !f g p. length (pmap f g p) = length p
</PRE>

<DT><STRONG><font color="black">path_Axiom</font></STRONG>
<DD>
<PRE>
|- !f.
     ?g.
       !x.
         g x =
         case f x of
            (y,NONE) -> stopped_at y
         || (y,SOME (l,v)) -> pcons y l (g v)
</PRE>

<DT><STRONG><font color="black">pconcat_thm</font></STRONG>
<DD>
<PRE>
|- (!x lab p2. pconcat (stopped_at x) lab p2 = pcons x lab p2) /\
   !x r p lab p2. pconcat (pcons x r p) lab p2 = pcons x r (pconcat p lab p2)
</PRE>

<DT><STRONG><font color="black">pconcat_eq_stopped</font></STRONG>
<DD>
<PRE>
|- !p1 lab p2 x.
     pconcat p1 lab p2 <> stopped_at x /\ stopped_at x <> pconcat p1 lab p2
</PRE>

<DT><STRONG><font color="black">pconcat_eq_pcons</font></STRONG>
<DD>
<PRE>
|- !x r p p1 lab p2.
     ((pconcat p1 lab p2 = pcons x r p) <=>
      (lab = r) /\ (p1 = stopped_at x) /\ (p = p2) \/
      ?p1'. (p1 = pcons x r p1') /\ (p = pconcat p1' lab p2)) /\
     ((pcons x r p = pconcat p1 lab p2) <=>
      (lab = r) /\ (p1 = stopped_at x) /\ (p = p2) \/
      ?p1'. (p1 = pcons x r p1') /\ (p = pconcat p1' lab p2))
</PRE>

<DT><STRONG><font color="black">finite_pconcat</font></STRONG>
<DD>
<PRE>
|- !p1 lab p2. finite (pconcat p1 lab p2) <=> finite p1 /\ finite p2
</PRE>

<DT><STRONG><font color="black">infinite_PL</font></STRONG>
<DD>
<PRE>
|- !p. ~finite p ==> !i. i IN PL p
</PRE>

<DT><STRONG><font color="black">PL_pcons</font></STRONG>
<DD>
<PRE>
|- !x r q. PL (pcons x r q) = 0 INSERT IMAGE SUC (PL q)
</PRE>

<DT><STRONG><font color="black">PL_stopped_at</font></STRONG>
<DD>
<PRE>
|- !x. PL (stopped_at x) = {0}
</PRE>

<DT><STRONG><font color="black">PL_thm</font></STRONG>
<DD>
<PRE>
|- (!x. PL (stopped_at x) = {0}) /\
   !x r q. PL (pcons x r q) = 0 INSERT IMAGE SUC (PL q)
</PRE>

<DT><STRONG><font color="black">PL_0</font></STRONG>
<DD>
<PRE>
|- !p. 0 IN PL p
</PRE>

<DT><STRONG><font color="black">PL_downward_closed</font></STRONG>
<DD>
<PRE>
|- !i p. i IN PL p ==> !j. j < i ==> j IN PL p
</PRE>

<DT><STRONG><font color="black">PL_pmap</font></STRONG>
<DD>
<PRE>
|- PL (pmap f g p) = PL p
</PRE>

<DT><STRONG><font color="black">el_pmap</font></STRONG>
<DD>
<PRE>
|- !i p. i IN PL p ==> (el i (pmap f g p) = f (el i p))
</PRE>

<DT><STRONG><font color="black">nth_label_pmap</font></STRONG>
<DD>
<PRE>
|- !i p. SUC i IN PL p ==> (nth_label i (pmap f g p) = g (nth_label i p))
</PRE>

<DT><STRONG><font color="black">firstP_at_thm</font></STRONG>
<DD>
<PRE>
|- (!P x n. firstP_at P (stopped_at x) n <=> (n = 0) /\ P x) /\
   !P n x r p.
     firstP_at P (pcons x r p) n <=>
     (n = 0) /\ P x \/ 0 < n /\ ~P x /\ firstP_at P p (n - 1)
</PRE>

<DT><STRONG><font color="black">firstP_at_zero</font></STRONG>
<DD>
<PRE>
|- !P p. firstP_at P p 0 <=> P (first p)
</PRE>

<DT><STRONG><font color="black">exists_thm</font></STRONG>
<DD>
<PRE>
|- !P.
     (!x. exists P (stopped_at x) <=> P x) /\
     !x r p. exists P (pcons x r p) <=> P x \/ exists P p
</PRE>

<DT><STRONG><font color="black">every_thm</font></STRONG>
<DD>
<PRE>
|- !P.
     (!x. every P (stopped_at x) <=> P x) /\
     !x r p. every P (pcons x r p) <=> P x /\ every P p
</PRE>

<DT><STRONG><font color="black">not_every</font></STRONG>
<DD>
<PRE>
|- !P p. ~every P p <=> exists ($~ o P) p
</PRE>

<DT><STRONG><font color="black">not_exists</font></STRONG>
<DD>
<PRE>
|- !P p. ~exists P p <=> every ($~ o P) p
</PRE>

<DT><STRONG><font color="black">exists_el</font></STRONG>
<DD>
<PRE>
|- !P p. exists P p <=> ?i. i IN PL p /\ P (el i p)
</PRE>

<DT><STRONG><font color="black">every_el</font></STRONG>
<DD>
<PRE>
|- !P p. every P p <=> !i. i IN PL p ==> P (el i p)
</PRE>

<DT><STRONG><font color="black">every_coinduction</font></STRONG>
<DD>
<PRE>
|- !P Q.
     (!x. P (stopped_at x) ==> Q x) /\
     (!x r p. P (pcons x r p) ==> Q x /\ P p) ==>
     !p. P p ==> every Q p
</PRE>

<DT><STRONG><font color="black">exists_induction</font></STRONG>
<DD>
<PRE>
|- (!x. Q x ==> P (stopped_at x)) /\ (!x r p. Q x ==> P (pcons x r p)) /\
   (!x r p. P p ==> P (pcons x r p)) ==>
   !p. exists Q p ==> P p
</PRE>

<DT><STRONG><font color="black">mem_thm</font></STRONG>
<DD>
<PRE>
|- (!x s. mem s (stopped_at x) <=> (s = x)) /\
   !x r p s. mem s (pcons x r p) <=> (s = x) \/ mem s p
</PRE>

<DT><STRONG><font color="black">numeral_drop</font></STRONG>
<DD>
<PRE>
|- (!n p. drop (NUMERAL (BIT1 n)) p = drop (NUMERAL (BIT1 n) - 1) (tail p)) /\
   !n p. drop (NUMERAL (BIT2 n)) p = drop (NUMERAL (BIT1 n)) (tail p)
</PRE>

<DT><STRONG><font color="black">finite_drop</font></STRONG>
<DD>
<PRE>
|- !p n. n IN PL p ==> (finite (drop n p) <=> finite p)
</PRE>

<DT><STRONG><font color="black">length_drop</font></STRONG>
<DD>
<PRE>
|- !p n.
     n IN PL p ==>
     (length (drop n p) =
      case length p of NONE -> NONE || SOME m -> SOME (m - n))
</PRE>

<DT><STRONG><font color="black">PL_drop</font></STRONG>
<DD>
<PRE>
|- !p i. i IN PL p ==> (PL (drop i p) = IMAGE (\n. n - i) (PL p))
</PRE>

<DT><STRONG><font color="black">IN_PL_drop</font></STRONG>
<DD>
<PRE>
|- !i j p. i IN PL p ==> (j IN PL (drop i p) <=> i + j IN PL p)
</PRE>

<DT><STRONG><font color="black">first_drop</font></STRONG>
<DD>
<PRE>
|- !i p. i IN PL p ==> (first (drop i p) = el i p)
</PRE>

<DT><STRONG><font color="black">first_label_drop</font></STRONG>
<DD>
<PRE>
|- !i p. i IN PL p ==> (first_label (drop i p) = nth_label i p)
</PRE>

<DT><STRONG><font color="black">tail_drop</font></STRONG>
<DD>
<PRE>
|- !i p. i + 1 IN PL p ==> (tail (drop i p) = drop (i + 1) p)
</PRE>

<DT><STRONG><font color="black">el_drop</font></STRONG>
<DD>
<PRE>
|- !i j p. i + j IN PL p ==> (el i (drop j p) = el (i + j) p)
</PRE>

<DT><STRONG><font color="black">nth_label_drop</font></STRONG>
<DD>
<PRE>
|- !i j p.
     SUC (i + j) IN PL p ==> (nth_label i (drop j p) = nth_label (i + j) p)
</PRE>

<DT><STRONG><font color="black">first_take</font></STRONG>
<DD>
<PRE>
|- !p i. first (take i p) = first p
</PRE>

<DT><STRONG><font color="black">finite_take</font></STRONG>
<DD>
<PRE>
|- !p i. i IN PL p ==> finite (take i p)
</PRE>

<DT><STRONG><font color="black">length_take</font></STRONG>
<DD>
<PRE>
|- !p i. i IN PL p ==> (length (take i p) = SOME (i + 1))
</PRE>

<DT><STRONG><font color="black">PL_take</font></STRONG>
<DD>
<PRE>
|- !p i. i IN PL p ==> (PL (take i p) = {n | n <= i})
</PRE>

<DT><STRONG><font color="black">last_take</font></STRONG>
<DD>
<PRE>
|- !i p. i IN PL p ==> (last (take i p) = el i p)
</PRE>

<DT><STRONG><font color="black">nth_label_take</font></STRONG>
<DD>
<PRE>
|- !n p i. i < n /\ n IN PL p ==> (nth_label i (take n p) = nth_label i p)
</PRE>

<DT><STRONG><font color="black">singleton_seg</font></STRONG>
<DD>
<PRE>
|- !i p. i IN PL p ==> (seg i i p = stopped_at (el i p))
</PRE>

<DT><STRONG><font color="black">recursive_seg</font></STRONG>
<DD>
<PRE>
|- !i j p.
     i < j /\ j IN PL p ==>
     (seg i j p = pcons (el i p) (nth_label i p) (seg (i + 1) j p))
</PRE>

<DT><STRONG><font color="black">PL_seg</font></STRONG>
<DD>
<PRE>
|- !i j p. i <= j /\ j IN PL p ==> (PL (seg i j p) = {n | n <= j - i})
</PRE>

<DT><STRONG><font color="black">finite_seg</font></STRONG>
<DD>
<PRE>
|- !p i j. i <= j /\ j IN PL p ==> finite (seg i j p)
</PRE>

<DT><STRONG><font color="black">first_seg</font></STRONG>
<DD>
<PRE>
|- !i j p. i <= j /\ j IN PL p ==> (first (seg i j p) = el i p)
</PRE>

<DT><STRONG><font color="black">last_seg</font></STRONG>
<DD>
<PRE>
|- !i j p. i <= j /\ j IN PL p ==> (last (seg i j p) = el j p)
</PRE>

<DT><STRONG><font color="black">firstP_at_unique</font></STRONG>
<DD>
<PRE>
|- !P p n. firstP_at P p n ==> !m. firstP_at P p m <=> (m = n)
</PRE>

<DT><STRONG><font color="black">is_stopped_thm</font></STRONG>
<DD>
<PRE>
|- (!x. is_stopped (stopped_at x) <=> T) /\
   !x r p. is_stopped (pcons x r p) <=> F
</PRE>

<DT><STRONG><font color="black">filter_every</font></STRONG>
<DD>
<PRE>
|- !P p. exists P p ==> every P (filter P p)
</PRE>

<DT><STRONG><font color="black">pgenerate_infinite</font></STRONG>
<DD>
<PRE>
|- !f g. ~finite (pgenerate f g)
</PRE>

<DT><STRONG><font color="black">pgenerate_not_stopped</font></STRONG>
<DD>
<PRE>
|- !f g x. stopped_at x <> pgenerate f g
</PRE>

<DT><STRONG><font color="black">el_pgenerate</font></STRONG>
<DD>
<PRE>
|- !n f g. el n (pgenerate f g) = f n
</PRE>

<DT><STRONG><font color="black">nth_label_pgenerate</font></STRONG>
<DD>
<PRE>
|- !n f g. nth_label n (pgenerate f g) = g n
</PRE>

<DT><STRONG><font color="black">pgenerate_11</font></STRONG>
<DD>
<PRE>
|- !f1 g1 f2 g2.
     (pgenerate f1 g1 = pgenerate f2 g2) <=> (f1 = f2) /\ (g1 = g2)
</PRE>

<DT><STRONG><font color="black">pgenerate_onto</font></STRONG>
<DD>
<PRE>
|- !p. ~finite p ==> ?f g. p = pgenerate f g
</PRE>

<DT><STRONG><font color="black">okpath_monotone</font></STRONG>
<DD>
<PRE>
|- !R. monotone (okpath_f R)
</PRE>

<DT><STRONG><font color="black">okpath_co_ind</font></STRONG>
<DD>
<PRE>
|- !P.
     (!x r p. P (pcons x r p) ==> R x r (first p) /\ P p) ==>
     !p. P p ==> okpath R p
</PRE>

<DT><STRONG><font color="black">okpath_cases</font></STRONG>
<DD>
<PRE>
|- !R x.
     okpath R x <=>
     (?x'. x = stopped_at x') \/
     ?x' r p. (x = pcons x' r p) /\ R x' r (first p) /\ okpath R p
</PRE>

<DT><STRONG><font color="black">okpath_thm</font></STRONG>
<DD>
<PRE>
|- !R.
     (!x. okpath R (stopped_at x)) /\
     !x r p. okpath R (pcons x r p) <=> R x r (first p) /\ okpath R p
</PRE>

<DT><STRONG><font color="black">finite_okpath_ind</font></STRONG>
<DD>
<PRE>
|- !R.
     (!x. P (stopped_at x)) /\
     (!x r p.
        okpath R p /\ finite p /\ R x r (first p) /\ P p ==>
        P (pcons x r p)) ==>
     !sigma. okpath R sigma /\ finite sigma ==> P sigma
</PRE>

<DT><STRONG><font color="black">okpath_pmap</font></STRONG>
<DD>
<PRE>
|- !R f g p.
     okpath R p /\ (!x r y. R x r y ==> R (f x) (g r) (f y)) ==>
     okpath R (pmap f g p)
</PRE>

<DT><STRONG><font color="black">finite_plink</font></STRONG>
<DD>
<PRE>
|- !p1 p2. finite (plink p1 p2) <=> finite p1 /\ finite p2
</PRE>

<DT><STRONG><font color="black">first_plink</font></STRONG>
<DD>
<PRE>
|- !p1 p2. (last p1 = first p2) ==> (first (plink p1 p2) = first p1)
</PRE>

<DT><STRONG><font color="black">last_plink</font></STRONG>
<DD>
<PRE>
|- !p1 p2.
     finite p1 /\ finite p2 /\ (last p1 = first p2) ==>
     (last (plink p1 p2) = last p2)
</PRE>

<DT><STRONG><font color="black">okpath_plink</font></STRONG>
<DD>
<PRE>
|- !R p1 p2.
     finite p1 /\ (last p1 = first p2) ==>
     (okpath R (plink p1 p2) <=> okpath R p1 /\ okpath R p2)
</PRE>

<DT><STRONG><font color="black">okpath_take</font></STRONG>
<DD>
<PRE>
|- !R p i. i IN PL p /\ okpath R p ==> okpath R (take i p)
</PRE>

<DT><STRONG><font color="black">okpath_drop</font></STRONG>
<DD>
<PRE>
|- !R p i. i IN PL p /\ okpath R p ==> okpath R (drop i p)
</PRE>

<DT><STRONG><font color="black">okpath_seg</font></STRONG>
<DD>
<PRE>
|- !R p i j. i <= j /\ j IN PL p /\ okpath R p ==> okpath R (seg i j p)
</PRE>

<DT><STRONG><font color="black">SN_finite_paths</font></STRONG>
<DD>
<PRE>
|- !R p. SN R /\ okpath R p ==> finite p
</PRE>

<DT><STRONG><font color="black">finite_paths_SN</font></STRONG>
<DD>
<PRE>
|- !R. (!p. okpath R p ==> finite p) ==> SN R
</PRE>

<DT><STRONG><font color="black">SN_finite_paths_EQ</font></STRONG>
<DD>
<PRE>
|- !R. SN R <=> !p. okpath R p ==> finite p
</PRE>

</DL>



<HR>
</BODY>
</HTML>
