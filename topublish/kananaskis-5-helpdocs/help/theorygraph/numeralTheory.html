<HTML>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><TITLE>Theory: numeral</TITLE><meta http-equiv="content-type" content="text/html;charset=UTF-8">
</HEAD>
<BODY bgcolor=linen text=midnightblue>
<H1><font color="black">Theory "numeral"</font></H1>
<STRONG><font size=+3 color="black">Parents</font></STRONG>&nbsp;&nbsp;&nbsp;&nbsp;
    <A HREF = "arithmeticTheory.html"><STRONG><font color="black">arithmetic</font></STRONG></A>

<H1><font color="black">Signature</font></H1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr>
    <th>
    <font color="crimson">Constant</font>
    <th>
    <font color="crimson">Type</font><tr><td>
                                         <STRONG><font color="black">exactlog</font></STRONG>
                                         <td>
                                         :num -> num
    <tr><td>
        <STRONG><font color="black">iBIT_cases</font></STRONG>
        <td>
        :num -> 'a -> (num -> 'a) -> (num -> 'a) -> 'a
    <tr><td> <STRONG><font color="black">iDUB</font></STRONG> <td> :num -> num
    <tr><td>
        <STRONG><font color="black">iMOD_2EXP</font></STRONG>
        <td>
        :num -> num -> num
    <tr><td> <STRONG><font color="black">iSQR</font></STRONG> <td> :num -> num
    <tr><td>
        <STRONG><font color="black">iSUB</font></STRONG>
        <td>
        :bool -> num -> num -> num
    <tr><td> <STRONG><font color="black">iZ</font></STRONG> <td> :num -> num
    <tr><td>
        <STRONG><font color="black">iiSUC</font></STRONG>
        <td>
        :num -> num
    <tr><td>
        <STRONG><font color="black">internal_mult</font></STRONG>
        <td>
        :num -> num -> num
    <tr><td>
        <STRONG><font color="black">onecount</font></STRONG>
        <td>
        :num -> num -> num
    <tr><td>
        <STRONG><font color="black">texp_help</font></STRONG>
        <td>
        :num -> num -> num
    
</table>
</center>

<H1><font color="black">Definitions</font></H1>
<DL>
<DT><STRONG><font color="black">iZ</font></STRONG>
<DD>
<PRE>
|- !x. numeral$iZ x = x
</PRE>

<DT><STRONG><font color="black">iiSUC</font></STRONG>
<DD>
<PRE>
|- !n. numeral$iiSUC n = SUC (SUC n)
</PRE>

<DT><STRONG><font color="black">iBIT_cases</font></STRONG>
<DD>
<PRE>
|- (!zf bf1 bf2. iBIT_cases ZERO zf bf1 bf2 = zf) /\
   (!n zf bf1 bf2. iBIT_cases (BIT1 n) zf bf1 bf2 = bf1 n) /\
   !n zf bf1 bf2. iBIT_cases (BIT2 n) zf bf1 bf2 = bf2 n
</PRE>

<DT><STRONG><font color="black">iDUB</font></STRONG>
<DD>
<PRE>
|- !x. numeral$iDUB x = x + x
</PRE>

<DT><STRONG><font color="black">iSUB_DEF</font></STRONG>
<DD>
<PRE>
|- (!b x. numeral$iSUB b ZERO x = ZERO) /\
   (!b n x.
      numeral$iSUB b (BIT1 n) x =
      if b then
        iBIT_cases x (BIT1 n) (\m. numeral$iDUB (numeral$iSUB T n m))
          (\m. BIT1 (numeral$iSUB F n m))
      else
        iBIT_cases x (numeral$iDUB n) (\m. BIT1 (numeral$iSUB F n m))
          (\m. numeral$iDUB (numeral$iSUB F n m))) /\
   !b n x.
     numeral$iSUB b (BIT2 n) x =
     if b then
       iBIT_cases x (BIT2 n) (\m. BIT1 (numeral$iSUB T n m))
         (\m. numeral$iDUB (numeral$iSUB T n m))
     else
       iBIT_cases x (BIT1 n) (\m. numeral$iDUB (numeral$iSUB T n m))
         (\m. BIT1 (numeral$iSUB F n m))
</PRE>

<DT><STRONG><font color="black">iSQR</font></STRONG>
<DD>
<PRE>
|- !x. numeral$iSQR x = x * x
</PRE>

<DT><STRONG><font color="black">iMOD_2EXP</font></STRONG>
<DD>
<PRE>
|- numeral$iMOD_2EXP = MOD_2EXP
</PRE>

<DT><STRONG><font color="black">texp_help_def</font></STRONG>
<DD>
<PRE>
|- (!acc. numeral$texp_help 0 acc = BIT2 acc) /\
   !n acc. numeral$texp_help (SUC n) acc = numeral$texp_help n (BIT1 acc)
</PRE>

<DT><STRONG><font color="black">onecount_def</font></STRONG>
<DD>
<PRE>
|- (!x. numeral$onecount ZERO x = x) /\
   (!n x. numeral$onecount (BIT1 n) x = numeral$onecount n (SUC x)) /\
   !n x. numeral$onecount (BIT2 n) x = ZERO
</PRE>

<DT><STRONG><font color="black">exactlog_def</font></STRONG>
<DD>
<PRE>
|- (numeral$exactlog ZERO = ZERO) /\ (!n. numeral$exactlog (BIT1 n) = ZERO) /\
   !n.
     numeral$exactlog (BIT2 n) =
     (let x = numeral$onecount n ZERO in if x = ZERO then ZERO else BIT1 x)
</PRE>

<DT><STRONG><font color="black">internal_mult_def</font></STRONG>
<DD>
<PRE>
|- internal_mult = $*
</PRE>

</DL>


<HR>

<HR>
<H1><font color="black">Theorems</font></H1>
<DL>
<DT><STRONG><font color="black">numeral_suc</font></STRONG>
<DD>
<PRE>
|- (SUC ZERO = BIT1 ZERO) /\ (!n. SUC (BIT1 n) = BIT2 n) /\
   !n. SUC (BIT2 n) = BIT1 (SUC n)
</PRE>

<DT><STRONG><font color="black">numeral_distrib</font></STRONG>
<DD>
<PRE>
|- (!n. 0 + n = n) /\ (!n. n + 0 = n) /\
   (!n m. NUMERAL n + NUMERAL m = NUMERAL (numeral$iZ (n + m))) /\
   (!n. 0 * n = 0) /\ (!n. n * 0 = 0) /\
   (!n m. NUMERAL n * NUMERAL m = NUMERAL (n * m)) /\ (!n. 0 - n = 0) /\
   (!n. n - 0 = n) /\ (!n m. NUMERAL n - NUMERAL m = NUMERAL (n - m)) /\
   (!n. 0 ** NUMERAL (BIT1 n) = 0) /\ (!n. 0 ** NUMERAL (BIT2 n) = 0) /\
   (!n. n ** 0 = 1) /\ (!n m. NUMERAL n ** NUMERAL m = NUMERAL (n ** m)) /\
   (SUC 0 = 1) /\ (!n. SUC (NUMERAL n) = NUMERAL (SUC n)) /\ (PRE 0 = 0) /\
   (!n. PRE (NUMERAL n) = NUMERAL (PRE n)) /\
   (!n. (NUMERAL n = 0) <=> (n = ZERO)) /\
   (!n. (0 = NUMERAL n) <=> (n = ZERO)) /\
   (!n m. (NUMERAL n = NUMERAL m) <=> (n = m)) /\ (!n. n < 0 <=> F) /\
   (!n. 0 < NUMERAL n <=> ZERO < n) /\
   (!n m. NUMERAL n < NUMERAL m <=> n < m) /\ (!n. 0 > n <=> F) /\
   (!n. NUMERAL n > 0 <=> ZERO < n) /\
   (!n m. NUMERAL n > NUMERAL m <=> m < n) /\ (!n. 0 <= n <=> T) /\
   (!n. NUMERAL n <= 0 <=> n <= ZERO) /\
   (!n m. NUMERAL n <= NUMERAL m <=> n <= m) /\ (!n. n >= 0 <=> T) /\
   (!n. 0 >= n <=> (n = 0)) /\ (!n m. NUMERAL n >= NUMERAL m <=> m <= n) /\
   (!n. ODD (NUMERAL n) <=> ODD n) /\ (!n. EVEN (NUMERAL n) <=> EVEN n) /\
   ~ODD 0 /\ EVEN 0
</PRE>

<DT><STRONG><font color="black">numeral_iisuc</font></STRONG>
<DD>
<PRE>
|- (numeral$iiSUC ZERO = BIT2 ZERO) /\
   (numeral$iiSUC (BIT1 n) = BIT1 (SUC n)) /\
   (numeral$iiSUC (BIT2 n) = BIT2 (SUC n))
</PRE>

<DT><STRONG><font color="black">numeral_add</font></STRONG>
<DD>
<PRE>
|- !n m.
     (numeral$iZ (ZERO + n) = n) /\ (numeral$iZ (n + ZERO) = n) /\
     (numeral$iZ (BIT1 n + BIT1 m) = BIT2 (numeral$iZ (n + m))) /\
     (numeral$iZ (BIT1 n + BIT2 m) = BIT1 (SUC (n + m))) /\
     (numeral$iZ (BIT2 n + BIT1 m) = BIT1 (SUC (n + m))) /\
     (numeral$iZ (BIT2 n + BIT2 m) = BIT2 (SUC (n + m))) /\
     (SUC (ZERO + n) = SUC n) /\ (SUC (n + ZERO) = SUC n) /\
     (SUC (BIT1 n + BIT1 m) = BIT1 (SUC (n + m))) /\
     (SUC (BIT1 n + BIT2 m) = BIT2 (SUC (n + m))) /\
     (SUC (BIT2 n + BIT1 m) = BIT2 (SUC (n + m))) /\
     (SUC (BIT2 n + BIT2 m) = BIT1 (numeral$iiSUC (n + m))) /\
     (numeral$iiSUC (ZERO + n) = numeral$iiSUC n) /\
     (numeral$iiSUC (n + ZERO) = numeral$iiSUC n) /\
     (numeral$iiSUC (BIT1 n + BIT1 m) = BIT2 (SUC (n + m))) /\
     (numeral$iiSUC (BIT1 n + BIT2 m) = BIT1 (numeral$iiSUC (n + m))) /\
     (numeral$iiSUC (BIT2 n + BIT1 m) = BIT1 (numeral$iiSUC (n + m))) /\
     (numeral$iiSUC (BIT2 n + BIT2 m) = BIT2 (numeral$iiSUC (n + m)))
</PRE>

<DT><STRONG><font color="black">numeral_eq</font></STRONG>
<DD>
<PRE>
|- !n m.
     ((ZERO = BIT1 n) <=> F) /\ ((BIT1 n = ZERO) <=> F) /\
     ((ZERO = BIT2 n) <=> F) /\ ((BIT2 n = ZERO) <=> F) /\
     ((BIT1 n = BIT2 m) <=> F) /\ ((BIT2 n = BIT1 m) <=> F) /\
     ((BIT1 n = BIT1 m) <=> (n = m)) /\ ((BIT2 n = BIT2 m) <=> (n = m))
</PRE>

<DT><STRONG><font color="black">numeral_lt</font></STRONG>
<DD>
<PRE>
|- !n m.
     (ZERO < BIT1 n <=> T) /\ (ZERO < BIT2 n <=> T) /\ (n < ZERO <=> F) /\
     (BIT1 n < BIT1 m <=> n < m) /\ (BIT2 n < BIT2 m <=> n < m) /\
     (BIT1 n < BIT2 m <=> ~(m < n)) /\ (BIT2 n < BIT1 m <=> n < m)
</PRE>

<DT><STRONG><font color="black">numeral_lte</font></STRONG>
<DD>
<PRE>
|- !n m.
     (ZERO <= n <=> T) /\ (BIT1 n <= ZERO <=> F) /\ (BIT2 n <= ZERO <=> F) /\
     (BIT1 n <= BIT1 m <=> n <= m) /\ (BIT1 n <= BIT2 m <=> n <= m) /\
     (BIT2 n <= BIT1 m <=> ~(m <= n)) /\ (BIT2 n <= BIT2 m <=> n <= m)
</PRE>

<DT><STRONG><font color="black">numeral_pre</font></STRONG>
<DD>
<PRE>
|- (PRE ZERO = ZERO) /\ (PRE (BIT1 ZERO) = ZERO) /\
   (!n. PRE (BIT1 (BIT1 n)) = BIT2 (PRE (BIT1 n))) /\
   (!n. PRE (BIT1 (BIT2 n)) = BIT2 (BIT1 n)) /\ !n. PRE (BIT2 n) = BIT1 n
</PRE>

<DT><STRONG><font color="black">bit_initiality</font></STRONG>
<DD>
<PRE>
|- !zf b1f b2f.
     ?f.
       (f ZERO = zf) /\ (!n. f (BIT1 n) = b1f n (f n)) /\
       !n. f (BIT2 n) = b2f n (f n)
</PRE>

<DT><STRONG><font color="black">bit_induction</font></STRONG>
<DD>
<PRE>
|- !P.
     P ZERO /\ (!n. P n ==> P (BIT1 n)) /\ (!n. P n ==> P (BIT2 n)) ==>
     !n. P n
</PRE>

<DT><STRONG><font color="black">iSUB_THM</font></STRONG>
<DD>
<PRE>
|- !b n m.
     (numeral$iSUB b ZERO x = ZERO) /\ (numeral$iSUB T n ZERO = n) /\
     (numeral$iSUB F (BIT1 n) ZERO = numeral$iDUB n) /\
     (numeral$iSUB T (BIT1 n) (BIT1 m) = numeral$iDUB (numeral$iSUB T n m)) /\
     (numeral$iSUB F (BIT1 n) (BIT1 m) = BIT1 (numeral$iSUB F n m)) /\
     (numeral$iSUB T (BIT1 n) (BIT2 m) = BIT1 (numeral$iSUB F n m)) /\
     (numeral$iSUB F (BIT1 n) (BIT2 m) = numeral$iDUB (numeral$iSUB F n m)) /\
     (numeral$iSUB F (BIT2 n) ZERO = BIT1 n) /\
     (numeral$iSUB T (BIT2 n) (BIT1 m) = BIT1 (numeral$iSUB T n m)) /\
     (numeral$iSUB F (BIT2 n) (BIT1 m) = numeral$iDUB (numeral$iSUB T n m)) /\
     (numeral$iSUB T (BIT2 n) (BIT2 m) = numeral$iDUB (numeral$iSUB T n m)) /\
     (numeral$iSUB F (BIT2 n) (BIT2 m) = BIT1 (numeral$iSUB F n m))
</PRE>

<DT><STRONG><font color="black">numeral_sub</font></STRONG>
<DD>
<PRE>
|- !n m. NUMERAL (n - m) = if m < n then NUMERAL (numeral$iSUB T n m) else 0
</PRE>

<DT><STRONG><font color="black">iDUB_removal</font></STRONG>
<DD>
<PRE>
|- !n.
     (numeral$iDUB (BIT1 n) = BIT2 (numeral$iDUB n)) /\
     (numeral$iDUB (BIT2 n) = BIT2 (BIT1 n)) /\ (numeral$iDUB ZERO = ZERO)
</PRE>

<DT><STRONG><font color="black">numeral_mult</font></STRONG>
<DD>
<PRE>
|- !n m.
     (ZERO * n = ZERO) /\ (n * ZERO = ZERO) /\
     (BIT1 n * m = numeral$iZ (numeral$iDUB (n * m) + m)) /\
     (BIT2 n * m = numeral$iDUB (numeral$iZ (n * m + m)))
</PRE>

<DT><STRONG><font color="black">numeral_exp</font></STRONG>
<DD>
<PRE>
|- (!n. n ** ZERO = BIT1 ZERO) /\
   (!n m. n ** BIT1 m = n * numeral$iSQR (n ** m)) /\
   !n m. n ** BIT2 m = numeral$iSQR n * numeral$iSQR (n ** m)
</PRE>

<DT><STRONG><font color="black">numeral_evenodd</font></STRONG>
<DD>
<PRE>
|- !n.
     EVEN ZERO /\ EVEN (BIT2 n) /\ ~EVEN (BIT1 n) /\ ~ODD ZERO /\
     ~ODD (BIT2 n) /\ ODD (BIT1 n)
</PRE>

<DT><STRONG><font color="black">numeral_fact</font></STRONG>
<DD>
<PRE>
|- (FACT 0 = 1) /\
   (!n.
      FACT (NUMERAL (BIT1 n)) =
      NUMERAL (BIT1 n) * FACT (PRE (NUMERAL (BIT1 n)))) /\
   !n. FACT (NUMERAL (BIT2 n)) = NUMERAL (BIT2 n) * FACT (NUMERAL (BIT1 n))
</PRE>

<DT><STRONG><font color="black">numeral_funpow</font></STRONG>
<DD>
<PRE>
|- (FUNPOW f 0 x = x) /\
   (FUNPOW f (NUMERAL (BIT1 n)) x =
    FUNPOW f (PRE (NUMERAL (BIT1 n))) (f x)) /\
   (FUNPOW f (NUMERAL (BIT2 n)) x = FUNPOW f (NUMERAL (BIT1 n)) (f x))
</PRE>

<DT><STRONG><font color="black">numeral_MIN</font></STRONG>
<DD>
<PRE>
|- (MIN 0 x = 0) /\ (MIN x 0 = 0) /\
   (MIN (NUMERAL x) (NUMERAL y) = NUMERAL (if x < y then x else y))
</PRE>

<DT><STRONG><font color="black">numeral_MAX</font></STRONG>
<DD>
<PRE>
|- (MAX 0 x = x) /\ (MAX x 0 = x) /\
   (MAX (NUMERAL x) (NUMERAL y) = NUMERAL (if x < y then y else x))
</PRE>

<DT><STRONG><font color="black">divmod_POS</font></STRONG>
<DD>
<PRE>
|- !n.
     0 < n ==>
     (DIVMOD (a,m,n) =
      if m < n then
        (a,m)
      else
        (let q = findq (1,m,n) in DIVMOD (a + q,m - n * q,n)))
</PRE>

<DT><STRONG><font color="black">DIVMOD_NUMERAL_CALC</font></STRONG>
<DD>
<PRE>
|- (!m n. m DIV BIT1 n = FST (DIVMOD (ZERO,m,BIT1 n))) /\
   (!m n. m DIV BIT2 n = FST (DIVMOD (ZERO,m,BIT2 n))) /\
   (!m n. m MOD BIT1 n = SND (DIVMOD (ZERO,m,BIT1 n))) /\
   !m n. m MOD BIT2 n = SND (DIVMOD (ZERO,m,BIT2 n))
</PRE>

<DT><STRONG><font color="black">numeral_div2</font></STRONG>
<DD>
<PRE>
|- (DIV2 0 = 0) /\ (!n. DIV2 (NUMERAL (BIT1 n)) = NUMERAL n) /\
   !n. DIV2 (NUMERAL (BIT2 n)) = NUMERAL (SUC n)
</PRE>

<DT><STRONG><font color="black">numeral_imod_2exp</font></STRONG>
<DD>
<PRE>
|- (!n. numeral$iMOD_2EXP 0 n = ZERO) /\
   (!x n. numeral$iMOD_2EXP x ZERO = ZERO) /\
   (!x n.
      numeral$iMOD_2EXP (NUMERAL (BIT1 x)) (BIT1 n) =
      BIT1 (numeral$iMOD_2EXP (NUMERAL (BIT1 x) - 1) n)) /\
   (!x n.
      numeral$iMOD_2EXP (NUMERAL (BIT2 x)) (BIT1 n) =
      BIT1 (numeral$iMOD_2EXP (NUMERAL (BIT1 x)) n)) /\
   (!x n.
      numeral$iMOD_2EXP (NUMERAL (BIT1 x)) (BIT2 n) =
      numeral$iDUB (numeral$iMOD_2EXP (NUMERAL (BIT1 x) - 1) (SUC n))) /\
   !x n.
     numeral$iMOD_2EXP (NUMERAL (BIT2 x)) (BIT2 n) =
     numeral$iDUB (numeral$iMOD_2EXP (NUMERAL (BIT1 x)) (SUC n))
</PRE>

<DT><STRONG><font color="black">MOD_2EXP</font></STRONG>
<DD>
<PRE>
|- (!x. MOD_2EXP x 0 = 0) /\
   !x n. MOD_2EXP x (NUMERAL n) = NUMERAL (numeral$iMOD_2EXP x n)
</PRE>

<DT><STRONG><font color="black">DIV_2EXP</font></STRONG>
<DD>
<PRE>
|- !n x. DIV_2EXP n x = FUNPOW DIV2 n x
</PRE>

<DT><STRONG><font color="black">texp_help_thm</font></STRONG>
<DD>
<PRE>
|- !n a. numeral$texp_help n a = (a + 1) * 2 ** (n + 1)
</PRE>

<DT><STRONG><font color="black">texp_help0</font></STRONG>
<DD>
<PRE>
|- numeral$texp_help n 0 = 2 ** (n + 1)
</PRE>

<DT><STRONG><font color="black">numeral_texp_help</font></STRONG>
<DD>
<PRE>
|- (numeral$texp_help ZERO acc = BIT2 acc) /\
   (numeral$texp_help (BIT1 n) acc =
    numeral$texp_help (PRE (BIT1 n)) (BIT1 acc)) /\
   (numeral$texp_help (BIT2 n) acc = numeral$texp_help (BIT1 n) (BIT1 acc))
</PRE>

<DT><STRONG><font color="black">TWO_EXP_THM</font></STRONG>
<DD>
<PRE>
|- (2 ** 0 = 1) /\
   (2 ** NUMERAL (BIT1 n) =
    NUMERAL (numeral$texp_help (PRE (BIT1 n)) ZERO)) /\
   (2 ** NUMERAL (BIT2 n) = NUMERAL (numeral$texp_help (BIT1 n) ZERO))
</PRE>

<DT><STRONG><font color="black">onecount_characterisation</font></STRONG>
<DD>
<PRE>
|- !n a.
     0 < numeral$onecount n a /\ 0 < n ==>
     (n = 2 ** (numeral$onecount n a - a) - 1)
</PRE>

<DT><STRONG><font color="black">exactlog_characterisation</font></STRONG>
<DD>
<PRE>
|- !n m. (numeral$exactlog n = BIT1 m) ==> (n = 2 ** (m + 1))
</PRE>

<DT><STRONG><font color="black">DIV2_BIT1</font></STRONG>
<DD>
<PRE>
|- DIV2 (BIT1 x) = x
</PRE>

<DT><STRONG><font color="black">enumeral_mult</font></STRONG>
<DD>
<PRE>
|- (ZERO * n = ZERO) /\ (n * ZERO = ZERO) /\
   (BIT1 x * BIT1 y = internal_mult (BIT1 x) (BIT1 y)) /\
   (BIT1 x * BIT2 y =
    (let n = numeral$exactlog (BIT2 y) in
       if ODD n then
         numeral$texp_help (DIV2 n) (PRE (BIT1 x))
       else
         internal_mult (BIT1 x) (BIT2 y))) /\
   (BIT2 x * BIT1 y =
    (let m = numeral$exactlog (BIT2 x) in
       if ODD m then
         numeral$texp_help (DIV2 m) (PRE (BIT1 y))
       else
         internal_mult (BIT2 x) (BIT1 y))) /\
   (BIT2 x * BIT2 y =
    (let m = numeral$exactlog (BIT2 x) in
     let n = numeral$exactlog (BIT2 y) in
       if ODD m then
         numeral$texp_help (DIV2 m) (PRE (BIT2 y))
       else
         if ODD n then
           numeral$texp_help (DIV2 n) (PRE (BIT2 x))
         else
           internal_mult (BIT2 x) (BIT2 y)))
</PRE>

<DT><STRONG><font color="black">internal_mult_characterisation</font></STRONG>
<DD>
<PRE>
|- !n m.
     (internal_mult ZERO n = ZERO) /\ (internal_mult n ZERO = ZERO) /\
     (internal_mult (BIT1 n) m =
      numeral$iZ (numeral$iDUB (internal_mult n m) + m)) /\
     (internal_mult (BIT2 n) m =
      numeral$iDUB (numeral$iZ (internal_mult n m + m)))
</PRE>

</DL>



<HR>
</BODY>
</HTML>
