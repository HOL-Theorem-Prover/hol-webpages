<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: bitstring</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "bitstring"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "wordsTheory.html"><span class="strong">words</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">add</span>
    <td>
    :bitstring -> bitstring -> bitstring
    <tr><td>
    <span class="strong">band</span>
    <td>
    :bitstring -> bitstring -> bitstring
    <tr><td>
    <span class="strong">bitify</span>
    <td>
    :num list -> bitstring -> num list
    <tr><td>
    <span class="strong">bitwise</span>
    <td>
    :bool reln -> bitstring -> bitstring -> bitstring
    <tr><td>
    <span class="strong">bnand</span>
    <td>
    :bitstring -> bitstring -> bitstring
    <tr><td>
    <span class="strong">bnor</span>
    <td>
    :bitstring -> bitstring -> bitstring
    <tr><td> <span class="strong">bnot</span> <td> :bitstring -> bitstring
    <tr><td>
    <span class="strong">boolify</span>
    <td>
    :bitstring -> num list -> bitstring
    <tr><td>
    <span class="strong">bor</span>
    <td>
    :bitstring -> bitstring -> bitstring
    <tr><td>
    <span class="strong">bxnor</span>
    <td>
    :bitstring -> bitstring -> bitstring
    <tr><td>
    <span class="strong">bxor</span>
    <td>
    :bitstring -> bitstring -> bitstring
    <tr><td>
    <span class="strong">extend</span>
    <td>
    :bool -> num -> bitstring -> bitstring
    <tr><td>
    <span class="strong">field</span>
    <td>
    :num -> num -> bitstring -> bitstring
    <tr><td>
    <span class="strong">field_insert</span>
    <td>
    :num -> num -> bitstring -> bitstring -> bitstring
    <tr><td>
    <span class="strong">fixwidth</span>
    <td>
    :num -> bitstring -> bitstring
    <tr><td>
    <span class="strong">modify</span>
    <td>
    :(num -> bool -> bool) -> bitstring -> bitstring
    <tr><td> <span class="strong">n2v</span> <td> :num -> bitstring
    <tr><td>
    <span class="strong">replicate</span>
    <td>
    :bitstring -> num -> bitstring
    <tr><td> <span class="strong">rev_count_list</span> <td> :num -> num list
    <tr><td>
    <span class="strong">rotate</span>
    <td>
    :bitstring -> num -> bitstring
    <tr><td> <span class="strong">s2v</span> <td> :string -> bitstring
    <tr><td>
    <span class="strong">shiftl</span>
    <td>
    :bitstring -> num -> bitstring
    <tr><td>
    <span class="strong">shiftr</span>
    <td>
    :bitstring -> num -> bitstring
    <tr><td>
    <span class="strong">sign_extend</span>
    <td>
    :num -> ฮฑ list -> ฮฑ list
    <tr><td>
    <span class="strong">testbit</span>
    <td>
    :num -> bitstring -> bool
    <tr><td> <span class="strong">v2n</span> <td> :bitstring -> num
    <tr><td> <span class="strong">v2s</span> <td> :bitstring -> string
    <tr><td> <span class="strong">v2w</span> <td> :bitstring -> ฮฑ word
    <tr><td> <span class="strong">w2v</span> <td> :ฮฑ word -> bitstring
    <tr><td>
    <span class="strong">zero_extend</span>
    <td>
    :num -> bitstring -> bitstring
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">extend_def</span>
<DD>
<pre>
โข (โv0 l. extend v0 0 l = l) โง โc n l. extend c (SUC n) l = extend c n (c::l)
</pre>

<DT><span class="strong">boolify_def</span>
<DD>
<pre>
โข (โa. boolify a [] = a) โง โa n l. boolify a (n::l) = boolify ((n โ 0)::a) l
</pre>

<DT><span class="strong">n2v_def</span>
<DD>
<pre>
โข โn. n2v n = boolify [] (num_to_bin_list n)
</pre>

<DT><span class="strong">v2n_def</span>
<DD>
<pre>
โข โl. v2n l = num_from_bin_list (bitify [] l)
</pre>

<DT><span class="strong">s2v_def</span>
<DD>
<pre>
โข s2v = MAP (ฮปc. c = #"1" โจ c = #"T")
</pre>

<DT><span class="strong">v2s_def</span>
<DD>
<pre>
โข v2s = MAP (ฮปb. if b then #"1" else #"0")
</pre>

<DT><span class="strong">zero_extend_def</span>
<DD>
<pre>
โข โn v. zero_extend n v = PAD_LEFT F n v
</pre>

<DT><span class="strong">sign_extend_def</span>
<DD>
<pre>
โข โn v. sign_extend n v = PAD_LEFT (HD v) n v
</pre>

<DT><span class="strong">fixwidth_def</span>
<DD>
<pre>
โข โn v.
      fixwidth n v =
      (let l = LENGTH v in if l < n then zero_extend n v else DROP (l โ n) v)
</pre>

<DT><span class="strong">shiftl_def</span>
<DD>
<pre>
โข โv m. shiftl v m = PAD_RIGHT F (LENGTH v + m) v
</pre>

<DT><span class="strong">shiftr_def</span>
<DD>
<pre>
โข โv m. shiftr v m = TAKE (LENGTH v โ m) v
</pre>

<DT><span class="strong">field_def</span>
<DD>
<pre>
โข โh l v. field h l v = fixwidth (SUC h โ l) (shiftr v l)
</pre>

<DT><span class="strong">rotate_def</span>
<DD>
<pre>
โข โv m.
      rotate v m =
      (let
         l = LENGTH v ;
         x = m MOD l
       in
         if l = 0 โจ x = 0 then v else field (x โ 1) 0 v ++ field (l โ 1) x v)
</pre>

<DT><span class="strong">testbit_def</span>
<DD>
<pre>
โข โb v. testbit b v โ field b b v = [T]
</pre>

<DT><span class="strong">w2v_def</span>
<DD>
<pre>
โข โw. w2v w = GENLIST (ฮปi. w ' (dimindex (:ฮฑ) โ 1 โ i)) (dimindex (:ฮฑ))
</pre>

<DT><span class="strong">v2w_def</span>
<DD>
<pre>
โข โv. v2w v = FCP i. testbit i v
</pre>

<DT><span class="strong">rev_count_list_def</span>
<DD>
<pre>
โข โn. rev_count_list n = GENLIST (ฮปi. n โ 1 โ i) n
</pre>

<DT><span class="strong">modify_def</span>
<DD>
<pre>
โข โf v. modify f v = MAP (UNCURRY f) (ZIP (rev_count_list (LENGTH v),v))
</pre>

<DT><span class="strong">field_insert_def</span>
<DD>
<pre>
โข โh l s.
      field_insert h l s =
      modify (ฮปi. COND (l โค i โง i โค h) (testbit (i โ l) s))
</pre>

<DT><span class="strong">add_def</span>
<DD>
<pre>
โข โa b.
      add a b =
      (let
         m = MAX (LENGTH a) (LENGTH b)
       in
         zero_extend m (n2v (v2n a + v2n b)))
</pre>

<DT><span class="strong">bitwise_def</span>
<DD>
<pre>
โข โf v1 v2.
      bitwise f v1 v2 =
      (let
         m = MAX (LENGTH v1) (LENGTH v2)
       in
         MAP (UNCURRY f) (ZIP (fixwidth m v1,fixwidth m v2)))
</pre>

<DT><span class="strong">bnot_def</span>
<DD>
<pre>
โข bnot = MAP $~
</pre>

<DT><span class="strong">bor_def</span>
<DD>
<pre>
โข bor = bitwise $\/
</pre>

<DT><span class="strong">band_def</span>
<DD>
<pre>
โข band = bitwise $/\
</pre>

<DT><span class="strong">bxor_def</span>
<DD>
<pre>
โข bxor = bitwise (ฮปx y. x โ y)
</pre>

<DT><span class="strong">bnor_def</span>
<DD>
<pre>
โข bnor = bitwise (ฮปx y. ยฌ(x โจ y))
</pre>

<DT><span class="strong">bxnor_def</span>
<DD>
<pre>
โข bxnor = bitwise $<=>
</pre>

<DT><span class="strong">bnand_def</span>
<DD>
<pre>
โข bnand = bitwise (ฮปx y. ยฌ(x โง y))
</pre>

<DT><span class="strong">replicate_def</span>
<DD>
<pre>
โข โv n. replicate v n = FLAT (GENLIST (K v) n)
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">extend_def_compute</span>
<DD>
<pre>
โข (โv0 l. extend v0 0 l = l) โง
  (โc n l.
       extend c (NUMERAL (BIT1 n)) l = extend c (NUMERAL (BIT1 n) โ 1) (c::l)) โง
  โc n l. extend c (NUMERAL (BIT2 n)) l = extend c (NUMERAL (BIT1 n)) (c::l)
</pre>

<DT><span class="strong">bitify_ind</span>
<DD>
<pre>
โข โP.
      (โa. P a []) โง (โa l. P (0::a) l โ P a (F::l)) โง
      (โa l. P (1::a) l โ P a (T::l)) โ
      โv v1. P v v1
</pre>

<DT><span class="strong">bitify_def</span>
<DD>
<pre>
โข (โa. bitify a [] = a) โง (โl a. bitify a (F::l) = bitify (0::a) l) โง
  โl a. bitify a (T::l) = bitify (1::a) l
</pre>

<DT><span class="strong">extend_cons</span>
<DD>
<pre>
โข โn c l. extend c (SUC n) l = c::extend c n l
</pre>

<DT><span class="strong">pad_left_extend</span>
<DD>
<pre>
โข โn l c. PAD_LEFT c n l = extend c (n โ LENGTH l) l
</pre>

<DT><span class="strong">extend</span>
<DD>
<pre>
โข (โn v. zero_extend n v = extend F (n โ LENGTH v) v) โง
  โn v. sign_extend n v = extend (HD v) (n โ LENGTH v) v
</pre>

<DT><span class="strong">fixwidth</span>
<DD>
<pre>
โข โn v.
      fixwidth n v =
      (let
         l = LENGTH v
       in
         if l < n then extend F (n โ l) v else DROP (l โ n) v)
</pre>

<DT><span class="strong">fixwidth_id</span>
<DD>
<pre>
โข โw. fixwidth (LENGTH w) w = w
</pre>

<DT><span class="strong">fixwidth_id_imp</span>
<DD>
<pre>
โข โn w. n = LENGTH w โ fixwidth n w = w
</pre>

<DT><span class="strong">boolify_reverse_map</span>
<DD>
<pre>
โข โv a. boolify a v = REVERSE (MAP (ฮปn. n โ 0) v) ++ a
</pre>

<DT><span class="strong">bitify_reverse_map</span>
<DD>
<pre>
โข โv a. bitify a v = REVERSE (MAP (ฮปb. if b then 1 else 0) v) ++ a
</pre>

<DT><span class="strong">every_bit_bitify</span>
<DD>
<pre>
โข โv. EVERY ($> 2) (bitify [] v)
</pre>

<DT><span class="strong">length_pad_left</span>
<DD>
<pre>
โข โx n a. LENGTH (PAD_LEFT x n a) = if LENGTH a < n then n else LENGTH a
</pre>

<DT><span class="strong">length_pad_right</span>
<DD>
<pre>
โข โx n a. LENGTH (PAD_RIGHT x n a) = if LENGTH a < n then n else LENGTH a
</pre>

<DT><span class="strong">length_zero_extend</span>
<DD>
<pre>
โข โn v. LENGTH v < n โ LENGTH (zero_extend n v) = n
</pre>

<DT><span class="strong">length_sign_extend</span>
<DD>
<pre>
โข โn v. LENGTH v < n โ LENGTH (sign_extend n v) = n
</pre>

<DT><span class="strong">length_fixwidth</span>
<DD>
<pre>
โข โn v. LENGTH (fixwidth n v) = n
</pre>

<DT><span class="strong">length_field</span>
<DD>
<pre>
โข โh l v. LENGTH (field h l v) = SUC h โ l
</pre>

<DT><span class="strong">length_bitify</span>
<DD>
<pre>
โข โv l. LENGTH (bitify l v) = LENGTH l + LENGTH v
</pre>

<DT><span class="strong">length_bitify_null</span>
<DD>
<pre>
โข โv l. LENGTH (bitify [] v) = LENGTH v
</pre>

<DT><span class="strong">length_shiftr</span>
<DD>
<pre>
โข โv n. LENGTH (shiftr v n) = LENGTH v โ n
</pre>

<DT><span class="strong">length_rev_count_list</span>
<DD>
<pre>
โข โn. LENGTH (rev_count_list n) = n
</pre>

<DT><span class="strong">length_w2v</span>
<DD>
<pre>
โข โw. LENGTH (w2v w) = dimindex (:ฮฑ)
</pre>

<DT><span class="strong">length_rotate</span>
<DD>
<pre>
โข โv n. LENGTH (rotate v n) = LENGTH v
</pre>

<DT><span class="strong">el_rev_count_list</span>
<DD>
<pre>
โข โn i. i < n โ EL i (rev_count_list n) = n โ 1 โ i
</pre>

<DT><span class="strong">el_zero_extend</span>
<DD>
<pre>
โข โn i v.
      EL i (zero_extend n v) โ n โ LENGTH v โค i โง EL (i โ (n โ LENGTH v)) v
</pre>

<DT><span class="strong">el_sign_extend</span>
<DD>
<pre>
โข โn i v.
      EL i (sign_extend n v) = if i < n โ LENGTH v then EL 0 v
      else EL (i โ (n โ LENGTH v)) v
</pre>

<DT><span class="strong">el_fixwidth</span>
<DD>
<pre>
โข โi n w.
      i < n โ
      (EL i (fixwidth n w) โ
       if LENGTH w < n then n โ LENGTH w โค i โง EL (i โ (n โ LENGTH w)) w
       else EL (i + (LENGTH w โ n)) w)
</pre>

<DT><span class="strong">el_field</span>
<DD>
<pre>
โข โv h l i.
      i < SUC h โ l โ
      (EL i (field h l v) โ SUC h โค i + LENGTH v โง EL (i + LENGTH v โ SUC h) v)
</pre>

<DT><span class="strong">el_w2v</span>
<DD>
<pre>
โข โw n. n < dimindex (:ฮฑ) โ (EL n (w2v w) โ w ' (dimindex (:ฮฑ) โ 1 โ n))
</pre>

<DT><span class="strong">el_shiftr</span>
<DD>
<pre>
โข โi v n d.
      n < d โง i < d โ n โง 0 < d โ
      (EL i (shiftr (fixwidth d v) n) โ
       d โค i + LENGTH v โง EL (i + LENGTH v โ d) v)
</pre>

<DT><span class="strong">shiftr_0</span>
<DD>
<pre>
โข โv. shiftr v 0 = v
</pre>

<DT><span class="strong">field_fixwidth</span>
<DD>
<pre>
โข โh v. field h 0 v = fixwidth (SUC h) v
</pre>

<DT><span class="strong">testbit</span>
<DD>
<pre>
โข โb v. testbit b v โ (let n = LENGTH v in b < n โง EL (n โ 1 โ b) v)
</pre>

<DT><span class="strong">testbit_geq_len</span>
<DD>
<pre>
โข โv i. LENGTH v โค i โ ยฌtestbit i v
</pre>

<DT><span class="strong">testbit_el</span>
<DD>
<pre>
โข โv i. i < LENGTH v โ (testbit i v โ EL (LENGTH v โ 1 โ i) v)
</pre>

<DT><span class="strong">bit_v2w</span>
<DD>
<pre>
โข โn v. word_bit n (v2w v) โ n < dimindex (:ฮฑ) โง testbit n v
</pre>

<DT><span class="strong">word_index_v2w</span>
<DD>
<pre>
โข โv i.
      v2w v ' i โ if i < dimindex (:ฮฑ) then testbit i v
      else FAIL $' index too large (v2w v) i
</pre>

<DT><span class="strong">testbit_w2v</span>
<DD>
<pre>
โข โn w. testbit n (w2v w) โ word_bit n w
</pre>

<DT><span class="strong">w2v_v2w</span>
<DD>
<pre>
โข โv. w2v (v2w v) = fixwidth (dimindex (:ฮฑ)) v
</pre>

<DT><span class="strong">v2w_w2v</span>
<DD>
<pre>
โข โw. v2w (w2v w) = w
</pre>

<DT><span class="strong">v2w_fixwidth</span>
<DD>
<pre>
โข โv. v2w (fixwidth (dimindex (:ฮฑ)) v) = v2w v
</pre>

<DT><span class="strong">fixwidth_fixwidth</span>
<DD>
<pre>
โข โn v. fixwidth n (fixwidth n v) = fixwidth n v
</pre>

<DT><span class="strong">bitstring_nchotomy</span>
<DD>
<pre>
โข โw. โv. w = v2w v
</pre>

<DT><span class="strong">ranged_bitstring_nchotomy</span>
<DD>
<pre>
โข โw. โv. w = v2w v โง Abbrev (LENGTH v = dimindex (:ฮฑ))
</pre>

<DT><span class="strong">fixwidth_eq</span>
<DD>
<pre>
โข โn v w.
      fixwidth n v = fixwidth n w โ โi. i < n โ (testbit i v โ testbit i w)
</pre>

<DT><span class="strong">v2w_11</span>
<DD>
<pre>
โข โv w.
      v2w v = v2w w โ fixwidth (dimindex (:ฮฑ)) v = fixwidth (dimindex (:ฮฑ)) w
</pre>

<DT><span class="strong">field_concat_right</span>
<DD>
<pre>
โข โh a b. LENGTH b = SUC h โ field h 0 (a ++ b) = b
</pre>

<DT><span class="strong">field_concat_left</span>
<DD>
<pre>
โข โh l a b.
      l โค h โง LENGTH b โค l โ
      field h l (a ++ b) = field (h โ LENGTH b) (l โ LENGTH b) a
</pre>

<DT><span class="strong">field_id_imp</span>
<DD>
<pre>
โข โn v. SUC n = LENGTH v โ field n 0 v = v
</pre>

<DT><span class="strong">shiftl_replicate_F</span>
<DD>
<pre>
โข โv n. shiftl v n = v ++ replicate [F] n
</pre>

<DT><span class="strong">word_lsb_v2w</span>
<DD>
<pre>
โข โv. word_lsb (v2w v) โ v โ [] โง LAST v
</pre>

<DT><span class="strong">word_msb_v2w</span>
<DD>
<pre>
โข โv. word_msb (v2w v) โ testbit (dimindex (:ฮฑ) โ 1) v
</pre>

<DT><span class="strong">w2w_v2w</span>
<DD>
<pre>
โข โv.
      w2w (v2w v) =
      v2w
        (fixwidth
           (if dimindex (:ฮฒ) < dimindex (:ฮฑ) then dimindex (:ฮฒ)
            else dimindex (:ฮฑ)) v)
</pre>

<DT><span class="strong">sw2sw_v2w</span>
<DD>
<pre>
โข โv.
      sw2sw (v2w v) =
      if dimindex (:ฮฑ) < dimindex (:ฮฒ) then
        v2w (sign_extend (dimindex (:ฮฒ)) (fixwidth (dimindex (:ฮฑ)) v))
      else v2w (fixwidth (dimindex (:ฮฒ)) v)
</pre>

<DT><span class="strong">n2w_v2n</span>
<DD>
<pre>
โข โv. n2w (v2n v) = v2w v
</pre>

<DT><span class="strong">v2n_n2v</span>
<DD>
<pre>
โข โn. v2n (n2v n) = n
</pre>

<DT><span class="strong">v2w_n2v</span>
<DD>
<pre>
โข โn. v2w (n2v n) = n2w n
</pre>

<DT><span class="strong">w2n_v2w</span>
<DD>
<pre>
โข โv. w2n (v2w v) = MOD_2EXP (dimindex (:ฮฑ)) (v2n v)
</pre>

<DT><span class="strong">v2n_lt</span>
<DD>
<pre>
โข โv. v2n v < 2 ** LENGTH v
</pre>

<DT><span class="strong">word_and_v2w</span>
<DD>
<pre>
โข โv w. (v2w v && v2w w) = v2w (band v w)
</pre>

<DT><span class="strong">word_or_v2w</span>
<DD>
<pre>
โข โv w. (v2w v โ v2w w) = v2w (bor v w)
</pre>

<DT><span class="strong">word_xor_v2w</span>
<DD>
<pre>
โข โv w. (v2w v โ v2w w) = v2w (bxor v w)
</pre>

<DT><span class="strong">word_nand_v2w</span>
<DD>
<pre>
โข โv w.
      (v2w v ~&& v2w w) =
      v2w (bnand (fixwidth (dimindex (:ฮฑ)) v) (fixwidth (dimindex (:ฮฑ)) w))
</pre>

<DT><span class="strong">word_nor_v2w</span>
<DD>
<pre>
โข โv w.
      (v2w v ~|| v2w w) =
      v2w (bnor (fixwidth (dimindex (:ฮฑ)) v) (fixwidth (dimindex (:ฮฑ)) w))
</pre>

<DT><span class="strong">word_xnor_v2w</span>
<DD>
<pre>
โข โv w.
      (v2w v ~?? v2w w) =
      v2w (bxnor (fixwidth (dimindex (:ฮฑ)) v) (fixwidth (dimindex (:ฮฑ)) w))
</pre>

<DT><span class="strong">word_1comp_v2w</span>
<DD>
<pre>
โข โv. ยฌv2w v = v2w (bnot (fixwidth (dimindex (:ฮฑ)) v))
</pre>

<DT><span class="strong">word_lsl_v2w</span>
<DD>
<pre>
โข โn v. v2w v โช n = v2w (shiftl v n)
</pre>

<DT><span class="strong">word_lsr_v2w</span>
<DD>
<pre>
โข โn v. v2w v โ n = v2w (shiftr (fixwidth (dimindex (:ฮฑ)) v) n)
</pre>

<DT><span class="strong">word_modify_v2w</span>
<DD>
<pre>
โข โf v. word_modify f (v2w v) = v2w (modify f (fixwidth (dimindex (:ฮฑ)) v))
</pre>

<DT><span class="strong">word_bits_v2w</span>
<DD>
<pre>
โข โh l v. (h -- l) (v2w v) = v2w (field h l (fixwidth (dimindex (:ฮฑ)) v))
</pre>

<DT><span class="strong">word_extract_v2w</span>
<DD>
<pre>
โข โh l v. (h >< l) (v2w v) = w2w ((h -- l) (v2w v))
</pre>

<DT><span class="strong">word_slice_v2w</span>
<DD>
<pre>
โข โh l v.
      (h '' l) (v2w v) =
      v2w (shiftl (field h l (fixwidth (dimindex (:ฮฑ)) v)) l)
</pre>

<DT><span class="strong">word_asr_v2w</span>
<DD>
<pre>
โข โn v.
      v2w v โซ n =
      (let
         l = fixwidth (dimindex (:ฮฑ)) v
       in
         v2w
           (sign_extend (dimindex (:ฮฑ))
              (if dimindex (:ฮฑ) โค n then [HD l] else shiftr l n)))
</pre>

<DT><span class="strong">word_ror_v2w</span>
<DD>
<pre>
โข โn v. v2w v โ n = v2w (rotate (fixwidth (dimindex (:ฮฑ)) v) n)
</pre>

<DT><span class="strong">word_reverse_v2w</span>
<DD>
<pre>
โข โv. word_reverse (v2w v) = v2w (REVERSE (fixwidth (dimindex (:ฮฑ)) v))
</pre>

<DT><span class="strong">word_join_v2w</span>
<DD>
<pre>
โข โv1 v2.
      FINITE ๐(:ฮฑ) โง FINITE ๐(:ฮฒ) โ
      word_join (v2w v1) (v2w v2) = v2w (v1 ++ fixwidth (dimindex (:ฮฒ)) v2)
</pre>

<DT><span class="strong">word_concat_v2w</span>
<DD>
<pre>
โข โv1 v2.
      FINITE ๐(:ฮฑ) โง FINITE ๐(:ฮฒ) โ
      v2w v1 @@ v2w v2 =
      v2w
        (fixwidth (MIN (dimindex (:ฮณ)) (dimindex (:ฮฑ) + dimindex (:ฮฒ)))
           (v1 ++ fixwidth (dimindex (:ฮฒ)) v2))
</pre>

<DT><span class="strong">word_join_v2w_rwt</span>
<DD>
<pre>
โข โv1 v2.
      word_join (v2w v1) (v2w v2) =
      if FINITE ๐(:ฮฑ) โง FINITE ๐(:ฮฒ) then
        v2w (v1 ++ fixwidth (dimindex (:ฮฒ)) v2)
      else FAIL word_join bad domain (v2w v1) (v2w v2)
</pre>

<DT><span class="strong">word_concat_v2w_rwt</span>
<DD>
<pre>
โข โv1 v2.
      v2w v1 @@ v2w v2 =
      if FINITE ๐(:ฮฑ) โง FINITE ๐(:ฮฒ) then
        v2w
          (fixwidth (MIN (dimindex (:ฮณ)) (dimindex (:ฮฑ) + dimindex (:ฮฒ)))
             (v1 ++ fixwidth (dimindex (:ฮฒ)) v2))
      else FAIL $@@ bad domain (v2w v1) (v2w v2)
</pre>

<DT><span class="strong">word_reduce_v2w</span>
<DD>
<pre>
โข โf v.
      word_reduce f (v2w v) =
      (let l = fixwidth (dimindex (:ฮฑ)) v in v2w [FOLDL f (HD l) (TL l)])
</pre>

<DT><span class="strong">reduce_and_v2w</span>
<DD>
<pre>
โข โv. reduce_and (v2w v) = word_reduce $/\ (v2w v)
</pre>

<DT><span class="strong">reduce_or_v2w</span>
<DD>
<pre>
โข โv. reduce_or (v2w v) = word_reduce $\/ (v2w v)
</pre>

<DT><span class="strong">extract_v2w</span>
<DD>
<pre>
โข โh l v.
      LENGTH v โค dimindex (:ฮฑ) โง dimindex (:ฮฒ) = SUC h โ l โง
      dimindex (:ฮฒ) โค dimindex (:ฮฑ) โ
      (h >< l) (v2w v) = v2w (field h l v)
</pre>

<DT><span class="strong">word_bit_last_shiftr</span>
<DD>
<pre>
โข โi v.
      i < dimindex (:ฮฑ) โ
      (word_bit i (v2w v) โ (let l = shiftr v i in ยฌNULL l โง LAST l))
</pre>

<DT><span class="strong">ops_to_v2w</span>
<DD>
<pre>
โข (โv n. (v2w v โ n2w n) = (v2w v โ v2w (n2v n))) โง
  (โv n. (n2w n โ v2w v) = (v2w (n2v n) โ v2w v)) โง
  (โv n. (v2w v && n2w n) = (v2w v && v2w (n2v n))) โง
  (โv n. (n2w n && v2w v) = (v2w (n2v n) && v2w v)) โง
  (โv n. (v2w v โ n2w n) = (v2w v โ v2w (n2v n))) โง
  (โv n. (n2w n โ v2w v) = (v2w (n2v n) โ v2w v)) โง
  (โv n. (v2w v ~|| n2w n) = (v2w v ~|| v2w (n2v n))) โง
  (โv n. (n2w n ~|| v2w v) = (v2w (n2v n) ~|| v2w v)) โง
  (โv n. (v2w v ~&& n2w n) = (v2w v ~&& v2w (n2v n))) โง
  (โv n. (n2w n ~&& v2w v) = (v2w (n2v n) ~&& v2w v)) โง
  (โv n. (v2w v ~?? n2w n) = (v2w v ~?? v2w (n2v n))) โง
  (โv n. (n2w n ~?? v2w v) = (v2w (n2v n) ~?? v2w v)) โง
  (โv n. v2w v @@ n2w n = v2w v @@ v2w (n2v n)) โง
  (โv n. n2w n @@ v2w v = v2w (n2v n) @@ v2w v) โง
  (โv n. word_join (v2w v) (n2w n) = word_join (v2w v) (v2w (n2v n))) โง
  โv n. word_join (n2w n) (v2w v) = word_join (v2w (n2v n)) (v2w v)
</pre>

<DT><span class="strong">ops_to_n2w</span>
<DD>
<pre>
โข (โv. -v2w v = -n2w (v2n v)) โง
  (โv. word_log2 (v2w v) = word_log2 (n2w (v2n v))) โง
  (โv n. v2w v = n2w n โ n2w (v2n v) = n2w n) โง
  (โv n. n2w n = v2w v โ n2w n = n2w (v2n v)) โง
  (โv w. v2w v + w = n2w (v2n v) + w) โง (โv w. w + v2w v = w + n2w (v2n v)) โง
  (โv w. v2w v โ w = n2w (v2n v) โ w) โง (โv w. w โ v2w v = w โ n2w (v2n v)) โง
  (โv w. v2w v * w = n2w (v2n v) * w) โง (โv w. w * v2w v = w * n2w (v2n v)) โง
  (โv w. v2w v / w = n2w (v2n v) / w) โง (โv w. w / v2w v = w / n2w (v2n v)) โง
  (โv w. v2w v // w = n2w (v2n v) // w) โง
  (โv w. w // v2w v = w // n2w (v2n v)) โง
  (โv w. word_mod (v2w v) w = word_mod (n2w (v2n v)) w) โง
  (โv w. word_mod w (v2w v) = word_mod w (n2w (v2n v))) โง
  (โv w. v2w v < w โ n2w (v2n v) < w) โง (โv w. w < v2w v โ w < n2w (v2n v)) โง
  (โv w. v2w v > w โ n2w (v2n v) > w) โง (โv w. w > v2w v โ w > n2w (v2n v)) โง
  (โv w. v2w v โค w โ n2w (v2n v) โค w) โง (โv w. w โค v2w v โ w โค n2w (v2n v)) โง
  (โv w. v2w v โฅ w โ n2w (v2n v) โฅ w) โง (โv w. w โฅ v2w v โ w โฅ n2w (v2n v)) โง
  (โv w. v2w v <โ w โ n2w (v2n v) <โ w) โง
  (โv w. w <โ v2w v โ w <โ n2w (v2n v)) โง
  (โv w. v2w v >โ w โ n2w (v2n v) >โ w) โง
  (โv w. w >โ v2w v โ w >โ n2w (v2n v)) โง
  (โv w. v2w v โคโ w โ n2w (v2n v) โคโ w) โง
  (โv w. w โคโ v2w v โ w โคโ n2w (v2n v)) โง
  (โv w. v2w v โฅโ w โ n2w (v2n v) โฅโ w) โง โv w. w โฅโ v2w v โ w โฅโ n2w (v2n v)
</pre>

</DL>



<hr>
</body>
</html>
