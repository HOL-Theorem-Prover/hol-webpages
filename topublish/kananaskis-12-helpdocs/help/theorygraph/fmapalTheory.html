<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: fmapal</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "fmapal"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "enumeralTheory.html"><span class="strong">enumeral</span></a>&nbsp;&nbsp;
    <a href = "finite_mapTheory.html"><span class="strong">finite_map</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">AP_SND</span>
    <td>
    :(β -> γ) -> α # β -> α # γ
    <tr><td>
    <span class="strong">FMAPAL</span>
    <td>
    :α toto -> (α # β) bt -> (α |-> β)
    <tr><td>
    <span class="strong">OFU</span>
    <td>
    :α toto -> (α |-> β) -> (α |-> β) -> (α |-> β)
    <tr><td>
    <span class="strong">OPTION_FLAT</span>
    <td>
    :'z list option list -> 'z list
    <tr><td>
    <span class="strong">OPTION_UPDATE</span>
    <td>
    :(α -> β option) -> (α -> β option) -> α -> β option
    <tr><td>
    <span class="strong">ORL</span>
    <td>
    :α toto -> (α, β) alist -> bool
    <tr><td>
    <span class="strong">ORL_bt</span>
    <td>
    :α toto -> (α # β) bt -> bool
    <tr><td>
    <span class="strong">ORL_bt_lb</span>
    <td>
    :α toto -> α -> (α # β) bt -> bool
    <tr><td>
    <span class="strong">ORL_bt_lb_ub</span>
    <td>
    :α toto -> α -> (α # β) bt -> α -> bool
    <tr><td>
    <span class="strong">ORL_bt_ub</span>
    <td>
    :α toto -> (α # β) bt -> α -> bool
    <tr><td>
    <span class="strong">ORL_sublists</span>
    <td>
    :α toto -> (α, β) alist option list -> bool
    <tr><td>
    <span class="strong">ORWL</span>
    <td>
    :α toto -> (α |-> β) -> (α, β) alist -> bool
    <tr><td>
    <span class="strong">UFO</span>
    <td>
    :α toto -> (α |-> β) -> (α |-> β) -> (α |-> β)
    <tr><td>
    <span class="strong">assocv</span>
    <td>
    :(α, β) alist -> α -> β option
    <tr><td>
    <span class="strong">bl_to_fmap</span>
    <td>
    :α toto -> (α # β) bl -> (α |-> β)
    <tr><td> <span class="strong">bt_map</span> <td> :(α -> β) -> α bt -> β bt
    <tr><td>
    <span class="strong">bt_rplacv_cn</span>
    <td>
    :α toto -> α # β -> (α # β) bt -> ((α # β) bt -> (α # β) bt) -> (α # β) bt
    <tr><td>
    <span class="strong">bt_to_fmap_lb</span>
    <td>
    :α toto -> α -> (α # β) bt -> (α |-> β)
    <tr><td>
    <span class="strong">bt_to_fmap_lb_ub</span>
    <td>
    :α toto -> α -> (α # β) bt -> α -> (α |-> β)
    <tr><td>
    <span class="strong">bt_to_fmap_ub</span>
    <td>
    :α toto -> (α # β) bt -> α -> (α |-> β)
    <tr><td>
    <span class="strong">bt_to_orl</span>
    <td>
    :α toto -> (α # β) bt -> (α, β) alist
    <tr><td>
    <span class="strong">bt_to_orl_ac</span>
    <td>
    :α toto -> (α # β) bt -> (α, β) alist -> (α, β) alist
    <tr><td>
    <span class="strong">bt_to_orl_lb</span>
    <td>
    :α toto -> α -> (α # β) bt -> (α, β) alist
    <tr><td>
    <span class="strong">bt_to_orl_lb_ac</span>
    <td>
    :α toto -> α -> (α # β) bt -> (α, β) alist -> (α, β) alist
    <tr><td>
    <span class="strong">bt_to_orl_lb_ub</span>
    <td>
    :α toto -> α -> (α # β) bt -> α -> (α, β) alist
    <tr><td>
    <span class="strong">bt_to_orl_lb_ub_ac</span>
    <td>
    :α toto -> α -> (α # β) bt -> α -> (α, β) alist -> (α, β) alist
    <tr><td>
    <span class="strong">bt_to_orl_lb_ub_ac_tupled_aux</span>
    <td>
    :(α toto # α # (α # β) bt # α # (α, β) alist) reln ->
    α toto # α # (α # β) bt # α # (α, β) alist -> (α, β) alist
    <tr><td>
    <span class="strong">bt_to_orl_ub</span>
    <td>
    :α toto -> (α # β) bt -> α -> (α, β) alist
    <tr><td>
    <span class="strong">bt_to_orl_ub_ac</span>
    <td>
    :α toto -> (α # β) bt -> α -> (α, β) alist -> (α, β) alist
    <tr><td>
    <span class="strong">diff_merge</span>
    <td>
    :α toto -> (α, β) alist -> α list -> (α, β) alist
    <tr><td> <span class="strong">fmap</span> <td> :(α, β) alist -> (α |-> β)
    <tr><td>
    <span class="strong">incr_build</span>
    <td>
    :α toto -> (α, β) alist -> (α, β) alist option list
    <tr><td>
    <span class="strong">incr_flat</span>
    <td>
    :α toto -> (α, β) alist option list -> (α, β) alist
    <tr><td>
    <span class="strong">incr_merge</span>
    <td>
    :α toto ->
    (α, β) alist -> (α, β) alist option list -> (α, β) alist option list
    <tr><td>
    <span class="strong">incr_sort</span>
    <td>
    :α toto -> (α, β) alist -> (α, β) alist
    <tr><td>
    <span class="strong">inter_merge</span>
    <td>
    :α toto -> (α, β) alist -> α list -> (α, β) alist
    <tr><td>
    <span class="strong">list_rplacv_cn</span>
    <td>
    :α # β -> (α, β) alist -> ((α, β) alist -> (α, β) alist) -> (α, β) alist
    <tr><td>
    <span class="strong">merge</span>
    <td>
    :α toto -> (α, β) alist -> (α, β) alist -> (α, β) alist
    <tr><td>
    <span class="strong">merge_out</span>
    <td>
    :α toto -> (α, β) alist -> (α, β) alist option list -> (α, β) alist
    <tr><td>
    <span class="strong">optry</span>
    <td>
    :'z option -> 'z option -> 'z option
    <tr><td>
    <span class="strong">optry_list</span>
    <td>
    :('z -> η option) -> 'z option list -> η option
    <tr><td>
    <span class="strong">unlookup</span>
    <td>
    :(α -> β option) -> (α |-> β)
    <tr><td>
    <span class="strong">vcossa</span>
    <td>
    :α -> (α, β) alist -> β option
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">optry</span>
<DD>
<pre>
⊢ (∀p q. optry (SOME p) q = SOME p) ∧ ∀q. optry NONE q = q
</pre>

<DT><span class="strong">vcossa</span>
<DD>
<pre>
⊢ ∀a l. vcossa a l = assocv l a
</pre>

<DT><span class="strong">OPTION_UPDATE</span>
<DD>
<pre>
⊢ ∀f g x. OPTION_UPDATE f g x = optry (f x) (g x)
</pre>

<DT><span class="strong">incr_build</span>
<DD>
<pre>
⊢ (∀cmp. incr_build cmp [] = []) ∧
  ∀cmp ab l. incr_build cmp (ab::l) = incr_merge cmp [ab] (incr_build cmp l)
</pre>

<DT><span class="strong">incr_flat</span>
<DD>
<pre>
⊢ ∀cmp lol. incr_flat cmp lol = merge_out cmp [] lol
</pre>

<DT><span class="strong">incr_sort</span>
<DD>
<pre>
⊢ ∀cmp l. incr_sort cmp l = merge_out cmp [] (incr_build cmp l)
</pre>

<DT><span class="strong">OPTION_FLAT_primitive</span>
<DD>
<pre>
⊢ OPTION_FLAT =
  WFREC (@R. WF R ∧ (∀l. R l (NONE::l)) ∧ ∀a l. R l (SOME a::l))
    (λOPTION_FLAT a'.
         case a' of
           [] => I []
         | NONE::l => I (OPTION_FLAT l)
         | SOME a::l => I (a ++ OPTION_FLAT l))
</pre>

<DT><span class="strong">unlookup</span>
<DD>
<pre>
⊢ ∀f. unlookup f = FUN_FMAP (THE ∘ f) (IS_SOME ∘ f)
</pre>

<DT><span class="strong">bt_to_fmap_lb</span>
<DD>
<pre>
⊢ ∀cmp lb t.
      bt_to_fmap_lb cmp lb t =
      DRESTRICT (FMAPAL cmp t) {x | apto cmp lb x = Less}
</pre>

<DT><span class="strong">bt_to_fmap_ub</span>
<DD>
<pre>
⊢ ∀cmp t ub.
      bt_to_fmap_ub cmp t ub =
      DRESTRICT (FMAPAL cmp t) {x | apto cmp x ub = Less}
</pre>

<DT><span class="strong">bt_to_fmap_lb_ub</span>
<DD>
<pre>
⊢ ∀cmp lb t ub.
      bt_to_fmap_lb_ub cmp lb t ub =
      DRESTRICT (FMAPAL cmp t)
        {x | apto cmp lb x = Less ∧ apto cmp x ub = Less}
</pre>

<DT><span class="strong">bt_map</span>
<DD>
<pre>
⊢ (∀f. bt_map f nt = nt) ∧
  ∀f l x r. bt_map f (node l x r) = node (bt_map f l) (f x) (bt_map f r)
</pre>

<DT><span class="strong">fmap</span>
<DD>
<pre>
⊢ ∀l. fmap l = FEMPTY |++ REVERSE l
</pre>

<DT><span class="strong">bt_to_orl_lb_ub_ac_tupled_AUX</span>
<DD>
<pre>
⊢ ∀R.
      bt_to_orl_lb_ub_ac_tupled_aux R =
      WFREC R
        (λbt_to_orl_lb_ub_ac_tupled a.
             case a of
               (cmp,lb,nt,ub,m) => I m
             | (cmp,lb,node l (x,y) r,ub,m) =>
               I
                 (if apto cmp lb x = Less then
                    if apto cmp x ub = Less then
                      bt_to_orl_lb_ub_ac_tupled
                        (cmp,lb,l,x,
                         (x,y)::bt_to_orl_lb_ub_ac_tupled (cmp,x,r,ub,m))
                    else bt_to_orl_lb_ub_ac_tupled (cmp,lb,l,ub,m)
                  else bt_to_orl_lb_ub_ac_tupled (cmp,lb,r,ub,m)))
</pre>

<DT><span class="strong">ORWL</span>
<DD>
<pre>
⊢ ∀cmp f l. ORWL cmp f l ⇔ f = fmap l ∧ ORL cmp l
</pre>

<DT><span class="strong">OFU</span>
<DD>
<pre>
⊢ ∀cmp f g. OFU cmp f g = DRESTRICT f {x | LESS_ALL cmp x (FDOM g)} FUNION g
</pre>

<DT><span class="strong">UFO</span>
<DD>
<pre>
⊢ ∀cmp f g.
      UFO cmp f g =
      f FUNION DRESTRICT g {y | ∀z. z ∈ FDOM f ⇒ apto cmp z y = Less}
</pre>

<DT><span class="strong">AP_SND</span>
<DD>
<pre>
⊢ ∀f a b. AP_SND f (a,b) = (a,f b)
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">ORL_ind</span>
<DD>
<pre>
⊢ ∀P.
      (∀cmp. P cmp []) ∧ (∀cmp a b l. P cmp l ⇒ P cmp ((a,b)::l)) ⇒
      ∀v v1. P v v1
</pre>

<DT><span class="strong">ORL</span>
<DD>
<pre>
⊢ (∀cmp. ORL cmp [] ⇔ T) ∧
  ∀l cmp b a.
      ORL cmp ((a,b)::l) ⇔ ORL cmp l ∧ ∀p q. MEM (p,q) l ⇒ apto cmp a p = Less
</pre>

<DT><span class="strong">optry_list_ind</span>
<DD>
<pre>
⊢ ∀P.
      (∀f. P f []) ∧ (∀f l. P f l ⇒ P f (NONE::l)) ∧
      (∀f z l. P f l ⇒ P f (SOME z::l)) ⇒
      ∀v v1. P v v1
</pre>

<DT><span class="strong">optry_list</span>
<DD>
<pre>
⊢ (∀f. optry_list f [] = NONE) ∧
  (∀l f. optry_list f (NONE::l) = optry_list f l) ∧
  ∀z l f. optry_list f (SOME z::l) = optry (f z) (optry_list f l)
</pre>

<DT><span class="strong">assocv_ind</span>
<DD>
<pre>
⊢ ∀P.
      (∀a. P [] a) ∧ (∀x y l a. (a ≠ x ⇒ P l a) ⇒ P ((x,y)::l) a) ⇒
      ∀v v1. P v v1
</pre>

<DT><span class="strong">assocv</span>
<DD>
<pre>
⊢ (∀a. assocv [] a = NONE) ∧
  ∀y x l a. assocv ((x,y)::l) a = if a = x then SOME y else assocv l a
</pre>

<DT><span class="strong">merge_ind</span>
<DD>
<pre>
⊢ ∀P.
      (∀cmp l. P cmp [] l) ∧ (∀cmp v4 v5. P cmp (v4::v5) []) ∧
      (∀cmp a1 b1 l1 a2 b2 l2.
           (apto cmp a1 a2 = Equal ⇒ P cmp l1 l2) ∧
           (apto cmp a1 a2 = Greater ⇒ P cmp ((a1,b1)::l1) l2) ∧
           (apto cmp a1 a2 = Less ⇒ P cmp l1 ((a2,b2)::l2)) ⇒
           P cmp ((a1,b1)::l1) ((a2,b2)::l2)) ⇒
      ∀v v1 v2. P v v1 v2
</pre>

<DT><span class="strong">merge</span>
<DD>
<pre>
⊢ (∀l cmp. merge cmp [] l = l) ∧
  (∀v5 v4 cmp. merge cmp (v4::v5) [] = v4::v5) ∧
  ∀l2 l1 cmp b2 b1 a2 a1.
      merge cmp ((a1,b1)::l1) ((a2,b2)::l2) =
      case apto cmp a1 a2 of
        Less => (a1,b1)::merge cmp l1 ((a2,b2)::l2)
      | Equal => (a1,b1)::merge cmp l1 l2
      | Greater => (a2,b2)::merge cmp ((a1,b1)::l1) l2
</pre>

<DT><span class="strong">incr_merge_ind</span>
<DD>
<pre>
⊢ ∀P.
      (∀cmp l. P cmp l []) ∧ (∀cmp l lol. P cmp l (NONE::lol)) ∧
      (∀cmp l m lol. P cmp (merge cmp l m) lol ⇒ P cmp l (SOME m::lol)) ⇒
      ∀v v1 v2. P v v1 v2
</pre>

<DT><span class="strong">incr_merge</span>
<DD>
<pre>
⊢ (∀l cmp. incr_merge cmp l [] = [SOME l]) ∧
  (∀lol l cmp. incr_merge cmp l (NONE::lol) = SOME l::lol) ∧
  ∀m lol l cmp.
      incr_merge cmp l (SOME m::lol) =
      NONE::incr_merge cmp (merge cmp l m) lol
</pre>

<DT><span class="strong">ORL_sublists_ind</span>
<DD>
<pre>
⊢ ∀P.
      (∀cmp. P cmp []) ∧ (∀cmp lol. P cmp lol ⇒ P cmp (NONE::lol)) ∧
      (∀cmp m lol. P cmp lol ⇒ P cmp (SOME m::lol)) ⇒
      ∀v v1. P v v1
</pre>

<DT><span class="strong">ORL_sublists</span>
<DD>
<pre>
⊢ (∀cmp. ORL_sublists cmp [] ⇔ T) ∧
  (∀lol cmp. ORL_sublists cmp (NONE::lol) ⇔ ORL_sublists cmp lol) ∧
  ∀m lol cmp.
      ORL_sublists cmp (SOME m::lol) ⇔ ORL cmp m ∧ ORL_sublists cmp lol
</pre>

<DT><span class="strong">merge_out_ind</span>
<DD>
<pre>
⊢ ∀P.
      (∀cmp l. P cmp l []) ∧ (∀cmp l lol. P cmp l lol ⇒ P cmp l (NONE::lol)) ∧
      (∀cmp l m lol. P cmp (merge cmp l m) lol ⇒ P cmp l (SOME m::lol)) ⇒
      ∀v v1 v2. P v v1 v2
</pre>

<DT><span class="strong">merge_out</span>
<DD>
<pre>
⊢ (∀l cmp. merge_out cmp l [] = l) ∧
  (∀lol l cmp. merge_out cmp l (NONE::lol) = merge_out cmp l lol) ∧
  ∀m lol l cmp.
      merge_out cmp l (SOME m::lol) = merge_out cmp (merge cmp l m) lol
</pre>

<DT><span class="strong">OPTION_FLAT_ind</span>
<DD>
<pre>
⊢ ∀P. P [] ∧ (∀l. P l ⇒ P (NONE::l)) ∧ (∀a l. P l ⇒ P (SOME a::l)) ⇒ ∀v. P v
</pre>

<DT><span class="strong">OPTION_FLAT</span>
<DD>
<pre>
⊢ OPTION_FLAT [] = [] ∧ (∀l. OPTION_FLAT (NONE::l) = OPTION_FLAT l) ∧
  ∀l a. OPTION_FLAT (SOME a::l) = a ++ OPTION_FLAT l
</pre>

<DT><span class="strong">bt_to_fmap_ind</span>
<DD>
<pre>
⊢ ∀P.
      (∀cmp. P cmp nt) ∧
      (∀cmp l x v r. P cmp l ∧ P cmp r ⇒ P cmp (node l (x,v) r)) ⇒
      ∀v v1. P v v1
</pre>

<DT><span class="strong">bt_to_fmap</span>
<DD>
<pre>
⊢ (∀cmp. FMAPAL cmp nt = FEMPTY) ∧
  ∀x v r l cmp.
      FMAPAL cmp (node l (x,v) r) =
      DRESTRICT (FMAPAL cmp l) {y | apto cmp y x = Less} FUNION
      FEMPTY |+ (x,v) FUNION
      DRESTRICT (FMAPAL cmp r) {z | apto cmp x z = Less}
</pre>

<DT><span class="strong">FAPPLY_nt</span>
<DD>
<pre>
⊢ ∀cmp x. FMAPAL cmp nt ' x = FEMPTY ' x
</pre>

<DT><span class="strong">FAPPLY_node</span>
<DD>
<pre>
⊢ ∀cmp x l a b r.
      FMAPAL cmp (node l (a,b) r) ' x =
      case apto cmp x a of
        Less => FMAPAL cmp l ' x
      | Equal => b
      | Greater => FMAPAL cmp r ' x
</pre>

<DT><span class="strong">bt_FST_FDOM</span>
<DD>
<pre>
⊢ ∀cmp t. FDOM (FMAPAL cmp t) = ENUMERAL cmp (bt_map FST t)
</pre>

<DT><span class="strong">bt_to_orl_lb_ub_ind</span>
<DD>
<pre>
⊢ ∀P.
      (∀cmp lb ub. P cmp lb nt ub) ∧
      (∀cmp lb l x y r ub.
           (apto cmp lb x ≠ Less ⇒ P cmp lb r ub) ∧
           (apto cmp lb x = Less ∧ apto cmp x ub ≠ Less ⇒ P cmp lb l ub) ∧
           (apto cmp lb x = Less ∧ apto cmp x ub = Less ⇒ P cmp lb l x) ∧
           (apto cmp lb x = Less ∧ apto cmp x ub = Less ⇒ P cmp x r ub) ⇒
           P cmp lb (node l (x,y) r) ub) ⇒
      ∀v v1 v2 v3. P v v1 v2 v3
</pre>

<DT><span class="strong">bt_to_orl_lb_ub</span>
<DD>
<pre>
⊢ (∀ub lb cmp. bt_to_orl_lb_ub cmp lb nt ub = []) ∧
  ∀y x ub r lb l cmp.
      bt_to_orl_lb_ub cmp lb (node l (x,y) r) ub =
      if apto cmp lb x = Less then
        if apto cmp x ub = Less then
          bt_to_orl_lb_ub cmp lb l x ++ [(x,y)] ++ bt_to_orl_lb_ub cmp x r ub
        else bt_to_orl_lb_ub cmp lb l ub else bt_to_orl_lb_ub cmp lb r ub
</pre>

<DT><span class="strong">bt_to_orl_lb_ind</span>
<DD>
<pre>
⊢ ∀P.
      (∀cmp lb. P cmp lb nt) ∧
      (∀cmp lb l x y r.
           (apto cmp lb x ≠ Less ⇒ P cmp lb r) ∧
           (apto cmp lb x = Less ⇒ P cmp x r) ⇒
           P cmp lb (node l (x,y) r)) ⇒
      ∀v v1 v2. P v v1 v2
</pre>

<DT><span class="strong">bt_to_orl_lb</span>
<DD>
<pre>
⊢ (∀lb cmp. bt_to_orl_lb cmp lb nt = []) ∧
  ∀y x r lb l cmp.
      bt_to_orl_lb cmp lb (node l (x,y) r) =
      if apto cmp lb x = Less then
        bt_to_orl_lb_ub cmp lb l x ++ [(x,y)] ++ bt_to_orl_lb cmp x r
      else bt_to_orl_lb cmp lb r
</pre>

<DT><span class="strong">bt_to_orl_ub_ind</span>
<DD>
<pre>
⊢ ∀P.
      (∀cmp ub. P cmp nt ub) ∧
      (∀cmp l x y r ub.
           (apto cmp x ub ≠ Less ⇒ P cmp l ub) ∧
           (apto cmp x ub = Less ⇒ P cmp l x) ⇒
           P cmp (node l (x,y) r) ub) ⇒
      ∀v v1 v2. P v v1 v2
</pre>

<DT><span class="strong">bt_to_orl_ub</span>
<DD>
<pre>
⊢ (∀ub cmp. bt_to_orl_ub cmp nt ub = []) ∧
  ∀y x ub r l cmp.
      bt_to_orl_ub cmp (node l (x,y) r) ub =
      if apto cmp x ub = Less then
        bt_to_orl_ub cmp l x ++ [(x,y)] ++ bt_to_orl_lb_ub cmp x r ub
      else bt_to_orl_ub cmp l ub
</pre>

<DT><span class="strong">bt_to_orl_ind</span>
<DD>
<pre>
⊢ ∀P.
      (∀cmp. P cmp nt) ∧ (∀cmp l x y r. P cmp (node l (x,y) r)) ⇒
      ∀v v1. P v v1
</pre>

<DT><span class="strong">bt_to_orl</span>
<DD>
<pre>
⊢ bt_to_orl cmp nt = [] ∧
  bt_to_orl cmp (node l (x,y) r) =
  bt_to_orl_ub cmp l x ++ [(x,y)] ++ bt_to_orl_lb cmp x r
</pre>

<DT><span class="strong">bt_to_orl_lb_ub_ac_ind</span>
<DD>
<pre>
⊢ ∀P.
      (∀cmp lb ub m. P cmp lb nt ub m) ∧
      (∀cmp lb l x y r ub m.
           (apto cmp lb x ≠ Less ⇒ P cmp lb r ub m) ∧
           (apto cmp lb x = Less ∧ apto cmp x ub ≠ Less ⇒ P cmp lb l ub m) ∧
           (apto cmp lb x = Less ∧ apto cmp x ub = Less ⇒
            P cmp lb l x ((x,y)::bt_to_orl_lb_ub_ac cmp x r ub m)) ∧
           (apto cmp lb x = Less ∧ apto cmp x ub = Less ⇒ P cmp x r ub m) ⇒
           P cmp lb (node l (x,y) r) ub m) ⇒
      ∀v v1 v2 v3 v4. P v v1 v2 v3 v4
</pre>

<DT><span class="strong">bt_to_orl_lb_ub_ac</span>
<DD>
<pre>
⊢ (∀ub m lb cmp. bt_to_orl_lb_ub_ac cmp lb nt ub m = m) ∧
  ∀y x ub r m lb l cmp.
      bt_to_orl_lb_ub_ac cmp lb (node l (x,y) r) ub m =
      if apto cmp lb x = Less then
        if apto cmp x ub = Less then
          bt_to_orl_lb_ub_ac cmp lb l x
            ((x,y)::bt_to_orl_lb_ub_ac cmp x r ub m)
        else bt_to_orl_lb_ub_ac cmp lb l ub m
      else bt_to_orl_lb_ub_ac cmp lb r ub m
</pre>

<DT><span class="strong">bt_to_orl_lb_ac_ind</span>
<DD>
<pre>
⊢ ∀P.
      (∀cmp lb m. P cmp lb nt m) ∧
      (∀cmp lb l x y r m.
           (apto cmp lb x ≠ Less ⇒ P cmp lb r m) ∧
           (apto cmp lb x = Less ⇒ P cmp x r m) ⇒
           P cmp lb (node l (x,y) r) m) ⇒
      ∀v v1 v2 v3. P v v1 v2 v3
</pre>

<DT><span class="strong">bt_to_orl_lb_ac</span>
<DD>
<pre>
⊢ (∀m lb cmp. bt_to_orl_lb_ac cmp lb nt m = m) ∧
  ∀y x r m lb l cmp.
      bt_to_orl_lb_ac cmp lb (node l (x,y) r) m =
      if apto cmp lb x = Less then
        bt_to_orl_lb_ub_ac cmp lb l x ((x,y)::bt_to_orl_lb_ac cmp x r m)
      else bt_to_orl_lb_ac cmp lb r m
</pre>

<DT><span class="strong">bt_to_orl_ub_ac_ind</span>
<DD>
<pre>
⊢ ∀P.
      (∀cmp ub m. P cmp nt ub m) ∧
      (∀cmp l x y r ub m.
           (apto cmp x ub ≠ Less ⇒ P cmp l ub m) ∧
           (apto cmp x ub = Less ⇒
            P cmp l x ((x,y)::bt_to_orl_lb_ub_ac cmp x r ub m)) ⇒
           P cmp (node l (x,y) r) ub m) ⇒
      ∀v v1 v2 v3. P v v1 v2 v3
</pre>

<DT><span class="strong">bt_to_orl_ub_ac</span>
<DD>
<pre>
⊢ (∀ub m cmp. bt_to_orl_ub_ac cmp nt ub m = m) ∧
  ∀y x ub r m l cmp.
      bt_to_orl_ub_ac cmp (node l (x,y) r) ub m =
      if apto cmp x ub = Less then
        bt_to_orl_ub_ac cmp l x ((x,y)::bt_to_orl_lb_ub_ac cmp x r ub m)
      else bt_to_orl_ub_ac cmp l ub m
</pre>

<DT><span class="strong">bt_to_orl_ac_ind</span>
<DD>
<pre>
⊢ ∀P.
      (∀cmp m. P cmp nt m) ∧ (∀cmp l x y r m. P cmp (node l (x,y) r) m) ⇒
      ∀v v1 v2. P v v1 v2
</pre>

<DT><span class="strong">bt_to_orl_ac</span>
<DD>
<pre>
⊢ bt_to_orl_ac cmp nt m = m ∧
  bt_to_orl_ac cmp (node l (x,y) r) m =
  bt_to_orl_ub_ac cmp l x ((x,y)::bt_to_orl_lb_ac cmp x r m)
</pre>

<DT><span class="strong">ORWL_bt_to_orl</span>
<DD>
<pre>
⊢ ∀cmp t. ORWL cmp (FMAPAL cmp t) (bt_to_orl cmp t)
</pre>

<DT><span class="strong">bl_to_fmap_ind</span>
<DD>
<pre>
⊢ ∀P.
      (∀cmp. P cmp nbl) ∧ (∀cmp b. P cmp b ⇒ P cmp (zerbl b)) ∧
      (∀cmp x y t b. P cmp b ⇒ P cmp (onebl (x,y) t b)) ⇒
      ∀v v1. P v v1
</pre>

<DT><span class="strong">bl_to_fmap</span>
<DD>
<pre>
⊢ (∀cmp. bl_to_fmap cmp nbl = FEMPTY) ∧
  (∀cmp b. bl_to_fmap cmp (zerbl b) = bl_to_fmap cmp b) ∧
  ∀y x t cmp b.
      bl_to_fmap cmp (onebl (x,y) t b) =
      OFU cmp
        (FEMPTY |+ (x,y) FUNION
         DRESTRICT (FMAPAL cmp t) {z | apto cmp x z = Less})
        (bl_to_fmap cmp b)
</pre>

<DT><span class="strong">bt_to_orl_ID_IMP</span>
<DD>
<pre>
⊢ ∀cmp l. ORL cmp l ⇒ bt_to_orl cmp (list_to_bt l) = l
</pre>

<DT><span class="strong">fmap_FDOM</span>
<DD>
<pre>
⊢ ∀l. FDOM (fmap l) = LIST_TO_SET (MAP FST l)
</pre>

<DT><span class="strong">ORL_FUNION_IMP</span>
<DD>
<pre>
⊢ ∀cmp l.
      ORL cmp l ⇒
      ∀m.
          ORL cmp m ⇒
          ORL cmp (merge cmp l m) ∧
          fmap (merge cmp l m) = fmap l FUNION fmap m
</pre>

<DT><span class="strong">FMAPAL_FDOM_THM</span>
<DD>
<pre>
⊢ (∀cmp x. x ∈ FDOM (FMAPAL cmp nt) ⇔ F) ∧
  ∀cmp x a b l r.
      x ∈ FDOM (FMAPAL cmp (node l (a,b) r)) ⇔
      case apto cmp x a of
        Less => x ∈ FDOM (FMAPAL cmp l)
      | Equal => T
      | Greater => x ∈ FDOM (FMAPAL cmp r)
</pre>

<DT><span class="strong">inter_merge_ind</span>
<DD>
<pre>
⊢ ∀P.
      (∀cmp. P cmp [] []) ∧ (∀cmp a b l. P cmp ((a,b)::l) []) ∧
      (∀cmp y m. P cmp [] (y::m)) ∧
      (∀cmp a b l y m.
           (apto cmp a y = Equal ⇒ P cmp l m) ∧
           (apto cmp a y = Greater ⇒ P cmp ((a,b)::l) m) ∧
           (apto cmp a y = Less ⇒ P cmp l (y::m)) ⇒
           P cmp ((a,b)::l) (y::m)) ⇒
      ∀v v1 v2. P v v1 v2
</pre>

<DT><span class="strong">inter_merge</span>
<DD>
<pre>
⊢ (∀cmp. inter_merge cmp [] [] = []) ∧
  (∀l cmp b a. inter_merge cmp ((a,b)::l) [] = []) ∧
  (∀y m cmp. inter_merge cmp [] (y::m) = []) ∧
  ∀y m l cmp b a.
      inter_merge cmp ((a,b)::l) (y::m) =
      case apto cmp a y of
        Less => inter_merge cmp l (y::m)
      | Equal => (a,b)::inter_merge cmp l m
      | Greater => inter_merge cmp ((a,b)::l) m
</pre>

<DT><span class="strong">ORL_DRESTRICT_IMP</span>
<DD>
<pre>
⊢ ∀cmp l.
      ORL cmp l ⇒
      ∀m.
          OL cmp m ⇒
          ORL cmp (inter_merge cmp l m) ∧
          fmap (inter_merge cmp l m) = DRESTRICT (fmap l) (LIST_TO_SET m)
</pre>

<DT><span class="strong">diff_merge_ind</span>
<DD>
<pre>
⊢ ∀P.
      (∀cmp. P cmp [] []) ∧ (∀cmp a b l. P cmp ((a,b)::l) []) ∧
      (∀cmp y m. P cmp [] (y::m)) ∧
      (∀cmp a b l y m.
           (apto cmp a y = Equal ⇒ P cmp l m) ∧
           (apto cmp a y = Greater ⇒ P cmp ((a,b)::l) m) ∧
           (apto cmp a y = Less ⇒ P cmp l (y::m)) ⇒
           P cmp ((a,b)::l) (y::m)) ⇒
      ∀v v1 v2. P v v1 v2
</pre>

<DT><span class="strong">diff_merge</span>
<DD>
<pre>
⊢ (∀cmp. diff_merge cmp [] [] = []) ∧
  (∀l cmp b a. diff_merge cmp ((a,b)::l) [] = (a,b)::l) ∧
  (∀y m cmp. diff_merge cmp [] (y::m) = []) ∧
  ∀y m l cmp b a.
      diff_merge cmp ((a,b)::l) (y::m) =
      case apto cmp a y of
        Less => (a,b)::diff_merge cmp l (y::m)
      | Equal => diff_merge cmp l m
      | Greater => diff_merge cmp ((a,b)::l) m
</pre>

<DT><span class="strong">ORL_DRESTRICT_COMPL_IMP</span>
<DD>
<pre>
⊢ ∀cmp l.
      ORL cmp l ⇒
      ∀m.
          OL cmp m ⇒
          ORL cmp (diff_merge cmp l m) ∧
          fmap (diff_merge cmp l m) =
          DRESTRICT (fmap l) (COMPL (LIST_TO_SET m))
</pre>

<DT><span class="strong">FMAPAL_fmap</span>
<DD>
<pre>
⊢ ∀cmp l. fmap l = FMAPAL cmp (list_to_bt (incr_sort cmp l))
</pre>

<DT><span class="strong">ORL_FMAPAL</span>
<DD>
<pre>
⊢ ∀cmp l. ORL cmp l ⇒ fmap l = FMAPAL cmp (list_to_bt l)
</pre>

<DT><span class="strong">ORWL_FUNION_THM</span>
<DD>
<pre>
⊢ ∀cmp s l t m.
      ORWL cmp s l ∧ ORWL cmp t m ⇒ ORWL cmp (s FUNION t) (merge cmp l m)
</pre>

<DT><span class="strong">ORWL_DRESTRICT_THM</span>
<DD>
<pre>
⊢ ∀cmp s l t m.
      ORWL cmp s l ∧ OWL cmp t m ⇒
      ORWL cmp (DRESTRICT s t) (inter_merge cmp l m)
</pre>

<DT><span class="strong">ORWL_DRESTRICT_COMPL_THM</span>
<DD>
<pre>
⊢ ∀cmp s l t m.
      ORWL cmp s l ∧ OWL cmp t m ⇒
      ORWL cmp (DRESTRICT s (COMPL t)) (diff_merge cmp l m)
</pre>

<DT><span class="strong">o_f_bt_map</span>
<DD>
<pre>
⊢ ∀cmp f t. f o_f FMAPAL cmp t = FMAPAL cmp (bt_map (AP_SND f) t)
</pre>

<DT><span class="strong">FAPPLY_fmap_NIL</span>
<DD>
<pre>
⊢ ∀x. fmap [] ' x = FEMPTY ' x
</pre>

<DT><span class="strong">FAPPLY_fmap_CONS</span>
<DD>
<pre>
⊢ ∀x y z l. fmap ((y,z)::l) ' x = if x = y then z else fmap l ' x
</pre>

<DT><span class="strong">o_f_fmap</span>
<DD>
<pre>
⊢ ∀f l. f o_f fmap l = fmap (MAP (AP_SND f) l)
</pre>

<DT><span class="strong">ORL_bt_lb_ub_ind</span>
<DD>
<pre>
⊢ ∀P.
      (∀cmp lb ub. P cmp lb nt ub) ∧
      (∀cmp lb l x y r ub.
           P cmp lb l x ∧ P cmp x r ub ⇒ P cmp lb (node l (x,y) r) ub) ⇒
      ∀v v1 v2 v3. P v v1 v2 v3
</pre>

<DT><span class="strong">ORL_bt_lb_ub</span>
<DD>
<pre>
⊢ (∀ub lb cmp. ORL_bt_lb_ub cmp lb nt ub ⇔ apto cmp lb ub = Less) ∧
  ∀y x ub r lb l cmp.
      ORL_bt_lb_ub cmp lb (node l (x,y) r) ub ⇔
      ORL_bt_lb_ub cmp lb l x ∧ ORL_bt_lb_ub cmp x r ub
</pre>

<DT><span class="strong">ORL_bt_lb_ind</span>
<DD>
<pre>
⊢ ∀P.
      (∀cmp lb. P cmp lb nt) ∧
      (∀cmp lb l x y r. P cmp x r ⇒ P cmp lb (node l (x,y) r)) ⇒
      ∀v v1 v2. P v v1 v2
</pre>

<DT><span class="strong">ORL_bt_lb</span>
<DD>
<pre>
⊢ (∀lb cmp. ORL_bt_lb cmp lb nt ⇔ T) ∧
  ∀y x r lb l cmp.
      ORL_bt_lb cmp lb (node l (x,y) r) ⇔
      ORL_bt_lb_ub cmp lb l x ∧ ORL_bt_lb cmp x r
</pre>

<DT><span class="strong">ORL_bt_ub_ind</span>
<DD>
<pre>
⊢ ∀P.
      (∀cmp ub. P cmp nt ub) ∧
      (∀cmp l x y r ub. P cmp l x ⇒ P cmp (node l (x,y) r) ub) ⇒
      ∀v v1 v2. P v v1 v2
</pre>

<DT><span class="strong">ORL_bt_ub</span>
<DD>
<pre>
⊢ (∀ub cmp. ORL_bt_ub cmp nt ub ⇔ T) ∧
  ∀y x ub r l cmp.
      ORL_bt_ub cmp (node l (x,y) r) ub ⇔
      ORL_bt_ub cmp l x ∧ ORL_bt_lb_ub cmp x r ub
</pre>

<DT><span class="strong">ORL_bt_ind</span>
<DD>
<pre>
⊢ ∀P.
      (∀cmp. P cmp nt) ∧ (∀cmp l x y r. P cmp (node l (x,y) r)) ⇒
      ∀v v1. P v v1
</pre>

<DT><span class="strong">ORL_bt</span>
<DD>
<pre>
⊢ (ORL_bt cmp nt ⇔ T) ∧
  (ORL_bt cmp (node l (x,y) r) ⇔ ORL_bt_ub cmp l x ∧ ORL_bt_lb cmp x r)
</pre>

<DT><span class="strong">better_bt_to_orl</span>
<DD>
<pre>
⊢ ∀cmp t.
      bt_to_orl cmp t = if ORL_bt cmp t then bt_to_list_ac t []
      else bt_to_orl_ac cmp t []
</pre>

<DT><span class="strong">list_rplacv_cn_ind</span>
<DD>
<pre>
⊢ ∀P.
      (∀x y cn. P (x,y) [] cn) ∧
      (∀x y w z l cn.
           (x ≠ w ⇒ P (x,y) l (λm. cn ((w,z)::m))) ⇒ P (x,y) ((w,z)::l) cn) ⇒
      ∀v v1 v2 v3. P (v,v1) v2 v3
</pre>

<DT><span class="strong">list_rplacv_cn</span>
<DD>
<pre>
⊢ (∀y x cn. list_rplacv_cn (x,y) [] cn = []) ∧
  ∀z y x w l cn.
      list_rplacv_cn (x,y) ((w,z)::l) cn = if x = w then cn ((x,y)::l)
      else list_rplacv_cn (x,y) l (λm. cn ((w,z)::m))
</pre>

<DT><span class="strong">fmap_FDOM_rec</span>
<DD>
<pre>
⊢ (∀x. x ∈ FDOM (fmap []) ⇔ F) ∧
  ∀x w z l. x ∈ FDOM (fmap ((w,z)::l)) ⇔ x = w ∨ x ∈ FDOM (fmap l)
</pre>

<DT><span class="strong">list_rplacv_thm</span>
<DD>
<pre>
⊢ ∀x y l.
      (let
         ans = list_rplacv_cn (x,y) l (λm. m)
       in
         if ans = [] then x ∉ FDOM (fmap l)
         else x ∈ FDOM (fmap l) ∧ fmap l |+ (x,y) = fmap ans)
</pre>

<DT><span class="strong">bt_rplacv_cn_ind</span>
<DD>
<pre>
⊢ ∀P.
      (∀cmp x y cn. P cmp (x,y) nt cn) ∧
      (∀cmp x y l w z r cn.
           (apto cmp x w = Greater ⇒ P cmp (x,y) r (λm. cn (node l (w,z) m))) ∧
           (apto cmp x w = Less ⇒ P cmp (x,y) l (λm. cn (node m (w,z) r))) ⇒
           P cmp (x,y) (node l (w,z) r) cn) ⇒
      ∀v v1 v2 v3 v4. P v (v1,v2) v3 v4
</pre>

<DT><span class="strong">bt_rplacv_cn</span>
<DD>
<pre>
⊢ (∀y x cn cmp. bt_rplacv_cn cmp (x,y) nt cn = nt) ∧
  ∀z y x w r l cn cmp.
      bt_rplacv_cn cmp (x,y) (node l (w,z) r) cn =
      case apto cmp x w of
        Less => bt_rplacv_cn cmp (x,y) l (λm. cn (node m (w,z) r))
      | Equal => cn (node l (x,y) r)
      | Greater => bt_rplacv_cn cmp (x,y) r (λm. cn (node l (w,z) m))
</pre>

<DT><span class="strong">bt_rplacv_thm</span>
<DD>
<pre>
⊢ ∀cmp x y t.
      (let
         ans = bt_rplacv_cn cmp (x,y) t (λm. m)
       in
         if ans = nt then x ∉ FDOM (FMAPAL cmp t)
         else x ∈ FDOM (FMAPAL cmp t) ∧ FMAPAL cmp t |+ (x,y) = FMAPAL cmp ans)
</pre>

<DT><span class="strong">FUN_fmap_thm</span>
<DD>
<pre>
⊢ ∀f l. fmap (MAP (λx. (x,f x)) l) = FUN_FMAP f (LIST_TO_SET l)
</pre>

<DT><span class="strong">fmap_ORWL_thm</span>
<DD>
<pre>
⊢ ∀cmp l. ORWL cmp (fmap l) (incr_sort cmp l)
</pre>

</DL>



<hr>
</body>
</html>
