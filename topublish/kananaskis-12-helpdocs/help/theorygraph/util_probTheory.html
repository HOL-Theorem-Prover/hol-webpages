<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: util_prob</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "util_prob"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "real_sigmaTheory.html"><span class="strong">real_sigma</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">lg</span>
    <td>
    :real -> real
    <tr><td> <span class="strong">logr</span> <td> :real -> real -> real
    <tr><td> <span class="strong">minimal</span> <td> :(num -> bool) -> num
    <tr><td>
    <span class="strong">pair</span>
    <td>
    :(Î± -> bool) -> (Î² -> bool) -> Î± # Î² -> bool
    <tr><td> <span class="strong">powr</span> <td> :real -> real -> real
    <tr><td>
    <span class="strong">prod_sets</span>
    <td>
    :((Î± -> bool) -> bool) -> ((Î² -> bool) -> bool) -> (Î± # Î² -> bool) -> bool
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">pair_def</span>
<DD>
<pre>
âŠ¢ âˆ€X Y. pair X Y = (Î»(x,y). x âˆˆ X âˆ§ y âˆˆ Y)
</pre>

<DT><span class="strong">powr_def</span>
<DD>
<pre>
âŠ¢ âˆ€x a. x powr a = exp (a * ln x)
</pre>

<DT><span class="strong">logr_def</span>
<DD>
<pre>
âŠ¢ âˆ€a x. logr a x = ln x / ln a
</pre>

<DT><span class="strong">lg_def</span>
<DD>
<pre>
âŠ¢ âˆ€x. lg x = logr 2 x
</pre>

<DT><span class="strong">prod_sets_def</span>
<DD>
<pre>
âŠ¢ âˆ€a b. prod_sets a b = {s Ã— t | s âˆˆ a âˆ§ t âˆˆ b}
</pre>

<DT><span class="strong">minimal_def</span>
<DD>
<pre>
âŠ¢ âˆ€p. minimal p = @n. p n âˆ§ âˆ€m. m < n â‡’ Â¬p m
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">EQ_T_IMP</span>
<DD>
<pre>
âŠ¢ âˆ€x. x â‡” T â‡’ x
</pre>

<DT><span class="strong">IN_PAIR</span>
<DD>
<pre>
âŠ¢ âˆ€x X Y. x âˆˆ pair X Y â‡” FST x âˆˆ X âˆ§ SND x âˆˆ Y
</pre>

<DT><span class="strong">PAIR_UNIV</span>
<DD>
<pre>
âŠ¢ pair ğ•Œ(:Î±) ğ•Œ(:Î²) = ğ•Œ(:Î± # Î²)
</pre>

<DT><span class="strong">PAIRED_BETA_THM</span>
<DD>
<pre>
âŠ¢ âˆ€f z. UNCURRY f z = f (FST z) (SND z)
</pre>

<DT><span class="strong">MAX_LE_X</span>
<DD>
<pre>
âŠ¢ âˆ€m n k. MAX m n â‰¤ k â‡” m â‰¤ k âˆ§ n â‰¤ k
</pre>

<DT><span class="strong">X_LE_MAX</span>
<DD>
<pre>
âŠ¢ âˆ€m n k. k â‰¤ MAX m n â‡” k â‰¤ m âˆ¨ k â‰¤ n
</pre>

<DT><span class="strong">TRANSFORM_2D_NUM</span>
<DD>
<pre>
âŠ¢ âˆ€P. (âˆ€m n. P m n â‡’ P n m) âˆ§ (âˆ€m n. P m (m + n)) â‡’ âˆ€m n. P m n
</pre>

<DT><span class="strong">TRIANGLE_2D_NUM</span>
<DD>
<pre>
âŠ¢ âˆ€P. (âˆ€d n. P n (d + n)) â‡’ âˆ€m n. m â‰¤ n â‡’ P m n
</pre>

<DT><span class="strong">lg_1</span>
<DD>
<pre>
âŠ¢ lg 1 = 0
</pre>

<DT><span class="strong">logr_1</span>
<DD>
<pre>
âŠ¢ âˆ€b. logr b 1 = 0
</pre>

<DT><span class="strong">lg_nonzero</span>
<DD>
<pre>
âŠ¢ âˆ€x. x â‰  0 âˆ§ 0 â‰¤ x â‡’ (lg x â‰  0 â‡” x â‰  1)
</pre>

<DT><span class="strong">lg_mul</span>
<DD>
<pre>
âŠ¢ âˆ€x y. 0 < x âˆ§ 0 < y â‡’ lg (x * y) = lg x + lg y
</pre>

<DT><span class="strong">logr_mul</span>
<DD>
<pre>
âŠ¢ âˆ€b x y. 0 < x âˆ§ 0 < y â‡’ logr b (x * y) = logr b x + logr b y
</pre>

<DT><span class="strong">lg_2</span>
<DD>
<pre>
âŠ¢ lg 2 = 1
</pre>

<DT><span class="strong">lg_inv</span>
<DD>
<pre>
âŠ¢ âˆ€x. 0 < x â‡’ lg xâ»Â¹ = -lg x
</pre>

<DT><span class="strong">logr_inv</span>
<DD>
<pre>
âŠ¢ âˆ€b x. 0 < x â‡’ logr b xâ»Â¹ = -logr b x
</pre>

<DT><span class="strong">logr_div</span>
<DD>
<pre>
âŠ¢ âˆ€b x y. 0 < x âˆ§ 0 < y â‡’ logr b (x / y) = logr b x âˆ’ logr b y
</pre>

<DT><span class="strong">neg_lg</span>
<DD>
<pre>
âŠ¢ âˆ€x. 0 < x â‡’ -lg x = lg xâ»Â¹
</pre>

<DT><span class="strong">neg_logr</span>
<DD>
<pre>
âŠ¢ âˆ€b x. 0 < x â‡’ -logr b x = logr b xâ»Â¹
</pre>

<DT><span class="strong">lg_pow</span>
<DD>
<pre>
âŠ¢ âˆ€n. lg (2 pow n) = &n
</pre>

<DT><span class="strong">NUM_2D_BIJ</span>
<DD>
<pre>
âŠ¢ âˆƒf. BIJ f (ğ•Œ(:num) Ã— ğ•Œ(:num)) ğ•Œ(:num)
</pre>

<DT><span class="strong">NUM_2D_BIJ_INV</span>
<DD>
<pre>
âŠ¢ âˆƒf. BIJ f ğ•Œ(:num) (ğ•Œ(:num) Ã— ğ•Œ(:num))
</pre>

<DT><span class="strong">NUM_2D_BIJ_NZ</span>
<DD>
<pre>
âŠ¢ âˆƒf. BIJ f (ğ•Œ(:num) Ã— (ğ•Œ(:num) DIFF {0})) ğ•Œ(:num)
</pre>

<DT><span class="strong">NUM_2D_BIJ_NZ_INV</span>
<DD>
<pre>
âŠ¢ âˆƒf. BIJ f ğ•Œ(:num) (ğ•Œ(:num) Ã— (ğ•Œ(:num) DIFF {0}))
</pre>

<DT><span class="strong">NUM_2D_BIJ_NZ_ALT</span>
<DD>
<pre>
âŠ¢ âˆƒf. BIJ f (ğ•Œ(:num) Ã— ğ•Œ(:num)) (ğ•Œ(:num) DIFF {0})
</pre>

<DT><span class="strong">NUM_2D_BIJ_NZ_ALT_INV</span>
<DD>
<pre>
âŠ¢ âˆƒf. BIJ f (ğ•Œ(:num) DIFF {0}) (ğ•Œ(:num) Ã— ğ•Œ(:num))
</pre>

<DT><span class="strong">NUM_2D_BIJ_NZ_ALT2</span>
<DD>
<pre>
âŠ¢ âˆƒf. BIJ f ((ğ•Œ(:num) DIFF {0}) Ã— (ğ•Œ(:num) DIFF {0})) ğ•Œ(:num)
</pre>

<DT><span class="strong">NUM_2D_BIJ_NZ_ALT2_INV</span>
<DD>
<pre>
âŠ¢ âˆƒf. BIJ f ğ•Œ(:num) ((ğ•Œ(:num) DIFF {0}) Ã— (ğ•Œ(:num) DIFF {0}))
</pre>

<DT><span class="strong">K_PARTIAL</span>
<DD>
<pre>
âŠ¢ âˆ€x. K x = (Î»z. x)
</pre>

<DT><span class="strong">IN_o</span>
<DD>
<pre>
âŠ¢ âˆ€x f s. x âˆˆ s âˆ˜ f â‡” f x âˆˆ s
</pre>

<DT><span class="strong">IN_PROD_SETS</span>
<DD>
<pre>
âŠ¢ âˆ€s a b. s âˆˆ prod_sets a b â‡” âˆƒt u. s = t Ã— u âˆ§ t âˆˆ a âˆ§ u âˆˆ b
</pre>

<DT><span class="strong">NUM_2D_BIJ_SMALL_SQUARE</span>
<DD>
<pre>
âŠ¢ âˆ€f k.
      BIJ f ğ•Œ(:num) (ğ•Œ(:num) Ã— ğ•Œ(:num)) â‡’
      âˆƒN. count k Ã— count k âŠ† IMAGE f (count N)
</pre>

<DT><span class="strong">NUM_2D_BIJ_BIG_SQUARE</span>
<DD>
<pre>
âŠ¢ âˆ€f N.
      BIJ f ğ•Œ(:num) (ğ•Œ(:num) Ã— ğ•Œ(:num)) â‡’
      âˆƒk. IMAGE f (count N) âŠ† count k Ã— count k
</pre>

<DT><span class="strong">finite_enumeration_of_sets_has_max_non_empty</span>
<DD>
<pre>
âŠ¢ âˆ€f s.
      FINITE s âˆ§ (âˆ€x. f x âˆˆ s) âˆ§ (âˆ€m n. m â‰  n â‡’ DISJOINT (f m) (f n)) â‡’
      âˆƒN. âˆ€n. n â‰¥ N â‡’ f n = âˆ…
</pre>

<DT><span class="strong">PREIMAGE_REAL_COMPL1</span>
<DD>
<pre>
âŠ¢ âˆ€c. COMPL {x | c < x} = {x | x â‰¤ c}
</pre>

<DT><span class="strong">PREIMAGE_REAL_COMPL2</span>
<DD>
<pre>
âŠ¢ âˆ€c. COMPL {x | c â‰¤ x} = {x | x < c}
</pre>

<DT><span class="strong">PREIMAGE_REAL_COMPL3</span>
<DD>
<pre>
âŠ¢ âˆ€c. COMPL {x | x â‰¤ c} = {x | c < x}
</pre>

<DT><span class="strong">PREIMAGE_REAL_COMPL4</span>
<DD>
<pre>
âŠ¢ âˆ€c. COMPL {x | x < c} = {x | c â‰¤ x}
</pre>

<DT><span class="strong">GBIGUNION_IMAGE</span>
<DD>
<pre>
âŠ¢ âˆ€s p n. {s | âˆƒn. p s n} = BIGUNION (IMAGE (Î»n. {s | p s n}) ğ•Œ(:Î³))
</pre>

<DT><span class="strong">LT_SUC</span>
<DD>
<pre>
âŠ¢ âˆ€a b. a < SUC b â‡” a < b âˆ¨ a = b
</pre>

<DT><span class="strong">LE_SUC</span>
<DD>
<pre>
âŠ¢ âˆ€a b. a â‰¤ SUC b â‡” a â‰¤ b âˆ¨ a = SUC b
</pre>

<DT><span class="strong">HALF_POS</span>
<DD>
<pre>
âŠ¢ 0 < 1 / 2
</pre>

<DT><span class="strong">HALF_LT_1</span>
<DD>
<pre>
âŠ¢ 1 / 2 < 1
</pre>

<DT><span class="strong">HALF_CANCEL</span>
<DD>
<pre>
âŠ¢ 2 * (1 / 2) = 1
</pre>

<DT><span class="strong">X_HALF_HALF</span>
<DD>
<pre>
âŠ¢ âˆ€x. 1 / 2 * x + 1 / 2 * x = x
</pre>

<DT><span class="strong">ONE_MINUS_HALF</span>
<DD>
<pre>
âŠ¢ 1 âˆ’ 1 / 2 = 1 / 2
</pre>

<DT><span class="strong">POW_HALF_POS</span>
<DD>
<pre>
âŠ¢ âˆ€n. 0 < (1 / 2) pow n
</pre>

<DT><span class="strong">POW_HALF_SMALL</span>
<DD>
<pre>
âŠ¢ âˆ€e. 0 < e â‡’ âˆƒn. (1 / 2) pow n < e
</pre>

<DT><span class="strong">POW_HALF_MONO</span>
<DD>
<pre>
âŠ¢ âˆ€m n. m â‰¤ n â‡’ (1 / 2) pow n â‰¤ (1 / 2) pow m
</pre>

<DT><span class="strong">REAL_LE_LT_MUL</span>
<DD>
<pre>
âŠ¢ âˆ€x y. 0 â‰¤ x âˆ§ 0 < y â‡’ 0 â‰¤ x * y
</pre>

<DT><span class="strong">REAL_LT_LE_MUL</span>
<DD>
<pre>
âŠ¢ âˆ€x y. 0 < x âˆ§ 0 â‰¤ y â‡’ 0 â‰¤ x * y
</pre>

<DT><span class="strong">REAL_MUL_IDEMPOT</span>
<DD>
<pre>
âŠ¢ âˆ€r. r * r = r â‡” r = 0 âˆ¨ r = 1
</pre>

<DT><span class="strong">REAL_SUP_LE_X</span>
<DD>
<pre>
âŠ¢ âˆ€P x. (âˆƒr. P r) âˆ§ (âˆ€r. P r â‡’ r â‰¤ x) â‡’ sup P â‰¤ x
</pre>

<DT><span class="strong">REAL_X_LE_SUP</span>
<DD>
<pre>
âŠ¢ âˆ€P x. (âˆƒr. P r) âˆ§ (âˆƒz. âˆ€r. P r â‡’ r â‰¤ z) âˆ§ (âˆƒr. P r âˆ§ x â‰¤ r) â‡’ x â‰¤ sup P
</pre>

<DT><span class="strong">INF_DEF_ALT</span>
<DD>
<pre>
âŠ¢ âˆ€p. inf p = -sup (Î»r. -r âˆˆ p)
</pre>

<DT><span class="strong">LE_INF</span>
<DD>
<pre>
âŠ¢ âˆ€p r. (âˆƒx. x âˆˆ p) âˆ§ (âˆ€x. x âˆˆ p â‡’ r â‰¤ x) â‡’ r â‰¤ inf p
</pre>

<DT><span class="strong">INF_LE</span>
<DD>
<pre>
âŠ¢ âˆ€p r. (âˆƒz. âˆ€x. x âˆˆ p â‡’ z â‰¤ x) âˆ§ (âˆƒx. x âˆˆ p âˆ§ x â‰¤ r) â‡’ inf p â‰¤ r
</pre>

<DT><span class="strong">INF_GREATER</span>
<DD>
<pre>
âŠ¢ âˆ€p z. (âˆƒx. x âˆˆ p) âˆ§ inf p < z â‡’ âˆƒx. x âˆˆ p âˆ§ x < z
</pre>

<DT><span class="strong">INF_CLOSE</span>
<DD>
<pre>
âŠ¢ âˆ€p e. (âˆƒx. x âˆˆ p) âˆ§ 0 < e â‡’ âˆƒx. x âˆˆ p âˆ§ x < inf p + e
</pre>

<DT><span class="strong">INCREASING_SEQ</span>
<DD>
<pre>
âŠ¢ âˆ€f l.
      (âˆ€n. f n â‰¤ f (SUC n)) âˆ§ (âˆ€n. f n â‰¤ l) âˆ§ (âˆ€e. 0 < e â‡’ âˆƒn. l < f n + e) â‡’
      f --> l
</pre>

<DT><span class="strong">SEQ_SANDWICH</span>
<DD>
<pre>
âŠ¢ âˆ€f g h l. f --> l âˆ§ h --> l âˆ§ (âˆ€n. f n â‰¤ g n âˆ§ g n â‰¤ h n) â‡’ g --> l
</pre>

<DT><span class="strong">SER_POS</span>
<DD>
<pre>
âŠ¢ âˆ€f. summable f âˆ§ (âˆ€n. 0 â‰¤ f n) â‡’ 0 â‰¤ suminf f
</pre>

<DT><span class="strong">SER_POS_MONO</span>
<DD>
<pre>
âŠ¢ âˆ€f. (âˆ€n. 0 â‰¤ f n) â‡’ mono (Î»n. sum (0,n) f)
</pre>

<DT><span class="strong">POS_SUMMABLE</span>
<DD>
<pre>
âŠ¢ âˆ€f. (âˆ€n. 0 â‰¤ f n) âˆ§ (âˆƒx. âˆ€n. sum (0,n) f â‰¤ x) â‡’ summable f
</pre>

<DT><span class="strong">SUMMABLE_LE</span>
<DD>
<pre>
âŠ¢ âˆ€f x. summable f âˆ§ (âˆ€n. sum (0,n) f â‰¤ x) â‡’ suminf f â‰¤ x
</pre>

<DT><span class="strong">SUMS_EQ</span>
<DD>
<pre>
âŠ¢ âˆ€f x. f sums x â‡” summable f âˆ§ suminf f = x
</pre>

<DT><span class="strong">SUMINF_POS</span>
<DD>
<pre>
âŠ¢ âˆ€f. (âˆ€n. 0 â‰¤ f n) âˆ§ summable f â‡’ 0 â‰¤ suminf f
</pre>

<DT><span class="strong">SUM_PICK</span>
<DD>
<pre>
âŠ¢ âˆ€n k x. sum (0,n) (Î»m. if m = k then x else 0) = if k < n then x else 0
</pre>

<DT><span class="strong">SUM_LT</span>
<DD>
<pre>
âŠ¢ âˆ€f g m n.
      (âˆ€r. m â‰¤ r âˆ§ r < n + m â‡’ f r < g r) âˆ§ 0 < n â‡’ sum (m,n) f < sum (m,n) g
</pre>

<DT><span class="strong">SUM_CONST_R</span>
<DD>
<pre>
âŠ¢ âˆ€n r. sum (0,n) (K r) = &n * r
</pre>

<DT><span class="strong">SUMS_ZERO</span>
<DD>
<pre>
âŠ¢ K 0 sums 0
</pre>

<DT><span class="strong">SUMINF_ADD</span>
<DD>
<pre>
âŠ¢ âˆ€f g.
      summable f âˆ§ summable g â‡’
      summable (Î»n. f n + g n) âˆ§ suminf f + suminf g = suminf (Î»n. f n + g n)
</pre>

<DT><span class="strong">SUMINF_2D</span>
<DD>
<pre>
âŠ¢ âˆ€f g h.
      (âˆ€m n. 0 â‰¤ f m n) âˆ§ (âˆ€n. f n sums g n) âˆ§ summable g âˆ§
      BIJ h ğ•Œ(:num) (ğ•Œ(:num) Ã— ğ•Œ(:num)) â‡’
      UNCURRY f âˆ˜ h sums suminf g
</pre>

<DT><span class="strong">POW_HALF_SER</span>
<DD>
<pre>
âŠ¢ (Î»n. (1 / 2) pow (n + 1)) sums 1
</pre>

<DT><span class="strong">SER_POS_COMPARE</span>
<DD>
<pre>
âŠ¢ âˆ€f g.
      (âˆ€n. 0 â‰¤ f n) âˆ§ summable g âˆ§ (âˆ€n. f n â‰¤ g n) â‡’
      summable f âˆ§ suminf f â‰¤ suminf g
</pre>

<DT><span class="strong">MINIMAL_EXISTS0</span>
<DD>
<pre>
âŠ¢ (âˆƒn. P n) â‡” âˆƒn. P n âˆ§ âˆ€m. m < n â‡’ Â¬P m
</pre>

<DT><span class="strong">MINIMAL_EXISTS</span>
<DD>
<pre>
âŠ¢ âˆ€P. (âˆƒn. P n) â‡” P (minimal P) âˆ§ âˆ€n. n < minimal P â‡’ Â¬P n
</pre>

<DT><span class="strong">MINIMAL_EXISTS_IMP</span>
<DD>
<pre>
âŠ¢ âˆ€P. (âˆƒn. P n) â‡’ âˆƒm. P m âˆ§ âˆ€n. n < m â‡’ Â¬P n
</pre>

<DT><span class="strong">MINIMAL_EQ_IMP</span>
<DD>
<pre>
âŠ¢ âˆ€m p. p m âˆ§ (âˆ€n. n < m â‡’ Â¬p n) â‡’ m = minimal p
</pre>

<DT><span class="strong">MINIMAL_SUC</span>
<DD>
<pre>
âŠ¢ âˆ€n p.
      SUC n = minimal p âˆ§ p (SUC n) â‡” Â¬p 0 âˆ§ n = minimal (p âˆ˜ SUC) âˆ§ p (SUC n)
</pre>

<DT><span class="strong">MINIMAL_EQ</span>
<DD>
<pre>
âŠ¢ âˆ€p m. p m âˆ§ m = minimal p â‡” p m âˆ§ âˆ€n. n < m â‡’ Â¬p n
</pre>

<DT><span class="strong">MINIMAL_SUC_IMP</span>
<DD>
<pre>
âŠ¢ âˆ€n p. p (SUC n) âˆ§ Â¬p 0 âˆ§ n = minimal (p âˆ˜ SUC) â‡’ SUC n = minimal p
</pre>

</DL>



<hr>
</body>
</html>
