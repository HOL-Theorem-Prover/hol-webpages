<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: path</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "path"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "llistTheory.html"><span class="strong">llist</span></a>&nbsp;&nbsp;
    <a href = "fixedPointTheory.html"><span class="strong">fixedPoint</span></a>

<h1>Signature</h1>
<center>
    <table BORDER=4 CELLPADDING=10 CELLSPACING=1>
    
    <tr> <th> Type <th> Arity<tr><td> <span class="strong">path</span> <td> 2
    <tr> <th> Constant <th> Type<tr><td>
    <span class="strong">PL</span>
    <td>
    :(Î±, Î²) path -> num -> bool
    <tr><td>
    <span class="strong">SN</span>
    <td>
    :(Î± -> Î² -> Î± -> bool) -> bool
    <tr><td>
    <span class="strong">drop</span>
    <td>
    :num -> (Î±, Î²) path -> (Î±, Î²) path
    <tr><td> <span class="strong">el</span> <td> :num -> (Î±, Î²) path -> Î±
    <tr><td>
    <span class="strong">every</span>
    <td>
    :(Î± -> bool) -> (Î±, Î²) path -> bool
    <tr><td>
    <span class="strong">exists</span>
    <td>
    :(Î± -> bool) -> (Î±, Î²) path -> bool
    <tr><td>
    <span class="strong">filter</span>
    <td>
    :(Î± -> bool) -> (Î±, Î²) path -> (Î±, Î²) path
    <tr><td> <span class="strong">finite</span> <td> :(Î±, Î²) path -> bool
    <tr><td> <span class="strong">first</span> <td> :(Î±, Î²) path -> Î±
    <tr><td>
    <span class="strong">firstP_at</span>
    <td>
    :(Î± -> bool) -> (Î±, Î²) path -> num -> bool
    <tr><td> <span class="strong">first_label</span> <td> :(Î±, Î²) path -> Î²
    <tr><td>
    <span class="strong">fromPath</span>
    <td>
    :(Î±, Î²) path -> Î± # (Î² # Î±) llist
    <tr><td> <span class="strong">is_stopped</span> <td> :(Î±, Î²) path -> bool
    <tr><td> <span class="strong">labels</span> <td> :(Î±, Î²) path -> Î² llist
    <tr><td> <span class="strong">last</span> <td> :(Î±, Î²) path -> Î±
    <tr><td>
    <span class="strong">length</span>
    <td>
    :(Î±, Î²) path -> num option
    <tr><td> <span class="strong">mem</span> <td> :Î± -> (Î±, Î²) path -> bool
    <tr><td>
    <span class="strong">nth_label</span>
    <td>
    :num -> (Î², Î±) path -> Î±
    <tr><td>
    <span class="strong">okpath</span>
    <td>
    :(Î± -> Î² -> Î± -> bool) -> (Î±, Î²) path -> bool
    <tr><td>
    <span class="strong">okpath_f</span>
    <td>
    :(Î± -> Î² -> Î± -> bool) -> ((Î±, Î²) path -> bool) -> (Î±, Î²) path -> bool
    <tr><td>
    <span class="strong">parallel_comp</span>
    <td>
    :(Î± -> Î² -> Î³ -> bool) ->
    (Î´ -> Î² -> Îµ -> bool) -> Î± # Î´ -> Î² -> Î³ # Îµ -> bool
    <tr><td>
    <span class="strong">pconcat</span>
    <td>
    :(Î±, Î²) path -> Î² -> (Î±, Î²) path -> (Î±, Î²) path
    <tr><td>
    <span class="strong">pcons</span>
    <td>
    :Î± -> Î² -> (Î±, Î²) path -> (Î±, Î²) path
    <tr><td>
    <span class="strong">pgenerate</span>
    <td>
    :(num -> Î±) -> (num -> Î²) -> (Î±, Î²) path
    <tr><td>
    <span class="strong">plink</span>
    <td>
    :(Î±, Î²) path -> (Î±, Î²) path -> (Î±, Î²) path
    <tr><td>
    <span class="strong">pmap</span>
    <td>
    :(Î± -> Î³) -> (Î² -> Î´) -> (Î±, Î²) path -> (Î³, Î´) path
    <tr><td>
    <span class="strong">seg</span>
    <td>
    :num -> num -> (Î±, Î²) path -> (Î±, Î²) path
    <tr><td> <span class="strong">stopped_at</span> <td> :Î± -> (Î±, Î²) path
    <tr><td> <span class="strong">tail</span> <td> :(Î±, Î²) path -> (Î±, Î²) path
    <tr><td>
    <span class="strong">take</span>
    <td>
    :num -> (Î±, Î²) path -> (Î±, Î²) path
    <tr><td>
    <span class="strong">toPath</span>
    <td>
    :Î± # (Î² # Î±) llist -> (Î±, Î²) path
    <tr><td>
    <span class="strong">trace_machine</span>
    <td>
    :(Î± list -> bool) -> Î± list -> Î± -> Î± list -> bool
    <tr><td>
    <span class="strong">unfold</span>
    <td>
    :(Î³ -> Î±) -> (Î³ -> (Î³ # Î²) option) -> Î³ -> (Î±, Î²) path
    
</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">path_TY_DEF</span>
<DD>
<pre>
âŠ¢ âˆƒrep. TYPE_DEFINITION (Î»x. T) rep
</pre>

<DT><span class="strong">path_absrep_bijections</span>
<DD>
<pre>
âŠ¢ (âˆ€a. toPath (fromPath a) = a) âˆ§ âˆ€r. (Î»x. T) r â‡” fromPath (toPath r) = r
</pre>

<DT><span class="strong">first_def</span>
<DD>
<pre>
âŠ¢ âˆ€p. first p = FST (fromPath p)
</pre>

<DT><span class="strong">stopped_at_def</span>
<DD>
<pre>
âŠ¢ âˆ€x. stopped_at x = toPath (x,[||])
</pre>

<DT><span class="strong">pcons_def</span>
<DD>
<pre>
âŠ¢ âˆ€x r p. pcons x r p = toPath (x,(r,first p):::SND (fromPath p))
</pre>

<DT><span class="strong">finite_def</span>
<DD>
<pre>
âŠ¢ âˆ€sigma. finite sigma â‡” LFINITE (SND (fromPath sigma))
</pre>

<DT><span class="strong">last_thm</span>
<DD>
<pre>
âŠ¢ (âˆ€x. last (stopped_at x) = x) âˆ§ âˆ€x r p. last (pcons x r p) = last p
</pre>

<DT><span class="strong">pmap_def</span>
<DD>
<pre>
âŠ¢ âˆ€f g p. pmap f g p = toPath ((f ## LMAP (g ## f)) (fromPath p))
</pre>

<DT><span class="strong">tail_def</span>
<DD>
<pre>
âŠ¢ âˆ€x r p. tail (pcons x r p) = p
</pre>

<DT><span class="strong">first_label_def</span>
<DD>
<pre>
âŠ¢ âˆ€x r p. first_label (pcons x r p) = r
</pre>

<DT><span class="strong">length_def</span>
<DD>
<pre>
âŠ¢ âˆ€p.
      length p =
      if finite p then SOME (LENGTH (THE (toList (SND (fromPath p)))) + 1)
      else NONE
</pre>

<DT><span class="strong">el_def</span>
<DD>
<pre>
âŠ¢ (âˆ€p. el 0 p = first p) âˆ§ âˆ€n p. el (SUC n) p = el n (tail p)
</pre>

<DT><span class="strong">nth_label_def</span>
<DD>
<pre>
âŠ¢ (âˆ€p. nth_label 0 p = first_label p) âˆ§
  âˆ€n p. nth_label (SUC n) p = nth_label n (tail p)
</pre>

<DT><span class="strong">pconcat_def</span>
<DD>
<pre>
âŠ¢ âˆ€p1 lab p2.
      pconcat p1 lab p2 =
      toPath
        (first p1,
         LAPPEND (SND (fromPath p1)) ((lab,first p2):::SND (fromPath p2)))
</pre>

<DT><span class="strong">PL_def</span>
<DD>
<pre>
âŠ¢ âˆ€p. PL p = {i | finite p â‡’ i < THE (length p)}
</pre>

<DT><span class="strong">firstP_at_def</span>
<DD>
<pre>
âŠ¢ âˆ€P p i. firstP_at P p i â‡” i âˆˆ PL p âˆ§ P (el i p) âˆ§ âˆ€j. j < i â‡’ Â¬P (el j p)
</pre>

<DT><span class="strong">exists_def</span>
<DD>
<pre>
âŠ¢ âˆ€P p. exists P p â‡” âˆƒi. firstP_at P p i
</pre>

<DT><span class="strong">every_def</span>
<DD>
<pre>
âŠ¢ âˆ€P p. every P p â‡” Â¬exists ($~ âˆ˜ P) p
</pre>

<DT><span class="strong">mem_def</span>
<DD>
<pre>
âŠ¢ âˆ€s p. mem s p â‡” âˆƒi. i âˆˆ PL p âˆ§ s = el i p
</pre>

<DT><span class="strong">drop_def</span>
<DD>
<pre>
âŠ¢ (âˆ€p. drop 0 p = p) âˆ§ âˆ€n p. drop (SUC n) p = drop n (tail p)
</pre>

<DT><span class="strong">take_def</span>
<DD>
<pre>
âŠ¢ (âˆ€p. take 0 p = stopped_at (first p)) âˆ§
  âˆ€n p. take (SUC n) p = pcons (first p) (first_label p) (take n (tail p))
</pre>

<DT><span class="strong">seg_def</span>
<DD>
<pre>
âŠ¢ âˆ€i j p. seg i j p = take (j âˆ’ i) (drop i p)
</pre>

<DT><span class="strong">labels_def</span>
<DD>
<pre>
âŠ¢ (âˆ€x. labels (stopped_at x) = [||]) âˆ§
  âˆ€x r p. labels (pcons x r p) = r:::labels p
</pre>

<DT><span class="strong">is_stopped_def</span>
<DD>
<pre>
âŠ¢ âˆ€p. is_stopped p â‡” âˆƒx. p = stopped_at x
</pre>

<DT><span class="strong">filter_def</span>
<DD>
<pre>
âŠ¢ âˆ€P.
      (âˆ€x. P x â‡’ filter P (stopped_at x) = stopped_at x) âˆ§
      âˆ€x r p.
          filter P (pcons x r p) =
          if P x then
            if exists P p then pcons x r (filter P p) else stopped_at x
          else filter P p
</pre>

<DT><span class="strong">pgenerate_def</span>
<DD>
<pre>
âŠ¢ âˆ€f g. pgenerate f g = pcons (f 0) (g 0) (pgenerate (f âˆ˜ SUC) (g âˆ˜ SUC))
</pre>

<DT><span class="strong">okpath_f_def</span>
<DD>
<pre>
âŠ¢ âˆ€R X.
      okpath_f R X =
      {stopped_at x | x âˆˆ ğ•Œ(:Î±)} âˆª {pcons x r p | R x r (first p) âˆ§ p âˆˆ X}
</pre>

<DT><span class="strong">okpath_def</span>
<DD>
<pre>
âŠ¢ âˆ€R. okpath R = gfp (okpath_f R)
</pre>

<DT><span class="strong">plink_def</span>
<DD>
<pre>
âŠ¢ (âˆ€x p. plink (stopped_at x) p = p) âˆ§
  âˆ€x r p1 p2. plink (pcons x r p1) p2 = pcons x r (plink p1 p2)
</pre>

<DT><span class="strong">SN_def</span>
<DD>
<pre>
âŠ¢ âˆ€R. SN R â‡” WF (Î»x y. âˆƒl. R y l x)
</pre>

<DT><span class="strong">unfold_def</span>
<DD>
<pre>
âŠ¢ âˆ€proj f s.
      unfold proj f s =
      toPath
        (proj s,
         LUNFOLD
           (Î»s. OPTION_MAP (Î»(next_s,lbl). (next_s,lbl,proj next_s)) (f s)) s)
</pre>

<DT><span class="strong">trace_machine_def</span>
<DD>
<pre>
âŠ¢ âˆ€P s l s'. trace_machine P s l s' â‡” P (s ++ [l]) âˆ§ s' = s ++ [l]
</pre>

<DT><span class="strong">parallel_comp_def</span>
<DD>
<pre>
âŠ¢ âˆ€m1 m2 s1 s2 l s1' s2'.
      parallel_comp m1 m2 (s1,s2) l (s1',s2') â‡” m1 s1 l s1' âˆ§ m2 s2 l s2'
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">path_rep_bijections_thm</span>
<DD>
<pre>
âŠ¢ (âˆ€a. toPath (fromPath a) = a) âˆ§ âˆ€r. fromPath (toPath r) = r
</pre>

<DT><span class="strong">toPath_11</span>
<DD>
<pre>
âŠ¢ âˆ€r r'. toPath r = toPath r' â‡” r = r'
</pre>

<DT><span class="strong">fromPath_11</span>
<DD>
<pre>
âŠ¢ âˆ€a a'. fromPath a = fromPath a' â‡” a = a'
</pre>

<DT><span class="strong">fromPath_onto</span>
<DD>
<pre>
âŠ¢ âˆ€r. âˆƒa. r = fromPath a
</pre>

<DT><span class="strong">toPath_onto</span>
<DD>
<pre>
âŠ¢ âˆ€a. âˆƒr. a = toPath r
</pre>

<DT><span class="strong">stopped_at_11</span>
<DD>
<pre>
âŠ¢ âˆ€x y. stopped_at x = stopped_at y â‡” x = y
</pre>

<DT><span class="strong">pcons_11</span>
<DD>
<pre>
âŠ¢ âˆ€x r p y s q. pcons x r p = pcons y s q â‡” x = y âˆ§ r = s âˆ§ p = q
</pre>

<DT><span class="strong">stopped_at_not_pcons</span>
<DD>
<pre>
âŠ¢ âˆ€x y r p. stopped_at x â‰  pcons y r p âˆ§ pcons y r p â‰  stopped_at x
</pre>

<DT><span class="strong">path_cases</span>
<DD>
<pre>
âŠ¢ âˆ€p. (âˆƒx. p = stopped_at x) âˆ¨ âˆƒx r q. p = pcons x r q
</pre>

<DT><span class="strong">FORALL_path</span>
<DD>
<pre>
âŠ¢ âˆ€P. (âˆ€p. P p) â‡” (âˆ€x. P (stopped_at x)) âˆ§ âˆ€x r p. P (pcons x r p)
</pre>

<DT><span class="strong">EXISTS_path</span>
<DD>
<pre>
âŠ¢ âˆ€P. (âˆƒp. P p) â‡” (âˆƒx. P (stopped_at x)) âˆ¨ âˆƒx r p. P (pcons x r p)
</pre>

<DT><span class="strong">first_thm</span>
<DD>
<pre>
âŠ¢ (âˆ€x. first (stopped_at x) = x) âˆ§ âˆ€x r p. first (pcons x r p) = x
</pre>

<DT><span class="strong">finite_thm</span>
<DD>
<pre>
âŠ¢ (âˆ€x. finite (stopped_at x) â‡” T) âˆ§ âˆ€x r p. finite (pcons x r p) â‡” finite p
</pre>

<DT><span class="strong">path_bisimulation</span>
<DD>
<pre>
âŠ¢ âˆ€p1 p2.
      p1 = p2 â‡”
      âˆƒR.
          R p1 p2 âˆ§
          âˆ€q1 q2.
              R q1 q2 â‡’
              (âˆƒx. q1 = stopped_at x âˆ§ q2 = stopped_at x) âˆ¨
              âˆƒx r q1' q2'.
                  q1 = pcons x r q1' âˆ§ q2 = pcons x r q2' âˆ§ R q1' q2'
</pre>

<DT><span class="strong">finite_path_ind</span>
<DD>
<pre>
âŠ¢ âˆ€P.
      (âˆ€x. P (stopped_at x)) âˆ§ (âˆ€x r p. finite p âˆ§ P p â‡’ P (pcons x r p)) â‡’
      âˆ€q. finite q â‡’ P q
</pre>

<DT><span class="strong">pmap_thm</span>
<DD>
<pre>
âŠ¢ (âˆ€x. pmap f g (stopped_at x) = stopped_at (f x)) âˆ§
  âˆ€x r p. pmap f g (pcons x r p) = pcons (f x) (g r) (pmap f g p)
</pre>

<DT><span class="strong">first_pmap</span>
<DD>
<pre>
âŠ¢ âˆ€p. first (pmap f g p) = f (first p)
</pre>

<DT><span class="strong">last_pmap</span>
<DD>
<pre>
âŠ¢ âˆ€p. finite p â‡’ last (pmap f g p) = f (last p)
</pre>

<DT><span class="strong">finite_pmap</span>
<DD>
<pre>
âŠ¢ âˆ€f g p. finite (pmap f g p) â‡” finite p
</pre>

<DT><span class="strong">length_thm</span>
<DD>
<pre>
âŠ¢ (âˆ€x. length (stopped_at x) = SOME 1) âˆ§
  âˆ€x r p.
      length (pcons x r p) = if finite p then SOME (THE (length p) + 1)
      else NONE
</pre>

<DT><span class="strong">alt_length_thm</span>
<DD>
<pre>
âŠ¢ (âˆ€x. length (stopped_at x) = SOME 1) âˆ§
  âˆ€x r p. length (pcons x r p) = OPTION_MAP SUC (length p)
</pre>

<DT><span class="strong">length_never_zero</span>
<DD>
<pre>
âŠ¢ âˆ€p. length p â‰  SOME 0
</pre>

<DT><span class="strong">finite_length</span>
<DD>
<pre>
âŠ¢ âˆ€p. (finite p â‡” âˆƒn. length p = SOME n) âˆ§ (Â¬finite p â‡” length p = NONE)
</pre>

<DT><span class="strong">length_pmap</span>
<DD>
<pre>
âŠ¢ âˆ€f g p. length (pmap f g p) = length p
</pre>

<DT><span class="strong">el_def_compute</span>
<DD>
<pre>
âŠ¢ (âˆ€p. el 0 p = first p) âˆ§
  (âˆ€n p. el (NUMERAL (BIT1 n)) p = el (NUMERAL (BIT1 n) âˆ’ 1) (tail p)) âˆ§
  âˆ€n p. el (NUMERAL (BIT2 n)) p = el (NUMERAL (BIT1 n)) (tail p)
</pre>

<DT><span class="strong">nth_label_def_compute</span>
<DD>
<pre>
âŠ¢ (âˆ€p. nth_label 0 p = first_label p) âˆ§
  (âˆ€n p.
       nth_label (NUMERAL (BIT1 n)) p =
       nth_label (NUMERAL (BIT1 n) âˆ’ 1) (tail p)) âˆ§
  âˆ€n p. nth_label (NUMERAL (BIT2 n)) p = nth_label (NUMERAL (BIT1 n)) (tail p)
</pre>

<DT><span class="strong">path_Axiom</span>
<DD>
<pre>
âŠ¢ âˆ€f.
      âˆƒg.
          âˆ€x.
              g x =
              case f x of
                (y,NONE) => stopped_at y
              | (y,SOME (l,v)) => pcons y l (g v)
</pre>

<DT><span class="strong">pconcat_thm</span>
<DD>
<pre>
âŠ¢ (âˆ€x lab p2. pconcat (stopped_at x) lab p2 = pcons x lab p2) âˆ§
  âˆ€x r p lab p2. pconcat (pcons x r p) lab p2 = pcons x r (pconcat p lab p2)
</pre>

<DT><span class="strong">pconcat_eq_stopped</span>
<DD>
<pre>
âŠ¢ âˆ€p1 lab p2 x.
      pconcat p1 lab p2 â‰  stopped_at x âˆ§ stopped_at x â‰  pconcat p1 lab p2
</pre>

<DT><span class="strong">pconcat_eq_pcons</span>
<DD>
<pre>
âŠ¢ âˆ€x r p p1 lab p2.
      (pconcat p1 lab p2 = pcons x r p â‡”
       lab = r âˆ§ p1 = stopped_at x âˆ§ p = p2 âˆ¨
       âˆƒp1'. p1 = pcons x r p1' âˆ§ p = pconcat p1' lab p2) âˆ§
      (pcons x r p = pconcat p1 lab p2 â‡”
       lab = r âˆ§ p1 = stopped_at x âˆ§ p = p2 âˆ¨
       âˆƒp1'. p1 = pcons x r p1' âˆ§ p = pconcat p1' lab p2)
</pre>

<DT><span class="strong">finite_pconcat</span>
<DD>
<pre>
âŠ¢ âˆ€p1 lab p2. finite (pconcat p1 lab p2) â‡” finite p1 âˆ§ finite p2
</pre>

<DT><span class="strong">infinite_PL</span>
<DD>
<pre>
âŠ¢ âˆ€p. Â¬finite p â‡’ âˆ€i. i âˆˆ PL p
</pre>

<DT><span class="strong">PL_pcons</span>
<DD>
<pre>
âŠ¢ âˆ€x r q. PL (pcons x r q) = 0 INSERT IMAGE SUC (PL q)
</pre>

<DT><span class="strong">PL_stopped_at</span>
<DD>
<pre>
âŠ¢ âˆ€x. PL (stopped_at x) = {0}
</pre>

<DT><span class="strong">PL_thm</span>
<DD>
<pre>
âŠ¢ (âˆ€x. PL (stopped_at x) = {0}) âˆ§
  âˆ€x r q. PL (pcons x r q) = 0 INSERT IMAGE SUC (PL q)
</pre>

<DT><span class="strong">PL_0</span>
<DD>
<pre>
âŠ¢ âˆ€p. 0 âˆˆ PL p
</pre>

<DT><span class="strong">PL_downward_closed</span>
<DD>
<pre>
âŠ¢ âˆ€i p. i âˆˆ PL p â‡’ âˆ€j. j < i â‡’ j âˆˆ PL p
</pre>

<DT><span class="strong">PL_pmap</span>
<DD>
<pre>
âŠ¢ PL (pmap f g p) = PL p
</pre>

<DT><span class="strong">el_pmap</span>
<DD>
<pre>
âŠ¢ âˆ€i p. i âˆˆ PL p â‡’ el i (pmap f g p) = f (el i p)
</pre>

<DT><span class="strong">nth_label_pmap</span>
<DD>
<pre>
âŠ¢ âˆ€i p. SUC i âˆˆ PL p â‡’ nth_label i (pmap f g p) = g (nth_label i p)
</pre>

<DT><span class="strong">firstP_at_thm</span>
<DD>
<pre>
âŠ¢ (âˆ€P x n. firstP_at P (stopped_at x) n â‡” n = 0 âˆ§ P x) âˆ§
  âˆ€P n x r p.
      firstP_at P (pcons x r p) n â‡”
      n = 0 âˆ§ P x âˆ¨ 0 < n âˆ§ Â¬P x âˆ§ firstP_at P p (n âˆ’ 1)
</pre>

<DT><span class="strong">firstP_at_zero</span>
<DD>
<pre>
âŠ¢ âˆ€P p. firstP_at P p 0 â‡” P (first p)
</pre>

<DT><span class="strong">exists_thm</span>
<DD>
<pre>
âŠ¢ âˆ€P.
      (âˆ€x. exists P (stopped_at x) â‡” P x) âˆ§
      âˆ€x r p. exists P (pcons x r p) â‡” P x âˆ¨ exists P p
</pre>

<DT><span class="strong">every_thm</span>
<DD>
<pre>
âŠ¢ âˆ€P.
      (âˆ€x. every P (stopped_at x) â‡” P x) âˆ§
      âˆ€x r p. every P (pcons x r p) â‡” P x âˆ§ every P p
</pre>

<DT><span class="strong">not_every</span>
<DD>
<pre>
âŠ¢ âˆ€P p. Â¬every P p â‡” exists ($~ âˆ˜ P) p
</pre>

<DT><span class="strong">not_exists</span>
<DD>
<pre>
âŠ¢ âˆ€P p. Â¬exists P p â‡” every ($~ âˆ˜ P) p
</pre>

<DT><span class="strong">exists_el</span>
<DD>
<pre>
âŠ¢ âˆ€P p. exists P p â‡” âˆƒi. i âˆˆ PL p âˆ§ P (el i p)
</pre>

<DT><span class="strong">every_el</span>
<DD>
<pre>
âŠ¢ âˆ€P p. every P p â‡” âˆ€i. i âˆˆ PL p â‡’ P (el i p)
</pre>

<DT><span class="strong">every_coinduction</span>
<DD>
<pre>
âŠ¢ âˆ€P Q.
      (âˆ€x. P (stopped_at x) â‡’ Q x) âˆ§ (âˆ€x r p. P (pcons x r p) â‡’ Q x âˆ§ P p) â‡’
      âˆ€p. P p â‡’ every Q p
</pre>

<DT><span class="strong">exists_induction</span>
<DD>
<pre>
âŠ¢ (âˆ€x. Q x â‡’ P (stopped_at x)) âˆ§ (âˆ€x r p. Q x â‡’ P (pcons x r p)) âˆ§
  (âˆ€x r p. P p â‡’ P (pcons x r p)) â‡’
  âˆ€p. exists Q p â‡’ P p
</pre>

<DT><span class="strong">mem_thm</span>
<DD>
<pre>
âŠ¢ (âˆ€x s. mem s (stopped_at x) â‡” s = x) âˆ§
  âˆ€x r p s. mem s (pcons x r p) â‡” s = x âˆ¨ mem s p
</pre>

<DT><span class="strong">drop_def_compute</span>
<DD>
<pre>
âŠ¢ (âˆ€p. drop 0 p = p) âˆ§
  (âˆ€n p. drop (NUMERAL (BIT1 n)) p = drop (NUMERAL (BIT1 n) âˆ’ 1) (tail p)) âˆ§
  âˆ€n p. drop (NUMERAL (BIT2 n)) p = drop (NUMERAL (BIT1 n)) (tail p)
</pre>

<DT><span class="strong">numeral_drop</span>
<DD>
<pre>
âŠ¢ (âˆ€n p. drop (NUMERAL (BIT1 n)) p = drop (NUMERAL (BIT1 n) âˆ’ 1) (tail p)) âˆ§
  âˆ€n p. drop (NUMERAL (BIT2 n)) p = drop (NUMERAL (BIT1 n)) (tail p)
</pre>

<DT><span class="strong">finite_drop</span>
<DD>
<pre>
âŠ¢ âˆ€p n. n âˆˆ PL p â‡’ (finite (drop n p) â‡” finite p)
</pre>

<DT><span class="strong">length_drop</span>
<DD>
<pre>
âŠ¢ âˆ€p n.
      n âˆˆ PL p â‡’
      length (drop n p) =
      case length p of NONE => NONE | SOME m => SOME (m âˆ’ n)
</pre>

<DT><span class="strong">PL_drop</span>
<DD>
<pre>
âŠ¢ âˆ€p i. i âˆˆ PL p â‡’ PL (drop i p) = IMAGE (Î»n. n âˆ’ i) (PL p)
</pre>

<DT><span class="strong">IN_PL_drop</span>
<DD>
<pre>
âŠ¢ âˆ€i j p. i âˆˆ PL p â‡’ (j âˆˆ PL (drop i p) â‡” i + j âˆˆ PL p)
</pre>

<DT><span class="strong">first_drop</span>
<DD>
<pre>
âŠ¢ âˆ€i p. i âˆˆ PL p â‡’ first (drop i p) = el i p
</pre>

<DT><span class="strong">first_label_drop</span>
<DD>
<pre>
âŠ¢ âˆ€i p. i âˆˆ PL p â‡’ first_label (drop i p) = nth_label i p
</pre>

<DT><span class="strong">tail_drop</span>
<DD>
<pre>
âŠ¢ âˆ€i p. i + 1 âˆˆ PL p â‡’ tail (drop i p) = drop (i + 1) p
</pre>

<DT><span class="strong">el_drop</span>
<DD>
<pre>
âŠ¢ âˆ€i j p. i + j âˆˆ PL p â‡’ el i (drop j p) = el (i + j) p
</pre>

<DT><span class="strong">nth_label_drop</span>
<DD>
<pre>
âŠ¢ âˆ€i j p. SUC (i + j) âˆˆ PL p â‡’ nth_label i (drop j p) = nth_label (i + j) p
</pre>

<DT><span class="strong">take_def_compute</span>
<DD>
<pre>
âŠ¢ (âˆ€p. take 0 p = stopped_at (first p)) âˆ§
  (âˆ€n p.
       take (NUMERAL (BIT1 n)) p =
       pcons (first p) (first_label p) (take (NUMERAL (BIT1 n) âˆ’ 1) (tail p))) âˆ§
  âˆ€n p.
      take (NUMERAL (BIT2 n)) p =
      pcons (first p) (first_label p) (take (NUMERAL (BIT1 n)) (tail p))
</pre>

<DT><span class="strong">first_take</span>
<DD>
<pre>
âŠ¢ âˆ€p i. first (take i p) = first p
</pre>

<DT><span class="strong">finite_take</span>
<DD>
<pre>
âŠ¢ âˆ€p i. i âˆˆ PL p â‡’ finite (take i p)
</pre>

<DT><span class="strong">length_take</span>
<DD>
<pre>
âŠ¢ âˆ€p i. i âˆˆ PL p â‡’ length (take i p) = SOME (i + 1)
</pre>

<DT><span class="strong">PL_take</span>
<DD>
<pre>
âŠ¢ âˆ€p i. i âˆˆ PL p â‡’ PL (take i p) = {n | n â‰¤ i}
</pre>

<DT><span class="strong">last_take</span>
<DD>
<pre>
âŠ¢ âˆ€i p. i âˆˆ PL p â‡’ last (take i p) = el i p
</pre>

<DT><span class="strong">nth_label_take</span>
<DD>
<pre>
âŠ¢ âˆ€n p i. i < n âˆ§ n âˆˆ PL p â‡’ nth_label i (take n p) = nth_label i p
</pre>

<DT><span class="strong">singleton_seg</span>
<DD>
<pre>
âŠ¢ âˆ€i p. i âˆˆ PL p â‡’ seg i i p = stopped_at (el i p)
</pre>

<DT><span class="strong">recursive_seg</span>
<DD>
<pre>
âŠ¢ âˆ€i j p.
      i < j âˆ§ j âˆˆ PL p â‡’
      seg i j p = pcons (el i p) (nth_label i p) (seg (i + 1) j p)
</pre>

<DT><span class="strong">PL_seg</span>
<DD>
<pre>
âŠ¢ âˆ€i j p. i â‰¤ j âˆ§ j âˆˆ PL p â‡’ PL (seg i j p) = {n | n â‰¤ j âˆ’ i}
</pre>

<DT><span class="strong">finite_seg</span>
<DD>
<pre>
âŠ¢ âˆ€p i j. i â‰¤ j âˆ§ j âˆˆ PL p â‡’ finite (seg i j p)
</pre>

<DT><span class="strong">first_seg</span>
<DD>
<pre>
âŠ¢ âˆ€i j p. i â‰¤ j âˆ§ j âˆˆ PL p â‡’ first (seg i j p) = el i p
</pre>

<DT><span class="strong">last_seg</span>
<DD>
<pre>
âŠ¢ âˆ€i j p. i â‰¤ j âˆ§ j âˆˆ PL p â‡’ last (seg i j p) = el j p
</pre>

<DT><span class="strong">firstP_at_unique</span>
<DD>
<pre>
âŠ¢ âˆ€P p n. firstP_at P p n â‡’ âˆ€m. firstP_at P p m â‡” m = n
</pre>

<DT><span class="strong">is_stopped_thm</span>
<DD>
<pre>
âŠ¢ (âˆ€x. is_stopped (stopped_at x) â‡” T) âˆ§ âˆ€x r p. is_stopped (pcons x r p) â‡” F
</pre>

<DT><span class="strong">filter_every</span>
<DD>
<pre>
âŠ¢ âˆ€P p. exists P p â‡’ every P (filter P p)
</pre>

<DT><span class="strong">pgenerate_infinite</span>
<DD>
<pre>
âŠ¢ âˆ€f g. Â¬finite (pgenerate f g)
</pre>

<DT><span class="strong">pgenerate_not_stopped</span>
<DD>
<pre>
âŠ¢ âˆ€f g x. stopped_at x â‰  pgenerate f g
</pre>

<DT><span class="strong">el_pgenerate</span>
<DD>
<pre>
âŠ¢ âˆ€n f g. el n (pgenerate f g) = f n
</pre>

<DT><span class="strong">nth_label_pgenerate</span>
<DD>
<pre>
âŠ¢ âˆ€n f g. nth_label n (pgenerate f g) = g n
</pre>

<DT><span class="strong">pgenerate_11</span>
<DD>
<pre>
âŠ¢ âˆ€f1 g1 f2 g2. pgenerate f1 g1 = pgenerate f2 g2 â‡” f1 = f2 âˆ§ g1 = g2
</pre>

<DT><span class="strong">pgenerate_onto</span>
<DD>
<pre>
âŠ¢ âˆ€p. Â¬finite p â‡’ âˆƒf g. p = pgenerate f g
</pre>

<DT><span class="strong">okpath_monotone</span>
<DD>
<pre>
âŠ¢ âˆ€R. monotone (okpath_f R)
</pre>

<DT><span class="strong">okpath_co_ind</span>
<DD>
<pre>
âŠ¢ âˆ€P. (âˆ€x r p. P (pcons x r p) â‡’ R x r (first p) âˆ§ P p) â‡’ âˆ€p. P p â‡’ okpath R p
</pre>

<DT><span class="strong">okpath_cases</span>
<DD>
<pre>
âŠ¢ âˆ€R x.
      okpath R x â‡”
      (âˆƒx'. x = stopped_at x') âˆ¨
      âˆƒx' r p. x = pcons x' r p âˆ§ R x' r (first p) âˆ§ okpath R p
</pre>

<DT><span class="strong">okpath_thm</span>
<DD>
<pre>
âŠ¢ âˆ€R.
      (âˆ€x. okpath R (stopped_at x)) âˆ§
      âˆ€x r p. okpath R (pcons x r p) â‡” R x r (first p) âˆ§ okpath R p
</pre>

<DT><span class="strong">finite_okpath_ind</span>
<DD>
<pre>
âŠ¢ âˆ€R.
      (âˆ€x. P (stopped_at x)) âˆ§
      (âˆ€x r p. okpath R p âˆ§ finite p âˆ§ R x r (first p) âˆ§ P p â‡’ P (pcons x r p)) â‡’
      âˆ€sigma. okpath R sigma âˆ§ finite sigma â‡’ P sigma
</pre>

<DT><span class="strong">okpath_pmap</span>
<DD>
<pre>
âŠ¢ âˆ€R f g p.
      okpath R p âˆ§ (âˆ€x r y. R x r y â‡’ R (f x) (g r) (f y)) â‡’
      okpath R (pmap f g p)
</pre>

<DT><span class="strong">finite_plink</span>
<DD>
<pre>
âŠ¢ âˆ€p1 p2. finite (plink p1 p2) â‡” finite p1 âˆ§ finite p2
</pre>

<DT><span class="strong">first_plink</span>
<DD>
<pre>
âŠ¢ âˆ€p1 p2. last p1 = first p2 â‡’ first (plink p1 p2) = first p1
</pre>

<DT><span class="strong">last_plink</span>
<DD>
<pre>
âŠ¢ âˆ€p1 p2.
      finite p1 âˆ§ finite p2 âˆ§ last p1 = first p2 â‡’
      last (plink p1 p2) = last p2
</pre>

<DT><span class="strong">okpath_plink</span>
<DD>
<pre>
âŠ¢ âˆ€R p1 p2.
      finite p1 âˆ§ last p1 = first p2 â‡’
      (okpath R (plink p1 p2) â‡” okpath R p1 âˆ§ okpath R p2)
</pre>

<DT><span class="strong">okpath_take</span>
<DD>
<pre>
âŠ¢ âˆ€R p i. i âˆˆ PL p âˆ§ okpath R p â‡’ okpath R (take i p)
</pre>

<DT><span class="strong">okpath_drop</span>
<DD>
<pre>
âŠ¢ âˆ€R p i. i âˆˆ PL p âˆ§ okpath R p â‡’ okpath R (drop i p)
</pre>

<DT><span class="strong">okpath_seg</span>
<DD>
<pre>
âŠ¢ âˆ€R p i j. i â‰¤ j âˆ§ j âˆˆ PL p âˆ§ okpath R p â‡’ okpath R (seg i j p)
</pre>

<DT><span class="strong">SN_finite_paths</span>
<DD>
<pre>
âŠ¢ âˆ€R p. SN R âˆ§ okpath R p â‡’ finite p
</pre>

<DT><span class="strong">finite_paths_SN</span>
<DD>
<pre>
âŠ¢ âˆ€R. (âˆ€p. okpath R p â‡’ finite p) â‡’ SN R
</pre>

<DT><span class="strong">SN_finite_paths_EQ</span>
<DD>
<pre>
âŠ¢ âˆ€R. SN R â‡” âˆ€p. okpath R p â‡’ finite p
</pre>

<DT><span class="strong">labels_LMAP</span>
<DD>
<pre>
âŠ¢ âˆ€p. labels p = LMAP FST (SND (fromPath p))
</pre>

<DT><span class="strong">labels_plink</span>
<DD>
<pre>
âŠ¢ âˆ€p1 p2. labels (plink p1 p2) = LAPPEND (labels p1) (labels p2)
</pre>

<DT><span class="strong">finite_labels</span>
<DD>
<pre>
âŠ¢ âˆ€p. LFINITE (labels p) â‡” finite p
</pre>

<DT><span class="strong">unfold_thm</span>
<DD>
<pre>
âŠ¢ âˆ€proj f s.
      unfold proj f s =
      case f s of
        NONE => stopped_at (proj s)
      | SOME (s',l) => pcons (proj s) l (unfold proj f s')
</pre>

<DT><span class="strong">unfold_thm2</span>
<DD>
<pre>
âŠ¢ âˆ€proj f x v1 v2.
      (f x = NONE â‡’ unfold proj f x = stopped_at (proj x)) âˆ§
      (f x = SOME (v1,v2) â‡’
       unfold proj f x = pcons (proj x) v2 (unfold proj f v1))
</pre>

<DT><span class="strong">labels_unfold</span>
<DD>
<pre>
âŠ¢ âˆ€proj f s. labels (unfold proj f s) = LUNFOLD f s
</pre>

<DT><span class="strong">okpath_unfold</span>
<DD>
<pre>
âŠ¢ âˆ€P m proj f s.
      P s âˆ§ (âˆ€s s' l. P s âˆ§ f s = SOME (s',l) â‡’ P s') âˆ§
      (âˆ€s s' l. P s âˆ§ f s = SOME (s',l) â‡’ m (proj s) l (proj s')) â‡’
      okpath m (unfold proj f s)
</pre>

<DT><span class="strong">trace_machine_thm</span>
<DD>
<pre>
âŠ¢ âˆ€P tr.
      (âˆ€n l. LTAKE n tr = SOME l â‡’ P l) â‡’
      âˆƒp. tr = labels p âˆ§ okpath (trace_machine P) p âˆ§ first p = []
</pre>

<DT><span class="strong">trace_machine_thm2</span>
<DD>
<pre>
âŠ¢ âˆ€n l P p init.
      okpath (trace_machine P) p âˆ§ P (first p) â‡’
      LTAKE n (labels p) = SOME l â‡’
      P (first p ++ l)
</pre>

<DT><span class="strong">LTAKE_labels</span>
<DD>
<pre>
âŠ¢ âˆ€n p l.
      LTAKE n (labels p) = SOME l â‡”
      n âˆˆ PL p âˆ§ toList (labels (take n p)) = SOME l
</pre>

<DT><span class="strong">drop_eq_pcons</span>
<DD>
<pre>
âŠ¢ âˆ€n p h l t. n âˆˆ PL p âˆ§ drop n p = pcons h l t â‡’ n + 1 âˆˆ PL p
</pre>

<DT><span class="strong">okpath_parallel_comp</span>
<DD>
<pre>
âŠ¢ âˆ€p m1 m2.
      okpath (parallel_comp m1 m2) p â‡”
      okpath m1 (pmap FST (Î»x. x) p) âˆ§ okpath m2 (pmap SND (Î»x. x) p)
</pre>

<DT><span class="strong">build_pcomp_trace</span>
<DD>
<pre>
âŠ¢ âˆ€m1 p1 m2 p2.
      okpath m1 p1 âˆ§ okpath m2 p2 âˆ§ labels p1 = labels p2 â‡’
      âˆƒp.
          okpath (parallel_comp m1 m2) p âˆ§ labels p = labels p1 âˆ§
          first p = (first p1,first p2)
</pre>

<DT><span class="strong">nth_label_LNTH</span>
<DD>
<pre>
âŠ¢ âˆ€n p x. LNTH n (labels p) = SOME x â‡” n + 1 âˆˆ PL p âˆ§ nth_label n p = x
</pre>

<DT><span class="strong">nth_label_LTAKE</span>
<DD>
<pre>
âŠ¢ âˆ€n p l i v.
      LTAKE n (labels p) = SOME l âˆ§ i < LENGTH l â‡’ nth_label i p = EL i l
</pre>

<DT><span class="strong">finite_path_end_cases</span>
<DD>
<pre>
âŠ¢ âˆ€p.
      finite p â‡’
      (âˆƒx. p = stopped_at x) âˆ¨
      âˆƒp' l s. p = plink p' (pcons (last p') l (stopped_at s))
</pre>

<DT><span class="strong">simulation_trace_inclusion</span>
<DD>
<pre>
âŠ¢ âˆ€R M1 M2 p t_init.
      (âˆ€s1 l s2 t1. R s1 t1 âˆ§ M1 s1 l s2 â‡’ âˆƒt2. R s2 t2 âˆ§ M2 t1 l t2) âˆ§
      okpath M1 p âˆ§ R (first p) t_init â‡’
      âˆƒq. okpath M2 q âˆ§ labels p = labels q âˆ§ first q = t_init
</pre>

</DL>



<hr>
</body>
</html>
