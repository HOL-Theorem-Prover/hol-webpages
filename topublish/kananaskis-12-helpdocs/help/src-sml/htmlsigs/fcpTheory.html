<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure fcpTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure fcpTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/n-bit/fcpScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature fcpTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#FCP-val">FCP</a> : thm
<a name="line7"></a>    val <a href="#FCP_CONCAT_def-val">FCP_CONCAT_def</a> : thm
<a name="line8"></a>    val <a href="#FCP_CONS_def-val">FCP_CONS_def</a> : thm
<a name="line9"></a>    val <a href="#FCP_EVERY_def-val">FCP_EVERY_def</a> : thm
<a name="line10"></a>    val <a href="#FCP_EXISTS_def-val">FCP_EXISTS_def</a> : thm
<a name="line11"></a>    val <a href="#FCP_FOLD_def-val">FCP_FOLD_def</a> : thm
<a name="line12"></a>    val <a href="#FCP_HD_def-val">FCP_HD_def</a> : thm
<a name="line13"></a>    val <a href="#FCP_MAP_def-val">FCP_MAP_def</a> : thm
<a name="line14"></a>    val <a href="#FCP_TL_def-val">FCP_TL_def</a> : thm
<a name="line15"></a>    val <a href="#FCP_UPDATE_def-val">FCP_UPDATE_def</a> : thm
<a name="line16"></a>    val <a href="#FCP_ZIP_def-val">FCP_ZIP_def</a> : thm
<a name="line17"></a>    val <a href="#HAS_SIZE_def-val">HAS_SIZE_def</a> : thm
<a name="line18"></a>    val <a href="#L2V_def-val">L2V_def</a> : thm
<a name="line19"></a>    val <a href="#V2L_def-val">V2L_def</a> : thm
<a name="line20"></a>    val <a href="#bit0_TY_DEF-val">bit0_TY_DEF</a> : thm
<a name="line21"></a>    val <a href="#bit0_case_def-val">bit0_case_def</a> : thm
<a name="line22"></a>    val <a href="#bit0_size_def-val">bit0_size_def</a> : thm
<a name="line23"></a>    val <a href="#bit1_TY_DEF-val">bit1_TY_DEF</a> : thm
<a name="line24"></a>    val <a href="#bit1_case_def-val">bit1_case_def</a> : thm
<a name="line25"></a>    val <a href="#bit1_size_def-val">bit1_size_def</a> : thm
<a name="line26"></a>    val <a href="#cart_TY_DEF-val">cart_TY_DEF</a> : thm
<a name="line27"></a>    val <a href="#cart_tybij-val">cart_tybij</a> : thm
<a name="line28"></a>    val <a href="#dimindex_def-val">dimindex_def</a> : thm
<a name="line29"></a>    val <a href="#fcp_case_def-val">fcp_case_def</a> : thm
<a name="line30"></a>    val <a href="#fcp_index-val">fcp_index</a> : thm
<a name="line31"></a>    val <a href="#finite_image_TY_DEF-val">finite_image_TY_DEF</a> : thm
<a name="line32"></a>    val <a href="#finite_image_tybij-val">finite_image_tybij</a> : thm
<a name="line33"></a>    val <a href="#finite_index_def-val">finite_index_def</a> : thm
<a name="line34"></a>  
<a name="line35"></a>  (*  Theorems  *)
<a name="line36"></a>    val <a href="#APPLY_FCP_UPDATE_ID-val">APPLY_FCP_UPDATE_ID</a> : thm
<a name="line37"></a>    val <a href="#CART_EQ-val">CART_EQ</a> : thm
<a name="line38"></a>    val <a href="#DIMINDEX_GE_1-val">DIMINDEX_GE_1</a> : thm
<a name="line39"></a>    val <a href="#EL_V2L-val">EL_V2L</a> : thm
<a name="line40"></a>    val <a href="#FCP_APPLY_UPDATE_THM-val">FCP_APPLY_UPDATE_THM</a> : thm
<a name="line41"></a>    val <a href="#FCP_BETA-val">FCP_BETA</a> : thm
<a name="line42"></a>    val <a href="#FCP_CONS-val">FCP_CONS</a> : thm
<a name="line43"></a>    val <a href="#FCP_ETA-val">FCP_ETA</a> : thm
<a name="line44"></a>    val <a href="#FCP_EVERY-val">FCP_EVERY</a> : thm
<a name="line45"></a>    val <a href="#FCP_EXISTS-val">FCP_EXISTS</a> : thm
<a name="line46"></a>    val <a href="#FCP_HD-val">FCP_HD</a> : thm
<a name="line47"></a>    val <a href="#FCP_MAP-val">FCP_MAP</a> : thm
<a name="line48"></a>    val <a href="#FCP_TL-val">FCP_TL</a> : thm
<a name="line49"></a>    val <a href="#FCP_UNIQUE-val">FCP_UNIQUE</a> : thm
<a name="line50"></a>    val <a href="#FCP_UPDATE_COMMUTES-val">FCP_UPDATE_COMMUTES</a> : thm
<a name="line51"></a>    val <a href="#FCP_UPDATE_EQ-val">FCP_UPDATE_EQ</a> : thm
<a name="line52"></a>    val <a href="#FCP_UPDATE_IMP_ID-val">FCP_UPDATE_IMP_ID</a> : thm
<a name="line53"></a>    val <a href="#LENGTH_V2L-val">LENGTH_V2L</a> : thm
<a name="line54"></a>    val <a href="#NOT_FINITE_IMP_dimindex_1-val">NOT_FINITE_IMP_dimindex_1</a> : thm
<a name="line55"></a>    val <a href="#NULL_V2L-val">NULL_V2L</a> : thm
<a name="line56"></a>    val <a href="#READ_L2V-val">READ_L2V</a> : thm
<a name="line57"></a>    val <a href="#READ_TL-val">READ_TL</a> : thm
<a name="line58"></a>    val <a href="#V2L_L2V-val">V2L_L2V</a> : thm
<a name="line59"></a>    val <a href="#bit0_11-val">bit0_11</a> : thm
<a name="line60"></a>    val <a href="#bit0_Axiom-val">bit0_Axiom</a> : thm
<a name="line61"></a>    val <a href="#bit0_case_cong-val">bit0_case_cong</a> : thm
<a name="line62"></a>    val <a href="#bit0_case_eq-val">bit0_case_eq</a> : thm
<a name="line63"></a>    val <a href="#bit0_distinct-val">bit0_distinct</a> : thm
<a name="line64"></a>    val <a href="#bit0_induction-val">bit0_induction</a> : thm
<a name="line65"></a>    val <a href="#bit0_nchotomy-val">bit0_nchotomy</a> : thm
<a name="line66"></a>    val <a href="#bit1_11-val">bit1_11</a> : thm
<a name="line67"></a>    val <a href="#bit1_Axiom-val">bit1_Axiom</a> : thm
<a name="line68"></a>    val <a href="#bit1_case_cong-val">bit1_case_cong</a> : thm
<a name="line69"></a>    val <a href="#bit1_case_eq-val">bit1_case_eq</a> : thm
<a name="line70"></a>    val <a href="#bit1_distinct-val">bit1_distinct</a> : thm
<a name="line71"></a>    val <a href="#bit1_induction-val">bit1_induction</a> : thm
<a name="line72"></a>    val <a href="#bit1_nchotomy-val">bit1_nchotomy</a> : thm
<a name="line73"></a>    val <a href="#card_dimindex-val">card_dimindex</a> : thm
<a name="line74"></a>    val <a href="#datatype_bit0-val">datatype_bit0</a> : thm
<a name="line75"></a>    val <a href="#datatype_bit1-val">datatype_bit1</a> : thm
<a name="line76"></a>    val <a href="#fcp_Axiom-val">fcp_Axiom</a> : thm
<a name="line77"></a>    val <a href="#fcp_ind-val">fcp_ind</a> : thm
<a name="line78"></a>    val <a href="#fcp_subst_comp-val">fcp_subst_comp</a> : thm
<a name="line79"></a>    val <a href="#finite_bit0-val">finite_bit0</a> : thm
<a name="line80"></a>    val <a href="#finite_bit1-val">finite_bit1</a> : thm
<a name="line81"></a>    val <a href="#finite_one-val">finite_one</a> : thm
<a name="line82"></a>    val <a href="#finite_sum-val">finite_sum</a> : thm
<a name="line83"></a>    val <a href="#index_bit0-val">index_bit0</a> : thm
<a name="line84"></a>    val <a href="#index_bit1-val">index_bit1</a> : thm
<a name="line85"></a>    val <a href="#index_comp-val">index_comp</a> : thm
<a name="line86"></a>    val <a href="#index_one-val">index_one</a> : thm
<a name="line87"></a>    val <a href="#index_sum-val">index_sum</a> : thm
<a name="line88"></a>  
<a name="line89"></a>  val fcp_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line90"></a>(*
   [indexedLists] Parent theory of "fcp"
   
   [patternMatches] Parent theory of "fcp"
   
   [<a name="FCP-val"><b>FCP</b></a>]  Definition
      
      ‚ä¢ $FCP = (Œªg. @f. ‚àÄi. i &lt; dimindex (:Œ≤) ‚áí (f ' i = g i))
   
   [<a name="FCP_CONCAT_def-val"><b>FCP_CONCAT_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄa b.
            FCP_CONCAT a b =
            FCP i.
                if i &lt; dimindex (:Œ≥) then b ' i
                else a ' (i ‚àí dimindex (:Œ≥))
   
   [<a name="FCP_CONS_def-val"><b>FCP_CONS_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄh v. FCP_CONS h v = (0 :+ h) (FCP i. v ' (PRE i))
   
   [<a name="FCP_EVERY_def-val"><b>FCP_EVERY_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄP v. FCP_EVERY P v ‚áî ‚àÄi. dimindex (:Œ±) ‚â§ i ‚à® P (v ' i)
   
   [<a name="FCP_EXISTS_def-val"><b>FCP_EXISTS_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄP v. FCP_EXISTS P v ‚áî ‚àÉi. i &lt; dimindex (:Œ±) ‚àß P (v ' i)
   
   [<a name="FCP_FOLD_def-val"><b>FCP_FOLD_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄf i v. FCP_FOLD f i v = FOLDL f i (V2L v)
   
   [<a name="FCP_HD_def-val"><b>FCP_HD_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄv. FCP_HD v = v ' 0
   
   [<a name="FCP_MAP_def-val"><b>FCP_MAP_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄf v. FCP_MAP f v = FCP i. f (v ' i)
   
   [<a name="FCP_TL_def-val"><b>FCP_TL_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄv. FCP_TL v = FCP i. v ' (SUC i)
   
   [<a name="FCP_UPDATE_def-val"><b>FCP_UPDATE_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄa b. a :+ b = (Œªm. FCP c. if a = c then b else m ' c)
   
   [<a name="FCP_ZIP_def-val"><b>FCP_ZIP_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄa b. FCP_ZIP a b = FCP i. (a ' i,b ' i)
   
   [<a name="HAS_SIZE_def-val"><b>HAS_SIZE_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄs n. s HAS_SIZE n ‚áî FINITE s ‚àß (CARD s = n)
   
   [<a name="L2V_def-val"><b>L2V_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄL. L2V L = FCP i. EL i L
   
   [<a name="V2L_def-val"><b>V2L_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄv. V2L v = GENLIST ($' v) (dimindex (:Œ≤))
   
   [<a name="bit0_TY_DEF-val"><b>bit0_TY_DEF</b></a>]  Definition
      
      ‚ä¢ ‚àÉrep.
            TYPE_DEFINITION
              (Œªa0.
                   ‚àÄ'bit0' .
                       (‚àÄa0.
                            (‚àÉa.
                                 a0 =
                                 (Œªa.
                                      ind_type$CONSTR 0 a
                                        (Œªn. ind_type$BOTTOM)) a) ‚à®
                            (‚àÉa.
                                 a0 =
                                 (Œªa.
                                      ind_type$CONSTR (SUC 0) a
                                        (Œªn. ind_type$BOTTOM)) a) ‚áí
                            'bit0' a0) ‚áí
                       'bit0' a0) rep
   
   [<a name="bit0_case_def-val"><b>bit0_case_def</b></a>]  Definition
      
      ‚ä¢ (‚àÄa f f1. bit0_CASE (BIT0A a) f f1 = f a) ‚àß
        ‚àÄa f f1. bit0_CASE (BIT0B a) f f1 = f1 a
   
   [<a name="bit0_size_def-val"><b>bit0_size_def</b></a>]  Definition
      
      ‚ä¢ (‚àÄf a. bit0_size f (BIT0A a) = 1 + f a) ‚àß
        ‚àÄf a. bit0_size f (BIT0B a) = 1 + f a
   
   [<a name="bit1_TY_DEF-val"><b>bit1_TY_DEF</b></a>]  Definition
      
      ‚ä¢ ‚àÉrep.
            TYPE_DEFINITION
              (Œªa0.
                   ‚àÄ'bit1' .
                       (‚àÄa0.
                            (‚àÉa.
                                 a0 =
                                 (Œªa.
                                      ind_type$CONSTR 0 a
                                        (Œªn. ind_type$BOTTOM)) a) ‚à®
                            (‚àÉa.
                                 a0 =
                                 (Œªa.
                                      ind_type$CONSTR (SUC 0) a
                                        (Œªn. ind_type$BOTTOM)) a) ‚à®
                            (a0 =
                             ind_type$CONSTR (SUC (SUC 0)) ARB
                               (Œªn. ind_type$BOTTOM)) ‚áí
                            'bit1' a0) ‚áí
                       'bit1' a0) rep
   
   [<a name="bit1_case_def-val"><b>bit1_case_def</b></a>]  Definition
      
      ‚ä¢ (‚àÄa f f1 v. bit1_CASE (BIT1A a) f f1 v = f a) ‚àß
        (‚àÄa f f1 v. bit1_CASE (BIT1B a) f f1 v = f1 a) ‚àß
        ‚àÄf f1 v. bit1_CASE BIT1C f f1 v = v
   
   [<a name="bit1_size_def-val"><b>bit1_size_def</b></a>]  Definition
      
      ‚ä¢ (‚àÄf a. bit1_size f (BIT1A a) = 1 + f a) ‚àß
        (‚àÄf a. bit1_size f (BIT1B a) = 1 + f a) ‚àß ‚àÄf. bit1_size f BIT1C = 0
   
   [<a name="cart_TY_DEF-val"><b>cart_TY_DEF</b></a>]  Definition
      
      ‚ä¢ ‚àÉrep. TYPE_DEFINITION (Œªf. T) rep
   
   [<a name="cart_tybij-val"><b>cart_tybij</b></a>]  Definition
      
      ‚ä¢ (‚àÄa. mk_cart (dest_cart a) = a) ‚àß
        ‚àÄr. (Œªf. T) r ‚áî (dest_cart (mk_cart r) = r)
   
   [<a name="dimindex_def-val"><b>dimindex_def</b></a>]  Definition
      
      ‚ä¢ dimindex (:Œ±) = if FINITE ùïå(:Œ±) then CARD ùïå(:Œ±) else 1
   
   [<a name="fcp_case_def-val"><b>fcp_case_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄh f. fcp_CASE (mk_cart h) f = f h
   
   [<a name="fcp_index-val"><b>fcp_index</b></a>]  Definition
      
      ‚ä¢ ‚àÄx i. x ' i = dest_cart x (finite_index i)
   
   [<a name="finite_image_TY_DEF-val"><b>finite_image_TY_DEF</b></a>]  Definition
      
      ‚ä¢ ‚àÉrep. TYPE_DEFINITION (Œªx. (x = ARB) ‚à® FINITE ùïå(:Œ±)) rep
   
   [<a name="finite_image_tybij-val"><b>finite_image_tybij</b></a>]  Definition
      
      ‚ä¢ (‚àÄa. mk_finite_image (dest_finite_image a) = a) ‚àß
        ‚àÄr.
            (Œªx. (x = ARB) ‚à® FINITE ùïå(:Œ±)) r ‚áî
            (dest_finite_image (mk_finite_image r) = r)
   
   [<a name="finite_index_def-val"><b>finite_index_def</b></a>]  Definition
      
      ‚ä¢ finite_index = @f. ‚àÄx. ‚àÉ!n. n &lt; dimindex (:Œ±) ‚àß (f n = x)
   
   [<a name="APPLY_FCP_UPDATE_ID-val"><b>APPLY_FCP_UPDATE_ID</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm a. (a :+ m ' a) m = m
   
   [<a name="CART_EQ-val"><b>CART_EQ</b></a>]  Theorem
      
      ‚ä¢ ‚àÄx y. (x = y) ‚áî ‚àÄi. i &lt; dimindex (:Œ≤) ‚áí (x ' i = y ' i)
   
   [<a name="DIMINDEX_GE_1-val"><b>DIMINDEX_GE_1</b></a>]  Theorem
      
      ‚ä¢ 1 ‚â§ dimindex (:Œ±)
   
   [<a name="EL_V2L-val"><b>EL_V2L</b></a>]  Theorem
      
      ‚ä¢ ‚àÄi v. i &lt; dimindex (:Œ≤) ‚áí (EL i (V2L v) = v ' i)
   
   [<a name="FCP_APPLY_UPDATE_THM-val"><b>FCP_APPLY_UPDATE_THM</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm a w b.
            (a :+ w) m ' b =
            if b &lt; dimindex (:Œ≤) then if a = b then w else m ' b
            else FAIL $' index out of range ((a :+ w) m) b
   
   [<a name="FCP_BETA-val"><b>FCP_BETA</b></a>]  Theorem
      
      ‚ä¢ ‚àÄi. i &lt; dimindex (:Œ≤) ‚áí ($FCP g ' i = g i)
   
   [<a name="FCP_CONS-val"><b>FCP_CONS</b></a>]  Theorem
      
      ‚ä¢ ‚àÄa v. FCP_CONS a v = L2V (a::V2L v)
   
   [<a name="FCP_ETA-val"><b>FCP_ETA</b></a>]  Theorem
      
      ‚ä¢ ‚àÄg. (FCP i. g ' i) = g
   
   [<a name="FCP_EVERY-val"><b>FCP_EVERY</b></a>]  Theorem
      
      ‚ä¢ ‚àÄP v. FCP_EVERY P v ‚áî EVERY P (V2L v)
   
   [<a name="FCP_EXISTS-val"><b>FCP_EXISTS</b></a>]  Theorem
      
      ‚ä¢ ‚àÄP v. FCP_EXISTS P v ‚áî EXISTS P (V2L v)
   
   [<a name="FCP_HD-val"><b>FCP_HD</b></a>]  Theorem
      
      ‚ä¢ ‚àÄv. FCP_HD v = HD (V2L v)
   
   [<a name="FCP_MAP-val"><b>FCP_MAP</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf v. FCP_MAP f v = L2V (MAP f (V2L v))
   
   [<a name="FCP_TL-val"><b>FCP_TL</b></a>]  Theorem
      
      ‚ä¢ ‚àÄv.
            1 &lt; dimindex (:Œ≤) ‚àß (dimindex (:Œ≥) = dimindex (:Œ≤) ‚àí 1) ‚áí
            (FCP_TL v = L2V (TL (V2L v)))
   
   [<a name="FCP_UNIQUE-val"><b>FCP_UNIQUE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g. (‚àÄi. i &lt; dimindex (:Œ≤) ‚áí (f ' i = g i)) ‚áî ($FCP g = f)
   
   [<a name="FCP_UPDATE_COMMUTES-val"><b>FCP_UPDATE_COMMUTES</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm a b c d. a ‚â† b ‚áí ((a :+ c) ((b :+ d) m) = (b :+ d) ((a :+ c) m))
   
   [<a name="FCP_UPDATE_EQ-val"><b>FCP_UPDATE_EQ</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm a b c. (a :+ c) ((a :+ b) m) = (a :+ c) m
   
   [<a name="FCP_UPDATE_IMP_ID-val"><b>FCP_UPDATE_IMP_ID</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm a v. (m ' a = v) ‚áí ((a :+ v) m = m)
   
   [<a name="LENGTH_V2L-val"><b>LENGTH_V2L</b></a>]  Theorem
      
      ‚ä¢ ‚àÄv. LENGTH (V2L v) = dimindex (:Œ≤)
   
   [<a name="NOT_FINITE_IMP_dimindex_1-val"><b>NOT_FINITE_IMP_dimindex_1</b></a>]  Theorem
      
      ‚ä¢ INFINITE ùïå(:Œ±) ‚áí (dimindex (:Œ±) = 1)
   
   [<a name="NULL_V2L-val"><b>NULL_V2L</b></a>]  Theorem
      
      ‚ä¢ ‚àÄv. ¬¨NULL (V2L v)
   
   [<a name="READ_L2V-val"><b>READ_L2V</b></a>]  Theorem
      
      ‚ä¢ ‚àÄi a. i &lt; dimindex (:Œ≤) ‚áí (L2V a ' i = EL i a)
   
   [<a name="READ_TL-val"><b>READ_TL</b></a>]  Theorem
      
      ‚ä¢ ‚àÄi a. i &lt; dimindex (:Œ≤) ‚áí (FCP_TL a ' i = a ' (SUC i))
   
   [<a name="V2L_L2V-val"><b>V2L_L2V</b></a>]  Theorem
      
      ‚ä¢ ‚àÄx. (dimindex (:Œ≤) = LENGTH x) ‚áí (V2L (L2V x) = x)
   
   [<a name="bit0_11-val"><b>bit0_11</b></a>]  Theorem
      
      ‚ä¢ (‚àÄa a'. (BIT0A a = BIT0A a') ‚áî (a = a')) ‚àß
        ‚àÄa a'. (BIT0B a = BIT0B a') ‚áî (a = a')
   
   [<a name="bit0_Axiom-val"><b>bit0_Axiom</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf0 f1. ‚àÉfn. (‚àÄa. fn (BIT0A a) = f0 a) ‚àß ‚àÄa. fn (BIT0B a) = f1 a
   
   [<a name="bit0_case_cong-val"><b>bit0_case_cong</b></a>]  Theorem
      
      ‚ä¢ ‚àÄM M' f f1.
            (M = M') ‚àß (‚àÄa. (M' = BIT0A a) ‚áí (f a = f' a)) ‚àß
            (‚àÄa. (M' = BIT0B a) ‚áí (f1 a = f1' a)) ‚áí
            (bit0_CASE M f f1 = bit0_CASE M' f' f1')
   
   [<a name="bit0_case_eq-val"><b>bit0_case_eq</b></a>]  Theorem
      
      ‚ä¢ (bit0_CASE x f f1 = v) ‚áî
        (‚àÉa. (x = BIT0A a) ‚àß (f a = v)) ‚à® ‚àÉa. (x = BIT0B a) ‚àß (f1 a = v)
   
   [<a name="bit0_distinct-val"><b>bit0_distinct</b></a>]  Theorem
      
      ‚ä¢ ‚àÄa' a. BIT0A a ‚â† BIT0B a'
   
   [<a name="bit0_induction-val"><b>bit0_induction</b></a>]  Theorem
      
      ‚ä¢ ‚àÄP. (‚àÄa. P (BIT0A a)) ‚àß (‚àÄa. P (BIT0B a)) ‚áí ‚àÄb. P b
   
   [<a name="bit0_nchotomy-val"><b>bit0_nchotomy</b></a>]  Theorem
      
      ‚ä¢ ‚àÄbb. (‚àÉa. bb = BIT0A a) ‚à® ‚àÉa. bb = BIT0B a
   
   [<a name="bit1_11-val"><b>bit1_11</b></a>]  Theorem
      
      ‚ä¢ (‚àÄa a'. (BIT1A a = BIT1A a') ‚áî (a = a')) ‚àß
        ‚àÄa a'. (BIT1B a = BIT1B a') ‚áî (a = a')
   
   [<a name="bit1_Axiom-val"><b>bit1_Axiom</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf0 f1 f2.
            ‚àÉfn.
                (‚àÄa. fn (BIT1A a) = f0 a) ‚àß (‚àÄa. fn (BIT1B a) = f1 a) ‚àß
                (fn BIT1C = f2)
   
   [<a name="bit1_case_cong-val"><b>bit1_case_cong</b></a>]  Theorem
      
      ‚ä¢ ‚àÄM M' f f1 v.
            (M = M') ‚àß (‚àÄa. (M' = BIT1A a) ‚áí (f a = f' a)) ‚àß
            (‚àÄa. (M' = BIT1B a) ‚áí (f1 a = f1' a)) ‚àß
            ((M' = BIT1C) ‚áí (v = v')) ‚áí
            (bit1_CASE M f f1 v = bit1_CASE M' f' f1' v')
   
   [<a name="bit1_case_eq-val"><b>bit1_case_eq</b></a>]  Theorem
      
      ‚ä¢ (bit1_CASE x f f1 v = v') ‚áî
        (‚àÉa. (x = BIT1A a) ‚àß (f a = v')) ‚à®
        (‚àÉa. (x = BIT1B a) ‚àß (f1 a = v')) ‚à® (x = BIT1C) ‚àß (v = v')
   
   [<a name="bit1_distinct-val"><b>bit1_distinct</b></a>]  Theorem
      
      ‚ä¢ (‚àÄa' a. BIT1A a ‚â† BIT1B a') ‚àß (‚àÄa. BIT1A a ‚â† BIT1C) ‚àß
        ‚àÄa. BIT1B a ‚â† BIT1C
   
   [<a name="bit1_induction-val"><b>bit1_induction</b></a>]  Theorem
      
      ‚ä¢ ‚àÄP. (‚àÄa. P (BIT1A a)) ‚àß (‚àÄa. P (BIT1B a)) ‚àß P BIT1C ‚áí ‚àÄb. P b
   
   [<a name="bit1_nchotomy-val"><b>bit1_nchotomy</b></a>]  Theorem
      
      ‚ä¢ ‚àÄbb. (‚àÉa. bb = BIT1A a) ‚à® (‚àÉa. bb = BIT1B a) ‚à® (bb = BIT1C)
   
   [<a name="card_dimindex-val"><b>card_dimindex</b></a>]  Theorem
      
      ‚ä¢ FINITE ùïå(:Œ±) ‚áí (CARD ùïå(:Œ±) = dimindex (:Œ±))
   
   [<a name="datatype_bit0-val"><b>datatype_bit0</b></a>]  Theorem
      
      ‚ä¢ DATATYPE (bit0 BIT0A BIT0B)
   
   [<a name="datatype_bit1-val"><b>datatype_bit1</b></a>]  Theorem
      
      ‚ä¢ DATATYPE (bit1 BIT1A BIT1B BIT1C)
   
   [<a name="fcp_Axiom-val"><b>fcp_Axiom</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf. ‚àÉg. ‚àÄh. g (mk_cart h) = f h
   
   [<a name="fcp_ind-val"><b>fcp_ind</b></a>]  Theorem
      
      ‚ä¢ ‚àÄP. (‚àÄf. P (mk_cart f)) ‚áí ‚àÄa. P a
   
   [<a name="fcp_subst_comp-val"><b>fcp_subst_comp</b></a>]  Theorem
      
      ‚ä¢ ‚àÄa b f. (x :+ y) ($FCP f) = FCP c. if x = c then y else f c
   
   [<a name="finite_bit0-val"><b>finite_bit0</b></a>]  Theorem
      
      ‚ä¢ FINITE ùïå(:Œ± bit0) ‚áî FINITE ùïå(:Œ±)
   
   [<a name="finite_bit1-val"><b>finite_bit1</b></a>]  Theorem
      
      ‚ä¢ FINITE ùïå(:Œ± bit1) ‚áî FINITE ùïå(:Œ±)
   
   [<a name="finite_one-val"><b>finite_one</b></a>]  Theorem
      
      ‚ä¢ FINITE ùïå(:unit)
   
   [<a name="finite_sum-val"><b>finite_sum</b></a>]  Theorem
      
      ‚ä¢ FINITE ùïå(:Œ± + Œ≤) ‚áî FINITE ùïå(:Œ±) ‚àß FINITE ùïå(:Œ≤)
   
   [<a name="index_bit0-val"><b>index_bit0</b></a>]  Theorem
      
      ‚ä¢ dimindex (:Œ± bit0) = if FINITE ùïå(:Œ±) then 2 * dimindex (:Œ±) else 1
   
   [<a name="index_bit1-val"><b>index_bit1</b></a>]  Theorem
      
      ‚ä¢ dimindex (:Œ± bit1) =
        if FINITE ùïå(:Œ±) then 2 * dimindex (:Œ±) + 1
        else 1
   
   [<a name="index_comp-val"><b>index_comp</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf n.
            $FCP f ' n =
            if n &lt; dimindex (:Œ≤) then f n
            else FAIL $' FCP out of bounds ($FCP f) n
   
   [<a name="index_one-val"><b>index_one</b></a>]  Theorem
      
      ‚ä¢ dimindex (:unit) = 1
   
   [<a name="index_sum-val"><b>index_sum</b></a>]  Theorem
      
      ‚ä¢ dimindex (:Œ± + Œ≤) =
        if FINITE ùïå(:Œ±) ‚àß FINITE ùïå(:Œ≤) then dimindex (:Œ±) + dimindex (:Œ≤)
        else 1
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/n-bit/fcpScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-11</a></em></p></body></html>
