<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure util_probTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure util_probTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/probability/util_probScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature util_probTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#lg_def-val">lg_def</a> : thm
<a name="line7"></a>    val <a href="#logr_def-val">logr_def</a> : thm
<a name="line8"></a>    val <a href="#minimal_def-val">minimal_def</a> : thm
<a name="line9"></a>    val <a href="#pair_def-val">pair_def</a> : thm
<a name="line10"></a>    val <a href="#powr_def-val">powr_def</a> : thm
<a name="line11"></a>    val <a href="#prod_sets_def-val">prod_sets_def</a> : thm
<a name="line12"></a>  
<a name="line13"></a>  (*  Theorems  *)
<a name="line14"></a>    val <a href="#EQ_T_IMP-val">EQ_T_IMP</a> : thm
<a name="line15"></a>    val <a href="#GBIGUNION_IMAGE-val">GBIGUNION_IMAGE</a> : thm
<a name="line16"></a>    val <a href="#HALF_CANCEL-val">HALF_CANCEL</a> : thm
<a name="line17"></a>    val <a href="#HALF_LT_1-val">HALF_LT_1</a> : thm
<a name="line18"></a>    val <a href="#HALF_POS-val">HALF_POS</a> : thm
<a name="line19"></a>    val <a href="#INCREASING_SEQ-val">INCREASING_SEQ</a> : thm
<a name="line20"></a>    val <a href="#INF_CLOSE-val">INF_CLOSE</a> : thm
<a name="line21"></a>    val <a href="#INF_DEF_ALT-val">INF_DEF_ALT</a> : thm
<a name="line22"></a>    val <a href="#INF_GREATER-val">INF_GREATER</a> : thm
<a name="line23"></a>    val <a href="#INF_LE-val">INF_LE</a> : thm
<a name="line24"></a>    val <a href="#IN_PAIR-val">IN_PAIR</a> : thm
<a name="line25"></a>    val <a href="#IN_PROD_SETS-val">IN_PROD_SETS</a> : thm
<a name="line26"></a>    val <a href="#IN_o-val">IN_o</a> : thm
<a name="line27"></a>    val <a href="#K_PARTIAL-val">K_PARTIAL</a> : thm
<a name="line28"></a>    val <a href="#LE_INF-val">LE_INF</a> : thm
<a name="line29"></a>    val <a href="#LE_SUC-val">LE_SUC</a> : thm
<a name="line30"></a>    val <a href="#LT_SUC-val">LT_SUC</a> : thm
<a name="line31"></a>    val <a href="#MAX_LE_X-val">MAX_LE_X</a> : thm
<a name="line32"></a>    val <a href="#MINIMAL_EQ-val">MINIMAL_EQ</a> : thm
<a name="line33"></a>    val <a href="#MINIMAL_EQ_IMP-val">MINIMAL_EQ_IMP</a> : thm
<a name="line34"></a>    val <a href="#MINIMAL_EXISTS-val">MINIMAL_EXISTS</a> : thm
<a name="line35"></a>    val <a href="#MINIMAL_EXISTS0-val">MINIMAL_EXISTS0</a> : thm
<a name="line36"></a>    val <a href="#MINIMAL_EXISTS_IMP-val">MINIMAL_EXISTS_IMP</a> : thm
<a name="line37"></a>    val <a href="#MINIMAL_SUC-val">MINIMAL_SUC</a> : thm
<a name="line38"></a>    val <a href="#MINIMAL_SUC_IMP-val">MINIMAL_SUC_IMP</a> : thm
<a name="line39"></a>    val <a href="#NUM_2D_BIJ-val">NUM_2D_BIJ</a> : thm
<a name="line40"></a>    val <a href="#NUM_2D_BIJ_BIG_SQUARE-val">NUM_2D_BIJ_BIG_SQUARE</a> : thm
<a name="line41"></a>    val <a href="#NUM_2D_BIJ_INV-val">NUM_2D_BIJ_INV</a> : thm
<a name="line42"></a>    val <a href="#NUM_2D_BIJ_NZ-val">NUM_2D_BIJ_NZ</a> : thm
<a name="line43"></a>    val <a href="#NUM_2D_BIJ_NZ_ALT-val">NUM_2D_BIJ_NZ_ALT</a> : thm
<a name="line44"></a>    val <a href="#NUM_2D_BIJ_NZ_ALT2-val">NUM_2D_BIJ_NZ_ALT2</a> : thm
<a name="line45"></a>    val <a href="#NUM_2D_BIJ_NZ_ALT2_INV-val">NUM_2D_BIJ_NZ_ALT2_INV</a> : thm
<a name="line46"></a>    val <a href="#NUM_2D_BIJ_NZ_ALT_INV-val">NUM_2D_BIJ_NZ_ALT_INV</a> : thm
<a name="line47"></a>    val <a href="#NUM_2D_BIJ_NZ_INV-val">NUM_2D_BIJ_NZ_INV</a> : thm
<a name="line48"></a>    val <a href="#NUM_2D_BIJ_SMALL_SQUARE-val">NUM_2D_BIJ_SMALL_SQUARE</a> : thm
<a name="line49"></a>    val <a href="#ONE_MINUS_HALF-val">ONE_MINUS_HALF</a> : thm
<a name="line50"></a>    val <a href="#PAIRED_BETA_THM-val">PAIRED_BETA_THM</a> : thm
<a name="line51"></a>    val <a href="#PAIR_UNIV-val">PAIR_UNIV</a> : thm
<a name="line52"></a>    val <a href="#POS_SUMMABLE-val">POS_SUMMABLE</a> : thm
<a name="line53"></a>    val <a href="#POW_HALF_MONO-val">POW_HALF_MONO</a> : thm
<a name="line54"></a>    val <a href="#POW_HALF_POS-val">POW_HALF_POS</a> : thm
<a name="line55"></a>    val <a href="#POW_HALF_SER-val">POW_HALF_SER</a> : thm
<a name="line56"></a>    val <a href="#POW_HALF_SMALL-val">POW_HALF_SMALL</a> : thm
<a name="line57"></a>    val <a href="#PREIMAGE_REAL_COMPL1-val">PREIMAGE_REAL_COMPL1</a> : thm
<a name="line58"></a>    val <a href="#PREIMAGE_REAL_COMPL2-val">PREIMAGE_REAL_COMPL2</a> : thm
<a name="line59"></a>    val <a href="#PREIMAGE_REAL_COMPL3-val">PREIMAGE_REAL_COMPL3</a> : thm
<a name="line60"></a>    val <a href="#PREIMAGE_REAL_COMPL4-val">PREIMAGE_REAL_COMPL4</a> : thm
<a name="line61"></a>    val <a href="#REAL_LE_LT_MUL-val">REAL_LE_LT_MUL</a> : thm
<a name="line62"></a>    val <a href="#REAL_LT_LE_MUL-val">REAL_LT_LE_MUL</a> : thm
<a name="line63"></a>    val <a href="#REAL_MUL_IDEMPOT-val">REAL_MUL_IDEMPOT</a> : thm
<a name="line64"></a>    val <a href="#REAL_SUP_LE_X-val">REAL_SUP_LE_X</a> : thm
<a name="line65"></a>    val <a href="#REAL_X_LE_SUP-val">REAL_X_LE_SUP</a> : thm
<a name="line66"></a>    val <a href="#SEQ_SANDWICH-val">SEQ_SANDWICH</a> : thm
<a name="line67"></a>    val <a href="#SER_POS-val">SER_POS</a> : thm
<a name="line68"></a>    val <a href="#SER_POS_COMPARE-val">SER_POS_COMPARE</a> : thm
<a name="line69"></a>    val <a href="#SER_POS_MONO-val">SER_POS_MONO</a> : thm
<a name="line70"></a>    val <a href="#SUMINF_2D-val">SUMINF_2D</a> : thm
<a name="line71"></a>    val <a href="#SUMINF_ADD-val">SUMINF_ADD</a> : thm
<a name="line72"></a>    val <a href="#SUMINF_POS-val">SUMINF_POS</a> : thm
<a name="line73"></a>    val <a href="#SUMMABLE_LE-val">SUMMABLE_LE</a> : thm
<a name="line74"></a>    val <a href="#SUMS_EQ-val">SUMS_EQ</a> : thm
<a name="line75"></a>    val <a href="#SUMS_ZERO-val">SUMS_ZERO</a> : thm
<a name="line76"></a>    val <a href="#SUM_CONST_R-val">SUM_CONST_R</a> : thm
<a name="line77"></a>    val <a href="#SUM_LT-val">SUM_LT</a> : thm
<a name="line78"></a>    val <a href="#SUM_PICK-val">SUM_PICK</a> : thm
<a name="line79"></a>    val <a href="#TRANSFORM_2D_NUM-val">TRANSFORM_2D_NUM</a> : thm
<a name="line80"></a>    val <a href="#TRIANGLE_2D_NUM-val">TRIANGLE_2D_NUM</a> : thm
<a name="line81"></a>    val <a href="#X_HALF_HALF-val">X_HALF_HALF</a> : thm
<a name="line82"></a>    val <a href="#X_LE_MAX-val">X_LE_MAX</a> : thm
<a name="line83"></a>    val <a href="#finite_enumeration_of_sets_has_max_non_empty-val">finite_enumeration_of_sets_has_max_non_empty</a> : thm
<a name="line84"></a>    val <a href="#lg_1-val">lg_1</a> : thm
<a name="line85"></a>    val <a href="#lg_2-val">lg_2</a> : thm
<a name="line86"></a>    val <a href="#lg_inv-val">lg_inv</a> : thm
<a name="line87"></a>    val <a href="#lg_mul-val">lg_mul</a> : thm
<a name="line88"></a>    val <a href="#lg_nonzero-val">lg_nonzero</a> : thm
<a name="line89"></a>    val <a href="#lg_pow-val">lg_pow</a> : thm
<a name="line90"></a>    val <a href="#logr_1-val">logr_1</a> : thm
<a name="line91"></a>    val <a href="#logr_div-val">logr_div</a> : thm
<a name="line92"></a>    val <a href="#logr_inv-val">logr_inv</a> : thm
<a name="line93"></a>    val <a href="#logr_mul-val">logr_mul</a> : thm
<a name="line94"></a>    val <a href="#neg_lg-val">neg_lg</a> : thm
<a name="line95"></a>    val <a href="#neg_logr-val">neg_logr</a> : thm
<a name="line96"></a>  
<a name="line97"></a>  val util_prob_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line98"></a>(*
   [real_sigma] Parent theory of "util_prob"
   
   [<a name="lg_def-val"><b>lg_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄx. lg x = logr 2 x
   
   [<a name="logr_def-val"><b>logr_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄa x. logr a x = ln x / ln a
   
   [<a name="minimal_def-val"><b>minimal_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄp. minimal p = @n. p n ‚àß ‚àÄm. m &lt; n ‚áí ¬¨p m
   
   [<a name="pair_def-val"><b>pair_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄX Y. pair X Y = (Œª(x,y). x ‚àà X ‚àß y ‚àà Y)
   
   [<a name="powr_def-val"><b>powr_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄx a. x powr a = exp (a * ln x)
   
   [<a name="prod_sets_def-val"><b>prod_sets_def</b></a>]  Definition
      
      ‚ä¢ ‚àÄa b. prod_sets a b = {s √ó t | s ‚àà a ‚àß t ‚àà b}
   
   [<a name="EQ_T_IMP-val"><b>EQ_T_IMP</b></a>]  Theorem
      
      ‚ä¢ ‚àÄx. x ‚áî T ‚áí x
   
   [<a name="GBIGUNION_IMAGE-val"><b>GBIGUNION_IMAGE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs p n. {s | ‚àÉn. p s n} = BIGUNION (IMAGE (Œªn. {s | p s n}) ùïå(:Œ≥))
   
   [<a name="HALF_CANCEL-val"><b>HALF_CANCEL</b></a>]  Theorem
      
      ‚ä¢ 2 * (1 / 2) = 1
   
   [<a name="HALF_LT_1-val"><b>HALF_LT_1</b></a>]  Theorem
      
      ‚ä¢ 1 / 2 &lt; 1
   
   [<a name="HALF_POS-val"><b>HALF_POS</b></a>]  Theorem
      
      ‚ä¢ 0 &lt; 1 / 2
   
   [<a name="INCREASING_SEQ-val"><b>INCREASING_SEQ</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf l.
            (‚àÄn. f n ‚â§ f (SUC n)) ‚àß (‚àÄn. f n ‚â§ l) ‚àß
            (‚àÄe. 0 &lt; e ‚áí ‚àÉn. l &lt; f n + e) ‚áí
            f --&gt; l
   
   [<a name="INF_CLOSE-val"><b>INF_CLOSE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄp e. (‚àÉx. x ‚àà p) ‚àß 0 &lt; e ‚áí ‚àÉx. x ‚àà p ‚àß x &lt; inf p + e
   
   [<a name="INF_DEF_ALT-val"><b>INF_DEF_ALT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄp. inf p = -sup (Œªr. -r ‚àà p)
   
   [<a name="INF_GREATER-val"><b>INF_GREATER</b></a>]  Theorem
      
      ‚ä¢ ‚àÄp z. (‚àÉx. x ‚àà p) ‚àß inf p &lt; z ‚áí ‚àÉx. x ‚àà p ‚àß x &lt; z
   
   [<a name="INF_LE-val"><b>INF_LE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄp r. (‚àÉz. ‚àÄx. x ‚àà p ‚áí z ‚â§ x) ‚àß (‚àÉx. x ‚àà p ‚àß x ‚â§ r) ‚áí inf p ‚â§ r
   
   [<a name="IN_PAIR-val"><b>IN_PAIR</b></a>]  Theorem
      
      ‚ä¢ ‚àÄx X Y. x ‚àà pair X Y ‚áî FST x ‚àà X ‚àß SND x ‚àà Y
   
   [<a name="IN_PROD_SETS-val"><b>IN_PROD_SETS</b></a>]  Theorem
      
      ‚ä¢ ‚àÄs a b. s ‚àà prod_sets a b ‚áî ‚àÉt u. (s = t √ó u) ‚àß t ‚àà a ‚àß u ‚àà b
   
   [<a name="IN_o-val"><b>IN_o</b></a>]  Theorem
      
      ‚ä¢ ‚àÄx f s. x ‚àà s ‚àò f ‚áî f x ‚àà s
   
   [<a name="K_PARTIAL-val"><b>K_PARTIAL</b></a>]  Theorem
      
      ‚ä¢ ‚àÄx. K x = (Œªz. x)
   
   [<a name="LE_INF-val"><b>LE_INF</b></a>]  Theorem
      
      ‚ä¢ ‚àÄp r. (‚àÉx. x ‚àà p) ‚àß (‚àÄx. x ‚àà p ‚áí r ‚â§ x) ‚áí r ‚â§ inf p
   
   [<a name="LE_SUC-val"><b>LE_SUC</b></a>]  Theorem
      
      ‚ä¢ ‚àÄa b. a ‚â§ SUC b ‚áî a ‚â§ b ‚à® (a = SUC b)
   
   [<a name="LT_SUC-val"><b>LT_SUC</b></a>]  Theorem
      
      ‚ä¢ ‚àÄa b. a &lt; SUC b ‚áî a &lt; b ‚à® (a = b)
   
   [<a name="MAX_LE_X-val"><b>MAX_LE_X</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm n k. MAX m n ‚â§ k ‚áî m ‚â§ k ‚àß n ‚â§ k
   
   [<a name="MINIMAL_EQ-val"><b>MINIMAL_EQ</b></a>]  Theorem
      
      ‚ä¢ ‚àÄp m. p m ‚àß (m = minimal p) ‚áî p m ‚àß ‚àÄn. n &lt; m ‚áí ¬¨p n
   
   [<a name="MINIMAL_EQ_IMP-val"><b>MINIMAL_EQ_IMP</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm p. p m ‚àß (‚àÄn. n &lt; m ‚áí ¬¨p n) ‚áí (m = minimal p)
   
   [<a name="MINIMAL_EXISTS-val"><b>MINIMAL_EXISTS</b></a>]  Theorem
      
      ‚ä¢ ‚àÄP. (‚àÉn. P n) ‚áî P (minimal P) ‚àß ‚àÄn. n &lt; minimal P ‚áí ¬¨P n
   
   [<a name="MINIMAL_EXISTS0-val"><b>MINIMAL_EXISTS0</b></a>]  Theorem
      
      ‚ä¢ (‚àÉn. P n) ‚áî ‚àÉn. P n ‚àß ‚àÄm. m &lt; n ‚áí ¬¨P m
   
   [<a name="MINIMAL_EXISTS_IMP-val"><b>MINIMAL_EXISTS_IMP</b></a>]  Theorem
      
      ‚ä¢ ‚àÄP. (‚àÉn. P n) ‚áí ‚àÉm. P m ‚àß ‚àÄn. n &lt; m ‚áí ¬¨P n
   
   [<a name="MINIMAL_SUC-val"><b>MINIMAL_SUC</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn p.
            (SUC n = minimal p) ‚àß p (SUC n) ‚áî
            ¬¨p 0 ‚àß (n = minimal (p ‚àò SUC)) ‚àß p (SUC n)
   
   [<a name="MINIMAL_SUC_IMP-val"><b>MINIMAL_SUC_IMP</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn p.
            p (SUC n) ‚àß ¬¨p 0 ‚àß (n = minimal (p ‚àò SUC)) ‚áí
            (SUC n = minimal p)
   
   [<a name="NUM_2D_BIJ-val"><b>NUM_2D_BIJ</b></a>]  Theorem
      
      ‚ä¢ ‚àÉf. BIJ f (ùïå(:num) √ó ùïå(:num)) ùïå(:num)
   
   [<a name="NUM_2D_BIJ_BIG_SQUARE-val"><b>NUM_2D_BIJ_BIG_SQUARE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf N.
            BIJ f ùïå(:num) (ùïå(:num) √ó ùïå(:num)) ‚áí
            ‚àÉk. IMAGE f (count N) ‚äÜ count k √ó count k
   
   [<a name="NUM_2D_BIJ_INV-val"><b>NUM_2D_BIJ_INV</b></a>]  Theorem
      
      ‚ä¢ ‚àÉf. BIJ f ùïå(:num) (ùïå(:num) √ó ùïå(:num))
   
   [<a name="NUM_2D_BIJ_NZ-val"><b>NUM_2D_BIJ_NZ</b></a>]  Theorem
      
      ‚ä¢ ‚àÉf. BIJ f (ùïå(:num) √ó (ùïå(:num) DIFF {0})) ùïå(:num)
   
   [<a name="NUM_2D_BIJ_NZ_ALT-val"><b>NUM_2D_BIJ_NZ_ALT</b></a>]  Theorem
      
      ‚ä¢ ‚àÉf. BIJ f (ùïå(:num) √ó ùïå(:num)) (ùïå(:num) DIFF {0})
   
   [<a name="NUM_2D_BIJ_NZ_ALT2-val"><b>NUM_2D_BIJ_NZ_ALT2</b></a>]  Theorem
      
      ‚ä¢ ‚àÉf. BIJ f ((ùïå(:num) DIFF {0}) √ó (ùïå(:num) DIFF {0})) ùïå(:num)
   
   [<a name="NUM_2D_BIJ_NZ_ALT2_INV-val"><b>NUM_2D_BIJ_NZ_ALT2_INV</b></a>]  Theorem
      
      ‚ä¢ ‚àÉf. BIJ f ùïå(:num) ((ùïå(:num) DIFF {0}) √ó (ùïå(:num) DIFF {0}))
   
   [<a name="NUM_2D_BIJ_NZ_ALT_INV-val"><b>NUM_2D_BIJ_NZ_ALT_INV</b></a>]  Theorem
      
      ‚ä¢ ‚àÉf. BIJ f (ùïå(:num) DIFF {0}) (ùïå(:num) √ó ùïå(:num))
   
   [<a name="NUM_2D_BIJ_NZ_INV-val"><b>NUM_2D_BIJ_NZ_INV</b></a>]  Theorem
      
      ‚ä¢ ‚àÉf. BIJ f ùïå(:num) (ùïå(:num) √ó (ùïå(:num) DIFF {0}))
   
   [<a name="NUM_2D_BIJ_SMALL_SQUARE-val"><b>NUM_2D_BIJ_SMALL_SQUARE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf k.
            BIJ f ùïå(:num) (ùïå(:num) √ó ùïå(:num)) ‚áí
            ‚àÉN. count k √ó count k ‚äÜ IMAGE f (count N)
   
   [<a name="ONE_MINUS_HALF-val"><b>ONE_MINUS_HALF</b></a>]  Theorem
      
      ‚ä¢ 1 ‚àí 1 / 2 = 1 / 2
   
   [<a name="PAIRED_BETA_THM-val"><b>PAIRED_BETA_THM</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf z. UNCURRY f z = f (FST z) (SND z)
   
   [<a name="PAIR_UNIV-val"><b>PAIR_UNIV</b></a>]  Theorem
      
      ‚ä¢ pair ùïå(:Œ±) ùïå(:Œ≤) = ùïå(:Œ± # Œ≤)
   
   [<a name="POS_SUMMABLE-val"><b>POS_SUMMABLE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf. (‚àÄn. 0 ‚â§ f n) ‚àß (‚àÉx. ‚àÄn. sum (0,n) f ‚â§ x) ‚áí summable f
   
   [<a name="POW_HALF_MONO-val"><b>POW_HALF_MONO</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm n. m ‚â§ n ‚áí (1 / 2) pow n ‚â§ (1 / 2) pow m
   
   [<a name="POW_HALF_POS-val"><b>POW_HALF_POS</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. 0 &lt; (1 / 2) pow n
   
   [<a name="POW_HALF_SER-val"><b>POW_HALF_SER</b></a>]  Theorem
      
      ‚ä¢ (Œªn. (1 / 2) pow (n + 1)) sums 1
   
   [<a name="POW_HALF_SMALL-val"><b>POW_HALF_SMALL</b></a>]  Theorem
      
      ‚ä¢ ‚àÄe. 0 &lt; e ‚áí ‚àÉn. (1 / 2) pow n &lt; e
   
   [<a name="PREIMAGE_REAL_COMPL1-val"><b>PREIMAGE_REAL_COMPL1</b></a>]  Theorem
      
      ‚ä¢ ‚àÄc. COMPL {x | c &lt; x} = {x | x ‚â§ c}
   
   [<a name="PREIMAGE_REAL_COMPL2-val"><b>PREIMAGE_REAL_COMPL2</b></a>]  Theorem
      
      ‚ä¢ ‚àÄc. COMPL {x | c ‚â§ x} = {x | x &lt; c}
   
   [<a name="PREIMAGE_REAL_COMPL3-val"><b>PREIMAGE_REAL_COMPL3</b></a>]  Theorem
      
      ‚ä¢ ‚àÄc. COMPL {x | x ‚â§ c} = {x | c &lt; x}
   
   [<a name="PREIMAGE_REAL_COMPL4-val"><b>PREIMAGE_REAL_COMPL4</b></a>]  Theorem
      
      ‚ä¢ ‚àÄc. COMPL {x | x &lt; c} = {x | c ‚â§ x}
   
   [<a name="REAL_LE_LT_MUL-val"><b>REAL_LE_LT_MUL</b></a>]  Theorem
      
      ‚ä¢ ‚àÄx y. 0 ‚â§ x ‚àß 0 &lt; y ‚áí 0 ‚â§ x * y
   
   [<a name="REAL_LT_LE_MUL-val"><b>REAL_LT_LE_MUL</b></a>]  Theorem
      
      ‚ä¢ ‚àÄx y. 0 &lt; x ‚àß 0 ‚â§ y ‚áí 0 ‚â§ x * y
   
   [<a name="REAL_MUL_IDEMPOT-val"><b>REAL_MUL_IDEMPOT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄr. (r * r = r) ‚áî (r = 0) ‚à® (r = 1)
   
   [<a name="REAL_SUP_LE_X-val"><b>REAL_SUP_LE_X</b></a>]  Theorem
      
      ‚ä¢ ‚àÄP x. (‚àÉr. P r) ‚àß (‚àÄr. P r ‚áí r ‚â§ x) ‚áí sup P ‚â§ x
   
   [<a name="REAL_X_LE_SUP-val"><b>REAL_X_LE_SUP</b></a>]  Theorem
      
      ‚ä¢ ‚àÄP x.
            (‚àÉr. P r) ‚àß (‚àÉz. ‚àÄr. P r ‚áí r ‚â§ z) ‚àß (‚àÉr. P r ‚àß x ‚â§ r) ‚áí
            x ‚â§ sup P
   
   [<a name="SEQ_SANDWICH-val"><b>SEQ_SANDWICH</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g h l. f --&gt; l ‚àß h --&gt; l ‚àß (‚àÄn. f n ‚â§ g n ‚àß g n ‚â§ h n) ‚áí g --&gt; l
   
   [<a name="SER_POS-val"><b>SER_POS</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf. summable f ‚àß (‚àÄn. 0 ‚â§ f n) ‚áí 0 ‚â§ suminf f
   
   [<a name="SER_POS_COMPARE-val"><b>SER_POS_COMPARE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g.
            (‚àÄn. 0 ‚â§ f n) ‚àß summable g ‚àß (‚àÄn. f n ‚â§ g n) ‚áí
            summable f ‚àß suminf f ‚â§ suminf g
   
   [<a name="SER_POS_MONO-val"><b>SER_POS_MONO</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf. (‚àÄn. 0 ‚â§ f n) ‚áí mono (Œªn. sum (0,n) f)
   
   [<a name="SUMINF_2D-val"><b>SUMINF_2D</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g h.
            (‚àÄm n. 0 ‚â§ f m n) ‚àß (‚àÄn. f n sums g n) ‚àß summable g ‚àß
            BIJ h ùïå(:num) (ùïå(:num) √ó ùïå(:num)) ‚áí
            UNCURRY f ‚àò h sums suminf g
   
   [<a name="SUMINF_ADD-val"><b>SUMINF_ADD</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g.
            summable f ‚àß summable g ‚áí
            summable (Œªn. f n + g n) ‚àß
            (suminf f + suminf g = suminf (Œªn. f n + g n))
   
   [<a name="SUMINF_POS-val"><b>SUMINF_POS</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf. (‚àÄn. 0 ‚â§ f n) ‚àß summable f ‚áí 0 ‚â§ suminf f
   
   [<a name="SUMMABLE_LE-val"><b>SUMMABLE_LE</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf x. summable f ‚àß (‚àÄn. sum (0,n) f ‚â§ x) ‚áí suminf f ‚â§ x
   
   [<a name="SUMS_EQ-val"><b>SUMS_EQ</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf x. f sums x ‚áî summable f ‚àß (suminf f = x)
   
   [<a name="SUMS_ZERO-val"><b>SUMS_ZERO</b></a>]  Theorem
      
      ‚ä¢ K 0 sums 0
   
   [<a name="SUM_CONST_R-val"><b>SUM_CONST_R</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn r. sum (0,n) (K r) = &n * r
   
   [<a name="SUM_LT-val"><b>SUM_LT</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf g m n.
            (‚àÄr. m ‚â§ r ‚àß r &lt; n + m ‚áí f r &lt; g r) ‚àß 0 &lt; n ‚áí
            sum (m,n) f &lt; sum (m,n) g
   
   [<a name="SUM_PICK-val"><b>SUM_PICK</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn k x.
            sum (0,n) (Œªm. if m = k then x else 0) = if k &lt; n then x else 0
   
   [<a name="TRANSFORM_2D_NUM-val"><b>TRANSFORM_2D_NUM</b></a>]  Theorem
      
      ‚ä¢ ‚àÄP. (‚àÄm n. P m n ‚áí P n m) ‚àß (‚àÄm n. P m (m + n)) ‚áí ‚àÄm n. P m n
   
   [<a name="TRIANGLE_2D_NUM-val"><b>TRIANGLE_2D_NUM</b></a>]  Theorem
      
      ‚ä¢ ‚àÄP. (‚àÄd n. P n (d + n)) ‚áí ‚àÄm n. m ‚â§ n ‚áí P m n
   
   [<a name="X_HALF_HALF-val"><b>X_HALF_HALF</b></a>]  Theorem
      
      ‚ä¢ ‚àÄx. 1 / 2 * x + 1 / 2 * x = x
   
   [<a name="X_LE_MAX-val"><b>X_LE_MAX</b></a>]  Theorem
      
      ‚ä¢ ‚àÄm n k. k ‚â§ MAX m n ‚áî k ‚â§ m ‚à® k ‚â§ n
   
   [<a name="finite_enumeration_of_sets_has_max_non_empty-val"><b>finite_enumeration_of_sets_has_max_non_empty</b></a>]  Theorem
      
      ‚ä¢ ‚àÄf s.
            FINITE s ‚àß (‚àÄx. f x ‚àà s) ‚àß (‚àÄm n. m ‚â† n ‚áí DISJOINT (f m) (f n)) ‚áí
            ‚àÉN. ‚àÄn. n ‚â• N ‚áí (f n = ‚àÖ)
   
   [<a name="lg_1-val"><b>lg_1</b></a>]  Theorem
      
      ‚ä¢ lg 1 = 0
   
   [<a name="lg_2-val"><b>lg_2</b></a>]  Theorem
      
      ‚ä¢ lg 2 = 1
   
   [<a name="lg_inv-val"><b>lg_inv</b></a>]  Theorem
      
      ‚ä¢ ‚àÄx. 0 &lt; x ‚áí (lg x‚Åª¬π = -lg x)
   
   [<a name="lg_mul-val"><b>lg_mul</b></a>]  Theorem
      
      ‚ä¢ ‚àÄx y. 0 &lt; x ‚àß 0 &lt; y ‚áí (lg (x * y) = lg x + lg y)
   
   [<a name="lg_nonzero-val"><b>lg_nonzero</b></a>]  Theorem
      
      ‚ä¢ ‚àÄx. x ‚â† 0 ‚àß 0 ‚â§ x ‚áí (lg x ‚â† 0 ‚áî x ‚â† 1)
   
   [<a name="lg_pow-val"><b>lg_pow</b></a>]  Theorem
      
      ‚ä¢ ‚àÄn. lg (2 pow n) = &n
   
   [<a name="logr_1-val"><b>logr_1</b></a>]  Theorem
      
      ‚ä¢ ‚àÄb. logr b 1 = 0
   
   [<a name="logr_div-val"><b>logr_div</b></a>]  Theorem
      
      ‚ä¢ ‚àÄb x y. 0 &lt; x ‚àß 0 &lt; y ‚áí (logr b (x / y) = logr b x ‚àí logr b y)
   
   [<a name="logr_inv-val"><b>logr_inv</b></a>]  Theorem
      
      ‚ä¢ ‚àÄb x. 0 &lt; x ‚áí (logr b x‚Åª¬π = -logr b x)
   
   [<a name="logr_mul-val"><b>logr_mul</b></a>]  Theorem
      
      ‚ä¢ ‚àÄb x y. 0 &lt; x ‚àß 0 &lt; y ‚áí (logr b (x * y) = logr b x + logr b y)
   
   [<a name="neg_lg-val"><b>neg_lg</b></a>]  Theorem
      
      ‚ä¢ ‚àÄx. 0 &lt; x ‚áí (-lg x = lg x‚Åª¬π)
   
   [<a name="neg_logr-val"><b>neg_logr</b></a>]  Theorem
      
      ‚ä¢ ‚àÄb x. 0 &lt; x ‚áí (-logr b x = logr b x‚Åª¬π)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/probability/util_probScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-11</a></em></p></body></html>
