<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure EncodeTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure EncodeTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/Boolify/src/EncodeScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature EncodeTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#biprefix_def-val">biprefix_def</a> : thm
<a name="line7"></a>    val <a href="#collision_free_def-val">collision_free_def</a> : thm
<a name="line8"></a>    val <a href="#encode_blist_def-val">encode_blist_def</a> : thm
<a name="line9"></a>    val <a href="#encode_bnum_def-val">encode_bnum_def</a> : thm
<a name="line10"></a>    val <a href="#encode_bool_def-val">encode_bool_def</a> : thm
<a name="line11"></a>    val <a href="#encode_list_def-val">encode_list_def</a> : thm
<a name="line12"></a>    val <a href="#encode_num_primitive_def-val">encode_num_primitive_def</a> : thm
<a name="line13"></a>    val <a href="#encode_option_def-val">encode_option_def</a> : thm
<a name="line14"></a>    val <a href="#encode_prod_def-val">encode_prod_def</a> : thm
<a name="line15"></a>    val <a href="#encode_sum_def-val">encode_sum_def</a> : thm
<a name="line16"></a>    val <a href="#encode_unit_def-val">encode_unit_def</a> : thm
<a name="line17"></a>    val <a href="#lift_blist_def-val">lift_blist_def</a> : thm
<a name="line18"></a>    val <a href="#lift_option_def-val">lift_option_def</a> : thm
<a name="line19"></a>    val <a href="#lift_prod_def-val">lift_prod_def</a> : thm
<a name="line20"></a>    val <a href="#lift_sum_def-val">lift_sum_def</a> : thm
<a name="line21"></a>    val <a href="#tree_TY_DEF-val">tree_TY_DEF</a> : thm
<a name="line22"></a>    val <a href="#tree_case_def-val">tree_case_def</a> : thm
<a name="line23"></a>    val <a href="#tree_size_def-val">tree_size_def</a> : thm
<a name="line24"></a>    val <a href="#wf_encoder_def-val">wf_encoder_def</a> : thm
<a name="line25"></a>    val <a href="#wf_pred_bnum_def-val">wf_pred_bnum_def</a> : thm
<a name="line26"></a>    val <a href="#wf_pred_def-val">wf_pred_def</a> : thm
<a name="line27"></a>  
<a name="line28"></a>  (*  Theorems  *)
<a name="line29"></a>    val <a href="#biprefix_append-val">biprefix_append</a> : thm
<a name="line30"></a>    val <a href="#biprefix_appends-val">biprefix_appends</a> : thm
<a name="line31"></a>    val <a href="#biprefix_cons-val">biprefix_cons</a> : thm
<a name="line32"></a>    val <a href="#biprefix_refl-val">biprefix_refl</a> : thm
<a name="line33"></a>    val <a href="#biprefix_sym-val">biprefix_sym</a> : thm
<a name="line34"></a>    val <a href="#datatype_tree-val">datatype_tree</a> : thm
<a name="line35"></a>    val <a href="#encode_blist_def_compute-val">encode_blist_def_compute</a> : thm
<a name="line36"></a>    val <a href="#encode_bnum_def_compute-val">encode_bnum_def_compute</a> : thm
<a name="line37"></a>    val <a href="#encode_bnum_inj-val">encode_bnum_inj</a> : thm
<a name="line38"></a>    val <a href="#encode_bnum_length-val">encode_bnum_length</a> : thm
<a name="line39"></a>    val <a href="#encode_list_cong-val">encode_list_cong</a> : thm
<a name="line40"></a>    val <a href="#encode_num_def-val">encode_num_def</a> : thm
<a name="line41"></a>    val <a href="#encode_num_ind-val">encode_num_ind</a> : thm
<a name="line42"></a>    val <a href="#encode_prod_alt-val">encode_prod_alt</a> : thm
<a name="line43"></a>    val <a href="#encode_tree_def-val">encode_tree_def</a> : thm
<a name="line44"></a>    val <a href="#lift_blist_suc-val">lift_blist_suc</a> : thm
<a name="line45"></a>    val <a href="#lift_tree_def-val">lift_tree_def</a> : thm
<a name="line46"></a>    val <a href="#tree_11-val">tree_11</a> : thm
<a name="line47"></a>    val <a href="#tree_Axiom-val">tree_Axiom</a> : thm
<a name="line48"></a>    val <a href="#tree_case_cong-val">tree_case_cong</a> : thm
<a name="line49"></a>    val <a href="#tree_case_eq-val">tree_case_eq</a> : thm
<a name="line50"></a>    val <a href="#tree_ind-val">tree_ind</a> : thm
<a name="line51"></a>    val <a href="#tree_induction-val">tree_induction</a> : thm
<a name="line52"></a>    val <a href="#tree_nchotomy-val">tree_nchotomy</a> : thm
<a name="line53"></a>    val <a href="#wf_encode_blist-val">wf_encode_blist</a> : thm
<a name="line54"></a>    val <a href="#wf_encode_bnum-val">wf_encode_bnum</a> : thm
<a name="line55"></a>    val <a href="#wf_encode_bnum_collision_free-val">wf_encode_bnum_collision_free</a> : thm
<a name="line56"></a>    val <a href="#wf_encode_bool-val">wf_encode_bool</a> : thm
<a name="line57"></a>    val <a href="#wf_encode_list-val">wf_encode_list</a> : thm
<a name="line58"></a>    val <a href="#wf_encode_num-val">wf_encode_num</a> : thm
<a name="line59"></a>    val <a href="#wf_encode_option-val">wf_encode_option</a> : thm
<a name="line60"></a>    val <a href="#wf_encode_prod-val">wf_encode_prod</a> : thm
<a name="line61"></a>    val <a href="#wf_encode_sum-val">wf_encode_sum</a> : thm
<a name="line62"></a>    val <a href="#wf_encode_tree-val">wf_encode_tree</a> : thm
<a name="line63"></a>    val <a href="#wf_encode_unit-val">wf_encode_unit</a> : thm
<a name="line64"></a>    val <a href="#wf_encoder_alt-val">wf_encoder_alt</a> : thm
<a name="line65"></a>    val <a href="#wf_encoder_eq-val">wf_encoder_eq</a> : thm
<a name="line66"></a>    val <a href="#wf_encoder_total-val">wf_encoder_total</a> : thm
<a name="line67"></a>    val <a href="#wf_pred_bnum-val">wf_pred_bnum</a> : thm
<a name="line68"></a>    val <a href="#wf_pred_bnum_total-val">wf_pred_bnum_total</a> : thm
<a name="line69"></a>  
<a name="line70"></a>  val Encode_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line71"></a>(*
   [indexedLists] Parent theory of "Encode"
   
   [patternMatches] Parent theory of "Encode"
   
   [<a name="biprefix_def-val"><b>biprefix_def</b></a>]  Definition
      
      ⊢ ∀a b. biprefix a b ⇔ b ≼ a ∨ a ≼ b
   
   [<a name="collision_free_def-val"><b>collision_free_def</b></a>]  Definition
      
      ⊢ ∀m p.
            collision_free m p ⇔
            ∀x y. p x ∧ p y ∧ (x MOD 2 ** m = y MOD 2 ** m) ⇒ (x = y)
   
   [<a name="encode_blist_def-val"><b>encode_blist_def</b></a>]  Definition
      
      ⊢ (∀e l. encode_blist 0 e l = []) ∧
        ∀m e l.
            encode_blist (SUC m) e l = e (HD l) ⧺ encode_blist m e (TL l)
   
   [<a name="encode_bnum_def-val"><b>encode_bnum_def</b></a>]  Definition
      
      ⊢ (∀n. encode_bnum 0 n = []) ∧
        ∀m n. encode_bnum (SUC m) n = ¬EVEN n::encode_bnum m (n DIV 2)
   
   [<a name="encode_bool_def-val"><b>encode_bool_def</b></a>]  Definition
      
      ⊢ ∀x. encode_bool x = [x]
   
   [<a name="encode_list_def-val"><b>encode_list_def</b></a>]  Definition
      
      ⊢ (∀xb. encode_list xb [] = [F]) ∧
        ∀xb x xs. encode_list xb (x::xs) = T::(xb x ⧺ encode_list xb xs)
   
   [<a name="encode_num_primitive_def-val"><b>encode_num_primitive_def</b></a>]  Definition
      
      ⊢ encode_num =
        WFREC
          (@R.
               WF R ∧ (∀n. n ≠ 0 ∧ EVEN n ⇒ R ((n − 2) DIV 2) n) ∧
               ∀n. n ≠ 0 ∧ ¬EVEN n ⇒ R ((n − 1) DIV 2) n)
          (λencode_num a.
               I
                 (if a = 0 then [T; T]
                  else if EVEN a then F::encode_num ((a − 2) DIV 2)
                  else T::F::encode_num ((a − 1) DIV 2)))
   
   [<a name="encode_option_def-val"><b>encode_option_def</b></a>]  Definition
      
      ⊢ (∀xb. encode_option xb NONE = [F]) ∧
        ∀xb x. encode_option xb (SOME x) = T::xb x
   
   [<a name="encode_prod_def-val"><b>encode_prod_def</b></a>]  Definition
      
      ⊢ ∀xb yb x y. encode_prod xb yb (x,y) = xb x ⧺ yb y
   
   [<a name="encode_sum_def-val"><b>encode_sum_def</b></a>]  Definition
      
      ⊢ (∀xb yb x. encode_sum xb yb (INL x) = T::xb x) ∧
        ∀xb yb y. encode_sum xb yb (INR y) = F::yb y
   
   [<a name="encode_unit_def-val"><b>encode_unit_def</b></a>]  Definition
      
      ⊢ ∀v0. encode_unit v0 = []
   
   [<a name="lift_blist_def-val"><b>lift_blist_def</b></a>]  Definition
      
      ⊢ ∀m p x. lift_blist m p x ⇔ EVERY p x ∧ (LENGTH x = m)
   
   [<a name="lift_option_def-val"><b>lift_option_def</b></a>]  Definition
      
      ⊢ ∀p x. lift_option p x ⇔ case x of NONE =&gt; T | SOME y =&gt; p y
   
   [<a name="lift_prod_def-val"><b>lift_prod_def</b></a>]  Definition
      
      ⊢ ∀p1 p2 x. lift_prod p1 p2 x ⇔ p1 (FST x) ∧ p2 (SND x)
   
   [<a name="lift_sum_def-val"><b>lift_sum_def</b></a>]  Definition
      
      ⊢ ∀p1 p2 x.
            lift_sum p1 p2 x ⇔ case x of INL x1 =&gt; p1 x1 | INR x2 =&gt; p2 x2
   
   [<a name="tree_TY_DEF-val"><b>tree_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep.
            TYPE_DEFINITION
              (λa0'.
                   ∀'tree' '@temp @ind_typeEncode0list' .
                       (∀a0'.
                            (∃a0 a1.
                                 (a0' =
                                  (λa0 a1.
                                       ind_type$CONSTR 0 a0
                                         (ind_type$FCONS a1
                                            (λn. ind_type$BOTTOM))) a0 a1) ∧
                                 '@temp @ind_typeEncode0list' a1) ⇒
                            'tree' a0') ∧
                       (∀a1'.
                            (a1' =
                             ind_type$CONSTR (SUC 0) ARB
                               (λn. ind_type$BOTTOM)) ∨
                            (∃a0 a1.
                                 (a1' =
                                  (λa0 a1.
                                       ind_type$CONSTR (SUC (SUC 0)) ARB
                                         (ind_type$FCONS a0
                                            (ind_type$FCONS a1
                                               (λn. ind_type$BOTTOM)))) a0
                                    a1) ∧ 'tree' a0 ∧
                                 '@temp @ind_typeEncode0list' a1) ⇒
                            '@temp @ind_typeEncode0list' a1') ⇒
                       'tree' a0') rep
   
   [<a name="tree_case_def-val"><b>tree_case_def</b></a>]  Definition
      
      ⊢ ∀a0 a1 f. tree_CASE (Node a0 a1) f = f a0 a1
   
   [<a name="tree_size_def-val"><b>tree_size_def</b></a>]  Definition
      
      ⊢ (∀f a0 a1. tree_size f (Node a0 a1) = 1 + (f a0 + tree1_size f a1)) ∧
        (∀f. tree1_size f [] = 0) ∧
        ∀f a0 a1.
            tree1_size f (a0::a1) = 1 + (tree_size f a0 + tree1_size f a1)
   
   [<a name="wf_encoder_def-val"><b>wf_encoder_def</b></a>]  Definition
      
      ⊢ ∀p e. wf_encoder p e ⇔ ∀x y. p x ∧ p y ∧ e y ≼ e x ⇒ (x = y)
   
   [<a name="wf_pred_bnum_def-val"><b>wf_pred_bnum_def</b></a>]  Definition
      
      ⊢ ∀m p. wf_pred_bnum m p ⇔ wf_pred p ∧ ∀x. p x ⇒ x &lt; 2 ** m
   
   [<a name="wf_pred_def-val"><b>wf_pred_def</b></a>]  Definition
      
      ⊢ ∀p. wf_pred p ⇔ ∃x. p x
   
   [<a name="biprefix_append-val"><b>biprefix_append</b></a>]  Theorem
      
      ⊢ ∀a b c d. biprefix (a ⧺ b) (c ⧺ d) ⇒ biprefix a c
   
   [<a name="biprefix_appends-val"><b>biprefix_appends</b></a>]  Theorem
      
      ⊢ ∀a b c. biprefix (a ⧺ b) (a ⧺ c) ⇔ biprefix b c
   
   [<a name="biprefix_cons-val"><b>biprefix_cons</b></a>]  Theorem
      
      ⊢ ∀a b c d. biprefix (a::b) (c::d) ⇔ (a = c) ∧ biprefix b d
   
   [<a name="biprefix_refl-val"><b>biprefix_refl</b></a>]  Theorem
      
      ⊢ ∀x. biprefix x x
   
   [<a name="biprefix_sym-val"><b>biprefix_sym</b></a>]  Theorem
      
      ⊢ ∀x y. biprefix x y ⇒ biprefix y x
   
   [<a name="datatype_tree-val"><b>datatype_tree</b></a>]  Theorem
      
      ⊢ DATATYPE (tree Node)
   
   [<a name="encode_blist_def_compute-val"><b>encode_blist_def_compute</b></a>]  Theorem
      
      ⊢ (∀e l. encode_blist 0 e l = []) ∧
        (∀m e l.
             encode_blist (NUMERAL (BIT1 m)) e l =
             e (HD l) ⧺ encode_blist (NUMERAL (BIT1 m) − 1) e (TL l)) ∧
        ∀m e l.
            encode_blist (NUMERAL (BIT2 m)) e l =
            e (HD l) ⧺ encode_blist (NUMERAL (BIT1 m)) e (TL l)
   
   [<a name="encode_bnum_def_compute-val"><b>encode_bnum_def_compute</b></a>]  Theorem
      
      ⊢ (∀n. encode_bnum 0 n = []) ∧
        (∀m n.
             encode_bnum (NUMERAL (BIT1 m)) n =
             ¬EVEN n::encode_bnum (NUMERAL (BIT1 m) − 1) (n DIV 2)) ∧
        ∀m n.
            encode_bnum (NUMERAL (BIT2 m)) n =
            ¬EVEN n::encode_bnum (NUMERAL (BIT1 m)) (n DIV 2)
   
   [<a name="encode_bnum_inj-val"><b>encode_bnum_inj</b></a>]  Theorem
      
      ⊢ ∀m x y.
            x &lt; 2 ** m ∧ y &lt; 2 ** m ∧ (encode_bnum m x = encode_bnum m y) ⇒
            (x = y)
   
   [<a name="encode_bnum_length-val"><b>encode_bnum_length</b></a>]  Theorem
      
      ⊢ ∀m n. LENGTH (encode_bnum m n) = m
   
   [<a name="encode_list_cong-val"><b>encode_list_cong</b></a>]  Theorem
      
      ⊢ ∀l1 l2 f1 f2.
            (l1 = l2) ∧ (∀x. MEM x l2 ⇒ (f1 x = f2 x)) ⇒
            (encode_list f1 l1 = encode_list f2 l2)
   
   [<a name="encode_num_def-val"><b>encode_num_def</b></a>]  Theorem
      
      ⊢ encode_num n =
        if n = 0 then [T; T]
        else if EVEN n then F::encode_num ((n − 2) DIV 2)
        else T::F::encode_num ((n − 1) DIV 2)
   
   [<a name="encode_num_ind-val"><b>encode_num_ind</b></a>]  Theorem
      
      ⊢ ∀P.
            (∀n.
                 (n ≠ 0 ∧ EVEN n ⇒ P ((n − 2) DIV 2)) ∧
                 (n ≠ 0 ∧ ¬EVEN n ⇒ P ((n − 1) DIV 2)) ⇒
                 P n) ⇒
            ∀v. P v
   
   [<a name="encode_prod_alt-val"><b>encode_prod_alt</b></a>]  Theorem
      
      ⊢ ∀xb yb p. encode_prod xb yb p = xb (FST p) ⧺ yb (SND p)
   
   [<a name="encode_tree_def-val"><b>encode_tree_def</b></a>]  Theorem
      
      ⊢ encode_tree e (Node a ts) = e a ⧺ encode_list (encode_tree e) ts
   
   [<a name="lift_blist_suc-val"><b>lift_blist_suc</b></a>]  Theorem
      
      ⊢ ∀n p h t. lift_blist (SUC n) p (h::t) ⇔ p h ∧ lift_blist n p t
   
   [<a name="lift_tree_def-val"><b>lift_tree_def</b></a>]  Theorem
      
      ⊢ lift_tree p (Node a ts) ⇔ p a ∧ EVERY (lift_tree p) ts
   
   [<a name="tree_11-val"><b>tree_11</b></a>]  Theorem
      
      ⊢ ∀a0 a1 a0' a1'.
            (Node a0 a1 = Node a0' a1') ⇔ (a0 = a0') ∧ (a1 = a1')
   
   [<a name="tree_Axiom-val"><b>tree_Axiom</b></a>]  Theorem
      
      ⊢ ∀f0 f1 f2.
            ∃fn0 fn1.
                (∀a0 a1. fn0 (Node a0 a1) = f0 a0 a1 (fn1 a1)) ∧
                (fn1 [] = f1) ∧
                ∀a0 a1. fn1 (a0::a1) = f2 a0 a1 (fn0 a0) (fn1 a1)
   
   [<a name="tree_case_cong-val"><b>tree_case_cong</b></a>]  Theorem
      
      ⊢ ∀M M' f.
            (M = M') ∧ (∀a0 a1. (M' = Node a0 a1) ⇒ (f a0 a1 = f' a0 a1)) ⇒
            (tree_CASE M f = tree_CASE M' f')
   
   [<a name="tree_case_eq-val"><b>tree_case_eq</b></a>]  Theorem
      
      ⊢ (tree_CASE x f = v) ⇔ ∃a l. (x = Node a l) ∧ (f a l = v)
   
   [<a name="tree_ind-val"><b>tree_ind</b></a>]  Theorem
      
      ⊢ ∀p. (∀a ts. (∀t. MEM t ts ⇒ p t) ⇒ p (Node a ts)) ⇒ ∀t. p t
   
   [<a name="tree_induction-val"><b>tree_induction</b></a>]  Theorem
      
      ⊢ ∀P0 P1.
            (∀l. P1 l ⇒ ∀a. P0 (Node a l)) ∧ P1 [] ∧
            (∀t l. P0 t ∧ P1 l ⇒ P1 (t::l)) ⇒
            (∀t. P0 t) ∧ ∀l. P1 l
   
   [<a name="tree_nchotomy-val"><b>tree_nchotomy</b></a>]  Theorem
      
      ⊢ ∀tt. ∃a l. tt = Node a l
   
   [<a name="wf_encode_blist-val"><b>wf_encode_blist</b></a>]  Theorem
      
      ⊢ ∀m p e.
            wf_encoder p e ⇒ wf_encoder (lift_blist m p) (encode_blist m e)
   
   [<a name="wf_encode_bnum-val"><b>wf_encode_bnum</b></a>]  Theorem
      
      ⊢ ∀m p. wf_pred_bnum m p ⇒ wf_encoder p (encode_bnum m)
   
   [<a name="wf_encode_bnum_collision_free-val"><b>wf_encode_bnum_collision_free</b></a>]  Theorem
      
      ⊢ ∀m p. wf_encoder p (encode_bnum m) ⇔ collision_free m p
   
   [<a name="wf_encode_bool-val"><b>wf_encode_bool</b></a>]  Theorem
      
      ⊢ ∀p. wf_encoder p encode_bool
   
   [<a name="wf_encode_list-val"><b>wf_encode_list</b></a>]  Theorem
      
      ⊢ ∀p e. wf_encoder p e ⇒ wf_encoder (EVERY p) (encode_list e)
   
   [<a name="wf_encode_num-val"><b>wf_encode_num</b></a>]  Theorem
      
      ⊢ ∀p. wf_encoder p encode_num
   
   [<a name="wf_encode_option-val"><b>wf_encode_option</b></a>]  Theorem
      
      ⊢ ∀p e. wf_encoder p e ⇒ wf_encoder (lift_option p) (encode_option e)
   
   [<a name="wf_encode_prod-val"><b>wf_encode_prod</b></a>]  Theorem
      
      ⊢ ∀p1 p2 e1 e2.
            wf_encoder p1 e1 ∧ wf_encoder p2 e2 ⇒
            wf_encoder (lift_prod p1 p2) (encode_prod e1 e2)
   
   [<a name="wf_encode_sum-val"><b>wf_encode_sum</b></a>]  Theorem
      
      ⊢ ∀p1 p2 e1 e2.
            wf_encoder p1 e1 ∧ wf_encoder p2 e2 ⇒
            wf_encoder (lift_sum p1 p2) (encode_sum e1 e2)
   
   [<a name="wf_encode_tree-val"><b>wf_encode_tree</b></a>]  Theorem
      
      ⊢ ∀p e. wf_encoder p e ⇒ wf_encoder (lift_tree p) (encode_tree e)
   
   [<a name="wf_encode_unit-val"><b>wf_encode_unit</b></a>]  Theorem
      
      ⊢ ∀p. wf_encoder p encode_unit
   
   [<a name="wf_encoder_alt-val"><b>wf_encoder_alt</b></a>]  Theorem
      
      ⊢ wf_encoder p e ⇔ ∀x y. p x ∧ p y ∧ biprefix (e x) (e y) ⇒ (x = y)
   
   [<a name="wf_encoder_eq-val"><b>wf_encoder_eq</b></a>]  Theorem
      
      ⊢ ∀p e f. wf_encoder p e ∧ (∀x. p x ⇒ (e x = f x)) ⇒ wf_encoder p f
   
   [<a name="wf_encoder_total-val"><b>wf_encoder_total</b></a>]  Theorem
      
      ⊢ ∀p e. wf_encoder (K T) e ⇒ wf_encoder p e
   
   [<a name="wf_pred_bnum-val"><b>wf_pred_bnum</b></a>]  Theorem
      
      ⊢ ∀m p. wf_pred_bnum m p ⇒ collision_free m p
   
   [<a name="wf_pred_bnum_total-val"><b>wf_pred_bnum_total</b></a>]  Theorem
      
      ⊢ ∀m. wf_pred_bnum m (λx. x &lt; 2 ** m)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/Boolify/src/EncodeScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-11</a></em></p></body></html>
