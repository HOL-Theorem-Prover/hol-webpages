<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure DeepSyntaxTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure DeepSyntaxTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/integer/DeepSyntaxScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature DeepSyntaxTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#Aset_def-val">Aset_def</a> : thm
<a name="line7"></a>    val <a href="#Bset_def-val">Bset_def</a> : thm
<a name="line8"></a>    val <a href="#alldivide_def-val">alldivide_def</a> : thm
<a name="line9"></a>    val <a href="#deep_form_TY_DEF-val">deep_form_TY_DEF</a> : thm
<a name="line10"></a>    val <a href="#deep_form_case_def-val">deep_form_case_def</a> : thm
<a name="line11"></a>    val <a href="#deep_form_size_def-val">deep_form_size_def</a> : thm
<a name="line12"></a>    val <a href="#eval_form_def-val">eval_form_def</a> : thm
<a name="line13"></a>    val <a href="#neginf_def-val">neginf_def</a> : thm
<a name="line14"></a>    val <a href="#posinf_def-val">posinf_def</a> : thm
<a name="line15"></a>  
<a name="line16"></a>  (*  Theorems  *)
<a name="line17"></a>    val <a href="#add_d_neginf-val">add_d_neginf</a> : thm
<a name="line18"></a>    val <a href="#add_d_posinf-val">add_d_posinf</a> : thm
<a name="line19"></a>    val <a href="#datatype_deep_form-val">datatype_deep_form</a> : thm
<a name="line20"></a>    val <a href="#deep_form_11-val">deep_form_11</a> : thm
<a name="line21"></a>    val <a href="#deep_form_Axiom-val">deep_form_Axiom</a> : thm
<a name="line22"></a>    val <a href="#deep_form_case_cong-val">deep_form_case_cong</a> : thm
<a name="line23"></a>    val <a href="#deep_form_case_eq-val">deep_form_case_eq</a> : thm
<a name="line24"></a>    val <a href="#deep_form_distinct-val">deep_form_distinct</a> : thm
<a name="line25"></a>    val <a href="#deep_form_induction-val">deep_form_induction</a> : thm
<a name="line26"></a>    val <a href="#deep_form_nchotomy-val">deep_form_nchotomy</a> : thm
<a name="line27"></a>    val <a href="#in_aset-val">in_aset</a> : thm
<a name="line28"></a>    val <a href="#in_bset-val">in_bset</a> : thm
<a name="line29"></a>    val <a href="#neginf_disj1_implies_exoriginal-val">neginf_disj1_implies_exoriginal</a> : thm
<a name="line30"></a>    val <a href="#neginf_exoriginal_eq_rhs-val">neginf_exoriginal_eq_rhs</a> : thm
<a name="line31"></a>    val <a href="#neginf_exoriginal_implies_rhs-val">neginf_exoriginal_implies_rhs</a> : thm
<a name="line32"></a>    val <a href="#neginf_ok-val">neginf_ok</a> : thm
<a name="line33"></a>    val <a href="#posinf_disj1_implies_exoriginal-val">posinf_disj1_implies_exoriginal</a> : thm
<a name="line34"></a>    val <a href="#posinf_exoriginal_eq_rhs-val">posinf_exoriginal_eq_rhs</a> : thm
<a name="line35"></a>    val <a href="#posinf_exoriginal_implies_rhs-val">posinf_exoriginal_implies_rhs</a> : thm
<a name="line36"></a>    val <a href="#posinf_ok-val">posinf_ok</a> : thm
<a name="line37"></a>  
<a name="line38"></a>  val DeepSyntax_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line39"></a>(*
   [int_arith] Parent theory of "DeepSyntax"
   
   [<a name="Aset_def-val"><b>Aset_def</b></a>]  Definition
      
      ⊢ (∀pos f1 f2. Aset pos (Conjn f1 f2) = Aset pos f1 ∪ Aset pos f2) ∧
        (∀pos f1 f2. Aset pos (Disjn f1 f2) = Aset pos f1 ∪ Aset pos f2) ∧
        (∀pos f. Aset pos (Negn f) = Aset (¬pos) f) ∧
        (∀pos b. Aset pos (UnrelatedBool b) = ∅) ∧
        (∀pos i. Aset pos (xLT i) = if pos then {i} else ∅) ∧
        (∀pos i. Aset pos (LTx i) = if pos then ∅ else {i + 1}) ∧
        (∀pos i. Aset pos (xEQ i) = if pos then {i + 1} else {i}) ∧
        ∀pos i1 i2. Aset pos (xDivided i1 i2) = ∅
   
   [<a name="Bset_def-val"><b>Bset_def</b></a>]  Definition
      
      ⊢ (∀pos f1 f2. Bset pos (Conjn f1 f2) = Bset pos f1 ∪ Bset pos f2) ∧
        (∀pos f1 f2. Bset pos (Disjn f1 f2) = Bset pos f1 ∪ Bset pos f2) ∧
        (∀pos f. Bset pos (Negn f) = Bset (¬pos) f) ∧
        (∀pos b. Bset pos (UnrelatedBool b) = ∅) ∧
        (∀pos i. Bset pos (xLT i) = if pos then ∅ else {i + -1}) ∧
        (∀pos i. Bset pos (LTx i) = if pos then {i} else ∅) ∧
        (∀pos i. Bset pos (xEQ i) = if pos then {i + -1} else {i}) ∧
        ∀pos i1 i2. Bset pos (xDivided i1 i2) = ∅
   
   [<a name="alldivide_def-val"><b>alldivide_def</b></a>]  Definition
      
      ⊢ (∀f1 f2 d.
             alldivide (Conjn f1 f2) d ⇔ alldivide f1 d ∧ alldivide f2 d) ∧
        (∀f1 f2 d.
             alldivide (Disjn f1 f2) d ⇔ alldivide f1 d ∧ alldivide f2 d) ∧
        (∀f d. alldivide (Negn f) d ⇔ alldivide f d) ∧
        (∀b d. alldivide (UnrelatedBool b) d ⇔ T) ∧
        (∀i d. alldivide (xLT i) d ⇔ T) ∧ (∀i d. alldivide (LTx i) d ⇔ T) ∧
        (∀i d. alldivide (xEQ i) d ⇔ T) ∧
        ∀i1 i2 d. alldivide (xDivided i1 i2) d ⇔ i1 int_divides d
   
   [<a name="deep_form_TY_DEF-val"><b>deep_form_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep.
            TYPE_DEFINITION
              (λa0'.
                   ∀'deep_form' .
                       (∀a0'.
                            (∃a0 a1.
                                 (a0' =
                                  (λa0 a1.
                                       ind_type$CONSTR 0 (ARB,ARB,ARB)
                                         (ind_type$FCONS a0
                                            (ind_type$FCONS a1
                                               (λn. ind_type$BOTTOM)))) a0
                                    a1) ∧ 'deep_form' a0 ∧ 'deep_form' a1) ∨
                            (∃a0 a1.
                                 (a0' =
                                  (λa0 a1.
                                       ind_type$CONSTR (SUC 0)
                                         (ARB,ARB,ARB)
                                         (ind_type$FCONS a0
                                            (ind_type$FCONS a1
                                               (λn. ind_type$BOTTOM)))) a0
                                    a1) ∧ 'deep_form' a0 ∧ 'deep_form' a1) ∨
                            (∃a.
                                 (a0' =
                                  (λa.
                                       ind_type$CONSTR (SUC (SUC 0))
                                         (ARB,ARB,ARB)
                                         (ind_type$FCONS a
                                            (λn. ind_type$BOTTOM))) a) ∧
                                 'deep_form' a) ∨
                            (∃a.
                                 a0' =
                                 (λa.
                                      ind_type$CONSTR (SUC (SUC (SUC 0)))
                                        (a,ARB,ARB) (λn. ind_type$BOTTOM))
                                   a) ∨
                            (∃a.
                                 a0' =
                                 (λa.
                                      ind_type$CONSTR
                                        (SUC (SUC (SUC (SUC 0))))
                                        (ARB,a,ARB) (λn. ind_type$BOTTOM))
                                   a) ∨
                            (∃a.
                                 a0' =
                                 (λa.
                                      ind_type$CONSTR
                                        (SUC (SUC (SUC (SUC (SUC 0)))))
                                        (ARB,a,ARB) (λn. ind_type$BOTTOM))
                                   a) ∨
                            (∃a.
                                 a0' =
                                 (λa.
                                      ind_type$CONSTR
                                        (SUC
                                           (SUC (SUC (SUC (SUC (SUC 0))))))
                                        (ARB,a,ARB) (λn. ind_type$BOTTOM))
                                   a) ∨
                            (∃a0 a1.
                                 a0' =
                                 (λa0 a1.
                                      ind_type$CONSTR
                                        (SUC
                                           (SUC
                                              (SUC
                                                 (SUC (SUC (SUC (SUC 0)))))))
                                        (ARB,a0,a1) (λn. ind_type$BOTTOM))
                                   a0 a1) ⇒
                            'deep_form' a0') ⇒
                       'deep_form' a0') rep
   
   [<a name="deep_form_case_def-val"><b>deep_form_case_def</b></a>]  Definition
      
      ⊢ (∀a0 a1 f f1 f2 f3 f4 f5 f6 f7.
             deep_form_CASE (Conjn a0 a1) f f1 f2 f3 f4 f5 f6 f7 = f a0 a1) ∧
        (∀a0 a1 f f1 f2 f3 f4 f5 f6 f7.
             deep_form_CASE (Disjn a0 a1) f f1 f2 f3 f4 f5 f6 f7 = f1 a0 a1) ∧
        (∀a f f1 f2 f3 f4 f5 f6 f7.
             deep_form_CASE (Negn a) f f1 f2 f3 f4 f5 f6 f7 = f2 a) ∧
        (∀a f f1 f2 f3 f4 f5 f6 f7.
             deep_form_CASE (UnrelatedBool a) f f1 f2 f3 f4 f5 f6 f7 = f3 a) ∧
        (∀a f f1 f2 f3 f4 f5 f6 f7.
             deep_form_CASE (xLT a) f f1 f2 f3 f4 f5 f6 f7 = f4 a) ∧
        (∀a f f1 f2 f3 f4 f5 f6 f7.
             deep_form_CASE (LTx a) f f1 f2 f3 f4 f5 f6 f7 = f5 a) ∧
        (∀a f f1 f2 f3 f4 f5 f6 f7.
             deep_form_CASE (xEQ a) f f1 f2 f3 f4 f5 f6 f7 = f6 a) ∧
        ∀a0 a1 f f1 f2 f3 f4 f5 f6 f7.
            deep_form_CASE (xDivided a0 a1) f f1 f2 f3 f4 f5 f6 f7 =
            f7 a0 a1
   
   [<a name="deep_form_size_def-val"><b>deep_form_size_def</b></a>]  Definition
      
      ⊢ (∀a0 a1.
             deep_form_size (Conjn a0 a1) =
             1 + (deep_form_size a0 + deep_form_size a1)) ∧
        (∀a0 a1.
             deep_form_size (Disjn a0 a1) =
             1 + (deep_form_size a0 + deep_form_size a1)) ∧
        (∀a. deep_form_size (Negn a) = 1 + deep_form_size a) ∧
        (∀a. deep_form_size (UnrelatedBool a) = 1 + bool_size a) ∧
        (∀a. deep_form_size (xLT a) = 1) ∧
        (∀a. deep_form_size (LTx a) = 1) ∧
        (∀a. deep_form_size (xEQ a) = 1) ∧
        ∀a0 a1. deep_form_size (xDivided a0 a1) = 1
   
   [<a name="eval_form_def-val"><b>eval_form_def</b></a>]  Definition
      
      ⊢ (∀f1 f2 x.
             eval_form (Conjn f1 f2) x ⇔ eval_form f1 x ∧ eval_form f2 x) ∧
        (∀f1 f2 x.
             eval_form (Disjn f1 f2) x ⇔ eval_form f1 x ∨ eval_form f2 x) ∧
        (∀f x. eval_form (Negn f) x ⇔ ¬eval_form f x) ∧
        (∀b x. eval_form (UnrelatedBool b) x ⇔ b) ∧
        (∀i x. eval_form (xLT i) x ⇔ x &lt; i) ∧
        (∀i x. eval_form (LTx i) x ⇔ i &lt; x) ∧
        (∀i x. eval_form (xEQ i) x ⇔ (x = i)) ∧
        ∀i1 i2 x. eval_form (xDivided i1 i2) x ⇔ i1 int_divides x + i2
   
   [<a name="neginf_def-val"><b>neginf_def</b></a>]  Definition
      
      ⊢ (∀f1 f2. neginf (Conjn f1 f2) = Conjn (neginf f1) (neginf f2)) ∧
        (∀f1 f2. neginf (Disjn f1 f2) = Disjn (neginf f1) (neginf f2)) ∧
        (∀f. neginf (Negn f) = Negn (neginf f)) ∧
        (∀b. neginf (UnrelatedBool b) = UnrelatedBool b) ∧
        (∀i. neginf (xLT i) = UnrelatedBool T) ∧
        (∀i. neginf (LTx i) = UnrelatedBool F) ∧
        (∀i. neginf (xEQ i) = UnrelatedBool F) ∧
        ∀i1 i2. neginf (xDivided i1 i2) = xDivided i1 i2
   
   [<a name="posinf_def-val"><b>posinf_def</b></a>]  Definition
      
      ⊢ (∀f1 f2. posinf (Conjn f1 f2) = Conjn (posinf f1) (posinf f2)) ∧
        (∀f1 f2. posinf (Disjn f1 f2) = Disjn (posinf f1) (posinf f2)) ∧
        (∀f. posinf (Negn f) = Negn (posinf f)) ∧
        (∀b. posinf (UnrelatedBool b) = UnrelatedBool b) ∧
        (∀i. posinf (xLT i) = UnrelatedBool F) ∧
        (∀i. posinf (LTx i) = UnrelatedBool T) ∧
        (∀i. posinf (xEQ i) = UnrelatedBool F) ∧
        ∀i1 i2. posinf (xDivided i1 i2) = xDivided i1 i2
   
   [<a name="add_d_neginf-val"><b>add_d_neginf</b></a>]  Theorem
      
      ⊢ ∀f x y d.
            alldivide f d ⇒
            (eval_form (neginf f) x ⇔ eval_form (neginf f) (x + y * d))
   
   [<a name="add_d_posinf-val"><b>add_d_posinf</b></a>]  Theorem
      
      ⊢ ∀f x y d.
            alldivide f d ⇒
            (eval_form (posinf f) x ⇔ eval_form (posinf f) (x + y * d))
   
   [<a name="datatype_deep_form-val"><b>datatype_deep_form</b></a>]  Theorem
      
      ⊢ DATATYPE
          (deep_form Conjn Disjn Negn UnrelatedBool xLT LTx xEQ xDivided)
   
   [<a name="deep_form_11-val"><b>deep_form_11</b></a>]  Theorem
      
      ⊢ (∀a0 a1 a0' a1'.
             (Conjn a0 a1 = Conjn a0' a1') ⇔ (a0 = a0') ∧ (a1 = a1')) ∧
        (∀a0 a1 a0' a1'.
             (Disjn a0 a1 = Disjn a0' a1') ⇔ (a0 = a0') ∧ (a1 = a1')) ∧
        (∀a a'. (Negn a = Negn a') ⇔ (a = a')) ∧
        (∀a a'. (UnrelatedBool a = UnrelatedBool a') ⇔ (a ⇔ a')) ∧
        (∀a a'. (xLT a = xLT a') ⇔ (a = a')) ∧
        (∀a a'. (LTx a = LTx a') ⇔ (a = a')) ∧
        (∀a a'. (xEQ a = xEQ a') ⇔ (a = a')) ∧
        ∀a0 a1 a0' a1'.
            (xDivided a0 a1 = xDivided a0' a1') ⇔ (a0 = a0') ∧ (a1 = a1')
   
   [<a name="deep_form_Axiom-val"><b>deep_form_Axiom</b></a>]  Theorem
      
      ⊢ ∀f0 f1 f2 f3 f4 f5 f6 f7.
            ∃fn.
                (∀a0 a1. fn (Conjn a0 a1) = f0 a0 a1 (fn a0) (fn a1)) ∧
                (∀a0 a1. fn (Disjn a0 a1) = f1 a0 a1 (fn a0) (fn a1)) ∧
                (∀a. fn (Negn a) = f2 a (fn a)) ∧
                (∀a. fn (UnrelatedBool a) = f3 a) ∧
                (∀a. fn (xLT a) = f4 a) ∧ (∀a. fn (LTx a) = f5 a) ∧
                (∀a. fn (xEQ a) = f6 a) ∧
                ∀a0 a1. fn (xDivided a0 a1) = f7 a0 a1
   
   [<a name="deep_form_case_cong-val"><b>deep_form_case_cong</b></a>]  Theorem
      
      ⊢ ∀M M' f f1 f2 f3 f4 f5 f6 f7.
            (M = M') ∧
            (∀a0 a1. (M' = Conjn a0 a1) ⇒ (f a0 a1 = f' a0 a1)) ∧
            (∀a0 a1. (M' = Disjn a0 a1) ⇒ (f1 a0 a1 = f1' a0 a1)) ∧
            (∀a. (M' = Negn a) ⇒ (f2 a = f2' a)) ∧
            (∀a. (M' = UnrelatedBool a) ⇒ (f3 a = f3' a)) ∧
            (∀a. (M' = xLT a) ⇒ (f4 a = f4' a)) ∧
            (∀a. (M' = LTx a) ⇒ (f5 a = f5' a)) ∧
            (∀a. (M' = xEQ a) ⇒ (f6 a = f6' a)) ∧
            (∀a0 a1. (M' = xDivided a0 a1) ⇒ (f7 a0 a1 = f7' a0 a1)) ⇒
            (deep_form_CASE M f f1 f2 f3 f4 f5 f6 f7 =
             deep_form_CASE M' f' f1' f2' f3' f4' f5' f6' f7')
   
   [<a name="deep_form_case_eq-val"><b>deep_form_case_eq</b></a>]  Theorem
      
      ⊢ (deep_form_CASE x f f1 f2 f3 f4 f5 f6 f7 = v) ⇔
        (∃d d0. (x = Conjn d d0) ∧ (f d d0 = v)) ∨
        (∃d d0. (x = Disjn d d0) ∧ (f1 d d0 = v)) ∨
        (∃d. (x = Negn d) ∧ (f2 d = v)) ∨
        (∃b. (x = UnrelatedBool b) ∧ (f3 b = v)) ∨
        (∃i. (x = xLT i) ∧ (f4 i = v)) ∨ (∃i. (x = LTx i) ∧ (f5 i = v)) ∨
        (∃i. (x = xEQ i) ∧ (f6 i = v)) ∨
        ∃i i0. (x = xDivided i i0) ∧ (f7 i i0 = v)
   
   [<a name="deep_form_distinct-val"><b>deep_form_distinct</b></a>]  Theorem
      
      ⊢ (∀a1' a1 a0' a0. Conjn a0 a1 ≠ Disjn a0' a1') ∧
        (∀a1 a0 a. Conjn a0 a1 ≠ Negn a) ∧
        (∀a1 a0 a. Conjn a0 a1 ≠ UnrelatedBool a) ∧
        (∀a1 a0 a. Conjn a0 a1 ≠ xLT a) ∧ (∀a1 a0 a. Conjn a0 a1 ≠ LTx a) ∧
        (∀a1 a0 a. Conjn a0 a1 ≠ xEQ a) ∧
        (∀a1' a1 a0' a0. Conjn a0 a1 ≠ xDivided a0' a1') ∧
        (∀a1 a0 a. Disjn a0 a1 ≠ Negn a) ∧
        (∀a1 a0 a. Disjn a0 a1 ≠ UnrelatedBool a) ∧
        (∀a1 a0 a. Disjn a0 a1 ≠ xLT a) ∧ (∀a1 a0 a. Disjn a0 a1 ≠ LTx a) ∧
        (∀a1 a0 a. Disjn a0 a1 ≠ xEQ a) ∧
        (∀a1' a1 a0' a0. Disjn a0 a1 ≠ xDivided a0' a1') ∧
        (∀a' a. Negn a ≠ UnrelatedBool a') ∧ (∀a' a. Negn a ≠ xLT a') ∧
        (∀a' a. Negn a ≠ LTx a') ∧ (∀a' a. Negn a ≠ xEQ a') ∧
        (∀a1 a0 a. Negn a ≠ xDivided a0 a1) ∧
        (∀a' a. UnrelatedBool a ≠ xLT a') ∧
        (∀a' a. UnrelatedBool a ≠ LTx a') ∧
        (∀a' a. UnrelatedBool a ≠ xEQ a') ∧
        (∀a1 a0 a. UnrelatedBool a ≠ xDivided a0 a1) ∧
        (∀a' a. xLT a ≠ LTx a') ∧ (∀a' a. xLT a ≠ xEQ a') ∧
        (∀a1 a0 a. xLT a ≠ xDivided a0 a1) ∧ (∀a' a. LTx a ≠ xEQ a') ∧
        (∀a1 a0 a. LTx a ≠ xDivided a0 a1) ∧
        ∀a1 a0 a. xEQ a ≠ xDivided a0 a1
   
   [<a name="deep_form_induction-val"><b>deep_form_induction</b></a>]  Theorem
      
      ⊢ ∀P.
            (∀d d0. P d ∧ P d0 ⇒ P (Conjn d d0)) ∧
            (∀d d0. P d ∧ P d0 ⇒ P (Disjn d d0)) ∧ (∀d. P d ⇒ P (Negn d)) ∧
            (∀b. P (UnrelatedBool b)) ∧ (∀i. P (xLT i)) ∧ (∀i. P (LTx i)) ∧
            (∀i. P (xEQ i)) ∧ (∀i i0. P (xDivided i i0)) ⇒
            ∀d. P d
   
   [<a name="deep_form_nchotomy-val"><b>deep_form_nchotomy</b></a>]  Theorem
      
      ⊢ ∀dd.
            (∃d d0. dd = Conjn d d0) ∨ (∃d d0. dd = Disjn d d0) ∨
            (∃d. dd = Negn d) ∨ (∃b. dd = UnrelatedBool b) ∨
            (∃i. dd = xLT i) ∨ (∃i. dd = LTx i) ∨ (∃i. dd = xEQ i) ∨
            ∃i i0. dd = xDivided i i0
   
   [<a name="in_aset-val"><b>in_aset</b></a>]  Theorem
      
      ⊢ ((∃a. a ∈ Aset pos (Conjn f1 f2) ∧ P a) ⇔
         (∃a. a ∈ Aset pos f1 ∧ P a) ∨ ∃a. a ∈ Aset pos f2 ∧ P a) ∧
        ((∃a. a ∈ Aset pos (Disjn f1 f2) ∧ P a) ⇔
         (∃a. a ∈ Aset pos f1 ∧ P a) ∨ ∃a. a ∈ Aset pos f2 ∧ P a) ∧
        ((∃a. a ∈ Aset T (Negn f) ∧ P a) ⇔ ∃a. a ∈ Aset F f ∧ P a) ∧
        ((∃a. a ∈ Aset F (Negn f) ∧ P a) ⇔ ∃a. a ∈ Aset T f ∧ P a) ∧
        ((∃a. a ∈ Aset pos (UnrelatedBool a0) ∧ P a) ⇔ F) ∧
        ((∃a. a ∈ Aset T (xLT i) ∧ P a) ⇔ P i) ∧
        ((∃a. a ∈ Aset F (xLT i) ∧ P a) ⇔ F) ∧
        ((∃a. a ∈ Aset T (LTx i) ∧ P a) ⇔ F) ∧
        ((∃a. a ∈ Aset F (LTx i) ∧ P a) ⇔ P (i + 1)) ∧
        ((∃a. a ∈ Aset T (xEQ i) ∧ P a) ⇔ P (i + 1)) ∧
        ((∃a. a ∈ Aset F (xEQ i) ∧ P a) ⇔ P i) ∧
        ((∃a. a ∈ Aset pos (xDivided i1 i2) ∧ P a) ⇔ F)
   
   [<a name="in_bset-val"><b>in_bset</b></a>]  Theorem
      
      ⊢ ((∃b. b ∈ Bset pos (Conjn f1 f2) ∧ P b) ⇔
         (∃b. b ∈ Bset pos f1 ∧ P b) ∨ ∃b. b ∈ Bset pos f2 ∧ P b) ∧
        ((∃b. b ∈ Bset pos (Disjn f1 f2) ∧ P b) ⇔
         (∃b. b ∈ Bset pos f1 ∧ P b) ∨ ∃b. b ∈ Bset pos f2 ∧ P b) ∧
        ((∃b. b ∈ Bset T (Negn f) ∧ P b) ⇔ ∃b. b ∈ Bset F f ∧ P b) ∧
        ((∃b. b ∈ Bset F (Negn f) ∧ P b) ⇔ ∃b. b ∈ Bset T f ∧ P b) ∧
        ((∃b. b ∈ Bset pos (UnrelatedBool b0) ∧ P b) ⇔ F) ∧
        ((∃b. b ∈ Bset T (xLT i) ∧ P b) ⇔ F) ∧
        ((∃b. b ∈ Bset F (xLT i) ∧ P b) ⇔ P (i + -1)) ∧
        ((∃b. b ∈ Bset T (LTx i) ∧ P b) ⇔ P i) ∧
        ((∃b. b ∈ Bset F (LTx i) ∧ P b) ⇔ F) ∧
        ((∃b. b ∈ Bset T (xEQ i) ∧ P b) ⇔ P (i + -1)) ∧
        ((∃b. b ∈ Bset F (xEQ i) ∧ P b) ⇔ P i) ∧
        ((∃b. b ∈ Bset pos (xDivided i1 i2) ∧ P b) ⇔ F)
   
   [<a name="neginf_disj1_implies_exoriginal-val"><b>neginf_disj1_implies_exoriginal</b></a>]  Theorem
      
      ⊢ ∀f d i.
            alldivide f d ⇒
            0 &lt; i ∧ i ≤ d ∧ eval_form (neginf f) i ⇒
            ∃x. eval_form f x
   
   [<a name="neginf_exoriginal_eq_rhs-val"><b>neginf_exoriginal_eq_rhs</b></a>]  Theorem
      
      ⊢ ∀f d.
            alldivide f d ∧ 0 &lt; d ⇒
            ((∃x. eval_form f x) ⇔
             (∃i. K (0 &lt; i ∧ i ≤ d) i ∧ eval_form (neginf f) i) ∨
             ∃b j.
                 (b ∈ Bset T f ∧ K (0 &lt; j ∧ j ≤ d) j) ∧ eval_form f (b + j))
   
   [<a name="neginf_exoriginal_implies_rhs-val"><b>neginf_exoriginal_implies_rhs</b></a>]  Theorem
      
      ⊢ ∀f d x.
            alldivide f d ∧ 0 &lt; d ⇒
            eval_form f x ⇒
            (∃i. 0 &lt; i ∧ i ≤ d ∧ eval_form (neginf f) i) ∨
            ∃j b. 0 &lt; j ∧ j ≤ d ∧ b ∈ Bset T f ∧ eval_form f (b + j)
   
   [<a name="neginf_ok-val"><b>neginf_ok</b></a>]  Theorem
      
      ⊢ ∀f. ∃y. ∀x. x &lt; y ⇒ (eval_form f x ⇔ eval_form (neginf f) x)
   
   [<a name="posinf_disj1_implies_exoriginal-val"><b>posinf_disj1_implies_exoriginal</b></a>]  Theorem
      
      ⊢ ∀f d i.
            alldivide f d ⇒
            0 &lt; i ∧ i ≤ d ∧ eval_form (posinf f) i ⇒
            ∃x. eval_form f x
   
   [<a name="posinf_exoriginal_eq_rhs-val"><b>posinf_exoriginal_eq_rhs</b></a>]  Theorem
      
      ⊢ ∀f d.
            alldivide f d ∧ 0 &lt; d ⇒
            ((∃x. eval_form f x) ⇔
             (∃i. K (0 &lt; i ∧ i ≤ d) i ∧ eval_form (posinf f) i) ∨
             ∃b j.
                 (b ∈ Aset T f ∧ K (0 &lt; j ∧ j ≤ d) j) ∧
                 eval_form f (b + -1 * j))
   
   [<a name="posinf_exoriginal_implies_rhs-val"><b>posinf_exoriginal_implies_rhs</b></a>]  Theorem
      
      ⊢ ∀f d x.
            alldivide f d ∧ 0 &lt; d ⇒
            eval_form f x ⇒
            (∃i. 0 &lt; i ∧ i ≤ d ∧ eval_form (posinf f) i) ∨
            ∃j b. 0 &lt; j ∧ j ≤ d ∧ b ∈ Aset T f ∧ eval_form f (b + -j)
   
   [<a name="posinf_ok-val"><b>posinf_ok</b></a>]  Theorem
      
      ⊢ ∀f. ∃y. ∀x. y &lt; x ⇒ (eval_form f x ⇔ eval_form (posinf f) x)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/integer/DeepSyntaxScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-11</a></em></p></body></html>
