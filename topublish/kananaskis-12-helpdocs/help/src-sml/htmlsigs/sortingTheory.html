<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure sortingTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure sortingTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/sort/sortingScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature sortingTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#PART3_DEF-val">PART3_DEF</a> : thm
<a name="line7"></a>    val <a href="#PARTITION_DEF-val">PARTITION_DEF</a> : thm
<a name="line8"></a>    val <a href="#PART_DEF-val">PART_DEF</a> : thm
<a name="line9"></a>    val <a href="#PERM_DEF-val">PERM_DEF</a> : thm
<a name="line10"></a>    val <a href="#PERM_SINGLE_SWAP_DEF-val">PERM_SINGLE_SWAP_DEF</a> : thm
<a name="line11"></a>    val <a href="#SORTS_DEF-val">SORTS_DEF</a> : thm
<a name="line12"></a>    val <a href="#STABLE_DEF-val">STABLE_DEF</a> : thm
<a name="line13"></a>  
<a name="line14"></a>  (*  Theorems  *)
<a name="line15"></a>    val <a href="#ALL_DISTINCT_PERM-val">ALL_DISTINCT_PERM</a> : thm
<a name="line16"></a>    val <a href="#ALL_DISTINCT_PERM_LIST_TO_SET_TO_LIST-val">ALL_DISTINCT_PERM_LIST_TO_SET_TO_LIST</a> : thm
<a name="line17"></a>    val <a href="#ALL_DISTINCT_SORTED_WEAKEN-val">ALL_DISTINCT_SORTED_WEAKEN</a> : thm
<a name="line18"></a>    val <a href="#APPEND_PERM_SYM-val">APPEND_PERM_SYM</a> : thm
<a name="line19"></a>    val <a href="#CONS_PERM-val">CONS_PERM</a> : thm
<a name="line20"></a>    val <a href="#FILTER_EQ_LENGTHS_EQ-val">FILTER_EQ_LENGTHS_EQ</a> : thm
<a name="line21"></a>    val <a href="#FILTER_EQ_REP-val">FILTER_EQ_REP</a> : thm
<a name="line22"></a>    val <a href="#FOLDR_PERM-val">FOLDR_PERM</a> : thm
<a name="line23"></a>    val <a href="#MEM_PERM-val">MEM_PERM</a> : thm
<a name="line24"></a>    val <a href="#PART3_FILTER-val">PART3_FILTER</a> : thm
<a name="line25"></a>    val <a href="#PART_LENGTH-val">PART_LENGTH</a> : thm
<a name="line26"></a>    val <a href="#PART_LENGTH_LEM-val">PART_LENGTH_LEM</a> : thm
<a name="line27"></a>    val <a href="#PART_MEM-val">PART_MEM</a> : thm
<a name="line28"></a>    val <a href="#PARTs_HAVE_PROP-val">PARTs_HAVE_PROP</a> : thm
<a name="line29"></a>    val <a href="#PERM3-val">PERM3</a> : thm
<a name="line30"></a>    val <a href="#PERM3_FILTER-val">PERM3_FILTER</a> : thm
<a name="line31"></a>    val <a href="#PERM_ALL_DISTINCT-val">PERM_ALL_DISTINCT</a> : thm
<a name="line32"></a>    val <a href="#PERM_APPEND-val">PERM_APPEND</a> : thm
<a name="line33"></a>    val <a href="#PERM_APPEND_IFF-val">PERM_APPEND_IFF</a> : thm
<a name="line34"></a>    val <a href="#PERM_CONG-val">PERM_CONG</a> : thm
<a name="line35"></a>    val <a href="#PERM_CONG_2-val">PERM_CONG_2</a> : thm
<a name="line36"></a>    val <a href="#PERM_CONG_APPEND_IFF-val">PERM_CONG_APPEND_IFF</a> : thm
<a name="line37"></a>    val <a href="#PERM_CONS_EQ_APPEND-val">PERM_CONS_EQ_APPEND</a> : thm
<a name="line38"></a>    val <a href="#PERM_CONS_IFF-val">PERM_CONS_IFF</a> : thm
<a name="line39"></a>    val <a href="#PERM_EQC-val">PERM_EQC</a> : thm
<a name="line40"></a>    val <a href="#PERM_EQUIVALENCE-val">PERM_EQUIVALENCE</a> : thm
<a name="line41"></a>    val <a href="#PERM_EQUIVALENCE_ALT_DEF-val">PERM_EQUIVALENCE_ALT_DEF</a> : thm
<a name="line42"></a>    val <a href="#PERM_FILTER-val">PERM_FILTER</a> : thm
<a name="line43"></a>    val <a href="#PERM_FUN_APPEND-val">PERM_FUN_APPEND</a> : thm
<a name="line44"></a>    val <a href="#PERM_FUN_APPEND_APPEND_1-val">PERM_FUN_APPEND_APPEND_1</a> : thm
<a name="line45"></a>    val <a href="#PERM_FUN_APPEND_APPEND_2-val">PERM_FUN_APPEND_APPEND_2</a> : thm
<a name="line46"></a>    val <a href="#PERM_FUN_APPEND_C-val">PERM_FUN_APPEND_C</a> : thm
<a name="line47"></a>    val <a href="#PERM_FUN_APPEND_CONS-val">PERM_FUN_APPEND_CONS</a> : thm
<a name="line48"></a>    val <a href="#PERM_FUN_APPEND_IFF-val">PERM_FUN_APPEND_IFF</a> : thm
<a name="line49"></a>    val <a href="#PERM_FUN_CONG-val">PERM_FUN_CONG</a> : thm
<a name="line50"></a>    val <a href="#PERM_FUN_CONS-val">PERM_FUN_CONS</a> : thm
<a name="line51"></a>    val <a href="#PERM_FUN_CONS_11_APPEND-val">PERM_FUN_CONS_11_APPEND</a> : thm
<a name="line52"></a>    val <a href="#PERM_FUN_CONS_11_SWAP_AT_FRONT-val">PERM_FUN_CONS_11_SWAP_AT_FRONT</a> : thm
<a name="line53"></a>    val <a href="#PERM_FUN_CONS_APPEND_1-val">PERM_FUN_CONS_APPEND_1</a> : thm
<a name="line54"></a>    val <a href="#PERM_FUN_CONS_APPEND_2-val">PERM_FUN_CONS_APPEND_2</a> : thm
<a name="line55"></a>    val <a href="#PERM_FUN_CONS_IFF-val">PERM_FUN_CONS_IFF</a> : thm
<a name="line56"></a>    val <a href="#PERM_FUN_SPLIT-val">PERM_FUN_SPLIT</a> : thm
<a name="line57"></a>    val <a href="#PERM_FUN_SWAP_AT_FRONT-val">PERM_FUN_SWAP_AT_FRONT</a> : thm
<a name="line58"></a>    val <a href="#PERM_IND-val">PERM_IND</a> : thm
<a name="line59"></a>    val <a href="#PERM_INTRO-val">PERM_INTRO</a> : thm
<a name="line60"></a>    val <a href="#PERM_LENGTH-val">PERM_LENGTH</a> : thm
<a name="line61"></a>    val <a href="#PERM_LIST_TO_SET-val">PERM_LIST_TO_SET</a> : thm
<a name="line62"></a>    val <a href="#PERM_MAP-val">PERM_MAP</a> : thm
<a name="line63"></a>    val <a href="#PERM_MEM_EQ-val">PERM_MEM_EQ</a> : thm
<a name="line64"></a>    val <a href="#PERM_MONO-val">PERM_MONO</a> : thm
<a name="line65"></a>    val <a href="#PERM_NIL-val">PERM_NIL</a> : thm
<a name="line66"></a>    val <a href="#PERM_QSORT3-val">PERM_QSORT3</a> : thm
<a name="line67"></a>    val <a href="#PERM_REFL-val">PERM_REFL</a> : thm
<a name="line68"></a>    val <a href="#PERM_REVERSE-val">PERM_REVERSE</a> : thm
<a name="line69"></a>    val <a href="#PERM_REVERSE_EQ-val">PERM_REVERSE_EQ</a> : thm
<a name="line70"></a>    val <a href="#PERM_REWR-val">PERM_REWR</a> : thm
<a name="line71"></a>    val <a href="#PERM_RTC-val">PERM_RTC</a> : thm
<a name="line72"></a>    val <a href="#PERM_SET_TO_LIST_count_COUNT_LIST-val">PERM_SET_TO_LIST_count_COUNT_LIST</a> : thm
<a name="line73"></a>    val <a href="#PERM_SING-val">PERM_SING</a> : thm
<a name="line74"></a>    val <a href="#PERM_SINGLE_SWAP_APPEND-val">PERM_SINGLE_SWAP_APPEND</a> : thm
<a name="line75"></a>    val <a href="#PERM_SINGLE_SWAP_CONS-val">PERM_SINGLE_SWAP_CONS</a> : thm
<a name="line76"></a>    val <a href="#PERM_SINGLE_SWAP_I-val">PERM_SINGLE_SWAP_I</a> : thm
<a name="line77"></a>    val <a href="#PERM_SINGLE_SWAP_REFL-val">PERM_SINGLE_SWAP_REFL</a> : thm
<a name="line78"></a>    val <a href="#PERM_SINGLE_SWAP_SYM-val">PERM_SINGLE_SWAP_SYM</a> : thm
<a name="line79"></a>    val <a href="#PERM_SINGLE_SWAP_TC_CONS-val">PERM_SINGLE_SWAP_TC_CONS</a> : thm
<a name="line80"></a>    val <a href="#PERM_SPLIT-val">PERM_SPLIT</a> : thm
<a name="line81"></a>    val <a href="#PERM_SPLIT_IF-val">PERM_SPLIT_IF</a> : thm
<a name="line82"></a>    val <a href="#PERM_STRONG_IND-val">PERM_STRONG_IND</a> : thm
<a name="line83"></a>    val <a href="#PERM_SUM-val">PERM_SUM</a> : thm
<a name="line84"></a>    val <a href="#PERM_SWAP_AT_FRONT-val">PERM_SWAP_AT_FRONT</a> : thm
<a name="line85"></a>    val <a href="#PERM_SWAP_L_AT_FRONT-val">PERM_SWAP_L_AT_FRONT</a> : thm
<a name="line86"></a>    val <a href="#PERM_SYM-val">PERM_SYM</a> : thm
<a name="line87"></a>    val <a href="#PERM_TC-val">PERM_TC</a> : thm
<a name="line88"></a>    val <a href="#PERM_TRANS-val">PERM_TRANS</a> : thm
<a name="line89"></a>    val <a href="#PERM_alt-val">PERM_alt</a> : thm
<a name="line90"></a>    val <a href="#PERM_lifts_equalities-val">PERM_lifts_equalities</a> : thm
<a name="line91"></a>    val <a href="#PERM_lifts_invariants-val">PERM_lifts_invariants</a> : thm
<a name="line92"></a>    val <a href="#PERM_lifts_monotonicities-val">PERM_lifts_monotonicities</a> : thm
<a name="line93"></a>    val <a href="#PERM_lifts_transitive_relations-val">PERM_lifts_transitive_relations</a> : thm
<a name="line94"></a>    val <a href="#PERM_transitive-val">PERM_transitive</a> : thm
<a name="line95"></a>    val <a href="#QSORT3_DEF-val">QSORT3_DEF</a> : thm
<a name="line96"></a>    val <a href="#QSORT3_IND-val">QSORT3_IND</a> : thm
<a name="line97"></a>    val <a href="#QSORT3_MEM-val">QSORT3_MEM</a> : thm
<a name="line98"></a>    val <a href="#QSORT3_SORTED-val">QSORT3_SORTED</a> : thm
<a name="line99"></a>    val <a href="#QSORT3_SORTS-val">QSORT3_SORTS</a> : thm
<a name="line100"></a>    val <a href="#QSORT3_SPLIT-val">QSORT3_SPLIT</a> : thm
<a name="line101"></a>    val <a href="#QSORT3_STABLE-val">QSORT3_STABLE</a> : thm
<a name="line102"></a>    val <a href="#QSORT_DEF-val">QSORT_DEF</a> : thm
<a name="line103"></a>    val <a href="#QSORT_IND-val">QSORT_IND</a> : thm
<a name="line104"></a>    val <a href="#QSORT_MEM-val">QSORT_MEM</a> : thm
<a name="line105"></a>    val <a href="#QSORT_PERM-val">QSORT_PERM</a> : thm
<a name="line106"></a>    val <a href="#QSORT_SORTED-val">QSORT_SORTED</a> : thm
<a name="line107"></a>    val <a href="#QSORT_SORTS-val">QSORT_SORTS</a> : thm
<a name="line108"></a>    val <a href="#QSORT_eq_if_PERM-val">QSORT_eq_if_PERM</a> : thm
<a name="line109"></a>    val <a href="#SORTED_ALL_DISTINCT-val">SORTED_ALL_DISTINCT</a> : thm
<a name="line110"></a>    val <a href="#SORTED_APPEND-val">SORTED_APPEND</a> : thm
<a name="line111"></a>    val <a href="#SORTED_APPEND_IFF-val">SORTED_APPEND_IFF</a> : thm
<a name="line112"></a>    val <a href="#SORTED_DEF-val">SORTED_DEF</a> : thm
<a name="line113"></a>    val <a href="#SORTED_EL_LESS-val">SORTED_EL_LESS</a> : thm
<a name="line114"></a>    val <a href="#SORTED_EL_SUC-val">SORTED_EL_SUC</a> : thm
<a name="line115"></a>    val <a href="#SORTED_EQ-val">SORTED_EQ</a> : thm
<a name="line116"></a>    val <a href="#SORTED_EQ_PART-val">SORTED_EQ_PART</a> : thm
<a name="line117"></a>    val <a href="#SORTED_FILTER-val">SORTED_FILTER</a> : thm
<a name="line118"></a>    val <a href="#SORTED_GENLIST_PLUS-val">SORTED_GENLIST_PLUS</a> : thm
<a name="line119"></a>    val <a href="#SORTED_IND-val">SORTED_IND</a> : thm
<a name="line120"></a>    val <a href="#SORTED_NIL-val">SORTED_NIL</a> : thm
<a name="line121"></a>    val <a href="#SORTED_PERM_EQ-val">SORTED_PERM_EQ</a> : thm
<a name="line122"></a>    val <a href="#SORTED_SING-val">SORTED_SING</a> : thm
<a name="line123"></a>    val <a href="#SORTED_TL-val">SORTED_TL</a> : thm
<a name="line124"></a>    val <a href="#SORTED_weaken-val">SORTED_weaken</a> : thm
<a name="line125"></a>    val <a href="#SUM_IMAGE_count_MULT-val">SUM_IMAGE_count_MULT</a> : thm
<a name="line126"></a>    val <a href="#SUM_IMAGE_count_SUM_GENLIST-val">SUM_IMAGE_count_SUM_GENLIST</a> : thm
<a name="line127"></a>    val <a href="#less_sorted_eq-val">less_sorted_eq</a> : thm
<a name="line128"></a>    val <a href="#sorted_count_list-val">sorted_count_list</a> : thm
<a name="line129"></a>    val <a href="#sorted_filter-val">sorted_filter</a> : thm
<a name="line130"></a>    val <a href="#sorted_map-val">sorted_map</a> : thm
<a name="line131"></a>    val <a href="#sorted_perm_count_list-val">sorted_perm_count_list</a> : thm
<a name="line132"></a>    val <a href="#sum_of_sums-val">sum_of_sums</a> : thm
<a name="line133"></a>  
<a name="line134"></a>  val sorting_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line135"></a>(*
   [indexedLists] Parent theory of "sorting"
   
   [patternMatches] Parent theory of "sorting"
   
   [<a name="PART3_DEF-val"><b>PART3_DEF</b></a>]  Definition
      
      ⊢ (∀R h. PART3 R h [] = ([],[],[])) ∧
        ∀R h hd tl.
            PART3 R h (hd::tl) =
            if R h hd ∧ R hd h then (I ## CONS hd ## I) (PART3 R h tl)
            else if R hd h then (CONS hd ## I ## I) (PART3 R h tl)
            else (I ## I ## CONS hd) (PART3 R h tl)
   
   [<a name="PARTITION_DEF-val"><b>PARTITION_DEF</b></a>]  Definition
      
      ⊢ ∀P l. PARTITION P l = PART P l [] []
   
   [<a name="PART_DEF-val"><b>PART_DEF</b></a>]  Definition
      
      ⊢ (∀P l1 l2. PART P [] l1 l2 = (l1,l2)) ∧
        ∀P h rst l1 l2.
            PART P (h::rst) l1 l2 =
            if P h then PART P rst (h::l1) l2
            else PART P rst l1 (h::l2)
   
   [<a name="PERM_DEF-val"><b>PERM_DEF</b></a>]  Definition
      
      ⊢ ∀L1 L2. PERM L1 L2 ⇔ ∀x. FILTER ($= x) L1 = FILTER ($= x) L2
   
   [<a name="PERM_SINGLE_SWAP_DEF-val"><b>PERM_SINGLE_SWAP_DEF</b></a>]  Definition
      
      ⊢ ∀l1 l2.
            PERM_SINGLE_SWAP l1 l2 ⇔
            ∃x1 x2 x3. (l1 = x1 ⧺ x2 ⧺ x3) ∧ (l2 = x1 ⧺ x3 ⧺ x2)
   
   [<a name="SORTS_DEF-val"><b>SORTS_DEF</b></a>]  Definition
      
      ⊢ ∀f R. SORTS f R ⇔ ∀l. PERM l (f R l) ∧ SORTED R (f R l)
   
   [<a name="STABLE_DEF-val"><b>STABLE_DEF</b></a>]  Definition
      
      ⊢ ∀sort r.
            STABLE sort r ⇔
            SORTS sort r ∧
            ∀p.
                (∀x y. p x ∧ p y ⇒ r x y) ⇒
                ∀l. FILTER p l = FILTER p (sort r l)
   
   [<a name="ALL_DISTINCT_PERM-val"><b>ALL_DISTINCT_PERM</b></a>]  Theorem
      
      ⊢ ∀l1 l2. PERM l1 l2 ⇒ (ALL_DISTINCT l1 ⇔ ALL_DISTINCT l2)
   
   [<a name="ALL_DISTINCT_PERM_LIST_TO_SET_TO_LIST-val"><b>ALL_DISTINCT_PERM_LIST_TO_SET_TO_LIST</b></a>]  Theorem
      
      ⊢ ∀ls. ALL_DISTINCT ls ⇔ PERM ls (SET_TO_LIST (set ls))
   
   [<a name="ALL_DISTINCT_SORTED_WEAKEN-val"><b>ALL_DISTINCT_SORTED_WEAKEN</b></a>]  Theorem
      
      ⊢ ∀R R' ls.
            (∀x y. MEM x ls ∧ MEM y ls ∧ x ≠ y ⇒ (R x y ⇔ R' x y)) ∧
            ALL_DISTINCT ls ∧ SORTED R ls ⇒
            SORTED R' ls
   
   [<a name="APPEND_PERM_SYM-val"><b>APPEND_PERM_SYM</b></a>]  Theorem
      
      ⊢ ∀A B C. PERM (A ⧺ B) C ⇒ PERM (B ⧺ A) C
   
   [<a name="CONS_PERM-val"><b>CONS_PERM</b></a>]  Theorem
      
      ⊢ ∀x L M N. PERM L (M ⧺ N) ⇒ PERM (x::L) (M ⧺ x::N)
   
   [<a name="FILTER_EQ_LENGTHS_EQ-val"><b>FILTER_EQ_LENGTHS_EQ</b></a>]  Theorem
      
      ⊢ (LENGTH (FILTER ($= x) l1) = LENGTH (FILTER ($= x) l2)) ⇒
        (FILTER ($= x) l1 = FILTER ($= x) l2)
   
   [<a name="FILTER_EQ_REP-val"><b>FILTER_EQ_REP</b></a>]  Theorem
      
      ⊢ FILTER ($= x) l = REPLICATE (LENGTH (FILTER ($= x) l)) x
   
   [<a name="FOLDR_PERM-val"><b>FOLDR_PERM</b></a>]  Theorem
      
      ⊢ ∀f l1 l2 e.
            ASSOC f ∧ COMM f ⇒ PERM l1 l2 ⇒ (FOLDR f e l1 = FOLDR f e l2)
   
   [<a name="MEM_PERM-val"><b>MEM_PERM</b></a>]  Theorem
      
      ⊢ ∀l1 l2. PERM l1 l2 ⇒ ∀a. MEM a l1 ⇔ MEM a l2
   
   [<a name="PART3_FILTER-val"><b>PART3_FILTER</b></a>]  Theorem
      
      ⊢ ∀tl hd.
            PART3 R hd tl =
            (FILTER (λx. R x hd ∧ ¬R hd x) tl,
             FILTER (λx. R x hd ∧ R hd x) tl,FILTER (λx. ¬R x hd) tl)
   
   [<a name="PART_LENGTH-val"><b>PART_LENGTH</b></a>]  Theorem
      
      ⊢ ∀P L l1 l2 p q.
            ((p,q) = PART P L l1 l2) ⇒
            (LENGTH L + LENGTH l1 + LENGTH l2 = LENGTH p + LENGTH q)
   
   [<a name="PART_LENGTH_LEM-val"><b>PART_LENGTH_LEM</b></a>]  Theorem
      
      ⊢ ∀P L l1 l2 p q.
            ((p,q) = PART P L l1 l2) ⇒
            LENGTH p ≤ LENGTH L + LENGTH l1 + LENGTH l2 ∧
            LENGTH q ≤ LENGTH L + LENGTH l1 + LENGTH l2
   
   [<a name="PART_MEM-val"><b>PART_MEM</b></a>]  Theorem
      
      ⊢ ∀P L a1 a2 l1 l2.
            ((a1,a2) = PART P L l1 l2) ⇒
            ∀x. MEM x (L ⧺ (l1 ⧺ l2)) ⇔ MEM x (a1 ⧺ a2)
   
   [<a name="PARTs_HAVE_PROP-val"><b>PARTs_HAVE_PROP</b></a>]  Theorem
      
      ⊢ ∀P L A B l1 l2.
            ((A,B) = PART P L l1 l2) ∧ (∀x. MEM x l1 ⇒ P x) ∧
            (∀x. MEM x l2 ⇒ ¬P x) ⇒
            (∀z. MEM z A ⇒ P z) ∧ ∀z. MEM z B ⇒ ¬P z
   
   [<a name="PERM3-val"><b>PERM3</b></a>]  Theorem
      
      ⊢ ∀x a a' b b' c c'.
            (PERM a a' ∧ PERM b b' ∧ PERM c c') ∧ PERM x (a ⧺ b ⧺ c) ⇒
            PERM x (a' ⧺ b' ⧺ c')
   
   [<a name="PERM3_FILTER-val"><b>PERM3_FILTER</b></a>]  Theorem
      
      ⊢ ∀l h.
            PERM l
              (FILTER (λx. R x h ∧ ¬R h x) l ⧺
               FILTER (λx. R x h ∧ R h x) l ⧺ FILTER (λx. ¬R x h) l)
   
   [<a name="PERM_ALL_DISTINCT-val"><b>PERM_ALL_DISTINCT</b></a>]  Theorem
      
      ⊢ ∀l1 l2.
            ALL_DISTINCT l1 ∧ ALL_DISTINCT l2 ∧ (∀x. MEM x l1 ⇔ MEM x l2) ⇒
            PERM l1 l2
   
   [<a name="PERM_APPEND-val"><b>PERM_APPEND</b></a>]  Theorem
      
      ⊢ ∀l1 l2. PERM (l1 ⧺ l2) (l2 ⧺ l1)
   
   [<a name="PERM_APPEND_IFF-val"><b>PERM_APPEND_IFF</b></a>]  Theorem
      
      ⊢ (∀l l1 l2. PERM (l ⧺ l1) (l ⧺ l2) ⇔ PERM l1 l2) ∧
        ∀l l1 l2. PERM (l1 ⧺ l) (l2 ⧺ l) ⇔ PERM l1 l2
   
   [<a name="PERM_CONG-val"><b>PERM_CONG</b></a>]  Theorem
      
      ⊢ ∀L1 L2 L3 L4. PERM L1 L3 ∧ PERM L2 L4 ⇒ PERM (L1 ⧺ L2) (L3 ⧺ L4)
   
   [<a name="PERM_CONG_2-val"><b>PERM_CONG_2</b></a>]  Theorem
      
      ⊢ ∀l1 l1' l2 l2'.
            PERM l1 l1' ⇒ PERM l2 l2' ⇒ (PERM l1 l2 ⇔ PERM l1' l2')
   
   [<a name="PERM_CONG_APPEND_IFF-val"><b>PERM_CONG_APPEND_IFF</b></a>]  Theorem
      
      ⊢ ∀l l1 l1' l2 l2'.
            PERM l1 (l ⧺ l1') ⇒
            PERM l2 (l ⧺ l2') ⇒
            (PERM l1 l2 ⇔ PERM l1' l2')
   
   [<a name="PERM_CONS_EQ_APPEND-val"><b>PERM_CONS_EQ_APPEND</b></a>]  Theorem
      
      ⊢ ∀L h. PERM (h::t) L ⇔ ∃M N. (L = M ⧺ h::N) ∧ PERM t (M ⧺ N)
   
   [<a name="PERM_CONS_IFF-val"><b>PERM_CONS_IFF</b></a>]  Theorem
      
      ⊢ ∀x l2 l1. PERM (x::l1) (x::l2) ⇔ PERM l1 l2
   
   [<a name="PERM_EQC-val"><b>PERM_EQC</b></a>]  Theorem
      
      ⊢ PERM = PERM_SINGLE_SWAP^=
   
   [<a name="PERM_EQUIVALENCE-val"><b>PERM_EQUIVALENCE</b></a>]  Theorem
      
      ⊢ equivalence PERM
   
   [<a name="PERM_EQUIVALENCE_ALT_DEF-val"><b>PERM_EQUIVALENCE_ALT_DEF</b></a>]  Theorem
      
      ⊢ ∀x y. PERM x y ⇔ (PERM x = PERM y)
   
   [<a name="PERM_FILTER-val"><b>PERM_FILTER</b></a>]  Theorem
      
      ⊢ ∀P l1 l2. PERM l1 l2 ⇒ PERM (FILTER P l1) (FILTER P l2)
   
   [<a name="PERM_FUN_APPEND-val"><b>PERM_FUN_APPEND</b></a>]  Theorem
      
      ⊢ ∀l1 l2. PERM (l1 ⧺ l2) = PERM (l2 ⧺ l1)
   
   [<a name="PERM_FUN_APPEND_APPEND_1-val"><b>PERM_FUN_APPEND_APPEND_1</b></a>]  Theorem
      
      ⊢ ∀l1 l2 l3 l4.
            (PERM l1 = PERM (l2 ⧺ l3)) ⇒
            (PERM (l1 ⧺ l4) = PERM (l2 ⧺ (l3 ⧺ l4)))
   
   [<a name="PERM_FUN_APPEND_APPEND_2-val"><b>PERM_FUN_APPEND_APPEND_2</b></a>]  Theorem
      
      ⊢ ∀l1 l2 l3 l4.
            (PERM l1 = PERM (l2 ⧺ l3)) ⇒
            (PERM (l4 ⧺ l1) = PERM (l2 ⧺ (l4 ⧺ l3)))
   
   [<a name="PERM_FUN_APPEND_C-val"><b>PERM_FUN_APPEND_C</b></a>]  Theorem
      
      ⊢ ∀l1 l1' l2 l2'.
            (PERM l1 = PERM l1') ⇒
            (PERM l2 = PERM l2') ⇒
            (PERM (l1 ⧺ l2) = PERM (l1' ⧺ l2'))
   
   [<a name="PERM_FUN_APPEND_CONS-val"><b>PERM_FUN_APPEND_CONS</b></a>]  Theorem
      
      ⊢ ∀x l1 l2. PERM (l1 ⧺ x::l2) = PERM (x::l1 ⧺ l2)
   
   [<a name="PERM_FUN_APPEND_IFF-val"><b>PERM_FUN_APPEND_IFF</b></a>]  Theorem
      
      ⊢ ∀l l1 l2. (PERM l1 = PERM l2) ⇒ (PERM (l ⧺ l1) = PERM (l ⧺ l2))
   
   [<a name="PERM_FUN_CONG-val"><b>PERM_FUN_CONG</b></a>]  Theorem
      
      ⊢ ∀l1 l1' l2 l2'.
            (PERM l1 = PERM l1') ⇒
            (PERM l2 = PERM l2') ⇒
            (PERM l1 l2 ⇔ PERM l1' l2')
   
   [<a name="PERM_FUN_CONS-val"><b>PERM_FUN_CONS</b></a>]  Theorem
      
      ⊢ ∀x l1 l1'. (PERM l1 = PERM l1') ⇒ (PERM (x::l1) = PERM (x::l1'))
   
   [<a name="PERM_FUN_CONS_11_APPEND-val"><b>PERM_FUN_CONS_11_APPEND</b></a>]  Theorem
      
      ⊢ ∀y l1 l2 l3.
            (PERM l1 = PERM (l2 ⧺ l3)) ⇒ (PERM (y::l1) = PERM (l2 ⧺ y::l3))
   
   [<a name="PERM_FUN_CONS_11_SWAP_AT_FRONT-val"><b>PERM_FUN_CONS_11_SWAP_AT_FRONT</b></a>]  Theorem
      
      ⊢ ∀y l1 x l2.
            (PERM l1 = PERM (x::l2)) ⇒ (PERM (y::l1) = PERM (x::y::l2))
   
   [<a name="PERM_FUN_CONS_APPEND_1-val"><b>PERM_FUN_CONS_APPEND_1</b></a>]  Theorem
      
      ⊢ ∀l l1 x l2.
            (PERM l1 = PERM (x::l2)) ⇒ (PERM (l1 ⧺ l) = PERM (x::(l2 ⧺ l)))
   
   [<a name="PERM_FUN_CONS_APPEND_2-val"><b>PERM_FUN_CONS_APPEND_2</b></a>]  Theorem
      
      ⊢ ∀l l1 x l2.
            (PERM l1 = PERM (x::l2)) ⇒ (PERM (l ⧺ l1) = PERM (x::(l ⧺ l2)))
   
   [<a name="PERM_FUN_CONS_IFF-val"><b>PERM_FUN_CONS_IFF</b></a>]  Theorem
      
      ⊢ ∀x l1 l2. (PERM l1 = PERM l2) ⇒ (PERM (x::l1) = PERM (x::l2))
   
   [<a name="PERM_FUN_SPLIT-val"><b>PERM_FUN_SPLIT</b></a>]  Theorem
      
      ⊢ ∀l l1 l1' l2. PERM l (l1 ⧺ l2) ⇒ PERM l1' l1 ⇒ PERM l (l1' ⧺ l2)
   
   [<a name="PERM_FUN_SWAP_AT_FRONT-val"><b>PERM_FUN_SWAP_AT_FRONT</b></a>]  Theorem
      
      ⊢ ∀x y l. PERM (x::y::l) = PERM (y::x::l)
   
   [<a name="PERM_IND-val"><b>PERM_IND</b></a>]  Theorem
      
      ⊢ ∀P.
            P [] [] ∧ (∀x l1 l2. P l1 l2 ⇒ P (x::l1) (x::l2)) ∧
            (∀x y l1 l2. P l1 l2 ⇒ P (x::y::l1) (y::x::l2)) ∧
            (∀l1 l2 l3. P l1 l2 ∧ P l2 l3 ⇒ P l1 l3) ⇒
            ∀l1 l2. PERM l1 l2 ⇒ P l1 l2
   
   [<a name="PERM_INTRO-val"><b>PERM_INTRO</b></a>]  Theorem
      
      ⊢ ∀x y. (x = y) ⇒ PERM x y
   
   [<a name="PERM_LENGTH-val"><b>PERM_LENGTH</b></a>]  Theorem
      
      ⊢ ∀l1 l2. PERM l1 l2 ⇒ (LENGTH l1 = LENGTH l2)
   
   [<a name="PERM_LIST_TO_SET-val"><b>PERM_LIST_TO_SET</b></a>]  Theorem
      
      ⊢ ∀l1 l2. PERM l1 l2 ⇒ (set l1 = set l2)
   
   [<a name="PERM_MAP-val"><b>PERM_MAP</b></a>]  Theorem
      
      ⊢ ∀f l1 l2. PERM l1 l2 ⇒ PERM (MAP f l1) (MAP f l2)
   
   [<a name="PERM_MEM_EQ-val"><b>PERM_MEM_EQ</b></a>]  Theorem
      
      ⊢ ∀l1 l2. PERM l1 l2 ⇒ ∀x. MEM x l1 ⇔ MEM x l2
   
   [<a name="PERM_MONO-val"><b>PERM_MONO</b></a>]  Theorem
      
      ⊢ ∀l1 l2 x. PERM l1 l2 ⇒ PERM (x::l1) (x::l2)
   
   [<a name="PERM_NIL-val"><b>PERM_NIL</b></a>]  Theorem
      
      ⊢ ∀L. (PERM L [] ⇔ (L = [])) ∧ (PERM [] L ⇔ (L = []))
   
   [<a name="PERM_QSORT3-val"><b>PERM_QSORT3</b></a>]  Theorem
      
      ⊢ ∀l R. PERM l (QSORT3 R l)
   
   [<a name="PERM_REFL-val"><b>PERM_REFL</b></a>]  Theorem
      
      ⊢ ∀L. PERM L L
   
   [<a name="PERM_REVERSE-val"><b>PERM_REVERSE</b></a>]  Theorem
      
      ⊢ PERM ls (REVERSE ls)
   
   [<a name="PERM_REVERSE_EQ-val"><b>PERM_REVERSE_EQ</b></a>]  Theorem
      
      ⊢ (PERM (REVERSE l1) l2 ⇔ PERM l1 l2) ∧
        (PERM l1 (REVERSE l2) ⇔ PERM l1 l2)
   
   [<a name="PERM_REWR-val"><b>PERM_REWR</b></a>]  Theorem
      
      ⊢ ∀l r l1 l2. PERM l r ⇒ (PERM (l ⧺ l1) l2 ⇔ PERM (r ⧺ l1) l2)
   
   [<a name="PERM_RTC-val"><b>PERM_RTC</b></a>]  Theorem
      
      ⊢ PERM = PERM_SINGLE_SWAP^*
   
   [<a name="PERM_SET_TO_LIST_count_COUNT_LIST-val"><b>PERM_SET_TO_LIST_count_COUNT_LIST</b></a>]  Theorem
      
      ⊢ PERM (SET_TO_LIST (count n)) (COUNT_LIST n)
   
   [<a name="PERM_SING-val"><b>PERM_SING</b></a>]  Theorem
      
      ⊢ (PERM L [x] ⇔ (L = [x])) ∧ (PERM [x] L ⇔ (L = [x]))
   
   [<a name="PERM_SINGLE_SWAP_APPEND-val"><b>PERM_SINGLE_SWAP_APPEND</b></a>]  Theorem
      
      ⊢ PERM_SINGLE_SWAP (x2 ⧺ x3) (x3 ⧺ x2)
   
   [<a name="PERM_SINGLE_SWAP_CONS-val"><b>PERM_SINGLE_SWAP_CONS</b></a>]  Theorem
      
      ⊢ PERM_SINGLE_SWAP M N ⇒ PERM_SINGLE_SWAP (x::M) (x::N)
   
   [<a name="PERM_SINGLE_SWAP_I-val"><b>PERM_SINGLE_SWAP_I</b></a>]  Theorem
      
      ⊢ PERM_SINGLE_SWAP (x1 ⧺ x2 ⧺ x3) (x1 ⧺ x3 ⧺ x2)
   
   [<a name="PERM_SINGLE_SWAP_REFL-val"><b>PERM_SINGLE_SWAP_REFL</b></a>]  Theorem
      
      ⊢ ∀l. PERM_SINGLE_SWAP l l
   
   [<a name="PERM_SINGLE_SWAP_SYM-val"><b>PERM_SINGLE_SWAP_SYM</b></a>]  Theorem
      
      ⊢ ∀l1 l2. PERM_SINGLE_SWAP l1 l2 ⇔ PERM_SINGLE_SWAP l2 l1
   
   [<a name="PERM_SINGLE_SWAP_TC_CONS-val"><b>PERM_SINGLE_SWAP_TC_CONS</b></a>]  Theorem
      
      ⊢ ∀M N. PERM_SINGLE_SWAP⁺ M N ⇒ PERM_SINGLE_SWAP⁺ (x::M) (x::N)
   
   [<a name="PERM_SPLIT-val"><b>PERM_SPLIT</b></a>]  Theorem
      
      ⊢ ∀P l. PERM l (FILTER P l ⧺ FILTER ($~ ∘ P) l)
   
   [<a name="PERM_SPLIT_IF-val"><b>PERM_SPLIT_IF</b></a>]  Theorem
      
      ⊢ ∀P Q l. EVERY (λx. P x ⇔ ¬Q x) l ⇒ PERM l (FILTER P l ⧺ FILTER Q l)
   
   [<a name="PERM_STRONG_IND-val"><b>PERM_STRONG_IND</b></a>]  Theorem
      
      ⊢ ∀P.
            P [] [] ∧
            (∀x l1 l2. PERM l1 l2 ∧ P l1 l2 ⇒ P (x::l1) (x::l2)) ∧
            (∀x y l1 l2. PERM l1 l2 ∧ P l1 l2 ⇒ P (x::y::l1) (y::x::l2)) ∧
            (∀l1 l2 l3.
                 PERM l1 l2 ∧ P l1 l2 ∧ PERM l2 l3 ∧ P l2 l3 ⇒ P l1 l3) ⇒
            ∀l1 l2. PERM l1 l2 ⇒ P l1 l2
   
   [<a name="PERM_SUM-val"><b>PERM_SUM</b></a>]  Theorem
      
      ⊢ ∀l1 l2. PERM l1 l2 ⇒ (SUM l1 = SUM l2)
   
   [<a name="PERM_SWAP_AT_FRONT-val"><b>PERM_SWAP_AT_FRONT</b></a>]  Theorem
      
      ⊢ PERM (x::y::l1) (y::x::l2) ⇔ PERM l1 l2
   
   [<a name="PERM_SWAP_L_AT_FRONT-val"><b>PERM_SWAP_L_AT_FRONT</b></a>]  Theorem
      
      ⊢ ∀x y. PERM (x ⧺ y ⧺ l1) (y ⧺ x ⧺ l2) ⇔ PERM l1 l2
   
   [<a name="PERM_SYM-val"><b>PERM_SYM</b></a>]  Theorem
      
      ⊢ ∀l1 l2. PERM l1 l2 ⇔ PERM l2 l1
   
   [<a name="PERM_TC-val"><b>PERM_TC</b></a>]  Theorem
      
      ⊢ PERM = PERM_SINGLE_SWAP⁺
   
   [<a name="PERM_TRANS-val"><b>PERM_TRANS</b></a>]  Theorem
      
      ⊢ ∀x y z. PERM x y ∧ PERM y z ⇒ PERM x z
   
   [<a name="PERM_alt-val"><b>PERM_alt</b></a>]  Theorem
      
      ⊢ ∀L1 L2.
            PERM L1 L2 ⇔
            ∀x. LENGTH (FILTER ($= x) L1) = LENGTH (FILTER ($= x) L2)
   
   [<a name="PERM_lifts_equalities-val"><b>PERM_lifts_equalities</b></a>]  Theorem
      
      ⊢ ∀f.
            (∀x1 x2 x3. f (x1 ⧺ x2 ⧺ x3) = f (x1 ⧺ x3 ⧺ x2)) ⇒
            ∀x y. PERM x y ⇒ (f x = f y)
   
   [<a name="PERM_lifts_invariants-val"><b>PERM_lifts_invariants</b></a>]  Theorem
      
      ⊢ ∀P.
            (∀x1 x2 x3. P (x1 ⧺ x2 ⧺ x3) ⇒ P (x1 ⧺ x3 ⧺ x2)) ⇒
            ∀x y. P x ∧ PERM x y ⇒ P y
   
   [<a name="PERM_lifts_monotonicities-val"><b>PERM_lifts_monotonicities</b></a>]  Theorem
      
      ⊢ ∀f.
            (∀x1 x2 x3.
                 ∃x1' x2' x3'.
                     (f (x1 ⧺ x2 ⧺ x3) = x1' ⧺ x2' ⧺ x3') ∧
                     (f (x1 ⧺ x3 ⧺ x2) = x1' ⧺ x3' ⧺ x2')) ⇒
            ∀x y. PERM x y ⇒ PERM (f x) (f y)
   
   [<a name="PERM_lifts_transitive_relations-val"><b>PERM_lifts_transitive_relations</b></a>]  Theorem
      
      ⊢ ∀f Q.
            (∀x1 x2 x3. Q (f (x1 ⧺ x2 ⧺ x3)) (f (x1 ⧺ x3 ⧺ x2))) ∧
            transitive Q ⇒
            ∀x y. PERM x y ⇒ Q (f x) (f y)
   
   [<a name="PERM_transitive-val"><b>PERM_transitive</b></a>]  Theorem
      
      ⊢ transitive PERM
   
   [<a name="QSORT3_DEF-val"><b>QSORT3_DEF</b></a>]  Theorem
      
      ⊢ (∀R. QSORT3 R [] = []) ∧
        ∀tl hd R.
            QSORT3 R (hd::tl) =
            (let
               (lo,eq,hi) = PART3 R hd tl
             in
               QSORT3 R lo ⧺ hd::eq ⧺ QSORT3 R hi)
   
   [<a name="QSORT3_IND-val"><b>QSORT3_IND</b></a>]  Theorem
      
      ⊢ ∀P.
            (∀R. P R []) ∧
            (∀R hd tl.
                 (∀lo eq hi. ((lo,eq,hi) = PART3 R hd tl) ⇒ P R hi) ∧
                 (∀lo eq hi. ((lo,eq,hi) = PART3 R hd tl) ⇒ P R lo) ⇒
                 P R (hd::tl)) ⇒
            ∀v v1. P v v1
   
   [<a name="QSORT3_MEM-val"><b>QSORT3_MEM</b></a>]  Theorem
      
      ⊢ ∀R L x. MEM x (QSORT3 R L) ⇔ MEM x L
   
   [<a name="QSORT3_SORTED-val"><b>QSORT3_SORTED</b></a>]  Theorem
      
      ⊢ ∀R L. transitive R ∧ total R ⇒ SORTED R (QSORT3 R L)
   
   [<a name="QSORT3_SORTS-val"><b>QSORT3_SORTS</b></a>]  Theorem
      
      ⊢ ∀R. transitive R ∧ total R ⇒ SORTS QSORT3 R
   
   [<a name="QSORT3_SPLIT-val"><b>QSORT3_SPLIT</b></a>]  Theorem
      
      ⊢ ∀R.
            transitive R ∧ total R ⇒
            ∀l e.
                QSORT3 R l =
                QSORT3 R (FILTER (λx. R x e ∧ ¬R e x) l) ⧺
                FILTER (λx. R x e ∧ R e x) l ⧺
                QSORT3 R (FILTER (λx. ¬R x e) l)
   
   [<a name="QSORT3_STABLE-val"><b>QSORT3_STABLE</b></a>]  Theorem
      
      ⊢ ∀R. transitive R ∧ total R ⇒ STABLE QSORT3 R
   
   [<a name="QSORT_DEF-val"><b>QSORT_DEF</b></a>]  Theorem
      
      ⊢ (∀ord. QSORT ord [] = []) ∧
        ∀t ord h.
            QSORT ord (h::t) =
            (let
               (l1,l2) = PARTITION (λy. ord y h) t
             in
               QSORT ord l1 ⧺ [h] ⧺ QSORT ord l2)
   
   [<a name="QSORT_IND-val"><b>QSORT_IND</b></a>]  Theorem
      
      ⊢ ∀P.
            (∀ord. P ord []) ∧
            (∀ord h t.
                 (∀l1 l2. ((l1,l2) = PARTITION (λy. ord y h) t) ⇒ P ord l2) ∧
                 (∀l1 l2. ((l1,l2) = PARTITION (λy. ord y h) t) ⇒ P ord l1) ⇒
                 P ord (h::t)) ⇒
            ∀v v1. P v v1
   
   [<a name="QSORT_MEM-val"><b>QSORT_MEM</b></a>]  Theorem
      
      ⊢ ∀R L x. MEM x (QSORT R L) ⇔ MEM x L
   
   [<a name="QSORT_PERM-val"><b>QSORT_PERM</b></a>]  Theorem
      
      ⊢ ∀R L. PERM L (QSORT R L)
   
   [<a name="QSORT_SORTED-val"><b>QSORT_SORTED</b></a>]  Theorem
      
      ⊢ ∀R L. transitive R ∧ total R ⇒ SORTED R (QSORT R L)
   
   [<a name="QSORT_SORTS-val"><b>QSORT_SORTS</b></a>]  Theorem
      
      ⊢ ∀R. transitive R ∧ total R ⇒ SORTS QSORT R
   
   [<a name="QSORT_eq_if_PERM-val"><b>QSORT_eq_if_PERM</b></a>]  Theorem
      
      ⊢ ∀R.
            total R ∧ transitive R ∧ antisymmetric R ⇒
            ∀l1 l2. (QSORT R l1 = QSORT R l2) ⇔ PERM l1 l2
   
   [<a name="SORTED_ALL_DISTINCT-val"><b>SORTED_ALL_DISTINCT</b></a>]  Theorem
      
      ⊢ irreflexive R ∧ transitive R ⇒ ∀ls. SORTED R ls ⇒ ALL_DISTINCT ls
   
   [<a name="SORTED_APPEND-val"><b>SORTED_APPEND</b></a>]  Theorem
      
      ⊢ ∀R L1 L2.
            transitive R ∧ SORTED R L1 ∧ SORTED R L2 ∧
            (∀x y. MEM x L1 ∧ MEM y L2 ⇒ R x y) ⇒
            SORTED R (L1 ⧺ L2)
   
   [<a name="SORTED_APPEND_IFF-val"><b>SORTED_APPEND_IFF</b></a>]  Theorem
      
      ⊢ ∀R L1 L2.
            SORTED R (L1 ⧺ L2) ⇔
            SORTED R L1 ∧ SORTED R L2 ∧
            ((L1 = []) ∨ (L2 = []) ∨ R (LAST L1) (HD L2))
   
   [<a name="SORTED_DEF-val"><b>SORTED_DEF</b></a>]  Theorem
      
      ⊢ (∀R. SORTED R [] ⇔ T) ∧ (∀x R. SORTED R [x] ⇔ T) ∧
        ∀y x rst R. SORTED R (x::y::rst) ⇔ R x y ∧ SORTED R (y::rst)
   
   [<a name="SORTED_EL_LESS-val"><b>SORTED_EL_LESS</b></a>]  Theorem
      
      ⊢ ∀R.
            transitive R ⇒
            ∀ls.
                SORTED R ls ⇔
                ∀m n. m &lt; n ∧ n &lt; LENGTH ls ⇒ R (EL m ls) (EL n ls)
   
   [<a name="SORTED_EL_SUC-val"><b>SORTED_EL_SUC</b></a>]  Theorem
      
      ⊢ ∀R ls.
            SORTED R ls ⇔
            ∀n. SUC n &lt; LENGTH ls ⇒ R (EL n ls) (EL (SUC n) ls)
   
   [<a name="SORTED_EQ-val"><b>SORTED_EQ</b></a>]  Theorem
      
      ⊢ ∀R L x.
            transitive R ⇒
            (SORTED R (x::L) ⇔ SORTED R L ∧ ∀y. MEM y L ⇒ R x y)
   
   [<a name="SORTED_EQ_PART-val"><b>SORTED_EQ_PART</b></a>]  Theorem
      
      ⊢ ∀l R. transitive R ⇒ SORTED R (FILTER (λx. R x hd ∧ R hd x) l)
   
   [<a name="SORTED_FILTER-val"><b>SORTED_FILTER</b></a>]  Theorem
      
      ⊢ ∀R ls P. transitive R ∧ SORTED R ls ⇒ SORTED R (FILTER P ls)
   
   [<a name="SORTED_GENLIST_PLUS-val"><b>SORTED_GENLIST_PLUS</b></a>]  Theorem
      
      ⊢ ∀n k. SORTED $&lt; (GENLIST ($+ k) n)
   
   [<a name="SORTED_IND-val"><b>SORTED_IND</b></a>]  Theorem
      
      ⊢ ∀P.
            (∀R. P R []) ∧ (∀R x. P R [x]) ∧
            (∀R x y rst. P R (y::rst) ⇒ P R (x::y::rst)) ⇒
            ∀v v1. P v v1
   
   [<a name="SORTED_NIL-val"><b>SORTED_NIL</b></a>]  Theorem
      
      ⊢ ∀R. SORTED R []
   
   [<a name="SORTED_PERM_EQ-val"><b>SORTED_PERM_EQ</b></a>]  Theorem
      
      ⊢ ∀R.
            transitive R ∧ antisymmetric R ⇒
            ∀l1 l2. SORTED R l1 ∧ SORTED R l2 ∧ PERM l1 l2 ⇒ (l1 = l2)
   
   [<a name="SORTED_SING-val"><b>SORTED_SING</b></a>]  Theorem
      
      ⊢ ∀R x. SORTED R [x]
   
   [<a name="SORTED_TL-val"><b>SORTED_TL</b></a>]  Theorem
      
      ⊢ SORTED R (x::xs) ⇒ SORTED R xs
   
   [<a name="SORTED_weaken-val"><b>SORTED_weaken</b></a>]  Theorem
      
      ⊢ ∀R R' ls.
            SORTED R ls ∧ (∀x y. MEM x ls ∧ MEM y ls ∧ R x y ⇒ R' x y) ⇒
            SORTED R' ls
   
   [<a name="SUM_IMAGE_count_MULT-val"><b>SUM_IMAGE_count_MULT</b></a>]  Theorem
      
      ⊢ (∀m. m &lt; n ⇒ (g m = ∑ (λx. f (x + k * m)) (count k))) ⇒
        (∑ f (count (k * n)) = ∑ g (count n))
   
   [<a name="SUM_IMAGE_count_SUM_GENLIST-val"><b>SUM_IMAGE_count_SUM_GENLIST</b></a>]  Theorem
      
      ⊢ ∑ f (count n) = SUM (GENLIST f n)
   
   [<a name="less_sorted_eq-val"><b>less_sorted_eq</b></a>]  Theorem
      
      ⊢ ∀L x. SORTED $&lt; (x::L) ⇔ SORTED $&lt; L ∧ ∀y. MEM y L ⇒ x &lt; y
   
   [<a name="sorted_count_list-val"><b>sorted_count_list</b></a>]  Theorem
      
      ⊢ ∀n. SORTED $&lt;= (COUNT_LIST n)
   
   [<a name="sorted_filter-val"><b>sorted_filter</b></a>]  Theorem
      
      ⊢ ∀R ls. transitive R ⇒ SORTED R ls ⇒ SORTED R (FILTER P ls)
   
   [<a name="sorted_map-val"><b>sorted_map</b></a>]  Theorem
      
      ⊢ ∀R f l.
            transitive R ⇒ (SORTED R (MAP f l) ⇔ SORTED (inv_image R f) l)
   
   [<a name="sorted_perm_count_list-val"><b>sorted_perm_count_list</b></a>]  Theorem
      
      ⊢ ∀y f l n.
            SORTED (inv_image $&lt;= f) l ∧ PERM (MAP f l) (COUNT_LIST n) ⇒
            (MAP f l = COUNT_LIST n)
   
   [<a name="sum_of_sums-val"><b>sum_of_sums</b></a>]  Theorem
      
      ⊢ ∑ (λm. ∑ (f m) (count a)) (count b) =
        ∑ (λm. f (m DIV a) (m MOD a)) (count (a * b))
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/sort/sortingScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-11</a></em></p></body></html>
