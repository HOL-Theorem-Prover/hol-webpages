<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure binary_ieeeTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure binary_ieeeTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/floating-point/binary_ieeeScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature binary_ieeeTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#ULP_primitive_def-val">ULP_primitive_def</a> : thm
<a name="line7"></a>    val <a href="#check_for_signalling_def-val">check_for_signalling_def</a> : thm
<a name="line8"></a>    val <a href="#clear_flags_def-val">clear_flags_def</a> : thm
<a name="line9"></a>    val <a href="#closest_def-val">closest_def</a> : thm
<a name="line10"></a>    val <a href="#closest_such_def-val">closest_such_def</a> : thm
<a name="line11"></a>    val <a href="#dividezero_flags_def-val">dividezero_flags_def</a> : thm
<a name="line12"></a>    val <a href="#exponent_boundary_def-val">exponent_boundary_def</a> : thm
<a name="line13"></a>    val <a href="#flags_DivideByZero-val">flags_DivideByZero</a> : thm
<a name="line14"></a>    val <a href="#flags_DivideByZero_fupd-val">flags_DivideByZero_fupd</a> : thm
<a name="line15"></a>    val <a href="#flags_InvalidOp-val">flags_InvalidOp</a> : thm
<a name="line16"></a>    val <a href="#flags_InvalidOp_fupd-val">flags_InvalidOp_fupd</a> : thm
<a name="line17"></a>    val <a href="#flags_Overflow-val">flags_Overflow</a> : thm
<a name="line18"></a>    val <a href="#flags_Overflow_fupd-val">flags_Overflow_fupd</a> : thm
<a name="line19"></a>    val <a href="#flags_Precision-val">flags_Precision</a> : thm
<a name="line20"></a>    val <a href="#flags_Precision_fupd-val">flags_Precision_fupd</a> : thm
<a name="line21"></a>    val <a href="#flags_TY_DEF-val">flags_TY_DEF</a> : thm
<a name="line22"></a>    val <a href="#flags_Underflow_AfterRounding-val">flags_Underflow_AfterRounding</a> : thm
<a name="line23"></a>    val <a href="#flags_Underflow_AfterRounding_fupd-val">flags_Underflow_AfterRounding_fupd</a> : thm
<a name="line24"></a>    val <a href="#flags_Underflow_BeforeRounding-val">flags_Underflow_BeforeRounding</a> : thm
<a name="line25"></a>    val <a href="#flags_Underflow_BeforeRounding_fupd-val">flags_Underflow_BeforeRounding_fupd</a> : thm
<a name="line26"></a>    val <a href="#flags_case_def-val">flags_case_def</a> : thm
<a name="line27"></a>    val <a href="#flags_size_def-val">flags_size_def</a> : thm
<a name="line28"></a>    val <a href="#float_Exponent-val">float_Exponent</a> : thm
<a name="line29"></a>    val <a href="#float_Exponent_fupd-val">float_Exponent_fupd</a> : thm
<a name="line30"></a>    val <a href="#float_Sign-val">float_Sign</a> : thm
<a name="line31"></a>    val <a href="#float_Sign_fupd-val">float_Sign_fupd</a> : thm
<a name="line32"></a>    val <a href="#float_Significand-val">float_Significand</a> : thm
<a name="line33"></a>    val <a href="#float_Significand_fupd-val">float_Significand_fupd</a> : thm
<a name="line34"></a>    val <a href="#float_TY_DEF-val">float_TY_DEF</a> : thm
<a name="line35"></a>    val <a href="#float_abs_def-val">float_abs_def</a> : thm
<a name="line36"></a>    val <a href="#float_add_def-val">float_add_def</a> : thm
<a name="line37"></a>    val <a href="#float_bottom_def-val">float_bottom_def</a> : thm
<a name="line38"></a>    val <a href="#float_case_def-val">float_case_def</a> : thm
<a name="line39"></a>    val <a href="#float_compare_BIJ-val">float_compare_BIJ</a> : thm
<a name="line40"></a>    val <a href="#float_compare_CASE-val">float_compare_CASE</a> : thm
<a name="line41"></a>    val <a href="#float_compare_TY_DEF-val">float_compare_TY_DEF</a> : thm
<a name="line42"></a>    val <a href="#float_compare_def-val">float_compare_def</a> : thm
<a name="line43"></a>    val <a href="#float_compare_size_def-val">float_compare_size_def</a> : thm
<a name="line44"></a>    val <a href="#float_div_def-val">float_div_def</a> : thm
<a name="line45"></a>    val <a href="#float_equal_def-val">float_equal_def</a> : thm
<a name="line46"></a>    val <a href="#float_greater_equal_def-val">float_greater_equal_def</a> : thm
<a name="line47"></a>    val <a href="#float_greater_than_def-val">float_greater_than_def</a> : thm
<a name="line48"></a>    val <a href="#float_is_finite_def-val">float_is_finite_def</a> : thm
<a name="line49"></a>    val <a href="#float_is_infinite_def-val">float_is_infinite_def</a> : thm
<a name="line50"></a>    val <a href="#float_is_integral_def-val">float_is_integral_def</a> : thm
<a name="line51"></a>    val <a href="#float_is_nan_def-val">float_is_nan_def</a> : thm
<a name="line52"></a>    val <a href="#float_is_normal_def-val">float_is_normal_def</a> : thm
<a name="line53"></a>    val <a href="#float_is_signalling_def-val">float_is_signalling_def</a> : thm
<a name="line54"></a>    val <a href="#float_is_subnormal_def-val">float_is_subnormal_def</a> : thm
<a name="line55"></a>    val <a href="#float_is_zero_def-val">float_is_zero_def</a> : thm
<a name="line56"></a>    val <a href="#float_less_equal_def-val">float_less_equal_def</a> : thm
<a name="line57"></a>    val <a href="#float_less_than_def-val">float_less_than_def</a> : thm
<a name="line58"></a>    val <a href="#float_minus_infinity_def-val">float_minus_infinity_def</a> : thm
<a name="line59"></a>    val <a href="#float_minus_min_def-val">float_minus_min_def</a> : thm
<a name="line60"></a>    val <a href="#float_minus_zero_def-val">float_minus_zero_def</a> : thm
<a name="line61"></a>    val <a href="#float_mul_add_def-val">float_mul_add_def</a> : thm
<a name="line62"></a>    val <a href="#float_mul_def-val">float_mul_def</a> : thm
<a name="line63"></a>    val <a href="#float_mul_sub_def-val">float_mul_sub_def</a> : thm
<a name="line64"></a>    val <a href="#float_negate_def-val">float_negate_def</a> : thm
<a name="line65"></a>    val <a href="#float_plus_infinity_def-val">float_plus_infinity_def</a> : thm
<a name="line66"></a>    val <a href="#float_plus_min_def-val">float_plus_min_def</a> : thm
<a name="line67"></a>    val <a href="#float_plus_zero_def-val">float_plus_zero_def</a> : thm
<a name="line68"></a>    val <a href="#float_round_def-val">float_round_def</a> : thm
<a name="line69"></a>    val <a href="#float_round_to_integral_def-val">float_round_to_integral_def</a> : thm
<a name="line70"></a>    val <a href="#float_round_with_flags_def-val">float_round_with_flags_def</a> : thm
<a name="line71"></a>    val <a href="#float_size_def-val">float_size_def</a> : thm
<a name="line72"></a>    val <a href="#float_some_qnan_def-val">float_some_qnan_def</a> : thm
<a name="line73"></a>    val <a href="#float_sqrt_def-val">float_sqrt_def</a> : thm
<a name="line74"></a>    val <a href="#float_sub_def-val">float_sub_def</a> : thm
<a name="line75"></a>    val <a href="#float_to_int_def-val">float_to_int_def</a> : thm
<a name="line76"></a>    val <a href="#float_to_real_def-val">float_to_real_def</a> : thm
<a name="line77"></a>    val <a href="#float_top_def-val">float_top_def</a> : thm
<a name="line78"></a>    val <a href="#float_value_TY_DEF-val">float_value_TY_DEF</a> : thm
<a name="line79"></a>    val <a href="#float_value_case_def-val">float_value_case_def</a> : thm
<a name="line80"></a>    val <a href="#float_value_def-val">float_value_def</a> : thm
<a name="line81"></a>    val <a href="#float_value_size_def-val">float_value_size_def</a> : thm
<a name="line82"></a>    val <a href="#fp_op_TY_DEF-val">fp_op_TY_DEF</a> : thm
<a name="line83"></a>    val <a href="#fp_op_case_def-val">fp_op_case_def</a> : thm
<a name="line84"></a>    val <a href="#fp_op_size_def-val">fp_op_size_def</a> : thm
<a name="line85"></a>    val <a href="#integral_round_def-val">integral_round_def</a> : thm
<a name="line86"></a>    val <a href="#invalidop_flags_def-val">invalidop_flags_def</a> : thm
<a name="line87"></a>    val <a href="#is_closest_def-val">is_closest_def</a> : thm
<a name="line88"></a>    val <a href="#is_integral_def-val">is_integral_def</a> : thm
<a name="line89"></a>    val <a href="#largest_def-val">largest_def</a> : thm
<a name="line90"></a>    val <a href="#real_to_float_def-val">real_to_float_def</a> : thm
<a name="line91"></a>    val <a href="#real_to_float_with_flags_def-val">real_to_float_with_flags_def</a> : thm
<a name="line92"></a>    val <a href="#round_def-val">round_def</a> : thm
<a name="line93"></a>    val <a href="#rounding_BIJ-val">rounding_BIJ</a> : thm
<a name="line94"></a>    val <a href="#rounding_CASE-val">rounding_CASE</a> : thm
<a name="line95"></a>    val <a href="#rounding_TY_DEF-val">rounding_TY_DEF</a> : thm
<a name="line96"></a>    val <a href="#rounding_size_def-val">rounding_size_def</a> : thm
<a name="line97"></a>    val <a href="#threshold_def-val">threshold_def</a> : thm
<a name="line98"></a>    val <a href="#ulp_def-val">ulp_def</a> : thm
<a name="line99"></a>  
<a name="line100"></a>  (*  Theorems  *)
<a name="line101"></a>    val <a href="#EXISTS_flags-val">EXISTS_flags</a> : thm
<a name="line102"></a>    val <a href="#EXISTS_float-val">EXISTS_float</a> : thm
<a name="line103"></a>    val <a href="#FORALL_flags-val">FORALL_flags</a> : thm
<a name="line104"></a>    val <a href="#FORALL_float-val">FORALL_float</a> : thm
<a name="line105"></a>    val <a href="#ULP_def-val">ULP_def</a> : thm
<a name="line106"></a>    val <a href="#ULP_ind-val">ULP_ind</a> : thm
<a name="line107"></a>    val <a href="#ULP_le_mono-val">ULP_le_mono</a> : thm
<a name="line108"></a>    val <a href="#abs_float_value-val">abs_float_value</a> : thm
<a name="line109"></a>    val <a href="#bottom_properties-val">bottom_properties</a> : thm
<a name="line110"></a>    val <a href="#datatype_flags-val">datatype_flags</a> : thm
<a name="line111"></a>    val <a href="#datatype_float-val">datatype_float</a> : thm
<a name="line112"></a>    val <a href="#datatype_float_compare-val">datatype_float_compare</a> : thm
<a name="line113"></a>    val <a href="#datatype_float_value-val">datatype_float_value</a> : thm
<a name="line114"></a>    val <a href="#datatype_fp_op-val">datatype_fp_op</a> : thm
<a name="line115"></a>    val <a href="#datatype_rounding-val">datatype_rounding</a> : thm
<a name="line116"></a>    val <a href="#diff_float_ULP-val">diff_float_ULP</a> : thm
<a name="line117"></a>    val <a href="#diff_lt_ulp_eq0-val">diff_lt_ulp_eq0</a> : thm
<a name="line118"></a>    val <a href="#diff_lt_ulp_even-val">diff_lt_ulp_even</a> : thm
<a name="line119"></a>    val <a href="#diff_lt_ulp_even4-val">diff_lt_ulp_even4</a> : thm
<a name="line120"></a>    val <a href="#div_eq0-val">div_eq0</a> : thm
<a name="line121"></a>    val <a href="#exp_ge2-val">exp_ge2</a> : thm
<a name="line122"></a>    val <a href="#exp_gt2-val">exp_gt2</a> : thm
<a name="line123"></a>    val <a href="#flags_11-val">flags_11</a> : thm
<a name="line124"></a>    val <a href="#flags_Axiom-val">flags_Axiom</a> : thm
<a name="line125"></a>    val <a href="#flags_accessors-val">flags_accessors</a> : thm
<a name="line126"></a>    val <a href="#flags_accfupds-val">flags_accfupds</a> : thm
<a name="line127"></a>    val <a href="#flags_case_cong-val">flags_case_cong</a> : thm
<a name="line128"></a>    val <a href="#flags_case_eq-val">flags_case_eq</a> : thm
<a name="line129"></a>    val <a href="#flags_component_equality-val">flags_component_equality</a> : thm
<a name="line130"></a>    val <a href="#flags_fn_updates-val">flags_fn_updates</a> : thm
<a name="line131"></a>    val <a href="#flags_fupdcanon-val">flags_fupdcanon</a> : thm
<a name="line132"></a>    val <a href="#flags_fupdcanon_comp-val">flags_fupdcanon_comp</a> : thm
<a name="line133"></a>    val <a href="#flags_fupdfupds-val">flags_fupdfupds</a> : thm
<a name="line134"></a>    val <a href="#flags_fupdfupds_comp-val">flags_fupdfupds_comp</a> : thm
<a name="line135"></a>    val <a href="#flags_induction-val">flags_induction</a> : thm
<a name="line136"></a>    val <a href="#flags_literal_11-val">flags_literal_11</a> : thm
<a name="line137"></a>    val <a href="#flags_literal_nchotomy-val">flags_literal_nchotomy</a> : thm
<a name="line138"></a>    val <a href="#flags_nchotomy-val">flags_nchotomy</a> : thm
<a name="line139"></a>    val <a href="#flags_updates_eq_literal-val">flags_updates_eq_literal</a> : thm
<a name="line140"></a>    val <a href="#float_11-val">float_11</a> : thm
<a name="line141"></a>    val <a href="#float_Axiom-val">float_Axiom</a> : thm
<a name="line142"></a>    val <a href="#float_accessors-val">float_accessors</a> : thm
<a name="line143"></a>    val <a href="#float_accfupds-val">float_accfupds</a> : thm
<a name="line144"></a>    val <a href="#float_add_compute-val">float_add_compute</a> : thm
<a name="line145"></a>    val <a href="#float_add_finite-val">float_add_finite</a> : thm
<a name="line146"></a>    val <a href="#float_add_finite_minus_infinity-val">float_add_finite_minus_infinity</a> : thm
<a name="line147"></a>    val <a href="#float_add_finite_plus_infinity-val">float_add_finite_plus_infinity</a> : thm
<a name="line148"></a>    val <a href="#float_add_minus_infinity_finite-val">float_add_minus_infinity_finite</a> : thm
<a name="line149"></a>    val <a href="#float_add_nan-val">float_add_nan</a> : thm
<a name="line150"></a>    val <a href="#float_add_plus_infinity_finite-val">float_add_plus_infinity_finite</a> : thm
<a name="line151"></a>    val <a href="#float_case_cong-val">float_case_cong</a> : thm
<a name="line152"></a>    val <a href="#float_case_eq-val">float_case_eq</a> : thm
<a name="line153"></a>    val <a href="#float_cases-val">float_cases</a> : thm
<a name="line154"></a>    val <a href="#float_cases_finite-val">float_cases_finite</a> : thm
<a name="line155"></a>    val <a href="#float_compare2num_11-val">float_compare2num_11</a> : thm
<a name="line156"></a>    val <a href="#float_compare2num_ONTO-val">float_compare2num_ONTO</a> : thm
<a name="line157"></a>    val <a href="#float_compare2num_num2float_compare-val">float_compare2num_num2float_compare</a> : thm
<a name="line158"></a>    val <a href="#float_compare2num_thm-val">float_compare2num_thm</a> : thm
<a name="line159"></a>    val <a href="#float_compare_Axiom-val">float_compare_Axiom</a> : thm
<a name="line160"></a>    val <a href="#float_compare_EQ_float_compare-val">float_compare_EQ_float_compare</a> : thm
<a name="line161"></a>    val <a href="#float_compare_case_cong-val">float_compare_case_cong</a> : thm
<a name="line162"></a>    val <a href="#float_compare_case_def-val">float_compare_case_def</a> : thm
<a name="line163"></a>    val <a href="#float_compare_case_eq-val">float_compare_case_eq</a> : thm
<a name="line164"></a>    val <a href="#float_compare_distinct-val">float_compare_distinct</a> : thm
<a name="line165"></a>    val <a href="#float_compare_induction-val">float_compare_induction</a> : thm
<a name="line166"></a>    val <a href="#float_compare_nchotomy-val">float_compare_nchotomy</a> : thm
<a name="line167"></a>    val <a href="#float_component_equality-val">float_component_equality</a> : thm
<a name="line168"></a>    val <a href="#float_components-val">float_components</a> : thm
<a name="line169"></a>    val <a href="#float_distinct-val">float_distinct</a> : thm
<a name="line170"></a>    val <a href="#float_distinct_finite-val">float_distinct_finite</a> : thm
<a name="line171"></a>    val <a href="#float_div_compute-val">float_div_compute</a> : thm
<a name="line172"></a>    val <a href="#float_div_finite-val">float_div_finite</a> : thm
<a name="line173"></a>    val <a href="#float_div_finite_minus_infinity-val">float_div_finite_minus_infinity</a> : thm
<a name="line174"></a>    val <a href="#float_div_finite_plus_infinity-val">float_div_finite_plus_infinity</a> : thm
<a name="line175"></a>    val <a href="#float_div_minus_infinity_finite-val">float_div_minus_infinity_finite</a> : thm
<a name="line176"></a>    val <a href="#float_div_nan-val">float_div_nan</a> : thm
<a name="line177"></a>    val <a href="#float_div_plus_infinity_finite-val">float_div_plus_infinity_finite</a> : thm
<a name="line178"></a>    val <a href="#float_fn_updates-val">float_fn_updates</a> : thm
<a name="line179"></a>    val <a href="#float_fupdcanon-val">float_fupdcanon</a> : thm
<a name="line180"></a>    val <a href="#float_fupdcanon_comp-val">float_fupdcanon_comp</a> : thm
<a name="line181"></a>    val <a href="#float_fupdfupds-val">float_fupdfupds</a> : thm
<a name="line182"></a>    val <a href="#float_fupdfupds_comp-val">float_fupdfupds_comp</a> : thm
<a name="line183"></a>    val <a href="#float_induction-val">float_induction</a> : thm
<a name="line184"></a>    val <a href="#float_infinities-val">float_infinities</a> : thm
<a name="line185"></a>    val <a href="#float_infinities_distinct-val">float_infinities_distinct</a> : thm
<a name="line186"></a>    val <a href="#float_infinity_negate_abs-val">float_infinity_negate_abs</a> : thm
<a name="line187"></a>    val <a href="#float_is_distinct-val">float_is_distinct</a> : thm
<a name="line188"></a>    val <a href="#float_is_finite-val">float_is_finite</a> : thm
<a name="line189"></a>    val <a href="#float_is_zero-val">float_is_zero</a> : thm
<a name="line190"></a>    val <a href="#float_is_zero_to_real-val">float_is_zero_to_real</a> : thm
<a name="line191"></a>    val <a href="#float_literal_11-val">float_literal_11</a> : thm
<a name="line192"></a>    val <a href="#float_literal_nchotomy-val">float_literal_nchotomy</a> : thm
<a name="line193"></a>    val <a href="#float_minus_infinity-val">float_minus_infinity</a> : thm
<a name="line194"></a>    val <a href="#float_minus_zero-val">float_minus_zero</a> : thm
<a name="line195"></a>    val <a href="#float_mul_compute-val">float_mul_compute</a> : thm
<a name="line196"></a>    val <a href="#float_mul_finite-val">float_mul_finite</a> : thm
<a name="line197"></a>    val <a href="#float_mul_finite_minus_infinity-val">float_mul_finite_minus_infinity</a> : thm
<a name="line198"></a>    val <a href="#float_mul_finite_plus_infinity-val">float_mul_finite_plus_infinity</a> : thm
<a name="line199"></a>    val <a href="#float_mul_minus_infinity_finite-val">float_mul_minus_infinity_finite</a> : thm
<a name="line200"></a>    val <a href="#float_mul_nan-val">float_mul_nan</a> : thm
<a name="line201"></a>    val <a href="#float_mul_plus_infinity_finite-val">float_mul_plus_infinity_finite</a> : thm
<a name="line202"></a>    val <a href="#float_nchotomy-val">float_nchotomy</a> : thm
<a name="line203"></a>    val <a href="#float_negate_negate-val">float_negate_negate</a> : thm
<a name="line204"></a>    val <a href="#float_round_bottom-val">float_round_bottom</a> : thm
<a name="line205"></a>    val <a href="#float_round_minus_infinity-val">float_round_minus_infinity</a> : thm
<a name="line206"></a>    val <a href="#float_round_non_zero-val">float_round_non_zero</a> : thm
<a name="line207"></a>    val <a href="#float_round_plus_infinity-val">float_round_plus_infinity</a> : thm
<a name="line208"></a>    val <a href="#float_round_roundTowardNegative_minus_infinity-val">float_round_roundTowardNegative_minus_infinity</a> : thm
<a name="line209"></a>    val <a href="#float_round_roundTowardNegative_top-val">float_round_roundTowardNegative_top</a> : thm
<a name="line210"></a>    val <a href="#float_round_roundTowardPositive_bottom-val">float_round_roundTowardPositive_bottom</a> : thm
<a name="line211"></a>    val <a href="#float_round_roundTowardPositive_plus_infinity-val">float_round_roundTowardPositive_plus_infinity</a> : thm
<a name="line212"></a>    val <a href="#float_round_roundTowardZero_bottom-val">float_round_roundTowardZero_bottom</a> : thm
<a name="line213"></a>    val <a href="#float_round_roundTowardZero_top-val">float_round_roundTowardZero_top</a> : thm
<a name="line214"></a>    val <a href="#float_round_to_integral_compute-val">float_round_to_integral_compute</a> : thm
<a name="line215"></a>    val <a href="#float_round_top-val">float_round_top</a> : thm
<a name="line216"></a>    val <a href="#float_sets-val">float_sets</a> : thm
<a name="line217"></a>    val <a href="#float_sub_compute-val">float_sub_compute</a> : thm
<a name="line218"></a>    val <a href="#float_sub_finite-val">float_sub_finite</a> : thm
<a name="line219"></a>    val <a href="#float_sub_finite_minus_infinity-val">float_sub_finite_minus_infinity</a> : thm
<a name="line220"></a>    val <a href="#float_sub_finite_plus_infinity-val">float_sub_finite_plus_infinity</a> : thm
<a name="line221"></a>    val <a href="#float_sub_minus_infinity_finite-val">float_sub_minus_infinity_finite</a> : thm
<a name="line222"></a>    val <a href="#float_sub_nan-val">float_sub_nan</a> : thm
<a name="line223"></a>    val <a href="#float_sub_plus_infinity_finite-val">float_sub_plus_infinity_finite</a> : thm
<a name="line224"></a>    val <a href="#float_tests-val">float_tests</a> : thm
<a name="line225"></a>    val <a href="#float_to_real-val">float_to_real</a> : thm
<a name="line226"></a>    val <a href="#float_to_real_eq-val">float_to_real_eq</a> : thm
<a name="line227"></a>    val <a href="#float_to_real_negate-val">float_to_real_negate</a> : thm
<a name="line228"></a>    val <a href="#float_updates_eq_literal-val">float_updates_eq_literal</a> : thm
<a name="line229"></a>    val <a href="#float_value_11-val">float_value_11</a> : thm
<a name="line230"></a>    val <a href="#float_value_Axiom-val">float_value_Axiom</a> : thm
<a name="line231"></a>    val <a href="#float_value_case_cong-val">float_value_case_cong</a> : thm
<a name="line232"></a>    val <a href="#float_value_case_eq-val">float_value_case_eq</a> : thm
<a name="line233"></a>    val <a href="#float_value_distinct-val">float_value_distinct</a> : thm
<a name="line234"></a>    val <a href="#float_value_induction-val">float_value_induction</a> : thm
<a name="line235"></a>    val <a href="#float_value_nchotomy-val">float_value_nchotomy</a> : thm
<a name="line236"></a>    val <a href="#float_values-val">float_values</a> : thm
<a name="line237"></a>    val <a href="#fp_op_11-val">fp_op_11</a> : thm
<a name="line238"></a>    val <a href="#fp_op_Axiom-val">fp_op_Axiom</a> : thm
<a name="line239"></a>    val <a href="#fp_op_case_cong-val">fp_op_case_cong</a> : thm
<a name="line240"></a>    val <a href="#fp_op_case_eq-val">fp_op_case_eq</a> : thm
<a name="line241"></a>    val <a href="#fp_op_distinct-val">fp_op_distinct</a> : thm
<a name="line242"></a>    val <a href="#fp_op_induction-val">fp_op_induction</a> : thm
<a name="line243"></a>    val <a href="#fp_op_nchotomy-val">fp_op_nchotomy</a> : thm
<a name="line244"></a>    val <a href="#infinity_properties-val">infinity_properties</a> : thm
<a name="line245"></a>    val <a href="#largest-val">largest</a> : thm
<a name="line246"></a>    val <a href="#largest_is_positive-val">largest_is_positive</a> : thm
<a name="line247"></a>    val <a href="#largest_is_top-val">largest_is_top</a> : thm
<a name="line248"></a>    val <a href="#largest_lt_threshold-val">largest_lt_threshold</a> : thm
<a name="line249"></a>    val <a href="#le2-val">le2</a> : thm
<a name="line250"></a>    val <a href="#less_than_ulp-val">less_than_ulp</a> : thm
<a name="line251"></a>    val <a href="#min_properties-val">min_properties</a> : thm
<a name="line252"></a>    val <a href="#neg_ulp-val">neg_ulp</a> : thm
<a name="line253"></a>    val <a href="#num2float_compare_11-val">num2float_compare_11</a> : thm
<a name="line254"></a>    val <a href="#num2float_compare_ONTO-val">num2float_compare_ONTO</a> : thm
<a name="line255"></a>    val <a href="#num2float_compare_float_compare2num-val">num2float_compare_float_compare2num</a> : thm
<a name="line256"></a>    val <a href="#num2float_compare_thm-val">num2float_compare_thm</a> : thm
<a name="line257"></a>    val <a href="#num2rounding_11-val">num2rounding_11</a> : thm
<a name="line258"></a>    val <a href="#num2rounding_ONTO-val">num2rounding_ONTO</a> : thm
<a name="line259"></a>    val <a href="#num2rounding_rounding2num-val">num2rounding_rounding2num</a> : thm
<a name="line260"></a>    val <a href="#num2rounding_thm-val">num2rounding_thm</a> : thm
<a name="line261"></a>    val <a href="#round_roundTiesToEven-val">round_roundTiesToEven</a> : thm
<a name="line262"></a>    val <a href="#round_roundTiesToEven0-val">round_roundTiesToEven0</a> : thm
<a name="line263"></a>    val <a href="#round_roundTiesToEven_is_minus_zero-val">round_roundTiesToEven_is_minus_zero</a> : thm
<a name="line264"></a>    val <a href="#round_roundTiesToEven_is_plus_zero-val">round_roundTiesToEven_is_plus_zero</a> : thm
<a name="line265"></a>    val <a href="#round_roundTiesToEven_is_zero-val">round_roundTiesToEven_is_zero</a> : thm
<a name="line266"></a>    val <a href="#round_roundTiesToEven_minus_infinity-val">round_roundTiesToEven_minus_infinity</a> : thm
<a name="line267"></a>    val <a href="#round_roundTiesToEven_plus_infinity-val">round_roundTiesToEven_plus_infinity</a> : thm
<a name="line268"></a>    val <a href="#round_roundTowardNegative_minus_infinity-val">round_roundTowardNegative_minus_infinity</a> : thm
<a name="line269"></a>    val <a href="#round_roundTowardNegative_top-val">round_roundTowardNegative_top</a> : thm
<a name="line270"></a>    val <a href="#round_roundTowardPositive_bottom-val">round_roundTowardPositive_bottom</a> : thm
<a name="line271"></a>    val <a href="#round_roundTowardPositive_plus_infinity-val">round_roundTowardPositive_plus_infinity</a> : thm
<a name="line272"></a>    val <a href="#round_roundTowardZero-val">round_roundTowardZero</a> : thm
<a name="line273"></a>    val <a href="#round_roundTowardZero_bottom-val">round_roundTowardZero_bottom</a> : thm
<a name="line274"></a>    val <a href="#round_roundTowardZero_is_minus_zero-val">round_roundTowardZero_is_minus_zero</a> : thm
<a name="line275"></a>    val <a href="#round_roundTowardZero_is_plus_zero-val">round_roundTowardZero_is_plus_zero</a> : thm
<a name="line276"></a>    val <a href="#round_roundTowardZero_is_zero-val">round_roundTowardZero_is_zero</a> : thm
<a name="line277"></a>    val <a href="#round_roundTowardZero_top-val">round_roundTowardZero_top</a> : thm
<a name="line278"></a>    val <a href="#rounding2num_11-val">rounding2num_11</a> : thm
<a name="line279"></a>    val <a href="#rounding2num_ONTO-val">rounding2num_ONTO</a> : thm
<a name="line280"></a>    val <a href="#rounding2num_num2rounding-val">rounding2num_num2rounding</a> : thm
<a name="line281"></a>    val <a href="#rounding2num_thm-val">rounding2num_thm</a> : thm
<a name="line282"></a>    val <a href="#rounding_Axiom-val">rounding_Axiom</a> : thm
<a name="line283"></a>    val <a href="#rounding_EQ_rounding-val">rounding_EQ_rounding</a> : thm
<a name="line284"></a>    val <a href="#rounding_case_cong-val">rounding_case_cong</a> : thm
<a name="line285"></a>    val <a href="#rounding_case_def-val">rounding_case_def</a> : thm
<a name="line286"></a>    val <a href="#rounding_case_eq-val">rounding_case_eq</a> : thm
<a name="line287"></a>    val <a href="#rounding_distinct-val">rounding_distinct</a> : thm
<a name="line288"></a>    val <a href="#rounding_induction-val">rounding_induction</a> : thm
<a name="line289"></a>    val <a href="#rounding_nchotomy-val">rounding_nchotomy</a> : thm
<a name="line290"></a>    val <a href="#sign_not_zero-val">sign_not_zero</a> : thm
<a name="line291"></a>    val <a href="#some_nan_properties-val">some_nan_properties</a> : thm
<a name="line292"></a>    val <a href="#threshold-val">threshold</a> : thm
<a name="line293"></a>    val <a href="#threshold_is_positive-val">threshold_is_positive</a> : thm
<a name="line294"></a>    val <a href="#top_properties-val">top_properties</a> : thm
<a name="line295"></a>    val <a href="#ulp-val">ulp</a> : thm
<a name="line296"></a>    val <a href="#ulp_lt_ULP-val">ulp_lt_ULP</a> : thm
<a name="line297"></a>    val <a href="#ulp_lt_largest-val">ulp_lt_largest</a> : thm
<a name="line298"></a>    val <a href="#ulp_lt_threshold-val">ulp_lt_threshold</a> : thm
<a name="line299"></a>    val <a href="#zero_le_pos_div_twopow-val">zero_le_pos_div_twopow</a> : thm
<a name="line300"></a>    val <a href="#zero_le_twopow-val">zero_le_twopow</a> : thm
<a name="line301"></a>    val <a href="#zero_lt_twopow-val">zero_lt_twopow</a> : thm
<a name="line302"></a>    val <a href="#zero_neq_twopow-val">zero_neq_twopow</a> : thm
<a name="line303"></a>    val <a href="#zero_properties-val">zero_properties</a> : thm
<a name="line304"></a>    val <a href="#zero_to_real-val">zero_to_real</a> : thm
<a name="line305"></a>  
<a name="line306"></a>  val binary_ieee_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line307"></a>(*
   [intreal] Parent theory of "binary_ieee"
   
   [transc] Parent theory of "binary_ieee"
   
   [words] Parent theory of "binary_ieee"
   
   [<a name="ULP_primitive_def-val"><b>ULP_primitive_def</b></a>]  Definition
      
      ⊢ ULP =
        WFREC (@R. WF R)
          (λULP a.
               case a of
                 (v,v1) =&gt;
                   I
                     (2 pow (if v = 0w then 1 else w2n v) /
                      2 pow (bias (:χ) + precision (:τ))))
   
   [<a name="check_for_signalling_def-val"><b>check_for_signalling_def</b></a>]  Definition
      
      ⊢ ∀l.
            check_for_signalling l =
            clear_flags with InvalidOp := EXISTS float_is_signalling l
   
   [<a name="clear_flags_def-val"><b>clear_flags_def</b></a>]  Definition
      
      ⊢ clear_flags =
        &lt;|DivideByZero := F; InvalidOp := F; Overflow := F; Precision := F;
          Underflow_BeforeRounding := F; Underflow_AfterRounding := F|&gt;
   
   [<a name="closest_def-val"><b>closest_def</b></a>]  Definition
      
      ⊢ closest = closest_such (K T)
   
   [<a name="closest_such_def-val"><b>closest_such_def</b></a>]  Definition
      
      ⊢ ∀p s x.
            closest_such p s x =
            @a. is_closest s x a ∧ ∀b. is_closest s x b ∧ p b ⇒ p a
   
   [<a name="dividezero_flags_def-val"><b>dividezero_flags_def</b></a>]  Definition
      
      ⊢ dividezero_flags = clear_flags with DivideByZero := T
   
   [<a name="exponent_boundary_def-val"><b>exponent_boundary_def</b></a>]  Definition
      
      ⊢ ∀y x.
            exponent_boundary y x ⇔
            (x.Sign = y.Sign) ∧ (w2n x.Exponent = w2n y.Exponent + 1) ∧
            x.Exponent ≠ 1w ∧ (y.Significand = -1w) ∧ (x.Significand = 0w)
   
   [<a name="flags_DivideByZero-val"><b>flags_DivideByZero</b></a>]  Definition
      
      ⊢ ∀b b0 b1 b2 b3 b4. (flags b b0 b1 b2 b3 b4).DivideByZero ⇔ b
   
   [<a name="flags_DivideByZero_fupd-val"><b>flags_DivideByZero_fupd</b></a>]  Definition
      
      ⊢ ∀f b b0 b1 b2 b3 b4.
            flags b b0 b1 b2 b3 b4 with DivideByZero updated_by f =
            flags (f b) b0 b1 b2 b3 b4
   
   [<a name="flags_InvalidOp-val"><b>flags_InvalidOp</b></a>]  Definition
      
      ⊢ ∀b b0 b1 b2 b3 b4. (flags b b0 b1 b2 b3 b4).InvalidOp ⇔ b0
   
   [<a name="flags_InvalidOp_fupd-val"><b>flags_InvalidOp_fupd</b></a>]  Definition
      
      ⊢ ∀f b b0 b1 b2 b3 b4.
            flags b b0 b1 b2 b3 b4 with InvalidOp updated_by f =
            flags b (f b0) b1 b2 b3 b4
   
   [<a name="flags_Overflow-val"><b>flags_Overflow</b></a>]  Definition
      
      ⊢ ∀b b0 b1 b2 b3 b4. (flags b b0 b1 b2 b3 b4).Overflow ⇔ b1
   
   [<a name="flags_Overflow_fupd-val"><b>flags_Overflow_fupd</b></a>]  Definition
      
      ⊢ ∀f b b0 b1 b2 b3 b4.
            flags b b0 b1 b2 b3 b4 with Overflow updated_by f =
            flags b b0 (f b1) b2 b3 b4
   
   [<a name="flags_Precision-val"><b>flags_Precision</b></a>]  Definition
      
      ⊢ ∀b b0 b1 b2 b3 b4. (flags b b0 b1 b2 b3 b4).Precision ⇔ b2
   
   [<a name="flags_Precision_fupd-val"><b>flags_Precision_fupd</b></a>]  Definition
      
      ⊢ ∀f b b0 b1 b2 b3 b4.
            flags b b0 b1 b2 b3 b4 with Precision updated_by f =
            flags b b0 b1 (f b2) b3 b4
   
   [<a name="flags_TY_DEF-val"><b>flags_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep.
            TYPE_DEFINITION
              (λa0'.
                   ∀'flags' .
                       (∀a0'.
                            (∃a0 a1 a2 a3 a4 a5.
                                 a0' =
                                 (λa0 a1 a2 a3 a4 a5.
                                      ind_type$CONSTR 0 (a0,a1,a2,a3,a4,a5)
                                        (λn. ind_type$BOTTOM)) a0 a1 a2 a3
                                   a4 a5) ⇒
                            'flags' a0') ⇒
                       'flags' a0') rep
   
   [<a name="flags_Underflow_AfterRounding-val"><b>flags_Underflow_AfterRounding</b></a>]  Definition
      
      ⊢ ∀b b0 b1 b2 b3 b4.
            (flags b b0 b1 b2 b3 b4).Underflow_AfterRounding ⇔ b4
   
   [<a name="flags_Underflow_AfterRounding_fupd-val"><b>flags_Underflow_AfterRounding_fupd</b></a>]  Definition
      
      ⊢ ∀f b b0 b1 b2 b3 b4.
            flags b b0 b1 b2 b3 b4 with
            Underflow_AfterRounding updated_by f =
            flags b b0 b1 b2 b3 (f b4)
   
   [<a name="flags_Underflow_BeforeRounding-val"><b>flags_Underflow_BeforeRounding</b></a>]  Definition
      
      ⊢ ∀b b0 b1 b2 b3 b4.
            (flags b b0 b1 b2 b3 b4).Underflow_BeforeRounding ⇔ b3
   
   [<a name="flags_Underflow_BeforeRounding_fupd-val"><b>flags_Underflow_BeforeRounding_fupd</b></a>]  Definition
      
      ⊢ ∀f b b0 b1 b2 b3 b4.
            flags b b0 b1 b2 b3 b4 with
            Underflow_BeforeRounding updated_by f =
            flags b b0 b1 b2 (f b3) b4
   
   [<a name="flags_case_def-val"><b>flags_case_def</b></a>]  Definition
      
      ⊢ ∀a0 a1 a2 a3 a4 a5 f.
            flags_CASE (flags a0 a1 a2 a3 a4 a5) f = f a0 a1 a2 a3 a4 a5
   
   [<a name="flags_size_def-val"><b>flags_size_def</b></a>]  Definition
      
      ⊢ ∀a0 a1 a2 a3 a4 a5.
            flags_size (flags a0 a1 a2 a3 a4 a5) =
            1 +
            (bool_size a0 +
             (bool_size a1 +
              (bool_size a2 +
               (bool_size a3 + (bool_size a4 + bool_size a5)))))
   
   [<a name="float_Exponent-val"><b>float_Exponent</b></a>]  Definition
      
      ⊢ ∀c c0 c1. (float c c0 c1).Exponent = c0
   
   [<a name="float_Exponent_fupd-val"><b>float_Exponent_fupd</b></a>]  Definition
      
      ⊢ ∀f c c0 c1.
            float c c0 c1 with Exponent updated_by f = float c (f c0) c1
   
   [<a name="float_Sign-val"><b>float_Sign</b></a>]  Definition
      
      ⊢ ∀c c0 c1. (float c c0 c1).Sign = c
   
   [<a name="float_Sign_fupd-val"><b>float_Sign_fupd</b></a>]  Definition
      
      ⊢ ∀f c c0 c1.
            float c c0 c1 with Sign updated_by f = float (f c) c0 c1
   
   [<a name="float_Significand-val"><b>float_Significand</b></a>]  Definition
      
      ⊢ ∀c c0 c1. (float c c0 c1).Significand = c1
   
   [<a name="float_Significand_fupd-val"><b>float_Significand_fupd</b></a>]  Definition
      
      ⊢ ∀f c c0 c1.
            float c c0 c1 with Significand updated_by f = float c c0 (f c1)
   
   [<a name="float_TY_DEF-val"><b>float_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep.
            TYPE_DEFINITION
              (λa0'.
                   ∀'float' .
                       (∀a0'.
                            (∃a0 a1 a2.
                                 a0' =
                                 (λa0 a1 a2.
                                      ind_type$CONSTR 0 (a0,a1,a2)
                                        (λn. ind_type$BOTTOM)) a0 a1 a2) ⇒
                            'float' a0') ⇒
                       'float' a0') rep
   
   [<a name="float_abs_def-val"><b>float_abs_def</b></a>]  Definition
      
      ⊢ ∀x. float_abs x = x with Sign := 0w
   
   [<a name="float_add_def-val"><b>float_add_def</b></a>]  Definition
      
      ⊢ ∀mode x y.
            float_add mode x y =
            case (float_value x,float_value y) of
              (Float r1,Float r2) =&gt;
                float_round_with_flags mode
                  (if (r1 = 0) ∧ (r2 = 0) ∧ (x.Sign = y.Sign) then
                     x.Sign = 1w
                   else (mode = roundTowardNegative)) (r1 + r2)
            | (Float r1,Infinity) =&gt; (clear_flags,y)
            | (Float r1,NaN) =&gt;
              (check_for_signalling [y],float_some_qnan (FP_Add mode x y))
            | (Infinity,Float v7) =&gt; (clear_flags,x)
            | (Infinity,Infinity) =&gt;
              if x.Sign = y.Sign then (clear_flags,x)
              else (invalidop_flags,float_some_qnan (FP_Add mode x y))
            | (Infinity,NaN) =&gt;
              (check_for_signalling [y],float_some_qnan (FP_Add mode x y))
            | (NaN,v1) =&gt;
              (check_for_signalling [x; y],
               float_some_qnan (FP_Add mode x y))
   
   [<a name="float_bottom_def-val"><b>float_bottom_def</b></a>]  Definition
      
      ⊢ float_bottom (:τ # χ) = float_negate (float_top (:τ # χ))
   
   [<a name="float_case_def-val"><b>float_case_def</b></a>]  Definition
      
      ⊢ ∀a0 a1 a2 f. float_CASE (float a0 a1 a2) f = f a0 a1 a2
   
   [<a name="float_compare_BIJ-val"><b>float_compare_BIJ</b></a>]  Definition
      
      ⊢ (∀a. num2float_compare (float_compare2num a) = a) ∧
        ∀r. (λn. n &lt; 4) r ⇔ (float_compare2num (num2float_compare r) = r)
   
   [<a name="float_compare_CASE-val"><b>float_compare_CASE</b></a>]  Definition
      
      ⊢ ∀x v0 v1 v2 v3.
            (case x of LT =&gt; v0 | EQ =&gt; v1 | GT =&gt; v2 | UN =&gt; v3) =
            (λm.
                 if m &lt; 1 then v0
                 else if m &lt; 2 then v1
                 else if m = 2 then v2
                 else v3) (float_compare2num x)
   
   [<a name="float_compare_TY_DEF-val"><b>float_compare_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep. TYPE_DEFINITION (λn. n &lt; 4) rep
   
   [<a name="float_compare_def-val"><b>float_compare_def</b></a>]  Definition
      
      ⊢ ∀x y.
            float_compare x y =
            case (float_value x,float_value y) of
              (Float r1,Float r2) =&gt;
                if r1 &lt; r2 then LT else if r1 = r2 then EQ else GT
            | (Float r1,Infinity) =&gt; if y.Sign = 1w then GT else LT
            | (Float r1,NaN) =&gt; UN
            | (Infinity,Float v7) =&gt; if x.Sign = 1w then LT else GT
            | (Infinity,Infinity) =&gt;
              if x.Sign = y.Sign then EQ
              else if x.Sign = 1w then LT
              else GT
            | (Infinity,NaN) =&gt; UN
            | (NaN,v1) =&gt; UN
   
   [<a name="float_compare_size_def-val"><b>float_compare_size_def</b></a>]  Definition
      
      ⊢ ∀x. float_compare_size x = 0
   
   [<a name="float_div_def-val"><b>float_div_def</b></a>]  Definition
      
      ⊢ ∀mode x y.
            float_div mode x y =
            case (float_value x,float_value y) of
              (Float 0,Float 0) =&gt;
                (invalidop_flags,float_some_qnan (FP_Div mode x y))
            | (Float r1,Float 0) =&gt;
              (dividezero_flags,
               if x.Sign = y.Sign then float_plus_infinity (:τ # χ)
               else float_minus_infinity (:τ # χ))
            | (Float r1,Float r2) =&gt;
              float_round_with_flags mode (x.Sign ≠ y.Sign) (r1 / r2)
            | (Float r1,Infinity) =&gt;
              (clear_flags,if x.Sign = y.Sign then float_plus_zero (:τ # χ)
               else float_minus_zero (:τ # χ))
            | (Float r1,NaN) =&gt;
              (check_for_signalling [y],float_some_qnan (FP_Div mode x y))
            | (Infinity,Float v7) =&gt;
              (clear_flags,
               if x.Sign = y.Sign then float_plus_infinity (:τ # χ)
               else float_minus_infinity (:τ # χ))
            | (Infinity,Infinity) =&gt;
              (invalidop_flags,float_some_qnan (FP_Div mode x y))
            | (Infinity,NaN) =&gt;
              (check_for_signalling [y],float_some_qnan (FP_Div mode x y))
            | (NaN,v1) =&gt;
              (check_for_signalling [x; y],
               float_some_qnan (FP_Div mode x y))
   
   [<a name="float_equal_def-val"><b>float_equal_def</b></a>]  Definition
      
      ⊢ ∀x y. float_equal x y ⇔ (float_compare x y = EQ)
   
   [<a name="float_greater_equal_def-val"><b>float_greater_equal_def</b></a>]  Definition
      
      ⊢ ∀x y.
            float_greater_equal x y ⇔
            case float_compare x y of LT =&gt; F | EQ =&gt; T | GT =&gt; T | UN =&gt; F
   
   [<a name="float_greater_than_def-val"><b>float_greater_than_def</b></a>]  Definition
      
      ⊢ ∀x y. float_greater_than x y ⇔ (float_compare x y = GT)
   
   [<a name="float_is_finite_def-val"><b>float_is_finite_def</b></a>]  Definition
      
      ⊢ ∀x.
            float_is_finite x ⇔
            case float_value x of Float v1 =&gt; T | Infinity =&gt; F | NaN =&gt; F
   
   [<a name="float_is_infinite_def-val"><b>float_is_infinite_def</b></a>]  Definition
      
      ⊢ ∀x.
            float_is_infinite x ⇔
            case float_value x of Float v1 =&gt; F | Infinity =&gt; T | NaN =&gt; F
   
   [<a name="float_is_integral_def-val"><b>float_is_integral_def</b></a>]  Definition
      
      ⊢ ∀x.
            float_is_integral x ⇔
            case float_value x of
              Float r =&gt; is_integral r
            | Infinity =&gt; F
            | NaN =&gt; F
   
   [<a name="float_is_nan_def-val"><b>float_is_nan_def</b></a>]  Definition
      
      ⊢ ∀x.
            float_is_nan x ⇔
            case float_value x of Float v1 =&gt; F | Infinity =&gt; F | NaN =&gt; T
   
   [<a name="float_is_normal_def-val"><b>float_is_normal_def</b></a>]  Definition
      
      ⊢ ∀x. float_is_normal x ⇔ x.Exponent ≠ 0w ∧ x.Exponent ≠ UINT_MAXw
   
   [<a name="float_is_signalling_def-val"><b>float_is_signalling_def</b></a>]  Definition
      
      ⊢ ∀x.
            float_is_signalling x ⇔
            float_is_nan x ∧ ¬word_msb x.Significand
   
   [<a name="float_is_subnormal_def-val"><b>float_is_subnormal_def</b></a>]  Definition
      
      ⊢ ∀x. float_is_subnormal x ⇔ (x.Exponent = 0w) ∧ x.Significand ≠ 0w
   
   [<a name="float_is_zero_def-val"><b>float_is_zero_def</b></a>]  Definition
      
      ⊢ ∀x.
            float_is_zero x ⇔
            case float_value x of
              Float r =&gt; r = 0
            | Infinity =&gt; F
            | NaN =&gt; F
   
   [<a name="float_less_equal_def-val"><b>float_less_equal_def</b></a>]  Definition
      
      ⊢ ∀x y.
            float_less_equal x y ⇔
            case float_compare x y of LT =&gt; T | EQ =&gt; T | GT =&gt; F | UN =&gt; F
   
   [<a name="float_less_than_def-val"><b>float_less_than_def</b></a>]  Definition
      
      ⊢ ∀x y. float_less_than x y ⇔ (float_compare x y = LT)
   
   [<a name="float_minus_infinity_def-val"><b>float_minus_infinity_def</b></a>]  Definition
      
      ⊢ float_minus_infinity (:τ # χ) =
        float_negate (float_plus_infinity (:τ # χ))
   
   [<a name="float_minus_min_def-val"><b>float_minus_min_def</b></a>]  Definition
      
      ⊢ float_minus_min (:τ # χ) = float_negate (float_plus_min (:τ # χ))
   
   [<a name="float_minus_zero_def-val"><b>float_minus_zero_def</b></a>]  Definition
      
      ⊢ float_minus_zero (:τ # χ) = float_negate (float_plus_zero (:τ # χ))
   
   [<a name="float_mul_add_def-val"><b>float_mul_add_def</b></a>]  Definition
      
      ⊢ ∀mode x y z.
            float_mul_add mode x y z =
            (let
               signP = x.Sign ⊕ y.Sign ;
               infP = float_is_infinite x ∨ float_is_infinite y
             in
               if float_is_nan x ∨ float_is_nan y ∨ float_is_nan z then
                 (check_for_signalling [x; y; z],
                  float_some_qnan (FP_MulAdd mode x y z))
               else if
                 float_is_infinite x ∧ float_is_zero y ∨
                 float_is_zero x ∧ float_is_infinite y ∨
                 float_is_infinite z ∧ infP ∧ signP ≠ z.Sign
               then
                 (invalidop_flags,float_some_qnan (FP_MulAdd mode x y z))
               else if
                 float_is_infinite z ∧ (z.Sign = 0w) ∨ infP ∧ (signP = 0w)
               then
                 (clear_flags,float_plus_infinity (:τ # χ))
               else if
                 float_is_infinite z ∧ (z.Sign = 1w) ∨ infP ∧ (signP = 1w)
               then
                 (clear_flags,float_minus_infinity (:τ # χ))
               else
                 (let
                    r1 = float_to_real x * float_to_real y and
                    r2 = float_to_real z
                  in
                    float_round_with_flags mode
                      (if (r1 = 0) ∧ (r2 = 0) ∧ (signP = z.Sign) then
                         signP = 1w
                       else (mode = roundTowardNegative)) (r1 + r2)))
   
   [<a name="float_mul_def-val"><b>float_mul_def</b></a>]  Definition
      
      ⊢ ∀mode x y.
            float_mul mode x y =
            case (float_value x,float_value y) of
              (Float r',Float r2) =&gt;
                float_round_with_flags mode (x.Sign ≠ y.Sign) (r' * r2)
            | (Float 0,Infinity) =&gt;
              (invalidop_flags,float_some_qnan (FP_Mul mode x y))
            | (Float r',Infinity) =&gt;
              (clear_flags,
               if x.Sign = y.Sign then float_plus_infinity (:τ # χ)
               else float_minus_infinity (:τ # χ))
            | (Float r',NaN) =&gt;
              (check_for_signalling [y],float_some_qnan (FP_Mul mode x y))
            | (Infinity,Float 0) =&gt;
              (invalidop_flags,float_some_qnan (FP_Mul mode x y))
            | (Infinity,Float r) =&gt;
              (clear_flags,
               if x.Sign = y.Sign then float_plus_infinity (:τ # χ)
               else float_minus_infinity (:τ # χ))
            | (Infinity,Infinity) =&gt;
              (clear_flags,
               if x.Sign = y.Sign then float_plus_infinity (:τ # χ)
               else float_minus_infinity (:τ # χ))
            | (Infinity,NaN) =&gt;
              (check_for_signalling [y],float_some_qnan (FP_Mul mode x y))
            | (NaN,v1) =&gt;
              (check_for_signalling [x; y],
               float_some_qnan (FP_Mul mode x y))
   
   [<a name="float_mul_sub_def-val"><b>float_mul_sub_def</b></a>]  Definition
      
      ⊢ ∀mode x y z.
            float_mul_sub mode x y z =
            (let
               signP = x.Sign ⊕ y.Sign ;
               infP = float_is_infinite x ∨ float_is_infinite y
             in
               if float_is_nan x ∨ float_is_nan y ∨ float_is_nan z then
                 (check_for_signalling [x; y; z],
                  float_some_qnan (FP_MulSub mode x y z))
               else if
                 float_is_infinite x ∧ float_is_zero y ∨
                 float_is_zero x ∧ float_is_infinite y ∨
                 float_is_infinite z ∧ infP ∧ (signP = z.Sign)
               then
                 (invalidop_flags,float_some_qnan (FP_MulAdd mode x y z))
               else if
                 float_is_infinite z ∧ (z.Sign = 1w) ∨ infP ∧ (signP = 0w)
               then
                 (clear_flags,float_plus_infinity (:τ # χ))
               else if
                 float_is_infinite z ∧ (z.Sign = 0w) ∨ infP ∧ (signP = 1w)
               then
                 (clear_flags,float_minus_infinity (:τ # χ))
               else
                 (let
                    r1 = float_to_real x * float_to_real y and
                    r2 = float_to_real z
                  in
                    float_round_with_flags mode
                      (if (r1 = 0) ∧ (r2 = 0) ∧ signP ≠ z.Sign then
                         signP = 1w
                       else (mode = roundTowardNegative)) (r1 − r2)))
   
   [<a name="float_negate_def-val"><b>float_negate_def</b></a>]  Definition
      
      ⊢ ∀x. float_negate x = x with Sign := ¬x.Sign
   
   [<a name="float_plus_infinity_def-val"><b>float_plus_infinity_def</b></a>]  Definition
      
      ⊢ float_plus_infinity (:τ # χ) =
        &lt;|Sign := 0w; Exponent := UINT_MAXw; Significand := 0w|&gt;
   
   [<a name="float_plus_min_def-val"><b>float_plus_min_def</b></a>]  Definition
      
      ⊢ float_plus_min (:τ # χ) =
        &lt;|Sign := 0w; Exponent := 0w; Significand := 1w|&gt;
   
   [<a name="float_plus_zero_def-val"><b>float_plus_zero_def</b></a>]  Definition
      
      ⊢ float_plus_zero (:τ # χ) =
        &lt;|Sign := 0w; Exponent := 0w; Significand := 0w|&gt;
   
   [<a name="float_round_def-val"><b>float_round_def</b></a>]  Definition
      
      ⊢ ∀mode toneg r.
            float_round mode toneg r =
            (let
               x = round mode r
             in
               if float_is_zero x then
                 if toneg then float_minus_zero (:τ # χ)
                 else float_plus_zero (:τ # χ) else x)
   
   [<a name="float_round_to_integral_def-val"><b>float_round_to_integral_def</b></a>]  Definition
      
      ⊢ ∀mode x.
            float_round_to_integral mode x =
            case float_value x of
              Float r =&gt; integral_round mode r
            | Infinity =&gt; x
            | NaN =&gt; x
   
   [<a name="float_round_with_flags_def-val"><b>float_round_with_flags_def</b></a>]  Definition
      
      ⊢ ∀mode to_neg r.
            float_round_with_flags mode to_neg r =
            (let
               x = float_round mode to_neg r and a = abs r ;
               inexact = float_value x ≠ Float r
             in
               (clear_flags with
                &lt;|Overflow :=
                    (float_is_infinite x ∨ 2 pow INT_MIN (:χ) ≤ a);
                  Underflow_BeforeRounding :=
                    (inexact ∧ a &lt; 2 / 2 pow bias (:χ));
                  Underflow_AfterRounding :=
                    (inexact ∧
                     (float_round mode to_neg r).Exponent ≤₊
                     n2w (INT_MIN (:χ))); Precision := inexact|&gt;,x))
   
   [<a name="float_size_def-val"><b>float_size_def</b></a>]  Definition
      
      ⊢ ∀f f1 a0 a1 a2. float_size f f1 (float a0 a1 a2) = 1
   
   [<a name="float_some_qnan_def-val"><b>float_some_qnan_def</b></a>]  Definition
      
      ⊢ ∀fp_op.
            float_some_qnan fp_op =
            (@f.
                 (let
                    qnan = f fp_op
                  in
                    float_is_nan qnan ∧ ¬float_is_signalling qnan)) fp_op
   
   [<a name="float_sqrt_def-val"><b>float_sqrt_def</b></a>]  Definition
      
      ⊢ ∀mode x.
            float_sqrt mode x =
            if x.Sign = 0w then
              case float_value x of
                Float r =&gt; float_round_with_flags mode F (sqrt r)
              | Infinity =&gt; (clear_flags,float_plus_infinity (:τ # χ))
              | NaN =&gt;
                (check_for_signalling [x],float_some_qnan (FP_Sqrt mode x))
            else (invalidop_flags,float_some_qnan (FP_Sqrt mode x))
   
   [<a name="float_sub_def-val"><b>float_sub_def</b></a>]  Definition
      
      ⊢ ∀mode x y.
            float_sub mode x y =
            case (float_value x,float_value y) of
              (Float r1,Float r2) =&gt;
                float_round_with_flags mode
                  (if (r1 = 0) ∧ (r2 = 0) ∧ x.Sign ≠ y.Sign then
                     x.Sign = 1w
                   else (mode = roundTowardNegative)) (r1 − r2)
            | (Float r1,Infinity) =&gt; (clear_flags,float_negate y)
            | (Float r1,NaN) =&gt;
              (check_for_signalling [y],float_some_qnan (FP_Sub mode x y))
            | (Infinity,Float v7) =&gt; (clear_flags,x)
            | (Infinity,Infinity) =&gt;
              if x.Sign = y.Sign then
                (invalidop_flags,float_some_qnan (FP_Sub mode x y))
              else (clear_flags,x)
            | (Infinity,NaN) =&gt;
              (check_for_signalling [y],float_some_qnan (FP_Sub mode x y))
            | (NaN,v1) =&gt;
              (check_for_signalling [x; y],
               float_some_qnan (FP_Sub mode x y))
   
   [<a name="float_to_int_def-val"><b>float_to_int_def</b></a>]  Definition
      
      ⊢ ∀mode x.
            float_to_int mode x =
            case float_value x of
              Float r =&gt;
                SOME
                  (case mode of
                   roundTiesToEven =&gt;
                     (let
                        f = flr r ;
                        df = abs (r − real_of_int f)
                      in
                        if
                          df &lt; 1 / 2 ∨ (df = 1 / 2) ∧ EVEN (Num (ABS f))
                        then
                          f else clg r)
                 | roundTowardPositive =&gt; clg r
                 | roundTowardNegative =&gt; flr r
                 | roundTowardZero =&gt; if x.Sign = 1w then clg r else flr r)
            | Infinity =&gt; NONE
            | NaN =&gt; NONE
   
   [<a name="float_to_real_def-val"><b>float_to_real_def</b></a>]  Definition
      
      ⊢ ∀x.
            float_to_real x =
            if x.Exponent = 0w then
              -1 pow w2n x.Sign * (2 / 2 pow bias (:χ)) *
              (&w2n x.Significand / 2 pow precision (:τ))
            else
              -1 pow w2n x.Sign *
              (2 pow w2n x.Exponent / 2 pow bias (:χ)) *
              (1 + &w2n x.Significand / 2 pow precision (:τ))
   
   [<a name="float_top_def-val"><b>float_top_def</b></a>]  Definition
      
      ⊢ float_top (:τ # χ) =
        &lt;|Sign := 0w; Exponent := UINT_MAXw − 1w; Significand := UINT_MAXw|&gt;
   
   [<a name="float_value_TY_DEF-val"><b>float_value_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep.
            TYPE_DEFINITION
              (λa0.
                   ∀'float_value' .
                       (∀a0.
                            (∃a.
                                 a0 =
                                 (λa.
                                      ind_type$CONSTR 0 a
                                        (λn. ind_type$BOTTOM)) a) ∨
                            (a0 =
                             ind_type$CONSTR (SUC 0) ARB
                               (λn. ind_type$BOTTOM)) ∨
                            (a0 =
                             ind_type$CONSTR (SUC (SUC 0)) ARB
                               (λn. ind_type$BOTTOM)) ⇒
                            'float_value' a0) ⇒
                       'float_value' a0) rep
   
   [<a name="float_value_case_def-val"><b>float_value_case_def</b></a>]  Definition
      
      ⊢ (∀a f v v1. float_value_CASE (Float a) f v v1 = f a) ∧
        (∀f v v1. float_value_CASE Infinity f v v1 = v) ∧
        ∀f v v1. float_value_CASE NaN f v v1 = v1
   
   [<a name="float_value_def-val"><b>float_value_def</b></a>]  Definition
      
      ⊢ ∀x.
            float_value x =
            if x.Exponent = UINT_MAXw then
              if x.Significand = 0w then Infinity else NaN
            else Float (float_to_real x)
   
   [<a name="float_value_size_def-val"><b>float_value_size_def</b></a>]  Definition
      
      ⊢ (∀a. float_value_size (Float a) = 1) ∧
        (float_value_size Infinity = 0) ∧ (float_value_size NaN = 0)
   
   [<a name="fp_op_TY_DEF-val"><b>fp_op_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep.
            TYPE_DEFINITION
              (λa0'.
                   ∀'fp_op' .
                       (∀a0'.
                            (∃a0 a1.
                                 a0' =
                                 (λa0 a1.
                                      ind_type$CONSTR 0 (a0,a1,ARB,ARB)
                                        (λn. ind_type$BOTTOM)) a0 a1) ∨
                            (∃a0 a1 a2.
                                 a0' =
                                 (λa0 a1 a2.
                                      ind_type$CONSTR (SUC 0)
                                        (a0,a1,a2,ARB)
                                        (λn. ind_type$BOTTOM)) a0 a1 a2) ∨
                            (∃a0 a1 a2.
                                 a0' =
                                 (λa0 a1 a2.
                                      ind_type$CONSTR (SUC (SUC 0))
                                        (a0,a1,a2,ARB)
                                        (λn. ind_type$BOTTOM)) a0 a1 a2) ∨
                            (∃a0 a1 a2.
                                 a0' =
                                 (λa0 a1 a2.
                                      ind_type$CONSTR (SUC (SUC (SUC 0)))
                                        (a0,a1,a2,ARB)
                                        (λn. ind_type$BOTTOM)) a0 a1 a2) ∨
                            (∃a0 a1 a2.
                                 a0' =
                                 (λa0 a1 a2.
                                      ind_type$CONSTR
                                        (SUC (SUC (SUC (SUC 0))))
                                        (a0,a1,a2,ARB)
                                        (λn. ind_type$BOTTOM)) a0 a1 a2) ∨
                            (∃a0 a1 a2 a3.
                                 a0' =
                                 (λa0 a1 a2 a3.
                                      ind_type$CONSTR
                                        (SUC (SUC (SUC (SUC (SUC 0)))))
                                        (a0,a1,a2,a3) (λn. ind_type$BOTTOM))
                                   a0 a1 a2 a3) ∨
                            (∃a0 a1 a2 a3.
                                 a0' =
                                 (λa0 a1 a2 a3.
                                      ind_type$CONSTR
                                        (SUC
                                           (SUC (SUC (SUC (SUC (SUC 0))))))
                                        (a0,a1,a2,a3) (λn. ind_type$BOTTOM))
                                   a0 a1 a2 a3) ⇒
                            'fp_op' a0') ⇒
                       'fp_op' a0') rep
   
   [<a name="fp_op_case_def-val"><b>fp_op_case_def</b></a>]  Definition
      
      ⊢ (∀a0 a1 f f1 f2 f3 f4 f5 f6.
             fp_op_CASE (FP_Sqrt a0 a1) f f1 f2 f3 f4 f5 f6 = f a0 a1) ∧
        (∀a0 a1 a2 f f1 f2 f3 f4 f5 f6.
             fp_op_CASE (FP_Add a0 a1 a2) f f1 f2 f3 f4 f5 f6 = f1 a0 a1 a2) ∧
        (∀a0 a1 a2 f f1 f2 f3 f4 f5 f6.
             fp_op_CASE (FP_Sub a0 a1 a2) f f1 f2 f3 f4 f5 f6 = f2 a0 a1 a2) ∧
        (∀a0 a1 a2 f f1 f2 f3 f4 f5 f6.
             fp_op_CASE (FP_Mul a0 a1 a2) f f1 f2 f3 f4 f5 f6 = f3 a0 a1 a2) ∧
        (∀a0 a1 a2 f f1 f2 f3 f4 f5 f6.
             fp_op_CASE (FP_Div a0 a1 a2) f f1 f2 f3 f4 f5 f6 = f4 a0 a1 a2) ∧
        (∀a0 a1 a2 a3 f f1 f2 f3 f4 f5 f6.
             fp_op_CASE (FP_MulAdd a0 a1 a2 a3) f f1 f2 f3 f4 f5 f6 =
             f5 a0 a1 a2 a3) ∧
        ∀a0 a1 a2 a3 f f1 f2 f3 f4 f5 f6.
            fp_op_CASE (FP_MulSub a0 a1 a2 a3) f f1 f2 f3 f4 f5 f6 =
            f6 a0 a1 a2 a3
   
   [<a name="fp_op_size_def-val"><b>fp_op_size_def</b></a>]  Definition
      
      ⊢ (∀f f1 a0 a1.
             fp_op_size f f1 (FP_Sqrt a0 a1) =
             1 + (rounding_size a0 + float_size f f1 a1)) ∧
        (∀f f1 a0 a1 a2.
             fp_op_size f f1 (FP_Add a0 a1 a2) =
             1 +
             (rounding_size a0 + (float_size f f1 a1 + float_size f f1 a2))) ∧
        (∀f f1 a0 a1 a2.
             fp_op_size f f1 (FP_Sub a0 a1 a2) =
             1 +
             (rounding_size a0 + (float_size f f1 a1 + float_size f f1 a2))) ∧
        (∀f f1 a0 a1 a2.
             fp_op_size f f1 (FP_Mul a0 a1 a2) =
             1 +
             (rounding_size a0 + (float_size f f1 a1 + float_size f f1 a2))) ∧
        (∀f f1 a0 a1 a2.
             fp_op_size f f1 (FP_Div a0 a1 a2) =
             1 +
             (rounding_size a0 + (float_size f f1 a1 + float_size f f1 a2))) ∧
        (∀f f1 a0 a1 a2 a3.
             fp_op_size f f1 (FP_MulAdd a0 a1 a2 a3) =
             1 +
             (rounding_size a0 +
              (float_size f f1 a1 +
               (float_size f f1 a2 + float_size f f1 a3)))) ∧
        ∀f f1 a0 a1 a2 a3.
            fp_op_size f f1 (FP_MulSub a0 a1 a2 a3) =
            1 +
            (rounding_size a0 +
             (float_size f f1 a1 +
              (float_size f f1 a2 + float_size f f1 a3)))
   
   [<a name="integral_round_def-val"><b>integral_round_def</b></a>]  Definition
      
      ⊢ ∀mode x.
            integral_round mode x =
            case mode of
              roundTiesToEven =&gt;
                (let
                   t = threshold (:τ # χ)
                 in
                   if x ≤ -t then float_minus_infinity (:τ # χ)
                   else if x ≥ t then float_plus_infinity (:τ # χ)
                   else
                     closest_such
                       (λa. ∃n. EVEN n ∧ (abs (float_to_real a) = &n))
                       float_is_integral x)
            | roundTowardPositive =&gt;
              (let
                 t = largest (:τ # χ)
               in
                 if x &lt; -t then float_bottom (:τ # χ)
                 else if x &gt; t then float_plus_infinity (:τ # χ)
                 else
                   closest {a | float_is_integral a ∧ float_to_real a ≥ x}
                     x)
            | roundTowardNegative =&gt;
              (let
                 t = largest (:τ # χ)
               in
                 if x &lt; -t then float_minus_infinity (:τ # χ)
                 else if x &gt; t then float_top (:τ # χ)
                 else
                   closest {a | float_is_integral a ∧ float_to_real a ≤ x}
                     x)
            | roundTowardZero =&gt;
              (let
                 t = largest (:τ # χ)
               in
                 if x &lt; -t then float_bottom (:τ # χ)
                 else if x &gt; t then float_top (:τ # χ)
                 else
                   closest
                     {a |
                     float_is_integral a ∧ abs (float_to_real a) ≤ abs x} x)
   
   [<a name="invalidop_flags_def-val"><b>invalidop_flags_def</b></a>]  Definition
      
      ⊢ invalidop_flags = clear_flags with InvalidOp := T
   
   [<a name="is_closest_def-val"><b>is_closest_def</b></a>]  Definition
      
      ⊢ ∀s x a.
            is_closest s x a ⇔
            a ∈ s ∧
            ∀b.
                b ∈ s ⇒
                abs (float_to_real a − x) ≤ abs (float_to_real b − x)
   
   [<a name="is_integral_def-val"><b>is_integral_def</b></a>]  Definition
      
      ⊢ ∀r. is_integral r ⇔ ∃n. abs r = &n
   
   [<a name="largest_def-val"><b>largest_def</b></a>]  Definition
      
      ⊢ largest (:τ # χ) =
        2 pow (UINT_MAX (:χ) − 1) / 2 pow bias (:χ) *
        (2 − (2 pow precision (:τ))⁻¹)
   
   [<a name="real_to_float_def-val"><b>real_to_float_def</b></a>]  Definition
      
      ⊢ ∀m. real_to_float m = float_round m (m = roundTowardNegative)
   
   [<a name="real_to_float_with_flags_def-val"><b>real_to_float_with_flags_def</b></a>]  Definition
      
      ⊢ ∀m.
            real_to_float_with_flags m =
            float_round_with_flags m (m = roundTowardNegative)
   
   [<a name="round_def-val"><b>round_def</b></a>]  Definition
      
      ⊢ ∀mode x.
            round mode x =
            case mode of
              roundTiesToEven =&gt;
                (let
                   t = threshold (:τ # χ)
                 in
                   if x ≤ -t then float_minus_infinity (:τ # χ)
                   else if x ≥ t then float_plus_infinity (:τ # χ)
                   else
                     closest_such (λa. ¬word_lsb a.Significand)
                       float_is_finite x)
            | roundTowardPositive =&gt;
              (let
                 t = largest (:τ # χ)
               in
                 if x &lt; -t then float_bottom (:τ # χ)
                 else if x &gt; t then float_plus_infinity (:τ # χ)
                 else
                   closest {a | float_is_finite a ∧ float_to_real a ≥ x} x)
            | roundTowardNegative =&gt;
              (let
                 t = largest (:τ # χ)
               in
                 if x &lt; -t then float_minus_infinity (:τ # χ)
                 else if x &gt; t then float_top (:τ # χ)
                 else
                   closest {a | float_is_finite a ∧ float_to_real a ≤ x} x)
            | roundTowardZero =&gt;
              (let
                 t = largest (:τ # χ)
               in
                 if x &lt; -t then float_bottom (:τ # χ)
                 else if x &gt; t then float_top (:τ # χ)
                 else
                   closest
                     {a | float_is_finite a ∧ abs (float_to_real a) ≤ abs x}
                     x)
   
   [<a name="rounding_BIJ-val"><b>rounding_BIJ</b></a>]  Definition
      
      ⊢ (∀a. num2rounding (rounding2num a) = a) ∧
        ∀r. (λn. n &lt; 4) r ⇔ (rounding2num (num2rounding r) = r)
   
   [<a name="rounding_CASE-val"><b>rounding_CASE</b></a>]  Definition
      
      ⊢ ∀x v0 v1 v2 v3.
            (case x of
               roundTiesToEven =&gt; v0
             | roundTowardPositive =&gt; v1
             | roundTowardNegative =&gt; v2
             | roundTowardZero =&gt; v3) =
            (λm.
                 if m &lt; 1 then v0
                 else if m &lt; 2 then v1
                 else if m = 2 then v2
                 else v3) (rounding2num x)
   
   [<a name="rounding_TY_DEF-val"><b>rounding_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep. TYPE_DEFINITION (λn. n &lt; 4) rep
   
   [<a name="rounding_size_def-val"><b>rounding_size_def</b></a>]  Definition
      
      ⊢ ∀x. rounding_size x = 0
   
   [<a name="threshold_def-val"><b>threshold_def</b></a>]  Definition
      
      ⊢ threshold (:τ # χ) =
        2 pow (UINT_MAX (:χ) − 1) / 2 pow bias (:χ) *
        (2 − (2 pow SUC (precision (:τ)))⁻¹)
   
   [<a name="ulp_def-val"><b>ulp_def</b></a>]  Definition
      
      ⊢ ulp (:τ # χ) = ULP (0w,(:τ))
   
   [<a name="EXISTS_flags-val"><b>EXISTS_flags</b></a>]  Theorem
      
      ⊢ ∀P.
            (∃f. P f) ⇔
            ∃b4 b3 b2 b1 b0 b.
                P
                  &lt;|DivideByZero := b4; InvalidOp := b3; Overflow := b2;
                  Precision := b1; Underflow_BeforeRounding := b0;
                  Underflow_AfterRounding := b|&gt;
   
   [<a name="EXISTS_float-val"><b>EXISTS_float</b></a>]  Theorem
      
      ⊢ ∀P.
            (∃f. P f) ⇔
            ∃c1 c0 c. P &lt;|Sign := c1; Exponent := c0; Significand := c|&gt;
   
   [<a name="FORALL_flags-val"><b>FORALL_flags</b></a>]  Theorem
      
      ⊢ ∀P.
            (∀f. P f) ⇔
            ∀b4 b3 b2 b1 b0 b.
                P
                  &lt;|DivideByZero := b4; InvalidOp := b3; Overflow := b2;
                  Precision := b1; Underflow_BeforeRounding := b0;
                  Underflow_AfterRounding := b|&gt;
   
   [<a name="FORALL_float-val"><b>FORALL_float</b></a>]  Theorem
      
      ⊢ ∀P.
            (∀f. P f) ⇔
            ∀c1 c0 c. P &lt;|Sign := c1; Exponent := c0; Significand := c|&gt;
   
   [<a name="ULP_def-val"><b>ULP_def</b></a>]  Theorem
      
      ⊢ ULP (e,(:τ)) =
        2 pow (if e = 0w then 1 else w2n e) /
        2 pow (bias (:χ) + precision (:τ))
   
   [<a name="ULP_ind-val"><b>ULP_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀e. P (e,(:τ))) ⇒ ∀v v1. P (v,v1)
   
   [<a name="ULP_le_mono-val"><b>ULP_le_mono</b></a>]  Theorem
      
      ⊢ ∀e1 e2. e2 ≠ 0w ⇒ (ULP (e1,(:τ)) ≤ ULP (e2,(:τ)) ⇔ e1 ≤₊ e2)
   
   [<a name="abs_float_value-val"><b>abs_float_value</b></a>]  Theorem
      
      ⊢ (∀b c d. abs (-1 pow w2n b * c * d) = abs (c * d)) ∧
        ∀b c. abs (-1 pow w2n b * c) = abs c
   
   [<a name="bottom_properties-val"><b>bottom_properties</b></a>]  Theorem
      
      ⊢ ¬float_is_zero (float_bottom (:τ # χ)) ∧
        float_is_finite (float_bottom (:τ # χ)) ∧
        ¬float_is_nan (float_bottom (:τ # χ)) ∧
        (float_is_normal (float_bottom (:τ # χ)) ⇔ precision (:χ) ≠ 1) ∧
        (float_is_subnormal (float_bottom (:τ # χ)) ⇔ (precision (:χ) = 1)) ∧
        ¬float_is_infinite (float_bottom (:τ # χ))
   
   [<a name="datatype_flags-val"><b>datatype_flags</b></a>]  Theorem
      
      ⊢ DATATYPE
          (record flags DivideByZero InvalidOp Overflow Precision
             Underflow_BeforeRounding Underflow_AfterRounding)
   
   [<a name="datatype_float-val"><b>datatype_float</b></a>]  Theorem
      
      ⊢ DATATYPE (record float Sign Exponent Significand)
   
   [<a name="datatype_float_compare-val"><b>datatype_float_compare</b></a>]  Theorem
      
      ⊢ DATATYPE (float_compare LT EQ GT UN)
   
   [<a name="datatype_float_value-val"><b>datatype_float_value</b></a>]  Theorem
      
      ⊢ DATATYPE (float_value Float Infinity NaN)
   
   [<a name="datatype_fp_op-val"><b>datatype_fp_op</b></a>]  Theorem
      
      ⊢ DATATYPE
          (fp_op FP_Sqrt FP_Add FP_Sub FP_Mul FP_Div FP_MulAdd FP_MulSub)
   
   [<a name="datatype_rounding-val"><b>datatype_rounding</b></a>]  Theorem
      
      ⊢ DATATYPE
          (rounding roundTiesToEven roundTowardPositive roundTowardNegative
             roundTowardZero)
   
   [<a name="diff_float_ULP-val"><b>diff_float_ULP</b></a>]  Theorem
      
      ⊢ ∀x y.
            float_to_real x ≠ float_to_real y ∧ ¬exponent_boundary y x ⇒
            ULP (x.Exponent,(:τ)) ≤ abs (float_to_real x − float_to_real y)
   
   [<a name="diff_lt_ulp_eq0-val"><b>diff_lt_ulp_eq0</b></a>]  Theorem
      
      ⊢ ∀a b x.
            ¬exponent_boundary b a ∧
            abs (x − float_to_real a) &lt; ULP (a.Exponent,(:τ)) ∧
            abs (x − float_to_real b) &lt; ULP (a.Exponent,(:τ)) ∧
            abs (float_to_real a) ≤ abs x ∧ abs (float_to_real b) ≤ abs x ∧
            ¬float_is_zero a ⇒
            (b = a)
   
   [<a name="diff_lt_ulp_even-val"><b>diff_lt_ulp_even</b></a>]  Theorem
      
      ⊢ ∀a b x.
            ¬exponent_boundary b a ∧
            2 * abs (float_to_real a − x) &lt; ULP (a.Exponent,(:τ)) ∧
            2 * abs (float_to_real b − x) &lt; ULP (a.Exponent,(:τ)) ∧
            ¬float_is_zero a ⇒
            (b = a)
   
   [<a name="diff_lt_ulp_even4-val"><b>diff_lt_ulp_even4</b></a>]  Theorem
      
      ⊢ ∀a b x.
            ¬exponent_boundary b a ∧
            4 * abs (float_to_real a − x) ≤ ULP (a.Exponent,(:τ)) ∧
            4 * abs (float_to_real b − x) ≤ ULP (a.Exponent,(:τ)) ∧
            ¬float_is_zero a ⇒
            (b = a)
   
   [<a name="div_eq0-val"><b>div_eq0</b></a>]  Theorem
      
      ⊢ ∀a b. 0 &lt; b ⇒ ((a / b = 0) ⇔ (a = 0))
   
   [<a name="exp_ge2-val"><b>exp_ge2</b></a>]  Theorem
      
      ⊢ ∀b. 2 ≤ 2 ** b ⇔ 1 ≤ b
   
   [<a name="exp_gt2-val"><b>exp_gt2</b></a>]  Theorem
      
      ⊢ ∀b. 2 &lt; 2 ** b ⇔ 1 &lt; b
   
   [<a name="flags_11-val"><b>flags_11</b></a>]  Theorem
      
      ⊢ ∀a0 a1 a2 a3 a4 a5 a0' a1' a2' a3' a4' a5'.
            (flags a0 a1 a2 a3 a4 a5 = flags a0' a1' a2' a3' a4' a5') ⇔
            (a0 ⇔ a0') ∧ (a1 ⇔ a1') ∧ (a2 ⇔ a2') ∧ (a3 ⇔ a3') ∧
            (a4 ⇔ a4') ∧ (a5 ⇔ a5')
   
   [<a name="flags_Axiom-val"><b>flags_Axiom</b></a>]  Theorem
      
      ⊢ ∀f.
            ∃fn.
                ∀a0 a1 a2 a3 a4 a5.
                    fn (flags a0 a1 a2 a3 a4 a5) = f a0 a1 a2 a3 a4 a5
   
   [<a name="flags_accessors-val"><b>flags_accessors</b></a>]  Theorem
      
      ⊢ (∀b b0 b1 b2 b3 b4. (flags b b0 b1 b2 b3 b4).DivideByZero ⇔ b) ∧
        (∀b b0 b1 b2 b3 b4. (flags b b0 b1 b2 b3 b4).InvalidOp ⇔ b0) ∧
        (∀b b0 b1 b2 b3 b4. (flags b b0 b1 b2 b3 b4).Overflow ⇔ b1) ∧
        (∀b b0 b1 b2 b3 b4. (flags b b0 b1 b2 b3 b4).Precision ⇔ b2) ∧
        (∀b b0 b1 b2 b3 b4.
             (flags b b0 b1 b2 b3 b4).Underflow_BeforeRounding ⇔ b3) ∧
        ∀b b0 b1 b2 b3 b4.
            (flags b b0 b1 b2 b3 b4).Underflow_AfterRounding ⇔ b4
   
   [<a name="flags_accfupds-val"><b>flags_accfupds</b></a>]  Theorem
      
      ⊢ (∀f0 f.
             (f with InvalidOp updated_by f0).DivideByZero ⇔ f.DivideByZero) ∧
        (∀f0 f.
             (f with Overflow updated_by f0).DivideByZero ⇔ f.DivideByZero) ∧
        (∀f0 f.
             (f with Precision updated_by f0).DivideByZero ⇔ f.DivideByZero) ∧
        (∀f0 f.
             (f with Underflow_BeforeRounding updated_by f0).DivideByZero ⇔
             f.DivideByZero) ∧
        (∀f0 f.
             (f with Underflow_AfterRounding updated_by f0).DivideByZero ⇔
             f.DivideByZero) ∧
        (∀f0 f. (f with DivideByZero updated_by f0).InvalidOp ⇔ f.InvalidOp) ∧
        (∀f0 f. (f with Overflow updated_by f0).InvalidOp ⇔ f.InvalidOp) ∧
        (∀f0 f. (f with Precision updated_by f0).InvalidOp ⇔ f.InvalidOp) ∧
        (∀f0 f.
             (f with Underflow_BeforeRounding updated_by f0).InvalidOp ⇔
             f.InvalidOp) ∧
        (∀f0 f.
             (f with Underflow_AfterRounding updated_by f0).InvalidOp ⇔
             f.InvalidOp) ∧
        (∀f0 f. (f with DivideByZero updated_by f0).Overflow ⇔ f.Overflow) ∧
        (∀f0 f. (f with InvalidOp updated_by f0).Overflow ⇔ f.Overflow) ∧
        (∀f0 f. (f with Precision updated_by f0).Overflow ⇔ f.Overflow) ∧
        (∀f0 f.
             (f with Underflow_BeforeRounding updated_by f0).Overflow ⇔
             f.Overflow) ∧
        (∀f0 f.
             (f with Underflow_AfterRounding updated_by f0).Overflow ⇔
             f.Overflow) ∧
        (∀f0 f. (f with DivideByZero updated_by f0).Precision ⇔ f.Precision) ∧
        (∀f0 f. (f with InvalidOp updated_by f0).Precision ⇔ f.Precision) ∧
        (∀f0 f. (f with Overflow updated_by f0).Precision ⇔ f.Precision) ∧
        (∀f0 f.
             (f with Underflow_BeforeRounding updated_by f0).Precision ⇔
             f.Precision) ∧
        (∀f0 f.
             (f with Underflow_AfterRounding updated_by f0).Precision ⇔
             f.Precision) ∧
        (∀f0 f.
             (f with DivideByZero updated_by f0).Underflow_BeforeRounding ⇔
             f.Underflow_BeforeRounding) ∧
        (∀f0 f.
             (f with InvalidOp updated_by f0).Underflow_BeforeRounding ⇔
             f.Underflow_BeforeRounding) ∧
        (∀f0 f.
             (f with Overflow updated_by f0).Underflow_BeforeRounding ⇔
             f.Underflow_BeforeRounding) ∧
        (∀f0 f.
             (f with Precision updated_by f0).Underflow_BeforeRounding ⇔
             f.Underflow_BeforeRounding) ∧
        (∀f0 f.
             (f with Underflow_AfterRounding updated_by f0).
             Underflow_BeforeRounding ⇔ f.Underflow_BeforeRounding) ∧
        (∀f0 f.
             (f with DivideByZero updated_by f0).Underflow_AfterRounding ⇔
             f.Underflow_AfterRounding) ∧
        (∀f0 f.
             (f with InvalidOp updated_by f0).Underflow_AfterRounding ⇔
             f.Underflow_AfterRounding) ∧
        (∀f0 f.
             (f with Overflow updated_by f0).Underflow_AfterRounding ⇔
             f.Underflow_AfterRounding) ∧
        (∀f0 f.
             (f with Precision updated_by f0).Underflow_AfterRounding ⇔
             f.Underflow_AfterRounding) ∧
        (∀f0 f.
             (f with Underflow_BeforeRounding updated_by f0).
             Underflow_AfterRounding ⇔ f.Underflow_AfterRounding) ∧
        (∀f0 f.
             (f with DivideByZero updated_by f0).DivideByZero ⇔
             f0 f.DivideByZero) ∧
        (∀f0 f. (f with InvalidOp updated_by f0).InvalidOp ⇔ f0 f.InvalidOp) ∧
        (∀f0 f. (f with Overflow updated_by f0).Overflow ⇔ f0 f.Overflow) ∧
        (∀f0 f. (f with Precision updated_by f0).Precision ⇔ f0 f.Precision) ∧
        (∀f0 f.
             (f with Underflow_BeforeRounding updated_by f0).
             Underflow_BeforeRounding ⇔ f0 f.Underflow_BeforeRounding) ∧
        ∀f0 f.
            (f with Underflow_AfterRounding updated_by f0).
            Underflow_AfterRounding ⇔ f0 f.Underflow_AfterRounding
   
   [<a name="flags_case_cong-val"><b>flags_case_cong</b></a>]  Theorem
      
      ⊢ ∀M M' f.
            (M = M') ∧
            (∀a0 a1 a2 a3 a4 a5.
                 (M' = flags a0 a1 a2 a3 a4 a5) ⇒
                 (f a0 a1 a2 a3 a4 a5 = f' a0 a1 a2 a3 a4 a5)) ⇒
            (flags_CASE M f = flags_CASE M' f')
   
   [<a name="flags_case_eq-val"><b>flags_case_eq</b></a>]  Theorem
      
      ⊢ (flags_CASE x f = v) ⇔
        ∃b b0 b1 b2 b3 b4.
            (x = flags b b0 b1 b2 b3 b4) ∧ (f b b0 b1 b2 b3 b4 = v)
   
   [<a name="flags_component_equality-val"><b>flags_component_equality</b></a>]  Theorem
      
      ⊢ ∀f1 f2.
            (f1 = f2) ⇔
            (f1.DivideByZero ⇔ f2.DivideByZero) ∧
            (f1.InvalidOp ⇔ f2.InvalidOp) ∧ (f1.Overflow ⇔ f2.Overflow) ∧
            (f1.Precision ⇔ f2.Precision) ∧
            (f1.Underflow_BeforeRounding ⇔ f2.Underflow_BeforeRounding) ∧
            (f1.Underflow_AfterRounding ⇔ f2.Underflow_AfterRounding)
   
   [<a name="flags_fn_updates-val"><b>flags_fn_updates</b></a>]  Theorem
      
      ⊢ (∀f b b0 b1 b2 b3 b4.
             flags b b0 b1 b2 b3 b4 with DivideByZero updated_by f =
             flags (f b) b0 b1 b2 b3 b4) ∧
        (∀f b b0 b1 b2 b3 b4.
             flags b b0 b1 b2 b3 b4 with InvalidOp updated_by f =
             flags b (f b0) b1 b2 b3 b4) ∧
        (∀f b b0 b1 b2 b3 b4.
             flags b b0 b1 b2 b3 b4 with Overflow updated_by f =
             flags b b0 (f b1) b2 b3 b4) ∧
        (∀f b b0 b1 b2 b3 b4.
             flags b b0 b1 b2 b3 b4 with Precision updated_by f =
             flags b b0 b1 (f b2) b3 b4) ∧
        (∀f b b0 b1 b2 b3 b4.
             flags b b0 b1 b2 b3 b4 with
             Underflow_BeforeRounding updated_by f =
             flags b b0 b1 b2 (f b3) b4) ∧
        ∀f b b0 b1 b2 b3 b4.
            flags b b0 b1 b2 b3 b4 with
            Underflow_AfterRounding updated_by f =
            flags b b0 b1 b2 b3 (f b4)
   
   [<a name="flags_fupdcanon-val"><b>flags_fupdcanon</b></a>]  Theorem
      
      ⊢ (∀g f0 f.
             f with &lt;|InvalidOp updated_by f0; DivideByZero updated_by g|&gt; =
             f with &lt;|DivideByZero updated_by g; InvalidOp updated_by f0|&gt;) ∧
        (∀g f0 f.
             f with &lt;|Overflow updated_by f0; DivideByZero updated_by g|&gt; =
             f with &lt;|DivideByZero updated_by g; Overflow updated_by f0|&gt;) ∧
        (∀g f0 f.
             f with &lt;|Overflow updated_by f0; InvalidOp updated_by g|&gt; =
             f with &lt;|InvalidOp updated_by g; Overflow updated_by f0|&gt;) ∧
        (∀g f0 f.
             f with &lt;|Precision updated_by f0; DivideByZero updated_by g|&gt; =
             f with &lt;|DivideByZero updated_by g; Precision updated_by f0|&gt;) ∧
        (∀g f0 f.
             f with &lt;|Precision updated_by f0; InvalidOp updated_by g|&gt; =
             f with &lt;|InvalidOp updated_by g; Precision updated_by f0|&gt;) ∧
        (∀g f0 f.
             f with &lt;|Precision updated_by f0; Overflow updated_by g|&gt; =
             f with &lt;|Overflow updated_by g; Precision updated_by f0|&gt;) ∧
        (∀g f0 f.
             f with
             &lt;|Underflow_BeforeRounding updated_by f0;
               DivideByZero updated_by g|&gt; =
             f with
             &lt;|DivideByZero updated_by g;
               Underflow_BeforeRounding updated_by f0|&gt;) ∧
        (∀g f0 f.
             f with
             &lt;|Underflow_BeforeRounding updated_by f0;
               InvalidOp updated_by g|&gt; =
             f with
             &lt;|InvalidOp updated_by g;
               Underflow_BeforeRounding updated_by f0|&gt;) ∧
        (∀g f0 f.
             f with
             &lt;|Underflow_BeforeRounding updated_by f0;
               Overflow updated_by g|&gt; =
             f with
             &lt;|Overflow updated_by g;
               Underflow_BeforeRounding updated_by f0|&gt;) ∧
        (∀g f0 f.
             f with
             &lt;|Underflow_BeforeRounding updated_by f0;
               Precision updated_by g|&gt; =
             f with
             &lt;|Precision updated_by g;
               Underflow_BeforeRounding updated_by f0|&gt;) ∧
        (∀g f0 f.
             f with
             &lt;|Underflow_AfterRounding updated_by f0;
               DivideByZero updated_by g|&gt; =
             f with
             &lt;|DivideByZero updated_by g;
               Underflow_AfterRounding updated_by f0|&gt;) ∧
        (∀g f0 f.
             f with
             &lt;|Underflow_AfterRounding updated_by f0;
               InvalidOp updated_by g|&gt; =
             f with
             &lt;|InvalidOp updated_by g;
               Underflow_AfterRounding updated_by f0|&gt;) ∧
        (∀g f0 f.
             f with
             &lt;|Underflow_AfterRounding updated_by f0; Overflow updated_by g|&gt; =
             f with
             &lt;|Overflow updated_by g; Underflow_AfterRounding updated_by f0|&gt;) ∧
        (∀g f0 f.
             f with
             &lt;|Underflow_AfterRounding updated_by f0;
               Precision updated_by g|&gt; =
             f with
             &lt;|Precision updated_by g;
               Underflow_AfterRounding updated_by f0|&gt;) ∧
        ∀g f0 f.
            f with
            &lt;|Underflow_AfterRounding updated_by f0;
              Underflow_BeforeRounding updated_by g|&gt; =
            f with
            &lt;|Underflow_BeforeRounding updated_by g;
              Underflow_AfterRounding updated_by f0|&gt;
   
   [<a name="flags_fupdcanon_comp-val"><b>flags_fupdcanon_comp</b></a>]  Theorem
      
      ⊢ ((∀g f0.
              InvalidOp_fupd f0 ∘ DivideByZero_fupd g =
              DivideByZero_fupd g ∘ InvalidOp_fupd f0) ∧
         ∀h g f0.
             InvalidOp_fupd f0 ∘ DivideByZero_fupd g ∘ h =
             DivideByZero_fupd g ∘ InvalidOp_fupd f0 ∘ h) ∧
        ((∀g f0.
              Overflow_fupd f0 ∘ DivideByZero_fupd g =
              DivideByZero_fupd g ∘ Overflow_fupd f0) ∧
         ∀h g f0.
             Overflow_fupd f0 ∘ DivideByZero_fupd g ∘ h =
             DivideByZero_fupd g ∘ Overflow_fupd f0 ∘ h) ∧
        ((∀g f0.
              Overflow_fupd f0 ∘ InvalidOp_fupd g =
              InvalidOp_fupd g ∘ Overflow_fupd f0) ∧
         ∀h g f0.
             Overflow_fupd f0 ∘ InvalidOp_fupd g ∘ h =
             InvalidOp_fupd g ∘ Overflow_fupd f0 ∘ h) ∧
        ((∀g f0.
              Precision_fupd f0 ∘ DivideByZero_fupd g =
              DivideByZero_fupd g ∘ Precision_fupd f0) ∧
         ∀h g f0.
             Precision_fupd f0 ∘ DivideByZero_fupd g ∘ h =
             DivideByZero_fupd g ∘ Precision_fupd f0 ∘ h) ∧
        ((∀g f0.
              Precision_fupd f0 ∘ InvalidOp_fupd g =
              InvalidOp_fupd g ∘ Precision_fupd f0) ∧
         ∀h g f0.
             Precision_fupd f0 ∘ InvalidOp_fupd g ∘ h =
             InvalidOp_fupd g ∘ Precision_fupd f0 ∘ h) ∧
        ((∀g f0.
              Precision_fupd f0 ∘ Overflow_fupd g =
              Overflow_fupd g ∘ Precision_fupd f0) ∧
         ∀h g f0.
             Precision_fupd f0 ∘ Overflow_fupd g ∘ h =
             Overflow_fupd g ∘ Precision_fupd f0 ∘ h) ∧
        ((∀g f0.
              Underflow_BeforeRounding_fupd f0 ∘ DivideByZero_fupd g =
              DivideByZero_fupd g ∘ Underflow_BeforeRounding_fupd f0) ∧
         ∀h g f0.
             Underflow_BeforeRounding_fupd f0 ∘ DivideByZero_fupd g ∘ h =
             DivideByZero_fupd g ∘ Underflow_BeforeRounding_fupd f0 ∘ h) ∧
        ((∀g f0.
              Underflow_BeforeRounding_fupd f0 ∘ InvalidOp_fupd g =
              InvalidOp_fupd g ∘ Underflow_BeforeRounding_fupd f0) ∧
         ∀h g f0.
             Underflow_BeforeRounding_fupd f0 ∘ InvalidOp_fupd g ∘ h =
             InvalidOp_fupd g ∘ Underflow_BeforeRounding_fupd f0 ∘ h) ∧
        ((∀g f0.
              Underflow_BeforeRounding_fupd f0 ∘ Overflow_fupd g =
              Overflow_fupd g ∘ Underflow_BeforeRounding_fupd f0) ∧
         ∀h g f0.
             Underflow_BeforeRounding_fupd f0 ∘ Overflow_fupd g ∘ h =
             Overflow_fupd g ∘ Underflow_BeforeRounding_fupd f0 ∘ h) ∧
        ((∀g f0.
              Underflow_BeforeRounding_fupd f0 ∘ Precision_fupd g =
              Precision_fupd g ∘ Underflow_BeforeRounding_fupd f0) ∧
         ∀h g f0.
             Underflow_BeforeRounding_fupd f0 ∘ Precision_fupd g ∘ h =
             Precision_fupd g ∘ Underflow_BeforeRounding_fupd f0 ∘ h) ∧
        ((∀g f0.
              Underflow_AfterRounding_fupd f0 ∘ DivideByZero_fupd g =
              DivideByZero_fupd g ∘ Underflow_AfterRounding_fupd f0) ∧
         ∀h g f0.
             Underflow_AfterRounding_fupd f0 ∘ DivideByZero_fupd g ∘ h =
             DivideByZero_fupd g ∘ Underflow_AfterRounding_fupd f0 ∘ h) ∧
        ((∀g f0.
              Underflow_AfterRounding_fupd f0 ∘ InvalidOp_fupd g =
              InvalidOp_fupd g ∘ Underflow_AfterRounding_fupd f0) ∧
         ∀h g f0.
             Underflow_AfterRounding_fupd f0 ∘ InvalidOp_fupd g ∘ h =
             InvalidOp_fupd g ∘ Underflow_AfterRounding_fupd f0 ∘ h) ∧
        ((∀g f0.
              Underflow_AfterRounding_fupd f0 ∘ Overflow_fupd g =
              Overflow_fupd g ∘ Underflow_AfterRounding_fupd f0) ∧
         ∀h g f0.
             Underflow_AfterRounding_fupd f0 ∘ Overflow_fupd g ∘ h =
             Overflow_fupd g ∘ Underflow_AfterRounding_fupd f0 ∘ h) ∧
        ((∀g f0.
              Underflow_AfterRounding_fupd f0 ∘ Precision_fupd g =
              Precision_fupd g ∘ Underflow_AfterRounding_fupd f0) ∧
         ∀h g f0.
             Underflow_AfterRounding_fupd f0 ∘ Precision_fupd g ∘ h =
             Precision_fupd g ∘ Underflow_AfterRounding_fupd f0 ∘ h) ∧
        (∀g f0.
             Underflow_AfterRounding_fupd f0 ∘
             Underflow_BeforeRounding_fupd g =
             Underflow_BeforeRounding_fupd g ∘
             Underflow_AfterRounding_fupd f0) ∧
        ∀h g f0.
            Underflow_AfterRounding_fupd f0 ∘
            Underflow_BeforeRounding_fupd g ∘ h =
            Underflow_BeforeRounding_fupd g ∘
            Underflow_AfterRounding_fupd f0 ∘ h
   
   [<a name="flags_fupdfupds-val"><b>flags_fupdfupds</b></a>]  Theorem
      
      ⊢ (∀g f0 f.
             f with
             &lt;|DivideByZero updated_by f0; DivideByZero updated_by g|&gt; =
             f with DivideByZero updated_by f0 ∘ g) ∧
        (∀g f0 f.
             f with &lt;|InvalidOp updated_by f0; InvalidOp updated_by g|&gt; =
             f with InvalidOp updated_by f0 ∘ g) ∧
        (∀g f0 f.
             f with &lt;|Overflow updated_by f0; Overflow updated_by g|&gt; =
             f with Overflow updated_by f0 ∘ g) ∧
        (∀g f0 f.
             f with &lt;|Precision updated_by f0; Precision updated_by g|&gt; =
             f with Precision updated_by f0 ∘ g) ∧
        (∀g f0 f.
             f with
             &lt;|Underflow_BeforeRounding updated_by f0;
               Underflow_BeforeRounding updated_by g|&gt; =
             f with Underflow_BeforeRounding updated_by f0 ∘ g) ∧
        ∀g f0 f.
            f with
            &lt;|Underflow_AfterRounding updated_by f0;
              Underflow_AfterRounding updated_by g|&gt; =
            f with Underflow_AfterRounding updated_by f0 ∘ g
   
   [<a name="flags_fupdfupds_comp-val"><b>flags_fupdfupds_comp</b></a>]  Theorem
      
      ⊢ ((∀g f0.
              DivideByZero_fupd f0 ∘ DivideByZero_fupd g =
              DivideByZero_fupd (f0 ∘ g)) ∧
         ∀h g f0.
             DivideByZero_fupd f0 ∘ DivideByZero_fupd g ∘ h =
             DivideByZero_fupd (f0 ∘ g) ∘ h) ∧
        ((∀g f0.
              InvalidOp_fupd f0 ∘ InvalidOp_fupd g =
              InvalidOp_fupd (f0 ∘ g)) ∧
         ∀h g f0.
             InvalidOp_fupd f0 ∘ InvalidOp_fupd g ∘ h =
             InvalidOp_fupd (f0 ∘ g) ∘ h) ∧
        ((∀g f0.
              Overflow_fupd f0 ∘ Overflow_fupd g = Overflow_fupd (f0 ∘ g)) ∧
         ∀h g f0.
             Overflow_fupd f0 ∘ Overflow_fupd g ∘ h =
             Overflow_fupd (f0 ∘ g) ∘ h) ∧
        ((∀g f0.
              Precision_fupd f0 ∘ Precision_fupd g =
              Precision_fupd (f0 ∘ g)) ∧
         ∀h g f0.
             Precision_fupd f0 ∘ Precision_fupd g ∘ h =
             Precision_fupd (f0 ∘ g) ∘ h) ∧
        ((∀g f0.
              Underflow_BeforeRounding_fupd f0 ∘
              Underflow_BeforeRounding_fupd g =
              Underflow_BeforeRounding_fupd (f0 ∘ g)) ∧
         ∀h g f0.
             Underflow_BeforeRounding_fupd f0 ∘
             Underflow_BeforeRounding_fupd g ∘ h =
             Underflow_BeforeRounding_fupd (f0 ∘ g) ∘ h) ∧
        (∀g f0.
             Underflow_AfterRounding_fupd f0 ∘
             Underflow_AfterRounding_fupd g =
             Underflow_AfterRounding_fupd (f0 ∘ g)) ∧
        ∀h g f0.
            Underflow_AfterRounding_fupd f0 ∘
            Underflow_AfterRounding_fupd g ∘ h =
            Underflow_AfterRounding_fupd (f0 ∘ g) ∘ h
   
   [<a name="flags_induction-val"><b>flags_induction</b></a>]  Theorem
      
      ⊢ ∀P. (∀b b0 b1 b2 b3 b4. P (flags b b0 b1 b2 b3 b4)) ⇒ ∀f. P f
   
   [<a name="flags_literal_11-val"><b>flags_literal_11</b></a>]  Theorem
      
      ⊢ ∀b41 b31 b21 b11 b01 b1 b42 b32 b22 b12 b02 b2.
            (&lt;|DivideByZero := b41; InvalidOp := b31; Overflow := b21;
               Precision := b11; Underflow_BeforeRounding := b01;
               Underflow_AfterRounding := b1|&gt; =
             &lt;|DivideByZero := b42; InvalidOp := b32; Overflow := b22;
               Precision := b12; Underflow_BeforeRounding := b02;
               Underflow_AfterRounding := b2|&gt;) ⇔
            (b41 ⇔ b42) ∧ (b31 ⇔ b32) ∧ (b21 ⇔ b22) ∧ (b11 ⇔ b12) ∧
            (b01 ⇔ b02) ∧ (b1 ⇔ b2)
   
   [<a name="flags_literal_nchotomy-val"><b>flags_literal_nchotomy</b></a>]  Theorem
      
      ⊢ ∀f.
            ∃b4 b3 b2 b1 b0 b.
                f =
                &lt;|DivideByZero := b4; InvalidOp := b3; Overflow := b2;
                  Precision := b1; Underflow_BeforeRounding := b0;
                  Underflow_AfterRounding := b|&gt;
   
   [<a name="flags_nchotomy-val"><b>flags_nchotomy</b></a>]  Theorem
      
      ⊢ ∀ff. ∃b b0 b1 b2 b3 b4. ff = flags b b0 b1 b2 b3 b4
   
   [<a name="flags_updates_eq_literal-val"><b>flags_updates_eq_literal</b></a>]  Theorem
      
      ⊢ ∀f b4 b3 b2 b1 b0 b.
            f with
            &lt;|DivideByZero := b4; InvalidOp := b3; Overflow := b2;
              Precision := b1; Underflow_BeforeRounding := b0;
              Underflow_AfterRounding := b|&gt; =
            &lt;|DivideByZero := b4; InvalidOp := b3; Overflow := b2;
              Precision := b1; Underflow_BeforeRounding := b0;
              Underflow_AfterRounding := b|&gt;
   
   [<a name="float_11-val"><b>float_11</b></a>]  Theorem
      
      ⊢ ∀a0 a1 a2 a0' a1' a2'.
            (float a0 a1 a2 = float a0' a1' a2') ⇔
            (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2')
   
   [<a name="float_Axiom-val"><b>float_Axiom</b></a>]  Theorem
      
      ⊢ ∀f. ∃fn. ∀a0 a1 a2. fn (float a0 a1 a2) = f a0 a1 a2
   
   [<a name="float_accessors-val"><b>float_accessors</b></a>]  Theorem
      
      ⊢ (∀c c0 c1. (float c c0 c1).Sign = c) ∧
        (∀c c0 c1. (float c c0 c1).Exponent = c0) ∧
        ∀c c0 c1. (float c c0 c1).Significand = c1
   
   [<a name="float_accfupds-val"><b>float_accfupds</b></a>]  Theorem
      
      ⊢ (∀f0 f. (f with Exponent updated_by f0).Sign = f.Sign) ∧
        (∀f0 f. (f with Significand updated_by f0).Sign = f.Sign) ∧
        (∀f0 f. (f with Sign updated_by f0).Exponent = f.Exponent) ∧
        (∀f0 f. (f with Significand updated_by f0).Exponent = f.Exponent) ∧
        (∀f0 f. (f with Sign updated_by f0).Significand = f.Significand) ∧
        (∀f0 f. (f with Exponent updated_by f0).Significand = f.Significand) ∧
        (∀f0 f. (f with Sign updated_by f0).Sign = f0 f.Sign) ∧
        (∀f0 f. (f with Exponent updated_by f0).Exponent = f0 f.Exponent) ∧
        ∀f0 f.
            (f with Significand updated_by f0).Significand =
            f0 f.Significand
   
   [<a name="float_add_compute-val"><b>float_add_compute</b></a>]  Theorem
      
      ⊢ (∀mode x fp_op.
             float_add mode (float_some_qnan fp_op) x =
             (check_for_signalling [x],
              float_some_qnan (FP_Add mode (float_some_qnan fp_op) x))) ∧
        (∀mode x fp_op.
             float_add mode x (float_some_qnan fp_op) =
             (check_for_signalling [x],
              float_some_qnan (FP_Add mode x (float_some_qnan fp_op)))) ∧
        (∀mode.
             float_add mode (float_minus_infinity (:τ # χ))
               (float_minus_infinity (:τ # χ)) =
             (clear_flags,float_minus_infinity (:τ # χ))) ∧
        (∀mode.
             float_add mode (float_minus_infinity (:τ # χ))
               (float_plus_infinity (:τ # χ)) =
             (invalidop_flags,
              float_some_qnan
                (FP_Add mode (float_minus_infinity (:τ # χ))
                   (float_plus_infinity (:τ # χ))))) ∧
        (∀mode.
             float_add mode (float_plus_infinity (:τ # χ))
               (float_plus_infinity (:τ # χ)) =
             (clear_flags,float_plus_infinity (:τ # χ))) ∧
        ∀mode.
            float_add mode (float_plus_infinity (:τ # χ))
              (float_minus_infinity (:τ # χ)) =
            (invalidop_flags,
             float_some_qnan
               (FP_Add mode (float_plus_infinity (:τ # χ))
                  (float_minus_infinity (:τ # χ))))
   
   [<a name="float_add_finite-val"><b>float_add_finite</b></a>]  Theorem
      
      ⊢ ∀mode x y r1 r2.
            (float_value x = Float r1) ∧ (float_value y = Float r2) ⇒
            (float_add mode x y =
             float_round_with_flags mode
               (if (r1 = 0) ∧ (r2 = 0) ∧ (x.Sign = y.Sign) then x.Sign = 1w
                else (mode = roundTowardNegative)) (r1 + r2))
   
   [<a name="float_add_finite_minus_infinity-val"><b>float_add_finite_minus_infinity</b></a>]  Theorem
      
      ⊢ ∀mode x r.
            (float_value x = Float r) ⇒
            (float_add mode x (float_minus_infinity (:τ # χ)) =
             (clear_flags,float_minus_infinity (:τ # χ)))
   
   [<a name="float_add_finite_plus_infinity-val"><b>float_add_finite_plus_infinity</b></a>]  Theorem
      
      ⊢ ∀mode x r.
            (float_value x = Float r) ⇒
            (float_add mode x (float_plus_infinity (:τ # χ)) =
             (clear_flags,float_plus_infinity (:τ # χ)))
   
   [<a name="float_add_minus_infinity_finite-val"><b>float_add_minus_infinity_finite</b></a>]  Theorem
      
      ⊢ ∀mode x r.
            (float_value x = Float r) ⇒
            (float_add mode (float_minus_infinity (:τ # χ)) x =
             (clear_flags,float_minus_infinity (:τ # χ)))
   
   [<a name="float_add_nan-val"><b>float_add_nan</b></a>]  Theorem
      
      ⊢ ∀mode x y.
            (float_value x = NaN) ∨ (float_value y = NaN) ⇒
            (float_add mode x y =
             (check_for_signalling [x; y],float_some_qnan (FP_Add mode x y)))
   
   [<a name="float_add_plus_infinity_finite-val"><b>float_add_plus_infinity_finite</b></a>]  Theorem
      
      ⊢ ∀mode x r.
            (float_value x = Float r) ⇒
            (float_add mode (float_plus_infinity (:τ # χ)) x =
             (clear_flags,float_plus_infinity (:τ # χ)))
   
   [<a name="float_case_cong-val"><b>float_case_cong</b></a>]  Theorem
      
      ⊢ ∀M M' f.
            (M = M') ∧
            (∀a0 a1 a2. (M' = float a0 a1 a2) ⇒ (f a0 a1 a2 = f' a0 a1 a2)) ⇒
            (float_CASE M f = float_CASE M' f')
   
   [<a name="float_case_eq-val"><b>float_case_eq</b></a>]  Theorem
      
      ⊢ (float_CASE x f = v) ⇔
        ∃c c0 c1. (x = float c c0 c1) ∧ (f c c0 c1 = v)
   
   [<a name="float_cases-val"><b>float_cases</b></a>]  Theorem
      
      ⊢ ∀x.
            float_is_nan x ∨ float_is_infinite x ∨ float_is_normal x ∨
            float_is_subnormal x ∨ float_is_zero x
   
   [<a name="float_cases_finite-val"><b>float_cases_finite</b></a>]  Theorem
      
      ⊢ ∀x. float_is_nan x ∨ float_is_infinite x ∨ float_is_finite x
   
   [<a name="float_compare2num_11-val"><b>float_compare2num_11</b></a>]  Theorem
      
      ⊢ ∀a a'. (float_compare2num a = float_compare2num a') ⇔ (a = a')
   
   [<a name="float_compare2num_ONTO-val"><b>float_compare2num_ONTO</b></a>]  Theorem
      
      ⊢ ∀r. r &lt; 4 ⇔ ∃a. r = float_compare2num a
   
   [<a name="float_compare2num_num2float_compare-val"><b>float_compare2num_num2float_compare</b></a>]  Theorem
      
      ⊢ ∀r. r &lt; 4 ⇔ (float_compare2num (num2float_compare r) = r)
   
   [<a name="float_compare2num_thm-val"><b>float_compare2num_thm</b></a>]  Theorem
      
      ⊢ (float_compare2num LT = 0) ∧ (float_compare2num EQ = 1) ∧
        (float_compare2num GT = 2) ∧ (float_compare2num UN = 3)
   
   [<a name="float_compare_Axiom-val"><b>float_compare_Axiom</b></a>]  Theorem
      
      ⊢ ∀x0 x1 x2 x3.
            ∃f. (f LT = x0) ∧ (f EQ = x1) ∧ (f GT = x2) ∧ (f UN = x3)
   
   [<a name="float_compare_EQ_float_compare-val"><b>float_compare_EQ_float_compare</b></a>]  Theorem
      
      ⊢ ∀a a'. (a = a') ⇔ (float_compare2num a = float_compare2num a')
   
   [<a name="float_compare_case_cong-val"><b>float_compare_case_cong</b></a>]  Theorem
      
      ⊢ ∀M M' v0 v1 v2 v3.
            (M = M') ∧ ((M' = LT) ⇒ (v0 = v0')) ∧
            ((M' = EQ) ⇒ (v1 = v1')) ∧ ((M' = GT) ⇒ (v2 = v2')) ∧
            ((M' = UN) ⇒ (v3 = v3')) ⇒
            ((case M of LT =&gt; v0 | EQ =&gt; v1 | GT =&gt; v2 | UN =&gt; v3) =
             case M' of LT =&gt; v0' | EQ =&gt; v1' | GT =&gt; v2' | UN =&gt; v3')
   
   [<a name="float_compare_case_def-val"><b>float_compare_case_def</b></a>]  Theorem
      
      ⊢ (∀v0 v1 v2 v3.
             (case LT of LT =&gt; v0 | EQ =&gt; v1 | GT =&gt; v2 | UN =&gt; v3) = v0) ∧
        (∀v0 v1 v2 v3.
             (case EQ of LT =&gt; v0 | EQ =&gt; v1 | GT =&gt; v2 | UN =&gt; v3) = v1) ∧
        (∀v0 v1 v2 v3.
             (case GT of LT =&gt; v0 | EQ =&gt; v1 | GT =&gt; v2 | UN =&gt; v3) = v2) ∧
        ∀v0 v1 v2 v3.
            (case UN of LT =&gt; v0 | EQ =&gt; v1 | GT =&gt; v2 | UN =&gt; v3) = v3
   
   [<a name="float_compare_case_eq-val"><b>float_compare_case_eq</b></a>]  Theorem
      
      ⊢ ((case x of LT =&gt; v0 | EQ =&gt; v1 | GT =&gt; v2 | UN =&gt; v3) = v) ⇔
        (x = LT) ∧ (v0 = v) ∨ (x = EQ) ∧ (v1 = v) ∨ (x = GT) ∧ (v2 = v) ∨
        (x = UN) ∧ (v3 = v)
   
   [<a name="float_compare_distinct-val"><b>float_compare_distinct</b></a>]  Theorem
      
      ⊢ LT ≠ EQ ∧ LT ≠ GT ∧ LT ≠ UN ∧ EQ ≠ GT ∧ EQ ≠ UN ∧ GT ≠ UN
   
   [<a name="float_compare_induction-val"><b>float_compare_induction</b></a>]  Theorem
      
      ⊢ ∀P. P EQ ∧ P GT ∧ P LT ∧ P UN ⇒ ∀a. P a
   
   [<a name="float_compare_nchotomy-val"><b>float_compare_nchotomy</b></a>]  Theorem
      
      ⊢ ∀a. (a = LT) ∨ (a = EQ) ∨ (a = GT) ∨ (a = UN)
   
   [<a name="float_component_equality-val"><b>float_component_equality</b></a>]  Theorem
      
      ⊢ ∀f1 f2.
            (f1 = f2) ⇔
            (f1.Sign = f2.Sign) ∧ (f1.Exponent = f2.Exponent) ∧
            (f1.Significand = f2.Significand)
   
   [<a name="float_components-val"><b>float_components</b></a>]  Theorem
      
      ⊢ ((float_plus_infinity (:τ # χ)).Sign = 0w) ∧
        ((float_plus_infinity (:τ # χ)).Exponent = UINT_MAXw) ∧
        ((float_plus_infinity (:τ # χ)).Significand = 0w) ∧
        ((float_minus_infinity (:τ # χ)).Sign = 1w) ∧
        ((float_minus_infinity (:τ # χ)).Exponent = UINT_MAXw) ∧
        ((float_minus_infinity (:τ # χ)).Significand = 0w) ∧
        ((float_plus_zero (:τ # χ)).Sign = 0w) ∧
        ((float_plus_zero (:τ # χ)).Exponent = 0w) ∧
        ((float_plus_zero (:τ # χ)).Significand = 0w) ∧
        ((float_minus_zero (:τ # χ)).Sign = 1w) ∧
        ((float_minus_zero (:τ # χ)).Exponent = 0w) ∧
        ((float_minus_zero (:τ # χ)).Significand = 0w) ∧
        ((float_plus_min (:τ # χ)).Sign = 0w) ∧
        ((float_plus_min (:τ # χ)).Exponent = 0w) ∧
        ((float_plus_min (:τ # χ)).Significand = 1w) ∧
        ((float_minus_min (:τ # χ)).Sign = 1w) ∧
        ((float_minus_min (:τ # χ)).Exponent = 0w) ∧
        ((float_minus_min (:τ # χ)).Significand = 1w) ∧
        ((float_top (:τ # χ)).Sign = 0w) ∧
        ((float_top (:τ # χ)).Exponent = UINT_MAXw − 1w) ∧
        ((float_top (:τ # χ)).Significand = UINT_MAXw) ∧
        ((float_bottom (:τ # χ)).Sign = 1w) ∧
        ((float_bottom (:τ # χ)).Exponent = UINT_MAXw − 1w) ∧
        ((float_bottom (:τ # χ)).Significand = UINT_MAXw) ∧
        (∀fp_op. (float_some_qnan fp_op).Exponent = UINT_MAXw) ∧
        (∀fp_op. (float_some_qnan fp_op).Significand ≠ 0w) ∧
        (∀x. (float_negate x).Sign = ¬x.Sign) ∧
        (∀x. (float_negate x).Exponent = x.Exponent) ∧
        ∀x. (float_negate x).Significand = x.Significand
   
   [<a name="float_distinct-val"><b>float_distinct</b></a>]  Theorem
      
      ⊢ float_plus_infinity (:τ # χ) ≠ float_minus_infinity (:τ # χ) ∧
        float_plus_infinity (:τ # χ) ≠ float_plus_zero (:τ # χ) ∧
        float_plus_infinity (:τ # χ) ≠ float_minus_zero (:τ # χ) ∧
        float_plus_infinity (:τ # χ) ≠ float_top (:τ # χ) ∧
        float_plus_infinity (:τ # χ) ≠ float_bottom (:τ # χ) ∧
        float_plus_infinity (:τ # χ) ≠ float_plus_min (:τ # χ) ∧
        float_plus_infinity (:τ # χ) ≠ float_minus_min (:τ # χ) ∧
        (∀fp_op. float_plus_infinity (:τ # χ) ≠ float_some_qnan fp_op) ∧
        float_minus_infinity (:τ # χ) ≠ float_plus_zero (:τ # χ) ∧
        float_minus_infinity (:τ # χ) ≠ float_minus_zero (:τ # χ) ∧
        float_minus_infinity (:τ # χ) ≠ float_top (:τ # χ) ∧
        float_minus_infinity (:τ # χ) ≠ float_bottom (:τ # χ) ∧
        float_minus_infinity (:τ # χ) ≠ float_plus_min (:τ # χ) ∧
        float_minus_infinity (:τ # χ) ≠ float_minus_min (:τ # χ) ∧
        (∀fp_op. float_minus_infinity (:τ # χ) ≠ float_some_qnan fp_op) ∧
        float_plus_zero (:τ # χ) ≠ float_minus_zero (:τ # χ) ∧
        float_plus_zero (:τ # χ) ≠ float_top (:τ # χ) ∧
        float_plus_zero (:τ # χ) ≠ float_bottom (:τ # χ) ∧
        float_plus_zero (:τ # χ) ≠ float_plus_min (:τ # χ) ∧
        float_plus_zero (:τ # χ) ≠ float_minus_min (:τ # χ) ∧
        (∀fp_op. float_plus_zero (:τ # χ) ≠ float_some_qnan fp_op) ∧
        float_minus_zero (:τ # χ) ≠ float_top (:τ # χ) ∧
        float_minus_zero (:τ # χ) ≠ float_bottom (:τ # χ) ∧
        float_minus_zero (:τ # χ) ≠ float_plus_min (:τ # χ) ∧
        float_minus_zero (:τ # χ) ≠ float_minus_min (:τ # χ) ∧
        (∀fp_op. float_minus_zero (:τ # χ) ≠ float_some_qnan fp_op) ∧
        float_top (:τ # χ) ≠ float_minus_min (:τ # χ) ∧
        float_top (:τ # χ) ≠ float_bottom (:τ # χ) ∧
        (∀fp_op. float_top (:τ # χ) ≠ float_some_qnan fp_op) ∧
        float_bottom (:τ # χ) ≠ float_plus_min (:τ # χ) ∧
        (∀fp_op. float_bottom (:τ # χ) ≠ float_some_qnan fp_op) ∧
        (∀fp_op. float_plus_min (:τ # χ) ≠ float_some_qnan fp_op) ∧
        float_plus_min (:τ # χ) ≠ float_minus_min (:τ # χ) ∧
        (∀fp_op. float_minus_min (:τ # χ) ≠ float_some_qnan fp_op) ∧
        ∀x. float_negate x ≠ x
   
   [<a name="float_distinct_finite-val"><b>float_distinct_finite</b></a>]  Theorem
      
      ⊢ ∀x.
            ¬(float_is_nan x ∧ float_is_infinite x) ∧
            ¬(float_is_nan x ∧ float_is_finite x) ∧
            ¬(float_is_infinite x ∧ float_is_finite x)
   
   [<a name="float_div_compute-val"><b>float_div_compute</b></a>]  Theorem
      
      ⊢ (∀mode x fp_op.
             float_div mode (float_some_qnan fp_op) x =
             (check_for_signalling [x],
              float_some_qnan (FP_Div mode (float_some_qnan fp_op) x))) ∧
        (∀mode x fp_op.
             float_div mode x (float_some_qnan fp_op) =
             (check_for_signalling [x],
              float_some_qnan (FP_Div mode x (float_some_qnan fp_op)))) ∧
        (∀mode.
             float_div mode (float_minus_infinity (:τ # χ))
               (float_minus_infinity (:τ # χ)) =
             (invalidop_flags,
              float_some_qnan
                (FP_Div mode (float_minus_infinity (:τ # χ))
                   (float_minus_infinity (:τ # χ))))) ∧
        (∀mode.
             float_div mode (float_minus_infinity (:τ # χ))
               (float_plus_infinity (:τ # χ)) =
             (invalidop_flags,
              float_some_qnan
                (FP_Div mode (float_minus_infinity (:τ # χ))
                   (float_plus_infinity (:τ # χ))))) ∧
        (∀mode.
             float_div mode (float_plus_infinity (:τ # χ))
               (float_plus_infinity (:τ # χ)) =
             (invalidop_flags,
              float_some_qnan
                (FP_Div mode (float_plus_infinity (:τ # χ))
                   (float_plus_infinity (:τ # χ))))) ∧
        ∀mode.
            float_div mode (float_plus_infinity (:τ # χ))
              (float_minus_infinity (:τ # χ)) =
            (invalidop_flags,
             float_some_qnan
               (FP_Div mode (float_plus_infinity (:τ # χ))
                  (float_minus_infinity (:τ # χ))))
   
   [<a name="float_div_finite-val"><b>float_div_finite</b></a>]  Theorem
      
      ⊢ ∀mode x y r1 r2.
            (float_value x = Float r1) ∧ (float_value y = Float r2) ⇒
            (float_div mode x y =
             if r2 = 0 then
               if r1 = 0 then
                 (invalidop_flags,float_some_qnan (FP_Div mode x y))
               else
                 (dividezero_flags,
                  if x.Sign = y.Sign then float_plus_infinity (:τ # χ)
                  else float_minus_infinity (:τ # χ))
             else float_round_with_flags mode (x.Sign ≠ y.Sign) (r1 / r2))
   
   [<a name="float_div_finite_minus_infinity-val"><b>float_div_finite_minus_infinity</b></a>]  Theorem
      
      ⊢ ∀mode x r.
            (float_value x = Float r) ⇒
            (float_div mode x (float_minus_infinity (:τ # χ)) =
             (clear_flags,if x.Sign = 0w then float_minus_zero (:τ # χ)
              else float_plus_zero (:τ # χ)))
   
   [<a name="float_div_finite_plus_infinity-val"><b>float_div_finite_plus_infinity</b></a>]  Theorem
      
      ⊢ ∀mode x r.
            (float_value x = Float r) ⇒
            (float_div mode x (float_plus_infinity (:τ # χ)) =
             (clear_flags,if x.Sign = 0w then float_plus_zero (:τ # χ)
              else float_minus_zero (:τ # χ)))
   
   [<a name="float_div_minus_infinity_finite-val"><b>float_div_minus_infinity_finite</b></a>]  Theorem
      
      ⊢ ∀mode x r.
            (float_value x = Float r) ⇒
            (float_div mode (float_minus_infinity (:τ # χ)) x =
             (clear_flags,if x.Sign = 0w then float_minus_infinity (:τ # χ)
              else float_plus_infinity (:τ # χ)))
   
   [<a name="float_div_nan-val"><b>float_div_nan</b></a>]  Theorem
      
      ⊢ ∀mode x y.
            (float_value x = NaN) ∨ (float_value y = NaN) ⇒
            (float_div mode x y =
             (check_for_signalling [x; y],float_some_qnan (FP_Div mode x y)))
   
   [<a name="float_div_plus_infinity_finite-val"><b>float_div_plus_infinity_finite</b></a>]  Theorem
      
      ⊢ ∀mode x r.
            (float_value x = Float r) ⇒
            (float_div mode (float_plus_infinity (:τ # χ)) x =
             (clear_flags,if x.Sign = 0w then float_plus_infinity (:τ # χ)
              else float_minus_infinity (:τ # χ)))
   
   [<a name="float_fn_updates-val"><b>float_fn_updates</b></a>]  Theorem
      
      ⊢ (∀f c c0 c1.
             float c c0 c1 with Sign updated_by f = float (f c) c0 c1) ∧
        (∀f c c0 c1.
             float c c0 c1 with Exponent updated_by f = float c (f c0) c1) ∧
        ∀f c c0 c1.
            float c c0 c1 with Significand updated_by f = float c c0 (f c1)
   
   [<a name="float_fupdcanon-val"><b>float_fupdcanon</b></a>]  Theorem
      
      ⊢ (∀g f0 f.
             f with &lt;|Exponent updated_by f0; Sign updated_by g|&gt; =
             f with &lt;|Sign updated_by g; Exponent updated_by f0|&gt;) ∧
        (∀g f0 f.
             f with &lt;|Significand updated_by f0; Sign updated_by g|&gt; =
             f with &lt;|Sign updated_by g; Significand updated_by f0|&gt;) ∧
        ∀g f0 f.
            f with &lt;|Significand updated_by f0; Exponent updated_by g|&gt; =
            f with &lt;|Exponent updated_by g; Significand updated_by f0|&gt;
   
   [<a name="float_fupdcanon_comp-val"><b>float_fupdcanon_comp</b></a>]  Theorem
      
      ⊢ ((∀g f0.
              Exponent_fupd f0 ∘ Sign_fupd g =
              Sign_fupd g ∘ Exponent_fupd f0) ∧
         ∀h g f0.
             Exponent_fupd f0 ∘ Sign_fupd g ∘ h =
             Sign_fupd g ∘ Exponent_fupd f0 ∘ h) ∧
        ((∀g f0.
              Significand_fupd f0 ∘ Sign_fupd g =
              Sign_fupd g ∘ Significand_fupd f0) ∧
         ∀h g f0.
             Significand_fupd f0 ∘ Sign_fupd g ∘ h =
             Sign_fupd g ∘ Significand_fupd f0 ∘ h) ∧
        (∀g f0.
             Significand_fupd f0 ∘ Exponent_fupd g =
             Exponent_fupd g ∘ Significand_fupd f0) ∧
        ∀h g f0.
            Significand_fupd f0 ∘ Exponent_fupd g ∘ h =
            Exponent_fupd g ∘ Significand_fupd f0 ∘ h
   
   [<a name="float_fupdfupds-val"><b>float_fupdfupds</b></a>]  Theorem
      
      ⊢ (∀g f0 f.
             f with &lt;|Sign updated_by f0; Sign updated_by g|&gt; =
             f with Sign updated_by f0 ∘ g) ∧
        (∀g f0 f.
             f with &lt;|Exponent updated_by f0; Exponent updated_by g|&gt; =
             f with Exponent updated_by f0 ∘ g) ∧
        ∀g f0 f.
            f with &lt;|Significand updated_by f0; Significand updated_by g|&gt; =
            f with Significand updated_by f0 ∘ g
   
   [<a name="float_fupdfupds_comp-val"><b>float_fupdfupds_comp</b></a>]  Theorem
      
      ⊢ ((∀g f0. Sign_fupd f0 ∘ Sign_fupd g = Sign_fupd (f0 ∘ g)) ∧
         ∀h g f0. Sign_fupd f0 ∘ Sign_fupd g ∘ h = Sign_fupd (f0 ∘ g) ∘ h) ∧
        ((∀g f0.
              Exponent_fupd f0 ∘ Exponent_fupd g = Exponent_fupd (f0 ∘ g)) ∧
         ∀h g f0.
             Exponent_fupd f0 ∘ Exponent_fupd g ∘ h =
             Exponent_fupd (f0 ∘ g) ∘ h) ∧
        (∀g f0.
             Significand_fupd f0 ∘ Significand_fupd g =
             Significand_fupd (f0 ∘ g)) ∧
        ∀h g f0.
            Significand_fupd f0 ∘ Significand_fupd g ∘ h =
            Significand_fupd (f0 ∘ g) ∘ h
   
   [<a name="float_induction-val"><b>float_induction</b></a>]  Theorem
      
      ⊢ ∀P. (∀c c0 c1. P (float c c0 c1)) ⇒ ∀f. P f
   
   [<a name="float_infinities-val"><b>float_infinities</b></a>]  Theorem
      
      ⊢ ∀x.
            float_is_infinite x ⇔
            (x = float_plus_infinity (:τ # χ)) ∨
            (x = float_minus_infinity (:τ # χ))
   
   [<a name="float_infinities_distinct-val"><b>float_infinities_distinct</b></a>]  Theorem
      
      ⊢ ∀x.
            ¬((x = float_plus_infinity (:τ # χ)) ∧
             (x = float_minus_infinity (:τ # χ)))
   
   [<a name="float_infinity_negate_abs-val"><b>float_infinity_negate_abs</b></a>]  Theorem
      
      ⊢ (float_negate (float_plus_infinity (:τ # χ)) =
         float_minus_infinity (:τ # χ)) ∧
        (float_negate (float_minus_infinity (:τ # χ)) =
         float_plus_infinity (:τ # χ)) ∧
        (float_abs (float_plus_infinity (:τ # χ)) =
         float_plus_infinity (:τ # χ)) ∧
        (float_abs (float_minus_infinity (:τ # χ)) =
         float_plus_infinity (:τ # χ))
   
   [<a name="float_is_distinct-val"><b>float_is_distinct</b></a>]  Theorem
      
      ⊢ ∀x.
            ¬(float_is_nan x ∧ float_is_infinite x) ∧
            ¬(float_is_nan x ∧ float_is_normal x) ∧
            ¬(float_is_nan x ∧ float_is_subnormal x) ∧
            ¬(float_is_nan x ∧ float_is_zero x) ∧
            ¬(float_is_infinite x ∧ float_is_normal x) ∧
            ¬(float_is_infinite x ∧ float_is_subnormal x) ∧
            ¬(float_is_infinite x ∧ float_is_zero x) ∧
            ¬(float_is_normal x ∧ float_is_subnormal x) ∧
            ¬(float_is_normal x ∧ float_is_zero x) ∧
            ¬(float_is_subnormal x ∧ float_is_zero x)
   
   [<a name="float_is_finite-val"><b>float_is_finite</b></a>]  Theorem
      
      ⊢ ∀x.
            float_is_finite x ⇔
            float_is_normal x ∨ float_is_subnormal x ∨ float_is_zero x
   
   [<a name="float_is_zero-val"><b>float_is_zero</b></a>]  Theorem
      
      ⊢ ∀x. float_is_zero x ⇔ (x.Exponent = 0w) ∧ (x.Significand = 0w)
   
   [<a name="float_is_zero_to_real-val"><b>float_is_zero_to_real</b></a>]  Theorem
      
      ⊢ ∀x. float_is_zero x ⇔ (float_to_real x = 0)
   
   [<a name="float_literal_11-val"><b>float_literal_11</b></a>]  Theorem
      
      ⊢ ∀c11 c01 c1 c12 c02 c2.
            (&lt;|Sign := c11; Exponent := c01; Significand := c1|&gt; =
             &lt;|Sign := c12; Exponent := c02; Significand := c2|&gt;) ⇔
            (c11 = c12) ∧ (c01 = c02) ∧ (c1 = c2)
   
   [<a name="float_literal_nchotomy-val"><b>float_literal_nchotomy</b></a>]  Theorem
      
      ⊢ ∀f. ∃c1 c0 c. f = &lt;|Sign := c1; Exponent := c0; Significand := c|&gt;
   
   [<a name="float_minus_infinity-val"><b>float_minus_infinity</b></a>]  Theorem
      
      ⊢ float_minus_infinity (:τ # χ) =
        &lt;|Sign := 1w; Exponent := UINT_MAXw; Significand := 0w|&gt;
   
   [<a name="float_minus_zero-val"><b>float_minus_zero</b></a>]  Theorem
      
      ⊢ float_minus_zero (:τ # χ) =
        &lt;|Sign := 1w; Exponent := 0w; Significand := 0w|&gt;
   
   [<a name="float_mul_compute-val"><b>float_mul_compute</b></a>]  Theorem
      
      ⊢ (∀mode x fp_op.
             float_mul mode (float_some_qnan fp_op) x =
             (check_for_signalling [x],
              float_some_qnan (FP_Mul mode (float_some_qnan fp_op) x))) ∧
        (∀mode x fp_op.
             float_mul mode x (float_some_qnan fp_op) =
             (check_for_signalling [x],
              float_some_qnan (FP_Mul mode x (float_some_qnan fp_op)))) ∧
        (∀mode.
             float_mul mode (float_minus_infinity (:τ # χ))
               (float_minus_infinity (:τ # χ)) =
             (clear_flags,float_plus_infinity (:τ # χ))) ∧
        (∀mode.
             float_mul mode (float_minus_infinity (:τ # χ))
               (float_plus_infinity (:τ # χ)) =
             (clear_flags,float_minus_infinity (:τ # χ))) ∧
        (∀mode.
             float_mul mode (float_plus_infinity (:τ # χ))
               (float_plus_infinity (:τ # χ)) =
             (clear_flags,float_plus_infinity (:τ # χ))) ∧
        ∀mode.
            float_mul mode (float_plus_infinity (:τ # χ))
              (float_minus_infinity (:τ # χ)) =
            (clear_flags,float_minus_infinity (:τ # χ))
   
   [<a name="float_mul_finite-val"><b>float_mul_finite</b></a>]  Theorem
      
      ⊢ ∀mode x y r1 r2.
            (float_value x = Float r1) ∧ (float_value y = Float r2) ⇒
            (float_mul mode x y =
             float_round_with_flags mode (x.Sign ≠ y.Sign) (r1 * r2))
   
   [<a name="float_mul_finite_minus_infinity-val"><b>float_mul_finite_minus_infinity</b></a>]  Theorem
      
      ⊢ ∀mode x r.
            (float_value x = Float r) ⇒
            (float_mul mode x (float_minus_infinity (:τ # χ)) =
             if r = 0 then
               (invalidop_flags,
                float_some_qnan
                  (FP_Mul mode x (float_minus_infinity (:τ # χ))))
             else
               (clear_flags,
                if x.Sign = 0w then float_minus_infinity (:τ # χ)
                else float_plus_infinity (:τ # χ)))
   
   [<a name="float_mul_finite_plus_infinity-val"><b>float_mul_finite_plus_infinity</b></a>]  Theorem
      
      ⊢ ∀mode x r.
            (float_value x = Float r) ⇒
            (float_mul mode x (float_plus_infinity (:τ # χ)) =
             if r = 0 then
               (invalidop_flags,
                float_some_qnan
                  (FP_Mul mode x (float_plus_infinity (:τ # χ))))
             else
               (clear_flags,
                if x.Sign = 0w then float_plus_infinity (:τ # χ)
                else float_minus_infinity (:τ # χ)))
   
   [<a name="float_mul_minus_infinity_finite-val"><b>float_mul_minus_infinity_finite</b></a>]  Theorem
      
      ⊢ ∀mode x r.
            (float_value x = Float r) ⇒
            (float_mul mode (float_minus_infinity (:τ # χ)) x =
             if r = 0 then
               (invalidop_flags,
                float_some_qnan
                  (FP_Mul mode (float_minus_infinity (:τ # χ)) x))
             else
               (clear_flags,
                if x.Sign = 0w then float_minus_infinity (:τ # χ)
                else float_plus_infinity (:τ # χ)))
   
   [<a name="float_mul_nan-val"><b>float_mul_nan</b></a>]  Theorem
      
      ⊢ ∀mode x y.
            (float_value x = NaN) ∨ (float_value y = NaN) ⇒
            (float_mul mode x y =
             (check_for_signalling [x; y],float_some_qnan (FP_Mul mode x y)))
   
   [<a name="float_mul_plus_infinity_finite-val"><b>float_mul_plus_infinity_finite</b></a>]  Theorem
      
      ⊢ ∀mode x r.
            (float_value x = Float r) ⇒
            (float_mul mode (float_plus_infinity (:τ # χ)) x =
             if r = 0 then
               (invalidop_flags,
                float_some_qnan
                  (FP_Mul mode (float_plus_infinity (:τ # χ)) x))
             else
               (clear_flags,
                if x.Sign = 0w then float_plus_infinity (:τ # χ)
                else float_minus_infinity (:τ # χ)))
   
   [<a name="float_nchotomy-val"><b>float_nchotomy</b></a>]  Theorem
      
      ⊢ ∀ff. ∃c c0 c1. ff = float c c0 c1
   
   [<a name="float_negate_negate-val"><b>float_negate_negate</b></a>]  Theorem
      
      ⊢ ∀x. float_negate (float_negate x) = x
   
   [<a name="float_round_bottom-val"><b>float_round_bottom</b></a>]  Theorem
      
      ⊢ ∀mode toneg r.
            (round mode r = float_bottom (:τ # χ)) ⇒
            (float_round mode toneg r = float_bottom (:τ # χ))
   
   [<a name="float_round_minus_infinity-val"><b>float_round_minus_infinity</b></a>]  Theorem
      
      ⊢ ∀mode toneg r.
            (round mode r = float_minus_infinity (:τ # χ)) ⇒
            (float_round mode toneg r = float_minus_infinity (:τ # χ))
   
   [<a name="float_round_non_zero-val"><b>float_round_non_zero</b></a>]  Theorem
      
      ⊢ ∀mode toneg r s e f.
            (round mode r = &lt;|Sign := s; Exponent := e; Significand := f|&gt;) ∧
            (e ≠ 0w ∨ f ≠ 0w) ⇒
            (float_round mode toneg r =
             &lt;|Sign := s; Exponent := e; Significand := f|&gt;)
   
   [<a name="float_round_plus_infinity-val"><b>float_round_plus_infinity</b></a>]  Theorem
      
      ⊢ ∀mode toneg r.
            (round mode r = float_plus_infinity (:τ # χ)) ⇒
            (float_round mode toneg r = float_plus_infinity (:τ # χ))
   
   [<a name="float_round_roundTowardNegative_minus_infinity-val"><b>float_round_roundTowardNegative_minus_infinity</b></a>]  Theorem
      
      ⊢ ∀b y x.
            x &lt; -largest (:τ # χ) ⇒
            (float_round roundTowardNegative b x =
             float_minus_infinity (:τ # χ))
   
   [<a name="float_round_roundTowardNegative_top-val"><b>float_round_roundTowardNegative_top</b></a>]  Theorem
      
      ⊢ ∀b y x.
            largest (:τ # χ) &lt; x ⇒
            (float_round roundTowardNegative b x = float_top (:τ # χ))
   
   [<a name="float_round_roundTowardPositive_bottom-val"><b>float_round_roundTowardPositive_bottom</b></a>]  Theorem
      
      ⊢ ∀b y x.
            x &lt; -largest (:τ # χ) ⇒
            (float_round roundTowardPositive b x = float_bottom (:τ # χ))
   
   [<a name="float_round_roundTowardPositive_plus_infinity-val"><b>float_round_roundTowardPositive_plus_infinity</b></a>]  Theorem
      
      ⊢ ∀b y x.
            largest (:τ # χ) &lt; x ⇒
            (float_round roundTowardPositive b x =
             float_plus_infinity (:τ # χ))
   
   [<a name="float_round_roundTowardZero_bottom-val"><b>float_round_roundTowardZero_bottom</b></a>]  Theorem
      
      ⊢ ∀b y x.
            x &lt; -largest (:τ # χ) ⇒
            (float_round roundTowardZero b x = float_bottom (:τ # χ))
   
   [<a name="float_round_roundTowardZero_top-val"><b>float_round_roundTowardZero_top</b></a>]  Theorem
      
      ⊢ ∀b y x.
            largest (:τ # χ) &lt; x ⇒
            (float_round roundTowardZero b x = float_top (:τ # χ))
   
   [<a name="float_round_to_integral_compute-val"><b>float_round_to_integral_compute</b></a>]  Theorem
      
      ⊢ (∀m.
             float_round_to_integral m (float_minus_infinity (:τ # χ)) =
             float_minus_infinity (:τ # χ)) ∧
        (∀m.
             float_round_to_integral m (float_plus_infinity (:τ # χ)) =
             float_plus_infinity (:τ # χ)) ∧
        ∀m fp_op.
            float_round_to_integral m (float_some_qnan fp_op) =
            float_some_qnan fp_op
   
   [<a name="float_round_top-val"><b>float_round_top</b></a>]  Theorem
      
      ⊢ ∀mode toneg r.
            (round mode r = float_top (:τ # χ)) ⇒
            (float_round mode toneg r = float_top (:τ # χ))
   
   [<a name="float_sets-val"><b>float_sets</b></a>]  Theorem
      
      ⊢ (float_is_zero =
         {float_minus_zero (:τ # χ); float_plus_zero (:τ # χ)}) ∧
        (float_is_infinite =
         {float_minus_infinity (:τ # χ); float_plus_infinity (:τ # χ)})
   
   [<a name="float_sub_compute-val"><b>float_sub_compute</b></a>]  Theorem
      
      ⊢ (∀mode x fp_op.
             float_sub mode (float_some_qnan fp_op) x =
             (check_for_signalling [x],
              float_some_qnan (FP_Sub mode (float_some_qnan fp_op) x))) ∧
        (∀mode x fp_op.
             float_sub mode x (float_some_qnan fp_op) =
             (check_for_signalling [x],
              float_some_qnan (FP_Sub mode x (float_some_qnan fp_op)))) ∧
        (∀mode.
             float_sub mode (float_minus_infinity (:τ # χ))
               (float_minus_infinity (:τ # χ)) =
             (invalidop_flags,
              float_some_qnan
                (FP_Sub mode (float_minus_infinity (:τ # χ))
                   (float_minus_infinity (:τ # χ))))) ∧
        (∀mode.
             float_sub mode (float_minus_infinity (:τ # χ))
               (float_plus_infinity (:τ # χ)) =
             (clear_flags,float_minus_infinity (:τ # χ))) ∧
        (∀mode.
             float_sub mode (float_plus_infinity (:τ # χ))
               (float_plus_infinity (:τ # χ)) =
             (invalidop_flags,
              float_some_qnan
                (FP_Sub mode (float_plus_infinity (:τ # χ))
                   (float_plus_infinity (:τ # χ))))) ∧
        ∀mode.
            float_sub mode (float_plus_infinity (:τ # χ))
              (float_minus_infinity (:τ # χ)) =
            (clear_flags,float_plus_infinity (:τ # χ))
   
   [<a name="float_sub_finite-val"><b>float_sub_finite</b></a>]  Theorem
      
      ⊢ ∀mode x y r1 r2.
            (float_value x = Float r1) ∧ (float_value y = Float r2) ⇒
            (float_sub mode x y =
             float_round_with_flags mode
               (if (r1 = 0) ∧ (r2 = 0) ∧ x.Sign ≠ y.Sign then x.Sign = 1w
                else (mode = roundTowardNegative)) (r1 − r2))
   
   [<a name="float_sub_finite_minus_infinity-val"><b>float_sub_finite_minus_infinity</b></a>]  Theorem
      
      ⊢ ∀mode x r.
            (float_value x = Float r) ⇒
            (float_sub mode x (float_minus_infinity (:τ # χ)) =
             (clear_flags,float_plus_infinity (:τ # χ)))
   
   [<a name="float_sub_finite_plus_infinity-val"><b>float_sub_finite_plus_infinity</b></a>]  Theorem
      
      ⊢ ∀mode x r.
            (float_value x = Float r) ⇒
            (float_sub mode x (float_plus_infinity (:τ # χ)) =
             (clear_flags,float_minus_infinity (:τ # χ)))
   
   [<a name="float_sub_minus_infinity_finite-val"><b>float_sub_minus_infinity_finite</b></a>]  Theorem
      
      ⊢ ∀mode x r.
            (float_value x = Float r) ⇒
            (float_sub mode (float_minus_infinity (:τ # χ)) x =
             (clear_flags,float_minus_infinity (:τ # χ)))
   
   [<a name="float_sub_nan-val"><b>float_sub_nan</b></a>]  Theorem
      
      ⊢ ∀mode x y.
            (float_value x = NaN) ∨ (float_value y = NaN) ⇒
            (float_sub mode x y =
             (check_for_signalling [x; y],float_some_qnan (FP_Sub mode x y)))
   
   [<a name="float_sub_plus_infinity_finite-val"><b>float_sub_plus_infinity_finite</b></a>]  Theorem
      
      ⊢ ∀mode x r.
            (float_value x = Float r) ⇒
            (float_sub mode (float_plus_infinity (:τ # χ)) x =
             (clear_flags,float_plus_infinity (:τ # χ)))
   
   [<a name="float_tests-val"><b>float_tests</b></a>]  Theorem
      
      ⊢ (∀s e f.
             float_is_nan &lt;|Sign := s; Exponent := e; Significand := f|&gt; ⇔
             (e = -1w) ∧ f ≠ 0w) ∧
        (∀s e f.
             float_is_signalling
               &lt;|Sign := s; Exponent := e; Significand := f|&gt; ⇔
             (e = -1w) ∧ ¬word_msb f ∧ f ≠ 0w) ∧
        (∀s e f.
             float_is_infinite
               &lt;|Sign := s; Exponent := e; Significand := f|&gt; ⇔
             (e = -1w) ∧ (f = 0w)) ∧
        (∀s e f.
             float_is_normal &lt;|Sign := s; Exponent := e; Significand := f|&gt; ⇔
             e ≠ 0w ∧ e ≠ -1w) ∧
        (∀s e f.
             float_is_subnormal
               &lt;|Sign := s; Exponent := e; Significand := f|&gt; ⇔
             (e = 0w) ∧ f ≠ 0w) ∧
        (∀s e f.
             float_is_zero &lt;|Sign := s; Exponent := e; Significand := f|&gt; ⇔
             (e = 0w) ∧ (f = 0w)) ∧
        ∀s e f.
            float_is_finite &lt;|Sign := s; Exponent := e; Significand := f|&gt; ⇔
            e ≠ -1w
   
   [<a name="float_to_real-val"><b>float_to_real</b></a>]  Theorem
      
      ⊢ ∀s e f.
            float_to_real &lt;|Sign := s; Exponent := e; Significand := f|&gt; =
            (let
               r =
                 if e = 0w then
                   2 / &(2 ** bias (:χ)) * (&w2n f / &dimword (:τ))
                 else
                   &(2 ** w2n e) / &(2 ** bias (:χ)) *
                   (1 + &w2n f / &dimword (:τ))
             in
               if s = 1w then -r else r)
   
   [<a name="float_to_real_eq-val"><b>float_to_real_eq</b></a>]  Theorem
      
      ⊢ ∀x y.
            (float_to_real x = float_to_real y) ⇔
            (x = y) ∨ float_is_zero x ∧ float_is_zero y
   
   [<a name="float_to_real_negate-val"><b>float_to_real_negate</b></a>]  Theorem
      
      ⊢ ∀x. float_to_real (float_negate x) = -float_to_real x
   
   [<a name="float_updates_eq_literal-val"><b>float_updates_eq_literal</b></a>]  Theorem
      
      ⊢ ∀f c1 c0 c.
            f with &lt;|Sign := c1; Exponent := c0; Significand := c|&gt; =
            &lt;|Sign := c1; Exponent := c0; Significand := c|&gt;
   
   [<a name="float_value_11-val"><b>float_value_11</b></a>]  Theorem
      
      ⊢ ∀a a'. (Float a = Float a') ⇔ (a = a')
   
   [<a name="float_value_Axiom-val"><b>float_value_Axiom</b></a>]  Theorem
      
      ⊢ ∀f0 f1 f2.
            ∃fn.
                (∀a. fn (Float a) = f0 a) ∧ (fn Infinity = f1) ∧
                (fn NaN = f2)
   
   [<a name="float_value_case_cong-val"><b>float_value_case_cong</b></a>]  Theorem
      
      ⊢ ∀M M' f v v1.
            (M = M') ∧ (∀a. (M' = Float a) ⇒ (f a = f' a)) ∧
            ((M' = Infinity) ⇒ (v = v')) ∧ ((M' = NaN) ⇒ (v1 = v1')) ⇒
            (float_value_CASE M f v v1 = float_value_CASE M' f' v' v1')
   
   [<a name="float_value_case_eq-val"><b>float_value_case_eq</b></a>]  Theorem
      
      ⊢ (float_value_CASE x f v v1 = v') ⇔
        (∃r. (x = Float r) ∧ (f r = v')) ∨ (x = Infinity) ∧ (v = v') ∨
        (x = NaN) ∧ (v1 = v')
   
   [<a name="float_value_distinct-val"><b>float_value_distinct</b></a>]  Theorem
      
      ⊢ (∀a. Float a ≠ Infinity) ∧ (∀a. Float a ≠ NaN) ∧ Infinity ≠ NaN
   
   [<a name="float_value_induction-val"><b>float_value_induction</b></a>]  Theorem
      
      ⊢ ∀P. (∀r. P (Float r)) ∧ P Infinity ∧ P NaN ⇒ ∀f. P f
   
   [<a name="float_value_nchotomy-val"><b>float_value_nchotomy</b></a>]  Theorem
      
      ⊢ ∀ff. (∃r. ff = Float r) ∨ (ff = Infinity) ∨ (ff = NaN)
   
   [<a name="float_values-val"><b>float_values</b></a>]  Theorem
      
      ⊢ (float_value (float_plus_infinity (:τ # χ)) = Infinity) ∧
        (float_value (float_minus_infinity (:τ # χ)) = Infinity) ∧
        (∀fp_op. float_value (float_some_qnan fp_op) = NaN) ∧
        (float_value (float_plus_zero (:τ # χ)) = Float 0) ∧
        (float_value (float_minus_zero (:τ # χ)) = Float 0) ∧
        (float_value (float_plus_min (:τ # χ)) =
         Float (2 / 2 pow (bias (:χ) + precision (:τ)))) ∧
        (float_value (float_minus_min (:τ # χ)) =
         Float (-2 / 2 pow (bias (:χ) + precision (:τ))))
   
   [<a name="fp_op_11-val"><b>fp_op_11</b></a>]  Theorem
      
      ⊢ (∀a0 a1 a0' a1'.
             (FP_Sqrt a0 a1 = FP_Sqrt a0' a1') ⇔ (a0 = a0') ∧ (a1 = a1')) ∧
        (∀a0 a1 a2 a0' a1' a2'.
             (FP_Add a0 a1 a2 = FP_Add a0' a1' a2') ⇔
             (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2')) ∧
        (∀a0 a1 a2 a0' a1' a2'.
             (FP_Sub a0 a1 a2 = FP_Sub a0' a1' a2') ⇔
             (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2')) ∧
        (∀a0 a1 a2 a0' a1' a2'.
             (FP_Mul a0 a1 a2 = FP_Mul a0' a1' a2') ⇔
             (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2')) ∧
        (∀a0 a1 a2 a0' a1' a2'.
             (FP_Div a0 a1 a2 = FP_Div a0' a1' a2') ⇔
             (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2')) ∧
        (∀a0 a1 a2 a3 a0' a1' a2' a3'.
             (FP_MulAdd a0 a1 a2 a3 = FP_MulAdd a0' a1' a2' a3') ⇔
             (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2') ∧ (a3 = a3')) ∧
        ∀a0 a1 a2 a3 a0' a1' a2' a3'.
            (FP_MulSub a0 a1 a2 a3 = FP_MulSub a0' a1' a2' a3') ⇔
            (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2') ∧ (a3 = a3')
   
   [<a name="fp_op_Axiom-val"><b>fp_op_Axiom</b></a>]  Theorem
      
      ⊢ ∀f0 f1 f2 f3 f4 f5 f6.
            ∃fn.
                (∀a0 a1. fn (FP_Sqrt a0 a1) = f0 a0 a1) ∧
                (∀a0 a1 a2. fn (FP_Add a0 a1 a2) = f1 a0 a1 a2) ∧
                (∀a0 a1 a2. fn (FP_Sub a0 a1 a2) = f2 a0 a1 a2) ∧
                (∀a0 a1 a2. fn (FP_Mul a0 a1 a2) = f3 a0 a1 a2) ∧
                (∀a0 a1 a2. fn (FP_Div a0 a1 a2) = f4 a0 a1 a2) ∧
                (∀a0 a1 a2 a3. fn (FP_MulAdd a0 a1 a2 a3) = f5 a0 a1 a2 a3) ∧
                ∀a0 a1 a2 a3. fn (FP_MulSub a0 a1 a2 a3) = f6 a0 a1 a2 a3
   
   [<a name="fp_op_case_cong-val"><b>fp_op_case_cong</b></a>]  Theorem
      
      ⊢ ∀M M' f f1 f2 f3 f4 f5 f6.
            (M = M') ∧
            (∀a0 a1. (M' = FP_Sqrt a0 a1) ⇒ (f a0 a1 = f' a0 a1)) ∧
            (∀a0 a1 a2.
                 (M' = FP_Add a0 a1 a2) ⇒ (f1 a0 a1 a2 = f1' a0 a1 a2)) ∧
            (∀a0 a1 a2.
                 (M' = FP_Sub a0 a1 a2) ⇒ (f2 a0 a1 a2 = f2' a0 a1 a2)) ∧
            (∀a0 a1 a2.
                 (M' = FP_Mul a0 a1 a2) ⇒ (f3 a0 a1 a2 = f3' a0 a1 a2)) ∧
            (∀a0 a1 a2.
                 (M' = FP_Div a0 a1 a2) ⇒ (f4 a0 a1 a2 = f4' a0 a1 a2)) ∧
            (∀a0 a1 a2 a3.
                 (M' = FP_MulAdd a0 a1 a2 a3) ⇒
                 (f5 a0 a1 a2 a3 = f5' a0 a1 a2 a3)) ∧
            (∀a0 a1 a2 a3.
                 (M' = FP_MulSub a0 a1 a2 a3) ⇒
                 (f6 a0 a1 a2 a3 = f6' a0 a1 a2 a3)) ⇒
            (fp_op_CASE M f f1 f2 f3 f4 f5 f6 =
             fp_op_CASE M' f' f1' f2' f3' f4' f5' f6')
   
   [<a name="fp_op_case_eq-val"><b>fp_op_case_eq</b></a>]  Theorem
      
      ⊢ (fp_op_CASE x f f1 f2 f3 f4 f5 f6 = v) ⇔
        (∃r f'. (x = FP_Sqrt r f') ∧ (f r f' = v)) ∨
        (∃r f' f0. (x = FP_Add r f' f0) ∧ (f1 r f' f0 = v)) ∨
        (∃r f' f0. (x = FP_Sub r f' f0) ∧ (f2 r f' f0 = v)) ∨
        (∃r f' f0. (x = FP_Mul r f' f0) ∧ (f3 r f' f0 = v)) ∨
        (∃r f' f0. (x = FP_Div r f' f0) ∧ (f4 r f' f0 = v)) ∨
        (∃r f' f0 f1'. (x = FP_MulAdd r f' f0 f1') ∧ (f5 r f' f0 f1' = v)) ∨
        ∃r f' f0 f1'. (x = FP_MulSub r f' f0 f1') ∧ (f6 r f' f0 f1' = v)
   
   [<a name="fp_op_distinct-val"><b>fp_op_distinct</b></a>]  Theorem
      
      ⊢ (∀a2 a1' a1 a0' a0. FP_Sqrt a0 a1 ≠ FP_Add a0' a1' a2) ∧
        (∀a2 a1' a1 a0' a0. FP_Sqrt a0 a1 ≠ FP_Sub a0' a1' a2) ∧
        (∀a2 a1' a1 a0' a0. FP_Sqrt a0 a1 ≠ FP_Mul a0' a1' a2) ∧
        (∀a2 a1' a1 a0' a0. FP_Sqrt a0 a1 ≠ FP_Div a0' a1' a2) ∧
        (∀a3 a2 a1' a1 a0' a0. FP_Sqrt a0 a1 ≠ FP_MulAdd a0' a1' a2 a3) ∧
        (∀a3 a2 a1' a1 a0' a0. FP_Sqrt a0 a1 ≠ FP_MulSub a0' a1' a2 a3) ∧
        (∀a2' a2 a1' a1 a0' a0. FP_Add a0 a1 a2 ≠ FP_Sub a0' a1' a2') ∧
        (∀a2' a2 a1' a1 a0' a0. FP_Add a0 a1 a2 ≠ FP_Mul a0' a1' a2') ∧
        (∀a2' a2 a1' a1 a0' a0. FP_Add a0 a1 a2 ≠ FP_Div a0' a1' a2') ∧
        (∀a3 a2' a2 a1' a1 a0' a0.
             FP_Add a0 a1 a2 ≠ FP_MulAdd a0' a1' a2' a3) ∧
        (∀a3 a2' a2 a1' a1 a0' a0.
             FP_Add a0 a1 a2 ≠ FP_MulSub a0' a1' a2' a3) ∧
        (∀a2' a2 a1' a1 a0' a0. FP_Sub a0 a1 a2 ≠ FP_Mul a0' a1' a2') ∧
        (∀a2' a2 a1' a1 a0' a0. FP_Sub a0 a1 a2 ≠ FP_Div a0' a1' a2') ∧
        (∀a3 a2' a2 a1' a1 a0' a0.
             FP_Sub a0 a1 a2 ≠ FP_MulAdd a0' a1' a2' a3) ∧
        (∀a3 a2' a2 a1' a1 a0' a0.
             FP_Sub a0 a1 a2 ≠ FP_MulSub a0' a1' a2' a3) ∧
        (∀a2' a2 a1' a1 a0' a0. FP_Mul a0 a1 a2 ≠ FP_Div a0' a1' a2') ∧
        (∀a3 a2' a2 a1' a1 a0' a0.
             FP_Mul a0 a1 a2 ≠ FP_MulAdd a0' a1' a2' a3) ∧
        (∀a3 a2' a2 a1' a1 a0' a0.
             FP_Mul a0 a1 a2 ≠ FP_MulSub a0' a1' a2' a3) ∧
        (∀a3 a2' a2 a1' a1 a0' a0.
             FP_Div a0 a1 a2 ≠ FP_MulAdd a0' a1' a2' a3) ∧
        (∀a3 a2' a2 a1' a1 a0' a0.
             FP_Div a0 a1 a2 ≠ FP_MulSub a0' a1' a2' a3) ∧
        ∀a3' a3 a2' a2 a1' a1 a0' a0.
            FP_MulAdd a0 a1 a2 a3 ≠ FP_MulSub a0' a1' a2' a3'
   
   [<a name="fp_op_induction-val"><b>fp_op_induction</b></a>]  Theorem
      
      ⊢ ∀P.
            (∀r f. P (FP_Sqrt r f)) ∧ (∀r f f0. P (FP_Add r f f0)) ∧
            (∀r f f0. P (FP_Sub r f f0)) ∧ (∀r f f0. P (FP_Mul r f f0)) ∧
            (∀r f f0. P (FP_Div r f f0)) ∧
            (∀r f f0 f1. P (FP_MulAdd r f f0 f1)) ∧
            (∀r f f0 f1. P (FP_MulSub r f f0 f1)) ⇒
            ∀f. P f
   
   [<a name="fp_op_nchotomy-val"><b>fp_op_nchotomy</b></a>]  Theorem
      
      ⊢ ∀ff.
            (∃r f. ff = FP_Sqrt r f) ∨ (∃r f f0. ff = FP_Add r f f0) ∨
            (∃r f f0. ff = FP_Sub r f f0) ∨ (∃r f f0. ff = FP_Mul r f f0) ∨
            (∃r f f0. ff = FP_Div r f f0) ∨
            (∃r f f0 f1. ff = FP_MulAdd r f f0 f1) ∨
            ∃r f f0 f1. ff = FP_MulSub r f f0 f1
   
   [<a name="infinity_properties-val"><b>infinity_properties</b></a>]  Theorem
      
      ⊢ ¬float_is_zero (float_plus_infinity (:τ # χ)) ∧
        ¬float_is_zero (float_minus_infinity (:τ # χ)) ∧
        ¬float_is_finite (float_plus_infinity (:τ # χ)) ∧
        ¬float_is_finite (float_minus_infinity (:τ # χ)) ∧
        ¬float_is_integral (float_plus_infinity (:τ # χ)) ∧
        ¬float_is_integral (float_minus_infinity (:τ # χ)) ∧
        ¬float_is_nan (float_plus_infinity (:τ # χ)) ∧
        ¬float_is_nan (float_minus_infinity (:τ # χ)) ∧
        ¬float_is_normal (float_plus_infinity (:τ # χ)) ∧
        ¬float_is_normal (float_minus_infinity (:τ # χ)) ∧
        ¬float_is_subnormal (float_plus_infinity (:τ # χ)) ∧
        ¬float_is_subnormal (float_minus_infinity (:τ # χ)) ∧
        float_is_infinite (float_plus_infinity (:τ # χ)) ∧
        float_is_infinite (float_minus_infinity (:τ # χ))
   
   [<a name="largest-val"><b>largest</b></a>]  Theorem
      
      ⊢ largest (:τ # χ) =
        &(2 ** (UINT_MAX (:χ) − 1)) * (2 − 1 / &dimword (:τ)) /
        &(2 ** bias (:χ))
   
   [<a name="largest_is_positive-val"><b>largest_is_positive</b></a>]  Theorem
      
      ⊢ 0 ≤ largest (:τ # χ)
   
   [<a name="largest_is_top-val"><b>largest_is_top</b></a>]  Theorem
      
      ⊢ 1 &lt; precision (:χ) ⇒
        (largest (:τ # χ) = float_to_real (float_top (:τ # χ)))
   
   [<a name="largest_lt_threshold-val"><b>largest_lt_threshold</b></a>]  Theorem
      
      ⊢ largest (:τ # χ) &lt; threshold (:τ # χ)
   
   [<a name="le2-val"><b>le2</b></a>]  Theorem
      
      ⊢ ∀n m. 2 ≤ n ∧ 2 ≤ m ⇒ 2 ≤ n * m
   
   [<a name="less_than_ulp-val"><b>less_than_ulp</b></a>]  Theorem
      
      ⊢ ∀a.
            abs (float_to_real a) &lt; ulp (:τ # χ) ⇔
            (a.Exponent = 0w) ∧ (a.Significand = 0w)
   
   [<a name="min_properties-val"><b>min_properties</b></a>]  Theorem
      
      ⊢ ¬float_is_zero (float_plus_min (:τ # χ)) ∧
        float_is_finite (float_plus_min (:τ # χ)) ∧
        (float_is_integral (float_plus_min (:τ # χ)) ⇔
         (precision (:χ) = 1) ∧ (precision (:τ) = 1)) ∧
        ¬float_is_nan (float_plus_min (:τ # χ)) ∧
        ¬float_is_normal (float_plus_min (:τ # χ)) ∧
        float_is_subnormal (float_plus_min (:τ # χ)) ∧
        ¬float_is_infinite (float_plus_min (:τ # χ)) ∧
        ¬float_is_zero (float_minus_min (:τ # χ)) ∧
        float_is_finite (float_minus_min (:τ # χ)) ∧
        (float_is_integral (float_minus_min (:τ # χ)) ⇔
         (precision (:χ) = 1) ∧ (precision (:τ) = 1)) ∧
        ¬float_is_nan (float_minus_min (:τ # χ)) ∧
        ¬float_is_normal (float_minus_min (:τ # χ)) ∧
        float_is_subnormal (float_minus_min (:τ # χ)) ∧
        ¬float_is_infinite (float_minus_min (:τ # χ))
   
   [<a name="neg_ulp-val"><b>neg_ulp</b></a>]  Theorem
      
      ⊢ -ulp (:τ # χ) =
        float_to_real (float_negate (float_plus_min (:τ # χ)))
   
   [<a name="num2float_compare_11-val"><b>num2float_compare_11</b></a>]  Theorem
      
      ⊢ ∀r r'.
            r &lt; 4 ⇒
            r' &lt; 4 ⇒
            ((num2float_compare r = num2float_compare r') ⇔ (r = r'))
   
   [<a name="num2float_compare_ONTO-val"><b>num2float_compare_ONTO</b></a>]  Theorem
      
      ⊢ ∀a. ∃r. (a = num2float_compare r) ∧ r &lt; 4
   
   [<a name="num2float_compare_float_compare2num-val"><b>num2float_compare_float_compare2num</b></a>]  Theorem
      
      ⊢ ∀a. num2float_compare (float_compare2num a) = a
   
   [<a name="num2float_compare_thm-val"><b>num2float_compare_thm</b></a>]  Theorem
      
      ⊢ (num2float_compare 0 = LT) ∧ (num2float_compare 1 = EQ) ∧
        (num2float_compare 2 = GT) ∧ (num2float_compare 3 = UN)
   
   [<a name="num2rounding_11-val"><b>num2rounding_11</b></a>]  Theorem
      
      ⊢ ∀r r'.
            r &lt; 4 ⇒
            r' &lt; 4 ⇒
            ((num2rounding r = num2rounding r') ⇔ (r = r'))
   
   [<a name="num2rounding_ONTO-val"><b>num2rounding_ONTO</b></a>]  Theorem
      
      ⊢ ∀a. ∃r. (a = num2rounding r) ∧ r &lt; 4
   
   [<a name="num2rounding_rounding2num-val"><b>num2rounding_rounding2num</b></a>]  Theorem
      
      ⊢ ∀a. num2rounding (rounding2num a) = a
   
   [<a name="num2rounding_thm-val"><b>num2rounding_thm</b></a>]  Theorem
      
      ⊢ (num2rounding 0 = roundTiesToEven) ∧
        (num2rounding 1 = roundTowardPositive) ∧
        (num2rounding 2 = roundTowardNegative) ∧
        (num2rounding 3 = roundTowardZero)
   
   [<a name="round_roundTiesToEven-val"><b>round_roundTiesToEven</b></a>]  Theorem
      
      ⊢ ∀y x r.
            (float_value y = Float r) ∧
            ((y.Significand = 0w) ∧ y.Exponent ≠ 1w ⇒ abs r ≤ abs x) ∧
            2 * abs (r − x) ≤ ULP (y.Exponent,(:τ)) ∧
            ((2 * abs (r − x) = ULP (y.Exponent,(:τ))) ⇒
             ¬word_lsb y.Significand) ∧ ulp (:τ # χ) &lt; 2 * abs x ∧
            abs x &lt; threshold (:τ # χ) ⇒
            (round roundTiesToEven x = y)
   
   [<a name="round_roundTiesToEven0-val"><b>round_roundTiesToEven0</b></a>]  Theorem
      
      ⊢ ∀y x r.
            (float_value y = Float r) ∧
            ((y.Significand = 0w) ∧ y.Exponent ≠ 1w ∧ ¬(abs r ≤ abs x)) ∧
            4 * abs (r − x) ≤ ULP (y.Exponent,(:τ)) ∧
            ulp (:τ # χ) &lt; 2 * abs x ∧ abs x &lt; threshold (:τ # χ) ⇒
            (round roundTiesToEven x = y)
   
   [<a name="round_roundTiesToEven_is_minus_zero-val"><b>round_roundTiesToEven_is_minus_zero</b></a>]  Theorem
      
      ⊢ ∀x.
            2 * abs x ≤ ulp (:τ # χ) ⇒
            (float_round roundTiesToEven T x = float_minus_zero (:τ # χ))
   
   [<a name="round_roundTiesToEven_is_plus_zero-val"><b>round_roundTiesToEven_is_plus_zero</b></a>]  Theorem
      
      ⊢ ∀x.
            2 * abs x ≤ ulp (:τ # χ) ⇒
            (float_round roundTiesToEven F x = float_plus_zero (:τ # χ))
   
   [<a name="round_roundTiesToEven_is_zero-val"><b>round_roundTiesToEven_is_zero</b></a>]  Theorem
      
      ⊢ ∀x.
            2 * abs x ≤ ulp (:τ # χ) ⇒
            (round roundTiesToEven x = float_plus_zero (:τ # χ)) ∨
            (round roundTiesToEven x = float_minus_zero (:τ # χ))
   
   [<a name="round_roundTiesToEven_minus_infinity-val"><b>round_roundTiesToEven_minus_infinity</b></a>]  Theorem
      
      ⊢ ∀y x.
            x ≤ -threshold (:τ # χ) ⇒
            (round roundTiesToEven x = float_minus_infinity (:τ # χ))
   
   [<a name="round_roundTiesToEven_plus_infinity-val"><b>round_roundTiesToEven_plus_infinity</b></a>]  Theorem
      
      ⊢ ∀y x.
            threshold (:τ # χ) ≤ x ⇒
            (round roundTiesToEven x = float_plus_infinity (:τ # χ))
   
   [<a name="round_roundTowardNegative_minus_infinity-val"><b>round_roundTowardNegative_minus_infinity</b></a>]  Theorem
      
      ⊢ ∀y x.
            x &lt; -largest (:τ # χ) ⇒
            (round roundTowardNegative x = float_minus_infinity (:τ # χ))
   
   [<a name="round_roundTowardNegative_top-val"><b>round_roundTowardNegative_top</b></a>]  Theorem
      
      ⊢ ∀y x.
            largest (:τ # χ) &lt; x ⇒
            (round roundTowardNegative x = float_top (:τ # χ))
   
   [<a name="round_roundTowardPositive_bottom-val"><b>round_roundTowardPositive_bottom</b></a>]  Theorem
      
      ⊢ ∀y x.
            x &lt; -largest (:τ # χ) ⇒
            (round roundTowardPositive x = float_bottom (:τ # χ))
   
   [<a name="round_roundTowardPositive_plus_infinity-val"><b>round_roundTowardPositive_plus_infinity</b></a>]  Theorem
      
      ⊢ ∀y x.
            largest (:τ # χ) &lt; x ⇒
            (round roundTowardPositive x = float_plus_infinity (:τ # χ))
   
   [<a name="round_roundTowardZero-val"><b>round_roundTowardZero</b></a>]  Theorem
      
      ⊢ ∀y x r.
            (float_value y = Float r) ∧
            abs (r − x) &lt; ULP (y.Exponent,(:τ)) ∧ abs r ≤ abs x ∧
            ulp (:τ # χ) ≤ abs x ∧ abs x ≤ largest (:τ # χ) ⇒
            (round roundTowardZero x = y)
   
   [<a name="round_roundTowardZero_bottom-val"><b>round_roundTowardZero_bottom</b></a>]  Theorem
      
      ⊢ ∀y x.
            x &lt; -largest (:τ # χ) ⇒
            (round roundTowardZero x = float_bottom (:τ # χ))
   
   [<a name="round_roundTowardZero_is_minus_zero-val"><b>round_roundTowardZero_is_minus_zero</b></a>]  Theorem
      
      ⊢ ∀x.
            abs x &lt; ulp (:τ # χ) ⇒
            (float_round roundTowardZero T x = float_minus_zero (:τ # χ))
   
   [<a name="round_roundTowardZero_is_plus_zero-val"><b>round_roundTowardZero_is_plus_zero</b></a>]  Theorem
      
      ⊢ ∀x.
            abs x &lt; ulp (:τ # χ) ⇒
            (float_round roundTowardZero F x = float_plus_zero (:τ # χ))
   
   [<a name="round_roundTowardZero_is_zero-val"><b>round_roundTowardZero_is_zero</b></a>]  Theorem
      
      ⊢ ∀x.
            abs x &lt; ulp (:τ # χ) ⇒
            (round roundTowardZero x = float_plus_zero (:τ # χ)) ∨
            (round roundTowardZero x = float_minus_zero (:τ # χ))
   
   [<a name="round_roundTowardZero_top-val"><b>round_roundTowardZero_top</b></a>]  Theorem
      
      ⊢ ∀y x.
            largest (:τ # χ) &lt; x ⇒
            (round roundTowardZero x = float_top (:τ # χ))
   
   [<a name="rounding2num_11-val"><b>rounding2num_11</b></a>]  Theorem
      
      ⊢ ∀a a'. (rounding2num a = rounding2num a') ⇔ (a = a')
   
   [<a name="rounding2num_ONTO-val"><b>rounding2num_ONTO</b></a>]  Theorem
      
      ⊢ ∀r. r &lt; 4 ⇔ ∃a. r = rounding2num a
   
   [<a name="rounding2num_num2rounding-val"><b>rounding2num_num2rounding</b></a>]  Theorem
      
      ⊢ ∀r. r &lt; 4 ⇔ (rounding2num (num2rounding r) = r)
   
   [<a name="rounding2num_thm-val"><b>rounding2num_thm</b></a>]  Theorem
      
      ⊢ (rounding2num roundTiesToEven = 0) ∧
        (rounding2num roundTowardPositive = 1) ∧
        (rounding2num roundTowardNegative = 2) ∧
        (rounding2num roundTowardZero = 3)
   
   [<a name="rounding_Axiom-val"><b>rounding_Axiom</b></a>]  Theorem
      
      ⊢ ∀x0 x1 x2 x3.
            ∃f.
                (f roundTiesToEven = x0) ∧ (f roundTowardPositive = x1) ∧
                (f roundTowardNegative = x2) ∧ (f roundTowardZero = x3)
   
   [<a name="rounding_EQ_rounding-val"><b>rounding_EQ_rounding</b></a>]  Theorem
      
      ⊢ ∀a a'. (a = a') ⇔ (rounding2num a = rounding2num a')
   
   [<a name="rounding_case_cong-val"><b>rounding_case_cong</b></a>]  Theorem
      
      ⊢ ∀M M' v0 v1 v2 v3.
            (M = M') ∧ ((M' = roundTiesToEven) ⇒ (v0 = v0')) ∧
            ((M' = roundTowardPositive) ⇒ (v1 = v1')) ∧
            ((M' = roundTowardNegative) ⇒ (v2 = v2')) ∧
            ((M' = roundTowardZero) ⇒ (v3 = v3')) ⇒
            ((case M of
                roundTiesToEven =&gt; v0
              | roundTowardPositive =&gt; v1
              | roundTowardNegative =&gt; v2
              | roundTowardZero =&gt; v3) =
             case M' of
               roundTiesToEven =&gt; v0'
             | roundTowardPositive =&gt; v1'
             | roundTowardNegative =&gt; v2'
             | roundTowardZero =&gt; v3')
   
   [<a name="rounding_case_def-val"><b>rounding_case_def</b></a>]  Theorem
      
      ⊢ (∀v0 v1 v2 v3.
             (case roundTiesToEven of
                roundTiesToEven =&gt; v0
              | roundTowardPositive =&gt; v1
              | roundTowardNegative =&gt; v2
              | roundTowardZero =&gt; v3) =
             v0) ∧
        (∀v0 v1 v2 v3.
             (case roundTowardPositive of
                roundTiesToEven =&gt; v0
              | roundTowardPositive =&gt; v1
              | roundTowardNegative =&gt; v2
              | roundTowardZero =&gt; v3) =
             v1) ∧
        (∀v0 v1 v2 v3.
             (case roundTowardNegative of
                roundTiesToEven =&gt; v0
              | roundTowardPositive =&gt; v1
              | roundTowardNegative =&gt; v2
              | roundTowardZero =&gt; v3) =
             v2) ∧
        ∀v0 v1 v2 v3.
            (case roundTowardZero of
               roundTiesToEven =&gt; v0
             | roundTowardPositive =&gt; v1
             | roundTowardNegative =&gt; v2
             | roundTowardZero =&gt; v3) =
            v3
   
   [<a name="rounding_case_eq-val"><b>rounding_case_eq</b></a>]  Theorem
      
      ⊢ ((case x of
            roundTiesToEven =&gt; v0
          | roundTowardPositive =&gt; v1
          | roundTowardNegative =&gt; v2
          | roundTowardZero =&gt; v3) = v) ⇔
        (x = roundTiesToEven) ∧ (v0 = v) ∨
        (x = roundTowardPositive) ∧ (v1 = v) ∨
        (x = roundTowardNegative) ∧ (v2 = v) ∨
        (x = roundTowardZero) ∧ (v3 = v)
   
   [<a name="rounding_distinct-val"><b>rounding_distinct</b></a>]  Theorem
      
      ⊢ roundTiesToEven ≠ roundTowardPositive ∧
        roundTiesToEven ≠ roundTowardNegative ∧
        roundTiesToEven ≠ roundTowardZero ∧
        roundTowardPositive ≠ roundTowardNegative ∧
        roundTowardPositive ≠ roundTowardZero ∧
        roundTowardNegative ≠ roundTowardZero
   
   [<a name="rounding_induction-val"><b>rounding_induction</b></a>]  Theorem
      
      ⊢ ∀P.
            P roundTiesToEven ∧ P roundTowardNegative ∧
            P roundTowardPositive ∧ P roundTowardZero ⇒
            ∀a. P a
   
   [<a name="rounding_nchotomy-val"><b>rounding_nchotomy</b></a>]  Theorem
      
      ⊢ ∀a.
            (a = roundTiesToEven) ∨ (a = roundTowardPositive) ∨
            (a = roundTowardNegative) ∨ (a = roundTowardZero)
   
   [<a name="sign_not_zero-val"><b>sign_not_zero</b></a>]  Theorem
      
      ⊢ ∀s. -1 pow w2n s ≠ 0
   
   [<a name="some_nan_properties-val"><b>some_nan_properties</b></a>]  Theorem
      
      ⊢ ∀fp_op.
            ¬float_is_zero (float_some_qnan fp_op) ∧
            ¬float_is_finite (float_some_qnan fp_op) ∧
            ¬float_is_integral (float_some_qnan fp_op) ∧
            float_is_nan (float_some_qnan fp_op) ∧
            ¬float_is_signalling (float_some_qnan fp_op) ∧
            ¬float_is_normal (float_some_qnan fp_op) ∧
            ¬float_is_subnormal (float_some_qnan fp_op) ∧
            ¬float_is_infinite (float_some_qnan fp_op)
   
   [<a name="threshold-val"><b>threshold</b></a>]  Theorem
      
      ⊢ threshold (:τ # χ) =
        &(2 ** (UINT_MAX (:χ) − 1)) * (2 − 1 / &(2 * dimword (:τ))) /
        &(2 ** bias (:χ))
   
   [<a name="threshold_is_positive-val"><b>threshold_is_positive</b></a>]  Theorem
      
      ⊢ 0 &lt; threshold (:τ # χ)
   
   [<a name="top_properties-val"><b>top_properties</b></a>]  Theorem
      
      ⊢ ¬float_is_zero (float_top (:τ # χ)) ∧
        float_is_finite (float_top (:τ # χ)) ∧
        ¬float_is_nan (float_top (:τ # χ)) ∧
        (float_is_normal (float_top (:τ # χ)) ⇔ precision (:χ) ≠ 1) ∧
        (float_is_subnormal (float_top (:τ # χ)) ⇔ (precision (:χ) = 1)) ∧
        ¬float_is_infinite (float_top (:τ # χ))
   
   [<a name="ulp-val"><b>ulp</b></a>]  Theorem
      
      ⊢ ulp (:τ # χ) = float_to_real (float_plus_min (:τ # χ))
   
   [<a name="ulp_lt_ULP-val"><b>ulp_lt_ULP</b></a>]  Theorem
      
      ⊢ ∀e. ulp (:τ # χ) ≤ ULP (e,(:τ))
   
   [<a name="ulp_lt_largest-val"><b>ulp_lt_largest</b></a>]  Theorem
      
      ⊢ ulp (:τ # χ) &lt; largest (:τ # χ)
   
   [<a name="ulp_lt_threshold-val"><b>ulp_lt_threshold</b></a>]  Theorem
      
      ⊢ ulp (:τ # χ) &lt; threshold (:τ # χ)
   
   [<a name="zero_le_pos_div_twopow-val"><b>zero_le_pos_div_twopow</b></a>]  Theorem
      
      ⊢ ∀m n. 0 ≤ &m / 2 pow n
   
   [<a name="zero_le_twopow-val"><b>zero_le_twopow</b></a>]  Theorem
      
      ⊢ ∀n. 0 ≤ 2 pow n
   
   [<a name="zero_lt_twopow-val"><b>zero_lt_twopow</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; 2 pow n
   
   [<a name="zero_neq_twopow-val"><b>zero_neq_twopow</b></a>]  Theorem
      
      ⊢ ∀n. 2 pow n ≠ 0
   
   [<a name="zero_properties-val"><b>zero_properties</b></a>]  Theorem
      
      ⊢ float_is_zero (float_plus_zero (:τ # χ)) ∧
        float_is_zero (float_minus_zero (:τ # χ)) ∧
        float_is_finite (float_plus_zero (:τ # χ)) ∧
        float_is_finite (float_minus_zero (:τ # χ)) ∧
        float_is_integral (float_plus_zero (:τ # χ)) ∧
        float_is_integral (float_minus_zero (:τ # χ)) ∧
        ¬float_is_nan (float_plus_zero (:τ # χ)) ∧
        ¬float_is_nan (float_minus_zero (:τ # χ)) ∧
        ¬float_is_normal (float_plus_zero (:τ # χ)) ∧
        ¬float_is_normal (float_minus_zero (:τ # χ)) ∧
        ¬float_is_subnormal (float_plus_zero (:τ # χ)) ∧
        ¬float_is_subnormal (float_minus_zero (:τ # χ)) ∧
        ¬float_is_infinite (float_plus_zero (:τ # χ)) ∧
        ¬float_is_infinite (float_minus_zero (:τ # χ))
   
   [<a name="zero_to_real-val"><b>zero_to_real</b></a>]  Theorem
      
      ⊢ (float_to_real (float_plus_zero (:τ # χ)) = 0) ∧
        (float_to_real (float_minus_zero (:τ # χ)) = 0)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/floating-point/binary_ieeeScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-11</a></em></p></body></html>
