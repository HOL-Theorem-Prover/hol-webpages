<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure comparisonTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure comparisonTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/enumfset/comparisonScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature comparisonTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#equiv_inj_def-val">equiv_inj_def</a> : thm
<a name="line7"></a>    val <a href="#good_cmp_def-val">good_cmp_def</a> : thm
<a name="line8"></a>    val <a href="#resp_equiv2_def-val">resp_equiv2_def</a> : thm
<a name="line9"></a>    val <a href="#resp_equiv_def-val">resp_equiv_def</a> : thm
<a name="line10"></a>  
<a name="line11"></a>  (*  Theorems  *)
<a name="line12"></a>    val <a href="#TO_inv_invert-val">TO_inv_invert</a> : thm
<a name="line13"></a>    val <a href="#TO_of_LinearOrder_LLEX-val">TO_of_LinearOrder_LLEX</a> : thm
<a name="line14"></a>    val <a href="#TotOrd_list_cmp-val">TotOrd_list_cmp</a> : thm
<a name="line15"></a>    val <a href="#TotOrder_imp_good_cmp-val">TotOrder_imp_good_cmp</a> : thm
<a name="line16"></a>    val <a href="#antisym_resp_equiv-val">antisym_resp_equiv</a> : thm
<a name="line17"></a>    val <a href="#bool_cmp_antisym-val">bool_cmp_antisym</a> : thm
<a name="line18"></a>    val <a href="#bool_cmp_def-val">bool_cmp_def</a> : thm
<a name="line19"></a>    val <a href="#bool_cmp_good-val">bool_cmp_good</a> : thm
<a name="line20"></a>    val <a href="#char_cmp_antisym-val">char_cmp_antisym</a> : thm
<a name="line21"></a>    val <a href="#char_cmp_charOrd-val">char_cmp_charOrd</a> : thm
<a name="line22"></a>    val <a href="#char_cmp_def-val">char_cmp_def</a> : thm
<a name="line23"></a>    val <a href="#char_cmp_good-val">char_cmp_good</a> : thm
<a name="line24"></a>    val <a href="#cmp_thms-val">cmp_thms</a> : thm
<a name="line25"></a>    val <a href="#good_cmp_thm-val">good_cmp_thm</a> : thm
<a name="line26"></a>    val <a href="#good_cmp_trans-val">good_cmp_trans</a> : thm
<a name="line27"></a>    val <a href="#list_cmp_ListOrd-val">list_cmp_ListOrd</a> : thm
<a name="line28"></a>    val <a href="#list_cmp_antisym-val">list_cmp_antisym</a> : thm
<a name="line29"></a>    val <a href="#list_cmp_cong-val">list_cmp_cong</a> : thm
<a name="line30"></a>    val <a href="#list_cmp_equal_list_rel-val">list_cmp_equal_list_rel</a> : thm
<a name="line31"></a>    val <a href="#list_cmp_good-val">list_cmp_good</a> : thm
<a name="line32"></a>    val <a href="#num_cmp_antisym-val">num_cmp_antisym</a> : thm
<a name="line33"></a>    val <a href="#num_cmp_def-val">num_cmp_def</a> : thm
<a name="line34"></a>    val <a href="#num_cmp_good-val">num_cmp_good</a> : thm
<a name="line35"></a>    val <a href="#num_cmp_numOrd-val">num_cmp_numOrd</a> : thm
<a name="line36"></a>    val <a href="#option_cmp2_TO_inv-val">option_cmp2_TO_inv</a> : thm
<a name="line37"></a>    val <a href="#option_cmp2_antisym-val">option_cmp2_antisym</a> : thm
<a name="line38"></a>    val <a href="#option_cmp2_cong-val">option_cmp2_cong</a> : thm
<a name="line39"></a>    val <a href="#option_cmp2_def-val">option_cmp2_def</a> : thm
<a name="line40"></a>    val <a href="#option_cmp2_good-val">option_cmp2_good</a> : thm
<a name="line41"></a>    val <a href="#option_cmp2_ind-val">option_cmp2_ind</a> : thm
<a name="line42"></a>    val <a href="#option_cmp_antisym-val">option_cmp_antisym</a> : thm
<a name="line43"></a>    val <a href="#option_cmp_cong-val">option_cmp_cong</a> : thm
<a name="line44"></a>    val <a href="#option_cmp_def-val">option_cmp_def</a> : thm
<a name="line45"></a>    val <a href="#option_cmp_good-val">option_cmp_good</a> : thm
<a name="line46"></a>    val <a href="#pair_cmp_antisym-val">pair_cmp_antisym</a> : thm
<a name="line47"></a>    val <a href="#pair_cmp_cong-val">pair_cmp_cong</a> : thm
<a name="line48"></a>    val <a href="#pair_cmp_def-val">pair_cmp_def</a> : thm
<a name="line49"></a>    val <a href="#pair_cmp_good-val">pair_cmp_good</a> : thm
<a name="line50"></a>    val <a href="#pair_cmp_lexTO-val">pair_cmp_lexTO</a> : thm
<a name="line51"></a>    val <a href="#string_cmp_antisym-val">string_cmp_antisym</a> : thm
<a name="line52"></a>    val <a href="#string_cmp_def-val">string_cmp_def</a> : thm
<a name="line53"></a>    val <a href="#string_cmp_good-val">string_cmp_good</a> : thm
<a name="line54"></a>    val <a href="#string_cmp_stringto-val">string_cmp_stringto</a> : thm
<a name="line55"></a>  
<a name="line56"></a>  val comparison_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line57"></a>(*
   [toto] Parent theory of "comparison"
   
   [<a name="equiv_inj_def-val"><b>equiv_inj_def</b></a>]  Definition
      
      ⊢ ∀cmp cmp2 f.
            equiv_inj cmp cmp2 f ⇔
            ∀k1 k2. cmp2 (f k1) (f k2) = Equal ⇒ cmp k1 k2 = Equal
   
   [<a name="good_cmp_def-val"><b>good_cmp_def</b></a>]  Definition
      
      ⊢ ∀cmp.
            good_cmp cmp ⇔
            (∀x. cmp x x = Equal) ∧
            (∀x y. cmp x y = Equal ⇒ cmp y x = Equal) ∧
            (∀x y. cmp x y = Greater ⇔ cmp y x = Less) ∧
            (∀x y z. cmp x y = Equal ∧ cmp y z = Less ⇒ cmp x z = Less) ∧
            (∀x y z. cmp x y = Less ∧ cmp y z = Equal ⇒ cmp x z = Less) ∧
            (∀x y z. cmp x y = Equal ∧ cmp y z = Equal ⇒ cmp x z = Equal) ∧
            ∀x y z. cmp x y = Less ∧ cmp y z = Less ⇒ cmp x z = Less
   
   [<a name="resp_equiv2_def-val"><b>resp_equiv2_def</b></a>]  Definition
      
      ⊢ ∀cmp cmp2 f.
            resp_equiv2 cmp cmp2 f ⇔
            ∀k1 k2. cmp k1 k2 = Equal ⇒ cmp2 (f k1) (f k2) = Equal
   
   [<a name="resp_equiv_def-val"><b>resp_equiv_def</b></a>]  Definition
      
      ⊢ ∀cmp f.
            resp_equiv cmp f ⇔
            ∀k1 k2 v. cmp k1 k2 = Equal ⇒ f k1 v = f k2 v
   
   [<a name="TO_inv_invert-val"><b>TO_inv_invert</b></a>]  Theorem
      
      ⊢ ∀c. TotOrd c ⇒ TO_inv c = CURRY (invert ∘ UNCURRY c)
   
   [<a name="TO_of_LinearOrder_LLEX-val"><b>TO_of_LinearOrder_LLEX</b></a>]  Theorem
      
      ⊢ ∀R.
            irreflexive R ⇒
            TO_of_LinearOrder (LLEX R) = list_cmp (TO_of_LinearOrder R)
   
   [<a name="TotOrd_list_cmp-val"><b>TotOrd_list_cmp</b></a>]  Theorem
      
      ⊢ ∀c. TotOrd c ⇒ TotOrd (list_cmp c)
   
   [<a name="TotOrder_imp_good_cmp-val"><b>TotOrder_imp_good_cmp</b></a>]  Theorem
      
      ⊢ ∀cmp. TotOrd cmp ⇒ good_cmp cmp
   
   [<a name="antisym_resp_equiv-val"><b>antisym_resp_equiv</b></a>]  Theorem
      
      ⊢ ∀cmp f.
            (∀x y. cmp x y = Equal ⇒ x = y) ⇒
            resp_equiv cmp f ∧
            ∀cmp2. good_cmp cmp2 ⇒ resp_equiv2 cmp cmp2 f
   
   [<a name="bool_cmp_antisym-val"><b>bool_cmp_antisym</b></a>]  Theorem
      
      ⊢ ∀x y. bool_cmp x y = Equal ⇔ (x ⇔ y)
   
   [<a name="bool_cmp_def-val"><b>bool_cmp_def</b></a>]  Theorem
      
      ⊢ bool_cmp T T = Equal ∧ bool_cmp F F = Equal ∧
        bool_cmp T F = Greater ∧ bool_cmp F T = Less
   
   [<a name="bool_cmp_good-val"><b>bool_cmp_good</b></a>]  Theorem
      
      ⊢ good_cmp bool_cmp
   
   [<a name="char_cmp_antisym-val"><b>char_cmp_antisym</b></a>]  Theorem
      
      ⊢ ∀x y. char_cmp x y = Equal ⇔ x = y
   
   [<a name="char_cmp_charOrd-val"><b>char_cmp_charOrd</b></a>]  Theorem
      
      ⊢ char_cmp = charOrd
   
   [<a name="char_cmp_def-val"><b>char_cmp_def</b></a>]  Theorem
      
      ⊢ ∀c1 c2. char_cmp c1 c2 = num_cmp (ORD c1) (ORD c2)
   
   [<a name="char_cmp_good-val"><b>char_cmp_good</b></a>]  Theorem
      
      ⊢ good_cmp char_cmp
   
   [<a name="cmp_thms-val"><b>cmp_thms</b></a>]  Theorem
      
      ⊢ (Less ≠ Equal ∧ Less ≠ Greater ∧ Equal ≠ Greater) ∧
        ((∀v0 v1 v2.
              (case Less of Less =&gt; v0 | Equal =&gt; v1 | Greater =&gt; v2) = v0) ∧
         (∀v0 v1 v2.
              (case Equal of Less =&gt; v0 | Equal =&gt; v1 | Greater =&gt; v2) = v1) ∧
         ∀v0 v1 v2.
             (case Greater of Less =&gt; v0 | Equal =&gt; v1 | Greater =&gt; v2) =
             v2) ∧ (∀a. a = Less ∨ a = Equal ∨ a = Greater) ∧
        ∀cmp.
            good_cmp cmp ⇔
            (∀x. cmp x x = Equal) ∧
            (∀x y. cmp x y = Equal ⇒ cmp y x = Equal) ∧
            (∀x y. cmp x y = Greater ⇔ cmp y x = Less) ∧
            (∀x y z. cmp x y = Equal ∧ cmp y z = Less ⇒ cmp x z = Less) ∧
            (∀x y z. cmp x y = Less ∧ cmp y z = Equal ⇒ cmp x z = Less) ∧
            (∀x y z. cmp x y = Equal ∧ cmp y z = Equal ⇒ cmp x z = Equal) ∧
            ∀x y z. cmp x y = Less ∧ cmp y z = Less ⇒ cmp x z = Less
   
   [<a name="good_cmp_thm-val"><b>good_cmp_thm</b></a>]  Theorem
      
      ⊢ ∀cmp.
            good_cmp cmp ⇔
            (∀x. cmp x x = Equal) ∧
            ∀x y z.
                (cmp x y = Greater ⇔ cmp y x = Less) ∧
                (cmp x y = Less ∧ cmp y z = Equal ⇒ cmp x z = Less) ∧
                (cmp x y = Less ∧ cmp y z = Less ⇒ cmp x z = Less)
   
   [<a name="good_cmp_trans-val"><b>good_cmp_trans</b></a>]  Theorem
      
      ⊢ ∀cmp. good_cmp cmp ⇒ transitive (λ(k,v) (k',v'). cmp k k' = Less)
   
   [<a name="list_cmp_ListOrd-val"><b>list_cmp_ListOrd</b></a>]  Theorem
      
      ⊢ ∀c. TotOrd c ⇒ list_cmp c = ListOrd (TO c)
   
   [<a name="list_cmp_antisym-val"><b>list_cmp_antisym</b></a>]  Theorem
      
      ⊢ ∀cmp x y.
            (∀x y. cmp x y = Equal ⇔ x = y) ⇒
            (list_cmp cmp x y = Equal ⇔ x = y)
   
   [<a name="list_cmp_cong-val"><b>list_cmp_cong</b></a>]  Theorem
      
      ⊢ ∀cmp l1 l2 cmp' l1' l2'.
            l1 = l1' ∧ l2 = l2' ∧
            (∀x x'. MEM x l1' ∧ MEM x' l2' ⇒ cmp x x' = cmp' x x') ⇒
            list_cmp cmp l1 l2 = list_cmp cmp' l1' l2'
   
   [<a name="list_cmp_equal_list_rel-val"><b>list_cmp_equal_list_rel</b></a>]  Theorem
      
      ⊢ ∀cmp l1 l2.
            list_cmp cmp l1 l2 = Equal ⇔
            LIST_REL (λx y. cmp x y = Equal) l1 l2
   
   [<a name="list_cmp_good-val"><b>list_cmp_good</b></a>]  Theorem
      
      ⊢ ∀cmp. good_cmp cmp ⇒ good_cmp (list_cmp cmp)
   
   [<a name="num_cmp_antisym-val"><b>num_cmp_antisym</b></a>]  Theorem
      
      ⊢ ∀x y. num_cmp x y = Equal ⇔ x = y
   
   [<a name="num_cmp_def-val"><b>num_cmp_def</b></a>]  Theorem
      
      ⊢ ∀n1 n2.
            num_cmp n1 n2 = if n1 = n2 then Equal else if n1 &lt; n2 then Less
            else Greater
   
   [<a name="num_cmp_good-val"><b>num_cmp_good</b></a>]  Theorem
      
      ⊢ good_cmp num_cmp
   
   [<a name="num_cmp_numOrd-val"><b>num_cmp_numOrd</b></a>]  Theorem
      
      ⊢ num_cmp = numOrd
   
   [<a name="option_cmp2_TO_inv-val"><b>option_cmp2_TO_inv</b></a>]  Theorem
      
      ⊢ ∀c. option_cmp2 c = TO_inv (option_cmp (TO_inv c))
   
   [<a name="option_cmp2_antisym-val"><b>option_cmp2_antisym</b></a>]  Theorem
      
      ⊢ ∀cmp x y.
            (∀x y. cmp x y = Equal ⇔ x = y) ⇒
            (option_cmp2 cmp x y = Equal ⇔ x = y)
   
   [<a name="option_cmp2_cong-val"><b>option_cmp2_cong</b></a>]  Theorem
      
      ⊢ ∀cmp v1 v2 cmp' v1' v2'.
            v1 = v1' ∧ v2 = v2' ∧
            (∀x x'. v1' = SOME x ∧ v2' = SOME x' ⇒ cmp x x' = cmp' x x') ⇒
            option_cmp2 cmp v1 v2 = option_cmp2 cmp' v1' v2'
   
   [<a name="option_cmp2_def-val"><b>option_cmp2_def</b></a>]  Theorem
      
      ⊢ option_cmp2 cmp NONE NONE = Equal ∧
        option_cmp2 cmp NONE (SOME x') = Greater ∧
        option_cmp2 cmp (SOME x) NONE = Less ∧
        option_cmp2 cmp (SOME x) (SOME y) = cmp x y
   
   [<a name="option_cmp2_good-val"><b>option_cmp2_good</b></a>]  Theorem
      
      ⊢ ∀cmp. good_cmp cmp ⇒ good_cmp (option_cmp2 cmp)
   
   [<a name="option_cmp2_ind-val"><b>option_cmp2_ind</b></a>]  Theorem
      
      ⊢ ∀P.
            (∀cmp. P cmp NONE NONE) ∧ (∀cmp x. P cmp NONE (SOME x)) ∧
            (∀cmp x. P cmp (SOME x) NONE) ∧
            (∀cmp x y. P cmp (SOME x) (SOME y)) ⇒
            ∀v v1 v2. P v v1 v2
   
   [<a name="option_cmp_antisym-val"><b>option_cmp_antisym</b></a>]  Theorem
      
      ⊢ ∀cmp x y.
            (∀x y. cmp x y = Equal ⇔ x = y) ⇒
            (option_cmp cmp x y = Equal ⇔ x = y)
   
   [<a name="option_cmp_cong-val"><b>option_cmp_cong</b></a>]  Theorem
      
      ⊢ ∀cmp v1 v2 cmp' v1' v2'.
            v1 = v1' ∧ v2 = v2' ∧
            (∀x x'. v1' = SOME x ∧ v2' = SOME x' ⇒ cmp x x' = cmp' x x') ⇒
            option_cmp cmp v1 v2 = option_cmp cmp' v1' v2'
   
   [<a name="option_cmp_def-val"><b>option_cmp_def</b></a>]  Theorem
      
      ⊢ option_cmp c NONE NONE = Equal ∧
        option_cmp c NONE (SOME v0) = Less ∧
        option_cmp c (SOME v3) NONE = Greater ∧
        option_cmp c (SOME v1) (SOME v2) = c v1 v2
   
   [<a name="option_cmp_good-val"><b>option_cmp_good</b></a>]  Theorem
      
      ⊢ ∀cmp. good_cmp cmp ⇒ good_cmp (option_cmp cmp)
   
   [<a name="pair_cmp_antisym-val"><b>pair_cmp_antisym</b></a>]  Theorem
      
      ⊢ ∀cmp1 cmp2 x y.
            (∀x y. cmp1 x y = Equal ⇔ x = y) ∧
            (∀x y. cmp2 x y = Equal ⇔ x = y) ⇒
            (pair_cmp cmp1 cmp2 x y = Equal ⇔ x = y)
   
   [<a name="pair_cmp_cong-val"><b>pair_cmp_cong</b></a>]  Theorem
      
      ⊢ ∀cmp1 cmp2 v1 v2 cmp1' cmp2' v1' v2'.
            v1 = v1' ∧ v2 = v2' ∧
            (∀a b c d. v1' = (a,b) ∧ v2' = (c,d) ⇒ cmp1 a c = cmp1' a c) ∧
            (∀a b c d. v1' = (a,b) ∧ v2' = (c,d) ⇒ cmp2 b d = cmp2' b d) ⇒
            pair_cmp cmp1 cmp2 v1 v2 = pair_cmp cmp1' cmp2' v1' v2'
   
   [<a name="pair_cmp_def-val"><b>pair_cmp_def</b></a>]  Theorem
      
      ⊢ pair_cmp c1 c2 x y =
        case c1 (FST x) (FST y) of
          Less =&gt; Less
        | Equal =&gt; c2 (SND x) (SND y)
        | Greater =&gt; Greater
   
   [<a name="pair_cmp_good-val"><b>pair_cmp_good</b></a>]  Theorem
      
      ⊢ ∀cmp1 cmp2.
            good_cmp cmp1 ∧ good_cmp cmp2 ⇒ good_cmp (pair_cmp cmp1 cmp2)
   
   [<a name="pair_cmp_lexTO-val"><b>pair_cmp_lexTO</b></a>]  Theorem
      
      ⊢ ∀R V. TotOrd R ∧ TotOrd V ⇒ pair_cmp R V = R lexTO V
   
   [<a name="string_cmp_antisym-val"><b>string_cmp_antisym</b></a>]  Theorem
      
      ⊢ ∀x y. string_cmp x y = Equal ⇔ x = y
   
   [<a name="string_cmp_def-val"><b>string_cmp_def</b></a>]  Theorem
      
      ⊢ string_cmp = list_cmp char_cmp
   
   [<a name="string_cmp_good-val"><b>string_cmp_good</b></a>]  Theorem
      
      ⊢ good_cmp string_cmp
   
   [<a name="string_cmp_stringto-val"><b>string_cmp_stringto</b></a>]  Theorem
      
      ⊢ string_cmp = apto stringto
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/enumfset/comparisonScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-11</a></em></p></body></html>
