<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure sptreeTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure sptreeTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/patricia/sptreeScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature sptreeTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#delete_def-val">delete_def</a> : thm
<a name="line7"></a>    val <a href="#difference_def-val">difference_def</a> : thm
<a name="line8"></a>    val <a href="#domain_def-val">domain_def</a> : thm
<a name="line9"></a>    val <a href="#filter_v_def-val">filter_v_def</a> : thm
<a name="line10"></a>    val <a href="#foldi_def-val">foldi_def</a> : thm
<a name="line11"></a>    val <a href="#fromAList_primitive_def-val">fromAList_primitive_def</a> : thm
<a name="line12"></a>    val <a href="#fromList_def-val">fromList_def</a> : thm
<a name="line13"></a>    val <a href="#inter_def-val">inter_def</a> : thm
<a name="line14"></a>    val <a href="#inter_eq_def-val">inter_eq_def</a> : thm
<a name="line15"></a>    val <a href="#lrnext_primitive_def-val">lrnext_primitive_def</a> : thm
<a name="line16"></a>    val <a href="#map_def-val">map_def</a> : thm
<a name="line17"></a>    val <a href="#mapi0_def-val">mapi0_def</a> : thm
<a name="line18"></a>    val <a href="#mapi_def-val">mapi_def</a> : thm
<a name="line19"></a>    val <a href="#mk_wf_def-val">mk_wf_def</a> : thm
<a name="line20"></a>    val <a href="#size_def-val">size_def</a> : thm
<a name="line21"></a>    val <a href="#spt_TY_DEF-val">spt_TY_DEF</a> : thm
<a name="line22"></a>    val <a href="#spt_case_def-val">spt_case_def</a> : thm
<a name="line23"></a>    val <a href="#spt_center_primitive_def-val">spt_center_primitive_def</a> : thm
<a name="line24"></a>    val <a href="#spt_left_def-val">spt_left_def</a> : thm
<a name="line25"></a>    val <a href="#spt_right_def-val">spt_right_def</a> : thm
<a name="line26"></a>    val <a href="#spt_size_def-val">spt_size_def</a> : thm
<a name="line27"></a>    val <a href="#toAList_def-val">toAList_def</a> : thm
<a name="line28"></a>    val <a href="#toListA_def-val">toListA_def</a> : thm
<a name="line29"></a>    val <a href="#toList_def-val">toList_def</a> : thm
<a name="line30"></a>    val <a href="#union_def-val">union_def</a> : thm
<a name="line31"></a>    val <a href="#wf_def-val">wf_def</a> : thm
<a name="line32"></a>  
<a name="line33"></a>  (*  Theorems  *)
<a name="line34"></a>    val <a href="#ALL_DISTINCT_MAP_FST_toAList-val">ALL_DISTINCT_MAP_FST_toAList</a> : thm
<a name="line35"></a>    val <a href="#ALOOKUP_toAList-val">ALOOKUP_toAList</a> : thm
<a name="line36"></a>    val <a href="#FINITE_domain-val">FINITE_domain</a> : thm
<a name="line37"></a>    val <a href="#IN_domain-val">IN_domain</a> : thm
<a name="line38"></a>    val <a href="#MAP_foldi-val">MAP_foldi</a> : thm
<a name="line39"></a>    val <a href="#MEM_toAList-val">MEM_toAList</a> : thm
<a name="line40"></a>    val <a href="#MEM_toList-val">MEM_toList</a> : thm
<a name="line41"></a>    val <a href="#datatype_spt-val">datatype_spt</a> : thm
<a name="line42"></a>    val <a href="#delete_compute-val">delete_compute</a> : thm
<a name="line43"></a>    val <a href="#delete_fail-val">delete_fail</a> : thm
<a name="line44"></a>    val <a href="#delete_mk_wf-val">delete_mk_wf</a> : thm
<a name="line45"></a>    val <a href="#difference_sub-val">difference_sub</a> : thm
<a name="line46"></a>    val <a href="#domain_delete-val">domain_delete</a> : thm
<a name="line47"></a>    val <a href="#domain_difference-val">domain_difference</a> : thm
<a name="line48"></a>    val <a href="#domain_empty-val">domain_empty</a> : thm
<a name="line49"></a>    val <a href="#domain_foldi-val">domain_foldi</a> : thm
<a name="line50"></a>    val <a href="#domain_fromAList-val">domain_fromAList</a> : thm
<a name="line51"></a>    val <a href="#domain_fromList-val">domain_fromList</a> : thm
<a name="line52"></a>    val <a href="#domain_insert-val">domain_insert</a> : thm
<a name="line53"></a>    val <a href="#domain_inter-val">domain_inter</a> : thm
<a name="line54"></a>    val <a href="#domain_lookup-val">domain_lookup</a> : thm
<a name="line55"></a>    val <a href="#domain_map-val">domain_map</a> : thm
<a name="line56"></a>    val <a href="#domain_mapi-val">domain_mapi</a> : thm
<a name="line57"></a>    val <a href="#domain_mk_wf-val">domain_mk_wf</a> : thm
<a name="line58"></a>    val <a href="#domain_sing-val">domain_sing</a> : thm
<a name="line59"></a>    val <a href="#domain_union-val">domain_union</a> : thm
<a name="line60"></a>    val <a href="#foldi_FOLDR_toAList-val">foldi_FOLDR_toAList</a> : thm
<a name="line61"></a>    val <a href="#fromAList_def-val">fromAList_def</a> : thm
<a name="line62"></a>    val <a href="#fromAList_ind-val">fromAList_ind</a> : thm
<a name="line63"></a>    val <a href="#fromAList_toAList-val">fromAList_toAList</a> : thm
<a name="line64"></a>    val <a href="#insert_compute-val">insert_compute</a> : thm
<a name="line65"></a>    val <a href="#insert_def-val">insert_def</a> : thm
<a name="line66"></a>    val <a href="#insert_ind-val">insert_ind</a> : thm
<a name="line67"></a>    val <a href="#insert_insert-val">insert_insert</a> : thm
<a name="line68"></a>    val <a href="#insert_mk_wf-val">insert_mk_wf</a> : thm
<a name="line69"></a>    val <a href="#insert_notEmpty-val">insert_notEmpty</a> : thm
<a name="line70"></a>    val <a href="#insert_shadow-val">insert_shadow</a> : thm
<a name="line71"></a>    val <a href="#insert_union-val">insert_union</a> : thm
<a name="line72"></a>    val <a href="#inter_LN-val">inter_LN</a> : thm
<a name="line73"></a>    val <a href="#inter_assoc-val">inter_assoc</a> : thm
<a name="line74"></a>    val <a href="#inter_eq-val">inter_eq</a> : thm
<a name="line75"></a>    val <a href="#isEmpty_toList-val">isEmpty_toList</a> : thm
<a name="line76"></a>    val <a href="#isEmpty_toListA-val">isEmpty_toListA</a> : thm
<a name="line77"></a>    val <a href="#isEmpty_union-val">isEmpty_union</a> : thm
<a name="line78"></a>    val <a href="#lookup_NONE_domain-val">lookup_NONE_domain</a> : thm
<a name="line79"></a>    val <a href="#lookup_compute-val">lookup_compute</a> : thm
<a name="line80"></a>    val <a href="#lookup_def-val">lookup_def</a> : thm
<a name="line81"></a>    val <a href="#lookup_delete-val">lookup_delete</a> : thm
<a name="line82"></a>    val <a href="#lookup_difference-val">lookup_difference</a> : thm
<a name="line83"></a>    val <a href="#lookup_filter_v-val">lookup_filter_v</a> : thm
<a name="line84"></a>    val <a href="#lookup_fromAList-val">lookup_fromAList</a> : thm
<a name="line85"></a>    val <a href="#lookup_fromAList_toAList-val">lookup_fromAList_toAList</a> : thm
<a name="line86"></a>    val <a href="#lookup_fromList-val">lookup_fromList</a> : thm
<a name="line87"></a>    val <a href="#lookup_fromList_outside-val">lookup_fromList_outside</a> : thm
<a name="line88"></a>    val <a href="#lookup_ind-val">lookup_ind</a> : thm
<a name="line89"></a>    val <a href="#lookup_insert-val">lookup_insert</a> : thm
<a name="line90"></a>    val <a href="#lookup_insert1-val">lookup_insert1</a> : thm
<a name="line91"></a>    val <a href="#lookup_inter-val">lookup_inter</a> : thm
<a name="line92"></a>    val <a href="#lookup_inter_EQ-val">lookup_inter_EQ</a> : thm
<a name="line93"></a>    val <a href="#lookup_inter_alt-val">lookup_inter_alt</a> : thm
<a name="line94"></a>    val <a href="#lookup_inter_assoc-val">lookup_inter_assoc</a> : thm
<a name="line95"></a>    val <a href="#lookup_inter_eq-val">lookup_inter_eq</a> : thm
<a name="line96"></a>    val <a href="#lookup_map-val">lookup_map</a> : thm
<a name="line97"></a>    val <a href="#lookup_map_K-val">lookup_map_K</a> : thm
<a name="line98"></a>    val <a href="#lookup_mapi-val">lookup_mapi</a> : thm
<a name="line99"></a>    val <a href="#lookup_mapi0-val">lookup_mapi0</a> : thm
<a name="line100"></a>    val <a href="#lookup_mk_BN-val">lookup_mk_BN</a> : thm
<a name="line101"></a>    val <a href="#lookup_mk_wf-val">lookup_mk_wf</a> : thm
<a name="line102"></a>    val <a href="#lookup_union-val">lookup_union</a> : thm
<a name="line103"></a>    val <a href="#lrnext_def-val">lrnext_def</a> : thm
<a name="line104"></a>    val <a href="#lrnext_ind-val">lrnext_ind</a> : thm
<a name="line105"></a>    val <a href="#lrnext_thm-val">lrnext_thm</a> : thm
<a name="line106"></a>    val <a href="#map_LN-val">map_LN</a> : thm
<a name="line107"></a>    val <a href="#map_insert-val">map_insert</a> : thm
<a name="line108"></a>    val <a href="#map_map_K-val">map_map_K</a> : thm
<a name="line109"></a>    val <a href="#map_map_o-val">map_map_o</a> : thm
<a name="line110"></a>    val <a href="#mapi_Alist-val">mapi_Alist</a> : thm
<a name="line111"></a>    val <a href="#mk_BN_def-val">mk_BN_def</a> : thm
<a name="line112"></a>    val <a href="#mk_BN_ind-val">mk_BN_ind</a> : thm
<a name="line113"></a>    val <a href="#mk_BS_def-val">mk_BS_def</a> : thm
<a name="line114"></a>    val <a href="#mk_BS_ind-val">mk_BS_ind</a> : thm
<a name="line115"></a>    val <a href="#mk_wf_eq-val">mk_wf_eq</a> : thm
<a name="line116"></a>    val <a href="#num_set_domain_eq-val">num_set_domain_eq</a> : thm
<a name="line117"></a>    val <a href="#set_foldi_keys-val">set_foldi_keys</a> : thm
<a name="line118"></a>    val <a href="#size_delete-val">size_delete</a> : thm
<a name="line119"></a>    val <a href="#size_domain-val">size_domain</a> : thm
<a name="line120"></a>    val <a href="#size_insert-val">size_insert</a> : thm
<a name="line121"></a>    val <a href="#spt_11-val">spt_11</a> : thm
<a name="line122"></a>    val <a href="#spt_Axiom-val">spt_Axiom</a> : thm
<a name="line123"></a>    val <a href="#spt_acc_0-val">spt_acc_0</a> : thm
<a name="line124"></a>    val <a href="#spt_acc_def-val">spt_acc_def</a> : thm
<a name="line125"></a>    val <a href="#spt_acc_def_compute-val">spt_acc_def_compute</a> : thm
<a name="line126"></a>    val <a href="#spt_acc_eqn-val">spt_acc_eqn</a> : thm
<a name="line127"></a>    val <a href="#spt_acc_ind-val">spt_acc_ind</a> : thm
<a name="line128"></a>    val <a href="#spt_acc_thm-val">spt_acc_thm</a> : thm
<a name="line129"></a>    val <a href="#spt_case_cong-val">spt_case_cong</a> : thm
<a name="line130"></a>    val <a href="#spt_case_eq-val">spt_case_eq</a> : thm
<a name="line131"></a>    val <a href="#spt_center_def-val">spt_center_def</a> : thm
<a name="line132"></a>    val <a href="#spt_center_ind-val">spt_center_ind</a> : thm
<a name="line133"></a>    val <a href="#spt_distinct-val">spt_distinct</a> : thm
<a name="line134"></a>    val <a href="#spt_eq_thm-val">spt_eq_thm</a> : thm
<a name="line135"></a>    val <a href="#spt_induction-val">spt_induction</a> : thm
<a name="line136"></a>    val <a href="#spt_nchotomy-val">spt_nchotomy</a> : thm
<a name="line137"></a>    val <a href="#subspt_LN-val">subspt_LN</a> : thm
<a name="line138"></a>    val <a href="#subspt_def-val">subspt_def</a> : thm
<a name="line139"></a>    val <a href="#subspt_domain-val">subspt_domain</a> : thm
<a name="line140"></a>    val <a href="#subspt_eq-val">subspt_eq</a> : thm
<a name="line141"></a>    val <a href="#subspt_lookup-val">subspt_lookup</a> : thm
<a name="line142"></a>    val <a href="#subspt_refl-val">subspt_refl</a> : thm
<a name="line143"></a>    val <a href="#subspt_trans-val">subspt_trans</a> : thm
<a name="line144"></a>    val <a href="#toListA_append-val">toListA_append</a> : thm
<a name="line145"></a>    val <a href="#toList_map-val">toList_map</a> : thm
<a name="line146"></a>    val <a href="#union_LN-val">union_LN</a> : thm
<a name="line147"></a>    val <a href="#union_assoc-val">union_assoc</a> : thm
<a name="line148"></a>    val <a href="#union_mk_wf-val">union_mk_wf</a> : thm
<a name="line149"></a>    val <a href="#union_num_set_sym-val">union_num_set_sym</a> : thm
<a name="line150"></a>    val <a href="#wf_delete-val">wf_delete</a> : thm
<a name="line151"></a>    val <a href="#wf_difference-val">wf_difference</a> : thm
<a name="line152"></a>    val <a href="#wf_filter_v-val">wf_filter_v</a> : thm
<a name="line153"></a>    val <a href="#wf_fromAList-val">wf_fromAList</a> : thm
<a name="line154"></a>    val <a href="#wf_insert-val">wf_insert</a> : thm
<a name="line155"></a>    val <a href="#wf_inter-val">wf_inter</a> : thm
<a name="line156"></a>    val <a href="#wf_map-val">wf_map</a> : thm
<a name="line157"></a>    val <a href="#wf_mapi-val">wf_mapi</a> : thm
<a name="line158"></a>    val <a href="#wf_mk_BN-val">wf_mk_BN</a> : thm
<a name="line159"></a>    val <a href="#wf_mk_BS-val">wf_mk_BS</a> : thm
<a name="line160"></a>    val <a href="#wf_mk_id-val">wf_mk_id</a> : thm
<a name="line161"></a>    val <a href="#wf_mk_wf-val">wf_mk_wf</a> : thm
<a name="line162"></a>    val <a href="#wf_union-val">wf_union</a> : thm
<a name="line163"></a>  
<a name="line164"></a>  val sptree_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line165"></a>(*
   [alist] Parent theory of "sptree"
   
   [logroot] Parent theory of "sptree"
   
   [<a name="delete_def-val"><b>delete_def</b></a>]  Definition
      
      ⊢ (∀k. isEmpty (delete k LN)) ∧
        (∀k a. delete k (LS a) = if k = 0 then LN else LS a) ∧
        (∀k t1 t2.
             delete k (BN t1 t2) =
             if k = 0 then BN t1 t2
             else if EVEN k then mk_BN (delete ((k − 1) DIV 2) t1) t2
             else mk_BN t1 (delete ((k − 1) DIV 2) t2)) ∧
        ∀k t1 a t2.
            delete k (BS t1 a t2) =
            if k = 0 then BN t1 t2
            else if EVEN k then mk_BS (delete ((k − 1) DIV 2) t1) a t2
            else mk_BS t1 a (delete ((k − 1) DIV 2) t2)
   
   [<a name="difference_def-val"><b>difference_def</b></a>]  Definition
      
      ⊢ (∀t. isEmpty (difference LN t)) ∧
        (∀a t.
             difference (LS a) t =
             case t of
               LN =&gt; LS a
             | LS b =&gt; LN
             | BN t1 t2 =&gt; LS a
             | BS t1' b' t2' =&gt; LN) ∧
        (∀t1 t2 t.
             difference (BN t1 t2) t =
             case t of
               LN =&gt; BN t1 t2
             | LS a =&gt; BN t1 t2
             | BN t1' t2' =&gt; mk_BN (difference t1 t1') (difference t2 t2')
             | BS t1'' a'' t2'' =&gt;
               mk_BN (difference t1 t1'') (difference t2 t2'')) ∧
        ∀t1 a t2 t.
            difference (BS t1 a t2) t =
            case t of
              LN =&gt; BS t1 a t2
            | LS a' =&gt; BN t1 t2
            | BN t1' t2' =&gt; mk_BS (difference t1 t1') a (difference t2 t2')
            | BS t1'' a''' t2'' =&gt;
              mk_BN (difference t1 t1'') (difference t2 t2'')
   
   [<a name="domain_def-val"><b>domain_def</b></a>]  Definition
      
      ⊢ (domain LN = ∅) ∧ (∀v0. domain (LS v0) = {0}) ∧
        (∀t1 t2.
             domain (BN t1 t2) =
             IMAGE (λn. 2 * n + 2) (domain t1) ∪
             IMAGE (λn. 2 * n + 1) (domain t2)) ∧
        ∀t1 v1 t2.
            domain (BS t1 v1 t2) =
            {0} ∪ IMAGE (λn. 2 * n + 2) (domain t1) ∪
            IMAGE (λn. 2 * n + 1) (domain t2)
   
   [<a name="filter_v_def-val"><b>filter_v_def</b></a>]  Definition
      
      ⊢ (∀f. isEmpty (filter_v f LN)) ∧
        (∀f x. filter_v f (LS x) = if f x then LS x else LN) ∧
        (∀f l r. filter_v f (BN l r) = mk_BN (filter_v f l) (filter_v f r)) ∧
        ∀f l x r.
            filter_v f (BS l x r) =
            if f x then mk_BS (filter_v f l) x (filter_v f r)
            else mk_BN (filter_v f l) (filter_v f r)
   
   [<a name="foldi_def-val"><b>foldi_def</b></a>]  Definition
      
      ⊢ (∀f i acc. foldi f i acc LN = acc) ∧
        (∀f i acc a. foldi f i acc (LS a) = f i a acc) ∧
        (∀f i acc t1 t2.
             foldi f i acc (BN t1 t2) =
             (let
                inc = sptree$lrnext i
              in
                foldi f (i + inc) (foldi f (i + 2 * inc) acc t1) t2)) ∧
        ∀f i acc t1 a t2.
            foldi f i acc (BS t1 a t2) =
            (let
               inc = sptree$lrnext i
             in
               foldi f (i + inc) (f i a (foldi f (i + 2 * inc) acc t1)) t2)
   
   [<a name="fromAList_primitive_def-val"><b>fromAList_primitive_def</b></a>]  Definition
      
      ⊢ fromAList =
        WFREC (@R. WF R ∧ ∀y x xs. R xs ((x,y)::xs))
          (λfromAList a.
               case a of
                 [] =&gt; I LN
               | (x,y)::xs =&gt; I (insert x y (fromAList xs)))
   
   [<a name="fromList_def-val"><b>fromList_def</b></a>]  Definition
      
      ⊢ ∀l.
            fromList l =
            SND (FOLDL (λ(i,t) a. (i + 1,insert i a t)) (0,LN) l)
   
   [<a name="inter_def-val"><b>inter_def</b></a>]  Definition
      
      ⊢ (∀t. isEmpty (inter LN t)) ∧
        (∀a t.
             inter (LS a) t =
             case t of
               LN =&gt; LN
             | LS b =&gt; LS a
             | BN t1 t2 =&gt; LN
             | BS t1' v4 t2' =&gt; LS a) ∧
        (∀t1 t2 t.
             inter (BN t1 t2) t =
             case t of
               LN =&gt; LN
             | LS a =&gt; LN
             | BN t1' t2' =&gt; mk_BN (inter t1 t1') (inter t2 t2')
             | BS t1'' a'' t2'' =&gt; mk_BN (inter t1 t1'') (inter t2 t2'')) ∧
        ∀t1 a t2 t.
            inter (BS t1 a t2) t =
            case t of
              LN =&gt; LN
            | LS a' =&gt; LS a
            | BN t1' t2' =&gt; mk_BN (inter t1 t1') (inter t2 t2')
            | BS t1'' a''' t2'' =&gt; mk_BS (inter t1 t1'') a (inter t2 t2'')
   
   [<a name="inter_eq_def-val"><b>inter_eq_def</b></a>]  Definition
      
      ⊢ (∀t. isEmpty (inter_eq LN t)) ∧
        (∀a t.
             inter_eq (LS a) t =
             case t of
               LN =&gt; LN
             | LS b =&gt; if a = b then LS a else LN
             | BN t1 t2 =&gt; LN
             | BS t1' b' t2' =&gt; if a = b' then LS a else LN) ∧
        (∀t1 t2 t.
             inter_eq (BN t1 t2) t =
             case t of
               LN =&gt; LN
             | LS a =&gt; LN
             | BN t1' t2' =&gt; mk_BN (inter_eq t1 t1') (inter_eq t2 t2')
             | BS t1'' a'' t2'' =&gt;
               mk_BN (inter_eq t1 t1'') (inter_eq t2 t2'')) ∧
        ∀t1 a t2 t.
            inter_eq (BS t1 a t2) t =
            case t of
              LN =&gt; LN
            | LS a' =&gt; if a' = a then LS a else LN
            | BN t1' t2' =&gt; mk_BN (inter_eq t1 t1') (inter_eq t2 t2')
            | BS t1'' a''' t2'' =&gt;
              if a''' = a then
                mk_BS (inter_eq t1 t1'') a (inter_eq t2 t2'')
              else mk_BN (inter_eq t1 t1'') (inter_eq t2 t2'')
   
   [<a name="lrnext_primitive_def-val"><b>lrnext_primitive_def</b></a>]  Definition
      
      ⊢ sptree$lrnext =
        WFREC (@R. WF R ∧ ∀n. n ≠ 0 ⇒ R ((n − 1) DIV 2) n)
          (λlrnext a. I (if a = 0 then 1 else 2 * lrnext ((a − 1) DIV 2)))
   
   [<a name="map_def-val"><b>map_def</b></a>]  Definition
      
      ⊢ (∀f. isEmpty (map f LN)) ∧ (∀f a. map f (LS a) = LS (f a)) ∧
        (∀f t1 t2. map f (BN t1 t2) = BN (map f t1) (map f t2)) ∧
        ∀f t1 a t2. map f (BS t1 a t2) = BS (map f t1) (f a) (map f t2)
   
   [<a name="mapi0_def-val"><b>mapi0_def</b></a>]  Definition
      
      ⊢ (∀f i. isEmpty (mapi0 f i LN)) ∧
        (∀f i a. mapi0 f i (LS a) = LS (f i a)) ∧
        (∀f i t1 t2.
             mapi0 f i (BN t1 t2) =
             (let
                inc = sptree$lrnext i
              in
                mk_BN (mapi0 f (i + 2 * inc) t1) (mapi0 f (i + inc) t2))) ∧
        ∀f i t1 a t2.
            mapi0 f i (BS t1 a t2) =
            (let
               inc = sptree$lrnext i
             in
               mk_BS (mapi0 f (i + 2 * inc) t1) (f i a)
                 (mapi0 f (i + inc) t2))
   
   [<a name="mapi_def-val"><b>mapi_def</b></a>]  Definition
      
      ⊢ ∀f pt. mapi f pt = mapi0 f 0 pt
   
   [<a name="mk_wf_def-val"><b>mk_wf_def</b></a>]  Definition
      
      ⊢ isEmpty (mk_wf LN) ∧ (∀x. mk_wf (LS x) = LS x) ∧
        (∀t1 t2. mk_wf (BN t1 t2) = mk_BN (mk_wf t1) (mk_wf t2)) ∧
        ∀t1 x t2. mk_wf (BS t1 x t2) = mk_BS (mk_wf t1) x (mk_wf t2)
   
   [<a name="size_def-val"><b>size_def</b></a>]  Definition
      
      ⊢ (size LN = 0) ∧ (∀a. size (LS a) = 1) ∧
        (∀t1 t2. size (BN t1 t2) = size t1 + size t2) ∧
        ∀t1 a t2. size (BS t1 a t2) = size t1 + size t2 + 1
   
   [<a name="spt_TY_DEF-val"><b>spt_TY_DEF</b></a>]  Definition
      
      ⊢ ∃rep.
            TYPE_DEFINITION
              (λa0'.
                   ∀'spt' .
                       (∀a0'.
                            (a0' =
                             ind_type$CONSTR 0 ARB (λn. ind_type$BOTTOM)) ∨
                            (∃a.
                                 a0' =
                                 (λa.
                                      ind_type$CONSTR (SUC 0) a
                                        (λn. ind_type$BOTTOM)) a) ∨
                            (∃a0 a1.
                                 (a0' =
                                  (λa0 a1.
                                       ind_type$CONSTR (SUC (SUC 0)) ARB
                                         (ind_type$FCONS a0
                                            (ind_type$FCONS a1
                                               (λn. ind_type$BOTTOM)))) a0
                                    a1) ∧ 'spt' a0 ∧ 'spt' a1) ∨
                            (∃a0 a1 a2.
                                 (a0' =
                                  (λa0 a1 a2.
                                       ind_type$CONSTR (SUC (SUC (SUC 0)))
                                         a1
                                         (ind_type$FCONS a0
                                            (ind_type$FCONS a2
                                               (λn. ind_type$BOTTOM)))) a0
                                    a1 a2) ∧ 'spt' a0 ∧ 'spt' a2) ⇒
                            'spt' a0') ⇒
                       'spt' a0') rep
   
   [<a name="spt_case_def-val"><b>spt_case_def</b></a>]  Definition
      
      ⊢ (∀v f f1 f2. spt_CASE LN v f f1 f2 = v) ∧
        (∀a v f f1 f2. spt_CASE (LS a) v f f1 f2 = f a) ∧
        (∀a0 a1 v f f1 f2. spt_CASE (BN a0 a1) v f f1 f2 = f1 a0 a1) ∧
        ∀a0 a1 a2 v f f1 f2. spt_CASE (BS a0 a1 a2) v f f1 f2 = f2 a0 a1 a2
   
   [<a name="spt_center_primitive_def-val"><b>spt_center_primitive_def</b></a>]  Definition
      
      ⊢ spt_center =
        WFREC (@R. WF R)
          (λspt_center a.
               case a of
                 LN =&gt; I NONE
               | LS x =&gt; I (SOME x)
               | BN v7 v8 =&gt; I NONE
               | BS t1 x' t2 =&gt; I (SOME x'))
   
   [<a name="spt_left_def-val"><b>spt_left_def</b></a>]  Definition
      
      ⊢ isEmpty (spt_left LN) ∧ (∀x. isEmpty (spt_left (LS x))) ∧
        (∀t1 t2. spt_left (BN t1 t2) = t1) ∧
        ∀t1 x t2. spt_left (BS t1 x t2) = t1
   
   [<a name="spt_right_def-val"><b>spt_right_def</b></a>]  Definition
      
      ⊢ isEmpty (spt_right LN) ∧ (∀x. isEmpty (spt_right (LS x))) ∧
        (∀t1 t2. spt_right (BN t1 t2) = t2) ∧
        ∀t1 x t2. spt_right (BS t1 x t2) = t2
   
   [<a name="spt_size_def-val"><b>spt_size_def</b></a>]  Definition
      
      ⊢ (∀f. spt_size f LN = 0) ∧ (∀f a. spt_size f (LS a) = 1 + f a) ∧
        (∀f a0 a1.
             spt_size f (BN a0 a1) = 1 + (spt_size f a0 + spt_size f a1)) ∧
        ∀f a0 a1 a2.
            spt_size f (BS a0 a1 a2) =
            1 + (spt_size f a0 + (f a1 + spt_size f a2))
   
   [<a name="toAList_def-val"><b>toAList_def</b></a>]  Definition
      
      ⊢ toAList = foldi (λk v a. (k,v)::a) 0 []
   
   [<a name="toListA_def-val"><b>toListA_def</b></a>]  Definition
      
      ⊢ (∀acc. toListA acc LN = acc) ∧
        (∀acc a. toListA acc (LS a) = a::acc) ∧
        (∀acc t1 t2. toListA acc (BN t1 t2) = toListA (toListA acc t2) t1) ∧
        ∀acc t1 a t2.
            toListA acc (BS t1 a t2) = toListA (a::toListA acc t2) t1
   
   [<a name="toList_def-val"><b>toList_def</b></a>]  Definition
      
      ⊢ ∀m. toList m = toListA [] m
   
   [<a name="union_def-val"><b>union_def</b></a>]  Definition
      
      ⊢ (∀t. union LN t = t) ∧
        (∀a t.
             union (LS a) t =
             case t of
               LN =&gt; LS a
             | LS b =&gt; LS a
             | BN t1 t2 =&gt; BS t1 a t2
             | BS t1' v4 t2' =&gt; BS t1' a t2') ∧
        (∀t1 t2 t.
             union (BN t1 t2) t =
             case t of
               LN =&gt; BN t1 t2
             | LS a =&gt; BS t1 a t2
             | BN t1' t2' =&gt; BN (union t1 t1') (union t2 t2')
             | BS t1'' a'' t2'' =&gt; BS (union t1 t1'') a'' (union t2 t2'')) ∧
        ∀t1 a t2 t.
            union (BS t1 a t2) t =
            case t of
              LN =&gt; BS t1 a t2
            | LS a' =&gt; BS t1 a t2
            | BN t1' t2' =&gt; BS (union t1 t1') a (union t2 t2')
            | BS t1'' a''' t2'' =&gt; BS (union t1 t1'') a (union t2 t2'')
   
   [<a name="wf_def-val"><b>wf_def</b></a>]  Definition
      
      ⊢ (wf LN ⇔ T) ∧ (∀a. wf (LS a) ⇔ T) ∧
        (∀t1 t2. wf (BN t1 t2) ⇔ wf t1 ∧ wf t2 ∧ ¬(isEmpty t1 ∧ isEmpty t2)) ∧
        ∀t1 a t2.
            wf (BS t1 a t2) ⇔ wf t1 ∧ wf t2 ∧ ¬(isEmpty t1 ∧ isEmpty t2)
   
   [<a name="ALL_DISTINCT_MAP_FST_toAList-val"><b>ALL_DISTINCT_MAP_FST_toAList</b></a>]  Theorem
      
      ⊢ ∀t. ALL_DISTINCT (MAP FST (toAList t))
   
   [<a name="ALOOKUP_toAList-val"><b>ALOOKUP_toAList</b></a>]  Theorem
      
      ⊢ ∀t x. ALOOKUP (toAList t) x = lookup x t
   
   [<a name="FINITE_domain-val"><b>FINITE_domain</b></a>]  Theorem
      
      ⊢ FINITE (domain t)
   
   [<a name="IN_domain-val"><b>IN_domain</b></a>]  Theorem
      
      ⊢ ∀n x t1 t2.
            (n ∈ domain LN ⇔ F) ∧ (n ∈ domain (LS x) ⇔ (n = 0)) ∧
            (n ∈ domain (BN t1 t2) ⇔
             n ≠ 0 ∧ if EVEN n then (n − 1) DIV 2 ∈ domain t1
             else (n − 1) DIV 2 ∈ domain t2) ∧
            (n ∈ domain (BS t1 x t2) ⇔
             (n = 0) ∨ if EVEN n then (n − 1) DIV 2 ∈ domain t1
             else (n − 1) DIV 2 ∈ domain t2)
   
   [<a name="MAP_foldi-val"><b>MAP_foldi</b></a>]  Theorem
      
      ⊢ ∀n acc.
            MAP f (foldi (λk v a. (k,v)::a) n acc pt) =
            foldi (λk v a. f (k,v)::a) n (MAP f acc) pt
   
   [<a name="MEM_toAList-val"><b>MEM_toAList</b></a>]  Theorem
      
      ⊢ ∀t k v. MEM (k,v) (toAList t) ⇔ (lookup k t = SOME v)
   
   [<a name="MEM_toList-val"><b>MEM_toList</b></a>]  Theorem
      
      ⊢ ∀x t. MEM x (toList t) ⇔ ∃k. lookup k t = SOME x
   
   [<a name="datatype_spt-val"><b>datatype_spt</b></a>]  Theorem
      
      ⊢ DATATYPE (spt LN LS BN BS)
   
   [<a name="delete_compute-val"><b>delete_compute</b></a>]  Theorem
      
      ⊢ (delete (NUMERAL n) t = delete n t) ∧ isEmpty (delete 0 LN) ∧
        isEmpty (delete 0 (LS a)) ∧ (delete 0 (BN t1 t2) = BN t1 t2) ∧
        (delete 0 (BS t1 a t2) = BN t1 t2) ∧ isEmpty (delete ZERO LN) ∧
        isEmpty (delete ZERO (LS a)) ∧
        (delete ZERO (BN t1 t2) = BN t1 t2) ∧
        (delete ZERO (BS t1 a t2) = BN t1 t2) ∧
        isEmpty (delete (BIT1 n) LN) ∧ (delete (BIT1 n) (LS a) = LS a) ∧
        (delete (BIT1 n) (BN t1 t2) = mk_BN t1 (delete n t2)) ∧
        (delete (BIT1 n) (BS t1 a t2) = mk_BS t1 a (delete n t2)) ∧
        isEmpty (delete (BIT2 n) LN) ∧ (delete (BIT2 n) (LS a) = LS a) ∧
        (delete (BIT2 n) (BN t1 t2) = mk_BN (delete n t1) t2) ∧
        (delete (BIT2 n) (BS t1 a t2) = mk_BS (delete n t1) a t2)
   
   [<a name="delete_fail-val"><b>delete_fail</b></a>]  Theorem
      
      ⊢ ∀n t. wf t ⇒ (n ∉ domain t ⇔ (delete n t = t))
   
   [<a name="delete_mk_wf-val"><b>delete_mk_wf</b></a>]  Theorem
      
      ⊢ ∀x t. delete x (mk_wf t) = mk_wf (delete x t)
   
   [<a name="difference_sub-val"><b>difference_sub</b></a>]  Theorem
      
      ⊢ isEmpty (difference a b) ⇒ domain a ⊆ domain b
   
   [<a name="domain_delete-val"><b>domain_delete</b></a>]  Theorem
      
      ⊢ domain (delete k t) = domain t DELETE k
   
   [<a name="domain_difference-val"><b>domain_difference</b></a>]  Theorem
      
      ⊢ ∀t1 t2. domain (difference t1 t2) = domain t1 DIFF domain t2
   
   [<a name="domain_empty-val"><b>domain_empty</b></a>]  Theorem
      
      ⊢ ∀t. wf t ⇒ (isEmpty t ⇔ (domain t = ∅))
   
   [<a name="domain_foldi-val"><b>domain_foldi</b></a>]  Theorem
      
      ⊢ domain t = foldi (λk v a. k INSERT a) 0 ∅ t
   
   [<a name="domain_fromAList-val"><b>domain_fromAList</b></a>]  Theorem
      
      ⊢ ∀ls. domain (fromAList ls) = set (MAP FST ls)
   
   [<a name="domain_fromList-val"><b>domain_fromList</b></a>]  Theorem
      
      ⊢ domain (fromList l) = count (LENGTH l)
   
   [<a name="domain_insert-val"><b>domain_insert</b></a>]  Theorem
      
      ⊢ domain (insert k v t) = k INSERT domain t
   
   [<a name="domain_inter-val"><b>domain_inter</b></a>]  Theorem
      
      ⊢ domain (inter t1 t2) = domain t1 ∩ domain t2
   
   [<a name="domain_lookup-val"><b>domain_lookup</b></a>]  Theorem
      
      ⊢ ∀t k. k ∈ domain t ⇔ ∃v. lookup k t = SOME v
   
   [<a name="domain_map-val"><b>domain_map</b></a>]  Theorem
      
      ⊢ ∀s. domain (map f s) = domain s
   
   [<a name="domain_mapi-val"><b>domain_mapi</b></a>]  Theorem
      
      ⊢ domain (mapi f pt) = domain pt
   
   [<a name="domain_mk_wf-val"><b>domain_mk_wf</b></a>]  Theorem
      
      ⊢ ∀t. domain (mk_wf t) = domain t
   
   [<a name="domain_sing-val"><b>domain_sing</b></a>]  Theorem
      
      ⊢ domain (insert k v LN) = {k}
   
   [<a name="domain_union-val"><b>domain_union</b></a>]  Theorem
      
      ⊢ domain (union t1 t2) = domain t1 ∪ domain t2
   
   [<a name="foldi_FOLDR_toAList-val"><b>foldi_FOLDR_toAList</b></a>]  Theorem
      
      ⊢ ∀f a t. foldi f 0 a t = FOLDR (UNCURRY f) a (toAList t)
   
   [<a name="fromAList_def-val"><b>fromAList_def</b></a>]  Theorem
      
      ⊢ isEmpty (fromAList []) ∧
        ∀y xs x. fromAList ((x,y)::xs) = insert x y (fromAList xs)
   
   [<a name="fromAList_ind-val"><b>fromAList_ind</b></a>]  Theorem
      
      ⊢ ∀P. P [] ∧ (∀x y xs. P xs ⇒ P ((x,y)::xs)) ⇒ ∀v. P v
   
   [<a name="fromAList_toAList-val"><b>fromAList_toAList</b></a>]  Theorem
      
      ⊢ ∀t. wf t ⇒ (fromAList (toAList t) = t)
   
   [<a name="insert_compute-val"><b>insert_compute</b></a>]  Theorem
      
      ⊢ (insert (NUMERAL n) a t = insert n a t) ∧ (insert 0 a LN = LS a) ∧
        (insert 0 a (LS a') = LS a) ∧
        (insert 0 a (BN t1 t2) = BS t1 a t2) ∧
        (insert 0 a (BS t1 a' t2) = BS t1 a t2) ∧
        (insert ZERO a LN = LS a) ∧ (insert ZERO a (LS a') = LS a) ∧
        (insert ZERO a (BN t1 t2) = BS t1 a t2) ∧
        (insert ZERO a (BS t1 a' t2) = BS t1 a t2) ∧
        (insert (BIT1 n) a LN = BN LN (insert n a LN)) ∧
        (insert (BIT1 n) a (LS a') = BS LN a' (insert n a LN)) ∧
        (insert (BIT1 n) a (BN t1 t2) = BN t1 (insert n a t2)) ∧
        (insert (BIT1 n) a (BS t1 a' t2) = BS t1 a' (insert n a t2)) ∧
        (insert (BIT2 n) a LN = BN (insert n a LN) LN) ∧
        (insert (BIT2 n) a (LS a') = BS (insert n a LN) a' LN) ∧
        (insert (BIT2 n) a (BN t1 t2) = BN (insert n a t1) t2) ∧
        (insert (BIT2 n) a (BS t1 a' t2) = BS (insert n a t1) a' t2)
   
   [<a name="insert_def-val"><b>insert_def</b></a>]  Theorem
      
      ⊢ (∀k a.
             insert k a LN =
             if k = 0 then LS a
             else if EVEN k then BN (insert ((k − 1) DIV 2) a LN) LN
             else BN LN (insert ((k − 1) DIV 2) a LN)) ∧
        (∀k a' a.
             insert k a (LS a') =
             if k = 0 then LS a
             else if EVEN k then BS (insert ((k − 1) DIV 2) a LN) a' LN
             else BS LN a' (insert ((k − 1) DIV 2) a LN)) ∧
        (∀t2 t1 k a.
             insert k a (BN t1 t2) =
             if k = 0 then BS t1 a t2
             else if EVEN k then BN (insert ((k − 1) DIV 2) a t1) t2
             else BN t1 (insert ((k − 1) DIV 2) a t2)) ∧
        ∀t2 t1 k a' a.
            insert k a (BS t1 a' t2) =
            if k = 0 then BS t1 a t2
            else if EVEN k then BS (insert ((k − 1) DIV 2) a t1) a' t2
            else BS t1 a' (insert ((k − 1) DIV 2) a t2)
   
   [<a name="insert_ind-val"><b>insert_ind</b></a>]  Theorem
      
      ⊢ ∀P.
            (∀k a.
                 (k ≠ 0 ∧ EVEN k ⇒ P ((k − 1) DIV 2) a LN) ∧
                 (k ≠ 0 ∧ ¬EVEN k ⇒ P ((k − 1) DIV 2) a LN) ⇒
                 P k a LN) ∧
            (∀k a a'.
                 (k ≠ 0 ∧ EVEN k ⇒ P ((k − 1) DIV 2) a LN) ∧
                 (k ≠ 0 ∧ ¬EVEN k ⇒ P ((k − 1) DIV 2) a LN) ⇒
                 P k a (LS a')) ∧
            (∀k a t1 t2.
                 (k ≠ 0 ∧ EVEN k ⇒ P ((k − 1) DIV 2) a t1) ∧
                 (k ≠ 0 ∧ ¬EVEN k ⇒ P ((k − 1) DIV 2) a t2) ⇒
                 P k a (BN t1 t2)) ∧
            (∀k a t1 a' t2.
                 (k ≠ 0 ∧ EVEN k ⇒ P ((k − 1) DIV 2) a t1) ∧
                 (k ≠ 0 ∧ ¬EVEN k ⇒ P ((k − 1) DIV 2) a t2) ⇒
                 P k a (BS t1 a' t2)) ⇒
            ∀v v1 v2. P v v1 v2
   
   [<a name="insert_insert-val"><b>insert_insert</b></a>]  Theorem
      
      ⊢ ∀x1 x2 v1 v2 t.
            insert x1 v1 (insert x2 v2 t) =
            if x1 = x2 then insert x1 v1 t
            else insert x2 v2 (insert x1 v1 t)
   
   [<a name="insert_mk_wf-val"><b>insert_mk_wf</b></a>]  Theorem
      
      ⊢ ∀x v t. insert x v (mk_wf t) = mk_wf (insert x v t)
   
   [<a name="insert_notEmpty-val"><b>insert_notEmpty</b></a>]  Theorem
      
      ⊢ insert k a t ≠ LN
   
   [<a name="insert_shadow-val"><b>insert_shadow</b></a>]  Theorem
      
      ⊢ ∀t a b c. insert a b (insert a c t) = insert a b t
   
   [<a name="insert_union-val"><b>insert_union</b></a>]  Theorem
      
      ⊢ ∀k v s. insert k v s = union (insert k v LN) s
   
   [<a name="inter_LN-val"><b>inter_LN</b></a>]  Theorem
      
      ⊢ ∀t. isEmpty (inter t LN) ∧ isEmpty (inter LN t)
   
   [<a name="inter_assoc-val"><b>inter_assoc</b></a>]  Theorem
      
      ⊢ ∀t1 t2 t3. inter t1 (inter t2 t3) = inter (inter t1 t2) t3
   
   [<a name="inter_eq-val"><b>inter_eq</b></a>]  Theorem
      
      ⊢ ∀t1 t2 t3 t4.
            (inter t1 t2 = inter t3 t4) ⇔
            ∀x. lookup x (inter t1 t2) = lookup x (inter t3 t4)
   
   [<a name="isEmpty_toList-val"><b>isEmpty_toList</b></a>]  Theorem
      
      ⊢ ∀t. wf t ⇒ (isEmpty t ⇔ (toList t = []))
   
   [<a name="isEmpty_toListA-val"><b>isEmpty_toListA</b></a>]  Theorem
      
      ⊢ ∀t acc. wf t ⇒ (isEmpty t ⇔ (toListA acc t = acc))
   
   [<a name="isEmpty_union-val"><b>isEmpty_union</b></a>]  Theorem
      
      ⊢ isEmpty (union m1 m2) ⇔ isEmpty m1 ∧ isEmpty m2
   
   [<a name="lookup_NONE_domain-val"><b>lookup_NONE_domain</b></a>]  Theorem
      
      ⊢ (lookup k t = NONE) ⇔ k ∉ domain t
   
   [<a name="lookup_compute-val"><b>lookup_compute</b></a>]  Theorem
      
      ⊢ (lookup (NUMERAL n) t = lookup n t) ∧ (lookup 0 LN = NONE) ∧
        (lookup 0 (LS a) = SOME a) ∧ (lookup 0 (BN t1 t2) = NONE) ∧
        (lookup 0 (BS t1 a t2) = SOME a) ∧ (lookup ZERO LN = NONE) ∧
        (lookup ZERO (LS a) = SOME a) ∧ (lookup ZERO (BN t1 t2) = NONE) ∧
        (lookup ZERO (BS t1 a t2) = SOME a) ∧ (lookup (BIT1 n) LN = NONE) ∧
        (lookup (BIT1 n) (LS a) = NONE) ∧
        (lookup (BIT1 n) (BN t1 t2) = lookup n t2) ∧
        (lookup (BIT1 n) (BS t1 a t2) = lookup n t2) ∧
        (lookup (BIT2 n) LN = NONE) ∧ (lookup (BIT2 n) (LS a) = NONE) ∧
        (lookup (BIT2 n) (BN t1 t2) = lookup n t1) ∧
        (lookup (BIT2 n) (BS t1 a t2) = lookup n t1)
   
   [<a name="lookup_def-val"><b>lookup_def</b></a>]  Theorem
      
      ⊢ (∀k. lookup k LN = NONE) ∧
        (∀k a. lookup k (LS a) = if k = 0 then SOME a else NONE) ∧
        (∀t2 t1 k.
             lookup k (BN t1 t2) =
             if k = 0 then NONE
             else lookup ((k − 1) DIV 2) (if EVEN k then t1 else t2)) ∧
        ∀t2 t1 k a.
            lookup k (BS t1 a t2) =
            if k = 0 then SOME a
            else lookup ((k − 1) DIV 2) (if EVEN k then t1 else t2)
   
   [<a name="lookup_delete-val"><b>lookup_delete</b></a>]  Theorem
      
      ⊢ ∀t k1 k2.
            lookup k1 (delete k2 t) = if k1 = k2 then NONE else lookup k1 t
   
   [<a name="lookup_difference-val"><b>lookup_difference</b></a>]  Theorem
      
      ⊢ ∀m1 m2 k.
            lookup k (difference m1 m2) =
            if lookup k m2 = NONE then lookup k m1
            else NONE
   
   [<a name="lookup_filter_v-val"><b>lookup_filter_v</b></a>]  Theorem
      
      ⊢ ∀k t f.
            lookup k (filter_v f t) =
            case lookup k t of
              NONE =&gt; NONE
            | SOME v =&gt; if f v then SOME v else NONE
   
   [<a name="lookup_fromAList-val"><b>lookup_fromAList</b></a>]  Theorem
      
      ⊢ ∀ls x. lookup x (fromAList ls) = ALOOKUP ls x
   
   [<a name="lookup_fromAList_toAList-val"><b>lookup_fromAList_toAList</b></a>]  Theorem
      
      ⊢ ∀t x. lookup x (fromAList (toAList t)) = lookup x t
   
   [<a name="lookup_fromList-val"><b>lookup_fromList</b></a>]  Theorem
      
      ⊢ lookup n (fromList l) =
        if n &lt; LENGTH l then SOME (EL n l)
        else NONE
   
   [<a name="lookup_fromList_outside-val"><b>lookup_fromList_outside</b></a>]  Theorem
      
      ⊢ ∀k. LENGTH args ≤ k ⇒ (lookup k (fromList args) = NONE)
   
   [<a name="lookup_ind-val"><b>lookup_ind</b></a>]  Theorem
      
      ⊢ ∀P.
            (∀k. P k LN) ∧ (∀k a. P k (LS a)) ∧
            (∀k t1 t2.
                 (k ≠ 0 ⇒ P ((k − 1) DIV 2) (if EVEN k then t1 else t2)) ⇒
                 P k (BN t1 t2)) ∧
            (∀k t1 a t2.
                 (k ≠ 0 ⇒ P ((k − 1) DIV 2) (if EVEN k then t1 else t2)) ⇒
                 P k (BS t1 a t2)) ⇒
            ∀v v1. P v v1
   
   [<a name="lookup_insert-val"><b>lookup_insert</b></a>]  Theorem
      
      ⊢ ∀k2 v t k1.
            lookup k1 (insert k2 v t) =
            if k1 = k2 then SOME v
            else lookup k1 t
   
   [<a name="lookup_insert1-val"><b>lookup_insert1</b></a>]  Theorem
      
      ⊢ ∀k a t. lookup k (insert k a t) = SOME a
   
   [<a name="lookup_inter-val"><b>lookup_inter</b></a>]  Theorem
      
      ⊢ ∀m1 m2 k.
            lookup k (inter m1 m2) =
            case (lookup k m1,lookup k m2) of
              (NONE,v4) =&gt; NONE
            | (SOME v,NONE) =&gt; NONE
            | (SOME v,SOME w) =&gt; SOME v
   
   [<a name="lookup_inter_EQ-val"><b>lookup_inter_EQ</b></a>]  Theorem
      
      ⊢ ((lookup x (inter t1 t2) = SOME y) ⇔
         (lookup x t1 = SOME y) ∧ lookup x t2 ≠ NONE) ∧
        ((lookup x (inter t1 t2) = NONE) ⇔
         (lookup x t1 = NONE) ∨ (lookup x t2 = NONE))
   
   [<a name="lookup_inter_alt-val"><b>lookup_inter_alt</b></a>]  Theorem
      
      ⊢ lookup x (inter t1 t2) =
        if x ∈ domain t2 then lookup x t1
        else NONE
   
   [<a name="lookup_inter_assoc-val"><b>lookup_inter_assoc</b></a>]  Theorem
      
      ⊢ lookup x (inter t1 (inter t2 t3)) =
        lookup x (inter (inter t1 t2) t3)
   
   [<a name="lookup_inter_eq-val"><b>lookup_inter_eq</b></a>]  Theorem
      
      ⊢ ∀m1 m2 k.
            lookup k (inter_eq m1 m2) =
            case lookup k m1 of
              NONE =&gt; NONE
            | SOME v =&gt; if lookup k m2 = SOME v then SOME v else NONE
   
   [<a name="lookup_map-val"><b>lookup_map</b></a>]  Theorem
      
      ⊢ ∀s x. lookup x (map f s) = OPTION_MAP f (lookup x s)
   
   [<a name="lookup_map_K-val"><b>lookup_map_K</b></a>]  Theorem
      
      ⊢ ∀t n.
            lookup n (map (K x) t) = if n ∈ domain t then SOME x else NONE
   
   [<a name="lookup_mapi-val"><b>lookup_mapi</b></a>]  Theorem
      
      ⊢ lookup k (mapi f pt) = OPTION_MAP (f k) (lookup k pt)
   
   [<a name="lookup_mapi0-val"><b>lookup_mapi0</b></a>]  Theorem
      
      ⊢ ∀pt i k.
            lookup k (mapi0 f i pt) =
            case lookup k pt of
              NONE =&gt; NONE
            | SOME v =&gt; SOME (f (spt_acc i k) v)
   
   [<a name="lookup_mk_BN-val"><b>lookup_mk_BN</b></a>]  Theorem
      
      ⊢ lookup i (mk_BN t1 t2) =
        if i = 0 then NONE
        else lookup ((i − 1) DIV 2) (if EVEN i then t1 else t2)
   
   [<a name="lookup_mk_wf-val"><b>lookup_mk_wf</b></a>]  Theorem
      
      ⊢ ∀x t. lookup x (mk_wf t) = lookup x t
   
   [<a name="lookup_union-val"><b>lookup_union</b></a>]  Theorem
      
      ⊢ ∀m1 m2 k.
            lookup k (union m1 m2) =
            case lookup k m1 of NONE =&gt; lookup k m2 | SOME v =&gt; SOME v
   
   [<a name="lrnext_def-val"><b>lrnext_def</b></a>]  Theorem
      
      ⊢ ∀n.
            sptree$lrnext n =
            if n = 0 then 1
            else 2 * sptree$lrnext ((n − 1) DIV 2)
   
   [<a name="lrnext_ind-val"><b>lrnext_ind</b></a>]  Theorem
      
      ⊢ ∀P. (∀n. (n ≠ 0 ⇒ P ((n − 1) DIV 2)) ⇒ P n) ⇒ ∀v. P v
   
   [<a name="lrnext_thm-val"><b>lrnext_thm</b></a>]  Theorem
      
      ⊢ (∀a. sptree$lrnext 0 = 1) ∧
        (∀n a. sptree$lrnext (NUMERAL n) = sptree$lrnext n) ∧
        (sptree$lrnext ZERO = 1) ∧
        (∀n. sptree$lrnext (BIT1 n) = 2 * sptree$lrnext n) ∧
        ∀n. sptree$lrnext (BIT2 n) = 2 * sptree$lrnext n
   
   [<a name="map_LN-val"><b>map_LN</b></a>]  Theorem
      
      ⊢ ∀t. isEmpty (map f t) ⇔ isEmpty t
   
   [<a name="map_insert-val"><b>map_insert</b></a>]  Theorem
      
      ⊢ ∀f x y z. map f (insert x y z) = insert x (f y) (map f z)
   
   [<a name="map_map_K-val"><b>map_map_K</b></a>]  Theorem
      
      ⊢ ∀t. map (K a) (map f t) = map (K a) t
   
   [<a name="map_map_o-val"><b>map_map_o</b></a>]  Theorem
      
      ⊢ ∀t f g. map f (map g t) = map (f ∘ g) t
   
   [<a name="mapi_Alist-val"><b>mapi_Alist</b></a>]  Theorem
      
      ⊢ mapi f pt =
        fromAList (MAP (λkv. (FST kv,f (FST kv) (SND kv))) (toAList pt))
   
   [<a name="mk_BN_def-val"><b>mk_BN_def</b></a>]  Theorem
      
      ⊢ isEmpty (mk_BN LN LN) ∧ (mk_BN LN (LS v14) = BN LN (LS v14)) ∧
        (mk_BN LN (BN v15 v16) = BN LN (BN v15 v16)) ∧
        (mk_BN LN (BS v17 v18 v19) = BN LN (BS v17 v18 v19)) ∧
        (mk_BN (LS v2) t2 = BN (LS v2) t2) ∧
        (mk_BN (BN v3 v4) t2 = BN (BN v3 v4) t2) ∧
        (mk_BN (BS v5 v6 v7) t2 = BN (BS v5 v6 v7) t2)
   
   [<a name="mk_BN_ind-val"><b>mk_BN_ind</b></a>]  Theorem
      
      ⊢ ∀P.
            P LN LN ∧ (∀v14. P LN (LS v14)) ∧
            (∀v15 v16. P LN (BN v15 v16)) ∧
            (∀v17 v18 v19. P LN (BS v17 v18 v19)) ∧
            (∀v2 t2. P (LS v2) t2) ∧ (∀v3 v4 t2. P (BN v3 v4) t2) ∧
            (∀v5 v6 v7 t2. P (BS v5 v6 v7) t2) ⇒
            ∀v v1. P v v1
   
   [<a name="mk_BS_def-val"><b>mk_BS_def</b></a>]  Theorem
      
      ⊢ (mk_BS LN x LN = LS x) ∧ (mk_BS (LS v16) x LN = BS (LS v16) x LN) ∧
        (mk_BS (BN v17 v18) x LN = BS (BN v17 v18) x LN) ∧
        (mk_BS (BS v19 v20 v21) x LN = BS (BS v19 v20 v21) x LN) ∧
        (mk_BS t1 x (LS v4) = BS t1 x (LS v4)) ∧
        (mk_BS t1 x (BN v5 v6) = BS t1 x (BN v5 v6)) ∧
        (mk_BS t1 x (BS v7 v8 v9) = BS t1 x (BS v7 v8 v9))
   
   [<a name="mk_BS_ind-val"><b>mk_BS_ind</b></a>]  Theorem
      
      ⊢ ∀P.
            (∀x. P LN x LN) ∧ (∀v16 x. P (LS v16) x LN) ∧
            (∀v17 v18 x. P (BN v17 v18) x LN) ∧
            (∀v19 v20 v21 x. P (BS v19 v20 v21) x LN) ∧
            (∀t1 x v4. P t1 x (LS v4)) ∧ (∀t1 x v5 v6. P t1 x (BN v5 v6)) ∧
            (∀t1 x v7 v8 v9. P t1 x (BS v7 v8 v9)) ⇒
            ∀v v1 v2. P v v1 v2
   
   [<a name="mk_wf_eq-val"><b>mk_wf_eq</b></a>]  Theorem
      
      ⊢ ∀t1 t2. (mk_wf t1 = mk_wf t2) ⇔ ∀x. lookup x t1 = lookup x t2
   
   [<a name="num_set_domain_eq-val"><b>num_set_domain_eq</b></a>]  Theorem
      
      ⊢ ∀t1 t2. wf t1 ∧ wf t2 ⇒ ((domain t1 = domain t2) ⇔ (t1 = t2))
   
   [<a name="set_foldi_keys-val"><b>set_foldi_keys</b></a>]  Theorem
      
      ⊢ ∀t a i.
            foldi (λk v a. k INSERT a) i a t =
            a ∪ IMAGE (λn. i + sptree$lrnext i * n) (domain t)
   
   [<a name="size_delete-val"><b>size_delete</b></a>]  Theorem
      
      ⊢ ∀n t.
            size (delete n t) =
            if lookup n t = NONE then size t
            else size t − 1
   
   [<a name="size_domain-val"><b>size_domain</b></a>]  Theorem
      
      ⊢ ∀t. size t = CARD (domain t)
   
   [<a name="size_insert-val"><b>size_insert</b></a>]  Theorem
      
      ⊢ ∀k v m.
            size (insert k v m) =
            if k ∈ domain m then size m
            else size m + 1
   
   [<a name="spt_11-val"><b>spt_11</b></a>]  Theorem
      
      ⊢ (∀a a'. (LS a = LS a') ⇔ (a = a')) ∧
        (∀a0 a1 a0' a1'. (BN a0 a1 = BN a0' a1') ⇔ (a0 = a0') ∧ (a1 = a1')) ∧
        ∀a0 a1 a2 a0' a1' a2'.
            (BS a0 a1 a2 = BS a0' a1' a2') ⇔
            (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2')
   
   [<a name="spt_Axiom-val"><b>spt_Axiom</b></a>]  Theorem
      
      ⊢ ∀f0 f1 f2 f3.
            ∃fn.
                (fn LN = f0) ∧ (∀a. fn (LS a) = f1 a) ∧
                (∀a0 a1. fn (BN a0 a1) = f2 a0 a1 (fn a0) (fn a1)) ∧
                ∀a0 a1 a2. fn (BS a0 a1 a2) = f3 a1 a0 a2 (fn a0) (fn a2)
   
   [<a name="spt_acc_0-val"><b>spt_acc_0</b></a>]  Theorem
      
      ⊢ ∀k. spt_acc 0 k = k
   
   [<a name="spt_acc_def-val"><b>spt_acc_def</b></a>]  Theorem
      
      ⊢ (∀i. spt_acc i 0 = i) ∧
        ∀k i.
            spt_acc i (SUC k) =
            spt_acc
              (i + if EVEN (SUC k) then 2 * sptree$lrnext i
               else sptree$lrnext i) (k DIV 2)
   
   [<a name="spt_acc_def_compute-val"><b>spt_acc_def_compute</b></a>]  Theorem
      
      ⊢ (∀i. spt_acc i 0 = i) ∧
        (∀k i.
             spt_acc i (NUMERAL (BIT1 k)) =
             spt_acc
               (i + if EVEN (NUMERAL (BIT1 k)) then 2 * sptree$lrnext i
                else sptree$lrnext i) ((NUMERAL (BIT1 k) − 1) DIV 2)) ∧
        ∀k i.
            spt_acc i (NUMERAL (BIT2 k)) =
            spt_acc
              (i + if EVEN (NUMERAL (BIT2 k)) then 2 * sptree$lrnext i
               else sptree$lrnext i) (NUMERAL (BIT1 k) DIV 2)
   
   [<a name="spt_acc_eqn-val"><b>spt_acc_eqn</b></a>]  Theorem
      
      ⊢ ∀k i. spt_acc i k = sptree$lrnext i * k + i
   
   [<a name="spt_acc_ind-val"><b>spt_acc_ind</b></a>]  Theorem
      
      ⊢ ∀P.
            (∀i. P i 0) ∧
            (∀i k.
                 P
                   (i + if EVEN (SUC k) then 2 * sptree$lrnext i
                    else sptree$lrnext i) (k DIV 2) ⇒
                 P i (SUC k)) ⇒
            ∀v v1. P v v1
   
   [<a name="spt_acc_thm-val"><b>spt_acc_thm</b></a>]  Theorem
      
      ⊢ spt_acc i k =
        if k = 0 then i
        else
          spt_acc
            (i + if EVEN k then 2 * sptree$lrnext i else sptree$lrnext i)
            ((k − 1) DIV 2)
   
   [<a name="spt_case_cong-val"><b>spt_case_cong</b></a>]  Theorem
      
      ⊢ ∀M M' v f f1 f2.
            (M = M') ∧ (isEmpty M' ⇒ (v = v')) ∧
            (∀a. (M' = LS a) ⇒ (f a = f' a)) ∧
            (∀a0 a1. (M' = BN a0 a1) ⇒ (f1 a0 a1 = f1' a0 a1)) ∧
            (∀a0 a1 a2. (M' = BS a0 a1 a2) ⇒ (f2 a0 a1 a2 = f2' a0 a1 a2)) ⇒
            (spt_CASE M v f f1 f2 = spt_CASE M' v' f' f1' f2')
   
   [<a name="spt_case_eq-val"><b>spt_case_eq</b></a>]  Theorem
      
      ⊢ (spt_CASE x v f f1 f2 = v') ⇔
        isEmpty x ∧ (v = v') ∨ (∃a. (x = LS a) ∧ (f a = v')) ∨
        (∃s s0. (x = BN s s0) ∧ (f1 s s0 = v')) ∨
        ∃s a s0. (x = BS s a s0) ∧ (f2 s a s0 = v')
   
   [<a name="spt_center_def-val"><b>spt_center_def</b></a>]  Theorem
      
      ⊢ (spt_center (LS x) = SOME x) ∧ (spt_center (BS t1 x t2) = SOME x) ∧
        (spt_center LN = NONE) ∧ (spt_center (BN v1 v2) = NONE)
   
   [<a name="spt_center_ind-val"><b>spt_center_ind</b></a>]  Theorem
      
      ⊢ ∀P.
            (∀x. P (LS x)) ∧ (∀t1 x t2. P (BS t1 x t2)) ∧ P LN ∧
            (∀v1 v2. P (BN v1 v2)) ⇒
            ∀v. P v
   
   [<a name="spt_distinct-val"><b>spt_distinct</b></a>]  Theorem
      
      ⊢ (∀a. LN ≠ LS a) ∧ (∀a1 a0. LN ≠ BN a0 a1) ∧
        (∀a2 a1 a0. LN ≠ BS a0 a1 a2) ∧ (∀a1 a0 a. LS a ≠ BN a0 a1) ∧
        (∀a2 a1 a0 a. LS a ≠ BS a0 a1 a2) ∧
        ∀a2 a1' a1 a0' a0. BN a0 a1 ≠ BS a0' a1' a2
   
   [<a name="spt_eq_thm-val"><b>spt_eq_thm</b></a>]  Theorem
      
      ⊢ ∀t1 t2. wf t1 ∧ wf t2 ⇒ ((t1 = t2) ⇔ ∀n. lookup n t1 = lookup n t2)
   
   [<a name="spt_induction-val"><b>spt_induction</b></a>]  Theorem
      
      ⊢ ∀P.
            P LN ∧ (∀a. P (LS a)) ∧ (∀s s0. P s ∧ P s0 ⇒ P (BN s s0)) ∧
            (∀s s0. P s ∧ P s0 ⇒ ∀a. P (BS s a s0)) ⇒
            ∀s. P s
   
   [<a name="spt_nchotomy-val"><b>spt_nchotomy</b></a>]  Theorem
      
      ⊢ ∀ss.
            isEmpty ss ∨ (∃a. ss = LS a) ∨ (∃s s0. ss = BN s s0) ∨
            ∃s a s0. ss = BS s a s0
   
   [<a name="subspt_LN-val"><b>subspt_LN</b></a>]  Theorem
      
      ⊢ (subspt LN sp ⇔ T) ∧ (subspt sp LN ⇔ (domain sp = ∅))
   
   [<a name="subspt_def-val"><b>subspt_def</b></a>]  Theorem
      
      ⊢ ∀sp1 sp2.
            subspt sp1 sp2 ⇔
            ∀k.
                k ∈ domain sp1 ⇒
                k ∈ domain sp2 ∧ (lookup k sp2 = lookup k sp1)
   
   [<a name="subspt_domain-val"><b>subspt_domain</b></a>]  Theorem
      
      ⊢ ∀t1 t2. subspt t1 t2 ⇔ domain t1 ⊆ domain t2
   
   [<a name="subspt_eq-val"><b>subspt_eq</b></a>]  Theorem
      
      ⊢ (∀t. subspt LN t ⇔ T) ∧
        (∀x t. subspt (LS x) t ⇔ (spt_center t = SOME x)) ∧
        (∀t1 t2 t.
             subspt (BN t1 t2) t ⇔
             subspt t1 (spt_left t) ∧ subspt t2 (spt_right t)) ∧
        ∀t1 x t2 t.
            subspt (BS t1 x t2) t ⇔
            (spt_center t = SOME x) ∧ subspt t1 (spt_left t) ∧
            subspt t2 (spt_right t)
   
   [<a name="subspt_lookup-val"><b>subspt_lookup</b></a>]  Theorem
      
      ⊢ ∀t1 t2.
            subspt t1 t2 ⇔
            ∀x y. (lookup x t1 = SOME y) ⇒ (lookup x t2 = SOME y)
   
   [<a name="subspt_refl-val"><b>subspt_refl</b></a>]  Theorem
      
      ⊢ subspt sp sp
   
   [<a name="subspt_trans-val"><b>subspt_trans</b></a>]  Theorem
      
      ⊢ subspt sp1 sp2 ∧ subspt sp2 sp3 ⇒ subspt sp1 sp3
   
   [<a name="toListA_append-val"><b>toListA_append</b></a>]  Theorem
      
      ⊢ ∀t acc. toListA acc t = toListA [] t ⧺ acc
   
   [<a name="toList_map-val"><b>toList_map</b></a>]  Theorem
      
      ⊢ ∀s. toList (map f s) = MAP f (toList s)
   
   [<a name="union_LN-val"><b>union_LN</b></a>]  Theorem
      
      ⊢ ∀t. (union t LN = t) ∧ (union LN t = t)
   
   [<a name="union_assoc-val"><b>union_assoc</b></a>]  Theorem
      
      ⊢ ∀t1 t2 t3. union t1 (union t2 t3) = union (union t1 t2) t3
   
   [<a name="union_mk_wf-val"><b>union_mk_wf</b></a>]  Theorem
      
      ⊢ ∀t1 t2. inter (mk_wf t1) (mk_wf t2) = mk_wf (inter t1 t2)
   
   [<a name="union_num_set_sym-val"><b>union_num_set_sym</b></a>]  Theorem
      
      ⊢ ∀t1 t2. union t1 t2 = union t2 t1
   
   [<a name="wf_delete-val"><b>wf_delete</b></a>]  Theorem
      
      ⊢ ∀t k. wf t ⇒ wf (delete k t)
   
   [<a name="wf_difference-val"><b>wf_difference</b></a>]  Theorem
      
      ⊢ ∀t1 t2. wf t1 ∧ wf t2 ⇒ wf (difference t1 t2)
   
   [<a name="wf_filter_v-val"><b>wf_filter_v</b></a>]  Theorem
      
      ⊢ ∀t f. wf t ⇒ wf (filter_v f t)
   
   [<a name="wf_fromAList-val"><b>wf_fromAList</b></a>]  Theorem
      
      ⊢ ∀ls. wf (fromAList ls)
   
   [<a name="wf_insert-val"><b>wf_insert</b></a>]  Theorem
      
      ⊢ ∀k a t. wf t ⇒ wf (insert k a t)
   
   [<a name="wf_inter-val"><b>wf_inter</b></a>]  Theorem
      
      ⊢ ∀m1 m2. wf (inter m1 m2)
   
   [<a name="wf_map-val"><b>wf_map</b></a>]  Theorem
      
      ⊢ ∀t f. wf (map f t) ⇔ wf t
   
   [<a name="wf_mapi-val"><b>wf_mapi</b></a>]  Theorem
      
      ⊢ wf (mapi f pt)
   
   [<a name="wf_mk_BN-val"><b>wf_mk_BN</b></a>]  Theorem
      
      ⊢ wf t1 ∧ wf t2 ⇒ wf (mk_BN t1 t2)
   
   [<a name="wf_mk_BS-val"><b>wf_mk_BS</b></a>]  Theorem
      
      ⊢ wf t1 ∧ wf t2 ⇒ wf (mk_BS t1 a t2)
   
   [<a name="wf_mk_id-val"><b>wf_mk_id</b></a>]  Theorem
      
      ⊢ ∀t. wf t ⇒ (mk_wf t = t)
   
   [<a name="wf_mk_wf-val"><b>wf_mk_wf</b></a>]  Theorem
      
      ⊢ ∀t. wf (mk_wf t)
   
   [<a name="wf_union-val"><b>wf_union</b></a>]  Theorem
      
      ⊢ ∀m1 m2. wf m1 ∧ wf m2 ⇒ wf (union m1 m2)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/patricia/sptreeScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-11</a></em></p></body></html>
