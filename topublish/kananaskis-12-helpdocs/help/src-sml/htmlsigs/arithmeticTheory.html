<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure arithmeticTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure arithmeticTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/num/theories/arithmeticScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature arithmeticTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#ABS_DIFF_def-val">ABS_DIFF_def</a> : thm
<a name="line7"></a>    val <a href="#ADD-val">ADD</a> : thm
<a name="line8"></a>    val <a href="#ALT_ZERO-val">ALT_ZERO</a> : thm
<a name="line9"></a>    val <a href="#BIT1-val">BIT1</a> : thm
<a name="line10"></a>    val <a href="#BIT2-val">BIT2</a> : thm
<a name="line11"></a>    val <a href="#DIV2_def-val">DIV2_def</a> : thm
<a name="line12"></a>    val <a href="#DIVISION-val">DIVISION</a> : thm
<a name="line13"></a>    val <a href="#DIVMOD_DEF-val">DIVMOD_DEF</a> : thm
<a name="line14"></a>    val <a href="#EVEN-val">EVEN</a> : thm
<a name="line15"></a>    val <a href="#EXP-val">EXP</a> : thm
<a name="line16"></a>    val <a href="#FACT-val">FACT</a> : thm
<a name="line17"></a>    val <a href="#FUNPOW-val">FUNPOW</a> : thm
<a name="line18"></a>    val <a href="#GREATER_DEF-val">GREATER_DEF</a> : thm
<a name="line19"></a>    val <a href="#GREATER_OR_EQ-val">GREATER_OR_EQ</a> : thm
<a name="line20"></a>    val <a href="#LESS_OR_EQ-val">LESS_OR_EQ</a> : thm
<a name="line21"></a>    val <a href="#MAX_DEF-val">MAX_DEF</a> : thm
<a name="line22"></a>    val <a href="#MIN_DEF-val">MIN_DEF</a> : thm
<a name="line23"></a>    val <a href="#MODEQ_DEF-val">MODEQ_DEF</a> : thm
<a name="line24"></a>    val <a href="#MULT-val">MULT</a> : thm
<a name="line25"></a>    val <a href="#NRC-val">NRC</a> : thm
<a name="line26"></a>    val <a href="#NUMERAL_DEF-val">NUMERAL_DEF</a> : thm
<a name="line27"></a>    val <a href="#ODD-val">ODD</a> : thm
<a name="line28"></a>    val <a href="#SUB-val">SUB</a> : thm
<a name="line29"></a>    val <a href="#findq_def-val">findq_def</a> : thm
<a name="line30"></a>    val <a href="#nat_elim__magic-val">nat_elim__magic</a> : thm
<a name="line31"></a>    val <a href="#num_case_def-val">num_case_def</a> : thm
<a name="line32"></a>  
<a name="line33"></a>  (*  Theorems  *)
<a name="line34"></a>    val <a href="#ABS_DIFF_ADD_SAME-val">ABS_DIFF_ADD_SAME</a> : thm
<a name="line35"></a>    val <a href="#ABS_DIFF_COMM-val">ABS_DIFF_COMM</a> : thm
<a name="line36"></a>    val <a href="#ABS_DIFF_EQS-val">ABS_DIFF_EQS</a> : thm
<a name="line37"></a>    val <a href="#ABS_DIFF_EQ_0-val">ABS_DIFF_EQ_0</a> : thm
<a name="line38"></a>    val <a href="#ABS_DIFF_LE_SUM-val">ABS_DIFF_LE_SUM</a> : thm
<a name="line39"></a>    val <a href="#ABS_DIFF_PLUS_LE-val">ABS_DIFF_PLUS_LE</a> : thm
<a name="line40"></a>    val <a href="#ABS_DIFF_SUC-val">ABS_DIFF_SUC</a> : thm
<a name="line41"></a>    val <a href="#ABS_DIFF_SUC_LE-val">ABS_DIFF_SUC_LE</a> : thm
<a name="line42"></a>    val <a href="#ABS_DIFF_SUMS-val">ABS_DIFF_SUMS</a> : thm
<a name="line43"></a>    val <a href="#ABS_DIFF_SYM-val">ABS_DIFF_SYM</a> : thm
<a name="line44"></a>    val <a href="#ABS_DIFF_TRIANGLE-val">ABS_DIFF_TRIANGLE</a> : thm
<a name="line45"></a>    val <a href="#ABS_DIFF_TRIANGLE_lem-val">ABS_DIFF_TRIANGLE_lem</a> : thm
<a name="line46"></a>    val <a href="#ABS_DIFF_ZERO-val">ABS_DIFF_ZERO</a> : thm
<a name="line47"></a>    val <a href="#ADD1-val">ADD1</a> : thm
<a name="line48"></a>    val <a href="#ADD_0-val">ADD_0</a> : thm
<a name="line49"></a>    val <a href="#ADD_ASSOC-val">ADD_ASSOC</a> : thm
<a name="line50"></a>    val <a href="#ADD_CLAUSES-val">ADD_CLAUSES</a> : thm
<a name="line51"></a>    val <a href="#ADD_COMM-val">ADD_COMM</a> : thm
<a name="line52"></a>    val <a href="#ADD_DIV_ADD_DIV-val">ADD_DIV_ADD_DIV</a> : thm
<a name="line53"></a>    val <a href="#ADD_DIV_RWT-val">ADD_DIV_RWT</a> : thm
<a name="line54"></a>    val <a href="#ADD_EQ_0-val">ADD_EQ_0</a> : thm
<a name="line55"></a>    val <a href="#ADD_EQ_1-val">ADD_EQ_1</a> : thm
<a name="line56"></a>    val <a href="#ADD_EQ_SUB-val">ADD_EQ_SUB</a> : thm
<a name="line57"></a>    val <a href="#ADD_INV_0-val">ADD_INV_0</a> : thm
<a name="line58"></a>    val <a href="#ADD_INV_0_EQ-val">ADD_INV_0_EQ</a> : thm
<a name="line59"></a>    val <a href="#ADD_MOD-val">ADD_MOD</a> : thm
<a name="line60"></a>    val <a href="#ADD_MODULUS-val">ADD_MODULUS</a> : thm
<a name="line61"></a>    val <a href="#ADD_MODULUS_LEFT-val">ADD_MODULUS_LEFT</a> : thm
<a name="line62"></a>    val <a href="#ADD_MODULUS_RIGHT-val">ADD_MODULUS_RIGHT</a> : thm
<a name="line63"></a>    val <a href="#ADD_MONO_LESS_EQ-val">ADD_MONO_LESS_EQ</a> : thm
<a name="line64"></a>    val <a href="#ADD_SUB-val">ADD_SUB</a> : thm
<a name="line65"></a>    val <a href="#ADD_SUC-val">ADD_SUC</a> : thm
<a name="line66"></a>    val <a href="#ADD_SYM-val">ADD_SYM</a> : thm
<a name="line67"></a>    val <a href="#BOUNDED_EXISTS_THM-val">BOUNDED_EXISTS_THM</a> : thm
<a name="line68"></a>    val <a href="#BOUNDED_FORALL_THM-val">BOUNDED_FORALL_THM</a> : thm
<a name="line69"></a>    val <a href="#CANCEL_SUB-val">CANCEL_SUB</a> : thm
<a name="line70"></a>    val <a href="#COMPLETE_INDUCTION-val">COMPLETE_INDUCTION</a> : thm
<a name="line71"></a>    val <a href="#DA-val">DA</a> : thm
<a name="line72"></a>    val <a href="#DIVMOD_CALC-val">DIVMOD_CALC</a> : thm
<a name="line73"></a>    val <a href="#DIVMOD_CORRECT-val">DIVMOD_CORRECT</a> : thm
<a name="line74"></a>    val <a href="#DIVMOD_ID-val">DIVMOD_ID</a> : thm
<a name="line75"></a>    val <a href="#DIVMOD_THM-val">DIVMOD_THM</a> : thm
<a name="line76"></a>    val <a href="#DIV_1-val">DIV_1</a> : thm
<a name="line77"></a>    val <a href="#DIV_DIV_DIV_MULT-val">DIV_DIV_DIV_MULT</a> : thm
<a name="line78"></a>    val <a href="#DIV_EQ_X-val">DIV_EQ_X</a> : thm
<a name="line79"></a>    val <a href="#DIV_LESS-val">DIV_LESS</a> : thm
<a name="line80"></a>    val <a href="#DIV_LESS_EQ-val">DIV_LESS_EQ</a> : thm
<a name="line81"></a>    val <a href="#DIV_LE_MONOTONE-val">DIV_LE_MONOTONE</a> : thm
<a name="line82"></a>    val <a href="#DIV_LE_X-val">DIV_LE_X</a> : thm
<a name="line83"></a>    val <a href="#DIV_LT_X-val">DIV_LT_X</a> : thm
<a name="line84"></a>    val <a href="#DIV_MOD_MOD_DIV-val">DIV_MOD_MOD_DIV</a> : thm
<a name="line85"></a>    val <a href="#DIV_MULT-val">DIV_MULT</a> : thm
<a name="line86"></a>    val <a href="#DIV_ONE-val">DIV_ONE</a> : thm
<a name="line87"></a>    val <a href="#DIV_P-val">DIV_P</a> : thm
<a name="line88"></a>    val <a href="#DIV_P_UNIV-val">DIV_P_UNIV</a> : thm
<a name="line89"></a>    val <a href="#DIV_SUB-val">DIV_SUB</a> : thm
<a name="line90"></a>    val <a href="#DIV_UNIQUE-val">DIV_UNIQUE</a> : thm
<a name="line91"></a>    val <a href="#DOUBLE_LT-val">DOUBLE_LT</a> : thm
<a name="line92"></a>    val <a href="#EQ_ADD_LCANCEL-val">EQ_ADD_LCANCEL</a> : thm
<a name="line93"></a>    val <a href="#EQ_ADD_RCANCEL-val">EQ_ADD_RCANCEL</a> : thm
<a name="line94"></a>    val <a href="#EQ_LESS_EQ-val">EQ_LESS_EQ</a> : thm
<a name="line95"></a>    val <a href="#EQ_MONO_ADD_EQ-val">EQ_MONO_ADD_EQ</a> : thm
<a name="line96"></a>    val <a href="#EQ_MULT_LCANCEL-val">EQ_MULT_LCANCEL</a> : thm
<a name="line97"></a>    val <a href="#EQ_MULT_RCANCEL-val">EQ_MULT_RCANCEL</a> : thm
<a name="line98"></a>    val <a href="#EVEN_ADD-val">EVEN_ADD</a> : thm
<a name="line99"></a>    val <a href="#EVEN_AND_ODD-val">EVEN_AND_ODD</a> : thm
<a name="line100"></a>    val <a href="#EVEN_DOUBLE-val">EVEN_DOUBLE</a> : thm
<a name="line101"></a>    val <a href="#EVEN_EXISTS-val">EVEN_EXISTS</a> : thm
<a name="line102"></a>    val <a href="#EVEN_EXP-val">EVEN_EXP</a> : thm
<a name="line103"></a>    val <a href="#EVEN_EXP_IFF-val">EVEN_EXP_IFF</a> : thm
<a name="line104"></a>    val <a href="#EVEN_MOD2-val">EVEN_MOD2</a> : thm
<a name="line105"></a>    val <a href="#EVEN_MULT-val">EVEN_MULT</a> : thm
<a name="line106"></a>    val <a href="#EVEN_ODD-val">EVEN_ODD</a> : thm
<a name="line107"></a>    val <a href="#EVEN_ODD_EXISTS-val">EVEN_ODD_EXISTS</a> : thm
<a name="line108"></a>    val <a href="#EVEN_OR_ODD-val">EVEN_OR_ODD</a> : thm
<a name="line109"></a>    val <a href="#EXISTS_GREATEST-val">EXISTS_GREATEST</a> : thm
<a name="line110"></a>    val <a href="#EXISTS_NUM-val">EXISTS_NUM</a> : thm
<a name="line111"></a>    val <a href="#EXP2_LT-val">EXP2_LT</a> : thm
<a name="line112"></a>    val <a href="#EXP_1-val">EXP_1</a> : thm
<a name="line113"></a>    val <a href="#EXP_ADD-val">EXP_ADD</a> : thm
<a name="line114"></a>    val <a href="#EXP_ALWAYS_BIG_ENOUGH-val">EXP_ALWAYS_BIG_ENOUGH</a> : thm
<a name="line115"></a>    val <a href="#EXP_BASE_INJECTIVE-val">EXP_BASE_INJECTIVE</a> : thm
<a name="line116"></a>    val <a href="#EXP_BASE_LEQ_MONO_IMP-val">EXP_BASE_LEQ_MONO_IMP</a> : thm
<a name="line117"></a>    val <a href="#EXP_BASE_LEQ_MONO_SUC_IMP-val">EXP_BASE_LEQ_MONO_SUC_IMP</a> : thm
<a name="line118"></a>    val <a href="#EXP_BASE_LE_IFF-val">EXP_BASE_LE_IFF</a> : thm
<a name="line119"></a>    val <a href="#EXP_BASE_LE_MONO-val">EXP_BASE_LE_MONO</a> : thm
<a name="line120"></a>    val <a href="#EXP_BASE_LT_MONO-val">EXP_BASE_LT_MONO</a> : thm
<a name="line121"></a>    val <a href="#EXP_BASE_MULT-val">EXP_BASE_MULT</a> : thm
<a name="line122"></a>    val <a href="#EXP_EQ_0-val">EXP_EQ_0</a> : thm
<a name="line123"></a>    val <a href="#EXP_EQ_1-val">EXP_EQ_1</a> : thm
<a name="line124"></a>    val <a href="#EXP_EXP_INJECTIVE-val">EXP_EXP_INJECTIVE</a> : thm
<a name="line125"></a>    val <a href="#EXP_EXP_LE_MONO-val">EXP_EXP_LE_MONO</a> : thm
<a name="line126"></a>    val <a href="#EXP_EXP_LT_MONO-val">EXP_EXP_LT_MONO</a> : thm
<a name="line127"></a>    val <a href="#EXP_EXP_MULT-val">EXP_EXP_MULT</a> : thm
<a name="line128"></a>    val <a href="#EXP_MOD-val">EXP_MOD</a> : thm
<a name="line129"></a>    val <a href="#EXP_SUB-val">EXP_SUB</a> : thm
<a name="line130"></a>    val <a href="#EXP_SUB_NUMERAL-val">EXP_SUB_NUMERAL</a> : thm
<a name="line131"></a>    val <a href="#FACT_LESS-val">FACT_LESS</a> : thm
<a name="line132"></a>    val <a href="#FORALL_NUM-val">FORALL_NUM</a> : thm
<a name="line133"></a>    val <a href="#FORALL_NUM_THM-val">FORALL_NUM_THM</a> : thm
<a name="line134"></a>    val <a href="#FUNPOW_0-val">FUNPOW_0</a> : thm
<a name="line135"></a>    val <a href="#FUNPOW_1-val">FUNPOW_1</a> : thm
<a name="line136"></a>    val <a href="#FUNPOW_ADD-val">FUNPOW_ADD</a> : thm
<a name="line137"></a>    val <a href="#FUNPOW_SUC-val">FUNPOW_SUC</a> : thm
<a name="line138"></a>    val <a href="#GREATER_EQ-val">GREATER_EQ</a> : thm
<a name="line139"></a>    val <a href="#INV_PRE_EQ-val">INV_PRE_EQ</a> : thm
<a name="line140"></a>    val <a href="#INV_PRE_LESS-val">INV_PRE_LESS</a> : thm
<a name="line141"></a>    val <a href="#INV_PRE_LESS_EQ-val">INV_PRE_LESS_EQ</a> : thm
<a name="line142"></a>    val <a href="#LE-val">LE</a> : thm
<a name="line143"></a>    val <a href="#LEFT_ADD_DISTRIB-val">LEFT_ADD_DISTRIB</a> : thm
<a name="line144"></a>    val <a href="#LEFT_SUB_DISTRIB-val">LEFT_SUB_DISTRIB</a> : thm
<a name="line145"></a>    val <a href="#LESS_0_CASES-val">LESS_0_CASES</a> : thm
<a name="line146"></a>    val <a href="#LESS_ADD-val">LESS_ADD</a> : thm
<a name="line147"></a>    val <a href="#LESS_ADD_1-val">LESS_ADD_1</a> : thm
<a name="line148"></a>    val <a href="#LESS_ADD_NONZERO-val">LESS_ADD_NONZERO</a> : thm
<a name="line149"></a>    val <a href="#LESS_ADD_SUC-val">LESS_ADD_SUC</a> : thm
<a name="line150"></a>    val <a href="#LESS_ANTISYM-val">LESS_ANTISYM</a> : thm
<a name="line151"></a>    val <a href="#LESS_CASES-val">LESS_CASES</a> : thm
<a name="line152"></a>    val <a href="#LESS_CASES_IMP-val">LESS_CASES_IMP</a> : thm
<a name="line153"></a>    val <a href="#LESS_DIV_EQ_ZERO-val">LESS_DIV_EQ_ZERO</a> : thm
<a name="line154"></a>    val <a href="#LESS_EQ-val">LESS_EQ</a> : thm
<a name="line155"></a>    val <a href="#LESS_EQUAL_ADD-val">LESS_EQUAL_ADD</a> : thm
<a name="line156"></a>    val <a href="#LESS_EQUAL_ANTISYM-val">LESS_EQUAL_ANTISYM</a> : thm
<a name="line157"></a>    val <a href="#LESS_EQUAL_DIFF-val">LESS_EQUAL_DIFF</a> : thm
<a name="line158"></a>    val <a href="#LESS_EQ_0-val">LESS_EQ_0</a> : thm
<a name="line159"></a>    val <a href="#LESS_EQ_ADD-val">LESS_EQ_ADD</a> : thm
<a name="line160"></a>    val <a href="#LESS_EQ_ADD_EXISTS-val">LESS_EQ_ADD_EXISTS</a> : thm
<a name="line161"></a>    val <a href="#LESS_EQ_ADD_SUB-val">LESS_EQ_ADD_SUB</a> : thm
<a name="line162"></a>    val <a href="#LESS_EQ_ANTISYM-val">LESS_EQ_ANTISYM</a> : thm
<a name="line163"></a>    val <a href="#LESS_EQ_CASES-val">LESS_EQ_CASES</a> : thm
<a name="line164"></a>    val <a href="#LESS_EQ_EXISTS-val">LESS_EQ_EXISTS</a> : thm
<a name="line165"></a>    val <a href="#LESS_EQ_IFF_LESS_SUC-val">LESS_EQ_IFF_LESS_SUC</a> : thm
<a name="line166"></a>    val <a href="#LESS_EQ_IMP_LESS_SUC-val">LESS_EQ_IMP_LESS_SUC</a> : thm
<a name="line167"></a>    val <a href="#LESS_EQ_LESS_EQ_MONO-val">LESS_EQ_LESS_EQ_MONO</a> : thm
<a name="line168"></a>    val <a href="#LESS_EQ_LESS_TRANS-val">LESS_EQ_LESS_TRANS</a> : thm
<a name="line169"></a>    val <a href="#LESS_EQ_MONO-val">LESS_EQ_MONO</a> : thm
<a name="line170"></a>    val <a href="#LESS_EQ_MONO_ADD_EQ-val">LESS_EQ_MONO_ADD_EQ</a> : thm
<a name="line171"></a>    val <a href="#LESS_EQ_REFL-val">LESS_EQ_REFL</a> : thm
<a name="line172"></a>    val <a href="#LESS_EQ_SUB_LESS-val">LESS_EQ_SUB_LESS</a> : thm
<a name="line173"></a>    val <a href="#LESS_EQ_SUC_REFL-val">LESS_EQ_SUC_REFL</a> : thm
<a name="line174"></a>    val <a href="#LESS_EQ_TRANS-val">LESS_EQ_TRANS</a> : thm
<a name="line175"></a>    val <a href="#LESS_EXP_SUC_MONO-val">LESS_EXP_SUC_MONO</a> : thm
<a name="line176"></a>    val <a href="#LESS_IMP_LESS_ADD-val">LESS_IMP_LESS_ADD</a> : thm
<a name="line177"></a>    val <a href="#LESS_IMP_LESS_OR_EQ-val">LESS_IMP_LESS_OR_EQ</a> : thm
<a name="line178"></a>    val <a href="#LESS_LESS_CASES-val">LESS_LESS_CASES</a> : thm
<a name="line179"></a>    val <a href="#LESS_LESS_EQ_TRANS-val">LESS_LESS_EQ_TRANS</a> : thm
<a name="line180"></a>    val <a href="#LESS_LESS_SUC-val">LESS_LESS_SUC</a> : thm
<a name="line181"></a>    val <a href="#LESS_MOD-val">LESS_MOD</a> : thm
<a name="line182"></a>    val <a href="#LESS_MONO_ADD-val">LESS_MONO_ADD</a> : thm
<a name="line183"></a>    val <a href="#LESS_MONO_ADD_EQ-val">LESS_MONO_ADD_EQ</a> : thm
<a name="line184"></a>    val <a href="#LESS_MONO_ADD_INV-val">LESS_MONO_ADD_INV</a> : thm
<a name="line185"></a>    val <a href="#LESS_MONO_EQ-val">LESS_MONO_EQ</a> : thm
<a name="line186"></a>    val <a href="#LESS_MONO_MULT-val">LESS_MONO_MULT</a> : thm
<a name="line187"></a>    val <a href="#LESS_MONO_MULT2-val">LESS_MONO_MULT2</a> : thm
<a name="line188"></a>    val <a href="#LESS_MONO_REV-val">LESS_MONO_REV</a> : thm
<a name="line189"></a>    val <a href="#LESS_MULT2-val">LESS_MULT2</a> : thm
<a name="line190"></a>    val <a href="#LESS_MULT_MONO-val">LESS_MULT_MONO</a> : thm
<a name="line191"></a>    val <a href="#LESS_NOT_SUC-val">LESS_NOT_SUC</a> : thm
<a name="line192"></a>    val <a href="#LESS_OR-val">LESS_OR</a> : thm
<a name="line193"></a>    val <a href="#LESS_OR_EQ_ADD-val">LESS_OR_EQ_ADD</a> : thm
<a name="line194"></a>    val <a href="#LESS_OR_EQ_ALT-val">LESS_OR_EQ_ALT</a> : thm
<a name="line195"></a>    val <a href="#LESS_STRONG_ADD-val">LESS_STRONG_ADD</a> : thm
<a name="line196"></a>    val <a href="#LESS_SUB_ADD_LESS-val">LESS_SUB_ADD_LESS</a> : thm
<a name="line197"></a>    val <a href="#LESS_SUC_EQ_COR-val">LESS_SUC_EQ_COR</a> : thm
<a name="line198"></a>    val <a href="#LESS_SUC_NOT-val">LESS_SUC_NOT</a> : thm
<a name="line199"></a>    val <a href="#LESS_TRANS-val">LESS_TRANS</a> : thm
<a name="line200"></a>    val <a href="#LE_ADD_LCANCEL-val">LE_ADD_LCANCEL</a> : thm
<a name="line201"></a>    val <a href="#LE_ADD_RCANCEL-val">LE_ADD_RCANCEL</a> : thm
<a name="line202"></a>    val <a href="#LE_LT1-val">LE_LT1</a> : thm
<a name="line203"></a>    val <a href="#LE_MULT_CANCEL_LBARE-val">LE_MULT_CANCEL_LBARE</a> : thm
<a name="line204"></a>    val <a href="#LE_MULT_CANCEL_RBARE-val">LE_MULT_CANCEL_RBARE</a> : thm
<a name="line205"></a>    val <a href="#LE_MULT_LCANCEL-val">LE_MULT_LCANCEL</a> : thm
<a name="line206"></a>    val <a href="#LE_MULT_RCANCEL-val">LE_MULT_RCANCEL</a> : thm
<a name="line207"></a>    val <a href="#LE_SUB_LCANCEL-val">LE_SUB_LCANCEL</a> : thm
<a name="line208"></a>    val <a href="#LE_SUB_RCANCEL-val">LE_SUB_RCANCEL</a> : thm
<a name="line209"></a>    val <a href="#LT_ADD_LCANCEL-val">LT_ADD_LCANCEL</a> : thm
<a name="line210"></a>    val <a href="#LT_ADD_RCANCEL-val">LT_ADD_RCANCEL</a> : thm
<a name="line211"></a>    val <a href="#LT_MULT_CANCEL_LBARE-val">LT_MULT_CANCEL_LBARE</a> : thm
<a name="line212"></a>    val <a href="#LT_MULT_CANCEL_RBARE-val">LT_MULT_CANCEL_RBARE</a> : thm
<a name="line213"></a>    val <a href="#LT_MULT_LCANCEL-val">LT_MULT_LCANCEL</a> : thm
<a name="line214"></a>    val <a href="#LT_MULT_RCANCEL-val">LT_MULT_RCANCEL</a> : thm
<a name="line215"></a>    val <a href="#LT_SUB_LCANCEL-val">LT_SUB_LCANCEL</a> : thm
<a name="line216"></a>    val <a href="#LT_SUB_RCANCEL-val">LT_SUB_RCANCEL</a> : thm
<a name="line217"></a>    val <a href="#MAX_0-val">MAX_0</a> : thm
<a name="line218"></a>    val <a href="#MAX_ASSOC-val">MAX_ASSOC</a> : thm
<a name="line219"></a>    val <a href="#MAX_COMM-val">MAX_COMM</a> : thm
<a name="line220"></a>    val <a href="#MAX_EQ_0-val">MAX_EQ_0</a> : thm
<a name="line221"></a>    val <a href="#MAX_IDEM-val">MAX_IDEM</a> : thm
<a name="line222"></a>    val <a href="#MAX_LE-val">MAX_LE</a> : thm
<a name="line223"></a>    val <a href="#MAX_LT-val">MAX_LT</a> : thm
<a name="line224"></a>    val <a href="#MIN_0-val">MIN_0</a> : thm
<a name="line225"></a>    val <a href="#MIN_ASSOC-val">MIN_ASSOC</a> : thm
<a name="line226"></a>    val <a href="#MIN_COMM-val">MIN_COMM</a> : thm
<a name="line227"></a>    val <a href="#MIN_EQ_0-val">MIN_EQ_0</a> : thm
<a name="line228"></a>    val <a href="#MIN_IDEM-val">MIN_IDEM</a> : thm
<a name="line229"></a>    val <a href="#MIN_LE-val">MIN_LE</a> : thm
<a name="line230"></a>    val <a href="#MIN_LT-val">MIN_LT</a> : thm
<a name="line231"></a>    val <a href="#MIN_MAX_EQ-val">MIN_MAX_EQ</a> : thm
<a name="line232"></a>    val <a href="#MIN_MAX_LE-val">MIN_MAX_LE</a> : thm
<a name="line233"></a>    val <a href="#MIN_MAX_LT-val">MIN_MAX_LT</a> : thm
<a name="line234"></a>    val <a href="#MIN_MAX_PRED-val">MIN_MAX_PRED</a> : thm
<a name="line235"></a>    val <a href="#MODEQ_0-val">MODEQ_0</a> : thm
<a name="line236"></a>    val <a href="#MODEQ_0_CONG-val">MODEQ_0_CONG</a> : thm
<a name="line237"></a>    val <a href="#MODEQ_EXP_CONG-val">MODEQ_EXP_CONG</a> : thm
<a name="line238"></a>    val <a href="#MODEQ_INTRO_CONG-val">MODEQ_INTRO_CONG</a> : thm
<a name="line239"></a>    val <a href="#MODEQ_MOD-val">MODEQ_MOD</a> : thm
<a name="line240"></a>    val <a href="#MODEQ_MULT_CONG-val">MODEQ_MULT_CONG</a> : thm
<a name="line241"></a>    val <a href="#MODEQ_NONZERO_MODEQUALITY-val">MODEQ_NONZERO_MODEQUALITY</a> : thm
<a name="line242"></a>    val <a href="#MODEQ_NUMERAL-val">MODEQ_NUMERAL</a> : thm
<a name="line243"></a>    val <a href="#MODEQ_PLUS_CONG-val">MODEQ_PLUS_CONG</a> : thm
<a name="line244"></a>    val <a href="#MODEQ_REFL-val">MODEQ_REFL</a> : thm
<a name="line245"></a>    val <a href="#MODEQ_SUC_CONG-val">MODEQ_SUC_CONG</a> : thm
<a name="line246"></a>    val <a href="#MODEQ_SYM-val">MODEQ_SYM</a> : thm
<a name="line247"></a>    val <a href="#MODEQ_THM-val">MODEQ_THM</a> : thm
<a name="line248"></a>    val <a href="#MODEQ_TRANS-val">MODEQ_TRANS</a> : thm
<a name="line249"></a>    val <a href="#MOD_1-val">MOD_1</a> : thm
<a name="line250"></a>    val <a href="#MOD_2-val">MOD_2</a> : thm
<a name="line251"></a>    val <a href="#MOD_COMMON_FACTOR-val">MOD_COMMON_FACTOR</a> : thm
<a name="line252"></a>    val <a href="#MOD_ELIM-val">MOD_ELIM</a> : thm
<a name="line253"></a>    val <a href="#MOD_EQ_0-val">MOD_EQ_0</a> : thm
<a name="line254"></a>    val <a href="#MOD_EQ_0_DIVISOR-val">MOD_EQ_0_DIVISOR</a> : thm
<a name="line255"></a>    val <a href="#MOD_LESS-val">MOD_LESS</a> : thm
<a name="line256"></a>    val <a href="#MOD_LESS_EQ-val">MOD_LESS_EQ</a> : thm
<a name="line257"></a>    val <a href="#MOD_LIFT_PLUS-val">MOD_LIFT_PLUS</a> : thm
<a name="line258"></a>    val <a href="#MOD_LIFT_PLUS_IFF-val">MOD_LIFT_PLUS_IFF</a> : thm
<a name="line259"></a>    val <a href="#MOD_MOD-val">MOD_MOD</a> : thm
<a name="line260"></a>    val <a href="#MOD_MULT-val">MOD_MULT</a> : thm
<a name="line261"></a>    val <a href="#MOD_MULT_MOD-val">MOD_MULT_MOD</a> : thm
<a name="line262"></a>    val <a href="#MOD_ONE-val">MOD_ONE</a> : thm
<a name="line263"></a>    val <a href="#MOD_P-val">MOD_P</a> : thm
<a name="line264"></a>    val <a href="#MOD_PLUS-val">MOD_PLUS</a> : thm
<a name="line265"></a>    val <a href="#MOD_P_UNIV-val">MOD_P_UNIV</a> : thm
<a name="line266"></a>    val <a href="#MOD_SUB-val">MOD_SUB</a> : thm
<a name="line267"></a>    val <a href="#MOD_SUC-val">MOD_SUC</a> : thm
<a name="line268"></a>    val <a href="#MOD_SUC_IFF-val">MOD_SUC_IFF</a> : thm
<a name="line269"></a>    val <a href="#MOD_TIMES-val">MOD_TIMES</a> : thm
<a name="line270"></a>    val <a href="#MOD_TIMES2-val">MOD_TIMES2</a> : thm
<a name="line271"></a>    val <a href="#MOD_TIMES_SUB-val">MOD_TIMES_SUB</a> : thm
<a name="line272"></a>    val <a href="#MOD_UNIQUE-val">MOD_UNIQUE</a> : thm
<a name="line273"></a>    val <a href="#MULT_0-val">MULT_0</a> : thm
<a name="line274"></a>    val <a href="#MULT_ASSOC-val">MULT_ASSOC</a> : thm
<a name="line275"></a>    val <a href="#MULT_CLAUSES-val">MULT_CLAUSES</a> : thm
<a name="line276"></a>    val <a href="#MULT_COMM-val">MULT_COMM</a> : thm
<a name="line277"></a>    val <a href="#MULT_DIV-val">MULT_DIV</a> : thm
<a name="line278"></a>    val <a href="#MULT_EQ_0-val">MULT_EQ_0</a> : thm
<a name="line279"></a>    val <a href="#MULT_EQ_1-val">MULT_EQ_1</a> : thm
<a name="line280"></a>    val <a href="#MULT_EQ_DIV-val">MULT_EQ_DIV</a> : thm
<a name="line281"></a>    val <a href="#MULT_EQ_ID-val">MULT_EQ_ID</a> : thm
<a name="line282"></a>    val <a href="#MULT_EXP_MONO-val">MULT_EXP_MONO</a> : thm
<a name="line283"></a>    val <a href="#MULT_INCREASES-val">MULT_INCREASES</a> : thm
<a name="line284"></a>    val <a href="#MULT_LEFT_1-val">MULT_LEFT_1</a> : thm
<a name="line285"></a>    val <a href="#MULT_LESS_EQ_SUC-val">MULT_LESS_EQ_SUC</a> : thm
<a name="line286"></a>    val <a href="#MULT_MONO_EQ-val">MULT_MONO_EQ</a> : thm
<a name="line287"></a>    val <a href="#MULT_RIGHT_1-val">MULT_RIGHT_1</a> : thm
<a name="line288"></a>    val <a href="#MULT_SUC-val">MULT_SUC</a> : thm
<a name="line289"></a>    val <a href="#MULT_SUC_EQ-val">MULT_SUC_EQ</a> : thm
<a name="line290"></a>    val <a href="#MULT_SYM-val">MULT_SYM</a> : thm
<a name="line291"></a>    val <a href="#NORM_0-val">NORM_0</a> : thm
<a name="line292"></a>    val <a href="#NOT_EXP_0-val">NOT_EXP_0</a> : thm
<a name="line293"></a>    val <a href="#NOT_GREATER-val">NOT_GREATER</a> : thm
<a name="line294"></a>    val <a href="#NOT_GREATER_EQ-val">NOT_GREATER_EQ</a> : thm
<a name="line295"></a>    val <a href="#NOT_LEQ-val">NOT_LEQ</a> : thm
<a name="line296"></a>    val <a href="#NOT_LESS-val">NOT_LESS</a> : thm
<a name="line297"></a>    val <a href="#NOT_LESS_EQUAL-val">NOT_LESS_EQUAL</a> : thm
<a name="line298"></a>    val <a href="#NOT_LT_ZERO_EQ_ZERO-val">NOT_LT_ZERO_EQ_ZERO</a> : thm
<a name="line299"></a>    val <a href="#NOT_NUM_EQ-val">NOT_NUM_EQ</a> : thm
<a name="line300"></a>    val <a href="#NOT_ODD_EQ_EVEN-val">NOT_ODD_EQ_EVEN</a> : thm
<a name="line301"></a>    val <a href="#NOT_STRICTLY_DECREASING-val">NOT_STRICTLY_DECREASING</a> : thm
<a name="line302"></a>    val <a href="#NOT_SUC_ADD_LESS_EQ-val">NOT_SUC_ADD_LESS_EQ</a> : thm
<a name="line303"></a>    val <a href="#NOT_SUC_LESS_EQ-val">NOT_SUC_LESS_EQ</a> : thm
<a name="line304"></a>    val <a href="#NOT_SUC_LESS_EQ_0-val">NOT_SUC_LESS_EQ_0</a> : thm
<a name="line305"></a>    val <a href="#NOT_ZERO_LT_ZERO-val">NOT_ZERO_LT_ZERO</a> : thm
<a name="line306"></a>    val <a href="#NRC_0-val">NRC_0</a> : thm
<a name="line307"></a>    val <a href="#NRC_1-val">NRC_1</a> : thm
<a name="line308"></a>    val <a href="#NRC_ADD_E-val">NRC_ADD_E</a> : thm
<a name="line309"></a>    val <a href="#NRC_ADD_EQN-val">NRC_ADD_EQN</a> : thm
<a name="line310"></a>    val <a href="#NRC_ADD_I-val">NRC_ADD_I</a> : thm
<a name="line311"></a>    val <a href="#NRC_RTC-val">NRC_RTC</a> : thm
<a name="line312"></a>    val <a href="#NRC_SUC_RECURSE_LEFT-val">NRC_SUC_RECURSE_LEFT</a> : thm
<a name="line313"></a>    val <a href="#NUMERAL_MULT_EQ_DIV-val">NUMERAL_MULT_EQ_DIV</a> : thm
<a name="line314"></a>    val <a href="#ODD_ADD-val">ODD_ADD</a> : thm
<a name="line315"></a>    val <a href="#ODD_DOUBLE-val">ODD_DOUBLE</a> : thm
<a name="line316"></a>    val <a href="#ODD_EVEN-val">ODD_EVEN</a> : thm
<a name="line317"></a>    val <a href="#ODD_EXISTS-val">ODD_EXISTS</a> : thm
<a name="line318"></a>    val <a href="#ODD_EXP-val">ODD_EXP</a> : thm
<a name="line319"></a>    val <a href="#ODD_EXP_IFF-val">ODD_EXP_IFF</a> : thm
<a name="line320"></a>    val <a href="#ODD_MULT-val">ODD_MULT</a> : thm
<a name="line321"></a>    val <a href="#ODD_OR_EVEN-val">ODD_OR_EVEN</a> : thm
<a name="line322"></a>    val <a href="#ONE-val">ONE</a> : thm
<a name="line323"></a>    val <a href="#ONE_LT_EXP-val">ONE_LT_EXP</a> : thm
<a name="line324"></a>    val <a href="#ONE_LT_MULT-val">ONE_LT_MULT</a> : thm
<a name="line325"></a>    val <a href="#ONE_LT_MULT_IMP-val">ONE_LT_MULT_IMP</a> : thm
<a name="line326"></a>    val <a href="#ONE_MOD-val">ONE_MOD</a> : thm
<a name="line327"></a>    val <a href="#ONE_MOD_IFF-val">ONE_MOD_IFF</a> : thm
<a name="line328"></a>    val <a href="#ONE_ONE_INV_IMAGE_BOUNDED-val">ONE_ONE_INV_IMAGE_BOUNDED</a> : thm
<a name="line329"></a>    val <a href="#ONE_ONE_UNBOUNDED-val">ONE_ONE_UNBOUNDED</a> : thm
<a name="line330"></a>    val <a href="#OR_LESS-val">OR_LESS</a> : thm
<a name="line331"></a>    val <a href="#PRE_ELIM_THM-val">PRE_ELIM_THM</a> : thm
<a name="line332"></a>    val <a href="#PRE_LESS_EQ-val">PRE_LESS_EQ</a> : thm
<a name="line333"></a>    val <a href="#PRE_SUB-val">PRE_SUB</a> : thm
<a name="line334"></a>    val <a href="#PRE_SUB1-val">PRE_SUB1</a> : thm
<a name="line335"></a>    val <a href="#PRE_SUC_EQ-val">PRE_SUC_EQ</a> : thm
<a name="line336"></a>    val <a href="#RIGHT_ADD_DISTRIB-val">RIGHT_ADD_DISTRIB</a> : thm
<a name="line337"></a>    val <a href="#RIGHT_SUB_DISTRIB-val">RIGHT_SUB_DISTRIB</a> : thm
<a name="line338"></a>    val <a href="#RTC_NRC-val">RTC_NRC</a> : thm
<a name="line339"></a>    val <a href="#RTC_eq_NRC-val">RTC_eq_NRC</a> : thm
<a name="line340"></a>    val <a href="#STRICTLY_INCREASING_ONE_ONE-val">STRICTLY_INCREASING_ONE_ONE</a> : thm
<a name="line341"></a>    val <a href="#STRICTLY_INCREASING_TC-val">STRICTLY_INCREASING_TC</a> : thm
<a name="line342"></a>    val <a href="#STRICTLY_INCREASING_UNBOUNDED-val">STRICTLY_INCREASING_UNBOUNDED</a> : thm
<a name="line343"></a>    val <a href="#SUB_0-val">SUB_0</a> : thm
<a name="line344"></a>    val <a href="#SUB_ADD-val">SUB_ADD</a> : thm
<a name="line345"></a>    val <a href="#SUB_CANCEL-val">SUB_CANCEL</a> : thm
<a name="line346"></a>    val <a href="#SUB_ELIM_THM-val">SUB_ELIM_THM</a> : thm
<a name="line347"></a>    val <a href="#SUB_EQUAL_0-val">SUB_EQUAL_0</a> : thm
<a name="line348"></a>    val <a href="#SUB_EQ_0-val">SUB_EQ_0</a> : thm
<a name="line349"></a>    val <a href="#SUB_EQ_EQ_0-val">SUB_EQ_EQ_0</a> : thm
<a name="line350"></a>    val <a href="#SUB_LEFT_ADD-val">SUB_LEFT_ADD</a> : thm
<a name="line351"></a>    val <a href="#SUB_LEFT_EQ-val">SUB_LEFT_EQ</a> : thm
<a name="line352"></a>    val <a href="#SUB_LEFT_GREATER-val">SUB_LEFT_GREATER</a> : thm
<a name="line353"></a>    val <a href="#SUB_LEFT_GREATER_EQ-val">SUB_LEFT_GREATER_EQ</a> : thm
<a name="line354"></a>    val <a href="#SUB_LEFT_LESS-val">SUB_LEFT_LESS</a> : thm
<a name="line355"></a>    val <a href="#SUB_LEFT_LESS_EQ-val">SUB_LEFT_LESS_EQ</a> : thm
<a name="line356"></a>    val <a href="#SUB_LEFT_SUB-val">SUB_LEFT_SUB</a> : thm
<a name="line357"></a>    val <a href="#SUB_LEFT_SUC-val">SUB_LEFT_SUC</a> : thm
<a name="line358"></a>    val <a href="#SUB_LESS-val">SUB_LESS</a> : thm
<a name="line359"></a>    val <a href="#SUB_LESS_0-val">SUB_LESS_0</a> : thm
<a name="line360"></a>    val <a href="#SUB_LESS_EQ-val">SUB_LESS_EQ</a> : thm
<a name="line361"></a>    val <a href="#SUB_LESS_EQ_ADD-val">SUB_LESS_EQ_ADD</a> : thm
<a name="line362"></a>    val <a href="#SUB_LESS_OR-val">SUB_LESS_OR</a> : thm
<a name="line363"></a>    val <a href="#SUB_LESS_SUC-val">SUB_LESS_SUC</a> : thm
<a name="line364"></a>    val <a href="#SUB_MOD-val">SUB_MOD</a> : thm
<a name="line365"></a>    val <a href="#SUB_MONO_EQ-val">SUB_MONO_EQ</a> : thm
<a name="line366"></a>    val <a href="#SUB_PLUS-val">SUB_PLUS</a> : thm
<a name="line367"></a>    val <a href="#SUB_RIGHT_ADD-val">SUB_RIGHT_ADD</a> : thm
<a name="line368"></a>    val <a href="#SUB_RIGHT_EQ-val">SUB_RIGHT_EQ</a> : thm
<a name="line369"></a>    val <a href="#SUB_RIGHT_GREATER-val">SUB_RIGHT_GREATER</a> : thm
<a name="line370"></a>    val <a href="#SUB_RIGHT_GREATER_EQ-val">SUB_RIGHT_GREATER_EQ</a> : thm
<a name="line371"></a>    val <a href="#SUB_RIGHT_LESS-val">SUB_RIGHT_LESS</a> : thm
<a name="line372"></a>    val <a href="#SUB_RIGHT_LESS_EQ-val">SUB_RIGHT_LESS_EQ</a> : thm
<a name="line373"></a>    val <a href="#SUB_RIGHT_SUB-val">SUB_RIGHT_SUB</a> : thm
<a name="line374"></a>    val <a href="#SUB_SUB-val">SUB_SUB</a> : thm
<a name="line375"></a>    val <a href="#SUC_ADD_SYM-val">SUC_ADD_SYM</a> : thm
<a name="line376"></a>    val <a href="#SUC_ELIM_NUMERALS-val">SUC_ELIM_NUMERALS</a> : thm
<a name="line377"></a>    val <a href="#SUC_ELIM_THM-val">SUC_ELIM_THM</a> : thm
<a name="line378"></a>    val <a href="#SUC_MOD-val">SUC_MOD</a> : thm
<a name="line379"></a>    val <a href="#SUC_NOT-val">SUC_NOT</a> : thm
<a name="line380"></a>    val <a href="#SUC_ONE_ADD-val">SUC_ONE_ADD</a> : thm
<a name="line381"></a>    val <a href="#SUC_PRE-val">SUC_PRE</a> : thm
<a name="line382"></a>    val <a href="#SUC_SUB-val">SUC_SUB</a> : thm
<a name="line383"></a>    val <a href="#SUC_SUB1-val">SUC_SUB1</a> : thm
<a name="line384"></a>    val <a href="#TC_eq_NRC-val">TC_eq_NRC</a> : thm
<a name="line385"></a>    val <a href="#TIMES2-val">TIMES2</a> : thm
<a name="line386"></a>    val <a href="#TWO-val">TWO</a> : thm
<a name="line387"></a>    val <a href="#WOP-val">WOP</a> : thm
<a name="line388"></a>    val <a href="#X_LE_DIV-val">X_LE_DIV</a> : thm
<a name="line389"></a>    val <a href="#X_LE_X_EXP-val">X_LE_X_EXP</a> : thm
<a name="line390"></a>    val <a href="#X_LT_DIV-val">X_LT_DIV</a> : thm
<a name="line391"></a>    val <a href="#X_LT_EXP_X-val">X_LT_EXP_X</a> : thm
<a name="line392"></a>    val <a href="#X_LT_EXP_X_IFF-val">X_LT_EXP_X_IFF</a> : thm
<a name="line393"></a>    val <a href="#X_MOD_Y_EQ_X-val">X_MOD_Y_EQ_X</a> : thm
<a name="line394"></a>    val <a href="#ZERO_DIV-val">ZERO_DIV</a> : thm
<a name="line395"></a>    val <a href="#ZERO_EXP-val">ZERO_EXP</a> : thm
<a name="line396"></a>    val <a href="#ZERO_LESS_ADD-val">ZERO_LESS_ADD</a> : thm
<a name="line397"></a>    val <a href="#ZERO_LESS_EQ-val">ZERO_LESS_EQ</a> : thm
<a name="line398"></a>    val <a href="#ZERO_LESS_EXP-val">ZERO_LESS_EXP</a> : thm
<a name="line399"></a>    val <a href="#ZERO_LESS_MULT-val">ZERO_LESS_MULT</a> : thm
<a name="line400"></a>    val <a href="#ZERO_LT_EXP-val">ZERO_LT_EXP</a> : thm
<a name="line401"></a>    val <a href="#ZERO_MOD-val">ZERO_MOD</a> : thm
<a name="line402"></a>    val <a href="#datatype_num-val">datatype_num</a> : thm
<a name="line403"></a>    val <a href="#findq_divisor-val">findq_divisor</a> : thm
<a name="line404"></a>    val <a href="#findq_eq_0-val">findq_eq_0</a> : thm
<a name="line405"></a>    val <a href="#findq_thm-val">findq_thm</a> : thm
<a name="line406"></a>    val <a href="#num_CASES-val">num_CASES</a> : thm
<a name="line407"></a>    val <a href="#num_case_compute-val">num_case_compute</a> : thm
<a name="line408"></a>    val <a href="#num_case_cong-val">num_case_cong</a> : thm
<a name="line409"></a>    val <a href="#num_case_eq-val">num_case_eq</a> : thm
<a name="line410"></a>    val <a href="#transitive_LESS-val">transitive_LESS</a> : thm
<a name="line411"></a>    val <a href="#transitive_measure-val">transitive_measure</a> : thm
<a name="line412"></a>    val <a href="#transitive_monotone-val">transitive_monotone</a> : thm
<a name="line413"></a>  
<a name="line414"></a>  val arithmetic_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line415"></a>(*
   [pair] Parent theory of "arithmetic"
   
   [prim_rec] Parent theory of "arithmetic"
   
   [<a name="ABS_DIFF_def-val"><b>ABS_DIFF_def</b></a>]  Definition
      
      ⊢ ∀n m. ABS_DIFF n m = if n &lt; m then m − n else n − m
   
   [<a name="ADD-val"><b>ADD</b></a>]  Definition
      
      ⊢ (∀n. 0 + n = n) ∧ ∀m n. SUC m + n = SUC (m + n)
   
   [<a name="ALT_ZERO-val"><b>ALT_ZERO</b></a>]  Definition
      
      ⊢ ZERO = 0
   
   [<a name="BIT1-val"><b>BIT1</b></a>]  Definition
      
      ⊢ ∀n. BIT1 n = n + (n + SUC 0)
   
   [<a name="BIT2-val"><b>BIT2</b></a>]  Definition
      
      ⊢ ∀n. BIT2 n = n + (n + SUC (SUC 0))
   
   [<a name="DIV2_def-val"><b>DIV2_def</b></a>]  Definition
      
      ⊢ ∀n. DIV2 n = n DIV 2
   
   [<a name="DIVISION-val"><b>DIVISION</b></a>]  Definition
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀k. (k = k DIV n * n + k MOD n) ∧ k MOD n &lt; n
   
   [<a name="DIVMOD_DEF-val"><b>DIVMOD_DEF</b></a>]  Definition
      
      ⊢ DIVMOD =
        WFREC (measure (FST ∘ SND))
          (λf (a,m,n).
               if n = 0 then (0,0)
               else if m &lt; n then (a,m)
               else (let q = findq (1,m,n) in f (a + q,m − n * q,n)))
   
   [<a name="EVEN-val"><b>EVEN</b></a>]  Definition
      
      ⊢ (EVEN 0 ⇔ T) ∧ ∀n. EVEN (SUC n) ⇔ ¬EVEN n
   
   [<a name="EXP-val"><b>EXP</b></a>]  Definition
      
      ⊢ (∀m. m ** 0 = 1) ∧ ∀m n. m ** SUC n = m * m ** n
   
   [<a name="FACT-val"><b>FACT</b></a>]  Definition
      
      ⊢ (FACT 0 = 1) ∧ ∀n. FACT (SUC n) = SUC n * FACT n
   
   [<a name="FUNPOW-val"><b>FUNPOW</b></a>]  Definition
      
      ⊢ (∀f x. FUNPOW f 0 x = x) ∧
        ∀f n x. FUNPOW f (SUC n) x = FUNPOW f n (f x)
   
   [<a name="GREATER_DEF-val"><b>GREATER_DEF</b></a>]  Definition
      
      ⊢ ∀m n. m &gt; n ⇔ n &lt; m
   
   [<a name="GREATER_OR_EQ-val"><b>GREATER_OR_EQ</b></a>]  Definition
      
      ⊢ ∀m n. m ≥ n ⇔ m &gt; n ∨ (m = n)
   
   [<a name="LESS_OR_EQ-val"><b>LESS_OR_EQ</b></a>]  Definition
      
      ⊢ ∀m n. m ≤ n ⇔ m &lt; n ∨ (m = n)
   
   [<a name="MAX_DEF-val"><b>MAX_DEF</b></a>]  Definition
      
      ⊢ ∀m n. MAX m n = if m &lt; n then n else m
   
   [<a name="MIN_DEF-val"><b>MIN_DEF</b></a>]  Definition
      
      ⊢ ∀m n. MIN m n = if m &lt; n then m else n
   
   [<a name="MODEQ_DEF-val"><b>MODEQ_DEF</b></a>]  Definition
      
      ⊢ ∀n m1 m2. MODEQ n m1 m2 ⇔ ∃a b. a * n + m1 = b * n + m2
   
   [<a name="MULT-val"><b>MULT</b></a>]  Definition
      
      ⊢ (∀n. 0 * n = 0) ∧ ∀m n. SUC m * n = m * n + n
   
   [<a name="NRC-val"><b>NRC</b></a>]  Definition
      
      ⊢ (∀R x y. NRC R 0 x y ⇔ (x = y)) ∧
        ∀R n x y. NRC R (SUC n) x y ⇔ ∃z. R x z ∧ NRC R n z y
   
   [<a name="NUMERAL_DEF-val"><b>NUMERAL_DEF</b></a>]  Definition
      
      ⊢ ∀x. NUMERAL x = x
   
   [<a name="ODD-val"><b>ODD</b></a>]  Definition
      
      ⊢ (ODD 0 ⇔ F) ∧ ∀n. ODD (SUC n) ⇔ ¬ODD n
   
   [<a name="SUB-val"><b>SUB</b></a>]  Definition
      
      ⊢ (∀m. 0 − m = 0) ∧
        ∀m n. SUC m − n = if m &lt; n then 0 else SUC (m − n)
   
   [<a name="findq_def-val"><b>findq_def</b></a>]  Definition
      
      ⊢ findq =
        WFREC (measure (λ(a,m,n). m − n))
          (λf (a,m,n).
               if n = 0 then a
               else (let d = 2 * n in if m &lt; d then a else f (2 * a,m,d)))
   
   [<a name="nat_elim__magic-val"><b>nat_elim__magic</b></a>]  Definition
      
      ⊢ ∀n. &n = n
   
   [<a name="num_case_def-val"><b>num_case_def</b></a>]  Definition
      
      ⊢ (∀v f. num_CASE 0 v f = v) ∧ ∀n v f. num_CASE (SUC n) v f = f n
   
   [<a name="ABS_DIFF_ADD_SAME-val"><b>ABS_DIFF_ADD_SAME</b></a>]  Theorem
      
      ⊢ ∀n m p. ABS_DIFF (n + p) (m + p) = ABS_DIFF n m
   
   [<a name="ABS_DIFF_COMM-val"><b>ABS_DIFF_COMM</b></a>]  Theorem
      
      ⊢ ∀n m. ABS_DIFF n m = ABS_DIFF m n
   
   [<a name="ABS_DIFF_EQS-val"><b>ABS_DIFF_EQS</b></a>]  Theorem
      
      ⊢ ∀n. ABS_DIFF n n = 0
   
   [<a name="ABS_DIFF_EQ_0-val"><b>ABS_DIFF_EQ_0</b></a>]  Theorem
      
      ⊢ ∀n m. (ABS_DIFF n m = 0) ⇔ (n = m)
   
   [<a name="ABS_DIFF_LE_SUM-val"><b>ABS_DIFF_LE_SUM</b></a>]  Theorem
      
      ⊢ ABS_DIFF x z ≤ x + z
   
   [<a name="ABS_DIFF_PLUS_LE-val"><b>ABS_DIFF_PLUS_LE</b></a>]  Theorem
      
      ⊢ ∀x z y. ABS_DIFF x (y + z) ≤ y + ABS_DIFF x z
   
   [<a name="ABS_DIFF_SUC-val"><b>ABS_DIFF_SUC</b></a>]  Theorem
      
      ⊢ ∀n m. ABS_DIFF (SUC n) (SUC m) = ABS_DIFF n m
   
   [<a name="ABS_DIFF_SUC_LE-val"><b>ABS_DIFF_SUC_LE</b></a>]  Theorem
      
      ⊢ ∀x z. ABS_DIFF x (SUC z) ≤ SUC (ABS_DIFF x z)
   
   [<a name="ABS_DIFF_SUMS-val"><b>ABS_DIFF_SUMS</b></a>]  Theorem
      
      ⊢ ∀n1 n2 m1 m2.
            ABS_DIFF (n1 + n2) (m1 + m2) ≤ ABS_DIFF n1 m1 + ABS_DIFF n2 m2
   
   [<a name="ABS_DIFF_SYM-val"><b>ABS_DIFF_SYM</b></a>]  Theorem
      
      ⊢ ∀n m. ABS_DIFF n m = ABS_DIFF m n
   
   [<a name="ABS_DIFF_TRIANGLE-val"><b>ABS_DIFF_TRIANGLE</b></a>]  Theorem
      
      ⊢ ∀x y z. ABS_DIFF x z ≤ ABS_DIFF x y + ABS_DIFF y z
   
   [<a name="ABS_DIFF_TRIANGLE_lem-val"><b>ABS_DIFF_TRIANGLE_lem</b></a>]  Theorem
      
      ⊢ ∀x y. x ≤ ABS_DIFF x y + y
   
   [<a name="ABS_DIFF_ZERO-val"><b>ABS_DIFF_ZERO</b></a>]  Theorem
      
      ⊢ ∀n. (ABS_DIFF n 0 = n) ∧ (ABS_DIFF 0 n = n)
   
   [<a name="ADD1-val"><b>ADD1</b></a>]  Theorem
      
      ⊢ ∀m. SUC m = m + 1
   
   [<a name="ADD_0-val"><b>ADD_0</b></a>]  Theorem
      
      ⊢ ∀m. m + 0 = m
   
   [<a name="ADD_ASSOC-val"><b>ADD_ASSOC</b></a>]  Theorem
      
      ⊢ ∀m n p. m + (n + p) = m + n + p
   
   [<a name="ADD_CLAUSES-val"><b>ADD_CLAUSES</b></a>]  Theorem
      
      ⊢ (0 + m = m) ∧ (m + 0 = m) ∧ (SUC m + n = SUC (m + n)) ∧
        (m + SUC n = SUC (m + n))
   
   [<a name="ADD_COMM-val"><b>ADD_COMM</b></a>]  Theorem
      
      ⊢ ∀m n. m + n = n + m
   
   [<a name="ADD_DIV_ADD_DIV-val"><b>ADD_DIV_ADD_DIV</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀x r. (x * n + r) DIV n = x + r DIV n
   
   [<a name="ADD_DIV_RWT-val"><b>ADD_DIV_RWT</b></a>]  Theorem
      
      ⊢ ∀n.
            0 &lt; n ⇒
            ∀m p.
                (m MOD n = 0) ∨ (p MOD n = 0) ⇒
                ((m + p) DIV n = m DIV n + p DIV n)
   
   [<a name="ADD_EQ_0-val"><b>ADD_EQ_0</b></a>]  Theorem
      
      ⊢ ∀m n. (m + n = 0) ⇔ (m = 0) ∧ (n = 0)
   
   [<a name="ADD_EQ_1-val"><b>ADD_EQ_1</b></a>]  Theorem
      
      ⊢ ∀m n. (m + n = 1) ⇔ (m = 1) ∧ (n = 0) ∨ (m = 0) ∧ (n = 1)
   
   [<a name="ADD_EQ_SUB-val"><b>ADD_EQ_SUB</b></a>]  Theorem
      
      ⊢ ∀m n p. n ≤ p ⇒ ((m + n = p) ⇔ (m = p − n))
   
   [<a name="ADD_INV_0-val"><b>ADD_INV_0</b></a>]  Theorem
      
      ⊢ ∀m n. (m + n = m) ⇒ (n = 0)
   
   [<a name="ADD_INV_0_EQ-val"><b>ADD_INV_0_EQ</b></a>]  Theorem
      
      ⊢ ∀m n. (m + n = m) ⇔ (n = 0)
   
   [<a name="ADD_MOD-val"><b>ADD_MOD</b></a>]  Theorem
      
      ⊢ ∀n a b p.
            0 &lt; n ⇒ (((a + p) MOD n = (b + p) MOD n) ⇔ (a MOD n = b MOD n))
   
   [<a name="ADD_MODULUS-val"><b>ADD_MODULUS</b></a>]  Theorem
      
      ⊢ (∀n x. 0 &lt; n ⇒ ((x + n) MOD n = x MOD n)) ∧
        ∀n x. 0 &lt; n ⇒ ((n + x) MOD n = x MOD n)
   
   [<a name="ADD_MODULUS_LEFT-val"><b>ADD_MODULUS_LEFT</b></a>]  Theorem
      
      ⊢ ∀n x. 0 &lt; n ⇒ ((x + n) MOD n = x MOD n)
   
   [<a name="ADD_MODULUS_RIGHT-val"><b>ADD_MODULUS_RIGHT</b></a>]  Theorem
      
      ⊢ ∀n x. 0 &lt; n ⇒ ((n + x) MOD n = x MOD n)
   
   [<a name="ADD_MONO_LESS_EQ-val"><b>ADD_MONO_LESS_EQ</b></a>]  Theorem
      
      ⊢ ∀m n p. m + n ≤ m + p ⇔ n ≤ p
   
   [<a name="ADD_SUB-val"><b>ADD_SUB</b></a>]  Theorem
      
      ⊢ ∀a c. a + c − c = a
   
   [<a name="ADD_SUC-val"><b>ADD_SUC</b></a>]  Theorem
      
      ⊢ ∀m n. SUC (m + n) = m + SUC n
   
   [<a name="ADD_SYM-val"><b>ADD_SYM</b></a>]  Theorem
      
      ⊢ ∀m n. m + n = n + m
   
   [<a name="BOUNDED_EXISTS_THM-val"><b>BOUNDED_EXISTS_THM</b></a>]  Theorem
      
      ⊢ ∀c. 0 &lt; c ⇒ ((∃n. n &lt; c ∧ P n) ⇔ P (c − 1) ∨ ∃n. n &lt; c − 1 ∧ P n)
   
   [<a name="BOUNDED_FORALL_THM-val"><b>BOUNDED_FORALL_THM</b></a>]  Theorem
      
      ⊢ ∀c. 0 &lt; c ⇒ ((∀n. n &lt; c ⇒ P n) ⇔ P (c − 1) ∧ ∀n. n &lt; c − 1 ⇒ P n)
   
   [<a name="CANCEL_SUB-val"><b>CANCEL_SUB</b></a>]  Theorem
      
      ⊢ ∀p n m. p ≤ n ∧ p ≤ m ⇒ ((n − p = m − p) ⇔ (n = m))
   
   [<a name="COMPLETE_INDUCTION-val"><b>COMPLETE_INDUCTION</b></a>]  Theorem
      
      ⊢ ∀P. (∀n. (∀m. m &lt; n ⇒ P m) ⇒ P n) ⇒ ∀n. P n
   
   [<a name="DA-val"><b>DA</b></a>]  Theorem
      
      ⊢ ∀k n. 0 &lt; n ⇒ ∃r q. (k = q * n + r) ∧ r &lt; n
   
   [<a name="DIVMOD_CALC-val"><b>DIVMOD_CALC</b></a>]  Theorem
      
      ⊢ (∀m n. 0 &lt; n ⇒ (m DIV n = FST (DIVMOD (0,m,n)))) ∧
        ∀m n. 0 &lt; n ⇒ (m MOD n = SND (DIVMOD (0,m,n)))
   
   [<a name="DIVMOD_CORRECT-val"><b>DIVMOD_CORRECT</b></a>]  Theorem
      
      ⊢ ∀m n a. 0 &lt; n ⇒ (DIVMOD (a,m,n) = (a + m DIV n,m MOD n))
   
   [<a name="DIVMOD_ID-val"><b>DIVMOD_ID</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ (n DIV n = 1) ∧ (n MOD n = 0)
   
   [<a name="DIVMOD_THM-val"><b>DIVMOD_THM</b></a>]  Theorem
      
      ⊢ DIVMOD (a,m,n) =
        if n = 0 then (0,0)
        else if m &lt; n then (a,m)
        else (let q = findq (1,m,n) in DIVMOD (a + q,m − n * q,n))
   
   [<a name="DIV_1-val"><b>DIV_1</b></a>]  Theorem
      
      ⊢ ∀q. q DIV 1 = q
   
   [<a name="DIV_DIV_DIV_MULT-val"><b>DIV_DIV_DIV_MULT</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ∧ 0 &lt; n ⇒ ∀x. x DIV m DIV n = x DIV (m * n)
   
   [<a name="DIV_EQ_X-val"><b>DIV_EQ_X</b></a>]  Theorem
      
      ⊢ ∀x y z. 0 &lt; z ⇒ ((y DIV z = x) ⇔ x * z ≤ y ∧ y &lt; SUC x * z)
   
   [<a name="DIV_LESS-val"><b>DIV_LESS</b></a>]  Theorem
      
      ⊢ ∀n d. 0 &lt; n ∧ 1 &lt; d ⇒ n DIV d &lt; n
   
   [<a name="DIV_LESS_EQ-val"><b>DIV_LESS_EQ</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀k. k DIV n ≤ k
   
   [<a name="DIV_LE_MONOTONE-val"><b>DIV_LE_MONOTONE</b></a>]  Theorem
      
      ⊢ ∀n x y. 0 &lt; n ∧ x ≤ y ⇒ x DIV n ≤ y DIV n
   
   [<a name="DIV_LE_X-val"><b>DIV_LE_X</b></a>]  Theorem
      
      ⊢ ∀x y z. 0 &lt; z ⇒ (y DIV z ≤ x ⇔ y &lt; (x + 1) * z)
   
   [<a name="DIV_LT_X-val"><b>DIV_LT_X</b></a>]  Theorem
      
      ⊢ ∀x y z. 0 &lt; z ⇒ (y DIV z &lt; x ⇔ y &lt; x * z)
   
   [<a name="DIV_MOD_MOD_DIV-val"><b>DIV_MOD_MOD_DIV</b></a>]  Theorem
      
      ⊢ ∀m n k. 0 &lt; n ∧ 0 &lt; k ⇒ ((m DIV n) MOD k = m MOD (n * k) DIV n)
   
   [<a name="DIV_MULT-val"><b>DIV_MULT</b></a>]  Theorem
      
      ⊢ ∀n r. r &lt; n ⇒ ∀q. (q * n + r) DIV n = q
   
   [<a name="DIV_ONE-val"><b>DIV_ONE</b></a>]  Theorem
      
      ⊢ ∀q. q DIV SUC 0 = q
   
   [<a name="DIV_P-val"><b>DIV_P</b></a>]  Theorem
      
      ⊢ ∀P p q. 0 &lt; q ⇒ (P (p DIV q) ⇔ ∃k r. (p = k * q + r) ∧ r &lt; q ∧ P k)
   
   [<a name="DIV_P_UNIV-val"><b>DIV_P_UNIV</b></a>]  Theorem
      
      ⊢ ∀P m n. 0 &lt; n ⇒ (P (m DIV n) ⇔ ∀q r. (m = q * n + r) ∧ r &lt; n ⇒ P q)
   
   [<a name="DIV_SUB-val"><b>DIV_SUB</b></a>]  Theorem
      
      ⊢ 0 &lt; n ∧ n * q ≤ m ⇒ ((m − n * q) DIV n = m DIV n − q)
   
   [<a name="DIV_UNIQUE-val"><b>DIV_UNIQUE</b></a>]  Theorem
      
      ⊢ ∀n k q. (∃r. (k = q * n + r) ∧ r &lt; n) ⇒ (k DIV n = q)
   
   [<a name="DOUBLE_LT-val"><b>DOUBLE_LT</b></a>]  Theorem
      
      ⊢ ∀p q. 2 * p + 1 &lt; 2 * q ⇔ 2 * p &lt; 2 * q
   
   [<a name="EQ_ADD_LCANCEL-val"><b>EQ_ADD_LCANCEL</b></a>]  Theorem
      
      ⊢ ∀m n p. (m + n = m + p) ⇔ (n = p)
   
   [<a name="EQ_ADD_RCANCEL-val"><b>EQ_ADD_RCANCEL</b></a>]  Theorem
      
      ⊢ ∀m n p. (m + p = n + p) ⇔ (m = n)
   
   [<a name="EQ_LESS_EQ-val"><b>EQ_LESS_EQ</b></a>]  Theorem
      
      ⊢ ∀m n. (m = n) ⇔ m ≤ n ∧ n ≤ m
   
   [<a name="EQ_MONO_ADD_EQ-val"><b>EQ_MONO_ADD_EQ</b></a>]  Theorem
      
      ⊢ ∀m n p. (m + p = n + p) ⇔ (m = n)
   
   [<a name="EQ_MULT_LCANCEL-val"><b>EQ_MULT_LCANCEL</b></a>]  Theorem
      
      ⊢ ∀m n p. (m * n = m * p) ⇔ (m = 0) ∨ (n = p)
   
   [<a name="EQ_MULT_RCANCEL-val"><b>EQ_MULT_RCANCEL</b></a>]  Theorem
      
      ⊢ ∀m n p. (n * m = p * m) ⇔ (m = 0) ∨ (n = p)
   
   [<a name="EVEN_ADD-val"><b>EVEN_ADD</b></a>]  Theorem
      
      ⊢ ∀m n. EVEN (m + n) ⇔ (EVEN m ⇔ EVEN n)
   
   [<a name="EVEN_AND_ODD-val"><b>EVEN_AND_ODD</b></a>]  Theorem
      
      ⊢ ∀n. ¬(EVEN n ∧ ODD n)
   
   [<a name="EVEN_DOUBLE-val"><b>EVEN_DOUBLE</b></a>]  Theorem
      
      ⊢ ∀n. EVEN (2 * n)
   
   [<a name="EVEN_EXISTS-val"><b>EVEN_EXISTS</b></a>]  Theorem
      
      ⊢ ∀n. EVEN n ⇔ ∃m. n = 2 * m
   
   [<a name="EVEN_EXP-val"><b>EVEN_EXP</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; n ∧ EVEN m ⇒ EVEN (m ** n)
   
   [<a name="EVEN_EXP_IFF-val"><b>EVEN_EXP_IFF</b></a>]  Theorem
      
      ⊢ ∀n m. EVEN (m ** n) ⇔ 0 &lt; n ∧ EVEN m
   
   [<a name="EVEN_MOD2-val"><b>EVEN_MOD2</b></a>]  Theorem
      
      ⊢ ∀x. EVEN x ⇔ (x MOD 2 = 0)
   
   [<a name="EVEN_MULT-val"><b>EVEN_MULT</b></a>]  Theorem
      
      ⊢ ∀m n. EVEN (m * n) ⇔ EVEN m ∨ EVEN n
   
   [<a name="EVEN_ODD-val"><b>EVEN_ODD</b></a>]  Theorem
      
      ⊢ ∀n. EVEN n ⇔ ¬ODD n
   
   [<a name="EVEN_ODD_EXISTS-val"><b>EVEN_ODD_EXISTS</b></a>]  Theorem
      
      ⊢ ∀n. (EVEN n ⇒ ∃m. n = 2 * m) ∧ (ODD n ⇒ ∃m. n = SUC (2 * m))
   
   [<a name="EVEN_OR_ODD-val"><b>EVEN_OR_ODD</b></a>]  Theorem
      
      ⊢ ∀n. EVEN n ∨ ODD n
   
   [<a name="EXISTS_GREATEST-val"><b>EXISTS_GREATEST</b></a>]  Theorem
      
      ⊢ ∀P. (∃x. P x) ∧ (∃x. ∀y. y &gt; x ⇒ ¬P y) ⇔ ∃x. P x ∧ ∀y. y &gt; x ⇒ ¬P y
   
   [<a name="EXISTS_NUM-val"><b>EXISTS_NUM</b></a>]  Theorem
      
      ⊢ ∀P. (∃n. P n) ⇔ P 0 ∨ ∃m. P (SUC m)
   
   [<a name="EXP2_LT-val"><b>EXP2_LT</b></a>]  Theorem
      
      ⊢ ∀m n. n DIV 2 &lt; 2 ** m ⇔ n &lt; 2 ** SUC m
   
   [<a name="EXP_1-val"><b>EXP_1</b></a>]  Theorem
      
      ⊢ ∀n. (1 ** n = 1) ∧ (n ** 1 = n)
   
   [<a name="EXP_ADD-val"><b>EXP_ADD</b></a>]  Theorem
      
      ⊢ ∀p q n. n ** (p + q) = n ** p * n ** q
   
   [<a name="EXP_ALWAYS_BIG_ENOUGH-val"><b>EXP_ALWAYS_BIG_ENOUGH</b></a>]  Theorem
      
      ⊢ ∀b. 1 &lt; b ⇒ ∀n. ∃m. n ≤ b ** m
   
   [<a name="EXP_BASE_INJECTIVE-val"><b>EXP_BASE_INJECTIVE</b></a>]  Theorem
      
      ⊢ ∀b. 1 &lt; b ⇒ ∀n m. (b ** n = b ** m) ⇔ (n = m)
   
   [<a name="EXP_BASE_LEQ_MONO_IMP-val"><b>EXP_BASE_LEQ_MONO_IMP</b></a>]  Theorem
      
      ⊢ ∀n m b. 0 &lt; b ∧ m ≤ n ⇒ b ** m ≤ b ** n
   
   [<a name="EXP_BASE_LEQ_MONO_SUC_IMP-val"><b>EXP_BASE_LEQ_MONO_SUC_IMP</b></a>]  Theorem
      
      ⊢ m ≤ n ⇒ SUC b ** m ≤ SUC b ** n
   
   [<a name="EXP_BASE_LE_IFF-val"><b>EXP_BASE_LE_IFF</b></a>]  Theorem
      
      ⊢ b ** m ≤ b ** n ⇔
        (b = 0) ∧ (n = 0) ∨ (b = 0) ∧ 0 &lt; m ∨ (b = 1) ∨ 1 &lt; b ∧ m ≤ n
   
   [<a name="EXP_BASE_LE_MONO-val"><b>EXP_BASE_LE_MONO</b></a>]  Theorem
      
      ⊢ ∀b. 1 &lt; b ⇒ ∀n m. b ** m ≤ b ** n ⇔ m ≤ n
   
   [<a name="EXP_BASE_LT_MONO-val"><b>EXP_BASE_LT_MONO</b></a>]  Theorem
      
      ⊢ ∀b. 1 &lt; b ⇒ ∀n m. b ** m &lt; b ** n ⇔ m &lt; n
   
   [<a name="EXP_BASE_MULT-val"><b>EXP_BASE_MULT</b></a>]  Theorem
      
      ⊢ ∀z x y. (x * y) ** z = x ** z * y ** z
   
   [<a name="EXP_EQ_0-val"><b>EXP_EQ_0</b></a>]  Theorem
      
      ⊢ ∀n m. (n ** m = 0) ⇔ (n = 0) ∧ 0 &lt; m
   
   [<a name="EXP_EQ_1-val"><b>EXP_EQ_1</b></a>]  Theorem
      
      ⊢ ∀n m. (n ** m = 1) ⇔ (n = 1) ∨ (m = 0)
   
   [<a name="EXP_EXP_INJECTIVE-val"><b>EXP_EXP_INJECTIVE</b></a>]  Theorem
      
      ⊢ ∀b1 b2 x. (b1 ** x = b2 ** x) ⇔ (x = 0) ∨ (b1 = b2)
   
   [<a name="EXP_EXP_LE_MONO-val"><b>EXP_EXP_LE_MONO</b></a>]  Theorem
      
      ⊢ ∀a b. a ** n ≤ b ** n ⇔ a ≤ b ∨ (n = 0)
   
   [<a name="EXP_EXP_LT_MONO-val"><b>EXP_EXP_LT_MONO</b></a>]  Theorem
      
      ⊢ ∀a b. a ** n &lt; b ** n ⇔ a &lt; b ∧ 0 &lt; n
   
   [<a name="EXP_EXP_MULT-val"><b>EXP_EXP_MULT</b></a>]  Theorem
      
      ⊢ ∀z x y. x ** (y * z) = (x ** y) ** z
   
   [<a name="EXP_MOD-val"><b>EXP_MOD</b></a>]  Theorem
      
      ⊢ 0 &lt; n ⇒ ((x MOD n) ** e MOD n = x ** e MOD n)
   
   [<a name="EXP_SUB-val"><b>EXP_SUB</b></a>]  Theorem
      
      ⊢ ∀p q n. 0 &lt; n ∧ q ≤ p ⇒ (n ** (p − q) = n ** p DIV n ** q)
   
   [<a name="EXP_SUB_NUMERAL-val"><b>EXP_SUB_NUMERAL</b></a>]  Theorem
      
      ⊢ 0 &lt; n ⇒
        (n ** NUMERAL (BIT1 x) DIV n = n ** (NUMERAL (BIT1 x) − 1)) ∧
        (n ** NUMERAL (BIT2 x) DIV n = n ** NUMERAL (BIT1 x))
   
   [<a name="FACT_LESS-val"><b>FACT_LESS</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; FACT n
   
   [<a name="FORALL_NUM-val"><b>FORALL_NUM</b></a>]  Theorem
      
      ⊢ ∀P. (∀n. P n) ⇔ P 0 ∧ ∀n. P (SUC n)
   
   [<a name="FORALL_NUM_THM-val"><b>FORALL_NUM_THM</b></a>]  Theorem
      
      ⊢ (∀n. P n) ⇔ P 0 ∧ ∀n. P n ⇒ P (SUC n)
   
   [<a name="FUNPOW_0-val"><b>FUNPOW_0</b></a>]  Theorem
      
      ⊢ FUNPOW f 0 x = x
   
   [<a name="FUNPOW_1-val"><b>FUNPOW_1</b></a>]  Theorem
      
      ⊢ FUNPOW f 1 x = f x
   
   [<a name="FUNPOW_ADD-val"><b>FUNPOW_ADD</b></a>]  Theorem
      
      ⊢ ∀m n. FUNPOW f (m + n) x = FUNPOW f m (FUNPOW f n x)
   
   [<a name="FUNPOW_SUC-val"><b>FUNPOW_SUC</b></a>]  Theorem
      
      ⊢ ∀f n x. FUNPOW f (SUC n) x = f (FUNPOW f n x)
   
   [<a name="GREATER_EQ-val"><b>GREATER_EQ</b></a>]  Theorem
      
      ⊢ ∀n m. n ≥ m ⇔ m ≤ n
   
   [<a name="INV_PRE_EQ-val"><b>INV_PRE_EQ</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ∧ 0 &lt; n ⇒ ((PRE m = PRE n) ⇔ (m = n))
   
   [<a name="INV_PRE_LESS-val"><b>INV_PRE_LESS</b></a>]  Theorem
      
      ⊢ ∀m. 0 &lt; m ⇒ ∀n. PRE m &lt; PRE n ⇔ m &lt; n
   
   [<a name="INV_PRE_LESS_EQ-val"><b>INV_PRE_LESS_EQ</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀m. PRE m ≤ PRE n ⇔ m ≤ n
   
   [<a name="LE-val"><b>LE</b></a>]  Theorem
      
      ⊢ (∀n. n ≤ 0 ⇔ (n = 0)) ∧ ∀m n. m ≤ SUC n ⇔ (m = SUC n) ∨ m ≤ n
   
   [<a name="LEFT_ADD_DISTRIB-val"><b>LEFT_ADD_DISTRIB</b></a>]  Theorem
      
      ⊢ ∀m n p. p * (m + n) = p * m + p * n
   
   [<a name="LEFT_SUB_DISTRIB-val"><b>LEFT_SUB_DISTRIB</b></a>]  Theorem
      
      ⊢ ∀m n p. p * (m − n) = p * m − p * n
   
   [<a name="LESS_0_CASES-val"><b>LESS_0_CASES</b></a>]  Theorem
      
      ⊢ ∀m. (0 = m) ∨ 0 &lt; m
   
   [<a name="LESS_ADD-val"><b>LESS_ADD</b></a>]  Theorem
      
      ⊢ ∀m n. n &lt; m ⇒ ∃p. p + n = m
   
   [<a name="LESS_ADD_1-val"><b>LESS_ADD_1</b></a>]  Theorem
      
      ⊢ ∀m n. n &lt; m ⇒ ∃p. m = n + (p + 1)
   
   [<a name="LESS_ADD_NONZERO-val"><b>LESS_ADD_NONZERO</b></a>]  Theorem
      
      ⊢ ∀m n. n ≠ 0 ⇒ m &lt; m + n
   
   [<a name="LESS_ADD_SUC-val"><b>LESS_ADD_SUC</b></a>]  Theorem
      
      ⊢ ∀m n. m &lt; m + SUC n
   
   [<a name="LESS_ANTISYM-val"><b>LESS_ANTISYM</b></a>]  Theorem
      
      ⊢ ∀m n. ¬(m &lt; n ∧ n &lt; m)
   
   [<a name="LESS_CASES-val"><b>LESS_CASES</b></a>]  Theorem
      
      ⊢ ∀m n. m &lt; n ∨ n ≤ m
   
   [<a name="LESS_CASES_IMP-val"><b>LESS_CASES_IMP</b></a>]  Theorem
      
      ⊢ ∀m n. ¬(m &lt; n) ∧ m ≠ n ⇒ n &lt; m
   
   [<a name="LESS_DIV_EQ_ZERO-val"><b>LESS_DIV_EQ_ZERO</b></a>]  Theorem
      
      ⊢ ∀r n. r &lt; n ⇒ (r DIV n = 0)
   
   [<a name="LESS_EQ-val"><b>LESS_EQ</b></a>]  Theorem
      
      ⊢ ∀m n. m &lt; n ⇔ SUC m ≤ n
   
   [<a name="LESS_EQUAL_ADD-val"><b>LESS_EQUAL_ADD</b></a>]  Theorem
      
      ⊢ ∀m n. m ≤ n ⇒ ∃p. n = m + p
   
   [<a name="LESS_EQUAL_ANTISYM-val"><b>LESS_EQUAL_ANTISYM</b></a>]  Theorem
      
      ⊢ ∀n m. n ≤ m ∧ m ≤ n ⇒ (n = m)
   
   [<a name="LESS_EQUAL_DIFF-val"><b>LESS_EQUAL_DIFF</b></a>]  Theorem
      
      ⊢ ∀m n. m ≤ n ⇒ ∃k. m = n − k
   
   [<a name="LESS_EQ_0-val"><b>LESS_EQ_0</b></a>]  Theorem
      
      ⊢ ∀n. n ≤ 0 ⇔ (n = 0)
   
   [<a name="LESS_EQ_ADD-val"><b>LESS_EQ_ADD</b></a>]  Theorem
      
      ⊢ ∀m n. m ≤ m + n
   
   [<a name="LESS_EQ_ADD_EXISTS-val"><b>LESS_EQ_ADD_EXISTS</b></a>]  Theorem
      
      ⊢ ∀m n. n ≤ m ⇒ ∃p. p + n = m
   
   [<a name="LESS_EQ_ADD_SUB-val"><b>LESS_EQ_ADD_SUB</b></a>]  Theorem
      
      ⊢ ∀c b. c ≤ b ⇒ ∀a. a + b − c = a + (b − c)
   
   [<a name="LESS_EQ_ANTISYM-val"><b>LESS_EQ_ANTISYM</b></a>]  Theorem
      
      ⊢ ∀m n. ¬(m &lt; n ∧ n ≤ m)
   
   [<a name="LESS_EQ_CASES-val"><b>LESS_EQ_CASES</b></a>]  Theorem
      
      ⊢ ∀m n. m ≤ n ∨ n ≤ m
   
   [<a name="LESS_EQ_EXISTS-val"><b>LESS_EQ_EXISTS</b></a>]  Theorem
      
      ⊢ ∀m n. m ≤ n ⇔ ∃p. n = m + p
   
   [<a name="LESS_EQ_IFF_LESS_SUC-val"><b>LESS_EQ_IFF_LESS_SUC</b></a>]  Theorem
      
      ⊢ ∀n m. n ≤ m ⇔ n &lt; SUC m
   
   [<a name="LESS_EQ_IMP_LESS_SUC-val"><b>LESS_EQ_IMP_LESS_SUC</b></a>]  Theorem
      
      ⊢ ∀n m. n ≤ m ⇒ n &lt; SUC m
   
   [<a name="LESS_EQ_LESS_EQ_MONO-val"><b>LESS_EQ_LESS_EQ_MONO</b></a>]  Theorem
      
      ⊢ ∀m n p q. m ≤ p ∧ n ≤ q ⇒ m + n ≤ p + q
   
   [<a name="LESS_EQ_LESS_TRANS-val"><b>LESS_EQ_LESS_TRANS</b></a>]  Theorem
      
      ⊢ ∀m n p. m ≤ n ∧ n &lt; p ⇒ m &lt; p
   
   [<a name="LESS_EQ_MONO-val"><b>LESS_EQ_MONO</b></a>]  Theorem
      
      ⊢ ∀n m. SUC n ≤ SUC m ⇔ n ≤ m
   
   [<a name="LESS_EQ_MONO_ADD_EQ-val"><b>LESS_EQ_MONO_ADD_EQ</b></a>]  Theorem
      
      ⊢ ∀m n p. m + p ≤ n + p ⇔ m ≤ n
   
   [<a name="LESS_EQ_REFL-val"><b>LESS_EQ_REFL</b></a>]  Theorem
      
      ⊢ ∀m. m ≤ m
   
   [<a name="LESS_EQ_SUB_LESS-val"><b>LESS_EQ_SUB_LESS</b></a>]  Theorem
      
      ⊢ ∀a b. b ≤ a ⇒ ∀c. a − b &lt; c ⇔ a &lt; b + c
   
   [<a name="LESS_EQ_SUC_REFL-val"><b>LESS_EQ_SUC_REFL</b></a>]  Theorem
      
      ⊢ ∀m. m ≤ SUC m
   
   [<a name="LESS_EQ_TRANS-val"><b>LESS_EQ_TRANS</b></a>]  Theorem
      
      ⊢ ∀m n p. m ≤ n ∧ n ≤ p ⇒ m ≤ p
   
   [<a name="LESS_EXP_SUC_MONO-val"><b>LESS_EXP_SUC_MONO</b></a>]  Theorem
      
      ⊢ ∀n m. SUC (SUC m) ** n &lt; SUC (SUC m) ** SUC n
   
   [<a name="LESS_IMP_LESS_ADD-val"><b>LESS_IMP_LESS_ADD</b></a>]  Theorem
      
      ⊢ ∀n m. n &lt; m ⇒ ∀p. n &lt; m + p
   
   [<a name="LESS_IMP_LESS_OR_EQ-val"><b>LESS_IMP_LESS_OR_EQ</b></a>]  Theorem
      
      ⊢ ∀m n. m &lt; n ⇒ m ≤ n
   
   [<a name="LESS_LESS_CASES-val"><b>LESS_LESS_CASES</b></a>]  Theorem
      
      ⊢ ∀m n. (m = n) ∨ m &lt; n ∨ n &lt; m
   
   [<a name="LESS_LESS_EQ_TRANS-val"><b>LESS_LESS_EQ_TRANS</b></a>]  Theorem
      
      ⊢ ∀m n p. m &lt; n ∧ n ≤ p ⇒ m &lt; p
   
   [<a name="LESS_LESS_SUC-val"><b>LESS_LESS_SUC</b></a>]  Theorem
      
      ⊢ ∀m n. ¬(m &lt; n ∧ n &lt; SUC m)
   
   [<a name="LESS_MOD-val"><b>LESS_MOD</b></a>]  Theorem
      
      ⊢ ∀n k. k &lt; n ⇒ (k MOD n = k)
   
   [<a name="LESS_MONO_ADD-val"><b>LESS_MONO_ADD</b></a>]  Theorem
      
      ⊢ ∀m n p. m &lt; n ⇒ m + p &lt; n + p
   
   [<a name="LESS_MONO_ADD_EQ-val"><b>LESS_MONO_ADD_EQ</b></a>]  Theorem
      
      ⊢ ∀m n p. m + p &lt; n + p ⇔ m &lt; n
   
   [<a name="LESS_MONO_ADD_INV-val"><b>LESS_MONO_ADD_INV</b></a>]  Theorem
      
      ⊢ ∀m n p. m + p &lt; n + p ⇒ m &lt; n
   
   [<a name="LESS_MONO_EQ-val"><b>LESS_MONO_EQ</b></a>]  Theorem
      
      ⊢ ∀m n. SUC m &lt; SUC n ⇔ m &lt; n
   
   [<a name="LESS_MONO_MULT-val"><b>LESS_MONO_MULT</b></a>]  Theorem
      
      ⊢ ∀m n p. m ≤ n ⇒ m * p ≤ n * p
   
   [<a name="LESS_MONO_MULT2-val"><b>LESS_MONO_MULT2</b></a>]  Theorem
      
      ⊢ ∀m n i j. m ≤ i ∧ n ≤ j ⇒ m * n ≤ i * j
   
   [<a name="LESS_MONO_REV-val"><b>LESS_MONO_REV</b></a>]  Theorem
      
      ⊢ ∀m n. SUC m &lt; SUC n ⇒ m &lt; n
   
   [<a name="LESS_MULT2-val"><b>LESS_MULT2</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m ∧ 0 &lt; n ⇒ 0 &lt; m * n
   
   [<a name="LESS_MULT_MONO-val"><b>LESS_MULT_MONO</b></a>]  Theorem
      
      ⊢ ∀m i n. SUC n * m &lt; SUC n * i ⇔ m &lt; i
   
   [<a name="LESS_NOT_SUC-val"><b>LESS_NOT_SUC</b></a>]  Theorem
      
      ⊢ ∀m n. m &lt; n ∧ n ≠ SUC m ⇒ SUC m &lt; n
   
   [<a name="LESS_OR-val"><b>LESS_OR</b></a>]  Theorem
      
      ⊢ ∀m n. m &lt; n ⇒ SUC m ≤ n
   
   [<a name="LESS_OR_EQ_ADD-val"><b>LESS_OR_EQ_ADD</b></a>]  Theorem
      
      ⊢ ∀n m. n &lt; m ∨ ∃p. n = p + m
   
   [<a name="LESS_OR_EQ_ALT-val"><b>LESS_OR_EQ_ALT</b></a>]  Theorem
      
      ⊢ $&lt;= = (λx y. y = SUC x)^*
   
   [<a name="LESS_STRONG_ADD-val"><b>LESS_STRONG_ADD</b></a>]  Theorem
      
      ⊢ ∀m n. n &lt; m ⇒ ∃p. SUC p + n = m
   
   [<a name="LESS_SUB_ADD_LESS-val"><b>LESS_SUB_ADD_LESS</b></a>]  Theorem
      
      ⊢ ∀n m i. i &lt; n − m ⇒ i + m &lt; n
   
   [<a name="LESS_SUC_EQ_COR-val"><b>LESS_SUC_EQ_COR</b></a>]  Theorem
      
      ⊢ ∀m n. m &lt; n ∧ SUC m ≠ n ⇒ SUC m &lt; n
   
   [<a name="LESS_SUC_NOT-val"><b>LESS_SUC_NOT</b></a>]  Theorem
      
      ⊢ ∀m n. m &lt; n ⇒ ¬(n &lt; SUC m)
   
   [<a name="LESS_TRANS-val"><b>LESS_TRANS</b></a>]  Theorem
      
      ⊢ ∀m n p. m &lt; n ∧ n &lt; p ⇒ m &lt; p
   
   [<a name="LE_ADD_LCANCEL-val"><b>LE_ADD_LCANCEL</b></a>]  Theorem
      
      ⊢ ∀m n p. m + n ≤ m + p ⇔ n ≤ p
   
   [<a name="LE_ADD_RCANCEL-val"><b>LE_ADD_RCANCEL</b></a>]  Theorem
      
      ⊢ ∀m n p. n + m ≤ p + m ⇔ n ≤ p
   
   [<a name="LE_LT1-val"><b>LE_LT1</b></a>]  Theorem
      
      ⊢ ∀x y. x ≤ y ⇔ x &lt; y + 1
   
   [<a name="LE_MULT_CANCEL_LBARE-val"><b>LE_MULT_CANCEL_LBARE</b></a>]  Theorem
      
      ⊢ (m ≤ m * n ⇔ (m = 0) ∨ 0 &lt; n) ∧ (m ≤ n * m ⇔ (m = 0) ∨ 0 &lt; n)
   
   [<a name="LE_MULT_CANCEL_RBARE-val"><b>LE_MULT_CANCEL_RBARE</b></a>]  Theorem
      
      ⊢ (m * n ≤ m ⇔ (m = 0) ∨ n ≤ 1) ∧ (m * n ≤ n ⇔ (n = 0) ∨ m ≤ 1)
   
   [<a name="LE_MULT_LCANCEL-val"><b>LE_MULT_LCANCEL</b></a>]  Theorem
      
      ⊢ ∀m n p. m * n ≤ m * p ⇔ (m = 0) ∨ n ≤ p
   
   [<a name="LE_MULT_RCANCEL-val"><b>LE_MULT_RCANCEL</b></a>]  Theorem
      
      ⊢ ∀m n p. m * n ≤ p * n ⇔ (n = 0) ∨ m ≤ p
   
   [<a name="LE_SUB_LCANCEL-val"><b>LE_SUB_LCANCEL</b></a>]  Theorem
      
      ⊢ ∀z y x. x − y ≤ x − z ⇔ z ≤ y ∨ x ≤ y
   
   [<a name="LE_SUB_RCANCEL-val"><b>LE_SUB_RCANCEL</b></a>]  Theorem
      
      ⊢ ∀m n p. n − m ≤ p − m ⇔ n ≤ m ∨ n ≤ p
   
   [<a name="LT_ADD_LCANCEL-val"><b>LT_ADD_LCANCEL</b></a>]  Theorem
      
      ⊢ ∀m n p. p + m &lt; p + n ⇔ m &lt; n
   
   [<a name="LT_ADD_RCANCEL-val"><b>LT_ADD_RCANCEL</b></a>]  Theorem
      
      ⊢ ∀m n p. m + p &lt; n + p ⇔ m &lt; n
   
   [<a name="LT_MULT_CANCEL_LBARE-val"><b>LT_MULT_CANCEL_LBARE</b></a>]  Theorem
      
      ⊢ (m &lt; m * n ⇔ 0 &lt; m ∧ 1 &lt; n) ∧ (m &lt; n * m ⇔ 0 &lt; m ∧ 1 &lt; n)
   
   [<a name="LT_MULT_CANCEL_RBARE-val"><b>LT_MULT_CANCEL_RBARE</b></a>]  Theorem
      
      ⊢ (m * n &lt; m ⇔ 0 &lt; m ∧ (n = 0)) ∧ (m * n &lt; n ⇔ 0 &lt; n ∧ (m = 0))
   
   [<a name="LT_MULT_LCANCEL-val"><b>LT_MULT_LCANCEL</b></a>]  Theorem
      
      ⊢ ∀m n p. m * n &lt; m * p ⇔ 0 &lt; m ∧ n &lt; p
   
   [<a name="LT_MULT_RCANCEL-val"><b>LT_MULT_RCANCEL</b></a>]  Theorem
      
      ⊢ ∀m n p. m * n &lt; p * n ⇔ 0 &lt; n ∧ m &lt; p
   
   [<a name="LT_SUB_LCANCEL-val"><b>LT_SUB_LCANCEL</b></a>]  Theorem
      
      ⊢ ∀z y x. x − y &lt; x − z ⇔ z &lt; y ∧ z &lt; x
   
   [<a name="LT_SUB_RCANCEL-val"><b>LT_SUB_RCANCEL</b></a>]  Theorem
      
      ⊢ ∀m n p. n − m &lt; p − m ⇔ n &lt; p ∧ m &lt; p
   
   [<a name="MAX_0-val"><b>MAX_0</b></a>]  Theorem
      
      ⊢ ∀n. (MAX n 0 = n) ∧ (MAX 0 n = n)
   
   [<a name="MAX_ASSOC-val"><b>MAX_ASSOC</b></a>]  Theorem
      
      ⊢ ∀m n p. MAX m (MAX n p) = MAX (MAX m n) p
   
   [<a name="MAX_COMM-val"><b>MAX_COMM</b></a>]  Theorem
      
      ⊢ ∀m n. MAX m n = MAX n m
   
   [<a name="MAX_EQ_0-val"><b>MAX_EQ_0</b></a>]  Theorem
      
      ⊢ (MAX m n = 0) ⇔ (m = 0) ∧ (n = 0)
   
   [<a name="MAX_IDEM-val"><b>MAX_IDEM</b></a>]  Theorem
      
      ⊢ ∀n. MAX n n = n
   
   [<a name="MAX_LE-val"><b>MAX_LE</b></a>]  Theorem
      
      ⊢ ∀n m p.
            (p ≤ MAX m n ⇔ p ≤ m ∨ p ≤ n) ∧ (MAX m n ≤ p ⇔ m ≤ p ∧ n ≤ p)
   
   [<a name="MAX_LT-val"><b>MAX_LT</b></a>]  Theorem
      
      ⊢ ∀n m p.
            (p &lt; MAX m n ⇔ p &lt; m ∨ p &lt; n) ∧ (MAX m n &lt; p ⇔ m &lt; p ∧ n &lt; p)
   
   [<a name="MIN_0-val"><b>MIN_0</b></a>]  Theorem
      
      ⊢ ∀n. (MIN n 0 = 0) ∧ (MIN 0 n = 0)
   
   [<a name="MIN_ASSOC-val"><b>MIN_ASSOC</b></a>]  Theorem
      
      ⊢ ∀m n p. MIN m (MIN n p) = MIN (MIN m n) p
   
   [<a name="MIN_COMM-val"><b>MIN_COMM</b></a>]  Theorem
      
      ⊢ ∀m n. MIN m n = MIN n m
   
   [<a name="MIN_EQ_0-val"><b>MIN_EQ_0</b></a>]  Theorem
      
      ⊢ (MIN m n = 0) ⇔ (m = 0) ∨ (n = 0)
   
   [<a name="MIN_IDEM-val"><b>MIN_IDEM</b></a>]  Theorem
      
      ⊢ ∀n. MIN n n = n
   
   [<a name="MIN_LE-val"><b>MIN_LE</b></a>]  Theorem
      
      ⊢ ∀n m p.
            (MIN m n ≤ p ⇔ m ≤ p ∨ n ≤ p) ∧ (p ≤ MIN m n ⇔ p ≤ m ∧ p ≤ n)
   
   [<a name="MIN_LT-val"><b>MIN_LT</b></a>]  Theorem
      
      ⊢ ∀n m p.
            (MIN m n &lt; p ⇔ m &lt; p ∨ n &lt; p) ∧ (p &lt; MIN m n ⇔ p &lt; m ∧ p &lt; n)
   
   [<a name="MIN_MAX_EQ-val"><b>MIN_MAX_EQ</b></a>]  Theorem
      
      ⊢ ∀m n. (MIN m n = MAX m n) ⇔ (m = n)
   
   [<a name="MIN_MAX_LE-val"><b>MIN_MAX_LE</b></a>]  Theorem
      
      ⊢ ∀m n. MIN m n ≤ MAX m n
   
   [<a name="MIN_MAX_LT-val"><b>MIN_MAX_LT</b></a>]  Theorem
      
      ⊢ ∀m n. MIN m n &lt; MAX m n ⇔ m ≠ n
   
   [<a name="MIN_MAX_PRED-val"><b>MIN_MAX_PRED</b></a>]  Theorem
      
      ⊢ ∀P m n. P m ∧ P n ⇒ P (MIN m n) ∧ P (MAX m n)
   
   [<a name="MODEQ_0-val"><b>MODEQ_0</b></a>]  Theorem
      
      ⊢ 0 &lt; n ⇒ MODEQ n n 0
   
   [<a name="MODEQ_0_CONG-val"><b>MODEQ_0_CONG</b></a>]  Theorem
      
      ⊢ MODEQ 0 m1 m2 ⇔ (m1 = m2)
   
   [<a name="MODEQ_EXP_CONG-val"><b>MODEQ_EXP_CONG</b></a>]  Theorem
      
      ⊢ MODEQ n x y ⇒ MODEQ n (x ** e) (y ** e)
   
   [<a name="MODEQ_INTRO_CONG-val"><b>MODEQ_INTRO_CONG</b></a>]  Theorem
      
      ⊢ 0 &lt; n ⇒ MODEQ n e0 e1 ⇒ (e0 MOD n = e1 MOD n)
   
   [<a name="MODEQ_MOD-val"><b>MODEQ_MOD</b></a>]  Theorem
      
      ⊢ 0 &lt; n ⇒ MODEQ n (x MOD n) x
   
   [<a name="MODEQ_MULT_CONG-val"><b>MODEQ_MULT_CONG</b></a>]  Theorem
      
      ⊢ MODEQ n x0 x1 ⇒ MODEQ n y0 y1 ⇒ MODEQ n (x0 * y0) (x1 * y1)
   
   [<a name="MODEQ_NONZERO_MODEQUALITY-val"><b>MODEQ_NONZERO_MODEQUALITY</b></a>]  Theorem
      
      ⊢ 0 &lt; n ⇒ (MODEQ n m1 m2 ⇔ (m1 MOD n = m2 MOD n))
   
   [<a name="MODEQ_NUMERAL-val"><b>MODEQ_NUMERAL</b></a>]  Theorem
      
      ⊢ (NUMERAL n ≤ NUMERAL m ⇒
         MODEQ (NUMERAL (BIT1 n)) (NUMERAL (BIT1 m))
           (NUMERAL (BIT1 m) MOD NUMERAL (BIT1 n))) ∧
        (NUMERAL n ≤ NUMERAL m ⇒
         MODEQ (NUMERAL (BIT1 n)) (NUMERAL (BIT2 m))
           (NUMERAL (BIT2 m) MOD NUMERAL (BIT1 n))) ∧
        (NUMERAL n ≤ NUMERAL m ⇒
         MODEQ (NUMERAL (BIT2 n)) (NUMERAL (BIT2 m))
           (NUMERAL (BIT2 m) MOD NUMERAL (BIT2 n))) ∧
        (NUMERAL n &lt; NUMERAL m ⇒
         MODEQ (NUMERAL (BIT2 n)) (NUMERAL (BIT1 m))
           (NUMERAL (BIT1 m) MOD NUMERAL (BIT2 n)))
   
   [<a name="MODEQ_PLUS_CONG-val"><b>MODEQ_PLUS_CONG</b></a>]  Theorem
      
      ⊢ MODEQ n x0 x1 ⇒ MODEQ n y0 y1 ⇒ MODEQ n (x0 + y0) (x1 + y1)
   
   [<a name="MODEQ_REFL-val"><b>MODEQ_REFL</b></a>]  Theorem
      
      ⊢ ∀x. MODEQ n x x
   
   [<a name="MODEQ_SUC_CONG-val"><b>MODEQ_SUC_CONG</b></a>]  Theorem
      
      ⊢ MODEQ n x y ⇒ MODEQ n (SUC x) (SUC y)
   
   [<a name="MODEQ_SYM-val"><b>MODEQ_SYM</b></a>]  Theorem
      
      ⊢ MODEQ n x y ⇔ MODEQ n y x
   
   [<a name="MODEQ_THM-val"><b>MODEQ_THM</b></a>]  Theorem
      
      ⊢ MODEQ n m1 m2 ⇔ (n = 0) ∧ (m1 = m2) ∨ 0 &lt; n ∧ (m1 MOD n = m2 MOD n)
   
   [<a name="MODEQ_TRANS-val"><b>MODEQ_TRANS</b></a>]  Theorem
      
      ⊢ ∀x y z. MODEQ n x y ∧ MODEQ n y z ⇒ MODEQ n x z
   
   [<a name="MOD_1-val"><b>MOD_1</b></a>]  Theorem
      
      ⊢ ∀k. k MOD 1 = 0
   
   [<a name="MOD_2-val"><b>MOD_2</b></a>]  Theorem
      
      ⊢ ∀n. n MOD 2 = if EVEN n then 0 else 1
   
   [<a name="MOD_COMMON_FACTOR-val"><b>MOD_COMMON_FACTOR</b></a>]  Theorem
      
      ⊢ ∀n p q. 0 &lt; n ∧ 0 &lt; q ⇒ (n * p MOD q = (n * p) MOD (n * q))
   
   [<a name="MOD_ELIM-val"><b>MOD_ELIM</b></a>]  Theorem
      
      ⊢ ∀P x n. 0 &lt; n ∧ P x ∧ (∀y. P (y + n) ⇒ P y) ⇒ P (x MOD n)
   
   [<a name="MOD_EQ_0-val"><b>MOD_EQ_0</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀k. (k * n) MOD n = 0
   
   [<a name="MOD_EQ_0_DIVISOR-val"><b>MOD_EQ_0_DIVISOR</b></a>]  Theorem
      
      ⊢ 0 &lt; n ⇒ ((k MOD n = 0) ⇔ ∃d. k = d * n)
   
   [<a name="MOD_LESS-val"><b>MOD_LESS</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; n ⇒ m MOD n &lt; n
   
   [<a name="MOD_LESS_EQ-val"><b>MOD_LESS_EQ</b></a>]  Theorem
      
      ⊢ 0 &lt; y ⇒ x MOD y ≤ x
   
   [<a name="MOD_LIFT_PLUS-val"><b>MOD_LIFT_PLUS</b></a>]  Theorem
      
      ⊢ 0 &lt; n ∧ k &lt; n − x MOD n ⇒ ((x + k) MOD n = x MOD n + k)
   
   [<a name="MOD_LIFT_PLUS_IFF-val"><b>MOD_LIFT_PLUS_IFF</b></a>]  Theorem
      
      ⊢ 0 &lt; n ⇒ (((x + k) MOD n = x MOD n + k) ⇔ k &lt; n − x MOD n)
   
   [<a name="MOD_MOD-val"><b>MOD_MOD</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀k. k MOD n MOD n = k MOD n
   
   [<a name="MOD_MULT-val"><b>MOD_MULT</b></a>]  Theorem
      
      ⊢ ∀n r. r &lt; n ⇒ ∀q. (q * n + r) MOD n = r
   
   [<a name="MOD_MULT_MOD-val"><b>MOD_MULT_MOD</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; n ∧ 0 &lt; m ⇒ ∀x. x MOD (n * m) MOD n = x MOD n
   
   [<a name="MOD_ONE-val"><b>MOD_ONE</b></a>]  Theorem
      
      ⊢ ∀k. k MOD SUC 0 = 0
   
   [<a name="MOD_P-val"><b>MOD_P</b></a>]  Theorem
      
      ⊢ ∀P p q. 0 &lt; q ⇒ (P (p MOD q) ⇔ ∃k r. (p = k * q + r) ∧ r &lt; q ∧ P r)
   
   [<a name="MOD_PLUS-val"><b>MOD_PLUS</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀j k. (j MOD n + k MOD n) MOD n = (j + k) MOD n
   
   [<a name="MOD_P_UNIV-val"><b>MOD_P_UNIV</b></a>]  Theorem
      
      ⊢ ∀P m n. 0 &lt; n ⇒ (P (m MOD n) ⇔ ∀q r. (m = q * n + r) ∧ r &lt; n ⇒ P r)
   
   [<a name="MOD_SUB-val"><b>MOD_SUB</b></a>]  Theorem
      
      ⊢ 0 &lt; n ∧ n * q ≤ m ⇒ ((m − n * q) MOD n = m MOD n)
   
   [<a name="MOD_SUC-val"><b>MOD_SUC</b></a>]  Theorem
      
      ⊢ 0 &lt; y ∧ SUC x ≠ SUC (x DIV y) * y ⇒ (SUC x MOD y = SUC (x MOD y))
   
   [<a name="MOD_SUC_IFF-val"><b>MOD_SUC_IFF</b></a>]  Theorem
      
      ⊢ 0 &lt; y ⇒ ((SUC x MOD y = SUC (x MOD y)) ⇔ SUC x ≠ SUC (x DIV y) * y)
   
   [<a name="MOD_TIMES-val"><b>MOD_TIMES</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀q r. (q * n + r) MOD n = r MOD n
   
   [<a name="MOD_TIMES2-val"><b>MOD_TIMES2</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ ∀j k. (j MOD n * k MOD n) MOD n = (j * k) MOD n
   
   [<a name="MOD_TIMES_SUB-val"><b>MOD_TIMES_SUB</b></a>]  Theorem
      
      ⊢ ∀n q r. 0 &lt; n ∧ 0 &lt; q ∧ r ≤ n ⇒ ((q * n − r) MOD n = (n − r) MOD n)
   
   [<a name="MOD_UNIQUE-val"><b>MOD_UNIQUE</b></a>]  Theorem
      
      ⊢ ∀n k r. (∃q. (k = q * n + r) ∧ r &lt; n) ⇒ (k MOD n = r)
   
   [<a name="MULT_0-val"><b>MULT_0</b></a>]  Theorem
      
      ⊢ ∀m. m * 0 = 0
   
   [<a name="MULT_ASSOC-val"><b>MULT_ASSOC</b></a>]  Theorem
      
      ⊢ ∀m n p. m * (n * p) = m * n * p
   
   [<a name="MULT_CLAUSES-val"><b>MULT_CLAUSES</b></a>]  Theorem
      
      ⊢ ∀m n.
            (0 * m = 0) ∧ (m * 0 = 0) ∧ (1 * m = m) ∧ (m * 1 = m) ∧
            (SUC m * n = m * n + n) ∧ (m * SUC n = m + m * n)
   
   [<a name="MULT_COMM-val"><b>MULT_COMM</b></a>]  Theorem
      
      ⊢ ∀m n. m * n = n * m
   
   [<a name="MULT_DIV-val"><b>MULT_DIV</b></a>]  Theorem
      
      ⊢ ∀n q. 0 &lt; n ⇒ (q * n DIV n = q)
   
   [<a name="MULT_EQ_0-val"><b>MULT_EQ_0</b></a>]  Theorem
      
      ⊢ ∀m n. (m * n = 0) ⇔ (m = 0) ∨ (n = 0)
   
   [<a name="MULT_EQ_1-val"><b>MULT_EQ_1</b></a>]  Theorem
      
      ⊢ ∀x y. (x * y = 1) ⇔ (x = 1) ∧ (y = 1)
   
   [<a name="MULT_EQ_DIV-val"><b>MULT_EQ_DIV</b></a>]  Theorem
      
      ⊢ 0 &lt; x ⇒ ((x * y = z) ⇔ (y = z DIV x) ∧ (z MOD x = 0))
   
   [<a name="MULT_EQ_ID-val"><b>MULT_EQ_ID</b></a>]  Theorem
      
      ⊢ ∀m n. (m * n = n) ⇔ (m = 1) ∨ (n = 0)
   
   [<a name="MULT_EXP_MONO-val"><b>MULT_EXP_MONO</b></a>]  Theorem
      
      ⊢ ∀p q n m. (n * SUC q ** p = m * SUC q ** p) ⇔ (n = m)
   
   [<a name="MULT_INCREASES-val"><b>MULT_INCREASES</b></a>]  Theorem
      
      ⊢ ∀m n. 1 &lt; m ∧ 0 &lt; n ⇒ SUC n ≤ m * n
   
   [<a name="MULT_LEFT_1-val"><b>MULT_LEFT_1</b></a>]  Theorem
      
      ⊢ ∀m. 1 * m = m
   
   [<a name="MULT_LESS_EQ_SUC-val"><b>MULT_LESS_EQ_SUC</b></a>]  Theorem
      
      ⊢ ∀m n p. m ≤ n ⇔ SUC p * m ≤ SUC p * n
   
   [<a name="MULT_MONO_EQ-val"><b>MULT_MONO_EQ</b></a>]  Theorem
      
      ⊢ ∀m i n. (SUC n * m = SUC n * i) ⇔ (m = i)
   
   [<a name="MULT_RIGHT_1-val"><b>MULT_RIGHT_1</b></a>]  Theorem
      
      ⊢ ∀m. m * 1 = m
   
   [<a name="MULT_SUC-val"><b>MULT_SUC</b></a>]  Theorem
      
      ⊢ ∀m n. m * SUC n = m + m * n
   
   [<a name="MULT_SUC_EQ-val"><b>MULT_SUC_EQ</b></a>]  Theorem
      
      ⊢ ∀p m n. (n * SUC p = m * SUC p) ⇔ (n = m)
   
   [<a name="MULT_SYM-val"><b>MULT_SYM</b></a>]  Theorem
      
      ⊢ ∀m n. m * n = n * m
   
   [<a name="NORM_0-val"><b>NORM_0</b></a>]  Theorem
      
      ⊢ 0 = 0
   
   [<a name="NOT_EXP_0-val"><b>NOT_EXP_0</b></a>]  Theorem
      
      ⊢ ∀m n. SUC n ** m ≠ 0
   
   [<a name="NOT_GREATER-val"><b>NOT_GREATER</b></a>]  Theorem
      
      ⊢ ∀m n. ¬(m &gt; n) ⇔ m ≤ n
   
   [<a name="NOT_GREATER_EQ-val"><b>NOT_GREATER_EQ</b></a>]  Theorem
      
      ⊢ ∀m n. ¬(m ≥ n) ⇔ SUC m ≤ n
   
   [<a name="NOT_LEQ-val"><b>NOT_LEQ</b></a>]  Theorem
      
      ⊢ ∀m n. ¬(m ≤ n) ⇔ SUC n ≤ m
   
   [<a name="NOT_LESS-val"><b>NOT_LESS</b></a>]  Theorem
      
      ⊢ ∀m n. ¬(m &lt; n) ⇔ n ≤ m
   
   [<a name="NOT_LESS_EQUAL-val"><b>NOT_LESS_EQUAL</b></a>]  Theorem
      
      ⊢ ∀m n. ¬(m ≤ n) ⇔ n &lt; m
   
   [<a name="NOT_LT_ZERO_EQ_ZERO-val"><b>NOT_LT_ZERO_EQ_ZERO</b></a>]  Theorem
      
      ⊢ ∀n. ¬(0 &lt; n) ⇔ (n = 0)
   
   [<a name="NOT_NUM_EQ-val"><b>NOT_NUM_EQ</b></a>]  Theorem
      
      ⊢ ∀m n. m ≠ n ⇔ SUC m ≤ n ∨ SUC n ≤ m
   
   [<a name="NOT_ODD_EQ_EVEN-val"><b>NOT_ODD_EQ_EVEN</b></a>]  Theorem
      
      ⊢ ∀n m. SUC (n + n) ≠ m + m
   
   [<a name="NOT_STRICTLY_DECREASING-val"><b>NOT_STRICTLY_DECREASING</b></a>]  Theorem
      
      ⊢ ∀f. ¬∀n. f (SUC n) &lt; f n
   
   [<a name="NOT_SUC_ADD_LESS_EQ-val"><b>NOT_SUC_ADD_LESS_EQ</b></a>]  Theorem
      
      ⊢ ∀m n. ¬(SUC (m + n) ≤ m)
   
   [<a name="NOT_SUC_LESS_EQ-val"><b>NOT_SUC_LESS_EQ</b></a>]  Theorem
      
      ⊢ ∀n m. ¬(SUC n ≤ m) ⇔ m ≤ n
   
   [<a name="NOT_SUC_LESS_EQ_0-val"><b>NOT_SUC_LESS_EQ_0</b></a>]  Theorem
      
      ⊢ ∀n. ¬(SUC n ≤ 0)
   
   [<a name="NOT_ZERO_LT_ZERO-val"><b>NOT_ZERO_LT_ZERO</b></a>]  Theorem
      
      ⊢ ∀n. n ≠ 0 ⇔ 0 &lt; n
   
   [<a name="NRC_0-val"><b>NRC_0</b></a>]  Theorem
      
      ⊢ ∀R x y. NRC R 0 x y ⇔ (x = y)
   
   [<a name="NRC_1-val"><b>NRC_1</b></a>]  Theorem
      
      ⊢ NRC R 1 x y ⇔ R x y
   
   [<a name="NRC_ADD_E-val"><b>NRC_ADD_E</b></a>]  Theorem
      
      ⊢ ∀m n x z. NRC R (m + n) x z ⇒ ∃y. NRC R m x y ∧ NRC R n y z
   
   [<a name="NRC_ADD_EQN-val"><b>NRC_ADD_EQN</b></a>]  Theorem
      
      ⊢ NRC R (m + n) x z ⇔ ∃y. NRC R m x y ∧ NRC R n y z
   
   [<a name="NRC_ADD_I-val"><b>NRC_ADD_I</b></a>]  Theorem
      
      ⊢ ∀m n x y z. NRC R m x y ∧ NRC R n y z ⇒ NRC R (m + n) x z
   
   [<a name="NRC_RTC-val"><b>NRC_RTC</b></a>]  Theorem
      
      ⊢ ∀n x y. NRC R n x y ⇒ R^* x y
   
   [<a name="NRC_SUC_RECURSE_LEFT-val"><b>NRC_SUC_RECURSE_LEFT</b></a>]  Theorem
      
      ⊢ NRC R (SUC n) x y ⇔ ∃z. NRC R n x z ∧ R z y
   
   [<a name="NUMERAL_MULT_EQ_DIV-val"><b>NUMERAL_MULT_EQ_DIV</b></a>]  Theorem
      
      ⊢ ((NUMERAL (BIT1 x) * y = NUMERAL z) ⇔
         (y = NUMERAL z DIV NUMERAL (BIT1 x)) ∧
         (NUMERAL z MOD NUMERAL (BIT1 x) = 0)) ∧
        ((NUMERAL (BIT2 x) * y = NUMERAL z) ⇔
         (y = NUMERAL z DIV NUMERAL (BIT2 x)) ∧
         (NUMERAL z MOD NUMERAL (BIT2 x) = 0))
   
   [<a name="ODD_ADD-val"><b>ODD_ADD</b></a>]  Theorem
      
      ⊢ ∀m n. ODD (m + n) ⇔ (ODD m ⇎ ODD n)
   
   [<a name="ODD_DOUBLE-val"><b>ODD_DOUBLE</b></a>]  Theorem
      
      ⊢ ∀n. ODD (SUC (2 * n))
   
   [<a name="ODD_EVEN-val"><b>ODD_EVEN</b></a>]  Theorem
      
      ⊢ ∀n. ODD n ⇔ ¬EVEN n
   
   [<a name="ODD_EXISTS-val"><b>ODD_EXISTS</b></a>]  Theorem
      
      ⊢ ∀n. ODD n ⇔ ∃m. n = SUC (2 * m)
   
   [<a name="ODD_EXP-val"><b>ODD_EXP</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; n ∧ ODD m ⇒ ODD (m ** n)
   
   [<a name="ODD_EXP_IFF-val"><b>ODD_EXP_IFF</b></a>]  Theorem
      
      ⊢ ∀n m. ODD (m ** n) ⇔ (n = 0) ∨ ODD m
   
   [<a name="ODD_MULT-val"><b>ODD_MULT</b></a>]  Theorem
      
      ⊢ ∀m n. ODD (m * n) ⇔ ODD m ∧ ODD n
   
   [<a name="ODD_OR_EVEN-val"><b>ODD_OR_EVEN</b></a>]  Theorem
      
      ⊢ ∀n. ∃m. (n = SUC (SUC 0) * m) ∨ (n = SUC (SUC 0) * m + 1)
   
   [<a name="ONE-val"><b>ONE</b></a>]  Theorem
      
      ⊢ 1 = SUC 0
   
   [<a name="ONE_LT_EXP-val"><b>ONE_LT_EXP</b></a>]  Theorem
      
      ⊢ ∀x y. 1 &lt; x ** y ⇔ 1 &lt; x ∧ 0 &lt; y
   
   [<a name="ONE_LT_MULT-val"><b>ONE_LT_MULT</b></a>]  Theorem
      
      ⊢ ∀x y. 1 &lt; x * y ⇔ 0 &lt; x ∧ 1 &lt; y ∨ 0 &lt; y ∧ 1 &lt; x
   
   [<a name="ONE_LT_MULT_IMP-val"><b>ONE_LT_MULT_IMP</b></a>]  Theorem
      
      ⊢ ∀p q. 1 &lt; p ∧ 0 &lt; q ⇒ 1 &lt; p * q
   
   [<a name="ONE_MOD-val"><b>ONE_MOD</b></a>]  Theorem
      
      ⊢ 1 &lt; n ⇒ (1 MOD n = 1)
   
   [<a name="ONE_MOD_IFF-val"><b>ONE_MOD_IFF</b></a>]  Theorem
      
      ⊢ 1 &lt; n ⇔ 0 &lt; n ∧ (1 MOD n = 1)
   
   [<a name="ONE_ONE_INV_IMAGE_BOUNDED-val"><b>ONE_ONE_INV_IMAGE_BOUNDED</b></a>]  Theorem
      
      ⊢ ONE_ONE f ⇒ ∀b. ∃a. ∀x. f x ≤ b ⇒ x ≤ a
   
   [<a name="ONE_ONE_UNBOUNDED-val"><b>ONE_ONE_UNBOUNDED</b></a>]  Theorem
      
      ⊢ ∀f. ONE_ONE f ⇒ ∀b. ∃n. b &lt; f n
   
   [<a name="OR_LESS-val"><b>OR_LESS</b></a>]  Theorem
      
      ⊢ ∀m n. SUC m ≤ n ⇒ m &lt; n
   
   [<a name="PRE_ELIM_THM-val"><b>PRE_ELIM_THM</b></a>]  Theorem
      
      ⊢ P (PRE n) ⇔ ∀m. ((n = 0) ⇒ P 0) ∧ ((n = SUC m) ⇒ P m)
   
   [<a name="PRE_LESS_EQ-val"><b>PRE_LESS_EQ</b></a>]  Theorem
      
      ⊢ ∀n. m ≤ n ⇒ PRE m ≤ PRE n
   
   [<a name="PRE_SUB-val"><b>PRE_SUB</b></a>]  Theorem
      
      ⊢ ∀m n. PRE (m − n) = PRE m − n
   
   [<a name="PRE_SUB1-val"><b>PRE_SUB1</b></a>]  Theorem
      
      ⊢ ∀m. PRE m = m − 1
   
   [<a name="PRE_SUC_EQ-val"><b>PRE_SUC_EQ</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; n ⇒ ((m = PRE n) ⇔ (SUC m = n))
   
   [<a name="RIGHT_ADD_DISTRIB-val"><b>RIGHT_ADD_DISTRIB</b></a>]  Theorem
      
      ⊢ ∀m n p. (m + n) * p = m * p + n * p
   
   [<a name="RIGHT_SUB_DISTRIB-val"><b>RIGHT_SUB_DISTRIB</b></a>]  Theorem
      
      ⊢ ∀m n p. (m − n) * p = m * p − n * p
   
   [<a name="RTC_NRC-val"><b>RTC_NRC</b></a>]  Theorem
      
      ⊢ ∀x y. R^* x y ⇒ ∃n. NRC R n x y
   
   [<a name="RTC_eq_NRC-val"><b>RTC_eq_NRC</b></a>]  Theorem
      
      ⊢ ∀R x y. R^* x y ⇔ ∃n. NRC R n x y
   
   [<a name="STRICTLY_INCREASING_ONE_ONE-val"><b>STRICTLY_INCREASING_ONE_ONE</b></a>]  Theorem
      
      ⊢ ∀f. (∀n. f n &lt; f (SUC n)) ⇒ ONE_ONE f
   
   [<a name="STRICTLY_INCREASING_TC-val"><b>STRICTLY_INCREASING_TC</b></a>]  Theorem
      
      ⊢ ∀f. (∀n. f n &lt; f (SUC n)) ⇒ ∀m n. m &lt; n ⇒ f m &lt; f n
   
   [<a name="STRICTLY_INCREASING_UNBOUNDED-val"><b>STRICTLY_INCREASING_UNBOUNDED</b></a>]  Theorem
      
      ⊢ ∀f. (∀n. f n &lt; f (SUC n)) ⇒ ∀b. ∃n. b &lt; f n
   
   [<a name="SUB_0-val"><b>SUB_0</b></a>]  Theorem
      
      ⊢ ∀m. (0 − m = 0) ∧ (m − 0 = m)
   
   [<a name="SUB_ADD-val"><b>SUB_ADD</b></a>]  Theorem
      
      ⊢ ∀m n. n ≤ m ⇒ (m − n + n = m)
   
   [<a name="SUB_CANCEL-val"><b>SUB_CANCEL</b></a>]  Theorem
      
      ⊢ ∀p n m. n ≤ p ∧ m ≤ p ⇒ ((p − n = p − m) ⇔ (n = m))
   
   [<a name="SUB_ELIM_THM-val"><b>SUB_ELIM_THM</b></a>]  Theorem
      
      ⊢ P (a − b) ⇔ ∀d. ((b = a + d) ⇒ P 0) ∧ ((a = b + d) ⇒ P d)
   
   [<a name="SUB_EQUAL_0-val"><b>SUB_EQUAL_0</b></a>]  Theorem
      
      ⊢ ∀c. c − c = 0
   
   [<a name="SUB_EQ_0-val"><b>SUB_EQ_0</b></a>]  Theorem
      
      ⊢ ∀m n. (m − n = 0) ⇔ m ≤ n
   
   [<a name="SUB_EQ_EQ_0-val"><b>SUB_EQ_EQ_0</b></a>]  Theorem
      
      ⊢ ∀m n. (m − n = m) ⇔ (m = 0) ∨ (n = 0)
   
   [<a name="SUB_LEFT_ADD-val"><b>SUB_LEFT_ADD</b></a>]  Theorem
      
      ⊢ ∀m n p. m + (n − p) = if n ≤ p then m else m + n − p
   
   [<a name="SUB_LEFT_EQ-val"><b>SUB_LEFT_EQ</b></a>]  Theorem
      
      ⊢ ∀m n p. (m = n − p) ⇔ (m + p = n) ∨ m ≤ 0 ∧ n ≤ p
   
   [<a name="SUB_LEFT_GREATER-val"><b>SUB_LEFT_GREATER</b></a>]  Theorem
      
      ⊢ ∀m n p. m &gt; n − p ⇔ m + p &gt; n ∧ m &gt; 0
   
   [<a name="SUB_LEFT_GREATER_EQ-val"><b>SUB_LEFT_GREATER_EQ</b></a>]  Theorem
      
      ⊢ ∀m n p. m ≥ n − p ⇔ m + p ≥ n
   
   [<a name="SUB_LEFT_LESS-val"><b>SUB_LEFT_LESS</b></a>]  Theorem
      
      ⊢ ∀m n p. m &lt; n − p ⇔ m + p &lt; n
   
   [<a name="SUB_LEFT_LESS_EQ-val"><b>SUB_LEFT_LESS_EQ</b></a>]  Theorem
      
      ⊢ ∀m n p. m ≤ n − p ⇔ m + p ≤ n ∨ m ≤ 0
   
   [<a name="SUB_LEFT_SUB-val"><b>SUB_LEFT_SUB</b></a>]  Theorem
      
      ⊢ ∀m n p. m − (n − p) = if n ≤ p then m else m + p − n
   
   [<a name="SUB_LEFT_SUC-val"><b>SUB_LEFT_SUC</b></a>]  Theorem
      
      ⊢ ∀m n. SUC (m − n) = if m ≤ n then SUC 0 else SUC m − n
   
   [<a name="SUB_LESS-val"><b>SUB_LESS</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; n ∧ n ≤ m ⇒ m − n &lt; m
   
   [<a name="SUB_LESS_0-val"><b>SUB_LESS_0</b></a>]  Theorem
      
      ⊢ ∀n m. m &lt; n ⇔ 0 &lt; n − m
   
   [<a name="SUB_LESS_EQ-val"><b>SUB_LESS_EQ</b></a>]  Theorem
      
      ⊢ ∀n m. n − m ≤ n
   
   [<a name="SUB_LESS_EQ_ADD-val"><b>SUB_LESS_EQ_ADD</b></a>]  Theorem
      
      ⊢ ∀m p. m ≤ p ⇒ ∀n. p − m ≤ n ⇔ p ≤ m + n
   
   [<a name="SUB_LESS_OR-val"><b>SUB_LESS_OR</b></a>]  Theorem
      
      ⊢ ∀m n. n &lt; m ⇒ n ≤ m − 1
   
   [<a name="SUB_LESS_SUC-val"><b>SUB_LESS_SUC</b></a>]  Theorem
      
      ⊢ ∀p m. p − m &lt; SUC p
   
   [<a name="SUB_MOD-val"><b>SUB_MOD</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; n ∧ n ≤ m ⇒ ((m − n) MOD n = m MOD n)
   
   [<a name="SUB_MONO_EQ-val"><b>SUB_MONO_EQ</b></a>]  Theorem
      
      ⊢ ∀n m. SUC n − SUC m = n − m
   
   [<a name="SUB_PLUS-val"><b>SUB_PLUS</b></a>]  Theorem
      
      ⊢ ∀a b c. a − (b + c) = a − b − c
   
   [<a name="SUB_RIGHT_ADD-val"><b>SUB_RIGHT_ADD</b></a>]  Theorem
      
      ⊢ ∀m n p. m − n + p = if m ≤ n then p else m + p − n
   
   [<a name="SUB_RIGHT_EQ-val"><b>SUB_RIGHT_EQ</b></a>]  Theorem
      
      ⊢ ∀m n p. (m − n = p) ⇔ (m = n + p) ∨ m ≤ n ∧ p ≤ 0
   
   [<a name="SUB_RIGHT_GREATER-val"><b>SUB_RIGHT_GREATER</b></a>]  Theorem
      
      ⊢ ∀m n p. m − n &gt; p ⇔ m &gt; n + p
   
   [<a name="SUB_RIGHT_GREATER_EQ-val"><b>SUB_RIGHT_GREATER_EQ</b></a>]  Theorem
      
      ⊢ ∀m n p. m − n ≥ p ⇔ m ≥ n + p ∨ 0 ≥ p
   
   [<a name="SUB_RIGHT_LESS-val"><b>SUB_RIGHT_LESS</b></a>]  Theorem
      
      ⊢ ∀m n p. m − n &lt; p ⇔ m &lt; n + p ∧ 0 &lt; p
   
   [<a name="SUB_RIGHT_LESS_EQ-val"><b>SUB_RIGHT_LESS_EQ</b></a>]  Theorem
      
      ⊢ ∀m n p. m − n ≤ p ⇔ m ≤ n + p
   
   [<a name="SUB_RIGHT_SUB-val"><b>SUB_RIGHT_SUB</b></a>]  Theorem
      
      ⊢ ∀m n p. m − n − p = m − (n + p)
   
   [<a name="SUB_SUB-val"><b>SUB_SUB</b></a>]  Theorem
      
      ⊢ ∀b c. c ≤ b ⇒ ∀a. a − (b − c) = a + c − b
   
   [<a name="SUC_ADD_SYM-val"><b>SUC_ADD_SYM</b></a>]  Theorem
      
      ⊢ ∀m n. SUC (m + n) = SUC n + m
   
   [<a name="SUC_ELIM_NUMERALS-val"><b>SUC_ELIM_NUMERALS</b></a>]  Theorem
      
      ⊢ ∀f g.
            (∀n. g (SUC n) = f n (SUC n)) ⇔
            (∀n.
                 g (NUMERAL (BIT1 n)) =
                 f (NUMERAL (BIT1 n) − 1) (NUMERAL (BIT1 n))) ∧
            ∀n.
                g (NUMERAL (BIT2 n)) =
                f (NUMERAL (BIT1 n)) (NUMERAL (BIT2 n))
   
   [<a name="SUC_ELIM_THM-val"><b>SUC_ELIM_THM</b></a>]  Theorem
      
      ⊢ ∀P. (∀n. P (SUC n) n) ⇔ ∀n. 0 &lt; n ⇒ P n (n − 1)
   
   [<a name="SUC_MOD-val"><b>SUC_MOD</b></a>]  Theorem
      
      ⊢ ∀n a b. 0 &lt; n ⇒ ((SUC a MOD n = SUC b MOD n) ⇔ (a MOD n = b MOD n))
   
   [<a name="SUC_NOT-val"><b>SUC_NOT</b></a>]  Theorem
      
      ⊢ ∀n. 0 ≠ SUC n
   
   [<a name="SUC_ONE_ADD-val"><b>SUC_ONE_ADD</b></a>]  Theorem
      
      ⊢ ∀n. SUC n = 1 + n
   
   [<a name="SUC_PRE-val"><b>SUC_PRE</b></a>]  Theorem
      
      ⊢ 0 &lt; m ⇔ (SUC (PRE m) = m)
   
   [<a name="SUC_SUB-val"><b>SUC_SUB</b></a>]  Theorem
      
      ⊢ ∀a. SUC a − a = 1
   
   [<a name="SUC_SUB1-val"><b>SUC_SUB1</b></a>]  Theorem
      
      ⊢ ∀m. SUC m − 1 = m
   
   [<a name="TC_eq_NRC-val"><b>TC_eq_NRC</b></a>]  Theorem
      
      ⊢ ∀R x y. R⁺ x y ⇔ ∃n. NRC R (SUC n) x y
   
   [<a name="TIMES2-val"><b>TIMES2</b></a>]  Theorem
      
      ⊢ ∀n. 2 * n = n + n
   
   [<a name="TWO-val"><b>TWO</b></a>]  Theorem
      
      ⊢ 2 = SUC 1
   
   [<a name="WOP-val"><b>WOP</b></a>]  Theorem
      
      ⊢ ∀P. (∃n. P n) ⇒ ∃n. P n ∧ ∀m. m &lt; n ⇒ ¬P m
   
   [<a name="X_LE_DIV-val"><b>X_LE_DIV</b></a>]  Theorem
      
      ⊢ ∀x y z. 0 &lt; z ⇒ (x ≤ y DIV z ⇔ x * z ≤ y)
   
   [<a name="X_LE_X_EXP-val"><b>X_LE_X_EXP</b></a>]  Theorem
      
      ⊢ 0 &lt; n ⇒ x ≤ x ** n
   
   [<a name="X_LT_DIV-val"><b>X_LT_DIV</b></a>]  Theorem
      
      ⊢ ∀x y z. 0 &lt; z ⇒ (x &lt; y DIV z ⇔ (x + 1) * z ≤ y)
   
   [<a name="X_LT_EXP_X-val"><b>X_LT_EXP_X</b></a>]  Theorem
      
      ⊢ 1 &lt; b ⇒ x &lt; b ** x
   
   [<a name="X_LT_EXP_X_IFF-val"><b>X_LT_EXP_X_IFF</b></a>]  Theorem
      
      ⊢ x &lt; b ** x ⇔ 1 &lt; b ∨ (x = 0)
   
   [<a name="X_MOD_Y_EQ_X-val"><b>X_MOD_Y_EQ_X</b></a>]  Theorem
      
      ⊢ ∀x y. 0 &lt; y ⇒ ((x MOD y = x) ⇔ x &lt; y)
   
   [<a name="ZERO_DIV-val"><b>ZERO_DIV</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ (0 DIV n = 0)
   
   [<a name="ZERO_EXP-val"><b>ZERO_EXP</b></a>]  Theorem
      
      ⊢ 0 ** x = if x = 0 then 1 else 0
   
   [<a name="ZERO_LESS_ADD-val"><b>ZERO_LESS_ADD</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m + n ⇔ 0 &lt; m ∨ 0 &lt; n
   
   [<a name="ZERO_LESS_EQ-val"><b>ZERO_LESS_EQ</b></a>]  Theorem
      
      ⊢ ∀n. 0 ≤ n
   
   [<a name="ZERO_LESS_EXP-val"><b>ZERO_LESS_EXP</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; SUC n ** m
   
   [<a name="ZERO_LESS_MULT-val"><b>ZERO_LESS_MULT</b></a>]  Theorem
      
      ⊢ ∀m n. 0 &lt; m * n ⇔ 0 &lt; m ∧ 0 &lt; n
   
   [<a name="ZERO_LT_EXP-val"><b>ZERO_LT_EXP</b></a>]  Theorem
      
      ⊢ 0 &lt; x ** y ⇔ 0 &lt; x ∨ (y = 0)
   
   [<a name="ZERO_MOD-val"><b>ZERO_MOD</b></a>]  Theorem
      
      ⊢ ∀n. 0 &lt; n ⇒ (0 MOD n = 0)
   
   [<a name="datatype_num-val"><b>datatype_num</b></a>]  Theorem
      
      ⊢ DATATYPE (num 0 SUC)
   
   [<a name="findq_divisor-val"><b>findq_divisor</b></a>]  Theorem
      
      ⊢ n ≤ m ⇒ findq (a,m,n) * n ≤ a * m
   
   [<a name="findq_eq_0-val"><b>findq_eq_0</b></a>]  Theorem
      
      ⊢ ∀a m n. (findq (a,m,n) = 0) ⇔ (a = 0)
   
   [<a name="findq_thm-val"><b>findq_thm</b></a>]  Theorem
      
      ⊢ findq (a,m,n) =
        if n = 0 then a
        else (let d = 2 * n in if m &lt; d then a else findq (2 * a,m,d))
   
   [<a name="num_CASES-val"><b>num_CASES</b></a>]  Theorem
      
      ⊢ ∀m. (m = 0) ∨ ∃n. m = SUC n
   
   [<a name="num_case_compute-val"><b>num_case_compute</b></a>]  Theorem
      
      ⊢ ∀n. num_CASE n f g = if n = 0 then f else g (PRE n)
   
   [<a name="num_case_cong-val"><b>num_case_cong</b></a>]  Theorem
      
      ⊢ ∀M M' v f.
            (M = M') ∧ ((M' = 0) ⇒ (v = v')) ∧
            (∀n. (M' = SUC n) ⇒ (f n = f' n)) ⇒
            (num_CASE M v f = num_CASE M' v' f')
   
   [<a name="num_case_eq-val"><b>num_case_eq</b></a>]  Theorem
      
      ⊢ (num_CASE n zc sc = v) ⇔
        (n = 0) ∧ (zc = v) ∨ ∃x. (n = SUC x) ∧ (sc x = v)
   
   [<a name="transitive_LESS-val"><b>transitive_LESS</b></a>]  Theorem
      
      ⊢ transitive $&lt;
   
   [<a name="transitive_measure-val"><b>transitive_measure</b></a>]  Theorem
      
      ⊢ ∀f. transitive (measure f)
   
   [<a name="transitive_monotone-val"><b>transitive_monotone</b></a>]  Theorem
      
      ⊢ ∀R f.
            transitive R ∧ (∀n. R (f n) (f (SUC n))) ⇒
            ∀m n. m &lt; n ⇒ R (f m) (f n)
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/num/theories/arithmeticScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-11</a></em></p></body></html>
