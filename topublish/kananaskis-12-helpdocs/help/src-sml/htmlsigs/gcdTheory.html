<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure gcdTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure gcdTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/num/extra_theories/gcdScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature gcdTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>  
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#is_gcd_def-val">is_gcd_def</a> : thm
<a name="line7"></a>    val <a href="#lcm_def-val">lcm_def</a> : thm
<a name="line8"></a>  
<a name="line9"></a>  (*  Theorems  *)
<a name="line10"></a>    val <a href="#BINARY_GCD-val">BINARY_GCD</a> : thm
<a name="line11"></a>    val <a href="#FACTOR_OUT_GCD-val">FACTOR_OUT_GCD</a> : thm
<a name="line12"></a>    val <a href="#GCD_0L-val">GCD_0L</a> : thm
<a name="line13"></a>    val <a href="#GCD_0R-val">GCD_0R</a> : thm
<a name="line14"></a>    val <a href="#GCD_1-val">GCD_1</a> : thm
<a name="line15"></a>    val <a href="#GCD_ADD_L-val">GCD_ADD_L</a> : thm
<a name="line16"></a>    val <a href="#GCD_ADD_L_THM-val">GCD_ADD_L_THM</a> : thm
<a name="line17"></a>    val <a href="#GCD_ADD_R-val">GCD_ADD_R</a> : thm
<a name="line18"></a>    val <a href="#GCD_ADD_R_THM-val">GCD_ADD_R_THM</a> : thm
<a name="line19"></a>    val <a href="#GCD_CANCEL_MULT-val">GCD_CANCEL_MULT</a> : thm
<a name="line20"></a>    val <a href="#GCD_COMMON_FACTOR-val">GCD_COMMON_FACTOR</a> : thm
<a name="line21"></a>    val <a href="#GCD_EFFICIENTLY-val">GCD_EFFICIENTLY</a> : thm
<a name="line22"></a>    val <a href="#GCD_EQ_0-val">GCD_EQ_0</a> : thm
<a name="line23"></a>    val <a href="#GCD_IS_GCD-val">GCD_IS_GCD</a> : thm
<a name="line24"></a>    val <a href="#GCD_IS_GREATEST_COMMON_DIVISOR-val">GCD_IS_GREATEST_COMMON_DIVISOR</a> : thm
<a name="line25"></a>    val <a href="#GCD_REF-val">GCD_REF</a> : thm
<a name="line26"></a>    val <a href="#GCD_SUCfree_ind-val">GCD_SUCfree_ind</a> : thm
<a name="line27"></a>    val <a href="#GCD_SYM-val">GCD_SYM</a> : thm
<a name="line28"></a>    val <a href="#IS_GCD_0L-val">IS_GCD_0L</a> : thm
<a name="line29"></a>    val <a href="#IS_GCD_0R-val">IS_GCD_0R</a> : thm
<a name="line30"></a>    val <a href="#IS_GCD_MINUS_L-val">IS_GCD_MINUS_L</a> : thm
<a name="line31"></a>    val <a href="#IS_GCD_MINUS_R-val">IS_GCD_MINUS_R</a> : thm
<a name="line32"></a>    val <a href="#IS_GCD_REF-val">IS_GCD_REF</a> : thm
<a name="line33"></a>    val <a href="#IS_GCD_SYM-val">IS_GCD_SYM</a> : thm
<a name="line34"></a>    val <a href="#IS_GCD_UNIQUE-val">IS_GCD_UNIQUE</a> : thm
<a name="line35"></a>    val <a href="#LCM_0-val">LCM_0</a> : thm
<a name="line36"></a>    val <a href="#LCM_1-val">LCM_1</a> : thm
<a name="line37"></a>    val <a href="#LCM_COMM-val">LCM_COMM</a> : thm
<a name="line38"></a>    val <a href="#LCM_IS_LEAST_COMMON_MULTIPLE-val">LCM_IS_LEAST_COMMON_MULTIPLE</a> : thm
<a name="line39"></a>    val <a href="#LCM_LE-val">LCM_LE</a> : thm
<a name="line40"></a>    val <a href="#LCM_LEAST-val">LCM_LEAST</a> : thm
<a name="line41"></a>    val <a href="#LINEAR_GCD-val">LINEAR_GCD</a> : thm
<a name="line42"></a>    val <a href="#L_EUCLIDES-val">L_EUCLIDES</a> : thm
<a name="line43"></a>    val <a href="#PRIME_GCD-val">PRIME_GCD</a> : thm
<a name="line44"></a>    val <a href="#PRIME_IS_GCD-val">PRIME_IS_GCD</a> : thm
<a name="line45"></a>    val <a href="#P_EUCLIDES-val">P_EUCLIDES</a> : thm
<a name="line46"></a>    val <a href="#gcd_def-val">gcd_def</a> : thm
<a name="line47"></a>    val <a href="#gcd_def_compute-val">gcd_def_compute</a> : thm
<a name="line48"></a>    val <a href="#gcd_ind-val">gcd_ind</a> : thm
<a name="line49"></a>  
<a name="line50"></a>  val gcd_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line51"></a>(*
   [basicSize] Parent theory of "gcd"
   
   [divides] Parent theory of "gcd"
   
   [<a name="is_gcd_def-val"><b>is_gcd_def</b></a>]  Definition
      
      ⊢ ∀a b c.
            is_gcd a b c ⇔
            divides c a ∧ divides c b ∧
            ∀d. divides d a ∧ divides d b ⇒ divides d c
   
   [<a name="lcm_def-val"><b>lcm_def</b></a>]  Definition
      
      ⊢ ∀m n. lcm m n = if (m = 0) ∨ (n = 0) then 0 else m * n DIV gcd m n
   
   [<a name="BINARY_GCD-val"><b>BINARY_GCD</b></a>]  Theorem
      
      ⊢ ∀m n.
            (EVEN m ∧ EVEN n ⇒ (gcd m n = 2 * gcd (m DIV 2) (n DIV 2))) ∧
            (EVEN m ∧ ODD n ⇒ (gcd m n = gcd (m DIV 2) n))
   
   [<a name="FACTOR_OUT_GCD-val"><b>FACTOR_OUT_GCD</b></a>]  Theorem
      
      ⊢ ∀n m.
            n ≠ 0 ∧ m ≠ 0 ⇒
            ∃p q. (n = p * gcd n m) ∧ (m = q * gcd n m) ∧ (gcd p q = 1)
   
   [<a name="GCD_0L-val"><b>GCD_0L</b></a>]  Theorem
      
      ⊢ ∀a. gcd 0 a = a
   
   [<a name="GCD_0R-val"><b>GCD_0R</b></a>]  Theorem
      
      ⊢ ∀a. gcd a 0 = a
   
   [<a name="GCD_1-val"><b>GCD_1</b></a>]  Theorem
      
      ⊢ (gcd 1 x = 1) ∧ (gcd x 1 = 1)
   
   [<a name="GCD_ADD_L-val"><b>GCD_ADD_L</b></a>]  Theorem
      
      ⊢ ∀a b. gcd (a + b) a = gcd a b
   
   [<a name="GCD_ADD_L_THM-val"><b>GCD_ADD_L_THM</b></a>]  Theorem
      
      ⊢ (∀a b. gcd (a + b) a = gcd a b) ∧ ∀a b. gcd (b + a) a = gcd a b
   
   [<a name="GCD_ADD_R-val"><b>GCD_ADD_R</b></a>]  Theorem
      
      ⊢ ∀a b. gcd a (a + b) = gcd a b
   
   [<a name="GCD_ADD_R_THM-val"><b>GCD_ADD_R_THM</b></a>]  Theorem
      
      ⊢ (∀a b. gcd a (a + b) = gcd a b) ∧ ∀a b. gcd a (b + a) = gcd a b
   
   [<a name="GCD_CANCEL_MULT-val"><b>GCD_CANCEL_MULT</b></a>]  Theorem
      
      ⊢ ∀m n k. (gcd m k = 1) ⇒ (gcd m (k * n) = gcd m n)
   
   [<a name="GCD_COMMON_FACTOR-val"><b>GCD_COMMON_FACTOR</b></a>]  Theorem
      
      ⊢ ∀m n k. gcd (k * m) (k * n) = k * gcd m n
   
   [<a name="GCD_EFFICIENTLY-val"><b>GCD_EFFICIENTLY</b></a>]  Theorem
      
      ⊢ ∀a b. gcd a b = if a = 0 then b else gcd (b MOD a) a
   
   [<a name="GCD_EQ_0-val"><b>GCD_EQ_0</b></a>]  Theorem
      
      ⊢ ∀n m. (gcd n m = 0) ⇔ (n = 0) ∧ (m = 0)
   
   [<a name="GCD_IS_GCD-val"><b>GCD_IS_GCD</b></a>]  Theorem
      
      ⊢ ∀a b. is_gcd a b (gcd a b)
   
   [<a name="GCD_IS_GREATEST_COMMON_DIVISOR-val"><b>GCD_IS_GREATEST_COMMON_DIVISOR</b></a>]  Theorem
      
      ⊢ ∀a b.
            divides (gcd a b) a ∧ divides (gcd a b) b ∧
            ∀d. divides d a ∧ divides d b ⇒ divides d (gcd a b)
   
   [<a name="GCD_REF-val"><b>GCD_REF</b></a>]  Theorem
      
      ⊢ ∀a. gcd a a = a
   
   [<a name="GCD_SUCfree_ind-val"><b>GCD_SUCfree_ind</b></a>]  Theorem
      
      ⊢ ∀P.
            (∀y. P 0 y) ∧ (∀x y. P x y ⇒ P y x) ∧ (∀x. P x x) ∧
            (∀x y. 0 &lt; x ∧ 0 &lt; y ∧ P x y ⇒ P x (x + y)) ⇒
            ∀m n. P m n
   
   [<a name="GCD_SYM-val"><b>GCD_SYM</b></a>]  Theorem
      
      ⊢ ∀a b. gcd a b = gcd b a
   
   [<a name="IS_GCD_0L-val"><b>IS_GCD_0L</b></a>]  Theorem
      
      ⊢ ∀a. is_gcd 0 a a
   
   [<a name="IS_GCD_0R-val"><b>IS_GCD_0R</b></a>]  Theorem
      
      ⊢ ∀a. is_gcd a 0 a
   
   [<a name="IS_GCD_MINUS_L-val"><b>IS_GCD_MINUS_L</b></a>]  Theorem
      
      ⊢ ∀a b c. b ≤ a ∧ is_gcd (a − b) b c ⇒ is_gcd a b c
   
   [<a name="IS_GCD_MINUS_R-val"><b>IS_GCD_MINUS_R</b></a>]  Theorem
      
      ⊢ ∀a b c. a ≤ b ∧ is_gcd a (b − a) c ⇒ is_gcd a b c
   
   [<a name="IS_GCD_REF-val"><b>IS_GCD_REF</b></a>]  Theorem
      
      ⊢ ∀a. is_gcd a a a
   
   [<a name="IS_GCD_SYM-val"><b>IS_GCD_SYM</b></a>]  Theorem
      
      ⊢ ∀a b c. is_gcd a b c ⇔ is_gcd b a c
   
   [<a name="IS_GCD_UNIQUE-val"><b>IS_GCD_UNIQUE</b></a>]  Theorem
      
      ⊢ ∀a b c d. is_gcd a b c ∧ is_gcd a b d ⇒ (c = d)
   
   [<a name="LCM_0-val"><b>LCM_0</b></a>]  Theorem
      
      ⊢ (lcm 0 x = 0) ∧ (lcm x 0 = 0)
   
   [<a name="LCM_1-val"><b>LCM_1</b></a>]  Theorem
      
      ⊢ (lcm 1 x = x) ∧ (lcm x 1 = x)
   
   [<a name="LCM_COMM-val"><b>LCM_COMM</b></a>]  Theorem
      
      ⊢ lcm a b = lcm b a
   
   [<a name="LCM_IS_LEAST_COMMON_MULTIPLE-val"><b>LCM_IS_LEAST_COMMON_MULTIPLE</b></a>]  Theorem
      
      ⊢ divides m (lcm m n) ∧ divides n (lcm m n) ∧
        ∀p. divides m p ∧ divides n p ⇒ divides (lcm m n) p
   
   [<a name="LCM_LE-val"><b>LCM_LE</b></a>]  Theorem
      
      ⊢ 0 &lt; m ∧ 0 &lt; n ⇒ m ≤ lcm m n ∧ m ≤ lcm n m
   
   [<a name="LCM_LEAST-val"><b>LCM_LEAST</b></a>]  Theorem
      
      ⊢ 0 &lt; m ∧ 0 &lt; n ⇒
        ∀p. 0 &lt; p ∧ p &lt; lcm m n ⇒ ¬divides m p ∨ ¬divides n p
   
   [<a name="LINEAR_GCD-val"><b>LINEAR_GCD</b></a>]  Theorem
      
      ⊢ ∀n m. n ≠ 0 ⇒ ∃p q. p * n = q * m + gcd m n
   
   [<a name="L_EUCLIDES-val"><b>L_EUCLIDES</b></a>]  Theorem
      
      ⊢ ∀a b c. (gcd a b = 1) ∧ divides b (a * c) ⇒ divides b c
   
   [<a name="PRIME_GCD-val"><b>PRIME_GCD</b></a>]  Theorem
      
      ⊢ ∀p b. prime p ⇒ divides p b ∨ (gcd p b = 1)
   
   [<a name="PRIME_IS_GCD-val"><b>PRIME_IS_GCD</b></a>]  Theorem
      
      ⊢ ∀p b. prime p ⇒ divides p b ∨ is_gcd p b 1
   
   [<a name="P_EUCLIDES-val"><b>P_EUCLIDES</b></a>]  Theorem
      
      ⊢ ∀p a b. prime p ∧ divides p (a * b) ⇒ divides p a ∨ divides p b
   
   [<a name="gcd_def-val"><b>gcd_def</b></a>]  Theorem
      
      ⊢ (∀y. gcd 0 y = y) ∧ (∀x. gcd (SUC x) 0 = SUC x) ∧
        ∀y x.
            gcd (SUC x) (SUC y) =
            if y ≤ x then gcd (x − y) (SUC y)
            else gcd (SUC x) (y − x)
   
   [<a name="gcd_def_compute-val"><b>gcd_def_compute</b></a>]  Theorem
      
      ⊢ (∀y. gcd 0 y = y) ∧
        (∀x. gcd (NUMERAL (BIT1 x)) 0 = NUMERAL (BIT1 x)) ∧
        (∀x. gcd (NUMERAL (BIT2 x)) 0 = NUMERAL (BIT2 x)) ∧
        (∀y x.
             gcd (NUMERAL (BIT1 x)) (NUMERAL (BIT1 y)) =
             if NUMERAL (BIT1 y) − 1 ≤ NUMERAL (BIT1 x) − 1 then
               gcd (NUMERAL (BIT1 x) − 1 − (NUMERAL (BIT1 y) − 1))
                 (NUMERAL (BIT1 y))
             else
               gcd (NUMERAL (BIT1 x))
                 (NUMERAL (BIT1 y) − 1 − (NUMERAL (BIT1 x) − 1))) ∧
        (∀y x.
             gcd (NUMERAL (BIT2 x)) (NUMERAL (BIT1 y)) =
             if NUMERAL (BIT1 y) − 1 ≤ NUMERAL (BIT1 x) then
               gcd (NUMERAL (BIT1 x) − (NUMERAL (BIT1 y) − 1))
                 (NUMERAL (BIT1 y))
             else
               gcd (NUMERAL (BIT2 x))
                 (NUMERAL (BIT1 y) − 1 − NUMERAL (BIT1 x))) ∧
        (∀y x.
             gcd (NUMERAL (BIT1 x)) (NUMERAL (BIT2 y)) =
             if NUMERAL (BIT1 y) ≤ NUMERAL (BIT1 x) − 1 then
               gcd (NUMERAL (BIT1 x) − 1 − NUMERAL (BIT1 y))
                 (NUMERAL (BIT2 y))
             else
               gcd (NUMERAL (BIT1 x))
                 (NUMERAL (BIT1 y) − (NUMERAL (BIT1 x) − 1))) ∧
        ∀y x.
            gcd (NUMERAL (BIT2 x)) (NUMERAL (BIT2 y)) =
            if NUMERAL (BIT1 y) ≤ NUMERAL (BIT1 x) then
              gcd (NUMERAL (BIT1 x) − NUMERAL (BIT1 y)) (NUMERAL (BIT2 y))
            else
              gcd (NUMERAL (BIT2 x)) (NUMERAL (BIT1 y) − NUMERAL (BIT1 x))
   
   [<a name="gcd_ind-val"><b>gcd_ind</b></a>]  Theorem
      
      ⊢ ∀P.
            (∀y. P 0 y) ∧ (∀x. P (SUC x) 0) ∧
            (∀x y.
                 (¬(y ≤ x) ⇒ P (SUC x) (y − x)) ∧
                 (y ≤ x ⇒ P (x − y) (SUC y)) ⇒
                 P (SUC x) (SUC y)) ⇒
            ∀v v1. P v v1
   
   
*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/num/extra_theories/gcdScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-11</a></em></p></body></html>
