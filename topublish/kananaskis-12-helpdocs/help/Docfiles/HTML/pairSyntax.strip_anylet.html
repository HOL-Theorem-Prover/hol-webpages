<!DOCTYPE HTML PUBLIC "-//W32//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML>
<HEAD>
<meta http-equiv="content-type" content="text/html ; charset=US-ASCII">
<TITLE>pairSyntax.strip_anylet</TITLE>
<LINK REL = "STYLESHEET" HREF = "../doc.css" TYPE = "text/css"></HEAD>
<BODY>

<DIV class = "TYPE"><PRE>strip_anylet : term -&gt; (term * term) list list * term</PRE></DIV>

<DL>
<DT><SPAN class = "FIELD-NAME">STRUCTURE</SPAN></DT>
<DD><DIV class = "FIELD-BODY"><A HREF = "../../src-sml/htmlsigs/pairSyntax.html">pairSyntax</A></DIV></DD>
<DT><SPAN class = "FIELD-NAME">SYNOPSIS</SPAN></DT>
<DD><DIV class = "FIELD-BODY"><SPAN class = "TEXT">Repeatedly destructs arbitrary </SPAN><SPAN class = "BRKT">let</SPAN><SPAN class = "TEXT"> terms.</SPAN></DIV></DD>
<DT><SPAN class = "FIELD-NAME">DESCRIPTION</SPAN></DT>
<DD><DIV class = "FIELD-BODY"><SPAN class = "TEXT">The invocation </SPAN><SPAN class = "BRKT">strip_anylet&nbsp;M</SPAN><SPAN class = "TEXT"> where </SPAN><SPAN class = "BRKT">M</SPAN><SPAN class = "TEXT"> has the form of a let-abstraction, i.e.,
</SPAN><SPAN class = "BRKT">LET&nbsp;P&nbsp;Q</SPAN><SPAN class = "TEXT">, returns a pair </SPAN><SPAN class = "BRKT">([[(a1,b1),...,(an,bn)],&nbsp;...&nbsp;[(u1,v1),...,(uk,vk)]],body)</SPAN><SPAN class = "TEXT">,
where the first element of the pair is a list of lists of bindings,
and the second is the body of the let. The binding lists are required since let
terms can, in general, be of the form (using surface syntax)
</SPAN><SPAN class = "BRKT">let&nbsp;a1&nbsp;=&nbsp;b1&nbsp;and&nbsp;...&nbsp;and&nbsp;an&nbsp;=&nbsp;bn&nbsp;in&nbsp;body</SPAN><SPAN class = "TEXT">.</SPAN></DIV></DD>
<DT><SPAN class = "FIELD-NAME">FAILURE</SPAN></DT>
<DD><DIV class = "FIELD-BODY"><SPAN class = "TEXT">Never fails.</SPAN></DIV></DD>
<DT><SPAN class = "FIELD-NAME">EXAMPLE</SPAN></DT>
<DD><DIV class = "FIELD-BODY"><SPAN class = "TEXT"></SPAN><DIV class = "XMPL"><pre>
- strip_anylet ``let g x = A in
                 let v = g x y in
                 let f x y (a,b) = g a
                 and foo = M
                 in
                  f x foo v``;
&gt; val it =
    ([[(`g x`, `A`)],
      [(`v`, `g x y`)],
      [(`f x y (a,b)`, `g a`), (`foo`, `M`)]], `f x foo v`)
</pre></DIV>
</DIV></DD>
<DT><SPAN class = "FIELD-NAME">USES</SPAN></DT>
<DD><DIV class = "FIELD-BODY"><SPAN class = "TEXT">Programming that involves manipulation of term syntax.</SPAN></DIV></DD>
<dt><span class = "FIELD-NAME">SEEALSO</span></dt>
<dd><div class = "FIELD-BODY"><A HREF = "boolSyntax.dest_let.html">dest_let</A>,
<A HREF = "pairSyntax.mk_anylet.html">mk_anylet</A>,
<A HREF = "pairSyntax.list_mk_anylet.html">list_mk_anylet</A>,
<A HREF = "pairSyntax.dest_anylet.html">dest_anylet</A></div></dd>
</DL>

<div class = "HOL"><A HREF="http://hol.sourceforge.net">HOL</A>&nbsp;&nbsp;Kananaskis-11</div></BODY></HTML>
