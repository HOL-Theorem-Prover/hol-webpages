<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: extreal</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "extreal"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "util_probTheory.html"><span class="strong">util_prob</span></a>

<h1>Signature</h1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr>
    <th>
    Type
    <th>
    Arity<tr><td> <span class="strong">extreal</span> <td> 0
    <tr>
    <th>
    Constant
    <th>
    Type<tr><td>
            <span class="strong">EXTREAL_SUM_IMAGE</span>
            <td>
            :(α -> extreal) -> (α -> bool) -> extreal
    <tr><td> <span class="strong">NegInf</span> <td> :extreal
    <tr><td> <span class="strong">Normal</span> <td> :real -> extreal
    <tr><td> <span class="strong">PosInf</span> <td> :extreal
    <tr><td> <span class="strong">Q_set</span> <td> :extreal -> bool
    <tr><td> <span class="strong">ceiling</span> <td> :extreal -> num
    <tr><td>
        <span class="strong">ext_mono_decreasing</span>
        <td>
        :(num -> extreal) -> bool
    <tr><td>
        <span class="strong">ext_mono_increasing</span>
        <td>
        :(num -> extreal) -> bool
    <tr><td>
        <span class="strong">ext_suminf</span>
        <td>
        :(num -> extreal) -> extreal
    <tr><td>
        <span class="strong">extreal_CASE</span>
        <td>
        :extreal -> α -> α -> (real -> α) -> α
    <tr><td> <span class="strong">extreal_abs</span> <td> :extreal -> extreal
    <tr><td>
        <span class="strong">extreal_add</span>
        <td>
        :extreal -> extreal -> extreal
    <tr><td>
        <span class="strong">extreal_add_tupled</span>
        <td>
        :extreal # extreal -> extreal
    <tr><td> <span class="strong">extreal_ainv</span> <td> :extreal -> extreal
    <tr><td>
        <span class="strong">extreal_div</span>
        <td>
        :extreal -> extreal -> extreal
    <tr><td> <span class="strong">extreal_exp</span> <td> :extreal -> extreal
    <tr><td>
        <span class="strong">extreal_inf</span>
        <td>
        :(extreal -> bool) -> extreal
    <tr><td> <span class="strong">extreal_inv</span> <td> :extreal -> extreal
    <tr><td>
        <span class="strong">extreal_le</span>
        <td>
        :extreal -> extreal -> bool
    <tr><td> <span class="strong">extreal_le_tupled</span> <td> :extreal reln
    <tr><td> <span class="strong">extreal_lg</span> <td> :extreal -> extreal
    <tr><td>
        <span class="strong">extreal_logr</span>
        <td>
        :real -> extreal -> extreal
    <tr><td>
        <span class="strong">extreal_lt</span>
        <td>
        :extreal -> extreal -> bool
    <tr><td>
        <span class="strong">extreal_max</span>
        <td>
        :extreal -> extreal -> extreal
    <tr><td>
        <span class="strong">extreal_min</span>
        <td>
        :extreal -> extreal -> extreal
    <tr><td>
        <span class="strong">extreal_mul</span>
        <td>
        :extreal -> extreal -> extreal
    <tr><td>
        <span class="strong">extreal_mul_tupled</span>
        <td>
        :extreal # extreal -> extreal
    <tr><td> <span class="strong">extreal_of_num</span> <td> :num -> extreal
    <tr><td>
        <span class="strong">extreal_pow</span>
        <td>
        :extreal -> num -> extreal
    <tr><td> <span class="strong">extreal_size</span> <td> :extreal -> num
    <tr><td> <span class="strong">extreal_sqrt</span> <td> :extreal -> extreal
    <tr><td>
        <span class="strong">extreal_sub</span>
        <td>
        :extreal -> extreal -> extreal
    <tr><td>
        <span class="strong">extreal_sub_tupled</span>
        <td>
        :extreal # extreal -> extreal
    <tr><td>
        <span class="strong">extreal_sup</span>
        <td>
        :(extreal -> bool) -> extreal
    <tr><td>
        <span class="strong">mono_decreasing</span>
        <td>
        :(num -> real) -> bool
    <tr><td>
        <span class="strong">mono_increasing</span>
        <td>
        :(num -> real) -> bool
    <tr><td>
        <span class="strong">open_interval</span>
        <td>
        :extreal -> extreal -> extreal -> bool
    <tr><td>
        <span class="strong">open_intervals_set</span>
        <td>
        :(extreal -> bool) -> bool
    <tr><td>
        <span class="strong">rational_intervals</span>
        <td>
        :(extreal -> bool) -> bool
    <tr><td> <span class="strong">real</span> <td> :extreal -> real

</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">mono_decreasing_def</span>
<DD>
<pre>
|- ∀f. mono_decreasing f ⇔ ∀m n. m ≤ n ⇒ f n ≤ f m
</pre>

<DT><span class="strong">mono_increasing_def</span>
<DD>
<pre>
|- ∀f. mono_increasing f ⇔ ∀m n. m ≤ n ⇒ f m ≤ f n
</pre>

<DT><span class="strong">extreal_sqrt_def</span>
<DD>
<pre>
|- (∀x. sqrt (Normal x) = Normal (sqrt x)) ∧ (sqrt PosInf = PosInf)
</pre>

<DT><span class="strong">extreal_pow_def</span>
<DD>
<pre>
|- (∀a n. Normal a pow n = Normal (a pow n)) ∧
   (∀n. PosInf pow n = if n = 0 then Normal 1 else PosInf) ∧
   ∀n.
     NegInf pow n =
     if n = 0 then Normal 1 else if EVEN n then PosInf else NegInf
</pre>

<DT><span class="strong">extreal_exp_def</span>
<DD>
<pre>
|- (∀x. exp (Normal x) = Normal (exp x)) ∧ (exp PosInf = PosInf) ∧
   (exp NegInf = Normal 0)
</pre>

<DT><span class="strong">extreal_lg_def</span>
<DD>
<pre>
|- ∀x. lg x = logr 2 x
</pre>

<DT><span class="strong">extreal_logr_def</span>
<DD>
<pre>
|- (∀b x. logr b (Normal x) = Normal (logr b x)) ∧
   (∀b. logr b PosInf = PosInf) ∧ ∀b. logr b NegInf = NegInf
</pre>

<DT><span class="strong">extreal_abs_primitive_def</span>
<DD>
<pre>
|- abs =
   WFREC (@R. WF R)
     (λextreal_abs a.
        case a of
          NegInf => I PosInf
        | PosInf => I PosInf
        | Normal x => I (Normal (abs x)))
</pre>

<DT><span class="strong">extreal_div_def</span>
<DD>
<pre>
|- ∀x y. x / y = x * inv y
</pre>

<DT><span class="strong">extreal_ainv_def</span>
<DD>
<pre>
|- (-NegInf = PosInf) ∧ (-PosInf = NegInf) ∧ ∀x. -Normal x = Normal (-x)
</pre>

<DT><span class="strong">extreal_inv_def</span>
<DD>
<pre>
|- (inv NegInf = Normal 0) ∧ (inv PosInf = Normal 0) ∧
   ∀x. inv (Normal x) = Normal (inv x)
</pre>

<DT><span class="strong">extreal_mul_curried_def</span>
<DD>
<pre>
|- ∀x x1. x * x1 = extreal_mul_tupled (x,x1)
</pre>

<DT><span class="strong">extreal_mul_tupled_primitive_def</span>
<DD>
<pre>
|- extreal_mul_tupled =
   WFREC (@R. WF R)
     (λextreal_mul_tupled a.
        case a of
          (NegInf,NegInf) => I PosInf
        | (NegInf,PosInf) => I NegInf
        | (NegInf,Normal y) =>
            I (if y = 0 then Normal 0 else if 0 < y then NegInf else PosInf)
        | (PosInf,NegInf) => I NegInf
        | (PosInf,PosInf) => I PosInf
        | (PosInf,Normal y') =>
            I (if y' = 0 then Normal 0 else if 0 < y' then PosInf else NegInf)
        | (Normal x,NegInf) =>
            I (if x = 0 then Normal 0 else if 0 < x then NegInf else PosInf)
        | (Normal x,PosInf) =>
            I (if x = 0 then Normal 0 else if 0 < x then PosInf else NegInf)
        | (Normal x,Normal y'') => I (Normal (x * y'')))
</pre>

<DT><span class="strong">extreal_lt_def</span>
<DD>
<pre>
|- ∀x y. x < y ⇔ ¬(y ≤ x)
</pre>

<DT><span class="strong">extreal_le_curried_def</span>
<DD>
<pre>
|- ∀x x1. x ≤ x1 ⇔ extreal_le_tupled (x,x1)
</pre>

<DT><span class="strong">extreal_le_tupled_primitive_def</span>
<DD>
<pre>
|- extreal_le_tupled =
   WFREC (@R. WF R)
     (λextreal_le_tupled a'.
        case a' of
          (NegInf,a) => I T
        | (PosInf,NegInf) => I F
        | (PosInf,PosInf) => I T
        | (PosInf,Normal v6) => I F
        | (Normal x,NegInf) => I F
        | (Normal x,PosInf) => I T
        | (Normal x,Normal y) => I (x ≤ y))
</pre>

<DT><span class="strong">extreal_sub_curried_def</span>
<DD>
<pre>
|- ∀x x1. x − x1 = extreal_sub_tupled (x,x1)
</pre>

<DT><span class="strong">extreal_sub_tupled_primitive_def</span>
<DD>
<pre>
|- extreal_sub_tupled =
   WFREC (@R. WF R)
     (λextreal_sub_tupled a'.
        case a' of
          (NegInf,NegInf) => I PosInf
        | (NegInf,PosInf) => I NegInf
        | (NegInf,Normal v6) => I NegInf
        | (PosInf,a) => I PosInf
        | (Normal x,NegInf) => I PosInf
        | (Normal x,PosInf) => I NegInf
        | (Normal x,Normal y) => I (Normal (x − y)))
</pre>

<DT><span class="strong">extreal_add_curried_def</span>
<DD>
<pre>
|- ∀x x1. x + x1 = extreal_add_tupled (x,x1)
</pre>

<DT><span class="strong">extreal_add_tupled_primitive_def</span>
<DD>
<pre>
|- extreal_add_tupled =
   WFREC (@R. WF R)
     (λextreal_add_tupled a'.
        case a' of
          (NegInf,NegInf) => I NegInf
        | (NegInf,PosInf) => I PosInf
        | (NegInf,Normal v6) => I NegInf
        | (PosInf,a) => I PosInf
        | (Normal x,NegInf) => I NegInf
        | (Normal x,PosInf) => I PosInf
        | (Normal x,Normal y) => I (Normal (x + y)))
</pre>

<DT><span class="strong">real_def</span>
<DD>
<pre>
|- ∀x. real x = if (x = NegInf) ∨ (x = PosInf) then 0 else @r. x = Normal r
</pre>

<DT><span class="strong">extreal_of_num_def</span>
<DD>
<pre>
|- ∀n. &n = Normal (&n)
</pre>

<DT><span class="strong">extreal_TY_DEF</span>
<DD>
<pre>
|- ∃rep.
     TYPE_DEFINITION
       (λa0.
          ∀'extreal' .
            (∀a0.
               (a0 = ind_type$CONSTR 0 ARB (λn. ind_type$BOTTOM)) ∨
               (a0 = ind_type$CONSTR (SUC 0) ARB (λn. ind_type$BOTTOM)) ∨
               (∃a.
                  a0 =
                  (λa. ind_type$CONSTR (SUC (SUC 0)) a (λn. ind_type$BOTTOM))
                    a) ⇒
               'extreal' a0) ⇒
            'extreal' a0) rep
</pre>

<DT><span class="strong">extreal_case_def</span>
<DD>
<pre>
|- (∀v v1 f. extreal_CASE NegInf v v1 f = v) ∧
   (∀v v1 f. extreal_CASE PosInf v v1 f = v1) ∧
   ∀a v v1 f. extreal_CASE (Normal a) v v1 f = f a
</pre>

<DT><span class="strong">extreal_size_def</span>
<DD>
<pre>
|- (extreal_size NegInf = 0) ∧ (extreal_size PosInf = 0) ∧
   ∀a. extreal_size (Normal a) = 1
</pre>

<DT><span class="strong">ext_mono_increasing_def</span>
<DD>
<pre>
|- ∀f. mono_increasing f ⇔ ∀m n. m ≤ n ⇒ f m ≤ f n
</pre>

<DT><span class="strong">ext_mono_decreasing_def</span>
<DD>
<pre>
|- ∀f. mono_decreasing f ⇔ ∀m n. m ≤ n ⇒ f n ≤ f m
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_DEF</span>
<DD>
<pre>
|- ∀f s. SIGMA f s = ITSET (λe acc. f e + acc) s 0
</pre>

<DT><span class="strong">extreal_sup_def</span>
<DD>
<pre>
|- ∀p.
     sup p =
     if ∀x. (∀y. p y ⇒ y ≤ x) ⇒ (x = PosInf) then PosInf
     else if ∀x. p x ⇒ (x = NegInf) then NegInf
     else Normal (sup (λr. p (Normal r)))
</pre>

<DT><span class="strong">extreal_inf_def</span>
<DD>
<pre>
|- ∀p. inf p = -sup (IMAGE numeric_negate p)
</pre>

<DT><span class="strong">ext_suminf_def</span>
<DD>
<pre>
|- ∀f. suminf f = sup (IMAGE (λn. SIGMA f (count n)) 𝕌(:num))
</pre>

<DT><span class="strong">extreal_min_def</span>
<DD>
<pre>
|- ∀x y. min x y = if x ≤ y then x else y
</pre>

<DT><span class="strong">extreal_max_def</span>
<DD>
<pre>
|- ∀x y. max x y = if x ≤ y then y else x
</pre>

<DT><span class="strong">Q_set_def</span>
<DD>
<pre>
|- Q_set =
   {x | ∃a b. (x = &a / &b) ∧ 0 < &b} ∪ {x | ∃a b. (x = -(&a / &b)) ∧ 0 < &b}
</pre>

<DT><span class="strong">ceiling_def</span>
<DD>
<pre>
|- ∀x. ceiling (Normal x) = LEAST n. x ≤ &n
</pre>

<DT><span class="strong">open_interval_def</span>
<DD>
<pre>
|- ∀a b. open_interval a b = {x | a < x ∧ x < b}
</pre>

<DT><span class="strong">open_intervals_set_def</span>
<DD>
<pre>
|- open_intervals_set =
   {open_interval a b | a ∈ 𝕌(:extreal) ∧ b ∈ 𝕌(:extreal)}
</pre>

<DT><span class="strong">rational_intervals_def</span>
<DD>
<pre>
|- rational_intervals = {open_interval a b | a ∈ Q_set ∧ b ∈ Q_set}
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">num_not_infty</span>
<DD>
<pre>
|- ∀n. &n ≠ NegInf ∧ &n ≠ PosInf
</pre>

<DT><span class="strong">extreal_not_infty</span>
<DD>
<pre>
|- ∀x. Normal x ≠ NegInf ∧ Normal x ≠ PosInf
</pre>

<DT><span class="strong">extreal_eq_zero</span>
<DD>
<pre>
|- ∀x. (Normal x = 0) ⇔ (x = 0)
</pre>

<DT><span class="strong">extreal_cases</span>
<DD>
<pre>
|- ∀x. (x = NegInf) ∨ (x = PosInf) ∨ ∃r. x = Normal r
</pre>

<DT><span class="strong">mono_increasing_converges_to_sup</span>
<DD>
<pre>
|- ∀f r. mono_increasing f ∧ f --> r ⇒ (r = sup (IMAGE f 𝕌(:num)))
</pre>

<DT><span class="strong">mono_decreasing_suc</span>
<DD>
<pre>
|- ∀f. mono_decreasing f ⇔ ∀n. f (SUC n) ≤ f n
</pre>

<DT><span class="strong">mono_increasing_suc</span>
<DD>
<pre>
|- ∀f. mono_increasing f ⇔ ∀n. f n ≤ f (SUC n)
</pre>

<DT><span class="strong">LOGR_MONO_LE_IMP</span>
<DD>
<pre>
|- ∀x y b. 0 < x ∧ x ≤ y ∧ 1 ≤ b ⇒ logr b x ≤ logr b y
</pre>

<DT><span class="strong">LOGR_MONO_LE</span>
<DD>
<pre>
|- ∀x y b. 0 < x ∧ 0 < y ∧ 1 < b ⇒ (logr b x ≤ logr b y ⇔ x ≤ y)
</pre>

<DT><span class="strong">POW_NEG_ODD</span>
<DD>
<pre>
|- ∀x. x < 0 ⇒ (x pow n < 0 ⇔ ODD n)
</pre>

<DT><span class="strong">POW_POS_EVEN</span>
<DD>
<pre>
|- ∀x. x < 0 ⇒ (0 < x pow n ⇔ EVEN n)
</pre>

<DT><span class="strong">REAL_LE_RDIV_EQ_NEG</span>
<DD>
<pre>
|- ∀x y z. z < 0 ⇒ (y / z ≤ x ⇔ x * z ≤ y)
</pre>

<DT><span class="strong">REAL_LT_RDIV_EQ_NEG</span>
<DD>
<pre>
|- ∀x y z. z < 0 ⇒ (y / z < x ⇔ x * z < y)
</pre>

<DT><span class="strong">REAL_LT_RMUL_NEG_0_NEG</span>
<DD>
<pre>
|- ∀x y. x * y < 0 ∧ y < 0 ⇒ 0 < x
</pre>

<DT><span class="strong">REAL_LT_LMUL_NEG_0_NEG</span>
<DD>
<pre>
|- ∀x y. x * y < 0 ∧ x < 0 ⇒ 0 < y
</pre>

<DT><span class="strong">REAL_LT_RMUL_NEG_0</span>
<DD>
<pre>
|- ∀x y. x * y < 0 ∧ 0 < y ⇒ x < 0
</pre>

<DT><span class="strong">REAL_LT_LMUL_NEG_0</span>
<DD>
<pre>
|- ∀x y. x * y < 0 ∧ 0 < x ⇒ y < 0
</pre>

<DT><span class="strong">REAL_LT_RMUL_0_NEG</span>
<DD>
<pre>
|- ∀x y. 0 < x * y ∧ y < 0 ⇒ x < 0
</pre>

<DT><span class="strong">REAL_LT_LMUL_0_NEG</span>
<DD>
<pre>
|- ∀x y. 0 < x * y ∧ x < 0 ⇒ y < 0
</pre>

<DT><span class="strong">extreal_abs_def</span>
<DD>
<pre>
|- (abs (Normal x) = Normal (abs x)) ∧ (abs NegInf = PosInf) ∧
   (abs PosInf = PosInf)
</pre>

<DT><span class="strong">extreal_abs_ind</span>
<DD>
<pre>
|- ∀P. (∀x. P (Normal x)) ∧ P NegInf ∧ P PosInf ⇒ ∀v. P v
</pre>

<DT><span class="strong">extreal_mul_def</span>
<DD>
<pre>
|- (NegInf * NegInf = PosInf) ∧ (NegInf * PosInf = NegInf) ∧
   (PosInf * NegInf = NegInf) ∧ (PosInf * PosInf = PosInf) ∧
   (Normal x * NegInf =
    if x = 0 then Normal 0 else if 0 < x then NegInf else PosInf) ∧
   (NegInf * Normal y =
    if y = 0 then Normal 0 else if 0 < y then NegInf else PosInf) ∧
   (Normal x * PosInf =
    if x = 0 then Normal 0 else if 0 < x then PosInf else NegInf) ∧
   (PosInf * Normal y =
    if y = 0 then Normal 0 else if 0 < y then PosInf else NegInf) ∧
   (Normal x * Normal y = Normal (x * y))
</pre>

<DT><span class="strong">extreal_mul_ind</span>
<DD>
<pre>
|- ∀P.
     P NegInf NegInf ∧ P NegInf PosInf ∧ P PosInf NegInf ∧ P PosInf PosInf ∧
     (∀x. P (Normal x) NegInf) ∧ (∀y. P NegInf (Normal y)) ∧
     (∀x. P (Normal x) PosInf) ∧ (∀y. P PosInf (Normal y)) ∧
     (∀x y. P (Normal x) (Normal y)) ⇒
     ∀v v1. P v v1
</pre>

<DT><span class="strong">extreal_le_def</span>
<DD>
<pre>
|- (Normal x ≤ Normal y ⇔ x ≤ y) ∧ (NegInf ≤ a ⇔ T) ∧ (PosInf ≤ PosInf ⇔ T) ∧
   (Normal v2 ≤ PosInf ⇔ T) ∧ (PosInf ≤ NegInf ⇔ F) ∧
   (Normal v3 ≤ NegInf ⇔ F) ∧ (PosInf ≤ Normal v5 ⇔ F)
</pre>

<DT><span class="strong">extreal_le_ind</span>
<DD>
<pre>
|- ∀P.
     (∀x y. P (Normal x) (Normal y)) ∧ (∀a. P NegInf a) ∧ P PosInf PosInf ∧
     (∀v2. P (Normal v2) PosInf) ∧ P PosInf NegInf ∧
     (∀v3. P (Normal v3) NegInf) ∧ (∀v5. P PosInf (Normal v5)) ⇒
     ∀v v1. P v v1
</pre>

<DT><span class="strong">extreal_sub_def</span>
<DD>
<pre>
|- (Normal x − Normal y = Normal (x − y)) ∧ (PosInf − a = PosInf) ∧
   (NegInf − PosInf = NegInf) ∧ (Normal v2 − PosInf = NegInf) ∧
   (NegInf − NegInf = PosInf) ∧ (NegInf − Normal v5 = NegInf) ∧
   (Normal v3 − NegInf = PosInf)
</pre>

<DT><span class="strong">extreal_sub_ind</span>
<DD>
<pre>
|- ∀P.
     (∀x y. P (Normal x) (Normal y)) ∧ (∀a. P PosInf a) ∧ P NegInf PosInf ∧
     (∀v2. P (Normal v2) PosInf) ∧ P NegInf NegInf ∧
     (∀v5. P NegInf (Normal v5)) ∧ (∀v3. P (Normal v3) NegInf) ⇒
     ∀v v1. P v v1
</pre>

<DT><span class="strong">extreal_add_def</span>
<DD>
<pre>
|- (Normal x + Normal y = Normal (x + y)) ∧ (PosInf + a = PosInf) ∧
   (NegInf + PosInf = PosInf) ∧ (Normal v2 + PosInf = PosInf) ∧
   (NegInf + NegInf = NegInf) ∧ (NegInf + Normal v5 = NegInf) ∧
   (Normal v3 + NegInf = NegInf)
</pre>

<DT><span class="strong">extreal_add_ind</span>
<DD>
<pre>
|- ∀P.
     (∀x y. P (Normal x) (Normal y)) ∧ (∀a. P PosInf a) ∧ P NegInf PosInf ∧
     (∀v2. P (Normal v2) PosInf) ∧ P NegInf NegInf ∧
     (∀v5. P NegInf (Normal v5)) ∧ (∀v3. P (Normal v3) NegInf) ⇒
     ∀v v1. P v v1
</pre>

<DT><span class="strong">normal_real</span>
<DD>
<pre>
|- ∀x. x ≠ NegInf ∧ x ≠ PosInf ⇒ (Normal (real x) = x)
</pre>

<DT><span class="strong">real_normal</span>
<DD>
<pre>
|- ∀x. real (Normal x) = x
</pre>

<DT><span class="strong">extreal_induction</span>
<DD>
<pre>
|- ∀P. P NegInf ∧ P PosInf ∧ (∀r. P (Normal r)) ⇒ ∀e. P e
</pre>

<DT><span class="strong">extreal_Axiom</span>
<DD>
<pre>
|- ∀f0 f1 f2.
     ∃fn. (fn NegInf = f0) ∧ (fn PosInf = f1) ∧ ∀a. fn (Normal a) = f2 a
</pre>

<DT><span class="strong">extreal_nchotomy</span>
<DD>
<pre>
|- ∀ee. (ee = NegInf) ∨ (ee = PosInf) ∨ ∃r. ee = Normal r
</pre>

<DT><span class="strong">extreal_case_cong</span>
<DD>
<pre>
|- ∀M M' v v1 f.
     (M = M') ∧ ((M' = NegInf) ⇒ (v = v')) ∧ ((M' = PosInf) ⇒ (v1 = v1')) ∧
     (∀a. (M' = Normal a) ⇒ (f a = f' a)) ⇒
     (extreal_CASE M v v1 f = extreal_CASE M' v' v1' f')
</pre>

<DT><span class="strong">extreal_distinct</span>
<DD>
<pre>
|- NegInf ≠ PosInf ∧ (∀a. NegInf ≠ Normal a) ∧ ∀a. PosInf ≠ Normal a
</pre>

<DT><span class="strong">datatype_extreal</span>
<DD>
<pre>
|- DATATYPE (extreal NegInf PosInf Normal)
</pre>

<DT><span class="strong">extreal_11</span>
<DD>
<pre>
|- ∀a a'. (Normal a = Normal a') ⇔ (a = a')
</pre>

<DT><span class="strong">mul_rzero</span>
<DD>
<pre>
|- ∀x. x * 0 = 0
</pre>

<DT><span class="strong">mul_lzero</span>
<DD>
<pre>
|- ∀x. 0 * x = 0
</pre>

<DT><span class="strong">mul_rone</span>
<DD>
<pre>
|- ∀x. x * 1 = x
</pre>

<DT><span class="strong">mul_lone</span>
<DD>
<pre>
|- ∀x. 1 * x = x
</pre>

<DT><span class="strong">entire</span>
<DD>
<pre>
|- ∀x y. (x * y = 0) ⇔ (x = 0) ∨ (y = 0)
</pre>

<DT><span class="strong">extreal_lt_eq</span>
<DD>
<pre>
|- ∀x y. Normal x < Normal y ⇔ x < y
</pre>

<DT><span class="strong">le_refl</span>
<DD>
<pre>
|- ∀x. x ≤ x
</pre>

<DT><span class="strong">lt_refl</span>
<DD>
<pre>
|- ∀x. ¬(x < x)
</pre>

<DT><span class="strong">le_infty</span>
<DD>
<pre>
|- (∀x. NegInf ≤ x ∧ x ≤ PosInf) ∧ (∀x. x ≤ NegInf ⇔ (x = NegInf)) ∧
   ∀x. PosInf ≤ x ⇔ (x = PosInf)
</pre>

<DT><span class="strong">lt_infty</span>
<DD>
<pre>
|- ∀x y.
     NegInf < Normal y ∧ Normal y < PosInf ∧ NegInf < PosInf ∧ ¬(x < NegInf) ∧
     ¬(PosInf < x) ∧ (x ≠ PosInf ⇔ x < PosInf) ∧ (x ≠ NegInf ⇔ NegInf < x)
</pre>

<DT><span class="strong">lt_imp_le</span>
<DD>
<pre>
|- ∀x y. x < y ⇒ x ≤ y
</pre>

<DT><span class="strong">lt_imp_ne</span>
<DD>
<pre>
|- ∀x y. x < y ⇒ x ≠ y
</pre>

<DT><span class="strong">le_trans</span>
<DD>
<pre>
|- ∀x y z. x ≤ y ∧ y ≤ z ⇒ x ≤ z
</pre>

<DT><span class="strong">lt_trans</span>
<DD>
<pre>
|- ∀x y z. x < y ∧ y < z ⇒ x < z
</pre>

<DT><span class="strong">let_trans</span>
<DD>
<pre>
|- ∀x y z. x ≤ y ∧ y < z ⇒ x < z
</pre>

<DT><span class="strong">le_antisym</span>
<DD>
<pre>
|- ∀x y. x ≤ y ∧ y ≤ x ⇔ (x = y)
</pre>

<DT><span class="strong">lt_antisym</span>
<DD>
<pre>
|- ∀x y. ¬(x < y ∧ y < x)
</pre>

<DT><span class="strong">lte_trans</span>
<DD>
<pre>
|- ∀x y z. x < y ∧ y ≤ z ⇒ x < z
</pre>

<DT><span class="strong">le_total</span>
<DD>
<pre>
|- ∀x y. x ≤ y ∨ y ≤ x
</pre>

<DT><span class="strong">lt_total</span>
<DD>
<pre>
|- ∀x y. (x = y) ∨ x < y ∨ y < x
</pre>

<DT><span class="strong">le_01</span>
<DD>
<pre>
|- 0 ≤ 1
</pre>

<DT><span class="strong">lt_01</span>
<DD>
<pre>
|- 0 < 1
</pre>

<DT><span class="strong">ne_01</span>
<DD>
<pre>
|- 0 ≠ 1
</pre>

<DT><span class="strong">le_02</span>
<DD>
<pre>
|- 0 ≤ 2
</pre>

<DT><span class="strong">lt_02</span>
<DD>
<pre>
|- 0 < 2
</pre>

<DT><span class="strong">ne_02</span>
<DD>
<pre>
|- 0 ≠ 2
</pre>

<DT><span class="strong">le_num</span>
<DD>
<pre>
|- ∀n. 0 ≤ &n
</pre>

<DT><span class="strong">lt_le</span>
<DD>
<pre>
|- ∀x y. x < y ⇔ x ≤ y ∧ x ≠ y
</pre>

<DT><span class="strong">le_lt</span>
<DD>
<pre>
|- ∀x y. x ≤ y ⇔ x < y ∨ (x = y)
</pre>

<DT><span class="strong">le_neg</span>
<DD>
<pre>
|- ∀x y. -x ≤ -y ⇔ y ≤ x
</pre>

<DT><span class="strong">lt_neg</span>
<DD>
<pre>
|- ∀x y. -x < -y ⇔ y < x
</pre>

<DT><span class="strong">le_add</span>
<DD>
<pre>
|- ∀x y. 0 ≤ x ∧ 0 ≤ y ⇒ 0 ≤ x + y
</pre>

<DT><span class="strong">lt_add</span>
<DD>
<pre>
|- ∀x y. 0 < x ∧ 0 < y ⇒ 0 < x + y
</pre>

<DT><span class="strong">let_add</span>
<DD>
<pre>
|- ∀x y. 0 ≤ x ∧ 0 < y ⇒ 0 < x + y
</pre>

<DT><span class="strong">lte_add</span>
<DD>
<pre>
|- ∀x y. 0 < x ∧ 0 ≤ y ⇒ 0 < x + y
</pre>

<DT><span class="strong">le_add2</span>
<DD>
<pre>
|- ∀w x y z. w ≤ x ∧ y ≤ z ⇒ w + y ≤ x + z
</pre>

<DT><span class="strong">lt_add2</span>
<DD>
<pre>
|- ∀w x y z. w < x ∧ y < z ⇒ w + y < x + z
</pre>

<DT><span class="strong">let_add2</span>
<DD>
<pre>
|- ∀w x y z. w ≠ NegInf ∧ w ≠ PosInf ∧ w ≤ x ∧ y < z ⇒ w + y < x + z
</pre>

<DT><span class="strong">let_add2_alt</span>
<DD>
<pre>
|- ∀w x y z. x ≠ NegInf ∧ x ≠ PosInf ∧ w ≤ x ∧ y < z ⇒ w + y < x + z
</pre>

<DT><span class="strong">le_addr</span>
<DD>
<pre>
|- ∀x y. x ≠ NegInf ∧ x ≠ PosInf ⇒ (x ≤ x + y ⇔ 0 ≤ y)
</pre>

<DT><span class="strong">le_addr_imp</span>
<DD>
<pre>
|- ∀x y. 0 ≤ y ⇒ x ≤ x + y
</pre>

<DT><span class="strong">le_ladd</span>
<DD>
<pre>
|- ∀x y z. x ≠ NegInf ∧ x ≠ PosInf ⇒ (x + y ≤ x + z ⇔ y ≤ z)
</pre>

<DT><span class="strong">le_radd</span>
<DD>
<pre>
|- ∀x y z. x ≠ NegInf ∧ x ≠ PosInf ⇒ (y + x ≤ z + x ⇔ y ≤ z)
</pre>

<DT><span class="strong">le_radd_imp</span>
<DD>
<pre>
|- ∀x y z. y ≤ z ⇒ y + x ≤ z + x
</pre>

<DT><span class="strong">le_ladd_imp</span>
<DD>
<pre>
|- ∀x y z. y ≤ z ⇒ x + y ≤ x + z
</pre>

<DT><span class="strong">lt_ladd</span>
<DD>
<pre>
|- ∀x y z. x ≠ NegInf ∧ x ≠ PosInf ⇒ (x + y < x + z ⇔ y < z)
</pre>

<DT><span class="strong">lt_radd</span>
<DD>
<pre>
|- ∀x y z. x ≠ NegInf ∧ x ≠ PosInf ⇒ (y + x < z + x ⇔ y < z)
</pre>

<DT><span class="strong">lt_addl</span>
<DD>
<pre>
|- ∀x y. y ≠ NegInf ∧ y ≠ PosInf ⇒ (y < x + y ⇔ 0 < x)
</pre>

<DT><span class="strong">le_lneg</span>
<DD>
<pre>
|- ∀x y. -x ≤ y ⇔ 0 ≤ x + y
</pre>

<DT><span class="strong">le_mul</span>
<DD>
<pre>
|- ∀x y. 0 ≤ x ∧ 0 ≤ y ⇒ 0 ≤ x * y
</pre>

<DT><span class="strong">let_mul</span>
<DD>
<pre>
|- ∀x y. 0 ≤ x ∧ 0 < y ⇒ 0 ≤ x * y
</pre>

<DT><span class="strong">lte_mul</span>
<DD>
<pre>
|- ∀x y. 0 < x ∧ 0 ≤ y ⇒ 0 ≤ x * y
</pre>

<DT><span class="strong">le_mul_neg</span>
<DD>
<pre>
|- ∀x y. x ≤ 0 ∧ y ≤ 0 ⇒ 0 ≤ x * y
</pre>

<DT><span class="strong">mul_le</span>
<DD>
<pre>
|- ∀x y. 0 ≤ x ∧ y ≤ 0 ⇒ x * y ≤ 0
</pre>

<DT><span class="strong">lt_mul</span>
<DD>
<pre>
|- ∀x y. 0 < x ∧ 0 < y ⇒ 0 < x * y
</pre>

<DT><span class="strong">lt_mul_neg</span>
<DD>
<pre>
|- ∀x y. x < 0 ∧ y < 0 ⇒ 0 < x * y
</pre>

<DT><span class="strong">mul_lt</span>
<DD>
<pre>
|- ∀x y. 0 < x ∧ y < 0 ⇒ x * y < 0
</pre>

<DT><span class="strong">mul_let</span>
<DD>
<pre>
|- ∀x y. 0 ≤ x ∧ y < 0 ⇒ x * y ≤ 0
</pre>

<DT><span class="strong">mul_lte</span>
<DD>
<pre>
|- ∀x y. 0 < x ∧ y ≤ 0 ⇒ x * y ≤ 0
</pre>

<DT><span class="strong">le_rmul_imp</span>
<DD>
<pre>
|- ∀x y z. 0 < z ∧ x ≤ y ⇒ x * z ≤ y * z
</pre>

<DT><span class="strong">le_lmul_imp</span>
<DD>
<pre>
|- ∀x y z. 0 ≤ z ∧ x ≤ y ⇒ z * x ≤ z * y
</pre>

<DT><span class="strong">lt_rmul</span>
<DD>
<pre>
|- ∀x y z. 0 < z ∧ z ≠ PosInf ⇒ (x * z < y * z ⇔ x < y)
</pre>

<DT><span class="strong">lt_lmul</span>
<DD>
<pre>
|- ∀x y z. 0 < x ∧ x ≠ PosInf ⇒ (x * y < x * z ⇔ y < z)
</pre>

<DT><span class="strong">lt_mul2</span>
<DD>
<pre>
|- ∀x1 x2 y1 y2.
     0 ≤ x1 ∧ 0 ≤ y1 ∧ x1 ≠ PosInf ∧ y1 ≠ PosInf ∧ x1 < x2 ∧ y1 < y2 ⇒
     x1 * y1 < x2 * y2
</pre>

<DT><span class="strong">abs_pos</span>
<DD>
<pre>
|- ∀x. 0 ≤ abs x
</pre>

<DT><span class="strong">abs_refl</span>
<DD>
<pre>
|- ∀x. (abs x = x) ⇔ 0 ≤ x
</pre>

<DT><span class="strong">abs_bounds</span>
<DD>
<pre>
|- ∀x k. abs x ≤ k ⇔ -k ≤ x ∧ x ≤ k
</pre>

<DT><span class="strong">abs_bounds_lt</span>
<DD>
<pre>
|- ∀x k. abs x < k ⇔ -k < x ∧ x < k
</pre>

<DT><span class="strong">add_comm</span>
<DD>
<pre>
|- ∀x y. x + y = y + x
</pre>

<DT><span class="strong">add_assoc</span>
<DD>
<pre>
|- ∀x y z. x + (y + z) = x + y + z
</pre>

<DT><span class="strong">add_not_infty</span>
<DD>
<pre>
|- ∀x y.
     (x ≠ NegInf ∧ y ≠ NegInf ⇒ x + y ≠ NegInf) ∧
     (x ≠ PosInf ∧ y ≠ PosInf ⇒ x + y ≠ PosInf)
</pre>

<DT><span class="strong">add_rzero</span>
<DD>
<pre>
|- ∀x. x + 0 = x
</pre>

<DT><span class="strong">add_lzero</span>
<DD>
<pre>
|- ∀x. 0 + x = x
</pre>

<DT><span class="strong">add_infty</span>
<DD>
<pre>
|- (∀x. (x + PosInf = PosInf) ∧ (PosInf + x = PosInf)) ∧
   ∀x. x ≠ PosInf ⇒ (x + NegInf = NegInf) ∧ (NegInf + x = NegInf)
</pre>

<DT><span class="strong">EXTREAL_EQ_LADD</span>
<DD>
<pre>
|- ∀x y z. x ≠ NegInf ∧ x ≠ PosInf ⇒ ((x + y = x + z) ⇔ (y = z))
</pre>

<DT><span class="strong">sub_rzero</span>
<DD>
<pre>
|- ∀x. x − 0 = x
</pre>

<DT><span class="strong">sub_lzero</span>
<DD>
<pre>
|- ∀x. 0 − x = -x
</pre>

<DT><span class="strong">sub_le_imp</span>
<DD>
<pre>
|- ∀x y z. x ≠ NegInf ∧ x ≠ PosInf ∧ y ≤ z + x ⇒ y − x ≤ z
</pre>

<DT><span class="strong">sub_le_imp2</span>
<DD>
<pre>
|- ∀x y z. y ≠ NegInf ∧ y ≠ PosInf ∧ y ≤ z + x ⇒ y − x ≤ z
</pre>

<DT><span class="strong">le_sub_imp</span>
<DD>
<pre>
|- ∀x y z. y + x ≤ z ⇒ y ≤ z − x
</pre>

<DT><span class="strong">lt_sub_imp</span>
<DD>
<pre>
|- ∀x y z. y + x < z ⇒ y < z − x
</pre>

<DT><span class="strong">sub_lt_imp</span>
<DD>
<pre>
|- ∀x y z. x ≠ NegInf ∧ x ≠ PosInf ∧ y < z + x ⇒ y − x < z
</pre>

<DT><span class="strong">sub_lt_imp2</span>
<DD>
<pre>
|- ∀x y z. z ≠ NegInf ∧ z ≠ PosInf ∧ y < z + x ⇒ y − x < z
</pre>

<DT><span class="strong">sub_zero_lt</span>
<DD>
<pre>
|- ∀x y. x < y ⇒ 0 < y − x
</pre>

<DT><span class="strong">sub_zero_lt2</span>
<DD>
<pre>
|- ∀x y. x ≠ NegInf ∧ x ≠ PosInf ∧ 0 < y − x ⇒ x < y
</pre>

<DT><span class="strong">sub_lt_zero</span>
<DD>
<pre>
|- ∀x y. x < y ⇒ x − y < 0
</pre>

<DT><span class="strong">sub_lt_zero2</span>
<DD>
<pre>
|- ∀x y. y ≠ NegInf ∧ y ≠ PosInf ∧ x − y < 0 ⇒ x < y
</pre>

<DT><span class="strong">sub_zero_le</span>
<DD>
<pre>
|- ∀x y. x ≤ y ⇔ 0 ≤ y − x
</pre>

<DT><span class="strong">sub_le_zero</span>
<DD>
<pre>
|- ∀x y. y ≠ NegInf ∧ y ≠ PosInf ⇒ (x ≤ y ⇔ x − y ≤ 0)
</pre>

<DT><span class="strong">le_sub_eq</span>
<DD>
<pre>
|- ∀x y z. x ≠ NegInf ∧ x ≠ PosInf ⇒ (y ≤ z − x ⇔ y + x ≤ z)
</pre>

<DT><span class="strong">le_sub_eq2</span>
<DD>
<pre>
|- ∀x y z.
     z ≠ NegInf ∧ z ≠ PosInf ∧ x ≠ NegInf ∧ y ≠ NegInf ⇒
     (y ≤ z − x ⇔ y + x ≤ z)
</pre>

<DT><span class="strong">sub_le_eq</span>
<DD>
<pre>
|- ∀x y z. x ≠ NegInf ∧ x ≠ PosInf ⇒ (y − x ≤ z ⇔ y ≤ z + x)
</pre>

<DT><span class="strong">sub_le_eq2</span>
<DD>
<pre>
|- ∀x y z.
     y ≠ NegInf ∧ y ≠ PosInf ∧ x ≠ NegInf ∧ z ≠ NegInf ⇒
     (y − x ≤ z ⇔ y ≤ z + x)
</pre>

<DT><span class="strong">sub_le_switch</span>
<DD>
<pre>
|- ∀x y z.
     x ≠ NegInf ∧ x ≠ PosInf ∧ z ≠ NegInf ∧ z ≠ PosInf ⇒
     (y − x ≤ z ⇔ y − z ≤ x)
</pre>

<DT><span class="strong">sub_le_switch2</span>
<DD>
<pre>
|- ∀x y z.
     x ≠ NegInf ∧ x ≠ PosInf ∧ y ≠ NegInf ∧ y ≠ PosInf ⇒
     (y − x ≤ z ⇔ y − z ≤ x)
</pre>

<DT><span class="strong">lt_sub</span>
<DD>
<pre>
|- ∀x y z. z ≠ NegInf ∧ z ≠ PosInf ⇒ (y + x < z ⇔ y < z − x)
</pre>

<DT><span class="strong">sub_add2</span>
<DD>
<pre>
|- ∀x y. x ≠ NegInf ∧ x ≠ PosInf ⇒ (x + (y − x) = y)
</pre>

<DT><span class="strong">add_sub</span>
<DD>
<pre>
|- ∀x y. y ≠ NegInf ∧ y ≠ PosInf ⇒ (x + y − y = x)
</pre>

<DT><span class="strong">add_sub2</span>
<DD>
<pre>
|- ∀x y. y ≠ NegInf ∧ y ≠ PosInf ⇒ (y + x − y = x)
</pre>

<DT><span class="strong">sub_add</span>
<DD>
<pre>
|- ∀x y. y ≠ NegInf ∧ y ≠ PosInf ⇒ (x − y + y = x)
</pre>

<DT><span class="strong">extreal_sub_add</span>
<DD>
<pre>
|- ∀x y. x − y = x + -y
</pre>

<DT><span class="strong">sub_0</span>
<DD>
<pre>
|- ∀x y. (x − y = 0) ⇒ (x = y)
</pre>

<DT><span class="strong">neg_neg</span>
<DD>
<pre>
|- ∀x. - -x = x
</pre>

<DT><span class="strong">neg_0</span>
<DD>
<pre>
|- -0 = 0
</pre>

<DT><span class="strong">neg_eq0</span>
<DD>
<pre>
|- ∀x. (-x = 0) ⇔ (x = 0)
</pre>

<DT><span class="strong">eq_neg</span>
<DD>
<pre>
|- ∀x y. (-x = -y) ⇔ (x = y)
</pre>

<DT><span class="strong">neg_minus1</span>
<DD>
<pre>
|- ∀x. -x = -1 * x
</pre>

<DT><span class="strong">sub_rneg</span>
<DD>
<pre>
|- ∀x y. x − -y = x + y
</pre>

<DT><span class="strong">sub_lneg</span>
<DD>
<pre>
|- ∀x y.
     x ≠ NegInf ∧ y ≠ NegInf ∨ x ≠ PosInf ∧ y ≠ PosInf ⇒ (-x − y = -(x + y))
</pre>

<DT><span class="strong">neg_sub</span>
<DD>
<pre>
|- ∀x y.
     x ≠ NegInf ∧ x ≠ PosInf ∨ y ≠ NegInf ∧ y ≠ PosInf ⇒ (-(x − y) = y − x)
</pre>

<DT><span class="strong">sub_not_infty</span>
<DD>
<pre>
|- ∀x y.
     (x ≠ NegInf ∧ y ≠ PosInf ⇒ x − y ≠ NegInf) ∧
     (x ≠ PosInf ∧ y ≠ NegInf ⇒ x − y ≠ PosInf)
</pre>

<DT><span class="strong">le_lsub_imp</span>
<DD>
<pre>
|- ∀x y z. y ≤ z ⇒ x − z ≤ x − y
</pre>

<DT><span class="strong">eq_sub_ladd_normal</span>
<DD>
<pre>
|- ∀x y z. (x = y − Normal z) ⇔ (x + Normal z = y)
</pre>

<DT><span class="strong">eq_sub_radd</span>
<DD>
<pre>
|- ∀x y z. y ≠ NegInf ∧ y ≠ PosInf ⇒ ((x − y = z) ⇔ (x = z + y))
</pre>

<DT><span class="strong">eq_sub_ladd</span>
<DD>
<pre>
|- ∀x y z. z ≠ NegInf ∧ z ≠ PosInf ⇒ ((x = y − z) ⇔ (x + z = y))
</pre>

<DT><span class="strong">eq_sub_switch</span>
<DD>
<pre>
|- ∀x y z. (x = Normal z − y) ⇔ (y = Normal z − x)
</pre>

<DT><span class="strong">eq_add_sub_switch</span>
<DD>
<pre>
|- ∀a b c d.
     b ≠ NegInf ∧ b ≠ PosInf ∧ c ≠ NegInf ∧ c ≠ PosInf ⇒
     ((a + b = c + d) ⇔ (a − c = d − b))
</pre>

<DT><span class="strong">sub_refl</span>
<DD>
<pre>
|- ∀x. x ≠ NegInf ∧ x ≠ PosInf ⇒ (x − x = 0)
</pre>

<DT><span class="strong">mul_comm</span>
<DD>
<pre>
|- ∀x y. x * y = y * x
</pre>

<DT><span class="strong">mul_assoc</span>
<DD>
<pre>
|- ∀x y z. x * (y * z) = x * y * z
</pre>

<DT><span class="strong">mul_not_infty</span>
<DD>
<pre>
|- (∀c y. 0 ≤ c ∧ y ≠ NegInf ⇒ Normal c * y ≠ NegInf) ∧
   (∀c y. 0 ≤ c ∧ y ≠ PosInf ⇒ Normal c * y ≠ PosInf) ∧
   (∀c y. c ≤ 0 ∧ y ≠ NegInf ⇒ Normal c * y ≠ PosInf) ∧
   ∀c y. c ≤ 0 ∧ y ≠ PosInf ⇒ Normal c * y ≠ NegInf
</pre>

<DT><span class="strong">mul_not_infty2</span>
<DD>
<pre>
|- ∀x y.
     x ≠ NegInf ∧ x ≠ PosInf ∧ y ≠ NegInf ∧ y ≠ PosInf ⇒
     x * y ≠ NegInf ∧ x * y ≠ PosInf
</pre>

<DT><span class="strong">add_ldistrib_pos</span>
<DD>
<pre>
|- ∀x y z. 0 ≤ y ∧ 0 ≤ z ⇒ (x * (y + z) = x * y + x * z)
</pre>

<DT><span class="strong">add_ldistrib_neg</span>
<DD>
<pre>
|- ∀x y z. y ≤ 0 ∧ z ≤ 0 ⇒ (x * (y + z) = x * y + x * z)
</pre>

<DT><span class="strong">add_ldistrib_normal</span>
<DD>
<pre>
|- ∀x y z.
     y ≠ PosInf ∧ z ≠ PosInf ∨ y ≠ NegInf ∧ z ≠ NegInf ⇒
     (Normal x * (y + z) = Normal x * y + Normal x * z)
</pre>

<DT><span class="strong">add_ldistrib_normal2</span>
<DD>
<pre>
|- ∀x y z. 0 ≤ x ⇒ (Normal x * (y + z) = Normal x * y + Normal x * z)
</pre>

<DT><span class="strong">add_rdistrib_normal</span>
<DD>
<pre>
|- ∀x y z.
     y ≠ PosInf ∧ z ≠ PosInf ∨ y ≠ NegInf ∧ z ≠ NegInf ⇒
     ((y + z) * Normal x = y * Normal x + z * Normal x)
</pre>

<DT><span class="strong">add_rdistrib_normal2</span>
<DD>
<pre>
|- ∀x y z. 0 ≤ x ⇒ ((y + z) * Normal x = y * Normal x + z * Normal x)
</pre>

<DT><span class="strong">add_ldistrib</span>
<DD>
<pre>
|- ∀x y z. 0 ≤ y ∧ 0 ≤ z ∨ y ≤ 0 ∧ z ≤ 0 ⇒ (x * (y + z) = x * y + x * z)
</pre>

<DT><span class="strong">add_rdistrib</span>
<DD>
<pre>
|- ∀x y z. 0 ≤ y ∧ 0 ≤ z ∨ y ≤ 0 ∧ z ≤ 0 ⇒ ((y + z) * x = y * x + z * x)
</pre>

<DT><span class="strong">mul_lneg</span>
<DD>
<pre>
|- ∀x y. -x * y = -(x * y)
</pre>

<DT><span class="strong">mul_rneg</span>
<DD>
<pre>
|- ∀x y. x * -y = -(x * y)
</pre>

<DT><span class="strong">neg_mul2</span>
<DD>
<pre>
|- ∀x y. -x * -y = x * y
</pre>

<DT><span class="strong">add2_sub2</span>
<DD>
<pre>
|- ∀a b c d.
     b ≠ PosInf ∧ d ≠ PosInf ∨ b ≠ NegInf ∧ d ≠ NegInf ⇒
     (a − b + (c − d) = a + c − (b + d))
</pre>

<DT><span class="strong">sub_ldistrib</span>
<DD>
<pre>
|- ∀x y z.
     x ≠ NegInf ∧ x ≠ PosInf ∧ y ≠ NegInf ∧ y ≠ PosInf ∧ z ≠ NegInf ∧
     z ≠ PosInf ⇒
     (x * (y − z) = x * y − x * z)
</pre>

<DT><span class="strong">sub_rdistrib</span>
<DD>
<pre>
|- ∀x y z.
     x ≠ NegInf ∧ x ≠ PosInf ∧ y ≠ NegInf ∧ y ≠ PosInf ∧ z ≠ NegInf ∧
     z ≠ PosInf ⇒
     ((x − y) * z = x * z − y * z)
</pre>

<DT><span class="strong">extreal_div_eq</span>
<DD>
<pre>
|- ∀x y. Normal x / Normal y = Normal (x / y)
</pre>

<DT><span class="strong">inv_one</span>
<DD>
<pre>
|- inv 1 = 1
</pre>

<DT><span class="strong">inv_1over</span>
<DD>
<pre>
|- ∀x. inv x = 1 / x
</pre>

<DT><span class="strong">div_one</span>
<DD>
<pre>
|- ∀x. x / 1 = x
</pre>

<DT><span class="strong">inv_pos</span>
<DD>
<pre>
|- ∀x. 0 < x ∧ x ≠ PosInf ⇒ 0 < 1 / x
</pre>

<DT><span class="strong">rinv_uniq</span>
<DD>
<pre>
|- ∀x y. (x * y = 1) ⇒ (y = inv x)
</pre>

<DT><span class="strong">linv_uniq</span>
<DD>
<pre>
|- ∀x y. (x * y = 1) ⇒ (x = inv y)
</pre>

<DT><span class="strong">le_rdiv</span>
<DD>
<pre>
|- ∀x y z. 0 < x ⇒ (y * Normal x ≤ z ⇔ y ≤ z / Normal x)
</pre>

<DT><span class="strong">le_ldiv</span>
<DD>
<pre>
|- ∀x y z. 0 < x ⇒ (y ≤ z * Normal x ⇔ y / Normal x ≤ z)
</pre>

<DT><span class="strong">lt_rdiv</span>
<DD>
<pre>
|- ∀x y z. 0 < z ⇒ (x < y / Normal z ⇔ x * Normal z < y)
</pre>

<DT><span class="strong">lt_ldiv</span>
<DD>
<pre>
|- ∀x y z. 0 < z ⇒ (x / Normal z < y ⇔ x < y * Normal z)
</pre>

<DT><span class="strong">lt_rdiv_neg</span>
<DD>
<pre>
|- ∀x y z. z < 0 ⇒ (y / Normal z < x ⇔ x * Normal z < y)
</pre>

<DT><span class="strong">div_add</span>
<DD>
<pre>
|- ∀x y z. x ≠ NegInf ∧ y ≠ NegInf ∧ z ≠ 0 ⇒ (x / z + y / z = (x + y) / z)
</pre>

<DT><span class="strong">le_inv</span>
<DD>
<pre>
|- ∀x. 0 ≤ x ⇒ 0 ≤ inv x
</pre>

<DT><span class="strong">pow_0</span>
<DD>
<pre>
|- ∀x. x pow 0 = 1
</pre>

<DT><span class="strong">pow_1</span>
<DD>
<pre>
|- ∀x. x pow 1 = x
</pre>

<DT><span class="strong">pow_2</span>
<DD>
<pre>
|- ∀x. x pow 2 = x * x
</pre>

<DT><span class="strong">pow_zero</span>
<DD>
<pre>
|- ∀n x. (x pow SUC n = 0) ⇔ (x = 0)
</pre>

<DT><span class="strong">pow_zero_imp</span>
<DD>
<pre>
|- ∀n x. (x pow n = 0) ⇒ (x = 0)
</pre>

<DT><span class="strong">le_pow2</span>
<DD>
<pre>
|- ∀x. 0 ≤ x pow 2
</pre>

<DT><span class="strong">pow_pos_le</span>
<DD>
<pre>
|- ∀x. 0 ≤ x ⇒ ∀n. 0 ≤ x pow n
</pre>

<DT><span class="strong">pow_pos_lt</span>
<DD>
<pre>
|- ∀x n. 0 < x ⇒ 0 < x pow n
</pre>

<DT><span class="strong">pow_le</span>
<DD>
<pre>
|- ∀n x y. 0 ≤ x ∧ x ≤ y ⇒ x pow n ≤ y pow n
</pre>

<DT><span class="strong">pow_lt</span>
<DD>
<pre>
|- ∀n x y. 0 ≤ x ∧ x < y ⇒ x pow SUC n < y pow SUC n
</pre>

<DT><span class="strong">pow_lt2</span>
<DD>
<pre>
|- ∀n x y. n ≠ 0 ∧ 0 ≤ x ∧ x < y ⇒ x pow n < y pow n
</pre>

<DT><span class="strong">pow_le_mono</span>
<DD>
<pre>
|- ∀x n m. 1 ≤ x ∧ n ≤ m ⇒ x pow n ≤ x pow m
</pre>

<DT><span class="strong">pow_pos_even</span>
<DD>
<pre>
|- ∀x. x < 0 ⇒ (0 < x pow n ⇔ EVEN n)
</pre>

<DT><span class="strong">pow_neg_odd</span>
<DD>
<pre>
|- ∀x. x < 0 ⇒ (x pow n < 0 ⇔ ODD n)
</pre>

<DT><span class="strong">add_pow2</span>
<DD>
<pre>
|- ∀x y. (x + y) pow 2 = x pow 2 + y pow 2 + 2 * x * y
</pre>

<DT><span class="strong">pow_add</span>
<DD>
<pre>
|- ∀x n m. x pow (n + m) = x pow n * x pow m
</pre>

<DT><span class="strong">pow_mul</span>
<DD>
<pre>
|- ∀n x y. (x * y) pow n = x pow n * y pow n
</pre>

<DT><span class="strong">pow_minus1</span>
<DD>
<pre>
|- ∀n. -1 pow (2 * n) = 1
</pre>

<DT><span class="strong">pow_not_infty</span>
<DD>
<pre>
|- ∀n x. x ≠ NegInf ∧ x ≠ PosInf ⇒ x pow n ≠ NegInf ∧ x pow n ≠ PosInf
</pre>

<DT><span class="strong">sqrt_pos_le</span>
<DD>
<pre>
|- ∀x. 0 ≤ x ⇒ 0 ≤ sqrt x
</pre>

<DT><span class="strong">sqrt_pos_lt</span>
<DD>
<pre>
|- ∀x. 0 < x ⇒ 0 < sqrt x
</pre>

<DT><span class="strong">pow2_sqrt</span>
<DD>
<pre>
|- ∀x. 0 ≤ x ⇒ (sqrt (x pow 2) = x)
</pre>

<DT><span class="strong">sqrt_pow2</span>
<DD>
<pre>
|- ∀x. (sqrt x pow 2 = x) ⇔ 0 ≤ x
</pre>

<DT><span class="strong">sqrt_mono_le</span>
<DD>
<pre>
|- ∀x y. 0 ≤ x ∧ x ≤ y ⇒ sqrt x ≤ sqrt y
</pre>

<DT><span class="strong">logr_not_infty</span>
<DD>
<pre>
|- ∀x b. x ≠ NegInf ∧ x ≠ PosInf ⇒ logr b x ≠ NegInf ∧ logr b x ≠ PosInf
</pre>

<DT><span class="strong">half_between</span>
<DD>
<pre>
|- (0 < 1 / 2 ∧ 1 / 2 < 1) ∧ 0 ≤ 1 / 2 ∧ 1 / 2 ≤ 1
</pre>

<DT><span class="strong">thirds_between</span>
<DD>
<pre>
|- ((0 < 1 / 3 ∧ 1 / 3 < 1) ∧ 0 < 2 / 3 ∧ 2 / 3 < 1) ∧
   (0 ≤ 1 / 3 ∧ 1 / 3 ≤ 1) ∧ 0 ≤ 2 / 3 ∧ 2 / 3 ≤ 1
</pre>

<DT><span class="strong">half_cancel</span>
<DD>
<pre>
|- 2 * (1 / 2) = 1
</pre>

<DT><span class="strong">third_cancel</span>
<DD>
<pre>
|- 3 * (1 / 3) = 1
</pre>

<DT><span class="strong">fourth_cancel</span>
<DD>
<pre>
|- 4 * (1 / 4) = 1
</pre>

<DT><span class="strong">quotient_normal</span>
<DD>
<pre>
|- ∀n m. &n / &m = Normal (&n / &m)
</pre>

<DT><span class="strong">ext_mono_increasing_suc</span>
<DD>
<pre>
|- ∀f. mono_increasing f ⇔ ∀n. f n ≤ f (SUC n)
</pre>

<DT><span class="strong">ext_mono_decreasing_suc</span>
<DD>
<pre>
|- ∀f. mono_decreasing f ⇔ ∀n. f (SUC n) ≤ f n
</pre>

<DT><span class="strong">EXTREAL_ARCH</span>
<DD>
<pre>
|- ∀x. 0 < x ⇒ ∀y. y ≠ PosInf ⇒ ∃n. y < &n * x
</pre>

<DT><span class="strong">SIMP_REAL_ARCH</span>
<DD>
<pre>
|- ∀x. ∃n. x ≤ &n
</pre>

<DT><span class="strong">SIMP_REAL_ARCH_NEG</span>
<DD>
<pre>
|- ∀x. ∃n. -&n ≤ x
</pre>

<DT><span class="strong">SIMP_EXTREAL_ARCH</span>
<DD>
<pre>
|- ∀x. x ≠ PosInf ⇒ ∃n. x ≤ &n
</pre>

<DT><span class="strong">REAL_ARCH_POW</span>
<DD>
<pre>
|- ∀x. ∃n. x < 2 pow n
</pre>

<DT><span class="strong">EXTREAL_ARCH_POW</span>
<DD>
<pre>
|- ∀x. x ≠ PosInf ⇒ ∃n. x < 2 pow n
</pre>

<DT><span class="strong">EXTREAL_ARCH_POW_INV</span>
<DD>
<pre>
|- ∀e. 0 < e ⇒ ∃n. Normal ((1 / 2) pow n) < e
</pre>

<DT><span class="strong">REAL_LE_MUL_EPSILON</span>
<DD>
<pre>
|- ∀x y. (∀z. 0 < z ∧ z < 1 ⇒ z * x ≤ y) ⇒ x ≤ y
</pre>

<DT><span class="strong">le_epsilon</span>
<DD>
<pre>
|- ∀x y. (∀e. 0 < e ∧ e ≠ PosInf ⇒ x ≤ y + e) ⇒ x ≤ y
</pre>

<DT><span class="strong">le_mul_epsilon</span>
<DD>
<pre>
|- ∀x y. (∀z. 0 ≤ z ∧ z < 1 ⇒ z * x ≤ y) ⇒ x ≤ y
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_THM</span>
<DD>
<pre>
|- ∀f.
     (SIGMA f ∅ = 0) ∧
     ∀e s. FINITE s ⇒ (SIGMA f (e INSERT s) = f e + SIGMA f (s DELETE e))
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_NOT_NEG_INF</span>
<DD>
<pre>
|- ∀f s. FINITE s ∧ (∀x. x ∈ s ⇒ f x ≠ NegInf) ⇒ SIGMA f s ≠ NegInf
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_NOT_POS_INF</span>
<DD>
<pre>
|- ∀f s. FINITE s ∧ (∀x. x ∈ s ⇒ f x ≠ PosInf) ⇒ SIGMA f s ≠ PosInf
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_NOT_INFTY</span>
<DD>
<pre>
|- ∀f s.
     (FINITE s ∧ (∀x. x ∈ s ⇒ f x ≠ NegInf) ⇒ SIGMA f s ≠ NegInf) ∧
     (FINITE s ∧ (∀x. x ∈ s ⇒ f x ≠ PosInf) ⇒ SIGMA f s ≠ PosInf)
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_SING</span>
<DD>
<pre>
|- ∀f e. SIGMA f {e} = f e
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_POS</span>
<DD>
<pre>
|- ∀f s. FINITE s ∧ (∀x. x ∈ s ⇒ 0 ≤ f x) ⇒ 0 ≤ SIGMA f s
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_SPOS</span>
<DD>
<pre>
|- ∀f s. FINITE s ∧ s ≠ ∅ ∧ (∀x. x ∈ s ⇒ 0 < f x) ⇒ 0 < SIGMA f s
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_IF_ELIM</span>
<DD>
<pre>
|- ∀s P f.
     FINITE s ∧ (∀x. x ∈ s ⇒ P x) ⇒
     (SIGMA (λx. if P x then f x else 0) s = SIGMA f s)
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_FINITE_SAME</span>
<DD>
<pre>
|- ∀s.
     FINITE s ⇒
     ∀f p. p ∈ s ∧ (∀q. q ∈ s ⇒ (f p = f q)) ⇒ (SIGMA f s = &CARD s * f p)
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_FINITE_CONST</span>
<DD>
<pre>
|- ∀P. FINITE P ⇒ ∀f x. (∀y. f y = x) ⇒ (SIGMA f P = &CARD P * x)
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_ZERO</span>
<DD>
<pre>
|- ∀s. FINITE s ⇒ (SIGMA (λx. 0) s = 0)
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_0</span>
<DD>
<pre>
|- ∀f s. FINITE s ∧ (∀x. x ∈ s ⇒ (f x = 0)) ⇒ (SIGMA f s = 0)
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_IN_IF</span>
<DD>
<pre>
|- ∀s. FINITE s ⇒ ∀f. SIGMA f s = SIGMA (λx. if x ∈ s then f x else 0) s
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_CMUL</span>
<DD>
<pre>
|- ∀s.
     FINITE s ⇒
     ∀f c.
       0 ≤ c ∨ (∀x. x ∈ s ⇒ 0 ≤ f x) ⇒
       (SIGMA (λx. Normal c * f x) s = Normal c * SIGMA f s)
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_CMUL2</span>
<DD>
<pre>
|- ∀s f c.
     FINITE s ∧ (∀x. x ∈ s ⇒ f x ≠ NegInf) ⇒
     (SIGMA (λx. Normal c * f x) s = Normal c * SIGMA f s)
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_IMAGE</span>
<DD>
<pre>
|- ∀s.
     FINITE s ⇒
     ∀f'. INJ f' s (IMAGE f' s) ⇒ ∀f. SIGMA f (IMAGE f' s) = SIGMA (f o f') s
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_DISJOINT_UNION</span>
<DD>
<pre>
|- ∀s s'.
     FINITE s ∧ FINITE s' ∧ DISJOINT s s' ⇒
     ∀f. SIGMA f (s ∪ s') = SIGMA f s + SIGMA f s'
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_EQ_CARD</span>
<DD>
<pre>
|- ∀s. FINITE s ⇒ (SIGMA (λx. if x ∈ s then 1 else 0) s = &CARD s)
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_INV_CARD_EQ_1</span>
<DD>
<pre>
|- ∀s.
     s ≠ ∅ ∧ FINITE s ⇒ (SIGMA (λx. if x ∈ s then inv (&CARD s) else 0) s = 1)
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_INTER_NONZERO</span>
<DD>
<pre>
|- ∀s. FINITE s ⇒ ∀f. SIGMA f (s ∩ (λp. f p ≠ 0)) = SIGMA f s
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_INTER_ELIM</span>
<DD>
<pre>
|- ∀s.
     FINITE s ⇒
     ∀f s'. (∀x. x ∉ s' ⇒ (f x = 0)) ⇒ (SIGMA f (s ∩ s') = SIGMA f s)
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_ZERO_DIFF</span>
<DD>
<pre>
|- ∀s.
     FINITE s ⇒
     ∀f t. (∀x. x ∈ t ⇒ (f x = 0)) ⇒ (SIGMA f s = SIGMA f (s DIFF t))
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_MONO</span>
<DD>
<pre>
|- ∀s. FINITE s ⇒ ∀f f'. (∀x. x ∈ s ⇒ f x ≤ f' x) ⇒ SIGMA f s ≤ SIGMA f' s
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_MONO_SET</span>
<DD>
<pre>
|- ∀f s t.
     FINITE s ∧ FINITE t ∧ s ⊆ t ∧ (∀x. x ∈ t ⇒ 0 ≤ f x) ⇒
     SIGMA f s ≤ SIGMA f t
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_EQ</span>
<DD>
<pre>
|- ∀s. FINITE s ⇒ ∀f f'. (∀x. x ∈ s ⇒ (f x = f' x)) ⇒ (SIGMA f s = SIGMA f' s)
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_POS_MEM_LE</span>
<DD>
<pre>
|- ∀f s. FINITE s ∧ (∀x. x ∈ s ⇒ 0 ≤ f x) ⇒ ∀x. x ∈ s ⇒ f x ≤ SIGMA f s
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_ADD</span>
<DD>
<pre>
|- ∀s. FINITE s ⇒ ∀f f'. SIGMA (λx. f x + f' x) s = SIGMA f s + SIGMA f' s
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_SUB</span>
<DD>
<pre>
|- ∀s.
     FINITE s ⇒
     ∀f f'.
       (∀x. x ∈ s ⇒ f' x ≠ NegInf) ∨ (∀x. x ∈ s ⇒ f' x ≠ PosInf) ⇒
       (SIGMA (λx. f x − f' x) s = SIGMA f s − SIGMA f' s)
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_EXTREAL_SUM_IMAGE</span>
<DD>
<pre>
|- ∀s s' f.
     FINITE s ∧ FINITE s' ⇒
     (SIGMA (λx. SIGMA (f x) s') s = SIGMA (λx. f (FST x) (SND x)) (s × s'))
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_NORMAL</span>
<DD>
<pre>
|- ∀f s. FINITE s ⇒ (SIGMA (λx. Normal (f x)) s = Normal (SIGMA f s))
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_IN_IF_ALT</span>
<DD>
<pre>
|- ∀s f z. FINITE s ⇒ (SIGMA f s = SIGMA (λx. if x ∈ s then f x else z) s)
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_CROSS_SYM</span>
<DD>
<pre>
|- ∀f s1 s2.
     FINITE s1 ∧ FINITE s2 ⇒
     (SIGMA (λ(x,y). f (x,y)) (s1 × s2) = SIGMA (λ(y,x). f (x,y)) (s2 × s1))
</pre>

<DT><span class="strong">EXTREAL_SUM_IMAGE_COUNT</span>
<DD>
<pre>
|- ∀f.
     (SIGMA f (count 2) = f 0 + f 1) ∧ (SIGMA f (count 3) = f 0 + f 1 + f 2) ∧
     (SIGMA f (count 4) = f 0 + f 1 + f 2 + f 3) ∧
     (SIGMA f (count 5) = f 0 + f 1 + f 2 + f 3 + f 4)
</pre>

<DT><span class="strong">le_sup_imp</span>
<DD>
<pre>
|- ∀p x. p x ⇒ x ≤ sup p
</pre>

<DT><span class="strong">sup_le</span>
<DD>
<pre>
|- ∀p x. sup p ≤ x ⇔ ∀y. p y ⇒ y ≤ x
</pre>

<DT><span class="strong">le_sup</span>
<DD>
<pre>
|- ∀p x. x ≤ sup p ⇔ ∀y. (∀z. p z ⇒ z ≤ y) ⇒ x ≤ y
</pre>

<DT><span class="strong">sup_eq</span>
<DD>
<pre>
|- ∀p x. (sup p = x) ⇔ (∀y. p y ⇒ y ≤ x) ∧ ∀y. (∀z. p z ⇒ z ≤ y) ⇒ x ≤ y
</pre>

<DT><span class="strong">sup_const</span>
<DD>
<pre>
|- ∀x. sup (λy. y = x) = x
</pre>

<DT><span class="strong">sup_const_alt</span>
<DD>
<pre>
|- ∀p z. (∃x. p x) ∧ (∀x. p x ⇒ (x = z)) ⇒ (sup p = z)
</pre>

<DT><span class="strong">sup_const_over_set</span>
<DD>
<pre>
|- ∀s k. s ≠ ∅ ⇒ (sup (IMAGE (λx. k) s) = k)
</pre>

<DT><span class="strong">sup_num</span>
<DD>
<pre>
|- sup (λx. ∃n. x = &n) = PosInf
</pre>

<DT><span class="strong">sup_le_sup_imp</span>
<DD>
<pre>
|- ∀p q. (∀x. p x ⇒ ∃y. q y ∧ x ≤ y) ⇒ sup p ≤ sup q
</pre>

<DT><span class="strong">sup_mono</span>
<DD>
<pre>
|- ∀p q. (∀n. p n ≤ q n) ⇒ sup (IMAGE p 𝕌(:num)) ≤ sup (IMAGE q 𝕌(:num))
</pre>

<DT><span class="strong">sup_suc</span>
<DD>
<pre>
|- ∀f.
     (∀m n. m ≤ n ⇒ f m ≤ f n) ⇒
     (sup (IMAGE (λn. f (SUC n)) 𝕌(:num)) = sup (IMAGE f 𝕌(:num)))
</pre>

<DT><span class="strong">sup_seq</span>
<DD>
<pre>
|- ∀f l.
     mono_increasing f ⇒
     (f --> l ⇔ (sup (IMAGE (λn. Normal (f n)) 𝕌(:num)) = Normal l))
</pre>

<DT><span class="strong">sup_lt_infty</span>
<DD>
<pre>
|- ∀p. sup p < PosInf ⇒ ∀x. p x ⇒ x < PosInf
</pre>

<DT><span class="strong">sup_max</span>
<DD>
<pre>
|- ∀p z. p z ∧ (∀x. p x ⇒ x ≤ z) ⇒ (sup p = z)
</pre>

<DT><span class="strong">sup_add_mono</span>
<DD>
<pre>
|- ∀f g.
     (∀n. 0 ≤ f n) ∧ (∀n. f n ≤ f (SUC n)) ∧ (∀n. 0 ≤ g n) ∧
     (∀n. g n ≤ g (SUC n)) ⇒
     (sup (IMAGE (λn. f n + g n) 𝕌(:num)) =
      sup (IMAGE f 𝕌(:num)) + sup (IMAGE g 𝕌(:num)))
</pre>

<DT><span class="strong">sup_sum_mono</span>
<DD>
<pre>
|- ∀f s.
     FINITE s ∧ (∀i. i ∈ s ⇒ ∀n. 0 ≤ f i n) ∧
     (∀i. i ∈ s ⇒ ∀n. f i n ≤ f i (SUC n)) ⇒
     (sup (IMAGE (λn. SIGMA (λi. f i n) s) 𝕌(:num)) =
      SIGMA (λi. sup (IMAGE (f i) 𝕌(:num))) s)
</pre>

<DT><span class="strong">sup_le_mono</span>
<DD>
<pre>
|- ∀f z. (∀n. f n ≤ f (SUC n)) ∧ z < sup (IMAGE f 𝕌(:num)) ⇒ ∃n. z ≤ f n
</pre>

<DT><span class="strong">sup_cmul</span>
<DD>
<pre>
|- ∀f c.
     0 ≤ c ⇒
     (sup (IMAGE (λn. Normal c * f n) 𝕌(:α)) = Normal c * sup (IMAGE f 𝕌(:α)))
</pre>

<DT><span class="strong">sup_lt</span>
<DD>
<pre>
|- ∀P y. (∃x. P x ∧ y < x) ⇔ y < sup P
</pre>

<DT><span class="strong">sup_lt_epsilon</span>
<DD>
<pre>
|- ∀P e.
     0 < e ∧ (∃x. P x ∧ x ≠ NegInf) ∧ sup P ≠ PosInf ⇒ ∃x. P x ∧ sup P < x + e
</pre>

<DT><span class="strong">inf_le_imp</span>
<DD>
<pre>
|- ∀p x. p x ⇒ inf p ≤ x
</pre>

<DT><span class="strong">le_inf</span>
<DD>
<pre>
|- ∀p x. x ≤ inf p ⇔ ∀y. p y ⇒ x ≤ y
</pre>

<DT><span class="strong">inf_le</span>
<DD>
<pre>
|- ∀p x. inf p ≤ x ⇔ ∀y. (∀z. p z ⇒ y ≤ z) ⇒ y ≤ x
</pre>

<DT><span class="strong">inf_eq</span>
<DD>
<pre>
|- ∀p x. (inf p = x) ⇔ (∀y. p y ⇒ x ≤ y) ∧ ∀y. (∀z. p z ⇒ y ≤ z) ⇒ y ≤ x
</pre>

<DT><span class="strong">inf_const</span>
<DD>
<pre>
|- ∀x. inf (λy. y = x) = x
</pre>

<DT><span class="strong">inf_const_alt</span>
<DD>
<pre>
|- ∀p z. (∃x. p x) ∧ (∀x. p x ⇒ (x = z)) ⇒ (inf p = z)
</pre>

<DT><span class="strong">inf_const_over_set</span>
<DD>
<pre>
|- ∀s k. s ≠ ∅ ⇒ (inf (IMAGE (λx. k) s) = k)
</pre>

<DT><span class="strong">inf_suc</span>
<DD>
<pre>
|- ∀f.
     (∀m n. m ≤ n ⇒ f n ≤ f m) ⇒
     (inf (IMAGE (λn. f (SUC n)) 𝕌(:num)) = inf (IMAGE f 𝕌(:num)))
</pre>

<DT><span class="strong">inf_seq</span>
<DD>
<pre>
|- ∀f l.
     mono_decreasing f ⇒
     (f --> l ⇔ (inf (IMAGE (λn. Normal (f n)) 𝕌(:num)) = Normal l))
</pre>

<DT><span class="strong">inf_lt_infty</span>
<DD>
<pre>
|- ∀p. NegInf < inf p ⇒ ∀x. p x ⇒ NegInf < x
</pre>

<DT><span class="strong">inf_min</span>
<DD>
<pre>
|- ∀p z. p z ∧ (∀x. p x ⇒ z ≤ x) ⇒ (inf p = z)
</pre>

<DT><span class="strong">inf_cminus</span>
<DD>
<pre>
|- ∀f c.
     Normal c − inf (IMAGE f 𝕌(:α)) = sup (IMAGE (λn. Normal c − f n) 𝕌(:α))
</pre>

<DT><span class="strong">ext_suminf_add</span>
<DD>
<pre>
|- ∀f g.
     (∀n. 0 ≤ f n ∧ 0 ≤ g n) ⇒ (suminf (λn. f n + g n) = suminf f + suminf g)
</pre>

<DT><span class="strong">ext_suminf_cmul</span>
<DD>
<pre>
|- ∀f c. 0 ≤ c ∧ (∀n. 0 ≤ f n) ⇒ (suminf (λn. c * f n) = c * suminf f)
</pre>

<DT><span class="strong">ext_suminf_cmul_alt</span>
<DD>
<pre>
|- ∀f c.
     0 ≤ c ∧ ((∀n. f n ≠ NegInf) ∨ ∀n. f n ≠ PosInf) ⇒
     (suminf (λn. Normal c * f n) = Normal c * suminf f)
</pre>

<DT><span class="strong">ext_suminf_lt_infty</span>
<DD>
<pre>
|- ∀f. (∀n. 0 ≤ f n) ∧ suminf f ≠ PosInf ⇒ ∀n. f n < PosInf
</pre>

<DT><span class="strong">ext_suminf_suminf</span>
<DD>
<pre>
|- ∀r.
     (∀n. 0 ≤ r n) ∧ suminf (λn. Normal (r n)) ≠ PosInf ⇒
     (suminf (λn. Normal (r n)) = Normal (suminf r))
</pre>

<DT><span class="strong">ext_suminf_mono</span>
<DD>
<pre>
|- ∀f g. (∀n. g n ≠ NegInf ∧ g n ≤ f n) ⇒ suminf g ≤ suminf f
</pre>

<DT><span class="strong">ext_suminf_sub</span>
<DD>
<pre>
|- ∀f g.
     (∀n. 0 ≤ g n ∧ g n ≤ f n) ∧ suminf f ≠ PosInf ⇒
     (suminf (λi. f i − g i) = suminf f − suminf g)
</pre>

<DT><span class="strong">ext_suminf_sum</span>
<DD>
<pre>
|- ∀f n.
     (∀n. 0 ≤ f n) ∧ (∀m. n ≤ m ⇒ (f m = 0)) ⇒ (suminf f = SIGMA f (count n))
</pre>

<DT><span class="strong">min_le</span>
<DD>
<pre>
|- ∀z x y. min x y ≤ z ⇔ x ≤ z ∨ y ≤ z
</pre>

<DT><span class="strong">min_le1</span>
<DD>
<pre>
|- ∀x y. min x y ≤ x
</pre>

<DT><span class="strong">min_le2</span>
<DD>
<pre>
|- ∀x y. min x y ≤ y
</pre>

<DT><span class="strong">le_min</span>
<DD>
<pre>
|- ∀z x y. z ≤ min x y ⇔ z ≤ x ∧ z ≤ y
</pre>

<DT><span class="strong">min_le2_imp</span>
<DD>
<pre>
|- ∀x1 x2 y1 y2. x1 ≤ y1 ∧ x2 ≤ y2 ⇒ min x1 x2 ≤ min y1 y2
</pre>

<DT><span class="strong">min_refl</span>
<DD>
<pre>
|- ∀x. min x x = x
</pre>

<DT><span class="strong">min_comm</span>
<DD>
<pre>
|- ∀x y. min x y = min y x
</pre>

<DT><span class="strong">min_infty</span>
<DD>
<pre>
|- ∀x.
     (min x PosInf = x) ∧ (min PosInf x = x) ∧ (min NegInf x = NegInf) ∧
     (min x NegInf = NegInf)
</pre>

<DT><span class="strong">le_max</span>
<DD>
<pre>
|- ∀z x y. z ≤ max x y ⇔ z ≤ x ∨ z ≤ y
</pre>

<DT><span class="strong">le_max1</span>
<DD>
<pre>
|- ∀x y. x ≤ max x y
</pre>

<DT><span class="strong">le_max2</span>
<DD>
<pre>
|- ∀x y. y ≤ max x y
</pre>

<DT><span class="strong">max_le</span>
<DD>
<pre>
|- ∀z x y. max x y ≤ z ⇔ x ≤ z ∧ y ≤ z
</pre>

<DT><span class="strong">max_le2_imp</span>
<DD>
<pre>
|- ∀x1 x2 y1 y2. x1 ≤ y1 ∧ x2 ≤ y2 ⇒ max x1 x2 ≤ max y1 y2
</pre>

<DT><span class="strong">max_refl</span>
<DD>
<pre>
|- ∀x. max x x = x
</pre>

<DT><span class="strong">max_comm</span>
<DD>
<pre>
|- ∀x y. max x y = max y x
</pre>

<DT><span class="strong">max_infty</span>
<DD>
<pre>
|- ∀x.
     (max x PosInf = PosInf) ∧ (max PosInf x = PosInf) ∧ (max NegInf x = x) ∧
     (max x NegInf = x)
</pre>

<DT><span class="strong">Q_not_infty</span>
<DD>
<pre>
|- ∀x. x ∈ Q_set ⇒ ∃y. x = Normal y
</pre>

<DT><span class="strong">Q_COUNTABLE</span>
<DD>
<pre>
|- countable Q_set
</pre>

<DT><span class="strong">NUM_IN_Q</span>
<DD>
<pre>
|- ∀n. &n ∈ Q_set ∧ -&n ∈ Q_set
</pre>

<DT><span class="strong">Q_INFINITE</span>
<DD>
<pre>
|- INFINITE Q_set
</pre>

<DT><span class="strong">OPP_IN_Q</span>
<DD>
<pre>
|- ∀x. x ∈ Q_set ⇒ -x ∈ Q_set
</pre>

<DT><span class="strong">INV_IN_Q</span>
<DD>
<pre>
|- ∀x. x ∈ Q_set ∧ x ≠ 0 ⇒ 1 / x ∈ Q_set
</pre>

<DT><span class="strong">CMUL_IN_Q</span>
<DD>
<pre>
|- ∀z x. x ∈ Q_set ⇒ &z * x ∈ Q_set ∧ -&z * x ∈ Q_set
</pre>

<DT><span class="strong">ADD_IN_Q</span>
<DD>
<pre>
|- ∀x y. x ∈ Q_set ∧ y ∈ Q_set ⇒ x + y ∈ Q_set
</pre>

<DT><span class="strong">SUB_IN_Q</span>
<DD>
<pre>
|- ∀x y. x ∈ Q_set ∧ y ∈ Q_set ⇒ x − y ∈ Q_set
</pre>

<DT><span class="strong">MUL_IN_Q</span>
<DD>
<pre>
|- ∀x y. x ∈ Q_set ∧ y ∈ Q_set ⇒ x * y ∈ Q_set
</pre>

<DT><span class="strong">DIV_IN_Q</span>
<DD>
<pre>
|- ∀x y. x ∈ Q_set ∧ y ∈ Q_set ∧ y ≠ 0 ⇒ x / y ∈ Q_set
</pre>

<DT><span class="strong">rat_not_infty</span>
<DD>
<pre>
|- ∀r. r ∈ Q_set ⇒ r ≠ NegInf ∧ r ≠ PosInf
</pre>

<DT><span class="strong">CEILING_LBOUND</span>
<DD>
<pre>
|- ∀x. Normal x ≤ &ceiling (Normal x)
</pre>

<DT><span class="strong">CEILING_UBOUND</span>
<DD>
<pre>
|- ∀x. 0 ≤ x ⇒ &ceiling (Normal x) < Normal x + 1
</pre>

<DT><span class="strong">Q_DENSE_IN_R_LEMMA</span>
<DD>
<pre>
|- ∀x y. 0 ≤ x ∧ x < y ⇒ ∃r. r ∈ Q_set ∧ x < r ∧ r < y
</pre>

<DT><span class="strong">Q_DENSE_IN_R</span>
<DD>
<pre>
|- ∀x y. x < y ⇒ ∃r. r ∈ Q_set ∧ x < r ∧ r < y
</pre>

<DT><span class="strong">COUNTABLE_ENUM_Q</span>
<DD>
<pre>
|- ∀c. countable c ⇔ (c = ∅) ∨ ∃f. c = IMAGE f Q_set
</pre>

<DT><span class="strong">CROSS_COUNTABLE_UNIV</span>
<DD>
<pre>
|- countable (𝕌(:num) × 𝕌(:num))
</pre>

<DT><span class="strong">CROSS_COUNTABLE_LEMMA1</span>
<DD>
<pre>
|- ∀s. countable s ∧ FINITE s ∧ countable t ⇒ countable (s × t)
</pre>

<DT><span class="strong">CROSS_COUNTABLE_LEMMA2</span>
<DD>
<pre>
|- ∀s. countable s ∧ countable t ∧ FINITE t ⇒ countable (s × t)
</pre>

<DT><span class="strong">CROSS_COUNTABLE</span>
<DD>
<pre>
|- ∀s. countable s ∧ countable t ⇒ countable (s × t)
</pre>

<DT><span class="strong">COUNTABLE_RATIONAL_INTERVALS</span>
<DD>
<pre>
|- countable rational_intervals
</pre>

</DL>



<hr>
</body>
</html>
