<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure llistTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure llistTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/llist/llistScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature llistTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#LAPPEND-val">LAPPEND</a> : thm
<a name="line7"></a>    val <a href="#LCONS-val">LCONS</a> : thm
<a name="line8"></a>    val <a href="#LDROP-val">LDROP</a> : thm
<a name="line9"></a>    val <a href="#LFILTER-val">LFILTER</a> : thm
<a name="line10"></a>    val <a href="#LFINITE_def-val">LFINITE_def</a> : thm
<a name="line11"></a>    val <a href="#LFLATTEN-val">LFLATTEN</a> : thm
<a name="line12"></a>    val <a href="#LHD-val">LHD</a> : thm
<a name="line13"></a>    val <a href="#LLENGTH-val">LLENGTH</a> : thm
<a name="line14"></a>    val <a href="#LMAP-val">LMAP</a> : thm
<a name="line15"></a>    val <a href="#LNIL-val">LNIL</a> : thm
<a name="line16"></a>    val <a href="#LNTH-val">LNTH</a> : thm
<a name="line17"></a>    val <a href="#LTAKE-val">LTAKE</a> : thm
<a name="line18"></a>    val <a href="#LTL-val">LTL</a> : thm
<a name="line19"></a>    val <a href="#LUNFOLD-val">LUNFOLD</a> : thm
<a name="line20"></a>    val <a href="#LUNZIP_THM-val">LUNZIP_THM</a> : thm
<a name="line21"></a>    val <a href="#LZIP_THM-val">LZIP_THM</a> : thm
<a name="line22"></a>    val <a href="#every_def-val">every_def</a> : thm
<a name="line23"></a>    val <a href="#exists_def-val">exists_def</a> : thm
<a name="line24"></a>    val <a href="#fromList-val">fromList</a> : thm
<a name="line25"></a>    val <a href="#linear_order_to_list_f_def-val">linear_order_to_list_f_def</a> : thm
<a name="line26"></a>    val <a href="#llength_rel_def-val">llength_rel_def</a> : thm
<a name="line27"></a>    val <a href="#llist_TY_DEF-val">llist_TY_DEF</a> : thm
<a name="line28"></a>    val <a href="#llist_absrep-val">llist_absrep</a> : thm
<a name="line29"></a>    val <a href="#lrep_ok_def-val">lrep_ok_def</a> : thm
<a name="line30"></a>    val <a href="#toList-val">toList</a> : thm
<a name="line31"></a>
<a name="line32"></a>  (*  Theorems  *)
<a name="line33"></a>    val <a href="#LAPPEND_ASSOC-val">LAPPEND_ASSOC</a> : thm
<a name="line34"></a>    val <a href="#LAPPEND_EQ_LNIL-val">LAPPEND_EQ_LNIL</a> : thm
<a name="line35"></a>    val <a href="#LAPPEND_NIL_2ND-val">LAPPEND_NIL_2ND</a> : thm
<a name="line36"></a>    val <a href="#LAPPEND_fromList-val">LAPPEND_fromList</a> : thm
<a name="line37"></a>    val <a href="#LCONS_11-val">LCONS_11</a> : thm
<a name="line38"></a>    val <a href="#LCONS_NOT_NIL-val">LCONS_NOT_NIL</a> : thm
<a name="line39"></a>    val <a href="#LDROP1_THM-val">LDROP1_THM</a> : thm
<a name="line40"></a>    val <a href="#LDROP_THM-val">LDROP_THM</a> : thm
<a name="line41"></a>    val <a href="#LFILTER_APPEND-val">LFILTER_APPEND</a> : thm
<a name="line42"></a>    val <a href="#LFILTER_EQ_NIL-val">LFILTER_EQ_NIL</a> : thm
<a name="line43"></a>    val <a href="#LFILTER_NIL-val">LFILTER_NIL</a> : thm
<a name="line44"></a>    val <a href="#LFILTER_THM-val">LFILTER_THM</a> : thm
<a name="line45"></a>    val <a href="#LFINITE-val">LFINITE</a> : thm
<a name="line46"></a>    val <a href="#LFINITE_APPEND-val">LFINITE_APPEND</a> : thm
<a name="line47"></a>    val <a href="#LFINITE_DROP-val">LFINITE_DROP</a> : thm
<a name="line48"></a>    val <a href="#LFINITE_HAS_LENGTH-val">LFINITE_HAS_LENGTH</a> : thm
<a name="line49"></a>    val <a href="#LFINITE_INDUCTION-val">LFINITE_INDUCTION</a> : thm
<a name="line50"></a>    val <a href="#LFINITE_MAP-val">LFINITE_MAP</a> : thm
<a name="line51"></a>    val <a href="#LFINITE_STRONG_INDUCTION-val">LFINITE_STRONG_INDUCTION</a> : thm
<a name="line52"></a>    val <a href="#LFINITE_TAKE-val">LFINITE_TAKE</a> : thm
<a name="line53"></a>    val <a href="#LFINITE_THM-val">LFINITE_THM</a> : thm
<a name="line54"></a>    val <a href="#LFINITE_cases-val">LFINITE_cases</a> : thm
<a name="line55"></a>    val <a href="#LFINITE_fromList-val">LFINITE_fromList</a> : thm
<a name="line56"></a>    val <a href="#LFINITE_ind-val">LFINITE_ind</a> : thm
<a name="line57"></a>    val <a href="#LFINITE_rules-val">LFINITE_rules</a> : thm
<a name="line58"></a>    val <a href="#LFINITE_strongind-val">LFINITE_strongind</a> : thm
<a name="line59"></a>    val <a href="#LFINITE_toList-val">LFINITE_toList</a> : thm
<a name="line60"></a>    val <a href="#LFLATTEN_APPEND-val">LFLATTEN_APPEND</a> : thm
<a name="line61"></a>    val <a href="#LFLATTEN_EQ_NIL-val">LFLATTEN_EQ_NIL</a> : thm
<a name="line62"></a>    val <a href="#LFLATTEN_SINGLETON-val">LFLATTEN_SINGLETON</a> : thm
<a name="line63"></a>    val <a href="#LFLATTEN_THM-val">LFLATTEN_THM</a> : thm
<a name="line64"></a>    val <a href="#LHDTL_CONS_THM-val">LHDTL_CONS_THM</a> : thm
<a name="line65"></a>    val <a href="#LHDTL_EQ_SOME-val">LHDTL_EQ_SOME</a> : thm
<a name="line66"></a>    val <a href="#LHD_EQ_NONE-val">LHD_EQ_NONE</a> : thm
<a name="line67"></a>    val <a href="#LHD_LCONS-val">LHD_LCONS</a> : thm
<a name="line68"></a>    val <a href="#LHD_THM-val">LHD_THM</a> : thm
<a name="line69"></a>    val <a href="#LLENGTH_APPEND-val">LLENGTH_APPEND</a> : thm
<a name="line70"></a>    val <a href="#LLENGTH_MAP-val">LLENGTH_MAP</a> : thm
<a name="line71"></a>    val <a href="#LLENGTH_THM-val">LLENGTH_THM</a> : thm
<a name="line72"></a>    val <a href="#LLENGTH_fromList-val">LLENGTH_fromList</a> : thm
<a name="line73"></a>    val <a href="#LLIST_BISIMULATION-val">LLIST_BISIMULATION</a> : thm
<a name="line74"></a>    val <a href="#LLIST_BISIMULATION0-val">LLIST_BISIMULATION0</a> : thm
<a name="line75"></a>    val <a href="#LLIST_EQ-val">LLIST_EQ</a> : thm
<a name="line76"></a>    val <a href="#LLIST_STRONG_BISIMULATION-val">LLIST_STRONG_BISIMULATION</a> : thm
<a name="line77"></a>    val <a href="#LL_ALL_THM-val">LL_ALL_THM</a> : thm
<a name="line78"></a>    val <a href="#LMAP_APPEND-val">LMAP_APPEND</a> : thm
<a name="line79"></a>    val <a href="#LMAP_LUNFOLD-val">LMAP_LUNFOLD</a> : thm
<a name="line80"></a>    val <a href="#LMAP_MAP-val">LMAP_MAP</a> : thm
<a name="line81"></a>    val <a href="#LNTH_EQ-val">LNTH_EQ</a> : thm
<a name="line82"></a>    val <a href="#LNTH_LDROP-val">LNTH_LDROP</a> : thm
<a name="line83"></a>    val <a href="#LNTH_THM-val">LNTH_THM</a> : thm
<a name="line84"></a>    val <a href="#LTAKE_CONS_EQ_NONE-val">LTAKE_CONS_EQ_NONE</a> : thm
<a name="line85"></a>    val <a href="#LTAKE_CONS_EQ_SOME-val">LTAKE_CONS_EQ_SOME</a> : thm
<a name="line86"></a>    val <a href="#LTAKE_DROP-val">LTAKE_DROP</a> : thm
<a name="line87"></a>    val <a href="#LTAKE_EQ-val">LTAKE_EQ</a> : thm
<a name="line88"></a>    val <a href="#LTAKE_EQ_SOME_CONS-val">LTAKE_EQ_SOME_CONS</a> : thm
<a name="line89"></a>    val <a href="#LTAKE_LENGTH-val">LTAKE_LENGTH</a> : thm
<a name="line90"></a>    val <a href="#LTAKE_LNTH-val">LTAKE_LNTH</a> : thm
<a name="line91"></a>    val <a href="#LTAKE_NIL_EQ_NONE-val">LTAKE_NIL_EQ_NONE</a> : thm
<a name="line92"></a>    val <a href="#LTAKE_NIL_EQ_SOME-val">LTAKE_NIL_EQ_SOME</a> : thm
<a name="line93"></a>    val <a href="#LTAKE_SNOC_LNTH-val">LTAKE_SNOC_LNTH</a> : thm
<a name="line94"></a>    val <a href="#LTAKE_THM-val">LTAKE_THM</a> : thm
<a name="line95"></a>    val <a href="#LTAKE_fromList-val">LTAKE_fromList</a> : thm
<a name="line96"></a>    val <a href="#LTL_EQ_NONE-val">LTL_EQ_NONE</a> : thm
<a name="line97"></a>    val <a href="#LTL_LCONS-val">LTL_LCONS</a> : thm
<a name="line98"></a>    val <a href="#LTL_THM-val">LTL_THM</a> : thm
<a name="line99"></a>    val <a href="#LUNFOLD_EQ-val">LUNFOLD_EQ</a> : thm
<a name="line100"></a>    val <a href="#LUNFOLD_THM-val">LUNFOLD_THM</a> : thm
<a name="line101"></a>    val <a href="#LZIP_LUNZIP-val">LZIP_LUNZIP</a> : thm
<a name="line102"></a>    val <a href="#MONO_every-val">MONO_every</a> : thm
<a name="line103"></a>    val <a href="#MONO_exists-val">MONO_exists</a> : thm
<a name="line104"></a>    val <a href="#NOT_LFINITE_APPEND-val">NOT_LFINITE_APPEND</a> : thm
<a name="line105"></a>    val <a href="#NOT_LFINITE_DROP-val">NOT_LFINITE_DROP</a> : thm
<a name="line106"></a>    val <a href="#NOT_LFINITE_NO_LENGTH-val">NOT_LFINITE_NO_LENGTH</a> : thm
<a name="line107"></a>    val <a href="#NOT_LFINITE_TAKE-val">NOT_LFINITE_TAKE</a> : thm
<a name="line108"></a>    val <a href="#every_coind-val">every_coind</a> : thm
<a name="line109"></a>    val <a href="#every_strong_coind-val">every_strong_coind</a> : thm
<a name="line110"></a>    val <a href="#every_thm-val">every_thm</a> : thm
<a name="line111"></a>    val <a href="#exists_LDROP-val">exists_LDROP</a> : thm
<a name="line112"></a>    val <a href="#exists_LNTH-val">exists_LNTH</a> : thm
<a name="line113"></a>    val <a href="#exists_cases-val">exists_cases</a> : thm
<a name="line114"></a>    val <a href="#exists_ind-val">exists_ind</a> : thm
<a name="line115"></a>    val <a href="#exists_rules-val">exists_rules</a> : thm
<a name="line116"></a>    val <a href="#exists_strong_ind-val">exists_strong_ind</a> : thm
<a name="line117"></a>    val <a href="#exists_strongind-val">exists_strongind</a> : thm
<a name="line118"></a>    val <a href="#exists_thm-val">exists_thm</a> : thm
<a name="line119"></a>    val <a href="#from_toList-val">from_toList</a> : thm
<a name="line120"></a>    val <a href="#linear_order_to_llist-val">linear_order_to_llist</a> : thm
<a name="line121"></a>    val <a href="#llength_rel_cases-val">llength_rel_cases</a> : thm
<a name="line122"></a>    val <a href="#llength_rel_ind-val">llength_rel_ind</a> : thm
<a name="line123"></a>    val <a href="#llength_rel_rules-val">llength_rel_rules</a> : thm
<a name="line124"></a>    val <a href="#llength_rel_strongind-val">llength_rel_strongind</a> : thm
<a name="line125"></a>    val <a href="#llist_Axiom-val">llist_Axiom</a> : thm
<a name="line126"></a>    val <a href="#llist_Axiom_1-val">llist_Axiom_1</a> : thm
<a name="line127"></a>    val <a href="#llist_Axiom_1ue-val">llist_Axiom_1ue</a> : thm
<a name="line128"></a>    val <a href="#llist_CASES-val">llist_CASES</a> : thm
<a name="line129"></a>    val <a href="#llist_rep_LCONS-val">llist_rep_LCONS</a> : thm
<a name="line130"></a>    val <a href="#llist_ue_Axiom-val">llist_ue_Axiom</a> : thm
<a name="line131"></a>    val <a href="#toList_THM-val">toList_THM</a> : thm
<a name="line132"></a>    val <a href="#to_fromList-val">to_fromList</a> : thm
<a name="line133"></a>
<a name="line134"></a>  val llist_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line135"></a>(*
   [list] Parent theory of "llist"

   [set_relation] Parent theory of "llist"

   [<a name="LAPPEND-val"><b>LAPPEND</b></a>]  Definition

      |- (∀x. LAPPEND [||] x = x) ∧
         ∀h t x. LAPPEND (h:::t) x = h:::LAPPEND t x

   [<a name="LCONS-val"><b>LCONS</b></a>]  Definition

      |- ∀h t.
           h:::t =
           llist_abs (λn. if n = 0 then SOME h else llist_rep t (n − 1))

   [<a name="LDROP-val"><b>LDROP</b></a>]  Definition

      |- (∀ll. LDROP 0 ll = SOME ll) ∧
         ∀n ll.
           LDROP (SUC n) ll = OPTION_JOIN (OPTION_MAP (LDROP n) (LTL ll))

   [<a name="LFILTER-val"><b>LFILTER</b></a>]  Definition

      |- ∀P ll.
           LFILTER P ll =
           if ¬exists P ll then [||]
           else if P (THE (LHD ll)) then
             THE (LHD ll):::LFILTER P (THE (LTL ll))
           else LFILTER P (THE (LTL ll))

   [<a name="LFINITE_def-val"><b>LFINITE_def</b></a>]  Definition

      |- LFINITE =
         (λa0.
            ∀LFINITE'.
              (∀a0.
                 (a0 = [||]) ∨ (∃h t. (a0 = h:::t) ∧ LFINITE' t) ⇒
                 LFINITE' a0) ⇒
              LFINITE' a0)

   [<a name="LFLATTEN-val"><b>LFLATTEN</b></a>]  Definition

      |- ∀ll.
           LFLATTEN ll =
           if every ($= [||]) ll then [||]
           else if THE (LHD ll) = [||] then LFLATTEN (THE (LTL ll))
           else
             THE (LHD (THE (LHD ll))):::
                 LFLATTEN (THE (LTL (THE (LHD ll))):::THE (LTL ll))

   [<a name="LHD-val"><b>LHD</b></a>]  Definition

      |- ∀ll. LHD ll = llist_rep ll 0

   [<a name="LLENGTH-val"><b>LLENGTH</b></a>]  Definition

      |- ∀ll.
           LLENGTH ll =
           if LFINITE ll then SOME (@n. llength_rel ll n) else NONE

   [<a name="LMAP-val"><b>LMAP</b></a>]  Definition

      |- (∀f. LMAP f [||] = [||]) ∧ ∀f h t. LMAP f (h:::t) = f h:::LMAP f t

   [<a name="LNIL-val"><b>LNIL</b></a>]  Definition

      |- [||] = llist_abs (λn. NONE)

   [<a name="LNTH-val"><b>LNTH</b></a>]  Definition

      |- (∀ll. LNTH 0 ll = LHD ll) ∧
         ∀n ll.
           LNTH (SUC n) ll = OPTION_JOIN (OPTION_MAP (LNTH n) (LTL ll))

   [<a name="LTAKE-val"><b>LTAKE</b></a>]  Definition

      |- (∀ll. LTAKE 0 ll = SOME []) ∧
         ∀n ll.
           LTAKE (SUC n) ll =
           case LHD ll of
             NONE =&gt; NONE
           | SOME hd =&gt;
               case LTAKE n (THE (LTL ll)) of
                 NONE =&gt; NONE
               | SOME tl =&gt; SOME (hd::tl)

   [<a name="LTL-val"><b>LTL</b></a>]  Definition

      |- ∀ll.
           LTL ll =
           case LHD ll of
             NONE =&gt; NONE
           | SOME v =&gt; SOME (llist_abs (λn. llist_rep ll (n + 1)))

   [<a name="LUNFOLD-val"><b>LUNFOLD</b></a>]  Definition

      |- ∀f x.
           LUNFOLD f x =
           case f x of NONE =&gt; [||] | SOME (v1,v2) =&gt; v2:::LUNFOLD f v1

   [<a name="LUNZIP_THM-val"><b>LUNZIP_THM</b></a>]  Definition

      |- (LUNZIP [||] = ([||],[||])) ∧
         ∀x y t.
           LUNZIP ((x,y):::t) =
           (let (ll1,ll2) = LUNZIP t in (x:::ll1,y:::ll2))

   [<a name="LZIP_THM-val"><b>LZIP_THM</b></a>]  Definition

      |- (∀l1. LZIP (l1,[||]) = [||]) ∧ (∀l2. LZIP ([||],l2) = [||]) ∧
         ∀h1 h2 t1 t2. LZIP (h1:::t1,h2:::t2) = (h1,h2):::LZIP (t1,t2)

   [<a name="every_def-val"><b>every_def</b></a>]  Definition

      |- ∀P ll. every P ll ⇔ ¬exists ($~ o P) ll

   [<a name="exists_def-val"><b>exists_def</b></a>]  Definition

      |- exists =
         (λP a0.
            ∀exists'.
              (∀a0.
                 (∃h t. (a0 = h:::t) ∧ P h) ∨
                 (∃h t. (a0 = h:::t) ∧ exists' t) ⇒
                 exists' a0) ⇒
              exists' a0)

   [<a name="fromList-val"><b>fromList</b></a>]  Definition

      |- (fromList [] = [||]) ∧ ∀h t. fromList (h::t) = h:::fromList t

   [<a name="linear_order_to_list_f_def-val"><b>linear_order_to_list_f_def</b></a>]  Definition

      |- ∀lo.
           linear_order_to_list_f lo =
           (let min = minimal_elements (domain lo ∪ range lo) lo
            in
              if min = ∅ then NONE
              else
                SOME
                  (rrestrict lo (domain lo ∪ range lo DIFF min),
                   CHOICE min))

   [<a name="llength_rel_def-val"><b>llength_rel_def</b></a>]  Definition

      |- llength_rel =
         (λa0 a1.
            ∀llength_rel'.
              (∀a0 a1.
                 (a0 = [||]) ∧ (a1 = 0) ∨
                 (∃h n t. (a0 = h:::t) ∧ (a1 = SUC n) ∧ llength_rel' t n) ⇒
                 llength_rel' a0 a1) ⇒
              llength_rel' a0 a1)

   [<a name="llist_TY_DEF-val"><b>llist_TY_DEF</b></a>]  Definition

      |- ∃rep. TYPE_DEFINITION lrep_ok rep

   [<a name="llist_absrep-val"><b>llist_absrep</b></a>]  Definition

      |- (∀a. llist_abs (llist_rep a) = a) ∧
         ∀r. lrep_ok r ⇔ (llist_rep (llist_abs r) = r)

   [<a name="lrep_ok_def-val"><b>lrep_ok_def</b></a>]  Definition

      |- ∀f.
           lrep_ok f ⇔
           ∃P.
             (∀g.
                P g ⇒
                (g = (λn. NONE)) ∨
                ∃h t.
                  P t ∧ (g = (λn. if n = 0 then SOME h else t (n − 1)))) ∧
             P f

   [<a name="toList-val"><b>toList</b></a>]  Definition

      |- ∀ll.
           toList ll =
           if LFINITE ll then LTAKE (THE (LLENGTH ll)) ll else NONE

   [<a name="LAPPEND_ASSOC-val"><b>LAPPEND_ASSOC</b></a>]  Theorem

      |- ∀ll1 ll2 ll3.
           LAPPEND (LAPPEND ll1 ll2) ll3 = LAPPEND ll1 (LAPPEND ll2 ll3)

   [<a name="LAPPEND_EQ_LNIL-val"><b>LAPPEND_EQ_LNIL</b></a>]  Theorem

      |- (LAPPEND l1 l2 = [||]) ⇔ (l1 = [||]) ∧ (l2 = [||])

   [<a name="LAPPEND_NIL_2ND-val"><b>LAPPEND_NIL_2ND</b></a>]  Theorem

      |- ∀ll. LAPPEND ll [||] = ll

   [<a name="LAPPEND_fromList-val"><b>LAPPEND_fromList</b></a>]  Theorem

      |- ∀l1 l2. LAPPEND (fromList l1) (fromList l2) = fromList (l1 ++ l2)

   [<a name="LCONS_11-val"><b>LCONS_11</b></a>]  Theorem

      |- ∀h1 t1 h2 t2. (h1:::t1 = h2:::t2) ⇔ (h1 = h2) ∧ (t1 = t2)

   [<a name="LCONS_NOT_NIL-val"><b>LCONS_NOT_NIL</b></a>]  Theorem

      |- ∀h t. h:::t ≠ [||] ∧ [||] ≠ h:::t

   [<a name="LDROP1_THM-val"><b>LDROP1_THM</b></a>]  Theorem

      |- LDROP 1 = LTL

   [<a name="LDROP_THM-val"><b>LDROP_THM</b></a>]  Theorem

      |- (∀ll. LDROP 0 ll = SOME ll) ∧ (∀n. LDROP (SUC n) [||] = NONE) ∧
         ∀n h t. LDROP (SUC n) (h:::t) = LDROP n t

   [<a name="LFILTER_APPEND-val"><b>LFILTER_APPEND</b></a>]  Theorem

      |- ∀P ll1 ll2.
           LFINITE ll1 ⇒
           (LFILTER P (LAPPEND ll1 ll2) =
            LAPPEND (LFILTER P ll1) (LFILTER P ll2))

   [<a name="LFILTER_EQ_NIL-val"><b>LFILTER_EQ_NIL</b></a>]  Theorem

      |- ∀ll. (LFILTER P ll = [||]) ⇔ every ($~ o P) ll

   [<a name="LFILTER_NIL-val"><b>LFILTER_NIL</b></a>]  Theorem

      |- ∀P ll. every ($~ o P) ll ⇒ (LFILTER P ll = [||])

   [<a name="LFILTER_THM-val"><b>LFILTER_THM</b></a>]  Theorem

      |- (∀P. LFILTER P [||] = [||]) ∧
         ∀P h t.
           LFILTER P (h:::t) = if P h then h:::LFILTER P t else LFILTER P t

   [<a name="LFINITE-val"><b>LFINITE</b></a>]  Theorem

      |- LFINITE ll ⇔ ∃n. LTAKE n ll = NONE

   [<a name="LFINITE_APPEND-val"><b>LFINITE_APPEND</b></a>]  Theorem

      |- ∀ll1 ll2. LFINITE (LAPPEND ll1 ll2) ⇔ LFINITE ll1 ∧ LFINITE ll2

   [<a name="LFINITE_DROP-val"><b>LFINITE_DROP</b></a>]  Theorem

      |- ∀n ll. LFINITE ll ∧ n ≤ THE (LLENGTH ll) ⇒ ∃y. LDROP n ll = SOME y

   [<a name="LFINITE_HAS_LENGTH-val"><b>LFINITE_HAS_LENGTH</b></a>]  Theorem

      |- ∀ll. LFINITE ll ⇒ ∃n. LLENGTH ll = SOME n

   [<a name="LFINITE_INDUCTION-val"><b>LFINITE_INDUCTION</b></a>]  Theorem

      |- ∀P. P [||] ∧ (∀h t. P t ⇒ P (h:::t)) ⇒ ∀a0. LFINITE a0 ⇒ P a0

   [<a name="LFINITE_MAP-val"><b>LFINITE_MAP</b></a>]  Theorem

      |- ∀f ll. LFINITE (LMAP f ll) ⇔ LFINITE ll

   [<a name="LFINITE_STRONG_INDUCTION-val"><b>LFINITE_STRONG_INDUCTION</b></a>]  Theorem

      |- P [||] ∧ (∀h t. LFINITE t ∧ P t ⇒ P (h:::t)) ⇒
         ∀a0. LFINITE a0 ⇒ P a0

   [<a name="LFINITE_TAKE-val"><b>LFINITE_TAKE</b></a>]  Theorem

      |- ∀n ll. LFINITE ll ∧ n ≤ THE (LLENGTH ll) ⇒ ∃y. LTAKE n ll = SOME y

   [<a name="LFINITE_THM-val"><b>LFINITE_THM</b></a>]  Theorem

      |- (LFINITE [||] ⇔ T) ∧ ∀h t. LFINITE (h:::t) ⇔ LFINITE t

   [<a name="LFINITE_cases-val"><b>LFINITE_cases</b></a>]  Theorem

      |- ∀a0. LFINITE a0 ⇔ (a0 = [||]) ∨ ∃h t. (a0 = h:::t) ∧ LFINITE t

   [<a name="LFINITE_fromList-val"><b>LFINITE_fromList</b></a>]  Theorem

      |- ∀l. LFINITE (fromList l)

   [<a name="LFINITE_ind-val"><b>LFINITE_ind</b></a>]  Theorem

      |- ∀LFINITE'.
           LFINITE' [||] ∧ (∀h t. LFINITE' t ⇒ LFINITE' (h:::t)) ⇒
           ∀a0. LFINITE a0 ⇒ LFINITE' a0

   [<a name="LFINITE_rules-val"><b>LFINITE_rules</b></a>]  Theorem

      |- LFINITE [||] ∧ ∀h t. LFINITE t ⇒ LFINITE (h:::t)

   [<a name="LFINITE_strongind-val"><b>LFINITE_strongind</b></a>]  Theorem

      |- ∀LFINITE'.
           LFINITE' [||] ∧
           (∀h t. LFINITE t ∧ LFINITE' t ⇒ LFINITE' (h:::t)) ⇒
           ∀a0. LFINITE a0 ⇒ LFINITE' a0

   [<a name="LFINITE_toList-val"><b>LFINITE_toList</b></a>]  Theorem

      |- ∀ll. LFINITE ll ⇒ ∃l. toList ll = SOME l

   [<a name="LFLATTEN_APPEND-val"><b>LFLATTEN_APPEND</b></a>]  Theorem

      |- ∀h t. LFLATTEN (h:::t) = LAPPEND h (LFLATTEN t)

   [<a name="LFLATTEN_EQ_NIL-val"><b>LFLATTEN_EQ_NIL</b></a>]  Theorem

      |- ∀ll. (LFLATTEN ll = [||]) ⇔ every ($= [||]) ll

   [<a name="LFLATTEN_SINGLETON-val"><b>LFLATTEN_SINGLETON</b></a>]  Theorem

      |- ∀h. LFLATTEN [|h|] = h

   [<a name="LFLATTEN_THM-val"><b>LFLATTEN_THM</b></a>]  Theorem

      |- (LFLATTEN [||] = [||]) ∧ (∀tl. LFLATTEN ([||]:::t) = LFLATTEN t) ∧
         ∀h t tl. LFLATTEN ((h:::t):::tl) = h:::LFLATTEN (t:::tl)

   [<a name="LHDTL_CONS_THM-val"><b>LHDTL_CONS_THM</b></a>]  Theorem

      |- ∀h t. (LHD (h:::t) = SOME h) ∧ (LTL (h:::t) = SOME t)

   [<a name="LHDTL_EQ_SOME-val"><b>LHDTL_EQ_SOME</b></a>]  Theorem

      |- ∀h t ll. (ll = h:::t) ⇔ (LHD ll = SOME h) ∧ (LTL ll = SOME t)

   [<a name="LHD_EQ_NONE-val"><b>LHD_EQ_NONE</b></a>]  Theorem

      |- ∀ll.
           ((LHD ll = NONE) ⇔ (ll = [||])) ∧
           ((NONE = LHD ll) ⇔ (ll = [||]))

   [<a name="LHD_LCONS-val"><b>LHD_LCONS</b></a>]  Theorem

      |- LHD (h:::t) = SOME h

   [<a name="LHD_THM-val"><b>LHD_THM</b></a>]  Theorem

      |- (LHD [||] = NONE) ∧ ∀h t. LHD (h:::t) = SOME h

   [<a name="LLENGTH_APPEND-val"><b>LLENGTH_APPEND</b></a>]  Theorem

      |- ∀ll1 ll2.
           LLENGTH (LAPPEND ll1 ll2) =
           if LFINITE ll1 ∧ LFINITE ll2 then
             SOME (THE (LLENGTH ll1) + THE (LLENGTH ll2))
           else NONE

   [<a name="LLENGTH_MAP-val"><b>LLENGTH_MAP</b></a>]  Theorem

      |- ∀ll f. LLENGTH (LMAP f ll) = LLENGTH ll

   [<a name="LLENGTH_THM-val"><b>LLENGTH_THM</b></a>]  Theorem

      |- (LLENGTH [||] = SOME 0) ∧
         ∀h t. LLENGTH (h:::t) = OPTION_MAP SUC (LLENGTH t)

   [<a name="LLENGTH_fromList-val"><b>LLENGTH_fromList</b></a>]  Theorem

      |- ∀l. LLENGTH (fromList l) = SOME (LENGTH l)

   [<a name="LLIST_BISIMULATION-val"><b>LLIST_BISIMULATION</b></a>]  Theorem

      |- ∀ll1 ll2.
           (ll1 = ll2) ⇔
           ∃R.
             R ll1 ll2 ∧
             ∀ll3 ll4.
               R ll3 ll4 ⇒
               (ll3 = [||]) ∧ (ll4 = [||]) ∨
               (LHD ll3 = LHD ll4) ∧ R (THE (LTL ll3)) (THE (LTL ll4))

   [<a name="LLIST_BISIMULATION0-val"><b>LLIST_BISIMULATION0</b></a>]  Theorem

      |- ∀ll1 ll2.
           (ll1 = ll2) ⇔
           ∃R.
             R ll1 ll2 ∧
             ∀ll3 ll4.
               R ll3 ll4 ⇒
               (ll3 = [||]) ∧ (ll4 = [||]) ∨
               ∃h t1 t2. (ll3 = h:::t1) ∧ (ll4 = h:::t2) ∧ R t1 t2

   [<a name="LLIST_EQ-val"><b>LLIST_EQ</b></a>]  Theorem

      |- ∀f g.
           (∀x.
              (f x = [||]) ∧ (g x = [||]) ∨
              ∃h y. (f x = h:::f y) ∧ (g x = h:::g y)) ⇒
           ∀x. f x = g x

   [<a name="LLIST_STRONG_BISIMULATION-val"><b>LLIST_STRONG_BISIMULATION</b></a>]  Theorem

      |- ∀ll1 ll2.
           (ll1 = ll2) ⇔
           ∃R.
             R ll1 ll2 ∧
             ∀ll3 ll4.
               R ll3 ll4 ⇒
               (ll3 = ll4) ∨
               ∃h t1 t2. (ll3 = h:::t1) ∧ (ll4 = h:::t2) ∧ R t1 t2

   [<a name="LL_ALL_THM-val"><b>LL_ALL_THM</b></a>]  Theorem

      |- (every P [||] ⇔ T) ∧ (every P (h:::t) ⇔ P h ∧ every P t)

   [<a name="LMAP_APPEND-val"><b>LMAP_APPEND</b></a>]  Theorem

      |- ∀f ll1 ll2.
           LMAP f (LAPPEND ll1 ll2) = LAPPEND (LMAP f ll1) (LMAP f ll2)

   [<a name="LMAP_LUNFOLD-val"><b>LMAP_LUNFOLD</b></a>]  Theorem

      |- ∀f g s.
           LMAP f (LUNFOLD g s) =
           LUNFOLD (λs. OPTION_MAP (λ(x,y). (x,f y)) (g s)) s

   [<a name="LMAP_MAP-val"><b>LMAP_MAP</b></a>]  Theorem

      |- ∀f g ll. LMAP f (LMAP g ll) = LMAP (f o g) ll

   [<a name="LNTH_EQ-val"><b>LNTH_EQ</b></a>]  Theorem

      |- ∀ll1 ll2. (ll1 = ll2) ⇔ ∀n. LNTH n ll1 = LNTH n ll2

   [<a name="LNTH_LDROP-val"><b>LNTH_LDROP</b></a>]  Theorem

      |- ∀n l x. (LNTH n l = SOME x) ⇒ (LHD (THE (LDROP n l)) = SOME x)

   [<a name="LNTH_THM-val"><b>LNTH_THM</b></a>]  Theorem

      |- (∀n. LNTH n [||] = NONE) ∧ (∀h t. LNTH 0 (h:::t) = SOME h) ∧
         ∀n h t. LNTH (SUC n) (h:::t) = LNTH n t

   [<a name="LTAKE_CONS_EQ_NONE-val"><b>LTAKE_CONS_EQ_NONE</b></a>]  Theorem

      |- ∀m h t.
           (LTAKE m (h:::t) = NONE) ⇔ ∃n. (m = SUC n) ∧ (LTAKE n t = NONE)

   [<a name="LTAKE_CONS_EQ_SOME-val"><b>LTAKE_CONS_EQ_SOME</b></a>]  Theorem

      |- ∀m h t l.
           (LTAKE m (h:::t) = SOME l) ⇔
           (m = 0) ∧ (l = []) ∨
           ∃n l'. (m = SUC n) ∧ (LTAKE n t = SOME l') ∧ (l = h::l')

   [<a name="LTAKE_DROP-val"><b>LTAKE_DROP</b></a>]  Theorem

      |- (∀n ll.
            ¬LFINITE ll ⇒
            (LAPPEND (fromList (THE (LTAKE n ll))) (THE (LDROP n ll)) =
             ll)) ∧
         ∀n ll.
           LFINITE ll ∧ n ≤ THE (LLENGTH ll) ⇒
           (LAPPEND (fromList (THE (LTAKE n ll))) (THE (LDROP n ll)) = ll)

   [<a name="LTAKE_EQ-val"><b>LTAKE_EQ</b></a>]  Theorem

      |- ∀ll1 ll2. (ll1 = ll2) ⇔ ∀n. LTAKE n ll1 = LTAKE n ll2

   [<a name="LTAKE_EQ_SOME_CONS-val"><b>LTAKE_EQ_SOME_CONS</b></a>]  Theorem

      |- ∀n l x. (LTAKE n l = SOME x) ⇒ ∀h. ∃y. LTAKE n (h:::l) = SOME y

   [<a name="LTAKE_LENGTH-val"><b>LTAKE_LENGTH</b></a>]  Theorem

      |- ∀n ll l. (LTAKE n ll = SOME l) ⇒ (n = LENGTH l)

   [<a name="LTAKE_LNTH-val"><b>LTAKE_LNTH</b></a>]  Theorem

      |- ∀n ll. (LTAKE n ll = NONE) ⇒ (LNTH n ll = NONE)

   [<a name="LTAKE_NIL_EQ_NONE-val"><b>LTAKE_NIL_EQ_NONE</b></a>]  Theorem

      |- ∀m. (LTAKE m [||] = NONE) ⇔ 0 &lt; m

   [<a name="LTAKE_NIL_EQ_SOME-val"><b>LTAKE_NIL_EQ_SOME</b></a>]  Theorem

      |- ∀l m. (LTAKE m [||] = SOME l) ⇔ (m = 0) ∧ (l = [])

   [<a name="LTAKE_SNOC_LNTH-val"><b>LTAKE_SNOC_LNTH</b></a>]  Theorem

      |- ∀n ll.
           LTAKE (SUC n) ll =
           case LTAKE n ll of
             NONE =&gt; NONE
           | SOME l =&gt;
               case LNTH n ll of NONE =&gt; NONE | SOME e =&gt; SOME (l ++ [e])

   [<a name="LTAKE_THM-val"><b>LTAKE_THM</b></a>]  Theorem

      |- (∀l. LTAKE 0 l = SOME []) ∧ (∀n. LTAKE (SUC n) [||] = NONE) ∧
         ∀n h t. LTAKE (SUC n) (h:::t) = OPTION_MAP (CONS h) (LTAKE n t)

   [<a name="LTAKE_fromList-val"><b>LTAKE_fromList</b></a>]  Theorem

      |- ∀l. LTAKE (LENGTH l) (fromList l) = SOME l

   [<a name="LTL_EQ_NONE-val"><b>LTL_EQ_NONE</b></a>]  Theorem

      |- ∀ll.
           ((LTL ll = NONE) ⇔ (ll = [||])) ∧
           ((NONE = LTL ll) ⇔ (ll = [||]))

   [<a name="LTL_LCONS-val"><b>LTL_LCONS</b></a>]  Theorem

      |- LTL (h:::t) = SOME t

   [<a name="LTL_THM-val"><b>LTL_THM</b></a>]  Theorem

      |- (LTL [||] = NONE) ∧ ∀h t. LTL (h:::t) = SOME t

   [<a name="LUNFOLD_EQ-val"><b>LUNFOLD_EQ</b></a>]  Theorem

      |- ∀R f s ll.
           R s ll ∧
           (∀s ll.
              R s ll ⇒
              (f s = NONE) ∧ (ll = [||]) ∨
              ∃s' x ll'.
                (f s = SOME (s',x)) ∧ (LHD ll = SOME x) ∧
                (LTL ll = SOME ll') ∧ R s' ll') ⇒
           (LUNFOLD f s = ll)

   [<a name="LUNFOLD_THM-val"><b>LUNFOLD_THM</b></a>]  Theorem

      |- ∀f x v1 v2.
           ((f x = NONE) ⇒ (LUNFOLD f x = [||])) ∧
           ((f x = SOME (v1,v2)) ⇒ (LUNFOLD f x = v2:::LUNFOLD f v1))

   [<a name="LZIP_LUNZIP-val"><b>LZIP_LUNZIP</b></a>]  Theorem

      |- ∀ll. LZIP (LUNZIP ll) = ll

   [<a name="MONO_every-val"><b>MONO_every</b></a>]  Theorem

      |- (∀x. P x ⇒ Q x) ⇒ every P l ⇒ every Q l

   [<a name="MONO_exists-val"><b>MONO_exists</b></a>]  Theorem

      |- (∀x. P x ⇒ Q x) ⇒ exists P l ⇒ exists Q l

   [<a name="NOT_LFINITE_APPEND-val"><b>NOT_LFINITE_APPEND</b></a>]  Theorem

      |- ∀ll1 ll2. ¬LFINITE ll1 ⇒ (LAPPEND ll1 ll2 = ll1)

   [<a name="NOT_LFINITE_DROP-val"><b>NOT_LFINITE_DROP</b></a>]  Theorem

      |- ∀ll. ¬LFINITE ll ⇒ ∀n. ∃y. LDROP n ll = SOME y

   [<a name="NOT_LFINITE_NO_LENGTH-val"><b>NOT_LFINITE_NO_LENGTH</b></a>]  Theorem

      |- ∀ll. ¬LFINITE ll ⇒ (LLENGTH ll = NONE)

   [<a name="NOT_LFINITE_TAKE-val"><b>NOT_LFINITE_TAKE</b></a>]  Theorem

      |- ∀ll. ¬LFINITE ll ⇒ ∀n. ∃y. LTAKE n ll = SOME y

   [<a name="every_coind-val"><b>every_coind</b></a>]  Theorem

      |- ∀P Q. (∀h t. Q (h:::t) ⇒ P h ∧ Q t) ⇒ ∀ll. Q ll ⇒ every P ll

   [<a name="every_strong_coind-val"><b>every_strong_coind</b></a>]  Theorem

      |- ∀P Q.
           (∀h t. Q (h:::t) ⇒ P h) ∧ (∀h t. Q (h:::t) ⇒ Q t ∨ every P t) ⇒
           ∀ll. Q ll ⇒ every P ll

   [<a name="every_thm-val"><b>every_thm</b></a>]  Theorem

      |- (every P [||] ⇔ T) ∧ (every P (h:::t) ⇔ P h ∧ every P t)

   [<a name="exists_LDROP-val"><b>exists_LDROP</b></a>]  Theorem

      |- exists P ll ⇔ ∃n a t. (LDROP n ll = SOME (a:::t)) ∧ P a

   [<a name="exists_LNTH-val"><b>exists_LNTH</b></a>]  Theorem

      |- ∀l. exists P l ⇔ ∃n e. (SOME e = LNTH n l) ∧ P e

   [<a name="exists_cases-val"><b>exists_cases</b></a>]  Theorem

      |- ∀P a0.
           exists P a0 ⇔
           (∃h t. (a0 = h:::t) ∧ P h) ∨ ∃h t. (a0 = h:::t) ∧ exists P t

   [<a name="exists_ind-val"><b>exists_ind</b></a>]  Theorem

      |- ∀P exists'.
           (∀h t. P h ⇒ exists' (h:::t)) ∧
           (∀h t. exists' t ⇒ exists' (h:::t)) ⇒
           ∀a0. exists P a0 ⇒ exists' a0

   [<a name="exists_rules-val"><b>exists_rules</b></a>]  Theorem

      |- ∀P.
           (∀h t. P h ⇒ exists P (h:::t)) ∧
           ∀h t. exists P t ⇒ exists P (h:::t)

   [<a name="exists_strong_ind-val"><b>exists_strong_ind</b></a>]  Theorem

      |- ∀P Q.
           (∀h t. P h ⇒ Q (h:::t)) ∧ (∀h t. Q t ∧ exists P t ⇒ Q (h:::t)) ⇒
           ∀a0. exists P a0 ⇒ Q a0

   [<a name="exists_strongind-val"><b>exists_strongind</b></a>]  Theorem

      |- ∀P exists'.
           (∀h t. P h ⇒ exists' (h:::t)) ∧
           (∀h t. exists P t ∧ exists' t ⇒ exists' (h:::t)) ⇒
           ∀a0. exists P a0 ⇒ exists' a0

   [<a name="exists_thm-val"><b>exists_thm</b></a>]  Theorem

      |- (exists P [||] ⇔ F) ∧ (exists P (h:::t) ⇔ P h ∨ exists P t)

   [<a name="from_toList-val"><b>from_toList</b></a>]  Theorem

      |- ∀l. toList (fromList l) = SOME l

   [<a name="linear_order_to_llist-val"><b>linear_order_to_llist</b></a>]  Theorem

      |- ∀lo X.
           linear_order lo X ∧ finite_prefixes lo X ⇒
           ∃ll.
             (X = {x | ∃i. LNTH i ll = SOME x}) ∧
             lo ⊆
             {(x,y) |
              ∃i j. i ≤ j ∧ (LNTH i ll = SOME x) ∧ (LNTH j ll = SOME y)} ∧
             ∀i j x. (LNTH i ll = SOME x) ∧ (LNTH j ll = SOME x) ⇒ (i = j)

   [<a name="llength_rel_cases-val"><b>llength_rel_cases</b></a>]  Theorem

      |- ∀a0 a1.
           llength_rel a0 a1 ⇔
           (a0 = [||]) ∧ (a1 = 0) ∨
           ∃h n t. (a0 = h:::t) ∧ (a1 = SUC n) ∧ llength_rel t n

   [<a name="llength_rel_ind-val"><b>llength_rel_ind</b></a>]  Theorem

      |- ∀llength_rel'.
           llength_rel' [||] 0 ∧
           (∀h n t. llength_rel' t n ⇒ llength_rel' (h:::t) (SUC n)) ⇒
           ∀a0 a1. llength_rel a0 a1 ⇒ llength_rel' a0 a1

   [<a name="llength_rel_rules-val"><b>llength_rel_rules</b></a>]  Theorem

      |- llength_rel [||] 0 ∧
         ∀h n t. llength_rel t n ⇒ llength_rel (h:::t) (SUC n)

   [<a name="llength_rel_strongind-val"><b>llength_rel_strongind</b></a>]  Theorem

      |- ∀llength_rel'.
           llength_rel' [||] 0 ∧
           (∀h n t.
              llength_rel t n ∧ llength_rel' t n ⇒
              llength_rel' (h:::t) (SUC n)) ⇒
           ∀a0 a1. llength_rel a0 a1 ⇒ llength_rel' a0 a1

   [<a name="llist_Axiom-val"><b>llist_Axiom</b></a>]  Theorem

      |- ∀f.
           ∃g.
             (∀x. LHD (g x) = OPTION_MAP SND (f x)) ∧
             ∀x. LTL (g x) = OPTION_MAP (g o FST) (f x)

   [<a name="llist_Axiom_1-val"><b>llist_Axiom_1</b></a>]  Theorem

      |- ∀f. ∃g. ∀x. g x = case f x of NONE =&gt; [||] | SOME (a,b) =&gt; b:::g a

   [<a name="llist_Axiom_1ue-val"><b>llist_Axiom_1ue</b></a>]  Theorem

      |- ∀f.
           ∃!g. ∀x. g x = case f x of NONE =&gt; [||] | SOME (a,b) =&gt; b:::g a

   [<a name="llist_CASES-val"><b>llist_CASES</b></a>]  Theorem

      |- ∀l. (l = [||]) ∨ ∃h t. l = h:::t

   [<a name="llist_rep_LCONS-val"><b>llist_rep_LCONS</b></a>]  Theorem

      |- llist_rep (h:::t) =
         (λn. if n = 0 then SOME h else llist_rep t (n − 1))

   [<a name="llist_ue_Axiom-val"><b>llist_ue_Axiom</b></a>]  Theorem

      |- ∀f.
           ∃!g.
             (∀x. LHD (g x) = OPTION_MAP SND (f x)) ∧
             ∀x. LTL (g x) = OPTION_MAP (g o FST) (f x)

   [<a name="toList_THM-val"><b>toList_THM</b></a>]  Theorem

      |- (toList [||] = SOME []) ∧
         ∀h t. toList (h:::t) = OPTION_MAP (CONS h) (toList t)

   [<a name="to_fromList-val"><b>to_fromList</b></a>]  Theorem

      |- ∀ll. LFINITE ll ⇒ (fromList (THE (toList ll)) = ll)


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/llist/llistScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-9</a></em></p></body></html>
