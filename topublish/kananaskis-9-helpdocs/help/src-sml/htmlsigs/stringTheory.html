<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure stringTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure stringTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/string/stringScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature stringTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#DEST_STRING_def-val">DEST_STRING_def</a> : thm
<a name="line7"></a>    val <a href="#EXPLODE_def-val">EXPLODE_def</a> : thm
<a name="line8"></a>    val <a href="#EXTRACT_primitive_def-val">EXTRACT_primitive_def</a> : thm
<a name="line9"></a>    val <a href="#FIELDS_curried_def-val">FIELDS_curried_def</a> : thm
<a name="line10"></a>    val <a href="#FIELDS_tupled_primitive_def-val">FIELDS_tupled_primitive_def</a> : thm
<a name="line11"></a>    val <a href="#IMPLODE_def-val">IMPLODE_def</a> : thm
<a name="line12"></a>    val <a href="#STR_def-val">STR_def</a> : thm
<a name="line13"></a>    val <a href="#SUBSTRING_def-val">SUBSTRING_def</a> : thm
<a name="line14"></a>    val <a href="#SUB_def-val">SUB_def</a> : thm
<a name="line15"></a>    val <a href="#TOKENS_curried_def-val">TOKENS_curried_def</a> : thm
<a name="line16"></a>    val <a href="#TOKENS_tupled_primitive_def-val">TOKENS_tupled_primitive_def</a> : thm
<a name="line17"></a>    val <a href="#TRANSLATE_def-val">TRANSLATE_def</a> : thm
<a name="line18"></a>    val <a href="#char_BIJ-val">char_BIJ</a> : thm
<a name="line19"></a>    val <a href="#char_TY_DEF-val">char_TY_DEF</a> : thm
<a name="line20"></a>    val <a href="#char_ge_def-val">char_ge_def</a> : thm
<a name="line21"></a>    val <a href="#char_gt_def-val">char_gt_def</a> : thm
<a name="line22"></a>    val <a href="#char_le_def-val">char_le_def</a> : thm
<a name="line23"></a>    val <a href="#char_lt_def-val">char_lt_def</a> : thm
<a name="line24"></a>    val <a href="#char_size_def-val">char_size_def</a> : thm
<a name="line25"></a>    val <a href="#isAlphaNum_def-val">isAlphaNum_def</a> : thm
<a name="line26"></a>    val <a href="#isAlpha_def-val">isAlpha_def</a> : thm
<a name="line27"></a>    val <a href="#isAscii_def-val">isAscii_def</a> : thm
<a name="line28"></a>    val <a href="#isCntrl_def-val">isCntrl_def</a> : thm
<a name="line29"></a>    val <a href="#isDigit_def-val">isDigit_def</a> : thm
<a name="line30"></a>    val <a href="#isGraph_def-val">isGraph_def</a> : thm
<a name="line31"></a>    val <a href="#isHexDigit_def-val">isHexDigit_def</a> : thm
<a name="line32"></a>    val <a href="#isLower_def-val">isLower_def</a> : thm
<a name="line33"></a>    val <a href="#isPrint_def-val">isPrint_def</a> : thm
<a name="line34"></a>    val <a href="#isPunct_def-val">isPunct_def</a> : thm
<a name="line35"></a>    val <a href="#isSpace_def-val">isSpace_def</a> : thm
<a name="line36"></a>    val <a href="#isUpper_def-val">isUpper_def</a> : thm
<a name="line37"></a>    val <a href="#string_ge_def-val">string_ge_def</a> : thm
<a name="line38"></a>    val <a href="#string_gt_def-val">string_gt_def</a> : thm
<a name="line39"></a>    val <a href="#string_le_def-val">string_le_def</a> : thm
<a name="line40"></a>    val <a href="#string_lt_curried_def-val">string_lt_curried_def</a> : thm
<a name="line41"></a>    val <a href="#string_lt_tupled_primitive_def-val">string_lt_tupled_primitive_def</a> : thm
<a name="line42"></a>    val <a href="#toLower_def-val">toLower_def</a> : thm
<a name="line43"></a>    val <a href="#toUpper_def-val">toUpper_def</a> : thm
<a name="line44"></a>
<a name="line45"></a>  (*  Theorems  *)
<a name="line46"></a>    val <a href="#CHAR_EQ_THM-val">CHAR_EQ_THM</a> : thm
<a name="line47"></a>    val <a href="#CHAR_INDUCT_THM-val">CHAR_INDUCT_THM</a> : thm
<a name="line48"></a>    val <a href="#CHR_11-val">CHR_11</a> : thm
<a name="line49"></a>    val <a href="#CHR_ONTO-val">CHR_ONTO</a> : thm
<a name="line50"></a>    val <a href="#CHR_ORD-val">CHR_ORD</a> : thm
<a name="line51"></a>    val <a href="#DEST_STRING_LEMS-val">DEST_STRING_LEMS</a> : thm
<a name="line52"></a>    val <a href="#EXPLODE_11-val">EXPLODE_11</a> : thm
<a name="line53"></a>    val <a href="#EXPLODE_DEST_STRING-val">EXPLODE_DEST_STRING</a> : thm
<a name="line54"></a>    val <a href="#EXPLODE_EQNS-val">EXPLODE_EQNS</a> : thm
<a name="line55"></a>    val <a href="#EXPLODE_EQ_NIL-val">EXPLODE_EQ_NIL</a> : thm
<a name="line56"></a>    val <a href="#EXPLODE_EQ_THM-val">EXPLODE_EQ_THM</a> : thm
<a name="line57"></a>    val <a href="#EXPLODE_IMPLODE-val">EXPLODE_IMPLODE</a> : thm
<a name="line58"></a>    val <a href="#EXPLODE_ONTO-val">EXPLODE_ONTO</a> : thm
<a name="line59"></a>    val <a href="#EXTRACT_def-val">EXTRACT_def</a> : thm
<a name="line60"></a>    val <a href="#EXTRACT_ind-val">EXTRACT_ind</a> : thm
<a name="line61"></a>    val <a href="#FIELDS_def-val">FIELDS_def</a> : thm
<a name="line62"></a>    val <a href="#FIELDS_ind-val">FIELDS_ind</a> : thm
<a name="line63"></a>    val <a href="#IMPLODE_11-val">IMPLODE_11</a> : thm
<a name="line64"></a>    val <a href="#IMPLODE_EQNS-val">IMPLODE_EQNS</a> : thm
<a name="line65"></a>    val <a href="#IMPLODE_EQ_EMPTYSTRING-val">IMPLODE_EQ_EMPTYSTRING</a> : thm
<a name="line66"></a>    val <a href="#IMPLODE_EQ_THM-val">IMPLODE_EQ_THM</a> : thm
<a name="line67"></a>    val <a href="#IMPLODE_EXPLODE-val">IMPLODE_EXPLODE</a> : thm
<a name="line68"></a>    val <a href="#IMPLODE_EXPLODE_I-val">IMPLODE_EXPLODE_I</a> : thm
<a name="line69"></a>    val <a href="#IMPLODE_ONTO-val">IMPLODE_ONTO</a> : thm
<a name="line70"></a>    val <a href="#IMPLODE_STRING-val">IMPLODE_STRING</a> : thm
<a name="line71"></a>    val <a href="#ORD_11-val">ORD_11</a> : thm
<a name="line72"></a>    val <a href="#ORD_BOUND-val">ORD_BOUND</a> : thm
<a name="line73"></a>    val <a href="#ORD_CHR-val">ORD_CHR</a> : thm
<a name="line74"></a>    val <a href="#ORD_CHR_COMPUTE-val">ORD_CHR_COMPUTE</a> : thm
<a name="line75"></a>    val <a href="#ORD_CHR_RWT-val">ORD_CHR_RWT</a> : thm
<a name="line76"></a>    val <a href="#ORD_ONTO-val">ORD_ONTO</a> : thm
<a name="line77"></a>    val <a href="#STRCAT-val">STRCAT</a> : thm
<a name="line78"></a>    val <a href="#STRCAT_11-val">STRCAT_11</a> : thm
<a name="line79"></a>    val <a href="#STRCAT_ACYCLIC-val">STRCAT_ACYCLIC</a> : thm
<a name="line80"></a>    val <a href="#STRCAT_ASSOC-val">STRCAT_ASSOC</a> : thm
<a name="line81"></a>    val <a href="#STRCAT_EQNS-val">STRCAT_EQNS</a> : thm
<a name="line82"></a>    val <a href="#STRCAT_EQ_EMPTY-val">STRCAT_EQ_EMPTY</a> : thm
<a name="line83"></a>    val <a href="#STRCAT_EXPLODE-val">STRCAT_EXPLODE</a> : thm
<a name="line84"></a>    val <a href="#STRCAT_def-val">STRCAT_def</a> : thm
<a name="line85"></a>    val <a href="#STRING_ACYCLIC-val">STRING_ACYCLIC</a> : thm
<a name="line86"></a>    val <a href="#STRLEN_CAT-val">STRLEN_CAT</a> : thm
<a name="line87"></a>    val <a href="#STRLEN_DEF-val">STRLEN_DEF</a> : thm
<a name="line88"></a>    val <a href="#STRLEN_EQ_0-val">STRLEN_EQ_0</a> : thm
<a name="line89"></a>    val <a href="#STRLEN_EXPLODE_THM-val">STRLEN_EXPLODE_THM</a> : thm
<a name="line90"></a>    val <a href="#STRLEN_THM-val">STRLEN_THM</a> : thm
<a name="line91"></a>    val <a href="#TOKENS_def-val">TOKENS_def</a> : thm
<a name="line92"></a>    val <a href="#TOKENS_ind-val">TOKENS_ind</a> : thm
<a name="line93"></a>    val <a href="#char_nchotomy-val">char_nchotomy</a> : thm
<a name="line94"></a>    val <a href="#isPREFIX_DEF-val">isPREFIX_DEF</a> : thm
<a name="line95"></a>    val <a href="#isPREFIX_IND-val">isPREFIX_IND</a> : thm
<a name="line96"></a>    val <a href="#isPREFIX_STRCAT-val">isPREFIX_STRCAT</a> : thm
<a name="line97"></a>    val <a href="#ranged_char_nchotomy-val">ranged_char_nchotomy</a> : thm
<a name="line98"></a>    val <a href="#string_lt_antisym-val">string_lt_antisym</a> : thm
<a name="line99"></a>    val <a href="#string_lt_cases-val">string_lt_cases</a> : thm
<a name="line100"></a>    val <a href="#string_lt_def-val">string_lt_def</a> : thm
<a name="line101"></a>    val <a href="#string_lt_ind-val">string_lt_ind</a> : thm
<a name="line102"></a>    val <a href="#string_lt_nonrefl-val">string_lt_nonrefl</a> : thm
<a name="line103"></a>    val <a href="#string_lt_trans-val">string_lt_trans</a> : thm
<a name="line104"></a>
<a name="line105"></a>  val string_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line106"></a>(*
   [rich_list] Parent theory of "string"

   [<a name="DEST_STRING_def-val"><b>DEST_STRING_def</b></a>]  Definition

      |- (DEST_STRING "" = NONE) ∧
         ∀c rst. DEST_STRING (STRING c rst) = SOME (c,rst)

   [<a name="EXPLODE_def-val"><b>EXPLODE_def</b></a>]  Definition

      |- (EXPLODE "" = "") ∧
         ∀c s. EXPLODE (STRING c s) = STRING c (EXPLODE s)

   [<a name="EXTRACT_primitive_def-val"><b>EXTRACT_primitive_def</b></a>]  Definition

      |- EXTRACT =
         WFREC (@R. WF R)
           (λEXTRACT a.
              case a of
                (s,i,NONE) =&gt; I (SUBSTRING (s,i,STRLEN s − i))
              | (s,i,SOME n) =&gt; I (SUBSTRING (s,i,n)))

   [<a name="FIELDS_curried_def-val"><b>FIELDS_curried_def</b></a>]  Definition

      |- ∀x x1. FIELDS x x1 = FIELDS_tupled (x,x1)

   [<a name="FIELDS_tupled_primitive_def-val"><b>FIELDS_tupled_primitive_def</b></a>]  Definition

      |- FIELDS_tupled =
         WFREC
           (@R.
              WF R ∧
              (∀t h P l r.
                 ((l,r) = SPLITP P (STRING h t)) ∧ NULL l ⇒
                 R (P,TL r) (P,STRING h t)) ∧
              ∀t h P l r.
                ((l,r) = SPLITP P (STRING h t)) ∧ ¬NULL l ∧ ¬NULL r ⇒
                R (P,TL r) (P,STRING h t))
           (λFIELDS_tupled a.
              case a of
                (P,"") =&gt; I [""]
              | (P,STRING h t) =&gt;
                  I
                    (let (l,r) = SPLITP P (STRING h t)
                     in
                       if NULL l then ""::FIELDS_tupled (P,TL r)
                       else if NULL r then [l]
                       else l::FIELDS_tupled (P,TL r)))

   [<a name="IMPLODE_def-val"><b>IMPLODE_def</b></a>]  Definition

      |- (IMPLODE "" = "") ∧
         ∀c cs. IMPLODE (STRING c cs) = STRING c (IMPLODE cs)

   [<a name="STR_def-val"><b>STR_def</b></a>]  Definition

      |- ∀c. STR c = STRING c ""

   [<a name="SUBSTRING_def-val"><b>SUBSTRING_def</b></a>]  Definition

      |- ∀s i n. SUBSTRING (s,i,n) = SEG n i s

   [<a name="SUB_def-val"><b>SUB_def</b></a>]  Definition

      |- ∀s n. SUB (s,n) = EL n s

   [<a name="TOKENS_curried_def-val"><b>TOKENS_curried_def</b></a>]  Definition

      |- ∀x x1. TOKENS x x1 = TOKENS_tupled (x,x1)

   [<a name="TOKENS_tupled_primitive_def-val"><b>TOKENS_tupled_primitive_def</b></a>]  Definition

      |- TOKENS_tupled =
         WFREC
           (@R.
              WF R ∧
              (∀t h P l r.
                 ((l,r) = SPLITP P (STRING h t)) ∧ NULL l ⇒
                 R (P,TL r) (P,STRING h t)) ∧
              ∀t h P l r.
                ((l,r) = SPLITP P (STRING h t)) ∧ ¬NULL l ⇒
                R (P,r) (P,STRING h t))
           (λTOKENS_tupled a.
              case a of
                (P,"") =&gt; I []
              | (P,STRING h t) =&gt;
                  I
                    (let (l,r) = SPLITP P (STRING h t)
                     in
                       if NULL l then TOKENS_tupled (P,TL r)
                       else l::TOKENS_tupled (P,r)))

   [<a name="TRANSLATE_def-val"><b>TRANSLATE_def</b></a>]  Definition

      |- ∀f s. TRANSLATE f s = CONCAT (MAP f s)

   [<a name="char_BIJ-val"><b>char_BIJ</b></a>]  Definition

      |- (∀a. CHR (ORD a) = a) ∧ ∀r. (λn. n &lt; 256) r ⇔ (ORD (CHR r) = r)

   [<a name="char_TY_DEF-val"><b>char_TY_DEF</b></a>]  Definition

      |- ∃rep. TYPE_DEFINITION (λn. n &lt; 256) rep

   [<a name="char_ge_def-val"><b>char_ge_def</b></a>]  Definition

      |- ∀a b. a ≥ b ⇔ ORD a ≥ ORD b

   [<a name="char_gt_def-val"><b>char_gt_def</b></a>]  Definition

      |- ∀a b. a &gt; b ⇔ ORD a &gt; ORD b

   [<a name="char_le_def-val"><b>char_le_def</b></a>]  Definition

      |- ∀a b. a ≤ b ⇔ ORD a ≤ ORD b

   [<a name="char_lt_def-val"><b>char_lt_def</b></a>]  Definition

      |- ∀a b. a &lt; b ⇔ ORD a &lt; ORD b

   [<a name="char_size_def-val"><b>char_size_def</b></a>]  Definition

      |- ∀c. char_size c = 0

   [<a name="isAlphaNum_def-val"><b>isAlphaNum_def</b></a>]  Definition

      |- ∀c. isAlphaNum c ⇔ isAlpha c ∨ isDigit c

   [<a name="isAlpha_def-val"><b>isAlpha_def</b></a>]  Definition

      |- ∀c. isAlpha c ⇔ isLower c ∨ isUpper c

   [<a name="isAscii_def-val"><b>isAscii_def</b></a>]  Definition

      |- ∀c. isAscii c ⇔ ORD c ≤ 127

   [<a name="isCntrl_def-val"><b>isCntrl_def</b></a>]  Definition

      |- ∀c. isCntrl c ⇔ ORD c &lt; 32 ∨ 127 ≤ ORD c

   [<a name="isDigit_def-val"><b>isDigit_def</b></a>]  Definition

      |- ∀c. isDigit c ⇔ 48 ≤ ORD c ∧ ORD c ≤ 57

   [<a name="isGraph_def-val"><b>isGraph_def</b></a>]  Definition

      |- ∀c. isGraph c ⇔ isPrint c ∧ ¬isSpace c

   [<a name="isHexDigit_def-val"><b>isHexDigit_def</b></a>]  Definition

      |- ∀c.
           isHexDigit c ⇔
           48 ≤ ORD c ∧ ORD c ≤ 57 ∨ 97 ≤ ORD c ∧ ORD c ≤ 102 ∨
           65 ≤ ORD c ∧ ORD c ≤ 70

   [<a name="isLower_def-val"><b>isLower_def</b></a>]  Definition

      |- ∀c. isLower c ⇔ 97 ≤ ORD c ∧ ORD c ≤ 122

   [<a name="isPrint_def-val"><b>isPrint_def</b></a>]  Definition

      |- ∀c. isPrint c ⇔ 32 ≤ ORD c ∧ ORD c &lt; 127

   [<a name="isPunct_def-val"><b>isPunct_def</b></a>]  Definition

      |- ∀c. isPunct c ⇔ isGraph c ∧ ¬isAlphaNum c

   [<a name="isSpace_def-val"><b>isSpace_def</b></a>]  Definition

      |- ∀c. isSpace c ⇔ (ORD c = 32) ∨ 9 ≤ ORD c ∧ ORD c ≤ 13

   [<a name="isUpper_def-val"><b>isUpper_def</b></a>]  Definition

      |- ∀c. isUpper c ⇔ 65 ≤ ORD c ∧ ORD c ≤ 90

   [<a name="string_ge_def-val"><b>string_ge_def</b></a>]  Definition

      |- ∀s1 s2. s1 ≥ s2 ⇔ s2 ≤ s1

   [<a name="string_gt_def-val"><b>string_gt_def</b></a>]  Definition

      |- ∀s1 s2. s1 &gt; s2 ⇔ s2 &lt; s1

   [<a name="string_le_def-val"><b>string_le_def</b></a>]  Definition

      |- ∀s1 s2. s1 ≤ s2 ⇔ (s1 = s2) ∨ s1 &lt; s2

   [<a name="string_lt_curried_def-val"><b>string_lt_curried_def</b></a>]  Definition

      |- ∀x x1. x &lt; x1 ⇔ string_lt_tupled (x,x1)

   [<a name="string_lt_tupled_primitive_def-val"><b>string_lt_tupled_primitive_def</b></a>]  Definition

      |- string_lt_tupled =
         WFREC
           (@R. WF R ∧ ∀c2 c1 s2 s1. R (s1,s2) (STRING c1 s1,STRING c2 s2))
           (λstring_lt_tupled a.
              case a of
                (s,"") =&gt; I F
              | ("",STRING c s') =&gt; I T
              | (STRING c1 s1,STRING c s') =&gt;
                  I (c1 &lt; c ∨ (c1 = c) ∧ string_lt_tupled (s1,s')))

   [<a name="toLower_def-val"><b>toLower_def</b></a>]  Definition

      |- ∀c. toLower c = if isUpper c then CHR (ORD c + 32) else c

   [<a name="toUpper_def-val"><b>toUpper_def</b></a>]  Definition

      |- ∀c. toUpper c = if isLower c then CHR (ORD c − 32) else c

   [<a name="CHAR_EQ_THM-val"><b>CHAR_EQ_THM</b></a>]  Theorem

      |- ∀c1 c2. (c1 = c2) ⇔ (ORD c1 = ORD c2)

   [<a name="CHAR_INDUCT_THM-val"><b>CHAR_INDUCT_THM</b></a>]  Theorem

      |- ∀P. (∀n. n &lt; 256 ⇒ P (CHR n)) ⇒ ∀c. P c

   [<a name="CHR_11-val"><b>CHR_11</b></a>]  Theorem

      |- ∀r r'. r &lt; 256 ⇒ r' &lt; 256 ⇒ ((CHR r = CHR r') ⇔ (r = r'))

   [<a name="CHR_ONTO-val"><b>CHR_ONTO</b></a>]  Theorem

      |- ∀a. ∃r. (a = CHR r) ∧ r &lt; 256

   [<a name="CHR_ORD-val"><b>CHR_ORD</b></a>]  Theorem

      |- ∀a. CHR (ORD a) = a

   [<a name="DEST_STRING_LEMS-val"><b>DEST_STRING_LEMS</b></a>]  Theorem

      |- ∀s.
           ((DEST_STRING s = NONE) ⇔ (s = "")) ∧
           ((DEST_STRING s = SOME (c,t)) ⇔ (s = STRING c t))

   [<a name="EXPLODE_11-val"><b>EXPLODE_11</b></a>]  Theorem

      |- (EXPLODE s1 = EXPLODE s2) ⇔ (s1 = s2)

   [<a name="EXPLODE_DEST_STRING-val"><b>EXPLODE_DEST_STRING</b></a>]  Theorem

      |- ∀s.
           EXPLODE s =
           case DEST_STRING s of
             NONE =&gt; ""
           | SOME (c,t) =&gt; STRING c (EXPLODE t)

   [<a name="EXPLODE_EQNS-val"><b>EXPLODE_EQNS</b></a>]  Theorem

      |- (EXPLODE "" = "") ∧
         ∀c s. EXPLODE (STRING c s) = STRING c (EXPLODE s)

   [<a name="EXPLODE_EQ_NIL-val"><b>EXPLODE_EQ_NIL</b></a>]  Theorem

      |- ((EXPLODE s = "") ⇔ (s = "")) ∧ (("" = EXPLODE s) ⇔ (s = ""))

   [<a name="EXPLODE_EQ_THM-val"><b>EXPLODE_EQ_THM</b></a>]  Theorem

      |- ∀s h t.
           ((STRING h t = EXPLODE s) ⇔ (s = STRING h (IMPLODE t))) ∧
           ((EXPLODE s = STRING h t) ⇔ (s = STRING h (IMPLODE t)))

   [<a name="EXPLODE_IMPLODE-val"><b>EXPLODE_IMPLODE</b></a>]  Theorem

      |- EXPLODE (IMPLODE cs) = cs

   [<a name="EXPLODE_ONTO-val"><b>EXPLODE_ONTO</b></a>]  Theorem

      |- ∀cs. ∃s. cs = EXPLODE s

   [<a name="EXTRACT_def-val"><b>EXTRACT_def</b></a>]  Theorem

      |- (EXTRACT (s,i,NONE) = SUBSTRING (s,i,STRLEN s − i)) ∧
         (EXTRACT (s,i,SOME n) = SUBSTRING (s,i,n))

   [<a name="EXTRACT_ind-val"><b>EXTRACT_ind</b></a>]  Theorem

      |- ∀P.
           (∀s i. P (s,i,NONE)) ∧ (∀s i n. P (s,i,SOME n)) ⇒
           ∀v v1 v2. P (v,v1,v2)

   [<a name="FIELDS_def-val"><b>FIELDS_def</b></a>]  Theorem

      |- (∀P. FIELDS P "" = [""]) ∧
         ∀t h P.
           FIELDS P (STRING h t) =
           (let (l,r) = SPLITP P (STRING h t)
            in
              if NULL l then ""::FIELDS P (TL r)
              else if NULL r then [l]
              else l::FIELDS P (TL r))

   [<a name="FIELDS_ind-val"><b>FIELDS_ind</b></a>]  Theorem

      |- ∀P'.
           (∀P. P' P "") ∧
           (∀P h t.
              (∀l r.
                 ((l,r) = SPLITP P (STRING h t)) ∧ NULL l ⇒ P' P (TL r)) ∧
              (∀l r.
                 ((l,r) = SPLITP P (STRING h t)) ∧ ¬NULL l ∧ ¬NULL r ⇒
                 P' P (TL r)) ⇒
              P' P (STRING h t)) ⇒
           ∀v v1. P' v v1

   [<a name="IMPLODE_11-val"><b>IMPLODE_11</b></a>]  Theorem

      |- (IMPLODE cs1 = IMPLODE cs2) ⇔ (cs1 = cs2)

   [<a name="IMPLODE_EQNS-val"><b>IMPLODE_EQNS</b></a>]  Theorem

      |- (IMPLODE "" = "") ∧
         ∀c cs. IMPLODE (STRING c cs) = STRING c (IMPLODE cs)

   [<a name="IMPLODE_EQ_EMPTYSTRING-val"><b>IMPLODE_EQ_EMPTYSTRING</b></a>]  Theorem

      |- ((IMPLODE l = "") ⇔ (l = "")) ∧ (("" = IMPLODE l) ⇔ (l = ""))

   [<a name="IMPLODE_EQ_THM-val"><b>IMPLODE_EQ_THM</b></a>]  Theorem

      |- ∀c s l.
           ((STRING c s = IMPLODE l) ⇔ (l = STRING c (EXPLODE s))) ∧
           ((IMPLODE l = STRING c s) ⇔ (l = STRING c (EXPLODE s)))

   [<a name="IMPLODE_EXPLODE-val"><b>IMPLODE_EXPLODE</b></a>]  Theorem

      |- IMPLODE (EXPLODE s) = s

   [<a name="IMPLODE_EXPLODE_I-val"><b>IMPLODE_EXPLODE_I</b></a>]  Theorem

      |- (EXPLODE s = s) ∧ (IMPLODE s = s)

   [<a name="IMPLODE_ONTO-val"><b>IMPLODE_ONTO</b></a>]  Theorem

      |- ∀s. ∃cs. s = IMPLODE cs

   [<a name="IMPLODE_STRING-val"><b>IMPLODE_STRING</b></a>]  Theorem

      |- ∀clist. IMPLODE clist = FOLDR STRING "" clist

   [<a name="ORD_11-val"><b>ORD_11</b></a>]  Theorem

      |- ∀a a'. (ORD a = ORD a') ⇔ (a = a')

   [<a name="ORD_BOUND-val"><b>ORD_BOUND</b></a>]  Theorem

      |- ∀c. ORD c &lt; 256

   [<a name="ORD_CHR-val"><b>ORD_CHR</b></a>]  Theorem

      |- ∀r. r &lt; 256 ⇔ (ORD (CHR r) = r)

   [<a name="ORD_CHR_COMPUTE-val"><b>ORD_CHR_COMPUTE</b></a>]  Theorem

      |- ∀n. ORD (CHR n) = if n &lt; 256 then n else FAIL ORD &gt; 255 (CHR n)

   [<a name="ORD_CHR_RWT-val"><b>ORD_CHR_RWT</b></a>]  Theorem

      |- ∀r. r &lt; 256 ⇒ (ORD (CHR r) = r)

   [<a name="ORD_ONTO-val"><b>ORD_ONTO</b></a>]  Theorem

      |- ∀r. r &lt; 256 ⇔ ∃a. r = ORD a

   [<a name="STRCAT-val"><b>STRCAT</b></a>]  Theorem

      |- STRCAT s1 s2 = STRCAT s1 s2

   [<a name="STRCAT_11-val"><b>STRCAT_11</b></a>]  Theorem

      |- (∀l1 l2 l3. (STRCAT l1 l2 = STRCAT l1 l3) ⇔ (l2 = l3)) ∧
         ∀l1 l2 l3. (STRCAT l2 l1 = STRCAT l3 l1) ⇔ (l2 = l3)

   [<a name="STRCAT_ACYCLIC-val"><b>STRCAT_ACYCLIC</b></a>]  Theorem

      |- ∀s s1.
           ((s = STRCAT s s1) ⇔ (s1 = "")) ∧
           ((s = STRCAT s1 s) ⇔ (s1 = ""))

   [<a name="STRCAT_ASSOC-val"><b>STRCAT_ASSOC</b></a>]  Theorem

      |- ∀l1 l2 l3. STRCAT l1 (STRCAT l2 l3) = STRCAT (STRCAT l1 l2) l3

   [<a name="STRCAT_EQNS-val"><b>STRCAT_EQNS</b></a>]  Theorem

      |- (STRCAT "" s = s) ∧ (STRCAT s "" = s) ∧
         (STRCAT (STRING c s1) s2 = STRING c (STRCAT s1 s2))

   [<a name="STRCAT_EQ_EMPTY-val"><b>STRCAT_EQ_EMPTY</b></a>]  Theorem

      |- ∀l1 l2. (STRCAT l1 l2 = "") ⇔ (l1 = "") ∧ (l2 = "")

   [<a name="STRCAT_EXPLODE-val"><b>STRCAT_EXPLODE</b></a>]  Theorem

      |- ∀s1 s2. STRCAT s1 s2 = FOLDR STRING s2 (EXPLODE s1)

   [<a name="STRCAT_def-val"><b>STRCAT_def</b></a>]  Theorem

      |- (∀l. STRCAT "" l = l) ∧
         ∀l1 l2 h. STRCAT (STRING h l1) l2 = STRING h (STRCAT l1 l2)

   [<a name="STRING_ACYCLIC-val"><b>STRING_ACYCLIC</b></a>]  Theorem

      |- ∀s c. STRING c s ≠ s ∧ s ≠ STRING c s

   [<a name="STRLEN_CAT-val"><b>STRLEN_CAT</b></a>]  Theorem

      |- ∀l1 l2. STRLEN (STRCAT l1 l2) = STRLEN l1 + STRLEN l2

   [<a name="STRLEN_DEF-val"><b>STRLEN_DEF</b></a>]  Theorem

      |- (STRLEN "" = 0) ∧ ∀h t. STRLEN (STRING h t) = SUC (STRLEN t)

   [<a name="STRLEN_EQ_0-val"><b>STRLEN_EQ_0</b></a>]  Theorem

      |- ∀l. (STRLEN l = 0) ⇔ (l = "")

   [<a name="STRLEN_EXPLODE_THM-val"><b>STRLEN_EXPLODE_THM</b></a>]  Theorem

      |- STRLEN s = STRLEN (EXPLODE s)

   [<a name="STRLEN_THM-val"><b>STRLEN_THM</b></a>]  Theorem

      |- (STRLEN "" = 0) ∧ ∀h t. STRLEN (STRING h t) = SUC (STRLEN t)

   [<a name="TOKENS_def-val"><b>TOKENS_def</b></a>]  Theorem

      |- (∀P. TOKENS P "" = []) ∧
         ∀t h P.
           TOKENS P (STRING h t) =
           (let (l,r) = SPLITP P (STRING h t)
            in
              if NULL l then TOKENS P (TL r) else l::TOKENS P r)

   [<a name="TOKENS_ind-val"><b>TOKENS_ind</b></a>]  Theorem

      |- ∀P'.
           (∀P. P' P "") ∧
           (∀P h t.
              (∀l r.
                 ((l,r) = SPLITP P (STRING h t)) ∧ NULL l ⇒ P' P (TL r)) ∧
              (∀l r. ((l,r) = SPLITP P (STRING h t)) ∧ ¬NULL l ⇒ P' P r) ⇒
              P' P (STRING h t)) ⇒
           ∀v v1. P' v v1

   [<a name="char_nchotomy-val"><b>char_nchotomy</b></a>]  Theorem

      |- ∀c. ∃n. c = CHR n

   [<a name="isPREFIX_DEF-val"><b>isPREFIX_DEF</b></a>]  Theorem

      |- ∀s1 s2.
           s1 ≼ s2 ⇔
           case (DEST_STRING s1,DEST_STRING s2) of
             (NONE,v1) =&gt; T
           | (SOME v2,NONE) =&gt; F
           | (SOME (c1,t1),SOME (c2,t2)) =&gt; (c1 = c2) ∧ t1 ≼ t2

   [<a name="isPREFIX_IND-val"><b>isPREFIX_IND</b></a>]  Theorem

      |- ∀P.
           (∀s1 s2.
              (∀c t1 t2.
                 (DEST_STRING s1 = SOME (c,t1)) ∧
                 (DEST_STRING s2 = SOME (c,t2)) ⇒
                 P t1 t2) ⇒
              P s1 s2) ⇒
           ∀v v1. P v v1

   [<a name="isPREFIX_STRCAT-val"><b>isPREFIX_STRCAT</b></a>]  Theorem

      |- ∀s1 s2. s1 ≼ s2 ⇔ ∃s3. s2 = STRCAT s1 s3

   [<a name="ranged_char_nchotomy-val"><b>ranged_char_nchotomy</b></a>]  Theorem

      |- ∀c. ∃n. (c = CHR n) ∧ n &lt; 256

   [<a name="string_lt_antisym-val"><b>string_lt_antisym</b></a>]  Theorem

      |- ∀s t. ¬(s &lt; t ∧ t &lt; s)

   [<a name="string_lt_cases-val"><b>string_lt_cases</b></a>]  Theorem

      |- ∀s t. (s = t) ∨ s &lt; t ∨ t &lt; s

   [<a name="string_lt_def-val"><b>string_lt_def</b></a>]  Theorem

      |- (∀s. s &lt; "" ⇔ F) ∧ (∀s c. "" &lt; STRING c s ⇔ T) ∧
         ∀s2 s1 c2 c1.
           STRING c1 s1 &lt; STRING c2 s2 ⇔ c1 &lt; c2 ∨ (c1 = c2) ∧ s1 &lt; s2

   [<a name="string_lt_ind-val"><b>string_lt_ind</b></a>]  Theorem

      |- ∀P.
           (∀s. P s "") ∧ (∀c s. P "" (STRING c s)) ∧
           (∀c1 s1 c2 s2. P s1 s2 ⇒ P (STRING c1 s1) (STRING c2 s2)) ⇒
           ∀v v1. P v v1

   [<a name="string_lt_nonrefl-val"><b>string_lt_nonrefl</b></a>]  Theorem

      |- ∀s. ¬(s &lt; s)

   [<a name="string_lt_trans-val"><b>string_lt_trans</b></a>]  Theorem

      |- ∀s1 s2 s3. s1 &lt; s2 ∧ s2 &lt; s3 ⇒ s1 &lt; s3


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/string/stringScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-9</a></em></p></body></html>
