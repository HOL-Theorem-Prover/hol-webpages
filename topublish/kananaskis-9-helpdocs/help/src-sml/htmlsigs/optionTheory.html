<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure optionTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure optionTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/option/optionScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature optionTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#IS_NONE_DEF-val">IS_NONE_DEF</a> : thm
<a name="line7"></a>    val <a href="#IS_SOME_DEF-val">IS_SOME_DEF</a> : thm
<a name="line8"></a>    val <a href="#NONE_DEF-val">NONE_DEF</a> : thm
<a name="line9"></a>    val <a href="#OPTION_BIND_def-val">OPTION_BIND_def</a> : thm
<a name="line10"></a>    val <a href="#OPTION_CHOICE_def-val">OPTION_CHOICE_def</a> : thm
<a name="line11"></a>    val <a href="#OPTION_GUARD_def-val">OPTION_GUARD_def</a> : thm
<a name="line12"></a>    val <a href="#OPTION_IGNORE_BIND_def-val">OPTION_IGNORE_BIND_def</a> : thm
<a name="line13"></a>    val <a href="#OPTION_JOIN_DEF-val">OPTION_JOIN_DEF</a> : thm
<a name="line14"></a>    val <a href="#OPTION_MAP2_DEF-val">OPTION_MAP2_DEF</a> : thm
<a name="line15"></a>    val <a href="#OPTION_MAP_DEF-val">OPTION_MAP_DEF</a> : thm
<a name="line16"></a>    val <a href="#OPTREL_def-val">OPTREL_def</a> : thm
<a name="line17"></a>    val <a href="#SOME_DEF-val">SOME_DEF</a> : thm
<a name="line18"></a>    val <a href="#THE_DEF-val">THE_DEF</a> : thm
<a name="line19"></a>    val <a href="#option_REP_ABS_DEF-val">option_REP_ABS_DEF</a> : thm
<a name="line20"></a>    val <a href="#option_TY_DEF-val">option_TY_DEF</a> : thm
<a name="line21"></a>    val <a href="#option_case_def-val">option_case_def</a> : thm
<a name="line22"></a>    val <a href="#some_def-val">some_def</a> : thm
<a name="line23"></a>
<a name="line24"></a>  (*  Theorems  *)
<a name="line25"></a>    val <a href="#EXISTS_OPTION-val">EXISTS_OPTION</a> : thm
<a name="line26"></a>    val <a href="#FORALL_OPTION-val">FORALL_OPTION</a> : thm
<a name="line27"></a>    val <a href="#IF_EQUALS_OPTION-val">IF_EQUALS_OPTION</a> : thm
<a name="line28"></a>    val <a href="#IF_NONE_EQUALS_OPTION-val">IF_NONE_EQUALS_OPTION</a> : thm
<a name="line29"></a>    val <a href="#IS_NONE_EQ_NONE-val">IS_NONE_EQ_NONE</a> : thm
<a name="line30"></a>    val <a href="#NOT_IS_SOME_EQ_NONE-val">NOT_IS_SOME_EQ_NONE</a> : thm
<a name="line31"></a>    val <a href="#NOT_NONE_SOME-val">NOT_NONE_SOME</a> : thm
<a name="line32"></a>    val <a href="#NOT_SOME_NONE-val">NOT_SOME_NONE</a> : thm
<a name="line33"></a>    val <a href="#OPTION_BIND_EQUALS_OPTION-val">OPTION_BIND_EQUALS_OPTION</a> : thm
<a name="line34"></a>    val <a href="#OPTION_BIND_cong-val">OPTION_BIND_cong</a> : thm
<a name="line35"></a>    val <a href="#OPTION_CHOICE_EQ_NONE-val">OPTION_CHOICE_EQ_NONE</a> : thm
<a name="line36"></a>    val <a href="#OPTION_GUARD_COND-val">OPTION_GUARD_COND</a> : thm
<a name="line37"></a>    val <a href="#OPTION_GUARD_EQ_THM-val">OPTION_GUARD_EQ_THM</a> : thm
<a name="line38"></a>    val <a href="#OPTION_JOIN_EQ_SOME-val">OPTION_JOIN_EQ_SOME</a> : thm
<a name="line39"></a>    val <a href="#OPTION_MAP2_NONE-val">OPTION_MAP2_NONE</a> : thm
<a name="line40"></a>    val <a href="#OPTION_MAP2_SOME-val">OPTION_MAP2_SOME</a> : thm
<a name="line41"></a>    val <a href="#OPTION_MAP2_THM-val">OPTION_MAP2_THM</a> : thm
<a name="line42"></a>    val <a href="#OPTION_MAP2_cong-val">OPTION_MAP2_cong</a> : thm
<a name="line43"></a>    val <a href="#OPTION_MAP_COMPOSE-val">OPTION_MAP_COMPOSE</a> : thm
<a name="line44"></a>    val <a href="#OPTION_MAP_CONG-val">OPTION_MAP_CONG</a> : thm
<a name="line45"></a>    val <a href="#OPTION_MAP_EQ_NONE-val">OPTION_MAP_EQ_NONE</a> : thm
<a name="line46"></a>    val <a href="#OPTION_MAP_EQ_NONE_both_ways-val">OPTION_MAP_EQ_NONE_both_ways</a> : thm
<a name="line47"></a>    val <a href="#OPTION_MAP_EQ_SOME-val">OPTION_MAP_EQ_SOME</a> : thm
<a name="line48"></a>    val <a href="#OPTREL_MONO-val">OPTREL_MONO</a> : thm
<a name="line49"></a>    val <a href="#OPTREL_refl-val">OPTREL_refl</a> : thm
<a name="line50"></a>    val <a href="#SOME_11-val">SOME_11</a> : thm
<a name="line51"></a>    val <a href="#option_Axiom-val">option_Axiom</a> : thm
<a name="line52"></a>    val <a href="#option_CLAUSES-val">option_CLAUSES</a> : thm
<a name="line53"></a>    val <a href="#option_case_ID-val">option_case_ID</a> : thm
<a name="line54"></a>    val <a href="#option_case_SOME_ID-val">option_case_SOME_ID</a> : thm
<a name="line55"></a>    val <a href="#option_case_compute-val">option_case_compute</a> : thm
<a name="line56"></a>    val <a href="#option_case_cong-val">option_case_cong</a> : thm
<a name="line57"></a>    val <a href="#option_induction-val">option_induction</a> : thm
<a name="line58"></a>    val <a href="#option_nchotomy-val">option_nchotomy</a> : thm
<a name="line59"></a>    val <a href="#some_EQ-val">some_EQ</a> : thm
<a name="line60"></a>    val <a href="#some_F-val">some_F</a> : thm
<a name="line61"></a>    val <a href="#some_elim-val">some_elim</a> : thm
<a name="line62"></a>    val <a href="#some_intro-val">some_intro</a> : thm
<a name="line63"></a>
<a name="line64"></a>  val option_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line65"></a>
<a name="line66"></a>  val option_Induct : thm
<a name="line67"></a>  val option_CASES : thm
<a name="line68"></a>
<a name="line69"></a>(*
   [normalForms] Parent theory of "option"

   [one] Parent theory of "option"

   [sum] Parent theory of "option"

   [<a name="IS_NONE_DEF-val"><b>IS_NONE_DEF</b></a>]  Definition

      |- (∀x. IS_NONE (SOME x) ⇔ F) ∧ (IS_NONE NONE ⇔ T)

   [<a name="IS_SOME_DEF-val"><b>IS_SOME_DEF</b></a>]  Definition

      |- (∀x. IS_SOME (SOME x) ⇔ T) ∧ (IS_SOME NONE ⇔ F)

   [<a name="NONE_DEF-val"><b>NONE_DEF</b></a>]  Definition

      |- NONE = option_ABS (INR ())

   [<a name="OPTION_BIND_def-val"><b>OPTION_BIND_def</b></a>]  Definition

      |- (∀f. OPTION_BIND NONE f = NONE) ∧
         ∀x f. OPTION_BIND (SOME x) f = f x

   [<a name="OPTION_CHOICE_def-val"><b>OPTION_CHOICE_def</b></a>]  Definition

      |- (∀m2. OPTION_CHOICE NONE m2 = m2) ∧
         ∀x m2. OPTION_CHOICE (SOME x) m2 = SOME x

   [<a name="OPTION_GUARD_def-val"><b>OPTION_GUARD_def</b></a>]  Definition

      |- (OPTION_GUARD T = SOME ()) ∧ (OPTION_GUARD F = NONE)

   [<a name="OPTION_IGNORE_BIND_def-val"><b>OPTION_IGNORE_BIND_def</b></a>]  Definition

      |- ∀m1 m2. OPTION_IGNORE_BIND m1 m2 = OPTION_BIND m1 (K m2)

   [<a name="OPTION_JOIN_DEF-val"><b>OPTION_JOIN_DEF</b></a>]  Definition

      |- (OPTION_JOIN NONE = NONE) ∧ ∀x. OPTION_JOIN (SOME x) = x

   [<a name="OPTION_MAP2_DEF-val"><b>OPTION_MAP2_DEF</b></a>]  Definition

      |- ∀f x y.
           OPTION_MAP2 f x y =
           if IS_SOME x ∧ IS_SOME y then SOME (f (THE x) (THE y)) else NONE

   [<a name="OPTION_MAP_DEF-val"><b>OPTION_MAP_DEF</b></a>]  Definition

      |- (∀f x. OPTION_MAP f (SOME x) = SOME (f x)) ∧
         ∀f. OPTION_MAP f NONE = NONE

   [<a name="OPTREL_def-val"><b>OPTREL_def</b></a>]  Definition

      |- ∀R x y.
           OPTREL R x y ⇔
           (x = NONE) ∧ (y = NONE) ∨
           ∃x0 y0. (x = SOME x0) ∧ (y = SOME y0) ∧ R x0 y0

   [<a name="SOME_DEF-val"><b>SOME_DEF</b></a>]  Definition

      |- ∀x. SOME x = option_ABS (INL x)

   [<a name="THE_DEF-val"><b>THE_DEF</b></a>]  Definition

      |- ∀x. THE (SOME x) = x

   [<a name="option_REP_ABS_DEF-val"><b>option_REP_ABS_DEF</b></a>]  Definition

      |- (∀a. option_ABS (option_REP a) = a) ∧
         ∀r. (λx. T) r ⇔ (option_REP (option_ABS r) = r)

   [<a name="option_TY_DEF-val"><b>option_TY_DEF</b></a>]  Definition

      |- ∃rep. TYPE_DEFINITION (λx. T) rep

   [<a name="option_case_def-val"><b>option_case_def</b></a>]  Definition

      |- (∀v f. option_CASE NONE v f = v) ∧
         ∀x v f. option_CASE (SOME x) v f = f x

   [<a name="some_def-val"><b>some_def</b></a>]  Definition

      |- ∀P. $some P = if ∃x. P x then SOME (@x. P x) else NONE

   [<a name="EXISTS_OPTION-val"><b>EXISTS_OPTION</b></a>]  Theorem

      |- (∃opt. P opt) ⇔ P NONE ∨ ∃x. P (SOME x)

   [<a name="FORALL_OPTION-val"><b>FORALL_OPTION</b></a>]  Theorem

      |- (∀opt. P opt) ⇔ P NONE ∧ ∀x. P (SOME x)

   [<a name="IF_EQUALS_OPTION-val"><b>IF_EQUALS_OPTION</b></a>]  Theorem

      |- (((if P then SOME x else NONE) = NONE) ⇔ ¬P) ∧
         (((if P then NONE else SOME x) = NONE) ⇔ P) ∧
         (((if P then SOME x else NONE) = SOME y) ⇔ P ∧ (x = y)) ∧
         (((if P then NONE else SOME x) = SOME y) ⇔ ¬P ∧ (x = y))

   [<a name="IF_NONE_EQUALS_OPTION-val"><b>IF_NONE_EQUALS_OPTION</b></a>]  Theorem

      |- (((if P then X else NONE) = NONE) ⇔ P ⇒ IS_NONE X) ∧
         (((if P then NONE else X) = NONE) ⇔ IS_SOME X ⇒ P) ∧
         (((if P then X else NONE) = SOME x) ⇔ P ∧ (X = SOME x)) ∧
         (((if P then NONE else X) = SOME x) ⇔ ¬P ∧ (X = SOME x))

   [<a name="IS_NONE_EQ_NONE-val"><b>IS_NONE_EQ_NONE</b></a>]  Theorem

      |- ∀x. IS_NONE x ⇔ (x = NONE)

   [<a name="NOT_IS_SOME_EQ_NONE-val"><b>NOT_IS_SOME_EQ_NONE</b></a>]  Theorem

      |- ∀x. ¬IS_SOME x ⇔ (x = NONE)

   [<a name="NOT_NONE_SOME-val"><b>NOT_NONE_SOME</b></a>]  Theorem

      |- ∀x. NONE ≠ SOME x

   [<a name="NOT_SOME_NONE-val"><b>NOT_SOME_NONE</b></a>]  Theorem

      |- ∀x. SOME x ≠ NONE

   [<a name="OPTION_BIND_EQUALS_OPTION-val"><b>OPTION_BIND_EQUALS_OPTION</b></a>]  Theorem

      |- ((OPTION_BIND p f = NONE) ⇔
          (p = NONE) ∨ ∃x. (p = SOME x) ∧ (f x = NONE)) ∧
         ((OPTION_BIND p f = SOME y) ⇔ ∃x. (p = SOME x) ∧ (f x = SOME y))

   [<a name="OPTION_BIND_cong-val"><b>OPTION_BIND_cong</b></a>]  Theorem

      |- ∀o1 o2 f1 f2.
           (o1 = o2) ∧ (∀x. (o2 = SOME x) ⇒ (f1 x = f2 x)) ⇒
           (OPTION_BIND o1 f1 = OPTION_BIND o2 f2)

   [<a name="OPTION_CHOICE_EQ_NONE-val"><b>OPTION_CHOICE_EQ_NONE</b></a>]  Theorem

      |- (OPTION_CHOICE m1 m2 = NONE) ⇔ (m1 = NONE) ∧ (m2 = NONE)

   [<a name="OPTION_GUARD_COND-val"><b>OPTION_GUARD_COND</b></a>]  Theorem

      |- OPTION_GUARD b = if b then SOME () else NONE

   [<a name="OPTION_GUARD_EQ_THM-val"><b>OPTION_GUARD_EQ_THM</b></a>]  Theorem

      |- ((OPTION_GUARD b = SOME ()) ⇔ b) ∧ ((OPTION_GUARD b = NONE) ⇔ ¬b)

   [<a name="OPTION_JOIN_EQ_SOME-val"><b>OPTION_JOIN_EQ_SOME</b></a>]  Theorem

      |- ∀x y. (OPTION_JOIN x = SOME y) ⇔ (x = SOME (SOME y))

   [<a name="OPTION_MAP2_NONE-val"><b>OPTION_MAP2_NONE</b></a>]  Theorem

      |- (OPTION_MAP2 f o1 o2 = NONE) ⇔ (o1 = NONE) ∨ (o2 = NONE)

   [<a name="OPTION_MAP2_SOME-val"><b>OPTION_MAP2_SOME</b></a>]  Theorem

      |- (OPTION_MAP2 f o1 o2 = SOME v) ⇔
         ∃x1 x2. (o1 = SOME x1) ∧ (o2 = SOME x2) ∧ (v = f x1 x2)

   [<a name="OPTION_MAP2_THM-val"><b>OPTION_MAP2_THM</b></a>]  Theorem

      |- (OPTION_MAP2 f (SOME x) (SOME y) = SOME (f x y)) ∧
         (OPTION_MAP2 f (SOME x) NONE = NONE) ∧
         (OPTION_MAP2 f NONE (SOME y) = NONE) ∧
         (OPTION_MAP2 f NONE NONE = NONE)

   [<a name="OPTION_MAP2_cong-val"><b>OPTION_MAP2_cong</b></a>]  Theorem

      |- ∀x1 x2 y1 y2 f1 f2.
           (x1 = x2) ∧ (y1 = y2) ∧
           (∀x y. (x2 = SOME x) ∧ (y2 = SOME y) ⇒ (f1 x y = f2 x y)) ⇒
           (OPTION_MAP2 f1 x1 y1 = OPTION_MAP2 f2 x2 y2)

   [<a name="OPTION_MAP_COMPOSE-val"><b>OPTION_MAP_COMPOSE</b></a>]  Theorem

      |- OPTION_MAP f (OPTION_MAP g x) = OPTION_MAP (f o g) x

   [<a name="OPTION_MAP_CONG-val"><b>OPTION_MAP_CONG</b></a>]  Theorem

      |- ∀opt1 opt2 f1 f2.
           (opt1 = opt2) ∧ (∀x. (opt2 = SOME x) ⇒ (f1 x = f2 x)) ⇒
           (OPTION_MAP f1 opt1 = OPTION_MAP f2 opt2)

   [<a name="OPTION_MAP_EQ_NONE-val"><b>OPTION_MAP_EQ_NONE</b></a>]  Theorem

      |- ∀f x. (OPTION_MAP f x = NONE) ⇔ (x = NONE)

   [<a name="OPTION_MAP_EQ_NONE_both_ways-val"><b>OPTION_MAP_EQ_NONE_both_ways</b></a>]  Theorem

      |- ((OPTION_MAP f x = NONE) ⇔ (x = NONE)) ∧
         ((NONE = OPTION_MAP f x) ⇔ (x = NONE))

   [<a name="OPTION_MAP_EQ_SOME-val"><b>OPTION_MAP_EQ_SOME</b></a>]  Theorem

      |- ∀f x y. (OPTION_MAP f x = SOME y) ⇔ ∃z. (x = SOME z) ∧ (y = f z)

   [<a name="OPTREL_MONO-val"><b>OPTREL_MONO</b></a>]  Theorem

      |- (∀x y. P x y ⇒ Q x y) ⇒ OPTREL P x y ⇒ OPTREL Q x y

   [<a name="OPTREL_refl-val"><b>OPTREL_refl</b></a>]  Theorem

      |- (∀x. R x x) ⇒ ∀x. OPTREL R x x

   [<a name="SOME_11-val"><b>SOME_11</b></a>]  Theorem

      |- ∀x y. (SOME x = SOME y) ⇔ (x = y)

   [<a name="option_Axiom-val"><b>option_Axiom</b></a>]  Theorem

      |- ∀e f. ∃fn. (fn NONE = e) ∧ ∀x. fn (SOME x) = f x

   [<a name="option_CLAUSES-val"><b>option_CLAUSES</b></a>]  Theorem

      |- (∀x y. (SOME x = SOME y) ⇔ (x = y)) ∧ (∀x. THE (SOME x) = x) ∧
         (∀x. NONE ≠ SOME x) ∧ (∀x. SOME x ≠ NONE) ∧
         (∀x. IS_SOME (SOME x) ⇔ T) ∧ (IS_SOME NONE ⇔ F) ∧
         (∀x. IS_NONE x ⇔ (x = NONE)) ∧ (∀x. ¬IS_SOME x ⇔ (x = NONE)) ∧
         (∀x. IS_SOME x ⇒ (SOME (THE x) = x)) ∧
         (∀x. option_CASE x NONE SOME = x) ∧
         (∀x. option_CASE x x SOME = x) ∧
         (∀x. IS_NONE x ⇒ (option_CASE x e f = e)) ∧
         (∀x. IS_SOME x ⇒ (option_CASE x e f = f (THE x))) ∧
         (∀x. IS_SOME x ⇒ (option_CASE x e SOME = x)) ∧
         (∀v f. option_CASE NONE v f = v) ∧
         (∀x v f. option_CASE (SOME x) v f = f x) ∧
         (∀f x. OPTION_MAP f (SOME x) = SOME (f x)) ∧
         (∀f. OPTION_MAP f NONE = NONE) ∧ (OPTION_JOIN NONE = NONE) ∧
         ∀x. OPTION_JOIN (SOME x) = x

   [<a name="option_case_ID-val"><b>option_case_ID</b></a>]  Theorem

      |- ∀x. option_CASE x NONE SOME = x

   [<a name="option_case_SOME_ID-val"><b>option_case_SOME_ID</b></a>]  Theorem

      |- ∀x. option_CASE x x SOME = x

   [<a name="option_case_compute-val"><b>option_case_compute</b></a>]  Theorem

      |- option_CASE x e f = if IS_SOME x then f (THE x) else e

   [<a name="option_case_cong-val"><b>option_case_cong</b></a>]  Theorem

      |- ∀M M' v f.
           (M = M') ∧ ((M' = NONE) ⇒ (v = v')) ∧
           (∀x. (M' = SOME x) ⇒ (f x = f' x)) ⇒
           (option_CASE M v f = option_CASE M' v' f')

   [<a name="option_induction-val"><b>option_induction</b></a>]  Theorem

      |- ∀P. P NONE ∧ (∀a. P (SOME a)) ⇒ ∀x. P x

   [<a name="option_nchotomy-val"><b>option_nchotomy</b></a>]  Theorem

      |- ∀opt. (opt = NONE) ∨ ∃x. opt = SOME x

   [<a name="some_EQ-val"><b>some_EQ</b></a>]  Theorem

      |- ((some x. x = y) = SOME y) ∧ ((some x. y = x) = SOME y)

   [<a name="some_F-val"><b>some_F</b></a>]  Theorem

      |- (some x. F) = NONE

   [<a name="some_elim-val"><b>some_elim</b></a>]  Theorem

      |- Q ($some P) ⇒ (∃x. P x ∧ Q (SOME x)) ∨ (∀x. ¬P x) ∧ Q NONE

   [<a name="some_intro-val"><b>some_intro</b></a>]  Theorem

      |- (∀x. P x ⇒ Q (SOME x)) ∧ ((∀x. ¬P x) ⇒ Q NONE) ⇒ Q ($some P)


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/option/optionScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-9</a></em></p></body></html>
