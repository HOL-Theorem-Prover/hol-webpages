<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure ind_typeTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure ind_typeTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/datatype/ind_typeScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature ind_typeTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#BOTTOM-val">BOTTOM</a> : thm
<a name="line7"></a>    val <a href="#CONSTR-val">CONSTR</a> : thm
<a name="line8"></a>    val <a href="#FCONS-val">FCONS</a> : thm
<a name="line9"></a>    val <a href="#FNIL-val">FNIL</a> : thm
<a name="line10"></a>    val <a href="#INJA-val">INJA</a> : thm
<a name="line11"></a>    val <a href="#INJF-val">INJF</a> : thm
<a name="line12"></a>    val <a href="#INJN-val">INJN</a> : thm
<a name="line13"></a>    val <a href="#INJP-val">INJP</a> : thm
<a name="line14"></a>    val <a href="#ISO-val">ISO</a> : thm
<a name="line15"></a>    val <a href="#NUMPAIR-val">NUMPAIR</a> : thm
<a name="line16"></a>    val <a href="#NUMPAIR_DEST-val">NUMPAIR_DEST</a> : thm
<a name="line17"></a>    val <a href="#NUMSUM-val">NUMSUM</a> : thm
<a name="line18"></a>    val <a href="#NUMSUM_DEST-val">NUMSUM_DEST</a> : thm
<a name="line19"></a>    val <a href="#ZBOT-val">ZBOT</a> : thm
<a name="line20"></a>    val <a href="#ZCONSTR-val">ZCONSTR</a> : thm
<a name="line21"></a>    val <a href="#ZRECSPACE_def-val">ZRECSPACE_def</a> : thm
<a name="line22"></a>    val <a href="#recspace_TY_DEF-val">recspace_TY_DEF</a> : thm
<a name="line23"></a>    val <a href="#recspace_repfns-val">recspace_repfns</a> : thm
<a name="line24"></a>
<a name="line25"></a>  (*  Theorems  *)
<a name="line26"></a>    val <a href="#CONSTR_BOT-val">CONSTR_BOT</a> : thm
<a name="line27"></a>    val <a href="#CONSTR_IND-val">CONSTR_IND</a> : thm
<a name="line28"></a>    val <a href="#CONSTR_INJ-val">CONSTR_INJ</a> : thm
<a name="line29"></a>    val <a href="#CONSTR_REC-val">CONSTR_REC</a> : thm
<a name="line30"></a>    val <a href="#DEST_REC_INJ-val">DEST_REC_INJ</a> : thm
<a name="line31"></a>    val <a href="#FCONS_DEST-val">FCONS_DEST</a> : thm
<a name="line32"></a>    val <a href="#INJA_INJ-val">INJA_INJ</a> : thm
<a name="line33"></a>    val <a href="#INJF_INJ-val">INJF_INJ</a> : thm
<a name="line34"></a>    val <a href="#INJN_INJ-val">INJN_INJ</a> : thm
<a name="line35"></a>    val <a href="#INJP_INJ-val">INJP_INJ</a> : thm
<a name="line36"></a>    val <a href="#INJ_INVERSE2-val">INJ_INVERSE2</a> : thm
<a name="line37"></a>    val <a href="#ISO_FUN-val">ISO_FUN</a> : thm
<a name="line38"></a>    val <a href="#ISO_REFL-val">ISO_REFL</a> : thm
<a name="line39"></a>    val <a href="#ISO_USAGE-val">ISO_USAGE</a> : thm
<a name="line40"></a>    val <a href="#MK_REC_INJ-val">MK_REC_INJ</a> : thm
<a name="line41"></a>    val <a href="#NUMPAIR_INJ-val">NUMPAIR_INJ</a> : thm
<a name="line42"></a>    val <a href="#NUMPAIR_INJ_LEMMA-val">NUMPAIR_INJ_LEMMA</a> : thm
<a name="line43"></a>    val <a href="#NUMSUM_INJ-val">NUMSUM_INJ</a> : thm
<a name="line44"></a>    val <a href="#ZCONSTR_ZBOT-val">ZCONSTR_ZBOT</a> : thm
<a name="line45"></a>    val <a href="#ZRECSPACE_cases-val">ZRECSPACE_cases</a> : thm
<a name="line46"></a>    val <a href="#ZRECSPACE_ind-val">ZRECSPACE_ind</a> : thm
<a name="line47"></a>    val <a href="#ZRECSPACE_rules-val">ZRECSPACE_rules</a> : thm
<a name="line48"></a>    val <a href="#ZRECSPACE_strongind-val">ZRECSPACE_strongind</a> : thm
<a name="line49"></a>
<a name="line50"></a>  val ind_type_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line51"></a>(*
   [numeral] Parent theory of "ind_type"

   [while] Parent theory of "ind_type"

   [<a name="BOTTOM-val"><b>BOTTOM</b></a>]  Definition

      |- ind_type$BOTTOM = mk_rec ind_type$ZBOT

   [<a name="CONSTR-val"><b>CONSTR</b></a>]  Definition

      |- ∀c i r.
           ind_type$CONSTR c i r =
           mk_rec (ind_type$ZCONSTR c i (λn. dest_rec (r n)))

   [<a name="FCONS-val"><b>FCONS</b></a>]  Definition

      |- (∀a f. ind_type$FCONS a f 0 = a) ∧
         ∀a f n. ind_type$FCONS a f (SUC n) = f n

   [<a name="FNIL-val"><b>FNIL</b></a>]  Definition

      |- ∀n. ind_type$FNIL n = ARB

   [<a name="INJA-val"><b>INJA</b></a>]  Definition

      |- ∀a. ind_type$INJA a = (λn b. b = a)

   [<a name="INJF-val"><b>INJF</b></a>]  Definition

      |- ∀f. ind_type$INJF f = (λn. f (NUMFST n) (NUMSND n))

   [<a name="INJN-val"><b>INJN</b></a>]  Definition

      |- ∀m. ind_type$INJN m = (λn a. n = m)

   [<a name="INJP-val"><b>INJP</b></a>]  Definition

      |- ∀f1 f2.
           ind_type$INJP f1 f2 =
           (λn a.
              if NUMLEFT n then f1 (NUMRIGHT n) a else f2 (NUMRIGHT n) a)

   [<a name="ISO-val"><b>ISO</b></a>]  Definition

      |- ∀f g. ind_type$ISO f g ⇔ (∀x. f (g x) = x) ∧ ∀y. g (f y) = y

   [<a name="NUMPAIR-val"><b>NUMPAIR</b></a>]  Definition

      |- ∀x y. ind_type$NUMPAIR x y = 2 ** x * (2 * y + 1)

   [<a name="NUMPAIR_DEST-val"><b>NUMPAIR_DEST</b></a>]  Definition

      |- ∀x y.
           (NUMFST (ind_type$NUMPAIR x y) = x) ∧
           (NUMSND (ind_type$NUMPAIR x y) = y)

   [<a name="NUMSUM-val"><b>NUMSUM</b></a>]  Definition

      |- ∀b x. ind_type$NUMSUM b x = if b then SUC (2 * x) else 2 * x

   [<a name="NUMSUM_DEST-val"><b>NUMSUM_DEST</b></a>]  Definition

      |- ∀x y.
           (NUMLEFT (ind_type$NUMSUM x y) ⇔ x) ∧
           (NUMRIGHT (ind_type$NUMSUM x y) = y)

   [<a name="ZBOT-val"><b>ZBOT</b></a>]  Definition

      |- ind_type$ZBOT = ind_type$INJP (ind_type$INJN 0) (@z. T)

   [<a name="ZCONSTR-val"><b>ZCONSTR</b></a>]  Definition

      |- ∀c i r.
           ind_type$ZCONSTR c i r =
           ind_type$INJP (ind_type$INJN (SUC c))
             (ind_type$INJP (ind_type$INJA i) (ind_type$INJF r))

   [<a name="ZRECSPACE_def-val"><b>ZRECSPACE_def</b></a>]  Definition

      |- ZRECSPACE =
         (λa0.
            ∀ZRECSPACE'.
              (∀a0.
                 (a0 = ind_type$ZBOT) ∨
                 (∃c i r.
                    (a0 = ind_type$ZCONSTR c i r) ∧ ∀n. ZRECSPACE' (r n)) ⇒
                 ZRECSPACE' a0) ⇒
              ZRECSPACE' a0)

   [<a name="recspace_TY_DEF-val"><b>recspace_TY_DEF</b></a>]  Definition

      |- ∃rep. TYPE_DEFINITION ZRECSPACE rep

   [<a name="recspace_repfns-val"><b>recspace_repfns</b></a>]  Definition

      |- (∀a. mk_rec (dest_rec a) = a) ∧
         ∀r. ZRECSPACE r ⇔ (dest_rec (mk_rec r) = r)

   [<a name="CONSTR_BOT-val"><b>CONSTR_BOT</b></a>]  Theorem

      |- ∀c i r. ind_type$CONSTR c i r ≠ ind_type$BOTTOM

   [<a name="CONSTR_IND-val"><b>CONSTR_IND</b></a>]  Theorem

      |- ∀P.
           P ind_type$BOTTOM ∧
           (∀c i r. (∀n. P (r n)) ⇒ P (ind_type$CONSTR c i r)) ⇒
           ∀x. P x

   [<a name="CONSTR_INJ-val"><b>CONSTR_INJ</b></a>]  Theorem

      |- ∀c1 i1 r1 c2 i2 r2.
           (ind_type$CONSTR c1 i1 r1 = ind_type$CONSTR c2 i2 r2) ⇔
           (c1 = c2) ∧ (i1 = i2) ∧ (r1 = r2)

   [<a name="CONSTR_REC-val"><b>CONSTR_REC</b></a>]  Theorem

      |- ∀Fn.
           ∃f. ∀c i r. f (ind_type$CONSTR c i r) = Fn c i r (λn. f (r n))

   [<a name="DEST_REC_INJ-val"><b>DEST_REC_INJ</b></a>]  Theorem

      |- ∀x y. (dest_rec x = dest_rec y) ⇔ (x = y)

   [<a name="FCONS_DEST-val"><b>FCONS_DEST</b></a>]  Theorem

      |- ind_type$FCONS a f n = if n = 0 then a else f (n − 1)

   [<a name="INJA_INJ-val"><b>INJA_INJ</b></a>]  Theorem

      |- ∀a1 a2. (ind_type$INJA a1 = ind_type$INJA a2) ⇔ (a1 = a2)

   [<a name="INJF_INJ-val"><b>INJF_INJ</b></a>]  Theorem

      |- ∀f1 f2. (ind_type$INJF f1 = ind_type$INJF f2) ⇔ (f1 = f2)

   [<a name="INJN_INJ-val"><b>INJN_INJ</b></a>]  Theorem

      |- ∀n1 n2. (ind_type$INJN n1 = ind_type$INJN n2) ⇔ (n1 = n2)

   [<a name="INJP_INJ-val"><b>INJP_INJ</b></a>]  Theorem

      |- ∀f1 f1' f2 f2'.
           (ind_type$INJP f1 f2 = ind_type$INJP f1' f2') ⇔
           (f1 = f1') ∧ (f2 = f2')

   [<a name="INJ_INVERSE2-val"><b>INJ_INVERSE2</b></a>]  Theorem

      |- ∀P.
           (∀x1 y1 x2 y2. (P x1 y1 = P x2 y2) ⇔ (x1 = x2) ∧ (y1 = y2)) ⇒
           ∃X Y. ∀x y. (X (P x y) = x) ∧ (Y (P x y) = y)

   [<a name="ISO_FUN-val"><b>ISO_FUN</b></a>]  Theorem

      |- ind_type$ISO f f' ∧ ind_type$ISO g g' ⇒
         ind_type$ISO (λh a'. g (h (f' a'))) (λh a. g' (h (f a)))

   [<a name="ISO_REFL-val"><b>ISO_REFL</b></a>]  Theorem

      |- ind_type$ISO (λx. x) (λx. x)

   [<a name="ISO_USAGE-val"><b>ISO_USAGE</b></a>]  Theorem

      |- ind_type$ISO f g ⇒
         (∀P. (∀x. P x) ⇔ ∀x. P (g x)) ∧ (∀P. (∃x. P x) ⇔ ∃x. P (g x)) ∧
         ∀a b. (a = g b) ⇔ (f a = b)

   [<a name="MK_REC_INJ-val"><b>MK_REC_INJ</b></a>]  Theorem

      |- ∀x y. (mk_rec x = mk_rec y) ⇒ ZRECSPACE x ∧ ZRECSPACE y ⇒ (x = y)

   [<a name="NUMPAIR_INJ-val"><b>NUMPAIR_INJ</b></a>]  Theorem

      |- ∀x1 y1 x2 y2.
           (ind_type$NUMPAIR x1 y1 = ind_type$NUMPAIR x2 y2) ⇔
           (x1 = x2) ∧ (y1 = y2)

   [<a name="NUMPAIR_INJ_LEMMA-val"><b>NUMPAIR_INJ_LEMMA</b></a>]  Theorem

      |- ∀x1 y1 x2 y2.
           (ind_type$NUMPAIR x1 y1 = ind_type$NUMPAIR x2 y2) ⇒ (x1 = x2)

   [<a name="NUMSUM_INJ-val"><b>NUMSUM_INJ</b></a>]  Theorem

      |- ∀b1 x1 b2 x2.
           (ind_type$NUMSUM b1 x1 = ind_type$NUMSUM b2 x2) ⇔
           (b1 ⇔ b2) ∧ (x1 = x2)

   [<a name="ZCONSTR_ZBOT-val"><b>ZCONSTR_ZBOT</b></a>]  Theorem

      |- ∀c i r. ind_type$ZCONSTR c i r ≠ ind_type$ZBOT

   [<a name="ZRECSPACE_cases-val"><b>ZRECSPACE_cases</b></a>]  Theorem

      |- ∀a0.
           ZRECSPACE a0 ⇔
           (a0 = ind_type$ZBOT) ∨
           ∃c i r. (a0 = ind_type$ZCONSTR c i r) ∧ ∀n. ZRECSPACE (r n)

   [<a name="ZRECSPACE_ind-val"><b>ZRECSPACE_ind</b></a>]  Theorem

      |- ∀ZRECSPACE'.
           ZRECSPACE' ind_type$ZBOT ∧
           (∀c i r.
              (∀n. ZRECSPACE' (r n)) ⇒
              ZRECSPACE' (ind_type$ZCONSTR c i r)) ⇒
           ∀a0. ZRECSPACE a0 ⇒ ZRECSPACE' a0

   [<a name="ZRECSPACE_rules-val"><b>ZRECSPACE_rules</b></a>]  Theorem

      |- ZRECSPACE ind_type$ZBOT ∧
         ∀c i r. (∀n. ZRECSPACE (r n)) ⇒ ZRECSPACE (ind_type$ZCONSTR c i r)

   [<a name="ZRECSPACE_strongind-val"><b>ZRECSPACE_strongind</b></a>]  Theorem

      |- ∀ZRECSPACE'.
           ZRECSPACE' ind_type$ZBOT ∧
           (∀c i r.
              (∀n. ZRECSPACE (r n) ∧ ZRECSPACE' (r n)) ⇒
              ZRECSPACE' (ind_type$ZCONSTR c i r)) ⇒
           ∀a0. ZRECSPACE a0 ⇒ ZRECSPACE' a0


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/datatype/ind_typeScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-9</a></em></p></body></html>
