<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure sortingTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure sortingTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/sort/sortingScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature sortingTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#PART3_DEF-val">PART3_DEF</a> : thm
<a name="line7"></a>    val <a href="#PARTITION_DEF-val">PARTITION_DEF</a> : thm
<a name="line8"></a>    val <a href="#PART_DEF-val">PART_DEF</a> : thm
<a name="line9"></a>    val <a href="#PERM_DEF-val">PERM_DEF</a> : thm
<a name="line10"></a>    val <a href="#PERM_SINGLE_SWAP_DEF-val">PERM_SINGLE_SWAP_DEF</a> : thm
<a name="line11"></a>    val <a href="#QSORT3_curried_DEF-val">QSORT3_curried_DEF</a> : thm
<a name="line12"></a>    val <a href="#QSORT3_tupled_primitive_DEF-val">QSORT3_tupled_primitive_DEF</a> : thm
<a name="line13"></a>    val <a href="#QSORT_curried_DEF-val">QSORT_curried_DEF</a> : thm
<a name="line14"></a>    val <a href="#QSORT_tupled_primitive_DEF-val">QSORT_tupled_primitive_DEF</a> : thm
<a name="line15"></a>    val <a href="#SORTED_curried_DEF-val">SORTED_curried_DEF</a> : thm
<a name="line16"></a>    val <a href="#SORTED_tupled_primitive_DEF-val">SORTED_tupled_primitive_DEF</a> : thm
<a name="line17"></a>    val <a href="#SORTS_DEF-val">SORTS_DEF</a> : thm
<a name="line18"></a>    val <a href="#STABLE_DEF-val">STABLE_DEF</a> : thm
<a name="line19"></a>
<a name="line20"></a>  (*  Theorems  *)
<a name="line21"></a>    val <a href="#ALL_DISTINCT_PERM-val">ALL_DISTINCT_PERM</a> : thm
<a name="line22"></a>    val <a href="#ALL_DISTINCT_PERM_LIST_TO_SET_TO_LIST-val">ALL_DISTINCT_PERM_LIST_TO_SET_TO_LIST</a> : thm
<a name="line23"></a>    val <a href="#APPEND_PERM_SYM-val">APPEND_PERM_SYM</a> : thm
<a name="line24"></a>    val <a href="#CONS_PERM-val">CONS_PERM</a> : thm
<a name="line25"></a>    val <a href="#FOLDR_PERM-val">FOLDR_PERM</a> : thm
<a name="line26"></a>    val <a href="#MEM_PERM-val">MEM_PERM</a> : thm
<a name="line27"></a>    val <a href="#PART3_FILTER-val">PART3_FILTER</a> : thm
<a name="line28"></a>    val <a href="#PART_LENGTH-val">PART_LENGTH</a> : thm
<a name="line29"></a>    val <a href="#PART_LENGTH_LEM-val">PART_LENGTH_LEM</a> : thm
<a name="line30"></a>    val <a href="#PART_MEM-val">PART_MEM</a> : thm
<a name="line31"></a>    val <a href="#PARTs_HAVE_PROP-val">PARTs_HAVE_PROP</a> : thm
<a name="line32"></a>    val <a href="#PERM3-val">PERM3</a> : thm
<a name="line33"></a>    val <a href="#PERM3_FILTER-val">PERM3_FILTER</a> : thm
<a name="line34"></a>    val <a href="#PERM_ALL_DISTINCT-val">PERM_ALL_DISTINCT</a> : thm
<a name="line35"></a>    val <a href="#PERM_APPEND-val">PERM_APPEND</a> : thm
<a name="line36"></a>    val <a href="#PERM_APPEND_IFF-val">PERM_APPEND_IFF</a> : thm
<a name="line37"></a>    val <a href="#PERM_CONG-val">PERM_CONG</a> : thm
<a name="line38"></a>    val <a href="#PERM_CONG_2-val">PERM_CONG_2</a> : thm
<a name="line39"></a>    val <a href="#PERM_CONG_APPEND_IFF-val">PERM_CONG_APPEND_IFF</a> : thm
<a name="line40"></a>    val <a href="#PERM_CONS_EQ_APPEND-val">PERM_CONS_EQ_APPEND</a> : thm
<a name="line41"></a>    val <a href="#PERM_CONS_IFF-val">PERM_CONS_IFF</a> : thm
<a name="line42"></a>    val <a href="#PERM_EQC-val">PERM_EQC</a> : thm
<a name="line43"></a>    val <a href="#PERM_EQUIVALENCE-val">PERM_EQUIVALENCE</a> : thm
<a name="line44"></a>    val <a href="#PERM_EQUIVALENCE_ALT_DEF-val">PERM_EQUIVALENCE_ALT_DEF</a> : thm
<a name="line45"></a>    val <a href="#PERM_FILTER-val">PERM_FILTER</a> : thm
<a name="line46"></a>    val <a href="#PERM_FUN_APPEND-val">PERM_FUN_APPEND</a> : thm
<a name="line47"></a>    val <a href="#PERM_FUN_APPEND_APPEND_1-val">PERM_FUN_APPEND_APPEND_1</a> : thm
<a name="line48"></a>    val <a href="#PERM_FUN_APPEND_APPEND_2-val">PERM_FUN_APPEND_APPEND_2</a> : thm
<a name="line49"></a>    val <a href="#PERM_FUN_APPEND_CONS-val">PERM_FUN_APPEND_CONS</a> : thm
<a name="line50"></a>    val <a href="#PERM_FUN_APPEND_IFF-val">PERM_FUN_APPEND_IFF</a> : thm
<a name="line51"></a>    val <a href="#PERM_FUN_CONG-val">PERM_FUN_CONG</a> : thm
<a name="line52"></a>    val <a href="#PERM_FUN_CONS-val">PERM_FUN_CONS</a> : thm
<a name="line53"></a>    val <a href="#PERM_FUN_CONS_11_APPEND-val">PERM_FUN_CONS_11_APPEND</a> : thm
<a name="line54"></a>    val <a href="#PERM_FUN_CONS_11_SWAP_AT_FRONT-val">PERM_FUN_CONS_11_SWAP_AT_FRONT</a> : thm
<a name="line55"></a>    val <a href="#PERM_FUN_CONS_APPEND_1-val">PERM_FUN_CONS_APPEND_1</a> : thm
<a name="line56"></a>    val <a href="#PERM_FUN_CONS_APPEND_2-val">PERM_FUN_CONS_APPEND_2</a> : thm
<a name="line57"></a>    val <a href="#PERM_FUN_CONS_IFF-val">PERM_FUN_CONS_IFF</a> : thm
<a name="line58"></a>    val <a href="#PERM_FUN_SPLIT-val">PERM_FUN_SPLIT</a> : thm
<a name="line59"></a>    val <a href="#PERM_FUN_SWAP_AT_FRONT-val">PERM_FUN_SWAP_AT_FRONT</a> : thm
<a name="line60"></a>    val <a href="#PERM_IND-val">PERM_IND</a> : thm
<a name="line61"></a>    val <a href="#PERM_INTRO-val">PERM_INTRO</a> : thm
<a name="line62"></a>    val <a href="#PERM_LENGTH-val">PERM_LENGTH</a> : thm
<a name="line63"></a>    val <a href="#PERM_LIST_TO_SET-val">PERM_LIST_TO_SET</a> : thm
<a name="line64"></a>    val <a href="#PERM_MAP-val">PERM_MAP</a> : thm
<a name="line65"></a>    val <a href="#PERM_MEM_EQ-val">PERM_MEM_EQ</a> : thm
<a name="line66"></a>    val <a href="#PERM_MONO-val">PERM_MONO</a> : thm
<a name="line67"></a>    val <a href="#PERM_NIL-val">PERM_NIL</a> : thm
<a name="line68"></a>    val <a href="#PERM_QSORT3-val">PERM_QSORT3</a> : thm
<a name="line69"></a>    val <a href="#PERM_REFL-val">PERM_REFL</a> : thm
<a name="line70"></a>    val <a href="#PERM_REVERSE-val">PERM_REVERSE</a> : thm
<a name="line71"></a>    val <a href="#PERM_REVERSE_EQ-val">PERM_REVERSE_EQ</a> : thm
<a name="line72"></a>    val <a href="#PERM_REWR-val">PERM_REWR</a> : thm
<a name="line73"></a>    val <a href="#PERM_RTC-val">PERM_RTC</a> : thm
<a name="line74"></a>    val <a href="#PERM_SET_TO_LIST_count_COUNT_LIST-val">PERM_SET_TO_LIST_count_COUNT_LIST</a> : thm
<a name="line75"></a>    val <a href="#PERM_SING-val">PERM_SING</a> : thm
<a name="line76"></a>    val <a href="#PERM_SINGLE_SWAP_REFL-val">PERM_SINGLE_SWAP_REFL</a> : thm
<a name="line77"></a>    val <a href="#PERM_SINGLE_SWAP_SYM-val">PERM_SINGLE_SWAP_SYM</a> : thm
<a name="line78"></a>    val <a href="#PERM_SPLIT-val">PERM_SPLIT</a> : thm
<a name="line79"></a>    val <a href="#PERM_SUM-val">PERM_SUM</a> : thm
<a name="line80"></a>    val <a href="#PERM_SWAP_AT_FRONT-val">PERM_SWAP_AT_FRONT</a> : thm
<a name="line81"></a>    val <a href="#PERM_SYM-val">PERM_SYM</a> : thm
<a name="line82"></a>    val <a href="#PERM_TC-val">PERM_TC</a> : thm
<a name="line83"></a>    val <a href="#PERM_TRANS-val">PERM_TRANS</a> : thm
<a name="line84"></a>    val <a href="#PERM_lifts_equalities-val">PERM_lifts_equalities</a> : thm
<a name="line85"></a>    val <a href="#PERM_lifts_invariants-val">PERM_lifts_invariants</a> : thm
<a name="line86"></a>    val <a href="#PERM_lifts_monotonicities-val">PERM_lifts_monotonicities</a> : thm
<a name="line87"></a>    val <a href="#PERM_lifts_transitive_relations-val">PERM_lifts_transitive_relations</a> : thm
<a name="line88"></a>    val <a href="#PERM_transitive-val">PERM_transitive</a> : thm
<a name="line89"></a>    val <a href="#QSORT3_DEF-val">QSORT3_DEF</a> : thm
<a name="line90"></a>    val <a href="#QSORT3_IND-val">QSORT3_IND</a> : thm
<a name="line91"></a>    val <a href="#QSORT3_SORTS-val">QSORT3_SORTS</a> : thm
<a name="line92"></a>    val <a href="#QSORT3_SPLIT-val">QSORT3_SPLIT</a> : thm
<a name="line93"></a>    val <a href="#QSORT3_STABLE-val">QSORT3_STABLE</a> : thm
<a name="line94"></a>    val <a href="#QSORT_DEF-val">QSORT_DEF</a> : thm
<a name="line95"></a>    val <a href="#QSORT_IND-val">QSORT_IND</a> : thm
<a name="line96"></a>    val <a href="#QSORT_MEM-val">QSORT_MEM</a> : thm
<a name="line97"></a>    val <a href="#QSORT_PERM-val">QSORT_PERM</a> : thm
<a name="line98"></a>    val <a href="#QSORT_SORTED-val">QSORT_SORTED</a> : thm
<a name="line99"></a>    val <a href="#QSORT_SORTS-val">QSORT_SORTS</a> : thm
<a name="line100"></a>    val <a href="#QSORT_eq_if_PERM-val">QSORT_eq_if_PERM</a> : thm
<a name="line101"></a>    val <a href="#SORTED_APPEND-val">SORTED_APPEND</a> : thm
<a name="line102"></a>    val <a href="#SORTED_DEF-val">SORTED_DEF</a> : thm
<a name="line103"></a>    val <a href="#SORTED_EL_LESS-val">SORTED_EL_LESS</a> : thm
<a name="line104"></a>    val <a href="#SORTED_EL_SUC-val">SORTED_EL_SUC</a> : thm
<a name="line105"></a>    val <a href="#SORTED_EQ-val">SORTED_EQ</a> : thm
<a name="line106"></a>    val <a href="#SORTED_EQ_PART-val">SORTED_EQ_PART</a> : thm
<a name="line107"></a>    val <a href="#SORTED_IND-val">SORTED_IND</a> : thm
<a name="line108"></a>    val <a href="#SORTED_NIL-val">SORTED_NIL</a> : thm
<a name="line109"></a>    val <a href="#SORTED_PERM_EQ-val">SORTED_PERM_EQ</a> : thm
<a name="line110"></a>    val <a href="#SORTED_SING-val">SORTED_SING</a> : thm
<a name="line111"></a>    val <a href="#SORTED_transitive_APPEND_IFF-val">SORTED_transitive_APPEND_IFF</a> : thm
<a name="line112"></a>    val <a href="#SUM_IMAGE_count_MULT-val">SUM_IMAGE_count_MULT</a> : thm
<a name="line113"></a>    val <a href="#SUM_IMAGE_count_SUM_GENLIST-val">SUM_IMAGE_count_SUM_GENLIST</a> : thm
<a name="line114"></a>    val <a href="#sum_of_sums-val">sum_of_sums</a> : thm
<a name="line115"></a>
<a name="line116"></a>  val sorting_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line117"></a>(*
   [rich_list] Parent theory of "sorting"

   [<a name="PART3_DEF-val"><b>PART3_DEF</b></a>]  Definition

      |- (∀R h. PART3 R h [] = ([],[],[])) ∧
         ∀R h hd tl.
           PART3 R h (hd::tl) =
           if R h hd ∧ R hd h then (I ## CONS hd ## I) (PART3 R h tl)
           else if R hd h then (CONS hd ## I ## I) (PART3 R h tl)
           else (I ## I ## CONS hd) (PART3 R h tl)

   [<a name="PARTITION_DEF-val"><b>PARTITION_DEF</b></a>]  Definition

      |- ∀P l. PARTITION P l = PART P l [] []

   [<a name="PART_DEF-val"><b>PART_DEF</b></a>]  Definition

      |- (∀P l1 l2. PART P [] l1 l2 = (l1,l2)) ∧
         ∀P h rst l1 l2.
           PART P (h::rst) l1 l2 =
           if P h then PART P rst (h::l1) l2 else PART P rst l1 (h::l2)

   [<a name="PERM_DEF-val"><b>PERM_DEF</b></a>]  Definition

      |- ∀L1 L2. PERM L1 L2 ⇔ ∀x. FILTER ($= x) L1 = FILTER ($= x) L2

   [<a name="PERM_SINGLE_SWAP_DEF-val"><b>PERM_SINGLE_SWAP_DEF</b></a>]  Definition

      |- ∀l1 l2.
           PERM_SINGLE_SWAP l1 l2 ⇔
           ∃x1 x2 x3. (l1 = x1 ++ x2 ++ x3) ∧ (l2 = x1 ++ x3 ++ x2)

   [<a name="QSORT3_curried_DEF-val"><b>QSORT3_curried_DEF</b></a>]  Definition

      |- ∀x x1. QSORT3 x x1 = QSORT3_tupled (x,x1)

   [<a name="QSORT3_tupled_primitive_DEF-val"><b>QSORT3_tupled_primitive_DEF</b></a>]  Definition

      |- QSORT3_tupled =
         WFREC
           (@R'.
              WF R' ∧
              (∀tl hd R lo eq hi.
                 ((lo,eq,hi) = PART3 R hd tl) ⇒ R' (R,hi) (R,hd::tl)) ∧
              ∀tl hd R lo eq hi.
                ((lo,eq,hi) = PART3 R hd tl) ⇒ R' (R,lo) (R,hd::tl))
           (λQSORT3_tupled a.
              case a of
                (R,[]) =&gt; I []
              | (R,hd::tl) =&gt;
                  I
                    (let (lo,eq,hi) = PART3 R hd tl
                     in
                       QSORT3_tupled (R,lo) ++ hd::eq ++
                       QSORT3_tupled (R,hi)))

   [<a name="QSORT_curried_DEF-val"><b>QSORT_curried_DEF</b></a>]  Definition

      |- ∀x x1. QSORT x x1 = QSORT_tupled (x,x1)

   [<a name="QSORT_tupled_primitive_DEF-val"><b>QSORT_tupled_primitive_DEF</b></a>]  Definition

      |- QSORT_tupled =
         WFREC
           (@R.
              WF R ∧
              (∀t h ord l1 l2.
                 ((l1,l2) = PARTITION (λy. ord y h) t) ⇒
                 R (ord,l2) (ord,h::t)) ∧
              ∀t h ord l1 l2.
                ((l1,l2) = PARTITION (λy. ord y h) t) ⇒
                R (ord,l1) (ord,h::t))
           (λQSORT_tupled a.
              case a of
                (ord,[]) =&gt; I []
              | (ord,h::t) =&gt;
                  I
                    (let (l1,l2) = PARTITION (λy. ord y h) t
                     in
                       QSORT_tupled (ord,l1) ++ [h] ++
                       QSORT_tupled (ord,l2)))

   [<a name="SORTED_curried_DEF-val"><b>SORTED_curried_DEF</b></a>]  Definition

      |- ∀x x1. SORTED x x1 ⇔ SORTED_tupled (x,x1)

   [<a name="SORTED_tupled_primitive_DEF-val"><b>SORTED_tupled_primitive_DEF</b></a>]  Definition

      |- SORTED_tupled =
         WFREC (@R'. WF R' ∧ ∀x rst y R. R' (R,y::rst) (R,x::y::rst))
           (λSORTED_tupled a.
              case a of
                (R,[]) =&gt; I T
              | (R,[x]) =&gt; I T
              | (R,x::y::rst) =&gt; I (R x y ∧ SORTED_tupled (R,y::rst)))

   [<a name="SORTS_DEF-val"><b>SORTS_DEF</b></a>]  Definition

      |- ∀f R. SORTS f R ⇔ ∀l. PERM l (f R l) ∧ SORTED R (f R l)

   [<a name="STABLE_DEF-val"><b>STABLE_DEF</b></a>]  Definition

      |- ∀sort r.
           STABLE sort r ⇔
           SORTS sort r ∧
           ∀p.
             (∀x y. p x ∧ p y ⇒ r x y) ⇒
             ∀l. FILTER p l = FILTER p (sort r l)

   [<a name="ALL_DISTINCT_PERM-val"><b>ALL_DISTINCT_PERM</b></a>]  Theorem

      |- ∀l1 l2. PERM l1 l2 ⇒ (ALL_DISTINCT l1 ⇔ ALL_DISTINCT l2)

   [<a name="ALL_DISTINCT_PERM_LIST_TO_SET_TO_LIST-val"><b>ALL_DISTINCT_PERM_LIST_TO_SET_TO_LIST</b></a>]  Theorem

      |- ∀ls. ALL_DISTINCT ls ⇔ PERM ls (SET_TO_LIST (set ls))

   [<a name="APPEND_PERM_SYM-val"><b>APPEND_PERM_SYM</b></a>]  Theorem

      |- ∀A B C. PERM (A ++ B) C ⇒ PERM (B ++ A) C

   [<a name="CONS_PERM-val"><b>CONS_PERM</b></a>]  Theorem

      |- ∀x L M N. PERM L (M ++ N) ⇒ PERM (x::L) (M ++ x::N)

   [<a name="FOLDR_PERM-val"><b>FOLDR_PERM</b></a>]  Theorem

      |- ∀f l1 l2 e.
           ASSOC f ∧ COMM f ⇒ PERM l1 l2 ⇒ (FOLDR f e l1 = FOLDR f e l2)

   [<a name="MEM_PERM-val"><b>MEM_PERM</b></a>]  Theorem

      |- ∀l1 l2. PERM l1 l2 ⇒ ∀a. MEM a l1 ⇔ MEM a l2

   [<a name="PART3_FILTER-val"><b>PART3_FILTER</b></a>]  Theorem

      |- ∀tl hd.
           PART3 R hd tl =
           (FILTER (λx. R x hd ∧ ¬R hd x) tl,
            FILTER (λx. R x hd ∧ R hd x) tl,FILTER (λx. ¬R x hd) tl)

   [<a name="PART_LENGTH-val"><b>PART_LENGTH</b></a>]  Theorem

      |- ∀P L l1 l2 p q.
           ((p,q) = PART P L l1 l2) ⇒
           (LENGTH L + LENGTH l1 + LENGTH l2 = LENGTH p + LENGTH q)

   [<a name="PART_LENGTH_LEM-val"><b>PART_LENGTH_LEM</b></a>]  Theorem

      |- ∀P L l1 l2 p q.
           ((p,q) = PART P L l1 l2) ⇒
           LENGTH p ≤ LENGTH L + LENGTH l1 + LENGTH l2 ∧
           LENGTH q ≤ LENGTH L + LENGTH l1 + LENGTH l2

   [<a name="PART_MEM-val"><b>PART_MEM</b></a>]  Theorem

      |- ∀P L a1 a2 l1 l2.
           ((a1,a2) = PART P L l1 l2) ⇒
           ∀x. MEM x (L ++ (l1 ++ l2)) ⇔ MEM x (a1 ++ a2)

   [<a name="PARTs_HAVE_PROP-val"><b>PARTs_HAVE_PROP</b></a>]  Theorem

      |- ∀P L A B l1 l2.
           ((A,B) = PART P L l1 l2) ∧ (∀x. MEM x l1 ⇒ P x) ∧
           (∀x. MEM x l2 ⇒ ¬P x) ⇒
           (∀z. MEM z A ⇒ P z) ∧ ∀z. MEM z B ⇒ ¬P z

   [<a name="PERM3-val"><b>PERM3</b></a>]  Theorem

      |- ∀x a a' b b' c c'.
           (PERM a a' ∧ PERM b b' ∧ PERM c c') ∧ PERM x (a ++ b ++ c) ⇒
           PERM x (a' ++ b' ++ c')

   [<a name="PERM3_FILTER-val"><b>PERM3_FILTER</b></a>]  Theorem

      |- ∀l h.
           PERM l
             (FILTER (λx. R x h ∧ ¬R h x) l ++
              FILTER (λx. R x h ∧ R h x) l ++ FILTER (λx. ¬R x h) l)

   [<a name="PERM_ALL_DISTINCT-val"><b>PERM_ALL_DISTINCT</b></a>]  Theorem

      |- ∀l1 l2.
           ALL_DISTINCT l1 ∧ ALL_DISTINCT l2 ∧ (∀x. MEM x l1 ⇔ MEM x l2) ⇒
           PERM l1 l2

   [<a name="PERM_APPEND-val"><b>PERM_APPEND</b></a>]  Theorem

      |- ∀l1 l2. PERM (l1 ++ l2) (l2 ++ l1)

   [<a name="PERM_APPEND_IFF-val"><b>PERM_APPEND_IFF</b></a>]  Theorem

      |- (∀l l1 l2. PERM (l ++ l1) (l ++ l2) ⇔ PERM l1 l2) ∧
         ∀l l1 l2. PERM (l1 ++ l) (l2 ++ l) ⇔ PERM l1 l2

   [<a name="PERM_CONG-val"><b>PERM_CONG</b></a>]  Theorem

      |- ∀L1 L2 L3 L4. PERM L1 L3 ∧ PERM L2 L4 ⇒ PERM (L1 ++ L2) (L3 ++ L4)

   [<a name="PERM_CONG_2-val"><b>PERM_CONG_2</b></a>]  Theorem

      |- ∀l1 l1' l2 l2'.
           PERM l1 l1' ⇒ PERM l2 l2' ⇒ (PERM l1 l2 ⇔ PERM l1' l2')

   [<a name="PERM_CONG_APPEND_IFF-val"><b>PERM_CONG_APPEND_IFF</b></a>]  Theorem

      |- ∀l l1 l1' l2 l2'.
           PERM l1 (l ++ l1') ⇒
           PERM l2 (l ++ l2') ⇒
           (PERM l1 l2 ⇔ PERM l1' l2')

   [<a name="PERM_CONS_EQ_APPEND-val"><b>PERM_CONS_EQ_APPEND</b></a>]  Theorem

      |- ∀L h. PERM (h::t) L ⇔ ∃M N. (L = M ++ h::N) ∧ PERM t (M ++ N)

   [<a name="PERM_CONS_IFF-val"><b>PERM_CONS_IFF</b></a>]  Theorem

      |- ∀x l2 l1. PERM (x::l1) (x::l2) ⇔ PERM l1 l2

   [<a name="PERM_EQC-val"><b>PERM_EQC</b></a>]  Theorem

      |- PERM = PERM_SINGLE_SWAP^=

   [<a name="PERM_EQUIVALENCE-val"><b>PERM_EQUIVALENCE</b></a>]  Theorem

      |- equivalence PERM

   [<a name="PERM_EQUIVALENCE_ALT_DEF-val"><b>PERM_EQUIVALENCE_ALT_DEF</b></a>]  Theorem

      |- ∀x y. PERM x y ⇔ (PERM x = PERM y)

   [<a name="PERM_FILTER-val"><b>PERM_FILTER</b></a>]  Theorem

      |- ∀P l1 l2. PERM l1 l2 ⇒ PERM (FILTER P l1) (FILTER P l2)

   [<a name="PERM_FUN_APPEND-val"><b>PERM_FUN_APPEND</b></a>]  Theorem

      |- ∀l1 l2. PERM (l1 ++ l2) = PERM (l2 ++ l1)

   [<a name="PERM_FUN_APPEND_APPEND_1-val"><b>PERM_FUN_APPEND_APPEND_1</b></a>]  Theorem

      |- ∀l1 l2 l3 l4.
           (PERM l1 = PERM (l2 ++ l3)) ⇒
           (PERM (l1 ++ l4) = PERM (l2 ++ (l3 ++ l4)))

   [<a name="PERM_FUN_APPEND_APPEND_2-val"><b>PERM_FUN_APPEND_APPEND_2</b></a>]  Theorem

      |- ∀l1 l2 l3 l4.
           (PERM l1 = PERM (l2 ++ l3)) ⇒
           (PERM (l4 ++ l1) = PERM (l2 ++ (l4 ++ l3)))

   [<a name="PERM_FUN_APPEND_CONS-val"><b>PERM_FUN_APPEND_CONS</b></a>]  Theorem

      |- ∀x l1 l2. PERM (l1 ++ x::l2) = PERM (x::l1 ++ l2)

   [<a name="PERM_FUN_APPEND_IFF-val"><b>PERM_FUN_APPEND_IFF</b></a>]  Theorem

      |- ∀l l1 l2. (PERM l1 = PERM l2) ⇒ (PERM (l ++ l1) = PERM (l ++ l2))

   [<a name="PERM_FUN_CONG-val"><b>PERM_FUN_CONG</b></a>]  Theorem

      |- ∀l1 l1' l2 l2'.
           (PERM l1 = PERM l1') ⇒
           (PERM l2 = PERM l2') ⇒
           (PERM l1 l2 ⇔ PERM l1' l2')

   [<a name="PERM_FUN_CONS-val"><b>PERM_FUN_CONS</b></a>]  Theorem

      |- ∀x l1 l1'. (PERM l1 = PERM l1') ⇒ (PERM (x::l1) = PERM (x::l1'))

   [<a name="PERM_FUN_CONS_11_APPEND-val"><b>PERM_FUN_CONS_11_APPEND</b></a>]  Theorem

      |- ∀y l1 l2 l3.
           (PERM l1 = PERM (l2 ++ l3)) ⇒
           (PERM (y::l1) = PERM (l2 ++ y::l3))

   [<a name="PERM_FUN_CONS_11_SWAP_AT_FRONT-val"><b>PERM_FUN_CONS_11_SWAP_AT_FRONT</b></a>]  Theorem

      |- ∀y l1 x l2.
           (PERM l1 = PERM (x::l2)) ⇒ (PERM (y::l1) = PERM (x::y::l2))

   [<a name="PERM_FUN_CONS_APPEND_1-val"><b>PERM_FUN_CONS_APPEND_1</b></a>]  Theorem

      |- ∀l l1 x l2.
           (PERM l1 = PERM (x::l2)) ⇒
           (PERM (l1 ++ l) = PERM (x::(l2 ++ l)))

   [<a name="PERM_FUN_CONS_APPEND_2-val"><b>PERM_FUN_CONS_APPEND_2</b></a>]  Theorem

      |- ∀l l1 x l2.
           (PERM l1 = PERM (x::l2)) ⇒
           (PERM (l ++ l1) = PERM (x::(l ++ l2)))

   [<a name="PERM_FUN_CONS_IFF-val"><b>PERM_FUN_CONS_IFF</b></a>]  Theorem

      |- ∀x l1 l2. (PERM l1 = PERM l2) ⇒ (PERM (x::l1) = PERM (x::l2))

   [<a name="PERM_FUN_SPLIT-val"><b>PERM_FUN_SPLIT</b></a>]  Theorem

      |- ∀l l1 l1' l2. PERM l (l1 ++ l2) ⇒ PERM l1' l1 ⇒ PERM l (l1' ++ l2)

   [<a name="PERM_FUN_SWAP_AT_FRONT-val"><b>PERM_FUN_SWAP_AT_FRONT</b></a>]  Theorem

      |- ∀x y l. PERM (x::y::l) = PERM (y::x::l)

   [<a name="PERM_IND-val"><b>PERM_IND</b></a>]  Theorem

      |- ∀P.
           P [] [] ∧ (∀x l1 l2. P l1 l2 ⇒ P (x::l1) (x::l2)) ∧
           (∀x y l1 l2. P l1 l2 ⇒ P (x::y::l1) (y::x::l2)) ∧
           (∀l1 l2 l3. P l1 l2 ∧ P l2 l3 ⇒ P l1 l3) ⇒
           ∀l1 l2. PERM l1 l2 ⇒ P l1 l2

   [<a name="PERM_INTRO-val"><b>PERM_INTRO</b></a>]  Theorem

      |- ∀x y. (x = y) ⇒ PERM x y

   [<a name="PERM_LENGTH-val"><b>PERM_LENGTH</b></a>]  Theorem

      |- ∀l1 l2. PERM l1 l2 ⇒ (LENGTH l1 = LENGTH l2)

   [<a name="PERM_LIST_TO_SET-val"><b>PERM_LIST_TO_SET</b></a>]  Theorem

      |- ∀l1 l2. PERM l1 l2 ⇒ (set l1 = set l2)

   [<a name="PERM_MAP-val"><b>PERM_MAP</b></a>]  Theorem

      |- ∀f l1 l2. PERM l1 l2 ⇒ PERM (MAP f l1) (MAP f l2)

   [<a name="PERM_MEM_EQ-val"><b>PERM_MEM_EQ</b></a>]  Theorem

      |- ∀l1 l2. PERM l1 l2 ⇒ ∀x. MEM x l1 ⇔ MEM x l2

   [<a name="PERM_MONO-val"><b>PERM_MONO</b></a>]  Theorem

      |- ∀l1 l2 x. PERM l1 l2 ⇒ PERM (x::l1) (x::l2)

   [<a name="PERM_NIL-val"><b>PERM_NIL</b></a>]  Theorem

      |- ∀L. (PERM L [] ⇔ (L = [])) ∧ (PERM [] L ⇔ (L = []))

   [<a name="PERM_QSORT3-val"><b>PERM_QSORT3</b></a>]  Theorem

      |- ∀l R. PERM l (QSORT3 R l)

   [<a name="PERM_REFL-val"><b>PERM_REFL</b></a>]  Theorem

      |- ∀L. PERM L L

   [<a name="PERM_REVERSE-val"><b>PERM_REVERSE</b></a>]  Theorem

      |- PERM ls (REVERSE ls)

   [<a name="PERM_REVERSE_EQ-val"><b>PERM_REVERSE_EQ</b></a>]  Theorem

      |- (PERM (REVERSE l1) l2 ⇔ PERM l1 l2) ∧
         (PERM l1 (REVERSE l2) ⇔ PERM l1 l2)

   [<a name="PERM_REWR-val"><b>PERM_REWR</b></a>]  Theorem

      |- ∀l r l1 l2. PERM l r ⇒ (PERM (l ++ l1) l2 ⇔ PERM (r ++ l1) l2)

   [<a name="PERM_RTC-val"><b>PERM_RTC</b></a>]  Theorem

      |- PERM = PERM_SINGLE_SWAP^*

   [<a name="PERM_SET_TO_LIST_count_COUNT_LIST-val"><b>PERM_SET_TO_LIST_count_COUNT_LIST</b></a>]  Theorem

      |- PERM (SET_TO_LIST (count n)) (COUNT_LIST n)

   [<a name="PERM_SING-val"><b>PERM_SING</b></a>]  Theorem

      |- (PERM L [x] ⇔ (L = [x])) ∧ (PERM [x] L ⇔ (L = [x]))

   [<a name="PERM_SINGLE_SWAP_REFL-val"><b>PERM_SINGLE_SWAP_REFL</b></a>]  Theorem

      |- ∀l. PERM_SINGLE_SWAP l l

   [<a name="PERM_SINGLE_SWAP_SYM-val"><b>PERM_SINGLE_SWAP_SYM</b></a>]  Theorem

      |- ∀l1 l2. PERM_SINGLE_SWAP l1 l2 ⇔ PERM_SINGLE_SWAP l2 l1

   [<a name="PERM_SPLIT-val"><b>PERM_SPLIT</b></a>]  Theorem

      |- ∀P l. PERM l (FILTER P l ++ FILTER ($~ o P) l)

   [<a name="PERM_SUM-val"><b>PERM_SUM</b></a>]  Theorem

      |- ∀l1 l2. PERM l1 l2 ⇒ (SUM l1 = SUM l2)

   [<a name="PERM_SWAP_AT_FRONT-val"><b>PERM_SWAP_AT_FRONT</b></a>]  Theorem

      |- PERM (x::y::l1) (y::x::l2) ⇔ PERM l1 l2

   [<a name="PERM_SYM-val"><b>PERM_SYM</b></a>]  Theorem

      |- ∀l1 l2. PERM l1 l2 ⇔ PERM l2 l1

   [<a name="PERM_TC-val"><b>PERM_TC</b></a>]  Theorem

      |- PERM = PERM_SINGLE_SWAP⁺

   [<a name="PERM_TRANS-val"><b>PERM_TRANS</b></a>]  Theorem

      |- ∀x y z. PERM x y ∧ PERM y z ⇒ PERM x z

   [<a name="PERM_lifts_equalities-val"><b>PERM_lifts_equalities</b></a>]  Theorem

      |- ∀f.
           (∀x1 x2 x3. f (x1 ++ x2 ++ x3) = f (x1 ++ x3 ++ x2)) ⇒
           ∀x y. PERM x y ⇒ (f x = f y)

   [<a name="PERM_lifts_invariants-val"><b>PERM_lifts_invariants</b></a>]  Theorem

      |- ∀P.
           (∀x1 x2 x3. P (x1 ++ x2 ++ x3) ⇒ P (x1 ++ x3 ++ x2)) ⇒
           ∀x y. P x ∧ PERM x y ⇒ P y

   [<a name="PERM_lifts_monotonicities-val"><b>PERM_lifts_monotonicities</b></a>]  Theorem

      |- ∀f.
           (∀x1 x2 x3.
              ∃x1' x2' x3'.
                (f (x1 ++ x2 ++ x3) = x1' ++ x2' ++ x3') ∧
                (f (x1 ++ x3 ++ x2) = x1' ++ x3' ++ x2')) ⇒
           ∀x y. PERM x y ⇒ PERM (f x) (f y)

   [<a name="PERM_lifts_transitive_relations-val"><b>PERM_lifts_transitive_relations</b></a>]  Theorem

      |- ∀f Q.
           (∀x1 x2 x3. Q (f (x1 ++ x2 ++ x3)) (f (x1 ++ x3 ++ x2))) ∧
           transitive Q ⇒
           ∀x y. PERM x y ⇒ Q (f x) (f y)

   [<a name="PERM_transitive-val"><b>PERM_transitive</b></a>]  Theorem

      |- transitive PERM

   [<a name="QSORT3_DEF-val"><b>QSORT3_DEF</b></a>]  Theorem

      |- (∀R. QSORT3 R [] = []) ∧
         ∀tl hd R.
           QSORT3 R (hd::tl) =
           (let (lo,eq,hi) = PART3 R hd tl
            in
              QSORT3 R lo ++ hd::eq ++ QSORT3 R hi)

   [<a name="QSORT3_IND-val"><b>QSORT3_IND</b></a>]  Theorem

      |- ∀P.
           (∀R. P R []) ∧
           (∀R hd tl.
              (∀lo eq hi. ((lo,eq,hi) = PART3 R hd tl) ⇒ P R hi) ∧
              (∀lo eq hi. ((lo,eq,hi) = PART3 R hd tl) ⇒ P R lo) ⇒
              P R (hd::tl)) ⇒
           ∀v v1. P v v1

   [<a name="QSORT3_SORTS-val"><b>QSORT3_SORTS</b></a>]  Theorem

      |- ∀R. transitive R ∧ total R ⇒ SORTS QSORT3 R

   [<a name="QSORT3_SPLIT-val"><b>QSORT3_SPLIT</b></a>]  Theorem

      |- ∀R.
           transitive R ∧ total R ⇒
           ∀l e.
             QSORT3 R l =
             QSORT3 R (FILTER (λx. R x e ∧ ¬R e x) l) ++
             FILTER (λx. R x e ∧ R e x) l ++
             QSORT3 R (FILTER (λx. ¬R x e) l)

   [<a name="QSORT3_STABLE-val"><b>QSORT3_STABLE</b></a>]  Theorem

      |- ∀R. transitive R ∧ total R ⇒ STABLE QSORT3 R

   [<a name="QSORT_DEF-val"><b>QSORT_DEF</b></a>]  Theorem

      |- (∀ord. QSORT ord [] = []) ∧
         ∀t ord h.
           QSORT ord (h::t) =
           (let (l1,l2) = PARTITION (λy. ord y h) t
            in
              QSORT ord l1 ++ [h] ++ QSORT ord l2)

   [<a name="QSORT_IND-val"><b>QSORT_IND</b></a>]  Theorem

      |- ∀P.
           (∀ord. P ord []) ∧
           (∀ord h t.
              (∀l1 l2. ((l1,l2) = PARTITION (λy. ord y h) t) ⇒ P ord l2) ∧
              (∀l1 l2. ((l1,l2) = PARTITION (λy. ord y h) t) ⇒ P ord l1) ⇒
              P ord (h::t)) ⇒
           ∀v v1. P v v1

   [<a name="QSORT_MEM-val"><b>QSORT_MEM</b></a>]  Theorem

      |- ∀R L x. MEM x (QSORT R L) ⇔ MEM x L

   [<a name="QSORT_PERM-val"><b>QSORT_PERM</b></a>]  Theorem

      |- ∀R L. PERM L (QSORT R L)

   [<a name="QSORT_SORTED-val"><b>QSORT_SORTED</b></a>]  Theorem

      |- ∀R L. transitive R ∧ total R ⇒ SORTED R (QSORT R L)

   [<a name="QSORT_SORTS-val"><b>QSORT_SORTS</b></a>]  Theorem

      |- ∀R. transitive R ∧ total R ⇒ SORTS QSORT R

   [<a name="QSORT_eq_if_PERM-val"><b>QSORT_eq_if_PERM</b></a>]  Theorem

      |- ∀R.
           total R ∧ transitive R ∧ antisymmetric R ⇒
           ∀l1 l2. (QSORT R l1 = QSORT R l2) ⇔ PERM l1 l2

   [<a name="SORTED_APPEND-val"><b>SORTED_APPEND</b></a>]  Theorem

      |- ∀R L1 L2.
           transitive R ∧ SORTED R L1 ∧ SORTED R L2 ∧
           (∀x y. MEM x L1 ∧ MEM y L2 ⇒ R x y) ⇒
           SORTED R (L1 ++ L2)

   [<a name="SORTED_DEF-val"><b>SORTED_DEF</b></a>]  Theorem

      |- (∀R. SORTED R [] ⇔ T) ∧ (∀x R. SORTED R [x] ⇔ T) ∧
         ∀y x rst R. SORTED R (x::y::rst) ⇔ R x y ∧ SORTED R (y::rst)

   [<a name="SORTED_EL_LESS-val"><b>SORTED_EL_LESS</b></a>]  Theorem

      |- ∀R.
           transitive R ⇒
           ∀ls.
             SORTED R ls ⇔
             ∀m n. m &lt; n ∧ n &lt; LENGTH ls ⇒ R (EL m ls) (EL n ls)

   [<a name="SORTED_EL_SUC-val"><b>SORTED_EL_SUC</b></a>]  Theorem

      |- ∀R ls.
           SORTED R ls ⇔
           ∀n. SUC n &lt; LENGTH ls ⇒ R (EL n ls) (EL (SUC n) ls)

   [<a name="SORTED_EQ-val"><b>SORTED_EQ</b></a>]  Theorem

      |- ∀R L x.
           transitive R ⇒
           (SORTED R (x::L) ⇔ SORTED R L ∧ ∀y. MEM y L ⇒ R x y)

   [<a name="SORTED_EQ_PART-val"><b>SORTED_EQ_PART</b></a>]  Theorem

      |- ∀l R. transitive R ⇒ SORTED R (FILTER (λx. R x hd ∧ R hd x) l)

   [<a name="SORTED_IND-val"><b>SORTED_IND</b></a>]  Theorem

      |- ∀P.
           (∀R. P R []) ∧ (∀R x. P R [x]) ∧
           (∀R x y rst. P R (y::rst) ⇒ P R (x::y::rst)) ⇒
           ∀v v1. P v v1

   [<a name="SORTED_NIL-val"><b>SORTED_NIL</b></a>]  Theorem

      |- ∀R. SORTED R []

   [<a name="SORTED_PERM_EQ-val"><b>SORTED_PERM_EQ</b></a>]  Theorem

      |- ∀R.
           transitive R ∧ antisymmetric R ⇒
           ∀l1 l2. SORTED R l1 ∧ SORTED R l2 ∧ PERM l1 l2 ⇒ (l1 = l2)

   [<a name="SORTED_SING-val"><b>SORTED_SING</b></a>]  Theorem

      |- ∀R x. SORTED R [x]

   [<a name="SORTED_transitive_APPEND_IFF-val"><b>SORTED_transitive_APPEND_IFF</b></a>]  Theorem

      |- ∀R.
           transitive R ⇒
           ∀L1 L2.
             SORTED R (L1 ++ L2) ⇔
             SORTED R L1 ∧ SORTED R L2 ∧
             ((L1 = []) ∨ (L2 = []) ∨ R (LAST L1) (HD L2))

   [<a name="SUM_IMAGE_count_MULT-val"><b>SUM_IMAGE_count_MULT</b></a>]  Theorem

      |- (∀m. m &lt; n ⇒ (g m = ∑ (λx. f (x + k * m)) (count k))) ⇒
         (∑ f (count (k * n)) = ∑ g (count n))

   [<a name="SUM_IMAGE_count_SUM_GENLIST-val"><b>SUM_IMAGE_count_SUM_GENLIST</b></a>]  Theorem

      |- ∑ f (count n) = SUM (GENLIST f n)

   [<a name="sum_of_sums-val"><b>sum_of_sums</b></a>]  Theorem

      |- ∑ (λm. ∑ (f m) (count a)) (count b) =
         ∑ (λm. f (m DIV a) (m MOD a)) (count (a * b))


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/sort/sortingScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-9</a></em></p></body></html>
