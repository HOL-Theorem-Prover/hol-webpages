<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure listTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure listTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/list/src/listScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature listTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#ALL_DISTINCT-val">ALL_DISTINCT</a> : thm
<a name="line7"></a>    val <a href="#APPEND-val">APPEND</a> : thm
<a name="line8"></a>    val <a href="#DROP_def-val">DROP_def</a> : thm
<a name="line9"></a>    val <a href="#EL-val">EL</a> : thm
<a name="line10"></a>    val <a href="#EVERY_DEF-val">EVERY_DEF</a> : thm
<a name="line11"></a>    val <a href="#EVERYi_DEF-val">EVERYi_DEF</a> : thm
<a name="line12"></a>    val <a href="#EXISTS_DEF-val">EXISTS_DEF</a> : thm
<a name="line13"></a>    val <a href="#FILTER-val">FILTER</a> : thm
<a name="line14"></a>    val <a href="#FLAT-val">FLAT</a> : thm
<a name="line15"></a>    val <a href="#FOLDL-val">FOLDL</a> : thm
<a name="line16"></a>    val <a href="#FOLDR-val">FOLDR</a> : thm
<a name="line17"></a>    val <a href="#FRONT_DEF-val">FRONT_DEF</a> : thm
<a name="line18"></a>    val <a href="#GENLIST-val">GENLIST</a> : thm
<a name="line19"></a>    val <a href="#GENLIST_AUX-val">GENLIST_AUX</a> : thm
<a name="line20"></a>    val <a href="#HD-val">HD</a> : thm
<a name="line21"></a>    val <a href="#LAST_DEF-val">LAST_DEF</a> : thm
<a name="line22"></a>    val <a href="#LENGTH-val">LENGTH</a> : thm
<a name="line23"></a>    val <a href="#LEN_DEF-val">LEN_DEF</a> : thm
<a name="line24"></a>    val <a href="#LIST_TO_SET_DEF-val">LIST_TO_SET_DEF</a> : thm
<a name="line25"></a>    val <a href="#LRC_def-val">LRC_def</a> : thm
<a name="line26"></a>    val <a href="#LUPDATE_def-val">LUPDATE_def</a> : thm
<a name="line27"></a>    val <a href="#MAP-val">MAP</a> : thm
<a name="line28"></a>    val <a href="#NULL_DEF-val">NULL_DEF</a> : thm
<a name="line29"></a>    val <a href="#PAD_LEFT-val">PAD_LEFT</a> : thm
<a name="line30"></a>    val <a href="#PAD_RIGHT-val">PAD_RIGHT</a> : thm
<a name="line31"></a>    val <a href="#REVERSE_DEF-val">REVERSE_DEF</a> : thm
<a name="line32"></a>    val <a href="#REV_DEF-val">REV_DEF</a> : thm
<a name="line33"></a>    val <a href="#SET_TO_LIST_primitive-val">SET_TO_LIST_primitive</a> : thm
<a name="line34"></a>    val <a href="#SNOC-val">SNOC</a> : thm
<a name="line35"></a>    val <a href="#SUM-val">SUM</a> : thm
<a name="line36"></a>    val <a href="#SUM_ACC_DEF-val">SUM_ACC_DEF</a> : thm
<a name="line37"></a>    val <a href="#TAKE_def-val">TAKE_def</a> : thm
<a name="line38"></a>    val <a href="#TL-val">TL</a> : thm
<a name="line39"></a>    val <a href="#UNZIP-val">UNZIP</a> : thm
<a name="line40"></a>    val <a href="#ZIP-val">ZIP</a> : thm
<a name="line41"></a>    val <a href="#isPREFIX-val">isPREFIX</a> : thm
<a name="line42"></a>    val <a href="#list_TY_DEF-val">list_TY_DEF</a> : thm
<a name="line43"></a>    val <a href="#list_case_def-val">list_case_def</a> : thm
<a name="line44"></a>    val <a href="#list_size_def-val">list_size_def</a> : thm
<a name="line45"></a>    val <a href="#splitAtPki_DEF-val">splitAtPki_DEF</a> : thm
<a name="line46"></a>
<a name="line47"></a>  (*  Theorems  *)
<a name="line48"></a>    val <a href="#ALL_DISTINCT_APPEND-val">ALL_DISTINCT_APPEND</a> : thm
<a name="line49"></a>    val <a href="#ALL_DISTINCT_CARD_LIST_TO_SET-val">ALL_DISTINCT_CARD_LIST_TO_SET</a> : thm
<a name="line50"></a>    val <a href="#ALL_DISTINCT_EL_IMP-val">ALL_DISTINCT_EL_IMP</a> : thm
<a name="line51"></a>    val <a href="#ALL_DISTINCT_FILTER-val">ALL_DISTINCT_FILTER</a> : thm
<a name="line52"></a>    val <a href="#ALL_DISTINCT_GENLIST-val">ALL_DISTINCT_GENLIST</a> : thm
<a name="line53"></a>    val <a href="#ALL_DISTINCT_MAP-val">ALL_DISTINCT_MAP</a> : thm
<a name="line54"></a>    val <a href="#ALL_DISTINCT_REVERSE-val">ALL_DISTINCT_REVERSE</a> : thm
<a name="line55"></a>    val <a href="#ALL_DISTINCT_SET_TO_LIST-val">ALL_DISTINCT_SET_TO_LIST</a> : thm
<a name="line56"></a>    val <a href="#ALL_DISTINCT_SING-val">ALL_DISTINCT_SING</a> : thm
<a name="line57"></a>    val <a href="#ALL_DISTINCT_SNOC-val">ALL_DISTINCT_SNOC</a> : thm
<a name="line58"></a>    val <a href="#ALL_DISTINCT_ZIP-val">ALL_DISTINCT_ZIP</a> : thm
<a name="line59"></a>    val <a href="#ALL_DISTINCT_ZIP_SWAP-val">ALL_DISTINCT_ZIP_SWAP</a> : thm
<a name="line60"></a>    val <a href="#APPEND_11-val">APPEND_11</a> : thm
<a name="line61"></a>    val <a href="#APPEND_11_LENGTH-val">APPEND_11_LENGTH</a> : thm
<a name="line62"></a>    val <a href="#APPEND_ASSOC-val">APPEND_ASSOC</a> : thm
<a name="line63"></a>    val <a href="#APPEND_EQ_APPEND-val">APPEND_EQ_APPEND</a> : thm
<a name="line64"></a>    val <a href="#APPEND_EQ_APPEND_MID-val">APPEND_EQ_APPEND_MID</a> : thm
<a name="line65"></a>    val <a href="#APPEND_EQ_CONS-val">APPEND_EQ_CONS</a> : thm
<a name="line66"></a>    val <a href="#APPEND_EQ_SELF-val">APPEND_EQ_SELF</a> : thm
<a name="line67"></a>    val <a href="#APPEND_EQ_SING-val">APPEND_EQ_SING</a> : thm
<a name="line68"></a>    val <a href="#APPEND_FRONT_LAST-val">APPEND_FRONT_LAST</a> : thm
<a name="line69"></a>    val <a href="#APPEND_LENGTH_EQ-val">APPEND_LENGTH_EQ</a> : thm
<a name="line70"></a>    val <a href="#APPEND_NIL-val">APPEND_NIL</a> : thm
<a name="line71"></a>    val <a href="#APPEND_SNOC-val">APPEND_SNOC</a> : thm
<a name="line72"></a>    val <a href="#APPEND_eq_NIL-val">APPEND_eq_NIL</a> : thm
<a name="line73"></a>    val <a href="#CARD_LIST_TO_SET-val">CARD_LIST_TO_SET</a> : thm
<a name="line74"></a>    val <a href="#CONS-val">CONS</a> : thm
<a name="line75"></a>    val <a href="#CONS_11-val">CONS_11</a> : thm
<a name="line76"></a>    val <a href="#CONS_ACYCLIC-val">CONS_ACYCLIC</a> : thm
<a name="line77"></a>    val <a href="#DROP_0-val">DROP_0</a> : thm
<a name="line78"></a>    val <a href="#DROP_LENGTH_TOO_LONG-val">DROP_LENGTH_TOO_LONG</a> : thm
<a name="line79"></a>    val <a href="#DROP_NIL-val">DROP_NIL</a> : thm
<a name="line80"></a>    val <a href="#DROP_compute-val">DROP_compute</a> : thm
<a name="line81"></a>    val <a href="#DROP_splitAtPki-val">DROP_splitAtPki</a> : thm
<a name="line82"></a>    val <a href="#EL_ALL_DISTINCT_EL_EQ-val">EL_ALL_DISTINCT_EL_EQ</a> : thm
<a name="line83"></a>    val <a href="#EL_GENLIST-val">EL_GENLIST</a> : thm
<a name="line84"></a>    val <a href="#EL_LENGTH_SNOC-val">EL_LENGTH_SNOC</a> : thm
<a name="line85"></a>    val <a href="#EL_LUPDATE-val">EL_LUPDATE</a> : thm
<a name="line86"></a>    val <a href="#EL_MAP-val">EL_MAP</a> : thm
<a name="line87"></a>    val <a href="#EL_REVERSE-val">EL_REVERSE</a> : thm
<a name="line88"></a>    val <a href="#EL_SNOC-val">EL_SNOC</a> : thm
<a name="line89"></a>    val <a href="#EL_ZIP-val">EL_ZIP</a> : thm
<a name="line90"></a>    val <a href="#EL_compute-val">EL_compute</a> : thm
<a name="line91"></a>    val <a href="#EL_restricted-val">EL_restricted</a> : thm
<a name="line92"></a>    val <a href="#EL_simp-val">EL_simp</a> : thm
<a name="line93"></a>    val <a href="#EL_simp_restricted-val">EL_simp_restricted</a> : thm
<a name="line94"></a>    val <a href="#EQ_LIST-val">EQ_LIST</a> : thm
<a name="line95"></a>    val <a href="#EVERY2_EVERY-val">EVERY2_EVERY</a> : thm
<a name="line96"></a>    val <a href="#EVERY2_LENGTH-val">EVERY2_LENGTH</a> : thm
<a name="line97"></a>    val <a href="#EVERY2_cong-val">EVERY2_cong</a> : thm
<a name="line98"></a>    val <a href="#EVERY2_mono-val">EVERY2_mono</a> : thm
<a name="line99"></a>    val <a href="#EVERY_APPEND-val">EVERY_APPEND</a> : thm
<a name="line100"></a>    val <a href="#EVERY_CONG-val">EVERY_CONG</a> : thm
<a name="line101"></a>    val <a href="#EVERY_CONJ-val">EVERY_CONJ</a> : thm
<a name="line102"></a>    val <a href="#EVERY_EL-val">EVERY_EL</a> : thm
<a name="line103"></a>    val <a href="#EVERY_FILTER-val">EVERY_FILTER</a> : thm
<a name="line104"></a>    val <a href="#EVERY_FILTER_IMP-val">EVERY_FILTER_IMP</a> : thm
<a name="line105"></a>    val <a href="#EVERY_GENLIST-val">EVERY_GENLIST</a> : thm
<a name="line106"></a>    val <a href="#EVERY_MAP-val">EVERY_MAP</a> : thm
<a name="line107"></a>    val <a href="#EVERY_MEM-val">EVERY_MEM</a> : thm
<a name="line108"></a>    val <a href="#EVERY_MONOTONIC-val">EVERY_MONOTONIC</a> : thm
<a name="line109"></a>    val <a href="#EVERY_NOT_EXISTS-val">EVERY_NOT_EXISTS</a> : thm
<a name="line110"></a>    val <a href="#EVERY_SIMP-val">EVERY_SIMP</a> : thm
<a name="line111"></a>    val <a href="#EVERY_SNOC-val">EVERY_SNOC</a> : thm
<a name="line112"></a>    val <a href="#EXISTS_APPEND-val">EXISTS_APPEND</a> : thm
<a name="line113"></a>    val <a href="#EXISTS_CONG-val">EXISTS_CONG</a> : thm
<a name="line114"></a>    val <a href="#EXISTS_GENLIST-val">EXISTS_GENLIST</a> : thm
<a name="line115"></a>    val <a href="#EXISTS_LIST-val">EXISTS_LIST</a> : thm
<a name="line116"></a>    val <a href="#EXISTS_MAP-val">EXISTS_MAP</a> : thm
<a name="line117"></a>    val <a href="#EXISTS_MEM-val">EXISTS_MEM</a> : thm
<a name="line118"></a>    val <a href="#EXISTS_NOT_EVERY-val">EXISTS_NOT_EVERY</a> : thm
<a name="line119"></a>    val <a href="#EXISTS_SIMP-val">EXISTS_SIMP</a> : thm
<a name="line120"></a>    val <a href="#EXISTS_SNOC-val">EXISTS_SNOC</a> : thm
<a name="line121"></a>    val <a href="#FILTER_ALL_DISTINCT-val">FILTER_ALL_DISTINCT</a> : thm
<a name="line122"></a>    val <a href="#FILTER_APPEND_DISTRIB-val">FILTER_APPEND_DISTRIB</a> : thm
<a name="line123"></a>    val <a href="#FILTER_COND_REWRITE-val">FILTER_COND_REWRITE</a> : thm
<a name="line124"></a>    val <a href="#FILTER_EQ_APPEND-val">FILTER_EQ_APPEND</a> : thm
<a name="line125"></a>    val <a href="#FILTER_EQ_CONS-val">FILTER_EQ_CONS</a> : thm
<a name="line126"></a>    val <a href="#FILTER_EQ_ID-val">FILTER_EQ_ID</a> : thm
<a name="line127"></a>    val <a href="#FILTER_EQ_NIL-val">FILTER_EQ_NIL</a> : thm
<a name="line128"></a>    val <a href="#FILTER_NEQ_ID-val">FILTER_NEQ_ID</a> : thm
<a name="line129"></a>    val <a href="#FILTER_NEQ_NIL-val">FILTER_NEQ_NIL</a> : thm
<a name="line130"></a>    val <a href="#FILTER_REVERSE-val">FILTER_REVERSE</a> : thm
<a name="line131"></a>    val <a href="#FINITE_LIST_TO_SET-val">FINITE_LIST_TO_SET</a> : thm
<a name="line132"></a>    val <a href="#FLAT_APPEND-val">FLAT_APPEND</a> : thm
<a name="line133"></a>    val <a href="#FOLDL2_FOLDL-val">FOLDL2_FOLDL</a> : thm
<a name="line134"></a>    val <a href="#FOLDL2_cong-val">FOLDL2_cong</a> : thm
<a name="line135"></a>    val <a href="#FOLDL2_def-val">FOLDL2_def</a> : thm
<a name="line136"></a>    val <a href="#FOLDL2_ind-val">FOLDL2_ind</a> : thm
<a name="line137"></a>    val <a href="#FOLDL_CONG-val">FOLDL_CONG</a> : thm
<a name="line138"></a>    val <a href="#FOLDL_EQ_FOLDR-val">FOLDL_EQ_FOLDR</a> : thm
<a name="line139"></a>    val <a href="#FOLDL_SNOC-val">FOLDL_SNOC</a> : thm
<a name="line140"></a>    val <a href="#FOLDL_UNION_BIGUNION-val">FOLDL_UNION_BIGUNION</a> : thm
<a name="line141"></a>    val <a href="#FOLDL_UNION_BIGUNION_paired-val">FOLDL_UNION_BIGUNION_paired</a> : thm
<a name="line142"></a>    val <a href="#FOLDL_ZIP_SAME-val">FOLDL_ZIP_SAME</a> : thm
<a name="line143"></a>    val <a href="#FOLDR_CONG-val">FOLDR_CONG</a> : thm
<a name="line144"></a>    val <a href="#FOLDR_CONS-val">FOLDR_CONS</a> : thm
<a name="line145"></a>    val <a href="#FORALL_LIST-val">FORALL_LIST</a> : thm
<a name="line146"></a>    val <a href="#FRONT_CONS-val">FRONT_CONS</a> : thm
<a name="line147"></a>    val <a href="#FRONT_CONS_EQ_NIL-val">FRONT_CONS_EQ_NIL</a> : thm
<a name="line148"></a>    val <a href="#FRONT_SNOC-val">FRONT_SNOC</a> : thm
<a name="line149"></a>    val <a href="#GENLIST_APPEND-val">GENLIST_APPEND</a> : thm
<a name="line150"></a>    val <a href="#GENLIST_AUX_compute-val">GENLIST_AUX_compute</a> : thm
<a name="line151"></a>    val <a href="#GENLIST_CONS-val">GENLIST_CONS</a> : thm
<a name="line152"></a>    val <a href="#GENLIST_FUN_EQ-val">GENLIST_FUN_EQ</a> : thm
<a name="line153"></a>    val <a href="#GENLIST_GENLIST_AUX-val">GENLIST_GENLIST_AUX</a> : thm
<a name="line154"></a>    val <a href="#GENLIST_NUMERALS-val">GENLIST_NUMERALS</a> : thm
<a name="line155"></a>    val <a href="#HD_GENLIST-val">HD_GENLIST</a> : thm
<a name="line156"></a>    val <a href="#HD_GENLIST_COR-val">HD_GENLIST_COR</a> : thm
<a name="line157"></a>    val <a href="#INFINITE_LIST_UNIV-val">INFINITE_LIST_UNIV</a> : thm
<a name="line158"></a>    val <a href="#INJ_MAP_EQ-val">INJ_MAP_EQ</a> : thm
<a name="line159"></a>    val <a href="#IN_LIST_TO_SET-val">IN_LIST_TO_SET</a> : thm
<a name="line160"></a>    val <a href="#ITSET_eq_FOLDL_SET_TO_LIST-val">ITSET_eq_FOLDL_SET_TO_LIST</a> : thm
<a name="line161"></a>    val <a href="#LAST_APPEND_CONS-val">LAST_APPEND_CONS</a> : thm
<a name="line162"></a>    val <a href="#LAST_CONS-val">LAST_CONS</a> : thm
<a name="line163"></a>    val <a href="#LAST_CONS_cond-val">LAST_CONS_cond</a> : thm
<a name="line164"></a>    val <a href="#LAST_EL-val">LAST_EL</a> : thm
<a name="line165"></a>    val <a href="#LAST_SNOC-val">LAST_SNOC</a> : thm
<a name="line166"></a>    val <a href="#LAST_compute-val">LAST_compute</a> : thm
<a name="line167"></a>    val <a href="#LENGTH_APPEND-val">LENGTH_APPEND</a> : thm
<a name="line168"></a>    val <a href="#LENGTH_CONS-val">LENGTH_CONS</a> : thm
<a name="line169"></a>    val <a href="#LENGTH_DROP-val">LENGTH_DROP</a> : thm
<a name="line170"></a>    val <a href="#LENGTH_EQ_CONS-val">LENGTH_EQ_CONS</a> : thm
<a name="line171"></a>    val <a href="#LENGTH_EQ_NIL-val">LENGTH_EQ_NIL</a> : thm
<a name="line172"></a>    val <a href="#LENGTH_EQ_NUM-val">LENGTH_EQ_NUM</a> : thm
<a name="line173"></a>    val <a href="#LENGTH_EQ_NUM_compute-val">LENGTH_EQ_NUM_compute</a> : thm
<a name="line174"></a>    val <a href="#LENGTH_EQ_SUM-val">LENGTH_EQ_SUM</a> : thm
<a name="line175"></a>    val <a href="#LENGTH_FRONT_CONS-val">LENGTH_FRONT_CONS</a> : thm
<a name="line176"></a>    val <a href="#LENGTH_GENLIST-val">LENGTH_GENLIST</a> : thm
<a name="line177"></a>    val <a href="#LENGTH_LEN-val">LENGTH_LEN</a> : thm
<a name="line178"></a>    val <a href="#LENGTH_LUPDATE-val">LENGTH_LUPDATE</a> : thm
<a name="line179"></a>    val <a href="#LENGTH_MAP-val">LENGTH_MAP</a> : thm
<a name="line180"></a>    val <a href="#LENGTH_NIL-val">LENGTH_NIL</a> : thm
<a name="line181"></a>    val <a href="#LENGTH_NIL_SYM-val">LENGTH_NIL_SYM</a> : thm
<a name="line182"></a>    val <a href="#LENGTH_REVERSE-val">LENGTH_REVERSE</a> : thm
<a name="line183"></a>    val <a href="#LENGTH_SNOC-val">LENGTH_SNOC</a> : thm
<a name="line184"></a>    val <a href="#LENGTH_TAKE-val">LENGTH_TAKE</a> : thm
<a name="line185"></a>    val <a href="#LENGTH_TL-val">LENGTH_TL</a> : thm
<a name="line186"></a>    val <a href="#LENGTH_UNZIP-val">LENGTH_UNZIP</a> : thm
<a name="line187"></a>    val <a href="#LENGTH_ZIP-val">LENGTH_ZIP</a> : thm
<a name="line188"></a>    val <a href="#LEN_LENGTH_LEM-val">LEN_LENGTH_LEM</a> : thm
<a name="line189"></a>    val <a href="#LIST_EQ-val">LIST_EQ</a> : thm
<a name="line190"></a>    val <a href="#LIST_EQ_REWRITE-val">LIST_EQ_REWRITE</a> : thm
<a name="line191"></a>    val <a href="#LIST_NOT_EQ-val">LIST_NOT_EQ</a> : thm
<a name="line192"></a>    val <a href="#LIST_REL_CONJ-val">LIST_REL_CONJ</a> : thm
<a name="line193"></a>    val <a href="#LIST_REL_CONS1-val">LIST_REL_CONS1</a> : thm
<a name="line194"></a>    val <a href="#LIST_REL_CONS2-val">LIST_REL_CONS2</a> : thm
<a name="line195"></a>    val <a href="#LIST_REL_EL_EQN-val">LIST_REL_EL_EQN</a> : thm
<a name="line196"></a>    val <a href="#LIST_REL_EVERY_ZIP-val">LIST_REL_EVERY_ZIP</a> : thm
<a name="line197"></a>    val <a href="#LIST_REL_LENGTH-val">LIST_REL_LENGTH</a> : thm
<a name="line198"></a>    val <a href="#LIST_REL_MAP1-val">LIST_REL_MAP1</a> : thm
<a name="line199"></a>    val <a href="#LIST_REL_MAP2-val">LIST_REL_MAP2</a> : thm
<a name="line200"></a>    val <a href="#LIST_REL_NIL-val">LIST_REL_NIL</a> : thm
<a name="line201"></a>    val <a href="#LIST_REL_cases-val">LIST_REL_cases</a> : thm
<a name="line202"></a>    val <a href="#LIST_REL_def-val">LIST_REL_def</a> : thm
<a name="line203"></a>    val <a href="#LIST_REL_ind-val">LIST_REL_ind</a> : thm
<a name="line204"></a>    val <a href="#LIST_REL_mono-val">LIST_REL_mono</a> : thm
<a name="line205"></a>    val <a href="#LIST_REL_rules-val">LIST_REL_rules</a> : thm
<a name="line206"></a>    val <a href="#LIST_REL_strongind-val">LIST_REL_strongind</a> : thm
<a name="line207"></a>    val <a href="#LIST_TO_SET-val">LIST_TO_SET</a> : thm
<a name="line208"></a>    val <a href="#LIST_TO_SET_APPEND-val">LIST_TO_SET_APPEND</a> : thm
<a name="line209"></a>    val <a href="#LIST_TO_SET_EQ_EMPTY-val">LIST_TO_SET_EQ_EMPTY</a> : thm
<a name="line210"></a>    val <a href="#LIST_TO_SET_FILTER-val">LIST_TO_SET_FILTER</a> : thm
<a name="line211"></a>    val <a href="#LIST_TO_SET_MAP-val">LIST_TO_SET_MAP</a> : thm
<a name="line212"></a>    val <a href="#LIST_TO_SET_REVERSE-val">LIST_TO_SET_REVERSE</a> : thm
<a name="line213"></a>    val <a href="#LIST_TO_SET_SNOC-val">LIST_TO_SET_SNOC</a> : thm
<a name="line214"></a>    val <a href="#LIST_TO_SET_THM-val">LIST_TO_SET_THM</a> : thm
<a name="line215"></a>    val <a href="#LRC_MEM-val">LRC_MEM</a> : thm
<a name="line216"></a>    val <a href="#LRC_MEM_right-val">LRC_MEM_right</a> : thm
<a name="line217"></a>    val <a href="#LUPDATE_LENGTH-val">LUPDATE_LENGTH</a> : thm
<a name="line218"></a>    val <a href="#LUPDATE_SEM-val">LUPDATE_SEM</a> : thm
<a name="line219"></a>    val <a href="#LUPDATE_SNOC-val">LUPDATE_SNOC</a> : thm
<a name="line220"></a>    val <a href="#LUPDATE_compute-val">LUPDATE_compute</a> : thm
<a name="line221"></a>    val <a href="#MAP2-val">MAP2</a> : thm
<a name="line222"></a>    val <a href="#MAP2_CONG-val">MAP2_CONG</a> : thm
<a name="line223"></a>    val <a href="#MAP2_MAP-val">MAP2_MAP</a> : thm
<a name="line224"></a>    val <a href="#MAP2_ZIP-val">MAP2_ZIP</a> : thm
<a name="line225"></a>    val <a href="#MAP2_def-val">MAP2_def</a> : thm
<a name="line226"></a>    val <a href="#MAP2_ind-val">MAP2_ind</a> : thm
<a name="line227"></a>    val <a href="#MAP_APPEND-val">MAP_APPEND</a> : thm
<a name="line228"></a>    val <a href="#MAP_CONG-val">MAP_CONG</a> : thm
<a name="line229"></a>    val <a href="#MAP_EQ_EVERY2-val">MAP_EQ_EVERY2</a> : thm
<a name="line230"></a>    val <a href="#MAP_EQ_NIL-val">MAP_EQ_NIL</a> : thm
<a name="line231"></a>    val <a href="#MAP_EQ_f-val">MAP_EQ_f</a> : thm
<a name="line232"></a>    val <a href="#MAP_GENLIST-val">MAP_GENLIST</a> : thm
<a name="line233"></a>    val <a href="#MAP_ID-val">MAP_ID</a> : thm
<a name="line234"></a>    val <a href="#MAP_MAP_o-val">MAP_MAP_o</a> : thm
<a name="line235"></a>    val <a href="#MAP_SNOC-val">MAP_SNOC</a> : thm
<a name="line236"></a>    val <a href="#MAP_TL-val">MAP_TL</a> : thm
<a name="line237"></a>    val <a href="#MAP_ZIP-val">MAP_ZIP</a> : thm
<a name="line238"></a>    val <a href="#MAP_ZIP_SAME-val">MAP_ZIP_SAME</a> : thm
<a name="line239"></a>    val <a href="#MAP_o-val">MAP_o</a> : thm
<a name="line240"></a>    val <a href="#MEM-val">MEM</a> : thm
<a name="line241"></a>    val <a href="#MEM_APPEND-val">MEM_APPEND</a> : thm
<a name="line242"></a>    val <a href="#MEM_DROP-val">MEM_DROP</a> : thm
<a name="line243"></a>    val <a href="#MEM_EL-val">MEM_EL</a> : thm
<a name="line244"></a>    val <a href="#MEM_FILTER-val">MEM_FILTER</a> : thm
<a name="line245"></a>    val <a href="#MEM_FLAT-val">MEM_FLAT</a> : thm
<a name="line246"></a>    val <a href="#MEM_GENLIST-val">MEM_GENLIST</a> : thm
<a name="line247"></a>    val <a href="#MEM_LUPDATE-val">MEM_LUPDATE</a> : thm
<a name="line248"></a>    val <a href="#MEM_LUPDATE_E-val">MEM_LUPDATE_E</a> : thm
<a name="line249"></a>    val <a href="#MEM_MAP-val">MEM_MAP</a> : thm
<a name="line250"></a>    val <a href="#MEM_REVERSE-val">MEM_REVERSE</a> : thm
<a name="line251"></a>    val <a href="#MEM_SET_TO_LIST-val">MEM_SET_TO_LIST</a> : thm
<a name="line252"></a>    val <a href="#MEM_SNOC-val">MEM_SNOC</a> : thm
<a name="line253"></a>    val <a href="#MEM_SPLIT-val">MEM_SPLIT</a> : thm
<a name="line254"></a>    val <a href="#MEM_SPLIT_APPEND_first-val">MEM_SPLIT_APPEND_first</a> : thm
<a name="line255"></a>    val <a href="#MEM_SPLIT_APPEND_last-val">MEM_SPLIT_APPEND_last</a> : thm
<a name="line256"></a>    val <a href="#MEM_ZIP-val">MEM_ZIP</a> : thm
<a name="line257"></a>    val <a href="#MONO_EVERY-val">MONO_EVERY</a> : thm
<a name="line258"></a>    val <a href="#MONO_EXISTS-val">MONO_EXISTS</a> : thm
<a name="line259"></a>    val <a href="#NOT_CONS_NIL-val">NOT_CONS_NIL</a> : thm
<a name="line260"></a>    val <a href="#NOT_EQ_LIST-val">NOT_EQ_LIST</a> : thm
<a name="line261"></a>    val <a href="#NOT_EVERY-val">NOT_EVERY</a> : thm
<a name="line262"></a>    val <a href="#NOT_EXISTS-val">NOT_EXISTS</a> : thm
<a name="line263"></a>    val <a href="#NOT_NIL_CONS-val">NOT_NIL_CONS</a> : thm
<a name="line264"></a>    val <a href="#NOT_NULL_MEM-val">NOT_NULL_MEM</a> : thm
<a name="line265"></a>    val <a href="#NRC_LRC-val">NRC_LRC</a> : thm
<a name="line266"></a>    val <a href="#NULL-val">NULL</a> : thm
<a name="line267"></a>    val <a href="#NULL_EQ-val">NULL_EQ</a> : thm
<a name="line268"></a>    val <a href="#NULL_FILTER-val">NULL_FILTER</a> : thm
<a name="line269"></a>    val <a href="#NULL_GENLIST-val">NULL_GENLIST</a> : thm
<a name="line270"></a>    val <a href="#NULL_LENGTH-val">NULL_LENGTH</a> : thm
<a name="line271"></a>    val <a href="#REVERSE_11-val">REVERSE_11</a> : thm
<a name="line272"></a>    val <a href="#REVERSE_APPEND-val">REVERSE_APPEND</a> : thm
<a name="line273"></a>    val <a href="#REVERSE_EQ_NIL-val">REVERSE_EQ_NIL</a> : thm
<a name="line274"></a>    val <a href="#REVERSE_EQ_SING-val">REVERSE_EQ_SING</a> : thm
<a name="line275"></a>    val <a href="#REVERSE_GENLIST-val">REVERSE_GENLIST</a> : thm
<a name="line276"></a>    val <a href="#REVERSE_REV-val">REVERSE_REV</a> : thm
<a name="line277"></a>    val <a href="#REVERSE_REVERSE-val">REVERSE_REVERSE</a> : thm
<a name="line278"></a>    val <a href="#REVERSE_SNOC-val">REVERSE_SNOC</a> : thm
<a name="line279"></a>    val <a href="#REVERSE_SNOC_DEF-val">REVERSE_SNOC_DEF</a> : thm
<a name="line280"></a>    val <a href="#REV_REVERSE_LEM-val">REV_REVERSE_LEM</a> : thm
<a name="line281"></a>    val <a href="#SET_TO_LIST_CARD-val">SET_TO_LIST_CARD</a> : thm
<a name="line282"></a>    val <a href="#SET_TO_LIST_EMPTY-val">SET_TO_LIST_EMPTY</a> : thm
<a name="line283"></a>    val <a href="#SET_TO_LIST_IND-val">SET_TO_LIST_IND</a> : thm
<a name="line284"></a>    val <a href="#SET_TO_LIST_INV-val">SET_TO_LIST_INV</a> : thm
<a name="line285"></a>    val <a href="#SET_TO_LIST_IN_MEM-val">SET_TO_LIST_IN_MEM</a> : thm
<a name="line286"></a>    val <a href="#SET_TO_LIST_SING-val">SET_TO_LIST_SING</a> : thm
<a name="line287"></a>    val <a href="#SET_TO_LIST_THM-val">SET_TO_LIST_THM</a> : thm
<a name="line288"></a>    val <a href="#SNOC_11-val">SNOC_11</a> : thm
<a name="line289"></a>    val <a href="#SNOC_APPEND-val">SNOC_APPEND</a> : thm
<a name="line290"></a>    val <a href="#SNOC_Axiom-val">SNOC_Axiom</a> : thm
<a name="line291"></a>    val <a href="#SNOC_CASES-val">SNOC_CASES</a> : thm
<a name="line292"></a>    val <a href="#SNOC_INDUCT-val">SNOC_INDUCT</a> : thm
<a name="line293"></a>    val <a href="#SUM_ACC_SUM_LEM-val">SUM_ACC_SUM_LEM</a> : thm
<a name="line294"></a>    val <a href="#SUM_APPEND-val">SUM_APPEND</a> : thm
<a name="line295"></a>    val <a href="#SUM_IMAGE_LIST_TO_SET_upper_bound-val">SUM_IMAGE_LIST_TO_SET_upper_bound</a> : thm
<a name="line296"></a>    val <a href="#SUM_IMAGE_eq_SUM_MAP_SET_TO_LIST-val">SUM_IMAGE_eq_SUM_MAP_SET_TO_LIST</a> : thm
<a name="line297"></a>    val <a href="#SUM_MAP_FOLDL-val">SUM_MAP_FOLDL</a> : thm
<a name="line298"></a>    val <a href="#SUM_MAP_MEM_bound-val">SUM_MAP_MEM_bound</a> : thm
<a name="line299"></a>    val <a href="#SUM_MAP_PLUS_ZIP-val">SUM_MAP_PLUS_ZIP</a> : thm
<a name="line300"></a>    val <a href="#SUM_SNOC-val">SUM_SNOC</a> : thm
<a name="line301"></a>    val <a href="#SUM_SUM_ACC-val">SUM_SUM_ACC</a> : thm
<a name="line302"></a>    val <a href="#SUM_eq_0-val">SUM_eq_0</a> : thm
<a name="line303"></a>    val <a href="#TAKE_0-val">TAKE_0</a> : thm
<a name="line304"></a>    val <a href="#TAKE_APPEND1-val">TAKE_APPEND1</a> : thm
<a name="line305"></a>    val <a href="#TAKE_APPEND2-val">TAKE_APPEND2</a> : thm
<a name="line306"></a>    val <a href="#TAKE_DROP-val">TAKE_DROP</a> : thm
<a name="line307"></a>    val <a href="#TAKE_LENGTH_ID-val">TAKE_LENGTH_ID</a> : thm
<a name="line308"></a>    val <a href="#TAKE_LENGTH_TOO_LONG-val">TAKE_LENGTH_TOO_LONG</a> : thm
<a name="line309"></a>    val <a href="#TAKE_compute-val">TAKE_compute</a> : thm
<a name="line310"></a>    val <a href="#TAKE_splitAtPki-val">TAKE_splitAtPki</a> : thm
<a name="line311"></a>    val <a href="#TL_GENLIST-val">TL_GENLIST</a> : thm
<a name="line312"></a>    val <a href="#UNION_APPEND-val">UNION_APPEND</a> : thm
<a name="line313"></a>    val <a href="#UNZIP_MAP-val">UNZIP_MAP</a> : thm
<a name="line314"></a>    val <a href="#UNZIP_THM-val">UNZIP_THM</a> : thm
<a name="line315"></a>    val <a href="#UNZIP_ZIP-val">UNZIP_ZIP</a> : thm
<a name="line316"></a>    val <a href="#WF_LIST_PRED-val">WF_LIST_PRED</a> : thm
<a name="line317"></a>    val <a href="#ZIP_GENLIST-val">ZIP_GENLIST</a> : thm
<a name="line318"></a>    val <a href="#ZIP_MAP-val">ZIP_MAP</a> : thm
<a name="line319"></a>    val <a href="#ZIP_UNZIP-val">ZIP_UNZIP</a> : thm
<a name="line320"></a>    val <a href="#datatype_list-val">datatype_list</a> : thm
<a name="line321"></a>    val <a href="#isPREFIX_THM-val">isPREFIX_THM</a> : thm
<a name="line322"></a>    val <a href="#list_11-val">list_11</a> : thm
<a name="line323"></a>    val <a href="#list_Axiom-val">list_Axiom</a> : thm
<a name="line324"></a>    val <a href="#list_Axiom_old-val">list_Axiom_old</a> : thm
<a name="line325"></a>    val <a href="#list_CASES-val">list_CASES</a> : thm
<a name="line326"></a>    val <a href="#list_INDUCT-val">list_INDUCT</a> : thm
<a name="line327"></a>    val <a href="#list_case_compute-val">list_case_compute</a> : thm
<a name="line328"></a>    val <a href="#list_case_cong-val">list_case_cong</a> : thm
<a name="line329"></a>    val <a href="#list_distinct-val">list_distinct</a> : thm
<a name="line330"></a>    val <a href="#list_induction-val">list_induction</a> : thm
<a name="line331"></a>    val <a href="#list_nchotomy-val">list_nchotomy</a> : thm
<a name="line332"></a>    val <a href="#list_size_cong-val">list_size_cong</a> : thm
<a name="line333"></a>    val <a href="#splitAtPki_APPEND-val">splitAtPki_APPEND</a> : thm
<a name="line334"></a>    val <a href="#splitAtPki_EQN-val">splitAtPki_EQN</a> : thm
<a name="line335"></a>
<a name="line336"></a>  val list_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line337"></a>(*
   [ind_type] Parent theory of "list"

   [operator] Parent theory of "list"

   [pred_set] Parent theory of "list"

   [<a name="ALL_DISTINCT-val"><b>ALL_DISTINCT</b></a>]  Definition

      |- (ALL_DISTINCT [] ⇔ T) ∧
         ∀h t. ALL_DISTINCT (h::t) ⇔ h ∉ set t ∧ ALL_DISTINCT t

   [<a name="APPEND-val"><b>APPEND</b></a>]  Definition

      |- (∀l. [] ++ l = l) ∧ ∀l1 l2 h. h::l1 ++ l2 = h::(l1 ++ l2)

   [<a name="DROP_def-val"><b>DROP_def</b></a>]  Definition

      |- (∀n. DROP n [] = []) ∧
         ∀n x xs. DROP n (x::xs) = if n = 0 then x::xs else DROP (n − 1) xs

   [<a name="EL-val"><b>EL</b></a>]  Definition

      |- (∀l. EL 0 l = HD l) ∧ ∀l n. EL (SUC n) l = EL n (TL l)

   [<a name="EVERY_DEF-val"><b>EVERY_DEF</b></a>]  Definition

      |- (∀P. EVERY P [] ⇔ T) ∧ ∀P h t. EVERY P (h::t) ⇔ P h ∧ EVERY P t

   [<a name="EVERYi_DEF-val"><b>EVERYi_DEF</b></a>]  Definition

      |- (∀P. EVERYi P [] ⇔ T) ∧
         ∀P h t. EVERYi P (h::t) ⇔ P 0 h ∧ EVERYi (P o SUC) t

   [<a name="EXISTS_DEF-val"><b>EXISTS_DEF</b></a>]  Definition

      |- (∀P. EXISTS P [] ⇔ F) ∧ ∀P h t. EXISTS P (h::t) ⇔ P h ∨ EXISTS P t

   [<a name="FILTER-val"><b>FILTER</b></a>]  Definition

      |- (∀P. FILTER P [] = []) ∧
         ∀P h t.
           FILTER P (h::t) = if P h then h::FILTER P t else FILTER P t

   [<a name="FLAT-val"><b>FLAT</b></a>]  Definition

      |- (FLAT [] = []) ∧ ∀h t. FLAT (h::t) = h ++ FLAT t

   [<a name="FOLDL-val"><b>FOLDL</b></a>]  Definition

      |- (∀f e. FOLDL f e [] = e) ∧
         ∀f e x l. FOLDL f e (x::l) = FOLDL f (f e x) l

   [<a name="FOLDR-val"><b>FOLDR</b></a>]  Definition

      |- (∀f e. FOLDR f e [] = e) ∧
         ∀f e x l. FOLDR f e (x::l) = f x (FOLDR f e l)

   [<a name="FRONT_DEF-val"><b>FRONT_DEF</b></a>]  Definition

      |- ∀h t. FRONT (h::t) = if t = [] then [] else h::FRONT t

   [<a name="GENLIST-val"><b>GENLIST</b></a>]  Definition

      |- (∀f. GENLIST f 0 = []) ∧
         ∀f n. GENLIST f (SUC n) = SNOC (f n) (GENLIST f n)

   [<a name="GENLIST_AUX-val"><b>GENLIST_AUX</b></a>]  Definition

      |- (∀f l. GENLIST_AUX f 0 l = l) ∧
         ∀f n l. GENLIST_AUX f (SUC n) l = GENLIST_AUX f n (f n::l)

   [<a name="HD-val"><b>HD</b></a>]  Definition

      |- ∀h t. HD (h::t) = h

   [<a name="LAST_DEF-val"><b>LAST_DEF</b></a>]  Definition

      |- ∀h t. LAST (h::t) = if t = [] then h else LAST t

   [<a name="LENGTH-val"><b>LENGTH</b></a>]  Definition

      |- (LENGTH [] = 0) ∧ ∀h t. LENGTH (h::t) = SUC (LENGTH t)

   [<a name="LEN_DEF-val"><b>LEN_DEF</b></a>]  Definition

      |- (∀n. LEN [] n = n) ∧ ∀h t n. LEN (h::t) n = LEN t (n + 1)

   [<a name="LIST_TO_SET_DEF-val"><b>LIST_TO_SET_DEF</b></a>]  Definition

      |- (∀x. set [] x ⇔ F) ∧ ∀h t x. set (h::t) x ⇔ (x = h) ∨ set t x

   [<a name="LRC_def-val"><b>LRC_def</b></a>]  Definition

      |- (∀R x y. LRC R [] x y ⇔ (x = y)) ∧
         ∀R h t x y. LRC R (h::t) x y ⇔ (x = h) ∧ ∃z. R x z ∧ LRC R t z y

   [<a name="LUPDATE_def-val"><b>LUPDATE_def</b></a>]  Definition

      |- (∀e n. LUPDATE e n [] = []) ∧
         (∀e x l. LUPDATE e 0 (x::l) = e::l) ∧
         ∀e n x l. LUPDATE e (SUC n) (x::l) = x::LUPDATE e n l

   [<a name="MAP-val"><b>MAP</b></a>]  Definition

      |- (∀f. MAP f [] = []) ∧ ∀f h t. MAP f (h::t) = f h::MAP f t

   [<a name="NULL_DEF-val"><b>NULL_DEF</b></a>]  Definition

      |- (NULL [] ⇔ T) ∧ ∀h t. NULL (h::t) ⇔ F

   [<a name="PAD_LEFT-val"><b>PAD_LEFT</b></a>]  Definition

      |- ∀c n s. PAD_LEFT c n s = GENLIST (K c) (n − LENGTH s) ++ s

   [<a name="PAD_RIGHT-val"><b>PAD_RIGHT</b></a>]  Definition

      |- ∀c n s. PAD_RIGHT c n s = s ++ GENLIST (K c) (n − LENGTH s)

   [<a name="REVERSE_DEF-val"><b>REVERSE_DEF</b></a>]  Definition

      |- (REVERSE [] = []) ∧ ∀h t. REVERSE (h::t) = REVERSE t ++ [h]

   [<a name="REV_DEF-val"><b>REV_DEF</b></a>]  Definition

      |- (∀acc. REV [] acc = acc) ∧
         ∀h t acc. REV (h::t) acc = REV t (h::acc)

   [<a name="SET_TO_LIST_primitive-val"><b>SET_TO_LIST_primitive</b></a>]  Definition

      |- SET_TO_LIST =
         WFREC (@R. WF R ∧ ∀s. FINITE s ∧ s ≠ ∅ ⇒ R (REST s) s)
           (λSET_TO_LIST s.
              I
                (if FINITE s then
                   if s = ∅ then [] else CHOICE s::SET_TO_LIST (REST s)
                 else ARB))

   [<a name="SNOC-val"><b>SNOC</b></a>]  Definition

      |- (∀x. SNOC x [] = [x]) ∧ ∀x x' l. SNOC x (x'::l) = x'::SNOC x l

   [<a name="SUM-val"><b>SUM</b></a>]  Definition

      |- (SUM [] = 0) ∧ ∀h t. SUM (h::t) = h + SUM t

   [<a name="SUM_ACC_DEF-val"><b>SUM_ACC_DEF</b></a>]  Definition

      |- (∀acc. SUM_ACC [] acc = acc) ∧
         ∀h t acc. SUM_ACC (h::t) acc = SUM_ACC t (h + acc)

   [<a name="TAKE_def-val"><b>TAKE_def</b></a>]  Definition

      |- (∀n. TAKE n [] = []) ∧
         ∀n x xs. TAKE n (x::xs) = if n = 0 then [] else x::TAKE (n − 1) xs

   [<a name="TL-val"><b>TL</b></a>]  Definition

      |- ∀h t. TL (h::t) = t

   [<a name="UNZIP-val"><b>UNZIP</b></a>]  Definition

      |- (UNZIP [] = ([],[])) ∧
         ∀x l. UNZIP (x::l) = (FST x::FST (UNZIP l),SND x::SND (UNZIP l))

   [<a name="ZIP-val"><b>ZIP</b></a>]  Definition

      |- (ZIP ([],[]) = []) ∧
         ∀x1 l1 x2 l2. ZIP (x1::l1,x2::l2) = (x1,x2)::ZIP (l1,l2)

   [<a name="isPREFIX-val"><b>isPREFIX</b></a>]  Definition

      |- (∀l. [] ≼ l ⇔ T) ∧
         ∀h t l. h::t ≼ l ⇔ case l of [] =&gt; F | h'::t' =&gt; (h = h') ∧ t ≼ t'

   [<a name="list_TY_DEF-val"><b>list_TY_DEF</b></a>]  Definition

      |- ∃rep.
           TYPE_DEFINITION
             (λa0'.
                ∀'list' .
                  (∀a0'.
                     (a0' = ind_type$CONSTR 0 ARB (λn. ind_type$BOTTOM)) ∨
                     (∃a0 a1.
                        (a0' =
                         (λa0 a1.
                            ind_type$CONSTR (SUC 0) a0
                              (ind_type$FCONS a1 (λn. ind_type$BOTTOM))) a0
                           a1) ∧ 'list' a1) ⇒
                     'list' a0') ⇒
                  'list' a0') rep

   [<a name="list_case_def-val"><b>list_case_def</b></a>]  Definition

      |- (∀v f. list_CASE [] v f = v) ∧
         ∀a0 a1 v f. list_CASE (a0::a1) v f = f a0 a1

   [<a name="list_size_def-val"><b>list_size_def</b></a>]  Definition

      |- (∀f. list_size f [] = 0) ∧
         ∀f a0 a1. list_size f (a0::a1) = 1 + (f a0 + list_size f a1)

   [<a name="splitAtPki_DEF-val"><b>splitAtPki_DEF</b></a>]  Definition

      |- (∀P k. splitAtPki P k [] = k [] []) ∧
         ∀P k h t.
           splitAtPki P k (h::t) =
           if P 0 h then k [] (h::t)
           else splitAtPki (P o SUC) (λp s. k (h::p) s) t

   [<a name="ALL_DISTINCT_APPEND-val"><b>ALL_DISTINCT_APPEND</b></a>]  Theorem

      |- ∀l1 l2.
           ALL_DISTINCT (l1 ++ l2) ⇔
           ALL_DISTINCT l1 ∧ ALL_DISTINCT l2 ∧ ∀e. MEM e l1 ⇒ e ∉ set l2

   [<a name="ALL_DISTINCT_CARD_LIST_TO_SET-val"><b>ALL_DISTINCT_CARD_LIST_TO_SET</b></a>]  Theorem

      |- ∀ls. ALL_DISTINCT ls ⇒ (CARD (set ls) = LENGTH ls)

   [<a name="ALL_DISTINCT_EL_IMP-val"><b>ALL_DISTINCT_EL_IMP</b></a>]  Theorem

      |- ∀l n1 n2.
           ALL_DISTINCT l ∧ n1 &lt; LENGTH l ∧ n2 &lt; LENGTH l ⇒
           ((EL n1 l = EL n2 l) ⇔ (n1 = n2))

   [<a name="ALL_DISTINCT_FILTER-val"><b>ALL_DISTINCT_FILTER</b></a>]  Theorem

      |- ∀l. ALL_DISTINCT l ⇔ ∀x. MEM x l ⇒ (FILTER ($= x) l = [x])

   [<a name="ALL_DISTINCT_GENLIST-val"><b>ALL_DISTINCT_GENLIST</b></a>]  Theorem

      |- ALL_DISTINCT (GENLIST f n) ⇔
         ∀m1 m2. m1 &lt; n ∧ m2 &lt; n ∧ (f m1 = f m2) ⇒ (m1 = m2)

   [<a name="ALL_DISTINCT_MAP-val"><b>ALL_DISTINCT_MAP</b></a>]  Theorem

      |- ∀f ls. ALL_DISTINCT (MAP f ls) ⇒ ALL_DISTINCT ls

   [<a name="ALL_DISTINCT_REVERSE-val"><b>ALL_DISTINCT_REVERSE</b></a>]  Theorem

      |- ∀l. ALL_DISTINCT (REVERSE l) ⇔ ALL_DISTINCT l

   [<a name="ALL_DISTINCT_SET_TO_LIST-val"><b>ALL_DISTINCT_SET_TO_LIST</b></a>]  Theorem

      |- ∀s. FINITE s ⇒ ALL_DISTINCT (SET_TO_LIST s)

   [<a name="ALL_DISTINCT_SING-val"><b>ALL_DISTINCT_SING</b></a>]  Theorem

      |- ∀x. ALL_DISTINCT [x]

   [<a name="ALL_DISTINCT_SNOC-val"><b>ALL_DISTINCT_SNOC</b></a>]  Theorem

      |- ∀x l. ALL_DISTINCT (SNOC x l) ⇔ x ∉ set l ∧ ALL_DISTINCT l

   [<a name="ALL_DISTINCT_ZIP-val"><b>ALL_DISTINCT_ZIP</b></a>]  Theorem

      |- ∀l1 l2.
           ALL_DISTINCT l1 ∧ (LENGTH l1 = LENGTH l2) ⇒
           ALL_DISTINCT (ZIP (l1,l2))

   [<a name="ALL_DISTINCT_ZIP_SWAP-val"><b>ALL_DISTINCT_ZIP_SWAP</b></a>]  Theorem

      |- ∀l1 l2.
           ALL_DISTINCT (ZIP (l1,l2)) ∧ (LENGTH l1 = LENGTH l2) ⇒
           ALL_DISTINCT (ZIP (l2,l1))

   [<a name="APPEND_11-val"><b>APPEND_11</b></a>]  Theorem

      |- (∀l1 l2 l3. (l1 ++ l2 = l1 ++ l3) ⇔ (l2 = l3)) ∧
         ∀l1 l2 l3. (l2 ++ l1 = l3 ++ l1) ⇔ (l2 = l3)

   [<a name="APPEND_11_LENGTH-val"><b>APPEND_11_LENGTH</b></a>]  Theorem

      |- (∀l1 l2 l1' l2'.
            (LENGTH l1 = LENGTH l1') ⇒
            ((l1 ++ l2 = l1' ++ l2') ⇔ (l1 = l1') ∧ (l2 = l2'))) ∧
         ∀l1 l2 l1' l2'.
           (LENGTH l2 = LENGTH l2') ⇒
           ((l1 ++ l2 = l1' ++ l2') ⇔ (l1 = l1') ∧ (l2 = l2'))

   [<a name="APPEND_ASSOC-val"><b>APPEND_ASSOC</b></a>]  Theorem

      |- ∀l1 l2 l3. l1 ++ (l2 ++ l3) = l1 ++ l2 ++ l3

   [<a name="APPEND_EQ_APPEND-val"><b>APPEND_EQ_APPEND</b></a>]  Theorem

      |- (l1 ++ l2 = m1 ++ m2) ⇔
         (∃l. (l1 = m1 ++ l) ∧ (m2 = l ++ l2)) ∨
         ∃l. (m1 = l1 ++ l) ∧ (l2 = l ++ m2)

   [<a name="APPEND_EQ_APPEND_MID-val"><b>APPEND_EQ_APPEND_MID</b></a>]  Theorem

      |- (l1 ++ [e] ++ l2 = m1 ++ m2) ⇔
         (∃l. (m1 = l1 ++ [e] ++ l) ∧ (l2 = l ++ m2)) ∨
         ∃l. (l1 = m1 ++ l) ∧ (m2 = l ++ [e] ++ l2)

   [<a name="APPEND_EQ_CONS-val"><b>APPEND_EQ_CONS</b></a>]  Theorem

      |- (l1 ++ l2 = h::t) ⇔
         (l1 = []) ∧ (l2 = h::t) ∨ ∃lt. (l1 = h::lt) ∧ (t = lt ++ l2)

   [<a name="APPEND_EQ_SELF-val"><b>APPEND_EQ_SELF</b></a>]  Theorem

      |- (∀l1 l2. (l1 ++ l2 = l1) ⇔ (l2 = [])) ∧
         (∀l1 l2. (l1 ++ l2 = l2) ⇔ (l1 = [])) ∧
         (∀l1 l2. (l1 = l1 ++ l2) ⇔ (l2 = [])) ∧
         ∀l1 l2. (l2 = l1 ++ l2) ⇔ (l1 = [])

   [<a name="APPEND_EQ_SING-val"><b>APPEND_EQ_SING</b></a>]  Theorem

      |- (l1 ++ l2 = [e]) ⇔ (l1 = [e]) ∧ (l2 = []) ∨ (l1 = []) ∧ (l2 = [e])

   [<a name="APPEND_FRONT_LAST-val"><b>APPEND_FRONT_LAST</b></a>]  Theorem

      |- ∀l. l ≠ [] ⇒ (FRONT l ++ [LAST l] = l)

   [<a name="APPEND_LENGTH_EQ-val"><b>APPEND_LENGTH_EQ</b></a>]  Theorem

      |- ∀l1 l1'.
           (LENGTH l1 = LENGTH l1') ⇒
           ∀l2 l2'.
             (LENGTH l2 = LENGTH l2') ⇒
             ((l1 ++ l2 = l1' ++ l2') ⇔ (l1 = l1') ∧ (l2 = l2'))

   [<a name="APPEND_NIL-val"><b>APPEND_NIL</b></a>]  Theorem

      |- ∀l. l ++ [] = l

   [<a name="APPEND_SNOC-val"><b>APPEND_SNOC</b></a>]  Theorem

      |- ∀l1 x l2. l1 ++ SNOC x l2 = SNOC x (l1 ++ l2)

   [<a name="APPEND_eq_NIL-val"><b>APPEND_eq_NIL</b></a>]  Theorem

      |- (∀l1 l2. ([] = l1 ++ l2) ⇔ (l1 = []) ∧ (l2 = [])) ∧
         ∀l1 l2. (l1 ++ l2 = []) ⇔ (l1 = []) ∧ (l2 = [])

   [<a name="CARD_LIST_TO_SET-val"><b>CARD_LIST_TO_SET</b></a>]  Theorem

      |- CARD (set ls) ≤ LENGTH ls

   [<a name="CONS-val"><b>CONS</b></a>]  Theorem

      |- ∀l. ¬NULL l ⇒ (HD l::TL l = l)

   [<a name="CONS_11-val"><b>CONS_11</b></a>]  Theorem

      |- ∀a0 a1 a0' a1'. (a0::a1 = a0'::a1') ⇔ (a0 = a0') ∧ (a1 = a1')

   [<a name="CONS_ACYCLIC-val"><b>CONS_ACYCLIC</b></a>]  Theorem

      |- ∀l x. l ≠ x::l ∧ x::l ≠ l

   [<a name="DROP_0-val"><b>DROP_0</b></a>]  Theorem

      |- DROP 0 l = l

   [<a name="DROP_LENGTH_TOO_LONG-val"><b>DROP_LENGTH_TOO_LONG</b></a>]  Theorem

      |- ∀l n. LENGTH l ≤ n ⇒ (DROP n l = [])

   [<a name="DROP_NIL-val"><b>DROP_NIL</b></a>]  Theorem

      |- ∀ls n. (DROP n ls = []) ⇔ n ≥ LENGTH ls

   [<a name="DROP_compute-val"><b>DROP_compute</b></a>]  Theorem

      |- (∀l. DROP 0 l = l) ∧ (∀n. DROP (NUMERAL (BIT1 n)) [] = []) ∧
         (∀n. DROP (NUMERAL (BIT2 n)) [] = []) ∧
         (∀n h t.
            DROP (NUMERAL (BIT1 n)) (h::t) =
            DROP (NUMERAL (BIT1 n) − 1) t) ∧
         ∀n h t. DROP (NUMERAL (BIT2 n)) (h::t) = DROP (NUMERAL (BIT1 n)) t

   [<a name="DROP_splitAtPki-val"><b>DROP_splitAtPki</b></a>]  Theorem

      |- DROP n l = splitAtPki (K o $= n) (K I) l

   [<a name="EL_ALL_DISTINCT_EL_EQ-val"><b>EL_ALL_DISTINCT_EL_EQ</b></a>]  Theorem

      |- ∀l.
           ALL_DISTINCT l ⇔
           ∀n1 n2.
             n1 &lt; LENGTH l ∧ n2 &lt; LENGTH l ⇒
             ((EL n1 l = EL n2 l) ⇔ (n1 = n2))

   [<a name="EL_GENLIST-val"><b>EL_GENLIST</b></a>]  Theorem

      |- ∀f n x. x &lt; n ⇒ (EL x (GENLIST f n) = f x)

   [<a name="EL_LENGTH_SNOC-val"><b>EL_LENGTH_SNOC</b></a>]  Theorem

      |- ∀l x. EL (LENGTH l) (SNOC x l) = x

   [<a name="EL_LUPDATE-val"><b>EL_LUPDATE</b></a>]  Theorem

      |- ∀ys x i k.
           EL i (LUPDATE x k ys) =
           if (i = k) ∧ k &lt; LENGTH ys then x else EL i ys

   [<a name="EL_MAP-val"><b>EL_MAP</b></a>]  Theorem

      |- ∀n l. n &lt; LENGTH l ⇒ ∀f. EL n (MAP f l) = f (EL n l)

   [<a name="EL_REVERSE-val"><b>EL_REVERSE</b></a>]  Theorem

      |- ∀n l.
           n &lt; LENGTH l ⇒ (EL n (REVERSE l) = EL (PRE (LENGTH l − n)) l)

   [<a name="EL_SNOC-val"><b>EL_SNOC</b></a>]  Theorem

      |- ∀n l. n &lt; LENGTH l ⇒ ∀x. EL n (SNOC x l) = EL n l

   [<a name="EL_ZIP-val"><b>EL_ZIP</b></a>]  Theorem

      |- ∀l1 l2 n.
           (LENGTH l1 = LENGTH l2) ∧ n &lt; LENGTH l1 ⇒
           (EL n (ZIP (l1,l2)) = (EL n l1,EL n l2))

   [<a name="EL_compute-val"><b>EL_compute</b></a>]  Theorem

      |- ∀n. EL n l = if n = 0 then HD l else EL (PRE n) (TL l)

   [<a name="EL_restricted-val"><b>EL_restricted</b></a>]  Theorem

      |- (EL 0 = HD) ∧ (EL (SUC n) (l::ls) = EL n ls)

   [<a name="EL_simp-val"><b>EL_simp</b></a>]  Theorem

      |- (EL (NUMERAL (BIT1 n)) l = EL (PRE (NUMERAL (BIT1 n))) (TL l)) ∧
         (EL (NUMERAL (BIT2 n)) l = EL (NUMERAL (BIT1 n)) (TL l))

   [<a name="EL_simp_restricted-val"><b>EL_simp_restricted</b></a>]  Theorem

      |- (EL (NUMERAL (BIT1 n)) (l::ls) = EL (PRE (NUMERAL (BIT1 n))) ls) ∧
         (EL (NUMERAL (BIT2 n)) (l::ls) = EL (NUMERAL (BIT1 n)) ls)

   [<a name="EQ_LIST-val"><b>EQ_LIST</b></a>]  Theorem

      |- ∀h1 h2. (h1 = h2) ⇒ ∀l1 l2. (l1 = l2) ⇒ (h1::l1 = h2::l2)

   [<a name="EVERY2_EVERY-val"><b>EVERY2_EVERY</b></a>]  Theorem

      |- ∀l1 l2 f.
           LIST_REL f l1 l2 ⇔
           (LENGTH l1 = LENGTH l2) ∧ EVERY (UNCURRY f) (ZIP (l1,l2))

   [<a name="EVERY2_LENGTH-val"><b>EVERY2_LENGTH</b></a>]  Theorem

      |- ∀P l1 l2. LIST_REL P l1 l2 ⇒ (LENGTH l1 = LENGTH l2)

   [<a name="EVERY2_cong-val"><b>EVERY2_cong</b></a>]  Theorem

      |- ∀l1 l1' l2 l2' P P'.
           (l1 = l1') ∧ (l2 = l2') ∧
           (∀x y. MEM x l1' ∧ MEM y l2' ⇒ (P x y ⇔ P' x y)) ⇒
           (LIST_REL P l1 l2 ⇔ LIST_REL P' l1' l2')

   [<a name="EVERY2_mono-val"><b>EVERY2_mono</b></a>]  Theorem

      |- (∀x y. R1 x y ⇒ R2 x y) ⇒ LIST_REL R1 l1 l2 ⇒ LIST_REL R2 l1 l2

   [<a name="EVERY_APPEND-val"><b>EVERY_APPEND</b></a>]  Theorem

      |- ∀P l1 l2. EVERY P (l1 ++ l2) ⇔ EVERY P l1 ∧ EVERY P l2

   [<a name="EVERY_CONG-val"><b>EVERY_CONG</b></a>]  Theorem

      |- ∀l1 l2 P P'.
           (l1 = l2) ∧ (∀x. MEM x l2 ⇒ (P x ⇔ P' x)) ⇒
           (EVERY P l1 ⇔ EVERY P' l2)

   [<a name="EVERY_CONJ-val"><b>EVERY_CONJ</b></a>]  Theorem

      |- ∀P Q l. EVERY (λx. P x ∧ Q x) l ⇔ EVERY P l ∧ EVERY Q l

   [<a name="EVERY_EL-val"><b>EVERY_EL</b></a>]  Theorem

      |- ∀l P. EVERY P l ⇔ ∀n. n &lt; LENGTH l ⇒ P (EL n l)

   [<a name="EVERY_FILTER-val"><b>EVERY_FILTER</b></a>]  Theorem

      |- ∀P1 P2 l. EVERY P1 (FILTER P2 l) ⇔ EVERY (λx. P2 x ⇒ P1 x) l

   [<a name="EVERY_FILTER_IMP-val"><b>EVERY_FILTER_IMP</b></a>]  Theorem

      |- ∀P1 P2 l. EVERY P1 l ⇒ EVERY P1 (FILTER P2 l)

   [<a name="EVERY_GENLIST-val"><b>EVERY_GENLIST</b></a>]  Theorem

      |- ∀n. EVERY P (GENLIST f n) ⇔ ∀i. i &lt; n ⇒ P (f i)

   [<a name="EVERY_MAP-val"><b>EVERY_MAP</b></a>]  Theorem

      |- ∀P f l. EVERY P (MAP f l) ⇔ EVERY (λx. P (f x)) l

   [<a name="EVERY_MEM-val"><b>EVERY_MEM</b></a>]  Theorem

      |- ∀P l. EVERY P l ⇔ ∀e. MEM e l ⇒ P e

   [<a name="EVERY_MONOTONIC-val"><b>EVERY_MONOTONIC</b></a>]  Theorem

      |- ∀P Q. (∀x. P x ⇒ Q x) ⇒ ∀l. EVERY P l ⇒ EVERY Q l

   [<a name="EVERY_NOT_EXISTS-val"><b>EVERY_NOT_EXISTS</b></a>]  Theorem

      |- ∀P l. EVERY P l ⇔ ¬EXISTS (λx. ¬P x) l

   [<a name="EVERY_SIMP-val"><b>EVERY_SIMP</b></a>]  Theorem

      |- ∀c l. EVERY (λx. c) l ⇔ (l = []) ∨ c

   [<a name="EVERY_SNOC-val"><b>EVERY_SNOC</b></a>]  Theorem

      |- ∀P x l. EVERY P (SNOC x l) ⇔ EVERY P l ∧ P x

   [<a name="EXISTS_APPEND-val"><b>EXISTS_APPEND</b></a>]  Theorem

      |- ∀P l1 l2. EXISTS P (l1 ++ l2) ⇔ EXISTS P l1 ∨ EXISTS P l2

   [<a name="EXISTS_CONG-val"><b>EXISTS_CONG</b></a>]  Theorem

      |- ∀l1 l2 P P'.
           (l1 = l2) ∧ (∀x. MEM x l2 ⇒ (P x ⇔ P' x)) ⇒
           (EXISTS P l1 ⇔ EXISTS P' l2)

   [<a name="EXISTS_GENLIST-val"><b>EXISTS_GENLIST</b></a>]  Theorem

      |- ∀n. EXISTS P (GENLIST f n) ⇔ ∃i. i &lt; n ∧ P (f i)

   [<a name="EXISTS_LIST-val"><b>EXISTS_LIST</b></a>]  Theorem

      |- (∃l. P l) ⇔ P [] ∨ ∃h t. P (h::t)

   [<a name="EXISTS_MAP-val"><b>EXISTS_MAP</b></a>]  Theorem

      |- ∀P f l. EXISTS P (MAP f l) ⇔ EXISTS (λx. P (f x)) l

   [<a name="EXISTS_MEM-val"><b>EXISTS_MEM</b></a>]  Theorem

      |- ∀P l. EXISTS P l ⇔ ∃e. MEM e l ∧ P e

   [<a name="EXISTS_NOT_EVERY-val"><b>EXISTS_NOT_EVERY</b></a>]  Theorem

      |- ∀P l. EXISTS P l ⇔ ¬EVERY (λx. ¬P x) l

   [<a name="EXISTS_SIMP-val"><b>EXISTS_SIMP</b></a>]  Theorem

      |- ∀c l. EXISTS (λx. c) l ⇔ l ≠ [] ∧ c

   [<a name="EXISTS_SNOC-val"><b>EXISTS_SNOC</b></a>]  Theorem

      |- ∀P x l. EXISTS P (SNOC x l) ⇔ P x ∨ EXISTS P l

   [<a name="FILTER_ALL_DISTINCT-val"><b>FILTER_ALL_DISTINCT</b></a>]  Theorem

      |- ∀P l. ALL_DISTINCT l ⇒ ALL_DISTINCT (FILTER P l)

   [<a name="FILTER_APPEND_DISTRIB-val"><b>FILTER_APPEND_DISTRIB</b></a>]  Theorem

      |- ∀P L M. FILTER P (L ++ M) = FILTER P L ++ FILTER P M

   [<a name="FILTER_COND_REWRITE-val"><b>FILTER_COND_REWRITE</b></a>]  Theorem

      |- (FILTER P [] = []) ∧
         (∀h. P h ⇒ (FILTER P (h::l) = h::FILTER P l)) ∧
         ∀h. ¬P h ⇒ (FILTER P (h::l) = FILTER P l)

   [<a name="FILTER_EQ_APPEND-val"><b>FILTER_EQ_APPEND</b></a>]  Theorem

      |- ∀P l l1 l2.
           (FILTER P l = l1 ++ l2) ⇔
           ∃l3 l4. (l = l3 ++ l4) ∧ (FILTER P l3 = l1) ∧ (FILTER P l4 = l2)

   [<a name="FILTER_EQ_CONS-val"><b>FILTER_EQ_CONS</b></a>]  Theorem

      |- ∀P l h lr.
           (FILTER P l = h::lr) ⇔
           ∃l1 l2.
             (l = l1 ++ [h] ++ l2) ∧ (FILTER P l1 = []) ∧
             (FILTER P l2 = lr) ∧ P h

   [<a name="FILTER_EQ_ID-val"><b>FILTER_EQ_ID</b></a>]  Theorem

      |- ∀P l. (FILTER P l = l) ⇔ EVERY P l

   [<a name="FILTER_EQ_NIL-val"><b>FILTER_EQ_NIL</b></a>]  Theorem

      |- ∀P l. (FILTER P l = []) ⇔ EVERY (λx. ¬P x) l

   [<a name="FILTER_NEQ_ID-val"><b>FILTER_NEQ_ID</b></a>]  Theorem

      |- ∀P l. FILTER P l ≠ l ⇔ ∃x. MEM x l ∧ ¬P x

   [<a name="FILTER_NEQ_NIL-val"><b>FILTER_NEQ_NIL</b></a>]  Theorem

      |- ∀P l. FILTER P l ≠ [] ⇔ ∃x. MEM x l ∧ P x

   [<a name="FILTER_REVERSE-val"><b>FILTER_REVERSE</b></a>]  Theorem

      |- ∀l P. FILTER P (REVERSE l) = REVERSE (FILTER P l)

   [<a name="FINITE_LIST_TO_SET-val"><b>FINITE_LIST_TO_SET</b></a>]  Theorem

      |- ∀l. FINITE (set l)

   [<a name="FLAT_APPEND-val"><b>FLAT_APPEND</b></a>]  Theorem

      |- ∀l1 l2. FLAT (l1 ++ l2) = FLAT l1 ++ FLAT l2

   [<a name="FOLDL2_FOLDL-val"><b>FOLDL2_FOLDL</b></a>]  Theorem

      |- ∀l1 l2.
           (LENGTH l1 = LENGTH l2) ⇒
           ∀f a.
             FOLDL2 f a l1 l2 = FOLDL (λa. UNCURRY (f a)) a (ZIP (l1,l2))

   [<a name="FOLDL2_cong-val"><b>FOLDL2_cong</b></a>]  Theorem

      |- ∀l1 l1' l2 l2' a a' f f'.
           (l1 = l1') ∧ (l2 = l2') ∧ (a = a') ∧
           (∀z b c. MEM b l1' ∧ MEM c l2' ⇒ (f z b c = f' z b c)) ⇒
           (FOLDL2 f a l1 l2 = FOLDL2 f' a' l1' l2')

   [<a name="FOLDL2_def-val"><b>FOLDL2_def</b></a>]  Theorem

      |- (∀f cs c bs b a.
            FOLDL2 f a (b::bs) (c::cs) = FOLDL2 f (f a b c) bs cs) ∧
         (∀f cs a. FOLDL2 f a [] cs = a) ∧
         ∀v7 v6 f a. FOLDL2 f a (v6::v7) [] = a

   [<a name="FOLDL2_ind-val"><b>FOLDL2_ind</b></a>]  Theorem

      |- ∀P.
           (∀f a b bs c cs. P f (f a b c) bs cs ⇒ P f a (b::bs) (c::cs)) ∧
           (∀f a cs. P f a [] cs) ∧ (∀f a v6 v7. P f a (v6::v7) []) ⇒
           ∀v v1 v2 v3. P v v1 v2 v3

   [<a name="FOLDL_CONG-val"><b>FOLDL_CONG</b></a>]  Theorem

      |- ∀l l' b b' f f'.
           (l = l') ∧ (b = b') ∧ (∀x a. MEM x l' ⇒ (f a x = f' a x)) ⇒
           (FOLDL f b l = FOLDL f' b' l')

   [<a name="FOLDL_EQ_FOLDR-val"><b>FOLDL_EQ_FOLDR</b></a>]  Theorem

      |- ∀f l e. ASSOC f ∧ COMM f ⇒ (FOLDL f e l = FOLDR f e l)

   [<a name="FOLDL_SNOC-val"><b>FOLDL_SNOC</b></a>]  Theorem

      |- ∀f e x l. FOLDL f e (SNOC x l) = f (FOLDL f e l) x

   [<a name="FOLDL_UNION_BIGUNION-val"><b>FOLDL_UNION_BIGUNION</b></a>]  Theorem

      |- ∀f ls s.
           FOLDL (λs x. s ∪ f x) s ls = s ∪ BIGUNION (IMAGE f (set ls))

   [<a name="FOLDL_UNION_BIGUNION_paired-val"><b>FOLDL_UNION_BIGUNION_paired</b></a>]  Theorem

      |- ∀f ls s.
           FOLDL (λs (x,y). s ∪ f x y) s ls =
           s ∪ BIGUNION (IMAGE (UNCURRY f) (set ls))

   [<a name="FOLDL_ZIP_SAME-val"><b>FOLDL_ZIP_SAME</b></a>]  Theorem

      |- ∀ls f e. FOLDL f e (ZIP (ls,ls)) = FOLDL (λx y. f x (y,y)) e ls

   [<a name="FOLDR_CONG-val"><b>FOLDR_CONG</b></a>]  Theorem

      |- ∀l l' b b' f f'.
           (l = l') ∧ (b = b') ∧ (∀x a. MEM x l' ⇒ (f x a = f' x a)) ⇒
           (FOLDR f b l = FOLDR f' b' l')

   [<a name="FOLDR_CONS-val"><b>FOLDR_CONS</b></a>]  Theorem

      |- ∀f ls a. FOLDR (λx y. f x::y) a ls = MAP f ls ++ a

   [<a name="FORALL_LIST-val"><b>FORALL_LIST</b></a>]  Theorem

      |- (∀l. P l) ⇔ P [] ∧ ∀h t. P (h::t)

   [<a name="FRONT_CONS-val"><b>FRONT_CONS</b></a>]  Theorem

      |- (∀x. FRONT [x] = []) ∧ ∀x y z. FRONT (x::y::z) = x::FRONT (y::z)

   [<a name="FRONT_CONS_EQ_NIL-val"><b>FRONT_CONS_EQ_NIL</b></a>]  Theorem

      |- (∀x xs. (FRONT (x::xs) = []) ⇔ (xs = [])) ∧
         (∀x xs. ([] = FRONT (x::xs)) ⇔ (xs = [])) ∧
         ∀x xs. NULL (FRONT (x::xs)) ⇔ NULL xs

   [<a name="FRONT_SNOC-val"><b>FRONT_SNOC</b></a>]  Theorem

      |- ∀x l. FRONT (SNOC x l) = l

   [<a name="GENLIST_APPEND-val"><b>GENLIST_APPEND</b></a>]  Theorem

      |- ∀f a b.
           GENLIST f (a + b) = GENLIST f b ++ GENLIST (λt. f (t + b)) a

   [<a name="GENLIST_AUX_compute-val"><b>GENLIST_AUX_compute</b></a>]  Theorem

      |- (∀f l. GENLIST_AUX f 0 l = l) ∧
         (∀f n l.
            GENLIST_AUX f (NUMERAL (BIT1 n)) l =
            GENLIST_AUX f (NUMERAL (BIT1 n) − 1)
              (f (NUMERAL (BIT1 n) − 1)::l)) ∧
         ∀f n l.
           GENLIST_AUX f (NUMERAL (BIT2 n)) l =
           GENLIST_AUX f (NUMERAL (BIT1 n)) (f (NUMERAL (BIT1 n))::l)

   [<a name="GENLIST_CONS-val"><b>GENLIST_CONS</b></a>]  Theorem

      |- GENLIST f (SUC n) = f 0::GENLIST (f o SUC) n

   [<a name="GENLIST_FUN_EQ-val"><b>GENLIST_FUN_EQ</b></a>]  Theorem

      |- ∀n f g. (GENLIST f n = GENLIST g n) ⇔ ∀x. x &lt; n ⇒ (f x = g x)

   [<a name="GENLIST_GENLIST_AUX-val"><b>GENLIST_GENLIST_AUX</b></a>]  Theorem

      |- ∀n. GENLIST f n = GENLIST_AUX f n []

   [<a name="GENLIST_NUMERALS-val"><b>GENLIST_NUMERALS</b></a>]  Theorem

      |- (GENLIST f 0 = []) ∧
         (GENLIST f (NUMERAL n) = GENLIST_AUX f (NUMERAL n) [])

   [<a name="HD_GENLIST-val"><b>HD_GENLIST</b></a>]  Theorem

      |- HD (GENLIST f (SUC n)) = f 0

   [<a name="HD_GENLIST_COR-val"><b>HD_GENLIST_COR</b></a>]  Theorem

      |- ∀n f. 0 &lt; n ⇒ (HD (GENLIST f n) = f 0)

   [<a name="INFINITE_LIST_UNIV-val"><b>INFINITE_LIST_UNIV</b></a>]  Theorem

      |- INFINITE pred_set$UNIV

   [<a name="INJ_MAP_EQ-val"><b>INJ_MAP_EQ</b></a>]  Theorem

      |- ∀f l1 l2.
           INJ f (set l1 ∪ set l2) pred_set$UNIV ∧ (MAP f l1 = MAP f l2) ⇒
           (l1 = l2)

   [<a name="IN_LIST_TO_SET-val"><b>IN_LIST_TO_SET</b></a>]  Theorem

      |- T

   [<a name="ITSET_eq_FOLDL_SET_TO_LIST-val"><b>ITSET_eq_FOLDL_SET_TO_LIST</b></a>]  Theorem

      |- ∀s.
           FINITE s ⇒
           ∀f a. ITSET f s a = FOLDL (combin$C f) a (SET_TO_LIST s)

   [<a name="LAST_APPEND_CONS-val"><b>LAST_APPEND_CONS</b></a>]  Theorem

      |- ∀h l1 l2. LAST (l1 ++ h::l2) = LAST (h::l2)

   [<a name="LAST_CONS-val"><b>LAST_CONS</b></a>]  Theorem

      |- (∀x. LAST [x] = x) ∧ ∀x y z. LAST (x::y::z) = LAST (y::z)

   [<a name="LAST_CONS_cond-val"><b>LAST_CONS_cond</b></a>]  Theorem

      |- LAST (h::t) = if t = [] then h else LAST t

   [<a name="LAST_EL-val"><b>LAST_EL</b></a>]  Theorem

      |- ∀ls. ls ≠ [] ⇒ (LAST ls = EL (PRE (LENGTH ls)) ls)

   [<a name="LAST_SNOC-val"><b>LAST_SNOC</b></a>]  Theorem

      |- ∀x l. LAST (SNOC x l) = x

   [<a name="LAST_compute-val"><b>LAST_compute</b></a>]  Theorem

      |- (∀x. LAST [x] = x) ∧ ∀h1 h2 t. LAST (h1::h2::t) = LAST (h2::t)

   [<a name="LENGTH_APPEND-val"><b>LENGTH_APPEND</b></a>]  Theorem

      |- ∀l1 l2. LENGTH (l1 ++ l2) = LENGTH l1 + LENGTH l2

   [<a name="LENGTH_CONS-val"><b>LENGTH_CONS</b></a>]  Theorem

      |- ∀l n. (LENGTH l = SUC n) ⇔ ∃h l'. (LENGTH l' = n) ∧ (l = h::l')

   [<a name="LENGTH_DROP-val"><b>LENGTH_DROP</b></a>]  Theorem

      |- ∀n l. LENGTH (DROP n l) = LENGTH l − n

   [<a name="LENGTH_EQ_CONS-val"><b>LENGTH_EQ_CONS</b></a>]  Theorem

      |- ∀P n.
           (∀l. (LENGTH l = SUC n) ⇒ P l) ⇔
           ∀l. (LENGTH l = n) ⇒ (λl. ∀x. P (x::l)) l

   [<a name="LENGTH_EQ_NIL-val"><b>LENGTH_EQ_NIL</b></a>]  Theorem

      |- ∀P. (∀l. (LENGTH l = 0) ⇒ P l) ⇔ P []

   [<a name="LENGTH_EQ_NUM-val"><b>LENGTH_EQ_NUM</b></a>]  Theorem

      |- (∀l. (LENGTH l = 0) ⇔ (l = [])) ∧
         (∀l n.
            (LENGTH l = SUC n) ⇔ ∃h l'. (LENGTH l' = n) ∧ (l = h::l')) ∧
         ∀l n1 n2.
           (LENGTH l = n1 + n2) ⇔
           ∃l1 l2. (LENGTH l1 = n1) ∧ (LENGTH l2 = n2) ∧ (l = l1 ++ l2)

   [<a name="LENGTH_EQ_NUM_compute-val"><b>LENGTH_EQ_NUM_compute</b></a>]  Theorem

      |- (∀l. (LENGTH l = 0) ⇔ (l = [])) ∧
         (∀l n.
            (LENGTH l = NUMERAL (BIT1 n)) ⇔
            ∃h l'. (LENGTH l' = NUMERAL (BIT1 n) − 1) ∧ (l = h::l')) ∧
         (∀l n.
            (LENGTH l = NUMERAL (BIT2 n)) ⇔
            ∃h l'. (LENGTH l' = NUMERAL (BIT1 n)) ∧ (l = h::l')) ∧
         ∀l n1 n2.
           (LENGTH l = n1 + n2) ⇔
           ∃l1 l2. (LENGTH l1 = n1) ∧ (LENGTH l2 = n2) ∧ (l = l1 ++ l2)

   [<a name="LENGTH_EQ_SUM-val"><b>LENGTH_EQ_SUM</b></a>]  Theorem

      |- ∀l n1 n2.
           (LENGTH l = n1 + n2) ⇔
           ∃l1 l2. (LENGTH l1 = n1) ∧ (LENGTH l2 = n2) ∧ (l = l1 ++ l2)

   [<a name="LENGTH_FRONT_CONS-val"><b>LENGTH_FRONT_CONS</b></a>]  Theorem

      |- ∀x xs. LENGTH (FRONT (x::xs)) = LENGTH xs

   [<a name="LENGTH_GENLIST-val"><b>LENGTH_GENLIST</b></a>]  Theorem

      |- ∀f n. LENGTH (GENLIST f n) = n

   [<a name="LENGTH_LEN-val"><b>LENGTH_LEN</b></a>]  Theorem

      |- ∀L. LENGTH L = LEN L 0

   [<a name="LENGTH_LUPDATE-val"><b>LENGTH_LUPDATE</b></a>]  Theorem

      |- ∀x n ys. LENGTH (LUPDATE x n ys) = LENGTH ys

   [<a name="LENGTH_MAP-val"><b>LENGTH_MAP</b></a>]  Theorem

      |- ∀l f. LENGTH (MAP f l) = LENGTH l

   [<a name="LENGTH_NIL-val"><b>LENGTH_NIL</b></a>]  Theorem

      |- ∀l. (LENGTH l = 0) ⇔ (l = [])

   [<a name="LENGTH_NIL_SYM-val"><b>LENGTH_NIL_SYM</b></a>]  Theorem

      |- (0 = LENGTH l) ⇔ (l = [])

   [<a name="LENGTH_REVERSE-val"><b>LENGTH_REVERSE</b></a>]  Theorem

      |- ∀l. LENGTH (REVERSE l) = LENGTH l

   [<a name="LENGTH_SNOC-val"><b>LENGTH_SNOC</b></a>]  Theorem

      |- ∀x l. LENGTH (SNOC x l) = SUC (LENGTH l)

   [<a name="LENGTH_TAKE-val"><b>LENGTH_TAKE</b></a>]  Theorem

      |- ∀n l. n ≤ LENGTH l ⇒ (LENGTH (TAKE n l) = n)

   [<a name="LENGTH_TL-val"><b>LENGTH_TL</b></a>]  Theorem

      |- ∀l. 0 &lt; LENGTH l ⇒ (LENGTH (TL l) = LENGTH l − 1)

   [<a name="LENGTH_UNZIP-val"><b>LENGTH_UNZIP</b></a>]  Theorem

      |- ∀pl.
           (LENGTH (FST (UNZIP pl)) = LENGTH pl) ∧
           (LENGTH (SND (UNZIP pl)) = LENGTH pl)

   [<a name="LENGTH_ZIP-val"><b>LENGTH_ZIP</b></a>]  Theorem

      |- ∀l1 l2.
           (LENGTH l1 = LENGTH l2) ⇒
           (LENGTH (ZIP (l1,l2)) = LENGTH l1) ∧
           (LENGTH (ZIP (l1,l2)) = LENGTH l2)

   [<a name="LEN_LENGTH_LEM-val"><b>LEN_LENGTH_LEM</b></a>]  Theorem

      |- ∀L n. LEN L n = LENGTH L + n

   [<a name="LIST_EQ-val"><b>LIST_EQ</b></a>]  Theorem

      |- ∀l1 l2.
           (LENGTH l1 = LENGTH l2) ∧
           (∀x. x &lt; LENGTH l1 ⇒ (EL x l1 = EL x l2)) ⇒
           (l1 = l2)

   [<a name="LIST_EQ_REWRITE-val"><b>LIST_EQ_REWRITE</b></a>]  Theorem

      |- ∀l1 l2.
           (l1 = l2) ⇔
           (LENGTH l1 = LENGTH l2) ∧
           ∀x. x &lt; LENGTH l1 ⇒ (EL x l1 = EL x l2)

   [<a name="LIST_NOT_EQ-val"><b>LIST_NOT_EQ</b></a>]  Theorem

      |- ∀l1 l2. l1 ≠ l2 ⇒ ∀h1 h2. h1::l1 ≠ h2::l2

   [<a name="LIST_REL_CONJ-val"><b>LIST_REL_CONJ</b></a>]  Theorem

      |- LIST_REL (λa b. P a b ∧ Q a b) l1 l2 ⇔
         LIST_REL (λa b. P a b) l1 l2 ∧ LIST_REL (λa b. Q a b) l1 l2

   [<a name="LIST_REL_CONS1-val"><b>LIST_REL_CONS1</b></a>]  Theorem

      |- LIST_REL R (h::t) xs ⇔
         ∃h' t'. (xs = h'::t') ∧ R h h' ∧ LIST_REL R t t'

   [<a name="LIST_REL_CONS2-val"><b>LIST_REL_CONS2</b></a>]  Theorem

      |- LIST_REL R xs (h::t) ⇔
         ∃h' t'. (xs = h'::t') ∧ R h' h ∧ LIST_REL R t' t

   [<a name="LIST_REL_EL_EQN-val"><b>LIST_REL_EL_EQN</b></a>]  Theorem

      |- ∀R l1 l2.
           LIST_REL R l1 l2 ⇔
           (LENGTH l1 = LENGTH l2) ∧
           ∀n. n &lt; LENGTH l1 ⇒ R (EL n l1) (EL n l2)

   [<a name="LIST_REL_EVERY_ZIP-val"><b>LIST_REL_EVERY_ZIP</b></a>]  Theorem

      |- ∀R l1 l2.
           LIST_REL R l1 l2 ⇔
           (LENGTH l1 = LENGTH l2) ∧ EVERY (UNCURRY R) (ZIP (l1,l2))

   [<a name="LIST_REL_LENGTH-val"><b>LIST_REL_LENGTH</b></a>]  Theorem

      |- ∀x y. LIST_REL R x y ⇒ (LENGTH x = LENGTH y)

   [<a name="LIST_REL_MAP1-val"><b>LIST_REL_MAP1</b></a>]  Theorem

      |- LIST_REL R (MAP f l1) l2 ⇔ LIST_REL (R o f) l1 l2

   [<a name="LIST_REL_MAP2-val"><b>LIST_REL_MAP2</b></a>]  Theorem

      |- LIST_REL (λa b. R a b) l1 (MAP f l2) ⇔
         LIST_REL (λa b. R a (f b)) l1 l2

   [<a name="LIST_REL_NIL-val"><b>LIST_REL_NIL</b></a>]  Theorem

      |- (LIST_REL R [] x ⇔ (x = [])) ∧ (LIST_REL R [] y ⇔ (y = []))

   [<a name="LIST_REL_cases-val"><b>LIST_REL_cases</b></a>]  Theorem

      |- ∀R a0 a1.
           LIST_REL R a0 a1 ⇔
           (a0 = []) ∧ (a1 = []) ∨
           ∃h1 h2 t1 t2.
             (a0 = h1::t1) ∧ (a1 = h2::t2) ∧ R h1 h2 ∧ LIST_REL R t1 t2

   [<a name="LIST_REL_def-val"><b>LIST_REL_def</b></a>]  Theorem

      |- (LIST_REL R [] [] ⇔ T) ∧ (LIST_REL R (a::as) [] ⇔ F) ∧
         (LIST_REL R [] (b::bs) ⇔ F) ∧
         (LIST_REL R (a::as) (b::bs) ⇔ R a b ∧ LIST_REL R as bs)

   [<a name="LIST_REL_ind-val"><b>LIST_REL_ind</b></a>]  Theorem

      |- ∀R LIST_REL'.
           LIST_REL' [] [] ∧
           (∀h1 h2 t1 t2.
              R h1 h2 ∧ LIST_REL' t1 t2 ⇒ LIST_REL' (h1::t1) (h2::t2)) ⇒
           ∀a0 a1. LIST_REL R a0 a1 ⇒ LIST_REL' a0 a1

   [<a name="LIST_REL_mono-val"><b>LIST_REL_mono</b></a>]  Theorem

      |- (∀x y. R1 x y ⇒ R2 x y) ⇒ LIST_REL R1 l1 l2 ⇒ LIST_REL R2 l1 l2

   [<a name="LIST_REL_rules-val"><b>LIST_REL_rules</b></a>]  Theorem

      |- ∀R.
           LIST_REL R [] [] ∧
           ∀h1 h2 t1 t2.
             R h1 h2 ∧ LIST_REL R t1 t2 ⇒ LIST_REL R (h1::t1) (h2::t2)

   [<a name="LIST_REL_strongind-val"><b>LIST_REL_strongind</b></a>]  Theorem

      |- ∀R LIST_REL'.
           LIST_REL' [] [] ∧
           (∀h1 h2 t1 t2.
              R h1 h2 ∧ LIST_REL R t1 t2 ∧ LIST_REL' t1 t2 ⇒
              LIST_REL' (h1::t1) (h2::t2)) ⇒
           ∀a0 a1. LIST_REL R a0 a1 ⇒ LIST_REL' a0 a1

   [<a name="LIST_TO_SET-val"><b>LIST_TO_SET</b></a>]  Theorem

      |- (set [] = ∅) ∧ (set (h::t) = h INSERT set t)

   [<a name="LIST_TO_SET_APPEND-val"><b>LIST_TO_SET_APPEND</b></a>]  Theorem

      |- ∀l1 l2. set (l1 ++ l2) = set l1 ∪ set l2

   [<a name="LIST_TO_SET_EQ_EMPTY-val"><b>LIST_TO_SET_EQ_EMPTY</b></a>]  Theorem

      |- ((set l = ∅) ⇔ (l = [])) ∧ ((∅ = set l) ⇔ (l = []))

   [<a name="LIST_TO_SET_FILTER-val"><b>LIST_TO_SET_FILTER</b></a>]  Theorem

      |- set (FILTER P l) = {x | P x} ∩ set l

   [<a name="LIST_TO_SET_MAP-val"><b>LIST_TO_SET_MAP</b></a>]  Theorem

      |- ∀f l. set (MAP f l) = IMAGE f (set l)

   [<a name="LIST_TO_SET_REVERSE-val"><b>LIST_TO_SET_REVERSE</b></a>]  Theorem

      |- ∀ls. set (REVERSE ls) = set ls

   [<a name="LIST_TO_SET_SNOC-val"><b>LIST_TO_SET_SNOC</b></a>]  Theorem

      |- set (SNOC x ls) = x INSERT set ls

   [<a name="LIST_TO_SET_THM-val"><b>LIST_TO_SET_THM</b></a>]  Theorem

      |- (set [] = ∅) ∧ (set (h::t) = h INSERT set t)

   [<a name="LRC_MEM-val"><b>LRC_MEM</b></a>]  Theorem

      |- LRC R ls x y ∧ MEM e ls ⇒ ∃z t. R e z ∧ LRC R t z y

   [<a name="LRC_MEM_right-val"><b>LRC_MEM_right</b></a>]  Theorem

      |- LRC R (h::t) x y ∧ MEM e t ⇒ ∃z p. R z e ∧ LRC R p x z

   [<a name="LUPDATE_LENGTH-val"><b>LUPDATE_LENGTH</b></a>]  Theorem

      |- ∀xs x y ys. LUPDATE x (LENGTH xs) (xs ++ y::ys) = xs ++ x::ys

   [<a name="LUPDATE_SEM-val"><b>LUPDATE_SEM</b></a>]  Theorem

      |- (∀e n l. LENGTH (LUPDATE e n l) = LENGTH l) ∧
         ∀e n l p.
           p &lt; LENGTH l ⇒
           (EL p (LUPDATE e n l) = if p = n then e else EL p l)

   [<a name="LUPDATE_SNOC-val"><b>LUPDATE_SNOC</b></a>]  Theorem

      |- ∀ys k x y.
           LUPDATE x k (SNOC y ys) =
           if k = LENGTH ys then SNOC x ys else SNOC y (LUPDATE x k ys)

   [<a name="LUPDATE_compute-val"><b>LUPDATE_compute</b></a>]  Theorem

      |- (∀e n. LUPDATE e n [] = []) ∧
         (∀e x l. LUPDATE e 0 (x::l) = e::l) ∧
         (∀e n x l.
            LUPDATE e (NUMERAL (BIT1 n)) (x::l) =
            x::LUPDATE e (NUMERAL (BIT1 n) − 1) l) ∧
         ∀e n x l.
           LUPDATE e (NUMERAL (BIT2 n)) (x::l) =
           x::LUPDATE e (NUMERAL (BIT1 n)) l

   [<a name="MAP2-val"><b>MAP2</b></a>]  Theorem

      |- (∀f. MAP2 f [] [] = []) ∧
         ∀f h1 t1 h2 t2. MAP2 f (h1::t1) (h2::t2) = f h1 h2::MAP2 f t1 t2

   [<a name="MAP2_CONG-val"><b>MAP2_CONG</b></a>]  Theorem

      |- ∀l1 l1' l2 l2' f f'.
           (l1 = l1') ∧ (l2 = l2') ∧
           (∀x y. MEM x l1' ∧ MEM y l2' ⇒ (f x y = f' x y)) ⇒
           (MAP2 f l1 l2 = MAP2 f' l1' l2')

   [<a name="MAP2_MAP-val"><b>MAP2_MAP</b></a>]  Theorem

      |- ∀l1 l2.
           (LENGTH l1 = LENGTH l2) ⇒
           ∀f. MAP2 f l1 l2 = MAP (UNCURRY f) (ZIP (l1,l2))

   [<a name="MAP2_ZIP-val"><b>MAP2_ZIP</b></a>]  Theorem

      |- ∀l1 l2.
           (LENGTH l1 = LENGTH l2) ⇒
           ∀f. MAP2 f l1 l2 = MAP (UNCURRY f) (ZIP (l1,l2))

   [<a name="MAP2_def-val"><b>MAP2_def</b></a>]  Theorem

      |- (∀t2 t1 h2 h1 f.
            MAP2 f (h1::t1) (h2::t2) = f h1 h2::MAP2 f t1 t2) ∧
         (∀y f. MAP2 f [] y = []) ∧ ∀v5 v4 f. MAP2 f (v4::v5) [] = []

   [<a name="MAP2_ind-val"><b>MAP2_ind</b></a>]  Theorem

      |- ∀P.
           (∀f h1 t1 h2 t2. P f t1 t2 ⇒ P f (h1::t1) (h2::t2)) ∧
           (∀f y. P f [] y) ∧ (∀f v4 v5. P f (v4::v5) []) ⇒
           ∀v v1 v2. P v v1 v2

   [<a name="MAP_APPEND-val"><b>MAP_APPEND</b></a>]  Theorem

      |- ∀f l1 l2. MAP f (l1 ++ l2) = MAP f l1 ++ MAP f l2

   [<a name="MAP_CONG-val"><b>MAP_CONG</b></a>]  Theorem

      |- ∀l1 l2 f f'.
           (l1 = l2) ∧ (∀x. MEM x l2 ⇒ (f x = f' x)) ⇒
           (MAP f l1 = MAP f' l2)

   [<a name="MAP_EQ_EVERY2-val"><b>MAP_EQ_EVERY2</b></a>]  Theorem

      |- ∀f1 f2 l1 l2.
           (MAP f1 l1 = MAP f2 l2) ⇔
           (LENGTH l1 = LENGTH l2) ∧ LIST_REL (λx y. f1 x = f2 y) l1 l2

   [<a name="MAP_EQ_NIL-val"><b>MAP_EQ_NIL</b></a>]  Theorem

      |- ∀l f. ((MAP f l = []) ⇔ (l = [])) ∧ (([] = MAP f l) ⇔ (l = []))

   [<a name="MAP_EQ_f-val"><b>MAP_EQ_f</b></a>]  Theorem

      |- ∀f1 f2 l. (MAP f1 l = MAP f2 l) ⇔ ∀e. MEM e l ⇒ (f1 e = f2 e)

   [<a name="MAP_GENLIST-val"><b>MAP_GENLIST</b></a>]  Theorem

      |- ∀f g n. MAP f (GENLIST g n) = GENLIST (f o g) n

   [<a name="MAP_ID-val"><b>MAP_ID</b></a>]  Theorem

      |- (MAP (λx. x) l = l) ∧ (MAP I l = l)

   [<a name="MAP_MAP_o-val"><b>MAP_MAP_o</b></a>]  Theorem

      |- ∀f g l. MAP f (MAP g l) = MAP (f o g) l

   [<a name="MAP_SNOC-val"><b>MAP_SNOC</b></a>]  Theorem

      |- ∀f x l. MAP f (SNOC x l) = SNOC (f x) (MAP f l)

   [<a name="MAP_TL-val"><b>MAP_TL</b></a>]  Theorem

      |- ∀l f. ¬NULL l ⇒ (MAP f (TL l) = TL (MAP f l))

   [<a name="MAP_ZIP-val"><b>MAP_ZIP</b></a>]  Theorem

      |- (LENGTH l1 = LENGTH l2) ⇒
         (MAP FST (ZIP (l1,l2)) = l1) ∧ (MAP SND (ZIP (l1,l2)) = l2) ∧
         (MAP (f o FST) (ZIP (l1,l2)) = MAP f l1) ∧
         (MAP (g o SND) (ZIP (l1,l2)) = MAP g l2)

   [<a name="MAP_ZIP_SAME-val"><b>MAP_ZIP_SAME</b></a>]  Theorem

      |- ∀ls f. MAP f (ZIP (ls,ls)) = MAP (λx. f (x,x)) ls

   [<a name="MAP_o-val"><b>MAP_o</b></a>]  Theorem

      |- ∀f g. MAP (f o g) = MAP f o MAP g

   [<a name="MEM-val"><b>MEM</b></a>]  Theorem

      |- (∀x. MEM x [] ⇔ F) ∧ ∀x h t. MEM x (h::t) ⇔ (x = h) ∨ MEM x t

   [<a name="MEM_APPEND-val"><b>MEM_APPEND</b></a>]  Theorem

      |- ∀e l1 l2. MEM e (l1 ++ l2) ⇔ MEM e l1 ∨ MEM e l2

   [<a name="MEM_DROP-val"><b>MEM_DROP</b></a>]  Theorem

      |- ∀x ls n.
           MEM x (DROP n ls) ⇔
           n &lt; LENGTH ls ∧ (x = EL n ls) ∨ MEM x (DROP (SUC n) ls)

   [<a name="MEM_EL-val"><b>MEM_EL</b></a>]  Theorem

      |- ∀l x. MEM x l ⇔ ∃n. n &lt; LENGTH l ∧ (x = EL n l)

   [<a name="MEM_FILTER-val"><b>MEM_FILTER</b></a>]  Theorem

      |- ∀P L x. MEM x (FILTER P L) ⇔ P x ∧ MEM x L

   [<a name="MEM_FLAT-val"><b>MEM_FLAT</b></a>]  Theorem

      |- ∀x L. MEM x (FLAT L) ⇔ ∃l. MEM l L ∧ MEM x l

   [<a name="MEM_GENLIST-val"><b>MEM_GENLIST</b></a>]  Theorem

      |- MEM x (GENLIST f n) ⇔ ∃m. m &lt; n ∧ (x = f m)

   [<a name="MEM_LUPDATE-val"><b>MEM_LUPDATE</b></a>]  Theorem

      |- ∀l x y i.
           MEM x (LUPDATE y i l) ⇔
           i &lt; LENGTH l ∧ (x = y) ∨ ∃j. j &lt; LENGTH l ∧ i ≠ j ∧ (EL j l = x)

   [<a name="MEM_LUPDATE_E-val"><b>MEM_LUPDATE_E</b></a>]  Theorem

      |- ∀l x y i. MEM x (LUPDATE y i l) ⇒ (x = y) ∨ MEM x l

   [<a name="MEM_MAP-val"><b>MEM_MAP</b></a>]  Theorem

      |- ∀l f x. MEM x (MAP f l) ⇔ ∃y. (x = f y) ∧ MEM y l

   [<a name="MEM_REVERSE-val"><b>MEM_REVERSE</b></a>]  Theorem

      |- ∀l x. MEM x (REVERSE l) ⇔ MEM x l

   [<a name="MEM_SET_TO_LIST-val"><b>MEM_SET_TO_LIST</b></a>]  Theorem

      |- ∀s. FINITE s ⇒ ∀x. MEM x (SET_TO_LIST s) ⇔ x ∈ s

   [<a name="MEM_SNOC-val"><b>MEM_SNOC</b></a>]  Theorem

      |- ∀y x l. MEM y (SNOC x l) ⇔ (y = x) ∨ MEM y l

   [<a name="MEM_SPLIT-val"><b>MEM_SPLIT</b></a>]  Theorem

      |- ∀x l. MEM x l ⇔ ∃l1 l2. l = l1 ++ x::l2

   [<a name="MEM_SPLIT_APPEND_first-val"><b>MEM_SPLIT_APPEND_first</b></a>]  Theorem

      |- MEM e l ⇔ ∃pfx sfx. (l = pfx ++ [e] ++ sfx) ∧ e ∉ set pfx

   [<a name="MEM_SPLIT_APPEND_last-val"><b>MEM_SPLIT_APPEND_last</b></a>]  Theorem

      |- MEM e l ⇔ ∃pfx sfx. (l = pfx ++ [e] ++ sfx) ∧ e ∉ set sfx

   [<a name="MEM_ZIP-val"><b>MEM_ZIP</b></a>]  Theorem

      |- ∀l1 l2 p.
           (LENGTH l1 = LENGTH l2) ⇒
           (MEM p (ZIP (l1,l2)) ⇔
            ∃n. n &lt; LENGTH l1 ∧ (p = (EL n l1,EL n l2)))

   [<a name="MONO_EVERY-val"><b>MONO_EVERY</b></a>]  Theorem

      |- (∀x. P x ⇒ Q x) ⇒ EVERY P l ⇒ EVERY Q l

   [<a name="MONO_EXISTS-val"><b>MONO_EXISTS</b></a>]  Theorem

      |- (∀x. P x ⇒ Q x) ⇒ EXISTS P l ⇒ EXISTS Q l

   [<a name="NOT_CONS_NIL-val"><b>NOT_CONS_NIL</b></a>]  Theorem

      |- ∀a1 a0. a0::a1 ≠ []

   [<a name="NOT_EQ_LIST-val"><b>NOT_EQ_LIST</b></a>]  Theorem

      |- ∀h1 h2. h1 ≠ h2 ⇒ ∀l1 l2. h1::l1 ≠ h2::l2

   [<a name="NOT_EVERY-val"><b>NOT_EVERY</b></a>]  Theorem

      |- ∀P l. ¬EVERY P l ⇔ EXISTS ($~ o P) l

   [<a name="NOT_EXISTS-val"><b>NOT_EXISTS</b></a>]  Theorem

      |- ∀P l. ¬EXISTS P l ⇔ EVERY ($~ o P) l

   [<a name="NOT_NIL_CONS-val"><b>NOT_NIL_CONS</b></a>]  Theorem

      |- ∀a1 a0. [] ≠ a0::a1

   [<a name="NOT_NULL_MEM-val"><b>NOT_NULL_MEM</b></a>]  Theorem

      |- ∀l. ¬NULL l ⇔ ∃e. MEM e l

   [<a name="NRC_LRC-val"><b>NRC_LRC</b></a>]  Theorem

      |- NRC R n x y ⇔ ∃ls. LRC R ls x y ∧ (LENGTH ls = n)

   [<a name="NULL-val"><b>NULL</b></a>]  Theorem

      |- NULL [] ∧ ∀h t. ¬NULL (h::t)

   [<a name="NULL_EQ-val"><b>NULL_EQ</b></a>]  Theorem

      |- ∀l. NULL l ⇔ (l = [])

   [<a name="NULL_FILTER-val"><b>NULL_FILTER</b></a>]  Theorem

      |- ∀P ls. NULL (FILTER P ls) ⇔ ∀x. MEM x ls ⇒ ¬P x

   [<a name="NULL_GENLIST-val"><b>NULL_GENLIST</b></a>]  Theorem

      |- ∀n f. NULL (GENLIST f n) ⇔ (n = 0)

   [<a name="NULL_LENGTH-val"><b>NULL_LENGTH</b></a>]  Theorem

      |- ∀l. NULL l ⇔ (LENGTH l = 0)

   [<a name="REVERSE_11-val"><b>REVERSE_11</b></a>]  Theorem

      |- ∀l1 l2. (REVERSE l1 = REVERSE l2) ⇔ (l1 = l2)

   [<a name="REVERSE_APPEND-val"><b>REVERSE_APPEND</b></a>]  Theorem

      |- ∀l1 l2. REVERSE (l1 ++ l2) = REVERSE l2 ++ REVERSE l1

   [<a name="REVERSE_EQ_NIL-val"><b>REVERSE_EQ_NIL</b></a>]  Theorem

      |- (REVERSE l = []) ⇔ (l = [])

   [<a name="REVERSE_EQ_SING-val"><b>REVERSE_EQ_SING</b></a>]  Theorem

      |- (REVERSE l = [e]) ⇔ (l = [e])

   [<a name="REVERSE_GENLIST-val"><b>REVERSE_GENLIST</b></a>]  Theorem

      |- REVERSE (GENLIST f n) = GENLIST (λm. f (PRE n − m)) n

   [<a name="REVERSE_REV-val"><b>REVERSE_REV</b></a>]  Theorem

      |- ∀L. REVERSE L = REV L []

   [<a name="REVERSE_REVERSE-val"><b>REVERSE_REVERSE</b></a>]  Theorem

      |- ∀l. REVERSE (REVERSE l) = l

   [<a name="REVERSE_SNOC-val"><b>REVERSE_SNOC</b></a>]  Theorem

      |- ∀x l. REVERSE (SNOC x l) = x::REVERSE l

   [<a name="REVERSE_SNOC_DEF-val"><b>REVERSE_SNOC_DEF</b></a>]  Theorem

      |- (REVERSE [] = []) ∧ ∀x l. REVERSE (x::l) = SNOC x (REVERSE l)

   [<a name="REV_REVERSE_LEM-val"><b>REV_REVERSE_LEM</b></a>]  Theorem

      |- ∀L1 L2. REV L1 L2 = REVERSE L1 ++ L2

   [<a name="SET_TO_LIST_CARD-val"><b>SET_TO_LIST_CARD</b></a>]  Theorem

      |- ∀s. FINITE s ⇒ (LENGTH (SET_TO_LIST s) = CARD s)

   [<a name="SET_TO_LIST_EMPTY-val"><b>SET_TO_LIST_EMPTY</b></a>]  Theorem

      |- SET_TO_LIST ∅ = []

   [<a name="SET_TO_LIST_IND-val"><b>SET_TO_LIST_IND</b></a>]  Theorem

      |- ∀P. (∀s. (FINITE s ∧ s ≠ ∅ ⇒ P (REST s)) ⇒ P s) ⇒ ∀v. P v

   [<a name="SET_TO_LIST_INV-val"><b>SET_TO_LIST_INV</b></a>]  Theorem

      |- ∀s. FINITE s ⇒ (set (SET_TO_LIST s) = s)

   [<a name="SET_TO_LIST_IN_MEM-val"><b>SET_TO_LIST_IN_MEM</b></a>]  Theorem

      |- ∀s. FINITE s ⇒ ∀x. x ∈ s ⇔ MEM x (SET_TO_LIST s)

   [<a name="SET_TO_LIST_SING-val"><b>SET_TO_LIST_SING</b></a>]  Theorem

      |- SET_TO_LIST {x} = [x]

   [<a name="SET_TO_LIST_THM-val"><b>SET_TO_LIST_THM</b></a>]  Theorem

      |- FINITE s ⇒
         (SET_TO_LIST s =
          if s = ∅ then [] else CHOICE s::SET_TO_LIST (REST s))

   [<a name="SNOC_11-val"><b>SNOC_11</b></a>]  Theorem

      |- ∀x y a b. (SNOC x y = SNOC a b) ⇔ (x = a) ∧ (y = b)

   [<a name="SNOC_APPEND-val"><b>SNOC_APPEND</b></a>]  Theorem

      |- ∀x l. SNOC x l = l ++ [x]

   [<a name="SNOC_Axiom-val"><b>SNOC_Axiom</b></a>]  Theorem

      |- ∀e f. ∃fn. (fn [] = e) ∧ ∀x l. fn (SNOC x l) = f x l (fn l)

   [<a name="SNOC_CASES-val"><b>SNOC_CASES</b></a>]  Theorem

      |- ∀ll. (ll = []) ∨ ∃x l. ll = SNOC x l

   [<a name="SNOC_INDUCT-val"><b>SNOC_INDUCT</b></a>]  Theorem

      |- ∀P. P [] ∧ (∀l. P l ⇒ ∀x. P (SNOC x l)) ⇒ ∀l. P l

   [<a name="SUM_ACC_SUM_LEM-val"><b>SUM_ACC_SUM_LEM</b></a>]  Theorem

      |- ∀L n. SUM_ACC L n = SUM L + n

   [<a name="SUM_APPEND-val"><b>SUM_APPEND</b></a>]  Theorem

      |- ∀l1 l2. SUM (l1 ++ l2) = SUM l1 + SUM l2

   [<a name="SUM_IMAGE_LIST_TO_SET_upper_bound-val"><b>SUM_IMAGE_LIST_TO_SET_upper_bound</b></a>]  Theorem

      |- ∀ls. ∑ f (set ls) ≤ SUM (MAP f ls)

   [<a name="SUM_IMAGE_eq_SUM_MAP_SET_TO_LIST-val"><b>SUM_IMAGE_eq_SUM_MAP_SET_TO_LIST</b></a>]  Theorem

      |- FINITE s ⇒ (∑ f s = SUM (MAP f (SET_TO_LIST s)))

   [<a name="SUM_MAP_FOLDL-val"><b>SUM_MAP_FOLDL</b></a>]  Theorem

      |- ∀ls. SUM (MAP f ls) = FOLDL (λa e. a + f e) 0 ls

   [<a name="SUM_MAP_MEM_bound-val"><b>SUM_MAP_MEM_bound</b></a>]  Theorem

      |- ∀f x ls. MEM x ls ⇒ f x ≤ SUM (MAP f ls)

   [<a name="SUM_MAP_PLUS_ZIP-val"><b>SUM_MAP_PLUS_ZIP</b></a>]  Theorem

      |- ∀ls1 ls2.
           (LENGTH ls1 = LENGTH ls2) ∧ (∀x y. f (x,y) = g x + h y) ⇒
           (SUM (MAP f (ZIP (ls1,ls2))) =
            SUM (MAP g ls1) + SUM (MAP h ls2))

   [<a name="SUM_SNOC-val"><b>SUM_SNOC</b></a>]  Theorem

      |- ∀x l. SUM (SNOC x l) = SUM l + x

   [<a name="SUM_SUM_ACC-val"><b>SUM_SUM_ACC</b></a>]  Theorem

      |- ∀L. SUM L = SUM_ACC L 0

   [<a name="SUM_eq_0-val"><b>SUM_eq_0</b></a>]  Theorem

      |- ∀ls. (SUM ls = 0) ⇔ ∀x. MEM x ls ⇒ (x = 0)

   [<a name="TAKE_0-val"><b>TAKE_0</b></a>]  Theorem

      |- TAKE 0 l = []

   [<a name="TAKE_APPEND1-val"><b>TAKE_APPEND1</b></a>]  Theorem

      |- ∀n. n ≤ LENGTH l1 ⇒ (TAKE n (l1 ++ l2) = TAKE n l1)

   [<a name="TAKE_APPEND2-val"><b>TAKE_APPEND2</b></a>]  Theorem

      |- ∀n.
           LENGTH l1 &lt; n ⇒
           (TAKE n (l1 ++ l2) = l1 ++ TAKE (n − LENGTH l1) l2)

   [<a name="TAKE_DROP-val"><b>TAKE_DROP</b></a>]  Theorem

      |- ∀n l. TAKE n l ++ DROP n l = l

   [<a name="TAKE_LENGTH_ID-val"><b>TAKE_LENGTH_ID</b></a>]  Theorem

      |- ∀l. TAKE (LENGTH l) l = l

   [<a name="TAKE_LENGTH_TOO_LONG-val"><b>TAKE_LENGTH_TOO_LONG</b></a>]  Theorem

      |- ∀l n. LENGTH l ≤ n ⇒ (TAKE n l = l)

   [<a name="TAKE_compute-val"><b>TAKE_compute</b></a>]  Theorem

      |- (∀l. TAKE 0 l = []) ∧ (∀n. TAKE (NUMERAL (BIT1 n)) [] = []) ∧
         (∀n. TAKE (NUMERAL (BIT2 n)) [] = []) ∧
         (∀n h t.
            TAKE (NUMERAL (BIT1 n)) (h::t) =
            h::TAKE (NUMERAL (BIT1 n) − 1) t) ∧
         ∀n h t.
           TAKE (NUMERAL (BIT2 n)) (h::t) = h::TAKE (NUMERAL (BIT1 n)) t

   [<a name="TAKE_splitAtPki-val"><b>TAKE_splitAtPki</b></a>]  Theorem

      |- TAKE n l = splitAtPki (K o $= n) K l

   [<a name="TL_GENLIST-val"><b>TL_GENLIST</b></a>]  Theorem

      |- ∀f n. TL (GENLIST f (SUC n)) = GENLIST (f o SUC) n

   [<a name="UNION_APPEND-val"><b>UNION_APPEND</b></a>]  Theorem

      |- ∀l1 l2. set l1 ∪ set l2 = set (l1 ++ l2)

   [<a name="UNZIP_MAP-val"><b>UNZIP_MAP</b></a>]  Theorem

      |- ∀L. UNZIP L = (MAP FST L,MAP SND L)

   [<a name="UNZIP_THM-val"><b>UNZIP_THM</b></a>]  Theorem

      |- (UNZIP [] = ([],[])) ∧
         (UNZIP ((x,y)::t) = (let (L1,L2) = UNZIP t in (x::L1,y::L2)))

   [<a name="UNZIP_ZIP-val"><b>UNZIP_ZIP</b></a>]  Theorem

      |- ∀l1 l2. (LENGTH l1 = LENGTH l2) ⇒ (UNZIP (ZIP (l1,l2)) = (l1,l2))

   [<a name="WF_LIST_PRED-val"><b>WF_LIST_PRED</b></a>]  Theorem

      |- WF (λL1 L2. ∃h. L2 = h::L1)

   [<a name="ZIP_GENLIST-val"><b>ZIP_GENLIST</b></a>]  Theorem

      |- ∀l f n.
           (LENGTH l = n) ⇒
           (ZIP (l,GENLIST f n) = GENLIST (λx. (EL x l,f x)) n)

   [<a name="ZIP_MAP-val"><b>ZIP_MAP</b></a>]  Theorem

      |- ∀l1 l2 f1 f2.
           (LENGTH l1 = LENGTH l2) ⇒
           (ZIP (MAP f1 l1,l2) =
            MAP (λp. (f1 (FST p),SND p)) (ZIP (l1,l2))) ∧
           (ZIP (l1,MAP f2 l2) =
            MAP (λp. (FST p,f2 (SND p))) (ZIP (l1,l2)))

   [<a name="ZIP_UNZIP-val"><b>ZIP_UNZIP</b></a>]  Theorem

      |- ∀l. ZIP (UNZIP l) = l

   [<a name="datatype_list-val"><b>datatype_list</b></a>]  Theorem

      |- DATATYPE (list [] CONS)

   [<a name="isPREFIX_THM-val"><b>isPREFIX_THM</b></a>]  Theorem

      |- ([] ≼ l ⇔ T) ∧ (h::t ≼ [] ⇔ F) ∧
         (h1::t1 ≼ h2::t2 ⇔ (h1 = h2) ∧ t1 ≼ t2)

   [<a name="list_11-val"><b>list_11</b></a>]  Theorem

      |- ∀a0 a1 a0' a1'. (a0::a1 = a0'::a1') ⇔ (a0 = a0') ∧ (a1 = a1')

   [<a name="list_Axiom-val"><b>list_Axiom</b></a>]  Theorem

      |- ∀f0 f1. ∃fn. (fn [] = f0) ∧ ∀a0 a1. fn (a0::a1) = f1 a0 a1 (fn a1)

   [<a name="list_Axiom_old-val"><b>list_Axiom_old</b></a>]  Theorem

      |- ∀x f. ∃!fn1. (fn1 [] = x) ∧ ∀h t. fn1 (h::t) = f (fn1 t) h t

   [<a name="list_CASES-val"><b>list_CASES</b></a>]  Theorem

      |- ∀l. (l = []) ∨ ∃t h. l = h::t

   [<a name="list_INDUCT-val"><b>list_INDUCT</b></a>]  Theorem

      |- ∀P. P [] ∧ (∀t. P t ⇒ ∀h. P (h::t)) ⇒ ∀l. P l

   [<a name="list_case_compute-val"><b>list_case_compute</b></a>]  Theorem

      |- ∀l. list_CASE l b f = if NULL l then b else f (HD l) (TL l)

   [<a name="list_case_cong-val"><b>list_case_cong</b></a>]  Theorem

      |- ∀M M' v f.
           (M = M') ∧ ((M' = []) ⇒ (v = v')) ∧
           (∀a0 a1. (M' = a0::a1) ⇒ (f a0 a1 = f' a0 a1)) ⇒
           (list_CASE M v f = list_CASE M' v' f')

   [<a name="list_distinct-val"><b>list_distinct</b></a>]  Theorem

      |- ∀a1 a0. [] ≠ a0::a1

   [<a name="list_induction-val"><b>list_induction</b></a>]  Theorem

      |- ∀P. P [] ∧ (∀t. P t ⇒ ∀h. P (h::t)) ⇒ ∀l. P l

   [<a name="list_nchotomy-val"><b>list_nchotomy</b></a>]  Theorem

      |- ∀l. (l = []) ∨ ∃t h. l = h::t

   [<a name="list_size_cong-val"><b>list_size_cong</b></a>]  Theorem

      |- ∀M N f f'.
           (M = N) ∧ (∀x. MEM x N ⇒ (f x = f' x)) ⇒
           (list_size f M = list_size f' N)

   [<a name="splitAtPki_APPEND-val"><b>splitAtPki_APPEND</b></a>]  Theorem

      |- ∀l1 l2 P k.
           EVERYi (λi. $~ o P i) l1 ∧
           (0 &lt; LENGTH l2 ⇒ P (LENGTH l1) (HD l2)) ⇒
           (splitAtPki P k (l1 ++ l2) = k l1 l2)

   [<a name="splitAtPki_EQN-val"><b>splitAtPki_EQN</b></a>]  Theorem

      |- splitAtPki P k l =
         case OLEAST i. i &lt; LENGTH l ∧ P i (EL i l) of
           NONE =&gt; k l []
         | SOME i =&gt; k (TAKE i l) (DROP i l)


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/list/src/listScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-9</a></em></p></body></html>
