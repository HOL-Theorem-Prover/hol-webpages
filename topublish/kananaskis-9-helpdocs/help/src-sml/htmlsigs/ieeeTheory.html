<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure ieeeTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure ieeeTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/float/ieeeScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature ieeeTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#Exponent-val">Exponent</a> : thm
<a name="line7"></a>    val <a href="#Finite-val">Finite</a> : thm
<a name="line8"></a>    val <a href="#Float-val">Float</a> : thm
<a name="line9"></a>    val <a href="#Fraction-val">Fraction</a> : thm
<a name="line10"></a>    val <a href="#Infinity-val">Infinity</a> : thm
<a name="line11"></a>    val <a href="#Isdenormal-val">Isdenormal</a> : thm
<a name="line12"></a>    val <a href="#Isintegral-val">Isintegral</a> : thm
<a name="line13"></a>    val <a href="#Isnan-val">Isnan</a> : thm
<a name="line14"></a>    val <a href="#Isnormal-val">Isnormal</a> : thm
<a name="line15"></a>    val <a href="#Iszero-val">Iszero</a> : thm
<a name="line16"></a>    val <a href="#Minus_infinity-val">Minus_infinity</a> : thm
<a name="line17"></a>    val <a href="#Minus_zero-val">Minus_zero</a> : thm
<a name="line18"></a>    val <a href="#Plus_infinity-val">Plus_infinity</a> : thm
<a name="line19"></a>    val <a href="#Plus_zero-val">Plus_zero</a> : thm
<a name="line20"></a>    val <a href="#ROUNDFLOAT-val">ROUNDFLOAT</a> : thm
<a name="line21"></a>    val <a href="#Sign-val">Sign</a> : thm
<a name="line22"></a>    val <a href="#Ulp-val">Ulp</a> : thm
<a name="line23"></a>    val <a href="#Val-val">Val</a> : thm
<a name="line24"></a>    val <a href="#bias-val">bias</a> : thm
<a name="line25"></a>    val <a href="#bottomfloat-val">bottomfloat</a> : thm
<a name="line26"></a>    val <a href="#ccode_BIJ-val">ccode_BIJ</a> : thm
<a name="line27"></a>    val <a href="#ccode_CASE-val">ccode_CASE</a> : thm
<a name="line28"></a>    val <a href="#ccode_TY_DEF-val">ccode_TY_DEF</a> : thm
<a name="line29"></a>    val <a href="#ccode_size_def-val">ccode_size_def</a> : thm
<a name="line30"></a>    val <a href="#closest-val">closest</a> : thm
<a name="line31"></a>    val <a href="#emax-val">emax</a> : thm
<a name="line32"></a>    val <a href="#encoding-val">encoding</a> : thm
<a name="line33"></a>    val <a href="#exponent-val">exponent</a> : thm
<a name="line34"></a>    val <a href="#expwidth-val">expwidth</a> : thm
<a name="line35"></a>    val <a href="#fadd-val">fadd</a> : thm
<a name="line36"></a>    val <a href="#fcompare-val">fcompare</a> : thm
<a name="line37"></a>    val <a href="#fdiv-val">fdiv</a> : thm
<a name="line38"></a>    val <a href="#feq-val">feq</a> : thm
<a name="line39"></a>    val <a href="#fge-val">fge</a> : thm
<a name="line40"></a>    val <a href="#fgt-val">fgt</a> : thm
<a name="line41"></a>    val <a href="#fintrnd-val">fintrnd</a> : thm
<a name="line42"></a>    val <a href="#fle-val">fle</a> : thm
<a name="line43"></a>    val <a href="#float_TY_DEF-val">float_TY_DEF</a> : thm
<a name="line44"></a>    val <a href="#float_abs-val">float_abs</a> : thm
<a name="line45"></a>    val <a href="#float_add-val">float_add</a> : thm
<a name="line46"></a>    val <a href="#float_div-val">float_div</a> : thm
<a name="line47"></a>    val <a href="#float_eq-val">float_eq</a> : thm
<a name="line48"></a>    val <a href="#float_format-val">float_format</a> : thm
<a name="line49"></a>    val <a href="#float_ge-val">float_ge</a> : thm
<a name="line50"></a>    val <a href="#float_gt-val">float_gt</a> : thm
<a name="line51"></a>    val <a href="#float_le-val">float_le</a> : thm
<a name="line52"></a>    val <a href="#float_lt-val">float_lt</a> : thm
<a name="line53"></a>    val <a href="#float_mul-val">float_mul</a> : thm
<a name="line54"></a>    val <a href="#float_neg-val">float_neg</a> : thm
<a name="line55"></a>    val <a href="#float_rem-val">float_rem</a> : thm
<a name="line56"></a>    val <a href="#float_sqrt-val">float_sqrt</a> : thm
<a name="line57"></a>    val <a href="#float_sub-val">float_sub</a> : thm
<a name="line58"></a>    val <a href="#float_tybij-val">float_tybij</a> : thm
<a name="line59"></a>    val <a href="#flt-val">flt</a> : thm
<a name="line60"></a>    val <a href="#fmul-val">fmul</a> : thm
<a name="line61"></a>    val <a href="#fneg-val">fneg</a> : thm
<a name="line62"></a>    val <a href="#fraction-val">fraction</a> : thm
<a name="line63"></a>    val <a href="#fracwidth-val">fracwidth</a> : thm
<a name="line64"></a>    val <a href="#frem-val">frem</a> : thm
<a name="line65"></a>    val <a href="#fsqrt-val">fsqrt</a> : thm
<a name="line66"></a>    val <a href="#fsub-val">fsub</a> : thm
<a name="line67"></a>    val <a href="#intround_def-val">intround_def</a> : thm
<a name="line68"></a>    val <a href="#is_closest-val">is_closest</a> : thm
<a name="line69"></a>    val <a href="#is_denormal-val">is_denormal</a> : thm
<a name="line70"></a>    val <a href="#is_double-val">is_double</a> : thm
<a name="line71"></a>    val <a href="#is_double_extended-val">is_double_extended</a> : thm
<a name="line72"></a>    val <a href="#is_finite-val">is_finite</a> : thm
<a name="line73"></a>    val <a href="#is_infinity-val">is_infinity</a> : thm
<a name="line74"></a>    val <a href="#is_integral-val">is_integral</a> : thm
<a name="line75"></a>    val <a href="#is_nan-val">is_nan</a> : thm
<a name="line76"></a>    val <a href="#is_normal-val">is_normal</a> : thm
<a name="line77"></a>    val <a href="#is_single-val">is_single</a> : thm
<a name="line78"></a>    val <a href="#is_single_extended-val">is_single_extended</a> : thm
<a name="line79"></a>    val <a href="#is_valid-val">is_valid</a> : thm
<a name="line80"></a>    val <a href="#is_zero-val">is_zero</a> : thm
<a name="line81"></a>    val <a href="#largest-val">largest</a> : thm
<a name="line82"></a>    val <a href="#minus-val">minus</a> : thm
<a name="line83"></a>    val <a href="#minus_infinity-val">minus_infinity</a> : thm
<a name="line84"></a>    val <a href="#minus_zero-val">minus_zero</a> : thm
<a name="line85"></a>    val <a href="#plus_infinity-val">plus_infinity</a> : thm
<a name="line86"></a>    val <a href="#plus_zero-val">plus_zero</a> : thm
<a name="line87"></a>    val <a href="#rem-val">rem</a> : thm
<a name="line88"></a>    val <a href="#round_def-val">round_def</a> : thm
<a name="line89"></a>    val <a href="#roundmode_BIJ-val">roundmode_BIJ</a> : thm
<a name="line90"></a>    val <a href="#roundmode_CASE-val">roundmode_CASE</a> : thm
<a name="line91"></a>    val <a href="#roundmode_TY_DEF-val">roundmode_TY_DEF</a> : thm
<a name="line92"></a>    val <a href="#roundmode_size_def-val">roundmode_size_def</a> : thm
<a name="line93"></a>    val <a href="#sign-val">sign</a> : thm
<a name="line94"></a>    val <a href="#some_nan-val">some_nan</a> : thm
<a name="line95"></a>    val <a href="#threshold-val">threshold</a> : thm
<a name="line96"></a>    val <a href="#topfloat-val">topfloat</a> : thm
<a name="line97"></a>    val <a href="#ulp-val">ulp</a> : thm
<a name="line98"></a>    val <a href="#valof-val">valof</a> : thm
<a name="line99"></a>    val <a href="#wordlength-val">wordlength</a> : thm
<a name="line100"></a>    val <a href="#zerosign-val">zerosign</a> : thm
<a name="line101"></a>
<a name="line102"></a>  (*  Theorems  *)
<a name="line103"></a>    val <a href="#ccode2num_11-val">ccode2num_11</a> : thm
<a name="line104"></a>    val <a href="#ccode2num_ONTO-val">ccode2num_ONTO</a> : thm
<a name="line105"></a>    val <a href="#ccode2num_num2ccode-val">ccode2num_num2ccode</a> : thm
<a name="line106"></a>    val <a href="#ccode2num_thm-val">ccode2num_thm</a> : thm
<a name="line107"></a>    val <a href="#ccode_Axiom-val">ccode_Axiom</a> : thm
<a name="line108"></a>    val <a href="#ccode_EQ_ccode-val">ccode_EQ_ccode</a> : thm
<a name="line109"></a>    val <a href="#ccode_case_cong-val">ccode_case_cong</a> : thm
<a name="line110"></a>    val <a href="#ccode_case_def-val">ccode_case_def</a> : thm
<a name="line111"></a>    val <a href="#ccode_distinct-val">ccode_distinct</a> : thm
<a name="line112"></a>    val <a href="#ccode_induction-val">ccode_induction</a> : thm
<a name="line113"></a>    val <a href="#ccode_nchotomy-val">ccode_nchotomy</a> : thm
<a name="line114"></a>    val <a href="#datatype_ccode-val">datatype_ccode</a> : thm
<a name="line115"></a>    val <a href="#datatype_roundmode-val">datatype_roundmode</a> : thm
<a name="line116"></a>    val <a href="#num2ccode_11-val">num2ccode_11</a> : thm
<a name="line117"></a>    val <a href="#num2ccode_ONTO-val">num2ccode_ONTO</a> : thm
<a name="line118"></a>    val <a href="#num2ccode_ccode2num-val">num2ccode_ccode2num</a> : thm
<a name="line119"></a>    val <a href="#num2ccode_thm-val">num2ccode_thm</a> : thm
<a name="line120"></a>    val <a href="#num2roundmode_11-val">num2roundmode_11</a> : thm
<a name="line121"></a>    val <a href="#num2roundmode_ONTO-val">num2roundmode_ONTO</a> : thm
<a name="line122"></a>    val <a href="#num2roundmode_roundmode2num-val">num2roundmode_roundmode2num</a> : thm
<a name="line123"></a>    val <a href="#num2roundmode_thm-val">num2roundmode_thm</a> : thm
<a name="line124"></a>    val <a href="#roundmode2num_11-val">roundmode2num_11</a> : thm
<a name="line125"></a>    val <a href="#roundmode2num_ONTO-val">roundmode2num_ONTO</a> : thm
<a name="line126"></a>    val <a href="#roundmode2num_num2roundmode-val">roundmode2num_num2roundmode</a> : thm
<a name="line127"></a>    val <a href="#roundmode2num_thm-val">roundmode2num_thm</a> : thm
<a name="line128"></a>    val <a href="#roundmode_Axiom-val">roundmode_Axiom</a> : thm
<a name="line129"></a>    val <a href="#roundmode_EQ_roundmode-val">roundmode_EQ_roundmode</a> : thm
<a name="line130"></a>    val <a href="#roundmode_case_cong-val">roundmode_case_cong</a> : thm
<a name="line131"></a>    val <a href="#roundmode_case_def-val">roundmode_case_def</a> : thm
<a name="line132"></a>    val <a href="#roundmode_distinct-val">roundmode_distinct</a> : thm
<a name="line133"></a>    val <a href="#roundmode_induction-val">roundmode_induction</a> : thm
<a name="line134"></a>    val <a href="#roundmode_nchotomy-val">roundmode_nchotomy</a> : thm
<a name="line135"></a>
<a name="line136"></a>  val ieee_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line137"></a>(*
   [transc] Parent theory of "ieee"

   [<a name="Exponent-val"><b>Exponent</b></a>]  Definition

      |- ∀a. Exponent a = exponent (defloat a)

   [<a name="Finite-val"><b>Finite</b></a>]  Definition

      |- ∀a. Finite a ⇔ Isnormal a ∨ Isdenormal a ∨ Iszero a

   [<a name="Float-val"><b>Float</b></a>]  Definition

      |- ∀x. Float x = float (round float_format To_nearest x)

   [<a name="Fraction-val"><b>Fraction</b></a>]  Definition

      |- ∀a. Fraction a = fraction (defloat a)

   [<a name="Infinity-val"><b>Infinity</b></a>]  Definition

      |- ∀a. Infinity a ⇔ is_infinity float_format (defloat a)

   [<a name="Isdenormal-val"><b>Isdenormal</b></a>]  Definition

      |- ∀a. Isdenormal a ⇔ is_denormal float_format (defloat a)

   [<a name="Isintegral-val"><b>Isintegral</b></a>]  Definition

      |- ∀a. Isintegral a ⇔ is_integral float_format (defloat a)

   [<a name="Isnan-val"><b>Isnan</b></a>]  Definition

      |- ∀a. Isnan a ⇔ is_nan float_format (defloat a)

   [<a name="Isnormal-val"><b>Isnormal</b></a>]  Definition

      |- ∀a. Isnormal a ⇔ is_normal float_format (defloat a)

   [<a name="Iszero-val"><b>Iszero</b></a>]  Definition

      |- ∀a. Iszero a ⇔ is_zero float_format (defloat a)

   [<a name="Minus_infinity-val"><b>Minus_infinity</b></a>]  Definition

      |- Minus_infinity = float (minus_infinity float_format)

   [<a name="Minus_zero-val"><b>Minus_zero</b></a>]  Definition

      |- Minus_zero = float (minus_zero float_format)

   [<a name="Plus_infinity-val"><b>Plus_infinity</b></a>]  Definition

      |- Plus_infinity = float (plus_infinity float_format)

   [<a name="Plus_zero-val"><b>Plus_zero</b></a>]  Definition

      |- Plus_zero = float (plus_zero float_format)

   [<a name="ROUNDFLOAT-val"><b>ROUNDFLOAT</b></a>]  Definition

      |- ∀a.
           ROUNDFLOAT a =
           float (fintrnd float_format To_nearest (defloat a))

   [<a name="Sign-val"><b>Sign</b></a>]  Definition

      |- ∀a. Sign a = sign (defloat a)

   [<a name="Ulp-val"><b>Ulp</b></a>]  Definition

      |- ∀a. Ulp a = ulp float_format (defloat a)

   [<a name="Val-val"><b>Val</b></a>]  Definition

      |- ∀a. Val a = valof float_format (defloat a)

   [<a name="bias-val"><b>bias</b></a>]  Definition

      |- ∀X. bias X = 2 ** (expwidth X − 1) − 1

   [<a name="bottomfloat-val"><b>bottomfloat</b></a>]  Definition

      |- ∀X. bottomfloat X = (1,emax X − 1,2 ** fracwidth X − 1)

   [<a name="ccode_BIJ-val"><b>ccode_BIJ</b></a>]  Definition

      |- (∀a. num2ccode (ccode2num a) = a) ∧
         ∀r. (λn. n &lt; 4) r ⇔ (ccode2num (num2ccode r) = r)

   [<a name="ccode_CASE-val"><b>ccode_CASE</b></a>]  Definition

      |- ∀x v0 v1 v2 v3.
           (case x of Gt =&gt; v0 | Lt =&gt; v1 | Eq =&gt; v2 | Un =&gt; v3) =
           (λm.
              if m &lt; 1 then v0
              else if m &lt; 2 then v1
              else if m = 2 then v2
              else v3) (ccode2num x)

   [<a name="ccode_TY_DEF-val"><b>ccode_TY_DEF</b></a>]  Definition

      |- ∃rep. TYPE_DEFINITION (λn. n &lt; 4) rep

   [<a name="ccode_size_def-val"><b>ccode_size_def</b></a>]  Definition

      |- ∀x. ccode_size x = 0

   [<a name="closest-val"><b>closest</b></a>]  Definition

      |- ∀v p s x.
           closest v p s x =
           @a. is_closest v s x a ∧ ((∃b. is_closest v s x b ∧ p b) ⇒ p a)

   [<a name="emax-val"><b>emax</b></a>]  Definition

      |- ∀X. emax X = 2 ** expwidth X − 1

   [<a name="encoding-val"><b>encoding</b></a>]  Definition

      |- ∀X s e f.
           encoding X (s,e,f) =
           s * 2 ** (wordlength X − 1) + e * 2 ** fracwidth X + f

   [<a name="exponent-val"><b>exponent</b></a>]  Definition

      |- ∀s e f. exponent (s,e,f) = e

   [<a name="expwidth-val"><b>expwidth</b></a>]  Definition

      |- ∀ew fw. expwidth (ew,fw) = ew

   [<a name="fadd-val"><b>fadd</b></a>]  Definition

      |- ∀X m a b.
           fadd X m a b =
           if
             is_nan X a ∨ is_nan X b ∨
             is_infinity X a ∧ is_infinity X b ∧ sign a ≠ sign b
           then
             some_nan X
           else if is_infinity X a then a
           else if is_infinity X b then b
           else
             zerosign X
               (if is_zero X a ∧ is_zero X b ∧ (sign a = sign b) then
                  sign a
                else if m = To_ninfinity then 1
                else 0) (round X m (valof X a + valof X b))

   [<a name="fcompare-val"><b>fcompare</b></a>]  Definition

      |- ∀X a b.
           fcompare X a b =
           if is_nan X a ∨ is_nan X b then Un
           else if is_infinity X a ∧ (sign a = 1) then
             if is_infinity X b ∧ (sign b = 1) then Eq else Lt
           else if is_infinity X a ∧ (sign a = 0) then
             if is_infinity X b ∧ (sign b = 0) then Eq else Gt
           else if is_infinity X b ∧ (sign b = 1) then Gt
           else if is_infinity X b ∧ (sign b = 0) then Lt
           else if valof X a &lt; valof X b then Lt
           else if valof X a = valof X b then Eq
           else Gt

   [<a name="fdiv-val"><b>fdiv</b></a>]  Definition

      |- ∀X m a b.
           fdiv X m a b =
           if
             is_nan X a ∨ is_nan X b ∨ is_zero X a ∧ is_zero X b ∨
             is_infinity X a ∧ is_infinity X b
           then
             some_nan X
           else if is_infinity X a ∨ is_zero X b then
             if sign a = sign b then plus_infinity X else minus_infinity X
           else if is_infinity X b then
             if sign a = sign b then plus_zero X else minus_zero X
           else
             zerosign X (if sign a = sign b then 0 else 1)
               (round X m (valof X a / valof X b))

   [<a name="feq-val"><b>feq</b></a>]  Definition

      |- ∀X a b. feq X a b ⇔ (fcompare X a b = Eq)

   [<a name="fge-val"><b>fge</b></a>]  Definition

      |- ∀X a b. fge X a b ⇔ (fcompare X a b = Gt) ∨ (fcompare X a b = Eq)

   [<a name="fgt-val"><b>fgt</b></a>]  Definition

      |- ∀X a b. fgt X a b ⇔ (fcompare X a b = Gt)

   [<a name="fintrnd-val"><b>fintrnd</b></a>]  Definition

      |- ∀X m a.
           fintrnd X m a =
           if is_nan X a then some_nan X
           else if is_infinity X a then a
           else zerosign X (sign a) (intround X m (valof X a))

   [<a name="fle-val"><b>fle</b></a>]  Definition

      |- ∀X a b. fle X a b ⇔ (fcompare X a b = Lt) ∨ (fcompare X a b = Eq)

   [<a name="float_TY_DEF-val"><b>float_TY_DEF</b></a>]  Definition

      |- ∃rep. TYPE_DEFINITION (is_valid float_format) rep

   [<a name="float_abs-val"><b>float_abs</b></a>]  Definition

      |- ∀a. float_abs a = if a ≥ Plus_zero then a else ¬a

   [<a name="float_add-val"><b>float_add</b></a>]  Definition

      |- ∀a b.
           a + b =
           float (fadd float_format To_nearest (defloat a) (defloat b))

   [<a name="float_div-val"><b>float_div</b></a>]  Definition

      |- ∀a b.
           a / b =
           float (fdiv float_format To_nearest (defloat a) (defloat b))

   [<a name="float_eq-val"><b>float_eq</b></a>]  Definition

      |- ∀a b. a == b ⇔ feq float_format (defloat a) (defloat b)

   [<a name="float_format-val"><b>float_format</b></a>]  Definition

      |- float_format = (8,23)

   [<a name="float_ge-val"><b>float_ge</b></a>]  Definition

      |- ∀a b. a ≥ b ⇔ fge float_format (defloat a) (defloat b)

   [<a name="float_gt-val"><b>float_gt</b></a>]  Definition

      |- ∀a b. a &gt; b ⇔ fgt float_format (defloat a) (defloat b)

   [<a name="float_le-val"><b>float_le</b></a>]  Definition

      |- ∀a b. a ≤ b ⇔ fle float_format (defloat a) (defloat b)

   [<a name="float_lt-val"><b>float_lt</b></a>]  Definition

      |- ∀a b. a &lt; b ⇔ flt float_format (defloat a) (defloat b)

   [<a name="float_mul-val"><b>float_mul</b></a>]  Definition

      |- ∀a b.
           a * b =
           float (fmul float_format To_nearest (defloat a) (defloat b))

   [<a name="float_neg-val"><b>float_neg</b></a>]  Definition

      |- ∀a. ¬a = float (fneg float_format To_nearest (defloat a))

   [<a name="float_rem-val"><b>float_rem</b></a>]  Definition

      |- ∀a b.
           a float_rem b =
           float (frem float_format To_nearest (defloat a) (defloat b))

   [<a name="float_sqrt-val"><b>float_sqrt</b></a>]  Definition

      |- ∀a.
           float_sqrt a = float (fsqrt float_format To_nearest (defloat a))

   [<a name="float_sub-val"><b>float_sub</b></a>]  Definition

      |- ∀a b.
           a − b =
           float (fsub float_format To_nearest (defloat a) (defloat b))

   [<a name="float_tybij-val"><b>float_tybij</b></a>]  Definition

      |- (∀a. float (defloat a) = a) ∧
         ∀r. is_valid float_format r ⇔ (defloat (float r) = r)

   [<a name="flt-val"><b>flt</b></a>]  Definition

      |- ∀X a b. flt X a b ⇔ (fcompare X a b = Lt)

   [<a name="fmul-val"><b>fmul</b></a>]  Definition

      |- ∀X m a b.
           fmul X m a b =
           if
             is_nan X a ∨ is_nan X b ∨ is_zero X a ∧ is_infinity X b ∨
             is_infinity X a ∧ is_zero X b
           then
             some_nan X
           else if is_infinity X a ∨ is_infinity X b then
             if sign a = sign b then plus_infinity X else minus_infinity X
           else
             zerosign X (if sign a = sign b then 0 else 1)
               (round X m (valof X a * valof X b))

   [<a name="fneg-val"><b>fneg</b></a>]  Definition

      |- ∀X m a. fneg X m a = (1 − sign a,exponent a,fraction a)

   [<a name="fraction-val"><b>fraction</b></a>]  Definition

      |- ∀s e f. fraction (s,e,f) = f

   [<a name="fracwidth-val"><b>fracwidth</b></a>]  Definition

      |- ∀ew fw. fracwidth (ew,fw) = fw

   [<a name="frem-val"><b>frem</b></a>]  Definition

      |- ∀X m a b.
           frem X m a b =
           if is_nan X a ∨ is_nan X b ∨ is_infinity X a ∨ is_zero X b then
             some_nan X
           else if is_infinity X b then a
           else zerosign X (sign a) (round X m (valof X a rem valof X b))

   [<a name="fsqrt-val"><b>fsqrt</b></a>]  Definition

      |- ∀X m a.
           fsqrt X m a =
           if is_nan X a then some_nan X
           else if is_zero X a ∨ is_infinity X a ∧ (sign a = 0) then a
           else if sign a = 1 then some_nan X
           else zerosign X (sign a) (round X m (sqrt (valof X a)))

   [<a name="fsub-val"><b>fsub</b></a>]  Definition

      |- ∀X m a b.
           fsub X m a b =
           if
             is_nan X a ∨ is_nan X b ∨
             is_infinity X a ∧ is_infinity X b ∧ (sign a = sign b)
           then
             some_nan X
           else if is_infinity X a then a
           else if is_infinity X b then minus X b
           else
             zerosign X
               (if is_zero X a ∧ is_zero X b ∧ sign a ≠ sign b then sign a
                else if m = To_ninfinity then 1
                else 0) (round X m (valof X a − valof X b))

   [<a name="intround_def-val"><b>intround_def</b></a>]  Definition

      |- (∀X x.
            intround X To_nearest x =
            if x ≤ -threshold X then minus_infinity X
            else if x ≥ threshold X then plus_infinity X
            else
              closest (valof X) (λa. ∃n. EVEN n ∧ (abs (valof X a) = &n))
                {a | is_integral X a} x) ∧
         (∀X x.
            intround X float_To_zero x =
            if x &lt; -largest X then bottomfloat X
            else if x &gt; largest X then topfloat X
            else
              closest (valof X) (λx. T)
                {a | is_integral X a ∧ abs (valof X a) ≤ abs x} x) ∧
         (∀X x.
            intround X To_pinfinity x =
            if x &lt; -largest X then bottomfloat X
            else if x &gt; largest X then plus_infinity X
            else
              closest (valof X) (λx. T)
                {a | is_integral X a ∧ valof X a ≥ x} x) ∧
         ∀X x.
           intround X To_ninfinity x =
           if x &lt; -largest X then minus_infinity X
           else if x &gt; largest X then topfloat X
           else
             closest (valof X) (λx. T)
               {a | is_integral X a ∧ valof X a ≤ x} x

   [<a name="is_closest-val"><b>is_closest</b></a>]  Definition

      |- ∀v s x a.
           is_closest v s x a ⇔
           a ∈ s ∧ ∀b. b ∈ s ⇒ abs (v a − x) ≤ abs (v b − x)

   [<a name="is_denormal-val"><b>is_denormal</b></a>]  Definition

      |- ∀X a. is_denormal X a ⇔ (exponent a = 0) ∧ fraction a ≠ 0

   [<a name="is_double-val"><b>is_double</b></a>]  Definition

      |- ∀X. is_double X ⇔ (expwidth X = 11) ∧ (wordlength X = 64)

   [<a name="is_double_extended-val"><b>is_double_extended</b></a>]  Definition

      |- ∀X. is_double_extended X ⇔ expwidth X ≥ 15 ∧ wordlength X ≥ 79

   [<a name="is_finite-val"><b>is_finite</b></a>]  Definition

      |- ∀X a.
           is_finite X a ⇔
           is_valid X a ∧ (is_normal X a ∨ is_denormal X a ∨ is_zero X a)

   [<a name="is_infinity-val"><b>is_infinity</b></a>]  Definition

      |- ∀X a. is_infinity X a ⇔ (exponent a = emax X) ∧ (fraction a = 0)

   [<a name="is_integral-val"><b>is_integral</b></a>]  Definition

      |- ∀X a. is_integral X a ⇔ is_finite X a ∧ ∃n. abs (valof X a) = &n

   [<a name="is_nan-val"><b>is_nan</b></a>]  Definition

      |- ∀X a. is_nan X a ⇔ (exponent a = emax X) ∧ fraction a ≠ 0

   [<a name="is_normal-val"><b>is_normal</b></a>]  Definition

      |- ∀X a. is_normal X a ⇔ 0 &lt; exponent a ∧ exponent a &lt; emax X

   [<a name="is_single-val"><b>is_single</b></a>]  Definition

      |- ∀X. is_single X ⇔ (expwidth X = 8) ∧ (wordlength X = 32)

   [<a name="is_single_extended-val"><b>is_single_extended</b></a>]  Definition

      |- ∀X. is_single_extended X ⇔ expwidth X ≥ 11 ∧ wordlength X ≥ 43

   [<a name="is_valid-val"><b>is_valid</b></a>]  Definition

      |- ∀X s e f.
           is_valid X (s,e,f) ⇔
           s &lt; SUC (SUC 0) ∧ e &lt; 2 ** expwidth X ∧ f &lt; 2 ** fracwidth X

   [<a name="is_zero-val"><b>is_zero</b></a>]  Definition

      |- ∀X a. is_zero X a ⇔ (exponent a = 0) ∧ (fraction a = 0)

   [<a name="largest-val"><b>largest</b></a>]  Definition

      |- ∀X.
           largest X =
           2 pow (emax X − 1) / 2 pow bias X *
           (2 − inv (2 pow fracwidth X))

   [<a name="minus-val"><b>minus</b></a>]  Definition

      |- ∀X a. minus X a = (1 − sign a,exponent a,fraction a)

   [<a name="minus_infinity-val"><b>minus_infinity</b></a>]  Definition

      |- ∀X. minus_infinity X = (1,emax X,0)

   [<a name="minus_zero-val"><b>minus_zero</b></a>]  Definition

      |- ∀X. minus_zero X = (1,0,0)

   [<a name="plus_infinity-val"><b>plus_infinity</b></a>]  Definition

      |- ∀X. plus_infinity X = (0,emax X,0)

   [<a name="plus_zero-val"><b>plus_zero</b></a>]  Definition

      |- ∀X. plus_zero X = (0,0,0)

   [<a name="rem-val"><b>rem</b></a>]  Definition

      |- ∀x y.
           x rem y =
           (let n =
                  closest I (λx. ∃n. EVEN n ∧ (abs x = &n))
                    {x | ∃n. abs x = &n} (x / y)
            in
              x − n * y)

   [<a name="round_def-val"><b>round_def</b></a>]  Definition

      |- (∀X x.
            round X To_nearest x =
            if x ≤ -threshold X then minus_infinity X
            else if x ≥ threshold X then plus_infinity X
            else
              closest (valof X) (λa. EVEN (fraction a)) {a | is_finite X a}
                x) ∧
         (∀X x.
            round X float_To_zero x =
            if x &lt; -largest X then bottomfloat X
            else if x &gt; largest X then topfloat X
            else
              closest (valof X) (λx. T)
                {a | is_finite X a ∧ abs (valof X a) ≤ abs x} x) ∧
         (∀X x.
            round X To_pinfinity x =
            if x &lt; -largest X then bottomfloat X
            else if x &gt; largest X then plus_infinity X
            else
              closest (valof X) (λx. T) {a | is_finite X a ∧ valof X a ≥ x}
                x) ∧
         ∀X x.
           round X To_ninfinity x =
           if x &lt; -largest X then minus_infinity X
           else if x &gt; largest X then topfloat X
           else
             closest (valof X) (λx. T) {a | is_finite X a ∧ valof X a ≤ x}
               x

   [<a name="roundmode_BIJ-val"><b>roundmode_BIJ</b></a>]  Definition

      |- (∀a. num2roundmode (roundmode2num a) = a) ∧
         ∀r. (λn. n &lt; 4) r ⇔ (roundmode2num (num2roundmode r) = r)

   [<a name="roundmode_CASE-val"><b>roundmode_CASE</b></a>]  Definition

      |- ∀x v0 v1 v2 v3.
           (case x of
              To_nearest =&gt; v0
            | float_To_zero =&gt; v1
            | To_pinfinity =&gt; v2
            | To_ninfinity =&gt; v3) =
           (λm.
              if m &lt; 1 then v0
              else if m &lt; 2 then v1
              else if m = 2 then v2
              else v3) (roundmode2num x)

   [<a name="roundmode_TY_DEF-val"><b>roundmode_TY_DEF</b></a>]  Definition

      |- ∃rep. TYPE_DEFINITION (λn. n &lt; 4) rep

   [<a name="roundmode_size_def-val"><b>roundmode_size_def</b></a>]  Definition

      |- ∀x. roundmode_size x = 0

   [<a name="sign-val"><b>sign</b></a>]  Definition

      |- ∀s e f. sign (s,e,f) = s

   [<a name="some_nan-val"><b>some_nan</b></a>]  Definition

      |- ∀X. some_nan X = @a. is_nan X a

   [<a name="threshold-val"><b>threshold</b></a>]  Definition

      |- ∀X.
           threshold X =
           2 pow (emax X − 1) / 2 pow bias X *
           (2 − inv (2 pow SUC (fracwidth X)))

   [<a name="topfloat-val"><b>topfloat</b></a>]  Definition

      |- ∀X. topfloat X = (0,emax X − 1,2 ** fracwidth X − 1)

   [<a name="ulp-val"><b>ulp</b></a>]  Definition

      |- ∀X a.
           ulp X a = valof X (0,exponent a,1) − valof X (0,exponent a,0)

   [<a name="valof-val"><b>valof</b></a>]  Definition

      |- ∀X s e f.
           valof X (s,e,f) =
           if e = 0 then
             -1 pow s * (2 / 2 pow bias X) * (&f / 2 pow fracwidth X)
           else
             -1 pow s * (2 pow e / 2 pow bias X) *
             (1 + &f / 2 pow fracwidth X)

   [<a name="wordlength-val"><b>wordlength</b></a>]  Definition

      |- ∀X. wordlength X = expwidth X + fracwidth X + 1

   [<a name="zerosign-val"><b>zerosign</b></a>]  Definition

      |- ∀X s a.
           zerosign X s a =
           if is_zero X a then if s = 0 then plus_zero X else minus_zero X
           else a

   [<a name="ccode2num_11-val"><b>ccode2num_11</b></a>]  Theorem

      |- ∀a a'. (ccode2num a = ccode2num a') ⇔ (a = a')

   [<a name="ccode2num_ONTO-val"><b>ccode2num_ONTO</b></a>]  Theorem

      |- ∀r. r &lt; 4 ⇔ ∃a. r = ccode2num a

   [<a name="ccode2num_num2ccode-val"><b>ccode2num_num2ccode</b></a>]  Theorem

      |- ∀r. r &lt; 4 ⇔ (ccode2num (num2ccode r) = r)

   [<a name="ccode2num_thm-val"><b>ccode2num_thm</b></a>]  Theorem

      |- (ccode2num Gt = 0) ∧ (ccode2num Lt = 1) ∧ (ccode2num Eq = 2) ∧
         (ccode2num Un = 3)

   [<a name="ccode_Axiom-val"><b>ccode_Axiom</b></a>]  Theorem

      |- ∀x0 x1 x2 x3.
           ∃f. (f Gt = x0) ∧ (f Lt = x1) ∧ (f Eq = x2) ∧ (f Un = x3)

   [<a name="ccode_EQ_ccode-val"><b>ccode_EQ_ccode</b></a>]  Theorem

      |- ∀a a'. (a = a') ⇔ (ccode2num a = ccode2num a')

   [<a name="ccode_case_cong-val"><b>ccode_case_cong</b></a>]  Theorem

      |- ∀M M' v0 v1 v2 v3.
           (M = M') ∧ ((M' = Gt) ⇒ (v0 = v0')) ∧ ((M' = Lt) ⇒ (v1 = v1')) ∧
           ((M' = Eq) ⇒ (v2 = v2')) ∧ ((M' = Un) ⇒ (v3 = v3')) ⇒
           ((case M of Gt =&gt; v0 | Lt =&gt; v1 | Eq =&gt; v2 | Un =&gt; v3) =
            case M' of Gt =&gt; v0' | Lt =&gt; v1' | Eq =&gt; v2' | Un =&gt; v3')

   [<a name="ccode_case_def-val"><b>ccode_case_def</b></a>]  Theorem

      |- (∀v0 v1 v2 v3.
            (case Gt of Gt =&gt; v0 | Lt =&gt; v1 | Eq =&gt; v2 | Un =&gt; v3) = v0) ∧
         (∀v0 v1 v2 v3.
            (case Lt of Gt =&gt; v0 | Lt =&gt; v1 | Eq =&gt; v2 | Un =&gt; v3) = v1) ∧
         (∀v0 v1 v2 v3.
            (case Eq of Gt =&gt; v0 | Lt =&gt; v1 | Eq =&gt; v2 | Un =&gt; v3) = v2) ∧
         ∀v0 v1 v2 v3.
           (case Un of Gt =&gt; v0 | Lt =&gt; v1 | Eq =&gt; v2 | Un =&gt; v3) = v3

   [<a name="ccode_distinct-val"><b>ccode_distinct</b></a>]  Theorem

      |- Gt ≠ Lt ∧ Gt ≠ Eq ∧ Gt ≠ Un ∧ Lt ≠ Eq ∧ Lt ≠ Un ∧ Eq ≠ Un

   [<a name="ccode_induction-val"><b>ccode_induction</b></a>]  Theorem

      |- ∀P. P Eq ∧ P Gt ∧ P Lt ∧ P Un ⇒ ∀a. P a

   [<a name="ccode_nchotomy-val"><b>ccode_nchotomy</b></a>]  Theorem

      |- ∀a. (a = Gt) ∨ (a = Lt) ∨ (a = Eq) ∨ (a = Un)

   [<a name="datatype_ccode-val"><b>datatype_ccode</b></a>]  Theorem

      |- DATATYPE (ccode Gt Lt Eq Un)

   [<a name="datatype_roundmode-val"><b>datatype_roundmode</b></a>]  Theorem

      |- DATATYPE
           (roundmode To_nearest float_To_zero To_pinfinity To_ninfinity)

   [<a name="num2ccode_11-val"><b>num2ccode_11</b></a>]  Theorem

      |- ∀r r'. r &lt; 4 ⇒ r' &lt; 4 ⇒ ((num2ccode r = num2ccode r') ⇔ (r = r'))

   [<a name="num2ccode_ONTO-val"><b>num2ccode_ONTO</b></a>]  Theorem

      |- ∀a. ∃r. (a = num2ccode r) ∧ r &lt; 4

   [<a name="num2ccode_ccode2num-val"><b>num2ccode_ccode2num</b></a>]  Theorem

      |- ∀a. num2ccode (ccode2num a) = a

   [<a name="num2ccode_thm-val"><b>num2ccode_thm</b></a>]  Theorem

      |- (num2ccode 0 = Gt) ∧ (num2ccode 1 = Lt) ∧ (num2ccode 2 = Eq) ∧
         (num2ccode 3 = Un)

   [<a name="num2roundmode_11-val"><b>num2roundmode_11</b></a>]  Theorem

      |- ∀r r'.
           r &lt; 4 ⇒
           r' &lt; 4 ⇒
           ((num2roundmode r = num2roundmode r') ⇔ (r = r'))

   [<a name="num2roundmode_ONTO-val"><b>num2roundmode_ONTO</b></a>]  Theorem

      |- ∀a. ∃r. (a = num2roundmode r) ∧ r &lt; 4

   [<a name="num2roundmode_roundmode2num-val"><b>num2roundmode_roundmode2num</b></a>]  Theorem

      |- ∀a. num2roundmode (roundmode2num a) = a

   [<a name="num2roundmode_thm-val"><b>num2roundmode_thm</b></a>]  Theorem

      |- (num2roundmode 0 = To_nearest) ∧
         (num2roundmode 1 = float_To_zero) ∧
         (num2roundmode 2 = To_pinfinity) ∧
         (num2roundmode 3 = To_ninfinity)

   [<a name="roundmode2num_11-val"><b>roundmode2num_11</b></a>]  Theorem

      |- ∀a a'. (roundmode2num a = roundmode2num a') ⇔ (a = a')

   [<a name="roundmode2num_ONTO-val"><b>roundmode2num_ONTO</b></a>]  Theorem

      |- ∀r. r &lt; 4 ⇔ ∃a. r = roundmode2num a

   [<a name="roundmode2num_num2roundmode-val"><b>roundmode2num_num2roundmode</b></a>]  Theorem

      |- ∀r. r &lt; 4 ⇔ (roundmode2num (num2roundmode r) = r)

   [<a name="roundmode2num_thm-val"><b>roundmode2num_thm</b></a>]  Theorem

      |- (roundmode2num To_nearest = 0) ∧
         (roundmode2num float_To_zero = 1) ∧
         (roundmode2num To_pinfinity = 2) ∧
         (roundmode2num To_ninfinity = 3)

   [<a name="roundmode_Axiom-val"><b>roundmode_Axiom</b></a>]  Theorem

      |- ∀x0 x1 x2 x3.
           ∃f.
             (f To_nearest = x0) ∧ (f float_To_zero = x1) ∧
             (f To_pinfinity = x2) ∧ (f To_ninfinity = x3)

   [<a name="roundmode_EQ_roundmode-val"><b>roundmode_EQ_roundmode</b></a>]  Theorem

      |- ∀a a'. (a = a') ⇔ (roundmode2num a = roundmode2num a')

   [<a name="roundmode_case_cong-val"><b>roundmode_case_cong</b></a>]  Theorem

      |- ∀M M' v0 v1 v2 v3.
           (M = M') ∧ ((M' = To_nearest) ⇒ (v0 = v0')) ∧
           ((M' = float_To_zero) ⇒ (v1 = v1')) ∧
           ((M' = To_pinfinity) ⇒ (v2 = v2')) ∧
           ((M' = To_ninfinity) ⇒ (v3 = v3')) ⇒
           ((case M of
               To_nearest =&gt; v0
             | float_To_zero =&gt; v1
             | To_pinfinity =&gt; v2
             | To_ninfinity =&gt; v3) =
            case M' of
              To_nearest =&gt; v0'
            | float_To_zero =&gt; v1'
            | To_pinfinity =&gt; v2'
            | To_ninfinity =&gt; v3')

   [<a name="roundmode_case_def-val"><b>roundmode_case_def</b></a>]  Theorem

      |- (∀v0 v1 v2 v3.
            (case To_nearest of
               To_nearest =&gt; v0
             | float_To_zero =&gt; v1
             | To_pinfinity =&gt; v2
             | To_ninfinity =&gt; v3) =
            v0) ∧
         (∀v0 v1 v2 v3.
            (case float_To_zero of
               To_nearest =&gt; v0
             | float_To_zero =&gt; v1
             | To_pinfinity =&gt; v2
             | To_ninfinity =&gt; v3) =
            v1) ∧
         (∀v0 v1 v2 v3.
            (case To_pinfinity of
               To_nearest =&gt; v0
             | float_To_zero =&gt; v1
             | To_pinfinity =&gt; v2
             | To_ninfinity =&gt; v3) =
            v2) ∧
         ∀v0 v1 v2 v3.
           (case To_ninfinity of
              To_nearest =&gt; v0
            | float_To_zero =&gt; v1
            | To_pinfinity =&gt; v2
            | To_ninfinity =&gt; v3) =
           v3

   [<a name="roundmode_distinct-val"><b>roundmode_distinct</b></a>]  Theorem

      |- To_nearest ≠ float_To_zero ∧ To_nearest ≠ To_pinfinity ∧
         To_nearest ≠ To_ninfinity ∧ float_To_zero ≠ To_pinfinity ∧
         float_To_zero ≠ To_ninfinity ∧ To_pinfinity ≠ To_ninfinity

   [<a name="roundmode_induction-val"><b>roundmode_induction</b></a>]  Theorem

      |- ∀P.
           P To_nearest ∧ P To_ninfinity ∧ P To_pinfinity ∧
           P float_To_zero ⇒
           ∀a. P a

   [<a name="roundmode_nchotomy-val"><b>roundmode_nchotomy</b></a>]  Theorem

      |- ∀a.
           (a = To_nearest) ∨ (a = float_To_zero) ∨ (a = To_pinfinity) ∨
           (a = To_ninfinity)


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/float/ieeeScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-9</a></em></p></body></html>
