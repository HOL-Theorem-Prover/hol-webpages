<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure Temporal_LogicTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure Temporal_LogicTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/temporal/src/Temporal_LogicScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature Temporal_LogicTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#ALWAYS-val">ALWAYS</a> : thm
<a name="line7"></a>    val <a href="#BEFORE-val">BEFORE</a> : thm
<a name="line8"></a>    val <a href="#EVENTUAL-val">EVENTUAL</a> : thm
<a name="line9"></a>    val <a href="#NEXT-val">NEXT</a> : thm
<a name="line10"></a>    val <a href="#SBEFORE-val">SBEFORE</a> : thm
<a name="line11"></a>    val <a href="#SUNTIL-val">SUNTIL</a> : thm
<a name="line12"></a>    val <a href="#SWHEN-val">SWHEN</a> : thm
<a name="line13"></a>    val <a href="#UNTIL-val">UNTIL</a> : thm
<a name="line14"></a>    val <a href="#UPTO-val">UPTO</a> : thm
<a name="line15"></a>    val <a href="#WATCH-val">WATCH</a> : thm
<a name="line16"></a>    val <a href="#WHEN-val">WHEN</a> : thm
<a name="line17"></a>
<a name="line18"></a>  (*  Theorems  *)
<a name="line19"></a>    val <a href="#ALWAYS_AS_BEFORE-val">ALWAYS_AS_BEFORE</a> : thm
<a name="line20"></a>    val <a href="#ALWAYS_AS_SBEFORE-val">ALWAYS_AS_SBEFORE</a> : thm
<a name="line21"></a>    val <a href="#ALWAYS_AS_SUNTIL-val">ALWAYS_AS_SUNTIL</a> : thm
<a name="line22"></a>    val <a href="#ALWAYS_AS_SWHEN-val">ALWAYS_AS_SWHEN</a> : thm
<a name="line23"></a>    val <a href="#ALWAYS_AS_UNTIL-val">ALWAYS_AS_UNTIL</a> : thm
<a name="line24"></a>    val <a href="#ALWAYS_AS_WHEN-val">ALWAYS_AS_WHEN</a> : thm
<a name="line25"></a>    val <a href="#ALWAYS_FIX-val">ALWAYS_FIX</a> : thm
<a name="line26"></a>    val <a href="#ALWAYS_IDEM-val">ALWAYS_IDEM</a> : thm
<a name="line27"></a>    val <a href="#ALWAYS_INVARIANT-val">ALWAYS_INVARIANT</a> : thm
<a name="line28"></a>    val <a href="#ALWAYS_LINORD-val">ALWAYS_LINORD</a> : thm
<a name="line29"></a>    val <a href="#ALWAYS_NEXT-val">ALWAYS_NEXT</a> : thm
<a name="line30"></a>    val <a href="#ALWAYS_REC-val">ALWAYS_REC</a> : thm
<a name="line31"></a>    val <a href="#ALWAYS_SIGNAL-val">ALWAYS_SIGNAL</a> : thm
<a name="line32"></a>    val <a href="#AND_NEXT-val">AND_NEXT</a> : thm
<a name="line33"></a>    val <a href="#BEFORE_AS_NOT_SWHEN-val">BEFORE_AS_NOT_SWHEN</a> : thm
<a name="line34"></a>    val <a href="#BEFORE_AS_SBEFORE-val">BEFORE_AS_SBEFORE</a> : thm
<a name="line35"></a>    val <a href="#BEFORE_AS_SUNTIL-val">BEFORE_AS_SUNTIL</a> : thm
<a name="line36"></a>    val <a href="#BEFORE_AS_SWHEN-val">BEFORE_AS_SWHEN</a> : thm
<a name="line37"></a>    val <a href="#BEFORE_AS_UNTIL-val">BEFORE_AS_UNTIL</a> : thm
<a name="line38"></a>    val <a href="#BEFORE_AS_WHEN-val">BEFORE_AS_WHEN</a> : thm
<a name="line39"></a>    val <a href="#BEFORE_AS_WHEN_UNTIL-val">BEFORE_AS_WHEN_UNTIL</a> : thm
<a name="line40"></a>    val <a href="#BEFORE_EVENT-val">BEFORE_EVENT</a> : thm
<a name="line41"></a>    val <a href="#BEFORE_FIX-val">BEFORE_FIX</a> : thm
<a name="line42"></a>    val <a href="#BEFORE_HW-val">BEFORE_HW</a> : thm
<a name="line43"></a>    val <a href="#BEFORE_IDEM-val">BEFORE_IDEM</a> : thm
<a name="line44"></a>    val <a href="#BEFORE_IMP-val">BEFORE_IMP</a> : thm
<a name="line45"></a>    val <a href="#BEFORE_INVARIANT-val">BEFORE_INVARIANT</a> : thm
<a name="line46"></a>    val <a href="#BEFORE_LINORD-val">BEFORE_LINORD</a> : thm
<a name="line47"></a>    val <a href="#BEFORE_NEXT-val">BEFORE_NEXT</a> : thm
<a name="line48"></a>    val <a href="#BEFORE_REC-val">BEFORE_REC</a> : thm
<a name="line49"></a>    val <a href="#BEFORE_SIGNAL-val">BEFORE_SIGNAL</a> : thm
<a name="line50"></a>    val <a href="#BEFORE_SIMP-val">BEFORE_SIMP</a> : thm
<a name="line51"></a>    val <a href="#DELTA_CASES-val">DELTA_CASES</a> : thm
<a name="line52"></a>    val <a href="#EQUIV_NEXT-val">EQUIV_NEXT</a> : thm
<a name="line53"></a>    val <a href="#EVENTUAL_AS_BEFORE-val">EVENTUAL_AS_BEFORE</a> : thm
<a name="line54"></a>    val <a href="#EVENTUAL_AS_SBEFORE-val">EVENTUAL_AS_SBEFORE</a> : thm
<a name="line55"></a>    val <a href="#EVENTUAL_AS_SUNTIL-val">EVENTUAL_AS_SUNTIL</a> : thm
<a name="line56"></a>    val <a href="#EVENTUAL_AS_SWHEN-val">EVENTUAL_AS_SWHEN</a> : thm
<a name="line57"></a>    val <a href="#EVENTUAL_AS_UNTIL-val">EVENTUAL_AS_UNTIL</a> : thm
<a name="line58"></a>    val <a href="#EVENTUAL_AS_WHEN-val">EVENTUAL_AS_WHEN</a> : thm
<a name="line59"></a>    val <a href="#EVENTUAL_FIX-val">EVENTUAL_FIX</a> : thm
<a name="line60"></a>    val <a href="#EVENTUAL_IDEM-val">EVENTUAL_IDEM</a> : thm
<a name="line61"></a>    val <a href="#EVENTUAL_INVARIANT-val">EVENTUAL_INVARIANT</a> : thm
<a name="line62"></a>    val <a href="#EVENTUAL_LINORD-val">EVENTUAL_LINORD</a> : thm
<a name="line63"></a>    val <a href="#EVENTUAL_NEXT-val">EVENTUAL_NEXT</a> : thm
<a name="line64"></a>    val <a href="#EVENTUAL_REC-val">EVENTUAL_REC</a> : thm
<a name="line65"></a>    val <a href="#EVENTUAL_SIGNAL-val">EVENTUAL_SIGNAL</a> : thm
<a name="line66"></a>    val <a href="#IMMEDIATE_EVENT-val">IMMEDIATE_EVENT</a> : thm
<a name="line67"></a>    val <a href="#IMP_NEXT-val">IMP_NEXT</a> : thm
<a name="line68"></a>    val <a href="#MORE_EVENT-val">MORE_EVENT</a> : thm
<a name="line69"></a>    val <a href="#NEXT_LINORD-val">NEXT_LINORD</a> : thm
<a name="line70"></a>    val <a href="#NOT_ALWAYS-val">NOT_ALWAYS</a> : thm
<a name="line71"></a>    val <a href="#NOT_BEFORE-val">NOT_BEFORE</a> : thm
<a name="line72"></a>    val <a href="#NOT_EVENTUAL-val">NOT_EVENTUAL</a> : thm
<a name="line73"></a>    val <a href="#NOT_NEXT-val">NOT_NEXT</a> : thm
<a name="line74"></a>    val <a href="#NOT_SBEFORE-val">NOT_SBEFORE</a> : thm
<a name="line75"></a>    val <a href="#NOT_SUNTIL-val">NOT_SUNTIL</a> : thm
<a name="line76"></a>    val <a href="#NOT_SWHEN-val">NOT_SWHEN</a> : thm
<a name="line77"></a>    val <a href="#NOT_UNTIL-val">NOT_UNTIL</a> : thm
<a name="line78"></a>    val <a href="#NOT_WHEN-val">NOT_WHEN</a> : thm
<a name="line79"></a>    val <a href="#NO_EVENT-val">NO_EVENT</a> : thm
<a name="line80"></a>    val <a href="#OR_NEXT-val">OR_NEXT</a> : thm
<a name="line81"></a>    val <a href="#SBEFORE_AS_BEFORE-val">SBEFORE_AS_BEFORE</a> : thm
<a name="line82"></a>    val <a href="#SBEFORE_AS_SUNTIL-val">SBEFORE_AS_SUNTIL</a> : thm
<a name="line83"></a>    val <a href="#SBEFORE_AS_SWHEN-val">SBEFORE_AS_SWHEN</a> : thm
<a name="line84"></a>    val <a href="#SBEFORE_AS_UNTIL-val">SBEFORE_AS_UNTIL</a> : thm
<a name="line85"></a>    val <a href="#SBEFORE_AS_WHEN-val">SBEFORE_AS_WHEN</a> : thm
<a name="line86"></a>    val <a href="#SBEFORE_EVENT-val">SBEFORE_EVENT</a> : thm
<a name="line87"></a>    val <a href="#SBEFORE_IDEM-val">SBEFORE_IDEM</a> : thm
<a name="line88"></a>    val <a href="#SBEFORE_IMP-val">SBEFORE_IMP</a> : thm
<a name="line89"></a>    val <a href="#SBEFORE_INVARIANT-val">SBEFORE_INVARIANT</a> : thm
<a name="line90"></a>    val <a href="#SBEFORE_LINORD-val">SBEFORE_LINORD</a> : thm
<a name="line91"></a>    val <a href="#SBEFORE_NEXT-val">SBEFORE_NEXT</a> : thm
<a name="line92"></a>    val <a href="#SBEFORE_REC-val">SBEFORE_REC</a> : thm
<a name="line93"></a>    val <a href="#SBEFORE_SIGNAL-val">SBEFORE_SIGNAL</a> : thm
<a name="line94"></a>    val <a href="#SBEFORE_SIMP-val">SBEFORE_SIMP</a> : thm
<a name="line95"></a>    val <a href="#SOME_EVENT-val">SOME_EVENT</a> : thm
<a name="line96"></a>    val <a href="#SUNTIL_AS_BEFORE-val">SUNTIL_AS_BEFORE</a> : thm
<a name="line97"></a>    val <a href="#SUNTIL_AS_SBEFORE-val">SUNTIL_AS_SBEFORE</a> : thm
<a name="line98"></a>    val <a href="#SUNTIL_AS_SWHEN-val">SUNTIL_AS_SWHEN</a> : thm
<a name="line99"></a>    val <a href="#SUNTIL_AS_UNTIL-val">SUNTIL_AS_UNTIL</a> : thm
<a name="line100"></a>    val <a href="#SUNTIL_AS_WHEN-val">SUNTIL_AS_WHEN</a> : thm
<a name="line101"></a>    val <a href="#SUNTIL_EVENT-val">SUNTIL_EVENT</a> : thm
<a name="line102"></a>    val <a href="#SUNTIL_IDEM-val">SUNTIL_IDEM</a> : thm
<a name="line103"></a>    val <a href="#SUNTIL_IMP-val">SUNTIL_IMP</a> : thm
<a name="line104"></a>    val <a href="#SUNTIL_INVARIANT-val">SUNTIL_INVARIANT</a> : thm
<a name="line105"></a>    val <a href="#SUNTIL_LINORD-val">SUNTIL_LINORD</a> : thm
<a name="line106"></a>    val <a href="#SUNTIL_NEXT-val">SUNTIL_NEXT</a> : thm
<a name="line107"></a>    val <a href="#SUNTIL_REC-val">SUNTIL_REC</a> : thm
<a name="line108"></a>    val <a href="#SUNTIL_SIGNAL-val">SUNTIL_SIGNAL</a> : thm
<a name="line109"></a>    val <a href="#SUNTIL_SIMP-val">SUNTIL_SIMP</a> : thm
<a name="line110"></a>    val <a href="#SWHEN_AS_BEFORE-val">SWHEN_AS_BEFORE</a> : thm
<a name="line111"></a>    val <a href="#SWHEN_AS_NOT_WHEN-val">SWHEN_AS_NOT_WHEN</a> : thm
<a name="line112"></a>    val <a href="#SWHEN_AS_SBEFORE-val">SWHEN_AS_SBEFORE</a> : thm
<a name="line113"></a>    val <a href="#SWHEN_AS_SUNTIL-val">SWHEN_AS_SUNTIL</a> : thm
<a name="line114"></a>    val <a href="#SWHEN_AS_UNTIL-val">SWHEN_AS_UNTIL</a> : thm
<a name="line115"></a>    val <a href="#SWHEN_AS_WHEN-val">SWHEN_AS_WHEN</a> : thm
<a name="line116"></a>    val <a href="#SWHEN_EVENT-val">SWHEN_EVENT</a> : thm
<a name="line117"></a>    val <a href="#SWHEN_IDEM-val">SWHEN_IDEM</a> : thm
<a name="line118"></a>    val <a href="#SWHEN_IMP-val">SWHEN_IMP</a> : thm
<a name="line119"></a>    val <a href="#SWHEN_INVARIANT-val">SWHEN_INVARIANT</a> : thm
<a name="line120"></a>    val <a href="#SWHEN_LINORD-val">SWHEN_LINORD</a> : thm
<a name="line121"></a>    val <a href="#SWHEN_NEXT-val">SWHEN_NEXT</a> : thm
<a name="line122"></a>    val <a href="#SWHEN_REC-val">SWHEN_REC</a> : thm
<a name="line123"></a>    val <a href="#SWHEN_SIGNAL-val">SWHEN_SIGNAL</a> : thm
<a name="line124"></a>    val <a href="#SWHEN_SIMP-val">SWHEN_SIMP</a> : thm
<a name="line125"></a>    val <a href="#UNTIL_AS_BEFORE-val">UNTIL_AS_BEFORE</a> : thm
<a name="line126"></a>    val <a href="#UNTIL_AS_SBEFORE-val">UNTIL_AS_SBEFORE</a> : thm
<a name="line127"></a>    val <a href="#UNTIL_AS_SUNTIL-val">UNTIL_AS_SUNTIL</a> : thm
<a name="line128"></a>    val <a href="#UNTIL_AS_SWHEN-val">UNTIL_AS_SWHEN</a> : thm
<a name="line129"></a>    val <a href="#UNTIL_AS_WHEN-val">UNTIL_AS_WHEN</a> : thm
<a name="line130"></a>    val <a href="#UNTIL_EVENT-val">UNTIL_EVENT</a> : thm
<a name="line131"></a>    val <a href="#UNTIL_FIX-val">UNTIL_FIX</a> : thm
<a name="line132"></a>    val <a href="#UNTIL_IDEM-val">UNTIL_IDEM</a> : thm
<a name="line133"></a>    val <a href="#UNTIL_IMP-val">UNTIL_IMP</a> : thm
<a name="line134"></a>    val <a href="#UNTIL_INVARIANT-val">UNTIL_INVARIANT</a> : thm
<a name="line135"></a>    val <a href="#UNTIL_LINORD-val">UNTIL_LINORD</a> : thm
<a name="line136"></a>    val <a href="#UNTIL_NEXT-val">UNTIL_NEXT</a> : thm
<a name="line137"></a>    val <a href="#UNTIL_REC-val">UNTIL_REC</a> : thm
<a name="line138"></a>    val <a href="#UNTIL_SIGNAL-val">UNTIL_SIGNAL</a> : thm
<a name="line139"></a>    val <a href="#UNTIL_SIMP-val">UNTIL_SIMP</a> : thm
<a name="line140"></a>    val <a href="#WATCH_EXISTS-val">WATCH_EXISTS</a> : thm
<a name="line141"></a>    val <a href="#WATCH_REC-val">WATCH_REC</a> : thm
<a name="line142"></a>    val <a href="#WATCH_SIGNAL-val">WATCH_SIGNAL</a> : thm
<a name="line143"></a>    val <a href="#WELL_ORDER-val">WELL_ORDER</a> : thm
<a name="line144"></a>    val <a href="#WELL_ORDER_UNIQUE-val">WELL_ORDER_UNIQUE</a> : thm
<a name="line145"></a>    val <a href="#WHEN_AS_BEFORE-val">WHEN_AS_BEFORE</a> : thm
<a name="line146"></a>    val <a href="#WHEN_AS_NOT_SWHEN-val">WHEN_AS_NOT_SWHEN</a> : thm
<a name="line147"></a>    val <a href="#WHEN_AS_SBEFORE-val">WHEN_AS_SBEFORE</a> : thm
<a name="line148"></a>    val <a href="#WHEN_AS_SUNTIL-val">WHEN_AS_SUNTIL</a> : thm
<a name="line149"></a>    val <a href="#WHEN_AS_SWHEN-val">WHEN_AS_SWHEN</a> : thm
<a name="line150"></a>    val <a href="#WHEN_AS_UNTIL-val">WHEN_AS_UNTIL</a> : thm
<a name="line151"></a>    val <a href="#WHEN_EVENT-val">WHEN_EVENT</a> : thm
<a name="line152"></a>    val <a href="#WHEN_FIX-val">WHEN_FIX</a> : thm
<a name="line153"></a>    val <a href="#WHEN_IDEM-val">WHEN_IDEM</a> : thm
<a name="line154"></a>    val <a href="#WHEN_IMP-val">WHEN_IMP</a> : thm
<a name="line155"></a>    val <a href="#WHEN_INVARIANT-val">WHEN_INVARIANT</a> : thm
<a name="line156"></a>    val <a href="#WHEN_LINORD-val">WHEN_LINORD</a> : thm
<a name="line157"></a>    val <a href="#WHEN_NEXT-val">WHEN_NEXT</a> : thm
<a name="line158"></a>    val <a href="#WHEN_REC-val">WHEN_REC</a> : thm
<a name="line159"></a>    val <a href="#WHEN_SIGNAL-val">WHEN_SIGNAL</a> : thm
<a name="line160"></a>    val <a href="#WHEN_SIMP-val">WHEN_SIMP</a> : thm
<a name="line161"></a>    val <a href="#WHEN_SWHEN_LEMMA-val">WHEN_SWHEN_LEMMA</a> : thm
<a name="line162"></a>
<a name="line163"></a>  val Temporal_Logic_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line164"></a>(*
   [list] Parent theory of "Temporal_Logic"

   [<a name="ALWAYS-val"><b>ALWAYS</b></a>]  Definition

      |- ∀P t0. ALWAYS P t0 ⇔ ∀t. P (t + t0)

   [<a name="BEFORE-val"><b>BEFORE</b></a>]  Definition

      |- ∀a b t0.
           (a BEFORE b) t0 ⇔
           ∃q.
             (q WATCH b) t0 ∧
             ((∃t. ¬q (t + t0) ∧ ¬b (t + t0) ∧ a (t + t0)) ∨
              ∀t. ¬b (t + t0))

   [<a name="EVENTUAL-val"><b>EVENTUAL</b></a>]  Definition

      |- ∀P t0. EVENTUAL P t0 ⇔ ∃t. P (t + t0)

   [<a name="NEXT-val"><b>NEXT</b></a>]  Definition

      |- ∀P. NEXT P = (λt. P (SUC t))

   [<a name="SBEFORE-val"><b>SBEFORE</b></a>]  Definition

      |- ∀a b t0.
           (a SBEFORE b) t0 ⇔
           ∃q. (q WATCH b) t0 ∧ ∃t. ¬q (t + t0) ∧ ¬b (t + t0) ∧ a (t + t0)

   [<a name="SUNTIL-val"><b>SUNTIL</b></a>]  Definition

      |- ∀a b t0.
           (a SUNTIL b) t0 ⇔
           ∃q.
             (q WATCH b) t0 ∧ (∀t. q (t + t0) ∨ b (t + t0) ∨ a (t + t0)) ∧
             ∃t. b (t + t0)

   [<a name="SWHEN-val"><b>SWHEN</b></a>]  Definition

      |- ∀a b t0.
           (a SWHEN b) t0 ⇔
           ∃q. (q WATCH b) t0 ∧ ∃t. ¬q (t + t0) ∧ b (t + t0) ∧ a (t + t0)

   [<a name="UNTIL-val"><b>UNTIL</b></a>]  Definition

      |- ∀a b t0.
           (a UNTIL b) t0 ⇔
           ∃q. (q WATCH b) t0 ∧ ∀t. q (t + t0) ∨ b (t + t0) ∨ a (t + t0)

   [<a name="UPTO-val"><b>UPTO</b></a>]  Definition

      |- ∀t0 t1 a. UPTO (t0,t1,a) ⇔ ∀t2. t0 ≤ t2 ∧ t2 &lt; t1 ⇒ a t2

   [<a name="WATCH-val"><b>WATCH</b></a>]  Definition

      |- ∀q b t0.
           (q WATCH b) t0 ⇔
           ∀t. (q t0 ⇔ F) ∧ (q (SUC (t + t0)) ⇔ q (t + t0) ∨ b (t + t0))

   [<a name="WHEN-val"><b>WHEN</b></a>]  Definition

      |- ∀a b t0.
           (a WHEN b) t0 ⇔
           ∃q. (q WATCH b) t0 ∧ ∀t. q (t + t0) ∨ (b (t + t0) ⇒ a (t + t0))

   [<a name="ALWAYS_AS_BEFORE-val"><b>ALWAYS_AS_BEFORE</b></a>]  Theorem

      |- ALWAYS b = (λt. F) BEFORE (λt. ¬b t)

   [<a name="ALWAYS_AS_SBEFORE-val"><b>ALWAYS_AS_SBEFORE</b></a>]  Theorem

      |- ALWAYS b = (λt0. ¬((λt. ¬b t) SBEFORE (λt. F)) t0)

   [<a name="ALWAYS_AS_SUNTIL-val"><b>ALWAYS_AS_SUNTIL</b></a>]  Theorem

      |- ALWAYS a = (λt. ¬((λt. T) SUNTIL (λt. ¬a t)) t)

   [<a name="ALWAYS_AS_SWHEN-val"><b>ALWAYS_AS_SWHEN</b></a>]  Theorem

      |- ALWAYS a = (λt. ¬((λt. T) SWHEN (λt. ¬a t)) t)

   [<a name="ALWAYS_AS_UNTIL-val"><b>ALWAYS_AS_UNTIL</b></a>]  Theorem

      |- ALWAYS a = a UNTIL (λt. F)

   [<a name="ALWAYS_AS_WHEN-val"><b>ALWAYS_AS_WHEN</b></a>]  Theorem

      |- ALWAYS a = (λt. F) WHEN (λt. ¬a t)

   [<a name="ALWAYS_FIX-val"><b>ALWAYS_FIX</b></a>]  Theorem

      |- (y = (λt. a t ∧ y (t + 1))) ⇔ (y = ALWAYS a) ∨ (y = (λt. F))

   [<a name="ALWAYS_IDEM-val"><b>ALWAYS_IDEM</b></a>]  Theorem

      |- ALWAYS a = ALWAYS (ALWAYS a)

   [<a name="ALWAYS_INVARIANT-val"><b>ALWAYS_INVARIANT</b></a>]  Theorem

      |- ALWAYS a t0 ⇔
         ∃J. J t0 ∧ ∀t. J (t + t0) ⇒ a (t + t0) ∧ J (t + (t0 + 1))

   [<a name="ALWAYS_LINORD-val"><b>ALWAYS_LINORD</b></a>]  Theorem

      |- ALWAYS a t0 ⇔ ∀t1. t0 ≤ t1 ⇒ a t1

   [<a name="ALWAYS_NEXT-val"><b>ALWAYS_NEXT</b></a>]  Theorem

      |- ∀a. NEXT (ALWAYS a) = ALWAYS (NEXT a)

   [<a name="ALWAYS_REC-val"><b>ALWAYS_REC</b></a>]  Theorem

      |- ALWAYS P t0 ⇔ P t0 ∧ NEXT (ALWAYS P) t0

   [<a name="ALWAYS_SIGNAL-val"><b>ALWAYS_SIGNAL</b></a>]  Theorem

      |- ALWAYS a t0 ⇔ ∀t. a (t + t0)

   [<a name="AND_NEXT-val"><b>AND_NEXT</b></a>]  Theorem

      |- ∀Q P. NEXT (λt. P t ∧ Q t) = (λt. NEXT P t ∧ NEXT Q t)

   [<a name="BEFORE_AS_NOT_SWHEN-val"><b>BEFORE_AS_NOT_SWHEN</b></a>]  Theorem

      |- a BEFORE b = (λt0. ¬(b SWHEN (λt. a t ∨ b t)) t0)

   [<a name="BEFORE_AS_SBEFORE-val"><b>BEFORE_AS_SBEFORE</b></a>]  Theorem

      |- a BEFORE b = (λt0. (a SBEFORE b) t0 ∨ ALWAYS (λt. ¬b t) t0)

   [<a name="BEFORE_AS_SUNTIL-val"><b>BEFORE_AS_SUNTIL</b></a>]  Theorem

      |- a BEFORE b = (λt. ¬((λt. ¬a t) SUNTIL b) t)

   [<a name="BEFORE_AS_SWHEN-val"><b>BEFORE_AS_SWHEN</b></a>]  Theorem

      |- a BEFORE b =
         (λt0.
            ((λt. ¬b t) SWHEN (λt. a t ∨ b t)) t0 ∨
            ALWAYS (λt. ¬a t ∧ ¬b t) t0)

   [<a name="BEFORE_AS_UNTIL-val"><b>BEFORE_AS_UNTIL</b></a>]  Theorem

      |- a BEFORE b =
         (λt0. ¬((λt. ¬a t) UNTIL b) t0 ∨ ALWAYS (λt. ¬b t) t0)

   [<a name="BEFORE_AS_WHEN-val"><b>BEFORE_AS_WHEN</b></a>]  Theorem

      |- a BEFORE b = (λt. ¬b t) WHEN (λt. a t ∨ b t)

   [<a name="BEFORE_AS_WHEN_UNTIL-val"><b>BEFORE_AS_WHEN_UNTIL</b></a>]  Theorem

      |- a BEFORE b = (λt. ((λt. ¬b t) UNTIL a) t ∧ ((λt. ¬b t) WHEN a) t)

   [<a name="BEFORE_EVENT-val"><b>BEFORE_EVENT</b></a>]  Theorem

      |- a BEFORE b = (λt. a t ∧ ¬b t) BEFORE b

   [<a name="BEFORE_FIX-val"><b>BEFORE_FIX</b></a>]  Theorem

      |- ∀y.
           (y = (λt. ¬b t ∧ (a t ∨ y (t + 1)))) ⇔
           (y = a BEFORE b) ∨ (y = a SBEFORE b)

   [<a name="BEFORE_HW-val"><b>BEFORE_HW</b></a>]  Theorem

      |- (a BEFORE b) t0 ⇔
         ∃q. (q WATCH a) t0 ∧ ∀t. q (t + t0) ∨ ¬b (t + t0)

   [<a name="BEFORE_IDEM-val"><b>BEFORE_IDEM</b></a>]  Theorem

      |- a BEFORE b = (a BEFORE b) BEFORE b

   [<a name="BEFORE_IMP-val"><b>BEFORE_IMP</b></a>]  Theorem

      |- (a BEFORE b) t0 ⇔
         ∀q.
           (q WATCH b) t0 ⇒
           (∃t. ¬q (t + t0) ∧ ¬b (t + t0) ∧ a (t + t0)) ∨ ∀t. ¬b (t + t0)

   [<a name="BEFORE_INVARIANT-val"><b>BEFORE_INVARIANT</b></a>]  Theorem

      |- (a BEFORE b) t0 ⇔
         ∃J.
           J t0 ∧ (∀t. J (t + t0) ∧ ¬a (t + t0) ⇒ J (SUC (t + t0))) ∧
           ∀d. J (d + t0) ⇒ ¬b (d + t0)

   [<a name="BEFORE_LINORD-val"><b>BEFORE_LINORD</b></a>]  Theorem

      |- (a BEFORE b) t0 ⇔ ∀t1. t0 ≤ t1 ∧ UPTO (t0,t1,(λt. ¬a t)) ⇒ ¬b t1

   [<a name="BEFORE_NEXT-val"><b>BEFORE_NEXT</b></a>]  Theorem

      |- ∀a b. NEXT (a BEFORE b) = NEXT a BEFORE NEXT b

   [<a name="BEFORE_REC-val"><b>BEFORE_REC</b></a>]  Theorem

      |- (a BEFORE b) t0 ⇔ ¬b t0 ∧ (a t0 ∨ NEXT (a BEFORE b) t0)

   [<a name="BEFORE_SIGNAL-val"><b>BEFORE_SIGNAL</b></a>]  Theorem

      |- (a BEFORE b) t0 ⇔
         ∀delta.
           (∀t. t &lt; delta ⇒ ¬b (t + t0)) ∧ b (delta + t0) ⇒
           ∃t. t &lt; delta ∧ a (t + t0)

   [<a name="BEFORE_SIMP-val"><b>BEFORE_SIMP</b></a>]  Theorem

      |- ((λt. F) BEFORE b = ALWAYS (λt. ¬b t)) ∧
         ((λt. T) BEFORE b = (λt. ¬b t)) ∧ (a BEFORE (λt. F) = (λt. T)) ∧
         (a BEFORE (λt. T) = (λt. F)) ∧ (a BEFORE a = ALWAYS (λt. ¬a t))

   [<a name="DELTA_CASES-val"><b>DELTA_CASES</b></a>]  Theorem

      |- (∃d. (∀t. t &lt; d ⇒ ¬b (t + t0)) ∧ b (d + t0)) ∨ ∀d. ¬b (d + t0)

   [<a name="EQUIV_NEXT-val"><b>EQUIV_NEXT</b></a>]  Theorem

      |- ∀Q P. NEXT (λt. P t ⇔ Q t) = (λt. NEXT P t ⇔ NEXT Q t)

   [<a name="EVENTUAL_AS_BEFORE-val"><b>EVENTUAL_AS_BEFORE</b></a>]  Theorem

      |- EVENTUAL b = (λt0. ¬((λt. F) BEFORE b) t0)

   [<a name="EVENTUAL_AS_SBEFORE-val"><b>EVENTUAL_AS_SBEFORE</b></a>]  Theorem

      |- EVENTUAL b = b SBEFORE (λt. F)

   [<a name="EVENTUAL_AS_SUNTIL-val"><b>EVENTUAL_AS_SUNTIL</b></a>]  Theorem

      |- EVENTUAL a = (λt. T) SUNTIL a

   [<a name="EVENTUAL_AS_SWHEN-val"><b>EVENTUAL_AS_SWHEN</b></a>]  Theorem

      |- EVENTUAL a = (λt. T) SWHEN a

   [<a name="EVENTUAL_AS_UNTIL-val"><b>EVENTUAL_AS_UNTIL</b></a>]  Theorem

      |- EVENTUAL a = (λt. ¬((λt. ¬a t) UNTIL (λt. F)) t)

   [<a name="EVENTUAL_AS_WHEN-val"><b>EVENTUAL_AS_WHEN</b></a>]  Theorem

      |- EVENTUAL a = (λt. ¬((λt. F) WHEN a) t)

   [<a name="EVENTUAL_FIX-val"><b>EVENTUAL_FIX</b></a>]  Theorem

      |- (y = (λt. a t ∨ y (t + 1))) ⇔ (y = EVENTUAL a) ∨ (y = (λt. T))

   [<a name="EVENTUAL_IDEM-val"><b>EVENTUAL_IDEM</b></a>]  Theorem

      |- EVENTUAL a = EVENTUAL (EVENTUAL a)

   [<a name="EVENTUAL_INVARIANT-val"><b>EVENTUAL_INVARIANT</b></a>]  Theorem

      |- EVENTUAL b t0 ⇔
         ∃J.
           0 &lt; J t0 ∧
           (∀t. J (SUC (t + t0)) &lt; J (t + t0) ∨ (J (SUC (t + t0)) = 0)) ∧
           ∀t. 0 &lt; J (t + t0) ∧ (J (SUC (t + t0)) = 0) ⇒ b (t + t0)

   [<a name="EVENTUAL_LINORD-val"><b>EVENTUAL_LINORD</b></a>]  Theorem

      |- EVENTUAL a t0 ⇔ ∃t1. t0 ≤ t1 ∧ a t1

   [<a name="EVENTUAL_NEXT-val"><b>EVENTUAL_NEXT</b></a>]  Theorem

      |- ∀a. NEXT (EVENTUAL a) = EVENTUAL (NEXT a)

   [<a name="EVENTUAL_REC-val"><b>EVENTUAL_REC</b></a>]  Theorem

      |- EVENTUAL P t0 ⇔ P t0 ∨ NEXT (EVENTUAL P) t0

   [<a name="EVENTUAL_SIGNAL-val"><b>EVENTUAL_SIGNAL</b></a>]  Theorem

      |- EVENTUAL a t0 ⇔ ∃t. a (t + t0)

   [<a name="IMMEDIATE_EVENT-val"><b>IMMEDIATE_EVENT</b></a>]  Theorem

      |- b t0 ⇒
         (∀a. (a WHEN b) t0 ⇔ a t0) ∧ (∀a. (a UNTIL b) t0 ⇔ T) ∧
         (∀a. (a BEFORE b) t0 ⇔ F) ∧ (∀a. (a SWHEN b) t0 ⇔ a t0) ∧
         (∀a. (a SUNTIL b) t0 ⇔ T) ∧ ∀a. (a SBEFORE b) t0 ⇔ F

   [<a name="IMP_NEXT-val"><b>IMP_NEXT</b></a>]  Theorem

      |- ∀Q P. NEXT (λt. P t ⇒ Q t) = (λt. NEXT P t ⇒ NEXT Q t)

   [<a name="MORE_EVENT-val"><b>MORE_EVENT</b></a>]  Theorem

      |- (a WHEN b = (λt. a t ∧ b t) WHEN b) ∧
         (a UNTIL b = (λt. a t ∧ ¬b t) UNTIL b) ∧
         (a BEFORE b = (λt. a t ∧ ¬b t) BEFORE b) ∧
         (a SWHEN b = (λt. a t ∧ b t) SWHEN b) ∧
         (a SUNTIL b = (λt. a t ∧ ¬b t) SUNTIL b) ∧
         (a SBEFORE b = (λt. a t ∧ ¬b t) SBEFORE b)

   [<a name="NEXT_LINORD-val"><b>NEXT_LINORD</b></a>]  Theorem

      |- NEXT a t0 ⇔ ∃t1. t0 &lt; t1 ∧ (∀t3. t0 &lt; t3 ⇒ t1 ≤ t3) ∧ a t1

   [<a name="NOT_ALWAYS-val"><b>NOT_ALWAYS</b></a>]  Theorem

      |- ¬ALWAYS a t0 ⇔ EVENTUAL (λt. ¬a t) t0

   [<a name="NOT_BEFORE-val"><b>NOT_BEFORE</b></a>]  Theorem

      |- ¬(a BEFORE b) t0 ⇔ ((λt. ¬a t) SUNTIL b) t0

   [<a name="NOT_EVENTUAL-val"><b>NOT_EVENTUAL</b></a>]  Theorem

      |- ¬EVENTUAL a t0 ⇔ ALWAYS (λt. ¬a t) t0

   [<a name="NOT_NEXT-val"><b>NOT_NEXT</b></a>]  Theorem

      |- ∀P. NEXT (λt. ¬P t) = (λt. ¬NEXT P t)

   [<a name="NOT_SBEFORE-val"><b>NOT_SBEFORE</b></a>]  Theorem

      |- ¬(a SBEFORE b) t0 ⇔ ((λt. ¬a t) UNTIL b) t0

   [<a name="NOT_SUNTIL-val"><b>NOT_SUNTIL</b></a>]  Theorem

      |- ¬(a SUNTIL b) t0 ⇔ ((λt. ¬a t) BEFORE b) t0

   [<a name="NOT_SWHEN-val"><b>NOT_SWHEN</b></a>]  Theorem

      |- ¬(a SWHEN b) t0 ⇔ ((λt. ¬a t) WHEN b) t0

   [<a name="NOT_UNTIL-val"><b>NOT_UNTIL</b></a>]  Theorem

      |- ¬(a UNTIL b) t0 ⇔ ((λt. ¬a t) SBEFORE b) t0

   [<a name="NOT_WHEN-val"><b>NOT_WHEN</b></a>]  Theorem

      |- ¬(a WHEN b) t0 ⇔ ((λt. ¬a t) SWHEN b) t0

   [<a name="NO_EVENT-val"><b>NO_EVENT</b></a>]  Theorem

      |- ALWAYS (λt. ¬b t) t0 ⇒
         (∀a. (a WHEN b) t0 ⇔ T) ∧ (∀a. (a UNTIL b) t0 ⇔ ALWAYS a t0) ∧
         (∀a. (a BEFORE b) t0 ⇔ T) ∧ (∀a. (a SWHEN b) t0 ⇔ F) ∧
         (∀a. (a SUNTIL b) t0 ⇔ F) ∧ ∀a. (a SBEFORE b) t0 ⇔ EVENTUAL a t0

   [<a name="OR_NEXT-val"><b>OR_NEXT</b></a>]  Theorem

      |- ∀Q P. NEXT (λt. P t ∨ Q t) = (λt. NEXT P t ∨ NEXT Q t)

   [<a name="SBEFORE_AS_BEFORE-val"><b>SBEFORE_AS_BEFORE</b></a>]  Theorem

      |- a SBEFORE b = (λt0. (a BEFORE b) t0 ∧ EVENTUAL a t0)

   [<a name="SBEFORE_AS_SUNTIL-val"><b>SBEFORE_AS_SUNTIL</b></a>]  Theorem

      |- a SBEFORE b = (λt0. ¬((λt. ¬a t) SUNTIL b) t0 ∧ EVENTUAL a t0)

   [<a name="SBEFORE_AS_SWHEN-val"><b>SBEFORE_AS_SWHEN</b></a>]  Theorem

      |- a SBEFORE b = (λt. ¬b t) SWHEN (λt. a t ∨ b t)

   [<a name="SBEFORE_AS_UNTIL-val"><b>SBEFORE_AS_UNTIL</b></a>]  Theorem

      |- a SBEFORE b = (λt0. ¬((λt. ¬a t) UNTIL b) t0)

   [<a name="SBEFORE_AS_WHEN-val"><b>SBEFORE_AS_WHEN</b></a>]  Theorem

      |- a SBEFORE b =
         (λt0. ((λt. ¬b t) WHEN (λt. a t ∨ b t)) t0 ∧ EVENTUAL a t0)

   [<a name="SBEFORE_EVENT-val"><b>SBEFORE_EVENT</b></a>]  Theorem

      |- a SBEFORE b = (λt. a t ∧ ¬b t) SBEFORE b

   [<a name="SBEFORE_IDEM-val"><b>SBEFORE_IDEM</b></a>]  Theorem

      |- a SBEFORE b = (a SBEFORE b) SBEFORE b

   [<a name="SBEFORE_IMP-val"><b>SBEFORE_IMP</b></a>]  Theorem

      |- (a SBEFORE b) t0 ⇔
         ∀q. (q WATCH b) t0 ⇒ ∃t. ¬q (t + t0) ∧ ¬b (t + t0) ∧ a (t + t0)

   [<a name="SBEFORE_INVARIANT-val"><b>SBEFORE_INVARIANT</b></a>]  Theorem

      |- (a SBEFORE b) t0 ⇔
         (∃J1.
            J1 t0 ∧ (∀t. J1 (t + t0) ∧ ¬a (t + t0) ⇒ J1 (SUC (t + t0))) ∧
            ∀d. J1 (d + t0) ⇒ ¬b (d + t0)) ∧
         ∃J2.
           0 &lt; J2 t0 ∧
           (∀t.
              J2 (SUC (t + t0)) &lt; J2 (t + t0) ∨ (J2 (SUC (t + t0)) = 0)) ∧
           ∀t. 0 &lt; J2 (t + t0) ∧ (J2 (SUC (t + t0)) = 0) ⇒ a (t + t0)

   [<a name="SBEFORE_LINORD-val"><b>SBEFORE_LINORD</b></a>]  Theorem

      |- (a SBEFORE b) t0 ⇔
         ∃t1. t0 ≤ t1 ∧ a t1 ∧ ¬b t1 ∧ UPTO (t0,t1,(λt. ¬b t))

   [<a name="SBEFORE_NEXT-val"><b>SBEFORE_NEXT</b></a>]  Theorem

      |- ∀a b. NEXT (a SBEFORE b) = NEXT a SBEFORE NEXT b

   [<a name="SBEFORE_REC-val"><b>SBEFORE_REC</b></a>]  Theorem

      |- (a SBEFORE b) t0 ⇔ ¬b t0 ∧ (a t0 ∨ NEXT (a SBEFORE b) t0)

   [<a name="SBEFORE_SIGNAL-val"><b>SBEFORE_SIGNAL</b></a>]  Theorem

      |- (a SBEFORE b) t0 ⇔
         ∃delta. a (delta + t0) ∧ ∀t. t ≤ delta ⇒ ¬b (t + t0)

   [<a name="SBEFORE_SIMP-val"><b>SBEFORE_SIMP</b></a>]  Theorem

      |- ((λt. F) SBEFORE b = (λt. F)) ∧ ((λt. T) SBEFORE b = (λt. ¬b t)) ∧
         (a SBEFORE (λt. F) = EVENTUAL a) ∧ (a SBEFORE (λt. T) = (λt. F)) ∧
         (a SBEFORE a = (λt. F))

   [<a name="SOME_EVENT-val"><b>SOME_EVENT</b></a>]  Theorem

      |- (EVENTUAL b t0 ⇔ ∀a. (a WHEN b) t0 ⇔ (a SWHEN b) t0) ∧
         (EVENTUAL b t0 ⇔ ∀a. (a UNTIL b) t0 ⇔ (a SUNTIL b) t0) ∧
         (EVENTUAL b t0 ⇔ ∀a. (a BEFORE b) t0 ⇔ (a SBEFORE b) t0)

   [<a name="SUNTIL_AS_BEFORE-val"><b>SUNTIL_AS_BEFORE</b></a>]  Theorem

      |- a SUNTIL b = (λt0. ¬((λt. ¬a t) BEFORE b) t0)

   [<a name="SUNTIL_AS_SBEFORE-val"><b>SUNTIL_AS_SBEFORE</b></a>]  Theorem

      |- a SUNTIL b = (λt0. ¬((λt. ¬a t) SBEFORE b) t0 ∧ EVENTUAL b t0)

   [<a name="SUNTIL_AS_SWHEN-val"><b>SUNTIL_AS_SWHEN</b></a>]  Theorem

      |- a SUNTIL b = b SWHEN (λt. a t ⇒ b t)

   [<a name="SUNTIL_AS_UNTIL-val"><b>SUNTIL_AS_UNTIL</b></a>]  Theorem

      |- a SUNTIL b = (λt0. (a UNTIL b) t0 ∧ EVENTUAL b t0)

   [<a name="SUNTIL_AS_WHEN-val"><b>SUNTIL_AS_WHEN</b></a>]  Theorem

      |- a SUNTIL b = (λt. (b WHEN (λt. a t ⇒ b t)) t ∧ EVENTUAL b t)

   [<a name="SUNTIL_EVENT-val"><b>SUNTIL_EVENT</b></a>]  Theorem

      |- a SUNTIL b = (λt. a t ∧ ¬b t) SUNTIL b

   [<a name="SUNTIL_IDEM-val"><b>SUNTIL_IDEM</b></a>]  Theorem

      |- a SUNTIL b = (a SUNTIL b) SUNTIL b

   [<a name="SUNTIL_IMP-val"><b>SUNTIL_IMP</b></a>]  Theorem

      |- (a SUNTIL b) t0 ⇔
         ∀q.
           (q WATCH b) t0 ⇒
           (∀t. q (t + t0) ∨ b (t + t0) ∨ a (t + t0)) ∧ ∃t. b (t + t0)

   [<a name="SUNTIL_INVARIANT-val"><b>SUNTIL_INVARIANT</b></a>]  Theorem

      |- (a SUNTIL b) t0 ⇔
         (∃J1.
            J1 t0 ∧
            ∀t.
              J1 (t + t0) ∧ ¬b (t + t0) ⇒ a (t + t0) ∧ J1 (SUC (t + t0))) ∧
         ∃J2.
           0 &lt; J2 t0 ∧
           (∀t.
              J2 (SUC (t + t0)) &lt; J2 (t + t0) ∨ (J2 (SUC (t + t0)) = 0)) ∧
           ∀t. 0 &lt; J2 (t + t0) ∧ (J2 (SUC (t + t0)) = 0) ⇒ b (t + t0)

   [<a name="SUNTIL_LINORD-val"><b>SUNTIL_LINORD</b></a>]  Theorem

      |- (a SUNTIL b) t0 ⇔ ∃t1. t0 ≤ t1 ∧ b t1 ∧ UPTO (t0,t1,a)

   [<a name="SUNTIL_NEXT-val"><b>SUNTIL_NEXT</b></a>]  Theorem

      |- ∀a b. NEXT (a SUNTIL b) = NEXT a SUNTIL NEXT b

   [<a name="SUNTIL_REC-val"><b>SUNTIL_REC</b></a>]  Theorem

      |- (a SUNTIL b) t0 ⇔ ¬b t0 ⇒ a t0 ∧ NEXT (a SUNTIL b) t0

   [<a name="SUNTIL_SIGNAL-val"><b>SUNTIL_SIGNAL</b></a>]  Theorem

      |- (a SUNTIL b) t0 ⇔
         ∃delta.
           (∀t. t &lt; delta ⇒ a (t + t0) ∧ ¬b (t + t0)) ∧ b (delta + t0)

   [<a name="SUNTIL_SIMP-val"><b>SUNTIL_SIMP</b></a>]  Theorem

      |- ((λt. F) SUNTIL b = (λt. b t)) ∧ ((λt. T) SUNTIL b = EVENTUAL b) ∧
         (a SUNTIL (λt. F) = (λt. F)) ∧ (a SUNTIL (λt. T) = (λt. T)) ∧
         (a SUNTIL a = (λt. a t))

   [<a name="SWHEN_AS_BEFORE-val"><b>SWHEN_AS_BEFORE</b></a>]  Theorem

      |- a SWHEN b = (λt0. ¬(b BEFORE (λt. a t ∧ b t)) t0)

   [<a name="SWHEN_AS_NOT_WHEN-val"><b>SWHEN_AS_NOT_WHEN</b></a>]  Theorem

      |- (a SWHEN b) t0 ⇔ ¬((λt. ¬a t) WHEN b) t0

   [<a name="SWHEN_AS_SBEFORE-val"><b>SWHEN_AS_SBEFORE</b></a>]  Theorem

      |- a SWHEN b = b SBEFORE (λt. ¬a t ∧ b t)

   [<a name="SWHEN_AS_SUNTIL-val"><b>SWHEN_AS_SUNTIL</b></a>]  Theorem

      |- a SWHEN b = (λt. ¬b t) SUNTIL (λt. a t ∧ b t)

   [<a name="SWHEN_AS_UNTIL-val"><b>SWHEN_AS_UNTIL</b></a>]  Theorem

      |- a SWHEN b =
         (λt. ((λt. ¬b t) UNTIL (λt. a t ∧ b t)) t ∧ EVENTUAL b t)

   [<a name="SWHEN_AS_WHEN-val"><b>SWHEN_AS_WHEN</b></a>]  Theorem

      |- a SWHEN b = (λt0. (a WHEN b) t0 ∧ EVENTUAL b t0)

   [<a name="SWHEN_EVENT-val"><b>SWHEN_EVENT</b></a>]  Theorem

      |- a SWHEN b = (λt. a t ∧ b t) SWHEN b

   [<a name="SWHEN_IDEM-val"><b>SWHEN_IDEM</b></a>]  Theorem

      |- a SWHEN b = (a SWHEN b) SWHEN b

   [<a name="SWHEN_IMP-val"><b>SWHEN_IMP</b></a>]  Theorem

      |- (a SWHEN b) t0 ⇔
         ∀q. (q WATCH b) t0 ⇒ ∃t. ¬q (t + t0) ∧ b (t + t0) ∧ a (t + t0)

   [<a name="SWHEN_INVARIANT-val"><b>SWHEN_INVARIANT</b></a>]  Theorem

      |- (a SWHEN b) t0 ⇔
         (∃J1.
            J1 t0 ∧ (∀t. ¬b (t + t0) ∧ J1 (t + t0) ⇒ J1 (SUC (t + t0))) ∧
            ∀d. b (d + t0) ∧ J1 (d + t0) ⇒ a (d + t0)) ∧
         ∃J2.
           0 &lt; J2 t0 ∧
           (∀t.
              J2 (SUC (t + t0)) &lt; J2 (t + t0) ∨ (J2 (SUC (t + t0)) = 0)) ∧
           ∀t. 0 &lt; J2 (t + t0) ∧ (J2 (SUC (t + t0)) = 0) ⇒ b (t + t0)

   [<a name="SWHEN_LINORD-val"><b>SWHEN_LINORD</b></a>]  Theorem

      |- (a SWHEN b) t0 ⇔
         ∃t1. t0 ≤ t1 ∧ a t1 ∧ b t1 ∧ UPTO (t0,t1,(λt. ¬b t))

   [<a name="SWHEN_NEXT-val"><b>SWHEN_NEXT</b></a>]  Theorem

      |- ∀a b. NEXT (a SWHEN b) = NEXT a SWHEN NEXT b

   [<a name="SWHEN_REC-val"><b>SWHEN_REC</b></a>]  Theorem

      |- (a SWHEN b) t0 ⇔ if b t0 then a t0 else NEXT (a SWHEN b) t0

   [<a name="SWHEN_SIGNAL-val"><b>SWHEN_SIGNAL</b></a>]  Theorem

      |- (a SWHEN b) t0 ⇔
         ∃delta.
           (∀t. t &lt; delta ⇒ ¬b (t + t0)) ∧ b (delta + t0) ∧ a (delta + t0)

   [<a name="SWHEN_SIMP-val"><b>SWHEN_SIMP</b></a>]  Theorem

      |- ((λt. F) SWHEN b = (λt. F)) ∧ ((λt. T) SWHEN b = EVENTUAL b) ∧
         (a SWHEN (λt. F) = (λt. F)) ∧ (a SWHEN (λt. T) = (λt. a t)) ∧
         (a SWHEN a = EVENTUAL a)

   [<a name="UNTIL_AS_BEFORE-val"><b>UNTIL_AS_BEFORE</b></a>]  Theorem

      |- a UNTIL b = (λt0. ¬((λt. ¬a t) BEFORE b) t0 ∨ ALWAYS a t0)

   [<a name="UNTIL_AS_SBEFORE-val"><b>UNTIL_AS_SBEFORE</b></a>]  Theorem

      |- a UNTIL b = (λt0. ¬((λt. ¬a t) SBEFORE b) t0)

   [<a name="UNTIL_AS_SUNTIL-val"><b>UNTIL_AS_SUNTIL</b></a>]  Theorem

      |- a UNTIL b = (λt. (a SUNTIL b) t ∨ ALWAYS a t)

   [<a name="UNTIL_AS_SWHEN-val"><b>UNTIL_AS_SWHEN</b></a>]  Theorem

      |- a UNTIL b = (λt. (b SWHEN (λt. a t ⇒ b t)) t ∨ ALWAYS a t)

   [<a name="UNTIL_AS_WHEN-val"><b>UNTIL_AS_WHEN</b></a>]  Theorem

      |- a UNTIL b = b WHEN (λt. a t ⇒ b t)

   [<a name="UNTIL_EVENT-val"><b>UNTIL_EVENT</b></a>]  Theorem

      |- a UNTIL b = (λt. a t ∧ ¬b t) UNTIL b

   [<a name="UNTIL_FIX-val"><b>UNTIL_FIX</b></a>]  Theorem

      |- (y = (λt. ¬b t ⇒ a t ∧ y (t + 1))) ⇔
         (y = a UNTIL b) ∨ (y = a SUNTIL b)

   [<a name="UNTIL_IDEM-val"><b>UNTIL_IDEM</b></a>]  Theorem

      |- a UNTIL b = (a UNTIL b) UNTIL b

   [<a name="UNTIL_IMP-val"><b>UNTIL_IMP</b></a>]  Theorem

      |- (a UNTIL b) t0 ⇔
         ∀q. (q WATCH b) t0 ⇒ ∀t. q (t + t0) ∨ b (t + t0) ∨ a (t + t0)

   [<a name="UNTIL_INVARIANT-val"><b>UNTIL_INVARIANT</b></a>]  Theorem

      |- ∀t0.
           (a UNTIL b) t0 ⇔
           ∃J.
             J t0 ∧
             ∀t. J (t + t0) ∧ ¬b (t + t0) ⇒ a (t + t0) ∧ J (SUC (t + t0))

   [<a name="UNTIL_LINORD-val"><b>UNTIL_LINORD</b></a>]  Theorem

      |- (a UNTIL b) t0 ⇔
         ∀t1. t0 ≤ t1 ∧ ¬b t1 ∧ UPTO (t0,t1,(λt. ¬b t)) ⇒ a t1

   [<a name="UNTIL_NEXT-val"><b>UNTIL_NEXT</b></a>]  Theorem

      |- ∀a b. NEXT (a UNTIL b) = NEXT a UNTIL NEXT b

   [<a name="UNTIL_REC-val"><b>UNTIL_REC</b></a>]  Theorem

      |- (a UNTIL b) t0 ⇔ ¬b t0 ⇒ a t0 ∧ NEXT (a UNTIL b) t0

   [<a name="UNTIL_SIGNAL-val"><b>UNTIL_SIGNAL</b></a>]  Theorem

      |- (a UNTIL b) t0 ⇔
         ((∀t. ¬b (t + t0)) ⇒ ∀t. a (t + t0)) ∧
         ∀d.
           (∀t. t &lt; d ⇒ ¬b (t + t0)) ∧ b (d + t0) ⇒ ∀t. t &lt; d ⇒ a (t + t0)

   [<a name="UNTIL_SIMP-val"><b>UNTIL_SIMP</b></a>]  Theorem

      |- ((λt. F) UNTIL b = (λt. b t)) ∧ ((λt. T) UNTIL b = (λt. T)) ∧
         (a UNTIL (λt. F) = ALWAYS a) ∧ (a UNTIL (λt. T) = (λt. T)) ∧
         (a UNTIL a = (λt. a t))

   [<a name="WATCH_EXISTS-val"><b>WATCH_EXISTS</b></a>]  Theorem

      |- ∀b t0. ∃q. (q WATCH b) t0

   [<a name="WATCH_REC-val"><b>WATCH_REC</b></a>]  Theorem

      |- (q WATCH b) t0 ⇔
         ¬q t0 ∧ if b t0 then NEXT (ALWAYS q) t0 else NEXT (q WATCH b) t0

   [<a name="WATCH_SIGNAL-val"><b>WATCH_SIGNAL</b></a>]  Theorem

      |- (q WATCH b) t0 ⇔
         ((∀t. ¬b (t + t0)) ⇒ ∀t. ¬q (t + t0)) ∧
         ∀d.
           b (d + t0) ∧ (∀t. t &lt; d ⇒ ¬b (t + t0)) ⇒
           (∀t. t ≤ d ⇒ ¬q (t + t0)) ∧ ∀t. q (SUC (t + (d + t0)))

   [<a name="WELL_ORDER-val"><b>WELL_ORDER</b></a>]  Theorem

      |- (∃n. P n) ⇔ ∃m. P m ∧ ∀n. n &lt; m ⇒ ¬P n

   [<a name="WELL_ORDER_UNIQUE-val"><b>WELL_ORDER_UNIQUE</b></a>]  Theorem

      |- ∀m2 m1 P.
           (P m1 ∧ ∀n. n &lt; m1 ⇒ ¬P n) ∧ P m2 ∧ (∀n. n &lt; m2 ⇒ ¬P n) ⇒
           (m1 = m2)

   [<a name="WHEN_AS_BEFORE-val"><b>WHEN_AS_BEFORE</b></a>]  Theorem

      |- a WHEN b =
         (λt0. ¬(b BEFORE (λt. a t ∧ b t)) t0 ∨ ALWAYS (λt. ¬b t) t0)

   [<a name="WHEN_AS_NOT_SWHEN-val"><b>WHEN_AS_NOT_SWHEN</b></a>]  Theorem

      |- (a WHEN b) t0 ⇔ ¬((λt. ¬a t) SWHEN b) t0

   [<a name="WHEN_AS_SBEFORE-val"><b>WHEN_AS_SBEFORE</b></a>]  Theorem

      |- a WHEN b =
         (λt0. (b SBEFORE (λt. ¬a t ∧ b t)) t0 ∨ ALWAYS (λt. ¬b t) t0)

   [<a name="WHEN_AS_SUNTIL-val"><b>WHEN_AS_SUNTIL</b></a>]  Theorem

      |- a WHEN b =
         (λt. ((λt. ¬b t) SUNTIL (λt. a t ∧ b t)) t ∨ ALWAYS (λt. ¬b t) t)

   [<a name="WHEN_AS_SWHEN-val"><b>WHEN_AS_SWHEN</b></a>]  Theorem

      |- a WHEN b = (λt. (a SWHEN b) t ∨ ALWAYS (λt. ¬b t) t)

   [<a name="WHEN_AS_UNTIL-val"><b>WHEN_AS_UNTIL</b></a>]  Theorem

      |- a WHEN b = (λt. ¬b t) UNTIL (λt. a t ∧ b t)

   [<a name="WHEN_EVENT-val"><b>WHEN_EVENT</b></a>]  Theorem

      |- a WHEN b = (λt. a t ∧ b t) WHEN b

   [<a name="WHEN_FIX-val"><b>WHEN_FIX</b></a>]  Theorem

      |- (y = (λt. if b t then a t else y (t + 1))) ⇔
         (y = a WHEN b) ∨ (y = a SWHEN b)

   [<a name="WHEN_IDEM-val"><b>WHEN_IDEM</b></a>]  Theorem

      |- a WHEN b = (a WHEN b) WHEN b

   [<a name="WHEN_IMP-val"><b>WHEN_IMP</b></a>]  Theorem

      |- (a WHEN b) t0 ⇔
         ∀q. (q WATCH b) t0 ⇒ ∀t. q (t + t0) ∨ (b (t + t0) ⇒ a (t + t0))

   [<a name="WHEN_INVARIANT-val"><b>WHEN_INVARIANT</b></a>]  Theorem

      |- (a WHEN b) t0 ⇔
         ∃J.
           J t0 ∧ (∀t. ¬b (t + t0) ∧ J (t + t0) ⇒ J (SUC (t + t0))) ∧
           ∀d. b (d + t0) ∧ J (d + t0) ⇒ a (d + t0)

   [<a name="WHEN_LINORD-val"><b>WHEN_LINORD</b></a>]  Theorem

      |- (a WHEN b) t0 ⇔
         ∀t1. t0 ≤ t1 ∧ b t1 ∧ UPTO (t0,t1,(λt. ¬b t)) ⇒ a t1

   [<a name="WHEN_NEXT-val"><b>WHEN_NEXT</b></a>]  Theorem

      |- ∀a b. NEXT (a WHEN b) = NEXT a WHEN NEXT b

   [<a name="WHEN_REC-val"><b>WHEN_REC</b></a>]  Theorem

      |- (a WHEN b) t0 ⇔ if b t0 then a t0 else NEXT (a WHEN b) t0

   [<a name="WHEN_SIGNAL-val"><b>WHEN_SIGNAL</b></a>]  Theorem

      |- (a WHEN b) t0 ⇔
         ∀delta.
           (∀t. t &lt; delta ⇒ ¬b (t + t0)) ∧ b (delta + t0) ⇒ a (delta + t0)

   [<a name="WHEN_SIMP-val"><b>WHEN_SIMP</b></a>]  Theorem

      |- ((λt. F) WHEN b = ALWAYS (λt. ¬b t)) ∧
         ((λt. T) WHEN b = (λt. T)) ∧ (a WHEN (λt. F) = (λt. T)) ∧
         (a WHEN (λt. T) = (λt. a t)) ∧ (a WHEN a = (λt. T))

   [<a name="WHEN_SWHEN_LEMMA-val"><b>WHEN_SWHEN_LEMMA</b></a>]  Theorem

      |- if ∀t1. ∃t2. b (t2 + t1) then ∀t0. (a WHEN b) t0 ⇔ (a SWHEN b) t0
         else ∃t1. ∀t2. (a WHEN b) (t2 + t1) ∧ ¬(a SWHEN b) (t2 + t1)


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/temporal/src/Temporal_LogicScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-9</a></em></p></body></html>
