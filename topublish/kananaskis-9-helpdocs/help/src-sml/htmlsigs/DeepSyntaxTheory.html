<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure DeepSyntaxTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure DeepSyntaxTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/integer/DeepSyntaxScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature DeepSyntaxTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#Aset_def-val">Aset_def</a> : thm
<a name="line7"></a>    val <a href="#Bset_def-val">Bset_def</a> : thm
<a name="line8"></a>    val <a href="#alldivide_def-val">alldivide_def</a> : thm
<a name="line9"></a>    val <a href="#deep_form_TY_DEF-val">deep_form_TY_DEF</a> : thm
<a name="line10"></a>    val <a href="#deep_form_case_def-val">deep_form_case_def</a> : thm
<a name="line11"></a>    val <a href="#deep_form_size_def-val">deep_form_size_def</a> : thm
<a name="line12"></a>    val <a href="#eval_form_def-val">eval_form_def</a> : thm
<a name="line13"></a>    val <a href="#neginf_def-val">neginf_def</a> : thm
<a name="line14"></a>    val <a href="#posinf_def-val">posinf_def</a> : thm
<a name="line15"></a>
<a name="line16"></a>  (*  Theorems  *)
<a name="line17"></a>    val <a href="#add_d_neginf-val">add_d_neginf</a> : thm
<a name="line18"></a>    val <a href="#add_d_posinf-val">add_d_posinf</a> : thm
<a name="line19"></a>    val <a href="#datatype_deep_form-val">datatype_deep_form</a> : thm
<a name="line20"></a>    val <a href="#deep_form_11-val">deep_form_11</a> : thm
<a name="line21"></a>    val <a href="#deep_form_Axiom-val">deep_form_Axiom</a> : thm
<a name="line22"></a>    val <a href="#deep_form_case_cong-val">deep_form_case_cong</a> : thm
<a name="line23"></a>    val <a href="#deep_form_distinct-val">deep_form_distinct</a> : thm
<a name="line24"></a>    val <a href="#deep_form_induction-val">deep_form_induction</a> : thm
<a name="line25"></a>    val <a href="#deep_form_nchotomy-val">deep_form_nchotomy</a> : thm
<a name="line26"></a>    val <a href="#in_aset-val">in_aset</a> : thm
<a name="line27"></a>    val <a href="#in_bset-val">in_bset</a> : thm
<a name="line28"></a>    val <a href="#neginf_disj1_implies_exoriginal-val">neginf_disj1_implies_exoriginal</a> : thm
<a name="line29"></a>    val <a href="#neginf_exoriginal_eq_rhs-val">neginf_exoriginal_eq_rhs</a> : thm
<a name="line30"></a>    val <a href="#neginf_exoriginal_implies_rhs-val">neginf_exoriginal_implies_rhs</a> : thm
<a name="line31"></a>    val <a href="#neginf_ok-val">neginf_ok</a> : thm
<a name="line32"></a>    val <a href="#posinf_disj1_implies_exoriginal-val">posinf_disj1_implies_exoriginal</a> : thm
<a name="line33"></a>    val <a href="#posinf_exoriginal_eq_rhs-val">posinf_exoriginal_eq_rhs</a> : thm
<a name="line34"></a>    val <a href="#posinf_exoriginal_implies_rhs-val">posinf_exoriginal_implies_rhs</a> : thm
<a name="line35"></a>    val <a href="#posinf_ok-val">posinf_ok</a> : thm
<a name="line36"></a>
<a name="line37"></a>  val DeepSyntax_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line38"></a>(*
   [int_arith] Parent theory of "DeepSyntax"

   [<a name="Aset_def-val"><b>Aset_def</b></a>]  Definition

      |- (∀pos f1 f2. Aset pos (Conjn f1 f2) = Aset pos f1 ∪ Aset pos f2) ∧
         (∀pos f1 f2. Aset pos (Disjn f1 f2) = Aset pos f1 ∪ Aset pos f2) ∧
         (∀pos f. Aset pos (Negn f) = Aset (¬pos) f) ∧
         (∀pos b. Aset pos (UnrelatedBool b) = ∅) ∧
         (∀pos i. Aset pos (xLT i) = if pos then {i} else ∅) ∧
         (∀pos i. Aset pos (LTx i) = if pos then ∅ else {i + 1}) ∧
         (∀pos i. Aset pos (xEQ i) = if pos then {i + 1} else {i}) ∧
         ∀pos i1 i2. Aset pos (xDivided i1 i2) = ∅

   [<a name="Bset_def-val"><b>Bset_def</b></a>]  Definition

      |- (∀pos f1 f2. Bset pos (Conjn f1 f2) = Bset pos f1 ∪ Bset pos f2) ∧
         (∀pos f1 f2. Bset pos (Disjn f1 f2) = Bset pos f1 ∪ Bset pos f2) ∧
         (∀pos f. Bset pos (Negn f) = Bset (¬pos) f) ∧
         (∀pos b. Bset pos (UnrelatedBool b) = ∅) ∧
         (∀pos i. Bset pos (xLT i) = if pos then ∅ else {i + -1}) ∧
         (∀pos i. Bset pos (LTx i) = if pos then {i} else ∅) ∧
         (∀pos i. Bset pos (xEQ i) = if pos then {i + -1} else {i}) ∧
         ∀pos i1 i2. Bset pos (xDivided i1 i2) = ∅

   [<a name="alldivide_def-val"><b>alldivide_def</b></a>]  Definition

      |- (∀f1 f2 d.
            alldivide (Conjn f1 f2) d ⇔ alldivide f1 d ∧ alldivide f2 d) ∧
         (∀f1 f2 d.
            alldivide (Disjn f1 f2) d ⇔ alldivide f1 d ∧ alldivide f2 d) ∧
         (∀f d. alldivide (Negn f) d ⇔ alldivide f d) ∧
         (∀b d. alldivide (UnrelatedBool b) d ⇔ T) ∧
         (∀i d. alldivide (xLT i) d ⇔ T) ∧
         (∀i d. alldivide (LTx i) d ⇔ T) ∧
         (∀i d. alldivide (xEQ i) d ⇔ T) ∧
         ∀i1 i2 d. alldivide (xDivided i1 i2) d ⇔ i1 int_divides d

   [<a name="deep_form_TY_DEF-val"><b>deep_form_TY_DEF</b></a>]  Definition

      |- ∃rep.
           TYPE_DEFINITION
             (λa0'.
                ∀'deep_form' .
                  (∀a0'.
                     (∃a0 a1.
                        (a0' =
                         (λa0 a1.
                            ind_type$CONSTR 0 (ARB,ARB,ARB)
                              (ind_type$FCONS a0
                                 (ind_type$FCONS a1
                                    (λn. ind_type$BOTTOM)))) a0 a1) ∧
                        'deep_form' a0 ∧ 'deep_form' a1) ∨
                     (∃a0 a1.
                        (a0' =
                         (λa0 a1.
                            ind_type$CONSTR (SUC 0) (ARB,ARB,ARB)
                              (ind_type$FCONS a0
                                 (ind_type$FCONS a1
                                    (λn. ind_type$BOTTOM)))) a0 a1) ∧
                        'deep_form' a0 ∧ 'deep_form' a1) ∨
                     (∃a.
                        (a0' =
                         (λa.
                            ind_type$CONSTR (SUC (SUC 0)) (ARB,ARB,ARB)
                              (ind_type$FCONS a (λn. ind_type$BOTTOM)))
                           a) ∧ 'deep_form' a) ∨
                     (∃a.
                        a0' =
                        (λa.
                           ind_type$CONSTR (SUC (SUC (SUC 0))) (a,ARB,ARB)
                             (λn. ind_type$BOTTOM)) a) ∨
                     (∃a.
                        a0' =
                        (λa.
                           ind_type$CONSTR (SUC (SUC (SUC (SUC 0))))
                             (ARB,a,ARB) (λn. ind_type$BOTTOM)) a) ∨
                     (∃a.
                        a0' =
                        (λa.
                           ind_type$CONSTR (SUC (SUC (SUC (SUC (SUC 0)))))
                             (ARB,a,ARB) (λn. ind_type$BOTTOM)) a) ∨
                     (∃a.
                        a0' =
                        (λa.
                           ind_type$CONSTR
                             (SUC (SUC (SUC (SUC (SUC (SUC 0))))))
                             (ARB,a,ARB) (λn. ind_type$BOTTOM)) a) ∨
                     (∃a0 a1.
                        a0' =
                        (λa0 a1.
                           ind_type$CONSTR
                             (SUC (SUC (SUC (SUC (SUC (SUC (SUC 0)))))))
                             (ARB,a0,a1) (λn. ind_type$BOTTOM)) a0 a1) ⇒
                     'deep_form' a0') ⇒
                  'deep_form' a0') rep

   [<a name="deep_form_case_def-val"><b>deep_form_case_def</b></a>]  Definition

      |- (∀a0 a1 f f1 f2 f3 f4 f5 f6 f7.
            deep_form_CASE (Conjn a0 a1) f f1 f2 f3 f4 f5 f6 f7 =
            f a0 a1) ∧
         (∀a0 a1 f f1 f2 f3 f4 f5 f6 f7.
            deep_form_CASE (Disjn a0 a1) f f1 f2 f3 f4 f5 f6 f7 =
            f1 a0 a1) ∧
         (∀a f f1 f2 f3 f4 f5 f6 f7.
            deep_form_CASE (Negn a) f f1 f2 f3 f4 f5 f6 f7 = f2 a) ∧
         (∀a f f1 f2 f3 f4 f5 f6 f7.
            deep_form_CASE (UnrelatedBool a) f f1 f2 f3 f4 f5 f6 f7 =
            f3 a) ∧
         (∀a f f1 f2 f3 f4 f5 f6 f7.
            deep_form_CASE (xLT a) f f1 f2 f3 f4 f5 f6 f7 = f4 a) ∧
         (∀a f f1 f2 f3 f4 f5 f6 f7.
            deep_form_CASE (LTx a) f f1 f2 f3 f4 f5 f6 f7 = f5 a) ∧
         (∀a f f1 f2 f3 f4 f5 f6 f7.
            deep_form_CASE (xEQ a) f f1 f2 f3 f4 f5 f6 f7 = f6 a) ∧
         ∀a0 a1 f f1 f2 f3 f4 f5 f6 f7.
           deep_form_CASE (xDivided a0 a1) f f1 f2 f3 f4 f5 f6 f7 =
           f7 a0 a1

   [<a name="deep_form_size_def-val"><b>deep_form_size_def</b></a>]  Definition

      |- (∀a0 a1.
            deep_form_size (Conjn a0 a1) =
            1 + (deep_form_size a0 + deep_form_size a1)) ∧
         (∀a0 a1.
            deep_form_size (Disjn a0 a1) =
            1 + (deep_form_size a0 + deep_form_size a1)) ∧
         (∀a. deep_form_size (Negn a) = 1 + deep_form_size a) ∧
         (∀a. deep_form_size (UnrelatedBool a) = 1 + bool_size a) ∧
         (∀a. deep_form_size (xLT a) = 1) ∧
         (∀a. deep_form_size (LTx a) = 1) ∧
         (∀a. deep_form_size (xEQ a) = 1) ∧
         ∀a0 a1. deep_form_size (xDivided a0 a1) = 1

   [<a name="eval_form_def-val"><b>eval_form_def</b></a>]  Definition

      |- (∀f1 f2 x.
            eval_form (Conjn f1 f2) x ⇔ eval_form f1 x ∧ eval_form f2 x) ∧
         (∀f1 f2 x.
            eval_form (Disjn f1 f2) x ⇔ eval_form f1 x ∨ eval_form f2 x) ∧
         (∀f x. eval_form (Negn f) x ⇔ ¬eval_form f x) ∧
         (∀b x. eval_form (UnrelatedBool b) x ⇔ b) ∧
         (∀i x. eval_form (xLT i) x ⇔ x &lt; i) ∧
         (∀i x. eval_form (LTx i) x ⇔ i &lt; x) ∧
         (∀i x. eval_form (xEQ i) x ⇔ (x = i)) ∧
         ∀i1 i2 x. eval_form (xDivided i1 i2) x ⇔ i1 int_divides x + i2

   [<a name="neginf_def-val"><b>neginf_def</b></a>]  Definition

      |- (∀f1 f2. neginf (Conjn f1 f2) = Conjn (neginf f1) (neginf f2)) ∧
         (∀f1 f2. neginf (Disjn f1 f2) = Disjn (neginf f1) (neginf f2)) ∧
         (∀f. neginf (Negn f) = Negn (neginf f)) ∧
         (∀b. neginf (UnrelatedBool b) = UnrelatedBool b) ∧
         (∀i. neginf (xLT i) = UnrelatedBool T) ∧
         (∀i. neginf (LTx i) = UnrelatedBool F) ∧
         (∀i. neginf (xEQ i) = UnrelatedBool F) ∧
         ∀i1 i2. neginf (xDivided i1 i2) = xDivided i1 i2

   [<a name="posinf_def-val"><b>posinf_def</b></a>]  Definition

      |- (∀f1 f2. posinf (Conjn f1 f2) = Conjn (posinf f1) (posinf f2)) ∧
         (∀f1 f2. posinf (Disjn f1 f2) = Disjn (posinf f1) (posinf f2)) ∧
         (∀f. posinf (Negn f) = Negn (posinf f)) ∧
         (∀b. posinf (UnrelatedBool b) = UnrelatedBool b) ∧
         (∀i. posinf (xLT i) = UnrelatedBool F) ∧
         (∀i. posinf (LTx i) = UnrelatedBool T) ∧
         (∀i. posinf (xEQ i) = UnrelatedBool F) ∧
         ∀i1 i2. posinf (xDivided i1 i2) = xDivided i1 i2

   [<a name="add_d_neginf-val"><b>add_d_neginf</b></a>]  Theorem

      |- ∀f x y d.
           alldivide f d ⇒
           (eval_form (neginf f) x ⇔ eval_form (neginf f) (x + y * d))

   [<a name="add_d_posinf-val"><b>add_d_posinf</b></a>]  Theorem

      |- ∀f x y d.
           alldivide f d ⇒
           (eval_form (posinf f) x ⇔ eval_form (posinf f) (x + y * d))

   [<a name="datatype_deep_form-val"><b>datatype_deep_form</b></a>]  Theorem

      |- DATATYPE
           (deep_form Conjn Disjn Negn UnrelatedBool xLT LTx xEQ xDivided)

   [<a name="deep_form_11-val"><b>deep_form_11</b></a>]  Theorem

      |- (∀a0 a1 a0' a1'.
            (Conjn a0 a1 = Conjn a0' a1') ⇔ (a0 = a0') ∧ (a1 = a1')) ∧
         (∀a0 a1 a0' a1'.
            (Disjn a0 a1 = Disjn a0' a1') ⇔ (a0 = a0') ∧ (a1 = a1')) ∧
         (∀a a'. (Negn a = Negn a') ⇔ (a = a')) ∧
         (∀a a'. (UnrelatedBool a = UnrelatedBool a') ⇔ (a ⇔ a')) ∧
         (∀a a'. (xLT a = xLT a') ⇔ (a = a')) ∧
         (∀a a'. (LTx a = LTx a') ⇔ (a = a')) ∧
         (∀a a'. (xEQ a = xEQ a') ⇔ (a = a')) ∧
         ∀a0 a1 a0' a1'.
           (xDivided a0 a1 = xDivided a0' a1') ⇔ (a0 = a0') ∧ (a1 = a1')

   [<a name="deep_form_Axiom-val"><b>deep_form_Axiom</b></a>]  Theorem

      |- ∀f0 f1 f2 f3 f4 f5 f6 f7.
           ∃fn.
             (∀a0 a1. fn (Conjn a0 a1) = f0 a0 a1 (fn a0) (fn a1)) ∧
             (∀a0 a1. fn (Disjn a0 a1) = f1 a0 a1 (fn a0) (fn a1)) ∧
             (∀a. fn (Negn a) = f2 a (fn a)) ∧
             (∀a. fn (UnrelatedBool a) = f3 a) ∧ (∀a. fn (xLT a) = f4 a) ∧
             (∀a. fn (LTx a) = f5 a) ∧ (∀a. fn (xEQ a) = f6 a) ∧
             ∀a0 a1. fn (xDivided a0 a1) = f7 a0 a1

   [<a name="deep_form_case_cong-val"><b>deep_form_case_cong</b></a>]  Theorem

      |- ∀M M' f f1 f2 f3 f4 f5 f6 f7.
           (M = M') ∧ (∀a0 a1. (M' = Conjn a0 a1) ⇒ (f a0 a1 = f' a0 a1)) ∧
           (∀a0 a1. (M' = Disjn a0 a1) ⇒ (f1 a0 a1 = f1' a0 a1)) ∧
           (∀a. (M' = Negn a) ⇒ (f2 a = f2' a)) ∧
           (∀a. (M' = UnrelatedBool a) ⇒ (f3 a = f3' a)) ∧
           (∀a. (M' = xLT a) ⇒ (f4 a = f4' a)) ∧
           (∀a. (M' = LTx a) ⇒ (f5 a = f5' a)) ∧
           (∀a. (M' = xEQ a) ⇒ (f6 a = f6' a)) ∧
           (∀a0 a1. (M' = xDivided a0 a1) ⇒ (f7 a0 a1 = f7' a0 a1)) ⇒
           (deep_form_CASE M f f1 f2 f3 f4 f5 f6 f7 =
            deep_form_CASE M' f' f1' f2' f3' f4' f5' f6' f7')

   [<a name="deep_form_distinct-val"><b>deep_form_distinct</b></a>]  Theorem

      |- (∀a1' a1 a0' a0. Conjn a0 a1 ≠ Disjn a0' a1') ∧
         (∀a1 a0 a. Conjn a0 a1 ≠ Negn a) ∧
         (∀a1 a0 a. Conjn a0 a1 ≠ UnrelatedBool a) ∧
         (∀a1 a0 a. Conjn a0 a1 ≠ xLT a) ∧
         (∀a1 a0 a. Conjn a0 a1 ≠ LTx a) ∧
         (∀a1 a0 a. Conjn a0 a1 ≠ xEQ a) ∧
         (∀a1' a1 a0' a0. Conjn a0 a1 ≠ xDivided a0' a1') ∧
         (∀a1 a0 a. Disjn a0 a1 ≠ Negn a) ∧
         (∀a1 a0 a. Disjn a0 a1 ≠ UnrelatedBool a) ∧
         (∀a1 a0 a. Disjn a0 a1 ≠ xLT a) ∧
         (∀a1 a0 a. Disjn a0 a1 ≠ LTx a) ∧
         (∀a1 a0 a. Disjn a0 a1 ≠ xEQ a) ∧
         (∀a1' a1 a0' a0. Disjn a0 a1 ≠ xDivided a0' a1') ∧
         (∀a' a. Negn a ≠ UnrelatedBool a') ∧ (∀a' a. Negn a ≠ xLT a') ∧
         (∀a' a. Negn a ≠ LTx a') ∧ (∀a' a. Negn a ≠ xEQ a') ∧
         (∀a1 a0 a. Negn a ≠ xDivided a0 a1) ∧
         (∀a' a. UnrelatedBool a ≠ xLT a') ∧
         (∀a' a. UnrelatedBool a ≠ LTx a') ∧
         (∀a' a. UnrelatedBool a ≠ xEQ a') ∧
         (∀a1 a0 a. UnrelatedBool a ≠ xDivided a0 a1) ∧
         (∀a' a. xLT a ≠ LTx a') ∧ (∀a' a. xLT a ≠ xEQ a') ∧
         (∀a1 a0 a. xLT a ≠ xDivided a0 a1) ∧ (∀a' a. LTx a ≠ xEQ a') ∧
         (∀a1 a0 a. LTx a ≠ xDivided a0 a1) ∧
         ∀a1 a0 a. xEQ a ≠ xDivided a0 a1

   [<a name="deep_form_induction-val"><b>deep_form_induction</b></a>]  Theorem

      |- ∀P.
           (∀d d0. P d ∧ P d0 ⇒ P (Conjn d d0)) ∧
           (∀d d0. P d ∧ P d0 ⇒ P (Disjn d d0)) ∧ (∀d. P d ⇒ P (Negn d)) ∧
           (∀b. P (UnrelatedBool b)) ∧ (∀i. P (xLT i)) ∧ (∀i. P (LTx i)) ∧
           (∀i. P (xEQ i)) ∧ (∀i i0. P (xDivided i i0)) ⇒
           ∀d. P d

   [<a name="deep_form_nchotomy-val"><b>deep_form_nchotomy</b></a>]  Theorem

      |- ∀dd.
           (∃d d0. dd = Conjn d d0) ∨ (∃d d0. dd = Disjn d d0) ∨
           (∃d. dd = Negn d) ∨ (∃b. dd = UnrelatedBool b) ∨
           (∃i. dd = xLT i) ∨ (∃i. dd = LTx i) ∨ (∃i. dd = xEQ i) ∨
           ∃i i0. dd = xDivided i i0

   [<a name="in_aset-val"><b>in_aset</b></a>]  Theorem

      |- ((∃a. a ∈ Aset pos (Conjn f1 f2) ∧ P a) ⇔
          (∃a. a ∈ Aset pos f1 ∧ P a) ∨ ∃a. a ∈ Aset pos f2 ∧ P a) ∧
         ((∃a. a ∈ Aset pos (Disjn f1 f2) ∧ P a) ⇔
          (∃a. a ∈ Aset pos f1 ∧ P a) ∨ ∃a. a ∈ Aset pos f2 ∧ P a) ∧
         ((∃a. a ∈ Aset T (Negn f) ∧ P a) ⇔ ∃a. a ∈ Aset F f ∧ P a) ∧
         ((∃a. a ∈ Aset F (Negn f) ∧ P a) ⇔ ∃a. a ∈ Aset T f ∧ P a) ∧
         ((∃a. a ∈ Aset pos (UnrelatedBool a0) ∧ P a) ⇔ F) ∧
         ((∃a. a ∈ Aset T (xLT i) ∧ P a) ⇔ P i) ∧
         ((∃a. a ∈ Aset F (xLT i) ∧ P a) ⇔ F) ∧
         ((∃a. a ∈ Aset T (LTx i) ∧ P a) ⇔ F) ∧
         ((∃a. a ∈ Aset F (LTx i) ∧ P a) ⇔ P (i + 1)) ∧
         ((∃a. a ∈ Aset T (xEQ i) ∧ P a) ⇔ P (i + 1)) ∧
         ((∃a. a ∈ Aset F (xEQ i) ∧ P a) ⇔ P i) ∧
         ((∃a. a ∈ Aset pos (xDivided i1 i2) ∧ P a) ⇔ F)

   [<a name="in_bset-val"><b>in_bset</b></a>]  Theorem

      |- ((∃b. b ∈ Bset pos (Conjn f1 f2) ∧ P b) ⇔
          (∃b. b ∈ Bset pos f1 ∧ P b) ∨ ∃b. b ∈ Bset pos f2 ∧ P b) ∧
         ((∃b. b ∈ Bset pos (Disjn f1 f2) ∧ P b) ⇔
          (∃b. b ∈ Bset pos f1 ∧ P b) ∨ ∃b. b ∈ Bset pos f2 ∧ P b) ∧
         ((∃b. b ∈ Bset T (Negn f) ∧ P b) ⇔ ∃b. b ∈ Bset F f ∧ P b) ∧
         ((∃b. b ∈ Bset F (Negn f) ∧ P b) ⇔ ∃b. b ∈ Bset T f ∧ P b) ∧
         ((∃b. b ∈ Bset pos (UnrelatedBool b0) ∧ P b) ⇔ F) ∧
         ((∃b. b ∈ Bset T (xLT i) ∧ P b) ⇔ F) ∧
         ((∃b. b ∈ Bset F (xLT i) ∧ P b) ⇔ P (i + -1)) ∧
         ((∃b. b ∈ Bset T (LTx i) ∧ P b) ⇔ P i) ∧
         ((∃b. b ∈ Bset F (LTx i) ∧ P b) ⇔ F) ∧
         ((∃b. b ∈ Bset T (xEQ i) ∧ P b) ⇔ P (i + -1)) ∧
         ((∃b. b ∈ Bset F (xEQ i) ∧ P b) ⇔ P i) ∧
         ((∃b. b ∈ Bset pos (xDivided i1 i2) ∧ P b) ⇔ F)

   [<a name="neginf_disj1_implies_exoriginal-val"><b>neginf_disj1_implies_exoriginal</b></a>]  Theorem

      |- ∀f d i.
           alldivide f d ⇒
           0 &lt; i ∧ i ≤ d ∧ eval_form (neginf f) i ⇒
           ∃x. eval_form f x

   [<a name="neginf_exoriginal_eq_rhs-val"><b>neginf_exoriginal_eq_rhs</b></a>]  Theorem

      |- ∀f d.
           alldivide f d ∧ 0 &lt; d ⇒
           ((∃x. eval_form f x) ⇔
            (∃i. K (0 &lt; i ∧ i ≤ d) i ∧ eval_form (neginf f) i) ∨
            ∃b j.
              (b ∈ Bset T f ∧ K (0 &lt; j ∧ j ≤ d) j) ∧ eval_form f (b + j))

   [<a name="neginf_exoriginal_implies_rhs-val"><b>neginf_exoriginal_implies_rhs</b></a>]  Theorem

      |- ∀f d x.
           alldivide f d ∧ 0 &lt; d ⇒
           eval_form f x ⇒
           (∃i. 0 &lt; i ∧ i ≤ d ∧ eval_form (neginf f) i) ∨
           ∃j b. 0 &lt; j ∧ j ≤ d ∧ b ∈ Bset T f ∧ eval_form f (b + j)

   [<a name="neginf_ok-val"><b>neginf_ok</b></a>]  Theorem

      |- ∀f. ∃y. ∀x. x &lt; y ⇒ (eval_form f x ⇔ eval_form (neginf f) x)

   [<a name="posinf_disj1_implies_exoriginal-val"><b>posinf_disj1_implies_exoriginal</b></a>]  Theorem

      |- ∀f d i.
           alldivide f d ⇒
           0 &lt; i ∧ i ≤ d ∧ eval_form (posinf f) i ⇒
           ∃x. eval_form f x

   [<a name="posinf_exoriginal_eq_rhs-val"><b>posinf_exoriginal_eq_rhs</b></a>]  Theorem

      |- ∀f d.
           alldivide f d ∧ 0 &lt; d ⇒
           ((∃x. eval_form f x) ⇔
            (∃i. K (0 &lt; i ∧ i ≤ d) i ∧ eval_form (posinf f) i) ∨
            ∃b j.
              (b ∈ Aset T f ∧ K (0 &lt; j ∧ j ≤ d) j) ∧
              eval_form f (b + -1 * j))

   [<a name="posinf_exoriginal_implies_rhs-val"><b>posinf_exoriginal_implies_rhs</b></a>]  Theorem

      |- ∀f d x.
           alldivide f d ∧ 0 &lt; d ⇒
           eval_form f x ⇒
           (∃i. 0 &lt; i ∧ i ≤ d ∧ eval_form (posinf f) i) ∨
           ∃j b. 0 &lt; j ∧ j ≤ d ∧ b ∈ Aset T f ∧ eval_form f (b + -j)

   [<a name="posinf_ok-val"><b>posinf_ok</b></a>]  Theorem

      |- ∀f. ∃y. ∀x. y &lt; x ⇒ (eval_form f x ⇔ eval_form (posinf f) x)


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/integer/DeepSyntaxScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-9</a></em></p></body></html>
