<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure patriciaTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure patriciaTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/patricia/patriciaScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature patriciaTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#ADD_LIST_def-val">ADD_LIST_def</a> : thm
<a name="line7"></a>    val <a href="#ADD_curried_def-val">ADD_curried_def</a> : thm
<a name="line8"></a>    val <a href="#ADD_tupled_primitive_def-val">ADD_tupled_primitive_def</a> : thm
<a name="line9"></a>    val <a href="#BRANCHING_BIT_curried_def-val">BRANCHING_BIT_curried_def</a> : thm
<a name="line10"></a>    val <a href="#BRANCHING_BIT_tupled_primitive_def-val">BRANCHING_BIT_tupled_primitive_def</a> : thm
<a name="line11"></a>    val <a href="#BRANCH_primitive_def-val">BRANCH_primitive_def</a> : thm
<a name="line12"></a>    val <a href="#DEPTH_def-val">DEPTH_def</a> : thm
<a name="line13"></a>    val <a href="#EVERY_LEAF_def-val">EVERY_LEAF_def</a> : thm
<a name="line14"></a>    val <a href="#EXISTS_LEAF_def-val">EXISTS_LEAF_def</a> : thm
<a name="line15"></a>    val <a href="#FIND_def-val">FIND_def</a> : thm
<a name="line16"></a>    val <a href="#INSERT_PTREE_def-val">INSERT_PTREE_def</a> : thm
<a name="line17"></a>    val <a href="#IN_PTREE_def-val">IN_PTREE_def</a> : thm
<a name="line18"></a>    val <a href="#IS_EMPTY_primitive_def-val">IS_EMPTY_primitive_def</a> : thm
<a name="line19"></a>    val <a href="#IS_PTREE_def-val">IS_PTREE_def</a> : thm
<a name="line20"></a>    val <a href="#JOIN_def-val">JOIN_def</a> : thm
<a name="line21"></a>    val <a href="#KEYS_def-val">KEYS_def</a> : thm
<a name="line22"></a>    val <a href="#NUMSET_OF_PTREE_def-val">NUMSET_OF_PTREE_def</a> : thm
<a name="line23"></a>    val <a href="#PEEK_curried_def-val">PEEK_curried_def</a> : thm
<a name="line24"></a>    val <a href="#PEEK_tupled_primitive_def-val">PEEK_tupled_primitive_def</a> : thm
<a name="line25"></a>    val <a href="#PTREE_OF_NUMSET_def-val">PTREE_OF_NUMSET_def</a> : thm
<a name="line26"></a>    val <a href="#REMOVE_def-val">REMOVE_def</a> : thm
<a name="line27"></a>    val <a href="#SIZE_def-val">SIZE_def</a> : thm
<a name="line28"></a>    val <a href="#TRANSFORM_def-val">TRANSFORM_def</a> : thm
<a name="line29"></a>    val <a href="#TRAVERSE_AUX_def-val">TRAVERSE_AUX_def</a> : thm
<a name="line30"></a>    val <a href="#TRAVERSE_def-val">TRAVERSE_def</a> : thm
<a name="line31"></a>    val <a href="#UNION_PTREE_def-val">UNION_PTREE_def</a> : thm
<a name="line32"></a>    val <a href="#ptree_TY_DEF-val">ptree_TY_DEF</a> : thm
<a name="line33"></a>    val <a href="#ptree_case_def-val">ptree_case_def</a> : thm
<a name="line34"></a>    val <a href="#ptree_size_def-val">ptree_size_def</a> : thm
<a name="line35"></a>
<a name="line36"></a>  (*  Theorems  *)
<a name="line37"></a>    val <a href="#ADD_ADD-val">ADD_ADD</a> : thm
<a name="line38"></a>    val <a href="#ADD_ADD_SYM-val">ADD_ADD_SYM</a> : thm
<a name="line39"></a>    val <a href="#ADD_INSERT-val">ADD_INSERT</a> : thm
<a name="line40"></a>    val <a href="#ADD_IS_PTREE-val">ADD_IS_PTREE</a> : thm
<a name="line41"></a>    val <a href="#ADD_LIST_IS_PTREE-val">ADD_LIST_IS_PTREE</a> : thm
<a name="line42"></a>    val <a href="#ADD_TRANSFORM-val">ADD_TRANSFORM</a> : thm
<a name="line43"></a>    val <a href="#ADD_def-val">ADD_def</a> : thm
<a name="line44"></a>    val <a href="#ADD_ind-val">ADD_ind</a> : thm
<a name="line45"></a>    val <a href="#ALL_DISTINCT_TRAVERSE-val">ALL_DISTINCT_TRAVERSE</a> : thm
<a name="line46"></a>    val <a href="#BRANCH-val">BRANCH</a> : thm
<a name="line47"></a>    val <a href="#BRANCHING_BIT-val">BRANCHING_BIT</a> : thm
<a name="line48"></a>    val <a href="#BRANCHING_BIT_SYM-val">BRANCHING_BIT_SYM</a> : thm
<a name="line49"></a>    val <a href="#BRANCHING_BIT_ZERO-val">BRANCHING_BIT_ZERO</a> : thm
<a name="line50"></a>    val <a href="#BRANCHING_BIT_def-val">BRANCHING_BIT_def</a> : thm
<a name="line51"></a>    val <a href="#BRANCHING_BIT_ind-val">BRANCHING_BIT_ind</a> : thm
<a name="line52"></a>    val <a href="#BRANCH_def-val">BRANCH_def</a> : thm
<a name="line53"></a>    val <a href="#BRANCH_ind-val">BRANCH_ind</a> : thm
<a name="line54"></a>    val <a href="#CARD_LIST_TO_SET-val">CARD_LIST_TO_SET</a> : thm
<a name="line55"></a>    val <a href="#CARD_NUMSET_OF_PTREE-val">CARD_NUMSET_OF_PTREE</a> : thm
<a name="line56"></a>    val <a href="#DELETE_UNION-val">DELETE_UNION</a> : thm
<a name="line57"></a>    val <a href="#EMPTY_IS_PTREE-val">EMPTY_IS_PTREE</a> : thm
<a name="line58"></a>    val <a href="#EVERY_LEAF_ADD-val">EVERY_LEAF_ADD</a> : thm
<a name="line59"></a>    val <a href="#EVERY_LEAF_BRANCH-val">EVERY_LEAF_BRANCH</a> : thm
<a name="line60"></a>    val <a href="#EVERY_LEAF_PEEK-val">EVERY_LEAF_PEEK</a> : thm
<a name="line61"></a>    val <a href="#EVERY_LEAF_REMOVE-val">EVERY_LEAF_REMOVE</a> : thm
<a name="line62"></a>    val <a href="#EVERY_LEAF_TRANSFORM-val">EVERY_LEAF_TRANSFORM</a> : thm
<a name="line63"></a>    val <a href="#FILTER_ALL-val">FILTER_ALL</a> : thm
<a name="line64"></a>    val <a href="#FILTER_NONE-val">FILTER_NONE</a> : thm
<a name="line65"></a>    val <a href="#FINITE_NUMSET_OF_PTREE-val">FINITE_NUMSET_OF_PTREE</a> : thm
<a name="line66"></a>    val <a href="#INSERT_PTREE_IS_PTREE-val">INSERT_PTREE_IS_PTREE</a> : thm
<a name="line67"></a>    val <a href="#IN_NUMSET_OF_PTREE-val">IN_NUMSET_OF_PTREE</a> : thm
<a name="line68"></a>    val <a href="#IN_PTREE_EMPTY-val">IN_PTREE_EMPTY</a> : thm
<a name="line69"></a>    val <a href="#IN_PTREE_INSERT_PTREE-val">IN_PTREE_INSERT_PTREE</a> : thm
<a name="line70"></a>    val <a href="#IN_PTREE_OF_NUMSET-val">IN_PTREE_OF_NUMSET</a> : thm
<a name="line71"></a>    val <a href="#IN_PTREE_OF_NUMSET_EMPTY-val">IN_PTREE_OF_NUMSET_EMPTY</a> : thm
<a name="line72"></a>    val <a href="#IN_PTREE_REMOVE-val">IN_PTREE_REMOVE</a> : thm
<a name="line73"></a>    val <a href="#IN_PTREE_UNION_PTREE-val">IN_PTREE_UNION_PTREE</a> : thm
<a name="line74"></a>    val <a href="#IS_EMPTY_def-val">IS_EMPTY_def</a> : thm
<a name="line75"></a>    val <a href="#IS_EMPTY_ind-val">IS_EMPTY_ind</a> : thm
<a name="line76"></a>    val <a href="#IS_PTREE_BRANCH-val">IS_PTREE_BRANCH</a> : thm
<a name="line77"></a>    val <a href="#IS_PTREE_PEEK-val">IS_PTREE_PEEK</a> : thm
<a name="line78"></a>    val <a href="#KEYS_PEEK-val">KEYS_PEEK</a> : thm
<a name="line79"></a>    val <a href="#MEM_ALL_DISTINCT_IMP_PERM-val">MEM_ALL_DISTINCT_IMP_PERM</a> : thm
<a name="line80"></a>    val <a href="#MEM_TRAVERSE-val">MEM_TRAVERSE</a> : thm
<a name="line81"></a>    val <a href="#MEM_TRAVERSE_INSERT_PTREE-val">MEM_TRAVERSE_INSERT_PTREE</a> : thm
<a name="line82"></a>    val <a href="#MEM_TRAVERSE_PEEK-val">MEM_TRAVERSE_PEEK</a> : thm
<a name="line83"></a>    val <a href="#MONO_EVERY_LEAF-val">MONO_EVERY_LEAF</a> : thm
<a name="line84"></a>    val <a href="#NOT_ADD_EMPTY-val">NOT_ADD_EMPTY</a> : thm
<a name="line85"></a>    val <a href="#NOT_KEY_LEFT_AND_RIGHT-val">NOT_KEY_LEFT_AND_RIGHT</a> : thm
<a name="line86"></a>    val <a href="#NUMSET_OF_PTREE_EMPTY-val">NUMSET_OF_PTREE_EMPTY</a> : thm
<a name="line87"></a>    val <a href="#NUMSET_OF_PTREE_PTREE_OF_NUMSET-val">NUMSET_OF_PTREE_PTREE_OF_NUMSET</a> : thm
<a name="line88"></a>    val <a href="#NUMSET_OF_PTREE_PTREE_OF_NUMSET_EMPTY-val">NUMSET_OF_PTREE_PTREE_OF_NUMSET_EMPTY</a> : thm
<a name="line89"></a>    val <a href="#PEEK_ADD-val">PEEK_ADD</a> : thm
<a name="line90"></a>    val <a href="#PEEK_INSERT_PTREE-val">PEEK_INSERT_PTREE</a> : thm
<a name="line91"></a>    val <a href="#PEEK_NONE-val">PEEK_NONE</a> : thm
<a name="line92"></a>    val <a href="#PEEK_REMOVE-val">PEEK_REMOVE</a> : thm
<a name="line93"></a>    val <a href="#PEEK_TRANSFORM-val">PEEK_TRANSFORM</a> : thm
<a name="line94"></a>    val <a href="#PEEK_def-val">PEEK_def</a> : thm
<a name="line95"></a>    val <a href="#PEEK_ind-val">PEEK_ind</a> : thm
<a name="line96"></a>    val <a href="#PERM_ADD-val">PERM_ADD</a> : thm
<a name="line97"></a>    val <a href="#PERM_DELETE_PTREE-val">PERM_DELETE_PTREE</a> : thm
<a name="line98"></a>    val <a href="#PERM_INSERT_PTREE-val">PERM_INSERT_PTREE</a> : thm
<a name="line99"></a>    val <a href="#PERM_NOT_ADD-val">PERM_NOT_ADD</a> : thm
<a name="line100"></a>    val <a href="#PERM_NOT_REMOVE-val">PERM_NOT_REMOVE</a> : thm
<a name="line101"></a>    val <a href="#PERM_REMOVE-val">PERM_REMOVE</a> : thm
<a name="line102"></a>    val <a href="#PTREE_EQ-val">PTREE_EQ</a> : thm
<a name="line103"></a>    val <a href="#PTREE_EXTENSION-val">PTREE_EXTENSION</a> : thm
<a name="line104"></a>    val <a href="#PTREE_OF_NUMSET_DELETE-val">PTREE_OF_NUMSET_DELETE</a> : thm
<a name="line105"></a>    val <a href="#PTREE_OF_NUMSET_EMPTY-val">PTREE_OF_NUMSET_EMPTY</a> : thm
<a name="line106"></a>    val <a href="#PTREE_OF_NUMSET_INSERT-val">PTREE_OF_NUMSET_INSERT</a> : thm
<a name="line107"></a>    val <a href="#PTREE_OF_NUMSET_INSERT_EMPTY-val">PTREE_OF_NUMSET_INSERT_EMPTY</a> : thm
<a name="line108"></a>    val <a href="#PTREE_OF_NUMSET_IS_PTREE-val">PTREE_OF_NUMSET_IS_PTREE</a> : thm
<a name="line109"></a>    val <a href="#PTREE_OF_NUMSET_IS_PTREE_EMPTY-val">PTREE_OF_NUMSET_IS_PTREE_EMPTY</a> : thm
<a name="line110"></a>    val <a href="#PTREE_OF_NUMSET_NUMSET_OF_PTREE-val">PTREE_OF_NUMSET_NUMSET_OF_PTREE</a> : thm
<a name="line111"></a>    val <a href="#PTREE_OF_NUMSET_UNION-val">PTREE_OF_NUMSET_UNION</a> : thm
<a name="line112"></a>    val <a href="#PTREE_TRAVERSE_EQ-val">PTREE_TRAVERSE_EQ</a> : thm
<a name="line113"></a>    val <a href="#QSORT_MEM_EQ-val">QSORT_MEM_EQ</a> : thm
<a name="line114"></a>    val <a href="#REMOVE_ADD-val">REMOVE_ADD</a> : thm
<a name="line115"></a>    val <a href="#REMOVE_ADD_EQ-val">REMOVE_ADD_EQ</a> : thm
<a name="line116"></a>    val <a href="#REMOVE_IS_PTREE-val">REMOVE_IS_PTREE</a> : thm
<a name="line117"></a>    val <a href="#REMOVE_REMOVE-val">REMOVE_REMOVE</a> : thm
<a name="line118"></a>    val <a href="#REMOVE_TRANSFORM-val">REMOVE_TRANSFORM</a> : thm
<a name="line119"></a>    val <a href="#SIZE-val">SIZE</a> : thm
<a name="line120"></a>    val <a href="#SIZE_ADD-val">SIZE_ADD</a> : thm
<a name="line121"></a>    val <a href="#SIZE_PTREE_OF_NUMSET-val">SIZE_PTREE_OF_NUMSET</a> : thm
<a name="line122"></a>    val <a href="#SIZE_PTREE_OF_NUMSET_EMPTY-val">SIZE_PTREE_OF_NUMSET_EMPTY</a> : thm
<a name="line123"></a>    val <a href="#SIZE_REMOVE-val">SIZE_REMOVE</a> : thm
<a name="line124"></a>    val <a href="#TRANSFORM_BRANCH-val">TRANSFORM_BRANCH</a> : thm
<a name="line125"></a>    val <a href="#TRANSFORM_EMPTY-val">TRANSFORM_EMPTY</a> : thm
<a name="line126"></a>    val <a href="#TRANSFORM_IS_PTREE-val">TRANSFORM_IS_PTREE</a> : thm
<a name="line127"></a>    val <a href="#TRAVERSE_AUX-val">TRAVERSE_AUX</a> : thm
<a name="line128"></a>    val <a href="#TRAVERSE_TRANSFORM-val">TRAVERSE_TRANSFORM</a> : thm
<a name="line129"></a>    val <a href="#UNION_PTREE_ASSOC-val">UNION_PTREE_ASSOC</a> : thm
<a name="line130"></a>    val <a href="#UNION_PTREE_COMM-val">UNION_PTREE_COMM</a> : thm
<a name="line131"></a>    val <a href="#UNION_PTREE_COMM_EMPTY-val">UNION_PTREE_COMM_EMPTY</a> : thm
<a name="line132"></a>    val <a href="#UNION_PTREE_EMPTY-val">UNION_PTREE_EMPTY</a> : thm
<a name="line133"></a>    val <a href="#UNION_PTREE_IS_PTREE-val">UNION_PTREE_IS_PTREE</a> : thm
<a name="line134"></a>    val <a href="#datatype_ptree-val">datatype_ptree</a> : thm
<a name="line135"></a>    val <a href="#ptree_11-val">ptree_11</a> : thm
<a name="line136"></a>    val <a href="#ptree_Axiom-val">ptree_Axiom</a> : thm
<a name="line137"></a>    val <a href="#ptree_case_cong-val">ptree_case_cong</a> : thm
<a name="line138"></a>    val <a href="#ptree_distinct-val">ptree_distinct</a> : thm
<a name="line139"></a>    val <a href="#ptree_induction-val">ptree_induction</a> : thm
<a name="line140"></a>    val <a href="#ptree_nchotomy-val">ptree_nchotomy</a> : thm
<a name="line141"></a>
<a name="line142"></a>  val patricia_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line143"></a>(*
   [sorting] Parent theory of "patricia"

   [words] Parent theory of "patricia"

   [<a name="ADD_LIST_def-val"><b>ADD_LIST_def</b></a>]  Definition

      |- $|++ = FOLDL $|+

   [<a name="ADD_curried_def-val"><b>ADD_curried_def</b></a>]  Definition

      |- ∀x x1. x |+ x1 = ADD_tupled (x,x1)

   [<a name="ADD_tupled_primitive_def-val"><b>ADD_tupled_primitive_def</b></a>]  Definition

      |- ADD_tupled =
         WFREC
           (@R.
              WF R ∧
              (∀l e r p k m.
                 MOD_2EXP_EQ m k p ∧ ¬BIT m k ⇒
                 R (r,k,e) (Branch p m l r,k,e)) ∧
              ∀r e l p k m.
                MOD_2EXP_EQ m k p ∧ BIT m k ⇒
                R (l,k,e) (Branch p m l r,k,e))
           (λADD_tupled a.
              case a of
                (&lt;{}&gt;,k,e) =&gt; I (Leaf k e)
              | (Leaf j d,k,e) =&gt;
                  I
                    (if j = k then Leaf k e
                     else JOIN (k,Leaf k e,j,Leaf j d))
              | (Branch p m l r,k,e) =&gt;
                  I
                    (if MOD_2EXP_EQ m k p then
                       if BIT m k then Branch p m (ADD_tupled (l,k,e)) r
                       else Branch p m l (ADD_tupled (r,k,e))
                     else JOIN (k,Leaf k e,p,Branch p m l r)))

   [<a name="BRANCHING_BIT_curried_def-val"><b>BRANCHING_BIT_curried_def</b></a>]  Definition

      |- ∀x x1. BRANCHING_BIT x x1 = BRANCHING_BIT_tupled (x,x1)

   [<a name="BRANCHING_BIT_tupled_primitive_def-val"><b>BRANCHING_BIT_tupled_primitive_def</b></a>]  Definition

      |- BRANCHING_BIT_tupled =
         WFREC
           (@R.
              WF R ∧
              ∀p1 p0.
                ¬((ODD p0 ⇔ EVEN p1) ∨ (p0 = p1)) ⇒
                R (DIV2 p0,DIV2 p1) (p0,p1))
           (λBRANCHING_BIT_tupled a.
              case a of
                (p0,p1) =&gt;
                  I
                    (if (ODD p0 ⇔ EVEN p1) ∨ (p0 = p1) then 0
                     else SUC (BRANCHING_BIT_tupled (DIV2 p0,DIV2 p1))))

   [<a name="BRANCH_primitive_def-val"><b>BRANCH_primitive_def</b></a>]  Definition

      |- BRANCH =
         WFREC (@R. WF R)
           (λBRANCH a.
              case a of
                (p,m,&lt;{}&gt;,t) =&gt; I t
              | (p,m,Leaf v18 v19,&lt;{}&gt;) =&gt; I (Leaf v18 v19)
              | (p,m,Leaf v18 v19,Leaf v30 v31) =&gt;
                  I (Branch p m (Leaf v18 v19) (Leaf v30 v31))
              | (p,m,Leaf v18 v19,Branch v32 v33 v34 v35) =&gt;
                  I (Branch p m (Leaf v18 v19) (Branch v32 v33 v34 v35))
              | (p,m,Branch v20 v21 v22 v23,&lt;{}&gt;) =&gt;
                  I (Branch v20 v21 v22 v23)
              | (p,m,Branch v20 v21 v22 v23,Leaf v42 v43) =&gt;
                  I (Branch p m (Branch v20 v21 v22 v23) (Leaf v42 v43))
              | (p,m,Branch v20 v21 v22 v23,Branch v44 v45 v46 v47) =&gt;
                  I
                    (Branch p m (Branch v20 v21 v22 v23)
                       (Branch v44 v45 v46 v47)))

   [<a name="DEPTH_def-val"><b>DEPTH_def</b></a>]  Definition

      |- (DEPTH &lt;{}&gt; = 0) ∧ (∀j d. DEPTH (Leaf j d) = 1) ∧
         ∀p m l r. DEPTH (Branch p m l r) = 1 + MAX (DEPTH l) (DEPTH r)

   [<a name="EVERY_LEAF_def-val"><b>EVERY_LEAF_def</b></a>]  Definition

      |- (∀P. EVERY_LEAF P &lt;{}&gt; ⇔ T) ∧
         (∀P j d. EVERY_LEAF P (Leaf j d) ⇔ P j d) ∧
         ∀P p m l r.
           EVERY_LEAF P (Branch p m l r) ⇔ EVERY_LEAF P l ∧ EVERY_LEAF P r

   [<a name="EXISTS_LEAF_def-val"><b>EXISTS_LEAF_def</b></a>]  Definition

      |- (∀P. EXISTS_LEAF P &lt;{}&gt; ⇔ F) ∧
         (∀P j d. EXISTS_LEAF P (Leaf j d) ⇔ P j d) ∧
         ∀P p m l r.
           EXISTS_LEAF P (Branch p m l r) ⇔
           EXISTS_LEAF P l ∨ EXISTS_LEAF P r

   [<a name="FIND_def-val"><b>FIND_def</b></a>]  Definition

      |- ∀t k. FIND t k = THE (t ' k)

   [<a name="INSERT_PTREE_def-val"><b>INSERT_PTREE_def</b></a>]  Definition

      |- ∀n t. n INSERT_PTREE t = t |+ (n,())

   [<a name="IN_PTREE_def-val"><b>IN_PTREE_def</b></a>]  Definition

      |- ∀n t. n IN_PTREE t ⇔ IS_SOME (t ' n)

   [<a name="IS_EMPTY_primitive_def-val"><b>IS_EMPTY_primitive_def</b></a>]  Definition

      |- IS_EMPTY =
         WFREC (@R. WF R)
           (λIS_EMPTY a.
              case a of
                &lt;{}&gt; =&gt; I T
              | Leaf v6 v7 =&gt; I F
              | Branch v8 v9 v10 v11 =&gt; I F)

   [<a name="IS_PTREE_def-val"><b>IS_PTREE_def</b></a>]  Definition

      |- (IS_PTREE &lt;{}&gt; ⇔ T) ∧ (∀k d. IS_PTREE (Leaf k d) ⇔ T) ∧
         ∀p m l r.
           IS_PTREE (Branch p m l r) ⇔
           p &lt; 2 ** m ∧ IS_PTREE l ∧ IS_PTREE r ∧ l ≠ &lt;{}&gt; ∧ r ≠ &lt;{}&gt; ∧
           EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ BIT m k) l ∧
           EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ ¬BIT m k) r

   [<a name="JOIN_def-val"><b>JOIN_def</b></a>]  Definition

      |- ∀p0 t0 p1 t1.
           JOIN (p0,t0,p1,t1) =
           (let m = BRANCHING_BIT p0 p1
            in
              if BIT m p0 then Branch (MOD_2EXP m p0) m t0 t1
              else Branch (MOD_2EXP m p0) m t1 t0)

   [<a name="KEYS_def-val"><b>KEYS_def</b></a>]  Definition

      |- ∀t. KEYS t = QSORT $&lt; (TRAVERSE t)

   [<a name="NUMSET_OF_PTREE_def-val"><b>NUMSET_OF_PTREE_def</b></a>]  Definition

      |- ∀t. NUMSET_OF_PTREE t = LIST_TO_SET (TRAVERSE t)

   [<a name="PEEK_curried_def-val"><b>PEEK_curried_def</b></a>]  Definition

      |- ∀x x1. x ' x1 = PEEK_tupled (x,x1)

   [<a name="PEEK_tupled_primitive_def-val"><b>PEEK_tupled_primitive_def</b></a>]  Definition

      |- PEEK_tupled =
         WFREC
           (@R.
              WF R ∧
              ∀p r l k m.
                R (if BIT m k then l else r,k) (Branch p m l r,k))
           (λPEEK_tupled a.
              case a of
                (&lt;{}&gt;,k) =&gt; I NONE
              | (Leaf j d,k) =&gt; I (if k = j then SOME d else NONE)
              | (Branch p m l r,k) =&gt;
                  I (PEEK_tupled (if BIT m k then l else r,k)))

   [<a name="PTREE_OF_NUMSET_def-val"><b>PTREE_OF_NUMSET_def</b></a>]  Definition

      |- ∀t s. t |++ s = FOLDL (combin$C $INSERT_PTREE) t (SET_TO_LIST s)

   [<a name="REMOVE_def-val"><b>REMOVE_def</b></a>]  Definition

      |- (∀k. &lt;{}&gt; \\ k = &lt;{}&gt;) ∧
         (∀j d k. Leaf j d \\ k = if j = k then &lt;{}&gt; else Leaf j d) ∧
         ∀p m l r k.
           Branch p m l r \\ k =
           if MOD_2EXP_EQ m k p then
             if BIT m k then BRANCH (p,m,l \\ k,r)
             else BRANCH (p,m,l,r \\ k)
           else Branch p m l r

   [<a name="SIZE_def-val"><b>SIZE_def</b></a>]  Definition

      |- ∀t. SIZE t = LENGTH (TRAVERSE t)

   [<a name="TRANSFORM_def-val"><b>TRANSFORM_def</b></a>]  Definition

      |- (∀f. TRANSFORM f &lt;{}&gt; = &lt;{}&gt;) ∧
         (∀f j d. TRANSFORM f (Leaf j d) = Leaf j (f d)) ∧
         ∀f p m l r.
           TRANSFORM f (Branch p m l r) =
           Branch p m (TRANSFORM f l) (TRANSFORM f r)

   [<a name="TRAVERSE_AUX_def-val"><b>TRAVERSE_AUX_def</b></a>]  Definition

      |- (∀a. TRAVERSE_AUX &lt;{}&gt; a = a) ∧
         (∀k d a. TRAVERSE_AUX (Leaf k d) a = k::a) ∧
         ∀p m l r a.
           TRAVERSE_AUX (Branch p m l r) a =
           TRAVERSE_AUX l (TRAVERSE_AUX r a)

   [<a name="TRAVERSE_def-val"><b>TRAVERSE_def</b></a>]  Definition

      |- (TRAVERSE &lt;{}&gt; = []) ∧ (∀j d. TRAVERSE (Leaf j d) = [j]) ∧
         ∀p m l r. TRAVERSE (Branch p m l r) = TRAVERSE l ++ TRAVERSE r

   [<a name="UNION_PTREE_def-val"><b>UNION_PTREE_def</b></a>]  Definition

      |- ∀t1 t2. t1 UNION_PTREE t2 = t1 |++ NUMSET_OF_PTREE t2

   [<a name="ptree_TY_DEF-val"><b>ptree_TY_DEF</b></a>]  Definition

      |- ∃rep.
           TYPE_DEFINITION
             (λa0'.
                ∀'ptree' .
                  (∀a0'.
                     (a0' =
                      ind_type$CONSTR 0 (ARB,ARB,ARB)
                        (λn. ind_type$BOTTOM)) ∨
                     (∃a0 a1.
                        a0' =
                        (λa0 a1.
                           ind_type$CONSTR (SUC 0) (a0,a1,ARB)
                             (λn. ind_type$BOTTOM)) a0 a1) ∨
                     (∃a0 a1 a2 a3.
                        (a0' =
                         (λa0 a1 a2 a3.
                            ind_type$CONSTR (SUC (SUC 0)) (a0,ARB,a1)
                              (ind_type$FCONS a2
                                 (ind_type$FCONS a3
                                    (λn. ind_type$BOTTOM)))) a0 a1 a2 a3) ∧
                        'ptree' a2 ∧ 'ptree' a3) ⇒
                     'ptree' a0') ⇒
                  'ptree' a0') rep

   [<a name="ptree_case_def-val"><b>ptree_case_def</b></a>]  Definition

      |- (∀v f f1. ptree_CASE &lt;{}&gt; v f f1 = v) ∧
         (∀a0 a1 v f f1. ptree_CASE (Leaf a0 a1) v f f1 = f a0 a1) ∧
         ∀a0 a1 a2 a3 v f f1.
           ptree_CASE (Branch a0 a1 a2 a3) v f f1 = f1 a0 a1 a2 a3

   [<a name="ptree_size_def-val"><b>ptree_size_def</b></a>]  Definition

      |- (∀f. ptree_size f &lt;{}&gt; = 0) ∧
         (∀f a0 a1. ptree_size f (Leaf a0 a1) = 1 + (a0 + f a1)) ∧
         ∀f a0 a1 a2 a3.
           ptree_size f (Branch a0 a1 a2 a3) =
           1 + (a0 + (a1 + (ptree_size f a2 + ptree_size f a3)))

   [<a name="ADD_ADD-val"><b>ADD_ADD</b></a>]  Theorem

      |- ∀t k d e. t |+ (k,d) |+ (k,e) = t |+ (k,e)

   [<a name="ADD_ADD_SYM-val"><b>ADD_ADD_SYM</b></a>]  Theorem

      |- ∀t k j d e.
           IS_PTREE t ∧ k ≠ j ⇒ (t |+ (k,d) |+ (j,e) = t |+ (j,e) |+ (k,d))

   [<a name="ADD_INSERT-val"><b>ADD_INSERT</b></a>]  Theorem

      |- ∀v t n. t |+ (n,v) = n INSERT_PTREE t

   [<a name="ADD_IS_PTREE-val"><b>ADD_IS_PTREE</b></a>]  Theorem

      |- ∀t x. IS_PTREE t ⇒ IS_PTREE (t |+ x)

   [<a name="ADD_LIST_IS_PTREE-val"><b>ADD_LIST_IS_PTREE</b></a>]  Theorem

      |- ∀t l. IS_PTREE t ⇒ IS_PTREE (t |++ l)

   [<a name="ADD_TRANSFORM-val"><b>ADD_TRANSFORM</b></a>]  Theorem

      |- ∀f t k d. TRANSFORM f (t |+ (k,d)) = TRANSFORM f t |+ (k,f d)

   [<a name="ADD_def-val"><b>ADD_def</b></a>]  Theorem

      |- (∀k e. &lt;{}&gt; |+ (k,e) = Leaf k e) ∧
         (∀k j e d.
            Leaf j d |+ (k,e) =
            if j = k then Leaf k e else JOIN (k,Leaf k e,j,Leaf j d)) ∧
         ∀r p m l k e.
           Branch p m l r |+ (k,e) =
           if MOD_2EXP_EQ m k p then
             if BIT m k then Branch p m (l |+ (k,e)) r
             else Branch p m l (r |+ (k,e))
           else JOIN (k,Leaf k e,p,Branch p m l r)

   [<a name="ADD_ind-val"><b>ADD_ind</b></a>]  Theorem

      |- ∀P.
           (∀k e. P &lt;{}&gt; (k,e)) ∧ (∀j d k e. P (Leaf j d) (k,e)) ∧
           (∀p m l r k e.
              (MOD_2EXP_EQ m k p ∧ ¬BIT m k ⇒ P r (k,e)) ∧
              (MOD_2EXP_EQ m k p ∧ BIT m k ⇒ P l (k,e)) ⇒
              P (Branch p m l r) (k,e)) ⇒
           ∀v v1 v2. P v (v1,v2)

   [<a name="ALL_DISTINCT_TRAVERSE-val"><b>ALL_DISTINCT_TRAVERSE</b></a>]  Theorem

      |- ∀t. IS_PTREE t ⇒ ALL_DISTINCT (TRAVERSE t)

   [<a name="BRANCH-val"><b>BRANCH</b></a>]  Theorem

      |- ∀p m l r.
           BRANCH (p,m,l,r) =
           if l = &lt;{}&gt; then r else if r = &lt;{}&gt; then l else Branch p m l r

   [<a name="BRANCHING_BIT-val"><b>BRANCHING_BIT</b></a>]  Theorem

      |- ∀a b.
           a ≠ b ⇒ (BIT (BRANCHING_BIT a b) a ⇎ BIT (BRANCHING_BIT a b) b)

   [<a name="BRANCHING_BIT_SYM-val"><b>BRANCHING_BIT_SYM</b></a>]  Theorem

      |- ∀a b. BRANCHING_BIT a b = BRANCHING_BIT b a

   [<a name="BRANCHING_BIT_ZERO-val"><b>BRANCHING_BIT_ZERO</b></a>]  Theorem

      |- ∀a b. (BRANCHING_BIT a b = 0) ⇔ (ODD a ⇔ EVEN b) ∨ (a = b)

   [<a name="BRANCHING_BIT_def-val"><b>BRANCHING_BIT_def</b></a>]  Theorem

      |- ∀p1 p0.
           BRANCHING_BIT p0 p1 =
           if (ODD p0 ⇔ EVEN p1) ∨ (p0 = p1) then 0
           else SUC (BRANCHING_BIT (DIV2 p0) (DIV2 p1))

   [<a name="BRANCHING_BIT_ind-val"><b>BRANCHING_BIT_ind</b></a>]  Theorem

      |- ∀P.
           (∀p0 p1.
              (¬((ODD p0 ⇔ EVEN p1) ∨ (p0 = p1)) ⇒ P (DIV2 p0) (DIV2 p1)) ⇒
              P p0 p1) ⇒
           ∀v v1. P v v1

   [<a name="BRANCH_def-val"><b>BRANCH_def</b></a>]  Theorem

      |- (BRANCH (p,m,&lt;{}&gt;,t) = t) ∧
         (BRANCH (p,m,Leaf v6 v7,&lt;{}&gt;) = Leaf v6 v7) ∧
         (BRANCH (p,m,Branch v8 v9 v10 v11,&lt;{}&gt;) = Branch v8 v9 v10 v11) ∧
         (BRANCH (p,m,Leaf v12 v13,Leaf v24 v25) =
          Branch p m (Leaf v12 v13) (Leaf v24 v25)) ∧
         (BRANCH (p,m,Leaf v12 v13,Branch v26 v27 v28 v29) =
          Branch p m (Leaf v12 v13) (Branch v26 v27 v28 v29)) ∧
         (BRANCH (p,m,Branch v14 v15 v16 v17,Leaf v36 v37) =
          Branch p m (Branch v14 v15 v16 v17) (Leaf v36 v37)) ∧
         (BRANCH (p,m,Branch v14 v15 v16 v17,Branch v38 v39 v40 v41) =
          Branch p m (Branch v14 v15 v16 v17) (Branch v38 v39 v40 v41))

   [<a name="BRANCH_ind-val"><b>BRANCH_ind</b></a>]  Theorem

      |- ∀P.
           (∀p m t. P (p,m,&lt;{}&gt;,t)) ∧
           (∀p m v6 v7. P (p,m,Leaf v6 v7,&lt;{}&gt;)) ∧
           (∀p m v8 v9 v10 v11. P (p,m,Branch v8 v9 v10 v11,&lt;{}&gt;)) ∧
           (∀p m v12 v13 v24 v25. P (p,m,Leaf v12 v13,Leaf v24 v25)) ∧
           (∀p m v12 v13 v26 v27 v28 v29.
              P (p,m,Leaf v12 v13,Branch v26 v27 v28 v29)) ∧
           (∀p m v14 v15 v16 v17 v36 v37.
              P (p,m,Branch v14 v15 v16 v17,Leaf v36 v37)) ∧
           (∀p m v14 v15 v16 v17 v38 v39 v40 v41.
              P (p,m,Branch v14 v15 v16 v17,Branch v38 v39 v40 v41)) ⇒
           ∀v v1 v2 v3. P (v,v1,v2,v3)

   [<a name="CARD_LIST_TO_SET-val"><b>CARD_LIST_TO_SET</b></a>]  Theorem

      |- ∀l. ALL_DISTINCT l ⇒ (CARD (LIST_TO_SET l) = LENGTH l)

   [<a name="CARD_NUMSET_OF_PTREE-val"><b>CARD_NUMSET_OF_PTREE</b></a>]  Theorem

      |- ∀t. IS_PTREE t ⇒ (CARD (NUMSET_OF_PTREE t) = SIZE t)

   [<a name="DELETE_UNION-val"><b>DELETE_UNION</b></a>]  Theorem

      |- ∀x s1 s2. s1 ∪ s2 DELETE x = s1 DELETE x ∪ (s2 DELETE x)

   [<a name="EMPTY_IS_PTREE-val"><b>EMPTY_IS_PTREE</b></a>]  Theorem

      |- IS_PTREE &lt;{}&gt;

   [<a name="EVERY_LEAF_ADD-val"><b>EVERY_LEAF_ADD</b></a>]  Theorem

      |- ∀P t k d. P k d ∧ EVERY_LEAF P t ⇒ EVERY_LEAF P (t |+ (k,d))

   [<a name="EVERY_LEAF_BRANCH-val"><b>EVERY_LEAF_BRANCH</b></a>]  Theorem

      |- ∀P p m l r.
           EVERY_LEAF P (BRANCH (p,m,l,r)) ⇔
           EVERY_LEAF P l ∧ EVERY_LEAF P r

   [<a name="EVERY_LEAF_PEEK-val"><b>EVERY_LEAF_PEEK</b></a>]  Theorem

      |- ∀P t k. EVERY_LEAF P t ∧ IS_SOME (t ' k) ⇒ P k (THE (t ' k))

   [<a name="EVERY_LEAF_REMOVE-val"><b>EVERY_LEAF_REMOVE</b></a>]  Theorem

      |- ∀P t k. EVERY_LEAF P t ⇒ EVERY_LEAF P (t \\ k)

   [<a name="EVERY_LEAF_TRANSFORM-val"><b>EVERY_LEAF_TRANSFORM</b></a>]  Theorem

      |- ∀P Q f t.
           (∀k d. P k d ⇒ Q k (f d)) ∧ EVERY_LEAF P t ⇒
           EVERY_LEAF Q (TRANSFORM f t)

   [<a name="FILTER_ALL-val"><b>FILTER_ALL</b></a>]  Theorem

      |- ∀P l. (∀n. n &lt; LENGTH l ⇒ ¬P (EL n l)) ⇔ (FILTER P l = [])

   [<a name="FILTER_NONE-val"><b>FILTER_NONE</b></a>]  Theorem

      |- ∀P l. (∀n. n &lt; LENGTH l ⇒ P (EL n l)) ⇒ (FILTER P l = l)

   [<a name="FINITE_NUMSET_OF_PTREE-val"><b>FINITE_NUMSET_OF_PTREE</b></a>]  Theorem

      |- ∀t. FINITE (NUMSET_OF_PTREE t)

   [<a name="INSERT_PTREE_IS_PTREE-val"><b>INSERT_PTREE_IS_PTREE</b></a>]  Theorem

      |- ∀t x. IS_PTREE t ⇒ IS_PTREE (x INSERT_PTREE t)

   [<a name="IN_NUMSET_OF_PTREE-val"><b>IN_NUMSET_OF_PTREE</b></a>]  Theorem

      |- ∀t n. IS_PTREE t ⇒ (n ∈ NUMSET_OF_PTREE t ⇔ n IN_PTREE t)

   [<a name="IN_PTREE_EMPTY-val"><b>IN_PTREE_EMPTY</b></a>]  Theorem

      |- ∀n. ¬(n IN_PTREE &lt;{}&gt;)

   [<a name="IN_PTREE_INSERT_PTREE-val"><b>IN_PTREE_INSERT_PTREE</b></a>]  Theorem

      |- ∀t m n.
           IS_PTREE t ⇒
           (n IN_PTREE m INSERT_PTREE t ⇔ (m = n) ∨ n IN_PTREE t)

   [<a name="IN_PTREE_OF_NUMSET-val"><b>IN_PTREE_OF_NUMSET</b></a>]  Theorem

      |- ∀t s n.
           IS_PTREE t ∧ FINITE s ⇒
           (n IN_PTREE t |++ s ⇔ n IN_PTREE t ∨ n ∈ s)

   [<a name="IN_PTREE_OF_NUMSET_EMPTY-val"><b>IN_PTREE_OF_NUMSET_EMPTY</b></a>]  Theorem

      |- ∀s n. FINITE s ⇒ (n ∈ s ⇔ n IN_PTREE &lt;{}&gt; |++ s)

   [<a name="IN_PTREE_REMOVE-val"><b>IN_PTREE_REMOVE</b></a>]  Theorem

      |- ∀t m n. IS_PTREE t ⇒ (n IN_PTREE t \\ m ⇔ n ≠ m ∧ n IN_PTREE t)

   [<a name="IN_PTREE_UNION_PTREE-val"><b>IN_PTREE_UNION_PTREE</b></a>]  Theorem

      |- ∀t1 t2 n.
           IS_PTREE t1 ∧ IS_PTREE t2 ⇒
           (n IN_PTREE t1 UNION_PTREE t2 ⇔ n IN_PTREE t1 ∨ n IN_PTREE t2)

   [<a name="IS_EMPTY_def-val"><b>IS_EMPTY_def</b></a>]  Theorem

      |- (IS_EMPTY &lt;{}&gt; ⇔ T) ∧ (IS_EMPTY (Leaf v v1) ⇔ F) ∧
         (IS_EMPTY (Branch v2 v3 v4 v5) ⇔ F)

   [<a name="IS_EMPTY_ind-val"><b>IS_EMPTY_ind</b></a>]  Theorem

      |- ∀P.
           P &lt;{}&gt; ∧ (∀v v1. P (Leaf v v1)) ∧
           (∀v2 v3 v4 v5. P (Branch v2 v3 v4 v5)) ⇒
           ∀v. P v

   [<a name="IS_PTREE_BRANCH-val"><b>IS_PTREE_BRANCH</b></a>]  Theorem

      |- ∀p m l r.
           p &lt; 2 ** m ∧ ¬((l = &lt;{}&gt;) ∧ (r = &lt;{}&gt;)) ∧
           EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ BIT m k) l ∧
           EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ ¬BIT m k) r ∧ IS_PTREE l ∧
           IS_PTREE r ⇒
           IS_PTREE (BRANCH (p,m,l,r))

   [<a name="IS_PTREE_PEEK-val"><b>IS_PTREE_PEEK</b></a>]  Theorem

      |- (∀k. ¬IS_SOME (&lt;{}&gt; ' k)) ∧
         (∀k j b. IS_SOME (Leaf j b ' k) ⇔ (j = k)) ∧
         ∀p m l r.
           IS_PTREE (Branch p m l r) ⇒
           (∃k. BIT m k ∧ IS_SOME (l ' k)) ∧
           (∃k. ¬BIT m k ∧ IS_SOME (r ' k)) ∧
           ∀k n.
             ¬MOD_2EXP_EQ m k p ∨ n &lt; m ∧ (BIT n p ⇎ BIT n k) ⇒
             ¬IS_SOME (l ' k) ∧ ¬IS_SOME (r ' k)

   [<a name="KEYS_PEEK-val"><b>KEYS_PEEK</b></a>]  Theorem

      |- ∀t1 t2.
           IS_PTREE t1 ∧ IS_PTREE t2 ⇒
           ((KEYS t1 = KEYS t2) ⇔ (TRAVERSE t1 = TRAVERSE t2))

   [<a name="MEM_ALL_DISTINCT_IMP_PERM-val"><b>MEM_ALL_DISTINCT_IMP_PERM</b></a>]  Theorem

      |- ∀l1 l2.
           ALL_DISTINCT l1 ∧ ALL_DISTINCT l2 ∧ (∀x. MEM x l1 ⇔ MEM x l2) ⇒
           PERM l1 l2

   [<a name="MEM_TRAVERSE-val"><b>MEM_TRAVERSE</b></a>]  Theorem

      |- ∀t k. IS_PTREE t ⇒ (MEM k (TRAVERSE t) ⇔ k ∈ NUMSET_OF_PTREE t)

   [<a name="MEM_TRAVERSE_INSERT_PTREE-val"><b>MEM_TRAVERSE_INSERT_PTREE</b></a>]  Theorem

      |- ∀t x h.
           IS_PTREE t ⇒
           (MEM x (TRAVERSE (h INSERT_PTREE t)) ⇔
            (x = h) ∨ x ≠ h ∧ MEM x (TRAVERSE t))

   [<a name="MEM_TRAVERSE_PEEK-val"><b>MEM_TRAVERSE_PEEK</b></a>]  Theorem

      |- ∀t k. IS_PTREE t ⇒ (MEM k (TRAVERSE t) ⇔ IS_SOME (t ' k))

   [<a name="MONO_EVERY_LEAF-val"><b>MONO_EVERY_LEAF</b></a>]  Theorem

      |- ∀P Q t. (∀k d. P k d ⇒ Q k d) ∧ EVERY_LEAF P t ⇒ EVERY_LEAF Q t

   [<a name="NOT_ADD_EMPTY-val"><b>NOT_ADD_EMPTY</b></a>]  Theorem

      |- ∀t k d. t |+ (k,d) ≠ &lt;{}&gt;

   [<a name="NOT_KEY_LEFT_AND_RIGHT-val"><b>NOT_KEY_LEFT_AND_RIGHT</b></a>]  Theorem

      |- ∀p m l r k j.
           IS_PTREE (Branch p m l r) ∧ IS_SOME (l ' k) ∧ IS_SOME (r ' j) ⇒
           k ≠ j

   [<a name="NUMSET_OF_PTREE_EMPTY-val"><b>NUMSET_OF_PTREE_EMPTY</b></a>]  Theorem

      |- NUMSET_OF_PTREE &lt;{}&gt; = ∅

   [<a name="NUMSET_OF_PTREE_PTREE_OF_NUMSET-val"><b>NUMSET_OF_PTREE_PTREE_OF_NUMSET</b></a>]  Theorem

      |- ∀t s.
           IS_PTREE t ∧ FINITE s ⇒
           (NUMSET_OF_PTREE (t |++ s) = NUMSET_OF_PTREE t ∪ s)

   [<a name="NUMSET_OF_PTREE_PTREE_OF_NUMSET_EMPTY-val"><b>NUMSET_OF_PTREE_PTREE_OF_NUMSET_EMPTY</b></a>]  Theorem

      |- ∀s. FINITE s ⇒ (NUMSET_OF_PTREE (&lt;{}&gt; |++ s) = s)

   [<a name="PEEK_ADD-val"><b>PEEK_ADD</b></a>]  Theorem

      |- ∀t k d j.
           IS_PTREE t ⇒
           ((t |+ (k,d)) ' j = if k = j then SOME d else t ' j)

   [<a name="PEEK_INSERT_PTREE-val"><b>PEEK_INSERT_PTREE</b></a>]  Theorem

      |- ∀t k j.
           IS_PTREE t ⇒
           ((k INSERT_PTREE t) ' j = if k = j then SOME () else t ' j)

   [<a name="PEEK_NONE-val"><b>PEEK_NONE</b></a>]  Theorem

      |- ∀P t k. (∀d. ¬P k d) ∧ EVERY_LEAF P t ⇒ (t ' k = NONE)

   [<a name="PEEK_REMOVE-val"><b>PEEK_REMOVE</b></a>]  Theorem

      |- ∀t k j.
           IS_PTREE t ⇒ ((t \\ k) ' j = if k = j then NONE else t ' j)

   [<a name="PEEK_TRANSFORM-val"><b>PEEK_TRANSFORM</b></a>]  Theorem

      |- ∀f t k.
           TRANSFORM f t ' k =
           case t ' k of NONE =&gt; NONE | SOME x =&gt; SOME (f x)

   [<a name="PEEK_def-val"><b>PEEK_def</b></a>]  Theorem

      |- (∀k. &lt;{}&gt; ' k = NONE) ∧
         (∀k j d. Leaf j d ' k = if k = j then SOME d else NONE) ∧
         ∀r p m l k. Branch p m l r ' k = (if BIT m k then l else r) ' k

   [<a name="PEEK_ind-val"><b>PEEK_ind</b></a>]  Theorem

      |- ∀P.
           (∀k. P &lt;{}&gt; k) ∧ (∀j d k. P (Leaf j d) k) ∧
           (∀p m l r k.
              P (if BIT m k then l else r) k ⇒ P (Branch p m l r) k) ⇒
           ∀v v1. P v v1

   [<a name="PERM_ADD-val"><b>PERM_ADD</b></a>]  Theorem

      |- ∀t k d.
           IS_PTREE t ∧ k ∉ LIST_TO_SET (TRAVERSE t) ⇒
           PERM (TRAVERSE (t |+ (k,d))) (k::TRAVERSE t)

   [<a name="PERM_DELETE_PTREE-val"><b>PERM_DELETE_PTREE</b></a>]  Theorem

      |- ∀t k.
           IS_PTREE t ∧ MEM k (TRAVERSE t) ⇒
           PERM (TRAVERSE (t \\ k)) (FILTER (λx. x ≠ k) (TRAVERSE t))

   [<a name="PERM_INSERT_PTREE-val"><b>PERM_INSERT_PTREE</b></a>]  Theorem

      |- ∀t s.
           FINITE s ⇒
           IS_PTREE t ⇒
           PERM
             (TRAVERSE (FOLDL (combin$C $INSERT_PTREE) t (SET_TO_LIST s)))
             (SET_TO_LIST (NUMSET_OF_PTREE t ∪ s))

   [<a name="PERM_NOT_ADD-val"><b>PERM_NOT_ADD</b></a>]  Theorem

      |- ∀t k d.
           IS_PTREE t ∧ MEM k (TRAVERSE t) ⇒
           (TRAVERSE (t |+ (k,d)) = TRAVERSE t)

   [<a name="PERM_NOT_REMOVE-val"><b>PERM_NOT_REMOVE</b></a>]  Theorem

      |- ∀t k.
           IS_PTREE t ∧ k ∉ LIST_TO_SET (TRAVERSE t) ⇒
           (TRAVERSE (t \\ k) = TRAVERSE t)

   [<a name="PERM_REMOVE-val"><b>PERM_REMOVE</b></a>]  Theorem

      |- ∀t k.
           IS_PTREE t ∧ MEM k (TRAVERSE t) ⇒
           PERM (TRAVERSE (t \\ k)) (FILTER (λx. x ≠ k) (TRAVERSE t))

   [<a name="PTREE_EQ-val"><b>PTREE_EQ</b></a>]  Theorem

      |- ∀t1 t2.
           IS_PTREE t1 ∧ IS_PTREE t2 ⇒ ((∀k. t1 ' k = t2 ' k) ⇔ (t1 = t2))

   [<a name="PTREE_EXTENSION-val"><b>PTREE_EXTENSION</b></a>]  Theorem

      |- ∀t1 t2.
           IS_PTREE t1 ∧ IS_PTREE t2 ⇒
           ((t1 = t2) ⇔ ∀x. x IN_PTREE t1 ⇔ x IN_PTREE t2)

   [<a name="PTREE_OF_NUMSET_DELETE-val"><b>PTREE_OF_NUMSET_DELETE</b></a>]  Theorem

      |- ∀s x. FINITE s ⇒ (&lt;{}&gt; |++ (s DELETE x) = (&lt;{}&gt; |++ s) \\ x)

   [<a name="PTREE_OF_NUMSET_EMPTY-val"><b>PTREE_OF_NUMSET_EMPTY</b></a>]  Theorem

      |- ∀t. t |++ ∅ = t

   [<a name="PTREE_OF_NUMSET_INSERT-val"><b>PTREE_OF_NUMSET_INSERT</b></a>]  Theorem

      |- ∀t s x.
           IS_PTREE t ∧ FINITE s ⇒
           (t |++ (x INSERT s) = x INSERT_PTREE t |++ s)

   [<a name="PTREE_OF_NUMSET_INSERT_EMPTY-val"><b>PTREE_OF_NUMSET_INSERT_EMPTY</b></a>]  Theorem

      |- ∀s x.
           FINITE s ⇒ (&lt;{}&gt; |++ (x INSERT s) = x INSERT_PTREE &lt;{}&gt; |++ s)

   [<a name="PTREE_OF_NUMSET_IS_PTREE-val"><b>PTREE_OF_NUMSET_IS_PTREE</b></a>]  Theorem

      |- ∀t s. IS_PTREE t ⇒ IS_PTREE (t |++ s)

   [<a name="PTREE_OF_NUMSET_IS_PTREE_EMPTY-val"><b>PTREE_OF_NUMSET_IS_PTREE_EMPTY</b></a>]  Theorem

      |- ∀s. IS_PTREE (&lt;{}&gt; |++ s)

   [<a name="PTREE_OF_NUMSET_NUMSET_OF_PTREE-val"><b>PTREE_OF_NUMSET_NUMSET_OF_PTREE</b></a>]  Theorem

      |- ∀t s.
           IS_PTREE t ∧ FINITE s ⇒
           (&lt;{}&gt; |++ (NUMSET_OF_PTREE t ∪ s) = t |++ s)

   [<a name="PTREE_OF_NUMSET_UNION-val"><b>PTREE_OF_NUMSET_UNION</b></a>]  Theorem

      |- ∀t s1 s2.
           IS_PTREE t ∧ FINITE s1 ∧ FINITE s2 ⇒
           (t |++ (s1 ∪ s2) = t |++ s1 |++ s2)

   [<a name="PTREE_TRAVERSE_EQ-val"><b>PTREE_TRAVERSE_EQ</b></a>]  Theorem

      |- ∀t1 t2.
           IS_PTREE t1 ∧ IS_PTREE t2 ⇒
           ((∀k. MEM k (TRAVERSE t1) ⇔ MEM k (TRAVERSE t2)) ⇔
            (TRAVERSE t1 = TRAVERSE t2))

   [<a name="QSORT_MEM_EQ-val"><b>QSORT_MEM_EQ</b></a>]  Theorem

      |- ∀l2 l1 R. (QSORT R l1 = QSORT R l2) ⇒ ∀x. MEM x l1 ⇔ MEM x l2

   [<a name="REMOVE_ADD-val"><b>REMOVE_ADD</b></a>]  Theorem

      |- ∀t k d j.
           IS_PTREE t ⇒
           (t |+ (k,d) \\ j = if k = j then t \\ j else t \\ j |+ (k,d))

   [<a name="REMOVE_ADD_EQ-val"><b>REMOVE_ADD_EQ</b></a>]  Theorem

      |- ∀t k d. t |+ (k,d) \\ k = t \\ k

   [<a name="REMOVE_IS_PTREE-val"><b>REMOVE_IS_PTREE</b></a>]  Theorem

      |- ∀t k. IS_PTREE t ⇒ IS_PTREE (t \\ k)

   [<a name="REMOVE_REMOVE-val"><b>REMOVE_REMOVE</b></a>]  Theorem

      |- ∀t k. IS_PTREE t ⇒ (t \\ k \\ k = t \\ k)

   [<a name="REMOVE_TRANSFORM-val"><b>REMOVE_TRANSFORM</b></a>]  Theorem

      |- ∀f t k. TRANSFORM f (t \\ k) = TRANSFORM f t \\ k

   [<a name="SIZE-val"><b>SIZE</b></a>]  Theorem

      |- (SIZE &lt;{}&gt; = 0) ∧ (∀k d. SIZE (Leaf k d) = 1) ∧
         ∀p m l r. SIZE (Branch p m l r) = SIZE l + SIZE r

   [<a name="SIZE_ADD-val"><b>SIZE_ADD</b></a>]  Theorem

      |- ∀t k d.
           IS_PTREE t ⇒
           (SIZE (t |+ (k,d)) =
            if MEM k (TRAVERSE t) then SIZE t else SIZE t + 1)

   [<a name="SIZE_PTREE_OF_NUMSET-val"><b>SIZE_PTREE_OF_NUMSET</b></a>]  Theorem

      |- ∀t s.
           FINITE s ⇒
           IS_PTREE t ∧ ALL_DISTINCT (TRAVERSE t ++ SET_TO_LIST s) ⇒
           (SIZE (t |++ s) = SIZE t + CARD s)

   [<a name="SIZE_PTREE_OF_NUMSET_EMPTY-val"><b>SIZE_PTREE_OF_NUMSET_EMPTY</b></a>]  Theorem

      |- ∀s. FINITE s ⇒ (SIZE (&lt;{}&gt; |++ s) = CARD s)

   [<a name="SIZE_REMOVE-val"><b>SIZE_REMOVE</b></a>]  Theorem

      |- ∀t k.
           IS_PTREE t ⇒
           (SIZE (t \\ k) =
            if MEM k (TRAVERSE t) then SIZE t − 1 else SIZE t)

   [<a name="TRANSFORM_BRANCH-val"><b>TRANSFORM_BRANCH</b></a>]  Theorem

      |- ∀f p m l r.
           TRANSFORM f (BRANCH (p,m,l,r)) =
           BRANCH (p,m,TRANSFORM f l,TRANSFORM f r)

   [<a name="TRANSFORM_EMPTY-val"><b>TRANSFORM_EMPTY</b></a>]  Theorem

      |- ∀f t. (TRANSFORM f t = &lt;{}&gt;) ⇔ (t = &lt;{}&gt;)

   [<a name="TRANSFORM_IS_PTREE-val"><b>TRANSFORM_IS_PTREE</b></a>]  Theorem

      |- ∀f t. IS_PTREE t ⇒ IS_PTREE (TRANSFORM f t)

   [<a name="TRAVERSE_AUX-val"><b>TRAVERSE_AUX</b></a>]  Theorem

      |- ∀t. TRAVERSE t = TRAVERSE_AUX t []

   [<a name="TRAVERSE_TRANSFORM-val"><b>TRAVERSE_TRANSFORM</b></a>]  Theorem

      |- ∀f t. TRAVERSE (TRANSFORM f t) = TRAVERSE t

   [<a name="UNION_PTREE_ASSOC-val"><b>UNION_PTREE_ASSOC</b></a>]  Theorem

      |- ∀t1 t2 t3.
           IS_PTREE t1 ∧ IS_PTREE t2 ∧ IS_PTREE t3 ⇒
           (t1 UNION_PTREE (t2 UNION_PTREE t3) =
            t1 UNION_PTREE t2 UNION_PTREE t3)

   [<a name="UNION_PTREE_COMM-val"><b>UNION_PTREE_COMM</b></a>]  Theorem

      |- ∀t1 t2.
           IS_PTREE t1 ∧ IS_PTREE t2 ⇒
           (t1 UNION_PTREE t2 = t2 UNION_PTREE t1)

   [<a name="UNION_PTREE_COMM_EMPTY-val"><b>UNION_PTREE_COMM_EMPTY</b></a>]  Theorem

      |- ∀t. IS_PTREE t ⇒ (&lt;{}&gt; UNION_PTREE t = t UNION_PTREE &lt;{}&gt;)

   [<a name="UNION_PTREE_EMPTY-val"><b>UNION_PTREE_EMPTY</b></a>]  Theorem

      |- (∀t. t UNION_PTREE &lt;{}&gt; = t) ∧
         ∀t. IS_PTREE t ⇒ (&lt;{}&gt; UNION_PTREE t = t)

   [<a name="UNION_PTREE_IS_PTREE-val"><b>UNION_PTREE_IS_PTREE</b></a>]  Theorem

      |- ∀t1 t2. IS_PTREE t1 ∧ IS_PTREE t2 ⇒ IS_PTREE (t1 UNION_PTREE t2)

   [<a name="datatype_ptree-val"><b>datatype_ptree</b></a>]  Theorem

      |- DATATYPE (ptree &lt;{}&gt; Leaf Branch)

   [<a name="ptree_11-val"><b>ptree_11</b></a>]  Theorem

      |- (∀a0 a1 a0' a1'.
            (Leaf a0 a1 = Leaf a0' a1') ⇔ (a0 = a0') ∧ (a1 = a1')) ∧
         ∀a0 a1 a2 a3 a0' a1' a2' a3'.
           (Branch a0 a1 a2 a3 = Branch a0' a1' a2' a3') ⇔
           (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2') ∧ (a3 = a3')

   [<a name="ptree_Axiom-val"><b>ptree_Axiom</b></a>]  Theorem

      |- ∀f0 f1 f2.
           ∃fn.
             (fn &lt;{}&gt; = f0) ∧ (∀a0 a1. fn (Leaf a0 a1) = f1 a0 a1) ∧
             ∀a0 a1 a2 a3.
               fn (Branch a0 a1 a2 a3) = f2 a0 a1 a2 a3 (fn a2) (fn a3)

   [<a name="ptree_case_cong-val"><b>ptree_case_cong</b></a>]  Theorem

      |- ∀M M' v f f1.
           (M = M') ∧ ((M' = &lt;{}&gt;) ⇒ (v = v')) ∧
           (∀a0 a1. (M' = Leaf a0 a1) ⇒ (f a0 a1 = f' a0 a1)) ∧
           (∀a0 a1 a2 a3.
              (M' = Branch a0 a1 a2 a3) ⇒
              (f1 a0 a1 a2 a3 = f1' a0 a1 a2 a3)) ⇒
           (ptree_CASE M v f f1 = ptree_CASE M' v' f' f1')

   [<a name="ptree_distinct-val"><b>ptree_distinct</b></a>]  Theorem

      |- (∀a1 a0. &lt;{}&gt; ≠ Leaf a0 a1) ∧
         (∀a3 a2 a1 a0. &lt;{}&gt; ≠ Branch a0 a1 a2 a3) ∧
         ∀a3 a2 a1' a1 a0' a0. Leaf a0 a1 ≠ Branch a0' a1' a2 a3

   [<a name="ptree_induction-val"><b>ptree_induction</b></a>]  Theorem

      |- ∀P.
           P &lt;{}&gt; ∧ (∀n a. P (Leaf n a)) ∧
           (∀p p0. P p ∧ P p0 ⇒ ∀n n0. P (Branch n0 n p p0)) ⇒
           ∀p. P p

   [<a name="ptree_nchotomy-val"><b>ptree_nchotomy</b></a>]  Theorem

      |- ∀pp.
           (pp = &lt;{}&gt;) ∨ (∃n a. pp = Leaf n a) ∨
           ∃n0 n p p0. pp = Branch n0 n p p0


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/patricia/patriciaScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-9</a></em></p></body></html>
