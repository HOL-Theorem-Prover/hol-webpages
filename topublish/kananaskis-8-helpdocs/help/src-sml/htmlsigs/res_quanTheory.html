<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure res_quanTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure res_quanTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/res_quan/src/res_quanScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature res_quanTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Theorems  *)
<a name="line6"></a>    val <a href="#RES_ABSTRACT-val">RES_ABSTRACT</a> : thm
<a name="line7"></a>    val <a href="#RES_ABSTRACT_EQUAL-val">RES_ABSTRACT_EQUAL</a> : thm
<a name="line8"></a>    val <a href="#RES_ABSTRACT_EQUAL_EQ-val">RES_ABSTRACT_EQUAL_EQ</a> : thm
<a name="line9"></a>    val <a href="#RES_ABSTRACT_IDEMPOT-val">RES_ABSTRACT_IDEMPOT</a> : thm
<a name="line10"></a>    val <a href="#RES_DISJ_EXISTS_DIST-val">RES_DISJ_EXISTS_DIST</a> : thm
<a name="line11"></a>    val <a href="#RES_EXISTS-val">RES_EXISTS</a> : thm
<a name="line12"></a>    val <a href="#RES_EXISTS_ALT-val">RES_EXISTS_ALT</a> : thm
<a name="line13"></a>    val <a href="#RES_EXISTS_DISJ_DIST-val">RES_EXISTS_DISJ_DIST</a> : thm
<a name="line14"></a>    val <a href="#RES_EXISTS_EMPTY-val">RES_EXISTS_EMPTY</a> : thm
<a name="line15"></a>    val <a href="#RES_EXISTS_EQUAL-val">RES_EXISTS_EQUAL</a> : thm
<a name="line16"></a>    val <a href="#RES_EXISTS_NULL-val">RES_EXISTS_NULL</a> : thm
<a name="line17"></a>    val <a href="#RES_EXISTS_REORDER-val">RES_EXISTS_REORDER</a> : thm
<a name="line18"></a>    val <a href="#RES_EXISTS_UNIQUE-val">RES_EXISTS_UNIQUE</a> : thm
<a name="line19"></a>    val <a href="#RES_EXISTS_UNIQUE_ALT-val">RES_EXISTS_UNIQUE_ALT</a> : thm
<a name="line20"></a>    val <a href="#RES_EXISTS_UNIQUE_EMPTY-val">RES_EXISTS_UNIQUE_EMPTY</a> : thm
<a name="line21"></a>    val <a href="#RES_EXISTS_UNIQUE_NULL-val">RES_EXISTS_UNIQUE_NULL</a> : thm
<a name="line22"></a>    val <a href="#RES_EXISTS_UNIQUE_UNIV-val">RES_EXISTS_UNIQUE_UNIV</a> : thm
<a name="line23"></a>    val <a href="#RES_EXISTS_UNIV-val">RES_EXISTS_UNIV</a> : thm
<a name="line24"></a>    val <a href="#RES_FORALL-val">RES_FORALL</a> : thm
<a name="line25"></a>    val <a href="#RES_FORALL_CONJ_DIST-val">RES_FORALL_CONJ_DIST</a> : thm
<a name="line26"></a>    val <a href="#RES_FORALL_DISJ_DIST-val">RES_FORALL_DISJ_DIST</a> : thm
<a name="line27"></a>    val <a href="#RES_FORALL_EMPTY-val">RES_FORALL_EMPTY</a> : thm
<a name="line28"></a>    val <a href="#RES_FORALL_FORALL-val">RES_FORALL_FORALL</a> : thm
<a name="line29"></a>    val <a href="#RES_FORALL_NULL-val">RES_FORALL_NULL</a> : thm
<a name="line30"></a>    val <a href="#RES_FORALL_REORDER-val">RES_FORALL_REORDER</a> : thm
<a name="line31"></a>    val <a href="#RES_FORALL_UNIQUE-val">RES_FORALL_UNIQUE</a> : thm
<a name="line32"></a>    val <a href="#RES_FORALL_UNIV-val">RES_FORALL_UNIV</a> : thm
<a name="line33"></a>    val <a href="#RES_SELECT-val">RES_SELECT</a> : thm
<a name="line34"></a>    val <a href="#RES_SELECT_EMPTY-val">RES_SELECT_EMPTY</a> : thm
<a name="line35"></a>    val <a href="#RES_SELECT_UNIV-val">RES_SELECT_UNIV</a> : thm
<a name="line36"></a>
<a name="line37"></a>  val res_quan_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line38"></a>(*
   [pred_set] Parent theory of "res_quan"

   [<a name="RES_ABSTRACT-val"><b>RES_ABSTRACT</b></a>]  Theorem

      |- ∀p m x. x ∈ p ⇒ (RES_ABSTRACT p m x = m x)

   [<a name="RES_ABSTRACT_EQUAL-val"><b>RES_ABSTRACT_EQUAL</b></a>]  Theorem

      |- ∀p m1 m2.
           (∀x. x ∈ p ⇒ (m1 x = m2 x)) ⇒
           (RES_ABSTRACT p m1 = RES_ABSTRACT p m2)

   [<a name="RES_ABSTRACT_EQUAL_EQ-val"><b>RES_ABSTRACT_EQUAL_EQ</b></a>]  Theorem

      |- ∀p m1 m2.
           (RES_ABSTRACT p m1 = RES_ABSTRACT p m2) ⇔
           ∀x. x ∈ p ⇒ (m1 x = m2 x)

   [<a name="RES_ABSTRACT_IDEMPOT-val"><b>RES_ABSTRACT_IDEMPOT</b></a>]  Theorem

      |- ∀p m. RES_ABSTRACT p (RES_ABSTRACT p m) = RES_ABSTRACT p m

   [<a name="RES_DISJ_EXISTS_DIST-val"><b>RES_DISJ_EXISTS_DIST</b></a>]  Theorem

      |- ∀P Q R. (∃i::(λi. P i ∨ Q i). R i) ⇔ (∃i::P. R i) ∨ ∃i::Q. R i

   [<a name="RES_EXISTS-val"><b>RES_EXISTS</b></a>]  Theorem

      |- ∀P f. RES_EXISTS P f ⇔ ∃x. x ∈ P ∧ f x

   [<a name="RES_EXISTS_ALT-val"><b>RES_EXISTS_ALT</b></a>]  Theorem

      |- ∀p m. RES_EXISTS p m ⇔ RES_SELECT p m ∈ p ∧ m (RES_SELECT p m)

   [<a name="RES_EXISTS_DISJ_DIST-val"><b>RES_EXISTS_DISJ_DIST</b></a>]  Theorem

      |- ∀P Q R. (∃i::P. Q i ∨ R i) ⇔ (∃i::P. Q i) ∨ ∃i::P. R i

   [<a name="RES_EXISTS_EMPTY-val"><b>RES_EXISTS_EMPTY</b></a>]  Theorem

      |- ∀p. ¬RES_EXISTS ∅ p

   [<a name="RES_EXISTS_EQUAL-val"><b>RES_EXISTS_EQUAL</b></a>]  Theorem

      |- ∀P j. (∃i:: $= j. P i) ⇔ P j

   [<a name="RES_EXISTS_NULL-val"><b>RES_EXISTS_NULL</b></a>]  Theorem

      |- ∀p m. (∃x::p. m) ⇔ p ≠ ∅ ∧ m

   [<a name="RES_EXISTS_REORDER-val"><b>RES_EXISTS_REORDER</b></a>]  Theorem

      |- ∀P Q R. (∃(i::P) (j::Q). R i j) ⇔ ∃(j::Q) (i::P). R i j

   [<a name="RES_EXISTS_UNIQUE-val"><b>RES_EXISTS_UNIQUE</b></a>]  Theorem

      |- ∀P f.
           RES_EXISTS_UNIQUE P f ⇔
           (∃x::P. f x) ∧ ∀x y::P. f x ∧ f y ⇒ (x = y)

   [<a name="RES_EXISTS_UNIQUE_ALT-val"><b>RES_EXISTS_UNIQUE_ALT</b></a>]  Theorem

      |- ∀p m. RES_EXISTS_UNIQUE p m ⇔ ∃x::p. m x ∧ ∀y::p. m y ⇒ (y = x)

   [<a name="RES_EXISTS_UNIQUE_EMPTY-val"><b>RES_EXISTS_UNIQUE_EMPTY</b></a>]  Theorem

      |- ∀p. ¬RES_EXISTS_UNIQUE ∅ p

   [<a name="RES_EXISTS_UNIQUE_NULL-val"><b>RES_EXISTS_UNIQUE_NULL</b></a>]  Theorem

      |- ∀p m. (∃!x::p. m) ⇔ (∃x. p = {x}) ∧ m

   [<a name="RES_EXISTS_UNIQUE_UNIV-val"><b>RES_EXISTS_UNIQUE_UNIV</b></a>]  Theorem

      |- ∀p. RES_EXISTS_UNIQUE pred_set$UNIV p ⇔ $?! p

   [<a name="RES_EXISTS_UNIV-val"><b>RES_EXISTS_UNIV</b></a>]  Theorem

      |- ∀p. RES_EXISTS pred_set$UNIV p ⇔ $? p

   [<a name="RES_FORALL-val"><b>RES_FORALL</b></a>]  Theorem

      |- ∀P f. RES_FORALL P f ⇔ ∀x. x ∈ P ⇒ f x

   [<a name="RES_FORALL_CONJ_DIST-val"><b>RES_FORALL_CONJ_DIST</b></a>]  Theorem

      |- ∀P Q R. (∀i::P. Q i ∧ R i) ⇔ (∀i::P. Q i) ∧ ∀i::P. R i

   [<a name="RES_FORALL_DISJ_DIST-val"><b>RES_FORALL_DISJ_DIST</b></a>]  Theorem

      |- ∀P Q R. (∀i::(λj. P j ∨ Q j). R i) ⇔ (∀i::P. R i) ∧ ∀i::Q. R i

   [<a name="RES_FORALL_EMPTY-val"><b>RES_FORALL_EMPTY</b></a>]  Theorem

      |- ∀p. RES_FORALL ∅ p

   [<a name="RES_FORALL_FORALL-val"><b>RES_FORALL_FORALL</b></a>]  Theorem

      |- ∀P R x. (∀x (i::P). R i x) ⇔ ∀(i::P) x. R i x

   [<a name="RES_FORALL_NULL-val"><b>RES_FORALL_NULL</b></a>]  Theorem

      |- ∀p m. (∀x::p. m) ⇔ (p = ∅) ∨ m

   [<a name="RES_FORALL_REORDER-val"><b>RES_FORALL_REORDER</b></a>]  Theorem

      |- ∀P Q R. (∀(i::P) (j::Q). R i j) ⇔ ∀(j::Q) (i::P). R i j

   [<a name="RES_FORALL_UNIQUE-val"><b>RES_FORALL_UNIQUE</b></a>]  Theorem

      |- ∀P j. (∀i:: $= j. P i) ⇔ P j

   [<a name="RES_FORALL_UNIV-val"><b>RES_FORALL_UNIV</b></a>]  Theorem

      |- ∀p. RES_FORALL pred_set$UNIV p ⇔ $! p

   [<a name="RES_SELECT-val"><b>RES_SELECT</b></a>]  Theorem

      |- ∀P f. RES_SELECT P f = @x. x ∈ P ∧ f x

   [<a name="RES_SELECT_EMPTY-val"><b>RES_SELECT_EMPTY</b></a>]  Theorem

      |- ∀p. RES_SELECT ∅ p = @x. F

   [<a name="RES_SELECT_UNIV-val"><b>RES_SELECT_UNIV</b></a>]  Theorem

      |- ∀p. RES_SELECT pred_set$UNIV p = $@ p


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/res_quan/src/res_quanScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-8</a></em></p></body></html>
