<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure bitTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure bitTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/n-bit/bitScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature bitTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#BITS_def-val">BITS_def</a> : thm
<a name="line7"></a>    val <a href="#BITV_def-val">BITV_def</a> : thm
<a name="line8"></a>    val <a href="#BITWISE_def-val">BITWISE_def</a> : thm
<a name="line9"></a>    val <a href="#BIT_MODIFY_def-val">BIT_MODIFY_def</a> : thm
<a name="line10"></a>    val <a href="#BIT_REVERSE_def-val">BIT_REVERSE_def</a> : thm
<a name="line11"></a>    val <a href="#BIT_def-val">BIT_def</a> : thm
<a name="line12"></a>    val <a href="#BOOLIFY_def-val">BOOLIFY_def</a> : thm
<a name="line13"></a>    val <a href="#DIVMOD_2EXP_def-val">DIVMOD_2EXP_def</a> : thm
<a name="line14"></a>    val <a href="#LOG2_def-val">LOG2_def</a> : thm
<a name="line15"></a>    val <a href="#LOWEST_SET_BIT_def-val">LOWEST_SET_BIT_def</a> : thm
<a name="line16"></a>    val <a href="#LSB_def-val">LSB_def</a> : thm
<a name="line17"></a>    val <a href="#MOD_2EXP_EQ_def-val">MOD_2EXP_EQ_def</a> : thm
<a name="line18"></a>    val <a href="#MOD_2EXP_MAX_def-val">MOD_2EXP_MAX_def</a> : thm
<a name="line19"></a>    val <a href="#SBIT_def-val">SBIT_def</a> : thm
<a name="line20"></a>    val <a href="#SIGN_EXTEND_def-val">SIGN_EXTEND_def</a> : thm
<a name="line21"></a>    val <a href="#SLICE_def-val">SLICE_def</a> : thm
<a name="line22"></a>    val <a href="#TIMES_2EXP_def-val">TIMES_2EXP_def</a> : thm
<a name="line23"></a>
<a name="line24"></a>  (*  Theorems  *)
<a name="line25"></a>    val <a href="#ADD_BIT0-val">ADD_BIT0</a> : thm
<a name="line26"></a>    val <a href="#ADD_BITS_SUC-val">ADD_BITS_SUC</a> : thm
<a name="line27"></a>    val <a href="#ADD_BIT_SUC-val">ADD_BIT_SUC</a> : thm
<a name="line28"></a>    val <a href="#BITSLT_THM-val">BITSLT_THM</a> : thm
<a name="line29"></a>    val <a href="#BITSLT_THM2-val">BITSLT_THM2</a> : thm
<a name="line30"></a>    val <a href="#BITS_COMP_THM-val">BITS_COMP_THM</a> : thm
<a name="line31"></a>    val <a href="#BITS_COMP_THM2-val">BITS_COMP_THM2</a> : thm
<a name="line32"></a>    val <a href="#BITS_DIV_THM-val">BITS_DIV_THM</a> : thm
<a name="line33"></a>    val <a href="#BITS_LEQ-val">BITS_LEQ</a> : thm
<a name="line34"></a>    val <a href="#BITS_LOG2_ZERO_ID-val">BITS_LOG2_ZERO_ID</a> : thm
<a name="line35"></a>    val <a href="#BITS_LT_HIGH-val">BITS_LT_HIGH</a> : thm
<a name="line36"></a>    val <a href="#BITS_LT_LOW-val">BITS_LT_LOW</a> : thm
<a name="line37"></a>    val <a href="#BITS_MUL-val">BITS_MUL</a> : thm
<a name="line38"></a>    val <a href="#BITS_SLICE_THM-val">BITS_SLICE_THM</a> : thm
<a name="line39"></a>    val <a href="#BITS_SLICE_THM2-val">BITS_SLICE_THM2</a> : thm
<a name="line40"></a>    val <a href="#BITS_SUC-val">BITS_SUC</a> : thm
<a name="line41"></a>    val <a href="#BITS_SUC_THM-val">BITS_SUC_THM</a> : thm
<a name="line42"></a>    val <a href="#BITS_SUM-val">BITS_SUM</a> : thm
<a name="line43"></a>    val <a href="#BITS_SUM2-val">BITS_SUM2</a> : thm
<a name="line44"></a>    val <a href="#BITS_SUM3-val">BITS_SUM3</a> : thm
<a name="line45"></a>    val <a href="#BITS_THM-val">BITS_THM</a> : thm
<a name="line46"></a>    val <a href="#BITS_THM2-val">BITS_THM2</a> : thm
<a name="line47"></a>    val <a href="#BITS_ZERO-val">BITS_ZERO</a> : thm
<a name="line48"></a>    val <a href="#BITS_ZERO2-val">BITS_ZERO2</a> : thm
<a name="line49"></a>    val <a href="#BITS_ZERO3-val">BITS_ZERO3</a> : thm
<a name="line50"></a>    val <a href="#BITS_ZERO4-val">BITS_ZERO4</a> : thm
<a name="line51"></a>    val <a href="#BITS_ZERO5-val">BITS_ZERO5</a> : thm
<a name="line52"></a>    val <a href="#BITS_ZEROL-val">BITS_ZEROL</a> : thm
<a name="line53"></a>    val <a href="#BITV_THM-val">BITV_THM</a> : thm
<a name="line54"></a>    val <a href="#BITWISE_BITS-val">BITWISE_BITS</a> : thm
<a name="line55"></a>    val <a href="#BITWISE_COR-val">BITWISE_COR</a> : thm
<a name="line56"></a>    val <a href="#BITWISE_EVAL-val">BITWISE_EVAL</a> : thm
<a name="line57"></a>    val <a href="#BITWISE_LT_2EXP-val">BITWISE_LT_2EXP</a> : thm
<a name="line58"></a>    val <a href="#BITWISE_NOT_COR-val">BITWISE_NOT_COR</a> : thm
<a name="line59"></a>    val <a href="#BITWISE_ONE_COMP_LEM-val">BITWISE_ONE_COMP_LEM</a> : thm
<a name="line60"></a>    val <a href="#BITWISE_THM-val">BITWISE_THM</a> : thm
<a name="line61"></a>    val <a href="#BIT_B-val">BIT_B</a> : thm
<a name="line62"></a>    val <a href="#BIT_BITS_THM-val">BIT_BITS_THM</a> : thm
<a name="line63"></a>    val <a href="#BIT_B_NEQ-val">BIT_B_NEQ</a> : thm
<a name="line64"></a>    val <a href="#BIT_COMPLEMENT-val">BIT_COMPLEMENT</a> : thm
<a name="line65"></a>    val <a href="#BIT_COMP_THM3-val">BIT_COMP_THM3</a> : thm
<a name="line66"></a>    val <a href="#BIT_DIV2-val">BIT_DIV2</a> : thm
<a name="line67"></a>    val <a href="#BIT_EXP_SUB1-val">BIT_EXP_SUB1</a> : thm
<a name="line68"></a>    val <a href="#BIT_IMP_GE_TWOEXP-val">BIT_IMP_GE_TWOEXP</a> : thm
<a name="line69"></a>    val <a href="#BIT_LOG2-val">BIT_LOG2</a> : thm
<a name="line70"></a>    val <a href="#BIT_MODIFY_THM-val">BIT_MODIFY_THM</a> : thm
<a name="line71"></a>    val <a href="#BIT_OF_BITS_THM-val">BIT_OF_BITS_THM</a> : thm
<a name="line72"></a>    val <a href="#BIT_OF_BITS_THM2-val">BIT_OF_BITS_THM2</a> : thm
<a name="line73"></a>    val <a href="#BIT_REVERSE_THM-val">BIT_REVERSE_THM</a> : thm
<a name="line74"></a>    val <a href="#BIT_SHIFT_THM-val">BIT_SHIFT_THM</a> : thm
<a name="line75"></a>    val <a href="#BIT_SHIFT_THM2-val">BIT_SHIFT_THM2</a> : thm
<a name="line76"></a>    val <a href="#BIT_SHIFT_THM3-val">BIT_SHIFT_THM3</a> : thm
<a name="line77"></a>    val <a href="#BIT_SHIFT_THM4-val">BIT_SHIFT_THM4</a> : thm
<a name="line78"></a>    val <a href="#BIT_SHIFT_THM5-val">BIT_SHIFT_THM5</a> : thm
<a name="line79"></a>    val <a href="#BIT_SIGN_EXTEND-val">BIT_SIGN_EXTEND</a> : thm
<a name="line80"></a>    val <a href="#BIT_SLICE-val">BIT_SLICE</a> : thm
<a name="line81"></a>    val <a href="#BIT_SLICE_LEM-val">BIT_SLICE_LEM</a> : thm
<a name="line82"></a>    val <a href="#BIT_SLICE_THM-val">BIT_SLICE_THM</a> : thm
<a name="line83"></a>    val <a href="#BIT_SLICE_THM2-val">BIT_SLICE_THM2</a> : thm
<a name="line84"></a>    val <a href="#BIT_SLICE_THM3-val">BIT_SLICE_THM3</a> : thm
<a name="line85"></a>    val <a href="#BIT_SLICE_THM4-val">BIT_SLICE_THM4</a> : thm
<a name="line86"></a>    val <a href="#BIT_ZERO-val">BIT_ZERO</a> : thm
<a name="line87"></a>    val <a href="#BIT_num_from_bin_list-val">BIT_num_from_bin_list</a> : thm
<a name="line88"></a>    val <a href="#BIT_num_from_bin_string-val">BIT_num_from_bin_string</a> : thm
<a name="line89"></a>    val <a href="#BOOLIFY_def_compute-val">BOOLIFY_def_compute</a> : thm
<a name="line90"></a>    val <a href="#DIVMOD_2EXP-val">DIVMOD_2EXP</a> : thm
<a name="line91"></a>    val <a href="#DIV_GT0-val">DIV_GT0</a> : thm
<a name="line92"></a>    val <a href="#DIV_LT-val">DIV_LT</a> : thm
<a name="line93"></a>    val <a href="#DIV_MULT_1-val">DIV_MULT_1</a> : thm
<a name="line94"></a>    val <a href="#DIV_MULT_THM-val">DIV_MULT_THM</a> : thm
<a name="line95"></a>    val <a href="#DIV_MULT_THM2-val">DIV_MULT_THM2</a> : thm
<a name="line96"></a>    val <a href="#DIV_SUB1-val">DIV_SUB1</a> : thm
<a name="line97"></a>    val <a href="#EL_num_to_bin_list-val">EL_num_to_bin_list</a> : thm
<a name="line98"></a>    val <a href="#EXISTS_BIT_IN_RANGE-val">EXISTS_BIT_IN_RANGE</a> : thm
<a name="line99"></a>    val <a href="#EXISTS_BIT_LT-val">EXISTS_BIT_LT</a> : thm
<a name="line100"></a>    val <a href="#EXP_SUB_LESS_EQ-val">EXP_SUB_LESS_EQ</a> : thm
<a name="line101"></a>    val <a href="#LEAST_THM-val">LEAST_THM</a> : thm
<a name="line102"></a>    val <a href="#LESS_EQ_EXP_MULT-val">LESS_EQ_EXP_MULT</a> : thm
<a name="line103"></a>    val <a href="#LESS_MULT_MONO2-val">LESS_MULT_MONO2</a> : thm
<a name="line104"></a>    val <a href="#LOG2_LE_MONO-val">LOG2_LE_MONO</a> : thm
<a name="line105"></a>    val <a href="#LOG2_TWOEXP-val">LOG2_TWOEXP</a> : thm
<a name="line106"></a>    val <a href="#LOG2_UNIQUE-val">LOG2_UNIQUE</a> : thm
<a name="line107"></a>    val <a href="#LSB_ODD-val">LSB_ODD</a> : thm
<a name="line108"></a>    val <a href="#LT_TWOEXP-val">LT_TWOEXP</a> : thm
<a name="line109"></a>    val <a href="#MOD_2EXP_LT-val">MOD_2EXP_LT</a> : thm
<a name="line110"></a>    val <a href="#MOD_2EXP_MONO-val">MOD_2EXP_MONO</a> : thm
<a name="line111"></a>    val <a href="#MOD_ADD_1-val">MOD_ADD_1</a> : thm
<a name="line112"></a>    val <a href="#MOD_LEQ-val">MOD_LEQ</a> : thm
<a name="line113"></a>    val <a href="#MOD_PLUS_1-val">MOD_PLUS_1</a> : thm
<a name="line114"></a>    val <a href="#MOD_PLUS_LEFT-val">MOD_PLUS_LEFT</a> : thm
<a name="line115"></a>    val <a href="#MOD_PLUS_RIGHT-val">MOD_PLUS_RIGHT</a> : thm
<a name="line116"></a>    val <a href="#MOD_ZERO_GT-val">MOD_ZERO_GT</a> : thm
<a name="line117"></a>    val <a href="#NOT_BIT-val">NOT_BIT</a> : thm
<a name="line118"></a>    val <a href="#NOT_BITS-val">NOT_BITS</a> : thm
<a name="line119"></a>    val <a href="#NOT_BITS2-val">NOT_BITS2</a> : thm
<a name="line120"></a>    val <a href="#NOT_BIT_GT_BITWISE-val">NOT_BIT_GT_BITWISE</a> : thm
<a name="line121"></a>    val <a href="#NOT_BIT_GT_LOG2-val">NOT_BIT_GT_LOG2</a> : thm
<a name="line122"></a>    val <a href="#NOT_BIT_GT_TWOEXP-val">NOT_BIT_GT_TWOEXP</a> : thm
<a name="line123"></a>    val <a href="#NOT_MOD2_LEM-val">NOT_MOD2_LEM</a> : thm
<a name="line124"></a>    val <a href="#NOT_MOD2_LEM2-val">NOT_MOD2_LEM2</a> : thm
<a name="line125"></a>    val <a href="#NOT_ZERO_ADD1-val">NOT_ZERO_ADD1</a> : thm
<a name="line126"></a>    val <a href="#ODD_MOD2_LEM-val">ODD_MOD2_LEM</a> : thm
<a name="line127"></a>    val <a href="#ONE_LE_TWOEXP-val">ONE_LE_TWOEXP</a> : thm
<a name="line128"></a>    val <a href="#SBIT_DIV-val">SBIT_DIV</a> : thm
<a name="line129"></a>    val <a href="#SBIT_MULT-val">SBIT_MULT</a> : thm
<a name="line130"></a>    val <a href="#SLICELT_THM-val">SLICELT_THM</a> : thm
<a name="line131"></a>    val <a href="#SLICE_COMP_RWT-val">SLICE_COMP_RWT</a> : thm
<a name="line132"></a>    val <a href="#SLICE_COMP_THM-val">SLICE_COMP_THM</a> : thm
<a name="line133"></a>    val <a href="#SLICE_COMP_THM2-val">SLICE_COMP_THM2</a> : thm
<a name="line134"></a>    val <a href="#SLICE_THM-val">SLICE_THM</a> : thm
<a name="line135"></a>    val <a href="#SLICE_ZERO-val">SLICE_ZERO</a> : thm
<a name="line136"></a>    val <a href="#SLICE_ZERO2-val">SLICE_ZERO2</a> : thm
<a name="line137"></a>    val <a href="#SLICE_ZERO_THM-val">SLICE_ZERO_THM</a> : thm
<a name="line138"></a>    val <a href="#SUB_num_to_bin_string-val">SUB_num_to_bin_string</a> : thm
<a name="line139"></a>    val <a href="#SUC_SUB-val">SUC_SUB</a> : thm
<a name="line140"></a>    val <a href="#TRANS_THMS-val">TRANS_THMS</a> : thm
<a name="line141"></a>    val <a href="#TWOEXP_DIVISION-val">TWOEXP_DIVISION</a> : thm
<a name="line142"></a>    val <a href="#TWOEXP_LE_IMP_LE_LOG2-val">TWOEXP_LE_IMP_LE_LOG2</a> : thm
<a name="line143"></a>    val <a href="#TWOEXP_MONO-val">TWOEXP_MONO</a> : thm
<a name="line144"></a>    val <a href="#TWOEXP_MONO2-val">TWOEXP_MONO2</a> : thm
<a name="line145"></a>    val <a href="#TWOEXP_NOT_ZERO-val">TWOEXP_NOT_ZERO</a> : thm
<a name="line146"></a>    val <a href="#ZERO_LT_TWOEXP-val">ZERO_LT_TWOEXP</a> : thm
<a name="line147"></a>    val <a href="#num_bin_list-val">num_bin_list</a> : thm
<a name="line148"></a>    val <a href="#num_bin_string-val">num_bin_string</a> : thm
<a name="line149"></a>    val <a href="#num_dec_list-val">num_dec_list</a> : thm
<a name="line150"></a>    val <a href="#num_dec_string-val">num_dec_string</a> : thm
<a name="line151"></a>    val <a href="#num_hex_list-val">num_hex_list</a> : thm
<a name="line152"></a>    val <a href="#num_hex_string-val">num_hex_string</a> : thm
<a name="line153"></a>    val <a href="#num_oct_list-val">num_oct_list</a> : thm
<a name="line154"></a>    val <a href="#num_oct_string-val">num_oct_string</a> : thm
<a name="line155"></a>
<a name="line156"></a>  val bit_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line157"></a>(*
   [ASCIInumbers] Parent theory of "bit"

   [<a name="BITS_def-val"><b>BITS_def</b></a>]  Definition

      |- ∀h l n. BITS h l n = MOD_2EXP (SUC h − l) (DIV_2EXP l n)

   [<a name="BITV_def-val"><b>BITV_def</b></a>]  Definition

      |- ∀n b. BITV n b = BITS b b n

   [<a name="BITWISE_def-val"><b>BITWISE_def</b></a>]  Definition

      |- (∀op x y. BITWISE 0 op x y = 0) ∧
         ∀n op x y.
           BITWISE (SUC n) op x y =
           BITWISE n op x y + SBIT (op (BIT n x) (BIT n y)) n

   [<a name="BIT_MODIFY_def-val"><b>BIT_MODIFY_def</b></a>]  Definition

      |- (∀f x. BIT_MODIFY 0 f x = 0) ∧
         ∀n f x.
           BIT_MODIFY (SUC n) f x =
           BIT_MODIFY n f x + SBIT (f n (BIT n x)) n

   [<a name="BIT_REVERSE_def-val"><b>BIT_REVERSE_def</b></a>]  Definition

      |- (∀x. BIT_REVERSE 0 x = 0) ∧
         ∀n x.
           BIT_REVERSE (SUC n) x = BIT_REVERSE n x * 2 + SBIT (BIT n x) 0

   [<a name="BIT_def-val"><b>BIT_def</b></a>]  Definition

      |- ∀b n. BIT b n ⇔ (BITS b b n = 1)

   [<a name="BOOLIFY_def-val"><b>BOOLIFY_def</b></a>]  Definition

      |- (∀m a. BOOLIFY 0 m a = a) ∧
         ∀n m a. BOOLIFY (SUC n) m a = BOOLIFY n (DIV2 m) (ODD m::a)

   [<a name="DIVMOD_2EXP_def-val"><b>DIVMOD_2EXP_def</b></a>]  Definition

      |- ∀x n. DIVMOD_2EXP x n = (n DIV 2 ** x,n MOD 2 ** x)

   [<a name="LOG2_def-val"><b>LOG2_def</b></a>]  Definition

      |- LOG2 = LOG 2

   [<a name="LOWEST_SET_BIT_def-val"><b>LOWEST_SET_BIT_def</b></a>]  Definition

      |- ∀n. LOWEST_SET_BIT n = LEAST i. BIT i n

   [<a name="LSB_def-val"><b>LSB_def</b></a>]  Definition

      |- LSB = BIT 0

   [<a name="MOD_2EXP_EQ_def-val"><b>MOD_2EXP_EQ_def</b></a>]  Definition

      |- ∀n a b. MOD_2EXP_EQ n a b ⇔ (MOD_2EXP n a = MOD_2EXP n b)

   [<a name="MOD_2EXP_MAX_def-val"><b>MOD_2EXP_MAX_def</b></a>]  Definition

      |- ∀n a. MOD_2EXP_MAX n a ⇔ (MOD_2EXP n a = 2 ** n − 1)

   [<a name="SBIT_def-val"><b>SBIT_def</b></a>]  Definition

      |- ∀b n. SBIT b n = if b then 2 ** n else 0

   [<a name="SIGN_EXTEND_def-val"><b>SIGN_EXTEND_def</b></a>]  Definition

      |- ∀l h n.
           SIGN_EXTEND l h n =
           (let m = n MOD 2 ** l
            in
              if BIT (l − 1) n then 2 ** h − 2 ** l + m else m)

   [<a name="SLICE_def-val"><b>SLICE_def</b></a>]  Definition

      |- ∀h l n. SLICE h l n = MOD_2EXP (SUC h) n − MOD_2EXP l n

   [<a name="TIMES_2EXP_def-val"><b>TIMES_2EXP_def</b></a>]  Definition

      |- ∀x n. TIMES_2EXP x n = n * 2 ** x

   [<a name="ADD_BIT0-val"><b>ADD_BIT0</b></a>]  Theorem

      |- ∀m n. BIT 0 (m + n) ⇔ (BIT 0 m ⇎ BIT 0 n)

   [<a name="ADD_BITS_SUC-val"><b>ADD_BITS_SUC</b></a>]  Theorem

      |- ∀n a b.
           BITS (SUC n) (SUC n) (a + b) =
           (BITS (SUC n) (SUC n) a + BITS (SUC n) (SUC n) b +
            BITS (SUC n) (SUC n) (BITS n 0 a + BITS n 0 b)) MOD 2

   [<a name="ADD_BIT_SUC-val"><b>ADD_BIT_SUC</b></a>]  Theorem

      |- ∀n a b.
           BIT (SUC n) (a + b) ⇔
           if BIT (SUC n) (BITS n 0 a + BITS n 0 b) then
             BIT (SUC n) a ⇔ BIT (SUC n) b
           else
             BIT (SUC n) a ⇎ BIT (SUC n) b

   [<a name="BITSLT_THM-val"><b>BITSLT_THM</b></a>]  Theorem

      |- ∀h l n. BITS h l n &lt; 2 ** (SUC h − l)

   [<a name="BITSLT_THM2-val"><b>BITSLT_THM2</b></a>]  Theorem

      |- ∀h l n. BITS h l n &lt; 2 ** SUC h

   [<a name="BITS_COMP_THM-val"><b>BITS_COMP_THM</b></a>]  Theorem

      |- ∀h1 l1 h2 l2 n.
           h2 + l1 ≤ h1 ⇒
           (BITS h2 l2 (BITS h1 l1 n) = BITS (h2 + l1) (l2 + l1) n)

   [<a name="BITS_COMP_THM2-val"><b>BITS_COMP_THM2</b></a>]  Theorem

      |- ∀h1 l1 h2 l2 n.
           BITS h2 l2 (BITS h1 l1 n) = BITS (MIN h1 (h2 + l1)) (l2 + l1) n

   [<a name="BITS_DIV_THM-val"><b>BITS_DIV_THM</b></a>]  Theorem

      |- ∀h l x n. BITS h l x DIV 2 ** n = BITS h (l + n) x

   [<a name="BITS_LEQ-val"><b>BITS_LEQ</b></a>]  Theorem

      |- ∀h l n. BITS h l n ≤ n

   [<a name="BITS_LOG2_ZERO_ID-val"><b>BITS_LOG2_ZERO_ID</b></a>]  Theorem

      |- ∀n. 0 &lt; n ⇒ (BITS (LOG2 n) 0 n = n)

   [<a name="BITS_LT_HIGH-val"><b>BITS_LT_HIGH</b></a>]  Theorem

      |- ∀h l n. n &lt; 2 ** SUC h ⇒ (BITS h l n = n DIV 2 ** l)

   [<a name="BITS_LT_LOW-val"><b>BITS_LT_LOW</b></a>]  Theorem

      |- ∀h l n. n &lt; 2 ** l ⇒ (BITS h l n = 0)

   [<a name="BITS_MUL-val"><b>BITS_MUL</b></a>]  Theorem

      |- ∀h a b. BITS h 0 (BITS h 0 a * BITS h 0 b) = BITS h 0 (a * b)

   [<a name="BITS_SLICE_THM-val"><b>BITS_SLICE_THM</b></a>]  Theorem

      |- ∀h l n. BITS h l (SLICE h l n) = BITS h l n

   [<a name="BITS_SLICE_THM2-val"><b>BITS_SLICE_THM2</b></a>]  Theorem

      |- ∀h h2 l n. h ≤ h2 ⇒ (BITS h2 l (SLICE h l n) = BITS h l n)

   [<a name="BITS_SUC-val"><b>BITS_SUC</b></a>]  Theorem

      |- ∀h l n.
           l ≤ SUC h ⇒
           (SBIT (BIT (SUC h) n) (SUC h − l) + BITS h l n =
            BITS (SUC h) l n)

   [<a name="BITS_SUC_THM-val"><b>BITS_SUC_THM</b></a>]  Theorem

      |- ∀h l n.
           BITS (SUC h) l n =
           if SUC h &lt; l then
             0
           else
             SBIT (BIT (SUC h) n) (SUC h − l) + BITS h l n

   [<a name="BITS_SUM-val"><b>BITS_SUM</b></a>]  Theorem

      |- ∀h l a b.
           b &lt; 2 ** l ⇒ (BITS h l (a * 2 ** l + b) = BITS h l (a * 2 ** l))

   [<a name="BITS_SUM2-val"><b>BITS_SUM2</b></a>]  Theorem

      |- ∀h l a b. BITS h l (a * 2 ** SUC h + b) = BITS h l b

   [<a name="BITS_SUM3-val"><b>BITS_SUM3</b></a>]  Theorem

      |- ∀h a b. BITS h 0 (BITS h 0 a + BITS h 0 b) = BITS h 0 (a + b)

   [<a name="BITS_THM-val"><b>BITS_THM</b></a>]  Theorem

      |- ∀h l n. BITS h l n = (n DIV 2 ** l) MOD 2 ** (SUC h − l)

   [<a name="BITS_THM2-val"><b>BITS_THM2</b></a>]  Theorem

      |- ∀h l n. BITS h l n = n MOD 2 ** SUC h DIV 2 ** l

   [<a name="BITS_ZERO-val"><b>BITS_ZERO</b></a>]  Theorem

      |- ∀h l n. h &lt; l ⇒ (BITS h l n = 0)

   [<a name="BITS_ZERO2-val"><b>BITS_ZERO2</b></a>]  Theorem

      |- ∀h l. BITS h l 0 = 0

   [<a name="BITS_ZERO3-val"><b>BITS_ZERO3</b></a>]  Theorem

      |- ∀h n. BITS h 0 n = n MOD 2 ** SUC h

   [<a name="BITS_ZERO4-val"><b>BITS_ZERO4</b></a>]  Theorem

      |- ∀h l a. l ≤ h ⇒ (BITS h l (a * 2 ** l) = BITS (h − l) 0 a)

   [<a name="BITS_ZERO5-val"><b>BITS_ZERO5</b></a>]  Theorem

      |- ∀n m. (∀i. i ≤ n ⇒ ¬BIT i m) ⇒ (BITS n 0 m = 0)

   [<a name="BITS_ZEROL-val"><b>BITS_ZEROL</b></a>]  Theorem

      |- ∀h a. a &lt; 2 ** SUC h ⇒ (BITS h 0 a = a)

   [<a name="BITV_THM-val"><b>BITV_THM</b></a>]  Theorem

      |- ∀b n. BITV n b = SBIT (BIT b n) 0

   [<a name="BITWISE_BITS-val"><b>BITWISE_BITS</b></a>]  Theorem

      |- ∀wl op a b.
           BITWISE (SUC wl) op (BITS wl 0 a) (BITS wl 0 b) =
           BITWISE (SUC wl) op a b

   [<a name="BITWISE_COR-val"><b>BITWISE_COR</b></a>]  Theorem

      |- ∀x n op a b.
           x &lt; n ⇒
           op (BIT x a) (BIT x b) ⇒
           ((BITWISE n op a b DIV 2 ** x) MOD 2 = 1)

   [<a name="BITWISE_EVAL-val"><b>BITWISE_EVAL</b></a>]  Theorem

      |- ∀n op a b.
           BITWISE (SUC n) op a b =
           2 * BITWISE n op (a DIV 2) (b DIV 2) +
           SBIT (op (LSB a) (LSB b)) 0

   [<a name="BITWISE_LT_2EXP-val"><b>BITWISE_LT_2EXP</b></a>]  Theorem

      |- ∀n op a b. BITWISE n op a b &lt; 2 ** n

   [<a name="BITWISE_NOT_COR-val"><b>BITWISE_NOT_COR</b></a>]  Theorem

      |- ∀x n op a b.
           x &lt; n ⇒
           ¬op (BIT x a) (BIT x b) ⇒
           ((BITWISE n op a b DIV 2 ** x) MOD 2 = 0)

   [<a name="BITWISE_ONE_COMP_LEM-val"><b>BITWISE_ONE_COMP_LEM</b></a>]  Theorem

      |- ∀n a b.
           BITWISE (SUC n) (λx y. ¬x) a b = 2 ** SUC n − 1 − BITS n 0 a

   [<a name="BITWISE_THM-val"><b>BITWISE_THM</b></a>]  Theorem

      |- ∀x n op a b.
           x &lt; n ⇒ (BIT x (BITWISE n op a b) ⇔ op (BIT x a) (BIT x b))

   [<a name="BIT_B-val"><b>BIT_B</b></a>]  Theorem

      |- ∀b. BIT b (2 ** b)

   [<a name="BIT_BITS_THM-val"><b>BIT_BITS_THM</b></a>]  Theorem

      |- ∀h l a b.
           (∀x. l ≤ x ∧ x ≤ h ⇒ (BIT x a ⇔ BIT x b)) ⇔
           (BITS h l a = BITS h l b)

   [<a name="BIT_B_NEQ-val"><b>BIT_B_NEQ</b></a>]  Theorem

      |- ∀a b. a ≠ b ⇒ ¬BIT a (2 ** b)

   [<a name="BIT_COMPLEMENT-val"><b>BIT_COMPLEMENT</b></a>]  Theorem

      |- ∀n i a.
           BIT i (2 ** n − a MOD 2 ** n) ⇔
           (a MOD 2 ** n = 0) ∧ (i = n) ∨
           a MOD 2 ** n ≠ 0 ∧ i &lt; n ∧ ¬BIT i (a MOD 2 ** n − 1)

   [<a name="BIT_COMP_THM3-val"><b>BIT_COMP_THM3</b></a>]  Theorem

      |- ∀h m l n.
           SUC m ≤ h ∧ l ≤ m ⇒
           (BITS h (SUC m) n * 2 ** (SUC m − l) + BITS m l n = BITS h l n)

   [<a name="BIT_DIV2-val"><b>BIT_DIV2</b></a>]  Theorem

      |- ∀n i. BIT n (i DIV 2) ⇔ BIT (SUC n) i

   [<a name="BIT_EXP_SUB1-val"><b>BIT_EXP_SUB1</b></a>]  Theorem

      |- ∀b n. BIT b (2 ** n − 1) ⇔ b &lt; n

   [<a name="BIT_IMP_GE_TWOEXP-val"><b>BIT_IMP_GE_TWOEXP</b></a>]  Theorem

      |- ∀i n. BIT i n ⇒ 2 ** i ≤ n

   [<a name="BIT_LOG2-val"><b>BIT_LOG2</b></a>]  Theorem

      |- ∀n. n ≠ 0 ⇒ BIT (LOG2 n) n

   [<a name="BIT_MODIFY_THM-val"><b>BIT_MODIFY_THM</b></a>]  Theorem

      |- ∀x n f a. x &lt; n ⇒ (BIT x (BIT_MODIFY n f a) ⇔ f x (BIT x a))

   [<a name="BIT_OF_BITS_THM-val"><b>BIT_OF_BITS_THM</b></a>]  Theorem

      |- ∀n h l a. l + n ≤ h ⇒ (BIT n (BITS h l a) ⇔ BIT (l + n) a)

   [<a name="BIT_OF_BITS_THM2-val"><b>BIT_OF_BITS_THM2</b></a>]  Theorem

      |- ∀h l x n. h &lt; l + x ⇒ ¬BIT x (BITS h l n)

   [<a name="BIT_REVERSE_THM-val"><b>BIT_REVERSE_THM</b></a>]  Theorem

      |- ∀x n a. x &lt; n ⇒ (BIT x (BIT_REVERSE n a) ⇔ BIT (n − 1 − x) a)

   [<a name="BIT_SHIFT_THM-val"><b>BIT_SHIFT_THM</b></a>]  Theorem

      |- ∀n a s. BIT (n + s) (a * 2 ** s) ⇔ BIT n a

   [<a name="BIT_SHIFT_THM2-val"><b>BIT_SHIFT_THM2</b></a>]  Theorem

      |- ∀n a s. s ≤ n ⇒ (BIT n (a * 2 ** s) ⇔ BIT (n − s) a)

   [<a name="BIT_SHIFT_THM3-val"><b>BIT_SHIFT_THM3</b></a>]  Theorem

      |- ∀n a s. n &lt; s ⇒ ¬BIT n (a * 2 ** s)

   [<a name="BIT_SHIFT_THM4-val"><b>BIT_SHIFT_THM4</b></a>]  Theorem

      |- ∀n i a. BIT i (a DIV 2 ** n) ⇔ BIT (i + n) a

   [<a name="BIT_SHIFT_THM5-val"><b>BIT_SHIFT_THM5</b></a>]  Theorem

      |- ∀n m i a.
           i + n &lt; m ∧ a &lt; 2 ** m ⇒
           (BIT i
              (2 ** m −
               (a DIV 2 ** n + if a MOD 2 ** n = 0 then 0 else 1) MOD
               2 ** m) ⇔ BIT (i + n) (2 ** m − a MOD 2 ** m))

   [<a name="BIT_SIGN_EXTEND-val"><b>BIT_SIGN_EXTEND</b></a>]  Theorem

      |- ∀l h n i.
           l ≠ 0 ⇒
           (BIT i (SIGN_EXTEND l h n) ⇔
            if l ≤ h ⇒ i &lt; l then
              BIT i (n MOD 2 ** l)
            else
              i &lt; h ∧ BIT (l − 1) n)

   [<a name="BIT_SLICE-val"><b>BIT_SLICE</b></a>]  Theorem

      |- ∀n a b. (BIT n a ⇔ BIT n b) ⇔ (SLICE n n a = SLICE n n b)

   [<a name="BIT_SLICE_LEM-val"><b>BIT_SLICE_LEM</b></a>]  Theorem

      |- ∀y x n. SBIT (BIT x n) (x + y) = SLICE x x n * 2 ** y

   [<a name="BIT_SLICE_THM-val"><b>BIT_SLICE_THM</b></a>]  Theorem

      |- ∀x n. SBIT (BIT x n) x = SLICE x x n

   [<a name="BIT_SLICE_THM2-val"><b>BIT_SLICE_THM2</b></a>]  Theorem

      |- ∀b n. BIT b n ⇔ (SLICE b b n = 2 ** b)

   [<a name="BIT_SLICE_THM3-val"><b>BIT_SLICE_THM3</b></a>]  Theorem

      |- ∀b n. ¬BIT b n ⇔ (SLICE b b n = 0)

   [<a name="BIT_SLICE_THM4-val"><b>BIT_SLICE_THM4</b></a>]  Theorem

      |- ∀b h l n. BIT b (SLICE h l n) ⇔ l ≤ b ∧ b ≤ h ∧ BIT b n

   [<a name="BIT_ZERO-val"><b>BIT_ZERO</b></a>]  Theorem

      |- ∀b. ¬BIT b 0

   [<a name="BIT_num_from_bin_list-val"><b>BIT_num_from_bin_list</b></a>]  Theorem

      |- ∀x l.
           EVERY ($&gt; 2) l ∧ x &lt; LENGTH l ⇒
           (BIT x (num_from_bin_list l) ⇔ (EL x l = 1))

   [<a name="BIT_num_from_bin_string-val"><b>BIT_num_from_bin_string</b></a>]  Theorem

      |- ∀x s.
           EVERY ($&gt; 2 o UNHEX) s ∧ x &lt; STRLEN s ⇒
           (BIT x (num_from_bin_string s) ⇔
            (UNHEX (SUB (s,PRE (STRLEN s − x))) = 1))

   [<a name="BOOLIFY_def_compute-val"><b>BOOLIFY_def_compute</b></a>]  Theorem

      |- (∀m a. BOOLIFY 0 m a = a) ∧
         (∀n m a.
            BOOLIFY (NUMERAL (BIT1 n)) m a =
            BOOLIFY (NUMERAL (BIT1 n) − 1) (DIV2 m) (ODD m::a)) ∧
         ∀n m a.
           BOOLIFY (NUMERAL (BIT2 n)) m a =
           BOOLIFY (NUMERAL (BIT1 n)) (DIV2 m) (ODD m::a)

   [<a name="DIVMOD_2EXP-val"><b>DIVMOD_2EXP</b></a>]  Theorem

      |- ∀x n. DIVMOD_2EXP x n = (DIV_2EXP x n,MOD_2EXP x n)

   [<a name="DIV_GT0-val"><b>DIV_GT0</b></a>]  Theorem

      |- ∀a b. b ≤ a ∧ 0 &lt; b ⇒ 0 &lt; a DIV b

   [<a name="DIV_LT-val"><b>DIV_LT</b></a>]  Theorem

      |- ∀n m a. n &lt; m ∧ a &lt; 2 ** m ⇒ a DIV 2 ** n &lt; 2 ** m

   [<a name="DIV_MULT_1-val"><b>DIV_MULT_1</b></a>]  Theorem

      |- ∀r n. r &lt; n ⇒ ((n + r) DIV n = 1)

   [<a name="DIV_MULT_THM-val"><b>DIV_MULT_THM</b></a>]  Theorem

      |- ∀x n. n DIV 2 ** x * 2 ** x = n − n MOD 2 ** x

   [<a name="DIV_MULT_THM2-val"><b>DIV_MULT_THM2</b></a>]  Theorem

      |- ∀n. 2 * (n DIV 2) = n − n MOD 2

   [<a name="DIV_SUB1-val"><b>DIV_SUB1</b></a>]  Theorem

      |- ∀a b.
           2 ** b ≤ a ∧ (a MOD 2 ** b = 0) ⇒
           (a DIV 2 ** b − 1 = (a − 1) DIV 2 ** b)

   [<a name="EL_num_to_bin_list-val"><b>EL_num_to_bin_list</b></a>]  Theorem

      |- ∀x n.
           x &lt; LENGTH (num_to_bin_list n) ⇒
           (EL x (num_to_bin_list n) = BITV n x)

   [<a name="EXISTS_BIT_IN_RANGE-val"><b>EXISTS_BIT_IN_RANGE</b></a>]  Theorem

      |- ∀a b n.
           n ≠ 0 ∧ 2 ** a ≤ n ∧ n &lt; 2 ** b ⇒ ∃i. a ≤ i ∧ i &lt; b ∧ BIT i n

   [<a name="EXISTS_BIT_LT-val"><b>EXISTS_BIT_LT</b></a>]  Theorem

      |- ∀b n. n ≠ 0 ∧ n &lt; 2 ** b ⇒ ∃i. i &lt; b ∧ BIT i n

   [<a name="EXP_SUB_LESS_EQ-val"><b>EXP_SUB_LESS_EQ</b></a>]  Theorem

      |- ∀a b. 2 ** (a − b) ≤ 2 ** a

   [<a name="LEAST_THM-val"><b>LEAST_THM</b></a>]  Theorem

      |- ∀n P. (∀m. m &lt; n ⇒ ¬P m) ∧ P n ⇒ ($LEAST P = n)

   [<a name="LESS_EQ_EXP_MULT-val"><b>LESS_EQ_EXP_MULT</b></a>]  Theorem

      |- ∀a b. a ≤ b ⇒ ∃p. 2 ** b = p * 2 ** a

   [<a name="LESS_MULT_MONO2-val"><b>LESS_MULT_MONO2</b></a>]  Theorem

      |- ∀a b x y. a &lt; x ∧ b &lt; y ⇒ a * b &lt; x * y

   [<a name="LOG2_LE_MONO-val"><b>LOG2_LE_MONO</b></a>]  Theorem

      |- ∀x y. 0 &lt; x ⇒ x ≤ y ⇒ LOG2 x ≤ LOG2 y

   [<a name="LOG2_TWOEXP-val"><b>LOG2_TWOEXP</b></a>]  Theorem

      |- ∀n. LOG2 (2 ** n) = n

   [<a name="LOG2_UNIQUE-val"><b>LOG2_UNIQUE</b></a>]  Theorem

      |- ∀n p. 2 ** p ≤ n ∧ n &lt; 2 ** SUC p ⇒ (LOG2 n = p)

   [<a name="LSB_ODD-val"><b>LSB_ODD</b></a>]  Theorem

      |- LSB = ODD

   [<a name="LT_TWOEXP-val"><b>LT_TWOEXP</b></a>]  Theorem

      |- ∀x n. x &lt; 2 ** n ⇔ (x = 0) ∨ LOG2 x &lt; n

   [<a name="MOD_2EXP_LT-val"><b>MOD_2EXP_LT</b></a>]  Theorem

      |- ∀n k. k MOD 2 ** n &lt; 2 ** n

   [<a name="MOD_2EXP_MONO-val"><b>MOD_2EXP_MONO</b></a>]  Theorem

      |- ∀n h l. l ≤ h ⇒ n MOD 2 ** l ≤ n MOD 2 ** SUC h

   [<a name="MOD_ADD_1-val"><b>MOD_ADD_1</b></a>]  Theorem

      |- ∀n. 0 &lt; n ⇒ ∀x. (x + 1) MOD n ≠ 0 ⇒ ((x + 1) MOD n = x MOD n + 1)

   [<a name="MOD_LEQ-val"><b>MOD_LEQ</b></a>]  Theorem

      |- ∀a b. 0 &lt; b ⇒ a MOD b ≤ a

   [<a name="MOD_PLUS_1-val"><b>MOD_PLUS_1</b></a>]  Theorem

      |- ∀n. 0 &lt; n ⇒ ∀x. ((x + 1) MOD n = 0) ⇔ (x MOD n + 1 = n)

   [<a name="MOD_PLUS_LEFT-val"><b>MOD_PLUS_LEFT</b></a>]  Theorem

      |- ∀n. 0 &lt; n ⇒ ∀j k. (k MOD n + j) MOD n = (k + j) MOD n

   [<a name="MOD_PLUS_RIGHT-val"><b>MOD_PLUS_RIGHT</b></a>]  Theorem

      |- ∀n. 0 &lt; n ⇒ ∀j k. (j + k MOD n) MOD n = (j + k) MOD n

   [<a name="MOD_ZERO_GT-val"><b>MOD_ZERO_GT</b></a>]  Theorem

      |- ∀n a. a ≠ 0 ∧ (a MOD 2 ** n = 0) ⇒ 2 ** n ≤ a

   [<a name="NOT_BIT-val"><b>NOT_BIT</b></a>]  Theorem

      |- ∀n a. ¬BIT n a ⇔ (BITS n n a = 0)

   [<a name="NOT_BITS-val"><b>NOT_BITS</b></a>]  Theorem

      |- ∀n a. BITS n n a ≠ 0 ⇔ (BITS n n a = 1)

   [<a name="NOT_BITS2-val"><b>NOT_BITS2</b></a>]  Theorem

      |- ∀n a. BITS n n a ≠ 1 ⇔ (BITS n n a = 0)

   [<a name="NOT_BIT_GT_BITWISE-val"><b>NOT_BIT_GT_BITWISE</b></a>]  Theorem

      |- ∀i n op a b. n ≤ i ⇒ ¬BIT i (BITWISE n op a b)

   [<a name="NOT_BIT_GT_LOG2-val"><b>NOT_BIT_GT_LOG2</b></a>]  Theorem

      |- ∀i n. LOG2 n &lt; i ⇒ ¬BIT i n

   [<a name="NOT_BIT_GT_TWOEXP-val"><b>NOT_BIT_GT_TWOEXP</b></a>]  Theorem

      |- ∀i n. n &lt; 2 ** i ⇒ ¬BIT i n

   [<a name="NOT_MOD2_LEM-val"><b>NOT_MOD2_LEM</b></a>]  Theorem

      |- ∀n. n MOD 2 ≠ 0 ⇔ (n MOD 2 = 1)

   [<a name="NOT_MOD2_LEM2-val"><b>NOT_MOD2_LEM2</b></a>]  Theorem

      |- ∀n. n MOD 2 ≠ 1 ⇔ (n MOD 2 = 0)

   [<a name="NOT_ZERO_ADD1-val"><b>NOT_ZERO_ADD1</b></a>]  Theorem

      |- ∀m. m ≠ 0 ⇒ ∃p. m = SUC p

   [<a name="ODD_MOD2_LEM-val"><b>ODD_MOD2_LEM</b></a>]  Theorem

      |- ∀n. ODD n ⇔ (n MOD 2 = 1)

   [<a name="ONE_LE_TWOEXP-val"><b>ONE_LE_TWOEXP</b></a>]  Theorem

      |- ∀n. 1 ≤ 2 ** n

   [<a name="SBIT_DIV-val"><b>SBIT_DIV</b></a>]  Theorem

      |- ∀b m n. n &lt; m ⇒ (SBIT b (m − n) = SBIT b m DIV 2 ** n)

   [<a name="SBIT_MULT-val"><b>SBIT_MULT</b></a>]  Theorem

      |- ∀b m n. SBIT b n * 2 ** m = SBIT b (n + m)

   [<a name="SLICELT_THM-val"><b>SLICELT_THM</b></a>]  Theorem

      |- ∀h l n. SLICE h l n &lt; 2 ** SUC h

   [<a name="SLICE_COMP_RWT-val"><b>SLICE_COMP_RWT</b></a>]  Theorem

      |- ∀h m' m l n.
           l ≤ m ∧ (m' = m + 1) ∧ m &lt; h ⇒
           (SLICE h m' n + SLICE m l n = SLICE h l n)

   [<a name="SLICE_COMP_THM-val"><b>SLICE_COMP_THM</b></a>]  Theorem

      |- ∀h m l n.
           SUC m ≤ h ∧ l ≤ m ⇒
           (SLICE h (SUC m) n + SLICE m l n = SLICE h l n)

   [<a name="SLICE_COMP_THM2-val"><b>SLICE_COMP_THM2</b></a>]  Theorem

      |- ∀h l x y n.
           h ≤ x ∧ y ≤ l ⇒ (SLICE h l (SLICE x y n) = SLICE h l n)

   [<a name="SLICE_THM-val"><b>SLICE_THM</b></a>]  Theorem

      |- ∀n h l. SLICE h l n = BITS h l n * 2 ** l

   [<a name="SLICE_ZERO-val"><b>SLICE_ZERO</b></a>]  Theorem

      |- ∀h l n. h &lt; l ⇒ (SLICE h l n = 0)

   [<a name="SLICE_ZERO2-val"><b>SLICE_ZERO2</b></a>]  Theorem

      |- ∀l h. SLICE h l 0 = 0

   [<a name="SLICE_ZERO_THM-val"><b>SLICE_ZERO_THM</b></a>]  Theorem

      |- ∀n h. SLICE h 0 n = BITS h 0 n

   [<a name="SUB_num_to_bin_string-val"><b>SUB_num_to_bin_string</b></a>]  Theorem

      |- ∀x n.
           x &lt; STRLEN (num_to_bin_string n) ⇒
           (SUB (num_to_bin_string n,x) =
            HEX (BITV n (PRE (STRLEN (num_to_bin_string n) − x))))

   [<a name="SUC_SUB-val"><b>SUC_SUB</b></a>]  Theorem

      |- SUC a − a = 1

   [<a name="TRANS_THMS-val"><b>TRANS_THMS</b></a>]  Theorem

      |- (∀m n p. m &lt; n ∧ n &lt; p ⇒ m &lt; p) ∧
         (∀m n p. m ≤ n ∧ n &lt; p ⇒ m &lt; p) ∧
         (∀m n p. m &lt; n ∧ n ≤ p ⇒ m &lt; p) ∧ ∀m n p. m ≤ n ∧ n ≤ p ⇒ m ≤ p

   [<a name="TWOEXP_DIVISION-val"><b>TWOEXP_DIVISION</b></a>]  Theorem

      |- ∀n k. k = k DIV 2 ** n * 2 ** n + k MOD 2 ** n

   [<a name="TWOEXP_LE_IMP_LE_LOG2-val"><b>TWOEXP_LE_IMP_LE_LOG2</b></a>]  Theorem

      |- (∀x y. 2 ** x ≤ y ⇒ x ≤ LOG2 y) ∧
         ∀y x. 0 &lt; x ⇒ x ≤ 2 ** y ⇒ LOG2 x ≤ y

   [<a name="TWOEXP_MONO-val"><b>TWOEXP_MONO</b></a>]  Theorem

      |- ∀a b. a &lt; b ⇒ 2 ** a &lt; 2 ** b

   [<a name="TWOEXP_MONO2-val"><b>TWOEXP_MONO2</b></a>]  Theorem

      |- ∀a b. a ≤ b ⇒ 2 ** a ≤ 2 ** b

   [<a name="TWOEXP_NOT_ZERO-val"><b>TWOEXP_NOT_ZERO</b></a>]  Theorem

      |- ∀n. 2 ** n ≠ 0

   [<a name="ZERO_LT_TWOEXP-val"><b>ZERO_LT_TWOEXP</b></a>]  Theorem

      |- ∀n. 0 &lt; 2 ** n

   [<a name="num_bin_list-val"><b>num_bin_list</b></a>]  Theorem

      |- num_from_bin_list o num_to_bin_list = I

   [<a name="num_bin_string-val"><b>num_bin_string</b></a>]  Theorem

      |- num_from_bin_string o num_to_bin_string = I

   [<a name="num_dec_list-val"><b>num_dec_list</b></a>]  Theorem

      |- num_from_dec_list o num_to_dec_list = I

   [<a name="num_dec_string-val"><b>num_dec_string</b></a>]  Theorem

      |- toNum o toString = I

   [<a name="num_hex_list-val"><b>num_hex_list</b></a>]  Theorem

      |- num_from_hex_list o num_to_hex_list = I

   [<a name="num_hex_string-val"><b>num_hex_string</b></a>]  Theorem

      |- num_from_hex_string o num_to_hex_string = I

   [<a name="num_oct_list-val"><b>num_oct_list</b></a>]  Theorem

      |- num_from_oct_list o num_to_oct_list = I

   [<a name="num_oct_string-val"><b>num_oct_string</b></a>]  Theorem

      |- num_from_oct_string o num_to_oct_string = I


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/n-bit/bitScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-8</a></em></p></body></html>
