<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure rich_listTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure rich_listTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/list/src/rich_listScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature rich_listTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#AND_EL_DEF-val">AND_EL_DEF</a> : thm
<a name="line7"></a>    val <a href="#BUTLASTN-val">BUTLASTN</a> : thm
<a name="line8"></a>    val <a href="#COUNT_LIST_AUX_def-val">COUNT_LIST_AUX_def</a> : thm
<a name="line9"></a>    val <a href="#COUNT_LIST_def-val">COUNT_LIST_def</a> : thm
<a name="line10"></a>    val <a href="#ELL-val">ELL</a> : thm
<a name="line11"></a>    val <a href="#IS_SUBLIST-val">IS_SUBLIST</a> : thm
<a name="line12"></a>    val <a href="#IS_SUFFIX-val">IS_SUFFIX</a> : thm
<a name="line13"></a>    val <a href="#LASTN-val">LASTN</a> : thm
<a name="line14"></a>    val <a href="#LIST_ELEM_COUNT_DEF-val">LIST_ELEM_COUNT_DEF</a> : thm
<a name="line15"></a>    val <a href="#OR_EL_DEF-val">OR_EL_DEF</a> : thm
<a name="line16"></a>    val <a href="#PREFIX_DEF-val">PREFIX_DEF</a> : thm
<a name="line17"></a>    val <a href="#REPLACE_ELEMENT_DEF-val">REPLACE_ELEMENT_DEF</a> : thm
<a name="line18"></a>    val <a href="#REPLICATE-val">REPLICATE</a> : thm
<a name="line19"></a>    val <a href="#SCANL-val">SCANL</a> : thm
<a name="line20"></a>    val <a href="#SCANR-val">SCANR</a> : thm
<a name="line21"></a>    val <a href="#SEG-val">SEG</a> : thm
<a name="line22"></a>    val <a href="#SPLITP-val">SPLITP</a> : thm
<a name="line23"></a>    val <a href="#SPLITP_AUX_def-val">SPLITP_AUX_def</a> : thm
<a name="line24"></a>    val <a href="#SUFFIX_DEF-val">SUFFIX_DEF</a> : thm
<a name="line25"></a>    val <a href="#UNZIP_FST_DEF-val">UNZIP_FST_DEF</a> : thm
<a name="line26"></a>    val <a href="#UNZIP_SND_DEF-val">UNZIP_SND_DEF</a> : thm
<a name="line27"></a>
<a name="line28"></a>  (*  Theorems  *)
<a name="line29"></a>    val <a href="#ALL_EL_MAP-val">ALL_EL_MAP</a> : thm
<a name="line30"></a>    val <a href="#AND_EL_FOLDL-val">AND_EL_FOLDL</a> : thm
<a name="line31"></a>    val <a href="#AND_EL_FOLDR-val">AND_EL_FOLDR</a> : thm
<a name="line32"></a>    val <a href="#APPEND_ASSOC_CONS-val">APPEND_ASSOC_CONS</a> : thm
<a name="line33"></a>    val <a href="#APPEND_BUTLASTN_DROP-val">APPEND_BUTLASTN_DROP</a> : thm
<a name="line34"></a>    val <a href="#APPEND_BUTLASTN_LASTN-val">APPEND_BUTLASTN_LASTN</a> : thm
<a name="line35"></a>    val <a href="#APPEND_FOLDL-val">APPEND_FOLDL</a> : thm
<a name="line36"></a>    val <a href="#APPEND_FOLDR-val">APPEND_FOLDR</a> : thm
<a name="line37"></a>    val <a href="#APPEND_NIL-val">APPEND_NIL</a> : thm
<a name="line38"></a>    val <a href="#APPEND_SNOC1-val">APPEND_SNOC1</a> : thm
<a name="line39"></a>    val <a href="#APPEND_TAKE_LASTN-val">APPEND_TAKE_LASTN</a> : thm
<a name="line40"></a>    val <a href="#ASSOC_APPEND-val">ASSOC_APPEND</a> : thm
<a name="line41"></a>    val <a href="#ASSOC_FOLDL_FLAT-val">ASSOC_FOLDL_FLAT</a> : thm
<a name="line42"></a>    val <a href="#ASSOC_FOLDR_FLAT-val">ASSOC_FOLDR_FLAT</a> : thm
<a name="line43"></a>    val <a href="#BUTLASTN_1-val">BUTLASTN_1</a> : thm
<a name="line44"></a>    val <a href="#BUTLASTN_APPEND1-val">BUTLASTN_APPEND1</a> : thm
<a name="line45"></a>    val <a href="#BUTLASTN_APPEND2-val">BUTLASTN_APPEND2</a> : thm
<a name="line46"></a>    val <a href="#BUTLASTN_BUTLASTN-val">BUTLASTN_BUTLASTN</a> : thm
<a name="line47"></a>    val <a href="#BUTLASTN_CONS-val">BUTLASTN_CONS</a> : thm
<a name="line48"></a>    val <a href="#BUTLASTN_FRONT-val">BUTLASTN_FRONT</a> : thm
<a name="line49"></a>    val <a href="#BUTLASTN_LASTN-val">BUTLASTN_LASTN</a> : thm
<a name="line50"></a>    val <a href="#BUTLASTN_LASTN_NIL-val">BUTLASTN_LASTN_NIL</a> : thm
<a name="line51"></a>    val <a href="#BUTLASTN_LENGTH_APPEND-val">BUTLASTN_LENGTH_APPEND</a> : thm
<a name="line52"></a>    val <a href="#BUTLASTN_LENGTH_CONS-val">BUTLASTN_LENGTH_CONS</a> : thm
<a name="line53"></a>    val <a href="#BUTLASTN_LENGTH_NIL-val">BUTLASTN_LENGTH_NIL</a> : thm
<a name="line54"></a>    val <a href="#BUTLASTN_MAP-val">BUTLASTN_MAP</a> : thm
<a name="line55"></a>    val <a href="#BUTLASTN_REVERSE-val">BUTLASTN_REVERSE</a> : thm
<a name="line56"></a>    val <a href="#BUTLASTN_SEG-val">BUTLASTN_SEG</a> : thm
<a name="line57"></a>    val <a href="#BUTLASTN_SUC_FRONT-val">BUTLASTN_SUC_FRONT</a> : thm
<a name="line58"></a>    val <a href="#BUTLASTN_TAKE-val">BUTLASTN_TAKE</a> : thm
<a name="line59"></a>    val <a href="#BUTLASTN_compute-val">BUTLASTN_compute</a> : thm
<a name="line60"></a>    val <a href="#COMM_ASSOC_FOLDL_REVERSE-val">COMM_ASSOC_FOLDL_REVERSE</a> : thm
<a name="line61"></a>    val <a href="#COMM_ASSOC_FOLDR_REVERSE-val">COMM_ASSOC_FOLDR_REVERSE</a> : thm
<a name="line62"></a>    val <a href="#COMM_MONOID_FOLDL-val">COMM_MONOID_FOLDL</a> : thm
<a name="line63"></a>    val <a href="#COMM_MONOID_FOLDR-val">COMM_MONOID_FOLDR</a> : thm
<a name="line64"></a>    val <a href="#CONS_APPEND-val">CONS_APPEND</a> : thm
<a name="line65"></a>    val <a href="#COUNT_LIST_ADD-val">COUNT_LIST_ADD</a> : thm
<a name="line66"></a>    val <a href="#COUNT_LIST_AUX_def_compute-val">COUNT_LIST_AUX_def_compute</a> : thm
<a name="line67"></a>    val <a href="#COUNT_LIST_COUNT-val">COUNT_LIST_COUNT</a> : thm
<a name="line68"></a>    val <a href="#COUNT_LIST_GENLIST-val">COUNT_LIST_GENLIST</a> : thm
<a name="line69"></a>    val <a href="#COUNT_LIST_SNOC-val">COUNT_LIST_SNOC</a> : thm
<a name="line70"></a>    val <a href="#COUNT_LIST_compute-val">COUNT_LIST_compute</a> : thm
<a name="line71"></a>    val <a href="#DROP-val">DROP</a> : thm
<a name="line72"></a>    val <a href="#DROP_APPEND1-val">DROP_APPEND1</a> : thm
<a name="line73"></a>    val <a href="#DROP_APPEND2-val">DROP_APPEND2</a> : thm
<a name="line74"></a>    val <a href="#DROP_CONS_EL-val">DROP_CONS_EL</a> : thm
<a name="line75"></a>    val <a href="#DROP_DROP-val">DROP_DROP</a> : thm
<a name="line76"></a>    val <a href="#DROP_LASTN-val">DROP_LASTN</a> : thm
<a name="line77"></a>    val <a href="#DROP_LENGTH_APPEND-val">DROP_LENGTH_APPEND</a> : thm
<a name="line78"></a>    val <a href="#DROP_LENGTH_NIL-val">DROP_LENGTH_NIL</a> : thm
<a name="line79"></a>    val <a href="#DROP_REVERSE-val">DROP_REVERSE</a> : thm
<a name="line80"></a>    val <a href="#DROP_SEG-val">DROP_SEG</a> : thm
<a name="line81"></a>    val <a href="#DROP_SNOC-val">DROP_SNOC</a> : thm
<a name="line82"></a>    val <a href="#ELL_0_SNOC-val">ELL_0_SNOC</a> : thm
<a name="line83"></a>    val <a href="#ELL_APPEND1-val">ELL_APPEND1</a> : thm
<a name="line84"></a>    val <a href="#ELL_APPEND2-val">ELL_APPEND2</a> : thm
<a name="line85"></a>    val <a href="#ELL_CONS-val">ELL_CONS</a> : thm
<a name="line86"></a>    val <a href="#ELL_EL-val">ELL_EL</a> : thm
<a name="line87"></a>    val <a href="#ELL_LAST-val">ELL_LAST</a> : thm
<a name="line88"></a>    val <a href="#ELL_LENGTH_APPEND-val">ELL_LENGTH_APPEND</a> : thm
<a name="line89"></a>    val <a href="#ELL_LENGTH_CONS-val">ELL_LENGTH_CONS</a> : thm
<a name="line90"></a>    val <a href="#ELL_LENGTH_SNOC-val">ELL_LENGTH_SNOC</a> : thm
<a name="line91"></a>    val <a href="#ELL_MAP-val">ELL_MAP</a> : thm
<a name="line92"></a>    val <a href="#ELL_MEM-val">ELL_MEM</a> : thm
<a name="line93"></a>    val <a href="#ELL_PRE_LENGTH-val">ELL_PRE_LENGTH</a> : thm
<a name="line94"></a>    val <a href="#ELL_REVERSE-val">ELL_REVERSE</a> : thm
<a name="line95"></a>    val <a href="#ELL_REVERSE_EL-val">ELL_REVERSE_EL</a> : thm
<a name="line96"></a>    val <a href="#ELL_SEG-val">ELL_SEG</a> : thm
<a name="line97"></a>    val <a href="#ELL_SNOC-val">ELL_SNOC</a> : thm
<a name="line98"></a>    val <a href="#ELL_SUC_SNOC-val">ELL_SUC_SNOC</a> : thm
<a name="line99"></a>    val <a href="#ELL_compute-val">ELL_compute</a> : thm
<a name="line100"></a>    val <a href="#EL_APPEND1-val">EL_APPEND1</a> : thm
<a name="line101"></a>    val <a href="#EL_APPEND2-val">EL_APPEND2</a> : thm
<a name="line102"></a>    val <a href="#EL_CONS-val">EL_CONS</a> : thm
<a name="line103"></a>    val <a href="#EL_COUNT_LIST-val">EL_COUNT_LIST</a> : thm
<a name="line104"></a>    val <a href="#EL_DROP-val">EL_DROP</a> : thm
<a name="line105"></a>    val <a href="#EL_ELL-val">EL_ELL</a> : thm
<a name="line106"></a>    val <a href="#EL_FRONT-val">EL_FRONT</a> : thm
<a name="line107"></a>    val <a href="#EL_LENGTH_APPEND-val">EL_LENGTH_APPEND</a> : thm
<a name="line108"></a>    val <a href="#EL_MEM-val">EL_MEM</a> : thm
<a name="line109"></a>    val <a href="#EL_PRE_LENGTH-val">EL_PRE_LENGTH</a> : thm
<a name="line110"></a>    val <a href="#EL_REVERSE_ELL-val">EL_REVERSE_ELL</a> : thm
<a name="line111"></a>    val <a href="#EL_SEG-val">EL_SEG</a> : thm
<a name="line112"></a>    val <a href="#EL_TAKE-val">EL_TAKE</a> : thm
<a name="line113"></a>    val <a href="#EVERY_BUTLASTN-val">EVERY_BUTLASTN</a> : thm
<a name="line114"></a>    val <a href="#EVERY_DROP-val">EVERY_DROP</a> : thm
<a name="line115"></a>    val <a href="#EVERY_FOLDL-val">EVERY_FOLDL</a> : thm
<a name="line116"></a>    val <a href="#EVERY_FOLDL_MAP-val">EVERY_FOLDL_MAP</a> : thm
<a name="line117"></a>    val <a href="#EVERY_FOLDR-val">EVERY_FOLDR</a> : thm
<a name="line118"></a>    val <a href="#EVERY_FOLDR_MAP-val">EVERY_FOLDR_MAP</a> : thm
<a name="line119"></a>    val <a href="#EVERY_LASTN-val">EVERY_LASTN</a> : thm
<a name="line120"></a>    val <a href="#EVERY_REPLICATE-val">EVERY_REPLICATE</a> : thm
<a name="line121"></a>    val <a href="#EVERY_REVERSE-val">EVERY_REVERSE</a> : thm
<a name="line122"></a>    val <a href="#EVERY_SEG-val">EVERY_SEG</a> : thm
<a name="line123"></a>    val <a href="#EVERY_TAKE-val">EVERY_TAKE</a> : thm
<a name="line124"></a>    val <a href="#EXISTS_BUTLASTN-val">EXISTS_BUTLASTN</a> : thm
<a name="line125"></a>    val <a href="#EXISTS_DISJ-val">EXISTS_DISJ</a> : thm
<a name="line126"></a>    val <a href="#EXISTS_DROP-val">EXISTS_DROP</a> : thm
<a name="line127"></a>    val <a href="#EXISTS_FOLDL-val">EXISTS_FOLDL</a> : thm
<a name="line128"></a>    val <a href="#EXISTS_FOLDL_MAP-val">EXISTS_FOLDL_MAP</a> : thm
<a name="line129"></a>    val <a href="#EXISTS_FOLDR-val">EXISTS_FOLDR</a> : thm
<a name="line130"></a>    val <a href="#EXISTS_FOLDR_MAP-val">EXISTS_FOLDR_MAP</a> : thm
<a name="line131"></a>    val <a href="#EXISTS_LASTN-val">EXISTS_LASTN</a> : thm
<a name="line132"></a>    val <a href="#EXISTS_REVERSE-val">EXISTS_REVERSE</a> : thm
<a name="line133"></a>    val <a href="#EXISTS_SEG-val">EXISTS_SEG</a> : thm
<a name="line134"></a>    val <a href="#EXISTS_TAKE-val">EXISTS_TAKE</a> : thm
<a name="line135"></a>    val <a href="#FCOMM_FOLDL_APPEND-val">FCOMM_FOLDL_APPEND</a> : thm
<a name="line136"></a>    val <a href="#FCOMM_FOLDL_FLAT-val">FCOMM_FOLDL_FLAT</a> : thm
<a name="line137"></a>    val <a href="#FCOMM_FOLDR_APPEND-val">FCOMM_FOLDR_APPEND</a> : thm
<a name="line138"></a>    val <a href="#FCOMM_FOLDR_FLAT-val">FCOMM_FOLDR_FLAT</a> : thm
<a name="line139"></a>    val <a href="#FILTER_COMM-val">FILTER_COMM</a> : thm
<a name="line140"></a>    val <a href="#FILTER_EQ-val">FILTER_EQ</a> : thm
<a name="line141"></a>    val <a href="#FILTER_FILTER-val">FILTER_FILTER</a> : thm
<a name="line142"></a>    val <a href="#FILTER_FLAT-val">FILTER_FLAT</a> : thm
<a name="line143"></a>    val <a href="#FILTER_FOLDL-val">FILTER_FOLDL</a> : thm
<a name="line144"></a>    val <a href="#FILTER_FOLDR-val">FILTER_FOLDR</a> : thm
<a name="line145"></a>    val <a href="#FILTER_IDEM-val">FILTER_IDEM</a> : thm
<a name="line146"></a>    val <a href="#FILTER_MAP-val">FILTER_MAP</a> : thm
<a name="line147"></a>    val <a href="#FILTER_SNOC-val">FILTER_SNOC</a> : thm
<a name="line148"></a>    val <a href="#FLAT_APPEND-val">FLAT_APPEND</a> : thm
<a name="line149"></a>    val <a href="#FLAT_FLAT-val">FLAT_FLAT</a> : thm
<a name="line150"></a>    val <a href="#FLAT_FOLDL-val">FLAT_FOLDL</a> : thm
<a name="line151"></a>    val <a href="#FLAT_FOLDR-val">FLAT_FOLDR</a> : thm
<a name="line152"></a>    val <a href="#FLAT_REVERSE-val">FLAT_REVERSE</a> : thm
<a name="line153"></a>    val <a href="#FLAT_SNOC-val">FLAT_SNOC</a> : thm
<a name="line154"></a>    val <a href="#FOLDL_APPEND-val">FOLDL_APPEND</a> : thm
<a name="line155"></a>    val <a href="#FOLDL_FILTER-val">FOLDL_FILTER</a> : thm
<a name="line156"></a>    val <a href="#FOLDL_FOLDR_REVERSE-val">FOLDL_FOLDR_REVERSE</a> : thm
<a name="line157"></a>    val <a href="#FOLDL_MAP-val">FOLDL_MAP</a> : thm
<a name="line158"></a>    val <a href="#FOLDL_MAP2-val">FOLDL_MAP2</a> : thm
<a name="line159"></a>    val <a href="#FOLDL_REVERSE-val">FOLDL_REVERSE</a> : thm
<a name="line160"></a>    val <a href="#FOLDL_SINGLE-val">FOLDL_SINGLE</a> : thm
<a name="line161"></a>    val <a href="#FOLDL_SNOC_NIL-val">FOLDL_SNOC_NIL</a> : thm
<a name="line162"></a>    val <a href="#FOLDR_APPEND-val">FOLDR_APPEND</a> : thm
<a name="line163"></a>    val <a href="#FOLDR_CONS_NIL-val">FOLDR_CONS_NIL</a> : thm
<a name="line164"></a>    val <a href="#FOLDR_FILTER-val">FOLDR_FILTER</a> : thm
<a name="line165"></a>    val <a href="#FOLDR_FILTER_REVERSE-val">FOLDR_FILTER_REVERSE</a> : thm
<a name="line166"></a>    val <a href="#FOLDR_FOLDL-val">FOLDR_FOLDL</a> : thm
<a name="line167"></a>    val <a href="#FOLDR_FOLDL_REVERSE-val">FOLDR_FOLDL_REVERSE</a> : thm
<a name="line168"></a>    val <a href="#FOLDR_MAP-val">FOLDR_MAP</a> : thm
<a name="line169"></a>    val <a href="#FOLDR_MAP_REVERSE-val">FOLDR_MAP_REVERSE</a> : thm
<a name="line170"></a>    val <a href="#FOLDR_REVERSE-val">FOLDR_REVERSE</a> : thm
<a name="line171"></a>    val <a href="#FOLDR_SINGLE-val">FOLDR_SINGLE</a> : thm
<a name="line172"></a>    val <a href="#FOLDR_SNOC-val">FOLDR_SNOC</a> : thm
<a name="line173"></a>    val <a href="#FRONT_APPEND-val">FRONT_APPEND</a> : thm
<a name="line174"></a>    val <a href="#IS_PREFIX-val">IS_PREFIX</a> : thm
<a name="line175"></a>    val <a href="#IS_PREFIX_ANTISYM-val">IS_PREFIX_ANTISYM</a> : thm
<a name="line176"></a>    val <a href="#IS_PREFIX_APPEND-val">IS_PREFIX_APPEND</a> : thm
<a name="line177"></a>    val <a href="#IS_PREFIX_APPEND1-val">IS_PREFIX_APPEND1</a> : thm
<a name="line178"></a>    val <a href="#IS_PREFIX_APPEND2-val">IS_PREFIX_APPEND2</a> : thm
<a name="line179"></a>    val <a href="#IS_PREFIX_APPENDS-val">IS_PREFIX_APPENDS</a> : thm
<a name="line180"></a>    val <a href="#IS_PREFIX_BUTLAST-val">IS_PREFIX_BUTLAST</a> : thm
<a name="line181"></a>    val <a href="#IS_PREFIX_IS_SUBLIST-val">IS_PREFIX_IS_SUBLIST</a> : thm
<a name="line182"></a>    val <a href="#IS_PREFIX_LENGTH-val">IS_PREFIX_LENGTH</a> : thm
<a name="line183"></a>    val <a href="#IS_PREFIX_LENGTH_ANTI-val">IS_PREFIX_LENGTH_ANTI</a> : thm
<a name="line184"></a>    val <a href="#IS_PREFIX_NIL-val">IS_PREFIX_NIL</a> : thm
<a name="line185"></a>    val <a href="#IS_PREFIX_PREFIX-val">IS_PREFIX_PREFIX</a> : thm
<a name="line186"></a>    val <a href="#IS_PREFIX_REFL-val">IS_PREFIX_REFL</a> : thm
<a name="line187"></a>    val <a href="#IS_PREFIX_REVERSE-val">IS_PREFIX_REVERSE</a> : thm
<a name="line188"></a>    val <a href="#IS_PREFIX_SNOC-val">IS_PREFIX_SNOC</a> : thm
<a name="line189"></a>    val <a href="#IS_PREFIX_TRANS-val">IS_PREFIX_TRANS</a> : thm
<a name="line190"></a>    val <a href="#IS_SUBLIST_APPEND-val">IS_SUBLIST_APPEND</a> : thm
<a name="line191"></a>    val <a href="#IS_SUBLIST_REVERSE-val">IS_SUBLIST_REVERSE</a> : thm
<a name="line192"></a>    val <a href="#IS_SUFFIX_APPEND-val">IS_SUFFIX_APPEND</a> : thm
<a name="line193"></a>    val <a href="#IS_SUFFIX_CONS2_E-val">IS_SUFFIX_CONS2_E</a> : thm
<a name="line194"></a>    val <a href="#IS_SUFFIX_IS_SUBLIST-val">IS_SUFFIX_IS_SUBLIST</a> : thm
<a name="line195"></a>    val <a href="#IS_SUFFIX_REFL-val">IS_SUFFIX_REFL</a> : thm
<a name="line196"></a>    val <a href="#IS_SUFFIX_REVERSE-val">IS_SUFFIX_REVERSE</a> : thm
<a name="line197"></a>    val <a href="#IS_SUFFIX_compute-val">IS_SUFFIX_compute</a> : thm
<a name="line198"></a>    val <a href="#LASTN_1-val">LASTN_1</a> : thm
<a name="line199"></a>    val <a href="#LASTN_APPEND1-val">LASTN_APPEND1</a> : thm
<a name="line200"></a>    val <a href="#LASTN_APPEND2-val">LASTN_APPEND2</a> : thm
<a name="line201"></a>    val <a href="#LASTN_BUTLASTN-val">LASTN_BUTLASTN</a> : thm
<a name="line202"></a>    val <a href="#LASTN_CONS-val">LASTN_CONS</a> : thm
<a name="line203"></a>    val <a href="#LASTN_DROP-val">LASTN_DROP</a> : thm
<a name="line204"></a>    val <a href="#LASTN_LASTN-val">LASTN_LASTN</a> : thm
<a name="line205"></a>    val <a href="#LASTN_LENGTH_APPEND-val">LASTN_LENGTH_APPEND</a> : thm
<a name="line206"></a>    val <a href="#LASTN_LENGTH_ID-val">LASTN_LENGTH_ID</a> : thm
<a name="line207"></a>    val <a href="#LASTN_MAP-val">LASTN_MAP</a> : thm
<a name="line208"></a>    val <a href="#LASTN_REVERSE-val">LASTN_REVERSE</a> : thm
<a name="line209"></a>    val <a href="#LASTN_SEG-val">LASTN_SEG</a> : thm
<a name="line210"></a>    val <a href="#LASTN_compute-val">LASTN_compute</a> : thm
<a name="line211"></a>    val <a href="#LAST_LASTN_LAST-val">LAST_LASTN_LAST</a> : thm
<a name="line212"></a>    val <a href="#LENGTH_BUTLASTN-val">LENGTH_BUTLASTN</a> : thm
<a name="line213"></a>    val <a href="#LENGTH_COUNT_LIST-val">LENGTH_COUNT_LIST</a> : thm
<a name="line214"></a>    val <a href="#LENGTH_EQ-val">LENGTH_EQ</a> : thm
<a name="line215"></a>    val <a href="#LENGTH_FILTER_LEQ-val">LENGTH_FILTER_LEQ</a> : thm
<a name="line216"></a>    val <a href="#LENGTH_FLAT-val">LENGTH_FLAT</a> : thm
<a name="line217"></a>    val <a href="#LENGTH_FOLDL-val">LENGTH_FOLDL</a> : thm
<a name="line218"></a>    val <a href="#LENGTH_FOLDR-val">LENGTH_FOLDR</a> : thm
<a name="line219"></a>    val <a href="#LENGTH_FRONT-val">LENGTH_FRONT</a> : thm
<a name="line220"></a>    val <a href="#LENGTH_LASTN-val">LENGTH_LASTN</a> : thm
<a name="line221"></a>    val <a href="#LENGTH_MAP2-val">LENGTH_MAP2</a> : thm
<a name="line222"></a>    val <a href="#LENGTH_NOT_NULL-val">LENGTH_NOT_NULL</a> : thm
<a name="line223"></a>    val <a href="#LENGTH_REPLICATE-val">LENGTH_REPLICATE</a> : thm
<a name="line224"></a>    val <a href="#LENGTH_SCANL-val">LENGTH_SCANL</a> : thm
<a name="line225"></a>    val <a href="#LENGTH_SCANR-val">LENGTH_SCANR</a> : thm
<a name="line226"></a>    val <a href="#LENGTH_SEG-val">LENGTH_SEG</a> : thm
<a name="line227"></a>    val <a href="#LENGTH_UNZIP_FST-val">LENGTH_UNZIP_FST</a> : thm
<a name="line228"></a>    val <a href="#LENGTH_UNZIP_SND-val">LENGTH_UNZIP_SND</a> : thm
<a name="line229"></a>    val <a href="#LIST_ELEM_COUNT_MEM-val">LIST_ELEM_COUNT_MEM</a> : thm
<a name="line230"></a>    val <a href="#LIST_ELEM_COUNT_THM-val">LIST_ELEM_COUNT_THM</a> : thm
<a name="line231"></a>    val <a href="#MAP_FILTER-val">MAP_FILTER</a> : thm
<a name="line232"></a>    val <a href="#MAP_FLAT-val">MAP_FLAT</a> : thm
<a name="line233"></a>    val <a href="#MAP_FOLDL-val">MAP_FOLDL</a> : thm
<a name="line234"></a>    val <a href="#MAP_FOLDR-val">MAP_FOLDR</a> : thm
<a name="line235"></a>    val <a href="#MAP_REVERSE-val">MAP_REVERSE</a> : thm
<a name="line236"></a>    val <a href="#MEM_BUTLASTN-val">MEM_BUTLASTN</a> : thm
<a name="line237"></a>    val <a href="#MEM_COUNT_LIST-val">MEM_COUNT_LIST</a> : thm
<a name="line238"></a>    val <a href="#MEM_DROP-val">MEM_DROP</a> : thm
<a name="line239"></a>    val <a href="#MEM_EXISTS-val">MEM_EXISTS</a> : thm
<a name="line240"></a>    val <a href="#MEM_FOLDL-val">MEM_FOLDL</a> : thm
<a name="line241"></a>    val <a href="#MEM_FOLDL_MAP-val">MEM_FOLDL_MAP</a> : thm
<a name="line242"></a>    val <a href="#MEM_FOLDR-val">MEM_FOLDR</a> : thm
<a name="line243"></a>    val <a href="#MEM_FOLDR_MAP-val">MEM_FOLDR_MAP</a> : thm
<a name="line244"></a>    val <a href="#MEM_FRONT-val">MEM_FRONT</a> : thm
<a name="line245"></a>    val <a href="#MEM_LAST-val">MEM_LAST</a> : thm
<a name="line246"></a>    val <a href="#MEM_LASTN-val">MEM_LASTN</a> : thm
<a name="line247"></a>    val <a href="#MEM_LAST_FRONT-val">MEM_LAST_FRONT</a> : thm
<a name="line248"></a>    val <a href="#MEM_REPLICATE-val">MEM_REPLICATE</a> : thm
<a name="line249"></a>    val <a href="#MEM_SEG-val">MEM_SEG</a> : thm
<a name="line250"></a>    val <a href="#MEM_TAKE-val">MEM_TAKE</a> : thm
<a name="line251"></a>    val <a href="#MONOID_APPEND_NIL-val">MONOID_APPEND_NIL</a> : thm
<a name="line252"></a>    val <a href="#NOT_NIL_SNOC-val">NOT_NIL_SNOC</a> : thm
<a name="line253"></a>    val <a href="#NOT_NULL_SNOC-val">NOT_NULL_SNOC</a> : thm
<a name="line254"></a>    val <a href="#NOT_SNOC_NIL-val">NOT_SNOC_NIL</a> : thm
<a name="line255"></a>    val <a href="#NULL_FOLDL-val">NULL_FOLDL</a> : thm
<a name="line256"></a>    val <a href="#NULL_FOLDR-val">NULL_FOLDR</a> : thm
<a name="line257"></a>    val <a href="#OR_EL_FOLDL-val">OR_EL_FOLDL</a> : thm
<a name="line258"></a>    val <a href="#OR_EL_FOLDR-val">OR_EL_FOLDR</a> : thm
<a name="line259"></a>    val <a href="#PREFIX-val">PREFIX</a> : thm
<a name="line260"></a>    val <a href="#PREFIX_FOLDR-val">PREFIX_FOLDR</a> : thm
<a name="line261"></a>    val <a href="#REPLACE_ELEMENT_SEM-val">REPLACE_ELEMENT_SEM</a> : thm
<a name="line262"></a>    val <a href="#REPLACE_ELEMENT_compute-val">REPLACE_ELEMENT_compute</a> : thm
<a name="line263"></a>    val <a href="#REPLICATE_compute-val">REPLICATE_compute</a> : thm
<a name="line264"></a>    val <a href="#REVERSE_FLAT-val">REVERSE_FLAT</a> : thm
<a name="line265"></a>    val <a href="#REVERSE_FOLDL-val">REVERSE_FOLDL</a> : thm
<a name="line266"></a>    val <a href="#REVERSE_FOLDR-val">REVERSE_FOLDR</a> : thm
<a name="line267"></a>    val <a href="#SEG_0_SNOC-val">SEG_0_SNOC</a> : thm
<a name="line268"></a>    val <a href="#SEG_APPEND-val">SEG_APPEND</a> : thm
<a name="line269"></a>    val <a href="#SEG_APPEND1-val">SEG_APPEND1</a> : thm
<a name="line270"></a>    val <a href="#SEG_APPEND2-val">SEG_APPEND2</a> : thm
<a name="line271"></a>    val <a href="#SEG_LASTN_BUTLASTN-val">SEG_LASTN_BUTLASTN</a> : thm
<a name="line272"></a>    val <a href="#SEG_LENGTH_ID-val">SEG_LENGTH_ID</a> : thm
<a name="line273"></a>    val <a href="#SEG_LENGTH_SNOC-val">SEG_LENGTH_SNOC</a> : thm
<a name="line274"></a>    val <a href="#SEG_REVERSE-val">SEG_REVERSE</a> : thm
<a name="line275"></a>    val <a href="#SEG_SEG-val">SEG_SEG</a> : thm
<a name="line276"></a>    val <a href="#SEG_SNOC-val">SEG_SNOC</a> : thm
<a name="line277"></a>    val <a href="#SEG_SUC_CONS-val">SEG_SUC_CONS</a> : thm
<a name="line278"></a>    val <a href="#SEG_TAKE_BUTFISTN-val">SEG_TAKE_BUTFISTN</a> : thm
<a name="line279"></a>    val <a href="#SEG_compute-val">SEG_compute</a> : thm
<a name="line280"></a>    val <a href="#SNOC_EL_TAKE-val">SNOC_EL_TAKE</a> : thm
<a name="line281"></a>    val <a href="#SNOC_EQ_LENGTH_EQ-val">SNOC_EQ_LENGTH_EQ</a> : thm
<a name="line282"></a>    val <a href="#SNOC_FOLDR-val">SNOC_FOLDR</a> : thm
<a name="line283"></a>    val <a href="#SNOC_REVERSE_CONS-val">SNOC_REVERSE_CONS</a> : thm
<a name="line284"></a>    val <a href="#SPLITP_EVERY-val">SPLITP_EVERY</a> : thm
<a name="line285"></a>    val <a href="#SPLITP_compute-val">SPLITP_compute</a> : thm
<a name="line286"></a>    val <a href="#SUM_FLAT-val">SUM_FLAT</a> : thm
<a name="line287"></a>    val <a href="#SUM_FOLDL-val">SUM_FOLDL</a> : thm
<a name="line288"></a>    val <a href="#SUM_FOLDR-val">SUM_FOLDR</a> : thm
<a name="line289"></a>    val <a href="#SUM_REVERSE-val">SUM_REVERSE</a> : thm
<a name="line290"></a>    val <a href="#TAKE-val">TAKE</a> : thm
<a name="line291"></a>    val <a href="#TAKE_APPEND1-val">TAKE_APPEND1</a> : thm
<a name="line292"></a>    val <a href="#TAKE_APPEND2-val">TAKE_APPEND2</a> : thm
<a name="line293"></a>    val <a href="#TAKE_BUTLASTN-val">TAKE_BUTLASTN</a> : thm
<a name="line294"></a>    val <a href="#TAKE_LENGTH_APPEND-val">TAKE_LENGTH_APPEND</a> : thm
<a name="line295"></a>    val <a href="#TAKE_REVERSE-val">TAKE_REVERSE</a> : thm
<a name="line296"></a>    val <a href="#TAKE_SEG-val">TAKE_SEG</a> : thm
<a name="line297"></a>    val <a href="#TAKE_SNOC-val">TAKE_SNOC</a> : thm
<a name="line298"></a>    val <a href="#TAKE_TAKE-val">TAKE_TAKE</a> : thm
<a name="line299"></a>    val <a href="#TL_SNOC-val">TL_SNOC</a> : thm
<a name="line300"></a>    val <a href="#UNZIP_SNOC-val">UNZIP_SNOC</a> : thm
<a name="line301"></a>    val <a href="#ZIP_APPEND-val">ZIP_APPEND</a> : thm
<a name="line302"></a>    val <a href="#ZIP_SNOC-val">ZIP_SNOC</a> : thm
<a name="line303"></a>    val <a href="#ZIP_TAKE-val">ZIP_TAKE</a> : thm
<a name="line304"></a>    val <a href="#ZIP_TAKE_LEQ-val">ZIP_TAKE_LEQ</a> : thm
<a name="line305"></a>
<a name="line306"></a>  val rich_list_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line307"></a>
<a name="line308"></a>  (* Aliases for legacy theorem names *)
<a name="line309"></a>
<a name="line310"></a>  val ALL_DISTINCT_SNOC : thm
<a name="line311"></a>  val ALL_EL : thm
<a name="line312"></a>  val ALL_EL_APPEND : thm
<a name="line313"></a>  val ALL_EL_BUTFIRSTN : thm
<a name="line314"></a>  val ALL_EL_BUTLASTN : thm
<a name="line315"></a>  val ALL_EL_CONJ : thm
<a name="line316"></a>  val ALL_EL_FIRSTN : thm
<a name="line317"></a>  val ALL_EL_FOLDL : thm
<a name="line318"></a>  val ALL_EL_FOLDL_MAP : thm
<a name="line319"></a>  val ALL_EL_FOLDR : thm
<a name="line320"></a>  val ALL_EL_FOLDR_MAP : thm
<a name="line321"></a>  val ALL_EL_LASTN : thm
<a name="line322"></a>  val ALL_EL_REPLICATE : thm
<a name="line323"></a>  val ALL_EL_REVERSE : thm
<a name="line324"></a>  val ALL_EL_SEG : thm
<a name="line325"></a>  val ALL_EL_SNOC : thm
<a name="line326"></a>  val APPEND : thm
<a name="line327"></a>  val APPEND_11_LENGTH : thm
<a name="line328"></a>  val APPEND_ASSOC : thm
<a name="line329"></a>  val APPEND_BUTLASTN_BUTFIRSTN : thm
<a name="line330"></a>  val APPEND_BUTLAST_LAST : thm
<a name="line331"></a>  val APPEND_FIRSTN_BUTFIRSTN : thm
<a name="line332"></a>  val APPEND_FIRSTN_LASTN : thm
<a name="line333"></a>  val APPEND_LENGTH_EQ : thm
<a name="line334"></a>  val APPEND_SNOC : thm
<a name="line335"></a>  val BUTFIRSTN : thm
<a name="line336"></a>  val BUTFIRSTN_APPEND1 : thm
<a name="line337"></a>  val BUTFIRSTN_APPEND2 : thm
<a name="line338"></a>  val BUTFIRSTN_BUTFIRSTN : thm
<a name="line339"></a>  val BUTFIRSTN_CONS_EL : thm
<a name="line340"></a>  val BUTFIRSTN_LASTN : thm
<a name="line341"></a>  val BUTFIRSTN_LENGTH_APPEND : thm
<a name="line342"></a>  val BUTFIRSTN_LENGTH_NIL : thm
<a name="line343"></a>  val BUTFIRSTN_REVERSE : thm
<a name="line344"></a>  val BUTFIRSTN_SEG : thm
<a name="line345"></a>  val BUTFIRSTN_SNOC : thm
<a name="line346"></a>  val BUTLAST : thm
<a name="line347"></a>  val BUTLASTN_BUTLAST : thm
<a name="line348"></a>  val BUTLASTN_FIRSTN : thm
<a name="line349"></a>  val BUTLASTN_SUC_BUTLAST : thm
<a name="line350"></a>  val BUTLAST_CONS : thm
<a name="line351"></a>  val CONS : thm
<a name="line352"></a>  val CONS_11 : thm
<a name="line353"></a>  val EL : thm
<a name="line354"></a>  val ELL_IS_EL : thm
<a name="line355"></a>  val EL_BUTFIRSTN : thm
<a name="line356"></a>  val EL_FIRSTN : thm
<a name="line357"></a>  val EL_GENLIST : thm
<a name="line358"></a>  val EL_IS_EL : thm
<a name="line359"></a>  val EL_LENGTH_SNOC : thm
<a name="line360"></a>  val EL_MAP : thm
<a name="line361"></a>  val EL_REVERSE : thm
<a name="line362"></a>  val EL_SNOC : thm
<a name="line363"></a>  val EQ_LIST : thm
<a name="line364"></a>  val EVERY_GENLIST : thm
<a name="line365"></a>  val EXISTS_GENLIST : thm
<a name="line366"></a>  val FILTER : thm
<a name="line367"></a>  val FILTER_APPEND : thm
<a name="line368"></a>  val FILTER_REVERSE : thm
<a name="line369"></a>  val FIRSTN : thm
<a name="line370"></a>  val FIRSTN_APPEND1 : thm
<a name="line371"></a>  val FIRSTN_APPEND2 : thm
<a name="line372"></a>  val FIRSTN_BUTLASTN : thm
<a name="line373"></a>  val FIRSTN_FIRSTN : thm
<a name="line374"></a>  val FIRSTN_LENGTH_APPEND : thm
<a name="line375"></a>  val FIRSTN_LENGTH_ID : thm
<a name="line376"></a>  val FIRSTN_REVERSE : thm
<a name="line377"></a>  val FIRSTN_SEG : thm
<a name="line378"></a>  val FIRSTN_SNOC : thm
<a name="line379"></a>  val FLAT : thm
<a name="line380"></a>  val FOLDL : thm
<a name="line381"></a>  val FOLDL_SNOC : thm
<a name="line382"></a>  val FOLDR : thm
<a name="line383"></a>  val GENLIST : thm
<a name="line384"></a>  val GENLIST_APPEND : thm
<a name="line385"></a>  val GENLIST_CONS : thm
<a name="line386"></a>  val GENLIST_FUN_EQ : thm
<a name="line387"></a>  val HD : thm
<a name="line388"></a>  val HD_GENLIST : thm
<a name="line389"></a>  val IS_EL : thm
<a name="line390"></a>  val IS_EL_APPEND : thm
<a name="line391"></a>  val IS_EL_BUTFIRSTN : thm
<a name="line392"></a>  val IS_EL_BUTLASTN : thm
<a name="line393"></a>  val IS_EL_DEF : thm
<a name="line394"></a>  val IS_EL_FILTER : thm
<a name="line395"></a>  val IS_EL_FIRSTN : thm
<a name="line396"></a>  val IS_EL_FOLDL : thm
<a name="line397"></a>  val IS_EL_FOLDL_MAP : thm
<a name="line398"></a>  val IS_EL_FOLDR : thm
<a name="line399"></a>  val IS_EL_FOLDR_MAP : thm
<a name="line400"></a>  val IS_EL_LASTN : thm
<a name="line401"></a>  val IS_EL_REPLICATE : thm
<a name="line402"></a>  val IS_EL_REVERSE : thm
<a name="line403"></a>  val IS_EL_SEG : thm
<a name="line404"></a>  val IS_EL_SNOC : thm
<a name="line405"></a>  val IS_EL_SOME_EL : thm
<a name="line406"></a>  val LAST : thm
<a name="line407"></a>  val LASTN_BUTFIRSTN : thm
<a name="line408"></a>  val LAST_APPEND : thm
<a name="line409"></a>  val LAST_CONS : thm
<a name="line410"></a>  val LENGTH : thm
<a name="line411"></a>  val LENGTH_APPEND : thm
<a name="line412"></a>  val LENGTH_BUTFIRSTN : thm
<a name="line413"></a>  val LENGTH_BUTLAST : thm
<a name="line414"></a>  val LENGTH_CONS : thm
<a name="line415"></a>  val LENGTH_EQ_NIL : thm
<a name="line416"></a>  val LENGTH_FIRSTN : thm
<a name="line417"></a>  val LENGTH_GENLIST : thm
<a name="line418"></a>  val LENGTH_MAP : thm
<a name="line419"></a>  val LENGTH_NIL : thm
<a name="line420"></a>  val LENGTH_REVERSE : thm
<a name="line421"></a>  val LENGTH_SNOC : thm
<a name="line422"></a>  val LENGTH_ZIP : thm
<a name="line423"></a>  val LIST_NOT_EQ : thm
<a name="line424"></a>  val MAP : thm
<a name="line425"></a>  val MAP2 : thm
<a name="line426"></a>  val MAP2_ZIP : thm
<a name="line427"></a>  val MAP_APPEND : thm
<a name="line428"></a>  val MAP_EQ_f : thm
<a name="line429"></a>  val MAP_GENLIST : thm
<a name="line430"></a>  val MAP_MAP_o : thm
<a name="line431"></a>  val MAP_SNOC : thm
<a name="line432"></a>  val MAP_o : thm
<a name="line433"></a>  val NOT_ALL_EL_SOME_EL : thm
<a name="line434"></a>  val NOT_CONS_NIL : thm
<a name="line435"></a>  val NOT_EQ_LIST : thm
<a name="line436"></a>  val NOT_NIL_CONS : thm
<a name="line437"></a>  val NOT_SOME_EL_ALL_EL : thm
<a name="line438"></a>  val NULL : thm
<a name="line439"></a>  val NULL_DEF : thm
<a name="line440"></a>  val NULL_EQ_NIL : thm
<a name="line441"></a>  val REVERSE : thm
<a name="line442"></a>  val REVERSE_APPEND : thm
<a name="line443"></a>  val REVERSE_EQ_NIL : thm
<a name="line444"></a>  val REVERSE_REVERSE : thm
<a name="line445"></a>  val REVERSE_SNOC : thm
<a name="line446"></a>  val SNOC : thm
<a name="line447"></a>  val SNOC_11 : thm
<a name="line448"></a>  val SNOC_APPEND : thm
<a name="line449"></a>  val SNOC_Axiom : thm
<a name="line450"></a>  val SNOC_CASES : thm
<a name="line451"></a>  val SNOC_EL_FIRSTN : thm
<a name="line452"></a>  val SNOC_INDUCT : thm
<a name="line453"></a>  val SOME_EL : thm
<a name="line454"></a>  val SOME_EL_APPEND : thm
<a name="line455"></a>  val SOME_EL_BUTFIRSTN : thm
<a name="line456"></a>  val SOME_EL_BUTLASTN : thm
<a name="line457"></a>  val SOME_EL_DISJ : thm
<a name="line458"></a>  val SOME_EL_FIRSTN : thm
<a name="line459"></a>  val SOME_EL_FOLDL : thm
<a name="line460"></a>  val SOME_EL_FOLDL_MAP : thm
<a name="line461"></a>  val SOME_EL_FOLDR : thm
<a name="line462"></a>  val SOME_EL_FOLDR_MAP : thm
<a name="line463"></a>  val SOME_EL_LASTN : thm
<a name="line464"></a>  val SOME_EL_MAP : thm
<a name="line465"></a>  val SOME_EL_REVERSE : thm
<a name="line466"></a>  val SOME_EL_SEG : thm
<a name="line467"></a>  val SOME_EL_SNOC : thm
<a name="line468"></a>  val SUM : thm
<a name="line469"></a>  val SUM_APPEND : thm
<a name="line470"></a>  val SUM_SNOC : thm
<a name="line471"></a>  val TL : thm
<a name="line472"></a>  val TL_GENLIST : thm
<a name="line473"></a>  val UNZIP : thm
<a name="line474"></a>  val UNZIP_ZIP : thm
<a name="line475"></a>  val ZIP : thm
<a name="line476"></a>  val ZIP_FIRSTN : thm
<a name="line477"></a>  val ZIP_FIRSTN_LEQ : thm
<a name="line478"></a>  val ZIP_GENLIST : thm
<a name="line479"></a>  val ZIP_UNZIP : thm
<a name="line480"></a>
<a name="line481"></a>(*
   [list] Parent theory of "rich_list"

   [<a name="AND_EL_DEF-val"><b>AND_EL_DEF</b></a>]  Definition

      |- AND_EL = EVERY I

   [<a name="BUTLASTN-val"><b>BUTLASTN</b></a>]  Definition

      |- (∀l. BUTLASTN 0 l = l) ∧
         ∀n x l. BUTLASTN (SUC n) (SNOC x l) = BUTLASTN n l

   [<a name="COUNT_LIST_AUX_def-val"><b>COUNT_LIST_AUX_def</b></a>]  Definition

      |- (∀l. COUNT_LIST_AUX 0 l = l) ∧
         ∀n l. COUNT_LIST_AUX (SUC n) l = COUNT_LIST_AUX n (n::l)

   [<a name="COUNT_LIST_def-val"><b>COUNT_LIST_def</b></a>]  Definition

      |- (COUNT_LIST 0 = []) ∧
         ∀n. COUNT_LIST (SUC n) = 0::MAP SUC (COUNT_LIST n)

   [<a name="ELL-val"><b>ELL</b></a>]  Definition

      |- (∀l. ELL 0 l = LAST l) ∧ ∀n l. ELL (SUC n) l = ELL n (FRONT l)

   [<a name="IS_SUBLIST-val"><b>IS_SUBLIST</b></a>]  Definition

      |- (∀l. IS_SUBLIST l [] ⇔ T) ∧ (∀x l. IS_SUBLIST [] (x::l) ⇔ F) ∧
         ∀x1 l1 x2 l2.
           IS_SUBLIST (x1::l1) (x2::l2) ⇔
           (x1 = x2) ∧ l2 ≼ l1 ∨ IS_SUBLIST l1 (x2::l2)

   [<a name="IS_SUFFIX-val"><b>IS_SUFFIX</b></a>]  Definition

      |- (∀l. IS_SUFFIX l [] ⇔ T) ∧ (∀x l. IS_SUFFIX [] (SNOC x l) ⇔ F) ∧
         ∀x1 l1 x2 l2.
           IS_SUFFIX (SNOC x1 l1) (SNOC x2 l2) ⇔
           (x1 = x2) ∧ IS_SUFFIX l1 l2

   [<a name="LASTN-val"><b>LASTN</b></a>]  Definition

      |- (∀l. LASTN 0 l = []) ∧
         ∀n x l. LASTN (SUC n) (SNOC x l) = SNOC x (LASTN n l)

   [<a name="LIST_ELEM_COUNT_DEF-val"><b>LIST_ELEM_COUNT_DEF</b></a>]  Definition

      |- ∀e l. LIST_ELEM_COUNT e l = LENGTH (FILTER (λx. x = e) l)

   [<a name="OR_EL_DEF-val"><b>OR_EL_DEF</b></a>]  Definition

      |- OR_EL = EXISTS I

   [<a name="PREFIX_DEF-val"><b>PREFIX_DEF</b></a>]  Definition

      |- ∀P l. PREFIX P l = FST (SPLITP ($~ o P) l)

   [<a name="REPLACE_ELEMENT_DEF-val"><b>REPLACE_ELEMENT_DEF</b></a>]  Definition

      |- (∀e n. REPLACE_ELEMENT e n [] = []) ∧
         (∀e x l. REPLACE_ELEMENT e 0 (x::l) = e::l) ∧
         ∀e n x l.
           REPLACE_ELEMENT e (SUC n) (x::l) = x::REPLACE_ELEMENT e n l

   [<a name="REPLICATE-val"><b>REPLICATE</b></a>]  Definition

      |- (∀x. REPLICATE 0 x = []) ∧
         ∀n x. REPLICATE (SUC n) x = x::REPLICATE n x

   [<a name="SCANL-val"><b>SCANL</b></a>]  Definition

      |- (∀f e. SCANL f e [] = [e]) ∧
         ∀f e x l. SCANL f e (x::l) = e::SCANL f (f e x) l

   [<a name="SCANR-val"><b>SCANR</b></a>]  Definition

      |- (∀f e. SCANR f e [] = [e]) ∧
         ∀f e x l. SCANR f e (x::l) = f x (HD (SCANR f e l))::SCANR f e l

   [<a name="SEG-val"><b>SEG</b></a>]  Definition

      |- (∀k l. SEG 0 k l = []) ∧
         (∀m x l. SEG (SUC m) 0 (x::l) = x::SEG m 0 l) ∧
         ∀m k x l. SEG (SUC m) (SUC k) (x::l) = SEG (SUC m) k l

   [<a name="SPLITP-val"><b>SPLITP</b></a>]  Definition

      |- (∀P. SPLITP P [] = ([],[])) ∧
         ∀P x l.
           SPLITP P (x::l) =
           if P x then
             ([],x::l)
           else
             (x::FST (SPLITP P l),SND (SPLITP P l))

   [<a name="SPLITP_AUX_def-val"><b>SPLITP_AUX_def</b></a>]  Definition

      |- (∀acc P. SPLITP_AUX acc P [] = (acc,[])) ∧
         ∀acc P h t.
           SPLITP_AUX acc P (h::t) =
           if P h then (acc,h::t) else SPLITP_AUX (acc ++ [h]) P t

   [<a name="SUFFIX_DEF-val"><b>SUFFIX_DEF</b></a>]  Definition

      |- ∀P l.
           SUFFIX P l = FOLDL (λl' x. if P x then SNOC x l' else []) [] l

   [<a name="UNZIP_FST_DEF-val"><b>UNZIP_FST_DEF</b></a>]  Definition

      |- ∀l. UNZIP_FST l = FST (UNZIP l)

   [<a name="UNZIP_SND_DEF-val"><b>UNZIP_SND_DEF</b></a>]  Definition

      |- ∀l. UNZIP_SND l = SND (UNZIP l)

   [<a name="ALL_EL_MAP-val"><b>ALL_EL_MAP</b></a>]  Theorem

      |- ∀P f l. EVERY P (MAP f l) ⇔ EVERY (P o f) l

   [<a name="AND_EL_FOLDL-val"><b>AND_EL_FOLDL</b></a>]  Theorem

      |- ∀l. AND_EL l ⇔ FOLDL $/\ T l

   [<a name="AND_EL_FOLDR-val"><b>AND_EL_FOLDR</b></a>]  Theorem

      |- ∀l. AND_EL l ⇔ FOLDR $/\ T l

   [<a name="APPEND_ASSOC_CONS-val"><b>APPEND_ASSOC_CONS</b></a>]  Theorem

      |- ∀l1 h l2 l3. l1 ++ h::l2 ++ l3 = l1 ++ h::(l2 ++ l3)

   [<a name="APPEND_BUTLASTN_DROP-val"><b>APPEND_BUTLASTN_DROP</b></a>]  Theorem

      |- ∀m n l. (m + n = LENGTH l) ⇒ (BUTLASTN m l ++ DROP n l = l)

   [<a name="APPEND_BUTLASTN_LASTN-val"><b>APPEND_BUTLASTN_LASTN</b></a>]  Theorem

      |- ∀n l. n ≤ LENGTH l ⇒ (BUTLASTN n l ++ LASTN n l = l)

   [<a name="APPEND_FOLDL-val"><b>APPEND_FOLDL</b></a>]  Theorem

      |- ∀l1 l2. l1 ++ l2 = FOLDL (λl' x. SNOC x l') l1 l2

   [<a name="APPEND_FOLDR-val"><b>APPEND_FOLDR</b></a>]  Theorem

      |- ∀l1 l2. l1 ++ l2 = FOLDR CONS l2 l1

   [<a name="APPEND_NIL-val"><b>APPEND_NIL</b></a>]  Theorem

      |- (∀l. l ++ [] = l) ∧ ∀l. [] ++ l = l

   [<a name="APPEND_SNOC1-val"><b>APPEND_SNOC1</b></a>]  Theorem

      |- ∀l1 x l2. SNOC x l1 ++ l2 = l1 ++ x::l2

   [<a name="APPEND_TAKE_LASTN-val"><b>APPEND_TAKE_LASTN</b></a>]  Theorem

      |- ∀m n l. (m + n = LENGTH l) ⇒ (TAKE n l ++ LASTN m l = l)

   [<a name="ASSOC_APPEND-val"><b>ASSOC_APPEND</b></a>]  Theorem

      |- ASSOC $++

   [<a name="ASSOC_FOLDL_FLAT-val"><b>ASSOC_FOLDL_FLAT</b></a>]  Theorem

      |- ∀f.
           ASSOC f ⇒
           ∀e.
             RIGHT_ID f e ⇒
             ∀l. FOLDL f e (FLAT l) = FOLDL f e (MAP (FOLDL f e) l)

   [<a name="ASSOC_FOLDR_FLAT-val"><b>ASSOC_FOLDR_FLAT</b></a>]  Theorem

      |- ∀f.
           ASSOC f ⇒
           ∀e.
             LEFT_ID f e ⇒
             ∀l. FOLDR f e (FLAT l) = FOLDR f e (MAP (FOLDR f e) l)

   [<a name="BUTLASTN_1-val"><b>BUTLASTN_1</b></a>]  Theorem

      |- ∀l. l ≠ [] ⇒ (BUTLASTN 1 l = FRONT l)

   [<a name="BUTLASTN_APPEND1-val"><b>BUTLASTN_APPEND1</b></a>]  Theorem

      |- ∀l2 n.
           LENGTH l2 ≤ n ⇒
           ∀l1. BUTLASTN n (l1 ++ l2) = BUTLASTN (n − LENGTH l2) l1

   [<a name="BUTLASTN_APPEND2-val"><b>BUTLASTN_APPEND2</b></a>]  Theorem

      |- ∀n l1 l2.
           n ≤ LENGTH l2 ⇒ (BUTLASTN n (l1 ++ l2) = l1 ++ BUTLASTN n l2)

   [<a name="BUTLASTN_BUTLASTN-val"><b>BUTLASTN_BUTLASTN</b></a>]  Theorem

      |- ∀m n l.
           n + m ≤ LENGTH l ⇒
           (BUTLASTN n (BUTLASTN m l) = BUTLASTN (n + m) l)

   [<a name="BUTLASTN_CONS-val"><b>BUTLASTN_CONS</b></a>]  Theorem

      |- ∀n l. n ≤ LENGTH l ⇒ ∀x. BUTLASTN n (x::l) = x::BUTLASTN n l

   [<a name="BUTLASTN_FRONT-val"><b>BUTLASTN_FRONT</b></a>]  Theorem

      |- ∀n l. n &lt; LENGTH l ⇒ (BUTLASTN n (FRONT l) = FRONT (BUTLASTN n l))

   [<a name="BUTLASTN_LASTN-val"><b>BUTLASTN_LASTN</b></a>]  Theorem

      |- ∀m n l.
           m ≤ n ∧ n ≤ LENGTH l ⇒
           (BUTLASTN m (LASTN n l) = LASTN (n − m) (BUTLASTN m l))

   [<a name="BUTLASTN_LASTN_NIL-val"><b>BUTLASTN_LASTN_NIL</b></a>]  Theorem

      |- ∀n l. n ≤ LENGTH l ⇒ (BUTLASTN n (LASTN n l) = [])

   [<a name="BUTLASTN_LENGTH_APPEND-val"><b>BUTLASTN_LENGTH_APPEND</b></a>]  Theorem

      |- ∀l2 l1. BUTLASTN (LENGTH l2) (l1 ++ l2) = l1

   [<a name="BUTLASTN_LENGTH_CONS-val"><b>BUTLASTN_LENGTH_CONS</b></a>]  Theorem

      |- ∀l x. BUTLASTN (LENGTH l) (x::l) = [x]

   [<a name="BUTLASTN_LENGTH_NIL-val"><b>BUTLASTN_LENGTH_NIL</b></a>]  Theorem

      |- ∀l. BUTLASTN (LENGTH l) l = []

   [<a name="BUTLASTN_MAP-val"><b>BUTLASTN_MAP</b></a>]  Theorem

      |- ∀n l.
           n ≤ LENGTH l ⇒ ∀f. BUTLASTN n (MAP f l) = MAP f (BUTLASTN n l)

   [<a name="BUTLASTN_REVERSE-val"><b>BUTLASTN_REVERSE</b></a>]  Theorem

      |- ∀n l. n ≤ LENGTH l ⇒ (BUTLASTN n (REVERSE l) = REVERSE (DROP n l))

   [<a name="BUTLASTN_SEG-val"><b>BUTLASTN_SEG</b></a>]  Theorem

      |- ∀n l. n ≤ LENGTH l ⇒ (BUTLASTN n l = SEG (LENGTH l − n) 0 l)

   [<a name="BUTLASTN_SUC_FRONT-val"><b>BUTLASTN_SUC_FRONT</b></a>]  Theorem

      |- ∀n l. n &lt; LENGTH l ⇒ (BUTLASTN (SUC n) l = BUTLASTN n (FRONT l))

   [<a name="BUTLASTN_TAKE-val"><b>BUTLASTN_TAKE</b></a>]  Theorem

      |- ∀n l. n ≤ LENGTH l ⇒ (BUTLASTN n l = TAKE (LENGTH l − n) l)

   [<a name="BUTLASTN_compute-val"><b>BUTLASTN_compute</b></a>]  Theorem

      |- ∀n l.
           BUTLASTN n l =
           (let m = LENGTH l
            in
              if n ≤ m then
                TAKE (m − n) l
              else
                FAIL BUTLASTN longer than list n l)

   [<a name="COMM_ASSOC_FOLDL_REVERSE-val"><b>COMM_ASSOC_FOLDL_REVERSE</b></a>]  Theorem

      |- ∀f. COMM f ⇒ ASSOC f ⇒ ∀e l. FOLDL f e (REVERSE l) = FOLDL f e l

   [<a name="COMM_ASSOC_FOLDR_REVERSE-val"><b>COMM_ASSOC_FOLDR_REVERSE</b></a>]  Theorem

      |- ∀f. COMM f ⇒ ASSOC f ⇒ ∀e l. FOLDR f e (REVERSE l) = FOLDR f e l

   [<a name="COMM_MONOID_FOLDL-val"><b>COMM_MONOID_FOLDL</b></a>]  Theorem

      |- ∀f.
           COMM f ⇒
           ∀e'. MONOID f e' ⇒ ∀e l. FOLDL f e l = f e (FOLDL f e' l)

   [<a name="COMM_MONOID_FOLDR-val"><b>COMM_MONOID_FOLDR</b></a>]  Theorem

      |- ∀f.
           COMM f ⇒
           ∀e'. MONOID f e' ⇒ ∀e l. FOLDR f e l = f e (FOLDR f e' l)

   [<a name="CONS_APPEND-val"><b>CONS_APPEND</b></a>]  Theorem

      |- ∀x l. x::l = [x] ++ l

   [<a name="COUNT_LIST_ADD-val"><b>COUNT_LIST_ADD</b></a>]  Theorem

      |- ∀n m.
           COUNT_LIST (n + m) =
           COUNT_LIST n ++ MAP (λn'. n' + n) (COUNT_LIST m)

   [<a name="COUNT_LIST_AUX_def_compute-val"><b>COUNT_LIST_AUX_def_compute</b></a>]  Theorem

      |- (∀l. COUNT_LIST_AUX 0 l = l) ∧
         (∀n l.
            COUNT_LIST_AUX (NUMERAL (BIT1 n)) l =
            COUNT_LIST_AUX (NUMERAL (BIT1 n) − 1)
              (NUMERAL (BIT1 n) − 1::l)) ∧
         ∀n l.
           COUNT_LIST_AUX (NUMERAL (BIT2 n)) l =
           COUNT_LIST_AUX (NUMERAL (BIT1 n)) (NUMERAL (BIT1 n)::l)

   [<a name="COUNT_LIST_COUNT-val"><b>COUNT_LIST_COUNT</b></a>]  Theorem

      |- ∀n. set (COUNT_LIST n) = count n

   [<a name="COUNT_LIST_GENLIST-val"><b>COUNT_LIST_GENLIST</b></a>]  Theorem

      |- ∀n. COUNT_LIST n = GENLIST I n

   [<a name="COUNT_LIST_SNOC-val"><b>COUNT_LIST_SNOC</b></a>]  Theorem

      |- (COUNT_LIST 0 = []) ∧
         ∀n. COUNT_LIST (SUC n) = SNOC n (COUNT_LIST n)

   [<a name="COUNT_LIST_compute-val"><b>COUNT_LIST_compute</b></a>]  Theorem

      |- ∀n. COUNT_LIST n = COUNT_LIST_AUX n []

   [<a name="DROP-val"><b>DROP</b></a>]  Theorem

      |- (∀l. DROP 0 l = l) ∧ ∀n x l. DROP (SUC n) (x::l) = DROP n l

   [<a name="DROP_APPEND1-val"><b>DROP_APPEND1</b></a>]  Theorem

      |- ∀n l1. n ≤ LENGTH l1 ⇒ ∀l2. DROP n (l1 ++ l2) = DROP n l1 ++ l2

   [<a name="DROP_APPEND2-val"><b>DROP_APPEND2</b></a>]  Theorem

      |- ∀l1 n.
           LENGTH l1 ≤ n ⇒ ∀l2. DROP n (l1 ++ l2) = DROP (n − LENGTH l1) l2

   [<a name="DROP_CONS_EL-val"><b>DROP_CONS_EL</b></a>]  Theorem

      |- ∀n l. n &lt; LENGTH l ⇒ (DROP n l = EL n l::DROP (SUC n) l)

   [<a name="DROP_DROP-val"><b>DROP_DROP</b></a>]  Theorem

      |- ∀n m l. n + m ≤ LENGTH l ⇒ (DROP n (DROP m l) = DROP (n + m) l)

   [<a name="DROP_LASTN-val"><b>DROP_LASTN</b></a>]  Theorem

      |- ∀n l. n ≤ LENGTH l ⇒ (DROP n l = LASTN (LENGTH l − n) l)

   [<a name="DROP_LENGTH_APPEND-val"><b>DROP_LENGTH_APPEND</b></a>]  Theorem

      |- ∀l1 l2. DROP (LENGTH l1) (l1 ++ l2) = l2

   [<a name="DROP_LENGTH_NIL-val"><b>DROP_LENGTH_NIL</b></a>]  Theorem

      |- ∀l. DROP (LENGTH l) l = []

   [<a name="DROP_REVERSE-val"><b>DROP_REVERSE</b></a>]  Theorem

      |- ∀n l. n ≤ LENGTH l ⇒ (DROP n (REVERSE l) = REVERSE (BUTLASTN n l))

   [<a name="DROP_SEG-val"><b>DROP_SEG</b></a>]  Theorem

      |- ∀n l. n ≤ LENGTH l ⇒ (DROP n l = SEG (LENGTH l − n) n l)

   [<a name="DROP_SNOC-val"><b>DROP_SNOC</b></a>]  Theorem

      |- ∀n l. n ≤ LENGTH l ⇒ ∀x. DROP n (SNOC x l) = SNOC x (DROP n l)

   [<a name="ELL_0_SNOC-val"><b>ELL_0_SNOC</b></a>]  Theorem

      |- ∀l x. ELL 0 (SNOC x l) = x

   [<a name="ELL_APPEND1-val"><b>ELL_APPEND1</b></a>]  Theorem

      |- ∀l2 n.
           LENGTH l2 ≤ n ⇒ ∀l1. ELL n (l1 ++ l2) = ELL (n − LENGTH l2) l1

   [<a name="ELL_APPEND2-val"><b>ELL_APPEND2</b></a>]  Theorem

      |- ∀n l2. n &lt; LENGTH l2 ⇒ ∀l1. ELL n (l1 ++ l2) = ELL n l2

   [<a name="ELL_CONS-val"><b>ELL_CONS</b></a>]  Theorem

      |- ∀n l. n &lt; LENGTH l ⇒ ∀x. ELL n (x::l) = ELL n l

   [<a name="ELL_EL-val"><b>ELL_EL</b></a>]  Theorem

      |- ∀n l. n &lt; LENGTH l ⇒ (ELL n l = EL (PRE (LENGTH l − n)) l)

   [<a name="ELL_LAST-val"><b>ELL_LAST</b></a>]  Theorem

      |- ∀l. ¬NULL l ⇒ (ELL 0 l = LAST l)

   [<a name="ELL_LENGTH_APPEND-val"><b>ELL_LENGTH_APPEND</b></a>]  Theorem

      |- ∀l1 l2. ¬NULL l1 ⇒ (ELL (LENGTH l2) (l1 ++ l2) = LAST l1)

   [<a name="ELL_LENGTH_CONS-val"><b>ELL_LENGTH_CONS</b></a>]  Theorem

      |- ∀l x. ELL (LENGTH l) (x::l) = x

   [<a name="ELL_LENGTH_SNOC-val"><b>ELL_LENGTH_SNOC</b></a>]  Theorem

      |- ∀l x. ELL (LENGTH l) (SNOC x l) = if NULL l then x else HD l

   [<a name="ELL_MAP-val"><b>ELL_MAP</b></a>]  Theorem

      |- ∀n l f. n &lt; LENGTH l ⇒ (ELL n (MAP f l) = f (ELL n l))

   [<a name="ELL_MEM-val"><b>ELL_MEM</b></a>]  Theorem

      |- ∀n l. n &lt; LENGTH l ⇒ MEM (ELL n l) l

   [<a name="ELL_PRE_LENGTH-val"><b>ELL_PRE_LENGTH</b></a>]  Theorem

      |- ∀l. l ≠ [] ⇒ (ELL (PRE (LENGTH l)) l = HD l)

   [<a name="ELL_REVERSE-val"><b>ELL_REVERSE</b></a>]  Theorem

      |- ∀n l.
           n &lt; LENGTH l ⇒ (ELL n (REVERSE l) = ELL (PRE (LENGTH l − n)) l)

   [<a name="ELL_REVERSE_EL-val"><b>ELL_REVERSE_EL</b></a>]  Theorem

      |- ∀n l. n &lt; LENGTH l ⇒ (ELL n (REVERSE l) = EL n l)

   [<a name="ELL_SEG-val"><b>ELL_SEG</b></a>]  Theorem

      |- ∀n l. n &lt; LENGTH l ⇒ (ELL n l = HD (SEG 1 (PRE (LENGTH l − n)) l))

   [<a name="ELL_SNOC-val"><b>ELL_SNOC</b></a>]  Theorem

      |- ∀n. 0 &lt; n ⇒ ∀x l. ELL n (SNOC x l) = ELL (PRE n) l

   [<a name="ELL_SUC_SNOC-val"><b>ELL_SUC_SNOC</b></a>]  Theorem

      |- ∀n x l. ELL (SUC n) (SNOC x l) = ELL n l

   [<a name="ELL_compute-val"><b>ELL_compute</b></a>]  Theorem

      |- (∀l. ELL 0 l = LAST l) ∧
         (∀n l.
            ELL (NUMERAL (BIT1 n)) l =
            ELL (NUMERAL (BIT1 n) − 1) (FRONT l)) ∧
         ∀n l. ELL (NUMERAL (BIT2 n)) l = ELL (NUMERAL (BIT1 n)) (FRONT l)

   [<a name="EL_APPEND1-val"><b>EL_APPEND1</b></a>]  Theorem

      |- ∀n l1 l2. n &lt; LENGTH l1 ⇒ (EL n (l1 ++ l2) = EL n l1)

   [<a name="EL_APPEND2-val"><b>EL_APPEND2</b></a>]  Theorem

      |- ∀l1 n.
           LENGTH l1 ≤ n ⇒ ∀l2. EL n (l1 ++ l2) = EL (n − LENGTH l1) l2

   [<a name="EL_CONS-val"><b>EL_CONS</b></a>]  Theorem

      |- ∀n. 0 &lt; n ⇒ ∀x l. EL n (x::l) = EL (PRE n) l

   [<a name="EL_COUNT_LIST-val"><b>EL_COUNT_LIST</b></a>]  Theorem

      |- ∀m n. m &lt; n ⇒ (EL m (COUNT_LIST n) = m)

   [<a name="EL_DROP-val"><b>EL_DROP</b></a>]  Theorem

      |- ∀m n l. m + n &lt; LENGTH l ⇒ (EL m (DROP n l) = EL (m + n) l)

   [<a name="EL_ELL-val"><b>EL_ELL</b></a>]  Theorem

      |- ∀n l. n &lt; LENGTH l ⇒ (EL n l = ELL (PRE (LENGTH l − n)) l)

   [<a name="EL_FRONT-val"><b>EL_FRONT</b></a>]  Theorem

      |- ∀l n. n &lt; LENGTH (FRONT l) ∧ ¬NULL l ⇒ (EL n (FRONT l) = EL n l)

   [<a name="EL_LENGTH_APPEND-val"><b>EL_LENGTH_APPEND</b></a>]  Theorem

      |- ∀l2 l1. ¬NULL l2 ⇒ (EL (LENGTH l1) (l1 ++ l2) = HD l2)

   [<a name="EL_MEM-val"><b>EL_MEM</b></a>]  Theorem

      |- ∀n l. n &lt; LENGTH l ⇒ MEM (EL n l) l

   [<a name="EL_PRE_LENGTH-val"><b>EL_PRE_LENGTH</b></a>]  Theorem

      |- ∀l. l ≠ [] ⇒ (EL (PRE (LENGTH l)) l = LAST l)

   [<a name="EL_REVERSE_ELL-val"><b>EL_REVERSE_ELL</b></a>]  Theorem

      |- ∀n l. n &lt; LENGTH l ⇒ (EL n (REVERSE l) = ELL n l)

   [<a name="EL_SEG-val"><b>EL_SEG</b></a>]  Theorem

      |- ∀n l. n &lt; LENGTH l ⇒ (EL n l = HD (SEG 1 n l))

   [<a name="EL_TAKE-val"><b>EL_TAKE</b></a>]  Theorem

      |- ∀n x l. x &lt; n ∧ n ≤ LENGTH l ⇒ (EL x (TAKE n l) = EL x l)

   [<a name="EVERY_BUTLASTN-val"><b>EVERY_BUTLASTN</b></a>]  Theorem

      |- ∀P l. EVERY P l ⇒ ∀m. m ≤ LENGTH l ⇒ EVERY P (BUTLASTN m l)

   [<a name="EVERY_DROP-val"><b>EVERY_DROP</b></a>]  Theorem

      |- ∀P l. EVERY P l ⇒ ∀m. m ≤ LENGTH l ⇒ EVERY P (DROP m l)

   [<a name="EVERY_FOLDL-val"><b>EVERY_FOLDL</b></a>]  Theorem

      |- ∀P l. EVERY P l ⇔ FOLDL (λl' x. l' ∧ P x) T l

   [<a name="EVERY_FOLDL_MAP-val"><b>EVERY_FOLDL_MAP</b></a>]  Theorem

      |- ∀P l. EVERY P l ⇔ FOLDL $/\ T (MAP P l)

   [<a name="EVERY_FOLDR-val"><b>EVERY_FOLDR</b></a>]  Theorem

      |- ∀P l. EVERY P l ⇔ FOLDR (λx l'. P x ∧ l') T l

   [<a name="EVERY_FOLDR_MAP-val"><b>EVERY_FOLDR_MAP</b></a>]  Theorem

      |- ∀P l. EVERY P l ⇔ FOLDR $/\ T (MAP P l)

   [<a name="EVERY_LASTN-val"><b>EVERY_LASTN</b></a>]  Theorem

      |- ∀P l. EVERY P l ⇒ ∀m. m ≤ LENGTH l ⇒ EVERY P (LASTN m l)

   [<a name="EVERY_REPLICATE-val"><b>EVERY_REPLICATE</b></a>]  Theorem

      |- ∀x n. EVERY ($= x) (REPLICATE n x)

   [<a name="EVERY_REVERSE-val"><b>EVERY_REVERSE</b></a>]  Theorem

      |- ∀P l. EVERY P (REVERSE l) ⇔ EVERY P l

   [<a name="EVERY_SEG-val"><b>EVERY_SEG</b></a>]  Theorem

      |- ∀P l. EVERY P l ⇒ ∀m k. m + k ≤ LENGTH l ⇒ EVERY P (SEG m k l)

   [<a name="EVERY_TAKE-val"><b>EVERY_TAKE</b></a>]  Theorem

      |- ∀P l. EVERY P l ⇒ ∀m. m ≤ LENGTH l ⇒ EVERY P (TAKE m l)

   [<a name="EXISTS_BUTLASTN-val"><b>EXISTS_BUTLASTN</b></a>]  Theorem

      |- ∀m l. m ≤ LENGTH l ⇒ ∀P. EXISTS P (BUTLASTN m l) ⇒ EXISTS P l

   [<a name="EXISTS_DISJ-val"><b>EXISTS_DISJ</b></a>]  Theorem

      |- ∀P Q l. EXISTS (λx. P x ∨ Q x) l ⇔ EXISTS P l ∨ EXISTS Q l

   [<a name="EXISTS_DROP-val"><b>EXISTS_DROP</b></a>]  Theorem

      |- ∀m l. m ≤ LENGTH l ⇒ ∀P. EXISTS P (DROP m l) ⇒ EXISTS P l

   [<a name="EXISTS_FOLDL-val"><b>EXISTS_FOLDL</b></a>]  Theorem

      |- ∀P l. EXISTS P l ⇔ FOLDL (λl' x. l' ∨ P x) F l

   [<a name="EXISTS_FOLDL_MAP-val"><b>EXISTS_FOLDL_MAP</b></a>]  Theorem

      |- ∀P l. EXISTS P l ⇔ FOLDL $\/ F (MAP P l)

   [<a name="EXISTS_FOLDR-val"><b>EXISTS_FOLDR</b></a>]  Theorem

      |- ∀P l. EXISTS P l ⇔ FOLDR (λx l'. P x ∨ l') F l

   [<a name="EXISTS_FOLDR_MAP-val"><b>EXISTS_FOLDR_MAP</b></a>]  Theorem

      |- ∀P l. EXISTS P l ⇔ FOLDR $\/ F (MAP P l)

   [<a name="EXISTS_LASTN-val"><b>EXISTS_LASTN</b></a>]  Theorem

      |- ∀m l. m ≤ LENGTH l ⇒ ∀P. EXISTS P (LASTN m l) ⇒ EXISTS P l

   [<a name="EXISTS_REVERSE-val"><b>EXISTS_REVERSE</b></a>]  Theorem

      |- ∀P l. EXISTS P (REVERSE l) ⇔ EXISTS P l

   [<a name="EXISTS_SEG-val"><b>EXISTS_SEG</b></a>]  Theorem

      |- ∀m k l. m + k ≤ LENGTH l ⇒ ∀P. EXISTS P (SEG m k l) ⇒ EXISTS P l

   [<a name="EXISTS_TAKE-val"><b>EXISTS_TAKE</b></a>]  Theorem

      |- ∀m l. m ≤ LENGTH l ⇒ ∀P. EXISTS P (TAKE m l) ⇒ EXISTS P l

   [<a name="FCOMM_FOLDL_APPEND-val"><b>FCOMM_FOLDL_APPEND</b></a>]  Theorem

      |- ∀f g.
           FCOMM f g ⇒
           ∀e.
             RIGHT_ID g e ⇒
             ∀l1 l2. FOLDL f e (l1 ++ l2) = g (FOLDL f e l1) (FOLDL f e l2)

   [<a name="FCOMM_FOLDL_FLAT-val"><b>FCOMM_FOLDL_FLAT</b></a>]  Theorem

      |- ∀f g.
           FCOMM f g ⇒
           ∀e.
             RIGHT_ID g e ⇒
             ∀l. FOLDL f e (FLAT l) = FOLDL g e (MAP (FOLDL f e) l)

   [<a name="FCOMM_FOLDR_APPEND-val"><b>FCOMM_FOLDR_APPEND</b></a>]  Theorem

      |- ∀g f.
           FCOMM g f ⇒
           ∀e.
             LEFT_ID g e ⇒
             ∀l1 l2. FOLDR f e (l1 ++ l2) = g (FOLDR f e l1) (FOLDR f e l2)

   [<a name="FCOMM_FOLDR_FLAT-val"><b>FCOMM_FOLDR_FLAT</b></a>]  Theorem

      |- ∀g f.
           FCOMM g f ⇒
           ∀e.
             LEFT_ID g e ⇒
             ∀l. FOLDR f e (FLAT l) = FOLDR g e (MAP (FOLDR f e) l)

   [<a name="FILTER_COMM-val"><b>FILTER_COMM</b></a>]  Theorem

      |- ∀f1 f2 l. FILTER f1 (FILTER f2 l) = FILTER f2 (FILTER f1 l)

   [<a name="FILTER_EQ-val"><b>FILTER_EQ</b></a>]  Theorem

      |- ∀P1 P2 l.
           (FILTER P1 l = FILTER P2 l) ⇔ ∀x. MEM x l ⇒ (P1 x ⇔ P2 x)

   [<a name="FILTER_FILTER-val"><b>FILTER_FILTER</b></a>]  Theorem

      |- ∀P Q l. FILTER P (FILTER Q l) = FILTER (λx. P x ∧ Q x) l

   [<a name="FILTER_FLAT-val"><b>FILTER_FLAT</b></a>]  Theorem

      |- ∀P l. FILTER P (FLAT l) = FLAT (MAP (FILTER P) l)

   [<a name="FILTER_FOLDL-val"><b>FILTER_FOLDL</b></a>]  Theorem

      |- ∀P l.
           FILTER P l = FOLDL (λl' x. if P x then SNOC x l' else l') [] l

   [<a name="FILTER_FOLDR-val"><b>FILTER_FOLDR</b></a>]  Theorem

      |- ∀P l. FILTER P l = FOLDR (λx l'. if P x then x::l' else l') [] l

   [<a name="FILTER_IDEM-val"><b>FILTER_IDEM</b></a>]  Theorem

      |- ∀f l. FILTER f (FILTER f l) = FILTER f l

   [<a name="FILTER_MAP-val"><b>FILTER_MAP</b></a>]  Theorem

      |- ∀f1 f2 l. FILTER f1 (MAP f2 l) = MAP f2 (FILTER (f1 o f2) l)

   [<a name="FILTER_SNOC-val"><b>FILTER_SNOC</b></a>]  Theorem

      |- ∀P x l.
           FILTER P (SNOC x l) =
           if P x then SNOC x (FILTER P l) else FILTER P l

   [<a name="FLAT_APPEND-val"><b>FLAT_APPEND</b></a>]  Theorem

      |- ∀l1 l2. FLAT (l1 ++ l2) = FLAT l1 ++ FLAT l2

   [<a name="FLAT_FLAT-val"><b>FLAT_FLAT</b></a>]  Theorem

      |- ∀l. FLAT (FLAT l) = FLAT (MAP FLAT l)

   [<a name="FLAT_FOLDL-val"><b>FLAT_FOLDL</b></a>]  Theorem

      |- ∀l. FLAT l = FOLDL $++ [] l

   [<a name="FLAT_FOLDR-val"><b>FLAT_FOLDR</b></a>]  Theorem

      |- ∀l. FLAT l = FOLDR $++ [] l

   [<a name="FLAT_REVERSE-val"><b>FLAT_REVERSE</b></a>]  Theorem

      |- ∀l. FLAT (REVERSE l) = REVERSE (FLAT (MAP REVERSE l))

   [<a name="FLAT_SNOC-val"><b>FLAT_SNOC</b></a>]  Theorem

      |- ∀x l. FLAT (SNOC x l) = FLAT l ++ x

   [<a name="FOLDL_APPEND-val"><b>FOLDL_APPEND</b></a>]  Theorem

      |- ∀f e l1 l2. FOLDL f e (l1 ++ l2) = FOLDL f (FOLDL f e l1) l2

   [<a name="FOLDL_FILTER-val"><b>FOLDL_FILTER</b></a>]  Theorem

      |- ∀f e P l.
           FOLDL f e (FILTER P l) =
           FOLDL (λx y. if P y then f x y else x) e l

   [<a name="FOLDL_FOLDR_REVERSE-val"><b>FOLDL_FOLDR_REVERSE</b></a>]  Theorem

      |- ∀f e l. FOLDL f e l = FOLDR (λx y. f y x) e (REVERSE l)

   [<a name="FOLDL_MAP-val"><b>FOLDL_MAP</b></a>]  Theorem

      |- ∀f e g l. FOLDL f e (MAP g l) = FOLDL (λx y. f x (g y)) e l

   [<a name="FOLDL_MAP2-val"><b>FOLDL_MAP2</b></a>]  Theorem

      |- ∀f e g l. FOLDL f e (MAP g l) = FOLDL (λx y. f x (g y)) e l

   [<a name="FOLDL_REVERSE-val"><b>FOLDL_REVERSE</b></a>]  Theorem

      |- ∀f e l. FOLDL f e (REVERSE l) = FOLDR (λx y. f y x) e l

   [<a name="FOLDL_SINGLE-val"><b>FOLDL_SINGLE</b></a>]  Theorem

      |- ∀f e x. FOLDL f e [x] = f e x

   [<a name="FOLDL_SNOC_NIL-val"><b>FOLDL_SNOC_NIL</b></a>]  Theorem

      |- ∀l. FOLDL (λxs x. SNOC x xs) [] l = l

   [<a name="FOLDR_APPEND-val"><b>FOLDR_APPEND</b></a>]  Theorem

      |- ∀f e l1 l2. FOLDR f e (l1 ++ l2) = FOLDR f (FOLDR f e l2) l1

   [<a name="FOLDR_CONS_NIL-val"><b>FOLDR_CONS_NIL</b></a>]  Theorem

      |- ∀l. FOLDR CONS [] l = l

   [<a name="FOLDR_FILTER-val"><b>FOLDR_FILTER</b></a>]  Theorem

      |- ∀f e P l.
           FOLDR f e (FILTER P l) =
           FOLDR (λx y. if P x then f x y else y) e l

   [<a name="FOLDR_FILTER_REVERSE-val"><b>FOLDR_FILTER_REVERSE</b></a>]  Theorem

      |- ∀f.
           (∀a b c. f a (f b c) = f b (f a c)) ⇒
           ∀e P l.
             FOLDR f e (FILTER P (REVERSE l)) = FOLDR f e (FILTER P l)

   [<a name="FOLDR_FOLDL-val"><b>FOLDR_FOLDL</b></a>]  Theorem

      |- ∀f e. MONOID f e ⇒ ∀l. FOLDR f e l = FOLDL f e l

   [<a name="FOLDR_FOLDL_REVERSE-val"><b>FOLDR_FOLDL_REVERSE</b></a>]  Theorem

      |- ∀f e l. FOLDR f e l = FOLDL (λx y. f y x) e (REVERSE l)

   [<a name="FOLDR_MAP-val"><b>FOLDR_MAP</b></a>]  Theorem

      |- ∀f e g l. FOLDR f e (MAP g l) = FOLDR (λx y. f (g x) y) e l

   [<a name="FOLDR_MAP_REVERSE-val"><b>FOLDR_MAP_REVERSE</b></a>]  Theorem

      |- ∀f.
           (∀a b c. f a (f b c) = f b (f a c)) ⇒
           ∀e g l. FOLDR f e (MAP g (REVERSE l)) = FOLDR f e (MAP g l)

   [<a name="FOLDR_REVERSE-val"><b>FOLDR_REVERSE</b></a>]  Theorem

      |- ∀f e l. FOLDR f e (REVERSE l) = FOLDL (λx y. f y x) e l

   [<a name="FOLDR_SINGLE-val"><b>FOLDR_SINGLE</b></a>]  Theorem

      |- ∀f e x. FOLDR f e [x] = f x e

   [<a name="FOLDR_SNOC-val"><b>FOLDR_SNOC</b></a>]  Theorem

      |- ∀f e x l. FOLDR f e (SNOC x l) = FOLDR f (f x e) l

   [<a name="FRONT_APPEND-val"><b>FRONT_APPEND</b></a>]  Theorem

      |- ∀l1 l2 e. FRONT (l1 ++ e::l2) = l1 ++ FRONT (e::l2)

   [<a name="IS_PREFIX-val"><b>IS_PREFIX</b></a>]  Theorem

      |- (∀l. [] ≼ l ⇔ T) ∧ (∀x l. x::l ≼ [] ⇔ F) ∧
         ∀x1 l1 x2 l2. x2::l2 ≼ x1::l1 ⇔ (x1 = x2) ∧ l2 ≼ l1

   [<a name="IS_PREFIX_ANTISYM-val"><b>IS_PREFIX_ANTISYM</b></a>]  Theorem

      |- ∀x y. x ≼ y ∧ y ≼ x ⇒ (x = y)

   [<a name="IS_PREFIX_APPEND-val"><b>IS_PREFIX_APPEND</b></a>]  Theorem

      |- ∀l1 l2. l2 ≼ l1 ⇔ ∃l. l1 = l2 ++ l

   [<a name="IS_PREFIX_APPEND1-val"><b>IS_PREFIX_APPEND1</b></a>]  Theorem

      |- ∀a b c. a ++ b ≼ c ⇒ a ≼ c

   [<a name="IS_PREFIX_APPEND2-val"><b>IS_PREFIX_APPEND2</b></a>]  Theorem

      |- ∀a b c. a ≼ b ++ c ⇒ a ≼ b ∨ b ≼ a

   [<a name="IS_PREFIX_APPENDS-val"><b>IS_PREFIX_APPENDS</b></a>]  Theorem

      |- ∀a b c. a ++ b ≼ a ++ c ⇔ b ≼ c

   [<a name="IS_PREFIX_BUTLAST-val"><b>IS_PREFIX_BUTLAST</b></a>]  Theorem

      |- ∀x y. FRONT (x::y) ≼ x::y

   [<a name="IS_PREFIX_IS_SUBLIST-val"><b>IS_PREFIX_IS_SUBLIST</b></a>]  Theorem

      |- ∀l1 l2. l2 ≼ l1 ⇒ IS_SUBLIST l1 l2

   [<a name="IS_PREFIX_LENGTH-val"><b>IS_PREFIX_LENGTH</b></a>]  Theorem

      |- ∀x y. x ≼ y ⇒ LENGTH x ≤ LENGTH y

   [<a name="IS_PREFIX_LENGTH_ANTI-val"><b>IS_PREFIX_LENGTH_ANTI</b></a>]  Theorem

      |- ∀x y. x ≼ y ∧ (LENGTH x = LENGTH y) ⇔ (x = y)

   [<a name="IS_PREFIX_NIL-val"><b>IS_PREFIX_NIL</b></a>]  Theorem

      |- ∀x. [] ≼ x ∧ (x ≼ [] ⇔ (x = []))

   [<a name="IS_PREFIX_PREFIX-val"><b>IS_PREFIX_PREFIX</b></a>]  Theorem

      |- ∀P l. PREFIX P l ≼ l

   [<a name="IS_PREFIX_REFL-val"><b>IS_PREFIX_REFL</b></a>]  Theorem

      |- ∀x. x ≼ x

   [<a name="IS_PREFIX_REVERSE-val"><b>IS_PREFIX_REVERSE</b></a>]  Theorem

      |- ∀l1 l2. REVERSE l2 ≼ REVERSE l1 ⇔ IS_SUFFIX l1 l2

   [<a name="IS_PREFIX_SNOC-val"><b>IS_PREFIX_SNOC</b></a>]  Theorem

      |- ∀x y z. z ≼ SNOC x y ⇔ z ≼ y ∨ (z = SNOC x y)

   [<a name="IS_PREFIX_TRANS-val"><b>IS_PREFIX_TRANS</b></a>]  Theorem

      |- ∀x y z. y ≼ x ∧ z ≼ y ⇒ z ≼ x

   [<a name="IS_SUBLIST_APPEND-val"><b>IS_SUBLIST_APPEND</b></a>]  Theorem

      |- ∀l1 l2. IS_SUBLIST l1 l2 ⇔ ∃l l'. l1 = l ++ (l2 ++ l')

   [<a name="IS_SUBLIST_REVERSE-val"><b>IS_SUBLIST_REVERSE</b></a>]  Theorem

      |- ∀l1 l2. IS_SUBLIST (REVERSE l1) (REVERSE l2) ⇔ IS_SUBLIST l1 l2

   [<a name="IS_SUFFIX_APPEND-val"><b>IS_SUFFIX_APPEND</b></a>]  Theorem

      |- ∀l1 l2. IS_SUFFIX l1 l2 ⇔ ∃l. l1 = l ++ l2

   [<a name="IS_SUFFIX_CONS2_E-val"><b>IS_SUFFIX_CONS2_E</b></a>]  Theorem

      |- ∀s h t. IS_SUFFIX s (h::t) ⇒ IS_SUFFIX s t

   [<a name="IS_SUFFIX_IS_SUBLIST-val"><b>IS_SUFFIX_IS_SUBLIST</b></a>]  Theorem

      |- ∀l1 l2. IS_SUFFIX l1 l2 ⇒ IS_SUBLIST l1 l2

   [<a name="IS_SUFFIX_REFL-val"><b>IS_SUFFIX_REFL</b></a>]  Theorem

      |- ∀l. IS_SUFFIX l l

   [<a name="IS_SUFFIX_REVERSE-val"><b>IS_SUFFIX_REVERSE</b></a>]  Theorem

      |- ∀l2 l1. IS_SUFFIX (REVERSE l1) (REVERSE l2) ⇔ l2 ≼ l1

   [<a name="IS_SUFFIX_compute-val"><b>IS_SUFFIX_compute</b></a>]  Theorem

      |- ∀l1 l2. IS_SUFFIX l1 l2 ⇔ REVERSE l2 ≼ REVERSE l1

   [<a name="LASTN_1-val"><b>LASTN_1</b></a>]  Theorem

      |- ∀l. l ≠ [] ⇒ (LASTN 1 l = [LAST l])

   [<a name="LASTN_APPEND1-val"><b>LASTN_APPEND1</b></a>]  Theorem

      |- ∀l2 n.
           LENGTH l2 ≤ n ⇒
           ∀l1. LASTN n (l1 ++ l2) = LASTN (n − LENGTH l2) l1 ++ l2

   [<a name="LASTN_APPEND2-val"><b>LASTN_APPEND2</b></a>]  Theorem

      |- ∀n l2. n ≤ LENGTH l2 ⇒ ∀l1. LASTN n (l1 ++ l2) = LASTN n l2

   [<a name="LASTN_BUTLASTN-val"><b>LASTN_BUTLASTN</b></a>]  Theorem

      |- ∀n m l.
           n + m ≤ LENGTH l ⇒
           (LASTN n (BUTLASTN m l) = BUTLASTN m (LASTN (n + m) l))

   [<a name="LASTN_CONS-val"><b>LASTN_CONS</b></a>]  Theorem

      |- ∀n l. n ≤ LENGTH l ⇒ ∀x. LASTN n (x::l) = LASTN n l

   [<a name="LASTN_DROP-val"><b>LASTN_DROP</b></a>]  Theorem

      |- ∀n l. n ≤ LENGTH l ⇒ (LASTN n l = DROP (LENGTH l − n) l)

   [<a name="LASTN_LASTN-val"><b>LASTN_LASTN</b></a>]  Theorem

      |- ∀l n m. m ≤ LENGTH l ⇒ n ≤ m ⇒ (LASTN n (LASTN m l) = LASTN n l)

   [<a name="LASTN_LENGTH_APPEND-val"><b>LASTN_LENGTH_APPEND</b></a>]  Theorem

      |- ∀l2 l1. LASTN (LENGTH l2) (l1 ++ l2) = l2

   [<a name="LASTN_LENGTH_ID-val"><b>LASTN_LENGTH_ID</b></a>]  Theorem

      |- ∀l. LASTN (LENGTH l) l = l

   [<a name="LASTN_MAP-val"><b>LASTN_MAP</b></a>]  Theorem

      |- ∀n l. n ≤ LENGTH l ⇒ ∀f. LASTN n (MAP f l) = MAP f (LASTN n l)

   [<a name="LASTN_REVERSE-val"><b>LASTN_REVERSE</b></a>]  Theorem

      |- ∀n l. n ≤ LENGTH l ⇒ (LASTN n (REVERSE l) = REVERSE (TAKE n l))

   [<a name="LASTN_SEG-val"><b>LASTN_SEG</b></a>]  Theorem

      |- ∀n l. n ≤ LENGTH l ⇒ (LASTN n l = SEG n (LENGTH l − n) l)

   [<a name="LASTN_compute-val"><b>LASTN_compute</b></a>]  Theorem

      |- ∀n l.
           LASTN n l =
           (let m = LENGTH l
            in
              if n ≤ m then
                DROP (m − n) l
              else
                FAIL LASTN longer than list n l)

   [<a name="LAST_LASTN_LAST-val"><b>LAST_LASTN_LAST</b></a>]  Theorem

      |- ∀n l. n ≤ LENGTH l ⇒ 0 &lt; n ⇒ (LAST (LASTN n l) = LAST l)

   [<a name="LENGTH_BUTLASTN-val"><b>LENGTH_BUTLASTN</b></a>]  Theorem

      |- ∀n l. n ≤ LENGTH l ⇒ (LENGTH (BUTLASTN n l) = LENGTH l − n)

   [<a name="LENGTH_COUNT_LIST-val"><b>LENGTH_COUNT_LIST</b></a>]  Theorem

      |- ∀n. LENGTH (COUNT_LIST n) = n

   [<a name="LENGTH_EQ-val"><b>LENGTH_EQ</b></a>]  Theorem

      |- ∀x y. (x = y) ⇒ (LENGTH x = LENGTH y)

   [<a name="LENGTH_FILTER_LEQ-val"><b>LENGTH_FILTER_LEQ</b></a>]  Theorem

      |- ∀P l. LENGTH (FILTER P l) ≤ LENGTH l

   [<a name="LENGTH_FLAT-val"><b>LENGTH_FLAT</b></a>]  Theorem

      |- ∀l. LENGTH (FLAT l) = SUM (MAP LENGTH l)

   [<a name="LENGTH_FOLDL-val"><b>LENGTH_FOLDL</b></a>]  Theorem

      |- ∀l. LENGTH l = FOLDL (λl' x. SUC l') 0 l

   [<a name="LENGTH_FOLDR-val"><b>LENGTH_FOLDR</b></a>]  Theorem

      |- ∀l. LENGTH l = FOLDR (λx l'. SUC l') 0 l

   [<a name="LENGTH_FRONT-val"><b>LENGTH_FRONT</b></a>]  Theorem

      |- ∀l. l ≠ [] ⇒ (LENGTH (FRONT l) = PRE (LENGTH l))

   [<a name="LENGTH_LASTN-val"><b>LENGTH_LASTN</b></a>]  Theorem

      |- ∀n l. n ≤ LENGTH l ⇒ (LENGTH (LASTN n l) = n)

   [<a name="LENGTH_MAP2-val"><b>LENGTH_MAP2</b></a>]  Theorem

      |- ∀l1 l2.
           (LENGTH l1 = LENGTH l2) ⇒
           ∀f.
             (LENGTH (MAP2 f l1 l2) = LENGTH l1) ∧
             (LENGTH (MAP2 f l1 l2) = LENGTH l2)

   [<a name="LENGTH_NOT_NULL-val"><b>LENGTH_NOT_NULL</b></a>]  Theorem

      |- ∀l. 0 &lt; LENGTH l ⇔ ¬NULL l

   [<a name="LENGTH_REPLICATE-val"><b>LENGTH_REPLICATE</b></a>]  Theorem

      |- ∀n x. LENGTH (REPLICATE n x) = n

   [<a name="LENGTH_SCANL-val"><b>LENGTH_SCANL</b></a>]  Theorem

      |- ∀f e l. LENGTH (SCANL f e l) = SUC (LENGTH l)

   [<a name="LENGTH_SCANR-val"><b>LENGTH_SCANR</b></a>]  Theorem

      |- ∀f e l. LENGTH (SCANR f e l) = SUC (LENGTH l)

   [<a name="LENGTH_SEG-val"><b>LENGTH_SEG</b></a>]  Theorem

      |- ∀n k l. n + k ≤ LENGTH l ⇒ (LENGTH (SEG n k l) = n)

   [<a name="LENGTH_UNZIP_FST-val"><b>LENGTH_UNZIP_FST</b></a>]  Theorem

      |- ∀l. LENGTH (UNZIP_FST l) = LENGTH l

   [<a name="LENGTH_UNZIP_SND-val"><b>LENGTH_UNZIP_SND</b></a>]  Theorem

      |- ∀l. LENGTH (UNZIP_SND l) = LENGTH l

   [<a name="LIST_ELEM_COUNT_MEM-val"><b>LIST_ELEM_COUNT_MEM</b></a>]  Theorem

      |- ∀e l. LIST_ELEM_COUNT e l &gt; 0 ⇔ MEM e l

   [<a name="LIST_ELEM_COUNT_THM-val"><b>LIST_ELEM_COUNT_THM</b></a>]  Theorem

      |- (∀e. LIST_ELEM_COUNT e [] = 0) ∧
         (∀e l1 l2.
            LIST_ELEM_COUNT e (l1 ++ l2) =
            LIST_ELEM_COUNT e l1 + LIST_ELEM_COUNT e l2) ∧
         (∀e h l.
            (h = e) ⇒
            (LIST_ELEM_COUNT e (h::l) = SUC (LIST_ELEM_COUNT e l))) ∧
         ∀e h l. h ≠ e ⇒ (LIST_ELEM_COUNT e (h::l) = LIST_ELEM_COUNT e l)

   [<a name="MAP_FILTER-val"><b>MAP_FILTER</b></a>]  Theorem

      |- ∀f P l.
           (∀x. P (f x) ⇔ P x) ⇒ (MAP f (FILTER P l) = FILTER P (MAP f l))

   [<a name="MAP_FLAT-val"><b>MAP_FLAT</b></a>]  Theorem

      |- ∀f l. MAP f (FLAT l) = FLAT (MAP (MAP f) l)

   [<a name="MAP_FOLDL-val"><b>MAP_FOLDL</b></a>]  Theorem

      |- ∀f l. MAP f l = FOLDL (λl' x. SNOC (f x) l') [] l

   [<a name="MAP_FOLDR-val"><b>MAP_FOLDR</b></a>]  Theorem

      |- ∀f l. MAP f l = FOLDR (λx l'. f x::l') [] l

   [<a name="MAP_REVERSE-val"><b>MAP_REVERSE</b></a>]  Theorem

      |- ∀f l. MAP f (REVERSE l) = REVERSE (MAP f l)

   [<a name="MEM_BUTLASTN-val"><b>MEM_BUTLASTN</b></a>]  Theorem

      |- ∀m l. m ≤ LENGTH l ⇒ ∀x. MEM x (BUTLASTN m l) ⇒ MEM x l

   [<a name="MEM_COUNT_LIST-val"><b>MEM_COUNT_LIST</b></a>]  Theorem

      |- ∀m n. MEM m (COUNT_LIST n) ⇔ m &lt; n

   [<a name="MEM_DROP-val"><b>MEM_DROP</b></a>]  Theorem

      |- ∀m l. m ≤ LENGTH l ⇒ ∀x. MEM x (DROP m l) ⇒ MEM x l

   [<a name="MEM_EXISTS-val"><b>MEM_EXISTS</b></a>]  Theorem

      |- ∀x l. MEM x l ⇔ EXISTS ($= x) l

   [<a name="MEM_FOLDL-val"><b>MEM_FOLDL</b></a>]  Theorem

      |- ∀y l. MEM y l ⇔ FOLDL (λl' x. l' ∨ (y = x)) F l

   [<a name="MEM_FOLDL_MAP-val"><b>MEM_FOLDL_MAP</b></a>]  Theorem

      |- ∀x l. MEM x l ⇔ FOLDL $\/ F (MAP ($= x) l)

   [<a name="MEM_FOLDR-val"><b>MEM_FOLDR</b></a>]  Theorem

      |- ∀y l. MEM y l ⇔ FOLDR (λx l'. (y = x) ∨ l') F l

   [<a name="MEM_FOLDR_MAP-val"><b>MEM_FOLDR_MAP</b></a>]  Theorem

      |- ∀x l. MEM x l ⇔ FOLDR $\/ F (MAP ($= x) l)

   [<a name="MEM_FRONT-val"><b>MEM_FRONT</b></a>]  Theorem

      |- ∀l e y. MEM y (FRONT (e::l)) ⇒ MEM y (e::l)

   [<a name="MEM_LAST-val"><b>MEM_LAST</b></a>]  Theorem

      |- ∀e l. MEM (LAST (e::l)) (e::l)

   [<a name="MEM_LASTN-val"><b>MEM_LASTN</b></a>]  Theorem

      |- ∀m l. m ≤ LENGTH l ⇒ ∀x. MEM x (LASTN m l) ⇒ MEM x l

   [<a name="MEM_LAST_FRONT-val"><b>MEM_LAST_FRONT</b></a>]  Theorem

      |- ∀e l h. MEM e l ∧ e ≠ LAST (h::l) ⇒ MEM e (FRONT (h::l))

   [<a name="MEM_REPLICATE-val"><b>MEM_REPLICATE</b></a>]  Theorem

      |- ∀n. 0 &lt; n ⇒ ∀x. MEM x (REPLICATE n x)

   [<a name="MEM_SEG-val"><b>MEM_SEG</b></a>]  Theorem

      |- ∀n m l. n + m ≤ LENGTH l ⇒ ∀x. MEM x (SEG n m l) ⇒ MEM x l

   [<a name="MEM_TAKE-val"><b>MEM_TAKE</b></a>]  Theorem

      |- ∀m l. m ≤ LENGTH l ⇒ ∀x. MEM x (TAKE m l) ⇒ MEM x l

   [<a name="MONOID_APPEND_NIL-val"><b>MONOID_APPEND_NIL</b></a>]  Theorem

      |- MONOID $++ []

   [<a name="NOT_NIL_SNOC-val"><b>NOT_NIL_SNOC</b></a>]  Theorem

      |- ∀x l. [] ≠ SNOC x l

   [<a name="NOT_NULL_SNOC-val"><b>NOT_NULL_SNOC</b></a>]  Theorem

      |- ∀x l. ¬NULL (SNOC x l)

   [<a name="NOT_SNOC_NIL-val"><b>NOT_SNOC_NIL</b></a>]  Theorem

      |- ∀x l. SNOC x l ≠ []

   [<a name="NULL_FOLDL-val"><b>NULL_FOLDL</b></a>]  Theorem

      |- ∀l. NULL l ⇔ FOLDL (λx l'. F) T l

   [<a name="NULL_FOLDR-val"><b>NULL_FOLDR</b></a>]  Theorem

      |- ∀l. NULL l ⇔ FOLDR (λx l'. F) T l

   [<a name="OR_EL_FOLDL-val"><b>OR_EL_FOLDL</b></a>]  Theorem

      |- ∀l. OR_EL l ⇔ FOLDL $\/ F l

   [<a name="OR_EL_FOLDR-val"><b>OR_EL_FOLDR</b></a>]  Theorem

      |- ∀l. OR_EL l ⇔ FOLDR $\/ F l

   [<a name="PREFIX-val"><b>PREFIX</b></a>]  Theorem

      |- (∀P. PREFIX P [] = []) ∧
         ∀P x l. PREFIX P (x::l) = if P x then x::PREFIX P l else []

   [<a name="PREFIX_FOLDR-val"><b>PREFIX_FOLDR</b></a>]  Theorem

      |- ∀P l. PREFIX P l = FOLDR (λx l'. if P x then x::l' else []) [] l

   [<a name="REPLACE_ELEMENT_SEM-val"><b>REPLACE_ELEMENT_SEM</b></a>]  Theorem

      |- (∀e n l. LENGTH (REPLACE_ELEMENT e n l) = LENGTH l) ∧
         ∀e n l p.
           p &lt; LENGTH l ⇒
           (EL p (REPLACE_ELEMENT e n l) = if p = n then e else EL p l)

   [<a name="REPLACE_ELEMENT_compute-val"><b>REPLACE_ELEMENT_compute</b></a>]  Theorem

      |- (∀e n. REPLACE_ELEMENT e n [] = []) ∧
         (∀e x l. REPLACE_ELEMENT e 0 (x::l) = e::l) ∧
         (∀e n x l.
            REPLACE_ELEMENT e (NUMERAL (BIT1 n)) (x::l) =
            x::REPLACE_ELEMENT e (NUMERAL (BIT1 n) − 1) l) ∧
         ∀e n x l.
           REPLACE_ELEMENT e (NUMERAL (BIT2 n)) (x::l) =
           x::REPLACE_ELEMENT e (NUMERAL (BIT1 n)) l

   [<a name="REPLICATE_compute-val"><b>REPLICATE_compute</b></a>]  Theorem

      |- (∀x. REPLICATE 0 x = []) ∧
         (∀n x.
            REPLICATE (NUMERAL (BIT1 n)) x =
            x::REPLICATE (NUMERAL (BIT1 n) − 1) x) ∧
         ∀n x.
           REPLICATE (NUMERAL (BIT2 n)) x =
           x::REPLICATE (NUMERAL (BIT1 n)) x

   [<a name="REVERSE_FLAT-val"><b>REVERSE_FLAT</b></a>]  Theorem

      |- ∀l. REVERSE (FLAT l) = FLAT (REVERSE (MAP REVERSE l))

   [<a name="REVERSE_FOLDL-val"><b>REVERSE_FOLDL</b></a>]  Theorem

      |- ∀l. REVERSE l = FOLDL (λl' x. x::l') [] l

   [<a name="REVERSE_FOLDR-val"><b>REVERSE_FOLDR</b></a>]  Theorem

      |- ∀l. REVERSE l = FOLDR SNOC [] l

   [<a name="SEG_0_SNOC-val"><b>SEG_0_SNOC</b></a>]  Theorem

      |- ∀m l x. m ≤ LENGTH l ⇒ (SEG m 0 (SNOC x l) = SEG m 0 l)

   [<a name="SEG_APPEND-val"><b>SEG_APPEND</b></a>]  Theorem

      |- ∀m l1 n l2.
           m &lt; LENGTH l1 ∧ LENGTH l1 ≤ n + m ∧
           n + m ≤ LENGTH l1 + LENGTH l2 ⇒
           (SEG n m (l1 ++ l2) =
            SEG (LENGTH l1 − m) m l1 ++ SEG (n + m − LENGTH l1) 0 l2)

   [<a name="SEG_APPEND1-val"><b>SEG_APPEND1</b></a>]  Theorem

      |- ∀n m l1. n + m ≤ LENGTH l1 ⇒ ∀l2. SEG n m (l1 ++ l2) = SEG n m l1

   [<a name="SEG_APPEND2-val"><b>SEG_APPEND2</b></a>]  Theorem

      |- ∀l1 m n l2.
           LENGTH l1 ≤ m ∧ n ≤ LENGTH l2 ⇒
           (SEG n m (l1 ++ l2) = SEG n (m − LENGTH l1) l2)

   [<a name="SEG_LASTN_BUTLASTN-val"><b>SEG_LASTN_BUTLASTN</b></a>]  Theorem

      |- ∀n m l.
           n + m ≤ LENGTH l ⇒
           (SEG n m l = LASTN n (BUTLASTN (LENGTH l − (n + m)) l))

   [<a name="SEG_LENGTH_ID-val"><b>SEG_LENGTH_ID</b></a>]  Theorem

      |- ∀l. SEG (LENGTH l) 0 l = l

   [<a name="SEG_LENGTH_SNOC-val"><b>SEG_LENGTH_SNOC</b></a>]  Theorem

      |- ∀l x. SEG 1 (LENGTH l) (SNOC x l) = [x]

   [<a name="SEG_REVERSE-val"><b>SEG_REVERSE</b></a>]  Theorem

      |- ∀n m l.
           n + m ≤ LENGTH l ⇒
           (SEG n m (REVERSE l) = REVERSE (SEG n (LENGTH l − (n + m)) l))

   [<a name="SEG_SEG-val"><b>SEG_SEG</b></a>]  Theorem

      |- ∀n1 m1 n2 m2 l.
           n1 + m1 ≤ LENGTH l ∧ n2 + m2 ≤ n1 ⇒
           (SEG n2 m2 (SEG n1 m1 l) = SEG n2 (m1 + m2) l)

   [<a name="SEG_SNOC-val"><b>SEG_SNOC</b></a>]  Theorem

      |- ∀n m l. n + m ≤ LENGTH l ⇒ ∀x. SEG n m (SNOC x l) = SEG n m l

   [<a name="SEG_SUC_CONS-val"><b>SEG_SUC_CONS</b></a>]  Theorem

      |- ∀m n l x. SEG m (SUC n) (x::l) = SEG m n l

   [<a name="SEG_TAKE_BUTFISTN-val"><b>SEG_TAKE_BUTFISTN</b></a>]  Theorem

      |- ∀n m l. n + m ≤ LENGTH l ⇒ (SEG n m l = TAKE n (DROP m l))

   [<a name="SEG_compute-val"><b>SEG_compute</b></a>]  Theorem

      |- (∀k l. SEG 0 k l = []) ∧
         (∀m x l.
            SEG (NUMERAL (BIT1 m)) 0 (x::l) =
            x::SEG (NUMERAL (BIT1 m) − 1) 0 l) ∧
         (∀m x l.
            SEG (NUMERAL (BIT2 m)) 0 (x::l) =
            x::SEG (NUMERAL (BIT1 m)) 0 l) ∧
         (∀m k x l.
            SEG (NUMERAL (BIT1 m)) (NUMERAL (BIT1 k)) (x::l) =
            SEG (NUMERAL (BIT1 m)) (NUMERAL (BIT1 k) − 1) l) ∧
         (∀m k x l.
            SEG (NUMERAL (BIT2 m)) (NUMERAL (BIT1 k)) (x::l) =
            SEG (NUMERAL (BIT2 m)) (NUMERAL (BIT1 k) − 1) l) ∧
         (∀m k x l.
            SEG (NUMERAL (BIT1 m)) (NUMERAL (BIT2 k)) (x::l) =
            SEG (NUMERAL (BIT1 m)) (NUMERAL (BIT1 k)) l) ∧
         ∀m k x l.
           SEG (NUMERAL (BIT2 m)) (NUMERAL (BIT2 k)) (x::l) =
           SEG (NUMERAL (BIT2 m)) (NUMERAL (BIT1 k)) l

   [<a name="SNOC_EL_TAKE-val"><b>SNOC_EL_TAKE</b></a>]  Theorem

      |- ∀n l. n &lt; LENGTH l ⇒ (SNOC (EL n l) (TAKE n l) = TAKE (SUC n) l)

   [<a name="SNOC_EQ_LENGTH_EQ-val"><b>SNOC_EQ_LENGTH_EQ</b></a>]  Theorem

      |- ∀x1 l1 x2 l2. (SNOC x1 l1 = SNOC x2 l2) ⇒ (LENGTH l1 = LENGTH l2)

   [<a name="SNOC_FOLDR-val"><b>SNOC_FOLDR</b></a>]  Theorem

      |- ∀x l. SNOC x l = FOLDR CONS [x] l

   [<a name="SNOC_REVERSE_CONS-val"><b>SNOC_REVERSE_CONS</b></a>]  Theorem

      |- ∀x l. SNOC x l = REVERSE (x::REVERSE l)

   [<a name="SPLITP_EVERY-val"><b>SPLITP_EVERY</b></a>]  Theorem

      |- ∀P l. EVERY (λx. ¬P x) l ⇒ (SPLITP P l = (l,[]))

   [<a name="SPLITP_compute-val"><b>SPLITP_compute</b></a>]  Theorem

      |- SPLITP = SPLITP_AUX []

   [<a name="SUM_FLAT-val"><b>SUM_FLAT</b></a>]  Theorem

      |- ∀l. SUM (FLAT l) = SUM (MAP SUM l)

   [<a name="SUM_FOLDL-val"><b>SUM_FOLDL</b></a>]  Theorem

      |- ∀l. SUM l = FOLDL $+ 0 l

   [<a name="SUM_FOLDR-val"><b>SUM_FOLDR</b></a>]  Theorem

      |- ∀l. SUM l = FOLDR $+ 0 l

   [<a name="SUM_REVERSE-val"><b>SUM_REVERSE</b></a>]  Theorem

      |- ∀l. SUM (REVERSE l) = SUM l

   [<a name="TAKE-val"><b>TAKE</b></a>]  Theorem

      |- (∀l. TAKE 0 l = []) ∧ ∀n x l. TAKE (SUC n) (x::l) = x::TAKE n l

   [<a name="TAKE_APPEND1-val"><b>TAKE_APPEND1</b></a>]  Theorem

      |- ∀n l1. n ≤ LENGTH l1 ⇒ ∀l2. TAKE n (l1 ++ l2) = TAKE n l1

   [<a name="TAKE_APPEND2-val"><b>TAKE_APPEND2</b></a>]  Theorem

      |- ∀l1 n.
           LENGTH l1 ≤ n ⇒
           ∀l2. TAKE n (l1 ++ l2) = l1 ++ TAKE (n − LENGTH l1) l2

   [<a name="TAKE_BUTLASTN-val"><b>TAKE_BUTLASTN</b></a>]  Theorem

      |- ∀n l. n ≤ LENGTH l ⇒ (TAKE n l = BUTLASTN (LENGTH l − n) l)

   [<a name="TAKE_LENGTH_APPEND-val"><b>TAKE_LENGTH_APPEND</b></a>]  Theorem

      |- ∀l1 l2. TAKE (LENGTH l1) (l1 ++ l2) = l1

   [<a name="TAKE_REVERSE-val"><b>TAKE_REVERSE</b></a>]  Theorem

      |- ∀n l. n ≤ LENGTH l ⇒ (TAKE n (REVERSE l) = REVERSE (LASTN n l))

   [<a name="TAKE_SEG-val"><b>TAKE_SEG</b></a>]  Theorem

      |- ∀n l. n ≤ LENGTH l ⇒ (TAKE n l = SEG n 0 l)

   [<a name="TAKE_SNOC-val"><b>TAKE_SNOC</b></a>]  Theorem

      |- ∀n l. n ≤ LENGTH l ⇒ ∀x. TAKE n (SNOC x l) = TAKE n l

   [<a name="TAKE_TAKE-val"><b>TAKE_TAKE</b></a>]  Theorem

      |- ∀m l. m ≤ LENGTH l ⇒ ∀n. n ≤ m ⇒ (TAKE n (TAKE m l) = TAKE n l)

   [<a name="TL_SNOC-val"><b>TL_SNOC</b></a>]  Theorem

      |- ∀x l. TL (SNOC x l) = if NULL l then [] else SNOC x (TL l)

   [<a name="UNZIP_SNOC-val"><b>UNZIP_SNOC</b></a>]  Theorem

      |- ∀x l.
           UNZIP (SNOC x l) =
           (SNOC (FST x) (FST (UNZIP l)),SNOC (SND x) (SND (UNZIP l)))

   [<a name="ZIP_APPEND-val"><b>ZIP_APPEND</b></a>]  Theorem

      |- ∀a b c d.
           (LENGTH a = LENGTH b) ∧ (LENGTH c = LENGTH d) ⇒
           (ZIP (a,b) ++ ZIP (c,d) = ZIP (a ++ c,b ++ d))

   [<a name="ZIP_SNOC-val"><b>ZIP_SNOC</b></a>]  Theorem

      |- ∀l1 l2.
           (LENGTH l1 = LENGTH l2) ⇒
           ∀x1 x2. ZIP (SNOC x1 l1,SNOC x2 l2) = SNOC (x1,x2) (ZIP (l1,l2))

   [<a name="ZIP_TAKE-val"><b>ZIP_TAKE</b></a>]  Theorem

      |- ∀n a b.
           n ≤ LENGTH a ∧ (LENGTH a = LENGTH b) ⇒
           (ZIP (TAKE n a,TAKE n b) = TAKE n (ZIP (a,b)))

   [<a name="ZIP_TAKE_LEQ-val"><b>ZIP_TAKE_LEQ</b></a>]  Theorem

      |- ∀n a b.
           n ≤ LENGTH a ∧ LENGTH a ≤ LENGTH b ⇒
           (ZIP (TAKE n a,TAKE n b) = TAKE n (ZIP (a,TAKE (LENGTH a) b)))


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/list/src/rich_listScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-8</a></em></p></body></html>
