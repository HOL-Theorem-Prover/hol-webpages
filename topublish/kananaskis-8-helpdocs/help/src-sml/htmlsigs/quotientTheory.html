<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure quotientTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure quotientTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/quotient/src/quotientScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature quotientTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#?!!-val">?!!</a> : thm
<a name="line7"></a>    val <a href="#EQUIV_def-val">EQUIV_def</a> : thm
<a name="line8"></a>    val <a href="#FUN_MAP-val">FUN_MAP</a> : thm
<a name="line9"></a>    val <a href="#FUN_REL-val">FUN_REL</a> : thm
<a name="line10"></a>    val <a href="#PARTIAL_EQUIV_def-val">PARTIAL_EQUIV_def</a> : thm
<a name="line11"></a>    val <a href="#QUOTIENT_def-val">QUOTIENT_def</a> : thm
<a name="line12"></a>    val <a href="#RES_EXISTS_EQUIV_DEF-val">RES_EXISTS_EQUIV_DEF</a> : thm
<a name="line13"></a>    val <a href="#respects_def-val">respects_def</a> : thm
<a name="line14"></a>
<a name="line15"></a>  (*  Theorems  *)
<a name="line16"></a>    val <a href="#ABSTRACT_PRS-val">ABSTRACT_PRS</a> : thm
<a name="line17"></a>    val <a href="#ABSTRACT_RES_ABSTRACT-val">ABSTRACT_RES_ABSTRACT</a> : thm
<a name="line18"></a>    val <a href="#APPLY_PRS-val">APPLY_PRS</a> : thm
<a name="line19"></a>    val <a href="#APPLY_RSP-val">APPLY_RSP</a> : thm
<a name="line20"></a>    val <a href="#COND_PRS-val">COND_PRS</a> : thm
<a name="line21"></a>    val <a href="#COND_RSP-val">COND_RSP</a> : thm
<a name="line22"></a>    val <a href="#CONJ_IMPLIES-val">CONJ_IMPLIES</a> : thm
<a name="line23"></a>    val <a href="#C_PRS-val">C_PRS</a> : thm
<a name="line24"></a>    val <a href="#C_RSP-val">C_RSP</a> : thm
<a name="line25"></a>    val <a href="#DISJ_IMPLIES-val">DISJ_IMPLIES</a> : thm
<a name="line26"></a>    val <a href="#EQUALS_EQUIV_IMPLIES-val">EQUALS_EQUIV_IMPLIES</a> : thm
<a name="line27"></a>    val <a href="#EQUALS_IMPLIES-val">EQUALS_IMPLIES</a> : thm
<a name="line28"></a>    val <a href="#EQUALS_PRS-val">EQUALS_PRS</a> : thm
<a name="line29"></a>    val <a href="#EQUALS_RSP-val">EQUALS_RSP</a> : thm
<a name="line30"></a>    val <a href="#EQUIV_IMP_PARTIAL_EQUIV-val">EQUIV_IMP_PARTIAL_EQUIV</a> : thm
<a name="line31"></a>    val <a href="#EQUIV_REFL_SYM_TRANS-val">EQUIV_REFL_SYM_TRANS</a> : thm
<a name="line32"></a>    val <a href="#EQUIV_RES_ABSTRACT_LEFT-val">EQUIV_RES_ABSTRACT_LEFT</a> : thm
<a name="line33"></a>    val <a href="#EQUIV_RES_ABSTRACT_RIGHT-val">EQUIV_RES_ABSTRACT_RIGHT</a> : thm
<a name="line34"></a>    val <a href="#EQUIV_RES_EXISTS-val">EQUIV_RES_EXISTS</a> : thm
<a name="line35"></a>    val <a href="#EQUIV_RES_EXISTS_UNIQUE-val">EQUIV_RES_EXISTS_UNIQUE</a> : thm
<a name="line36"></a>    val <a href="#EQUIV_RES_FORALL-val">EQUIV_RES_FORALL</a> : thm
<a name="line37"></a>    val <a href="#EQ_IMPLIES-val">EQ_IMPLIES</a> : thm
<a name="line38"></a>    val <a href="#EXISTS_PRS-val">EXISTS_PRS</a> : thm
<a name="line39"></a>    val <a href="#EXISTS_REGULAR-val">EXISTS_REGULAR</a> : thm
<a name="line40"></a>    val <a href="#EXISTS_UNIQUE_PRS-val">EXISTS_UNIQUE_PRS</a> : thm
<a name="line41"></a>    val <a href="#EXISTS_UNIQUE_REGULAR-val">EXISTS_UNIQUE_REGULAR</a> : thm
<a name="line42"></a>    val <a href="#FORALL_PRS-val">FORALL_PRS</a> : thm
<a name="line43"></a>    val <a href="#FORALL_REGULAR-val">FORALL_REGULAR</a> : thm
<a name="line44"></a>    val <a href="#FUN_MAP_I-val">FUN_MAP_I</a> : thm
<a name="line45"></a>    val <a href="#FUN_MAP_THM-val">FUN_MAP_THM</a> : thm
<a name="line46"></a>    val <a href="#FUN_QUOTIENT-val">FUN_QUOTIENT</a> : thm
<a name="line47"></a>    val <a href="#FUN_REL_EQ-val">FUN_REL_EQ</a> : thm
<a name="line48"></a>    val <a href="#FUN_REL_EQUALS-val">FUN_REL_EQUALS</a> : thm
<a name="line49"></a>    val <a href="#FUN_REL_EQ_REL-val">FUN_REL_EQ_REL</a> : thm
<a name="line50"></a>    val <a href="#FUN_REL_IMP-val">FUN_REL_IMP</a> : thm
<a name="line51"></a>    val <a href="#FUN_REL_MP-val">FUN_REL_MP</a> : thm
<a name="line52"></a>    val <a href="#IDENTITY_EQUIV-val">IDENTITY_EQUIV</a> : thm
<a name="line53"></a>    val <a href="#IDENTITY_QUOTIENT-val">IDENTITY_QUOTIENT</a> : thm
<a name="line54"></a>    val <a href="#IMP_IMPLIES-val">IMP_IMPLIES</a> : thm
<a name="line55"></a>    val <a href="#IN_FUN-val">IN_FUN</a> : thm
<a name="line56"></a>    val <a href="#IN_RESPECTS-val">IN_RESPECTS</a> : thm
<a name="line57"></a>    val <a href="#I_PRS-val">I_PRS</a> : thm
<a name="line58"></a>    val <a href="#I_RSP-val">I_RSP</a> : thm
<a name="line59"></a>    val <a href="#K_PRS-val">K_PRS</a> : thm
<a name="line60"></a>    val <a href="#K_RSP-val">K_RSP</a> : thm
<a name="line61"></a>    val <a href="#LAMBDA_PRS-val">LAMBDA_PRS</a> : thm
<a name="line62"></a>    val <a href="#LAMBDA_PRS1-val">LAMBDA_PRS1</a> : thm
<a name="line63"></a>    val <a href="#LAMBDA_REP_ABS_RSP-val">LAMBDA_REP_ABS_RSP</a> : thm
<a name="line64"></a>    val <a href="#LAMBDA_RSP-val">LAMBDA_RSP</a> : thm
<a name="line65"></a>    val <a href="#LEFT_RES_EXISTS_REGULAR-val">LEFT_RES_EXISTS_REGULAR</a> : thm
<a name="line66"></a>    val <a href="#LEFT_RES_FORALL_REGULAR-val">LEFT_RES_FORALL_REGULAR</a> : thm
<a name="line67"></a>    val <a href="#LET_PRS-val">LET_PRS</a> : thm
<a name="line68"></a>    val <a href="#LET_RES_ABSTRACT-val">LET_RES_ABSTRACT</a> : thm
<a name="line69"></a>    val <a href="#LET_RSP-val">LET_RSP</a> : thm
<a name="line70"></a>    val <a href="#NOT_IMPLIES-val">NOT_IMPLIES</a> : thm
<a name="line71"></a>    val <a href="#QUOTIENT_ABS_REP-val">QUOTIENT_ABS_REP</a> : thm
<a name="line72"></a>    val <a href="#QUOTIENT_REL-val">QUOTIENT_REL</a> : thm
<a name="line73"></a>    val <a href="#QUOTIENT_REL_ABS-val">QUOTIENT_REL_ABS</a> : thm
<a name="line74"></a>    val <a href="#QUOTIENT_REL_ABS_EQ-val">QUOTIENT_REL_ABS_EQ</a> : thm
<a name="line75"></a>    val <a href="#QUOTIENT_REL_REP-val">QUOTIENT_REL_REP</a> : thm
<a name="line76"></a>    val <a href="#QUOTIENT_REP_ABS-val">QUOTIENT_REP_ABS</a> : thm
<a name="line77"></a>    val <a href="#QUOTIENT_REP_REFL-val">QUOTIENT_REP_REFL</a> : thm
<a name="line78"></a>    val <a href="#QUOTIENT_SYM-val">QUOTIENT_SYM</a> : thm
<a name="line79"></a>    val <a href="#QUOTIENT_TRANS-val">QUOTIENT_TRANS</a> : thm
<a name="line80"></a>    val <a href="#REP_ABS_RSP-val">REP_ABS_RSP</a> : thm
<a name="line81"></a>    val <a href="#RESPECTS-val">RESPECTS</a> : thm
<a name="line82"></a>    val <a href="#RESPECTS_MP-val">RESPECTS_MP</a> : thm
<a name="line83"></a>    val <a href="#RESPECTS_REP_ABS-val">RESPECTS_REP_ABS</a> : thm
<a name="line84"></a>    val <a href="#RESPECTS_THM-val">RESPECTS_THM</a> : thm
<a name="line85"></a>    val <a href="#RESPECTS_o-val">RESPECTS_o</a> : thm
<a name="line86"></a>    val <a href="#RES_ABSTRACT_ABSTRACT-val">RES_ABSTRACT_ABSTRACT</a> : thm
<a name="line87"></a>    val <a href="#RES_ABSTRACT_RSP-val">RES_ABSTRACT_RSP</a> : thm
<a name="line88"></a>    val <a href="#RES_EXISTS_EQUIV-val">RES_EXISTS_EQUIV</a> : thm
<a name="line89"></a>    val <a href="#RES_EXISTS_EQUIV_RSP-val">RES_EXISTS_EQUIV_RSP</a> : thm
<a name="line90"></a>    val <a href="#RES_EXISTS_PRS-val">RES_EXISTS_PRS</a> : thm
<a name="line91"></a>    val <a href="#RES_EXISTS_REGULAR-val">RES_EXISTS_REGULAR</a> : thm
<a name="line92"></a>    val <a href="#RES_EXISTS_RSP-val">RES_EXISTS_RSP</a> : thm
<a name="line93"></a>    val <a href="#RES_EXISTS_UNIQUE_REGULAR-val">RES_EXISTS_UNIQUE_REGULAR</a> : thm
<a name="line94"></a>    val <a href="#RES_EXISTS_UNIQUE_REGULAR_SAME-val">RES_EXISTS_UNIQUE_REGULAR_SAME</a> : thm
<a name="line95"></a>    val <a href="#RES_EXISTS_UNIQUE_RESPECTS_REGULAR-val">RES_EXISTS_UNIQUE_RESPECTS_REGULAR</a> : thm
<a name="line96"></a>    val <a href="#RES_FORALL_PRS-val">RES_FORALL_PRS</a> : thm
<a name="line97"></a>    val <a href="#RES_FORALL_REGULAR-val">RES_FORALL_REGULAR</a> : thm
<a name="line98"></a>    val <a href="#RES_FORALL_RSP-val">RES_FORALL_RSP</a> : thm
<a name="line99"></a>    val <a href="#RIGHT_RES_EXISTS_REGULAR-val">RIGHT_RES_EXISTS_REGULAR</a> : thm
<a name="line100"></a>    val <a href="#RIGHT_RES_FORALL_REGULAR-val">RIGHT_RES_FORALL_REGULAR</a> : thm
<a name="line101"></a>    val <a href="#W_PRS-val">W_PRS</a> : thm
<a name="line102"></a>    val <a href="#W_RSP-val">W_RSP</a> : thm
<a name="line103"></a>    val <a href="#literal_case_PRS-val">literal_case_PRS</a> : thm
<a name="line104"></a>    val <a href="#literal_case_RSP-val">literal_case_RSP</a> : thm
<a name="line105"></a>    val <a href="#o_PRS-val">o_PRS</a> : thm
<a name="line106"></a>    val <a href="#o_RSP-val">o_RSP</a> : thm
<a name="line107"></a>
<a name="line108"></a>  val quotient_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line109"></a>(*
   [list] Parent theory of "quotient"

   [res_quan] Parent theory of "quotient"

   [<a name="?!!-val"><b>?!!</b></a>]  Definition

      |- ∀P. $?!! P ⇔ $?! P

   [<a name="EQUIV_def-val"><b>EQUIV_def</b></a>]  Definition

      |- ∀E. EQUIV E ⇔ ∀x y. E x y ⇔ (E x = E y)

   [<a name="FUN_MAP-val"><b>FUN_MAP</b></a>]  Definition

      |- ∀f g. f --&gt; g = (λh x. g (h (f x)))

   [<a name="FUN_REL-val"><b>FUN_REL</b></a>]  Definition

      |- ∀R1 R2 f g. (R1 ===&gt; R2) f g ⇔ ∀x y. R1 x y ⇒ R2 (f x) (g y)

   [<a name="PARTIAL_EQUIV_def-val"><b>PARTIAL_EQUIV_def</b></a>]  Definition

      |- ∀R.
           PARTIAL_EQUIV R ⇔
           (∃x. R x x) ∧ ∀x y. R x y ⇔ R x x ∧ R y y ∧ (R x = R y)

   [<a name="QUOTIENT_def-val"><b>QUOTIENT_def</b></a>]  Definition

      |- ∀R abs rep.
           QUOTIENT R abs rep ⇔
           (∀a. abs (rep a) = a) ∧ (∀a. R (rep a) (rep a)) ∧
           ∀r s. R r s ⇔ R r r ∧ R s s ∧ (abs r = abs s)

   [<a name="RES_EXISTS_EQUIV_DEF-val"><b>RES_EXISTS_EQUIV_DEF</b></a>]  Definition

      |- RES_EXISTS_EQUIV =
         (λR P.
            (∃x::respects R. P x) ∧ ∀x y::respects R. P x ∧ P y ⇒ R x y)

   [<a name="respects_def-val"><b>respects_def</b></a>]  Definition

      |- respects = W

   [<a name="ABSTRACT_PRS-val"><b>ABSTRACT_PRS</b></a>]  Theorem

      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f.
               f =
               (rep1 --&gt; abs2)
                 (RES_ABSTRACT (respects R1) ((abs1 --&gt; rep2) f))

   [<a name="ABSTRACT_RES_ABSTRACT-val"><b>ABSTRACT_RES_ABSTRACT</b></a>]  Theorem

      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 f g.
             (R1 ===&gt; R2) f g ⇒
             (R1 ===&gt; R2) f (RES_ABSTRACT (respects R1) g)

   [<a name="APPLY_PRS-val"><b>APPLY_PRS</b></a>]  Theorem

      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f x. f x = abs2 ((abs1 --&gt; rep2) f (rep1 x))

   [<a name="APPLY_RSP-val"><b>APPLY_RSP</b></a>]  Theorem

      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f g x y. (R1 ===&gt; R2) f g ∧ R1 x y ⇒ R2 (f x) (g y)

   [<a name="COND_PRS-val"><b>COND_PRS</b></a>]  Theorem

      |- ∀R abs rep.
           QUOTIENT R abs rep ⇒
           ∀a b c. (if a then b else c) = abs (if a then rep b else rep c)

   [<a name="COND_RSP-val"><b>COND_RSP</b></a>]  Theorem

      |- ∀R abs rep.
           QUOTIENT R abs rep ⇒
           ∀a1 a2 b1 b2 c1 c2.
             (a1 ⇔ a2) ∧ R b1 b2 ∧ R c1 c2 ⇒
             R (if a1 then b1 else c1) (if a2 then b2 else c2)

   [<a name="CONJ_IMPLIES-val"><b>CONJ_IMPLIES</b></a>]  Theorem

      |- ∀P P' Q Q'. (P ⇒ Q) ∧ (P' ⇒ Q') ⇒ P ∧ P' ⇒ Q ∧ Q'

   [<a name="C_PRS-val"><b>C_PRS</b></a>]  Theorem

      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀R3 abs3 rep3.
               QUOTIENT R3 abs3 rep3 ⇒
               ∀f x y.
                 combin$C f x y =
                 abs3
                   (combin$C ((abs1 --&gt; abs2 --&gt; rep3) f) (rep2 x)
                      (rep1 y))

   [<a name="C_RSP-val"><b>C_RSP</b></a>]  Theorem

      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀R3 abs3 rep3.
               QUOTIENT R3 abs3 rep3 ⇒
               ∀f1 f2 x1 x2 y1 y2.
                 (R1 ===&gt; R2 ===&gt; R3) f1 f2 ∧ R2 x1 x2 ∧ R1 y1 y2 ⇒
                 R3 (combin$C f1 x1 y1) (combin$C f2 x2 y2)

   [<a name="DISJ_IMPLIES-val"><b>DISJ_IMPLIES</b></a>]  Theorem

      |- ∀P P' Q Q'. (P ⇒ Q) ∧ (P' ⇒ Q') ⇒ P ∨ P' ⇒ Q ∨ Q'

   [<a name="EQUALS_EQUIV_IMPLIES-val"><b>EQUALS_EQUIV_IMPLIES</b></a>]  Theorem

      |- ∀R. EQUIV R ⇒ R a1 a2 ∧ R b1 b2 ⇒ (a1 = b1) ⇒ R a2 b2

   [<a name="EQUALS_IMPLIES-val"><b>EQUALS_IMPLIES</b></a>]  Theorem

      |- ∀P P' Q Q'. (P = Q) ∧ (P' = Q') ⇒ (P = P') ⇒ (Q = Q')

   [<a name="EQUALS_PRS-val"><b>EQUALS_PRS</b></a>]  Theorem

      |- ∀R abs rep. QUOTIENT R abs rep ⇒ ∀x y. (x = y) ⇔ R (rep x) (rep y)

   [<a name="EQUALS_RSP-val"><b>EQUALS_RSP</b></a>]  Theorem

      |- ∀R abs rep.
           QUOTIENT R abs rep ⇒
           ∀x1 x2 y1 y2. R x1 x2 ∧ R y1 y2 ⇒ (R x1 y1 ⇔ R x2 y2)

   [<a name="EQUIV_IMP_PARTIAL_EQUIV-val"><b>EQUIV_IMP_PARTIAL_EQUIV</b></a>]  Theorem

      |- ∀R. EQUIV R ⇒ PARTIAL_EQUIV R

   [<a name="EQUIV_REFL_SYM_TRANS-val"><b>EQUIV_REFL_SYM_TRANS</b></a>]  Theorem

      |- ∀R.
           (∀x y. R x y ⇔ (R x = R y)) ⇔
           (∀x. R x x) ∧ (∀x y. R x y ⇒ R y x) ∧
           ∀x y z. R x y ∧ R y z ⇒ R x z

   [<a name="EQUIV_RES_ABSTRACT_LEFT-val"><b>EQUIV_RES_ABSTRACT_LEFT</b></a>]  Theorem

      |- ∀R1 R2 f1 f2 x1 x2.
           R2 (f1 x1) (f2 x2) ∧ R1 x1 x1 ⇒
           R2 (RES_ABSTRACT (respects R1) f1 x1) (f2 x2)

   [<a name="EQUIV_RES_ABSTRACT_RIGHT-val"><b>EQUIV_RES_ABSTRACT_RIGHT</b></a>]  Theorem

      |- ∀R1 R2 f1 f2 x1 x2.
           R2 (f1 x1) (f2 x2) ∧ R1 x2 x2 ⇒
           R2 (f1 x1) (RES_ABSTRACT (respects R1) f2 x2)

   [<a name="EQUIV_RES_EXISTS-val"><b>EQUIV_RES_EXISTS</b></a>]  Theorem

      |- ∀E P. EQUIV E ⇒ (RES_EXISTS (respects E) P ⇔ $? P)

   [<a name="EQUIV_RES_EXISTS_UNIQUE-val"><b>EQUIV_RES_EXISTS_UNIQUE</b></a>]  Theorem

      |- ∀E P. EQUIV E ⇒ (RES_EXISTS_UNIQUE (respects E) P ⇔ $?! P)

   [<a name="EQUIV_RES_FORALL-val"><b>EQUIV_RES_FORALL</b></a>]  Theorem

      |- ∀E P. EQUIV E ⇒ (RES_FORALL (respects E) P ⇔ $! P)

   [<a name="EQ_IMPLIES-val"><b>EQ_IMPLIES</b></a>]  Theorem

      |- ∀P Q. (P ⇔ Q) ⇒ P ⇒ Q

   [<a name="EXISTS_PRS-val"><b>EXISTS_PRS</b></a>]  Theorem

      |- ∀R abs rep.
           QUOTIENT R abs rep ⇒
           ∀f. $? f ⇔ RES_EXISTS (respects R) ((abs --&gt; I) f)

   [<a name="EXISTS_REGULAR-val"><b>EXISTS_REGULAR</b></a>]  Theorem

      |- ∀P Q. (∀x. P x ⇒ Q x) ⇒ $? P ⇒ $? Q

   [<a name="EXISTS_UNIQUE_PRS-val"><b>EXISTS_UNIQUE_PRS</b></a>]  Theorem

      |- ∀R abs rep.
           QUOTIENT R abs rep ⇒
           ∀f. $?! f ⇔ RES_EXISTS_EQUIV R ((abs --&gt; I) f)

   [<a name="EXISTS_UNIQUE_REGULAR-val"><b>EXISTS_UNIQUE_REGULAR</b></a>]  Theorem

      |- ∀P E Q.
           (∀x. P x ⇒ respects E x ∧ Q x) ∧
           (∀x y. respects E x ∧ Q x ∧ respects E y ∧ Q y ⇒ E x y) ⇒
           $?! P ⇒
           RES_EXISTS_EQUIV E Q

   [<a name="FORALL_PRS-val"><b>FORALL_PRS</b></a>]  Theorem

      |- ∀R abs rep.
           QUOTIENT R abs rep ⇒
           ∀f. $! f ⇔ RES_FORALL (respects R) ((abs --&gt; I) f)

   [<a name="FORALL_REGULAR-val"><b>FORALL_REGULAR</b></a>]  Theorem

      |- ∀P Q. (∀x. P x ⇒ Q x) ⇒ $! P ⇒ $! Q

   [<a name="FUN_MAP_I-val"><b>FUN_MAP_I</b></a>]  Theorem

      |- I --&gt; I = I

   [<a name="FUN_MAP_THM-val"><b>FUN_MAP_THM</b></a>]  Theorem

      |- ∀f g h x. (f --&gt; g) h x = g (h (f x))

   [<a name="FUN_QUOTIENT-val"><b>FUN_QUOTIENT</b></a>]  Theorem

      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             QUOTIENT (R1 ===&gt; R2) (rep1 --&gt; abs2) (abs1 --&gt; rep2)

   [<a name="FUN_REL_EQ-val"><b>FUN_REL_EQ</b></a>]  Theorem

      |- $= ===&gt; $= = $=

   [<a name="FUN_REL_EQUALS-val"><b>FUN_REL_EQUALS</b></a>]  Theorem

      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f g.
               respects (R1 ===&gt; R2) f ∧ respects (R1 ===&gt; R2) g ⇒
               (((rep1 --&gt; abs2) f = (rep1 --&gt; abs2) g) ⇔
                ∀x y. R1 x y ⇒ R2 (f x) (g y))

   [<a name="FUN_REL_EQ_REL-val"><b>FUN_REL_EQ_REL</b></a>]  Theorem

      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f g.
               (R1 ===&gt; R2) f g ⇔
               respects (R1 ===&gt; R2) f ∧ respects (R1 ===&gt; R2) g ∧
               ((rep1 --&gt; abs2) f = (rep1 --&gt; abs2) g)

   [<a name="FUN_REL_IMP-val"><b>FUN_REL_IMP</b></a>]  Theorem

      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f g.
               respects (R1 ===&gt; R2) f ∧ respects (R1 ===&gt; R2) g ∧
               ((rep1 --&gt; abs2) f = (rep1 --&gt; abs2) g) ⇒
               ∀x y. R1 x y ⇒ R2 (f x) (g y)

   [<a name="FUN_REL_MP-val"><b>FUN_REL_MP</b></a>]  Theorem

      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f g x y. (R1 ===&gt; R2) f g ∧ R1 x y ⇒ R2 (f x) (g y)

   [<a name="IDENTITY_EQUIV-val"><b>IDENTITY_EQUIV</b></a>]  Theorem

      |- EQUIV $=

   [<a name="IDENTITY_QUOTIENT-val"><b>IDENTITY_QUOTIENT</b></a>]  Theorem

      |- QUOTIENT $= I I

   [<a name="IMP_IMPLIES-val"><b>IMP_IMPLIES</b></a>]  Theorem

      |- ∀P P' Q Q'. (Q ⇒ P) ∧ (P' ⇒ Q') ⇒ (P ⇒ P') ⇒ Q ⇒ Q'

   [<a name="IN_FUN-val"><b>IN_FUN</b></a>]  Theorem

      |- ∀f g s x. x ∈ (f --&gt; g) s ⇔ g (f x ∈ s)

   [<a name="IN_RESPECTS-val"><b>IN_RESPECTS</b></a>]  Theorem

      |- ∀R x. x ∈ respects R ⇔ R x x

   [<a name="I_PRS-val"><b>I_PRS</b></a>]  Theorem

      |- ∀R abs rep. QUOTIENT R abs rep ⇒ ∀e. I e = abs (I (rep e))

   [<a name="I_RSP-val"><b>I_RSP</b></a>]  Theorem

      |- ∀R abs rep. QUOTIENT R abs rep ⇒ ∀e1 e2. R e1 e2 ⇒ R (I e1) (I e2)

   [<a name="K_PRS-val"><b>K_PRS</b></a>]  Theorem

      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀x y. K x y = abs1 (K (rep1 x) (rep2 y))

   [<a name="K_RSP-val"><b>K_RSP</b></a>]  Theorem

      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀x1 x2 y1 y2. R1 x1 x2 ∧ R2 y1 y2 ⇒ R1 (K x1 y1) (K x2 y2)

   [<a name="LAMBDA_PRS-val"><b>LAMBDA_PRS</b></a>]  Theorem

      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f. (λx. f x) = (rep1 --&gt; abs2) (λx. rep2 (f (abs1 x)))

   [<a name="LAMBDA_PRS1-val"><b>LAMBDA_PRS1</b></a>]  Theorem

      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f. (λx. f x) = (rep1 --&gt; abs2) (λx. (abs1 --&gt; rep2) f x)

   [<a name="LAMBDA_REP_ABS_RSP-val"><b>LAMBDA_REP_ABS_RSP</b></a>]  Theorem

      |- ∀REL1 abs1 rep1 REL2 abs2 rep2 f1 f2.
           ((∀r r'. REL1 r r' ⇒ REL1 r (rep1 (abs1 r'))) ∧
            ∀r r'. REL2 r r' ⇒ REL2 r (rep2 (abs2 r'))) ∧
           (REL1 ===&gt; REL2) f1 f2 ⇒
           (REL1 ===&gt; REL2) f1 ((abs1 --&gt; rep2) ((rep1 --&gt; abs2) f2))

   [<a name="LAMBDA_RSP-val"><b>LAMBDA_RSP</b></a>]  Theorem

      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f1 f2.
               (R1 ===&gt; R2) f1 f2 ⇒ (R1 ===&gt; R2) (λx. f1 x) (λy. f2 y)

   [<a name="LEFT_RES_EXISTS_REGULAR-val"><b>LEFT_RES_EXISTS_REGULAR</b></a>]  Theorem

      |- ∀P R Q. (∀x. R x ⇒ Q x ⇒ P x) ⇒ RES_EXISTS R Q ⇒ $? P

   [<a name="LEFT_RES_FORALL_REGULAR-val"><b>LEFT_RES_FORALL_REGULAR</b></a>]  Theorem

      |- ∀P R Q. (∀x. R x ∧ (Q x ⇒ P x)) ⇒ RES_FORALL R Q ⇒ $! P

   [<a name="LET_PRS-val"><b>LET_PRS</b></a>]  Theorem

      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f x. LET f x = abs2 (LET ((abs1 --&gt; rep2) f) (rep1 x))

   [<a name="LET_RES_ABSTRACT-val"><b>LET_RES_ABSTRACT</b></a>]  Theorem

      |- ∀r lam v. v ∈ r ⇒ (LET (RES_ABSTRACT r lam) v = LET lam v)

   [<a name="LET_RSP-val"><b>LET_RSP</b></a>]  Theorem

      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f g x y. (R1 ===&gt; R2) f g ∧ R1 x y ⇒ R2 (LET f x) (LET g y)

   [<a name="NOT_IMPLIES-val"><b>NOT_IMPLIES</b></a>]  Theorem

      |- ∀P Q. (Q ⇒ P) ⇒ ¬P ⇒ ¬Q

   [<a name="QUOTIENT_ABS_REP-val"><b>QUOTIENT_ABS_REP</b></a>]  Theorem

      |- ∀R abs rep. QUOTIENT R abs rep ⇒ ∀a. abs (rep a) = a

   [<a name="QUOTIENT_REL-val"><b>QUOTIENT_REL</b></a>]  Theorem

      |- ∀R abs rep.
           QUOTIENT R abs rep ⇒
           ∀r s. R r s ⇔ R r r ∧ R s s ∧ (abs r = abs s)

   [<a name="QUOTIENT_REL_ABS-val"><b>QUOTIENT_REL_ABS</b></a>]  Theorem

      |- ∀R abs rep. QUOTIENT R abs rep ⇒ ∀r s. R r s ⇒ (abs r = abs s)

   [<a name="QUOTIENT_REL_ABS_EQ-val"><b>QUOTIENT_REL_ABS_EQ</b></a>]  Theorem

      |- ∀R abs rep.
           QUOTIENT R abs rep ⇒
           ∀r s. R r r ⇒ R s s ⇒ (R r s ⇔ (abs r = abs s))

   [<a name="QUOTIENT_REL_REP-val"><b>QUOTIENT_REL_REP</b></a>]  Theorem

      |- ∀R abs rep. QUOTIENT R abs rep ⇒ ∀a b. R (rep a) (rep b) ⇔ (a = b)

   [<a name="QUOTIENT_REP_ABS-val"><b>QUOTIENT_REP_ABS</b></a>]  Theorem

      |- ∀R abs rep. QUOTIENT R abs rep ⇒ ∀r. R r r ⇒ R (rep (abs r)) r

   [<a name="QUOTIENT_REP_REFL-val"><b>QUOTIENT_REP_REFL</b></a>]  Theorem

      |- ∀R abs rep. QUOTIENT R abs rep ⇒ ∀a. R (rep a) (rep a)

   [<a name="QUOTIENT_SYM-val"><b>QUOTIENT_SYM</b></a>]  Theorem

      |- ∀R abs rep. QUOTIENT R abs rep ⇒ ∀x y. R x y ⇒ R y x

   [<a name="QUOTIENT_TRANS-val"><b>QUOTIENT_TRANS</b></a>]  Theorem

      |- ∀R abs rep. QUOTIENT R abs rep ⇒ ∀x y z. R x y ∧ R y z ⇒ R x z

   [<a name="REP_ABS_RSP-val"><b>REP_ABS_RSP</b></a>]  Theorem

      |- ∀REL abs rep.
           QUOTIENT REL abs rep ⇒ ∀x1 x2. REL x1 x2 ⇒ REL x1 (rep (abs x2))

   [<a name="RESPECTS-val"><b>RESPECTS</b></a>]  Theorem

      |- ∀R x. respects R x ⇔ R x x

   [<a name="RESPECTS_MP-val"><b>RESPECTS_MP</b></a>]  Theorem

      |- ∀R1 R2 f x y. respects (R1 ===&gt; R2) f ∧ R1 x y ⇒ R2 (f x) (f y)

   [<a name="RESPECTS_REP_ABS-val"><b>RESPECTS_REP_ABS</b></a>]  Theorem

      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 f x.
             respects (R1 ===&gt; R2) f ∧ R1 x x ⇒
             R2 (f (rep1 (abs1 x))) (f x)

   [<a name="RESPECTS_THM-val"><b>RESPECTS_THM</b></a>]  Theorem

      |- ∀R1 R2 f. respects (R1 ===&gt; R2) f ⇔ ∀x y. R1 x y ⇒ R2 (f x) (f y)

   [<a name="RESPECTS_o-val"><b>RESPECTS_o</b></a>]  Theorem

      |- ∀R1 R2 R3 f g.
           respects (R2 ===&gt; R3) f ∧ respects (R1 ===&gt; R2) g ⇒
           respects (R1 ===&gt; R3) (f o g)

   [<a name="RES_ABSTRACT_ABSTRACT-val"><b>RES_ABSTRACT_ABSTRACT</b></a>]  Theorem

      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 f g.
             (R1 ===&gt; R2) f g ⇒
             (R1 ===&gt; R2) (RES_ABSTRACT (respects R1) f) g

   [<a name="RES_ABSTRACT_RSP-val"><b>RES_ABSTRACT_RSP</b></a>]  Theorem

      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f1 f2.
               (R1 ===&gt; R2) f1 f2 ⇒
               (R1 ===&gt; R2) (RES_ABSTRACT (respects R1) f1)
                 (RES_ABSTRACT (respects R1) f2)

   [<a name="RES_EXISTS_EQUIV-val"><b>RES_EXISTS_EQUIV</b></a>]  Theorem

      |- ∀R m.
           RES_EXISTS_EQUIV R m ⇔
           (∃x::respects R. m x) ∧ ∀x y::respects R. m x ∧ m y ⇒ R x y

   [<a name="RES_EXISTS_EQUIV_RSP-val"><b>RES_EXISTS_EQUIV_RSP</b></a>]  Theorem

      |- ∀R abs rep.
           QUOTIENT R abs rep ⇒
           ∀f g.
             (R ===&gt; $&lt;=&gt;) f g ⇒
             (RES_EXISTS_EQUIV R f ⇔ RES_EXISTS_EQUIV R g)

   [<a name="RES_EXISTS_PRS-val"><b>RES_EXISTS_PRS</b></a>]  Theorem

      |- ∀R abs rep.
           QUOTIENT R abs rep ⇒
           ∀P f.
             RES_EXISTS P f ⇔ RES_EXISTS ((abs --&gt; I) P) ((abs --&gt; I) f)

   [<a name="RES_EXISTS_REGULAR-val"><b>RES_EXISTS_REGULAR</b></a>]  Theorem

      |- ∀P Q R. (∀x. R x ⇒ P x ⇒ Q x) ⇒ RES_EXISTS R P ⇒ RES_EXISTS R Q

   [<a name="RES_EXISTS_RSP-val"><b>RES_EXISTS_RSP</b></a>]  Theorem

      |- ∀R abs rep.
           QUOTIENT R abs rep ⇒
           ∀f g.
             (R ===&gt; $&lt;=&gt;) f g ⇒
             (RES_EXISTS (respects R) f ⇔ RES_EXISTS (respects R) g)

   [<a name="RES_EXISTS_UNIQUE_REGULAR-val"><b>RES_EXISTS_UNIQUE_REGULAR</b></a>]  Theorem

      |- ∀P R Q.
           (∀x. P x ⇒ Q x) ∧
           (∀x y. respects R x ∧ Q x ∧ respects R y ∧ Q y ⇒ R x y) ⇒
           RES_EXISTS_UNIQUE (respects R) P ⇒
           RES_EXISTS_EQUIV R Q

   [<a name="RES_EXISTS_UNIQUE_REGULAR_SAME-val"><b>RES_EXISTS_UNIQUE_REGULAR_SAME</b></a>]  Theorem

      |- ∀R P Q.
           (R ===&gt; $&lt;=&gt;) P Q ⇒
           RES_EXISTS_UNIQUE (respects R) P ⇒
           RES_EXISTS_EQUIV R Q

   [<a name="RES_EXISTS_UNIQUE_RESPECTS_REGULAR-val"><b>RES_EXISTS_UNIQUE_RESPECTS_REGULAR</b></a>]  Theorem

      |- ∀R P. RES_EXISTS_UNIQUE (respects R) P ⇒ RES_EXISTS_EQUIV R P

   [<a name="RES_FORALL_PRS-val"><b>RES_FORALL_PRS</b></a>]  Theorem

      |- ∀R abs rep.
           QUOTIENT R abs rep ⇒
           ∀P f.
             RES_FORALL P f ⇔ RES_FORALL ((abs --&gt; I) P) ((abs --&gt; I) f)

   [<a name="RES_FORALL_REGULAR-val"><b>RES_FORALL_REGULAR</b></a>]  Theorem

      |- ∀P Q R. (∀x. R x ⇒ P x ⇒ Q x) ⇒ RES_FORALL R P ⇒ RES_FORALL R Q

   [<a name="RES_FORALL_RSP-val"><b>RES_FORALL_RSP</b></a>]  Theorem

      |- ∀R abs rep.
           QUOTIENT R abs rep ⇒
           ∀f g.
             (R ===&gt; $&lt;=&gt;) f g ⇒
             (RES_FORALL (respects R) f ⇔ RES_FORALL (respects R) g)

   [<a name="RIGHT_RES_EXISTS_REGULAR-val"><b>RIGHT_RES_EXISTS_REGULAR</b></a>]  Theorem

      |- ∀P R Q. (∀x. R x ∧ (P x ⇒ Q x)) ⇒ $? P ⇒ RES_EXISTS R Q

   [<a name="RIGHT_RES_FORALL_REGULAR-val"><b>RIGHT_RES_FORALL_REGULAR</b></a>]  Theorem

      |- ∀P R Q. (∀x. R x ⇒ P x ⇒ Q x) ⇒ $! P ⇒ RES_FORALL R Q

   [<a name="W_PRS-val"><b>W_PRS</b></a>]  Theorem

      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f x. W f x = abs2 (W ((abs1 --&gt; abs1 --&gt; rep2) f) (rep1 x))

   [<a name="W_RSP-val"><b>W_RSP</b></a>]  Theorem

      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f1 f2 x1 x2.
               (R1 ===&gt; R1 ===&gt; R2) f1 f2 ∧ R1 x1 x2 ⇒
               R2 (W f1 x1) (W f2 x2)

   [<a name="literal_case_PRS-val"><b>literal_case_PRS</b></a>]  Theorem

      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f x.
               literal_case f x =
               abs2 (literal_case ((abs1 --&gt; rep2) f) (rep1 x))

   [<a name="literal_case_RSP-val"><b>literal_case_RSP</b></a>]  Theorem

      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀f g x y.
               (R1 ===&gt; R2) f g ∧ R1 x y ⇒
               R2 (literal_case f x) (literal_case g y)

   [<a name="o_PRS-val"><b>o_PRS</b></a>]  Theorem

      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀R3 abs3 rep3.
               QUOTIENT R3 abs3 rep3 ⇒
               ∀f g.
                 f o g =
                 (rep1 --&gt; abs3) ((abs2 --&gt; rep3) f o (abs1 --&gt; rep2) g)

   [<a name="o_RSP-val"><b>o_RSP</b></a>]  Theorem

      |- ∀R1 abs1 rep1.
           QUOTIENT R1 abs1 rep1 ⇒
           ∀R2 abs2 rep2.
             QUOTIENT R2 abs2 rep2 ⇒
             ∀R3 abs3 rep3.
               QUOTIENT R3 abs3 rep3 ⇒
               ∀f1 f2 g1 g2.
                 (R2 ===&gt; R3) f1 f2 ∧ (R1 ===&gt; R2) g1 g2 ⇒
                 (R1 ===&gt; R3) (f1 o g1) (f2 o g2)


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/quotient/src/quotientScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-8</a></em></p></body></html>
