<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure prob_extraTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure prob_extraTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/prob/prob_extraScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature prob_extraTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#inf_def-val">inf_def</a> : thm
<a name="line7"></a>
<a name="line8"></a>  (*  Theorems  *)
<a name="line9"></a>    val <a href="#ABS_BETWEEN_LE-val">ABS_BETWEEN_LE</a> : thm
<a name="line10"></a>    val <a href="#ABS_UNIT_INTERVAL-val">ABS_UNIT_INTERVAL</a> : thm
<a name="line11"></a>    val <a href="#APPEND_MEM-val">APPEND_MEM</a> : thm
<a name="line12"></a>    val <a href="#BOOL_BOOL_CASES-val">BOOL_BOOL_CASES</a> : thm
<a name="line13"></a>    val <a href="#BOOL_BOOL_CASES_THM-val">BOOL_BOOL_CASES_THM</a> : thm
<a name="line14"></a>    val <a href="#COMPL_CLAUSES-val">COMPL_CLAUSES</a> : thm
<a name="line15"></a>    val <a href="#COMPL_COMPL-val">COMPL_COMPL</a> : thm
<a name="line16"></a>    val <a href="#COMPL_SPLITS-val">COMPL_SPLITS</a> : thm
<a name="line17"></a>    val <a href="#DIVISION_TWO-val">DIVISION_TWO</a> : thm
<a name="line18"></a>    val <a href="#DIV_THEN_MULT-val">DIV_THEN_MULT</a> : thm
<a name="line19"></a>    val <a href="#DIV_TWO-val">DIV_TWO</a> : thm
<a name="line20"></a>    val <a href="#DIV_TWO_BASIC-val">DIV_TWO_BASIC</a> : thm
<a name="line21"></a>    val <a href="#DIV_TWO_CANCEL-val">DIV_TWO_CANCEL</a> : thm
<a name="line22"></a>    val <a href="#DIV_TWO_EXP-val">DIV_TWO_EXP</a> : thm
<a name="line23"></a>    val <a href="#DIV_TWO_MONO-val">DIV_TWO_MONO</a> : thm
<a name="line24"></a>    val <a href="#DIV_TWO_MONO_EVEN-val">DIV_TWO_MONO_EVEN</a> : thm
<a name="line25"></a>    val <a href="#DIV_TWO_UNIQUE-val">DIV_TWO_UNIQUE</a> : thm
<a name="line26"></a>    val <a href="#EQ_EXT_EQ-val">EQ_EXT_EQ</a> : thm
<a name="line27"></a>    val <a href="#EVEN_EXP_TWO-val">EVEN_EXP_TWO</a> : thm
<a name="line28"></a>    val <a href="#EVEN_ODD_BASIC-val">EVEN_ODD_BASIC</a> : thm
<a name="line29"></a>    val <a href="#EVEN_ODD_EXISTS_EQ-val">EVEN_ODD_EXISTS_EQ</a> : thm
<a name="line30"></a>    val <a href="#EXISTS_LONGEST-val">EXISTS_LONGEST</a> : thm
<a name="line31"></a>    val <a href="#EXP_DIV_TWO-val">EXP_DIV_TWO</a> : thm
<a name="line32"></a>    val <a href="#FILTER_FALSE-val">FILTER_FALSE</a> : thm
<a name="line33"></a>    val <a href="#FILTER_MEM-val">FILTER_MEM</a> : thm
<a name="line34"></a>    val <a href="#FILTER_OUT_ELT-val">FILTER_OUT_ELT</a> : thm
<a name="line35"></a>    val <a href="#FILTER_TRUE-val">FILTER_TRUE</a> : thm
<a name="line36"></a>    val <a href="#FOLDR_MAP-val">FOLDR_MAP</a> : thm
<a name="line37"></a>    val <a href="#GSPEC_DEF_ALT-val">GSPEC_DEF_ALT</a> : thm
<a name="line38"></a>    val <a href="#HALF_CANCEL-val">HALF_CANCEL</a> : thm
<a name="line39"></a>    val <a href="#HALF_LT_1-val">HALF_LT_1</a> : thm
<a name="line40"></a>    val <a href="#HALF_POS-val">HALF_POS</a> : thm
<a name="line41"></a>    val <a href="#INF_DEF_ALT-val">INF_DEF_ALT</a> : thm
<a name="line42"></a>    val <a href="#INTER_IS_EMPTY-val">INTER_IS_EMPTY</a> : thm
<a name="line43"></a>    val <a href="#INTER_UNION_COMPL-val">INTER_UNION_COMPL</a> : thm
<a name="line44"></a>    val <a href="#INTER_UNION_RDISTRIB-val">INTER_UNION_RDISTRIB</a> : thm
<a name="line45"></a>    val <a href="#INV_SUC-val">INV_SUC</a> : thm
<a name="line46"></a>    val <a href="#INV_SUC_MAX-val">INV_SUC_MAX</a> : thm
<a name="line47"></a>    val <a href="#INV_SUC_POS-val">INV_SUC_POS</a> : thm
<a name="line48"></a>    val <a href="#IN_COMPL-val">IN_COMPL</a> : thm
<a name="line49"></a>    val <a href="#IN_EMPTY-val">IN_EMPTY</a> : thm
<a name="line50"></a>    val <a href="#IS_PREFIX_ANTISYM-val">IS_PREFIX_ANTISYM</a> : thm
<a name="line51"></a>    val <a href="#IS_PREFIX_BUTLAST-val">IS_PREFIX_BUTLAST</a> : thm
<a name="line52"></a>    val <a href="#IS_PREFIX_LENGTH-val">IS_PREFIX_LENGTH</a> : thm
<a name="line53"></a>    val <a href="#IS_PREFIX_LENGTH_ANTI-val">IS_PREFIX_LENGTH_ANTI</a> : thm
<a name="line54"></a>    val <a href="#IS_PREFIX_NIL-val">IS_PREFIX_NIL</a> : thm
<a name="line55"></a>    val <a href="#IS_PREFIX_REFL-val">IS_PREFIX_REFL</a> : thm
<a name="line56"></a>    val <a href="#IS_PREFIX_SNOC-val">IS_PREFIX_SNOC</a> : thm
<a name="line57"></a>    val <a href="#IS_PREFIX_TRANS-val">IS_PREFIX_TRANS</a> : thm
<a name="line58"></a>    val <a href="#LAST_MAP_CONS-val">LAST_MAP_CONS</a> : thm
<a name="line59"></a>    val <a href="#LAST_MEM-val">LAST_MEM</a> : thm
<a name="line60"></a>    val <a href="#LENGTH_FILTER-val">LENGTH_FILTER</a> : thm
<a name="line61"></a>    val <a href="#MAP_ID-val">MAP_ID</a> : thm
<a name="line62"></a>    val <a href="#MAP_MEM-val">MAP_MEM</a> : thm
<a name="line63"></a>    val <a href="#MEM_FILTER-val">MEM_FILTER</a> : thm
<a name="line64"></a>    val <a href="#MEM_NIL-val">MEM_NIL</a> : thm
<a name="line65"></a>    val <a href="#MEM_NIL_MAP_CONS-val">MEM_NIL_MAP_CONS</a> : thm
<a name="line66"></a>    val <a href="#MOD_TWO-val">MOD_TWO</a> : thm
<a name="line67"></a>    val <a href="#ONE_MINUS_HALF-val">ONE_MINUS_HALF</a> : thm
<a name="line68"></a>    val <a href="#POW_HALF_EXP-val">POW_HALF_EXP</a> : thm
<a name="line69"></a>    val <a href="#POW_HALF_MONO-val">POW_HALF_MONO</a> : thm
<a name="line70"></a>    val <a href="#POW_HALF_POS-val">POW_HALF_POS</a> : thm
<a name="line71"></a>    val <a href="#POW_HALF_TWICE-val">POW_HALF_TWICE</a> : thm
<a name="line72"></a>    val <a href="#RAND_THM-val">RAND_THM</a> : thm
<a name="line73"></a>    val <a href="#REAL_INF_MIN-val">REAL_INF_MIN</a> : thm
<a name="line74"></a>    val <a href="#REAL_INVINV_ALL-val">REAL_INVINV_ALL</a> : thm
<a name="line75"></a>    val <a href="#REAL_LE_EQ-val">REAL_LE_EQ</a> : thm
<a name="line76"></a>    val <a href="#REAL_LE_INV_LE-val">REAL_LE_INV_LE</a> : thm
<a name="line77"></a>    val <a href="#REAL_POW-val">REAL_POW</a> : thm
<a name="line78"></a>    val <a href="#REAL_SUP_EXISTS_UNIQUE-val">REAL_SUP_EXISTS_UNIQUE</a> : thm
<a name="line79"></a>    val <a href="#REAL_SUP_LE_X-val">REAL_SUP_LE_X</a> : thm
<a name="line80"></a>    val <a href="#REAL_SUP_MAX-val">REAL_SUP_MAX</a> : thm
<a name="line81"></a>    val <a href="#REAL_X_LE_SUP-val">REAL_X_LE_SUP</a> : thm
<a name="line82"></a>    val <a href="#SET_EQ_EXT-val">SET_EQ_EXT</a> : thm
<a name="line83"></a>    val <a href="#SUBSET_EQ-val">SUBSET_EQ</a> : thm
<a name="line84"></a>    val <a href="#SUBSET_EQ_DECOMP-val">SUBSET_EQ_DECOMP</a> : thm
<a name="line85"></a>    val <a href="#UNION_DEF_ALT-val">UNION_DEF_ALT</a> : thm
<a name="line86"></a>    val <a href="#UNION_DISJOINT_SPLIT-val">UNION_DISJOINT_SPLIT</a> : thm
<a name="line87"></a>    val <a href="#X_HALF_HALF-val">X_HALF_HALF</a> : thm
<a name="line88"></a>
<a name="line89"></a>  val prob_extra_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line90"></a>(*
   [poly] Parent theory of "prob_extra"

   [transc] Parent theory of "prob_extra"

   [<a name="inf_def-val"><b>inf_def</b></a>]  Definition

      |- ‚àÄP. inf P = -sup (IMAGE numeric_negate P)

   [<a name="ABS_BETWEEN_LE-val"><b>ABS_BETWEEN_LE</b></a>]  Theorem

      |- ‚àÄx y d. 0 ‚â§ d ‚àß x ‚àí d ‚â§ y ‚àß y ‚â§ x + d ‚áî abs (y ‚àí x) ‚â§ d

   [<a name="ABS_UNIT_INTERVAL-val"><b>ABS_UNIT_INTERVAL</b></a>]  Theorem

      |- ‚àÄx y. 0 ‚â§ x ‚àß x ‚â§ 1 ‚àß 0 ‚â§ y ‚àß y ‚â§ 1 ‚áí abs (x ‚àí y) ‚â§ 1

   [<a name="APPEND_MEM-val"><b>APPEND_MEM</b></a>]  Theorem

      |- ‚àÄx l1 l2. MEM x (l1 ++ l2) ‚áî MEM x l1 ‚à® MEM x l2

   [<a name="BOOL_BOOL_CASES-val"><b>BOOL_BOOL_CASES</b></a>]  Theorem

      |- ‚àÄP. P (Œªb. F) ‚àß P (Œªb. T) ‚àß P (Œªb. b) ‚àß P (Œªb. ¬¨b) ‚áí ‚àÄf. P f

   [<a name="BOOL_BOOL_CASES_THM-val"><b>BOOL_BOOL_CASES_THM</b></a>]  Theorem

      |- ‚àÄf. (f = (Œªb. F)) ‚à® (f = (Œªb. T)) ‚à® (f = (Œªb. b)) ‚à® (f = (Œªb. ¬¨b))

   [<a name="COMPL_CLAUSES-val"><b>COMPL_CLAUSES</b></a>]  Theorem

      |- ‚àÄs. (COMPL s ‚à© s = ‚àÖ) ‚àß (COMPL s ‚à™ s = ùïå(:Œ±))

   [<a name="COMPL_COMPL-val"><b>COMPL_COMPL</b></a>]  Theorem

      |- ‚àÄs. COMPL (COMPL s) = s

   [<a name="COMPL_SPLITS-val"><b>COMPL_SPLITS</b></a>]  Theorem

      |- ‚àÄp q. p ‚à© q ‚à™ COMPL p ‚à© q = q

   [<a name="DIVISION_TWO-val"><b>DIVISION_TWO</b></a>]  Theorem

      |- ‚àÄn.
           (n = 2 * (n DIV 2) + n MOD 2) ‚àß ((n MOD 2 = 0) ‚à® (n MOD 2 = 1))

   [<a name="DIV_THEN_MULT-val"><b>DIV_THEN_MULT</b></a>]  Theorem

      |- ‚àÄp q. SUC q * (p DIV SUC q) ‚â§ p

   [<a name="DIV_TWO-val"><b>DIV_TWO</b></a>]  Theorem

      |- ‚àÄn. n = 2 * (n DIV 2) + n MOD 2

   [<a name="DIV_TWO_BASIC-val"><b>DIV_TWO_BASIC</b></a>]  Theorem

      |- (0 DIV 2 = 0) ‚àß (1 DIV 2 = 0) ‚àß (2 DIV 2 = 1)

   [<a name="DIV_TWO_CANCEL-val"><b>DIV_TWO_CANCEL</b></a>]  Theorem

      |- ‚àÄn. (2 * n DIV 2 = n) ‚àß (SUC (2 * n) DIV 2 = n)

   [<a name="DIV_TWO_EXP-val"><b>DIV_TWO_EXP</b></a>]  Theorem

      |- ‚àÄn k. k DIV 2 &lt; 2 ** n ‚áî k &lt; 2 ** SUC n

   [<a name="DIV_TWO_MONO-val"><b>DIV_TWO_MONO</b></a>]  Theorem

      |- ‚àÄm n. m DIV 2 &lt; n DIV 2 ‚áí m &lt; n

   [<a name="DIV_TWO_MONO_EVEN-val"><b>DIV_TWO_MONO_EVEN</b></a>]  Theorem

      |- ‚àÄm n. EVEN n ‚áí (m DIV 2 &lt; n DIV 2 ‚áî m &lt; n)

   [<a name="DIV_TWO_UNIQUE-val"><b>DIV_TWO_UNIQUE</b></a>]  Theorem

      |- ‚àÄn q r.
           (n = 2 * q + r) ‚àß ((r = 0) ‚à® (r = 1)) ‚áí
           (q = n DIV 2) ‚àß (r = n MOD 2)

   [<a name="EQ_EXT_EQ-val"><b>EQ_EXT_EQ</b></a>]  Theorem

      |- ‚àÄf g. (‚àÄx. f x = g x) ‚áî (f = g)

   [<a name="EVEN_EXP_TWO-val"><b>EVEN_EXP_TWO</b></a>]  Theorem

      |- ‚àÄn. EVEN (2 ** n) ‚áî n ‚â† 0

   [<a name="EVEN_ODD_BASIC-val"><b>EVEN_ODD_BASIC</b></a>]  Theorem

      |- EVEN 0 ‚àß ¬¨EVEN 1 ‚àß EVEN 2 ‚àß ¬¨ODD 0 ‚àß ODD 1 ‚àß ¬¨ODD 2

   [<a name="EVEN_ODD_EXISTS_EQ-val"><b>EVEN_ODD_EXISTS_EQ</b></a>]  Theorem

      |- ‚àÄn. (EVEN n ‚áî ‚àÉm. n = 2 * m) ‚àß (ODD n ‚áî ‚àÉm. n = SUC (2 * m))

   [<a name="EXISTS_LONGEST-val"><b>EXISTS_LONGEST</b></a>]  Theorem

      |- ‚àÄx y. ‚àÉz. MEM z (x::y) ‚àß ‚àÄw. MEM w (x::y) ‚áí LENGTH w ‚â§ LENGTH z

   [<a name="EXP_DIV_TWO-val"><b>EXP_DIV_TWO</b></a>]  Theorem

      |- ‚àÄn. 2 ** SUC n DIV 2 = 2 ** n

   [<a name="FILTER_FALSE-val"><b>FILTER_FALSE</b></a>]  Theorem

      |- ‚àÄl. FILTER (Œªx. F) l = []

   [<a name="FILTER_MEM-val"><b>FILTER_MEM</b></a>]  Theorem

      |- ‚àÄP x l. MEM x (FILTER P l) ‚áí P x

   [<a name="FILTER_OUT_ELT-val"><b>FILTER_OUT_ELT</b></a>]  Theorem

      |- ‚àÄx l. MEM x l ‚à® (FILTER (Œªy. y ‚â† x) l = l)

   [<a name="FILTER_TRUE-val"><b>FILTER_TRUE</b></a>]  Theorem

      |- ‚àÄl. FILTER (Œªx. T) l = l

   [<a name="FOLDR_MAP-val"><b>FOLDR_MAP</b></a>]  Theorem

      |- ‚àÄf e g l. FOLDR f e (MAP g l) = FOLDR (Œªx y. f (g x) y) e l

   [<a name="GSPEC_DEF_ALT-val"><b>GSPEC_DEF_ALT</b></a>]  Theorem

      |- ‚àÄf. GSPEC f = (Œªv. ‚àÉx. (v,T) = f x)

   [<a name="HALF_CANCEL-val"><b>HALF_CANCEL</b></a>]  Theorem

      |- 2 * (1 / 2) = 1

   [<a name="HALF_LT_1-val"><b>HALF_LT_1</b></a>]  Theorem

      |- 1 / 2 &lt; 1

   [<a name="HALF_POS-val"><b>HALF_POS</b></a>]  Theorem

      |- 0 &lt; 1 / 2

   [<a name="INF_DEF_ALT-val"><b>INF_DEF_ALT</b></a>]  Theorem

      |- ‚àÄP. inf P = -sup (Œªr. P (-r))

   [<a name="INTER_IS_EMPTY-val"><b>INTER_IS_EMPTY</b></a>]  Theorem

      |- ‚àÄs t. (s ‚à© t = ‚àÖ) ‚áî ‚àÄx. ¬¨s x ‚à® ¬¨t x

   [<a name="INTER_UNION_COMPL-val"><b>INTER_UNION_COMPL</b></a>]  Theorem

      |- ‚àÄs t. s ‚à© t = COMPL (COMPL s ‚à™ COMPL t)

   [<a name="INTER_UNION_RDISTRIB-val"><b>INTER_UNION_RDISTRIB</b></a>]  Theorem

      |- ‚àÄp q r. (p ‚à™ q) ‚à© r = p ‚à© r ‚à™ q ‚à© r

   [<a name="INV_SUC-val"><b>INV_SUC</b></a>]  Theorem

      |- ‚àÄn. 0 &lt; 1 / &SUC n ‚àß 1 / &SUC n ‚â§ 1

   [<a name="INV_SUC_MAX-val"><b>INV_SUC_MAX</b></a>]  Theorem

      |- ‚àÄn. 1 / &SUC n ‚â§ 1

   [<a name="INV_SUC_POS-val"><b>INV_SUC_POS</b></a>]  Theorem

      |- ‚àÄn. 0 &lt; 1 / &SUC n

   [<a name="IN_COMPL-val"><b>IN_COMPL</b></a>]  Theorem

      |- ‚àÄx s. x ‚àà COMPL s ‚áî x ‚àâ s

   [<a name="IN_EMPTY-val"><b>IN_EMPTY</b></a>]  Theorem

      |- ‚àÄx. x ‚àâ ‚àÖ

   [<a name="IS_PREFIX_ANTISYM-val"><b>IS_PREFIX_ANTISYM</b></a>]  Theorem

      |- ‚àÄx y. x ‚âº y ‚àß y ‚âº x ‚áí (x = y)

   [<a name="IS_PREFIX_BUTLAST-val"><b>IS_PREFIX_BUTLAST</b></a>]  Theorem

      |- ‚àÄx y. FRONT (x::y) ‚âº x::y

   [<a name="IS_PREFIX_LENGTH-val"><b>IS_PREFIX_LENGTH</b></a>]  Theorem

      |- ‚àÄx y. x ‚âº y ‚áí LENGTH x ‚â§ LENGTH y

   [<a name="IS_PREFIX_LENGTH_ANTI-val"><b>IS_PREFIX_LENGTH_ANTI</b></a>]  Theorem

      |- ‚àÄx y. x ‚âº y ‚àß (LENGTH x = LENGTH y) ‚áí (x = y)

   [<a name="IS_PREFIX_NIL-val"><b>IS_PREFIX_NIL</b></a>]  Theorem

      |- ‚àÄx. [] ‚âº x ‚àß (x ‚âº [] ‚áî (x = []))

   [<a name="IS_PREFIX_REFL-val"><b>IS_PREFIX_REFL</b></a>]  Theorem

      |- ‚àÄx. x ‚âº x

   [<a name="IS_PREFIX_SNOC-val"><b>IS_PREFIX_SNOC</b></a>]  Theorem

      |- ‚àÄx y z. z ‚âº SNOC x y ‚áî z ‚âº y ‚à® (z = SNOC x y)

   [<a name="IS_PREFIX_TRANS-val"><b>IS_PREFIX_TRANS</b></a>]  Theorem

      |- ‚àÄx y z. y ‚âº x ‚àß z ‚âº y ‚áí z ‚âº x

   [<a name="LAST_MAP_CONS-val"><b>LAST_MAP_CONS</b></a>]  Theorem

      |- ‚àÄb h t. ‚àÉx. LAST (MAP (CONS b) (h::t)) = b::x

   [<a name="LAST_MEM-val"><b>LAST_MEM</b></a>]  Theorem

      |- ‚àÄh t. MEM (LAST (h::t)) (h::t)

   [<a name="LENGTH_FILTER-val"><b>LENGTH_FILTER</b></a>]  Theorem

      |- ‚àÄP l. LENGTH (FILTER P l) ‚â§ LENGTH l

   [<a name="MAP_ID-val"><b>MAP_ID</b></a>]  Theorem

      |- ‚àÄl. MAP (Œªx. x) l = l

   [<a name="MAP_MEM-val"><b>MAP_MEM</b></a>]  Theorem

      |- ‚àÄf l x. MEM x (MAP f l) ‚áî ‚àÉy. MEM y l ‚àß (x = f y)

   [<a name="MEM_FILTER-val"><b>MEM_FILTER</b></a>]  Theorem

      |- ‚àÄP l x. MEM x (FILTER P l) ‚áí MEM x l

   [<a name="MEM_NIL-val"><b>MEM_NIL</b></a>]  Theorem

      |- ‚àÄl. (‚àÄx. ¬¨MEM x l) ‚áî (l = [])

   [<a name="MEM_NIL_MAP_CONS-val"><b>MEM_NIL_MAP_CONS</b></a>]  Theorem

      |- ‚àÄx l. ¬¨MEM [] (MAP (CONS x) l)

   [<a name="MOD_TWO-val"><b>MOD_TWO</b></a>]  Theorem

      |- ‚àÄn. n MOD 2 = if EVEN n then 0 else 1

   [<a name="ONE_MINUS_HALF-val"><b>ONE_MINUS_HALF</b></a>]  Theorem

      |- 1 ‚àí 1 / 2 = 1 / 2

   [<a name="POW_HALF_EXP-val"><b>POW_HALF_EXP</b></a>]  Theorem

      |- ‚àÄn. (1 / 2) pow n = inv (&(2 ** n))

   [<a name="POW_HALF_MONO-val"><b>POW_HALF_MONO</b></a>]  Theorem

      |- ‚àÄm n. m ‚â§ n ‚áí (1 / 2) pow n ‚â§ (1 / 2) pow m

   [<a name="POW_HALF_POS-val"><b>POW_HALF_POS</b></a>]  Theorem

      |- ‚àÄn. 0 &lt; (1 / 2) pow n

   [<a name="POW_HALF_TWICE-val"><b>POW_HALF_TWICE</b></a>]  Theorem

      |- ‚àÄn. (1 / 2) pow n = 2 * (1 / 2) pow SUC n

   [<a name="RAND_THM-val"><b>RAND_THM</b></a>]  Theorem

      |- ‚àÄf x y. (x = y) ‚áí (f x = f y)

   [<a name="REAL_INF_MIN-val"><b>REAL_INF_MIN</b></a>]  Theorem

      |- ‚àÄP z. P z ‚àß (‚àÄx. P x ‚áí z ‚â§ x) ‚áí (inf P = z)

   [<a name="REAL_INVINV_ALL-val"><b>REAL_INVINV_ALL</b></a>]  Theorem

      |- ‚àÄx. inv (inv x) = x

   [<a name="REAL_LE_EQ-val"><b>REAL_LE_EQ</b></a>]  Theorem

      |- ‚àÄx y. x ‚â§ y ‚àß y ‚â§ x ‚áí (x = y)

   [<a name="REAL_LE_INV_LE-val"><b>REAL_LE_INV_LE</b></a>]  Theorem

      |- ‚àÄx y. 0 &lt; x ‚àß x ‚â§ y ‚áí inv y ‚â§ inv x

   [<a name="REAL_POW-val"><b>REAL_POW</b></a>]  Theorem

      |- ‚àÄm n. &m pow n = &(m ** n)

   [<a name="REAL_SUP_EXISTS_UNIQUE-val"><b>REAL_SUP_EXISTS_UNIQUE</b></a>]  Theorem

      |- ‚àÄP.
           (‚àÉx. P x) ‚àß (‚àÉz. ‚àÄx. P x ‚áí x ‚â§ z) ‚áí
           ‚àÉ!s. ‚àÄy. (‚àÉx. P x ‚àß y &lt; x) ‚áî y &lt; s

   [<a name="REAL_SUP_LE_X-val"><b>REAL_SUP_LE_X</b></a>]  Theorem

      |- ‚àÄP x. (‚àÉr. P r) ‚àß (‚àÄr. P r ‚áí r ‚â§ x) ‚áí sup P ‚â§ x

   [<a name="REAL_SUP_MAX-val"><b>REAL_SUP_MAX</b></a>]  Theorem

      |- ‚àÄP z. P z ‚àß (‚àÄx. P x ‚áí x ‚â§ z) ‚áí (sup P = z)

   [<a name="REAL_X_LE_SUP-val"><b>REAL_X_LE_SUP</b></a>]  Theorem

      |- ‚àÄP x.
           (‚àÉr. P r) ‚àß (‚àÉz. ‚àÄr. P r ‚áí r ‚â§ z) ‚àß (‚àÉr. P r ‚àß x ‚â§ r) ‚áí
           x ‚â§ sup P

   [<a name="SET_EQ_EXT-val"><b>SET_EQ_EXT</b></a>]  Theorem

      |- ‚àÄs t. (s = t) ‚áî ‚àÄv. v ‚àà s ‚áî v ‚àà t

   [<a name="SUBSET_EQ-val"><b>SUBSET_EQ</b></a>]  Theorem

      |- ‚àÄs t. (s = t) ‚áî s ‚äÜ t ‚àß t ‚äÜ s

   [<a name="SUBSET_EQ_DECOMP-val"><b>SUBSET_EQ_DECOMP</b></a>]  Theorem

      |- ‚àÄs t. s ‚äÜ t ‚àß t ‚äÜ s ‚áí (s = t)

   [<a name="UNION_DEF_ALT-val"><b>UNION_DEF_ALT</b></a>]  Theorem

      |- ‚àÄs t. s ‚à™ t = (Œªx. s x ‚à® t x)

   [<a name="UNION_DISJOINT_SPLIT-val"><b>UNION_DISJOINT_SPLIT</b></a>]  Theorem

      |- ‚àÄs t u. (s ‚à™ t = s ‚à™ u) ‚àß (s ‚à© t = ‚àÖ) ‚àß (s ‚à© u = ‚àÖ) ‚áí (t = u)

   [<a name="X_HALF_HALF-val"><b>X_HALF_HALF</b></a>]  Theorem

      |- ‚àÄx. 1 / 2 * x + 1 / 2 * x = x


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/prob/prob_extraScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-8</a></em></p></body></html>
