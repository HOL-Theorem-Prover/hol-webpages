<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure arithmeticTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure arithmeticTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/num/theories/arithmeticScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature arithmeticTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#ABS_DIFF_def-val">ABS_DIFF_def</a> : thm
<a name="line7"></a>    val <a href="#ADD-val">ADD</a> : thm
<a name="line8"></a>    val <a href="#ALT_ZERO-val">ALT_ZERO</a> : thm
<a name="line9"></a>    val <a href="#BIT1-val">BIT1</a> : thm
<a name="line10"></a>    val <a href="#BIT2-val">BIT2</a> : thm
<a name="line11"></a>    val <a href="#DIV2_def-val">DIV2_def</a> : thm
<a name="line12"></a>    val <a href="#DIVISION-val">DIVISION</a> : thm
<a name="line13"></a>    val <a href="#DIVMOD_DEF-val">DIVMOD_DEF</a> : thm
<a name="line14"></a>    val <a href="#DIV_2EXP_def-val">DIV_2EXP_def</a> : thm
<a name="line15"></a>    val <a href="#EVEN-val">EVEN</a> : thm
<a name="line16"></a>    val <a href="#EXP-val">EXP</a> : thm
<a name="line17"></a>    val <a href="#FACT-val">FACT</a> : thm
<a name="line18"></a>    val <a href="#FUNPOW-val">FUNPOW</a> : thm
<a name="line19"></a>    val <a href="#GREATER_DEF-val">GREATER_DEF</a> : thm
<a name="line20"></a>    val <a href="#GREATER_OR_EQ-val">GREATER_OR_EQ</a> : thm
<a name="line21"></a>    val <a href="#LESS_OR_EQ-val">LESS_OR_EQ</a> : thm
<a name="line22"></a>    val <a href="#MAX_DEF-val">MAX_DEF</a> : thm
<a name="line23"></a>    val <a href="#MIN_DEF-val">MIN_DEF</a> : thm
<a name="line24"></a>    val <a href="#MODEQ_DEF-val">MODEQ_DEF</a> : thm
<a name="line25"></a>    val <a href="#MOD_2EXP_def-val">MOD_2EXP_def</a> : thm
<a name="line26"></a>    val <a href="#MULT-val">MULT</a> : thm
<a name="line27"></a>    val <a href="#NRC-val">NRC</a> : thm
<a name="line28"></a>    val <a href="#NUMERAL_DEF-val">NUMERAL_DEF</a> : thm
<a name="line29"></a>    val <a href="#ODD-val">ODD</a> : thm
<a name="line30"></a>    val <a href="#SUB-val">SUB</a> : thm
<a name="line31"></a>    val <a href="#findq_def-val">findq_def</a> : thm
<a name="line32"></a>    val <a href="#nat_elim__magic-val">nat_elim__magic</a> : thm
<a name="line33"></a>    val <a href="#num_case_def-val">num_case_def</a> : thm
<a name="line34"></a>
<a name="line35"></a>  (*  Theorems  *)
<a name="line36"></a>    val <a href="#ABS_DIFF_ADD_SAME-val">ABS_DIFF_ADD_SAME</a> : thm
<a name="line37"></a>    val <a href="#ABS_DIFF_COMM-val">ABS_DIFF_COMM</a> : thm
<a name="line38"></a>    val <a href="#ABS_DIFF_EQS-val">ABS_DIFF_EQS</a> : thm
<a name="line39"></a>    val <a href="#ABS_DIFF_EQ_0-val">ABS_DIFF_EQ_0</a> : thm
<a name="line40"></a>    val <a href="#ABS_DIFF_SUMS-val">ABS_DIFF_SUMS</a> : thm
<a name="line41"></a>    val <a href="#ABS_DIFF_SYM-val">ABS_DIFF_SYM</a> : thm
<a name="line42"></a>    val <a href="#ABS_DIFF_TRIANGLE-val">ABS_DIFF_TRIANGLE</a> : thm
<a name="line43"></a>    val <a href="#ABS_DIFF_ZERO-val">ABS_DIFF_ZERO</a> : thm
<a name="line44"></a>    val <a href="#ADD1-val">ADD1</a> : thm
<a name="line45"></a>    val <a href="#ADD_0-val">ADD_0</a> : thm
<a name="line46"></a>    val <a href="#ADD_ASSOC-val">ADD_ASSOC</a> : thm
<a name="line47"></a>    val <a href="#ADD_CLAUSES-val">ADD_CLAUSES</a> : thm
<a name="line48"></a>    val <a href="#ADD_COMM-val">ADD_COMM</a> : thm
<a name="line49"></a>    val <a href="#ADD_DIV_ADD_DIV-val">ADD_DIV_ADD_DIV</a> : thm
<a name="line50"></a>    val <a href="#ADD_DIV_RWT-val">ADD_DIV_RWT</a> : thm
<a name="line51"></a>    val <a href="#ADD_EQ_0-val">ADD_EQ_0</a> : thm
<a name="line52"></a>    val <a href="#ADD_EQ_1-val">ADD_EQ_1</a> : thm
<a name="line53"></a>    val <a href="#ADD_EQ_SUB-val">ADD_EQ_SUB</a> : thm
<a name="line54"></a>    val <a href="#ADD_INV_0-val">ADD_INV_0</a> : thm
<a name="line55"></a>    val <a href="#ADD_INV_0_EQ-val">ADD_INV_0_EQ</a> : thm
<a name="line56"></a>    val <a href="#ADD_MOD-val">ADD_MOD</a> : thm
<a name="line57"></a>    val <a href="#ADD_MODULUS-val">ADD_MODULUS</a> : thm
<a name="line58"></a>    val <a href="#ADD_MODULUS_LEFT-val">ADD_MODULUS_LEFT</a> : thm
<a name="line59"></a>    val <a href="#ADD_MODULUS_RIGHT-val">ADD_MODULUS_RIGHT</a> : thm
<a name="line60"></a>    val <a href="#ADD_MONO_LESS_EQ-val">ADD_MONO_LESS_EQ</a> : thm
<a name="line61"></a>    val <a href="#ADD_SUB-val">ADD_SUB</a> : thm
<a name="line62"></a>    val <a href="#ADD_SUC-val">ADD_SUC</a> : thm
<a name="line63"></a>    val <a href="#ADD_SYM-val">ADD_SYM</a> : thm
<a name="line64"></a>    val <a href="#BOUNDED_EXISTS_THM-val">BOUNDED_EXISTS_THM</a> : thm
<a name="line65"></a>    val <a href="#BOUNDED_FORALL_THM-val">BOUNDED_FORALL_THM</a> : thm
<a name="line66"></a>    val <a href="#CANCEL_SUB-val">CANCEL_SUB</a> : thm
<a name="line67"></a>    val <a href="#COMPLETE_INDUCTION-val">COMPLETE_INDUCTION</a> : thm
<a name="line68"></a>    val <a href="#DA-val">DA</a> : thm
<a name="line69"></a>    val <a href="#DIVMOD_CALC-val">DIVMOD_CALC</a> : thm
<a name="line70"></a>    val <a href="#DIVMOD_CORRECT-val">DIVMOD_CORRECT</a> : thm
<a name="line71"></a>    val <a href="#DIVMOD_ID-val">DIVMOD_ID</a> : thm
<a name="line72"></a>    val <a href="#DIVMOD_THM-val">DIVMOD_THM</a> : thm
<a name="line73"></a>    val <a href="#DIV_1-val">DIV_1</a> : thm
<a name="line74"></a>    val <a href="#DIV_DIV_DIV_MULT-val">DIV_DIV_DIV_MULT</a> : thm
<a name="line75"></a>    val <a href="#DIV_EQ_X-val">DIV_EQ_X</a> : thm
<a name="line76"></a>    val <a href="#DIV_LESS-val">DIV_LESS</a> : thm
<a name="line77"></a>    val <a href="#DIV_LESS_EQ-val">DIV_LESS_EQ</a> : thm
<a name="line78"></a>    val <a href="#DIV_LE_MONOTONE-val">DIV_LE_MONOTONE</a> : thm
<a name="line79"></a>    val <a href="#DIV_LE_X-val">DIV_LE_X</a> : thm
<a name="line80"></a>    val <a href="#DIV_LT_X-val">DIV_LT_X</a> : thm
<a name="line81"></a>    val <a href="#DIV_MOD_MOD_DIV-val">DIV_MOD_MOD_DIV</a> : thm
<a name="line82"></a>    val <a href="#DIV_MULT-val">DIV_MULT</a> : thm
<a name="line83"></a>    val <a href="#DIV_ONE-val">DIV_ONE</a> : thm
<a name="line84"></a>    val <a href="#DIV_P-val">DIV_P</a> : thm
<a name="line85"></a>    val <a href="#DIV_P_UNIV-val">DIV_P_UNIV</a> : thm
<a name="line86"></a>    val <a href="#DIV_SUB-val">DIV_SUB</a> : thm
<a name="line87"></a>    val <a href="#DIV_UNIQUE-val">DIV_UNIQUE</a> : thm
<a name="line88"></a>    val <a href="#DOUBLE_LT-val">DOUBLE_LT</a> : thm
<a name="line89"></a>    val <a href="#EQ_ADD_LCANCEL-val">EQ_ADD_LCANCEL</a> : thm
<a name="line90"></a>    val <a href="#EQ_ADD_RCANCEL-val">EQ_ADD_RCANCEL</a> : thm
<a name="line91"></a>    val <a href="#EQ_LESS_EQ-val">EQ_LESS_EQ</a> : thm
<a name="line92"></a>    val <a href="#EQ_MONO_ADD_EQ-val">EQ_MONO_ADD_EQ</a> : thm
<a name="line93"></a>    val <a href="#EQ_MULT_LCANCEL-val">EQ_MULT_LCANCEL</a> : thm
<a name="line94"></a>    val <a href="#EVEN_ADD-val">EVEN_ADD</a> : thm
<a name="line95"></a>    val <a href="#EVEN_AND_ODD-val">EVEN_AND_ODD</a> : thm
<a name="line96"></a>    val <a href="#EVEN_DOUBLE-val">EVEN_DOUBLE</a> : thm
<a name="line97"></a>    val <a href="#EVEN_EXISTS-val">EVEN_EXISTS</a> : thm
<a name="line98"></a>    val <a href="#EVEN_EXP-val">EVEN_EXP</a> : thm
<a name="line99"></a>    val <a href="#EVEN_MOD2-val">EVEN_MOD2</a> : thm
<a name="line100"></a>    val <a href="#EVEN_MULT-val">EVEN_MULT</a> : thm
<a name="line101"></a>    val <a href="#EVEN_ODD-val">EVEN_ODD</a> : thm
<a name="line102"></a>    val <a href="#EVEN_ODD_EXISTS-val">EVEN_ODD_EXISTS</a> : thm
<a name="line103"></a>    val <a href="#EVEN_OR_ODD-val">EVEN_OR_ODD</a> : thm
<a name="line104"></a>    val <a href="#EXISTS_GREATEST-val">EXISTS_GREATEST</a> : thm
<a name="line105"></a>    val <a href="#EXISTS_NUM-val">EXISTS_NUM</a> : thm
<a name="line106"></a>    val <a href="#EXP2_LT-val">EXP2_LT</a> : thm
<a name="line107"></a>    val <a href="#EXP_1-val">EXP_1</a> : thm
<a name="line108"></a>    val <a href="#EXP_ADD-val">EXP_ADD</a> : thm
<a name="line109"></a>    val <a href="#EXP_ALWAYS_BIG_ENOUGH-val">EXP_ALWAYS_BIG_ENOUGH</a> : thm
<a name="line110"></a>    val <a href="#EXP_BASE_INJECTIVE-val">EXP_BASE_INJECTIVE</a> : thm
<a name="line111"></a>    val <a href="#EXP_BASE_LEQ_MONO_IMP-val">EXP_BASE_LEQ_MONO_IMP</a> : thm
<a name="line112"></a>    val <a href="#EXP_BASE_LEQ_MONO_SUC_IMP-val">EXP_BASE_LEQ_MONO_SUC_IMP</a> : thm
<a name="line113"></a>    val <a href="#EXP_BASE_LE_IFF-val">EXP_BASE_LE_IFF</a> : thm
<a name="line114"></a>    val <a href="#EXP_BASE_LE_MONO-val">EXP_BASE_LE_MONO</a> : thm
<a name="line115"></a>    val <a href="#EXP_BASE_LT_MONO-val">EXP_BASE_LT_MONO</a> : thm
<a name="line116"></a>    val <a href="#EXP_BASE_MULT-val">EXP_BASE_MULT</a> : thm
<a name="line117"></a>    val <a href="#EXP_EQ_0-val">EXP_EQ_0</a> : thm
<a name="line118"></a>    val <a href="#EXP_EQ_1-val">EXP_EQ_1</a> : thm
<a name="line119"></a>    val <a href="#EXP_EXP_INJECTIVE-val">EXP_EXP_INJECTIVE</a> : thm
<a name="line120"></a>    val <a href="#EXP_EXP_LE_MONO-val">EXP_EXP_LE_MONO</a> : thm
<a name="line121"></a>    val <a href="#EXP_EXP_LT_MONO-val">EXP_EXP_LT_MONO</a> : thm
<a name="line122"></a>    val <a href="#EXP_EXP_MULT-val">EXP_EXP_MULT</a> : thm
<a name="line123"></a>    val <a href="#EXP_SUB-val">EXP_SUB</a> : thm
<a name="line124"></a>    val <a href="#EXP_SUB_NUMERAL-val">EXP_SUB_NUMERAL</a> : thm
<a name="line125"></a>    val <a href="#FACT_LESS-val">FACT_LESS</a> : thm
<a name="line126"></a>    val <a href="#FORALL_NUM-val">FORALL_NUM</a> : thm
<a name="line127"></a>    val <a href="#FORALL_NUM_THM-val">FORALL_NUM_THM</a> : thm
<a name="line128"></a>    val <a href="#FUNPOW_0-val">FUNPOW_0</a> : thm
<a name="line129"></a>    val <a href="#FUNPOW_1-val">FUNPOW_1</a> : thm
<a name="line130"></a>    val <a href="#FUNPOW_ADD-val">FUNPOW_ADD</a> : thm
<a name="line131"></a>    val <a href="#FUNPOW_SUC-val">FUNPOW_SUC</a> : thm
<a name="line132"></a>    val <a href="#FUN_EQ_LEMMA-val">FUN_EQ_LEMMA</a> : thm
<a name="line133"></a>    val <a href="#GREATER_EQ-val">GREATER_EQ</a> : thm
<a name="line134"></a>    val <a href="#INV_PRE_EQ-val">INV_PRE_EQ</a> : thm
<a name="line135"></a>    val <a href="#INV_PRE_LESS-val">INV_PRE_LESS</a> : thm
<a name="line136"></a>    val <a href="#INV_PRE_LESS_EQ-val">INV_PRE_LESS_EQ</a> : thm
<a name="line137"></a>    val <a href="#LE-val">LE</a> : thm
<a name="line138"></a>    val <a href="#LEFT_ADD_DISTRIB-val">LEFT_ADD_DISTRIB</a> : thm
<a name="line139"></a>    val <a href="#LEFT_SUB_DISTRIB-val">LEFT_SUB_DISTRIB</a> : thm
<a name="line140"></a>    val <a href="#LESS_0_CASES-val">LESS_0_CASES</a> : thm
<a name="line141"></a>    val <a href="#LESS_ADD-val">LESS_ADD</a> : thm
<a name="line142"></a>    val <a href="#LESS_ADD_1-val">LESS_ADD_1</a> : thm
<a name="line143"></a>    val <a href="#LESS_ADD_NONZERO-val">LESS_ADD_NONZERO</a> : thm
<a name="line144"></a>    val <a href="#LESS_ADD_SUC-val">LESS_ADD_SUC</a> : thm
<a name="line145"></a>    val <a href="#LESS_ANTISYM-val">LESS_ANTISYM</a> : thm
<a name="line146"></a>    val <a href="#LESS_CASES-val">LESS_CASES</a> : thm
<a name="line147"></a>    val <a href="#LESS_CASES_IMP-val">LESS_CASES_IMP</a> : thm
<a name="line148"></a>    val <a href="#LESS_DIV_EQ_ZERO-val">LESS_DIV_EQ_ZERO</a> : thm
<a name="line149"></a>    val <a href="#LESS_EQ-val">LESS_EQ</a> : thm
<a name="line150"></a>    val <a href="#LESS_EQUAL_ADD-val">LESS_EQUAL_ADD</a> : thm
<a name="line151"></a>    val <a href="#LESS_EQUAL_ANTISYM-val">LESS_EQUAL_ANTISYM</a> : thm
<a name="line152"></a>    val <a href="#LESS_EQUAL_DIFF-val">LESS_EQUAL_DIFF</a> : thm
<a name="line153"></a>    val <a href="#LESS_EQ_0-val">LESS_EQ_0</a> : thm
<a name="line154"></a>    val <a href="#LESS_EQ_ADD-val">LESS_EQ_ADD</a> : thm
<a name="line155"></a>    val <a href="#LESS_EQ_ADD_EXISTS-val">LESS_EQ_ADD_EXISTS</a> : thm
<a name="line156"></a>    val <a href="#LESS_EQ_ADD_SUB-val">LESS_EQ_ADD_SUB</a> : thm
<a name="line157"></a>    val <a href="#LESS_EQ_ANTISYM-val">LESS_EQ_ANTISYM</a> : thm
<a name="line158"></a>    val <a href="#LESS_EQ_CASES-val">LESS_EQ_CASES</a> : thm
<a name="line159"></a>    val <a href="#LESS_EQ_EXISTS-val">LESS_EQ_EXISTS</a> : thm
<a name="line160"></a>    val <a href="#LESS_EQ_IMP_LESS_SUC-val">LESS_EQ_IMP_LESS_SUC</a> : thm
<a name="line161"></a>    val <a href="#LESS_EQ_LESS_EQ_MONO-val">LESS_EQ_LESS_EQ_MONO</a> : thm
<a name="line162"></a>    val <a href="#LESS_EQ_LESS_TRANS-val">LESS_EQ_LESS_TRANS</a> : thm
<a name="line163"></a>    val <a href="#LESS_EQ_MONO-val">LESS_EQ_MONO</a> : thm
<a name="line164"></a>    val <a href="#LESS_EQ_MONO_ADD_EQ-val">LESS_EQ_MONO_ADD_EQ</a> : thm
<a name="line165"></a>    val <a href="#LESS_EQ_REFL-val">LESS_EQ_REFL</a> : thm
<a name="line166"></a>    val <a href="#LESS_EQ_SUB_LESS-val">LESS_EQ_SUB_LESS</a> : thm
<a name="line167"></a>    val <a href="#LESS_EQ_SUC_REFL-val">LESS_EQ_SUC_REFL</a> : thm
<a name="line168"></a>    val <a href="#LESS_EQ_TRANS-val">LESS_EQ_TRANS</a> : thm
<a name="line169"></a>    val <a href="#LESS_EXP_SUC_MONO-val">LESS_EXP_SUC_MONO</a> : thm
<a name="line170"></a>    val <a href="#LESS_IMP_LESS_ADD-val">LESS_IMP_LESS_ADD</a> : thm
<a name="line171"></a>    val <a href="#LESS_IMP_LESS_OR_EQ-val">LESS_IMP_LESS_OR_EQ</a> : thm
<a name="line172"></a>    val <a href="#LESS_LESS_CASES-val">LESS_LESS_CASES</a> : thm
<a name="line173"></a>    val <a href="#LESS_LESS_EQ_TRANS-val">LESS_LESS_EQ_TRANS</a> : thm
<a name="line174"></a>    val <a href="#LESS_LESS_SUC-val">LESS_LESS_SUC</a> : thm
<a name="line175"></a>    val <a href="#LESS_MOD-val">LESS_MOD</a> : thm
<a name="line176"></a>    val <a href="#LESS_MONO_ADD-val">LESS_MONO_ADD</a> : thm
<a name="line177"></a>    val <a href="#LESS_MONO_ADD_EQ-val">LESS_MONO_ADD_EQ</a> : thm
<a name="line178"></a>    val <a href="#LESS_MONO_ADD_INV-val">LESS_MONO_ADD_INV</a> : thm
<a name="line179"></a>    val <a href="#LESS_MONO_EQ-val">LESS_MONO_EQ</a> : thm
<a name="line180"></a>    val <a href="#LESS_MONO_MULT-val">LESS_MONO_MULT</a> : thm
<a name="line181"></a>    val <a href="#LESS_MONO_MULT2-val">LESS_MONO_MULT2</a> : thm
<a name="line182"></a>    val <a href="#LESS_MONO_REV-val">LESS_MONO_REV</a> : thm
<a name="line183"></a>    val <a href="#LESS_MULT2-val">LESS_MULT2</a> : thm
<a name="line184"></a>    val <a href="#LESS_MULT_MONO-val">LESS_MULT_MONO</a> : thm
<a name="line185"></a>    val <a href="#LESS_NOT_SUC-val">LESS_NOT_SUC</a> : thm
<a name="line186"></a>    val <a href="#LESS_OR-val">LESS_OR</a> : thm
<a name="line187"></a>    val <a href="#LESS_OR_EQ_ADD-val">LESS_OR_EQ_ADD</a> : thm
<a name="line188"></a>    val <a href="#LESS_STRONG_ADD-val">LESS_STRONG_ADD</a> : thm
<a name="line189"></a>    val <a href="#LESS_SUB_ADD_LESS-val">LESS_SUB_ADD_LESS</a> : thm
<a name="line190"></a>    val <a href="#LESS_SUC_EQ_COR-val">LESS_SUC_EQ_COR</a> : thm
<a name="line191"></a>    val <a href="#LESS_SUC_NOT-val">LESS_SUC_NOT</a> : thm
<a name="line192"></a>    val <a href="#LESS_TRANS-val">LESS_TRANS</a> : thm
<a name="line193"></a>    val <a href="#LE_ADD_LCANCEL-val">LE_ADD_LCANCEL</a> : thm
<a name="line194"></a>    val <a href="#LE_ADD_RCANCEL-val">LE_ADD_RCANCEL</a> : thm
<a name="line195"></a>    val <a href="#LE_LT1-val">LE_LT1</a> : thm
<a name="line196"></a>    val <a href="#LE_MULT_CANCEL_LBARE-val">LE_MULT_CANCEL_LBARE</a> : thm
<a name="line197"></a>    val <a href="#LE_MULT_CANCEL_RBARE-val">LE_MULT_CANCEL_RBARE</a> : thm
<a name="line198"></a>    val <a href="#LE_MULT_LCANCEL-val">LE_MULT_LCANCEL</a> : thm
<a name="line199"></a>    val <a href="#LE_MULT_RCANCEL-val">LE_MULT_RCANCEL</a> : thm
<a name="line200"></a>    val <a href="#LE_SUB_RCANCEL-val">LE_SUB_RCANCEL</a> : thm
<a name="line201"></a>    val <a href="#LT_ADD_LCANCEL-val">LT_ADD_LCANCEL</a> : thm
<a name="line202"></a>    val <a href="#LT_ADD_RCANCEL-val">LT_ADD_RCANCEL</a> : thm
<a name="line203"></a>    val <a href="#LT_MULT_CANCEL_LBARE-val">LT_MULT_CANCEL_LBARE</a> : thm
<a name="line204"></a>    val <a href="#LT_MULT_CANCEL_RBARE-val">LT_MULT_CANCEL_RBARE</a> : thm
<a name="line205"></a>    val <a href="#LT_MULT_LCANCEL-val">LT_MULT_LCANCEL</a> : thm
<a name="line206"></a>    val <a href="#LT_MULT_RCANCEL-val">LT_MULT_RCANCEL</a> : thm
<a name="line207"></a>    val <a href="#LT_SUB_RCANCEL-val">LT_SUB_RCANCEL</a> : thm
<a name="line208"></a>    val <a href="#MAX_0-val">MAX_0</a> : thm
<a name="line209"></a>    val <a href="#MAX_ASSOC-val">MAX_ASSOC</a> : thm
<a name="line210"></a>    val <a href="#MAX_COMM-val">MAX_COMM</a> : thm
<a name="line211"></a>    val <a href="#MAX_IDEM-val">MAX_IDEM</a> : thm
<a name="line212"></a>    val <a href="#MAX_LE-val">MAX_LE</a> : thm
<a name="line213"></a>    val <a href="#MAX_LT-val">MAX_LT</a> : thm
<a name="line214"></a>    val <a href="#MIN_0-val">MIN_0</a> : thm
<a name="line215"></a>    val <a href="#MIN_ASSOC-val">MIN_ASSOC</a> : thm
<a name="line216"></a>    val <a href="#MIN_COMM-val">MIN_COMM</a> : thm
<a name="line217"></a>    val <a href="#MIN_IDEM-val">MIN_IDEM</a> : thm
<a name="line218"></a>    val <a href="#MIN_LE-val">MIN_LE</a> : thm
<a name="line219"></a>    val <a href="#MIN_LT-val">MIN_LT</a> : thm
<a name="line220"></a>    val <a href="#MIN_MAX_EQ-val">MIN_MAX_EQ</a> : thm
<a name="line221"></a>    val <a href="#MIN_MAX_LE-val">MIN_MAX_LE</a> : thm
<a name="line222"></a>    val <a href="#MIN_MAX_LT-val">MIN_MAX_LT</a> : thm
<a name="line223"></a>    val <a href="#MIN_MAX_PRED-val">MIN_MAX_PRED</a> : thm
<a name="line224"></a>    val <a href="#MODEQ_0-val">MODEQ_0</a> : thm
<a name="line225"></a>    val <a href="#MODEQ_0_CONG-val">MODEQ_0_CONG</a> : thm
<a name="line226"></a>    val <a href="#MODEQ_INTRO_CONG-val">MODEQ_INTRO_CONG</a> : thm
<a name="line227"></a>    val <a href="#MODEQ_MOD-val">MODEQ_MOD</a> : thm
<a name="line228"></a>    val <a href="#MODEQ_MULT_CONG-val">MODEQ_MULT_CONG</a> : thm
<a name="line229"></a>    val <a href="#MODEQ_NONZERO_MODEQUALITY-val">MODEQ_NONZERO_MODEQUALITY</a> : thm
<a name="line230"></a>    val <a href="#MODEQ_NUMERAL-val">MODEQ_NUMERAL</a> : thm
<a name="line231"></a>    val <a href="#MODEQ_PLUS_CONG-val">MODEQ_PLUS_CONG</a> : thm
<a name="line232"></a>    val <a href="#MODEQ_REFL-val">MODEQ_REFL</a> : thm
<a name="line233"></a>    val <a href="#MODEQ_SYM-val">MODEQ_SYM</a> : thm
<a name="line234"></a>    val <a href="#MODEQ_THM-val">MODEQ_THM</a> : thm
<a name="line235"></a>    val <a href="#MODEQ_TRANS-val">MODEQ_TRANS</a> : thm
<a name="line236"></a>    val <a href="#MOD_1-val">MOD_1</a> : thm
<a name="line237"></a>    val <a href="#MOD_2-val">MOD_2</a> : thm
<a name="line238"></a>    val <a href="#MOD_COMMON_FACTOR-val">MOD_COMMON_FACTOR</a> : thm
<a name="line239"></a>    val <a href="#MOD_ELIM-val">MOD_ELIM</a> : thm
<a name="line240"></a>    val <a href="#MOD_EQ_0-val">MOD_EQ_0</a> : thm
<a name="line241"></a>    val <a href="#MOD_EQ_0_DIVISOR-val">MOD_EQ_0_DIVISOR</a> : thm
<a name="line242"></a>    val <a href="#MOD_LESS-val">MOD_LESS</a> : thm
<a name="line243"></a>    val <a href="#MOD_LESS_EQ-val">MOD_LESS_EQ</a> : thm
<a name="line244"></a>    val <a href="#MOD_LIFT_PLUS-val">MOD_LIFT_PLUS</a> : thm
<a name="line245"></a>    val <a href="#MOD_LIFT_PLUS_IFF-val">MOD_LIFT_PLUS_IFF</a> : thm
<a name="line246"></a>    val <a href="#MOD_MOD-val">MOD_MOD</a> : thm
<a name="line247"></a>    val <a href="#MOD_MULT-val">MOD_MULT</a> : thm
<a name="line248"></a>    val <a href="#MOD_MULT_MOD-val">MOD_MULT_MOD</a> : thm
<a name="line249"></a>    val <a href="#MOD_ONE-val">MOD_ONE</a> : thm
<a name="line250"></a>    val <a href="#MOD_P-val">MOD_P</a> : thm
<a name="line251"></a>    val <a href="#MOD_PLUS-val">MOD_PLUS</a> : thm
<a name="line252"></a>    val <a href="#MOD_P_UNIV-val">MOD_P_UNIV</a> : thm
<a name="line253"></a>    val <a href="#MOD_SUB-val">MOD_SUB</a> : thm
<a name="line254"></a>    val <a href="#MOD_SUC-val">MOD_SUC</a> : thm
<a name="line255"></a>    val <a href="#MOD_SUC_IFF-val">MOD_SUC_IFF</a> : thm
<a name="line256"></a>    val <a href="#MOD_TIMES-val">MOD_TIMES</a> : thm
<a name="line257"></a>    val <a href="#MOD_TIMES2-val">MOD_TIMES2</a> : thm
<a name="line258"></a>    val <a href="#MOD_TIMES_SUB-val">MOD_TIMES_SUB</a> : thm
<a name="line259"></a>    val <a href="#MOD_UNIQUE-val">MOD_UNIQUE</a> : thm
<a name="line260"></a>    val <a href="#MULT_0-val">MULT_0</a> : thm
<a name="line261"></a>    val <a href="#MULT_ASSOC-val">MULT_ASSOC</a> : thm
<a name="line262"></a>    val <a href="#MULT_CLAUSES-val">MULT_CLAUSES</a> : thm
<a name="line263"></a>    val <a href="#MULT_COMM-val">MULT_COMM</a> : thm
<a name="line264"></a>    val <a href="#MULT_DIV-val">MULT_DIV</a> : thm
<a name="line265"></a>    val <a href="#MULT_EQ_0-val">MULT_EQ_0</a> : thm
<a name="line266"></a>    val <a href="#MULT_EQ_1-val">MULT_EQ_1</a> : thm
<a name="line267"></a>    val <a href="#MULT_EQ_DIV-val">MULT_EQ_DIV</a> : thm
<a name="line268"></a>    val <a href="#MULT_EQ_ID-val">MULT_EQ_ID</a> : thm
<a name="line269"></a>    val <a href="#MULT_EXP_MONO-val">MULT_EXP_MONO</a> : thm
<a name="line270"></a>    val <a href="#MULT_INCREASES-val">MULT_INCREASES</a> : thm
<a name="line271"></a>    val <a href="#MULT_LEFT_1-val">MULT_LEFT_1</a> : thm
<a name="line272"></a>    val <a href="#MULT_LESS_EQ_SUC-val">MULT_LESS_EQ_SUC</a> : thm
<a name="line273"></a>    val <a href="#MULT_MONO_EQ-val">MULT_MONO_EQ</a> : thm
<a name="line274"></a>    val <a href="#MULT_RIGHT_1-val">MULT_RIGHT_1</a> : thm
<a name="line275"></a>    val <a href="#MULT_SUC-val">MULT_SUC</a> : thm
<a name="line276"></a>    val <a href="#MULT_SUC_EQ-val">MULT_SUC_EQ</a> : thm
<a name="line277"></a>    val <a href="#MULT_SYM-val">MULT_SYM</a> : thm
<a name="line278"></a>    val <a href="#NORM_0-val">NORM_0</a> : thm
<a name="line279"></a>    val <a href="#NOT_EXP_0-val">NOT_EXP_0</a> : thm
<a name="line280"></a>    val <a href="#NOT_GREATER-val">NOT_GREATER</a> : thm
<a name="line281"></a>    val <a href="#NOT_GREATER_EQ-val">NOT_GREATER_EQ</a> : thm
<a name="line282"></a>    val <a href="#NOT_LEQ-val">NOT_LEQ</a> : thm
<a name="line283"></a>    val <a href="#NOT_LESS-val">NOT_LESS</a> : thm
<a name="line284"></a>    val <a href="#NOT_LESS_EQUAL-val">NOT_LESS_EQUAL</a> : thm
<a name="line285"></a>    val <a href="#NOT_NUM_EQ-val">NOT_NUM_EQ</a> : thm
<a name="line286"></a>    val <a href="#NOT_ODD_EQ_EVEN-val">NOT_ODD_EQ_EVEN</a> : thm
<a name="line287"></a>    val <a href="#NOT_STRICTLY_DECREASING-val">NOT_STRICTLY_DECREASING</a> : thm
<a name="line288"></a>    val <a href="#NOT_SUC_ADD_LESS_EQ-val">NOT_SUC_ADD_LESS_EQ</a> : thm
<a name="line289"></a>    val <a href="#NOT_SUC_LESS_EQ-val">NOT_SUC_LESS_EQ</a> : thm
<a name="line290"></a>    val <a href="#NOT_SUC_LESS_EQ_0-val">NOT_SUC_LESS_EQ_0</a> : thm
<a name="line291"></a>    val <a href="#NOT_ZERO_LT_ZERO-val">NOT_ZERO_LT_ZERO</a> : thm
<a name="line292"></a>    val <a href="#NRC_0-val">NRC_0</a> : thm
<a name="line293"></a>    val <a href="#NRC_1-val">NRC_1</a> : thm
<a name="line294"></a>    val <a href="#NRC_ADD_E-val">NRC_ADD_E</a> : thm
<a name="line295"></a>    val <a href="#NRC_ADD_EQN-val">NRC_ADD_EQN</a> : thm
<a name="line296"></a>    val <a href="#NRC_ADD_I-val">NRC_ADD_I</a> : thm
<a name="line297"></a>    val <a href="#NRC_RTC-val">NRC_RTC</a> : thm
<a name="line298"></a>    val <a href="#NRC_SUC_RECURSE_LEFT-val">NRC_SUC_RECURSE_LEFT</a> : thm
<a name="line299"></a>    val <a href="#NUMERAL_MULT_EQ_DIV-val">NUMERAL_MULT_EQ_DIV</a> : thm
<a name="line300"></a>    val <a href="#ODD_ADD-val">ODD_ADD</a> : thm
<a name="line301"></a>    val <a href="#ODD_DOUBLE-val">ODD_DOUBLE</a> : thm
<a name="line302"></a>    val <a href="#ODD_EVEN-val">ODD_EVEN</a> : thm
<a name="line303"></a>    val <a href="#ODD_EXISTS-val">ODD_EXISTS</a> : thm
<a name="line304"></a>    val <a href="#ODD_MULT-val">ODD_MULT</a> : thm
<a name="line305"></a>    val <a href="#ODD_OR_EVEN-val">ODD_OR_EVEN</a> : thm
<a name="line306"></a>    val <a href="#ONE-val">ONE</a> : thm
<a name="line307"></a>    val <a href="#ONE_LT_EXP-val">ONE_LT_EXP</a> : thm
<a name="line308"></a>    val <a href="#ONE_LT_MULT-val">ONE_LT_MULT</a> : thm
<a name="line309"></a>    val <a href="#ONE_LT_MULT_IMP-val">ONE_LT_MULT_IMP</a> : thm
<a name="line310"></a>    val <a href="#ONE_MOD-val">ONE_MOD</a> : thm
<a name="line311"></a>    val <a href="#ONE_MOD_IFF-val">ONE_MOD_IFF</a> : thm
<a name="line312"></a>    val <a href="#ONE_ONE_UNBOUNDED-val">ONE_ONE_UNBOUNDED</a> : thm
<a name="line313"></a>    val <a href="#OR_LESS-val">OR_LESS</a> : thm
<a name="line314"></a>    val <a href="#PRE_ELIM_THM-val">PRE_ELIM_THM</a> : thm
<a name="line315"></a>    val <a href="#PRE_SUB-val">PRE_SUB</a> : thm
<a name="line316"></a>    val <a href="#PRE_SUB1-val">PRE_SUB1</a> : thm
<a name="line317"></a>    val <a href="#PRE_SUC_EQ-val">PRE_SUC_EQ</a> : thm
<a name="line318"></a>    val <a href="#RIGHT_ADD_DISTRIB-val">RIGHT_ADD_DISTRIB</a> : thm
<a name="line319"></a>    val <a href="#RIGHT_SUB_DISTRIB-val">RIGHT_SUB_DISTRIB</a> : thm
<a name="line320"></a>    val <a href="#RTC_NRC-val">RTC_NRC</a> : thm
<a name="line321"></a>    val <a href="#RTC_eq_NRC-val">RTC_eq_NRC</a> : thm
<a name="line322"></a>    val <a href="#STRICTLY_INCREASING_ONE_ONE-val">STRICTLY_INCREASING_ONE_ONE</a> : thm
<a name="line323"></a>    val <a href="#STRICTLY_INCREASING_TC-val">STRICTLY_INCREASING_TC</a> : thm
<a name="line324"></a>    val <a href="#STRICTLY_INCREASING_UNBOUNDED-val">STRICTLY_INCREASING_UNBOUNDED</a> : thm
<a name="line325"></a>    val <a href="#SUB_0-val">SUB_0</a> : thm
<a name="line326"></a>    val <a href="#SUB_ADD-val">SUB_ADD</a> : thm
<a name="line327"></a>    val <a href="#SUB_CANCEL-val">SUB_CANCEL</a> : thm
<a name="line328"></a>    val <a href="#SUB_ELIM_THM-val">SUB_ELIM_THM</a> : thm
<a name="line329"></a>    val <a href="#SUB_EQUAL_0-val">SUB_EQUAL_0</a> : thm
<a name="line330"></a>    val <a href="#SUB_EQ_0-val">SUB_EQ_0</a> : thm
<a name="line331"></a>    val <a href="#SUB_EQ_EQ_0-val">SUB_EQ_EQ_0</a> : thm
<a name="line332"></a>    val <a href="#SUB_LEFT_ADD-val">SUB_LEFT_ADD</a> : thm
<a name="line333"></a>    val <a href="#SUB_LEFT_EQ-val">SUB_LEFT_EQ</a> : thm
<a name="line334"></a>    val <a href="#SUB_LEFT_GREATER-val">SUB_LEFT_GREATER</a> : thm
<a name="line335"></a>    val <a href="#SUB_LEFT_GREATER_EQ-val">SUB_LEFT_GREATER_EQ</a> : thm
<a name="line336"></a>    val <a href="#SUB_LEFT_LESS-val">SUB_LEFT_LESS</a> : thm
<a name="line337"></a>    val <a href="#SUB_LEFT_LESS_EQ-val">SUB_LEFT_LESS_EQ</a> : thm
<a name="line338"></a>    val <a href="#SUB_LEFT_SUB-val">SUB_LEFT_SUB</a> : thm
<a name="line339"></a>    val <a href="#SUB_LEFT_SUC-val">SUB_LEFT_SUC</a> : thm
<a name="line340"></a>    val <a href="#SUB_LESS-val">SUB_LESS</a> : thm
<a name="line341"></a>    val <a href="#SUB_LESS_0-val">SUB_LESS_0</a> : thm
<a name="line342"></a>    val <a href="#SUB_LESS_EQ-val">SUB_LESS_EQ</a> : thm
<a name="line343"></a>    val <a href="#SUB_LESS_EQ_ADD-val">SUB_LESS_EQ_ADD</a> : thm
<a name="line344"></a>    val <a href="#SUB_LESS_OR-val">SUB_LESS_OR</a> : thm
<a name="line345"></a>    val <a href="#SUB_MOD-val">SUB_MOD</a> : thm
<a name="line346"></a>    val <a href="#SUB_MONO_EQ-val">SUB_MONO_EQ</a> : thm
<a name="line347"></a>    val <a href="#SUB_PLUS-val">SUB_PLUS</a> : thm
<a name="line348"></a>    val <a href="#SUB_RIGHT_ADD-val">SUB_RIGHT_ADD</a> : thm
<a name="line349"></a>    val <a href="#SUB_RIGHT_EQ-val">SUB_RIGHT_EQ</a> : thm
<a name="line350"></a>    val <a href="#SUB_RIGHT_GREATER-val">SUB_RIGHT_GREATER</a> : thm
<a name="line351"></a>    val <a href="#SUB_RIGHT_GREATER_EQ-val">SUB_RIGHT_GREATER_EQ</a> : thm
<a name="line352"></a>    val <a href="#SUB_RIGHT_LESS-val">SUB_RIGHT_LESS</a> : thm
<a name="line353"></a>    val <a href="#SUB_RIGHT_LESS_EQ-val">SUB_RIGHT_LESS_EQ</a> : thm
<a name="line354"></a>    val <a href="#SUB_RIGHT_SUB-val">SUB_RIGHT_SUB</a> : thm
<a name="line355"></a>    val <a href="#SUB_SUB-val">SUB_SUB</a> : thm
<a name="line356"></a>    val <a href="#SUC_ADD_SYM-val">SUC_ADD_SYM</a> : thm
<a name="line357"></a>    val <a href="#SUC_ELIM_NUMERALS-val">SUC_ELIM_NUMERALS</a> : thm
<a name="line358"></a>    val <a href="#SUC_ELIM_THM-val">SUC_ELIM_THM</a> : thm
<a name="line359"></a>    val <a href="#SUC_MOD-val">SUC_MOD</a> : thm
<a name="line360"></a>    val <a href="#SUC_NOT-val">SUC_NOT</a> : thm
<a name="line361"></a>    val <a href="#SUC_ONE_ADD-val">SUC_ONE_ADD</a> : thm
<a name="line362"></a>    val <a href="#SUC_PRE-val">SUC_PRE</a> : thm
<a name="line363"></a>    val <a href="#SUC_SUB1-val">SUC_SUB1</a> : thm
<a name="line364"></a>    val <a href="#TC_eq_NRC-val">TC_eq_NRC</a> : thm
<a name="line365"></a>    val <a href="#TIMES2-val">TIMES2</a> : thm
<a name="line366"></a>    val <a href="#TWO-val">TWO</a> : thm
<a name="line367"></a>    val <a href="#WOP-val">WOP</a> : thm
<a name="line368"></a>    val <a href="#X_LE_DIV-val">X_LE_DIV</a> : thm
<a name="line369"></a>    val <a href="#X_LE_X_EXP-val">X_LE_X_EXP</a> : thm
<a name="line370"></a>    val <a href="#X_LT_DIV-val">X_LT_DIV</a> : thm
<a name="line371"></a>    val <a href="#X_LT_EXP_X-val">X_LT_EXP_X</a> : thm
<a name="line372"></a>    val <a href="#X_LT_EXP_X_IFF-val">X_LT_EXP_X_IFF</a> : thm
<a name="line373"></a>    val <a href="#X_MOD_Y_EQ_X-val">X_MOD_Y_EQ_X</a> : thm
<a name="line374"></a>    val <a href="#ZERO_DIV-val">ZERO_DIV</a> : thm
<a name="line375"></a>    val <a href="#ZERO_EXP-val">ZERO_EXP</a> : thm
<a name="line376"></a>    val <a href="#ZERO_LESS_ADD-val">ZERO_LESS_ADD</a> : thm
<a name="line377"></a>    val <a href="#ZERO_LESS_EQ-val">ZERO_LESS_EQ</a> : thm
<a name="line378"></a>    val <a href="#ZERO_LESS_EXP-val">ZERO_LESS_EXP</a> : thm
<a name="line379"></a>    val <a href="#ZERO_LESS_MULT-val">ZERO_LESS_MULT</a> : thm
<a name="line380"></a>    val <a href="#ZERO_LT_EXP-val">ZERO_LT_EXP</a> : thm
<a name="line381"></a>    val <a href="#ZERO_MOD-val">ZERO_MOD</a> : thm
<a name="line382"></a>    val <a href="#findq_divisor-val">findq_divisor</a> : thm
<a name="line383"></a>    val <a href="#findq_eq_0-val">findq_eq_0</a> : thm
<a name="line384"></a>    val <a href="#findq_thm-val">findq_thm</a> : thm
<a name="line385"></a>    val <a href="#num_CASES-val">num_CASES</a> : thm
<a name="line386"></a>    val <a href="#num_case_compute-val">num_case_compute</a> : thm
<a name="line387"></a>    val <a href="#num_case_cong-val">num_case_cong</a> : thm
<a name="line388"></a>    val <a href="#transitive_measure-val">transitive_measure</a> : thm
<a name="line389"></a>    val <a href="#transitive_monotone-val">transitive_monotone</a> : thm
<a name="line390"></a>
<a name="line391"></a>  val arithmetic_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line392"></a>(*
   [pair] Parent theory of "arithmetic"

   [prim_rec] Parent theory of "arithmetic"

   [<a name="ABS_DIFF_def-val"><b>ABS_DIFF_def</b></a>]  Definition

      |- ∀n m. ABS_DIFF n m = if n &lt; m then m − n else n − m

   [<a name="ADD-val"><b>ADD</b></a>]  Definition

      |- (∀n. 0 + n = n) ∧ ∀m n. SUC m + n = SUC (m + n)

   [<a name="ALT_ZERO-val"><b>ALT_ZERO</b></a>]  Definition

      |- ZERO = 0

   [<a name="BIT1-val"><b>BIT1</b></a>]  Definition

      |- ∀n. BIT1 n = n + (n + SUC 0)

   [<a name="BIT2-val"><b>BIT2</b></a>]  Definition

      |- ∀n. BIT2 n = n + (n + SUC (SUC 0))

   [<a name="DIV2_def-val"><b>DIV2_def</b></a>]  Definition

      |- ∀n. DIV2 n = n DIV 2

   [<a name="DIVISION-val"><b>DIVISION</b></a>]  Definition

      |- ∀n. 0 &lt; n ⇒ ∀k. (k = k DIV n * n + k MOD n) ∧ k MOD n &lt; n

   [<a name="DIVMOD_DEF-val"><b>DIVMOD_DEF</b></a>]  Definition

      |- DIVMOD =
         WFREC (measure (FST o SND))
           (λf (a,m,n).
              if n = 0 then
                (0,0)
              else if m &lt; n then
                (a,m)
              else
                (let q = findq (1,m,n) in f (a + q,m − n * q,n)))

   [<a name="DIV_2EXP_def-val"><b>DIV_2EXP_def</b></a>]  Definition

      |- ∀x n. DIV_2EXP x n = n DIV 2 ** x

   [<a name="EVEN-val"><b>EVEN</b></a>]  Definition

      |- (EVEN 0 ⇔ T) ∧ ∀n. EVEN (SUC n) ⇔ ¬EVEN n

   [<a name="EXP-val"><b>EXP</b></a>]  Definition

      |- (∀m. m ** 0 = 1) ∧ ∀m n. m ** SUC n = m * m ** n

   [<a name="FACT-val"><b>FACT</b></a>]  Definition

      |- (FACT 0 = 1) ∧ ∀n. FACT (SUC n) = SUC n * FACT n

   [<a name="FUNPOW-val"><b>FUNPOW</b></a>]  Definition

      |- (∀f x. FUNPOW f 0 x = x) ∧
         ∀f n x. FUNPOW f (SUC n) x = FUNPOW f n (f x)

   [<a name="GREATER_DEF-val"><b>GREATER_DEF</b></a>]  Definition

      |- ∀m n. m &gt; n ⇔ n &lt; m

   [<a name="GREATER_OR_EQ-val"><b>GREATER_OR_EQ</b></a>]  Definition

      |- ∀m n. m ≥ n ⇔ m &gt; n ∨ (m = n)

   [<a name="LESS_OR_EQ-val"><b>LESS_OR_EQ</b></a>]  Definition

      |- ∀m n. m ≤ n ⇔ m &lt; n ∨ (m = n)

   [<a name="MAX_DEF-val"><b>MAX_DEF</b></a>]  Definition

      |- ∀m n. MAX m n = if m &lt; n then n else m

   [<a name="MIN_DEF-val"><b>MIN_DEF</b></a>]  Definition

      |- ∀m n. MIN m n = if m &lt; n then m else n

   [<a name="MODEQ_DEF-val"><b>MODEQ_DEF</b></a>]  Definition

      |- ∀n m1 m2. MODEQ n m1 m2 ⇔ ∃a b. a * n + m1 = b * n + m2

   [<a name="MOD_2EXP_def-val"><b>MOD_2EXP_def</b></a>]  Definition

      |- ∀x n. MOD_2EXP x n = n MOD 2 ** x

   [<a name="MULT-val"><b>MULT</b></a>]  Definition

      |- (∀n. 0 * n = 0) ∧ ∀m n. SUC m * n = m * n + n

   [<a name="NRC-val"><b>NRC</b></a>]  Definition

      |- (∀R x y. NRC R 0 x y ⇔ (x = y)) ∧
         ∀R n x y. NRC R (SUC n) x y ⇔ ∃z. R x z ∧ NRC R n z y

   [<a name="NUMERAL_DEF-val"><b>NUMERAL_DEF</b></a>]  Definition

      |- ∀x. NUMERAL x = x

   [<a name="ODD-val"><b>ODD</b></a>]  Definition

      |- (ODD 0 ⇔ F) ∧ ∀n. ODD (SUC n) ⇔ ¬ODD n

   [<a name="SUB-val"><b>SUB</b></a>]  Definition

      |- (∀m. 0 − m = 0) ∧
         ∀m n. SUC m − n = if m &lt; n then 0 else SUC (m − n)

   [<a name="findq_def-val"><b>findq_def</b></a>]  Definition

      |- findq =
         WFREC (measure (λ(a,m,n). m − n))
           (λf (a,m,n).
              if n = 0 then
                a
              else
                (let d = 2 * n in if m &lt; d then a else f (2 * a,m,d)))

   [<a name="nat_elim__magic-val"><b>nat_elim__magic</b></a>]  Definition

      |- ∀n. &n = n

   [<a name="num_case_def-val"><b>num_case_def</b></a>]  Definition

      |- (∀b f. num_case b f 0 = b) ∧ ∀b f n. num_case b f (SUC n) = f n

   [<a name="ABS_DIFF_ADD_SAME-val"><b>ABS_DIFF_ADD_SAME</b></a>]  Theorem

      |- ∀n m p. ABS_DIFF (n + p) (m + p) = ABS_DIFF n m

   [<a name="ABS_DIFF_COMM-val"><b>ABS_DIFF_COMM</b></a>]  Theorem

      |- ∀n m. ABS_DIFF n m = ABS_DIFF m n

   [<a name="ABS_DIFF_EQS-val"><b>ABS_DIFF_EQS</b></a>]  Theorem

      |- ∀n. ABS_DIFF n n = 0

   [<a name="ABS_DIFF_EQ_0-val"><b>ABS_DIFF_EQ_0</b></a>]  Theorem

      |- ∀n m. (ABS_DIFF n m = 0) ⇔ (n = m)

   [<a name="ABS_DIFF_SUMS-val"><b>ABS_DIFF_SUMS</b></a>]  Theorem

      |- ∀n1 n2 m1 m2.
           ABS_DIFF (n1 + n2) (m1 + m2) ≤ ABS_DIFF n1 m1 + ABS_DIFF n2 m2

   [<a name="ABS_DIFF_SYM-val"><b>ABS_DIFF_SYM</b></a>]  Theorem

      |- ∀n m. ABS_DIFF n m = ABS_DIFF m n

   [<a name="ABS_DIFF_TRIANGLE-val"><b>ABS_DIFF_TRIANGLE</b></a>]  Theorem

      |- ∀x y z. ABS_DIFF x z ≤ ABS_DIFF x y + ABS_DIFF y z

   [<a name="ABS_DIFF_ZERO-val"><b>ABS_DIFF_ZERO</b></a>]  Theorem

      |- ∀n. (ABS_DIFF n 0 = n) ∧ (ABS_DIFF 0 n = n)

   [<a name="ADD1-val"><b>ADD1</b></a>]  Theorem

      |- ∀m. SUC m = m + 1

   [<a name="ADD_0-val"><b>ADD_0</b></a>]  Theorem

      |- ∀m. m + 0 = m

   [<a name="ADD_ASSOC-val"><b>ADD_ASSOC</b></a>]  Theorem

      |- ∀m n p. m + (n + p) = m + n + p

   [<a name="ADD_CLAUSES-val"><b>ADD_CLAUSES</b></a>]  Theorem

      |- (0 + m = m) ∧ (m + 0 = m) ∧ (SUC m + n = SUC (m + n)) ∧
         (m + SUC n = SUC (m + n))

   [<a name="ADD_COMM-val"><b>ADD_COMM</b></a>]  Theorem

      |- ∀m n. m + n = n + m

   [<a name="ADD_DIV_ADD_DIV-val"><b>ADD_DIV_ADD_DIV</b></a>]  Theorem

      |- ∀n. 0 &lt; n ⇒ ∀x r. (x * n + r) DIV n = x + r DIV n

   [<a name="ADD_DIV_RWT-val"><b>ADD_DIV_RWT</b></a>]  Theorem

      |- ∀n.
           0 &lt; n ⇒
           ∀m p.
             (m MOD n = 0) ∨ (p MOD n = 0) ⇒
             ((m + p) DIV n = m DIV n + p DIV n)

   [<a name="ADD_EQ_0-val"><b>ADD_EQ_0</b></a>]  Theorem

      |- ∀m n. (m + n = 0) ⇔ (m = 0) ∧ (n = 0)

   [<a name="ADD_EQ_1-val"><b>ADD_EQ_1</b></a>]  Theorem

      |- ∀m n. (m + n = 1) ⇔ (m = 1) ∧ (n = 0) ∨ (m = 0) ∧ (n = 1)

   [<a name="ADD_EQ_SUB-val"><b>ADD_EQ_SUB</b></a>]  Theorem

      |- ∀m n p. n ≤ p ⇒ ((m + n = p) ⇔ (m = p − n))

   [<a name="ADD_INV_0-val"><b>ADD_INV_0</b></a>]  Theorem

      |- ∀m n. (m + n = m) ⇒ (n = 0)

   [<a name="ADD_INV_0_EQ-val"><b>ADD_INV_0_EQ</b></a>]  Theorem

      |- ∀m n. (m + n = m) ⇔ (n = 0)

   [<a name="ADD_MOD-val"><b>ADD_MOD</b></a>]  Theorem

      |- ∀n a b p.
           0 &lt; n ⇒ (((a + p) MOD n = (b + p) MOD n) ⇔ (a MOD n = b MOD n))

   [<a name="ADD_MODULUS-val"><b>ADD_MODULUS</b></a>]  Theorem

      |- (∀n x. 0 &lt; n ⇒ ((x + n) MOD n = x MOD n)) ∧
         ∀n x. 0 &lt; n ⇒ ((n + x) MOD n = x MOD n)

   [<a name="ADD_MODULUS_LEFT-val"><b>ADD_MODULUS_LEFT</b></a>]  Theorem

      |- ∀n x. 0 &lt; n ⇒ ((x + n) MOD n = x MOD n)

   [<a name="ADD_MODULUS_RIGHT-val"><b>ADD_MODULUS_RIGHT</b></a>]  Theorem

      |- ∀n x. 0 &lt; n ⇒ ((n + x) MOD n = x MOD n)

   [<a name="ADD_MONO_LESS_EQ-val"><b>ADD_MONO_LESS_EQ</b></a>]  Theorem

      |- ∀m n p. m + n ≤ m + p ⇔ n ≤ p

   [<a name="ADD_SUB-val"><b>ADD_SUB</b></a>]  Theorem

      |- ∀a c. a + c − c = a

   [<a name="ADD_SUC-val"><b>ADD_SUC</b></a>]  Theorem

      |- ∀m n. SUC (m + n) = m + SUC n

   [<a name="ADD_SYM-val"><b>ADD_SYM</b></a>]  Theorem

      |- ∀m n. m + n = n + m

   [<a name="BOUNDED_EXISTS_THM-val"><b>BOUNDED_EXISTS_THM</b></a>]  Theorem

      |- ∀c. 0 &lt; c ⇒ ((∃n. n &lt; c ∧ P n) ⇔ P (c − 1) ∨ ∃n. n &lt; c − 1 ∧ P n)

   [<a name="BOUNDED_FORALL_THM-val"><b>BOUNDED_FORALL_THM</b></a>]  Theorem

      |- ∀c. 0 &lt; c ⇒ ((∀n. n &lt; c ⇒ P n) ⇔ P (c − 1) ∧ ∀n. n &lt; c − 1 ⇒ P n)

   [<a name="CANCEL_SUB-val"><b>CANCEL_SUB</b></a>]  Theorem

      |- ∀p n m. p ≤ n ∧ p ≤ m ⇒ ((n − p = m − p) ⇔ (n = m))

   [<a name="COMPLETE_INDUCTION-val"><b>COMPLETE_INDUCTION</b></a>]  Theorem

      |- ∀P. (∀n. (∀m. m &lt; n ⇒ P m) ⇒ P n) ⇒ ∀n. P n

   [<a name="DA-val"><b>DA</b></a>]  Theorem

      |- ∀k n. 0 &lt; n ⇒ ∃r q. (k = q * n + r) ∧ r &lt; n

   [<a name="DIVMOD_CALC-val"><b>DIVMOD_CALC</b></a>]  Theorem

      |- (∀m n. 0 &lt; n ⇒ (m DIV n = FST (DIVMOD (0,m,n)))) ∧
         ∀m n. 0 &lt; n ⇒ (m MOD n = SND (DIVMOD (0,m,n)))

   [<a name="DIVMOD_CORRECT-val"><b>DIVMOD_CORRECT</b></a>]  Theorem

      |- ∀m n a. 0 &lt; n ⇒ (DIVMOD (a,m,n) = (a + m DIV n,m MOD n))

   [<a name="DIVMOD_ID-val"><b>DIVMOD_ID</b></a>]  Theorem

      |- ∀n. 0 &lt; n ⇒ (n DIV n = 1) ∧ (n MOD n = 0)

   [<a name="DIVMOD_THM-val"><b>DIVMOD_THM</b></a>]  Theorem

      |- DIVMOD (a,m,n) =
         if n = 0 then
           (0,0)
         else if m &lt; n then
           (a,m)
         else
           (let q = findq (1,m,n) in DIVMOD (a + q,m − n * q,n))

   [<a name="DIV_1-val"><b>DIV_1</b></a>]  Theorem

      |- ∀q. q DIV 1 = q

   [<a name="DIV_DIV_DIV_MULT-val"><b>DIV_DIV_DIV_MULT</b></a>]  Theorem

      |- ∀m n. 0 &lt; m ∧ 0 &lt; n ⇒ ∀x. x DIV m DIV n = x DIV (m * n)

   [<a name="DIV_EQ_X-val"><b>DIV_EQ_X</b></a>]  Theorem

      |- ∀x y z. 0 &lt; z ⇒ ((y DIV z = x) ⇔ x * z ≤ y ∧ y &lt; SUC x * z)

   [<a name="DIV_LESS-val"><b>DIV_LESS</b></a>]  Theorem

      |- ∀n d. 0 &lt; n ∧ 1 &lt; d ⇒ n DIV d &lt; n

   [<a name="DIV_LESS_EQ-val"><b>DIV_LESS_EQ</b></a>]  Theorem

      |- ∀n. 0 &lt; n ⇒ ∀k. k DIV n ≤ k

   [<a name="DIV_LE_MONOTONE-val"><b>DIV_LE_MONOTONE</b></a>]  Theorem

      |- ∀n x y. 0 &lt; n ∧ x ≤ y ⇒ x DIV n ≤ y DIV n

   [<a name="DIV_LE_X-val"><b>DIV_LE_X</b></a>]  Theorem

      |- ∀x y z. 0 &lt; z ⇒ (y DIV z ≤ x ⇔ y &lt; (x + 1) * z)

   [<a name="DIV_LT_X-val"><b>DIV_LT_X</b></a>]  Theorem

      |- ∀x y z. 0 &lt; z ⇒ (y DIV z &lt; x ⇔ y &lt; x * z)

   [<a name="DIV_MOD_MOD_DIV-val"><b>DIV_MOD_MOD_DIV</b></a>]  Theorem

      |- ∀m n k. 0 &lt; n ∧ 0 &lt; k ⇒ ((m DIV n) MOD k = m MOD (n * k) DIV n)

   [<a name="DIV_MULT-val"><b>DIV_MULT</b></a>]  Theorem

      |- ∀n r. r &lt; n ⇒ ∀q. (q * n + r) DIV n = q

   [<a name="DIV_ONE-val"><b>DIV_ONE</b></a>]  Theorem

      |- ∀q. q DIV SUC 0 = q

   [<a name="DIV_P-val"><b>DIV_P</b></a>]  Theorem

      |- ∀P p q.
           0 &lt; q ⇒ (P (p DIV q) ⇔ ∃k r. (p = k * q + r) ∧ r &lt; q ∧ P k)

   [<a name="DIV_P_UNIV-val"><b>DIV_P_UNIV</b></a>]  Theorem

      |- ∀P m n.
           0 &lt; n ⇒ (P (m DIV n) ⇔ ∀q r. (m = q * n + r) ∧ r &lt; n ⇒ P q)

   [<a name="DIV_SUB-val"><b>DIV_SUB</b></a>]  Theorem

      |- 0 &lt; n ∧ n * q ≤ m ⇒ ((m − n * q) DIV n = m DIV n − q)

   [<a name="DIV_UNIQUE-val"><b>DIV_UNIQUE</b></a>]  Theorem

      |- ∀n k q. (∃r. (k = q * n + r) ∧ r &lt; n) ⇒ (k DIV n = q)

   [<a name="DOUBLE_LT-val"><b>DOUBLE_LT</b></a>]  Theorem

      |- ∀p q. 2 * p + 1 &lt; 2 * q ⇔ 2 * p &lt; 2 * q

   [<a name="EQ_ADD_LCANCEL-val"><b>EQ_ADD_LCANCEL</b></a>]  Theorem

      |- ∀m n p. (m + n = m + p) ⇔ (n = p)

   [<a name="EQ_ADD_RCANCEL-val"><b>EQ_ADD_RCANCEL</b></a>]  Theorem

      |- ∀m n p. (m + p = n + p) ⇔ (m = n)

   [<a name="EQ_LESS_EQ-val"><b>EQ_LESS_EQ</b></a>]  Theorem

      |- ∀m n. (m = n) ⇔ m ≤ n ∧ n ≤ m

   [<a name="EQ_MONO_ADD_EQ-val"><b>EQ_MONO_ADD_EQ</b></a>]  Theorem

      |- ∀m n p. (m + p = n + p) ⇔ (m = n)

   [<a name="EQ_MULT_LCANCEL-val"><b>EQ_MULT_LCANCEL</b></a>]  Theorem

      |- ∀m n p. (m * n = m * p) ⇔ (m = 0) ∨ (n = p)

   [<a name="EVEN_ADD-val"><b>EVEN_ADD</b></a>]  Theorem

      |- ∀m n. EVEN (m + n) ⇔ (EVEN m ⇔ EVEN n)

   [<a name="EVEN_AND_ODD-val"><b>EVEN_AND_ODD</b></a>]  Theorem

      |- ∀n. ¬(EVEN n ∧ ODD n)

   [<a name="EVEN_DOUBLE-val"><b>EVEN_DOUBLE</b></a>]  Theorem

      |- ∀n. EVEN (2 * n)

   [<a name="EVEN_EXISTS-val"><b>EVEN_EXISTS</b></a>]  Theorem

      |- ∀n. EVEN n ⇔ ∃m. n = 2 * m

   [<a name="EVEN_EXP-val"><b>EVEN_EXP</b></a>]  Theorem

      |- ∀m n. 0 &lt; n ∧ EVEN m ⇒ EVEN (m ** n)

   [<a name="EVEN_MOD2-val"><b>EVEN_MOD2</b></a>]  Theorem

      |- ∀x. EVEN x ⇔ (x MOD 2 = 0)

   [<a name="EVEN_MULT-val"><b>EVEN_MULT</b></a>]  Theorem

      |- ∀m n. EVEN (m * n) ⇔ EVEN m ∨ EVEN n

   [<a name="EVEN_ODD-val"><b>EVEN_ODD</b></a>]  Theorem

      |- ∀n. EVEN n ⇔ ¬ODD n

   [<a name="EVEN_ODD_EXISTS-val"><b>EVEN_ODD_EXISTS</b></a>]  Theorem

      |- ∀n. (EVEN n ⇒ ∃m. n = 2 * m) ∧ (ODD n ⇒ ∃m. n = SUC (2 * m))

   [<a name="EVEN_OR_ODD-val"><b>EVEN_OR_ODD</b></a>]  Theorem

      |- ∀n. EVEN n ∨ ODD n

   [<a name="EXISTS_GREATEST-val"><b>EXISTS_GREATEST</b></a>]  Theorem

      |- ∀P.
           (∃x. P x) ∧ (∃x. ∀y. y &gt; x ⇒ ¬P y) ⇔ ∃x. P x ∧ ∀y. y &gt; x ⇒ ¬P y

   [<a name="EXISTS_NUM-val"><b>EXISTS_NUM</b></a>]  Theorem

      |- ∀P. (∃n. P n) ⇔ P 0 ∨ ∃m. P (SUC m)

   [<a name="EXP2_LT-val"><b>EXP2_LT</b></a>]  Theorem

      |- ∀m n. n DIV 2 &lt; 2 ** m ⇔ n &lt; 2 ** SUC m

   [<a name="EXP_1-val"><b>EXP_1</b></a>]  Theorem

      |- ∀n. (1 ** n = 1) ∧ (n ** 1 = n)

   [<a name="EXP_ADD-val"><b>EXP_ADD</b></a>]  Theorem

      |- ∀p q n. n ** (p + q) = n ** p * n ** q

   [<a name="EXP_ALWAYS_BIG_ENOUGH-val"><b>EXP_ALWAYS_BIG_ENOUGH</b></a>]  Theorem

      |- ∀b. 1 &lt; b ⇒ ∀n. ∃m. n ≤ b ** m

   [<a name="EXP_BASE_INJECTIVE-val"><b>EXP_BASE_INJECTIVE</b></a>]  Theorem

      |- ∀b. 1 &lt; b ⇒ ∀n m. (b ** n = b ** m) ⇔ (n = m)

   [<a name="EXP_BASE_LEQ_MONO_IMP-val"><b>EXP_BASE_LEQ_MONO_IMP</b></a>]  Theorem

      |- ∀n m b. 0 &lt; b ∧ m ≤ n ⇒ b ** m ≤ b ** n

   [<a name="EXP_BASE_LEQ_MONO_SUC_IMP-val"><b>EXP_BASE_LEQ_MONO_SUC_IMP</b></a>]  Theorem

      |- m ≤ n ⇒ SUC b ** m ≤ SUC b ** n

   [<a name="EXP_BASE_LE_IFF-val"><b>EXP_BASE_LE_IFF</b></a>]  Theorem

      |- b ** m ≤ b ** n ⇔
         (b = 0) ∧ (n = 0) ∨ (b = 0) ∧ 0 &lt; m ∨ (b = 1) ∨ 1 &lt; b ∧ m ≤ n

   [<a name="EXP_BASE_LE_MONO-val"><b>EXP_BASE_LE_MONO</b></a>]  Theorem

      |- ∀b. 1 &lt; b ⇒ ∀n m. b ** m ≤ b ** n ⇔ m ≤ n

   [<a name="EXP_BASE_LT_MONO-val"><b>EXP_BASE_LT_MONO</b></a>]  Theorem

      |- ∀b. 1 &lt; b ⇒ ∀n m. b ** m &lt; b ** n ⇔ m &lt; n

   [<a name="EXP_BASE_MULT-val"><b>EXP_BASE_MULT</b></a>]  Theorem

      |- ∀z x y. (x * y) ** z = x ** z * y ** z

   [<a name="EXP_EQ_0-val"><b>EXP_EQ_0</b></a>]  Theorem

      |- ∀n m. (n ** m = 0) ⇔ (n = 0) ∧ 0 &lt; m

   [<a name="EXP_EQ_1-val"><b>EXP_EQ_1</b></a>]  Theorem

      |- ∀n m. (n ** m = 1) ⇔ (n = 1) ∨ (m = 0)

   [<a name="EXP_EXP_INJECTIVE-val"><b>EXP_EXP_INJECTIVE</b></a>]  Theorem

      |- ∀b1 b2 x. (b1 ** x = b2 ** x) ⇔ (x = 0) ∨ (b1 = b2)

   [<a name="EXP_EXP_LE_MONO-val"><b>EXP_EXP_LE_MONO</b></a>]  Theorem

      |- ∀a b. a ** n ≤ b ** n ⇔ a ≤ b ∨ (n = 0)

   [<a name="EXP_EXP_LT_MONO-val"><b>EXP_EXP_LT_MONO</b></a>]  Theorem

      |- ∀a b. a ** n &lt; b ** n ⇔ a &lt; b ∧ 0 &lt; n

   [<a name="EXP_EXP_MULT-val"><b>EXP_EXP_MULT</b></a>]  Theorem

      |- ∀z x y. x ** (y * z) = (x ** y) ** z

   [<a name="EXP_SUB-val"><b>EXP_SUB</b></a>]  Theorem

      |- ∀p q n. 0 &lt; n ∧ q ≤ p ⇒ (n ** (p − q) = n ** p DIV n ** q)

   [<a name="EXP_SUB_NUMERAL-val"><b>EXP_SUB_NUMERAL</b></a>]  Theorem

      |- 0 &lt; n ⇒
         (n ** NUMERAL (BIT1 x) DIV n = n ** (NUMERAL (BIT1 x) − 1)) ∧
         (n ** NUMERAL (BIT2 x) DIV n = n ** NUMERAL (BIT1 x))

   [<a name="FACT_LESS-val"><b>FACT_LESS</b></a>]  Theorem

      |- ∀n. 0 &lt; FACT n

   [<a name="FORALL_NUM-val"><b>FORALL_NUM</b></a>]  Theorem

      |- ∀P. (∀n. P n) ⇔ P 0 ∧ ∀n. P (SUC n)

   [<a name="FORALL_NUM_THM-val"><b>FORALL_NUM_THM</b></a>]  Theorem

      |- (∀n. P n) ⇔ P 0 ∧ ∀n. P n ⇒ P (SUC n)

   [<a name="FUNPOW_0-val"><b>FUNPOW_0</b></a>]  Theorem

      |- FUNPOW f 0 x = x

   [<a name="FUNPOW_1-val"><b>FUNPOW_1</b></a>]  Theorem

      |- FUNPOW f 1 x = f x

   [<a name="FUNPOW_ADD-val"><b>FUNPOW_ADD</b></a>]  Theorem

      |- ∀m n. FUNPOW f (m + n) x = FUNPOW f m (FUNPOW f n x)

   [<a name="FUNPOW_SUC-val"><b>FUNPOW_SUC</b></a>]  Theorem

      |- ∀f n x. FUNPOW f (SUC n) x = f (FUNPOW f n x)

   [<a name="FUN_EQ_LEMMA-val"><b>FUN_EQ_LEMMA</b></a>]  Theorem

      |- ∀f x1 x2. f x1 ∧ ¬f x2 ⇒ x1 ≠ x2

   [<a name="GREATER_EQ-val"><b>GREATER_EQ</b></a>]  Theorem

      |- ∀n m. n ≥ m ⇔ m ≤ n

   [<a name="INV_PRE_EQ-val"><b>INV_PRE_EQ</b></a>]  Theorem

      |- ∀m n. 0 &lt; m ∧ 0 &lt; n ⇒ ((PRE m = PRE n) ⇔ (m = n))

   [<a name="INV_PRE_LESS-val"><b>INV_PRE_LESS</b></a>]  Theorem

      |- ∀m. 0 &lt; m ⇒ ∀n. PRE m &lt; PRE n ⇔ m &lt; n

   [<a name="INV_PRE_LESS_EQ-val"><b>INV_PRE_LESS_EQ</b></a>]  Theorem

      |- ∀n. 0 &lt; n ⇒ ∀m. PRE m ≤ PRE n ⇔ m ≤ n

   [<a name="LE-val"><b>LE</b></a>]  Theorem

      |- (∀n. n ≤ 0 ⇔ (n = 0)) ∧ ∀m n. m ≤ SUC n ⇔ (m = SUC n) ∨ m ≤ n

   [<a name="LEFT_ADD_DISTRIB-val"><b>LEFT_ADD_DISTRIB</b></a>]  Theorem

      |- ∀m n p. p * (m + n) = p * m + p * n

   [<a name="LEFT_SUB_DISTRIB-val"><b>LEFT_SUB_DISTRIB</b></a>]  Theorem

      |- ∀m n p. p * (m − n) = p * m − p * n

   [<a name="LESS_0_CASES-val"><b>LESS_0_CASES</b></a>]  Theorem

      |- ∀m. (0 = m) ∨ 0 &lt; m

   [<a name="LESS_ADD-val"><b>LESS_ADD</b></a>]  Theorem

      |- ∀m n. n &lt; m ⇒ ∃p. p + n = m

   [<a name="LESS_ADD_1-val"><b>LESS_ADD_1</b></a>]  Theorem

      |- ∀m n. n &lt; m ⇒ ∃p. m = n + (p + 1)

   [<a name="LESS_ADD_NONZERO-val"><b>LESS_ADD_NONZERO</b></a>]  Theorem

      |- ∀m n. n ≠ 0 ⇒ m &lt; m + n

   [<a name="LESS_ADD_SUC-val"><b>LESS_ADD_SUC</b></a>]  Theorem

      |- ∀m n. m &lt; m + SUC n

   [<a name="LESS_ANTISYM-val"><b>LESS_ANTISYM</b></a>]  Theorem

      |- ∀m n. ¬(m &lt; n ∧ n &lt; m)

   [<a name="LESS_CASES-val"><b>LESS_CASES</b></a>]  Theorem

      |- ∀m n. m &lt; n ∨ n ≤ m

   [<a name="LESS_CASES_IMP-val"><b>LESS_CASES_IMP</b></a>]  Theorem

      |- ∀m n. ¬(m &lt; n) ∧ m ≠ n ⇒ n &lt; m

   [<a name="LESS_DIV_EQ_ZERO-val"><b>LESS_DIV_EQ_ZERO</b></a>]  Theorem

      |- ∀r n. r &lt; n ⇒ (r DIV n = 0)

   [<a name="LESS_EQ-val"><b>LESS_EQ</b></a>]  Theorem

      |- ∀m n. m &lt; n ⇔ SUC m ≤ n

   [<a name="LESS_EQUAL_ADD-val"><b>LESS_EQUAL_ADD</b></a>]  Theorem

      |- ∀m n. m ≤ n ⇒ ∃p. n = m + p

   [<a name="LESS_EQUAL_ANTISYM-val"><b>LESS_EQUAL_ANTISYM</b></a>]  Theorem

      |- ∀n m. n ≤ m ∧ m ≤ n ⇒ (n = m)

   [<a name="LESS_EQUAL_DIFF-val"><b>LESS_EQUAL_DIFF</b></a>]  Theorem

      |- ∀m n. m ≤ n ⇒ ∃k. m = n − k

   [<a name="LESS_EQ_0-val"><b>LESS_EQ_0</b></a>]  Theorem

      |- ∀n. n ≤ 0 ⇔ (n = 0)

   [<a name="LESS_EQ_ADD-val"><b>LESS_EQ_ADD</b></a>]  Theorem

      |- ∀m n. m ≤ m + n

   [<a name="LESS_EQ_ADD_EXISTS-val"><b>LESS_EQ_ADD_EXISTS</b></a>]  Theorem

      |- ∀m n. n ≤ m ⇒ ∃p. p + n = m

   [<a name="LESS_EQ_ADD_SUB-val"><b>LESS_EQ_ADD_SUB</b></a>]  Theorem

      |- ∀c b. c ≤ b ⇒ ∀a. a + b − c = a + (b − c)

   [<a name="LESS_EQ_ANTISYM-val"><b>LESS_EQ_ANTISYM</b></a>]  Theorem

      |- ∀m n. ¬(m &lt; n ∧ n ≤ m)

   [<a name="LESS_EQ_CASES-val"><b>LESS_EQ_CASES</b></a>]  Theorem

      |- ∀m n. m ≤ n ∨ n ≤ m

   [<a name="LESS_EQ_EXISTS-val"><b>LESS_EQ_EXISTS</b></a>]  Theorem

      |- ∀m n. m ≤ n ⇔ ∃p. n = m + p

   [<a name="LESS_EQ_IMP_LESS_SUC-val"><b>LESS_EQ_IMP_LESS_SUC</b></a>]  Theorem

      |- ∀n m. n ≤ m ⇒ n &lt; SUC m

   [<a name="LESS_EQ_LESS_EQ_MONO-val"><b>LESS_EQ_LESS_EQ_MONO</b></a>]  Theorem

      |- ∀m n p q. m ≤ p ∧ n ≤ q ⇒ m + n ≤ p + q

   [<a name="LESS_EQ_LESS_TRANS-val"><b>LESS_EQ_LESS_TRANS</b></a>]  Theorem

      |- ∀m n p. m ≤ n ∧ n &lt; p ⇒ m &lt; p

   [<a name="LESS_EQ_MONO-val"><b>LESS_EQ_MONO</b></a>]  Theorem

      |- ∀n m. SUC n ≤ SUC m ⇔ n ≤ m

   [<a name="LESS_EQ_MONO_ADD_EQ-val"><b>LESS_EQ_MONO_ADD_EQ</b></a>]  Theorem

      |- ∀m n p. m + p ≤ n + p ⇔ m ≤ n

   [<a name="LESS_EQ_REFL-val"><b>LESS_EQ_REFL</b></a>]  Theorem

      |- ∀m. m ≤ m

   [<a name="LESS_EQ_SUB_LESS-val"><b>LESS_EQ_SUB_LESS</b></a>]  Theorem

      |- ∀a b. b ≤ a ⇒ ∀c. a − b &lt; c ⇔ a &lt; b + c

   [<a name="LESS_EQ_SUC_REFL-val"><b>LESS_EQ_SUC_REFL</b></a>]  Theorem

      |- ∀m. m ≤ SUC m

   [<a name="LESS_EQ_TRANS-val"><b>LESS_EQ_TRANS</b></a>]  Theorem

      |- ∀m n p. m ≤ n ∧ n ≤ p ⇒ m ≤ p

   [<a name="LESS_EXP_SUC_MONO-val"><b>LESS_EXP_SUC_MONO</b></a>]  Theorem

      |- ∀n m. SUC (SUC m) ** n &lt; SUC (SUC m) ** SUC n

   [<a name="LESS_IMP_LESS_ADD-val"><b>LESS_IMP_LESS_ADD</b></a>]  Theorem

      |- ∀n m. n &lt; m ⇒ ∀p. n &lt; m + p

   [<a name="LESS_IMP_LESS_OR_EQ-val"><b>LESS_IMP_LESS_OR_EQ</b></a>]  Theorem

      |- ∀m n. m &lt; n ⇒ m ≤ n

   [<a name="LESS_LESS_CASES-val"><b>LESS_LESS_CASES</b></a>]  Theorem

      |- ∀m n. (m = n) ∨ m &lt; n ∨ n &lt; m

   [<a name="LESS_LESS_EQ_TRANS-val"><b>LESS_LESS_EQ_TRANS</b></a>]  Theorem

      |- ∀m n p. m &lt; n ∧ n ≤ p ⇒ m &lt; p

   [<a name="LESS_LESS_SUC-val"><b>LESS_LESS_SUC</b></a>]  Theorem

      |- ∀m n. ¬(m &lt; n ∧ n &lt; SUC m)

   [<a name="LESS_MOD-val"><b>LESS_MOD</b></a>]  Theorem

      |- ∀n k. k &lt; n ⇒ (k MOD n = k)

   [<a name="LESS_MONO_ADD-val"><b>LESS_MONO_ADD</b></a>]  Theorem

      |- ∀m n p. m &lt; n ⇒ m + p &lt; n + p

   [<a name="LESS_MONO_ADD_EQ-val"><b>LESS_MONO_ADD_EQ</b></a>]  Theorem

      |- ∀m n p. m + p &lt; n + p ⇔ m &lt; n

   [<a name="LESS_MONO_ADD_INV-val"><b>LESS_MONO_ADD_INV</b></a>]  Theorem

      |- ∀m n p. m + p &lt; n + p ⇒ m &lt; n

   [<a name="LESS_MONO_EQ-val"><b>LESS_MONO_EQ</b></a>]  Theorem

      |- ∀m n. SUC m &lt; SUC n ⇔ m &lt; n

   [<a name="LESS_MONO_MULT-val"><b>LESS_MONO_MULT</b></a>]  Theorem

      |- ∀m n p. m ≤ n ⇒ m * p ≤ n * p

   [<a name="LESS_MONO_MULT2-val"><b>LESS_MONO_MULT2</b></a>]  Theorem

      |- ∀m n i j. m ≤ i ∧ n ≤ j ⇒ m * n ≤ i * j

   [<a name="LESS_MONO_REV-val"><b>LESS_MONO_REV</b></a>]  Theorem

      |- ∀m n. SUC m &lt; SUC n ⇒ m &lt; n

   [<a name="LESS_MULT2-val"><b>LESS_MULT2</b></a>]  Theorem

      |- ∀m n. 0 &lt; m ∧ 0 &lt; n ⇒ 0 &lt; m * n

   [<a name="LESS_MULT_MONO-val"><b>LESS_MULT_MONO</b></a>]  Theorem

      |- ∀m i n. SUC n * m &lt; SUC n * i ⇔ m &lt; i

   [<a name="LESS_NOT_SUC-val"><b>LESS_NOT_SUC</b></a>]  Theorem

      |- ∀m n. m &lt; n ∧ n ≠ SUC m ⇒ SUC m &lt; n

   [<a name="LESS_OR-val"><b>LESS_OR</b></a>]  Theorem

      |- ∀m n. m &lt; n ⇒ SUC m ≤ n

   [<a name="LESS_OR_EQ_ADD-val"><b>LESS_OR_EQ_ADD</b></a>]  Theorem

      |- ∀n m. n &lt; m ∨ ∃p. n = p + m

   [<a name="LESS_STRONG_ADD-val"><b>LESS_STRONG_ADD</b></a>]  Theorem

      |- ∀m n. n &lt; m ⇒ ∃p. SUC p + n = m

   [<a name="LESS_SUB_ADD_LESS-val"><b>LESS_SUB_ADD_LESS</b></a>]  Theorem

      |- ∀n m i. i &lt; n − m ⇒ i + m &lt; n

   [<a name="LESS_SUC_EQ_COR-val"><b>LESS_SUC_EQ_COR</b></a>]  Theorem

      |- ∀m n. m &lt; n ∧ SUC m ≠ n ⇒ SUC m &lt; n

   [<a name="LESS_SUC_NOT-val"><b>LESS_SUC_NOT</b></a>]  Theorem

      |- ∀m n. m &lt; n ⇒ ¬(n &lt; SUC m)

   [<a name="LESS_TRANS-val"><b>LESS_TRANS</b></a>]  Theorem

      |- ∀m n p. m &lt; n ∧ n &lt; p ⇒ m &lt; p

   [<a name="LE_ADD_LCANCEL-val"><b>LE_ADD_LCANCEL</b></a>]  Theorem

      |- ∀m n p. m + n ≤ m + p ⇔ n ≤ p

   [<a name="LE_ADD_RCANCEL-val"><b>LE_ADD_RCANCEL</b></a>]  Theorem

      |- ∀m n p. n + m ≤ p + m ⇔ n ≤ p

   [<a name="LE_LT1-val"><b>LE_LT1</b></a>]  Theorem

      |- ∀x y. x ≤ y ⇔ x &lt; y + 1

   [<a name="LE_MULT_CANCEL_LBARE-val"><b>LE_MULT_CANCEL_LBARE</b></a>]  Theorem

      |- (m ≤ m * n ⇔ (m = 0) ∨ 0 &lt; n) ∧ (m ≤ n * m ⇔ (m = 0) ∨ 0 &lt; n)

   [<a name="LE_MULT_CANCEL_RBARE-val"><b>LE_MULT_CANCEL_RBARE</b></a>]  Theorem

      |- (m * n ≤ m ⇔ (m = 0) ∨ n ≤ 1) ∧ (m * n ≤ n ⇔ (n = 0) ∨ m ≤ 1)

   [<a name="LE_MULT_LCANCEL-val"><b>LE_MULT_LCANCEL</b></a>]  Theorem

      |- ∀m n p. m * n ≤ m * p ⇔ (m = 0) ∨ n ≤ p

   [<a name="LE_MULT_RCANCEL-val"><b>LE_MULT_RCANCEL</b></a>]  Theorem

      |- ∀m n p. m * n ≤ p * n ⇔ (n = 0) ∨ m ≤ p

   [<a name="LE_SUB_RCANCEL-val"><b>LE_SUB_RCANCEL</b></a>]  Theorem

      |- ∀m n p. n − m ≤ p − m ⇔ n ≤ m ∨ n ≤ p

   [<a name="LT_ADD_LCANCEL-val"><b>LT_ADD_LCANCEL</b></a>]  Theorem

      |- ∀m n p. p + m &lt; p + n ⇔ m &lt; n

   [<a name="LT_ADD_RCANCEL-val"><b>LT_ADD_RCANCEL</b></a>]  Theorem

      |- ∀m n p. m + p &lt; n + p ⇔ m &lt; n

   [<a name="LT_MULT_CANCEL_LBARE-val"><b>LT_MULT_CANCEL_LBARE</b></a>]  Theorem

      |- (m &lt; m * n ⇔ 0 &lt; m ∧ 1 &lt; n) ∧ (m &lt; n * m ⇔ 0 &lt; m ∧ 1 &lt; n)

   [<a name="LT_MULT_CANCEL_RBARE-val"><b>LT_MULT_CANCEL_RBARE</b></a>]  Theorem

      |- (m * n &lt; m ⇔ 0 &lt; m ∧ (n = 0)) ∧ (m * n &lt; n ⇔ 0 &lt; n ∧ (m = 0))

   [<a name="LT_MULT_LCANCEL-val"><b>LT_MULT_LCANCEL</b></a>]  Theorem

      |- ∀m n p. m * n &lt; m * p ⇔ 0 &lt; m ∧ n &lt; p

   [<a name="LT_MULT_RCANCEL-val"><b>LT_MULT_RCANCEL</b></a>]  Theorem

      |- ∀m n p. m * n &lt; p * n ⇔ 0 &lt; n ∧ m &lt; p

   [<a name="LT_SUB_RCANCEL-val"><b>LT_SUB_RCANCEL</b></a>]  Theorem

      |- ∀m n p. n − m &lt; p − m ⇔ n &lt; p ∧ m &lt; p

   [<a name="MAX_0-val"><b>MAX_0</b></a>]  Theorem

      |- ∀n. (MAX n 0 = n) ∧ (MAX 0 n = n)

   [<a name="MAX_ASSOC-val"><b>MAX_ASSOC</b></a>]  Theorem

      |- ∀m n p. MAX m (MAX n p) = MAX (MAX m n) p

   [<a name="MAX_COMM-val"><b>MAX_COMM</b></a>]  Theorem

      |- ∀m n. MAX m n = MAX n m

   [<a name="MAX_IDEM-val"><b>MAX_IDEM</b></a>]  Theorem

      |- ∀n. MAX n n = n

   [<a name="MAX_LE-val"><b>MAX_LE</b></a>]  Theorem

      |- ∀n m p.
           (p ≤ MAX m n ⇔ p ≤ m ∨ p ≤ n) ∧ (MAX m n ≤ p ⇔ m ≤ p ∧ n ≤ p)

   [<a name="MAX_LT-val"><b>MAX_LT</b></a>]  Theorem

      |- ∀n m p.
           (p &lt; MAX m n ⇔ p &lt; m ∨ p &lt; n) ∧ (MAX m n &lt; p ⇔ m &lt; p ∧ n &lt; p)

   [<a name="MIN_0-val"><b>MIN_0</b></a>]  Theorem

      |- ∀n. (MIN n 0 = 0) ∧ (MIN 0 n = 0)

   [<a name="MIN_ASSOC-val"><b>MIN_ASSOC</b></a>]  Theorem

      |- ∀m n p. MIN m (MIN n p) = MIN (MIN m n) p

   [<a name="MIN_COMM-val"><b>MIN_COMM</b></a>]  Theorem

      |- ∀m n. MIN m n = MIN n m

   [<a name="MIN_IDEM-val"><b>MIN_IDEM</b></a>]  Theorem

      |- ∀n. MIN n n = n

   [<a name="MIN_LE-val"><b>MIN_LE</b></a>]  Theorem

      |- ∀n m p.
           (MIN m n ≤ p ⇔ m ≤ p ∨ n ≤ p) ∧ (p ≤ MIN m n ⇔ p ≤ m ∧ p ≤ n)

   [<a name="MIN_LT-val"><b>MIN_LT</b></a>]  Theorem

      |- ∀n m p.
           (MIN m n &lt; p ⇔ m &lt; p ∨ n &lt; p) ∧ (p &lt; MIN m n ⇔ p &lt; m ∧ p &lt; n)

   [<a name="MIN_MAX_EQ-val"><b>MIN_MAX_EQ</b></a>]  Theorem

      |- ∀m n. (MIN m n = MAX m n) ⇔ (m = n)

   [<a name="MIN_MAX_LE-val"><b>MIN_MAX_LE</b></a>]  Theorem

      |- ∀m n. MIN m n ≤ MAX m n

   [<a name="MIN_MAX_LT-val"><b>MIN_MAX_LT</b></a>]  Theorem

      |- ∀m n. MIN m n &lt; MAX m n ⇔ m ≠ n

   [<a name="MIN_MAX_PRED-val"><b>MIN_MAX_PRED</b></a>]  Theorem

      |- ∀P m n. P m ∧ P n ⇒ P (MIN m n) ∧ P (MAX m n)

   [<a name="MODEQ_0-val"><b>MODEQ_0</b></a>]  Theorem

      |- 0 &lt; n ⇒ MODEQ n n 0

   [<a name="MODEQ_0_CONG-val"><b>MODEQ_0_CONG</b></a>]  Theorem

      |- MODEQ 0 m1 m2 ⇔ (m1 = m2)

   [<a name="MODEQ_INTRO_CONG-val"><b>MODEQ_INTRO_CONG</b></a>]  Theorem

      |- 0 &lt; n ⇒ MODEQ n e0 e1 ⇒ (e0 MOD n = e1 MOD n)

   [<a name="MODEQ_MOD-val"><b>MODEQ_MOD</b></a>]  Theorem

      |- 0 &lt; n ⇒ MODEQ n (x MOD n) x

   [<a name="MODEQ_MULT_CONG-val"><b>MODEQ_MULT_CONG</b></a>]  Theorem

      |- MODEQ n x0 x1 ⇒ MODEQ n y0 y1 ⇒ MODEQ n (x0 * y0) (x1 * y1)

   [<a name="MODEQ_NONZERO_MODEQUALITY-val"><b>MODEQ_NONZERO_MODEQUALITY</b></a>]  Theorem

      |- 0 &lt; n ⇒ (MODEQ n m1 m2 ⇔ (m1 MOD n = m2 MOD n))

   [<a name="MODEQ_NUMERAL-val"><b>MODEQ_NUMERAL</b></a>]  Theorem

      |- (NUMERAL n ≤ NUMERAL m ⇒
          MODEQ (NUMERAL (BIT1 n)) (NUMERAL (BIT1 m))
            (NUMERAL (BIT1 m) MOD NUMERAL (BIT1 n))) ∧
         (NUMERAL n ≤ NUMERAL m ⇒
          MODEQ (NUMERAL (BIT1 n)) (NUMERAL (BIT2 m))
            (NUMERAL (BIT2 m) MOD NUMERAL (BIT1 n))) ∧
         (NUMERAL n ≤ NUMERAL m ⇒
          MODEQ (NUMERAL (BIT2 n)) (NUMERAL (BIT2 m))
            (NUMERAL (BIT2 m) MOD NUMERAL (BIT2 n))) ∧
         (NUMERAL n &lt; NUMERAL m ⇒
          MODEQ (NUMERAL (BIT2 n)) (NUMERAL (BIT1 m))
            (NUMERAL (BIT1 m) MOD NUMERAL (BIT2 n)))

   [<a name="MODEQ_PLUS_CONG-val"><b>MODEQ_PLUS_CONG</b></a>]  Theorem

      |- MODEQ n x0 x1 ⇒ MODEQ n y0 y1 ⇒ MODEQ n (x0 + y0) (x1 + y1)

   [<a name="MODEQ_REFL-val"><b>MODEQ_REFL</b></a>]  Theorem

      |- ∀x. MODEQ n x x

   [<a name="MODEQ_SYM-val"><b>MODEQ_SYM</b></a>]  Theorem

      |- MODEQ n x y ⇔ MODEQ n y x

   [<a name="MODEQ_THM-val"><b>MODEQ_THM</b></a>]  Theorem

      |- MODEQ n m1 m2 ⇔
         (n = 0) ∧ (m1 = m2) ∨ 0 &lt; n ∧ (m1 MOD n = m2 MOD n)

   [<a name="MODEQ_TRANS-val"><b>MODEQ_TRANS</b></a>]  Theorem

      |- ∀x y z. MODEQ n x y ∧ MODEQ n y z ⇒ MODEQ n x z

   [<a name="MOD_1-val"><b>MOD_1</b></a>]  Theorem

      |- ∀k. k MOD 1 = 0

   [<a name="MOD_2-val"><b>MOD_2</b></a>]  Theorem

      |- ∀n. n MOD 2 = if EVEN n then 0 else 1

   [<a name="MOD_COMMON_FACTOR-val"><b>MOD_COMMON_FACTOR</b></a>]  Theorem

      |- ∀n p q. 0 &lt; n ∧ 0 &lt; q ⇒ (n * p MOD q = (n * p) MOD (n * q))

   [<a name="MOD_ELIM-val"><b>MOD_ELIM</b></a>]  Theorem

      |- ∀P x n. 0 &lt; n ∧ P x ∧ (∀y. P (y + n) ⇒ P y) ⇒ P (x MOD n)

   [<a name="MOD_EQ_0-val"><b>MOD_EQ_0</b></a>]  Theorem

      |- ∀n. 0 &lt; n ⇒ ∀k. (k * n) MOD n = 0

   [<a name="MOD_EQ_0_DIVISOR-val"><b>MOD_EQ_0_DIVISOR</b></a>]  Theorem

      |- 0 &lt; n ⇒ ((k MOD n = 0) ⇔ ∃d. k = d * n)

   [<a name="MOD_LESS-val"><b>MOD_LESS</b></a>]  Theorem

      |- ∀m n. 0 &lt; n ⇒ m MOD n &lt; n

   [<a name="MOD_LESS_EQ-val"><b>MOD_LESS_EQ</b></a>]  Theorem

      |- 0 &lt; y ⇒ x MOD y ≤ x

   [<a name="MOD_LIFT_PLUS-val"><b>MOD_LIFT_PLUS</b></a>]  Theorem

      |- 0 &lt; n ∧ k &lt; n − x MOD n ⇒ ((x + k) MOD n = x MOD n + k)

   [<a name="MOD_LIFT_PLUS_IFF-val"><b>MOD_LIFT_PLUS_IFF</b></a>]  Theorem

      |- 0 &lt; n ⇒ (((x + k) MOD n = x MOD n + k) ⇔ k &lt; n − x MOD n)

   [<a name="MOD_MOD-val"><b>MOD_MOD</b></a>]  Theorem

      |- ∀n. 0 &lt; n ⇒ ∀k. k MOD n MOD n = k MOD n

   [<a name="MOD_MULT-val"><b>MOD_MULT</b></a>]  Theorem

      |- ∀n r. r &lt; n ⇒ ∀q. (q * n + r) MOD n = r

   [<a name="MOD_MULT_MOD-val"><b>MOD_MULT_MOD</b></a>]  Theorem

      |- ∀m n. 0 &lt; n ∧ 0 &lt; m ⇒ ∀x. x MOD (n * m) MOD n = x MOD n

   [<a name="MOD_ONE-val"><b>MOD_ONE</b></a>]  Theorem

      |- ∀k. k MOD SUC 0 = 0

   [<a name="MOD_P-val"><b>MOD_P</b></a>]  Theorem

      |- ∀P p q.
           0 &lt; q ⇒ (P (p MOD q) ⇔ ∃k r. (p = k * q + r) ∧ r &lt; q ∧ P r)

   [<a name="MOD_PLUS-val"><b>MOD_PLUS</b></a>]  Theorem

      |- ∀n. 0 &lt; n ⇒ ∀j k. (j MOD n + k MOD n) MOD n = (j + k) MOD n

   [<a name="MOD_P_UNIV-val"><b>MOD_P_UNIV</b></a>]  Theorem

      |- ∀P m n.
           0 &lt; n ⇒ (P (m MOD n) ⇔ ∀q r. (m = q * n + r) ∧ r &lt; n ⇒ P r)

   [<a name="MOD_SUB-val"><b>MOD_SUB</b></a>]  Theorem

      |- 0 &lt; n ∧ n * q ≤ m ⇒ ((m − n * q) MOD n = m MOD n)

   [<a name="MOD_SUC-val"><b>MOD_SUC</b></a>]  Theorem

      |- 0 &lt; y ∧ SUC x ≠ SUC (x DIV y) * y ⇒ (SUC x MOD y = SUC (x MOD y))

   [<a name="MOD_SUC_IFF-val"><b>MOD_SUC_IFF</b></a>]  Theorem

      |- 0 &lt; y ⇒
         ((SUC x MOD y = SUC (x MOD y)) ⇔ SUC x ≠ SUC (x DIV y) * y)

   [<a name="MOD_TIMES-val"><b>MOD_TIMES</b></a>]  Theorem

      |- ∀n. 0 &lt; n ⇒ ∀q r. (q * n + r) MOD n = r MOD n

   [<a name="MOD_TIMES2-val"><b>MOD_TIMES2</b></a>]  Theorem

      |- ∀n. 0 &lt; n ⇒ ∀j k. (j MOD n * k MOD n) MOD n = (j * k) MOD n

   [<a name="MOD_TIMES_SUB-val"><b>MOD_TIMES_SUB</b></a>]  Theorem

      |- ∀n q r.
           0 &lt; n ∧ 0 &lt; q ∧ r ≤ n ⇒ ((q * n − r) MOD n = (n − r) MOD n)

   [<a name="MOD_UNIQUE-val"><b>MOD_UNIQUE</b></a>]  Theorem

      |- ∀n k r. (∃q. (k = q * n + r) ∧ r &lt; n) ⇒ (k MOD n = r)

   [<a name="MULT_0-val"><b>MULT_0</b></a>]  Theorem

      |- ∀m. m * 0 = 0

   [<a name="MULT_ASSOC-val"><b>MULT_ASSOC</b></a>]  Theorem

      |- ∀m n p. m * (n * p) = m * n * p

   [<a name="MULT_CLAUSES-val"><b>MULT_CLAUSES</b></a>]  Theorem

      |- ∀m n.
           (0 * m = 0) ∧ (m * 0 = 0) ∧ (1 * m = m) ∧ (m * 1 = m) ∧
           (SUC m * n = m * n + n) ∧ (m * SUC n = m + m * n)

   [<a name="MULT_COMM-val"><b>MULT_COMM</b></a>]  Theorem

      |- ∀m n. m * n = n * m

   [<a name="MULT_DIV-val"><b>MULT_DIV</b></a>]  Theorem

      |- ∀n q. 0 &lt; n ⇒ (q * n DIV n = q)

   [<a name="MULT_EQ_0-val"><b>MULT_EQ_0</b></a>]  Theorem

      |- ∀m n. (m * n = 0) ⇔ (m = 0) ∨ (n = 0)

   [<a name="MULT_EQ_1-val"><b>MULT_EQ_1</b></a>]  Theorem

      |- ∀x y. (x * y = 1) ⇔ (x = 1) ∧ (y = 1)

   [<a name="MULT_EQ_DIV-val"><b>MULT_EQ_DIV</b></a>]  Theorem

      |- 0 &lt; x ⇒ ((x * y = z) ⇔ (y = z DIV x) ∧ (z MOD x = 0))

   [<a name="MULT_EQ_ID-val"><b>MULT_EQ_ID</b></a>]  Theorem

      |- ∀m n. (m * n = n) ⇔ (m = 1) ∨ (n = 0)

   [<a name="MULT_EXP_MONO-val"><b>MULT_EXP_MONO</b></a>]  Theorem

      |- ∀p q n m. (n * SUC q ** p = m * SUC q ** p) ⇔ (n = m)

   [<a name="MULT_INCREASES-val"><b>MULT_INCREASES</b></a>]  Theorem

      |- ∀m n. 1 &lt; m ∧ 0 &lt; n ⇒ SUC n ≤ m * n

   [<a name="MULT_LEFT_1-val"><b>MULT_LEFT_1</b></a>]  Theorem

      |- ∀m. 1 * m = m

   [<a name="MULT_LESS_EQ_SUC-val"><b>MULT_LESS_EQ_SUC</b></a>]  Theorem

      |- ∀m n p. m ≤ n ⇔ SUC p * m ≤ SUC p * n

   [<a name="MULT_MONO_EQ-val"><b>MULT_MONO_EQ</b></a>]  Theorem

      |- ∀m i n. (SUC n * m = SUC n * i) ⇔ (m = i)

   [<a name="MULT_RIGHT_1-val"><b>MULT_RIGHT_1</b></a>]  Theorem

      |- ∀m. m * 1 = m

   [<a name="MULT_SUC-val"><b>MULT_SUC</b></a>]  Theorem

      |- ∀m n. m * SUC n = m + m * n

   [<a name="MULT_SUC_EQ-val"><b>MULT_SUC_EQ</b></a>]  Theorem

      |- ∀p m n. (n * SUC p = m * SUC p) ⇔ (n = m)

   [<a name="MULT_SYM-val"><b>MULT_SYM</b></a>]  Theorem

      |- ∀m n. m * n = n * m

   [<a name="NORM_0-val"><b>NORM_0</b></a>]  Theorem

      |- 0 = 0

   [<a name="NOT_EXP_0-val"><b>NOT_EXP_0</b></a>]  Theorem

      |- ∀m n. SUC n ** m ≠ 0

   [<a name="NOT_GREATER-val"><b>NOT_GREATER</b></a>]  Theorem

      |- ∀m n. ¬(m &gt; n) ⇔ m ≤ n

   [<a name="NOT_GREATER_EQ-val"><b>NOT_GREATER_EQ</b></a>]  Theorem

      |- ∀m n. ¬(m ≥ n) ⇔ SUC m ≤ n

   [<a name="NOT_LEQ-val"><b>NOT_LEQ</b></a>]  Theorem

      |- ∀m n. ¬(m ≤ n) ⇔ SUC n ≤ m

   [<a name="NOT_LESS-val"><b>NOT_LESS</b></a>]  Theorem

      |- ∀m n. ¬(m &lt; n) ⇔ n ≤ m

   [<a name="NOT_LESS_EQUAL-val"><b>NOT_LESS_EQUAL</b></a>]  Theorem

      |- ∀m n. ¬(m ≤ n) ⇔ n &lt; m

   [<a name="NOT_NUM_EQ-val"><b>NOT_NUM_EQ</b></a>]  Theorem

      |- ∀m n. m ≠ n ⇔ SUC m ≤ n ∨ SUC n ≤ m

   [<a name="NOT_ODD_EQ_EVEN-val"><b>NOT_ODD_EQ_EVEN</b></a>]  Theorem

      |- ∀n m. SUC (n + n) ≠ m + m

   [<a name="NOT_STRICTLY_DECREASING-val"><b>NOT_STRICTLY_DECREASING</b></a>]  Theorem

      |- ∀f. ¬∀n. f (SUC n) &lt; f n

   [<a name="NOT_SUC_ADD_LESS_EQ-val"><b>NOT_SUC_ADD_LESS_EQ</b></a>]  Theorem

      |- ∀m n. ¬(SUC (m + n) ≤ m)

   [<a name="NOT_SUC_LESS_EQ-val"><b>NOT_SUC_LESS_EQ</b></a>]  Theorem

      |- ∀n m. ¬(SUC n ≤ m) ⇔ m ≤ n

   [<a name="NOT_SUC_LESS_EQ_0-val"><b>NOT_SUC_LESS_EQ_0</b></a>]  Theorem

      |- ∀n. ¬(SUC n ≤ 0)

   [<a name="NOT_ZERO_LT_ZERO-val"><b>NOT_ZERO_LT_ZERO</b></a>]  Theorem

      |- ∀n. n ≠ 0 ⇔ 0 &lt; n

   [<a name="NRC_0-val"><b>NRC_0</b></a>]  Theorem

      |- ∀R x y. NRC R 0 x y ⇔ (x = y)

   [<a name="NRC_1-val"><b>NRC_1</b></a>]  Theorem

      |- NRC R 1 x y ⇔ R x y

   [<a name="NRC_ADD_E-val"><b>NRC_ADD_E</b></a>]  Theorem

      |- ∀m n x z. NRC R (m + n) x z ⇒ ∃y. NRC R m x y ∧ NRC R n y z

   [<a name="NRC_ADD_EQN-val"><b>NRC_ADD_EQN</b></a>]  Theorem

      |- NRC R (m + n) x z ⇔ ∃y. NRC R m x y ∧ NRC R n y z

   [<a name="NRC_ADD_I-val"><b>NRC_ADD_I</b></a>]  Theorem

      |- ∀m n x y z. NRC R m x y ∧ NRC R n y z ⇒ NRC R (m + n) x z

   [<a name="NRC_RTC-val"><b>NRC_RTC</b></a>]  Theorem

      |- ∀n x y. NRC R n x y ⇒ R^* x y

   [<a name="NRC_SUC_RECURSE_LEFT-val"><b>NRC_SUC_RECURSE_LEFT</b></a>]  Theorem

      |- NRC R (SUC n) x y ⇔ ∃z. NRC R n x z ∧ R z y

   [<a name="NUMERAL_MULT_EQ_DIV-val"><b>NUMERAL_MULT_EQ_DIV</b></a>]  Theorem

      |- ((NUMERAL (BIT1 x) * y = NUMERAL z) ⇔
          (y = NUMERAL z DIV NUMERAL (BIT1 x)) ∧
          (NUMERAL z MOD NUMERAL (BIT1 x) = 0)) ∧
         ((NUMERAL (BIT2 x) * y = NUMERAL z) ⇔
          (y = NUMERAL z DIV NUMERAL (BIT2 x)) ∧
          (NUMERAL z MOD NUMERAL (BIT2 x) = 0))

   [<a name="ODD_ADD-val"><b>ODD_ADD</b></a>]  Theorem

      |- ∀m n. ODD (m + n) ⇔ (ODD m ⇎ ODD n)

   [<a name="ODD_DOUBLE-val"><b>ODD_DOUBLE</b></a>]  Theorem

      |- ∀n. ODD (SUC (2 * n))

   [<a name="ODD_EVEN-val"><b>ODD_EVEN</b></a>]  Theorem

      |- ∀n. ODD n ⇔ ¬EVEN n

   [<a name="ODD_EXISTS-val"><b>ODD_EXISTS</b></a>]  Theorem

      |- ∀n. ODD n ⇔ ∃m. n = SUC (2 * m)

   [<a name="ODD_MULT-val"><b>ODD_MULT</b></a>]  Theorem

      |- ∀m n. ODD (m * n) ⇔ ODD m ∧ ODD n

   [<a name="ODD_OR_EVEN-val"><b>ODD_OR_EVEN</b></a>]  Theorem

      |- ∀n. ∃m. (n = SUC (SUC 0) * m) ∨ (n = SUC (SUC 0) * m + 1)

   [<a name="ONE-val"><b>ONE</b></a>]  Theorem

      |- 1 = SUC 0

   [<a name="ONE_LT_EXP-val"><b>ONE_LT_EXP</b></a>]  Theorem

      |- ∀x y. 1 &lt; x ** y ⇔ 1 &lt; x ∧ 0 &lt; y

   [<a name="ONE_LT_MULT-val"><b>ONE_LT_MULT</b></a>]  Theorem

      |- ∀x y. 1 &lt; x * y ⇔ 0 &lt; x ∧ 1 &lt; y ∨ 0 &lt; y ∧ 1 &lt; x

   [<a name="ONE_LT_MULT_IMP-val"><b>ONE_LT_MULT_IMP</b></a>]  Theorem

      |- ∀p q. 1 &lt; p ∧ 0 &lt; q ⇒ 1 &lt; p * q

   [<a name="ONE_MOD-val"><b>ONE_MOD</b></a>]  Theorem

      |- 1 &lt; n ⇒ (1 MOD n = 1)

   [<a name="ONE_MOD_IFF-val"><b>ONE_MOD_IFF</b></a>]  Theorem

      |- 1 &lt; n ⇔ 0 &lt; n ∧ (1 MOD n = 1)

   [<a name="ONE_ONE_UNBOUNDED-val"><b>ONE_ONE_UNBOUNDED</b></a>]  Theorem

      |- ∀f. ONE_ONE f ⇒ ∀b. ∃n. b &lt; f n

   [<a name="OR_LESS-val"><b>OR_LESS</b></a>]  Theorem

      |- ∀m n. SUC m ≤ n ⇒ m &lt; n

   [<a name="PRE_ELIM_THM-val"><b>PRE_ELIM_THM</b></a>]  Theorem

      |- P (PRE n) ⇔ ∀m. ((n = 0) ⇒ P 0) ∧ ((n = SUC m) ⇒ P m)

   [<a name="PRE_SUB-val"><b>PRE_SUB</b></a>]  Theorem

      |- ∀m n. PRE (m − n) = PRE m − n

   [<a name="PRE_SUB1-val"><b>PRE_SUB1</b></a>]  Theorem

      |- ∀m. PRE m = m − 1

   [<a name="PRE_SUC_EQ-val"><b>PRE_SUC_EQ</b></a>]  Theorem

      |- ∀m n. 0 &lt; n ⇒ ((m = PRE n) ⇔ (SUC m = n))

   [<a name="RIGHT_ADD_DISTRIB-val"><b>RIGHT_ADD_DISTRIB</b></a>]  Theorem

      |- ∀m n p. (m + n) * p = m * p + n * p

   [<a name="RIGHT_SUB_DISTRIB-val"><b>RIGHT_SUB_DISTRIB</b></a>]  Theorem

      |- ∀m n p. (m − n) * p = m * p − n * p

   [<a name="RTC_NRC-val"><b>RTC_NRC</b></a>]  Theorem

      |- ∀x y. R^* x y ⇒ ∃n. NRC R n x y

   [<a name="RTC_eq_NRC-val"><b>RTC_eq_NRC</b></a>]  Theorem

      |- ∀R x y. R^* x y ⇔ ∃n. NRC R n x y

   [<a name="STRICTLY_INCREASING_ONE_ONE-val"><b>STRICTLY_INCREASING_ONE_ONE</b></a>]  Theorem

      |- ∀f. (∀n. f n &lt; f (SUC n)) ⇒ ONE_ONE f

   [<a name="STRICTLY_INCREASING_TC-val"><b>STRICTLY_INCREASING_TC</b></a>]  Theorem

      |- ∀f. (∀n. f n &lt; f (SUC n)) ⇒ ∀m n. m &lt; n ⇒ f m &lt; f n

   [<a name="STRICTLY_INCREASING_UNBOUNDED-val"><b>STRICTLY_INCREASING_UNBOUNDED</b></a>]  Theorem

      |- ∀f. (∀n. f n &lt; f (SUC n)) ⇒ ∀b. ∃n. b &lt; f n

   [<a name="SUB_0-val"><b>SUB_0</b></a>]  Theorem

      |- ∀m. (0 − m = 0) ∧ (m − 0 = m)

   [<a name="SUB_ADD-val"><b>SUB_ADD</b></a>]  Theorem

      |- ∀m n. n ≤ m ⇒ (m − n + n = m)

   [<a name="SUB_CANCEL-val"><b>SUB_CANCEL</b></a>]  Theorem

      |- ∀p n m. n ≤ p ∧ m ≤ p ⇒ ((p − n = p − m) ⇔ (n = m))

   [<a name="SUB_ELIM_THM-val"><b>SUB_ELIM_THM</b></a>]  Theorem

      |- P (a − b) ⇔ ∀d. ((b = a + d) ⇒ P 0) ∧ ((a = b + d) ⇒ P d)

   [<a name="SUB_EQUAL_0-val"><b>SUB_EQUAL_0</b></a>]  Theorem

      |- ∀c. c − c = 0

   [<a name="SUB_EQ_0-val"><b>SUB_EQ_0</b></a>]  Theorem

      |- ∀m n. (m − n = 0) ⇔ m ≤ n

   [<a name="SUB_EQ_EQ_0-val"><b>SUB_EQ_EQ_0</b></a>]  Theorem

      |- ∀m n. (m − n = m) ⇔ (m = 0) ∨ (n = 0)

   [<a name="SUB_LEFT_ADD-val"><b>SUB_LEFT_ADD</b></a>]  Theorem

      |- ∀m n p. m + (n − p) = if n ≤ p then m else m + n − p

   [<a name="SUB_LEFT_EQ-val"><b>SUB_LEFT_EQ</b></a>]  Theorem

      |- ∀m n p. (m = n − p) ⇔ (m + p = n) ∨ m ≤ 0 ∧ n ≤ p

   [<a name="SUB_LEFT_GREATER-val"><b>SUB_LEFT_GREATER</b></a>]  Theorem

      |- ∀m n p. m &gt; n − p ⇔ m + p &gt; n ∧ m &gt; 0

   [<a name="SUB_LEFT_GREATER_EQ-val"><b>SUB_LEFT_GREATER_EQ</b></a>]  Theorem

      |- ∀m n p. m ≥ n − p ⇔ m + p ≥ n

   [<a name="SUB_LEFT_LESS-val"><b>SUB_LEFT_LESS</b></a>]  Theorem

      |- ∀m n p. m &lt; n − p ⇔ m + p &lt; n

   [<a name="SUB_LEFT_LESS_EQ-val"><b>SUB_LEFT_LESS_EQ</b></a>]  Theorem

      |- ∀m n p. m ≤ n − p ⇔ m + p ≤ n ∨ m ≤ 0

   [<a name="SUB_LEFT_SUB-val"><b>SUB_LEFT_SUB</b></a>]  Theorem

      |- ∀m n p. m − (n − p) = if n ≤ p then m else m + p − n

   [<a name="SUB_LEFT_SUC-val"><b>SUB_LEFT_SUC</b></a>]  Theorem

      |- ∀m n. SUC (m − n) = if m ≤ n then SUC 0 else SUC m − n

   [<a name="SUB_LESS-val"><b>SUB_LESS</b></a>]  Theorem

      |- ∀m n. 0 &lt; n ∧ n ≤ m ⇒ m − n &lt; m

   [<a name="SUB_LESS_0-val"><b>SUB_LESS_0</b></a>]  Theorem

      |- ∀n m. m &lt; n ⇔ 0 &lt; n − m

   [<a name="SUB_LESS_EQ-val"><b>SUB_LESS_EQ</b></a>]  Theorem

      |- ∀n m. n − m ≤ n

   [<a name="SUB_LESS_EQ_ADD-val"><b>SUB_LESS_EQ_ADD</b></a>]  Theorem

      |- ∀m p. m ≤ p ⇒ ∀n. p − m ≤ n ⇔ p ≤ m + n

   [<a name="SUB_LESS_OR-val"><b>SUB_LESS_OR</b></a>]  Theorem

      |- ∀m n. n &lt; m ⇒ n ≤ m − 1

   [<a name="SUB_MOD-val"><b>SUB_MOD</b></a>]  Theorem

      |- ∀m n. 0 &lt; n ∧ n ≤ m ⇒ ((m − n) MOD n = m MOD n)

   [<a name="SUB_MONO_EQ-val"><b>SUB_MONO_EQ</b></a>]  Theorem

      |- ∀n m. SUC n − SUC m = n − m

   [<a name="SUB_PLUS-val"><b>SUB_PLUS</b></a>]  Theorem

      |- ∀a b c. a − (b + c) = a − b − c

   [<a name="SUB_RIGHT_ADD-val"><b>SUB_RIGHT_ADD</b></a>]  Theorem

      |- ∀m n p. m − n + p = if m ≤ n then p else m + p − n

   [<a name="SUB_RIGHT_EQ-val"><b>SUB_RIGHT_EQ</b></a>]  Theorem

      |- ∀m n p. (m − n = p) ⇔ (m = n + p) ∨ m ≤ n ∧ p ≤ 0

   [<a name="SUB_RIGHT_GREATER-val"><b>SUB_RIGHT_GREATER</b></a>]  Theorem

      |- ∀m n p. m − n &gt; p ⇔ m &gt; n + p

   [<a name="SUB_RIGHT_GREATER_EQ-val"><b>SUB_RIGHT_GREATER_EQ</b></a>]  Theorem

      |- ∀m n p. m − n ≥ p ⇔ m ≥ n + p ∨ 0 ≥ p

   [<a name="SUB_RIGHT_LESS-val"><b>SUB_RIGHT_LESS</b></a>]  Theorem

      |- ∀m n p. m − n &lt; p ⇔ m &lt; n + p ∧ 0 &lt; p

   [<a name="SUB_RIGHT_LESS_EQ-val"><b>SUB_RIGHT_LESS_EQ</b></a>]  Theorem

      |- ∀m n p. m − n ≤ p ⇔ m ≤ n + p

   [<a name="SUB_RIGHT_SUB-val"><b>SUB_RIGHT_SUB</b></a>]  Theorem

      |- ∀m n p. m − n − p = m − (n + p)

   [<a name="SUB_SUB-val"><b>SUB_SUB</b></a>]  Theorem

      |- ∀b c. c ≤ b ⇒ ∀a. a − (b − c) = a + c − b

   [<a name="SUC_ADD_SYM-val"><b>SUC_ADD_SYM</b></a>]  Theorem

      |- ∀m n. SUC (m + n) = SUC n + m

   [<a name="SUC_ELIM_NUMERALS-val"><b>SUC_ELIM_NUMERALS</b></a>]  Theorem

      |- ∀f g.
           (∀n. g (SUC n) = f n (SUC n)) ⇔
           (∀n.
              g (NUMERAL (BIT1 n)) =
              f (NUMERAL (BIT1 n) − 1) (NUMERAL (BIT1 n))) ∧
           ∀n.
             g (NUMERAL (BIT2 n)) = f (NUMERAL (BIT1 n)) (NUMERAL (BIT2 n))

   [<a name="SUC_ELIM_THM-val"><b>SUC_ELIM_THM</b></a>]  Theorem

      |- ∀P. (∀n. P (SUC n) n) ⇔ ∀n. 0 &lt; n ⇒ P n (n − 1)

   [<a name="SUC_MOD-val"><b>SUC_MOD</b></a>]  Theorem

      |- ∀n a b.
           0 &lt; n ⇒ ((SUC a MOD n = SUC b MOD n) ⇔ (a MOD n = b MOD n))

   [<a name="SUC_NOT-val"><b>SUC_NOT</b></a>]  Theorem

      |- ∀n. 0 ≠ SUC n

   [<a name="SUC_ONE_ADD-val"><b>SUC_ONE_ADD</b></a>]  Theorem

      |- ∀n. SUC n = 1 + n

   [<a name="SUC_PRE-val"><b>SUC_PRE</b></a>]  Theorem

      |- 0 &lt; m ⇔ (SUC (PRE m) = m)

   [<a name="SUC_SUB1-val"><b>SUC_SUB1</b></a>]  Theorem

      |- ∀m. SUC m − 1 = m

   [<a name="TC_eq_NRC-val"><b>TC_eq_NRC</b></a>]  Theorem

      |- ∀R x y. R⁺ x y ⇔ ∃n. NRC R (SUC n) x y

   [<a name="TIMES2-val"><b>TIMES2</b></a>]  Theorem

      |- ∀n. 2 * n = n + n

   [<a name="TWO-val"><b>TWO</b></a>]  Theorem

      |- 2 = SUC 1

   [<a name="WOP-val"><b>WOP</b></a>]  Theorem

      |- ∀P. (∃n. P n) ⇒ ∃n. P n ∧ ∀m. m &lt; n ⇒ ¬P m

   [<a name="X_LE_DIV-val"><b>X_LE_DIV</b></a>]  Theorem

      |- ∀x y z. 0 &lt; z ⇒ (x ≤ y DIV z ⇔ x * z ≤ y)

   [<a name="X_LE_X_EXP-val"><b>X_LE_X_EXP</b></a>]  Theorem

      |- 0 &lt; n ⇒ x ≤ x ** n

   [<a name="X_LT_DIV-val"><b>X_LT_DIV</b></a>]  Theorem

      |- ∀x y z. 0 &lt; z ⇒ (x &lt; y DIV z ⇔ (x + 1) * z ≤ y)

   [<a name="X_LT_EXP_X-val"><b>X_LT_EXP_X</b></a>]  Theorem

      |- 1 &lt; b ⇒ x &lt; b ** x

   [<a name="X_LT_EXP_X_IFF-val"><b>X_LT_EXP_X_IFF</b></a>]  Theorem

      |- x &lt; b ** x ⇔ 1 &lt; b ∨ (x = 0)

   [<a name="X_MOD_Y_EQ_X-val"><b>X_MOD_Y_EQ_X</b></a>]  Theorem

      |- ∀x y. 0 &lt; y ⇒ ((x MOD y = x) ⇔ x &lt; y)

   [<a name="ZERO_DIV-val"><b>ZERO_DIV</b></a>]  Theorem

      |- ∀n. 0 &lt; n ⇒ (0 DIV n = 0)

   [<a name="ZERO_EXP-val"><b>ZERO_EXP</b></a>]  Theorem

      |- 0 ** x = if x = 0 then 1 else 0

   [<a name="ZERO_LESS_ADD-val"><b>ZERO_LESS_ADD</b></a>]  Theorem

      |- ∀m n. 0 &lt; m + n ⇔ 0 &lt; m ∨ 0 &lt; n

   [<a name="ZERO_LESS_EQ-val"><b>ZERO_LESS_EQ</b></a>]  Theorem

      |- ∀n. 0 ≤ n

   [<a name="ZERO_LESS_EXP-val"><b>ZERO_LESS_EXP</b></a>]  Theorem

      |- ∀m n. 0 &lt; SUC n ** m

   [<a name="ZERO_LESS_MULT-val"><b>ZERO_LESS_MULT</b></a>]  Theorem

      |- ∀m n. 0 &lt; m * n ⇔ 0 &lt; m ∧ 0 &lt; n

   [<a name="ZERO_LT_EXP-val"><b>ZERO_LT_EXP</b></a>]  Theorem

      |- 0 &lt; x ** y ⇔ 0 &lt; x ∨ (y = 0)

   [<a name="ZERO_MOD-val"><b>ZERO_MOD</b></a>]  Theorem

      |- ∀n. 0 &lt; n ⇒ (0 MOD n = 0)

   [<a name="findq_divisor-val"><b>findq_divisor</b></a>]  Theorem

      |- n ≤ m ⇒ findq (a,m,n) * n ≤ a * m

   [<a name="findq_eq_0-val"><b>findq_eq_0</b></a>]  Theorem

      |- ∀a m n. (findq (a,m,n) = 0) ⇔ (a = 0)

   [<a name="findq_thm-val"><b>findq_thm</b></a>]  Theorem

      |- findq (a,m,n) =
         if n = 0 then
           a
         else
           (let d = 2 * n in if m &lt; d then a else findq (2 * a,m,d))

   [<a name="num_CASES-val"><b>num_CASES</b></a>]  Theorem

      |- ∀m. (m = 0) ∨ ∃n. m = SUC n

   [<a name="num_case_compute-val"><b>num_case_compute</b></a>]  Theorem

      |- ∀n. num_case f g n = if n = 0 then f else g (PRE n)

   [<a name="num_case_cong-val"><b>num_case_cong</b></a>]  Theorem

      |- ∀M M' b f.
           (M = M') ∧ ((M' = 0) ⇒ (b = b')) ∧
           (∀n. (M' = SUC n) ⇒ (f n = f' n)) ⇒
           (num_case b f M = num_case b' f' M')

   [<a name="transitive_measure-val"><b>transitive_measure</b></a>]  Theorem

      |- ∀f. transitive (measure f)

   [<a name="transitive_monotone-val"><b>transitive_monotone</b></a>]  Theorem

      |- ∀R f.
           transitive R ∧ (∀n. R (f n) (f (SUC n))) ⇒
           ∀m n. m &lt; n ⇒ R (f m) (f n)


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/num/theories/arithmeticScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-8</a></em></p></body></html>
