<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure int_arithTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure int_arithTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/integer/int_arithScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature int_arithTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#bmarker_def-val">bmarker_def</a> : thm
<a name="line7"></a>
<a name="line8"></a>  (*  Theorems  *)
<a name="line9"></a>    val <a href="#CONJ_EQ_ELIM-val">CONJ_EQ_ELIM</a> : thm
<a name="line10"></a>    val <a href="#HO_SUB_ELIM-val">HO_SUB_ELIM</a> : thm
<a name="line11"></a>    val <a href="#INT_DIVIDES_LRMUL-val">INT_DIVIDES_LRMUL</a> : thm
<a name="line12"></a>    val <a href="#INT_DIVIDES_RELPRIME_MUL-val">INT_DIVIDES_RELPRIME_MUL</a> : thm
<a name="line13"></a>    val <a href="#INT_LINEAR_GCD-val">INT_LINEAR_GCD</a> : thm
<a name="line14"></a>    val <a href="#INT_LT_ADD_NUMERAL-val">INT_LT_ADD_NUMERAL</a> : thm
<a name="line15"></a>    val <a href="#INT_NUM_COND-val">INT_NUM_COND</a> : thm
<a name="line16"></a>    val <a href="#INT_NUM_DIVIDES-val">INT_NUM_DIVIDES</a> : thm
<a name="line17"></a>    val <a href="#INT_NUM_EVEN-val">INT_NUM_EVEN</a> : thm
<a name="line18"></a>    val <a href="#INT_NUM_EXISTS-val">INT_NUM_EXISTS</a> : thm
<a name="line19"></a>    val <a href="#INT_NUM_FORALL-val">INT_NUM_FORALL</a> : thm
<a name="line20"></a>    val <a href="#INT_NUM_ODD-val">INT_NUM_ODD</a> : thm
<a name="line21"></a>    val <a href="#INT_NUM_SUB-val">INT_NUM_SUB</a> : thm
<a name="line22"></a>    val <a href="#INT_NUM_UEXISTS-val">INT_NUM_UEXISTS</a> : thm
<a name="line23"></a>    val <a href="#INT_SUB_SUB3-val">INT_SUB_SUB3</a> : thm
<a name="line24"></a>    val <a href="#NOT_INT_DIVIDES-val">NOT_INT_DIVIDES</a> : thm
<a name="line25"></a>    val <a href="#NOT_INT_DIVIDES_POS-val">NOT_INT_DIVIDES_POS</a> : thm
<a name="line26"></a>    val <a href="#add_to_great-val">add_to_great</a> : thm
<a name="line27"></a>    val <a href="#bmarker_rewrites-val">bmarker_rewrites</a> : thm
<a name="line28"></a>    val <a href="#bot_and_greaters-val">bot_and_greaters</a> : thm
<a name="line29"></a>    val <a href="#can_get_big-val">can_get_big</a> : thm
<a name="line30"></a>    val <a href="#can_get_small-val">can_get_small</a> : thm
<a name="line31"></a>    val <a href="#cooper_lemma_1-val">cooper_lemma_1</a> : thm
<a name="line32"></a>    val <a href="#elim_eq-val">elim_eq</a> : thm
<a name="line33"></a>    val <a href="#elim_eq_coeffs-val">elim_eq_coeffs</a> : thm
<a name="line34"></a>    val <a href="#elim_le_coeffs-val">elim_le_coeffs</a> : thm
<a name="line35"></a>    val <a href="#elim_lt_coeffs1-val">elim_lt_coeffs1</a> : thm
<a name="line36"></a>    val <a href="#elim_lt_coeffs2-val">elim_lt_coeffs2</a> : thm
<a name="line37"></a>    val <a href="#elim_minus_ones-val">elim_minus_ones</a> : thm
<a name="line38"></a>    val <a href="#elim_neg_ones-val">elim_neg_ones</a> : thm
<a name="line39"></a>    val <a href="#eq_context_rwt1-val">eq_context_rwt1</a> : thm
<a name="line40"></a>    val <a href="#eq_context_rwt2-val">eq_context_rwt2</a> : thm
<a name="line41"></a>    val <a href="#eq_justify_multiplication-val">eq_justify_multiplication</a> : thm
<a name="line42"></a>    val <a href="#eq_move_all_left-val">eq_move_all_left</a> : thm
<a name="line43"></a>    val <a href="#eq_move_all_right-val">eq_move_all_right</a> : thm
<a name="line44"></a>    val <a href="#eq_move_left_left-val">eq_move_left_left</a> : thm
<a name="line45"></a>    val <a href="#eq_move_left_right-val">eq_move_left_right</a> : thm
<a name="line46"></a>    val <a href="#eq_move_right_left-val">eq_move_right_left</a> : thm
<a name="line47"></a>    val <a href="#gcd1thm-val">gcd1thm</a> : thm
<a name="line48"></a>    val <a href="#gcd21_thm-val">gcd21_thm</a> : thm
<a name="line49"></a>    val <a href="#gcdthm2-val">gcdthm2</a> : thm
<a name="line50"></a>    val <a href="#in_additive_range-val">in_additive_range</a> : thm
<a name="line51"></a>    val <a href="#in_subtractive_range-val">in_subtractive_range</a> : thm
<a name="line52"></a>    val <a href="#justify_divides-val">justify_divides</a> : thm
<a name="line53"></a>    val <a href="#justify_divides2-val">justify_divides2</a> : thm
<a name="line54"></a>    val <a href="#justify_divides3-val">justify_divides3</a> : thm
<a name="line55"></a>    val <a href="#lcm_eliminate-val">lcm_eliminate</a> : thm
<a name="line56"></a>    val <a href="#le_context_rwt1-val">le_context_rwt1</a> : thm
<a name="line57"></a>    val <a href="#le_context_rwt2-val">le_context_rwt2</a> : thm
<a name="line58"></a>    val <a href="#le_context_rwt3-val">le_context_rwt3</a> : thm
<a name="line59"></a>    val <a href="#le_context_rwt4-val">le_context_rwt4</a> : thm
<a name="line60"></a>    val <a href="#le_context_rwt5-val">le_context_rwt5</a> : thm
<a name="line61"></a>    val <a href="#le_move_all_right-val">le_move_all_right</a> : thm
<a name="line62"></a>    val <a href="#le_move_right_left-val">le_move_right_left</a> : thm
<a name="line63"></a>    val <a href="#less_to_leq_samel-val">less_to_leq_samel</a> : thm
<a name="line64"></a>    val <a href="#less_to_leq_samer-val">less_to_leq_samer</a> : thm
<a name="line65"></a>    val <a href="#lt_justify_multiplication-val">lt_justify_multiplication</a> : thm
<a name="line66"></a>    val <a href="#lt_move_all_left-val">lt_move_all_left</a> : thm
<a name="line67"></a>    val <a href="#lt_move_all_right-val">lt_move_all_right</a> : thm
<a name="line68"></a>    val <a href="#lt_move_left_left-val">lt_move_left_left</a> : thm
<a name="line69"></a>    val <a href="#lt_move_left_right-val">lt_move_left_right</a> : thm
<a name="line70"></a>    val <a href="#move_sub-val">move_sub</a> : thm
<a name="line71"></a>    val <a href="#not_less-val">not_less</a> : thm
<a name="line72"></a>    val <a href="#positive_product_implication-val">positive_product_implication</a> : thm
<a name="line73"></a>    val <a href="#restricted_quantification_simp-val">restricted_quantification_simp</a> : thm
<a name="line74"></a>    val <a href="#subtract_to_small-val">subtract_to_small</a> : thm
<a name="line75"></a>    val <a href="#top_and_lessers-val">top_and_lessers</a> : thm
<a name="line76"></a>
<a name="line77"></a>  val int_arith_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line78"></a>(*
   [gcd] Parent theory of "int_arith"

   [integer] Parent theory of "int_arith"

   [<a name="bmarker_def-val"><b>bmarker_def</b></a>]  Definition

      |- ∀b. int_arith$bmarker b ⇔ b

   [<a name="CONJ_EQ_ELIM-val"><b>CONJ_EQ_ELIM</b></a>]  Theorem

      |- ∀P v e. (v = e) ∧ P v ⇔ (v = e) ∧ P e

   [<a name="HO_SUB_ELIM-val"><b>HO_SUB_ELIM</b></a>]  Theorem

      |- ∀P a b. P (&(a − b)) ⇔ &b ≤ &a ∧ P (&a + -&b) ∨ &a &lt; &b ∧ P 0

   [<a name="INT_DIVIDES_LRMUL-val"><b>INT_DIVIDES_LRMUL</b></a>]  Theorem

      |- ∀p q r. q ≠ 0 ⇒ (p * q int_divides r * q ⇔ p int_divides r)

   [<a name="INT_DIVIDES_RELPRIME_MUL-val"><b>INT_DIVIDES_RELPRIME_MUL</b></a>]  Theorem

      |- ∀p q r. (gcd p q = 1) ⇒ (&p int_divides &q * r ⇔ &p int_divides r)

   [<a name="INT_LINEAR_GCD-val"><b>INT_LINEAR_GCD</b></a>]  Theorem

      |- ∀n m. ∃p q. p * &n + q * &m = &gcd n m

   [<a name="INT_LT_ADD_NUMERAL-val"><b>INT_LT_ADD_NUMERAL</b></a>]  Theorem

      |- ∀x y.
           x &lt; x + &NUMERAL (BIT1 y) ∧ x &lt; x + &NUMERAL (BIT2 y) ∧
           ¬(x &lt; x + -&NUMERAL y)

   [<a name="INT_NUM_COND-val"><b>INT_NUM_COND</b></a>]  Theorem

      |- ∀b n m. &(if b then n else m) = if b then &n else &m

   [<a name="INT_NUM_DIVIDES-val"><b>INT_NUM_DIVIDES</b></a>]  Theorem

      |- ∀n m. &n int_divides &m ⇔ divides n m

   [<a name="INT_NUM_EVEN-val"><b>INT_NUM_EVEN</b></a>]  Theorem

      |- ∀n. EVEN n ⇔ 2 int_divides &n

   [<a name="INT_NUM_EXISTS-val"><b>INT_NUM_EXISTS</b></a>]  Theorem

      |- (∃n. P (&n)) ⇔ ∃x. 0 ≤ x ∧ P x

   [<a name="INT_NUM_FORALL-val"><b>INT_NUM_FORALL</b></a>]  Theorem

      |- (∀n. P (&n)) ⇔ ∀x. 0 ≤ x ⇒ P x

   [<a name="INT_NUM_ODD-val"><b>INT_NUM_ODD</b></a>]  Theorem

      |- ∀n. ODD n ⇔ ¬(2 int_divides &n)

   [<a name="INT_NUM_SUB-val"><b>INT_NUM_SUB</b></a>]  Theorem

      |- ∀n m. &(n − m) = if &n &lt; &m then 0 else &n − &m

   [<a name="INT_NUM_UEXISTS-val"><b>INT_NUM_UEXISTS</b></a>]  Theorem

      |- (∃!n. P (&n)) ⇔ ∃!x. 0 ≤ x ∧ P x

   [<a name="INT_SUB_SUB3-val"><b>INT_SUB_SUB3</b></a>]  Theorem

      |- ∀x y z. x − (y − z) = x + z − y

   [<a name="NOT_INT_DIVIDES-val"><b>NOT_INT_DIVIDES</b></a>]  Theorem

      |- ∀c d.
           c ≠ 0 ⇒
           (¬(c int_divides d) ⇔
            ∃i. 1 ≤ i ∧ i ≤ ABS c − 1 ∧ c int_divides d + i)

   [<a name="NOT_INT_DIVIDES_POS-val"><b>NOT_INT_DIVIDES_POS</b></a>]  Theorem

      |- ∀n d.
           n ≠ 0 ⇒
           (¬(&n int_divides d) ⇔
            ∃i. (1 ≤ i ∧ i ≤ &n − 1) ∧ &n int_divides d + i)

   [<a name="add_to_great-val"><b>add_to_great</b></a>]  Theorem

      |- ∀x d. 0 &lt; d ⇒ ∃k. 0 &lt; x + k * d ∧ x + k * d ≤ d

   [<a name="bmarker_rewrites-val"><b>bmarker_rewrites</b></a>]  Theorem

      |- ∀p q r.
           (q ∧ int_arith$bmarker p ⇔ int_arith$bmarker p ∧ q) ∧
           (q ∧ int_arith$bmarker p ∧ r ⇔ int_arith$bmarker p ∧ q ∧ r) ∧
           ((int_arith$bmarker p ∧ q) ∧ r ⇔ int_arith$bmarker p ∧ q ∧ r)

   [<a name="bot_and_greaters-val"><b>bot_and_greaters</b></a>]  Theorem

      |- ∀P d x0. (∀x. P x ⇒ P (x + d)) ∧ P x0 ⇒ ∀c. 0 &lt; c ⇒ P (x0 + c * d)

   [<a name="can_get_big-val"><b>can_get_big</b></a>]  Theorem

      |- ∀x y d. 0 &lt; d ⇒ ∃c. 0 &lt; c ∧ x &lt; y + c * d

   [<a name="can_get_small-val"><b>can_get_small</b></a>]  Theorem

      |- ∀x y d. 0 &lt; d ⇒ ∃c. 0 &lt; c ∧ y − c * d &lt; x

   [<a name="cooper_lemma_1-val"><b>cooper_lemma_1</b></a>]  Theorem

      |- ∀m n a b u v p q x d.
           (d = gcd (u * m) (a * n)) ∧ (&d = p * &u * &m + q * &a * &n) ∧
           m ≠ 0 ∧ n ≠ 0 ∧ a ≠ 0 ∧ u ≠ 0 ⇒
           (&m int_divides &a * x + b ∧ &n int_divides &u * x + v ⇔
            &m * &n int_divides &d * x + v * &m * p + b * &n * q ∧
            &d int_divides &a * v − &u * b)

   [<a name="elim_eq-val"><b>elim_eq</b></a>]  Theorem

      |- (x = y) ⇔ x &lt; y + 1 ∧ y &lt; x + 1

   [<a name="elim_eq_coeffs-val"><b>elim_eq_coeffs</b></a>]  Theorem

      |- ∀m x y. m ≠ 0 ⇒ ((&m * x = y) ⇔ &m int_divides y ∧ (x = y / &m))

   [<a name="elim_le_coeffs-val"><b>elim_le_coeffs</b></a>]  Theorem

      |- ∀m n x. 0 &lt; m ⇒ (0 ≤ m * x + n ⇔ 0 ≤ x + n / m)

   [<a name="elim_lt_coeffs1-val"><b>elim_lt_coeffs1</b></a>]  Theorem

      |- ∀n m x. m ≠ 0 ⇒ (&n &lt; &m * x ⇔ &n / &m &lt; x)

   [<a name="elim_lt_coeffs2-val"><b>elim_lt_coeffs2</b></a>]  Theorem

      |- ∀n m x.
           m ≠ 0 ⇒
           (&m * x &lt; &n ⇔
            x &lt; if &m int_divides &n then &n / &m else &n / &m + 1)

   [<a name="elim_minus_ones-val"><b>elim_minus_ones</b></a>]  Theorem

      |- ∀x. x + 1 − 1 = x

   [<a name="elim_neg_ones-val"><b>elim_neg_ones</b></a>]  Theorem

      |- ∀x. x + -1 + 1 = x

   [<a name="eq_context_rwt1-val"><b>eq_context_rwt1</b></a>]  Theorem

      |- (0 = c + x) ⇒ (0 ≤ c + y ⇔ x ≤ y)

   [<a name="eq_context_rwt2-val"><b>eq_context_rwt2</b></a>]  Theorem

      |- (0 = c + x) ⇒ (0 ≤ -c + y ⇔ -x ≤ y)

   [<a name="eq_justify_multiplication-val"><b>eq_justify_multiplication</b></a>]  Theorem

      |- ∀n x y. 0 &lt; n ⇒ ((x = y) ⇔ (n * x = n * y))

   [<a name="eq_move_all_left-val"><b>eq_move_all_left</b></a>]  Theorem

      |- ∀x y. (x = y) ⇔ (x + -y = 0)

   [<a name="eq_move_all_right-val"><b>eq_move_all_right</b></a>]  Theorem

      |- ∀x y. (x = y) ⇔ (0 = y + -x)

   [<a name="eq_move_left_left-val"><b>eq_move_left_left</b></a>]  Theorem

      |- ∀x y z. (x = y + z) ⇔ (x + -y = z)

   [<a name="eq_move_left_right-val"><b>eq_move_left_right</b></a>]  Theorem

      |- ∀x y z. (x + y = z) ⇔ (y = z + -x)

   [<a name="eq_move_right_left-val"><b>eq_move_right_left</b></a>]  Theorem

      |- ∀x y z. (x = y + z) ⇔ (x + -z = y)

   [<a name="gcd1thm-val"><b>gcd1thm</b></a>]  Theorem

      |- ∀m n p q. (p * &m + q * &n = 1) ⇒ (gcd m n = 1)

   [<a name="gcd21_thm-val"><b>gcd21_thm</b></a>]  Theorem

      |- ∀m a x b p q.
           (p * &a + q * &m = 1) ∧ m ≠ 0 ∧ a ≠ 0 ⇒
           (&m int_divides &a * x + b ⇔ ∃t. x = -p * b + t * &m)

   [<a name="gcdthm2-val"><b>gcdthm2</b></a>]  Theorem

      |- ∀m a x b d p q.
           (d = gcd a m) ∧ (&d = p * &a + q * &m) ∧ d ≠ 0 ∧ m ≠ 0 ∧ a ≠ 0 ⇒
           (&m int_divides &a * x + b ⇔
            &d int_divides b ∧ ∃t. x = -p * (b / &d) + t * (&m / &d))

   [<a name="in_additive_range-val"><b>in_additive_range</b></a>]  Theorem

      |- ∀low d x.
           low &lt; x ∧ x ≤ low + d ⇔ ∃j. (x = low + j) ∧ 0 &lt; j ∧ j ≤ d

   [<a name="in_subtractive_range-val"><b>in_subtractive_range</b></a>]  Theorem

      |- ∀high d x.
           high − d ≤ x ∧ x &lt; high ⇔ ∃j. (x = high − j) ∧ 0 &lt; j ∧ j ≤ d

   [<a name="justify_divides-val"><b>justify_divides</b></a>]  Theorem

      |- ∀n x y. 0 &lt; n ⇒ (x int_divides y ⇔ n * x int_divides n * y)

   [<a name="justify_divides2-val"><b>justify_divides2</b></a>]  Theorem

      |- ∀n c x y.
           n * x int_divides n * y + c ⇔
           n * x int_divides n * y + c ∧ n int_divides c

   [<a name="justify_divides3-val"><b>justify_divides3</b></a>]  Theorem

      |- ∀n x c. n int_divides n * x + c ⇔ n int_divides c

   [<a name="lcm_eliminate-val"><b>lcm_eliminate</b></a>]  Theorem

      |- ∀P c. (∃x. P (c * x)) ⇔ ∃x. P x ∧ c int_divides x

   [<a name="le_context_rwt1-val"><b>le_context_rwt1</b></a>]  Theorem

      |- 0 ≤ c + x ⇒ x ≤ y ⇒ (0 ≤ c + y ⇔ T)

   [<a name="le_context_rwt2-val"><b>le_context_rwt2</b></a>]  Theorem

      |- 0 ≤ c + x ⇒ y &lt; -x ⇒ (0 ≤ -c + y ⇔ F)

   [<a name="le_context_rwt3-val"><b>le_context_rwt3</b></a>]  Theorem

      |- 0 ≤ c + x ⇒ x &lt; y ⇒ ((0 = c + y) ⇔ F)

   [<a name="le_context_rwt4-val"><b>le_context_rwt4</b></a>]  Theorem

      |- 0 ≤ c + x ⇒ x &lt; -y ⇒ ((0 = -c + y) ⇔ F)

   [<a name="le_context_rwt5-val"><b>le_context_rwt5</b></a>]  Theorem

      |- 0 ≤ c + x ⇒ (0 ≤ -c + -x ⇔ (0 = c + x))

   [<a name="le_move_all_right-val"><b>le_move_all_right</b></a>]  Theorem

      |- ∀x y. x ≤ y ⇔ 0 ≤ y + -x

   [<a name="le_move_right_left-val"><b>le_move_right_left</b></a>]  Theorem

      |- ∀x y z. x ≤ y + z ⇔ x + -z ≤ y

   [<a name="less_to_leq_samel-val"><b>less_to_leq_samel</b></a>]  Theorem

      |- ∀x y. x &lt; y ⇔ x ≤ y + -1

   [<a name="less_to_leq_samer-val"><b>less_to_leq_samer</b></a>]  Theorem

      |- ∀x y. x &lt; y ⇔ x + 1 ≤ y

   [<a name="lt_justify_multiplication-val"><b>lt_justify_multiplication</b></a>]  Theorem

      |- ∀n x y. 0 &lt; n ⇒ (x &lt; y ⇔ n * x &lt; n * y)

   [<a name="lt_move_all_left-val"><b>lt_move_all_left</b></a>]  Theorem

      |- ∀x y. x &lt; y ⇔ x + -y &lt; 0

   [<a name="lt_move_all_right-val"><b>lt_move_all_right</b></a>]  Theorem

      |- ∀x y. x &lt; y ⇔ 0 &lt; y + -x

   [<a name="lt_move_left_left-val"><b>lt_move_left_left</b></a>]  Theorem

      |- ∀x y z. x &lt; y + z ⇔ x + -y &lt; z

   [<a name="lt_move_left_right-val"><b>lt_move_left_right</b></a>]  Theorem

      |- ∀x y z. x + y &lt; z ⇔ y &lt; z + -x

   [<a name="move_sub-val"><b>move_sub</b></a>]  Theorem

      |- ∀c b a. a − c + b = a + b − c

   [<a name="not_less-val"><b>not_less</b></a>]  Theorem

      |- ¬(x &lt; y) ⇔ y &lt; x + 1

   [<a name="positive_product_implication-val"><b>positive_product_implication</b></a>]  Theorem

      |- ∀c d. 0 &lt; c ∧ 0 &lt; d ⇒ 0 &lt; c * d

   [<a name="restricted_quantification_simp-val"><b>restricted_quantification_simp</b></a>]  Theorem

      |- ∀low high x.
           low &lt; x ∧ x ≤ high ⇔
           low &lt; high ∧ ((x = high) ∨ low &lt; x ∧ x ≤ high − 1)

   [<a name="subtract_to_small-val"><b>subtract_to_small</b></a>]  Theorem

      |- ∀x d. 0 &lt; d ⇒ ∃k. 0 &lt; x − k * d ∧ x − k * d ≤ d

   [<a name="top_and_lessers-val"><b>top_and_lessers</b></a>]  Theorem

      |- ∀P d x0. (∀x. P x ⇒ P (x − d)) ∧ P x0 ⇒ ∀c. 0 &lt; c ⇒ P (x0 − c * d)


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/integer/int_arithScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-8</a></em></p></body></html>
