<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure set_relationTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure set_relationTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/pred_set/src/set_relationScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature set_relationTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#acyclic_def-val">acyclic_def</a> : thm
<a name="line7"></a>    val <a href="#all_choices_def-val">all_choices_def</a> : thm
<a name="line8"></a>    val <a href="#antisym_def-val">antisym_def</a> : thm
<a name="line9"></a>    val <a href="#chain_def-val">chain_def</a> : thm
<a name="line10"></a>    val <a href="#domain_def-val">domain_def</a> : thm
<a name="line11"></a>    val <a href="#fchains_def-val">fchains_def</a> : thm
<a name="line12"></a>    val <a href="#finite_prefixes_def-val">finite_prefixes_def</a> : thm
<a name="line13"></a>    val <a href="#get_min_def-val">get_min_def</a> : thm
<a name="line14"></a>    val <a href="#irreflexive_def-val">irreflexive_def</a> : thm
<a name="line15"></a>    val <a href="#linear_order_def-val">linear_order_def</a> : thm
<a name="line16"></a>    val <a href="#maximal_elements_def-val">maximal_elements_def</a> : thm
<a name="line17"></a>    val <a href="#minimal_elements_def-val">minimal_elements_def</a> : thm
<a name="line18"></a>    val <a href="#nth_min_curried_def-val">nth_min_curried_def</a> : thm
<a name="line19"></a>    val <a href="#nth_min_tupled_primitive_def-val">nth_min_tupled_primitive_def</a> : thm
<a name="line20"></a>    val <a href="#num_order_def-val">num_order_def</a> : thm
<a name="line21"></a>    val <a href="#partial_order_def-val">partial_order_def</a> : thm
<a name="line22"></a>    val <a href="#per_def-val">per_def</a> : thm
<a name="line23"></a>    val <a href="#per_restrict_def-val">per_restrict_def</a> : thm
<a name="line24"></a>    val <a href="#range_def-val">range_def</a> : thm
<a name="line25"></a>    val <a href="#rcomp_def-val">rcomp_def</a> : thm
<a name="line26"></a>    val <a href="#reflexive_def-val">reflexive_def</a> : thm
<a name="line27"></a>    val <a href="#rrestrict_def-val">rrestrict_def</a> : thm
<a name="line28"></a>    val <a href="#strict_def-val">strict_def</a> : thm
<a name="line29"></a>    val <a href="#strict_linear_order_def-val">strict_linear_order_def</a> : thm
<a name="line30"></a>    val <a href="#tc_def-val">tc_def</a> : thm
<a name="line31"></a>    val <a href="#transitive_def-val">transitive_def</a> : thm
<a name="line32"></a>    val <a href="#univ_reln_def-val">univ_reln_def</a> : thm
<a name="line33"></a>    val <a href="#upper_bounds_def-val">upper_bounds_def</a> : thm
<a name="line34"></a>
<a name="line35"></a>  (*  Theorems  *)
<a name="line36"></a>    val <a href="#acyclic_bigunion-val">acyclic_bigunion</a> : thm
<a name="line37"></a>    val <a href="#acyclic_irreflexive-val">acyclic_irreflexive</a> : thm
<a name="line38"></a>    val <a href="#acyclic_rrestrict-val">acyclic_rrestrict</a> : thm
<a name="line39"></a>    val <a href="#acyclic_subset-val">acyclic_subset</a> : thm
<a name="line40"></a>    val <a href="#acyclic_union-val">acyclic_union</a> : thm
<a name="line41"></a>    val <a href="#all_choices_thm-val">all_choices_thm</a> : thm
<a name="line42"></a>    val <a href="#countable_per-val">countable_per</a> : thm
<a name="line43"></a>    val <a href="#empty_linear_order-val">empty_linear_order</a> : thm
<a name="line44"></a>    val <a href="#empty_strict_linear_order-val">empty_strict_linear_order</a> : thm
<a name="line45"></a>    val <a href="#extend_linear_order-val">extend_linear_order</a> : thm
<a name="line46"></a>    val <a href="#finite_acyclic_has_maximal-val">finite_acyclic_has_maximal</a> : thm
<a name="line47"></a>    val <a href="#finite_acyclic_has_maximal_path-val">finite_acyclic_has_maximal_path</a> : thm
<a name="line48"></a>    val <a href="#finite_acyclic_has_minimal-val">finite_acyclic_has_minimal</a> : thm
<a name="line49"></a>    val <a href="#finite_acyclic_has_minimal_path-val">finite_acyclic_has_minimal_path</a> : thm
<a name="line50"></a>    val <a href="#finite_linear_order_has_maximal-val">finite_linear_order_has_maximal</a> : thm
<a name="line51"></a>    val <a href="#finite_linear_order_has_minimal-val">finite_linear_order_has_minimal</a> : thm
<a name="line52"></a>    val <a href="#finite_prefix_linear_order_has_unique_minimal-val">finite_prefix_linear_order_has_unique_minimal</a> : thm
<a name="line53"></a>    val <a href="#finite_prefix_po_has_minimal_path-val">finite_prefix_po_has_minimal_path</a> : thm
<a name="line54"></a>    val <a href="#finite_prefixes_comp-val">finite_prefixes_comp</a> : thm
<a name="line55"></a>    val <a href="#finite_prefixes_inj_image-val">finite_prefixes_inj_image</a> : thm
<a name="line56"></a>    val <a href="#finite_prefixes_range-val">finite_prefixes_range</a> : thm
<a name="line57"></a>    val <a href="#finite_prefixes_subset-val">finite_prefixes_subset</a> : thm
<a name="line58"></a>    val <a href="#finite_prefixes_union-val">finite_prefixes_union</a> : thm
<a name="line59"></a>    val <a href="#finite_strict_linear_order_has_maximal-val">finite_strict_linear_order_has_maximal</a> : thm
<a name="line60"></a>    val <a href="#finite_strict_linear_order_has_minimal-val">finite_strict_linear_order_has_minimal</a> : thm
<a name="line61"></a>    val <a href="#in_domain-val">in_domain</a> : thm
<a name="line62"></a>    val <a href="#in_range-val">in_range</a> : thm
<a name="line63"></a>    val <a href="#in_rrestrict-val">in_rrestrict</a> : thm
<a name="line64"></a>    val <a href="#linear_order-val">linear_order</a> : thm
<a name="line65"></a>    val <a href="#linear_order_dom_rng-val">linear_order_dom_rng</a> : thm
<a name="line66"></a>    val <a href="#linear_order_num_order-val">linear_order_num_order</a> : thm
<a name="line67"></a>    val <a href="#linear_order_of_countable_po-val">linear_order_of_countable_po</a> : thm
<a name="line68"></a>    val <a href="#linear_order_restrict-val">linear_order_restrict</a> : thm
<a name="line69"></a>    val <a href="#linear_order_subset-val">linear_order_subset</a> : thm
<a name="line70"></a>    val <a href="#maximal_TC-val">maximal_TC</a> : thm
<a name="line71"></a>    val <a href="#maximal_linear_order-val">maximal_linear_order</a> : thm
<a name="line72"></a>    val <a href="#maximal_union-val">maximal_union</a> : thm
<a name="line73"></a>    val <a href="#minimal_TC-val">minimal_TC</a> : thm
<a name="line74"></a>    val <a href="#minimal_linear_order-val">minimal_linear_order</a> : thm
<a name="line75"></a>    val <a href="#minimal_linear_order_unique-val">minimal_linear_order_unique</a> : thm
<a name="line76"></a>    val <a href="#minimal_union-val">minimal_union</a> : thm
<a name="line77"></a>    val <a href="#nat_order_iso_thm-val">nat_order_iso_thm</a> : thm
<a name="line78"></a>    val <a href="#nth_min_def-val">nth_min_def</a> : thm
<a name="line79"></a>    val <a href="#nth_min_def_compute-val">nth_min_def_compute</a> : thm
<a name="line80"></a>    val <a href="#nth_min_ind-val">nth_min_ind</a> : thm
<a name="line81"></a>    val <a href="#num_order_finite_prefix-val">num_order_finite_prefix</a> : thm
<a name="line82"></a>    val <a href="#partial_order_dom_rng-val">partial_order_dom_rng</a> : thm
<a name="line83"></a>    val <a href="#partial_order_linear_order-val">partial_order_linear_order</a> : thm
<a name="line84"></a>    val <a href="#partial_order_subset-val">partial_order_subset</a> : thm
<a name="line85"></a>    val <a href="#per_delete-val">per_delete</a> : thm
<a name="line86"></a>    val <a href="#per_restrict_per-val">per_restrict_per</a> : thm
<a name="line87"></a>    val <a href="#rextension-val">rextension</a> : thm
<a name="line88"></a>    val <a href="#rrestrict_rrestrict-val">rrestrict_rrestrict</a> : thm
<a name="line89"></a>    val <a href="#rrestrict_tc-val">rrestrict_tc</a> : thm
<a name="line90"></a>    val <a href="#rrestrict_union-val">rrestrict_union</a> : thm
<a name="line91"></a>    val <a href="#rtc_ind_right-val">rtc_ind_right</a> : thm
<a name="line92"></a>    val <a href="#strict_linear_order-val">strict_linear_order</a> : thm
<a name="line93"></a>    val <a href="#strict_linear_order_acyclic-val">strict_linear_order_acyclic</a> : thm
<a name="line94"></a>    val <a href="#strict_linear_order_dom_rng-val">strict_linear_order_dom_rng</a> : thm
<a name="line95"></a>    val <a href="#strict_linear_order_restrict-val">strict_linear_order_restrict</a> : thm
<a name="line96"></a>    val <a href="#strict_linear_order_union_acyclic-val">strict_linear_order_union_acyclic</a> : thm
<a name="line97"></a>    val <a href="#strict_partial_order-val">strict_partial_order</a> : thm
<a name="line98"></a>    val <a href="#strict_partial_order_acyclic-val">strict_partial_order_acyclic</a> : thm
<a name="line99"></a>    val <a href="#strict_rrestrict-val">strict_rrestrict</a> : thm
<a name="line100"></a>    val <a href="#tc_cases-val">tc_cases</a> : thm
<a name="line101"></a>    val <a href="#tc_cases_left-val">tc_cases_left</a> : thm
<a name="line102"></a>    val <a href="#tc_cases_right-val">tc_cases_right</a> : thm
<a name="line103"></a>    val <a href="#tc_domain_range-val">tc_domain_range</a> : thm
<a name="line104"></a>    val <a href="#tc_empty-val">tc_empty</a> : thm
<a name="line105"></a>    val <a href="#tc_implication-val">tc_implication</a> : thm
<a name="line106"></a>    val <a href="#tc_ind-val">tc_ind</a> : thm
<a name="line107"></a>    val <a href="#tc_ind_left-val">tc_ind_left</a> : thm
<a name="line108"></a>    val <a href="#tc_ind_right-val">tc_ind_right</a> : thm
<a name="line109"></a>    val <a href="#tc_rules-val">tc_rules</a> : thm
<a name="line110"></a>    val <a href="#tc_strongind-val">tc_strongind</a> : thm
<a name="line111"></a>    val <a href="#tc_strongind_left-val">tc_strongind_left</a> : thm
<a name="line112"></a>    val <a href="#tc_strongind_right-val">tc_strongind_right</a> : thm
<a name="line113"></a>    val <a href="#tc_transitive-val">tc_transitive</a> : thm
<a name="line114"></a>    val <a href="#tc_union-val">tc_union</a> : thm
<a name="line115"></a>    val <a href="#transitive_tc-val">transitive_tc</a> : thm
<a name="line116"></a>    val <a href="#upper_bounds_lem-val">upper_bounds_lem</a> : thm
<a name="line117"></a>    val <a href="#zorns_lemma-val">zorns_lemma</a> : thm
<a name="line118"></a>
<a name="line119"></a>  val set_relation_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line120"></a>(*
   [pred_set] Parent theory of "set_relation"

   [<a name="acyclic_def-val"><b>acyclic_def</b></a>]  Definition

      |- ∀r. acyclic r ⇔ ∀x. (x,x) ∉ tc r

   [<a name="all_choices_def-val"><b>all_choices_def</b></a>]  Definition

      |- ∀xss.
           all_choices xss =
           {IMAGE choice xss | choice | ∀xs. xs ∈ xss ⇒ choice xs ∈ xs}

   [<a name="antisym_def-val"><b>antisym_def</b></a>]  Definition

      |- ∀r. antisym r ⇔ ∀x y. (x,y) ∈ r ∧ (y,x) ∈ r ⇒ (x = y)

   [<a name="chain_def-val"><b>chain_def</b></a>]  Definition

      |- ∀s r. chain s r ⇔ ∀x y. x ∈ s ∧ y ∈ s ⇒ (x,y) ∈ r ∨ (y,x) ∈ r

   [<a name="domain_def-val"><b>domain_def</b></a>]  Definition

      |- ∀r. domain r = {x | ∃y. (x,y) ∈ r}

   [<a name="fchains_def-val"><b>fchains_def</b></a>]  Definition

      |- ∀r.
           fchains r =
           {k |
            chain k r ∧ k ≠ ∅ ∧
            ∀C.
              chain C r ∧ C ⊆ k ∧ (upper_bounds C r DIFF C) ∩ k ≠ ∅ ⇒
              CHOICE (upper_bounds C r DIFF C) ∈
              minimal_elements ((upper_bounds C r DIFF C) ∩ k) r}

   [<a name="finite_prefixes_def-val"><b>finite_prefixes_def</b></a>]  Definition

      |- ∀r s. finite_prefixes r s ⇔ ∀e. e ∈ s ⇒ FINITE {e' | (e',e) ∈ r}

   [<a name="get_min_def-val"><b>get_min_def</b></a>]  Definition

      |- ∀r' s r.
           get_min r' (s,r) =
           (let mins = minimal_elements (minimal_elements s r) r'
            in
              if SING mins then SOME (CHOICE mins) else NONE)

   [<a name="irreflexive_def-val"><b>irreflexive_def</b></a>]  Definition

      |- ∀r s. irreflexive r s ⇔ ∀x. x ∈ s ⇒ (x,x) ∉ r

   [<a name="linear_order_def-val"><b>linear_order_def</b></a>]  Definition

      |- ∀r s.
           linear_order r s ⇔
           domain r ⊆ s ∧ range r ⊆ s ∧ transitive r ∧ antisym r ∧
           ∀x y. x ∈ s ∧ y ∈ s ⇒ (x,y) ∈ r ∨ (y,x) ∈ r

   [<a name="maximal_elements_def-val"><b>maximal_elements_def</b></a>]  Definition

      |- ∀xs r.
           maximal_elements xs r =
           {x | x ∈ xs ∧ ∀x'. x' ∈ xs ∧ (x,x') ∈ r ⇒ (x = x')}

   [<a name="minimal_elements_def-val"><b>minimal_elements_def</b></a>]  Definition

      |- ∀xs r.
           minimal_elements xs r =
           {x | x ∈ xs ∧ ∀x'. x' ∈ xs ∧ (x',x) ∈ r ⇒ (x = x')}

   [<a name="nth_min_curried_def-val"><b>nth_min_curried_def</b></a>]  Definition

      |- ∀x x1 x2. nth_min x x1 x2 = nth_min_tupled (x,x1,x2)

   [<a name="nth_min_tupled_primitive_def-val"><b>nth_min_tupled_primitive_def</b></a>]  Definition

      |- nth_min_tupled =
         WFREC
           (@R.
              WF R ∧
              ∀n r s r' min.
                (min = get_min r' (s,r)) ∧ min ≠ NONE ⇒
                R (r',(s DELETE THE min,r),n) (r',(s,r),SUC n))
           (λnth_min_tupled a.
              case a of
                (r',(s,r),0) =&gt; I (get_min r' (s,r))
              | (r',(s,r),SUC n) =&gt;
                  I
                    (let min = get_min r' (s,r)
                     in
                       if min = NONE then
                         NONE
                       else
                         nth_min_tupled (r',(s DELETE THE min,r),n)))

   [<a name="num_order_def-val"><b>num_order_def</b></a>]  Definition

      |- ∀f s. num_order f s = {(x,y) | x ∈ s ∧ y ∈ s ∧ f x ≤ f y}

   [<a name="partial_order_def-val"><b>partial_order_def</b></a>]  Definition

      |- ∀r s.
           partial_order r s ⇔
           domain r ⊆ s ∧ range r ⊆ s ∧ transitive r ∧ reflexive r s ∧
           antisym r

   [<a name="per_def-val"><b>per_def</b></a>]  Definition

      |- ∀xs xss.
           per xs xss ⇔
           BIGUNION xss ⊆ xs ∧ ∅ ∉ xss ∧
           ∀xs1 xs2. xs1 ∈ xss ∧ xs2 ∈ xss ∧ xs1 ≠ xs2 ⇒ DISJOINT xs1 xs2

   [<a name="per_restrict_def-val"><b>per_restrict_def</b></a>]  Definition

      |- ∀xss xs. per_restrict xss xs = {xs' ∩ xs | xs' ∈ xss} DELETE ∅

   [<a name="range_def-val"><b>range_def</b></a>]  Definition

      |- ∀r. range r = {y | ∃x. (x,y) ∈ r}

   [<a name="rcomp_def-val"><b>rcomp_def</b></a>]  Definition

      |- ∀r1 r2. r1 OO r2 = {(x,y) | ∃z. (x,z) ∈ r1 ∧ (z,y) ∈ r2}

   [<a name="reflexive_def-val"><b>reflexive_def</b></a>]  Definition

      |- ∀r s. reflexive r s ⇔ ∀x. x ∈ s ⇒ (x,x) ∈ r

   [<a name="rrestrict_def-val"><b>rrestrict_def</b></a>]  Definition

      |- ∀r s. rrestrict r s = {(x,y) | (x,y) ∈ r ∧ x ∈ s ∧ y ∈ s}

   [<a name="strict_def-val"><b>strict_def</b></a>]  Definition

      |- ∀r. strict r = {(x,y) | (x,y) ∈ r ∧ x ≠ y}

   [<a name="strict_linear_order_def-val"><b>strict_linear_order_def</b></a>]  Definition

      |- ∀r s.
           strict_linear_order r s ⇔
           domain r ⊆ s ∧ range r ⊆ s ∧ transitive r ∧ (∀x. (x,x) ∉ r) ∧
           ∀x y. x ∈ s ∧ y ∈ s ∧ x ≠ y ⇒ (x,y) ∈ r ∨ (y,x) ∈ r

   [<a name="tc_def-val"><b>tc_def</b></a>]  Definition

      |- tc =
         (λr a0.
            ∀tc'.
              (∀a0.
                 (∃x y. (a0 = (x,y)) ∧ r (x,y)) ∨
                 (∃x y. (a0 = (x,y)) ∧ ∃z. tc' (x,z) ∧ tc' (z,y)) ⇒
                 tc' a0) ⇒
              tc' a0)

   [<a name="transitive_def-val"><b>transitive_def</b></a>]  Definition

      |- ∀r. transitive r ⇔ ∀x y z. (x,y) ∈ r ∧ (y,z) ∈ r ⇒ (x,z) ∈ r

   [<a name="univ_reln_def-val"><b>univ_reln_def</b></a>]  Definition

      |- ∀xs. univ_reln xs = {(x1,x2) | x1 ∈ xs ∧ x2 ∈ xs}

   [<a name="upper_bounds_def-val"><b>upper_bounds_def</b></a>]  Definition

      |- ∀s r. upper_bounds s r = {x | x ∈ range r ∧ ∀y. y ∈ s ⇒ (y,x) ∈ r}

   [<a name="acyclic_bigunion-val"><b>acyclic_bigunion</b></a>]  Theorem

      |- ∀rs.
           (∀r r'.
              r ∈ rs ∧ r' ∈ rs ∧ r ≠ r' ⇒
              DISJOINT (domain r ∪ range r) (domain r' ∪ range r')) ∧
           (∀r. r ∈ rs ⇒ acyclic r) ⇒
           acyclic (BIGUNION rs)

   [<a name="acyclic_irreflexive-val"><b>acyclic_irreflexive</b></a>]  Theorem

      |- ∀r x. acyclic r ⇒ (x,x) ∉ r

   [<a name="acyclic_rrestrict-val"><b>acyclic_rrestrict</b></a>]  Theorem

      |- ∀r s. acyclic r ⇒ acyclic (rrestrict r s)

   [<a name="acyclic_subset-val"><b>acyclic_subset</b></a>]  Theorem

      |- ∀r1 r2. acyclic r1 ∧ r2 ⊆ r1 ⇒ acyclic r2

   [<a name="acyclic_union-val"><b>acyclic_union</b></a>]  Theorem

      |- ∀r r'.
           DISJOINT (domain r ∪ range r) (domain r' ∪ range r') ∧
           acyclic r ∧ acyclic r' ⇒
           acyclic (r ∪ r')

   [<a name="all_choices_thm-val"><b>all_choices_thm</b></a>]  Theorem

      |- ∀x s y. x ∈ all_choices s ∧ y ∈ x ⇒ ∃z. z ∈ s ∧ y ∈ z

   [<a name="countable_per-val"><b>countable_per</b></a>]  Theorem

      |- ∀xs xss. countable xs ∧ per xs xss ⇒ countable xss

   [<a name="empty_linear_order-val"><b>empty_linear_order</b></a>]  Theorem

      |- ∀r. linear_order r ∅ ⇔ (r = ∅)

   [<a name="empty_strict_linear_order-val"><b>empty_strict_linear_order</b></a>]  Theorem

      |- ∀r. strict_linear_order r ∅ ⇔ (r = ∅)

   [<a name="extend_linear_order-val"><b>extend_linear_order</b></a>]  Theorem

      |- ∀r s x.
           x ∉ s ∧ linear_order r s ⇒
           linear_order (r ∪ {(y,x) | y | y ∈ s ∪ {x}}) (s ∪ {x})

   [<a name="finite_acyclic_has_maximal-val"><b>finite_acyclic_has_maximal</b></a>]  Theorem

      |- ∀s.
           FINITE s ⇒ s ≠ ∅ ⇒ ∀r. acyclic r ⇒ ∃x. x ∈ maximal_elements s r

   [<a name="finite_acyclic_has_maximal_path-val"><b>finite_acyclic_has_maximal_path</b></a>]  Theorem

      |- ∀s r x.
           FINITE s ∧ acyclic r ∧ x ∈ s ∧ x ∉ maximal_elements s r ⇒
           ∃y. y ∈ maximal_elements s r ∧ (x,y) ∈ tc r

   [<a name="finite_acyclic_has_minimal-val"><b>finite_acyclic_has_minimal</b></a>]  Theorem

      |- ∀s.
           FINITE s ⇒ s ≠ ∅ ⇒ ∀r. acyclic r ⇒ ∃x. x ∈ minimal_elements s r

   [<a name="finite_acyclic_has_minimal_path-val"><b>finite_acyclic_has_minimal_path</b></a>]  Theorem

      |- ∀s r x.
           FINITE s ∧ acyclic r ∧ x ∈ s ∧ x ∉ minimal_elements s r ⇒
           ∃y. y ∈ minimal_elements s r ∧ (y,x) ∈ tc r

   [<a name="finite_linear_order_has_maximal-val"><b>finite_linear_order_has_maximal</b></a>]  Theorem

      |- ∀s r.
           FINITE s ∧ linear_order r s ∧ s ≠ ∅ ⇒
           ∃x. x ∈ maximal_elements s r

   [<a name="finite_linear_order_has_minimal-val"><b>finite_linear_order_has_minimal</b></a>]  Theorem

      |- ∀s r.
           FINITE s ∧ linear_order r s ∧ s ≠ ∅ ⇒
           ∃x. x ∈ minimal_elements s r

   [<a name="finite_prefix_linear_order_has_unique_minimal-val"><b>finite_prefix_linear_order_has_unique_minimal</b></a>]  Theorem

      |- ∀r s s'.
           linear_order r s ∧ finite_prefixes r s ∧ x ∈ s' ∧ s' ⊆ s ⇒
           SING (minimal_elements s' r)

   [<a name="finite_prefix_po_has_minimal_path-val"><b>finite_prefix_po_has_minimal_path</b></a>]  Theorem

      |- ∀r s x s'.
           partial_order r s ∧ finite_prefixes r s ∧
           x ∉ minimal_elements s' r ∧ x ∈ s' ∧ s' ⊆ s ⇒
           ∃x'. x' ∈ minimal_elements s' r ∧ (x',x) ∈ r

   [<a name="finite_prefixes_comp-val"><b>finite_prefixes_comp</b></a>]  Theorem

      |- ∀r1 r2 s1 s2.
           finite_prefixes r1 s1 ∧ finite_prefixes r2 s2 ∧
           {x | ∃y. y ∈ s2 ∧ (x,y) ∈ r2} ⊆ s1 ⇒
           finite_prefixes (r1 OO r2) s2

   [<a name="finite_prefixes_inj_image-val"><b>finite_prefixes_inj_image</b></a>]  Theorem

      |- ∀f r s.
           (∀x y. (f x = f y) ⇒ (x = y)) ∧ finite_prefixes r s ⇒
           finite_prefixes {(f x,f y) | (x,y) ∈ r} (IMAGE f s)

   [<a name="finite_prefixes_range-val"><b>finite_prefixes_range</b></a>]  Theorem

      |- ∀r s t.
           finite_prefixes r s ∧ DISJOINT t (range r) ⇒
           finite_prefixes r (s ∪ t)

   [<a name="finite_prefixes_subset-val"><b>finite_prefixes_subset</b></a>]  Theorem

      |- ∀r s s'.
           finite_prefixes r s ∧ s' ⊆ s ⇒
           finite_prefixes r s' ∧ finite_prefixes (rrestrict r s') s'

   [<a name="finite_prefixes_union-val"><b>finite_prefixes_union</b></a>]  Theorem

      |- ∀r1 r2 s1 s2.
           finite_prefixes r1 s1 ∧ finite_prefixes r2 s2 ⇒
           finite_prefixes (r1 ∪ r2) (s1 ∩ s2)

   [<a name="finite_strict_linear_order_has_maximal-val"><b>finite_strict_linear_order_has_maximal</b></a>]  Theorem

      |- ∀s r.
           FINITE s ∧ strict_linear_order r s ∧ s ≠ ∅ ⇒
           ∃x. x ∈ maximal_elements s r

   [<a name="finite_strict_linear_order_has_minimal-val"><b>finite_strict_linear_order_has_minimal</b></a>]  Theorem

      |- ∀s r.
           FINITE s ∧ strict_linear_order r s ∧ s ≠ ∅ ⇒
           ∃x. x ∈ minimal_elements s r

   [<a name="in_domain-val"><b>in_domain</b></a>]  Theorem

      |- ∀x r. x ∈ domain r ⇔ ∃y. (x,y) ∈ r

   [<a name="in_range-val"><b>in_range</b></a>]  Theorem

      |- ∀y r. y ∈ range r ⇔ ∃x. (x,y) ∈ r

   [<a name="in_rrestrict-val"><b>in_rrestrict</b></a>]  Theorem

      |- ∀x y r s. (x,y) ∈ rrestrict r s ⇔ (x,y) ∈ r ∧ x ∈ s ∧ y ∈ s

   [<a name="linear_order-val"><b>linear_order</b></a>]  Theorem

      |- ∀r s.
           strict_linear_order r s ⇒ linear_order (r ∪ {(x,x) | x ∈ s}) s

   [<a name="linear_order_dom_rng-val"><b>linear_order_dom_rng</b></a>]  Theorem

      |- ∀r s x y. (x,y) ∈ r ∧ linear_order r s ⇒ x ∈ s ∧ y ∈ s

   [<a name="linear_order_num_order-val"><b>linear_order_num_order</b></a>]  Theorem

      |- ∀f s t. INJ f s t ⇒ linear_order (num_order f s) s

   [<a name="linear_order_of_countable_po-val"><b>linear_order_of_countable_po</b></a>]  Theorem

      |- ∀r s.
           countable s ∧ partial_order r s ∧ finite_prefixes r s ⇒
           ∃r'. linear_order r' s ∧ finite_prefixes r' s ∧ r ⊆ r'

   [<a name="linear_order_restrict-val"><b>linear_order_restrict</b></a>]  Theorem

      |- ∀s r s'. linear_order r s ⇒ linear_order (rrestrict r s') (s ∩ s')

   [<a name="linear_order_subset-val"><b>linear_order_subset</b></a>]  Theorem

      |- ∀r s s'.
           linear_order r s ∧ s' ⊆ s ⇒ linear_order (rrestrict r s') s'

   [<a name="maximal_TC-val"><b>maximal_TC</b></a>]  Theorem

      |- ∀s r.
           domain r ⊆ s ∧ range r ⊆ s ⇒
           (maximal_elements s (tc r) = maximal_elements s r)

   [<a name="maximal_linear_order-val"><b>maximal_linear_order</b></a>]  Theorem

      |- ∀s r x y.
           y ∈ s ∧ linear_order r s ∧ x ∈ maximal_elements s r ⇒ (y,x) ∈ r

   [<a name="maximal_union-val"><b>maximal_union</b></a>]  Theorem

      |- ∀e s r1 r2.
           e ∈ maximal_elements s (r1 ∪ r2) ⇒
           e ∈ maximal_elements s r1 ∧ e ∈ maximal_elements s r2

   [<a name="minimal_TC-val"><b>minimal_TC</b></a>]  Theorem

      |- ∀s r.
           domain r ⊆ s ∧ range r ⊆ s ⇒
           (minimal_elements s (tc r) = minimal_elements s r)

   [<a name="minimal_linear_order-val"><b>minimal_linear_order</b></a>]  Theorem

      |- ∀s r x y.
           y ∈ s ∧ linear_order r s ∧ x ∈ minimal_elements s r ⇒ (x,y) ∈ r

   [<a name="minimal_linear_order_unique-val"><b>minimal_linear_order_unique</b></a>]  Theorem

      |- ∀r s s' x y.
           linear_order r s ∧ x ∈ minimal_elements s' r ∧
           y ∈ minimal_elements s' r ∧ s' ⊆ s ⇒
           (x = y)

   [<a name="minimal_union-val"><b>minimal_union</b></a>]  Theorem

      |- ∀e s r1 r2.
           e ∈ minimal_elements s (r1 ∪ r2) ⇒
           e ∈ minimal_elements s r1 ∧ e ∈ minimal_elements s r2

   [<a name="nat_order_iso_thm-val"><b>nat_order_iso_thm</b></a>]  Theorem

      |- ∀f s.
           (∀n m. (f m = f n) ∧ f m ≠ NONE ⇒ (m = n)) ∧
           (∀x. x ∈ s ⇒ ∃m. f m = SOME x) ∧
           (∀m x. (f m = SOME x) ⇒ x ∈ s) ⇒
           linear_order
             {(x,y) | ∃m n. m ≤ n ∧ (f m = SOME x) ∧ (f n = SOME y)} s ∧
           finite_prefixes
             {(x,y) | ∃m n. m ≤ n ∧ (f m = SOME x) ∧ (f n = SOME y)} s

   [<a name="nth_min_def-val"><b>nth_min_def</b></a>]  Theorem

      |- (∀s r' r. nth_min r' (s,r) 0 = get_min r' (s,r)) ∧
         ∀s r' r n.
           nth_min r' (s,r) (SUC n) =
           (let min = get_min r' (s,r)
            in
              if min = NONE then
                NONE
              else
                nth_min r' (s DELETE THE min,r) n)

   [<a name="nth_min_def_compute-val"><b>nth_min_def_compute</b></a>]  Theorem

      |- (∀s r' r. nth_min r' (s,r) 0 = get_min r' (s,r)) ∧
         (∀s r' r n.
            nth_min r' (s,r) (NUMERAL (BIT1 n)) =
            (let min = get_min r' (s,r)
             in
               if min = NONE then
                 NONE
               else
                 nth_min r' (s DELETE THE min,r) (NUMERAL (BIT1 n) − 1))) ∧
         ∀s r' r n.
           nth_min r' (s,r) (NUMERAL (BIT2 n)) =
           (let min = get_min r' (s,r)
            in
              if min = NONE then
                NONE
              else
                nth_min r' (s DELETE THE min,r) (NUMERAL (BIT1 n)))

   [<a name="nth_min_ind-val"><b>nth_min_ind</b></a>]  Theorem

      |- ∀P.
           (∀r' s r. P r' (s,r) 0) ∧
           (∀r' s r n.
              (∀min.
                 (min = get_min r' (s,r)) ∧ min ≠ NONE ⇒
                 P r' (s DELETE THE min,r) n) ⇒
              P r' (s,r) (SUC n)) ⇒
           ∀v v1 v2 v3. P v (v1,v2) v3

   [<a name="num_order_finite_prefix-val"><b>num_order_finite_prefix</b></a>]  Theorem

      |- ∀f s t. INJ f s t ⇒ finite_prefixes (num_order f s) s

   [<a name="partial_order_dom_rng-val"><b>partial_order_dom_rng</b></a>]  Theorem

      |- ∀r s x y. (x,y) ∈ r ∧ partial_order r s ⇒ x ∈ s ∧ y ∈ s

   [<a name="partial_order_linear_order-val"><b>partial_order_linear_order</b></a>]  Theorem

      |- ∀r s. linear_order r s ⇒ partial_order r s

   [<a name="partial_order_subset-val"><b>partial_order_subset</b></a>]  Theorem

      |- ∀r s s'.
           partial_order r s ∧ s' ⊆ s ⇒ partial_order (rrestrict r s') s'

   [<a name="per_delete-val"><b>per_delete</b></a>]  Theorem

      |- ∀xs xss e.
           per xs xss ⇒
           per (xs DELETE e)
             {es | es ∈ IMAGE (λes. es DELETE e) xss ∧ es ≠ ∅}

   [<a name="per_restrict_per-val"><b>per_restrict_per</b></a>]  Theorem

      |- ∀r s s'. per s r ⇒ per s' (per_restrict r s')

   [<a name="rextension-val"><b>rextension</b></a>]  Theorem

      |- ∀s t. (s = t) ⇔ ∀x y. (x,y) ∈ s ⇔ (x,y) ∈ t

   [<a name="rrestrict_rrestrict-val"><b>rrestrict_rrestrict</b></a>]  Theorem

      |- ∀r x y. rrestrict (rrestrict r x) y = rrestrict r (x ∩ y)

   [<a name="rrestrict_tc-val"><b>rrestrict_tc</b></a>]  Theorem

      |- ∀e e'. (e,e') ∈ tc (rrestrict r x) ⇒ (e,e') ∈ tc r

   [<a name="rrestrict_union-val"><b>rrestrict_union</b></a>]  Theorem

      |- ∀r1 r2 s. rrestrict (r1 ∪ r2) s = rrestrict r1 s ∪ rrestrict r2 s

   [<a name="rtc_ind_right-val"><b>rtc_ind_right</b></a>]  Theorem

      |- ∀r tc'.
           (∀x. x ∈ domain r ∨ x ∈ range r ⇒ tc' x x) ∧
           (∀x y. (∃z. tc' x z ∧ (z,y) ∈ r) ⇒ tc' x y) ⇒
           ∀x y. (x,y) ∈ tc r ⇒ tc' x y

   [<a name="strict_linear_order-val"><b>strict_linear_order</b></a>]  Theorem

      |- ∀r s. linear_order r s ⇒ strict_linear_order (strict r) s

   [<a name="strict_linear_order_acyclic-val"><b>strict_linear_order_acyclic</b></a>]  Theorem

      |- ∀r s. strict_linear_order r s ⇒ acyclic r

   [<a name="strict_linear_order_dom_rng-val"><b>strict_linear_order_dom_rng</b></a>]  Theorem

      |- ∀r s x y. (x,y) ∈ r ∧ strict_linear_order r s ⇒ x ∈ s ∧ y ∈ s

   [<a name="strict_linear_order_restrict-val"><b>strict_linear_order_restrict</b></a>]  Theorem

      |- ∀s r s'.
           strict_linear_order r s ⇒
           strict_linear_order (rrestrict r s') (s ∩ s')

   [<a name="strict_linear_order_union_acyclic-val"><b>strict_linear_order_union_acyclic</b></a>]  Theorem

      |- ∀r1 r2 s.
           strict_linear_order r1 s ∧ domain r2 ∪ range r2 ⊆ s ⇒
           (acyclic (r1 ∪ r2) ⇔ r2 ⊆ r1)

   [<a name="strict_partial_order-val"><b>strict_partial_order</b></a>]  Theorem

      |- ∀r s.
           partial_order r s ⇒
           domain (strict r) ⊆ s ∧ range (strict r) ⊆ s ∧
           transitive (strict r) ∧ antisym (strict r)

   [<a name="strict_partial_order_acyclic-val"><b>strict_partial_order_acyclic</b></a>]  Theorem

      |- ∀r s. partial_order r s ⇒ acyclic (strict r)

   [<a name="strict_rrestrict-val"><b>strict_rrestrict</b></a>]  Theorem

      |- ∀r s. strict (rrestrict r s) = rrestrict (strict r) s

   [<a name="tc_cases-val"><b>tc_cases</b></a>]  Theorem

      |- ∀r x y. (x,y) ∈ tc r ⇔ (x,y) ∈ r ∨ ∃z. (x,z) ∈ tc r ∧ (z,y) ∈ tc r

   [<a name="tc_cases_left-val"><b>tc_cases_left</b></a>]  Theorem

      |- ∀r x y. (x,y) ∈ tc r ⇔ (x,y) ∈ r ∨ ∃z. (x,z) ∈ r ∧ (z,y) ∈ tc r

   [<a name="tc_cases_right-val"><b>tc_cases_right</b></a>]  Theorem

      |- ∀r x y. (x,y) ∈ tc r ⇔ (x,y) ∈ r ∨ ∃z. (x,z) ∈ tc r ∧ (z,y) ∈ r

   [<a name="tc_domain_range-val"><b>tc_domain_range</b></a>]  Theorem

      |- ∀x y. (x,y) ∈ tc r ⇒ x ∈ domain r ∧ y ∈ range r

   [<a name="tc_empty-val"><b>tc_empty</b></a>]  Theorem

      |- ∀x y. (x,y) ∉ tc ∅

   [<a name="tc_implication-val"><b>tc_implication</b></a>]  Theorem

      |- ∀r1 r2.
           (∀x y. (x,y) ∈ r1 ⇒ (x,y) ∈ r2) ⇒
           ∀x y. (x,y) ∈ tc r1 ⇒ (x,y) ∈ tc r2

   [<a name="tc_ind-val"><b>tc_ind</b></a>]  Theorem

      |- ∀r tc'.
           (∀x y. (x,y) ∈ r ⇒ tc' x y) ∧
           (∀x y. (∃z. tc' x z ∧ tc' z y) ⇒ tc' x y) ⇒
           ∀x y. (x,y) ∈ tc r ⇒ tc' x y

   [<a name="tc_ind_left-val"><b>tc_ind_left</b></a>]  Theorem

      |- ∀r tc'.
           (∀x y. (x,y) ∈ r ⇒ tc' x y) ∧
           (∀x y. (∃z. (x,z) ∈ r ∧ tc' z y) ⇒ tc' x y) ⇒
           ∀x y. (x,y) ∈ tc r ⇒ tc' x y

   [<a name="tc_ind_right-val"><b>tc_ind_right</b></a>]  Theorem

      |- ∀r tc'.
           (∀x y. (x,y) ∈ r ⇒ tc' x y) ∧
           (∀x y. (∃z. tc' x z ∧ (z,y) ∈ r) ⇒ tc' x y) ⇒
           ∀x y. (x,y) ∈ tc r ⇒ tc' x y

   [<a name="tc_rules-val"><b>tc_rules</b></a>]  Theorem

      |- ∀r.
           (∀x y. (x,y) ∈ r ⇒ (x,y) ∈ tc r) ∧
           ∀x y. (∃z. (x,z) ∈ tc r ∧ (z,y) ∈ tc r) ⇒ (x,y) ∈ tc r

   [<a name="tc_strongind-val"><b>tc_strongind</b></a>]  Theorem

      |- ∀r tc'.
           (∀x y. (x,y) ∈ r ⇒ tc' x y) ∧
           (∀x y.
              (∃z. (x,z) ∈ tc r ∧ tc' x z ∧ (z,y) ∈ tc r ∧ tc' z y) ⇒
              tc' x y) ⇒
           ∀x y. (x,y) ∈ tc r ⇒ tc' x y

   [<a name="tc_strongind_left-val"><b>tc_strongind_left</b></a>]  Theorem

      |- ∀r tc'.
           (∀x y. (x,y) ∈ r ⇒ tc' x y) ∧
           (∀x y. (∃z. (x,z) ∈ r ∧ (z,y) ∈ tc r ∧ tc' z y) ⇒ tc' x y) ⇒
           ∀x y. (x,y) ∈ tc r ⇒ tc' x y

   [<a name="tc_strongind_right-val"><b>tc_strongind_right</b></a>]  Theorem

      |- ∀r tc'.
           (∀x y. (x,y) ∈ r ⇒ tc' x y) ∧
           (∀x y. (∃z. (x,z) ∈ tc r ∧ tc' x z ∧ (z,y) ∈ r) ⇒ tc' x y) ⇒
           ∀x y. (x,y) ∈ tc r ⇒ tc' x y

   [<a name="tc_transitive-val"><b>tc_transitive</b></a>]  Theorem

      |- ∀r. transitive (tc r)

   [<a name="tc_union-val"><b>tc_union</b></a>]  Theorem

      |- ∀x y. (x,y) ∈ tc r1 ⇒ ∀r2. (x,y) ∈ tc (r1 ∪ r2)

   [<a name="transitive_tc-val"><b>transitive_tc</b></a>]  Theorem

      |- ∀r. transitive r ⇒ (tc r = r)

   [<a name="upper_bounds_lem-val"><b>upper_bounds_lem</b></a>]  Theorem

      |- ∀r s x1 x2.
           transitive r ∧ x1 ∈ upper_bounds s r ∧ (x1,x2) ∈ r ⇒
           x2 ∈ upper_bounds s r

   [<a name="zorns_lemma-val"><b>zorns_lemma</b></a>]  Theorem

      |- ∀r s.
           s ≠ ∅ ∧ partial_order r s ∧
           (∀t. chain t r ⇒ upper_bounds t r ≠ ∅) ⇒
           ∃x. x ∈ maximal_elements s r


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/pred_set/src/set_relationScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-8</a></em></p></body></html>
