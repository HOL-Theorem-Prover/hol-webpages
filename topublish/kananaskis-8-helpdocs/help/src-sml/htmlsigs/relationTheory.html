<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure relationTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure relationTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/relation/relationScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature relationTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#CR_def-val">CR_def</a> : thm
<a name="line7"></a>    val <a href="#EMPTY_REL_DEF-val">EMPTY_REL_DEF</a> : thm
<a name="line8"></a>    val <a href="#EQC_DEF-val">EQC_DEF</a> : thm
<a name="line9"></a>    val <a href="#IDEM_DEF-val">IDEM_DEF</a> : thm
<a name="line10"></a>    val <a href="#INDUCTIVE_INVARIANT_DEF-val">INDUCTIVE_INVARIANT_DEF</a> : thm
<a name="line11"></a>    val <a href="#INDUCTIVE_INVARIANT_ON_DEF-val">INDUCTIVE_INVARIANT_ON_DEF</a> : thm
<a name="line12"></a>    val <a href="#INVOL_DEF-val">INVOL_DEF</a> : thm
<a name="line13"></a>    val <a href="#LinearOrder-val">LinearOrder</a> : thm
<a name="line14"></a>    val <a href="#O_DEF-val">O_DEF</a> : thm
<a name="line15"></a>    val <a href="#Order-val">Order</a> : thm
<a name="line16"></a>    val <a href="#PreOrder-val">PreOrder</a> : thm
<a name="line17"></a>    val <a href="#RCOMPL-val">RCOMPL</a> : thm
<a name="line18"></a>    val <a href="#RC_DEF-val">RC_DEF</a> : thm
<a name="line19"></a>    val <a href="#RDOM_DEF-val">RDOM_DEF</a> : thm
<a name="line20"></a>    val <a href="#RESTRICT_DEF-val">RESTRICT_DEF</a> : thm
<a name="line21"></a>    val <a href="#RINTER-val">RINTER</a> : thm
<a name="line22"></a>    val <a href="#RRANGE-val">RRANGE</a> : thm
<a name="line23"></a>    val <a href="#RSUBSET-val">RSUBSET</a> : thm
<a name="line24"></a>    val <a href="#RTC_DEF-val">RTC_DEF</a> : thm
<a name="line25"></a>    val <a href="#RUNION-val">RUNION</a> : thm
<a name="line26"></a>    val <a href="#RUNIV-val">RUNIV</a> : thm
<a name="line27"></a>    val <a href="#SC_DEF-val">SC_DEF</a> : thm
<a name="line28"></a>    val <a href="#SN_def-val">SN_def</a> : thm
<a name="line29"></a>    val <a href="#STRORD-val">STRORD</a> : thm
<a name="line30"></a>    val <a href="#StrongLinearOrder-val">StrongLinearOrder</a> : thm
<a name="line31"></a>    val <a href="#StrongOrder-val">StrongOrder</a> : thm
<a name="line32"></a>    val <a href="#TC_DEF-val">TC_DEF</a> : thm
<a name="line33"></a>    val <a href="#WCR_def-val">WCR_def</a> : thm
<a name="line34"></a>    val <a href="#WFP_DEF-val">WFP_DEF</a> : thm
<a name="line35"></a>    val <a href="#WFREC_DEF-val">WFREC_DEF</a> : thm
<a name="line36"></a>    val <a href="#WF_DEF-val">WF_DEF</a> : thm
<a name="line37"></a>    val <a href="#WeakLinearOrder-val">WeakLinearOrder</a> : thm
<a name="line38"></a>    val <a href="#WeakOrder-val">WeakOrder</a> : thm
<a name="line39"></a>    val <a href="#antisymmetric_def-val">antisymmetric_def</a> : thm
<a name="line40"></a>    val <a href="#approx_def-val">approx_def</a> : thm
<a name="line41"></a>    val <a href="#diag_def-val">diag_def</a> : thm
<a name="line42"></a>    val <a href="#diamond_def-val">diamond_def</a> : thm
<a name="line43"></a>    val <a href="#equivalence_def-val">equivalence_def</a> : thm
<a name="line44"></a>    val <a href="#inv_DEF-val">inv_DEF</a> : thm
<a name="line45"></a>    val <a href="#inv_image_def-val">inv_image_def</a> : thm
<a name="line46"></a>    val <a href="#irreflexive_def-val">irreflexive_def</a> : thm
<a name="line47"></a>    val <a href="#nf_def-val">nf_def</a> : thm
<a name="line48"></a>    val <a href="#rcdiamond_def-val">rcdiamond_def</a> : thm
<a name="line49"></a>    val <a href="#reflexive_def-val">reflexive_def</a> : thm
<a name="line50"></a>    val <a href="#symmetric_def-val">symmetric_def</a> : thm
<a name="line51"></a>    val <a href="#the_fun_def-val">the_fun_def</a> : thm
<a name="line52"></a>    val <a href="#total_def-val">total_def</a> : thm
<a name="line53"></a>    val <a href="#transitive_def-val">transitive_def</a> : thm
<a name="line54"></a>    val <a href="#trichotomous-val">trichotomous</a> : thm
<a name="line55"></a>
<a name="line56"></a>  (*  Theorems  *)
<a name="line57"></a>    val <a href="#ALT_equivalence-val">ALT_equivalence</a> : thm
<a name="line58"></a>    val <a href="#EQC_EQUIVALENCE-val">EQC_EQUIVALENCE</a> : thm
<a name="line59"></a>    val <a href="#EQC_IDEM-val">EQC_IDEM</a> : thm
<a name="line60"></a>    val <a href="#EQC_INDUCTION-val">EQC_INDUCTION</a> : thm
<a name="line61"></a>    val <a href="#EQC_MONOTONE-val">EQC_MONOTONE</a> : thm
<a name="line62"></a>    val <a href="#EQC_MOVES_IN-val">EQC_MOVES_IN</a> : thm
<a name="line63"></a>    val <a href="#EQC_R-val">EQC_R</a> : thm
<a name="line64"></a>    val <a href="#EQC_REFL-val">EQC_REFL</a> : thm
<a name="line65"></a>    val <a href="#EQC_SYM-val">EQC_SYM</a> : thm
<a name="line66"></a>    val <a href="#EQC_TRANS-val">EQC_TRANS</a> : thm
<a name="line67"></a>    val <a href="#EXTEND_RTC_TC-val">EXTEND_RTC_TC</a> : thm
<a name="line68"></a>    val <a href="#EXTEND_RTC_TC_EQN-val">EXTEND_RTC_TC_EQN</a> : thm
<a name="line69"></a>    val <a href="#EqIsBothRSUBSET-val">EqIsBothRSUBSET</a> : thm
<a name="line70"></a>    val <a href="#IDEM-val">IDEM</a> : thm
<a name="line71"></a>    val <a href="#IDEM_RC-val">IDEM_RC</a> : thm
<a name="line72"></a>    val <a href="#IDEM_RTC-val">IDEM_RTC</a> : thm
<a name="line73"></a>    val <a href="#IDEM_SC-val">IDEM_SC</a> : thm
<a name="line74"></a>    val <a href="#IDEM_STRORD-val">IDEM_STRORD</a> : thm
<a name="line75"></a>    val <a href="#IDEM_TC-val">IDEM_TC</a> : thm
<a name="line76"></a>    val <a href="#INDUCTION_WF_THM-val">INDUCTION_WF_THM</a> : thm
<a name="line77"></a>    val <a href="#INDUCTIVE_INVARIANT_ON_WFREC-val">INDUCTIVE_INVARIANT_ON_WFREC</a> : thm
<a name="line78"></a>    val <a href="#INDUCTIVE_INVARIANT_WFREC-val">INDUCTIVE_INVARIANT_WFREC</a> : thm
<a name="line79"></a>    val <a href="#INVOL-val">INVOL</a> : thm
<a name="line80"></a>    val <a href="#INVOL_ONE_ENO-val">INVOL_ONE_ENO</a> : thm
<a name="line81"></a>    val <a href="#INVOL_ONE_ONE-val">INVOL_ONE_ONE</a> : thm
<a name="line82"></a>    val <a href="#IN_RDOM-val">IN_RDOM</a> : thm
<a name="line83"></a>    val <a href="#IN_RRANGE-val">IN_RRANGE</a> : thm
<a name="line84"></a>    val <a href="#Id_O-val">Id_O</a> : thm
<a name="line85"></a>    val <a href="#NOT_INVOL-val">NOT_INVOL</a> : thm
<a name="line86"></a>    val <a href="#Newmans_lemma-val">Newmans_lemma</a> : thm
<a name="line87"></a>    val <a href="#O_ASSOC-val">O_ASSOC</a> : thm
<a name="line88"></a>    val <a href="#O_Id-val">O_Id</a> : thm
<a name="line89"></a>    val <a href="#O_MONO-val">O_MONO</a> : thm
<a name="line90"></a>    val <a href="#RC_IDEM-val">RC_IDEM</a> : thm
<a name="line91"></a>    val <a href="#RC_MONOTONE-val">RC_MONOTONE</a> : thm
<a name="line92"></a>    val <a href="#RC_MOVES_OUT-val">RC_MOVES_OUT</a> : thm
<a name="line93"></a>    val <a href="#RC_OR_Id-val">RC_OR_Id</a> : thm
<a name="line94"></a>    val <a href="#RC_REFLEXIVE-val">RC_REFLEXIVE</a> : thm
<a name="line95"></a>    val <a href="#RC_RTC-val">RC_RTC</a> : thm
<a name="line96"></a>    val <a href="#RC_STRORD-val">RC_STRORD</a> : thm
<a name="line97"></a>    val <a href="#RC_SUBSET-val">RC_SUBSET</a> : thm
<a name="line98"></a>    val <a href="#RC_Weak-val">RC_Weak</a> : thm
<a name="line99"></a>    val <a href="#RC_lifts_equalities-val">RC_lifts_equalities</a> : thm
<a name="line100"></a>    val <a href="#RC_lifts_invariants-val">RC_lifts_invariants</a> : thm
<a name="line101"></a>    val <a href="#RC_lifts_monotonicities-val">RC_lifts_monotonicities</a> : thm
<a name="line102"></a>    val <a href="#REMPTY_SUBSET-val">REMPTY_SUBSET</a> : thm
<a name="line103"></a>    val <a href="#RESTRICT_LEMMA-val">RESTRICT_LEMMA</a> : thm
<a name="line104"></a>    val <a href="#RINTER_ASSOC-val">RINTER_ASSOC</a> : thm
<a name="line105"></a>    val <a href="#RINTER_COMM-val">RINTER_COMM</a> : thm
<a name="line106"></a>    val <a href="#RSUBSET_ANTISYM-val">RSUBSET_ANTISYM</a> : thm
<a name="line107"></a>    val <a href="#RSUBSET_WeakOrder-val">RSUBSET_WeakOrder</a> : thm
<a name="line108"></a>    val <a href="#RSUBSET_antisymmetric-val">RSUBSET_antisymmetric</a> : thm
<a name="line109"></a>    val <a href="#RTC_CASES1-val">RTC_CASES1</a> : thm
<a name="line110"></a>    val <a href="#RTC_CASES2-val">RTC_CASES2</a> : thm
<a name="line111"></a>    val <a href="#RTC_CASES_RTC_TWICE-val">RTC_CASES_RTC_TWICE</a> : thm
<a name="line112"></a>    val <a href="#RTC_CASES_TC-val">RTC_CASES_TC</a> : thm
<a name="line113"></a>    val <a href="#RTC_EQC-val">RTC_EQC</a> : thm
<a name="line114"></a>    val <a href="#RTC_IDEM-val">RTC_IDEM</a> : thm
<a name="line115"></a>    val <a href="#RTC_INDUCT-val">RTC_INDUCT</a> : thm
<a name="line116"></a>    val <a href="#RTC_INDUCT_RIGHT1-val">RTC_INDUCT_RIGHT1</a> : thm
<a name="line117"></a>    val <a href="#RTC_MONOTONE-val">RTC_MONOTONE</a> : thm
<a name="line118"></a>    val <a href="#RTC_REFL-val">RTC_REFL</a> : thm
<a name="line119"></a>    val <a href="#RTC_REFLEXIVE-val">RTC_REFLEXIVE</a> : thm
<a name="line120"></a>    val <a href="#RTC_RTC-val">RTC_RTC</a> : thm
<a name="line121"></a>    val <a href="#RTC_RULES-val">RTC_RULES</a> : thm
<a name="line122"></a>    val <a href="#RTC_RULES_RIGHT1-val">RTC_RULES_RIGHT1</a> : thm
<a name="line123"></a>    val <a href="#RTC_SINGLE-val">RTC_SINGLE</a> : thm
<a name="line124"></a>    val <a href="#RTC_STRONG_INDUCT-val">RTC_STRONG_INDUCT</a> : thm
<a name="line125"></a>    val <a href="#RTC_STRONG_INDUCT_RIGHT1-val">RTC_STRONG_INDUCT_RIGHT1</a> : thm
<a name="line126"></a>    val <a href="#RTC_SUBSET-val">RTC_SUBSET</a> : thm
<a name="line127"></a>    val <a href="#RTC_TC_RC-val">RTC_TC_RC</a> : thm
<a name="line128"></a>    val <a href="#RTC_TRANSITIVE-val">RTC_TRANSITIVE</a> : thm
<a name="line129"></a>    val <a href="#RTC_lifts_equalities-val">RTC_lifts_equalities</a> : thm
<a name="line130"></a>    val <a href="#RTC_lifts_invariants-val">RTC_lifts_invariants</a> : thm
<a name="line131"></a>    val <a href="#RTC_lifts_monotonicities-val">RTC_lifts_monotonicities</a> : thm
<a name="line132"></a>    val <a href="#RTC_lifts_reflexive_transitive_relations-val">RTC_lifts_reflexive_transitive_relations</a> : thm
<a name="line133"></a>    val <a href="#RUNION_ASSOC-val">RUNION_ASSOC</a> : thm
<a name="line134"></a>    val <a href="#RUNION_COMM-val">RUNION_COMM</a> : thm
<a name="line135"></a>    val <a href="#RUNIV_SUBSET-val">RUNIV_SUBSET</a> : thm
<a name="line136"></a>    val <a href="#SC_IDEM-val">SC_IDEM</a> : thm
<a name="line137"></a>    val <a href="#SC_MONOTONE-val">SC_MONOTONE</a> : thm
<a name="line138"></a>    val <a href="#SC_SYMMETRIC-val">SC_SYMMETRIC</a> : thm
<a name="line139"></a>    val <a href="#SC_lifts_equalities-val">SC_lifts_equalities</a> : thm
<a name="line140"></a>    val <a href="#SC_lifts_monotonicities-val">SC_lifts_monotonicities</a> : thm
<a name="line141"></a>    val <a href="#STRONG_EQC_INDUCTION-val">STRONG_EQC_INDUCTION</a> : thm
<a name="line142"></a>    val <a href="#STRORD_AND_NOT_Id-val">STRORD_AND_NOT_Id</a> : thm
<a name="line143"></a>    val <a href="#STRORD_RC-val">STRORD_RC</a> : thm
<a name="line144"></a>    val <a href="#STRORD_Strong-val">STRORD_Strong</a> : thm
<a name="line145"></a>    val <a href="#StrongOrd_Ord-val">StrongOrd_Ord</a> : thm
<a name="line146"></a>    val <a href="#TC_CASES1-val">TC_CASES1</a> : thm
<a name="line147"></a>    val <a href="#TC_CASES2-val">TC_CASES2</a> : thm
<a name="line148"></a>    val <a href="#TC_IDEM-val">TC_IDEM</a> : thm
<a name="line149"></a>    val <a href="#TC_INDUCT-val">TC_INDUCT</a> : thm
<a name="line150"></a>    val <a href="#TC_INDUCT_LEFT1-val">TC_INDUCT_LEFT1</a> : thm
<a name="line151"></a>    val <a href="#TC_INDUCT_RIGHT1-val">TC_INDUCT_RIGHT1</a> : thm
<a name="line152"></a>    val <a href="#TC_MONOTONE-val">TC_MONOTONE</a> : thm
<a name="line153"></a>    val <a href="#TC_RC_EQNS-val">TC_RC_EQNS</a> : thm
<a name="line154"></a>    val <a href="#TC_RTC-val">TC_RTC</a> : thm
<a name="line155"></a>    val <a href="#TC_RULES-val">TC_RULES</a> : thm
<a name="line156"></a>    val <a href="#TC_STRONG_INDUCT-val">TC_STRONG_INDUCT</a> : thm
<a name="line157"></a>    val <a href="#TC_STRONG_INDUCT_LEFT1-val">TC_STRONG_INDUCT_LEFT1</a> : thm
<a name="line158"></a>    val <a href="#TC_STRONG_INDUCT_RIGHT1-val">TC_STRONG_INDUCT_RIGHT1</a> : thm
<a name="line159"></a>    val <a href="#TC_SUBSET-val">TC_SUBSET</a> : thm
<a name="line160"></a>    val <a href="#TC_TRANSITIVE-val">TC_TRANSITIVE</a> : thm
<a name="line161"></a>    val <a href="#TC_implies_one_step-val">TC_implies_one_step</a> : thm
<a name="line162"></a>    val <a href="#TC_lifts_equalities-val">TC_lifts_equalities</a> : thm
<a name="line163"></a>    val <a href="#TC_lifts_invariants-val">TC_lifts_invariants</a> : thm
<a name="line164"></a>    val <a href="#TC_lifts_monotonicities-val">TC_lifts_monotonicities</a> : thm
<a name="line165"></a>    val <a href="#TC_lifts_transitive_relations-val">TC_lifts_transitive_relations</a> : thm
<a name="line166"></a>    val <a href="#TFL_INDUCTIVE_INVARIANT_ON_WFREC-val">TFL_INDUCTIVE_INVARIANT_ON_WFREC</a> : thm
<a name="line167"></a>    val <a href="#TFL_INDUCTIVE_INVARIANT_WFREC-val">TFL_INDUCTIVE_INVARIANT_WFREC</a> : thm
<a name="line168"></a>    val <a href="#WFP_CASES-val">WFP_CASES</a> : thm
<a name="line169"></a>    val <a href="#WFP_INDUCT-val">WFP_INDUCT</a> : thm
<a name="line170"></a>    val <a href="#WFP_RULES-val">WFP_RULES</a> : thm
<a name="line171"></a>    val <a href="#WFP_STRONG_INDUCT-val">WFP_STRONG_INDUCT</a> : thm
<a name="line172"></a>    val <a href="#WFREC_COROLLARY-val">WFREC_COROLLARY</a> : thm
<a name="line173"></a>    val <a href="#WFREC_THM-val">WFREC_THM</a> : thm
<a name="line174"></a>    val <a href="#WF_EMPTY_REL-val">WF_EMPTY_REL</a> : thm
<a name="line175"></a>    val <a href="#WF_EQ_INDUCTION_THM-val">WF_EQ_INDUCTION_THM</a> : thm
<a name="line176"></a>    val <a href="#WF_EQ_WFP-val">WF_EQ_WFP</a> : thm
<a name="line177"></a>    val <a href="#WF_INDUCTION_THM-val">WF_INDUCTION_THM</a> : thm
<a name="line178"></a>    val <a href="#WF_NOT_REFL-val">WF_NOT_REFL</a> : thm
<a name="line179"></a>    val <a href="#WF_RECURSION_THM-val">WF_RECURSION_THM</a> : thm
<a name="line180"></a>    val <a href="#WF_SUBSET-val">WF_SUBSET</a> : thm
<a name="line181"></a>    val <a href="#WF_TC-val">WF_TC</a> : thm
<a name="line182"></a>    val <a href="#WF_TC_EQN-val">WF_TC_EQN</a> : thm
<a name="line183"></a>    val <a href="#WF_antisymmetric-val">WF_antisymmetric</a> : thm
<a name="line184"></a>    val <a href="#WF_inv_image-val">WF_inv_image</a> : thm
<a name="line185"></a>    val <a href="#WF_irreflexive-val">WF_irreflexive</a> : thm
<a name="line186"></a>    val <a href="#WF_noloops-val">WF_noloops</a> : thm
<a name="line187"></a>    val <a href="#WeakLinearOrder_dichotomy-val">WeakLinearOrder_dichotomy</a> : thm
<a name="line188"></a>    val <a href="#WeakOrd_Ord-val">WeakOrd_Ord</a> : thm
<a name="line189"></a>    val <a href="#WeakOrder_EQ-val">WeakOrder_EQ</a> : thm
<a name="line190"></a>    val <a href="#antisymmetric_RC-val">antisymmetric_RC</a> : thm
<a name="line191"></a>    val <a href="#antisymmetric_RINTER-val">antisymmetric_RINTER</a> : thm
<a name="line192"></a>    val <a href="#antisymmetric_inv-val">antisymmetric_inv</a> : thm
<a name="line193"></a>    val <a href="#diamond_RC_diamond-val">diamond_RC_diamond</a> : thm
<a name="line194"></a>    val <a href="#diamond_TC_diamond-val">diamond_TC_diamond</a> : thm
<a name="line195"></a>    val <a href="#equivalence_inv_identity-val">equivalence_inv_identity</a> : thm
<a name="line196"></a>    val <a href="#establish_CR-val">establish_CR</a> : thm
<a name="line197"></a>    val <a href="#inv_EQC-val">inv_EQC</a> : thm
<a name="line198"></a>    val <a href="#inv_INVOL-val">inv_INVOL</a> : thm
<a name="line199"></a>    val <a href="#inv_Id-val">inv_Id</a> : thm
<a name="line200"></a>    val <a href="#inv_MOVES_OUT-val">inv_MOVES_OUT</a> : thm
<a name="line201"></a>    val <a href="#inv_O-val">inv_O</a> : thm
<a name="line202"></a>    val <a href="#inv_RC-val">inv_RC</a> : thm
<a name="line203"></a>    val <a href="#inv_SC-val">inv_SC</a> : thm
<a name="line204"></a>    val <a href="#inv_TC-val">inv_TC</a> : thm
<a name="line205"></a>    val <a href="#inv_diag-val">inv_diag</a> : thm
<a name="line206"></a>    val <a href="#inv_inv-val">inv_inv</a> : thm
<a name="line207"></a>    val <a href="#irrefl_trans_implies_antisym-val">irrefl_trans_implies_antisym</a> : thm
<a name="line208"></a>    val <a href="#irreflexive_RSUBSET-val">irreflexive_RSUBSET</a> : thm
<a name="line209"></a>    val <a href="#irreflexive_inv-val">irreflexive_inv</a> : thm
<a name="line210"></a>    val <a href="#rcdiamond_diamond-val">rcdiamond_diamond</a> : thm
<a name="line211"></a>    val <a href="#reflexive_EQC-val">reflexive_EQC</a> : thm
<a name="line212"></a>    val <a href="#reflexive_Id_RSUBSET-val">reflexive_Id_RSUBSET</a> : thm
<a name="line213"></a>    val <a href="#reflexive_RC-val">reflexive_RC</a> : thm
<a name="line214"></a>    val <a href="#reflexive_RC_identity-val">reflexive_RC_identity</a> : thm
<a name="line215"></a>    val <a href="#reflexive_RTC-val">reflexive_RTC</a> : thm
<a name="line216"></a>    val <a href="#reflexive_TC-val">reflexive_TC</a> : thm
<a name="line217"></a>    val <a href="#reflexive_inv-val">reflexive_inv</a> : thm
<a name="line218"></a>    val <a href="#symmetric_EQC-val">symmetric_EQC</a> : thm
<a name="line219"></a>    val <a href="#symmetric_RC-val">symmetric_RC</a> : thm
<a name="line220"></a>    val <a href="#symmetric_SC_identity-val">symmetric_SC_identity</a> : thm
<a name="line221"></a>    val <a href="#symmetric_TC-val">symmetric_TC</a> : thm
<a name="line222"></a>    val <a href="#symmetric_inv-val">symmetric_inv</a> : thm
<a name="line223"></a>    val <a href="#symmetric_inv_RSUBSET-val">symmetric_inv_RSUBSET</a> : thm
<a name="line224"></a>    val <a href="#symmetric_inv_identity-val">symmetric_inv_identity</a> : thm
<a name="line225"></a>    val <a href="#transitive_EQC-val">transitive_EQC</a> : thm
<a name="line226"></a>    val <a href="#transitive_O_RSUBSET-val">transitive_O_RSUBSET</a> : thm
<a name="line227"></a>    val <a href="#transitive_RC-val">transitive_RC</a> : thm
<a name="line228"></a>    val <a href="#transitive_RINTER-val">transitive_RINTER</a> : thm
<a name="line229"></a>    val <a href="#transitive_RTC-val">transitive_RTC</a> : thm
<a name="line230"></a>    val <a href="#transitive_TC_identity-val">transitive_TC_identity</a> : thm
<a name="line231"></a>    val <a href="#transitive_inv-val">transitive_inv</a> : thm
<a name="line232"></a>
<a name="line233"></a>  val relation_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line234"></a>(*
   [combin] Parent theory of "relation"

   [normalForms] Parent theory of "relation"

   [sat] Parent theory of "relation"

   [<a name="CR_def-val"><b>CR_def</b></a>]  Definition

      |- ∀R. CR R ⇔ diamond R^*

   [<a name="EMPTY_REL_DEF-val"><b>EMPTY_REL_DEF</b></a>]  Definition

      |- ∀x y. REMPTY x y ⇔ F

   [<a name="EQC_DEF-val"><b>EQC_DEF</b></a>]  Definition

      |- ∀R. R^= = RC (SC R)⁺

   [<a name="IDEM_DEF-val"><b>IDEM_DEF</b></a>]  Definition

      |- ∀f. IDEM f ⇔ (f o f = f)

   [<a name="INDUCTIVE_INVARIANT_DEF-val"><b>INDUCTIVE_INVARIANT_DEF</b></a>]  Definition

      |- ∀R P M.
           INDUCTIVE_INVARIANT R P M ⇔
           ∀f x. (∀y. R y x ⇒ P y (f y)) ⇒ P x (M f x)

   [<a name="INDUCTIVE_INVARIANT_ON_DEF-val"><b>INDUCTIVE_INVARIANT_ON_DEF</b></a>]  Definition

      |- ∀R D P M.
           INDUCTIVE_INVARIANT_ON R D P M ⇔
           ∀f x. D x ∧ (∀y. D y ⇒ R y x ⇒ P y (f y)) ⇒ P x (M f x)

   [<a name="INVOL_DEF-val"><b>INVOL_DEF</b></a>]  Definition

      |- ∀f. INVOL f ⇔ (f o f = I)

   [<a name="LinearOrder-val"><b>LinearOrder</b></a>]  Definition

      |- ∀R. LinearOrder R ⇔ Order R ∧ trichotomous R

   [<a name="O_DEF-val"><b>O_DEF</b></a>]  Definition

      |- ∀R1 R2 x z. (R1 O R2) x z ⇔ ∃y. R2 x y ∧ R1 y z

   [<a name="Order-val"><b>Order</b></a>]  Definition

      |- ∀Z. Order Z ⇔ antisymmetric Z ∧ transitive Z

   [<a name="PreOrder-val"><b>PreOrder</b></a>]  Definition

      |- ∀R. PreOrder R ⇔ reflexive R ∧ transitive R

   [<a name="RCOMPL-val"><b>RCOMPL</b></a>]  Definition

      |- ∀R x y. RCOMPL R x y ⇔ ¬R x y

   [<a name="RC_DEF-val"><b>RC_DEF</b></a>]  Definition

      |- ∀R x y. RC R x y ⇔ (x = y) ∨ R x y

   [<a name="RDOM_DEF-val"><b>RDOM_DEF</b></a>]  Definition

      |- ∀R x. RDOM R x ⇔ ∃y. R x y

   [<a name="RESTRICT_DEF-val"><b>RESTRICT_DEF</b></a>]  Definition

      |- ∀f R x. RESTRICT f R x = (λy. if R y x then f y else ARB)

   [<a name="RINTER-val"><b>RINTER</b></a>]  Definition

      |- ∀R1 R2 x y. (R1 RINTER R2) x y ⇔ R1 x y ∧ R2 x y

   [<a name="RRANGE-val"><b>RRANGE</b></a>]  Definition

      |- ∀R y. RRANGE R y ⇔ ∃x. R x y

   [<a name="RSUBSET-val"><b>RSUBSET</b></a>]  Definition

      |- ∀R1 R2. R1 RSUBSET R2 ⇔ ∀x y. R1 x y ⇒ R2 x y

   [<a name="RTC_DEF-val"><b>RTC_DEF</b></a>]  Definition

      |- ∀R a b.
           R^* a b ⇔
           ∀P. (∀x. P x x) ∧ (∀x y z. R x y ∧ P y z ⇒ P x z) ⇒ P a b

   [<a name="RUNION-val"><b>RUNION</b></a>]  Definition

      |- ∀R1 R2 x y. (R1 RUNION R2) x y ⇔ R1 x y ∨ R2 x y

   [<a name="RUNIV-val"><b>RUNIV</b></a>]  Definition

      |- ∀x y. RUNIV x y ⇔ T

   [<a name="SC_DEF-val"><b>SC_DEF</b></a>]  Definition

      |- ∀R x y. SC R x y ⇔ R x y ∨ R y x

   [<a name="SN_def-val"><b>SN_def</b></a>]  Definition

      |- ∀R. SN R ⇔ WF (inv R)

   [<a name="STRORD-val"><b>STRORD</b></a>]  Definition

      |- ∀R a b. STRORD R a b ⇔ R a b ∧ a ≠ b

   [<a name="StrongLinearOrder-val"><b>StrongLinearOrder</b></a>]  Definition

      |- ∀R. StrongLinearOrder R ⇔ StrongOrder R ∧ trichotomous R

   [<a name="StrongOrder-val"><b>StrongOrder</b></a>]  Definition

      |- ∀Z. StrongOrder Z ⇔ irreflexive Z ∧ transitive Z

   [<a name="TC_DEF-val"><b>TC_DEF</b></a>]  Definition

      |- ∀R a b.
           R⁺ a b ⇔
           ∀P.
             (∀x y. R x y ⇒ P x y) ∧ (∀x y z. P x y ∧ P y z ⇒ P x z) ⇒
             P a b

   [<a name="WCR_def-val"><b>WCR_def</b></a>]  Definition

      |- ∀R. WCR R ⇔ ∀x y z. R x y ∧ R x z ⇒ ∃u. R^* y u ∧ R^* z u

   [<a name="WFP_DEF-val"><b>WFP_DEF</b></a>]  Definition

      |- ∀R a. WFP R a ⇔ ∀P. (∀x. (∀y. R y x ⇒ P y) ⇒ P x) ⇒ P a

   [<a name="WFREC_DEF-val"><b>WFREC_DEF</b></a>]  Definition

      |- ∀R M.
           WFREC R M =
           (λx.
              M (RESTRICT (the_fun R⁺ (λf v. M (RESTRICT f R v) v) x) R x)
                x)

   [<a name="WF_DEF-val"><b>WF_DEF</b></a>]  Definition

      |- ∀R. WF R ⇔ ∀B. (∃w. B w) ⇒ ∃min. B min ∧ ∀b. R b min ⇒ ¬B b

   [<a name="WeakLinearOrder-val"><b>WeakLinearOrder</b></a>]  Definition

      |- ∀R. WeakLinearOrder R ⇔ WeakOrder R ∧ trichotomous R

   [<a name="WeakOrder-val"><b>WeakOrder</b></a>]  Definition

      |- ∀Z. WeakOrder Z ⇔ reflexive Z ∧ antisymmetric Z ∧ transitive Z

   [<a name="antisymmetric_def-val"><b>antisymmetric_def</b></a>]  Definition

      |- ∀R. antisymmetric R ⇔ ∀x y. R x y ∧ R y x ⇒ (x = y)

   [<a name="approx_def-val"><b>approx_def</b></a>]  Definition

      |- ∀R M x f.
           approx R M x f ⇔ (f = RESTRICT (λy. M (RESTRICT f R y) y) R x)

   [<a name="diag_def-val"><b>diag_def</b></a>]  Definition

      |- ∀A x y. diag A x y ⇔ (x = y) ∧ x ∈ A

   [<a name="diamond_def-val"><b>diamond_def</b></a>]  Definition

      |- ∀R. diamond R ⇔ ∀x y z. R x y ∧ R x z ⇒ ∃u. R y u ∧ R z u

   [<a name="equivalence_def-val"><b>equivalence_def</b></a>]  Definition

      |- ∀R. equivalence R ⇔ reflexive R ∧ symmetric R ∧ transitive R

   [<a name="inv_DEF-val"><b>inv_DEF</b></a>]  Definition

      |- ∀R x y. inv R x y ⇔ R y x

   [<a name="inv_image_def-val"><b>inv_image_def</b></a>]  Definition

      |- ∀R f. inv_image R f = (λx y. R (f x) (f y))

   [<a name="irreflexive_def-val"><b>irreflexive_def</b></a>]  Definition

      |- ∀R. irreflexive R ⇔ ∀x. ¬R x x

   [<a name="nf_def-val"><b>nf_def</b></a>]  Definition

      |- ∀R x. nf R x ⇔ ∀y. ¬R x y

   [<a name="rcdiamond_def-val"><b>rcdiamond_def</b></a>]  Definition

      |- ∀R. rcdiamond R ⇔ ∀x y z. R x y ∧ R x z ⇒ ∃u. RC R y u ∧ RC R z u

   [<a name="reflexive_def-val"><b>reflexive_def</b></a>]  Definition

      |- ∀R. reflexive R ⇔ ∀x. R x x

   [<a name="symmetric_def-val"><b>symmetric_def</b></a>]  Definition

      |- ∀R. symmetric R ⇔ ∀x y. R x y ⇔ R y x

   [<a name="the_fun_def-val"><b>the_fun_def</b></a>]  Definition

      |- ∀R M x. the_fun R M x = @f. approx R M x f

   [<a name="total_def-val"><b>total_def</b></a>]  Definition

      |- ∀R. total R ⇔ ∀x y. R x y ∨ R y x

   [<a name="transitive_def-val"><b>transitive_def</b></a>]  Definition

      |- ∀R. transitive R ⇔ ∀x y z. R x y ∧ R y z ⇒ R x z

   [<a name="trichotomous-val"><b>trichotomous</b></a>]  Definition

      |- ∀R. trichotomous R ⇔ ∀a b. R a b ∨ R b a ∨ (a = b)

   [<a name="ALT_equivalence-val"><b>ALT_equivalence</b></a>]  Theorem

      |- ∀R. equivalence R ⇔ ∀x y. R x y ⇔ (R x = R y)

   [<a name="EQC_EQUIVALENCE-val"><b>EQC_EQUIVALENCE</b></a>]  Theorem

      |- ∀R. equivalence R^=

   [<a name="EQC_IDEM-val"><b>EQC_IDEM</b></a>]  Theorem

      |- ∀R. R^= ^= = R^=

   [<a name="EQC_INDUCTION-val"><b>EQC_INDUCTION</b></a>]  Theorem

      |- ∀R P.
           (∀x y. R x y ⇒ P x y) ∧ (∀x. P x x) ∧ (∀x y. P x y ⇒ P y x) ∧
           (∀x y z. P x y ∧ P y z ⇒ P x z) ⇒
           ∀x y. R^= x y ⇒ P x y

   [<a name="EQC_MONOTONE-val"><b>EQC_MONOTONE</b></a>]  Theorem

      |- (∀x y. R x y ⇒ R' x y) ⇒ R^= x y ⇒ R'^= x y

   [<a name="EQC_MOVES_IN-val"><b>EQC_MOVES_IN</b></a>]  Theorem

      |- ∀R. ((RC R)^= = R^=) ∧ ((SC R)^= = R^=) ∧ (R⁺ ^= = R^=)

   [<a name="EQC_R-val"><b>EQC_R</b></a>]  Theorem

      |- ∀R x y. R x y ⇒ R^= x y

   [<a name="EQC_REFL-val"><b>EQC_REFL</b></a>]  Theorem

      |- ∀R x. R^= x x

   [<a name="EQC_SYM-val"><b>EQC_SYM</b></a>]  Theorem

      |- ∀R x y. R^= x y ⇒ R^= y x

   [<a name="EQC_TRANS-val"><b>EQC_TRANS</b></a>]  Theorem

      |- ∀R x y z. R^= x y ∧ R^= y z ⇒ R^= x z

   [<a name="EXTEND_RTC_TC-val"><b>EXTEND_RTC_TC</b></a>]  Theorem

      |- ∀R x y z. R x y ∧ R^* y z ⇒ R⁺ x z

   [<a name="EXTEND_RTC_TC_EQN-val"><b>EXTEND_RTC_TC_EQN</b></a>]  Theorem

      |- ∀R x z. R⁺ x z ⇔ ∃y. R x y ∧ R^* y z

   [<a name="EqIsBothRSUBSET-val"><b>EqIsBothRSUBSET</b></a>]  Theorem

      |- ∀y z. (y = z) ⇔ y RSUBSET z ∧ z RSUBSET y

   [<a name="IDEM-val"><b>IDEM</b></a>]  Theorem

      |- ∀f. IDEM f ⇔ ∀x. f (f x) = f x

   [<a name="IDEM_RC-val"><b>IDEM_RC</b></a>]  Theorem

      |- IDEM RC

   [<a name="IDEM_RTC-val"><b>IDEM_RTC</b></a>]  Theorem

      |- IDEM RTC

   [<a name="IDEM_SC-val"><b>IDEM_SC</b></a>]  Theorem

      |- IDEM SC

   [<a name="IDEM_STRORD-val"><b>IDEM_STRORD</b></a>]  Theorem

      |- IDEM STRORD

   [<a name="IDEM_TC-val"><b>IDEM_TC</b></a>]  Theorem

      |- IDEM TC

   [<a name="INDUCTION_WF_THM-val"><b>INDUCTION_WF_THM</b></a>]  Theorem

      |- ∀R. (∀P. (∀x. (∀y. R y x ⇒ P y) ⇒ P x) ⇒ ∀x. P x) ⇒ WF R

   [<a name="INDUCTIVE_INVARIANT_ON_WFREC-val"><b>INDUCTIVE_INVARIANT_ON_WFREC</b></a>]  Theorem

      |- ∀R P M D x.
           WF R ∧ INDUCTIVE_INVARIANT_ON R D P M ∧ D x ⇒ P x (WFREC R M x)

   [<a name="INDUCTIVE_INVARIANT_WFREC-val"><b>INDUCTIVE_INVARIANT_WFREC</b></a>]  Theorem

      |- ∀R P M. WF R ∧ INDUCTIVE_INVARIANT R P M ⇒ ∀x. P x (WFREC R M x)

   [<a name="INVOL-val"><b>INVOL</b></a>]  Theorem

      |- ∀f. INVOL f ⇔ ∀x. f (f x) = x

   [<a name="INVOL_ONE_ENO-val"><b>INVOL_ONE_ENO</b></a>]  Theorem

      |- ∀f. INVOL f ⇒ ∀a b. (f a = b) ⇔ (a = f b)

   [<a name="INVOL_ONE_ONE-val"><b>INVOL_ONE_ONE</b></a>]  Theorem

      |- ∀f. INVOL f ⇒ ∀a b. (f a = f b) ⇔ (a = b)

   [<a name="IN_RDOM-val"><b>IN_RDOM</b></a>]  Theorem

      |- x ∈ RDOM R ⇔ ∃y. R x y

   [<a name="IN_RRANGE-val"><b>IN_RRANGE</b></a>]  Theorem

      |- y ∈ RRANGE R ⇔ ∃x. R x y

   [<a name="Id_O-val"><b>Id_O</b></a>]  Theorem

      |- $= O R = R

   [<a name="NOT_INVOL-val"><b>NOT_INVOL</b></a>]  Theorem

      |- INVOL $~

   [<a name="Newmans_lemma-val"><b>Newmans_lemma</b></a>]  Theorem

      |- ∀R. WCR R ∧ SN R ⇒ CR R

   [<a name="O_ASSOC-val"><b>O_ASSOC</b></a>]  Theorem

      |- R1 O R2 O R3 = (R1 O R2) O R3

   [<a name="O_Id-val"><b>O_Id</b></a>]  Theorem

      |- R O $= = R

   [<a name="O_MONO-val"><b>O_MONO</b></a>]  Theorem

      |- R1 RSUBSET R2 ∧ S1 RSUBSET S2 ⇒ R1 O S1 RSUBSET R2 O S2

   [<a name="RC_IDEM-val"><b>RC_IDEM</b></a>]  Theorem

      |- ∀R. RC (RC R) = RC R

   [<a name="RC_MONOTONE-val"><b>RC_MONOTONE</b></a>]  Theorem

      |- (∀x y. R x y ⇒ Q x y) ⇒ RC R x y ⇒ RC Q x y

   [<a name="RC_MOVES_OUT-val"><b>RC_MOVES_OUT</b></a>]  Theorem

      |- ∀R.
           (SC (RC R) = RC (SC R)) ∧ (RC (RC R) = RC R) ∧ ((RC R)⁺ = RC R⁺)

   [<a name="RC_OR_Id-val"><b>RC_OR_Id</b></a>]  Theorem

      |- RC R = R RUNION $=

   [<a name="RC_REFLEXIVE-val"><b>RC_REFLEXIVE</b></a>]  Theorem

      |- ∀R. reflexive (RC R)

   [<a name="RC_RTC-val"><b>RC_RTC</b></a>]  Theorem

      |- ∀R x y. RC R x y ⇒ R^* x y

   [<a name="RC_STRORD-val"><b>RC_STRORD</b></a>]  Theorem

      |- ∀R. WeakOrder R ⇒ (RC (STRORD R) = R)

   [<a name="RC_SUBSET-val"><b>RC_SUBSET</b></a>]  Theorem

      |- ∀R x y. R x y ⇒ RC R x y

   [<a name="RC_Weak-val"><b>RC_Weak</b></a>]  Theorem

      |- Order R ⇔ WeakOrder (RC R)

   [<a name="RC_lifts_equalities-val"><b>RC_lifts_equalities</b></a>]  Theorem

      |- (∀x y. R x y ⇒ (f x = f y)) ⇒ ∀x y. RC R x y ⇒ (f x = f y)

   [<a name="RC_lifts_invariants-val"><b>RC_lifts_invariants</b></a>]  Theorem

      |- (∀x y. P x ∧ R x y ⇒ P y) ⇒ ∀x y. P x ∧ RC R x y ⇒ P y

   [<a name="RC_lifts_monotonicities-val"><b>RC_lifts_monotonicities</b></a>]  Theorem

      |- (∀x y. R x y ⇒ R (f x) (f y)) ⇒ ∀x y. RC R x y ⇒ RC R (f x) (f y)

   [<a name="REMPTY_SUBSET-val"><b>REMPTY_SUBSET</b></a>]  Theorem

      |- REMPTY RSUBSET R ∧ (R RSUBSET REMPTY ⇔ (R = REMPTY))

   [<a name="RESTRICT_LEMMA-val"><b>RESTRICT_LEMMA</b></a>]  Theorem

      |- ∀f R y z. R y z ⇒ (RESTRICT f R z y = f y)

   [<a name="RINTER_ASSOC-val"><b>RINTER_ASSOC</b></a>]  Theorem

      |- R1 RINTER (R2 RINTER R3) = R1 RINTER R2 RINTER R3

   [<a name="RINTER_COMM-val"><b>RINTER_COMM</b></a>]  Theorem

      |- R1 RINTER R2 = R2 RINTER R1

   [<a name="RSUBSET_ANTISYM-val"><b>RSUBSET_ANTISYM</b></a>]  Theorem

      |- ∀R1 R2. R1 RSUBSET R2 ∧ R2 RSUBSET R1 ⇒ (R1 = R2)

   [<a name="RSUBSET_WeakOrder-val"><b>RSUBSET_WeakOrder</b></a>]  Theorem

      |- WeakOrder $RSUBSET

   [<a name="RSUBSET_antisymmetric-val"><b>RSUBSET_antisymmetric</b></a>]  Theorem

      |- antisymmetric $RSUBSET

   [<a name="RTC_CASES1-val"><b>RTC_CASES1</b></a>]  Theorem

      |- ∀R x y. R^* x y ⇔ (x = y) ∨ ∃u. R x u ∧ R^* u y

   [<a name="RTC_CASES2-val"><b>RTC_CASES2</b></a>]  Theorem

      |- ∀R x y. R^* x y ⇔ (x = y) ∨ ∃u. R^* x u ∧ R u y

   [<a name="RTC_CASES_RTC_TWICE-val"><b>RTC_CASES_RTC_TWICE</b></a>]  Theorem

      |- ∀R x y. R^* x y ⇔ ∃u. R^* x u ∧ R^* u y

   [<a name="RTC_CASES_TC-val"><b>RTC_CASES_TC</b></a>]  Theorem

      |- ∀R x y. R^* x y ⇔ (x = y) ∨ R⁺ x y

   [<a name="RTC_EQC-val"><b>RTC_EQC</b></a>]  Theorem

      |- ∀x y. R^* x y ⇒ R^= x y

   [<a name="RTC_IDEM-val"><b>RTC_IDEM</b></a>]  Theorem

      |- ∀R. R^* ^* = R^*

   [<a name="RTC_INDUCT-val"><b>RTC_INDUCT</b></a>]  Theorem

      |- ∀R P.
           (∀x. P x x) ∧ (∀x y z. R x y ∧ P y z ⇒ P x z) ⇒
           ∀x y. R^* x y ⇒ P x y

   [<a name="RTC_INDUCT_RIGHT1-val"><b>RTC_INDUCT_RIGHT1</b></a>]  Theorem

      |- ∀R P.
           (∀x. P x x) ∧ (∀x y z. P x y ∧ R y z ⇒ P x z) ⇒
           ∀x y. R^* x y ⇒ P x y

   [<a name="RTC_MONOTONE-val"><b>RTC_MONOTONE</b></a>]  Theorem

      |- (∀x y. R x y ⇒ Q x y) ⇒ R^* x y ⇒ Q^* x y

   [<a name="RTC_REFL-val"><b>RTC_REFL</b></a>]  Theorem

      |- R^* x x

   [<a name="RTC_REFLEXIVE-val"><b>RTC_REFLEXIVE</b></a>]  Theorem

      |- ∀R. reflexive R^*

   [<a name="RTC_RTC-val"><b>RTC_RTC</b></a>]  Theorem

      |- ∀R x y. R^* x y ⇒ ∀z. R^* y z ⇒ R^* x z

   [<a name="RTC_RULES-val"><b>RTC_RULES</b></a>]  Theorem

      |- ∀R. (∀x. R^* x x) ∧ ∀x y z. R x y ∧ R^* y z ⇒ R^* x z

   [<a name="RTC_RULES_RIGHT1-val"><b>RTC_RULES_RIGHT1</b></a>]  Theorem

      |- ∀R. (∀x. R^* x x) ∧ ∀x y z. R^* x y ∧ R y z ⇒ R^* x z

   [<a name="RTC_SINGLE-val"><b>RTC_SINGLE</b></a>]  Theorem

      |- ∀R x y. R x y ⇒ R^* x y

   [<a name="RTC_STRONG_INDUCT-val"><b>RTC_STRONG_INDUCT</b></a>]  Theorem

      |- ∀R P.
           (∀x. P x x) ∧ (∀x y z. R x y ∧ R^* y z ∧ P y z ⇒ P x z) ⇒
           ∀x y. R^* x y ⇒ P x y

   [<a name="RTC_STRONG_INDUCT_RIGHT1-val"><b>RTC_STRONG_INDUCT_RIGHT1</b></a>]  Theorem

      |- ∀R P.
           (∀x. P x x) ∧ (∀x y z. P x y ∧ R^* x y ∧ R y z ⇒ P x z) ⇒
           ∀x y. R^* x y ⇒ P x y

   [<a name="RTC_SUBSET-val"><b>RTC_SUBSET</b></a>]  Theorem

      |- ∀R x y. R x y ⇒ R^* x y

   [<a name="RTC_TC_RC-val"><b>RTC_TC_RC</b></a>]  Theorem

      |- ∀R x y. R^* x y ⇒ RC R x y ∨ R⁺ x y

   [<a name="RTC_TRANSITIVE-val"><b>RTC_TRANSITIVE</b></a>]  Theorem

      |- ∀R. transitive R^*

   [<a name="RTC_lifts_equalities-val"><b>RTC_lifts_equalities</b></a>]  Theorem

      |- (∀x y. R x y ⇒ (f x = f y)) ⇒ ∀x y. R^* x y ⇒ (f x = f y)

   [<a name="RTC_lifts_invariants-val"><b>RTC_lifts_invariants</b></a>]  Theorem

      |- (∀x y. P x ∧ R x y ⇒ P y) ⇒ ∀x y. P x ∧ R^* x y ⇒ P y

   [<a name="RTC_lifts_monotonicities-val"><b>RTC_lifts_monotonicities</b></a>]  Theorem

      |- (∀x y. R x y ⇒ R (f x) (f y)) ⇒ ∀x y. R^* x y ⇒ R^* (f x) (f y)

   [<a name="RTC_lifts_reflexive_transitive_relations-val"><b>RTC_lifts_reflexive_transitive_relations</b></a>]  Theorem

      |- (∀x y. R x y ⇒ Q (f x) (f y)) ∧ reflexive Q ∧ transitive Q ⇒
         ∀x y. R^* x y ⇒ Q (f x) (f y)

   [<a name="RUNION_ASSOC-val"><b>RUNION_ASSOC</b></a>]  Theorem

      |- R1 RUNION (R2 RUNION R3) = R1 RUNION R2 RUNION R3

   [<a name="RUNION_COMM-val"><b>RUNION_COMM</b></a>]  Theorem

      |- R1 RUNION R2 = R2 RUNION R1

   [<a name="RUNIV_SUBSET-val"><b>RUNIV_SUBSET</b></a>]  Theorem

      |- (RUNIV RSUBSET R ⇔ (R = RUNIV)) ∧ R RSUBSET RUNIV

   [<a name="SC_IDEM-val"><b>SC_IDEM</b></a>]  Theorem

      |- ∀R. SC (SC R) = SC R

   [<a name="SC_MONOTONE-val"><b>SC_MONOTONE</b></a>]  Theorem

      |- (∀x y. R x y ⇒ Q x y) ⇒ SC R x y ⇒ SC Q x y

   [<a name="SC_SYMMETRIC-val"><b>SC_SYMMETRIC</b></a>]  Theorem

      |- ∀R. symmetric (SC R)

   [<a name="SC_lifts_equalities-val"><b>SC_lifts_equalities</b></a>]  Theorem

      |- (∀x y. R x y ⇒ (f x = f y)) ⇒ ∀x y. SC R x y ⇒ (f x = f y)

   [<a name="SC_lifts_monotonicities-val"><b>SC_lifts_monotonicities</b></a>]  Theorem

      |- (∀x y. R x y ⇒ R (f x) (f y)) ⇒ ∀x y. SC R x y ⇒ SC R (f x) (f y)

   [<a name="STRONG_EQC_INDUCTION-val"><b>STRONG_EQC_INDUCTION</b></a>]  Theorem

      |- ∀R P.
           (∀x y. R x y ⇒ P x y) ∧ (∀x. P x x) ∧
           (∀x y. R^= x y ∧ P x y ⇒ P y x) ∧
           (∀x y z. P x y ∧ P y z ∧ R^= x y ∧ R^= y z ⇒ P x z) ⇒
           ∀x y. R^= x y ⇒ P x y

   [<a name="STRORD_AND_NOT_Id-val"><b>STRORD_AND_NOT_Id</b></a>]  Theorem

      |- STRORD R = R RINTER RCOMPL $=

   [<a name="STRORD_RC-val"><b>STRORD_RC</b></a>]  Theorem

      |- ∀R. StrongOrder R ⇒ (STRORD (RC R) = R)

   [<a name="STRORD_Strong-val"><b>STRORD_Strong</b></a>]  Theorem

      |- ∀R. Order R ⇔ StrongOrder (STRORD R)

   [<a name="StrongOrd_Ord-val"><b>StrongOrd_Ord</b></a>]  Theorem

      |- ∀R. StrongOrder R ⇒ Order R

   [<a name="TC_CASES1-val"><b>TC_CASES1</b></a>]  Theorem

      |- ∀R x z. R⁺ x z ⇒ R x z ∨ ∃y. R x y ∧ R⁺ y z

   [<a name="TC_CASES2-val"><b>TC_CASES2</b></a>]  Theorem

      |- ∀R x z. R⁺ x z ⇒ R x z ∨ ∃y. R⁺ x y ∧ R y z

   [<a name="TC_IDEM-val"><b>TC_IDEM</b></a>]  Theorem

      |- ∀R. R⁺ ⁺ = R⁺

   [<a name="TC_INDUCT-val"><b>TC_INDUCT</b></a>]  Theorem

      |- ∀R P.
           (∀x y. R x y ⇒ P x y) ∧ (∀x y z. P x y ∧ P y z ⇒ P x z) ⇒
           ∀u v. R⁺ u v ⇒ P u v

   [<a name="TC_INDUCT_LEFT1-val"><b>TC_INDUCT_LEFT1</b></a>]  Theorem

      |- ∀R P.
           (∀x y. R x y ⇒ P x y) ∧ (∀x y z. R x y ∧ P y z ⇒ P x z) ⇒
           ∀x y. R⁺ x y ⇒ P x y

   [<a name="TC_INDUCT_RIGHT1-val"><b>TC_INDUCT_RIGHT1</b></a>]  Theorem

      |- ∀R P.
           (∀x y. R x y ⇒ P x y) ∧ (∀x y z. P x y ∧ R y z ⇒ P x z) ⇒
           ∀x y. R⁺ x y ⇒ P x y

   [<a name="TC_MONOTONE-val"><b>TC_MONOTONE</b></a>]  Theorem

      |- (∀x y. R x y ⇒ Q x y) ⇒ R⁺ x y ⇒ Q⁺ x y

   [<a name="TC_RC_EQNS-val"><b>TC_RC_EQNS</b></a>]  Theorem

      |- ∀R. (RC R⁺ = R^* ) ∧ ((RC R)⁺ = R^* )

   [<a name="TC_RTC-val"><b>TC_RTC</b></a>]  Theorem

      |- ∀R x y. R⁺ x y ⇒ R^* x y

   [<a name="TC_RULES-val"><b>TC_RULES</b></a>]  Theorem

      |- ∀R. (∀x y. R x y ⇒ R⁺ x y) ∧ ∀x y z. R⁺ x y ∧ R⁺ y z ⇒ R⁺ x z

   [<a name="TC_STRONG_INDUCT-val"><b>TC_STRONG_INDUCT</b></a>]  Theorem

      |- ∀R P.
           (∀x y. R x y ⇒ P x y) ∧
           (∀x y z. P x y ∧ P y z ∧ R⁺ x y ∧ R⁺ y z ⇒ P x z) ⇒
           ∀u v. R⁺ u v ⇒ P u v

   [<a name="TC_STRONG_INDUCT_LEFT1-val"><b>TC_STRONG_INDUCT_LEFT1</b></a>]  Theorem

      |- ∀R P.
           (∀x y. R x y ⇒ P x y) ∧
           (∀x y z. R x y ∧ P y z ∧ R⁺ y z ⇒ P x z) ⇒
           ∀u v. R⁺ u v ⇒ P u v

   [<a name="TC_STRONG_INDUCT_RIGHT1-val"><b>TC_STRONG_INDUCT_RIGHT1</b></a>]  Theorem

      |- ∀R P.
           (∀x y. R x y ⇒ P x y) ∧
           (∀x y z. P x y ∧ R⁺ x y ∧ R y z ⇒ P x z) ⇒
           ∀u v. R⁺ u v ⇒ P u v

   [<a name="TC_SUBSET-val"><b>TC_SUBSET</b></a>]  Theorem

      |- ∀R x y. R x y ⇒ R⁺ x y

   [<a name="TC_TRANSITIVE-val"><b>TC_TRANSITIVE</b></a>]  Theorem

      |- ∀R. transitive R⁺

   [<a name="TC_implies_one_step-val"><b>TC_implies_one_step</b></a>]  Theorem

      |- ∀x y. R⁺ x y ∧ x ≠ y ⇒ ∃z. R x z ∧ x ≠ z

   [<a name="TC_lifts_equalities-val"><b>TC_lifts_equalities</b></a>]  Theorem

      |- (∀x y. R x y ⇒ (f x = f y)) ⇒ ∀x y. R⁺ x y ⇒ (f x = f y)

   [<a name="TC_lifts_invariants-val"><b>TC_lifts_invariants</b></a>]  Theorem

      |- (∀x y. P x ∧ R x y ⇒ P y) ⇒ ∀x y. P x ∧ R⁺ x y ⇒ P y

   [<a name="TC_lifts_monotonicities-val"><b>TC_lifts_monotonicities</b></a>]  Theorem

      |- (∀x y. R x y ⇒ R (f x) (f y)) ⇒ ∀x y. R⁺ x y ⇒ R⁺ (f x) (f y)

   [<a name="TC_lifts_transitive_relations-val"><b>TC_lifts_transitive_relations</b></a>]  Theorem

      |- (∀x y. R x y ⇒ Q (f x) (f y)) ∧ transitive Q ⇒
         ∀x y. R⁺ x y ⇒ Q (f x) (f y)

   [<a name="TFL_INDUCTIVE_INVARIANT_ON_WFREC-val"><b>TFL_INDUCTIVE_INVARIANT_ON_WFREC</b></a>]  Theorem

      |- ∀f R D P M x.
           (f = WFREC R M) ∧ WF R ∧ INDUCTIVE_INVARIANT_ON R D P M ∧ D x ⇒
           P x (f x)

   [<a name="TFL_INDUCTIVE_INVARIANT_WFREC-val"><b>TFL_INDUCTIVE_INVARIANT_WFREC</b></a>]  Theorem

      |- ∀f R P M x.
           (f = WFREC R M) ∧ WF R ∧ INDUCTIVE_INVARIANT R P M ⇒ P x (f x)

   [<a name="WFP_CASES-val"><b>WFP_CASES</b></a>]  Theorem

      |- ∀R x. WFP R x ⇔ ∀y. R y x ⇒ WFP R y

   [<a name="WFP_INDUCT-val"><b>WFP_INDUCT</b></a>]  Theorem

      |- ∀R P. (∀x. (∀y. R y x ⇒ P y) ⇒ P x) ⇒ ∀x. WFP R x ⇒ P x

   [<a name="WFP_RULES-val"><b>WFP_RULES</b></a>]  Theorem

      |- ∀R x. (∀y. R y x ⇒ WFP R y) ⇒ WFP R x

   [<a name="WFP_STRONG_INDUCT-val"><b>WFP_STRONG_INDUCT</b></a>]  Theorem

      |- ∀R. (∀x. WFP R x ∧ (∀y. R y x ⇒ P y) ⇒ P x) ⇒ ∀x. WFP R x ⇒ P x

   [<a name="WFREC_COROLLARY-val"><b>WFREC_COROLLARY</b></a>]  Theorem

      |- ∀M R f. (f = WFREC R M) ⇒ WF R ⇒ ∀x. f x = M (RESTRICT f R x) x

   [<a name="WFREC_THM-val"><b>WFREC_THM</b></a>]  Theorem

      |- ∀R M. WF R ⇒ ∀x. WFREC R M x = M (RESTRICT (WFREC R M) R x) x

   [<a name="WF_EMPTY_REL-val"><b>WF_EMPTY_REL</b></a>]  Theorem

      |- WF REMPTY

   [<a name="WF_EQ_INDUCTION_THM-val"><b>WF_EQ_INDUCTION_THM</b></a>]  Theorem

      |- ∀R. WF R ⇔ ∀P. (∀x. (∀y. R y x ⇒ P y) ⇒ P x) ⇒ ∀x. P x

   [<a name="WF_EQ_WFP-val"><b>WF_EQ_WFP</b></a>]  Theorem

      |- ∀R. WF R ⇔ ∀x. WFP R x

   [<a name="WF_INDUCTION_THM-val"><b>WF_INDUCTION_THM</b></a>]  Theorem

      |- ∀R. WF R ⇒ ∀P. (∀x. (∀y. R y x ⇒ P y) ⇒ P x) ⇒ ∀x. P x

   [<a name="WF_NOT_REFL-val"><b>WF_NOT_REFL</b></a>]  Theorem

      |- ∀R x y. WF R ⇒ R x y ⇒ x ≠ y

   [<a name="WF_RECURSION_THM-val"><b>WF_RECURSION_THM</b></a>]  Theorem

      |- ∀R. WF R ⇒ ∀M. ∃!f. ∀x. f x = M (RESTRICT f R x) x

   [<a name="WF_SUBSET-val"><b>WF_SUBSET</b></a>]  Theorem

      |- ∀R P. WF R ∧ (∀x y. P x y ⇒ R x y) ⇒ WF P

   [<a name="WF_TC-val"><b>WF_TC</b></a>]  Theorem

      |- ∀R. WF R ⇒ WF R⁺

   [<a name="WF_TC_EQN-val"><b>WF_TC_EQN</b></a>]  Theorem

      |- WF R⁺ ⇔ WF R

   [<a name="WF_antisymmetric-val"><b>WF_antisymmetric</b></a>]  Theorem

      |- WF R ⇒ antisymmetric R

   [<a name="WF_inv_image-val"><b>WF_inv_image</b></a>]  Theorem

      |- ∀R f. WF R ⇒ WF (inv_image R f)

   [<a name="WF_irreflexive-val"><b>WF_irreflexive</b></a>]  Theorem

      |- WF R ⇒ irreflexive R

   [<a name="WF_noloops-val"><b>WF_noloops</b></a>]  Theorem

      |- WF R ⇒ R⁺ x y ⇒ x ≠ y

   [<a name="WeakLinearOrder_dichotomy-val"><b>WeakLinearOrder_dichotomy</b></a>]  Theorem

      |- ∀R. WeakLinearOrder R ⇔ WeakOrder R ∧ ∀a b. R a b ∨ R b a

   [<a name="WeakOrd_Ord-val"><b>WeakOrd_Ord</b></a>]  Theorem

      |- ∀R. WeakOrder R ⇒ Order R

   [<a name="WeakOrder_EQ-val"><b>WeakOrder_EQ</b></a>]  Theorem

      |- ∀R. WeakOrder R ⇒ ∀y z. (y = z) ⇔ R y z ∧ R z y

   [<a name="antisymmetric_RC-val"><b>antisymmetric_RC</b></a>]  Theorem

      |- ∀R. antisymmetric (RC R) ⇔ antisymmetric R

   [<a name="antisymmetric_RINTER-val"><b>antisymmetric_RINTER</b></a>]  Theorem

      |- (antisymmetric R1 ⇒ antisymmetric (R1 RINTER R2)) ∧
         (antisymmetric R2 ⇒ antisymmetric (R1 RINTER R2))

   [<a name="antisymmetric_inv-val"><b>antisymmetric_inv</b></a>]  Theorem

      |- ∀R. antisymmetric (inv R) ⇔ antisymmetric R

   [<a name="diamond_RC_diamond-val"><b>diamond_RC_diamond</b></a>]  Theorem

      |- ∀R. diamond R ⇒ diamond (RC R)

   [<a name="diamond_TC_diamond-val"><b>diamond_TC_diamond</b></a>]  Theorem

      |- ∀R. diamond R ⇒ diamond R⁺

   [<a name="equivalence_inv_identity-val"><b>equivalence_inv_identity</b></a>]  Theorem

      |- ∀R. equivalence R ⇒ (inv R = R)

   [<a name="establish_CR-val"><b>establish_CR</b></a>]  Theorem

      |- ∀R. (rcdiamond R ⇒ CR R) ∧ (diamond R ⇒ CR R)

   [<a name="inv_EQC-val"><b>inv_EQC</b></a>]  Theorem

      |- ∀R. (inv R^= = R^=) ∧ ((inv R)^= = R^=)

   [<a name="inv_INVOL-val"><b>inv_INVOL</b></a>]  Theorem

      |- INVOL inv

   [<a name="inv_Id-val"><b>inv_Id</b></a>]  Theorem

      |- inv $= = $=

   [<a name="inv_MOVES_OUT-val"><b>inv_MOVES_OUT</b></a>]  Theorem

      |- ∀R.
           (inv (inv R) = R) ∧ (SC (inv R) = SC R) ∧
           (RC (inv R) = inv (RC R)) ∧ ((inv R)⁺ = inv R⁺) ∧
           ((inv R)^* = inv R^* ) ∧ ((inv R)^= = R^=)

   [<a name="inv_O-val"><b>inv_O</b></a>]  Theorem

      |- ∀R R'. inv (R O R') = inv R' O inv R

   [<a name="inv_RC-val"><b>inv_RC</b></a>]  Theorem

      |- ∀R. inv (RC R) = RC (inv R)

   [<a name="inv_SC-val"><b>inv_SC</b></a>]  Theorem

      |- ∀R. (inv (SC R) = SC R) ∧ (SC (inv R) = SC R)

   [<a name="inv_TC-val"><b>inv_TC</b></a>]  Theorem

      |- ∀R. inv R⁺ = (inv R)⁺

   [<a name="inv_diag-val"><b>inv_diag</b></a>]  Theorem

      |- inv (diag A) = diag A

   [<a name="inv_inv-val"><b>inv_inv</b></a>]  Theorem

      |- ∀R. inv (inv R) = R

   [<a name="irrefl_trans_implies_antisym-val"><b>irrefl_trans_implies_antisym</b></a>]  Theorem

      |- ∀R. irreflexive R ∧ transitive R ⇒ antisymmetric R

   [<a name="irreflexive_RSUBSET-val"><b>irreflexive_RSUBSET</b></a>]  Theorem

      |- ∀R1 R2. irreflexive R2 ∧ R1 RSUBSET R2 ⇒ irreflexive R1

   [<a name="irreflexive_inv-val"><b>irreflexive_inv</b></a>]  Theorem

      |- ∀R. irreflexive (inv R) ⇔ irreflexive R

   [<a name="rcdiamond_diamond-val"><b>rcdiamond_diamond</b></a>]  Theorem

      |- ∀R. rcdiamond R ⇔ diamond (RC R)

   [<a name="reflexive_EQC-val"><b>reflexive_EQC</b></a>]  Theorem

      |- reflexive R^=

   [<a name="reflexive_Id_RSUBSET-val"><b>reflexive_Id_RSUBSET</b></a>]  Theorem

      |- ∀R. reflexive R ⇔ $= RSUBSET R

   [<a name="reflexive_RC-val"><b>reflexive_RC</b></a>]  Theorem

      |- ∀R. reflexive (RC R)

   [<a name="reflexive_RC_identity-val"><b>reflexive_RC_identity</b></a>]  Theorem

      |- ∀R. reflexive R ⇒ (RC R = R)

   [<a name="reflexive_RTC-val"><b>reflexive_RTC</b></a>]  Theorem

      |- ∀R. reflexive R^*

   [<a name="reflexive_TC-val"><b>reflexive_TC</b></a>]  Theorem

      |- ∀R. reflexive R ⇒ reflexive R⁺

   [<a name="reflexive_inv-val"><b>reflexive_inv</b></a>]  Theorem

      |- ∀R. reflexive (inv R) ⇔ reflexive R

   [<a name="symmetric_EQC-val"><b>symmetric_EQC</b></a>]  Theorem

      |- symmetric R^=

   [<a name="symmetric_RC-val"><b>symmetric_RC</b></a>]  Theorem

      |- ∀R. symmetric (RC R) ⇔ symmetric R

   [<a name="symmetric_SC_identity-val"><b>symmetric_SC_identity</b></a>]  Theorem

      |- ∀R. symmetric R ⇒ (SC R = R)

   [<a name="symmetric_TC-val"><b>symmetric_TC</b></a>]  Theorem

      |- ∀R. symmetric R ⇒ symmetric R⁺

   [<a name="symmetric_inv-val"><b>symmetric_inv</b></a>]  Theorem

      |- ∀R. symmetric (inv R) ⇔ symmetric R

   [<a name="symmetric_inv_RSUBSET-val"><b>symmetric_inv_RSUBSET</b></a>]  Theorem

      |- symmetric R ⇔ inv R RSUBSET R

   [<a name="symmetric_inv_identity-val"><b>symmetric_inv_identity</b></a>]  Theorem

      |- ∀R. symmetric R ⇒ (inv R = R)

   [<a name="transitive_EQC-val"><b>transitive_EQC</b></a>]  Theorem

      |- transitive R^=

   [<a name="transitive_O_RSUBSET-val"><b>transitive_O_RSUBSET</b></a>]  Theorem

      |- transitive R ⇔ R O R RSUBSET R

   [<a name="transitive_RC-val"><b>transitive_RC</b></a>]  Theorem

      |- ∀R. transitive R ⇒ transitive (RC R)

   [<a name="transitive_RINTER-val"><b>transitive_RINTER</b></a>]  Theorem

      |- transitive R1 ∧ transitive R2 ⇒ transitive (R1 RINTER R2)

   [<a name="transitive_RTC-val"><b>transitive_RTC</b></a>]  Theorem

      |- ∀R. transitive R^*

   [<a name="transitive_TC_identity-val"><b>transitive_TC_identity</b></a>]  Theorem

      |- ∀R. transitive R ⇒ (R⁺ = R)

   [<a name="transitive_inv-val"><b>transitive_inv</b></a>]  Theorem

      |- ∀R. transitive (inv R) ⇔ transitive R


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/relation/relationScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-8</a></em></p></body></html>
