<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure OmegaTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure OmegaTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/integer/OmegaScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature OmegaTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#MAP2_curried_def-val">MAP2_curried_def</a> : thm
<a name="line7"></a>    val <a href="#MAP2_tupled_primitive_def-val">MAP2_tupled_primitive_def</a> : thm
<a name="line8"></a>    val <a href="#calc_nightmare_curried_def-val">calc_nightmare_curried_def</a> : thm
<a name="line9"></a>    val <a href="#calc_nightmare_tupled_primitive_def-val">calc_nightmare_tupled_primitive_def</a> : thm
<a name="line10"></a>    val <a href="#dark_shadow_cond_row_curried_def-val">dark_shadow_cond_row_curried_def</a> : thm
<a name="line11"></a>    val <a href="#dark_shadow_cond_row_tupled_primitive_def-val">dark_shadow_cond_row_tupled_primitive_def</a> : thm
<a name="line12"></a>    val <a href="#dark_shadow_condition_curried_def-val">dark_shadow_condition_curried_def</a> : thm
<a name="line13"></a>    val <a href="#dark_shadow_condition_tupled_primitive_def-val">dark_shadow_condition_tupled_primitive_def</a> : thm
<a name="line14"></a>    val <a href="#dark_shadow_curried_def-val">dark_shadow_curried_def</a> : thm
<a name="line15"></a>    val <a href="#dark_shadow_row_curried_def-val">dark_shadow_row_curried_def</a> : thm
<a name="line16"></a>    val <a href="#dark_shadow_row_tupled_primitive_def-val">dark_shadow_row_tupled_primitive_def</a> : thm
<a name="line17"></a>    val <a href="#dark_shadow_tupled_primitive_def-val">dark_shadow_tupled_primitive_def</a> : thm
<a name="line18"></a>    val <a href="#evallower_curried_def-val">evallower_curried_def</a> : thm
<a name="line19"></a>    val <a href="#evallower_tupled_primitive_def-val">evallower_tupled_primitive_def</a> : thm
<a name="line20"></a>    val <a href="#evalupper_curried_def-val">evalupper_curried_def</a> : thm
<a name="line21"></a>    val <a href="#evalupper_tupled_primitive_def-val">evalupper_tupled_primitive_def</a> : thm
<a name="line22"></a>    val <a href="#fst1_def-val">fst1_def</a> : thm
<a name="line23"></a>    val <a href="#fst_nzero_def-val">fst_nzero_def</a> : thm
<a name="line24"></a>    val <a href="#modhat_def-val">modhat_def</a> : thm
<a name="line25"></a>    val <a href="#nightmare_curried_def-val">nightmare_curried_def</a> : thm
<a name="line26"></a>    val <a href="#nightmare_tupled_primitive_def-val">nightmare_tupled_primitive_def</a> : thm
<a name="line27"></a>    val <a href="#real_shadow_def-val">real_shadow_def</a> : thm
<a name="line28"></a>    val <a href="#rshadow_row_curried_def-val">rshadow_row_curried_def</a> : thm
<a name="line29"></a>    val <a href="#rshadow_row_tupled_primitive_def-val">rshadow_row_tupled_primitive_def</a> : thm
<a name="line30"></a>    val <a href="#sumc_curried_def-val">sumc_curried_def</a> : thm
<a name="line31"></a>    val <a href="#sumc_tupled_primitive_def-val">sumc_tupled_primitive_def</a> : thm
<a name="line32"></a>
<a name="line33"></a>  (*  Theorems  *)
<a name="line34"></a>    val <a href="#MAP2_def-val">MAP2_def</a> : thm
<a name="line35"></a>    val <a href="#MAP2_ind-val">MAP2_ind</a> : thm
<a name="line36"></a>    val <a href="#MAP2_zero_ADD-val">MAP2_zero_ADD</a> : thm
<a name="line37"></a>    val <a href="#alternative_equivalence-val">alternative_equivalence</a> : thm
<a name="line38"></a>    val <a href="#basic_shadow_equivalence-val">basic_shadow_equivalence</a> : thm
<a name="line39"></a>    val <a href="#bigger_satisfies_lowers-val">bigger_satisfies_lowers</a> : thm
<a name="line40"></a>    val <a href="#calc_nightmare_def-val">calc_nightmare_def</a> : thm
<a name="line41"></a>    val <a href="#calc_nightmare_ind-val">calc_nightmare_ind</a> : thm
<a name="line42"></a>    val <a href="#calculational_nightmare-val">calculational_nightmare</a> : thm
<a name="line43"></a>    val <a href="#dark_implies_real-val">dark_implies_real</a> : thm
<a name="line44"></a>    val <a href="#dark_shadow_FORALL-val">dark_shadow_FORALL</a> : thm
<a name="line45"></a>    val <a href="#dark_shadow_cond_row_def-val">dark_shadow_cond_row_def</a> : thm
<a name="line46"></a>    val <a href="#dark_shadow_cond_row_ind-val">dark_shadow_cond_row_ind</a> : thm
<a name="line47"></a>    val <a href="#dark_shadow_condition_def-val">dark_shadow_condition_def</a> : thm
<a name="line48"></a>    val <a href="#dark_shadow_condition_ind-val">dark_shadow_condition_ind</a> : thm
<a name="line49"></a>    val <a href="#dark_shadow_def-val">dark_shadow_def</a> : thm
<a name="line50"></a>    val <a href="#dark_shadow_ind-val">dark_shadow_ind</a> : thm
<a name="line51"></a>    val <a href="#dark_shadow_row_def-val">dark_shadow_row_def</a> : thm
<a name="line52"></a>    val <a href="#dark_shadow_row_ind-val">dark_shadow_row_ind</a> : thm
<a name="line53"></a>    val <a href="#darkrow_implies_realrow-val">darkrow_implies_realrow</a> : thm
<a name="line54"></a>    val <a href="#equality_removal-val">equality_removal</a> : thm
<a name="line55"></a>    val <a href="#eval_base-val">eval_base</a> : thm
<a name="line56"></a>    val <a href="#eval_step_extra1-val">eval_step_extra1</a> : thm
<a name="line57"></a>    val <a href="#eval_step_extra2-val">eval_step_extra2</a> : thm
<a name="line58"></a>    val <a href="#eval_step_extra3-val">eval_step_extra3</a> : thm
<a name="line59"></a>    val <a href="#eval_step_extra4-val">eval_step_extra4</a> : thm
<a name="line60"></a>    val <a href="#eval_step_lower1-val">eval_step_lower1</a> : thm
<a name="line61"></a>    val <a href="#eval_step_lower2-val">eval_step_lower2</a> : thm
<a name="line62"></a>    val <a href="#eval_step_upper1-val">eval_step_upper1</a> : thm
<a name="line63"></a>    val <a href="#eval_step_upper2-val">eval_step_upper2</a> : thm
<a name="line64"></a>    val <a href="#evallower_FORALL-val">evallower_FORALL</a> : thm
<a name="line65"></a>    val <a href="#evallower_def-val">evallower_def</a> : thm
<a name="line66"></a>    val <a href="#evallower_ind-val">evallower_ind</a> : thm
<a name="line67"></a>    val <a href="#evalupper_FORALL-val">evalupper_FORALL</a> : thm
<a name="line68"></a>    val <a href="#evalupper_def-val">evalupper_def</a> : thm
<a name="line69"></a>    val <a href="#evalupper_ind-val">evalupper_ind</a> : thm
<a name="line70"></a>    val <a href="#exact_shadow_case-val">exact_shadow_case</a> : thm
<a name="line71"></a>    val <a href="#final_equivalence-val">final_equivalence</a> : thm
<a name="line72"></a>    val <a href="#nightmare_EXISTS-val">nightmare_EXISTS</a> : thm
<a name="line73"></a>    val <a href="#nightmare_def-val">nightmare_def</a> : thm
<a name="line74"></a>    val <a href="#nightmare_implies_LHS-val">nightmare_implies_LHS</a> : thm
<a name="line75"></a>    val <a href="#nightmare_ind-val">nightmare_ind</a> : thm
<a name="line76"></a>    val <a href="#onlylowers_satisfiable-val">onlylowers_satisfiable</a> : thm
<a name="line77"></a>    val <a href="#onlyuppers_satisfiable-val">onlyuppers_satisfiable</a> : thm
<a name="line78"></a>    val <a href="#real_shadow_FORALL-val">real_shadow_FORALL</a> : thm
<a name="line79"></a>    val <a href="#real_shadow_always_implied-val">real_shadow_always_implied</a> : thm
<a name="line80"></a>    val <a href="#real_shadow_revimp_lowers1-val">real_shadow_revimp_lowers1</a> : thm
<a name="line81"></a>    val <a href="#real_shadow_revimp_uppers1-val">real_shadow_revimp_uppers1</a> : thm
<a name="line82"></a>    val <a href="#rshadow_row_def-val">rshadow_row_def</a> : thm
<a name="line83"></a>    val <a href="#rshadow_row_ind-val">rshadow_row_ind</a> : thm
<a name="line84"></a>    val <a href="#singleton_real_shadow-val">singleton_real_shadow</a> : thm
<a name="line85"></a>    val <a href="#smaller_satisfies_uppers-val">smaller_satisfies_uppers</a> : thm
<a name="line86"></a>    val <a href="#sumc_ADD-val">sumc_ADD</a> : thm
<a name="line87"></a>    val <a href="#sumc_MULT-val">sumc_MULT</a> : thm
<a name="line88"></a>    val <a href="#sumc_def-val">sumc_def</a> : thm
<a name="line89"></a>    val <a href="#sumc_ind-val">sumc_ind</a> : thm
<a name="line90"></a>    val <a href="#sumc_nonsingle-val">sumc_nonsingle</a> : thm
<a name="line91"></a>    val <a href="#sumc_singleton-val">sumc_singleton</a> : thm
<a name="line92"></a>    val <a href="#sumc_thm-val">sumc_thm</a> : thm
<a name="line93"></a>
<a name="line94"></a>  val Omega_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line95"></a>(*
   [integer] Parent theory of "Omega"

   [<a name="MAP2_curried_def-val"><b>MAP2_curried_def</b></a>]  Definition

      |- ∀x x1 x2 x3. MAP2 x x1 x2 x3 = MAP2_tupled (x,x1,x2,x3)

   [<a name="MAP2_tupled_primitive_def-val"><b>MAP2_tupled_primitive_def</b></a>]  Definition

      |- MAP2_tupled =
         WFREC
           (@R.
              WF R ∧ (∀y ys f pad. R (pad,f,[],ys) (pad,f,[],y::ys)) ∧
              (∀x xs f pad. R (pad,f,xs,[]) (pad,f,x::xs,[])) ∧
              ∀y x ys xs f pad. R (pad,f,xs,ys) (pad,f,x::xs,y::ys))
           (λMAP2_tupled a.
              case a of
                (pad,f,[],[]) =&gt; I []
              | (pad,f,[],y::ys) =&gt; I (f pad y::MAP2_tupled (pad,f,[],ys))
              | (pad,f,x::xs,[]) =&gt; I (f x pad::MAP2_tupled (pad,f,xs,[]))
              | (pad,f,x::xs,y'::ys') =&gt;
                  I (f x y'::MAP2_tupled (pad,f,xs,ys')))

   [<a name="calc_nightmare_curried_def-val"><b>calc_nightmare_curried_def</b></a>]  Definition

      |- ∀x x1 x2. calc_nightmare x x1 x2 ⇔ calc_nightmare_tupled (x,x1,x2)

   [<a name="calc_nightmare_tupled_primitive_def-val"><b>calc_nightmare_tupled_primitive_def</b></a>]  Definition

      |- calc_nightmare_tupled =
         WFREC (@R'. WF R' ∧ ∀R d rs c x. R' (x,c,rs) (x,c,(d,R)::rs))
           (λcalc_nightmare_tupled a.
              case a of
                (x,c,[]) =&gt; I F
              | (x,c,(d,R)::rs) =&gt;
                  I
                    ((∃i.
                        (0 ≤ i ∧ i ≤ (&c * &d − &c − &d) / &c) ∧
                        (&d * x = R + i)) ∨
                     calc_nightmare_tupled (x,c,rs)))

   [<a name="dark_shadow_cond_row_curried_def-val"><b>dark_shadow_cond_row_curried_def</b></a>]  Definition

      |- ∀x x1.
           dark_shadow_cond_row x x1 ⇔ dark_shadow_cond_row_tupled (x,x1)

   [<a name="dark_shadow_cond_row_tupled_primitive_def-val"><b>dark_shadow_cond_row_tupled_primitive_def</b></a>]  Definition

      |- dark_shadow_cond_row_tupled =
         WFREC (@R'. WF R' ∧ ∀R d t L c. R' ((c,L),t) ((c,L),(d,R)::t))
           (λdark_shadow_cond_row_tupled a.
              case a of
                ((c,L),[]) =&gt; I T
              | ((c,L),(d,R)::t) =&gt;
                  I
                    (¬(∃i.
                         &c * &d * i &lt; &c * R ∧ &c * R ≤ &d * L ∧
                         &d * L &lt; &c * &d * (i + 1)) ∧
                     dark_shadow_cond_row_tupled ((c,L),t)))

   [<a name="dark_shadow_condition_curried_def-val"><b>dark_shadow_condition_curried_def</b></a>]  Definition

      |- ∀x x1.
           dark_shadow_condition x x1 ⇔ dark_shadow_condition_tupled (x,x1)

   [<a name="dark_shadow_condition_tupled_primitive_def-val"><b>dark_shadow_condition_tupled_primitive_def</b></a>]  Definition

      |- dark_shadow_condition_tupled =
         WFREC
           (@R.
              WF R ∧
              ∀L c lowers uppers. R (uppers,lowers) ((c,L)::uppers,lowers))
           (λdark_shadow_condition_tupled a.
              case a of
                ([],lowers) =&gt; I T
              | ((c,L)::uppers,lowers) =&gt;
                  I
                    (dark_shadow_cond_row (c,L) lowers ∧
                     dark_shadow_condition_tupled (uppers,lowers)))

   [<a name="dark_shadow_curried_def-val"><b>dark_shadow_curried_def</b></a>]  Definition

      |- ∀x x1. dark_shadow x x1 ⇔ dark_shadow_tupled (x,x1)

   [<a name="dark_shadow_row_curried_def-val"><b>dark_shadow_row_curried_def</b></a>]  Definition

      |- ∀x x1 x2.
           dark_shadow_row x x1 x2 ⇔ dark_shadow_row_tupled (x,x1,x2)

   [<a name="dark_shadow_row_tupled_primitive_def-val"><b>dark_shadow_row_tupled_primitive_def</b></a>]  Definition

      |- dark_shadow_row_tupled =
         WFREC (@R'. WF R' ∧ ∀R d rs L c. R' (c,L,rs) (c,L,(d,R)::rs))
           (λdark_shadow_row_tupled a.
              case a of
                (c,L,[]) =&gt; I T
              | (c,L,(d,R)::rs) =&gt;
                  I
                    (&d * L − &c * R ≥ (&c − 1) * (&d − 1) ∧
                     dark_shadow_row_tupled (c,L,rs)))

   [<a name="dark_shadow_tupled_primitive_def-val"><b>dark_shadow_tupled_primitive_def</b></a>]  Definition

      |- dark_shadow_tupled =
         WFREC
           (@R.
              WF R ∧
              ∀L c lowers uppers. R (uppers,lowers) ((c,L)::uppers,lowers))
           (λdark_shadow_tupled a.
              case a of
                ([],lowers) =&gt; I T
              | ((c,L)::uppers,lowers) =&gt;
                  I
                    (dark_shadow_row c L lowers ∧
                     dark_shadow_tupled (uppers,lowers)))

   [<a name="evallower_curried_def-val"><b>evallower_curried_def</b></a>]  Definition

      |- ∀x x1. evallower x x1 ⇔ evallower_tupled (x,x1)

   [<a name="evallower_tupled_primitive_def-val"><b>evallower_tupled_primitive_def</b></a>]  Definition

      |- evallower_tupled =
         WFREC (@R. WF R ∧ ∀y c cs x. R (x,cs) (x,(c,y)::cs))
           (λevallower_tupled a.
              case a of
                (x,[]) =&gt; I T
              | (x,(c,y)::cs) =&gt; I (y ≤ &c * x ∧ evallower_tupled (x,cs)))

   [<a name="evalupper_curried_def-val"><b>evalupper_curried_def</b></a>]  Definition

      |- ∀x x1. evalupper x x1 ⇔ evalupper_tupled (x,x1)

   [<a name="evalupper_tupled_primitive_def-val"><b>evalupper_tupled_primitive_def</b></a>]  Definition

      |- evalupper_tupled =
         WFREC (@R. WF R ∧ ∀y c cs x. R (x,cs) (x,(c,y)::cs))
           (λevalupper_tupled a.
              case a of
                (x,[]) =&gt; I T
              | (x,(c,y)::cs) =&gt; I (&c * x ≤ y ∧ evalupper_tupled (x,cs)))

   [<a name="fst1_def-val"><b>fst1_def</b></a>]  Definition

      |- ∀x. fst1 x ⇔ (FST x = 1)

   [<a name="fst_nzero_def-val"><b>fst_nzero_def</b></a>]  Definition

      |- ∀x. fst_nzero x ⇔ 0 &lt; FST x

   [<a name="modhat_def-val"><b>modhat_def</b></a>]  Definition

      |- ∀x y. modhat x y = x − y * ((2 * x + y) / (2 * y))

   [<a name="nightmare_curried_def-val"><b>nightmare_curried_def</b></a>]  Definition

      |- ∀x x1 x2 x3 x4.
           nightmare x x1 x2 x3 x4 ⇔ nightmare_tupled (x,x1,x2,x3,x4)

   [<a name="nightmare_tupled_primitive_def-val"><b>nightmare_tupled_primitive_def</b></a>]  Definition

      |- nightmare_tupled =
         WFREC
           (@R'.
              WF R' ∧
              ∀R d rs lowers uppers c x.
                R' (x,c,uppers,lowers,rs) (x,c,uppers,lowers,(d,R)::rs))
           (λnightmare_tupled a.
              case a of
                (x,c,uppers,lowers,[]) =&gt; I F
              | (x,c,uppers,lowers,(d,R)::rs) =&gt;
                  I
                    ((∃i.
                        (0 ≤ i ∧ i ≤ (&c * &d − &c − &d) / &c) ∧
                        (&d * x = R + i) ∧ evalupper x uppers ∧
                        evallower x lowers) ∨
                     nightmare_tupled (x,c,uppers,lowers,rs)))

   [<a name="real_shadow_def-val"><b>real_shadow_def</b></a>]  Definition

      |- (∀lowers. real_shadow [] lowers ⇔ T) ∧
         ∀upper ls lowers.
           real_shadow (upper::ls) lowers ⇔
           rshadow_row upper lowers ∧ real_shadow ls lowers

   [<a name="rshadow_row_curried_def-val"><b>rshadow_row_curried_def</b></a>]  Definition

      |- ∀x x1. rshadow_row x x1 ⇔ rshadow_row_tupled (x,x1)

   [<a name="rshadow_row_tupled_primitive_def-val"><b>rshadow_row_tupled_primitive_def</b></a>]  Definition

      |- rshadow_row_tupled =
         WFREC
           (@R.
              WF R ∧
              ∀lowery lowerc rs uppery upperc.
                R ((upperc,uppery),rs)
                  ((upperc,uppery),(lowerc,lowery)::rs))
           (λrshadow_row_tupled a.
              case a of
                ((upperc,uppery),[]) =&gt; I T
              | ((upperc,uppery),(lowerc,lowery)::rs) =&gt;
                  I
                    (&upperc * lowery ≤ &lowerc * uppery ∧
                     rshadow_row_tupled ((upperc,uppery),rs)))

   [<a name="sumc_curried_def-val"><b>sumc_curried_def</b></a>]  Definition

      |- ∀x x1. sumc x x1 = sumc_tupled (x,x1)

   [<a name="sumc_tupled_primitive_def-val"><b>sumc_tupled_primitive_def</b></a>]  Definition

      |- sumc_tupled =
         WFREC (@R. WF R ∧ ∀v c vs cs. R (cs,vs) (c::cs,v::vs))
           (λsumc_tupled a.
              case a of
                ([],[]) =&gt; I 0
              | ([],v10::v11) =&gt; I 0
              | (c::cs,[]) =&gt; I 0
              | (c::cs,v::vs) =&gt; I (c * v + sumc_tupled (cs,vs)))

   [<a name="MAP2_def-val"><b>MAP2_def</b></a>]  Theorem

      |- (∀pad f. MAP2 pad f [] [] = []) ∧
         (∀ys y pad f. MAP2 pad f [] (y::ys) = f pad y::MAP2 pad f [] ys) ∧
         (∀xs x pad f. MAP2 pad f (x::xs) [] = f x pad::MAP2 pad f xs []) ∧
         ∀ys y xs x pad f.
           MAP2 pad f (x::xs) (y::ys) = f x y::MAP2 pad f xs ys

   [<a name="MAP2_ind-val"><b>MAP2_ind</b></a>]  Theorem

      |- ∀P.
           (∀pad f. P pad f [] []) ∧
           (∀pad f y ys. P pad f [] ys ⇒ P pad f [] (y::ys)) ∧
           (∀pad f x xs. P pad f xs [] ⇒ P pad f (x::xs) []) ∧
           (∀pad f x xs y ys. P pad f xs ys ⇒ P pad f (x::xs) (y::ys)) ⇒
           ∀v v1 v2 v3. P v v1 v2 v3

   [<a name="MAP2_zero_ADD-val"><b>MAP2_zero_ADD</b></a>]  Theorem

      |- ∀xs. (MAP2 0 $+ [] xs = xs) ∧ (MAP2 0 $+ xs [] = xs)

   [<a name="alternative_equivalence-val"><b>alternative_equivalence</b></a>]  Theorem

      |- ∀uppers lowers m.
           EVERY fst_nzero uppers ∧ EVERY fst_nzero lowers ∧
           EVERY (λp. FST p ≤ m) uppers ⇒
           ((∃x. evalupper x uppers ∧ evallower x lowers) ⇔
            dark_shadow uppers lowers ∨
            ∃x. nightmare x m uppers lowers lowers)

   [<a name="basic_shadow_equivalence-val"><b>basic_shadow_equivalence</b></a>]  Theorem

      |- ∀uppers lowers.
           EVERY fst_nzero uppers ∧ EVERY fst_nzero lowers ⇒
           ((∃x. evalupper x uppers ∧ evallower x lowers) ⇔
            real_shadow uppers lowers ∧
            dark_shadow_condition uppers lowers)

   [<a name="bigger_satisfies_lowers-val"><b>bigger_satisfies_lowers</b></a>]  Theorem

      |- ∀lowers x y. evallower x lowers ∧ x &lt; y ⇒ evallower y lowers

   [<a name="calc_nightmare_def-val"><b>calc_nightmare_def</b></a>]  Theorem

      |- (∀x c. calc_nightmare x c [] ⇔ F) ∧
         ∀x rs d c R.
           calc_nightmare x c ((d,R)::rs) ⇔
           (∃i.
              (0 ≤ i ∧ i ≤ (&c * &d − &c − &d) / &c) ∧ (&d * x = R + i)) ∨
           calc_nightmare x c rs

   [<a name="calc_nightmare_ind-val"><b>calc_nightmare_ind</b></a>]  Theorem

      |- ∀P.
           (∀x c. P x c []) ∧ (∀x c d R rs. P x c rs ⇒ P x c ((d,R)::rs)) ⇒
           ∀v v1 v2. P v v1 v2

   [<a name="calculational_nightmare-val"><b>calculational_nightmare</b></a>]  Theorem

      |- ∀rs.
           nightmare x c uppers lowers rs ⇔
           calc_nightmare x c rs ∧ evalupper x uppers ∧ evallower x lowers

   [<a name="dark_implies_real-val"><b>dark_implies_real</b></a>]  Theorem

      |- ∀uppers lowers.
           EVERY fst_nzero uppers ∧ EVERY fst_nzero lowers ∧
           dark_shadow uppers lowers ⇒
           real_shadow uppers lowers

   [<a name="dark_shadow_FORALL-val"><b>dark_shadow_FORALL</b></a>]  Theorem

      |- ∀uppers lowers.
           dark_shadow uppers lowers ⇔
           ∀c d L R.
             MEM (c,L) uppers ∧ MEM (d,R) lowers ⇒
             &d * L − &c * R ≥ (&c − 1) * (&d − 1)

   [<a name="dark_shadow_cond_row_def-val"><b>dark_shadow_cond_row_def</b></a>]  Theorem

      |- (∀c L. dark_shadow_cond_row (c,L) [] ⇔ T) ∧
         ∀t d c R L.
           dark_shadow_cond_row (c,L) ((d,R)::t) ⇔
           ¬(∃i.
               &c * &d * i &lt; &c * R ∧ &c * R ≤ &d * L ∧
               &d * L &lt; &c * &d * (i + 1)) ∧ dark_shadow_cond_row (c,L) t

   [<a name="dark_shadow_cond_row_ind-val"><b>dark_shadow_cond_row_ind</b></a>]  Theorem

      |- ∀P.
           (∀c L. P (c,L) []) ∧
           (∀c L d R t. P (c,L) t ⇒ P (c,L) ((d,R)::t)) ⇒
           ∀v v1 v2. P (v,v1) v2

   [<a name="dark_shadow_condition_def-val"><b>dark_shadow_condition_def</b></a>]  Theorem

      |- (∀lowers. dark_shadow_condition [] lowers ⇔ T) ∧
         ∀uppers lowers c L.
           dark_shadow_condition ((c,L)::uppers) lowers ⇔
           dark_shadow_cond_row (c,L) lowers ∧
           dark_shadow_condition uppers lowers

   [<a name="dark_shadow_condition_ind-val"><b>dark_shadow_condition_ind</b></a>]  Theorem

      |- ∀P.
           (∀lowers. P [] lowers) ∧
           (∀c L uppers lowers.
              P uppers lowers ⇒ P ((c,L)::uppers) lowers) ⇒
           ∀v v1. P v v1

   [<a name="dark_shadow_def-val"><b>dark_shadow_def</b></a>]  Theorem

      |- (∀lowers. dark_shadow [] lowers ⇔ T) ∧
         ∀uppers lowers c L.
           dark_shadow ((c,L)::uppers) lowers ⇔
           dark_shadow_row c L lowers ∧ dark_shadow uppers lowers

   [<a name="dark_shadow_ind-val"><b>dark_shadow_ind</b></a>]  Theorem

      |- ∀P.
           (∀lowers. P [] lowers) ∧
           (∀c L uppers lowers.
              P uppers lowers ⇒ P ((c,L)::uppers) lowers) ⇒
           ∀v v1. P v v1

   [<a name="dark_shadow_row_def-val"><b>dark_shadow_row_def</b></a>]  Theorem

      |- (∀c L. dark_shadow_row c L [] ⇔ T) ∧
         ∀rs d c R L.
           dark_shadow_row c L ((d,R)::rs) ⇔
           &d * L − &c * R ≥ (&c − 1) * (&d − 1) ∧ dark_shadow_row c L rs

   [<a name="dark_shadow_row_ind-val"><b>dark_shadow_row_ind</b></a>]  Theorem

      |- ∀P.
           (∀c L. P c L []) ∧ (∀c L d R rs. P c L rs ⇒ P c L ((d,R)::rs)) ⇒
           ∀v v1 v2. P v v1 v2

   [<a name="darkrow_implies_realrow-val"><b>darkrow_implies_realrow</b></a>]  Theorem

      |- ∀lowers c L.
           0 &lt; c ∧ EVERY fst_nzero lowers ∧ dark_shadow_row c L lowers ⇒
           rshadow_row (c,L) lowers

   [<a name="equality_removal-val"><b>equality_removal</b></a>]  Theorem

      |- ∀c x cs vs.
           0 &lt; c ⇒
           ((0 = c * x + sumc cs vs) ⇔
            ∃s.
              (x =
               -(c + 1) * s + sumc (MAP (λx. modhat x (c + 1)) cs) vs) ∧
              (0 = c * x + sumc cs vs))

   [<a name="eval_base-val"><b>eval_base</b></a>]  Theorem

      |- p ⇔ ((evalupper x [] ∧ evallower x []) ∧ T) ∧ p

   [<a name="eval_step_extra1-val"><b>eval_step_extra1</b></a>]  Theorem

      |- ((evalupper x ups ∧ evallower x lows) ∧ T) ∧ ex' ⇔
         (evalupper x ups ∧ evallower x lows) ∧ ex'

   [<a name="eval_step_extra2-val"><b>eval_step_extra2</b></a>]  Theorem

      |- ((evalupper x ups ∧ evallower x lows) ∧ ex) ∧ ex' ⇔
         (evalupper x ups ∧ evallower x lows) ∧ ex ∧ ex'

   [<a name="eval_step_extra3-val"><b>eval_step_extra3</b></a>]  Theorem

      |- ((evalupper x ups ∧ evallower x lows) ∧ T) ∧ ex' ∧ p ⇔
         ((evalupper x ups ∧ evallower x lows) ∧ ex') ∧ p

   [<a name="eval_step_extra4-val"><b>eval_step_extra4</b></a>]  Theorem

      |- ((evalupper x ups ∧ evallower x lows) ∧ ex) ∧ ex' ∧ p ⇔
         ((evalupper x ups ∧ evallower x lows) ∧ ex ∧ ex') ∧ p

   [<a name="eval_step_lower1-val"><b>eval_step_lower1</b></a>]  Theorem

      |- ((evalupper x ups ∧ evallower x lows) ∧ ex) ∧ r ≤ &c * x ⇔
         (evalupper x ups ∧ evallower x ((c,r)::lows)) ∧ ex

   [<a name="eval_step_lower2-val"><b>eval_step_lower2</b></a>]  Theorem

      |- ((evalupper x ups ∧ evallower x lows) ∧ ex) ∧ r ≤ &c * x ∧ p ⇔
         ((evalupper x ups ∧ evallower x ((c,r)::lows)) ∧ ex) ∧ p

   [<a name="eval_step_upper1-val"><b>eval_step_upper1</b></a>]  Theorem

      |- ((evalupper x ups ∧ evallower x lows) ∧ ex) ∧ &c * x ≤ r ⇔
         (evalupper x ((c,r)::ups) ∧ evallower x lows) ∧ ex

   [<a name="eval_step_upper2-val"><b>eval_step_upper2</b></a>]  Theorem

      |- ((evalupper x ups ∧ evallower x lows) ∧ ex) ∧ &c * x ≤ r ∧ p ⇔
         ((evalupper x ((c,r)::ups) ∧ evallower x lows) ∧ ex) ∧ p

   [<a name="evallower_FORALL-val"><b>evallower_FORALL</b></a>]  Theorem

      |- ∀lowers x.
           evallower x lowers ⇔ ∀d R. MEM (d,R) lowers ⇒ R ≤ &d * x

   [<a name="evallower_def-val"><b>evallower_def</b></a>]  Theorem

      |- (∀x. evallower x [] ⇔ T) ∧
         ∀y x cs c. evallower x ((c,y)::cs) ⇔ y ≤ &c * x ∧ evallower x cs

   [<a name="evallower_ind-val"><b>evallower_ind</b></a>]  Theorem

      |- ∀P.
           (∀x. P x []) ∧ (∀x c y cs. P x cs ⇒ P x ((c,y)::cs)) ⇒
           ∀v v1. P v v1

   [<a name="evalupper_FORALL-val"><b>evalupper_FORALL</b></a>]  Theorem

      |- ∀uppers x.
           evalupper x uppers ⇔ ∀c L. MEM (c,L) uppers ⇒ &c * x ≤ L

   [<a name="evalupper_def-val"><b>evalupper_def</b></a>]  Theorem

      |- (∀x. evalupper x [] ⇔ T) ∧
         ∀y x cs c. evalupper x ((c,y)::cs) ⇔ &c * x ≤ y ∧ evalupper x cs

   [<a name="evalupper_ind-val"><b>evalupper_ind</b></a>]  Theorem

      |- ∀P.
           (∀x. P x []) ∧ (∀x c y cs. P x cs ⇒ P x ((c,y)::cs)) ⇒
           ∀v v1. P v v1

   [<a name="exact_shadow_case-val"><b>exact_shadow_case</b></a>]  Theorem

      |- ∀uppers lowers.
           EVERY fst_nzero uppers ∧ EVERY fst_nzero lowers ⇒
           EVERY fst1 uppers ∨ EVERY fst1 lowers ⇒
           ((∃x. evalupper x uppers ∧ evallower x lowers) ⇔
            real_shadow uppers lowers)

   [<a name="final_equivalence-val"><b>final_equivalence</b></a>]  Theorem

      |- ∀uppers lowers m.
           EVERY fst_nzero uppers ∧ EVERY fst_nzero lowers ∧
           EVERY (λp. FST p ≤ m) uppers ⇒
           ((∃x. evalupper x uppers ∧ evallower x lowers) ⇔
            real_shadow uppers lowers ∧
            (dark_shadow uppers lowers ∨
             ∃x. nightmare x m uppers lowers lowers))

   [<a name="nightmare_EXISTS-val"><b>nightmare_EXISTS</b></a>]  Theorem

      |- ∀rs x c uppers lowers.
           nightmare x c uppers lowers rs ⇔
           ∃i d R.
             0 ≤ i ∧ i ≤ (&d * &c − &c − &d) / &c ∧ MEM (d,R) rs ∧
             evalupper x uppers ∧ evallower x lowers ∧ (&d * x = R + i)

   [<a name="nightmare_def-val"><b>nightmare_def</b></a>]  Theorem

      |- (∀x uppers lowers c. nightmare x c uppers lowers [] ⇔ F) ∧
         ∀x uppers rs lowers d c R.
           nightmare x c uppers lowers ((d,R)::rs) ⇔
           (∃i.
              (0 ≤ i ∧ i ≤ (&c * &d − &c − &d) / &c) ∧ (&d * x = R + i) ∧
              evalupper x uppers ∧ evallower x lowers) ∨
           nightmare x c uppers lowers rs

   [<a name="nightmare_implies_LHS-val"><b>nightmare_implies_LHS</b></a>]  Theorem

      |- ∀rs x uppers lowers c.
           nightmare x c uppers lowers rs ⇒
           evalupper x uppers ∧ evallower x lowers

   [<a name="nightmare_ind-val"><b>nightmare_ind</b></a>]  Theorem

      |- ∀P.
           (∀x c uppers lowers. P x c uppers lowers []) ∧
           (∀x c uppers lowers d R rs.
              P x c uppers lowers rs ⇒ P x c uppers lowers ((d,R)::rs)) ⇒
           ∀v v1 v2 v3 v4. P v v1 v2 v3 v4

   [<a name="onlylowers_satisfiable-val"><b>onlylowers_satisfiable</b></a>]  Theorem

      |- ∀lowers. EVERY fst_nzero lowers ⇒ ∃x. evallower x lowers

   [<a name="onlyuppers_satisfiable-val"><b>onlyuppers_satisfiable</b></a>]  Theorem

      |- ∀uppers. EVERY fst_nzero uppers ⇒ ∃x. evalupper x uppers

   [<a name="real_shadow_FORALL-val"><b>real_shadow_FORALL</b></a>]  Theorem

      |- ∀uppers lowers.
           real_shadow uppers lowers ⇔
           ∀c d L R. MEM (c,L) uppers ∧ MEM (d,R) lowers ⇒ &c * R ≤ &d * L

   [<a name="real_shadow_always_implied-val"><b>real_shadow_always_implied</b></a>]  Theorem

      |- ∀uppers lowers x.
           evalupper x uppers ∧ evallower x lowers ∧
           EVERY fst_nzero uppers ∧ EVERY fst_nzero lowers ⇒
           real_shadow uppers lowers

   [<a name="real_shadow_revimp_lowers1-val"><b>real_shadow_revimp_lowers1</b></a>]  Theorem

      |- ∀uppers lowers c L x.
           0 &lt; c ∧ rshadow_row (c,L) lowers ∧ evalupper x uppers ∧
           evallower x lowers ∧ EVERY fst_nzero uppers ∧
           EVERY fst1 lowers ⇒
           ∃x. &c * x ≤ L ∧ evalupper x uppers ∧ evallower x lowers

   [<a name="real_shadow_revimp_uppers1-val"><b>real_shadow_revimp_uppers1</b></a>]  Theorem

      |- ∀uppers lowers L x.
           rshadow_row (1,L) lowers ∧ evallower x lowers ∧
           evalupper x uppers ∧ EVERY fst_nzero lowers ∧
           EVERY fst1 uppers ⇒
           ∃x. x ≤ L ∧ evalupper x uppers ∧ evallower x lowers

   [<a name="rshadow_row_def-val"><b>rshadow_row_def</b></a>]  Theorem

      |- (∀uppery upperc. rshadow_row (upperc,uppery) [] ⇔ T) ∧
         ∀uppery upperc rs lowery lowerc.
           rshadow_row (upperc,uppery) ((lowerc,lowery)::rs) ⇔
           &upperc * lowery ≤ &lowerc * uppery ∧
           rshadow_row (upperc,uppery) rs

   [<a name="rshadow_row_ind-val"><b>rshadow_row_ind</b></a>]  Theorem

      |- ∀P.
           (∀upperc uppery. P (upperc,uppery) []) ∧
           (∀upperc uppery lowerc lowery rs.
              P (upperc,uppery) rs ⇒
              P (upperc,uppery) ((lowerc,lowery)::rs)) ⇒
           ∀v v1 v2. P (v,v1) v2

   [<a name="singleton_real_shadow-val"><b>singleton_real_shadow</b></a>]  Theorem

      |- ∀c L x.
           &c * x ≤ L ∧ 0 &lt; c ⇒
           ∀lowers.
             EVERY fst_nzero lowers ∧ evallower x lowers ⇒
             rshadow_row (c,L) lowers

   [<a name="smaller_satisfies_uppers-val"><b>smaller_satisfies_uppers</b></a>]  Theorem

      |- ∀uppers x y. evalupper x uppers ∧ y &lt; x ⇒ evalupper y uppers

   [<a name="sumc_ADD-val"><b>sumc_ADD</b></a>]  Theorem

      |- ∀cs vs ds. sumc cs vs + sumc ds vs = sumc (MAP2 0 $+ cs ds) vs

   [<a name="sumc_MULT-val"><b>sumc_MULT</b></a>]  Theorem

      |- ∀cs vs f. f * sumc cs vs = sumc (MAP (λx. f * x) cs) vs

   [<a name="sumc_def-val"><b>sumc_def</b></a>]  Theorem

      |- (sumc [] [] = 0) ∧ (∀v5 v4. sumc (v4::v5) [] = 0) ∧
         (∀v9 v8. sumc [] (v8::v9) = 0) ∧
         ∀vs v cs c. sumc (c::cs) (v::vs) = c * v + sumc cs vs

   [<a name="sumc_ind-val"><b>sumc_ind</b></a>]  Theorem

      |- ∀P.
           P [] [] ∧ (∀v4 v5. P (v4::v5) []) ∧ (∀v8 v9. P [] (v8::v9)) ∧
           (∀c cs v vs. P cs vs ⇒ P (c::cs) (v::vs)) ⇒
           ∀v v1. P v v1

   [<a name="sumc_nonsingle-val"><b>sumc_nonsingle</b></a>]  Theorem

      |- ∀f cs c v vs.
           sumc (MAP f (c::cs)) (v::vs) = f c * v + sumc (MAP f cs) vs

   [<a name="sumc_singleton-val"><b>sumc_singleton</b></a>]  Theorem

      |- ∀f c. sumc (MAP f [c]) [1] = f c

   [<a name="sumc_thm-val"><b>sumc_thm</b></a>]  Theorem

      |- ∀cs vs c v.
           (sumc [] vs = 0) ∧ (sumc cs [] = 0) ∧
           (sumc (c::cs) (v::vs) = c * v + sumc cs vs)


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/integer/OmegaScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-8</a></em></p></body></html>
