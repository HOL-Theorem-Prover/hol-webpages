<!DOCTYPE HTML PUBLIC "-//W32//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML>
<HEAD>
<meta http-equiv="content-type" content="text/html ; charset=US-ASCII">
<TITLE>bossLib.SPOSE_NOT_THEN</TITLE>
<LINK REL = "STYLESHEET" HREF = "../doc.css" TYPE = "text/css"></HEAD>
<BODY>

<DIV class = "TYPE"><PRE>SPOSE_NOT_THEN : (thm -&gt; tactic) -&gt; tactic</PRE></DIV>

<DL>
<DT><SPAN class = "FIELD-NAME">STRUCTURE</SPAN></DT>
<DD><DIV class = "FIELD-BODY"><A HREF = "../../src-sml/htmlsigs/bossLib.html">bossLib</A></DIV></DD>
<DT><SPAN class = "FIELD-NAME">SYNOPSIS</SPAN></DT>
<DD><DIV class = "FIELD-BODY"><SPAN class = "TEXT">Initiate proof by contradiction.</SPAN></DIV></DD>
<DT><SPAN class = "FIELD-NAME">DESCRIPTION</SPAN></DT>
<DD><DIV class = "FIELD-BODY"><SPAN class = "TEXT"></SPAN><SPAN class = "BRKT">SPOSE_NOT_THEN</SPAN><SPAN class = "TEXT"> provides a flexible way to start a proof by contradiction.
Simple tactics for contradiction proofs often simply negate the goal and
place it on the assumption list. However, if the goal is quantified, as
is often the case, then more processing is required in order to get it
into a suitable form for subsequent work. </SPAN><SPAN class = "BRKT">SPOSE_NOT_THEN&nbsp;ttac</SPAN><SPAN class = "TEXT"> negates
the current goal, pushes the negation inwards, and applies </SPAN><SPAN class = "BRKT">ttac</SPAN><SPAN class = "TEXT"> to it.</SPAN></DIV></DD>
<DT><SPAN class = "FIELD-NAME">FAILURE</SPAN></DT>
<DD><DIV class = "FIELD-BODY"><SPAN class = "TEXT">Never fails, unless </SPAN><SPAN class = "BRKT">ttac</SPAN><SPAN class = "TEXT"> fails.</SPAN></DIV></DD>
<DT><SPAN class = "FIELD-NAME">EXAMPLE</SPAN></DT>
<DD><DIV class = "FIELD-BODY"><SPAN class = "TEXT">Suppose we want to prove Euclid&rsquo;s theorem. 
</SPAN><DIV class = "XMPL"><pre>
   !m. ?n. prime n /\ m &lt; n
</pre></DIV>
<SPAN class = "TEXT">
The classic proof is by contradiction. However, if we start such a
proof with </SPAN><SPAN class = "BRKT">CCONTR_TAC</SPAN><SPAN class = "TEXT">, we get the goal
</SPAN><DIV class = "XMPL"><pre>
   { ~!m. ?n. prime n /\ m &lt; n } ?- F
</pre></DIV>
<SPAN class = "TEXT">
and one would immediately want to simplify the assumption, which is a
bit awkward. Instead, an invocation </SPAN><SPAN class = "BRKT">SPOSE_NOT_THEN&nbsp;ASSUME_TAC</SPAN><SPAN class = "TEXT"> yields
</SPAN><DIV class = "XMPL"><pre>
   { ?m. !n. ~prime n \/ ~(m &lt; n) } ?- F
</pre></DIV>
<SPAN class = "TEXT">
and </SPAN><SPAN class = "BRKT">SPOSE_NOT_THEN&nbsp;STRIP_ASSUME_TAC</SPAN><SPAN class = "TEXT"> results in
</SPAN><DIV class = "XMPL"><pre>
   { !n. ~prime n \/ ~(m &lt; n) } ?- F
</pre></DIV>
</DIV></DD>
<dt><span class = "FIELD-NAME">SEEALSO</span></dt>
<dd><div class = "FIELD-BODY"><A HREF = "Tactic.CCONTR_TAC.html">CCONTR_TAC</A>,
<A HREF = "Tactic.CONTR_TAC.html">CONTR_TAC</A>,
<A HREF = "Tactic.ASSUME_TAC.html">ASSUME_TAC</A>,
<A HREF = "Tactic.STRIP_ASSUME_TAC.html">STRIP_ASSUME_TAC</A></div></dd>
</DL>

<div class = "HOL"><A HREF="http://hol.sourceforge.net">HOL</A>&nbsp;&nbsp;Kananaskis-8</div></BODY></HTML>
