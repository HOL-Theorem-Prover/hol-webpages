<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: rich_list</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "rich_list"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "listTheory.html"><span class="strong">list</span></a>

<h1>Signature</h1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr>
    <th>
    Constant
    <th>
    Type<tr><td> <span class="strong">AND_EL</span> <td> :bitstring -> bool
    <tr><td>
        <span class="strong">BUTLASTN</span>
        <td>
        :num -> α list -> α list
    <tr><td> <span class="strong">COUNT_LIST</span> <td> :num -> num list
    <tr><td>
        <span class="strong">COUNT_LIST_AUX</span>
        <td>
        :num -> num list -> num list
    <tr><td> <span class="strong">ELL</span> <td> :num -> α list -> α
    <tr><td>
        <span class="strong">IS_SUBLIST</span>
        <td>
        :α list -> α list -> bool
    <tr><td>
        <span class="strong">IS_SUFFIX</span>
        <td>
        :α list -> α list -> bool
    <tr><td> <span class="strong">LASTN</span> <td> :num -> α list -> α list
    <tr><td>
        <span class="strong">LIST_ELEM_COUNT</span>
        <td>
        :α -> α list -> num
    <tr><td> <span class="strong">OR_EL</span> <td> :bitstring -> bool
    <tr><td>
        <span class="strong">PREFIX</span>
        <td>
        :(α -> bool) -> α list -> α list
    <tr><td>
        <span class="strong">REPLACE_ELEMENT</span>
        <td>
        :α -> num -> α list -> α list
    <tr><td> <span class="strong">REPLICATE</span> <td> :num -> α -> α list
    <tr><td>
        <span class="strong">SCANL</span>
        <td>
        :(β -> α -> β) -> β -> α list -> β list
    <tr><td>
        <span class="strong">SCANR</span>
        <td>
        :(α -> β -> β) -> β -> α list -> β list
    <tr><td>
        <span class="strong">SEG</span>
        <td>
        :num -> num -> α list -> α list
    <tr><td>
        <span class="strong">SPLITP</span>
        <td>
        :(α -> bool) -> α list -> α list # α list
    <tr><td>
        <span class="strong">SPLITP_AUX</span>
        <td>
        :α list -> (α -> bool) -> α list -> α list # α list
    <tr><td>
        <span class="strong">SUFFIX</span>
        <td>
        :(α -> bool) -> α list -> α list
    <tr><td>
        <span class="strong">UNZIP_FST</span>
        <td>
        :(α, β) alist -> α list
    <tr><td>
        <span class="strong">UNZIP_SND</span>
        <td>
        :(β, α) alist -> α list

</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">ELL</span>
<DD>
<pre>
|- (∀l. ELL 0 l = LAST l) ∧ ∀n l. ELL (SUC n) l = ELL n (FRONT l)
</pre>

<DT><span class="strong">REPLICATE</span>
<DD>
<pre>
|- (∀x. REPLICATE 0 x = []) ∧ ∀n x. REPLICATE (SUC n) x = x::REPLICATE n x
</pre>

<DT><span class="strong">SCANL</span>
<DD>
<pre>
|- (∀f e. SCANL f e [] = [e]) ∧
   ∀f e x l. SCANL f e (x::l) = e::SCANL f (f e x) l
</pre>

<DT><span class="strong">SCANR</span>
<DD>
<pre>
|- (∀f e. SCANR f e [] = [e]) ∧
   ∀f e x l. SCANR f e (x::l) = f x (HD (SCANR f e l))::SCANR f e l
</pre>

<DT><span class="strong">SPLITP</span>
<DD>
<pre>
|- (∀P. SPLITP P [] = ([],[])) ∧
   ∀P x l.
     SPLITP P (x::l) =
     if P x then ([],x::l) else (x::FST (SPLITP P l),SND (SPLITP P l))
</pre>

<DT><span class="strong">SPLITP_AUX_def</span>
<DD>
<pre>
|- (∀acc P. SPLITP_AUX acc P [] = (acc,[])) ∧
   ∀acc P h t.
     SPLITP_AUX acc P (h::t) =
     if P h then (acc,h::t) else SPLITP_AUX (acc ++ [h]) P t
</pre>

<DT><span class="strong">PREFIX_DEF</span>
<DD>
<pre>
|- ∀P l. PREFIX P l = FST (SPLITP ($~ o P) l)
</pre>

<DT><span class="strong">SUFFIX_DEF</span>
<DD>
<pre>
|- ∀P l. SUFFIX P l = FOLDL (λl' x. if P x then SNOC x l' else []) [] l
</pre>

<DT><span class="strong">AND_EL_DEF</span>
<DD>
<pre>
|- AND_EL = EVERY I
</pre>

<DT><span class="strong">OR_EL_DEF</span>
<DD>
<pre>
|- OR_EL = EXISTS I
</pre>

<DT><span class="strong">UNZIP_FST_DEF</span>
<DD>
<pre>
|- ∀l. UNZIP_FST l = FST (UNZIP l)
</pre>

<DT><span class="strong">UNZIP_SND_DEF</span>
<DD>
<pre>
|- ∀l. UNZIP_SND l = SND (UNZIP l)
</pre>

<DT><span class="strong">LIST_ELEM_COUNT_DEF</span>
<DD>
<pre>
|- ∀e l. LIST_ELEM_COUNT e l = LENGTH (FILTER (λx. x = e) l)
</pre>

<DT><span class="strong">COUNT_LIST_def</span>
<DD>
<pre>
|- (COUNT_LIST 0 = []) ∧ ∀n. COUNT_LIST (SUC n) = 0::MAP SUC (COUNT_LIST n)
</pre>

<DT><span class="strong">COUNT_LIST_AUX_def</span>
<DD>
<pre>
|- (∀l. COUNT_LIST_AUX 0 l = l) ∧
   ∀n l. COUNT_LIST_AUX (SUC n) l = COUNT_LIST_AUX n (n::l)
</pre>

<DT><span class="strong">REPLACE_ELEMENT_DEF</span>
<DD>
<pre>
|- (∀e n. REPLACE_ELEMENT e n [] = []) ∧
   (∀e x l. REPLACE_ELEMENT e 0 (x::l) = e::l) ∧
   ∀e n x l. REPLACE_ELEMENT e (SUC n) (x::l) = x::REPLACE_ELEMENT e n l
</pre>

<DT><span class="strong">LASTN</span>
<DD>
<pre>
|- (∀l. LASTN 0 l = []) ∧
   ∀n x l. LASTN (SUC n) (SNOC x l) = SNOC x (LASTN n l)
</pre>

<DT><span class="strong">BUTLASTN</span>
<DD>
<pre>
|- (∀l. BUTLASTN 0 l = l) ∧ ∀n x l. BUTLASTN (SUC n) (SNOC x l) = BUTLASTN n l
</pre>

<DT><span class="strong">IS_SUBLIST</span>
<DD>
<pre>
|- (∀l. IS_SUBLIST l [] ⇔ T) ∧ (∀x l. IS_SUBLIST [] (x::l) ⇔ F) ∧
   ∀x1 l1 x2 l2.
     IS_SUBLIST (x1::l1) (x2::l2) ⇔
     (x1 = x2) ∧ l2 ≼ l1 ∨ IS_SUBLIST l1 (x2::l2)
</pre>

<DT><span class="strong">SEG</span>
<DD>
<pre>
|- (∀k l. SEG 0 k l = []) ∧ (∀m x l. SEG (SUC m) 0 (x::l) = x::SEG m 0 l) ∧
   ∀m k x l. SEG (SUC m) (SUC k) (x::l) = SEG (SUC m) k l
</pre>

<DT><span class="strong">IS_SUFFIX</span>
<DD>
<pre>
|- (∀l. IS_SUFFIX l [] ⇔ T) ∧ (∀x l. IS_SUFFIX [] (SNOC x l) ⇔ F) ∧
   ∀x1 l1 x2 l2.
     IS_SUFFIX (SNOC x1 l1) (SNOC x2 l2) ⇔ (x1 = x2) ∧ IS_SUFFIX l1 l2
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">DROP_LENGTH_NIL</span>
<DD>
<pre>
|- ∀l. DROP (LENGTH l) l = []
</pre>

<DT><span class="strong">TAKE_TAKE</span>
<DD>
<pre>
|- ∀m l. m ≤ LENGTH l ⇒ ∀n. n ≤ m ⇒ (TAKE n (TAKE m l) = TAKE n l)
</pre>

<DT><span class="strong">EVERY_BUTLASTN</span>
<DD>
<pre>
|- ∀P l. EVERY P l ⇒ ∀m. m ≤ LENGTH l ⇒ EVERY P (BUTLASTN m l)
</pre>

<DT><span class="strong">EVERY_LASTN</span>
<DD>
<pre>
|- ∀P l. EVERY P l ⇒ ∀m. m ≤ LENGTH l ⇒ EVERY P (LASTN m l)
</pre>

<DT><span class="strong">BUTLASTN_MAP</span>
<DD>
<pre>
|- ∀n l. n ≤ LENGTH l ⇒ ∀f. BUTLASTN n (MAP f l) = MAP f (BUTLASTN n l)
</pre>

<DT><span class="strong">LASTN_MAP</span>
<DD>
<pre>
|- ∀n l. n ≤ LENGTH l ⇒ ∀f. LASTN n (MAP f l) = MAP f (LASTN n l)
</pre>

<DT><span class="strong">LASTN_APPEND1</span>
<DD>
<pre>
|- ∀l2 n.
     LENGTH l2 ≤ n ⇒ ∀l1. LASTN n (l1 ++ l2) = LASTN (n − LENGTH l2) l1 ++ l2
</pre>

<DT><span class="strong">LASTN_APPEND2</span>
<DD>
<pre>
|- ∀n l2. n ≤ LENGTH l2 ⇒ ∀l1. LASTN n (l1 ++ l2) = LASTN n l2
</pre>

<DT><span class="strong">BUTLASTN_APPEND1</span>
<DD>
<pre>
|- ∀l2 n.
     LENGTH l2 ≤ n ⇒ ∀l1. BUTLASTN n (l1 ++ l2) = BUTLASTN (n − LENGTH l2) l1
</pre>

<DT><span class="strong">BUTLASTN_1</span>
<DD>
<pre>
|- ∀l. l ≠ [] ⇒ (BUTLASTN 1 l = FRONT l)
</pre>

<DT><span class="strong">LASTN_1</span>
<DD>
<pre>
|- ∀l. l ≠ [] ⇒ (LASTN 1 l = [LAST l])
</pre>

<DT><span class="strong">BUTLASTN_LASTN</span>
<DD>
<pre>
|- ∀m n l.
     m ≤ n ∧ n ≤ LENGTH l ⇒
     (BUTLASTN m (LASTN n l) = LASTN (n − m) (BUTLASTN m l))
</pre>

<DT><span class="strong">LASTN_BUTLASTN</span>
<DD>
<pre>
|- ∀n m l.
     n + m ≤ LENGTH l ⇒
     (LASTN n (BUTLASTN m l) = BUTLASTN m (LASTN (n + m) l))
</pre>

<DT><span class="strong">BUTLASTN_LASTN_NIL</span>
<DD>
<pre>
|- ∀n l. n ≤ LENGTH l ⇒ (BUTLASTN n (LASTN n l) = [])
</pre>

<DT><span class="strong">LAST_LASTN_LAST</span>
<DD>
<pre>
|- ∀n l. n ≤ LENGTH l ⇒ 0 < n ⇒ (LAST (LASTN n l) = LAST l)
</pre>

<DT><span class="strong">BUTLASTN_LENGTH_CONS</span>
<DD>
<pre>
|- ∀l x. BUTLASTN (LENGTH l) (x::l) = [x]
</pre>

<DT><span class="strong">BUTLASTN_CONS</span>
<DD>
<pre>
|- ∀n l. n ≤ LENGTH l ⇒ ∀x. BUTLASTN n (x::l) = x::BUTLASTN n l
</pre>

<DT><span class="strong">LASTN_LENGTH_APPEND</span>
<DD>
<pre>
|- ∀l2 l1. LASTN (LENGTH l2) (l1 ++ l2) = l2
</pre>

<DT><span class="strong">BUTLASTN_LENGTH_APPEND</span>
<DD>
<pre>
|- ∀l2 l1. BUTLASTN (LENGTH l2) (l1 ++ l2) = l1
</pre>

<DT><span class="strong">BUTLASTN_APPEND2</span>
<DD>
<pre>
|- ∀n l1 l2. n ≤ LENGTH l2 ⇒ (BUTLASTN n (l1 ++ l2) = l1 ++ BUTLASTN n l2)
</pre>

<DT><span class="strong">APPEND_TAKE_LASTN</span>
<DD>
<pre>
|- ∀m n l. (m + n = LENGTH l) ⇒ (TAKE n l ++ LASTN m l = l)
</pre>

<DT><span class="strong">APPEND_BUTLASTN_LASTN</span>
<DD>
<pre>
|- ∀n l. n ≤ LENGTH l ⇒ (BUTLASTN n l ++ LASTN n l = l)
</pre>

<DT><span class="strong">BUTLASTN_BUTLASTN</span>
<DD>
<pre>
|- ∀m n l. n + m ≤ LENGTH l ⇒ (BUTLASTN n (BUTLASTN m l) = BUTLASTN (n + m) l)
</pre>

<DT><span class="strong">LENGTH_BUTLASTN</span>
<DD>
<pre>
|- ∀n l. n ≤ LENGTH l ⇒ (LENGTH (BUTLASTN n l) = LENGTH l − n)
</pre>

<DT><span class="strong">BUTLASTN_FRONT</span>
<DD>
<pre>
|- ∀n l. n < LENGTH l ⇒ (BUTLASTN n (FRONT l) = FRONT (BUTLASTN n l))
</pre>

<DT><span class="strong">BUTLASTN_SUC_FRONT</span>
<DD>
<pre>
|- ∀n l. n < LENGTH l ⇒ (BUTLASTN (SUC n) l = BUTLASTN n (FRONT l))
</pre>

<DT><span class="strong">ELL_compute</span>
<DD>
<pre>
|- (∀l. ELL 0 l = LAST l) ∧
   (∀n l. ELL (NUMERAL (BIT1 n)) l = ELL (NUMERAL (BIT1 n) − 1) (FRONT l)) ∧
   ∀n l. ELL (NUMERAL (BIT2 n)) l = ELL (NUMERAL (BIT1 n)) (FRONT l)
</pre>

<DT><span class="strong">REPLICATE_compute</span>
<DD>
<pre>
|- (∀x. REPLICATE 0 x = []) ∧
   (∀n x.
      REPLICATE (NUMERAL (BIT1 n)) x =
      x::REPLICATE (NUMERAL (BIT1 n) − 1) x) ∧
   ∀n x. REPLICATE (NUMERAL (BIT2 n)) x = x::REPLICATE (NUMERAL (BIT1 n)) x
</pre>

<DT><span class="strong">COUNT_LIST_AUX_def_compute</span>
<DD>
<pre>
|- (∀l. COUNT_LIST_AUX 0 l = l) ∧
   (∀n l.
      COUNT_LIST_AUX (NUMERAL (BIT1 n)) l =
      COUNT_LIST_AUX (NUMERAL (BIT1 n) − 1) (NUMERAL (BIT1 n) − 1::l)) ∧
   ∀n l.
     COUNT_LIST_AUX (NUMERAL (BIT2 n)) l =
     COUNT_LIST_AUX (NUMERAL (BIT1 n)) (NUMERAL (BIT1 n)::l)
</pre>

<DT><span class="strong">TAKE</span>
<DD>
<pre>
|- (∀l. TAKE 0 l = []) ∧ ∀n x l. TAKE (SUC n) (x::l) = x::TAKE n l
</pre>

<DT><span class="strong">DROP</span>
<DD>
<pre>
|- (∀l. DROP 0 l = l) ∧ ∀n x l. DROP (SUC n) (x::l) = DROP n l
</pre>

<DT><span class="strong">NOT_NULL_SNOC</span>
<DD>
<pre>
|- ∀x l. ¬NULL (SNOC x l)
</pre>

<DT><span class="strong">LENGTH_MAP2</span>
<DD>
<pre>
|- ∀l1 l2.
     (LENGTH l1 = LENGTH l2) ⇒
     ∀f.
       (LENGTH (MAP2 f l1 l2) = LENGTH l1) ∧
       (LENGTH (MAP2 f l1 l2) = LENGTH l2)
</pre>

<DT><span class="strong">LENGTH_EQ</span>
<DD>
<pre>
|- ∀x y. (x = y) ⇒ (LENGTH x = LENGTH y)
</pre>

<DT><span class="strong">LENGTH_NOT_NULL</span>
<DD>
<pre>
|- ∀l. 0 < LENGTH l ⇔ ¬NULL l
</pre>

<DT><span class="strong">NOT_NIL_SNOC</span>
<DD>
<pre>
|- ∀x l. [] ≠ SNOC x l
</pre>

<DT><span class="strong">NOT_SNOC_NIL</span>
<DD>
<pre>
|- ∀x l. SNOC x l ≠ []
</pre>

<DT><span class="strong">SNOC_EQ_LENGTH_EQ</span>
<DD>
<pre>
|- ∀x1 l1 x2 l2. (SNOC x1 l1 = SNOC x2 l2) ⇒ (LENGTH l1 = LENGTH l2)
</pre>

<DT><span class="strong">SNOC_REVERSE_CONS</span>
<DD>
<pre>
|- ∀x l. SNOC x l = REVERSE (x::REVERSE l)
</pre>

<DT><span class="strong">FOLDR_SNOC</span>
<DD>
<pre>
|- ∀f e x l. FOLDR f e (SNOC x l) = FOLDR f (f x e) l
</pre>

<DT><span class="strong">FOLDR_FOLDL</span>
<DD>
<pre>
|- ∀f e. MONOID f e ⇒ ∀l. FOLDR f e l = FOLDL f e l
</pre>

<DT><span class="strong">LENGTH_FOLDR</span>
<DD>
<pre>
|- ∀l. LENGTH l = FOLDR (λx l'. SUC l') 0 l
</pre>

<DT><span class="strong">LENGTH_FOLDL</span>
<DD>
<pre>
|- ∀l. LENGTH l = FOLDL (λl' x. SUC l') 0 l
</pre>

<DT><span class="strong">MAP_FOLDR</span>
<DD>
<pre>
|- ∀f l. MAP f l = FOLDR (λx l'. f x::l') [] l
</pre>

<DT><span class="strong">MAP_FOLDL</span>
<DD>
<pre>
|- ∀f l. MAP f l = FOLDL (λl' x. SNOC (f x) l') [] l
</pre>

<DT><span class="strong">FILTER_FOLDR</span>
<DD>
<pre>
|- ∀P l. FILTER P l = FOLDR (λx l'. if P x then x::l' else l') [] l
</pre>

<DT><span class="strong">FILTER_SNOC</span>
<DD>
<pre>
|- ∀P x l.
     FILTER P (SNOC x l) = if P x then SNOC x (FILTER P l) else FILTER P l
</pre>

<DT><span class="strong">FILTER_FOLDL</span>
<DD>
<pre>
|- ∀P l. FILTER P l = FOLDL (λl' x. if P x then SNOC x l' else l') [] l
</pre>

<DT><span class="strong">FILTER_COMM</span>
<DD>
<pre>
|- ∀f1 f2 l. FILTER f1 (FILTER f2 l) = FILTER f2 (FILTER f1 l)
</pre>

<DT><span class="strong">FILTER_IDEM</span>
<DD>
<pre>
|- ∀f l. FILTER f (FILTER f l) = FILTER f l
</pre>

<DT><span class="strong">FILTER_MAP</span>
<DD>
<pre>
|- ∀f1 f2 l. FILTER f1 (MAP f2 l) = MAP f2 (FILTER (f1 o f2) l)
</pre>

<DT><span class="strong">LENGTH_FILTER_LEQ</span>
<DD>
<pre>
|- ∀P l. LENGTH (FILTER P l) ≤ LENGTH l
</pre>

<DT><span class="strong">FILTER_EQ</span>
<DD>
<pre>
|- ∀P1 P2 l. (FILTER P1 l = FILTER P2 l) ⇔ ∀x. MEM x l ⇒ (P1 x ⇔ P2 x)
</pre>

<DT><span class="strong">LENGTH_SEG</span>
<DD>
<pre>
|- ∀n k l. n + k ≤ LENGTH l ⇒ (LENGTH (SEG n k l) = n)
</pre>

<DT><span class="strong">APPEND_NIL</span>
<DD>
<pre>
|- (∀l. l ++ [] = l) ∧ ∀l. [] ++ l = l
</pre>

<DT><span class="strong">APPEND_FOLDR</span>
<DD>
<pre>
|- ∀l1 l2. l1 ++ l2 = FOLDR CONS l2 l1
</pre>

<DT><span class="strong">APPEND_FOLDL</span>
<DD>
<pre>
|- ∀l1 l2. l1 ++ l2 = FOLDL (λl' x. SNOC x l') l1 l2
</pre>

<DT><span class="strong">FOLDR_APPEND</span>
<DD>
<pre>
|- ∀f e l1 l2. FOLDR f e (l1 ++ l2) = FOLDR f (FOLDR f e l2) l1
</pre>

<DT><span class="strong">FOLDL_APPEND</span>
<DD>
<pre>
|- ∀f e l1 l2. FOLDL f e (l1 ++ l2) = FOLDL f (FOLDL f e l1) l2
</pre>

<DT><span class="strong">CONS_APPEND</span>
<DD>
<pre>
|- ∀x l. x::l = [x] ++ l
</pre>

<DT><span class="strong">ASSOC_APPEND</span>
<DD>
<pre>
|- ASSOC $++
</pre>

<DT><span class="strong">MONOID_APPEND_NIL</span>
<DD>
<pre>
|- MONOID $++ []
</pre>

<DT><span class="strong">FLAT_SNOC</span>
<DD>
<pre>
|- ∀x l. FLAT (SNOC x l) = FLAT l ++ x
</pre>

<DT><span class="strong">FLAT_FOLDR</span>
<DD>
<pre>
|- ∀l. FLAT l = FOLDR $++ [] l
</pre>

<DT><span class="strong">FLAT_FOLDL</span>
<DD>
<pre>
|- ∀l. FLAT l = FOLDL $++ [] l
</pre>

<DT><span class="strong">LENGTH_FLAT</span>
<DD>
<pre>
|- ∀l. LENGTH (FLAT l) = SUM (MAP LENGTH l)
</pre>

<DT><span class="strong">REVERSE_FOLDR</span>
<DD>
<pre>
|- ∀l. REVERSE l = FOLDR SNOC [] l
</pre>

<DT><span class="strong">REVERSE_FOLDL</span>
<DD>
<pre>
|- ∀l. REVERSE l = FOLDL (λl' x. x::l') [] l
</pre>

<DT><span class="strong">ALL_EL_MAP</span>
<DD>
<pre>
|- ∀P f l. EVERY P (MAP f l) ⇔ EVERY (P o f) l
</pre>

<DT><span class="strong">MEM_EXISTS</span>
<DD>
<pre>
|- ∀x l. MEM x l ⇔ EXISTS ($= x) l
</pre>

<DT><span class="strong">SUM_FOLDR</span>
<DD>
<pre>
|- ∀l. SUM l = FOLDR $+ 0 l
</pre>

<DT><span class="strong">SUM_FOLDL</span>
<DD>
<pre>
|- ∀l. SUM l = FOLDL $+ 0 l
</pre>

<DT><span class="strong">IS_PREFIX</span>
<DD>
<pre>
|- (∀l. [] ≼ l ⇔ T) ∧ (∀x l. x::l ≼ [] ⇔ F) ∧
   ∀x1 l1 x2 l2. x2::l2 ≼ x1::l1 ⇔ (x1 = x2) ∧ l2 ≼ l1
</pre>

<DT><span class="strong">IS_PREFIX_APPEND</span>
<DD>
<pre>
|- ∀l1 l2. l2 ≼ l1 ⇔ ∃l. l1 = l2 ++ l
</pre>

<DT><span class="strong">IS_SUFFIX_APPEND</span>
<DD>
<pre>
|- ∀l1 l2. IS_SUFFIX l1 l2 ⇔ ∃l. l1 = l ++ l2
</pre>

<DT><span class="strong">IS_SUBLIST_APPEND</span>
<DD>
<pre>
|- ∀l1 l2. IS_SUBLIST l1 l2 ⇔ ∃l l'. l1 = l ++ (l2 ++ l')
</pre>

<DT><span class="strong">IS_PREFIX_IS_SUBLIST</span>
<DD>
<pre>
|- ∀l1 l2. l2 ≼ l1 ⇒ IS_SUBLIST l1 l2
</pre>

<DT><span class="strong">IS_SUFFIX_IS_SUBLIST</span>
<DD>
<pre>
|- ∀l1 l2. IS_SUFFIX l1 l2 ⇒ IS_SUBLIST l1 l2
</pre>

<DT><span class="strong">IS_PREFIX_REVERSE</span>
<DD>
<pre>
|- ∀l1 l2. REVERSE l2 ≼ REVERSE l1 ⇔ IS_SUFFIX l1 l2
</pre>

<DT><span class="strong">IS_SUFFIX_REVERSE</span>
<DD>
<pre>
|- ∀l2 l1. IS_SUFFIX (REVERSE l1) (REVERSE l2) ⇔ l2 ≼ l1
</pre>

<DT><span class="strong">IS_SUFFIX_CONS2_E</span>
<DD>
<pre>
|- ∀s h t. IS_SUFFIX s (h::t) ⇒ IS_SUFFIX s t
</pre>

<DT><span class="strong">IS_SUFFIX_REFL</span>
<DD>
<pre>
|- ∀l. IS_SUFFIX l l
</pre>

<DT><span class="strong">IS_SUBLIST_REVERSE</span>
<DD>
<pre>
|- ∀l1 l2. IS_SUBLIST (REVERSE l1) (REVERSE l2) ⇔ IS_SUBLIST l1 l2
</pre>

<DT><span class="strong">PREFIX_FOLDR</span>
<DD>
<pre>
|- ∀P l. PREFIX P l = FOLDR (λx l'. if P x then x::l' else []) [] l
</pre>

<DT><span class="strong">PREFIX</span>
<DD>
<pre>
|- (∀P. PREFIX P [] = []) ∧
   ∀P x l. PREFIX P (x::l) = if P x then x::PREFIX P l else []
</pre>

<DT><span class="strong">IS_PREFIX_PREFIX</span>
<DD>
<pre>
|- ∀P l. PREFIX P l ≼ l
</pre>

<DT><span class="strong">LENGTH_SCANL</span>
<DD>
<pre>
|- ∀f e l. LENGTH (SCANL f e l) = SUC (LENGTH l)
</pre>

<DT><span class="strong">LENGTH_SCANR</span>
<DD>
<pre>
|- ∀f e l. LENGTH (SCANR f e l) = SUC (LENGTH l)
</pre>

<DT><span class="strong">COMM_MONOID_FOLDL</span>
<DD>
<pre>
|- ∀f. COMM f ⇒ ∀e'. MONOID f e' ⇒ ∀e l. FOLDL f e l = f e (FOLDL f e' l)
</pre>

<DT><span class="strong">COMM_MONOID_FOLDR</span>
<DD>
<pre>
|- ∀f. COMM f ⇒ ∀e'. MONOID f e' ⇒ ∀e l. FOLDR f e l = f e (FOLDR f e' l)
</pre>

<DT><span class="strong">FCOMM_FOLDR_APPEND</span>
<DD>
<pre>
|- ∀g f.
     FCOMM g f ⇒
     ∀e.
       LEFT_ID g e ⇒
       ∀l1 l2. FOLDR f e (l1 ++ l2) = g (FOLDR f e l1) (FOLDR f e l2)
</pre>

<DT><span class="strong">FCOMM_FOLDL_APPEND</span>
<DD>
<pre>
|- ∀f g.
     FCOMM f g ⇒
     ∀e.
       RIGHT_ID g e ⇒
       ∀l1 l2. FOLDL f e (l1 ++ l2) = g (FOLDL f e l1) (FOLDL f e l2)
</pre>

<DT><span class="strong">FOLDL_SINGLE</span>
<DD>
<pre>
|- ∀f e x. FOLDL f e [x] = f e x
</pre>

<DT><span class="strong">FOLDR_SINGLE</span>
<DD>
<pre>
|- ∀f e x. FOLDR f e [x] = f x e
</pre>

<DT><span class="strong">FOLDR_CONS_NIL</span>
<DD>
<pre>
|- ∀l. FOLDR CONS [] l = l
</pre>

<DT><span class="strong">FOLDL_SNOC_NIL</span>
<DD>
<pre>
|- ∀l. FOLDL (λxs x. SNOC x xs) [] l = l
</pre>

<DT><span class="strong">FOLDR_FOLDL_REVERSE</span>
<DD>
<pre>
|- ∀f e l. FOLDR f e l = FOLDL (λx y. f y x) e (REVERSE l)
</pre>

<DT><span class="strong">FOLDL_FOLDR_REVERSE</span>
<DD>
<pre>
|- ∀f e l. FOLDL f e l = FOLDR (λx y. f y x) e (REVERSE l)
</pre>

<DT><span class="strong">FOLDR_REVERSE</span>
<DD>
<pre>
|- ∀f e l. FOLDR f e (REVERSE l) = FOLDL (λx y. f y x) e l
</pre>

<DT><span class="strong">FOLDL_REVERSE</span>
<DD>
<pre>
|- ∀f e l. FOLDL f e (REVERSE l) = FOLDR (λx y. f y x) e l
</pre>

<DT><span class="strong">FOLDR_MAP</span>
<DD>
<pre>
|- ∀f e g l. FOLDR f e (MAP g l) = FOLDR (λx y. f (g x) y) e l
</pre>

<DT><span class="strong">FOLDL_MAP</span>
<DD>
<pre>
|- ∀f e g l. FOLDL f e (MAP g l) = FOLDL (λx y. f x (g y)) e l
</pre>

<DT><span class="strong">EVERY_FOLDR</span>
<DD>
<pre>
|- ∀P l. EVERY P l ⇔ FOLDR (λx l'. P x ∧ l') T l
</pre>

<DT><span class="strong">EVERY_FOLDL</span>
<DD>
<pre>
|- ∀P l. EVERY P l ⇔ FOLDL (λl' x. l' ∧ P x) T l
</pre>

<DT><span class="strong">EXISTS_FOLDR</span>
<DD>
<pre>
|- ∀P l. EXISTS P l ⇔ FOLDR (λx l'. P x ∨ l') F l
</pre>

<DT><span class="strong">EXISTS_FOLDL</span>
<DD>
<pre>
|- ∀P l. EXISTS P l ⇔ FOLDL (λl' x. l' ∨ P x) F l
</pre>

<DT><span class="strong">EVERY_FOLDR_MAP</span>
<DD>
<pre>
|- ∀P l. EVERY P l ⇔ FOLDR $/\ T (MAP P l)
</pre>

<DT><span class="strong">EVERY_FOLDL_MAP</span>
<DD>
<pre>
|- ∀P l. EVERY P l ⇔ FOLDL $/\ T (MAP P l)
</pre>

<DT><span class="strong">EXISTS_FOLDR_MAP</span>
<DD>
<pre>
|- ∀P l. EXISTS P l ⇔ FOLDR $\/ F (MAP P l)
</pre>

<DT><span class="strong">EXISTS_FOLDL_MAP</span>
<DD>
<pre>
|- ∀P l. EXISTS P l ⇔ FOLDL $\/ F (MAP P l)
</pre>

<DT><span class="strong">FOLDR_FILTER</span>
<DD>
<pre>
|- ∀f e P l.
     FOLDR f e (FILTER P l) = FOLDR (λx y. if P x then f x y else y) e l
</pre>

<DT><span class="strong">FOLDL_FILTER</span>
<DD>
<pre>
|- ∀f e P l.
     FOLDL f e (FILTER P l) = FOLDL (λx y. if P y then f x y else x) e l
</pre>

<DT><span class="strong">ASSOC_FOLDR_FLAT</span>
<DD>
<pre>
|- ∀f.
     ASSOC f ⇒
     ∀e. LEFT_ID f e ⇒ ∀l. FOLDR f e (FLAT l) = FOLDR f e (MAP (FOLDR f e) l)
</pre>

<DT><span class="strong">ASSOC_FOLDL_FLAT</span>
<DD>
<pre>
|- ∀f.
     ASSOC f ⇒
     ∀e. RIGHT_ID f e ⇒ ∀l. FOLDL f e (FLAT l) = FOLDL f e (MAP (FOLDL f e) l)
</pre>

<DT><span class="strong">MAP_FLAT</span>
<DD>
<pre>
|- ∀f l. MAP f (FLAT l) = FLAT (MAP (MAP f) l)
</pre>

<DT><span class="strong">FILTER_FLAT</span>
<DD>
<pre>
|- ∀P l. FILTER P (FLAT l) = FLAT (MAP (FILTER P) l)
</pre>

<DT><span class="strong">EXISTS_DISJ</span>
<DD>
<pre>
|- ∀P Q l. EXISTS (λx. P x ∨ Q x) l ⇔ EXISTS P l ∨ EXISTS Q l
</pre>

<DT><span class="strong">MEM_FOLDR</span>
<DD>
<pre>
|- ∀y l. MEM y l ⇔ FOLDR (λx l'. (y = x) ∨ l') F l
</pre>

<DT><span class="strong">MEM_FOLDL</span>
<DD>
<pre>
|- ∀y l. MEM y l ⇔ FOLDL (λl' x. l' ∨ (y = x)) F l
</pre>

<DT><span class="strong">NULL_FOLDR</span>
<DD>
<pre>
|- ∀l. NULL l ⇔ FOLDR (λx l'. F) T l
</pre>

<DT><span class="strong">NULL_FOLDL</span>
<DD>
<pre>
|- ∀l. NULL l ⇔ FOLDL (λx l'. F) T l
</pre>

<DT><span class="strong">MAP_REVERSE</span>
<DD>
<pre>
|- ∀f l. MAP f (REVERSE l) = REVERSE (MAP f l)
</pre>

<DT><span class="strong">SEG_LENGTH_ID</span>
<DD>
<pre>
|- ∀l. SEG (LENGTH l) 0 l = l
</pre>

<DT><span class="strong">SEG_SUC_CONS</span>
<DD>
<pre>
|- ∀m n l x. SEG m (SUC n) (x::l) = SEG m n l
</pre>

<DT><span class="strong">SEG_0_SNOC</span>
<DD>
<pre>
|- ∀m l x. m ≤ LENGTH l ⇒ (SEG m 0 (SNOC x l) = SEG m 0 l)
</pre>

<DT><span class="strong">BUTLASTN_SEG</span>
<DD>
<pre>
|- ∀n l. n ≤ LENGTH l ⇒ (BUTLASTN n l = SEG (LENGTH l − n) 0 l)
</pre>

<DT><span class="strong">LASTN_CONS</span>
<DD>
<pre>
|- ∀n l. n ≤ LENGTH l ⇒ ∀x. LASTN n (x::l) = LASTN n l
</pre>

<DT><span class="strong">LENGTH_LASTN</span>
<DD>
<pre>
|- ∀n l. n ≤ LENGTH l ⇒ (LENGTH (LASTN n l) = n)
</pre>

<DT><span class="strong">LASTN_LENGTH_ID</span>
<DD>
<pre>
|- ∀l. LASTN (LENGTH l) l = l
</pre>

<DT><span class="strong">LASTN_LASTN</span>
<DD>
<pre>
|- ∀l n m. m ≤ LENGTH l ⇒ n ≤ m ⇒ (LASTN n (LASTN m l) = LASTN n l)
</pre>

<DT><span class="strong">TAKE_SNOC</span>
<DD>
<pre>
|- ∀n l. n ≤ LENGTH l ⇒ ∀x. TAKE n (SNOC x l) = TAKE n l
</pre>

<DT><span class="strong">BUTLASTN_LENGTH_NIL</span>
<DD>
<pre>
|- ∀l. BUTLASTN (LENGTH l) l = []
</pre>

<DT><span class="strong">DROP_APPEND1</span>
<DD>
<pre>
|- ∀n l1. n ≤ LENGTH l1 ⇒ ∀l2. DROP n (l1 ++ l2) = DROP n l1 ++ l2
</pre>

<DT><span class="strong">DROP_APPEND2</span>
<DD>
<pre>
|- ∀l1 n. LENGTH l1 ≤ n ⇒ ∀l2. DROP n (l1 ++ l2) = DROP (n − LENGTH l1) l2
</pre>

<DT><span class="strong">DROP_DROP</span>
<DD>
<pre>
|- ∀n m l. n + m ≤ LENGTH l ⇒ (DROP n (DROP m l) = DROP (n + m) l)
</pre>

<DT><span class="strong">LASTN_SEG</span>
<DD>
<pre>
|- ∀n l. n ≤ LENGTH l ⇒ (LASTN n l = SEG n (LENGTH l − n) l)
</pre>

<DT><span class="strong">TAKE_SEG</span>
<DD>
<pre>
|- ∀n l. n ≤ LENGTH l ⇒ (TAKE n l = SEG n 0 l)
</pre>

<DT><span class="strong">DROP_SEG</span>
<DD>
<pre>
|- ∀n l. n ≤ LENGTH l ⇒ (DROP n l = SEG (LENGTH l − n) n l)
</pre>

<DT><span class="strong">DROP_SNOC</span>
<DD>
<pre>
|- ∀n l. n ≤ LENGTH l ⇒ ∀x. DROP n (SNOC x l) = SNOC x (DROP n l)
</pre>

<DT><span class="strong">APPEND_BUTLASTN_DROP</span>
<DD>
<pre>
|- ∀m n l. (m + n = LENGTH l) ⇒ (BUTLASTN m l ++ DROP n l = l)
</pre>

<DT><span class="strong">SEG_SEG</span>
<DD>
<pre>
|- ∀n1 m1 n2 m2 l.
     n1 + m1 ≤ LENGTH l ∧ n2 + m2 ≤ n1 ⇒
     (SEG n2 m2 (SEG n1 m1 l) = SEG n2 (m1 + m2) l)
</pre>

<DT><span class="strong">SEG_APPEND1</span>
<DD>
<pre>
|- ∀n m l1. n + m ≤ LENGTH l1 ⇒ ∀l2. SEG n m (l1 ++ l2) = SEG n m l1
</pre>

<DT><span class="strong">SEG_APPEND2</span>
<DD>
<pre>
|- ∀l1 m n l2.
     LENGTH l1 ≤ m ∧ n ≤ LENGTH l2 ⇒
     (SEG n m (l1 ++ l2) = SEG n (m − LENGTH l1) l2)
</pre>

<DT><span class="strong">SEG_TAKE_BUTFISTN</span>
<DD>
<pre>
|- ∀n m l. n + m ≤ LENGTH l ⇒ (SEG n m l = TAKE n (DROP m l))
</pre>

<DT><span class="strong">SEG_APPEND</span>
<DD>
<pre>
|- ∀m l1 n l2.
     m < LENGTH l1 ∧ LENGTH l1 ≤ n + m ∧ n + m ≤ LENGTH l1 + LENGTH l2 ⇒
     (SEG n m (l1 ++ l2) =
      SEG (LENGTH l1 − m) m l1 ++ SEG (n + m − LENGTH l1) 0 l2)
</pre>

<DT><span class="strong">SEG_LENGTH_SNOC</span>
<DD>
<pre>
|- ∀l x. SEG 1 (LENGTH l) (SNOC x l) = [x]
</pre>

<DT><span class="strong">SEG_SNOC</span>
<DD>
<pre>
|- ∀n m l. n + m ≤ LENGTH l ⇒ ∀x. SEG n m (SNOC x l) = SEG n m l
</pre>

<DT><span class="strong">ELL_SEG</span>
<DD>
<pre>
|- ∀n l. n < LENGTH l ⇒ (ELL n l = HD (SEG 1 (PRE (LENGTH l − n)) l))
</pre>

<DT><span class="strong">SNOC_FOLDR</span>
<DD>
<pre>
|- ∀x l. SNOC x l = FOLDR CONS [x] l
</pre>

<DT><span class="strong">MEM_FOLDR_MAP</span>
<DD>
<pre>
|- ∀x l. MEM x l ⇔ FOLDR $\/ F (MAP ($= x) l)
</pre>

<DT><span class="strong">MEM_FOLDL_MAP</span>
<DD>
<pre>
|- ∀x l. MEM x l ⇔ FOLDL $\/ F (MAP ($= x) l)
</pre>

<DT><span class="strong">FILTER_FILTER</span>
<DD>
<pre>
|- ∀P Q l. FILTER P (FILTER Q l) = FILTER (λx. P x ∧ Q x) l
</pre>

<DT><span class="strong">FCOMM_FOLDR_FLAT</span>
<DD>
<pre>
|- ∀g f.
     FCOMM g f ⇒
     ∀e. LEFT_ID g e ⇒ ∀l. FOLDR f e (FLAT l) = FOLDR g e (MAP (FOLDR f e) l)
</pre>

<DT><span class="strong">FCOMM_FOLDL_FLAT</span>
<DD>
<pre>
|- ∀f g.
     FCOMM f g ⇒
     ∀e. RIGHT_ID g e ⇒ ∀l. FOLDL f e (FLAT l) = FOLDL g e (MAP (FOLDL f e) l)
</pre>

<DT><span class="strong">FOLDR_MAP_REVERSE</span>
<DD>
<pre>
|- ∀f.
     (∀a b c. f a (f b c) = f b (f a c)) ⇒
     ∀e g l. FOLDR f e (MAP g (REVERSE l)) = FOLDR f e (MAP g l)
</pre>

<DT><span class="strong">FOLDR_FILTER_REVERSE</span>
<DD>
<pre>
|- ∀f.
     (∀a b c. f a (f b c) = f b (f a c)) ⇒
     ∀e P l. FOLDR f e (FILTER P (REVERSE l)) = FOLDR f e (FILTER P l)
</pre>

<DT><span class="strong">COMM_ASSOC_FOLDR_REVERSE</span>
<DD>
<pre>
|- ∀f. COMM f ⇒ ASSOC f ⇒ ∀e l. FOLDR f e (REVERSE l) = FOLDR f e l
</pre>

<DT><span class="strong">COMM_ASSOC_FOLDL_REVERSE</span>
<DD>
<pre>
|- ∀f. COMM f ⇒ ASSOC f ⇒ ∀e l. FOLDL f e (REVERSE l) = FOLDL f e l
</pre>

<DT><span class="strong">ELL_LAST</span>
<DD>
<pre>
|- ∀l. ¬NULL l ⇒ (ELL 0 l = LAST l)
</pre>

<DT><span class="strong">ELL_0_SNOC</span>
<DD>
<pre>
|- ∀l x. ELL 0 (SNOC x l) = x
</pre>

<DT><span class="strong">ELL_SNOC</span>
<DD>
<pre>
|- ∀n. 0 < n ⇒ ∀x l. ELL n (SNOC x l) = ELL (PRE n) l
</pre>

<DT><span class="strong">ELL_SUC_SNOC</span>
<DD>
<pre>
|- ∀n x l. ELL (SUC n) (SNOC x l) = ELL n l
</pre>

<DT><span class="strong">ELL_CONS</span>
<DD>
<pre>
|- ∀n l. n < LENGTH l ⇒ ∀x. ELL n (x::l) = ELL n l
</pre>

<DT><span class="strong">ELL_LENGTH_CONS</span>
<DD>
<pre>
|- ∀l x. ELL (LENGTH l) (x::l) = x
</pre>

<DT><span class="strong">ELL_LENGTH_SNOC</span>
<DD>
<pre>
|- ∀l x. ELL (LENGTH l) (SNOC x l) = if NULL l then x else HD l
</pre>

<DT><span class="strong">ELL_APPEND2</span>
<DD>
<pre>
|- ∀n l2. n < LENGTH l2 ⇒ ∀l1. ELL n (l1 ++ l2) = ELL n l2
</pre>

<DT><span class="strong">ELL_APPEND1</span>
<DD>
<pre>
|- ∀l2 n. LENGTH l2 ≤ n ⇒ ∀l1. ELL n (l1 ++ l2) = ELL (n − LENGTH l2) l1
</pre>

<DT><span class="strong">ELL_PRE_LENGTH</span>
<DD>
<pre>
|- ∀l. l ≠ [] ⇒ (ELL (PRE (LENGTH l)) l = HD l)
</pre>

<DT><span class="strong">EL_PRE_LENGTH</span>
<DD>
<pre>
|- ∀l. l ≠ [] ⇒ (EL (PRE (LENGTH l)) l = LAST l)
</pre>

<DT><span class="strong">EL_ELL</span>
<DD>
<pre>
|- ∀n l. n < LENGTH l ⇒ (EL n l = ELL (PRE (LENGTH l − n)) l)
</pre>

<DT><span class="strong">EL_LENGTH_APPEND</span>
<DD>
<pre>
|- ∀l2 l1. ¬NULL l2 ⇒ (EL (LENGTH l1) (l1 ++ l2) = HD l2)
</pre>

<DT><span class="strong">ELL_EL</span>
<DD>
<pre>
|- ∀n l. n < LENGTH l ⇒ (ELL n l = EL (PRE (LENGTH l − n)) l)
</pre>

<DT><span class="strong">ELL_MAP</span>
<DD>
<pre>
|- ∀n l f. n < LENGTH l ⇒ (ELL n (MAP f l) = f (ELL n l))
</pre>

<DT><span class="strong">LENGTH_FRONT</span>
<DD>
<pre>
|- ∀l. l ≠ [] ⇒ (LENGTH (FRONT l) = PRE (LENGTH l))
</pre>

<DT><span class="strong">DROP_LENGTH_APPEND</span>
<DD>
<pre>
|- ∀l1 l2. DROP (LENGTH l1) (l1 ++ l2) = l2
</pre>

<DT><span class="strong">TAKE_APPEND1</span>
<DD>
<pre>
|- ∀n l1. n ≤ LENGTH l1 ⇒ ∀l2. TAKE n (l1 ++ l2) = TAKE n l1
</pre>

<DT><span class="strong">TAKE_APPEND2</span>
<DD>
<pre>
|- ∀l1 n.
     LENGTH l1 ≤ n ⇒ ∀l2. TAKE n (l1 ++ l2) = l1 ++ TAKE (n − LENGTH l1) l2
</pre>

<DT><span class="strong">TAKE_LENGTH_APPEND</span>
<DD>
<pre>
|- ∀l1 l2. TAKE (LENGTH l1) (l1 ++ l2) = l1
</pre>

<DT><span class="strong">REVERSE_FLAT</span>
<DD>
<pre>
|- ∀l. REVERSE (FLAT l) = FLAT (REVERSE (MAP REVERSE l))
</pre>

<DT><span class="strong">MAP_FILTER</span>
<DD>
<pre>
|- ∀f P l. (∀x. P (f x) ⇔ P x) ⇒ (MAP f (FILTER P l) = FILTER P (MAP f l))
</pre>

<DT><span class="strong">FLAT_APPEND</span>
<DD>
<pre>
|- ∀l1 l2. FLAT (l1 ++ l2) = FLAT l1 ++ FLAT l2
</pre>

<DT><span class="strong">FLAT_REVERSE</span>
<DD>
<pre>
|- ∀l. FLAT (REVERSE l) = REVERSE (FLAT (MAP REVERSE l))
</pre>

<DT><span class="strong">FLAT_FLAT</span>
<DD>
<pre>
|- ∀l. FLAT (FLAT l) = FLAT (MAP FLAT l)
</pre>

<DT><span class="strong">EVERY_REVERSE</span>
<DD>
<pre>
|- ∀P l. EVERY P (REVERSE l) ⇔ EVERY P l
</pre>

<DT><span class="strong">EXISTS_REVERSE</span>
<DD>
<pre>
|- ∀P l. EXISTS P (REVERSE l) ⇔ EXISTS P l
</pre>

<DT><span class="strong">EVERY_SEG</span>
<DD>
<pre>
|- ∀P l. EVERY P l ⇒ ∀m k. m + k ≤ LENGTH l ⇒ EVERY P (SEG m k l)
</pre>

<DT><span class="strong">EVERY_TAKE</span>
<DD>
<pre>
|- ∀P l. EVERY P l ⇒ ∀m. m ≤ LENGTH l ⇒ EVERY P (TAKE m l)
</pre>

<DT><span class="strong">EVERY_DROP</span>
<DD>
<pre>
|- ∀P l. EVERY P l ⇒ ∀m. m ≤ LENGTH l ⇒ EVERY P (DROP m l)
</pre>

<DT><span class="strong">EXISTS_SEG</span>
<DD>
<pre>
|- ∀m k l. m + k ≤ LENGTH l ⇒ ∀P. EXISTS P (SEG m k l) ⇒ EXISTS P l
</pre>

<DT><span class="strong">EXISTS_TAKE</span>
<DD>
<pre>
|- ∀m l. m ≤ LENGTH l ⇒ ∀P. EXISTS P (TAKE m l) ⇒ EXISTS P l
</pre>

<DT><span class="strong">EXISTS_DROP</span>
<DD>
<pre>
|- ∀m l. m ≤ LENGTH l ⇒ ∀P. EXISTS P (DROP m l) ⇒ EXISTS P l
</pre>

<DT><span class="strong">EXISTS_LASTN</span>
<DD>
<pre>
|- ∀m l. m ≤ LENGTH l ⇒ ∀P. EXISTS P (LASTN m l) ⇒ EXISTS P l
</pre>

<DT><span class="strong">EXISTS_BUTLASTN</span>
<DD>
<pre>
|- ∀m l. m ≤ LENGTH l ⇒ ∀P. EXISTS P (BUTLASTN m l) ⇒ EXISTS P l
</pre>

<DT><span class="strong">MEM_SEG</span>
<DD>
<pre>
|- ∀n m l. n + m ≤ LENGTH l ⇒ ∀x. MEM x (SEG n m l) ⇒ MEM x l
</pre>

<DT><span class="strong">MEM_TAKE</span>
<DD>
<pre>
|- ∀m l. m ≤ LENGTH l ⇒ ∀x. MEM x (TAKE m l) ⇒ MEM x l
</pre>

<DT><span class="strong">MEM_DROP</span>
<DD>
<pre>
|- ∀m l. m ≤ LENGTH l ⇒ ∀x. MEM x (DROP m l) ⇒ MEM x l
</pre>

<DT><span class="strong">MEM_BUTLASTN</span>
<DD>
<pre>
|- ∀m l. m ≤ LENGTH l ⇒ ∀x. MEM x (BUTLASTN m l) ⇒ MEM x l
</pre>

<DT><span class="strong">MEM_LASTN</span>
<DD>
<pre>
|- ∀m l. m ≤ LENGTH l ⇒ ∀x. MEM x (LASTN m l) ⇒ MEM x l
</pre>

<DT><span class="strong">ZIP_SNOC</span>
<DD>
<pre>
|- ∀l1 l2.
     (LENGTH l1 = LENGTH l2) ⇒
     ∀x1 x2. ZIP (SNOC x1 l1,SNOC x2 l2) = SNOC (x1,x2) (ZIP (l1,l2))
</pre>

<DT><span class="strong">UNZIP_SNOC</span>
<DD>
<pre>
|- ∀x l.
     UNZIP (SNOC x l) =
     (SNOC (FST x) (FST (UNZIP l)),SNOC (SND x) (SND (UNZIP l)))
</pre>

<DT><span class="strong">LENGTH_UNZIP_FST</span>
<DD>
<pre>
|- ∀l. LENGTH (UNZIP_FST l) = LENGTH l
</pre>

<DT><span class="strong">LENGTH_UNZIP_SND</span>
<DD>
<pre>
|- ∀l. LENGTH (UNZIP_SND l) = LENGTH l
</pre>

<DT><span class="strong">SUM_REVERSE</span>
<DD>
<pre>
|- ∀l. SUM (REVERSE l) = SUM l
</pre>

<DT><span class="strong">SUM_FLAT</span>
<DD>
<pre>
|- ∀l. SUM (FLAT l) = SUM (MAP SUM l)
</pre>

<DT><span class="strong">EL_APPEND1</span>
<DD>
<pre>
|- ∀n l1 l2. n < LENGTH l1 ⇒ (EL n (l1 ++ l2) = EL n l1)
</pre>

<DT><span class="strong">EL_APPEND2</span>
<DD>
<pre>
|- ∀l1 n. LENGTH l1 ≤ n ⇒ ∀l2. EL n (l1 ++ l2) = EL (n − LENGTH l1) l2
</pre>

<DT><span class="strong">EL_CONS</span>
<DD>
<pre>
|- ∀n. 0 < n ⇒ ∀x l. EL n (x::l) = EL (PRE n) l
</pre>

<DT><span class="strong">EL_SEG</span>
<DD>
<pre>
|- ∀n l. n < LENGTH l ⇒ (EL n l = HD (SEG 1 n l))
</pre>

<DT><span class="strong">EL_MEM</span>
<DD>
<pre>
|- ∀n l. n < LENGTH l ⇒ MEM (EL n l) l
</pre>

<DT><span class="strong">TL_SNOC</span>
<DD>
<pre>
|- ∀x l. TL (SNOC x l) = if NULL l then [] else SNOC x (TL l)
</pre>

<DT><span class="strong">EL_REVERSE_ELL</span>
<DD>
<pre>
|- ∀n l. n < LENGTH l ⇒ (EL n (REVERSE l) = ELL n l)
</pre>

<DT><span class="strong">ELL_LENGTH_APPEND</span>
<DD>
<pre>
|- ∀l1 l2. ¬NULL l1 ⇒ (ELL (LENGTH l2) (l1 ++ l2) = LAST l1)
</pre>

<DT><span class="strong">ELL_MEM</span>
<DD>
<pre>
|- ∀n l. n < LENGTH l ⇒ MEM (ELL n l) l
</pre>

<DT><span class="strong">ELL_REVERSE</span>
<DD>
<pre>
|- ∀n l. n < LENGTH l ⇒ (ELL n (REVERSE l) = ELL (PRE (LENGTH l − n)) l)
</pre>

<DT><span class="strong">ELL_REVERSE_EL</span>
<DD>
<pre>
|- ∀n l. n < LENGTH l ⇒ (ELL n (REVERSE l) = EL n l)
</pre>

<DT><span class="strong">TAKE_BUTLASTN</span>
<DD>
<pre>
|- ∀n l. n ≤ LENGTH l ⇒ (TAKE n l = BUTLASTN (LENGTH l − n) l)
</pre>

<DT><span class="strong">BUTLASTN_TAKE</span>
<DD>
<pre>
|- ∀n l. n ≤ LENGTH l ⇒ (BUTLASTN n l = TAKE (LENGTH l − n) l)
</pre>

<DT><span class="strong">LASTN_DROP</span>
<DD>
<pre>
|- ∀n l. n ≤ LENGTH l ⇒ (LASTN n l = DROP (LENGTH l − n) l)
</pre>

<DT><span class="strong">DROP_LASTN</span>
<DD>
<pre>
|- ∀n l. n ≤ LENGTH l ⇒ (DROP n l = LASTN (LENGTH l − n) l)
</pre>

<DT><span class="strong">SEG_LASTN_BUTLASTN</span>
<DD>
<pre>
|- ∀n m l.
     n + m ≤ LENGTH l ⇒
     (SEG n m l = LASTN n (BUTLASTN (LENGTH l − (n + m)) l))
</pre>

<DT><span class="strong">DROP_REVERSE</span>
<DD>
<pre>
|- ∀n l. n ≤ LENGTH l ⇒ (DROP n (REVERSE l) = REVERSE (BUTLASTN n l))
</pre>

<DT><span class="strong">BUTLASTN_REVERSE</span>
<DD>
<pre>
|- ∀n l. n ≤ LENGTH l ⇒ (BUTLASTN n (REVERSE l) = REVERSE (DROP n l))
</pre>

<DT><span class="strong">LASTN_REVERSE</span>
<DD>
<pre>
|- ∀n l. n ≤ LENGTH l ⇒ (LASTN n (REVERSE l) = REVERSE (TAKE n l))
</pre>

<DT><span class="strong">TAKE_REVERSE</span>
<DD>
<pre>
|- ∀n l. n ≤ LENGTH l ⇒ (TAKE n (REVERSE l) = REVERSE (LASTN n l))
</pre>

<DT><span class="strong">SEG_REVERSE</span>
<DD>
<pre>
|- ∀n m l.
     n + m ≤ LENGTH l ⇒
     (SEG n m (REVERSE l) = REVERSE (SEG n (LENGTH l − (n + m)) l))
</pre>

<DT><span class="strong">LENGTH_REPLICATE</span>
<DD>
<pre>
|- ∀n x. LENGTH (REPLICATE n x) = n
</pre>

<DT><span class="strong">MEM_REPLICATE</span>
<DD>
<pre>
|- ∀n. 0 < n ⇒ ∀x. MEM x (REPLICATE n x)
</pre>

<DT><span class="strong">EVERY_REPLICATE</span>
<DD>
<pre>
|- ∀x n. EVERY ($= x) (REPLICATE n x)
</pre>

<DT><span class="strong">AND_EL_FOLDL</span>
<DD>
<pre>
|- ∀l. AND_EL l ⇔ FOLDL $/\ T l
</pre>

<DT><span class="strong">AND_EL_FOLDR</span>
<DD>
<pre>
|- ∀l. AND_EL l ⇔ FOLDR $/\ T l
</pre>

<DT><span class="strong">OR_EL_FOLDL</span>
<DD>
<pre>
|- ∀l. OR_EL l ⇔ FOLDL $\/ F l
</pre>

<DT><span class="strong">OR_EL_FOLDR</span>
<DD>
<pre>
|- ∀l. OR_EL l ⇔ FOLDR $\/ F l
</pre>

<DT><span class="strong">IS_PREFIX_NIL</span>
<DD>
<pre>
|- ∀x. [] ≼ x ∧ (x ≼ [] ⇔ (x = []))
</pre>

<DT><span class="strong">IS_PREFIX_REFL</span>
<DD>
<pre>
|- ∀x. x ≼ x
</pre>

<DT><span class="strong">IS_PREFIX_ANTISYM</span>
<DD>
<pre>
|- ∀x y. x ≼ y ∧ y ≼ x ⇒ (x = y)
</pre>

<DT><span class="strong">IS_PREFIX_TRANS</span>
<DD>
<pre>
|- ∀x y z. y ≼ x ∧ z ≼ y ⇒ z ≼ x
</pre>

<DT><span class="strong">IS_PREFIX_BUTLAST</span>
<DD>
<pre>
|- ∀x y. FRONT (x::y) ≼ x::y
</pre>

<DT><span class="strong">IS_PREFIX_LENGTH</span>
<DD>
<pre>
|- ∀x y. x ≼ y ⇒ LENGTH x ≤ LENGTH y
</pre>

<DT><span class="strong">IS_PREFIX_LENGTH_ANTI</span>
<DD>
<pre>
|- ∀x y. x ≼ y ∧ (LENGTH x = LENGTH y) ⇔ (x = y)
</pre>

<DT><span class="strong">IS_PREFIX_SNOC</span>
<DD>
<pre>
|- ∀x y z. z ≼ SNOC x y ⇔ z ≼ y ∨ (z = SNOC x y)
</pre>

<DT><span class="strong">IS_PREFIX_APPEND1</span>
<DD>
<pre>
|- ∀a b c. a ++ b ≼ c ⇒ a ≼ c
</pre>

<DT><span class="strong">IS_PREFIX_APPEND2</span>
<DD>
<pre>
|- ∀a b c. a ≼ b ++ c ⇒ a ≼ b ∨ b ≼ a
</pre>

<DT><span class="strong">IS_PREFIX_APPENDS</span>
<DD>
<pre>
|- ∀a b c. a ++ b ≼ a ++ c ⇔ b ≼ c
</pre>

<DT><span class="strong">COUNT_LIST_GENLIST</span>
<DD>
<pre>
|- ∀n. COUNT_LIST n = GENLIST I n
</pre>

<DT><span class="strong">LENGTH_COUNT_LIST</span>
<DD>
<pre>
|- ∀n. LENGTH (COUNT_LIST n) = n
</pre>

<DT><span class="strong">EL_COUNT_LIST</span>
<DD>
<pre>
|- ∀m n. m < n ⇒ (EL m (COUNT_LIST n) = m)
</pre>

<DT><span class="strong">MEM_COUNT_LIST</span>
<DD>
<pre>
|- ∀m n. MEM m (COUNT_LIST n) ⇔ m < n
</pre>

<DT><span class="strong">COUNT_LIST_SNOC</span>
<DD>
<pre>
|- (COUNT_LIST 0 = []) ∧ ∀n. COUNT_LIST (SUC n) = SNOC n (COUNT_LIST n)
</pre>

<DT><span class="strong">COUNT_LIST_COUNT</span>
<DD>
<pre>
|- ∀n. LIST_TO_SET (COUNT_LIST n) = count n
</pre>

<DT><span class="strong">COUNT_LIST_ADD</span>
<DD>
<pre>
|- ∀n m. COUNT_LIST (n + m) = COUNT_LIST n ++ MAP (λn'. n' + n) (COUNT_LIST m)
</pre>

<DT><span class="strong">EL_DROP</span>
<DD>
<pre>
|- ∀m n l. m + n < LENGTH l ⇒ (EL m (DROP n l) = EL (m + n) l)
</pre>

<DT><span class="strong">SNOC_EL_TAKE</span>
<DD>
<pre>
|- ∀n l. n < LENGTH l ⇒ (SNOC (EL n l) (TAKE n l) = TAKE (SUC n) l)
</pre>

<DT><span class="strong">ZIP_TAKE_LEQ</span>
<DD>
<pre>
|- ∀n a b.
     n ≤ LENGTH a ∧ LENGTH a ≤ LENGTH b ⇒
     (ZIP (TAKE n a,TAKE n b) = TAKE n (ZIP (a,TAKE (LENGTH a) b)))
</pre>

<DT><span class="strong">ZIP_TAKE</span>
<DD>
<pre>
|- ∀n a b.
     n ≤ LENGTH a ∧ (LENGTH a = LENGTH b) ⇒
     (ZIP (TAKE n a,TAKE n b) = TAKE n (ZIP (a,b)))
</pre>

<DT><span class="strong">EL_TAKE</span>
<DD>
<pre>
|- ∀n x l. x < n ∧ n ≤ LENGTH l ⇒ (EL x (TAKE n l) = EL x l)
</pre>

<DT><span class="strong">ZIP_APPEND</span>
<DD>
<pre>
|- ∀a b c d.
     (LENGTH a = LENGTH b) ∧ (LENGTH c = LENGTH d) ⇒
     (ZIP (a,b) ++ ZIP (c,d) = ZIP (a ++ c,b ++ d))
</pre>

<DT><span class="strong">APPEND_ASSOC_CONS</span>
<DD>
<pre>
|- ∀l1 h l2 l3. l1 ++ h::l2 ++ l3 = l1 ++ h::(l2 ++ l3)
</pre>

<DT><span class="strong">APPEND_SNOC1</span>
<DD>
<pre>
|- ∀l1 x l2. SNOC x l1 ++ l2 = l1 ++ x::l2
</pre>

<DT><span class="strong">FOLDL_MAP2</span>
<DD>
<pre>
|- ∀f e g l. FOLDL f e (MAP g l) = FOLDL (λx y. f x (g y)) e l
</pre>

<DT><span class="strong">SPLITP_EVERY</span>
<DD>
<pre>
|- ∀P l. EVERY (λx. ¬P x) l ⇒ (SPLITP P l = (l,[]))
</pre>

<DT><span class="strong">MEM_FRONT</span>
<DD>
<pre>
|- ∀l e y. MEM y (FRONT (e::l)) ⇒ MEM y (e::l)
</pre>

<DT><span class="strong">FRONT_APPEND</span>
<DD>
<pre>
|- ∀l1 l2 e. FRONT (l1 ++ e::l2) = l1 ++ FRONT (e::l2)
</pre>

<DT><span class="strong">EL_FRONT</span>
<DD>
<pre>
|- ∀l n. n < LENGTH (FRONT l) ∧ ¬NULL l ⇒ (EL n (FRONT l) = EL n l)
</pre>

<DT><span class="strong">MEM_LAST</span>
<DD>
<pre>
|- ∀e l. MEM (LAST (e::l)) (e::l)
</pre>

<DT><span class="strong">DROP_CONS_EL</span>
<DD>
<pre>
|- ∀n l. n < LENGTH l ⇒ (DROP n l = EL n l::DROP (SUC n) l)
</pre>

<DT><span class="strong">MEM_LAST_FRONT</span>
<DD>
<pre>
|- ∀e l h. MEM e l ∧ e ≠ LAST (h::l) ⇒ MEM e (FRONT (h::l))
</pre>

<DT><span class="strong">LIST_ELEM_COUNT_THM</span>
<DD>
<pre>
|- (∀e. LIST_ELEM_COUNT e [] = 0) ∧
   (∀e l1 l2.
      LIST_ELEM_COUNT e (l1 ++ l2) =
      LIST_ELEM_COUNT e l1 + LIST_ELEM_COUNT e l2) ∧
   (∀e h l.
      (h = e) ⇒ (LIST_ELEM_COUNT e (h::l) = SUC (LIST_ELEM_COUNT e l))) ∧
   ∀e h l. h ≠ e ⇒ (LIST_ELEM_COUNT e (h::l) = LIST_ELEM_COUNT e l)
</pre>

<DT><span class="strong">LIST_ELEM_COUNT_MEM</span>
<DD>
<pre>
|- ∀e l. LIST_ELEM_COUNT e l > 0 ⇔ MEM e l
</pre>

<DT><span class="strong">REPLACE_ELEMENT_SEM</span>
<DD>
<pre>
|- (∀e n l. LENGTH (REPLACE_ELEMENT e n l) = LENGTH l) ∧
   ∀e n l p.
     p < LENGTH l ⇒
     (EL p (REPLACE_ELEMENT e n l) = if p = n then e else EL p l)
</pre>

<DT><span class="strong">COUNT_LIST_compute</span>
<DD>
<pre>
|- ∀n. COUNT_LIST n = COUNT_LIST_AUX n []
</pre>

<DT><span class="strong">SPLITP_compute</span>
<DD>
<pre>
|- SPLITP = SPLITP_AUX []
</pre>

<DT><span class="strong">IS_SUFFIX_compute</span>
<DD>
<pre>
|- ∀l1 l2. IS_SUFFIX l1 l2 ⇔ REVERSE l2 ≼ REVERSE l1
</pre>

<DT><span class="strong">REPLACE_ELEMENT_compute</span>
<DD>
<pre>
|- (∀e n. REPLACE_ELEMENT e n [] = []) ∧
   (∀e x l. REPLACE_ELEMENT e 0 (x::l) = e::l) ∧
   (∀e n x l.
      REPLACE_ELEMENT e (NUMERAL (BIT1 n)) (x::l) =
      x::REPLACE_ELEMENT e (NUMERAL (BIT1 n) − 1) l) ∧
   ∀e n x l.
     REPLACE_ELEMENT e (NUMERAL (BIT2 n)) (x::l) =
     x::REPLACE_ELEMENT e (NUMERAL (BIT1 n)) l
</pre>

<DT><span class="strong">SEG_compute</span>
<DD>
<pre>
|- (∀k l. SEG 0 k l = []) ∧
   (∀m x l.
      SEG (NUMERAL (BIT1 m)) 0 (x::l) = x::SEG (NUMERAL (BIT1 m) − 1) 0 l) ∧
   (∀m x l. SEG (NUMERAL (BIT2 m)) 0 (x::l) = x::SEG (NUMERAL (BIT1 m)) 0 l) ∧
   (∀m k x l.
      SEG (NUMERAL (BIT1 m)) (NUMERAL (BIT1 k)) (x::l) =
      SEG (NUMERAL (BIT1 m)) (NUMERAL (BIT1 k) − 1) l) ∧
   (∀m k x l.
      SEG (NUMERAL (BIT2 m)) (NUMERAL (BIT1 k)) (x::l) =
      SEG (NUMERAL (BIT2 m)) (NUMERAL (BIT1 k) − 1) l) ∧
   (∀m k x l.
      SEG (NUMERAL (BIT1 m)) (NUMERAL (BIT2 k)) (x::l) =
      SEG (NUMERAL (BIT1 m)) (NUMERAL (BIT1 k)) l) ∧
   ∀m k x l.
     SEG (NUMERAL (BIT2 m)) (NUMERAL (BIT2 k)) (x::l) =
     SEG (NUMERAL (BIT2 m)) (NUMERAL (BIT1 k)) l
</pre>

<DT><span class="strong">BUTLASTN_compute</span>
<DD>
<pre>
|- ∀n l.
     BUTLASTN n l =
     (let m = LENGTH l
      in
        if n ≤ m then TAKE (m − n) l else FAIL BUTLASTN longer than list n l)
</pre>

<DT><span class="strong">LASTN_compute</span>
<DD>
<pre>
|- ∀n l.
     LASTN n l =
     (let m = LENGTH l
      in
        if n ≤ m then DROP (m − n) l else FAIL LASTN longer than list n l)
</pre>

</DL>



<hr>
</body>
</html>
