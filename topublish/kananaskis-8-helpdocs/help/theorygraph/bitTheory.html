<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: bit</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "bit"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "ASCIInumbersTheory.html"><span class="strong">ASCIInumbers</span></a>

<h1>Signature</h1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr>
    <th>
    Constant
    <th>
    Type<tr><td> <span class="strong">BIT</span> <td> :num -> num -> bool
    <tr><td> <span class="strong">BITS</span> <td> :num -> num -> num -> num
    <tr><td> <span class="strong">BITV</span> <td> :num -> num -> num
    <tr><td>
        <span class="strong">BITWISE</span>
        <td>
        :num -> (bool -> bool -> bool) -> num -> num -> num
    <tr><td>
        <span class="strong">BIT_MODIFY</span>
        <td>
        :num -> (num -> bool -> bool) -> num -> num
    <tr><td> <span class="strong">BIT_REVERSE</span> <td> :num -> num -> num
    <tr><td>
        <span class="strong">BOOLIFY</span>
        <td>
        :num -> num -> bitstring -> bitstring
    <tr><td>
        <span class="strong">DIVMOD_2EXP</span>
        <td>
        :num -> num -> num # num
    <tr><td> <span class="strong">LOG2</span> <td> :num -> num
    <tr><td> <span class="strong">LOWEST_SET_BIT</span> <td> :num -> num
    <tr><td> <span class="strong">LSB</span> <td> :num -> bool
    <tr><td>
        <span class="strong">MOD_2EXP_EQ</span>
        <td>
        :num -> num -> num -> bool
    <tr><td> <span class="strong">MOD_2EXP_MAX</span> <td> :num -> num -> bool
    <tr><td> <span class="strong">SBIT</span> <td> :bool -> num -> num
    <tr><td>
        <span class="strong">SIGN_EXTEND</span>
        <td>
        :num -> num -> num -> num
    <tr><td> <span class="strong">SLICE</span> <td> :num -> num -> num -> num
    <tr><td> <span class="strong">TIMES_2EXP</span> <td> :num -> num -> num

</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">TIMES_2EXP_def</span>
<DD>
<pre>
|- ∀x n. TIMES_2EXP x n = n * 2 ** x
</pre>

<DT><span class="strong">DIVMOD_2EXP_def</span>
<DD>
<pre>
|- ∀x n. DIVMOD_2EXP x n = (n DIV 2 ** x,n MOD 2 ** x)
</pre>

<DT><span class="strong">SBIT_def</span>
<DD>
<pre>
|- ∀b n. SBIT b n = if b then 2 ** n else 0
</pre>

<DT><span class="strong">BITS_def</span>
<DD>
<pre>
|- ∀h l n. BITS h l n = MOD_2EXP (SUC h − l) (DIV_2EXP l n)
</pre>

<DT><span class="strong">BITV_def</span>
<DD>
<pre>
|- ∀n b. BITV n b = BITS b b n
</pre>

<DT><span class="strong">BIT_def</span>
<DD>
<pre>
|- ∀b n. BIT b n ⇔ (BITS b b n = 1)
</pre>

<DT><span class="strong">SLICE_def</span>
<DD>
<pre>
|- ∀h l n. SLICE h l n = MOD_2EXP (SUC h) n − MOD_2EXP l n
</pre>

<DT><span class="strong">LSB_def</span>
<DD>
<pre>
|- LSB = BIT 0
</pre>

<DT><span class="strong">LOG2_def</span>
<DD>
<pre>
|- LOG2 = LOG 2
</pre>

<DT><span class="strong">LOWEST_SET_BIT_def</span>
<DD>
<pre>
|- ∀n. LOWEST_SET_BIT n = LEAST i. BIT i n
</pre>

<DT><span class="strong">BIT_REVERSE_def</span>
<DD>
<pre>
|- (∀x. BIT_REVERSE 0 x = 0) ∧
   ∀n x. BIT_REVERSE (SUC n) x = BIT_REVERSE n x * 2 + SBIT (BIT n x) 0
</pre>

<DT><span class="strong">BITWISE_def</span>
<DD>
<pre>
|- (∀op x y. BITWISE 0 op x y = 0) ∧
   ∀n op x y.
     BITWISE (SUC n) op x y =
     BITWISE n op x y + SBIT (op (BIT n x) (BIT n y)) n
</pre>

<DT><span class="strong">BIT_MODIFY_def</span>
<DD>
<pre>
|- (∀f x. BIT_MODIFY 0 f x = 0) ∧
   ∀n f x. BIT_MODIFY (SUC n) f x = BIT_MODIFY n f x + SBIT (f n (BIT n x)) n
</pre>

<DT><span class="strong">SIGN_EXTEND_def</span>
<DD>
<pre>
|- ∀l h n.
     SIGN_EXTEND l h n =
     (let m = n MOD 2 ** l
      in
        if BIT (l − 1) n then 2 ** h − 2 ** l + m else m)
</pre>

<DT><span class="strong">MOD_2EXP_EQ_def</span>
<DD>
<pre>
|- ∀n a b. MOD_2EXP_EQ n a b ⇔ (MOD_2EXP n a = MOD_2EXP n b)
</pre>

<DT><span class="strong">MOD_2EXP_MAX_def</span>
<DD>
<pre>
|- ∀n a. MOD_2EXP_MAX n a ⇔ (MOD_2EXP n a = 2 ** n − 1)
</pre>

<DT><span class="strong">BOOLIFY_def</span>
<DD>
<pre>
|- (∀m a. BOOLIFY 0 m a = a) ∧
   ∀n m a. BOOLIFY (SUC n) m a = BOOLIFY n (DIV2 m) (ODD m::a)
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">BOOLIFY_def_compute</span>
<DD>
<pre>
|- (∀m a. BOOLIFY 0 m a = a) ∧
   (∀n m a.
      BOOLIFY (NUMERAL (BIT1 n)) m a =
      BOOLIFY (NUMERAL (BIT1 n) − 1) (DIV2 m) (ODD m::a)) ∧
   ∀n m a.
     BOOLIFY (NUMERAL (BIT2 n)) m a =
     BOOLIFY (NUMERAL (BIT1 n)) (DIV2 m) (ODD m::a)
</pre>

<DT><span class="strong">TRANS_THMS</span>
<DD>
<pre>
|- (∀m n p. m < n ∧ n < p ⇒ m < p) ∧ (∀m n p. m ≤ n ∧ n < p ⇒ m < p) ∧
   (∀m n p. m < n ∧ n ≤ p ⇒ m < p) ∧ ∀m n p. m ≤ n ∧ n ≤ p ⇒ m ≤ p
</pre>

<DT><span class="strong">LESS_MULT_MONO2</span>
<DD>
<pre>
|- ∀a b x y. a < x ∧ b < y ⇒ a * b < x * y
</pre>

<DT><span class="strong">LOG2_UNIQUE</span>
<DD>
<pre>
|- ∀n p. 2 ** p ≤ n ∧ n < 2 ** SUC p ⇒ (LOG2 n = p)
</pre>

<DT><span class="strong">LOG2_TWOEXP</span>
<DD>
<pre>
|- ∀n. LOG2 (2 ** n) = n
</pre>

<DT><span class="strong">DIVMOD_2EXP</span>
<DD>
<pre>
|- ∀x n. DIVMOD_2EXP x n = (DIV_2EXP x n,MOD_2EXP x n)
</pre>

<DT><span class="strong">SUC_SUB</span>
<DD>
<pre>
|- SUC a − a = 1
</pre>

<DT><span class="strong">DIV_MULT_1</span>
<DD>
<pre>
|- ∀r n. r < n ⇒ ((n + r) DIV n = 1)
</pre>

<DT><span class="strong">NOT_ZERO_ADD1</span>
<DD>
<pre>
|- ∀m. m ≠ 0 ⇒ ∃p. m = SUC p
</pre>

<DT><span class="strong">ZERO_LT_TWOEXP</span>
<DD>
<pre>
|- ∀n. 0 < 2 ** n
</pre>

<DT><span class="strong">ONE_LE_TWOEXP</span>
<DD>
<pre>
|- ∀n. 1 ≤ 2 ** n
</pre>

<DT><span class="strong">TWOEXP_NOT_ZERO</span>
<DD>
<pre>
|- ∀n. 2 ** n ≠ 0
</pre>

<DT><span class="strong">MOD_2EXP_LT</span>
<DD>
<pre>
|- ∀n k. k MOD 2 ** n < 2 ** n
</pre>

<DT><span class="strong">TWOEXP_DIVISION</span>
<DD>
<pre>
|- ∀n k. k = k DIV 2 ** n * 2 ** n + k MOD 2 ** n
</pre>

<DT><span class="strong">TWOEXP_MONO</span>
<DD>
<pre>
|- ∀a b. a < b ⇒ 2 ** a < 2 ** b
</pre>

<DT><span class="strong">TWOEXP_MONO2</span>
<DD>
<pre>
|- ∀a b. a ≤ b ⇒ 2 ** a ≤ 2 ** b
</pre>

<DT><span class="strong">EXP_SUB_LESS_EQ</span>
<DD>
<pre>
|- ∀a b. 2 ** (a − b) ≤ 2 ** a
</pre>

<DT><span class="strong">MOD_LEQ</span>
<DD>
<pre>
|- ∀a b. 0 < b ⇒ a MOD b ≤ a
</pre>

<DT><span class="strong">BITS_THM</span>
<DD>
<pre>
|- ∀h l n. BITS h l n = (n DIV 2 ** l) MOD 2 ** (SUC h − l)
</pre>

<DT><span class="strong">BITSLT_THM</span>
<DD>
<pre>
|- ∀h l n. BITS h l n < 2 ** (SUC h − l)
</pre>

<DT><span class="strong">BITSLT_THM2</span>
<DD>
<pre>
|- ∀h l n. BITS h l n < 2 ** SUC h
</pre>

<DT><span class="strong">BITS_THM2</span>
<DD>
<pre>
|- ∀h l n. BITS h l n = n MOD 2 ** SUC h DIV 2 ** l
</pre>

<DT><span class="strong">BITS_LEQ</span>
<DD>
<pre>
|- ∀h l n. BITS h l n ≤ n
</pre>

<DT><span class="strong">BITS_COMP_THM</span>
<DD>
<pre>
|- ∀h1 l1 h2 l2 n.
     h2 + l1 ≤ h1 ⇒ (BITS h2 l2 (BITS h1 l1 n) = BITS (h2 + l1) (l2 + l1) n)
</pre>

<DT><span class="strong">BITS_DIV_THM</span>
<DD>
<pre>
|- ∀h l x n. BITS h l x DIV 2 ** n = BITS h (l + n) x
</pre>

<DT><span class="strong">BITS_LT_HIGH</span>
<DD>
<pre>
|- ∀h l n. n < 2 ** SUC h ⇒ (BITS h l n = n DIV 2 ** l)
</pre>

<DT><span class="strong">BITS_ZERO</span>
<DD>
<pre>
|- ∀h l n. h < l ⇒ (BITS h l n = 0)
</pre>

<DT><span class="strong">BITS_ZERO2</span>
<DD>
<pre>
|- ∀h l. BITS h l 0 = 0
</pre>

<DT><span class="strong">BITS_ZERO3</span>
<DD>
<pre>
|- ∀h n. BITS h 0 n = n MOD 2 ** SUC h
</pre>

<DT><span class="strong">BITS_ZERO4</span>
<DD>
<pre>
|- ∀h l a. l ≤ h ⇒ (BITS h l (a * 2 ** l) = BITS (h − l) 0 a)
</pre>

<DT><span class="strong">BITS_ZEROL</span>
<DD>
<pre>
|- ∀h a. a < 2 ** SUC h ⇒ (BITS h 0 a = a)
</pre>

<DT><span class="strong">BITS_LOG2_ZERO_ID</span>
<DD>
<pre>
|- ∀n. 0 < n ⇒ (BITS (LOG2 n) 0 n = n)
</pre>

<DT><span class="strong">BITS_LT_LOW</span>
<DD>
<pre>
|- ∀h l n. n < 2 ** l ⇒ (BITS h l n = 0)
</pre>

<DT><span class="strong">BIT_ZERO</span>
<DD>
<pre>
|- ∀b. ¬BIT b 0
</pre>

<DT><span class="strong">BIT_B</span>
<DD>
<pre>
|- ∀b. BIT b (2 ** b)
</pre>

<DT><span class="strong">BIT_B_NEQ</span>
<DD>
<pre>
|- ∀a b. a ≠ b ⇒ ¬BIT a (2 ** b)
</pre>

<DT><span class="strong">BITS_COMP_THM2</span>
<DD>
<pre>
|- ∀h1 l1 h2 l2 n.
     BITS h2 l2 (BITS h1 l1 n) = BITS (MIN h1 (h2 + l1)) (l2 + l1) n
</pre>

<DT><span class="strong">NOT_MOD2_LEM</span>
<DD>
<pre>
|- ∀n. n MOD 2 ≠ 0 ⇔ (n MOD 2 = 1)
</pre>

<DT><span class="strong">NOT_MOD2_LEM2</span>
<DD>
<pre>
|- ∀n. n MOD 2 ≠ 1 ⇔ (n MOD 2 = 0)
</pre>

<DT><span class="strong">ODD_MOD2_LEM</span>
<DD>
<pre>
|- ∀n. ODD n ⇔ (n MOD 2 = 1)
</pre>

<DT><span class="strong">DIV_MULT_THM</span>
<DD>
<pre>
|- ∀x n. n DIV 2 ** x * 2 ** x = n − n MOD 2 ** x
</pre>

<DT><span class="strong">DIV_MULT_THM2</span>
<DD>
<pre>
|- ∀n. 2 * (n DIV 2) = n − n MOD 2
</pre>

<DT><span class="strong">LESS_EQ_EXP_MULT</span>
<DD>
<pre>
|- ∀a b. a ≤ b ⇒ ∃p. 2 ** b = p * 2 ** a
</pre>

<DT><span class="strong">SLICE_THM</span>
<DD>
<pre>
|- ∀n h l. SLICE h l n = BITS h l n * 2 ** l
</pre>

<DT><span class="strong">SLICELT_THM</span>
<DD>
<pre>
|- ∀h l n. SLICE h l n < 2 ** SUC h
</pre>

<DT><span class="strong">BITS_SLICE_THM</span>
<DD>
<pre>
|- ∀h l n. BITS h l (SLICE h l n) = BITS h l n
</pre>

<DT><span class="strong">BITS_SLICE_THM2</span>
<DD>
<pre>
|- ∀h h2 l n. h ≤ h2 ⇒ (BITS h2 l (SLICE h l n) = BITS h l n)
</pre>

<DT><span class="strong">SLICE_ZERO_THM</span>
<DD>
<pre>
|- ∀n h. SLICE h 0 n = BITS h 0 n
</pre>

<DT><span class="strong">MOD_2EXP_MONO</span>
<DD>
<pre>
|- ∀n h l. l ≤ h ⇒ n MOD 2 ** l ≤ n MOD 2 ** SUC h
</pre>

<DT><span class="strong">SLICE_COMP_THM</span>
<DD>
<pre>
|- ∀h m l n.
     SUC m ≤ h ∧ l ≤ m ⇒ (SLICE h (SUC m) n + SLICE m l n = SLICE h l n)
</pre>

<DT><span class="strong">SLICE_COMP_RWT</span>
<DD>
<pre>
|- ∀h m' m l n.
     l ≤ m ∧ (m' = m + 1) ∧ m < h ⇒ (SLICE h m' n + SLICE m l n = SLICE h l n)
</pre>

<DT><span class="strong">SLICE_ZERO</span>
<DD>
<pre>
|- ∀h l n. h < l ⇒ (SLICE h l n = 0)
</pre>

<DT><span class="strong">SLICE_ZERO2</span>
<DD>
<pre>
|- ∀l h. SLICE h l 0 = 0
</pre>

<DT><span class="strong">BITS_SUM</span>
<DD>
<pre>
|- ∀h l a b. b < 2 ** l ⇒ (BITS h l (a * 2 ** l + b) = BITS h l (a * 2 ** l))
</pre>

<DT><span class="strong">BITS_SUM2</span>
<DD>
<pre>
|- ∀h l a b. BITS h l (a * 2 ** SUC h + b) = BITS h l b
</pre>

<DT><span class="strong">SLICE_COMP_THM2</span>
<DD>
<pre>
|- ∀h l x y n. h ≤ x ∧ y ≤ l ⇒ (SLICE h l (SLICE x y n) = SLICE h l n)
</pre>

<DT><span class="strong">BITS_SUM3</span>
<DD>
<pre>
|- ∀h a b. BITS h 0 (BITS h 0 a + BITS h 0 b) = BITS h 0 (a + b)
</pre>

<DT><span class="strong">BITS_MUL</span>
<DD>
<pre>
|- ∀h a b. BITS h 0 (BITS h 0 a * BITS h 0 b) = BITS h 0 (a * b)
</pre>

<DT><span class="strong">BIT_COMP_THM3</span>
<DD>
<pre>
|- ∀h m l n.
     SUC m ≤ h ∧ l ≤ m ⇒
     (BITS h (SUC m) n * 2 ** (SUC m − l) + BITS m l n = BITS h l n)
</pre>

<DT><span class="strong">NOT_BIT</span>
<DD>
<pre>
|- ∀n a. ¬BIT n a ⇔ (BITS n n a = 0)
</pre>

<DT><span class="strong">NOT_BITS</span>
<DD>
<pre>
|- ∀n a. BITS n n a ≠ 0 ⇔ (BITS n n a = 1)
</pre>

<DT><span class="strong">NOT_BITS2</span>
<DD>
<pre>
|- ∀n a. BITS n n a ≠ 1 ⇔ (BITS n n a = 0)
</pre>

<DT><span class="strong">BIT_SLICE</span>
<DD>
<pre>
|- ∀n a b. (BIT n a ⇔ BIT n b) ⇔ (SLICE n n a = SLICE n n b)
</pre>

<DT><span class="strong">BIT_SLICE_LEM</span>
<DD>
<pre>
|- ∀y x n. SBIT (BIT x n) (x + y) = SLICE x x n * 2 ** y
</pre>

<DT><span class="strong">BIT_SLICE_THM</span>
<DD>
<pre>
|- ∀x n. SBIT (BIT x n) x = SLICE x x n
</pre>

<DT><span class="strong">BIT_SLICE_THM2</span>
<DD>
<pre>
|- ∀b n. BIT b n ⇔ (SLICE b b n = 2 ** b)
</pre>

<DT><span class="strong">BIT_SLICE_THM3</span>
<DD>
<pre>
|- ∀b n. ¬BIT b n ⇔ (SLICE b b n = 0)
</pre>

<DT><span class="strong">BIT_SLICE_THM4</span>
<DD>
<pre>
|- ∀b h l n. BIT b (SLICE h l n) ⇔ l ≤ b ∧ b ≤ h ∧ BIT b n
</pre>

<DT><span class="strong">SBIT_DIV</span>
<DD>
<pre>
|- ∀b m n. n < m ⇒ (SBIT b (m − n) = SBIT b m DIV 2 ** n)
</pre>

<DT><span class="strong">BITS_SUC</span>
<DD>
<pre>
|- ∀h l n.
     l ≤ SUC h ⇒
     (SBIT (BIT (SUC h) n) (SUC h − l) + BITS h l n = BITS (SUC h) l n)
</pre>

<DT><span class="strong">BITS_SUC_THM</span>
<DD>
<pre>
|- ∀h l n.
     BITS (SUC h) l n =
     if SUC h < l then 0 else SBIT (BIT (SUC h) n) (SUC h − l) + BITS h l n
</pre>

<DT><span class="strong">BIT_BITS_THM</span>
<DD>
<pre>
|- ∀h l a b.
     (∀x. l ≤ x ∧ x ≤ h ⇒ (BIT x a ⇔ BIT x b)) ⇔ (BITS h l a = BITS h l b)
</pre>

<DT><span class="strong">BITS_ZERO5</span>
<DD>
<pre>
|- ∀n m. (∀i. i ≤ n ⇒ ¬BIT i m) ⇒ (BITS n 0 m = 0)
</pre>

<DT><span class="strong">LSB_ODD</span>
<DD>
<pre>
|- LSB = ODD
</pre>

<DT><span class="strong">BITV_THM</span>
<DD>
<pre>
|- ∀b n. BITV n b = SBIT (BIT b n) 0
</pre>

<DT><span class="strong">ADD_BIT0</span>
<DD>
<pre>
|- ∀m n. BIT 0 (m + n) ⇔ (BIT 0 m ⇎ BIT 0 n)
</pre>

<DT><span class="strong">ADD_BITS_SUC</span>
<DD>
<pre>
|- ∀n a b.
     BITS (SUC n) (SUC n) (a + b) =
     (BITS (SUC n) (SUC n) a + BITS (SUC n) (SUC n) b +
      BITS (SUC n) (SUC n) (BITS n 0 a + BITS n 0 b)) MOD 2
</pre>

<DT><span class="strong">ADD_BIT_SUC</span>
<DD>
<pre>
|- ∀n a b.
     BIT (SUC n) (a + b) ⇔
     if BIT (SUC n) (BITS n 0 a + BITS n 0 b) then
       BIT (SUC n) a ⇔ BIT (SUC n) b
     else
       BIT (SUC n) a ⇎ BIT (SUC n) b
</pre>

<DT><span class="strong">BITWISE_LT_2EXP</span>
<DD>
<pre>
|- ∀n op a b. BITWISE n op a b < 2 ** n
</pre>

<DT><span class="strong">BITWISE_THM</span>
<DD>
<pre>
|- ∀x n op a b. x < n ⇒ (BIT x (BITWISE n op a b) ⇔ op (BIT x a) (BIT x b))
</pre>

<DT><span class="strong">BITWISE_COR</span>
<DD>
<pre>
|- ∀x n op a b.
     x < n ⇒
     op (BIT x a) (BIT x b) ⇒
     ((BITWISE n op a b DIV 2 ** x) MOD 2 = 1)
</pre>

<DT><span class="strong">BITWISE_NOT_COR</span>
<DD>
<pre>
|- ∀x n op a b.
     x < n ⇒
     ¬op (BIT x a) (BIT x b) ⇒
     ((BITWISE n op a b DIV 2 ** x) MOD 2 = 0)
</pre>

<DT><span class="strong">BITWISE_BITS</span>
<DD>
<pre>
|- ∀wl op a b.
     BITWISE (SUC wl) op (BITS wl 0 a) (BITS wl 0 b) = BITWISE (SUC wl) op a b
</pre>

<DT><span class="strong">NOT_BIT_GT_TWOEXP</span>
<DD>
<pre>
|- ∀i n. n < 2 ** i ⇒ ¬BIT i n
</pre>

<DT><span class="strong">BIT_IMP_GE_TWOEXP</span>
<DD>
<pre>
|- ∀i n. BIT i n ⇒ 2 ** i ≤ n
</pre>

<DT><span class="strong">BITWISE_ONE_COMP_LEM</span>
<DD>
<pre>
|- ∀n a b. BITWISE (SUC n) (λx y. ¬x) a b = 2 ** SUC n − 1 − BITS n 0 a
</pre>

<DT><span class="strong">BIT_COMPLEMENT</span>
<DD>
<pre>
|- ∀n i a.
     BIT i (2 ** n − a MOD 2 ** n) ⇔
     (a MOD 2 ** n = 0) ∧ (i = n) ∨
     a MOD 2 ** n ≠ 0 ∧ i < n ∧ ¬BIT i (a MOD 2 ** n − 1)
</pre>

<DT><span class="strong">BIT_OF_BITS_THM</span>
<DD>
<pre>
|- ∀n h l a. l + n ≤ h ⇒ (BIT n (BITS h l a) ⇔ BIT (l + n) a)
</pre>

<DT><span class="strong">BIT_SHIFT_THM</span>
<DD>
<pre>
|- ∀n a s. BIT (n + s) (a * 2 ** s) ⇔ BIT n a
</pre>

<DT><span class="strong">BIT_SHIFT_THM2</span>
<DD>
<pre>
|- ∀n a s. s ≤ n ⇒ (BIT n (a * 2 ** s) ⇔ BIT (n − s) a)
</pre>

<DT><span class="strong">BIT_SHIFT_THM3</span>
<DD>
<pre>
|- ∀n a s. n < s ⇒ ¬BIT n (a * 2 ** s)
</pre>

<DT><span class="strong">BIT_OF_BITS_THM2</span>
<DD>
<pre>
|- ∀h l x n. h < l + x ⇒ ¬BIT x (BITS h l n)
</pre>

<DT><span class="strong">BIT_DIV2</span>
<DD>
<pre>
|- ∀n i. BIT n (i DIV 2) ⇔ BIT (SUC n) i
</pre>

<DT><span class="strong">BIT_SHIFT_THM4</span>
<DD>
<pre>
|- ∀n i a. BIT i (a DIV 2 ** n) ⇔ BIT (i + n) a
</pre>

<DT><span class="strong">DIV_LT</span>
<DD>
<pre>
|- ∀n m a. n < m ∧ a < 2 ** m ⇒ a DIV 2 ** n < 2 ** m
</pre>

<DT><span class="strong">MOD_ZERO_GT</span>
<DD>
<pre>
|- ∀n a. a ≠ 0 ∧ (a MOD 2 ** n = 0) ⇒ 2 ** n ≤ a
</pre>

<DT><span class="strong">DIV_GT0</span>
<DD>
<pre>
|- ∀a b. b ≤ a ∧ 0 < b ⇒ 0 < a DIV b
</pre>

<DT><span class="strong">DIV_SUB1</span>
<DD>
<pre>
|- ∀a b.
     2 ** b ≤ a ∧ (a MOD 2 ** b = 0) ⇒ (a DIV 2 ** b − 1 = (a − 1) DIV 2 ** b)
</pre>

<DT><span class="strong">BIT_EXP_SUB1</span>
<DD>
<pre>
|- ∀b n. BIT b (2 ** n − 1) ⇔ b < n
</pre>

<DT><span class="strong">BIT_SHIFT_THM5</span>
<DD>
<pre>
|- ∀n m i a.
     i + n < m ∧ a < 2 ** m ⇒
     (BIT i
        (2 ** m −
         (a DIV 2 ** n + if a MOD 2 ** n = 0 then 0 else 1) MOD 2 ** m) ⇔
      BIT (i + n) (2 ** m − a MOD 2 ** m))
</pre>

<DT><span class="strong">SBIT_MULT</span>
<DD>
<pre>
|- ∀b m n. SBIT b n * 2 ** m = SBIT b (n + m)
</pre>

<DT><span class="strong">BITWISE_EVAL</span>
<DD>
<pre>
|- ∀n op a b.
     BITWISE (SUC n) op a b =
     2 * BITWISE n op (a DIV 2) (b DIV 2) + SBIT (op (LSB a) (LSB b)) 0
</pre>

<DT><span class="strong">MOD_PLUS_RIGHT</span>
<DD>
<pre>
|- ∀n. 0 < n ⇒ ∀j k. (j + k MOD n) MOD n = (j + k) MOD n
</pre>

<DT><span class="strong">MOD_PLUS_LEFT</span>
<DD>
<pre>
|- ∀n. 0 < n ⇒ ∀j k. (k MOD n + j) MOD n = (k + j) MOD n
</pre>

<DT><span class="strong">MOD_PLUS_1</span>
<DD>
<pre>
|- ∀n. 0 < n ⇒ ∀x. ((x + 1) MOD n = 0) ⇔ (x MOD n + 1 = n)
</pre>

<DT><span class="strong">MOD_ADD_1</span>
<DD>
<pre>
|- ∀n. 0 < n ⇒ ∀x. (x + 1) MOD n ≠ 0 ⇒ ((x + 1) MOD n = x MOD n + 1)
</pre>

<DT><span class="strong">BIT_REVERSE_THM</span>
<DD>
<pre>
|- ∀x n a. x < n ⇒ (BIT x (BIT_REVERSE n a) ⇔ BIT (n − 1 − x) a)
</pre>

<DT><span class="strong">LOG2_LE_MONO</span>
<DD>
<pre>
|- ∀x y. 0 < x ⇒ x ≤ y ⇒ LOG2 x ≤ LOG2 y
</pre>

<DT><span class="strong">TWOEXP_LE_IMP_LE_LOG2</span>
<DD>
<pre>
|- (∀x y. 2 ** x ≤ y ⇒ x ≤ LOG2 y) ∧ ∀y x. 0 < x ⇒ x ≤ 2 ** y ⇒ LOG2 x ≤ y
</pre>

<DT><span class="strong">NOT_BIT_GT_LOG2</span>
<DD>
<pre>
|- ∀i n. LOG2 n < i ⇒ ¬BIT i n
</pre>

<DT><span class="strong">NOT_BIT_GT_BITWISE</span>
<DD>
<pre>
|- ∀i n op a b. n ≤ i ⇒ ¬BIT i (BITWISE n op a b)
</pre>

<DT><span class="strong">LT_TWOEXP</span>
<DD>
<pre>
|- ∀x n. x < 2 ** n ⇔ (x = 0) ∨ LOG2 x < n
</pre>

<DT><span class="strong">BIT_MODIFY_THM</span>
<DD>
<pre>
|- ∀x n f a. x < n ⇒ (BIT x (BIT_MODIFY n f a) ⇔ f x (BIT x a))
</pre>

<DT><span class="strong">BIT_SIGN_EXTEND</span>
<DD>
<pre>
|- ∀l h n i.
     l ≠ 0 ⇒
     (BIT i (SIGN_EXTEND l h n) ⇔
      if l ≤ h ⇒ i < l then BIT i (n MOD 2 ** l) else i < h ∧ BIT (l − 1) n)
</pre>

<DT><span class="strong">BIT_LOG2</span>
<DD>
<pre>
|- ∀n. n ≠ 0 ⇒ BIT (LOG2 n) n
</pre>

<DT><span class="strong">EXISTS_BIT_IN_RANGE</span>
<DD>
<pre>
|- ∀a b n. n ≠ 0 ∧ 2 ** a ≤ n ∧ n < 2 ** b ⇒ ∃i. a ≤ i ∧ i < b ∧ BIT i n
</pre>

<DT><span class="strong">EXISTS_BIT_LT</span>
<DD>
<pre>
|- ∀b n. n ≠ 0 ∧ n < 2 ** b ⇒ ∃i. i < b ∧ BIT i n
</pre>

<DT><span class="strong">LEAST_THM</span>
<DD>
<pre>
|- ∀n P. (∀m. m < n ⇒ ¬P m) ∧ P n ⇒ ($LEAST P = n)
</pre>

<DT><span class="strong">BIT_num_from_bin_list</span>
<DD>
<pre>
|- ∀x l.
     EVERY ($> 2) l ∧ x < LENGTH l ⇒
     (BIT x (num_from_bin_list l) ⇔ (EL x l = 1))
</pre>

<DT><span class="strong">BIT_num_from_bin_string</span>
<DD>
<pre>
|- ∀x s.
     EVERY ($> 2 o UNHEX) s ∧ x < STRLEN s ⇒
     (BIT x (num_from_bin_string s) ⇔
      (UNHEX (SUB (s,PRE (STRLEN s − x))) = 1))
</pre>

<DT><span class="strong">EL_num_to_bin_list</span>
<DD>
<pre>
|- ∀x n.
     x < LENGTH (num_to_bin_list n) ⇒ (EL x (num_to_bin_list n) = BITV n x)
</pre>

<DT><span class="strong">SUB_num_to_bin_string</span>
<DD>
<pre>
|- ∀x n.
     x < STRLEN (num_to_bin_string n) ⇒
     (SUB (num_to_bin_string n,x) =
      HEX (BITV n (PRE (STRLEN (num_to_bin_string n) − x))))
</pre>

<DT><span class="strong">num_bin_list</span>
<DD>
<pre>
|- num_from_bin_list o num_to_bin_list = I
</pre>

<DT><span class="strong">num_oct_list</span>
<DD>
<pre>
|- num_from_oct_list o num_to_oct_list = I
</pre>

<DT><span class="strong">num_dec_list</span>
<DD>
<pre>
|- num_from_dec_list o num_to_dec_list = I
</pre>

<DT><span class="strong">num_hex_list</span>
<DD>
<pre>
|- num_from_hex_list o num_to_hex_list = I
</pre>

<DT><span class="strong">num_bin_string</span>
<DD>
<pre>
|- num_from_bin_string o num_to_bin_string = I
</pre>

<DT><span class="strong">num_oct_string</span>
<DD>
<pre>
|- num_from_oct_string o num_to_oct_string = I
</pre>

<DT><span class="strong">num_dec_string</span>
<DD>
<pre>
|- toNum o toString = I
</pre>

<DT><span class="strong">num_hex_string</span>
<DD>
<pre>
|- num_from_hex_string o num_to_hex_string = I
</pre>

</DL>



<hr>
</body>
</html>
