<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: fcp</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "fcp"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "quotient_sumTheory.html"><span class="strong">quotient_sum</span></a>&nbsp;&nbsp;
    <a href = "quotient_pairTheory.html"><span class="strong">quotient_pair</span></a>&nbsp;&nbsp;
    <a href = "quotient_optionTheory.html"><span class="strong">quotient_option</span></a>&nbsp;&nbsp;
    <a href = "quotient_listTheory.html"><span class="strong">quotient_list</span></a>

<h1>Signature</h1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr> <th> Type <th> Arity<tr><td> <span class="strong">bit0</span> <td> 1
    <tr><td> <span class="strong">bit1</span> <td> 1
    <tr><td> <span class="strong">cart</span> <td> 2
    <tr><td> <span class="strong">finite_image</span> <td> 1
    <tr><td> <span class="strong">sub1</span> <td> 1
    <tr>
    <th>
    Constant
    <th>
    Type<tr><td> <span class="strong">:+</span> <td> :num -> Œ± -> Œ±[Œ≤] -> Œ±[Œ≤]
    <tr><td> <span class="strong">BIT0A</span> <td> :Œ± -> Œ± bit0
    <tr><td> <span class="strong">BIT0B</span> <td> :Œ± -> Œ± bit0
    <tr><td> <span class="strong">BIT1A</span> <td> :Œ± -> Œ± bit1
    <tr><td> <span class="strong">BIT1B</span> <td> :Œ± -> Œ± bit1
    <tr><td> <span class="strong">BIT1C</span> <td> :Œ± bit1
    <tr><td> <span class="strong">EQUAL</span> <td> :Œ± -> bool
    <tr><td> <span class="strong">FCP</span> <td> :(num -> Œ±) -> Œ±[Œ≤]
    <tr><td> <span class="strong">FCP_CONS</span> <td> :Œ± -> Œ±[Œ≤] -> Œ±[Œ≥]
    <tr><td>
        <span class="strong">FCP_EVERY</span>
        <td>
        :(Œ≤ -> bool) -> Œ≤[Œ±] -> bool
    <tr><td>
        <span class="strong">FCP_EXISTS</span>
        <td>
        :(Œ≤ -> bool) -> Œ≤[Œ±] -> bool
    <tr><td> <span class="strong">FCP_HD</span> <td> :Œ±[Œ≤] -> Œ±
    <tr><td>
        <span class="strong">FCP_MAP</span>
        <td>
        :(Œ± -> Œ≤) -> Œ±[Œ≥] -> Œ≤[Œ≥]
    <tr><td> <span class="strong">FCP_TL</span> <td> :Œ±[Œ≥] -> Œ±[Œ≤]
    <tr><td>
        <span class="strong">HAS_SIZE</span>
        <td>
        :(Œ± -> bool) -> num -> bool
    <tr><td> <span class="strong">IS_BIT0A</span> <td> :Œ± bit0 -> bool
    <tr><td> <span class="strong">IS_BIT0B</span> <td> :Œ± bit0 -> bool
    <tr><td> <span class="strong">IS_BIT1A</span> <td> :Œ± bit1 -> bool
    <tr><td> <span class="strong">IS_BIT1B</span> <td> :Œ± bit1 -> bool
    <tr><td> <span class="strong">IS_BIT1C</span> <td> :Œ± bit1 -> bool
    <tr><td> <span class="strong">L2V</span> <td> :Œ± list -> Œ±[Œ≤]
    <tr><td> <span class="strong">V2L</span> <td> :Œ±[Œ≤] -> Œ± list
    <tr><td> <span class="strong">abs_sub1</span> <td> :Œ± -> Œ± sub1
    <tr><td>
        <span class="strong">abs_sub1_CLASS</span>
        <td>
        :(Œ± -> bool) -> Œ± sub1
    <tr><td>
        <span class="strong">bit0_case</span>
        <td>
        :(Œ± -> Œ≤) -> (Œ± -> Œ≤) -> Œ± bit0 -> Œ≤
    <tr><td>
        <span class="strong">bit0_size</span>
        <td>
        :(Œ± -> num) -> Œ± bit0 -> num
    <tr><td>
        <span class="strong">bit1_case</span>
        <td>
        :(Œ± -> Œ≤) -> (Œ± -> Œ≤) -> Œ≤ -> Œ± bit1 -> Œ≤
    <tr><td>
        <span class="strong">bit1_size</span>
        <td>
        :(Œ± -> num) -> Œ± bit1 -> num
    <tr><td>
        <span class="strong">dest_cart</span>
        <td>
        :Œ±[Œ≤] -> Œ≤ finite_image -> Œ±
    <tr><td>
        <span class="strong">dest_finite_image</span>
        <td>
        :Œ± finite_image -> Œ±
    <tr><td> <span class="strong">dimindex</span> <td> :Œ± itself -> num
    <tr><td>
        <span class="strong">fcp_case</span>
        <td>
        :((Œ≤ finite_image -> Œ±) -> Œ≥) -> Œ±[Œ≤] -> Œ≥
    <tr><td> <span class="strong">fcp_index</span> <td> :Œ±[Œ≤] -> num -> Œ±
    <tr><td> <span class="strong">finite_index</span> <td> :num -> Œ±
    <tr><td>
        <span class="strong">mk_cart</span>
        <td>
        :(Œ≤ finite_image -> Œ±) -> Œ±[Œ≤]
    <tr><td>
        <span class="strong">mk_finite_image</span>
        <td>
        :Œ± -> Œ± finite_image
    <tr><td> <span class="strong">rep_sub1</span> <td> :Œ± sub1 -> Œ±
    <tr><td>
        <span class="strong">rep_sub1_CLASS</span>
        <td>
        :Œ± sub1 -> Œ± -> bool
    <tr><td> <span class="strong">sub_equiv</span> <td> :Œ± -> Œ± -> bool

</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">HAS_SIZE_def</span>
<DD>
<pre>
|- ‚àÄs n. s HAS_SIZE n ‚áî FINITE s ‚àß (CARD s = n)
</pre>

<DT><span class="strong">finite_image_TY_DEF</span>
<DD>
<pre>
|- ‚àÉrep. TYPE_DEFINITION (Œªx. (x = ARB) ‚à® FINITE ùïå(:Œ±)) rep
</pre>

<DT><span class="strong">finite_image_tybij</span>
<DD>
<pre>
|- (‚àÄa. mk_finite_image (dest_finite_image a) = a) ‚àß
   ‚àÄr.
     (Œªx. (x = ARB) ‚à® FINITE ùïå(:Œ±)) r ‚áî
     (dest_finite_image (mk_finite_image r) = r)
</pre>

<DT><span class="strong">dimindex_def</span>
<DD>
<pre>
|- dimindex (:Œ±) = if FINITE ùïå(:Œ±) then CARD ùïå(:Œ±) else 1
</pre>

<DT><span class="strong">finite_index_def</span>
<DD>
<pre>
|- finite_index = @f. ‚àÄx. ‚àÉ!n. n < dimindex (:Œ±) ‚àß (f n = x)
</pre>

<DT><span class="strong">cart_TY_DEF</span>
<DD>
<pre>
|- ‚àÉrep. TYPE_DEFINITION (Œªf. T) rep
</pre>

<DT><span class="strong">cart_tybij</span>
<DD>
<pre>
|- (‚àÄa. mk_cart (dest_cart a) = a) ‚àß
   ‚àÄr. (Œªf. T) r ‚áî (dest_cart (mk_cart r) = r)
</pre>

<DT><span class="strong">fcp_index</span>
<DD>
<pre>
|- ‚àÄx i. x ' i = dest_cart x (finite_index i)
</pre>

<DT><span class="strong">fcp_case_def</span>
<DD>
<pre>
|- ‚àÄf' h. fcp_case f' (mk_cart h) = f' h
</pre>

<DT><span class="strong">FCP</span>
<DD>
<pre>
|- $FCP = (Œªg. @f. ‚àÄi. i < dimindex (:Œ≤) ‚áí (f ' i = g i))
</pre>

<DT><span class="strong">EQUAL_def</span>
<DD>
<pre>
|- EQUAL = {CHOICE ùïå(:Œ±); CHOICE (REST ùïå(:Œ±))}
</pre>

<DT><span class="strong">sub_equiv_def</span>
<DD>
<pre>
|- ‚àÄa b. sub_equiv a b ‚áî a ‚àà EQUAL ‚àß b ‚àà EQUAL ‚à® (a = b)
</pre>

<DT><span class="strong">sub1_TY_DEF</span>
<DD>
<pre>
|- ‚àÉrep. TYPE_DEFINITION (Œªc. ‚àÉr. sub_equiv r r ‚àß (c = sub_equiv r)) rep
</pre>

<DT><span class="strong">sub1_bijections</span>
<DD>
<pre>
|- (‚àÄa. abs_sub1_CLASS (rep_sub1_CLASS a) = a) ‚àß
   ‚àÄr.
     (Œªc. ‚àÉr. sub_equiv r r ‚àß (c = sub_equiv r)) r ‚áî
     (rep_sub1_CLASS (abs_sub1_CLASS r) = r)
</pre>

<DT><span class="strong">rep_sub1_def</span>
<DD>
<pre>
|- ‚àÄa. rep_sub1 a = $@ (rep_sub1_CLASS a)
</pre>

<DT><span class="strong">abs_sub1_def</span>
<DD>
<pre>
|- ‚àÄr. abs_sub1 r = abs_sub1_CLASS (sub_equiv r)
</pre>

<DT><span class="strong">bit0_TY_DEF</span>
<DD>
<pre>
|- ‚àÉrep.
     TYPE_DEFINITION
       (Œªa0.
          ‚àÄ'bit0' .
            (‚àÄa0.
               (‚àÉa. a0 = (Œªa. ind_type$CONSTR 0 a (Œªn. ind_type$BOTTOM)) a) ‚à®
               (‚àÉa.
                  a0 =
                  (Œªa. ind_type$CONSTR (SUC 0) a (Œªn. ind_type$BOTTOM)) a) ‚áí
               'bit0' a0) ‚áí
            'bit0' a0) rep
</pre>

<DT><span class="strong">bit0_case_def</span>
<DD>
<pre>
|- (‚àÄf f1 a. bit0_case f f1 (BIT0A a) = f a) ‚àß
   ‚àÄf f1 a. bit0_case f f1 (BIT0B a) = f1 a
</pre>

<DT><span class="strong">bit0_size_def</span>
<DD>
<pre>
|- (‚àÄf a. bit0_size f (BIT0A a) = 1 + f a) ‚àß
   ‚àÄf a. bit0_size f (BIT0B a) = 1 + f a
</pre>

<DT><span class="strong">IS_BIT0A_def</span>
<DD>
<pre>
|- (‚àÄx. IS_BIT0A (BIT0A x) ‚áî T) ‚àß ‚àÄx. IS_BIT0A (BIT0B x) ‚áî F
</pre>

<DT><span class="strong">IS_BIT0B_def</span>
<DD>
<pre>
|- (‚àÄx. IS_BIT0B (BIT0A x) ‚áî F) ‚àß ‚àÄx. IS_BIT0B (BIT0B x) ‚áî T
</pre>

<DT><span class="strong">bit1_TY_DEF</span>
<DD>
<pre>
|- ‚àÉrep.
     TYPE_DEFINITION
       (Œªa0.
          ‚àÄ'bit1' .
            (‚àÄa0.
               (‚àÉa. a0 = (Œªa. ind_type$CONSTR 0 a (Œªn. ind_type$BOTTOM)) a) ‚à®
               (‚àÉa.
                  a0 =
                  (Œªa. ind_type$CONSTR (SUC 0) a (Œªn. ind_type$BOTTOM)) a) ‚à®
               (a0 =
                ind_type$CONSTR (SUC (SUC 0)) ARB (Œªn. ind_type$BOTTOM)) ‚áí
               'bit1' a0) ‚áí
            'bit1' a0) rep
</pre>

<DT><span class="strong">bit1_case_def</span>
<DD>
<pre>
|- (‚àÄf f1 v a. bit1_case f f1 v (BIT1A a) = f a) ‚àß
   (‚àÄf f1 v a. bit1_case f f1 v (BIT1B a) = f1 a) ‚àß
   ‚àÄf f1 v. bit1_case f f1 v BIT1C = v
</pre>

<DT><span class="strong">bit1_size_def</span>
<DD>
<pre>
|- (‚àÄf a. bit1_size f (BIT1A a) = 1 + f a) ‚àß
   (‚àÄf a. bit1_size f (BIT1B a) = 1 + f a) ‚àß ‚àÄf. bit1_size f BIT1C = 0
</pre>

<DT><span class="strong">IS_BIT1A_def</span>
<DD>
<pre>
|- (‚àÄx. IS_BIT1A (BIT1A x) ‚áî T) ‚àß (‚àÄx. IS_BIT1A (BIT1B x) ‚áî F) ‚àß
   (IS_BIT1A BIT1C ‚áî F)
</pre>

<DT><span class="strong">IS_BIT1B_def</span>
<DD>
<pre>
|- (‚àÄx. IS_BIT1B (BIT1A x) ‚áî F) ‚àß (‚àÄx. IS_BIT1B (BIT1B x) ‚áî T) ‚àß
   (IS_BIT1B BIT1C ‚áî F)
</pre>

<DT><span class="strong">IS_BIT1C_def</span>
<DD>
<pre>
|- (‚àÄx. IS_BIT1C (BIT1A x) ‚áî F) ‚àß (‚àÄx. IS_BIT1C (BIT1B x) ‚áî F) ‚àß
   (IS_BIT1C BIT1C ‚áî T)
</pre>

<DT><span class="strong">FCP_UPDATE_def</span>
<DD>
<pre>
|- ‚àÄa b. a :+ b = (Œªm. FCP c. if a = c then b else m ' c)
</pre>

<DT><span class="strong">FCP_TL_def</span>
<DD>
<pre>
|- ‚àÄv. FCP_TL v = FCP i. v ' (SUC i)
</pre>

<DT><span class="strong">FCP_HD_def</span>
<DD>
<pre>
|- ‚àÄv. FCP_HD v = v ' 0
</pre>

<DT><span class="strong">FCP_CONS_def</span>
<DD>
<pre>
|- ‚àÄh v. FCP_CONS h v = (0 :+ h) (FCP i. v ' (PRE i))
</pre>

<DT><span class="strong">FCP_MAP_def</span>
<DD>
<pre>
|- ‚àÄf v. FCP_MAP f v = FCP i. f (v ' i)
</pre>

<DT><span class="strong">FCP_EXISTS_def</span>
<DD>
<pre>
|- ‚àÄP v. FCP_EXISTS P v ‚áî ‚àÉi. i < dimindex (:Œ±) ‚àß P (v ' i)
</pre>

<DT><span class="strong">FCP_EVERY_def</span>
<DD>
<pre>
|- ‚àÄP v. FCP_EVERY P v ‚áî ‚àÄi. dimindex (:Œ±) ‚â§ i ‚à® P (v ' i)
</pre>

<DT><span class="strong">V2L_def</span>
<DD>
<pre>
|- ‚àÄv.
     V2L v =
     @L. (LENGTH L = dimindex (:Œ≤)) ‚àß ‚àÄi. i < dimindex (:Œ≤) ‚áí (EL i L = v ' i)
</pre>

<DT><span class="strong">L2V_def</span>
<DD>
<pre>
|- ‚àÄL. L2V L = FCP i. EL i L
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">dimindex</span>
<DD>
<pre>
|- dimindex (:Œ±) = if FINITE ùïå(:Œ±) then CARD ùïå(:Œ±) else 1
</pre>

<DT><span class="strong">NOT_FINITE_IMP_dimindex_1</span>
<DD>
<pre>
|- INFINITE ùïå(:Œ±) ‚áí (dimindex (:Œ±) = 1)
</pre>

<DT><span class="strong">DIMINDEX_GE_1</span>
<DD>
<pre>
|- 1 ‚â§ dimindex (:Œ±)
</pre>

<DT><span class="strong">fcp_Axiom</span>
<DD>
<pre>
|- ‚àÄf. ‚àÉg. ‚àÄh. g (mk_cart h) = f h
</pre>

<DT><span class="strong">fcp_ind</span>
<DD>
<pre>
|- ‚àÄP. (‚àÄf. P (mk_cart f)) ‚áí ‚àÄa. P a
</pre>

<DT><span class="strong">CART_EQ</span>
<DD>
<pre>
|- ‚àÄx y. (x = y) ‚áî ‚àÄi. i < dimindex (:Œ≤) ‚áí (x ' i = y ' i)
</pre>

<DT><span class="strong">FCP_BETA</span>
<DD>
<pre>
|- ‚àÄi. i < dimindex (:Œ≤) ‚áí ($FCP g ' i = g i)
</pre>

<DT><span class="strong">FCP_ETA</span>
<DD>
<pre>
|- ‚àÄg. (FCP i. g ' i) = g
</pre>

<DT><span class="strong">index_sum</span>
<DD>
<pre>
|- dimindex (:Œ± + Œ≤) =
   if FINITE ùïå(:Œ±) ‚àß FINITE ùïå(:Œ≤) then dimindex (:Œ±) + dimindex (:Œ≤) else 1
</pre>

<DT><span class="strong">finite_sum</span>
<DD>
<pre>
|- FINITE ùïå(:Œ± + Œ≤) ‚áî FINITE ùïå(:Œ±) ‚àß FINITE ùïå(:Œ≤)
</pre>

<DT><span class="strong">sub1_ABS_REP_CLASS</span>
<DD>
<pre>
|- (‚àÄa. abs_sub1_CLASS (rep_sub1_CLASS a) = a) ‚àß
   ‚àÄc.
     (‚àÉr. sub_equiv r r ‚àß (c = sub_equiv r)) ‚áî
     (rep_sub1_CLASS (abs_sub1_CLASS c) = c)
</pre>

<DT><span class="strong">sub1_QUOTIENT</span>
<DD>
<pre>
|- QUOTIENT sub_equiv abs_sub1 rep_sub1
</pre>

<DT><span class="strong">finite_sub1</span>
<DD>
<pre>
|- FINITE ùïå(:Œ± sub1) ‚áî FINITE ùïå(:Œ±)
</pre>

<DT><span class="strong">INDEX_SUB1</span>
<DD>
<pre>
|- dimindex (:Œ± sub1) = if 1 < dimindex (:Œ±) then PRE (dimindex (:Œ±)) else 1
</pre>

<DT><span class="strong">datatype_bit0</span>
<DD>
<pre>
|- DATATYPE (bit0 BIT0A BIT0B)
</pre>

<DT><span class="strong">bit0_11</span>
<DD>
<pre>
|- (‚àÄa a'. (BIT0A a = BIT0A a') ‚áî (a = a')) ‚àß
   ‚àÄa a'. (BIT0B a = BIT0B a') ‚áî (a = a')
</pre>

<DT><span class="strong">bit0_distinct</span>
<DD>
<pre>
|- ‚àÄa' a. BIT0A a ‚â† BIT0B a'
</pre>

<DT><span class="strong">bit0_case_cong</span>
<DD>
<pre>
|- ‚àÄM M' f f1.
     (M = M') ‚àß (‚àÄa. (M' = BIT0A a) ‚áí (f a = f' a)) ‚àß
     (‚àÄa. (M' = BIT0B a) ‚áí (f1 a = f1' a)) ‚áí
     (bit0_case f f1 M = bit0_case f' f1' M')
</pre>

<DT><span class="strong">bit0_nchotomy</span>
<DD>
<pre>
|- ‚àÄbb. (‚àÉa. bb = BIT0A a) ‚à® ‚àÉa. bb = BIT0B a
</pre>

<DT><span class="strong">bit0_Axiom</span>
<DD>
<pre>
|- ‚àÄf0 f1. ‚àÉfn. (‚àÄa. fn (BIT0A a) = f0 a) ‚àß ‚àÄa. fn (BIT0B a) = f1 a
</pre>

<DT><span class="strong">bit0_induction</span>
<DD>
<pre>
|- ‚àÄP. (‚àÄa. P (BIT0A a)) ‚àß (‚àÄa. P (BIT0B a)) ‚áí ‚àÄb. P b
</pre>

<DT><span class="strong">index_bit0</span>
<DD>
<pre>
|- dimindex (:Œ± bit0) = if FINITE ùïå(:Œ±) then 2 * dimindex (:Œ±) else 1
</pre>

<DT><span class="strong">finite_bit0</span>
<DD>
<pre>
|- FINITE ùïå(:Œ± bit0) ‚áî FINITE ùïå(:Œ±)
</pre>

<DT><span class="strong">datatype_bit1</span>
<DD>
<pre>
|- DATATYPE (bit1 BIT1A BIT1B BIT1C)
</pre>

<DT><span class="strong">bit1_11</span>
<DD>
<pre>
|- (‚àÄa a'. (BIT1A a = BIT1A a') ‚áî (a = a')) ‚àß
   ‚àÄa a'. (BIT1B a = BIT1B a') ‚áî (a = a')
</pre>

<DT><span class="strong">bit1_distinct</span>
<DD>
<pre>
|- (‚àÄa' a. BIT1A a ‚â† BIT1B a') ‚àß (‚àÄa. BIT1A a ‚â† BIT1C) ‚àß ‚àÄa. BIT1B a ‚â† BIT1C
</pre>

<DT><span class="strong">bit1_case_cong</span>
<DD>
<pre>
|- ‚àÄM M' f f1 v.
     (M = M') ‚àß (‚àÄa. (M' = BIT1A a) ‚áí (f a = f' a)) ‚àß
     (‚àÄa. (M' = BIT1B a) ‚áí (f1 a = f1' a)) ‚àß ((M' = BIT1C) ‚áí (v = v')) ‚áí
     (bit1_case f f1 v M = bit1_case f' f1' v' M')
</pre>

<DT><span class="strong">bit1_nchotomy</span>
<DD>
<pre>
|- ‚àÄbb. (‚àÉa. bb = BIT1A a) ‚à® (‚àÉa. bb = BIT1B a) ‚à® (bb = BIT1C)
</pre>

<DT><span class="strong">bit1_Axiom</span>
<DD>
<pre>
|- ‚àÄf0 f1 f2.
     ‚àÉfn.
       (‚àÄa. fn (BIT1A a) = f0 a) ‚àß (‚àÄa. fn (BIT1B a) = f1 a) ‚àß (fn BIT1C = f2)
</pre>

<DT><span class="strong">bit1_induction</span>
<DD>
<pre>
|- ‚àÄP. (‚àÄa. P (BIT1A a)) ‚àß (‚àÄa. P (BIT1B a)) ‚àß P BIT1C ‚áí ‚àÄb. P b
</pre>

<DT><span class="strong">index_bit1</span>
<DD>
<pre>
|- dimindex (:Œ± bit1) = if FINITE ùïå(:Œ±) then 2 * dimindex (:Œ±) + 1 else 1
</pre>

<DT><span class="strong">finite_bit1</span>
<DD>
<pre>
|- FINITE ùïå(:Œ± bit1) ‚áî FINITE ùïå(:Œ±)
</pre>

<DT><span class="strong">index_one</span>
<DD>
<pre>
|- dimindex (:unit) = 1
</pre>

<DT><span class="strong">finite_one</span>
<DD>
<pre>
|- FINITE ùïå(:unit)
</pre>

<DT><span class="strong">card_dimindex</span>
<DD>
<pre>
|- FINITE ùïå(:Œ±) ‚áí (CARD ùïå(:Œ±) = dimindex (:Œ±))
</pre>

<DT><span class="strong">FCP_UPDATE_COMMUTES</span>
<DD>
<pre>
|- ‚àÄm a b c d. a ‚â† b ‚áí ((a :+ c) ((b :+ d) m) = (b :+ d) ((a :+ c) m))
</pre>

<DT><span class="strong">FCP_UPDATE_EQ</span>
<DD>
<pre>
|- ‚àÄm a b c. (a :+ c) ((a :+ b) m) = (a :+ c) m
</pre>

<DT><span class="strong">FCP_UPDATE_IMP_ID</span>
<DD>
<pre>
|- ‚àÄm a v. (m ' a = v) ‚áí ((a :+ v) m = m)
</pre>

<DT><span class="strong">APPLY_FCP_UPDATE_ID</span>
<DD>
<pre>
|- ‚àÄm a. (a :+ m ' a) m = m
</pre>

<DT><span class="strong">FCP_APPLY_UPDATE_THM</span>
<DD>
<pre>
|- ‚àÄm a w b.
     (a :+ w) m ' b =
     if b < dimindex (:Œ≤) then
       if a = b then w else m ' b
     else
       FAIL $' index out of range ((a :+ w) m) b
</pre>

<DT><span class="strong">exists_v2l_thm</span>
<DD>
<pre>
|- ‚àÉx. (LENGTH x = dimindex (:Œ≤)) ‚àß ‚àÄi. i < dimindex (:Œ≤) ‚áí (EL i x = v ' i)
</pre>

<DT><span class="strong">LENGTH_V2L</span>
<DD>
<pre>
|- LENGTH (V2L v) = dimindex (:Œ≤)
</pre>

<DT><span class="strong">EL_V2L</span>
<DD>
<pre>
|- i < dimindex (:Œ≤) ‚áí (EL i (V2L v) = v ' i)
</pre>

<DT><span class="strong">FCP_MAP</span>
<DD>
<pre>
|- FCP_MAP f v = L2V (MAP f (V2L v))
</pre>

<DT><span class="strong">FCP_TL</span>
<DD>
<pre>
|- 1 < dimindex (:Œ≤) ‚áí (FCP_TL v = L2V (TL (V2L v)))
</pre>

<DT><span class="strong">FCP_EXISTS</span>
<DD>
<pre>
|- FCP_EXISTS P v ‚áî EXISTS P (V2L v)
</pre>

<DT><span class="strong">FCP_EVERY</span>
<DD>
<pre>
|- FCP_EVERY P v ‚áî EVERY P (V2L v)
</pre>

<DT><span class="strong">FCP_HD</span>
<DD>
<pre>
|- FCP_HD v = HD (V2L v)
</pre>

<DT><span class="strong">FCP_CONS</span>
<DD>
<pre>
|- FCP_CONS a v = L2V (a::V2L v)
</pre>

<DT><span class="strong">V2L_L2V</span>
<DD>
<pre>
|- ‚àÄx. (dimindex (:Œ≤) = LENGTH x) ‚áí (V2L (L2V x) = x)
</pre>

<DT><span class="strong">NULL_V2L</span>
<DD>
<pre>
|- ¬¨NULL (V2L v)
</pre>

<DT><span class="strong">V2L_RECURSIVE</span>
<DD>
<pre>
|- V2L v = FCP_HD v::if dimindex (:Œ≤) = 1 then [] else V2L (FCP_TL v)
</pre>

<DT><span class="strong">READ_TL</span>
<DD>
<pre>
|- i < dimindex (:Œ≤) ‚áí (FCP_TL a ' i = a ' (SUC i))
</pre>

<DT><span class="strong">READ_L2V</span>
<DD>
<pre>
|- i < dimindex (:Œ≤) ‚áí (L2V a ' i = EL i a)
</pre>

<DT><span class="strong">index_comp</span>
<DD>
<pre>
|- ‚àÄf n.
     $FCP f ' n =
     if n < dimindex (:Œ≤) then f n else FAIL $' FCP out of bounds ($FCP f) n
</pre>

<DT><span class="strong">fcp_subst_comp</span>
<DD>
<pre>
|- ‚àÄa b f. (x :+ y) ($FCP f) = FCP c. if x = c then y else f c
</pre>

</DL>



<hr>
</body>
</html>
