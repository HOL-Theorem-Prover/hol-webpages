<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure sptreeTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure sptreeTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/patricia/sptreeScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature sptreeTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#delete_def-val">delete_def</a> : thm
<a name="line7"></a>    val <a href="#difference_def-val">difference_def</a> : thm
<a name="line8"></a>    val <a href="#domain_def-val">domain_def</a> : thm
<a name="line9"></a>    val <a href="#foldi_def-val">foldi_def</a> : thm
<a name="line10"></a>    val <a href="#fromAList_primitive_def-val">fromAList_primitive_def</a> : thm
<a name="line11"></a>    val <a href="#fromList_def-val">fromList_def</a> : thm
<a name="line12"></a>    val <a href="#insert_curried_def-val">insert_curried_def</a> : thm
<a name="line13"></a>    val <a href="#insert_tupled_primitive_def-val">insert_tupled_primitive_def</a> : thm
<a name="line14"></a>    val <a href="#inter_def-val">inter_def</a> : thm
<a name="line15"></a>    val <a href="#inter_eq_def-val">inter_eq_def</a> : thm
<a name="line16"></a>    val <a href="#lookup_curried_def-val">lookup_curried_def</a> : thm
<a name="line17"></a>    val <a href="#lookup_tupled_primitive_def-val">lookup_tupled_primitive_def</a> : thm
<a name="line18"></a>    val <a href="#lrnext_primitive_def-val">lrnext_primitive_def</a> : thm
<a name="line19"></a>    val <a href="#map_def-val">map_def</a> : thm
<a name="line20"></a>    val <a href="#mk_BN_curried_def-val">mk_BN_curried_def</a> : thm
<a name="line21"></a>    val <a href="#mk_BN_tupled_primitive_def-val">mk_BN_tupled_primitive_def</a> : thm
<a name="line22"></a>    val <a href="#mk_BS_curried_def-val">mk_BS_curried_def</a> : thm
<a name="line23"></a>    val <a href="#mk_BS_tupled_primitive_def-val">mk_BS_tupled_primitive_def</a> : thm
<a name="line24"></a>    val <a href="#mk_wf_def-val">mk_wf_def</a> : thm
<a name="line25"></a>    val <a href="#size_def-val">size_def</a> : thm
<a name="line26"></a>    val <a href="#spt_TY_DEF-val">spt_TY_DEF</a> : thm
<a name="line27"></a>    val <a href="#spt_case_def-val">spt_case_def</a> : thm
<a name="line28"></a>    val <a href="#spt_size_def-val">spt_size_def</a> : thm
<a name="line29"></a>    val <a href="#toAList_def-val">toAList_def</a> : thm
<a name="line30"></a>    val <a href="#toListA_def-val">toListA_def</a> : thm
<a name="line31"></a>    val <a href="#toList_def-val">toList_def</a> : thm
<a name="line32"></a>    val <a href="#union_def-val">union_def</a> : thm
<a name="line33"></a>    val <a href="#wf_def-val">wf_def</a> : thm
<a name="line34"></a>
<a name="line35"></a>  (*  Theorems  *)
<a name="line36"></a>    val <a href="#ALL_DISTINCT_MAP_FST_toAList-val">ALL_DISTINCT_MAP_FST_toAList</a> : thm
<a name="line37"></a>    val <a href="#ALOOKUP_toAList-val">ALOOKUP_toAList</a> : thm
<a name="line38"></a>    val <a href="#FINITE_domain-val">FINITE_domain</a> : thm
<a name="line39"></a>    val <a href="#MEM_toAList-val">MEM_toAList</a> : thm
<a name="line40"></a>    val <a href="#MEM_toList-val">MEM_toList</a> : thm
<a name="line41"></a>    val <a href="#datatype_spt-val">datatype_spt</a> : thm
<a name="line42"></a>    val <a href="#delete_compute-val">delete_compute</a> : thm
<a name="line43"></a>    val <a href="#delete_mk_wf-val">delete_mk_wf</a> : thm
<a name="line44"></a>    val <a href="#domain_delete-val">domain_delete</a> : thm
<a name="line45"></a>    val <a href="#domain_empty-val">domain_empty</a> : thm
<a name="line46"></a>    val <a href="#domain_foldi-val">domain_foldi</a> : thm
<a name="line47"></a>    val <a href="#domain_fromAList-val">domain_fromAList</a> : thm
<a name="line48"></a>    val <a href="#domain_fromList-val">domain_fromList</a> : thm
<a name="line49"></a>    val <a href="#domain_insert-val">domain_insert</a> : thm
<a name="line50"></a>    val <a href="#domain_inter-val">domain_inter</a> : thm
<a name="line51"></a>    val <a href="#domain_lookup-val">domain_lookup</a> : thm
<a name="line52"></a>    val <a href="#domain_map-val">domain_map</a> : thm
<a name="line53"></a>    val <a href="#domain_mk_wf-val">domain_mk_wf</a> : thm
<a name="line54"></a>    val <a href="#domain_sing-val">domain_sing</a> : thm
<a name="line55"></a>    val <a href="#domain_union-val">domain_union</a> : thm
<a name="line56"></a>    val <a href="#foldi_FOLDR_toAList-val">foldi_FOLDR_toAList</a> : thm
<a name="line57"></a>    val <a href="#fromAList_def-val">fromAList_def</a> : thm
<a name="line58"></a>    val <a href="#fromAList_ind-val">fromAList_ind</a> : thm
<a name="line59"></a>    val <a href="#fromAList_toAList-val">fromAList_toAList</a> : thm
<a name="line60"></a>    val <a href="#insert_compute-val">insert_compute</a> : thm
<a name="line61"></a>    val <a href="#insert_def-val">insert_def</a> : thm
<a name="line62"></a>    val <a href="#insert_ind-val">insert_ind</a> : thm
<a name="line63"></a>    val <a href="#insert_mk_wf-val">insert_mk_wf</a> : thm
<a name="line64"></a>    val <a href="#insert_notEmpty-val">insert_notEmpty</a> : thm
<a name="line65"></a>    val <a href="#insert_union-val">insert_union</a> : thm
<a name="line66"></a>    val <a href="#inter_LN-val">inter_LN</a> : thm
<a name="line67"></a>    val <a href="#inter_assoc-val">inter_assoc</a> : thm
<a name="line68"></a>    val <a href="#inter_eq-val">inter_eq</a> : thm
<a name="line69"></a>    val <a href="#isEmpty_toList-val">isEmpty_toList</a> : thm
<a name="line70"></a>    val <a href="#isEmpty_toListA-val">isEmpty_toListA</a> : thm
<a name="line71"></a>    val <a href="#isEmpty_union-val">isEmpty_union</a> : thm
<a name="line72"></a>    val <a href="#lookup_NONE_domain-val">lookup_NONE_domain</a> : thm
<a name="line73"></a>    val <a href="#lookup_compute-val">lookup_compute</a> : thm
<a name="line74"></a>    val <a href="#lookup_def-val">lookup_def</a> : thm
<a name="line75"></a>    val <a href="#lookup_delete-val">lookup_delete</a> : thm
<a name="line76"></a>    val <a href="#lookup_difference-val">lookup_difference</a> : thm
<a name="line77"></a>    val <a href="#lookup_fromAList-val">lookup_fromAList</a> : thm
<a name="line78"></a>    val <a href="#lookup_fromAList_toAList-val">lookup_fromAList_toAList</a> : thm
<a name="line79"></a>    val <a href="#lookup_fromList-val">lookup_fromList</a> : thm
<a name="line80"></a>    val <a href="#lookup_ind-val">lookup_ind</a> : thm
<a name="line81"></a>    val <a href="#lookup_insert-val">lookup_insert</a> : thm
<a name="line82"></a>    val <a href="#lookup_insert1-val">lookup_insert1</a> : thm
<a name="line83"></a>    val <a href="#lookup_inter-val">lookup_inter</a> : thm
<a name="line84"></a>    val <a href="#lookup_inter_EQ-val">lookup_inter_EQ</a> : thm
<a name="line85"></a>    val <a href="#lookup_inter_alt-val">lookup_inter_alt</a> : thm
<a name="line86"></a>    val <a href="#lookup_inter_assoc-val">lookup_inter_assoc</a> : thm
<a name="line87"></a>    val <a href="#lookup_inter_eq-val">lookup_inter_eq</a> : thm
<a name="line88"></a>    val <a href="#lookup_map-val">lookup_map</a> : thm
<a name="line89"></a>    val <a href="#lookup_mk_wf-val">lookup_mk_wf</a> : thm
<a name="line90"></a>    val <a href="#lookup_union-val">lookup_union</a> : thm
<a name="line91"></a>    val <a href="#lrnext_def-val">lrnext_def</a> : thm
<a name="line92"></a>    val <a href="#lrnext_ind-val">lrnext_ind</a> : thm
<a name="line93"></a>    val <a href="#lrnext_thm-val">lrnext_thm</a> : thm
<a name="line94"></a>    val <a href="#map_LN-val">map_LN</a> : thm
<a name="line95"></a>    val <a href="#mk_BN_def-val">mk_BN_def</a> : thm
<a name="line96"></a>    val <a href="#mk_BN_ind-val">mk_BN_ind</a> : thm
<a name="line97"></a>    val <a href="#mk_BS_def-val">mk_BS_def</a> : thm
<a name="line98"></a>    val <a href="#mk_BS_ind-val">mk_BS_ind</a> : thm
<a name="line99"></a>    val <a href="#mk_wf_eq-val">mk_wf_eq</a> : thm
<a name="line100"></a>    val <a href="#set_foldi_keys-val">set_foldi_keys</a> : thm
<a name="line101"></a>    val <a href="#spt_11-val">spt_11</a> : thm
<a name="line102"></a>    val <a href="#spt_Axiom-val">spt_Axiom</a> : thm
<a name="line103"></a>    val <a href="#spt_case_cong-val">spt_case_cong</a> : thm
<a name="line104"></a>    val <a href="#spt_distinct-val">spt_distinct</a> : thm
<a name="line105"></a>    val <a href="#spt_eq_thm-val">spt_eq_thm</a> : thm
<a name="line106"></a>    val <a href="#spt_induction-val">spt_induction</a> : thm
<a name="line107"></a>    val <a href="#spt_nchotomy-val">spt_nchotomy</a> : thm
<a name="line108"></a>    val <a href="#toListA_append-val">toListA_append</a> : thm
<a name="line109"></a>    val <a href="#toList_map-val">toList_map</a> : thm
<a name="line110"></a>    val <a href="#union_LN-val">union_LN</a> : thm
<a name="line111"></a>    val <a href="#union_assoc-val">union_assoc</a> : thm
<a name="line112"></a>    val <a href="#union_mk_wf-val">union_mk_wf</a> : thm
<a name="line113"></a>    val <a href="#wf_delete-val">wf_delete</a> : thm
<a name="line114"></a>    val <a href="#wf_fromAList-val">wf_fromAList</a> : thm
<a name="line115"></a>    val <a href="#wf_insert-val">wf_insert</a> : thm
<a name="line116"></a>    val <a href="#wf_inter-val">wf_inter</a> : thm
<a name="line117"></a>    val <a href="#wf_map-val">wf_map</a> : thm
<a name="line118"></a>    val <a href="#wf_mk_id-val">wf_mk_id</a> : thm
<a name="line119"></a>    val <a href="#wf_mk_wf-val">wf_mk_wf</a> : thm
<a name="line120"></a>    val <a href="#wf_union-val">wf_union</a> : thm
<a name="line121"></a>
<a name="line122"></a>  val sptree_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line123"></a>(*
   [alist] Parent theory of "sptree"

   [logroot] Parent theory of "sptree"

   [<a name="delete_def-val"><b>delete_def</b></a>]  Definition

      |- (∀k. isEmpty (delete k LN)) ∧
         (∀k a. delete k (LS a) = if k = 0 then LN else LS a) ∧
         (∀k t1 t2.
            delete k (BN t1 t2) =
            if k = 0 then BN t1 t2
            else if EVEN k then mk_BN (delete ((k − 1) DIV 2) t1) t2
            else mk_BN t1 (delete ((k − 1) DIV 2) t2)) ∧
         ∀k t1 a t2.
           delete k (BS t1 a t2) =
           if k = 0 then BN t1 t2
           else if EVEN k then mk_BS (delete ((k − 1) DIV 2) t1) a t2
           else mk_BS t1 a (delete ((k − 1) DIV 2) t2)

   [<a name="difference_def-val"><b>difference_def</b></a>]  Definition

      |- (∀t. isEmpty (difference LN t)) ∧
         (∀a t.
            difference (LS a) t =
            case t of
              LN =&gt; LS a
            | LS b =&gt; LN
            | BN t1 t2 =&gt; LS a
            | BS t1' b' t2' =&gt; LN) ∧
         (∀t1 t2 t.
            difference (BN t1 t2) t =
            case t of
              LN =&gt; BN t1 t2
            | LS a =&gt; BN t1 t2
            | BN t1' t2' =&gt; mk_BN (difference t1 t1') (difference t2 t2')
            | BS t1'' a'' t2'' =&gt;
                mk_BN (difference t1 t1'') (difference t2 t2'')) ∧
         ∀t1 a t2 t.
           difference (BS t1 a t2) t =
           case t of
             LN =&gt; BS t1 a t2
           | LS a' =&gt; BN t1 t2
           | BN t1' t2' =&gt; mk_BS (difference t1 t1') a (difference t2 t2')
           | BS t1'' a''' t2'' =&gt;
               mk_BN (difference t1 t1'') (difference t2 t2'')

   [<a name="domain_def-val"><b>domain_def</b></a>]  Definition

      |- (domain LN = ∅) ∧ (∀v0. domain (LS v0) = {0}) ∧
         (∀t1 t2.
            domain (BN t1 t2) =
            IMAGE (λn. 2 * n + 2) (domain t1) ∪
            IMAGE (λn. 2 * n + 1) (domain t2)) ∧
         ∀t1 v1 t2.
           domain (BS t1 v1 t2) =
           {0} ∪ IMAGE (λn. 2 * n + 2) (domain t1) ∪
           IMAGE (λn. 2 * n + 1) (domain t2)

   [<a name="foldi_def-val"><b>foldi_def</b></a>]  Definition

      |- (∀f i acc. foldi f i acc LN = acc) ∧
         (∀f i acc a. foldi f i acc (LS a) = f i a acc) ∧
         (∀f i acc t1 t2.
            foldi f i acc (BN t1 t2) =
            (let inc = sptree$lrnext i
             in
               foldi f (i + inc) (foldi f (i + 2 * inc) acc t1) t2)) ∧
         ∀f i acc t1 a t2.
           foldi f i acc (BS t1 a t2) =
           (let inc = sptree$lrnext i
            in
              foldi f (i + inc) (f i a (foldi f (i + 2 * inc) acc t1)) t2)

   [<a name="fromAList_primitive_def-val"><b>fromAList_primitive_def</b></a>]  Definition

      |- fromAList =
         WFREC (@R. WF R ∧ ∀y x xs. R xs ((x,y)::xs))
           (λfromAList a.
              case a of
                [] =&gt; I LN
              | (x,y)::xs =&gt; I (insert x y (fromAList xs)))

   [<a name="fromList_def-val"><b>fromList_def</b></a>]  Definition

      |- ∀l.
           fromList l =
           SND (FOLDL (λ(i,t) a. (i + 1,insert i a t)) (0,LN) l)

   [<a name="insert_curried_def-val"><b>insert_curried_def</b></a>]  Definition

      |- ∀x x1 x2. insert x x1 x2 = insert_tupled (x,x1,x2)

   [<a name="insert_tupled_primitive_def-val"><b>insert_tupled_primitive_def</b></a>]  Definition

      |- insert_tupled =
         WFREC
           (@R.
              WF R ∧
              (∀a k. k ≠ 0 ∧ ¬EVEN k ⇒ R ((k − 1) DIV 2,a,LN) (k,a,LN)) ∧
              (∀a k. k ≠ 0 ∧ EVEN k ⇒ R ((k − 1) DIV 2,a,LN) (k,a,LN)) ∧
              (∀a' a k.
                 k ≠ 0 ∧ ¬EVEN k ⇒ R ((k − 1) DIV 2,a,LN) (k,a,LS a')) ∧
              (∀a' a k.
                 k ≠ 0 ∧ EVEN k ⇒ R ((k − 1) DIV 2,a,LN) (k,a,LS a')) ∧
              (∀t1 t2 a k.
                 k ≠ 0 ∧ ¬EVEN k ⇒ R ((k − 1) DIV 2,a,t2) (k,a,BN t1 t2)) ∧
              (∀t2 t1 a k.
                 k ≠ 0 ∧ EVEN k ⇒ R ((k − 1) DIV 2,a,t1) (k,a,BN t1 t2)) ∧
              (∀t2 a' t1 a k.
                 k ≠ 0 ∧ EVEN k ⇒
                 R ((k − 1) DIV 2,a,t1) (k,a,BS t1 a' t2)) ∧
              ∀a' t1 t2 a k.
                k ≠ 0 ∧ ¬EVEN k ⇒ R ((k − 1) DIV 2,a,t2) (k,a,BS t1 a' t2))
           (λinsert_tupled a''.
              case a'' of
                (k,a,LN) =&gt;
                  I
                    (if k = 0 then LS a
                     else if EVEN k then
                       BN (insert_tupled ((k − 1) DIV 2,a,LN)) LN
                     else BN LN (insert_tupled ((k − 1) DIV 2,a,LN)))
              | (k,a,LS a') =&gt;
                  I
                    (if k = 0 then LS a
                     else if EVEN k then
                       BS (insert_tupled ((k − 1) DIV 2,a,LN)) a' LN
                     else BS LN a' (insert_tupled ((k − 1) DIV 2,a,LN)))
              | (k,a,BN t1 t2) =&gt;
                  I
                    (if k = 0 then BS t1 a t2
                     else if EVEN k then
                       BN (insert_tupled ((k − 1) DIV 2,a,t1)) t2
                     else BN t1 (insert_tupled ((k − 1) DIV 2,a,t2)))
              | (k,a,BS t1' a''' t2') =&gt;
                  I
                    (if k = 0 then BS t1' a t2'
                     else if EVEN k then
                       BS (insert_tupled ((k − 1) DIV 2,a,t1')) a''' t2'
                     else
                       BS t1' a''' (insert_tupled ((k − 1) DIV 2,a,t2'))))

   [<a name="inter_def-val"><b>inter_def</b></a>]  Definition

      |- (∀t. isEmpty (inter LN t)) ∧
         (∀a t.
            inter (LS a) t =
            case t of
              LN =&gt; LN
            | LS b =&gt; LS a
            | BN t1 t2 =&gt; LN
            | BS t1' v4 t2' =&gt; LS a) ∧
         (∀t1 t2 t.
            inter (BN t1 t2) t =
            case t of
              LN =&gt; LN
            | LS a =&gt; LN
            | BN t1' t2' =&gt; mk_BN (inter t1 t1') (inter t2 t2')
            | BS t1'' a'' t2'' =&gt; mk_BN (inter t1 t1'') (inter t2 t2'')) ∧
         ∀t1 a t2 t.
           inter (BS t1 a t2) t =
           case t of
             LN =&gt; LN
           | LS a' =&gt; LS a
           | BN t1' t2' =&gt; mk_BN (inter t1 t1') (inter t2 t2')
           | BS t1'' a''' t2'' =&gt; mk_BS (inter t1 t1'') a (inter t2 t2'')

   [<a name="inter_eq_def-val"><b>inter_eq_def</b></a>]  Definition

      |- (∀t. isEmpty (inter_eq LN t)) ∧
         (∀a t.
            inter_eq (LS a) t =
            case t of
              LN =&gt; LN
            | LS b =&gt; if a = b then LS a else LN
            | BN t1 t2 =&gt; LN
            | BS t1' b' t2' =&gt; if a = b' then LS a else LN) ∧
         (∀t1 t2 t.
            inter_eq (BN t1 t2) t =
            case t of
              LN =&gt; LN
            | LS a =&gt; LN
            | BN t1' t2' =&gt; mk_BN (inter_eq t1 t1') (inter_eq t2 t2')
            | BS t1'' a'' t2'' =&gt;
                mk_BN (inter_eq t1 t1'') (inter_eq t2 t2'')) ∧
         ∀t1 a t2 t.
           inter_eq (BS t1 a t2) t =
           case t of
             LN =&gt; LN
           | LS a' =&gt; if a' = a then LS a else LN
           | BN t1' t2' =&gt; mk_BN (inter_eq t1 t1') (inter_eq t2 t2')
           | BS t1'' a''' t2'' =&gt;
               if a''' = a then
                 mk_BS (inter_eq t1 t1'') a (inter_eq t2 t2'')
               else mk_BN (inter_eq t1 t1'') (inter_eq t2 t2'')

   [<a name="lookup_curried_def-val"><b>lookup_curried_def</b></a>]  Definition

      |- ∀x x1. lookup x x1 = lookup_tupled (x,x1)

   [<a name="lookup_tupled_primitive_def-val"><b>lookup_tupled_primitive_def</b></a>]  Definition

      |- lookup_tupled =
         WFREC
           (@R.
              WF R ∧
              (∀t2 t1 k.
                 k ≠ 0 ⇒
                 R ((k − 1) DIV 2,if EVEN k then t1 else t2)
                   (k,BN t1 t2)) ∧
              ∀a t2 t1 k.
                k ≠ 0 ⇒
                R ((k − 1) DIV 2,if EVEN k then t1 else t2) (k,BS t1 a t2))
           (λlookup_tupled a'.
              case a' of
                (k,LN) =&gt; I NONE
              | (k,LS a) =&gt; I (if k = 0 then SOME a else NONE)
              | (k,BN t1 t2) =&gt;
                  I
                    (if k = 0 then NONE
                     else
                       lookup_tupled
                         ((k − 1) DIV 2,if EVEN k then t1 else t2))
              | (k,BS t1' a'' t2') =&gt;
                  I
                    (if k = 0 then SOME a''
                     else
                       lookup_tupled
                         ((k − 1) DIV 2,if EVEN k then t1' else t2')))

   [<a name="lrnext_primitive_def-val"><b>lrnext_primitive_def</b></a>]  Definition

      |- sptree$lrnext =
         WFREC (@R. WF R ∧ ∀n. n ≠ 0 ⇒ R ((n − 1) DIV 2) n)
           (λlrnext n. I (if n = 0 then 1 else 2 * lrnext ((n − 1) DIV 2)))

   [<a name="map_def-val"><b>map_def</b></a>]  Definition

      |- (∀f. isEmpty (map f LN)) ∧ (∀f a. map f (LS a) = LS (f a)) ∧
         (∀f t1 t2. map f (BN t1 t2) = BN (map f t1) (map f t2)) ∧
         ∀f t1 a t2. map f (BS t1 a t2) = BS (map f t1) (f a) (map f t2)

   [<a name="mk_BN_curried_def-val"><b>mk_BN_curried_def</b></a>]  Definition

      |- ∀x x1. mk_BN x x1 = mk_BN_tupled (x,x1)

   [<a name="mk_BN_tupled_primitive_def-val"><b>mk_BN_tupled_primitive_def</b></a>]  Definition

      |- mk_BN_tupled =
         WFREC (@R. WF R)
           (λmk_BN_tupled a.
              case a of
                (LN,LN) =&gt; I LN
              | (LN,LS v20) =&gt; I (BN LN (LS v20))
              | (LN,BN v21 v22) =&gt; I (BN LN (BN v21 v22))
              | (LN,BS v23 v24 v25) =&gt; I (BN LN (BS v23 v24 v25))
              | (LS v8,v1) =&gt; I (BN (LS v8) v1)
              | (BN v9 v10,v1) =&gt; I (BN (BN v9 v10) v1)
              | (BS v11 v12 v13,v1) =&gt; I (BN (BS v11 v12 v13) v1))

   [<a name="mk_BS_curried_def-val"><b>mk_BS_curried_def</b></a>]  Definition

      |- ∀x x1 x2. mk_BS x x1 x2 = mk_BS_tupled (x,x1,x2)

   [<a name="mk_BS_tupled_primitive_def-val"><b>mk_BS_tupled_primitive_def</b></a>]  Definition

      |- mk_BS_tupled =
         WFREC (@R. WF R)
           (λmk_BS_tupled a.
              case a of
                (LN,x,LN) =&gt; I (LS x)
              | (LS v22,x,LN) =&gt; I (BS (LS v22) x LN)
              | (BN v23 v24,x,LN) =&gt; I (BS (BN v23 v24) x LN)
              | (BS v25 v26 v27,x,LN) =&gt; I (BS (BS v25 v26 v27) x LN)
              | (v,x,LS v10) =&gt; I (BS v x (LS v10))
              | (v,x,BN v11 v12) =&gt; I (BS v x (BN v11 v12))
              | (v,x,BS v13 v14 v15) =&gt; I (BS v x (BS v13 v14 v15)))

   [<a name="mk_wf_def-val"><b>mk_wf_def</b></a>]  Definition

      |- isEmpty (mk_wf LN) ∧ (∀x. mk_wf (LS x) = LS x) ∧
         (∀t1 t2. mk_wf (BN t1 t2) = mk_BN (mk_wf t1) (mk_wf t2)) ∧
         ∀t1 x t2. mk_wf (BS t1 x t2) = mk_BS (mk_wf t1) x (mk_wf t2)

   [<a name="size_def-val"><b>size_def</b></a>]  Definition

      |- (size LN = 0) ∧ (∀a. size (LS a) = 1) ∧
         (∀t1 t2. size (BN t1 t2) = size t1 + size t2) ∧
         ∀t1 a t2. size (BS t1 a t2) = size t1 + size t2 + 1

   [<a name="spt_TY_DEF-val"><b>spt_TY_DEF</b></a>]  Definition

      |- ∃rep.
           TYPE_DEFINITION
             (λa0'.
                ∀'spt' .
                  (∀a0'.
                     (a0' = ind_type$CONSTR 0 ARB (λn. ind_type$BOTTOM)) ∨
                     (∃a.
                        a0' =
                        (λa.
                           ind_type$CONSTR (SUC 0) a (λn. ind_type$BOTTOM))
                          a) ∨
                     (∃a0 a1.
                        (a0' =
                         (λa0 a1.
                            ind_type$CONSTR (SUC (SUC 0)) ARB
                              (ind_type$FCONS a0
                                 (ind_type$FCONS a1
                                    (λn. ind_type$BOTTOM)))) a0 a1) ∧
                        'spt' a0 ∧ 'spt' a1) ∨
                     (∃a0 a1 a2.
                        (a0' =
                         (λa0 a1 a2.
                            ind_type$CONSTR (SUC (SUC (SUC 0))) a1
                              (ind_type$FCONS a0
                                 (ind_type$FCONS a2
                                    (λn. ind_type$BOTTOM)))) a0 a1 a2) ∧
                        'spt' a0 ∧ 'spt' a2) ⇒
                     'spt' a0') ⇒
                  'spt' a0') rep

   [<a name="spt_case_def-val"><b>spt_case_def</b></a>]  Definition

      |- (∀v f f1 f2. spt_CASE LN v f f1 f2 = v) ∧
         (∀a v f f1 f2. spt_CASE (LS a) v f f1 f2 = f a) ∧
         (∀a0 a1 v f f1 f2. spt_CASE (BN a0 a1) v f f1 f2 = f1 a0 a1) ∧
         ∀a0 a1 a2 v f f1 f2.
           spt_CASE (BS a0 a1 a2) v f f1 f2 = f2 a0 a1 a2

   [<a name="spt_size_def-val"><b>spt_size_def</b></a>]  Definition

      |- (∀f. spt_size f LN = 0) ∧ (∀f a. spt_size f (LS a) = 1 + f a) ∧
         (∀f a0 a1.
            spt_size f (BN a0 a1) = 1 + (spt_size f a0 + spt_size f a1)) ∧
         ∀f a0 a1 a2.
           spt_size f (BS a0 a1 a2) =
           1 + (spt_size f a0 + (f a1 + spt_size f a2))

   [<a name="toAList_def-val"><b>toAList_def</b></a>]  Definition

      |- toAList = foldi (λk v a. (k,v)::a) 0 []

   [<a name="toListA_def-val"><b>toListA_def</b></a>]  Definition

      |- (∀acc. toListA acc LN = acc) ∧
         (∀acc a. toListA acc (LS a) = a::acc) ∧
         (∀acc t1 t2.
            toListA acc (BN t1 t2) = toListA (toListA acc t2) t1) ∧
         ∀acc t1 a t2.
           toListA acc (BS t1 a t2) = toListA (a::toListA acc t2) t1

   [<a name="toList_def-val"><b>toList_def</b></a>]  Definition

      |- ∀m. toList m = toListA [] m

   [<a name="union_def-val"><b>union_def</b></a>]  Definition

      |- (∀t. union LN t = t) ∧
         (∀a t.
            union (LS a) t =
            case t of
              LN =&gt; LS a
            | LS b =&gt; LS a
            | BN t1 t2 =&gt; BS t1 a t2
            | BS t1' v4 t2' =&gt; BS t1' a t2') ∧
         (∀t1 t2 t.
            union (BN t1 t2) t =
            case t of
              LN =&gt; BN t1 t2
            | LS a =&gt; BS t1 a t2
            | BN t1' t2' =&gt; BN (union t1 t1') (union t2 t2')
            | BS t1'' a'' t2'' =&gt; BS (union t1 t1'') a'' (union t2 t2'')) ∧
         ∀t1 a t2 t.
           union (BS t1 a t2) t =
           case t of
             LN =&gt; BS t1 a t2
           | LS a' =&gt; BS t1 a t2
           | BN t1' t2' =&gt; BS (union t1 t1') a (union t2 t2')
           | BS t1'' a''' t2'' =&gt; BS (union t1 t1'') a (union t2 t2'')

   [<a name="wf_def-val"><b>wf_def</b></a>]  Definition

      |- (wf LN ⇔ T) ∧ (∀a. wf (LS a) ⇔ T) ∧
         (∀t1 t2.
            wf (BN t1 t2) ⇔ wf t1 ∧ wf t2 ∧ ¬(isEmpty t1 ∧ isEmpty t2)) ∧
         ∀t1 a t2.
           wf (BS t1 a t2) ⇔ wf t1 ∧ wf t2 ∧ ¬(isEmpty t1 ∧ isEmpty t2)

   [<a name="ALL_DISTINCT_MAP_FST_toAList-val"><b>ALL_DISTINCT_MAP_FST_toAList</b></a>]  Theorem

      |- ∀t. ALL_DISTINCT (MAP FST (toAList t))

   [<a name="ALOOKUP_toAList-val"><b>ALOOKUP_toAList</b></a>]  Theorem

      |- ∀t x. ALOOKUP (toAList t) x = lookup x t

   [<a name="FINITE_domain-val"><b>FINITE_domain</b></a>]  Theorem

      |- FINITE (domain t)

   [<a name="MEM_toAList-val"><b>MEM_toAList</b></a>]  Theorem

      |- ∀t k v. MEM (k,v) (toAList t) ⇔ (lookup k t = SOME v)

   [<a name="MEM_toList-val"><b>MEM_toList</b></a>]  Theorem

      |- ∀x t. MEM x (toList t) ⇔ ∃k. lookup k t = SOME x

   [<a name="datatype_spt-val"><b>datatype_spt</b></a>]  Theorem

      |- DATATYPE (spt LN LS BN BS)

   [<a name="delete_compute-val"><b>delete_compute</b></a>]  Theorem

      |- (delete (NUMERAL n) t = delete n t) ∧ isEmpty (delete 0 LN) ∧
         isEmpty (delete 0 (LS a)) ∧ (delete 0 (BN t1 t2) = BN t1 t2) ∧
         (delete 0 (BS t1 a t2) = BN t1 t2) ∧ isEmpty (delete ZERO LN) ∧
         isEmpty (delete ZERO (LS a)) ∧
         (delete ZERO (BN t1 t2) = BN t1 t2) ∧
         (delete ZERO (BS t1 a t2) = BN t1 t2) ∧
         isEmpty (delete (BIT1 n) LN) ∧ (delete (BIT1 n) (LS a) = LS a) ∧
         (delete (BIT1 n) (BN t1 t2) = mk_BN t1 (delete n t2)) ∧
         (delete (BIT1 n) (BS t1 a t2) = mk_BS t1 a (delete n t2)) ∧
         isEmpty (delete (BIT2 n) LN) ∧ (delete (BIT2 n) (LS a) = LS a) ∧
         (delete (BIT2 n) (BN t1 t2) = mk_BN (delete n t1) t2) ∧
         (delete (BIT2 n) (BS t1 a t2) = mk_BS (delete n t1) a t2)

   [<a name="delete_mk_wf-val"><b>delete_mk_wf</b></a>]  Theorem

      |- ∀x t. delete x (mk_wf t) = mk_wf (delete x t)

   [<a name="domain_delete-val"><b>domain_delete</b></a>]  Theorem

      |- domain (delete k t) = domain t DELETE k

   [<a name="domain_empty-val"><b>domain_empty</b></a>]  Theorem

      |- ∀t. wf t ⇒ (isEmpty t ⇔ (domain t = ∅))

   [<a name="domain_foldi-val"><b>domain_foldi</b></a>]  Theorem

      |- domain t = foldi (λk v a. k INSERT a) 0 ∅ t

   [<a name="domain_fromAList-val"><b>domain_fromAList</b></a>]  Theorem

      |- ∀ls. domain (fromAList ls) = set (MAP FST ls)

   [<a name="domain_fromList-val"><b>domain_fromList</b></a>]  Theorem

      |- domain (fromList l) = count (LENGTH l)

   [<a name="domain_insert-val"><b>domain_insert</b></a>]  Theorem

      |- domain (insert k v t) = k INSERT domain t

   [<a name="domain_inter-val"><b>domain_inter</b></a>]  Theorem

      |- domain (inter t1 t2) = domain t1 ∩ domain t2

   [<a name="domain_lookup-val"><b>domain_lookup</b></a>]  Theorem

      |- ∀t k. k ∈ domain t ⇔ ∃v. lookup k t = SOME v

   [<a name="domain_map-val"><b>domain_map</b></a>]  Theorem

      |- ∀s. domain (map f s) = domain s

   [<a name="domain_mk_wf-val"><b>domain_mk_wf</b></a>]  Theorem

      |- ∀t. domain (mk_wf t) = domain t

   [<a name="domain_sing-val"><b>domain_sing</b></a>]  Theorem

      |- domain (insert k v LN) = {k}

   [<a name="domain_union-val"><b>domain_union</b></a>]  Theorem

      |- domain (union t1 t2) = domain t1 ∪ domain t2

   [<a name="foldi_FOLDR_toAList-val"><b>foldi_FOLDR_toAList</b></a>]  Theorem

      |- ∀f a t. foldi f 0 a t = FOLDR (UNCURRY f) a (toAList t)

   [<a name="fromAList_def-val"><b>fromAList_def</b></a>]  Theorem

      |- isEmpty (fromAList []) ∧
         ∀y xs x. fromAList ((x,y)::xs) = insert x y (fromAList xs)

   [<a name="fromAList_ind-val"><b>fromAList_ind</b></a>]  Theorem

      |- ∀P. P [] ∧ (∀x y xs. P xs ⇒ P ((x,y)::xs)) ⇒ ∀v. P v

   [<a name="fromAList_toAList-val"><b>fromAList_toAList</b></a>]  Theorem

      |- ∀t. wf t ⇒ (fromAList (toAList t) = t)

   [<a name="insert_compute-val"><b>insert_compute</b></a>]  Theorem

      |- (insert (NUMERAL n) a t = insert n a t) ∧ (insert 0 a LN = LS a) ∧
         (insert 0 a (LS a') = LS a) ∧
         (insert 0 a (BN t1 t2) = BS t1 a t2) ∧
         (insert 0 a (BS t1 a' t2) = BS t1 a t2) ∧
         (insert ZERO a LN = LS a) ∧ (insert ZERO a (LS a') = LS a) ∧
         (insert ZERO a (BN t1 t2) = BS t1 a t2) ∧
         (insert ZERO a (BS t1 a' t2) = BS t1 a t2) ∧
         (insert (BIT1 n) a LN = BN LN (insert n a LN)) ∧
         (insert (BIT1 n) a (LS a') = BS LN a' (insert n a LN)) ∧
         (insert (BIT1 n) a (BN t1 t2) = BN t1 (insert n a t2)) ∧
         (insert (BIT1 n) a (BS t1 a' t2) = BS t1 a' (insert n a t2)) ∧
         (insert (BIT2 n) a LN = BN (insert n a LN) LN) ∧
         (insert (BIT2 n) a (LS a') = BS (insert n a LN) a' LN) ∧
         (insert (BIT2 n) a (BN t1 t2) = BN (insert n a t1) t2) ∧
         (insert (BIT2 n) a (BS t1 a' t2) = BS (insert n a t1) a' t2)

   [<a name="insert_def-val"><b>insert_def</b></a>]  Theorem

      |- (∀k a.
            insert k a LN =
            if k = 0 then LS a
            else if EVEN k then BN (insert ((k − 1) DIV 2) a LN) LN
            else BN LN (insert ((k − 1) DIV 2) a LN)) ∧
         (∀k a' a.
            insert k a (LS a') =
            if k = 0 then LS a
            else if EVEN k then BS (insert ((k − 1) DIV 2) a LN) a' LN
            else BS LN a' (insert ((k − 1) DIV 2) a LN)) ∧
         (∀t2 t1 k a.
            insert k a (BN t1 t2) =
            if k = 0 then BS t1 a t2
            else if EVEN k then BN (insert ((k − 1) DIV 2) a t1) t2
            else BN t1 (insert ((k − 1) DIV 2) a t2)) ∧
         ∀t2 t1 k a' a.
           insert k a (BS t1 a' t2) =
           if k = 0 then BS t1 a t2
           else if EVEN k then BS (insert ((k − 1) DIV 2) a t1) a' t2
           else BS t1 a' (insert ((k − 1) DIV 2) a t2)

   [<a name="insert_ind-val"><b>insert_ind</b></a>]  Theorem

      |- ∀P.
           (∀k a.
              (k ≠ 0 ∧ EVEN k ⇒ P ((k − 1) DIV 2) a LN) ∧
              (k ≠ 0 ∧ ¬EVEN k ⇒ P ((k − 1) DIV 2) a LN) ⇒
              P k a LN) ∧
           (∀k a a'.
              (k ≠ 0 ∧ EVEN k ⇒ P ((k − 1) DIV 2) a LN) ∧
              (k ≠ 0 ∧ ¬EVEN k ⇒ P ((k − 1) DIV 2) a LN) ⇒
              P k a (LS a')) ∧
           (∀k a t1 t2.
              (k ≠ 0 ∧ EVEN k ⇒ P ((k − 1) DIV 2) a t1) ∧
              (k ≠ 0 ∧ ¬EVEN k ⇒ P ((k − 1) DIV 2) a t2) ⇒
              P k a (BN t1 t2)) ∧
           (∀k a t1 a' t2.
              (k ≠ 0 ∧ EVEN k ⇒ P ((k − 1) DIV 2) a t1) ∧
              (k ≠ 0 ∧ ¬EVEN k ⇒ P ((k − 1) DIV 2) a t2) ⇒
              P k a (BS t1 a' t2)) ⇒
           ∀v v1 v2. P v v1 v2

   [<a name="insert_mk_wf-val"><b>insert_mk_wf</b></a>]  Theorem

      |- ∀x v t. insert x v (mk_wf t) = mk_wf (insert x v t)

   [<a name="insert_notEmpty-val"><b>insert_notEmpty</b></a>]  Theorem

      |- insert k a t ≠ LN

   [<a name="insert_union-val"><b>insert_union</b></a>]  Theorem

      |- ∀k v s. insert k v s = union (insert k v LN) s

   [<a name="inter_LN-val"><b>inter_LN</b></a>]  Theorem

      |- ∀t. isEmpty (inter t LN) ∧ isEmpty (inter LN t)

   [<a name="inter_assoc-val"><b>inter_assoc</b></a>]  Theorem

      |- ∀t1 t2 t3. inter t1 (inter t2 t3) = inter (inter t1 t2) t3

   [<a name="inter_eq-val"><b>inter_eq</b></a>]  Theorem

      |- ∀t1 t2 t3 t4.
           (inter t1 t2 = inter t3 t4) ⇔
           ∀x. lookup x (inter t1 t2) = lookup x (inter t3 t4)

   [<a name="isEmpty_toList-val"><b>isEmpty_toList</b></a>]  Theorem

      |- ∀t. wf t ⇒ (isEmpty t ⇔ (toList t = []))

   [<a name="isEmpty_toListA-val"><b>isEmpty_toListA</b></a>]  Theorem

      |- ∀t acc. wf t ⇒ (isEmpty t ⇔ (toListA acc t = acc))

   [<a name="isEmpty_union-val"><b>isEmpty_union</b></a>]  Theorem

      |- isEmpty (union m1 m2) ⇔ isEmpty m1 ∧ isEmpty m2

   [<a name="lookup_NONE_domain-val"><b>lookup_NONE_domain</b></a>]  Theorem

      |- (lookup k t = NONE) ⇔ k ∉ domain t

   [<a name="lookup_compute-val"><b>lookup_compute</b></a>]  Theorem

      |- (lookup (NUMERAL n) t = lookup n t) ∧ (lookup 0 LN = NONE) ∧
         (lookup 0 (LS a) = SOME a) ∧ (lookup 0 (BN t1 t2) = NONE) ∧
         (lookup 0 (BS t1 a t2) = SOME a) ∧ (lookup ZERO LN = NONE) ∧
         (lookup ZERO (LS a) = SOME a) ∧ (lookup ZERO (BN t1 t2) = NONE) ∧
         (lookup ZERO (BS t1 a t2) = SOME a) ∧
         (lookup (BIT1 n) LN = NONE) ∧ (lookup (BIT1 n) (LS a) = NONE) ∧
         (lookup (BIT1 n) (BN t1 t2) = lookup n t2) ∧
         (lookup (BIT1 n) (BS t1 a t2) = lookup n t2) ∧
         (lookup (BIT2 n) LN = NONE) ∧ (lookup (BIT2 n) (LS a) = NONE) ∧
         (lookup (BIT2 n) (BN t1 t2) = lookup n t1) ∧
         (lookup (BIT2 n) (BS t1 a t2) = lookup n t1)

   [<a name="lookup_def-val"><b>lookup_def</b></a>]  Theorem

      |- (∀k. lookup k LN = NONE) ∧
         (∀k a. lookup k (LS a) = if k = 0 then SOME a else NONE) ∧
         (∀t2 t1 k.
            lookup k (BN t1 t2) =
            if k = 0 then NONE
            else lookup ((k − 1) DIV 2) (if EVEN k then t1 else t2)) ∧
         ∀t2 t1 k a.
           lookup k (BS t1 a t2) =
           if k = 0 then SOME a
           else lookup ((k − 1) DIV 2) (if EVEN k then t1 else t2)

   [<a name="lookup_delete-val"><b>lookup_delete</b></a>]  Theorem

      |- ∀t k1 k2.
           lookup k1 (delete k2 t) = if k1 = k2 then NONE else lookup k1 t

   [<a name="lookup_difference-val"><b>lookup_difference</b></a>]  Theorem

      |- ∀m1 m2 k.
           lookup k (difference m1 m2) =
           if lookup k m2 = NONE then lookup k m1 else NONE

   [<a name="lookup_fromAList-val"><b>lookup_fromAList</b></a>]  Theorem

      |- ∀ls x. lookup x (fromAList ls) = ALOOKUP ls x

   [<a name="lookup_fromAList_toAList-val"><b>lookup_fromAList_toAList</b></a>]  Theorem

      |- ∀t x. lookup x (fromAList (toAList t)) = lookup x t

   [<a name="lookup_fromList-val"><b>lookup_fromList</b></a>]  Theorem

      |- lookup n (fromList l) =
         if n &lt; LENGTH l then SOME (EL n l) else NONE

   [<a name="lookup_ind-val"><b>lookup_ind</b></a>]  Theorem

      |- ∀P.
           (∀k. P k LN) ∧ (∀k a. P k (LS a)) ∧
           (∀k t1 t2.
              (k ≠ 0 ⇒ P ((k − 1) DIV 2) (if EVEN k then t1 else t2)) ⇒
              P k (BN t1 t2)) ∧
           (∀k t1 a t2.
              (k ≠ 0 ⇒ P ((k − 1) DIV 2) (if EVEN k then t1 else t2)) ⇒
              P k (BS t1 a t2)) ⇒
           ∀v v1. P v v1

   [<a name="lookup_insert-val"><b>lookup_insert</b></a>]  Theorem

      |- ∀k2 v t k1.
           lookup k1 (insert k2 v t) =
           if k1 = k2 then SOME v else lookup k1 t

   [<a name="lookup_insert1-val"><b>lookup_insert1</b></a>]  Theorem

      |- ∀k a t. lookup k (insert k a t) = SOME a

   [<a name="lookup_inter-val"><b>lookup_inter</b></a>]  Theorem

      |- ∀m1 m2 k.
           lookup k (inter m1 m2) =
           case (lookup k m1,lookup k m2) of
             (NONE,v4) =&gt; NONE
           | (SOME v,NONE) =&gt; NONE
           | (SOME v,SOME w) =&gt; SOME v

   [<a name="lookup_inter_EQ-val"><b>lookup_inter_EQ</b></a>]  Theorem

      |- ((lookup x (inter t1 t2) = SOME y) ⇔
          (lookup x t1 = SOME y) ∧ lookup x t2 ≠ NONE) ∧
         ((lookup x (inter t1 t2) = NONE) ⇔
          (lookup x t1 = NONE) ∨ (lookup x t2 = NONE))

   [<a name="lookup_inter_alt-val"><b>lookup_inter_alt</b></a>]  Theorem

      |- lookup x (inter t1 t2) =
         if x ∈ domain t2 then lookup x t1 else NONE

   [<a name="lookup_inter_assoc-val"><b>lookup_inter_assoc</b></a>]  Theorem

      |- lookup x (inter t1 (inter t2 t3)) =
         lookup x (inter (inter t1 t2) t3)

   [<a name="lookup_inter_eq-val"><b>lookup_inter_eq</b></a>]  Theorem

      |- ∀m1 m2 k.
           lookup k (inter_eq m1 m2) =
           case lookup k m1 of
             NONE =&gt; NONE
           | SOME v =&gt; if lookup k m2 = SOME v then SOME v else NONE

   [<a name="lookup_map-val"><b>lookup_map</b></a>]  Theorem

      |- ∀s x. lookup x (map f s) = OPTION_MAP f (lookup x s)

   [<a name="lookup_mk_wf-val"><b>lookup_mk_wf</b></a>]  Theorem

      |- ∀x t. lookup x (mk_wf t) = lookup x t

   [<a name="lookup_union-val"><b>lookup_union</b></a>]  Theorem

      |- ∀m1 m2 k.
           lookup k (union m1 m2) =
           case lookup k m1 of NONE =&gt; lookup k m2 | SOME v =&gt; SOME v

   [<a name="lrnext_def-val"><b>lrnext_def</b></a>]  Theorem

      |- ∀n.
           sptree$lrnext n =
           if n = 0 then 1 else 2 * sptree$lrnext ((n − 1) DIV 2)

   [<a name="lrnext_ind-val"><b>lrnext_ind</b></a>]  Theorem

      |- ∀P. (∀n. (n ≠ 0 ⇒ P ((n − 1) DIV 2)) ⇒ P n) ⇒ ∀v. P v

   [<a name="lrnext_thm-val"><b>lrnext_thm</b></a>]  Theorem

      |- (∀a. sptree$lrnext 0 = 1) ∧
         (∀n a. sptree$lrnext (NUMERAL n) = sptree$lrnext n) ∧
         (sptree$lrnext ZERO = 1) ∧
         (∀n. sptree$lrnext (BIT1 n) = 2 * sptree$lrnext n) ∧
         ∀n. sptree$lrnext (BIT2 n) = 2 * sptree$lrnext n

   [<a name="map_LN-val"><b>map_LN</b></a>]  Theorem

      |- ∀t. isEmpty (map f t) ⇔ isEmpty t

   [<a name="mk_BN_def-val"><b>mk_BN_def</b></a>]  Theorem

      |- isEmpty (mk_BN LN LN) ∧ (mk_BN LN (LS v14) = BN LN (LS v14)) ∧
         (mk_BN LN (BN v15 v16) = BN LN (BN v15 v16)) ∧
         (mk_BN LN (BS v17 v18 v19) = BN LN (BS v17 v18 v19)) ∧
         (mk_BN (LS v2) t2 = BN (LS v2) t2) ∧
         (mk_BN (BN v3 v4) t2 = BN (BN v3 v4) t2) ∧
         (mk_BN (BS v5 v6 v7) t2 = BN (BS v5 v6 v7) t2)

   [<a name="mk_BN_ind-val"><b>mk_BN_ind</b></a>]  Theorem

      |- ∀P.
           P LN LN ∧ (∀v14. P LN (LS v14)) ∧
           (∀v15 v16. P LN (BN v15 v16)) ∧
           (∀v17 v18 v19. P LN (BS v17 v18 v19)) ∧ (∀v2 t2. P (LS v2) t2) ∧
           (∀v3 v4 t2. P (BN v3 v4) t2) ∧
           (∀v5 v6 v7 t2. P (BS v5 v6 v7) t2) ⇒
           ∀v v1. P v v1

   [<a name="mk_BS_def-val"><b>mk_BS_def</b></a>]  Theorem

      |- (mk_BS LN x LN = LS x) ∧
         (mk_BS (LS v16) x LN = BS (LS v16) x LN) ∧
         (mk_BS (BN v17 v18) x LN = BS (BN v17 v18) x LN) ∧
         (mk_BS (BS v19 v20 v21) x LN = BS (BS v19 v20 v21) x LN) ∧
         (mk_BS t1 x (LS v4) = BS t1 x (LS v4)) ∧
         (mk_BS t1 x (BN v5 v6) = BS t1 x (BN v5 v6)) ∧
         (mk_BS t1 x (BS v7 v8 v9) = BS t1 x (BS v7 v8 v9))

   [<a name="mk_BS_ind-val"><b>mk_BS_ind</b></a>]  Theorem

      |- ∀P.
           (∀x. P LN x LN) ∧ (∀v16 x. P (LS v16) x LN) ∧
           (∀v17 v18 x. P (BN v17 v18) x LN) ∧
           (∀v19 v20 v21 x. P (BS v19 v20 v21) x LN) ∧
           (∀t1 x v4. P t1 x (LS v4)) ∧ (∀t1 x v5 v6. P t1 x (BN v5 v6)) ∧
           (∀t1 x v7 v8 v9. P t1 x (BS v7 v8 v9)) ⇒
           ∀v v1 v2. P v v1 v2

   [<a name="mk_wf_eq-val"><b>mk_wf_eq</b></a>]  Theorem

      |- ∀t1 t2. (mk_wf t1 = mk_wf t2) ⇔ ∀x. lookup x t1 = lookup x t2

   [<a name="set_foldi_keys-val"><b>set_foldi_keys</b></a>]  Theorem

      |- ∀t a i.
           foldi (λk v a. k INSERT a) i a t =
           a ∪ IMAGE (λn. i + sptree$lrnext i * n) (domain t)

   [<a name="spt_11-val"><b>spt_11</b></a>]  Theorem

      |- (∀a a'. (LS a = LS a') ⇔ (a = a')) ∧
         (∀a0 a1 a0' a1'.
            (BN a0 a1 = BN a0' a1') ⇔ (a0 = a0') ∧ (a1 = a1')) ∧
         ∀a0 a1 a2 a0' a1' a2'.
           (BS a0 a1 a2 = BS a0' a1' a2') ⇔
           (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2')

   [<a name="spt_Axiom-val"><b>spt_Axiom</b></a>]  Theorem

      |- ∀f0 f1 f2 f3.
           ∃fn.
             (fn LN = f0) ∧ (∀a. fn (LS a) = f1 a) ∧
             (∀a0 a1. fn (BN a0 a1) = f2 a0 a1 (fn a0) (fn a1)) ∧
             ∀a0 a1 a2. fn (BS a0 a1 a2) = f3 a1 a0 a2 (fn a0) (fn a2)

   [<a name="spt_case_cong-val"><b>spt_case_cong</b></a>]  Theorem

      |- ∀M M' v f f1 f2.
           (M = M') ∧ (isEmpty M' ⇒ (v = v')) ∧
           (∀a. (M' = LS a) ⇒ (f a = f' a)) ∧
           (∀a0 a1. (M' = BN a0 a1) ⇒ (f1 a0 a1 = f1' a0 a1)) ∧
           (∀a0 a1 a2. (M' = BS a0 a1 a2) ⇒ (f2 a0 a1 a2 = f2' a0 a1 a2)) ⇒
           (spt_CASE M v f f1 f2 = spt_CASE M' v' f' f1' f2')

   [<a name="spt_distinct-val"><b>spt_distinct</b></a>]  Theorem

      |- (∀a. LN ≠ LS a) ∧ (∀a1 a0. LN ≠ BN a0 a1) ∧
         (∀a2 a1 a0. LN ≠ BS a0 a1 a2) ∧ (∀a1 a0 a. LS a ≠ BN a0 a1) ∧
         (∀a2 a1 a0 a. LS a ≠ BS a0 a1 a2) ∧
         ∀a2 a1' a1 a0' a0. BN a0 a1 ≠ BS a0' a1' a2

   [<a name="spt_eq_thm-val"><b>spt_eq_thm</b></a>]  Theorem

      |- ∀t1 t2.
           wf t1 ∧ wf t2 ⇒ ((t1 = t2) ⇔ ∀n. lookup n t1 = lookup n t2)

   [<a name="spt_induction-val"><b>spt_induction</b></a>]  Theorem

      |- ∀P.
           P LN ∧ (∀a. P (LS a)) ∧ (∀s s0. P s ∧ P s0 ⇒ P (BN s s0)) ∧
           (∀s s0. P s ∧ P s0 ⇒ ∀a. P (BS s a s0)) ⇒
           ∀s. P s

   [<a name="spt_nchotomy-val"><b>spt_nchotomy</b></a>]  Theorem

      |- ∀ss.
           isEmpty ss ∨ (∃a. ss = LS a) ∨ (∃s s0. ss = BN s s0) ∨
           ∃s a s0. ss = BS s a s0

   [<a name="toListA_append-val"><b>toListA_append</b></a>]  Theorem

      |- ∀t acc. toListA acc t = toListA [] t ++ acc

   [<a name="toList_map-val"><b>toList_map</b></a>]  Theorem

      |- ∀s. toList (map f s) = MAP f (toList s)

   [<a name="union_LN-val"><b>union_LN</b></a>]  Theorem

      |- ∀t. (union t LN = t) ∧ (union LN t = t)

   [<a name="union_assoc-val"><b>union_assoc</b></a>]  Theorem

      |- ∀t1 t2 t3. union t1 (union t2 t3) = union (union t1 t2) t3

   [<a name="union_mk_wf-val"><b>union_mk_wf</b></a>]  Theorem

      |- ∀t1 t2. inter (mk_wf t1) (mk_wf t2) = mk_wf (inter t1 t2)

   [<a name="wf_delete-val"><b>wf_delete</b></a>]  Theorem

      |- ∀t k. wf t ⇒ wf (delete k t)

   [<a name="wf_fromAList-val"><b>wf_fromAList</b></a>]  Theorem

      |- ∀ls. wf (fromAList ls)

   [<a name="wf_insert-val"><b>wf_insert</b></a>]  Theorem

      |- ∀k a t. wf t ⇒ wf (insert k a t)

   [<a name="wf_inter-val"><b>wf_inter</b></a>]  Theorem

      |- ∀m1 m2. wf (inter m1 m2)

   [<a name="wf_map-val"><b>wf_map</b></a>]  Theorem

      |- ∀t f. wf (map f t) ⇔ wf t

   [<a name="wf_mk_id-val"><b>wf_mk_id</b></a>]  Theorem

      |- ∀t. wf t ⇒ (mk_wf t = t)

   [<a name="wf_mk_wf-val"><b>wf_mk_wf</b></a>]  Theorem

      |- ∀t. wf (mk_wf t)

   [<a name="wf_union-val"><b>wf_union</b></a>]  Theorem

      |- ∀m1 m2. wf m1 ∧ wf m2 ⇒ wf (union m1 m2)


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/patricia/sptreeScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-11</a></em></p></body></html>
