<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure fmapalTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure fmapalTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/enumfset/fmapalScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature fmapalTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#AP_SND-val">AP_SND</a> : thm
<a name="line7"></a>    val <a href="#OFU-val">OFU</a> : thm
<a name="line8"></a>    val <a href="#OPTION_FLAT_primitive-val">OPTION_FLAT_primitive</a> : thm
<a name="line9"></a>    val <a href="#OPTION_UPDATE-val">OPTION_UPDATE</a> : thm
<a name="line10"></a>    val <a href="#ORL_bt_curried-val">ORL_bt_curried</a> : thm
<a name="line11"></a>    val <a href="#ORL_bt_lb_curried-val">ORL_bt_lb_curried</a> : thm
<a name="line12"></a>    val <a href="#ORL_bt_lb_tupled_primitive-val">ORL_bt_lb_tupled_primitive</a> : thm
<a name="line13"></a>    val <a href="#ORL_bt_lb_ub_curried-val">ORL_bt_lb_ub_curried</a> : thm
<a name="line14"></a>    val <a href="#ORL_bt_lb_ub_tupled_primitive-val">ORL_bt_lb_ub_tupled_primitive</a> : thm
<a name="line15"></a>    val <a href="#ORL_bt_tupled_primitive-val">ORL_bt_tupled_primitive</a> : thm
<a name="line16"></a>    val <a href="#ORL_bt_ub_curried-val">ORL_bt_ub_curried</a> : thm
<a name="line17"></a>    val <a href="#ORL_bt_ub_tupled_primitive-val">ORL_bt_ub_tupled_primitive</a> : thm
<a name="line18"></a>    val <a href="#ORL_curried-val">ORL_curried</a> : thm
<a name="line19"></a>    val <a href="#ORL_sublists_curried-val">ORL_sublists_curried</a> : thm
<a name="line20"></a>    val <a href="#ORL_sublists_tupled_primitive-val">ORL_sublists_tupled_primitive</a> : thm
<a name="line21"></a>    val <a href="#ORL_tupled_primitive-val">ORL_tupled_primitive</a> : thm
<a name="line22"></a>    val <a href="#ORWL-val">ORWL</a> : thm
<a name="line23"></a>    val <a href="#UFO-val">UFO</a> : thm
<a name="line24"></a>    val <a href="#assocv_curried-val">assocv_curried</a> : thm
<a name="line25"></a>    val <a href="#assocv_tupled_primitive-val">assocv_tupled_primitive</a> : thm
<a name="line26"></a>    val <a href="#bl_to_fmap_curried-val">bl_to_fmap_curried</a> : thm
<a name="line27"></a>    val <a href="#bl_to_fmap_tupled_primitive-val">bl_to_fmap_tupled_primitive</a> : thm
<a name="line28"></a>    val <a href="#bt_map-val">bt_map</a> : thm
<a name="line29"></a>    val <a href="#bt_rplacv_cn_curried-val">bt_rplacv_cn_curried</a> : thm
<a name="line30"></a>    val <a href="#bt_rplacv_cn_tupled_primitive-val">bt_rplacv_cn_tupled_primitive</a> : thm
<a name="line31"></a>    val <a href="#bt_to_fmap_curried-val">bt_to_fmap_curried</a> : thm
<a name="line32"></a>    val <a href="#bt_to_fmap_lb-val">bt_to_fmap_lb</a> : thm
<a name="line33"></a>    val <a href="#bt_to_fmap_lb_ub-val">bt_to_fmap_lb_ub</a> : thm
<a name="line34"></a>    val <a href="#bt_to_fmap_tupled_primitive-val">bt_to_fmap_tupled_primitive</a> : thm
<a name="line35"></a>    val <a href="#bt_to_fmap_ub-val">bt_to_fmap_ub</a> : thm
<a name="line36"></a>    val <a href="#bt_to_orl_ac_curried-val">bt_to_orl_ac_curried</a> : thm
<a name="line37"></a>    val <a href="#bt_to_orl_ac_tupled_primitive-val">bt_to_orl_ac_tupled_primitive</a> : thm
<a name="line38"></a>    val <a href="#bt_to_orl_curried-val">bt_to_orl_curried</a> : thm
<a name="line39"></a>    val <a href="#bt_to_orl_lb_ac_curried-val">bt_to_orl_lb_ac_curried</a> : thm
<a name="line40"></a>    val <a href="#bt_to_orl_lb_ac_tupled_primitive-val">bt_to_orl_lb_ac_tupled_primitive</a> : thm
<a name="line41"></a>    val <a href="#bt_to_orl_lb_curried-val">bt_to_orl_lb_curried</a> : thm
<a name="line42"></a>    val <a href="#bt_to_orl_lb_tupled_primitive-val">bt_to_orl_lb_tupled_primitive</a> : thm
<a name="line43"></a>    val <a href="#bt_to_orl_lb_ub_ac_curried-val">bt_to_orl_lb_ub_ac_curried</a> : thm
<a name="line44"></a>    val <a href="#bt_to_orl_lb_ub_ac_tupled_AUX-val">bt_to_orl_lb_ub_ac_tupled_AUX</a> : thm
<a name="line45"></a>    val <a href="#bt_to_orl_lb_ub_ac_tupled_primitive-val">bt_to_orl_lb_ub_ac_tupled_primitive</a> : thm
<a name="line46"></a>    val <a href="#bt_to_orl_lb_ub_curried-val">bt_to_orl_lb_ub_curried</a> : thm
<a name="line47"></a>    val <a href="#bt_to_orl_lb_ub_tupled_primitive-val">bt_to_orl_lb_ub_tupled_primitive</a> : thm
<a name="line48"></a>    val <a href="#bt_to_orl_tupled_primitive-val">bt_to_orl_tupled_primitive</a> : thm
<a name="line49"></a>    val <a href="#bt_to_orl_ub_ac_curried-val">bt_to_orl_ub_ac_curried</a> : thm
<a name="line50"></a>    val <a href="#bt_to_orl_ub_ac_tupled_primitive-val">bt_to_orl_ub_ac_tupled_primitive</a> : thm
<a name="line51"></a>    val <a href="#bt_to_orl_ub_curried-val">bt_to_orl_ub_curried</a> : thm
<a name="line52"></a>    val <a href="#bt_to_orl_ub_tupled_primitive-val">bt_to_orl_ub_tupled_primitive</a> : thm
<a name="line53"></a>    val <a href="#diff_merge_curried-val">diff_merge_curried</a> : thm
<a name="line54"></a>    val <a href="#diff_merge_tupled_primitive-val">diff_merge_tupled_primitive</a> : thm
<a name="line55"></a>    val <a href="#fmap-val">fmap</a> : thm
<a name="line56"></a>    val <a href="#incr_build-val">incr_build</a> : thm
<a name="line57"></a>    val <a href="#incr_flat-val">incr_flat</a> : thm
<a name="line58"></a>    val <a href="#incr_merge_curried-val">incr_merge_curried</a> : thm
<a name="line59"></a>    val <a href="#incr_merge_tupled_primitive-val">incr_merge_tupled_primitive</a> : thm
<a name="line60"></a>    val <a href="#incr_sort-val">incr_sort</a> : thm
<a name="line61"></a>    val <a href="#inter_merge_curried-val">inter_merge_curried</a> : thm
<a name="line62"></a>    val <a href="#inter_merge_tupled_primitive-val">inter_merge_tupled_primitive</a> : thm
<a name="line63"></a>    val <a href="#list_rplacv_cn_curried-val">list_rplacv_cn_curried</a> : thm
<a name="line64"></a>    val <a href="#list_rplacv_cn_tupled_primitive-val">list_rplacv_cn_tupled_primitive</a> : thm
<a name="line65"></a>    val <a href="#merge_curried-val">merge_curried</a> : thm
<a name="line66"></a>    val <a href="#merge_out_curried-val">merge_out_curried</a> : thm
<a name="line67"></a>    val <a href="#merge_out_tupled_primitive-val">merge_out_tupled_primitive</a> : thm
<a name="line68"></a>    val <a href="#merge_tupled_primitive-val">merge_tupled_primitive</a> : thm
<a name="line69"></a>    val <a href="#optry-val">optry</a> : thm
<a name="line70"></a>    val <a href="#optry_list_curried-val">optry_list_curried</a> : thm
<a name="line71"></a>    val <a href="#optry_list_tupled_primitive-val">optry_list_tupled_primitive</a> : thm
<a name="line72"></a>    val <a href="#unlookup-val">unlookup</a> : thm
<a name="line73"></a>    val <a href="#vcossa-val">vcossa</a> : thm
<a name="line74"></a>
<a name="line75"></a>  (*  Theorems  *)
<a name="line76"></a>    val <a href="#FAPPLY_fmap_CONS-val">FAPPLY_fmap_CONS</a> : thm
<a name="line77"></a>    val <a href="#FAPPLY_fmap_NIL-val">FAPPLY_fmap_NIL</a> : thm
<a name="line78"></a>    val <a href="#FAPPLY_node-val">FAPPLY_node</a> : thm
<a name="line79"></a>    val <a href="#FAPPLY_nt-val">FAPPLY_nt</a> : thm
<a name="line80"></a>    val <a href="#FMAPAL_FDOM_THM-val">FMAPAL_FDOM_THM</a> : thm
<a name="line81"></a>    val <a href="#FMAPAL_fmap-val">FMAPAL_fmap</a> : thm
<a name="line82"></a>    val <a href="#FUN_fmap_thm-val">FUN_fmap_thm</a> : thm
<a name="line83"></a>    val <a href="#OPTION_FLAT-val">OPTION_FLAT</a> : thm
<a name="line84"></a>    val <a href="#OPTION_FLAT_ind-val">OPTION_FLAT_ind</a> : thm
<a name="line85"></a>    val <a href="#ORL-val">ORL</a> : thm
<a name="line86"></a>    val <a href="#ORL_DRESTRICT_COMPL_IMP-val">ORL_DRESTRICT_COMPL_IMP</a> : thm
<a name="line87"></a>    val <a href="#ORL_DRESTRICT_IMP-val">ORL_DRESTRICT_IMP</a> : thm
<a name="line88"></a>    val <a href="#ORL_FMAPAL-val">ORL_FMAPAL</a> : thm
<a name="line89"></a>    val <a href="#ORL_FUNION_IMP-val">ORL_FUNION_IMP</a> : thm
<a name="line90"></a>    val <a href="#ORL_bt-val">ORL_bt</a> : thm
<a name="line91"></a>    val <a href="#ORL_bt_ind-val">ORL_bt_ind</a> : thm
<a name="line92"></a>    val <a href="#ORL_bt_lb-val">ORL_bt_lb</a> : thm
<a name="line93"></a>    val <a href="#ORL_bt_lb_ind-val">ORL_bt_lb_ind</a> : thm
<a name="line94"></a>    val <a href="#ORL_bt_lb_ub-val">ORL_bt_lb_ub</a> : thm
<a name="line95"></a>    val <a href="#ORL_bt_lb_ub_ind-val">ORL_bt_lb_ub_ind</a> : thm
<a name="line96"></a>    val <a href="#ORL_bt_ub-val">ORL_bt_ub</a> : thm
<a name="line97"></a>    val <a href="#ORL_bt_ub_ind-val">ORL_bt_ub_ind</a> : thm
<a name="line98"></a>    val <a href="#ORL_ind-val">ORL_ind</a> : thm
<a name="line99"></a>    val <a href="#ORL_sublists-val">ORL_sublists</a> : thm
<a name="line100"></a>    val <a href="#ORL_sublists_ind-val">ORL_sublists_ind</a> : thm
<a name="line101"></a>    val <a href="#ORWL_DRESTRICT_COMPL_THM-val">ORWL_DRESTRICT_COMPL_THM</a> : thm
<a name="line102"></a>    val <a href="#ORWL_DRESTRICT_THM-val">ORWL_DRESTRICT_THM</a> : thm
<a name="line103"></a>    val <a href="#ORWL_FUNION_THM-val">ORWL_FUNION_THM</a> : thm
<a name="line104"></a>    val <a href="#ORWL_bt_to_orl-val">ORWL_bt_to_orl</a> : thm
<a name="line105"></a>    val <a href="#assocv-val">assocv</a> : thm
<a name="line106"></a>    val <a href="#assocv_ind-val">assocv_ind</a> : thm
<a name="line107"></a>    val <a href="#better_bt_to_orl-val">better_bt_to_orl</a> : thm
<a name="line108"></a>    val <a href="#bl_to_fmap-val">bl_to_fmap</a> : thm
<a name="line109"></a>    val <a href="#bl_to_fmap_ind-val">bl_to_fmap_ind</a> : thm
<a name="line110"></a>    val <a href="#bt_FST_FDOM-val">bt_FST_FDOM</a> : thm
<a name="line111"></a>    val <a href="#bt_rplacv_cn-val">bt_rplacv_cn</a> : thm
<a name="line112"></a>    val <a href="#bt_rplacv_cn_ind-val">bt_rplacv_cn_ind</a> : thm
<a name="line113"></a>    val <a href="#bt_rplacv_thm-val">bt_rplacv_thm</a> : thm
<a name="line114"></a>    val <a href="#bt_to_fmap-val">bt_to_fmap</a> : thm
<a name="line115"></a>    val <a href="#bt_to_fmap_ind-val">bt_to_fmap_ind</a> : thm
<a name="line116"></a>    val <a href="#bt_to_orl-val">bt_to_orl</a> : thm
<a name="line117"></a>    val <a href="#bt_to_orl_ID_IMP-val">bt_to_orl_ID_IMP</a> : thm
<a name="line118"></a>    val <a href="#bt_to_orl_ac-val">bt_to_orl_ac</a> : thm
<a name="line119"></a>    val <a href="#bt_to_orl_ac_ind-val">bt_to_orl_ac_ind</a> : thm
<a name="line120"></a>    val <a href="#bt_to_orl_ind-val">bt_to_orl_ind</a> : thm
<a name="line121"></a>    val <a href="#bt_to_orl_lb-val">bt_to_orl_lb</a> : thm
<a name="line122"></a>    val <a href="#bt_to_orl_lb_ac-val">bt_to_orl_lb_ac</a> : thm
<a name="line123"></a>    val <a href="#bt_to_orl_lb_ac_ind-val">bt_to_orl_lb_ac_ind</a> : thm
<a name="line124"></a>    val <a href="#bt_to_orl_lb_ind-val">bt_to_orl_lb_ind</a> : thm
<a name="line125"></a>    val <a href="#bt_to_orl_lb_ub-val">bt_to_orl_lb_ub</a> : thm
<a name="line126"></a>    val <a href="#bt_to_orl_lb_ub_ac-val">bt_to_orl_lb_ub_ac</a> : thm
<a name="line127"></a>    val <a href="#bt_to_orl_lb_ub_ac_ind-val">bt_to_orl_lb_ub_ac_ind</a> : thm
<a name="line128"></a>    val <a href="#bt_to_orl_lb_ub_ind-val">bt_to_orl_lb_ub_ind</a> : thm
<a name="line129"></a>    val <a href="#bt_to_orl_ub-val">bt_to_orl_ub</a> : thm
<a name="line130"></a>    val <a href="#bt_to_orl_ub_ac-val">bt_to_orl_ub_ac</a> : thm
<a name="line131"></a>    val <a href="#bt_to_orl_ub_ac_ind-val">bt_to_orl_ub_ac_ind</a> : thm
<a name="line132"></a>    val <a href="#bt_to_orl_ub_ind-val">bt_to_orl_ub_ind</a> : thm
<a name="line133"></a>    val <a href="#diff_merge-val">diff_merge</a> : thm
<a name="line134"></a>    val <a href="#diff_merge_ind-val">diff_merge_ind</a> : thm
<a name="line135"></a>    val <a href="#fmap_FDOM-val">fmap_FDOM</a> : thm
<a name="line136"></a>    val <a href="#fmap_FDOM_rec-val">fmap_FDOM_rec</a> : thm
<a name="line137"></a>    val <a href="#fmap_ORWL_thm-val">fmap_ORWL_thm</a> : thm
<a name="line138"></a>    val <a href="#incr_merge-val">incr_merge</a> : thm
<a name="line139"></a>    val <a href="#incr_merge_ind-val">incr_merge_ind</a> : thm
<a name="line140"></a>    val <a href="#inter_merge-val">inter_merge</a> : thm
<a name="line141"></a>    val <a href="#inter_merge_ind-val">inter_merge_ind</a> : thm
<a name="line142"></a>    val <a href="#list_rplacv_cn-val">list_rplacv_cn</a> : thm
<a name="line143"></a>    val <a href="#list_rplacv_cn_ind-val">list_rplacv_cn_ind</a> : thm
<a name="line144"></a>    val <a href="#list_rplacv_thm-val">list_rplacv_thm</a> : thm
<a name="line145"></a>    val <a href="#merge-val">merge</a> : thm
<a name="line146"></a>    val <a href="#merge_ind-val">merge_ind</a> : thm
<a name="line147"></a>    val <a href="#merge_out-val">merge_out</a> : thm
<a name="line148"></a>    val <a href="#merge_out_ind-val">merge_out_ind</a> : thm
<a name="line149"></a>    val <a href="#o_f_bt_map-val">o_f_bt_map</a> : thm
<a name="line150"></a>    val <a href="#o_f_fmap-val">o_f_fmap</a> : thm
<a name="line151"></a>    val <a href="#optry_list-val">optry_list</a> : thm
<a name="line152"></a>    val <a href="#optry_list_ind-val">optry_list_ind</a> : thm
<a name="line153"></a>
<a name="line154"></a>  val fmapal_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line155"></a>(*
   [enumeral] Parent theory of "fmapal"

   [finite_map] Parent theory of "fmapal"

   [<a name="AP_SND-val"><b>AP_SND</b></a>]  Definition

      |- !f a b. AP_SND f (a,b) = (a,f b)

   [<a name="OFU-val"><b>OFU</b></a>]  Definition

      |- !cmp f g.
           OFU cmp f g = DRESTRICT f {x | LESS_ALL cmp x (FDOM g)} FUNION g

   [<a name="OPTION_FLAT_primitive-val"><b>OPTION_FLAT_primitive</b></a>]  Definition

      |- OPTION_FLAT =
         WFREC (@R. WF R /\ (!l. R l (NONE::l)) /\ !a l. R l (SOME a::l))
           (\OPTION_FLAT a'.
              case a' of
                [] =&gt; I []
              | NONE::l =&gt; I (OPTION_FLAT l)
              | SOME a::l =&gt; I (a ++ OPTION_FLAT l))

   [<a name="OPTION_UPDATE-val"><b>OPTION_UPDATE</b></a>]  Definition

      |- !f g x. OPTION_UPDATE f g x = optry (f x) (g x)

   [<a name="ORL_bt_curried-val"><b>ORL_bt_curried</b></a>]  Definition

      |- !x x1. ORL_bt x x1 &lt;=&gt; ORL_bt_tupled (x,x1)

   [<a name="ORL_bt_lb_curried-val"><b>ORL_bt_lb_curried</b></a>]  Definition

      |- !x x1 x2. ORL_bt_lb x x1 x2 &lt;=&gt; ORL_bt_lb_tupled (x,x1,x2)

   [<a name="ORL_bt_lb_tupled_primitive-val"><b>ORL_bt_lb_tupled_primitive</b></a>]  Definition

      |- ORL_bt_lb_tupled =
         WFREC
           (@R.
              WF R /\ !y l lb r x cmp. R (cmp,x,r) (cmp,lb,node l (x,y) r))
           (\ORL_bt_lb_tupled a.
              case a of
                (cmp,lb,nt) =&gt; I T
              | (cmp,lb,node l (x,y) r) =&gt;
                  I
                    (ORL_bt_lb_ub cmp lb l x /\
                     ORL_bt_lb_tupled (cmp,x,r)))

   [<a name="ORL_bt_lb_ub_curried-val"><b>ORL_bt_lb_ub_curried</b></a>]  Definition

      |- !x x1 x2 x3.
           ORL_bt_lb_ub x x1 x2 x3 &lt;=&gt; ORL_bt_lb_ub_tupled (x,x1,x2,x3)

   [<a name="ORL_bt_lb_ub_tupled_primitive-val"><b>ORL_bt_lb_ub_tupled_primitive</b></a>]  Definition

      |- ORL_bt_lb_ub_tupled =
         WFREC
           (@R.
              WF R /\
              (!ub r y x l lb cmp.
                 R (cmp,lb,l,x) (cmp,lb,node l (x,y) r,ub)) /\
              !y l lb ub r x cmp.
                R (cmp,x,r,ub) (cmp,lb,node l (x,y) r,ub))
           (\ORL_bt_lb_ub_tupled a.
              case a of
                (cmp,lb,nt,ub) =&gt; I (apto cmp lb ub = LESS)
              | (cmp,lb,node l (x,y) r,ub) =&gt;
                  I
                    (ORL_bt_lb_ub_tupled (cmp,lb,l,x) /\
                     ORL_bt_lb_ub_tupled (cmp,x,r,ub)))

   [<a name="ORL_bt_tupled_primitive-val"><b>ORL_bt_tupled_primitive</b></a>]  Definition

      |- ORL_bt_tupled =
         WFREC (@R. WF R)
           (\ORL_bt_tupled a.
              case a of
                (cmp,nt) =&gt; I T
              | (cmp,node l (x,y) r) =&gt;
                  I (ORL_bt_ub cmp l x /\ ORL_bt_lb cmp x r))

   [<a name="ORL_bt_ub_curried-val"><b>ORL_bt_ub_curried</b></a>]  Definition

      |- !x x1 x2. ORL_bt_ub x x1 x2 &lt;=&gt; ORL_bt_ub_tupled (x,x1,x2)

   [<a name="ORL_bt_ub_tupled_primitive-val"><b>ORL_bt_ub_tupled_primitive</b></a>]  Definition

      |- ORL_bt_ub_tupled =
         WFREC
           (@R.
              WF R /\ !ub r y x l cmp. R (cmp,l,x) (cmp,node l (x,y) r,ub))
           (\ORL_bt_ub_tupled a.
              case a of
                (cmp,nt,ub) =&gt; I T
              | (cmp,node l (x,y) r,ub) =&gt;
                  I
                    (ORL_bt_ub_tupled (cmp,l,x) /\
                     ORL_bt_lb_ub cmp x r ub))

   [<a name="ORL_curried-val"><b>ORL_curried</b></a>]  Definition

      |- !x x1. ORL x x1 &lt;=&gt; ORL_tupled (x,x1)

   [<a name="ORL_sublists_curried-val"><b>ORL_sublists_curried</b></a>]  Definition

      |- !x x1. ORL_sublists x x1 &lt;=&gt; ORL_sublists_tupled (x,x1)

   [<a name="ORL_sublists_tupled_primitive-val"><b>ORL_sublists_tupled_primitive</b></a>]  Definition

      |- ORL_sublists_tupled =
         WFREC
           (@R.
              WF R /\ (!lol cmp. R (cmp,lol) (cmp,NONE::lol)) /\
              !m lol cmp. R (cmp,lol) (cmp,SOME m::lol))
           (\ORL_sublists_tupled a.
              case a of
                (cmp,[]) =&gt; I T
              | (cmp,NONE::lol) =&gt; I (ORL_sublists_tupled (cmp,lol))
              | (cmp,SOME m::lol) =&gt;
                  I (ORL cmp m /\ ORL_sublists_tupled (cmp,lol)))

   [<a name="ORL_tupled_primitive-val"><b>ORL_tupled_primitive</b></a>]  Definition

      |- ORL_tupled =
         WFREC (@R. WF R /\ !b a l cmp. R (cmp,l) (cmp,(a,b)::l))
           (\ORL_tupled a'.
              case a' of
                (cmp,[]) =&gt; I T
              | (cmp,(a,b)::l) =&gt;
                  I
                    (ORL_tupled (cmp,l) /\
                     !p q. MEM (p,q) l ==&gt; (apto cmp a p = LESS)))

   [<a name="ORWL-val"><b>ORWL</b></a>]  Definition

      |- !cmp f l. ORWL cmp f l &lt;=&gt; (f = fmap l) /\ ORL cmp l

   [<a name="UFO-val"><b>UFO</b></a>]  Definition

      |- !cmp f g.
           UFO cmp f g =
           f FUNION
           DRESTRICT g {y | !z. z IN FDOM f ==&gt; (apto cmp z y = LESS)}

   [<a name="assocv_curried-val"><b>assocv_curried</b></a>]  Definition

      |- !x x1. assocv x x1 = assocv_tupled (x,x1)

   [<a name="assocv_tupled_primitive-val"><b>assocv_tupled_primitive</b></a>]  Definition

      |- assocv_tupled =
         WFREC (@R. WF R /\ !y l x a. a &lt;&gt; x ==&gt; R (l,a) ((x,y)::l,a))
           (\assocv_tupled a'.
              case a' of
                ([],a) =&gt; I NONE
              | ((x,y)::l,a) =&gt;
                  I (if a = x then SOME y else assocv_tupled (l,a)))

   [<a name="bl_to_fmap_curried-val"><b>bl_to_fmap_curried</b></a>]  Definition

      |- !x x1. bl_to_fmap x x1 = bl_to_fmap_tupled (x,x1)

   [<a name="bl_to_fmap_tupled_primitive-val"><b>bl_to_fmap_tupled_primitive</b></a>]  Definition

      |- bl_to_fmap_tupled =
         WFREC
           (@R.
              WF R /\ (!b cmp. R (cmp,b) (cmp,zerbl b)) /\
              !t y x b cmp. R (cmp,b) (cmp,onebl (x,y) t b))
           (\bl_to_fmap_tupled a.
              case a of
                (cmp,nbl) =&gt; I FEMPTY
              | (cmp,zerbl b) =&gt; I (bl_to_fmap_tupled (cmp,b))
              | (cmp,onebl (x,y) t b') =&gt;
                  I
                    (OFU cmp
                       (FEMPTY |+ (x,y) FUNION
                        DRESTRICT (FMAPAL cmp t) {z | apto cmp x z = LESS})
                       (bl_to_fmap_tupled (cmp,b'))))

   [<a name="bt_map-val"><b>bt_map</b></a>]  Definition

      |- (!f. bt_map f nt = nt) /\
         !f l x r.
           bt_map f (node l x r) = node (bt_map f l) (f x) (bt_map f r)

   [<a name="bt_rplacv_cn_curried-val"><b>bt_rplacv_cn_curried</b></a>]  Definition

      |- !x x1 x2 x3.
           bt_rplacv_cn x x1 x2 x3 = bt_rplacv_cn_tupled (x,x1,x2,x3)

   [<a name="bt_rplacv_cn_tupled_primitive-val"><b>bt_rplacv_cn_tupled_primitive</b></a>]  Definition

      |- bt_rplacv_cn_tupled =
         WFREC
           (@R.
              WF R /\
              (!z l cn r y w x cmp.
                 (apto cmp x w = GREATER) ==&gt;
                 R (cmp,(x,y),r,(\m. cn (node l (w,z) m)))
                   (cmp,(x,y),node l (w,z) r,cn)) /\
              !r z cn l y w x cmp.
                (apto cmp x w = LESS) ==&gt;
                R (cmp,(x,y),l,(\m. cn (node m (w,z) r)))
                  (cmp,(x,y),node l (w,z) r,cn))
           (\bt_rplacv_cn_tupled a.
              case a of
                (cmp,(x,y),nt,cn) =&gt; I nt
              | (cmp,(x,y),node l (w,z) r,cn) =&gt;
                  I
                    (case apto cmp x w of
                       LESS =&gt;
                         bt_rplacv_cn_tupled
                           (cmp,(x,y),l,(\m. cn (node m (w,z) r)))
                     | EQUAL =&gt; cn (node l (x,y) r)
                     | GREATER =&gt;
                         bt_rplacv_cn_tupled
                           (cmp,(x,y),r,(\m. cn (node l (w,z) m)))))

   [<a name="bt_to_fmap_curried-val"><b>bt_to_fmap_curried</b></a>]  Definition

      |- !x x1. FMAPAL x x1 = bt_to_fmap_tupled (x,x1)

   [<a name="bt_to_fmap_lb-val"><b>bt_to_fmap_lb</b></a>]  Definition

      |- !cmp lb t.
           bt_to_fmap_lb cmp lb t =
           DRESTRICT (FMAPAL cmp t) {x | apto cmp lb x = LESS}

   [<a name="bt_to_fmap_lb_ub-val"><b>bt_to_fmap_lb_ub</b></a>]  Definition

      |- !cmp lb t ub.
           bt_to_fmap_lb_ub cmp lb t ub =
           DRESTRICT (FMAPAL cmp t)
             {x | (apto cmp lb x = LESS) /\ (apto cmp x ub = LESS)}

   [<a name="bt_to_fmap_tupled_primitive-val"><b>bt_to_fmap_tupled_primitive</b></a>]  Definition

      |- bt_to_fmap_tupled =
         WFREC
           (@R.
              WF R /\ (!r v x l cmp. R (cmp,l) (cmp,node l (x,v) r)) /\
              !v x l r cmp. R (cmp,r) (cmp,node l (x,v) r))
           (\bt_to_fmap_tupled a.
              case a of
                (cmp,nt) =&gt; I FEMPTY
              | (cmp,node l (x,v) r) =&gt;
                  I
                    (DRESTRICT (bt_to_fmap_tupled (cmp,l))
                       {y | apto cmp y x = LESS} FUNION
                     FEMPTY |+ (x,v) FUNION
                     DRESTRICT (bt_to_fmap_tupled (cmp,r))
                       {z | apto cmp x z = LESS}))

   [<a name="bt_to_fmap_ub-val"><b>bt_to_fmap_ub</b></a>]  Definition

      |- !cmp t ub.
           bt_to_fmap_ub cmp t ub =
           DRESTRICT (FMAPAL cmp t) {x | apto cmp x ub = LESS}

   [<a name="bt_to_orl_ac_curried-val"><b>bt_to_orl_ac_curried</b></a>]  Definition

      |- !x x1 x2. bt_to_orl_ac x x1 x2 = bt_to_orl_ac_tupled (x,x1,x2)

   [<a name="bt_to_orl_ac_tupled_primitive-val"><b>bt_to_orl_ac_tupled_primitive</b></a>]  Definition

      |- bt_to_orl_ac_tupled =
         WFREC (@R. WF R)
           (\bt_to_orl_ac_tupled a.
              case a of
                (cmp,nt,m) =&gt; I m
              | (cmp,node l (x,y) r,m) =&gt;
                  I
                    (bt_to_orl_ub_ac cmp l x
                       ((x,y)::bt_to_orl_lb_ac cmp x r m)))

   [<a name="bt_to_orl_curried-val"><b>bt_to_orl_curried</b></a>]  Definition

      |- !x x1. bt_to_orl x x1 = bt_to_orl_tupled (x,x1)

   [<a name="bt_to_orl_lb_ac_curried-val"><b>bt_to_orl_lb_ac_curried</b></a>]  Definition

      |- !x x1 x2 x3.
           bt_to_orl_lb_ac x x1 x2 x3 = bt_to_orl_lb_ac_tupled (x,x1,x2,x3)

   [<a name="bt_to_orl_lb_ac_tupled_primitive-val"><b>bt_to_orl_lb_ac_tupled_primitive</b></a>]  Definition

      |- bt_to_orl_lb_ac_tupled =
         WFREC
           (@R.
              WF R /\
              (!y l m r x lb cmp.
                 apto cmp lb x &lt;&gt; LESS ==&gt;
                 R (cmp,lb,r,m) (cmp,lb,node l (x,y) r,m)) /\
              !y l m r x lb cmp.
                (apto cmp lb x = LESS) ==&gt;
                R (cmp,x,r,m) (cmp,lb,node l (x,y) r,m))
           (\bt_to_orl_lb_ac_tupled a.
              case a of
                (cmp,lb,nt,m) =&gt; I m
              | (cmp,lb,node l (x,y) r,m) =&gt;
                  I
                    (if apto cmp lb x = LESS then
                       bt_to_orl_lb_ub_ac cmp lb l x
                         ((x,y)::bt_to_orl_lb_ac_tupled (cmp,x,r,m))
                     else bt_to_orl_lb_ac_tupled (cmp,lb,r,m)))

   [<a name="bt_to_orl_lb_curried-val"><b>bt_to_orl_lb_curried</b></a>]  Definition

      |- !x x1 x2. bt_to_orl_lb x x1 x2 = bt_to_orl_lb_tupled (x,x1,x2)

   [<a name="bt_to_orl_lb_tupled_primitive-val"><b>bt_to_orl_lb_tupled_primitive</b></a>]  Definition

      |- bt_to_orl_lb_tupled =
         WFREC
           (@R.
              WF R /\
              (!y l r x lb cmp.
                 apto cmp lb x &lt;&gt; LESS ==&gt;
                 R (cmp,lb,r) (cmp,lb,node l (x,y) r)) /\
              !y l r x lb cmp.
                (apto cmp lb x = LESS) ==&gt;
                R (cmp,x,r) (cmp,lb,node l (x,y) r))
           (\bt_to_orl_lb_tupled a.
              case a of
                (cmp,lb,nt) =&gt; I []
              | (cmp,lb,node l (x,y) r) =&gt;
                  I
                    (if apto cmp lb x = LESS then
                       bt_to_orl_lb_ub cmp lb l x ++ [(x,y)] ++
                       bt_to_orl_lb_tupled (cmp,x,r)
                     else bt_to_orl_lb_tupled (cmp,lb,r)))

   [<a name="bt_to_orl_lb_ub_ac_curried-val"><b>bt_to_orl_lb_ub_ac_curried</b></a>]  Definition

      |- !x x1 x2 x3 x4.
           bt_to_orl_lb_ub_ac x x1 x2 x3 x4 =
           bt_to_orl_lb_ub_ac_tupled (x,x1,x2,x3,x4)

   [<a name="bt_to_orl_lb_ub_ac_tupled_AUX-val"><b>bt_to_orl_lb_ub_ac_tupled_AUX</b></a>]  Definition

      |- !R.
           bt_to_orl_lb_ub_ac_tupled_aux R =
           WFREC R
             (\bt_to_orl_lb_ub_ac_tupled a.
                case a of
                  (cmp,lb,nt,ub,m) =&gt; I m
                | (cmp,lb,node l (x,y) r,ub,m) =&gt;
                    I
                      (if apto cmp lb x = LESS then
                         if apto cmp x ub = LESS then
                           bt_to_orl_lb_ub_ac_tupled
                             (cmp,lb,l,x,
                              (x,y)::
                                  bt_to_orl_lb_ub_ac_tupled (cmp,x,r,ub,m))
                         else bt_to_orl_lb_ub_ac_tupled (cmp,lb,l,ub,m)
                       else bt_to_orl_lb_ub_ac_tupled (cmp,lb,r,ub,m)))

   [<a name="bt_to_orl_lb_ub_ac_tupled_primitive-val"><b>bt_to_orl_lb_ub_ac_tupled_primitive</b></a>]  Definition

      |- bt_to_orl_lb_ub_ac_tupled =
         bt_to_orl_lb_ub_ac_tupled_aux
           (@R.
              WF R /\
              (!y l m ub r x lb cmp.
                 apto cmp lb x &lt;&gt; LESS ==&gt;
                 R (cmp,lb,r,ub,m) (cmp,lb,node l (x,y) r,ub,m)) /\
              (!r y m l ub x lb cmp.
                 (apto cmp lb x = LESS) /\ apto cmp x ub &lt;&gt; LESS ==&gt;
                 R (cmp,lb,l,ub,m) (cmp,lb,node l (x,y) r,ub,m)) /\
              (!m r y l ub x lb cmp.
                 (apto cmp lb x = LESS) /\ (apto cmp x ub = LESS) ==&gt;
                 R
                   (cmp,lb,l,x,
                    (x,y)::bt_to_orl_lb_ub_ac_tupled_aux R (cmp,x,r,ub,m))
                   (cmp,lb,node l (x,y) r,ub,m)) /\
              !y l m r ub x lb cmp.
                (apto cmp lb x = LESS) /\ (apto cmp x ub = LESS) ==&gt;
                R (cmp,x,r,ub,m) (cmp,lb,node l (x,y) r,ub,m))

   [<a name="bt_to_orl_lb_ub_curried-val"><b>bt_to_orl_lb_ub_curried</b></a>]  Definition

      |- !x x1 x2 x3.
           bt_to_orl_lb_ub x x1 x2 x3 = bt_to_orl_lb_ub_tupled (x,x1,x2,x3)

   [<a name="bt_to_orl_lb_ub_tupled_primitive-val"><b>bt_to_orl_lb_ub_tupled_primitive</b></a>]  Definition

      |- bt_to_orl_lb_ub_tupled =
         WFREC
           (@R.
              WF R /\
              (!y l ub r x lb cmp.
                 apto cmp lb x &lt;&gt; LESS ==&gt;
                 R (cmp,lb,r,ub) (cmp,lb,node l (x,y) r,ub)) /\
              (!r y l ub x lb cmp.
                 (apto cmp lb x = LESS) /\ apto cmp x ub &lt;&gt; LESS ==&gt;
                 R (cmp,lb,l,ub) (cmp,lb,node l (x,y) r,ub)) /\
              (!r y l ub x lb cmp.
                 (apto cmp lb x = LESS) /\ (apto cmp x ub = LESS) ==&gt;
                 R (cmp,lb,l,x) (cmp,lb,node l (x,y) r,ub)) /\
              !y l r ub x lb cmp.
                (apto cmp lb x = LESS) /\ (apto cmp x ub = LESS) ==&gt;
                R (cmp,x,r,ub) (cmp,lb,node l (x,y) r,ub))
           (\bt_to_orl_lb_ub_tupled a.
              case a of
                (cmp,lb,nt,ub) =&gt; I []
              | (cmp,lb,node l (x,y) r,ub) =&gt;
                  I
                    (if apto cmp lb x = LESS then
                       if apto cmp x ub = LESS then
                         bt_to_orl_lb_ub_tupled (cmp,lb,l,x) ++ [(x,y)] ++
                         bt_to_orl_lb_ub_tupled (cmp,x,r,ub)
                       else bt_to_orl_lb_ub_tupled (cmp,lb,l,ub)
                     else bt_to_orl_lb_ub_tupled (cmp,lb,r,ub)))

   [<a name="bt_to_orl_tupled_primitive-val"><b>bt_to_orl_tupled_primitive</b></a>]  Definition

      |- bt_to_orl_tupled =
         WFREC (@R. WF R)
           (\bt_to_orl_tupled a.
              case a of
                (cmp,nt) =&gt; I []
              | (cmp,node l (x,y) r) =&gt;
                  I
                    (bt_to_orl_ub cmp l x ++ [(x,y)] ++
                     bt_to_orl_lb cmp x r))

   [<a name="bt_to_orl_ub_ac_curried-val"><b>bt_to_orl_ub_ac_curried</b></a>]  Definition

      |- !x x1 x2 x3.
           bt_to_orl_ub_ac x x1 x2 x3 = bt_to_orl_ub_ac_tupled (x,x1,x2,x3)

   [<a name="bt_to_orl_ub_ac_tupled_primitive-val"><b>bt_to_orl_ub_ac_tupled_primitive</b></a>]  Definition

      |- bt_to_orl_ub_ac_tupled =
         WFREC
           (@R.
              WF R /\
              (!r y m l ub x cmp.
                 apto cmp x ub &lt;&gt; LESS ==&gt;
                 R (cmp,l,ub,m) (cmp,node l (x,y) r,ub,m)) /\
              !m r y l ub x cmp.
                (apto cmp x ub = LESS) ==&gt;
                R (cmp,l,x,(x,y)::bt_to_orl_lb_ub_ac cmp x r ub m)
                  (cmp,node l (x,y) r,ub,m))
           (\bt_to_orl_ub_ac_tupled a.
              case a of
                (cmp,nt,ub,m) =&gt; I m
              | (cmp,node l (x,y) r,ub,m) =&gt;
                  I
                    (if apto cmp x ub = LESS then
                       bt_to_orl_ub_ac_tupled
                         (cmp,l,x,(x,y)::bt_to_orl_lb_ub_ac cmp x r ub m)
                     else bt_to_orl_ub_ac_tupled (cmp,l,ub,m)))

   [<a name="bt_to_orl_ub_curried-val"><b>bt_to_orl_ub_curried</b></a>]  Definition

      |- !x x1 x2. bt_to_orl_ub x x1 x2 = bt_to_orl_ub_tupled (x,x1,x2)

   [<a name="bt_to_orl_ub_tupled_primitive-val"><b>bt_to_orl_ub_tupled_primitive</b></a>]  Definition

      |- bt_to_orl_ub_tupled =
         WFREC
           (@R.
              WF R /\
              (!r y l ub x cmp.
                 apto cmp x ub &lt;&gt; LESS ==&gt;
                 R (cmp,l,ub) (cmp,node l (x,y) r,ub)) /\
              !r y l ub x cmp.
                (apto cmp x ub = LESS) ==&gt;
                R (cmp,l,x) (cmp,node l (x,y) r,ub))
           (\bt_to_orl_ub_tupled a.
              case a of
                (cmp,nt,ub) =&gt; I []
              | (cmp,node l (x,y) r,ub) =&gt;
                  I
                    (if apto cmp x ub = LESS then
                       bt_to_orl_ub_tupled (cmp,l,x) ++ [(x,y)] ++
                       bt_to_orl_lb_ub cmp x r ub
                     else bt_to_orl_ub_tupled (cmp,l,ub)))

   [<a name="diff_merge_curried-val"><b>diff_merge_curried</b></a>]  Definition

      |- !x x1 x2. diff_merge x x1 x2 = diff_merge_tupled (x,x1,x2)

   [<a name="diff_merge_tupled_primitive-val"><b>diff_merge_tupled_primitive</b></a>]  Definition

      |- diff_merge_tupled =
         WFREC
           (@R.
              WF R /\
              (!b m l y a cmp.
                 (apto cmp a y = EQUAL) ==&gt;
                 R (cmp,l,m) (cmp,(a,b)::l,y::m)) /\
              (!m l b y a cmp.
                 (apto cmp a y = GREATER) ==&gt;
                 R (cmp,(a,b)::l,m) (cmp,(a,b)::l,y::m)) /\
              !b m l y a cmp.
                (apto cmp a y = LESS) ==&gt;
                R (cmp,l,y::m) (cmp,(a,b)::l,y::m))
           (\diff_merge_tupled a'.
              case a' of
                (cmp,[],v3) =&gt; I []
              | (cmp,(a,b)::l,[]) =&gt; I ((a,b)::l)
              | (cmp,(a,b)::l,y::m) =&gt;
                  I
                    (case apto cmp a y of
                       LESS =&gt; (a,b)::diff_merge_tupled (cmp,l,y::m)
                     | EQUAL =&gt; diff_merge_tupled (cmp,l,m)
                     | GREATER =&gt; diff_merge_tupled (cmp,(a,b)::l,m)))

   [<a name="fmap-val"><b>fmap</b></a>]  Definition

      |- !l. fmap l = FEMPTY |++ REVERSE l

   [<a name="incr_build-val"><b>incr_build</b></a>]  Definition

      |- (!cmp. incr_build cmp [] = []) /\
         !cmp ab l.
           incr_build cmp (ab::l) = incr_merge cmp [ab] (incr_build cmp l)

   [<a name="incr_flat-val"><b>incr_flat</b></a>]  Definition

      |- !cmp lol. incr_flat cmp lol = merge_out cmp [] lol

   [<a name="incr_merge_curried-val"><b>incr_merge_curried</b></a>]  Definition

      |- !x x1 x2. incr_merge x x1 x2 = incr_merge_tupled (x,x1,x2)

   [<a name="incr_merge_tupled_primitive-val"><b>incr_merge_tupled_primitive</b></a>]  Definition

      |- incr_merge_tupled =
         WFREC
           (@R.
              WF R /\
              !lol m l cmp. R (cmp,merge cmp l m,lol) (cmp,l,SOME m::lol))
           (\incr_merge_tupled a.
              case a of
                (cmp,l,[]) =&gt; I [SOME l]
              | (cmp,l,NONE::lol) =&gt; I (SOME l::lol)
              | (cmp,l,SOME m::lol) =&gt;
                  I (NONE::incr_merge_tupled (cmp,merge cmp l m,lol)))

   [<a name="incr_sort-val"><b>incr_sort</b></a>]  Definition

      |- !cmp l. incr_sort cmp l = merge_out cmp [] (incr_build cmp l)

   [<a name="inter_merge_curried-val"><b>inter_merge_curried</b></a>]  Definition

      |- !x x1 x2. inter_merge x x1 x2 = inter_merge_tupled (x,x1,x2)

   [<a name="inter_merge_tupled_primitive-val"><b>inter_merge_tupled_primitive</b></a>]  Definition

      |- inter_merge_tupled =
         WFREC
           (@R.
              WF R /\
              (!b m l y a cmp.
                 (apto cmp a y = EQUAL) ==&gt;
                 R (cmp,l,m) (cmp,(a,b)::l,y::m)) /\
              (!m l b y a cmp.
                 (apto cmp a y = GREATER) ==&gt;
                 R (cmp,(a,b)::l,m) (cmp,(a,b)::l,y::m)) /\
              !b m l y a cmp.
                (apto cmp a y = LESS) ==&gt;
                R (cmp,l,y::m) (cmp,(a,b)::l,y::m))
           (\inter_merge_tupled a'.
              case a' of
                (cmp,[],v3) =&gt; I []
              | (cmp,v4::l,[]) =&gt; I []
              | (cmp,(a,b)::l,y::m) =&gt;
                  I
                    (case apto cmp a y of
                       LESS =&gt; inter_merge_tupled (cmp,l,y::m)
                     | EQUAL =&gt; (a,b)::inter_merge_tupled (cmp,l,m)
                     | GREATER =&gt; inter_merge_tupled (cmp,(a,b)::l,m)))

   [<a name="list_rplacv_cn_curried-val"><b>list_rplacv_cn_curried</b></a>]  Definition

      |- !x x1 x2. list_rplacv_cn x x1 x2 = list_rplacv_cn_tupled (x,x1,x2)

   [<a name="list_rplacv_cn_tupled_primitive-val"><b>list_rplacv_cn_tupled_primitive</b></a>]  Definition

      |- list_rplacv_cn_tupled =
         WFREC
           (@R.
              WF R /\
              !z cn l y w x.
                x &lt;&gt; w ==&gt;
                R ((x,y),l,(\m. cn ((w,z)::m))) ((x,y),(w,z)::l,cn))
           (\list_rplacv_cn_tupled a.
              case a of
                ((x,y),[],cn) =&gt; I []
              | ((x,y),(w,z)::l,cn) =&gt;
                  I
                    (if x = w then cn ((x,y)::l)
                     else
                       list_rplacv_cn_tupled
                         ((x,y),l,(\m. cn ((w,z)::m)))))

   [<a name="merge_curried-val"><b>merge_curried</b></a>]  Definition

      |- !x x1 x2. merge x x1 x2 = merge_tupled (x,x1,x2)

   [<a name="merge_out_curried-val"><b>merge_out_curried</b></a>]  Definition

      |- !x x1 x2. merge_out x x1 x2 = merge_out_tupled (x,x1,x2)

   [<a name="merge_out_tupled_primitive-val"><b>merge_out_tupled_primitive</b></a>]  Definition

      |- merge_out_tupled =
         WFREC
           (@R.
              WF R /\ (!lol l cmp. R (cmp,l,lol) (cmp,l,NONE::lol)) /\
              !lol m l cmp. R (cmp,merge cmp l m,lol) (cmp,l,SOME m::lol))
           (\merge_out_tupled a.
              case a of
                (cmp,l,[]) =&gt; I l
              | (cmp,l,NONE::lol) =&gt; I (merge_out_tupled (cmp,l,lol))
              | (cmp,l,SOME m::lol) =&gt;
                  I (merge_out_tupled (cmp,merge cmp l m,lol)))

   [<a name="merge_tupled_primitive-val"><b>merge_tupled_primitive</b></a>]  Definition

      |- merge_tupled =
         WFREC
           (@R.
              WF R /\
              (!b2 b1 l2 l1 a2 a1 cmp.
                 (apto cmp a1 a2 = EQUAL) ==&gt;
                 R (cmp,l1,l2) (cmp,(a1,b1)::l1,(a2,b2)::l2)) /\
              (!b2 l2 l1 b1 a2 a1 cmp.
                 (apto cmp a1 a2 = GREATER) ==&gt;
                 R (cmp,(a1,b1)::l1,l2) (cmp,(a1,b1)::l1,(a2,b2)::l2)) /\
              !b1 l2 b2 l1 a2 a1 cmp.
                (apto cmp a1 a2 = LESS) ==&gt;
                R (cmp,l1,(a2,b2)::l2) (cmp,(a1,b1)::l1,(a2,b2)::l2))
           (\merge_tupled a.
              case a of
                (cmp,[],l) =&gt; I l
              | (cmp,v6::l1,[]) =&gt; I (v6::l1)
              | (cmp,(a1,b1)::l1,(a2,b2)::l2) =&gt;
                  I
                    (case apto cmp a1 a2 of
                       LESS =&gt; (a1,b1)::merge_tupled (cmp,l1,(a2,b2)::l2)
                     | EQUAL =&gt; (a1,b1)::merge_tupled (cmp,l1,l2)
                     | GREATER =&gt;
                         (a2,b2)::merge_tupled (cmp,(a1,b1)::l1,l2)))

   [<a name="optry-val"><b>optry</b></a>]  Definition

      |- (!p q. optry (SOME p) q = SOME p) /\ !q. optry NONE q = q

   [<a name="optry_list_curried-val"><b>optry_list_curried</b></a>]  Definition

      |- !x x1. optry_list x x1 = optry_list_tupled (x,x1)

   [<a name="optry_list_tupled_primitive-val"><b>optry_list_tupled_primitive</b></a>]  Definition

      |- optry_list_tupled =
         WFREC
           (@R.
              WF R /\ (!l f. R (f,l) (f,NONE::l)) /\
              !z l f. R (f,l) (f,SOME z::l))
           (\optry_list_tupled a.
              case a of
                (f,[]) =&gt; I NONE
              | (f,NONE::l) =&gt; I (optry_list_tupled (f,l))
              | (f,SOME z::l) =&gt; I (optry (f z) (optry_list_tupled (f,l))))

   [<a name="unlookup-val"><b>unlookup</b></a>]  Definition

      |- !f. unlookup f = FUN_FMAP (THE o f) (IS_SOME o f)

   [<a name="vcossa-val"><b>vcossa</b></a>]  Definition

      |- !a l. vcossa a l = assocv l a

   [<a name="FAPPLY_fmap_CONS-val"><b>FAPPLY_fmap_CONS</b></a>]  Theorem

      |- !x y z l. fmap ((y,z)::l) ' x = if x = y then z else fmap l ' x

   [<a name="FAPPLY_fmap_NIL-val"><b>FAPPLY_fmap_NIL</b></a>]  Theorem

      |- !x. fmap [] ' x = FEMPTY ' x

   [<a name="FAPPLY_node-val"><b>FAPPLY_node</b></a>]  Theorem

      |- !cmp x l a b r.
           FMAPAL cmp (node l (a,b) r) ' x =
           case apto cmp x a of
             LESS =&gt; FMAPAL cmp l ' x
           | EQUAL =&gt; b
           | GREATER =&gt; FMAPAL cmp r ' x

   [<a name="FAPPLY_nt-val"><b>FAPPLY_nt</b></a>]  Theorem

      |- !cmp x. FMAPAL cmp nt ' x = FEMPTY ' x

   [<a name="FMAPAL_FDOM_THM-val"><b>FMAPAL_FDOM_THM</b></a>]  Theorem

      |- (!cmp x. x IN FDOM (FMAPAL cmp nt) &lt;=&gt; F) /\
         !cmp x a b l r.
           x IN FDOM (FMAPAL cmp (node l (a,b) r)) &lt;=&gt;
           case apto cmp x a of
             LESS =&gt; x IN FDOM (FMAPAL cmp l)
           | EQUAL =&gt; T
           | GREATER =&gt; x IN FDOM (FMAPAL cmp r)

   [<a name="FMAPAL_fmap-val"><b>FMAPAL_fmap</b></a>]  Theorem

      |- !cmp l. fmap l = FMAPAL cmp (list_to_bt (incr_sort cmp l))

   [<a name="FUN_fmap_thm-val"><b>FUN_fmap_thm</b></a>]  Theorem

      |- !f l. fmap (MAP (\x. (x,f x)) l) = FUN_FMAP f (set l)

   [<a name="OPTION_FLAT-val"><b>OPTION_FLAT</b></a>]  Theorem

      |- (OPTION_FLAT [] = []) /\
         (!l. OPTION_FLAT (NONE::l) = OPTION_FLAT l) /\
         !l a. OPTION_FLAT (SOME a::l) = a ++ OPTION_FLAT l

   [<a name="OPTION_FLAT_ind-val"><b>OPTION_FLAT_ind</b></a>]  Theorem

      |- !P.
           P [] /\ (!l. P l ==&gt; P (NONE::l)) /\
           (!a l. P l ==&gt; P (SOME a::l)) ==&gt;
           !v. P v

   [<a name="ORL-val"><b>ORL</b></a>]  Theorem

      |- (!cmp. ORL cmp [] &lt;=&gt; T) /\
         !l cmp b a.
           ORL cmp ((a,b)::l) &lt;=&gt;
           ORL cmp l /\ !p q. MEM (p,q) l ==&gt; (apto cmp a p = LESS)

   [<a name="ORL_DRESTRICT_COMPL_IMP-val"><b>ORL_DRESTRICT_COMPL_IMP</b></a>]  Theorem

      |- !cmp l.
           ORL cmp l ==&gt;
           !m.
             OL cmp m ==&gt;
             ORL cmp (diff_merge cmp l m) /\
             (fmap (diff_merge cmp l m) =
              DRESTRICT (fmap l) (COMPL (set m)))

   [<a name="ORL_DRESTRICT_IMP-val"><b>ORL_DRESTRICT_IMP</b></a>]  Theorem

      |- !cmp l.
           ORL cmp l ==&gt;
           !m.
             OL cmp m ==&gt;
             ORL cmp (inter_merge cmp l m) /\
             (fmap (inter_merge cmp l m) = DRESTRICT (fmap l) (set m))

   [<a name="ORL_FMAPAL-val"><b>ORL_FMAPAL</b></a>]  Theorem

      |- !cmp l. ORL cmp l ==&gt; (fmap l = FMAPAL cmp (list_to_bt l))

   [<a name="ORL_FUNION_IMP-val"><b>ORL_FUNION_IMP</b></a>]  Theorem

      |- !cmp l.
           ORL cmp l ==&gt;
           !m.
             ORL cmp m ==&gt;
             ORL cmp (merge cmp l m) /\
             (fmap (merge cmp l m) = fmap l FUNION fmap m)

   [<a name="ORL_bt-val"><b>ORL_bt</b></a>]  Theorem

      |- (ORL_bt cmp nt &lt;=&gt; T) /\
         (ORL_bt cmp (node l (x,y) r) &lt;=&gt;
          ORL_bt_ub cmp l x /\ ORL_bt_lb cmp x r)

   [<a name="ORL_bt_ind-val"><b>ORL_bt_ind</b></a>]  Theorem

      |- !P.
           (!cmp. P cmp nt) /\ (!cmp l x y r. P cmp (node l (x,y) r)) ==&gt;
           !v v1. P v v1

   [<a name="ORL_bt_lb-val"><b>ORL_bt_lb</b></a>]  Theorem

      |- (!lb cmp. ORL_bt_lb cmp lb nt &lt;=&gt; T) /\
         !y x r lb l cmp.
           ORL_bt_lb cmp lb (node l (x,y) r) &lt;=&gt;
           ORL_bt_lb_ub cmp lb l x /\ ORL_bt_lb cmp x r

   [<a name="ORL_bt_lb_ind-val"><b>ORL_bt_lb_ind</b></a>]  Theorem

      |- !P.
           (!cmp lb. P cmp lb nt) /\
           (!cmp lb l x y r. P cmp x r ==&gt; P cmp lb (node l (x,y) r)) ==&gt;
           !v v1 v2. P v v1 v2

   [<a name="ORL_bt_lb_ub-val"><b>ORL_bt_lb_ub</b></a>]  Theorem

      |- (!ub lb cmp.
            ORL_bt_lb_ub cmp lb nt ub &lt;=&gt; (apto cmp lb ub = LESS)) /\
         !y x ub r lb l cmp.
           ORL_bt_lb_ub cmp lb (node l (x,y) r) ub &lt;=&gt;
           ORL_bt_lb_ub cmp lb l x /\ ORL_bt_lb_ub cmp x r ub

   [<a name="ORL_bt_lb_ub_ind-val"><b>ORL_bt_lb_ub_ind</b></a>]  Theorem

      |- !P.
           (!cmp lb ub. P cmp lb nt ub) /\
           (!cmp lb l x y r ub.
              P cmp lb l x /\ P cmp x r ub ==&gt;
              P cmp lb (node l (x,y) r) ub) ==&gt;
           !v v1 v2 v3. P v v1 v2 v3

   [<a name="ORL_bt_ub-val"><b>ORL_bt_ub</b></a>]  Theorem

      |- (!ub cmp. ORL_bt_ub cmp nt ub &lt;=&gt; T) /\
         !y x ub r l cmp.
           ORL_bt_ub cmp (node l (x,y) r) ub &lt;=&gt;
           ORL_bt_ub cmp l x /\ ORL_bt_lb_ub cmp x r ub

   [<a name="ORL_bt_ub_ind-val"><b>ORL_bt_ub_ind</b></a>]  Theorem

      |- !P.
           (!cmp ub. P cmp nt ub) /\
           (!cmp l x y r ub. P cmp l x ==&gt; P cmp (node l (x,y) r) ub) ==&gt;
           !v v1 v2. P v v1 v2

   [<a name="ORL_ind-val"><b>ORL_ind</b></a>]  Theorem

      |- !P.
           (!cmp. P cmp []) /\
           (!cmp a b l. P cmp l ==&gt; P cmp ((a,b)::l)) ==&gt;
           !v v1. P v v1

   [<a name="ORL_sublists-val"><b>ORL_sublists</b></a>]  Theorem

      |- (!cmp. ORL_sublists cmp [] &lt;=&gt; T) /\
         (!lol cmp.
            ORL_sublists cmp (NONE::lol) &lt;=&gt; ORL_sublists cmp lol) /\
         !m lol cmp.
           ORL_sublists cmp (SOME m::lol) &lt;=&gt;
           ORL cmp m /\ ORL_sublists cmp lol

   [<a name="ORL_sublists_ind-val"><b>ORL_sublists_ind</b></a>]  Theorem

      |- !P.
           (!cmp. P cmp []) /\
           (!cmp lol. P cmp lol ==&gt; P cmp (NONE::lol)) /\
           (!cmp m lol. P cmp lol ==&gt; P cmp (SOME m::lol)) ==&gt;
           !v v1. P v v1

   [<a name="ORWL_DRESTRICT_COMPL_THM-val"><b>ORWL_DRESTRICT_COMPL_THM</b></a>]  Theorem

      |- !cmp s l t m.
           ORWL cmp s l /\ OWL cmp t m ==&gt;
           ORWL cmp (DRESTRICT s (COMPL t)) (diff_merge cmp l m)

   [<a name="ORWL_DRESTRICT_THM-val"><b>ORWL_DRESTRICT_THM</b></a>]  Theorem

      |- !cmp s l t m.
           ORWL cmp s l /\ OWL cmp t m ==&gt;
           ORWL cmp (DRESTRICT s t) (inter_merge cmp l m)

   [<a name="ORWL_FUNION_THM-val"><b>ORWL_FUNION_THM</b></a>]  Theorem

      |- !cmp s l t m.
           ORWL cmp s l /\ ORWL cmp t m ==&gt;
           ORWL cmp (s FUNION t) (merge cmp l m)

   [<a name="ORWL_bt_to_orl-val"><b>ORWL_bt_to_orl</b></a>]  Theorem

      |- !cmp t. ORWL cmp (FMAPAL cmp t) (bt_to_orl cmp t)

   [<a name="assocv-val"><b>assocv</b></a>]  Theorem

      |- (!a. assocv [] a = NONE) /\
         !y x l a.
           assocv ((x,y)::l) a = if a = x then SOME y else assocv l a

   [<a name="assocv_ind-val"><b>assocv_ind</b></a>]  Theorem

      |- !P.
           (!a. P [] a) /\
           (!x y l a. (a &lt;&gt; x ==&gt; P l a) ==&gt; P ((x,y)::l) a) ==&gt;
           !v v1. P v v1

   [<a name="better_bt_to_orl-val"><b>better_bt_to_orl</b></a>]  Theorem

      |- !cmp t.
           bt_to_orl cmp t =
           if ORL_bt cmp t then bt_to_list_ac t []
           else bt_to_orl_ac cmp t []

   [<a name="bl_to_fmap-val"><b>bl_to_fmap</b></a>]  Theorem

      |- (!cmp. bl_to_fmap cmp nbl = FEMPTY) /\
         (!cmp b. bl_to_fmap cmp (zerbl b) = bl_to_fmap cmp b) /\
         !y x t cmp b.
           bl_to_fmap cmp (onebl (x,y) t b) =
           OFU cmp
             (FEMPTY |+ (x,y) FUNION
              DRESTRICT (FMAPAL cmp t) {z | apto cmp x z = LESS})
             (bl_to_fmap cmp b)

   [<a name="bl_to_fmap_ind-val"><b>bl_to_fmap_ind</b></a>]  Theorem

      |- !P.
           (!cmp. P cmp nbl) /\ (!cmp b. P cmp b ==&gt; P cmp (zerbl b)) /\
           (!cmp x y t b. P cmp b ==&gt; P cmp (onebl (x,y) t b)) ==&gt;
           !v v1. P v v1

   [<a name="bt_FST_FDOM-val"><b>bt_FST_FDOM</b></a>]  Theorem

      |- !cmp t. FDOM (FMAPAL cmp t) = ENUMERAL cmp (bt_map FST t)

   [<a name="bt_rplacv_cn-val"><b>bt_rplacv_cn</b></a>]  Theorem

      |- (!y x cn cmp. bt_rplacv_cn cmp (x,y) nt cn = nt) /\
         !z y x w r l cn cmp.
           bt_rplacv_cn cmp (x,y) (node l (w,z) r) cn =
           case apto cmp x w of
             LESS =&gt; bt_rplacv_cn cmp (x,y) l (\m. cn (node m (w,z) r))
           | EQUAL =&gt; cn (node l (x,y) r)
           | GREATER =&gt; bt_rplacv_cn cmp (x,y) r (\m. cn (node l (w,z) m))

   [<a name="bt_rplacv_cn_ind-val"><b>bt_rplacv_cn_ind</b></a>]  Theorem

      |- !P.
           (!cmp x y cn. P cmp (x,y) nt cn) /\
           (!cmp x y l w z r cn.
              ((apto cmp x w = GREATER) ==&gt;
               P cmp (x,y) r (\m. cn (node l (w,z) m))) /\
              ((apto cmp x w = LESS) ==&gt;
               P cmp (x,y) l (\m. cn (node m (w,z) r))) ==&gt;
              P cmp (x,y) (node l (w,z) r) cn) ==&gt;
           !v v1 v2 v3 v4. P v (v1,v2) v3 v4

   [<a name="bt_rplacv_thm-val"><b>bt_rplacv_thm</b></a>]  Theorem

      |- !cmp x y t.
           (let ans = bt_rplacv_cn cmp (x,y) t (\m. m)
            in
              if ans = nt then x NOTIN FDOM (FMAPAL cmp t)
              else
                x IN FDOM (FMAPAL cmp t) /\
                (FMAPAL cmp t |+ (x,y) = FMAPAL cmp ans))

   [<a name="bt_to_fmap-val"><b>bt_to_fmap</b></a>]  Theorem

      |- (!cmp. FMAPAL cmp nt = FEMPTY) /\
         !x v r l cmp.
           FMAPAL cmp (node l (x,v) r) =
           DRESTRICT (FMAPAL cmp l) {y | apto cmp y x = LESS} FUNION
           FEMPTY |+ (x,v) FUNION
           DRESTRICT (FMAPAL cmp r) {z | apto cmp x z = LESS}

   [<a name="bt_to_fmap_ind-val"><b>bt_to_fmap_ind</b></a>]  Theorem

      |- !P.
           (!cmp. P cmp nt) /\
           (!cmp l x v r.
              P cmp l /\ P cmp r ==&gt; P cmp (node l (x,v) r)) ==&gt;
           !v v1. P v v1

   [<a name="bt_to_orl-val"><b>bt_to_orl</b></a>]  Theorem

      |- (bt_to_orl cmp nt = []) /\
         (bt_to_orl cmp (node l (x,y) r) =
          bt_to_orl_ub cmp l x ++ [(x,y)] ++ bt_to_orl_lb cmp x r)

   [<a name="bt_to_orl_ID_IMP-val"><b>bt_to_orl_ID_IMP</b></a>]  Theorem

      |- !cmp l. ORL cmp l ==&gt; (bt_to_orl cmp (list_to_bt l) = l)

   [<a name="bt_to_orl_ac-val"><b>bt_to_orl_ac</b></a>]  Theorem

      |- (bt_to_orl_ac cmp nt m = m) /\
         (bt_to_orl_ac cmp (node l (x,y) r) m =
          bt_to_orl_ub_ac cmp l x ((x,y)::bt_to_orl_lb_ac cmp x r m))

   [<a name="bt_to_orl_ac_ind-val"><b>bt_to_orl_ac_ind</b></a>]  Theorem

      |- !P.
           (!cmp m. P cmp nt m) /\
           (!cmp l x y r m. P cmp (node l (x,y) r) m) ==&gt;
           !v v1 v2. P v v1 v2

   [<a name="bt_to_orl_ind-val"><b>bt_to_orl_ind</b></a>]  Theorem

      |- !P.
           (!cmp. P cmp nt) /\ (!cmp l x y r. P cmp (node l (x,y) r)) ==&gt;
           !v v1. P v v1

   [<a name="bt_to_orl_lb-val"><b>bt_to_orl_lb</b></a>]  Theorem

      |- (!lb cmp. bt_to_orl_lb cmp lb nt = []) /\
         !y x r lb l cmp.
           bt_to_orl_lb cmp lb (node l (x,y) r) =
           if apto cmp lb x = LESS then
             bt_to_orl_lb_ub cmp lb l x ++ [(x,y)] ++ bt_to_orl_lb cmp x r
           else bt_to_orl_lb cmp lb r

   [<a name="bt_to_orl_lb_ac-val"><b>bt_to_orl_lb_ac</b></a>]  Theorem

      |- (!m lb cmp. bt_to_orl_lb_ac cmp lb nt m = m) /\
         !y x r m lb l cmp.
           bt_to_orl_lb_ac cmp lb (node l (x,y) r) m =
           if apto cmp lb x = LESS then
             bt_to_orl_lb_ub_ac cmp lb l x
               ((x,y)::bt_to_orl_lb_ac cmp x r m)
           else bt_to_orl_lb_ac cmp lb r m

   [<a name="bt_to_orl_lb_ac_ind-val"><b>bt_to_orl_lb_ac_ind</b></a>]  Theorem

      |- !P.
           (!cmp lb m. P cmp lb nt m) /\
           (!cmp lb l x y r m.
              (apto cmp lb x &lt;&gt; LESS ==&gt; P cmp lb r m) /\
              ((apto cmp lb x = LESS) ==&gt; P cmp x r m) ==&gt;
              P cmp lb (node l (x,y) r) m) ==&gt;
           !v v1 v2 v3. P v v1 v2 v3

   [<a name="bt_to_orl_lb_ind-val"><b>bt_to_orl_lb_ind</b></a>]  Theorem

      |- !P.
           (!cmp lb. P cmp lb nt) /\
           (!cmp lb l x y r.
              (apto cmp lb x &lt;&gt; LESS ==&gt; P cmp lb r) /\
              ((apto cmp lb x = LESS) ==&gt; P cmp x r) ==&gt;
              P cmp lb (node l (x,y) r)) ==&gt;
           !v v1 v2. P v v1 v2

   [<a name="bt_to_orl_lb_ub-val"><b>bt_to_orl_lb_ub</b></a>]  Theorem

      |- (!ub lb cmp. bt_to_orl_lb_ub cmp lb nt ub = []) /\
         !y x ub r lb l cmp.
           bt_to_orl_lb_ub cmp lb (node l (x,y) r) ub =
           if apto cmp lb x = LESS then
             if apto cmp x ub = LESS then
               bt_to_orl_lb_ub cmp lb l x ++ [(x,y)] ++
               bt_to_orl_lb_ub cmp x r ub
             else bt_to_orl_lb_ub cmp lb l ub
           else bt_to_orl_lb_ub cmp lb r ub

   [<a name="bt_to_orl_lb_ub_ac-val"><b>bt_to_orl_lb_ub_ac</b></a>]  Theorem

      |- (!ub m lb cmp. bt_to_orl_lb_ub_ac cmp lb nt ub m = m) /\
         !y x ub r m lb l cmp.
           bt_to_orl_lb_ub_ac cmp lb (node l (x,y) r) ub m =
           if apto cmp lb x = LESS then
             if apto cmp x ub = LESS then
               bt_to_orl_lb_ub_ac cmp lb l x
                 ((x,y)::bt_to_orl_lb_ub_ac cmp x r ub m)
             else bt_to_orl_lb_ub_ac cmp lb l ub m
           else bt_to_orl_lb_ub_ac cmp lb r ub m

   [<a name="bt_to_orl_lb_ub_ac_ind-val"><b>bt_to_orl_lb_ub_ac_ind</b></a>]  Theorem

      |- !P.
           (!cmp lb ub m. P cmp lb nt ub m) /\
           (!cmp lb l x y r ub m.
              (apto cmp lb x &lt;&gt; LESS ==&gt; P cmp lb r ub m) /\
              ((apto cmp lb x = LESS) /\ apto cmp x ub &lt;&gt; LESS ==&gt;
               P cmp lb l ub m) /\
              ((apto cmp lb x = LESS) /\ (apto cmp x ub = LESS) ==&gt;
               P cmp lb l x ((x,y)::bt_to_orl_lb_ub_ac cmp x r ub m)) /\
              ((apto cmp lb x = LESS) /\ (apto cmp x ub = LESS) ==&gt;
               P cmp x r ub m) ==&gt;
              P cmp lb (node l (x,y) r) ub m) ==&gt;
           !v v1 v2 v3 v4. P v v1 v2 v3 v4

   [<a name="bt_to_orl_lb_ub_ind-val"><b>bt_to_orl_lb_ub_ind</b></a>]  Theorem

      |- !P.
           (!cmp lb ub. P cmp lb nt ub) /\
           (!cmp lb l x y r ub.
              (apto cmp lb x &lt;&gt; LESS ==&gt; P cmp lb r ub) /\
              ((apto cmp lb x = LESS) /\ apto cmp x ub &lt;&gt; LESS ==&gt;
               P cmp lb l ub) /\
              ((apto cmp lb x = LESS) /\ (apto cmp x ub = LESS) ==&gt;
               P cmp lb l x) /\
              ((apto cmp lb x = LESS) /\ (apto cmp x ub = LESS) ==&gt;
               P cmp x r ub) ==&gt;
              P cmp lb (node l (x,y) r) ub) ==&gt;
           !v v1 v2 v3. P v v1 v2 v3

   [<a name="bt_to_orl_ub-val"><b>bt_to_orl_ub</b></a>]  Theorem

      |- (!ub cmp. bt_to_orl_ub cmp nt ub = []) /\
         !y x ub r l cmp.
           bt_to_orl_ub cmp (node l (x,y) r) ub =
           if apto cmp x ub = LESS then
             bt_to_orl_ub cmp l x ++ [(x,y)] ++ bt_to_orl_lb_ub cmp x r ub
           else bt_to_orl_ub cmp l ub

   [<a name="bt_to_orl_ub_ac-val"><b>bt_to_orl_ub_ac</b></a>]  Theorem

      |- (!ub m cmp. bt_to_orl_ub_ac cmp nt ub m = m) /\
         !y x ub r m l cmp.
           bt_to_orl_ub_ac cmp (node l (x,y) r) ub m =
           if apto cmp x ub = LESS then
             bt_to_orl_ub_ac cmp l x
               ((x,y)::bt_to_orl_lb_ub_ac cmp x r ub m)
           else bt_to_orl_ub_ac cmp l ub m

   [<a name="bt_to_orl_ub_ac_ind-val"><b>bt_to_orl_ub_ac_ind</b></a>]  Theorem

      |- !P.
           (!cmp ub m. P cmp nt ub m) /\
           (!cmp l x y r ub m.
              (apto cmp x ub &lt;&gt; LESS ==&gt; P cmp l ub m) /\
              ((apto cmp x ub = LESS) ==&gt;
               P cmp l x ((x,y)::bt_to_orl_lb_ub_ac cmp x r ub m)) ==&gt;
              P cmp (node l (x,y) r) ub m) ==&gt;
           !v v1 v2 v3. P v v1 v2 v3

   [<a name="bt_to_orl_ub_ind-val"><b>bt_to_orl_ub_ind</b></a>]  Theorem

      |- !P.
           (!cmp ub. P cmp nt ub) /\
           (!cmp l x y r ub.
              (apto cmp x ub &lt;&gt; LESS ==&gt; P cmp l ub) /\
              ((apto cmp x ub = LESS) ==&gt; P cmp l x) ==&gt;
              P cmp (node l (x,y) r) ub) ==&gt;
           !v v1 v2. P v v1 v2

   [<a name="diff_merge-val"><b>diff_merge</b></a>]  Theorem

      |- (!cmp. diff_merge cmp [] [] = []) /\
         (!l cmp b a. diff_merge cmp ((a,b)::l) [] = (a,b)::l) /\
         (!y m cmp. diff_merge cmp [] (y::m) = []) /\
         !y m l cmp b a.
           diff_merge cmp ((a,b)::l) (y::m) =
           case apto cmp a y of
             LESS =&gt; (a,b)::diff_merge cmp l (y::m)
           | EQUAL =&gt; diff_merge cmp l m
           | GREATER =&gt; diff_merge cmp ((a,b)::l) m

   [<a name="diff_merge_ind-val"><b>diff_merge_ind</b></a>]  Theorem

      |- !P.
           (!cmp. P cmp [] []) /\ (!cmp a b l. P cmp ((a,b)::l) []) /\
           (!cmp y m. P cmp [] (y::m)) /\
           (!cmp a b l y m.
              ((apto cmp a y = EQUAL) ==&gt; P cmp l m) /\
              ((apto cmp a y = GREATER) ==&gt; P cmp ((a,b)::l) m) /\
              ((apto cmp a y = LESS) ==&gt; P cmp l (y::m)) ==&gt;
              P cmp ((a,b)::l) (y::m)) ==&gt;
           !v v1 v2. P v v1 v2

   [<a name="fmap_FDOM-val"><b>fmap_FDOM</b></a>]  Theorem

      |- !l. FDOM (fmap l) = set (MAP FST l)

   [<a name="fmap_FDOM_rec-val"><b>fmap_FDOM_rec</b></a>]  Theorem

      |- (!x. x IN FDOM (fmap []) &lt;=&gt; F) /\
         !x w z l.
           x IN FDOM (fmap ((w,z)::l)) &lt;=&gt; (x = w) \/ x IN FDOM (fmap l)

   [<a name="fmap_ORWL_thm-val"><b>fmap_ORWL_thm</b></a>]  Theorem

      |- !cmp l. ORWL cmp (fmap l) (incr_sort cmp l)

   [<a name="incr_merge-val"><b>incr_merge</b></a>]  Theorem

      |- (!l cmp. incr_merge cmp l [] = [SOME l]) /\
         (!lol l cmp. incr_merge cmp l (NONE::lol) = SOME l::lol) /\
         !m lol l cmp.
           incr_merge cmp l (SOME m::lol) =
           NONE::incr_merge cmp (merge cmp l m) lol

   [<a name="incr_merge_ind-val"><b>incr_merge_ind</b></a>]  Theorem

      |- !P.
           (!cmp l. P cmp l []) /\ (!cmp l lol. P cmp l (NONE::lol)) /\
           (!cmp l m lol.
              P cmp (merge cmp l m) lol ==&gt; P cmp l (SOME m::lol)) ==&gt;
           !v v1 v2. P v v1 v2

   [<a name="inter_merge-val"><b>inter_merge</b></a>]  Theorem

      |- (!cmp. inter_merge cmp [] [] = []) /\
         (!l cmp b a. inter_merge cmp ((a,b)::l) [] = []) /\
         (!y m cmp. inter_merge cmp [] (y::m) = []) /\
         !y m l cmp b a.
           inter_merge cmp ((a,b)::l) (y::m) =
           case apto cmp a y of
             LESS =&gt; inter_merge cmp l (y::m)
           | EQUAL =&gt; (a,b)::inter_merge cmp l m
           | GREATER =&gt; inter_merge cmp ((a,b)::l) m

   [<a name="inter_merge_ind-val"><b>inter_merge_ind</b></a>]  Theorem

      |- !P.
           (!cmp. P cmp [] []) /\ (!cmp a b l. P cmp ((a,b)::l) []) /\
           (!cmp y m. P cmp [] (y::m)) /\
           (!cmp a b l y m.
              ((apto cmp a y = EQUAL) ==&gt; P cmp l m) /\
              ((apto cmp a y = GREATER) ==&gt; P cmp ((a,b)::l) m) /\
              ((apto cmp a y = LESS) ==&gt; P cmp l (y::m)) ==&gt;
              P cmp ((a,b)::l) (y::m)) ==&gt;
           !v v1 v2. P v v1 v2

   [<a name="list_rplacv_cn-val"><b>list_rplacv_cn</b></a>]  Theorem

      |- (!y x cn. list_rplacv_cn (x,y) [] cn = []) /\
         !z y x w l cn.
           list_rplacv_cn (x,y) ((w,z)::l) cn =
           if x = w then cn ((x,y)::l)
           else list_rplacv_cn (x,y) l (\m. cn ((w,z)::m))

   [<a name="list_rplacv_cn_ind-val"><b>list_rplacv_cn_ind</b></a>]  Theorem

      |- !P.
           (!x y cn. P (x,y) [] cn) /\
           (!x y w z l cn.
              (x &lt;&gt; w ==&gt; P (x,y) l (\m. cn ((w,z)::m))) ==&gt;
              P (x,y) ((w,z)::l) cn) ==&gt;
           !v v1 v2 v3. P (v,v1) v2 v3

   [<a name="list_rplacv_thm-val"><b>list_rplacv_thm</b></a>]  Theorem

      |- !x y l.
           (let ans = list_rplacv_cn (x,y) l (\m. m)
            in
              if ans = [] then x NOTIN FDOM (fmap l)
              else x IN FDOM (fmap l) /\ (fmap l |+ (x,y) = fmap ans))

   [<a name="merge-val"><b>merge</b></a>]  Theorem

      |- (!l cmp. merge cmp [] l = l) /\
         (!v5 v4 cmp. merge cmp (v4::v5) [] = v4::v5) /\
         !l2 l1 cmp b2 b1 a2 a1.
           merge cmp ((a1,b1)::l1) ((a2,b2)::l2) =
           case apto cmp a1 a2 of
             LESS =&gt; (a1,b1)::merge cmp l1 ((a2,b2)::l2)
           | EQUAL =&gt; (a1,b1)::merge cmp l1 l2
           | GREATER =&gt; (a2,b2)::merge cmp ((a1,b1)::l1) l2

   [<a name="merge_ind-val"><b>merge_ind</b></a>]  Theorem

      |- !P.
           (!cmp l. P cmp [] l) /\ (!cmp v4 v5. P cmp (v4::v5) []) /\
           (!cmp a1 b1 l1 a2 b2 l2.
              ((apto cmp a1 a2 = EQUAL) ==&gt; P cmp l1 l2) /\
              ((apto cmp a1 a2 = GREATER) ==&gt; P cmp ((a1,b1)::l1) l2) /\
              ((apto cmp a1 a2 = LESS) ==&gt; P cmp l1 ((a2,b2)::l2)) ==&gt;
              P cmp ((a1,b1)::l1) ((a2,b2)::l2)) ==&gt;
           !v v1 v2. P v v1 v2

   [<a name="merge_out-val"><b>merge_out</b></a>]  Theorem

      |- (!l cmp. merge_out cmp l [] = l) /\
         (!lol l cmp. merge_out cmp l (NONE::lol) = merge_out cmp l lol) /\
         !m lol l cmp.
           merge_out cmp l (SOME m::lol) =
           merge_out cmp (merge cmp l m) lol

   [<a name="merge_out_ind-val"><b>merge_out_ind</b></a>]  Theorem

      |- !P.
           (!cmp l. P cmp l []) /\
           (!cmp l lol. P cmp l lol ==&gt; P cmp l (NONE::lol)) /\
           (!cmp l m lol.
              P cmp (merge cmp l m) lol ==&gt; P cmp l (SOME m::lol)) ==&gt;
           !v v1 v2. P v v1 v2

   [<a name="o_f_bt_map-val"><b>o_f_bt_map</b></a>]  Theorem

      |- !cmp f t. f o_f FMAPAL cmp t = FMAPAL cmp (bt_map (AP_SND f) t)

   [<a name="o_f_fmap-val"><b>o_f_fmap</b></a>]  Theorem

      |- !f l. f o_f fmap l = fmap (MAP (AP_SND f) l)

   [<a name="optry_list-val"><b>optry_list</b></a>]  Theorem

      |- (!f. optry_list f [] = NONE) /\
         (!l f. optry_list f (NONE::l) = optry_list f l) /\
         !z l f. optry_list f (SOME z::l) = optry (f z) (optry_list f l)

   [<a name="optry_list_ind-val"><b>optry_list_ind</b></a>]  Theorem

      |- !P.
           (!f. P f []) /\ (!f l. P f l ==&gt; P f (NONE::l)) /\
           (!f z l. P f l ==&gt; P f (SOME z::l)) ==&gt;
           !v v1. P v v1


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/enumfset/fmapalScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-11</a></em></p></body></html>
