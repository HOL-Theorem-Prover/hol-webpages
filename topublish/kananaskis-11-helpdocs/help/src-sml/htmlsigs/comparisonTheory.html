<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><link rel="icon" href="../../../../images/logo.ico" type="image/vnd.microsoft.icon">
<meta http-equiv="content-type" content="text/html ; charset=UTF-8">
<title>Structure comparisonTheory</title>
<style type="text/css">
<!--
  body {background: #fbf2e7}
-->
</style></head>
<body>
<h1>Structure comparisonTheory</h1>
<hr><table width="100%"><tr align = center>
<th><a href="../../../src/enumfset/comparisonScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<pre>
<a name="line1"></a>signature comparisonTheory =
<a name="line2"></a>sig
<a name="line3"></a>  type thm = Thm.thm
<a name="line4"></a>
<a name="line5"></a>  (*  Definitions  *)
<a name="line6"></a>    val <a href="#bool_cmp_curried_def-val">bool_cmp_curried_def</a> : thm
<a name="line7"></a>    val <a href="#bool_cmp_tupled_primitive_def-val">bool_cmp_tupled_primitive_def</a> : thm
<a name="line8"></a>    val <a href="#char_cmp_def-val">char_cmp_def</a> : thm
<a name="line9"></a>    val <a href="#equiv_inj_def-val">equiv_inj_def</a> : thm
<a name="line10"></a>    val <a href="#good_cmp_def-val">good_cmp_def</a> : thm
<a name="line11"></a>    val <a href="#invert_def-val">invert_def</a> : thm
<a name="line12"></a>    val <a href="#list_cmp_curried_def-val">list_cmp_curried_def</a> : thm
<a name="line13"></a>    val <a href="#list_cmp_tupled_primitive_def-val">list_cmp_tupled_primitive_def</a> : thm
<a name="line14"></a>    val <a href="#num_cmp_def-val">num_cmp_def</a> : thm
<a name="line15"></a>    val <a href="#option_cmp2_curried_def-val">option_cmp2_curried_def</a> : thm
<a name="line16"></a>    val <a href="#option_cmp2_tupled_primitive_def-val">option_cmp2_tupled_primitive_def</a> : thm
<a name="line17"></a>    val <a href="#option_cmp_curried_def-val">option_cmp_curried_def</a> : thm
<a name="line18"></a>    val <a href="#option_cmp_tupled_primitive_def-val">option_cmp_tupled_primitive_def</a> : thm
<a name="line19"></a>    val <a href="#pair_cmp_def-val">pair_cmp_def</a> : thm
<a name="line20"></a>    val <a href="#resp_equiv2_def-val">resp_equiv2_def</a> : thm
<a name="line21"></a>    val <a href="#resp_equiv_def-val">resp_equiv_def</a> : thm
<a name="line22"></a>    val <a href="#string_cmp_def-val">string_cmp_def</a> : thm
<a name="line23"></a>
<a name="line24"></a>  (*  Theorems  *)
<a name="line25"></a>    val <a href="#TO_inv_invert-val">TO_inv_invert</a> : thm
<a name="line26"></a>    val <a href="#TotOrder_imp_good_cmp-val">TotOrder_imp_good_cmp</a> : thm
<a name="line27"></a>    val <a href="#antisym_resp_equiv-val">antisym_resp_equiv</a> : thm
<a name="line28"></a>    val <a href="#bool_cmp_antisym-val">bool_cmp_antisym</a> : thm
<a name="line29"></a>    val <a href="#bool_cmp_def-val">bool_cmp_def</a> : thm
<a name="line30"></a>    val <a href="#bool_cmp_good-val">bool_cmp_good</a> : thm
<a name="line31"></a>    val <a href="#bool_cmp_ind-val">bool_cmp_ind</a> : thm
<a name="line32"></a>    val <a href="#char_cmp_antisym-val">char_cmp_antisym</a> : thm
<a name="line33"></a>    val <a href="#char_cmp_charOrd-val">char_cmp_charOrd</a> : thm
<a name="line34"></a>    val <a href="#char_cmp_good-val">char_cmp_good</a> : thm
<a name="line35"></a>    val <a href="#cmp_thms-val">cmp_thms</a> : thm
<a name="line36"></a>    val <a href="#comparison_case_def-val">comparison_case_def</a> : thm
<a name="line37"></a>    val <a href="#comparison_distinct-val">comparison_distinct</a> : thm
<a name="line38"></a>    val <a href="#comparison_nchotomy-val">comparison_nchotomy</a> : thm
<a name="line39"></a>    val <a href="#good_cmp_thm-val">good_cmp_thm</a> : thm
<a name="line40"></a>    val <a href="#good_cmp_trans-val">good_cmp_trans</a> : thm
<a name="line41"></a>    val <a href="#invert_eq_EQUAL-val">invert_eq_EQUAL</a> : thm
<a name="line42"></a>    val <a href="#list_cmp_ListOrd-val">list_cmp_ListOrd</a> : thm
<a name="line43"></a>    val <a href="#list_cmp_antisym-val">list_cmp_antisym</a> : thm
<a name="line44"></a>    val <a href="#list_cmp_cong-val">list_cmp_cong</a> : thm
<a name="line45"></a>    val <a href="#list_cmp_def-val">list_cmp_def</a> : thm
<a name="line46"></a>    val <a href="#list_cmp_equal_list_rel-val">list_cmp_equal_list_rel</a> : thm
<a name="line47"></a>    val <a href="#list_cmp_good-val">list_cmp_good</a> : thm
<a name="line48"></a>    val <a href="#list_cmp_ind-val">list_cmp_ind</a> : thm
<a name="line49"></a>    val <a href="#num_cmp_antisym-val">num_cmp_antisym</a> : thm
<a name="line50"></a>    val <a href="#num_cmp_good-val">num_cmp_good</a> : thm
<a name="line51"></a>    val <a href="#num_cmp_numOrd-val">num_cmp_numOrd</a> : thm
<a name="line52"></a>    val <a href="#option_cmp2_TO_inv-val">option_cmp2_TO_inv</a> : thm
<a name="line53"></a>    val <a href="#option_cmp2_antisym-val">option_cmp2_antisym</a> : thm
<a name="line54"></a>    val <a href="#option_cmp2_cong-val">option_cmp2_cong</a> : thm
<a name="line55"></a>    val <a href="#option_cmp2_def-val">option_cmp2_def</a> : thm
<a name="line56"></a>    val <a href="#option_cmp2_good-val">option_cmp2_good</a> : thm
<a name="line57"></a>    val <a href="#option_cmp2_ind-val">option_cmp2_ind</a> : thm
<a name="line58"></a>    val <a href="#option_cmp_antisym-val">option_cmp_antisym</a> : thm
<a name="line59"></a>    val <a href="#option_cmp_cong-val">option_cmp_cong</a> : thm
<a name="line60"></a>    val <a href="#option_cmp_def-val">option_cmp_def</a> : thm
<a name="line61"></a>    val <a href="#option_cmp_good-val">option_cmp_good</a> : thm
<a name="line62"></a>    val <a href="#option_cmp_ind-val">option_cmp_ind</a> : thm
<a name="line63"></a>    val <a href="#pair_cmp_antisym-val">pair_cmp_antisym</a> : thm
<a name="line64"></a>    val <a href="#pair_cmp_cong-val">pair_cmp_cong</a> : thm
<a name="line65"></a>    val <a href="#pair_cmp_good-val">pair_cmp_good</a> : thm
<a name="line66"></a>    val <a href="#pair_cmp_lexTO-val">pair_cmp_lexTO</a> : thm
<a name="line67"></a>    val <a href="#string_cmp_antisym-val">string_cmp_antisym</a> : thm
<a name="line68"></a>    val <a href="#string_cmp_good-val">string_cmp_good</a> : thm
<a name="line69"></a>    val <a href="#string_cmp_stringto-val">string_cmp_stringto</a> : thm
<a name="line70"></a>
<a name="line71"></a>  val comparison_grammars : type_grammar.grammar * term_grammar.grammar
<a name="line72"></a>(*
   [toto] Parent theory of "comparison"

   [<a name="bool_cmp_curried_def-val"><b>bool_cmp_curried_def</b></a>]  Definition

      |- ∀x x1. bool_cmp x x1 = bool_cmp_tupled (x,x1)

   [<a name="bool_cmp_tupled_primitive_def-val"><b>bool_cmp_tupled_primitive_def</b></a>]  Definition

      |- bool_cmp_tupled =
         WFREC (@R. WF R)
           (λbool_cmp_tupled a.
              case a of
                (T,T) =&gt; I Equal
              | (T,F) =&gt; I Greater
              | (F,T) =&gt; I Less
              | (F,F) =&gt; I Equal)

   [<a name="char_cmp_def-val"><b>char_cmp_def</b></a>]  Definition

      |- ∀c1 c2. char_cmp c1 c2 = num_cmp (ORD c1) (ORD c2)

   [<a name="equiv_inj_def-val"><b>equiv_inj_def</b></a>]  Definition

      |- ∀cmp cmp2 f.
           equiv_inj cmp cmp2 f ⇔
           ∀k1 k2. cmp2 (f k1) (f k2) = Equal ⇒ cmp k1 k2 = Equal

   [<a name="good_cmp_def-val"><b>good_cmp_def</b></a>]  Definition

      |- ∀cmp.
           good_cmp cmp ⇔
           (∀x. cmp x x = Equal) ∧
           (∀x y. cmp x y = Equal ⇒ cmp y x = Equal) ∧
           (∀x y. cmp x y = Greater ⇔ cmp y x = Less) ∧
           (∀x y z. cmp x y = Equal ∧ cmp y z = Less ⇒ cmp x z = Less) ∧
           (∀x y z. cmp x y = Less ∧ cmp y z = Equal ⇒ cmp x z = Less) ∧
           (∀x y z. cmp x y = Equal ∧ cmp y z = Equal ⇒ cmp x z = Equal) ∧
           ∀x y z. cmp x y = Less ∧ cmp y z = Less ⇒ cmp x z = Less

   [<a name="invert_def-val"><b>invert_def</b></a>]  Definition

      |- invert Greater = Less ∧ invert Less = Greater ∧
         invert Equal = Equal

   [<a name="list_cmp_curried_def-val"><b>list_cmp_curried_def</b></a>]  Definition

      |- ∀x x1 x2. list_cmp x x1 x2 = list_cmp_tupled (x,x1,x2)

   [<a name="list_cmp_tupled_primitive_def-val"><b>list_cmp_tupled_primitive_def</b></a>]  Definition

      |- list_cmp_tupled =
         WFREC
           (@R.
              WF R ∧
              ∀y2 y1 x2 x1 cmp.
                cmp x1 x2 = Equal ⇒ R (cmp,y1,y2) (cmp,x1::y1,x2::y2))
           (λlist_cmp_tupled a.
              case a of
                (cmp,[],[]) =&gt; I Equal
              | (cmp,[],x::y) =&gt; I Less
              | (cmp,x'::y',[]) =&gt; I Greater
              | (cmp,x'::y',x2::y2) =&gt;
                  I
                    (case cmp x' x2 of
                       Less =&gt; Less
                     | Equal =&gt; list_cmp_tupled (cmp,y',y2)
                     | Greater =&gt; Greater))

   [<a name="num_cmp_def-val"><b>num_cmp_def</b></a>]  Definition

      |- ∀n1 n2.
           num_cmp n1 n2 =
           if n1 = n2 then Equal else if n1 &lt; n2 then Less else Greater

   [<a name="option_cmp2_curried_def-val"><b>option_cmp2_curried_def</b></a>]  Definition

      |- ∀x x1 x2. option_cmp2 x x1 x2 = option_cmp2_tupled (x,x1,x2)

   [<a name="option_cmp2_tupled_primitive_def-val"><b>option_cmp2_tupled_primitive_def</b></a>]  Definition

      |- option_cmp2_tupled =
         WFREC (@R. WF R)
           (λoption_cmp2_tupled a.
              case a of
                (cmp,NONE,NONE) =&gt; I Equal
              | (cmp,NONE,SOME x) =&gt; I Greater
              | (cmp,SOME x',NONE) =&gt; I Less
              | (cmp,SOME x',SOME y) =&gt; I (cmp x' y))

   [<a name="option_cmp_curried_def-val"><b>option_cmp_curried_def</b></a>]  Definition

      |- ∀x x1 x2. option_cmp x x1 x2 = option_cmp_tupled (x,x1,x2)

   [<a name="option_cmp_tupled_primitive_def-val"><b>option_cmp_tupled_primitive_def</b></a>]  Definition

      |- option_cmp_tupled =
         WFREC (@R. WF R)
           (λoption_cmp_tupled a.
              case a of
                (cmp,NONE,NONE) =&gt; I Equal
              | (cmp,NONE,SOME x) =&gt; I Less
              | (cmp,SOME x',NONE) =&gt; I Greater
              | (cmp,SOME x',SOME y) =&gt; I (cmp x' y))

   [<a name="pair_cmp_def-val"><b>pair_cmp_def</b></a>]  Definition

      |- ∀cmp1 cmp2 x y.
           pair_cmp cmp1 cmp2 x y =
           case cmp1 (FST x) (FST y) of
             Less =&gt; Less
           | Equal =&gt; cmp2 (SND x) (SND y)
           | Greater =&gt; Greater

   [<a name="resp_equiv2_def-val"><b>resp_equiv2_def</b></a>]  Definition

      |- ∀cmp cmp2 f.
           resp_equiv2 cmp cmp2 f ⇔
           ∀k1 k2. cmp k1 k2 = Equal ⇒ cmp2 (f k1) (f k2) = Equal

   [<a name="resp_equiv_def-val"><b>resp_equiv_def</b></a>]  Definition

      |- ∀cmp f.
           resp_equiv cmp f ⇔ ∀k1 k2 v. cmp k1 k2 = Equal ⇒ f k1 v = f k2 v

   [<a name="string_cmp_def-val"><b>string_cmp_def</b></a>]  Definition

      |- string_cmp = list_cmp char_cmp

   [<a name="TO_inv_invert-val"><b>TO_inv_invert</b></a>]  Theorem

      |- ∀c. TotOrd c ⇒ TO_inv c = CURRY (invert o UNCURRY c)

   [<a name="TotOrder_imp_good_cmp-val"><b>TotOrder_imp_good_cmp</b></a>]  Theorem

      |- ∀cmp. TotOrd cmp ⇒ good_cmp cmp

   [<a name="antisym_resp_equiv-val"><b>antisym_resp_equiv</b></a>]  Theorem

      |- ∀cmp f.
           (∀x y. cmp x y = Equal ⇒ x = y) ⇒
           resp_equiv cmp f ∧ ∀cmp2. good_cmp cmp2 ⇒ resp_equiv2 cmp cmp2 f

   [<a name="bool_cmp_antisym-val"><b>bool_cmp_antisym</b></a>]  Theorem

      |- ∀x y. bool_cmp x y = Equal ⇔ (x ⇔ y)

   [<a name="bool_cmp_def-val"><b>bool_cmp_def</b></a>]  Theorem

      |- bool_cmp T T = Equal ∧ bool_cmp F F = Equal ∧
         bool_cmp T F = Greater ∧ bool_cmp F T = Less

   [<a name="bool_cmp_good-val"><b>bool_cmp_good</b></a>]  Theorem

      |- good_cmp bool_cmp

   [<a name="bool_cmp_ind-val"><b>bool_cmp_ind</b></a>]  Theorem

      |- ∀P. P T T ∧ P F F ∧ P T F ∧ P F T ⇒ ∀v v1. P v v1

   [<a name="char_cmp_antisym-val"><b>char_cmp_antisym</b></a>]  Theorem

      |- ∀x y. char_cmp x y = Equal ⇔ x = y

   [<a name="char_cmp_charOrd-val"><b>char_cmp_charOrd</b></a>]  Theorem

      |- char_cmp = charOrd

   [<a name="char_cmp_good-val"><b>char_cmp_good</b></a>]  Theorem

      |- good_cmp char_cmp

   [<a name="cmp_thms-val"><b>cmp_thms</b></a>]  Theorem

      |- (Less ≠ Equal ∧ Less ≠ Greater ∧ Equal ≠ Greater) ∧
         ((∀v0 v1 v2.
             (case Less of Less =&gt; v0 | Equal =&gt; v1 | Greater =&gt; v2) =
             v0) ∧
          (∀v0 v1 v2.
             (case Equal of Less =&gt; v0 | Equal =&gt; v1 | Greater =&gt; v2) =
             v1) ∧
          ∀v0 v1 v2.
            (case Greater of Less =&gt; v0 | Equal =&gt; v1 | Greater =&gt; v2) =
            v2) ∧ (∀a. a = Less ∨ a = Equal ∨ a = Greater) ∧
         ∀cmp.
           good_cmp cmp ⇔
           (∀x. cmp x x = Equal) ∧
           (∀x y. cmp x y = Equal ⇒ cmp y x = Equal) ∧
           (∀x y. cmp x y = Greater ⇔ cmp y x = Less) ∧
           (∀x y z. cmp x y = Equal ∧ cmp y z = Less ⇒ cmp x z = Less) ∧
           (∀x y z. cmp x y = Less ∧ cmp y z = Equal ⇒ cmp x z = Less) ∧
           (∀x y z. cmp x y = Equal ∧ cmp y z = Equal ⇒ cmp x z = Equal) ∧
           ∀x y z. cmp x y = Less ∧ cmp y z = Less ⇒ cmp x z = Less

   [<a name="comparison_case_def-val"><b>comparison_case_def</b></a>]  Theorem

      |- (∀v0 v1 v2.
            (case Less of Less =&gt; v0 | Equal =&gt; v1 | Greater =&gt; v2) = v0) ∧
         (∀v0 v1 v2.
            (case Equal of Less =&gt; v0 | Equal =&gt; v1 | Greater =&gt; v2) =
            v1) ∧
         ∀v0 v1 v2.
           (case Greater of Less =&gt; v0 | Equal =&gt; v1 | Greater =&gt; v2) = v2

   [<a name="comparison_distinct-val"><b>comparison_distinct</b></a>]  Theorem

      |- Less ≠ Equal ∧ Less ≠ Greater ∧ Equal ≠ Greater

   [<a name="comparison_nchotomy-val"><b>comparison_nchotomy</b></a>]  Theorem

      |- ∀a. a = Less ∨ a = Equal ∨ a = Greater

   [<a name="good_cmp_thm-val"><b>good_cmp_thm</b></a>]  Theorem

      |- ∀cmp.
           good_cmp cmp ⇔
           (∀x. cmp x x = Equal) ∧
           ∀x y z.
             (cmp x y = Greater ⇔ cmp y x = Less) ∧
             (cmp x y = Less ∧ cmp y z = Equal ⇒ cmp x z = Less) ∧
             (cmp x y = Less ∧ cmp y z = Less ⇒ cmp x z = Less)

   [<a name="good_cmp_trans-val"><b>good_cmp_trans</b></a>]  Theorem

      |- ∀cmp. good_cmp cmp ⇒ transitive (λ(k,v) (k',v'). cmp k k' = Less)

   [<a name="invert_eq_EQUAL-val"><b>invert_eq_EQUAL</b></a>]  Theorem

      |- ∀x. invert x = Equal ⇔ x = Equal

   [<a name="list_cmp_ListOrd-val"><b>list_cmp_ListOrd</b></a>]  Theorem

      |- ∀c. TotOrd c ⇒ list_cmp c = ListOrd (TO c)

   [<a name="list_cmp_antisym-val"><b>list_cmp_antisym</b></a>]  Theorem

      |- ∀cmp x y.
           (∀x y. cmp x y = Equal ⇔ x = y) ⇒
           (list_cmp cmp x y = Equal ⇔ x = y)

   [<a name="list_cmp_cong-val"><b>list_cmp_cong</b></a>]  Theorem

      |- ∀cmp l1 l2 cmp' l1' l2'.
           l1 = l1' ∧ l2 = l2' ∧
           (∀x x'. MEM x l1' ∧ MEM x' l2' ⇒ cmp x x' = cmp' x x') ⇒
           list_cmp cmp l1 l2 = list_cmp cmp' l1' l2'

   [<a name="list_cmp_def-val"><b>list_cmp_def</b></a>]  Theorem

      |- (∀cmp. list_cmp cmp [] [] = Equal) ∧
         (∀y x cmp. list_cmp cmp [] (x::y) = Less) ∧
         (∀y x cmp. list_cmp cmp (x::y) [] = Greater) ∧
         ∀y2 y1 x2 x1 cmp.
           list_cmp cmp (x1::y1) (x2::y2) =
           case cmp x1 x2 of
             Less =&gt; Less
           | Equal =&gt; list_cmp cmp y1 y2
           | Greater =&gt; Greater

   [<a name="list_cmp_equal_list_rel-val"><b>list_cmp_equal_list_rel</b></a>]  Theorem

      |- ∀cmp l1 l2.
           list_cmp cmp l1 l2 = Equal ⇔
           LIST_REL (λx y. cmp x y = Equal) l1 l2

   [<a name="list_cmp_good-val"><b>list_cmp_good</b></a>]  Theorem

      |- ∀cmp. good_cmp cmp ⇒ good_cmp (list_cmp cmp)

   [<a name="list_cmp_ind-val"><b>list_cmp_ind</b></a>]  Theorem

      |- ∀P.
           (∀cmp. P cmp [] []) ∧ (∀cmp x y. P cmp [] (x::y)) ∧
           (∀cmp x y. P cmp (x::y) []) ∧
           (∀cmp x1 y1 x2 y2.
              (cmp x1 x2 = Equal ⇒ P cmp y1 y2) ⇒
              P cmp (x1::y1) (x2::y2)) ⇒
           ∀v v1 v2. P v v1 v2

   [<a name="num_cmp_antisym-val"><b>num_cmp_antisym</b></a>]  Theorem

      |- ∀x y. num_cmp x y = Equal ⇔ x = y

   [<a name="num_cmp_good-val"><b>num_cmp_good</b></a>]  Theorem

      |- good_cmp num_cmp

   [<a name="num_cmp_numOrd-val"><b>num_cmp_numOrd</b></a>]  Theorem

      |- num_cmp = numOrd

   [<a name="option_cmp2_TO_inv-val"><b>option_cmp2_TO_inv</b></a>]  Theorem

      |- ∀c. option_cmp2 c = TO_inv (option_cmp (TO_inv c))

   [<a name="option_cmp2_antisym-val"><b>option_cmp2_antisym</b></a>]  Theorem

      |- ∀cmp x y.
           (∀x y. cmp x y = Equal ⇔ x = y) ⇒
           (option_cmp2 cmp x y = Equal ⇔ x = y)

   [<a name="option_cmp2_cong-val"><b>option_cmp2_cong</b></a>]  Theorem

      |- ∀cmp v1 v2 cmp' v1' v2'.
           v1 = v1' ∧ v2 = v2' ∧
           (∀x x'. v1' = SOME x ∧ v2' = SOME x' ⇒ cmp x x' = cmp' x x') ⇒
           option_cmp2 cmp v1 v2 = option_cmp2 cmp' v1' v2'

   [<a name="option_cmp2_def-val"><b>option_cmp2_def</b></a>]  Theorem

      |- option_cmp2 cmp NONE NONE = Equal ∧
         option_cmp2 cmp NONE (SOME x') = Greater ∧
         option_cmp2 cmp (SOME x) NONE = Less ∧
         option_cmp2 cmp (SOME x) (SOME y) = cmp x y

   [<a name="option_cmp2_good-val"><b>option_cmp2_good</b></a>]  Theorem

      |- ∀cmp. good_cmp cmp ⇒ good_cmp (option_cmp2 cmp)

   [<a name="option_cmp2_ind-val"><b>option_cmp2_ind</b></a>]  Theorem

      |- ∀P.
           (∀cmp. P cmp NONE NONE) ∧ (∀cmp x. P cmp NONE (SOME x)) ∧
           (∀cmp x. P cmp (SOME x) NONE) ∧
           (∀cmp x y. P cmp (SOME x) (SOME y)) ⇒
           ∀v v1 v2. P v v1 v2

   [<a name="option_cmp_antisym-val"><b>option_cmp_antisym</b></a>]  Theorem

      |- ∀cmp x y.
           (∀x y. cmp x y = Equal ⇔ x = y) ⇒
           (option_cmp cmp x y = Equal ⇔ x = y)

   [<a name="option_cmp_cong-val"><b>option_cmp_cong</b></a>]  Theorem

      |- ∀cmp v1 v2 cmp' v1' v2'.
           v1 = v1' ∧ v2 = v2' ∧
           (∀x x'. v1' = SOME x ∧ v2' = SOME x' ⇒ cmp x x' = cmp' x x') ⇒
           option_cmp cmp v1 v2 = option_cmp cmp' v1' v2'

   [<a name="option_cmp_def-val"><b>option_cmp_def</b></a>]  Theorem

      |- option_cmp cmp NONE NONE = Equal ∧
         option_cmp cmp NONE (SOME x') = Less ∧
         option_cmp cmp (SOME x) NONE = Greater ∧
         option_cmp cmp (SOME x) (SOME y) = cmp x y

   [<a name="option_cmp_good-val"><b>option_cmp_good</b></a>]  Theorem

      |- ∀cmp. good_cmp cmp ⇒ good_cmp (option_cmp cmp)

   [<a name="option_cmp_ind-val"><b>option_cmp_ind</b></a>]  Theorem

      |- ∀P.
           (∀cmp. P cmp NONE NONE) ∧ (∀cmp x. P cmp NONE (SOME x)) ∧
           (∀cmp x. P cmp (SOME x) NONE) ∧
           (∀cmp x y. P cmp (SOME x) (SOME y)) ⇒
           ∀v v1 v2. P v v1 v2

   [<a name="pair_cmp_antisym-val"><b>pair_cmp_antisym</b></a>]  Theorem

      |- ∀cmp1 cmp2 x y.
           (∀x y. cmp1 x y = Equal ⇔ x = y) ∧
           (∀x y. cmp2 x y = Equal ⇔ x = y) ⇒
           (pair_cmp cmp1 cmp2 x y = Equal ⇔ x = y)

   [<a name="pair_cmp_cong-val"><b>pair_cmp_cong</b></a>]  Theorem

      |- ∀cmp1 cmp2 v1 v2 cmp1' cmp2' v1' v2'.
           v1 = v1' ∧ v2 = v2' ∧
           (∀a b c d. v1' = (a,b) ∧ v2' = (c,d) ⇒ cmp1 a c = cmp1' a c) ∧
           (∀a b c d. v1' = (a,b) ∧ v2' = (c,d) ⇒ cmp2 b d = cmp2' b d) ⇒
           pair_cmp cmp1 cmp2 v1 v2 = pair_cmp cmp1' cmp2' v1' v2'

   [<a name="pair_cmp_good-val"><b>pair_cmp_good</b></a>]  Theorem

      |- ∀cmp1 cmp2.
           good_cmp cmp1 ∧ good_cmp cmp2 ⇒ good_cmp (pair_cmp cmp1 cmp2)

   [<a name="pair_cmp_lexTO-val"><b>pair_cmp_lexTO</b></a>]  Theorem

      |- ∀R V. TotOrd R ∧ TotOrd V ⇒ pair_cmp R V = R lexTO V

   [<a name="string_cmp_antisym-val"><b>string_cmp_antisym</b></a>]  Theorem

      |- ∀x y. string_cmp x y = Equal ⇔ x = y

   [<a name="string_cmp_good-val"><b>string_cmp_good</b></a>]  Theorem

      |- good_cmp string_cmp

   [<a name="string_cmp_stringto-val"><b>string_cmp_stringto</b></a>]  Theorem

      |- string_cmp = apto stringto


*)
end

</pre><hr><table width="100%"><tr align = center>
<th><a href="../../../src/enumfset/comparisonScript.sml" type="text/plain" type="text/plain">Source File</a>
<th><a href="idIndex.html">Identifier index</A>
<th><a href="TheoryIndex.html">Theory binding index</A>
</table><hr>
<p><em><a href="http://hol.sourceforge.net">HOL&nbsp;4,&nbsp;Kananaskis-11</a></em></p></body></html>
