<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: bitstring</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "bitstring"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "wordsTheory.html"><span class="strong">words</span></a>

<h1>Signature</h1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr>
    <th>
    Constant
    <th>
    Type<tr><td>
            <span class="strong">add</span>
            <td>
            :bitstring -> bitstring -> bitstring
    <tr><td>
        <span class="strong">band</span>
        <td>
        :bitstring -> bitstring -> bitstring
    <tr><td>
        <span class="strong">bitify</span>
        <td>
        :num list -> bitstring -> num list
    <tr><td>
        <span class="strong">bitify_tupled</span>
        <td>
        :num list # bitstring -> num list
    <tr><td>
        <span class="strong">bitwise</span>
        <td>
        :bool toto$reln -> bitstring -> bitstring -> bitstring
    <tr><td>
        <span class="strong">bnand</span>
        <td>
        :bitstring -> bitstring -> bitstring
    <tr><td>
        <span class="strong">bnor</span>
        <td>
        :bitstring -> bitstring -> bitstring
    <tr><td> <span class="strong">bnot</span> <td> :bitstring -> bitstring
    <tr><td>
        <span class="strong">boolify</span>
        <td>
        :bitstring -> num list -> bitstring
    <tr><td>
        <span class="strong">bor</span>
        <td>
        :bitstring -> bitstring -> bitstring
    <tr><td>
        <span class="strong">bxnor</span>
        <td>
        :bitstring -> bitstring -> bitstring
    <tr><td>
        <span class="strong">bxor</span>
        <td>
        :bitstring -> bitstring -> bitstring
    <tr><td>
        <span class="strong">extend</span>
        <td>
        :Î± -> num -> Î± list -> Î± list
    <tr><td>
        <span class="strong">field</span>
        <td>
        :num -> num -> bitstring -> bitstring
    <tr><td>
        <span class="strong">field_insert</span>
        <td>
        :num -> num -> bitstring -> bitstring -> bitstring
    <tr><td>
        <span class="strong">fixwidth</span>
        <td>
        :num -> bitstring -> bitstring
    <tr><td>
        <span class="strong">modify</span>
        <td>
        :(num -> bool -> bool) -> bitstring -> bitstring
    <tr><td> <span class="strong">n2v</span> <td> :num -> bitstring
    <tr><td>
        <span class="strong">replicate</span>
        <td>
        :bitstring -> num -> bitstring
    <tr><td> <span class="strong">rev_count_list</span> <td> :num -> num list
    <tr><td>
        <span class="strong">rotate</span>
        <td>
        :bitstring -> num -> bitstring
    <tr><td> <span class="strong">s2v</span> <td> :string -> bitstring
    <tr><td>
        <span class="strong">shiftl</span>
        <td>
        :bitstring -> num -> bitstring
    <tr><td> <span class="strong">shiftr</span> <td> :Î± list -> num -> Î± list
    <tr><td>
        <span class="strong">sign_extend</span>
        <td>
        :num -> Î± list -> Î± list
    <tr><td>
        <span class="strong">testbit</span>
        <td>
        :num -> bitstring -> bool
    <tr><td> <span class="strong">v2n</span> <td> :bitstring -> num
    <tr><td> <span class="strong">v2s</span> <td> :bitstring -> string
    <tr><td> <span class="strong">v2w</span> <td> :bitstring -> Î± word
    <tr><td> <span class="strong">w2v</span> <td> :Î± word -> bitstring
    <tr><td>
        <span class="strong">zero_extend</span>
        <td>
        :num -> bitstring -> bitstring

</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">extend_def</span>
<DD>
<pre>
|- (âˆ€v0 l. extend v0 0 l = l) âˆ§ âˆ€c n l. extend c (SUC n) l = extend c n (c::l)
</pre>

<DT><span class="strong">boolify_def</span>
<DD>
<pre>
|- (âˆ€a. boolify a [] = a) âˆ§ âˆ€a n l. boolify a (n::l) = boolify ((n â‰  0)::a) l
</pre>

<DT><span class="strong">bitify_tupled_primitive_def</span>
<DD>
<pre>
|- bitify_tupled =
   WFREC (@R. WF R âˆ§ (âˆ€l a. R (0::a,l) (a,F::l)) âˆ§ âˆ€l a. R (1::a,l) (a,T::l))
     (Î»bitify_tupled a'.
        case a' of
          (a,[]) => I a
        | (a,T::l) => I (bitify_tupled (1::a,l))
        | (a,F::l) => I (bitify_tupled (0::a,l)))
</pre>

<DT><span class="strong">bitify_curried_def</span>
<DD>
<pre>
|- âˆ€x x1. bitify x x1 = bitify_tupled (x,x1)
</pre>

<DT><span class="strong">n2v_def</span>
<DD>
<pre>
|- âˆ€n.
     n2v n =
     if n = 0 then [F]
     else
       (let w = LOG2 n
        in
          PAD_LEFT F (w + 1) (boolify [] (num_to_bin_list (BITS w 0 n))))
</pre>

<DT><span class="strong">v2n_def</span>
<DD>
<pre>
|- âˆ€l. v2n l = num_from_bin_list (bitify [] l)
</pre>

<DT><span class="strong">s2v_def</span>
<DD>
<pre>
|- s2v = MAP (Î»c. (c = #"1") âˆ¨ (c = #"T"))
</pre>

<DT><span class="strong">v2s_def</span>
<DD>
<pre>
|- v2s = MAP (Î»b. if b then #"1" else #"0")
</pre>

<DT><span class="strong">zero_extend_def</span>
<DD>
<pre>
|- âˆ€n v. zero_extend n v = PAD_LEFT F n v
</pre>

<DT><span class="strong">sign_extend_def</span>
<DD>
<pre>
|- âˆ€n v. sign_extend n v = PAD_LEFT (HD v) n v
</pre>

<DT><span class="strong">fixwidth_def</span>
<DD>
<pre>
|- âˆ€n v.
     fixwidth n v =
     (let l = LENGTH v in if l < n then zero_extend n v else DROP (l âˆ’ n) v)
</pre>

<DT><span class="strong">shiftl_def</span>
<DD>
<pre>
|- âˆ€v m. shiftl v m = PAD_RIGHT F (LENGTH v + m) v
</pre>

<DT><span class="strong">shiftr_def</span>
<DD>
<pre>
|- âˆ€v m. shiftr v m = TAKE (LENGTH v âˆ’ m) v
</pre>

<DT><span class="strong">field_def</span>
<DD>
<pre>
|- âˆ€h l v. field h l v = fixwidth (SUC h âˆ’ l) (shiftr v l)
</pre>

<DT><span class="strong">rotate_def</span>
<DD>
<pre>
|- âˆ€v m.
     rotate v m =
     (let l = LENGTH v in
      let x = m MOD l
      in
        if (l = 0) âˆ¨ (x = 0) then v
        else field (x âˆ’ 1) 0 v ++ field (l âˆ’ 1) x v)
</pre>

<DT><span class="strong">testbit_def</span>
<DD>
<pre>
|- âˆ€b v. testbit b v â‡” (field b b v = [T])
</pre>

<DT><span class="strong">w2v_def</span>
<DD>
<pre>
|- âˆ€w. w2v w = GENLIST (Î»i. w ' (dimindex (:Î±) âˆ’ 1 âˆ’ i)) (dimindex (:Î±))
</pre>

<DT><span class="strong">v2w_def</span>
<DD>
<pre>
|- âˆ€v. v2w v = FCP i. testbit i v
</pre>

<DT><span class="strong">rev_count_list_def</span>
<DD>
<pre>
|- âˆ€n. rev_count_list n = GENLIST (Î»i. n âˆ’ 1 âˆ’ i) n
</pre>

<DT><span class="strong">modify_def</span>
<DD>
<pre>
|- âˆ€f v. modify f v = MAP (UNCURRY f) (ZIP (rev_count_list (LENGTH v),v))
</pre>

<DT><span class="strong">field_insert_def</span>
<DD>
<pre>
|- âˆ€h l s.
     field_insert h l s =
     modify (Î»i. COND (l â‰¤ i âˆ§ i â‰¤ h) (testbit (i âˆ’ l) s))
</pre>

<DT><span class="strong">add_def</span>
<DD>
<pre>
|- âˆ€a b.
     add a b =
     (let m = MAX (LENGTH a) (LENGTH b)
      in
        zero_extend m (n2v (v2n a + v2n b)))
</pre>

<DT><span class="strong">bitwise_def</span>
<DD>
<pre>
|- âˆ€f v1 v2.
     bitwise f v1 v2 =
     (let m = MAX (LENGTH v1) (LENGTH v2)
      in
        MAP (UNCURRY f) (ZIP (fixwidth m v1,fixwidth m v2)))
</pre>

<DT><span class="strong">bnot_def</span>
<DD>
<pre>
|- bnot = MAP $~
</pre>

<DT><span class="strong">bor_def</span>
<DD>
<pre>
|- bor = bitwise $\/
</pre>

<DT><span class="strong">band_def</span>
<DD>
<pre>
|- band = bitwise $/\
</pre>

<DT><span class="strong">bxor_def</span>
<DD>
<pre>
|- bxor = bitwise (Î»x y. x â‡ y)
</pre>

<DT><span class="strong">bnor_def</span>
<DD>
<pre>
|- bnor = bitwise (Î»x y. Â¬(x âˆ¨ y))
</pre>

<DT><span class="strong">bxnor_def</span>
<DD>
<pre>
|- bxnor = bitwise $<=>
</pre>

<DT><span class="strong">bnand_def</span>
<DD>
<pre>
|- bnand = bitwise (Î»x y. Â¬(x âˆ§ y))
</pre>

<DT><span class="strong">replicate_def</span>
<DD>
<pre>
|- âˆ€v n. replicate v n = FLAT (GENLIST (K v) n)
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">extend_def_compute</span>
<DD>
<pre>
|- (âˆ€v0 l. extend v0 0 l = l) âˆ§
   (âˆ€c n l.
      extend c (NUMERAL (BIT1 n)) l =
      extend c (NUMERAL (BIT1 n) âˆ’ 1) (c::l)) âˆ§
   âˆ€c n l. extend c (NUMERAL (BIT2 n)) l = extend c (NUMERAL (BIT1 n)) (c::l)
</pre>

<DT><span class="strong">bitify_ind</span>
<DD>
<pre>
|- âˆ€P.
     (âˆ€a. P a []) âˆ§ (âˆ€a l. P (0::a) l â‡’ P a (F::l)) âˆ§
     (âˆ€a l. P (1::a) l â‡’ P a (T::l)) â‡’
     âˆ€v v1. P v v1
</pre>

<DT><span class="strong">bitify_def</span>
<DD>
<pre>
|- (âˆ€a. bitify a [] = a) âˆ§ (âˆ€l a. bitify a (F::l) = bitify (0::a) l) âˆ§
   âˆ€l a. bitify a (T::l) = bitify (1::a) l
</pre>

<DT><span class="strong">extend_cons</span>
<DD>
<pre>
|- âˆ€n c l. extend c (SUC n) l = c::extend c n l
</pre>

<DT><span class="strong">pad_left_extend</span>
<DD>
<pre>
|- âˆ€n l c. PAD_LEFT c n l = extend c (n âˆ’ LENGTH l) l
</pre>

<DT><span class="strong">extend</span>
<DD>
<pre>
|- (âˆ€n v. zero_extend n v = extend F (n âˆ’ LENGTH v) v) âˆ§
   âˆ€n v. sign_extend n v = extend (HD v) (n âˆ’ LENGTH v) v
</pre>

<DT><span class="strong">fixwidth</span>
<DD>
<pre>
|- âˆ€n v.
     fixwidth n v =
     (let l = LENGTH v
      in
        if l < n then extend F (n âˆ’ l) v else DROP (l âˆ’ n) v)
</pre>

<DT><span class="strong">fixwidth_id</span>
<DD>
<pre>
|- âˆ€w. fixwidth (LENGTH w) w = w
</pre>

<DT><span class="strong">fixwidth_id_imp</span>
<DD>
<pre>
|- âˆ€n w. (n = LENGTH w) â‡’ (fixwidth n w = w)
</pre>

<DT><span class="strong">boolify_reverse_map</span>
<DD>
<pre>
|- âˆ€v a. boolify a v = REVERSE (MAP (Î»n. n â‰  0) v) ++ a
</pre>

<DT><span class="strong">bitify_reverse_map</span>
<DD>
<pre>
|- âˆ€v a. bitify a v = REVERSE (MAP (Î»b. if b then 1 else 0) v) ++ a
</pre>

<DT><span class="strong">every_bit_bitify</span>
<DD>
<pre>
|- âˆ€v. EVERY ($> 2) (bitify [] v)
</pre>

<DT><span class="strong">length_pad_left</span>
<DD>
<pre>
|- âˆ€x n a. LENGTH (PAD_LEFT x n a) = if LENGTH a < n then n else LENGTH a
</pre>

<DT><span class="strong">length_pad_right</span>
<DD>
<pre>
|- âˆ€x n a. LENGTH (PAD_RIGHT x n a) = if LENGTH a < n then n else LENGTH a
</pre>

<DT><span class="strong">length_zero_extend</span>
<DD>
<pre>
|- âˆ€n v. LENGTH v < n â‡’ (LENGTH (zero_extend n v) = n)
</pre>

<DT><span class="strong">length_sign_extend</span>
<DD>
<pre>
|- âˆ€n v. LENGTH v < n â‡’ (LENGTH (sign_extend n v) = n)
</pre>

<DT><span class="strong">length_fixwidth</span>
<DD>
<pre>
|- âˆ€n v. LENGTH (fixwidth n v) = n
</pre>

<DT><span class="strong">length_field</span>
<DD>
<pre>
|- âˆ€h l v. LENGTH (field h l v) = SUC h âˆ’ l
</pre>

<DT><span class="strong">length_bitify</span>
<DD>
<pre>
|- âˆ€v l. LENGTH (bitify l v) = LENGTH l + LENGTH v
</pre>

<DT><span class="strong">length_bitify_null</span>
<DD>
<pre>
|- âˆ€v l. LENGTH (bitify [] v) = LENGTH v
</pre>

<DT><span class="strong">length_shiftr</span>
<DD>
<pre>
|- âˆ€v n. LENGTH (shiftr v n) = LENGTH v âˆ’ n
</pre>

<DT><span class="strong">length_rev_count_list</span>
<DD>
<pre>
|- âˆ€n. LENGTH (rev_count_list n) = n
</pre>

<DT><span class="strong">length_w2v</span>
<DD>
<pre>
|- âˆ€w. LENGTH (w2v w) = dimindex (:Î±)
</pre>

<DT><span class="strong">length_rotate</span>
<DD>
<pre>
|- âˆ€v n. LENGTH (rotate v n) = LENGTH v
</pre>

<DT><span class="strong">el_rev_count_list</span>
<DD>
<pre>
|- âˆ€n i. i < n â‡’ (EL i (rev_count_list n) = n âˆ’ 1 âˆ’ i)
</pre>

<DT><span class="strong">el_zero_extend</span>
<DD>
<pre>
|- âˆ€n i v.
     EL i (zero_extend n v) â‡” n âˆ’ LENGTH v â‰¤ i âˆ§ EL (i âˆ’ (n âˆ’ LENGTH v)) v
</pre>

<DT><span class="strong">el_sign_extend</span>
<DD>
<pre>
|- âˆ€n i v.
     EL i (sign_extend n v) =
     if i < n âˆ’ LENGTH v then EL 0 v else EL (i âˆ’ (n âˆ’ LENGTH v)) v
</pre>

<DT><span class="strong">el_fixwidth</span>
<DD>
<pre>
|- âˆ€i n w.
     i < n â‡’
     (EL i (fixwidth n w) â‡”
      if LENGTH w < n then n âˆ’ LENGTH w â‰¤ i âˆ§ EL (i âˆ’ (n âˆ’ LENGTH w)) w
      else EL (i + (LENGTH w âˆ’ n)) w)
</pre>

<DT><span class="strong">el_field</span>
<DD>
<pre>
|- âˆ€v h l i.
     i < SUC h âˆ’ l â‡’
     (EL i (field h l v) â‡” SUC h â‰¤ i + LENGTH v âˆ§ EL (i + LENGTH v âˆ’ SUC h) v)
</pre>

<DT><span class="strong">el_w2v</span>
<DD>
<pre>
|- âˆ€w n. n < dimindex (:Î±) â‡’ (EL n (w2v w) â‡” w ' (dimindex (:Î±) âˆ’ 1 âˆ’ n))
</pre>

<DT><span class="strong">el_shiftr</span>
<DD>
<pre>
|- âˆ€i v n d.
     n < d âˆ§ i < d âˆ’ n âˆ§ 0 < d â‡’
     (EL i (shiftr (fixwidth d v) n) â‡”
      d â‰¤ i + LENGTH v âˆ§ EL (i + LENGTH v âˆ’ d) v)
</pre>

<DT><span class="strong">shiftr_0</span>
<DD>
<pre>
|- âˆ€v. shiftr v 0 = v
</pre>

<DT><span class="strong">field_fixwidth</span>
<DD>
<pre>
|- âˆ€h v. field h 0 v = fixwidth (SUC h) v
</pre>

<DT><span class="strong">testbit</span>
<DD>
<pre>
|- âˆ€b v. testbit b v â‡” (let n = LENGTH v in b < n âˆ§ EL (n âˆ’ 1 âˆ’ b) v)
</pre>

<DT><span class="strong">testbit_geq_len</span>
<DD>
<pre>
|- âˆ€v i. LENGTH v â‰¤ i â‡’ Â¬testbit i v
</pre>

<DT><span class="strong">testbit_el</span>
<DD>
<pre>
|- âˆ€v i. i < LENGTH v â‡’ (testbit i v â‡” EL (LENGTH v âˆ’ 1 âˆ’ i) v)
</pre>

<DT><span class="strong">bit_v2w</span>
<DD>
<pre>
|- âˆ€n v. word_bit n (v2w v) â‡” n < dimindex (:Î±) âˆ§ testbit n v
</pre>

<DT><span class="strong">word_index_v2w</span>
<DD>
<pre>
|- âˆ€v i.
     v2w v ' i â‡”
     if i < dimindex (:Î±) then testbit i v
     else FAIL $' index too large (v2w v) i
</pre>

<DT><span class="strong">testbit_w2v</span>
<DD>
<pre>
|- âˆ€n w. testbit n (w2v w) â‡” word_bit n w
</pre>

<DT><span class="strong">w2v_v2w</span>
<DD>
<pre>
|- âˆ€v. w2v (v2w v) = fixwidth (dimindex (:Î±)) v
</pre>

<DT><span class="strong">v2w_w2v</span>
<DD>
<pre>
|- âˆ€w. v2w (w2v w) = w
</pre>

<DT><span class="strong">v2w_fixwidth</span>
<DD>
<pre>
|- âˆ€v. v2w (fixwidth (dimindex (:Î±)) v) = v2w v
</pre>

<DT><span class="strong">fixwidth_fixwidth</span>
<DD>
<pre>
|- âˆ€n v. fixwidth n (fixwidth n v) = fixwidth n v
</pre>

<DT><span class="strong">bitstring_nchotomy</span>
<DD>
<pre>
|- âˆ€w. âˆƒv. w = v2w v
</pre>

<DT><span class="strong">ranged_bitstring_nchotomy</span>
<DD>
<pre>
|- âˆ€w. âˆƒv. (w = v2w v) âˆ§ Abbrev (LENGTH v = dimindex (:Î±))
</pre>

<DT><span class="strong">fixwidth_eq</span>
<DD>
<pre>
|- âˆ€n v w.
     (fixwidth n v = fixwidth n w) â‡” âˆ€i. i < n â‡’ (testbit i v â‡” testbit i w)
</pre>

<DT><span class="strong">v2w_11</span>
<DD>
<pre>
|- âˆ€v w.
     (v2w v = v2w w) â‡”
     (fixwidth (dimindex (:Î±)) v = fixwidth (dimindex (:Î±)) w)
</pre>

<DT><span class="strong">field_concat_right</span>
<DD>
<pre>
|- âˆ€h a b. (LENGTH b = SUC h) â‡’ (field h 0 (a ++ b) = b)
</pre>

<DT><span class="strong">field_concat_left</span>
<DD>
<pre>
|- âˆ€h l a b.
     l â‰¤ h âˆ§ LENGTH b â‰¤ l â‡’
     (field h l (a ++ b) = field (h âˆ’ LENGTH b) (l âˆ’ LENGTH b) a)
</pre>

<DT><span class="strong">field_id_imp</span>
<DD>
<pre>
|- âˆ€n v. (SUC n = LENGTH v) â‡’ (field n 0 v = v)
</pre>

<DT><span class="strong">shiftl_replicate_F</span>
<DD>
<pre>
|- âˆ€v n. shiftl v n = v ++ replicate [F] n
</pre>

<DT><span class="strong">word_lsb_v2w</span>
<DD>
<pre>
|- âˆ€v. word_lsb (v2w v) â‡” v â‰  [] âˆ§ LAST v
</pre>

<DT><span class="strong">word_msb_v2w</span>
<DD>
<pre>
|- âˆ€v. word_msb (v2w v) â‡” testbit (dimindex (:Î±) âˆ’ 1) v
</pre>

<DT><span class="strong">w2w_v2w</span>
<DD>
<pre>
|- âˆ€v.
     w2w (v2w v) =
     v2w
       (fixwidth
          (if dimindex (:Î²) < dimindex (:Î±) then dimindex (:Î²)
           else dimindex (:Î±)) v)
</pre>

<DT><span class="strong">sw2sw_v2w</span>
<DD>
<pre>
|- âˆ€v.
     sw2sw (v2w v) =
     if dimindex (:Î±) < dimindex (:Î²) then
       v2w (sign_extend (dimindex (:Î²)) (fixwidth (dimindex (:Î±)) v))
     else v2w (fixwidth (dimindex (:Î²)) v)
</pre>

<DT><span class="strong">n2w_v2n</span>
<DD>
<pre>
|- âˆ€v. n2w (v2n v) = v2w v
</pre>

<DT><span class="strong">v2n_n2v</span>
<DD>
<pre>
|- âˆ€n. v2n (n2v n) = n
</pre>

<DT><span class="strong">v2w_n2v</span>
<DD>
<pre>
|- âˆ€n. v2w (n2v n) = n2w n
</pre>

<DT><span class="strong">w2n_v2w</span>
<DD>
<pre>
|- âˆ€v. w2n (v2w v) = MOD_2EXP (dimindex (:Î±)) (v2n v)
</pre>

<DT><span class="strong">v2n_lt</span>
<DD>
<pre>
|- âˆ€v. v2n v < 2 ** LENGTH v
</pre>

<DT><span class="strong">word_and_v2w</span>
<DD>
<pre>
|- âˆ€v w. v2w v && v2w w = v2w (band v w)
</pre>

<DT><span class="strong">word_or_v2w</span>
<DD>
<pre>
|- âˆ€v w. v2w v â€– v2w w = v2w (bor v w)
</pre>

<DT><span class="strong">word_xor_v2w</span>
<DD>
<pre>
|- âˆ€v w. v2w v âŠ• v2w w = v2w (bxor v w)
</pre>

<DT><span class="strong">word_nand_v2w</span>
<DD>
<pre>
|- âˆ€v w.
     v2w v ~&& v2w w =
     v2w (bnand (fixwidth (dimindex (:Î±)) v) (fixwidth (dimindex (:Î±)) w))
</pre>

<DT><span class="strong">word_nor_v2w</span>
<DD>
<pre>
|- âˆ€v w.
     v2w v ~|| v2w w =
     v2w (bnor (fixwidth (dimindex (:Î±)) v) (fixwidth (dimindex (:Î±)) w))
</pre>

<DT><span class="strong">word_xnor_v2w</span>
<DD>
<pre>
|- âˆ€v w.
     v2w v ~?? v2w w =
     v2w (bxnor (fixwidth (dimindex (:Î±)) v) (fixwidth (dimindex (:Î±)) w))
</pre>

<DT><span class="strong">word_1comp_v2w</span>
<DD>
<pre>
|- âˆ€v. Â¬v2w v = v2w (bnot (fixwidth (dimindex (:Î±)) v))
</pre>

<DT><span class="strong">word_lsl_v2w</span>
<DD>
<pre>
|- âˆ€n v. v2w v â‰ª n = v2w (shiftl v n)
</pre>

<DT><span class="strong">word_lsr_v2w</span>
<DD>
<pre>
|- âˆ€n v. v2w v â‹™ n = v2w (shiftr (fixwidth (dimindex (:Î±)) v) n)
</pre>

<DT><span class="strong">word_modify_v2w</span>
<DD>
<pre>
|- âˆ€f v. word_modify f (v2w v) = v2w (modify f (fixwidth (dimindex (:Î±)) v))
</pre>

<DT><span class="strong">word_bits_v2w</span>
<DD>
<pre>
|- âˆ€h l v. (h -- l) (v2w v) = v2w (field h l (fixwidth (dimindex (:Î±)) v))
</pre>

<DT><span class="strong">word_extract_v2w</span>
<DD>
<pre>
|- âˆ€h l v. (h >< l) (v2w v) = w2w ((h -- l) (v2w v))
</pre>

<DT><span class="strong">word_slice_v2w</span>
<DD>
<pre>
|- âˆ€h l v.
     (h '' l) (v2w v) =
     v2w (shiftl (field h l (fixwidth (dimindex (:Î±)) v)) l)
</pre>

<DT><span class="strong">word_asr_v2w</span>
<DD>
<pre>
|- âˆ€n v.
     v2w v â‰« n =
     (let l = fixwidth (dimindex (:Î±)) v
      in
        v2w
          (sign_extend (dimindex (:Î±))
             (if dimindex (:Î±) â‰¤ n then [HD l] else shiftr l n)))
</pre>

<DT><span class="strong">word_ror_v2w</span>
<DD>
<pre>
|- âˆ€n v. v2w v â‡„ n = v2w (rotate (fixwidth (dimindex (:Î±)) v) n)
</pre>

<DT><span class="strong">word_reverse_v2w</span>
<DD>
<pre>
|- âˆ€v. word_reverse (v2w v) = v2w (REVERSE (fixwidth (dimindex (:Î±)) v))
</pre>

<DT><span class="strong">word_join_v2w</span>
<DD>
<pre>
|- âˆ€v1 v2.
     FINITE ğ•Œ(:Î±) âˆ§ FINITE ğ•Œ(:Î²) â‡’
     (word_join (v2w v1) (v2w v2) = v2w (v1 ++ fixwidth (dimindex (:Î²)) v2))
</pre>

<DT><span class="strong">word_concat_v2w</span>
<DD>
<pre>
|- âˆ€v1 v2.
     FINITE ğ•Œ(:Î±) âˆ§ FINITE ğ•Œ(:Î²) â‡’
     (v2w v1 @@ v2w v2 =
      v2w
        (fixwidth (MIN (dimindex (:Î³)) (dimindex (:Î±) + dimindex (:Î²)))
           (v1 ++ fixwidth (dimindex (:Î²)) v2)))
</pre>

<DT><span class="strong">word_join_v2w_rwt</span>
<DD>
<pre>
|- âˆ€v1 v2.
     word_join (v2w v1) (v2w v2) =
     if FINITE ğ•Œ(:Î±) âˆ§ FINITE ğ•Œ(:Î²) then
       v2w (v1 ++ fixwidth (dimindex (:Î²)) v2)
     else FAIL word_join bad domain (v2w v1) (v2w v2)
</pre>

<DT><span class="strong">word_concat_v2w_rwt</span>
<DD>
<pre>
|- âˆ€v1 v2.
     v2w v1 @@ v2w v2 =
     if FINITE ğ•Œ(:Î±) âˆ§ FINITE ğ•Œ(:Î²) then
       v2w
         (fixwidth (MIN (dimindex (:Î³)) (dimindex (:Î±) + dimindex (:Î²)))
            (v1 ++ fixwidth (dimindex (:Î²)) v2))
     else FAIL $@@ bad domain (v2w v1) (v2w v2)
</pre>

<DT><span class="strong">word_reduce_v2w</span>
<DD>
<pre>
|- âˆ€f v.
     word_reduce f (v2w v) =
     (let l = fixwidth (dimindex (:Î±)) v in v2w [FOLDL f (HD l) (TL l)])
</pre>

<DT><span class="strong">reduce_and_v2w</span>
<DD>
<pre>
|- âˆ€v. reduce_and (v2w v) = word_reduce $/\ (v2w v)
</pre>

<DT><span class="strong">reduce_or_v2w</span>
<DD>
<pre>
|- âˆ€v. reduce_or (v2w v) = word_reduce $\/ (v2w v)
</pre>

<DT><span class="strong">extract_v2w</span>
<DD>
<pre>
|- âˆ€h l v.
     LENGTH v â‰¤ dimindex (:Î±) âˆ§ (dimindex (:Î²) = SUC h âˆ’ l) âˆ§
     dimindex (:Î²) < dimindex (:Î±) â‡’
     ((h >< l) (v2w v) = v2w (field h l v))
</pre>

<DT><span class="strong">word_bit_last_shiftr</span>
<DD>
<pre>
|- âˆ€i v.
     i < dimindex (:Î±) â‡’
     (word_bit i (v2w v) â‡” (let l = shiftr v i in Â¬NULL l âˆ§ LAST l))
</pre>

<DT><span class="strong">ops_to_v2w</span>
<DD>
<pre>
|- (âˆ€v n. v2w v â€– n2w n = v2w v â€– v2w (n2v n)) âˆ§
   (âˆ€v n. n2w n â€– v2w v = v2w (n2v n) â€– v2w v) âˆ§
   (âˆ€v n. v2w v && n2w n = v2w v && v2w (n2v n)) âˆ§
   (âˆ€v n. n2w n && v2w v = v2w (n2v n) && v2w v) âˆ§
   (âˆ€v n. v2w v âŠ• n2w n = v2w v âŠ• v2w (n2v n)) âˆ§
   (âˆ€v n. n2w n âŠ• v2w v = v2w (n2v n) âŠ• v2w v) âˆ§
   (âˆ€v n. v2w v ~|| n2w n = v2w v ~|| v2w (n2v n)) âˆ§
   (âˆ€v n. n2w n ~|| v2w v = v2w (n2v n) ~|| v2w v) âˆ§
   (âˆ€v n. v2w v ~&& n2w n = v2w v ~&& v2w (n2v n)) âˆ§
   (âˆ€v n. n2w n ~&& v2w v = v2w (n2v n) ~&& v2w v) âˆ§
   (âˆ€v n. v2w v ~?? n2w n = v2w v ~?? v2w (n2v n)) âˆ§
   (âˆ€v n. n2w n ~?? v2w v = v2w (n2v n) ~?? v2w v) âˆ§
   (âˆ€v n. v2w v @@ n2w n = v2w v @@ v2w (n2v n)) âˆ§
   (âˆ€v n. n2w n @@ v2w v = v2w (n2v n) @@ v2w v) âˆ§
   (âˆ€v n. word_join (v2w v) (n2w n) = word_join (v2w v) (v2w (n2v n))) âˆ§
   âˆ€v n. word_join (n2w n) (v2w v) = word_join (v2w (n2v n)) (v2w v)
</pre>

<DT><span class="strong">ops_to_n2w</span>
<DD>
<pre>
|- (âˆ€v. -v2w v = -n2w (v2n v)) âˆ§
   (âˆ€v. word_log2 (v2w v) = word_log2 (n2w (v2n v))) âˆ§
   (âˆ€v n. (v2w v = n2w n) â‡” (n2w (v2n v) = n2w n)) âˆ§
   (âˆ€v n. (n2w n = v2w v) â‡” (n2w n = n2w (v2n v))) âˆ§
   (âˆ€v w. v2w v + w = n2w (v2n v) + w) âˆ§ (âˆ€v w. w + v2w v = w + n2w (v2n v)) âˆ§
   (âˆ€v w. v2w v âˆ’ w = n2w (v2n v) âˆ’ w) âˆ§ (âˆ€v w. w âˆ’ v2w v = w âˆ’ n2w (v2n v)) âˆ§
   (âˆ€v w. v2w v * w = n2w (v2n v) * w) âˆ§ (âˆ€v w. w * v2w v = w * n2w (v2n v)) âˆ§
   (âˆ€v w. v2w v / w = n2w (v2n v) / w) âˆ§ (âˆ€v w. w / v2w v = w / n2w (v2n v)) âˆ§
   (âˆ€v w. v2w v // w = n2w (v2n v) // w) âˆ§
   (âˆ€v w. w // v2w v = w // n2w (v2n v)) âˆ§
   (âˆ€v w. word_mod (v2w v) w = word_mod (n2w (v2n v)) w) âˆ§
   (âˆ€v w. word_mod w (v2w v) = word_mod w (n2w (v2n v))) âˆ§
   (âˆ€v w. v2w v < w â‡” n2w (v2n v) < w) âˆ§ (âˆ€v w. w < v2w v â‡” w < n2w (v2n v)) âˆ§
   (âˆ€v w. v2w v > w â‡” n2w (v2n v) > w) âˆ§ (âˆ€v w. w > v2w v â‡” w > n2w (v2n v)) âˆ§
   (âˆ€v w. v2w v â‰¤ w â‡” n2w (v2n v) â‰¤ w) âˆ§ (âˆ€v w. w â‰¤ v2w v â‡” w â‰¤ n2w (v2n v)) âˆ§
   (âˆ€v w. v2w v â‰¥ w â‡” n2w (v2n v) â‰¥ w) âˆ§ (âˆ€v w. w â‰¥ v2w v â‡” w â‰¥ n2w (v2n v)) âˆ§
   (âˆ€v w. v2w v <â‚Š w â‡” n2w (v2n v) <â‚Š w) âˆ§
   (âˆ€v w. w <â‚Š v2w v â‡” w <â‚Š n2w (v2n v)) âˆ§
   (âˆ€v w. v2w v >â‚Š w â‡” n2w (v2n v) >â‚Š w) âˆ§
   (âˆ€v w. w >â‚Š v2w v â‡” w >â‚Š n2w (v2n v)) âˆ§
   (âˆ€v w. v2w v â‰¤â‚Š w â‡” n2w (v2n v) â‰¤â‚Š w) âˆ§
   (âˆ€v w. w â‰¤â‚Š v2w v â‡” w â‰¤â‚Š n2w (v2n v)) âˆ§
   (âˆ€v w. v2w v â‰¥â‚Š w â‡” n2w (v2n v) â‰¥â‚Š w) âˆ§ âˆ€v w. w â‰¥â‚Š v2w v â‡” w â‰¥â‚Š n2w (v2n v)
</pre>

</DL>



<hr>
</body>
</html>
