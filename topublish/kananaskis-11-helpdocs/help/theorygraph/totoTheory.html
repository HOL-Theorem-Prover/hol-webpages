<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><link rel="icon" href="../../../images/logo.ico" type="image/vnd.microsoft.icon"><title>Theory: toto</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "toto"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "wotTheory.html"><span class="strong">wot</span></a>&nbsp;&nbsp;
    <a href = "stringTheory.html"><span class="strong">string</span></a>

<h1>Signature</h1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr> <th> Type <th> Arity<tr><td> <span class="strong">cpn</span> <td> 0
    <tr><td> <span class="strong">num_dt</span> <td> 0
    <tr><td> <span class="strong">toto</span> <td> 1
    <tr>
    <th>
    Constant
    <th>
    Type<tr><td> <span class="strong">EQUAL</span> <td> :cpn
    <tr><td> <span class="strong">GREATER</span> <td> :cpn
    <tr><td> <span class="strong">LESS</span> <td> :cpn
    <tr><td> <span class="strong">ListOrd</span> <td> :α toto -> α list comp
    <tr><td>
        <span class="strong">StrongLinearOrder_of_TO</span>
        <td>
        :α comp -> α toto$reln
    <tr><td> <span class="strong">TO</span> <td> :α comp -> α toto
    <tr><td> <span class="strong">TO_inv</span> <td> :α comp -> α comp
    <tr><td>
        <span class="strong">TO_of_LinearOrder</span>
        <td>
        :α toto$reln -> α comp
    <tr><td> <span class="strong">TotOrd</span> <td> :α comp -> bool
    <tr><td>
        <span class="strong">WeakLinearOrder_of_TO</span>
        <td>
        :α comp -> α toto$reln
    <tr><td> <span class="strong">apto</span> <td> :α toto -> α comp
    <tr><td> <span class="strong">bit1</span> <td> :num_dt -> num_dt
    <tr><td> <span class="strong">bit2</span> <td> :num_dt -> num_dt
    <tr><td> <span class="strong">charOrd</span> <td> :char comp
    <tr><td> <span class="strong">charto</span> <td> :char toto
    <tr><td> <span class="strong">cpn2num</span> <td> :cpn -> num
    <tr><td>
        <span class="strong">cpn_CASE</span>
        <td>
        :cpn -> α -> α -> α -> α
    <tr><td> <span class="strong">cpn_size</span> <td> :cpn -> num
    <tr><td>
        <span class="strong">imageOrd</span>
        <td>
        :(α -> γ) -> γ comp -> α comp
    <tr><td>
        <span class="strong">lexTO</span>
        <td>
        :α comp -> β comp -> (α # β) comp
    <tr><td>
        <span class="strong">lextoto</span>
        <td>
        :α toto -> β toto -> (α # β) toto
    <tr><td>
        <span class="strong">listorder</span>
        <td>
        :α toto$reln -> α list toto$reln
    <tr><td>
        <span class="strong">listorder_tupled</span>
        <td>
        :α toto$reln # α list # α list -> bool
    <tr><td> <span class="strong">listoto</span> <td> :α toto -> α list toto
    <tr><td> <span class="strong">num2cpn</span> <td> :num -> cpn
    <tr><td> <span class="strong">numOrd</span> <td> :num comp
    <tr><td> <span class="strong">num_dtOrd</span> <td> :num_dt comp
    <tr><td>
        <span class="strong">num_dtOrd_tupled</span>
        <td>
        :num_dt # num_dt -> cpn
    <tr><td>
        <span class="strong">num_dt_CASE</span>
        <td>
        :num_dt -> α -> (num_dt -> α) -> (num_dt -> α) -> α
    <tr><td> <span class="strong">num_dt_size</span> <td> :num_dt -> num
    <tr><td> <span class="strong">num_to_dt</span> <td> :num -> num_dt
    <tr><td> <span class="strong">numto</span> <td> :num toto
    <tr><td> <span class="strong">qk_numOrd</span> <td> :num comp
    <tr><td> <span class="strong">qk_numto</span> <td> :num toto
    <tr><td> <span class="strong">stringto</span> <td> :string toto
    <tr><td> <span class="strong">toto_inv</span> <td> :α toto -> α toto
    <tr><td>
        <span class="strong">toto_of_LinearOrder</span>
        <td>
        :α toto$reln -> α toto
    <tr><td> <span class="strong">zer</span> <td> :num_dt

</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">cpn_TY_DEF</span>
<DD>
<pre>
|- ∃rep. TYPE_DEFINITION (λn. n < 3) rep
</pre>

<DT><span class="strong">cpn_BIJ</span>
<DD>
<pre>
|- (∀a. num2cpn (cpn2num a) = a) ∧
   ∀r. (λn. n < 3) r ⇔ (cpn2num (num2cpn r) = r)
</pre>

<DT><span class="strong">cpn_size_def</span>
<DD>
<pre>
|- ∀x. cpn_size x = 0
</pre>

<DT><span class="strong">cpn_CASE</span>
<DD>
<pre>
|- ∀x v0 v1 v2.
     (case x of Less => v0 | Equal => v1 | Greater => v2) =
     (λm. if m < 1 then v0 else if m = 1 then v1 else v2) (cpn2num x)
</pre>

<DT><span class="strong">TotOrd</span>
<DD>
<pre>
|- ∀c.
     TotOrd c ⇔
     (∀x y. (c x y = Equal) ⇔ (x = y)) ∧
     (∀x y. (c x y = Greater) ⇔ (c y x = Less)) ∧
     ∀x y z. (c x y = Less) ∧ (c y z = Less) ⇒ (c x z = Less)
</pre>

<DT><span class="strong">TO_of_LinearOrder</span>
<DD>
<pre>
|- ∀r x y.
     TO_of_LinearOrder r x y =
     if x = y then Equal else if r x y then Less else Greater
</pre>

<DT><span class="strong">toto_TY_DEF</span>
<DD>
<pre>
|- ∃rep. TYPE_DEFINITION TotOrd rep
</pre>

<DT><span class="strong">to_bij</span>
<DD>
<pre>
|- (∀a. TO (apto a) = a) ∧ ∀r. TotOrd r ⇔ (apto (TO r) = r)
</pre>

<DT><span class="strong">WeakLinearOrder_of_TO</span>
<DD>
<pre>
|- ∀c x y.
     WeakLinearOrder_of_TO c x y ⇔
     case c x y of Less => T | Equal => T | Greater => F
</pre>

<DT><span class="strong">StrongLinearOrder_of_TO</span>
<DD>
<pre>
|- ∀c x y.
     StrongLinearOrder_of_TO c x y ⇔
     case c x y of Less => T | Equal => F | Greater => F
</pre>

<DT><span class="strong">toto_of_LinearOrder</span>
<DD>
<pre>
|- ∀r. toto_of_LinearOrder r = TO (TO_of_LinearOrder r)
</pre>

<DT><span class="strong">TO_inv</span>
<DD>
<pre>
|- ∀c x y. TO_inv c x y = c y x
</pre>

<DT><span class="strong">toto_inv</span>
<DD>
<pre>
|- ∀c. toto_inv c = TO (TO_inv (apto c))
</pre>

<DT><span class="strong">lexTO</span>
<DD>
<pre>
|- ∀R V.
     R lexTO V =
     TO_of_LinearOrder
       (StrongLinearOrder_of_TO R LEX StrongLinearOrder_of_TO V)
</pre>

<DT><span class="strong">lextoto</span>
<DD>
<pre>
|- ∀c v. c lextoto v = TO (apto c lexTO apto v)
</pre>

<DT><span class="strong">numOrd</span>
<DD>
<pre>
|- numOrd = TO_of_LinearOrder $<
</pre>

<DT><span class="strong">numto</span>
<DD>
<pre>
|- numto = TO numOrd
</pre>

<DT><span class="strong">num_dt_TY_DEF</span>
<DD>
<pre>
|- ∃rep.
     TYPE_DEFINITION
       (λa0.
          ∀'num_dt' .
            (∀a0.
               (a0 = ind_type$CONSTR 0 ARB (λn. ind_type$BOTTOM)) ∨
               (∃a.
                  (a0 =
                   (λa.
                      ind_type$CONSTR (SUC 0) ARB
                        (ind_type$FCONS a (λn. ind_type$BOTTOM))) a) ∧
                  'num_dt' a) ∨
               (∃a.
                  (a0 =
                   (λa.
                      ind_type$CONSTR (SUC (SUC 0)) ARB
                        (ind_type$FCONS a (λn. ind_type$BOTTOM))) a) ∧
                  'num_dt' a) ⇒
               'num_dt' a0) ⇒
            'num_dt' a0) rep
</pre>

<DT><span class="strong">num_dt_case_def</span>
<DD>
<pre>
|- (∀v f f1. num_dt_CASE zer v f f1 = v) ∧
   (∀a v f f1. num_dt_CASE (bit1 a) v f f1 = f a) ∧
   ∀a v f f1. num_dt_CASE (bit2 a) v f f1 = f1 a
</pre>

<DT><span class="strong">num_dt_size_def</span>
<DD>
<pre>
|- (num_dt_size zer = 0) ∧ (∀a. num_dt_size (bit1 a) = 1 + num_dt_size a) ∧
   ∀a. num_dt_size (bit2 a) = 1 + num_dt_size a
</pre>

<DT><span class="strong">num_to_dt_primitive</span>
<DD>
<pre>
|- num_to_dt =
   WFREC
     (@R.
        WF R ∧ (∀n. n ≠ 0 ∧ ODD n ⇒ R (DIV2 (n − 1)) n) ∧
        ∀n. n ≠ 0 ∧ ¬ODD n ⇒ R (DIV2 (n − 2)) n)
     (λnum_to_dt n.
        I
          (if n = 0 then zer
           else if ODD n then bit1 (num_to_dt (DIV2 (n − 1)))
           else bit2 (num_to_dt (DIV2 (n − 2)))))
</pre>

<DT><span class="strong">num_dtOrd_tupled_primitive</span>
<DD>
<pre>
|- num_dtOrd_tupled =
   WFREC
     (@R.
        WF R ∧ (∀y x. R (x,y) (bit1 x,bit1 y)) ∧
        ∀y x. R (x,y) (bit2 x,bit2 y))
     (λnum_dtOrd_tupled a.
        case a of
          (zer,zer) => I Equal
        | (zer,bit1 x) => I Less
        | (zer,bit2 x') => I Less
        | (bit1 x'',zer) => I Greater
        | (bit1 x'',bit1 y'') => I (num_dtOrd_tupled (x'',y''))
        | (bit1 x'',bit2 y) => I Less
        | (bit2 x''',zer) => I Greater
        | (bit2 x''',bit1 y') => I Greater
        | (bit2 x''',bit2 y''') => I (num_dtOrd_tupled (x''',y''')))
</pre>

<DT><span class="strong">num_dtOrd_curried</span>
<DD>
<pre>
|- ∀x x1. num_dtOrd x x1 = num_dtOrd_tupled (x,x1)
</pre>

<DT><span class="strong">qk_numOrd_def</span>
<DD>
<pre>
|- ∀m n. qk_numOrd m n = num_dtOrd (num_to_dt m) (num_to_dt n)
</pre>

<DT><span class="strong">qk_numto</span>
<DD>
<pre>
|- qk_numto = TO qk_numOrd
</pre>

<DT><span class="strong">charOrd</span>
<DD>
<pre>
|- ∀a b. charOrd a b = numOrd (ORD a) (ORD b)
</pre>

<DT><span class="strong">charto</span>
<DD>
<pre>
|- charto = TO charOrd
</pre>

<DT><span class="strong">listorder_tupled_primitive</span>
<DD>
<pre>
|- listorder_tupled =
   WFREC (@R. WF R ∧ ∀s r m l V. R (V,l,m) (V,r::l,s::m))
     (λlistorder_tupled a.
        case a of
          (V,l,[]) => I F
        | (V,[],s::m) => I T
        | (V,r::l',s::m) => I (V r s ∨ (r = s) ∧ listorder_tupled (V,l',m)))
</pre>

<DT><span class="strong">listorder_curried</span>
<DD>
<pre>
|- ∀x x1 x2. listorder x x1 x2 ⇔ listorder_tupled (x,x1,x2)
</pre>

<DT><span class="strong">ListOrd</span>
<DD>
<pre>
|- ∀c.
     ListOrd c =
     TO_of_LinearOrder (listorder (StrongLinearOrder_of_TO (apto c)))
</pre>

<DT><span class="strong">listoto</span>
<DD>
<pre>
|- ∀c. listoto c = TO (ListOrd c)
</pre>

<DT><span class="strong">stringto</span>
<DD>
<pre>
|- stringto = listoto charto
</pre>

<DT><span class="strong">imageOrd</span>
<DD>
<pre>
|- ∀f cp a b. imageOrd f cp a b = cp (f a) (f b)
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">StrongLinearOrderExists</span>
<DD>
<pre>
|- ∃R. StrongLinearOrder R
</pre>

<DT><span class="strong">num2cpn_cpn2num</span>
<DD>
<pre>
|- ∀a. num2cpn (cpn2num a) = a
</pre>

<DT><span class="strong">cpn2num_num2cpn</span>
<DD>
<pre>
|- ∀r. r < 3 ⇔ (cpn2num (num2cpn r) = r)
</pre>

<DT><span class="strong">num2cpn_11</span>
<DD>
<pre>
|- ∀r r'. r < 3 ⇒ r' < 3 ⇒ ((num2cpn r = num2cpn r') ⇔ (r = r'))
</pre>

<DT><span class="strong">cpn2num_11</span>
<DD>
<pre>
|- ∀a a'. (cpn2num a = cpn2num a') ⇔ (a = a')
</pre>

<DT><span class="strong">num2cpn_ONTO</span>
<DD>
<pre>
|- ∀a. ∃r. (a = num2cpn r) ∧ r < 3
</pre>

<DT><span class="strong">cpn2num_ONTO</span>
<DD>
<pre>
|- ∀r. r < 3 ⇔ ∃a. r = cpn2num a
</pre>

<DT><span class="strong">num2cpn_thm</span>
<DD>
<pre>
|- (num2cpn 0 = Less) ∧ (num2cpn 1 = Equal) ∧ (num2cpn 2 = Greater)
</pre>

<DT><span class="strong">cpn2num_thm</span>
<DD>
<pre>
|- (cpn2num Less = 0) ∧ (cpn2num Equal = 1) ∧ (cpn2num Greater = 2)
</pre>

<DT><span class="strong">cpn_EQ_cpn</span>
<DD>
<pre>
|- ∀a a'. (a = a') ⇔ (cpn2num a = cpn2num a')
</pre>

<DT><span class="strong">cpn_case_def</span>
<DD>
<pre>
|- (∀v0 v1 v2. (case Less of Less => v0 | Equal => v1 | Greater => v2) = v0) ∧
   (∀v0 v1 v2.
      (case Equal of Less => v0 | Equal => v1 | Greater => v2) = v1) ∧
   ∀v0 v1 v2. (case Greater of Less => v0 | Equal => v1 | Greater => v2) = v2
</pre>

<DT><span class="strong">datatype_cpn</span>
<DD>
<pre>
|- DATATYPE (cpn Less Equal Greater)
</pre>

<DT><span class="strong">cpn_distinct</span>
<DD>
<pre>
|- Less ≠ Equal ∧ Less ≠ Greater ∧ Equal ≠ Greater
</pre>

<DT><span class="strong">cpn_case_cong</span>
<DD>
<pre>
|- ∀M M' v0 v1 v2.
     (M = M') ∧ ((M' = Less) ⇒ (v0 = v0')) ∧ ((M' = Equal) ⇒ (v1 = v1')) ∧
     ((M' = Greater) ⇒ (v2 = v2')) ⇒
     ((case M of Less => v0 | Equal => v1 | Greater => v2) =
      case M' of Less => v0' | Equal => v1' | Greater => v2')
</pre>

<DT><span class="strong">cpn_nchotomy</span>
<DD>
<pre>
|- ∀a. (a = Less) ∨ (a = Equal) ∨ (a = Greater)
</pre>

<DT><span class="strong">cpn_Axiom</span>
<DD>
<pre>
|- ∀x0 x1 x2. ∃f. (f Less = x0) ∧ (f Equal = x1) ∧ (f Greater = x2)
</pre>

<DT><span class="strong">cpn_induction</span>
<DD>
<pre>
|- ∀P. P Equal ∧ P Greater ∧ P Less ⇒ ∀a. P a
</pre>

<DT><span class="strong">trichotomous_ALT</span>
<DD>
<pre>
|- ∀R. trichotomous R ⇔ ∀x y. ¬R x y ∧ ¬R y x ⇒ (x = y)
</pre>

<DT><span class="strong">TotOrd_TO_of_LO</span>
<DD>
<pre>
|- ∀r. LinearOrder r ⇒ TotOrd (TO_of_LinearOrder r)
</pre>

<DT><span class="strong">SPLIT_PAIRS</span>
<DD>
<pre>
|- ∀x y. (x = y) ⇔ (FST x = FST y) ∧ (SND x = SND y)
</pre>

<DT><span class="strong">all_cpn_distinct</span>
<DD>
<pre>
|- (Less ≠ Equal ∧ Less ≠ Greater ∧ Equal ≠ Greater) ∧ Equal ≠ Less ∧
   Greater ≠ Less ∧ Greater ≠ Equal
</pre>

<DT><span class="strong">TO_exists</span>
<DD>
<pre>
|- ∃x. TotOrd x
</pre>

<DT><span class="strong">TO_apto_ID</span>
<DD>
<pre>
|- ∀a. TO (apto a) = a
</pre>

<DT><span class="strong">TO_apto_TO_ID</span>
<DD>
<pre>
|- ∀r. TotOrd r ⇔ (apto (TO r) = r)
</pre>

<DT><span class="strong">TO_11</span>
<DD>
<pre>
|- ∀r r'. TotOrd r ⇒ TotOrd r' ⇒ ((TO r = TO r') ⇔ (r = r'))
</pre>

<DT><span class="strong">onto_apto</span>
<DD>
<pre>
|- ∀r. TotOrd r ⇔ ∃a. r = apto a
</pre>

<DT><span class="strong">TO_onto</span>
<DD>
<pre>
|- ∀a. ∃r. (a = TO r) ∧ TotOrd r
</pre>

<DT><span class="strong">TotOrd_apto</span>
<DD>
<pre>
|- ∀c. TotOrd (apto c)
</pre>

<DT><span class="strong">TO_apto_TO_IMP</span>
<DD>
<pre>
|- ∀r. TotOrd r ⇒ (apto (TO r) = r)
</pre>

<DT><span class="strong">toto_thm</span>
<DD>
<pre>
|- ∀c.
     (∀x y. (apto c x y = Equal) ⇔ (x = y)) ∧
     (∀x y. (apto c x y = Greater) ⇔ (apto c y x = Less)) ∧
     ∀x y z. (apto c x y = Less) ∧ (apto c y z = Less) ⇒ (apto c x z = Less)
</pre>

<DT><span class="strong">TO_equal_eq</span>
<DD>
<pre>
|- ∀c. TotOrd c ⇒ ∀x y. (c x y = Equal) ⇔ (x = y)
</pre>

<DT><span class="strong">toto_equal_eq</span>
<DD>
<pre>
|- ∀c x y. (apto c x y = Equal) ⇔ (x = y)
</pre>

<DT><span class="strong">toto_equal_imp_eq</span>
<DD>
<pre>
|- ∀c x y. (apto c x y = Equal) ⇒ (x = y)
</pre>

<DT><span class="strong">TO_refl</span>
<DD>
<pre>
|- ∀c. TotOrd c ⇒ ∀x. c x x = Equal
</pre>

<DT><span class="strong">toto_refl</span>
<DD>
<pre>
|- ∀c x. apto c x x = Equal
</pre>

<DT><span class="strong">toto_equal_sym</span>
<DD>
<pre>
|- ∀c x y. (apto c x y = Equal) ⇔ (apto c y x = Equal)
</pre>

<DT><span class="strong">TO_antisym</span>
<DD>
<pre>
|- ∀c. TotOrd c ⇒ ∀x y. (c x y = Greater) ⇔ (c y x = Less)
</pre>

<DT><span class="strong">toto_antisym</span>
<DD>
<pre>
|- ∀c x y. (apto c x y = Greater) ⇔ (apto c y x = Less)
</pre>

<DT><span class="strong">toto_not_less_refl</span>
<DD>
<pre>
|- ∀cmp h. (apto cmp h h = Less) ⇔ F
</pre>

<DT><span class="strong">toto_swap_cases</span>
<DD>
<pre>
|- ∀c x y.
     apto c y x =
     case apto c x y of Less => Greater | Equal => Equal | Greater => Less
</pre>

<DT><span class="strong">toto_glneq</span>
<DD>
<pre>
|- (∀c x y. (apto c x y = Less) ⇒ x ≠ y) ∧
   ∀c x y. (apto c x y = Greater) ⇒ x ≠ y
</pre>

<DT><span class="strong">toto_cpn_eqn</span>
<DD>
<pre>
|- (∀c x y. (apto c x y = Equal) ⇒ (x = y)) ∧
   (∀c x y. (apto c x y = Less) ⇒ x ≠ y) ∧
   ∀c x y. (apto c x y = Greater) ⇒ x ≠ y
</pre>

<DT><span class="strong">TO_cpn_eqn</span>
<DD>
<pre>
|- ∀c.
     TotOrd c ⇒
     (∀x y. (c x y = Less) ⇒ x ≠ y) ∧ (∀x y. (c x y = Greater) ⇒ x ≠ y) ∧
     ∀x y. (c x y = Equal) ⇒ (x = y)
</pre>

<DT><span class="strong">NOT_EQ_LESS_IMP</span>
<DD>
<pre>
|- ∀cmp x y. apto cmp x y ≠ Less ⇒ (x = y) ∨ (apto cmp y x = Less)
</pre>

<DT><span class="strong">totoEEtrans</span>
<DD>
<pre>
|- ∀c x y z.
     ((apto c x y = Equal) ∧ (apto c y z = Equal) ⇒ (apto c x z = Equal)) ∧
     ((apto c x y = Equal) ∧ (apto c z y = Equal) ⇒ (apto c x z = Equal))
</pre>

<DT><span class="strong">totoLLtrans</span>
<DD>
<pre>
|- ∀c x y z. (apto c x y = Less) ∧ (apto c y z = Less) ⇒ (apto c x z = Less)
</pre>

<DT><span class="strong">totoLGtrans</span>
<DD>
<pre>
|- ∀c x y z.
     (apto c x y = Less) ∧ (apto c z y = Greater) ⇒ (apto c x z = Less)
</pre>

<DT><span class="strong">totoGGtrans</span>
<DD>
<pre>
|- ∀c x y z.
     (apto c y x = Greater) ∧ (apto c z y = Greater) ⇒ (apto c x z = Less)
</pre>

<DT><span class="strong">totoGLtrans</span>
<DD>
<pre>
|- ∀c x y z.
     (apto c y x = Greater) ∧ (apto c y z = Less) ⇒ (apto c x z = Less)
</pre>

<DT><span class="strong">totoLEtrans</span>
<DD>
<pre>
|- ∀c x y z. (apto c x y = Less) ∧ (apto c y z = Equal) ⇒ (apto c x z = Less)
</pre>

<DT><span class="strong">totoELtrans</span>
<DD>
<pre>
|- ∀c x y z. (apto c x y = Equal) ∧ (apto c y z = Less) ⇒ (apto c x z = Less)
</pre>

<DT><span class="strong">toto_trans_less</span>
<DD>
<pre>
|- (∀c x y z.
      (apto c x y = Less) ∧ (apto c y z = Less) ⇒ (apto c x z = Less)) ∧
   (∀c x y z.
      (apto c x y = Less) ∧ (apto c z y = Greater) ⇒ (apto c x z = Less)) ∧
   (∀c x y z.
      (apto c y x = Greater) ∧ (apto c z y = Greater) ⇒ (apto c x z = Less)) ∧
   (∀c x y z.
      (apto c y x = Greater) ∧ (apto c y z = Less) ⇒ (apto c x z = Less)) ∧
   (∀c x y z.
      (apto c x y = Less) ∧ (apto c y z = Equal) ⇒ (apto c x z = Less)) ∧
   ∀c x y z. (apto c x y = Equal) ∧ (apto c y z = Less) ⇒ (apto c x z = Less)
</pre>

<DT><span class="strong">Weak_Weak_of</span>
<DD>
<pre>
|- ∀c. WeakLinearOrder (WeakLinearOrder_of_TO (apto c))
</pre>

<DT><span class="strong">STRORD_SLO</span>
<DD>
<pre>
|- ∀R. WeakLinearOrder R ⇒ StrongLinearOrder (STRORD R)
</pre>

<DT><span class="strong">Strongof_toto_STRORD</span>
<DD>
<pre>
|- ∀c.
     StrongLinearOrder_of_TO (apto c) =
     STRORD (WeakLinearOrder_of_TO (apto c))
</pre>

<DT><span class="strong">Strong_Strong_of</span>
<DD>
<pre>
|- ∀c. StrongLinearOrder (StrongLinearOrder_of_TO (apto c))
</pre>

<DT><span class="strong">Strong_Strong_of_TO</span>
<DD>
<pre>
|- ∀c. TotOrd c ⇒ StrongLinearOrder (StrongLinearOrder_of_TO c)
</pre>

<DT><span class="strong">TotOrd_TO_of_Weak</span>
<DD>
<pre>
|- ∀r. WeakLinearOrder r ⇒ TotOrd (TO_of_LinearOrder r)
</pre>

<DT><span class="strong">TotOrd_TO_of_Strong</span>
<DD>
<pre>
|- ∀r. StrongLinearOrder r ⇒ TotOrd (TO_of_LinearOrder r)
</pre>

<DT><span class="strong">toto_Weak_thm</span>
<DD>
<pre>
|- ∀c. toto_of_LinearOrder (WeakLinearOrder_of_TO (apto c)) = c
</pre>

<DT><span class="strong">toto_Strong_thm</span>
<DD>
<pre>
|- ∀c. toto_of_LinearOrder (StrongLinearOrder_of_TO (apto c)) = c
</pre>

<DT><span class="strong">Weak_toto_thm</span>
<DD>
<pre>
|- ∀r.
     WeakLinearOrder r ⇒
     (WeakLinearOrder_of_TO (apto (toto_of_LinearOrder r)) = r)
</pre>

<DT><span class="strong">Strong_toto_thm</span>
<DD>
<pre>
|- ∀r.
     StrongLinearOrder r ⇒
     (StrongLinearOrder_of_TO (apto (toto_of_LinearOrder r)) = r)
</pre>

<DT><span class="strong">TotOrd_inv</span>
<DD>
<pre>
|- ∀c. TotOrd c ⇒ TotOrd (TO_inv c)
</pre>

<DT><span class="strong">inv_TO</span>
<DD>
<pre>
|- ∀r. TotOrd r ⇒ (toto_inv (TO r) = TO (TO_inv r))
</pre>

<DT><span class="strong">apto_inv</span>
<DD>
<pre>
|- ∀c. apto (toto_inv c) = TO_inv (apto c)
</pre>

<DT><span class="strong">Weak_toto_inv</span>
<DD>
<pre>
|- ∀c.
     WeakLinearOrder_of_TO (apto (toto_inv c)) =
     inv (WeakLinearOrder_of_TO (apto c))
</pre>

<DT><span class="strong">Strong_toto_inv</span>
<DD>
<pre>
|- ∀c.
     StrongLinearOrder_of_TO (apto (toto_inv c)) =
     inv (StrongLinearOrder_of_TO (apto c))
</pre>

<DT><span class="strong">TO_inv_TO_inv</span>
<DD>
<pre>
|- ∀c. TO_inv (TO_inv c) = c
</pre>

<DT><span class="strong">toto_inv_toto_inv</span>
<DD>
<pre>
|- ∀c. toto_inv (toto_inv c) = c
</pre>

<DT><span class="strong">TO_inv_Ord</span>
<DD>
<pre>
|- ∀r. TO_of_LinearOrder (inv r) = TO_inv (TO_of_LinearOrder r)
</pre>

<DT><span class="strong">TO_of_less_rel</span>
<DD>
<pre>
|- ∀r. StrongLinearOrder r ⇒ ∀x y. (TO_of_LinearOrder r x y = Less) ⇔ r x y
</pre>

<DT><span class="strong">TO_of_greater_ler</span>
<DD>
<pre>
|- ∀r. StrongLinearOrder r ⇒ ∀x y. (TO_of_LinearOrder r x y = Greater) ⇔ r y x
</pre>

<DT><span class="strong">toto_equal_imp</span>
<DD>
<pre>
|- ∀cmp phi.
     LinearOrder phi ∧ (cmp = toto_of_LinearOrder phi) ⇒
     ∀x y. ((x = y) ⇔ T) ⇒ (apto cmp x y = Equal)
</pre>

<DT><span class="strong">toto_unequal_imp</span>
<DD>
<pre>
|- ∀cmp phi.
     LinearOrder phi ∧ (cmp = toto_of_LinearOrder phi) ⇒
     ∀x y.
       ((x = y) ⇔ F) ⇒
       if phi x y then apto cmp x y = Less else apto cmp x y = Greater
</pre>

<DT><span class="strong">StrongOrder_ALT</span>
<DD>
<pre>
|- ∀Z. StrongOrder Z ⇔ irreflexive Z ∧ transitive Z
</pre>

<DT><span class="strong">LEX_ALT</span>
<DD>
<pre>
|- ∀R U c d.
     (R LEX U) c d ⇔ R (FST c) (FST d) ∨ (FST c = FST d) ∧ U (SND c) (SND d)
</pre>

<DT><span class="strong">SLO_LEX</span>
<DD>
<pre>
|- ∀R V.
     StrongLinearOrder R ∧ StrongLinearOrder V ⇒ StrongLinearOrder (R LEX V)
</pre>

<DT><span class="strong">lexTO_thm</span>
<DD>
<pre>
|- ∀R V.
     TotOrd R ∧ TotOrd V ⇒
     ∀x y.
       (R lexTO V) x y =
       case R (FST x) (FST y) of
         Less => Less
       | Equal => V (SND x) (SND y)
       | Greater => Greater
</pre>

<DT><span class="strong">lexTO_ALT</span>
<DD>
<pre>
|- ∀R V.
     TotOrd R ∧ TotOrd V ⇒
     ∀(r,u) (r',u').
       (R lexTO V) (r,u) (r',u') =
       case R r r' of Less => Less | Equal => V u u' | Greater => Greater
</pre>

<DT><span class="strong">TO_lexTO</span>
<DD>
<pre>
|- ∀R V. TotOrd R ∧ TotOrd V ⇒ TotOrd (R lexTO V)
</pre>

<DT><span class="strong">pre_aplextoto</span>
<DD>
<pre>
|- ∀c v x y.
     apto (c lextoto v) x y =
     case apto c (FST x) (FST y) of
       Less => Less
     | Equal => apto v (SND x) (SND y)
     | Greater => Greater
</pre>

<DT><span class="strong">aplextoto</span>
<DD>
<pre>
|- ∀c v x1 x2 y1 y2.
     apto (c lextoto v) (x1,x2) (y1,y2) =
     case apto c x1 y1 of
       Less => Less
     | Equal => apto v x2 y2
     | Greater => Greater
</pre>

<DT><span class="strong">StrongLinearOrder_LESS</span>
<DD>
<pre>
|- StrongLinearOrder $<
</pre>

<DT><span class="strong">TO_numOrd</span>
<DD>
<pre>
|- TotOrd numOrd
</pre>

<DT><span class="strong">apnumto_thm</span>
<DD>
<pre>
|- apto numto = numOrd
</pre>

<DT><span class="strong">numeralOrd</span>
<DD>
<pre>
|- ∀x y.
     (numOrd ZERO ZERO = Equal) ∧ (numOrd ZERO (BIT1 y) = Less) ∧
     (numOrd ZERO (BIT2 y) = Less) ∧ (numOrd (BIT1 x) ZERO = Greater) ∧
     (numOrd (BIT2 x) ZERO = Greater) ∧
     (numOrd (BIT1 x) (BIT1 y) = numOrd x y) ∧
     (numOrd (BIT2 x) (BIT2 y) = numOrd x y) ∧
     (numOrd (BIT1 x) (BIT2 y) =
      case numOrd x y of Less => Less | Equal => Less | Greater => Greater) ∧
     (numOrd (BIT2 x) (BIT1 y) =
      case numOrd x y of Less => Less | Equal => Greater | Greater => Greater)
</pre>

<DT><span class="strong">datatype_num_dt</span>
<DD>
<pre>
|- DATATYPE (num_dt zer bit1 bit2)
</pre>

<DT><span class="strong">num_dt_11</span>
<DD>
<pre>
|- (∀a a'. (bit1 a = bit1 a') ⇔ (a = a')) ∧
   ∀a a'. (bit2 a = bit2 a') ⇔ (a = a')
</pre>

<DT><span class="strong">num_dt_distinct</span>
<DD>
<pre>
|- (∀a. zer ≠ bit1 a) ∧ (∀a. zer ≠ bit2 a) ∧ ∀a' a. bit1 a ≠ bit2 a'
</pre>

<DT><span class="strong">num_dt_case_cong</span>
<DD>
<pre>
|- ∀M M' v f f1.
     (M = M') ∧ ((M' = zer) ⇒ (v = v')) ∧ (∀a. (M' = bit1 a) ⇒ (f a = f' a)) ∧
     (∀a. (M' = bit2 a) ⇒ (f1 a = f1' a)) ⇒
     (num_dt_CASE M v f f1 = num_dt_CASE M' v' f' f1')
</pre>

<DT><span class="strong">num_dt_nchotomy</span>
<DD>
<pre>
|- ∀nn. (nn = zer) ∨ (∃n. nn = bit1 n) ∨ ∃n. nn = bit2 n
</pre>

<DT><span class="strong">num_dt_Axiom</span>
<DD>
<pre>
|- ∀f0 f1 f2.
     ∃fn.
       (fn zer = f0) ∧ (∀a. fn (bit1 a) = f1 a (fn a)) ∧
       ∀a. fn (bit2 a) = f2 a (fn a)
</pre>

<DT><span class="strong">num_dt_induction</span>
<DD>
<pre>
|- ∀P. P zer ∧ (∀n. P n ⇒ P (bit1 n)) ∧ (∀n. P n ⇒ P (bit2 n)) ⇒ ∀n. P n
</pre>

<DT><span class="strong">num_dtOrd_ind</span>
<DD>
<pre>
|- ∀P.
     P zer zer ∧ (∀x. P zer (bit1 x)) ∧ (∀x. P zer (bit2 x)) ∧
     (∀x. P (bit1 x) zer) ∧ (∀x. P (bit2 x) zer) ∧
     (∀x y. P (bit1 x) (bit2 y)) ∧ (∀x y. P (bit2 x) (bit1 y)) ∧
     (∀x y. P x y ⇒ P (bit1 x) (bit1 y)) ∧
     (∀x y. P x y ⇒ P (bit2 x) (bit2 y)) ⇒
     ∀v v1. P v v1
</pre>

<DT><span class="strong">num_dtOrd</span>
<DD>
<pre>
|- (num_dtOrd zer zer = Equal) ∧ (∀x. num_dtOrd zer (bit1 x) = Less) ∧
   (∀x. num_dtOrd zer (bit2 x) = Less) ∧
   (∀x. num_dtOrd (bit1 x) zer = Greater) ∧
   (∀x. num_dtOrd (bit2 x) zer = Greater) ∧
   (∀y x. num_dtOrd (bit1 x) (bit2 y) = Less) ∧
   (∀y x. num_dtOrd (bit2 x) (bit1 y) = Greater) ∧
   (∀y x. num_dtOrd (bit1 x) (bit1 y) = num_dtOrd x y) ∧
   ∀y x. num_dtOrd (bit2 x) (bit2 y) = num_dtOrd x y
</pre>

<DT><span class="strong">TO_qk_numOrd</span>
<DD>
<pre>
|- TotOrd qk_numOrd
</pre>

<DT><span class="strong">qk_numeralOrd</span>
<DD>
<pre>
|- ∀x y.
     (qk_numOrd ZERO ZERO = Equal) ∧ (qk_numOrd ZERO (BIT1 y) = Less) ∧
     (qk_numOrd ZERO (BIT2 y) = Less) ∧ (qk_numOrd (BIT1 x) ZERO = Greater) ∧
     (qk_numOrd (BIT2 x) ZERO = Greater) ∧
     (qk_numOrd (BIT1 x) (BIT1 y) = qk_numOrd x y) ∧
     (qk_numOrd (BIT2 x) (BIT2 y) = qk_numOrd x y) ∧
     (qk_numOrd (BIT1 x) (BIT2 y) = Less) ∧
     (qk_numOrd (BIT2 x) (BIT1 y) = Greater)
</pre>

<DT><span class="strong">ap_qk_numto_thm</span>
<DD>
<pre>
|- apto qk_numto = qk_numOrd
</pre>

<DT><span class="strong">TO_charOrd</span>
<DD>
<pre>
|- TotOrd charOrd
</pre>

<DT><span class="strong">apcharto_thm</span>
<DD>
<pre>
|- apto charto = charOrd
</pre>

<DT><span class="strong">charOrd_lt_lem</span>
<DD>
<pre>
|- ∀a b.
     (numOrd a b = Less) ⇒ (b < 256 ⇔ T) ⇒ (charOrd (CHR a) (CHR b) = Less)
</pre>

<DT><span class="strong">charOrd_gt_lem</span>
<DD>
<pre>
|- ∀a b.
     (numOrd a b = Greater) ⇒
     (a < 256 ⇔ T) ⇒
     (charOrd (CHR a) (CHR b) = Greater)
</pre>

<DT><span class="strong">charOrd_eq_lem</span>
<DD>
<pre>
|- ∀a b. (numOrd a b = Equal) ⇒ (charOrd (CHR a) (CHR b) = Equal)
</pre>

<DT><span class="strong">charOrd_thm</span>
<DD>
<pre>
|- charOrd = TO_of_LinearOrder $<
</pre>

<DT><span class="strong">listorder_ind</span>
<DD>
<pre>
|- ∀P.
     (∀V l. P V l []) ∧ (∀V s m. P V [] (s::m)) ∧
     (∀V r l s m. P V l m ⇒ P V (r::l) (s::m)) ⇒
     ∀v v1 v2. P v v1 v2
</pre>

<DT><span class="strong">listorder</span>
<DD>
<pre>
|- (∀l V. listorder V l [] ⇔ F) ∧ (∀s m V. listorder V [] (s::m) ⇔ T) ∧
   ∀s r m l V. listorder V (r::l) (s::m) ⇔ V r s ∨ (r = s) ∧ listorder V l m
</pre>

<DT><span class="strong">SLO_listorder</span>
<DD>
<pre>
|- ∀V. StrongLinearOrder V ⇒ StrongLinearOrder (listorder V)
</pre>

<DT><span class="strong">TO_ListOrd</span>
<DD>
<pre>
|- ∀c. TotOrd (ListOrd c)
</pre>

<DT><span class="strong">ListOrd_THM</span>
<DD>
<pre>
|- ∀c.
     (ListOrd c [] [] = Equal) ∧ (∀b y. ListOrd c [] (b::y) = Less) ∧
     (∀a x. ListOrd c (a::x) [] = Greater) ∧
     ∀a x b y.
       ListOrd c (a::x) (b::y) =
       case apto c a b of
         Less => Less
       | Equal => ListOrd c x y
       | Greater => Greater
</pre>

<DT><span class="strong">aplistoto</span>
<DD>
<pre>
|- ∀c.
     (apto (listoto c) [] [] = Equal) ∧
     (∀b y. apto (listoto c) [] (b::y) = Less) ∧
     (∀a x. apto (listoto c) (a::x) [] = Greater) ∧
     ∀a x b y.
       apto (listoto c) (a::x) (b::y) =
       case apto c a b of
         Less => Less
       | Equal => apto (listoto c) x y
       | Greater => Greater
</pre>

<DT><span class="strong">TO_injection</span>
<DD>
<pre>
|- ∀cp. TotOrd cp ⇒ ∀f. ONE_ONE f ⇒ TotOrd (imageOrd f cp)
</pre>

</DL>



<hr>
</body>
</html>
