<!DOCTYPE HTML PUBLIC "-//W32//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML>
<HEAD>
<meta http-equiv="content-type" content="text/html ; charset=US-ASCII">
<TITLE>proofManagerLib.expand</TITLE>
<LINK REL = "STYLESHEET" HREF = "../doc.css" TYPE = "text/css"></HEAD>
<BODY>

<DIV class = "TYPE"><PRE>expand : tactic -&gt; proof</PRE></DIV>

<DL>
<DT><SPAN class = "FIELD-NAME">STRUCTURE</SPAN></DT>
<DD><DIV class = "FIELD-BODY"><A HREF = "../../src-sml/htmlsigs/proofManagerLib.html">proofManagerLib</A></DIV></DD>
<DT><SPAN class = "FIELD-NAME">SYNOPSIS</SPAN></DT>
<DD><DIV class = "FIELD-BODY"><SPAN class = "TEXT">Applies a tactic to the current goal, stacking the resulting subgoals.</SPAN></DIV></DD>
<DT><SPAN class = "FIELD-NAME">DESCRIPTION</SPAN></DT>
<DD><DIV class = "FIELD-BODY"><SPAN class = "TEXT">The function </SPAN><SPAN class = "BRKT">expand</SPAN><SPAN class = "TEXT"> is part of the subgoal package.  It may be abbreviated by
the function </SPAN><SPAN class = "BRKT">e</SPAN><SPAN class = "TEXT">.  It applies a tactic to the current goal to give a new proof
state. The previous state is stored on the backup list. If the tactic produces
subgoals, the new proof state is formed from the old one by removing the
current goal from the goal stack and adding a new level consisting of its
subgoals. The corresponding justification is placed on the justification stack.
The new subgoals are printed. If more than one subgoal is produced, they are
printed from the bottom of the stack so that the new current goal is  printed
last.</SPAN>
<P>
<SPAN class = "TEXT">If a tactic solves the current goal (returns an empty subgoal list), then its
justification is used to prove a corresponding theorem. This theorem is
incorporated into the justification of the parent goal and printed. If the
subgoal was the last subgoal of the level, the level is removed and the parent
goal is proved using  its (new) justification. This process is repeated until a
level with unproven subgoals is reached. The next goal on the goal stack then
becomes the current goal. This goal is printed. If all the subgoals are proved,
the resulting proof state consists of the theorem proved by the justifications.</SPAN>
<P>
<SPAN class = "TEXT">The tactic applied is a validating version of the tactic given. It ensures that
the justification of the tactic does provide a proof of the goal from the
subgoals generated by the tactic. It will cause failure if this is not so. The
tactical </SPAN><SPAN class = "BRKT">VALID</SPAN><SPAN class = "TEXT"> performs this validation.</SPAN>
<P>
<SPAN class = "TEXT">For a description of the subgoal package, see  </SPAN><SPAN class = "BRKT">set_goal</SPAN><SPAN class = "TEXT">.</SPAN></DIV></DD>
<DT><SPAN class = "FIELD-NAME">FAILURE</SPAN></DT>
<DD><DIV class = "FIELD-BODY"><SPAN class = "TEXT"></SPAN><SPAN class = "BRKT">expand&nbsp;tac</SPAN><SPAN class = "TEXT"> fails if the tactic </SPAN><SPAN class = "BRKT">tac</SPAN><SPAN class = "TEXT"> fails for the top goal. It will diverge
if the tactic diverges for the goal. It will fail if there are no unproven
goals. This could be because no goal has been set using </SPAN><SPAN class = "BRKT">set_goal</SPAN><SPAN class = "TEXT"> or because
the last goal set has been completely proved. It will also fail in cases when
the tactic is invalid.</SPAN></DIV></DD>
<DT><SPAN class = "FIELD-NAME">EXAMPLE</SPAN></DT>
<DD><DIV class = "FIELD-BODY"><SPAN class = "TEXT"></SPAN><DIV class = "XMPL"><pre>
- expand CONJ_TAC;
- expand CONJ_TAC;
OK..
NO_PROOFS! Uncaught exception:
! NO_PROOFS

- g `(HD[1;2;3] = 1) /\ (TL[1;2;3] = [2;3])`;
&gt; val it =
    Proof manager status: 1 proof.
    1. Incomplete:
         Initial goal:
         (HD [1; 2; 3] = 1) /\ (TL [1; 2; 3] = [2; 3])

     : proofs

- expand CONJ_TAC;
OK..
2 subgoals:
&gt; val it =
    TL [1; 2; 3] = [2; 3]


    HD [1; 2; 3] = 1

     : proof

- expand (REWRITE_TAC[listTheory.HD]);
OK..

Goal proved.
|- HD [1; 2; 3] = 1

Remaining subgoals:
&gt; val it =
    TL [1; 2; 3] = [2; 3]

     : proof

- expand (REWRITE_TAC[listTheory.TL]);
OK..

Goal proved.
|- TL [1; 2; 3] = [2; 3]
&gt; val it =
    Initial goal proved.
    |- (HD [1; 2; 3] = 1) /\ (TL [1; 2; 3] = [2; 3]) : proof
</pre></DIV>
<SPAN class = "TEXT">
In the following example an invalid tactic is used. It is invalid
because it assumes something that is not on the assumption list of the goal.
The justification adds this assumption to the assumption list so the
justification would not prove the goal that was set.
</SPAN><DIV class = "XMPL"><pre>
- g `1=2`;
&gt; val it =
    Proof manager status: 2 proofs.
    2. Completed: |- (HD [1; 2; 3] = 1) /\ (TL [1; 2; 3] = [2; 3])
    1. Incomplete:
         Initial goal:
         1 = 2

     : proofs
- expand (REWRITE_TAC[ASSUME (Term `1=2`)]);
OK..

Exception raised at Tactical.VALID:
Invalid tactic
! Uncaught exception:
! HOL_ERR
</pre></DIV>
<SPAN class = "TEXT"></SPAN>
<P>
<SPAN class = "TEXT">Note that an invalid tactic may "succeed".
Thus, where </SPAN><SPAN class = "BRKT">tac1</SPAN><SPAN class = "TEXT"> is invalid, and </SPAN><SPAN class = "BRKT">tac2</SPAN><SPAN class = "TEXT"> is valid (and both succeed),
</SPAN><SPAN class = "BRKT">FIRST&nbsp;[tac1,&nbsp;tac2]</SPAN><SPAN class = "TEXT"> is invalid.  For example, where
theorem </SPAN><SPAN class = "BRKT">uth</SPAN><SPAN class = "TEXT"> is </SPAN><SPAN class = "BRKT">[p]&nbsp;|-&nbsp;q</SPAN><SPAN class = "TEXT"> and </SPAN><SPAN class = "BRKT">uth'</SPAN><SPAN class = "TEXT"> is </SPAN><SPAN class = "BRKT">[p']&nbsp;|-&nbsp;q</SPAN><SPAN class = "TEXT"></SPAN>
<P>
<SPAN class = "TEXT"></SPAN><DIV class = "XMPL"><pre>
1 subgoal:
val it =

q
------------------------------------
  p
:
   proof

&gt; e (FIRST (map ACCEPT_TAC [uth', uth])) ;
OK..

Exception raised at Tactical.VALID:
Invalid tactic [...]

&gt; e (FIRST (map (VALID o ACCEPT_TAC) [uth', uth])) ;
OK..

Goal proved.
 [p] |- q
</pre></DIV>
</DIV></DD>
<DT><SPAN class = "FIELD-NAME">USES</SPAN></DT>
<DD><DIV class = "FIELD-BODY"><SPAN class = "TEXT">Doing a step in an interactive goal-directed proof.</SPAN></DIV></DD>
<dt><span class = "FIELD-NAME">SEEALSO</span></dt>
<dd><div class = "FIELD-BODY"><A HREF = "proofManagerLib.set_goal.html">set_goal</A>,
<A HREF = "proofManagerLib.restart.html">restart</A>,
<A HREF = "proofManagerLib.backup.html">backup</A>,
<A HREF = "proofManagerLib.restore.html">restore</A>,
<A HREF = "proofManagerLib.save.html">save</A>,
<A HREF = "proofManagerLib.set_backup.html">set_backup</A>,
<A HREF = "proofManagerLib.expand.html">expand</A>,
<A HREF = "proofManagerLib.expandf.html">expandf</A>,
<A HREF = "proofManagerLib.flatn.html">flatn</A>,
<A HREF = "proofManagerLib.p.html">p</A>,
<A HREF = "proofManagerLib.top_thm.html">top_thm</A>,
<A HREF = "proofManagerLib.top_goal.html">top_goal</A>,
<A HREF = "Tactical.VALID.html">VALID</A>,
<A HREF = "Tactical.VALIDATE.html">VALIDATE</A></div></dd>
</DL>

<div class = "HOL"><A HREF="http://hol.sourceforge.net">HOL</A>&nbsp;&nbsp;Kananaskis-11</div></BODY></HTML>
